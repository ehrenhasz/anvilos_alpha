{
  "module_name": "atmel_hlcdc_plane.c",
  "hash_id": "130b3566ec704fa2774f1cd18df7e2a60997c2fed0c3618576a17a4d697973b4",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/atmel-hlcdc/atmel_hlcdc_plane.c",
  "human_readable_source": "\n \n\n#include <linux/dmapool.h>\n#include <linux/mfd/atmel-hlcdc.h>\n\n#include <drm/drm_atomic.h>\n#include <drm/drm_atomic_helper.h>\n#include <drm/drm_blend.h>\n#include <drm/drm_fb_dma_helper.h>\n#include <drm/drm_fourcc.h>\n#include <drm/drm_framebuffer.h>\n#include <drm/drm_gem_dma_helper.h>\n\n#include \"atmel_hlcdc_dc.h\"\n\n \nstruct atmel_hlcdc_plane_state {\n\tstruct drm_plane_state base;\n\tint crtc_x;\n\tint crtc_y;\n\tunsigned int crtc_w;\n\tunsigned int crtc_h;\n\tuint32_t src_x;\n\tuint32_t src_y;\n\tuint32_t src_w;\n\tuint32_t src_h;\n\n\tint disc_x;\n\tint disc_y;\n\tint disc_w;\n\tint disc_h;\n\n\tint ahb_id;\n\n\t \n\tint bpp[ATMEL_HLCDC_LAYER_MAX_PLANES];\n\tunsigned int offsets[ATMEL_HLCDC_LAYER_MAX_PLANES];\n\tint xstride[ATMEL_HLCDC_LAYER_MAX_PLANES];\n\tint pstride[ATMEL_HLCDC_LAYER_MAX_PLANES];\n\tint nplanes;\n\n\t \n\tstruct atmel_hlcdc_dma_channel_dscr *dscrs[ATMEL_HLCDC_LAYER_MAX_PLANES];\n};\n\nstatic inline struct atmel_hlcdc_plane_state *\ndrm_plane_state_to_atmel_hlcdc_plane_state(struct drm_plane_state *s)\n{\n\treturn container_of(s, struct atmel_hlcdc_plane_state, base);\n}\n\n#define SUBPIXEL_MASK\t\t\t0xffff\n\nstatic uint32_t rgb_formats[] = {\n\tDRM_FORMAT_C8,\n\tDRM_FORMAT_XRGB4444,\n\tDRM_FORMAT_ARGB4444,\n\tDRM_FORMAT_RGBA4444,\n\tDRM_FORMAT_ARGB1555,\n\tDRM_FORMAT_RGB565,\n\tDRM_FORMAT_RGB888,\n\tDRM_FORMAT_XRGB8888,\n\tDRM_FORMAT_ARGB8888,\n\tDRM_FORMAT_RGBA8888,\n};\n\nstruct atmel_hlcdc_formats atmel_hlcdc_plane_rgb_formats = {\n\t.formats = rgb_formats,\n\t.nformats = ARRAY_SIZE(rgb_formats),\n};\n\nstatic uint32_t rgb_and_yuv_formats[] = {\n\tDRM_FORMAT_C8,\n\tDRM_FORMAT_XRGB4444,\n\tDRM_FORMAT_ARGB4444,\n\tDRM_FORMAT_RGBA4444,\n\tDRM_FORMAT_ARGB1555,\n\tDRM_FORMAT_RGB565,\n\tDRM_FORMAT_RGB888,\n\tDRM_FORMAT_XRGB8888,\n\tDRM_FORMAT_ARGB8888,\n\tDRM_FORMAT_RGBA8888,\n\tDRM_FORMAT_AYUV,\n\tDRM_FORMAT_YUYV,\n\tDRM_FORMAT_UYVY,\n\tDRM_FORMAT_YVYU,\n\tDRM_FORMAT_VYUY,\n\tDRM_FORMAT_NV21,\n\tDRM_FORMAT_NV61,\n\tDRM_FORMAT_YUV422,\n\tDRM_FORMAT_YUV420,\n};\n\nstruct atmel_hlcdc_formats atmel_hlcdc_plane_rgb_and_yuv_formats = {\n\t.formats = rgb_and_yuv_formats,\n\t.nformats = ARRAY_SIZE(rgb_and_yuv_formats),\n};\n\nstatic int atmel_hlcdc_format_to_plane_mode(u32 format, u32 *mode)\n{\n\tswitch (format) {\n\tcase DRM_FORMAT_C8:\n\t\t*mode = ATMEL_HLCDC_C8_MODE;\n\t\tbreak;\n\tcase DRM_FORMAT_XRGB4444:\n\t\t*mode = ATMEL_HLCDC_XRGB4444_MODE;\n\t\tbreak;\n\tcase DRM_FORMAT_ARGB4444:\n\t\t*mode = ATMEL_HLCDC_ARGB4444_MODE;\n\t\tbreak;\n\tcase DRM_FORMAT_RGBA4444:\n\t\t*mode = ATMEL_HLCDC_RGBA4444_MODE;\n\t\tbreak;\n\tcase DRM_FORMAT_RGB565:\n\t\t*mode = ATMEL_HLCDC_RGB565_MODE;\n\t\tbreak;\n\tcase DRM_FORMAT_RGB888:\n\t\t*mode = ATMEL_HLCDC_RGB888_MODE;\n\t\tbreak;\n\tcase DRM_FORMAT_ARGB1555:\n\t\t*mode = ATMEL_HLCDC_ARGB1555_MODE;\n\t\tbreak;\n\tcase DRM_FORMAT_XRGB8888:\n\t\t*mode = ATMEL_HLCDC_XRGB8888_MODE;\n\t\tbreak;\n\tcase DRM_FORMAT_ARGB8888:\n\t\t*mode = ATMEL_HLCDC_ARGB8888_MODE;\n\t\tbreak;\n\tcase DRM_FORMAT_RGBA8888:\n\t\t*mode = ATMEL_HLCDC_RGBA8888_MODE;\n\t\tbreak;\n\tcase DRM_FORMAT_AYUV:\n\t\t*mode = ATMEL_HLCDC_AYUV_MODE;\n\t\tbreak;\n\tcase DRM_FORMAT_YUYV:\n\t\t*mode = ATMEL_HLCDC_YUYV_MODE;\n\t\tbreak;\n\tcase DRM_FORMAT_UYVY:\n\t\t*mode = ATMEL_HLCDC_UYVY_MODE;\n\t\tbreak;\n\tcase DRM_FORMAT_YVYU:\n\t\t*mode = ATMEL_HLCDC_YVYU_MODE;\n\t\tbreak;\n\tcase DRM_FORMAT_VYUY:\n\t\t*mode = ATMEL_HLCDC_VYUY_MODE;\n\t\tbreak;\n\tcase DRM_FORMAT_NV21:\n\t\t*mode = ATMEL_HLCDC_NV21_MODE;\n\t\tbreak;\n\tcase DRM_FORMAT_NV61:\n\t\t*mode = ATMEL_HLCDC_NV61_MODE;\n\t\tbreak;\n\tcase DRM_FORMAT_YUV420:\n\t\t*mode = ATMEL_HLCDC_YUV420_MODE;\n\t\tbreak;\n\tcase DRM_FORMAT_YUV422:\n\t\t*mode = ATMEL_HLCDC_YUV422_MODE;\n\t\tbreak;\n\tdefault:\n\t\treturn -ENOTSUPP;\n\t}\n\n\treturn 0;\n}\n\nstatic u32 heo_downscaling_xcoef[] = {\n\t0x11343311,\n\t0x000000f7,\n\t0x1635300c,\n\t0x000000f9,\n\t0x1b362c08,\n\t0x000000fb,\n\t0x1f372804,\n\t0x000000fe,\n\t0x24382400,\n\t0x00000000,\n\t0x28371ffe,\n\t0x00000004,\n\t0x2c361bfb,\n\t0x00000008,\n\t0x303516f9,\n\t0x0000000c,\n};\n\nstatic u32 heo_downscaling_ycoef[] = {\n\t0x00123737,\n\t0x00173732,\n\t0x001b382d,\n\t0x001f3928,\n\t0x00243824,\n\t0x0028391f,\n\t0x002d381b,\n\t0x00323717,\n};\n\nstatic u32 heo_upscaling_xcoef[] = {\n\t0xf74949f7,\n\t0x00000000,\n\t0xf55f33fb,\n\t0x000000fe,\n\t0xf5701efe,\n\t0x000000ff,\n\t0xf87c0dff,\n\t0x00000000,\n\t0x00800000,\n\t0x00000000,\n\t0x0d7cf800,\n\t0x000000ff,\n\t0x1e70f5ff,\n\t0x000000fe,\n\t0x335ff5fe,\n\t0x000000fb,\n};\n\nstatic u32 heo_upscaling_ycoef[] = {\n\t0x00004040,\n\t0x00075920,\n\t0x00056f0c,\n\t0x00027b03,\n\t0x00008000,\n\t0x00037b02,\n\t0x000c6f05,\n\t0x00205907,\n};\n\n#define ATMEL_HLCDC_XPHIDEF\t4\n#define ATMEL_HLCDC_YPHIDEF\t4\n\nstatic u32 atmel_hlcdc_plane_phiscaler_get_factor(u32 srcsize,\n\t\t\t\t\t\t  u32 dstsize,\n\t\t\t\t\t\t  u32 phidef)\n{\n\tu32 factor, max_memsize;\n\n\tfactor = (256 * ((8 * (srcsize - 1)) - phidef)) / (dstsize - 1);\n\tmax_memsize = ((factor * (dstsize - 1)) + (256 * phidef)) / 2048;\n\n\tif (max_memsize > srcsize - 1)\n\t\tfactor--;\n\n\treturn factor;\n}\n\nstatic void\natmel_hlcdc_plane_scaler_set_phicoeff(struct atmel_hlcdc_plane *plane,\n\t\t\t\t      const u32 *coeff_tab, int size,\n\t\t\t\t      unsigned int cfg_offs)\n{\n\tint i;\n\n\tfor (i = 0; i < size; i++)\n\t\tatmel_hlcdc_layer_write_cfg(&plane->layer, cfg_offs + i,\n\t\t\t\t\t    coeff_tab[i]);\n}\n\nstatic void atmel_hlcdc_plane_setup_scaler(struct atmel_hlcdc_plane *plane,\n\t\t\t\t\t   struct atmel_hlcdc_plane_state *state)\n{\n\tconst struct atmel_hlcdc_layer_desc *desc = plane->layer.desc;\n\tu32 xfactor, yfactor;\n\n\tif (!desc->layout.scaler_config)\n\t\treturn;\n\n\tif (state->crtc_w == state->src_w && state->crtc_h == state->src_h) {\n\t\tatmel_hlcdc_layer_write_cfg(&plane->layer,\n\t\t\t\t\t    desc->layout.scaler_config, 0);\n\t\treturn;\n\t}\n\n\tif (desc->layout.phicoeffs.x) {\n\t\txfactor = atmel_hlcdc_plane_phiscaler_get_factor(state->src_w,\n\t\t\t\t\t\t\tstate->crtc_w,\n\t\t\t\t\t\t\tATMEL_HLCDC_XPHIDEF);\n\n\t\tyfactor = atmel_hlcdc_plane_phiscaler_get_factor(state->src_h,\n\t\t\t\t\t\t\tstate->crtc_h,\n\t\t\t\t\t\t\tATMEL_HLCDC_YPHIDEF);\n\n\t\tatmel_hlcdc_plane_scaler_set_phicoeff(plane,\n\t\t\t\tstate->crtc_w < state->src_w ?\n\t\t\t\theo_downscaling_xcoef :\n\t\t\t\theo_upscaling_xcoef,\n\t\t\t\tARRAY_SIZE(heo_upscaling_xcoef),\n\t\t\t\tdesc->layout.phicoeffs.x);\n\n\t\tatmel_hlcdc_plane_scaler_set_phicoeff(plane,\n\t\t\t\tstate->crtc_h < state->src_h ?\n\t\t\t\theo_downscaling_ycoef :\n\t\t\t\theo_upscaling_ycoef,\n\t\t\t\tARRAY_SIZE(heo_upscaling_ycoef),\n\t\t\t\tdesc->layout.phicoeffs.y);\n\t} else {\n\t\txfactor = (1024 * state->src_w) / state->crtc_w;\n\t\tyfactor = (1024 * state->src_h) / state->crtc_h;\n\t}\n\n\tatmel_hlcdc_layer_write_cfg(&plane->layer, desc->layout.scaler_config,\n\t\t\t\t    ATMEL_HLCDC_LAYER_SCALER_ENABLE |\n\t\t\t\t    ATMEL_HLCDC_LAYER_SCALER_FACTORS(xfactor,\n\t\t\t\t\t\t\t\t     yfactor));\n}\n\nstatic void\natmel_hlcdc_plane_update_pos_and_size(struct atmel_hlcdc_plane *plane,\n\t\t\t\t      struct atmel_hlcdc_plane_state *state)\n{\n\tconst struct atmel_hlcdc_layer_desc *desc = plane->layer.desc;\n\n\tif (desc->layout.size)\n\t\tatmel_hlcdc_layer_write_cfg(&plane->layer, desc->layout.size,\n\t\t\t\t\tATMEL_HLCDC_LAYER_SIZE(state->crtc_w,\n\t\t\t\t\t\t\t       state->crtc_h));\n\n\tif (desc->layout.memsize)\n\t\tatmel_hlcdc_layer_write_cfg(&plane->layer,\n\t\t\t\t\tdesc->layout.memsize,\n\t\t\t\t\tATMEL_HLCDC_LAYER_SIZE(state->src_w,\n\t\t\t\t\t\t\t       state->src_h));\n\n\tif (desc->layout.pos)\n\t\tatmel_hlcdc_layer_write_cfg(&plane->layer, desc->layout.pos,\n\t\t\t\t\tATMEL_HLCDC_LAYER_POS(state->crtc_x,\n\t\t\t\t\t\t\t      state->crtc_y));\n\n\tatmel_hlcdc_plane_setup_scaler(plane, state);\n}\n\nstatic void\natmel_hlcdc_plane_update_general_settings(struct atmel_hlcdc_plane *plane,\n\t\t\t\t\tstruct atmel_hlcdc_plane_state *state)\n{\n\tunsigned int cfg = ATMEL_HLCDC_LAYER_DMA_BLEN_INCR16 | state->ahb_id;\n\tconst struct atmel_hlcdc_layer_desc *desc = plane->layer.desc;\n\tconst struct drm_format_info *format = state->base.fb->format;\n\n\t \n\tif (format->format == DRM_FORMAT_RGB888)\n\t\tcfg |= ATMEL_HLCDC_LAYER_DMA_ROTDIS;\n\n\tatmel_hlcdc_layer_write_cfg(&plane->layer, ATMEL_HLCDC_LAYER_DMA_CFG,\n\t\t\t\t    cfg);\n\n\tcfg = ATMEL_HLCDC_LAYER_DMA | ATMEL_HLCDC_LAYER_REP;\n\n\tif (plane->base.type != DRM_PLANE_TYPE_PRIMARY) {\n\t\tcfg |= ATMEL_HLCDC_LAYER_OVR | ATMEL_HLCDC_LAYER_ITER2BL |\n\t\t       ATMEL_HLCDC_LAYER_ITER;\n\n\t\tif (format->has_alpha)\n\t\t\tcfg |= ATMEL_HLCDC_LAYER_LAEN;\n\t\telse\n\t\t\tcfg |= ATMEL_HLCDC_LAYER_GAEN |\n\t\t\t       ATMEL_HLCDC_LAYER_GA(state->base.alpha);\n\t}\n\n\tif (state->disc_h && state->disc_w)\n\t\tcfg |= ATMEL_HLCDC_LAYER_DISCEN;\n\n\tatmel_hlcdc_layer_write_cfg(&plane->layer, desc->layout.general_config,\n\t\t\t\t    cfg);\n}\n\nstatic void atmel_hlcdc_plane_update_format(struct atmel_hlcdc_plane *plane,\n\t\t\t\t\tstruct atmel_hlcdc_plane_state *state)\n{\n\tu32 cfg;\n\tint ret;\n\n\tret = atmel_hlcdc_format_to_plane_mode(state->base.fb->format->format,\n\t\t\t\t\t       &cfg);\n\tif (ret)\n\t\treturn;\n\n\tif ((state->base.fb->format->format == DRM_FORMAT_YUV422 ||\n\t     state->base.fb->format->format == DRM_FORMAT_NV61) &&\n\t    drm_rotation_90_or_270(state->base.rotation))\n\t\tcfg |= ATMEL_HLCDC_YUV422ROT;\n\n\tatmel_hlcdc_layer_write_cfg(&plane->layer,\n\t\t\t\t    ATMEL_HLCDC_LAYER_FORMAT_CFG, cfg);\n}\n\nstatic void atmel_hlcdc_plane_update_clut(struct atmel_hlcdc_plane *plane,\n\t\t\t\t\t  struct atmel_hlcdc_plane_state *state)\n{\n\tstruct drm_crtc *crtc = state->base.crtc;\n\tstruct drm_color_lut *lut;\n\tint idx;\n\n\tif (!crtc || !crtc->state)\n\t\treturn;\n\n\tif (!crtc->state->color_mgmt_changed || !crtc->state->gamma_lut)\n\t\treturn;\n\n\tlut = (struct drm_color_lut *)crtc->state->gamma_lut->data;\n\n\tfor (idx = 0; idx < ATMEL_HLCDC_CLUT_SIZE; idx++, lut++) {\n\t\tu32 val = ((lut->red << 8) & 0xff0000) |\n\t\t\t(lut->green & 0xff00) |\n\t\t\t(lut->blue >> 8);\n\n\t\tatmel_hlcdc_layer_write_clut(&plane->layer, idx, val);\n\t}\n}\n\nstatic void atmel_hlcdc_plane_update_buffers(struct atmel_hlcdc_plane *plane,\n\t\t\t\t\tstruct atmel_hlcdc_plane_state *state)\n{\n\tconst struct atmel_hlcdc_layer_desc *desc = plane->layer.desc;\n\tstruct drm_framebuffer *fb = state->base.fb;\n\tu32 sr;\n\tint i;\n\n\tsr = atmel_hlcdc_layer_read_reg(&plane->layer, ATMEL_HLCDC_LAYER_CHSR);\n\n\tfor (i = 0; i < state->nplanes; i++) {\n\t\tstruct drm_gem_dma_object *gem = drm_fb_dma_get_gem_obj(fb, i);\n\n\t\tstate->dscrs[i]->addr = gem->dma_addr + state->offsets[i];\n\n\t\tatmel_hlcdc_layer_write_reg(&plane->layer,\n\t\t\t\t\t    ATMEL_HLCDC_LAYER_PLANE_HEAD(i),\n\t\t\t\t\t    state->dscrs[i]->self);\n\n\t\tif (!(sr & ATMEL_HLCDC_LAYER_EN)) {\n\t\t\tatmel_hlcdc_layer_write_reg(&plane->layer,\n\t\t\t\t\tATMEL_HLCDC_LAYER_PLANE_ADDR(i),\n\t\t\t\t\tstate->dscrs[i]->addr);\n\t\t\tatmel_hlcdc_layer_write_reg(&plane->layer,\n\t\t\t\t\tATMEL_HLCDC_LAYER_PLANE_CTRL(i),\n\t\t\t\t\tstate->dscrs[i]->ctrl);\n\t\t\tatmel_hlcdc_layer_write_reg(&plane->layer,\n\t\t\t\t\tATMEL_HLCDC_LAYER_PLANE_NEXT(i),\n\t\t\t\t\tstate->dscrs[i]->self);\n\t\t}\n\n\t\tif (desc->layout.xstride[i])\n\t\t\tatmel_hlcdc_layer_write_cfg(&plane->layer,\n\t\t\t\t\t\t    desc->layout.xstride[i],\n\t\t\t\t\t\t    state->xstride[i]);\n\n\t\tif (desc->layout.pstride[i])\n\t\t\tatmel_hlcdc_layer_write_cfg(&plane->layer,\n\t\t\t\t\t\t    desc->layout.pstride[i],\n\t\t\t\t\t\t    state->pstride[i]);\n\t}\n}\n\nint atmel_hlcdc_plane_prepare_ahb_routing(struct drm_crtc_state *c_state)\n{\n\tunsigned int ahb_load[2] = { };\n\tstruct drm_plane *plane;\n\n\tdrm_atomic_crtc_state_for_each_plane(plane, c_state) {\n\t\tstruct atmel_hlcdc_plane_state *plane_state;\n\t\tstruct drm_plane_state *plane_s;\n\t\tunsigned int pixels, load = 0;\n\t\tint i;\n\n\t\tplane_s = drm_atomic_get_plane_state(c_state->state, plane);\n\t\tif (IS_ERR(plane_s))\n\t\t\treturn PTR_ERR(plane_s);\n\n\t\tplane_state =\n\t\t\tdrm_plane_state_to_atmel_hlcdc_plane_state(plane_s);\n\n\t\tpixels = (plane_state->src_w * plane_state->src_h) -\n\t\t\t (plane_state->disc_w * plane_state->disc_h);\n\n\t\tfor (i = 0; i < plane_state->nplanes; i++)\n\t\t\tload += pixels * plane_state->bpp[i];\n\n\t\tif (ahb_load[0] <= ahb_load[1])\n\t\t\tplane_state->ahb_id = 0;\n\t\telse\n\t\t\tplane_state->ahb_id = 1;\n\n\t\tahb_load[plane_state->ahb_id] += load;\n\t}\n\n\treturn 0;\n}\n\nint\natmel_hlcdc_plane_prepare_disc_area(struct drm_crtc_state *c_state)\n{\n\tint disc_x = 0, disc_y = 0, disc_w = 0, disc_h = 0;\n\tconst struct atmel_hlcdc_layer_cfg_layout *layout;\n\tstruct atmel_hlcdc_plane_state *primary_state;\n\tstruct drm_plane_state *primary_s;\n\tstruct atmel_hlcdc_plane *primary;\n\tstruct drm_plane *ovl;\n\n\tprimary = drm_plane_to_atmel_hlcdc_plane(c_state->crtc->primary);\n\tlayout = &primary->layer.desc->layout;\n\tif (!layout->disc_pos || !layout->disc_size)\n\t\treturn 0;\n\n\tprimary_s = drm_atomic_get_plane_state(c_state->state,\n\t\t\t\t\t       &primary->base);\n\tif (IS_ERR(primary_s))\n\t\treturn PTR_ERR(primary_s);\n\n\tprimary_state = drm_plane_state_to_atmel_hlcdc_plane_state(primary_s);\n\n\tdrm_atomic_crtc_state_for_each_plane(ovl, c_state) {\n\t\tstruct atmel_hlcdc_plane_state *ovl_state;\n\t\tstruct drm_plane_state *ovl_s;\n\n\t\tif (ovl == c_state->crtc->primary)\n\t\t\tcontinue;\n\n\t\tovl_s = drm_atomic_get_plane_state(c_state->state, ovl);\n\t\tif (IS_ERR(ovl_s))\n\t\t\treturn PTR_ERR(ovl_s);\n\n\t\tovl_state = drm_plane_state_to_atmel_hlcdc_plane_state(ovl_s);\n\n\t\tif (!ovl_s->visible ||\n\t\t    !ovl_s->fb ||\n\t\t    ovl_s->fb->format->has_alpha ||\n\t\t    ovl_s->alpha != DRM_BLEND_ALPHA_OPAQUE)\n\t\t\tcontinue;\n\n\t\t \n\t\tif (ovl_state->crtc_h * ovl_state->crtc_w < disc_h * disc_w)\n\t\t\tcontinue;\n\n\t\tdisc_x = ovl_state->crtc_x;\n\t\tdisc_y = ovl_state->crtc_y;\n\t\tdisc_h = ovl_state->crtc_h;\n\t\tdisc_w = ovl_state->crtc_w;\n\t}\n\n\tprimary_state->disc_x = disc_x;\n\tprimary_state->disc_y = disc_y;\n\tprimary_state->disc_w = disc_w;\n\tprimary_state->disc_h = disc_h;\n\n\treturn 0;\n}\n\nstatic void\natmel_hlcdc_plane_update_disc_area(struct atmel_hlcdc_plane *plane,\n\t\t\t\t   struct atmel_hlcdc_plane_state *state)\n{\n\tconst struct atmel_hlcdc_layer_cfg_layout *layout;\n\n\tlayout = &plane->layer.desc->layout;\n\tif (!layout->disc_pos || !layout->disc_size)\n\t\treturn;\n\n\tatmel_hlcdc_layer_write_cfg(&plane->layer, layout->disc_pos,\n\t\t\t\tATMEL_HLCDC_LAYER_DISC_POS(state->disc_x,\n\t\t\t\t\t\t\t   state->disc_y));\n\n\tatmel_hlcdc_layer_write_cfg(&plane->layer, layout->disc_size,\n\t\t\t\tATMEL_HLCDC_LAYER_DISC_SIZE(state->disc_w,\n\t\t\t\t\t\t\t    state->disc_h));\n}\n\nstatic int atmel_hlcdc_plane_atomic_check(struct drm_plane *p,\n\t\t\t\t\t  struct drm_atomic_state *state)\n{\n\tstruct drm_plane_state *s = drm_atomic_get_new_plane_state(state, p);\n\tstruct atmel_hlcdc_plane *plane = drm_plane_to_atmel_hlcdc_plane(p);\n\tstruct atmel_hlcdc_plane_state *hstate =\n\t\t\t\tdrm_plane_state_to_atmel_hlcdc_plane_state(s);\n\tconst struct atmel_hlcdc_layer_desc *desc = plane->layer.desc;\n\tstruct drm_framebuffer *fb = hstate->base.fb;\n\tconst struct drm_display_mode *mode;\n\tstruct drm_crtc_state *crtc_state;\n\tint ret;\n\tint i;\n\n\tif (!hstate->base.crtc || WARN_ON(!fb))\n\t\treturn 0;\n\n\tcrtc_state = drm_atomic_get_existing_crtc_state(state, s->crtc);\n\tmode = &crtc_state->adjusted_mode;\n\n\tret = drm_atomic_helper_check_plane_state(s, crtc_state,\n\t\t\t\t\t\t  (1 << 16) / 2048,\n\t\t\t\t\t\t  INT_MAX, true, true);\n\tif (ret || !s->visible)\n\t\treturn ret;\n\n\thstate->src_x = s->src.x1;\n\thstate->src_y = s->src.y1;\n\thstate->src_w = drm_rect_width(&s->src);\n\thstate->src_h = drm_rect_height(&s->src);\n\thstate->crtc_x = s->dst.x1;\n\thstate->crtc_y = s->dst.y1;\n\thstate->crtc_w = drm_rect_width(&s->dst);\n\thstate->crtc_h = drm_rect_height(&s->dst);\n\n\tif ((hstate->src_x | hstate->src_y | hstate->src_w | hstate->src_h) &\n\t    SUBPIXEL_MASK)\n\t\treturn -EINVAL;\n\n\thstate->src_x >>= 16;\n\thstate->src_y >>= 16;\n\thstate->src_w >>= 16;\n\thstate->src_h >>= 16;\n\n\thstate->nplanes = fb->format->num_planes;\n\tif (hstate->nplanes > ATMEL_HLCDC_LAYER_MAX_PLANES)\n\t\treturn -EINVAL;\n\n\tfor (i = 0; i < hstate->nplanes; i++) {\n\t\tunsigned int offset = 0;\n\t\tint xdiv = i ? fb->format->hsub : 1;\n\t\tint ydiv = i ? fb->format->vsub : 1;\n\n\t\thstate->bpp[i] = fb->format->cpp[i];\n\t\tif (!hstate->bpp[i])\n\t\t\treturn -EINVAL;\n\n\t\tswitch (hstate->base.rotation & DRM_MODE_ROTATE_MASK) {\n\t\tcase DRM_MODE_ROTATE_90:\n\t\t\toffset = (hstate->src_y / ydiv) *\n\t\t\t\t fb->pitches[i];\n\t\t\toffset += ((hstate->src_x + hstate->src_w - 1) /\n\t\t\t\t   xdiv) * hstate->bpp[i];\n\t\t\thstate->xstride[i] = -(((hstate->src_h - 1) / ydiv) *\n\t\t\t\t\t    fb->pitches[i]) -\n\t\t\t\t\t  (2 * hstate->bpp[i]);\n\t\t\thstate->pstride[i] = fb->pitches[i] - hstate->bpp[i];\n\t\t\tbreak;\n\t\tcase DRM_MODE_ROTATE_180:\n\t\t\toffset = ((hstate->src_y + hstate->src_h - 1) /\n\t\t\t\t  ydiv) * fb->pitches[i];\n\t\t\toffset += ((hstate->src_x + hstate->src_w - 1) /\n\t\t\t\t   xdiv) * hstate->bpp[i];\n\t\t\thstate->xstride[i] = ((((hstate->src_w - 1) / xdiv) - 1) *\n\t\t\t\t\t   hstate->bpp[i]) - fb->pitches[i];\n\t\t\thstate->pstride[i] = -2 * hstate->bpp[i];\n\t\t\tbreak;\n\t\tcase DRM_MODE_ROTATE_270:\n\t\t\toffset = ((hstate->src_y + hstate->src_h - 1) /\n\t\t\t\t  ydiv) * fb->pitches[i];\n\t\t\toffset += (hstate->src_x / xdiv) * hstate->bpp[i];\n\t\t\thstate->xstride[i] = ((hstate->src_h - 1) / ydiv) *\n\t\t\t\t\t  fb->pitches[i];\n\t\t\thstate->pstride[i] = -fb->pitches[i] - hstate->bpp[i];\n\t\t\tbreak;\n\t\tcase DRM_MODE_ROTATE_0:\n\t\tdefault:\n\t\t\toffset = (hstate->src_y / ydiv) * fb->pitches[i];\n\t\t\toffset += (hstate->src_x / xdiv) * hstate->bpp[i];\n\t\t\thstate->xstride[i] = fb->pitches[i] -\n\t\t\t\t\t  ((hstate->src_w / xdiv) *\n\t\t\t\t\t   hstate->bpp[i]);\n\t\t\thstate->pstride[i] = 0;\n\t\t\tbreak;\n\t\t}\n\n\t\thstate->offsets[i] = offset + fb->offsets[i];\n\t}\n\n\t \n\tif (drm_rotation_90_or_270(hstate->base.rotation)) {\n\t\tswap(hstate->src_w, hstate->src_h);\n\t}\n\n\tif (!desc->layout.size &&\n\t    (mode->hdisplay != hstate->crtc_w ||\n\t     mode->vdisplay != hstate->crtc_h))\n\t\treturn -EINVAL;\n\n\tif ((hstate->crtc_h != hstate->src_h || hstate->crtc_w != hstate->src_w) &&\n\t    (!desc->layout.memsize ||\n\t     hstate->base.fb->format->has_alpha))\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nstatic void atmel_hlcdc_plane_atomic_disable(struct drm_plane *p,\n\t\t\t\t\t     struct drm_atomic_state *state)\n{\n\tstruct atmel_hlcdc_plane *plane = drm_plane_to_atmel_hlcdc_plane(p);\n\n\t \n\tatmel_hlcdc_layer_write_reg(&plane->layer, ATMEL_HLCDC_LAYER_IDR,\n\t\t\t\t    0xffffffff);\n\n\t \n\tatmel_hlcdc_layer_write_reg(&plane->layer, ATMEL_HLCDC_LAYER_CHDR,\n\t\t\t\t    ATMEL_HLCDC_LAYER_RST |\n\t\t\t\t    ATMEL_HLCDC_LAYER_A2Q |\n\t\t\t\t    ATMEL_HLCDC_LAYER_UPDATE);\n\n\t \n\tatmel_hlcdc_layer_read_reg(&plane->layer, ATMEL_HLCDC_LAYER_ISR);\n}\n\nstatic void atmel_hlcdc_plane_atomic_update(struct drm_plane *p,\n\t\t\t\t\t    struct drm_atomic_state *state)\n{\n\tstruct drm_plane_state *new_s = drm_atomic_get_new_plane_state(state,\n\t\t\t\t\t\t\t\t       p);\n\tstruct atmel_hlcdc_plane *plane = drm_plane_to_atmel_hlcdc_plane(p);\n\tstruct atmel_hlcdc_plane_state *hstate =\n\t\t\tdrm_plane_state_to_atmel_hlcdc_plane_state(new_s);\n\tu32 sr;\n\n\tif (!new_s->crtc || !new_s->fb)\n\t\treturn;\n\n\tif (!hstate->base.visible) {\n\t\tatmel_hlcdc_plane_atomic_disable(p, state);\n\t\treturn;\n\t}\n\n\tatmel_hlcdc_plane_update_pos_and_size(plane, hstate);\n\tatmel_hlcdc_plane_update_general_settings(plane, hstate);\n\tatmel_hlcdc_plane_update_format(plane, hstate);\n\tatmel_hlcdc_plane_update_clut(plane, hstate);\n\tatmel_hlcdc_plane_update_buffers(plane, hstate);\n\tatmel_hlcdc_plane_update_disc_area(plane, hstate);\n\n\t \n\tatmel_hlcdc_layer_write_reg(&plane->layer, ATMEL_HLCDC_LAYER_IER,\n\t\t\t\t    ATMEL_HLCDC_LAYER_OVR_IRQ(0) |\n\t\t\t\t    ATMEL_HLCDC_LAYER_OVR_IRQ(1) |\n\t\t\t\t    ATMEL_HLCDC_LAYER_OVR_IRQ(2));\n\n\t \n\tsr = atmel_hlcdc_layer_read_reg(&plane->layer, ATMEL_HLCDC_LAYER_CHSR);\n\tatmel_hlcdc_layer_write_reg(&plane->layer, ATMEL_HLCDC_LAYER_CHER,\n\t\t\tATMEL_HLCDC_LAYER_UPDATE |\n\t\t\t(sr & ATMEL_HLCDC_LAYER_EN ?\n\t\t\t ATMEL_HLCDC_LAYER_A2Q : ATMEL_HLCDC_LAYER_EN));\n}\n\nstatic int atmel_hlcdc_plane_init_properties(struct atmel_hlcdc_plane *plane)\n{\n\tconst struct atmel_hlcdc_layer_desc *desc = plane->layer.desc;\n\n\tif (desc->type == ATMEL_HLCDC_OVERLAY_LAYER ||\n\t    desc->type == ATMEL_HLCDC_CURSOR_LAYER) {\n\t\tint ret;\n\n\t\tret = drm_plane_create_alpha_property(&plane->base);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tif (desc->layout.xstride[0] && desc->layout.pstride[0]) {\n\t\tint ret;\n\n\t\tret = drm_plane_create_rotation_property(&plane->base,\n\t\t\t\t\t\t\t DRM_MODE_ROTATE_0,\n\t\t\t\t\t\t\t DRM_MODE_ROTATE_0 |\n\t\t\t\t\t\t\t DRM_MODE_ROTATE_90 |\n\t\t\t\t\t\t\t DRM_MODE_ROTATE_180 |\n\t\t\t\t\t\t\t DRM_MODE_ROTATE_270);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tif (desc->layout.csc) {\n\t\t \n\t\tatmel_hlcdc_layer_write_cfg(&plane->layer,\n\t\t\t\t\t    desc->layout.csc,\n\t\t\t\t\t    0x4c900091);\n\t\tatmel_hlcdc_layer_write_cfg(&plane->layer,\n\t\t\t\t\t    desc->layout.csc + 1,\n\t\t\t\t\t    0x7a5f5090);\n\t\tatmel_hlcdc_layer_write_cfg(&plane->layer,\n\t\t\t\t\t    desc->layout.csc + 2,\n\t\t\t\t\t    0x40040890);\n\t}\n\n\treturn 0;\n}\n\nvoid atmel_hlcdc_plane_irq(struct atmel_hlcdc_plane *plane)\n{\n\tconst struct atmel_hlcdc_layer_desc *desc = plane->layer.desc;\n\tu32 isr;\n\n\tisr = atmel_hlcdc_layer_read_reg(&plane->layer, ATMEL_HLCDC_LAYER_ISR);\n\n\t \n\tif (isr &\n\t    (ATMEL_HLCDC_LAYER_OVR_IRQ(0) | ATMEL_HLCDC_LAYER_OVR_IRQ(1) |\n\t     ATMEL_HLCDC_LAYER_OVR_IRQ(2)))\n\t\tdev_dbg(plane->base.dev->dev, \"overrun on plane %s\\n\",\n\t\t\tdesc->name);\n}\n\nstatic const struct drm_plane_helper_funcs atmel_hlcdc_layer_plane_helper_funcs = {\n\t.atomic_check = atmel_hlcdc_plane_atomic_check,\n\t.atomic_update = atmel_hlcdc_plane_atomic_update,\n\t.atomic_disable = atmel_hlcdc_plane_atomic_disable,\n};\n\nstatic int atmel_hlcdc_plane_alloc_dscrs(struct drm_plane *p,\n\t\t\t\t\t struct atmel_hlcdc_plane_state *state)\n{\n\tstruct atmel_hlcdc_dc *dc = p->dev->dev_private;\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(state->dscrs); i++) {\n\t\tstruct atmel_hlcdc_dma_channel_dscr *dscr;\n\t\tdma_addr_t dscr_dma;\n\n\t\tdscr = dma_pool_alloc(dc->dscrpool, GFP_KERNEL, &dscr_dma);\n\t\tif (!dscr)\n\t\t\tgoto err;\n\n\t\tdscr->addr = 0;\n\t\tdscr->next = dscr_dma;\n\t\tdscr->self = dscr_dma;\n\t\tdscr->ctrl = ATMEL_HLCDC_LAYER_DFETCH;\n\n\t\tstate->dscrs[i] = dscr;\n\t}\n\n\treturn 0;\n\nerr:\n\tfor (i--; i >= 0; i--) {\n\t\tdma_pool_free(dc->dscrpool, state->dscrs[i],\n\t\t\t      state->dscrs[i]->self);\n\t}\n\n\treturn -ENOMEM;\n}\n\nstatic void atmel_hlcdc_plane_reset(struct drm_plane *p)\n{\n\tstruct atmel_hlcdc_plane_state *state;\n\n\tif (p->state) {\n\t\tstate = drm_plane_state_to_atmel_hlcdc_plane_state(p->state);\n\n\t\tif (state->base.fb)\n\t\t\tdrm_framebuffer_put(state->base.fb);\n\n\t\tkfree(state);\n\t\tp->state = NULL;\n\t}\n\n\tstate = kzalloc(sizeof(*state), GFP_KERNEL);\n\tif (state) {\n\t\tif (atmel_hlcdc_plane_alloc_dscrs(p, state)) {\n\t\t\tkfree(state);\n\t\t\tdev_err(p->dev->dev,\n\t\t\t\t\"Failed to allocate initial plane state\\n\");\n\t\t\treturn;\n\t\t}\n\t\t__drm_atomic_helper_plane_reset(p, &state->base);\n\t}\n}\n\nstatic struct drm_plane_state *\natmel_hlcdc_plane_atomic_duplicate_state(struct drm_plane *p)\n{\n\tstruct atmel_hlcdc_plane_state *state =\n\t\t\tdrm_plane_state_to_atmel_hlcdc_plane_state(p->state);\n\tstruct atmel_hlcdc_plane_state *copy;\n\n\tcopy = kmemdup(state, sizeof(*state), GFP_KERNEL);\n\tif (!copy)\n\t\treturn NULL;\n\n\tif (atmel_hlcdc_plane_alloc_dscrs(p, copy)) {\n\t\tkfree(copy);\n\t\treturn NULL;\n\t}\n\n\tif (copy->base.fb)\n\t\tdrm_framebuffer_get(copy->base.fb);\n\n\treturn &copy->base;\n}\n\nstatic void atmel_hlcdc_plane_atomic_destroy_state(struct drm_plane *p,\n\t\t\t\t\t\t   struct drm_plane_state *s)\n{\n\tstruct atmel_hlcdc_plane_state *state =\n\t\t\tdrm_plane_state_to_atmel_hlcdc_plane_state(s);\n\tstruct atmel_hlcdc_dc *dc = p->dev->dev_private;\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(state->dscrs); i++) {\n\t\tdma_pool_free(dc->dscrpool, state->dscrs[i],\n\t\t\t      state->dscrs[i]->self);\n\t}\n\n\tif (s->fb)\n\t\tdrm_framebuffer_put(s->fb);\n\n\tkfree(state);\n}\n\nstatic const struct drm_plane_funcs layer_plane_funcs = {\n\t.update_plane = drm_atomic_helper_update_plane,\n\t.disable_plane = drm_atomic_helper_disable_plane,\n\t.destroy = drm_plane_cleanup,\n\t.reset = atmel_hlcdc_plane_reset,\n\t.atomic_duplicate_state = atmel_hlcdc_plane_atomic_duplicate_state,\n\t.atomic_destroy_state = atmel_hlcdc_plane_atomic_destroy_state,\n};\n\nstatic int atmel_hlcdc_plane_create(struct drm_device *dev,\n\t\t\t\t    const struct atmel_hlcdc_layer_desc *desc)\n{\n\tstruct atmel_hlcdc_dc *dc = dev->dev_private;\n\tstruct atmel_hlcdc_plane *plane;\n\tenum drm_plane_type type;\n\tint ret;\n\n\tplane = devm_kzalloc(dev->dev, sizeof(*plane), GFP_KERNEL);\n\tif (!plane)\n\t\treturn -ENOMEM;\n\n\tatmel_hlcdc_layer_init(&plane->layer, desc, dc->hlcdc->regmap);\n\n\tif (desc->type == ATMEL_HLCDC_BASE_LAYER)\n\t\ttype = DRM_PLANE_TYPE_PRIMARY;\n\telse if (desc->type == ATMEL_HLCDC_CURSOR_LAYER)\n\t\ttype = DRM_PLANE_TYPE_CURSOR;\n\telse\n\t\ttype = DRM_PLANE_TYPE_OVERLAY;\n\n\tret = drm_universal_plane_init(dev, &plane->base, 0,\n\t\t\t\t       &layer_plane_funcs,\n\t\t\t\t       desc->formats->formats,\n\t\t\t\t       desc->formats->nformats,\n\t\t\t\t       NULL, type, NULL);\n\tif (ret)\n\t\treturn ret;\n\n\tdrm_plane_helper_add(&plane->base,\n\t\t\t     &atmel_hlcdc_layer_plane_helper_funcs);\n\n\t \n\tret = atmel_hlcdc_plane_init_properties(plane);\n\tif (ret)\n\t\treturn ret;\n\n\tdc->layers[desc->id] = &plane->layer;\n\n\treturn 0;\n}\n\nint atmel_hlcdc_create_planes(struct drm_device *dev)\n{\n\tstruct atmel_hlcdc_dc *dc = dev->dev_private;\n\tconst struct atmel_hlcdc_layer_desc *descs = dc->desc->layers;\n\tint nlayers = dc->desc->nlayers;\n\tint i, ret;\n\n\tdc->dscrpool = dmam_pool_create(\"atmel-hlcdc-dscr\", dev->dev,\n\t\t\t\tsizeof(struct atmel_hlcdc_dma_channel_dscr),\n\t\t\t\tsizeof(u64), 0);\n\tif (!dc->dscrpool)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < nlayers; i++) {\n\t\tif (descs[i].type != ATMEL_HLCDC_BASE_LAYER &&\n\t\t    descs[i].type != ATMEL_HLCDC_OVERLAY_LAYER &&\n\t\t    descs[i].type != ATMEL_HLCDC_CURSOR_LAYER)\n\t\t\tcontinue;\n\n\t\tret = atmel_hlcdc_plane_create(dev, &descs[i]);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}