{
  "module_name": "atmel_hlcdc_crtc.c",
  "hash_id": "b492b3d686300f358790292eae75c5ae3df242db6b5e5ed2ad9e6ba0e6ae3961",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/atmel-hlcdc/atmel_hlcdc_crtc.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/media-bus-format.h>\n#include <linux/mfd/atmel-hlcdc.h>\n#include <linux/pinctrl/consumer.h>\n#include <linux/pm.h>\n#include <linux/pm_runtime.h>\n\n#include <video/videomode.h>\n\n#include <drm/drm_atomic.h>\n#include <drm/drm_atomic_helper.h>\n#include <drm/drm_crtc.h>\n#include <drm/drm_modeset_helper_vtables.h>\n#include <drm/drm_probe_helper.h>\n#include <drm/drm_vblank.h>\n\n#include \"atmel_hlcdc_dc.h\"\n\n \nstruct atmel_hlcdc_crtc_state {\n\tstruct drm_crtc_state base;\n\tunsigned int output_mode;\n};\n\nstatic inline struct atmel_hlcdc_crtc_state *\ndrm_crtc_state_to_atmel_hlcdc_crtc_state(struct drm_crtc_state *state)\n{\n\treturn container_of(state, struct atmel_hlcdc_crtc_state, base);\n}\n\n \nstruct atmel_hlcdc_crtc {\n\tstruct drm_crtc base;\n\tstruct atmel_hlcdc_dc *dc;\n\tstruct drm_pending_vblank_event *event;\n\tint id;\n};\n\nstatic inline struct atmel_hlcdc_crtc *\ndrm_crtc_to_atmel_hlcdc_crtc(struct drm_crtc *crtc)\n{\n\treturn container_of(crtc, struct atmel_hlcdc_crtc, base);\n}\n\nstatic void atmel_hlcdc_crtc_mode_set_nofb(struct drm_crtc *c)\n{\n\tstruct atmel_hlcdc_crtc *crtc = drm_crtc_to_atmel_hlcdc_crtc(c);\n\tstruct regmap *regmap = crtc->dc->hlcdc->regmap;\n\tstruct drm_display_mode *adj = &c->state->adjusted_mode;\n\tstruct drm_encoder *encoder = NULL, *en_iter;\n\tstruct drm_connector *connector = NULL;\n\tstruct atmel_hlcdc_crtc_state *state;\n\tstruct drm_device *ddev = c->dev;\n\tstruct drm_connector_list_iter iter;\n\tunsigned long mode_rate;\n\tstruct videomode vm;\n\tunsigned long prate;\n\tunsigned int mask = ATMEL_HLCDC_CLKDIV_MASK | ATMEL_HLCDC_CLKPOL;\n\tunsigned int cfg = 0;\n\tint div, ret;\n\n\t \n\tdrm_for_each_encoder(en_iter, ddev) {\n\t\tif (en_iter->crtc == c) {\n\t\t\tencoder = en_iter;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (encoder) {\n\t\t \n\t\tdrm_connector_list_iter_begin(ddev, &iter);\n\t\tdrm_for_each_connector_iter(connector, &iter)\n\t\t\tif (connector->encoder == encoder)\n\t\t\t\tbreak;\n\t\tdrm_connector_list_iter_end(&iter);\n\t}\n\n\tret = clk_prepare_enable(crtc->dc->hlcdc->sys_clk);\n\tif (ret)\n\t\treturn;\n\n\tvm.vfront_porch = adj->crtc_vsync_start - adj->crtc_vdisplay;\n\tvm.vback_porch = adj->crtc_vtotal - adj->crtc_vsync_end;\n\tvm.vsync_len = adj->crtc_vsync_end - adj->crtc_vsync_start;\n\tvm.hfront_porch = adj->crtc_hsync_start - adj->crtc_hdisplay;\n\tvm.hback_porch = adj->crtc_htotal - adj->crtc_hsync_end;\n\tvm.hsync_len = adj->crtc_hsync_end - adj->crtc_hsync_start;\n\n\tregmap_write(regmap, ATMEL_HLCDC_CFG(1),\n\t\t     (vm.hsync_len - 1) | ((vm.vsync_len - 1) << 16));\n\n\tregmap_write(regmap, ATMEL_HLCDC_CFG(2),\n\t\t     (vm.vfront_porch - 1) | (vm.vback_porch << 16));\n\n\tregmap_write(regmap, ATMEL_HLCDC_CFG(3),\n\t\t     (vm.hfront_porch - 1) | ((vm.hback_porch - 1) << 16));\n\n\tregmap_write(regmap, ATMEL_HLCDC_CFG(4),\n\t\t     (adj->crtc_hdisplay - 1) |\n\t\t     ((adj->crtc_vdisplay - 1) << 16));\n\n\tprate = clk_get_rate(crtc->dc->hlcdc->sys_clk);\n\tmode_rate = adj->crtc_clock * 1000;\n\tif (!crtc->dc->desc->fixed_clksrc) {\n\t\tprate *= 2;\n\t\tcfg |= ATMEL_HLCDC_CLKSEL;\n\t\tmask |= ATMEL_HLCDC_CLKSEL;\n\t}\n\n\tdiv = DIV_ROUND_UP(prate, mode_rate);\n\tif (div < 2) {\n\t\tdiv = 2;\n\t} else if (ATMEL_HLCDC_CLKDIV(div) & ~ATMEL_HLCDC_CLKDIV_MASK) {\n\t\t \n\t\tcfg &= ~ATMEL_HLCDC_CLKSEL;\n\t\tprate /= 2;\n\t\tdiv = DIV_ROUND_UP(prate, mode_rate);\n\t\tif (ATMEL_HLCDC_CLKDIV(div) & ~ATMEL_HLCDC_CLKDIV_MASK)\n\t\t\tdiv = ATMEL_HLCDC_CLKDIV_MASK;\n\t} else {\n\t\tint div_low = prate / mode_rate;\n\n\t\tif (div_low >= 2 &&\n\t\t    (10 * (prate / div_low - mode_rate) <\n\t\t     (mode_rate - prate / div)))\n\t\t\t \n\t\t\tdiv = div_low;\n\t}\n\n\tcfg |= ATMEL_HLCDC_CLKDIV(div);\n\n\tif (connector &&\n\t    connector->display_info.bus_flags & DRM_BUS_FLAG_PIXDATA_DRIVE_NEGEDGE)\n\t\tcfg |= ATMEL_HLCDC_CLKPOL;\n\n\tregmap_update_bits(regmap, ATMEL_HLCDC_CFG(0), mask, cfg);\n\n\tstate = drm_crtc_state_to_atmel_hlcdc_crtc_state(c->state);\n\tcfg = state->output_mode << 8;\n\n\tif (adj->flags & DRM_MODE_FLAG_NVSYNC)\n\t\tcfg |= ATMEL_HLCDC_VSPOL;\n\n\tif (adj->flags & DRM_MODE_FLAG_NHSYNC)\n\t\tcfg |= ATMEL_HLCDC_HSPOL;\n\n\tregmap_update_bits(regmap, ATMEL_HLCDC_CFG(5),\n\t\t\t   ATMEL_HLCDC_HSPOL | ATMEL_HLCDC_VSPOL |\n\t\t\t   ATMEL_HLCDC_VSPDLYS | ATMEL_HLCDC_VSPDLYE |\n\t\t\t   ATMEL_HLCDC_DISPPOL | ATMEL_HLCDC_DISPDLY |\n\t\t\t   ATMEL_HLCDC_VSPSU | ATMEL_HLCDC_VSPHO |\n\t\t\t   ATMEL_HLCDC_GUARDTIME_MASK | ATMEL_HLCDC_MODE_MASK,\n\t\t\t   cfg);\n\n\tclk_disable_unprepare(crtc->dc->hlcdc->sys_clk);\n}\n\nstatic enum drm_mode_status\natmel_hlcdc_crtc_mode_valid(struct drm_crtc *c,\n\t\t\t    const struct drm_display_mode *mode)\n{\n\tstruct atmel_hlcdc_crtc *crtc = drm_crtc_to_atmel_hlcdc_crtc(c);\n\n\treturn atmel_hlcdc_dc_mode_valid(crtc->dc, mode);\n}\n\nstatic void atmel_hlcdc_crtc_atomic_disable(struct drm_crtc *c,\n\t\t\t\t\t    struct drm_atomic_state *state)\n{\n\tstruct drm_device *dev = c->dev;\n\tstruct atmel_hlcdc_crtc *crtc = drm_crtc_to_atmel_hlcdc_crtc(c);\n\tstruct regmap *regmap = crtc->dc->hlcdc->regmap;\n\tunsigned int status;\n\n\tdrm_crtc_vblank_off(c);\n\n\tpm_runtime_get_sync(dev->dev);\n\n\tregmap_write(regmap, ATMEL_HLCDC_DIS, ATMEL_HLCDC_DISP);\n\twhile (!regmap_read(regmap, ATMEL_HLCDC_SR, &status) &&\n\t       (status & ATMEL_HLCDC_DISP))\n\t\tcpu_relax();\n\n\tregmap_write(regmap, ATMEL_HLCDC_DIS, ATMEL_HLCDC_SYNC);\n\twhile (!regmap_read(regmap, ATMEL_HLCDC_SR, &status) &&\n\t       (status & ATMEL_HLCDC_SYNC))\n\t\tcpu_relax();\n\n\tregmap_write(regmap, ATMEL_HLCDC_DIS, ATMEL_HLCDC_PIXEL_CLK);\n\twhile (!regmap_read(regmap, ATMEL_HLCDC_SR, &status) &&\n\t       (status & ATMEL_HLCDC_PIXEL_CLK))\n\t\tcpu_relax();\n\n\tclk_disable_unprepare(crtc->dc->hlcdc->sys_clk);\n\tpinctrl_pm_select_sleep_state(dev->dev);\n\n\tpm_runtime_allow(dev->dev);\n\n\tpm_runtime_put_sync(dev->dev);\n}\n\nstatic void atmel_hlcdc_crtc_atomic_enable(struct drm_crtc *c,\n\t\t\t\t\t   struct drm_atomic_state *state)\n{\n\tstruct drm_device *dev = c->dev;\n\tstruct atmel_hlcdc_crtc *crtc = drm_crtc_to_atmel_hlcdc_crtc(c);\n\tstruct regmap *regmap = crtc->dc->hlcdc->regmap;\n\tunsigned int status;\n\n\tpm_runtime_get_sync(dev->dev);\n\n\tpm_runtime_forbid(dev->dev);\n\n\tpinctrl_pm_select_default_state(dev->dev);\n\tclk_prepare_enable(crtc->dc->hlcdc->sys_clk);\n\n\tregmap_write(regmap, ATMEL_HLCDC_EN, ATMEL_HLCDC_PIXEL_CLK);\n\twhile (!regmap_read(regmap, ATMEL_HLCDC_SR, &status) &&\n\t       !(status & ATMEL_HLCDC_PIXEL_CLK))\n\t\tcpu_relax();\n\n\n\tregmap_write(regmap, ATMEL_HLCDC_EN, ATMEL_HLCDC_SYNC);\n\twhile (!regmap_read(regmap, ATMEL_HLCDC_SR, &status) &&\n\t       !(status & ATMEL_HLCDC_SYNC))\n\t\tcpu_relax();\n\n\tregmap_write(regmap, ATMEL_HLCDC_EN, ATMEL_HLCDC_DISP);\n\twhile (!regmap_read(regmap, ATMEL_HLCDC_SR, &status) &&\n\t       !(status & ATMEL_HLCDC_DISP))\n\t\tcpu_relax();\n\n\tpm_runtime_put_sync(dev->dev);\n\n}\n\n#define ATMEL_HLCDC_RGB444_OUTPUT\tBIT(0)\n#define ATMEL_HLCDC_RGB565_OUTPUT\tBIT(1)\n#define ATMEL_HLCDC_RGB666_OUTPUT\tBIT(2)\n#define ATMEL_HLCDC_RGB888_OUTPUT\tBIT(3)\n#define ATMEL_HLCDC_OUTPUT_MODE_MASK\tGENMASK(3, 0)\n\nstatic int atmel_hlcdc_connector_output_mode(struct drm_connector_state *state)\n{\n\tstruct drm_connector *connector = state->connector;\n\tstruct drm_display_info *info = &connector->display_info;\n\tstruct drm_encoder *encoder;\n\tunsigned int supported_fmts = 0;\n\tint j;\n\n\tencoder = state->best_encoder;\n\tif (!encoder)\n\t\tencoder = connector->encoder;\n\n\tswitch (atmel_hlcdc_encoder_get_bus_fmt(encoder)) {\n\tcase 0:\n\t\tbreak;\n\tcase MEDIA_BUS_FMT_RGB444_1X12:\n\t\treturn ATMEL_HLCDC_RGB444_OUTPUT;\n\tcase MEDIA_BUS_FMT_RGB565_1X16:\n\t\treturn ATMEL_HLCDC_RGB565_OUTPUT;\n\tcase MEDIA_BUS_FMT_RGB666_1X18:\n\t\treturn ATMEL_HLCDC_RGB666_OUTPUT;\n\tcase MEDIA_BUS_FMT_RGB888_1X24:\n\t\treturn ATMEL_HLCDC_RGB888_OUTPUT;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tfor (j = 0; j < info->num_bus_formats; j++) {\n\t\tswitch (info->bus_formats[j]) {\n\t\tcase MEDIA_BUS_FMT_RGB444_1X12:\n\t\t\tsupported_fmts |= ATMEL_HLCDC_RGB444_OUTPUT;\n\t\t\tbreak;\n\t\tcase MEDIA_BUS_FMT_RGB565_1X16:\n\t\t\tsupported_fmts |= ATMEL_HLCDC_RGB565_OUTPUT;\n\t\t\tbreak;\n\t\tcase MEDIA_BUS_FMT_RGB666_1X18:\n\t\t\tsupported_fmts |= ATMEL_HLCDC_RGB666_OUTPUT;\n\t\t\tbreak;\n\t\tcase MEDIA_BUS_FMT_RGB888_1X24:\n\t\t\tsupported_fmts |= ATMEL_HLCDC_RGB888_OUTPUT;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn supported_fmts;\n}\n\nstatic int atmel_hlcdc_crtc_select_output_mode(struct drm_crtc_state *state)\n{\n\tunsigned int output_fmts = ATMEL_HLCDC_OUTPUT_MODE_MASK;\n\tstruct atmel_hlcdc_crtc_state *hstate;\n\tstruct drm_connector_state *cstate;\n\tstruct drm_connector *connector;\n\tstruct atmel_hlcdc_crtc *crtc;\n\tint i;\n\n\tcrtc = drm_crtc_to_atmel_hlcdc_crtc(state->crtc);\n\n\tfor_each_new_connector_in_state(state->state, connector, cstate, i) {\n\t\tunsigned int supported_fmts = 0;\n\n\t\tif (!cstate->crtc)\n\t\t\tcontinue;\n\n\t\tsupported_fmts = atmel_hlcdc_connector_output_mode(cstate);\n\n\t\tif (crtc->dc->desc->conflicting_output_formats)\n\t\t\toutput_fmts &= supported_fmts;\n\t\telse\n\t\t\toutput_fmts |= supported_fmts;\n\t}\n\n\tif (!output_fmts)\n\t\treturn -EINVAL;\n\n\thstate = drm_crtc_state_to_atmel_hlcdc_crtc_state(state);\n\thstate->output_mode = fls(output_fmts) - 1;\n\n\treturn 0;\n}\n\nstatic int atmel_hlcdc_crtc_atomic_check(struct drm_crtc *c,\n\t\t\t\t\t struct drm_atomic_state *state)\n{\n\tstruct drm_crtc_state *s = drm_atomic_get_new_crtc_state(state, c);\n\tint ret;\n\n\tret = atmel_hlcdc_crtc_select_output_mode(s);\n\tif (ret)\n\t\treturn ret;\n\n\tret = atmel_hlcdc_plane_prepare_disc_area(s);\n\tif (ret)\n\t\treturn ret;\n\n\treturn atmel_hlcdc_plane_prepare_ahb_routing(s);\n}\n\nstatic void atmel_hlcdc_crtc_atomic_begin(struct drm_crtc *c,\n\t\t\t\t\t  struct drm_atomic_state *state)\n{\n\tdrm_crtc_vblank_on(c);\n}\n\nstatic void atmel_hlcdc_crtc_atomic_flush(struct drm_crtc *c,\n\t\t\t\t\t  struct drm_atomic_state *state)\n{\n\tstruct atmel_hlcdc_crtc *crtc = drm_crtc_to_atmel_hlcdc_crtc(c);\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&c->dev->event_lock, flags);\n\n\tif (c->state->event) {\n\t\tc->state->event->pipe = drm_crtc_index(c);\n\n\t\tWARN_ON(drm_crtc_vblank_get(c) != 0);\n\n\t\tcrtc->event = c->state->event;\n\t\tc->state->event = NULL;\n\t}\n\tspin_unlock_irqrestore(&c->dev->event_lock, flags);\n}\n\nstatic const struct drm_crtc_helper_funcs lcdc_crtc_helper_funcs = {\n\t.mode_valid = atmel_hlcdc_crtc_mode_valid,\n\t.mode_set_nofb = atmel_hlcdc_crtc_mode_set_nofb,\n\t.atomic_check = atmel_hlcdc_crtc_atomic_check,\n\t.atomic_begin = atmel_hlcdc_crtc_atomic_begin,\n\t.atomic_flush = atmel_hlcdc_crtc_atomic_flush,\n\t.atomic_enable = atmel_hlcdc_crtc_atomic_enable,\n\t.atomic_disable = atmel_hlcdc_crtc_atomic_disable,\n};\n\nstatic void atmel_hlcdc_crtc_destroy(struct drm_crtc *c)\n{\n\tstruct atmel_hlcdc_crtc *crtc = drm_crtc_to_atmel_hlcdc_crtc(c);\n\n\tdrm_crtc_cleanup(c);\n\tkfree(crtc);\n}\n\nstatic void atmel_hlcdc_crtc_finish_page_flip(struct atmel_hlcdc_crtc *crtc)\n{\n\tstruct drm_device *dev = crtc->base.dev;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&dev->event_lock, flags);\n\tif (crtc->event) {\n\t\tdrm_crtc_send_vblank_event(&crtc->base, crtc->event);\n\t\tdrm_crtc_vblank_put(&crtc->base);\n\t\tcrtc->event = NULL;\n\t}\n\tspin_unlock_irqrestore(&dev->event_lock, flags);\n}\n\nvoid atmel_hlcdc_crtc_irq(struct drm_crtc *c)\n{\n\tdrm_crtc_handle_vblank(c);\n\tatmel_hlcdc_crtc_finish_page_flip(drm_crtc_to_atmel_hlcdc_crtc(c));\n}\n\nstatic void atmel_hlcdc_crtc_reset(struct drm_crtc *crtc)\n{\n\tstruct atmel_hlcdc_crtc_state *state;\n\n\tif (crtc->state) {\n\t\t__drm_atomic_helper_crtc_destroy_state(crtc->state);\n\t\tstate = drm_crtc_state_to_atmel_hlcdc_crtc_state(crtc->state);\n\t\tkfree(state);\n\t\tcrtc->state = NULL;\n\t}\n\n\tstate = kzalloc(sizeof(*state), GFP_KERNEL);\n\tif (state)\n\t\t__drm_atomic_helper_crtc_reset(crtc, &state->base);\n}\n\nstatic struct drm_crtc_state *\natmel_hlcdc_crtc_duplicate_state(struct drm_crtc *crtc)\n{\n\tstruct atmel_hlcdc_crtc_state *state, *cur;\n\n\tif (WARN_ON(!crtc->state))\n\t\treturn NULL;\n\n\tstate = kmalloc(sizeof(*state), GFP_KERNEL);\n\tif (!state)\n\t\treturn NULL;\n\t__drm_atomic_helper_crtc_duplicate_state(crtc, &state->base);\n\n\tcur = drm_crtc_state_to_atmel_hlcdc_crtc_state(crtc->state);\n\tstate->output_mode = cur->output_mode;\n\n\treturn &state->base;\n}\n\nstatic void atmel_hlcdc_crtc_destroy_state(struct drm_crtc *crtc,\n\t\t\t\t\t   struct drm_crtc_state *s)\n{\n\tstruct atmel_hlcdc_crtc_state *state;\n\n\tstate = drm_crtc_state_to_atmel_hlcdc_crtc_state(s);\n\t__drm_atomic_helper_crtc_destroy_state(s);\n\tkfree(state);\n}\n\nstatic int atmel_hlcdc_crtc_enable_vblank(struct drm_crtc *c)\n{\n\tstruct atmel_hlcdc_crtc *crtc = drm_crtc_to_atmel_hlcdc_crtc(c);\n\tstruct regmap *regmap = crtc->dc->hlcdc->regmap;\n\n\t \n\tregmap_write(regmap, ATMEL_HLCDC_IER, ATMEL_HLCDC_SOF);\n\n\treturn 0;\n}\n\nstatic void atmel_hlcdc_crtc_disable_vblank(struct drm_crtc *c)\n{\n\tstruct atmel_hlcdc_crtc *crtc = drm_crtc_to_atmel_hlcdc_crtc(c);\n\tstruct regmap *regmap = crtc->dc->hlcdc->regmap;\n\n\tregmap_write(regmap, ATMEL_HLCDC_IDR, ATMEL_HLCDC_SOF);\n}\n\nstatic const struct drm_crtc_funcs atmel_hlcdc_crtc_funcs = {\n\t.page_flip = drm_atomic_helper_page_flip,\n\t.set_config = drm_atomic_helper_set_config,\n\t.destroy = atmel_hlcdc_crtc_destroy,\n\t.reset = atmel_hlcdc_crtc_reset,\n\t.atomic_duplicate_state =  atmel_hlcdc_crtc_duplicate_state,\n\t.atomic_destroy_state = atmel_hlcdc_crtc_destroy_state,\n\t.enable_vblank = atmel_hlcdc_crtc_enable_vblank,\n\t.disable_vblank = atmel_hlcdc_crtc_disable_vblank,\n};\n\nint atmel_hlcdc_crtc_create(struct drm_device *dev)\n{\n\tstruct atmel_hlcdc_plane *primary = NULL, *cursor = NULL;\n\tstruct atmel_hlcdc_dc *dc = dev->dev_private;\n\tstruct atmel_hlcdc_crtc *crtc;\n\tint ret;\n\tint i;\n\n\tcrtc = kzalloc(sizeof(*crtc), GFP_KERNEL);\n\tif (!crtc)\n\t\treturn -ENOMEM;\n\n\tcrtc->dc = dc;\n\n\tfor (i = 0; i < ATMEL_HLCDC_MAX_LAYERS; i++) {\n\t\tif (!dc->layers[i])\n\t\t\tcontinue;\n\n\t\tswitch (dc->layers[i]->desc->type) {\n\t\tcase ATMEL_HLCDC_BASE_LAYER:\n\t\t\tprimary = atmel_hlcdc_layer_to_plane(dc->layers[i]);\n\t\t\tbreak;\n\n\t\tcase ATMEL_HLCDC_CURSOR_LAYER:\n\t\t\tcursor = atmel_hlcdc_layer_to_plane(dc->layers[i]);\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tret = drm_crtc_init_with_planes(dev, &crtc->base, &primary->base,\n\t\t\t\t\t&cursor->base, &atmel_hlcdc_crtc_funcs,\n\t\t\t\t\tNULL);\n\tif (ret < 0)\n\t\tgoto fail;\n\n\tcrtc->id = drm_crtc_index(&crtc->base);\n\n\tfor (i = 0; i < ATMEL_HLCDC_MAX_LAYERS; i++) {\n\t\tstruct atmel_hlcdc_plane *overlay;\n\n\t\tif (dc->layers[i] &&\n\t\t    dc->layers[i]->desc->type == ATMEL_HLCDC_OVERLAY_LAYER) {\n\t\t\toverlay = atmel_hlcdc_layer_to_plane(dc->layers[i]);\n\t\t\toverlay->base.possible_crtcs = 1 << crtc->id;\n\t\t}\n\t}\n\n\tdrm_crtc_helper_add(&crtc->base, &lcdc_crtc_helper_funcs);\n\n\tdrm_mode_crtc_set_gamma_size(&crtc->base, ATMEL_HLCDC_CLUT_SIZE);\n\tdrm_crtc_enable_color_mgmt(&crtc->base, 0, false,\n\t\t\t\t   ATMEL_HLCDC_CLUT_SIZE);\n\n\tdc->crtc = &crtc->base;\n\n\treturn 0;\n\nfail:\n\tatmel_hlcdc_crtc_destroy(&crtc->base);\n\treturn ret;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}