{
  "module_name": "atmel_hlcdc_dc.c",
  "hash_id": "a514188a88af1e78ba8fbb8d2c27878ab1114d1e2238e55be45dd2d7907f32d5",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/atmel-hlcdc/atmel_hlcdc_dc.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/irq.h>\n#include <linux/irqchip.h>\n#include <linux/mfd/atmel-hlcdc.h>\n#include <linux/module.h>\n#include <linux/pm_runtime.h>\n#include <linux/platform_device.h>\n\n#include <drm/drm_atomic.h>\n#include <drm/drm_atomic_helper.h>\n#include <drm/drm_drv.h>\n#include <drm/drm_fbdev_dma.h>\n#include <drm/drm_gem_dma_helper.h>\n#include <drm/drm_gem_framebuffer_helper.h>\n#include <drm/drm_module.h>\n#include <drm/drm_probe_helper.h>\n#include <drm/drm_vblank.h>\n\n#include \"atmel_hlcdc_dc.h\"\n\n#define ATMEL_HLCDC_LAYER_IRQS_OFFSET\t\t8\n\nstatic const struct atmel_hlcdc_layer_desc atmel_hlcdc_at91sam9n12_layers[] = {\n\t{\n\t\t.name = \"base\",\n\t\t.formats = &atmel_hlcdc_plane_rgb_formats,\n\t\t.regs_offset = 0x40,\n\t\t.id = 0,\n\t\t.type = ATMEL_HLCDC_BASE_LAYER,\n\t\t.cfgs_offset = 0x2c,\n\t\t.layout = {\n\t\t\t.xstride = { 2 },\n\t\t\t.default_color = 3,\n\t\t\t.general_config = 4,\n\t\t},\n\t\t.clut_offset = 0x400,\n\t},\n};\n\nstatic const struct atmel_hlcdc_dc_desc atmel_hlcdc_dc_at91sam9n12 = {\n\t.min_width = 0,\n\t.min_height = 0,\n\t.max_width = 1280,\n\t.max_height = 860,\n\t.max_spw = 0x3f,\n\t.max_vpw = 0x3f,\n\t.max_hpw = 0xff,\n\t.conflicting_output_formats = true,\n\t.nlayers = ARRAY_SIZE(atmel_hlcdc_at91sam9n12_layers),\n\t.layers = atmel_hlcdc_at91sam9n12_layers,\n};\n\nstatic const struct atmel_hlcdc_layer_desc atmel_hlcdc_at91sam9x5_layers[] = {\n\t{\n\t\t.name = \"base\",\n\t\t.formats = &atmel_hlcdc_plane_rgb_formats,\n\t\t.regs_offset = 0x40,\n\t\t.id = 0,\n\t\t.type = ATMEL_HLCDC_BASE_LAYER,\n\t\t.cfgs_offset = 0x2c,\n\t\t.layout = {\n\t\t\t.xstride = { 2 },\n\t\t\t.default_color = 3,\n\t\t\t.general_config = 4,\n\t\t\t.disc_pos = 5,\n\t\t\t.disc_size = 6,\n\t\t},\n\t\t.clut_offset = 0x400,\n\t},\n\t{\n\t\t.name = \"overlay1\",\n\t\t.formats = &atmel_hlcdc_plane_rgb_formats,\n\t\t.regs_offset = 0x100,\n\t\t.id = 1,\n\t\t.type = ATMEL_HLCDC_OVERLAY_LAYER,\n\t\t.cfgs_offset = 0x2c,\n\t\t.layout = {\n\t\t\t.pos = 2,\n\t\t\t.size = 3,\n\t\t\t.xstride = { 4 },\n\t\t\t.pstride = { 5 },\n\t\t\t.default_color = 6,\n\t\t\t.chroma_key = 7,\n\t\t\t.chroma_key_mask = 8,\n\t\t\t.general_config = 9,\n\t\t},\n\t\t.clut_offset = 0x800,\n\t},\n\t{\n\t\t.name = \"high-end-overlay\",\n\t\t.formats = &atmel_hlcdc_plane_rgb_and_yuv_formats,\n\t\t.regs_offset = 0x280,\n\t\t.id = 2,\n\t\t.type = ATMEL_HLCDC_OVERLAY_LAYER,\n\t\t.cfgs_offset = 0x4c,\n\t\t.layout = {\n\t\t\t.pos = 2,\n\t\t\t.size = 3,\n\t\t\t.memsize = 4,\n\t\t\t.xstride = { 5, 7 },\n\t\t\t.pstride = { 6, 8 },\n\t\t\t.default_color = 9,\n\t\t\t.chroma_key = 10,\n\t\t\t.chroma_key_mask = 11,\n\t\t\t.general_config = 12,\n\t\t\t.scaler_config = 13,\n\t\t\t.csc = 14,\n\t\t},\n\t\t.clut_offset = 0x1000,\n\t},\n\t{\n\t\t.name = \"cursor\",\n\t\t.formats = &atmel_hlcdc_plane_rgb_formats,\n\t\t.regs_offset = 0x340,\n\t\t.id = 3,\n\t\t.type = ATMEL_HLCDC_CURSOR_LAYER,\n\t\t.max_width = 128,\n\t\t.max_height = 128,\n\t\t.cfgs_offset = 0x2c,\n\t\t.layout = {\n\t\t\t.pos = 2,\n\t\t\t.size = 3,\n\t\t\t.xstride = { 4 },\n\t\t\t.default_color = 6,\n\t\t\t.chroma_key = 7,\n\t\t\t.chroma_key_mask = 8,\n\t\t\t.general_config = 9,\n\t\t},\n\t\t.clut_offset = 0x1400,\n\t},\n};\n\nstatic const struct atmel_hlcdc_dc_desc atmel_hlcdc_dc_at91sam9x5 = {\n\t.min_width = 0,\n\t.min_height = 0,\n\t.max_width = 800,\n\t.max_height = 600,\n\t.max_spw = 0x3f,\n\t.max_vpw = 0x3f,\n\t.max_hpw = 0xff,\n\t.conflicting_output_formats = true,\n\t.nlayers = ARRAY_SIZE(atmel_hlcdc_at91sam9x5_layers),\n\t.layers = atmel_hlcdc_at91sam9x5_layers,\n};\n\nstatic const struct atmel_hlcdc_layer_desc atmel_hlcdc_sama5d3_layers[] = {\n\t{\n\t\t.name = \"base\",\n\t\t.formats = &atmel_hlcdc_plane_rgb_formats,\n\t\t.regs_offset = 0x40,\n\t\t.id = 0,\n\t\t.type = ATMEL_HLCDC_BASE_LAYER,\n\t\t.cfgs_offset = 0x2c,\n\t\t.layout = {\n\t\t\t.xstride = { 2 },\n\t\t\t.default_color = 3,\n\t\t\t.general_config = 4,\n\t\t\t.disc_pos = 5,\n\t\t\t.disc_size = 6,\n\t\t},\n\t\t.clut_offset = 0x600,\n\t},\n\t{\n\t\t.name = \"overlay1\",\n\t\t.formats = &atmel_hlcdc_plane_rgb_formats,\n\t\t.regs_offset = 0x140,\n\t\t.id = 1,\n\t\t.type = ATMEL_HLCDC_OVERLAY_LAYER,\n\t\t.cfgs_offset = 0x2c,\n\t\t.layout = {\n\t\t\t.pos = 2,\n\t\t\t.size = 3,\n\t\t\t.xstride = { 4 },\n\t\t\t.pstride = { 5 },\n\t\t\t.default_color = 6,\n\t\t\t.chroma_key = 7,\n\t\t\t.chroma_key_mask = 8,\n\t\t\t.general_config = 9,\n\t\t},\n\t\t.clut_offset = 0xa00,\n\t},\n\t{\n\t\t.name = \"overlay2\",\n\t\t.formats = &atmel_hlcdc_plane_rgb_formats,\n\t\t.regs_offset = 0x240,\n\t\t.id = 2,\n\t\t.type = ATMEL_HLCDC_OVERLAY_LAYER,\n\t\t.cfgs_offset = 0x2c,\n\t\t.layout = {\n\t\t\t.pos = 2,\n\t\t\t.size = 3,\n\t\t\t.xstride = { 4 },\n\t\t\t.pstride = { 5 },\n\t\t\t.default_color = 6,\n\t\t\t.chroma_key = 7,\n\t\t\t.chroma_key_mask = 8,\n\t\t\t.general_config = 9,\n\t\t},\n\t\t.clut_offset = 0xe00,\n\t},\n\t{\n\t\t.name = \"high-end-overlay\",\n\t\t.formats = &atmel_hlcdc_plane_rgb_and_yuv_formats,\n\t\t.regs_offset = 0x340,\n\t\t.id = 3,\n\t\t.type = ATMEL_HLCDC_OVERLAY_LAYER,\n\t\t.cfgs_offset = 0x4c,\n\t\t.layout = {\n\t\t\t.pos = 2,\n\t\t\t.size = 3,\n\t\t\t.memsize = 4,\n\t\t\t.xstride = { 5, 7 },\n\t\t\t.pstride = { 6, 8 },\n\t\t\t.default_color = 9,\n\t\t\t.chroma_key = 10,\n\t\t\t.chroma_key_mask = 11,\n\t\t\t.general_config = 12,\n\t\t\t.scaler_config = 13,\n\t\t\t.phicoeffs = {\n\t\t\t\t.x = 17,\n\t\t\t\t.y = 33,\n\t\t\t},\n\t\t\t.csc = 14,\n\t\t},\n\t\t.clut_offset = 0x1200,\n\t},\n\t{\n\t\t.name = \"cursor\",\n\t\t.formats = &atmel_hlcdc_plane_rgb_formats,\n\t\t.regs_offset = 0x440,\n\t\t.id = 4,\n\t\t.type = ATMEL_HLCDC_CURSOR_LAYER,\n\t\t.max_width = 128,\n\t\t.max_height = 128,\n\t\t.cfgs_offset = 0x2c,\n\t\t.layout = {\n\t\t\t.pos = 2,\n\t\t\t.size = 3,\n\t\t\t.xstride = { 4 },\n\t\t\t.pstride = { 5 },\n\t\t\t.default_color = 6,\n\t\t\t.chroma_key = 7,\n\t\t\t.chroma_key_mask = 8,\n\t\t\t.general_config = 9,\n\t\t\t.scaler_config = 13,\n\t\t},\n\t\t.clut_offset = 0x1600,\n\t},\n};\n\nstatic const struct atmel_hlcdc_dc_desc atmel_hlcdc_dc_sama5d3 = {\n\t.min_width = 0,\n\t.min_height = 0,\n\t.max_width = 2048,\n\t.max_height = 2048,\n\t.max_spw = 0x3f,\n\t.max_vpw = 0x3f,\n\t.max_hpw = 0x1ff,\n\t.conflicting_output_formats = true,\n\t.nlayers = ARRAY_SIZE(atmel_hlcdc_sama5d3_layers),\n\t.layers = atmel_hlcdc_sama5d3_layers,\n};\n\nstatic const struct atmel_hlcdc_layer_desc atmel_hlcdc_sama5d4_layers[] = {\n\t{\n\t\t.name = \"base\",\n\t\t.formats = &atmel_hlcdc_plane_rgb_formats,\n\t\t.regs_offset = 0x40,\n\t\t.id = 0,\n\t\t.type = ATMEL_HLCDC_BASE_LAYER,\n\t\t.cfgs_offset = 0x2c,\n\t\t.layout = {\n\t\t\t.xstride = { 2 },\n\t\t\t.default_color = 3,\n\t\t\t.general_config = 4,\n\t\t\t.disc_pos = 5,\n\t\t\t.disc_size = 6,\n\t\t},\n\t\t.clut_offset = 0x600,\n\t},\n\t{\n\t\t.name = \"overlay1\",\n\t\t.formats = &atmel_hlcdc_plane_rgb_formats,\n\t\t.regs_offset = 0x140,\n\t\t.id = 1,\n\t\t.type = ATMEL_HLCDC_OVERLAY_LAYER,\n\t\t.cfgs_offset = 0x2c,\n\t\t.layout = {\n\t\t\t.pos = 2,\n\t\t\t.size = 3,\n\t\t\t.xstride = { 4 },\n\t\t\t.pstride = { 5 },\n\t\t\t.default_color = 6,\n\t\t\t.chroma_key = 7,\n\t\t\t.chroma_key_mask = 8,\n\t\t\t.general_config = 9,\n\t\t},\n\t\t.clut_offset = 0xa00,\n\t},\n\t{\n\t\t.name = \"overlay2\",\n\t\t.formats = &atmel_hlcdc_plane_rgb_formats,\n\t\t.regs_offset = 0x240,\n\t\t.id = 2,\n\t\t.type = ATMEL_HLCDC_OVERLAY_LAYER,\n\t\t.cfgs_offset = 0x2c,\n\t\t.layout = {\n\t\t\t.pos = 2,\n\t\t\t.size = 3,\n\t\t\t.xstride = { 4 },\n\t\t\t.pstride = { 5 },\n\t\t\t.default_color = 6,\n\t\t\t.chroma_key = 7,\n\t\t\t.chroma_key_mask = 8,\n\t\t\t.general_config = 9,\n\t\t},\n\t\t.clut_offset = 0xe00,\n\t},\n\t{\n\t\t.name = \"high-end-overlay\",\n\t\t.formats = &atmel_hlcdc_plane_rgb_and_yuv_formats,\n\t\t.regs_offset = 0x340,\n\t\t.id = 3,\n\t\t.type = ATMEL_HLCDC_OVERLAY_LAYER,\n\t\t.cfgs_offset = 0x4c,\n\t\t.layout = {\n\t\t\t.pos = 2,\n\t\t\t.size = 3,\n\t\t\t.memsize = 4,\n\t\t\t.xstride = { 5, 7 },\n\t\t\t.pstride = { 6, 8 },\n\t\t\t.default_color = 9,\n\t\t\t.chroma_key = 10,\n\t\t\t.chroma_key_mask = 11,\n\t\t\t.general_config = 12,\n\t\t\t.scaler_config = 13,\n\t\t\t.phicoeffs = {\n\t\t\t\t.x = 17,\n\t\t\t\t.y = 33,\n\t\t\t},\n\t\t\t.csc = 14,\n\t\t},\n\t\t.clut_offset = 0x1200,\n\t},\n};\n\nstatic const struct atmel_hlcdc_dc_desc atmel_hlcdc_dc_sama5d4 = {\n\t.min_width = 0,\n\t.min_height = 0,\n\t.max_width = 2048,\n\t.max_height = 2048,\n\t.max_spw = 0xff,\n\t.max_vpw = 0xff,\n\t.max_hpw = 0x3ff,\n\t.nlayers = ARRAY_SIZE(atmel_hlcdc_sama5d4_layers),\n\t.layers = atmel_hlcdc_sama5d4_layers,\n};\n\nstatic const struct atmel_hlcdc_layer_desc atmel_hlcdc_sam9x60_layers[] = {\n\t{\n\t\t.name = \"base\",\n\t\t.formats = &atmel_hlcdc_plane_rgb_formats,\n\t\t.regs_offset = 0x60,\n\t\t.id = 0,\n\t\t.type = ATMEL_HLCDC_BASE_LAYER,\n\t\t.cfgs_offset = 0x2c,\n\t\t.layout = {\n\t\t\t.xstride = { 2 },\n\t\t\t.default_color = 3,\n\t\t\t.general_config = 4,\n\t\t\t.disc_pos = 5,\n\t\t\t.disc_size = 6,\n\t\t},\n\t\t.clut_offset = 0x600,\n\t},\n\t{\n\t\t.name = \"overlay1\",\n\t\t.formats = &atmel_hlcdc_plane_rgb_formats,\n\t\t.regs_offset = 0x160,\n\t\t.id = 1,\n\t\t.type = ATMEL_HLCDC_OVERLAY_LAYER,\n\t\t.cfgs_offset = 0x2c,\n\t\t.layout = {\n\t\t\t.pos = 2,\n\t\t\t.size = 3,\n\t\t\t.xstride = { 4 },\n\t\t\t.pstride = { 5 },\n\t\t\t.default_color = 6,\n\t\t\t.chroma_key = 7,\n\t\t\t.chroma_key_mask = 8,\n\t\t\t.general_config = 9,\n\t\t},\n\t\t.clut_offset = 0xa00,\n\t},\n\t{\n\t\t.name = \"overlay2\",\n\t\t.formats = &atmel_hlcdc_plane_rgb_formats,\n\t\t.regs_offset = 0x260,\n\t\t.id = 2,\n\t\t.type = ATMEL_HLCDC_OVERLAY_LAYER,\n\t\t.cfgs_offset = 0x2c,\n\t\t.layout = {\n\t\t\t.pos = 2,\n\t\t\t.size = 3,\n\t\t\t.xstride = { 4 },\n\t\t\t.pstride = { 5 },\n\t\t\t.default_color = 6,\n\t\t\t.chroma_key = 7,\n\t\t\t.chroma_key_mask = 8,\n\t\t\t.general_config = 9,\n\t\t},\n\t\t.clut_offset = 0xe00,\n\t},\n\t{\n\t\t.name = \"high-end-overlay\",\n\t\t.formats = &atmel_hlcdc_plane_rgb_and_yuv_formats,\n\t\t.regs_offset = 0x360,\n\t\t.id = 3,\n\t\t.type = ATMEL_HLCDC_OVERLAY_LAYER,\n\t\t.cfgs_offset = 0x4c,\n\t\t.layout = {\n\t\t\t.pos = 2,\n\t\t\t.size = 3,\n\t\t\t.memsize = 4,\n\t\t\t.xstride = { 5, 7 },\n\t\t\t.pstride = { 6, 8 },\n\t\t\t.default_color = 9,\n\t\t\t.chroma_key = 10,\n\t\t\t.chroma_key_mask = 11,\n\t\t\t.general_config = 12,\n\t\t\t.scaler_config = 13,\n\t\t\t.phicoeffs = {\n\t\t\t\t.x = 17,\n\t\t\t\t.y = 33,\n\t\t\t},\n\t\t\t.csc = 14,\n\t\t},\n\t\t.clut_offset = 0x1200,\n\t},\n};\n\nstatic const struct atmel_hlcdc_dc_desc atmel_hlcdc_dc_sam9x60 = {\n\t.min_width = 0,\n\t.min_height = 0,\n\t.max_width = 2048,\n\t.max_height = 2048,\n\t.max_spw = 0xff,\n\t.max_vpw = 0xff,\n\t.max_hpw = 0x3ff,\n\t.fixed_clksrc = true,\n\t.nlayers = ARRAY_SIZE(atmel_hlcdc_sam9x60_layers),\n\t.layers = atmel_hlcdc_sam9x60_layers,\n};\n\nstatic const struct of_device_id atmel_hlcdc_of_match[] = {\n\t{\n\t\t.compatible = \"atmel,at91sam9n12-hlcdc\",\n\t\t.data = &atmel_hlcdc_dc_at91sam9n12,\n\t},\n\t{\n\t\t.compatible = \"atmel,at91sam9x5-hlcdc\",\n\t\t.data = &atmel_hlcdc_dc_at91sam9x5,\n\t},\n\t{\n\t\t.compatible = \"atmel,sama5d2-hlcdc\",\n\t\t.data = &atmel_hlcdc_dc_sama5d4,\n\t},\n\t{\n\t\t.compatible = \"atmel,sama5d3-hlcdc\",\n\t\t.data = &atmel_hlcdc_dc_sama5d3,\n\t},\n\t{\n\t\t.compatible = \"atmel,sama5d4-hlcdc\",\n\t\t.data = &atmel_hlcdc_dc_sama5d4,\n\t},\n\t{\n\t\t.compatible = \"microchip,sam9x60-hlcdc\",\n\t\t.data = &atmel_hlcdc_dc_sam9x60,\n\t},\n\t{   },\n};\nMODULE_DEVICE_TABLE(of, atmel_hlcdc_of_match);\n\nenum drm_mode_status\natmel_hlcdc_dc_mode_valid(struct atmel_hlcdc_dc *dc,\n\t\t\t  const struct drm_display_mode *mode)\n{\n\tint vfront_porch = mode->vsync_start - mode->vdisplay;\n\tint vback_porch = mode->vtotal - mode->vsync_end;\n\tint vsync_len = mode->vsync_end - mode->vsync_start;\n\tint hfront_porch = mode->hsync_start - mode->hdisplay;\n\tint hback_porch = mode->htotal - mode->hsync_end;\n\tint hsync_len = mode->hsync_end - mode->hsync_start;\n\n\tif (hsync_len > dc->desc->max_spw + 1 || hsync_len < 1)\n\t\treturn MODE_HSYNC;\n\n\tif (vsync_len > dc->desc->max_spw + 1 || vsync_len < 1)\n\t\treturn MODE_VSYNC;\n\n\tif (hfront_porch > dc->desc->max_hpw + 1 || hfront_porch < 1 ||\n\t    hback_porch > dc->desc->max_hpw + 1 || hback_porch < 1 ||\n\t    mode->hdisplay < 1)\n\t\treturn MODE_H_ILLEGAL;\n\n\tif (vfront_porch > dc->desc->max_vpw + 1 || vfront_porch < 1 ||\n\t    vback_porch > dc->desc->max_vpw || vback_porch < 0 ||\n\t    mode->vdisplay < 1)\n\t\treturn MODE_V_ILLEGAL;\n\n\treturn MODE_OK;\n}\n\nstatic void atmel_hlcdc_layer_irq(struct atmel_hlcdc_layer *layer)\n{\n\tif (!layer)\n\t\treturn;\n\n\tif (layer->desc->type == ATMEL_HLCDC_BASE_LAYER ||\n\t    layer->desc->type == ATMEL_HLCDC_OVERLAY_LAYER ||\n\t    layer->desc->type == ATMEL_HLCDC_CURSOR_LAYER)\n\t\tatmel_hlcdc_plane_irq(atmel_hlcdc_layer_to_plane(layer));\n}\n\nstatic irqreturn_t atmel_hlcdc_dc_irq_handler(int irq, void *data)\n{\n\tstruct drm_device *dev = data;\n\tstruct atmel_hlcdc_dc *dc = dev->dev_private;\n\tunsigned long status;\n\tunsigned int imr, isr;\n\tint i;\n\n\tregmap_read(dc->hlcdc->regmap, ATMEL_HLCDC_IMR, &imr);\n\tregmap_read(dc->hlcdc->regmap, ATMEL_HLCDC_ISR, &isr);\n\tstatus = imr & isr;\n\tif (!status)\n\t\treturn IRQ_NONE;\n\n\tif (status & ATMEL_HLCDC_SOF)\n\t\tatmel_hlcdc_crtc_irq(dc->crtc);\n\n\tfor (i = 0; i < ATMEL_HLCDC_MAX_LAYERS; i++) {\n\t\tif (ATMEL_HLCDC_LAYER_STATUS(i) & status)\n\t\t\tatmel_hlcdc_layer_irq(dc->layers[i]);\n\t}\n\n\treturn IRQ_HANDLED;\n}\n\nstatic void atmel_hlcdc_dc_irq_postinstall(struct drm_device *dev)\n{\n\tstruct atmel_hlcdc_dc *dc = dev->dev_private;\n\tunsigned int cfg = 0;\n\tint i;\n\n\t \n\tfor (i = 0; i < ATMEL_HLCDC_MAX_LAYERS; i++) {\n\t\tif (dc->layers[i])\n\t\t\tcfg |= ATMEL_HLCDC_LAYER_STATUS(i);\n\t}\n\n\tregmap_write(dc->hlcdc->regmap, ATMEL_HLCDC_IER, cfg);\n}\n\nstatic void atmel_hlcdc_dc_irq_disable(struct drm_device *dev)\n{\n\tstruct atmel_hlcdc_dc *dc = dev->dev_private;\n\tunsigned int isr;\n\n\tregmap_write(dc->hlcdc->regmap, ATMEL_HLCDC_IDR, 0xffffffff);\n\tregmap_read(dc->hlcdc->regmap, ATMEL_HLCDC_ISR, &isr);\n}\n\nstatic int atmel_hlcdc_dc_irq_install(struct drm_device *dev, unsigned int irq)\n{\n\tint ret;\n\n\tatmel_hlcdc_dc_irq_disable(dev);\n\n\tret = devm_request_irq(dev->dev, irq, atmel_hlcdc_dc_irq_handler, 0,\n\t\t\t       dev->driver->name, dev);\n\tif (ret)\n\t\treturn ret;\n\n\tatmel_hlcdc_dc_irq_postinstall(dev);\n\n\treturn 0;\n}\n\nstatic void atmel_hlcdc_dc_irq_uninstall(struct drm_device *dev)\n{\n\tatmel_hlcdc_dc_irq_disable(dev);\n}\n\nstatic const struct drm_mode_config_funcs mode_config_funcs = {\n\t.fb_create = drm_gem_fb_create,\n\t.atomic_check = drm_atomic_helper_check,\n\t.atomic_commit = drm_atomic_helper_commit,\n};\n\nstatic int atmel_hlcdc_dc_modeset_init(struct drm_device *dev)\n{\n\tstruct atmel_hlcdc_dc *dc = dev->dev_private;\n\tint ret;\n\n\tdrm_mode_config_init(dev);\n\n\tret = atmel_hlcdc_create_outputs(dev);\n\tif (ret) {\n\t\tdev_err(dev->dev, \"failed to create HLCDC outputs: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = atmel_hlcdc_create_planes(dev);\n\tif (ret) {\n\t\tdev_err(dev->dev, \"failed to create planes: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = atmel_hlcdc_crtc_create(dev);\n\tif (ret) {\n\t\tdev_err(dev->dev, \"failed to create crtc\\n\");\n\t\treturn ret;\n\t}\n\n\tdev->mode_config.min_width = dc->desc->min_width;\n\tdev->mode_config.min_height = dc->desc->min_height;\n\tdev->mode_config.max_width = dc->desc->max_width;\n\tdev->mode_config.max_height = dc->desc->max_height;\n\tdev->mode_config.funcs = &mode_config_funcs;\n\tdev->mode_config.async_page_flip = true;\n\n\treturn 0;\n}\n\nstatic int atmel_hlcdc_dc_load(struct drm_device *dev)\n{\n\tstruct platform_device *pdev = to_platform_device(dev->dev);\n\tconst struct of_device_id *match;\n\tstruct atmel_hlcdc_dc *dc;\n\tint ret;\n\n\tmatch = of_match_node(atmel_hlcdc_of_match, dev->dev->parent->of_node);\n\tif (!match) {\n\t\tdev_err(&pdev->dev, \"invalid compatible string\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tif (!match->data) {\n\t\tdev_err(&pdev->dev, \"invalid hlcdc description\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tdc = devm_kzalloc(dev->dev, sizeof(*dc), GFP_KERNEL);\n\tif (!dc)\n\t\treturn -ENOMEM;\n\n\tdc->desc = match->data;\n\tdc->hlcdc = dev_get_drvdata(dev->dev->parent);\n\tdev->dev_private = dc;\n\n\tret = clk_prepare_enable(dc->hlcdc->periph_clk);\n\tif (ret) {\n\t\tdev_err(dev->dev, \"failed to enable periph_clk\\n\");\n\t\treturn ret;\n\t}\n\n\tpm_runtime_enable(dev->dev);\n\n\tret = drm_vblank_init(dev, 1);\n\tif (ret < 0) {\n\t\tdev_err(dev->dev, \"failed to initialize vblank\\n\");\n\t\tgoto err_periph_clk_disable;\n\t}\n\n\tret = atmel_hlcdc_dc_modeset_init(dev);\n\tif (ret < 0) {\n\t\tdev_err(dev->dev, \"failed to initialize mode setting\\n\");\n\t\tgoto err_periph_clk_disable;\n\t}\n\n\tdrm_mode_config_reset(dev);\n\n\tpm_runtime_get_sync(dev->dev);\n\tret = atmel_hlcdc_dc_irq_install(dev, dc->hlcdc->irq);\n\tpm_runtime_put_sync(dev->dev);\n\tif (ret < 0) {\n\t\tdev_err(dev->dev, \"failed to install IRQ handler\\n\");\n\t\tgoto err_periph_clk_disable;\n\t}\n\n\tplatform_set_drvdata(pdev, dev);\n\n\tdrm_kms_helper_poll_init(dev);\n\n\treturn 0;\n\nerr_periph_clk_disable:\n\tpm_runtime_disable(dev->dev);\n\tclk_disable_unprepare(dc->hlcdc->periph_clk);\n\n\treturn ret;\n}\n\nstatic void atmel_hlcdc_dc_unload(struct drm_device *dev)\n{\n\tstruct atmel_hlcdc_dc *dc = dev->dev_private;\n\n\tdrm_kms_helper_poll_fini(dev);\n\tdrm_atomic_helper_shutdown(dev);\n\tdrm_mode_config_cleanup(dev);\n\n\tpm_runtime_get_sync(dev->dev);\n\tatmel_hlcdc_dc_irq_uninstall(dev);\n\tpm_runtime_put_sync(dev->dev);\n\n\tdev->dev_private = NULL;\n\n\tpm_runtime_disable(dev->dev);\n\tclk_disable_unprepare(dc->hlcdc->periph_clk);\n}\n\nDEFINE_DRM_GEM_DMA_FOPS(fops);\n\nstatic const struct drm_driver atmel_hlcdc_dc_driver = {\n\t.driver_features = DRIVER_GEM | DRIVER_MODESET | DRIVER_ATOMIC,\n\tDRM_GEM_DMA_DRIVER_OPS,\n\t.fops = &fops,\n\t.name = \"atmel-hlcdc\",\n\t.desc = \"Atmel HLCD Controller DRM\",\n\t.date = \"20141504\",\n\t.major = 1,\n\t.minor = 0,\n};\n\nstatic int atmel_hlcdc_dc_drm_probe(struct platform_device *pdev)\n{\n\tstruct drm_device *ddev;\n\tint ret;\n\n\tddev = drm_dev_alloc(&atmel_hlcdc_dc_driver, &pdev->dev);\n\tif (IS_ERR(ddev))\n\t\treturn PTR_ERR(ddev);\n\n\tret = atmel_hlcdc_dc_load(ddev);\n\tif (ret)\n\t\tgoto err_put;\n\n\tret = drm_dev_register(ddev, 0);\n\tif (ret)\n\t\tgoto err_unload;\n\n\tdrm_fbdev_dma_setup(ddev, 24);\n\n\treturn 0;\n\nerr_unload:\n\tatmel_hlcdc_dc_unload(ddev);\n\nerr_put:\n\tdrm_dev_put(ddev);\n\n\treturn ret;\n}\n\nstatic void atmel_hlcdc_dc_drm_remove(struct platform_device *pdev)\n{\n\tstruct drm_device *ddev = platform_get_drvdata(pdev);\n\n\tdrm_dev_unregister(ddev);\n\tatmel_hlcdc_dc_unload(ddev);\n\tdrm_dev_put(ddev);\n}\n\nstatic int atmel_hlcdc_dc_drm_suspend(struct device *dev)\n{\n\tstruct drm_device *drm_dev = dev_get_drvdata(dev);\n\tstruct atmel_hlcdc_dc *dc = drm_dev->dev_private;\n\tstruct regmap *regmap = dc->hlcdc->regmap;\n\tstruct drm_atomic_state *state;\n\n\tstate = drm_atomic_helper_suspend(drm_dev);\n\tif (IS_ERR(state))\n\t\treturn PTR_ERR(state);\n\n\tdc->suspend.state = state;\n\n\tregmap_read(regmap, ATMEL_HLCDC_IMR, &dc->suspend.imr);\n\tregmap_write(regmap, ATMEL_HLCDC_IDR, dc->suspend.imr);\n\tclk_disable_unprepare(dc->hlcdc->periph_clk);\n\n\treturn 0;\n}\n\nstatic int atmel_hlcdc_dc_drm_resume(struct device *dev)\n{\n\tstruct drm_device *drm_dev = dev_get_drvdata(dev);\n\tstruct atmel_hlcdc_dc *dc = drm_dev->dev_private;\n\n\tclk_prepare_enable(dc->hlcdc->periph_clk);\n\tregmap_write(dc->hlcdc->regmap, ATMEL_HLCDC_IER, dc->suspend.imr);\n\n\treturn drm_atomic_helper_resume(drm_dev, dc->suspend.state);\n}\n\nstatic DEFINE_SIMPLE_DEV_PM_OPS(atmel_hlcdc_dc_drm_pm_ops,\n\t\t\t\tatmel_hlcdc_dc_drm_suspend,\n\t\t\t\tatmel_hlcdc_dc_drm_resume);\n\nstatic const struct of_device_id atmel_hlcdc_dc_of_match[] = {\n\t{ .compatible = \"atmel,hlcdc-display-controller\" },\n\t{ },\n};\n\nstatic struct platform_driver atmel_hlcdc_dc_platform_driver = {\n\t.probe\t= atmel_hlcdc_dc_drm_probe,\n\t.remove_new = atmel_hlcdc_dc_drm_remove,\n\t.driver\t= {\n\t\t.name\t= \"atmel-hlcdc-display-controller\",\n\t\t.pm\t= pm_sleep_ptr(&atmel_hlcdc_dc_drm_pm_ops),\n\t\t.of_match_table = atmel_hlcdc_dc_of_match,\n\t},\n};\ndrm_module_platform_driver(atmel_hlcdc_dc_platform_driver);\n\nMODULE_AUTHOR(\"Jean-Jacques Hiblot <jjhiblot@traphandler.com>\");\nMODULE_AUTHOR(\"Boris Brezillon <boris.brezillon@free-electrons.com>\");\nMODULE_DESCRIPTION(\"Atmel HLCDC Display Controller DRM Driver\");\nMODULE_LICENSE(\"GPL\");\nMODULE_ALIAS(\"platform:atmel-hlcdc-dc\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}