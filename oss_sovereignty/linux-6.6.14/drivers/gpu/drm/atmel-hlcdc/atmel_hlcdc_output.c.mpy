{
  "module_name": "atmel_hlcdc_output.c",
  "hash_id": "d762d4b1663db7e6b56de18172556d206174656cc0b402cb47ab591dc350801d",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/atmel-hlcdc/atmel_hlcdc_output.c",
  "human_readable_source": "\n \n\n#include <linux/media-bus-format.h>\n#include <linux/of.h>\n#include <linux/of_graph.h>\n\n#include <drm/drm_bridge.h>\n#include <drm/drm_encoder.h>\n#include <drm/drm_of.h>\n#include <drm/drm_simple_kms_helper.h>\n\n#include \"atmel_hlcdc_dc.h\"\n\nstruct atmel_hlcdc_rgb_output {\n\tstruct drm_encoder encoder;\n\tint bus_fmt;\n};\n\nstatic struct atmel_hlcdc_rgb_output *\natmel_hlcdc_encoder_to_rgb_output(struct drm_encoder *encoder)\n{\n\treturn container_of(encoder, struct atmel_hlcdc_rgb_output, encoder);\n}\n\nint atmel_hlcdc_encoder_get_bus_fmt(struct drm_encoder *encoder)\n{\n\tstruct atmel_hlcdc_rgb_output *output;\n\n\toutput = atmel_hlcdc_encoder_to_rgb_output(encoder);\n\n\treturn output->bus_fmt;\n}\n\nstatic int atmel_hlcdc_of_bus_fmt(const struct device_node *ep)\n{\n\tu32 bus_width;\n\tint ret;\n\n\tret = of_property_read_u32(ep, \"bus-width\", &bus_width);\n\tif (ret == -EINVAL)\n\t\treturn 0;\n\tif (ret)\n\t\treturn ret;\n\n\tswitch (bus_width) {\n\tcase 12:\n\t\treturn MEDIA_BUS_FMT_RGB444_1X12;\n\tcase 16:\n\t\treturn MEDIA_BUS_FMT_RGB565_1X16;\n\tcase 18:\n\t\treturn MEDIA_BUS_FMT_RGB666_1X18;\n\tcase 24:\n\t\treturn MEDIA_BUS_FMT_RGB888_1X24;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic int atmel_hlcdc_attach_endpoint(struct drm_device *dev, int endpoint)\n{\n\tstruct atmel_hlcdc_rgb_output *output;\n\tstruct device_node *ep;\n\tstruct drm_panel *panel;\n\tstruct drm_bridge *bridge;\n\tint ret;\n\n\tep = of_graph_get_endpoint_by_regs(dev->dev->of_node, 0, endpoint);\n\tif (!ep)\n\t\treturn -ENODEV;\n\n\tret = drm_of_find_panel_or_bridge(dev->dev->of_node, 0, endpoint,\n\t\t\t\t\t  &panel, &bridge);\n\tif (ret) {\n\t\tof_node_put(ep);\n\t\treturn ret;\n\t}\n\n\toutput = devm_kzalloc(dev->dev, sizeof(*output), GFP_KERNEL);\n\tif (!output) {\n\t\tof_node_put(ep);\n\t\treturn -ENOMEM;\n\t}\n\n\toutput->bus_fmt = atmel_hlcdc_of_bus_fmt(ep);\n\tof_node_put(ep);\n\tif (output->bus_fmt < 0) {\n\t\tdev_err(dev->dev, \"endpoint %d: invalid bus width\\n\", endpoint);\n\t\treturn -EINVAL;\n\t}\n\n\tret = drm_simple_encoder_init(dev, &output->encoder,\n\t\t\t\t      DRM_MODE_ENCODER_NONE);\n\tif (ret)\n\t\treturn ret;\n\n\toutput->encoder.possible_crtcs = 0x1;\n\n\tif (panel) {\n\t\tbridge = drm_panel_bridge_add_typed(panel,\n\t\t\t\t\t\t    DRM_MODE_CONNECTOR_Unknown);\n\t\tif (IS_ERR(bridge))\n\t\t\treturn PTR_ERR(bridge);\n\t}\n\n\tif (bridge) {\n\t\tret = drm_bridge_attach(&output->encoder, bridge, NULL, 0);\n\t\tif (!ret)\n\t\t\treturn 0;\n\n\t\tif (panel)\n\t\t\tdrm_panel_bridge_remove(bridge);\n\t}\n\n\tdrm_encoder_cleanup(&output->encoder);\n\n\treturn ret;\n}\n\nint atmel_hlcdc_create_outputs(struct drm_device *dev)\n{\n\tint endpoint, ret = 0;\n\tint attached = 0;\n\n\t \n\tfor (endpoint = 0; !ret || endpoint < 4; endpoint++) {\n\t\tret = atmel_hlcdc_attach_endpoint(dev, endpoint);\n\t\tif (ret == -ENODEV)\n\t\t\tcontinue;\n\t\tif (ret)\n\t\t\tbreak;\n\t\tattached++;\n\t}\n\n\t \n\tif (ret == -ENODEV && attached)\n\t\treturn 0;\n\n\treturn ret;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}