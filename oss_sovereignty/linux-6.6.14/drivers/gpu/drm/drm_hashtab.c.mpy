{
  "module_name": "drm_hashtab.c",
  "hash_id": "72709b13ee965c6bf1cbb15e90f85df21053d0c8a1ad1ef8d7b6c201189f1ba2",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/drm_hashtab.c",
  "human_readable_source": " \n \n\n#include <linux/hash.h>\n#include <linux/mm.h>\n#include <linux/rculist.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n\n#include <drm/drm_print.h>\n\n#include \"drm_legacy.h\"\n\nint drm_ht_create(struct drm_open_hash *ht, unsigned int order)\n{\n\tunsigned int size = 1 << order;\n\n\tht->order = order;\n\tht->table = NULL;\n\tif (size <= PAGE_SIZE / sizeof(*ht->table))\n\t\tht->table = kcalloc(size, sizeof(*ht->table), GFP_KERNEL);\n\telse\n\t\tht->table = vzalloc(array_size(size, sizeof(*ht->table)));\n\tif (!ht->table) {\n\t\tDRM_ERROR(\"Out of memory for hash table\\n\");\n\t\treturn -ENOMEM;\n\t}\n\treturn 0;\n}\n\nvoid drm_ht_verbose_list(struct drm_open_hash *ht, unsigned long key)\n{\n\tstruct drm_hash_item *entry;\n\tstruct hlist_head *h_list;\n\tunsigned int hashed_key;\n\tint count = 0;\n\n\thashed_key = hash_long(key, ht->order);\n\tDRM_DEBUG(\"Key is 0x%08lx, Hashed key is 0x%08x\\n\", key, hashed_key);\n\th_list = &ht->table[hashed_key];\n\thlist_for_each_entry(entry, h_list, head)\n\t\tDRM_DEBUG(\"count %d, key: 0x%08lx\\n\", count++, entry->key);\n}\n\nstatic struct hlist_node *drm_ht_find_key(struct drm_open_hash *ht,\n\t\t\t\t\t  unsigned long key)\n{\n\tstruct drm_hash_item *entry;\n\tstruct hlist_head *h_list;\n\tunsigned int hashed_key;\n\n\thashed_key = hash_long(key, ht->order);\n\th_list = &ht->table[hashed_key];\n\thlist_for_each_entry(entry, h_list, head) {\n\t\tif (entry->key == key)\n\t\t\treturn &entry->head;\n\t\tif (entry->key > key)\n\t\t\tbreak;\n\t}\n\treturn NULL;\n}\n\nstatic struct hlist_node *drm_ht_find_key_rcu(struct drm_open_hash *ht,\n\t\t\t\t\t      unsigned long key)\n{\n\tstruct drm_hash_item *entry;\n\tstruct hlist_head *h_list;\n\tunsigned int hashed_key;\n\n\thashed_key = hash_long(key, ht->order);\n\th_list = &ht->table[hashed_key];\n\thlist_for_each_entry_rcu(entry, h_list, head) {\n\t\tif (entry->key == key)\n\t\t\treturn &entry->head;\n\t\tif (entry->key > key)\n\t\t\tbreak;\n\t}\n\treturn NULL;\n}\n\nint drm_ht_insert_item(struct drm_open_hash *ht, struct drm_hash_item *item)\n{\n\tstruct drm_hash_item *entry;\n\tstruct hlist_head *h_list;\n\tstruct hlist_node *parent;\n\tunsigned int hashed_key;\n\tunsigned long key = item->key;\n\n\thashed_key = hash_long(key, ht->order);\n\th_list = &ht->table[hashed_key];\n\tparent = NULL;\n\thlist_for_each_entry(entry, h_list, head) {\n\t\tif (entry->key == key)\n\t\t\treturn -EINVAL;\n\t\tif (entry->key > key)\n\t\t\tbreak;\n\t\tparent = &entry->head;\n\t}\n\tif (parent) {\n\t\thlist_add_behind_rcu(&item->head, parent);\n\t} else {\n\t\thlist_add_head_rcu(&item->head, h_list);\n\t}\n\treturn 0;\n}\n\n \nint drm_ht_just_insert_please(struct drm_open_hash *ht, struct drm_hash_item *item,\n\t\t\t      unsigned long seed, int bits, int shift,\n\t\t\t      unsigned long add)\n{\n\tint ret;\n\tunsigned long mask = (1UL << bits) - 1;\n\tunsigned long first, unshifted_key;\n\n\tunshifted_key = hash_long(seed, bits);\n\tfirst = unshifted_key;\n\tdo {\n\t\titem->key = (unshifted_key << shift) + add;\n\t\tret = drm_ht_insert_item(ht, item);\n\t\tif (ret)\n\t\t\tunshifted_key = (unshifted_key + 1) & mask;\n\t} while(ret && (unshifted_key != first));\n\n\tif (ret) {\n\t\tDRM_ERROR(\"Available key bit space exhausted\\n\");\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}\n\nint drm_ht_find_item(struct drm_open_hash *ht, unsigned long key,\n\t\t     struct drm_hash_item **item)\n{\n\tstruct hlist_node *list;\n\n\tlist = drm_ht_find_key_rcu(ht, key);\n\tif (!list)\n\t\treturn -EINVAL;\n\n\t*item = hlist_entry(list, struct drm_hash_item, head);\n\treturn 0;\n}\n\nint drm_ht_remove_key(struct drm_open_hash *ht, unsigned long key)\n{\n\tstruct hlist_node *list;\n\n\tlist = drm_ht_find_key(ht, key);\n\tif (list) {\n\t\thlist_del_init_rcu(list);\n\t\treturn 0;\n\t}\n\treturn -EINVAL;\n}\n\nint drm_ht_remove_item(struct drm_open_hash *ht, struct drm_hash_item *item)\n{\n\thlist_del_init_rcu(&item->head);\n\treturn 0;\n}\n\nvoid drm_ht_remove(struct drm_open_hash *ht)\n{\n\tif (ht->table) {\n\t\tkvfree(ht->table);\n\t\tht->table = NULL;\n\t}\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}