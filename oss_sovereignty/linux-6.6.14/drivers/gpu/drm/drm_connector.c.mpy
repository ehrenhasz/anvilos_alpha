{
  "module_name": "drm_connector.c",
  "hash_id": "950a67fe21325f619e441f46ab807daf7940056b0f499458c4b6d737b2655c02",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/drm_connector.c",
  "human_readable_source": " \n\n#include <drm/drm_auth.h>\n#include <drm/drm_connector.h>\n#include <drm/drm_drv.h>\n#include <drm/drm_edid.h>\n#include <drm/drm_encoder.h>\n#include <drm/drm_file.h>\n#include <drm/drm_managed.h>\n#include <drm/drm_panel.h>\n#include <drm/drm_print.h>\n#include <drm/drm_privacy_screen_consumer.h>\n#include <drm/drm_sysfs.h>\n#include <drm/drm_utils.h>\n\n#include <linux/property.h>\n#include <linux/uaccess.h>\n\n#include <video/cmdline.h>\n\n#include \"drm_crtc_internal.h\"\n#include \"drm_internal.h\"\n\n \n\n \nstatic DEFINE_MUTEX(connector_list_lock);\nstatic LIST_HEAD(connector_list);\n\nstruct drm_conn_prop_enum_list {\n\tint type;\n\tconst char *name;\n\tstruct ida ida;\n};\n\n \nstatic struct drm_conn_prop_enum_list drm_connector_enum_list[] = {\n\t{ DRM_MODE_CONNECTOR_Unknown, \"Unknown\" },\n\t{ DRM_MODE_CONNECTOR_VGA, \"VGA\" },\n\t{ DRM_MODE_CONNECTOR_DVII, \"DVI-I\" },\n\t{ DRM_MODE_CONNECTOR_DVID, \"DVI-D\" },\n\t{ DRM_MODE_CONNECTOR_DVIA, \"DVI-A\" },\n\t{ DRM_MODE_CONNECTOR_Composite, \"Composite\" },\n\t{ DRM_MODE_CONNECTOR_SVIDEO, \"SVIDEO\" },\n\t{ DRM_MODE_CONNECTOR_LVDS, \"LVDS\" },\n\t{ DRM_MODE_CONNECTOR_Component, \"Component\" },\n\t{ DRM_MODE_CONNECTOR_9PinDIN, \"DIN\" },\n\t{ DRM_MODE_CONNECTOR_DisplayPort, \"DP\" },\n\t{ DRM_MODE_CONNECTOR_HDMIA, \"HDMI-A\" },\n\t{ DRM_MODE_CONNECTOR_HDMIB, \"HDMI-B\" },\n\t{ DRM_MODE_CONNECTOR_TV, \"TV\" },\n\t{ DRM_MODE_CONNECTOR_eDP, \"eDP\" },\n\t{ DRM_MODE_CONNECTOR_VIRTUAL, \"Virtual\" },\n\t{ DRM_MODE_CONNECTOR_DSI, \"DSI\" },\n\t{ DRM_MODE_CONNECTOR_DPI, \"DPI\" },\n\t{ DRM_MODE_CONNECTOR_WRITEBACK, \"Writeback\" },\n\t{ DRM_MODE_CONNECTOR_SPI, \"SPI\" },\n\t{ DRM_MODE_CONNECTOR_USB, \"USB\" },\n};\n\nvoid drm_connector_ida_init(void)\n{\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(drm_connector_enum_list); i++)\n\t\tida_init(&drm_connector_enum_list[i].ida);\n}\n\nvoid drm_connector_ida_destroy(void)\n{\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(drm_connector_enum_list); i++)\n\t\tida_destroy(&drm_connector_enum_list[i].ida);\n}\n\n \nconst char *drm_get_connector_type_name(unsigned int type)\n{\n\tif (type < ARRAY_SIZE(drm_connector_enum_list))\n\t\treturn drm_connector_enum_list[type].name;\n\n\treturn NULL;\n}\nEXPORT_SYMBOL(drm_get_connector_type_name);\n\n \nstatic void drm_connector_get_cmdline_mode(struct drm_connector *connector)\n{\n\tstruct drm_cmdline_mode *mode = &connector->cmdline_mode;\n\tconst char *option;\n\n\toption = video_get_options(connector->name);\n\tif (!option)\n\t\treturn;\n\n\tif (!drm_mode_parse_command_line_for_connector(option,\n\t\t\t\t\t\t       connector,\n\t\t\t\t\t\t       mode))\n\t\treturn;\n\n\tif (mode->force) {\n\t\tDRM_INFO(\"forcing %s connector %s\\n\", connector->name,\n\t\t\t drm_get_connector_force_name(mode->force));\n\t\tconnector->force = mode->force;\n\t}\n\n\tif (mode->panel_orientation != DRM_MODE_PANEL_ORIENTATION_UNKNOWN) {\n\t\tDRM_INFO(\"cmdline forces connector %s panel_orientation to %d\\n\",\n\t\t\t connector->name, mode->panel_orientation);\n\t\tdrm_connector_set_panel_orientation(connector,\n\t\t\t\t\t\t    mode->panel_orientation);\n\t}\n\n\tDRM_DEBUG_KMS(\"cmdline mode for connector %s %s %dx%d@%dHz%s%s%s\\n\",\n\t\t      connector->name, mode->name,\n\t\t      mode->xres, mode->yres,\n\t\t      mode->refresh_specified ? mode->refresh : 60,\n\t\t      mode->rb ? \" reduced blanking\" : \"\",\n\t\t      mode->margins ? \" with margins\" : \"\",\n\t\t      mode->interlace ?  \" interlaced\" : \"\");\n}\n\nstatic void drm_connector_free(struct kref *kref)\n{\n\tstruct drm_connector *connector =\n\t\tcontainer_of(kref, struct drm_connector, base.refcount);\n\tstruct drm_device *dev = connector->dev;\n\n\tdrm_mode_object_unregister(dev, &connector->base);\n\tconnector->funcs->destroy(connector);\n}\n\nvoid drm_connector_free_work_fn(struct work_struct *work)\n{\n\tstruct drm_connector *connector, *n;\n\tstruct drm_device *dev =\n\t\tcontainer_of(work, struct drm_device, mode_config.connector_free_work);\n\tstruct drm_mode_config *config = &dev->mode_config;\n\tunsigned long flags;\n\tstruct llist_node *freed;\n\n\tspin_lock_irqsave(&config->connector_list_lock, flags);\n\tfreed = llist_del_all(&config->connector_free_list);\n\tspin_unlock_irqrestore(&config->connector_list_lock, flags);\n\n\tllist_for_each_entry_safe(connector, n, freed, free_node) {\n\t\tdrm_mode_object_unregister(dev, &connector->base);\n\t\tconnector->funcs->destroy(connector);\n\t}\n}\n\nstatic int __drm_connector_init(struct drm_device *dev,\n\t\t\t\tstruct drm_connector *connector,\n\t\t\t\tconst struct drm_connector_funcs *funcs,\n\t\t\t\tint connector_type,\n\t\t\t\tstruct i2c_adapter *ddc)\n{\n\tstruct drm_mode_config *config = &dev->mode_config;\n\tint ret;\n\tstruct ida *connector_ida =\n\t\t&drm_connector_enum_list[connector_type].ida;\n\n\tWARN_ON(drm_drv_uses_atomic_modeset(dev) &&\n\t\t(!funcs->atomic_destroy_state ||\n\t\t !funcs->atomic_duplicate_state));\n\n\tret = __drm_mode_object_add(dev, &connector->base,\n\t\t\t\t    DRM_MODE_OBJECT_CONNECTOR,\n\t\t\t\t    false, drm_connector_free);\n\tif (ret)\n\t\treturn ret;\n\n\tconnector->base.properties = &connector->properties;\n\tconnector->dev = dev;\n\tconnector->funcs = funcs;\n\n\t \n\tret = ida_alloc_max(&config->connector_ida, 31, GFP_KERNEL);\n\tif (ret < 0) {\n\t\tDRM_DEBUG_KMS(\"Failed to allocate %s connector index: %d\\n\",\n\t\t\t      drm_connector_enum_list[connector_type].name,\n\t\t\t      ret);\n\t\tgoto out_put;\n\t}\n\tconnector->index = ret;\n\tret = 0;\n\n\tconnector->connector_type = connector_type;\n\tconnector->connector_type_id =\n\t\tida_alloc_min(connector_ida, 1, GFP_KERNEL);\n\tif (connector->connector_type_id < 0) {\n\t\tret = connector->connector_type_id;\n\t\tgoto out_put_id;\n\t}\n\tconnector->name =\n\t\tkasprintf(GFP_KERNEL, \"%s-%d\",\n\t\t\t  drm_connector_enum_list[connector_type].name,\n\t\t\t  connector->connector_type_id);\n\tif (!connector->name) {\n\t\tret = -ENOMEM;\n\t\tgoto out_put_type_id;\n\t}\n\n\t \n\tconnector->ddc = ddc;\n\n\tINIT_LIST_HEAD(&connector->global_connector_list_entry);\n\tINIT_LIST_HEAD(&connector->probed_modes);\n\tINIT_LIST_HEAD(&connector->modes);\n\tmutex_init(&connector->mutex);\n\tmutex_init(&connector->edid_override_mutex);\n\tconnector->edid_blob_ptr = NULL;\n\tconnector->epoch_counter = 0;\n\tconnector->tile_blob_ptr = NULL;\n\tconnector->status = connector_status_unknown;\n\tconnector->display_info.panel_orientation =\n\t\tDRM_MODE_PANEL_ORIENTATION_UNKNOWN;\n\n\tdrm_connector_get_cmdline_mode(connector);\n\n\t \n\tspin_lock_irq(&config->connector_list_lock);\n\tlist_add_tail(&connector->head, &config->connector_list);\n\tconfig->num_connector++;\n\tspin_unlock_irq(&config->connector_list_lock);\n\n\tif (connector_type != DRM_MODE_CONNECTOR_VIRTUAL &&\n\t    connector_type != DRM_MODE_CONNECTOR_WRITEBACK)\n\t\tdrm_connector_attach_edid_property(connector);\n\n\tdrm_object_attach_property(&connector->base,\n\t\t\t\t      config->dpms_property, 0);\n\n\tdrm_object_attach_property(&connector->base,\n\t\t\t\t   config->link_status_property,\n\t\t\t\t   0);\n\n\tdrm_object_attach_property(&connector->base,\n\t\t\t\t   config->non_desktop_property,\n\t\t\t\t   0);\n\tdrm_object_attach_property(&connector->base,\n\t\t\t\t   config->tile_property,\n\t\t\t\t   0);\n\n\tif (drm_core_check_feature(dev, DRIVER_ATOMIC)) {\n\t\tdrm_object_attach_property(&connector->base, config->prop_crtc_id, 0);\n\t}\n\n\tconnector->debugfs_entry = NULL;\nout_put_type_id:\n\tif (ret)\n\t\tida_free(connector_ida, connector->connector_type_id);\nout_put_id:\n\tif (ret)\n\t\tida_free(&config->connector_ida, connector->index);\nout_put:\n\tif (ret)\n\t\tdrm_mode_object_unregister(dev, &connector->base);\n\n\treturn ret;\n}\n\n \nint drm_connector_init(struct drm_device *dev,\n\t\t       struct drm_connector *connector,\n\t\t       const struct drm_connector_funcs *funcs,\n\t\t       int connector_type)\n{\n\tif (drm_WARN_ON(dev, !(funcs && funcs->destroy)))\n\t\treturn -EINVAL;\n\n\treturn __drm_connector_init(dev, connector, funcs, connector_type, NULL);\n}\nEXPORT_SYMBOL(drm_connector_init);\n\n \nint drm_connector_init_with_ddc(struct drm_device *dev,\n\t\t\t\tstruct drm_connector *connector,\n\t\t\t\tconst struct drm_connector_funcs *funcs,\n\t\t\t\tint connector_type,\n\t\t\t\tstruct i2c_adapter *ddc)\n{\n\tif (drm_WARN_ON(dev, !(funcs && funcs->destroy)))\n\t\treturn -EINVAL;\n\n\treturn __drm_connector_init(dev, connector, funcs, connector_type, ddc);\n}\nEXPORT_SYMBOL(drm_connector_init_with_ddc);\n\nstatic void drm_connector_cleanup_action(struct drm_device *dev,\n\t\t\t\t\t void *ptr)\n{\n\tstruct drm_connector *connector = ptr;\n\n\tdrm_connector_cleanup(connector);\n}\n\n \nint drmm_connector_init(struct drm_device *dev,\n\t\t\tstruct drm_connector *connector,\n\t\t\tconst struct drm_connector_funcs *funcs,\n\t\t\tint connector_type,\n\t\t\tstruct i2c_adapter *ddc)\n{\n\tint ret;\n\n\tif (drm_WARN_ON(dev, funcs && funcs->destroy))\n\t\treturn -EINVAL;\n\n\tret = __drm_connector_init(dev, connector, funcs, connector_type, ddc);\n\tif (ret)\n\t\treturn ret;\n\n\tret = drmm_add_action_or_reset(dev, drm_connector_cleanup_action,\n\t\t\t\t       connector);\n\tif (ret)\n\t\treturn ret;\n\n\treturn 0;\n}\nEXPORT_SYMBOL(drmm_connector_init);\n\n \nvoid drm_connector_attach_edid_property(struct drm_connector *connector)\n{\n\tstruct drm_mode_config *config = &connector->dev->mode_config;\n\n\tdrm_object_attach_property(&connector->base,\n\t\t\t\t   config->edid_property,\n\t\t\t\t   0);\n}\nEXPORT_SYMBOL(drm_connector_attach_edid_property);\n\n \nint drm_connector_attach_encoder(struct drm_connector *connector,\n\t\t\t\t struct drm_encoder *encoder)\n{\n\t \n\tif (WARN_ON(connector->encoder))\n\t\treturn -EINVAL;\n\n\tconnector->possible_encoders |= drm_encoder_mask(encoder);\n\n\treturn 0;\n}\nEXPORT_SYMBOL(drm_connector_attach_encoder);\n\n \nbool drm_connector_has_possible_encoder(struct drm_connector *connector,\n\t\t\t\t\tstruct drm_encoder *encoder)\n{\n\treturn connector->possible_encoders & drm_encoder_mask(encoder);\n}\nEXPORT_SYMBOL(drm_connector_has_possible_encoder);\n\nstatic void drm_mode_remove(struct drm_connector *connector,\n\t\t\t    struct drm_display_mode *mode)\n{\n\tlist_del(&mode->head);\n\tdrm_mode_destroy(connector->dev, mode);\n}\n\n \nvoid drm_connector_cleanup(struct drm_connector *connector)\n{\n\tstruct drm_device *dev = connector->dev;\n\tstruct drm_display_mode *mode, *t;\n\n\t \n\tif (WARN_ON(connector->registration_state ==\n\t\t    DRM_CONNECTOR_REGISTERED))\n\t\tdrm_connector_unregister(connector);\n\n\tif (connector->privacy_screen) {\n\t\tdrm_privacy_screen_put(connector->privacy_screen);\n\t\tconnector->privacy_screen = NULL;\n\t}\n\n\tif (connector->tile_group) {\n\t\tdrm_mode_put_tile_group(dev, connector->tile_group);\n\t\tconnector->tile_group = NULL;\n\t}\n\n\tlist_for_each_entry_safe(mode, t, &connector->probed_modes, head)\n\t\tdrm_mode_remove(connector, mode);\n\n\tlist_for_each_entry_safe(mode, t, &connector->modes, head)\n\t\tdrm_mode_remove(connector, mode);\n\n\tida_free(&drm_connector_enum_list[connector->connector_type].ida,\n\t\t\t  connector->connector_type_id);\n\n\tida_free(&dev->mode_config.connector_ida, connector->index);\n\n\tkfree(connector->display_info.bus_formats);\n\tkfree(connector->display_info.vics);\n\tdrm_mode_object_unregister(dev, &connector->base);\n\tkfree(connector->name);\n\tconnector->name = NULL;\n\tfwnode_handle_put(connector->fwnode);\n\tconnector->fwnode = NULL;\n\tspin_lock_irq(&dev->mode_config.connector_list_lock);\n\tlist_del(&connector->head);\n\tdev->mode_config.num_connector--;\n\tspin_unlock_irq(&dev->mode_config.connector_list_lock);\n\n\tWARN_ON(connector->state && !connector->funcs->atomic_destroy_state);\n\tif (connector->state && connector->funcs->atomic_destroy_state)\n\t\tconnector->funcs->atomic_destroy_state(connector,\n\t\t\t\t\t\t       connector->state);\n\n\tmutex_destroy(&connector->mutex);\n\n\tmemset(connector, 0, sizeof(*connector));\n\n\tif (dev->registered)\n\t\tdrm_sysfs_hotplug_event(dev);\n}\nEXPORT_SYMBOL(drm_connector_cleanup);\n\n \nint drm_connector_register(struct drm_connector *connector)\n{\n\tint ret = 0;\n\n\tif (!connector->dev->registered)\n\t\treturn 0;\n\n\tmutex_lock(&connector->mutex);\n\tif (connector->registration_state != DRM_CONNECTOR_INITIALIZING)\n\t\tgoto unlock;\n\n\tret = drm_sysfs_connector_add(connector);\n\tif (ret)\n\t\tgoto unlock;\n\n\tdrm_debugfs_connector_add(connector);\n\n\tif (connector->funcs->late_register) {\n\t\tret = connector->funcs->late_register(connector);\n\t\tif (ret)\n\t\t\tgoto err_debugfs;\n\t}\n\n\tdrm_mode_object_register(connector->dev, &connector->base);\n\n\tconnector->registration_state = DRM_CONNECTOR_REGISTERED;\n\n\t \n\tdrm_sysfs_connector_hotplug_event(connector);\n\n\tif (connector->privacy_screen)\n\t\tdrm_privacy_screen_register_notifier(connector->privacy_screen,\n\t\t\t\t\t   &connector->privacy_screen_notifier);\n\n\tmutex_lock(&connector_list_lock);\n\tlist_add_tail(&connector->global_connector_list_entry, &connector_list);\n\tmutex_unlock(&connector_list_lock);\n\tgoto unlock;\n\nerr_debugfs:\n\tdrm_debugfs_connector_remove(connector);\n\tdrm_sysfs_connector_remove(connector);\nunlock:\n\tmutex_unlock(&connector->mutex);\n\treturn ret;\n}\nEXPORT_SYMBOL(drm_connector_register);\n\n \nvoid drm_connector_unregister(struct drm_connector *connector)\n{\n\tmutex_lock(&connector->mutex);\n\tif (connector->registration_state != DRM_CONNECTOR_REGISTERED) {\n\t\tmutex_unlock(&connector->mutex);\n\t\treturn;\n\t}\n\n\tmutex_lock(&connector_list_lock);\n\tlist_del_init(&connector->global_connector_list_entry);\n\tmutex_unlock(&connector_list_lock);\n\n\tif (connector->privacy_screen)\n\t\tdrm_privacy_screen_unregister_notifier(\n\t\t\t\t\tconnector->privacy_screen,\n\t\t\t\t\t&connector->privacy_screen_notifier);\n\n\tif (connector->funcs->early_unregister)\n\t\tconnector->funcs->early_unregister(connector);\n\n\tdrm_sysfs_connector_remove(connector);\n\tdrm_debugfs_connector_remove(connector);\n\n\tconnector->registration_state = DRM_CONNECTOR_UNREGISTERED;\n\tmutex_unlock(&connector->mutex);\n}\nEXPORT_SYMBOL(drm_connector_unregister);\n\nvoid drm_connector_unregister_all(struct drm_device *dev)\n{\n\tstruct drm_connector *connector;\n\tstruct drm_connector_list_iter conn_iter;\n\n\tdrm_connector_list_iter_begin(dev, &conn_iter);\n\tdrm_for_each_connector_iter(connector, &conn_iter)\n\t\tdrm_connector_unregister(connector);\n\tdrm_connector_list_iter_end(&conn_iter);\n}\n\nint drm_connector_register_all(struct drm_device *dev)\n{\n\tstruct drm_connector *connector;\n\tstruct drm_connector_list_iter conn_iter;\n\tint ret = 0;\n\n\tdrm_connector_list_iter_begin(dev, &conn_iter);\n\tdrm_for_each_connector_iter(connector, &conn_iter) {\n\t\tret = drm_connector_register(connector);\n\t\tif (ret)\n\t\t\tbreak;\n\t}\n\tdrm_connector_list_iter_end(&conn_iter);\n\n\tif (ret)\n\t\tdrm_connector_unregister_all(dev);\n\treturn ret;\n}\n\n \nconst char *drm_get_connector_status_name(enum drm_connector_status status)\n{\n\tif (status == connector_status_connected)\n\t\treturn \"connected\";\n\telse if (status == connector_status_disconnected)\n\t\treturn \"disconnected\";\n\telse\n\t\treturn \"unknown\";\n}\nEXPORT_SYMBOL(drm_get_connector_status_name);\n\n \nconst char *drm_get_connector_force_name(enum drm_connector_force force)\n{\n\tswitch (force) {\n\tcase DRM_FORCE_UNSPECIFIED:\n\t\treturn \"unspecified\";\n\tcase DRM_FORCE_OFF:\n\t\treturn \"off\";\n\tcase DRM_FORCE_ON:\n\t\treturn \"on\";\n\tcase DRM_FORCE_ON_DIGITAL:\n\t\treturn \"digital\";\n\tdefault:\n\t\treturn \"unknown\";\n\t}\n}\n\n#ifdef CONFIG_LOCKDEP\nstatic struct lockdep_map connector_list_iter_dep_map = {\n\t.name = \"drm_connector_list_iter\"\n};\n#endif\n\n \nvoid drm_connector_list_iter_begin(struct drm_device *dev,\n\t\t\t\t   struct drm_connector_list_iter *iter)\n{\n\titer->dev = dev;\n\titer->conn = NULL;\n\tlock_acquire_shared_recursive(&connector_list_iter_dep_map, 0, 1, NULL, _RET_IP_);\n}\nEXPORT_SYMBOL(drm_connector_list_iter_begin);\n\n \nstatic void\n__drm_connector_put_safe(struct drm_connector *conn)\n{\n\tstruct drm_mode_config *config = &conn->dev->mode_config;\n\n\tlockdep_assert_held(&config->connector_list_lock);\n\n\tif (!refcount_dec_and_test(&conn->base.refcount.refcount))\n\t\treturn;\n\n\tllist_add(&conn->free_node, &config->connector_free_list);\n\tschedule_work(&config->connector_free_work);\n}\n\n \nstruct drm_connector *\ndrm_connector_list_iter_next(struct drm_connector_list_iter *iter)\n{\n\tstruct drm_connector *old_conn = iter->conn;\n\tstruct drm_mode_config *config = &iter->dev->mode_config;\n\tstruct list_head *lhead;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&config->connector_list_lock, flags);\n\tlhead = old_conn ? &old_conn->head : &config->connector_list;\n\n\tdo {\n\t\tif (lhead->next == &config->connector_list) {\n\t\t\titer->conn = NULL;\n\t\t\tbreak;\n\t\t}\n\n\t\tlhead = lhead->next;\n\t\titer->conn = list_entry(lhead, struct drm_connector, head);\n\n\t\t \n\t} while (!kref_get_unless_zero(&iter->conn->base.refcount));\n\n\tif (old_conn)\n\t\t__drm_connector_put_safe(old_conn);\n\tspin_unlock_irqrestore(&config->connector_list_lock, flags);\n\n\treturn iter->conn;\n}\nEXPORT_SYMBOL(drm_connector_list_iter_next);\n\n \nvoid drm_connector_list_iter_end(struct drm_connector_list_iter *iter)\n{\n\tstruct drm_mode_config *config = &iter->dev->mode_config;\n\tunsigned long flags;\n\n\titer->dev = NULL;\n\tif (iter->conn) {\n\t\tspin_lock_irqsave(&config->connector_list_lock, flags);\n\t\t__drm_connector_put_safe(iter->conn);\n\t\tspin_unlock_irqrestore(&config->connector_list_lock, flags);\n\t}\n\tlock_release(&connector_list_iter_dep_map, _RET_IP_);\n}\nEXPORT_SYMBOL(drm_connector_list_iter_end);\n\nstatic const struct drm_prop_enum_list drm_subpixel_enum_list[] = {\n\t{ SubPixelUnknown, \"Unknown\" },\n\t{ SubPixelHorizontalRGB, \"Horizontal RGB\" },\n\t{ SubPixelHorizontalBGR, \"Horizontal BGR\" },\n\t{ SubPixelVerticalRGB, \"Vertical RGB\" },\n\t{ SubPixelVerticalBGR, \"Vertical BGR\" },\n\t{ SubPixelNone, \"None\" },\n};\n\n \nconst char *drm_get_subpixel_order_name(enum subpixel_order order)\n{\n\treturn drm_subpixel_enum_list[order].name;\n}\nEXPORT_SYMBOL(drm_get_subpixel_order_name);\n\nstatic const struct drm_prop_enum_list drm_dpms_enum_list[] = {\n\t{ DRM_MODE_DPMS_ON, \"On\" },\n\t{ DRM_MODE_DPMS_STANDBY, \"Standby\" },\n\t{ DRM_MODE_DPMS_SUSPEND, \"Suspend\" },\n\t{ DRM_MODE_DPMS_OFF, \"Off\" }\n};\nDRM_ENUM_NAME_FN(drm_get_dpms_name, drm_dpms_enum_list)\n\nstatic const struct drm_prop_enum_list drm_link_status_enum_list[] = {\n\t{ DRM_MODE_LINK_STATUS_GOOD, \"Good\" },\n\t{ DRM_MODE_LINK_STATUS_BAD, \"Bad\" },\n};\n\n \nint drm_display_info_set_bus_formats(struct drm_display_info *info,\n\t\t\t\t     const u32 *formats,\n\t\t\t\t     unsigned int num_formats)\n{\n\tu32 *fmts = NULL;\n\n\tif (!formats && num_formats)\n\t\treturn -EINVAL;\n\n\tif (formats && num_formats) {\n\t\tfmts = kmemdup(formats, sizeof(*formats) * num_formats,\n\t\t\t       GFP_KERNEL);\n\t\tif (!fmts)\n\t\t\treturn -ENOMEM;\n\t}\n\n\tkfree(info->bus_formats);\n\tinfo->bus_formats = fmts;\n\tinfo->num_bus_formats = num_formats;\n\n\treturn 0;\n}\nEXPORT_SYMBOL(drm_display_info_set_bus_formats);\n\n \nstatic const struct drm_prop_enum_list drm_scaling_mode_enum_list[] = {\n\t{ DRM_MODE_SCALE_NONE, \"None\" },\n\t{ DRM_MODE_SCALE_FULLSCREEN, \"Full\" },\n\t{ DRM_MODE_SCALE_CENTER, \"Center\" },\n\t{ DRM_MODE_SCALE_ASPECT, \"Full aspect\" },\n};\n\nstatic const struct drm_prop_enum_list drm_aspect_ratio_enum_list[] = {\n\t{ DRM_MODE_PICTURE_ASPECT_NONE, \"Automatic\" },\n\t{ DRM_MODE_PICTURE_ASPECT_4_3, \"4:3\" },\n\t{ DRM_MODE_PICTURE_ASPECT_16_9, \"16:9\" },\n};\n\nstatic const struct drm_prop_enum_list drm_content_type_enum_list[] = {\n\t{ DRM_MODE_CONTENT_TYPE_NO_DATA, \"No Data\" },\n\t{ DRM_MODE_CONTENT_TYPE_GRAPHICS, \"Graphics\" },\n\t{ DRM_MODE_CONTENT_TYPE_PHOTO, \"Photo\" },\n\t{ DRM_MODE_CONTENT_TYPE_CINEMA, \"Cinema\" },\n\t{ DRM_MODE_CONTENT_TYPE_GAME, \"Game\" },\n};\n\nstatic const struct drm_prop_enum_list drm_panel_orientation_enum_list[] = {\n\t{ DRM_MODE_PANEL_ORIENTATION_NORMAL,\t\"Normal\"\t},\n\t{ DRM_MODE_PANEL_ORIENTATION_BOTTOM_UP,\t\"Upside Down\"\t},\n\t{ DRM_MODE_PANEL_ORIENTATION_LEFT_UP,\t\"Left Side Up\"\t},\n\t{ DRM_MODE_PANEL_ORIENTATION_RIGHT_UP,\t\"Right Side Up\"\t},\n};\n\nstatic const struct drm_prop_enum_list drm_dvi_i_select_enum_list[] = {\n\t{ DRM_MODE_SUBCONNECTOR_Automatic, \"Automatic\" },  \n\t{ DRM_MODE_SUBCONNECTOR_DVID,      \"DVI-D\"     },  \n\t{ DRM_MODE_SUBCONNECTOR_DVIA,      \"DVI-A\"     },  \n};\nDRM_ENUM_NAME_FN(drm_get_dvi_i_select_name, drm_dvi_i_select_enum_list)\n\nstatic const struct drm_prop_enum_list drm_dvi_i_subconnector_enum_list[] = {\n\t{ DRM_MODE_SUBCONNECTOR_Unknown,   \"Unknown\"   },  \n\t{ DRM_MODE_SUBCONNECTOR_DVID,      \"DVI-D\"     },  \n\t{ DRM_MODE_SUBCONNECTOR_DVIA,      \"DVI-A\"     },  \n};\nDRM_ENUM_NAME_FN(drm_get_dvi_i_subconnector_name,\n\t\t drm_dvi_i_subconnector_enum_list)\n\nstatic const struct drm_prop_enum_list drm_tv_mode_enum_list[] = {\n\t{ DRM_MODE_TV_MODE_NTSC, \"NTSC\" },\n\t{ DRM_MODE_TV_MODE_NTSC_443, \"NTSC-443\" },\n\t{ DRM_MODE_TV_MODE_NTSC_J, \"NTSC-J\" },\n\t{ DRM_MODE_TV_MODE_PAL, \"PAL\" },\n\t{ DRM_MODE_TV_MODE_PAL_M, \"PAL-M\" },\n\t{ DRM_MODE_TV_MODE_PAL_N, \"PAL-N\" },\n\t{ DRM_MODE_TV_MODE_SECAM, \"SECAM\" },\n};\nDRM_ENUM_NAME_FN(drm_get_tv_mode_name, drm_tv_mode_enum_list)\n\n \nint drm_get_tv_mode_from_name(const char *name, size_t len)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < ARRAY_SIZE(drm_tv_mode_enum_list); i++) {\n\t\tconst struct drm_prop_enum_list *item = &drm_tv_mode_enum_list[i];\n\n\t\tif (strlen(item->name) == len && !strncmp(item->name, name, len))\n\t\t\treturn item->type;\n\t}\n\n\treturn -EINVAL;\n}\nEXPORT_SYMBOL(drm_get_tv_mode_from_name);\n\nstatic const struct drm_prop_enum_list drm_tv_select_enum_list[] = {\n\t{ DRM_MODE_SUBCONNECTOR_Automatic, \"Automatic\" },  \n\t{ DRM_MODE_SUBCONNECTOR_Composite, \"Composite\" },  \n\t{ DRM_MODE_SUBCONNECTOR_SVIDEO,    \"SVIDEO\"    },  \n\t{ DRM_MODE_SUBCONNECTOR_Component, \"Component\" },  \n\t{ DRM_MODE_SUBCONNECTOR_SCART,     \"SCART\"     },  \n};\nDRM_ENUM_NAME_FN(drm_get_tv_select_name, drm_tv_select_enum_list)\n\nstatic const struct drm_prop_enum_list drm_tv_subconnector_enum_list[] = {\n\t{ DRM_MODE_SUBCONNECTOR_Unknown,   \"Unknown\"   },  \n\t{ DRM_MODE_SUBCONNECTOR_Composite, \"Composite\" },  \n\t{ DRM_MODE_SUBCONNECTOR_SVIDEO,    \"SVIDEO\"    },  \n\t{ DRM_MODE_SUBCONNECTOR_Component, \"Component\" },  \n\t{ DRM_MODE_SUBCONNECTOR_SCART,     \"SCART\"     },  \n};\nDRM_ENUM_NAME_FN(drm_get_tv_subconnector_name,\n\t\t drm_tv_subconnector_enum_list)\n\nstatic const struct drm_prop_enum_list drm_dp_subconnector_enum_list[] = {\n\t{ DRM_MODE_SUBCONNECTOR_Unknown,     \"Unknown\"   },  \n\t{ DRM_MODE_SUBCONNECTOR_VGA,\t     \"VGA\"       },  \n\t{ DRM_MODE_SUBCONNECTOR_DVID,\t     \"DVI-D\"     },  \n\t{ DRM_MODE_SUBCONNECTOR_HDMIA,\t     \"HDMI\"      },  \n\t{ DRM_MODE_SUBCONNECTOR_DisplayPort, \"DP\"        },  \n\t{ DRM_MODE_SUBCONNECTOR_Wireless,    \"Wireless\"  },  \n\t{ DRM_MODE_SUBCONNECTOR_Native,\t     \"Native\"    },  \n};\n\nDRM_ENUM_NAME_FN(drm_get_dp_subconnector_name,\n\t\t drm_dp_subconnector_enum_list)\n\n\nstatic const char * const colorspace_names[] = {\n\t \n\t[DRM_MODE_COLORIMETRY_DEFAULT] = \"Default\",\n\t \n\t[DRM_MODE_COLORIMETRY_SMPTE_170M_YCC] = \"SMPTE_170M_YCC\",\n\t[DRM_MODE_COLORIMETRY_BT709_YCC] = \"BT709_YCC\",\n\t \n\t[DRM_MODE_COLORIMETRY_XVYCC_601] = \"XVYCC_601\",\n\t \n\t[DRM_MODE_COLORIMETRY_XVYCC_709] = \"XVYCC_709\",\n\t \n\t[DRM_MODE_COLORIMETRY_SYCC_601] = \"SYCC_601\",\n\t \n\t[DRM_MODE_COLORIMETRY_OPYCC_601] = \"opYCC_601\",\n\t \n\t[DRM_MODE_COLORIMETRY_OPRGB] = \"opRGB\",\n\t \n\t[DRM_MODE_COLORIMETRY_BT2020_CYCC] = \"BT2020_CYCC\",\n\t \n\t[DRM_MODE_COLORIMETRY_BT2020_RGB] = \"BT2020_RGB\",\n\t \n\t[DRM_MODE_COLORIMETRY_BT2020_YCC] = \"BT2020_YCC\",\n\t \n\t[DRM_MODE_COLORIMETRY_DCI_P3_RGB_D65] = \"DCI-P3_RGB_D65\",\n\t[DRM_MODE_COLORIMETRY_DCI_P3_RGB_THEATER] = \"DCI-P3_RGB_Theater\",\n\t[DRM_MODE_COLORIMETRY_RGB_WIDE_FIXED] = \"RGB_WIDE_FIXED\",\n\t \n\t[DRM_MODE_COLORIMETRY_RGB_WIDE_FLOAT] = \"RGB_WIDE_FLOAT\",\n\t[DRM_MODE_COLORIMETRY_BT601_YCC] = \"BT601_YCC\",\n};\n\n \nconst char *drm_get_colorspace_name(enum drm_colorspace colorspace)\n{\n\tif (colorspace < ARRAY_SIZE(colorspace_names) && colorspace_names[colorspace])\n\t\treturn colorspace_names[colorspace];\n\telse\n\t\treturn \"(null)\";\n}\n\nstatic const u32 hdmi_colorspaces =\n\tBIT(DRM_MODE_COLORIMETRY_SMPTE_170M_YCC) |\n\tBIT(DRM_MODE_COLORIMETRY_BT709_YCC) |\n\tBIT(DRM_MODE_COLORIMETRY_XVYCC_601) |\n\tBIT(DRM_MODE_COLORIMETRY_XVYCC_709) |\n\tBIT(DRM_MODE_COLORIMETRY_SYCC_601) |\n\tBIT(DRM_MODE_COLORIMETRY_OPYCC_601) |\n\tBIT(DRM_MODE_COLORIMETRY_OPRGB) |\n\tBIT(DRM_MODE_COLORIMETRY_BT2020_CYCC) |\n\tBIT(DRM_MODE_COLORIMETRY_BT2020_RGB) |\n\tBIT(DRM_MODE_COLORIMETRY_BT2020_YCC) |\n\tBIT(DRM_MODE_COLORIMETRY_DCI_P3_RGB_D65) |\n\tBIT(DRM_MODE_COLORIMETRY_DCI_P3_RGB_THEATER);\n\n \nstatic const u32 dp_colorspaces =\n\tBIT(DRM_MODE_COLORIMETRY_RGB_WIDE_FIXED) |\n\tBIT(DRM_MODE_COLORIMETRY_RGB_WIDE_FLOAT) |\n\tBIT(DRM_MODE_COLORIMETRY_OPRGB) |\n\tBIT(DRM_MODE_COLORIMETRY_DCI_P3_RGB_D65) |\n\tBIT(DRM_MODE_COLORIMETRY_BT2020_RGB) |\n\tBIT(DRM_MODE_COLORIMETRY_BT601_YCC) |\n\tBIT(DRM_MODE_COLORIMETRY_BT709_YCC) |\n\tBIT(DRM_MODE_COLORIMETRY_XVYCC_601) |\n\tBIT(DRM_MODE_COLORIMETRY_XVYCC_709) |\n\tBIT(DRM_MODE_COLORIMETRY_SYCC_601) |\n\tBIT(DRM_MODE_COLORIMETRY_OPYCC_601) |\n\tBIT(DRM_MODE_COLORIMETRY_BT2020_CYCC) |\n\tBIT(DRM_MODE_COLORIMETRY_BT2020_YCC);\n\n \n\nint drm_connector_create_standard_properties(struct drm_device *dev)\n{\n\tstruct drm_property *prop;\n\n\tprop = drm_property_create(dev, DRM_MODE_PROP_BLOB |\n\t\t\t\t   DRM_MODE_PROP_IMMUTABLE,\n\t\t\t\t   \"EDID\", 0);\n\tif (!prop)\n\t\treturn -ENOMEM;\n\tdev->mode_config.edid_property = prop;\n\n\tprop = drm_property_create_enum(dev, 0,\n\t\t\t\t   \"DPMS\", drm_dpms_enum_list,\n\t\t\t\t   ARRAY_SIZE(drm_dpms_enum_list));\n\tif (!prop)\n\t\treturn -ENOMEM;\n\tdev->mode_config.dpms_property = prop;\n\n\tprop = drm_property_create(dev,\n\t\t\t\t   DRM_MODE_PROP_BLOB |\n\t\t\t\t   DRM_MODE_PROP_IMMUTABLE,\n\t\t\t\t   \"PATH\", 0);\n\tif (!prop)\n\t\treturn -ENOMEM;\n\tdev->mode_config.path_property = prop;\n\n\tprop = drm_property_create(dev,\n\t\t\t\t   DRM_MODE_PROP_BLOB |\n\t\t\t\t   DRM_MODE_PROP_IMMUTABLE,\n\t\t\t\t   \"TILE\", 0);\n\tif (!prop)\n\t\treturn -ENOMEM;\n\tdev->mode_config.tile_property = prop;\n\n\tprop = drm_property_create_enum(dev, 0, \"link-status\",\n\t\t\t\t\tdrm_link_status_enum_list,\n\t\t\t\t\tARRAY_SIZE(drm_link_status_enum_list));\n\tif (!prop)\n\t\treturn -ENOMEM;\n\tdev->mode_config.link_status_property = prop;\n\n\tprop = drm_property_create_bool(dev, DRM_MODE_PROP_IMMUTABLE, \"non-desktop\");\n\tif (!prop)\n\t\treturn -ENOMEM;\n\tdev->mode_config.non_desktop_property = prop;\n\n\tprop = drm_property_create(dev, DRM_MODE_PROP_BLOB,\n\t\t\t\t   \"HDR_OUTPUT_METADATA\", 0);\n\tif (!prop)\n\t\treturn -ENOMEM;\n\tdev->mode_config.hdr_output_metadata_property = prop;\n\n\treturn 0;\n}\n\n \nint drm_mode_create_dvi_i_properties(struct drm_device *dev)\n{\n\tstruct drm_property *dvi_i_selector;\n\tstruct drm_property *dvi_i_subconnector;\n\n\tif (dev->mode_config.dvi_i_select_subconnector_property)\n\t\treturn 0;\n\n\tdvi_i_selector =\n\t\tdrm_property_create_enum(dev, 0,\n\t\t\t\t    \"select subconnector\",\n\t\t\t\t    drm_dvi_i_select_enum_list,\n\t\t\t\t    ARRAY_SIZE(drm_dvi_i_select_enum_list));\n\tdev->mode_config.dvi_i_select_subconnector_property = dvi_i_selector;\n\n\tdvi_i_subconnector = drm_property_create_enum(dev, DRM_MODE_PROP_IMMUTABLE,\n\t\t\t\t    \"subconnector\",\n\t\t\t\t    drm_dvi_i_subconnector_enum_list,\n\t\t\t\t    ARRAY_SIZE(drm_dvi_i_subconnector_enum_list));\n\tdev->mode_config.dvi_i_subconnector_property = dvi_i_subconnector;\n\n\treturn 0;\n}\nEXPORT_SYMBOL(drm_mode_create_dvi_i_properties);\n\n \nvoid drm_connector_attach_dp_subconnector_property(struct drm_connector *connector)\n{\n\tstruct drm_mode_config *mode_config = &connector->dev->mode_config;\n\n\tif (!mode_config->dp_subconnector_property)\n\t\tmode_config->dp_subconnector_property =\n\t\t\tdrm_property_create_enum(connector->dev,\n\t\t\t\tDRM_MODE_PROP_IMMUTABLE,\n\t\t\t\t\"subconnector\",\n\t\t\t\tdrm_dp_subconnector_enum_list,\n\t\t\t\tARRAY_SIZE(drm_dp_subconnector_enum_list));\n\n\tdrm_object_attach_property(&connector->base,\n\t\t\t\t   mode_config->dp_subconnector_property,\n\t\t\t\t   DRM_MODE_SUBCONNECTOR_Unknown);\n}\nEXPORT_SYMBOL(drm_connector_attach_dp_subconnector_property);\n\n \n\n \n \n\n \nint drm_connector_attach_content_type_property(struct drm_connector *connector)\n{\n\tif (!drm_mode_create_content_type_property(connector->dev))\n\t\tdrm_object_attach_property(&connector->base,\n\t\t\t\t\t   connector->dev->mode_config.content_type_property,\n\t\t\t\t\t   DRM_MODE_CONTENT_TYPE_NO_DATA);\n\treturn 0;\n}\nEXPORT_SYMBOL(drm_connector_attach_content_type_property);\n\n \nvoid drm_connector_attach_tv_margin_properties(struct drm_connector *connector)\n{\n\tstruct drm_device *dev = connector->dev;\n\n\tdrm_object_attach_property(&connector->base,\n\t\t\t\t   dev->mode_config.tv_left_margin_property,\n\t\t\t\t   0);\n\tdrm_object_attach_property(&connector->base,\n\t\t\t\t   dev->mode_config.tv_right_margin_property,\n\t\t\t\t   0);\n\tdrm_object_attach_property(&connector->base,\n\t\t\t\t   dev->mode_config.tv_top_margin_property,\n\t\t\t\t   0);\n\tdrm_object_attach_property(&connector->base,\n\t\t\t\t   dev->mode_config.tv_bottom_margin_property,\n\t\t\t\t   0);\n}\nEXPORT_SYMBOL(drm_connector_attach_tv_margin_properties);\n\n \nint drm_mode_create_tv_margin_properties(struct drm_device *dev)\n{\n\tif (dev->mode_config.tv_left_margin_property)\n\t\treturn 0;\n\n\tdev->mode_config.tv_left_margin_property =\n\t\tdrm_property_create_range(dev, 0, \"left margin\", 0, 100);\n\tif (!dev->mode_config.tv_left_margin_property)\n\t\treturn -ENOMEM;\n\n\tdev->mode_config.tv_right_margin_property =\n\t\tdrm_property_create_range(dev, 0, \"right margin\", 0, 100);\n\tif (!dev->mode_config.tv_right_margin_property)\n\t\treturn -ENOMEM;\n\n\tdev->mode_config.tv_top_margin_property =\n\t\tdrm_property_create_range(dev, 0, \"top margin\", 0, 100);\n\tif (!dev->mode_config.tv_top_margin_property)\n\t\treturn -ENOMEM;\n\n\tdev->mode_config.tv_bottom_margin_property =\n\t\tdrm_property_create_range(dev, 0, \"bottom margin\", 0, 100);\n\tif (!dev->mode_config.tv_bottom_margin_property)\n\t\treturn -ENOMEM;\n\n\treturn 0;\n}\nEXPORT_SYMBOL(drm_mode_create_tv_margin_properties);\n\n \nint drm_mode_create_tv_properties_legacy(struct drm_device *dev,\n\t\t\t\t\t unsigned int num_modes,\n\t\t\t\t\t const char * const modes[])\n{\n\tstruct drm_property *tv_selector;\n\tstruct drm_property *tv_subconnector;\n\tunsigned int i;\n\n\tif (dev->mode_config.tv_select_subconnector_property)\n\t\treturn 0;\n\n\t \n\ttv_selector = drm_property_create_enum(dev, 0,\n\t\t\t\t\t  \"select subconnector\",\n\t\t\t\t\t  drm_tv_select_enum_list,\n\t\t\t\t\t  ARRAY_SIZE(drm_tv_select_enum_list));\n\tif (!tv_selector)\n\t\tgoto nomem;\n\n\tdev->mode_config.tv_select_subconnector_property = tv_selector;\n\n\ttv_subconnector =\n\t\tdrm_property_create_enum(dev, DRM_MODE_PROP_IMMUTABLE,\n\t\t\t\t    \"subconnector\",\n\t\t\t\t    drm_tv_subconnector_enum_list,\n\t\t\t\t    ARRAY_SIZE(drm_tv_subconnector_enum_list));\n\tif (!tv_subconnector)\n\t\tgoto nomem;\n\tdev->mode_config.tv_subconnector_property = tv_subconnector;\n\n\t \n\tif (drm_mode_create_tv_margin_properties(dev))\n\t\tgoto nomem;\n\n\tif (num_modes) {\n\t\tdev->mode_config.legacy_tv_mode_property =\n\t\t\tdrm_property_create(dev, DRM_MODE_PROP_ENUM,\n\t\t\t\t\t    \"mode\", num_modes);\n\t\tif (!dev->mode_config.legacy_tv_mode_property)\n\t\t\tgoto nomem;\n\n\t\tfor (i = 0; i < num_modes; i++)\n\t\t\tdrm_property_add_enum(dev->mode_config.legacy_tv_mode_property,\n\t\t\t\t\t      i, modes[i]);\n\t}\n\n\tdev->mode_config.tv_brightness_property =\n\t\tdrm_property_create_range(dev, 0, \"brightness\", 0, 100);\n\tif (!dev->mode_config.tv_brightness_property)\n\t\tgoto nomem;\n\n\tdev->mode_config.tv_contrast_property =\n\t\tdrm_property_create_range(dev, 0, \"contrast\", 0, 100);\n\tif (!dev->mode_config.tv_contrast_property)\n\t\tgoto nomem;\n\n\tdev->mode_config.tv_flicker_reduction_property =\n\t\tdrm_property_create_range(dev, 0, \"flicker reduction\", 0, 100);\n\tif (!dev->mode_config.tv_flicker_reduction_property)\n\t\tgoto nomem;\n\n\tdev->mode_config.tv_overscan_property =\n\t\tdrm_property_create_range(dev, 0, \"overscan\", 0, 100);\n\tif (!dev->mode_config.tv_overscan_property)\n\t\tgoto nomem;\n\n\tdev->mode_config.tv_saturation_property =\n\t\tdrm_property_create_range(dev, 0, \"saturation\", 0, 100);\n\tif (!dev->mode_config.tv_saturation_property)\n\t\tgoto nomem;\n\n\tdev->mode_config.tv_hue_property =\n\t\tdrm_property_create_range(dev, 0, \"hue\", 0, 100);\n\tif (!dev->mode_config.tv_hue_property)\n\t\tgoto nomem;\n\n\treturn 0;\nnomem:\n\treturn -ENOMEM;\n}\nEXPORT_SYMBOL(drm_mode_create_tv_properties_legacy);\n\n \nint drm_mode_create_tv_properties(struct drm_device *dev,\n\t\t\t\t  unsigned int supported_tv_modes)\n{\n\tstruct drm_prop_enum_list tv_mode_list[DRM_MODE_TV_MODE_MAX];\n\tstruct drm_property *tv_mode;\n\tunsigned int i, len = 0;\n\n\tif (dev->mode_config.tv_mode_property)\n\t\treturn 0;\n\n\tfor (i = 0; i < DRM_MODE_TV_MODE_MAX; i++) {\n\t\tif (!(supported_tv_modes & BIT(i)))\n\t\t\tcontinue;\n\n\t\ttv_mode_list[len].type = i;\n\t\ttv_mode_list[len].name = drm_get_tv_mode_name(i);\n\t\tlen++;\n\t}\n\n\ttv_mode = drm_property_create_enum(dev, 0, \"TV mode\",\n\t\t\t\t\t   tv_mode_list, len);\n\tif (!tv_mode)\n\t\treturn -ENOMEM;\n\n\tdev->mode_config.tv_mode_property = tv_mode;\n\n\treturn drm_mode_create_tv_properties_legacy(dev, 0, NULL);\n}\nEXPORT_SYMBOL(drm_mode_create_tv_properties);\n\n \nint drm_mode_create_scaling_mode_property(struct drm_device *dev)\n{\n\tstruct drm_property *scaling_mode;\n\n\tif (dev->mode_config.scaling_mode_property)\n\t\treturn 0;\n\n\tscaling_mode =\n\t\tdrm_property_create_enum(dev, 0, \"scaling mode\",\n\t\t\t\tdrm_scaling_mode_enum_list,\n\t\t\t\t    ARRAY_SIZE(drm_scaling_mode_enum_list));\n\n\tdev->mode_config.scaling_mode_property = scaling_mode;\n\n\treturn 0;\n}\nEXPORT_SYMBOL(drm_mode_create_scaling_mode_property);\n\n \n\n \nint drm_connector_attach_vrr_capable_property(\n\tstruct drm_connector *connector)\n{\n\tstruct drm_device *dev = connector->dev;\n\tstruct drm_property *prop;\n\n\tif (!connector->vrr_capable_property) {\n\t\tprop = drm_property_create_bool(dev, DRM_MODE_PROP_IMMUTABLE,\n\t\t\t\"vrr_capable\");\n\t\tif (!prop)\n\t\t\treturn -ENOMEM;\n\n\t\tconnector->vrr_capable_property = prop;\n\t\tdrm_object_attach_property(&connector->base, prop, 0);\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL(drm_connector_attach_vrr_capable_property);\n\n \nint drm_connector_attach_scaling_mode_property(struct drm_connector *connector,\n\t\t\t\t\t       u32 scaling_mode_mask)\n{\n\tstruct drm_device *dev = connector->dev;\n\tstruct drm_property *scaling_mode_property;\n\tint i;\n\tconst unsigned valid_scaling_mode_mask =\n\t\t(1U << ARRAY_SIZE(drm_scaling_mode_enum_list)) - 1;\n\n\tif (WARN_ON(hweight32(scaling_mode_mask) < 2 ||\n\t\t    scaling_mode_mask & ~valid_scaling_mode_mask))\n\t\treturn -EINVAL;\n\n\tscaling_mode_property =\n\t\tdrm_property_create(dev, DRM_MODE_PROP_ENUM, \"scaling mode\",\n\t\t\t\t    hweight32(scaling_mode_mask));\n\n\tif (!scaling_mode_property)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < ARRAY_SIZE(drm_scaling_mode_enum_list); i++) {\n\t\tint ret;\n\n\t\tif (!(BIT(i) & scaling_mode_mask))\n\t\t\tcontinue;\n\n\t\tret = drm_property_add_enum(scaling_mode_property,\n\t\t\t\t\t    drm_scaling_mode_enum_list[i].type,\n\t\t\t\t\t    drm_scaling_mode_enum_list[i].name);\n\n\t\tif (ret) {\n\t\t\tdrm_property_destroy(dev, scaling_mode_property);\n\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tdrm_object_attach_property(&connector->base,\n\t\t\t\t   scaling_mode_property, 0);\n\n\tconnector->scaling_mode_property = scaling_mode_property;\n\n\treturn 0;\n}\nEXPORT_SYMBOL(drm_connector_attach_scaling_mode_property);\n\n \nint drm_mode_create_aspect_ratio_property(struct drm_device *dev)\n{\n\tif (dev->mode_config.aspect_ratio_property)\n\t\treturn 0;\n\n\tdev->mode_config.aspect_ratio_property =\n\t\tdrm_property_create_enum(dev, 0, \"aspect ratio\",\n\t\t\t\tdrm_aspect_ratio_enum_list,\n\t\t\t\tARRAY_SIZE(drm_aspect_ratio_enum_list));\n\n\tif (dev->mode_config.aspect_ratio_property == NULL)\n\t\treturn -ENOMEM;\n\n\treturn 0;\n}\nEXPORT_SYMBOL(drm_mode_create_aspect_ratio_property);\n\n \n\nstatic int drm_mode_create_colorspace_property(struct drm_connector *connector,\n\t\t\t\t\tu32 supported_colorspaces)\n{\n\tstruct drm_device *dev = connector->dev;\n\tu32 colorspaces = supported_colorspaces | BIT(DRM_MODE_COLORIMETRY_DEFAULT);\n\tstruct drm_prop_enum_list enum_list[DRM_MODE_COLORIMETRY_COUNT];\n\tint i, len;\n\n\tif (connector->colorspace_property)\n\t\treturn 0;\n\n\tif (!supported_colorspaces) {\n\t\tdrm_err(dev, \"No supported colorspaces provded on [CONNECTOR:%d:%s]\\n\",\n\t\t\t    connector->base.id, connector->name);\n\t\treturn -EINVAL;\n\t}\n\n\tif ((supported_colorspaces & -BIT(DRM_MODE_COLORIMETRY_COUNT)) != 0) {\n\t\tdrm_err(dev, \"Unknown colorspace provded on [CONNECTOR:%d:%s]\\n\",\n\t\t\t    connector->base.id, connector->name);\n\t\treturn -EINVAL;\n\t}\n\n\tlen = 0;\n\tfor (i = 0; i < DRM_MODE_COLORIMETRY_COUNT; i++) {\n\t\tif ((colorspaces & BIT(i)) == 0)\n\t\t\tcontinue;\n\n\t\tenum_list[len].type = i;\n\t\tenum_list[len].name = colorspace_names[i];\n\t\tlen++;\n\t}\n\n\tconnector->colorspace_property =\n\t\tdrm_property_create_enum(dev, DRM_MODE_PROP_ENUM, \"Colorspace\",\n\t\t\t\t\tenum_list,\n\t\t\t\t\tlen);\n\n\tif (!connector->colorspace_property)\n\t\treturn -ENOMEM;\n\n\treturn 0;\n}\n\n \nint drm_mode_create_hdmi_colorspace_property(struct drm_connector *connector,\n\t\t\t\t\t     u32 supported_colorspaces)\n{\n\tu32 colorspaces;\n\n\tif (supported_colorspaces)\n\t\tcolorspaces = supported_colorspaces & hdmi_colorspaces;\n\telse\n\t\tcolorspaces = hdmi_colorspaces;\n\n\treturn drm_mode_create_colorspace_property(connector, colorspaces);\n}\nEXPORT_SYMBOL(drm_mode_create_hdmi_colorspace_property);\n\n \nint drm_mode_create_dp_colorspace_property(struct drm_connector *connector,\n\t\t\t\t\t   u32 supported_colorspaces)\n{\n\tu32 colorspaces;\n\n\tif (supported_colorspaces)\n\t\tcolorspaces = supported_colorspaces & dp_colorspaces;\n\telse\n\t\tcolorspaces = dp_colorspaces;\n\n\treturn drm_mode_create_colorspace_property(connector, colorspaces);\n}\nEXPORT_SYMBOL(drm_mode_create_dp_colorspace_property);\n\n \nint drm_mode_create_content_type_property(struct drm_device *dev)\n{\n\tif (dev->mode_config.content_type_property)\n\t\treturn 0;\n\n\tdev->mode_config.content_type_property =\n\t\tdrm_property_create_enum(dev, 0, \"content type\",\n\t\t\t\t\t drm_content_type_enum_list,\n\t\t\t\t\t ARRAY_SIZE(drm_content_type_enum_list));\n\n\tif (dev->mode_config.content_type_property == NULL)\n\t\treturn -ENOMEM;\n\n\treturn 0;\n}\nEXPORT_SYMBOL(drm_mode_create_content_type_property);\n\n \nint drm_mode_create_suggested_offset_properties(struct drm_device *dev)\n{\n\tif (dev->mode_config.suggested_x_property && dev->mode_config.suggested_y_property)\n\t\treturn 0;\n\n\tdev->mode_config.suggested_x_property =\n\t\tdrm_property_create_range(dev, DRM_MODE_PROP_IMMUTABLE, \"suggested X\", 0, 0xffffffff);\n\n\tdev->mode_config.suggested_y_property =\n\t\tdrm_property_create_range(dev, DRM_MODE_PROP_IMMUTABLE, \"suggested Y\", 0, 0xffffffff);\n\n\tif (dev->mode_config.suggested_x_property == NULL ||\n\t    dev->mode_config.suggested_y_property == NULL)\n\t\treturn -ENOMEM;\n\treturn 0;\n}\nEXPORT_SYMBOL(drm_mode_create_suggested_offset_properties);\n\n \nint drm_connector_set_path_property(struct drm_connector *connector,\n\t\t\t\t    const char *path)\n{\n\tstruct drm_device *dev = connector->dev;\n\tint ret;\n\n\tret = drm_property_replace_global_blob(dev,\n\t\t\t\t\t       &connector->path_blob_ptr,\n\t\t\t\t\t       strlen(path) + 1,\n\t\t\t\t\t       path,\n\t\t\t\t\t       &connector->base,\n\t\t\t\t\t       dev->mode_config.path_property);\n\treturn ret;\n}\nEXPORT_SYMBOL(drm_connector_set_path_property);\n\n \nint drm_connector_set_tile_property(struct drm_connector *connector)\n{\n\tstruct drm_device *dev = connector->dev;\n\tchar tile[256];\n\tint ret;\n\n\tif (!connector->has_tile) {\n\t\tret  = drm_property_replace_global_blob(dev,\n\t\t\t\t\t\t\t&connector->tile_blob_ptr,\n\t\t\t\t\t\t\t0,\n\t\t\t\t\t\t\tNULL,\n\t\t\t\t\t\t\t&connector->base,\n\t\t\t\t\t\t\tdev->mode_config.tile_property);\n\t\treturn ret;\n\t}\n\n\tsnprintf(tile, 256, \"%d:%d:%d:%d:%d:%d:%d:%d\",\n\t\t connector->tile_group->id, connector->tile_is_single_monitor,\n\t\t connector->num_h_tile, connector->num_v_tile,\n\t\t connector->tile_h_loc, connector->tile_v_loc,\n\t\t connector->tile_h_size, connector->tile_v_size);\n\n\tret = drm_property_replace_global_blob(dev,\n\t\t\t\t\t       &connector->tile_blob_ptr,\n\t\t\t\t\t       strlen(tile) + 1,\n\t\t\t\t\t       tile,\n\t\t\t\t\t       &connector->base,\n\t\t\t\t\t       dev->mode_config.tile_property);\n\treturn ret;\n}\nEXPORT_SYMBOL(drm_connector_set_tile_property);\n\n \nvoid drm_connector_set_link_status_property(struct drm_connector *connector,\n\t\t\t\t\t    uint64_t link_status)\n{\n\tstruct drm_device *dev = connector->dev;\n\n\tdrm_modeset_lock(&dev->mode_config.connection_mutex, NULL);\n\tconnector->state->link_status = link_status;\n\tdrm_modeset_unlock(&dev->mode_config.connection_mutex);\n}\nEXPORT_SYMBOL(drm_connector_set_link_status_property);\n\n \nint drm_connector_attach_max_bpc_property(struct drm_connector *connector,\n\t\t\t\t\t  int min, int max)\n{\n\tstruct drm_device *dev = connector->dev;\n\tstruct drm_property *prop;\n\n\tprop = connector->max_bpc_property;\n\tif (!prop) {\n\t\tprop = drm_property_create_range(dev, 0, \"max bpc\", min, max);\n\t\tif (!prop)\n\t\t\treturn -ENOMEM;\n\n\t\tconnector->max_bpc_property = prop;\n\t}\n\n\tdrm_object_attach_property(&connector->base, prop, max);\n\tconnector->state->max_requested_bpc = max;\n\tconnector->state->max_bpc = max;\n\n\treturn 0;\n}\nEXPORT_SYMBOL(drm_connector_attach_max_bpc_property);\n\n \nint drm_connector_attach_hdr_output_metadata_property(struct drm_connector *connector)\n{\n\tstruct drm_device *dev = connector->dev;\n\tstruct drm_property *prop = dev->mode_config.hdr_output_metadata_property;\n\n\tdrm_object_attach_property(&connector->base, prop, 0);\n\n\treturn 0;\n}\nEXPORT_SYMBOL(drm_connector_attach_hdr_output_metadata_property);\n\n \nint drm_connector_attach_colorspace_property(struct drm_connector *connector)\n{\n\tstruct drm_property *prop = connector->colorspace_property;\n\n\tdrm_object_attach_property(&connector->base, prop, DRM_MODE_COLORIMETRY_DEFAULT);\n\n\treturn 0;\n}\nEXPORT_SYMBOL(drm_connector_attach_colorspace_property);\n\n \nbool drm_connector_atomic_hdr_metadata_equal(struct drm_connector_state *old_state,\n\t\t\t\t\t     struct drm_connector_state *new_state)\n{\n\tstruct drm_property_blob *old_blob = old_state->hdr_output_metadata;\n\tstruct drm_property_blob *new_blob = new_state->hdr_output_metadata;\n\n\tif (!old_blob || !new_blob)\n\t\treturn old_blob == new_blob;\n\n\tif (old_blob->length != new_blob->length)\n\t\treturn false;\n\n\treturn !memcmp(old_blob->data, new_blob->data, old_blob->length);\n}\nEXPORT_SYMBOL(drm_connector_atomic_hdr_metadata_equal);\n\n \nvoid drm_connector_set_vrr_capable_property(\n\t\tstruct drm_connector *connector, bool capable)\n{\n\tif (!connector->vrr_capable_property)\n\t\treturn;\n\n\tdrm_object_property_set_value(&connector->base,\n\t\t\t\t      connector->vrr_capable_property,\n\t\t\t\t      capable);\n}\nEXPORT_SYMBOL(drm_connector_set_vrr_capable_property);\n\n \nint drm_connector_set_panel_orientation(\n\tstruct drm_connector *connector,\n\tenum drm_panel_orientation panel_orientation)\n{\n\tstruct drm_device *dev = connector->dev;\n\tstruct drm_display_info *info = &connector->display_info;\n\tstruct drm_property *prop;\n\n\t \n\tif (info->panel_orientation != DRM_MODE_PANEL_ORIENTATION_UNKNOWN)\n\t\treturn 0;\n\n\t \n\tif (panel_orientation == DRM_MODE_PANEL_ORIENTATION_UNKNOWN)\n\t\treturn 0;\n\n\tinfo->panel_orientation = panel_orientation;\n\n\tprop = dev->mode_config.panel_orientation_property;\n\tif (!prop) {\n\t\tprop = drm_property_create_enum(dev, DRM_MODE_PROP_IMMUTABLE,\n\t\t\t\t\"panel orientation\",\n\t\t\t\tdrm_panel_orientation_enum_list,\n\t\t\t\tARRAY_SIZE(drm_panel_orientation_enum_list));\n\t\tif (!prop)\n\t\t\treturn -ENOMEM;\n\n\t\tdev->mode_config.panel_orientation_property = prop;\n\t}\n\n\tdrm_object_attach_property(&connector->base, prop,\n\t\t\t\t   info->panel_orientation);\n\treturn 0;\n}\nEXPORT_SYMBOL(drm_connector_set_panel_orientation);\n\n \nint drm_connector_set_panel_orientation_with_quirk(\n\tstruct drm_connector *connector,\n\tenum drm_panel_orientation panel_orientation,\n\tint width, int height)\n{\n\tint orientation_quirk;\n\n\torientation_quirk = drm_get_panel_orientation_quirk(width, height);\n\tif (orientation_quirk != DRM_MODE_PANEL_ORIENTATION_UNKNOWN)\n\t\tpanel_orientation = orientation_quirk;\n\n\treturn drm_connector_set_panel_orientation(connector,\n\t\t\t\t\t\t   panel_orientation);\n}\nEXPORT_SYMBOL(drm_connector_set_panel_orientation_with_quirk);\n\n \nint drm_connector_set_orientation_from_panel(\n\tstruct drm_connector *connector,\n\tstruct drm_panel *panel)\n{\n\tenum drm_panel_orientation orientation;\n\n\tif (panel && panel->funcs && panel->funcs->get_orientation)\n\t\torientation = panel->funcs->get_orientation(panel);\n\telse\n\t\torientation = DRM_MODE_PANEL_ORIENTATION_UNKNOWN;\n\n\treturn drm_connector_set_panel_orientation(connector, orientation);\n}\nEXPORT_SYMBOL(drm_connector_set_orientation_from_panel);\n\nstatic const struct drm_prop_enum_list privacy_screen_enum[] = {\n\t{ PRIVACY_SCREEN_DISABLED,\t\t\"Disabled\" },\n\t{ PRIVACY_SCREEN_ENABLED,\t\t\"Enabled\" },\n\t{ PRIVACY_SCREEN_DISABLED_LOCKED,\t\"Disabled-locked\" },\n\t{ PRIVACY_SCREEN_ENABLED_LOCKED,\t\"Enabled-locked\" },\n};\n\n \nvoid\ndrm_connector_create_privacy_screen_properties(struct drm_connector *connector)\n{\n\tif (connector->privacy_screen_sw_state_property)\n\t\treturn;\n\n\t \n\tconnector->privacy_screen_sw_state_property =\n\t\tdrm_property_create_enum(connector->dev, DRM_MODE_PROP_ENUM,\n\t\t\t\t\"privacy-screen sw-state\",\n\t\t\t\tprivacy_screen_enum, 2);\n\n\tconnector->privacy_screen_hw_state_property =\n\t\tdrm_property_create_enum(connector->dev,\n\t\t\t\tDRM_MODE_PROP_IMMUTABLE | DRM_MODE_PROP_ENUM,\n\t\t\t\t\"privacy-screen hw-state\",\n\t\t\t\tprivacy_screen_enum,\n\t\t\t\tARRAY_SIZE(privacy_screen_enum));\n}\nEXPORT_SYMBOL(drm_connector_create_privacy_screen_properties);\n\n \nvoid\ndrm_connector_attach_privacy_screen_properties(struct drm_connector *connector)\n{\n\tif (!connector->privacy_screen_sw_state_property)\n\t\treturn;\n\n\tdrm_object_attach_property(&connector->base,\n\t\t\t\t   connector->privacy_screen_sw_state_property,\n\t\t\t\t   PRIVACY_SCREEN_DISABLED);\n\n\tdrm_object_attach_property(&connector->base,\n\t\t\t\t   connector->privacy_screen_hw_state_property,\n\t\t\t\t   PRIVACY_SCREEN_DISABLED);\n}\nEXPORT_SYMBOL(drm_connector_attach_privacy_screen_properties);\n\nstatic void drm_connector_update_privacy_screen_properties(\n\tstruct drm_connector *connector, bool set_sw_state)\n{\n\tenum drm_privacy_screen_status sw_state, hw_state;\n\n\tdrm_privacy_screen_get_state(connector->privacy_screen,\n\t\t\t\t     &sw_state, &hw_state);\n\n\tif (set_sw_state)\n\t\tconnector->state->privacy_screen_sw_state = sw_state;\n\tdrm_object_property_set_value(&connector->base,\n\t\t\tconnector->privacy_screen_hw_state_property, hw_state);\n}\n\nstatic int drm_connector_privacy_screen_notifier(\n\tstruct notifier_block *nb, unsigned long action, void *data)\n{\n\tstruct drm_connector *connector =\n\t\tcontainer_of(nb, struct drm_connector, privacy_screen_notifier);\n\tstruct drm_device *dev = connector->dev;\n\n\tdrm_modeset_lock(&dev->mode_config.connection_mutex, NULL);\n\tdrm_connector_update_privacy_screen_properties(connector, true);\n\tdrm_modeset_unlock(&dev->mode_config.connection_mutex);\n\n\tdrm_sysfs_connector_property_event(connector,\n\t\t\t\t\t   connector->privacy_screen_sw_state_property);\n\tdrm_sysfs_connector_property_event(connector,\n\t\t\t\t\t   connector->privacy_screen_hw_state_property);\n\n\treturn NOTIFY_DONE;\n}\n\n \nvoid drm_connector_attach_privacy_screen_provider(\n\tstruct drm_connector *connector, struct drm_privacy_screen *priv)\n{\n\tconnector->privacy_screen = priv;\n\tconnector->privacy_screen_notifier.notifier_call =\n\t\tdrm_connector_privacy_screen_notifier;\n\n\tdrm_connector_create_privacy_screen_properties(connector);\n\tdrm_connector_update_privacy_screen_properties(connector, true);\n\tdrm_connector_attach_privacy_screen_properties(connector);\n}\nEXPORT_SYMBOL(drm_connector_attach_privacy_screen_provider);\n\n \nvoid drm_connector_update_privacy_screen(const struct drm_connector_state *connector_state)\n{\n\tstruct drm_connector *connector = connector_state->connector;\n\tint ret;\n\n\tif (!connector->privacy_screen)\n\t\treturn;\n\n\tret = drm_privacy_screen_set_sw_state(connector->privacy_screen,\n\t\t\t\t\t      connector_state->privacy_screen_sw_state);\n\tif (ret) {\n\t\tdrm_err(connector->dev, \"Error updating privacy-screen sw_state\\n\");\n\t\treturn;\n\t}\n\n\t \n\tdrm_connector_update_privacy_screen_properties(connector, false);\n}\nEXPORT_SYMBOL(drm_connector_update_privacy_screen);\n\nint drm_connector_set_obj_prop(struct drm_mode_object *obj,\n\t\t\t\t    struct drm_property *property,\n\t\t\t\t    uint64_t value)\n{\n\tint ret = -EINVAL;\n\tstruct drm_connector *connector = obj_to_connector(obj);\n\n\t \n\tif (property == connector->dev->mode_config.dpms_property) {\n\t\tret = (*connector->funcs->dpms)(connector, (int)value);\n\t} else if (connector->funcs->set_property)\n\t\tret = connector->funcs->set_property(connector, property, value);\n\n\tif (!ret)\n\t\tdrm_object_property_set_value(&connector->base, property, value);\n\treturn ret;\n}\n\nint drm_connector_property_set_ioctl(struct drm_device *dev,\n\t\t\t\t     void *data, struct drm_file *file_priv)\n{\n\tstruct drm_mode_connector_set_property *conn_set_prop = data;\n\tstruct drm_mode_obj_set_property obj_set_prop = {\n\t\t.value = conn_set_prop->value,\n\t\t.prop_id = conn_set_prop->prop_id,\n\t\t.obj_id = conn_set_prop->connector_id,\n\t\t.obj_type = DRM_MODE_OBJECT_CONNECTOR\n\t};\n\n\t \n\treturn drm_mode_obj_set_property_ioctl(dev, &obj_set_prop, file_priv);\n}\n\nstatic struct drm_encoder *drm_connector_get_encoder(struct drm_connector *connector)\n{\n\t \n\tif (connector->state)\n\t\treturn connector->state->best_encoder;\n\treturn connector->encoder;\n}\n\nstatic bool\ndrm_mode_expose_to_userspace(const struct drm_display_mode *mode,\n\t\t\t     const struct list_head *modes,\n\t\t\t     const struct drm_file *file_priv)\n{\n\t \n\tif (!file_priv->stereo_allowed && drm_mode_is_stereo(mode))\n\t\treturn false;\n\t \n\tif (!file_priv->aspect_ratio_allowed) {\n\t\tconst struct drm_display_mode *mode_itr;\n\n\t\tlist_for_each_entry(mode_itr, modes, head) {\n\t\t\tif (mode_itr->expose_to_userspace &&\n\t\t\t    drm_mode_match(mode_itr, mode,\n\t\t\t\t\t   DRM_MODE_MATCH_TIMINGS |\n\t\t\t\t\t   DRM_MODE_MATCH_CLOCK |\n\t\t\t\t\t   DRM_MODE_MATCH_FLAGS |\n\t\t\t\t\t   DRM_MODE_MATCH_3D_FLAGS))\n\t\t\t\treturn false;\n\t\t}\n\t}\n\n\treturn true;\n}\n\nint drm_mode_getconnector(struct drm_device *dev, void *data,\n\t\t\t  struct drm_file *file_priv)\n{\n\tstruct drm_mode_get_connector *out_resp = data;\n\tstruct drm_connector *connector;\n\tstruct drm_encoder *encoder;\n\tstruct drm_display_mode *mode;\n\tint mode_count = 0;\n\tint encoders_count = 0;\n\tint ret = 0;\n\tint copied = 0;\n\tstruct drm_mode_modeinfo u_mode;\n\tstruct drm_mode_modeinfo __user *mode_ptr;\n\tuint32_t __user *encoder_ptr;\n\tbool is_current_master;\n\n\tif (!drm_core_check_feature(dev, DRIVER_MODESET))\n\t\treturn -EOPNOTSUPP;\n\n\tmemset(&u_mode, 0, sizeof(struct drm_mode_modeinfo));\n\n\tconnector = drm_connector_lookup(dev, file_priv, out_resp->connector_id);\n\tif (!connector)\n\t\treturn -ENOENT;\n\n\tencoders_count = hweight32(connector->possible_encoders);\n\n\tif ((out_resp->count_encoders >= encoders_count) && encoders_count) {\n\t\tcopied = 0;\n\t\tencoder_ptr = (uint32_t __user *)(unsigned long)(out_resp->encoders_ptr);\n\n\t\tdrm_connector_for_each_possible_encoder(connector, encoder) {\n\t\t\tif (put_user(encoder->base.id, encoder_ptr + copied)) {\n\t\t\t\tret = -EFAULT;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tcopied++;\n\t\t}\n\t}\n\tout_resp->count_encoders = encoders_count;\n\n\tout_resp->connector_id = connector->base.id;\n\tout_resp->connector_type = connector->connector_type;\n\tout_resp->connector_type_id = connector->connector_type_id;\n\n\tis_current_master = drm_is_current_master(file_priv);\n\n\tmutex_lock(&dev->mode_config.mutex);\n\tif (out_resp->count_modes == 0) {\n\t\tif (is_current_master)\n\t\t\tconnector->funcs->fill_modes(connector,\n\t\t\t\t\t\t     dev->mode_config.max_width,\n\t\t\t\t\t\t     dev->mode_config.max_height);\n\t\telse\n\t\t\tdrm_dbg_kms(dev, \"User-space requested a forced probe on [CONNECTOR:%d:%s] but is not the DRM master, demoting to read-only probe\",\n\t\t\t\t    connector->base.id, connector->name);\n\t}\n\n\tout_resp->mm_width = connector->display_info.width_mm;\n\tout_resp->mm_height = connector->display_info.height_mm;\n\tout_resp->subpixel = connector->display_info.subpixel_order;\n\tout_resp->connection = connector->status;\n\n\t \n\tlist_for_each_entry(mode, &connector->modes, head) {\n\t\tWARN_ON(mode->expose_to_userspace);\n\n\t\tif (drm_mode_expose_to_userspace(mode, &connector->modes,\n\t\t\t\t\t\t file_priv)) {\n\t\t\tmode->expose_to_userspace = true;\n\t\t\tmode_count++;\n\t\t}\n\t}\n\n\t \n\tif ((out_resp->count_modes >= mode_count) && mode_count) {\n\t\tcopied = 0;\n\t\tmode_ptr = (struct drm_mode_modeinfo __user *)(unsigned long)out_resp->modes_ptr;\n\t\tlist_for_each_entry(mode, &connector->modes, head) {\n\t\t\tif (!mode->expose_to_userspace)\n\t\t\t\tcontinue;\n\n\t\t\t \n\t\t\tmode->expose_to_userspace = false;\n\n\t\t\tdrm_mode_convert_to_umode(&u_mode, mode);\n\t\t\t \n\t\t\tif (!file_priv->aspect_ratio_allowed)\n\t\t\t\tu_mode.flags &= ~DRM_MODE_FLAG_PIC_AR_MASK;\n\t\t\tif (copy_to_user(mode_ptr + copied,\n\t\t\t\t\t &u_mode, sizeof(u_mode))) {\n\t\t\t\tret = -EFAULT;\n\n\t\t\t\t \n\t\t\t\tlist_for_each_entry_continue(mode, &connector->modes, head)\n\t\t\t\t\tmode->expose_to_userspace = false;\n\n\t\t\t\tmutex_unlock(&dev->mode_config.mutex);\n\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tcopied++;\n\t\t}\n\t} else {\n\t\t \n\t\tlist_for_each_entry(mode, &connector->modes, head)\n\t\t\tmode->expose_to_userspace = false;\n\t}\n\n\tout_resp->count_modes = mode_count;\n\tmutex_unlock(&dev->mode_config.mutex);\n\n\tdrm_modeset_lock(&dev->mode_config.connection_mutex, NULL);\n\tencoder = drm_connector_get_encoder(connector);\n\tif (encoder)\n\t\tout_resp->encoder_id = encoder->base.id;\n\telse\n\t\tout_resp->encoder_id = 0;\n\n\t \n\tret = drm_mode_object_get_properties(&connector->base, file_priv->atomic,\n\t\t\t(uint32_t __user *)(unsigned long)(out_resp->props_ptr),\n\t\t\t(uint64_t __user *)(unsigned long)(out_resp->prop_values_ptr),\n\t\t\t&out_resp->count_props);\n\tdrm_modeset_unlock(&dev->mode_config.connection_mutex);\n\nout:\n\tdrm_connector_put(connector);\n\n\treturn ret;\n}\n\n \nstruct drm_connector *drm_connector_find_by_fwnode(struct fwnode_handle *fwnode)\n{\n\tstruct drm_connector *connector, *found = ERR_PTR(-ENODEV);\n\n\tif (!fwnode)\n\t\treturn ERR_PTR(-ENODEV);\n\n\tmutex_lock(&connector_list_lock);\n\n\tlist_for_each_entry(connector, &connector_list, global_connector_list_entry) {\n\t\tif (connector->fwnode == fwnode ||\n\t\t    (connector->fwnode && connector->fwnode->secondary == fwnode)) {\n\t\t\tdrm_connector_get(connector);\n\t\t\tfound = connector;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tmutex_unlock(&connector_list_lock);\n\n\treturn found;\n}\n\n \nvoid drm_connector_oob_hotplug_event(struct fwnode_handle *connector_fwnode)\n{\n\tstruct drm_connector *connector;\n\n\tconnector = drm_connector_find_by_fwnode(connector_fwnode);\n\tif (IS_ERR(connector))\n\t\treturn;\n\n\tif (connector->funcs->oob_hotplug_event)\n\t\tconnector->funcs->oob_hotplug_event(connector);\n\n\tdrm_connector_put(connector);\n}\nEXPORT_SYMBOL(drm_connector_oob_hotplug_event);\n\n\n \n\nstatic void drm_tile_group_free(struct kref *kref)\n{\n\tstruct drm_tile_group *tg = container_of(kref, struct drm_tile_group, refcount);\n\tstruct drm_device *dev = tg->dev;\n\n\tmutex_lock(&dev->mode_config.idr_mutex);\n\tidr_remove(&dev->mode_config.tile_idr, tg->id);\n\tmutex_unlock(&dev->mode_config.idr_mutex);\n\tkfree(tg);\n}\n\n \nvoid drm_mode_put_tile_group(struct drm_device *dev,\n\t\t\t     struct drm_tile_group *tg)\n{\n\tkref_put(&tg->refcount, drm_tile_group_free);\n}\nEXPORT_SYMBOL(drm_mode_put_tile_group);\n\n \nstruct drm_tile_group *drm_mode_get_tile_group(struct drm_device *dev,\n\t\t\t\t\t       const char topology[8])\n{\n\tstruct drm_tile_group *tg;\n\tint id;\n\n\tmutex_lock(&dev->mode_config.idr_mutex);\n\tidr_for_each_entry(&dev->mode_config.tile_idr, tg, id) {\n\t\tif (!memcmp(tg->group_data, topology, 8)) {\n\t\t\tif (!kref_get_unless_zero(&tg->refcount))\n\t\t\t\ttg = NULL;\n\t\t\tmutex_unlock(&dev->mode_config.idr_mutex);\n\t\t\treturn tg;\n\t\t}\n\t}\n\tmutex_unlock(&dev->mode_config.idr_mutex);\n\treturn NULL;\n}\nEXPORT_SYMBOL(drm_mode_get_tile_group);\n\n \nstruct drm_tile_group *drm_mode_create_tile_group(struct drm_device *dev,\n\t\t\t\t\t\t  const char topology[8])\n{\n\tstruct drm_tile_group *tg;\n\tint ret;\n\n\ttg = kzalloc(sizeof(*tg), GFP_KERNEL);\n\tif (!tg)\n\t\treturn NULL;\n\n\tkref_init(&tg->refcount);\n\tmemcpy(tg->group_data, topology, 8);\n\ttg->dev = dev;\n\n\tmutex_lock(&dev->mode_config.idr_mutex);\n\tret = idr_alloc(&dev->mode_config.tile_idr, tg, 1, 0, GFP_KERNEL);\n\tif (ret >= 0) {\n\t\ttg->id = ret;\n\t} else {\n\t\tkfree(tg);\n\t\ttg = NULL;\n\t}\n\n\tmutex_unlock(&dev->mode_config.idr_mutex);\n\treturn tg;\n}\nEXPORT_SYMBOL(drm_mode_create_tile_group);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}