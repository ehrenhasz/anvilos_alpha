{
  "module_name": "hyperv_drm_drv.c",
  "hash_id": "6dfa1bb62d21c8d4194f5c9118f34d48ab9d068297a4fa8dcfb44a8334c5611b",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/hyperv/hyperv_drm_drv.c",
  "human_readable_source": "\n \n\n#include <linux/efi.h>\n#include <linux/hyperv.h>\n#include <linux/module.h>\n#include <linux/pci.h>\n#include <linux/screen_info.h>\n\n#include <drm/drm_aperture.h>\n#include <drm/drm_atomic_helper.h>\n#include <drm/drm_drv.h>\n#include <drm/drm_fbdev_generic.h>\n#include <drm/drm_gem_shmem_helper.h>\n#include <drm/drm_simple_kms_helper.h>\n\n#include \"hyperv_drm.h\"\n\n#define DRIVER_NAME \"hyperv_drm\"\n#define DRIVER_DESC \"DRM driver for Hyper-V synthetic video device\"\n#define DRIVER_DATE \"2020\"\n#define DRIVER_MAJOR 1\n#define DRIVER_MINOR 0\n\nDEFINE_DRM_GEM_FOPS(hv_fops);\n\nstatic struct drm_driver hyperv_driver = {\n\t.driver_features = DRIVER_MODESET | DRIVER_GEM | DRIVER_ATOMIC,\n\n\t.name\t\t = DRIVER_NAME,\n\t.desc\t\t = DRIVER_DESC,\n\t.date\t\t = DRIVER_DATE,\n\t.major\t\t = DRIVER_MAJOR,\n\t.minor\t\t = DRIVER_MINOR,\n\n\t.fops\t\t = &hv_fops,\n\tDRM_GEM_SHMEM_DRIVER_OPS,\n};\n\nstatic int hyperv_pci_probe(struct pci_dev *pdev,\n\t\t\t    const struct pci_device_id *ent)\n{\n\treturn 0;\n}\n\nstatic void hyperv_pci_remove(struct pci_dev *pdev)\n{\n}\n\nstatic const struct pci_device_id hyperv_pci_tbl[] = {\n\t{\n\t\t.vendor = PCI_VENDOR_ID_MICROSOFT,\n\t\t.device = PCI_DEVICE_ID_HYPERV_VIDEO,\n\t},\n\t{   }\n};\n\n \nstatic struct pci_driver hyperv_pci_driver = {\n\t.name =\t\tKBUILD_MODNAME,\n\t.id_table =\thyperv_pci_tbl,\n\t.probe =\thyperv_pci_probe,\n\t.remove =\thyperv_pci_remove,\n};\n\nstatic int hyperv_setup_vram(struct hyperv_drm_device *hv,\n\t\t\t     struct hv_device *hdev)\n{\n\tstruct drm_device *dev = &hv->dev;\n\tint ret;\n\n\tdrm_aperture_remove_conflicting_framebuffers(screen_info.lfb_base,\n\t\t\t\t\t\t     screen_info.lfb_size,\n\t\t\t\t\t\t     &hyperv_driver);\n\n\thv->fb_size = (unsigned long)hv->mmio_megabytes * 1024 * 1024;\n\n\tret = vmbus_allocate_mmio(&hv->mem, hdev, 0, -1, hv->fb_size, 0x100000,\n\t\t\t\t  true);\n\tif (ret) {\n\t\tdrm_err(dev, \"Failed to allocate mmio\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\t \n\thv->vram = ioremap_cache(hv->mem->start, hv->fb_size);\n\tif (!hv->vram) {\n\t\tdrm_err(dev, \"Failed to map vram\\n\");\n\t\tret = -ENOMEM;\n\t\tgoto error;\n\t}\n\n\thv->fb_base = hv->mem->start;\n\treturn 0;\n\nerror:\n\tvmbus_free_mmio(hv->mem->start, hv->fb_size);\n\treturn ret;\n}\n\nstatic int hyperv_vmbus_probe(struct hv_device *hdev,\n\t\t\t      const struct hv_vmbus_device_id *dev_id)\n{\n\tstruct hyperv_drm_device *hv;\n\tstruct drm_device *dev;\n\tint ret;\n\n\thv = devm_drm_dev_alloc(&hdev->device, &hyperv_driver,\n\t\t\t\tstruct hyperv_drm_device, dev);\n\tif (IS_ERR(hv))\n\t\treturn PTR_ERR(hv);\n\n\tdev = &hv->dev;\n\tinit_completion(&hv->wait);\n\thv_set_drvdata(hdev, hv);\n\thv->hdev = hdev;\n\n\tret = hyperv_connect_vsp(hdev);\n\tif (ret) {\n\t\tdrm_err(dev, \"Failed to connect to vmbus.\\n\");\n\t\tgoto err_hv_set_drv_data;\n\t}\n\n\tret = hyperv_setup_vram(hv, hdev);\n\tif (ret)\n\t\tgoto err_vmbus_close;\n\n\t \n\tret = hyperv_update_vram_location(hdev, hv->fb_base);\n\tif (ret)\n\t\tdrm_warn(dev, \"Failed to update vram location.\\n\");\n\n\tret = hyperv_mode_config_init(hv);\n\tif (ret)\n\t\tgoto err_free_mmio;\n\n\tret = drm_dev_register(dev, 0);\n\tif (ret) {\n\t\tdrm_err(dev, \"Failed to register drm driver.\\n\");\n\t\tgoto err_free_mmio;\n\t}\n\n\tdrm_fbdev_generic_setup(dev, 0);\n\n\treturn 0;\n\nerr_free_mmio:\n\tvmbus_free_mmio(hv->mem->start, hv->fb_size);\nerr_vmbus_close:\n\tvmbus_close(hdev->channel);\nerr_hv_set_drv_data:\n\thv_set_drvdata(hdev, NULL);\n\treturn ret;\n}\n\nstatic void hyperv_vmbus_remove(struct hv_device *hdev)\n{\n\tstruct drm_device *dev = hv_get_drvdata(hdev);\n\tstruct hyperv_drm_device *hv = to_hv(dev);\n\n\tdrm_dev_unplug(dev);\n\tdrm_atomic_helper_shutdown(dev);\n\tvmbus_close(hdev->channel);\n\thv_set_drvdata(hdev, NULL);\n\n\tvmbus_free_mmio(hv->mem->start, hv->fb_size);\n}\n\nstatic int hyperv_vmbus_suspend(struct hv_device *hdev)\n{\n\tstruct drm_device *dev = hv_get_drvdata(hdev);\n\tint ret;\n\n\tret = drm_mode_config_helper_suspend(dev);\n\tif (ret)\n\t\treturn ret;\n\n\tvmbus_close(hdev->channel);\n\n\treturn 0;\n}\n\nstatic int hyperv_vmbus_resume(struct hv_device *hdev)\n{\n\tstruct drm_device *dev = hv_get_drvdata(hdev);\n\tstruct hyperv_drm_device *hv = to_hv(dev);\n\tint ret;\n\n\tret = hyperv_connect_vsp(hdev);\n\tif (ret)\n\t\treturn ret;\n\n\tret = hyperv_update_vram_location(hdev, hv->fb_base);\n\tif (ret)\n\t\treturn ret;\n\n\treturn drm_mode_config_helper_resume(dev);\n}\n\nstatic const struct hv_vmbus_device_id hyperv_vmbus_tbl[] = {\n\t \n\t{HV_SYNTHVID_GUID},\n\t{}\n};\n\nstatic struct hv_driver hyperv_hv_driver = {\n\t.name = KBUILD_MODNAME,\n\t.id_table = hyperv_vmbus_tbl,\n\t.probe = hyperv_vmbus_probe,\n\t.remove = hyperv_vmbus_remove,\n\t.suspend = hyperv_vmbus_suspend,\n\t.resume = hyperv_vmbus_resume,\n\t.driver = {\n\t\t.probe_type = PROBE_PREFER_ASYNCHRONOUS,\n\t},\n};\n\nstatic int __init hyperv_init(void)\n{\n\tint ret;\n\n\tif (drm_firmware_drivers_only())\n\t\treturn -ENODEV;\n\n\tret = pci_register_driver(&hyperv_pci_driver);\n\tif (ret != 0)\n\t\treturn ret;\n\n\treturn vmbus_driver_register(&hyperv_hv_driver);\n}\n\nstatic void __exit hyperv_exit(void)\n{\n\tvmbus_driver_unregister(&hyperv_hv_driver);\n\tpci_unregister_driver(&hyperv_pci_driver);\n}\n\nmodule_init(hyperv_init);\nmodule_exit(hyperv_exit);\n\nMODULE_DEVICE_TABLE(pci, hyperv_pci_tbl);\nMODULE_DEVICE_TABLE(vmbus, hyperv_vmbus_tbl);\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Deepak Rawat <drawat.floss@gmail.com>\");\nMODULE_DESCRIPTION(\"DRM driver for Hyper-V synthetic video device\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}