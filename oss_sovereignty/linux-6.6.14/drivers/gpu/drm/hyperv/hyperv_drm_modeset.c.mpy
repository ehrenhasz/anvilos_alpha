{
  "module_name": "hyperv_drm_modeset.c",
  "hash_id": "b39f2c7e42b53529f1bd69c22a76cf75827e08f906bdfa31faf25696387f87c0",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/hyperv/hyperv_drm_modeset.c",
  "human_readable_source": "\n \n\n#include <linux/hyperv.h>\n\n#include <drm/drm_damage_helper.h>\n#include <drm/drm_drv.h>\n#include <drm/drm_edid.h>\n#include <drm/drm_format_helper.h>\n#include <drm/drm_fourcc.h>\n#include <drm/drm_framebuffer.h>\n#include <drm/drm_gem_atomic_helper.h>\n#include <drm/drm_gem_framebuffer_helper.h>\n#include <drm/drm_gem_shmem_helper.h>\n#include <drm/drm_probe_helper.h>\n#include <drm/drm_simple_kms_helper.h>\n\n#include \"hyperv_drm.h\"\n\nstatic int hyperv_blit_to_vram_rect(struct drm_framebuffer *fb,\n\t\t\t\t    const struct iosys_map *vmap,\n\t\t\t\t    struct drm_rect *rect)\n{\n\tstruct hyperv_drm_device *hv = to_hv(fb->dev);\n\tstruct iosys_map dst = IOSYS_MAP_INIT_VADDR_IOMEM(hv->vram);\n\tint idx;\n\n\tif (!drm_dev_enter(&hv->dev, &idx))\n\t\treturn -ENODEV;\n\n\tiosys_map_incr(&dst, drm_fb_clip_offset(fb->pitches[0], fb->format, rect));\n\tdrm_fb_memcpy(&dst, fb->pitches, vmap, fb, rect);\n\n\tdrm_dev_exit(idx);\n\n\treturn 0;\n}\n\nstatic int hyperv_blit_to_vram_fullscreen(struct drm_framebuffer *fb,\n\t\t\t\t\t  const struct iosys_map *map)\n{\n\tstruct drm_rect fullscreen = {\n\t\t.x1 = 0,\n\t\t.x2 = fb->width,\n\t\t.y1 = 0,\n\t\t.y2 = fb->height,\n\t};\n\treturn hyperv_blit_to_vram_rect(fb, map, &fullscreen);\n}\n\nstatic int hyperv_connector_get_modes(struct drm_connector *connector)\n{\n\tstruct hyperv_drm_device *hv = to_hv(connector->dev);\n\tint count;\n\n\tcount = drm_add_modes_noedid(connector,\n\t\t\t\t     connector->dev->mode_config.max_width,\n\t\t\t\t     connector->dev->mode_config.max_height);\n\tdrm_set_preferred_mode(connector, hv->preferred_width,\n\t\t\t       hv->preferred_height);\n\n\treturn count;\n}\n\nstatic const struct drm_connector_helper_funcs hyperv_connector_helper_funcs = {\n\t.get_modes = hyperv_connector_get_modes,\n};\n\nstatic const struct drm_connector_funcs hyperv_connector_funcs = {\n\t.fill_modes = drm_helper_probe_single_connector_modes,\n\t.destroy = drm_connector_cleanup,\n\t.reset = drm_atomic_helper_connector_reset,\n\t.atomic_duplicate_state = drm_atomic_helper_connector_duplicate_state,\n\t.atomic_destroy_state = drm_atomic_helper_connector_destroy_state,\n};\n\nstatic inline int hyperv_conn_init(struct hyperv_drm_device *hv)\n{\n\tdrm_connector_helper_add(&hv->connector, &hyperv_connector_helper_funcs);\n\treturn drm_connector_init(&hv->dev, &hv->connector,\n\t\t\t\t  &hyperv_connector_funcs,\n\t\t\t\t  DRM_MODE_CONNECTOR_VIRTUAL);\n}\n\nstatic int hyperv_check_size(struct hyperv_drm_device *hv, int w, int h,\n\t\t\t     struct drm_framebuffer *fb)\n{\n\tu32 pitch = w * (hv->screen_depth / 8);\n\n\tif (fb)\n\t\tpitch = fb->pitches[0];\n\n\tif (pitch * h > hv->fb_size)\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nstatic void hyperv_pipe_enable(struct drm_simple_display_pipe *pipe,\n\t\t\t       struct drm_crtc_state *crtc_state,\n\t\t\t       struct drm_plane_state *plane_state)\n{\n\tstruct hyperv_drm_device *hv = to_hv(pipe->crtc.dev);\n\tstruct drm_shadow_plane_state *shadow_plane_state = to_drm_shadow_plane_state(plane_state);\n\n\thyperv_hide_hw_ptr(hv->hdev);\n\thyperv_update_situation(hv->hdev, 1,  hv->screen_depth,\n\t\t\t\tcrtc_state->mode.hdisplay,\n\t\t\t\tcrtc_state->mode.vdisplay,\n\t\t\t\tplane_state->fb->pitches[0]);\n\thyperv_blit_to_vram_fullscreen(plane_state->fb, &shadow_plane_state->data[0]);\n}\n\nstatic int hyperv_pipe_check(struct drm_simple_display_pipe *pipe,\n\t\t\t     struct drm_plane_state *plane_state,\n\t\t\t     struct drm_crtc_state *crtc_state)\n{\n\tstruct hyperv_drm_device *hv = to_hv(pipe->crtc.dev);\n\tstruct drm_framebuffer *fb = plane_state->fb;\n\n\tif (fb->format->format != DRM_FORMAT_XRGB8888)\n\t\treturn -EINVAL;\n\n\tif (fb->pitches[0] * fb->height > hv->fb_size) {\n\t\tdrm_err(&hv->dev, \"fb size requested by %s for %dX%d (pitch %d) greater than %ld\\n\",\n\t\t\tcurrent->comm, fb->width, fb->height, fb->pitches[0], hv->fb_size);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic void hyperv_pipe_update(struct drm_simple_display_pipe *pipe,\n\t\t\t       struct drm_plane_state *old_state)\n{\n\tstruct hyperv_drm_device *hv = to_hv(pipe->crtc.dev);\n\tstruct drm_plane_state *state = pipe->plane.state;\n\tstruct drm_shadow_plane_state *shadow_plane_state = to_drm_shadow_plane_state(state);\n\tstruct drm_rect rect;\n\n\tif (drm_atomic_helper_damage_merged(old_state, state, &rect)) {\n\t\thyperv_blit_to_vram_rect(state->fb, &shadow_plane_state->data[0], &rect);\n\t\thyperv_update_dirt(hv->hdev, &rect);\n\t}\n}\n\nstatic const struct drm_simple_display_pipe_funcs hyperv_pipe_funcs = {\n\t.enable\t= hyperv_pipe_enable,\n\t.check = hyperv_pipe_check,\n\t.update\t= hyperv_pipe_update,\n\tDRM_GEM_SIMPLE_DISPLAY_PIPE_SHADOW_PLANE_FUNCS,\n};\n\nstatic const uint32_t hyperv_formats[] = {\n\tDRM_FORMAT_XRGB8888,\n};\n\nstatic const uint64_t hyperv_modifiers[] = {\n\tDRM_FORMAT_MOD_LINEAR,\n\tDRM_FORMAT_MOD_INVALID\n};\n\nstatic inline int hyperv_pipe_init(struct hyperv_drm_device *hv)\n{\n\tint ret;\n\n\tret = drm_simple_display_pipe_init(&hv->dev,\n\t\t\t\t\t   &hv->pipe,\n\t\t\t\t\t   &hyperv_pipe_funcs,\n\t\t\t\t\t   hyperv_formats,\n\t\t\t\t\t   ARRAY_SIZE(hyperv_formats),\n\t\t\t\t\t   hyperv_modifiers,\n\t\t\t\t\t   &hv->connector);\n\tif (ret)\n\t\treturn ret;\n\n\tdrm_plane_enable_fb_damage_clips(&hv->pipe.plane);\n\n\treturn 0;\n}\n\nstatic enum drm_mode_status\nhyperv_mode_valid(struct drm_device *dev,\n\t\t  const struct drm_display_mode *mode)\n{\n\tstruct hyperv_drm_device *hv = to_hv(dev);\n\n\tif (hyperv_check_size(hv, mode->hdisplay, mode->vdisplay, NULL))\n\t\treturn MODE_BAD;\n\n\treturn MODE_OK;\n}\n\nstatic const struct drm_mode_config_funcs hyperv_mode_config_funcs = {\n\t.fb_create = drm_gem_fb_create_with_dirty,\n\t.mode_valid = hyperv_mode_valid,\n\t.atomic_check = drm_atomic_helper_check,\n\t.atomic_commit = drm_atomic_helper_commit,\n};\n\nint hyperv_mode_config_init(struct hyperv_drm_device *hv)\n{\n\tstruct drm_device *dev = &hv->dev;\n\tint ret;\n\n\tret = drmm_mode_config_init(dev);\n\tif (ret) {\n\t\tdrm_err(dev, \"Failed to initialized mode setting.\\n\");\n\t\treturn ret;\n\t}\n\n\tdev->mode_config.min_width = 0;\n\tdev->mode_config.min_height = 0;\n\tdev->mode_config.max_width = hv->screen_width_max;\n\tdev->mode_config.max_height = hv->screen_height_max;\n\n\tdev->mode_config.preferred_depth = hv->screen_depth;\n\tdev->mode_config.prefer_shadow = 0;\n\n\tdev->mode_config.funcs = &hyperv_mode_config_funcs;\n\n\tret = hyperv_conn_init(hv);\n\tif (ret) {\n\t\tdrm_err(dev, \"Failed to initialized connector.\\n\");\n\t\treturn ret;\n\t}\n\n\tret = hyperv_pipe_init(hv);\n\tif (ret) {\n\t\tdrm_err(dev, \"Failed to initialized pipe.\\n\");\n\t\treturn ret;\n\t}\n\n\tdrm_mode_config_reset(dev);\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}