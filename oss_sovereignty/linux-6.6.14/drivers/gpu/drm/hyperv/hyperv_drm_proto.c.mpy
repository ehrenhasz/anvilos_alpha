{
  "module_name": "hyperv_drm_proto.c",
  "hash_id": "b0160af316ec9417f60f6d1c9c052d12d823112e472ac83d51d32d73392ec89e",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/hyperv/hyperv_drm_proto.c",
  "human_readable_source": "\n \n\n#include <linux/hyperv.h>\n\n#include <drm/drm_print.h>\n#include <drm/drm_simple_kms_helper.h>\n\n#include \"hyperv_drm.h\"\n\n#define VMBUS_RING_BUFSIZE (256 * 1024)\n#define VMBUS_VSP_TIMEOUT (10 * HZ)\n\n#define SYNTHVID_VERSION(major, minor) ((minor) << 16 | (major))\n#define SYNTHVID_VER_GET_MAJOR(ver) (ver & 0x0000ffff)\n#define SYNTHVID_VER_GET_MINOR(ver) ((ver & 0xffff0000) >> 16)\n\n \n#define SYNTHVID_VERSION_WIN7 SYNTHVID_VERSION(3, 0)\n#define SYNTHVID_VERSION_WIN8 SYNTHVID_VERSION(3, 2)\n#define SYNTHVID_VERSION_WIN10 SYNTHVID_VERSION(3, 5)\n\n#define SYNTHVID_DEPTH_WIN8 32\n#define SYNTHVID_WIDTH_WIN8 1600\n#define SYNTHVID_HEIGHT_WIN8 1200\n#define SYNTHVID_FB_SIZE_WIN8 (8 * 1024 * 1024)\n\nenum pipe_msg_type {\n\tPIPE_MSG_INVALID,\n\tPIPE_MSG_DATA,\n\tPIPE_MSG_MAX\n};\n\nenum synthvid_msg_type {\n\tSYNTHVID_ERROR\t\t\t= 0,\n\tSYNTHVID_VERSION_REQUEST\t= 1,\n\tSYNTHVID_VERSION_RESPONSE\t= 2,\n\tSYNTHVID_VRAM_LOCATION\t\t= 3,\n\tSYNTHVID_VRAM_LOCATION_ACK\t= 4,\n\tSYNTHVID_SITUATION_UPDATE\t= 5,\n\tSYNTHVID_SITUATION_UPDATE_ACK\t= 6,\n\tSYNTHVID_POINTER_POSITION\t= 7,\n\tSYNTHVID_POINTER_SHAPE\t\t= 8,\n\tSYNTHVID_FEATURE_CHANGE\t\t= 9,\n\tSYNTHVID_DIRT\t\t\t= 10,\n\tSYNTHVID_RESOLUTION_REQUEST\t= 13,\n\tSYNTHVID_RESOLUTION_RESPONSE\t= 14,\n\n\tSYNTHVID_MAX\t\t\t= 15\n};\n\nstruct pipe_msg_hdr {\n\tu32 type;\n\tu32 size;  \n} __packed;\n\nstruct hvd_screen_info {\n\tu16 width;\n\tu16 height;\n} __packed;\n\nstruct synthvid_msg_hdr {\n\tu32 type;\n\tu32 size;   \n} __packed;\n\nstruct synthvid_version_req {\n\tu32 version;\n} __packed;\n\nstruct synthvid_version_resp {\n\tu32 version;\n\tu8 is_accepted;\n\tu8 max_video_outputs;\n} __packed;\n\nstruct synthvid_vram_location {\n\tu64 user_ctx;\n\tu8 is_vram_gpa_specified;\n\tu64 vram_gpa;\n} __packed;\n\nstruct synthvid_vram_location_ack {\n\tu64 user_ctx;\n} __packed;\n\nstruct video_output_situation {\n\tu8 active;\n\tu32 vram_offset;\n\tu8 depth_bits;\n\tu32 width_pixels;\n\tu32 height_pixels;\n\tu32 pitch_bytes;\n} __packed;\n\nstruct synthvid_situation_update {\n\tu64 user_ctx;\n\tu8 video_output_count;\n\tstruct video_output_situation video_output[1];\n} __packed;\n\nstruct synthvid_situation_update_ack {\n\tu64 user_ctx;\n} __packed;\n\nstruct synthvid_pointer_position {\n\tu8 is_visible;\n\tu8 video_output;\n\ts32 image_x;\n\ts32 image_y;\n} __packed;\n\n#define SYNTHVID_CURSOR_MAX_X 96\n#define SYNTHVID_CURSOR_MAX_Y 96\n#define SYNTHVID_CURSOR_ARGB_PIXEL_SIZE 4\n#define SYNTHVID_CURSOR_MAX_SIZE (SYNTHVID_CURSOR_MAX_X * \\\n\tSYNTHVID_CURSOR_MAX_Y * SYNTHVID_CURSOR_ARGB_PIXEL_SIZE)\n#define SYNTHVID_CURSOR_COMPLETE (-1)\n\nstruct synthvid_pointer_shape {\n\tu8 part_idx;\n\tu8 is_argb;\n\tu32 width;  \n\tu32 height;  \n\tu32 hot_x;  \n\tu32 hot_y;\n\tu8 data[4];\n} __packed;\n\nstruct synthvid_feature_change {\n\tu8 is_dirt_needed;\n\tu8 is_ptr_pos_needed;\n\tu8 is_ptr_shape_needed;\n\tu8 is_situ_needed;\n} __packed;\n\nstruct rect {\n\ts32 x1, y1;  \n\ts32 x2, y2;  \n} __packed;\n\nstruct synthvid_dirt {\n\tu8 video_output;\n\tu8 dirt_count;\n\tstruct rect rect[1];\n} __packed;\n\n#define SYNTHVID_EDID_BLOCK_SIZE\t128\n#define\tSYNTHVID_MAX_RESOLUTION_COUNT\t64\n\nstruct synthvid_supported_resolution_req {\n\tu8 maximum_resolution_count;\n} __packed;\n\nstruct synthvid_supported_resolution_resp {\n\tu8 edid_block[SYNTHVID_EDID_BLOCK_SIZE];\n\tu8 resolution_count;\n\tu8 default_resolution_index;\n\tu8 is_standard;\n\tstruct hvd_screen_info supported_resolution[SYNTHVID_MAX_RESOLUTION_COUNT];\n} __packed;\n\nstruct synthvid_msg {\n\tstruct pipe_msg_hdr pipe_hdr;\n\tstruct synthvid_msg_hdr vid_hdr;\n\tunion {\n\t\tstruct synthvid_version_req ver_req;\n\t\tstruct synthvid_version_resp ver_resp;\n\t\tstruct synthvid_vram_location vram;\n\t\tstruct synthvid_vram_location_ack vram_ack;\n\t\tstruct synthvid_situation_update situ;\n\t\tstruct synthvid_situation_update_ack situ_ack;\n\t\tstruct synthvid_pointer_position ptr_pos;\n\t\tstruct synthvid_pointer_shape ptr_shape;\n\t\tstruct synthvid_feature_change feature_chg;\n\t\tstruct synthvid_dirt dirt;\n\t\tstruct synthvid_supported_resolution_req resolution_req;\n\t\tstruct synthvid_supported_resolution_resp resolution_resp;\n\t};\n} __packed;\n\nstatic inline bool hyperv_version_ge(u32 ver1, u32 ver2)\n{\n\tif (SYNTHVID_VER_GET_MAJOR(ver1) > SYNTHVID_VER_GET_MAJOR(ver2) ||\n\t    (SYNTHVID_VER_GET_MAJOR(ver1) == SYNTHVID_VER_GET_MAJOR(ver2) &&\n\t     SYNTHVID_VER_GET_MINOR(ver1) >= SYNTHVID_VER_GET_MINOR(ver2)))\n\t\treturn true;\n\n\treturn false;\n}\n\nstatic inline int hyperv_sendpacket(struct hv_device *hdev, struct synthvid_msg *msg)\n{\n\tstatic atomic64_t request_id = ATOMIC64_INIT(0);\n\tstruct hyperv_drm_device *hv = hv_get_drvdata(hdev);\n\tint ret;\n\n\tmsg->pipe_hdr.type = PIPE_MSG_DATA;\n\tmsg->pipe_hdr.size = msg->vid_hdr.size;\n\n\tret = vmbus_sendpacket(hdev->channel, msg,\n\t\t\t       msg->vid_hdr.size + sizeof(struct pipe_msg_hdr),\n\t\t\t       atomic64_inc_return(&request_id),\n\t\t\t       VM_PKT_DATA_INBAND, 0);\n\n\tif (ret)\n\t\tdrm_err_ratelimited(&hv->dev, \"Unable to send packet via vmbus; error %d\\n\", ret);\n\n\treturn ret;\n}\n\nstatic int hyperv_negotiate_version(struct hv_device *hdev, u32 ver)\n{\n\tstruct hyperv_drm_device *hv = hv_get_drvdata(hdev);\n\tstruct synthvid_msg *msg = (struct synthvid_msg *)hv->init_buf;\n\tstruct drm_device *dev = &hv->dev;\n\tunsigned long t;\n\n\tmemset(msg, 0, sizeof(struct synthvid_msg));\n\tmsg->vid_hdr.type = SYNTHVID_VERSION_REQUEST;\n\tmsg->vid_hdr.size = sizeof(struct synthvid_msg_hdr) +\n\t\tsizeof(struct synthvid_version_req);\n\tmsg->ver_req.version = ver;\n\thyperv_sendpacket(hdev, msg);\n\n\tt = wait_for_completion_timeout(&hv->wait, VMBUS_VSP_TIMEOUT);\n\tif (!t) {\n\t\tdrm_err(dev, \"Time out on waiting version response\\n\");\n\t\treturn -ETIMEDOUT;\n\t}\n\n\tif (!msg->ver_resp.is_accepted) {\n\t\tdrm_err(dev, \"Version request not accepted\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\thv->synthvid_version = ver;\n\tdrm_info(dev, \"Synthvid Version major %d, minor %d\\n\",\n\t\t SYNTHVID_VER_GET_MAJOR(ver), SYNTHVID_VER_GET_MINOR(ver));\n\n\treturn 0;\n}\n\nint hyperv_update_vram_location(struct hv_device *hdev, phys_addr_t vram_pp)\n{\n\tstruct hyperv_drm_device *hv = hv_get_drvdata(hdev);\n\tstruct synthvid_msg *msg = (struct synthvid_msg *)hv->init_buf;\n\tstruct drm_device *dev = &hv->dev;\n\tunsigned long t;\n\n\tmemset(msg, 0, sizeof(struct synthvid_msg));\n\tmsg->vid_hdr.type = SYNTHVID_VRAM_LOCATION;\n\tmsg->vid_hdr.size = sizeof(struct synthvid_msg_hdr) +\n\t\tsizeof(struct synthvid_vram_location);\n\tmsg->vram.user_ctx = vram_pp;\n\tmsg->vram.vram_gpa = vram_pp;\n\tmsg->vram.is_vram_gpa_specified = 1;\n\thyperv_sendpacket(hdev, msg);\n\n\tt = wait_for_completion_timeout(&hv->wait, VMBUS_VSP_TIMEOUT);\n\tif (!t) {\n\t\tdrm_err(dev, \"Time out on waiting vram location ack\\n\");\n\t\treturn -ETIMEDOUT;\n\t}\n\tif (msg->vram_ack.user_ctx != vram_pp) {\n\t\tdrm_err(dev, \"Unable to set VRAM location\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\treturn 0;\n}\n\nint hyperv_update_situation(struct hv_device *hdev, u8 active, u32 bpp,\n\t\t\t    u32 w, u32 h, u32 pitch)\n{\n\tstruct synthvid_msg msg;\n\n\tmemset(&msg, 0, sizeof(struct synthvid_msg));\n\n\tmsg.vid_hdr.type = SYNTHVID_SITUATION_UPDATE;\n\tmsg.vid_hdr.size = sizeof(struct synthvid_msg_hdr) +\n\t\tsizeof(struct synthvid_situation_update);\n\tmsg.situ.user_ctx = 0;\n\tmsg.situ.video_output_count = 1;\n\tmsg.situ.video_output[0].active = active;\n\t \n\tmsg.situ.video_output[0].vram_offset = 0;\n\tmsg.situ.video_output[0].depth_bits = bpp;\n\tmsg.situ.video_output[0].width_pixels = w;\n\tmsg.situ.video_output[0].height_pixels = h;\n\tmsg.situ.video_output[0].pitch_bytes = pitch;\n\n\thyperv_sendpacket(hdev, &msg);\n\n\treturn 0;\n}\n\n \nint hyperv_hide_hw_ptr(struct hv_device *hdev)\n{\n\tstruct synthvid_msg msg;\n\n\tmemset(&msg, 0, sizeof(struct synthvid_msg));\n\tmsg.vid_hdr.type = SYNTHVID_POINTER_POSITION;\n\tmsg.vid_hdr.size = sizeof(struct synthvid_msg_hdr) +\n\t\tsizeof(struct synthvid_pointer_position);\n\tmsg.ptr_pos.is_visible = 1;\n\tmsg.ptr_pos.video_output = 0;\n\tmsg.ptr_pos.image_x = 0;\n\tmsg.ptr_pos.image_y = 0;\n\thyperv_sendpacket(hdev, &msg);\n\n\tmemset(&msg, 0, sizeof(struct synthvid_msg));\n\tmsg.vid_hdr.type = SYNTHVID_POINTER_SHAPE;\n\tmsg.vid_hdr.size = sizeof(struct synthvid_msg_hdr) +\n\t\tsizeof(struct synthvid_pointer_shape);\n\tmsg.ptr_shape.part_idx = SYNTHVID_CURSOR_COMPLETE;\n\tmsg.ptr_shape.is_argb = 1;\n\tmsg.ptr_shape.width = 1;\n\tmsg.ptr_shape.height = 1;\n\tmsg.ptr_shape.hot_x = 0;\n\tmsg.ptr_shape.hot_y = 0;\n\tmsg.ptr_shape.data[0] = 0;\n\tmsg.ptr_shape.data[1] = 1;\n\tmsg.ptr_shape.data[2] = 1;\n\tmsg.ptr_shape.data[3] = 1;\n\thyperv_sendpacket(hdev, &msg);\n\n\treturn 0;\n}\n\nint hyperv_update_dirt(struct hv_device *hdev, struct drm_rect *rect)\n{\n\tstruct hyperv_drm_device *hv = hv_get_drvdata(hdev);\n\tstruct synthvid_msg msg;\n\n\tif (!hv->dirt_needed)\n\t\treturn 0;\n\n\tmemset(&msg, 0, sizeof(struct synthvid_msg));\n\n\tmsg.vid_hdr.type = SYNTHVID_DIRT;\n\tmsg.vid_hdr.size = sizeof(struct synthvid_msg_hdr) +\n\t\tsizeof(struct synthvid_dirt);\n\tmsg.dirt.video_output = 0;\n\tmsg.dirt.dirt_count = 1;\n\tmsg.dirt.rect[0].x1 = rect->x1;\n\tmsg.dirt.rect[0].y1 = rect->y1;\n\tmsg.dirt.rect[0].x2 = rect->x2;\n\tmsg.dirt.rect[0].y2 = rect->y2;\n\n\thyperv_sendpacket(hdev, &msg);\n\n\treturn 0;\n}\n\nstatic int hyperv_get_supported_resolution(struct hv_device *hdev)\n{\n\tstruct hyperv_drm_device *hv = hv_get_drvdata(hdev);\n\tstruct synthvid_msg *msg = (struct synthvid_msg *)hv->init_buf;\n\tstruct drm_device *dev = &hv->dev;\n\tunsigned long t;\n\tu8 index;\n\tint i;\n\n\tmemset(msg, 0, sizeof(struct synthvid_msg));\n\tmsg->vid_hdr.type = SYNTHVID_RESOLUTION_REQUEST;\n\tmsg->vid_hdr.size = sizeof(struct synthvid_msg_hdr) +\n\t\tsizeof(struct synthvid_supported_resolution_req);\n\tmsg->resolution_req.maximum_resolution_count =\n\t\tSYNTHVID_MAX_RESOLUTION_COUNT;\n\thyperv_sendpacket(hdev, msg);\n\n\tt = wait_for_completion_timeout(&hv->wait, VMBUS_VSP_TIMEOUT);\n\tif (!t) {\n\t\tdrm_err(dev, \"Time out on waiting resolution response\\n\");\n\t\treturn -ETIMEDOUT;\n\t}\n\n\tif (msg->resolution_resp.resolution_count == 0) {\n\t\tdrm_err(dev, \"No supported resolutions\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tindex = msg->resolution_resp.default_resolution_index;\n\tif (index >= msg->resolution_resp.resolution_count) {\n\t\tdrm_err(dev, \"Invalid resolution index: %d\\n\", index);\n\t\treturn -ENODEV;\n\t}\n\n\tfor (i = 0; i < msg->resolution_resp.resolution_count; i++) {\n\t\thv->screen_width_max = max_t(u32, hv->screen_width_max,\n\t\t\tmsg->resolution_resp.supported_resolution[i].width);\n\t\thv->screen_height_max = max_t(u32, hv->screen_height_max,\n\t\t\tmsg->resolution_resp.supported_resolution[i].height);\n\t}\n\n\thv->preferred_width =\n\t\tmsg->resolution_resp.supported_resolution[index].width;\n\thv->preferred_height =\n\t\tmsg->resolution_resp.supported_resolution[index].height;\n\n\treturn 0;\n}\n\nstatic void hyperv_receive_sub(struct hv_device *hdev)\n{\n\tstruct hyperv_drm_device *hv = hv_get_drvdata(hdev);\n\tstruct synthvid_msg *msg;\n\n\tif (!hv)\n\t\treturn;\n\n\tmsg = (struct synthvid_msg *)hv->recv_buf;\n\n\t \n\tif (msg->vid_hdr.type == SYNTHVID_VERSION_RESPONSE ||\n\t    msg->vid_hdr.type == SYNTHVID_RESOLUTION_RESPONSE ||\n\t    msg->vid_hdr.type == SYNTHVID_VRAM_LOCATION_ACK) {\n\t\tmemcpy(hv->init_buf, msg, VMBUS_MAX_PACKET_SIZE);\n\t\tcomplete(&hv->wait);\n\t\treturn;\n\t}\n\n\tif (msg->vid_hdr.type == SYNTHVID_FEATURE_CHANGE) {\n\t\thv->dirt_needed = msg->feature_chg.is_dirt_needed;\n\t\tif (hv->dirt_needed)\n\t\t\thyperv_hide_hw_ptr(hv->hdev);\n\t}\n}\n\nstatic void hyperv_receive(void *ctx)\n{\n\tstruct hv_device *hdev = ctx;\n\tstruct hyperv_drm_device *hv = hv_get_drvdata(hdev);\n\tstruct synthvid_msg *recv_buf;\n\tu32 bytes_recvd;\n\tu64 req_id;\n\tint ret;\n\n\tif (!hv)\n\t\treturn;\n\n\trecv_buf = (struct synthvid_msg *)hv->recv_buf;\n\n\tdo {\n\t\tret = vmbus_recvpacket(hdev->channel, recv_buf,\n\t\t\t\t       VMBUS_MAX_PACKET_SIZE,\n\t\t\t\t       &bytes_recvd, &req_id);\n\t\tif (bytes_recvd > 0 &&\n\t\t    recv_buf->pipe_hdr.type == PIPE_MSG_DATA)\n\t\t\thyperv_receive_sub(hdev);\n\t} while (bytes_recvd > 0 && ret == 0);\n}\n\nint hyperv_connect_vsp(struct hv_device *hdev)\n{\n\tstruct hyperv_drm_device *hv = hv_get_drvdata(hdev);\n\tstruct drm_device *dev = &hv->dev;\n\tint ret;\n\n\tret = vmbus_open(hdev->channel, VMBUS_RING_BUFSIZE, VMBUS_RING_BUFSIZE,\n\t\t\t NULL, 0, hyperv_receive, hdev);\n\tif (ret) {\n\t\tdrm_err(dev, \"Unable to open vmbus channel\\n\");\n\t\treturn ret;\n\t}\n\n\t \n\tswitch (vmbus_proto_version) {\n\tcase VERSION_WIN10:\n\tcase VERSION_WIN10_V5:\n\t\tret = hyperv_negotiate_version(hdev, SYNTHVID_VERSION_WIN10);\n\t\tif (!ret)\n\t\t\tbreak;\n\t\tfallthrough;\n\tcase VERSION_WIN8:\n\tcase VERSION_WIN8_1:\n\t\tret = hyperv_negotiate_version(hdev, SYNTHVID_VERSION_WIN8);\n\t\tbreak;\n\tdefault:\n\t\tret = hyperv_negotiate_version(hdev, SYNTHVID_VERSION_WIN10);\n\t\tbreak;\n\t}\n\n\tif (ret) {\n\t\tdrm_err(dev, \"Synthetic video device version not accepted %d\\n\", ret);\n\t\tgoto error;\n\t}\n\n\thv->screen_depth = SYNTHVID_DEPTH_WIN8;\n\n\tif (hyperv_version_ge(hv->synthvid_version, SYNTHVID_VERSION_WIN10)) {\n\t\tret = hyperv_get_supported_resolution(hdev);\n\t\tif (ret)\n\t\t\tdrm_err(dev, \"Failed to get supported resolution from host, use default\\n\");\n\t} else {\n\t\thv->screen_width_max = SYNTHVID_WIDTH_WIN8;\n\t\thv->screen_height_max = SYNTHVID_HEIGHT_WIN8;\n\t}\n\n\thv->mmio_megabytes = hdev->channel->offermsg.offer.mmio_megabytes;\n\n\treturn 0;\n\nerror:\n\tvmbus_close(hdev->channel);\n\treturn ret;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}