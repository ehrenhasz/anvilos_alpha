{
  "module_name": "drm_crtc_helper.c",
  "hash_id": "a8003a7275fa2d81b1f7a90e4d22cd7cc416582644026e5b7eddea7c1819fba3",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/drm_crtc_helper.c",
  "human_readable_source": " \n\n#include <linux/export.h>\n#include <linux/kernel.h>\n#include <linux/moduleparam.h>\n#include <linux/dynamic_debug.h>\n\n#include <drm/drm_atomic.h>\n#include <drm/drm_atomic_helper.h>\n#include <drm/drm_atomic_uapi.h>\n#include <drm/drm_bridge.h>\n#include <drm/drm_crtc.h>\n#include <drm/drm_crtc_helper.h>\n#include <drm/drm_drv.h>\n#include <drm/drm_edid.h>\n#include <drm/drm_encoder.h>\n#include <drm/drm_fourcc.h>\n#include <drm/drm_framebuffer.h>\n#include <drm/drm_print.h>\n#include <drm/drm_vblank.h>\n\n#include \"drm_crtc_helper_internal.h\"\n\nDECLARE_DYNDBG_CLASSMAP(drm_debug_classes, DD_CLASS_TYPE_DISJOINT_BITS, 0,\n\t\t\t\"DRM_UT_CORE\",\n\t\t\t\"DRM_UT_DRIVER\",\n\t\t\t\"DRM_UT_KMS\",\n\t\t\t\"DRM_UT_PRIME\",\n\t\t\t\"DRM_UT_ATOMIC\",\n\t\t\t\"DRM_UT_VBL\",\n\t\t\t\"DRM_UT_STATE\",\n\t\t\t\"DRM_UT_LEASE\",\n\t\t\t\"DRM_UT_DP\",\n\t\t\t\"DRM_UT_DRMRES\");\n\n \n\n \nbool drm_helper_encoder_in_use(struct drm_encoder *encoder)\n{\n\tstruct drm_connector *connector;\n\tstruct drm_connector_list_iter conn_iter;\n\tstruct drm_device *dev = encoder->dev;\n\n\tWARN_ON(drm_drv_uses_atomic_modeset(dev));\n\n\t \n\tif (!oops_in_progress) {\n\t\tWARN_ON(!mutex_is_locked(&dev->mode_config.mutex));\n\t\tWARN_ON(!drm_modeset_is_locked(&dev->mode_config.connection_mutex));\n\t}\n\n\n\tdrm_connector_list_iter_begin(dev, &conn_iter);\n\tdrm_for_each_connector_iter(connector, &conn_iter) {\n\t\tif (connector->encoder == encoder) {\n\t\t\tdrm_connector_list_iter_end(&conn_iter);\n\t\t\treturn true;\n\t\t}\n\t}\n\tdrm_connector_list_iter_end(&conn_iter);\n\treturn false;\n}\nEXPORT_SYMBOL(drm_helper_encoder_in_use);\n\n \nbool drm_helper_crtc_in_use(struct drm_crtc *crtc)\n{\n\tstruct drm_encoder *encoder;\n\tstruct drm_device *dev = crtc->dev;\n\n\tWARN_ON(drm_drv_uses_atomic_modeset(dev));\n\n\t \n\tif (!oops_in_progress)\n\t\tWARN_ON(!mutex_is_locked(&dev->mode_config.mutex));\n\n\tdrm_for_each_encoder(encoder, dev)\n\t\tif (encoder->crtc == crtc && drm_helper_encoder_in_use(encoder))\n\t\t\treturn true;\n\treturn false;\n}\nEXPORT_SYMBOL(drm_helper_crtc_in_use);\n\nstatic void\ndrm_encoder_disable(struct drm_encoder *encoder)\n{\n\tconst struct drm_encoder_helper_funcs *encoder_funcs = encoder->helper_private;\n\n\tif (!encoder_funcs)\n\t\treturn;\n\n\tif (encoder_funcs->disable)\n\t\t(*encoder_funcs->disable)(encoder);\n\telse if (encoder_funcs->dpms)\n\t\t(*encoder_funcs->dpms)(encoder, DRM_MODE_DPMS_OFF);\n}\n\nstatic void __drm_helper_disable_unused_functions(struct drm_device *dev)\n{\n\tstruct drm_encoder *encoder;\n\tstruct drm_crtc *crtc;\n\n\tdrm_warn_on_modeset_not_all_locked(dev);\n\n\tdrm_for_each_encoder(encoder, dev) {\n\t\tif (!drm_helper_encoder_in_use(encoder)) {\n\t\t\tdrm_encoder_disable(encoder);\n\t\t\t \n\t\t\tencoder->crtc = NULL;\n\t\t}\n\t}\n\n\tdrm_for_each_crtc(crtc, dev) {\n\t\tconst struct drm_crtc_helper_funcs *crtc_funcs = crtc->helper_private;\n\n\t\tcrtc->enabled = drm_helper_crtc_in_use(crtc);\n\t\tif (!crtc->enabled) {\n\t\t\tif (crtc_funcs->disable)\n\t\t\t\t(*crtc_funcs->disable)(crtc);\n\t\t\telse\n\t\t\t\t(*crtc_funcs->dpms)(crtc, DRM_MODE_DPMS_OFF);\n\t\t\tcrtc->primary->fb = NULL;\n\t\t}\n\t}\n}\n\n \nvoid drm_helper_disable_unused_functions(struct drm_device *dev)\n{\n\tWARN_ON(drm_drv_uses_atomic_modeset(dev));\n\n\tdrm_modeset_lock_all(dev);\n\t__drm_helper_disable_unused_functions(dev);\n\tdrm_modeset_unlock_all(dev);\n}\nEXPORT_SYMBOL(drm_helper_disable_unused_functions);\n\n \nstatic void\ndrm_crtc_prepare_encoders(struct drm_device *dev)\n{\n\tconst struct drm_encoder_helper_funcs *encoder_funcs;\n\tstruct drm_encoder *encoder;\n\n\tdrm_for_each_encoder(encoder, dev) {\n\t\tencoder_funcs = encoder->helper_private;\n\t\tif (!encoder_funcs)\n\t\t\tcontinue;\n\n\t\t \n\t\tif (encoder->crtc == NULL)\n\t\t\tdrm_encoder_disable(encoder);\n\t}\n}\n\n \nbool drm_crtc_helper_set_mode(struct drm_crtc *crtc,\n\t\t\t      struct drm_display_mode *mode,\n\t\t\t      int x, int y,\n\t\t\t      struct drm_framebuffer *old_fb)\n{\n\tstruct drm_device *dev = crtc->dev;\n\tstruct drm_display_mode *adjusted_mode, saved_mode, saved_hwmode;\n\tconst struct drm_crtc_helper_funcs *crtc_funcs = crtc->helper_private;\n\tconst struct drm_encoder_helper_funcs *encoder_funcs;\n\tint saved_x, saved_y;\n\tbool saved_enabled;\n\tstruct drm_encoder *encoder;\n\tbool ret = true;\n\n\tWARN_ON(drm_drv_uses_atomic_modeset(dev));\n\n\tdrm_warn_on_modeset_not_all_locked(dev);\n\n\tsaved_enabled = crtc->enabled;\n\tcrtc->enabled = drm_helper_crtc_in_use(crtc);\n\tif (!crtc->enabled)\n\t\treturn true;\n\n\tadjusted_mode = drm_mode_duplicate(dev, mode);\n\tif (!adjusted_mode) {\n\t\tcrtc->enabled = saved_enabled;\n\t\treturn false;\n\t}\n\n\tdrm_mode_init(&saved_mode, &crtc->mode);\n\tdrm_mode_init(&saved_hwmode, &crtc->hwmode);\n\tsaved_x = crtc->x;\n\tsaved_y = crtc->y;\n\n\t \n\tdrm_mode_copy(&crtc->mode, mode);\n\tcrtc->x = x;\n\tcrtc->y = y;\n\n\t \n\tdrm_for_each_encoder(encoder, dev) {\n\n\t\tif (encoder->crtc != crtc)\n\t\t\tcontinue;\n\n\t\tencoder_funcs = encoder->helper_private;\n\t\tif (!encoder_funcs)\n\t\t\tcontinue;\n\n\t\tencoder_funcs = encoder->helper_private;\n\t\tif (encoder_funcs->mode_fixup) {\n\t\t\tif (!(ret = encoder_funcs->mode_fixup(encoder, mode,\n\t\t\t\t\t\t\t      adjusted_mode))) {\n\t\t\t\tDRM_DEBUG_KMS(\"Encoder fixup failed\\n\");\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (crtc_funcs->mode_fixup) {\n\t\tif (!(ret = crtc_funcs->mode_fixup(crtc, mode,\n\t\t\t\t\t\tadjusted_mode))) {\n\t\t\tDRM_DEBUG_KMS(\"CRTC fixup failed\\n\");\n\t\t\tgoto done;\n\t\t}\n\t}\n\tDRM_DEBUG_KMS(\"[CRTC:%d:%s]\\n\", crtc->base.id, crtc->name);\n\n\tdrm_mode_copy(&crtc->hwmode, adjusted_mode);\n\n\t \n\tdrm_for_each_encoder(encoder, dev) {\n\n\t\tif (encoder->crtc != crtc)\n\t\t\tcontinue;\n\n\t\tencoder_funcs = encoder->helper_private;\n\t\tif (!encoder_funcs)\n\t\t\tcontinue;\n\n\t\t \n\t\tif (encoder_funcs->prepare)\n\t\t\tencoder_funcs->prepare(encoder);\n\t}\n\n\tdrm_crtc_prepare_encoders(dev);\n\n\tcrtc_funcs->prepare(crtc);\n\n\t \n\tret = !crtc_funcs->mode_set(crtc, mode, adjusted_mode, x, y, old_fb);\n\tif (!ret)\n\t    goto done;\n\n\tdrm_for_each_encoder(encoder, dev) {\n\n\t\tif (encoder->crtc != crtc)\n\t\t\tcontinue;\n\n\t\tencoder_funcs = encoder->helper_private;\n\t\tif (!encoder_funcs)\n\t\t\tcontinue;\n\n\t\tDRM_DEBUG_KMS(\"[ENCODER:%d:%s] set [MODE:%s]\\n\",\n\t\t\tencoder->base.id, encoder->name, mode->name);\n\t\tif (encoder_funcs->mode_set)\n\t\t\tencoder_funcs->mode_set(encoder, mode, adjusted_mode);\n\t}\n\n\t \n\tcrtc_funcs->commit(crtc);\n\n\tdrm_for_each_encoder(encoder, dev) {\n\n\t\tif (encoder->crtc != crtc)\n\t\t\tcontinue;\n\n\t\tencoder_funcs = encoder->helper_private;\n\t\tif (!encoder_funcs)\n\t\t\tcontinue;\n\n\t\tif (encoder_funcs->commit)\n\t\t\tencoder_funcs->commit(encoder);\n\t}\n\n\t \n\tdrm_calc_timestamping_constants(crtc, &crtc->hwmode);\n\n\t \ndone:\n\tdrm_mode_destroy(dev, adjusted_mode);\n\tif (!ret) {\n\t\tcrtc->enabled = saved_enabled;\n\t\tdrm_mode_copy(&crtc->mode, &saved_mode);\n\t\tdrm_mode_copy(&crtc->hwmode, &saved_hwmode);\n\t\tcrtc->x = saved_x;\n\t\tcrtc->y = saved_y;\n\t}\n\n\treturn ret;\n}\nEXPORT_SYMBOL(drm_crtc_helper_set_mode);\n\n \nint drm_crtc_helper_atomic_check(struct drm_crtc *crtc, struct drm_atomic_state *state)\n{\n\tstruct drm_crtc_state *new_crtc_state = drm_atomic_get_new_crtc_state(state, crtc);\n\n\tif (!new_crtc_state->enable)\n\t\treturn 0;\n\n\treturn drm_atomic_helper_check_crtc_primary_plane(new_crtc_state);\n}\nEXPORT_SYMBOL(drm_crtc_helper_atomic_check);\n\nstatic void\ndrm_crtc_helper_disable(struct drm_crtc *crtc)\n{\n\tstruct drm_device *dev = crtc->dev;\n\tstruct drm_connector *connector;\n\tstruct drm_encoder *encoder;\n\n\t \n\tdrm_for_each_encoder(encoder, dev) {\n\t\tstruct drm_connector_list_iter conn_iter;\n\n\t\tif (encoder->crtc != crtc)\n\t\t\tcontinue;\n\n\t\tdrm_connector_list_iter_begin(dev, &conn_iter);\n\t\tdrm_for_each_connector_iter(connector, &conn_iter) {\n\t\t\tif (connector->encoder != encoder)\n\t\t\t\tcontinue;\n\n\t\t\tconnector->encoder = NULL;\n\n\t\t\t \n\t\t\tconnector->dpms = DRM_MODE_DPMS_OFF;\n\n\t\t\t \n\t\t\tdrm_connector_put(connector);\n\t\t}\n\t\tdrm_connector_list_iter_end(&conn_iter);\n\t}\n\n\t__drm_helper_disable_unused_functions(dev);\n}\n\n \nstruct drm_encoder *\ndrm_connector_get_single_encoder(struct drm_connector *connector)\n{\n\tstruct drm_encoder *encoder;\n\n\tWARN_ON(hweight32(connector->possible_encoders) > 1);\n\tdrm_connector_for_each_possible_encoder(connector, encoder)\n\t\treturn encoder;\n\n\treturn NULL;\n}\n\n \nint drm_crtc_helper_set_config(struct drm_mode_set *set,\n\t\t\t       struct drm_modeset_acquire_ctx *ctx)\n{\n\tstruct drm_device *dev;\n\tstruct drm_crtc **save_encoder_crtcs, *new_crtc;\n\tstruct drm_encoder **save_connector_encoders, *new_encoder, *encoder;\n\tbool mode_changed = false;  \n\tbool fb_changed = false;  \n\tstruct drm_connector *connector;\n\tstruct drm_connector_list_iter conn_iter;\n\tint count = 0, ro, fail = 0;\n\tconst struct drm_crtc_helper_funcs *crtc_funcs;\n\tstruct drm_mode_set save_set;\n\tint ret;\n\tint i;\n\n\tDRM_DEBUG_KMS(\"\\n\");\n\n\tBUG_ON(!set);\n\tBUG_ON(!set->crtc);\n\tBUG_ON(!set->crtc->helper_private);\n\n\t \n\tBUG_ON(!set->mode && set->fb);\n\tBUG_ON(set->fb && set->num_connectors == 0);\n\n\tcrtc_funcs = set->crtc->helper_private;\n\n\tdev = set->crtc->dev;\n\tWARN_ON(drm_drv_uses_atomic_modeset(dev));\n\n\tif (!set->mode)\n\t\tset->fb = NULL;\n\n\tif (set->fb) {\n\t\tDRM_DEBUG_KMS(\"[CRTC:%d:%s] [FB:%d] #connectors=%d (x y) (%i %i)\\n\",\n\t\t\t      set->crtc->base.id, set->crtc->name,\n\t\t\t      set->fb->base.id,\n\t\t\t      (int)set->num_connectors, set->x, set->y);\n\t} else {\n\t\tDRM_DEBUG_KMS(\"[CRTC:%d:%s] [NOFB]\\n\",\n\t\t\t      set->crtc->base.id, set->crtc->name);\n\t\tdrm_crtc_helper_disable(set->crtc);\n\t\treturn 0;\n\t}\n\n\tdrm_warn_on_modeset_not_all_locked(dev);\n\n\t \n\tsave_encoder_crtcs = kcalloc(dev->mode_config.num_encoder,\n\t\t\t\tsizeof(struct drm_crtc *), GFP_KERNEL);\n\tif (!save_encoder_crtcs)\n\t\treturn -ENOMEM;\n\n\tsave_connector_encoders = kcalloc(dev->mode_config.num_connector,\n\t\t\t\tsizeof(struct drm_encoder *), GFP_KERNEL);\n\tif (!save_connector_encoders) {\n\t\tkfree(save_encoder_crtcs);\n\t\treturn -ENOMEM;\n\t}\n\n\t \n\tcount = 0;\n\tdrm_for_each_encoder(encoder, dev) {\n\t\tsave_encoder_crtcs[count++] = encoder->crtc;\n\t}\n\n\tcount = 0;\n\tdrm_connector_list_iter_begin(dev, &conn_iter);\n\tdrm_for_each_connector_iter(connector, &conn_iter)\n\t\tsave_connector_encoders[count++] = connector->encoder;\n\tdrm_connector_list_iter_end(&conn_iter);\n\n\tsave_set.crtc = set->crtc;\n\tsave_set.mode = &set->crtc->mode;\n\tsave_set.x = set->crtc->x;\n\tsave_set.y = set->crtc->y;\n\tsave_set.fb = set->crtc->primary->fb;\n\n\t \n\tif (set->crtc->primary->fb != set->fb) {\n\t\t \n\t\tif (set->crtc->primary->fb == NULL) {\n\t\t\tDRM_DEBUG_KMS(\"crtc has no fb, full mode set\\n\");\n\t\t\tmode_changed = true;\n\t\t} else if (set->fb->format != set->crtc->primary->fb->format) {\n\t\t\tmode_changed = true;\n\t\t} else\n\t\t\tfb_changed = true;\n\t}\n\n\tif (set->x != set->crtc->x || set->y != set->crtc->y)\n\t\tfb_changed = true;\n\n\tif (!drm_mode_equal(set->mode, &set->crtc->mode)) {\n\t\tDRM_DEBUG_KMS(\"modes are different, full mode set\\n\");\n\t\tdrm_mode_debug_printmodeline(&set->crtc->mode);\n\t\tdrm_mode_debug_printmodeline(set->mode);\n\t\tmode_changed = true;\n\t}\n\n\t \n\tfor (ro = 0; ro < set->num_connectors; ro++) {\n\t\tif (set->connectors[ro]->encoder)\n\t\t\tcontinue;\n\t\tdrm_connector_get(set->connectors[ro]);\n\t}\n\n\t \n\tcount = 0;\n\tdrm_connector_list_iter_begin(dev, &conn_iter);\n\tdrm_for_each_connector_iter(connector, &conn_iter) {\n\t\tconst struct drm_connector_helper_funcs *connector_funcs =\n\t\t\tconnector->helper_private;\n\t\tnew_encoder = connector->encoder;\n\t\tfor (ro = 0; ro < set->num_connectors; ro++) {\n\t\t\tif (set->connectors[ro] == connector) {\n\t\t\t\tif (connector_funcs->best_encoder)\n\t\t\t\t\tnew_encoder = connector_funcs->best_encoder(connector);\n\t\t\t\telse\n\t\t\t\t\tnew_encoder = drm_connector_get_single_encoder(connector);\n\n\t\t\t\t \n\t\t\t\tif (new_encoder == NULL)\n\t\t\t\t\t \n\t\t\t\t\tfail = 1;\n\n\t\t\t\tif (connector->dpms != DRM_MODE_DPMS_ON) {\n\t\t\t\t\tDRM_DEBUG_KMS(\"connector dpms not on, full mode switch\\n\");\n\t\t\t\t\tmode_changed = true;\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (new_encoder != connector->encoder) {\n\t\t\tDRM_DEBUG_KMS(\"encoder changed, full mode switch\\n\");\n\t\t\tmode_changed = true;\n\t\t\t \n\t\t\tif (connector->encoder)\n\t\t\t\tconnector->encoder->crtc = NULL;\n\t\t\tconnector->encoder = new_encoder;\n\t\t}\n\t}\n\tdrm_connector_list_iter_end(&conn_iter);\n\n\tif (fail) {\n\t\tret = -EINVAL;\n\t\tgoto fail;\n\t}\n\n\tcount = 0;\n\tdrm_connector_list_iter_begin(dev, &conn_iter);\n\tdrm_for_each_connector_iter(connector, &conn_iter) {\n\t\tif (!connector->encoder)\n\t\t\tcontinue;\n\n\t\tif (connector->encoder->crtc == set->crtc)\n\t\t\tnew_crtc = NULL;\n\t\telse\n\t\t\tnew_crtc = connector->encoder->crtc;\n\n\t\tfor (ro = 0; ro < set->num_connectors; ro++) {\n\t\t\tif (set->connectors[ro] == connector)\n\t\t\t\tnew_crtc = set->crtc;\n\t\t}\n\n\t\t \n\t\tif (new_crtc &&\n\t\t    !drm_encoder_crtc_ok(connector->encoder, new_crtc)) {\n\t\t\tret = -EINVAL;\n\t\t\tdrm_connector_list_iter_end(&conn_iter);\n\t\t\tgoto fail;\n\t\t}\n\t\tif (new_crtc != connector->encoder->crtc) {\n\t\t\tDRM_DEBUG_KMS(\"crtc changed, full mode switch\\n\");\n\t\t\tmode_changed = true;\n\t\t\tconnector->encoder->crtc = new_crtc;\n\t\t}\n\t\tif (new_crtc) {\n\t\t\tDRM_DEBUG_KMS(\"[CONNECTOR:%d:%s] to [CRTC:%d:%s]\\n\",\n\t\t\t\t      connector->base.id, connector->name,\n\t\t\t\t      new_crtc->base.id, new_crtc->name);\n\t\t} else {\n\t\t\tDRM_DEBUG_KMS(\"[CONNECTOR:%d:%s] to [NOCRTC]\\n\",\n\t\t\t\t      connector->base.id, connector->name);\n\t\t}\n\t}\n\tdrm_connector_list_iter_end(&conn_iter);\n\n\t \n\tif (fb_changed && !crtc_funcs->mode_set_base)\n\t\tmode_changed = true;\n\n\tif (mode_changed) {\n\t\tif (drm_helper_crtc_in_use(set->crtc)) {\n\t\t\tDRM_DEBUG_KMS(\"attempting to set mode from\"\n\t\t\t\t\t\" userspace\\n\");\n\t\t\tdrm_mode_debug_printmodeline(set->mode);\n\t\t\tset->crtc->primary->fb = set->fb;\n\t\t\tif (!drm_crtc_helper_set_mode(set->crtc, set->mode,\n\t\t\t\t\t\t      set->x, set->y,\n\t\t\t\t\t\t      save_set.fb)) {\n\t\t\t\tDRM_ERROR(\"failed to set mode on [CRTC:%d:%s]\\n\",\n\t\t\t\t\t  set->crtc->base.id, set->crtc->name);\n\t\t\t\tset->crtc->primary->fb = save_set.fb;\n\t\t\t\tret = -EINVAL;\n\t\t\t\tgoto fail;\n\t\t\t}\n\t\t\tDRM_DEBUG_KMS(\"Setting connector DPMS state to on\\n\");\n\t\t\tfor (i = 0; i < set->num_connectors; i++) {\n\t\t\t\tDRM_DEBUG_KMS(\"\\t[CONNECTOR:%d:%s] set DPMS on\\n\", set->connectors[i]->base.id,\n\t\t\t\t\t      set->connectors[i]->name);\n\t\t\t\tset->connectors[i]->funcs->dpms(set->connectors[i], DRM_MODE_DPMS_ON);\n\t\t\t}\n\t\t}\n\t\t__drm_helper_disable_unused_functions(dev);\n\t} else if (fb_changed) {\n\t\tset->crtc->x = set->x;\n\t\tset->crtc->y = set->y;\n\t\tset->crtc->primary->fb = set->fb;\n\t\tret = crtc_funcs->mode_set_base(set->crtc,\n\t\t\t\t\t\tset->x, set->y, save_set.fb);\n\t\tif (ret != 0) {\n\t\t\tset->crtc->x = save_set.x;\n\t\t\tset->crtc->y = save_set.y;\n\t\t\tset->crtc->primary->fb = save_set.fb;\n\t\t\tgoto fail;\n\t\t}\n\t}\n\n\tkfree(save_connector_encoders);\n\tkfree(save_encoder_crtcs);\n\treturn 0;\n\nfail:\n\t \n\tcount = 0;\n\tdrm_for_each_encoder(encoder, dev) {\n\t\tencoder->crtc = save_encoder_crtcs[count++];\n\t}\n\n\tcount = 0;\n\tdrm_connector_list_iter_begin(dev, &conn_iter);\n\tdrm_for_each_connector_iter(connector, &conn_iter)\n\t\tconnector->encoder = save_connector_encoders[count++];\n\tdrm_connector_list_iter_end(&conn_iter);\n\n\t \n\tfor (ro = 0; ro < set->num_connectors; ro++) {\n\t\tif (set->connectors[ro]->encoder)\n\t\t\tcontinue;\n\t\tdrm_connector_put(set->connectors[ro]);\n\t}\n\n\t \n\tif (mode_changed &&\n\t    !drm_crtc_helper_set_mode(save_set.crtc, save_set.mode, save_set.x,\n\t\t\t\t      save_set.y, save_set.fb))\n\t\tDRM_ERROR(\"failed to restore config after modeset failure\\n\");\n\n\tkfree(save_connector_encoders);\n\tkfree(save_encoder_crtcs);\n\treturn ret;\n}\nEXPORT_SYMBOL(drm_crtc_helper_set_config);\n\nstatic int drm_helper_choose_encoder_dpms(struct drm_encoder *encoder)\n{\n\tint dpms = DRM_MODE_DPMS_OFF;\n\tstruct drm_connector *connector;\n\tstruct drm_connector_list_iter conn_iter;\n\tstruct drm_device *dev = encoder->dev;\n\n\tdrm_connector_list_iter_begin(dev, &conn_iter);\n\tdrm_for_each_connector_iter(connector, &conn_iter)\n\t\tif (connector->encoder == encoder)\n\t\t\tif (connector->dpms < dpms)\n\t\t\t\tdpms = connector->dpms;\n\tdrm_connector_list_iter_end(&conn_iter);\n\n\treturn dpms;\n}\n\n \nstatic void drm_helper_encoder_dpms(struct drm_encoder *encoder, int mode)\n{\n\tconst struct drm_encoder_helper_funcs *encoder_funcs;\n\n\tencoder_funcs = encoder->helper_private;\n\tif (!encoder_funcs)\n\t\treturn;\n\n\tif (encoder_funcs->dpms)\n\t\tencoder_funcs->dpms(encoder, mode);\n}\n\nstatic int drm_helper_choose_crtc_dpms(struct drm_crtc *crtc)\n{\n\tint dpms = DRM_MODE_DPMS_OFF;\n\tstruct drm_connector *connector;\n\tstruct drm_connector_list_iter conn_iter;\n\tstruct drm_device *dev = crtc->dev;\n\n\tdrm_connector_list_iter_begin(dev, &conn_iter);\n\tdrm_for_each_connector_iter(connector, &conn_iter)\n\t\tif (connector->encoder && connector->encoder->crtc == crtc)\n\t\t\tif (connector->dpms < dpms)\n\t\t\t\tdpms = connector->dpms;\n\tdrm_connector_list_iter_end(&conn_iter);\n\n\treturn dpms;\n}\n\n \nint drm_helper_connector_dpms(struct drm_connector *connector, int mode)\n{\n\tstruct drm_encoder *encoder = connector->encoder;\n\tstruct drm_crtc *crtc = encoder ? encoder->crtc : NULL;\n\tint old_dpms, encoder_dpms = DRM_MODE_DPMS_OFF;\n\n\tWARN_ON(drm_drv_uses_atomic_modeset(connector->dev));\n\n\tif (mode == connector->dpms)\n\t\treturn 0;\n\n\told_dpms = connector->dpms;\n\tconnector->dpms = mode;\n\n\tif (encoder)\n\t\tencoder_dpms = drm_helper_choose_encoder_dpms(encoder);\n\n\t \n\tif (mode < old_dpms) {\n\t\tif (crtc) {\n\t\t\tconst struct drm_crtc_helper_funcs *crtc_funcs = crtc->helper_private;\n\n\t\t\tif (crtc_funcs->dpms)\n\t\t\t\t(*crtc_funcs->dpms) (crtc,\n\t\t\t\t\t\t     drm_helper_choose_crtc_dpms(crtc));\n\t\t}\n\t\tif (encoder)\n\t\t\tdrm_helper_encoder_dpms(encoder, encoder_dpms);\n\t}\n\n\t \n\tif (mode > old_dpms) {\n\t\tif (encoder)\n\t\t\tdrm_helper_encoder_dpms(encoder, encoder_dpms);\n\t\tif (crtc) {\n\t\t\tconst struct drm_crtc_helper_funcs *crtc_funcs = crtc->helper_private;\n\n\t\t\tif (crtc_funcs->dpms)\n\t\t\t\t(*crtc_funcs->dpms) (crtc,\n\t\t\t\t\t\t     drm_helper_choose_crtc_dpms(crtc));\n\t\t}\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL(drm_helper_connector_dpms);\n\n \nvoid drm_helper_resume_force_mode(struct drm_device *dev)\n{\n\tstruct drm_crtc *crtc;\n\tstruct drm_encoder *encoder;\n\tconst struct drm_crtc_helper_funcs *crtc_funcs;\n\tint encoder_dpms;\n\tbool ret;\n\n\tWARN_ON(drm_drv_uses_atomic_modeset(dev));\n\n\tdrm_modeset_lock_all(dev);\n\tdrm_for_each_crtc(crtc, dev) {\n\n\t\tif (!crtc->enabled)\n\t\t\tcontinue;\n\n\t\tret = drm_crtc_helper_set_mode(crtc, &crtc->mode,\n\t\t\t\t\t       crtc->x, crtc->y, crtc->primary->fb);\n\n\t\t \n\t\tif (ret == false)\n\t\t\tDRM_ERROR(\"failed to set mode on crtc %p\\n\", crtc);\n\n\t\t \n\t\tif (drm_helper_choose_crtc_dpms(crtc)) {\n\t\t\tdrm_for_each_encoder(encoder, dev) {\n\n\t\t\t\tif(encoder->crtc != crtc)\n\t\t\t\t\tcontinue;\n\n\t\t\t\tencoder_dpms = drm_helper_choose_encoder_dpms(\n\t\t\t\t\t\t\tencoder);\n\n\t\t\t\tdrm_helper_encoder_dpms(encoder, encoder_dpms);\n\t\t\t}\n\n\t\t\tcrtc_funcs = crtc->helper_private;\n\t\t\tif (crtc_funcs->dpms)\n\t\t\t\t(*crtc_funcs->dpms) (crtc,\n\t\t\t\t\t\t     drm_helper_choose_crtc_dpms(crtc));\n\t\t}\n\t}\n\n\t \n\t__drm_helper_disable_unused_functions(dev);\n\tdrm_modeset_unlock_all(dev);\n}\nEXPORT_SYMBOL(drm_helper_resume_force_mode);\n\n \nint drm_helper_force_disable_all(struct drm_device *dev)\n{\n\tstruct drm_crtc *crtc;\n\tint ret = 0;\n\n\tdrm_modeset_lock_all(dev);\n\tdrm_for_each_crtc(crtc, dev)\n\t\tif (crtc->enabled) {\n\t\t\tstruct drm_mode_set set = {\n\t\t\t\t.crtc = crtc,\n\t\t\t};\n\n\t\t\tret = drm_mode_set_config_internal(&set);\n\t\t\tif (ret)\n\t\t\t\tgoto out;\n\t\t}\nout:\n\tdrm_modeset_unlock_all(dev);\n\treturn ret;\n}\nEXPORT_SYMBOL(drm_helper_force_disable_all);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}