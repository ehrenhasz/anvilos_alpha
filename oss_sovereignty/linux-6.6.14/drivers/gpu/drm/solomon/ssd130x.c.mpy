{
  "module_name": "ssd130x.c",
  "hash_id": "9105258062644ef001c738a1ab7f31d2bdfb4d3aea7ce02d43789c86de149dca",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/solomon/ssd130x.c",
  "human_readable_source": "\n \n\n#include <linux/backlight.h>\n#include <linux/bitfield.h>\n#include <linux/bits.h>\n#include <linux/delay.h>\n#include <linux/gpio/consumer.h>\n#include <linux/property.h>\n#include <linux/pwm.h>\n#include <linux/regulator/consumer.h>\n\n#include <drm/drm_atomic.h>\n#include <drm/drm_atomic_helper.h>\n#include <drm/drm_crtc_helper.h>\n#include <drm/drm_damage_helper.h>\n#include <drm/drm_edid.h>\n#include <drm/drm_fbdev_generic.h>\n#include <drm/drm_format_helper.h>\n#include <drm/drm_framebuffer.h>\n#include <drm/drm_gem_atomic_helper.h>\n#include <drm/drm_gem_framebuffer_helper.h>\n#include <drm/drm_gem_shmem_helper.h>\n#include <drm/drm_managed.h>\n#include <drm/drm_modes.h>\n#include <drm/drm_rect.h>\n#include <drm/drm_probe_helper.h>\n\n#include \"ssd130x.h\"\n\n#define DRIVER_NAME\t\"ssd130x\"\n#define DRIVER_DESC\t\"DRM driver for Solomon SSD130x OLED displays\"\n#define DRIVER_DATE\t\"20220131\"\n#define DRIVER_MAJOR\t1\n#define DRIVER_MINOR\t0\n\n#define SSD130X_PAGE_COL_START_LOW\t\t0x00\n#define SSD130X_PAGE_COL_START_HIGH\t\t0x10\n#define SSD130X_SET_ADDRESS_MODE\t\t0x20\n#define SSD130X_SET_COL_RANGE\t\t\t0x21\n#define SSD130X_SET_PAGE_RANGE\t\t\t0x22\n#define SSD130X_CONTRAST\t\t\t0x81\n#define SSD130X_SET_LOOKUP_TABLE\t\t0x91\n#define SSD130X_CHARGE_PUMP\t\t\t0x8d\n#define SSD130X_SET_SEG_REMAP\t\t\t0xa0\n#define SSD130X_DISPLAY_OFF\t\t\t0xae\n#define SSD130X_SET_MULTIPLEX_RATIO\t\t0xa8\n#define SSD130X_DISPLAY_ON\t\t\t0xaf\n#define SSD130X_START_PAGE_ADDRESS\t\t0xb0\n#define SSD130X_SET_COM_SCAN_DIR\t\t0xc0\n#define SSD130X_SET_DISPLAY_OFFSET\t\t0xd3\n#define SSD130X_SET_CLOCK_FREQ\t\t\t0xd5\n#define SSD130X_SET_AREA_COLOR_MODE\t\t0xd8\n#define SSD130X_SET_PRECHARGE_PERIOD\t\t0xd9\n#define SSD130X_SET_COM_PINS_CONFIG\t\t0xda\n#define SSD130X_SET_VCOMH\t\t\t0xdb\n\n#define SSD130X_PAGE_COL_START_MASK\t\tGENMASK(3, 0)\n#define SSD130X_PAGE_COL_START_HIGH_SET(val)\tFIELD_PREP(SSD130X_PAGE_COL_START_MASK, (val) >> 4)\n#define SSD130X_PAGE_COL_START_LOW_SET(val)\tFIELD_PREP(SSD130X_PAGE_COL_START_MASK, (val))\n#define SSD130X_START_PAGE_ADDRESS_MASK\t\tGENMASK(2, 0)\n#define SSD130X_START_PAGE_ADDRESS_SET(val)\tFIELD_PREP(SSD130X_START_PAGE_ADDRESS_MASK, (val))\n#define SSD130X_SET_SEG_REMAP_MASK\t\tGENMASK(0, 0)\n#define SSD130X_SET_SEG_REMAP_SET(val)\t\tFIELD_PREP(SSD130X_SET_SEG_REMAP_MASK, (val))\n#define SSD130X_SET_COM_SCAN_DIR_MASK\t\tGENMASK(3, 3)\n#define SSD130X_SET_COM_SCAN_DIR_SET(val)\tFIELD_PREP(SSD130X_SET_COM_SCAN_DIR_MASK, (val))\n#define SSD130X_SET_CLOCK_DIV_MASK\t\tGENMASK(3, 0)\n#define SSD130X_SET_CLOCK_DIV_SET(val)\t\tFIELD_PREP(SSD130X_SET_CLOCK_DIV_MASK, (val))\n#define SSD130X_SET_CLOCK_FREQ_MASK\t\tGENMASK(7, 4)\n#define SSD130X_SET_CLOCK_FREQ_SET(val)\t\tFIELD_PREP(SSD130X_SET_CLOCK_FREQ_MASK, (val))\n#define SSD130X_SET_PRECHARGE_PERIOD1_MASK\tGENMASK(3, 0)\n#define SSD130X_SET_PRECHARGE_PERIOD1_SET(val)\tFIELD_PREP(SSD130X_SET_PRECHARGE_PERIOD1_MASK, (val))\n#define SSD130X_SET_PRECHARGE_PERIOD2_MASK\tGENMASK(7, 4)\n#define SSD130X_SET_PRECHARGE_PERIOD2_SET(val)\tFIELD_PREP(SSD130X_SET_PRECHARGE_PERIOD2_MASK, (val))\n#define SSD130X_SET_COM_PINS_CONFIG1_MASK\tGENMASK(4, 4)\n#define SSD130X_SET_COM_PINS_CONFIG1_SET(val)\tFIELD_PREP(SSD130X_SET_COM_PINS_CONFIG1_MASK, (val))\n#define SSD130X_SET_COM_PINS_CONFIG2_MASK\tGENMASK(5, 5)\n#define SSD130X_SET_COM_PINS_CONFIG2_SET(val)\tFIELD_PREP(SSD130X_SET_COM_PINS_CONFIG2_MASK, (val))\n\n#define SSD130X_SET_ADDRESS_MODE_HORIZONTAL\t0x00\n#define SSD130X_SET_ADDRESS_MODE_VERTICAL\t0x01\n#define SSD130X_SET_ADDRESS_MODE_PAGE\t\t0x02\n\n#define SSD130X_SET_AREA_COLOR_MODE_ENABLE\t0x1e\n#define SSD130X_SET_AREA_COLOR_MODE_LOW_POWER\t0x05\n\n#define MAX_CONTRAST 255\n\nconst struct ssd130x_deviceinfo ssd130x_variants[] = {\n\t[SH1106_ID] = {\n\t\t.default_vcomh = 0x40,\n\t\t.default_dclk_div = 1,\n\t\t.default_dclk_frq = 5,\n\t\t.default_width = 132,\n\t\t.default_height = 64,\n\t\t.page_mode_only = 1,\n\t\t.page_height = 8,\n\t},\n\t[SSD1305_ID] = {\n\t\t.default_vcomh = 0x34,\n\t\t.default_dclk_div = 1,\n\t\t.default_dclk_frq = 7,\n\t\t.default_width = 132,\n\t\t.default_height = 64,\n\t\t.page_height = 8,\n\t},\n\t[SSD1306_ID] = {\n\t\t.default_vcomh = 0x20,\n\t\t.default_dclk_div = 1,\n\t\t.default_dclk_frq = 8,\n\t\t.need_chargepump = 1,\n\t\t.default_width = 128,\n\t\t.default_height = 64,\n\t\t.page_height = 8,\n\t},\n\t[SSD1307_ID] = {\n\t\t.default_vcomh = 0x20,\n\t\t.default_dclk_div = 2,\n\t\t.default_dclk_frq = 12,\n\t\t.need_pwm = 1,\n\t\t.default_width = 128,\n\t\t.default_height = 39,\n\t\t.page_height = 8,\n\t},\n\t[SSD1309_ID] = {\n\t\t.default_vcomh = 0x34,\n\t\t.default_dclk_div = 1,\n\t\t.default_dclk_frq = 10,\n\t\t.default_width = 128,\n\t\t.default_height = 64,\n\t\t.page_height = 8,\n\t}\n};\nEXPORT_SYMBOL_NS_GPL(ssd130x_variants, DRM_SSD130X);\n\nstruct ssd130x_plane_state {\n\tstruct drm_shadow_plane_state base;\n\t \n\tu8 *buffer;\n\t \n\tu8 *data_array;\n};\n\nstatic inline struct ssd130x_plane_state *to_ssd130x_plane_state(struct drm_plane_state *state)\n{\n\treturn container_of(state, struct ssd130x_plane_state, base.base);\n}\n\nstatic inline struct ssd130x_device *drm_to_ssd130x(struct drm_device *drm)\n{\n\treturn container_of(drm, struct ssd130x_device, drm);\n}\n\n \nstatic int ssd130x_write_data(struct ssd130x_device *ssd130x, u8 *values, int count)\n{\n\treturn regmap_bulk_write(ssd130x->regmap, SSD130X_DATA, values, count);\n}\n\n \nstatic int ssd130x_write_cmd(struct ssd130x_device *ssd130x, int count,\n\t\t\t      ...)\n{\n\tva_list ap;\n\tu8 value;\n\tint ret;\n\n\tva_start(ap, count);\n\n\tdo {\n\t\tvalue = va_arg(ap, int);\n\t\tret = regmap_write(ssd130x->regmap, SSD130X_COMMAND, value);\n\t\tif (ret)\n\t\t\tgoto out_end;\n\t} while (--count);\n\nout_end:\n\tva_end(ap);\n\n\treturn ret;\n}\n\n \nstatic int ssd130x_set_col_range(struct ssd130x_device *ssd130x,\n\t\t\t\t u8 col_start, u8 cols)\n{\n\tu8 col_end = col_start + cols - 1;\n\tint ret;\n\n\tif (col_start == ssd130x->col_start && col_end == ssd130x->col_end)\n\t\treturn 0;\n\n\tret = ssd130x_write_cmd(ssd130x, 3, SSD130X_SET_COL_RANGE, col_start, col_end);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tssd130x->col_start = col_start;\n\tssd130x->col_end = col_end;\n\treturn 0;\n}\n\nstatic int ssd130x_set_page_range(struct ssd130x_device *ssd130x,\n\t\t\t\t  u8 page_start, u8 pages)\n{\n\tu8 page_end = page_start + pages - 1;\n\tint ret;\n\n\tif (page_start == ssd130x->page_start && page_end == ssd130x->page_end)\n\t\treturn 0;\n\n\tret = ssd130x_write_cmd(ssd130x, 3, SSD130X_SET_PAGE_RANGE, page_start, page_end);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tssd130x->page_start = page_start;\n\tssd130x->page_end = page_end;\n\treturn 0;\n}\n\n \nstatic int ssd130x_set_page_pos(struct ssd130x_device *ssd130x,\n\t\t\t\tu8 page_start, u8 col_start)\n{\n\tint ret;\n\tu32 page, col_low, col_high;\n\n\tpage = SSD130X_START_PAGE_ADDRESS |\n\t       SSD130X_START_PAGE_ADDRESS_SET(page_start);\n\tcol_low = SSD130X_PAGE_COL_START_LOW |\n\t\t  SSD130X_PAGE_COL_START_LOW_SET(col_start);\n\tcol_high = SSD130X_PAGE_COL_START_HIGH |\n\t\t   SSD130X_PAGE_COL_START_HIGH_SET(col_start);\n\tret = ssd130x_write_cmd(ssd130x, 3, page, col_low, col_high);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn 0;\n}\n\nstatic int ssd130x_pwm_enable(struct ssd130x_device *ssd130x)\n{\n\tstruct device *dev = ssd130x->dev;\n\tstruct pwm_state pwmstate;\n\n\tssd130x->pwm = pwm_get(dev, NULL);\n\tif (IS_ERR(ssd130x->pwm)) {\n\t\tdev_err(dev, \"Could not get PWM from firmware description!\\n\");\n\t\treturn PTR_ERR(ssd130x->pwm);\n\t}\n\n\tpwm_init_state(ssd130x->pwm, &pwmstate);\n\tpwm_set_relative_duty_cycle(&pwmstate, 50, 100);\n\tpwm_apply_state(ssd130x->pwm, &pwmstate);\n\n\t \n\tpwm_enable(ssd130x->pwm);\n\n\tdev_dbg(dev, \"Using PWM%d with a %lluns period.\\n\",\n\t\tssd130x->pwm->pwm, pwm_get_period(ssd130x->pwm));\n\n\treturn 0;\n}\n\nstatic void ssd130x_reset(struct ssd130x_device *ssd130x)\n{\n\tif (!ssd130x->reset)\n\t\treturn;\n\n\t \n\tgpiod_set_value_cansleep(ssd130x->reset, 1);\n\tudelay(4);\n\tgpiod_set_value_cansleep(ssd130x->reset, 0);\n\tudelay(4);\n}\n\nstatic int ssd130x_power_on(struct ssd130x_device *ssd130x)\n{\n\tstruct device *dev = ssd130x->dev;\n\tint ret;\n\n\tssd130x_reset(ssd130x);\n\n\tret = regulator_enable(ssd130x->vcc_reg);\n\tif (ret) {\n\t\tdev_err(dev, \"Failed to enable VCC: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tif (ssd130x->device_info->need_pwm) {\n\t\tret = ssd130x_pwm_enable(ssd130x);\n\t\tif (ret) {\n\t\t\tdev_err(dev, \"Failed to enable PWM: %d\\n\", ret);\n\t\t\tregulator_disable(ssd130x->vcc_reg);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic void ssd130x_power_off(struct ssd130x_device *ssd130x)\n{\n\tpwm_disable(ssd130x->pwm);\n\tpwm_put(ssd130x->pwm);\n\n\tregulator_disable(ssd130x->vcc_reg);\n}\n\nstatic int ssd130x_init(struct ssd130x_device *ssd130x)\n{\n\tu32 precharge, dclk, com_invdir, compins, chargepump, seg_remap;\n\tbool scan_mode;\n\tint ret;\n\n\t \n\tret = ssd130x_write_cmd(ssd130x, 2, SSD130X_CONTRAST, ssd130x->contrast);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tseg_remap = (SSD130X_SET_SEG_REMAP |\n\t\t     SSD130X_SET_SEG_REMAP_SET(ssd130x->seg_remap));\n\tret = ssd130x_write_cmd(ssd130x, 1, seg_remap);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tcom_invdir = (SSD130X_SET_COM_SCAN_DIR |\n\t\t      SSD130X_SET_COM_SCAN_DIR_SET(ssd130x->com_invdir));\n\tret = ssd130x_write_cmd(ssd130x,  1, com_invdir);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tret = ssd130x_write_cmd(ssd130x, 2, SSD130X_SET_MULTIPLEX_RATIO, ssd130x->height - 1);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tret = ssd130x_write_cmd(ssd130x, 2, SSD130X_SET_DISPLAY_OFFSET, ssd130x->com_offset);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tdclk = (SSD130X_SET_CLOCK_DIV_SET(ssd130x->dclk_div - 1) |\n\t\tSSD130X_SET_CLOCK_FREQ_SET(ssd130x->dclk_frq));\n\tret = ssd130x_write_cmd(ssd130x, 2, SSD130X_SET_CLOCK_FREQ, dclk);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tif (ssd130x->area_color_enable || ssd130x->low_power) {\n\t\tu32 mode = 0;\n\n\t\tif (ssd130x->area_color_enable)\n\t\t\tmode |= SSD130X_SET_AREA_COLOR_MODE_ENABLE;\n\n\t\tif (ssd130x->low_power)\n\t\t\tmode |= SSD130X_SET_AREA_COLOR_MODE_LOW_POWER;\n\n\t\tret = ssd130x_write_cmd(ssd130x, 2, SSD130X_SET_AREA_COLOR_MODE, mode);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\t \n\tprecharge = (SSD130X_SET_PRECHARGE_PERIOD1_SET(ssd130x->prechargep1) |\n\t\t     SSD130X_SET_PRECHARGE_PERIOD2_SET(ssd130x->prechargep2));\n\tret = ssd130x_write_cmd(ssd130x, 2, SSD130X_SET_PRECHARGE_PERIOD, precharge);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tcompins = BIT(1);\n\t \n\tscan_mode = !ssd130x->com_seq;\n\tcompins |= (SSD130X_SET_COM_PINS_CONFIG1_SET(scan_mode) |\n\t\t    SSD130X_SET_COM_PINS_CONFIG2_SET(ssd130x->com_lrremap));\n\tret = ssd130x_write_cmd(ssd130x, 2, SSD130X_SET_COM_PINS_CONFIG, compins);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tret = ssd130x_write_cmd(ssd130x, 2, SSD130X_SET_VCOMH, ssd130x->vcomh);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tchargepump = BIT(4);\n\n\tif (ssd130x->device_info->need_chargepump)\n\t\tchargepump |= BIT(2);\n\n\tret = ssd130x_write_cmd(ssd130x, 2, SSD130X_CHARGE_PUMP, chargepump);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tif (ssd130x->lookup_table_set) {\n\t\tint i;\n\n\t\tret = ssd130x_write_cmd(ssd130x, 1, SSD130X_SET_LOOKUP_TABLE);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tfor (i = 0; i < ARRAY_SIZE(ssd130x->lookup_table); i++) {\n\t\t\tu8 val = ssd130x->lookup_table[i];\n\n\t\t\tif (val < 31 || val > 63)\n\t\t\t\tdev_warn(ssd130x->dev,\n\t\t\t\t\t \"lookup table index %d value out of range 31 <= %d <= 63\\n\",\n\t\t\t\t\t i, val);\n\t\t\tret = ssd130x_write_cmd(ssd130x, 1, val);\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\t\t}\n\t}\n\n\t \n\tif (ssd130x->page_address_mode)\n\t\treturn ssd130x_write_cmd(ssd130x, 2, SSD130X_SET_ADDRESS_MODE,\n\t\t\t\t\t SSD130X_SET_ADDRESS_MODE_PAGE);\n\n\t \n\treturn ssd130x_write_cmd(ssd130x, 2, SSD130X_SET_ADDRESS_MODE,\n\t\t\t\t SSD130X_SET_ADDRESS_MODE_HORIZONTAL);\n}\n\nstatic int ssd130x_update_rect(struct ssd130x_device *ssd130x,\n\t\t\t       struct ssd130x_plane_state *ssd130x_state,\n\t\t\t       struct drm_rect *rect)\n{\n\tunsigned int x = rect->x1;\n\tunsigned int y = rect->y1;\n\tu8 *buf = ssd130x_state->buffer;\n\tu8 *data_array = ssd130x_state->data_array;\n\tunsigned int width = drm_rect_width(rect);\n\tunsigned int height = drm_rect_height(rect);\n\tunsigned int line_length = DIV_ROUND_UP(width, 8);\n\tunsigned int page_height = ssd130x->device_info->page_height;\n\tunsigned int pages = DIV_ROUND_UP(height, page_height);\n\tstruct drm_device *drm = &ssd130x->drm;\n\tu32 array_idx = 0;\n\tint ret, i, j, k;\n\n\tdrm_WARN_ONCE(drm, y % 8 != 0, \"y must be aligned to screen page\\n\");\n\n\t \n\n\tif (!ssd130x->page_address_mode) {\n\t\t \n\t\tret = ssd130x_set_col_range(ssd130x, ssd130x->col_offset + x, width);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tret = ssd130x_set_page_range(ssd130x, ssd130x->page_offset + y / 8, pages);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\tfor (i = 0; i < pages; i++) {\n\t\tint m = 8;\n\n\t\t \n\t\tif (8 * (y / 8 + i + 1) > ssd130x->height)\n\t\t\tm = ssd130x->height % 8;\n\t\tfor (j = 0; j < width; j++) {\n\t\t\tu8 data = 0;\n\n\t\t\tfor (k = 0; k < m; k++) {\n\t\t\t\tu8 byte = buf[(8 * i + k) * line_length + j / 8];\n\t\t\t\tu8 bit = (byte >> (j % 8)) & 1;\n\n\t\t\t\tdata |= bit << k;\n\t\t\t}\n\t\t\tdata_array[array_idx++] = data;\n\t\t}\n\n\t\t \n\t\tif (ssd130x->page_address_mode) {\n\t\t\tret = ssd130x_set_page_pos(ssd130x,\n\t\t\t\t\t\t   ssd130x->page_offset + i,\n\t\t\t\t\t\t   ssd130x->col_offset + x);\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\n\t\t\tret = ssd130x_write_data(ssd130x, data_array, width);\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\n\t\t\tarray_idx = 0;\n\t\t}\n\t}\n\n\t \n\tif (!ssd130x->page_address_mode)\n\t\tret = ssd130x_write_data(ssd130x, data_array, width * pages);\n\n\treturn ret;\n}\n\nstatic void ssd130x_clear_screen(struct ssd130x_device *ssd130x,\n\t\t\t\t struct ssd130x_plane_state *ssd130x_state)\n{\n\tunsigned int page_height = ssd130x->device_info->page_height;\n\tunsigned int pages = DIV_ROUND_UP(ssd130x->height, page_height);\n\tu8 *data_array = ssd130x_state->data_array;\n\tunsigned int width = ssd130x->width;\n\tint ret, i;\n\n\tif (!ssd130x->page_address_mode) {\n\t\tmemset(data_array, 0, width * pages);\n\n\t\t \n\t\tret = ssd130x_set_col_range(ssd130x, ssd130x->col_offset, width);\n\t\tif (ret < 0)\n\t\t\treturn;\n\n\t\tret = ssd130x_set_page_range(ssd130x, ssd130x->page_offset, pages);\n\t\tif (ret < 0)\n\t\t\treturn;\n\n\t\t \n\t\tssd130x_write_data(ssd130x, data_array, width * pages);\n\t} else {\n\t\t \n\t\tmemset(data_array, 0, width);\n\n\t\tfor (i = 0; i < pages; i++) {\n\t\t\tret = ssd130x_set_page_pos(ssd130x,\n\t\t\t\t\t\t   ssd130x->page_offset + i,\n\t\t\t\t\t\t   ssd130x->col_offset);\n\t\t\tif (ret < 0)\n\t\t\t\treturn;\n\n\t\t\tret = ssd130x_write_data(ssd130x, data_array, width);\n\t\t\tif (ret < 0)\n\t\t\t\treturn;\n\t\t}\n\t}\n}\n\nstatic int ssd130x_fb_blit_rect(struct drm_plane_state *state,\n\t\t\t\tconst struct iosys_map *vmap,\n\t\t\t\tstruct drm_rect *rect)\n{\n\tstruct drm_framebuffer *fb = state->fb;\n\tstruct ssd130x_device *ssd130x = drm_to_ssd130x(fb->dev);\n\tunsigned int page_height = ssd130x->device_info->page_height;\n\tstruct ssd130x_plane_state *ssd130x_state = to_ssd130x_plane_state(state);\n\tu8 *buf = ssd130x_state->buffer;\n\tstruct iosys_map dst;\n\tunsigned int dst_pitch;\n\tint ret = 0;\n\n\t \n\trect->y1 = round_down(rect->y1, page_height);\n\trect->y2 = min_t(unsigned int, round_up(rect->y2, page_height), ssd130x->height);\n\n\tdst_pitch = DIV_ROUND_UP(drm_rect_width(rect), 8);\n\n\tret = drm_gem_fb_begin_cpu_access(fb, DMA_FROM_DEVICE);\n\tif (ret)\n\t\treturn ret;\n\n\tiosys_map_set_vaddr(&dst, buf);\n\tdrm_fb_xrgb8888_to_mono(&dst, &dst_pitch, vmap, fb, rect);\n\n\tdrm_gem_fb_end_cpu_access(fb, DMA_FROM_DEVICE);\n\n\tssd130x_update_rect(ssd130x, ssd130x_state, rect);\n\n\treturn ret;\n}\n\nstatic int ssd130x_primary_plane_helper_atomic_check(struct drm_plane *plane,\n\t\t\t\t\t\t     struct drm_atomic_state *state)\n{\n\tstruct drm_device *drm = plane->dev;\n\tstruct ssd130x_device *ssd130x = drm_to_ssd130x(drm);\n\tstruct drm_plane_state *plane_state = drm_atomic_get_new_plane_state(state, plane);\n\tstruct ssd130x_plane_state *ssd130x_state = to_ssd130x_plane_state(plane_state);\n\tunsigned int page_height = ssd130x->device_info->page_height;\n\tunsigned int pages = DIV_ROUND_UP(ssd130x->height, page_height);\n\tconst struct drm_format_info *fi;\n\tunsigned int pitch;\n\tint ret;\n\n\tret = drm_plane_helper_atomic_check(plane, state);\n\tif (ret)\n\t\treturn ret;\n\n\tfi = drm_format_info(DRM_FORMAT_R1);\n\tif (!fi)\n\t\treturn -EINVAL;\n\n\tpitch = drm_format_info_min_pitch(fi, 0, ssd130x->width);\n\n\tssd130x_state->buffer = kcalloc(pitch, ssd130x->height, GFP_KERNEL);\n\tif (!ssd130x_state->buffer)\n\t\treturn -ENOMEM;\n\n\tssd130x_state->data_array = kcalloc(ssd130x->width, pages, GFP_KERNEL);\n\tif (!ssd130x_state->data_array) {\n\t\tkfree(ssd130x_state->buffer);\n\t\t \n\t\tssd130x_state->buffer = NULL;\n\t\treturn -ENOMEM;\n\t}\n\n\treturn 0;\n}\n\nstatic void ssd130x_primary_plane_helper_atomic_update(struct drm_plane *plane,\n\t\t\t\t\t\t       struct drm_atomic_state *state)\n{\n\tstruct drm_plane_state *plane_state = drm_atomic_get_new_plane_state(state, plane);\n\tstruct drm_plane_state *old_plane_state = drm_atomic_get_old_plane_state(state, plane);\n\tstruct drm_shadow_plane_state *shadow_plane_state = to_drm_shadow_plane_state(plane_state);\n\tstruct drm_atomic_helper_damage_iter iter;\n\tstruct drm_device *drm = plane->dev;\n\tstruct drm_rect dst_clip;\n\tstruct drm_rect damage;\n\tint idx;\n\n\tif (!drm_dev_enter(drm, &idx))\n\t\treturn;\n\n\tdrm_atomic_helper_damage_iter_init(&iter, old_plane_state, plane_state);\n\tdrm_atomic_for_each_plane_damage(&iter, &damage) {\n\t\tdst_clip = plane_state->dst;\n\n\t\tif (!drm_rect_intersect(&dst_clip, &damage))\n\t\t\tcontinue;\n\n\t\tssd130x_fb_blit_rect(plane_state, &shadow_plane_state->data[0], &dst_clip);\n\t}\n\n\tdrm_dev_exit(idx);\n}\n\nstatic void ssd130x_primary_plane_helper_atomic_disable(struct drm_plane *plane,\n\t\t\t\t\t\t\tstruct drm_atomic_state *state)\n{\n\tstruct drm_device *drm = plane->dev;\n\tstruct ssd130x_device *ssd130x = drm_to_ssd130x(drm);\n\tstruct ssd130x_plane_state *ssd130x_state = to_ssd130x_plane_state(plane->state);\n\tint idx;\n\n\tif (!drm_dev_enter(drm, &idx))\n\t\treturn;\n\n\tssd130x_clear_screen(ssd130x, ssd130x_state);\n\n\tdrm_dev_exit(idx);\n}\n\n \nstatic void ssd130x_primary_plane_reset(struct drm_plane *plane)\n{\n\tstruct ssd130x_plane_state *ssd130x_state;\n\n\tWARN_ON(plane->state);\n\n\tssd130x_state = kzalloc(sizeof(*ssd130x_state), GFP_KERNEL);\n\tif (!ssd130x_state)\n\t\treturn;\n\n\t__drm_gem_reset_shadow_plane(plane, &ssd130x_state->base);\n}\n\nstatic struct drm_plane_state *ssd130x_primary_plane_duplicate_state(struct drm_plane *plane)\n{\n\tstruct drm_shadow_plane_state *new_shadow_plane_state;\n\tstruct ssd130x_plane_state *old_ssd130x_state;\n\tstruct ssd130x_plane_state *ssd130x_state;\n\n\tif (WARN_ON(!plane->state))\n\t\treturn NULL;\n\n\told_ssd130x_state = to_ssd130x_plane_state(plane->state);\n\tssd130x_state = kmemdup(old_ssd130x_state, sizeof(*ssd130x_state), GFP_KERNEL);\n\tif (!ssd130x_state)\n\t\treturn NULL;\n\n\t \n\tssd130x_state->buffer = NULL;\n\tssd130x_state->data_array = NULL;\n\n\tnew_shadow_plane_state = &ssd130x_state->base;\n\n\t__drm_gem_duplicate_shadow_plane_state(plane, new_shadow_plane_state);\n\n\treturn &new_shadow_plane_state->base;\n}\n\nstatic void ssd130x_primary_plane_destroy_state(struct drm_plane *plane,\n\t\t\t\t\t\tstruct drm_plane_state *state)\n{\n\tstruct ssd130x_plane_state *ssd130x_state = to_ssd130x_plane_state(state);\n\n\tkfree(ssd130x_state->data_array);\n\tkfree(ssd130x_state->buffer);\n\n\t__drm_gem_destroy_shadow_plane_state(&ssd130x_state->base);\n\n\tkfree(ssd130x_state);\n}\n\nstatic const struct drm_plane_helper_funcs ssd130x_primary_plane_helper_funcs = {\n\tDRM_GEM_SHADOW_PLANE_HELPER_FUNCS,\n\t.atomic_check = ssd130x_primary_plane_helper_atomic_check,\n\t.atomic_update = ssd130x_primary_plane_helper_atomic_update,\n\t.atomic_disable = ssd130x_primary_plane_helper_atomic_disable,\n};\n\nstatic const struct drm_plane_funcs ssd130x_primary_plane_funcs = {\n\t.update_plane = drm_atomic_helper_update_plane,\n\t.disable_plane = drm_atomic_helper_disable_plane,\n\t.reset = ssd130x_primary_plane_reset,\n\t.atomic_duplicate_state = ssd130x_primary_plane_duplicate_state,\n\t.atomic_destroy_state = ssd130x_primary_plane_destroy_state,\n\t.destroy = drm_plane_cleanup,\n};\n\nstatic enum drm_mode_status ssd130x_crtc_helper_mode_valid(struct drm_crtc *crtc,\n\t\t\t\t\t\t\t   const struct drm_display_mode *mode)\n{\n\tstruct ssd130x_device *ssd130x = drm_to_ssd130x(crtc->dev);\n\n\tif (mode->hdisplay != ssd130x->mode.hdisplay &&\n\t    mode->vdisplay != ssd130x->mode.vdisplay)\n\t\treturn MODE_ONE_SIZE;\n\telse if (mode->hdisplay != ssd130x->mode.hdisplay)\n\t\treturn MODE_ONE_WIDTH;\n\telse if (mode->vdisplay != ssd130x->mode.vdisplay)\n\t\treturn MODE_ONE_HEIGHT;\n\n\treturn MODE_OK;\n}\n\n \nstatic const struct drm_crtc_helper_funcs ssd130x_crtc_helper_funcs = {\n\t.mode_valid = ssd130x_crtc_helper_mode_valid,\n\t.atomic_check = drm_crtc_helper_atomic_check,\n};\n\nstatic const struct drm_crtc_funcs ssd130x_crtc_funcs = {\n\t.reset = drm_atomic_helper_crtc_reset,\n\t.destroy = drm_crtc_cleanup,\n\t.set_config = drm_atomic_helper_set_config,\n\t.page_flip = drm_atomic_helper_page_flip,\n\t.atomic_duplicate_state = drm_atomic_helper_crtc_duplicate_state,\n\t.atomic_destroy_state = drm_atomic_helper_crtc_destroy_state,\n};\n\nstatic void ssd130x_encoder_helper_atomic_enable(struct drm_encoder *encoder,\n\t\t\t\t\t\t struct drm_atomic_state *state)\n{\n\tstruct drm_device *drm = encoder->dev;\n\tstruct ssd130x_device *ssd130x = drm_to_ssd130x(drm);\n\tint ret;\n\n\tret = ssd130x_power_on(ssd130x);\n\tif (ret)\n\t\treturn;\n\n\tret = ssd130x_init(ssd130x);\n\tif (ret)\n\t\tgoto power_off;\n\n\tssd130x_write_cmd(ssd130x, 1, SSD130X_DISPLAY_ON);\n\n\tbacklight_enable(ssd130x->bl_dev);\n\n\treturn;\n\npower_off:\n\tssd130x_power_off(ssd130x);\n\treturn;\n}\n\nstatic void ssd130x_encoder_helper_atomic_disable(struct drm_encoder *encoder,\n\t\t\t\t\t\t  struct drm_atomic_state *state)\n{\n\tstruct drm_device *drm = encoder->dev;\n\tstruct ssd130x_device *ssd130x = drm_to_ssd130x(drm);\n\n\tbacklight_disable(ssd130x->bl_dev);\n\n\tssd130x_write_cmd(ssd130x, 1, SSD130X_DISPLAY_OFF);\n\n\tssd130x_power_off(ssd130x);\n}\n\nstatic const struct drm_encoder_helper_funcs ssd130x_encoder_helper_funcs = {\n\t.atomic_enable = ssd130x_encoder_helper_atomic_enable,\n\t.atomic_disable = ssd130x_encoder_helper_atomic_disable,\n};\n\nstatic const struct drm_encoder_funcs ssd130x_encoder_funcs = {\n\t.destroy = drm_encoder_cleanup,\n};\n\nstatic int ssd130x_connector_helper_get_modes(struct drm_connector *connector)\n{\n\tstruct ssd130x_device *ssd130x = drm_to_ssd130x(connector->dev);\n\tstruct drm_display_mode *mode;\n\tstruct device *dev = ssd130x->dev;\n\n\tmode = drm_mode_duplicate(connector->dev, &ssd130x->mode);\n\tif (!mode) {\n\t\tdev_err(dev, \"Failed to duplicated mode\\n\");\n\t\treturn 0;\n\t}\n\n\tdrm_mode_probed_add(connector, mode);\n\tdrm_set_preferred_mode(connector, mode->hdisplay, mode->vdisplay);\n\n\t \n\treturn 1;\n}\n\nstatic const struct drm_connector_helper_funcs ssd130x_connector_helper_funcs = {\n\t.get_modes = ssd130x_connector_helper_get_modes,\n};\n\nstatic const struct drm_connector_funcs ssd130x_connector_funcs = {\n\t.reset = drm_atomic_helper_connector_reset,\n\t.fill_modes = drm_helper_probe_single_connector_modes,\n\t.destroy = drm_connector_cleanup,\n\t.atomic_duplicate_state = drm_atomic_helper_connector_duplicate_state,\n\t.atomic_destroy_state = drm_atomic_helper_connector_destroy_state,\n};\n\nstatic const struct drm_mode_config_funcs ssd130x_mode_config_funcs = {\n\t.fb_create = drm_gem_fb_create_with_dirty,\n\t.atomic_check = drm_atomic_helper_check,\n\t.atomic_commit = drm_atomic_helper_commit,\n};\n\nstatic const uint32_t ssd130x_formats[] = {\n\tDRM_FORMAT_XRGB8888,\n};\n\nDEFINE_DRM_GEM_FOPS(ssd130x_fops);\n\nstatic const struct drm_driver ssd130x_drm_driver = {\n\tDRM_GEM_SHMEM_DRIVER_OPS,\n\t.name\t\t\t= DRIVER_NAME,\n\t.desc\t\t\t= DRIVER_DESC,\n\t.date\t\t\t= DRIVER_DATE,\n\t.major\t\t\t= DRIVER_MAJOR,\n\t.minor\t\t\t= DRIVER_MINOR,\n\t.driver_features\t= DRIVER_ATOMIC | DRIVER_GEM | DRIVER_MODESET,\n\t.fops\t\t\t= &ssd130x_fops,\n};\n\nstatic int ssd130x_update_bl(struct backlight_device *bdev)\n{\n\tstruct ssd130x_device *ssd130x = bl_get_data(bdev);\n\tint brightness = backlight_get_brightness(bdev);\n\tint ret;\n\n\tssd130x->contrast = brightness;\n\n\tret = ssd130x_write_cmd(ssd130x, 1, SSD130X_CONTRAST);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = ssd130x_write_cmd(ssd130x, 1, ssd130x->contrast);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn 0;\n}\n\nstatic const struct backlight_ops ssd130xfb_bl_ops = {\n\t.update_status\t= ssd130x_update_bl,\n};\n\nstatic void ssd130x_parse_properties(struct ssd130x_device *ssd130x)\n{\n\tstruct device *dev = ssd130x->dev;\n\n\tif (device_property_read_u32(dev, \"solomon,width\", &ssd130x->width))\n\t\tssd130x->width = ssd130x->device_info->default_width;\n\n\tif (device_property_read_u32(dev, \"solomon,height\", &ssd130x->height))\n\t\tssd130x->height = ssd130x->device_info->default_height;\n\n\tif (device_property_read_u32(dev, \"solomon,page-offset\", &ssd130x->page_offset))\n\t\tssd130x->page_offset = 1;\n\n\tif (device_property_read_u32(dev, \"solomon,col-offset\", &ssd130x->col_offset))\n\t\tssd130x->col_offset = 0;\n\n\tif (device_property_read_u32(dev, \"solomon,com-offset\", &ssd130x->com_offset))\n\t\tssd130x->com_offset = 0;\n\n\tif (device_property_read_u32(dev, \"solomon,prechargep1\", &ssd130x->prechargep1))\n\t\tssd130x->prechargep1 = 2;\n\n\tif (device_property_read_u32(dev, \"solomon,prechargep2\", &ssd130x->prechargep2))\n\t\tssd130x->prechargep2 = 2;\n\n\tif (!device_property_read_u8_array(dev, \"solomon,lookup-table\",\n\t\t\t\t\t   ssd130x->lookup_table,\n\t\t\t\t\t   ARRAY_SIZE(ssd130x->lookup_table)))\n\t\tssd130x->lookup_table_set = 1;\n\n\tssd130x->seg_remap = !device_property_read_bool(dev, \"solomon,segment-no-remap\");\n\tssd130x->com_seq = device_property_read_bool(dev, \"solomon,com-seq\");\n\tssd130x->com_lrremap = device_property_read_bool(dev, \"solomon,com-lrremap\");\n\tssd130x->com_invdir = device_property_read_bool(dev, \"solomon,com-invdir\");\n\tssd130x->area_color_enable =\n\t\tdevice_property_read_bool(dev, \"solomon,area-color-enable\");\n\tssd130x->low_power = device_property_read_bool(dev, \"solomon,low-power\");\n\n\tssd130x->contrast = 127;\n\tssd130x->vcomh = ssd130x->device_info->default_vcomh;\n\n\t \n\tif (device_property_read_u32(dev, \"solomon,dclk-div\", &ssd130x->dclk_div))\n\t\tssd130x->dclk_div = ssd130x->device_info->default_dclk_div;\n\tif (device_property_read_u32(dev, \"solomon,dclk-frq\", &ssd130x->dclk_frq))\n\t\tssd130x->dclk_frq = ssd130x->device_info->default_dclk_frq;\n}\n\nstatic int ssd130x_init_modeset(struct ssd130x_device *ssd130x)\n{\n\tstruct drm_display_mode *mode = &ssd130x->mode;\n\tstruct device *dev = ssd130x->dev;\n\tstruct drm_device *drm = &ssd130x->drm;\n\tunsigned long max_width, max_height;\n\tstruct drm_plane *primary_plane;\n\tstruct drm_crtc *crtc;\n\tstruct drm_encoder *encoder;\n\tstruct drm_connector *connector;\n\tint ret;\n\n\t \n\n\tret = drmm_mode_config_init(drm);\n\tif (ret) {\n\t\tdev_err(dev, \"DRM mode config init failed: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tmode->type = DRM_MODE_TYPE_DRIVER;\n\tmode->clock = 1;\n\tmode->hdisplay = mode->htotal = ssd130x->width;\n\tmode->hsync_start = mode->hsync_end = ssd130x->width;\n\tmode->vdisplay = mode->vtotal = ssd130x->height;\n\tmode->vsync_start = mode->vsync_end = ssd130x->height;\n\tmode->width_mm = 27;\n\tmode->height_mm = 27;\n\n\tmax_width = max_t(unsigned long, mode->hdisplay, DRM_SHADOW_PLANE_MAX_WIDTH);\n\tmax_height = max_t(unsigned long, mode->vdisplay, DRM_SHADOW_PLANE_MAX_HEIGHT);\n\n\tdrm->mode_config.min_width = mode->hdisplay;\n\tdrm->mode_config.max_width = max_width;\n\tdrm->mode_config.min_height = mode->vdisplay;\n\tdrm->mode_config.max_height = max_height;\n\tdrm->mode_config.preferred_depth = 24;\n\tdrm->mode_config.funcs = &ssd130x_mode_config_funcs;\n\n\t \n\n\tprimary_plane = &ssd130x->primary_plane;\n\tret = drm_universal_plane_init(drm, primary_plane, 0, &ssd130x_primary_plane_funcs,\n\t\t\t\t       ssd130x_formats, ARRAY_SIZE(ssd130x_formats),\n\t\t\t\t       NULL, DRM_PLANE_TYPE_PRIMARY, NULL);\n\tif (ret) {\n\t\tdev_err(dev, \"DRM primary plane init failed: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tdrm_plane_helper_add(primary_plane, &ssd130x_primary_plane_helper_funcs);\n\n\tdrm_plane_enable_fb_damage_clips(primary_plane);\n\n\t \n\n\tcrtc = &ssd130x->crtc;\n\tret = drm_crtc_init_with_planes(drm, crtc, primary_plane, NULL,\n\t\t\t\t\t&ssd130x_crtc_funcs, NULL);\n\tif (ret) {\n\t\tdev_err(dev, \"DRM crtc init failed: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tdrm_crtc_helper_add(crtc, &ssd130x_crtc_helper_funcs);\n\n\t \n\n\tencoder = &ssd130x->encoder;\n\tret = drm_encoder_init(drm, encoder, &ssd130x_encoder_funcs,\n\t\t\t       DRM_MODE_ENCODER_NONE, NULL);\n\tif (ret) {\n\t\tdev_err(dev, \"DRM encoder init failed: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tdrm_encoder_helper_add(encoder, &ssd130x_encoder_helper_funcs);\n\n\tencoder->possible_crtcs = drm_crtc_mask(crtc);\n\n\t \n\n\tconnector = &ssd130x->connector;\n\tret = drm_connector_init(drm, connector, &ssd130x_connector_funcs,\n\t\t\t\t DRM_MODE_CONNECTOR_Unknown);\n\tif (ret) {\n\t\tdev_err(dev, \"DRM connector init failed: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tdrm_connector_helper_add(connector, &ssd130x_connector_helper_funcs);\n\n\tret = drm_connector_attach_encoder(connector, encoder);\n\tif (ret) {\n\t\tdev_err(dev, \"DRM attach connector to encoder failed: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tdrm_mode_config_reset(drm);\n\n\treturn 0;\n}\n\nstatic int ssd130x_get_resources(struct ssd130x_device *ssd130x)\n{\n\tstruct device *dev = ssd130x->dev;\n\n\tssd130x->reset = devm_gpiod_get_optional(dev, \"reset\", GPIOD_OUT_LOW);\n\tif (IS_ERR(ssd130x->reset))\n\t\treturn dev_err_probe(dev, PTR_ERR(ssd130x->reset),\n\t\t\t\t     \"Failed to get reset gpio\\n\");\n\n\tssd130x->vcc_reg = devm_regulator_get(dev, \"vcc\");\n\tif (IS_ERR(ssd130x->vcc_reg))\n\t\treturn dev_err_probe(dev, PTR_ERR(ssd130x->vcc_reg),\n\t\t\t\t     \"Failed to get VCC regulator\\n\");\n\n\treturn 0;\n}\n\nstruct ssd130x_device *ssd130x_probe(struct device *dev, struct regmap *regmap)\n{\n\tstruct ssd130x_device *ssd130x;\n\tstruct backlight_device *bl;\n\tstruct drm_device *drm;\n\tint ret;\n\n\tssd130x = devm_drm_dev_alloc(dev, &ssd130x_drm_driver,\n\t\t\t\t     struct ssd130x_device, drm);\n\tif (IS_ERR(ssd130x))\n\t\treturn ERR_PTR(dev_err_probe(dev, PTR_ERR(ssd130x),\n\t\t\t\t\t     \"Failed to allocate DRM device\\n\"));\n\n\tdrm = &ssd130x->drm;\n\n\tssd130x->dev = dev;\n\tssd130x->regmap = regmap;\n\tssd130x->device_info = device_get_match_data(dev);\n\n\tif (ssd130x->device_info->page_mode_only)\n\t\tssd130x->page_address_mode = 1;\n\n\tssd130x_parse_properties(ssd130x);\n\n\tret = ssd130x_get_resources(ssd130x);\n\tif (ret)\n\t\treturn ERR_PTR(ret);\n\n\tbl = devm_backlight_device_register(dev, dev_name(dev), dev, ssd130x,\n\t\t\t\t\t    &ssd130xfb_bl_ops, NULL);\n\tif (IS_ERR(bl))\n\t\treturn ERR_PTR(dev_err_probe(dev, PTR_ERR(bl),\n\t\t\t\t\t     \"Unable to register backlight device\\n\"));\n\n\tbl->props.brightness = ssd130x->contrast;\n\tbl->props.max_brightness = MAX_CONTRAST;\n\tssd130x->bl_dev = bl;\n\n\tret = ssd130x_init_modeset(ssd130x);\n\tif (ret)\n\t\treturn ERR_PTR(ret);\n\n\tret = drm_dev_register(drm, 0);\n\tif (ret)\n\t\treturn ERR_PTR(dev_err_probe(dev, ret, \"DRM device register failed\\n\"));\n\n\tdrm_fbdev_generic_setup(drm, 32);\n\n\treturn ssd130x;\n}\nEXPORT_SYMBOL_GPL(ssd130x_probe);\n\nvoid ssd130x_remove(struct ssd130x_device *ssd130x)\n{\n\tdrm_dev_unplug(&ssd130x->drm);\n}\nEXPORT_SYMBOL_GPL(ssd130x_remove);\n\nvoid ssd130x_shutdown(struct ssd130x_device *ssd130x)\n{\n\tdrm_atomic_helper_shutdown(&ssd130x->drm);\n}\nEXPORT_SYMBOL_GPL(ssd130x_shutdown);\n\nMODULE_DESCRIPTION(DRIVER_DESC);\nMODULE_AUTHOR(\"Javier Martinez Canillas <javierm@redhat.com>\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}