{
  "module_name": "ssd130x-spi.c",
  "hash_id": "4407814f2e1920d0de94ae8314b6d23e995488e4ede93fc8da88fcd85b89a432",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/solomon/ssd130x-spi.c",
  "human_readable_source": "\n \n#include <linux/spi/spi.h>\n#include <linux/module.h>\n\n#include \"ssd130x.h\"\n\n#define DRIVER_NAME\t\"ssd130x-spi\"\n#define DRIVER_DESC\t\"DRM driver for Solomon SSD130X OLED displays (SPI)\"\n\nstruct ssd130x_spi_transport {\n\tstruct spi_device *spi;\n\tstruct gpio_desc *dc;\n};\n\n \nstatic int ssd130x_spi_write(void *context, const void *data, size_t count)\n{\n\tstruct ssd130x_spi_transport *t = context;\n\tstruct spi_device *spi = t->spi;\n\tconst u8 *reg = data;\n\n\tif (*reg == SSD130X_COMMAND)\n\t\tgpiod_set_value_cansleep(t->dc, 0);\n\n\tif (*reg == SSD130X_DATA)\n\t\tgpiod_set_value_cansleep(t->dc, 1);\n\n\t \n\treturn spi_write(spi, reg + 1, count - 1);\n}\n\n \nstatic int ssd130x_spi_read(void *context, const void *reg, size_t reg_size,\n\t\t\t    void *val, size_t val_size)\n{\n\treturn -EOPNOTSUPP;\n}\n\nstatic const struct regmap_config ssd130x_spi_regmap_config = {\n\t.reg_bits = 8,\n\t.val_bits = 8,\n\t.write = ssd130x_spi_write,\n\t.read = ssd130x_spi_read,\n\t.can_multi_write = true,\n};\n\nstatic int ssd130x_spi_probe(struct spi_device *spi)\n{\n\tstruct ssd130x_spi_transport *t;\n\tstruct ssd130x_device *ssd130x;\n\tstruct regmap *regmap;\n\tstruct gpio_desc *dc;\n\tstruct device *dev = &spi->dev;\n\n\tdc = devm_gpiod_get(dev, \"dc\", GPIOD_OUT_LOW);\n\tif (IS_ERR(dc))\n\t\treturn dev_err_probe(dev, PTR_ERR(dc),\n\t\t\t\t     \"Failed to get dc gpio\\n\");\n\n\tt = devm_kzalloc(dev, sizeof(*t), GFP_KERNEL);\n\tif (!t)\n\t\treturn dev_err_probe(dev, -ENOMEM,\n\t\t\t\t     \"Failed to allocate SPI transport data\\n\");\n\n\tt->spi = spi;\n\tt->dc = dc;\n\n\tregmap = devm_regmap_init(dev, NULL, t, &ssd130x_spi_regmap_config);\n\tif (IS_ERR(regmap))\n\t\treturn PTR_ERR(regmap);\n\n\tssd130x = ssd130x_probe(dev, regmap);\n\tif (IS_ERR(ssd130x))\n\t\treturn PTR_ERR(ssd130x);\n\n\tspi_set_drvdata(spi, ssd130x);\n\n\treturn 0;\n}\n\nstatic void ssd130x_spi_remove(struct spi_device *spi)\n{\n\tstruct ssd130x_device *ssd130x = spi_get_drvdata(spi);\n\n\tssd130x_remove(ssd130x);\n}\n\nstatic void ssd130x_spi_shutdown(struct spi_device *spi)\n{\n\tstruct ssd130x_device *ssd130x = spi_get_drvdata(spi);\n\n\tssd130x_shutdown(ssd130x);\n}\n\nstatic const struct of_device_id ssd130x_of_match[] = {\n\t{\n\t\t.compatible = \"sinowealth,sh1106\",\n\t\t.data = &ssd130x_variants[SH1106_ID],\n\t},\n\t{\n\t\t.compatible = \"solomon,ssd1305\",\n\t\t.data = &ssd130x_variants[SSD1305_ID],\n\t},\n\t{\n\t\t.compatible = \"solomon,ssd1306\",\n\t\t.data = &ssd130x_variants[SSD1306_ID],\n\t},\n\t{\n\t\t.compatible = \"solomon,ssd1307\",\n\t\t.data = &ssd130x_variants[SSD1307_ID],\n\t},\n\t{\n\t\t.compatible = \"solomon,ssd1309\",\n\t\t.data = &ssd130x_variants[SSD1309_ID],\n\t},\n\t{   }\n};\nMODULE_DEVICE_TABLE(of, ssd130x_of_match);\n\n#if IS_MODULE(CONFIG_DRM_SSD130X_SPI)\n \nstatic const struct spi_device_id ssd130x_spi_table[] = {\n\t{ \"sh1106\",  SH1106_ID },\n\t{ \"ssd1305\", SSD1305_ID },\n\t{ \"ssd1306\", SSD1306_ID },\n\t{ \"ssd1307\", SSD1307_ID },\n\t{ \"ssd1309\", SSD1309_ID },\n\t{   }\n};\nMODULE_DEVICE_TABLE(spi, ssd130x_spi_table);\n#endif\n\nstatic struct spi_driver ssd130x_spi_driver = {\n\t.driver = {\n\t\t.name = DRIVER_NAME,\n\t\t.of_match_table = ssd130x_of_match,\n\t},\n\t.probe = ssd130x_spi_probe,\n\t.remove = ssd130x_spi_remove,\n\t.shutdown = ssd130x_spi_shutdown,\n};\nmodule_spi_driver(ssd130x_spi_driver);\n\nMODULE_DESCRIPTION(DRIVER_DESC);\nMODULE_AUTHOR(\"Javier Martinez Canillas <javierm@redhat.com>\");\nMODULE_LICENSE(\"GPL\");\nMODULE_IMPORT_NS(DRM_SSD130X);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}