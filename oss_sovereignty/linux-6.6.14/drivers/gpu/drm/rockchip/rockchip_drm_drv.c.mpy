{
  "module_name": "rockchip_drm_drv.c",
  "hash_id": "d8b29c9d849d72068243edc2c6ebe31fb8bfe5602daaafab43e7823b2b86b60d",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/rockchip/rockchip_drm_drv.c",
  "human_readable_source": "\n \n\n#include <linux/dma-mapping.h>\n#include <linux/platform_device.h>\n#include <linux/pm_runtime.h>\n#include <linux/module.h>\n#include <linux/of_graph.h>\n#include <linux/of_platform.h>\n#include <linux/component.h>\n#include <linux/console.h>\n#include <linux/iommu.h>\n\n#include <drm/drm_aperture.h>\n#include <drm/drm_drv.h>\n#include <drm/drm_fbdev_generic.h>\n#include <drm/drm_gem_dma_helper.h>\n#include <drm/drm_of.h>\n#include <drm/drm_probe_helper.h>\n#include <drm/drm_vblank.h>\n\n#if defined(CONFIG_ARM_DMA_USE_IOMMU)\n#include <asm/dma-iommu.h>\n#else\n#define arm_iommu_detach_device(...)\t({ })\n#define arm_iommu_release_mapping(...)\t({ })\n#define to_dma_iommu_mapping(dev) NULL\n#endif\n\n#include \"rockchip_drm_drv.h\"\n#include \"rockchip_drm_fb.h\"\n#include \"rockchip_drm_gem.h\"\n\n#define DRIVER_NAME\t\"rockchip\"\n#define DRIVER_DESC\t\"RockChip Soc DRM\"\n#define DRIVER_DATE\t\"20140818\"\n#define DRIVER_MAJOR\t1\n#define DRIVER_MINOR\t0\n\nstatic const struct drm_driver rockchip_drm_driver;\n\n \nint rockchip_drm_dma_attach_device(struct drm_device *drm_dev,\n\t\t\t\t   struct device *dev)\n{\n\tstruct rockchip_drm_private *private = drm_dev->dev_private;\n\tint ret;\n\n\tif (!private->domain)\n\t\treturn 0;\n\n\tif (IS_ENABLED(CONFIG_ARM_DMA_USE_IOMMU)) {\n\t\tstruct dma_iommu_mapping *mapping = to_dma_iommu_mapping(dev);\n\n\t\tif (mapping) {\n\t\t\tarm_iommu_detach_device(dev);\n\t\t\tarm_iommu_release_mapping(mapping);\n\t\t}\n\t}\n\n\tret = iommu_attach_device(private->domain, dev);\n\tif (ret) {\n\t\tDRM_DEV_ERROR(dev, \"Failed to attach iommu device\\n\");\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nvoid rockchip_drm_dma_detach_device(struct drm_device *drm_dev,\n\t\t\t\t    struct device *dev)\n{\n\tstruct rockchip_drm_private *private = drm_dev->dev_private;\n\n\tif (!private->domain)\n\t\treturn;\n\n\tiommu_detach_device(private->domain, dev);\n}\n\nvoid rockchip_drm_dma_init_device(struct drm_device *drm_dev,\n\t\t\t\t  struct device *dev)\n{\n\tstruct rockchip_drm_private *private = drm_dev->dev_private;\n\n\tif (!device_iommu_mapped(dev))\n\t\tprivate->iommu_dev = ERR_PTR(-ENODEV);\n\telse if (!private->iommu_dev)\n\t\tprivate->iommu_dev = dev;\n}\n\nstatic int rockchip_drm_init_iommu(struct drm_device *drm_dev)\n{\n\tstruct rockchip_drm_private *private = drm_dev->dev_private;\n\tstruct iommu_domain_geometry *geometry;\n\tu64 start, end;\n\n\tif (IS_ERR_OR_NULL(private->iommu_dev))\n\t\treturn 0;\n\n\tprivate->domain = iommu_domain_alloc(private->iommu_dev->bus);\n\tif (!private->domain)\n\t\treturn -ENOMEM;\n\n\tgeometry = &private->domain->geometry;\n\tstart = geometry->aperture_start;\n\tend = geometry->aperture_end;\n\n\tDRM_DEBUG(\"IOMMU context initialized (aperture: %#llx-%#llx)\\n\",\n\t\t  start, end);\n\tdrm_mm_init(&private->mm, start, end - start + 1);\n\tmutex_init(&private->mm_lock);\n\n\treturn 0;\n}\n\nstatic void rockchip_iommu_cleanup(struct drm_device *drm_dev)\n{\n\tstruct rockchip_drm_private *private = drm_dev->dev_private;\n\n\tif (!private->domain)\n\t\treturn;\n\n\tdrm_mm_takedown(&private->mm);\n\tiommu_domain_free(private->domain);\n}\n\nstatic int rockchip_drm_bind(struct device *dev)\n{\n\tstruct drm_device *drm_dev;\n\tstruct rockchip_drm_private *private;\n\tint ret;\n\n\t \n\tret = drm_aperture_remove_framebuffers(&rockchip_drm_driver);\n\tif (ret) {\n\t\tDRM_DEV_ERROR(dev,\n\t\t\t      \"Failed to remove existing framebuffers - %d.\\n\",\n\t\t\t      ret);\n\t\treturn ret;\n\t}\n\n\tdrm_dev = drm_dev_alloc(&rockchip_drm_driver, dev);\n\tif (IS_ERR(drm_dev))\n\t\treturn PTR_ERR(drm_dev);\n\n\tdev_set_drvdata(dev, drm_dev);\n\n\tprivate = devm_kzalloc(drm_dev->dev, sizeof(*private), GFP_KERNEL);\n\tif (!private) {\n\t\tret = -ENOMEM;\n\t\tgoto err_free;\n\t}\n\n\tdrm_dev->dev_private = private;\n\n\tret = drmm_mode_config_init(drm_dev);\n\tif (ret)\n\t\tgoto err_free;\n\n\trockchip_drm_mode_config_init(drm_dev);\n\n\t \n\tret = component_bind_all(dev, drm_dev);\n\tif (ret)\n\t\tgoto err_free;\n\n\tret = rockchip_drm_init_iommu(drm_dev);\n\tif (ret)\n\t\tgoto err_unbind_all;\n\n\tret = drm_vblank_init(drm_dev, drm_dev->mode_config.num_crtc);\n\tif (ret)\n\t\tgoto err_iommu_cleanup;\n\n\tdrm_mode_config_reset(drm_dev);\n\n\t \n\tdrm_kms_helper_poll_init(drm_dev);\n\n\tret = drm_dev_register(drm_dev, 0);\n\tif (ret)\n\t\tgoto err_kms_helper_poll_fini;\n\n\tdrm_fbdev_generic_setup(drm_dev, 0);\n\n\treturn 0;\nerr_kms_helper_poll_fini:\n\tdrm_kms_helper_poll_fini(drm_dev);\nerr_iommu_cleanup:\n\trockchip_iommu_cleanup(drm_dev);\nerr_unbind_all:\n\tcomponent_unbind_all(dev, drm_dev);\nerr_free:\n\tdrm_dev_put(drm_dev);\n\treturn ret;\n}\n\nstatic void rockchip_drm_unbind(struct device *dev)\n{\n\tstruct drm_device *drm_dev = dev_get_drvdata(dev);\n\n\tdrm_dev_unregister(drm_dev);\n\n\tdrm_kms_helper_poll_fini(drm_dev);\n\n\tdrm_atomic_helper_shutdown(drm_dev);\n\tcomponent_unbind_all(dev, drm_dev);\n\trockchip_iommu_cleanup(drm_dev);\n\n\tdrm_dev_put(drm_dev);\n}\n\nDEFINE_DRM_GEM_FOPS(rockchip_drm_driver_fops);\n\nstatic const struct drm_driver rockchip_drm_driver = {\n\t.driver_features\t= DRIVER_MODESET | DRIVER_GEM | DRIVER_ATOMIC,\n\t.dumb_create\t\t= rockchip_gem_dumb_create,\n\t.gem_prime_import_sg_table\t= rockchip_gem_prime_import_sg_table,\n\t.fops\t\t\t= &rockchip_drm_driver_fops,\n\t.name\t= DRIVER_NAME,\n\t.desc\t= DRIVER_DESC,\n\t.date\t= DRIVER_DATE,\n\t.major\t= DRIVER_MAJOR,\n\t.minor\t= DRIVER_MINOR,\n};\n\n#ifdef CONFIG_PM_SLEEP\nstatic int rockchip_drm_sys_suspend(struct device *dev)\n{\n\tstruct drm_device *drm = dev_get_drvdata(dev);\n\n\treturn drm_mode_config_helper_suspend(drm);\n}\n\nstatic int rockchip_drm_sys_resume(struct device *dev)\n{\n\tstruct drm_device *drm = dev_get_drvdata(dev);\n\n\treturn drm_mode_config_helper_resume(drm);\n}\n#endif\n\nstatic const struct dev_pm_ops rockchip_drm_pm_ops = {\n\tSET_SYSTEM_SLEEP_PM_OPS(rockchip_drm_sys_suspend,\n\t\t\t\trockchip_drm_sys_resume)\n};\n\n#define MAX_ROCKCHIP_SUB_DRIVERS 16\nstatic struct platform_driver *rockchip_sub_drivers[MAX_ROCKCHIP_SUB_DRIVERS];\nstatic int num_rockchip_sub_drivers;\n\n \nint rockchip_drm_encoder_set_crtc_endpoint_id(struct rockchip_encoder *rkencoder,\n\t\t\t\t\t      struct device_node *np, int port, int reg)\n{\n\tstruct of_endpoint ep;\n\tstruct device_node *en, *ren;\n\tint ret;\n\n\ten = of_graph_get_endpoint_by_regs(np, port, reg);\n\tif (!en)\n\t\treturn -ENOENT;\n\n\tren = of_graph_get_remote_endpoint(en);\n\tif (!ren)\n\t\treturn -ENOENT;\n\n\tret = of_graph_parse_endpoint(ren, &ep);\n\tif (ret)\n\t\treturn ret;\n\n\trkencoder->crtc_endpoint_id = ep.id;\n\n\treturn 0;\n}\n\n \nint rockchip_drm_endpoint_is_subdriver(struct device_node *ep)\n{\n\tstruct device_node *node = of_graph_get_remote_port_parent(ep);\n\tstruct platform_device *pdev;\n\tstruct device_driver *drv;\n\tint i;\n\n\tif (!node)\n\t\treturn -ENODEV;\n\n\t \n\tif (!of_device_is_available(node)) {\n\t\tof_node_put(node);\n\t\treturn -ENODEV;\n\t}\n\n\tpdev = of_find_device_by_node(node);\n\tof_node_put(node);\n\n\t \n\tif (!pdev)\n\t\treturn false;\n\n\t \n\tdrv = pdev->dev.driver;\n\tif (!drv) {\n\t\tplatform_device_put(pdev);\n\t\treturn false;\n\t}\n\n\tfor (i = 0; i < num_rockchip_sub_drivers; i++) {\n\t\tif (rockchip_sub_drivers[i] == to_platform_driver(drv)) {\n\t\t\tplatform_device_put(pdev);\n\t\t\treturn true;\n\t\t}\n\t}\n\n\tplatform_device_put(pdev);\n\treturn false;\n}\n\nstatic void rockchip_drm_match_remove(struct device *dev)\n{\n\tstruct device_link *link;\n\n\tlist_for_each_entry(link, &dev->links.consumers, s_node)\n\t\tdevice_link_del(link);\n}\n\nstatic struct component_match *rockchip_drm_match_add(struct device *dev)\n{\n\tstruct component_match *match = NULL;\n\tint i;\n\n\tfor (i = 0; i < num_rockchip_sub_drivers; i++) {\n\t\tstruct platform_driver *drv = rockchip_sub_drivers[i];\n\t\tstruct device *p = NULL, *d;\n\n\t\tdo {\n\t\t\td = platform_find_device_by_driver(p, &drv->driver);\n\t\t\tput_device(p);\n\t\t\tp = d;\n\n\t\t\tif (!d)\n\t\t\t\tbreak;\n\n\t\t\tdevice_link_add(dev, d, DL_FLAG_STATELESS);\n\t\t\tcomponent_match_add(dev, &match, component_compare_dev, d);\n\t\t} while (true);\n\t}\n\n\tif (IS_ERR(match))\n\t\trockchip_drm_match_remove(dev);\n\n\treturn match ?: ERR_PTR(-ENODEV);\n}\n\nstatic const struct component_master_ops rockchip_drm_ops = {\n\t.bind = rockchip_drm_bind,\n\t.unbind = rockchip_drm_unbind,\n};\n\nstatic int rockchip_drm_platform_of_probe(struct device *dev)\n{\n\tstruct device_node *np = dev->of_node;\n\tstruct device_node *port;\n\tbool found = false;\n\tint i;\n\n\tif (!np)\n\t\treturn -ENODEV;\n\n\tfor (i = 0;; i++) {\n\t\tport = of_parse_phandle(np, \"ports\", i);\n\t\tif (!port)\n\t\t\tbreak;\n\n\t\tif (!of_device_is_available(port->parent)) {\n\t\t\tof_node_put(port);\n\t\t\tcontinue;\n\t\t}\n\n\t\tfound = true;\n\t\tof_node_put(port);\n\t}\n\n\tif (i == 0) {\n\t\tDRM_DEV_ERROR(dev, \"missing 'ports' property\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tif (!found) {\n\t\tDRM_DEV_ERROR(dev,\n\t\t\t      \"No available vop found for display-subsystem.\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\treturn 0;\n}\n\nstatic int rockchip_drm_platform_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct component_match *match = NULL;\n\tint ret;\n\n\tret = rockchip_drm_platform_of_probe(dev);\n\tif (ret)\n\t\treturn ret;\n\n\tmatch = rockchip_drm_match_add(dev);\n\tif (IS_ERR(match))\n\t\treturn PTR_ERR(match);\n\n\tret = component_master_add_with_match(dev, &rockchip_drm_ops, match);\n\tif (ret < 0) {\n\t\trockchip_drm_match_remove(dev);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic void rockchip_drm_platform_remove(struct platform_device *pdev)\n{\n\tcomponent_master_del(&pdev->dev, &rockchip_drm_ops);\n\n\trockchip_drm_match_remove(&pdev->dev);\n}\n\nstatic void rockchip_drm_platform_shutdown(struct platform_device *pdev)\n{\n\tstruct drm_device *drm = platform_get_drvdata(pdev);\n\n\tif (drm)\n\t\tdrm_atomic_helper_shutdown(drm);\n}\n\nstatic const struct of_device_id rockchip_drm_dt_ids[] = {\n\t{ .compatible = \"rockchip,display-subsystem\", },\n\t{   },\n};\nMODULE_DEVICE_TABLE(of, rockchip_drm_dt_ids);\n\nstatic struct platform_driver rockchip_drm_platform_driver = {\n\t.probe = rockchip_drm_platform_probe,\n\t.remove_new = rockchip_drm_platform_remove,\n\t.shutdown = rockchip_drm_platform_shutdown,\n\t.driver = {\n\t\t.name = \"rockchip-drm\",\n\t\t.of_match_table = rockchip_drm_dt_ids,\n\t\t.pm = &rockchip_drm_pm_ops,\n\t},\n};\n\n#define ADD_ROCKCHIP_SUB_DRIVER(drv, cond) { \\\n\tif (IS_ENABLED(cond) && \\\n\t    !WARN_ON(num_rockchip_sub_drivers >= MAX_ROCKCHIP_SUB_DRIVERS)) \\\n\t\trockchip_sub_drivers[num_rockchip_sub_drivers++] = &drv; \\\n}\n\nstatic int __init rockchip_drm_init(void)\n{\n\tint ret;\n\n\tif (drm_firmware_drivers_only())\n\t\treturn -ENODEV;\n\n\tnum_rockchip_sub_drivers = 0;\n\tADD_ROCKCHIP_SUB_DRIVER(vop_platform_driver, CONFIG_ROCKCHIP_VOP);\n\tADD_ROCKCHIP_SUB_DRIVER(vop2_platform_driver, CONFIG_ROCKCHIP_VOP2);\n\tADD_ROCKCHIP_SUB_DRIVER(rockchip_lvds_driver,\n\t\t\t\tCONFIG_ROCKCHIP_LVDS);\n\tADD_ROCKCHIP_SUB_DRIVER(rockchip_dp_driver,\n\t\t\t\tCONFIG_ROCKCHIP_ANALOGIX_DP);\n\tADD_ROCKCHIP_SUB_DRIVER(cdn_dp_driver, CONFIG_ROCKCHIP_CDN_DP);\n\tADD_ROCKCHIP_SUB_DRIVER(dw_hdmi_rockchip_pltfm_driver,\n\t\t\t\tCONFIG_ROCKCHIP_DW_HDMI);\n\tADD_ROCKCHIP_SUB_DRIVER(dw_mipi_dsi_rockchip_driver,\n\t\t\t\tCONFIG_ROCKCHIP_DW_MIPI_DSI);\n\tADD_ROCKCHIP_SUB_DRIVER(inno_hdmi_driver, CONFIG_ROCKCHIP_INNO_HDMI);\n\tADD_ROCKCHIP_SUB_DRIVER(rk3066_hdmi_driver,\n\t\t\t\tCONFIG_ROCKCHIP_RK3066_HDMI);\n\n\tret = platform_register_drivers(rockchip_sub_drivers,\n\t\t\t\t\tnum_rockchip_sub_drivers);\n\tif (ret)\n\t\treturn ret;\n\n\tret = platform_driver_register(&rockchip_drm_platform_driver);\n\tif (ret)\n\t\tgoto err_unreg_drivers;\n\n\treturn 0;\n\nerr_unreg_drivers:\n\tplatform_unregister_drivers(rockchip_sub_drivers,\n\t\t\t\t    num_rockchip_sub_drivers);\n\treturn ret;\n}\n\nstatic void __exit rockchip_drm_fini(void)\n{\n\tplatform_driver_unregister(&rockchip_drm_platform_driver);\n\n\tplatform_unregister_drivers(rockchip_sub_drivers,\n\t\t\t\t    num_rockchip_sub_drivers);\n}\n\nmodule_init(rockchip_drm_init);\nmodule_exit(rockchip_drm_fini);\n\nMODULE_AUTHOR(\"Mark Yao <mark.yao@rock-chips.com>\");\nMODULE_DESCRIPTION(\"ROCKCHIP DRM Driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}