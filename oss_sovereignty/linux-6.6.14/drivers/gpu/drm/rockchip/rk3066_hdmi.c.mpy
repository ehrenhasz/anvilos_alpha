{
  "module_name": "rk3066_hdmi.c",
  "hash_id": "813eaa7ac653581f7716083655687b214a41695ed0b2b39f058c8bf929b4cb9e",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/rockchip/rk3066_hdmi.c",
  "human_readable_source": "\n \n\n#include <drm/drm_edid.h>\n#include <drm/drm_of.h>\n#include <drm/drm_probe_helper.h>\n#include <drm/drm_simple_kms_helper.h>\n\n#include <linux/clk.h>\n#include <linux/mfd/syscon.h>\n#include <linux/platform_device.h>\n#include <linux/regmap.h>\n\n#include \"rk3066_hdmi.h\"\n\n#include \"rockchip_drm_drv.h\"\n#include \"rockchip_drm_vop.h\"\n\n#define DEFAULT_PLLA_RATE 30000000\n\nstruct hdmi_data_info {\n\tint vic;  \n\tunsigned int enc_out_format;\n\tunsigned int colorimetry;\n};\n\nstruct rk3066_hdmi_i2c {\n\tstruct i2c_adapter adap;\n\n\tu8 ddc_addr;\n\tu8 segment_addr;\n\tu8 stat;\n\n\tstruct mutex i2c_lock;  \n\tstruct completion cmpltn;\n};\n\nstruct rk3066_hdmi {\n\tstruct device *dev;\n\tstruct drm_device *drm_dev;\n\tstruct regmap *grf_regmap;\n\tint irq;\n\tstruct clk *hclk;\n\tvoid __iomem *regs;\n\n\tstruct drm_connector connector;\n\tstruct rockchip_encoder encoder;\n\n\tstruct rk3066_hdmi_i2c *i2c;\n\tstruct i2c_adapter *ddc;\n\n\tunsigned int tmdsclk;\n\n\tstruct hdmi_data_info hdmi_data;\n\tstruct drm_display_mode previous_mode;\n};\n\nstatic struct rk3066_hdmi *encoder_to_rk3066_hdmi(struct drm_encoder *encoder)\n{\n\tstruct rockchip_encoder *rkencoder = to_rockchip_encoder(encoder);\n\n\treturn container_of(rkencoder, struct rk3066_hdmi, encoder);\n}\n\nstatic struct rk3066_hdmi *connector_to_rk3066_hdmi(struct drm_connector *connector)\n{\n\treturn container_of(connector, struct rk3066_hdmi, connector);\n}\n\nstatic inline u8 hdmi_readb(struct rk3066_hdmi *hdmi, u16 offset)\n{\n\treturn readl_relaxed(hdmi->regs + offset);\n}\n\nstatic inline void hdmi_writeb(struct rk3066_hdmi *hdmi, u16 offset, u32 val)\n{\n\twritel_relaxed(val, hdmi->regs + offset);\n}\n\nstatic inline void hdmi_modb(struct rk3066_hdmi *hdmi, u16 offset,\n\t\t\t     u32 msk, u32 val)\n{\n\tu8 temp = hdmi_readb(hdmi, offset) & ~msk;\n\n\ttemp |= val & msk;\n\thdmi_writeb(hdmi, offset, temp);\n}\n\nstatic void rk3066_hdmi_i2c_init(struct rk3066_hdmi *hdmi)\n{\n\tint ddc_bus_freq;\n\n\tddc_bus_freq = (hdmi->tmdsclk >> 2) / HDMI_SCL_RATE;\n\n\thdmi_writeb(hdmi, HDMI_DDC_BUS_FREQ_L, ddc_bus_freq & 0xFF);\n\thdmi_writeb(hdmi, HDMI_DDC_BUS_FREQ_H, (ddc_bus_freq >> 8) & 0xFF);\n\n\t \n\thdmi_modb(hdmi, HDMI_INTR_MASK1, HDMI_INTR_EDID_MASK, 0);\n\thdmi_writeb(hdmi, HDMI_INTR_STATUS1, HDMI_INTR_EDID_MASK);\n}\n\nstatic inline u8 rk3066_hdmi_get_power_mode(struct rk3066_hdmi *hdmi)\n{\n\treturn hdmi_readb(hdmi, HDMI_SYS_CTRL) & HDMI_SYS_POWER_MODE_MASK;\n}\n\nstatic void rk3066_hdmi_set_power_mode(struct rk3066_hdmi *hdmi, int mode)\n{\n\tu8 current_mode, next_mode;\n\tu8 i = 0;\n\n\tcurrent_mode = rk3066_hdmi_get_power_mode(hdmi);\n\n\tDRM_DEV_DEBUG(hdmi->dev, \"mode         :%d\\n\", mode);\n\tDRM_DEV_DEBUG(hdmi->dev, \"current_mode :%d\\n\", current_mode);\n\n\tif (current_mode == mode)\n\t\treturn;\n\n\tdo {\n\t\tif (current_mode > mode) {\n\t\t\tnext_mode = current_mode / 2;\n\t\t} else {\n\t\t\tif (current_mode < HDMI_SYS_POWER_MODE_A)\n\t\t\t\tnext_mode = HDMI_SYS_POWER_MODE_A;\n\t\t\telse\n\t\t\t\tnext_mode = current_mode * 2;\n\t\t}\n\n\t\tDRM_DEV_DEBUG(hdmi->dev, \"%d: next_mode :%d\\n\", i, next_mode);\n\n\t\tif (next_mode != HDMI_SYS_POWER_MODE_D) {\n\t\t\thdmi_modb(hdmi, HDMI_SYS_CTRL,\n\t\t\t\t  HDMI_SYS_POWER_MODE_MASK, next_mode);\n\t\t} else {\n\t\t\thdmi_writeb(hdmi, HDMI_SYS_CTRL,\n\t\t\t\t    HDMI_SYS_POWER_MODE_D |\n\t\t\t\t    HDMI_SYS_PLL_RESET_MASK);\n\t\t\tusleep_range(90, 100);\n\t\t\thdmi_writeb(hdmi, HDMI_SYS_CTRL,\n\t\t\t\t    HDMI_SYS_POWER_MODE_D |\n\t\t\t\t    HDMI_SYS_PLLB_RESET);\n\t\t\tusleep_range(90, 100);\n\t\t\thdmi_writeb(hdmi, HDMI_SYS_CTRL,\n\t\t\t\t    HDMI_SYS_POWER_MODE_D);\n\t\t}\n\t\tcurrent_mode = next_mode;\n\t\ti = i + 1;\n\t} while ((next_mode != mode) && (i < 5));\n\n\t \n\tif (mode < HDMI_SYS_POWER_MODE_D)\n\t\thdmi->tmdsclk = DEFAULT_PLLA_RATE;\n}\n\nstatic int\nrk3066_hdmi_upload_frame(struct rk3066_hdmi *hdmi, int setup_rc,\n\t\t\t union hdmi_infoframe *frame, u32 frame_index,\n\t\t\t u32 mask, u32 disable, u32 enable)\n{\n\tif (mask)\n\t\thdmi_modb(hdmi, HDMI_CP_AUTO_SEND_CTRL, mask, disable);\n\n\thdmi_writeb(hdmi, HDMI_CP_BUF_INDEX, frame_index);\n\n\tif (setup_rc >= 0) {\n\t\tu8 packed_frame[HDMI_MAXIMUM_INFO_FRAME_SIZE];\n\t\tssize_t rc, i;\n\n\t\trc = hdmi_infoframe_pack(frame, packed_frame,\n\t\t\t\t\t sizeof(packed_frame));\n\t\tif (rc < 0)\n\t\t\treturn rc;\n\n\t\tfor (i = 0; i < rc; i++)\n\t\t\thdmi_writeb(hdmi, HDMI_CP_BUF_ACC_HB0 + i * 4,\n\t\t\t\t    packed_frame[i]);\n\n\t\tif (mask)\n\t\t\thdmi_modb(hdmi, HDMI_CP_AUTO_SEND_CTRL, mask, enable);\n\t}\n\n\treturn setup_rc;\n}\n\nstatic int rk3066_hdmi_config_avi(struct rk3066_hdmi *hdmi,\n\t\t\t\t  struct drm_display_mode *mode)\n{\n\tunion hdmi_infoframe frame;\n\tint rc;\n\n\trc = drm_hdmi_avi_infoframe_from_display_mode(&frame.avi,\n\t\t\t\t\t\t      &hdmi->connector, mode);\n\n\tif (hdmi->hdmi_data.enc_out_format == HDMI_COLORSPACE_YUV444)\n\t\tframe.avi.colorspace = HDMI_COLORSPACE_YUV444;\n\telse if (hdmi->hdmi_data.enc_out_format == HDMI_COLORSPACE_YUV422)\n\t\tframe.avi.colorspace = HDMI_COLORSPACE_YUV422;\n\telse\n\t\tframe.avi.colorspace = HDMI_COLORSPACE_RGB;\n\n\tframe.avi.colorimetry = hdmi->hdmi_data.colorimetry;\n\tframe.avi.scan_mode = HDMI_SCAN_MODE_NONE;\n\n\treturn rk3066_hdmi_upload_frame(hdmi, rc, &frame,\n\t\t\t\t\tHDMI_INFOFRAME_AVI, 0, 0, 0);\n}\n\nstatic int rk3066_hdmi_config_video_timing(struct rk3066_hdmi *hdmi,\n\t\t\t\t\t   struct drm_display_mode *mode)\n{\n\tint value, vsync_offset;\n\n\t \n\tvalue = HDMI_EXT_VIDEO_SET_EN;\n\tvalue |= mode->flags & DRM_MODE_FLAG_PHSYNC ?\n\t\t HDMI_VIDEO_HSYNC_ACTIVE_HIGH : HDMI_VIDEO_HSYNC_ACTIVE_LOW;\n\tvalue |= mode->flags & DRM_MODE_FLAG_PVSYNC ?\n\t\t HDMI_VIDEO_VSYNC_ACTIVE_HIGH : HDMI_VIDEO_VSYNC_ACTIVE_LOW;\n\tvalue |= mode->flags & DRM_MODE_FLAG_INTERLACE ?\n\t\t HDMI_VIDEO_MODE_INTERLACE : HDMI_VIDEO_MODE_PROGRESSIVE;\n\n\tif (hdmi->hdmi_data.vic == 2 || hdmi->hdmi_data.vic == 3)\n\t\tvsync_offset = 6;\n\telse\n\t\tvsync_offset = 0;\n\n\tvalue |= vsync_offset << HDMI_VIDEO_VSYNC_OFFSET_SHIFT;\n\thdmi_writeb(hdmi, HDMI_EXT_VIDEO_PARA, value);\n\n\t \n\tvalue = mode->htotal;\n\thdmi_writeb(hdmi, HDMI_EXT_HTOTAL_L, value & 0xFF);\n\thdmi_writeb(hdmi, HDMI_EXT_HTOTAL_H, (value >> 8) & 0xFF);\n\n\tvalue = mode->htotal - mode->hdisplay;\n\thdmi_writeb(hdmi, HDMI_EXT_HBLANK_L, value & 0xFF);\n\thdmi_writeb(hdmi, HDMI_EXT_HBLANK_H, (value >> 8) & 0xFF);\n\n\tvalue = mode->htotal - mode->hsync_start;\n\thdmi_writeb(hdmi, HDMI_EXT_HDELAY_L, value & 0xFF);\n\thdmi_writeb(hdmi, HDMI_EXT_HDELAY_H, (value >> 8) & 0xFF);\n\n\tvalue = mode->hsync_end - mode->hsync_start;\n\thdmi_writeb(hdmi, HDMI_EXT_HDURATION_L, value & 0xFF);\n\thdmi_writeb(hdmi, HDMI_EXT_HDURATION_H, (value >> 8) & 0xFF);\n\n\tvalue = mode->vtotal;\n\thdmi_writeb(hdmi, HDMI_EXT_VTOTAL_L, value & 0xFF);\n\thdmi_writeb(hdmi, HDMI_EXT_VTOTAL_H, (value >> 8) & 0xFF);\n\n\tvalue = mode->vtotal - mode->vdisplay;\n\thdmi_writeb(hdmi, HDMI_EXT_VBLANK_L, value & 0xFF);\n\n\tvalue = mode->vtotal - mode->vsync_start + vsync_offset;\n\thdmi_writeb(hdmi, HDMI_EXT_VDELAY, value & 0xFF);\n\n\tvalue = mode->vsync_end - mode->vsync_start;\n\thdmi_writeb(hdmi, HDMI_EXT_VDURATION, value & 0xFF);\n\n\treturn 0;\n}\n\nstatic void\nrk3066_hdmi_phy_write(struct rk3066_hdmi *hdmi, u16 offset, u8 value)\n{\n\thdmi_writeb(hdmi, offset, value);\n\thdmi_modb(hdmi, HDMI_SYS_CTRL,\n\t\t  HDMI_SYS_PLL_RESET_MASK, HDMI_SYS_PLL_RESET);\n\tusleep_range(90, 100);\n\thdmi_modb(hdmi, HDMI_SYS_CTRL, HDMI_SYS_PLL_RESET_MASK, 0);\n\tusleep_range(900, 1000);\n}\n\nstatic void rk3066_hdmi_config_phy(struct rk3066_hdmi *hdmi)\n{\n\t \n\thdmi_writeb(hdmi, HDMI_DEEP_COLOR_MODE, 0x22);\n\n\t \n\tif (hdmi->tmdsclk > 100000000) {\n\t\trk3066_hdmi_phy_write(hdmi, 0x158, 0x0E);\n\t\trk3066_hdmi_phy_write(hdmi, 0x15c, 0x00);\n\t\trk3066_hdmi_phy_write(hdmi, 0x160, 0x60);\n\t\trk3066_hdmi_phy_write(hdmi, 0x164, 0x00);\n\t\trk3066_hdmi_phy_write(hdmi, 0x168, 0xDA);\n\t\trk3066_hdmi_phy_write(hdmi, 0x16c, 0xA1);\n\t\trk3066_hdmi_phy_write(hdmi, 0x170, 0x0e);\n\t\trk3066_hdmi_phy_write(hdmi, 0x174, 0x22);\n\t\trk3066_hdmi_phy_write(hdmi, 0x178, 0x00);\n\t} else if (hdmi->tmdsclk > 50000000) {\n\t\trk3066_hdmi_phy_write(hdmi, 0x158, 0x06);\n\t\trk3066_hdmi_phy_write(hdmi, 0x15c, 0x00);\n\t\trk3066_hdmi_phy_write(hdmi, 0x160, 0x60);\n\t\trk3066_hdmi_phy_write(hdmi, 0x164, 0x00);\n\t\trk3066_hdmi_phy_write(hdmi, 0x168, 0xCA);\n\t\trk3066_hdmi_phy_write(hdmi, 0x16c, 0xA3);\n\t\trk3066_hdmi_phy_write(hdmi, 0x170, 0x0e);\n\t\trk3066_hdmi_phy_write(hdmi, 0x174, 0x20);\n\t\trk3066_hdmi_phy_write(hdmi, 0x178, 0x00);\n\t} else {\n\t\trk3066_hdmi_phy_write(hdmi, 0x158, 0x02);\n\t\trk3066_hdmi_phy_write(hdmi, 0x15c, 0x00);\n\t\trk3066_hdmi_phy_write(hdmi, 0x160, 0x60);\n\t\trk3066_hdmi_phy_write(hdmi, 0x164, 0x00);\n\t\trk3066_hdmi_phy_write(hdmi, 0x168, 0xC2);\n\t\trk3066_hdmi_phy_write(hdmi, 0x16c, 0xA2);\n\t\trk3066_hdmi_phy_write(hdmi, 0x170, 0x0e);\n\t\trk3066_hdmi_phy_write(hdmi, 0x174, 0x20);\n\t\trk3066_hdmi_phy_write(hdmi, 0x178, 0x00);\n\t}\n}\n\nstatic int rk3066_hdmi_setup(struct rk3066_hdmi *hdmi,\n\t\t\t     struct drm_display_mode *mode)\n{\n\tstruct drm_display_info *display = &hdmi->connector.display_info;\n\n\thdmi->hdmi_data.vic = drm_match_cea_mode(mode);\n\thdmi->hdmi_data.enc_out_format = HDMI_COLORSPACE_RGB;\n\n\tif (hdmi->hdmi_data.vic == 6 || hdmi->hdmi_data.vic == 7 ||\n\t    hdmi->hdmi_data.vic == 21 || hdmi->hdmi_data.vic == 22 ||\n\t    hdmi->hdmi_data.vic == 2 || hdmi->hdmi_data.vic == 3 ||\n\t    hdmi->hdmi_data.vic == 17 || hdmi->hdmi_data.vic == 18)\n\t\thdmi->hdmi_data.colorimetry = HDMI_COLORIMETRY_ITU_601;\n\telse\n\t\thdmi->hdmi_data.colorimetry = HDMI_COLORIMETRY_ITU_709;\n\n\thdmi->tmdsclk = mode->clock * 1000;\n\n\t \n\thdmi_modb(hdmi, HDMI_VIDEO_CTRL2, HDMI_VIDEO_AUDIO_DISABLE_MASK,\n\t\t  HDMI_AUDIO_DISABLE | HDMI_VIDEO_DISABLE);\n\n\t \n\tif (rk3066_hdmi_get_power_mode(hdmi) != HDMI_SYS_POWER_MODE_B)\n\t\trk3066_hdmi_set_power_mode(hdmi, HDMI_SYS_POWER_MODE_B);\n\n\t \n\thdmi_modb(hdmi, HDMI_AV_CTRL1,\n\t\t  HDMI_VIDEO_DE_MASK, HDMI_VIDEO_EXTERNAL_DE);\n\thdmi_writeb(hdmi, HDMI_VIDEO_CTRL1,\n\t\t    HDMI_VIDEO_OUTPUT_RGB444 |\n\t\t    HDMI_VIDEO_INPUT_DATA_DEPTH_8BIT |\n\t\t    HDMI_VIDEO_INPUT_COLOR_RGB);\n\thdmi_writeb(hdmi, HDMI_DEEP_COLOR_MODE, 0x20);\n\n\trk3066_hdmi_config_video_timing(hdmi, mode);\n\n\tif (display->is_hdmi) {\n\t\thdmi_modb(hdmi, HDMI_HDCP_CTRL, HDMI_VIDEO_MODE_MASK,\n\t\t\t  HDMI_VIDEO_MODE_HDMI);\n\t\trk3066_hdmi_config_avi(hdmi, mode);\n\t} else {\n\t\thdmi_modb(hdmi, HDMI_HDCP_CTRL, HDMI_VIDEO_MODE_MASK, 0);\n\t}\n\n\trk3066_hdmi_config_phy(hdmi);\n\n\trk3066_hdmi_set_power_mode(hdmi, HDMI_SYS_POWER_MODE_E);\n\n\t \n\trk3066_hdmi_i2c_init(hdmi);\n\n\t \n\thdmi_modb(hdmi, HDMI_VIDEO_CTRL2,\n\t\t  HDMI_VIDEO_AUDIO_DISABLE_MASK, HDMI_AUDIO_DISABLE);\n\treturn 0;\n}\n\nstatic void\nrk3066_hdmi_encoder_mode_set(struct drm_encoder *encoder,\n\t\t\t     struct drm_display_mode *mode,\n\t\t\t     struct drm_display_mode *adj_mode)\n{\n\tstruct rk3066_hdmi *hdmi = encoder_to_rk3066_hdmi(encoder);\n\n\t \n\tdrm_mode_copy(&hdmi->previous_mode, adj_mode);\n}\n\nstatic void rk3066_hdmi_encoder_enable(struct drm_encoder *encoder)\n{\n\tstruct rk3066_hdmi *hdmi = encoder_to_rk3066_hdmi(encoder);\n\tint mux, val;\n\n\tmux = drm_of_encoder_active_endpoint_id(hdmi->dev->of_node, encoder);\n\tif (mux)\n\t\tval = (HDMI_VIDEO_SEL << 16) | HDMI_VIDEO_SEL;\n\telse\n\t\tval = HDMI_VIDEO_SEL << 16;\n\n\tregmap_write(hdmi->grf_regmap, GRF_SOC_CON0, val);\n\n\tDRM_DEV_DEBUG(hdmi->dev, \"hdmi encoder enable select: vop%s\\n\",\n\t\t      (mux) ? \"1\" : \"0\");\n\n\trk3066_hdmi_setup(hdmi, &hdmi->previous_mode);\n}\n\nstatic void rk3066_hdmi_encoder_disable(struct drm_encoder *encoder)\n{\n\tstruct rk3066_hdmi *hdmi = encoder_to_rk3066_hdmi(encoder);\n\n\tDRM_DEV_DEBUG(hdmi->dev, \"hdmi encoder disable\\n\");\n\n\tif (rk3066_hdmi_get_power_mode(hdmi) == HDMI_SYS_POWER_MODE_E) {\n\t\thdmi_writeb(hdmi, HDMI_VIDEO_CTRL2,\n\t\t\t    HDMI_VIDEO_AUDIO_DISABLE_MASK);\n\t\thdmi_modb(hdmi, HDMI_VIDEO_CTRL2,\n\t\t\t  HDMI_AUDIO_CP_LOGIC_RESET_MASK,\n\t\t\t  HDMI_AUDIO_CP_LOGIC_RESET);\n\t\tusleep_range(500, 510);\n\t}\n\trk3066_hdmi_set_power_mode(hdmi, HDMI_SYS_POWER_MODE_A);\n}\n\nstatic bool\nrk3066_hdmi_encoder_mode_fixup(struct drm_encoder *encoder,\n\t\t\t       const struct drm_display_mode *mode,\n\t\t\t       struct drm_display_mode *adj_mode)\n{\n\treturn true;\n}\n\nstatic int\nrk3066_hdmi_encoder_atomic_check(struct drm_encoder *encoder,\n\t\t\t\t struct drm_crtc_state *crtc_state,\n\t\t\t\t struct drm_connector_state *conn_state)\n{\n\tstruct rockchip_crtc_state *s = to_rockchip_crtc_state(crtc_state);\n\n\ts->output_mode = ROCKCHIP_OUT_MODE_P888;\n\ts->output_type = DRM_MODE_CONNECTOR_HDMIA;\n\n\treturn 0;\n}\n\nstatic const\nstruct drm_encoder_helper_funcs rk3066_hdmi_encoder_helper_funcs = {\n\t.enable       = rk3066_hdmi_encoder_enable,\n\t.disable      = rk3066_hdmi_encoder_disable,\n\t.mode_fixup   = rk3066_hdmi_encoder_mode_fixup,\n\t.mode_set     = rk3066_hdmi_encoder_mode_set,\n\t.atomic_check = rk3066_hdmi_encoder_atomic_check,\n};\n\nstatic enum drm_connector_status\nrk3066_hdmi_connector_detect(struct drm_connector *connector, bool force)\n{\n\tstruct rk3066_hdmi *hdmi = connector_to_rk3066_hdmi(connector);\n\n\treturn (hdmi_readb(hdmi, HDMI_HPG_MENS_STA) & HDMI_HPG_IN_STATUS_HIGH) ?\n\t\tconnector_status_connected : connector_status_disconnected;\n}\n\nstatic int rk3066_hdmi_connector_get_modes(struct drm_connector *connector)\n{\n\tstruct rk3066_hdmi *hdmi = connector_to_rk3066_hdmi(connector);\n\tstruct edid *edid;\n\tint ret = 0;\n\n\tif (!hdmi->ddc)\n\t\treturn 0;\n\n\tedid = drm_get_edid(connector, hdmi->ddc);\n\tif (edid) {\n\t\tdrm_connector_update_edid_property(connector, edid);\n\t\tret = drm_add_edid_modes(connector, edid);\n\t\tkfree(edid);\n\t}\n\n\treturn ret;\n}\n\nstatic enum drm_mode_status\nrk3066_hdmi_connector_mode_valid(struct drm_connector *connector,\n\t\t\t\t struct drm_display_mode *mode)\n{\n\tu32 vic = drm_match_cea_mode(mode);\n\n\tif (vic > 1)\n\t\treturn MODE_OK;\n\telse\n\t\treturn MODE_BAD;\n}\n\nstatic struct drm_encoder *\nrk3066_hdmi_connector_best_encoder(struct drm_connector *connector)\n{\n\tstruct rk3066_hdmi *hdmi = connector_to_rk3066_hdmi(connector);\n\n\treturn &hdmi->encoder.encoder;\n}\n\nstatic int\nrk3066_hdmi_probe_single_connector_modes(struct drm_connector *connector,\n\t\t\t\t\t uint32_t maxX, uint32_t maxY)\n{\n\tif (maxX > 1920)\n\t\tmaxX = 1920;\n\tif (maxY > 1080)\n\t\tmaxY = 1080;\n\n\treturn drm_helper_probe_single_connector_modes(connector, maxX, maxY);\n}\n\nstatic void rk3066_hdmi_connector_destroy(struct drm_connector *connector)\n{\n\tdrm_connector_unregister(connector);\n\tdrm_connector_cleanup(connector);\n}\n\nstatic const struct drm_connector_funcs rk3066_hdmi_connector_funcs = {\n\t.fill_modes = rk3066_hdmi_probe_single_connector_modes,\n\t.detect = rk3066_hdmi_connector_detect,\n\t.destroy = rk3066_hdmi_connector_destroy,\n\t.reset = drm_atomic_helper_connector_reset,\n\t.atomic_duplicate_state = drm_atomic_helper_connector_duplicate_state,\n\t.atomic_destroy_state = drm_atomic_helper_connector_destroy_state,\n};\n\nstatic const\nstruct drm_connector_helper_funcs rk3066_hdmi_connector_helper_funcs = {\n\t.get_modes = rk3066_hdmi_connector_get_modes,\n\t.mode_valid = rk3066_hdmi_connector_mode_valid,\n\t.best_encoder = rk3066_hdmi_connector_best_encoder,\n};\n\nstatic int\nrk3066_hdmi_register(struct drm_device *drm, struct rk3066_hdmi *hdmi)\n{\n\tstruct drm_encoder *encoder = &hdmi->encoder.encoder;\n\tstruct device *dev = hdmi->dev;\n\n\tencoder->possible_crtcs =\n\t\tdrm_of_find_possible_crtcs(drm, dev->of_node);\n\n\t \n\tif (encoder->possible_crtcs == 0)\n\t\treturn -EPROBE_DEFER;\n\n\tdrm_encoder_helper_add(encoder, &rk3066_hdmi_encoder_helper_funcs);\n\tdrm_simple_encoder_init(drm, encoder, DRM_MODE_ENCODER_TMDS);\n\n\thdmi->connector.polled = DRM_CONNECTOR_POLL_HPD;\n\n\tdrm_connector_helper_add(&hdmi->connector,\n\t\t\t\t &rk3066_hdmi_connector_helper_funcs);\n\tdrm_connector_init_with_ddc(drm, &hdmi->connector,\n\t\t\t\t    &rk3066_hdmi_connector_funcs,\n\t\t\t\t    DRM_MODE_CONNECTOR_HDMIA,\n\t\t\t\t    hdmi->ddc);\n\n\tdrm_connector_attach_encoder(&hdmi->connector, encoder);\n\n\treturn 0;\n}\n\nstatic irqreturn_t rk3066_hdmi_hardirq(int irq, void *dev_id)\n{\n\tstruct rk3066_hdmi *hdmi = dev_id;\n\tirqreturn_t ret = IRQ_NONE;\n\tu8 interrupt;\n\n\tif (rk3066_hdmi_get_power_mode(hdmi) == HDMI_SYS_POWER_MODE_A)\n\t\thdmi_writeb(hdmi, HDMI_SYS_CTRL, HDMI_SYS_POWER_MODE_B);\n\n\tinterrupt = hdmi_readb(hdmi, HDMI_INTR_STATUS1);\n\tif (interrupt)\n\t\thdmi_writeb(hdmi, HDMI_INTR_STATUS1, interrupt);\n\n\tif (interrupt & HDMI_INTR_EDID_MASK) {\n\t\thdmi->i2c->stat = interrupt;\n\t\tcomplete(&hdmi->i2c->cmpltn);\n\t}\n\n\tif (interrupt & (HDMI_INTR_HOTPLUG | HDMI_INTR_MSENS))\n\t\tret = IRQ_WAKE_THREAD;\n\n\treturn ret;\n}\n\nstatic irqreturn_t rk3066_hdmi_irq(int irq, void *dev_id)\n{\n\tstruct rk3066_hdmi *hdmi = dev_id;\n\n\tdrm_helper_hpd_irq_event(hdmi->connector.dev);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int rk3066_hdmi_i2c_read(struct rk3066_hdmi *hdmi, struct i2c_msg *msgs)\n{\n\tint length = msgs->len;\n\tu8 *buf = msgs->buf;\n\tint ret;\n\n\tret = wait_for_completion_timeout(&hdmi->i2c->cmpltn, HZ / 10);\n\tif (!ret || hdmi->i2c->stat & HDMI_INTR_EDID_ERR)\n\t\treturn -EAGAIN;\n\n\twhile (length--)\n\t\t*buf++ = hdmi_readb(hdmi, HDMI_DDC_READ_FIFO_ADDR);\n\n\treturn 0;\n}\n\nstatic int rk3066_hdmi_i2c_write(struct rk3066_hdmi *hdmi, struct i2c_msg *msgs)\n{\n\t \n\tif (msgs->len != 1 ||\n\t    (msgs->addr != DDC_ADDR && msgs->addr != DDC_SEGMENT_ADDR))\n\t\treturn -EINVAL;\n\n\treinit_completion(&hdmi->i2c->cmpltn);\n\n\tif (msgs->addr == DDC_SEGMENT_ADDR)\n\t\thdmi->i2c->segment_addr = msgs->buf[0];\n\tif (msgs->addr == DDC_ADDR)\n\t\thdmi->i2c->ddc_addr = msgs->buf[0];\n\n\t \n\thdmi_writeb(hdmi, HDMI_EDID_FIFO_ADDR, 0x00);\n\n\t \n\thdmi_writeb(hdmi, HDMI_EDID_WORD_ADDR, hdmi->i2c->ddc_addr);\n\n\t \n\thdmi_writeb(hdmi, HDMI_EDID_SEGMENT_POINTER, hdmi->i2c->segment_addr);\n\n\treturn 0;\n}\n\nstatic int rk3066_hdmi_i2c_xfer(struct i2c_adapter *adap,\n\t\t\t\tstruct i2c_msg *msgs, int num)\n{\n\tstruct rk3066_hdmi *hdmi = i2c_get_adapdata(adap);\n\tstruct rk3066_hdmi_i2c *i2c = hdmi->i2c;\n\tint i, ret = 0;\n\n\tmutex_lock(&i2c->i2c_lock);\n\n\trk3066_hdmi_i2c_init(hdmi);\n\n\t \n\thdmi_modb(hdmi, HDMI_INTR_MASK1,\n\t\t  HDMI_INTR_EDID_MASK, HDMI_INTR_EDID_MASK);\n\ti2c->stat = 0;\n\n\tfor (i = 0; i < num; i++) {\n\t\tDRM_DEV_DEBUG(hdmi->dev,\n\t\t\t      \"xfer: num: %d/%d, len: %d, flags: %#x\\n\",\n\t\t\t      i + 1, num, msgs[i].len, msgs[i].flags);\n\n\t\tif (msgs[i].flags & I2C_M_RD)\n\t\t\tret = rk3066_hdmi_i2c_read(hdmi, &msgs[i]);\n\t\telse\n\t\t\tret = rk3066_hdmi_i2c_write(hdmi, &msgs[i]);\n\n\t\tif (ret < 0)\n\t\t\tbreak;\n\t}\n\n\tif (!ret)\n\t\tret = num;\n\n\t \n\thdmi_modb(hdmi, HDMI_INTR_MASK1, HDMI_INTR_EDID_MASK, 0);\n\n\tmutex_unlock(&i2c->i2c_lock);\n\n\treturn ret;\n}\n\nstatic u32 rk3066_hdmi_i2c_func(struct i2c_adapter *adapter)\n{\n\treturn I2C_FUNC_I2C | I2C_FUNC_SMBUS_EMUL;\n}\n\nstatic const struct i2c_algorithm rk3066_hdmi_algorithm = {\n\t.master_xfer   = rk3066_hdmi_i2c_xfer,\n\t.functionality = rk3066_hdmi_i2c_func,\n};\n\nstatic struct i2c_adapter *rk3066_hdmi_i2c_adapter(struct rk3066_hdmi *hdmi)\n{\n\tstruct i2c_adapter *adap;\n\tstruct rk3066_hdmi_i2c *i2c;\n\tint ret;\n\n\ti2c = devm_kzalloc(hdmi->dev, sizeof(*i2c), GFP_KERNEL);\n\tif (!i2c)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tmutex_init(&i2c->i2c_lock);\n\tinit_completion(&i2c->cmpltn);\n\n\tadap = &i2c->adap;\n\tadap->class = I2C_CLASS_DDC;\n\tadap->owner = THIS_MODULE;\n\tadap->dev.parent = hdmi->dev;\n\tadap->dev.of_node = hdmi->dev->of_node;\n\tadap->algo = &rk3066_hdmi_algorithm;\n\tstrscpy(adap->name, \"RK3066 HDMI\", sizeof(adap->name));\n\ti2c_set_adapdata(adap, hdmi);\n\n\tret = i2c_add_adapter(adap);\n\tif (ret) {\n\t\tDRM_DEV_ERROR(hdmi->dev, \"cannot add %s I2C adapter\\n\",\n\t\t\t      adap->name);\n\t\tdevm_kfree(hdmi->dev, i2c);\n\t\treturn ERR_PTR(ret);\n\t}\n\n\thdmi->i2c = i2c;\n\n\tDRM_DEV_DEBUG(hdmi->dev, \"registered %s I2C bus driver\\n\", adap->name);\n\n\treturn adap;\n}\n\nstatic int rk3066_hdmi_bind(struct device *dev, struct device *master,\n\t\t\t    void *data)\n{\n\tstruct platform_device *pdev = to_platform_device(dev);\n\tstruct drm_device *drm = data;\n\tstruct rk3066_hdmi *hdmi;\n\tint irq;\n\tint ret;\n\n\thdmi = devm_kzalloc(dev, sizeof(*hdmi), GFP_KERNEL);\n\tif (!hdmi)\n\t\treturn -ENOMEM;\n\n\thdmi->dev = dev;\n\thdmi->drm_dev = drm;\n\thdmi->regs = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(hdmi->regs))\n\t\treturn PTR_ERR(hdmi->regs);\n\n\tirq = platform_get_irq(pdev, 0);\n\tif (irq < 0)\n\t\treturn irq;\n\n\thdmi->hclk = devm_clk_get(dev, \"hclk\");\n\tif (IS_ERR(hdmi->hclk)) {\n\t\tDRM_DEV_ERROR(dev, \"unable to get HDMI hclk clock\\n\");\n\t\treturn PTR_ERR(hdmi->hclk);\n\t}\n\n\tret = clk_prepare_enable(hdmi->hclk);\n\tif (ret) {\n\t\tDRM_DEV_ERROR(dev, \"cannot enable HDMI hclk clock: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\thdmi->grf_regmap = syscon_regmap_lookup_by_phandle(dev->of_node,\n\t\t\t\t\t\t\t   \"rockchip,grf\");\n\tif (IS_ERR(hdmi->grf_regmap)) {\n\t\tDRM_DEV_ERROR(dev, \"unable to get rockchip,grf\\n\");\n\t\tret = PTR_ERR(hdmi->grf_regmap);\n\t\tgoto err_disable_hclk;\n\t}\n\n\t \n\thdmi_writeb(hdmi, HDMI_INTERNAL_CLK_DIVIDER, 25);\n\n\thdmi->ddc = rk3066_hdmi_i2c_adapter(hdmi);\n\tif (IS_ERR(hdmi->ddc)) {\n\t\tret = PTR_ERR(hdmi->ddc);\n\t\thdmi->ddc = NULL;\n\t\tgoto err_disable_hclk;\n\t}\n\n\trk3066_hdmi_set_power_mode(hdmi, HDMI_SYS_POWER_MODE_B);\n\tusleep_range(999, 1000);\n\thdmi_writeb(hdmi, HDMI_INTR_MASK1, HDMI_INTR_HOTPLUG);\n\thdmi_writeb(hdmi, HDMI_INTR_MASK2, 0);\n\thdmi_writeb(hdmi, HDMI_INTR_MASK3, 0);\n\thdmi_writeb(hdmi, HDMI_INTR_MASK4, 0);\n\trk3066_hdmi_set_power_mode(hdmi, HDMI_SYS_POWER_MODE_A);\n\n\tret = rk3066_hdmi_register(drm, hdmi);\n\tif (ret)\n\t\tgoto err_disable_i2c;\n\n\tdev_set_drvdata(dev, hdmi);\n\n\tret = devm_request_threaded_irq(dev, irq, rk3066_hdmi_hardirq,\n\t\t\t\t\trk3066_hdmi_irq, IRQF_SHARED,\n\t\t\t\t\tdev_name(dev), hdmi);\n\tif (ret) {\n\t\tDRM_DEV_ERROR(dev, \"failed to request hdmi irq: %d\\n\", ret);\n\t\tgoto err_cleanup_hdmi;\n\t}\n\n\treturn 0;\n\nerr_cleanup_hdmi:\n\thdmi->connector.funcs->destroy(&hdmi->connector);\n\thdmi->encoder.encoder.funcs->destroy(&hdmi->encoder.encoder);\nerr_disable_i2c:\n\ti2c_put_adapter(hdmi->ddc);\nerr_disable_hclk:\n\tclk_disable_unprepare(hdmi->hclk);\n\n\treturn ret;\n}\n\nstatic void rk3066_hdmi_unbind(struct device *dev, struct device *master,\n\t\t\t       void *data)\n{\n\tstruct rk3066_hdmi *hdmi = dev_get_drvdata(dev);\n\n\thdmi->connector.funcs->destroy(&hdmi->connector);\n\thdmi->encoder.encoder.funcs->destroy(&hdmi->encoder.encoder);\n\n\ti2c_put_adapter(hdmi->ddc);\n\tclk_disable_unprepare(hdmi->hclk);\n}\n\nstatic const struct component_ops rk3066_hdmi_ops = {\n\t.bind   = rk3066_hdmi_bind,\n\t.unbind = rk3066_hdmi_unbind,\n};\n\nstatic int rk3066_hdmi_probe(struct platform_device *pdev)\n{\n\treturn component_add(&pdev->dev, &rk3066_hdmi_ops);\n}\n\nstatic void rk3066_hdmi_remove(struct platform_device *pdev)\n{\n\tcomponent_del(&pdev->dev, &rk3066_hdmi_ops);\n}\n\nstatic const struct of_device_id rk3066_hdmi_dt_ids[] = {\n\t{ .compatible = \"rockchip,rk3066-hdmi\" },\n\t{   },\n};\nMODULE_DEVICE_TABLE(of, rk3066_hdmi_dt_ids);\n\nstruct platform_driver rk3066_hdmi_driver = {\n\t.probe  = rk3066_hdmi_probe,\n\t.remove_new = rk3066_hdmi_remove,\n\t.driver = {\n\t\t.name = \"rockchip-rk3066-hdmi\",\n\t\t.of_match_table = rk3066_hdmi_dt_ids,\n\t},\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}