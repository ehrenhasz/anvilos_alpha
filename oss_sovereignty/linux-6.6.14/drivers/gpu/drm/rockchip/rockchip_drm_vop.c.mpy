{
  "module_name": "rockchip_drm_vop.c",
  "hash_id": "acf40d74f98c555d346f508f217d9e6502595011616ba18a23b7376ec54a6995",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/rockchip/rockchip_drm_vop.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/component.h>\n#include <linux/delay.h>\n#include <linux/iopoll.h>\n#include <linux/kernel.h>\n#include <linux/log2.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/overflow.h>\n#include <linux/platform_device.h>\n#include <linux/pm_runtime.h>\n#include <linux/reset.h>\n\n#include <drm/drm.h>\n#include <drm/drm_atomic.h>\n#include <drm/drm_atomic_uapi.h>\n#include <drm/drm_blend.h>\n#include <drm/drm_crtc.h>\n#include <drm/drm_flip_work.h>\n#include <drm/drm_fourcc.h>\n#include <drm/drm_framebuffer.h>\n#include <drm/drm_gem_atomic_helper.h>\n#include <drm/drm_gem_framebuffer_helper.h>\n#include <drm/drm_probe_helper.h>\n#include <drm/drm_self_refresh_helper.h>\n#include <drm/drm_vblank.h>\n\n#ifdef CONFIG_DRM_ANALOGIX_DP\n#include <drm/bridge/analogix_dp.h>\n#endif\n\n#include \"rockchip_drm_drv.h\"\n#include \"rockchip_drm_gem.h\"\n#include \"rockchip_drm_fb.h\"\n#include \"rockchip_drm_vop.h\"\n#include \"rockchip_rgb.h\"\n\n#define VOP_WIN_SET(vop, win, name, v) \\\n\t\tvop_reg_set(vop, &win->phy->name, win->base, ~0, v, #name)\n#define VOP_SCL_SET(vop, win, name, v) \\\n\t\tvop_reg_set(vop, &win->phy->scl->name, win->base, ~0, v, #name)\n#define VOP_SCL_SET_EXT(vop, win, name, v) \\\n\t\tvop_reg_set(vop, &win->phy->scl->ext->name, \\\n\t\t\t    win->base, ~0, v, #name)\n\n#define VOP_WIN_YUV2YUV_SET(vop, win_yuv2yuv, name, v) \\\n\tdo { \\\n\t\tif (win_yuv2yuv && win_yuv2yuv->name.mask) \\\n\t\t\tvop_reg_set(vop, &win_yuv2yuv->name, 0, ~0, v, #name); \\\n\t} while (0)\n\n#define VOP_WIN_YUV2YUV_COEFFICIENT_SET(vop, win_yuv2yuv, name, v) \\\n\tdo { \\\n\t\tif (win_yuv2yuv && win_yuv2yuv->phy->name.mask) \\\n\t\t\tvop_reg_set(vop, &win_yuv2yuv->phy->name, win_yuv2yuv->base, ~0, v, #name); \\\n\t} while (0)\n\n#define VOP_INTR_SET_MASK(vop, name, mask, v) \\\n\t\tvop_reg_set(vop, &vop->data->intr->name, 0, mask, v, #name)\n\n#define VOP_REG_SET(vop, group, name, v) \\\n\t\t    vop_reg_set(vop, &vop->data->group->name, 0, ~0, v, #name)\n\n#define VOP_HAS_REG(vop, group, name) \\\n\t\t(!!(vop->data->group->name.mask))\n\n#define VOP_INTR_SET_TYPE(vop, name, type, v) \\\n\tdo { \\\n\t\tint i, reg = 0, mask = 0; \\\n\t\tfor (i = 0; i < vop->data->intr->nintrs; i++) { \\\n\t\t\tif (vop->data->intr->intrs[i] & type) { \\\n\t\t\t\treg |= (v) << i; \\\n\t\t\t\tmask |= 1 << i; \\\n\t\t\t} \\\n\t\t} \\\n\t\tVOP_INTR_SET_MASK(vop, name, mask, reg); \\\n\t} while (0)\n#define VOP_INTR_GET_TYPE(vop, name, type) \\\n\t\tvop_get_intr_type(vop, &vop->data->intr->name, type)\n\n#define VOP_WIN_GET(vop, win, name) \\\n\t\tvop_read_reg(vop, win->base, &win->phy->name)\n\n#define VOP_WIN_HAS_REG(win, name) \\\n\t(!!(win->phy->name.mask))\n\n#define VOP_WIN_GET_YRGBADDR(vop, win) \\\n\t\tvop_readl(vop, win->base + win->phy->yrgb_mst.offset)\n\n#define VOP_WIN_TO_INDEX(vop_win) \\\n\t((vop_win) - (vop_win)->vop->win)\n\n#define VOP_AFBC_SET(vop, name, v) \\\n\tdo { \\\n\t\tif ((vop)->data->afbc) \\\n\t\t\tvop_reg_set((vop), &(vop)->data->afbc->name, \\\n\t\t\t\t    0, ~0, v, #name); \\\n\t} while (0)\n\n#define to_vop(x) container_of(x, struct vop, crtc)\n#define to_vop_win(x) container_of(x, struct vop_win, base)\n\n#define AFBC_FMT_RGB565\t\t0x0\n#define AFBC_FMT_U8U8U8U8\t0x5\n#define AFBC_FMT_U8U8U8\t\t0x4\n\n#define AFBC_TILE_16x16\t\tBIT(4)\n\n \nstatic const uint32_t bt601_yuv2rgb[] = {\n\t0x4A8, 0x0,    0x662,\n\t0x4A8, 0x1E6F, 0x1CBF,\n\t0x4A8, 0x812,  0x0,\n\t0x321168, 0x0877CF, 0x2EB127\n};\n\nenum vop_pending {\n\tVOP_PENDING_FB_UNREF,\n};\n\nstruct vop_win {\n\tstruct drm_plane base;\n\tconst struct vop_win_data *data;\n\tconst struct vop_win_yuv2yuv_data *yuv2yuv_data;\n\tstruct vop *vop;\n};\n\nstruct rockchip_rgb;\nstruct vop {\n\tstruct drm_crtc crtc;\n\tstruct device *dev;\n\tstruct drm_device *drm_dev;\n\tbool is_enabled;\n\n\tstruct completion dsp_hold_completion;\n\tunsigned int win_enabled;\n\n\t \n\tstruct drm_pending_vblank_event *event;\n\n\tstruct drm_flip_work fb_unref_work;\n\tunsigned long pending;\n\n\tstruct completion line_flag_completion;\n\n\tconst struct vop_data *data;\n\n\tuint32_t *regsbak;\n\tvoid __iomem *regs;\n\tvoid __iomem *lut_regs;\n\n\t \n\tuint32_t len;\n\n\t \n\tspinlock_t reg_lock;\n\t \n\tspinlock_t irq_lock;\n\t \n\tstruct mutex vop_lock;\n\n\tunsigned int irq;\n\n\t \n\tstruct clk *hclk;\n\t \n\tstruct clk *dclk;\n\t \n\tstruct clk *aclk;\n\n\t \n\tstruct reset_control *dclk_rst;\n\n\t \n\tstruct rockchip_rgb *rgb;\n\n\tstruct vop_win win[];\n};\n\nstatic inline uint32_t vop_readl(struct vop *vop, uint32_t offset)\n{\n\treturn readl(vop->regs + offset);\n}\n\nstatic inline uint32_t vop_read_reg(struct vop *vop, uint32_t base,\n\t\t\t\t    const struct vop_reg *reg)\n{\n\treturn (vop_readl(vop, base + reg->offset) >> reg->shift) & reg->mask;\n}\n\nstatic void vop_reg_set(struct vop *vop, const struct vop_reg *reg,\n\t\t\tuint32_t _offset, uint32_t _mask, uint32_t v,\n\t\t\tconst char *reg_name)\n{\n\tint offset, mask, shift;\n\n\tif (!reg || !reg->mask) {\n\t\tDRM_DEV_DEBUG(vop->dev, \"Warning: not support %s\\n\", reg_name);\n\t\treturn;\n\t}\n\n\toffset = reg->offset + _offset;\n\tmask = reg->mask & _mask;\n\tshift = reg->shift;\n\n\tif (reg->write_mask) {\n\t\tv = ((v << shift) & 0xffff) | (mask << (shift + 16));\n\t} else {\n\t\tuint32_t cached_val = vop->regsbak[offset >> 2];\n\n\t\tv = (cached_val & ~(mask << shift)) | ((v & mask) << shift);\n\t\tvop->regsbak[offset >> 2] = v;\n\t}\n\n\tif (reg->relaxed)\n\t\twritel_relaxed(v, vop->regs + offset);\n\telse\n\t\twritel(v, vop->regs + offset);\n}\n\nstatic inline uint32_t vop_get_intr_type(struct vop *vop,\n\t\t\t\t\t const struct vop_reg *reg, int type)\n{\n\tuint32_t i, ret = 0;\n\tuint32_t regs = vop_read_reg(vop, 0, reg);\n\n\tfor (i = 0; i < vop->data->intr->nintrs; i++) {\n\t\tif ((type & vop->data->intr->intrs[i]) && (regs & 1 << i))\n\t\t\tret |= vop->data->intr->intrs[i];\n\t}\n\n\treturn ret;\n}\n\nstatic inline void vop_cfg_done(struct vop *vop)\n{\n\tVOP_REG_SET(vop, common, cfg_done, 1);\n}\n\nstatic bool has_rb_swapped(uint32_t version, uint32_t format)\n{\n\tswitch (format) {\n\tcase DRM_FORMAT_XBGR8888:\n\tcase DRM_FORMAT_ABGR8888:\n\tcase DRM_FORMAT_BGR565:\n\t\treturn true;\n\t \n\tcase DRM_FORMAT_RGB888:\n\t\treturn VOP_MAJOR(version) == 3;\n\tcase DRM_FORMAT_BGR888:\n\t\treturn VOP_MAJOR(version) != 3;\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nstatic bool has_uv_swapped(uint32_t format)\n{\n\tswitch (format) {\n\tcase DRM_FORMAT_NV21:\n\tcase DRM_FORMAT_NV61:\n\tcase DRM_FORMAT_NV42:\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nstatic enum vop_data_format vop_convert_format(uint32_t format)\n{\n\tswitch (format) {\n\tcase DRM_FORMAT_XRGB8888:\n\tcase DRM_FORMAT_ARGB8888:\n\tcase DRM_FORMAT_XBGR8888:\n\tcase DRM_FORMAT_ABGR8888:\n\t\treturn VOP_FMT_ARGB8888;\n\tcase DRM_FORMAT_RGB888:\n\tcase DRM_FORMAT_BGR888:\n\t\treturn VOP_FMT_RGB888;\n\tcase DRM_FORMAT_RGB565:\n\tcase DRM_FORMAT_BGR565:\n\t\treturn VOP_FMT_RGB565;\n\tcase DRM_FORMAT_NV12:\n\tcase DRM_FORMAT_NV21:\n\t\treturn VOP_FMT_YUV420SP;\n\tcase DRM_FORMAT_NV16:\n\tcase DRM_FORMAT_NV61:\n\t\treturn VOP_FMT_YUV422SP;\n\tcase DRM_FORMAT_NV24:\n\tcase DRM_FORMAT_NV42:\n\t\treturn VOP_FMT_YUV444SP;\n\tdefault:\n\t\tDRM_ERROR(\"unsupported format[%08x]\\n\", format);\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic int vop_convert_afbc_format(uint32_t format)\n{\n\tswitch (format) {\n\tcase DRM_FORMAT_XRGB8888:\n\tcase DRM_FORMAT_ARGB8888:\n\tcase DRM_FORMAT_XBGR8888:\n\tcase DRM_FORMAT_ABGR8888:\n\t\treturn AFBC_FMT_U8U8U8U8;\n\tcase DRM_FORMAT_RGB888:\n\tcase DRM_FORMAT_BGR888:\n\t\treturn AFBC_FMT_U8U8U8;\n\tcase DRM_FORMAT_RGB565:\n\tcase DRM_FORMAT_BGR565:\n\t\treturn AFBC_FMT_RGB565;\n\tdefault:\n\t\tDRM_DEBUG_KMS(\"unsupported AFBC format[%08x]\\n\", format);\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic uint16_t scl_vop_cal_scale(enum scale_mode mode, uint32_t src,\n\t\t\t\t  uint32_t dst, bool is_horizontal,\n\t\t\t\t  int vsu_mode, int *vskiplines)\n{\n\tuint16_t val = 1 << SCL_FT_DEFAULT_FIXPOINT_SHIFT;\n\n\tif (vskiplines)\n\t\t*vskiplines = 0;\n\n\tif (is_horizontal) {\n\t\tif (mode == SCALE_UP)\n\t\t\tval = GET_SCL_FT_BIC(src, dst);\n\t\telse if (mode == SCALE_DOWN)\n\t\t\tval = GET_SCL_FT_BILI_DN(src, dst);\n\t} else {\n\t\tif (mode == SCALE_UP) {\n\t\t\tif (vsu_mode == SCALE_UP_BIL)\n\t\t\t\tval = GET_SCL_FT_BILI_UP(src, dst);\n\t\t\telse\n\t\t\t\tval = GET_SCL_FT_BIC(src, dst);\n\t\t} else if (mode == SCALE_DOWN) {\n\t\t\tif (vskiplines) {\n\t\t\t\t*vskiplines = scl_get_vskiplines(src, dst);\n\t\t\t\tval = scl_get_bili_dn_vskip(src, dst,\n\t\t\t\t\t\t\t    *vskiplines);\n\t\t\t} else {\n\t\t\t\tval = GET_SCL_FT_BILI_DN(src, dst);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn val;\n}\n\nstatic void scl_vop_cal_scl_fac(struct vop *vop, const struct vop_win_data *win,\n\t\t\t     uint32_t src_w, uint32_t src_h, uint32_t dst_w,\n\t\t\t     uint32_t dst_h, const struct drm_format_info *info)\n{\n\tuint16_t yrgb_hor_scl_mode, yrgb_ver_scl_mode;\n\tuint16_t cbcr_hor_scl_mode = SCALE_NONE;\n\tuint16_t cbcr_ver_scl_mode = SCALE_NONE;\n\tbool is_yuv = false;\n\tuint16_t cbcr_src_w = src_w / info->hsub;\n\tuint16_t cbcr_src_h = src_h / info->vsub;\n\tuint16_t vsu_mode;\n\tuint16_t lb_mode;\n\tuint32_t val;\n\tint vskiplines;\n\n\tif (info->is_yuv)\n\t\tis_yuv = true;\n\n\tif (dst_w > 3840) {\n\t\tDRM_DEV_ERROR(vop->dev, \"Maximum dst width (3840) exceeded\\n\");\n\t\treturn;\n\t}\n\n\tif (!win->phy->scl->ext) {\n\t\tVOP_SCL_SET(vop, win, scale_yrgb_x,\n\t\t\t    scl_cal_scale2(src_w, dst_w));\n\t\tVOP_SCL_SET(vop, win, scale_yrgb_y,\n\t\t\t    scl_cal_scale2(src_h, dst_h));\n\t\tif (is_yuv) {\n\t\t\tVOP_SCL_SET(vop, win, scale_cbcr_x,\n\t\t\t\t    scl_cal_scale2(cbcr_src_w, dst_w));\n\t\t\tVOP_SCL_SET(vop, win, scale_cbcr_y,\n\t\t\t\t    scl_cal_scale2(cbcr_src_h, dst_h));\n\t\t}\n\t\treturn;\n\t}\n\n\tyrgb_hor_scl_mode = scl_get_scl_mode(src_w, dst_w);\n\tyrgb_ver_scl_mode = scl_get_scl_mode(src_h, dst_h);\n\n\tif (is_yuv) {\n\t\tcbcr_hor_scl_mode = scl_get_scl_mode(cbcr_src_w, dst_w);\n\t\tcbcr_ver_scl_mode = scl_get_scl_mode(cbcr_src_h, dst_h);\n\t\tif (cbcr_hor_scl_mode == SCALE_DOWN)\n\t\t\tlb_mode = scl_vop_cal_lb_mode(dst_w, true);\n\t\telse\n\t\t\tlb_mode = scl_vop_cal_lb_mode(cbcr_src_w, true);\n\t} else {\n\t\tif (yrgb_hor_scl_mode == SCALE_DOWN)\n\t\t\tlb_mode = scl_vop_cal_lb_mode(dst_w, false);\n\t\telse\n\t\t\tlb_mode = scl_vop_cal_lb_mode(src_w, false);\n\t}\n\n\tVOP_SCL_SET_EXT(vop, win, lb_mode, lb_mode);\n\tif (lb_mode == LB_RGB_3840X2) {\n\t\tif (yrgb_ver_scl_mode != SCALE_NONE) {\n\t\t\tDRM_DEV_ERROR(vop->dev, \"not allow yrgb ver scale\\n\");\n\t\t\treturn;\n\t\t}\n\t\tif (cbcr_ver_scl_mode != SCALE_NONE) {\n\t\t\tDRM_DEV_ERROR(vop->dev, \"not allow cbcr ver scale\\n\");\n\t\t\treturn;\n\t\t}\n\t\tvsu_mode = SCALE_UP_BIL;\n\t} else if (lb_mode == LB_RGB_2560X4) {\n\t\tvsu_mode = SCALE_UP_BIL;\n\t} else {\n\t\tvsu_mode = SCALE_UP_BIC;\n\t}\n\n\tval = scl_vop_cal_scale(yrgb_hor_scl_mode, src_w, dst_w,\n\t\t\t\ttrue, 0, NULL);\n\tVOP_SCL_SET(vop, win, scale_yrgb_x, val);\n\tval = scl_vop_cal_scale(yrgb_ver_scl_mode, src_h, dst_h,\n\t\t\t\tfalse, vsu_mode, &vskiplines);\n\tVOP_SCL_SET(vop, win, scale_yrgb_y, val);\n\n\tVOP_SCL_SET_EXT(vop, win, vsd_yrgb_gt4, vskiplines == 4);\n\tVOP_SCL_SET_EXT(vop, win, vsd_yrgb_gt2, vskiplines == 2);\n\n\tVOP_SCL_SET_EXT(vop, win, yrgb_hor_scl_mode, yrgb_hor_scl_mode);\n\tVOP_SCL_SET_EXT(vop, win, yrgb_ver_scl_mode, yrgb_ver_scl_mode);\n\tVOP_SCL_SET_EXT(vop, win, yrgb_hsd_mode, SCALE_DOWN_BIL);\n\tVOP_SCL_SET_EXT(vop, win, yrgb_vsd_mode, SCALE_DOWN_BIL);\n\tVOP_SCL_SET_EXT(vop, win, yrgb_vsu_mode, vsu_mode);\n\tif (is_yuv) {\n\t\tval = scl_vop_cal_scale(cbcr_hor_scl_mode, cbcr_src_w,\n\t\t\t\t\tdst_w, true, 0, NULL);\n\t\tVOP_SCL_SET(vop, win, scale_cbcr_x, val);\n\t\tval = scl_vop_cal_scale(cbcr_ver_scl_mode, cbcr_src_h,\n\t\t\t\t\tdst_h, false, vsu_mode, &vskiplines);\n\t\tVOP_SCL_SET(vop, win, scale_cbcr_y, val);\n\n\t\tVOP_SCL_SET_EXT(vop, win, vsd_cbcr_gt4, vskiplines == 4);\n\t\tVOP_SCL_SET_EXT(vop, win, vsd_cbcr_gt2, vskiplines == 2);\n\t\tVOP_SCL_SET_EXT(vop, win, cbcr_hor_scl_mode, cbcr_hor_scl_mode);\n\t\tVOP_SCL_SET_EXT(vop, win, cbcr_ver_scl_mode, cbcr_ver_scl_mode);\n\t\tVOP_SCL_SET_EXT(vop, win, cbcr_hsd_mode, SCALE_DOWN_BIL);\n\t\tVOP_SCL_SET_EXT(vop, win, cbcr_vsd_mode, SCALE_DOWN_BIL);\n\t\tVOP_SCL_SET_EXT(vop, win, cbcr_vsu_mode, vsu_mode);\n\t}\n}\n\nstatic void vop_dsp_hold_valid_irq_enable(struct vop *vop)\n{\n\tunsigned long flags;\n\n\tif (WARN_ON(!vop->is_enabled))\n\t\treturn;\n\n\tspin_lock_irqsave(&vop->irq_lock, flags);\n\n\tVOP_INTR_SET_TYPE(vop, clear, DSP_HOLD_VALID_INTR, 1);\n\tVOP_INTR_SET_TYPE(vop, enable, DSP_HOLD_VALID_INTR, 1);\n\n\tspin_unlock_irqrestore(&vop->irq_lock, flags);\n}\n\nstatic void vop_dsp_hold_valid_irq_disable(struct vop *vop)\n{\n\tunsigned long flags;\n\n\tif (WARN_ON(!vop->is_enabled))\n\t\treturn;\n\n\tspin_lock_irqsave(&vop->irq_lock, flags);\n\n\tVOP_INTR_SET_TYPE(vop, enable, DSP_HOLD_VALID_INTR, 0);\n\n\tspin_unlock_irqrestore(&vop->irq_lock, flags);\n}\n\n \nstatic bool vop_line_flag_irq_is_enabled(struct vop *vop)\n{\n\tuint32_t line_flag_irq;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&vop->irq_lock, flags);\n\n\tline_flag_irq = VOP_INTR_GET_TYPE(vop, enable, LINE_FLAG_INTR);\n\n\tspin_unlock_irqrestore(&vop->irq_lock, flags);\n\n\treturn !!line_flag_irq;\n}\n\nstatic void vop_line_flag_irq_enable(struct vop *vop)\n{\n\tunsigned long flags;\n\n\tif (WARN_ON(!vop->is_enabled))\n\t\treturn;\n\n\tspin_lock_irqsave(&vop->irq_lock, flags);\n\n\tVOP_INTR_SET_TYPE(vop, clear, LINE_FLAG_INTR, 1);\n\tVOP_INTR_SET_TYPE(vop, enable, LINE_FLAG_INTR, 1);\n\n\tspin_unlock_irqrestore(&vop->irq_lock, flags);\n}\n\nstatic void vop_line_flag_irq_disable(struct vop *vop)\n{\n\tunsigned long flags;\n\n\tif (WARN_ON(!vop->is_enabled))\n\t\treturn;\n\n\tspin_lock_irqsave(&vop->irq_lock, flags);\n\n\tVOP_INTR_SET_TYPE(vop, enable, LINE_FLAG_INTR, 0);\n\n\tspin_unlock_irqrestore(&vop->irq_lock, flags);\n}\n\nstatic int vop_core_clks_enable(struct vop *vop)\n{\n\tint ret;\n\n\tret = clk_enable(vop->hclk);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = clk_enable(vop->aclk);\n\tif (ret < 0)\n\t\tgoto err_disable_hclk;\n\n\treturn 0;\n\nerr_disable_hclk:\n\tclk_disable(vop->hclk);\n\treturn ret;\n}\n\nstatic void vop_core_clks_disable(struct vop *vop)\n{\n\tclk_disable(vop->aclk);\n\tclk_disable(vop->hclk);\n}\n\nstatic void vop_win_disable(struct vop *vop, const struct vop_win *vop_win)\n{\n\tconst struct vop_win_data *win = vop_win->data;\n\n\tif (win->phy->scl && win->phy->scl->ext) {\n\t\tVOP_SCL_SET_EXT(vop, win, yrgb_hor_scl_mode, SCALE_NONE);\n\t\tVOP_SCL_SET_EXT(vop, win, yrgb_ver_scl_mode, SCALE_NONE);\n\t\tVOP_SCL_SET_EXT(vop, win, cbcr_hor_scl_mode, SCALE_NONE);\n\t\tVOP_SCL_SET_EXT(vop, win, cbcr_ver_scl_mode, SCALE_NONE);\n\t}\n\n\tVOP_WIN_SET(vop, win, enable, 0);\n\tvop->win_enabled &= ~BIT(VOP_WIN_TO_INDEX(vop_win));\n}\n\nstatic int vop_enable(struct drm_crtc *crtc, struct drm_crtc_state *old_state)\n{\n\tstruct vop *vop = to_vop(crtc);\n\tint ret, i;\n\n\tret = pm_runtime_resume_and_get(vop->dev);\n\tif (ret < 0) {\n\t\tDRM_DEV_ERROR(vop->dev, \"failed to get pm runtime: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = vop_core_clks_enable(vop);\n\tif (WARN_ON(ret < 0))\n\t\tgoto err_put_pm_runtime;\n\n\tret = clk_enable(vop->dclk);\n\tif (WARN_ON(ret < 0))\n\t\tgoto err_disable_core;\n\n\t \n\tret = rockchip_drm_dma_attach_device(vop->drm_dev, vop->dev);\n\tif (ret) {\n\t\tDRM_DEV_ERROR(vop->dev,\n\t\t\t      \"failed to attach dma mapping, %d\\n\", ret);\n\t\tgoto err_disable_dclk;\n\t}\n\n\tspin_lock(&vop->reg_lock);\n\tfor (i = 0; i < vop->len; i += 4)\n\t\twritel_relaxed(vop->regsbak[i / 4], vop->regs + i);\n\n\t \n\tif (!old_state || !old_state->self_refresh_active) {\n\t\tfor (i = 0; i < vop->data->win_size; i++) {\n\t\t\tstruct vop_win *vop_win = &vop->win[i];\n\n\t\t\tvop_win_disable(vop, vop_win);\n\t\t}\n\t}\n\n\tif (vop->data->afbc) {\n\t\tstruct rockchip_crtc_state *s;\n\t\t \n\t\tVOP_AFBC_SET(vop, enable, 0);\n\t\ts = to_rockchip_crtc_state(crtc->state);\n\t\ts->enable_afbc = false;\n\t}\n\n\tvop_cfg_done(vop);\n\n\tspin_unlock(&vop->reg_lock);\n\n\t \n\tvop->is_enabled = true;\n\n\tspin_lock(&vop->reg_lock);\n\n\tVOP_REG_SET(vop, common, standby, 1);\n\n\tspin_unlock(&vop->reg_lock);\n\n\tdrm_crtc_vblank_on(crtc);\n\n\treturn 0;\n\nerr_disable_dclk:\n\tclk_disable(vop->dclk);\nerr_disable_core:\n\tvop_core_clks_disable(vop);\nerr_put_pm_runtime:\n\tpm_runtime_put_sync(vop->dev);\n\treturn ret;\n}\n\nstatic void rockchip_drm_set_win_enabled(struct drm_crtc *crtc, bool enabled)\n{\n        struct vop *vop = to_vop(crtc);\n        int i;\n\n        spin_lock(&vop->reg_lock);\n\n        for (i = 0; i < vop->data->win_size; i++) {\n                struct vop_win *vop_win = &vop->win[i];\n                const struct vop_win_data *win = vop_win->data;\n\n                VOP_WIN_SET(vop, win, enable,\n                            enabled && (vop->win_enabled & BIT(i)));\n        }\n        vop_cfg_done(vop);\n\n        spin_unlock(&vop->reg_lock);\n}\n\nstatic void vop_crtc_atomic_disable(struct drm_crtc *crtc,\n\t\t\t\t    struct drm_atomic_state *state)\n{\n\tstruct vop *vop = to_vop(crtc);\n\n\tWARN_ON(vop->event);\n\n\tif (crtc->state->self_refresh_active)\n\t\trockchip_drm_set_win_enabled(crtc, false);\n\n\tif (crtc->state->self_refresh_active)\n\t\tgoto out;\n\n\tmutex_lock(&vop->vop_lock);\n\n\tdrm_crtc_vblank_off(crtc);\n\n\t \n\treinit_completion(&vop->dsp_hold_completion);\n\tvop_dsp_hold_valid_irq_enable(vop);\n\n\tspin_lock(&vop->reg_lock);\n\n\tVOP_REG_SET(vop, common, standby, 1);\n\n\tspin_unlock(&vop->reg_lock);\n\n\tif (!wait_for_completion_timeout(&vop->dsp_hold_completion,\n\t\t\t\t\t msecs_to_jiffies(200)))\n\t\tWARN(1, \"%s: timed out waiting for DSP hold\", crtc->name);\n\n\tvop_dsp_hold_valid_irq_disable(vop);\n\n\tvop->is_enabled = false;\n\n\t \n\trockchip_drm_dma_detach_device(vop->drm_dev, vop->dev);\n\n\tclk_disable(vop->dclk);\n\tvop_core_clks_disable(vop);\n\tpm_runtime_put(vop->dev);\n\n\tmutex_unlock(&vop->vop_lock);\n\nout:\n\tif (crtc->state->event && !crtc->state->active) {\n\t\tspin_lock_irq(&crtc->dev->event_lock);\n\t\tdrm_crtc_send_vblank_event(crtc, crtc->state->event);\n\t\tspin_unlock_irq(&crtc->dev->event_lock);\n\n\t\tcrtc->state->event = NULL;\n\t}\n}\n\nstatic void vop_plane_destroy(struct drm_plane *plane)\n{\n\tdrm_plane_cleanup(plane);\n}\n\nstatic inline bool rockchip_afbc(u64 modifier)\n{\n\treturn modifier == ROCKCHIP_AFBC_MOD;\n}\n\nstatic bool rockchip_mod_supported(struct drm_plane *plane,\n\t\t\t\t   u32 format, u64 modifier)\n{\n\tif (modifier == DRM_FORMAT_MOD_LINEAR)\n\t\treturn true;\n\n\tif (!rockchip_afbc(modifier)) {\n\t\tDRM_DEBUG_KMS(\"Unsupported format modifier 0x%llx\\n\", modifier);\n\n\t\treturn false;\n\t}\n\n\treturn vop_convert_afbc_format(format) >= 0;\n}\n\nstatic int vop_plane_atomic_check(struct drm_plane *plane,\n\t\t\t   struct drm_atomic_state *state)\n{\n\tstruct drm_plane_state *new_plane_state = drm_atomic_get_new_plane_state(state,\n\t\t\t\t\t\t\t\t\t\t plane);\n\tstruct drm_crtc *crtc = new_plane_state->crtc;\n\tstruct drm_crtc_state *crtc_state;\n\tstruct drm_framebuffer *fb = new_plane_state->fb;\n\tstruct vop_win *vop_win = to_vop_win(plane);\n\tconst struct vop_win_data *win = vop_win->data;\n\tint ret;\n\tint min_scale = win->phy->scl ? FRAC_16_16(1, 8) :\n\t\t\t\t\tDRM_PLANE_NO_SCALING;\n\tint max_scale = win->phy->scl ? FRAC_16_16(8, 1) :\n\t\t\t\t\tDRM_PLANE_NO_SCALING;\n\n\tif (!crtc || WARN_ON(!fb))\n\t\treturn 0;\n\n\tcrtc_state = drm_atomic_get_existing_crtc_state(state,\n\t\t\t\t\t\t\tcrtc);\n\tif (WARN_ON(!crtc_state))\n\t\treturn -EINVAL;\n\n\tret = drm_atomic_helper_check_plane_state(new_plane_state, crtc_state,\n\t\t\t\t\t\t  min_scale, max_scale,\n\t\t\t\t\t\t  true, true);\n\tif (ret)\n\t\treturn ret;\n\n\tif (!new_plane_state->visible)\n\t\treturn 0;\n\n\tret = vop_convert_format(fb->format->format);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tif (fb->format->is_yuv && ((new_plane_state->src.x1 >> 16) % 2)) {\n\t\tDRM_DEBUG_KMS(\"Invalid Source: Yuv format not support odd xpos\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (fb->format->is_yuv && new_plane_state->rotation & DRM_MODE_REFLECT_Y) {\n\t\tDRM_DEBUG_KMS(\"Invalid Source: Yuv format does not support this rotation\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (rockchip_afbc(fb->modifier)) {\n\t\tstruct vop *vop = to_vop(crtc);\n\n\t\tif (!vop->data->afbc) {\n\t\t\tDRM_DEBUG_KMS(\"vop does not support AFBC\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tret = vop_convert_afbc_format(fb->format->format);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tif (new_plane_state->src.x1 || new_plane_state->src.y1) {\n\t\t\tDRM_DEBUG_KMS(\"AFBC does not support offset display, \" \\\n\t\t\t\t      \"xpos=%d, ypos=%d, offset=%d\\n\",\n\t\t\t\t      new_plane_state->src.x1, new_plane_state->src.y1,\n\t\t\t\t      fb->offsets[0]);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (new_plane_state->rotation && new_plane_state->rotation != DRM_MODE_ROTATE_0) {\n\t\t\tDRM_DEBUG_KMS(\"No rotation support in AFBC, rotation=%d\\n\",\n\t\t\t\t      new_plane_state->rotation);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic void vop_plane_atomic_disable(struct drm_plane *plane,\n\t\t\t\t     struct drm_atomic_state *state)\n{\n\tstruct drm_plane_state *old_state = drm_atomic_get_old_plane_state(state,\n\t\t\t\t\t\t\t\t\t   plane);\n\tstruct vop_win *vop_win = to_vop_win(plane);\n\tstruct vop *vop = to_vop(old_state->crtc);\n\n\tif (!old_state->crtc)\n\t\treturn;\n\n\tspin_lock(&vop->reg_lock);\n\n\tvop_win_disable(vop, vop_win);\n\n\tspin_unlock(&vop->reg_lock);\n}\n\nstatic void vop_plane_atomic_update(struct drm_plane *plane,\n\t\tstruct drm_atomic_state *state)\n{\n\tstruct drm_plane_state *new_state = drm_atomic_get_new_plane_state(state,\n\t\t\t\t\t\t\t\t\t   plane);\n\tstruct drm_crtc *crtc = new_state->crtc;\n\tstruct vop_win *vop_win = to_vop_win(plane);\n\tconst struct vop_win_data *win = vop_win->data;\n\tconst struct vop_win_yuv2yuv_data *win_yuv2yuv = vop_win->yuv2yuv_data;\n\tstruct vop *vop = to_vop(new_state->crtc);\n\tstruct drm_framebuffer *fb = new_state->fb;\n\tunsigned int actual_w, actual_h;\n\tunsigned int dsp_stx, dsp_sty;\n\tuint32_t act_info, dsp_info, dsp_st;\n\tstruct drm_rect *src = &new_state->src;\n\tstruct drm_rect *dest = &new_state->dst;\n\tstruct drm_gem_object *obj, *uv_obj;\n\tstruct rockchip_gem_object *rk_obj, *rk_uv_obj;\n\tunsigned long offset;\n\tdma_addr_t dma_addr;\n\tuint32_t val;\n\tbool rb_swap, uv_swap;\n\tint win_index = VOP_WIN_TO_INDEX(vop_win);\n\tint format;\n\tint is_yuv = fb->format->is_yuv;\n\tint i;\n\n\t \n\tif (WARN_ON(!crtc))\n\t\treturn;\n\n\tif (WARN_ON(!vop->is_enabled))\n\t\treturn;\n\n\tif (!new_state->visible) {\n\t\tvop_plane_atomic_disable(plane, state);\n\t\treturn;\n\t}\n\n\tobj = fb->obj[0];\n\trk_obj = to_rockchip_obj(obj);\n\n\tactual_w = drm_rect_width(src) >> 16;\n\tactual_h = drm_rect_height(src) >> 16;\n\tact_info = (actual_h - 1) << 16 | ((actual_w - 1) & 0xffff);\n\n\tdsp_info = (drm_rect_height(dest) - 1) << 16;\n\tdsp_info |= (drm_rect_width(dest) - 1) & 0xffff;\n\n\tdsp_stx = dest->x1 + crtc->mode.htotal - crtc->mode.hsync_start;\n\tdsp_sty = dest->y1 + crtc->mode.vtotal - crtc->mode.vsync_start;\n\tdsp_st = dsp_sty << 16 | (dsp_stx & 0xffff);\n\n\toffset = (src->x1 >> 16) * fb->format->cpp[0];\n\toffset += (src->y1 >> 16) * fb->pitches[0];\n\tdma_addr = rk_obj->dma_addr + offset + fb->offsets[0];\n\n\t \n\tif (new_state->rotation & DRM_MODE_REFLECT_Y)\n\t\tdma_addr += (actual_h - 1) * fb->pitches[0];\n\n\tformat = vop_convert_format(fb->format->format);\n\n\tspin_lock(&vop->reg_lock);\n\n\tif (rockchip_afbc(fb->modifier)) {\n\t\tint afbc_format = vop_convert_afbc_format(fb->format->format);\n\n\t\tVOP_AFBC_SET(vop, format, afbc_format | AFBC_TILE_16x16);\n\t\tVOP_AFBC_SET(vop, hreg_block_split, 0);\n\t\tVOP_AFBC_SET(vop, win_sel, VOP_WIN_TO_INDEX(vop_win));\n\t\tVOP_AFBC_SET(vop, hdr_ptr, dma_addr);\n\t\tVOP_AFBC_SET(vop, pic_size, act_info);\n\t}\n\n\tVOP_WIN_SET(vop, win, format, format);\n\tVOP_WIN_SET(vop, win, yrgb_vir, DIV_ROUND_UP(fb->pitches[0], 4));\n\tVOP_WIN_SET(vop, win, yrgb_mst, dma_addr);\n\tVOP_WIN_YUV2YUV_SET(vop, win_yuv2yuv, y2r_en, is_yuv);\n\tVOP_WIN_SET(vop, win, y_mir_en,\n\t\t    (new_state->rotation & DRM_MODE_REFLECT_Y) ? 1 : 0);\n\tVOP_WIN_SET(vop, win, x_mir_en,\n\t\t    (new_state->rotation & DRM_MODE_REFLECT_X) ? 1 : 0);\n\n\tif (is_yuv) {\n\t\tint hsub = fb->format->hsub;\n\t\tint vsub = fb->format->vsub;\n\t\tint bpp = fb->format->cpp[1];\n\n\t\tuv_obj = fb->obj[1];\n\t\trk_uv_obj = to_rockchip_obj(uv_obj);\n\n\t\toffset = (src->x1 >> 16) * bpp / hsub;\n\t\toffset += (src->y1 >> 16) * fb->pitches[1] / vsub;\n\n\t\tdma_addr = rk_uv_obj->dma_addr + offset + fb->offsets[1];\n\t\tVOP_WIN_SET(vop, win, uv_vir, DIV_ROUND_UP(fb->pitches[1], 4));\n\t\tVOP_WIN_SET(vop, win, uv_mst, dma_addr);\n\n\t\tfor (i = 0; i < NUM_YUV2YUV_COEFFICIENTS; i++) {\n\t\t\tVOP_WIN_YUV2YUV_COEFFICIENT_SET(vop,\n\t\t\t\t\t\t\twin_yuv2yuv,\n\t\t\t\t\t\t\ty2r_coefficients[i],\n\t\t\t\t\t\t\tbt601_yuv2rgb[i]);\n\t\t}\n\n\t\tuv_swap = has_uv_swapped(fb->format->format);\n\t\tVOP_WIN_SET(vop, win, uv_swap, uv_swap);\n\t}\n\n\tif (win->phy->scl)\n\t\tscl_vop_cal_scl_fac(vop, win, actual_w, actual_h,\n\t\t\t\t    drm_rect_width(dest), drm_rect_height(dest),\n\t\t\t\t    fb->format);\n\n\tVOP_WIN_SET(vop, win, act_info, act_info);\n\tVOP_WIN_SET(vop, win, dsp_info, dsp_info);\n\tVOP_WIN_SET(vop, win, dsp_st, dsp_st);\n\n\trb_swap = has_rb_swapped(vop->data->version, fb->format->format);\n\tVOP_WIN_SET(vop, win, rb_swap, rb_swap);\n\n\t \n\tif (fb->format->has_alpha && win_index > 0) {\n\t\tVOP_WIN_SET(vop, win, dst_alpha_ctl,\n\t\t\t    DST_FACTOR_M0(ALPHA_SRC_INVERSE));\n\t\tval = SRC_ALPHA_EN(1) | SRC_COLOR_M0(ALPHA_SRC_PRE_MUL) |\n\t\t\tSRC_ALPHA_M0(ALPHA_STRAIGHT) |\n\t\t\tSRC_BLEND_M0(ALPHA_PER_PIX) |\n\t\t\tSRC_ALPHA_CAL_M0(ALPHA_NO_SATURATION) |\n\t\t\tSRC_FACTOR_M0(ALPHA_ONE);\n\t\tVOP_WIN_SET(vop, win, src_alpha_ctl, val);\n\n\t\tVOP_WIN_SET(vop, win, alpha_pre_mul, ALPHA_SRC_PRE_MUL);\n\t\tVOP_WIN_SET(vop, win, alpha_mode, ALPHA_PER_PIX);\n\t\tVOP_WIN_SET(vop, win, alpha_en, 1);\n\t} else {\n\t\tVOP_WIN_SET(vop, win, src_alpha_ctl, SRC_ALPHA_EN(0));\n\t\tVOP_WIN_SET(vop, win, alpha_en, 0);\n\t}\n\n\tVOP_WIN_SET(vop, win, enable, 1);\n\tvop->win_enabled |= BIT(win_index);\n\tspin_unlock(&vop->reg_lock);\n}\n\nstatic int vop_plane_atomic_async_check(struct drm_plane *plane,\n\t\t\t\t\tstruct drm_atomic_state *state)\n{\n\tstruct drm_plane_state *new_plane_state = drm_atomic_get_new_plane_state(state,\n\t\t\t\t\t\t\t\t\t\t plane);\n\tstruct vop_win *vop_win = to_vop_win(plane);\n\tconst struct vop_win_data *win = vop_win->data;\n\tint min_scale = win->phy->scl ? FRAC_16_16(1, 8) :\n\t\t\t\t\tDRM_PLANE_NO_SCALING;\n\tint max_scale = win->phy->scl ? FRAC_16_16(8, 1) :\n\t\t\t\t\tDRM_PLANE_NO_SCALING;\n\tstruct drm_crtc_state *crtc_state;\n\n\tif (plane != new_plane_state->crtc->cursor)\n\t\treturn -EINVAL;\n\n\tif (!plane->state)\n\t\treturn -EINVAL;\n\n\tif (!plane->state->fb)\n\t\treturn -EINVAL;\n\n\tif (state)\n\t\tcrtc_state = drm_atomic_get_existing_crtc_state(state,\n\t\t\t\t\t\t\t\tnew_plane_state->crtc);\n\telse  \n\t\tcrtc_state = plane->crtc->state;\n\n\treturn drm_atomic_helper_check_plane_state(plane->state, crtc_state,\n\t\t\t\t\t\t   min_scale, max_scale,\n\t\t\t\t\t\t   true, true);\n}\n\nstatic void vop_plane_atomic_async_update(struct drm_plane *plane,\n\t\t\t\t\t  struct drm_atomic_state *state)\n{\n\tstruct drm_plane_state *new_state = drm_atomic_get_new_plane_state(state,\n\t\t\t\t\t\t\t\t\t   plane);\n\tstruct vop *vop = to_vop(plane->state->crtc);\n\tstruct drm_framebuffer *old_fb = plane->state->fb;\n\n\tplane->state->crtc_x = new_state->crtc_x;\n\tplane->state->crtc_y = new_state->crtc_y;\n\tplane->state->crtc_h = new_state->crtc_h;\n\tplane->state->crtc_w = new_state->crtc_w;\n\tplane->state->src_x = new_state->src_x;\n\tplane->state->src_y = new_state->src_y;\n\tplane->state->src_h = new_state->src_h;\n\tplane->state->src_w = new_state->src_w;\n\tswap(plane->state->fb, new_state->fb);\n\n\tif (vop->is_enabled) {\n\t\tvop_plane_atomic_update(plane, state);\n\t\tspin_lock(&vop->reg_lock);\n\t\tvop_cfg_done(vop);\n\t\tspin_unlock(&vop->reg_lock);\n\n\t\t \n\t\tif (old_fb && plane->state->fb != old_fb) {\n\t\t\tdrm_framebuffer_get(old_fb);\n\t\t\tWARN_ON(drm_crtc_vblank_get(plane->state->crtc) != 0);\n\t\t\tdrm_flip_work_queue(&vop->fb_unref_work, old_fb);\n\t\t\tset_bit(VOP_PENDING_FB_UNREF, &vop->pending);\n\t\t}\n\t}\n}\n\nstatic const struct drm_plane_helper_funcs plane_helper_funcs = {\n\t.atomic_check = vop_plane_atomic_check,\n\t.atomic_update = vop_plane_atomic_update,\n\t.atomic_disable = vop_plane_atomic_disable,\n\t.atomic_async_check = vop_plane_atomic_async_check,\n\t.atomic_async_update = vop_plane_atomic_async_update,\n};\n\nstatic const struct drm_plane_funcs vop_plane_funcs = {\n\t.update_plane\t= drm_atomic_helper_update_plane,\n\t.disable_plane\t= drm_atomic_helper_disable_plane,\n\t.destroy = vop_plane_destroy,\n\t.reset = drm_atomic_helper_plane_reset,\n\t.atomic_duplicate_state = drm_atomic_helper_plane_duplicate_state,\n\t.atomic_destroy_state = drm_atomic_helper_plane_destroy_state,\n\t.format_mod_supported = rockchip_mod_supported,\n};\n\nstatic int vop_crtc_enable_vblank(struct drm_crtc *crtc)\n{\n\tstruct vop *vop = to_vop(crtc);\n\tunsigned long flags;\n\n\tif (WARN_ON(!vop->is_enabled))\n\t\treturn -EPERM;\n\n\tspin_lock_irqsave(&vop->irq_lock, flags);\n\n\tVOP_INTR_SET_TYPE(vop, clear, FS_INTR, 1);\n\tVOP_INTR_SET_TYPE(vop, enable, FS_INTR, 1);\n\n\tspin_unlock_irqrestore(&vop->irq_lock, flags);\n\n\treturn 0;\n}\n\nstatic void vop_crtc_disable_vblank(struct drm_crtc *crtc)\n{\n\tstruct vop *vop = to_vop(crtc);\n\tunsigned long flags;\n\n\tif (WARN_ON(!vop->is_enabled))\n\t\treturn;\n\n\tspin_lock_irqsave(&vop->irq_lock, flags);\n\n\tVOP_INTR_SET_TYPE(vop, enable, FS_INTR, 0);\n\n\tspin_unlock_irqrestore(&vop->irq_lock, flags);\n}\n\nstatic enum drm_mode_status vop_crtc_mode_valid(struct drm_crtc *crtc,\n\t\t\t\t\t\tconst struct drm_display_mode *mode)\n{\n\tstruct vop *vop = to_vop(crtc);\n\n\tif (vop->data->max_output.width && mode->hdisplay > vop->data->max_output.width)\n\t\treturn MODE_BAD_HVALUE;\n\n\treturn MODE_OK;\n}\n\nstatic bool vop_crtc_mode_fixup(struct drm_crtc *crtc,\n\t\t\t\tconst struct drm_display_mode *mode,\n\t\t\t\tstruct drm_display_mode *adjusted_mode)\n{\n\tstruct vop *vop = to_vop(crtc);\n\tunsigned long rate;\n\n\t \n\trate = clk_round_rate(vop->dclk, adjusted_mode->clock * 1000);\n\tif (rate / 1000 != adjusted_mode->clock)\n\t\trate = clk_round_rate(vop->dclk,\n\t\t\t\t      adjusted_mode->clock * 1000 + 999);\n\tadjusted_mode->clock = DIV_ROUND_UP(rate, 1000);\n\n\treturn true;\n}\n\nstatic bool vop_dsp_lut_is_enabled(struct vop *vop)\n{\n\treturn vop_read_reg(vop, 0, &vop->data->common->dsp_lut_en);\n}\n\nstatic u32 vop_lut_buffer_index(struct vop *vop)\n{\n\treturn vop_read_reg(vop, 0, &vop->data->common->lut_buffer_index);\n}\n\nstatic void vop_crtc_write_gamma_lut(struct vop *vop, struct drm_crtc *crtc)\n{\n\tstruct drm_color_lut *lut = crtc->state->gamma_lut->data;\n\tunsigned int i, bpc = ilog2(vop->data->lut_size);\n\n\tfor (i = 0; i < crtc->gamma_size; i++) {\n\t\tu32 word;\n\n\t\tword = (drm_color_lut_extract(lut[i].red, bpc) << (2 * bpc)) |\n\t\t       (drm_color_lut_extract(lut[i].green, bpc) << bpc) |\n\t\t\tdrm_color_lut_extract(lut[i].blue, bpc);\n\t\twritel(word, vop->lut_regs + i * 4);\n\t}\n}\n\nstatic void vop_crtc_gamma_set(struct vop *vop, struct drm_crtc *crtc,\n\t\t\t       struct drm_crtc_state *old_state)\n{\n\tstruct drm_crtc_state *state = crtc->state;\n\tunsigned int idle;\n\tu32 lut_idx, old_idx;\n\tint ret;\n\n\tif (!vop->lut_regs)\n\t\treturn;\n\n\tif (!state->gamma_lut || !VOP_HAS_REG(vop, common, update_gamma_lut)) {\n\t\t \n\t\tspin_lock(&vop->reg_lock);\n\t\tVOP_REG_SET(vop, common, dsp_lut_en, 0);\n\t\tvop_cfg_done(vop);\n\t\tspin_unlock(&vop->reg_lock);\n\n\t\t \n\t\tret = readx_poll_timeout(vop_dsp_lut_is_enabled, vop,\n\t\t\t\t\t idle, !idle, 5, 30 * 1000);\n\t\tif (ret) {\n\t\t\tDRM_DEV_ERROR(vop->dev, \"display LUT RAM enable timeout!\\n\");\n\t\t\treturn;\n\t\t}\n\n\t\tif (!state->gamma_lut)\n\t\t\treturn;\n\t} else {\n\t\t \n\t\told_idx = vop_lut_buffer_index(vop);\n\t}\n\n\tspin_lock(&vop->reg_lock);\n\tvop_crtc_write_gamma_lut(vop, crtc);\n\tVOP_REG_SET(vop, common, dsp_lut_en, 1);\n\tVOP_REG_SET(vop, common, update_gamma_lut, 1);\n\tvop_cfg_done(vop);\n\tspin_unlock(&vop->reg_lock);\n\n\tif (VOP_HAS_REG(vop, common, update_gamma_lut)) {\n\t\tret = readx_poll_timeout(vop_lut_buffer_index, vop,\n\t\t\t\t\t lut_idx, lut_idx != old_idx, 5, 30 * 1000);\n\t\tif (ret) {\n\t\t\tDRM_DEV_ERROR(vop->dev, \"gamma LUT update timeout!\\n\");\n\t\t\treturn;\n\t\t}\n\n\t\t \n\t\tspin_lock(&vop->reg_lock);\n\t\tVOP_REG_SET(vop, common, update_gamma_lut, 0);\n\t\tspin_unlock(&vop->reg_lock);\n\t}\n}\n\nstatic void vop_crtc_atomic_begin(struct drm_crtc *crtc,\n\t\t\t\t  struct drm_atomic_state *state)\n{\n\tstruct drm_crtc_state *crtc_state = drm_atomic_get_new_crtc_state(state,\n\t\t\t\t\t\t\t\t\t  crtc);\n\tstruct drm_crtc_state *old_crtc_state = drm_atomic_get_old_crtc_state(state,\n\t\t\t\t\t\t\t\t\t      crtc);\n\tstruct vop *vop = to_vop(crtc);\n\n\t \n\tif (crtc_state->color_mgmt_changed &&\n\t    !crtc_state->active_changed)\n\t\tvop_crtc_gamma_set(vop, crtc, old_crtc_state);\n}\n\nstatic void vop_crtc_atomic_enable(struct drm_crtc *crtc,\n\t\t\t\t   struct drm_atomic_state *state)\n{\n\tstruct drm_crtc_state *old_state = drm_atomic_get_old_crtc_state(state,\n\t\t\t\t\t\t\t\t\t crtc);\n\tstruct vop *vop = to_vop(crtc);\n\tconst struct vop_data *vop_data = vop->data;\n\tstruct rockchip_crtc_state *s = to_rockchip_crtc_state(crtc->state);\n\tstruct drm_display_mode *adjusted_mode = &crtc->state->adjusted_mode;\n\tu16 hsync_len = adjusted_mode->hsync_end - adjusted_mode->hsync_start;\n\tu16 hdisplay = adjusted_mode->hdisplay;\n\tu16 htotal = adjusted_mode->htotal;\n\tu16 hact_st = adjusted_mode->htotal - adjusted_mode->hsync_start;\n\tu16 hact_end = hact_st + hdisplay;\n\tu16 vdisplay = adjusted_mode->vdisplay;\n\tu16 vtotal = adjusted_mode->vtotal;\n\tu16 vsync_len = adjusted_mode->vsync_end - adjusted_mode->vsync_start;\n\tu16 vact_st = adjusted_mode->vtotal - adjusted_mode->vsync_start;\n\tu16 vact_end = vact_st + vdisplay;\n\tuint32_t pin_pol, val;\n\tint dither_bpc = s->output_bpc ? s->output_bpc : 10;\n\tint ret;\n\n\tif (old_state && old_state->self_refresh_active) {\n\t\tdrm_crtc_vblank_on(crtc);\n\t\trockchip_drm_set_win_enabled(crtc, true);\n\t\treturn;\n\t}\n\n\tmutex_lock(&vop->vop_lock);\n\n\tWARN_ON(vop->event);\n\n\tret = vop_enable(crtc, old_state);\n\tif (ret) {\n\t\tmutex_unlock(&vop->vop_lock);\n\t\tDRM_DEV_ERROR(vop->dev, \"Failed to enable vop (%d)\\n\", ret);\n\t\treturn;\n\t}\n\tpin_pol = (adjusted_mode->flags & DRM_MODE_FLAG_PHSYNC) ?\n\t\t   BIT(HSYNC_POSITIVE) : 0;\n\tpin_pol |= (adjusted_mode->flags & DRM_MODE_FLAG_PVSYNC) ?\n\t\t   BIT(VSYNC_POSITIVE) : 0;\n\tVOP_REG_SET(vop, output, pin_pol, pin_pol);\n\tVOP_REG_SET(vop, output, mipi_dual_channel_en, 0);\n\n\tswitch (s->output_type) {\n\tcase DRM_MODE_CONNECTOR_LVDS:\n\t\tVOP_REG_SET(vop, output, rgb_dclk_pol, 1);\n\t\tVOP_REG_SET(vop, output, rgb_pin_pol, pin_pol);\n\t\tVOP_REG_SET(vop, output, rgb_en, 1);\n\t\tbreak;\n\tcase DRM_MODE_CONNECTOR_eDP:\n\t\tVOP_REG_SET(vop, output, edp_dclk_pol, 1);\n\t\tVOP_REG_SET(vop, output, edp_pin_pol, pin_pol);\n\t\tVOP_REG_SET(vop, output, edp_en, 1);\n\t\tbreak;\n\tcase DRM_MODE_CONNECTOR_HDMIA:\n\t\tVOP_REG_SET(vop, output, hdmi_dclk_pol, 1);\n\t\tVOP_REG_SET(vop, output, hdmi_pin_pol, pin_pol);\n\t\tVOP_REG_SET(vop, output, hdmi_en, 1);\n\t\tbreak;\n\tcase DRM_MODE_CONNECTOR_DSI:\n\t\tVOP_REG_SET(vop, output, mipi_dclk_pol, 1);\n\t\tVOP_REG_SET(vop, output, mipi_pin_pol, pin_pol);\n\t\tVOP_REG_SET(vop, output, mipi_en, 1);\n\t\tVOP_REG_SET(vop, output, mipi_dual_channel_en,\n\t\t\t    !!(s->output_flags & ROCKCHIP_OUTPUT_DSI_DUAL));\n\t\tbreak;\n\tcase DRM_MODE_CONNECTOR_DisplayPort:\n\t\tVOP_REG_SET(vop, output, dp_dclk_pol, 0);\n\t\tVOP_REG_SET(vop, output, dp_pin_pol, pin_pol);\n\t\tVOP_REG_SET(vop, output, dp_en, 1);\n\t\tbreak;\n\tdefault:\n\t\tDRM_DEV_ERROR(vop->dev, \"unsupported connector_type [%d]\\n\",\n\t\t\t      s->output_type);\n\t}\n\n\t \n\tif (s->output_mode == ROCKCHIP_OUT_MODE_AAAA &&\n\t    !(vop_data->feature & VOP_FEATURE_OUTPUT_RGB10))\n\t\ts->output_mode = ROCKCHIP_OUT_MODE_P888;\n\n\tif (s->output_mode == ROCKCHIP_OUT_MODE_AAAA && dither_bpc <= 8)\n\t\tVOP_REG_SET(vop, common, pre_dither_down, 1);\n\telse\n\t\tVOP_REG_SET(vop, common, pre_dither_down, 0);\n\n\tif (dither_bpc == 6) {\n\t\tVOP_REG_SET(vop, common, dither_down_sel, DITHER_DOWN_ALLEGRO);\n\t\tVOP_REG_SET(vop, common, dither_down_mode, RGB888_TO_RGB666);\n\t\tVOP_REG_SET(vop, common, dither_down_en, 1);\n\t} else {\n\t\tVOP_REG_SET(vop, common, dither_down_en, 0);\n\t}\n\n\tVOP_REG_SET(vop, common, out_mode, s->output_mode);\n\n\tVOP_REG_SET(vop, modeset, htotal_pw, (htotal << 16) | hsync_len);\n\tval = hact_st << 16;\n\tval |= hact_end;\n\tVOP_REG_SET(vop, modeset, hact_st_end, val);\n\tVOP_REG_SET(vop, modeset, hpost_st_end, val);\n\n\tVOP_REG_SET(vop, modeset, vtotal_pw, (vtotal << 16) | vsync_len);\n\tval = vact_st << 16;\n\tval |= vact_end;\n\tVOP_REG_SET(vop, modeset, vact_st_end, val);\n\tVOP_REG_SET(vop, modeset, vpost_st_end, val);\n\n\tVOP_REG_SET(vop, intr, line_flag_num[0], vact_end);\n\n\tclk_set_rate(vop->dclk, adjusted_mode->clock * 1000);\n\n\tVOP_REG_SET(vop, common, standby, 0);\n\tmutex_unlock(&vop->vop_lock);\n\n\t \n\tif (crtc->state->gamma_lut)\n\t\tvop_crtc_gamma_set(vop, crtc, old_state);\n}\n\nstatic bool vop_fs_irq_is_pending(struct vop *vop)\n{\n\treturn VOP_INTR_GET_TYPE(vop, status, FS_INTR);\n}\n\nstatic void vop_wait_for_irq_handler(struct vop *vop)\n{\n\tbool pending;\n\tint ret;\n\n\t \n\tret = readx_poll_timeout_atomic(vop_fs_irq_is_pending, vop, pending,\n\t\t\t\t\t!pending, 0, 10 * 1000);\n\tif (ret)\n\t\tDRM_DEV_ERROR(vop->dev, \"VOP vblank IRQ stuck for 10 ms\\n\");\n\n\tsynchronize_irq(vop->irq);\n}\n\nstatic int vop_crtc_atomic_check(struct drm_crtc *crtc,\n\t\t\t\t struct drm_atomic_state *state)\n{\n\tstruct drm_crtc_state *crtc_state = drm_atomic_get_new_crtc_state(state,\n\t\t\t\t\t\t\t\t\t  crtc);\n\tstruct vop *vop = to_vop(crtc);\n\tstruct drm_plane *plane;\n\tstruct drm_plane_state *plane_state;\n\tstruct rockchip_crtc_state *s;\n\tint afbc_planes = 0;\n\n\tif (vop->lut_regs && crtc_state->color_mgmt_changed &&\n\t    crtc_state->gamma_lut) {\n\t\tunsigned int len;\n\n\t\tlen = drm_color_lut_size(crtc_state->gamma_lut);\n\t\tif (len != crtc->gamma_size) {\n\t\t\tDRM_DEBUG_KMS(\"Invalid LUT size; got %d, expected %d\\n\",\n\t\t\t\t      len, crtc->gamma_size);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tdrm_atomic_crtc_state_for_each_plane(plane, crtc_state) {\n\t\tplane_state =\n\t\t\tdrm_atomic_get_plane_state(crtc_state->state, plane);\n\t\tif (IS_ERR(plane_state)) {\n\t\t\tDRM_DEBUG_KMS(\"Cannot get plane state for plane %s\\n\",\n\t\t\t\t      plane->name);\n\t\t\treturn PTR_ERR(plane_state);\n\t\t}\n\n\t\tif (drm_is_afbc(plane_state->fb->modifier))\n\t\t\t++afbc_planes;\n\t}\n\n\tif (afbc_planes > 1) {\n\t\tDRM_DEBUG_KMS(\"Invalid number of AFBC planes; got %d, expected at most 1\\n\", afbc_planes);\n\t\treturn -EINVAL;\n\t}\n\n\ts = to_rockchip_crtc_state(crtc_state);\n\ts->enable_afbc = afbc_planes > 0;\n\n\treturn 0;\n}\n\nstatic void vop_crtc_atomic_flush(struct drm_crtc *crtc,\n\t\t\t\t  struct drm_atomic_state *state)\n{\n\tstruct drm_crtc_state *old_crtc_state = drm_atomic_get_old_crtc_state(state,\n\t\t\t\t\t\t\t\t\t      crtc);\n\tstruct drm_atomic_state *old_state = old_crtc_state->state;\n\tstruct drm_plane_state *old_plane_state, *new_plane_state;\n\tstruct vop *vop = to_vop(crtc);\n\tstruct drm_plane *plane;\n\tstruct rockchip_crtc_state *s;\n\tint i;\n\n\tif (WARN_ON(!vop->is_enabled))\n\t\treturn;\n\n\tspin_lock(&vop->reg_lock);\n\n\t \n\ts = to_rockchip_crtc_state(crtc->state);\n\tVOP_AFBC_SET(vop, enable, s->enable_afbc);\n\tvop_cfg_done(vop);\n\n\tspin_unlock(&vop->reg_lock);\n\n\t \n\tvop_wait_for_irq_handler(vop);\n\n\tspin_lock_irq(&crtc->dev->event_lock);\n\tif (crtc->state->event) {\n\t\tWARN_ON(drm_crtc_vblank_get(crtc) != 0);\n\t\tWARN_ON(vop->event);\n\n\t\tvop->event = crtc->state->event;\n\t\tcrtc->state->event = NULL;\n\t}\n\tspin_unlock_irq(&crtc->dev->event_lock);\n\n\tfor_each_oldnew_plane_in_state(old_state, plane, old_plane_state,\n\t\t\t\t       new_plane_state, i) {\n\t\tif (!old_plane_state->fb)\n\t\t\tcontinue;\n\n\t\tif (old_plane_state->fb == new_plane_state->fb)\n\t\t\tcontinue;\n\n\t\tdrm_framebuffer_get(old_plane_state->fb);\n\t\tWARN_ON(drm_crtc_vblank_get(crtc) != 0);\n\t\tdrm_flip_work_queue(&vop->fb_unref_work, old_plane_state->fb);\n\t\tset_bit(VOP_PENDING_FB_UNREF, &vop->pending);\n\t}\n}\n\nstatic const struct drm_crtc_helper_funcs vop_crtc_helper_funcs = {\n\t.mode_valid = vop_crtc_mode_valid,\n\t.mode_fixup = vop_crtc_mode_fixup,\n\t.atomic_check = vop_crtc_atomic_check,\n\t.atomic_begin = vop_crtc_atomic_begin,\n\t.atomic_flush = vop_crtc_atomic_flush,\n\t.atomic_enable = vop_crtc_atomic_enable,\n\t.atomic_disable = vop_crtc_atomic_disable,\n};\n\nstatic void vop_crtc_destroy(struct drm_crtc *crtc)\n{\n\tdrm_crtc_cleanup(crtc);\n}\n\nstatic struct drm_crtc_state *vop_crtc_duplicate_state(struct drm_crtc *crtc)\n{\n\tstruct rockchip_crtc_state *rockchip_state;\n\n\tif (WARN_ON(!crtc->state))\n\t\treturn NULL;\n\n\trockchip_state = kmemdup(to_rockchip_crtc_state(crtc->state),\n\t\t\t\t sizeof(*rockchip_state), GFP_KERNEL);\n\tif (!rockchip_state)\n\t\treturn NULL;\n\n\t__drm_atomic_helper_crtc_duplicate_state(crtc, &rockchip_state->base);\n\treturn &rockchip_state->base;\n}\n\nstatic void vop_crtc_destroy_state(struct drm_crtc *crtc,\n\t\t\t\t   struct drm_crtc_state *state)\n{\n\tstruct rockchip_crtc_state *s = to_rockchip_crtc_state(state);\n\n\t__drm_atomic_helper_crtc_destroy_state(&s->base);\n\tkfree(s);\n}\n\nstatic void vop_crtc_reset(struct drm_crtc *crtc)\n{\n\tstruct rockchip_crtc_state *crtc_state =\n\t\tkzalloc(sizeof(*crtc_state), GFP_KERNEL);\n\n\tif (crtc->state)\n\t\tvop_crtc_destroy_state(crtc, crtc->state);\n\n\tif (crtc_state)\n\t\t__drm_atomic_helper_crtc_reset(crtc, &crtc_state->base);\n\telse\n\t\t__drm_atomic_helper_crtc_reset(crtc, NULL);\n}\n\n#ifdef CONFIG_DRM_ANALOGIX_DP\nstatic struct drm_connector *vop_get_edp_connector(struct vop *vop)\n{\n\tstruct drm_connector *connector;\n\tstruct drm_connector_list_iter conn_iter;\n\n\tdrm_connector_list_iter_begin(vop->drm_dev, &conn_iter);\n\tdrm_for_each_connector_iter(connector, &conn_iter) {\n\t\tif (connector->connector_type == DRM_MODE_CONNECTOR_eDP) {\n\t\t\tdrm_connector_list_iter_end(&conn_iter);\n\t\t\treturn connector;\n\t\t}\n\t}\n\tdrm_connector_list_iter_end(&conn_iter);\n\n\treturn NULL;\n}\n\nstatic int vop_crtc_set_crc_source(struct drm_crtc *crtc,\n\t\t\t\t   const char *source_name)\n{\n\tstruct vop *vop = to_vop(crtc);\n\tstruct drm_connector *connector;\n\tint ret;\n\n\tconnector = vop_get_edp_connector(vop);\n\tif (!connector)\n\t\treturn -EINVAL;\n\n\tif (source_name && strcmp(source_name, \"auto\") == 0)\n\t\tret = analogix_dp_start_crc(connector);\n\telse if (!source_name)\n\t\tret = analogix_dp_stop_crc(connector);\n\telse\n\t\tret = -EINVAL;\n\n\treturn ret;\n}\n\nstatic int\nvop_crtc_verify_crc_source(struct drm_crtc *crtc, const char *source_name,\n\t\t\t   size_t *values_cnt)\n{\n\tif (source_name && strcmp(source_name, \"auto\") != 0)\n\t\treturn -EINVAL;\n\n\t*values_cnt = 3;\n\treturn 0;\n}\n\n#else\nstatic int vop_crtc_set_crc_source(struct drm_crtc *crtc,\n\t\t\t\t   const char *source_name)\n{\n\treturn -ENODEV;\n}\n\nstatic int\nvop_crtc_verify_crc_source(struct drm_crtc *crtc, const char *source_name,\n\t\t\t   size_t *values_cnt)\n{\n\treturn -ENODEV;\n}\n#endif\n\nstatic const struct drm_crtc_funcs vop_crtc_funcs = {\n\t.set_config = drm_atomic_helper_set_config,\n\t.page_flip = drm_atomic_helper_page_flip,\n\t.destroy = vop_crtc_destroy,\n\t.reset = vop_crtc_reset,\n\t.atomic_duplicate_state = vop_crtc_duplicate_state,\n\t.atomic_destroy_state = vop_crtc_destroy_state,\n\t.enable_vblank = vop_crtc_enable_vblank,\n\t.disable_vblank = vop_crtc_disable_vblank,\n\t.set_crc_source = vop_crtc_set_crc_source,\n\t.verify_crc_source = vop_crtc_verify_crc_source,\n};\n\nstatic void vop_fb_unref_worker(struct drm_flip_work *work, void *val)\n{\n\tstruct vop *vop = container_of(work, struct vop, fb_unref_work);\n\tstruct drm_framebuffer *fb = val;\n\n\tdrm_crtc_vblank_put(&vop->crtc);\n\tdrm_framebuffer_put(fb);\n}\n\nstatic void vop_handle_vblank(struct vop *vop)\n{\n\tstruct drm_device *drm = vop->drm_dev;\n\tstruct drm_crtc *crtc = &vop->crtc;\n\n\tspin_lock(&drm->event_lock);\n\tif (vop->event) {\n\t\tdrm_crtc_send_vblank_event(crtc, vop->event);\n\t\tdrm_crtc_vblank_put(crtc);\n\t\tvop->event = NULL;\n\t}\n\tspin_unlock(&drm->event_lock);\n\n\tif (test_and_clear_bit(VOP_PENDING_FB_UNREF, &vop->pending))\n\t\tdrm_flip_work_commit(&vop->fb_unref_work, system_unbound_wq);\n}\n\nstatic irqreturn_t vop_isr(int irq, void *data)\n{\n\tstruct vop *vop = data;\n\tstruct drm_crtc *crtc = &vop->crtc;\n\tuint32_t active_irqs;\n\tint ret = IRQ_NONE;\n\n\t \n\tif (!pm_runtime_get_if_in_use(vop->dev))\n\t\treturn IRQ_NONE;\n\n\tif (vop_core_clks_enable(vop)) {\n\t\tDRM_DEV_ERROR_RATELIMITED(vop->dev, \"couldn't enable clocks\\n\");\n\t\tgoto out;\n\t}\n\n\t \n\tspin_lock(&vop->irq_lock);\n\n\tactive_irqs = VOP_INTR_GET_TYPE(vop, status, INTR_MASK);\n\t \n\tif (active_irqs)\n\t\tVOP_INTR_SET_TYPE(vop, clear, active_irqs, 1);\n\n\tspin_unlock(&vop->irq_lock);\n\n\t \n\tif (!active_irqs)\n\t\tgoto out_disable;\n\n\tif (active_irqs & DSP_HOLD_VALID_INTR) {\n\t\tcomplete(&vop->dsp_hold_completion);\n\t\tactive_irqs &= ~DSP_HOLD_VALID_INTR;\n\t\tret = IRQ_HANDLED;\n\t}\n\n\tif (active_irqs & LINE_FLAG_INTR) {\n\t\tcomplete(&vop->line_flag_completion);\n\t\tactive_irqs &= ~LINE_FLAG_INTR;\n\t\tret = IRQ_HANDLED;\n\t}\n\n\tif (active_irqs & FS_INTR) {\n\t\tdrm_crtc_handle_vblank(crtc);\n\t\tvop_handle_vblank(vop);\n\t\tactive_irqs &= ~FS_INTR;\n\t\tret = IRQ_HANDLED;\n\t}\n\n\t \n\tif (active_irqs)\n\t\tDRM_DEV_ERROR(vop->dev, \"Unknown VOP IRQs: %#02x\\n\",\n\t\t\t      active_irqs);\n\nout_disable:\n\tvop_core_clks_disable(vop);\nout:\n\tpm_runtime_put(vop->dev);\n\treturn ret;\n}\n\nstatic void vop_plane_add_properties(struct drm_plane *plane,\n\t\t\t\t     const struct vop_win_data *win_data)\n{\n\tunsigned int flags = 0;\n\n\tflags |= VOP_WIN_HAS_REG(win_data, x_mir_en) ? DRM_MODE_REFLECT_X : 0;\n\tflags |= VOP_WIN_HAS_REG(win_data, y_mir_en) ? DRM_MODE_REFLECT_Y : 0;\n\tif (flags)\n\t\tdrm_plane_create_rotation_property(plane, DRM_MODE_ROTATE_0,\n\t\t\t\t\t\t   DRM_MODE_ROTATE_0 | flags);\n}\n\nstatic int vop_create_crtc(struct vop *vop)\n{\n\tconst struct vop_data *vop_data = vop->data;\n\tstruct device *dev = vop->dev;\n\tstruct drm_device *drm_dev = vop->drm_dev;\n\tstruct drm_plane *primary = NULL, *cursor = NULL, *plane, *tmp;\n\tstruct drm_crtc *crtc = &vop->crtc;\n\tstruct device_node *port;\n\tint ret;\n\tint i;\n\n\t \n\tfor (i = 0; i < vop_data->win_size; i++) {\n\t\tstruct vop_win *vop_win = &vop->win[i];\n\t\tconst struct vop_win_data *win_data = vop_win->data;\n\n\t\tif (win_data->type != DRM_PLANE_TYPE_PRIMARY &&\n\t\t    win_data->type != DRM_PLANE_TYPE_CURSOR)\n\t\t\tcontinue;\n\n\t\tret = drm_universal_plane_init(vop->drm_dev, &vop_win->base,\n\t\t\t\t\t       0, &vop_plane_funcs,\n\t\t\t\t\t       win_data->phy->data_formats,\n\t\t\t\t\t       win_data->phy->nformats,\n\t\t\t\t\t       win_data->phy->format_modifiers,\n\t\t\t\t\t       win_data->type, NULL);\n\t\tif (ret) {\n\t\t\tDRM_DEV_ERROR(vop->dev, \"failed to init plane %d\\n\",\n\t\t\t\t      ret);\n\t\t\tgoto err_cleanup_planes;\n\t\t}\n\n\t\tplane = &vop_win->base;\n\t\tdrm_plane_helper_add(plane, &plane_helper_funcs);\n\t\tvop_plane_add_properties(plane, win_data);\n\t\tif (plane->type == DRM_PLANE_TYPE_PRIMARY)\n\t\t\tprimary = plane;\n\t\telse if (plane->type == DRM_PLANE_TYPE_CURSOR)\n\t\t\tcursor = plane;\n\t}\n\n\tret = drm_crtc_init_with_planes(drm_dev, crtc, primary, cursor,\n\t\t\t\t\t&vop_crtc_funcs, NULL);\n\tif (ret)\n\t\tgoto err_cleanup_planes;\n\n\tdrm_crtc_helper_add(crtc, &vop_crtc_helper_funcs);\n\tif (vop->lut_regs) {\n\t\tdrm_mode_crtc_set_gamma_size(crtc, vop_data->lut_size);\n\t\tdrm_crtc_enable_color_mgmt(crtc, 0, false, vop_data->lut_size);\n\t}\n\n\t \n\tfor (i = 0; i < vop_data->win_size; i++) {\n\t\tstruct vop_win *vop_win = &vop->win[i];\n\t\tconst struct vop_win_data *win_data = vop_win->data;\n\t\tunsigned long possible_crtcs = drm_crtc_mask(crtc);\n\n\t\tif (win_data->type != DRM_PLANE_TYPE_OVERLAY)\n\t\t\tcontinue;\n\n\t\tret = drm_universal_plane_init(vop->drm_dev, &vop_win->base,\n\t\t\t\t\t       possible_crtcs,\n\t\t\t\t\t       &vop_plane_funcs,\n\t\t\t\t\t       win_data->phy->data_formats,\n\t\t\t\t\t       win_data->phy->nformats,\n\t\t\t\t\t       win_data->phy->format_modifiers,\n\t\t\t\t\t       win_data->type, NULL);\n\t\tif (ret) {\n\t\t\tDRM_DEV_ERROR(vop->dev, \"failed to init overlay %d\\n\",\n\t\t\t\t      ret);\n\t\t\tgoto err_cleanup_crtc;\n\t\t}\n\t\tdrm_plane_helper_add(&vop_win->base, &plane_helper_funcs);\n\t\tvop_plane_add_properties(&vop_win->base, win_data);\n\t}\n\n\tport = of_get_child_by_name(dev->of_node, \"port\");\n\tif (!port) {\n\t\tDRM_DEV_ERROR(vop->dev, \"no port node found in %pOF\\n\",\n\t\t\t      dev->of_node);\n\t\tret = -ENOENT;\n\t\tgoto err_cleanup_crtc;\n\t}\n\n\tdrm_flip_work_init(&vop->fb_unref_work, \"fb_unref\",\n\t\t\t   vop_fb_unref_worker);\n\n\tinit_completion(&vop->dsp_hold_completion);\n\tinit_completion(&vop->line_flag_completion);\n\tcrtc->port = port;\n\n\tret = drm_self_refresh_helper_init(crtc);\n\tif (ret)\n\t\tDRM_DEV_DEBUG_KMS(vop->dev,\n\t\t\t\"Failed to init %s with SR helpers %d, ignoring\\n\",\n\t\t\tcrtc->name, ret);\n\n\treturn 0;\n\nerr_cleanup_crtc:\n\tdrm_crtc_cleanup(crtc);\nerr_cleanup_planes:\n\tlist_for_each_entry_safe(plane, tmp, &drm_dev->mode_config.plane_list,\n\t\t\t\t head)\n\t\tdrm_plane_cleanup(plane);\n\treturn ret;\n}\n\nstatic void vop_destroy_crtc(struct vop *vop)\n{\n\tstruct drm_crtc *crtc = &vop->crtc;\n\tstruct drm_device *drm_dev = vop->drm_dev;\n\tstruct drm_plane *plane, *tmp;\n\n\tdrm_self_refresh_helper_cleanup(crtc);\n\n\tof_node_put(crtc->port);\n\n\t \n\tlist_for_each_entry_safe(plane, tmp, &drm_dev->mode_config.plane_list,\n\t\t\t\t head)\n\t\tvop_plane_destroy(plane);\n\n\t \n\tdrm_crtc_cleanup(crtc);\n\tdrm_flip_work_cleanup(&vop->fb_unref_work);\n}\n\nstatic int vop_initial(struct vop *vop)\n{\n\tstruct reset_control *ahb_rst;\n\tint i, ret;\n\n\tvop->hclk = devm_clk_get(vop->dev, \"hclk_vop\");\n\tif (IS_ERR(vop->hclk)) {\n\t\tDRM_DEV_ERROR(vop->dev, \"failed to get hclk source\\n\");\n\t\treturn PTR_ERR(vop->hclk);\n\t}\n\tvop->aclk = devm_clk_get(vop->dev, \"aclk_vop\");\n\tif (IS_ERR(vop->aclk)) {\n\t\tDRM_DEV_ERROR(vop->dev, \"failed to get aclk source\\n\");\n\t\treturn PTR_ERR(vop->aclk);\n\t}\n\tvop->dclk = devm_clk_get(vop->dev, \"dclk_vop\");\n\tif (IS_ERR(vop->dclk)) {\n\t\tDRM_DEV_ERROR(vop->dev, \"failed to get dclk source\\n\");\n\t\treturn PTR_ERR(vop->dclk);\n\t}\n\n\tret = pm_runtime_resume_and_get(vop->dev);\n\tif (ret < 0) {\n\t\tDRM_DEV_ERROR(vop->dev, \"failed to get pm runtime: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = clk_prepare(vop->dclk);\n\tif (ret < 0) {\n\t\tDRM_DEV_ERROR(vop->dev, \"failed to prepare dclk\\n\");\n\t\tgoto err_put_pm_runtime;\n\t}\n\n\t \n\tret = clk_prepare_enable(vop->hclk);\n\tif (ret < 0) {\n\t\tDRM_DEV_ERROR(vop->dev, \"failed to prepare/enable hclk\\n\");\n\t\tgoto err_unprepare_dclk;\n\t}\n\n\tret = clk_prepare_enable(vop->aclk);\n\tif (ret < 0) {\n\t\tDRM_DEV_ERROR(vop->dev, \"failed to prepare/enable aclk\\n\");\n\t\tgoto err_disable_hclk;\n\t}\n\n\t \n\tahb_rst = devm_reset_control_get(vop->dev, \"ahb\");\n\tif (IS_ERR(ahb_rst)) {\n\t\tDRM_DEV_ERROR(vop->dev, \"failed to get ahb reset\\n\");\n\t\tret = PTR_ERR(ahb_rst);\n\t\tgoto err_disable_aclk;\n\t}\n\treset_control_assert(ahb_rst);\n\tusleep_range(10, 20);\n\treset_control_deassert(ahb_rst);\n\n\tVOP_INTR_SET_TYPE(vop, clear, INTR_MASK, 1);\n\tVOP_INTR_SET_TYPE(vop, enable, INTR_MASK, 0);\n\n\tfor (i = 0; i < vop->len; i += sizeof(u32))\n\t\tvop->regsbak[i / 4] = readl_relaxed(vop->regs + i);\n\n\tVOP_REG_SET(vop, misc, global_regdone_en, 1);\n\tVOP_REG_SET(vop, common, dsp_blank, 0);\n\n\tfor (i = 0; i < vop->data->win_size; i++) {\n\t\tstruct vop_win *vop_win = &vop->win[i];\n\t\tconst struct vop_win_data *win = vop_win->data;\n\t\tint channel = i * 2 + 1;\n\n\t\tVOP_WIN_SET(vop, win, channel, (channel + 1) << 4 | channel);\n\t\tvop_win_disable(vop, vop_win);\n\t\tVOP_WIN_SET(vop, win, gate, 1);\n\t}\n\n\tvop_cfg_done(vop);\n\n\t \n\tvop->dclk_rst = devm_reset_control_get(vop->dev, \"dclk\");\n\tif (IS_ERR(vop->dclk_rst)) {\n\t\tDRM_DEV_ERROR(vop->dev, \"failed to get dclk reset\\n\");\n\t\tret = PTR_ERR(vop->dclk_rst);\n\t\tgoto err_disable_aclk;\n\t}\n\treset_control_assert(vop->dclk_rst);\n\tusleep_range(10, 20);\n\treset_control_deassert(vop->dclk_rst);\n\n\tclk_disable(vop->hclk);\n\tclk_disable(vop->aclk);\n\n\tvop->is_enabled = false;\n\n\tpm_runtime_put_sync(vop->dev);\n\n\treturn 0;\n\nerr_disable_aclk:\n\tclk_disable_unprepare(vop->aclk);\nerr_disable_hclk:\n\tclk_disable_unprepare(vop->hclk);\nerr_unprepare_dclk:\n\tclk_unprepare(vop->dclk);\nerr_put_pm_runtime:\n\tpm_runtime_put_sync(vop->dev);\n\treturn ret;\n}\n\n \nstatic void vop_win_init(struct vop *vop)\n{\n\tconst struct vop_data *vop_data = vop->data;\n\tunsigned int i;\n\n\tfor (i = 0; i < vop_data->win_size; i++) {\n\t\tstruct vop_win *vop_win = &vop->win[i];\n\t\tconst struct vop_win_data *win_data = &vop_data->win[i];\n\n\t\tvop_win->data = win_data;\n\t\tvop_win->vop = vop;\n\n\t\tif (vop_data->win_yuv2yuv)\n\t\t\tvop_win->yuv2yuv_data = &vop_data->win_yuv2yuv[i];\n\t}\n}\n\n \nint rockchip_drm_wait_vact_end(struct drm_crtc *crtc, unsigned int mstimeout)\n{\n\tstruct vop *vop = to_vop(crtc);\n\tunsigned long jiffies_left;\n\tint ret = 0;\n\n\tif (!crtc || !vop->is_enabled)\n\t\treturn -ENODEV;\n\n\tmutex_lock(&vop->vop_lock);\n\tif (mstimeout <= 0) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tif (vop_line_flag_irq_is_enabled(vop)) {\n\t\tret = -EBUSY;\n\t\tgoto out;\n\t}\n\n\treinit_completion(&vop->line_flag_completion);\n\tvop_line_flag_irq_enable(vop);\n\n\tjiffies_left = wait_for_completion_timeout(&vop->line_flag_completion,\n\t\t\t\t\t\t   msecs_to_jiffies(mstimeout));\n\tvop_line_flag_irq_disable(vop);\n\n\tif (jiffies_left == 0) {\n\t\tDRM_DEV_ERROR(vop->dev, \"Timeout waiting for IRQ\\n\");\n\t\tret = -ETIMEDOUT;\n\t\tgoto out;\n\t}\n\nout:\n\tmutex_unlock(&vop->vop_lock);\n\treturn ret;\n}\nEXPORT_SYMBOL(rockchip_drm_wait_vact_end);\n\nstatic int vop_bind(struct device *dev, struct device *master, void *data)\n{\n\tstruct platform_device *pdev = to_platform_device(dev);\n\tconst struct vop_data *vop_data;\n\tstruct drm_device *drm_dev = data;\n\tstruct vop *vop;\n\tstruct resource *res;\n\tint ret, irq;\n\n\tvop_data = of_device_get_match_data(dev);\n\tif (!vop_data)\n\t\treturn -ENODEV;\n\n\t \n\tvop = devm_kzalloc(dev, struct_size(vop, win, vop_data->win_size),\n\t\t\t   GFP_KERNEL);\n\tif (!vop)\n\t\treturn -ENOMEM;\n\n\tvop->dev = dev;\n\tvop->data = vop_data;\n\tvop->drm_dev = drm_dev;\n\tdev_set_drvdata(dev, vop);\n\n\tvop_win_init(vop);\n\n\tres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\n\tvop->regs = devm_ioremap_resource(dev, res);\n\tif (IS_ERR(vop->regs))\n\t\treturn PTR_ERR(vop->regs);\n\tvop->len = resource_size(res);\n\n\tres = platform_get_resource(pdev, IORESOURCE_MEM, 1);\n\tif (res) {\n\t\tif (vop_data->lut_size != 1024 && vop_data->lut_size != 256) {\n\t\t\tDRM_DEV_ERROR(dev, \"unsupported gamma LUT size %d\\n\", vop_data->lut_size);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tvop->lut_regs = devm_ioremap_resource(dev, res);\n\t\tif (IS_ERR(vop->lut_regs))\n\t\t\treturn PTR_ERR(vop->lut_regs);\n\t}\n\n\tvop->regsbak = devm_kzalloc(dev, vop->len, GFP_KERNEL);\n\tif (!vop->regsbak)\n\t\treturn -ENOMEM;\n\n\tirq = platform_get_irq(pdev, 0);\n\tif (irq < 0) {\n\t\tDRM_DEV_ERROR(dev, \"cannot find irq for vop\\n\");\n\t\treturn irq;\n\t}\n\tvop->irq = (unsigned int)irq;\n\n\tspin_lock_init(&vop->reg_lock);\n\tspin_lock_init(&vop->irq_lock);\n\tmutex_init(&vop->vop_lock);\n\n\tret = vop_create_crtc(vop);\n\tif (ret)\n\t\treturn ret;\n\n\tpm_runtime_enable(&pdev->dev);\n\n\tret = vop_initial(vop);\n\tif (ret < 0) {\n\t\tDRM_DEV_ERROR(&pdev->dev,\n\t\t\t      \"cannot initial vop dev - err %d\\n\", ret);\n\t\tgoto err_disable_pm_runtime;\n\t}\n\n\tret = devm_request_irq(dev, vop->irq, vop_isr,\n\t\t\t       IRQF_SHARED, dev_name(dev), vop);\n\tif (ret)\n\t\tgoto err_disable_pm_runtime;\n\n\tif (vop->data->feature & VOP_FEATURE_INTERNAL_RGB) {\n\t\tvop->rgb = rockchip_rgb_init(dev, &vop->crtc, vop->drm_dev, 0);\n\t\tif (IS_ERR(vop->rgb)) {\n\t\t\tret = PTR_ERR(vop->rgb);\n\t\t\tgoto err_disable_pm_runtime;\n\t\t}\n\t}\n\n\trockchip_drm_dma_init_device(drm_dev, dev);\n\n\treturn 0;\n\nerr_disable_pm_runtime:\n\tpm_runtime_disable(&pdev->dev);\n\tvop_destroy_crtc(vop);\n\treturn ret;\n}\n\nstatic void vop_unbind(struct device *dev, struct device *master, void *data)\n{\n\tstruct vop *vop = dev_get_drvdata(dev);\n\n\tif (vop->rgb)\n\t\trockchip_rgb_fini(vop->rgb);\n\n\tpm_runtime_disable(dev);\n\tvop_destroy_crtc(vop);\n\n\tclk_unprepare(vop->aclk);\n\tclk_unprepare(vop->hclk);\n\tclk_unprepare(vop->dclk);\n}\n\nconst struct component_ops vop_component_ops = {\n\t.bind = vop_bind,\n\t.unbind = vop_unbind,\n};\nEXPORT_SYMBOL_GPL(vop_component_ops);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}