{
  "module_name": "rockchip_lvds.c",
  "hash_id": "67ede69f0593aaa57a3ef12d713f701ebe0e291df7072e815b0d3b97ca534d25",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/rockchip/rockchip_lvds.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/component.h>\n#include <linux/mfd/syscon.h>\n#include <linux/of_graph.h>\n#include <linux/phy/phy.h>\n#include <linux/pinctrl/devinfo.h>\n#include <linux/platform_device.h>\n#include <linux/pm_runtime.h>\n#include <linux/regmap.h>\n#include <linux/reset.h>\n\n#include <drm/display/drm_dp_helper.h>\n#include <drm/drm_atomic_helper.h>\n#include <drm/drm_bridge.h>\n#include <drm/drm_bridge_connector.h>\n#include <drm/drm_of.h>\n#include <drm/drm_panel.h>\n#include <drm/drm_probe_helper.h>\n#include <drm/drm_simple_kms_helper.h>\n\n#include \"rockchip_drm_drv.h\"\n#include \"rockchip_drm_vop.h\"\n#include \"rockchip_lvds.h\"\n\n#define DISPLAY_OUTPUT_RGB\t\t0\n#define DISPLAY_OUTPUT_LVDS\t\t1\n#define DISPLAY_OUTPUT_DUAL_LVDS\t2\n\nstruct rockchip_lvds;\n\n \nstruct rockchip_lvds_soc_data {\n\tint (*probe)(struct platform_device *pdev, struct rockchip_lvds *lvds);\n\tconst struct drm_encoder_helper_funcs *helper_funcs;\n};\n\nstruct rockchip_lvds {\n\tstruct device *dev;\n\tvoid __iomem *regs;\n\tstruct regmap *grf;\n\tstruct clk *pclk;\n\tstruct phy *dphy;\n\tconst struct rockchip_lvds_soc_data *soc_data;\n\tint output;  \n\tint format;  \n\tstruct drm_device *drm_dev;\n\tstruct drm_panel *panel;\n\tstruct drm_bridge *bridge;\n\tstruct drm_connector connector;\n\tstruct rockchip_encoder encoder;\n\tstruct dev_pin_info *pins;\n};\n\nstatic inline struct rockchip_lvds *connector_to_lvds(struct drm_connector *connector)\n{\n\treturn container_of(connector, struct rockchip_lvds, connector);\n}\n\nstatic inline struct rockchip_lvds *encoder_to_lvds(struct drm_encoder *encoder)\n{\n\tstruct rockchip_encoder *rkencoder = to_rockchip_encoder(encoder);\n\n\treturn container_of(rkencoder, struct rockchip_lvds, encoder);\n}\n\nstatic inline void rk3288_writel(struct rockchip_lvds *lvds, u32 offset,\n\t\t\t\t u32 val)\n{\n\twritel_relaxed(val, lvds->regs + offset);\n\tif (lvds->output == DISPLAY_OUTPUT_LVDS)\n\t\treturn;\n\twritel_relaxed(val, lvds->regs + offset + RK3288_LVDS_CH1_OFFSET);\n}\n\nstatic inline int rockchip_lvds_name_to_format(const char *s)\n{\n\tif (strncmp(s, \"jeida-18\", 8) == 0)\n\t\treturn LVDS_JEIDA_18;\n\telse if (strncmp(s, \"jeida-24\", 8) == 0)\n\t\treturn LVDS_JEIDA_24;\n\telse if (strncmp(s, \"vesa-24\", 7) == 0)\n\t\treturn LVDS_VESA_24;\n\n\treturn -EINVAL;\n}\n\nstatic inline int rockchip_lvds_name_to_output(const char *s)\n{\n\tif (strncmp(s, \"rgb\", 3) == 0)\n\t\treturn DISPLAY_OUTPUT_RGB;\n\telse if (strncmp(s, \"lvds\", 4) == 0)\n\t\treturn DISPLAY_OUTPUT_LVDS;\n\telse if (strncmp(s, \"duallvds\", 8) == 0)\n\t\treturn DISPLAY_OUTPUT_DUAL_LVDS;\n\n\treturn -EINVAL;\n}\n\nstatic const struct drm_connector_funcs rockchip_lvds_connector_funcs = {\n\t.fill_modes = drm_helper_probe_single_connector_modes,\n\t.destroy = drm_connector_cleanup,\n\t.reset = drm_atomic_helper_connector_reset,\n\t.atomic_duplicate_state = drm_atomic_helper_connector_duplicate_state,\n\t.atomic_destroy_state = drm_atomic_helper_connector_destroy_state,\n};\n\nstatic int rockchip_lvds_connector_get_modes(struct drm_connector *connector)\n{\n\tstruct rockchip_lvds *lvds = connector_to_lvds(connector);\n\tstruct drm_panel *panel = lvds->panel;\n\n\treturn drm_panel_get_modes(panel, connector);\n}\n\nstatic const\nstruct drm_connector_helper_funcs rockchip_lvds_connector_helper_funcs = {\n\t.get_modes = rockchip_lvds_connector_get_modes,\n};\n\nstatic int\nrockchip_lvds_encoder_atomic_check(struct drm_encoder *encoder,\n\t\t\t\t   struct drm_crtc_state *crtc_state,\n\t\t\t\t   struct drm_connector_state *conn_state)\n{\n\tstruct rockchip_crtc_state *s = to_rockchip_crtc_state(crtc_state);\n\n\ts->output_mode = ROCKCHIP_OUT_MODE_P888;\n\ts->output_type = DRM_MODE_CONNECTOR_LVDS;\n\n\treturn 0;\n}\n\nstatic int rk3288_lvds_poweron(struct rockchip_lvds *lvds)\n{\n\tint ret;\n\tu32 val;\n\n\tret = clk_enable(lvds->pclk);\n\tif (ret < 0) {\n\t\tDRM_DEV_ERROR(lvds->dev, \"failed to enable lvds pclk %d\\n\", ret);\n\t\treturn ret;\n\t}\n\tret = pm_runtime_resume_and_get(lvds->dev);\n\tif (ret < 0) {\n\t\tDRM_DEV_ERROR(lvds->dev, \"failed to get pm runtime: %d\\n\", ret);\n\t\tclk_disable(lvds->pclk);\n\t\treturn ret;\n\t}\n\tval = RK3288_LVDS_CH0_REG0_LANE4_EN | RK3288_LVDS_CH0_REG0_LANE3_EN |\n\t\tRK3288_LVDS_CH0_REG0_LANE2_EN | RK3288_LVDS_CH0_REG0_LANE1_EN |\n\t\tRK3288_LVDS_CH0_REG0_LANE0_EN;\n\tif (lvds->output == DISPLAY_OUTPUT_RGB) {\n\t\tval |= RK3288_LVDS_CH0_REG0_TTL_EN |\n\t\t\tRK3288_LVDS_CH0_REG0_LANECK_EN;\n\t\trk3288_writel(lvds, RK3288_LVDS_CH0_REG0, val);\n\t\trk3288_writel(lvds, RK3288_LVDS_CH0_REG2,\n\t\t\t      RK3288_LVDS_PLL_FBDIV_REG2(0x46));\n\t\trk3288_writel(lvds, RK3288_LVDS_CH0_REG4,\n\t\t\t      RK3288_LVDS_CH0_REG4_LANECK_TTL_MODE |\n\t\t\t      RK3288_LVDS_CH0_REG4_LANE4_TTL_MODE |\n\t\t\t      RK3288_LVDS_CH0_REG4_LANE3_TTL_MODE |\n\t\t\t      RK3288_LVDS_CH0_REG4_LANE2_TTL_MODE |\n\t\t\t      RK3288_LVDS_CH0_REG4_LANE1_TTL_MODE |\n\t\t\t      RK3288_LVDS_CH0_REG4_LANE0_TTL_MODE);\n\t\trk3288_writel(lvds, RK3288_LVDS_CH0_REG5,\n\t\t\t      RK3288_LVDS_CH0_REG5_LANECK_TTL_DATA |\n\t\t\t      RK3288_LVDS_CH0_REG5_LANE4_TTL_DATA |\n\t\t\t      RK3288_LVDS_CH0_REG5_LANE3_TTL_DATA |\n\t\t\t      RK3288_LVDS_CH0_REG5_LANE2_TTL_DATA |\n\t\t\t      RK3288_LVDS_CH0_REG5_LANE1_TTL_DATA |\n\t\t\t      RK3288_LVDS_CH0_REG5_LANE0_TTL_DATA);\n\t} else {\n\t\tval |= RK3288_LVDS_CH0_REG0_LVDS_EN |\n\t\t\t    RK3288_LVDS_CH0_REG0_LANECK_EN;\n\t\trk3288_writel(lvds, RK3288_LVDS_CH0_REG0, val);\n\t\trk3288_writel(lvds, RK3288_LVDS_CH0_REG1,\n\t\t\t      RK3288_LVDS_CH0_REG1_LANECK_BIAS |\n\t\t\t      RK3288_LVDS_CH0_REG1_LANE4_BIAS |\n\t\t\t      RK3288_LVDS_CH0_REG1_LANE3_BIAS |\n\t\t\t      RK3288_LVDS_CH0_REG1_LANE2_BIAS |\n\t\t\t      RK3288_LVDS_CH0_REG1_LANE1_BIAS |\n\t\t\t      RK3288_LVDS_CH0_REG1_LANE0_BIAS);\n\t\trk3288_writel(lvds, RK3288_LVDS_CH0_REG2,\n\t\t\t      RK3288_LVDS_CH0_REG2_RESERVE_ON |\n\t\t\t      RK3288_LVDS_CH0_REG2_LANECK_LVDS_MODE |\n\t\t\t      RK3288_LVDS_CH0_REG2_LANE4_LVDS_MODE |\n\t\t\t      RK3288_LVDS_CH0_REG2_LANE3_LVDS_MODE |\n\t\t\t      RK3288_LVDS_CH0_REG2_LANE2_LVDS_MODE |\n\t\t\t      RK3288_LVDS_CH0_REG2_LANE1_LVDS_MODE |\n\t\t\t      RK3288_LVDS_CH0_REG2_LANE0_LVDS_MODE |\n\t\t\t      RK3288_LVDS_PLL_FBDIV_REG2(0x46));\n\t\trk3288_writel(lvds, RK3288_LVDS_CH0_REG4, 0x00);\n\t\trk3288_writel(lvds, RK3288_LVDS_CH0_REG5, 0x00);\n\t}\n\trk3288_writel(lvds, RK3288_LVDS_CH0_REG3,\n\t\t      RK3288_LVDS_PLL_FBDIV_REG3(0x46));\n\trk3288_writel(lvds, RK3288_LVDS_CH0_REGD,\n\t\t      RK3288_LVDS_PLL_PREDIV_REGD(0x0a));\n\trk3288_writel(lvds, RK3288_LVDS_CH0_REG20,\n\t\t      RK3288_LVDS_CH0_REG20_LSB);\n\n\trk3288_writel(lvds, RK3288_LVDS_CFG_REGC,\n\t\t      RK3288_LVDS_CFG_REGC_PLL_ENABLE);\n\trk3288_writel(lvds, RK3288_LVDS_CFG_REG21,\n\t\t      RK3288_LVDS_CFG_REG21_TX_ENABLE);\n\n\treturn 0;\n}\n\nstatic void rk3288_lvds_poweroff(struct rockchip_lvds *lvds)\n{\n\tint ret;\n\tu32 val;\n\n\trk3288_writel(lvds, RK3288_LVDS_CFG_REG21,\n\t\t      RK3288_LVDS_CFG_REG21_TX_ENABLE);\n\trk3288_writel(lvds, RK3288_LVDS_CFG_REGC,\n\t\t      RK3288_LVDS_CFG_REGC_PLL_ENABLE);\n\tval = LVDS_DUAL | LVDS_TTL_EN | LVDS_CH0_EN | LVDS_CH1_EN | LVDS_PWRDN;\n\tval |= val << 16;\n\tret = regmap_write(lvds->grf, RK3288_LVDS_GRF_SOC_CON7, val);\n\tif (ret != 0)\n\t\tDRM_DEV_ERROR(lvds->dev, \"Could not write to GRF: %d\\n\", ret);\n\n\tpm_runtime_put(lvds->dev);\n\tclk_disable(lvds->pclk);\n}\n\nstatic int rk3288_lvds_grf_config(struct drm_encoder *encoder,\n\t\t\t\t  struct drm_display_mode *mode)\n{\n\tstruct rockchip_lvds *lvds = encoder_to_lvds(encoder);\n\tu8 pin_hsync = (mode->flags & DRM_MODE_FLAG_PHSYNC) ? 1 : 0;\n\tu8 pin_dclk = (mode->flags & DRM_MODE_FLAG_PCSYNC) ? 1 : 0;\n\tu32 val;\n\tint ret;\n\n\t \n\tif (lvds->output == DISPLAY_OUTPUT_RGB)\n\t\tif (lvds->pins && !IS_ERR(lvds->pins->default_state))\n\t\t\tpinctrl_select_state(lvds->pins->p,\n\t\t\t\t\t     lvds->pins->default_state);\n\tval = lvds->format | LVDS_CH0_EN;\n\tif (lvds->output == DISPLAY_OUTPUT_RGB)\n\t\tval |= LVDS_TTL_EN | LVDS_CH1_EN;\n\telse if (lvds->output == DISPLAY_OUTPUT_DUAL_LVDS)\n\t\tval |= LVDS_DUAL | LVDS_CH1_EN;\n\n\tif ((mode->htotal - mode->hsync_start) & 0x01)\n\t\tval |= LVDS_START_PHASE_RST_1;\n\n\tval |= (pin_dclk << 8) | (pin_hsync << 9);\n\tval |= (0xffff << 16);\n\tret = regmap_write(lvds->grf, RK3288_LVDS_GRF_SOC_CON7, val);\n\tif (ret)\n\t\tDRM_DEV_ERROR(lvds->dev, \"Could not write to GRF: %d\\n\", ret);\n\n\treturn ret;\n}\n\nstatic int rk3288_lvds_set_vop_source(struct rockchip_lvds *lvds,\n\t\t\t\t      struct drm_encoder *encoder)\n{\n\tu32 val;\n\tint ret;\n\n\tret = drm_of_encoder_active_endpoint_id(lvds->dev->of_node, encoder);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tval = RK3288_LVDS_SOC_CON6_SEL_VOP_LIT << 16;\n\tif (ret)\n\t\tval |= RK3288_LVDS_SOC_CON6_SEL_VOP_LIT;\n\n\tret = regmap_write(lvds->grf, RK3288_LVDS_GRF_SOC_CON6, val);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn 0;\n}\n\nstatic void rk3288_lvds_encoder_enable(struct drm_encoder *encoder)\n{\n\tstruct rockchip_lvds *lvds = encoder_to_lvds(encoder);\n\tstruct drm_display_mode *mode = &encoder->crtc->state->adjusted_mode;\n\tint ret;\n\n\tdrm_panel_prepare(lvds->panel);\n\n\tret = rk3288_lvds_poweron(lvds);\n\tif (ret < 0) {\n\t\tDRM_DEV_ERROR(lvds->dev, \"failed to power on LVDS: %d\\n\", ret);\n\t\tdrm_panel_unprepare(lvds->panel);\n\t\treturn;\n\t}\n\n\tret = rk3288_lvds_grf_config(encoder, mode);\n\tif (ret) {\n\t\tDRM_DEV_ERROR(lvds->dev, \"failed to configure LVDS: %d\\n\", ret);\n\t\tdrm_panel_unprepare(lvds->panel);\n\t\treturn;\n\t}\n\n\tret = rk3288_lvds_set_vop_source(lvds, encoder);\n\tif (ret) {\n\t\tDRM_DEV_ERROR(lvds->dev, \"failed to set VOP source: %d\\n\", ret);\n\t\tdrm_panel_unprepare(lvds->panel);\n\t\treturn;\n\t}\n\n\tdrm_panel_enable(lvds->panel);\n}\n\nstatic void rk3288_lvds_encoder_disable(struct drm_encoder *encoder)\n{\n\tstruct rockchip_lvds *lvds = encoder_to_lvds(encoder);\n\n\tdrm_panel_disable(lvds->panel);\n\trk3288_lvds_poweroff(lvds);\n\tdrm_panel_unprepare(lvds->panel);\n}\n\nstatic int px30_lvds_poweron(struct rockchip_lvds *lvds)\n{\n\tint ret;\n\n\tret = pm_runtime_resume_and_get(lvds->dev);\n\tif (ret < 0) {\n\t\tDRM_DEV_ERROR(lvds->dev, \"failed to get pm runtime: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\t \n\tret = regmap_update_bits(lvds->grf, PX30_LVDS_GRF_PD_VO_CON1,\n\t\t\t\t  PX30_LVDS_MODE_EN(1) | PX30_LVDS_P2S_EN(1),\n\t\t\t\t  PX30_LVDS_MODE_EN(1) | PX30_LVDS_P2S_EN(1));\n\tif (ret)\n\t\tpm_runtime_put(lvds->dev);\n\n\treturn ret;\n}\n\nstatic void px30_lvds_poweroff(struct rockchip_lvds *lvds)\n{\n\tregmap_update_bits(lvds->grf, PX30_LVDS_GRF_PD_VO_CON1,\n\t\t\t   PX30_LVDS_MODE_EN(1) | PX30_LVDS_P2S_EN(1),\n\t\t\t   PX30_LVDS_MODE_EN(0) | PX30_LVDS_P2S_EN(0));\n\n\tpm_runtime_put(lvds->dev);\n}\n\nstatic int px30_lvds_grf_config(struct drm_encoder *encoder,\n\t\t\t\tstruct drm_display_mode *mode)\n{\n\tstruct rockchip_lvds *lvds = encoder_to_lvds(encoder);\n\n\tif (lvds->output != DISPLAY_OUTPUT_LVDS) {\n\t\tDRM_DEV_ERROR(lvds->dev, \"Unsupported display output %d\\n\",\n\t\t\t      lvds->output);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\treturn regmap_update_bits(lvds->grf, PX30_LVDS_GRF_PD_VO_CON1,\n\t\t\t\t  PX30_LVDS_FORMAT(lvds->format),\n\t\t\t\t  PX30_LVDS_FORMAT(lvds->format));\n}\n\nstatic int px30_lvds_set_vop_source(struct rockchip_lvds *lvds,\n\t\t\t\t    struct drm_encoder *encoder)\n{\n\tint vop;\n\n\tvop = drm_of_encoder_active_endpoint_id(lvds->dev->of_node, encoder);\n\tif (vop < 0)\n\t\treturn vop;\n\n\treturn regmap_update_bits(lvds->grf, PX30_LVDS_GRF_PD_VO_CON1,\n\t\t\t\t  PX30_LVDS_VOP_SEL(1),\n\t\t\t\t  PX30_LVDS_VOP_SEL(vop));\n}\n\nstatic void px30_lvds_encoder_enable(struct drm_encoder *encoder)\n{\n\tstruct rockchip_lvds *lvds = encoder_to_lvds(encoder);\n\tstruct drm_display_mode *mode = &encoder->crtc->state->adjusted_mode;\n\tint ret;\n\n\tdrm_panel_prepare(lvds->panel);\n\n\tret = px30_lvds_poweron(lvds);\n\tif (ret) {\n\t\tDRM_DEV_ERROR(lvds->dev, \"failed to power on LVDS: %d\\n\", ret);\n\t\tdrm_panel_unprepare(lvds->panel);\n\t\treturn;\n\t}\n\n\tret = px30_lvds_grf_config(encoder, mode);\n\tif (ret) {\n\t\tDRM_DEV_ERROR(lvds->dev, \"failed to configure LVDS: %d\\n\", ret);\n\t\tdrm_panel_unprepare(lvds->panel);\n\t\treturn;\n\t}\n\n\tret = px30_lvds_set_vop_source(lvds, encoder);\n\tif (ret) {\n\t\tDRM_DEV_ERROR(lvds->dev, \"failed to set VOP source: %d\\n\", ret);\n\t\tdrm_panel_unprepare(lvds->panel);\n\t\treturn;\n\t}\n\n\tdrm_panel_enable(lvds->panel);\n}\n\nstatic void px30_lvds_encoder_disable(struct drm_encoder *encoder)\n{\n\tstruct rockchip_lvds *lvds = encoder_to_lvds(encoder);\n\n\tdrm_panel_disable(lvds->panel);\n\tpx30_lvds_poweroff(lvds);\n\tdrm_panel_unprepare(lvds->panel);\n}\n\nstatic const\nstruct drm_encoder_helper_funcs rk3288_lvds_encoder_helper_funcs = {\n\t.enable = rk3288_lvds_encoder_enable,\n\t.disable = rk3288_lvds_encoder_disable,\n\t.atomic_check = rockchip_lvds_encoder_atomic_check,\n};\n\nstatic const\nstruct drm_encoder_helper_funcs px30_lvds_encoder_helper_funcs = {\n\t.enable = px30_lvds_encoder_enable,\n\t.disable = px30_lvds_encoder_disable,\n\t.atomic_check = rockchip_lvds_encoder_atomic_check,\n};\n\nstatic int rk3288_lvds_probe(struct platform_device *pdev,\n\t\t\t     struct rockchip_lvds *lvds)\n{\n\tint ret;\n\n\tlvds->regs = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(lvds->regs))\n\t\treturn PTR_ERR(lvds->regs);\n\n\tlvds->pclk = devm_clk_get(lvds->dev, \"pclk_lvds\");\n\tif (IS_ERR(lvds->pclk)) {\n\t\tDRM_DEV_ERROR(lvds->dev, \"could not get pclk_lvds\\n\");\n\t\treturn PTR_ERR(lvds->pclk);\n\t}\n\n\tlvds->pins = devm_kzalloc(lvds->dev, sizeof(*lvds->pins),\n\t\t\t\t  GFP_KERNEL);\n\tif (!lvds->pins)\n\t\treturn -ENOMEM;\n\n\tlvds->pins->p = devm_pinctrl_get(lvds->dev);\n\tif (IS_ERR(lvds->pins->p)) {\n\t\tDRM_DEV_ERROR(lvds->dev, \"no pinctrl handle\\n\");\n\t\tdevm_kfree(lvds->dev, lvds->pins);\n\t\tlvds->pins = NULL;\n\t} else {\n\t\tlvds->pins->default_state =\n\t\t\tpinctrl_lookup_state(lvds->pins->p, \"lcdc\");\n\t\tif (IS_ERR(lvds->pins->default_state)) {\n\t\t\tDRM_DEV_ERROR(lvds->dev, \"no default pinctrl state\\n\");\n\t\t\tdevm_kfree(lvds->dev, lvds->pins);\n\t\t\tlvds->pins = NULL;\n\t\t}\n\t}\n\n\tret = clk_prepare(lvds->pclk);\n\tif (ret < 0) {\n\t\tDRM_DEV_ERROR(lvds->dev, \"failed to prepare pclk_lvds\\n\");\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int px30_lvds_probe(struct platform_device *pdev,\n\t\t\t   struct rockchip_lvds *lvds)\n{\n\tint ret;\n\n\t \n\tret =  regmap_update_bits(lvds->grf, PX30_LVDS_GRF_PD_VO_CON1,\n\t\t\t\t  PX30_LVDS_MSBSEL(1),\n\t\t\t\t  PX30_LVDS_MSBSEL(1));\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tlvds->dphy = devm_phy_get(&pdev->dev, \"dphy\");\n\tif (IS_ERR(lvds->dphy))\n\t\treturn PTR_ERR(lvds->dphy);\n\n\tret = phy_init(lvds->dphy);\n\tif (ret)\n\t\treturn ret;\n\n\tret = phy_set_mode(lvds->dphy, PHY_MODE_LVDS);\n\tif (ret)\n\t\treturn ret;\n\n\treturn phy_power_on(lvds->dphy);\n}\n\nstatic const struct rockchip_lvds_soc_data rk3288_lvds_data = {\n\t.probe = rk3288_lvds_probe,\n\t.helper_funcs = &rk3288_lvds_encoder_helper_funcs,\n};\n\nstatic const struct rockchip_lvds_soc_data px30_lvds_data = {\n\t.probe = px30_lvds_probe,\n\t.helper_funcs = &px30_lvds_encoder_helper_funcs,\n};\n\nstatic const struct of_device_id rockchip_lvds_dt_ids[] = {\n\t{\n\t\t.compatible = \"rockchip,rk3288-lvds\",\n\t\t.data = &rk3288_lvds_data\n\t},\n\t{\n\t\t.compatible = \"rockchip,px30-lvds\",\n\t\t.data = &px30_lvds_data\n\t},\n\t{}\n};\nMODULE_DEVICE_TABLE(of, rockchip_lvds_dt_ids);\n\nstatic int rockchip_lvds_bind(struct device *dev, struct device *master,\n\t\t\t      void *data)\n{\n\tstruct rockchip_lvds *lvds = dev_get_drvdata(dev);\n\tstruct drm_device *drm_dev = data;\n\tstruct drm_encoder *encoder;\n\tstruct drm_connector *connector;\n\tstruct device_node *remote = NULL;\n\tstruct device_node  *port, *endpoint;\n\tint ret = 0, child_count = 0;\n\tconst char *name;\n\tu32 endpoint_id = 0;\n\n\tlvds->drm_dev = drm_dev;\n\tport = of_graph_get_port_by_id(dev->of_node, 1);\n\tif (!port) {\n\t\tDRM_DEV_ERROR(dev,\n\t\t\t      \"can't found port point, please init lvds panel port!\\n\");\n\t\treturn -EINVAL;\n\t}\n\tfor_each_child_of_node(port, endpoint) {\n\t\tchild_count++;\n\t\tof_property_read_u32(endpoint, \"reg\", &endpoint_id);\n\t\tret = drm_of_find_panel_or_bridge(dev->of_node, 1, endpoint_id,\n\t\t\t\t\t\t  &lvds->panel, &lvds->bridge);\n\t\tif (!ret) {\n\t\t\tof_node_put(endpoint);\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (!child_count) {\n\t\tDRM_DEV_ERROR(dev, \"lvds port does not have any children\\n\");\n\t\tret = -EINVAL;\n\t\tgoto err_put_port;\n\t} else if (ret) {\n\t\tDRM_DEV_ERROR(dev, \"failed to find panel and bridge node\\n\");\n\t\tret = -EPROBE_DEFER;\n\t\tgoto err_put_port;\n\t}\n\tif (lvds->panel)\n\t\tremote = lvds->panel->dev->of_node;\n\telse\n\t\tremote = lvds->bridge->of_node;\n\tif (of_property_read_string(dev->of_node, \"rockchip,output\", &name))\n\t\t \n\t\tlvds->output = DISPLAY_OUTPUT_RGB;\n\telse\n\t\tlvds->output = rockchip_lvds_name_to_output(name);\n\n\tif (lvds->output < 0) {\n\t\tDRM_DEV_ERROR(dev, \"invalid output type [%s]\\n\", name);\n\t\tret = lvds->output;\n\t\tgoto err_put_remote;\n\t}\n\n\tif (of_property_read_string(remote, \"data-mapping\", &name))\n\t\t \n\t\tlvds->format = LVDS_VESA_18;\n\telse\n\t\tlvds->format = rockchip_lvds_name_to_format(name);\n\n\tif (lvds->format < 0) {\n\t\tDRM_DEV_ERROR(dev, \"invalid data-mapping format [%s]\\n\", name);\n\t\tret = lvds->format;\n\t\tgoto err_put_remote;\n\t}\n\n\tencoder = &lvds->encoder.encoder;\n\tencoder->possible_crtcs = drm_of_find_possible_crtcs(drm_dev,\n\t\t\t\t\t\t\t     dev->of_node);\n\n\tret = drm_simple_encoder_init(drm_dev, encoder, DRM_MODE_ENCODER_LVDS);\n\tif (ret < 0) {\n\t\tDRM_DEV_ERROR(drm_dev->dev,\n\t\t\t      \"failed to initialize encoder: %d\\n\", ret);\n\t\tgoto err_put_remote;\n\t}\n\n\tdrm_encoder_helper_add(encoder, lvds->soc_data->helper_funcs);\n\tconnector = &lvds->connector;\n\n\tif (lvds->panel) {\n\t\tconnector->dpms = DRM_MODE_DPMS_OFF;\n\t\tret = drm_connector_init(drm_dev, connector,\n\t\t\t\t\t &rockchip_lvds_connector_funcs,\n\t\t\t\t\t DRM_MODE_CONNECTOR_LVDS);\n\t\tif (ret < 0) {\n\t\t\tDRM_DEV_ERROR(drm_dev->dev,\n\t\t\t\t      \"failed to initialize connector: %d\\n\", ret);\n\t\t\tgoto err_free_encoder;\n\t\t}\n\n\t\tdrm_connector_helper_add(connector,\n\t\t\t\t\t &rockchip_lvds_connector_helper_funcs);\n\t} else {\n\t\tret = drm_bridge_attach(encoder, lvds->bridge, NULL,\n\t\t\t\t\tDRM_BRIDGE_ATTACH_NO_CONNECTOR);\n\t\tif (ret)\n\t\t\tgoto err_free_encoder;\n\n\t\tconnector = drm_bridge_connector_init(lvds->drm_dev, encoder);\n\t\tif (IS_ERR(connector)) {\n\t\t\tDRM_DEV_ERROR(drm_dev->dev,\n\t\t\t\t      \"failed to initialize bridge connector: %pe\\n\",\n\t\t\t\t      connector);\n\t\t\tret = PTR_ERR(connector);\n\t\t\tgoto err_free_encoder;\n\t\t}\n\t}\n\n\tret = drm_connector_attach_encoder(connector, encoder);\n\tif (ret < 0) {\n\t\tDRM_DEV_ERROR(drm_dev->dev,\n\t\t\t      \"failed to attach encoder: %d\\n\", ret);\n\t\tgoto err_free_connector;\n\t}\n\n\tpm_runtime_enable(dev);\n\tof_node_put(remote);\n\tof_node_put(port);\n\n\treturn 0;\n\nerr_free_connector:\n\tdrm_connector_cleanup(connector);\nerr_free_encoder:\n\tdrm_encoder_cleanup(encoder);\nerr_put_remote:\n\tof_node_put(remote);\nerr_put_port:\n\tof_node_put(port);\n\n\treturn ret;\n}\n\nstatic void rockchip_lvds_unbind(struct device *dev, struct device *master,\n\t\t\t\tvoid *data)\n{\n\tstruct rockchip_lvds *lvds = dev_get_drvdata(dev);\n\tconst struct drm_encoder_helper_funcs *encoder_funcs;\n\n\tencoder_funcs = lvds->soc_data->helper_funcs;\n\tencoder_funcs->disable(&lvds->encoder.encoder);\n\tpm_runtime_disable(dev);\n\tdrm_connector_cleanup(&lvds->connector);\n\tdrm_encoder_cleanup(&lvds->encoder.encoder);\n}\n\nstatic const struct component_ops rockchip_lvds_component_ops = {\n\t.bind = rockchip_lvds_bind,\n\t.unbind = rockchip_lvds_unbind,\n};\n\nstatic int rockchip_lvds_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct rockchip_lvds *lvds;\n\tconst struct of_device_id *match;\n\tint ret;\n\n\tif (!dev->of_node)\n\t\treturn -ENODEV;\n\n\tlvds = devm_kzalloc(&pdev->dev, sizeof(*lvds), GFP_KERNEL);\n\tif (!lvds)\n\t\treturn -ENOMEM;\n\n\tlvds->dev = dev;\n\tmatch = of_match_node(rockchip_lvds_dt_ids, dev->of_node);\n\tif (!match)\n\t\treturn -ENODEV;\n\tlvds->soc_data = match->data;\n\n\tlvds->grf = syscon_regmap_lookup_by_phandle(dev->of_node,\n\t\t\t\t\t\t    \"rockchip,grf\");\n\tif (IS_ERR(lvds->grf)) {\n\t\tDRM_DEV_ERROR(dev, \"missing rockchip,grf property\\n\");\n\t\treturn PTR_ERR(lvds->grf);\n\t}\n\n\tret = lvds->soc_data->probe(pdev, lvds);\n\tif (ret) {\n\t\tDRM_DEV_ERROR(dev, \"Platform initialization failed\\n\");\n\t\treturn ret;\n\t}\n\n\tdev_set_drvdata(dev, lvds);\n\n\tret = component_add(&pdev->dev, &rockchip_lvds_component_ops);\n\tif (ret < 0) {\n\t\tDRM_DEV_ERROR(dev, \"failed to add component\\n\");\n\t\tclk_unprepare(lvds->pclk);\n\t}\n\n\treturn ret;\n}\n\nstatic void rockchip_lvds_remove(struct platform_device *pdev)\n{\n\tstruct rockchip_lvds *lvds = platform_get_drvdata(pdev);\n\n\tcomponent_del(&pdev->dev, &rockchip_lvds_component_ops);\n\tclk_unprepare(lvds->pclk);\n}\n\nstruct platform_driver rockchip_lvds_driver = {\n\t.probe = rockchip_lvds_probe,\n\t.remove_new = rockchip_lvds_remove,\n\t.driver = {\n\t\t   .name = \"rockchip-lvds\",\n\t\t   .of_match_table = of_match_ptr(rockchip_lvds_dt_ids),\n\t},\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}