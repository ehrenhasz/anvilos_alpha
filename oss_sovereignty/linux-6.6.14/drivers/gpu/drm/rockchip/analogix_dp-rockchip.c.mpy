{
  "module_name": "analogix_dp-rockchip.c",
  "hash_id": "5776b7002023606c6e5a1a2fa7faad79b5f8946664b1c98e63145662306fb28f",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/rockchip/analogix_dp-rockchip.c",
  "human_readable_source": "\n \n\n#include <linux/component.h>\n#include <linux/mfd/syscon.h>\n#include <linux/of.h>\n#include <linux/of_graph.h>\n#include <linux/platform_device.h>\n#include <linux/regmap.h>\n#include <linux/reset.h>\n#include <linux/clk.h>\n\n#include <video/of_videomode.h>\n#include <video/videomode.h>\n\n#include <drm/display/drm_dp_helper.h>\n#include <drm/drm_atomic.h>\n#include <drm/drm_atomic_helper.h>\n#include <drm/bridge/analogix_dp.h>\n#include <drm/drm_of.h>\n#include <drm/drm_panel.h>\n#include <drm/drm_probe_helper.h>\n#include <drm/drm_simple_kms_helper.h>\n\n#include \"rockchip_drm_drv.h\"\n#include \"rockchip_drm_vop.h\"\n\n#define RK3288_GRF_SOC_CON6\t\t0x25c\n#define RK3288_EDP_LCDC_SEL\t\tBIT(5)\n#define RK3399_GRF_SOC_CON20\t\t0x6250\n#define RK3399_EDP_LCDC_SEL\t\tBIT(5)\n\n#define HIWORD_UPDATE(val, mask)\t(val | (mask) << 16)\n\n#define PSR_WAIT_LINE_FLAG_TIMEOUT_MS\t100\n\n \nstruct rockchip_dp_chip_data {\n\tu32\tlcdsel_grf_reg;\n\tu32\tlcdsel_big;\n\tu32\tlcdsel_lit;\n\tu32\tchip_type;\n};\n\nstruct rockchip_dp_device {\n\tstruct drm_device        *drm_dev;\n\tstruct device            *dev;\n\tstruct rockchip_encoder  encoder;\n\tstruct drm_display_mode  mode;\n\n\tstruct clk               *pclk;\n\tstruct clk               *grfclk;\n\tstruct regmap            *grf;\n\tstruct reset_control     *rst;\n\n\tconst struct rockchip_dp_chip_data *data;\n\n\tstruct analogix_dp_device *adp;\n\tstruct analogix_dp_plat_data plat_data;\n};\n\nstatic struct rockchip_dp_device *encoder_to_dp(struct drm_encoder *encoder)\n{\n\tstruct rockchip_encoder *rkencoder = to_rockchip_encoder(encoder);\n\n\treturn container_of(rkencoder, struct rockchip_dp_device, encoder);\n}\n\nstatic struct rockchip_dp_device *pdata_encoder_to_dp(struct analogix_dp_plat_data *plat_data)\n{\n\treturn container_of(plat_data, struct rockchip_dp_device, plat_data);\n}\n\nstatic int rockchip_dp_pre_init(struct rockchip_dp_device *dp)\n{\n\treset_control_assert(dp->rst);\n\tusleep_range(10, 20);\n\treset_control_deassert(dp->rst);\n\n\treturn 0;\n}\n\nstatic int rockchip_dp_poweron_start(struct analogix_dp_plat_data *plat_data)\n{\n\tstruct rockchip_dp_device *dp = pdata_encoder_to_dp(plat_data);\n\tint ret;\n\n\tret = clk_prepare_enable(dp->pclk);\n\tif (ret < 0) {\n\t\tDRM_DEV_ERROR(dp->dev, \"failed to enable pclk %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = rockchip_dp_pre_init(dp);\n\tif (ret < 0) {\n\t\tDRM_DEV_ERROR(dp->dev, \"failed to dp pre init %d\\n\", ret);\n\t\tclk_disable_unprepare(dp->pclk);\n\t\treturn ret;\n\t}\n\n\treturn ret;\n}\n\nstatic int rockchip_dp_powerdown(struct analogix_dp_plat_data *plat_data)\n{\n\tstruct rockchip_dp_device *dp = pdata_encoder_to_dp(plat_data);\n\n\tclk_disable_unprepare(dp->pclk);\n\n\treturn 0;\n}\n\nstatic int rockchip_dp_get_modes(struct analogix_dp_plat_data *plat_data,\n\t\t\t\t struct drm_connector *connector)\n{\n\tstruct drm_display_info *di = &connector->display_info;\n\t \n\tu32 mask = DRM_COLOR_FORMAT_YCBCR444 | DRM_COLOR_FORMAT_YCBCR422;\n\n\tif ((di->color_formats & mask)) {\n\t\tDRM_DEBUG_KMS(\"Swapping display color format from YUV to RGB\\n\");\n\t\tdi->color_formats &= ~mask;\n\t\tdi->color_formats |= DRM_COLOR_FORMAT_RGB444;\n\t\tdi->bpc = 8;\n\t}\n\n\treturn 0;\n}\n\nstatic bool\nrockchip_dp_drm_encoder_mode_fixup(struct drm_encoder *encoder,\n\t\t\t\t   const struct drm_display_mode *mode,\n\t\t\t\t   struct drm_display_mode *adjusted_mode)\n{\n\t \n\treturn true;\n}\n\nstatic void rockchip_dp_drm_encoder_mode_set(struct drm_encoder *encoder,\n\t\t\t\t\t     struct drm_display_mode *mode,\n\t\t\t\t\t     struct drm_display_mode *adjusted)\n{\n\t \n}\n\nstatic\nstruct drm_crtc *rockchip_dp_drm_get_new_crtc(struct drm_encoder *encoder,\n\t\t\t\t\t      struct drm_atomic_state *state)\n{\n\tstruct drm_connector *connector;\n\tstruct drm_connector_state *conn_state;\n\n\tconnector = drm_atomic_get_new_connector_for_encoder(state, encoder);\n\tif (!connector)\n\t\treturn NULL;\n\n\tconn_state = drm_atomic_get_new_connector_state(state, connector);\n\tif (!conn_state)\n\t\treturn NULL;\n\n\treturn conn_state->crtc;\n}\n\nstatic void rockchip_dp_drm_encoder_enable(struct drm_encoder *encoder,\n\t\t\t\t\t   struct drm_atomic_state *state)\n{\n\tstruct rockchip_dp_device *dp = encoder_to_dp(encoder);\n\tstruct drm_crtc *crtc;\n\tstruct drm_crtc_state *old_crtc_state;\n\tint ret;\n\tu32 val;\n\n\tcrtc = rockchip_dp_drm_get_new_crtc(encoder, state);\n\tif (!crtc)\n\t\treturn;\n\n\told_crtc_state = drm_atomic_get_old_crtc_state(state, crtc);\n\t \n\tif (old_crtc_state && old_crtc_state->self_refresh_active)\n\t\treturn;\n\n\tret = drm_of_encoder_active_endpoint_id(dp->dev->of_node, encoder);\n\tif (ret < 0)\n\t\treturn;\n\n\tif (ret)\n\t\tval = dp->data->lcdsel_lit;\n\telse\n\t\tval = dp->data->lcdsel_big;\n\n\tDRM_DEV_DEBUG(dp->dev, \"vop %s output to dp\\n\", (ret) ? \"LIT\" : \"BIG\");\n\n\tret = clk_prepare_enable(dp->grfclk);\n\tif (ret < 0) {\n\t\tDRM_DEV_ERROR(dp->dev, \"failed to enable grfclk %d\\n\", ret);\n\t\treturn;\n\t}\n\n\tret = regmap_write(dp->grf, dp->data->lcdsel_grf_reg, val);\n\tif (ret != 0)\n\t\tDRM_DEV_ERROR(dp->dev, \"Could not write to GRF: %d\\n\", ret);\n\n\tclk_disable_unprepare(dp->grfclk);\n}\n\nstatic void rockchip_dp_drm_encoder_disable(struct drm_encoder *encoder,\n\t\t\t\t\t    struct drm_atomic_state *state)\n{\n\tstruct rockchip_dp_device *dp = encoder_to_dp(encoder);\n\tstruct drm_crtc *crtc;\n\tstruct drm_crtc_state *new_crtc_state = NULL;\n\tint ret;\n\n\tcrtc = rockchip_dp_drm_get_new_crtc(encoder, state);\n\t \n\tif (!crtc)\n\t\treturn;\n\n\tnew_crtc_state = drm_atomic_get_new_crtc_state(state, crtc);\n\t \n\tif (!new_crtc_state || !new_crtc_state->self_refresh_active)\n\t\treturn;\n\n\tret = rockchip_drm_wait_vact_end(crtc, PSR_WAIT_LINE_FLAG_TIMEOUT_MS);\n\tif (ret)\n\t\tDRM_DEV_ERROR(dp->dev, \"line flag irq timed out\\n\");\n}\n\nstatic int\nrockchip_dp_drm_encoder_atomic_check(struct drm_encoder *encoder,\n\t\t\t\t      struct drm_crtc_state *crtc_state,\n\t\t\t\t      struct drm_connector_state *conn_state)\n{\n\tstruct rockchip_crtc_state *s = to_rockchip_crtc_state(crtc_state);\n\tstruct drm_display_info *di = &conn_state->connector->display_info;\n\n\t \n\n\ts->output_mode = ROCKCHIP_OUT_MODE_AAAA;\n\ts->output_type = DRM_MODE_CONNECTOR_eDP;\n\ts->output_bpc = di->bpc;\n\n\treturn 0;\n}\n\nstatic struct drm_encoder_helper_funcs rockchip_dp_encoder_helper_funcs = {\n\t.mode_fixup = rockchip_dp_drm_encoder_mode_fixup,\n\t.mode_set = rockchip_dp_drm_encoder_mode_set,\n\t.atomic_enable = rockchip_dp_drm_encoder_enable,\n\t.atomic_disable = rockchip_dp_drm_encoder_disable,\n\t.atomic_check = rockchip_dp_drm_encoder_atomic_check,\n};\n\nstatic int rockchip_dp_of_probe(struct rockchip_dp_device *dp)\n{\n\tstruct device *dev = dp->dev;\n\tstruct device_node *np = dev->of_node;\n\n\tdp->grf = syscon_regmap_lookup_by_phandle(np, \"rockchip,grf\");\n\tif (IS_ERR(dp->grf)) {\n\t\tDRM_DEV_ERROR(dev, \"failed to get rockchip,grf property\\n\");\n\t\treturn PTR_ERR(dp->grf);\n\t}\n\n\tdp->grfclk = devm_clk_get(dev, \"grf\");\n\tif (PTR_ERR(dp->grfclk) == -ENOENT) {\n\t\tdp->grfclk = NULL;\n\t} else if (PTR_ERR(dp->grfclk) == -EPROBE_DEFER) {\n\t\treturn -EPROBE_DEFER;\n\t} else if (IS_ERR(dp->grfclk)) {\n\t\tDRM_DEV_ERROR(dev, \"failed to get grf clock\\n\");\n\t\treturn PTR_ERR(dp->grfclk);\n\t}\n\n\tdp->pclk = devm_clk_get(dev, \"pclk\");\n\tif (IS_ERR(dp->pclk)) {\n\t\tDRM_DEV_ERROR(dev, \"failed to get pclk property\\n\");\n\t\treturn PTR_ERR(dp->pclk);\n\t}\n\n\tdp->rst = devm_reset_control_get(dev, \"dp\");\n\tif (IS_ERR(dp->rst)) {\n\t\tDRM_DEV_ERROR(dev, \"failed to get dp reset control\\n\");\n\t\treturn PTR_ERR(dp->rst);\n\t}\n\n\treturn 0;\n}\n\nstatic int rockchip_dp_drm_create_encoder(struct rockchip_dp_device *dp)\n{\n\tstruct drm_encoder *encoder = &dp->encoder.encoder;\n\tstruct drm_device *drm_dev = dp->drm_dev;\n\tstruct device *dev = dp->dev;\n\tint ret;\n\n\tencoder->possible_crtcs = drm_of_find_possible_crtcs(drm_dev,\n\t\t\t\t\t\t\t     dev->of_node);\n\tDRM_DEBUG_KMS(\"possible_crtcs = 0x%x\\n\", encoder->possible_crtcs);\n\n\tret = drm_simple_encoder_init(drm_dev, encoder,\n\t\t\t\t      DRM_MODE_ENCODER_TMDS);\n\tif (ret) {\n\t\tDRM_ERROR(\"failed to initialize encoder with drm\\n\");\n\t\treturn ret;\n\t}\n\n\tdrm_encoder_helper_add(encoder, &rockchip_dp_encoder_helper_funcs);\n\n\treturn 0;\n}\n\nstatic int rockchip_dp_bind(struct device *dev, struct device *master,\n\t\t\t    void *data)\n{\n\tstruct rockchip_dp_device *dp = dev_get_drvdata(dev);\n\tstruct drm_device *drm_dev = data;\n\tint ret;\n\n\tdp->drm_dev = drm_dev;\n\n\tret = rockchip_dp_drm_create_encoder(dp);\n\tif (ret) {\n\t\tDRM_ERROR(\"failed to create drm encoder\\n\");\n\t\treturn ret;\n\t}\n\n\tdp->plat_data.encoder = &dp->encoder.encoder;\n\n\tret = analogix_dp_bind(dp->adp, drm_dev);\n\tif (ret)\n\t\tgoto err_cleanup_encoder;\n\n\treturn 0;\nerr_cleanup_encoder:\n\tdp->encoder.encoder.funcs->destroy(&dp->encoder.encoder);\n\treturn ret;\n}\n\nstatic void rockchip_dp_unbind(struct device *dev, struct device *master,\n\t\t\t       void *data)\n{\n\tstruct rockchip_dp_device *dp = dev_get_drvdata(dev);\n\n\tanalogix_dp_unbind(dp->adp);\n\tdp->encoder.encoder.funcs->destroy(&dp->encoder.encoder);\n}\n\nstatic const struct component_ops rockchip_dp_component_ops = {\n\t.bind = rockchip_dp_bind,\n\t.unbind = rockchip_dp_unbind,\n};\n\nstatic int rockchip_dp_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tconst struct rockchip_dp_chip_data *dp_data;\n\tstruct drm_panel *panel = NULL;\n\tstruct rockchip_dp_device *dp;\n\tint ret;\n\n\tdp_data = of_device_get_match_data(dev);\n\tif (!dp_data)\n\t\treturn -ENODEV;\n\n\tret = drm_of_find_panel_or_bridge(dev->of_node, 1, 0, &panel, NULL);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tdp = devm_kzalloc(dev, sizeof(*dp), GFP_KERNEL);\n\tif (!dp)\n\t\treturn -ENOMEM;\n\n\tdp->dev = dev;\n\tdp->adp = ERR_PTR(-ENODEV);\n\tdp->data = dp_data;\n\tdp->plat_data.panel = panel;\n\tdp->plat_data.dev_type = dp->data->chip_type;\n\tdp->plat_data.power_on_start = rockchip_dp_poweron_start;\n\tdp->plat_data.power_off = rockchip_dp_powerdown;\n\tdp->plat_data.get_modes = rockchip_dp_get_modes;\n\n\tret = rockchip_dp_of_probe(dp);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tplatform_set_drvdata(pdev, dp);\n\n\tdp->adp = analogix_dp_probe(dev, &dp->plat_data);\n\tif (IS_ERR(dp->adp))\n\t\treturn PTR_ERR(dp->adp);\n\n\tret = component_add(dev, &rockchip_dp_component_ops);\n\tif (ret)\n\t\tgoto err_dp_remove;\n\n\treturn 0;\n\nerr_dp_remove:\n\tanalogix_dp_remove(dp->adp);\n\treturn ret;\n}\n\nstatic void rockchip_dp_remove(struct platform_device *pdev)\n{\n\tstruct rockchip_dp_device *dp = platform_get_drvdata(pdev);\n\n\tcomponent_del(&pdev->dev, &rockchip_dp_component_ops);\n\tanalogix_dp_remove(dp->adp);\n}\n\n#ifdef CONFIG_PM_SLEEP\nstatic int rockchip_dp_suspend(struct device *dev)\n{\n\tstruct rockchip_dp_device *dp = dev_get_drvdata(dev);\n\n\tif (IS_ERR(dp->adp))\n\t\treturn 0;\n\n\treturn analogix_dp_suspend(dp->adp);\n}\n\nstatic int rockchip_dp_resume(struct device *dev)\n{\n\tstruct rockchip_dp_device *dp = dev_get_drvdata(dev);\n\n\tif (IS_ERR(dp->adp))\n\t\treturn 0;\n\n\treturn analogix_dp_resume(dp->adp);\n}\n#endif\n\nstatic const struct dev_pm_ops rockchip_dp_pm_ops = {\n#ifdef CONFIG_PM_SLEEP\n\t.suspend_late = rockchip_dp_suspend,\n\t.resume_early = rockchip_dp_resume,\n#endif\n};\n\nstatic const struct rockchip_dp_chip_data rk3399_edp = {\n\t.lcdsel_grf_reg = RK3399_GRF_SOC_CON20,\n\t.lcdsel_big = HIWORD_UPDATE(0, RK3399_EDP_LCDC_SEL),\n\t.lcdsel_lit = HIWORD_UPDATE(RK3399_EDP_LCDC_SEL, RK3399_EDP_LCDC_SEL),\n\t.chip_type = RK3399_EDP,\n};\n\nstatic const struct rockchip_dp_chip_data rk3288_dp = {\n\t.lcdsel_grf_reg = RK3288_GRF_SOC_CON6,\n\t.lcdsel_big = HIWORD_UPDATE(0, RK3288_EDP_LCDC_SEL),\n\t.lcdsel_lit = HIWORD_UPDATE(RK3288_EDP_LCDC_SEL, RK3288_EDP_LCDC_SEL),\n\t.chip_type = RK3288_DP,\n};\n\nstatic const struct of_device_id rockchip_dp_dt_ids[] = {\n\t{.compatible = \"rockchip,rk3288-dp\", .data = &rk3288_dp },\n\t{.compatible = \"rockchip,rk3399-edp\", .data = &rk3399_edp },\n\t{}\n};\nMODULE_DEVICE_TABLE(of, rockchip_dp_dt_ids);\n\nstruct platform_driver rockchip_dp_driver = {\n\t.probe = rockchip_dp_probe,\n\t.remove_new = rockchip_dp_remove,\n\t.driver = {\n\t\t   .name = \"rockchip-dp\",\n\t\t   .pm = &rockchip_dp_pm_ops,\n\t\t   .of_match_table = rockchip_dp_dt_ids,\n\t},\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}