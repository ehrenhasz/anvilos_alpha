{
  "module_name": "inno_hdmi.c",
  "hash_id": "5dfd8e7e34a5c5c1c0c4a567380ef05c19e4ef48ead94eccf5e59e3ac7f63cd8",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/rockchip/inno_hdmi.c",
  "human_readable_source": "\n \n\n#include <linux/irq.h>\n#include <linux/clk.h>\n#include <linux/delay.h>\n#include <linux/err.h>\n#include <linux/hdmi.h>\n#include <linux/mfd/syscon.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include <linux/mutex.h>\n#include <linux/platform_device.h>\n\n#include <drm/drm_atomic_helper.h>\n#include <drm/drm_edid.h>\n#include <drm/drm_of.h>\n#include <drm/drm_probe_helper.h>\n#include <drm/drm_simple_kms_helper.h>\n\n#include \"rockchip_drm_drv.h\"\n#include \"rockchip_drm_vop.h\"\n\n#include \"inno_hdmi.h\"\n\nstruct hdmi_data_info {\n\tint vic;\n\tbool sink_has_audio;\n\tunsigned int enc_in_format;\n\tunsigned int enc_out_format;\n\tunsigned int colorimetry;\n};\n\nstruct inno_hdmi_i2c {\n\tstruct i2c_adapter adap;\n\n\tu8 ddc_addr;\n\tu8 segment_addr;\n\n\tstruct mutex lock;\n\tstruct completion cmp;\n};\n\nstruct inno_hdmi {\n\tstruct device *dev;\n\tstruct drm_device *drm_dev;\n\n\tint irq;\n\tstruct clk *pclk;\n\tvoid __iomem *regs;\n\n\tstruct drm_connector\tconnector;\n\tstruct rockchip_encoder\tencoder;\n\n\tstruct inno_hdmi_i2c *i2c;\n\tstruct i2c_adapter *ddc;\n\n\tunsigned int tmds_rate;\n\n\tstruct hdmi_data_info\thdmi_data;\n\tstruct drm_display_mode previous_mode;\n};\n\nstatic struct inno_hdmi *encoder_to_inno_hdmi(struct drm_encoder *encoder)\n{\n\tstruct rockchip_encoder *rkencoder = to_rockchip_encoder(encoder);\n\n\treturn container_of(rkencoder, struct inno_hdmi, encoder);\n}\n\nstatic struct inno_hdmi *connector_to_inno_hdmi(struct drm_connector *connector)\n{\n\treturn container_of(connector, struct inno_hdmi, connector);\n}\n\nenum {\n\tCSC_ITU601_16_235_TO_RGB_0_255_8BIT,\n\tCSC_ITU601_0_255_TO_RGB_0_255_8BIT,\n\tCSC_ITU709_16_235_TO_RGB_0_255_8BIT,\n\tCSC_RGB_0_255_TO_ITU601_16_235_8BIT,\n\tCSC_RGB_0_255_TO_ITU709_16_235_8BIT,\n\tCSC_RGB_0_255_TO_RGB_16_235_8BIT,\n};\n\nstatic const char coeff_csc[][24] = {\n\t \n\t{\n\t\t0x04, 0xa7, 0x00, 0x00, 0x06, 0x62, 0x02, 0xcc,\n\t\t0x04, 0xa7, 0x11, 0x90, 0x13, 0x40, 0x00, 0x9a,\n\t\t0x04, 0xa7, 0x08, 0x12, 0x00, 0x00, 0x03, 0x02\n\t},\n\t \n\t{\n\t\t0x04, 0x00, 0x00, 0x00, 0x05, 0x9b, 0x02, 0xf8,\n\t\t0x04, 0x00, 0x11, 0x60, 0x12, 0xdb, 0x00, 0x87,\n\t\t0x04, 0x00, 0x07, 0x16, 0x00, 0x00, 0x02, 0xe3\n\t},\n\t \n\t{\n\t\t0x04, 0xa7, 0x00, 0x00, 0x07, 0x2c, 0x02, 0xf8,\n\t\t0x04, 0xa7, 0x10, 0xda, 0x12, 0x22, 0x00, 0x4d,\n\t\t0x04, 0xa7, 0x08, 0x74, 0x00, 0x00, 0x03, 0x21\n\t},\n\n\t \n\t{\n\t\t0x11, 0x5f, 0x01, 0x82, 0x10, 0x23, 0x00, 0x80,\n\t\t0x02, 0x1c, 0x00, 0xa1, 0x00, 0x36, 0x00, 0x1e,\n\t\t0x11, 0x29, 0x10, 0x59, 0x01, 0x82, 0x00, 0x80\n\t},\n\t \n\t{\n\t\t0x11, 0x98, 0x01, 0xc1, 0x10, 0x28, 0x00, 0x80,\n\t\t0x02, 0x74, 0x00, 0xbb, 0x00, 0x3f, 0x00, 0x10,\n\t\t0x11, 0x5a, 0x10, 0x67, 0x01, 0xc1, 0x00, 0x80\n\t},\n\t \n\t{\n\t\t0x00, 0x00, 0x03, 0x6F, 0x00, 0x00, 0x00, 0x10,\n\t\t0x03, 0x6F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10,\n\t\t0x00, 0x00, 0x00, 0x00, 0x03, 0x6F, 0x00, 0x10\n\t},\n};\n\nstatic inline u8 hdmi_readb(struct inno_hdmi *hdmi, u16 offset)\n{\n\treturn readl_relaxed(hdmi->regs + (offset) * 0x04);\n}\n\nstatic inline void hdmi_writeb(struct inno_hdmi *hdmi, u16 offset, u32 val)\n{\n\twritel_relaxed(val, hdmi->regs + (offset) * 0x04);\n}\n\nstatic inline void hdmi_modb(struct inno_hdmi *hdmi, u16 offset,\n\t\t\t     u32 msk, u32 val)\n{\n\tu8 temp = hdmi_readb(hdmi, offset) & ~msk;\n\n\ttemp |= val & msk;\n\thdmi_writeb(hdmi, offset, temp);\n}\n\nstatic void inno_hdmi_i2c_init(struct inno_hdmi *hdmi)\n{\n\tint ddc_bus_freq;\n\n\tddc_bus_freq = (hdmi->tmds_rate >> 2) / HDMI_SCL_RATE;\n\n\thdmi_writeb(hdmi, DDC_BUS_FREQ_L, ddc_bus_freq & 0xFF);\n\thdmi_writeb(hdmi, DDC_BUS_FREQ_H, (ddc_bus_freq >> 8) & 0xFF);\n\n\t \n\thdmi_writeb(hdmi, HDMI_INTERRUPT_MASK1, 0);\n\thdmi_writeb(hdmi, HDMI_INTERRUPT_STATUS1, m_INT_EDID_READY);\n}\n\nstatic void inno_hdmi_sys_power(struct inno_hdmi *hdmi, bool enable)\n{\n\tif (enable)\n\t\thdmi_modb(hdmi, HDMI_SYS_CTRL, m_POWER, v_PWR_ON);\n\telse\n\t\thdmi_modb(hdmi, HDMI_SYS_CTRL, m_POWER, v_PWR_OFF);\n}\n\nstatic void inno_hdmi_set_pwr_mode(struct inno_hdmi *hdmi, int mode)\n{\n\tswitch (mode) {\n\tcase NORMAL:\n\t\tinno_hdmi_sys_power(hdmi, false);\n\n\t\thdmi_writeb(hdmi, HDMI_PHY_PRE_EMPHASIS, 0x6f);\n\t\thdmi_writeb(hdmi, HDMI_PHY_DRIVER, 0xbb);\n\n\t\thdmi_writeb(hdmi, HDMI_PHY_SYS_CTL, 0x15);\n\t\thdmi_writeb(hdmi, HDMI_PHY_SYS_CTL, 0x14);\n\t\thdmi_writeb(hdmi, HDMI_PHY_SYS_CTL, 0x10);\n\t\thdmi_writeb(hdmi, HDMI_PHY_CHG_PWR, 0x0f);\n\t\thdmi_writeb(hdmi, HDMI_PHY_SYNC, 0x00);\n\t\thdmi_writeb(hdmi, HDMI_PHY_SYNC, 0x01);\n\n\t\tinno_hdmi_sys_power(hdmi, true);\n\t\tbreak;\n\n\tcase LOWER_PWR:\n\t\tinno_hdmi_sys_power(hdmi, false);\n\t\thdmi_writeb(hdmi, HDMI_PHY_DRIVER, 0x00);\n\t\thdmi_writeb(hdmi, HDMI_PHY_PRE_EMPHASIS, 0x00);\n\t\thdmi_writeb(hdmi, HDMI_PHY_CHG_PWR, 0x00);\n\t\thdmi_writeb(hdmi, HDMI_PHY_SYS_CTL, 0x15);\n\n\t\tbreak;\n\n\tdefault:\n\t\tDRM_DEV_ERROR(hdmi->dev, \"Unknown power mode %d\\n\", mode);\n\t}\n}\n\nstatic void inno_hdmi_reset(struct inno_hdmi *hdmi)\n{\n\tu32 val;\n\tu32 msk;\n\n\thdmi_modb(hdmi, HDMI_SYS_CTRL, m_RST_DIGITAL, v_NOT_RST_DIGITAL);\n\tudelay(100);\n\n\thdmi_modb(hdmi, HDMI_SYS_CTRL, m_RST_ANALOG, v_NOT_RST_ANALOG);\n\tudelay(100);\n\n\tmsk = m_REG_CLK_INV | m_REG_CLK_SOURCE | m_POWER | m_INT_POL;\n\tval = v_REG_CLK_INV | v_REG_CLK_SOURCE_SYS | v_PWR_ON | v_INT_POL_HIGH;\n\thdmi_modb(hdmi, HDMI_SYS_CTRL, msk, val);\n\n\tinno_hdmi_set_pwr_mode(hdmi, NORMAL);\n}\n\nstatic int inno_hdmi_upload_frame(struct inno_hdmi *hdmi, int setup_rc,\n\t\t\t\t  union hdmi_infoframe *frame, u32 frame_index,\n\t\t\t\t  u32 mask, u32 disable, u32 enable)\n{\n\tif (mask)\n\t\thdmi_modb(hdmi, HDMI_PACKET_SEND_AUTO, mask, disable);\n\n\thdmi_writeb(hdmi, HDMI_CONTROL_PACKET_BUF_INDEX, frame_index);\n\n\tif (setup_rc >= 0) {\n\t\tu8 packed_frame[HDMI_MAXIMUM_INFO_FRAME_SIZE];\n\t\tssize_t rc, i;\n\n\t\trc = hdmi_infoframe_pack(frame, packed_frame,\n\t\t\t\t\t sizeof(packed_frame));\n\t\tif (rc < 0)\n\t\t\treturn rc;\n\n\t\tfor (i = 0; i < rc; i++)\n\t\t\thdmi_writeb(hdmi, HDMI_CONTROL_PACKET_ADDR + i,\n\t\t\t\t    packed_frame[i]);\n\n\t\tif (mask)\n\t\t\thdmi_modb(hdmi, HDMI_PACKET_SEND_AUTO, mask, enable);\n\t}\n\n\treturn setup_rc;\n}\n\nstatic int inno_hdmi_config_video_vsi(struct inno_hdmi *hdmi,\n\t\t\t\t      struct drm_display_mode *mode)\n{\n\tunion hdmi_infoframe frame;\n\tint rc;\n\n\trc = drm_hdmi_vendor_infoframe_from_display_mode(&frame.vendor.hdmi,\n\t\t\t\t\t\t\t &hdmi->connector,\n\t\t\t\t\t\t\t mode);\n\n\treturn inno_hdmi_upload_frame(hdmi, rc, &frame, INFOFRAME_VSI,\n\t\tm_PACKET_VSI_EN, v_PACKET_VSI_EN(0), v_PACKET_VSI_EN(1));\n}\n\nstatic int inno_hdmi_config_video_avi(struct inno_hdmi *hdmi,\n\t\t\t\t      struct drm_display_mode *mode)\n{\n\tunion hdmi_infoframe frame;\n\tint rc;\n\n\trc = drm_hdmi_avi_infoframe_from_display_mode(&frame.avi,\n\t\t\t\t\t\t      &hdmi->connector,\n\t\t\t\t\t\t      mode);\n\n\tif (hdmi->hdmi_data.enc_out_format == HDMI_COLORSPACE_YUV444)\n\t\tframe.avi.colorspace = HDMI_COLORSPACE_YUV444;\n\telse if (hdmi->hdmi_data.enc_out_format == HDMI_COLORSPACE_YUV422)\n\t\tframe.avi.colorspace = HDMI_COLORSPACE_YUV422;\n\telse\n\t\tframe.avi.colorspace = HDMI_COLORSPACE_RGB;\n\n\treturn inno_hdmi_upload_frame(hdmi, rc, &frame, INFOFRAME_AVI, 0, 0, 0);\n}\n\nstatic int inno_hdmi_config_video_csc(struct inno_hdmi *hdmi)\n{\n\tstruct hdmi_data_info *data = &hdmi->hdmi_data;\n\tint c0_c2_change = 0;\n\tint csc_enable = 0;\n\tint csc_mode = 0;\n\tint auto_csc = 0;\n\tint value;\n\tint i;\n\n\t \n\thdmi_writeb(hdmi, HDMI_VIDEO_CONTRL1, v_DE_EXTERNAL |\n\t\t    v_VIDEO_INPUT_FORMAT(VIDEO_INPUT_SDR_RGB444));\n\n\t \n\tvalue = v_VIDEO_INPUT_BITS(VIDEO_INPUT_8BITS) |\n\t\tv_VIDEO_OUTPUT_COLOR(0) |\n\t\tv_VIDEO_INPUT_CSP(0);\n\thdmi_writeb(hdmi, HDMI_VIDEO_CONTRL2, value);\n\n\tif (data->enc_in_format == data->enc_out_format) {\n\t\tif ((data->enc_in_format == HDMI_COLORSPACE_RGB) ||\n\t\t    (data->enc_in_format >= HDMI_COLORSPACE_YUV444)) {\n\t\t\tvalue = v_SOF_DISABLE | v_COLOR_DEPTH_NOT_INDICATED(1);\n\t\t\thdmi_writeb(hdmi, HDMI_VIDEO_CONTRL3, value);\n\n\t\t\thdmi_modb(hdmi, HDMI_VIDEO_CONTRL,\n\t\t\t\t  m_VIDEO_AUTO_CSC | m_VIDEO_C0_C2_SWAP,\n\t\t\t\t  v_VIDEO_AUTO_CSC(AUTO_CSC_DISABLE) |\n\t\t\t\t  v_VIDEO_C0_C2_SWAP(C0_C2_CHANGE_DISABLE));\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tif (data->colorimetry == HDMI_COLORIMETRY_ITU_601) {\n\t\tif ((data->enc_in_format == HDMI_COLORSPACE_RGB) &&\n\t\t    (data->enc_out_format == HDMI_COLORSPACE_YUV444)) {\n\t\t\tcsc_mode = CSC_RGB_0_255_TO_ITU601_16_235_8BIT;\n\t\t\tauto_csc = AUTO_CSC_DISABLE;\n\t\t\tc0_c2_change = C0_C2_CHANGE_DISABLE;\n\t\t\tcsc_enable = v_CSC_ENABLE;\n\t\t} else if ((data->enc_in_format == HDMI_COLORSPACE_YUV444) &&\n\t\t\t   (data->enc_out_format == HDMI_COLORSPACE_RGB)) {\n\t\t\tcsc_mode = CSC_ITU601_16_235_TO_RGB_0_255_8BIT;\n\t\t\tauto_csc = AUTO_CSC_ENABLE;\n\t\t\tc0_c2_change = C0_C2_CHANGE_DISABLE;\n\t\t\tcsc_enable = v_CSC_DISABLE;\n\t\t}\n\t} else {\n\t\tif ((data->enc_in_format == HDMI_COLORSPACE_RGB) &&\n\t\t    (data->enc_out_format == HDMI_COLORSPACE_YUV444)) {\n\t\t\tcsc_mode = CSC_RGB_0_255_TO_ITU709_16_235_8BIT;\n\t\t\tauto_csc = AUTO_CSC_DISABLE;\n\t\t\tc0_c2_change = C0_C2_CHANGE_DISABLE;\n\t\t\tcsc_enable = v_CSC_ENABLE;\n\t\t} else if ((data->enc_in_format == HDMI_COLORSPACE_YUV444) &&\n\t\t\t   (data->enc_out_format == HDMI_COLORSPACE_RGB)) {\n\t\t\tcsc_mode = CSC_ITU709_16_235_TO_RGB_0_255_8BIT;\n\t\t\tauto_csc = AUTO_CSC_ENABLE;\n\t\t\tc0_c2_change = C0_C2_CHANGE_DISABLE;\n\t\t\tcsc_enable = v_CSC_DISABLE;\n\t\t}\n\t}\n\n\tfor (i = 0; i < 24; i++)\n\t\thdmi_writeb(hdmi, HDMI_VIDEO_CSC_COEF + i,\n\t\t\t    coeff_csc[csc_mode][i]);\n\n\tvalue = v_SOF_DISABLE | csc_enable | v_COLOR_DEPTH_NOT_INDICATED(1);\n\thdmi_writeb(hdmi, HDMI_VIDEO_CONTRL3, value);\n\thdmi_modb(hdmi, HDMI_VIDEO_CONTRL, m_VIDEO_AUTO_CSC |\n\t\t  m_VIDEO_C0_C2_SWAP, v_VIDEO_AUTO_CSC(auto_csc) |\n\t\t  v_VIDEO_C0_C2_SWAP(c0_c2_change));\n\n\treturn 0;\n}\n\nstatic int inno_hdmi_config_video_timing(struct inno_hdmi *hdmi,\n\t\t\t\t\t struct drm_display_mode *mode)\n{\n\tint value;\n\n\t \n\tvalue = v_EXTERANL_VIDEO(1);\n\tvalue |= mode->flags & DRM_MODE_FLAG_PHSYNC ?\n\t\t v_HSYNC_POLARITY(1) : v_HSYNC_POLARITY(0);\n\tvalue |= mode->flags & DRM_MODE_FLAG_PVSYNC ?\n\t\t v_VSYNC_POLARITY(1) : v_VSYNC_POLARITY(0);\n\tvalue |= mode->flags & DRM_MODE_FLAG_INTERLACE ?\n\t\t v_INETLACE(1) : v_INETLACE(0);\n\thdmi_writeb(hdmi, HDMI_VIDEO_TIMING_CTL, value);\n\n\t \n\tvalue = mode->htotal;\n\thdmi_writeb(hdmi, HDMI_VIDEO_EXT_HTOTAL_L, value & 0xFF);\n\thdmi_writeb(hdmi, HDMI_VIDEO_EXT_HTOTAL_H, (value >> 8) & 0xFF);\n\n\tvalue = mode->htotal - mode->hdisplay;\n\thdmi_writeb(hdmi, HDMI_VIDEO_EXT_HBLANK_L, value & 0xFF);\n\thdmi_writeb(hdmi, HDMI_VIDEO_EXT_HBLANK_H, (value >> 8) & 0xFF);\n\n\tvalue = mode->hsync_start - mode->hdisplay;\n\thdmi_writeb(hdmi, HDMI_VIDEO_EXT_HDELAY_L, value & 0xFF);\n\thdmi_writeb(hdmi, HDMI_VIDEO_EXT_HDELAY_H, (value >> 8) & 0xFF);\n\n\tvalue = mode->hsync_end - mode->hsync_start;\n\thdmi_writeb(hdmi, HDMI_VIDEO_EXT_HDURATION_L, value & 0xFF);\n\thdmi_writeb(hdmi, HDMI_VIDEO_EXT_HDURATION_H, (value >> 8) & 0xFF);\n\n\tvalue = mode->vtotal;\n\thdmi_writeb(hdmi, HDMI_VIDEO_EXT_VTOTAL_L, value & 0xFF);\n\thdmi_writeb(hdmi, HDMI_VIDEO_EXT_VTOTAL_H, (value >> 8) & 0xFF);\n\n\tvalue = mode->vtotal - mode->vdisplay;\n\thdmi_writeb(hdmi, HDMI_VIDEO_EXT_VBLANK, value & 0xFF);\n\n\tvalue = mode->vsync_start - mode->vdisplay;\n\thdmi_writeb(hdmi, HDMI_VIDEO_EXT_VDELAY, value & 0xFF);\n\n\tvalue = mode->vsync_end - mode->vsync_start;\n\thdmi_writeb(hdmi, HDMI_VIDEO_EXT_VDURATION, value & 0xFF);\n\n\thdmi_writeb(hdmi, HDMI_PHY_PRE_DIV_RATIO, 0x1e);\n\thdmi_writeb(hdmi, HDMI_PHY_FEEDBACK_DIV_RATIO_LOW, 0x2c);\n\thdmi_writeb(hdmi, HDMI_PHY_FEEDBACK_DIV_RATIO_HIGH, 0x01);\n\n\treturn 0;\n}\n\nstatic int inno_hdmi_setup(struct inno_hdmi *hdmi,\n\t\t\t   struct drm_display_mode *mode)\n{\n\tstruct drm_display_info *display = &hdmi->connector.display_info;\n\n\thdmi->hdmi_data.vic = drm_match_cea_mode(mode);\n\n\thdmi->hdmi_data.enc_in_format = HDMI_COLORSPACE_RGB;\n\thdmi->hdmi_data.enc_out_format = HDMI_COLORSPACE_RGB;\n\n\tif ((hdmi->hdmi_data.vic == 6) || (hdmi->hdmi_data.vic == 7) ||\n\t    (hdmi->hdmi_data.vic == 21) || (hdmi->hdmi_data.vic == 22) ||\n\t    (hdmi->hdmi_data.vic == 2) || (hdmi->hdmi_data.vic == 3) ||\n\t    (hdmi->hdmi_data.vic == 17) || (hdmi->hdmi_data.vic == 18))\n\t\thdmi->hdmi_data.colorimetry = HDMI_COLORIMETRY_ITU_601;\n\telse\n\t\thdmi->hdmi_data.colorimetry = HDMI_COLORIMETRY_ITU_709;\n\n\t \n\thdmi_modb(hdmi, HDMI_AV_MUTE, m_AUDIO_MUTE | m_VIDEO_BLACK,\n\t\t  v_AUDIO_MUTE(1) | v_VIDEO_MUTE(1));\n\n\t \n\thdmi_writeb(hdmi, HDMI_HDCP_CTRL,\n\t\t    v_HDMI_DVI(display->is_hdmi));\n\n\tinno_hdmi_config_video_timing(hdmi, mode);\n\n\tinno_hdmi_config_video_csc(hdmi);\n\n\tif (display->is_hdmi) {\n\t\tinno_hdmi_config_video_avi(hdmi, mode);\n\t\tinno_hdmi_config_video_vsi(hdmi, mode);\n\t}\n\n\t \n\thdmi->tmds_rate = mode->clock * 1000;\n\tinno_hdmi_i2c_init(hdmi);\n\n\t \n\thdmi_modb(hdmi, HDMI_AV_MUTE, m_AUDIO_MUTE | m_VIDEO_BLACK,\n\t\t  v_AUDIO_MUTE(0) | v_VIDEO_MUTE(0));\n\n\treturn 0;\n}\n\nstatic void inno_hdmi_encoder_mode_set(struct drm_encoder *encoder,\n\t\t\t\t       struct drm_display_mode *mode,\n\t\t\t\t       struct drm_display_mode *adj_mode)\n{\n\tstruct inno_hdmi *hdmi = encoder_to_inno_hdmi(encoder);\n\n\tinno_hdmi_setup(hdmi, adj_mode);\n\n\t \n\tdrm_mode_copy(&hdmi->previous_mode, adj_mode);\n}\n\nstatic void inno_hdmi_encoder_enable(struct drm_encoder *encoder)\n{\n\tstruct inno_hdmi *hdmi = encoder_to_inno_hdmi(encoder);\n\n\tinno_hdmi_set_pwr_mode(hdmi, NORMAL);\n}\n\nstatic void inno_hdmi_encoder_disable(struct drm_encoder *encoder)\n{\n\tstruct inno_hdmi *hdmi = encoder_to_inno_hdmi(encoder);\n\n\tinno_hdmi_set_pwr_mode(hdmi, LOWER_PWR);\n}\n\nstatic bool inno_hdmi_encoder_mode_fixup(struct drm_encoder *encoder,\n\t\t\t\t\t const struct drm_display_mode *mode,\n\t\t\t\t\t struct drm_display_mode *adj_mode)\n{\n\treturn true;\n}\n\nstatic int\ninno_hdmi_encoder_atomic_check(struct drm_encoder *encoder,\n\t\t\t       struct drm_crtc_state *crtc_state,\n\t\t\t       struct drm_connector_state *conn_state)\n{\n\tstruct rockchip_crtc_state *s = to_rockchip_crtc_state(crtc_state);\n\n\ts->output_mode = ROCKCHIP_OUT_MODE_P888;\n\ts->output_type = DRM_MODE_CONNECTOR_HDMIA;\n\n\treturn 0;\n}\n\nstatic struct drm_encoder_helper_funcs inno_hdmi_encoder_helper_funcs = {\n\t.enable     = inno_hdmi_encoder_enable,\n\t.disable    = inno_hdmi_encoder_disable,\n\t.mode_fixup = inno_hdmi_encoder_mode_fixup,\n\t.mode_set   = inno_hdmi_encoder_mode_set,\n\t.atomic_check = inno_hdmi_encoder_atomic_check,\n};\n\nstatic enum drm_connector_status\ninno_hdmi_connector_detect(struct drm_connector *connector, bool force)\n{\n\tstruct inno_hdmi *hdmi = connector_to_inno_hdmi(connector);\n\n\treturn (hdmi_readb(hdmi, HDMI_STATUS) & m_HOTPLUG) ?\n\t\tconnector_status_connected : connector_status_disconnected;\n}\n\nstatic int inno_hdmi_connector_get_modes(struct drm_connector *connector)\n{\n\tstruct inno_hdmi *hdmi = connector_to_inno_hdmi(connector);\n\tstruct edid *edid;\n\tint ret = 0;\n\n\tif (!hdmi->ddc)\n\t\treturn 0;\n\n\tedid = drm_get_edid(connector, hdmi->ddc);\n\tif (edid) {\n\t\thdmi->hdmi_data.sink_has_audio = drm_detect_monitor_audio(edid);\n\t\tdrm_connector_update_edid_property(connector, edid);\n\t\tret = drm_add_edid_modes(connector, edid);\n\t\tkfree(edid);\n\t}\n\n\treturn ret;\n}\n\nstatic enum drm_mode_status\ninno_hdmi_connector_mode_valid(struct drm_connector *connector,\n\t\t\t       struct drm_display_mode *mode)\n{\n\treturn MODE_OK;\n}\n\nstatic int\ninno_hdmi_probe_single_connector_modes(struct drm_connector *connector,\n\t\t\t\t       uint32_t maxX, uint32_t maxY)\n{\n\treturn drm_helper_probe_single_connector_modes(connector, 1920, 1080);\n}\n\nstatic void inno_hdmi_connector_destroy(struct drm_connector *connector)\n{\n\tdrm_connector_unregister(connector);\n\tdrm_connector_cleanup(connector);\n}\n\nstatic const struct drm_connector_funcs inno_hdmi_connector_funcs = {\n\t.fill_modes = inno_hdmi_probe_single_connector_modes,\n\t.detect = inno_hdmi_connector_detect,\n\t.destroy = inno_hdmi_connector_destroy,\n\t.reset = drm_atomic_helper_connector_reset,\n\t.atomic_duplicate_state = drm_atomic_helper_connector_duplicate_state,\n\t.atomic_destroy_state = drm_atomic_helper_connector_destroy_state,\n};\n\nstatic struct drm_connector_helper_funcs inno_hdmi_connector_helper_funcs = {\n\t.get_modes = inno_hdmi_connector_get_modes,\n\t.mode_valid = inno_hdmi_connector_mode_valid,\n};\n\nstatic int inno_hdmi_register(struct drm_device *drm, struct inno_hdmi *hdmi)\n{\n\tstruct drm_encoder *encoder = &hdmi->encoder.encoder;\n\tstruct device *dev = hdmi->dev;\n\n\tencoder->possible_crtcs = drm_of_find_possible_crtcs(drm, dev->of_node);\n\n\t \n\tif (encoder->possible_crtcs == 0)\n\t\treturn -EPROBE_DEFER;\n\n\tdrm_encoder_helper_add(encoder, &inno_hdmi_encoder_helper_funcs);\n\tdrm_simple_encoder_init(drm, encoder, DRM_MODE_ENCODER_TMDS);\n\n\thdmi->connector.polled = DRM_CONNECTOR_POLL_HPD;\n\n\tdrm_connector_helper_add(&hdmi->connector,\n\t\t\t\t &inno_hdmi_connector_helper_funcs);\n\tdrm_connector_init_with_ddc(drm, &hdmi->connector,\n\t\t\t\t    &inno_hdmi_connector_funcs,\n\t\t\t\t    DRM_MODE_CONNECTOR_HDMIA,\n\t\t\t\t    hdmi->ddc);\n\n\tdrm_connector_attach_encoder(&hdmi->connector, encoder);\n\n\treturn 0;\n}\n\nstatic irqreturn_t inno_hdmi_i2c_irq(struct inno_hdmi *hdmi)\n{\n\tstruct inno_hdmi_i2c *i2c = hdmi->i2c;\n\tu8 stat;\n\n\tstat = hdmi_readb(hdmi, HDMI_INTERRUPT_STATUS1);\n\tif (!(stat & m_INT_EDID_READY))\n\t\treturn IRQ_NONE;\n\n\t \n\thdmi_writeb(hdmi, HDMI_INTERRUPT_STATUS1, m_INT_EDID_READY);\n\n\tcomplete(&i2c->cmp);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic irqreturn_t inno_hdmi_hardirq(int irq, void *dev_id)\n{\n\tstruct inno_hdmi *hdmi = dev_id;\n\tirqreturn_t ret = IRQ_NONE;\n\tu8 interrupt;\n\n\tif (hdmi->i2c)\n\t\tret = inno_hdmi_i2c_irq(hdmi);\n\n\tinterrupt = hdmi_readb(hdmi, HDMI_STATUS);\n\tif (interrupt & m_INT_HOTPLUG) {\n\t\thdmi_modb(hdmi, HDMI_STATUS, m_INT_HOTPLUG, m_INT_HOTPLUG);\n\t\tret = IRQ_WAKE_THREAD;\n\t}\n\n\treturn ret;\n}\n\nstatic irqreturn_t inno_hdmi_irq(int irq, void *dev_id)\n{\n\tstruct inno_hdmi *hdmi = dev_id;\n\n\tdrm_helper_hpd_irq_event(hdmi->connector.dev);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int inno_hdmi_i2c_read(struct inno_hdmi *hdmi, struct i2c_msg *msgs)\n{\n\tint length = msgs->len;\n\tu8 *buf = msgs->buf;\n\tint ret;\n\n\tret = wait_for_completion_timeout(&hdmi->i2c->cmp, HZ / 10);\n\tif (!ret)\n\t\treturn -EAGAIN;\n\n\twhile (length--)\n\t\t*buf++ = hdmi_readb(hdmi, HDMI_EDID_FIFO_ADDR);\n\n\treturn 0;\n}\n\nstatic int inno_hdmi_i2c_write(struct inno_hdmi *hdmi, struct i2c_msg *msgs)\n{\n\t \n\tif ((msgs->len != 1) ||\n\t    ((msgs->addr != DDC_ADDR) && (msgs->addr != DDC_SEGMENT_ADDR)))\n\t\treturn -EINVAL;\n\n\treinit_completion(&hdmi->i2c->cmp);\n\n\tif (msgs->addr == DDC_SEGMENT_ADDR)\n\t\thdmi->i2c->segment_addr = msgs->buf[0];\n\tif (msgs->addr == DDC_ADDR)\n\t\thdmi->i2c->ddc_addr = msgs->buf[0];\n\n\t \n\thdmi_writeb(hdmi, HDMI_EDID_FIFO_OFFSET, 0x00);\n\n\t \n\thdmi_writeb(hdmi, HDMI_EDID_WORD_ADDR, hdmi->i2c->ddc_addr);\n\n\t \n\thdmi_writeb(hdmi, HDMI_EDID_SEGMENT_POINTER, hdmi->i2c->segment_addr);\n\n\treturn 0;\n}\n\nstatic int inno_hdmi_i2c_xfer(struct i2c_adapter *adap,\n\t\t\t      struct i2c_msg *msgs, int num)\n{\n\tstruct inno_hdmi *hdmi = i2c_get_adapdata(adap);\n\tstruct inno_hdmi_i2c *i2c = hdmi->i2c;\n\tint i, ret = 0;\n\n\tmutex_lock(&i2c->lock);\n\n\t \n\thdmi_writeb(hdmi, HDMI_INTERRUPT_MASK1, m_INT_EDID_READY);\n\thdmi_writeb(hdmi, HDMI_INTERRUPT_STATUS1, m_INT_EDID_READY);\n\n\tfor (i = 0; i < num; i++) {\n\t\tDRM_DEV_DEBUG(hdmi->dev,\n\t\t\t      \"xfer: num: %d/%d, len: %d, flags: %#x\\n\",\n\t\t\t      i + 1, num, msgs[i].len, msgs[i].flags);\n\n\t\tif (msgs[i].flags & I2C_M_RD)\n\t\t\tret = inno_hdmi_i2c_read(hdmi, &msgs[i]);\n\t\telse\n\t\t\tret = inno_hdmi_i2c_write(hdmi, &msgs[i]);\n\n\t\tif (ret < 0)\n\t\t\tbreak;\n\t}\n\n\tif (!ret)\n\t\tret = num;\n\n\t \n\thdmi_writeb(hdmi, HDMI_INTERRUPT_MASK1, 0);\n\n\tmutex_unlock(&i2c->lock);\n\n\treturn ret;\n}\n\nstatic u32 inno_hdmi_i2c_func(struct i2c_adapter *adapter)\n{\n\treturn I2C_FUNC_I2C | I2C_FUNC_SMBUS_EMUL;\n}\n\nstatic const struct i2c_algorithm inno_hdmi_algorithm = {\n\t.master_xfer\t= inno_hdmi_i2c_xfer,\n\t.functionality\t= inno_hdmi_i2c_func,\n};\n\nstatic struct i2c_adapter *inno_hdmi_i2c_adapter(struct inno_hdmi *hdmi)\n{\n\tstruct i2c_adapter *adap;\n\tstruct inno_hdmi_i2c *i2c;\n\tint ret;\n\n\ti2c = devm_kzalloc(hdmi->dev, sizeof(*i2c), GFP_KERNEL);\n\tif (!i2c)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tmutex_init(&i2c->lock);\n\tinit_completion(&i2c->cmp);\n\n\tadap = &i2c->adap;\n\tadap->class = I2C_CLASS_DDC;\n\tadap->owner = THIS_MODULE;\n\tadap->dev.parent = hdmi->dev;\n\tadap->dev.of_node = hdmi->dev->of_node;\n\tadap->algo = &inno_hdmi_algorithm;\n\tstrscpy(adap->name, \"Inno HDMI\", sizeof(adap->name));\n\ti2c_set_adapdata(adap, hdmi);\n\n\tret = i2c_add_adapter(adap);\n\tif (ret) {\n\t\tdev_warn(hdmi->dev, \"cannot add %s I2C adapter\\n\", adap->name);\n\t\tdevm_kfree(hdmi->dev, i2c);\n\t\treturn ERR_PTR(ret);\n\t}\n\n\thdmi->i2c = i2c;\n\n\tDRM_DEV_INFO(hdmi->dev, \"registered %s I2C bus driver\\n\", adap->name);\n\n\treturn adap;\n}\n\nstatic int inno_hdmi_bind(struct device *dev, struct device *master,\n\t\t\t\t void *data)\n{\n\tstruct platform_device *pdev = to_platform_device(dev);\n\tstruct drm_device *drm = data;\n\tstruct inno_hdmi *hdmi;\n\tint irq;\n\tint ret;\n\n\thdmi = devm_kzalloc(dev, sizeof(*hdmi), GFP_KERNEL);\n\tif (!hdmi)\n\t\treturn -ENOMEM;\n\n\thdmi->dev = dev;\n\thdmi->drm_dev = drm;\n\n\thdmi->regs = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(hdmi->regs))\n\t\treturn PTR_ERR(hdmi->regs);\n\n\thdmi->pclk = devm_clk_get(hdmi->dev, \"pclk\");\n\tif (IS_ERR(hdmi->pclk)) {\n\t\tDRM_DEV_ERROR(hdmi->dev, \"Unable to get HDMI pclk clk\\n\");\n\t\treturn PTR_ERR(hdmi->pclk);\n\t}\n\n\tret = clk_prepare_enable(hdmi->pclk);\n\tif (ret) {\n\t\tDRM_DEV_ERROR(hdmi->dev,\n\t\t\t      \"Cannot enable HDMI pclk clock: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tirq = platform_get_irq(pdev, 0);\n\tif (irq < 0) {\n\t\tret = irq;\n\t\tgoto err_disable_clk;\n\t}\n\n\tinno_hdmi_reset(hdmi);\n\n\thdmi->ddc = inno_hdmi_i2c_adapter(hdmi);\n\tif (IS_ERR(hdmi->ddc)) {\n\t\tret = PTR_ERR(hdmi->ddc);\n\t\thdmi->ddc = NULL;\n\t\tgoto err_disable_clk;\n\t}\n\n\t \n\thdmi->tmds_rate = clk_get_rate(hdmi->pclk);\n\tinno_hdmi_i2c_init(hdmi);\n\n\tret = inno_hdmi_register(drm, hdmi);\n\tif (ret)\n\t\tgoto err_put_adapter;\n\n\tdev_set_drvdata(dev, hdmi);\n\n\t \n\thdmi_modb(hdmi, HDMI_STATUS, m_MASK_INT_HOTPLUG, v_MASK_INT_HOTPLUG(1));\n\n\tret = devm_request_threaded_irq(dev, irq, inno_hdmi_hardirq,\n\t\t\t\t\tinno_hdmi_irq, IRQF_SHARED,\n\t\t\t\t\tdev_name(dev), hdmi);\n\tif (ret < 0)\n\t\tgoto err_cleanup_hdmi;\n\n\treturn 0;\nerr_cleanup_hdmi:\n\thdmi->connector.funcs->destroy(&hdmi->connector);\n\thdmi->encoder.encoder.funcs->destroy(&hdmi->encoder.encoder);\nerr_put_adapter:\n\ti2c_put_adapter(hdmi->ddc);\nerr_disable_clk:\n\tclk_disable_unprepare(hdmi->pclk);\n\treturn ret;\n}\n\nstatic void inno_hdmi_unbind(struct device *dev, struct device *master,\n\t\t\t     void *data)\n{\n\tstruct inno_hdmi *hdmi = dev_get_drvdata(dev);\n\n\thdmi->connector.funcs->destroy(&hdmi->connector);\n\thdmi->encoder.encoder.funcs->destroy(&hdmi->encoder.encoder);\n\n\ti2c_put_adapter(hdmi->ddc);\n\tclk_disable_unprepare(hdmi->pclk);\n}\n\nstatic const struct component_ops inno_hdmi_ops = {\n\t.bind\t= inno_hdmi_bind,\n\t.unbind\t= inno_hdmi_unbind,\n};\n\nstatic int inno_hdmi_probe(struct platform_device *pdev)\n{\n\treturn component_add(&pdev->dev, &inno_hdmi_ops);\n}\n\nstatic void inno_hdmi_remove(struct platform_device *pdev)\n{\n\tcomponent_del(&pdev->dev, &inno_hdmi_ops);\n}\n\nstatic const struct of_device_id inno_hdmi_dt_ids[] = {\n\t{ .compatible = \"rockchip,rk3036-inno-hdmi\",\n\t},\n\t{},\n};\nMODULE_DEVICE_TABLE(of, inno_hdmi_dt_ids);\n\nstruct platform_driver inno_hdmi_driver = {\n\t.probe  = inno_hdmi_probe,\n\t.remove_new = inno_hdmi_remove,\n\t.driver = {\n\t\t.name = \"innohdmi-rockchip\",\n\t\t.of_match_table = inno_hdmi_dt_ids,\n\t},\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}