{
  "module_name": "dw_hdmi-rockchip.c",
  "hash_id": "0d89e5618d739dd4673043dcbdf6c20b9950a472c778676adf07483dbf7e1120",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/rockchip/dw_hdmi-rockchip.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/mfd/syscon.h>\n#include <linux/module.h>\n#include <linux/platform_device.h>\n#include <linux/phy/phy.h>\n#include <linux/regmap.h>\n#include <linux/regulator/consumer.h>\n\n#include <drm/bridge/dw_hdmi.h>\n#include <drm/drm_edid.h>\n#include <drm/drm_of.h>\n#include <drm/drm_probe_helper.h>\n#include <drm/drm_simple_kms_helper.h>\n\n#include \"rockchip_drm_drv.h\"\n#include \"rockchip_drm_vop.h\"\n\n#define RK3228_GRF_SOC_CON2\t\t0x0408\n#define RK3228_HDMI_SDAIN_MSK\t\tBIT(14)\n#define RK3228_HDMI_SCLIN_MSK\t\tBIT(13)\n#define RK3228_GRF_SOC_CON6\t\t0x0418\n#define RK3228_HDMI_HPD_VSEL\t\tBIT(6)\n#define RK3228_HDMI_SDA_VSEL\t\tBIT(5)\n#define RK3228_HDMI_SCL_VSEL\t\tBIT(4)\n\n#define RK3288_GRF_SOC_CON6\t\t0x025C\n#define RK3288_HDMI_LCDC_SEL\t\tBIT(4)\n#define RK3328_GRF_SOC_CON2\t\t0x0408\n\n#define RK3328_HDMI_SDAIN_MSK\t\tBIT(11)\n#define RK3328_HDMI_SCLIN_MSK\t\tBIT(10)\n#define RK3328_HDMI_HPD_IOE\t\tBIT(2)\n#define RK3328_GRF_SOC_CON3\t\t0x040c\n \n#define RK3328_HDMI_SDA5V_GRF\t\tBIT(15)\n#define RK3328_HDMI_SCL5V_GRF\t\tBIT(14)\n#define RK3328_HDMI_HPD5V_GRF\t\tBIT(13)\n#define RK3328_HDMI_CEC5V_GRF\t\tBIT(12)\n#define RK3328_GRF_SOC_CON4\t\t0x0410\n#define RK3328_HDMI_HPD_SARADC\t\tBIT(13)\n#define RK3328_HDMI_CEC_5V\t\tBIT(11)\n#define RK3328_HDMI_SDA_5V\t\tBIT(10)\n#define RK3328_HDMI_SCL_5V\t\tBIT(9)\n#define RK3328_HDMI_HPD_5V\t\tBIT(8)\n\n#define RK3399_GRF_SOC_CON20\t\t0x6250\n#define RK3399_HDMI_LCDC_SEL\t\tBIT(6)\n\n#define RK3568_GRF_VO_CON1\t\t0x0364\n#define RK3568_HDMI_SDAIN_MSK\t\tBIT(15)\n#define RK3568_HDMI_SCLIN_MSK\t\tBIT(14)\n\n#define HIWORD_UPDATE(val, mask)\t(val | (mask) << 16)\n\n \nstruct rockchip_hdmi_chip_data {\n\tint\tlcdsel_grf_reg;\n\tu32\tlcdsel_big;\n\tu32\tlcdsel_lit;\n};\n\nstruct rockchip_hdmi {\n\tstruct device *dev;\n\tstruct regmap *regmap;\n\tstruct rockchip_encoder encoder;\n\tconst struct rockchip_hdmi_chip_data *chip_data;\n\tconst struct dw_hdmi_plat_data *plat_data;\n\tstruct clk *ref_clk;\n\tstruct clk *grf_clk;\n\tstruct dw_hdmi *hdmi;\n\tstruct regulator *avdd_0v9;\n\tstruct regulator *avdd_1v8;\n\tstruct phy *phy;\n};\n\nstatic struct rockchip_hdmi *to_rockchip_hdmi(struct drm_encoder *encoder)\n{\n\tstruct rockchip_encoder *rkencoder = to_rockchip_encoder(encoder);\n\n\treturn container_of(rkencoder, struct rockchip_hdmi, encoder);\n}\n\nstatic const struct dw_hdmi_mpll_config rockchip_mpll_cfg[] = {\n\t{\n\t\t27000000, {\n\t\t\t{ 0x00b3, 0x0000},\n\t\t\t{ 0x2153, 0x0000},\n\t\t\t{ 0x40f3, 0x0000}\n\t\t},\n\t}, {\n\t\t36000000, {\n\t\t\t{ 0x00b3, 0x0000},\n\t\t\t{ 0x2153, 0x0000},\n\t\t\t{ 0x40f3, 0x0000}\n\t\t},\n\t}, {\n\t\t40000000, {\n\t\t\t{ 0x00b3, 0x0000},\n\t\t\t{ 0x2153, 0x0000},\n\t\t\t{ 0x40f3, 0x0000}\n\t\t},\n\t}, {\n\t\t54000000, {\n\t\t\t{ 0x0072, 0x0001},\n\t\t\t{ 0x2142, 0x0001},\n\t\t\t{ 0x40a2, 0x0001},\n\t\t},\n\t}, {\n\t\t65000000, {\n\t\t\t{ 0x0072, 0x0001},\n\t\t\t{ 0x2142, 0x0001},\n\t\t\t{ 0x40a2, 0x0001},\n\t\t},\n\t}, {\n\t\t66000000, {\n\t\t\t{ 0x013e, 0x0003},\n\t\t\t{ 0x217e, 0x0002},\n\t\t\t{ 0x4061, 0x0002}\n\t\t},\n\t}, {\n\t\t74250000, {\n\t\t\t{ 0x0072, 0x0001},\n\t\t\t{ 0x2145, 0x0002},\n\t\t\t{ 0x4061, 0x0002}\n\t\t},\n\t}, {\n\t\t83500000, {\n\t\t\t{ 0x0072, 0x0001},\n\t\t},\n\t}, {\n\t\t108000000, {\n\t\t\t{ 0x0051, 0x0002},\n\t\t\t{ 0x2145, 0x0002},\n\t\t\t{ 0x4061, 0x0002}\n\t\t},\n\t}, {\n\t\t106500000, {\n\t\t\t{ 0x0051, 0x0002},\n\t\t\t{ 0x2145, 0x0002},\n\t\t\t{ 0x4061, 0x0002}\n\t\t},\n\t}, {\n\t\t146250000, {\n\t\t\t{ 0x0051, 0x0002},\n\t\t\t{ 0x2145, 0x0002},\n\t\t\t{ 0x4061, 0x0002}\n\t\t},\n\t}, {\n\t\t148500000, {\n\t\t\t{ 0x0051, 0x0003},\n\t\t\t{ 0x214c, 0x0003},\n\t\t\t{ 0x4064, 0x0003}\n\t\t},\n\t}, {\n\t\t340000000, {\n\t\t\t{ 0x0040, 0x0003 },\n\t\t\t{ 0x3b4c, 0x0003 },\n\t\t\t{ 0x5a64, 0x0003 },\n\t\t},\n\t}, {\n\t\t~0UL, {\n\t\t\t{ 0x00a0, 0x000a },\n\t\t\t{ 0x2001, 0x000f },\n\t\t\t{ 0x4002, 0x000f },\n\t\t},\n\t}\n};\n\nstatic const struct dw_hdmi_curr_ctrl rockchip_cur_ctr[] = {\n\t \n\t{\n\t\t40000000,  { 0x0018, 0x0018, 0x0018 },\n\t}, {\n\t\t65000000,  { 0x0028, 0x0028, 0x0028 },\n\t}, {\n\t\t66000000,  { 0x0038, 0x0038, 0x0038 },\n\t}, {\n\t\t74250000,  { 0x0028, 0x0038, 0x0038 },\n\t}, {\n\t\t83500000,  { 0x0028, 0x0038, 0x0038 },\n\t}, {\n\t\t146250000, { 0x0038, 0x0038, 0x0038 },\n\t}, {\n\t\t148500000, { 0x0000, 0x0038, 0x0038 },\n\t}, {\n\t\t600000000, { 0x0000, 0x0000, 0x0000 },\n\t}, {\n\t\t~0UL,      { 0x0000, 0x0000, 0x0000},\n\t}\n};\n\nstatic const struct dw_hdmi_phy_config rockchip_phy_config[] = {\n\t \n\t{ 74250000,  0x8009, 0x0004, 0x0272},\n\t{ 148500000, 0x802b, 0x0004, 0x028d},\n\t{ 297000000, 0x8039, 0x0005, 0x028d},\n\t{ ~0UL,\t     0x0000, 0x0000, 0x0000}\n};\n\nstatic int rockchip_hdmi_parse_dt(struct rockchip_hdmi *hdmi)\n{\n\tstruct device_node *np = hdmi->dev->of_node;\n\n\thdmi->regmap = syscon_regmap_lookup_by_phandle(np, \"rockchip,grf\");\n\tif (IS_ERR(hdmi->regmap)) {\n\t\tDRM_DEV_ERROR(hdmi->dev, \"Unable to get rockchip,grf\\n\");\n\t\treturn PTR_ERR(hdmi->regmap);\n\t}\n\n\thdmi->ref_clk = devm_clk_get_optional(hdmi->dev, \"ref\");\n\tif (!hdmi->ref_clk)\n\t\thdmi->ref_clk = devm_clk_get_optional(hdmi->dev, \"vpll\");\n\n\tif (PTR_ERR(hdmi->ref_clk) == -EPROBE_DEFER) {\n\t\treturn -EPROBE_DEFER;\n\t} else if (IS_ERR(hdmi->ref_clk)) {\n\t\tDRM_DEV_ERROR(hdmi->dev, \"failed to get reference clock\\n\");\n\t\treturn PTR_ERR(hdmi->ref_clk);\n\t}\n\n\thdmi->grf_clk = devm_clk_get(hdmi->dev, \"grf\");\n\tif (PTR_ERR(hdmi->grf_clk) == -ENOENT) {\n\t\thdmi->grf_clk = NULL;\n\t} else if (PTR_ERR(hdmi->grf_clk) == -EPROBE_DEFER) {\n\t\treturn -EPROBE_DEFER;\n\t} else if (IS_ERR(hdmi->grf_clk)) {\n\t\tDRM_DEV_ERROR(hdmi->dev, \"failed to get grf clock\\n\");\n\t\treturn PTR_ERR(hdmi->grf_clk);\n\t}\n\n\thdmi->avdd_0v9 = devm_regulator_get(hdmi->dev, \"avdd-0v9\");\n\tif (IS_ERR(hdmi->avdd_0v9))\n\t\treturn PTR_ERR(hdmi->avdd_0v9);\n\n\thdmi->avdd_1v8 = devm_regulator_get(hdmi->dev, \"avdd-1v8\");\n\tif (IS_ERR(hdmi->avdd_1v8))\n\t\treturn PTR_ERR(hdmi->avdd_1v8);\n\n\treturn 0;\n}\n\nstatic enum drm_mode_status\ndw_hdmi_rockchip_mode_valid(struct dw_hdmi *dw_hdmi, void *data,\n\t\t\t    const struct drm_display_info *info,\n\t\t\t    const struct drm_display_mode *mode)\n{\n\tstruct rockchip_hdmi *hdmi = data;\n\tconst struct dw_hdmi_mpll_config *mpll_cfg = rockchip_mpll_cfg;\n\tint pclk = mode->clock * 1000;\n\tbool exact_match = hdmi->plat_data->phy_force_vendor;\n\tint i;\n\n\tif (hdmi->ref_clk) {\n\t\tint rpclk = clk_round_rate(hdmi->ref_clk, pclk);\n\n\t\tif (abs(rpclk - pclk) > pclk / 1000)\n\t\t\treturn MODE_NOCLOCK;\n\t}\n\n\tfor (i = 0; mpll_cfg[i].mpixelclock != (~0UL); i++) {\n\t\t \n\t\tif (exact_match && pclk == mpll_cfg[i].mpixelclock)\n\t\t\treturn MODE_OK;\n\t\t \n\t\tif (!exact_match && pclk <= mpll_cfg[i].mpixelclock)\n\t\t\treturn MODE_OK;\n\t}\n\n\treturn MODE_BAD;\n}\n\nstatic void dw_hdmi_rockchip_encoder_disable(struct drm_encoder *encoder)\n{\n}\n\nstatic bool\ndw_hdmi_rockchip_encoder_mode_fixup(struct drm_encoder *encoder,\n\t\t\t\t    const struct drm_display_mode *mode,\n\t\t\t\t    struct drm_display_mode *adj_mode)\n{\n\treturn true;\n}\n\nstatic void dw_hdmi_rockchip_encoder_mode_set(struct drm_encoder *encoder,\n\t\t\t\t\t      struct drm_display_mode *mode,\n\t\t\t\t\t      struct drm_display_mode *adj_mode)\n{\n\tstruct rockchip_hdmi *hdmi = to_rockchip_hdmi(encoder);\n\n\tclk_set_rate(hdmi->ref_clk, adj_mode->clock * 1000);\n}\n\nstatic void dw_hdmi_rockchip_encoder_enable(struct drm_encoder *encoder)\n{\n\tstruct rockchip_hdmi *hdmi = to_rockchip_hdmi(encoder);\n\tu32 val;\n\tint ret;\n\n\tif (hdmi->chip_data->lcdsel_grf_reg < 0)\n\t\treturn;\n\n\tret = drm_of_encoder_active_endpoint_id(hdmi->dev->of_node, encoder);\n\tif (ret)\n\t\tval = hdmi->chip_data->lcdsel_lit;\n\telse\n\t\tval = hdmi->chip_data->lcdsel_big;\n\n\tret = clk_prepare_enable(hdmi->grf_clk);\n\tif (ret < 0) {\n\t\tDRM_DEV_ERROR(hdmi->dev, \"failed to enable grfclk %d\\n\", ret);\n\t\treturn;\n\t}\n\n\tret = regmap_write(hdmi->regmap, hdmi->chip_data->lcdsel_grf_reg, val);\n\tif (ret != 0)\n\t\tDRM_DEV_ERROR(hdmi->dev, \"Could not write to GRF: %d\\n\", ret);\n\n\tclk_disable_unprepare(hdmi->grf_clk);\n\tDRM_DEV_DEBUG(hdmi->dev, \"vop %s output to hdmi\\n\",\n\t\t      ret ? \"LIT\" : \"BIG\");\n}\n\nstatic int\ndw_hdmi_rockchip_encoder_atomic_check(struct drm_encoder *encoder,\n\t\t\t\t      struct drm_crtc_state *crtc_state,\n\t\t\t\t      struct drm_connector_state *conn_state)\n{\n\tstruct rockchip_crtc_state *s = to_rockchip_crtc_state(crtc_state);\n\n\ts->output_mode = ROCKCHIP_OUT_MODE_AAAA;\n\ts->output_type = DRM_MODE_CONNECTOR_HDMIA;\n\n\treturn 0;\n}\n\nstatic const struct drm_encoder_helper_funcs dw_hdmi_rockchip_encoder_helper_funcs = {\n\t.mode_fixup = dw_hdmi_rockchip_encoder_mode_fixup,\n\t.mode_set   = dw_hdmi_rockchip_encoder_mode_set,\n\t.enable     = dw_hdmi_rockchip_encoder_enable,\n\t.disable    = dw_hdmi_rockchip_encoder_disable,\n\t.atomic_check = dw_hdmi_rockchip_encoder_atomic_check,\n};\n\nstatic int dw_hdmi_rockchip_genphy_init(struct dw_hdmi *dw_hdmi, void *data,\n\t\t\t\t\tconst struct drm_display_info *display,\n\t\t\t\t\tconst struct drm_display_mode *mode)\n{\n\tstruct rockchip_hdmi *hdmi = (struct rockchip_hdmi *)data;\n\n\treturn phy_power_on(hdmi->phy);\n}\n\nstatic void dw_hdmi_rockchip_genphy_disable(struct dw_hdmi *dw_hdmi, void *data)\n{\n\tstruct rockchip_hdmi *hdmi = (struct rockchip_hdmi *)data;\n\n\tphy_power_off(hdmi->phy);\n}\n\nstatic void dw_hdmi_rk3228_setup_hpd(struct dw_hdmi *dw_hdmi, void *data)\n{\n\tstruct rockchip_hdmi *hdmi = (struct rockchip_hdmi *)data;\n\n\tdw_hdmi_phy_setup_hpd(dw_hdmi, data);\n\n\tregmap_write(hdmi->regmap,\n\t\tRK3228_GRF_SOC_CON6,\n\t\tHIWORD_UPDATE(RK3228_HDMI_HPD_VSEL | RK3228_HDMI_SDA_VSEL |\n\t\t\t      RK3228_HDMI_SCL_VSEL,\n\t\t\t      RK3228_HDMI_HPD_VSEL | RK3228_HDMI_SDA_VSEL |\n\t\t\t      RK3228_HDMI_SCL_VSEL));\n\n\tregmap_write(hdmi->regmap,\n\t\tRK3228_GRF_SOC_CON2,\n\t\tHIWORD_UPDATE(RK3228_HDMI_SDAIN_MSK | RK3228_HDMI_SCLIN_MSK,\n\t\t\t      RK3228_HDMI_SDAIN_MSK | RK3228_HDMI_SCLIN_MSK));\n}\n\nstatic enum drm_connector_status\ndw_hdmi_rk3328_read_hpd(struct dw_hdmi *dw_hdmi, void *data)\n{\n\tstruct rockchip_hdmi *hdmi = (struct rockchip_hdmi *)data;\n\tenum drm_connector_status status;\n\n\tstatus = dw_hdmi_phy_read_hpd(dw_hdmi, data);\n\n\tif (status == connector_status_connected)\n\t\tregmap_write(hdmi->regmap,\n\t\t\tRK3328_GRF_SOC_CON4,\n\t\t\tHIWORD_UPDATE(RK3328_HDMI_SDA_5V | RK3328_HDMI_SCL_5V,\n\t\t\t\t      RK3328_HDMI_SDA_5V | RK3328_HDMI_SCL_5V));\n\telse\n\t\tregmap_write(hdmi->regmap,\n\t\t\tRK3328_GRF_SOC_CON4,\n\t\t\tHIWORD_UPDATE(0, RK3328_HDMI_SDA_5V |\n\t\t\t\t\t RK3328_HDMI_SCL_5V));\n\treturn status;\n}\n\nstatic void dw_hdmi_rk3328_setup_hpd(struct dw_hdmi *dw_hdmi, void *data)\n{\n\tstruct rockchip_hdmi *hdmi = (struct rockchip_hdmi *)data;\n\n\tdw_hdmi_phy_setup_hpd(dw_hdmi, data);\n\n\t \n\tregmap_write(hdmi->regmap,\n\t\tRK3328_GRF_SOC_CON4,\n\t\tHIWORD_UPDATE(0, RK3328_HDMI_HPD_SARADC | RK3328_HDMI_CEC_5V |\n\t\t\t\t RK3328_HDMI_SDA_5V | RK3328_HDMI_SCL_5V |\n\t\t\t\t RK3328_HDMI_HPD_5V));\n\tregmap_write(hdmi->regmap,\n\t\tRK3328_GRF_SOC_CON3,\n\t\tHIWORD_UPDATE(0, RK3328_HDMI_SDA5V_GRF | RK3328_HDMI_SCL5V_GRF |\n\t\t\t\t RK3328_HDMI_HPD5V_GRF |\n\t\t\t\t RK3328_HDMI_CEC5V_GRF));\n\tregmap_write(hdmi->regmap,\n\t\tRK3328_GRF_SOC_CON2,\n\t\tHIWORD_UPDATE(RK3328_HDMI_SDAIN_MSK | RK3328_HDMI_SCLIN_MSK,\n\t\t\t      RK3328_HDMI_SDAIN_MSK | RK3328_HDMI_SCLIN_MSK |\n\t\t\t      RK3328_HDMI_HPD_IOE));\n}\n\nstatic const struct dw_hdmi_phy_ops rk3228_hdmi_phy_ops = {\n\t.init\t\t= dw_hdmi_rockchip_genphy_init,\n\t.disable\t= dw_hdmi_rockchip_genphy_disable,\n\t.read_hpd\t= dw_hdmi_phy_read_hpd,\n\t.update_hpd\t= dw_hdmi_phy_update_hpd,\n\t.setup_hpd\t= dw_hdmi_rk3228_setup_hpd,\n};\n\nstatic struct rockchip_hdmi_chip_data rk3228_chip_data = {\n\t.lcdsel_grf_reg = -1,\n};\n\nstatic const struct dw_hdmi_plat_data rk3228_hdmi_drv_data = {\n\t.mode_valid = dw_hdmi_rockchip_mode_valid,\n\t.mpll_cfg = rockchip_mpll_cfg,\n\t.cur_ctr = rockchip_cur_ctr,\n\t.phy_config = rockchip_phy_config,\n\t.phy_data = &rk3228_chip_data,\n\t.phy_ops = &rk3228_hdmi_phy_ops,\n\t.phy_name = \"inno_dw_hdmi_phy2\",\n\t.phy_force_vendor = true,\n};\n\nstatic struct rockchip_hdmi_chip_data rk3288_chip_data = {\n\t.lcdsel_grf_reg = RK3288_GRF_SOC_CON6,\n\t.lcdsel_big = HIWORD_UPDATE(0, RK3288_HDMI_LCDC_SEL),\n\t.lcdsel_lit = HIWORD_UPDATE(RK3288_HDMI_LCDC_SEL, RK3288_HDMI_LCDC_SEL),\n};\n\nstatic const struct dw_hdmi_plat_data rk3288_hdmi_drv_data = {\n\t.mode_valid = dw_hdmi_rockchip_mode_valid,\n\t.mpll_cfg   = rockchip_mpll_cfg,\n\t.cur_ctr    = rockchip_cur_ctr,\n\t.phy_config = rockchip_phy_config,\n\t.phy_data = &rk3288_chip_data,\n};\n\nstatic const struct dw_hdmi_phy_ops rk3328_hdmi_phy_ops = {\n\t.init\t\t= dw_hdmi_rockchip_genphy_init,\n\t.disable\t= dw_hdmi_rockchip_genphy_disable,\n\t.read_hpd\t= dw_hdmi_rk3328_read_hpd,\n\t.update_hpd\t= dw_hdmi_phy_update_hpd,\n\t.setup_hpd\t= dw_hdmi_rk3328_setup_hpd,\n};\n\nstatic struct rockchip_hdmi_chip_data rk3328_chip_data = {\n\t.lcdsel_grf_reg = -1,\n};\n\nstatic const struct dw_hdmi_plat_data rk3328_hdmi_drv_data = {\n\t.mode_valid = dw_hdmi_rockchip_mode_valid,\n\t.mpll_cfg = rockchip_mpll_cfg,\n\t.cur_ctr = rockchip_cur_ctr,\n\t.phy_config = rockchip_phy_config,\n\t.phy_data = &rk3328_chip_data,\n\t.phy_ops = &rk3328_hdmi_phy_ops,\n\t.phy_name = \"inno_dw_hdmi_phy2\",\n\t.phy_force_vendor = true,\n\t.use_drm_infoframe = true,\n};\n\nstatic struct rockchip_hdmi_chip_data rk3399_chip_data = {\n\t.lcdsel_grf_reg = RK3399_GRF_SOC_CON20,\n\t.lcdsel_big = HIWORD_UPDATE(0, RK3399_HDMI_LCDC_SEL),\n\t.lcdsel_lit = HIWORD_UPDATE(RK3399_HDMI_LCDC_SEL, RK3399_HDMI_LCDC_SEL),\n};\n\nstatic const struct dw_hdmi_plat_data rk3399_hdmi_drv_data = {\n\t.mode_valid = dw_hdmi_rockchip_mode_valid,\n\t.mpll_cfg   = rockchip_mpll_cfg,\n\t.cur_ctr    = rockchip_cur_ctr,\n\t.phy_config = rockchip_phy_config,\n\t.phy_data = &rk3399_chip_data,\n\t.use_drm_infoframe = true,\n};\n\nstatic struct rockchip_hdmi_chip_data rk3568_chip_data = {\n\t.lcdsel_grf_reg = -1,\n};\n\nstatic const struct dw_hdmi_plat_data rk3568_hdmi_drv_data = {\n\t.mode_valid = dw_hdmi_rockchip_mode_valid,\n\t.mpll_cfg   = rockchip_mpll_cfg,\n\t.cur_ctr    = rockchip_cur_ctr,\n\t.phy_config = rockchip_phy_config,\n\t.phy_data = &rk3568_chip_data,\n\t.use_drm_infoframe = true,\n};\n\nstatic const struct of_device_id dw_hdmi_rockchip_dt_ids[] = {\n\t{ .compatible = \"rockchip,rk3228-dw-hdmi\",\n\t  .data = &rk3228_hdmi_drv_data\n\t},\n\t{ .compatible = \"rockchip,rk3288-dw-hdmi\",\n\t  .data = &rk3288_hdmi_drv_data\n\t},\n\t{ .compatible = \"rockchip,rk3328-dw-hdmi\",\n\t  .data = &rk3328_hdmi_drv_data\n\t},\n\t{ .compatible = \"rockchip,rk3399-dw-hdmi\",\n\t  .data = &rk3399_hdmi_drv_data\n\t},\n\t{ .compatible = \"rockchip,rk3568-dw-hdmi\",\n\t  .data = &rk3568_hdmi_drv_data\n\t},\n\t{},\n};\nMODULE_DEVICE_TABLE(of, dw_hdmi_rockchip_dt_ids);\n\nstatic int dw_hdmi_rockchip_bind(struct device *dev, struct device *master,\n\t\t\t\t void *data)\n{\n\tstruct platform_device *pdev = to_platform_device(dev);\n\tstruct dw_hdmi_plat_data *plat_data;\n\tconst struct of_device_id *match;\n\tstruct drm_device *drm = data;\n\tstruct drm_encoder *encoder;\n\tstruct rockchip_hdmi *hdmi;\n\tint ret;\n\n\tif (!pdev->dev.of_node)\n\t\treturn -ENODEV;\n\n\thdmi = devm_kzalloc(&pdev->dev, sizeof(*hdmi), GFP_KERNEL);\n\tif (!hdmi)\n\t\treturn -ENOMEM;\n\n\tmatch = of_match_node(dw_hdmi_rockchip_dt_ids, pdev->dev.of_node);\n\tplat_data = devm_kmemdup(&pdev->dev, match->data,\n\t\t\t\t\t     sizeof(*plat_data), GFP_KERNEL);\n\tif (!plat_data)\n\t\treturn -ENOMEM;\n\n\thdmi->dev = &pdev->dev;\n\thdmi->plat_data = plat_data;\n\thdmi->chip_data = plat_data->phy_data;\n\tplat_data->phy_data = hdmi;\n\tplat_data->priv_data = hdmi;\n\tencoder = &hdmi->encoder.encoder;\n\n\tencoder->possible_crtcs = drm_of_find_possible_crtcs(drm, dev->of_node);\n\trockchip_drm_encoder_set_crtc_endpoint_id(&hdmi->encoder,\n\t\t\t\t\t\t  dev->of_node, 0, 0);\n\n\t \n\tif (encoder->possible_crtcs == 0)\n\t\treturn -EPROBE_DEFER;\n\n\tret = rockchip_hdmi_parse_dt(hdmi);\n\tif (ret) {\n\t\tif (ret != -EPROBE_DEFER)\n\t\t\tDRM_DEV_ERROR(hdmi->dev, \"Unable to parse OF data\\n\");\n\t\treturn ret;\n\t}\n\n\thdmi->phy = devm_phy_optional_get(dev, \"hdmi\");\n\tif (IS_ERR(hdmi->phy)) {\n\t\tret = PTR_ERR(hdmi->phy);\n\t\tif (ret != -EPROBE_DEFER)\n\t\t\tDRM_DEV_ERROR(hdmi->dev, \"failed to get phy\\n\");\n\t\treturn ret;\n\t}\n\n\tret = regulator_enable(hdmi->avdd_0v9);\n\tif (ret) {\n\t\tDRM_DEV_ERROR(hdmi->dev, \"failed to enable avdd0v9: %d\\n\", ret);\n\t\tgoto err_avdd_0v9;\n\t}\n\n\tret = regulator_enable(hdmi->avdd_1v8);\n\tif (ret) {\n\t\tDRM_DEV_ERROR(hdmi->dev, \"failed to enable avdd1v8: %d\\n\", ret);\n\t\tgoto err_avdd_1v8;\n\t}\n\n\tret = clk_prepare_enable(hdmi->ref_clk);\n\tif (ret) {\n\t\tDRM_DEV_ERROR(hdmi->dev, \"Failed to enable HDMI reference clock: %d\\n\",\n\t\t\t      ret);\n\t\tgoto err_clk;\n\t}\n\n\tif (hdmi->chip_data == &rk3568_chip_data) {\n\t\tregmap_write(hdmi->regmap, RK3568_GRF_VO_CON1,\n\t\t\t     HIWORD_UPDATE(RK3568_HDMI_SDAIN_MSK |\n\t\t\t\t\t   RK3568_HDMI_SCLIN_MSK,\n\t\t\t\t\t   RK3568_HDMI_SDAIN_MSK |\n\t\t\t\t\t   RK3568_HDMI_SCLIN_MSK));\n\t}\n\n\tdrm_encoder_helper_add(encoder, &dw_hdmi_rockchip_encoder_helper_funcs);\n\tdrm_simple_encoder_init(drm, encoder, DRM_MODE_ENCODER_TMDS);\n\n\tplatform_set_drvdata(pdev, hdmi);\n\n\thdmi->hdmi = dw_hdmi_bind(pdev, encoder, plat_data);\n\n\t \n\tif (IS_ERR(hdmi->hdmi)) {\n\t\tret = PTR_ERR(hdmi->hdmi);\n\t\tgoto err_bind;\n\t}\n\n\treturn 0;\n\nerr_bind:\n\tdrm_encoder_cleanup(encoder);\n\tclk_disable_unprepare(hdmi->ref_clk);\nerr_clk:\n\tregulator_disable(hdmi->avdd_1v8);\nerr_avdd_1v8:\n\tregulator_disable(hdmi->avdd_0v9);\nerr_avdd_0v9:\n\treturn ret;\n}\n\nstatic void dw_hdmi_rockchip_unbind(struct device *dev, struct device *master,\n\t\t\t\t    void *data)\n{\n\tstruct rockchip_hdmi *hdmi = dev_get_drvdata(dev);\n\n\tdw_hdmi_unbind(hdmi->hdmi);\n\tdrm_encoder_cleanup(&hdmi->encoder.encoder);\n\tclk_disable_unprepare(hdmi->ref_clk);\n\n\tregulator_disable(hdmi->avdd_1v8);\n\tregulator_disable(hdmi->avdd_0v9);\n}\n\nstatic const struct component_ops dw_hdmi_rockchip_ops = {\n\t.bind\t= dw_hdmi_rockchip_bind,\n\t.unbind\t= dw_hdmi_rockchip_unbind,\n};\n\nstatic int dw_hdmi_rockchip_probe(struct platform_device *pdev)\n{\n\treturn component_add(&pdev->dev, &dw_hdmi_rockchip_ops);\n}\n\nstatic void dw_hdmi_rockchip_remove(struct platform_device *pdev)\n{\n\tcomponent_del(&pdev->dev, &dw_hdmi_rockchip_ops);\n}\n\nstatic int __maybe_unused dw_hdmi_rockchip_resume(struct device *dev)\n{\n\tstruct rockchip_hdmi *hdmi = dev_get_drvdata(dev);\n\n\tdw_hdmi_resume(hdmi->hdmi);\n\n\treturn 0;\n}\n\nstatic const struct dev_pm_ops dw_hdmi_rockchip_pm = {\n\tSET_SYSTEM_SLEEP_PM_OPS(NULL, dw_hdmi_rockchip_resume)\n};\n\nstruct platform_driver dw_hdmi_rockchip_pltfm_driver = {\n\t.probe  = dw_hdmi_rockchip_probe,\n\t.remove_new = dw_hdmi_rockchip_remove,\n\t.driver = {\n\t\t.name = \"dwhdmi-rockchip\",\n\t\t.pm = &dw_hdmi_rockchip_pm,\n\t\t.of_match_table = dw_hdmi_rockchip_dt_ids,\n\t},\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}