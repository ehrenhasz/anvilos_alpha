{
  "module_name": "rockchip_drm_vop.h",
  "hash_id": "d7443dd9f2521b4f3811ac150526d6f1e7ee6849bc7e309f05797e7f13a40ebc",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/rockchip/rockchip_drm_vop.h",
  "human_readable_source": " \n \n\n#ifndef _ROCKCHIP_DRM_VOP_H\n#define _ROCKCHIP_DRM_VOP_H\n\n \n#define VOP_VERSION(major, minor)\t((major) << 8 | (minor))\n#define VOP_MAJOR(version)\t\t((version) >> 8)\n#define VOP_MINOR(version)\t\t((version) & 0xff)\n\n#define NUM_YUV2YUV_COEFFICIENTS 12\n\n \n#define ROCKCHIP_AFBC_MOD \\\n\tDRM_FORMAT_MOD_ARM_AFBC( \\\n\t\tAFBC_FORMAT_MOD_BLOCK_SIZE_16x16 | AFBC_FORMAT_MOD_SPARSE \\\n\t\t\t| AFBC_FORMAT_MOD_YTR \\\n\t)\n\nenum vop_data_format {\n\tVOP_FMT_ARGB8888 = 0,\n\tVOP_FMT_RGB888,\n\tVOP_FMT_RGB565,\n\tVOP_FMT_YUV420SP = 4,\n\tVOP_FMT_YUV422SP,\n\tVOP_FMT_YUV444SP,\n};\n\nstruct vop_rect {\n\tint width;\n\tint height;\n};\n\nstruct vop_reg {\n\tuint32_t mask;\n\tuint16_t offset;\n\tuint8_t shift;\n\tbool write_mask;\n\tbool relaxed;\n};\n\nstruct vop_afbc {\n\tstruct vop_reg enable;\n\tstruct vop_reg win_sel;\n\tstruct vop_reg format;\n\tstruct vop_reg rb_swap;\n\tstruct vop_reg uv_swap;\n\tstruct vop_reg auto_gating_en;\n\tstruct vop_reg block_split_en;\n\tstruct vop_reg pic_vir_width;\n\tstruct vop_reg tile_num;\n\tstruct vop_reg hreg_block_split;\n\tstruct vop_reg pic_offset;\n\tstruct vop_reg pic_size;\n\tstruct vop_reg dsp_offset;\n\tstruct vop_reg transform_offset;\n\tstruct vop_reg hdr_ptr;\n\tstruct vop_reg half_block_en;\n\tstruct vop_reg xmirror;\n\tstruct vop_reg ymirror;\n\tstruct vop_reg rotate_270;\n\tstruct vop_reg rotate_90;\n\tstruct vop_reg rstn;\n};\n\nstruct vop_modeset {\n\tstruct vop_reg htotal_pw;\n\tstruct vop_reg hact_st_end;\n\tstruct vop_reg hpost_st_end;\n\tstruct vop_reg vtotal_pw;\n\tstruct vop_reg vact_st_end;\n\tstruct vop_reg vpost_st_end;\n};\n\nstruct vop_output {\n\tstruct vop_reg pin_pol;\n\tstruct vop_reg dp_pin_pol;\n\tstruct vop_reg dp_dclk_pol;\n\tstruct vop_reg edp_pin_pol;\n\tstruct vop_reg edp_dclk_pol;\n\tstruct vop_reg hdmi_pin_pol;\n\tstruct vop_reg hdmi_dclk_pol;\n\tstruct vop_reg mipi_pin_pol;\n\tstruct vop_reg mipi_dclk_pol;\n\tstruct vop_reg rgb_pin_pol;\n\tstruct vop_reg rgb_dclk_pol;\n\tstruct vop_reg dp_en;\n\tstruct vop_reg edp_en;\n\tstruct vop_reg hdmi_en;\n\tstruct vop_reg mipi_en;\n\tstruct vop_reg mipi_dual_channel_en;\n\tstruct vop_reg rgb_en;\n};\n\nstruct vop_common {\n\tstruct vop_reg cfg_done;\n\tstruct vop_reg dsp_blank;\n\tstruct vop_reg data_blank;\n\tstruct vop_reg pre_dither_down;\n\tstruct vop_reg dither_down_sel;\n\tstruct vop_reg dither_down_mode;\n\tstruct vop_reg dither_down_en;\n\tstruct vop_reg dither_up;\n\tstruct vop_reg dsp_lut_en;\n\tstruct vop_reg update_gamma_lut;\n\tstruct vop_reg lut_buffer_index;\n\tstruct vop_reg gate_en;\n\tstruct vop_reg mmu_en;\n\tstruct vop_reg out_mode;\n\tstruct vop_reg standby;\n};\n\nstruct vop_misc {\n\tstruct vop_reg global_regdone_en;\n};\n\nstruct vop_intr {\n\tconst int *intrs;\n\tuint32_t nintrs;\n\n\tstruct vop_reg line_flag_num[2];\n\tstruct vop_reg enable;\n\tstruct vop_reg clear;\n\tstruct vop_reg status;\n};\n\nstruct vop_scl_extension {\n\tstruct vop_reg cbcr_vsd_mode;\n\tstruct vop_reg cbcr_vsu_mode;\n\tstruct vop_reg cbcr_hsd_mode;\n\tstruct vop_reg cbcr_ver_scl_mode;\n\tstruct vop_reg cbcr_hor_scl_mode;\n\tstruct vop_reg yrgb_vsd_mode;\n\tstruct vop_reg yrgb_vsu_mode;\n\tstruct vop_reg yrgb_hsd_mode;\n\tstruct vop_reg yrgb_ver_scl_mode;\n\tstruct vop_reg yrgb_hor_scl_mode;\n\tstruct vop_reg line_load_mode;\n\tstruct vop_reg cbcr_axi_gather_num;\n\tstruct vop_reg yrgb_axi_gather_num;\n\tstruct vop_reg vsd_cbcr_gt2;\n\tstruct vop_reg vsd_cbcr_gt4;\n\tstruct vop_reg vsd_yrgb_gt2;\n\tstruct vop_reg vsd_yrgb_gt4;\n\tstruct vop_reg bic_coe_sel;\n\tstruct vop_reg cbcr_axi_gather_en;\n\tstruct vop_reg yrgb_axi_gather_en;\n\tstruct vop_reg lb_mode;\n};\n\nstruct vop_scl_regs {\n\tconst struct vop_scl_extension *ext;\n\n\tstruct vop_reg scale_yrgb_x;\n\tstruct vop_reg scale_yrgb_y;\n\tstruct vop_reg scale_cbcr_x;\n\tstruct vop_reg scale_cbcr_y;\n};\n\nstruct vop_yuv2yuv_phy {\n\tstruct vop_reg y2r_coefficients[NUM_YUV2YUV_COEFFICIENTS];\n};\n\nstruct vop_win_phy {\n\tconst struct vop_scl_regs *scl;\n\tconst uint32_t *data_formats;\n\tuint32_t nformats;\n\tconst uint64_t *format_modifiers;\n\n\tstruct vop_reg enable;\n\tstruct vop_reg gate;\n\tstruct vop_reg format;\n\tstruct vop_reg rb_swap;\n\tstruct vop_reg uv_swap;\n\tstruct vop_reg act_info;\n\tstruct vop_reg dsp_info;\n\tstruct vop_reg dsp_st;\n\tstruct vop_reg yrgb_mst;\n\tstruct vop_reg uv_mst;\n\tstruct vop_reg yrgb_vir;\n\tstruct vop_reg uv_vir;\n\tstruct vop_reg y_mir_en;\n\tstruct vop_reg x_mir_en;\n\n\tstruct vop_reg dst_alpha_ctl;\n\tstruct vop_reg src_alpha_ctl;\n\tstruct vop_reg alpha_pre_mul;\n\tstruct vop_reg alpha_mode;\n\tstruct vop_reg alpha_en;\n\tstruct vop_reg channel;\n};\n\nstruct vop_win_yuv2yuv_data {\n\tuint32_t base;\n\tconst struct vop_yuv2yuv_phy *phy;\n\tstruct vop_reg y2r_en;\n};\n\nstruct vop_win_data {\n\tuint32_t base;\n\tconst struct vop_win_phy *phy;\n\tenum drm_plane_type type;\n};\n\nstruct vop_data {\n\tuint32_t version;\n\tconst struct vop_intr *intr;\n\tconst struct vop_common *common;\n\tconst struct vop_misc *misc;\n\tconst struct vop_modeset *modeset;\n\tconst struct vop_output *output;\n\tconst struct vop_afbc *afbc;\n\tconst struct vop_win_yuv2yuv_data *win_yuv2yuv;\n\tconst struct vop_win_data *win;\n\tunsigned int win_size;\n\tunsigned int lut_size;\n\tstruct vop_rect max_output;\n\n#define VOP_FEATURE_OUTPUT_RGB10\tBIT(0)\n#define VOP_FEATURE_INTERNAL_RGB\tBIT(1)\n\tu64 feature;\n};\n\n \n#define DSP_HOLD_VALID_INTR\t\t(1 << 0)\n#define FS_INTR\t\t\t\t(1 << 1)\n#define LINE_FLAG_INTR\t\t\t(1 << 2)\n#define BUS_ERROR_INTR\t\t\t(1 << 3)\n\n#define INTR_MASK\t\t\t(DSP_HOLD_VALID_INTR | FS_INTR | \\\n\t\t\t\t\t LINE_FLAG_INTR | BUS_ERROR_INTR)\n\n#define DSP_HOLD_VALID_INTR_EN(x)\t((x) << 4)\n#define FS_INTR_EN(x)\t\t\t((x) << 5)\n#define LINE_FLAG_INTR_EN(x)\t\t((x) << 6)\n#define BUS_ERROR_INTR_EN(x)\t\t((x) << 7)\n#define DSP_HOLD_VALID_INTR_MASK\t(1 << 4)\n#define FS_INTR_MASK\t\t\t(1 << 5)\n#define LINE_FLAG_INTR_MASK\t\t(1 << 6)\n#define BUS_ERROR_INTR_MASK\t\t(1 << 7)\n\n#define INTR_CLR_SHIFT\t\t\t8\n#define DSP_HOLD_VALID_INTR_CLR\t\t(1 << (INTR_CLR_SHIFT + 0))\n#define FS_INTR_CLR\t\t\t(1 << (INTR_CLR_SHIFT + 1))\n#define LINE_FLAG_INTR_CLR\t\t(1 << (INTR_CLR_SHIFT + 2))\n#define BUS_ERROR_INTR_CLR\t\t(1 << (INTR_CLR_SHIFT + 3))\n\n#define DSP_LINE_NUM(x)\t\t\t(((x) & 0x1fff) << 12)\n#define DSP_LINE_NUM_MASK\t\t(0x1fff << 12)\n\n \n#define SRC_FADING_VALUE(x)\t\t(((x) & 0xff) << 24)\n#define SRC_GLOBAL_ALPHA(x)\t\t(((x) & 0xff) << 16)\n#define SRC_FACTOR_M0(x)\t\t(((x) & 0x7) << 6)\n#define SRC_ALPHA_CAL_M0(x)\t\t(((x) & 0x1) << 5)\n#define SRC_BLEND_M0(x)\t\t\t(((x) & 0x3) << 3)\n#define SRC_ALPHA_M0(x)\t\t\t(((x) & 0x1) << 2)\n#define SRC_COLOR_M0(x)\t\t\t(((x) & 0x1) << 1)\n#define SRC_ALPHA_EN(x)\t\t\t(((x) & 0x1) << 0)\n \n#define DST_FACTOR_M0(x)\t\t(((x) & 0x7) << 6)\n\n \n#define ROCKCHIP_OUT_MODE_P888\t0\n#define ROCKCHIP_OUT_MODE_P666\t1\n#define ROCKCHIP_OUT_MODE_P565\t2\n \n#define ROCKCHIP_OUT_MODE_AAAA\t15\n\n \n#define ROCKCHIP_OUTPUT_DSI_DUAL\tBIT(0)\n\nenum alpha_mode {\n\tALPHA_STRAIGHT,\n\tALPHA_INVERSE,\n};\n\nenum global_blend_mode {\n\tALPHA_GLOBAL,\n\tALPHA_PER_PIX,\n\tALPHA_PER_PIX_GLOBAL,\n};\n\nenum alpha_cal_mode {\n\tALPHA_SATURATION,\n\tALPHA_NO_SATURATION,\n};\n\nenum color_mode {\n\tALPHA_SRC_PRE_MUL,\n\tALPHA_SRC_NO_PRE_MUL,\n};\n\nenum factor_mode {\n\tALPHA_ZERO,\n\tALPHA_ONE,\n\tALPHA_SRC,\n\tALPHA_SRC_INVERSE,\n\tALPHA_SRC_GLOBAL,\n};\n\nenum scale_mode {\n\tSCALE_NONE = 0x0,\n\tSCALE_UP   = 0x1,\n\tSCALE_DOWN = 0x2\n};\n\nenum lb_mode {\n\tLB_YUV_3840X5 = 0x0,\n\tLB_YUV_2560X8 = 0x1,\n\tLB_RGB_3840X2 = 0x2,\n\tLB_RGB_2560X4 = 0x3,\n\tLB_RGB_1920X5 = 0x4,\n\tLB_RGB_1280X8 = 0x5\n};\n\nenum sacle_up_mode {\n\tSCALE_UP_BIL = 0x0,\n\tSCALE_UP_BIC = 0x1\n};\n\nenum scale_down_mode {\n\tSCALE_DOWN_BIL = 0x0,\n\tSCALE_DOWN_AVG = 0x1\n};\n\nenum dither_down_mode {\n\tRGB888_TO_RGB565 = 0x0,\n\tRGB888_TO_RGB666 = 0x1\n};\n\nenum dither_down_mode_sel {\n\tDITHER_DOWN_ALLEGRO = 0x0,\n\tDITHER_DOWN_FRC = 0x1\n};\n\nenum vop_pol {\n\tHSYNC_POSITIVE = 0,\n\tVSYNC_POSITIVE = 1,\n\tDEN_NEGATIVE   = 2\n};\n\n#define FRAC_16_16(mult, div)    (((mult) << 16) / (div))\n#define SCL_FT_DEFAULT_FIXPOINT_SHIFT\t12\n#define SCL_MAX_VSKIPLINES\t\t4\n#define MIN_SCL_FT_AFTER_VSKIP\t\t1\n\nstatic inline uint16_t scl_cal_scale(int src, int dst, int shift)\n{\n\treturn ((src * 2 - 3) << (shift - 1)) / (dst - 1);\n}\n\nstatic inline uint16_t scl_cal_scale2(int src, int dst)\n{\n\treturn ((src - 1) << 12) / (dst - 1);\n}\n\n#define GET_SCL_FT_BILI_DN(src, dst)\tscl_cal_scale(src, dst, 12)\n#define GET_SCL_FT_BILI_UP(src, dst)\tscl_cal_scale(src, dst, 16)\n#define GET_SCL_FT_BIC(src, dst)\tscl_cal_scale(src, dst, 16)\n\nstatic inline uint16_t scl_get_bili_dn_vskip(int src_h, int dst_h,\n\t\t\t\t\t     int vskiplines)\n{\n\tint act_height;\n\n\tact_height = DIV_ROUND_UP(src_h, vskiplines);\n\n\tif (act_height == dst_h)\n\t\treturn GET_SCL_FT_BILI_DN(src_h, dst_h) / vskiplines;\n\n\treturn GET_SCL_FT_BILI_DN(act_height, dst_h);\n}\n\nstatic inline enum scale_mode scl_get_scl_mode(int src, int dst)\n{\n\tif (src < dst)\n\t\treturn SCALE_UP;\n\telse if (src > dst)\n\t\treturn SCALE_DOWN;\n\n\treturn SCALE_NONE;\n}\n\nstatic inline int scl_get_vskiplines(uint32_t srch, uint32_t dsth)\n{\n\tuint32_t vskiplines;\n\n\tfor (vskiplines = SCL_MAX_VSKIPLINES; vskiplines > 1; vskiplines /= 2)\n\t\tif (srch >= vskiplines * dsth * MIN_SCL_FT_AFTER_VSKIP)\n\t\t\tbreak;\n\n\treturn vskiplines;\n}\n\nstatic inline int scl_vop_cal_lb_mode(int width, bool is_yuv)\n{\n\tint lb_mode;\n\n\tif (is_yuv) {\n\t\tif (width > 1280)\n\t\t\tlb_mode = LB_YUV_3840X5;\n\t\telse\n\t\t\tlb_mode = LB_YUV_2560X8;\n\t} else {\n\t\tif (width > 2560)\n\t\t\tlb_mode = LB_RGB_3840X2;\n\t\telse if (width > 1920)\n\t\t\tlb_mode = LB_RGB_2560X4;\n\t\telse\n\t\t\tlb_mode = LB_RGB_1920X5;\n\t}\n\n\treturn lb_mode;\n}\n\nextern const struct component_ops vop_component_ops;\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}