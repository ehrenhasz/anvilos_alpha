{
  "module_name": "rockchip_rgb.c",
  "hash_id": "756a8a6edb33cbc542c39d44f7a0e070b5db85bfee333e054adb63a0c282c29b",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/rockchip/rockchip_rgb.c",
  "human_readable_source": "\n \n\n#include <linux/component.h>\n#include <linux/media-bus-format.h>\n#include <linux/of_graph.h>\n\n#include <drm/display/drm_dp_helper.h>\n#include <drm/drm_atomic_helper.h>\n#include <drm/drm_bridge.h>\n#include <drm/drm_bridge_connector.h>\n#include <drm/drm_of.h>\n#include <drm/drm_panel.h>\n#include <drm/drm_probe_helper.h>\n#include <drm/drm_simple_kms_helper.h>\n\n#include \"rockchip_drm_drv.h\"\n#include \"rockchip_drm_vop.h\"\n#include \"rockchip_rgb.h\"\n\nstruct rockchip_rgb {\n\tstruct device *dev;\n\tstruct drm_device *drm_dev;\n\tstruct drm_bridge *bridge;\n\tstruct rockchip_encoder encoder;\n\tstruct drm_connector connector;\n\tint output_mode;\n};\n\nstatic int\nrockchip_rgb_encoder_atomic_check(struct drm_encoder *encoder,\n\t\t\t\t   struct drm_crtc_state *crtc_state,\n\t\t\t\t   struct drm_connector_state *conn_state)\n{\n\tstruct rockchip_crtc_state *s = to_rockchip_crtc_state(crtc_state);\n\tstruct drm_connector *connector = conn_state->connector;\n\tstruct drm_display_info *info = &connector->display_info;\n\tu32 bus_format;\n\n\tif (info->num_bus_formats)\n\t\tbus_format = info->bus_formats[0];\n\telse\n\t\tbus_format = MEDIA_BUS_FMT_RGB888_1X24;\n\n\tswitch (bus_format) {\n\tcase MEDIA_BUS_FMT_RGB666_1X18:\n\t\ts->output_mode = ROCKCHIP_OUT_MODE_P666;\n\t\tbreak;\n\tcase MEDIA_BUS_FMT_RGB565_1X16:\n\t\ts->output_mode = ROCKCHIP_OUT_MODE_P565;\n\t\tbreak;\n\tcase MEDIA_BUS_FMT_RGB888_1X24:\n\tcase MEDIA_BUS_FMT_RGB666_1X24_CPADHI:\n\tdefault:\n\t\ts->output_mode = ROCKCHIP_OUT_MODE_P888;\n\t\tbreak;\n\t}\n\n\ts->output_type = DRM_MODE_CONNECTOR_LVDS;\n\n\treturn 0;\n}\n\nstatic const\nstruct drm_encoder_helper_funcs rockchip_rgb_encoder_helper_funcs = {\n\t.atomic_check = rockchip_rgb_encoder_atomic_check,\n};\n\nstruct rockchip_rgb *rockchip_rgb_init(struct device *dev,\n\t\t\t\t       struct drm_crtc *crtc,\n\t\t\t\t       struct drm_device *drm_dev,\n\t\t\t\t       int video_port)\n{\n\tstruct rockchip_rgb *rgb;\n\tstruct drm_encoder *encoder;\n\tstruct device_node *port, *endpoint;\n\tu32 endpoint_id;\n\tint ret = 0, child_count = 0;\n\tstruct drm_panel *panel;\n\tstruct drm_bridge *bridge;\n\tstruct drm_connector *connector;\n\n\trgb = devm_kzalloc(dev, sizeof(*rgb), GFP_KERNEL);\n\tif (!rgb)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\trgb->dev = dev;\n\trgb->drm_dev = drm_dev;\n\n\tport = of_graph_get_port_by_id(dev->of_node, video_port);\n\tif (!port)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tfor_each_child_of_node(port, endpoint) {\n\t\tif (of_property_read_u32(endpoint, \"reg\", &endpoint_id))\n\t\t\tendpoint_id = 0;\n\n\t\t \n\t\tif (rockchip_drm_endpoint_is_subdriver(endpoint) != 0)\n\t\t\tcontinue;\n\n\t\tchild_count++;\n\t\tret = drm_of_find_panel_or_bridge(dev->of_node, video_port,\n\t\t\t\t\t\t  endpoint_id, &panel, &bridge);\n\t\tif (!ret) {\n\t\t\tof_node_put(endpoint);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tof_node_put(port);\n\n\t \n\tif (!child_count)\n\t\treturn NULL;\n\n\tif (ret < 0) {\n\t\tif (ret != -EPROBE_DEFER)\n\t\t\tDRM_DEV_ERROR(dev, \"failed to find panel or bridge %d\\n\", ret);\n\t\treturn ERR_PTR(ret);\n\t}\n\n\tencoder = &rgb->encoder.encoder;\n\tencoder->possible_crtcs = drm_crtc_mask(crtc);\n\n\tret = drm_simple_encoder_init(drm_dev, encoder, DRM_MODE_ENCODER_NONE);\n\tif (ret < 0) {\n\t\tDRM_DEV_ERROR(drm_dev->dev,\n\t\t\t      \"failed to initialize encoder: %d\\n\", ret);\n\t\treturn ERR_PTR(ret);\n\t}\n\n\tdrm_encoder_helper_add(encoder, &rockchip_rgb_encoder_helper_funcs);\n\n\tif (panel) {\n\t\tbridge = drm_panel_bridge_add_typed(panel,\n\t\t\t\t\t\t    DRM_MODE_CONNECTOR_LVDS);\n\t\tif (IS_ERR(bridge))\n\t\t\treturn ERR_CAST(bridge);\n\t}\n\n\trgb->bridge = bridge;\n\n\tret = drm_bridge_attach(encoder, rgb->bridge, NULL,\n\t\t\t\tDRM_BRIDGE_ATTACH_NO_CONNECTOR);\n\tif (ret)\n\t\tgoto err_free_encoder;\n\n\tconnector = &rgb->connector;\n\tconnector = drm_bridge_connector_init(rgb->drm_dev, encoder);\n\tif (IS_ERR(connector)) {\n\t\tDRM_DEV_ERROR(drm_dev->dev,\n\t\t\t      \"failed to initialize bridge connector: %pe\\n\",\n\t\t\t      connector);\n\t\tret = PTR_ERR(connector);\n\t\tgoto err_free_encoder;\n\t}\n\n\trgb->encoder.crtc_endpoint_id = endpoint_id;\n\n\tret = drm_connector_attach_encoder(connector, encoder);\n\tif (ret < 0) {\n\t\tDRM_DEV_ERROR(drm_dev->dev,\n\t\t\t      \"failed to attach encoder: %d\\n\", ret);\n\t\tgoto err_free_connector;\n\t}\n\n\treturn rgb;\n\nerr_free_connector:\n\tdrm_connector_cleanup(connector);\nerr_free_encoder:\n\tdrm_encoder_cleanup(encoder);\n\treturn ERR_PTR(ret);\n}\nEXPORT_SYMBOL_GPL(rockchip_rgb_init);\n\nvoid rockchip_rgb_fini(struct rockchip_rgb *rgb)\n{\n\tdrm_panel_bridge_remove(rgb->bridge);\n\tdrm_connector_cleanup(&rgb->connector);\n\tdrm_encoder_cleanup(&rgb->encoder.encoder);\n}\nEXPORT_SYMBOL_GPL(rockchip_rgb_fini);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}