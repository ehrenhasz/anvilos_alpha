{
  "module_name": "rockchip_drm_vop2.c",
  "hash_id": "4dafe33ea36dbaa8df998119afe6f40f5c0e1f108af70fac52382982b0e2740c",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/rockchip/rockchip_drm_vop2.c",
  "human_readable_source": "\n \n#include <linux/bitfield.h>\n#include <linux/clk.h>\n#include <linux/component.h>\n#include <linux/delay.h>\n#include <linux/iopoll.h>\n#include <linux/kernel.h>\n#include <linux/media-bus-format.h>\n#include <linux/mfd/syscon.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/of_graph.h>\n#include <linux/platform_device.h>\n#include <linux/pm_runtime.h>\n#include <linux/regmap.h>\n#include <linux/swab.h>\n\n#include <drm/drm.h>\n#include <drm/drm_atomic.h>\n#include <drm/drm_atomic_uapi.h>\n#include <drm/drm_blend.h>\n#include <drm/drm_crtc.h>\n#include <drm/drm_debugfs.h>\n#include <drm/drm_flip_work.h>\n#include <drm/drm_framebuffer.h>\n#include <drm/drm_probe_helper.h>\n#include <drm/drm_vblank.h>\n\n#include <uapi/linux/videodev2.h>\n#include <dt-bindings/soc/rockchip,vop2.h>\n\n#include \"rockchip_drm_drv.h\"\n#include \"rockchip_drm_gem.h\"\n#include \"rockchip_drm_fb.h\"\n#include \"rockchip_drm_vop2.h\"\n#include \"rockchip_rgb.h\"\n\n \n\nenum vop2_data_format {\n\tVOP2_FMT_ARGB8888 = 0,\n\tVOP2_FMT_RGB888,\n\tVOP2_FMT_RGB565,\n\tVOP2_FMT_XRGB101010,\n\tVOP2_FMT_YUV420SP,\n\tVOP2_FMT_YUV422SP,\n\tVOP2_FMT_YUV444SP,\n\tVOP2_FMT_YUYV422 = 8,\n\tVOP2_FMT_YUYV420,\n\tVOP2_FMT_VYUY422,\n\tVOP2_FMT_VYUY420,\n\tVOP2_FMT_YUV420SP_TILE_8x4 = 0x10,\n\tVOP2_FMT_YUV420SP_TILE_16x2,\n\tVOP2_FMT_YUV422SP_TILE_8x4,\n\tVOP2_FMT_YUV422SP_TILE_16x2,\n\tVOP2_FMT_YUV420SP_10,\n\tVOP2_FMT_YUV422SP_10,\n\tVOP2_FMT_YUV444SP_10,\n};\n\nenum vop2_afbc_format {\n\tVOP2_AFBC_FMT_RGB565,\n\tVOP2_AFBC_FMT_ARGB2101010 = 2,\n\tVOP2_AFBC_FMT_YUV420_10BIT,\n\tVOP2_AFBC_FMT_RGB888,\n\tVOP2_AFBC_FMT_ARGB8888,\n\tVOP2_AFBC_FMT_YUV420 = 9,\n\tVOP2_AFBC_FMT_YUV422 = 0xb,\n\tVOP2_AFBC_FMT_YUV422_10BIT = 0xe,\n\tVOP2_AFBC_FMT_INVALID = -1,\n};\n\nunion vop2_alpha_ctrl {\n\tu32 val;\n\tstruct {\n\t\t \n\t\tu32 color_mode:1;\n\t\tu32 alpha_mode:1;\n\t\t \n\t\tu32 blend_mode:2;\n\t\tu32 alpha_cal_mode:1;\n\t\t \n\t\tu32 factor_mode:3;\n\t\t \n\t\tu32 alpha_en:1;\n\t\tu32 src_dst_swap:1;\n\t\tu32 reserved:6;\n\t\t \n\t\tu32 glb_alpha:8;\n\t} bits;\n};\n\nstruct vop2_alpha {\n\tunion vop2_alpha_ctrl src_color_ctrl;\n\tunion vop2_alpha_ctrl dst_color_ctrl;\n\tunion vop2_alpha_ctrl src_alpha_ctrl;\n\tunion vop2_alpha_ctrl dst_alpha_ctrl;\n};\n\nstruct vop2_alpha_config {\n\tbool src_premulti_en;\n\tbool dst_premulti_en;\n\tbool src_pixel_alpha_en;\n\tbool dst_pixel_alpha_en;\n\tu16 src_glb_alpha_value;\n\tu16 dst_glb_alpha_value;\n};\n\nstruct vop2_win {\n\tstruct vop2 *vop2;\n\tstruct drm_plane base;\n\tconst struct vop2_win_data *data;\n\tstruct regmap_field *reg[VOP2_WIN_MAX_REG];\n\n\t \n\tu8 win_id;\n\tu8 delay;\n\tu32 offset;\n\n\tenum drm_plane_type type;\n};\n\nstruct vop2_video_port {\n\tstruct drm_crtc crtc;\n\tstruct vop2 *vop2;\n\tstruct clk *dclk;\n\tunsigned int id;\n\tconst struct vop2_video_port_regs *regs;\n\tconst struct vop2_video_port_data *data;\n\n\tstruct completion dsp_hold_completion;\n\n\t \n\tu32 win_mask;\n\n\tstruct vop2_win *primary_plane;\n\tstruct drm_pending_vblank_event *event;\n\n\tunsigned int nlayers;\n};\n\nstruct vop2 {\n\tstruct device *dev;\n\tstruct drm_device *drm;\n\tstruct vop2_video_port vps[ROCKCHIP_MAX_CRTC];\n\n\tconst struct vop2_data *data;\n\t \n\tu32 registered_num_wins;\n\n\tvoid __iomem *regs;\n\tstruct regmap *map;\n\n\tstruct regmap *grf;\n\n\t \n\tu32 len;\n\n\tvoid __iomem *lut_regs;\n\n\t \n\tstruct mutex vop2_lock;\n\n\tint irq;\n\n\t \n\tunsigned int enable_count;\n\tstruct clk *hclk;\n\tstruct clk *aclk;\n\n\t \n\tstruct rockchip_rgb *rgb;\n\n\t \n\tstruct vop2_win win[];\n};\n\nstatic struct vop2_video_port *to_vop2_video_port(struct drm_crtc *crtc)\n{\n\treturn container_of(crtc, struct vop2_video_port, crtc);\n}\n\nstatic struct vop2_win *to_vop2_win(struct drm_plane *p)\n{\n\treturn container_of(p, struct vop2_win, base);\n}\n\nstatic void vop2_lock(struct vop2 *vop2)\n{\n\tmutex_lock(&vop2->vop2_lock);\n}\n\nstatic void vop2_unlock(struct vop2 *vop2)\n{\n\tmutex_unlock(&vop2->vop2_lock);\n}\n\nstatic void vop2_writel(struct vop2 *vop2, u32 offset, u32 v)\n{\n\tregmap_write(vop2->map, offset, v);\n}\n\nstatic void vop2_vp_write(struct vop2_video_port *vp, u32 offset, u32 v)\n{\n\tregmap_write(vp->vop2->map, vp->data->offset + offset, v);\n}\n\nstatic u32 vop2_readl(struct vop2 *vop2, u32 offset)\n{\n\tu32 val;\n\n\tregmap_read(vop2->map, offset, &val);\n\n\treturn val;\n}\n\nstatic void vop2_win_write(const struct vop2_win *win, unsigned int reg, u32 v)\n{\n\tregmap_field_write(win->reg[reg], v);\n}\n\nstatic bool vop2_cluster_window(const struct vop2_win *win)\n{\n\treturn win->data->feature & WIN_FEATURE_CLUSTER;\n}\n\nstatic void vop2_cfg_done(struct vop2_video_port *vp)\n{\n\tstruct vop2 *vop2 = vp->vop2;\n\n\tregmap_set_bits(vop2->map, RK3568_REG_CFG_DONE,\n\t\t\tBIT(vp->id) | RK3568_REG_CFG_DONE__GLB_CFG_DONE_EN);\n}\n\nstatic void vop2_win_disable(struct vop2_win *win)\n{\n\tvop2_win_write(win, VOP2_WIN_ENABLE, 0);\n\n\tif (vop2_cluster_window(win))\n\t\tvop2_win_write(win, VOP2_WIN_CLUSTER_ENABLE, 0);\n}\n\nstatic enum vop2_data_format vop2_convert_format(u32 format)\n{\n\tswitch (format) {\n\tcase DRM_FORMAT_XRGB8888:\n\tcase DRM_FORMAT_ARGB8888:\n\tcase DRM_FORMAT_XBGR8888:\n\tcase DRM_FORMAT_ABGR8888:\n\t\treturn VOP2_FMT_ARGB8888;\n\tcase DRM_FORMAT_RGB888:\n\tcase DRM_FORMAT_BGR888:\n\t\treturn VOP2_FMT_RGB888;\n\tcase DRM_FORMAT_RGB565:\n\tcase DRM_FORMAT_BGR565:\n\t\treturn VOP2_FMT_RGB565;\n\tcase DRM_FORMAT_NV12:\n\t\treturn VOP2_FMT_YUV420SP;\n\tcase DRM_FORMAT_NV16:\n\t\treturn VOP2_FMT_YUV422SP;\n\tcase DRM_FORMAT_NV24:\n\t\treturn VOP2_FMT_YUV444SP;\n\tcase DRM_FORMAT_YUYV:\n\tcase DRM_FORMAT_YVYU:\n\t\treturn VOP2_FMT_VYUY422;\n\tcase DRM_FORMAT_VYUY:\n\tcase DRM_FORMAT_UYVY:\n\t\treturn VOP2_FMT_YUYV422;\n\tdefault:\n\t\tDRM_ERROR(\"unsupported format[%08x]\\n\", format);\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic enum vop2_afbc_format vop2_convert_afbc_format(u32 format)\n{\n\tswitch (format) {\n\tcase DRM_FORMAT_XRGB8888:\n\tcase DRM_FORMAT_ARGB8888:\n\tcase DRM_FORMAT_XBGR8888:\n\tcase DRM_FORMAT_ABGR8888:\n\t\treturn VOP2_AFBC_FMT_ARGB8888;\n\tcase DRM_FORMAT_RGB888:\n\tcase DRM_FORMAT_BGR888:\n\t\treturn VOP2_AFBC_FMT_RGB888;\n\tcase DRM_FORMAT_RGB565:\n\tcase DRM_FORMAT_BGR565:\n\t\treturn VOP2_AFBC_FMT_RGB565;\n\tcase DRM_FORMAT_NV12:\n\t\treturn VOP2_AFBC_FMT_YUV420;\n\tcase DRM_FORMAT_NV16:\n\t\treturn VOP2_AFBC_FMT_YUV422;\n\tdefault:\n\t\treturn VOP2_AFBC_FMT_INVALID;\n\t}\n\n\treturn VOP2_AFBC_FMT_INVALID;\n}\n\nstatic bool vop2_win_rb_swap(u32 format)\n{\n\tswitch (format) {\n\tcase DRM_FORMAT_XBGR8888:\n\tcase DRM_FORMAT_ABGR8888:\n\tcase DRM_FORMAT_BGR888:\n\tcase DRM_FORMAT_BGR565:\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nstatic bool vop2_afbc_rb_swap(u32 format)\n{\n\tswitch (format) {\n\tcase DRM_FORMAT_NV24:\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nstatic bool vop2_afbc_uv_swap(u32 format)\n{\n\tswitch (format) {\n\tcase DRM_FORMAT_NV12:\n\tcase DRM_FORMAT_NV16:\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nstatic bool vop2_win_uv_swap(u32 format)\n{\n\tswitch (format) {\n\tcase DRM_FORMAT_NV12:\n\tcase DRM_FORMAT_NV16:\n\tcase DRM_FORMAT_NV24:\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nstatic bool vop2_win_dither_up(u32 format)\n{\n\tswitch (format) {\n\tcase DRM_FORMAT_BGR565:\n\tcase DRM_FORMAT_RGB565:\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nstatic bool vop2_output_uv_swap(u32 bus_format, u32 output_mode)\n{\n\t \n\tif (bus_format == MEDIA_BUS_FMT_YVYU8_1X16 ||\n\t    bus_format == MEDIA_BUS_FMT_VYUY8_1X16 ||\n\t    bus_format == MEDIA_BUS_FMT_YVYU8_2X8 ||\n\t    bus_format == MEDIA_BUS_FMT_VYUY8_2X8 ||\n\t    ((bus_format == MEDIA_BUS_FMT_YUV8_1X24 ||\n\t      bus_format == MEDIA_BUS_FMT_YUV10_1X30) &&\n\t     (output_mode == ROCKCHIP_OUT_MODE_AAAA ||\n\t      output_mode == ROCKCHIP_OUT_MODE_P888)))\n\t\treturn true;\n\telse\n\t\treturn false;\n}\n\nstatic bool is_yuv_output(u32 bus_format)\n{\n\tswitch (bus_format) {\n\tcase MEDIA_BUS_FMT_YUV8_1X24:\n\tcase MEDIA_BUS_FMT_YUV10_1X30:\n\tcase MEDIA_BUS_FMT_UYYVYY8_0_5X24:\n\tcase MEDIA_BUS_FMT_UYYVYY10_0_5X30:\n\tcase MEDIA_BUS_FMT_YUYV8_2X8:\n\tcase MEDIA_BUS_FMT_YVYU8_2X8:\n\tcase MEDIA_BUS_FMT_UYVY8_2X8:\n\tcase MEDIA_BUS_FMT_VYUY8_2X8:\n\tcase MEDIA_BUS_FMT_YUYV8_1X16:\n\tcase MEDIA_BUS_FMT_YVYU8_1X16:\n\tcase MEDIA_BUS_FMT_UYVY8_1X16:\n\tcase MEDIA_BUS_FMT_VYUY8_1X16:\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nstatic bool rockchip_afbc(struct drm_plane *plane, u64 modifier)\n{\n\tint i;\n\n\tif (modifier == DRM_FORMAT_MOD_LINEAR)\n\t\treturn false;\n\n\tfor (i = 0 ; i < plane->modifier_count; i++)\n\t\tif (plane->modifiers[i] == modifier)\n\t\t\treturn true;\n\n\treturn false;\n}\n\nstatic bool rockchip_vop2_mod_supported(struct drm_plane *plane, u32 format,\n\t\t\t\t\tu64 modifier)\n{\n\tstruct vop2_win *win = to_vop2_win(plane);\n\tstruct vop2 *vop2 = win->vop2;\n\n\tif (modifier == DRM_FORMAT_MOD_INVALID)\n\t\treturn false;\n\n\tif (modifier == DRM_FORMAT_MOD_LINEAR)\n\t\treturn true;\n\n\tif (!rockchip_afbc(plane, modifier)) {\n\t\tdrm_err(vop2->drm, \"Unsupported format modifier 0x%llx\\n\",\n\t\t\tmodifier);\n\n\t\treturn false;\n\t}\n\n\treturn vop2_convert_afbc_format(format) >= 0;\n}\n\nstatic u32 vop2_afbc_transform_offset(struct drm_plane_state *pstate,\n\t\t\t\t      bool afbc_half_block_en)\n{\n\tstruct drm_rect *src = &pstate->src;\n\tstruct drm_framebuffer *fb = pstate->fb;\n\tu32 bpp = fb->format->cpp[0] * 8;\n\tu32 vir_width = (fb->pitches[0] << 3) / bpp;\n\tu32 width = drm_rect_width(src) >> 16;\n\tu32 height = drm_rect_height(src) >> 16;\n\tu32 act_xoffset = src->x1 >> 16;\n\tu32 act_yoffset = src->y1 >> 16;\n\tu32 align16_crop = 0;\n\tu32 align64_crop = 0;\n\tu32 height_tmp;\n\tu8 tx, ty;\n\tu8 bottom_crop_line_num = 0;\n\n\t \n\tif (height & 0xf)\n\t\talign16_crop = 16 - (height & 0xf);\n\n\theight_tmp = height + align16_crop;\n\n\t \n\tif (height_tmp & 0x3f)\n\t\talign64_crop = 64 - (height_tmp & 0x3f);\n\n\tbottom_crop_line_num = align16_crop + align64_crop;\n\n\tswitch (pstate->rotation &\n\t\t(DRM_MODE_REFLECT_X | DRM_MODE_REFLECT_Y |\n\t\t DRM_MODE_ROTATE_90 | DRM_MODE_ROTATE_270)) {\n\tcase DRM_MODE_REFLECT_X | DRM_MODE_REFLECT_Y:\n\t\ttx = 16 - ((act_xoffset + width) & 0xf);\n\t\tty = bottom_crop_line_num - act_yoffset;\n\t\tbreak;\n\tcase DRM_MODE_REFLECT_X | DRM_MODE_ROTATE_90:\n\t\ttx = bottom_crop_line_num - act_yoffset;\n\t\tty = vir_width - width - act_xoffset;\n\t\tbreak;\n\tcase DRM_MODE_REFLECT_X | DRM_MODE_ROTATE_270:\n\t\ttx = act_yoffset;\n\t\tty = act_xoffset;\n\t\tbreak;\n\tcase DRM_MODE_REFLECT_X:\n\t\ttx = 16 - ((act_xoffset + width) & 0xf);\n\t\tty = act_yoffset;\n\t\tbreak;\n\tcase DRM_MODE_REFLECT_Y:\n\t\ttx = act_xoffset;\n\t\tty = bottom_crop_line_num - act_yoffset;\n\t\tbreak;\n\tcase DRM_MODE_ROTATE_90:\n\t\ttx = bottom_crop_line_num - act_yoffset;\n\t\tty = act_xoffset;\n\t\tbreak;\n\tcase DRM_MODE_ROTATE_270:\n\t\ttx = act_yoffset;\n\t\tty = vir_width - width - act_xoffset;\n\t\tbreak;\n\tcase 0:\n\t\ttx = act_xoffset;\n\t\tty = act_yoffset;\n\t\tbreak;\n\t}\n\n\tif (afbc_half_block_en)\n\t\tty &= 0x7f;\n\n#define TRANSFORM_XOFFSET GENMASK(7, 0)\n#define TRANSFORM_YOFFSET GENMASK(23, 16)\n\treturn FIELD_PREP(TRANSFORM_XOFFSET, tx) |\n\t\tFIELD_PREP(TRANSFORM_YOFFSET, ty);\n}\n\n \nstatic int vop2_get_cluster_lb_mode(struct vop2_win *win,\n\t\t\t\t    struct drm_plane_state *pstate)\n{\n\tif ((pstate->rotation & DRM_MODE_ROTATE_270) ||\n\t    (pstate->rotation & DRM_MODE_ROTATE_90))\n\t\treturn 2;\n\telse\n\t\treturn 0;\n}\n\nstatic u16 vop2_scale_factor(u32 src, u32 dst)\n{\n\tu32 fac;\n\tint shift;\n\n\tif (src == dst)\n\t\treturn 0;\n\n\tif (dst < 2)\n\t\treturn U16_MAX;\n\n\tif (src < 2)\n\t\treturn 0;\n\n\tif (src > dst)\n\t\tshift = 12;\n\telse\n\t\tshift = 16;\n\n\tsrc--;\n\tdst--;\n\n\tfac = DIV_ROUND_UP(src << shift, dst) - 1;\n\n\tif (fac > U16_MAX)\n\t\treturn U16_MAX;\n\n\treturn fac;\n}\n\nstatic void vop2_setup_scale(struct vop2 *vop2, const struct vop2_win *win,\n\t\t\t     u32 src_w, u32 src_h, u32 dst_w,\n\t\t\t     u32 dst_h, u32 pixel_format)\n{\n\tconst struct drm_format_info *info;\n\tu16 hor_scl_mode, ver_scl_mode;\n\tu16 hscl_filter_mode, vscl_filter_mode;\n\tu8 gt2 = 0;\n\tu8 gt4 = 0;\n\tu32 val;\n\n\tinfo = drm_format_info(pixel_format);\n\n\tif (src_h >= (4 * dst_h)) {\n\t\tgt4 = 1;\n\t\tsrc_h >>= 2;\n\t} else if (src_h >= (2 * dst_h)) {\n\t\tgt2 = 1;\n\t\tsrc_h >>= 1;\n\t}\n\n\thor_scl_mode = scl_get_scl_mode(src_w, dst_w);\n\tver_scl_mode = scl_get_scl_mode(src_h, dst_h);\n\n\tif (hor_scl_mode == SCALE_UP)\n\t\thscl_filter_mode = VOP2_SCALE_UP_BIC;\n\telse\n\t\thscl_filter_mode = VOP2_SCALE_DOWN_BIL;\n\n\tif (ver_scl_mode == SCALE_UP)\n\t\tvscl_filter_mode = VOP2_SCALE_UP_BIL;\n\telse\n\t\tvscl_filter_mode = VOP2_SCALE_DOWN_BIL;\n\n\t \n\tif (!(win->data->feature & WIN_FEATURE_AFBDC)) {\n\t\tif ((hor_scl_mode == SCALE_DOWN) && (dst_w & 0x1)) {\n\t\t\tdrm_dbg(vop2->drm, \"%s dst_w[%d] should align as 2 pixel\\n\",\n\t\t\t\twin->data->name, dst_w);\n\t\t\tdst_w++;\n\t\t}\n\t}\n\n\tval = vop2_scale_factor(src_w, dst_w);\n\tvop2_win_write(win, VOP2_WIN_SCALE_YRGB_X, val);\n\tval = vop2_scale_factor(src_h, dst_h);\n\tvop2_win_write(win, VOP2_WIN_SCALE_YRGB_Y, val);\n\n\tvop2_win_write(win, VOP2_WIN_VSD_YRGB_GT4, gt4);\n\tvop2_win_write(win, VOP2_WIN_VSD_YRGB_GT2, gt2);\n\n\tvop2_win_write(win, VOP2_WIN_YRGB_HOR_SCL_MODE, hor_scl_mode);\n\tvop2_win_write(win, VOP2_WIN_YRGB_VER_SCL_MODE, ver_scl_mode);\n\n\tif (vop2_cluster_window(win))\n\t\treturn;\n\n\tvop2_win_write(win, VOP2_WIN_YRGB_HSCL_FILTER_MODE, hscl_filter_mode);\n\tvop2_win_write(win, VOP2_WIN_YRGB_VSCL_FILTER_MODE, vscl_filter_mode);\n\n\tif (info->is_yuv) {\n\t\tsrc_w /= info->hsub;\n\t\tsrc_h /= info->vsub;\n\n\t\tgt4 = 0;\n\t\tgt2 = 0;\n\n\t\tif (src_h >= (4 * dst_h)) {\n\t\t\tgt4 = 1;\n\t\t\tsrc_h >>= 2;\n\t\t} else if (src_h >= (2 * dst_h)) {\n\t\t\tgt2 = 1;\n\t\t\tsrc_h >>= 1;\n\t\t}\n\n\t\thor_scl_mode = scl_get_scl_mode(src_w, dst_w);\n\t\tver_scl_mode = scl_get_scl_mode(src_h, dst_h);\n\n\t\tval = vop2_scale_factor(src_w, dst_w);\n\t\tvop2_win_write(win, VOP2_WIN_SCALE_CBCR_X, val);\n\n\t\tval = vop2_scale_factor(src_h, dst_h);\n\t\tvop2_win_write(win, VOP2_WIN_SCALE_CBCR_Y, val);\n\n\t\tvop2_win_write(win, VOP2_WIN_VSD_CBCR_GT4, gt4);\n\t\tvop2_win_write(win, VOP2_WIN_VSD_CBCR_GT2, gt2);\n\t\tvop2_win_write(win, VOP2_WIN_CBCR_HOR_SCL_MODE, hor_scl_mode);\n\t\tvop2_win_write(win, VOP2_WIN_CBCR_VER_SCL_MODE, ver_scl_mode);\n\t\tvop2_win_write(win, VOP2_WIN_CBCR_HSCL_FILTER_MODE, hscl_filter_mode);\n\t\tvop2_win_write(win, VOP2_WIN_CBCR_VSCL_FILTER_MODE, vscl_filter_mode);\n\t}\n}\n\nstatic int vop2_convert_csc_mode(int csc_mode)\n{\n\tswitch (csc_mode) {\n\tcase V4L2_COLORSPACE_SMPTE170M:\n\tcase V4L2_COLORSPACE_470_SYSTEM_M:\n\tcase V4L2_COLORSPACE_470_SYSTEM_BG:\n\t\treturn CSC_BT601L;\n\tcase V4L2_COLORSPACE_REC709:\n\tcase V4L2_COLORSPACE_SMPTE240M:\n\tcase V4L2_COLORSPACE_DEFAULT:\n\t\treturn CSC_BT709L;\n\tcase V4L2_COLORSPACE_JPEG:\n\t\treturn CSC_BT601F;\n\tcase V4L2_COLORSPACE_BT2020:\n\t\treturn CSC_BT2020;\n\tdefault:\n\t\treturn CSC_BT709L;\n\t}\n}\n\n \n\nstatic void vop2_setup_csc_mode(struct vop2_video_port *vp,\n\t\t\t\tstruct vop2_win *win,\n\t\t\t\tstruct drm_plane_state *pstate)\n{\n\tstruct rockchip_crtc_state *vcstate = to_rockchip_crtc_state(vp->crtc.state);\n\tint is_input_yuv = pstate->fb->format->is_yuv;\n\tint is_output_yuv = is_yuv_output(vcstate->bus_format);\n\tint input_csc = V4L2_COLORSPACE_DEFAULT;\n\tint output_csc = vcstate->color_space;\n\tbool r2y_en, y2r_en;\n\tint csc_mode;\n\n\tif (is_input_yuv && !is_output_yuv) {\n\t\ty2r_en = true;\n\t\tr2y_en = false;\n\t\tcsc_mode = vop2_convert_csc_mode(input_csc);\n\t} else if (!is_input_yuv && is_output_yuv) {\n\t\ty2r_en = false;\n\t\tr2y_en = true;\n\t\tcsc_mode = vop2_convert_csc_mode(output_csc);\n\t} else {\n\t\ty2r_en = false;\n\t\tr2y_en = false;\n\t\tcsc_mode = false;\n\t}\n\n\tvop2_win_write(win, VOP2_WIN_Y2R_EN, y2r_en);\n\tvop2_win_write(win, VOP2_WIN_R2Y_EN, r2y_en);\n\tvop2_win_write(win, VOP2_WIN_CSC_MODE, csc_mode);\n}\n\nstatic void vop2_crtc_enable_irq(struct vop2_video_port *vp, u32 irq)\n{\n\tstruct vop2 *vop2 = vp->vop2;\n\n\tvop2_writel(vop2, RK3568_VP_INT_CLR(vp->id), irq << 16 | irq);\n\tvop2_writel(vop2, RK3568_VP_INT_EN(vp->id), irq << 16 | irq);\n}\n\nstatic void vop2_crtc_disable_irq(struct vop2_video_port *vp, u32 irq)\n{\n\tstruct vop2 *vop2 = vp->vop2;\n\n\tvop2_writel(vop2, RK3568_VP_INT_EN(vp->id), irq << 16);\n}\n\nstatic int vop2_core_clks_prepare_enable(struct vop2 *vop2)\n{\n\tint ret;\n\n\tret = clk_prepare_enable(vop2->hclk);\n\tif (ret < 0) {\n\t\tdrm_err(vop2->drm, \"failed to enable hclk - %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = clk_prepare_enable(vop2->aclk);\n\tif (ret < 0) {\n\t\tdrm_err(vop2->drm, \"failed to enable aclk - %d\\n\", ret);\n\t\tgoto err;\n\t}\n\n\treturn 0;\nerr:\n\tclk_disable_unprepare(vop2->hclk);\n\n\treturn ret;\n}\n\nstatic void vop2_enable(struct vop2 *vop2)\n{\n\tint ret;\n\n\tret = pm_runtime_resume_and_get(vop2->dev);\n\tif (ret < 0) {\n\t\tdrm_err(vop2->drm, \"failed to get pm runtime: %d\\n\", ret);\n\t\treturn;\n\t}\n\n\tret = vop2_core_clks_prepare_enable(vop2);\n\tif (ret) {\n\t\tpm_runtime_put_sync(vop2->dev);\n\t\treturn;\n\t}\n\n\tret = rockchip_drm_dma_attach_device(vop2->drm, vop2->dev);\n\tif (ret) {\n\t\tdrm_err(vop2->drm, \"failed to attach dma mapping, %d\\n\", ret);\n\t\treturn;\n\t}\n\n\tregcache_sync(vop2->map);\n\n\tif (vop2->data->soc_id == 3566)\n\t\tvop2_writel(vop2, RK3568_OTP_WIN_EN, 1);\n\n\tvop2_writel(vop2, RK3568_REG_CFG_DONE, RK3568_REG_CFG_DONE__GLB_CFG_DONE_EN);\n\n\t \n\tregmap_clear_bits(vop2->map, RK3568_SYS_AUTO_GATING_CTRL,\n\t\t\t  RK3568_SYS_AUTO_GATING_CTRL__AUTO_GATING_EN);\n\n\tvop2_writel(vop2, RK3568_SYS0_INT_CLR,\n\t\t    VOP2_INT_BUS_ERRPR << 16 | VOP2_INT_BUS_ERRPR);\n\tvop2_writel(vop2, RK3568_SYS0_INT_EN,\n\t\t    VOP2_INT_BUS_ERRPR << 16 | VOP2_INT_BUS_ERRPR);\n\tvop2_writel(vop2, RK3568_SYS1_INT_CLR,\n\t\t    VOP2_INT_BUS_ERRPR << 16 | VOP2_INT_BUS_ERRPR);\n\tvop2_writel(vop2, RK3568_SYS1_INT_EN,\n\t\t    VOP2_INT_BUS_ERRPR << 16 | VOP2_INT_BUS_ERRPR);\n}\n\nstatic void vop2_disable(struct vop2 *vop2)\n{\n\trockchip_drm_dma_detach_device(vop2->drm, vop2->dev);\n\n\tpm_runtime_put_sync(vop2->dev);\n\n\tregcache_mark_dirty(vop2->map);\n\n\tclk_disable_unprepare(vop2->aclk);\n\tclk_disable_unprepare(vop2->hclk);\n}\n\nstatic void vop2_crtc_atomic_disable(struct drm_crtc *crtc,\n\t\t\t\t     struct drm_atomic_state *state)\n{\n\tstruct vop2_video_port *vp = to_vop2_video_port(crtc);\n\tstruct vop2 *vop2 = vp->vop2;\n\tstruct drm_crtc_state *old_crtc_state;\n\tint ret;\n\n\tvop2_lock(vop2);\n\n\told_crtc_state = drm_atomic_get_old_crtc_state(state, crtc);\n\tdrm_atomic_helper_disable_planes_on_crtc(old_crtc_state, false);\n\n\tdrm_crtc_vblank_off(crtc);\n\n\t \n\treinit_completion(&vp->dsp_hold_completion);\n\n\tvop2_crtc_enable_irq(vp, VP_INT_DSP_HOLD_VALID);\n\n\tvop2_vp_write(vp, RK3568_VP_DSP_CTRL, RK3568_VP_DSP_CTRL__STANDBY);\n\n\tret = wait_for_completion_timeout(&vp->dsp_hold_completion,\n\t\t\t\t\t  msecs_to_jiffies(50));\n\tif (!ret)\n\t\tdrm_info(vop2->drm, \"wait for vp%d dsp_hold timeout\\n\", vp->id);\n\n\tvop2_crtc_disable_irq(vp, VP_INT_DSP_HOLD_VALID);\n\n\tclk_disable_unprepare(vp->dclk);\n\n\tvop2->enable_count--;\n\n\tif (!vop2->enable_count)\n\t\tvop2_disable(vop2);\n\n\tvop2_unlock(vop2);\n\n\tif (crtc->state->event && !crtc->state->active) {\n\t\tspin_lock_irq(&crtc->dev->event_lock);\n\t\tdrm_crtc_send_vblank_event(crtc, crtc->state->event);\n\t\tspin_unlock_irq(&crtc->dev->event_lock);\n\n\t\tcrtc->state->event = NULL;\n\t}\n}\n\nstatic int vop2_plane_atomic_check(struct drm_plane *plane,\n\t\t\t\t   struct drm_atomic_state *astate)\n{\n\tstruct drm_plane_state *pstate = drm_atomic_get_new_plane_state(astate, plane);\n\tstruct drm_framebuffer *fb = pstate->fb;\n\tstruct drm_crtc *crtc = pstate->crtc;\n\tstruct drm_crtc_state *cstate;\n\tstruct vop2_video_port *vp;\n\tstruct vop2 *vop2;\n\tconst struct vop2_data *vop2_data;\n\tstruct drm_rect *dest = &pstate->dst;\n\tstruct drm_rect *src = &pstate->src;\n\tint min_scale = FRAC_16_16(1, 8);\n\tint max_scale = FRAC_16_16(8, 1);\n\tint format;\n\tint ret;\n\n\tif (!crtc)\n\t\treturn 0;\n\n\tvp = to_vop2_video_port(crtc);\n\tvop2 = vp->vop2;\n\tvop2_data = vop2->data;\n\n\tcstate = drm_atomic_get_existing_crtc_state(pstate->state, crtc);\n\tif (WARN_ON(!cstate))\n\t\treturn -EINVAL;\n\n\tret = drm_atomic_helper_check_plane_state(pstate, cstate,\n\t\t\t\t\t\t  min_scale, max_scale,\n\t\t\t\t\t\t  true, true);\n\tif (ret)\n\t\treturn ret;\n\n\tif (!pstate->visible)\n\t\treturn 0;\n\n\tformat = vop2_convert_format(fb->format->format);\n\tif (format < 0)\n\t\treturn format;\n\n\tif (drm_rect_width(src) >> 16 < 4 || drm_rect_height(src) >> 16 < 4 ||\n\t    drm_rect_width(dest) < 4 || drm_rect_width(dest) < 4) {\n\t\tdrm_err(vop2->drm, \"Invalid size: %dx%d->%dx%d, min size is 4x4\\n\",\n\t\t\tdrm_rect_width(src) >> 16, drm_rect_height(src) >> 16,\n\t\t\tdrm_rect_width(dest), drm_rect_height(dest));\n\t\tpstate->visible = false;\n\t\treturn 0;\n\t}\n\n\tif (drm_rect_width(src) >> 16 > vop2_data->max_input.width ||\n\t    drm_rect_height(src) >> 16 > vop2_data->max_input.height) {\n\t\tdrm_err(vop2->drm, \"Invalid source: %dx%d. max input: %dx%d\\n\",\n\t\t\tdrm_rect_width(src) >> 16,\n\t\t\tdrm_rect_height(src) >> 16,\n\t\t\tvop2_data->max_input.width,\n\t\t\tvop2_data->max_input.height);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (fb->format->is_yuv && ((pstate->src.x1 >> 16) % 2)) {\n\t\tdrm_err(vop2->drm, \"Invalid Source: Yuv format not support odd xpos\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic void vop2_plane_atomic_disable(struct drm_plane *plane,\n\t\t\t\t      struct drm_atomic_state *state)\n{\n\tstruct drm_plane_state *old_pstate = NULL;\n\tstruct vop2_win *win = to_vop2_win(plane);\n\tstruct vop2 *vop2 = win->vop2;\n\n\tdrm_dbg(vop2->drm, \"%s disable\\n\", win->data->name);\n\n\tif (state)\n\t\told_pstate = drm_atomic_get_old_plane_state(state, plane);\n\tif (old_pstate && !old_pstate->crtc)\n\t\treturn;\n\n\tvop2_win_disable(win);\n\tvop2_win_write(win, VOP2_WIN_YUV_CLIP, 0);\n}\n\n \nstatic void vop2_plane_setup_color_key(struct drm_plane *plane, u32 color_key)\n{\n\tstruct drm_plane_state *pstate = plane->state;\n\tstruct drm_framebuffer *fb = pstate->fb;\n\tstruct vop2_win *win = to_vop2_win(plane);\n\tu32 color_key_en = 0;\n\tu32 r = 0;\n\tu32 g = 0;\n\tu32 b = 0;\n\n\tif (!(color_key & VOP2_COLOR_KEY_MASK) || fb->format->is_yuv) {\n\t\tvop2_win_write(win, VOP2_WIN_COLOR_KEY_EN, 0);\n\t\treturn;\n\t}\n\n\tswitch (fb->format->format) {\n\tcase DRM_FORMAT_RGB565:\n\tcase DRM_FORMAT_BGR565:\n\t\tr = (color_key & 0xf800) >> 11;\n\t\tg = (color_key & 0x7e0) >> 5;\n\t\tb = (color_key & 0x1f);\n\t\tr <<= 5;\n\t\tg <<= 4;\n\t\tb <<= 5;\n\t\tcolor_key_en = 1;\n\t\tbreak;\n\tcase DRM_FORMAT_XRGB8888:\n\tcase DRM_FORMAT_ARGB8888:\n\tcase DRM_FORMAT_XBGR8888:\n\tcase DRM_FORMAT_ABGR8888:\n\tcase DRM_FORMAT_RGB888:\n\tcase DRM_FORMAT_BGR888:\n\t\tr = (color_key & 0xff0000) >> 16;\n\t\tg = (color_key & 0xff00) >> 8;\n\t\tb = (color_key & 0xff);\n\t\tr <<= 2;\n\t\tg <<= 2;\n\t\tb <<= 2;\n\t\tcolor_key_en = 1;\n\t\tbreak;\n\t}\n\n\tvop2_win_write(win, VOP2_WIN_COLOR_KEY_EN, color_key_en);\n\tvop2_win_write(win, VOP2_WIN_COLOR_KEY, (r << 20) | (g << 10) | b);\n}\n\nstatic void vop2_plane_atomic_update(struct drm_plane *plane,\n\t\t\t\t     struct drm_atomic_state *state)\n{\n\tstruct drm_plane_state *pstate = plane->state;\n\tstruct drm_crtc *crtc = pstate->crtc;\n\tstruct vop2_win *win = to_vop2_win(plane);\n\tstruct vop2_video_port *vp = to_vop2_video_port(crtc);\n\tstruct drm_display_mode *adjusted_mode = &crtc->state->adjusted_mode;\n\tstruct vop2 *vop2 = win->vop2;\n\tstruct drm_framebuffer *fb = pstate->fb;\n\tu32 bpp = fb->format->cpp[0] * 8;\n\tu32 actual_w, actual_h, dsp_w, dsp_h;\n\tu32 act_info, dsp_info;\n\tu32 format;\n\tu32 afbc_format;\n\tu32 rb_swap;\n\tu32 uv_swap;\n\tstruct drm_rect *src = &pstate->src;\n\tstruct drm_rect *dest = &pstate->dst;\n\tu32 afbc_tile_num;\n\tu32 transform_offset;\n\tbool dither_up;\n\tbool xmirror = pstate->rotation & DRM_MODE_REFLECT_X ? true : false;\n\tbool ymirror = pstate->rotation & DRM_MODE_REFLECT_Y ? true : false;\n\tbool rotate_270 = pstate->rotation & DRM_MODE_ROTATE_270;\n\tbool rotate_90 = pstate->rotation & DRM_MODE_ROTATE_90;\n\tstruct rockchip_gem_object *rk_obj;\n\tunsigned long offset;\n\tbool afbc_en;\n\tdma_addr_t yrgb_mst;\n\tdma_addr_t uv_mst;\n\n\t \n\tif (WARN_ON(!crtc))\n\t\treturn;\n\n\tif (!pstate->visible) {\n\t\tvop2_plane_atomic_disable(plane, state);\n\t\treturn;\n\t}\n\n\tafbc_en = rockchip_afbc(plane, fb->modifier);\n\n\toffset = (src->x1 >> 16) * fb->format->cpp[0];\n\n\t \n\tif (afbc_en)\n\t\toffset = 0;\n\telse if (pstate->rotation & DRM_MODE_REFLECT_Y)\n\t\toffset += ((src->y2 >> 16) - 1) * fb->pitches[0];\n\telse\n\t\toffset += (src->y1 >> 16) * fb->pitches[0];\n\n\trk_obj = to_rockchip_obj(fb->obj[0]);\n\n\tyrgb_mst = rk_obj->dma_addr + offset + fb->offsets[0];\n\tif (fb->format->is_yuv) {\n\t\tint hsub = fb->format->hsub;\n\t\tint vsub = fb->format->vsub;\n\n\t\toffset = (src->x1 >> 16) * fb->format->cpp[1] / hsub;\n\t\toffset += (src->y1 >> 16) * fb->pitches[1] / vsub;\n\n\t\tif ((pstate->rotation & DRM_MODE_REFLECT_Y) && !afbc_en)\n\t\t\toffset += fb->pitches[1] * ((pstate->src_h >> 16) - 2) / vsub;\n\n\t\trk_obj = to_rockchip_obj(fb->obj[0]);\n\t\tuv_mst = rk_obj->dma_addr + offset + fb->offsets[1];\n\t}\n\n\tactual_w = drm_rect_width(src) >> 16;\n\tactual_h = drm_rect_height(src) >> 16;\n\tdsp_w = drm_rect_width(dest);\n\n\tif (dest->x1 + dsp_w > adjusted_mode->hdisplay) {\n\t\tdrm_err(vop2->drm, \"vp%d %s dest->x1[%d] + dsp_w[%d] exceed mode hdisplay[%d]\\n\",\n\t\t\tvp->id, win->data->name, dest->x1, dsp_w, adjusted_mode->hdisplay);\n\t\tdsp_w = adjusted_mode->hdisplay - dest->x1;\n\t\tif (dsp_w < 4)\n\t\t\tdsp_w = 4;\n\t\tactual_w = dsp_w * actual_w / drm_rect_width(dest);\n\t}\n\n\tdsp_h = drm_rect_height(dest);\n\n\tif (dest->y1 + dsp_h > adjusted_mode->vdisplay) {\n\t\tdrm_err(vop2->drm, \"vp%d %s dest->y1[%d] + dsp_h[%d] exceed mode vdisplay[%d]\\n\",\n\t\t\tvp->id, win->data->name, dest->y1, dsp_h, adjusted_mode->vdisplay);\n\t\tdsp_h = adjusted_mode->vdisplay - dest->y1;\n\t\tif (dsp_h < 4)\n\t\t\tdsp_h = 4;\n\t\tactual_h = dsp_h * actual_h / drm_rect_height(dest);\n\t}\n\n\t \n\tif (!(win->data->feature & WIN_FEATURE_AFBDC)) {\n\t\tif (actual_w > dsp_w && (actual_w & 0xf) == 1) {\n\t\t\tdrm_err(vop2->drm, \"vp%d %s act_w[%d] MODE 16 == 1\\n\",\n\t\t\t\tvp->id, win->data->name, actual_w);\n\t\t\tactual_w -= 1;\n\t\t}\n\t}\n\n\tif (afbc_en && actual_w % 4) {\n\t\tdrm_err(vop2->drm, \"vp%d %s actual_w[%d] not 4 pixel aligned\\n\",\n\t\t\tvp->id, win->data->name, actual_w);\n\t\tactual_w = ALIGN_DOWN(actual_w, 4);\n\t}\n\n\tact_info = (actual_h - 1) << 16 | ((actual_w - 1) & 0xffff);\n\tdsp_info = (dsp_h - 1) << 16 | ((dsp_w - 1) & 0xffff);\n\n\tformat = vop2_convert_format(fb->format->format);\n\n\tdrm_dbg(vop2->drm, \"vp%d update %s[%dx%d->%dx%d@%dx%d] fmt[%p4cc_%s] addr[%pad]\\n\",\n\t\tvp->id, win->data->name, actual_w, actual_h, dsp_w, dsp_h,\n\t\tdest->x1, dest->y1,\n\t\t&fb->format->format,\n\t\tafbc_en ? \"AFBC\" : \"\", &yrgb_mst);\n\n\tif (afbc_en) {\n\t\tu32 stride;\n\n\t\t \n\t\tafbc_format = vop2_convert_afbc_format(fb->format->format);\n\n\t\t \n\t\tif (fb->modifier & AFBC_FORMAT_MOD_YTR)\n\t\t\tafbc_format |= (1 << 4);\n\n\t\tafbc_tile_num = ALIGN(actual_w, 16) >> 4;\n\n\t\t \n\t\tstride = (fb->pitches[0] << 3) / bpp;\n\t\tif ((stride & 0x3f) && (xmirror || rotate_90 || rotate_270))\n\t\t\tdrm_err(vop2->drm, \"vp%d %s stride[%d] not 64 pixel aligned\\n\",\n\t\t\t\tvp->id, win->data->name, stride);\n\n\t\trb_swap = vop2_afbc_rb_swap(fb->format->format);\n\t\tuv_swap = vop2_afbc_uv_swap(fb->format->format);\n\t\t \n\t\tif (fb->format->is_yuv && bpp == 10)\n\t\t\tformat = VOP2_CLUSTER_YUV444_10;\n\n\t\tif (vop2_cluster_window(win))\n\t\t\tvop2_win_write(win, VOP2_WIN_AFBC_ENABLE, 1);\n\t\tvop2_win_write(win, VOP2_WIN_AFBC_FORMAT, afbc_format);\n\t\tvop2_win_write(win, VOP2_WIN_AFBC_RB_SWAP, rb_swap);\n\t\tvop2_win_write(win, VOP2_WIN_AFBC_UV_SWAP, uv_swap);\n\t\tvop2_win_write(win, VOP2_WIN_AFBC_AUTO_GATING_EN, 0);\n\t\tvop2_win_write(win, VOP2_WIN_AFBC_BLOCK_SPLIT_EN, 0);\n\t\tif (pstate->rotation & (DRM_MODE_ROTATE_270 | DRM_MODE_ROTATE_90)) {\n\t\t\tvop2_win_write(win, VOP2_WIN_AFBC_HALF_BLOCK_EN, 0);\n\t\t\ttransform_offset = vop2_afbc_transform_offset(pstate, false);\n\t\t} else {\n\t\t\tvop2_win_write(win, VOP2_WIN_AFBC_HALF_BLOCK_EN, 1);\n\t\t\ttransform_offset = vop2_afbc_transform_offset(pstate, true);\n\t\t}\n\t\tvop2_win_write(win, VOP2_WIN_AFBC_HDR_PTR, yrgb_mst);\n\t\tvop2_win_write(win, VOP2_WIN_AFBC_PIC_SIZE, act_info);\n\t\tvop2_win_write(win, VOP2_WIN_AFBC_TRANSFORM_OFFSET, transform_offset);\n\t\tvop2_win_write(win, VOP2_WIN_AFBC_PIC_OFFSET, ((src->x1 >> 16) | src->y1));\n\t\tvop2_win_write(win, VOP2_WIN_AFBC_DSP_OFFSET, (dest->x1 | (dest->y1 << 16)));\n\t\tvop2_win_write(win, VOP2_WIN_AFBC_PIC_VIR_WIDTH, stride);\n\t\tvop2_win_write(win, VOP2_WIN_AFBC_TILE_NUM, afbc_tile_num);\n\t\tvop2_win_write(win, VOP2_WIN_XMIRROR, xmirror);\n\t\tvop2_win_write(win, VOP2_WIN_AFBC_ROTATE_270, rotate_270);\n\t\tvop2_win_write(win, VOP2_WIN_AFBC_ROTATE_90, rotate_90);\n\t} else {\n\t\tvop2_win_write(win, VOP2_WIN_YRGB_VIR, DIV_ROUND_UP(fb->pitches[0], 4));\n\t}\n\n\tvop2_win_write(win, VOP2_WIN_YMIRROR, ymirror);\n\n\tif (rotate_90 || rotate_270) {\n\t\tact_info = swahw32(act_info);\n\t\tactual_w = drm_rect_height(src) >> 16;\n\t\tactual_h = drm_rect_width(src) >> 16;\n\t}\n\n\tvop2_win_write(win, VOP2_WIN_FORMAT, format);\n\tvop2_win_write(win, VOP2_WIN_YRGB_MST, yrgb_mst);\n\n\trb_swap = vop2_win_rb_swap(fb->format->format);\n\tvop2_win_write(win, VOP2_WIN_RB_SWAP, rb_swap);\n\tif (!vop2_cluster_window(win)) {\n\t\tuv_swap = vop2_win_uv_swap(fb->format->format);\n\t\tvop2_win_write(win, VOP2_WIN_UV_SWAP, uv_swap);\n\t}\n\n\tif (fb->format->is_yuv) {\n\t\tvop2_win_write(win, VOP2_WIN_UV_VIR, DIV_ROUND_UP(fb->pitches[1], 4));\n\t\tvop2_win_write(win, VOP2_WIN_UV_MST, uv_mst);\n\t}\n\n\tvop2_setup_scale(vop2, win, actual_w, actual_h, dsp_w, dsp_h, fb->format->format);\n\tif (!vop2_cluster_window(win))\n\t\tvop2_plane_setup_color_key(plane, 0);\n\tvop2_win_write(win, VOP2_WIN_ACT_INFO, act_info);\n\tvop2_win_write(win, VOP2_WIN_DSP_INFO, dsp_info);\n\tvop2_win_write(win, VOP2_WIN_DSP_ST, dest->y1 << 16 | (dest->x1 & 0xffff));\n\n\tvop2_setup_csc_mode(vp, win, pstate);\n\n\tdither_up = vop2_win_dither_up(fb->format->format);\n\tvop2_win_write(win, VOP2_WIN_DITHER_UP, dither_up);\n\n\tvop2_win_write(win, VOP2_WIN_ENABLE, 1);\n\n\tif (vop2_cluster_window(win)) {\n\t\tint lb_mode = vop2_get_cluster_lb_mode(win, pstate);\n\n\t\tvop2_win_write(win, VOP2_WIN_CLUSTER_LB_MODE, lb_mode);\n\t\tvop2_win_write(win, VOP2_WIN_CLUSTER_ENABLE, 1);\n\t}\n}\n\nstatic const struct drm_plane_helper_funcs vop2_plane_helper_funcs = {\n\t.atomic_check = vop2_plane_atomic_check,\n\t.atomic_update = vop2_plane_atomic_update,\n\t.atomic_disable = vop2_plane_atomic_disable,\n};\n\nstatic const struct drm_plane_funcs vop2_plane_funcs = {\n\t.update_plane\t= drm_atomic_helper_update_plane,\n\t.disable_plane\t= drm_atomic_helper_disable_plane,\n\t.destroy = drm_plane_cleanup,\n\t.reset = drm_atomic_helper_plane_reset,\n\t.atomic_duplicate_state = drm_atomic_helper_plane_duplicate_state,\n\t.atomic_destroy_state = drm_atomic_helper_plane_destroy_state,\n\t.format_mod_supported = rockchip_vop2_mod_supported,\n};\n\nstatic int vop2_crtc_enable_vblank(struct drm_crtc *crtc)\n{\n\tstruct vop2_video_port *vp = to_vop2_video_port(crtc);\n\n\tvop2_crtc_enable_irq(vp, VP_INT_FS_FIELD);\n\n\treturn 0;\n}\n\nstatic void vop2_crtc_disable_vblank(struct drm_crtc *crtc)\n{\n\tstruct vop2_video_port *vp = to_vop2_video_port(crtc);\n\n\tvop2_crtc_disable_irq(vp, VP_INT_FS_FIELD);\n}\n\nstatic bool vop2_crtc_mode_fixup(struct drm_crtc *crtc,\n\t\t\t\t const struct drm_display_mode *mode,\n\t\t\t\t struct drm_display_mode *adj_mode)\n{\n\tdrm_mode_set_crtcinfo(adj_mode, CRTC_INTERLACE_HALVE_V |\n\t\t\t\t\tCRTC_STEREO_DOUBLE);\n\n\treturn true;\n}\n\nstatic void vop2_dither_setup(struct drm_crtc *crtc, u32 *dsp_ctrl)\n{\n\tstruct rockchip_crtc_state *vcstate = to_rockchip_crtc_state(crtc->state);\n\n\tswitch (vcstate->bus_format) {\n\tcase MEDIA_BUS_FMT_RGB565_1X16:\n\t\t*dsp_ctrl |= RK3568_VP_DSP_CTRL__DITHER_DOWN_EN;\n\t\tbreak;\n\tcase MEDIA_BUS_FMT_RGB666_1X18:\n\tcase MEDIA_BUS_FMT_RGB666_1X24_CPADHI:\n\tcase MEDIA_BUS_FMT_RGB666_1X7X3_SPWG:\n\t\t*dsp_ctrl |= RK3568_VP_DSP_CTRL__DITHER_DOWN_EN;\n\t\t*dsp_ctrl |= RGB888_TO_RGB666;\n\t\tbreak;\n\tcase MEDIA_BUS_FMT_YUV8_1X24:\n\tcase MEDIA_BUS_FMT_UYYVYY8_0_5X24:\n\t\t*dsp_ctrl |= RK3568_VP_DSP_CTRL__PRE_DITHER_DOWN_EN;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tif (vcstate->output_mode != ROCKCHIP_OUT_MODE_AAAA)\n\t\t*dsp_ctrl |= RK3568_VP_DSP_CTRL__PRE_DITHER_DOWN_EN;\n\n\t*dsp_ctrl |= FIELD_PREP(RK3568_VP_DSP_CTRL__DITHER_DOWN_SEL,\n\t\t\t\tDITHER_DOWN_ALLEGRO);\n}\n\nstatic void vop2_post_config(struct drm_crtc *crtc)\n{\n\tstruct vop2_video_port *vp = to_vop2_video_port(crtc);\n\tstruct drm_display_mode *mode = &crtc->state->adjusted_mode;\n\tu16 vtotal = mode->crtc_vtotal;\n\tu16 hdisplay = mode->crtc_hdisplay;\n\tu16 hact_st = mode->crtc_htotal - mode->crtc_hsync_start;\n\tu16 vdisplay = mode->crtc_vdisplay;\n\tu16 vact_st = mode->crtc_vtotal - mode->crtc_vsync_start;\n\tu32 left_margin = 100, right_margin = 100;\n\tu32 top_margin = 100, bottom_margin = 100;\n\tu16 hsize = hdisplay * (left_margin + right_margin) / 200;\n\tu16 vsize = vdisplay * (top_margin + bottom_margin) / 200;\n\tu16 hact_end, vact_end;\n\tu32 val;\n\n\tvsize = rounddown(vsize, 2);\n\thsize = rounddown(hsize, 2);\n\thact_st += hdisplay * (100 - left_margin) / 200;\n\thact_end = hact_st + hsize;\n\tval = hact_st << 16;\n\tval |= hact_end;\n\tvop2_vp_write(vp, RK3568_VP_POST_DSP_HACT_INFO, val);\n\tvact_st += vdisplay * (100 - top_margin) / 200;\n\tvact_end = vact_st + vsize;\n\tval = vact_st << 16;\n\tval |= vact_end;\n\tvop2_vp_write(vp, RK3568_VP_POST_DSP_VACT_INFO, val);\n\tval = scl_cal_scale2(vdisplay, vsize) << 16;\n\tval |= scl_cal_scale2(hdisplay, hsize);\n\tvop2_vp_write(vp, RK3568_VP_POST_SCL_FACTOR_YRGB, val);\n\n\tval = 0;\n\tif (hdisplay != hsize)\n\t\tval |= RK3568_VP_POST_SCL_CTRL__HSCALEDOWN;\n\tif (vdisplay != vsize)\n\t\tval |= RK3568_VP_POST_SCL_CTRL__VSCALEDOWN;\n\tvop2_vp_write(vp, RK3568_VP_POST_SCL_CTRL, val);\n\n\tif (mode->flags & DRM_MODE_FLAG_INTERLACE) {\n\t\tu16 vact_st_f1 = vtotal + vact_st + 1;\n\t\tu16 vact_end_f1 = vact_st_f1 + vsize;\n\n\t\tval = vact_st_f1 << 16 | vact_end_f1;\n\t\tvop2_vp_write(vp, RK3568_VP_POST_DSP_VACT_INFO_F1, val);\n\t}\n\n\tvop2_vp_write(vp, RK3568_VP_DSP_BG, 0);\n}\n\nstatic void rk3568_set_intf_mux(struct vop2_video_port *vp, int id,\n\t\t\t\tu32 polflags)\n{\n\tstruct vop2 *vop2 = vp->vop2;\n\tu32 die, dip;\n\n\tdie = vop2_readl(vop2, RK3568_DSP_IF_EN);\n\tdip = vop2_readl(vop2, RK3568_DSP_IF_POL);\n\n\tswitch (id) {\n\tcase ROCKCHIP_VOP2_EP_RGB0:\n\t\tdie &= ~RK3568_SYS_DSP_INFACE_EN_RGB_MUX;\n\t\tdie |= RK3568_SYS_DSP_INFACE_EN_RGB |\n\t\t\t   FIELD_PREP(RK3568_SYS_DSP_INFACE_EN_RGB_MUX, vp->id);\n\t\tdip &= ~RK3568_DSP_IF_POL__RGB_LVDS_PIN_POL;\n\t\tdip |= FIELD_PREP(RK3568_DSP_IF_POL__RGB_LVDS_PIN_POL, polflags);\n\t\tif (polflags & POLFLAG_DCLK_INV)\n\t\t\tregmap_write(vop2->grf, RK3568_GRF_VO_CON1, BIT(3 + 16) | BIT(3));\n\t\telse\n\t\t\tregmap_write(vop2->grf, RK3568_GRF_VO_CON1, BIT(3 + 16));\n\t\tbreak;\n\tcase ROCKCHIP_VOP2_EP_HDMI0:\n\t\tdie &= ~RK3568_SYS_DSP_INFACE_EN_HDMI_MUX;\n\t\tdie |= RK3568_SYS_DSP_INFACE_EN_HDMI |\n\t\t\t   FIELD_PREP(RK3568_SYS_DSP_INFACE_EN_HDMI_MUX, vp->id);\n\t\tdip &= ~RK3568_DSP_IF_POL__HDMI_PIN_POL;\n\t\tdip |= FIELD_PREP(RK3568_DSP_IF_POL__HDMI_PIN_POL, polflags);\n\t\tbreak;\n\tcase ROCKCHIP_VOP2_EP_EDP0:\n\t\tdie &= ~RK3568_SYS_DSP_INFACE_EN_EDP_MUX;\n\t\tdie |= RK3568_SYS_DSP_INFACE_EN_EDP |\n\t\t\t   FIELD_PREP(RK3568_SYS_DSP_INFACE_EN_EDP_MUX, vp->id);\n\t\tdip &= ~RK3568_DSP_IF_POL__EDP_PIN_POL;\n\t\tdip |= FIELD_PREP(RK3568_DSP_IF_POL__EDP_PIN_POL, polflags);\n\t\tbreak;\n\tcase ROCKCHIP_VOP2_EP_MIPI0:\n\t\tdie &= ~RK3568_SYS_DSP_INFACE_EN_MIPI0_MUX;\n\t\tdie |= RK3568_SYS_DSP_INFACE_EN_MIPI0 |\n\t\t\t   FIELD_PREP(RK3568_SYS_DSP_INFACE_EN_MIPI0_MUX, vp->id);\n\t\tdip &= ~RK3568_DSP_IF_POL__MIPI_PIN_POL;\n\t\tdip |= FIELD_PREP(RK3568_DSP_IF_POL__MIPI_PIN_POL, polflags);\n\t\tbreak;\n\tcase ROCKCHIP_VOP2_EP_MIPI1:\n\t\tdie &= ~RK3568_SYS_DSP_INFACE_EN_MIPI1_MUX;\n\t\tdie |= RK3568_SYS_DSP_INFACE_EN_MIPI1 |\n\t\t\t   FIELD_PREP(RK3568_SYS_DSP_INFACE_EN_MIPI1_MUX, vp->id);\n\t\tdip &= ~RK3568_DSP_IF_POL__MIPI_PIN_POL;\n\t\tdip |= FIELD_PREP(RK3568_DSP_IF_POL__MIPI_PIN_POL, polflags);\n\t\tbreak;\n\tcase ROCKCHIP_VOP2_EP_LVDS0:\n\t\tdie &= ~RK3568_SYS_DSP_INFACE_EN_LVDS0_MUX;\n\t\tdie |= RK3568_SYS_DSP_INFACE_EN_LVDS0 |\n\t\t\t   FIELD_PREP(RK3568_SYS_DSP_INFACE_EN_LVDS0_MUX, vp->id);\n\t\tdip &= ~RK3568_DSP_IF_POL__RGB_LVDS_PIN_POL;\n\t\tdip |= FIELD_PREP(RK3568_DSP_IF_POL__RGB_LVDS_PIN_POL, polflags);\n\t\tbreak;\n\tcase ROCKCHIP_VOP2_EP_LVDS1:\n\t\tdie &= ~RK3568_SYS_DSP_INFACE_EN_LVDS1_MUX;\n\t\tdie |= RK3568_SYS_DSP_INFACE_EN_LVDS1 |\n\t\t\t   FIELD_PREP(RK3568_SYS_DSP_INFACE_EN_LVDS1_MUX, vp->id);\n\t\tdip &= ~RK3568_DSP_IF_POL__RGB_LVDS_PIN_POL;\n\t\tdip |= FIELD_PREP(RK3568_DSP_IF_POL__RGB_LVDS_PIN_POL, polflags);\n\t\tbreak;\n\tdefault:\n\t\tdrm_err(vop2->drm, \"Invalid interface id %d on vp%d\\n\", id, vp->id);\n\t\treturn;\n\t}\n\n\tdip |= RK3568_DSP_IF_POL__CFG_DONE_IMD;\n\n\tvop2_writel(vop2, RK3568_DSP_IF_EN, die);\n\tvop2_writel(vop2, RK3568_DSP_IF_POL, dip);\n}\n\nstatic int us_to_vertical_line(struct drm_display_mode *mode, int us)\n{\n\treturn us * mode->clock / mode->htotal / 1000;\n}\n\nstatic void vop2_crtc_atomic_enable(struct drm_crtc *crtc,\n\t\t\t\t    struct drm_atomic_state *state)\n{\n\tstruct vop2_video_port *vp = to_vop2_video_port(crtc);\n\tstruct vop2 *vop2 = vp->vop2;\n\tconst struct vop2_data *vop2_data = vop2->data;\n\tconst struct vop2_video_port_data *vp_data = &vop2_data->vp[vp->id];\n\tstruct drm_crtc_state *crtc_state = drm_atomic_get_new_crtc_state(state, crtc);\n\tstruct rockchip_crtc_state *vcstate = to_rockchip_crtc_state(crtc->state);\n\tstruct drm_display_mode *mode = &crtc->state->adjusted_mode;\n\tunsigned long clock = mode->crtc_clock * 1000;\n\tu16 hsync_len = mode->crtc_hsync_end - mode->crtc_hsync_start;\n\tu16 hdisplay = mode->crtc_hdisplay;\n\tu16 htotal = mode->crtc_htotal;\n\tu16 hact_st = mode->crtc_htotal - mode->crtc_hsync_start;\n\tu16 hact_end = hact_st + hdisplay;\n\tu16 vdisplay = mode->crtc_vdisplay;\n\tu16 vtotal = mode->crtc_vtotal;\n\tu16 vsync_len = mode->crtc_vsync_end - mode->crtc_vsync_start;\n\tu16 vact_st = mode->crtc_vtotal - mode->crtc_vsync_start;\n\tu16 vact_end = vact_st + vdisplay;\n\tu8 out_mode;\n\tu32 dsp_ctrl = 0;\n\tint act_end;\n\tu32 val, polflags;\n\tint ret;\n\tstruct drm_encoder *encoder;\n\n\tdrm_dbg(vop2->drm, \"Update mode to %dx%d%s%d, type: %d for vp%d\\n\",\n\t\thdisplay, vdisplay, mode->flags & DRM_MODE_FLAG_INTERLACE ? \"i\" : \"p\",\n\t\tdrm_mode_vrefresh(mode), vcstate->output_type, vp->id);\n\n\tvop2_lock(vop2);\n\n\tret = clk_prepare_enable(vp->dclk);\n\tif (ret < 0) {\n\t\tdrm_err(vop2->drm, \"failed to enable dclk for video port%d - %d\\n\",\n\t\t\tvp->id, ret);\n\t\tvop2_unlock(vop2);\n\t\treturn;\n\t}\n\n\tif (!vop2->enable_count)\n\t\tvop2_enable(vop2);\n\n\tvop2->enable_count++;\n\n\tvop2_crtc_enable_irq(vp, VP_INT_POST_BUF_EMPTY);\n\n\tpolflags = 0;\n\tif (vcstate->bus_flags & DRM_BUS_FLAG_PIXDATA_DRIVE_NEGEDGE)\n\t\tpolflags |= POLFLAG_DCLK_INV;\n\tif (mode->flags & DRM_MODE_FLAG_PHSYNC)\n\t\tpolflags |= BIT(HSYNC_POSITIVE);\n\tif (mode->flags & DRM_MODE_FLAG_PVSYNC)\n\t\tpolflags |= BIT(VSYNC_POSITIVE);\n\n\tdrm_for_each_encoder_mask(encoder, crtc->dev, crtc_state->encoder_mask) {\n\t\tstruct rockchip_encoder *rkencoder = to_rockchip_encoder(encoder);\n\n\t\trk3568_set_intf_mux(vp, rkencoder->crtc_endpoint_id, polflags);\n\t}\n\n\tif (vcstate->output_mode == ROCKCHIP_OUT_MODE_AAAA &&\n\t    !(vp_data->feature & VOP_FEATURE_OUTPUT_10BIT))\n\t\tout_mode = ROCKCHIP_OUT_MODE_P888;\n\telse\n\t\tout_mode = vcstate->output_mode;\n\n\tdsp_ctrl |= FIELD_PREP(RK3568_VP_DSP_CTRL__OUT_MODE, out_mode);\n\n\tif (vop2_output_uv_swap(vcstate->bus_format, vcstate->output_mode))\n\t\tdsp_ctrl |= RK3568_VP_DSP_CTRL__DSP_RB_SWAP;\n\n\tif (is_yuv_output(vcstate->bus_format))\n\t\tdsp_ctrl |= RK3568_VP_DSP_CTRL__POST_DSP_OUT_R2Y;\n\n\tvop2_dither_setup(crtc, &dsp_ctrl);\n\n\tvop2_vp_write(vp, RK3568_VP_DSP_HTOTAL_HS_END, (htotal << 16) | hsync_len);\n\tval = hact_st << 16;\n\tval |= hact_end;\n\tvop2_vp_write(vp, RK3568_VP_DSP_HACT_ST_END, val);\n\n\tval = vact_st << 16;\n\tval |= vact_end;\n\tvop2_vp_write(vp, RK3568_VP_DSP_VACT_ST_END, val);\n\n\tif (mode->flags & DRM_MODE_FLAG_INTERLACE) {\n\t\tu16 vact_st_f1 = vtotal + vact_st + 1;\n\t\tu16 vact_end_f1 = vact_st_f1 + vdisplay;\n\n\t\tval = vact_st_f1 << 16 | vact_end_f1;\n\t\tvop2_vp_write(vp, RK3568_VP_DSP_VACT_ST_END_F1, val);\n\n\t\tval = vtotal << 16 | (vtotal + vsync_len);\n\t\tvop2_vp_write(vp, RK3568_VP_DSP_VS_ST_END_F1, val);\n\t\tdsp_ctrl |= RK3568_VP_DSP_CTRL__DSP_INTERLACE;\n\t\tdsp_ctrl |= RK3568_VP_DSP_CTRL__DSP_FILED_POL;\n\t\tdsp_ctrl |= RK3568_VP_DSP_CTRL__P2I_EN;\n\t\tvtotal += vtotal + 1;\n\t\tact_end = vact_end_f1;\n\t} else {\n\t\tact_end = vact_end;\n\t}\n\n\tvop2_writel(vop2, RK3568_VP_LINE_FLAG(vp->id),\n\t\t    (act_end - us_to_vertical_line(mode, 0)) << 16 | act_end);\n\n\tvop2_vp_write(vp, RK3568_VP_DSP_VTOTAL_VS_END, vtotal << 16 | vsync_len);\n\n\tif (mode->flags & DRM_MODE_FLAG_DBLCLK) {\n\t\tdsp_ctrl |= RK3568_VP_DSP_CTRL__CORE_DCLK_DIV;\n\t\tclock *= 2;\n\t}\n\n\tvop2_vp_write(vp, RK3568_VP_MIPI_CTRL, 0);\n\n\tclk_set_rate(vp->dclk, clock);\n\n\tvop2_post_config(crtc);\n\n\tvop2_cfg_done(vp);\n\n\tvop2_vp_write(vp, RK3568_VP_DSP_CTRL, dsp_ctrl);\n\n\tdrm_crtc_vblank_on(crtc);\n\n\tvop2_unlock(vop2);\n}\n\nstatic int vop2_crtc_atomic_check(struct drm_crtc *crtc,\n\t\t\t\t  struct drm_atomic_state *state)\n{\n\tstruct vop2_video_port *vp = to_vop2_video_port(crtc);\n\tstruct drm_plane *plane;\n\tint nplanes = 0;\n\tstruct drm_crtc_state *crtc_state = drm_atomic_get_new_crtc_state(state, crtc);\n\n\tdrm_atomic_crtc_state_for_each_plane(plane, crtc_state)\n\t\tnplanes++;\n\n\tif (nplanes > vp->nlayers)\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nstatic bool is_opaque(u16 alpha)\n{\n\treturn (alpha >> 8) == 0xff;\n}\n\nstatic void vop2_parse_alpha(struct vop2_alpha_config *alpha_config,\n\t\t\t     struct vop2_alpha *alpha)\n{\n\tint src_glb_alpha_en = is_opaque(alpha_config->src_glb_alpha_value) ? 0 : 1;\n\tint dst_glb_alpha_en = is_opaque(alpha_config->dst_glb_alpha_value) ? 0 : 1;\n\tint src_color_mode = alpha_config->src_premulti_en ?\n\t\t\t\tALPHA_SRC_PRE_MUL : ALPHA_SRC_NO_PRE_MUL;\n\tint dst_color_mode = alpha_config->dst_premulti_en ?\n\t\t\t\tALPHA_SRC_PRE_MUL : ALPHA_SRC_NO_PRE_MUL;\n\n\talpha->src_color_ctrl.val = 0;\n\talpha->dst_color_ctrl.val = 0;\n\talpha->src_alpha_ctrl.val = 0;\n\talpha->dst_alpha_ctrl.val = 0;\n\n\tif (!alpha_config->src_pixel_alpha_en)\n\t\talpha->src_color_ctrl.bits.blend_mode = ALPHA_GLOBAL;\n\telse if (alpha_config->src_pixel_alpha_en && !src_glb_alpha_en)\n\t\talpha->src_color_ctrl.bits.blend_mode = ALPHA_PER_PIX;\n\telse\n\t\talpha->src_color_ctrl.bits.blend_mode = ALPHA_PER_PIX_GLOBAL;\n\n\talpha->src_color_ctrl.bits.alpha_en = 1;\n\n\tif (alpha->src_color_ctrl.bits.blend_mode == ALPHA_GLOBAL) {\n\t\talpha->src_color_ctrl.bits.color_mode = src_color_mode;\n\t\talpha->src_color_ctrl.bits.factor_mode = SRC_FAC_ALPHA_SRC_GLOBAL;\n\t} else if (alpha->src_color_ctrl.bits.blend_mode == ALPHA_PER_PIX) {\n\t\talpha->src_color_ctrl.bits.color_mode = src_color_mode;\n\t\talpha->src_color_ctrl.bits.factor_mode = SRC_FAC_ALPHA_ONE;\n\t} else {\n\t\talpha->src_color_ctrl.bits.color_mode = ALPHA_SRC_PRE_MUL;\n\t\talpha->src_color_ctrl.bits.factor_mode = SRC_FAC_ALPHA_SRC_GLOBAL;\n\t}\n\talpha->src_color_ctrl.bits.glb_alpha = alpha_config->src_glb_alpha_value >> 8;\n\talpha->src_color_ctrl.bits.alpha_mode = ALPHA_STRAIGHT;\n\talpha->src_color_ctrl.bits.alpha_cal_mode = ALPHA_SATURATION;\n\n\talpha->dst_color_ctrl.bits.alpha_mode = ALPHA_STRAIGHT;\n\talpha->dst_color_ctrl.bits.alpha_cal_mode = ALPHA_SATURATION;\n\talpha->dst_color_ctrl.bits.blend_mode = ALPHA_GLOBAL;\n\talpha->dst_color_ctrl.bits.glb_alpha = alpha_config->dst_glb_alpha_value >> 8;\n\talpha->dst_color_ctrl.bits.color_mode = dst_color_mode;\n\talpha->dst_color_ctrl.bits.factor_mode = ALPHA_SRC_INVERSE;\n\n\talpha->src_alpha_ctrl.bits.alpha_mode = ALPHA_STRAIGHT;\n\talpha->src_alpha_ctrl.bits.blend_mode = alpha->src_color_ctrl.bits.blend_mode;\n\talpha->src_alpha_ctrl.bits.alpha_cal_mode = ALPHA_SATURATION;\n\talpha->src_alpha_ctrl.bits.factor_mode = ALPHA_ONE;\n\n\talpha->dst_alpha_ctrl.bits.alpha_mode = ALPHA_STRAIGHT;\n\tif (alpha_config->dst_pixel_alpha_en && !dst_glb_alpha_en)\n\t\talpha->dst_alpha_ctrl.bits.blend_mode = ALPHA_PER_PIX;\n\telse\n\t\talpha->dst_alpha_ctrl.bits.blend_mode = ALPHA_PER_PIX_GLOBAL;\n\talpha->dst_alpha_ctrl.bits.alpha_cal_mode = ALPHA_NO_SATURATION;\n\talpha->dst_alpha_ctrl.bits.factor_mode = ALPHA_SRC_INVERSE;\n}\n\nstatic int vop2_find_start_mixer_id_for_vp(struct vop2 *vop2, u8 port_id)\n{\n\tstruct vop2_video_port *vp;\n\tint used_layer = 0;\n\tint i;\n\n\tfor (i = 0; i < port_id; i++) {\n\t\tvp = &vop2->vps[i];\n\t\tused_layer += hweight32(vp->win_mask);\n\t}\n\n\treturn used_layer;\n}\n\nstatic void vop2_setup_cluster_alpha(struct vop2 *vop2, struct vop2_win *main_win)\n{\n\tu32 offset = (main_win->data->phys_id * 0x10);\n\tstruct vop2_alpha_config alpha_config;\n\tstruct vop2_alpha alpha;\n\tstruct drm_plane_state *bottom_win_pstate;\n\tbool src_pixel_alpha_en = false;\n\tu16 src_glb_alpha_val, dst_glb_alpha_val;\n\tbool premulti_en = false;\n\tbool swap = false;\n\n\t \n\tbottom_win_pstate = main_win->base.state;\n\tsrc_glb_alpha_val = 0;\n\tdst_glb_alpha_val = main_win->base.state->alpha;\n\n\tif (!bottom_win_pstate->fb)\n\t\treturn;\n\n\talpha_config.src_premulti_en = premulti_en;\n\talpha_config.dst_premulti_en = false;\n\talpha_config.src_pixel_alpha_en = src_pixel_alpha_en;\n\talpha_config.dst_pixel_alpha_en = true;  \n\talpha_config.src_glb_alpha_value = src_glb_alpha_val;\n\talpha_config.dst_glb_alpha_value = dst_glb_alpha_val;\n\tvop2_parse_alpha(&alpha_config, &alpha);\n\n\talpha.src_color_ctrl.bits.src_dst_swap = swap;\n\tvop2_writel(vop2, RK3568_CLUSTER0_MIX_SRC_COLOR_CTRL + offset,\n\t\t    alpha.src_color_ctrl.val);\n\tvop2_writel(vop2, RK3568_CLUSTER0_MIX_DST_COLOR_CTRL + offset,\n\t\t    alpha.dst_color_ctrl.val);\n\tvop2_writel(vop2, RK3568_CLUSTER0_MIX_SRC_ALPHA_CTRL + offset,\n\t\t    alpha.src_alpha_ctrl.val);\n\tvop2_writel(vop2, RK3568_CLUSTER0_MIX_DST_ALPHA_CTRL + offset,\n\t\t    alpha.dst_alpha_ctrl.val);\n}\n\nstatic void vop2_setup_alpha(struct vop2_video_port *vp)\n{\n\tstruct vop2 *vop2 = vp->vop2;\n\tstruct drm_framebuffer *fb;\n\tstruct vop2_alpha_config alpha_config;\n\tstruct vop2_alpha alpha;\n\tstruct drm_plane *plane;\n\tint pixel_alpha_en;\n\tint premulti_en, gpremulti_en = 0;\n\tint mixer_id;\n\tu32 offset;\n\tbool bottom_layer_alpha_en = false;\n\tu32 dst_global_alpha = DRM_BLEND_ALPHA_OPAQUE;\n\n\tmixer_id = vop2_find_start_mixer_id_for_vp(vop2, vp->id);\n\talpha_config.dst_pixel_alpha_en = true;  \n\n\tdrm_atomic_crtc_for_each_plane(plane, &vp->crtc) {\n\t\tstruct vop2_win *win = to_vop2_win(plane);\n\n\t\tif (plane->state->normalized_zpos == 0 &&\n\t\t    !is_opaque(plane->state->alpha) &&\n\t\t    !vop2_cluster_window(win)) {\n\t\t\t \n\t\t\tbottom_layer_alpha_en = true;\n\t\t\tdst_global_alpha = plane->state->alpha;\n\t\t}\n\t}\n\n\tdrm_atomic_crtc_for_each_plane(plane, &vp->crtc) {\n\t\tstruct vop2_win *win = to_vop2_win(plane);\n\t\tint zpos = plane->state->normalized_zpos;\n\n\t\tif (plane->state->pixel_blend_mode == DRM_MODE_BLEND_PREMULTI)\n\t\t\tpremulti_en = 1;\n\t\telse\n\t\t\tpremulti_en = 0;\n\n\t\tplane = &win->base;\n\t\tfb = plane->state->fb;\n\n\t\tpixel_alpha_en = fb->format->has_alpha;\n\n\t\talpha_config.src_premulti_en = premulti_en;\n\n\t\tif (bottom_layer_alpha_en && zpos == 1) {\n\t\t\tgpremulti_en = premulti_en;\n\t\t\t \n\t\t\talpha_config.dst_premulti_en = false;\n\t\t\talpha_config.src_pixel_alpha_en = pixel_alpha_en;\n\t\t\talpha_config.src_glb_alpha_value = plane->state->alpha;\n\t\t\talpha_config.dst_glb_alpha_value = dst_global_alpha;\n\t\t} else if (vop2_cluster_window(win)) {\n\t\t\t \n\t\t\talpha_config.dst_premulti_en = true;\n\t\t\talpha_config.src_pixel_alpha_en = true;\n\t\t\talpha_config.src_glb_alpha_value = DRM_BLEND_ALPHA_OPAQUE;\n\t\t\talpha_config.dst_glb_alpha_value = DRM_BLEND_ALPHA_OPAQUE;\n\t\t} else {\n\t\t\t \n\t\t\talpha_config.dst_premulti_en = true;\n\t\t\talpha_config.src_pixel_alpha_en = pixel_alpha_en;\n\t\t\talpha_config.src_glb_alpha_value = plane->state->alpha;\n\t\t\talpha_config.dst_glb_alpha_value = DRM_BLEND_ALPHA_OPAQUE;\n\t\t}\n\n\t\tvop2_parse_alpha(&alpha_config, &alpha);\n\n\t\toffset = (mixer_id + zpos - 1) * 0x10;\n\t\tvop2_writel(vop2, RK3568_MIX0_SRC_COLOR_CTRL + offset,\n\t\t\t    alpha.src_color_ctrl.val);\n\t\tvop2_writel(vop2, RK3568_MIX0_DST_COLOR_CTRL + offset,\n\t\t\t    alpha.dst_color_ctrl.val);\n\t\tvop2_writel(vop2, RK3568_MIX0_SRC_ALPHA_CTRL + offset,\n\t\t\t    alpha.src_alpha_ctrl.val);\n\t\tvop2_writel(vop2, RK3568_MIX0_DST_ALPHA_CTRL + offset,\n\t\t\t    alpha.dst_alpha_ctrl.val);\n\t}\n\n\tif (vp->id == 0) {\n\t\tif (bottom_layer_alpha_en) {\n\t\t\t \n\t\t\talpha_config.src_premulti_en = gpremulti_en;\n\t\t\talpha_config.dst_premulti_en = true;\n\t\t\talpha_config.src_pixel_alpha_en = true;\n\t\t\talpha_config.src_glb_alpha_value = DRM_BLEND_ALPHA_OPAQUE;\n\t\t\talpha_config.dst_glb_alpha_value = DRM_BLEND_ALPHA_OPAQUE;\n\t\t\tvop2_parse_alpha(&alpha_config, &alpha);\n\n\t\t\tvop2_writel(vop2, RK3568_HDR0_SRC_COLOR_CTRL,\n\t\t\t\t    alpha.src_color_ctrl.val);\n\t\t\tvop2_writel(vop2, RK3568_HDR0_DST_COLOR_CTRL,\n\t\t\t\t    alpha.dst_color_ctrl.val);\n\t\t\tvop2_writel(vop2, RK3568_HDR0_SRC_ALPHA_CTRL,\n\t\t\t\t    alpha.src_alpha_ctrl.val);\n\t\t\tvop2_writel(vop2, RK3568_HDR0_DST_ALPHA_CTRL,\n\t\t\t\t    alpha.dst_alpha_ctrl.val);\n\t\t} else {\n\t\t\tvop2_writel(vop2, RK3568_HDR0_SRC_COLOR_CTRL, 0);\n\t\t}\n\t}\n}\n\nstatic void vop2_setup_layer_mixer(struct vop2_video_port *vp)\n{\n\tstruct vop2 *vop2 = vp->vop2;\n\tstruct drm_plane *plane;\n\tu32 layer_sel = 0;\n\tu32 port_sel;\n\tunsigned int nlayer, ofs;\n\tstruct drm_display_mode *adjusted_mode;\n\tu16 hsync_len;\n\tu16 hdisplay;\n\tu32 bg_dly;\n\tu32 pre_scan_dly;\n\tint i;\n\tstruct vop2_video_port *vp0 = &vop2->vps[0];\n\tstruct vop2_video_port *vp1 = &vop2->vps[1];\n\tstruct vop2_video_port *vp2 = &vop2->vps[2];\n\n\tadjusted_mode = &vp->crtc.state->adjusted_mode;\n\thsync_len = adjusted_mode->crtc_hsync_end - adjusted_mode->crtc_hsync_start;\n\thdisplay = adjusted_mode->crtc_hdisplay;\n\n\tbg_dly = vp->data->pre_scan_max_dly[3];\n\tvop2_writel(vop2, RK3568_VP_BG_MIX_CTRL(vp->id),\n\t\t    FIELD_PREP(RK3568_VP_BG_MIX_CTRL__BG_DLY, bg_dly));\n\n\tpre_scan_dly = ((bg_dly + (hdisplay >> 1) - 1) << 16) | hsync_len;\n\tvop2_vp_write(vp, RK3568_VP_PRE_SCAN_HTIMING, pre_scan_dly);\n\n\tvop2_writel(vop2, RK3568_OVL_CTRL, 0);\n\tport_sel = vop2_readl(vop2, RK3568_OVL_PORT_SEL);\n\tport_sel &= RK3568_OVL_PORT_SEL__SEL_PORT;\n\n\tif (vp0->nlayers)\n\t\tport_sel |= FIELD_PREP(RK3568_OVL_PORT_SET__PORT0_MUX,\n\t\t\t\t     vp0->nlayers - 1);\n\telse\n\t\tport_sel |= FIELD_PREP(RK3568_OVL_PORT_SET__PORT0_MUX, 8);\n\n\tif (vp1->nlayers)\n\t\tport_sel |= FIELD_PREP(RK3568_OVL_PORT_SET__PORT1_MUX,\n\t\t\t\t     (vp0->nlayers + vp1->nlayers - 1));\n\telse\n\t\tport_sel |= FIELD_PREP(RK3568_OVL_PORT_SET__PORT1_MUX, 8);\n\n\tif (vp2->nlayers)\n\t\tport_sel |= FIELD_PREP(RK3568_OVL_PORT_SET__PORT2_MUX,\n\t\t\t(vp2->nlayers + vp1->nlayers + vp0->nlayers - 1));\n\telse\n\t\tport_sel |= FIELD_PREP(RK3568_OVL_PORT_SET__PORT1_MUX, 8);\n\n\tlayer_sel = vop2_readl(vop2, RK3568_OVL_LAYER_SEL);\n\n\tofs = 0;\n\tfor (i = 0; i < vp->id; i++)\n\t\tofs += vop2->vps[i].nlayers;\n\n\tnlayer = 0;\n\tdrm_atomic_crtc_for_each_plane(plane, &vp->crtc) {\n\t\tstruct vop2_win *win = to_vop2_win(plane);\n\n\t\tswitch (win->data->phys_id) {\n\t\tcase ROCKCHIP_VOP2_CLUSTER0:\n\t\t\tport_sel &= ~RK3568_OVL_PORT_SEL__CLUSTER0;\n\t\t\tport_sel |= FIELD_PREP(RK3568_OVL_PORT_SEL__CLUSTER0, vp->id);\n\t\t\tbreak;\n\t\tcase ROCKCHIP_VOP2_CLUSTER1:\n\t\t\tport_sel &= ~RK3568_OVL_PORT_SEL__CLUSTER1;\n\t\t\tport_sel |= FIELD_PREP(RK3568_OVL_PORT_SEL__CLUSTER1, vp->id);\n\t\t\tbreak;\n\t\tcase ROCKCHIP_VOP2_ESMART0:\n\t\t\tport_sel &= ~RK3568_OVL_PORT_SEL__ESMART0;\n\t\t\tport_sel |= FIELD_PREP(RK3568_OVL_PORT_SEL__ESMART0, vp->id);\n\t\t\tbreak;\n\t\tcase ROCKCHIP_VOP2_ESMART1:\n\t\t\tport_sel &= ~RK3568_OVL_PORT_SEL__ESMART1;\n\t\t\tport_sel |= FIELD_PREP(RK3568_OVL_PORT_SEL__ESMART1, vp->id);\n\t\t\tbreak;\n\t\tcase ROCKCHIP_VOP2_SMART0:\n\t\t\tport_sel &= ~RK3568_OVL_PORT_SEL__SMART0;\n\t\t\tport_sel |= FIELD_PREP(RK3568_OVL_PORT_SEL__SMART0, vp->id);\n\t\t\tbreak;\n\t\tcase ROCKCHIP_VOP2_SMART1:\n\t\t\tport_sel &= ~RK3568_OVL_PORT_SEL__SMART1;\n\t\t\tport_sel |= FIELD_PREP(RK3568_OVL_PORT_SEL__SMART1, vp->id);\n\t\t\tbreak;\n\t\t}\n\n\t\tlayer_sel &= ~RK3568_OVL_LAYER_SEL__LAYER(plane->state->normalized_zpos + ofs,\n\t\t\t\t\t\t\t  0x7);\n\t\tlayer_sel |= RK3568_OVL_LAYER_SEL__LAYER(plane->state->normalized_zpos + ofs,\n\t\t\t\t\t\t\t win->data->layer_sel_id);\n\t\tnlayer++;\n\t}\n\n\t \n\tfor (; nlayer < vp->nlayers; nlayer++) {\n\t\tlayer_sel &= ~RK3568_OVL_LAYER_SEL__LAYER(nlayer + ofs, 0x7);\n\t\tlayer_sel |= RK3568_OVL_LAYER_SEL__LAYER(nlayer + ofs, 5);\n\t}\n\n\tvop2_writel(vop2, RK3568_OVL_LAYER_SEL, layer_sel);\n\tvop2_writel(vop2, RK3568_OVL_PORT_SEL, port_sel);\n\tvop2_writel(vop2, RK3568_OVL_CTRL, RK3568_OVL_CTRL__LAYERSEL_REGDONE_IMD);\n}\n\nstatic void vop2_setup_dly_for_windows(struct vop2 *vop2)\n{\n\tstruct vop2_win *win;\n\tint i = 0;\n\tu32 cdly = 0, sdly = 0;\n\n\tfor (i = 0; i < vop2->data->win_size; i++) {\n\t\tu32 dly;\n\n\t\twin = &vop2->win[i];\n\t\tdly = win->delay;\n\n\t\tswitch (win->data->phys_id) {\n\t\tcase ROCKCHIP_VOP2_CLUSTER0:\n\t\t\tcdly |= FIELD_PREP(RK3568_CLUSTER_DLY_NUM__CLUSTER0_0, dly);\n\t\t\tcdly |= FIELD_PREP(RK3568_CLUSTER_DLY_NUM__CLUSTER0_1, dly);\n\t\t\tbreak;\n\t\tcase ROCKCHIP_VOP2_CLUSTER1:\n\t\t\tcdly |= FIELD_PREP(RK3568_CLUSTER_DLY_NUM__CLUSTER1_0, dly);\n\t\t\tcdly |= FIELD_PREP(RK3568_CLUSTER_DLY_NUM__CLUSTER1_1, dly);\n\t\t\tbreak;\n\t\tcase ROCKCHIP_VOP2_ESMART0:\n\t\t\tsdly |= FIELD_PREP(RK3568_SMART_DLY_NUM__ESMART0, dly);\n\t\t\tbreak;\n\t\tcase ROCKCHIP_VOP2_ESMART1:\n\t\t\tsdly |= FIELD_PREP(RK3568_SMART_DLY_NUM__ESMART1, dly);\n\t\t\tbreak;\n\t\tcase ROCKCHIP_VOP2_SMART0:\n\t\t\tsdly |= FIELD_PREP(RK3568_SMART_DLY_NUM__SMART0, dly);\n\t\t\tbreak;\n\t\tcase ROCKCHIP_VOP2_SMART1:\n\t\t\tsdly |= FIELD_PREP(RK3568_SMART_DLY_NUM__SMART1, dly);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tvop2_writel(vop2, RK3568_CLUSTER_DLY_NUM, cdly);\n\tvop2_writel(vop2, RK3568_SMART_DLY_NUM, sdly);\n}\n\nstatic void vop2_crtc_atomic_begin(struct drm_crtc *crtc,\n\t\t\t\t   struct drm_atomic_state *state)\n{\n\tstruct vop2_video_port *vp = to_vop2_video_port(crtc);\n\tstruct vop2 *vop2 = vp->vop2;\n\tstruct drm_plane *plane;\n\n\tvp->win_mask = 0;\n\n\tdrm_atomic_crtc_for_each_plane(plane, crtc) {\n\t\tstruct vop2_win *win = to_vop2_win(plane);\n\n\t\twin->delay = win->data->dly[VOP2_DLY_MODE_DEFAULT];\n\n\t\tvp->win_mask |= BIT(win->data->phys_id);\n\n\t\tif (vop2_cluster_window(win))\n\t\t\tvop2_setup_cluster_alpha(vop2, win);\n\t}\n\n\tif (!vp->win_mask)\n\t\treturn;\n\n\tvop2_setup_layer_mixer(vp);\n\tvop2_setup_alpha(vp);\n\tvop2_setup_dly_for_windows(vop2);\n}\n\nstatic void vop2_crtc_atomic_flush(struct drm_crtc *crtc,\n\t\t\t\t   struct drm_atomic_state *state)\n{\n\tstruct vop2_video_port *vp = to_vop2_video_port(crtc);\n\n\tvop2_post_config(crtc);\n\n\tvop2_cfg_done(vp);\n\n\tspin_lock_irq(&crtc->dev->event_lock);\n\n\tif (crtc->state->event) {\n\t\tWARN_ON(drm_crtc_vblank_get(crtc));\n\t\tvp->event = crtc->state->event;\n\t\tcrtc->state->event = NULL;\n\t}\n\n\tspin_unlock_irq(&crtc->dev->event_lock);\n}\n\nstatic const struct drm_crtc_helper_funcs vop2_crtc_helper_funcs = {\n\t.mode_fixup = vop2_crtc_mode_fixup,\n\t.atomic_check = vop2_crtc_atomic_check,\n\t.atomic_begin = vop2_crtc_atomic_begin,\n\t.atomic_flush = vop2_crtc_atomic_flush,\n\t.atomic_enable = vop2_crtc_atomic_enable,\n\t.atomic_disable = vop2_crtc_atomic_disable,\n};\n\nstatic struct drm_crtc_state *vop2_crtc_duplicate_state(struct drm_crtc *crtc)\n{\n\tstruct rockchip_crtc_state *vcstate;\n\n\tif (WARN_ON(!crtc->state))\n\t\treturn NULL;\n\n\tvcstate = kmemdup(to_rockchip_crtc_state(crtc->state),\n\t\t\t  sizeof(*vcstate), GFP_KERNEL);\n\tif (!vcstate)\n\t\treturn NULL;\n\n\t__drm_atomic_helper_crtc_duplicate_state(crtc, &vcstate->base);\n\n\treturn &vcstate->base;\n}\n\nstatic void vop2_crtc_destroy_state(struct drm_crtc *crtc,\n\t\t\t\t    struct drm_crtc_state *state)\n{\n\tstruct rockchip_crtc_state *vcstate = to_rockchip_crtc_state(state);\n\n\t__drm_atomic_helper_crtc_destroy_state(&vcstate->base);\n\tkfree(vcstate);\n}\n\nstatic void vop2_crtc_reset(struct drm_crtc *crtc)\n{\n\tstruct rockchip_crtc_state *vcstate =\n\t\tkzalloc(sizeof(*vcstate), GFP_KERNEL);\n\n\tif (crtc->state)\n\t\tvop2_crtc_destroy_state(crtc, crtc->state);\n\n\tif (vcstate)\n\t\t__drm_atomic_helper_crtc_reset(crtc, &vcstate->base);\n\telse\n\t\t__drm_atomic_helper_crtc_reset(crtc, NULL);\n}\n\nstatic const struct drm_crtc_funcs vop2_crtc_funcs = {\n\t.set_config = drm_atomic_helper_set_config,\n\t.page_flip = drm_atomic_helper_page_flip,\n\t.destroy = drm_crtc_cleanup,\n\t.reset = vop2_crtc_reset,\n\t.atomic_duplicate_state = vop2_crtc_duplicate_state,\n\t.atomic_destroy_state = vop2_crtc_destroy_state,\n\t.enable_vblank = vop2_crtc_enable_vblank,\n\t.disable_vblank = vop2_crtc_disable_vblank,\n};\n\nstatic irqreturn_t vop2_isr(int irq, void *data)\n{\n\tstruct vop2 *vop2 = data;\n\tconst struct vop2_data *vop2_data = vop2->data;\n\tu32 axi_irqs[VOP2_SYS_AXI_BUS_NUM];\n\tint ret = IRQ_NONE;\n\tint i;\n\n\t \n\tif (!pm_runtime_get_if_in_use(vop2->dev))\n\t\treturn IRQ_NONE;\n\n\tfor (i = 0; i < vop2_data->nr_vps; i++) {\n\t\tstruct vop2_video_port *vp = &vop2->vps[i];\n\t\tstruct drm_crtc *crtc = &vp->crtc;\n\t\tu32 irqs;\n\n\t\tirqs = vop2_readl(vop2, RK3568_VP_INT_STATUS(vp->id));\n\t\tvop2_writel(vop2, RK3568_VP_INT_CLR(vp->id), irqs << 16 | irqs);\n\n\t\tif (irqs & VP_INT_DSP_HOLD_VALID) {\n\t\t\tcomplete(&vp->dsp_hold_completion);\n\t\t\tret = IRQ_HANDLED;\n\t\t}\n\n\t\tif (irqs & VP_INT_FS_FIELD) {\n\t\t\tdrm_crtc_handle_vblank(crtc);\n\t\t\tspin_lock(&crtc->dev->event_lock);\n\t\t\tif (vp->event) {\n\t\t\t\tu32 val = vop2_readl(vop2, RK3568_REG_CFG_DONE);\n\n\t\t\t\tif (!(val & BIT(vp->id))) {\n\t\t\t\t\tdrm_crtc_send_vblank_event(crtc, vp->event);\n\t\t\t\t\tvp->event = NULL;\n\t\t\t\t\tdrm_crtc_vblank_put(crtc);\n\t\t\t\t}\n\t\t\t}\n\t\t\tspin_unlock(&crtc->dev->event_lock);\n\n\t\t\tret = IRQ_HANDLED;\n\t\t}\n\n\t\tif (irqs & VP_INT_POST_BUF_EMPTY) {\n\t\t\tdrm_err_ratelimited(vop2->drm,\n\t\t\t\t\t    \"POST_BUF_EMPTY irq err at vp%d\\n\",\n\t\t\t\t\t    vp->id);\n\t\t\tret = IRQ_HANDLED;\n\t\t}\n\t}\n\n\taxi_irqs[0] = vop2_readl(vop2, RK3568_SYS0_INT_STATUS);\n\tvop2_writel(vop2, RK3568_SYS0_INT_CLR, axi_irqs[0] << 16 | axi_irqs[0]);\n\taxi_irqs[1] = vop2_readl(vop2, RK3568_SYS1_INT_STATUS);\n\tvop2_writel(vop2, RK3568_SYS1_INT_CLR, axi_irqs[1] << 16 | axi_irqs[1]);\n\n\tfor (i = 0; i < ARRAY_SIZE(axi_irqs); i++) {\n\t\tif (axi_irqs[i] & VOP2_INT_BUS_ERRPR) {\n\t\t\tdrm_err_ratelimited(vop2->drm, \"BUS_ERROR irq err\\n\");\n\t\t\tret = IRQ_HANDLED;\n\t\t}\n\t}\n\n\tpm_runtime_put(vop2->dev);\n\n\treturn ret;\n}\n\nstatic int vop2_plane_init(struct vop2 *vop2, struct vop2_win *win,\n\t\t\t   unsigned long possible_crtcs)\n{\n\tconst struct vop2_win_data *win_data = win->data;\n\tunsigned int blend_caps = BIT(DRM_MODE_BLEND_PIXEL_NONE) |\n\t\t\t\t  BIT(DRM_MODE_BLEND_PREMULTI) |\n\t\t\t\t  BIT(DRM_MODE_BLEND_COVERAGE);\n\tint ret;\n\n\tret = drm_universal_plane_init(vop2->drm, &win->base, possible_crtcs,\n\t\t\t\t       &vop2_plane_funcs, win_data->formats,\n\t\t\t\t       win_data->nformats,\n\t\t\t\t       win_data->format_modifiers,\n\t\t\t\t       win->type, win_data->name);\n\tif (ret) {\n\t\tdrm_err(vop2->drm, \"failed to initialize plane %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tdrm_plane_helper_add(&win->base, &vop2_plane_helper_funcs);\n\n\tif (win->data->supported_rotations)\n\t\tdrm_plane_create_rotation_property(&win->base, DRM_MODE_ROTATE_0,\n\t\t\t\t\t\t   DRM_MODE_ROTATE_0 |\n\t\t\t\t\t\t   win->data->supported_rotations);\n\tdrm_plane_create_alpha_property(&win->base);\n\tdrm_plane_create_blend_mode_property(&win->base, blend_caps);\n\tdrm_plane_create_zpos_property(&win->base, win->win_id, 0,\n\t\t\t\t       vop2->registered_num_wins - 1);\n\n\treturn 0;\n}\n\nstatic struct vop2_video_port *find_vp_without_primary(struct vop2 *vop2)\n{\n\tint i;\n\n\tfor (i = 0; i < vop2->data->nr_vps; i++) {\n\t\tstruct vop2_video_port *vp = &vop2->vps[i];\n\n\t\tif (!vp->crtc.port)\n\t\t\tcontinue;\n\t\tif (vp->primary_plane)\n\t\t\tcontinue;\n\n\t\treturn vp;\n\t}\n\n\treturn NULL;\n}\n\n#define NR_LAYERS 6\n\nstatic int vop2_create_crtcs(struct vop2 *vop2)\n{\n\tconst struct vop2_data *vop2_data = vop2->data;\n\tstruct drm_device *drm = vop2->drm;\n\tstruct device *dev = vop2->dev;\n\tstruct drm_plane *plane;\n\tstruct device_node *port;\n\tstruct vop2_video_port *vp;\n\tint i, nvp, nvps = 0;\n\tint ret;\n\n\tfor (i = 0; i < vop2_data->nr_vps; i++) {\n\t\tconst struct vop2_video_port_data *vp_data;\n\t\tstruct device_node *np;\n\t\tchar dclk_name[9];\n\n\t\tvp_data = &vop2_data->vp[i];\n\t\tvp = &vop2->vps[i];\n\t\tvp->vop2 = vop2;\n\t\tvp->id = vp_data->id;\n\t\tvp->regs = vp_data->regs;\n\t\tvp->data = vp_data;\n\n\t\tsnprintf(dclk_name, sizeof(dclk_name), \"dclk_vp%d\", vp->id);\n\t\tvp->dclk = devm_clk_get(vop2->dev, dclk_name);\n\t\tif (IS_ERR(vp->dclk)) {\n\t\t\tdrm_err(vop2->drm, \"failed to get %s\\n\", dclk_name);\n\t\t\treturn PTR_ERR(vp->dclk);\n\t\t}\n\n\t\tnp = of_graph_get_remote_node(dev->of_node, i, -1);\n\t\tif (!np) {\n\t\t\tdrm_dbg(vop2->drm, \"%s: No remote for vp%d\\n\", __func__, i);\n\t\t\tcontinue;\n\t\t}\n\t\tof_node_put(np);\n\n\t\tport = of_graph_get_port_by_id(dev->of_node, i);\n\t\tif (!port) {\n\t\t\tdrm_err(vop2->drm, \"no port node found for video_port%d\\n\", i);\n\t\t\treturn -ENOENT;\n\t\t}\n\n\t\tvp->crtc.port = port;\n\t\tnvps++;\n\t}\n\n\tnvp = 0;\n\tfor (i = 0; i < vop2->registered_num_wins; i++) {\n\t\tstruct vop2_win *win = &vop2->win[i];\n\t\tu32 possible_crtcs = 0;\n\n\t\tif (vop2->data->soc_id == 3566) {\n\t\t\t \n\t\t\tswitch (win->data->phys_id) {\n\t\t\tcase ROCKCHIP_VOP2_SMART1:\n\t\t\tcase ROCKCHIP_VOP2_ESMART1:\n\t\t\tcase ROCKCHIP_VOP2_CLUSTER1:\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\tif (win->type == DRM_PLANE_TYPE_PRIMARY) {\n\t\t\tvp = find_vp_without_primary(vop2);\n\t\t\tif (vp) {\n\t\t\t\tpossible_crtcs = BIT(nvp);\n\t\t\t\tvp->primary_plane = win;\n\t\t\t\tnvp++;\n\t\t\t} else {\n\t\t\t\t \n\t\t\t\twin->type = DRM_PLANE_TYPE_OVERLAY;\n\t\t\t}\n\t\t}\n\n\t\tif (win->type == DRM_PLANE_TYPE_OVERLAY)\n\t\t\tpossible_crtcs = (1 << nvps) - 1;\n\n\t\tret = vop2_plane_init(vop2, win, possible_crtcs);\n\t\tif (ret) {\n\t\t\tdrm_err(vop2->drm, \"failed to init plane %s: %d\\n\",\n\t\t\t\twin->data->name, ret);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tfor (i = 0; i < vop2_data->nr_vps; i++) {\n\t\tvp = &vop2->vps[i];\n\n\t\tif (!vp->crtc.port)\n\t\t\tcontinue;\n\n\t\tplane = &vp->primary_plane->base;\n\n\t\tret = drm_crtc_init_with_planes(drm, &vp->crtc, plane, NULL,\n\t\t\t\t\t\t&vop2_crtc_funcs,\n\t\t\t\t\t\t\"video_port%d\", vp->id);\n\t\tif (ret) {\n\t\t\tdrm_err(vop2->drm, \"crtc init for video_port%d failed\\n\", i);\n\t\t\treturn ret;\n\t\t}\n\n\t\tdrm_crtc_helper_add(&vp->crtc, &vop2_crtc_helper_funcs);\n\n\t\tinit_completion(&vp->dsp_hold_completion);\n\t}\n\n\t \n\tfor (i = 0; i < vop2->data->nr_vps; i++) {\n\t\tstruct vop2_video_port *vp = &vop2->vps[i];\n\n\t\tif (vp->crtc.port)\n\t\t\tvp->nlayers = NR_LAYERS / nvps;\n\t}\n\n\treturn 0;\n}\n\nstatic void vop2_destroy_crtcs(struct vop2 *vop2)\n{\n\tstruct drm_device *drm = vop2->drm;\n\tstruct list_head *crtc_list = &drm->mode_config.crtc_list;\n\tstruct list_head *plane_list = &drm->mode_config.plane_list;\n\tstruct drm_crtc *crtc, *tmpc;\n\tstruct drm_plane *plane, *tmpp;\n\n\tlist_for_each_entry_safe(plane, tmpp, plane_list, head)\n\t\tdrm_plane_cleanup(plane);\n\n\t \n\tlist_for_each_entry_safe(crtc, tmpc, crtc_list, head) {\n\t\tof_node_put(crtc->port);\n\t\tdrm_crtc_cleanup(crtc);\n\t}\n}\n\nstatic int vop2_find_rgb_encoder(struct vop2 *vop2)\n{\n\tstruct device_node *node = vop2->dev->of_node;\n\tstruct device_node *endpoint;\n\tint i;\n\n\tfor (i = 0; i < vop2->data->nr_vps; i++) {\n\t\tendpoint = of_graph_get_endpoint_by_regs(node, i,\n\t\t\t\t\t\t\t ROCKCHIP_VOP2_EP_RGB0);\n\t\tif (!endpoint)\n\t\t\tcontinue;\n\n\t\tof_node_put(endpoint);\n\t\treturn i;\n\t}\n\n\treturn -ENOENT;\n}\n\nstatic struct reg_field vop2_cluster_regs[VOP2_WIN_MAX_REG] = {\n\t[VOP2_WIN_ENABLE] = REG_FIELD(RK3568_CLUSTER_WIN_CTRL0, 0, 0),\n\t[VOP2_WIN_FORMAT] = REG_FIELD(RK3568_CLUSTER_WIN_CTRL0, 1, 5),\n\t[VOP2_WIN_RB_SWAP] = REG_FIELD(RK3568_CLUSTER_WIN_CTRL0, 14, 14),\n\t[VOP2_WIN_DITHER_UP] = REG_FIELD(RK3568_CLUSTER_WIN_CTRL0, 18, 18),\n\t[VOP2_WIN_ACT_INFO] = REG_FIELD(RK3568_CLUSTER_WIN_ACT_INFO, 0, 31),\n\t[VOP2_WIN_DSP_INFO] = REG_FIELD(RK3568_CLUSTER_WIN_DSP_INFO, 0, 31),\n\t[VOP2_WIN_DSP_ST] = REG_FIELD(RK3568_CLUSTER_WIN_DSP_ST, 0, 31),\n\t[VOP2_WIN_YRGB_MST] = REG_FIELD(RK3568_CLUSTER_WIN_YRGB_MST, 0, 31),\n\t[VOP2_WIN_UV_MST] = REG_FIELD(RK3568_CLUSTER_WIN_CBR_MST, 0, 31),\n\t[VOP2_WIN_YUV_CLIP] = REG_FIELD(RK3568_CLUSTER_WIN_CTRL0, 19, 19),\n\t[VOP2_WIN_YRGB_VIR] = REG_FIELD(RK3568_CLUSTER_WIN_VIR, 0, 15),\n\t[VOP2_WIN_UV_VIR] = REG_FIELD(RK3568_CLUSTER_WIN_VIR, 16, 31),\n\t[VOP2_WIN_Y2R_EN] = REG_FIELD(RK3568_CLUSTER_WIN_CTRL0, 8, 8),\n\t[VOP2_WIN_R2Y_EN] = REG_FIELD(RK3568_CLUSTER_WIN_CTRL0, 9, 9),\n\t[VOP2_WIN_CSC_MODE] = REG_FIELD(RK3568_CLUSTER_WIN_CTRL0, 10, 11),\n\n\t \n\t[VOP2_WIN_SCALE_YRGB_X] = REG_FIELD(RK3568_CLUSTER_WIN_SCL_FACTOR_YRGB, 0, 15),\n\t[VOP2_WIN_SCALE_YRGB_Y] = REG_FIELD(RK3568_CLUSTER_WIN_SCL_FACTOR_YRGB, 16, 31),\n\t[VOP2_WIN_YRGB_VER_SCL_MODE] = REG_FIELD(RK3568_CLUSTER_WIN_CTRL1, 14, 15),\n\t[VOP2_WIN_YRGB_HOR_SCL_MODE] = REG_FIELD(RK3568_CLUSTER_WIN_CTRL1, 12, 13),\n\t[VOP2_WIN_BIC_COE_SEL] = REG_FIELD(RK3568_CLUSTER_WIN_CTRL1, 2, 3),\n\t[VOP2_WIN_VSD_YRGB_GT2] = REG_FIELD(RK3568_CLUSTER_WIN_CTRL1, 28, 28),\n\t[VOP2_WIN_VSD_YRGB_GT4] = REG_FIELD(RK3568_CLUSTER_WIN_CTRL1, 29, 29),\n\n\t \n\t[VOP2_WIN_AFBC_ENABLE] = REG_FIELD(RK3568_CLUSTER_CTRL, 1, 1),\n\t[VOP2_WIN_CLUSTER_ENABLE] = REG_FIELD(RK3568_CLUSTER_CTRL, 0, 0),\n\t[VOP2_WIN_CLUSTER_LB_MODE] = REG_FIELD(RK3568_CLUSTER_CTRL, 4, 7),\n\n\t \n\t[VOP2_WIN_AFBC_FORMAT] = REG_FIELD(RK3568_CLUSTER_WIN_AFBCD_CTRL, 2, 6),\n\t[VOP2_WIN_AFBC_RB_SWAP] = REG_FIELD(RK3568_CLUSTER_WIN_AFBCD_CTRL, 9, 9),\n\t[VOP2_WIN_AFBC_UV_SWAP] = REG_FIELD(RK3568_CLUSTER_WIN_AFBCD_CTRL, 10, 10),\n\t[VOP2_WIN_AFBC_AUTO_GATING_EN] = REG_FIELD(RK3568_CLUSTER_WIN_AFBCD_OUTPUT_CTRL, 4, 4),\n\t[VOP2_WIN_AFBC_HALF_BLOCK_EN] = REG_FIELD(RK3568_CLUSTER_WIN_AFBCD_CTRL, 7, 7),\n\t[VOP2_WIN_AFBC_BLOCK_SPLIT_EN] = REG_FIELD(RK3568_CLUSTER_WIN_AFBCD_CTRL, 8, 8),\n\t[VOP2_WIN_AFBC_HDR_PTR] = REG_FIELD(RK3568_CLUSTER_WIN_AFBCD_HDR_PTR, 0, 31),\n\t[VOP2_WIN_AFBC_PIC_SIZE] = REG_FIELD(RK3568_CLUSTER_WIN_AFBCD_PIC_SIZE, 0, 31),\n\t[VOP2_WIN_AFBC_PIC_VIR_WIDTH] = REG_FIELD(RK3568_CLUSTER_WIN_AFBCD_VIR_WIDTH, 0, 15),\n\t[VOP2_WIN_AFBC_TILE_NUM] = REG_FIELD(RK3568_CLUSTER_WIN_AFBCD_VIR_WIDTH, 16, 31),\n\t[VOP2_WIN_AFBC_PIC_OFFSET] = REG_FIELD(RK3568_CLUSTER_WIN_AFBCD_PIC_OFFSET, 0, 31),\n\t[VOP2_WIN_AFBC_DSP_OFFSET] = REG_FIELD(RK3568_CLUSTER_WIN_AFBCD_DSP_OFFSET, 0, 31),\n\t[VOP2_WIN_AFBC_TRANSFORM_OFFSET] = REG_FIELD(RK3568_CLUSTER_WIN_AFBCD_TRANSFORM_OFFSET, 0, 31),\n\t[VOP2_WIN_AFBC_ROTATE_90] = REG_FIELD(RK3568_CLUSTER_WIN_AFBCD_ROTATE_MODE, 0, 0),\n\t[VOP2_WIN_AFBC_ROTATE_270] = REG_FIELD(RK3568_CLUSTER_WIN_AFBCD_ROTATE_MODE, 1, 1),\n\t[VOP2_WIN_XMIRROR] = REG_FIELD(RK3568_CLUSTER_WIN_AFBCD_ROTATE_MODE, 2, 2),\n\t[VOP2_WIN_YMIRROR] = REG_FIELD(RK3568_CLUSTER_WIN_AFBCD_ROTATE_MODE, 3, 3),\n\t[VOP2_WIN_UV_SWAP] = { .reg = 0xffffffff },\n\t[VOP2_WIN_COLOR_KEY] = { .reg = 0xffffffff },\n\t[VOP2_WIN_COLOR_KEY_EN] = { .reg = 0xffffffff },\n\t[VOP2_WIN_SCALE_CBCR_X] = { .reg = 0xffffffff },\n\t[VOP2_WIN_SCALE_CBCR_Y] = { .reg = 0xffffffff },\n\t[VOP2_WIN_YRGB_HSCL_FILTER_MODE] = { .reg = 0xffffffff },\n\t[VOP2_WIN_YRGB_VSCL_FILTER_MODE] = { .reg = 0xffffffff },\n\t[VOP2_WIN_CBCR_VER_SCL_MODE] = { .reg = 0xffffffff },\n\t[VOP2_WIN_CBCR_HSCL_FILTER_MODE] = { .reg = 0xffffffff },\n\t[VOP2_WIN_CBCR_HOR_SCL_MODE] = { .reg = 0xffffffff },\n\t[VOP2_WIN_CBCR_VSCL_FILTER_MODE] = { .reg = 0xffffffff },\n\t[VOP2_WIN_VSD_CBCR_GT2] = { .reg = 0xffffffff },\n\t[VOP2_WIN_VSD_CBCR_GT4] = { .reg = 0xffffffff },\n};\n\nstatic int vop2_cluster_init(struct vop2_win *win)\n{\n\tstruct vop2 *vop2 = win->vop2;\n\tstruct reg_field *cluster_regs;\n\tint ret, i;\n\n\tcluster_regs = kmemdup(vop2_cluster_regs, sizeof(vop2_cluster_regs),\n\t\t\t       GFP_KERNEL);\n\tif (!cluster_regs)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < ARRAY_SIZE(vop2_cluster_regs); i++)\n\t\tif (cluster_regs[i].reg != 0xffffffff)\n\t\t\tcluster_regs[i].reg += win->offset;\n\n\tret = devm_regmap_field_bulk_alloc(vop2->dev, vop2->map, win->reg,\n\t\t\t\t\t   cluster_regs,\n\t\t\t\t\t   ARRAY_SIZE(vop2_cluster_regs));\n\n\tkfree(cluster_regs);\n\n\treturn ret;\n};\n\nstatic struct reg_field vop2_esmart_regs[VOP2_WIN_MAX_REG] = {\n\t[VOP2_WIN_ENABLE] = REG_FIELD(RK3568_SMART_REGION0_CTRL, 0, 0),\n\t[VOP2_WIN_FORMAT] = REG_FIELD(RK3568_SMART_REGION0_CTRL, 1, 5),\n\t[VOP2_WIN_DITHER_UP] = REG_FIELD(RK3568_SMART_REGION0_CTRL, 12, 12),\n\t[VOP2_WIN_RB_SWAP] = REG_FIELD(RK3568_SMART_REGION0_CTRL, 14, 14),\n\t[VOP2_WIN_UV_SWAP] = REG_FIELD(RK3568_SMART_REGION0_CTRL, 16, 16),\n\t[VOP2_WIN_ACT_INFO] = REG_FIELD(RK3568_SMART_REGION0_ACT_INFO, 0, 31),\n\t[VOP2_WIN_DSP_INFO] = REG_FIELD(RK3568_SMART_REGION0_DSP_INFO, 0, 31),\n\t[VOP2_WIN_DSP_ST] = REG_FIELD(RK3568_SMART_REGION0_DSP_ST, 0, 28),\n\t[VOP2_WIN_YRGB_MST] = REG_FIELD(RK3568_SMART_REGION0_YRGB_MST, 0, 31),\n\t[VOP2_WIN_UV_MST] = REG_FIELD(RK3568_SMART_REGION0_CBR_MST, 0, 31),\n\t[VOP2_WIN_YUV_CLIP] = REG_FIELD(RK3568_SMART_REGION0_CTRL, 17, 17),\n\t[VOP2_WIN_YRGB_VIR] = REG_FIELD(RK3568_SMART_REGION0_VIR, 0, 15),\n\t[VOP2_WIN_UV_VIR] = REG_FIELD(RK3568_SMART_REGION0_VIR, 16, 31),\n\t[VOP2_WIN_Y2R_EN] = REG_FIELD(RK3568_SMART_CTRL0, 0, 0),\n\t[VOP2_WIN_R2Y_EN] = REG_FIELD(RK3568_SMART_CTRL0, 1, 1),\n\t[VOP2_WIN_CSC_MODE] = REG_FIELD(RK3568_SMART_CTRL0, 2, 3),\n\t[VOP2_WIN_YMIRROR] = REG_FIELD(RK3568_SMART_CTRL1, 31, 31),\n\t[VOP2_WIN_COLOR_KEY] = REG_FIELD(RK3568_SMART_COLOR_KEY_CTRL, 0, 29),\n\t[VOP2_WIN_COLOR_KEY_EN] = REG_FIELD(RK3568_SMART_COLOR_KEY_CTRL, 31, 31),\n\n\t \n\t[VOP2_WIN_SCALE_YRGB_X] = REG_FIELD(RK3568_SMART_REGION0_SCL_FACTOR_YRGB, 0, 15),\n\t[VOP2_WIN_SCALE_YRGB_Y] = REG_FIELD(RK3568_SMART_REGION0_SCL_FACTOR_YRGB, 16, 31),\n\t[VOP2_WIN_SCALE_CBCR_X] = REG_FIELD(RK3568_SMART_REGION0_SCL_FACTOR_CBR, 0, 15),\n\t[VOP2_WIN_SCALE_CBCR_Y] = REG_FIELD(RK3568_SMART_REGION0_SCL_FACTOR_CBR, 16, 31),\n\t[VOP2_WIN_YRGB_HOR_SCL_MODE] = REG_FIELD(RK3568_SMART_REGION0_SCL_CTRL, 0, 1),\n\t[VOP2_WIN_YRGB_HSCL_FILTER_MODE] = REG_FIELD(RK3568_SMART_REGION0_SCL_CTRL, 2, 3),\n\t[VOP2_WIN_YRGB_VER_SCL_MODE] = REG_FIELD(RK3568_SMART_REGION0_SCL_CTRL, 4, 5),\n\t[VOP2_WIN_YRGB_VSCL_FILTER_MODE] = REG_FIELD(RK3568_SMART_REGION0_SCL_CTRL, 6, 7),\n\t[VOP2_WIN_CBCR_HOR_SCL_MODE] = REG_FIELD(RK3568_SMART_REGION0_SCL_CTRL, 8, 9),\n\t[VOP2_WIN_CBCR_HSCL_FILTER_MODE] = REG_FIELD(RK3568_SMART_REGION0_SCL_CTRL, 10, 11),\n\t[VOP2_WIN_CBCR_VER_SCL_MODE] = REG_FIELD(RK3568_SMART_REGION0_SCL_CTRL, 12, 13),\n\t[VOP2_WIN_CBCR_VSCL_FILTER_MODE] = REG_FIELD(RK3568_SMART_REGION0_SCL_CTRL, 14, 15),\n\t[VOP2_WIN_BIC_COE_SEL] = REG_FIELD(RK3568_SMART_REGION0_SCL_CTRL, 16, 17),\n\t[VOP2_WIN_VSD_YRGB_GT2] = REG_FIELD(RK3568_SMART_REGION0_CTRL, 8, 8),\n\t[VOP2_WIN_VSD_YRGB_GT4] = REG_FIELD(RK3568_SMART_REGION0_CTRL, 9, 9),\n\t[VOP2_WIN_VSD_CBCR_GT2] = REG_FIELD(RK3568_SMART_REGION0_CTRL, 10, 10),\n\t[VOP2_WIN_VSD_CBCR_GT4] = REG_FIELD(RK3568_SMART_REGION0_CTRL, 11, 11),\n\t[VOP2_WIN_XMIRROR] = { .reg = 0xffffffff },\n\t[VOP2_WIN_CLUSTER_ENABLE] = { .reg = 0xffffffff },\n\t[VOP2_WIN_AFBC_ENABLE] = { .reg = 0xffffffff },\n\t[VOP2_WIN_CLUSTER_LB_MODE] = { .reg = 0xffffffff },\n\t[VOP2_WIN_AFBC_FORMAT] = { .reg = 0xffffffff },\n\t[VOP2_WIN_AFBC_RB_SWAP] = { .reg = 0xffffffff },\n\t[VOP2_WIN_AFBC_UV_SWAP] = { .reg = 0xffffffff },\n\t[VOP2_WIN_AFBC_AUTO_GATING_EN] = { .reg = 0xffffffff },\n\t[VOP2_WIN_AFBC_BLOCK_SPLIT_EN] = { .reg = 0xffffffff },\n\t[VOP2_WIN_AFBC_PIC_VIR_WIDTH] = { .reg = 0xffffffff },\n\t[VOP2_WIN_AFBC_TILE_NUM] = { .reg = 0xffffffff },\n\t[VOP2_WIN_AFBC_PIC_OFFSET] = { .reg = 0xffffffff },\n\t[VOP2_WIN_AFBC_PIC_SIZE] = { .reg = 0xffffffff },\n\t[VOP2_WIN_AFBC_DSP_OFFSET] = { .reg = 0xffffffff },\n\t[VOP2_WIN_AFBC_TRANSFORM_OFFSET] = { .reg = 0xffffffff },\n\t[VOP2_WIN_AFBC_HDR_PTR] = { .reg = 0xffffffff },\n\t[VOP2_WIN_AFBC_HALF_BLOCK_EN] = { .reg = 0xffffffff },\n\t[VOP2_WIN_AFBC_ROTATE_270] = { .reg = 0xffffffff },\n\t[VOP2_WIN_AFBC_ROTATE_90] = { .reg = 0xffffffff },\n};\n\nstatic int vop2_esmart_init(struct vop2_win *win)\n{\n\tstruct vop2 *vop2 = win->vop2;\n\tstruct reg_field *esmart_regs;\n\tint ret, i;\n\n\tesmart_regs = kmemdup(vop2_esmart_regs, sizeof(vop2_esmart_regs),\n\t\t\t      GFP_KERNEL);\n\tif (!esmart_regs)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < ARRAY_SIZE(vop2_esmart_regs); i++)\n\t\tif (esmart_regs[i].reg != 0xffffffff)\n\t\t\tesmart_regs[i].reg += win->offset;\n\n\tret = devm_regmap_field_bulk_alloc(vop2->dev, vop2->map, win->reg,\n\t\t\t\t\t   esmart_regs,\n\t\t\t\t\t   ARRAY_SIZE(vop2_esmart_regs));\n\n\tkfree(esmart_regs);\n\n\treturn ret;\n};\n\nstatic int vop2_win_init(struct vop2 *vop2)\n{\n\tconst struct vop2_data *vop2_data = vop2->data;\n\tstruct vop2_win *win;\n\tint i, ret;\n\n\tfor (i = 0; i < vop2_data->win_size; i++) {\n\t\tconst struct vop2_win_data *win_data = &vop2_data->win[i];\n\n\t\twin = &vop2->win[i];\n\t\twin->data = win_data;\n\t\twin->type = win_data->type;\n\t\twin->offset = win_data->base;\n\t\twin->win_id = i;\n\t\twin->vop2 = vop2;\n\t\tif (vop2_cluster_window(win))\n\t\t\tret = vop2_cluster_init(win);\n\t\telse\n\t\t\tret = vop2_esmart_init(win);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tvop2->registered_num_wins = vop2_data->win_size;\n\n\treturn 0;\n}\n\n \nstatic const struct regmap_range vop2_nonvolatile_range[] = {\n\tregmap_reg_range(0x1000, 0x23ff),\n};\n\nstatic const struct regmap_access_table vop2_volatile_table = {\n\t.no_ranges = vop2_nonvolatile_range,\n\t.n_no_ranges = ARRAY_SIZE(vop2_nonvolatile_range),\n};\n\nstatic const struct regmap_config vop2_regmap_config = {\n\t.reg_bits\t= 32,\n\t.val_bits\t= 32,\n\t.reg_stride\t= 4,\n\t.max_register\t= 0x3000,\n\t.name\t\t= \"vop2\",\n\t.volatile_table\t= &vop2_volatile_table,\n\t.cache_type\t= REGCACHE_RBTREE,\n};\n\nstatic int vop2_bind(struct device *dev, struct device *master, void *data)\n{\n\tstruct platform_device *pdev = to_platform_device(dev);\n\tconst struct vop2_data *vop2_data;\n\tstruct drm_device *drm = data;\n\tstruct vop2 *vop2;\n\tstruct resource *res;\n\tsize_t alloc_size;\n\tint ret;\n\n\tvop2_data = of_device_get_match_data(dev);\n\tif (!vop2_data)\n\t\treturn -ENODEV;\n\n\t \n\talloc_size = struct_size(vop2, win, vop2_data->win_size);\n\tvop2 = devm_kzalloc(dev, alloc_size, GFP_KERNEL);\n\tif (!vop2)\n\t\treturn -ENOMEM;\n\n\tvop2->dev = dev;\n\tvop2->data = vop2_data;\n\tvop2->drm = drm;\n\n\tdev_set_drvdata(dev, vop2);\n\n\tres = platform_get_resource_byname(pdev, IORESOURCE_MEM, \"vop\");\n\tif (!res) {\n\t\tdrm_err(vop2->drm, \"failed to get vop2 register byname\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tvop2->regs = devm_ioremap_resource(dev, res);\n\tif (IS_ERR(vop2->regs))\n\t\treturn PTR_ERR(vop2->regs);\n\tvop2->len = resource_size(res);\n\n\tvop2->map = devm_regmap_init_mmio(dev, vop2->regs, &vop2_regmap_config);\n\tif (IS_ERR(vop2->map))\n\t\treturn PTR_ERR(vop2->map);\n\n\tret = vop2_win_init(vop2);\n\tif (ret)\n\t\treturn ret;\n\n\tres = platform_get_resource_byname(pdev, IORESOURCE_MEM, \"gamma-lut\");\n\tif (res) {\n\t\tvop2->lut_regs = devm_ioremap_resource(dev, res);\n\t\tif (IS_ERR(vop2->lut_regs))\n\t\t\treturn PTR_ERR(vop2->lut_regs);\n\t}\n\n\tvop2->grf = syscon_regmap_lookup_by_phandle(dev->of_node, \"rockchip,grf\");\n\n\tvop2->hclk = devm_clk_get(vop2->dev, \"hclk\");\n\tif (IS_ERR(vop2->hclk)) {\n\t\tdrm_err(vop2->drm, \"failed to get hclk source\\n\");\n\t\treturn PTR_ERR(vop2->hclk);\n\t}\n\n\tvop2->aclk = devm_clk_get(vop2->dev, \"aclk\");\n\tif (IS_ERR(vop2->aclk)) {\n\t\tdrm_err(vop2->drm, \"failed to get aclk source\\n\");\n\t\treturn PTR_ERR(vop2->aclk);\n\t}\n\n\tvop2->irq = platform_get_irq(pdev, 0);\n\tif (vop2->irq < 0) {\n\t\tdrm_err(vop2->drm, \"cannot find irq for vop2\\n\");\n\t\treturn vop2->irq;\n\t}\n\n\tmutex_init(&vop2->vop2_lock);\n\n\tret = devm_request_irq(dev, vop2->irq, vop2_isr, IRQF_SHARED, dev_name(dev), vop2);\n\tif (ret)\n\t\treturn ret;\n\n\tret = vop2_create_crtcs(vop2);\n\tif (ret)\n\t\treturn ret;\n\n\tret = vop2_find_rgb_encoder(vop2);\n\tif (ret >= 0) {\n\t\tvop2->rgb = rockchip_rgb_init(dev, &vop2->vps[ret].crtc,\n\t\t\t\t\t      vop2->drm, ret);\n\t\tif (IS_ERR(vop2->rgb)) {\n\t\t\tif (PTR_ERR(vop2->rgb) == -EPROBE_DEFER) {\n\t\t\t\tret = PTR_ERR(vop2->rgb);\n\t\t\t\tgoto err_crtcs;\n\t\t\t}\n\t\t\tvop2->rgb = NULL;\n\t\t}\n\t}\n\n\trockchip_drm_dma_init_device(vop2->drm, vop2->dev);\n\n\tpm_runtime_enable(&pdev->dev);\n\n\treturn 0;\n\nerr_crtcs:\n\tvop2_destroy_crtcs(vop2);\n\n\treturn ret;\n}\n\nstatic void vop2_unbind(struct device *dev, struct device *master, void *data)\n{\n\tstruct vop2 *vop2 = dev_get_drvdata(dev);\n\n\tpm_runtime_disable(dev);\n\n\tif (vop2->rgb)\n\t\trockchip_rgb_fini(vop2->rgb);\n\n\tvop2_destroy_crtcs(vop2);\n}\n\nconst struct component_ops vop2_component_ops = {\n\t.bind = vop2_bind,\n\t.unbind = vop2_unbind,\n};\nEXPORT_SYMBOL_GPL(vop2_component_ops);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}