{
  "module_name": "cdn-dp-core.c",
  "hash_id": "9268fbaa4ad2aa02a9ac6d88a2d850dcf5d4883e7ff8f97a55317ac394cef2cd",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/rockchip/cdn-dp-core.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/component.h>\n#include <linux/extcon.h>\n#include <linux/firmware.h>\n#include <linux/mfd/syscon.h>\n#include <linux/phy/phy.h>\n#include <linux/regmap.h>\n#include <linux/reset.h>\n\n#include <sound/hdmi-codec.h>\n\n#include <drm/display/drm_dp_helper.h>\n#include <drm/drm_atomic_helper.h>\n#include <drm/drm_edid.h>\n#include <drm/drm_of.h>\n#include <drm/drm_probe_helper.h>\n#include <drm/drm_simple_kms_helper.h>\n\n#include \"cdn-dp-core.h\"\n#include \"cdn-dp-reg.h\"\n#include \"rockchip_drm_vop.h\"\n\nstatic inline struct cdn_dp_device *connector_to_dp(struct drm_connector *connector)\n{\n\treturn container_of(connector, struct cdn_dp_device, connector);\n}\n\nstatic inline struct cdn_dp_device *encoder_to_dp(struct drm_encoder *encoder)\n{\n\tstruct rockchip_encoder *rkencoder = to_rockchip_encoder(encoder);\n\n\treturn container_of(rkencoder, struct cdn_dp_device, encoder);\n}\n\n#define GRF_SOC_CON9\t\t0x6224\n#define DP_SEL_VOP_LIT\t\tBIT(12)\n#define GRF_SOC_CON26\t\t0x6268\n#define DPTX_HPD_SEL\t\t(3 << 12)\n#define DPTX_HPD_DEL\t\t(2 << 12)\n#define DPTX_HPD_SEL_MASK\t(3 << 28)\n\n#define CDN_FW_TIMEOUT_MS\t(64 * 1000)\n#define CDN_DPCD_TIMEOUT_MS\t5000\n#define CDN_DP_FIRMWARE\t\t\"rockchip/dptx.bin\"\nMODULE_FIRMWARE(CDN_DP_FIRMWARE);\n\nstruct cdn_dp_data {\n\tu8 max_phy;\n};\n\nstatic struct cdn_dp_data rk3399_cdn_dp = {\n\t.max_phy = 2,\n};\n\nstatic const struct of_device_id cdn_dp_dt_ids[] = {\n\t{ .compatible = \"rockchip,rk3399-cdn-dp\",\n\t\t.data = (void *)&rk3399_cdn_dp },\n\t{}\n};\n\nMODULE_DEVICE_TABLE(of, cdn_dp_dt_ids);\n\nstatic int cdn_dp_grf_write(struct cdn_dp_device *dp,\n\t\t\t    unsigned int reg, unsigned int val)\n{\n\tint ret;\n\n\tret = clk_prepare_enable(dp->grf_clk);\n\tif (ret) {\n\t\tDRM_DEV_ERROR(dp->dev, \"Failed to prepare_enable grf clock\\n\");\n\t\treturn ret;\n\t}\n\n\tret = regmap_write(dp->grf, reg, val);\n\tif (ret) {\n\t\tDRM_DEV_ERROR(dp->dev, \"Could not write to GRF: %d\\n\", ret);\n\t\tclk_disable_unprepare(dp->grf_clk);\n\t\treturn ret;\n\t}\n\n\tclk_disable_unprepare(dp->grf_clk);\n\n\treturn 0;\n}\n\nstatic int cdn_dp_clk_enable(struct cdn_dp_device *dp)\n{\n\tint ret;\n\tunsigned long rate;\n\n\tret = clk_prepare_enable(dp->pclk);\n\tif (ret < 0) {\n\t\tDRM_DEV_ERROR(dp->dev, \"cannot enable dp pclk %d\\n\", ret);\n\t\tgoto err_pclk;\n\t}\n\n\tret = clk_prepare_enable(dp->core_clk);\n\tif (ret < 0) {\n\t\tDRM_DEV_ERROR(dp->dev, \"cannot enable core_clk %d\\n\", ret);\n\t\tgoto err_core_clk;\n\t}\n\n\tret = pm_runtime_get_sync(dp->dev);\n\tif (ret < 0) {\n\t\tDRM_DEV_ERROR(dp->dev, \"cannot get pm runtime %d\\n\", ret);\n\t\tgoto err_pm_runtime_get;\n\t}\n\n\treset_control_assert(dp->core_rst);\n\treset_control_assert(dp->dptx_rst);\n\treset_control_assert(dp->apb_rst);\n\treset_control_deassert(dp->core_rst);\n\treset_control_deassert(dp->dptx_rst);\n\treset_control_deassert(dp->apb_rst);\n\n\trate = clk_get_rate(dp->core_clk);\n\tif (!rate) {\n\t\tDRM_DEV_ERROR(dp->dev, \"get clk rate failed\\n\");\n\t\tret = -EINVAL;\n\t\tgoto err_set_rate;\n\t}\n\n\tcdn_dp_set_fw_clk(dp, rate);\n\tcdn_dp_clock_reset(dp);\n\n\treturn 0;\n\nerr_set_rate:\n\tpm_runtime_put(dp->dev);\nerr_pm_runtime_get:\n\tclk_disable_unprepare(dp->core_clk);\nerr_core_clk:\n\tclk_disable_unprepare(dp->pclk);\nerr_pclk:\n\treturn ret;\n}\n\nstatic void cdn_dp_clk_disable(struct cdn_dp_device *dp)\n{\n\tpm_runtime_put_sync(dp->dev);\n\tclk_disable_unprepare(dp->pclk);\n\tclk_disable_unprepare(dp->core_clk);\n}\n\nstatic int cdn_dp_get_port_lanes(struct cdn_dp_port *port)\n{\n\tstruct extcon_dev *edev = port->extcon;\n\tunion extcon_property_value property;\n\tint dptx;\n\tu8 lanes;\n\n\tdptx = extcon_get_state(edev, EXTCON_DISP_DP);\n\tif (dptx > 0) {\n\t\textcon_get_property(edev, EXTCON_DISP_DP,\n\t\t\t\t    EXTCON_PROP_USB_SS, &property);\n\t\tif (property.intval)\n\t\t\tlanes = 2;\n\t\telse\n\t\t\tlanes = 4;\n\t} else {\n\t\tlanes = 0;\n\t}\n\n\treturn lanes;\n}\n\nstatic int cdn_dp_get_sink_count(struct cdn_dp_device *dp, u8 *sink_count)\n{\n\tint ret;\n\tu8 value;\n\n\t*sink_count = 0;\n\tret = cdn_dp_dpcd_read(dp, DP_SINK_COUNT, &value, 1);\n\tif (ret)\n\t\treturn ret;\n\n\t*sink_count = DP_GET_SINK_COUNT(value);\n\treturn 0;\n}\n\nstatic struct cdn_dp_port *cdn_dp_connected_port(struct cdn_dp_device *dp)\n{\n\tstruct cdn_dp_port *port;\n\tint i, lanes;\n\n\tfor (i = 0; i < dp->ports; i++) {\n\t\tport = dp->port[i];\n\t\tlanes = cdn_dp_get_port_lanes(port);\n\t\tif (lanes)\n\t\t\treturn port;\n\t}\n\treturn NULL;\n}\n\nstatic bool cdn_dp_check_sink_connection(struct cdn_dp_device *dp)\n{\n\tunsigned long timeout = jiffies + msecs_to_jiffies(CDN_DPCD_TIMEOUT_MS);\n\tstruct cdn_dp_port *port;\n\tu8 sink_count = 0;\n\n\tif (dp->active_port < 0 || dp->active_port >= dp->ports) {\n\t\tDRM_DEV_ERROR(dp->dev, \"active_port is wrong!\\n\");\n\t\treturn false;\n\t}\n\n\tport = dp->port[dp->active_port];\n\n\t \n\twhile (time_before(jiffies, timeout)) {\n\t\tif (!extcon_get_state(port->extcon, EXTCON_DISP_DP))\n\t\t\treturn false;\n\n\t\tif (!cdn_dp_get_sink_count(dp, &sink_count))\n\t\t\treturn sink_count ? true : false;\n\n\t\tusleep_range(5000, 10000);\n\t}\n\n\tDRM_DEV_ERROR(dp->dev, \"Get sink capability timed out\\n\");\n\treturn false;\n}\n\nstatic enum drm_connector_status\ncdn_dp_connector_detect(struct drm_connector *connector, bool force)\n{\n\tstruct cdn_dp_device *dp = connector_to_dp(connector);\n\tenum drm_connector_status status = connector_status_disconnected;\n\n\tmutex_lock(&dp->lock);\n\tif (dp->connected)\n\t\tstatus = connector_status_connected;\n\tmutex_unlock(&dp->lock);\n\n\treturn status;\n}\n\nstatic void cdn_dp_connector_destroy(struct drm_connector *connector)\n{\n\tdrm_connector_unregister(connector);\n\tdrm_connector_cleanup(connector);\n}\n\nstatic const struct drm_connector_funcs cdn_dp_atomic_connector_funcs = {\n\t.detect = cdn_dp_connector_detect,\n\t.destroy = cdn_dp_connector_destroy,\n\t.fill_modes = drm_helper_probe_single_connector_modes,\n\t.reset = drm_atomic_helper_connector_reset,\n\t.atomic_duplicate_state = drm_atomic_helper_connector_duplicate_state,\n\t.atomic_destroy_state = drm_atomic_helper_connector_destroy_state,\n};\n\nstatic int cdn_dp_connector_get_modes(struct drm_connector *connector)\n{\n\tstruct cdn_dp_device *dp = connector_to_dp(connector);\n\tstruct edid *edid;\n\tint ret = 0;\n\n\tmutex_lock(&dp->lock);\n\tedid = dp->edid;\n\tif (edid) {\n\t\tDRM_DEV_DEBUG_KMS(dp->dev, \"got edid: width[%d] x height[%d]\\n\",\n\t\t\t\t  edid->width_cm, edid->height_cm);\n\n\t\tdp->sink_has_audio = drm_detect_monitor_audio(edid);\n\n\t\tdrm_connector_update_edid_property(connector, edid);\n\t\tret = drm_add_edid_modes(connector, edid);\n\t}\n\tmutex_unlock(&dp->lock);\n\n\treturn ret;\n}\n\nstatic enum drm_mode_status\ncdn_dp_connector_mode_valid(struct drm_connector *connector,\n\t\t\t    struct drm_display_mode *mode)\n{\n\tstruct cdn_dp_device *dp = connector_to_dp(connector);\n\tstruct drm_display_info *display_info = &dp->connector.display_info;\n\tu32 requested, actual, rate, sink_max, source_max = 0;\n\tu8 lanes, bpc;\n\n\t \n\tif (!dp->connected)\n\t\treturn MODE_BAD;\n\n\tswitch (display_info->bpc) {\n\tcase 10:\n\t\tbpc = 10;\n\t\tbreak;\n\tcase 6:\n\t\tbpc = 6;\n\t\tbreak;\n\tdefault:\n\t\tbpc = 8;\n\t\tbreak;\n\t}\n\n\trequested = mode->clock * bpc * 3 / 1000;\n\n\tsource_max = dp->lanes;\n\tsink_max = drm_dp_max_lane_count(dp->dpcd);\n\tlanes = min(source_max, sink_max);\n\n\tsource_max = drm_dp_bw_code_to_link_rate(CDN_DP_MAX_LINK_RATE);\n\tsink_max = drm_dp_max_link_rate(dp->dpcd);\n\trate = min(source_max, sink_max);\n\n\tactual = rate * lanes / 100;\n\n\t \n\tactual = actual * 8 / 10;\n\n\tif (requested > actual) {\n\t\tDRM_DEV_DEBUG_KMS(dp->dev,\n\t\t\t\t  \"requested=%d, actual=%d, clock=%d\\n\",\n\t\t\t\t  requested, actual, mode->clock);\n\t\treturn MODE_CLOCK_HIGH;\n\t}\n\n\treturn MODE_OK;\n}\n\nstatic struct drm_connector_helper_funcs cdn_dp_connector_helper_funcs = {\n\t.get_modes = cdn_dp_connector_get_modes,\n\t.mode_valid = cdn_dp_connector_mode_valid,\n};\n\nstatic int cdn_dp_firmware_init(struct cdn_dp_device *dp)\n{\n\tint ret;\n\tconst u32 *iram_data, *dram_data;\n\tconst struct firmware *fw = dp->fw;\n\tconst struct cdn_firmware_header *hdr;\n\n\thdr = (struct cdn_firmware_header *)fw->data;\n\tif (fw->size != le32_to_cpu(hdr->size_bytes)) {\n\t\tDRM_DEV_ERROR(dp->dev, \"firmware is invalid\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tiram_data = (const u32 *)(fw->data + hdr->header_size);\n\tdram_data = (const u32 *)(fw->data + hdr->header_size + hdr->iram_size);\n\n\tret = cdn_dp_load_firmware(dp, iram_data, hdr->iram_size,\n\t\t\t\t   dram_data, hdr->dram_size);\n\tif (ret)\n\t\treturn ret;\n\n\tret = cdn_dp_set_firmware_active(dp, true);\n\tif (ret) {\n\t\tDRM_DEV_ERROR(dp->dev, \"active ucpu failed: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\treturn cdn_dp_event_config(dp);\n}\n\nstatic int cdn_dp_get_sink_capability(struct cdn_dp_device *dp)\n{\n\tint ret;\n\n\tif (!cdn_dp_check_sink_connection(dp))\n\t\treturn -ENODEV;\n\n\tret = cdn_dp_dpcd_read(dp, DP_DPCD_REV, dp->dpcd,\n\t\t\t       DP_RECEIVER_CAP_SIZE);\n\tif (ret) {\n\t\tDRM_DEV_ERROR(dp->dev, \"Failed to get caps %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tkfree(dp->edid);\n\tdp->edid = drm_do_get_edid(&dp->connector,\n\t\t\t\t   cdn_dp_get_edid_block, dp);\n\treturn 0;\n}\n\nstatic int cdn_dp_enable_phy(struct cdn_dp_device *dp, struct cdn_dp_port *port)\n{\n\tunion extcon_property_value property;\n\tint ret;\n\n\tif (!port->phy_enabled) {\n\t\tret = phy_power_on(port->phy);\n\t\tif (ret) {\n\t\t\tDRM_DEV_ERROR(dp->dev, \"phy power on failed: %d\\n\",\n\t\t\t\t      ret);\n\t\t\tgoto err_phy;\n\t\t}\n\t\tport->phy_enabled = true;\n\t}\n\n\tret = cdn_dp_grf_write(dp, GRF_SOC_CON26,\n\t\t\t       DPTX_HPD_SEL_MASK | DPTX_HPD_SEL);\n\tif (ret) {\n\t\tDRM_DEV_ERROR(dp->dev, \"Failed to write HPD_SEL %d\\n\", ret);\n\t\tgoto err_power_on;\n\t}\n\n\tret = cdn_dp_get_hpd_status(dp);\n\tif (ret <= 0) {\n\t\tif (!ret)\n\t\t\tDRM_DEV_ERROR(dp->dev, \"hpd does not exist\\n\");\n\t\tgoto err_power_on;\n\t}\n\n\tret = extcon_get_property(port->extcon, EXTCON_DISP_DP,\n\t\t\t\t  EXTCON_PROP_USB_TYPEC_POLARITY, &property);\n\tif (ret) {\n\t\tDRM_DEV_ERROR(dp->dev, \"get property failed\\n\");\n\t\tgoto err_power_on;\n\t}\n\n\tport->lanes = cdn_dp_get_port_lanes(port);\n\tret = cdn_dp_set_host_cap(dp, port->lanes, property.intval);\n\tif (ret) {\n\t\tDRM_DEV_ERROR(dp->dev, \"set host capabilities failed: %d\\n\",\n\t\t\t      ret);\n\t\tgoto err_power_on;\n\t}\n\n\tdp->active_port = port->id;\n\treturn 0;\n\nerr_power_on:\n\tif (phy_power_off(port->phy))\n\t\tDRM_DEV_ERROR(dp->dev, \"phy power off failed: %d\", ret);\n\telse\n\t\tport->phy_enabled = false;\n\nerr_phy:\n\tcdn_dp_grf_write(dp, GRF_SOC_CON26,\n\t\t\t DPTX_HPD_SEL_MASK | DPTX_HPD_DEL);\n\treturn ret;\n}\n\nstatic int cdn_dp_disable_phy(struct cdn_dp_device *dp,\n\t\t\t      struct cdn_dp_port *port)\n{\n\tint ret;\n\n\tif (port->phy_enabled) {\n\t\tret = phy_power_off(port->phy);\n\t\tif (ret) {\n\t\t\tDRM_DEV_ERROR(dp->dev, \"phy power off failed: %d\", ret);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tport->phy_enabled = false;\n\tport->lanes = 0;\n\tdp->active_port = -1;\n\treturn 0;\n}\n\nstatic int cdn_dp_disable(struct cdn_dp_device *dp)\n{\n\tint ret, i;\n\n\tif (!dp->active)\n\t\treturn 0;\n\n\tfor (i = 0; i < dp->ports; i++)\n\t\tcdn_dp_disable_phy(dp, dp->port[i]);\n\n\tret = cdn_dp_grf_write(dp, GRF_SOC_CON26,\n\t\t\t       DPTX_HPD_SEL_MASK | DPTX_HPD_DEL);\n\tif (ret) {\n\t\tDRM_DEV_ERROR(dp->dev, \"Failed to clear hpd sel %d\\n\",\n\t\t\t      ret);\n\t\treturn ret;\n\t}\n\n\tcdn_dp_set_firmware_active(dp, false);\n\tcdn_dp_clk_disable(dp);\n\tdp->active = false;\n\tdp->max_lanes = 0;\n\tdp->max_rate = 0;\n\tif (!dp->connected) {\n\t\tkfree(dp->edid);\n\t\tdp->edid = NULL;\n\t}\n\n\treturn 0;\n}\n\nstatic int cdn_dp_enable(struct cdn_dp_device *dp)\n{\n\tint ret, i, lanes;\n\tstruct cdn_dp_port *port;\n\n\tport = cdn_dp_connected_port(dp);\n\tif (!port) {\n\t\tDRM_DEV_ERROR(dp->dev,\n\t\t\t      \"Can't enable without connection\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tif (dp->active)\n\t\treturn 0;\n\n\tret = cdn_dp_clk_enable(dp);\n\tif (ret)\n\t\treturn ret;\n\n\tret = cdn_dp_firmware_init(dp);\n\tif (ret) {\n\t\tDRM_DEV_ERROR(dp->dev, \"firmware init failed: %d\", ret);\n\t\tgoto err_clk_disable;\n\t}\n\n\t \n\tfor (i = port->id; i < dp->ports; i++) {\n\t\tport = dp->port[i];\n\t\tlanes = cdn_dp_get_port_lanes(port);\n\t\tif (lanes) {\n\t\t\tret = cdn_dp_enable_phy(dp, port);\n\t\t\tif (ret)\n\t\t\t\tcontinue;\n\n\t\t\tret = cdn_dp_get_sink_capability(dp);\n\t\t\tif (ret) {\n\t\t\t\tcdn_dp_disable_phy(dp, port);\n\t\t\t} else {\n\t\t\t\tdp->active = true;\n\t\t\t\tdp->lanes = port->lanes;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t}\n\nerr_clk_disable:\n\tcdn_dp_clk_disable(dp);\n\treturn ret;\n}\n\nstatic void cdn_dp_encoder_mode_set(struct drm_encoder *encoder,\n\t\t\t\t    struct drm_display_mode *mode,\n\t\t\t\t    struct drm_display_mode *adjusted)\n{\n\tstruct cdn_dp_device *dp = encoder_to_dp(encoder);\n\tstruct drm_display_info *display_info = &dp->connector.display_info;\n\tstruct video_info *video = &dp->video_info;\n\n\tswitch (display_info->bpc) {\n\tcase 10:\n\t\tvideo->color_depth = 10;\n\t\tbreak;\n\tcase 6:\n\t\tvideo->color_depth = 6;\n\t\tbreak;\n\tdefault:\n\t\tvideo->color_depth = 8;\n\t\tbreak;\n\t}\n\n\tvideo->color_fmt = PXL_RGB;\n\tvideo->v_sync_polarity = !!(mode->flags & DRM_MODE_FLAG_NVSYNC);\n\tvideo->h_sync_polarity = !!(mode->flags & DRM_MODE_FLAG_NHSYNC);\n\n\tdrm_mode_copy(&dp->mode, adjusted);\n}\n\nstatic bool cdn_dp_check_link_status(struct cdn_dp_device *dp)\n{\n\tu8 link_status[DP_LINK_STATUS_SIZE];\n\tstruct cdn_dp_port *port = cdn_dp_connected_port(dp);\n\tu8 sink_lanes = drm_dp_max_lane_count(dp->dpcd);\n\n\tif (!port || !dp->max_rate || !dp->max_lanes)\n\t\treturn false;\n\n\tif (cdn_dp_dpcd_read(dp, DP_LANE0_1_STATUS, link_status,\n\t\t\t     DP_LINK_STATUS_SIZE)) {\n\t\tDRM_ERROR(\"Failed to get link status\\n\");\n\t\treturn false;\n\t}\n\n\t \n\treturn drm_dp_channel_eq_ok(link_status, min(port->lanes, sink_lanes));\n}\n\nstatic void cdn_dp_audio_handle_plugged_change(struct cdn_dp_device *dp,\n\t\t\t\t\t       bool plugged)\n{\n\tif (dp->codec_dev)\n\t\tdp->plugged_cb(dp->codec_dev, plugged);\n}\n\nstatic void cdn_dp_encoder_enable(struct drm_encoder *encoder)\n{\n\tstruct cdn_dp_device *dp = encoder_to_dp(encoder);\n\tint ret, val;\n\n\tret = drm_of_encoder_active_endpoint_id(dp->dev->of_node, encoder);\n\tif (ret < 0) {\n\t\tDRM_DEV_ERROR(dp->dev, \"Could not get vop id, %d\", ret);\n\t\treturn;\n\t}\n\n\tDRM_DEV_DEBUG_KMS(dp->dev, \"vop %s output to cdn-dp\\n\",\n\t\t\t  (ret) ? \"LIT\" : \"BIG\");\n\tif (ret)\n\t\tval = DP_SEL_VOP_LIT | (DP_SEL_VOP_LIT << 16);\n\telse\n\t\tval = DP_SEL_VOP_LIT << 16;\n\n\tret = cdn_dp_grf_write(dp, GRF_SOC_CON9, val);\n\tif (ret)\n\t\treturn;\n\n\tmutex_lock(&dp->lock);\n\n\tret = cdn_dp_enable(dp);\n\tif (ret) {\n\t\tDRM_DEV_ERROR(dp->dev, \"Failed to enable encoder %d\\n\",\n\t\t\t      ret);\n\t\tgoto out;\n\t}\n\tif (!cdn_dp_check_link_status(dp)) {\n\t\tret = cdn_dp_train_link(dp);\n\t\tif (ret) {\n\t\t\tDRM_DEV_ERROR(dp->dev, \"Failed link train %d\\n\", ret);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tret = cdn_dp_set_video_status(dp, CONTROL_VIDEO_IDLE);\n\tif (ret) {\n\t\tDRM_DEV_ERROR(dp->dev, \"Failed to idle video %d\\n\", ret);\n\t\tgoto out;\n\t}\n\n\tret = cdn_dp_config_video(dp);\n\tif (ret) {\n\t\tDRM_DEV_ERROR(dp->dev, \"Failed to config video %d\\n\", ret);\n\t\tgoto out;\n\t}\n\n\tret = cdn_dp_set_video_status(dp, CONTROL_VIDEO_VALID);\n\tif (ret) {\n\t\tDRM_DEV_ERROR(dp->dev, \"Failed to valid video %d\\n\", ret);\n\t\tgoto out;\n\t}\n\n\tcdn_dp_audio_handle_plugged_change(dp, true);\n\nout:\n\tmutex_unlock(&dp->lock);\n}\n\nstatic void cdn_dp_encoder_disable(struct drm_encoder *encoder)\n{\n\tstruct cdn_dp_device *dp = encoder_to_dp(encoder);\n\tint ret;\n\n\tmutex_lock(&dp->lock);\n\tcdn_dp_audio_handle_plugged_change(dp, false);\n\n\tif (dp->active) {\n\t\tret = cdn_dp_disable(dp);\n\t\tif (ret) {\n\t\t\tDRM_DEV_ERROR(dp->dev, \"Failed to disable encoder %d\\n\",\n\t\t\t\t      ret);\n\t\t}\n\t}\n\tmutex_unlock(&dp->lock);\n\n\t \n\tif (!dp->connected && cdn_dp_connected_port(dp))\n\t\tschedule_work(&dp->event_work);\n}\n\nstatic int cdn_dp_encoder_atomic_check(struct drm_encoder *encoder,\n\t\t\t\t       struct drm_crtc_state *crtc_state,\n\t\t\t\t       struct drm_connector_state *conn_state)\n{\n\tstruct rockchip_crtc_state *s = to_rockchip_crtc_state(crtc_state);\n\n\ts->output_mode = ROCKCHIP_OUT_MODE_AAAA;\n\ts->output_type = DRM_MODE_CONNECTOR_DisplayPort;\n\n\treturn 0;\n}\n\nstatic const struct drm_encoder_helper_funcs cdn_dp_encoder_helper_funcs = {\n\t.mode_set = cdn_dp_encoder_mode_set,\n\t.enable = cdn_dp_encoder_enable,\n\t.disable = cdn_dp_encoder_disable,\n\t.atomic_check = cdn_dp_encoder_atomic_check,\n};\n\nstatic int cdn_dp_parse_dt(struct cdn_dp_device *dp)\n{\n\tstruct device *dev = dp->dev;\n\tstruct device_node *np = dev->of_node;\n\tstruct platform_device *pdev = to_platform_device(dev);\n\n\tdp->grf = syscon_regmap_lookup_by_phandle(np, \"rockchip,grf\");\n\tif (IS_ERR(dp->grf)) {\n\t\tDRM_DEV_ERROR(dev, \"cdn-dp needs rockchip,grf property\\n\");\n\t\treturn PTR_ERR(dp->grf);\n\t}\n\n\tdp->regs = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(dp->regs)) {\n\t\tDRM_DEV_ERROR(dev, \"ioremap reg failed\\n\");\n\t\treturn PTR_ERR(dp->regs);\n\t}\n\n\tdp->core_clk = devm_clk_get(dev, \"core-clk\");\n\tif (IS_ERR(dp->core_clk)) {\n\t\tDRM_DEV_ERROR(dev, \"cannot get core_clk_dp\\n\");\n\t\treturn PTR_ERR(dp->core_clk);\n\t}\n\n\tdp->pclk = devm_clk_get(dev, \"pclk\");\n\tif (IS_ERR(dp->pclk)) {\n\t\tDRM_DEV_ERROR(dev, \"cannot get pclk\\n\");\n\t\treturn PTR_ERR(dp->pclk);\n\t}\n\n\tdp->spdif_clk = devm_clk_get(dev, \"spdif\");\n\tif (IS_ERR(dp->spdif_clk)) {\n\t\tDRM_DEV_ERROR(dev, \"cannot get spdif_clk\\n\");\n\t\treturn PTR_ERR(dp->spdif_clk);\n\t}\n\n\tdp->grf_clk = devm_clk_get(dev, \"grf\");\n\tif (IS_ERR(dp->grf_clk)) {\n\t\tDRM_DEV_ERROR(dev, \"cannot get grf clk\\n\");\n\t\treturn PTR_ERR(dp->grf_clk);\n\t}\n\n\tdp->spdif_rst = devm_reset_control_get(dev, \"spdif\");\n\tif (IS_ERR(dp->spdif_rst)) {\n\t\tDRM_DEV_ERROR(dev, \"no spdif reset control found\\n\");\n\t\treturn PTR_ERR(dp->spdif_rst);\n\t}\n\n\tdp->dptx_rst = devm_reset_control_get(dev, \"dptx\");\n\tif (IS_ERR(dp->dptx_rst)) {\n\t\tDRM_DEV_ERROR(dev, \"no uphy reset control found\\n\");\n\t\treturn PTR_ERR(dp->dptx_rst);\n\t}\n\n\tdp->core_rst = devm_reset_control_get(dev, \"core\");\n\tif (IS_ERR(dp->core_rst)) {\n\t\tDRM_DEV_ERROR(dev, \"no core reset control found\\n\");\n\t\treturn PTR_ERR(dp->core_rst);\n\t}\n\n\tdp->apb_rst = devm_reset_control_get(dev, \"apb\");\n\tif (IS_ERR(dp->apb_rst)) {\n\t\tDRM_DEV_ERROR(dev, \"no apb reset control found\\n\");\n\t\treturn PTR_ERR(dp->apb_rst);\n\t}\n\n\treturn 0;\n}\n\nstatic int cdn_dp_audio_hw_params(struct device *dev,  void *data,\n\t\t\t\t  struct hdmi_codec_daifmt *daifmt,\n\t\t\t\t  struct hdmi_codec_params *params)\n{\n\tstruct cdn_dp_device *dp = dev_get_drvdata(dev);\n\tstruct audio_info audio = {\n\t\t.sample_width = params->sample_width,\n\t\t.sample_rate = params->sample_rate,\n\t\t.channels = params->channels,\n\t};\n\tint ret;\n\n\tmutex_lock(&dp->lock);\n\tif (!dp->active) {\n\t\tret = -ENODEV;\n\t\tgoto out;\n\t}\n\n\tswitch (daifmt->fmt) {\n\tcase HDMI_I2S:\n\t\taudio.format = AFMT_I2S;\n\t\tbreak;\n\tcase HDMI_SPDIF:\n\t\taudio.format = AFMT_SPDIF;\n\t\tbreak;\n\tdefault:\n\t\tDRM_DEV_ERROR(dev, \"Invalid format %d\\n\", daifmt->fmt);\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tret = cdn_dp_audio_config(dp, &audio);\n\tif (!ret)\n\t\tdp->audio_info = audio;\n\nout:\n\tmutex_unlock(&dp->lock);\n\treturn ret;\n}\n\nstatic void cdn_dp_audio_shutdown(struct device *dev, void *data)\n{\n\tstruct cdn_dp_device *dp = dev_get_drvdata(dev);\n\tint ret;\n\n\tmutex_lock(&dp->lock);\n\tif (!dp->active)\n\t\tgoto out;\n\n\tret = cdn_dp_audio_stop(dp, &dp->audio_info);\n\tif (!ret)\n\t\tdp->audio_info.format = AFMT_UNUSED;\nout:\n\tmutex_unlock(&dp->lock);\n}\n\nstatic int cdn_dp_audio_mute_stream(struct device *dev, void *data,\n\t\t\t\t    bool enable, int direction)\n{\n\tstruct cdn_dp_device *dp = dev_get_drvdata(dev);\n\tint ret;\n\n\tmutex_lock(&dp->lock);\n\tif (!dp->active) {\n\t\tret = -ENODEV;\n\t\tgoto out;\n\t}\n\n\tret = cdn_dp_audio_mute(dp, enable);\n\nout:\n\tmutex_unlock(&dp->lock);\n\treturn ret;\n}\n\nstatic int cdn_dp_audio_get_eld(struct device *dev, void *data,\n\t\t\t\tu8 *buf, size_t len)\n{\n\tstruct cdn_dp_device *dp = dev_get_drvdata(dev);\n\n\tmemcpy(buf, dp->connector.eld, min(sizeof(dp->connector.eld), len));\n\n\treturn 0;\n}\n\nstatic int cdn_dp_audio_hook_plugged_cb(struct device *dev, void *data,\n\t\t\t\t\thdmi_codec_plugged_cb fn,\n\t\t\t\t\tstruct device *codec_dev)\n{\n\tstruct cdn_dp_device *dp = dev_get_drvdata(dev);\n\n\tmutex_lock(&dp->lock);\n\tdp->plugged_cb = fn;\n\tdp->codec_dev = codec_dev;\n\tcdn_dp_audio_handle_plugged_change(dp, dp->connected);\n\tmutex_unlock(&dp->lock);\n\n\treturn 0;\n}\n\nstatic const struct hdmi_codec_ops audio_codec_ops = {\n\t.hw_params = cdn_dp_audio_hw_params,\n\t.audio_shutdown = cdn_dp_audio_shutdown,\n\t.mute_stream = cdn_dp_audio_mute_stream,\n\t.get_eld = cdn_dp_audio_get_eld,\n\t.hook_plugged_cb = cdn_dp_audio_hook_plugged_cb,\n\t.no_capture_mute = 1,\n};\n\nstatic int cdn_dp_audio_codec_init(struct cdn_dp_device *dp,\n\t\t\t\t   struct device *dev)\n{\n\tstruct hdmi_codec_pdata codec_data = {\n\t\t.i2s = 1,\n\t\t.spdif = 1,\n\t\t.ops = &audio_codec_ops,\n\t\t.max_i2s_channels = 8,\n\t};\n\n\tdp->audio_pdev = platform_device_register_data(\n\t\t\t dev, HDMI_CODEC_DRV_NAME, PLATFORM_DEVID_AUTO,\n\t\t\t &codec_data, sizeof(codec_data));\n\n\treturn PTR_ERR_OR_ZERO(dp->audio_pdev);\n}\n\nstatic int cdn_dp_request_firmware(struct cdn_dp_device *dp)\n{\n\tint ret;\n\tunsigned long timeout = jiffies + msecs_to_jiffies(CDN_FW_TIMEOUT_MS);\n\tunsigned long sleep = 1000;\n\n\tWARN_ON(!mutex_is_locked(&dp->lock));\n\n\tif (dp->fw_loaded)\n\t\treturn 0;\n\n\t \n\tmutex_unlock(&dp->lock);\n\n\twhile (time_before(jiffies, timeout)) {\n\t\tret = request_firmware(&dp->fw, CDN_DP_FIRMWARE, dp->dev);\n\t\tif (ret == -ENOENT) {\n\t\t\tmsleep(sleep);\n\t\t\tsleep *= 2;\n\t\t\tcontinue;\n\t\t} else if (ret) {\n\t\t\tDRM_DEV_ERROR(dp->dev,\n\t\t\t\t      \"failed to request firmware: %d\\n\", ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\tdp->fw_loaded = true;\n\t\tret = 0;\n\t\tgoto out;\n\t}\n\n\tDRM_DEV_ERROR(dp->dev, \"Timed out trying to load firmware\\n\");\n\tret = -ETIMEDOUT;\nout:\n\tmutex_lock(&dp->lock);\n\treturn ret;\n}\n\nstatic void cdn_dp_pd_event_work(struct work_struct *work)\n{\n\tstruct cdn_dp_device *dp = container_of(work, struct cdn_dp_device,\n\t\t\t\t\t\tevent_work);\n\tstruct drm_connector *connector = &dp->connector;\n\tenum drm_connector_status old_status;\n\n\tint ret;\n\n\tmutex_lock(&dp->lock);\n\n\tif (dp->suspended)\n\t\tgoto out;\n\n\tret = cdn_dp_request_firmware(dp);\n\tif (ret)\n\t\tgoto out;\n\n\tdp->connected = true;\n\n\t \n\tif (!cdn_dp_connected_port(dp)) {\n\t\tDRM_DEV_INFO(dp->dev, \"Not connected. Disabling cdn\\n\");\n\t\tdp->connected = false;\n\n\t \n\t} else if (!dp->active) {\n\t\tDRM_DEV_INFO(dp->dev, \"Connected, not enabled. Enabling cdn\\n\");\n\t\tret = cdn_dp_enable(dp);\n\t\tif (ret) {\n\t\t\tDRM_DEV_ERROR(dp->dev, \"Enable dp failed %d\\n\", ret);\n\t\t\tdp->connected = false;\n\t\t}\n\n\t \n\t} else if (!cdn_dp_check_sink_connection(dp)) {\n\t\tDRM_DEV_INFO(dp->dev, \"Connected without sink. Assert hpd\\n\");\n\t\tdp->connected = false;\n\n\t \n\t} else if (!cdn_dp_check_link_status(dp)) {\n\t\tunsigned int rate = dp->max_rate;\n\t\tunsigned int lanes = dp->max_lanes;\n\t\tstruct drm_display_mode *mode = &dp->mode;\n\n\t\tDRM_DEV_INFO(dp->dev, \"Connected with sink. Re-train link\\n\");\n\t\tret = cdn_dp_train_link(dp);\n\t\tif (ret) {\n\t\t\tdp->connected = false;\n\t\t\tDRM_DEV_ERROR(dp->dev, \"Train link failed %d\\n\", ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\t \n\t\tif (mode->clock &&\n\t\t    (rate != dp->max_rate || lanes != dp->max_lanes)) {\n\t\t\tret = cdn_dp_config_video(dp);\n\t\t\tif (ret) {\n\t\t\t\tdp->connected = false;\n\t\t\t\tDRM_DEV_ERROR(dp->dev,\n\t\t\t\t\t      \"Failed to config video %d\\n\",\n\t\t\t\t\t      ret);\n\t\t\t}\n\t\t}\n\t}\n\nout:\n\tmutex_unlock(&dp->lock);\n\n\told_status = connector->status;\n\tconnector->status = connector->funcs->detect(connector, false);\n\tif (old_status != connector->status)\n\t\tdrm_kms_helper_hotplug_event(dp->drm_dev);\n}\n\nstatic int cdn_dp_pd_event(struct notifier_block *nb,\n\t\t\t   unsigned long event, void *priv)\n{\n\tstruct cdn_dp_port *port = container_of(nb, struct cdn_dp_port,\n\t\t\t\t\t\tevent_nb);\n\tstruct cdn_dp_device *dp = port->dp;\n\n\t \n\tschedule_work(&dp->event_work);\n\n\treturn NOTIFY_DONE;\n}\n\nstatic int cdn_dp_bind(struct device *dev, struct device *master, void *data)\n{\n\tstruct cdn_dp_device *dp = dev_get_drvdata(dev);\n\tstruct drm_encoder *encoder;\n\tstruct drm_connector *connector;\n\tstruct cdn_dp_port *port;\n\tstruct drm_device *drm_dev = data;\n\tint ret, i;\n\n\tret = cdn_dp_parse_dt(dp);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tdp->drm_dev = drm_dev;\n\tdp->connected = false;\n\tdp->active = false;\n\tdp->active_port = -1;\n\tdp->fw_loaded = false;\n\n\tINIT_WORK(&dp->event_work, cdn_dp_pd_event_work);\n\n\tencoder = &dp->encoder.encoder;\n\n\tencoder->possible_crtcs = drm_of_find_possible_crtcs(drm_dev,\n\t\t\t\t\t\t\t     dev->of_node);\n\tDRM_DEBUG_KMS(\"possible_crtcs = 0x%x\\n\", encoder->possible_crtcs);\n\n\tret = drm_simple_encoder_init(drm_dev, encoder,\n\t\t\t\t      DRM_MODE_ENCODER_TMDS);\n\tif (ret) {\n\t\tDRM_ERROR(\"failed to initialize encoder with drm\\n\");\n\t\treturn ret;\n\t}\n\n\tdrm_encoder_helper_add(encoder, &cdn_dp_encoder_helper_funcs);\n\n\tconnector = &dp->connector;\n\tconnector->polled = DRM_CONNECTOR_POLL_HPD;\n\tconnector->dpms = DRM_MODE_DPMS_OFF;\n\n\tret = drm_connector_init(drm_dev, connector,\n\t\t\t\t &cdn_dp_atomic_connector_funcs,\n\t\t\t\t DRM_MODE_CONNECTOR_DisplayPort);\n\tif (ret) {\n\t\tDRM_ERROR(\"failed to initialize connector with drm\\n\");\n\t\tgoto err_free_encoder;\n\t}\n\n\tdrm_connector_helper_add(connector, &cdn_dp_connector_helper_funcs);\n\n\tret = drm_connector_attach_encoder(connector, encoder);\n\tif (ret) {\n\t\tDRM_ERROR(\"failed to attach connector and encoder\\n\");\n\t\tgoto err_free_connector;\n\t}\n\n\tfor (i = 0; i < dp->ports; i++) {\n\t\tport = dp->port[i];\n\n\t\tport->event_nb.notifier_call = cdn_dp_pd_event;\n\t\tret = devm_extcon_register_notifier(dp->dev, port->extcon,\n\t\t\t\t\t\t    EXTCON_DISP_DP,\n\t\t\t\t\t\t    &port->event_nb);\n\t\tif (ret) {\n\t\t\tDRM_DEV_ERROR(dev,\n\t\t\t\t      \"register EXTCON_DISP_DP notifier err\\n\");\n\t\t\tgoto err_free_connector;\n\t\t}\n\t}\n\n\tpm_runtime_enable(dev);\n\n\tschedule_work(&dp->event_work);\n\n\treturn 0;\n\nerr_free_connector:\n\tdrm_connector_cleanup(connector);\nerr_free_encoder:\n\tdrm_encoder_cleanup(encoder);\n\treturn ret;\n}\n\nstatic void cdn_dp_unbind(struct device *dev, struct device *master, void *data)\n{\n\tstruct cdn_dp_device *dp = dev_get_drvdata(dev);\n\tstruct drm_encoder *encoder = &dp->encoder.encoder;\n\tstruct drm_connector *connector = &dp->connector;\n\n\tcancel_work_sync(&dp->event_work);\n\tcdn_dp_encoder_disable(encoder);\n\tencoder->funcs->destroy(encoder);\n\tconnector->funcs->destroy(connector);\n\n\tpm_runtime_disable(dev);\n\tif (dp->fw_loaded)\n\t\trelease_firmware(dp->fw);\n\tkfree(dp->edid);\n\tdp->edid = NULL;\n}\n\nstatic const struct component_ops cdn_dp_component_ops = {\n\t.bind = cdn_dp_bind,\n\t.unbind = cdn_dp_unbind,\n};\n\nstatic int cdn_dp_suspend(struct device *dev)\n{\n\tstruct cdn_dp_device *dp = dev_get_drvdata(dev);\n\tint ret = 0;\n\n\tmutex_lock(&dp->lock);\n\tif (dp->active)\n\t\tret = cdn_dp_disable(dp);\n\tdp->suspended = true;\n\tmutex_unlock(&dp->lock);\n\n\treturn ret;\n}\n\nstatic __maybe_unused int cdn_dp_resume(struct device *dev)\n{\n\tstruct cdn_dp_device *dp = dev_get_drvdata(dev);\n\n\tmutex_lock(&dp->lock);\n\tdp->suspended = false;\n\tif (dp->fw_loaded)\n\t\tschedule_work(&dp->event_work);\n\tmutex_unlock(&dp->lock);\n\n\treturn 0;\n}\n\nstatic int cdn_dp_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tconst struct of_device_id *match;\n\tstruct cdn_dp_data *dp_data;\n\tstruct cdn_dp_port *port;\n\tstruct cdn_dp_device *dp;\n\tstruct extcon_dev *extcon;\n\tstruct phy *phy;\n\tint ret;\n\tint i;\n\n\tdp = devm_kzalloc(dev, sizeof(*dp), GFP_KERNEL);\n\tif (!dp)\n\t\treturn -ENOMEM;\n\tdp->dev = dev;\n\n\tmatch = of_match_node(cdn_dp_dt_ids, pdev->dev.of_node);\n\tdp_data = (struct cdn_dp_data *)match->data;\n\n\tfor (i = 0; i < dp_data->max_phy; i++) {\n\t\textcon = extcon_get_edev_by_phandle(dev, i);\n\t\tphy = devm_of_phy_get_by_index(dev, dev->of_node, i);\n\n\t\tif (PTR_ERR(extcon) == -EPROBE_DEFER ||\n\t\t    PTR_ERR(phy) == -EPROBE_DEFER)\n\t\t\treturn -EPROBE_DEFER;\n\n\t\tif (IS_ERR(extcon) || IS_ERR(phy))\n\t\t\tcontinue;\n\n\t\tport = devm_kzalloc(dev, sizeof(*port), GFP_KERNEL);\n\t\tif (!port)\n\t\t\treturn -ENOMEM;\n\n\t\tport->extcon = extcon;\n\t\tport->phy = phy;\n\t\tport->dp = dp;\n\t\tport->id = i;\n\t\tdp->port[dp->ports++] = port;\n\t}\n\n\tif (!dp->ports) {\n\t\tDRM_DEV_ERROR(dev, \"missing extcon or phy\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tmutex_init(&dp->lock);\n\tdev_set_drvdata(dev, dp);\n\n\tret = cdn_dp_audio_codec_init(dp, dev);\n\tif (ret)\n\t\treturn ret;\n\n\tret = component_add(dev, &cdn_dp_component_ops);\n\tif (ret)\n\t\tgoto err_audio_deinit;\n\n\treturn 0;\n\nerr_audio_deinit:\n\tplatform_device_unregister(dp->audio_pdev);\n\treturn ret;\n}\n\nstatic void cdn_dp_remove(struct platform_device *pdev)\n{\n\tstruct cdn_dp_device *dp = platform_get_drvdata(pdev);\n\n\tplatform_device_unregister(dp->audio_pdev);\n\tcdn_dp_suspend(dp->dev);\n\tcomponent_del(&pdev->dev, &cdn_dp_component_ops);\n}\n\nstatic void cdn_dp_shutdown(struct platform_device *pdev)\n{\n\tstruct cdn_dp_device *dp = platform_get_drvdata(pdev);\n\n\tcdn_dp_suspend(dp->dev);\n}\n\nstatic const struct dev_pm_ops cdn_dp_pm_ops = {\n\tSET_SYSTEM_SLEEP_PM_OPS(cdn_dp_suspend,\n\t\t\t\tcdn_dp_resume)\n};\n\nstruct platform_driver cdn_dp_driver = {\n\t.probe = cdn_dp_probe,\n\t.remove_new = cdn_dp_remove,\n\t.shutdown = cdn_dp_shutdown,\n\t.driver = {\n\t\t   .name = \"cdn-dp\",\n\t\t   .owner = THIS_MODULE,\n\t\t   .of_match_table = of_match_ptr(cdn_dp_dt_ids),\n\t\t   .pm = &cdn_dp_pm_ops,\n\t},\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}