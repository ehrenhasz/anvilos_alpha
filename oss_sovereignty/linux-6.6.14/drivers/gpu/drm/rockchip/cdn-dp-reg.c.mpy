{
  "module_name": "cdn-dp-reg.c",
  "hash_id": "1deaee22ef3fbe4ec0034a4cc0808b435f201c6a89bae1c8b2d79a7b07efc3cb",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/rockchip/cdn-dp-reg.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/device.h>\n#include <linux/delay.h>\n#include <linux/io.h>\n#include <linux/iopoll.h>\n#include <linux/reset.h>\n\n#include \"cdn-dp-core.h\"\n#include \"cdn-dp-reg.h\"\n\n#define CDN_DP_SPDIF_CLK\t\t200000000\n#define FW_ALIVE_TIMEOUT_US\t\t1000000\n#define MAILBOX_RETRY_US\t\t1000\n#define MAILBOX_TIMEOUT_US\t\t5000000\n#define LINK_TRAINING_RETRY_MS\t\t20\n#define LINK_TRAINING_TIMEOUT_MS\t500\n\nvoid cdn_dp_set_fw_clk(struct cdn_dp_device *dp, unsigned long clk)\n{\n\twritel(clk / 1000000, dp->regs + SW_CLK_H);\n}\n\nvoid cdn_dp_clock_reset(struct cdn_dp_device *dp)\n{\n\tu32 val;\n\n\tval = DPTX_FRMR_DATA_CLK_RSTN_EN |\n\t      DPTX_FRMR_DATA_CLK_EN |\n\t      DPTX_PHY_DATA_RSTN_EN |\n\t      DPTX_PHY_DATA_CLK_EN |\n\t      DPTX_PHY_CHAR_RSTN_EN |\n\t      DPTX_PHY_CHAR_CLK_EN |\n\t      SOURCE_AUX_SYS_CLK_RSTN_EN |\n\t      SOURCE_AUX_SYS_CLK_EN |\n\t      DPTX_SYS_CLK_RSTN_EN |\n\t      DPTX_SYS_CLK_EN |\n\t      CFG_DPTX_VIF_CLK_RSTN_EN |\n\t      CFG_DPTX_VIF_CLK_EN;\n\twritel(val, dp->regs + SOURCE_DPTX_CAR);\n\n\tval = SOURCE_PHY_RSTN_EN | SOURCE_PHY_CLK_EN;\n\twritel(val, dp->regs + SOURCE_PHY_CAR);\n\n\tval = SOURCE_PKT_SYS_RSTN_EN |\n\t      SOURCE_PKT_SYS_CLK_EN |\n\t      SOURCE_PKT_DATA_RSTN_EN |\n\t      SOURCE_PKT_DATA_CLK_EN;\n\twritel(val, dp->regs + SOURCE_PKT_CAR);\n\n\tval = SPDIF_CDR_CLK_RSTN_EN |\n\t      SPDIF_CDR_CLK_EN |\n\t      SOURCE_AIF_SYS_RSTN_EN |\n\t      SOURCE_AIF_SYS_CLK_EN |\n\t      SOURCE_AIF_CLK_RSTN_EN |\n\t      SOURCE_AIF_CLK_EN;\n\twritel(val, dp->regs + SOURCE_AIF_CAR);\n\n\tval = SOURCE_CIPHER_SYSTEM_CLK_RSTN_EN |\n\t      SOURCE_CIPHER_SYS_CLK_EN |\n\t      SOURCE_CIPHER_CHAR_CLK_RSTN_EN |\n\t      SOURCE_CIPHER_CHAR_CLK_EN;\n\twritel(val, dp->regs + SOURCE_CIPHER_CAR);\n\n\tval = SOURCE_CRYPTO_SYS_CLK_RSTN_EN |\n\t      SOURCE_CRYPTO_SYS_CLK_EN;\n\twritel(val, dp->regs + SOURCE_CRYPTO_CAR);\n\n\t \n\twritel(0, dp->regs + APB_INT_MASK);\n}\n\nstatic int cdn_dp_mailbox_read(struct cdn_dp_device *dp)\n{\n\tint val, ret;\n\n\tret = readx_poll_timeout(readl, dp->regs + MAILBOX_EMPTY_ADDR,\n\t\t\t\t val, !val, MAILBOX_RETRY_US,\n\t\t\t\t MAILBOX_TIMEOUT_US);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn readl(dp->regs + MAILBOX0_RD_DATA) & 0xff;\n}\n\nstatic int cdp_dp_mailbox_write(struct cdn_dp_device *dp, u8 val)\n{\n\tint ret, full;\n\n\tret = readx_poll_timeout(readl, dp->regs + MAILBOX_FULL_ADDR,\n\t\t\t\t full, !full, MAILBOX_RETRY_US,\n\t\t\t\t MAILBOX_TIMEOUT_US);\n\tif (ret < 0)\n\t\treturn ret;\n\n\twritel(val, dp->regs + MAILBOX0_WR_DATA);\n\n\treturn 0;\n}\n\nstatic int cdn_dp_mailbox_validate_receive(struct cdn_dp_device *dp,\n\t\t\t\t\t   u8 module_id, u8 opcode,\n\t\t\t\t\t   u16 req_size)\n{\n\tu32 mbox_size, i;\n\tu8 header[4];\n\tint ret;\n\n\t \n\tfor (i = 0; i < 4; i++) {\n\t\tret = cdn_dp_mailbox_read(dp);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\theader[i] = ret;\n\t}\n\n\tmbox_size = (header[2] << 8) | header[3];\n\n\tif (opcode != header[0] || module_id != header[1] ||\n\t    req_size != mbox_size) {\n\t\t \n\t\tfor (i = 0; i < mbox_size; i++)\n\t\t\tif (cdn_dp_mailbox_read(dp) < 0)\n\t\t\t\tbreak;\n\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int cdn_dp_mailbox_read_receive(struct cdn_dp_device *dp,\n\t\t\t\t       u8 *buff, u16 buff_size)\n{\n\tu32 i;\n\tint ret;\n\n\tfor (i = 0; i < buff_size; i++) {\n\t\tret = cdn_dp_mailbox_read(dp);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tbuff[i] = ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int cdn_dp_mailbox_send(struct cdn_dp_device *dp, u8 module_id,\n\t\t\t       u8 opcode, u16 size, u8 *message)\n{\n\tu8 header[4];\n\tint ret, i;\n\n\theader[0] = opcode;\n\theader[1] = module_id;\n\theader[2] = (size >> 8) & 0xff;\n\theader[3] = size & 0xff;\n\n\tfor (i = 0; i < 4; i++) {\n\t\tret = cdp_dp_mailbox_write(dp, header[i]);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tfor (i = 0; i < size; i++) {\n\t\tret = cdp_dp_mailbox_write(dp, message[i]);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int cdn_dp_reg_write(struct cdn_dp_device *dp, u16 addr, u32 val)\n{\n\tu8 msg[6];\n\n\tmsg[0] = (addr >> 8) & 0xff;\n\tmsg[1] = addr & 0xff;\n\tmsg[2] = (val >> 24) & 0xff;\n\tmsg[3] = (val >> 16) & 0xff;\n\tmsg[4] = (val >> 8) & 0xff;\n\tmsg[5] = val & 0xff;\n\treturn cdn_dp_mailbox_send(dp, MB_MODULE_ID_DP_TX, DPTX_WRITE_REGISTER,\n\t\t\t\t   sizeof(msg), msg);\n}\n\nstatic int cdn_dp_reg_write_bit(struct cdn_dp_device *dp, u16 addr,\n\t\t\t\tu8 start_bit, u8 bits_no, u32 val)\n{\n\tu8 field[8];\n\n\tfield[0] = (addr >> 8) & 0xff;\n\tfield[1] = addr & 0xff;\n\tfield[2] = start_bit;\n\tfield[3] = bits_no;\n\tfield[4] = (val >> 24) & 0xff;\n\tfield[5] = (val >> 16) & 0xff;\n\tfield[6] = (val >> 8) & 0xff;\n\tfield[7] = val & 0xff;\n\n\treturn cdn_dp_mailbox_send(dp, MB_MODULE_ID_DP_TX, DPTX_WRITE_FIELD,\n\t\t\t\t   sizeof(field), field);\n}\n\nint cdn_dp_dpcd_read(struct cdn_dp_device *dp, u32 addr, u8 *data, u16 len)\n{\n\tu8 msg[5], reg[5];\n\tint ret;\n\n\tmsg[0] = (len >> 8) & 0xff;\n\tmsg[1] = len & 0xff;\n\tmsg[2] = (addr >> 16) & 0xff;\n\tmsg[3] = (addr >> 8) & 0xff;\n\tmsg[4] = addr & 0xff;\n\tret = cdn_dp_mailbox_send(dp, MB_MODULE_ID_DP_TX, DPTX_READ_DPCD,\n\t\t\t\t  sizeof(msg), msg);\n\tif (ret)\n\t\tgoto err_dpcd_read;\n\n\tret = cdn_dp_mailbox_validate_receive(dp, MB_MODULE_ID_DP_TX,\n\t\t\t\t\t      DPTX_READ_DPCD,\n\t\t\t\t\t      sizeof(reg) + len);\n\tif (ret)\n\t\tgoto err_dpcd_read;\n\n\tret = cdn_dp_mailbox_read_receive(dp, reg, sizeof(reg));\n\tif (ret)\n\t\tgoto err_dpcd_read;\n\n\tret = cdn_dp_mailbox_read_receive(dp, data, len);\n\nerr_dpcd_read:\n\treturn ret;\n}\n\nint cdn_dp_dpcd_write(struct cdn_dp_device *dp, u32 addr, u8 value)\n{\n\tu8 msg[6], reg[5];\n\tint ret;\n\n\tmsg[0] = 0;\n\tmsg[1] = 1;\n\tmsg[2] = (addr >> 16) & 0xff;\n\tmsg[3] = (addr >> 8) & 0xff;\n\tmsg[4] = addr & 0xff;\n\tmsg[5] = value;\n\tret = cdn_dp_mailbox_send(dp, MB_MODULE_ID_DP_TX, DPTX_WRITE_DPCD,\n\t\t\t\t  sizeof(msg), msg);\n\tif (ret)\n\t\tgoto err_dpcd_write;\n\n\tret = cdn_dp_mailbox_validate_receive(dp, MB_MODULE_ID_DP_TX,\n\t\t\t\t\t      DPTX_WRITE_DPCD, sizeof(reg));\n\tif (ret)\n\t\tgoto err_dpcd_write;\n\n\tret = cdn_dp_mailbox_read_receive(dp, reg, sizeof(reg));\n\tif (ret)\n\t\tgoto err_dpcd_write;\n\n\tif (addr != (reg[2] << 16 | reg[3] << 8 | reg[4]))\n\t\tret = -EINVAL;\n\nerr_dpcd_write:\n\tif (ret)\n\t\tDRM_DEV_ERROR(dp->dev, \"dpcd write failed: %d\\n\", ret);\n\treturn ret;\n}\n\nint cdn_dp_load_firmware(struct cdn_dp_device *dp, const u32 *i_mem,\n\t\t\t u32 i_size, const u32 *d_mem, u32 d_size)\n{\n\tu32 reg;\n\tint i, ret;\n\n\t \n\twritel(APB_IRAM_PATH | APB_DRAM_PATH | APB_XT_RESET,\n\t       dp->regs + APB_CTRL);\n\n\tfor (i = 0; i < i_size; i += 4)\n\t\twritel(*i_mem++, dp->regs + ADDR_IMEM + i);\n\n\tfor (i = 0; i < d_size; i += 4)\n\t\twritel(*d_mem++, dp->regs + ADDR_DMEM + i);\n\n\t \n\twritel(0, dp->regs + APB_CTRL);\n\n\t \n\tret = readx_poll_timeout(readl, dp->regs + KEEP_ALIVE,\n\t\t\t\t reg, reg, 2000, FW_ALIVE_TIMEOUT_US);\n\tif (ret < 0) {\n\t\tDRM_DEV_ERROR(dp->dev, \"failed to loaded the FW reg = %x\\n\",\n\t\t\t      reg);\n\t\treturn -EINVAL;\n\t}\n\n\treg = readl(dp->regs + VER_L) & 0xff;\n\tdp->fw_version = reg;\n\treg = readl(dp->regs + VER_H) & 0xff;\n\tdp->fw_version |= reg << 8;\n\treg = readl(dp->regs + VER_LIB_L_ADDR) & 0xff;\n\tdp->fw_version |= reg << 16;\n\treg = readl(dp->regs + VER_LIB_H_ADDR) & 0xff;\n\tdp->fw_version |= reg << 24;\n\n\tDRM_DEV_DEBUG(dp->dev, \"firmware version: %x\\n\", dp->fw_version);\n\n\treturn 0;\n}\n\nint cdn_dp_set_firmware_active(struct cdn_dp_device *dp, bool enable)\n{\n\tu8 msg[5];\n\tint ret, i;\n\n\tmsg[0] = GENERAL_MAIN_CONTROL;\n\tmsg[1] = MB_MODULE_ID_GENERAL;\n\tmsg[2] = 0;\n\tmsg[3] = 1;\n\tmsg[4] = enable ? FW_ACTIVE : FW_STANDBY;\n\n\tfor (i = 0; i < sizeof(msg); i++) {\n\t\tret = cdp_dp_mailbox_write(dp, msg[i]);\n\t\tif (ret)\n\t\t\tgoto err_set_firmware_active;\n\t}\n\n\t \n\tfor (i = 0; i < sizeof(msg); i++)  {\n\t\tret = cdn_dp_mailbox_read(dp);\n\t\tif (ret < 0)\n\t\t\tgoto err_set_firmware_active;\n\n\t\tmsg[i] = ret;\n\t}\n\n\tret = 0;\n\nerr_set_firmware_active:\n\tif (ret < 0)\n\t\tDRM_DEV_ERROR(dp->dev, \"set firmware active failed\\n\");\n\treturn ret;\n}\n\nint cdn_dp_set_host_cap(struct cdn_dp_device *dp, u8 lanes, bool flip)\n{\n\tu8 msg[8];\n\tint ret;\n\n\tmsg[0] = CDN_DP_MAX_LINK_RATE;\n\tmsg[1] = lanes | SCRAMBLER_EN;\n\tmsg[2] = VOLTAGE_LEVEL_2;\n\tmsg[3] = PRE_EMPHASIS_LEVEL_3;\n\tmsg[4] = PTS1 | PTS2 | PTS3 | PTS4;\n\tmsg[5] = FAST_LT_NOT_SUPPORT;\n\tmsg[6] = flip ? LANE_MAPPING_FLIPPED : LANE_MAPPING_NORMAL;\n\tmsg[7] = ENHANCED;\n\n\tret = cdn_dp_mailbox_send(dp, MB_MODULE_ID_DP_TX,\n\t\t\t\t  DPTX_SET_HOST_CAPABILITIES,\n\t\t\t\t  sizeof(msg), msg);\n\tif (ret)\n\t\tgoto err_set_host_cap;\n\n\tret = cdn_dp_reg_write(dp, DP_AUX_SWAP_INVERSION_CONTROL,\n\t\t\t       AUX_HOST_INVERT);\n\nerr_set_host_cap:\n\tif (ret)\n\t\tDRM_DEV_ERROR(dp->dev, \"set host cap failed: %d\\n\", ret);\n\treturn ret;\n}\n\nint cdn_dp_event_config(struct cdn_dp_device *dp)\n{\n\tu8 msg[5];\n\tint ret;\n\n\tmemset(msg, 0, sizeof(msg));\n\n\tmsg[0] = DPTX_EVENT_ENABLE_HPD | DPTX_EVENT_ENABLE_TRAINING;\n\n\tret = cdn_dp_mailbox_send(dp, MB_MODULE_ID_DP_TX, DPTX_ENABLE_EVENT,\n\t\t\t\t  sizeof(msg), msg);\n\tif (ret)\n\t\tDRM_DEV_ERROR(dp->dev, \"set event config failed: %d\\n\", ret);\n\n\treturn ret;\n}\n\nu32 cdn_dp_get_event(struct cdn_dp_device *dp)\n{\n\treturn readl(dp->regs + SW_EVENTS0);\n}\n\nint cdn_dp_get_hpd_status(struct cdn_dp_device *dp)\n{\n\tu8 status;\n\tint ret;\n\n\tret = cdn_dp_mailbox_send(dp, MB_MODULE_ID_DP_TX, DPTX_HPD_STATE,\n\t\t\t\t  0, NULL);\n\tif (ret)\n\t\tgoto err_get_hpd;\n\n\tret = cdn_dp_mailbox_validate_receive(dp, MB_MODULE_ID_DP_TX,\n\t\t\t\t\t      DPTX_HPD_STATE, sizeof(status));\n\tif (ret)\n\t\tgoto err_get_hpd;\n\n\tret = cdn_dp_mailbox_read_receive(dp, &status, sizeof(status));\n\tif (ret)\n\t\tgoto err_get_hpd;\n\n\treturn status;\n\nerr_get_hpd:\n\tDRM_DEV_ERROR(dp->dev, \"get hpd status failed: %d\\n\", ret);\n\treturn ret;\n}\n\nint cdn_dp_get_edid_block(void *data, u8 *edid,\n\t\t\t  unsigned int block, size_t length)\n{\n\tstruct cdn_dp_device *dp = data;\n\tu8 msg[2], reg[2], i;\n\tint ret;\n\n\tfor (i = 0; i < 4; i++) {\n\t\tmsg[0] = block / 2;\n\t\tmsg[1] = block % 2;\n\n\t\tret = cdn_dp_mailbox_send(dp, MB_MODULE_ID_DP_TX, DPTX_GET_EDID,\n\t\t\t\t\t  sizeof(msg), msg);\n\t\tif (ret)\n\t\t\tcontinue;\n\n\t\tret = cdn_dp_mailbox_validate_receive(dp, MB_MODULE_ID_DP_TX,\n\t\t\t\t\t\t      DPTX_GET_EDID,\n\t\t\t\t\t\t      sizeof(reg) + length);\n\t\tif (ret)\n\t\t\tcontinue;\n\n\t\tret = cdn_dp_mailbox_read_receive(dp, reg, sizeof(reg));\n\t\tif (ret)\n\t\t\tcontinue;\n\n\t\tret = cdn_dp_mailbox_read_receive(dp, edid, length);\n\t\tif (ret)\n\t\t\tcontinue;\n\n\t\tif (reg[0] == length && reg[1] == block / 2)\n\t\t\tbreak;\n\t}\n\n\tif (ret)\n\t\tDRM_DEV_ERROR(dp->dev, \"get block[%d] edid failed: %d\\n\", block,\n\t\t\t      ret);\n\n\treturn ret;\n}\n\nstatic int cdn_dp_training_start(struct cdn_dp_device *dp)\n{\n\tunsigned long timeout;\n\tu8 msg, event[2];\n\tint ret;\n\n\tmsg = LINK_TRAINING_RUN;\n\n\t \n\tret = cdn_dp_mailbox_send(dp, MB_MODULE_ID_DP_TX, DPTX_TRAINING_CONTROL,\n\t\t\t\t  sizeof(msg), &msg);\n\tif (ret)\n\t\tgoto err_training_start;\n\n\ttimeout = jiffies + msecs_to_jiffies(LINK_TRAINING_TIMEOUT_MS);\n\twhile (time_before(jiffies, timeout)) {\n\t\tmsleep(LINK_TRAINING_RETRY_MS);\n\t\tret = cdn_dp_mailbox_send(dp, MB_MODULE_ID_DP_TX,\n\t\t\t\t\t  DPTX_READ_EVENT, 0, NULL);\n\t\tif (ret)\n\t\t\tgoto err_training_start;\n\n\t\tret = cdn_dp_mailbox_validate_receive(dp, MB_MODULE_ID_DP_TX,\n\t\t\t\t\t\t      DPTX_READ_EVENT,\n\t\t\t\t\t\t      sizeof(event));\n\t\tif (ret)\n\t\t\tgoto err_training_start;\n\n\t\tret = cdn_dp_mailbox_read_receive(dp, event, sizeof(event));\n\t\tif (ret)\n\t\t\tgoto err_training_start;\n\n\t\tif (event[1] & EQ_PHASE_FINISHED)\n\t\t\treturn 0;\n\t}\n\n\tret = -ETIMEDOUT;\n\nerr_training_start:\n\tDRM_DEV_ERROR(dp->dev, \"training failed: %d\\n\", ret);\n\treturn ret;\n}\n\nstatic int cdn_dp_get_training_status(struct cdn_dp_device *dp)\n{\n\tu8 status[10];\n\tint ret;\n\n\tret = cdn_dp_mailbox_send(dp, MB_MODULE_ID_DP_TX, DPTX_READ_LINK_STAT,\n\t\t\t\t  0, NULL);\n\tif (ret)\n\t\tgoto err_get_training_status;\n\n\tret = cdn_dp_mailbox_validate_receive(dp, MB_MODULE_ID_DP_TX,\n\t\t\t\t\t      DPTX_READ_LINK_STAT,\n\t\t\t\t\t      sizeof(status));\n\tif (ret)\n\t\tgoto err_get_training_status;\n\n\tret = cdn_dp_mailbox_read_receive(dp, status, sizeof(status));\n\tif (ret)\n\t\tgoto err_get_training_status;\n\n\tdp->max_rate = drm_dp_bw_code_to_link_rate(status[0]);\n\tdp->max_lanes = status[1];\n\nerr_get_training_status:\n\tif (ret)\n\t\tDRM_DEV_ERROR(dp->dev, \"get training status failed: %d\\n\", ret);\n\treturn ret;\n}\n\nint cdn_dp_train_link(struct cdn_dp_device *dp)\n{\n\tint ret;\n\n\tret = cdn_dp_training_start(dp);\n\tif (ret) {\n\t\tDRM_DEV_ERROR(dp->dev, \"Failed to start training %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = cdn_dp_get_training_status(dp);\n\tif (ret) {\n\t\tDRM_DEV_ERROR(dp->dev, \"Failed to get training stat %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tDRM_DEV_DEBUG_KMS(dp->dev, \"rate:0x%x, lanes:%d\\n\", dp->max_rate,\n\t\t\t  dp->max_lanes);\n\treturn ret;\n}\n\nint cdn_dp_set_video_status(struct cdn_dp_device *dp, int active)\n{\n\tu8 msg;\n\tint ret;\n\n\tmsg = !!active;\n\n\tret = cdn_dp_mailbox_send(dp, MB_MODULE_ID_DP_TX, DPTX_SET_VIDEO,\n\t\t\t\t  sizeof(msg), &msg);\n\tif (ret)\n\t\tDRM_DEV_ERROR(dp->dev, \"set video status failed: %d\\n\", ret);\n\n\treturn ret;\n}\n\nstatic int cdn_dp_get_msa_misc(struct video_info *video,\n\t\t\t       struct drm_display_mode *mode)\n{\n\tu32 msa_misc;\n\tu8 val[2] = {0};\n\n\tswitch (video->color_fmt) {\n\tcase PXL_RGB:\n\tcase Y_ONLY:\n\t\tval[0] = 0;\n\t\tbreak;\n\t \n\tcase YCBCR_4_4_4:\n\t\tval[0] = 6 + BT_601 * 8;\n\t\tbreak;\n\tcase YCBCR_4_2_2:\n\t\tval[0] = 5 + BT_601 * 8;\n\t\tbreak;\n\tcase YCBCR_4_2_0:\n\t\tval[0] = 5;\n\t\tbreak;\n\t}\n\n\tswitch (video->color_depth) {\n\tcase 6:\n\t\tval[1] = 0;\n\t\tbreak;\n\tcase 8:\n\t\tval[1] = 1;\n\t\tbreak;\n\tcase 10:\n\t\tval[1] = 2;\n\t\tbreak;\n\tcase 12:\n\t\tval[1] = 3;\n\t\tbreak;\n\tcase 16:\n\t\tval[1] = 4;\n\t\tbreak;\n\t}\n\n\tmsa_misc = 2 * val[0] + 32 * val[1] +\n\t\t   ((video->color_fmt == Y_ONLY) ? (1 << 14) : 0);\n\n\treturn msa_misc;\n}\n\nint cdn_dp_config_video(struct cdn_dp_device *dp)\n{\n\tstruct video_info *video = &dp->video_info;\n\tstruct drm_display_mode *mode = &dp->mode;\n\tu64 symbol;\n\tu32 val, link_rate, rem;\n\tu8 bit_per_pix, tu_size_reg = TU_SIZE;\n\tint ret;\n\n\tbit_per_pix = (video->color_fmt == YCBCR_4_2_2) ?\n\t\t      (video->color_depth * 2) : (video->color_depth * 3);\n\n\tlink_rate = dp->max_rate / 1000;\n\n\tret = cdn_dp_reg_write(dp, BND_HSYNC2VSYNC, VIF_BYPASS_INTERLACE);\n\tif (ret)\n\t\tgoto err_config_video;\n\n\tret = cdn_dp_reg_write(dp, HSYNC2VSYNC_POL_CTRL, 0);\n\tif (ret)\n\t\tgoto err_config_video;\n\n\t \n\tdo {\n\t\ttu_size_reg += 2;\n\t\tsymbol = (u64)tu_size_reg * mode->clock * bit_per_pix;\n\t\tdo_div(symbol, dp->max_lanes * link_rate * 8);\n\t\trem = do_div(symbol, 1000);\n\t\tif (tu_size_reg > 64) {\n\t\t\tret = -EINVAL;\n\t\t\tDRM_DEV_ERROR(dp->dev,\n\t\t\t\t      \"tu error, clk:%d, lanes:%d, rate:%d\\n\",\n\t\t\t\t      mode->clock, dp->max_lanes, link_rate);\n\t\t\tgoto err_config_video;\n\t\t}\n\t} while ((symbol <= 1) || (tu_size_reg - symbol < 4) ||\n\t\t (rem > 850) || (rem < 100));\n\n\tval = symbol + (tu_size_reg << 8);\n\tval |= TU_CNT_RST_EN;\n\tret = cdn_dp_reg_write(dp, DP_FRAMER_TU, val);\n\tif (ret)\n\t\tgoto err_config_video;\n\n\t \n\tval = div_u64(mode->clock * (symbol + 1), 1000) + link_rate;\n\tval /= (dp->max_lanes * link_rate);\n\tval = div_u64(8 * (symbol + 1), bit_per_pix) - val;\n\tval += 2;\n\tret = cdn_dp_reg_write(dp, DP_VC_TABLE(15), val);\n\n\tswitch (video->color_depth) {\n\tcase 6:\n\t\tval = BCS_6;\n\t\tbreak;\n\tcase 8:\n\t\tval = BCS_8;\n\t\tbreak;\n\tcase 10:\n\t\tval = BCS_10;\n\t\tbreak;\n\tcase 12:\n\t\tval = BCS_12;\n\t\tbreak;\n\tcase 16:\n\t\tval = BCS_16;\n\t\tbreak;\n\t}\n\n\tval += video->color_fmt << 8;\n\tret = cdn_dp_reg_write(dp, DP_FRAMER_PXL_REPR, val);\n\tif (ret)\n\t\tgoto err_config_video;\n\n\tval = video->h_sync_polarity ? DP_FRAMER_SP_HSP : 0;\n\tval |= video->v_sync_polarity ? DP_FRAMER_SP_VSP : 0;\n\tret = cdn_dp_reg_write(dp, DP_FRAMER_SP, val);\n\tif (ret)\n\t\tgoto err_config_video;\n\n\tval = (mode->hsync_start - mode->hdisplay) << 16;\n\tval |= mode->htotal - mode->hsync_end;\n\tret = cdn_dp_reg_write(dp, DP_FRONT_BACK_PORCH, val);\n\tif (ret)\n\t\tgoto err_config_video;\n\n\tval = mode->hdisplay * bit_per_pix / 8;\n\tret = cdn_dp_reg_write(dp, DP_BYTE_COUNT, val);\n\tif (ret)\n\t\tgoto err_config_video;\n\n\tval = mode->htotal | ((mode->htotal - mode->hsync_start) << 16);\n\tret = cdn_dp_reg_write(dp, MSA_HORIZONTAL_0, val);\n\tif (ret)\n\t\tgoto err_config_video;\n\n\tval = mode->hsync_end - mode->hsync_start;\n\tval |= (mode->hdisplay << 16) | (video->h_sync_polarity << 15);\n\tret = cdn_dp_reg_write(dp, MSA_HORIZONTAL_1, val);\n\tif (ret)\n\t\tgoto err_config_video;\n\n\tval = mode->vtotal;\n\tval |= (mode->vtotal - mode->vsync_start) << 16;\n\tret = cdn_dp_reg_write(dp, MSA_VERTICAL_0, val);\n\tif (ret)\n\t\tgoto err_config_video;\n\n\tval = mode->vsync_end - mode->vsync_start;\n\tval |= (mode->vdisplay << 16) | (video->v_sync_polarity << 15);\n\tret = cdn_dp_reg_write(dp, MSA_VERTICAL_1, val);\n\tif (ret)\n\t\tgoto err_config_video;\n\n\tval = cdn_dp_get_msa_misc(video, mode);\n\tret = cdn_dp_reg_write(dp, MSA_MISC, val);\n\tif (ret)\n\t\tgoto err_config_video;\n\n\tret = cdn_dp_reg_write(dp, STREAM_CONFIG, 1);\n\tif (ret)\n\t\tgoto err_config_video;\n\n\tval = mode->hsync_end - mode->hsync_start;\n\tval |= mode->hdisplay << 16;\n\tret = cdn_dp_reg_write(dp, DP_HORIZONTAL, val);\n\tif (ret)\n\t\tgoto err_config_video;\n\n\tval = mode->vdisplay;\n\tval |= (mode->vtotal - mode->vsync_start) << 16;\n\tret = cdn_dp_reg_write(dp, DP_VERTICAL_0, val);\n\tif (ret)\n\t\tgoto err_config_video;\n\n\tval = mode->vtotal;\n\tret = cdn_dp_reg_write(dp, DP_VERTICAL_1, val);\n\tif (ret)\n\t\tgoto err_config_video;\n\n\tret = cdn_dp_reg_write_bit(dp, DP_VB_ID, 2, 1, 0);\n\nerr_config_video:\n\tif (ret)\n\t\tDRM_DEV_ERROR(dp->dev, \"config video failed: %d\\n\", ret);\n\treturn ret;\n}\n\nint cdn_dp_audio_stop(struct cdn_dp_device *dp, struct audio_info *audio)\n{\n\tint ret;\n\n\tret = cdn_dp_reg_write(dp, AUDIO_PACK_CONTROL, 0);\n\tif (ret) {\n\t\tDRM_DEV_ERROR(dp->dev, \"audio stop failed: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\twritel(0, dp->regs + SPDIF_CTRL_ADDR);\n\n\t \n\twritel(0, dp->regs + AUDIO_SRC_CNTL);\n\twritel(0, dp->regs + AUDIO_SRC_CNFG);\n\twritel(AUDIO_SW_RST, dp->regs + AUDIO_SRC_CNTL);\n\twritel(0, dp->regs + AUDIO_SRC_CNTL);\n\n\t \n\twritel(0, dp->regs + SMPL2PKT_CNTL);\n\twritel(AUDIO_SW_RST, dp->regs + SMPL2PKT_CNTL);\n\twritel(0, dp->regs + SMPL2PKT_CNTL);\n\n\t \n\twritel(AUDIO_SW_RST, dp->regs + FIFO_CNTL);\n\twritel(0, dp->regs + FIFO_CNTL);\n\n\tif (audio->format == AFMT_SPDIF)\n\t\tclk_disable_unprepare(dp->spdif_clk);\n\n\treturn 0;\n}\n\nint cdn_dp_audio_mute(struct cdn_dp_device *dp, bool enable)\n{\n\tint ret;\n\n\tret = cdn_dp_reg_write_bit(dp, DP_VB_ID, 4, 1, enable);\n\tif (ret)\n\t\tDRM_DEV_ERROR(dp->dev, \"audio mute failed: %d\\n\", ret);\n\n\treturn ret;\n}\n\nstatic void cdn_dp_audio_config_i2s(struct cdn_dp_device *dp,\n\t\t\t\t    struct audio_info *audio)\n{\n\tint sub_pckt_num = 1, i2s_port_en_val = 0xf, i;\n\tu32 val;\n\n\tif (audio->channels == 2) {\n\t\tif (dp->max_lanes == 1)\n\t\t\tsub_pckt_num = 2;\n\t\telse\n\t\t\tsub_pckt_num = 4;\n\n\t\ti2s_port_en_val = 1;\n\t} else if (audio->channels == 4) {\n\t\ti2s_port_en_val = 3;\n\t}\n\n\twritel(0x0, dp->regs + SPDIF_CTRL_ADDR);\n\n\twritel(SYNC_WR_TO_CH_ZERO, dp->regs + FIFO_CNTL);\n\n\tval = MAX_NUM_CH(audio->channels);\n\tval |= NUM_OF_I2S_PORTS(audio->channels);\n\tval |= AUDIO_TYPE_LPCM;\n\tval |= CFG_SUB_PCKT_NUM(sub_pckt_num);\n\twritel(val, dp->regs + SMPL2PKT_CNFG);\n\n\tif (audio->sample_width == 16)\n\t\tval = 0;\n\telse if (audio->sample_width == 24)\n\t\tval = 1 << 9;\n\telse\n\t\tval = 2 << 9;\n\n\tval |= AUDIO_CH_NUM(audio->channels);\n\tval |= I2S_DEC_PORT_EN(i2s_port_en_val);\n\tval |= TRANS_SMPL_WIDTH_32;\n\twritel(val, dp->regs + AUDIO_SRC_CNFG);\n\n\tfor (i = 0; i < (audio->channels + 1) / 2; i++) {\n\t\tif (audio->sample_width == 16)\n\t\t\tval = (0x02 << 8) | (0x02 << 20);\n\t\telse if (audio->sample_width == 24)\n\t\t\tval = (0x0b << 8) | (0x0b << 20);\n\n\t\tval |= ((2 * i) << 4) | ((2 * i + 1) << 16);\n\t\twritel(val, dp->regs + STTS_BIT_CH(i));\n\t}\n\n\tswitch (audio->sample_rate) {\n\tcase 32000:\n\t\tval = SAMPLING_FREQ(3) |\n\t\t      ORIGINAL_SAMP_FREQ(0xc);\n\t\tbreak;\n\tcase 44100:\n\t\tval = SAMPLING_FREQ(0) |\n\t\t      ORIGINAL_SAMP_FREQ(0xf);\n\t\tbreak;\n\tcase 48000:\n\t\tval = SAMPLING_FREQ(2) |\n\t\t      ORIGINAL_SAMP_FREQ(0xd);\n\t\tbreak;\n\tcase 88200:\n\t\tval = SAMPLING_FREQ(8) |\n\t\t      ORIGINAL_SAMP_FREQ(0x7);\n\t\tbreak;\n\tcase 96000:\n\t\tval = SAMPLING_FREQ(0xa) |\n\t\t      ORIGINAL_SAMP_FREQ(5);\n\t\tbreak;\n\tcase 176400:\n\t\tval = SAMPLING_FREQ(0xc) |\n\t\t      ORIGINAL_SAMP_FREQ(3);\n\t\tbreak;\n\tcase 192000:\n\t\tval = SAMPLING_FREQ(0xe) |\n\t\t      ORIGINAL_SAMP_FREQ(1);\n\t\tbreak;\n\t}\n\tval |= 4;\n\twritel(val, dp->regs + COM_CH_STTS_BITS);\n\n\twritel(SMPL2PKT_EN, dp->regs + SMPL2PKT_CNTL);\n\twritel(I2S_DEC_START, dp->regs + AUDIO_SRC_CNTL);\n}\n\nstatic void cdn_dp_audio_config_spdif(struct cdn_dp_device *dp)\n{\n\tu32 val;\n\n\twritel(SYNC_WR_TO_CH_ZERO, dp->regs + FIFO_CNTL);\n\n\tval = MAX_NUM_CH(2) | AUDIO_TYPE_LPCM | CFG_SUB_PCKT_NUM(4);\n\twritel(val, dp->regs + SMPL2PKT_CNFG);\n\twritel(SMPL2PKT_EN, dp->regs + SMPL2PKT_CNTL);\n\n\tval = SPDIF_ENABLE | SPDIF_AVG_SEL | SPDIF_JITTER_BYPASS;\n\twritel(val, dp->regs + SPDIF_CTRL_ADDR);\n\n\tclk_prepare_enable(dp->spdif_clk);\n\tclk_set_rate(dp->spdif_clk, CDN_DP_SPDIF_CLK);\n}\n\nint cdn_dp_audio_config(struct cdn_dp_device *dp, struct audio_info *audio)\n{\n\tint ret;\n\n\t \n\tif (audio->format == AFMT_SPDIF) {\n\t\treset_control_assert(dp->spdif_rst);\n\t\treset_control_deassert(dp->spdif_rst);\n\t}\n\n\tret = cdn_dp_reg_write(dp, CM_LANE_CTRL, LANE_REF_CYC);\n\tif (ret)\n\t\tgoto err_audio_config;\n\n\tret = cdn_dp_reg_write(dp, CM_CTRL, 0);\n\tif (ret)\n\t\tgoto err_audio_config;\n\n\tif (audio->format == AFMT_I2S)\n\t\tcdn_dp_audio_config_i2s(dp, audio);\n\telse if (audio->format == AFMT_SPDIF)\n\t\tcdn_dp_audio_config_spdif(dp);\n\n\tret = cdn_dp_reg_write(dp, AUDIO_PACK_CONTROL, AUDIO_PACK_EN);\n\nerr_audio_config:\n\tif (ret)\n\t\tDRM_DEV_ERROR(dp->dev, \"audio config failed: %d\\n\", ret);\n\treturn ret;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}