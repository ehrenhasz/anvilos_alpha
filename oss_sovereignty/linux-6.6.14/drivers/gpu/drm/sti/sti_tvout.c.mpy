{
  "module_name": "sti_tvout.c",
  "hash_id": "58c338ff1de022a6eac371b5acfe634e5550f5262f62e016211b7c66c89dd01b",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/sti/sti_tvout.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/component.h>\n#include <linux/io.h>\n#include <linux/module.h>\n#include <linux/of_platform.h>\n#include <linux/platform_device.h>\n#include <linux/reset.h>\n#include <linux/seq_file.h>\n\n#include <drm/drm_atomic_helper.h>\n#include <drm/drm_debugfs.h>\n#include <drm/drm_device.h>\n#include <drm/drm_file.h>\n#include <drm/drm_print.h>\n\n#include \"sti_crtc.h\"\n#include \"sti_drv.h\"\n#include \"sti_vtg.h\"\n\n \n#define TVO_CSC_MAIN_M0                  0x000\n#define TVO_CSC_MAIN_M1                  0x004\n#define TVO_CSC_MAIN_M2                  0x008\n#define TVO_CSC_MAIN_M3                  0x00c\n#define TVO_CSC_MAIN_M4                  0x010\n#define TVO_CSC_MAIN_M5                  0x014\n#define TVO_CSC_MAIN_M6                  0x018\n#define TVO_CSC_MAIN_M7                  0x01c\n#define TVO_MAIN_IN_VID_FORMAT           0x030\n#define TVO_CSC_AUX_M0                   0x100\n#define TVO_CSC_AUX_M1                   0x104\n#define TVO_CSC_AUX_M2                   0x108\n#define TVO_CSC_AUX_M3                   0x10c\n#define TVO_CSC_AUX_M4                   0x110\n#define TVO_CSC_AUX_M5                   0x114\n#define TVO_CSC_AUX_M6                   0x118\n#define TVO_CSC_AUX_M7                   0x11c\n#define TVO_AUX_IN_VID_FORMAT            0x130\n#define TVO_VIP_HDF                      0x400\n#define TVO_HD_SYNC_SEL                  0x418\n#define TVO_HD_DAC_CFG_OFF               0x420\n#define TVO_VIP_HDMI                     0x500\n#define TVO_HDMI_FORCE_COLOR_0           0x504\n#define TVO_HDMI_FORCE_COLOR_1           0x508\n#define TVO_HDMI_CLIP_VALUE_B_CB         0x50c\n#define TVO_HDMI_CLIP_VALUE_Y_G          0x510\n#define TVO_HDMI_CLIP_VALUE_R_CR         0x514\n#define TVO_HDMI_SYNC_SEL                0x518\n#define TVO_HDMI_DFV_OBS                 0x540\n#define TVO_VIP_DVO                      0x600\n#define TVO_DVO_SYNC_SEL                 0x618\n#define TVO_DVO_CONFIG                   0x620\n\n#define TVO_IN_FMT_SIGNED                BIT(0)\n#define TVO_SYNC_EXT                     BIT(4)\n\n#define TVO_VIP_REORDER_R_SHIFT          24\n#define TVO_VIP_REORDER_G_SHIFT          20\n#define TVO_VIP_REORDER_B_SHIFT          16\n#define TVO_VIP_REORDER_MASK             0x3\n#define TVO_VIP_REORDER_Y_G_SEL          0\n#define TVO_VIP_REORDER_CB_B_SEL         1\n#define TVO_VIP_REORDER_CR_R_SEL         2\n\n#define TVO_VIP_CLIP_SHIFT               8\n#define TVO_VIP_CLIP_MASK                0x7\n#define TVO_VIP_CLIP_DISABLED            0\n#define TVO_VIP_CLIP_EAV_SAV             1\n#define TVO_VIP_CLIP_LIMITED_RANGE_RGB_Y 2\n#define TVO_VIP_CLIP_LIMITED_RANGE_CB_CR 3\n#define TVO_VIP_CLIP_PROG_RANGE          4\n\n#define TVO_VIP_RND_SHIFT                4\n#define TVO_VIP_RND_MASK                 0x3\n#define TVO_VIP_RND_8BIT_ROUNDED         0\n#define TVO_VIP_RND_10BIT_ROUNDED        1\n#define TVO_VIP_RND_12BIT_ROUNDED        2\n\n#define TVO_VIP_SEL_INPUT_MASK           0xf\n#define TVO_VIP_SEL_INPUT_MAIN           0x0\n#define TVO_VIP_SEL_INPUT_AUX            0x8\n#define TVO_VIP_SEL_INPUT_FORCE_COLOR    0xf\n#define TVO_VIP_SEL_INPUT_BYPASS_MASK    0x1\n#define TVO_VIP_SEL_INPUT_BYPASSED       1\n\n#define TVO_SYNC_MAIN_VTG_SET_REF        0x00\n#define TVO_SYNC_AUX_VTG_SET_REF         0x10\n\n#define TVO_SYNC_HD_DCS_SHIFT            8\n\n#define TVO_SYNC_DVO_PAD_HSYNC_SHIFT     8\n#define TVO_SYNC_DVO_PAD_VSYNC_SHIFT     16\n\n#define ENCODER_CRTC_MASK                (BIT(0) | BIT(1))\n\n#define TVO_MIN_HD_HEIGHT                720\n\n \nenum sti_tvout_video_out_type {\n\tSTI_TVOUT_VIDEO_OUT_RGB,\n\tSTI_TVOUT_VIDEO_OUT_YUV,\n};\n\nstruct sti_tvout {\n\tstruct device *dev;\n\tstruct drm_device *drm_dev;\n\tvoid __iomem *regs;\n\tstruct reset_control *reset;\n\tstruct drm_encoder *hdmi;\n\tstruct drm_encoder *hda;\n\tstruct drm_encoder *dvo;\n\tbool debugfs_registered;\n};\n\nstruct sti_tvout_encoder {\n\tstruct drm_encoder encoder;\n\tstruct sti_tvout *tvout;\n};\n\n#define to_sti_tvout_encoder(x) \\\n\tcontainer_of(x, struct sti_tvout_encoder, encoder)\n\n#define to_sti_tvout(x) to_sti_tvout_encoder(x)->tvout\n\n \nstatic const u32 rgb_to_ycbcr_601[8] = {\n\t0xF927082E, 0x04C9FEAB, 0x01D30964, 0xFA95FD3D,\n\t0x0000082E, 0x00002000, 0x00002000, 0x00000000\n};\n\n \nstatic const u32 rgb_to_ycbcr_709[8] = {\n\t0xF891082F, 0x0367FF40, 0x01280B71, 0xF9B1FE20,\n\t0x0000082F, 0x00002000, 0x00002000, 0x00000000\n};\n\nstatic u32 tvout_read(struct sti_tvout *tvout, int offset)\n{\n\treturn readl(tvout->regs + offset);\n}\n\nstatic void tvout_write(struct sti_tvout *tvout, u32 val, int offset)\n{\n\twritel(val, tvout->regs + offset);\n}\n\n \nstatic void tvout_vip_set_color_order(struct sti_tvout *tvout, int reg,\n\t\t\t\t      u32 cr_r, u32 y_g, u32 cb_b)\n{\n\tu32 val = tvout_read(tvout, reg);\n\n\tval &= ~(TVO_VIP_REORDER_MASK << TVO_VIP_REORDER_R_SHIFT);\n\tval &= ~(TVO_VIP_REORDER_MASK << TVO_VIP_REORDER_G_SHIFT);\n\tval &= ~(TVO_VIP_REORDER_MASK << TVO_VIP_REORDER_B_SHIFT);\n\tval |= cr_r << TVO_VIP_REORDER_R_SHIFT;\n\tval |= y_g << TVO_VIP_REORDER_G_SHIFT;\n\tval |= cb_b << TVO_VIP_REORDER_B_SHIFT;\n\n\ttvout_write(tvout, val, reg);\n}\n\n \nstatic void tvout_vip_set_clip_mode(struct sti_tvout *tvout, int reg, u32 range)\n{\n\tu32 val = tvout_read(tvout, reg);\n\n\tval &= ~(TVO_VIP_CLIP_MASK << TVO_VIP_CLIP_SHIFT);\n\tval |= range << TVO_VIP_CLIP_SHIFT;\n\ttvout_write(tvout, val, reg);\n}\n\n \nstatic void tvout_vip_set_rnd(struct sti_tvout *tvout, int reg, u32 rnd)\n{\n\tu32 val = tvout_read(tvout, reg);\n\n\tval &= ~(TVO_VIP_RND_MASK << TVO_VIP_RND_SHIFT);\n\tval |= rnd << TVO_VIP_RND_SHIFT;\n\ttvout_write(tvout, val, reg);\n}\n\n \nstatic void tvout_vip_set_sel_input(struct sti_tvout *tvout,\n\t\t\t\t    int reg,\n\t\t\t\t    bool main_path,\n\t\t\t\t    enum sti_tvout_video_out_type video_out)\n{\n\tu32 sel_input;\n\tu32 val = tvout_read(tvout, reg);\n\n\tif (main_path)\n\t\tsel_input = TVO_VIP_SEL_INPUT_MAIN;\n\telse\n\t\tsel_input = TVO_VIP_SEL_INPUT_AUX;\n\n\tswitch (video_out) {\n\tcase STI_TVOUT_VIDEO_OUT_RGB:\n\t\tsel_input |= TVO_VIP_SEL_INPUT_BYPASSED;\n\t\tbreak;\n\tcase STI_TVOUT_VIDEO_OUT_YUV:\n\t\tsel_input &= ~TVO_VIP_SEL_INPUT_BYPASSED;\n\t\tbreak;\n\t}\n\n\t \n\tsel_input = sel_input ^ TVO_VIP_SEL_INPUT_BYPASS_MASK;\n\n\tval &= ~TVO_VIP_SEL_INPUT_MASK;\n\tval |= sel_input;\n\ttvout_write(tvout, val, reg);\n}\n\n \nstatic void tvout_vip_set_in_vid_fmt(struct sti_tvout *tvout,\n\t\tint reg, u32 in_vid_fmt)\n{\n\tu32 val = tvout_read(tvout, reg);\n\n\tval &= ~TVO_IN_FMT_SIGNED;\n\tval |= in_vid_fmt;\n\ttvout_write(tvout, val, reg);\n}\n\n \nstatic void tvout_preformatter_set_matrix(struct sti_tvout *tvout,\n\t\t\t\t\t  struct drm_display_mode *mode)\n{\n\tunsigned int i;\n\tconst u32 *pf_matrix;\n\n\tif (mode->vdisplay >= TVO_MIN_HD_HEIGHT)\n\t\tpf_matrix = rgb_to_ycbcr_709;\n\telse\n\t\tpf_matrix = rgb_to_ycbcr_601;\n\n\tfor (i = 0; i < 8; i++) {\n\t\ttvout_write(tvout, *(pf_matrix + i),\n\t\t\t    TVO_CSC_MAIN_M0 + (i * 4));\n\t\ttvout_write(tvout, *(pf_matrix + i),\n\t\t\t    TVO_CSC_AUX_M0 + (i * 4));\n\t}\n}\n\n \nstatic void tvout_dvo_start(struct sti_tvout *tvout, bool main_path)\n{\n\tu32 tvo_in_vid_format;\n\tint val, tmp;\n\n\tdev_dbg(tvout->dev, \"%s\\n\", __func__);\n\n\tif (main_path) {\n\t\tDRM_DEBUG_DRIVER(\"main vip for DVO\\n\");\n\t\t \n\t\ttmp = TVO_SYNC_MAIN_VTG_SET_REF | VTG_SYNC_ID_DVO;\n\t\tval  = tmp << TVO_SYNC_DVO_PAD_VSYNC_SHIFT;\n\t\tval |= tmp << TVO_SYNC_DVO_PAD_HSYNC_SHIFT;\n\t\tval |= tmp;\n\t\ttvout_write(tvout, val, TVO_DVO_SYNC_SEL);\n\t\ttvo_in_vid_format = TVO_MAIN_IN_VID_FORMAT;\n\t} else {\n\t\tDRM_DEBUG_DRIVER(\"aux vip for DVO\\n\");\n\t\t \n\t\ttmp = TVO_SYNC_AUX_VTG_SET_REF | VTG_SYNC_ID_DVO;\n\t\tval  = tmp << TVO_SYNC_DVO_PAD_VSYNC_SHIFT;\n\t\tval |= tmp << TVO_SYNC_DVO_PAD_HSYNC_SHIFT;\n\t\tval |= tmp;\n\t\ttvout_write(tvout, val, TVO_DVO_SYNC_SEL);\n\t\ttvo_in_vid_format = TVO_AUX_IN_VID_FORMAT;\n\t}\n\n\t \n\ttvout_vip_set_color_order(tvout, TVO_VIP_DVO,\n\t\t\t\t  TVO_VIP_REORDER_CR_R_SEL,\n\t\t\t\t  TVO_VIP_REORDER_Y_G_SEL,\n\t\t\t\t  TVO_VIP_REORDER_CB_B_SEL);\n\n\t \n\ttvout_vip_set_clip_mode(tvout, TVO_VIP_DVO, TVO_VIP_CLIP_DISABLED);\n\n\t \n\ttvout_vip_set_rnd(tvout, TVO_VIP_DVO, TVO_VIP_RND_8BIT_ROUNDED);\n\n\t \n\ttvout_vip_set_in_vid_fmt(tvout, tvo_in_vid_format, TVO_IN_FMT_SIGNED);\n\n\t \n\ttvout_vip_set_sel_input(tvout, TVO_VIP_DVO, main_path,\n\t\t\t\tSTI_TVOUT_VIDEO_OUT_RGB);\n}\n\n \nstatic void tvout_hdmi_start(struct sti_tvout *tvout, bool main_path)\n{\n\tu32 tvo_in_vid_format;\n\n\tdev_dbg(tvout->dev, \"%s\\n\", __func__);\n\n\tif (main_path) {\n\t\tDRM_DEBUG_DRIVER(\"main vip for hdmi\\n\");\n\t\t \n\t\ttvout_write(tvout,\n\t\t\t    TVO_SYNC_MAIN_VTG_SET_REF | VTG_SYNC_ID_HDMI,\n\t\t\t    TVO_HDMI_SYNC_SEL);\n\t\ttvo_in_vid_format = TVO_MAIN_IN_VID_FORMAT;\n\t} else {\n\t\tDRM_DEBUG_DRIVER(\"aux vip for hdmi\\n\");\n\t\t \n\t\ttvout_write(tvout,\n\t\t\t    TVO_SYNC_AUX_VTG_SET_REF | VTG_SYNC_ID_HDMI,\n\t\t\t    TVO_HDMI_SYNC_SEL);\n\t\ttvo_in_vid_format = TVO_AUX_IN_VID_FORMAT;\n\t}\n\n\t \n\ttvout_vip_set_color_order(tvout, TVO_VIP_HDMI,\n\t\t\t\t  TVO_VIP_REORDER_CR_R_SEL,\n\t\t\t\t  TVO_VIP_REORDER_Y_G_SEL,\n\t\t\t\t  TVO_VIP_REORDER_CB_B_SEL);\n\n\t \n\ttvout_vip_set_clip_mode(tvout, TVO_VIP_HDMI, TVO_VIP_CLIP_DISABLED);\n\n\t \n\ttvout_vip_set_rnd(tvout, TVO_VIP_HDMI, TVO_VIP_RND_8BIT_ROUNDED);\n\n\t \n\ttvout_vip_set_in_vid_fmt(tvout, tvo_in_vid_format, TVO_IN_FMT_SIGNED);\n\n\t \n\ttvout_vip_set_sel_input(tvout, TVO_VIP_HDMI, main_path,\n\t\t\t\tSTI_TVOUT_VIDEO_OUT_RGB);\n}\n\n \nstatic void tvout_hda_start(struct sti_tvout *tvout, bool main_path)\n{\n\tu32 tvo_in_vid_format;\n\tint val;\n\n\tdev_dbg(tvout->dev, \"%s\\n\", __func__);\n\n\tif (main_path) {\n\t\tDRM_DEBUG_DRIVER(\"main vip for HDF\\n\");\n\t\t \n\t\tval  = TVO_SYNC_MAIN_VTG_SET_REF | VTG_SYNC_ID_HDDCS;\n\t\tval  = val << TVO_SYNC_HD_DCS_SHIFT;\n\t\tval |= TVO_SYNC_MAIN_VTG_SET_REF | VTG_SYNC_ID_HDF;\n\t\ttvout_write(tvout, val, TVO_HD_SYNC_SEL);\n\t\ttvo_in_vid_format = TVO_MAIN_IN_VID_FORMAT;\n\t} else {\n\t\tDRM_DEBUG_DRIVER(\"aux vip for HDF\\n\");\n\t\t \n\t\tval  = TVO_SYNC_AUX_VTG_SET_REF | VTG_SYNC_ID_HDDCS;\n\t\tval  = val << TVO_SYNC_HD_DCS_SHIFT;\n\t\tval |= TVO_SYNC_AUX_VTG_SET_REF | VTG_SYNC_ID_HDF;\n\t\ttvout_write(tvout, val, TVO_HD_SYNC_SEL);\n\t\ttvo_in_vid_format = TVO_AUX_IN_VID_FORMAT;\n\t}\n\n\t \n\ttvout_vip_set_color_order(tvout, TVO_VIP_HDF,\n\t\t\t\t  TVO_VIP_REORDER_CR_R_SEL,\n\t\t\t\t  TVO_VIP_REORDER_Y_G_SEL,\n\t\t\t\t  TVO_VIP_REORDER_CB_B_SEL);\n\n\t \n\ttvout_vip_set_clip_mode(tvout, TVO_VIP_HDF, TVO_VIP_CLIP_DISABLED);\n\n\t \n\ttvout_vip_set_rnd(tvout, TVO_VIP_HDF, TVO_VIP_RND_10BIT_ROUNDED);\n\n\t \n\ttvout_vip_set_in_vid_fmt(tvout, tvo_in_vid_format, TVO_IN_FMT_SIGNED);\n\n\t \n\ttvout_vip_set_sel_input(tvout, TVO_VIP_HDF, main_path,\n\t\t\t\tSTI_TVOUT_VIDEO_OUT_YUV);\n\n\t \n\ttvout_write(tvout, 0, TVO_HD_DAC_CFG_OFF);\n}\n\n#define DBGFS_DUMP(reg) seq_printf(s, \"\\n  %-25s 0x%08X\", #reg, \\\n\t\t\t\t   readl(tvout->regs + reg))\n\nstatic void tvout_dbg_vip(struct seq_file *s, int val)\n{\n\tint r, g, b, tmp, mask;\n\tchar *const reorder[] = {\"Y_G\", \"Cb_B\", \"Cr_R\"};\n\tchar *const clipping[] = {\"No\", \"EAV/SAV\", \"Limited range RGB/Y\",\n\t\t\t\t  \"Limited range Cb/Cr\", \"decided by register\"};\n\tchar *const round[] = {\"8-bit\", \"10-bit\", \"12-bit\"};\n\tchar *const input_sel[] = {\"Main (color matrix enabled)\",\n\t\t\t\t   \"Main (color matrix by-passed)\",\n\t\t\t\t   \"\", \"\", \"\", \"\", \"\", \"\",\n\t\t\t\t   \"Aux (color matrix enabled)\",\n\t\t\t\t   \"Aux (color matrix by-passed)\",\n\t\t\t\t   \"\", \"\", \"\", \"\", \"\", \"Force value\"};\n\n\tseq_putc(s, '\\t');\n\tmask = TVO_VIP_REORDER_MASK << TVO_VIP_REORDER_R_SHIFT;\n\tr = (val & mask) >> TVO_VIP_REORDER_R_SHIFT;\n\tmask = TVO_VIP_REORDER_MASK << TVO_VIP_REORDER_G_SHIFT;\n\tg = (val & mask) >> TVO_VIP_REORDER_G_SHIFT;\n\tmask = TVO_VIP_REORDER_MASK << TVO_VIP_REORDER_B_SHIFT;\n\tb = (val & mask) >> TVO_VIP_REORDER_B_SHIFT;\n\tseq_printf(s, \"%-24s %s->%s %s->%s %s->%s\\n\", \"Reorder:\",\n\t\t   reorder[r], reorder[TVO_VIP_REORDER_CR_R_SEL],\n\t\t   reorder[g], reorder[TVO_VIP_REORDER_Y_G_SEL],\n\t\t   reorder[b], reorder[TVO_VIP_REORDER_CB_B_SEL]);\n\tseq_puts(s, \"\\t\\t\\t\\t\\t\");\n\tmask = TVO_VIP_CLIP_MASK << TVO_VIP_CLIP_SHIFT;\n\ttmp = (val & mask) >> TVO_VIP_CLIP_SHIFT;\n\tseq_printf(s, \"%-24s %s\\n\", \"Clipping:\", clipping[tmp]);\n\tseq_puts(s, \"\\t\\t\\t\\t\\t\");\n\tmask = TVO_VIP_RND_MASK << TVO_VIP_RND_SHIFT;\n\ttmp = (val & mask) >> TVO_VIP_RND_SHIFT;\n\tseq_printf(s, \"%-24s input data rounded to %s per component\\n\",\n\t\t   \"Round:\", round[tmp]);\n\tseq_puts(s, \"\\t\\t\\t\\t\\t\");\n\ttmp = (val & TVO_VIP_SEL_INPUT_MASK);\n\tseq_printf(s, \"%-24s %s\", \"Input selection:\", input_sel[tmp]);\n}\n\nstatic void tvout_dbg_hd_dac_cfg(struct seq_file *s, int val)\n{\n\tseq_printf(s, \"\\t%-24s %s\", \"HD DAC:\",\n\t\t   val & 1 ? \"disabled\" : \"enabled\");\n}\n\nstatic int tvout_dbg_show(struct seq_file *s, void *data)\n{\n\tstruct drm_info_node *node = s->private;\n\tstruct sti_tvout *tvout = (struct sti_tvout *)node->info_ent->data;\n\tstruct drm_crtc *crtc;\n\n\tseq_printf(s, \"TVOUT: (vaddr = 0x%p)\", tvout->regs);\n\n\tseq_puts(s, \"\\n\\n  HDMI encoder: \");\n\tcrtc = tvout->hdmi->crtc;\n\tif (crtc) {\n\t\tseq_printf(s, \"connected to %s path\",\n\t\t\t   sti_crtc_is_main(crtc) ? \"main\" : \"aux\");\n\t\tDBGFS_DUMP(TVO_HDMI_SYNC_SEL);\n\t\tDBGFS_DUMP(TVO_VIP_HDMI);\n\t\ttvout_dbg_vip(s, readl(tvout->regs + TVO_VIP_HDMI));\n\t} else {\n\t\tseq_puts(s, \"disabled\");\n\t}\n\n\tseq_puts(s, \"\\n\\n  DVO encoder: \");\n\tcrtc = tvout->dvo->crtc;\n\tif (crtc) {\n\t\tseq_printf(s, \"connected to %s path\",\n\t\t\t   sti_crtc_is_main(crtc) ? \"main\" : \"aux\");\n\t\tDBGFS_DUMP(TVO_DVO_SYNC_SEL);\n\t\tDBGFS_DUMP(TVO_DVO_CONFIG);\n\t\tDBGFS_DUMP(TVO_VIP_DVO);\n\t\ttvout_dbg_vip(s, readl(tvout->regs + TVO_VIP_DVO));\n\t} else {\n\t\tseq_puts(s, \"disabled\");\n\t}\n\n\tseq_puts(s, \"\\n\\n  HDA encoder: \");\n\tcrtc = tvout->hda->crtc;\n\tif (crtc) {\n\t\tseq_printf(s, \"connected to %s path\",\n\t\t\t   sti_crtc_is_main(crtc) ? \"main\" : \"aux\");\n\t\tDBGFS_DUMP(TVO_HD_SYNC_SEL);\n\t\tDBGFS_DUMP(TVO_HD_DAC_CFG_OFF);\n\t\ttvout_dbg_hd_dac_cfg(s,\n\t\t\t\t     readl(tvout->regs + TVO_HD_DAC_CFG_OFF));\n\t\tDBGFS_DUMP(TVO_VIP_HDF);\n\t\ttvout_dbg_vip(s, readl(tvout->regs + TVO_VIP_HDF));\n\t} else {\n\t\tseq_puts(s, \"disabled\");\n\t}\n\n\tseq_puts(s, \"\\n\\n  main path configuration\");\n\tDBGFS_DUMP(TVO_CSC_MAIN_M0);\n\tDBGFS_DUMP(TVO_CSC_MAIN_M1);\n\tDBGFS_DUMP(TVO_CSC_MAIN_M2);\n\tDBGFS_DUMP(TVO_CSC_MAIN_M3);\n\tDBGFS_DUMP(TVO_CSC_MAIN_M4);\n\tDBGFS_DUMP(TVO_CSC_MAIN_M5);\n\tDBGFS_DUMP(TVO_CSC_MAIN_M6);\n\tDBGFS_DUMP(TVO_CSC_MAIN_M7);\n\tDBGFS_DUMP(TVO_MAIN_IN_VID_FORMAT);\n\n\tseq_puts(s, \"\\n\\n  auxiliary path configuration\");\n\tDBGFS_DUMP(TVO_CSC_AUX_M0);\n\tDBGFS_DUMP(TVO_CSC_AUX_M2);\n\tDBGFS_DUMP(TVO_CSC_AUX_M3);\n\tDBGFS_DUMP(TVO_CSC_AUX_M4);\n\tDBGFS_DUMP(TVO_CSC_AUX_M5);\n\tDBGFS_DUMP(TVO_CSC_AUX_M6);\n\tDBGFS_DUMP(TVO_CSC_AUX_M7);\n\tDBGFS_DUMP(TVO_AUX_IN_VID_FORMAT);\n\tseq_putc(s, '\\n');\n\treturn 0;\n}\n\nstatic struct drm_info_list tvout_debugfs_files[] = {\n\t{ \"tvout\", tvout_dbg_show, 0, NULL },\n};\n\nstatic void tvout_debugfs_init(struct sti_tvout *tvout, struct drm_minor *minor)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < ARRAY_SIZE(tvout_debugfs_files); i++)\n\t\ttvout_debugfs_files[i].data = tvout;\n\n\tdrm_debugfs_create_files(tvout_debugfs_files,\n\t\t\t\t ARRAY_SIZE(tvout_debugfs_files),\n\t\t\t\t minor->debugfs_root, minor);\n}\n\nstatic void sti_tvout_encoder_dpms(struct drm_encoder *encoder, int mode)\n{\n}\n\nstatic void sti_tvout_encoder_mode_set(struct drm_encoder *encoder,\n\t\t\t\t       struct drm_display_mode *mode,\n\t\t\t\t       struct drm_display_mode *adjusted_mode)\n{\n}\n\nstatic void sti_tvout_encoder_destroy(struct drm_encoder *encoder)\n{\n\tstruct sti_tvout_encoder *sti_encoder = to_sti_tvout_encoder(encoder);\n\n\tdrm_encoder_cleanup(encoder);\n\tkfree(sti_encoder);\n}\n\nstatic int sti_tvout_late_register(struct drm_encoder *encoder)\n{\n\tstruct sti_tvout *tvout = to_sti_tvout(encoder);\n\n\tif (tvout->debugfs_registered)\n\t\treturn 0;\n\n\ttvout_debugfs_init(tvout, encoder->dev->primary);\n\n\ttvout->debugfs_registered = true;\n\treturn 0;\n}\n\nstatic void sti_tvout_early_unregister(struct drm_encoder *encoder)\n{\n\tstruct sti_tvout *tvout = to_sti_tvout(encoder);\n\n\tif (!tvout->debugfs_registered)\n\t\treturn;\n\n\ttvout->debugfs_registered = false;\n}\n\nstatic const struct drm_encoder_funcs sti_tvout_encoder_funcs = {\n\t.destroy = sti_tvout_encoder_destroy,\n\t.late_register = sti_tvout_late_register,\n\t.early_unregister = sti_tvout_early_unregister,\n};\n\nstatic void sti_dvo_encoder_enable(struct drm_encoder *encoder)\n{\n\tstruct sti_tvout *tvout = to_sti_tvout(encoder);\n\n\ttvout_preformatter_set_matrix(tvout, &encoder->crtc->mode);\n\n\ttvout_dvo_start(tvout, sti_crtc_is_main(encoder->crtc));\n}\n\nstatic void sti_dvo_encoder_disable(struct drm_encoder *encoder)\n{\n\tstruct sti_tvout *tvout = to_sti_tvout(encoder);\n\n\t \n\ttvout_write(tvout, 0x0, TVO_VIP_DVO);\n}\n\nstatic const struct drm_encoder_helper_funcs sti_dvo_encoder_helper_funcs = {\n\t.dpms = sti_tvout_encoder_dpms,\n\t.mode_set = sti_tvout_encoder_mode_set,\n\t.enable = sti_dvo_encoder_enable,\n\t.disable = sti_dvo_encoder_disable,\n};\n\nstatic struct drm_encoder *\nsti_tvout_create_dvo_encoder(struct drm_device *dev,\n\t\t\t     struct sti_tvout *tvout)\n{\n\tstruct sti_tvout_encoder *encoder;\n\tstruct drm_encoder *drm_encoder;\n\n\tencoder = devm_kzalloc(tvout->dev, sizeof(*encoder), GFP_KERNEL);\n\tif (!encoder)\n\t\treturn NULL;\n\n\tencoder->tvout = tvout;\n\n\tdrm_encoder = &encoder->encoder;\n\n\tdrm_encoder->possible_crtcs = ENCODER_CRTC_MASK;\n\n\tdrm_encoder_init(dev, drm_encoder,\n\t\t\t &sti_tvout_encoder_funcs, DRM_MODE_ENCODER_LVDS,\n\t\t\t NULL);\n\n\tdrm_encoder_helper_add(drm_encoder, &sti_dvo_encoder_helper_funcs);\n\n\treturn drm_encoder;\n}\n\nstatic void sti_hda_encoder_enable(struct drm_encoder *encoder)\n{\n\tstruct sti_tvout *tvout = to_sti_tvout(encoder);\n\n\ttvout_preformatter_set_matrix(tvout, &encoder->crtc->mode);\n\n\ttvout_hda_start(tvout, sti_crtc_is_main(encoder->crtc));\n}\n\nstatic void sti_hda_encoder_disable(struct drm_encoder *encoder)\n{\n\tstruct sti_tvout *tvout = to_sti_tvout(encoder);\n\n\t \n\ttvout_write(tvout, 0x0, TVO_VIP_HDF);\n\n\t \n\ttvout_write(tvout, 1, TVO_HD_DAC_CFG_OFF);\n}\n\nstatic const struct drm_encoder_helper_funcs sti_hda_encoder_helper_funcs = {\n\t.dpms = sti_tvout_encoder_dpms,\n\t.mode_set = sti_tvout_encoder_mode_set,\n\t.commit = sti_hda_encoder_enable,\n\t.disable = sti_hda_encoder_disable,\n};\n\nstatic struct drm_encoder *sti_tvout_create_hda_encoder(struct drm_device *dev,\n\t\tstruct sti_tvout *tvout)\n{\n\tstruct sti_tvout_encoder *encoder;\n\tstruct drm_encoder *drm_encoder;\n\n\tencoder = devm_kzalloc(tvout->dev, sizeof(*encoder), GFP_KERNEL);\n\tif (!encoder)\n\t\treturn NULL;\n\n\tencoder->tvout = tvout;\n\n\tdrm_encoder = &encoder->encoder;\n\n\tdrm_encoder->possible_crtcs = ENCODER_CRTC_MASK;\n\n\tdrm_encoder_init(dev, drm_encoder,\n\t\t\t&sti_tvout_encoder_funcs, DRM_MODE_ENCODER_DAC, NULL);\n\n\tdrm_encoder_helper_add(drm_encoder, &sti_hda_encoder_helper_funcs);\n\n\treturn drm_encoder;\n}\n\nstatic void sti_hdmi_encoder_enable(struct drm_encoder *encoder)\n{\n\tstruct sti_tvout *tvout = to_sti_tvout(encoder);\n\n\ttvout_preformatter_set_matrix(tvout, &encoder->crtc->mode);\n\n\ttvout_hdmi_start(tvout, sti_crtc_is_main(encoder->crtc));\n}\n\nstatic void sti_hdmi_encoder_disable(struct drm_encoder *encoder)\n{\n\tstruct sti_tvout *tvout = to_sti_tvout(encoder);\n\n\t \n\ttvout_write(tvout, 0x0, TVO_VIP_HDMI);\n}\n\nstatic const struct drm_encoder_helper_funcs sti_hdmi_encoder_helper_funcs = {\n\t.dpms = sti_tvout_encoder_dpms,\n\t.mode_set = sti_tvout_encoder_mode_set,\n\t.commit = sti_hdmi_encoder_enable,\n\t.disable = sti_hdmi_encoder_disable,\n};\n\nstatic struct drm_encoder *sti_tvout_create_hdmi_encoder(struct drm_device *dev,\n\t\tstruct sti_tvout *tvout)\n{\n\tstruct sti_tvout_encoder *encoder;\n\tstruct drm_encoder *drm_encoder;\n\n\tencoder = devm_kzalloc(tvout->dev, sizeof(*encoder), GFP_KERNEL);\n\tif (!encoder)\n\t\treturn NULL;\n\n\tencoder->tvout = tvout;\n\n\tdrm_encoder = &encoder->encoder;\n\n\tdrm_encoder->possible_crtcs = ENCODER_CRTC_MASK;\n\n\tdrm_encoder_init(dev, drm_encoder,\n\t\t\t&sti_tvout_encoder_funcs, DRM_MODE_ENCODER_TMDS, NULL);\n\n\tdrm_encoder_helper_add(drm_encoder, &sti_hdmi_encoder_helper_funcs);\n\n\treturn drm_encoder;\n}\n\nstatic void sti_tvout_create_encoders(struct drm_device *dev,\n\t\tstruct sti_tvout *tvout)\n{\n\ttvout->hdmi = sti_tvout_create_hdmi_encoder(dev, tvout);\n\ttvout->hda = sti_tvout_create_hda_encoder(dev, tvout);\n\ttvout->dvo = sti_tvout_create_dvo_encoder(dev, tvout);\n\n\ttvout->hdmi->possible_clones = drm_encoder_mask(tvout->hdmi) |\n\t\tdrm_encoder_mask(tvout->hda) | drm_encoder_mask(tvout->dvo);\n\ttvout->hda->possible_clones = drm_encoder_mask(tvout->hdmi) |\n\t\tdrm_encoder_mask(tvout->hda) | drm_encoder_mask(tvout->dvo);\n\ttvout->dvo->possible_clones = drm_encoder_mask(tvout->hdmi) |\n\t\tdrm_encoder_mask(tvout->hda) | drm_encoder_mask(tvout->dvo);\n}\n\nstatic void sti_tvout_destroy_encoders(struct sti_tvout *tvout)\n{\n\tif (tvout->hdmi)\n\t\tdrm_encoder_cleanup(tvout->hdmi);\n\ttvout->hdmi = NULL;\n\n\tif (tvout->hda)\n\t\tdrm_encoder_cleanup(tvout->hda);\n\ttvout->hda = NULL;\n\n\tif (tvout->dvo)\n\t\tdrm_encoder_cleanup(tvout->dvo);\n\ttvout->dvo = NULL;\n}\n\nstatic int sti_tvout_bind(struct device *dev, struct device *master, void *data)\n{\n\tstruct sti_tvout *tvout = dev_get_drvdata(dev);\n\tstruct drm_device *drm_dev = data;\n\n\ttvout->drm_dev = drm_dev;\n\n\tsti_tvout_create_encoders(drm_dev, tvout);\n\n\treturn 0;\n}\n\nstatic void sti_tvout_unbind(struct device *dev, struct device *master,\n\tvoid *data)\n{\n\tstruct sti_tvout *tvout = dev_get_drvdata(dev);\n\n\tsti_tvout_destroy_encoders(tvout);\n}\n\nstatic const struct component_ops sti_tvout_ops = {\n\t.bind\t= sti_tvout_bind,\n\t.unbind\t= sti_tvout_unbind,\n};\n\nstatic int sti_tvout_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct device_node *node = dev->of_node;\n\tstruct sti_tvout *tvout;\n\tstruct resource *res;\n\n\tDRM_INFO(\"%s\\n\", __func__);\n\n\tif (!node)\n\t\treturn -ENODEV;\n\n\ttvout = devm_kzalloc(dev, sizeof(*tvout), GFP_KERNEL);\n\tif (!tvout)\n\t\treturn -ENOMEM;\n\n\ttvout->dev = dev;\n\n\t \n\tres = platform_get_resource_byname(pdev, IORESOURCE_MEM, \"tvout-reg\");\n\tif (!res) {\n\t\tDRM_ERROR(\"Invalid glue resource\\n\");\n\t\treturn -ENOMEM;\n\t}\n\ttvout->regs = devm_ioremap(dev, res->start, resource_size(res));\n\tif (!tvout->regs)\n\t\treturn -ENOMEM;\n\n\t \n\ttvout->reset = devm_reset_control_get(dev, \"tvout\");\n\t \n\tif (!IS_ERR(tvout->reset))\n\t\treset_control_deassert(tvout->reset);\n\n\tplatform_set_drvdata(pdev, tvout);\n\n\treturn component_add(dev, &sti_tvout_ops);\n}\n\nstatic void sti_tvout_remove(struct platform_device *pdev)\n{\n\tcomponent_del(&pdev->dev, &sti_tvout_ops);\n}\n\nstatic const struct of_device_id tvout_of_match[] = {\n\t{ .compatible = \"st,stih407-tvout\", },\n\t{   }\n};\nMODULE_DEVICE_TABLE(of, tvout_of_match);\n\nstruct platform_driver sti_tvout_driver = {\n\t.driver = {\n\t\t.name = \"sti-tvout\",\n\t\t.owner = THIS_MODULE,\n\t\t.of_match_table = tvout_of_match,\n\t},\n\t.probe = sti_tvout_probe,\n\t.remove_new = sti_tvout_remove,\n};\n\nMODULE_AUTHOR(\"Benjamin Gaignard <benjamin.gaignard@st.com>\");\nMODULE_DESCRIPTION(\"STMicroelectronics SoC DRM driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}