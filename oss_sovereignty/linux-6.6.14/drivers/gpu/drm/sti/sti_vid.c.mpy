{
  "module_name": "sti_vid.c",
  "hash_id": "a1ac83df0c99e5bd826c6dae1892a7967adde3c4de30a7ff2d0e9d5abd970947",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/sti/sti_vid.c",
  "human_readable_source": "\n \n#include <linux/seq_file.h>\n\n#include <drm/drm_debugfs.h>\n#include <drm/drm_file.h>\n#include <drm/drm_print.h>\n\n#include \"sti_plane.h\"\n#include \"sti_vid.h\"\n#include \"sti_vtg.h\"\n\n \n#define VID_CTL                 0x00\n#define VID_ALP                 0x04\n#define VID_CLF                 0x08\n#define VID_VPO                 0x0C\n#define VID_VPS                 0x10\n#define VID_KEY1                0x28\n#define VID_KEY2                0x2C\n#define VID_MPR0                0x30\n#define VID_MPR1                0x34\n#define VID_MPR2                0x38\n#define VID_MPR3                0x3C\n#define VID_MST                 0x68\n#define VID_BC                  0x70\n#define VID_TINT                0x74\n#define VID_CSAT                0x78\n\n \n#define VID_CTL_IGNORE          (BIT(31) | BIT(30))\n#define VID_CTL_PSI_ENABLE      (BIT(2) | BIT(1) | BIT(0))\n#define VID_ALP_OPAQUE          0x00000080\n#define VID_BC_DFLT             0x00008000\n#define VID_TINT_DFLT           0x00000000\n#define VID_CSAT_DFLT           0x00000080\n \n#define VID_MPR0_BT709          0x0A800000\n#define VID_MPR1_BT709          0x0AC50000\n#define VID_MPR2_BT709          0x07150545\n#define VID_MPR3_BT709          0x00000AE8\n \n#define VID_MPR0_BT601          0x0A800000\n#define VID_MPR1_BT601          0x0AAF0000\n#define VID_MPR2_BT601          0x094E0754\n#define VID_MPR3_BT601          0x00000ADD\n\n#define VID_MIN_HD_HEIGHT       720\n\n#define DBGFS_DUMP(reg) seq_printf(s, \"\\n  %-25s 0x%08X\", #reg, \\\n\t\t\t\t   readl(vid->regs + reg))\n\nstatic void vid_dbg_ctl(struct seq_file *s, int val)\n{\n\tval = val >> 30;\n\tseq_putc(s, '\\t');\n\n\tif (!(val & 1))\n\t\tseq_puts(s, \"NOT \");\n\tseq_puts(s, \"ignored on main mixer - \");\n\n\tif (!(val & 2))\n\t\tseq_puts(s, \"NOT \");\n\tseq_puts(s, \"ignored on aux mixer\");\n}\n\nstatic void vid_dbg_vpo(struct seq_file *s, int val)\n{\n\tseq_printf(s, \"\\txdo:%4d\\tydo:%4d\", val & 0x0FFF, (val >> 16) & 0x0FFF);\n}\n\nstatic void vid_dbg_vps(struct seq_file *s, int val)\n{\n\tseq_printf(s, \"\\txds:%4d\\tyds:%4d\", val & 0x0FFF, (val >> 16) & 0x0FFF);\n}\n\nstatic void vid_dbg_mst(struct seq_file *s, int val)\n{\n\tif (val & 1)\n\t\tseq_puts(s, \"\\tBUFFER UNDERFLOW!\");\n}\n\nstatic int vid_dbg_show(struct seq_file *s, void *arg)\n{\n\tstruct drm_info_node *node = s->private;\n\tstruct sti_vid *vid = (struct sti_vid *)node->info_ent->data;\n\n\tseq_printf(s, \"VID: (vaddr= 0x%p)\", vid->regs);\n\n\tDBGFS_DUMP(VID_CTL);\n\tvid_dbg_ctl(s, readl(vid->regs + VID_CTL));\n\tDBGFS_DUMP(VID_ALP);\n\tDBGFS_DUMP(VID_CLF);\n\tDBGFS_DUMP(VID_VPO);\n\tvid_dbg_vpo(s, readl(vid->regs + VID_VPO));\n\tDBGFS_DUMP(VID_VPS);\n\tvid_dbg_vps(s, readl(vid->regs + VID_VPS));\n\tDBGFS_DUMP(VID_KEY1);\n\tDBGFS_DUMP(VID_KEY2);\n\tDBGFS_DUMP(VID_MPR0);\n\tDBGFS_DUMP(VID_MPR1);\n\tDBGFS_DUMP(VID_MPR2);\n\tDBGFS_DUMP(VID_MPR3);\n\tDBGFS_DUMP(VID_MST);\n\tvid_dbg_mst(s, readl(vid->regs + VID_MST));\n\tDBGFS_DUMP(VID_BC);\n\tDBGFS_DUMP(VID_TINT);\n\tDBGFS_DUMP(VID_CSAT);\n\tseq_putc(s, '\\n');\n\treturn 0;\n}\n\nstatic struct drm_info_list vid_debugfs_files[] = {\n\t{ \"vid\", vid_dbg_show, 0, NULL },\n};\n\nvoid vid_debugfs_init(struct sti_vid *vid, struct drm_minor *minor)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < ARRAY_SIZE(vid_debugfs_files); i++)\n\t\tvid_debugfs_files[i].data = vid;\n\n\tdrm_debugfs_create_files(vid_debugfs_files,\n\t\t\t\t ARRAY_SIZE(vid_debugfs_files),\n\t\t\t\t minor->debugfs_root, minor);\n}\n\nvoid sti_vid_commit(struct sti_vid *vid,\n\t\t    struct drm_plane_state *state)\n{\n\tstruct drm_crtc *crtc = state->crtc;\n\tstruct drm_display_mode *mode = &crtc->mode;\n\tint dst_x = state->crtc_x;\n\tint dst_y = state->crtc_y;\n\tint dst_w = clamp_val(state->crtc_w, 0, mode->hdisplay - dst_x);\n\tint dst_h = clamp_val(state->crtc_h, 0, mode->vdisplay - dst_y);\n\tint src_h = state->src_h >> 16;\n\tu32 val, ydo, xdo, yds, xds;\n\n\t \n\tdst_w = ALIGN(dst_w, 2);\n\tdst_h = ALIGN(dst_h, 2);\n\n\t \n\tval = readl(vid->regs + VID_CTL);\n\tval &= ~VID_CTL_IGNORE;\n\twritel(val, vid->regs + VID_CTL);\n\n\tydo = sti_vtg_get_line_number(*mode, dst_y);\n\tyds = sti_vtg_get_line_number(*mode, dst_y + dst_h - 1);\n\txdo = sti_vtg_get_pixel_number(*mode, dst_x);\n\txds = sti_vtg_get_pixel_number(*mode, dst_x + dst_w - 1);\n\n\twritel((ydo << 16) | xdo, vid->regs + VID_VPO);\n\twritel((yds << 16) | xds, vid->regs + VID_VPS);\n\n\t \n\tif (src_h >= VID_MIN_HD_HEIGHT) {\n\t\twritel(VID_MPR0_BT709, vid->regs + VID_MPR0);\n\t\twritel(VID_MPR1_BT709, vid->regs + VID_MPR1);\n\t\twritel(VID_MPR2_BT709, vid->regs + VID_MPR2);\n\t\twritel(VID_MPR3_BT709, vid->regs + VID_MPR3);\n\t} else {\n\t\twritel(VID_MPR0_BT601, vid->regs + VID_MPR0);\n\t\twritel(VID_MPR1_BT601, vid->regs + VID_MPR1);\n\t\twritel(VID_MPR2_BT601, vid->regs + VID_MPR2);\n\t\twritel(VID_MPR3_BT601, vid->regs + VID_MPR3);\n\t}\n}\n\nvoid sti_vid_disable(struct sti_vid *vid)\n{\n\tu32 val;\n\n\t \n\tval = readl(vid->regs + VID_CTL);\n\tval |= VID_CTL_IGNORE;\n\twritel(val, vid->regs + VID_CTL);\n}\n\nstatic void sti_vid_init(struct sti_vid *vid)\n{\n\t \n\twritel(VID_CTL_PSI_ENABLE | VID_CTL_IGNORE, vid->regs + VID_CTL);\n\n\t \n\twritel(VID_ALP_OPAQUE, vid->regs + VID_ALP);\n\n\t \n\twritel(VID_BC_DFLT, vid->regs + VID_BC);\n\twritel(VID_TINT_DFLT, vid->regs + VID_TINT);\n\twritel(VID_CSAT_DFLT, vid->regs + VID_CSAT);\n}\n\nstruct sti_vid *sti_vid_create(struct device *dev, struct drm_device *drm_dev,\n\t\t\t       int id, void __iomem *baseaddr)\n{\n\tstruct sti_vid *vid;\n\n\tvid = devm_kzalloc(dev, sizeof(*vid), GFP_KERNEL);\n\tif (!vid) {\n\t\tDRM_ERROR(\"Failed to allocate memory for VID\\n\");\n\t\treturn NULL;\n\t}\n\n\tvid->dev = dev;\n\tvid->regs = baseaddr;\n\tvid->id = id;\n\n\tsti_vid_init(vid);\n\n\treturn vid;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}