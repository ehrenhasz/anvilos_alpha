{
  "module_name": "sti_hda.c",
  "hash_id": "8891aac6c1791a952f8db1376ed7221f328147002457ce27f86e2a654fdb85b2",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/sti/sti_hda.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/component.h>\n#include <linux/io.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include <linux/platform_device.h>\n#include <linux/seq_file.h>\n\n#include <drm/drm_atomic_helper.h>\n#include <drm/drm_bridge.h>\n#include <drm/drm_debugfs.h>\n#include <drm/drm_device.h>\n#include <drm/drm_file.h>\n#include <drm/drm_print.h>\n#include <drm/drm_probe_helper.h>\n\n \n#define HDA_ANA_CFG                     0x0000\n#define HDA_ANA_SCALE_CTRL_Y            0x0004\n#define HDA_ANA_SCALE_CTRL_CB           0x0008\n#define HDA_ANA_SCALE_CTRL_CR           0x000C\n#define HDA_ANA_ANC_CTRL                0x0010\n#define HDA_ANA_SRC_Y_CFG               0x0014\n#define HDA_COEFF_Y_PH1_TAP123          0x0018\n#define HDA_COEFF_Y_PH1_TAP456          0x001C\n#define HDA_COEFF_Y_PH2_TAP123          0x0020\n#define HDA_COEFF_Y_PH2_TAP456          0x0024\n#define HDA_COEFF_Y_PH3_TAP123          0x0028\n#define HDA_COEFF_Y_PH3_TAP456          0x002C\n#define HDA_COEFF_Y_PH4_TAP123          0x0030\n#define HDA_COEFF_Y_PH4_TAP456          0x0034\n#define HDA_ANA_SRC_C_CFG               0x0040\n#define HDA_COEFF_C_PH1_TAP123          0x0044\n#define HDA_COEFF_C_PH1_TAP456          0x0048\n#define HDA_COEFF_C_PH2_TAP123          0x004C\n#define HDA_COEFF_C_PH2_TAP456          0x0050\n#define HDA_COEFF_C_PH3_TAP123          0x0054\n#define HDA_COEFF_C_PH3_TAP456          0x0058\n#define HDA_COEFF_C_PH4_TAP123          0x005C\n#define HDA_COEFF_C_PH4_TAP456          0x0060\n#define HDA_SYNC_AWGI                   0x0300\n\n \n#define CFG_AWG_ASYNC_EN                BIT(0)\n#define CFG_AWG_ASYNC_HSYNC_MTD         BIT(1)\n#define CFG_AWG_ASYNC_VSYNC_MTD         BIT(2)\n#define CFG_AWG_SYNC_DEL                BIT(3)\n#define CFG_AWG_FLTR_MODE_SHIFT         4\n#define CFG_AWG_FLTR_MODE_MASK          (0xF << CFG_AWG_FLTR_MODE_SHIFT)\n#define CFG_AWG_FLTR_MODE_SD            (0 << CFG_AWG_FLTR_MODE_SHIFT)\n#define CFG_AWG_FLTR_MODE_ED            (1 << CFG_AWG_FLTR_MODE_SHIFT)\n#define CFG_AWG_FLTR_MODE_HD            (2 << CFG_AWG_FLTR_MODE_SHIFT)\n#define CFG_SYNC_ON_PBPR_MASK           BIT(8)\n#define CFG_PREFILTER_EN_MASK           BIT(9)\n#define CFG_PBPR_SYNC_OFF_SHIFT         16\n#define CFG_PBPR_SYNC_OFF_MASK          (0x7FF << CFG_PBPR_SYNC_OFF_SHIFT)\n#define CFG_PBPR_SYNC_OFF_VAL           0x117  \n\n \n#define SCALE_CTRL_Y_DFLT               0x00C50256\n#define SCALE_CTRL_CB_DFLT              0x00DB0249\n#define SCALE_CTRL_CR_DFLT              0x00DB0249\n\n \n#define DAC_CFG_HD_HZUVW_OFF_MASK       BIT(1)\n\n \n#define SAMPLER_COEF_NB                 8\n#define HDA_ANA_SRC_Y_CFG_ALT_2X        0x01130000\nstatic u32 coef_y_alt_2x[] = {\n\t0x00FE83FB, 0x1F900401, 0x00000000, 0x00000000,\n\t0x00F408F9, 0x055F7C25, 0x00000000, 0x00000000\n};\n\n#define HDA_ANA_SRC_C_CFG_ALT_2X        0x01750004\nstatic u32 coef_c_alt_2x[] = {\n\t0x001305F7, 0x05274BD0, 0x00000000, 0x00000000,\n\t0x0004907C, 0x09C80B9D, 0x00000000, 0x00000000\n};\n\n \n#define HDA_ANA_SRC_Y_CFG_4X            0x01ED0005\n#define HDA_ANA_SRC_C_CFG_4X            0x01ED0004\nstatic u32 coef_yc_4x[] = {\n\t0x00FC827F, 0x008FE20B, 0x00F684FC, 0x050F7C24,\n\t0x00F4857C, 0x0A1F402E, 0x00FA027F, 0x0E076E1D\n};\n\n \n#define AWG_MAX_INST                    64\n\n \nstatic u32 AWGi_720p_50[] = {\n\t0x00000971, 0x00000C26, 0x0000013B, 0x00000CDA,\n\t0x00000104, 0x00000E7E, 0x00000E7F, 0x0000013B,\n\t0x00000D8E, 0x00000104, 0x00001804, 0x00000971,\n\t0x00000C26, 0x0000003B, 0x00000FB4, 0x00000FB5,\n\t0x00000104, 0x00001AE8\n};\n\n#define NN_720p_50 ARRAY_SIZE(AWGi_720p_50)\n\n \nstatic u32 AWGi_720p_60[] = {\n\t0x00000971, 0x00000C26, 0x0000013B, 0x00000CDA,\n\t0x00000104, 0x00000E7E, 0x00000E7F, 0x0000013B,\n\t0x00000C44, 0x00000104, 0x00001804, 0x00000971,\n\t0x00000C26, 0x0000003B, 0x00000F0F, 0x00000F10,\n\t0x00000104, 0x00001AE8\n};\n\n#define NN_720p_60 ARRAY_SIZE(AWGi_720p_60)\n\n \nstatic u32 AWGi_1080p_30[] = {\n\t0x00000971, 0x00000C2A, 0x0000013B, 0x00000C56,\n\t0x00000104, 0x00000FDC, 0x00000FDD, 0x0000013B,\n\t0x00000C2A, 0x00000104, 0x00001804, 0x00000971,\n\t0x00000C2A, 0x0000003B, 0x00000EBE, 0x00000EBF,\n\t0x00000EBF, 0x00000104, 0x00001A2F, 0x00001C4B,\n\t0x00001C52\n};\n\n#define NN_1080p_30 ARRAY_SIZE(AWGi_1080p_30)\n\n \nstatic u32 AWGi_1080p_25[] = {\n\t0x00000971, 0x00000C2A, 0x0000013B, 0x00000C56,\n\t0x00000104, 0x00000FDC, 0x00000FDD, 0x0000013B,\n\t0x00000DE2, 0x00000104, 0x00001804, 0x00000971,\n\t0x00000C2A, 0x0000003B, 0x00000F51, 0x00000F51,\n\t0x00000F52, 0x00000104, 0x00001A2F, 0x00001C4B,\n\t0x00001C52\n};\n\n#define NN_1080p_25 ARRAY_SIZE(AWGi_1080p_25)\n\n \nstatic u32 AWGi_1080p_24[] = {\n\t0x00000971, 0x00000C2A, 0x0000013B, 0x00000C56,\n\t0x00000104, 0x00000FDC, 0x00000FDD, 0x0000013B,\n\t0x00000E50, 0x00000104, 0x00001804, 0x00000971,\n\t0x00000C2A, 0x0000003B, 0x00000F76, 0x00000F76,\n\t0x00000F76, 0x00000104, 0x00001A2F, 0x00001C4B,\n\t0x00001C52\n};\n\n#define NN_1080p_24 ARRAY_SIZE(AWGi_1080p_24)\n\n \nstatic u32 AWGi_720x480p_60[] = {\n\t0x00000904, 0x00000F18, 0x0000013B, 0x00001805,\n\t0x00000904, 0x00000C3D, 0x0000003B, 0x00001A06\n};\n\n#define NN_720x480p_60 ARRAY_SIZE(AWGi_720x480p_60)\n\n \nenum sti_hda_vid_cat {\n\tVID_SD,\n\tVID_ED,\n\tVID_HD_74M,\n\tVID_HD_148M\n};\n\nstruct sti_hda_video_config {\n\tstruct drm_display_mode mode;\n\tu32 *awg_instr;\n\tint nb_instr;\n\tenum sti_hda_vid_cat vid_cat;\n};\n\n \nstatic const struct sti_hda_video_config hda_supported_modes[] = {\n\t \n\t{{DRM_MODE(\"1920x1080\", DRM_MODE_TYPE_DRIVER, 74250, 1920, 2008,\n\t\t   2052, 2200, 0, 1080, 1084, 1089, 1125, 0,\n\t\t   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC)},\n\t AWGi_1080p_30, NN_1080p_30, VID_HD_74M},\n\t \n\t{{DRM_MODE(\"1920x1080\", DRM_MODE_TYPE_DRIVER, 74176, 1920, 2008,\n\t\t   2052, 2200, 0, 1080, 1084, 1089, 1125, 0,\n\t\t   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC)},\n\t AWGi_1080p_30, NN_1080p_30, VID_HD_74M},\n\t \n\t{{DRM_MODE(\"1920x1080\", DRM_MODE_TYPE_DRIVER, 74250, 1920, 2558,\n\t\t   2602, 2750, 0, 1080, 1084, 1089, 1125, 0,\n\t\t   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC)},\n\t AWGi_1080p_24, NN_1080p_24, VID_HD_74M},\n\t \n\t{{DRM_MODE(\"1920x1080\", DRM_MODE_TYPE_DRIVER, 74176, 1920, 2558,\n\t\t   2602, 2750, 0, 1080, 1084, 1089, 1125, 0,\n\t\t   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC)},\n\t AWGi_1080p_24, NN_1080p_24, VID_HD_74M},\n\t \n\t{{DRM_MODE(\"1920x1080\", DRM_MODE_TYPE_DRIVER, 74250, 1920, 2448,\n\t\t   2492, 2640, 0, 1080, 1084, 1089, 1125, 0,\n\t\t   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC)},\n\t AWGi_1080p_25, NN_1080p_25, VID_HD_74M},\n\t \n\t{{DRM_MODE(\"1280x720\", DRM_MODE_TYPE_DRIVER, 74250, 1280, 1390,\n\t\t   1430, 1650, 0, 720, 725, 730, 750, 0,\n\t\t   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC)},\n\t AWGi_720p_60, NN_720p_60, VID_HD_74M},\n\t \n\t{{DRM_MODE(\"1280x720\", DRM_MODE_TYPE_DRIVER, 74176, 1280, 1390,\n\t\t   1430, 1650, 0, 720, 725, 730, 750, 0,\n\t\t   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC)},\n\t AWGi_720p_60, NN_720p_60, VID_HD_74M},\n\t \n\t{{DRM_MODE(\"1280x720\", DRM_MODE_TYPE_DRIVER, 74250, 1280, 1720,\n\t\t   1760, 1980, 0, 720, 725, 730, 750, 0,\n\t\t   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC)},\n\t AWGi_720p_50, NN_720p_50, VID_HD_74M},\n\t \n\t{{DRM_MODE(\"720x480\", DRM_MODE_TYPE_DRIVER, 27027, 720, 736,\n\t\t   798, 858, 0, 480, 489, 495, 525, 0,\n\t\t   DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_NVSYNC)},\n\t AWGi_720x480p_60, NN_720x480p_60, VID_ED},\n\t \n\t{{DRM_MODE(\"720x480\", DRM_MODE_TYPE_DRIVER, 27000, 720, 736,\n\t\t   798, 858, 0, 480, 489, 495, 525, 0,\n\t\t   DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_NVSYNC)},\n\t AWGi_720x480p_60, NN_720x480p_60, VID_ED}\n};\n\n \nstruct sti_hda {\n\tstruct device dev;\n\tstruct drm_device *drm_dev;\n\tstruct drm_display_mode mode;\n\tvoid __iomem *regs;\n\tvoid __iomem *video_dacs_ctrl;\n\tstruct clk *clk_pix;\n\tstruct clk *clk_hddac;\n\tbool enabled;\n};\n\nstruct sti_hda_connector {\n\tstruct drm_connector drm_connector;\n\tstruct drm_encoder *encoder;\n\tstruct sti_hda *hda;\n};\n\n#define to_sti_hda_connector(x) \\\n\tcontainer_of(x, struct sti_hda_connector, drm_connector)\n\nstatic u32 hda_read(struct sti_hda *hda, int offset)\n{\n\treturn readl(hda->regs + offset);\n}\n\nstatic void hda_write(struct sti_hda *hda, u32 val, int offset)\n{\n\twritel(val, hda->regs + offset);\n}\n\n \nstatic bool hda_get_mode_idx(struct drm_display_mode mode, int *idx)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < ARRAY_SIZE(hda_supported_modes); i++)\n\t\tif (drm_mode_equal(&hda_supported_modes[i].mode, &mode)) {\n\t\t\t*idx = i;\n\t\t\treturn true;\n\t\t}\n\treturn false;\n}\n\n \nstatic void hda_enable_hd_dacs(struct sti_hda *hda, bool enable)\n{\n\tif (hda->video_dacs_ctrl) {\n\t\tu32 val;\n\n\t\tval = readl(hda->video_dacs_ctrl);\n\t\tif (enable)\n\t\t\tval &= ~DAC_CFG_HD_HZUVW_OFF_MASK;\n\t\telse\n\t\t\tval |= DAC_CFG_HD_HZUVW_OFF_MASK;\n\n\t\twritel(val, hda->video_dacs_ctrl);\n\t}\n}\n\n#define DBGFS_DUMP(reg) seq_printf(s, \"\\n  %-25s 0x%08X\", #reg, \\\n\t\t\t\t   readl(hda->regs + reg))\n\nstatic void hda_dbg_cfg(struct seq_file *s, int val)\n{\n\tseq_puts(s, \"\\tAWG \");\n\tseq_puts(s, val & CFG_AWG_ASYNC_EN ? \"enabled\" : \"disabled\");\n}\n\nstatic void hda_dbg_awg_microcode(struct seq_file *s, void __iomem *reg)\n{\n\tunsigned int i;\n\n\tseq_puts(s, \"\\n\\n  HDA AWG microcode:\");\n\tfor (i = 0; i < AWG_MAX_INST; i++) {\n\t\tif (i % 8 == 0)\n\t\t\tseq_printf(s, \"\\n  %04X:\", i);\n\t\tseq_printf(s, \" %04X\", readl(reg + i * 4));\n\t}\n}\n\nstatic void hda_dbg_video_dacs_ctrl(struct seq_file *s, void __iomem *reg)\n{\n\tu32 val = readl(reg);\n\n\tseq_printf(s, \"\\n\\n  %-25s 0x%08X\", \"VIDEO_DACS_CONTROL\", val);\n\tseq_puts(s, \"\\tHD DACs \");\n\tseq_puts(s, val & DAC_CFG_HD_HZUVW_OFF_MASK ? \"disabled\" : \"enabled\");\n}\n\nstatic int hda_dbg_show(struct seq_file *s, void *data)\n{\n\tstruct drm_info_node *node = s->private;\n\tstruct sti_hda *hda = (struct sti_hda *)node->info_ent->data;\n\n\tseq_printf(s, \"HD Analog: (vaddr = 0x%p)\", hda->regs);\n\tDBGFS_DUMP(HDA_ANA_CFG);\n\thda_dbg_cfg(s, readl(hda->regs + HDA_ANA_CFG));\n\tDBGFS_DUMP(HDA_ANA_SCALE_CTRL_Y);\n\tDBGFS_DUMP(HDA_ANA_SCALE_CTRL_CB);\n\tDBGFS_DUMP(HDA_ANA_SCALE_CTRL_CR);\n\tDBGFS_DUMP(HDA_ANA_ANC_CTRL);\n\tDBGFS_DUMP(HDA_ANA_SRC_Y_CFG);\n\tDBGFS_DUMP(HDA_ANA_SRC_C_CFG);\n\thda_dbg_awg_microcode(s, hda->regs + HDA_SYNC_AWGI);\n\tif (hda->video_dacs_ctrl)\n\t\thda_dbg_video_dacs_ctrl(s, hda->video_dacs_ctrl);\n\tseq_putc(s, '\\n');\n\treturn 0;\n}\n\nstatic struct drm_info_list hda_debugfs_files[] = {\n\t{ \"hda\", hda_dbg_show, 0, NULL },\n};\n\nstatic void hda_debugfs_init(struct sti_hda *hda, struct drm_minor *minor)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < ARRAY_SIZE(hda_debugfs_files); i++)\n\t\thda_debugfs_files[i].data = hda;\n\n\tdrm_debugfs_create_files(hda_debugfs_files,\n\t\t\t\t ARRAY_SIZE(hda_debugfs_files),\n\t\t\t\t minor->debugfs_root, minor);\n}\n\n \nstatic void sti_hda_configure_awg(struct sti_hda *hda, u32 *awg_instr, int nb)\n{\n\tunsigned int i;\n\n\tDRM_DEBUG_DRIVER(\"\\n\");\n\n\tfor (i = 0; i < nb; i++)\n\t\thda_write(hda, awg_instr[i], HDA_SYNC_AWGI + i * 4);\n\tfor (i = nb; i < AWG_MAX_INST; i++)\n\t\thda_write(hda, 0, HDA_SYNC_AWGI + i * 4);\n}\n\nstatic void sti_hda_disable(struct drm_bridge *bridge)\n{\n\tstruct sti_hda *hda = bridge->driver_private;\n\tu32 val;\n\n\tif (!hda->enabled)\n\t\treturn;\n\n\tDRM_DEBUG_DRIVER(\"\\n\");\n\n\t \n\tval = hda_read(hda, HDA_ANA_CFG);\n\tval &= ~CFG_AWG_ASYNC_EN;\n\thda_write(hda, val, HDA_ANA_CFG);\n\thda_write(hda, 0, HDA_ANA_ANC_CTRL);\n\n\thda_enable_hd_dacs(hda, false);\n\n\t \n\tclk_disable_unprepare(hda->clk_hddac);\n\tclk_disable_unprepare(hda->clk_pix);\n\n\thda->enabled = false;\n}\n\nstatic void sti_hda_pre_enable(struct drm_bridge *bridge)\n{\n\tstruct sti_hda *hda = bridge->driver_private;\n\tu32 val, i, mode_idx;\n\tu32 src_filter_y, src_filter_c;\n\tu32 *coef_y, *coef_c;\n\tu32 filter_mode;\n\n\tDRM_DEBUG_DRIVER(\"\\n\");\n\n\tif (hda->enabled)\n\t\treturn;\n\n\t \n\tif (clk_prepare_enable(hda->clk_pix))\n\t\tDRM_ERROR(\"Failed to prepare/enable hda_pix clk\\n\");\n\tif (clk_prepare_enable(hda->clk_hddac))\n\t\tDRM_ERROR(\"Failed to prepare/enable hda_hddac clk\\n\");\n\n\tif (!hda_get_mode_idx(hda->mode, &mode_idx)) {\n\t\tDRM_ERROR(\"Undefined mode\\n\");\n\t\treturn;\n\t}\n\n\tswitch (hda_supported_modes[mode_idx].vid_cat) {\n\tcase VID_HD_148M:\n\t\tDRM_ERROR(\"Beyond HD analog capabilities\\n\");\n\t\treturn;\n\tcase VID_HD_74M:\n\t\t \n\t\tfilter_mode = CFG_AWG_FLTR_MODE_HD;\n\t\tsrc_filter_y = HDA_ANA_SRC_Y_CFG_ALT_2X;\n\t\tsrc_filter_c = HDA_ANA_SRC_C_CFG_ALT_2X;\n\t\tcoef_y = coef_y_alt_2x;\n\t\tcoef_c = coef_c_alt_2x;\n\t\tbreak;\n\tcase VID_ED:\n\t\t \n\t\tfilter_mode = CFG_AWG_FLTR_MODE_ED;\n\t\tsrc_filter_y = HDA_ANA_SRC_Y_CFG_4X;\n\t\tsrc_filter_c = HDA_ANA_SRC_C_CFG_4X;\n\t\tcoef_y = coef_yc_4x;\n\t\tcoef_c = coef_yc_4x;\n\t\tbreak;\n\tcase VID_SD:\n\t\tDRM_ERROR(\"Not supported\\n\");\n\t\treturn;\n\tdefault:\n\t\tDRM_ERROR(\"Undefined resolution\\n\");\n\t\treturn;\n\t}\n\tDRM_DEBUG_DRIVER(\"Using HDA mode #%d\\n\", mode_idx);\n\n\t \n\thda_enable_hd_dacs(hda, true);\n\n\t \n\thda_write(hda, SCALE_CTRL_Y_DFLT, HDA_ANA_SCALE_CTRL_Y);\n\thda_write(hda, SCALE_CTRL_CB_DFLT, HDA_ANA_SCALE_CTRL_CB);\n\thda_write(hda, SCALE_CTRL_CR_DFLT, HDA_ANA_SCALE_CTRL_CR);\n\n\t \n\thda_write(hda , src_filter_y, HDA_ANA_SRC_Y_CFG);\n\thda_write(hda, src_filter_c,  HDA_ANA_SRC_C_CFG);\n\tfor (i = 0; i < SAMPLER_COEF_NB; i++) {\n\t\thda_write(hda, coef_y[i], HDA_COEFF_Y_PH1_TAP123 + i * 4);\n\t\thda_write(hda, coef_c[i], HDA_COEFF_C_PH1_TAP123 + i * 4);\n\t}\n\n\t \n\tval = 0;\n\tval |= (hda->mode.flags & DRM_MODE_FLAG_INTERLACE) ?\n\t    0 : CFG_AWG_ASYNC_VSYNC_MTD;\n\tval |= (CFG_PBPR_SYNC_OFF_VAL << CFG_PBPR_SYNC_OFF_SHIFT);\n\tval |= filter_mode;\n\thda_write(hda, val, HDA_ANA_CFG);\n\n\t \n\tsti_hda_configure_awg(hda, hda_supported_modes[mode_idx].awg_instr,\n\t\t\t      hda_supported_modes[mode_idx].nb_instr);\n\n\t \n\tval = hda_read(hda, HDA_ANA_CFG);\n\tval |= CFG_AWG_ASYNC_EN;\n\thda_write(hda, val, HDA_ANA_CFG);\n\n\thda->enabled = true;\n}\n\nstatic void sti_hda_set_mode(struct drm_bridge *bridge,\n\t\t\t     const struct drm_display_mode *mode,\n\t\t\t     const struct drm_display_mode *adjusted_mode)\n{\n\tstruct sti_hda *hda = bridge->driver_private;\n\tu32 mode_idx;\n\tint hddac_rate;\n\tint ret;\n\n\tDRM_DEBUG_DRIVER(\"\\n\");\n\n\tdrm_mode_copy(&hda->mode, mode);\n\n\tif (!hda_get_mode_idx(hda->mode, &mode_idx)) {\n\t\tDRM_ERROR(\"Undefined mode\\n\");\n\t\treturn;\n\t}\n\n\tswitch (hda_supported_modes[mode_idx].vid_cat) {\n\tcase VID_HD_74M:\n\t\t \n\t\thddac_rate = mode->clock * 1000 * 2;\n\t\tbreak;\n\tcase VID_ED:\n\t\t \n\t\thddac_rate = mode->clock * 1000 * 4;\n\t\tbreak;\n\tdefault:\n\t\tDRM_ERROR(\"Undefined mode\\n\");\n\t\treturn;\n\t}\n\n\t \n\tret = clk_set_rate(hda->clk_hddac, hddac_rate);\n\tif (ret < 0)\n\t\tDRM_ERROR(\"Cannot set rate (%dHz) for hda_hddac clk\\n\",\n\t\t\t  hddac_rate);\n\n\t \n\tret = clk_set_rate(hda->clk_pix, mode->clock * 1000);\n\tif (ret < 0)\n\t\tDRM_ERROR(\"Cannot set rate (%dHz) for hda_pix clk\\n\",\n\t\t\t  mode->clock * 1000);\n}\n\nstatic void sti_hda_bridge_nope(struct drm_bridge *bridge)\n{\n\t \n}\n\nstatic const struct drm_bridge_funcs sti_hda_bridge_funcs = {\n\t.pre_enable = sti_hda_pre_enable,\n\t.enable = sti_hda_bridge_nope,\n\t.disable = sti_hda_disable,\n\t.post_disable = sti_hda_bridge_nope,\n\t.mode_set = sti_hda_set_mode,\n};\n\nstatic int sti_hda_connector_get_modes(struct drm_connector *connector)\n{\n\tunsigned int i;\n\tint count = 0;\n\tstruct sti_hda_connector *hda_connector\n\t\t= to_sti_hda_connector(connector);\n\tstruct sti_hda *hda = hda_connector->hda;\n\n\tDRM_DEBUG_DRIVER(\"\\n\");\n\n\tfor (i = 0; i < ARRAY_SIZE(hda_supported_modes); i++) {\n\t\tstruct drm_display_mode *mode =\n\t\t\tdrm_mode_duplicate(hda->drm_dev,\n\t\t\t\t\t&hda_supported_modes[i].mode);\n\t\tif (!mode)\n\t\t\tcontinue;\n\n\t\t \n\t\tif (i == 0)\n\t\t\tmode->type |= DRM_MODE_TYPE_PREFERRED;\n\n\t\tdrm_mode_probed_add(connector, mode);\n\t\tcount++;\n\t}\n\n\treturn count;\n}\n\n#define CLK_TOLERANCE_HZ 50\n\nstatic enum drm_mode_status\nsti_hda_connector_mode_valid(struct drm_connector *connector,\n\t\t\t     struct drm_display_mode *mode)\n{\n\tint target = mode->clock * 1000;\n\tint target_min = target - CLK_TOLERANCE_HZ;\n\tint target_max = target + CLK_TOLERANCE_HZ;\n\tint result;\n\tint idx;\n\tstruct sti_hda_connector *hda_connector\n\t\t= to_sti_hda_connector(connector);\n\tstruct sti_hda *hda = hda_connector->hda;\n\n\tif (!hda_get_mode_idx(*mode, &idx)) {\n\t\treturn MODE_BAD;\n\t} else {\n\t\tresult = clk_round_rate(hda->clk_pix, target);\n\n\t\tDRM_DEBUG_DRIVER(\"target rate = %d => available rate = %d\\n\",\n\t\t\t\t target, result);\n\n\t\tif ((result < target_min) || (result > target_max)) {\n\t\t\tDRM_DEBUG_DRIVER(\"hda pixclk=%d not supported\\n\",\n\t\t\t\t\t target);\n\t\t\treturn MODE_BAD;\n\t\t}\n\t}\n\n\treturn MODE_OK;\n}\n\nstatic const\nstruct drm_connector_helper_funcs sti_hda_connector_helper_funcs = {\n\t.get_modes = sti_hda_connector_get_modes,\n\t.mode_valid = sti_hda_connector_mode_valid,\n};\n\nstatic int sti_hda_late_register(struct drm_connector *connector)\n{\n\tstruct sti_hda_connector *hda_connector\n\t\t= to_sti_hda_connector(connector);\n\tstruct sti_hda *hda = hda_connector->hda;\n\n\thda_debugfs_init(hda, hda->drm_dev->primary);\n\n\treturn 0;\n}\n\nstatic const struct drm_connector_funcs sti_hda_connector_funcs = {\n\t.fill_modes = drm_helper_probe_single_connector_modes,\n\t.destroy = drm_connector_cleanup,\n\t.reset = drm_atomic_helper_connector_reset,\n\t.atomic_duplicate_state = drm_atomic_helper_connector_duplicate_state,\n\t.atomic_destroy_state = drm_atomic_helper_connector_destroy_state,\n\t.late_register = sti_hda_late_register,\n};\n\nstatic struct drm_encoder *sti_hda_find_encoder(struct drm_device *dev)\n{\n\tstruct drm_encoder *encoder;\n\n\tlist_for_each_entry(encoder, &dev->mode_config.encoder_list, head) {\n\t\tif (encoder->encoder_type == DRM_MODE_ENCODER_DAC)\n\t\t\treturn encoder;\n\t}\n\n\treturn NULL;\n}\n\nstatic int sti_hda_bind(struct device *dev, struct device *master, void *data)\n{\n\tstruct sti_hda *hda = dev_get_drvdata(dev);\n\tstruct drm_device *drm_dev = data;\n\tstruct drm_encoder *encoder;\n\tstruct sti_hda_connector *connector;\n\tstruct drm_connector *drm_connector;\n\tstruct drm_bridge *bridge;\n\tint err;\n\n\t \n\thda->drm_dev = drm_dev;\n\n\tencoder = sti_hda_find_encoder(drm_dev);\n\tif (!encoder)\n\t\treturn -ENOMEM;\n\n\tconnector = devm_kzalloc(dev, sizeof(*connector), GFP_KERNEL);\n\tif (!connector)\n\t\treturn -ENOMEM;\n\n\tconnector->hda = hda;\n\n\t\tbridge = devm_kzalloc(dev, sizeof(*bridge), GFP_KERNEL);\n\tif (!bridge)\n\t\treturn -ENOMEM;\n\n\tbridge->driver_private = hda;\n\tbridge->funcs = &sti_hda_bridge_funcs;\n\tdrm_bridge_attach(encoder, bridge, NULL, 0);\n\n\tconnector->encoder = encoder;\n\n\tdrm_connector = (struct drm_connector *)connector;\n\n\tdrm_connector->polled = DRM_CONNECTOR_POLL_HPD;\n\n\tdrm_connector_init(drm_dev, drm_connector,\n\t\t\t&sti_hda_connector_funcs, DRM_MODE_CONNECTOR_Component);\n\tdrm_connector_helper_add(drm_connector,\n\t\t\t&sti_hda_connector_helper_funcs);\n\n\terr = drm_connector_attach_encoder(drm_connector, encoder);\n\tif (err) {\n\t\tDRM_ERROR(\"Failed to attach a connector to a encoder\\n\");\n\t\tgoto err_sysfs;\n\t}\n\n\t \n\thda_enable_hd_dacs(hda, false);\n\n\treturn 0;\n\nerr_sysfs:\n\treturn -EINVAL;\n}\n\nstatic void sti_hda_unbind(struct device *dev,\n\t\tstruct device *master, void *data)\n{\n}\n\nstatic const struct component_ops sti_hda_ops = {\n\t.bind = sti_hda_bind,\n\t.unbind = sti_hda_unbind,\n};\n\nstatic int sti_hda_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct sti_hda *hda;\n\tstruct resource *res;\n\n\tDRM_INFO(\"%s\\n\", __func__);\n\n\thda = devm_kzalloc(dev, sizeof(*hda), GFP_KERNEL);\n\tif (!hda)\n\t\treturn -ENOMEM;\n\n\thda->dev = pdev->dev;\n\n\t \n\tres = platform_get_resource_byname(pdev, IORESOURCE_MEM, \"hda-reg\");\n\tif (!res) {\n\t\tDRM_ERROR(\"Invalid hda resource\\n\");\n\t\treturn -ENOMEM;\n\t}\n\thda->regs = devm_ioremap(dev, res->start, resource_size(res));\n\tif (!hda->regs)\n\t\treturn -ENOMEM;\n\n\tres = platform_get_resource_byname(pdev, IORESOURCE_MEM,\n\t\t\t\"video-dacs-ctrl\");\n\tif (res) {\n\t\thda->video_dacs_ctrl = devm_ioremap(dev, res->start,\n\t\t\t\tresource_size(res));\n\t\tif (!hda->video_dacs_ctrl)\n\t\t\treturn -ENOMEM;\n\t} else {\n\t\t \n\t\tDRM_DEBUG_DRIVER(\"No video-dacs-ctrl resource\\n\");\n\t\thda->video_dacs_ctrl = NULL;\n\t}\n\n\t \n\thda->clk_pix = devm_clk_get(dev, \"pix\");\n\tif (IS_ERR(hda->clk_pix)) {\n\t\tDRM_ERROR(\"Cannot get hda_pix clock\\n\");\n\t\treturn PTR_ERR(hda->clk_pix);\n\t}\n\n\thda->clk_hddac = devm_clk_get(dev, \"hddac\");\n\tif (IS_ERR(hda->clk_hddac)) {\n\t\tDRM_ERROR(\"Cannot get hda_hddac clock\\n\");\n\t\treturn PTR_ERR(hda->clk_hddac);\n\t}\n\n\tplatform_set_drvdata(pdev, hda);\n\n\treturn component_add(&pdev->dev, &sti_hda_ops);\n}\n\nstatic void sti_hda_remove(struct platform_device *pdev)\n{\n\tcomponent_del(&pdev->dev, &sti_hda_ops);\n}\n\nstatic const struct of_device_id hda_of_match[] = {\n\t{ .compatible = \"st,stih416-hda\", },\n\t{ .compatible = \"st,stih407-hda\", },\n\t{   }\n};\nMODULE_DEVICE_TABLE(of, hda_of_match);\n\nstruct platform_driver sti_hda_driver = {\n\t.driver = {\n\t\t.name = \"sti-hda\",\n\t\t.owner = THIS_MODULE,\n\t\t.of_match_table = hda_of_match,\n\t},\n\t.probe = sti_hda_probe,\n\t.remove_new = sti_hda_remove,\n};\n\nMODULE_AUTHOR(\"Benjamin Gaignard <benjamin.gaignard@st.com>\");\nMODULE_DESCRIPTION(\"STMicroelectronics SoC DRM driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}