{
  "module_name": "sti_cursor.c",
  "hash_id": "46718917827ce12b3638bbf6add31acd2e63bb9989e13ac2dfe353a7ffe4c723",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/sti/sti_cursor.c",
  "human_readable_source": "\n \n\n#include <linux/dma-mapping.h>\n#include <linux/seq_file.h>\n\n#include <drm/drm_atomic.h>\n#include <drm/drm_device.h>\n#include <drm/drm_fb_dma_helper.h>\n#include <drm/drm_framebuffer.h>\n#include <drm/drm_gem_dma_helper.h>\n\n#include \"sti_compositor.h\"\n#include \"sti_cursor.h\"\n#include \"sti_plane.h\"\n#include \"sti_vtg.h\"\n\n \n#define CUR_CTL             0x00\n#define CUR_VPO             0x0C\n#define CUR_PML             0x14\n#define CUR_PMP             0x18\n#define CUR_SIZE            0x1C\n#define CUR_CML             0x20\n#define CUR_AWS             0x28\n#define CUR_AWE             0x2C\n\n#define CUR_CTL_CLUT_UPDATE BIT(1)\n\n#define STI_CURS_MIN_SIZE   1\n#define STI_CURS_MAX_SIZE   128\n\n \nstruct dma_pixmap {\n\tdma_addr_t paddr;\n\tsize_t size;\n\tvoid *base;\n};\n\n \nstruct sti_cursor {\n\tstruct sti_plane plane;\n\tstruct device *dev;\n\tvoid __iomem *regs;\n\tunsigned int width;\n\tunsigned int height;\n\tunsigned short *clut;\n\tdma_addr_t clut_paddr;\n\tstruct dma_pixmap pixmap;\n};\n\nstatic const uint32_t cursor_supported_formats[] = {\n\tDRM_FORMAT_ARGB8888,\n};\n\n#define to_sti_cursor(x) container_of(x, struct sti_cursor, plane)\n\n#define DBGFS_DUMP(reg) seq_printf(s, \"\\n  %-25s 0x%08X\", #reg, \\\n\t\t\t\t   readl(cursor->regs + reg))\n\nstatic void cursor_dbg_vpo(struct seq_file *s, u32 val)\n{\n\tseq_printf(s, \"\\txdo:%4d\\tydo:%4d\", val & 0x0FFF, (val >> 16) & 0x0FFF);\n}\n\nstatic void cursor_dbg_size(struct seq_file *s, u32 val)\n{\n\tseq_printf(s, \"\\t%d x %d\", val & 0x07FF, (val >> 16) & 0x07FF);\n}\n\nstatic void cursor_dbg_pml(struct seq_file *s,\n\t\t\t   struct sti_cursor *cursor, u32 val)\n{\n\tif (cursor->pixmap.paddr == val)\n\t\tseq_printf(s, \"\\tVirt @: %p\", cursor->pixmap.base);\n}\n\nstatic void cursor_dbg_cml(struct seq_file *s,\n\t\t\t   struct sti_cursor *cursor, u32 val)\n{\n\tif (cursor->clut_paddr == val)\n\t\tseq_printf(s, \"\\tVirt @: %p\", cursor->clut);\n}\n\nstatic int cursor_dbg_show(struct seq_file *s, void *data)\n{\n\tstruct drm_info_node *node = s->private;\n\tstruct sti_cursor *cursor = (struct sti_cursor *)node->info_ent->data;\n\n\tseq_printf(s, \"%s: (vaddr = 0x%p)\",\n\t\t   sti_plane_to_str(&cursor->plane), cursor->regs);\n\n\tDBGFS_DUMP(CUR_CTL);\n\tDBGFS_DUMP(CUR_VPO);\n\tcursor_dbg_vpo(s, readl(cursor->regs + CUR_VPO));\n\tDBGFS_DUMP(CUR_PML);\n\tcursor_dbg_pml(s, cursor, readl(cursor->regs + CUR_PML));\n\tDBGFS_DUMP(CUR_PMP);\n\tDBGFS_DUMP(CUR_SIZE);\n\tcursor_dbg_size(s, readl(cursor->regs + CUR_SIZE));\n\tDBGFS_DUMP(CUR_CML);\n\tcursor_dbg_cml(s, cursor, readl(cursor->regs + CUR_CML));\n\tDBGFS_DUMP(CUR_AWS);\n\tDBGFS_DUMP(CUR_AWE);\n\tseq_putc(s, '\\n');\n\treturn 0;\n}\n\nstatic struct drm_info_list cursor_debugfs_files[] = {\n\t{ \"cursor\", cursor_dbg_show, 0, NULL },\n};\n\nstatic void cursor_debugfs_init(struct sti_cursor *cursor,\n\t\t\t\tstruct drm_minor *minor)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < ARRAY_SIZE(cursor_debugfs_files); i++)\n\t\tcursor_debugfs_files[i].data = cursor;\n\n\tdrm_debugfs_create_files(cursor_debugfs_files,\n\t\t\t\t ARRAY_SIZE(cursor_debugfs_files),\n\t\t\t\t minor->debugfs_root, minor);\n}\n\nstatic void sti_cursor_argb8888_to_clut8(struct sti_cursor *cursor, u32 *src)\n{\n\tu8  *dst = cursor->pixmap.base;\n\tunsigned int i, j;\n\tu32 a, r, g, b;\n\n\tfor (i = 0; i < cursor->height; i++) {\n\t\tfor (j = 0; j < cursor->width; j++) {\n\t\t\t \n\t\t\ta = (*src >> 30) & 3;\n\t\t\tr = (*src >> 22) & 3;\n\t\t\tg = (*src >> 14) & 3;\n\t\t\tb = (*src >> 6) & 3;\n\t\t\t*dst = a << 6 | r << 4 | g << 2 | b;\n\t\t\tsrc++;\n\t\t\tdst++;\n\t\t}\n\t}\n}\n\nstatic void sti_cursor_init(struct sti_cursor *cursor)\n{\n\tunsigned short *base = cursor->clut;\n\tunsigned int a, r, g, b;\n\n\t \n\tfor (a = 0; a < 4; a++)\n\t\tfor (r = 0; r < 4; r++)\n\t\t\tfor (g = 0; g < 4; g++)\n\t\t\t\tfor (b = 0; b < 4; b++)\n\t\t\t\t\t*base++ = (a * 5) << 12 |\n\t\t\t\t\t\t  (r * 5) << 8 |\n\t\t\t\t\t\t  (g * 5) << 4 |\n\t\t\t\t\t\t  (b * 5);\n}\n\nstatic int sti_cursor_atomic_check(struct drm_plane *drm_plane,\n\t\t\t\t   struct drm_atomic_state *state)\n{\n\tstruct drm_plane_state *new_plane_state = drm_atomic_get_new_plane_state(state,\n\t\t\t\t\t\t\t\t\t\t drm_plane);\n\tstruct sti_plane *plane = to_sti_plane(drm_plane);\n\tstruct sti_cursor *cursor = to_sti_cursor(plane);\n\tstruct drm_crtc *crtc = new_plane_state->crtc;\n\tstruct drm_framebuffer *fb = new_plane_state->fb;\n\tstruct drm_crtc_state *crtc_state;\n\tstruct drm_display_mode *mode;\n\tint dst_x, dst_y, dst_w, dst_h;\n\tint src_w, src_h;\n\n\t \n\tif (!crtc || !fb)\n\t\treturn 0;\n\n\tcrtc_state = drm_atomic_get_crtc_state(state, crtc);\n\tmode = &crtc_state->mode;\n\tdst_x = new_plane_state->crtc_x;\n\tdst_y = new_plane_state->crtc_y;\n\tdst_w = clamp_val(new_plane_state->crtc_w, 0,\n\t\t\t  mode->crtc_hdisplay - dst_x);\n\tdst_h = clamp_val(new_plane_state->crtc_h, 0,\n\t\t\t  mode->crtc_vdisplay - dst_y);\n\t \n\tsrc_w = new_plane_state->src_w >> 16;\n\tsrc_h = new_plane_state->src_h >> 16;\n\n\tif (src_w < STI_CURS_MIN_SIZE ||\n\t    src_h < STI_CURS_MIN_SIZE ||\n\t    src_w > STI_CURS_MAX_SIZE ||\n\t    src_h > STI_CURS_MAX_SIZE) {\n\t\tDRM_ERROR(\"Invalid cursor size (%dx%d)\\n\",\n\t\t\t\tsrc_w, src_h);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (!cursor->pixmap.base ||\n\t    (cursor->width != src_w) ||\n\t    (cursor->height != src_h)) {\n\t\tcursor->width = src_w;\n\t\tcursor->height = src_h;\n\n\t\tif (cursor->pixmap.base)\n\t\t\tdma_free_wc(cursor->dev, cursor->pixmap.size,\n\t\t\t\t    cursor->pixmap.base, cursor->pixmap.paddr);\n\n\t\tcursor->pixmap.size = cursor->width * cursor->height;\n\n\t\tcursor->pixmap.base = dma_alloc_wc(cursor->dev,\n\t\t\t\t\t\t   cursor->pixmap.size,\n\t\t\t\t\t\t   &cursor->pixmap.paddr,\n\t\t\t\t\t\t   GFP_KERNEL | GFP_DMA);\n\t\tif (!cursor->pixmap.base) {\n\t\t\tDRM_ERROR(\"Failed to allocate memory for pixmap\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tif (!drm_fb_dma_get_gem_obj(fb, 0)) {\n\t\tDRM_ERROR(\"Can't get DMA GEM object for fb\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tDRM_DEBUG_KMS(\"CRTC:%d (%s) drm plane:%d (%s)\\n\",\n\t\t      crtc->base.id, sti_mixer_to_str(to_sti_mixer(crtc)),\n\t\t      drm_plane->base.id, sti_plane_to_str(plane));\n\tDRM_DEBUG_KMS(\"(%dx%d)@(%d,%d)\\n\", dst_w, dst_h, dst_x, dst_y);\n\n\treturn 0;\n}\n\nstatic void sti_cursor_atomic_update(struct drm_plane *drm_plane,\n\t\t\t\t     struct drm_atomic_state *state)\n{\n\tstruct drm_plane_state *newstate = drm_atomic_get_new_plane_state(state,\n\t\t\t\t\t\t\t\t\t  drm_plane);\n\tstruct sti_plane *plane = to_sti_plane(drm_plane);\n\tstruct sti_cursor *cursor = to_sti_cursor(plane);\n\tstruct drm_crtc *crtc = newstate->crtc;\n\tstruct drm_framebuffer *fb = newstate->fb;\n\tstruct drm_display_mode *mode;\n\tint dst_x, dst_y;\n\tstruct drm_gem_dma_object *dma_obj;\n\tu32 y, x;\n\tu32 val;\n\n\tif (!crtc || !fb)\n\t\treturn;\n\n\tmode = &crtc->mode;\n\tdst_x = newstate->crtc_x;\n\tdst_y = newstate->crtc_y;\n\n\tdma_obj = drm_fb_dma_get_gem_obj(fb, 0);\n\n\t \n\tsti_cursor_argb8888_to_clut8(cursor, (u32 *)dma_obj->vaddr);\n\n\t \n\ty = sti_vtg_get_line_number(*mode, 0);\n\tx = sti_vtg_get_pixel_number(*mode, 0);\n\tval = y << 16 | x;\n\twritel(val, cursor->regs + CUR_AWS);\n\ty = sti_vtg_get_line_number(*mode, mode->vdisplay - 1);\n\tx = sti_vtg_get_pixel_number(*mode, mode->hdisplay - 1);\n\tval = y << 16 | x;\n\twritel(val, cursor->regs + CUR_AWE);\n\n\t \n\twritel(cursor->pixmap.paddr, cursor->regs + CUR_PML);\n\twritel(cursor->width, cursor->regs + CUR_PMP);\n\twritel(cursor->height << 16 | cursor->width, cursor->regs + CUR_SIZE);\n\n\ty = sti_vtg_get_line_number(*mode, dst_y);\n\tx = sti_vtg_get_pixel_number(*mode, dst_x);\n\twritel((y << 16) | x, cursor->regs + CUR_VPO);\n\n\t \n\twritel(cursor->clut_paddr, cursor->regs + CUR_CML);\n\twritel(CUR_CTL_CLUT_UPDATE, cursor->regs + CUR_CTL);\n\n\tsti_plane_update_fps(plane, true, false);\n\n\tplane->status = STI_PLANE_UPDATED;\n}\n\nstatic void sti_cursor_atomic_disable(struct drm_plane *drm_plane,\n\t\t\t\t      struct drm_atomic_state *state)\n{\n\tstruct drm_plane_state *oldstate = drm_atomic_get_old_plane_state(state,\n\t\t\t\t\t\t\t\t\t  drm_plane);\n\tstruct sti_plane *plane = to_sti_plane(drm_plane);\n\n\tif (!oldstate->crtc) {\n\t\tDRM_DEBUG_DRIVER(\"drm plane:%d not enabled\\n\",\n\t\t\t\t drm_plane->base.id);\n\t\treturn;\n\t}\n\n\tDRM_DEBUG_DRIVER(\"CRTC:%d (%s) drm plane:%d (%s)\\n\",\n\t\t\t oldstate->crtc->base.id,\n\t\t\t sti_mixer_to_str(to_sti_mixer(oldstate->crtc)),\n\t\t\t drm_plane->base.id, sti_plane_to_str(plane));\n\n\tplane->status = STI_PLANE_DISABLING;\n}\n\nstatic const struct drm_plane_helper_funcs sti_cursor_helpers_funcs = {\n\t.atomic_check = sti_cursor_atomic_check,\n\t.atomic_update = sti_cursor_atomic_update,\n\t.atomic_disable = sti_cursor_atomic_disable,\n};\n\nstatic int sti_cursor_late_register(struct drm_plane *drm_plane)\n{\n\tstruct sti_plane *plane = to_sti_plane(drm_plane);\n\tstruct sti_cursor *cursor = to_sti_cursor(plane);\n\n\tcursor_debugfs_init(cursor, drm_plane->dev->primary);\n\n\treturn 0;\n}\n\nstatic const struct drm_plane_funcs sti_cursor_plane_helpers_funcs = {\n\t.update_plane = drm_atomic_helper_update_plane,\n\t.disable_plane = drm_atomic_helper_disable_plane,\n\t.destroy = drm_plane_cleanup,\n\t.reset = drm_atomic_helper_plane_reset,\n\t.atomic_duplicate_state = drm_atomic_helper_plane_duplicate_state,\n\t.atomic_destroy_state = drm_atomic_helper_plane_destroy_state,\n\t.late_register = sti_cursor_late_register,\n};\n\nstruct drm_plane *sti_cursor_create(struct drm_device *drm_dev,\n\t\t\t\t    struct device *dev, int desc,\n\t\t\t\t    void __iomem *baseaddr,\n\t\t\t\t    unsigned int possible_crtcs)\n{\n\tstruct sti_cursor *cursor;\n\tsize_t size;\n\tint res;\n\n\tcursor = devm_kzalloc(dev, sizeof(*cursor), GFP_KERNEL);\n\tif (!cursor) {\n\t\tDRM_ERROR(\"Failed to allocate memory for cursor\\n\");\n\t\treturn NULL;\n\t}\n\n\t \n\tsize = 0x100 * sizeof(unsigned short);\n\tcursor->clut = dma_alloc_wc(dev, size, &cursor->clut_paddr,\n\t\t\t\t    GFP_KERNEL | GFP_DMA);\n\n\tif (!cursor->clut) {\n\t\tDRM_ERROR(\"Failed to allocate memory for cursor clut\\n\");\n\t\tgoto err_clut;\n\t}\n\n\tcursor->dev = dev;\n\tcursor->regs = baseaddr;\n\tcursor->plane.desc = desc;\n\tcursor->plane.status = STI_PLANE_DISABLED;\n\n\tsti_cursor_init(cursor);\n\n\tres = drm_universal_plane_init(drm_dev, &cursor->plane.drm_plane,\n\t\t\t\t       possible_crtcs,\n\t\t\t\t       &sti_cursor_plane_helpers_funcs,\n\t\t\t\t       cursor_supported_formats,\n\t\t\t\t       ARRAY_SIZE(cursor_supported_formats),\n\t\t\t\t       NULL, DRM_PLANE_TYPE_CURSOR, NULL);\n\tif (res) {\n\t\tDRM_ERROR(\"Failed to initialize universal plane\\n\");\n\t\tgoto err_plane;\n\t}\n\n\tdrm_plane_helper_add(&cursor->plane.drm_plane,\n\t\t\t     &sti_cursor_helpers_funcs);\n\n\tsti_plane_init_property(&cursor->plane, DRM_PLANE_TYPE_CURSOR);\n\n\treturn &cursor->plane.drm_plane;\n\nerr_plane:\n\tdma_free_wc(dev, size, cursor->clut, cursor->clut_paddr);\nerr_clut:\n\tdevm_kfree(dev, cursor);\n\treturn NULL;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}