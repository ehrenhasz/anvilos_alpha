{
  "module_name": "sti_drv.c",
  "hash_id": "f715ad55089aa04287c16700fd7ceea6b7f4eb8701a4c828a27e3d155c6f0707",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/sti/sti_drv.c",
  "human_readable_source": "\n \n\n#include <linux/component.h>\n#include <linux/dma-mapping.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/of_platform.h>\n#include <linux/platform_device.h>\n\n#include <drm/drm_atomic.h>\n#include <drm/drm_atomic_helper.h>\n#include <drm/drm_debugfs.h>\n#include <drm/drm_drv.h>\n#include <drm/drm_fbdev_dma.h>\n#include <drm/drm_gem_dma_helper.h>\n#include <drm/drm_gem_framebuffer_helper.h>\n#include <drm/drm_of.h>\n#include <drm/drm_probe_helper.h>\n\n#include \"sti_drv.h\"\n#include \"sti_plane.h\"\n\n#define DRIVER_NAME\t\"sti\"\n#define DRIVER_DESC\t\"STMicroelectronics SoC DRM\"\n#define DRIVER_DATE\t\"20140601\"\n#define DRIVER_MAJOR\t1\n#define DRIVER_MINOR\t0\n\n#define STI_MAX_FB_HEIGHT\t4096\n#define STI_MAX_FB_WIDTH\t4096\n\nstatic int sti_drm_fps_get(void *data, u64 *val)\n{\n\tstruct drm_device *drm_dev = data;\n\tstruct drm_plane *p;\n\tunsigned int i = 0;\n\n\t*val = 0;\n\tlist_for_each_entry(p, &drm_dev->mode_config.plane_list, head) {\n\t\tstruct sti_plane *plane = to_sti_plane(p);\n\n\t\t*val |= plane->fps_info.output << i;\n\t\ti++;\n\t}\n\n\treturn 0;\n}\n\nstatic int sti_drm_fps_set(void *data, u64 val)\n{\n\tstruct drm_device *drm_dev = data;\n\tstruct drm_plane *p;\n\tunsigned int i = 0;\n\n\tlist_for_each_entry(p, &drm_dev->mode_config.plane_list, head) {\n\t\tstruct sti_plane *plane = to_sti_plane(p);\n\n\t\tmemset(&plane->fps_info, 0, sizeof(plane->fps_info));\n\t\tplane->fps_info.output = (val >> i) & 1;\n\n\t\ti++;\n\t}\n\n\treturn 0;\n}\n\nDEFINE_SIMPLE_ATTRIBUTE(sti_drm_fps_fops,\n\t\t\tsti_drm_fps_get, sti_drm_fps_set, \"%llu\\n\");\n\nstatic int sti_drm_fps_dbg_show(struct seq_file *s, void *data)\n{\n\tstruct drm_info_node *node = s->private;\n\tstruct drm_device *dev = node->minor->dev;\n\tstruct drm_plane *p;\n\n\tlist_for_each_entry(p, &dev->mode_config.plane_list, head) {\n\t\tstruct sti_plane *plane = to_sti_plane(p);\n\n\t\tseq_printf(s, \"%s%s\\n\",\n\t\t\t   plane->fps_info.fps_str,\n\t\t\t   plane->fps_info.fips_str);\n\t}\n\n\treturn 0;\n}\n\nstatic struct drm_info_list sti_drm_dbg_list[] = {\n\t{\"fps_get\", sti_drm_fps_dbg_show, 0},\n};\n\nstatic void sti_drm_dbg_init(struct drm_minor *minor)\n{\n\tdrm_debugfs_create_files(sti_drm_dbg_list,\n\t\t\t\t ARRAY_SIZE(sti_drm_dbg_list),\n\t\t\t\t minor->debugfs_root, minor);\n\n\tdebugfs_create_file(\"fps_show\", S_IRUGO | S_IWUSR, minor->debugfs_root,\n\t\t\t    minor->dev, &sti_drm_fps_fops);\n\n\tDRM_INFO(\"%s: debugfs installed\\n\", DRIVER_NAME);\n}\n\nstatic const struct drm_mode_config_funcs sti_mode_config_funcs = {\n\t.fb_create = drm_gem_fb_create,\n\t.atomic_check = drm_atomic_helper_check,\n\t.atomic_commit = drm_atomic_helper_commit,\n};\n\nstatic void sti_mode_config_init(struct drm_device *dev)\n{\n\tdev->mode_config.min_width = 0;\n\tdev->mode_config.min_height = 0;\n\n\t \n\tdev->mode_config.max_width = STI_MAX_FB_WIDTH;\n\tdev->mode_config.max_height = STI_MAX_FB_HEIGHT;\n\n\tdev->mode_config.funcs = &sti_mode_config_funcs;\n\n\tdev->mode_config.normalize_zpos = true;\n}\n\nDEFINE_DRM_GEM_DMA_FOPS(sti_driver_fops);\n\nstatic const struct drm_driver sti_driver = {\n\t.driver_features = DRIVER_MODESET | DRIVER_GEM | DRIVER_ATOMIC,\n\t.fops = &sti_driver_fops,\n\tDRM_GEM_DMA_DRIVER_OPS,\n\n\t.debugfs_init = sti_drm_dbg_init,\n\n\t.name = DRIVER_NAME,\n\t.desc = DRIVER_DESC,\n\t.date = DRIVER_DATE,\n\t.major = DRIVER_MAJOR,\n\t.minor = DRIVER_MINOR,\n};\n\nstatic int sti_init(struct drm_device *ddev)\n{\n\tstruct sti_private *private;\n\n\tprivate = kzalloc(sizeof(*private), GFP_KERNEL);\n\tif (!private)\n\t\treturn -ENOMEM;\n\n\tddev->dev_private = (void *)private;\n\tdev_set_drvdata(ddev->dev, ddev);\n\tprivate->drm_dev = ddev;\n\n\tdrm_mode_config_init(ddev);\n\n\tsti_mode_config_init(ddev);\n\n\tdrm_kms_helper_poll_init(ddev);\n\n\treturn 0;\n}\n\nstatic void sti_cleanup(struct drm_device *ddev)\n{\n\tstruct sti_private *private = ddev->dev_private;\n\n\tdrm_kms_helper_poll_fini(ddev);\n\tdrm_atomic_helper_shutdown(ddev);\n\tdrm_mode_config_cleanup(ddev);\n\tcomponent_unbind_all(ddev->dev, ddev);\n\tkfree(private);\n\tddev->dev_private = NULL;\n}\n\nstatic int sti_bind(struct device *dev)\n{\n\tstruct drm_device *ddev;\n\tint ret;\n\n\tddev = drm_dev_alloc(&sti_driver, dev);\n\tif (IS_ERR(ddev))\n\t\treturn PTR_ERR(ddev);\n\n\tret = sti_init(ddev);\n\tif (ret)\n\t\tgoto err_drm_dev_put;\n\n\tret = component_bind_all(ddev->dev, ddev);\n\tif (ret)\n\t\tgoto err_cleanup;\n\n\tret = drm_dev_register(ddev, 0);\n\tif (ret)\n\t\tgoto err_cleanup;\n\n\tdrm_mode_config_reset(ddev);\n\n\tdrm_fbdev_dma_setup(ddev, 32);\n\n\treturn 0;\n\nerr_cleanup:\n\tsti_cleanup(ddev);\nerr_drm_dev_put:\n\tdrm_dev_put(ddev);\n\treturn ret;\n}\n\nstatic void sti_unbind(struct device *dev)\n{\n\tstruct drm_device *ddev = dev_get_drvdata(dev);\n\n\tdrm_dev_unregister(ddev);\n\tsti_cleanup(ddev);\n\tdrm_dev_put(ddev);\n}\n\nstatic const struct component_master_ops sti_ops = {\n\t.bind = sti_bind,\n\t.unbind = sti_unbind,\n};\n\nstatic int sti_platform_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct device_node *node = dev->of_node;\n\tstruct device_node *child_np;\n\tstruct component_match *match = NULL;\n\n\tdma_set_coherent_mask(dev, DMA_BIT_MASK(32));\n\n\tdevm_of_platform_populate(dev);\n\n\tchild_np = of_get_next_available_child(node, NULL);\n\n\twhile (child_np) {\n\t\tdrm_of_component_match_add(dev, &match, component_compare_of,\n\t\t\t\t\t   child_np);\n\t\tchild_np = of_get_next_available_child(node, child_np);\n\t}\n\n\treturn component_master_add_with_match(dev, &sti_ops, match);\n}\n\nstatic void sti_platform_remove(struct platform_device *pdev)\n{\n\tcomponent_master_del(&pdev->dev, &sti_ops);\n}\n\nstatic const struct of_device_id sti_dt_ids[] = {\n\t{ .compatible = \"st,sti-display-subsystem\", },\n\t{   },\n};\nMODULE_DEVICE_TABLE(of, sti_dt_ids);\n\nstatic struct platform_driver sti_platform_driver = {\n\t.probe = sti_platform_probe,\n\t.remove_new = sti_platform_remove,\n\t.driver = {\n\t\t.name = DRIVER_NAME,\n\t\t.of_match_table = sti_dt_ids,\n\t},\n};\n\nstatic struct platform_driver * const drivers[] = {\n\t&sti_tvout_driver,\n\t&sti_hqvdp_driver,\n\t&sti_hdmi_driver,\n\t&sti_hda_driver,\n\t&sti_dvo_driver,\n\t&sti_vtg_driver,\n\t&sti_compositor_driver,\n\t&sti_platform_driver,\n};\n\nstatic int sti_drm_init(void)\n{\n\tif (drm_firmware_drivers_only())\n\t\treturn -ENODEV;\n\n\treturn platform_register_drivers(drivers, ARRAY_SIZE(drivers));\n}\nmodule_init(sti_drm_init);\n\nstatic void sti_drm_exit(void)\n{\n\tplatform_unregister_drivers(drivers, ARRAY_SIZE(drivers));\n}\nmodule_exit(sti_drm_exit);\n\nMODULE_AUTHOR(\"Benjamin Gaignard <benjamin.gaignard@st.com>\");\nMODULE_DESCRIPTION(\"STMicroelectronics SoC DRM driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}