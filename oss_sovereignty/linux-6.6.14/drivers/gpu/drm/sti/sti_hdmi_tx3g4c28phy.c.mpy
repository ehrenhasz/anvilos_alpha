{
  "module_name": "sti_hdmi_tx3g4c28phy.c",
  "hash_id": "2018722ef5cc33d947f492b4e193d4d2c83c5f30a349c2b1b19824df8709564b",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/sti/sti_hdmi_tx3g4c28phy.c",
  "human_readable_source": "\n \n\n#include <drm/drm_print.h>\n\n#include \"sti_hdmi_tx3g4c28phy.h\"\n\n#define HDMI_SRZ_CFG                             0x504\n#define HDMI_SRZ_PLL_CFG                         0x510\n#define HDMI_SRZ_ICNTL                           0x518\n#define HDMI_SRZ_CALCODE_EXT                     0x520\n\n#define HDMI_SRZ_CFG_EN                          BIT(0)\n#define HDMI_SRZ_CFG_DISABLE_BYPASS_SINK_CURRENT BIT(1)\n#define HDMI_SRZ_CFG_EXTERNAL_DATA               BIT(16)\n#define HDMI_SRZ_CFG_RBIAS_EXT                   BIT(17)\n#define HDMI_SRZ_CFG_EN_SINK_TERM_DETECTION      BIT(18)\n#define HDMI_SRZ_CFG_EN_BIASRES_DETECTION        BIT(19)\n#define HDMI_SRZ_CFG_EN_SRC_TERMINATION          BIT(24)\n\n#define HDMI_SRZ_CFG_INTERNAL_MASK  (HDMI_SRZ_CFG_EN     | \\\n\t\tHDMI_SRZ_CFG_DISABLE_BYPASS_SINK_CURRENT | \\\n\t\tHDMI_SRZ_CFG_EXTERNAL_DATA               | \\\n\t\tHDMI_SRZ_CFG_RBIAS_EXT                   | \\\n\t\tHDMI_SRZ_CFG_EN_SINK_TERM_DETECTION      | \\\n\t\tHDMI_SRZ_CFG_EN_BIASRES_DETECTION        | \\\n\t\tHDMI_SRZ_CFG_EN_SRC_TERMINATION)\n\n#define PLL_CFG_EN                               BIT(0)\n#define PLL_CFG_NDIV_SHIFT                       (8)\n#define PLL_CFG_IDF_SHIFT                        (16)\n#define PLL_CFG_ODF_SHIFT                        (24)\n\n#define ODF_DIV_1                                (0)\n#define ODF_DIV_2                                (1)\n#define ODF_DIV_4                                (2)\n#define ODF_DIV_8                                (3)\n\n#define HDMI_TIMEOUT_PLL_LOCK  50   \n\nstruct plldividers_s {\n\tuint32_t min;\n\tuint32_t max;\n\tuint32_t idf;\n\tuint32_t odf;\n};\n\n \n#define NB_PLL_MODE 5\nstatic struct plldividers_s plldividers[NB_PLL_MODE] = {\n\t{0, 20000000, 1, ODF_DIV_8},\n\t{20000000, 42500000, 2, ODF_DIV_8},\n\t{42500000, 85000000, 4, ODF_DIV_4},\n\t{85000000, 170000000, 8, ODF_DIV_2},\n\t{170000000, 340000000, 16, ODF_DIV_1}\n};\n\n#define NB_HDMI_PHY_CONFIG 2\nstatic struct hdmi_phy_config hdmiphy_config[NB_HDMI_PHY_CONFIG] = {\n\t{0, 250000000, {0x0, 0x0, 0x0, 0x0} },\n\t{250000000, 300000000, {0x1110, 0x0, 0x0, 0x0} },\n};\n\n \nstatic bool sti_hdmi_tx3g4c28phy_start(struct sti_hdmi *hdmi)\n{\n\tu32 ckpxpll = hdmi->mode.clock * 1000;\n\tu32 val, tmdsck, idf, odf, pllctrl = 0;\n\tbool foundplldivides = false;\n\tint i;\n\n\tDRM_DEBUG_DRIVER(\"ckpxpll = %dHz\\n\", ckpxpll);\n\n\tfor (i = 0; i < NB_PLL_MODE; i++) {\n\t\tif (ckpxpll >= plldividers[i].min &&\n\t\t    ckpxpll < plldividers[i].max) {\n\t\t\tidf = plldividers[i].idf;\n\t\t\todf = plldividers[i].odf;\n\t\t\tfoundplldivides = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!foundplldivides) {\n\t\tDRM_ERROR(\"input TMDS clock speed (%d) not supported\\n\",\n\t\t\t  ckpxpll);\n\t\tgoto err;\n\t}\n\n\t \n\ttmdsck = ckpxpll;\n\tpllctrl |= 40 << PLL_CFG_NDIV_SHIFT;\n\n\tif (tmdsck > 340000000) {\n\t\tDRM_ERROR(\"output TMDS clock (%d) out of range\\n\", tmdsck);\n\t\tgoto err;\n\t}\n\n\tpllctrl |= idf << PLL_CFG_IDF_SHIFT;\n\tpllctrl |= odf << PLL_CFG_ODF_SHIFT;\n\n\t \n\thdmi->event_received = false;\n\tDRM_DEBUG_DRIVER(\"pllctrl = 0x%x\\n\", pllctrl);\n\thdmi_write(hdmi, (pllctrl | PLL_CFG_EN), HDMI_SRZ_PLL_CFG);\n\n\t \n\twait_event_interruptible_timeout(hdmi->wait_event,\n\t\t\t\t\t hdmi->event_received == true,\n\t\t\t\t\t msecs_to_jiffies\n\t\t\t\t\t (HDMI_TIMEOUT_PLL_LOCK));\n\n\tif ((hdmi_read(hdmi, HDMI_STA) & HDMI_STA_DLL_LCK) == 0) {\n\t\tDRM_ERROR(\"hdmi phy pll not locked\\n\");\n\t\tgoto err;\n\t}\n\n\tDRM_DEBUG_DRIVER(\"got PHY PLL Lock\\n\");\n\n\tval = (HDMI_SRZ_CFG_EN |\n\t       HDMI_SRZ_CFG_EXTERNAL_DATA |\n\t       HDMI_SRZ_CFG_EN_BIASRES_DETECTION |\n\t       HDMI_SRZ_CFG_EN_SINK_TERM_DETECTION);\n\n\tif (tmdsck > 165000000)\n\t\tval |= HDMI_SRZ_CFG_EN_SRC_TERMINATION;\n\n\t \n\tfor (i = 0; i < NB_HDMI_PHY_CONFIG; i++) {\n\t\tif ((hdmiphy_config[i].min_tmds_freq <= tmdsck) &&\n\t\t    (hdmiphy_config[i].max_tmds_freq >= tmdsck)) {\n\t\t\tval |= (hdmiphy_config[i].config[0]\n\t\t\t\t& ~HDMI_SRZ_CFG_INTERNAL_MASK);\n\t\t\thdmi_write(hdmi, val, HDMI_SRZ_CFG);\n\n\t\t\tval = hdmiphy_config[i].config[1];\n\t\t\thdmi_write(hdmi, val, HDMI_SRZ_ICNTL);\n\n\t\t\tval = hdmiphy_config[i].config[2];\n\t\t\thdmi_write(hdmi, val, HDMI_SRZ_CALCODE_EXT);\n\n\t\t\tDRM_DEBUG_DRIVER(\"serializer cfg 0x%x 0x%x 0x%x\\n\",\n\t\t\t\t\t hdmiphy_config[i].config[0],\n\t\t\t\t\t hdmiphy_config[i].config[1],\n\t\t\t\t\t hdmiphy_config[i].config[2]);\n\t\t\treturn true;\n\t\t}\n\t}\n\n\t \n\thdmi_write(hdmi, val,  HDMI_SRZ_CFG);\n\thdmi_write(hdmi, 0x0, HDMI_SRZ_ICNTL);\n\thdmi_write(hdmi, 0x0, HDMI_SRZ_CALCODE_EXT);\n\n\treturn true;\n\nerr:\n\treturn false;\n}\n\n \nstatic void sti_hdmi_tx3g4c28phy_stop(struct sti_hdmi *hdmi)\n{\n\tint val = 0;\n\n\tDRM_DEBUG_DRIVER(\"\\n\");\n\n\thdmi->event_received = false;\n\n\tval = HDMI_SRZ_CFG_EN_SINK_TERM_DETECTION;\n\tval |= HDMI_SRZ_CFG_EN_BIASRES_DETECTION;\n\n\thdmi_write(hdmi, val, HDMI_SRZ_CFG);\n\thdmi_write(hdmi, 0, HDMI_SRZ_PLL_CFG);\n\n\t \n\twait_event_interruptible_timeout(hdmi->wait_event,\n\t\t\t\t\t hdmi->event_received == true,\n\t\t\t\t\t msecs_to_jiffies\n\t\t\t\t\t (HDMI_TIMEOUT_PLL_LOCK));\n\n\tif (hdmi_read(hdmi, HDMI_STA) & HDMI_STA_DLL_LCK)\n\t\tDRM_ERROR(\"hdmi phy pll not well disabled\\n\");\n}\n\nstruct hdmi_phy_ops tx3g4c28phy_ops = {\n\t.start = sti_hdmi_tx3g4c28phy_start,\n\t.stop = sti_hdmi_tx3g4c28phy_stop,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}