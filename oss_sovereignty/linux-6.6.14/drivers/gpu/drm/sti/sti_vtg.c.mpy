{
  "module_name": "sti_vtg.c",
  "hash_id": "0a6522d8523ee9f0b47394e870a147358fd3276dbd9ed03816d72e1ae8ef501a",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/sti/sti_vtg.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/io.h>\n#include <linux/notifier.h>\n#include <linux/of_platform.h>\n#include <linux/platform_device.h>\n\n#include <drm/drm_modes.h>\n#include <drm/drm_print.h>\n\n#include \"sti_drv.h\"\n#include \"sti_vtg.h\"\n\n#define VTG_MODE_MASTER         0\n\n \n#define VTG_MODE            0x0000\n#define VTG_CLKLN           0x0008\n#define VTG_HLFLN           0x000C\n#define VTG_DRST_AUTOC      0x0010\n#define VTG_VID_TFO         0x0040\n#define VTG_VID_TFS         0x0044\n#define VTG_VID_BFO         0x0048\n#define VTG_VID_BFS         0x004C\n\n#define VTG_HOST_ITS        0x0078\n#define VTG_HOST_ITS_BCLR   0x007C\n#define VTG_HOST_ITM_BCLR   0x0088\n#define VTG_HOST_ITM_BSET   0x008C\n\n#define VTG_H_HD_1          0x00C0\n#define VTG_TOP_V_VD_1      0x00C4\n#define VTG_BOT_V_VD_1      0x00C8\n#define VTG_TOP_V_HD_1      0x00CC\n#define VTG_BOT_V_HD_1      0x00D0\n\n#define VTG_H_HD_2          0x00E0\n#define VTG_TOP_V_VD_2      0x00E4\n#define VTG_BOT_V_VD_2      0x00E8\n#define VTG_TOP_V_HD_2      0x00EC\n#define VTG_BOT_V_HD_2      0x00F0\n\n#define VTG_H_HD_3          0x0100\n#define VTG_TOP_V_VD_3      0x0104\n#define VTG_BOT_V_VD_3      0x0108\n#define VTG_TOP_V_HD_3      0x010C\n#define VTG_BOT_V_HD_3      0x0110\n\n#define VTG_H_HD_4          0x0120\n#define VTG_TOP_V_VD_4      0x0124\n#define VTG_BOT_V_VD_4      0x0128\n#define VTG_TOP_V_HD_4      0x012c\n#define VTG_BOT_V_HD_4      0x0130\n\n#define VTG_IRQ_BOTTOM      BIT(0)\n#define VTG_IRQ_TOP         BIT(1)\n#define VTG_IRQ_MASK        (VTG_IRQ_TOP | VTG_IRQ_BOTTOM)\n\n \n#define HDMI_DELAY          (5)\n\n \n#define DVO_DELAY           (7)\n\n \n#define AWG_DELAY_HD        (-9)\n#define AWG_DELAY_ED        (-8)\n#define AWG_DELAY_SD        (-7)\n\n \nstruct sti_vtg_regs_offs {\n\tu32 h_hd;\n\tu32 top_v_vd;\n\tu32 bot_v_vd;\n\tu32 top_v_hd;\n\tu32 bot_v_hd;\n};\n\n#define VTG_MAX_SYNC_OUTPUT 4\nstatic const struct sti_vtg_regs_offs vtg_regs_offs[VTG_MAX_SYNC_OUTPUT] = {\n\t{ VTG_H_HD_1,\n\t  VTG_TOP_V_VD_1, VTG_BOT_V_VD_1, VTG_TOP_V_HD_1, VTG_BOT_V_HD_1 },\n\t{ VTG_H_HD_2,\n\t  VTG_TOP_V_VD_2, VTG_BOT_V_VD_2, VTG_TOP_V_HD_2, VTG_BOT_V_HD_2 },\n\t{ VTG_H_HD_3,\n\t  VTG_TOP_V_VD_3, VTG_BOT_V_VD_3, VTG_TOP_V_HD_3, VTG_BOT_V_HD_3 },\n\t{ VTG_H_HD_4,\n\t  VTG_TOP_V_VD_4, VTG_BOT_V_VD_4, VTG_TOP_V_HD_4, VTG_BOT_V_HD_4 }\n};\n\n \nstruct sti_vtg_sync_params {\n\tu32 hsync;\n\tu32 vsync_line_top;\n\tu32 vsync_line_bot;\n\tu32 vsync_off_top;\n\tu32 vsync_off_bot;\n};\n\n \nstruct sti_vtg {\n\tvoid __iomem *regs;\n\tstruct sti_vtg_sync_params sync_params[VTG_MAX_SYNC_OUTPUT];\n\tint irq;\n\tu32 irq_status;\n\tstruct raw_notifier_head notifier_list;\n\tstruct drm_crtc *crtc;\n};\n\nstruct sti_vtg *of_vtg_find(struct device_node *np)\n{\n\tstruct platform_device *pdev;\n\n\tpdev = of_find_device_by_node(np);\n\tif (!pdev)\n\t\treturn NULL;\n\n\treturn (struct sti_vtg *)platform_get_drvdata(pdev);\n}\n\nstatic void vtg_reset(struct sti_vtg *vtg)\n{\n\twritel(1, vtg->regs + VTG_DRST_AUTOC);\n}\n\nstatic void vtg_set_output_window(void __iomem *regs,\n\t\t\t\t  const struct drm_display_mode *mode)\n{\n\tu32 video_top_field_start;\n\tu32 video_top_field_stop;\n\tu32 video_bottom_field_start;\n\tu32 video_bottom_field_stop;\n\tu32 xstart = sti_vtg_get_pixel_number(*mode, 0);\n\tu32 ystart = sti_vtg_get_line_number(*mode, 0);\n\tu32 xstop = sti_vtg_get_pixel_number(*mode, mode->hdisplay - 1);\n\tu32 ystop = sti_vtg_get_line_number(*mode, mode->vdisplay - 1);\n\n\t \n\tvideo_top_field_start = (ystart << 16) | xstart;\n\tvideo_top_field_stop = (ystop << 16) | xstop;\n\n\t \n\tvideo_bottom_field_start = video_top_field_start;\n\tvideo_bottom_field_stop = video_top_field_stop;\n\n\twritel(video_top_field_start, regs + VTG_VID_TFO);\n\twritel(video_top_field_stop, regs + VTG_VID_TFS);\n\twritel(video_bottom_field_start, regs + VTG_VID_BFO);\n\twritel(video_bottom_field_stop, regs + VTG_VID_BFS);\n}\n\nstatic void vtg_set_hsync_vsync_pos(struct sti_vtg_sync_params *sync,\n\t\t\t\t    int delay,\n\t\t\t\t    const struct drm_display_mode *mode)\n{\n\tlong clocksperline, start, stop;\n\tu32 risesync_top, fallsync_top;\n\tu32 risesync_offs_top, fallsync_offs_top;\n\n\tclocksperline = mode->htotal;\n\n\t \n\tstart = 0;\n\tstop = mode->hsync_end - mode->hsync_start;\n\n\tstart += delay;\n\tstop  += delay;\n\n\tif (start < 0)\n\t\tstart += clocksperline;\n\telse if (start >= clocksperline)\n\t\tstart -= clocksperline;\n\n\tif (stop < 0)\n\t\tstop += clocksperline;\n\telse if (stop >= clocksperline)\n\t\tstop -= clocksperline;\n\n\tsync->hsync = (stop << 16) | start;\n\n\t \n\tif (delay >= 0) {\n\t\trisesync_top = 1;\n\t\tfallsync_top = risesync_top;\n\t\tfallsync_top += mode->vsync_end - mode->vsync_start;\n\n\t\tfallsync_offs_top = (u32)delay;\n\t\trisesync_offs_top = (u32)delay;\n\t} else {\n\t\trisesync_top = mode->vtotal;\n\t\tfallsync_top = mode->vsync_end - mode->vsync_start;\n\n\t\tfallsync_offs_top = clocksperline + delay;\n\t\trisesync_offs_top = clocksperline + delay;\n\t}\n\n\tsync->vsync_line_top = (fallsync_top << 16) | risesync_top;\n\tsync->vsync_off_top = (fallsync_offs_top << 16) | risesync_offs_top;\n\n\t \n\tsync->vsync_line_bot = sync->vsync_line_top;\n\tsync->vsync_off_bot = sync->vsync_off_top;\n}\n\nstatic void vtg_set_mode(struct sti_vtg *vtg,\n\t\t\t int type,\n\t\t\t struct sti_vtg_sync_params *sync,\n\t\t\t const struct drm_display_mode *mode)\n{\n\tunsigned int i;\n\n\t \n\twritel(mode->htotal, vtg->regs + VTG_CLKLN);\n\n\t \n\twritel(mode->vtotal * 2, vtg->regs + VTG_HLFLN);\n\n\t \n\tvtg_set_output_window(vtg->regs, mode);\n\n\t \n\tvtg_set_hsync_vsync_pos(&sync[VTG_SYNC_ID_HDMI - 1], HDMI_DELAY, mode);\n\n\t \n\tvtg_set_hsync_vsync_pos(&sync[VTG_SYNC_ID_HDDCS - 1], 0, mode);\n\n\t \n\tvtg_set_hsync_vsync_pos(&sync[VTG_SYNC_ID_HDF - 1], AWG_DELAY_HD, mode);\n\n\t \n\tvtg_set_hsync_vsync_pos(&sync[VTG_SYNC_ID_DVO - 1], DVO_DELAY, mode);\n\n\t \n\tfor (i = 0; i < VTG_MAX_SYNC_OUTPUT ; i++) {\n\t\twritel(sync[i].hsync,\n\t\t       vtg->regs + vtg_regs_offs[i].h_hd);\n\t\twritel(sync[i].vsync_line_top,\n\t\t       vtg->regs + vtg_regs_offs[i].top_v_vd);\n\t\twritel(sync[i].vsync_line_bot,\n\t\t       vtg->regs + vtg_regs_offs[i].bot_v_vd);\n\t\twritel(sync[i].vsync_off_top,\n\t\t       vtg->regs + vtg_regs_offs[i].top_v_hd);\n\t\twritel(sync[i].vsync_off_bot,\n\t\t       vtg->regs + vtg_regs_offs[i].bot_v_hd);\n\t}\n\n\t \n\twritel(type, vtg->regs + VTG_MODE);\n}\n\nstatic void vtg_enable_irq(struct sti_vtg *vtg)\n{\n\t \n\twritel(0xFFFF, vtg->regs + VTG_HOST_ITS_BCLR);\n\twritel(0xFFFF, vtg->regs + VTG_HOST_ITM_BCLR);\n\twritel(VTG_IRQ_MASK, vtg->regs + VTG_HOST_ITM_BSET);\n}\n\nvoid sti_vtg_set_config(struct sti_vtg *vtg,\n\t\tconst struct drm_display_mode *mode)\n{\n\t \n\tvtg_set_mode(vtg, VTG_MODE_MASTER, vtg->sync_params, mode);\n\n\tvtg_reset(vtg);\n\n\tvtg_enable_irq(vtg);\n}\n\n \nu32 sti_vtg_get_line_number(struct drm_display_mode mode, int y)\n{\n\tu32 start_line = mode.vtotal - mode.vsync_start + 1;\n\n\tif (mode.flags & DRM_MODE_FLAG_INTERLACE)\n\t\tstart_line *= 2;\n\n\treturn start_line + y;\n}\n\n \nu32 sti_vtg_get_pixel_number(struct drm_display_mode mode, int x)\n{\n\treturn mode.htotal - mode.hsync_start + x;\n}\n\nint sti_vtg_register_client(struct sti_vtg *vtg, struct notifier_block *nb,\n\t\t\t    struct drm_crtc *crtc)\n{\n\tvtg->crtc = crtc;\n\treturn raw_notifier_chain_register(&vtg->notifier_list, nb);\n}\n\nint sti_vtg_unregister_client(struct sti_vtg *vtg, struct notifier_block *nb)\n{\n\treturn raw_notifier_chain_unregister(&vtg->notifier_list, nb);\n}\n\nstatic irqreturn_t vtg_irq_thread(int irq, void *arg)\n{\n\tstruct sti_vtg *vtg = arg;\n\tu32 event;\n\n\tevent = (vtg->irq_status & VTG_IRQ_TOP) ?\n\t\tVTG_TOP_FIELD_EVENT : VTG_BOTTOM_FIELD_EVENT;\n\n\traw_notifier_call_chain(&vtg->notifier_list, event, vtg->crtc);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic irqreturn_t vtg_irq(int irq, void *arg)\n{\n\tstruct sti_vtg *vtg = arg;\n\n\tvtg->irq_status = readl(vtg->regs + VTG_HOST_ITS);\n\n\twritel(vtg->irq_status, vtg->regs + VTG_HOST_ITS_BCLR);\n\n\t \n\treadl(vtg->regs + VTG_HOST_ITS);\n\n\treturn IRQ_WAKE_THREAD;\n}\n\nstatic int vtg_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct sti_vtg *vtg;\n\tstruct resource *res;\n\tint ret;\n\n\tvtg = devm_kzalloc(dev, sizeof(*vtg), GFP_KERNEL);\n\tif (!vtg)\n\t\treturn -ENOMEM;\n\n\t \n\tres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\n\tif (!res) {\n\t\tDRM_ERROR(\"Get memory resource failed\\n\");\n\t\treturn -ENOMEM;\n\t}\n\tvtg->regs = devm_ioremap(dev, res->start, resource_size(res));\n\tif (!vtg->regs) {\n\t\tDRM_ERROR(\"failed to remap I/O memory\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tvtg->irq = platform_get_irq(pdev, 0);\n\tif (vtg->irq < 0) {\n\t\tDRM_ERROR(\"Failed to get VTG interrupt\\n\");\n\t\treturn vtg->irq;\n\t}\n\n\tRAW_INIT_NOTIFIER_HEAD(&vtg->notifier_list);\n\n\tret = devm_request_threaded_irq(dev, vtg->irq, vtg_irq,\n\t\t\t\t\tvtg_irq_thread, IRQF_ONESHOT,\n\t\t\t\t\tdev_name(dev), vtg);\n\tif (ret < 0) {\n\t\tDRM_ERROR(\"Failed to register VTG interrupt\\n\");\n\t\treturn ret;\n\t}\n\n\tplatform_set_drvdata(pdev, vtg);\n\n\tDRM_INFO(\"%s %s\\n\", __func__, dev_name(dev));\n\n\treturn 0;\n}\n\nstatic const struct of_device_id vtg_of_match[] = {\n\t{ .compatible = \"st,vtg\", },\n\t{   }\n};\nMODULE_DEVICE_TABLE(of, vtg_of_match);\n\nstruct platform_driver sti_vtg_driver = {\n\t.driver = {\n\t\t.name = \"sti-vtg\",\n\t\t.owner = THIS_MODULE,\n\t\t.of_match_table = vtg_of_match,\n\t},\n\t.probe\t= vtg_probe,\n};\n\nMODULE_AUTHOR(\"Benjamin Gaignard <benjamin.gaignard@st.com>\");\nMODULE_DESCRIPTION(\"STMicroelectronics SoC DRM driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}