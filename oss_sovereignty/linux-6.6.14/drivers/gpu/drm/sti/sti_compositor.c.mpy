{
  "module_name": "sti_compositor.c",
  "hash_id": "e203800f28cc8d44efc07e20cc2a76a21ef8706a8469f7d12ea7922ff4cf4251",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/sti/sti_compositor.c",
  "human_readable_source": "\n \n\n#include <linux/component.h>\n#include <linux/io.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/reset.h>\n\n#include <drm/drm_device.h>\n#include <drm/drm_print.h>\n#include <drm/drm_vblank.h>\n\n#include \"sti_compositor.h\"\n#include \"sti_crtc.h\"\n#include \"sti_cursor.h\"\n#include \"sti_drv.h\"\n#include \"sti_gdp.h\"\n#include \"sti_plane.h\"\n#include \"sti_vid.h\"\n#include \"sti_vtg.h\"\n\n \nstatic const struct sti_compositor_data stih407_compositor_data = {\n\t.nb_subdev = 8,\n\t.subdev_desc = {\n\t\t\t{STI_CURSOR_SUBDEV, (int)STI_CURSOR, 0x000},\n\t\t\t{STI_GPD_SUBDEV, (int)STI_GDP_0, 0x100},\n\t\t\t{STI_GPD_SUBDEV, (int)STI_GDP_1, 0x200},\n\t\t\t{STI_GPD_SUBDEV, (int)STI_GDP_2, 0x300},\n\t\t\t{STI_GPD_SUBDEV, (int)STI_GDP_3, 0x400},\n\t\t\t{STI_VID_SUBDEV, (int)STI_HQVDP_0, 0x700},\n\t\t\t{STI_MIXER_MAIN_SUBDEV, STI_MIXER_MAIN, 0xC00},\n\t\t\t{STI_MIXER_AUX_SUBDEV, STI_MIXER_AUX, 0xD00},\n\t},\n};\n\nvoid sti_compositor_debugfs_init(struct sti_compositor *compo,\n\t\t\t\t struct drm_minor *minor)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < STI_MAX_VID; i++)\n\t\tif (compo->vid[i])\n\t\t\tvid_debugfs_init(compo->vid[i], minor);\n\n\tfor (i = 0; i < STI_MAX_MIXER; i++)\n\t\tif (compo->mixer[i])\n\t\t\tsti_mixer_debugfs_init(compo->mixer[i], minor);\n}\n\nstatic int sti_compositor_bind(struct device *dev,\n\t\t\t       struct device *master,\n\t\t\t       void *data)\n{\n\tstruct sti_compositor *compo = dev_get_drvdata(dev);\n\tstruct drm_device *drm_dev = data;\n\tunsigned int i, mixer_id = 0, vid_id = 0, crtc_id = 0;\n\tstruct sti_private *dev_priv = drm_dev->dev_private;\n\tstruct drm_plane *cursor = NULL;\n\tstruct drm_plane *primary = NULL;\n\tstruct sti_compositor_subdev_descriptor *desc = compo->data.subdev_desc;\n\tunsigned int array_size = compo->data.nb_subdev;\n\n\tdev_priv->compo = compo;\n\n\t \n\tfor (i = 0; i < array_size; i++) {\n\t\tswitch (desc[i].type) {\n\t\tcase STI_VID_SUBDEV:\n\t\t\tcompo->vid[vid_id++] =\n\t\t\t    sti_vid_create(compo->dev, drm_dev, desc[i].id,\n\t\t\t\t\t   compo->regs + desc[i].offset);\n\t\t\tbreak;\n\t\tcase STI_MIXER_MAIN_SUBDEV:\n\t\tcase STI_MIXER_AUX_SUBDEV:\n\t\t\tcompo->mixer[mixer_id++] =\n\t\t\t    sti_mixer_create(compo->dev, drm_dev, desc[i].id,\n\t\t\t\t\t     compo->regs + desc[i].offset);\n\t\t\tbreak;\n\t\tcase STI_GPD_SUBDEV:\n\t\tcase STI_CURSOR_SUBDEV:\n\t\t\t \n\t\t\tbreak;\n\t\tdefault:\n\t\t\tDRM_ERROR(\"Unknown subdev component type\\n\");\n\t\t\treturn 1;\n\t\t}\n\t}\n\n\t \n\tfor (i = 0; i < array_size; i++) {\n\t\tenum drm_plane_type plane_type = DRM_PLANE_TYPE_OVERLAY;\n\n\t\tif (crtc_id < mixer_id)\n\t\t\tplane_type = DRM_PLANE_TYPE_PRIMARY;\n\n\t\tswitch (desc[i].type) {\n\t\tcase STI_MIXER_MAIN_SUBDEV:\n\t\tcase STI_MIXER_AUX_SUBDEV:\n\t\tcase STI_VID_SUBDEV:\n\t\t\t \n\t\t\tbreak;\n\t\tcase STI_CURSOR_SUBDEV:\n\t\t\tcursor = sti_cursor_create(drm_dev, compo->dev,\n\t\t\t\t\t\t   desc[i].id,\n\t\t\t\t\t\t   compo->regs + desc[i].offset,\n\t\t\t\t\t\t   1);\n\t\t\tif (!cursor) {\n\t\t\t\tDRM_ERROR(\"Can't create CURSOR plane\\n\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase STI_GPD_SUBDEV:\n\t\t\tprimary = sti_gdp_create(drm_dev, compo->dev,\n\t\t\t\t\t\t desc[i].id,\n\t\t\t\t\t\t compo->regs + desc[i].offset,\n\t\t\t\t\t\t (1 << mixer_id) - 1,\n\t\t\t\t\t\t plane_type);\n\t\t\tif (!primary) {\n\t\t\t\tDRM_ERROR(\"Can't create GDP plane\\n\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tDRM_ERROR(\"Unknown subdev component type\\n\");\n\t\t\treturn 1;\n\t\t}\n\n\t\t \n\t\tif (crtc_id < mixer_id && primary) {\n\t\t\tsti_crtc_init(drm_dev, compo->mixer[crtc_id],\n\t\t\t\t      primary, cursor);\n\t\t\tcrtc_id++;\n\t\t\tcursor = NULL;\n\t\t\tprimary = NULL;\n\t\t}\n\t}\n\n\tdrm_vblank_init(drm_dev, crtc_id);\n\n\treturn 0;\n}\n\nstatic void sti_compositor_unbind(struct device *dev, struct device *master,\n\tvoid *data)\n{\n\t \n}\n\nstatic const struct component_ops sti_compositor_ops = {\n\t.bind\t= sti_compositor_bind,\n\t.unbind\t= sti_compositor_unbind,\n};\n\nstatic const struct of_device_id compositor_of_match[] = {\n\t{\n\t\t.compatible = \"st,stih407-compositor\",\n\t\t.data = &stih407_compositor_data,\n\t}, {\n\t\t \n\t}\n};\nMODULE_DEVICE_TABLE(of, compositor_of_match);\n\nstatic int sti_compositor_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct device_node *np = dev->of_node;\n\tstruct device_node *vtg_np;\n\tstruct sti_compositor *compo;\n\tstruct resource *res;\n\tunsigned int i;\n\n\tcompo = devm_kzalloc(dev, sizeof(*compo), GFP_KERNEL);\n\tif (!compo) {\n\t\tDRM_ERROR(\"Failed to allocate compositor context\\n\");\n\t\treturn -ENOMEM;\n\t}\n\tcompo->dev = dev;\n\tfor (i = 0; i < STI_MAX_MIXER; i++)\n\t\tcompo->vtg_vblank_nb[i].notifier_call = sti_crtc_vblank_cb;\n\n\t \n\tBUG_ON(!of_match_node(compositor_of_match, np)->data);\n\n\tmemcpy(&compo->data, of_match_node(compositor_of_match, np)->data,\n\t       sizeof(struct sti_compositor_data));\n\n\t \n\tres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\n\tif (res == NULL) {\n\t\tDRM_ERROR(\"Get memory resource failed\\n\");\n\t\treturn -ENXIO;\n\t}\n\tcompo->regs = devm_ioremap(dev, res->start, resource_size(res));\n\tif (compo->regs == NULL) {\n\t\tDRM_ERROR(\"Register mapping failed\\n\");\n\t\treturn -ENXIO;\n\t}\n\n\t \n\tcompo->clk_compo_main = devm_clk_get(dev, \"compo_main\");\n\tif (IS_ERR(compo->clk_compo_main)) {\n\t\tDRM_ERROR(\"Cannot get compo_main clock\\n\");\n\t\treturn PTR_ERR(compo->clk_compo_main);\n\t}\n\n\tcompo->clk_compo_aux = devm_clk_get(dev, \"compo_aux\");\n\tif (IS_ERR(compo->clk_compo_aux)) {\n\t\tDRM_ERROR(\"Cannot get compo_aux clock\\n\");\n\t\treturn PTR_ERR(compo->clk_compo_aux);\n\t}\n\n\tcompo->clk_pix_main = devm_clk_get(dev, \"pix_main\");\n\tif (IS_ERR(compo->clk_pix_main)) {\n\t\tDRM_ERROR(\"Cannot get pix_main clock\\n\");\n\t\treturn PTR_ERR(compo->clk_pix_main);\n\t}\n\n\tcompo->clk_pix_aux = devm_clk_get(dev, \"pix_aux\");\n\tif (IS_ERR(compo->clk_pix_aux)) {\n\t\tDRM_ERROR(\"Cannot get pix_aux clock\\n\");\n\t\treturn PTR_ERR(compo->clk_pix_aux);\n\t}\n\n\t \n\tcompo->rst_main = devm_reset_control_get_shared(dev, \"compo-main\");\n\t \n\tif (!IS_ERR(compo->rst_main))\n\t\treset_control_deassert(compo->rst_main);\n\n\tcompo->rst_aux = devm_reset_control_get_shared(dev, \"compo-aux\");\n\t \n\tif (!IS_ERR(compo->rst_aux))\n\t\treset_control_deassert(compo->rst_aux);\n\n\tvtg_np = of_parse_phandle(pdev->dev.of_node, \"st,vtg\", 0);\n\tif (vtg_np)\n\t\tcompo->vtg[STI_MIXER_MAIN] = of_vtg_find(vtg_np);\n\tof_node_put(vtg_np);\n\n\tvtg_np = of_parse_phandle(pdev->dev.of_node, \"st,vtg\", 1);\n\tif (vtg_np)\n\t\tcompo->vtg[STI_MIXER_AUX] = of_vtg_find(vtg_np);\n\tof_node_put(vtg_np);\n\n\tplatform_set_drvdata(pdev, compo);\n\n\treturn component_add(&pdev->dev, &sti_compositor_ops);\n}\n\nstatic void sti_compositor_remove(struct platform_device *pdev)\n{\n\tcomponent_del(&pdev->dev, &sti_compositor_ops);\n}\n\nstruct platform_driver sti_compositor_driver = {\n\t.driver = {\n\t\t.name = \"sti-compositor\",\n\t\t.of_match_table = compositor_of_match,\n\t},\n\t.probe = sti_compositor_probe,\n\t.remove_new = sti_compositor_remove,\n};\n\nMODULE_AUTHOR(\"Benjamin Gaignard <benjamin.gaignard@st.com>\");\nMODULE_DESCRIPTION(\"STMicroelectronics SoC DRM driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}