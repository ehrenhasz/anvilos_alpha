{
  "module_name": "sti_hdmi.c",
  "hash_id": "09e2f3be7b465ccc279bc270af80cbcbed2d9dfa6723c24bfa3cad97127b6131",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/sti/sti_hdmi.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/component.h>\n#include <linux/debugfs.h>\n#include <linux/hdmi.h>\n#include <linux/i2c.h>\n#include <linux/module.h>\n#include <linux/io.h>\n#include <linux/platform_device.h>\n#include <linux/reset.h>\n\n#include <drm/drm_atomic_helper.h>\n#include <drm/drm_bridge.h>\n#include <drm/drm_debugfs.h>\n#include <drm/drm_drv.h>\n#include <drm/drm_edid.h>\n#include <drm/drm_file.h>\n#include <drm/drm_print.h>\n#include <drm/drm_probe_helper.h>\n\n#include <sound/hdmi-codec.h>\n\n#include \"sti_hdmi.h\"\n#include \"sti_hdmi_tx3g4c28phy.h\"\n#include \"sti_vtg.h\"\n\n#define HDMI_CFG                        0x0000\n#define HDMI_INT_EN                     0x0004\n#define HDMI_INT_STA                    0x0008\n#define HDMI_INT_CLR                    0x000C\n#define HDMI_STA                        0x0010\n#define HDMI_ACTIVE_VID_XMIN            0x0100\n#define HDMI_ACTIVE_VID_XMAX            0x0104\n#define HDMI_ACTIVE_VID_YMIN            0x0108\n#define HDMI_ACTIVE_VID_YMAX            0x010C\n#define HDMI_DFLT_CHL0_DAT              0x0110\n#define HDMI_DFLT_CHL1_DAT              0x0114\n#define HDMI_DFLT_CHL2_DAT              0x0118\n#define HDMI_AUDIO_CFG                  0x0200\n#define HDMI_SPDIF_FIFO_STATUS          0x0204\n#define HDMI_SW_DI_1_HEAD_WORD          0x0210\n#define HDMI_SW_DI_1_PKT_WORD0          0x0214\n#define HDMI_SW_DI_1_PKT_WORD1          0x0218\n#define HDMI_SW_DI_1_PKT_WORD2          0x021C\n#define HDMI_SW_DI_1_PKT_WORD3          0x0220\n#define HDMI_SW_DI_1_PKT_WORD4          0x0224\n#define HDMI_SW_DI_1_PKT_WORD5          0x0228\n#define HDMI_SW_DI_1_PKT_WORD6          0x022C\n#define HDMI_SW_DI_CFG                  0x0230\n#define HDMI_SAMPLE_FLAT_MASK           0x0244\n#define HDMI_AUDN                       0x0400\n#define HDMI_AUD_CTS                    0x0404\n#define HDMI_SW_DI_2_HEAD_WORD          0x0600\n#define HDMI_SW_DI_2_PKT_WORD0          0x0604\n#define HDMI_SW_DI_2_PKT_WORD1          0x0608\n#define HDMI_SW_DI_2_PKT_WORD2          0x060C\n#define HDMI_SW_DI_2_PKT_WORD3          0x0610\n#define HDMI_SW_DI_2_PKT_WORD4          0x0614\n#define HDMI_SW_DI_2_PKT_WORD5          0x0618\n#define HDMI_SW_DI_2_PKT_WORD6          0x061C\n#define HDMI_SW_DI_3_HEAD_WORD          0x0620\n#define HDMI_SW_DI_3_PKT_WORD0          0x0624\n#define HDMI_SW_DI_3_PKT_WORD1          0x0628\n#define HDMI_SW_DI_3_PKT_WORD2          0x062C\n#define HDMI_SW_DI_3_PKT_WORD3          0x0630\n#define HDMI_SW_DI_3_PKT_WORD4          0x0634\n#define HDMI_SW_DI_3_PKT_WORD5          0x0638\n#define HDMI_SW_DI_3_PKT_WORD6          0x063C\n\n#define HDMI_IFRAME_SLOT_AVI            1\n#define HDMI_IFRAME_SLOT_AUDIO          2\n#define HDMI_IFRAME_SLOT_VENDOR         3\n\n#define  XCAT(prefix, x, suffix)        prefix ## x ## suffix\n#define  HDMI_SW_DI_N_HEAD_WORD(x)      XCAT(HDMI_SW_DI_, x, _HEAD_WORD)\n#define  HDMI_SW_DI_N_PKT_WORD0(x)      XCAT(HDMI_SW_DI_, x, _PKT_WORD0)\n#define  HDMI_SW_DI_N_PKT_WORD1(x)      XCAT(HDMI_SW_DI_, x, _PKT_WORD1)\n#define  HDMI_SW_DI_N_PKT_WORD2(x)      XCAT(HDMI_SW_DI_, x, _PKT_WORD2)\n#define  HDMI_SW_DI_N_PKT_WORD3(x)      XCAT(HDMI_SW_DI_, x, _PKT_WORD3)\n#define  HDMI_SW_DI_N_PKT_WORD4(x)      XCAT(HDMI_SW_DI_, x, _PKT_WORD4)\n#define  HDMI_SW_DI_N_PKT_WORD5(x)      XCAT(HDMI_SW_DI_, x, _PKT_WORD5)\n#define  HDMI_SW_DI_N_PKT_WORD6(x)      XCAT(HDMI_SW_DI_, x, _PKT_WORD6)\n\n#define HDMI_SW_DI_MAX_WORD             7\n\n#define HDMI_IFRAME_DISABLED            0x0\n#define HDMI_IFRAME_SINGLE_SHOT         0x1\n#define HDMI_IFRAME_FIELD               0x2\n#define HDMI_IFRAME_FRAME               0x3\n#define HDMI_IFRAME_MASK                0x3\n#define HDMI_IFRAME_CFG_DI_N(x, n)       ((x) << ((n-1)*4))  \n\n#define HDMI_CFG_DEVICE_EN              BIT(0)\n#define HDMI_CFG_HDMI_NOT_DVI           BIT(1)\n#define HDMI_CFG_HDCP_EN                BIT(2)\n#define HDMI_CFG_ESS_NOT_OESS           BIT(3)\n#define HDMI_CFG_H_SYNC_POL_NEG         BIT(4)\n#define HDMI_CFG_V_SYNC_POL_NEG         BIT(6)\n#define HDMI_CFG_422_EN                 BIT(8)\n#define HDMI_CFG_FIFO_OVERRUN_CLR       BIT(12)\n#define HDMI_CFG_FIFO_UNDERRUN_CLR      BIT(13)\n#define HDMI_CFG_SW_RST_EN              BIT(31)\n\n#define HDMI_INT_GLOBAL                 BIT(0)\n#define HDMI_INT_SW_RST                 BIT(1)\n#define HDMI_INT_PIX_CAP                BIT(3)\n#define HDMI_INT_HOT_PLUG               BIT(4)\n#define HDMI_INT_DLL_LCK                BIT(5)\n#define HDMI_INT_NEW_FRAME              BIT(6)\n#define HDMI_INT_GENCTRL_PKT            BIT(7)\n#define HDMI_INT_AUDIO_FIFO_XRUN        BIT(8)\n#define HDMI_INT_SINK_TERM_PRESENT      BIT(11)\n\n#define HDMI_DEFAULT_INT (HDMI_INT_SINK_TERM_PRESENT \\\n\t\t\t| HDMI_INT_DLL_LCK \\\n\t\t\t| HDMI_INT_HOT_PLUG \\\n\t\t\t| HDMI_INT_GLOBAL)\n\n#define HDMI_WORKING_INT (HDMI_INT_SINK_TERM_PRESENT \\\n\t\t\t| HDMI_INT_AUDIO_FIFO_XRUN \\\n\t\t\t| HDMI_INT_GENCTRL_PKT \\\n\t\t\t| HDMI_INT_NEW_FRAME \\\n\t\t\t| HDMI_INT_DLL_LCK \\\n\t\t\t| HDMI_INT_HOT_PLUG \\\n\t\t\t| HDMI_INT_PIX_CAP \\\n\t\t\t| HDMI_INT_SW_RST \\\n\t\t\t| HDMI_INT_GLOBAL)\n\n#define HDMI_STA_SW_RST                 BIT(1)\n\n#define HDMI_AUD_CFG_8CH\t\tBIT(0)\n#define HDMI_AUD_CFG_SPDIF_DIV_2\tBIT(1)\n#define HDMI_AUD_CFG_SPDIF_DIV_3\tBIT(2)\n#define HDMI_AUD_CFG_SPDIF_CLK_DIV_4\t(BIT(1) | BIT(2))\n#define HDMI_AUD_CFG_CTS_CLK_256FS\tBIT(12)\n#define HDMI_AUD_CFG_DTS_INVALID\tBIT(16)\n#define HDMI_AUD_CFG_ONE_BIT_INVALID\t(BIT(18) | BIT(19) | BIT(20) |  BIT(21))\n#define HDMI_AUD_CFG_CH12_VALID\tBIT(28)\n#define HDMI_AUD_CFG_CH34_VALID\tBIT(29)\n#define HDMI_AUD_CFG_CH56_VALID\tBIT(30)\n#define HDMI_AUD_CFG_CH78_VALID\tBIT(31)\n\n \n#define HDMI_SAMPLE_FLAT_NO\t 0\n#define HDMI_SAMPLE_FLAT_SP0 BIT(0)\n#define HDMI_SAMPLE_FLAT_SP1 BIT(1)\n#define HDMI_SAMPLE_FLAT_SP2 BIT(2)\n#define HDMI_SAMPLE_FLAT_SP3 BIT(3)\n#define HDMI_SAMPLE_FLAT_ALL (HDMI_SAMPLE_FLAT_SP0 | HDMI_SAMPLE_FLAT_SP1 |\\\n\t\t\t      HDMI_SAMPLE_FLAT_SP2 | HDMI_SAMPLE_FLAT_SP3)\n\n#define HDMI_INFOFRAME_HEADER_TYPE(x)    (((x) & 0xff) <<  0)\n#define HDMI_INFOFRAME_HEADER_VERSION(x) (((x) & 0xff) <<  8)\n#define HDMI_INFOFRAME_HEADER_LEN(x)     (((x) & 0x0f) << 16)\n\nstruct sti_hdmi_connector {\n\tstruct drm_connector drm_connector;\n\tstruct drm_encoder *encoder;\n\tstruct sti_hdmi *hdmi;\n\tstruct drm_property *colorspace_property;\n};\n\n#define to_sti_hdmi_connector(x) \\\n\tcontainer_of(x, struct sti_hdmi_connector, drm_connector)\n\nstatic const struct drm_prop_enum_list colorspace_mode_names[] = {\n\t{ HDMI_COLORSPACE_RGB, \"rgb\" },\n\t{ HDMI_COLORSPACE_YUV422, \"yuv422\" },\n\t{ HDMI_COLORSPACE_YUV444, \"yuv444\" },\n};\n\nu32 hdmi_read(struct sti_hdmi *hdmi, int offset)\n{\n\treturn readl(hdmi->regs + offset);\n}\n\nvoid hdmi_write(struct sti_hdmi *hdmi, u32 val, int offset)\n{\n\twritel(val, hdmi->regs + offset);\n}\n\n \nstatic irqreturn_t hdmi_irq_thread(int irq, void *arg)\n{\n\tstruct sti_hdmi *hdmi = arg;\n\n\t \n\tif (hdmi->irq_status & HDMI_INT_HOT_PLUG) {\n\t\thdmi->hpd = readl(hdmi->regs + HDMI_STA) & HDMI_STA_HOT_PLUG;\n\t\tif (hdmi->drm_dev)\n\t\t\tdrm_helper_hpd_irq_event(hdmi->drm_dev);\n\t}\n\n\t \n\tif (hdmi->irq_status & (HDMI_INT_SW_RST | HDMI_INT_DLL_LCK)) {\n\t\thdmi->event_received = true;\n\t\twake_up_interruptible(&hdmi->wait_event);\n\t}\n\n\t \n\tif (hdmi->irq_status & HDMI_INT_AUDIO_FIFO_XRUN)\n\t\tDRM_INFO(\"Warning: audio FIFO underrun occurs!\\n\");\n\n\treturn IRQ_HANDLED;\n}\n\n \nstatic irqreturn_t hdmi_irq(int irq, void *arg)\n{\n\tstruct sti_hdmi *hdmi = arg;\n\n\t \n\thdmi->irq_status = hdmi_read(hdmi, HDMI_INT_STA);\n\n\t \n\thdmi_write(hdmi, hdmi->irq_status, HDMI_INT_CLR);\n\n\t \n\thdmi_read(hdmi, HDMI_INT_STA);\n\n\treturn IRQ_WAKE_THREAD;\n}\n\n \nstatic void hdmi_active_area(struct sti_hdmi *hdmi)\n{\n\tu32 xmin, xmax;\n\tu32 ymin, ymax;\n\n\txmin = sti_vtg_get_pixel_number(hdmi->mode, 1);\n\txmax = sti_vtg_get_pixel_number(hdmi->mode, hdmi->mode.hdisplay);\n\tymin = sti_vtg_get_line_number(hdmi->mode, 0);\n\tymax = sti_vtg_get_line_number(hdmi->mode, hdmi->mode.vdisplay - 1);\n\n\thdmi_write(hdmi, xmin, HDMI_ACTIVE_VID_XMIN);\n\thdmi_write(hdmi, xmax, HDMI_ACTIVE_VID_XMAX);\n\thdmi_write(hdmi, ymin, HDMI_ACTIVE_VID_YMIN);\n\thdmi_write(hdmi, ymax, HDMI_ACTIVE_VID_YMAX);\n}\n\n \nstatic void hdmi_config(struct sti_hdmi *hdmi)\n{\n\tstruct drm_connector *connector = hdmi->drm_connector;\n\tu32 conf;\n\n\tDRM_DEBUG_DRIVER(\"\\n\");\n\n\t \n\tconf = HDMI_CFG_FIFO_OVERRUN_CLR | HDMI_CFG_FIFO_UNDERRUN_CLR;\n\n\t \n\tconf |= HDMI_CFG_ESS_NOT_OESS;\n\tif (connector->display_info.is_hdmi)\n\t\tconf |= HDMI_CFG_HDMI_NOT_DVI;\n\n\t \n\tif (hdmi->mode.flags & DRM_MODE_FLAG_NHSYNC) {\n\t\tDRM_DEBUG_DRIVER(\"H Sync Negative\\n\");\n\t\tconf |= HDMI_CFG_H_SYNC_POL_NEG;\n\t}\n\n\t \n\tif (hdmi->mode.flags & DRM_MODE_FLAG_NVSYNC) {\n\t\tDRM_DEBUG_DRIVER(\"V Sync Negative\\n\");\n\t\tconf |= HDMI_CFG_V_SYNC_POL_NEG;\n\t}\n\n\t \n\tconf |= HDMI_CFG_DEVICE_EN;\n\n\thdmi_write(hdmi, conf, HDMI_CFG);\n}\n\n \nstatic void hdmi_infoframe_reset(struct sti_hdmi *hdmi,\n\t\t\t\t u32 slot)\n{\n\tu32 val, i;\n\tu32 head_offset, pack_offset;\n\n\tswitch (slot) {\n\tcase HDMI_IFRAME_SLOT_AVI:\n\t\thead_offset = HDMI_SW_DI_N_HEAD_WORD(HDMI_IFRAME_SLOT_AVI);\n\t\tpack_offset = HDMI_SW_DI_N_PKT_WORD0(HDMI_IFRAME_SLOT_AVI);\n\t\tbreak;\n\tcase HDMI_IFRAME_SLOT_AUDIO:\n\t\thead_offset = HDMI_SW_DI_N_HEAD_WORD(HDMI_IFRAME_SLOT_AUDIO);\n\t\tpack_offset = HDMI_SW_DI_N_PKT_WORD0(HDMI_IFRAME_SLOT_AUDIO);\n\t\tbreak;\n\tcase HDMI_IFRAME_SLOT_VENDOR:\n\t\thead_offset = HDMI_SW_DI_N_HEAD_WORD(HDMI_IFRAME_SLOT_VENDOR);\n\t\tpack_offset = HDMI_SW_DI_N_PKT_WORD0(HDMI_IFRAME_SLOT_VENDOR);\n\t\tbreak;\n\tdefault:\n\t\tDRM_ERROR(\"unsupported infoframe slot: %#x\\n\", slot);\n\t\treturn;\n\t}\n\n\t \n\tval = hdmi_read(hdmi, HDMI_SW_DI_CFG);\n\tval &= ~HDMI_IFRAME_CFG_DI_N(HDMI_IFRAME_MASK, slot);\n\thdmi_write(hdmi, val, HDMI_SW_DI_CFG);\n\n\t \n\thdmi_write(hdmi, 0x0, head_offset);\n\tfor (i = 0; i < HDMI_SW_DI_MAX_WORD; i += sizeof(u32))\n\t\thdmi_write(hdmi, 0x0, pack_offset + i);\n}\n\n \nstatic inline unsigned int hdmi_infoframe_subpack(const u8 *ptr, size_t size)\n{\n\tunsigned long value = 0;\n\tsize_t i;\n\n\tfor (i = size; i > 0; i--)\n\t\tvalue = (value << 8) | ptr[i - 1];\n\n\treturn value;\n}\n\n \nstatic void hdmi_infoframe_write_infopack(struct sti_hdmi *hdmi,\n\t\t\t\t\t  const u8 *data,\n\t\t\t\t\t  size_t size)\n{\n\tconst u8 *ptr = data;\n\tu32 val, slot, mode, i;\n\tu32 head_offset, pack_offset;\n\n\tswitch (*ptr) {\n\tcase HDMI_INFOFRAME_TYPE_AVI:\n\t\tslot = HDMI_IFRAME_SLOT_AVI;\n\t\tmode = HDMI_IFRAME_FIELD;\n\t\thead_offset = HDMI_SW_DI_N_HEAD_WORD(HDMI_IFRAME_SLOT_AVI);\n\t\tpack_offset = HDMI_SW_DI_N_PKT_WORD0(HDMI_IFRAME_SLOT_AVI);\n\t\tbreak;\n\tcase HDMI_INFOFRAME_TYPE_AUDIO:\n\t\tslot = HDMI_IFRAME_SLOT_AUDIO;\n\t\tmode = HDMI_IFRAME_FRAME;\n\t\thead_offset = HDMI_SW_DI_N_HEAD_WORD(HDMI_IFRAME_SLOT_AUDIO);\n\t\tpack_offset = HDMI_SW_DI_N_PKT_WORD0(HDMI_IFRAME_SLOT_AUDIO);\n\t\tbreak;\n\tcase HDMI_INFOFRAME_TYPE_VENDOR:\n\t\tslot = HDMI_IFRAME_SLOT_VENDOR;\n\t\tmode = HDMI_IFRAME_FRAME;\n\t\thead_offset = HDMI_SW_DI_N_HEAD_WORD(HDMI_IFRAME_SLOT_VENDOR);\n\t\tpack_offset = HDMI_SW_DI_N_PKT_WORD0(HDMI_IFRAME_SLOT_VENDOR);\n\t\tbreak;\n\tdefault:\n\t\tDRM_ERROR(\"unsupported infoframe type: %#x\\n\", *ptr);\n\t\treturn;\n\t}\n\n\t \n\tval = hdmi_read(hdmi, HDMI_SW_DI_CFG);\n\tval &= ~HDMI_IFRAME_CFG_DI_N(HDMI_IFRAME_MASK, slot);\n\thdmi_write(hdmi, val, HDMI_SW_DI_CFG);\n\n\tval = HDMI_INFOFRAME_HEADER_TYPE(*ptr++);\n\tval |= HDMI_INFOFRAME_HEADER_VERSION(*ptr++);\n\tval |= HDMI_INFOFRAME_HEADER_LEN(*ptr++);\n\twritel(val, hdmi->regs + head_offset);\n\n\t \n\tsize = size - HDMI_INFOFRAME_HEADER_SIZE + 1;\n\tfor (i = 0; i < size; i += sizeof(u32)) {\n\t\tsize_t num;\n\n\t\tnum = min_t(size_t, size - i, sizeof(u32));\n\t\tval = hdmi_infoframe_subpack(ptr, num);\n\t\tptr += sizeof(u32);\n\t\twritel(val, hdmi->regs + pack_offset + i);\n\t}\n\n\t \n\tval = hdmi_read(hdmi, HDMI_SW_DI_CFG);\n\tval |= HDMI_IFRAME_CFG_DI_N(mode, slot);\n\thdmi_write(hdmi, val, HDMI_SW_DI_CFG);\n}\n\n \nstatic int hdmi_avi_infoframe_config(struct sti_hdmi *hdmi)\n{\n\tstruct drm_display_mode *mode = &hdmi->mode;\n\tstruct hdmi_avi_infoframe infoframe;\n\tu8 buffer[HDMI_INFOFRAME_SIZE(AVI)];\n\tint ret;\n\n\tDRM_DEBUG_DRIVER(\"\\n\");\n\n\tret = drm_hdmi_avi_infoframe_from_display_mode(&infoframe,\n\t\t\t\t\t\t       hdmi->drm_connector, mode);\n\tif (ret < 0) {\n\t\tDRM_ERROR(\"failed to setup AVI infoframe: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\t \n\tinfoframe.colorspace = hdmi->colorspace;\n\tinfoframe.quantization_range = HDMI_QUANTIZATION_RANGE_DEFAULT;\n\tinfoframe.colorimetry = HDMI_COLORIMETRY_NONE;\n\n\tret = hdmi_avi_infoframe_pack(&infoframe, buffer, sizeof(buffer));\n\tif (ret < 0) {\n\t\tDRM_ERROR(\"failed to pack AVI infoframe: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\thdmi_infoframe_write_infopack(hdmi, buffer, ret);\n\n\treturn 0;\n}\n\n \nstatic int hdmi_audio_infoframe_config(struct sti_hdmi *hdmi)\n{\n\tstruct hdmi_audio_params *audio = &hdmi->audio;\n\tu8 buffer[HDMI_INFOFRAME_SIZE(AUDIO)];\n\tint ret, val;\n\n\tDRM_DEBUG_DRIVER(\"enter %s, AIF %s\\n\", __func__,\n\t\t\t audio->enabled ? \"enable\" : \"disable\");\n\tif (audio->enabled) {\n\t\t \n\t\tret = hdmi_audio_infoframe_pack(&audio->cea, buffer,\n\t\t\t\t\t\tsizeof(buffer));\n\t\tif (ret < 0) {\n\t\t\tDRM_ERROR(\"failed to pack audio infoframe: %d\\n\", ret);\n\t\t\treturn ret;\n\t\t}\n\t\thdmi_infoframe_write_infopack(hdmi, buffer, ret);\n\t} else {\n\t\t \n\t\tval = hdmi_read(hdmi, HDMI_SW_DI_CFG);\n\t\tval &= ~HDMI_IFRAME_CFG_DI_N(HDMI_IFRAME_MASK,\n\t\t\t\t\t     HDMI_IFRAME_SLOT_AUDIO);\n\t\thdmi_write(hdmi, val, HDMI_SW_DI_CFG);\n\t}\n\n\treturn 0;\n}\n\n \n#define HDMI_VENDOR_INFOFRAME_MAX_SIZE 6\nstatic int hdmi_vendor_infoframe_config(struct sti_hdmi *hdmi)\n{\n\tstruct drm_display_mode *mode = &hdmi->mode;\n\tstruct hdmi_vendor_infoframe infoframe;\n\tu8 buffer[HDMI_INFOFRAME_HEADER_SIZE + HDMI_VENDOR_INFOFRAME_MAX_SIZE];\n\tint ret;\n\n\tDRM_DEBUG_DRIVER(\"\\n\");\n\n\tret = drm_hdmi_vendor_infoframe_from_display_mode(&infoframe,\n\t\t\t\t\t\t\t  hdmi->drm_connector,\n\t\t\t\t\t\t\t  mode);\n\tif (ret < 0) {\n\t\t \n\t\treturn 0;\n\t}\n\n\tret = hdmi_vendor_infoframe_pack(&infoframe, buffer, sizeof(buffer));\n\tif (ret < 0) {\n\t\tDRM_ERROR(\"failed to pack VS infoframe: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\thdmi_infoframe_write_infopack(hdmi, buffer, ret);\n\n\treturn 0;\n}\n\n#define HDMI_TIMEOUT_SWRESET  100    \n\n \nstatic void hdmi_swreset(struct sti_hdmi *hdmi)\n{\n\tu32 val;\n\n\tDRM_DEBUG_DRIVER(\"\\n\");\n\n\t \n\tif (clk_prepare_enable(hdmi->clk_audio))\n\t\tDRM_INFO(\"Failed to prepare/enable hdmi_audio clk\\n\");\n\n\t \n\thdmi->event_received = false;\n\n\tval = hdmi_read(hdmi, HDMI_CFG);\n\tval |= HDMI_CFG_SW_RST_EN;\n\thdmi_write(hdmi, val, HDMI_CFG);\n\n\t \n\twait_event_interruptible_timeout(hdmi->wait_event,\n\t\t\t\t\t hdmi->event_received,\n\t\t\t\t\t msecs_to_jiffies\n\t\t\t\t\t (HDMI_TIMEOUT_SWRESET));\n\n\t \n\tif ((hdmi_read(hdmi, HDMI_STA) & HDMI_STA_SW_RST) == 0)\n\t\tDRM_DEBUG_DRIVER(\"Warning: HDMI sw reset timeout occurs\\n\");\n\n\tval = hdmi_read(hdmi, HDMI_CFG);\n\tval &= ~HDMI_CFG_SW_RST_EN;\n\thdmi_write(hdmi, val, HDMI_CFG);\n\n\t \n\tclk_disable_unprepare(hdmi->clk_audio);\n}\n\n#define DBGFS_PRINT_STR(str1, str2) seq_printf(s, \"%-24s %s\\n\", str1, str2)\n#define DBGFS_PRINT_INT(str1, int2) seq_printf(s, \"%-24s %d\\n\", str1, int2)\n#define DBGFS_DUMP(str, reg) seq_printf(s, \"%s  %-25s 0x%08X\", str, #reg, \\\n\t\t\t\t\thdmi_read(hdmi, reg))\n#define DBGFS_DUMP_DI(reg, slot) DBGFS_DUMP(\"\\n\", reg(slot))\n\nstatic void hdmi_dbg_cfg(struct seq_file *s, int val)\n{\n\tint tmp;\n\n\tseq_putc(s, '\\t');\n\ttmp = val & HDMI_CFG_HDMI_NOT_DVI;\n\tDBGFS_PRINT_STR(\"mode:\", tmp ? \"HDMI\" : \"DVI\");\n\tseq_puts(s, \"\\t\\t\\t\\t\\t\");\n\ttmp = val & HDMI_CFG_HDCP_EN;\n\tDBGFS_PRINT_STR(\"HDCP:\", tmp ? \"enable\" : \"disable\");\n\tseq_puts(s, \"\\t\\t\\t\\t\\t\");\n\ttmp = val & HDMI_CFG_ESS_NOT_OESS;\n\tDBGFS_PRINT_STR(\"HDCP mode:\", tmp ? \"ESS enable\" : \"OESS enable\");\n\tseq_puts(s, \"\\t\\t\\t\\t\\t\");\n\ttmp = val & HDMI_CFG_H_SYNC_POL_NEG;\n\tDBGFS_PRINT_STR(\"Hsync polarity:\", tmp ? \"inverted\" : \"normal\");\n\tseq_puts(s, \"\\t\\t\\t\\t\\t\");\n\ttmp = val & HDMI_CFG_V_SYNC_POL_NEG;\n\tDBGFS_PRINT_STR(\"Vsync polarity:\", tmp ? \"inverted\" : \"normal\");\n\tseq_puts(s, \"\\t\\t\\t\\t\\t\");\n\ttmp = val & HDMI_CFG_422_EN;\n\tDBGFS_PRINT_STR(\"YUV422 format:\", tmp ? \"enable\" : \"disable\");\n}\n\nstatic void hdmi_dbg_sta(struct seq_file *s, int val)\n{\n\tint tmp;\n\n\tseq_putc(s, '\\t');\n\ttmp = (val & HDMI_STA_DLL_LCK);\n\tDBGFS_PRINT_STR(\"pll:\", tmp ? \"locked\" : \"not locked\");\n\tseq_puts(s, \"\\t\\t\\t\\t\\t\");\n\ttmp = (val & HDMI_STA_HOT_PLUG);\n\tDBGFS_PRINT_STR(\"hdmi cable:\", tmp ? \"connected\" : \"not connected\");\n}\n\nstatic void hdmi_dbg_sw_di_cfg(struct seq_file *s, int val)\n{\n\tint tmp;\n\tchar *const en_di[] = {\"no transmission\",\n\t\t\t       \"single transmission\",\n\t\t\t       \"once every field\",\n\t\t\t       \"once every frame\"};\n\n\tseq_putc(s, '\\t');\n\ttmp = (val & HDMI_IFRAME_CFG_DI_N(HDMI_IFRAME_MASK, 1));\n\tDBGFS_PRINT_STR(\"Data island 1:\", en_di[tmp]);\n\tseq_puts(s, \"\\t\\t\\t\\t\\t\");\n\ttmp = (val & HDMI_IFRAME_CFG_DI_N(HDMI_IFRAME_MASK, 2)) >> 4;\n\tDBGFS_PRINT_STR(\"Data island 2:\", en_di[tmp]);\n\tseq_puts(s, \"\\t\\t\\t\\t\\t\");\n\ttmp = (val & HDMI_IFRAME_CFG_DI_N(HDMI_IFRAME_MASK, 3)) >> 8;\n\tDBGFS_PRINT_STR(\"Data island 3:\", en_di[tmp]);\n\tseq_puts(s, \"\\t\\t\\t\\t\\t\");\n\ttmp = (val & HDMI_IFRAME_CFG_DI_N(HDMI_IFRAME_MASK, 4)) >> 12;\n\tDBGFS_PRINT_STR(\"Data island 4:\", en_di[tmp]);\n\tseq_puts(s, \"\\t\\t\\t\\t\\t\");\n\ttmp = (val & HDMI_IFRAME_CFG_DI_N(HDMI_IFRAME_MASK, 5)) >> 16;\n\tDBGFS_PRINT_STR(\"Data island 5:\", en_di[tmp]);\n\tseq_puts(s, \"\\t\\t\\t\\t\\t\");\n\ttmp = (val & HDMI_IFRAME_CFG_DI_N(HDMI_IFRAME_MASK, 6)) >> 20;\n\tDBGFS_PRINT_STR(\"Data island 6:\", en_di[tmp]);\n}\n\nstatic int hdmi_dbg_show(struct seq_file *s, void *data)\n{\n\tstruct drm_info_node *node = s->private;\n\tstruct sti_hdmi *hdmi = (struct sti_hdmi *)node->info_ent->data;\n\n\tseq_printf(s, \"HDMI: (vaddr = 0x%p)\", hdmi->regs);\n\tDBGFS_DUMP(\"\\n\", HDMI_CFG);\n\thdmi_dbg_cfg(s, hdmi_read(hdmi, HDMI_CFG));\n\tDBGFS_DUMP(\"\", HDMI_INT_EN);\n\tDBGFS_DUMP(\"\\n\", HDMI_STA);\n\thdmi_dbg_sta(s, hdmi_read(hdmi, HDMI_STA));\n\tDBGFS_DUMP(\"\", HDMI_ACTIVE_VID_XMIN);\n\tseq_putc(s, '\\t');\n\tDBGFS_PRINT_INT(\"Xmin:\", hdmi_read(hdmi, HDMI_ACTIVE_VID_XMIN));\n\tDBGFS_DUMP(\"\", HDMI_ACTIVE_VID_XMAX);\n\tseq_putc(s, '\\t');\n\tDBGFS_PRINT_INT(\"Xmax:\", hdmi_read(hdmi, HDMI_ACTIVE_VID_XMAX));\n\tDBGFS_DUMP(\"\", HDMI_ACTIVE_VID_YMIN);\n\tseq_putc(s, '\\t');\n\tDBGFS_PRINT_INT(\"Ymin:\", hdmi_read(hdmi, HDMI_ACTIVE_VID_YMIN));\n\tDBGFS_DUMP(\"\", HDMI_ACTIVE_VID_YMAX);\n\tseq_putc(s, '\\t');\n\tDBGFS_PRINT_INT(\"Ymax:\", hdmi_read(hdmi, HDMI_ACTIVE_VID_YMAX));\n\tDBGFS_DUMP(\"\", HDMI_SW_DI_CFG);\n\thdmi_dbg_sw_di_cfg(s, hdmi_read(hdmi, HDMI_SW_DI_CFG));\n\n\tDBGFS_DUMP(\"\\n\", HDMI_AUDIO_CFG);\n\tDBGFS_DUMP(\"\\n\", HDMI_SPDIF_FIFO_STATUS);\n\tDBGFS_DUMP(\"\\n\", HDMI_AUDN);\n\n\tseq_printf(s, \"\\n AVI Infoframe (Data Island slot N=%d):\",\n\t\t   HDMI_IFRAME_SLOT_AVI);\n\tDBGFS_DUMP_DI(HDMI_SW_DI_N_HEAD_WORD, HDMI_IFRAME_SLOT_AVI);\n\tDBGFS_DUMP_DI(HDMI_SW_DI_N_PKT_WORD0, HDMI_IFRAME_SLOT_AVI);\n\tDBGFS_DUMP_DI(HDMI_SW_DI_N_PKT_WORD1, HDMI_IFRAME_SLOT_AVI);\n\tDBGFS_DUMP_DI(HDMI_SW_DI_N_PKT_WORD2, HDMI_IFRAME_SLOT_AVI);\n\tDBGFS_DUMP_DI(HDMI_SW_DI_N_PKT_WORD3, HDMI_IFRAME_SLOT_AVI);\n\tDBGFS_DUMP_DI(HDMI_SW_DI_N_PKT_WORD4, HDMI_IFRAME_SLOT_AVI);\n\tDBGFS_DUMP_DI(HDMI_SW_DI_N_PKT_WORD5, HDMI_IFRAME_SLOT_AVI);\n\tDBGFS_DUMP_DI(HDMI_SW_DI_N_PKT_WORD6, HDMI_IFRAME_SLOT_AVI);\n\tseq_printf(s, \"\\n\\n AUDIO Infoframe (Data Island slot N=%d):\",\n\t\t   HDMI_IFRAME_SLOT_AUDIO);\n\tDBGFS_DUMP_DI(HDMI_SW_DI_N_HEAD_WORD, HDMI_IFRAME_SLOT_AUDIO);\n\tDBGFS_DUMP_DI(HDMI_SW_DI_N_PKT_WORD0, HDMI_IFRAME_SLOT_AUDIO);\n\tDBGFS_DUMP_DI(HDMI_SW_DI_N_PKT_WORD1, HDMI_IFRAME_SLOT_AUDIO);\n\tDBGFS_DUMP_DI(HDMI_SW_DI_N_PKT_WORD2, HDMI_IFRAME_SLOT_AUDIO);\n\tDBGFS_DUMP_DI(HDMI_SW_DI_N_PKT_WORD3, HDMI_IFRAME_SLOT_AUDIO);\n\tDBGFS_DUMP_DI(HDMI_SW_DI_N_PKT_WORD4, HDMI_IFRAME_SLOT_AUDIO);\n\tDBGFS_DUMP_DI(HDMI_SW_DI_N_PKT_WORD5, HDMI_IFRAME_SLOT_AUDIO);\n\tDBGFS_DUMP_DI(HDMI_SW_DI_N_PKT_WORD6, HDMI_IFRAME_SLOT_AUDIO);\n\tseq_printf(s, \"\\n\\n VENDOR SPECIFIC Infoframe (Data Island slot N=%d):\",\n\t\t   HDMI_IFRAME_SLOT_VENDOR);\n\tDBGFS_DUMP_DI(HDMI_SW_DI_N_HEAD_WORD, HDMI_IFRAME_SLOT_VENDOR);\n\tDBGFS_DUMP_DI(HDMI_SW_DI_N_PKT_WORD0, HDMI_IFRAME_SLOT_VENDOR);\n\tDBGFS_DUMP_DI(HDMI_SW_DI_N_PKT_WORD1, HDMI_IFRAME_SLOT_VENDOR);\n\tDBGFS_DUMP_DI(HDMI_SW_DI_N_PKT_WORD2, HDMI_IFRAME_SLOT_VENDOR);\n\tDBGFS_DUMP_DI(HDMI_SW_DI_N_PKT_WORD3, HDMI_IFRAME_SLOT_VENDOR);\n\tDBGFS_DUMP_DI(HDMI_SW_DI_N_PKT_WORD4, HDMI_IFRAME_SLOT_VENDOR);\n\tDBGFS_DUMP_DI(HDMI_SW_DI_N_PKT_WORD5, HDMI_IFRAME_SLOT_VENDOR);\n\tDBGFS_DUMP_DI(HDMI_SW_DI_N_PKT_WORD6, HDMI_IFRAME_SLOT_VENDOR);\n\tseq_putc(s, '\\n');\n\treturn 0;\n}\n\nstatic struct drm_info_list hdmi_debugfs_files[] = {\n\t{ \"hdmi\", hdmi_dbg_show, 0, NULL },\n};\n\nstatic void hdmi_debugfs_init(struct sti_hdmi *hdmi, struct drm_minor *minor)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < ARRAY_SIZE(hdmi_debugfs_files); i++)\n\t\thdmi_debugfs_files[i].data = hdmi;\n\n\tdrm_debugfs_create_files(hdmi_debugfs_files,\n\t\t\t\t ARRAY_SIZE(hdmi_debugfs_files),\n\t\t\t\t minor->debugfs_root, minor);\n}\n\nstatic void sti_hdmi_disable(struct drm_bridge *bridge)\n{\n\tstruct sti_hdmi *hdmi = bridge->driver_private;\n\n\tu32 val = hdmi_read(hdmi, HDMI_CFG);\n\n\tif (!hdmi->enabled)\n\t\treturn;\n\n\tDRM_DEBUG_DRIVER(\"\\n\");\n\n\t \n\tval &= ~HDMI_CFG_DEVICE_EN;\n\thdmi_write(hdmi, val, HDMI_CFG);\n\n\thdmi_write(hdmi, 0xffffffff, HDMI_INT_CLR);\n\n\t \n\thdmi->phy_ops->stop(hdmi);\n\n\t \n\thdmi_infoframe_reset(hdmi, HDMI_IFRAME_SLOT_AVI);\n\thdmi_infoframe_reset(hdmi, HDMI_IFRAME_SLOT_AUDIO);\n\thdmi_infoframe_reset(hdmi, HDMI_IFRAME_SLOT_VENDOR);\n\n\t \n\thdmi_write(hdmi, 0x0000, HDMI_DFLT_CHL0_DAT);\n\thdmi_write(hdmi, 0x0000, HDMI_DFLT_CHL1_DAT);\n\thdmi_write(hdmi, 0x0060, HDMI_DFLT_CHL2_DAT);\n\n\t \n\tclk_disable_unprepare(hdmi->clk_phy);\n\tclk_disable_unprepare(hdmi->clk_tmds);\n\tclk_disable_unprepare(hdmi->clk_pix);\n\n\thdmi->enabled = false;\n\n\tcec_notifier_set_phys_addr(hdmi->notifier, CEC_PHYS_ADDR_INVALID);\n}\n\n \nstatic int sti_hdmi_audio_get_non_coherent_n(unsigned int audio_fs)\n{\n\tunsigned int n;\n\n\tswitch (audio_fs) {\n\tcase 32000:\n\t\tn = 4096;\n\t\tbreak;\n\tcase 44100:\n\t\tn = 6272;\n\t\tbreak;\n\tcase 48000:\n\t\tn = 6144;\n\t\tbreak;\n\tcase 88200:\n\t\tn = 6272 * 2;\n\t\tbreak;\n\tcase 96000:\n\t\tn = 6144 * 2;\n\t\tbreak;\n\tcase 176400:\n\t\tn = 6272 * 4;\n\t\tbreak;\n\tcase 192000:\n\t\tn = 6144 * 4;\n\t\tbreak;\n\tdefault:\n\t\t \n\t\tn = (audio_fs * 128) / 1000;\n\t}\n\n\treturn n;\n}\n\nstatic int hdmi_audio_configure(struct sti_hdmi *hdmi)\n{\n\tint audio_cfg, n;\n\tstruct hdmi_audio_params *params = &hdmi->audio;\n\tstruct hdmi_audio_infoframe *info = &params->cea;\n\n\tDRM_DEBUG_DRIVER(\"\\n\");\n\n\tif (!hdmi->enabled)\n\t\treturn 0;\n\n\t \n\tn = sti_hdmi_audio_get_non_coherent_n(params->sample_rate);\n\n\tDRM_DEBUG_DRIVER(\"Audio rate = %d Hz, TMDS clock = %d Hz, n = %d\\n\",\n\t\t\t params->sample_rate, hdmi->mode.clock * 1000, n);\n\thdmi_write(hdmi, n, HDMI_AUDN);\n\n\t \n\taudio_cfg = HDMI_AUD_CFG_SPDIF_DIV_2 | HDMI_AUD_CFG_DTS_INVALID |\n\t\t    HDMI_AUD_CFG_ONE_BIT_INVALID;\n\n\tswitch (info->channels) {\n\tcase 8:\n\t\taudio_cfg |= HDMI_AUD_CFG_CH78_VALID;\n\t\tfallthrough;\n\tcase 6:\n\t\taudio_cfg |= HDMI_AUD_CFG_CH56_VALID;\n\t\tfallthrough;\n\tcase 4:\n\t\taudio_cfg |= HDMI_AUD_CFG_CH34_VALID | HDMI_AUD_CFG_8CH;\n\t\tfallthrough;\n\tcase 2:\n\t\taudio_cfg |= HDMI_AUD_CFG_CH12_VALID;\n\t\tbreak;\n\tdefault:\n\t\tDRM_ERROR(\"ERROR: Unsupported number of channels (%d)!\\n\",\n\t\t\t  info->channels);\n\t\treturn -EINVAL;\n\t}\n\n\thdmi_write(hdmi, audio_cfg, HDMI_AUDIO_CFG);\n\n\treturn hdmi_audio_infoframe_config(hdmi);\n}\n\nstatic void sti_hdmi_pre_enable(struct drm_bridge *bridge)\n{\n\tstruct sti_hdmi *hdmi = bridge->driver_private;\n\n\tDRM_DEBUG_DRIVER(\"\\n\");\n\n\tif (hdmi->enabled)\n\t\treturn;\n\n\t \n\tif (clk_prepare_enable(hdmi->clk_pix))\n\t\tDRM_ERROR(\"Failed to prepare/enable hdmi_pix clk\\n\");\n\tif (clk_prepare_enable(hdmi->clk_tmds))\n\t\tDRM_ERROR(\"Failed to prepare/enable hdmi_tmds clk\\n\");\n\tif (clk_prepare_enable(hdmi->clk_phy))\n\t\tDRM_ERROR(\"Failed to prepare/enable hdmi_rejection_pll clk\\n\");\n\n\thdmi->enabled = true;\n\n\t \n\tif (!hdmi->phy_ops->start(hdmi)) {\n\t\tDRM_ERROR(\"Unable to start hdmi phy\\n\");\n\t\treturn;\n\t}\n\n\t \n\thdmi_active_area(hdmi);\n\n\t \n\thdmi_write(hdmi, HDMI_WORKING_INT, HDMI_INT_EN);\n\n\t \n\thdmi_config(hdmi);\n\n\t \n\tif (hdmi_avi_infoframe_config(hdmi))\n\t\tDRM_ERROR(\"Unable to configure AVI infoframe\\n\");\n\n\tif (hdmi->audio.enabled) {\n\t\tif (hdmi_audio_configure(hdmi))\n\t\t\tDRM_ERROR(\"Unable to configure audio\\n\");\n\t} else {\n\t\thdmi_audio_infoframe_config(hdmi);\n\t}\n\n\t \n\tif (hdmi_vendor_infoframe_config(hdmi))\n\t\tDRM_ERROR(\"Unable to configure VS infoframe\\n\");\n\n\t \n\thdmi_swreset(hdmi);\n}\n\nstatic void sti_hdmi_set_mode(struct drm_bridge *bridge,\n\t\t\t      const struct drm_display_mode *mode,\n\t\t\t      const struct drm_display_mode *adjusted_mode)\n{\n\tstruct sti_hdmi *hdmi = bridge->driver_private;\n\tint ret;\n\n\tDRM_DEBUG_DRIVER(\"\\n\");\n\n\t \n\tdrm_mode_copy(&hdmi->mode, mode);\n\n\t \n\tret = clk_set_rate(hdmi->clk_pix, mode->clock * 1000);\n\tif (ret < 0) {\n\t\tDRM_ERROR(\"Cannot set rate (%dHz) for hdmi_pix clk\\n\",\n\t\t\t  mode->clock * 1000);\n\t\treturn;\n\t}\n\tret = clk_set_rate(hdmi->clk_phy, mode->clock * 1000);\n\tif (ret < 0) {\n\t\tDRM_ERROR(\"Cannot set rate (%dHz) for hdmi_rejection_pll clk\\n\",\n\t\t\t  mode->clock * 1000);\n\t\treturn;\n\t}\n}\n\nstatic void sti_hdmi_bridge_nope(struct drm_bridge *bridge)\n{\n\t \n}\n\nstatic const struct drm_bridge_funcs sti_hdmi_bridge_funcs = {\n\t.pre_enable = sti_hdmi_pre_enable,\n\t.enable = sti_hdmi_bridge_nope,\n\t.disable = sti_hdmi_disable,\n\t.post_disable = sti_hdmi_bridge_nope,\n\t.mode_set = sti_hdmi_set_mode,\n};\n\nstatic int sti_hdmi_connector_get_modes(struct drm_connector *connector)\n{\n\tstruct sti_hdmi_connector *hdmi_connector\n\t\t= to_sti_hdmi_connector(connector);\n\tstruct sti_hdmi *hdmi = hdmi_connector->hdmi;\n\tstruct edid *edid;\n\tint count;\n\n\tDRM_DEBUG_DRIVER(\"\\n\");\n\n\tedid = drm_get_edid(connector, hdmi->ddc_adapt);\n\tif (!edid)\n\t\tgoto fail;\n\n\tcec_notifier_set_phys_addr_from_edid(hdmi->notifier, edid);\n\n\tcount = drm_add_edid_modes(connector, edid);\n\tdrm_connector_update_edid_property(connector, edid);\n\n\tDRM_DEBUG_KMS(\"%s : %dx%d cm\\n\",\n\t\t      (connector->display_info.is_hdmi ? \"hdmi monitor\" : \"dvi monitor\"),\n\t\t      edid->width_cm, edid->height_cm);\n\n\tkfree(edid);\n\treturn count;\n\nfail:\n\tDRM_ERROR(\"Can't read HDMI EDID\\n\");\n\treturn 0;\n}\n\n#define CLK_TOLERANCE_HZ 50\n\nstatic enum drm_mode_status\nsti_hdmi_connector_mode_valid(struct drm_connector *connector,\n\t\t\t      struct drm_display_mode *mode)\n{\n\tint target = mode->clock * 1000;\n\tint target_min = target - CLK_TOLERANCE_HZ;\n\tint target_max = target + CLK_TOLERANCE_HZ;\n\tint result;\n\tstruct sti_hdmi_connector *hdmi_connector\n\t\t= to_sti_hdmi_connector(connector);\n\tstruct sti_hdmi *hdmi = hdmi_connector->hdmi;\n\n\n\tresult = clk_round_rate(hdmi->clk_pix, target);\n\n\tDRM_DEBUG_DRIVER(\"target rate = %d => available rate = %d\\n\",\n\t\t\t target, result);\n\n\tif ((result < target_min) || (result > target_max)) {\n\t\tDRM_DEBUG_DRIVER(\"hdmi pixclk=%d not supported\\n\", target);\n\t\treturn MODE_BAD;\n\t}\n\n\treturn MODE_OK;\n}\n\nstatic const\nstruct drm_connector_helper_funcs sti_hdmi_connector_helper_funcs = {\n\t.get_modes = sti_hdmi_connector_get_modes,\n\t.mode_valid = sti_hdmi_connector_mode_valid,\n};\n\n \nstatic enum drm_connector_status\nsti_hdmi_connector_detect(struct drm_connector *connector, bool force)\n{\n\tstruct sti_hdmi_connector *hdmi_connector\n\t\t= to_sti_hdmi_connector(connector);\n\tstruct sti_hdmi *hdmi = hdmi_connector->hdmi;\n\n\tDRM_DEBUG_DRIVER(\"\\n\");\n\n\tif (hdmi->hpd) {\n\t\tDRM_DEBUG_DRIVER(\"hdmi cable connected\\n\");\n\t\treturn connector_status_connected;\n\t}\n\n\tDRM_DEBUG_DRIVER(\"hdmi cable disconnected\\n\");\n\tcec_notifier_set_phys_addr(hdmi->notifier, CEC_PHYS_ADDR_INVALID);\n\treturn connector_status_disconnected;\n}\n\nstatic void sti_hdmi_connector_init_property(struct drm_device *drm_dev,\n\t\t\t\t\t     struct drm_connector *connector)\n{\n\tstruct sti_hdmi_connector *hdmi_connector\n\t\t= to_sti_hdmi_connector(connector);\n\tstruct sti_hdmi *hdmi = hdmi_connector->hdmi;\n\tstruct drm_property *prop;\n\n\t \n\thdmi->colorspace = DEFAULT_COLORSPACE_MODE;\n\tprop = drm_property_create_enum(drm_dev, 0, \"colorspace\",\n\t\t\t\t\tcolorspace_mode_names,\n\t\t\t\t\tARRAY_SIZE(colorspace_mode_names));\n\tif (!prop) {\n\t\tDRM_ERROR(\"fails to create colorspace property\\n\");\n\t\treturn;\n\t}\n\thdmi_connector->colorspace_property = prop;\n\tdrm_object_attach_property(&connector->base, prop, hdmi->colorspace);\n}\n\nstatic int\nsti_hdmi_connector_set_property(struct drm_connector *connector,\n\t\t\t\tstruct drm_connector_state *state,\n\t\t\t\tstruct drm_property *property,\n\t\t\t\tuint64_t val)\n{\n\tstruct sti_hdmi_connector *hdmi_connector\n\t\t= to_sti_hdmi_connector(connector);\n\tstruct sti_hdmi *hdmi = hdmi_connector->hdmi;\n\n\tif (property == hdmi_connector->colorspace_property) {\n\t\thdmi->colorspace = val;\n\t\treturn 0;\n\t}\n\n\tDRM_ERROR(\"failed to set hdmi connector property\\n\");\n\treturn -EINVAL;\n}\n\nstatic int\nsti_hdmi_connector_get_property(struct drm_connector *connector,\n\t\t\t\tconst struct drm_connector_state *state,\n\t\t\t\tstruct drm_property *property,\n\t\t\t\tuint64_t *val)\n{\n\tstruct sti_hdmi_connector *hdmi_connector\n\t\t= to_sti_hdmi_connector(connector);\n\tstruct sti_hdmi *hdmi = hdmi_connector->hdmi;\n\n\tif (property == hdmi_connector->colorspace_property) {\n\t\t*val = hdmi->colorspace;\n\t\treturn 0;\n\t}\n\n\tDRM_ERROR(\"failed to get hdmi connector property\\n\");\n\treturn -EINVAL;\n}\n\nstatic int sti_hdmi_late_register(struct drm_connector *connector)\n{\n\tstruct sti_hdmi_connector *hdmi_connector\n\t\t= to_sti_hdmi_connector(connector);\n\tstruct sti_hdmi *hdmi = hdmi_connector->hdmi;\n\n\thdmi_debugfs_init(hdmi, hdmi->drm_dev->primary);\n\n\treturn 0;\n}\n\nstatic const struct drm_connector_funcs sti_hdmi_connector_funcs = {\n\t.fill_modes = drm_helper_probe_single_connector_modes,\n\t.detect = sti_hdmi_connector_detect,\n\t.destroy = drm_connector_cleanup,\n\t.reset = drm_atomic_helper_connector_reset,\n\t.atomic_set_property = sti_hdmi_connector_set_property,\n\t.atomic_get_property = sti_hdmi_connector_get_property,\n\t.atomic_duplicate_state = drm_atomic_helper_connector_duplicate_state,\n\t.atomic_destroy_state = drm_atomic_helper_connector_destroy_state,\n\t.late_register = sti_hdmi_late_register,\n};\n\nstatic struct drm_encoder *sti_hdmi_find_encoder(struct drm_device *dev)\n{\n\tstruct drm_encoder *encoder;\n\n\tlist_for_each_entry(encoder, &dev->mode_config.encoder_list, head) {\n\t\tif (encoder->encoder_type == DRM_MODE_ENCODER_TMDS)\n\t\t\treturn encoder;\n\t}\n\n\treturn NULL;\n}\n\nstatic void hdmi_audio_shutdown(struct device *dev, void *data)\n{\n\tstruct sti_hdmi *hdmi = dev_get_drvdata(dev);\n\tint audio_cfg;\n\n\tDRM_DEBUG_DRIVER(\"\\n\");\n\n\t \n\taudio_cfg = HDMI_AUD_CFG_SPDIF_DIV_2 | HDMI_AUD_CFG_DTS_INVALID |\n\t\t    HDMI_AUD_CFG_ONE_BIT_INVALID;\n\thdmi_write(hdmi, audio_cfg, HDMI_AUDIO_CFG);\n\n\thdmi->audio.enabled = false;\n\thdmi_audio_infoframe_config(hdmi);\n}\n\nstatic int hdmi_audio_hw_params(struct device *dev,\n\t\t\t\tvoid *data,\n\t\t\t\tstruct hdmi_codec_daifmt *daifmt,\n\t\t\t\tstruct hdmi_codec_params *params)\n{\n\tstruct sti_hdmi *hdmi = dev_get_drvdata(dev);\n\tint ret;\n\n\tDRM_DEBUG_DRIVER(\"\\n\");\n\n\tif ((daifmt->fmt != HDMI_I2S) || daifmt->bit_clk_inv ||\n\t    daifmt->frame_clk_inv || daifmt->bit_clk_provider ||\n\t    daifmt->frame_clk_provider) {\n\t\tdev_err(dev, \"%s: Bad flags %d %d %d %d\\n\", __func__,\n\t\t\tdaifmt->bit_clk_inv, daifmt->frame_clk_inv,\n\t\t\tdaifmt->bit_clk_provider,\n\t\t\tdaifmt->frame_clk_provider);\n\t\treturn -EINVAL;\n\t}\n\n\thdmi->audio.sample_width = params->sample_width;\n\thdmi->audio.sample_rate = params->sample_rate;\n\thdmi->audio.cea = params->cea;\n\n\thdmi->audio.enabled = true;\n\n\tret = hdmi_audio_configure(hdmi);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn 0;\n}\n\nstatic int hdmi_audio_mute(struct device *dev, void *data,\n\t\t\t   bool enable, int direction)\n{\n\tstruct sti_hdmi *hdmi = dev_get_drvdata(dev);\n\n\tDRM_DEBUG_DRIVER(\"%s\\n\", enable ? \"enable\" : \"disable\");\n\n\tif (enable)\n\t\thdmi_write(hdmi, HDMI_SAMPLE_FLAT_ALL, HDMI_SAMPLE_FLAT_MASK);\n\telse\n\t\thdmi_write(hdmi, HDMI_SAMPLE_FLAT_NO, HDMI_SAMPLE_FLAT_MASK);\n\n\treturn 0;\n}\n\nstatic int hdmi_audio_get_eld(struct device *dev, void *data, uint8_t *buf, size_t len)\n{\n\tstruct sti_hdmi *hdmi = dev_get_drvdata(dev);\n\tstruct drm_connector *connector = hdmi->drm_connector;\n\n\tDRM_DEBUG_DRIVER(\"\\n\");\n\tmemcpy(buf, connector->eld, min(sizeof(connector->eld), len));\n\n\treturn 0;\n}\n\nstatic const struct hdmi_codec_ops audio_codec_ops = {\n\t.hw_params = hdmi_audio_hw_params,\n\t.audio_shutdown = hdmi_audio_shutdown,\n\t.mute_stream = hdmi_audio_mute,\n\t.get_eld = hdmi_audio_get_eld,\n\t.no_capture_mute = 1,\n};\n\nstatic int sti_hdmi_register_audio_driver(struct device *dev,\n\t\t\t\t\t  struct sti_hdmi *hdmi)\n{\n\tstruct hdmi_codec_pdata codec_data = {\n\t\t.ops = &audio_codec_ops,\n\t\t.max_i2s_channels = 8,\n\t\t.i2s = 1,\n\t};\n\n\tDRM_DEBUG_DRIVER(\"\\n\");\n\n\thdmi->audio.enabled = false;\n\n\thdmi->audio_pdev = platform_device_register_data(\n\t\tdev, HDMI_CODEC_DRV_NAME, PLATFORM_DEVID_AUTO,\n\t\t&codec_data, sizeof(codec_data));\n\n\tif (IS_ERR(hdmi->audio_pdev))\n\t\treturn PTR_ERR(hdmi->audio_pdev);\n\n\tDRM_INFO(\"%s Driver bound %s\\n\", HDMI_CODEC_DRV_NAME, dev_name(dev));\n\n\treturn 0;\n}\n\nstatic int sti_hdmi_bind(struct device *dev, struct device *master, void *data)\n{\n\tstruct sti_hdmi *hdmi = dev_get_drvdata(dev);\n\tstruct drm_device *drm_dev = data;\n\tstruct drm_encoder *encoder;\n\tstruct sti_hdmi_connector *connector;\n\tstruct cec_connector_info conn_info;\n\tstruct drm_connector *drm_connector;\n\tstruct drm_bridge *bridge;\n\tint err;\n\n\t \n\thdmi->drm_dev = drm_dev;\n\n\tencoder = sti_hdmi_find_encoder(drm_dev);\n\tif (!encoder)\n\t\treturn -EINVAL;\n\n\tconnector = devm_kzalloc(dev, sizeof(*connector), GFP_KERNEL);\n\tif (!connector)\n\t\treturn -EINVAL;\n\n\tconnector->hdmi = hdmi;\n\n\tbridge = devm_kzalloc(dev, sizeof(*bridge), GFP_KERNEL);\n\tif (!bridge)\n\t\treturn -EINVAL;\n\n\tbridge->driver_private = hdmi;\n\tbridge->funcs = &sti_hdmi_bridge_funcs;\n\tdrm_bridge_attach(encoder, bridge, NULL, 0);\n\n\tconnector->encoder = encoder;\n\n\tdrm_connector = (struct drm_connector *)connector;\n\n\tdrm_connector->polled = DRM_CONNECTOR_POLL_HPD;\n\n\tdrm_connector_init_with_ddc(drm_dev, drm_connector,\n\t\t\t\t    &sti_hdmi_connector_funcs,\n\t\t\t\t    DRM_MODE_CONNECTOR_HDMIA,\n\t\t\t\t    hdmi->ddc_adapt);\n\tdrm_connector_helper_add(drm_connector,\n\t\t\t&sti_hdmi_connector_helper_funcs);\n\n\t \n\tsti_hdmi_connector_init_property(drm_dev, drm_connector);\n\n\thdmi->drm_connector = drm_connector;\n\n\terr = drm_connector_attach_encoder(drm_connector, encoder);\n\tif (err) {\n\t\tDRM_ERROR(\"Failed to attach a connector to a encoder\\n\");\n\t\tgoto err_sysfs;\n\t}\n\n\terr = sti_hdmi_register_audio_driver(dev, hdmi);\n\tif (err) {\n\t\tDRM_ERROR(\"Failed to attach an audio codec\\n\");\n\t\tgoto err_sysfs;\n\t}\n\n\t \n\terr = hdmi_audio_infoframe_init(&hdmi->audio.cea);\n\tif (err) {\n\t\tDRM_ERROR(\"Failed to init audio infoframe\\n\");\n\t\tgoto err_sysfs;\n\t}\n\n\tcec_fill_conn_info_from_drm(&conn_info, drm_connector);\n\thdmi->notifier = cec_notifier_conn_register(&hdmi->dev, NULL,\n\t\t\t\t\t\t    &conn_info);\n\tif (!hdmi->notifier) {\n\t\thdmi->drm_connector = NULL;\n\t\treturn -ENOMEM;\n\t}\n\n\t \n\thdmi_write(hdmi, HDMI_DEFAULT_INT, HDMI_INT_EN);\n\n\treturn 0;\n\nerr_sysfs:\n\thdmi->drm_connector = NULL;\n\treturn -EINVAL;\n}\n\nstatic void sti_hdmi_unbind(struct device *dev,\n\t\tstruct device *master, void *data)\n{\n\tstruct sti_hdmi *hdmi = dev_get_drvdata(dev);\n\n\tcec_notifier_conn_unregister(hdmi->notifier);\n}\n\nstatic const struct component_ops sti_hdmi_ops = {\n\t.bind = sti_hdmi_bind,\n\t.unbind = sti_hdmi_unbind,\n};\n\nstatic const struct of_device_id hdmi_of_match[] = {\n\t{\n\t\t.compatible = \"st,stih407-hdmi\",\n\t\t.data = &tx3g4c28phy_ops,\n\t}, {\n\t\t \n\t}\n};\nMODULE_DEVICE_TABLE(of, hdmi_of_match);\n\nstatic int sti_hdmi_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct sti_hdmi *hdmi;\n\tstruct device_node *np = dev->of_node;\n\tstruct resource *res;\n\tstruct device_node *ddc;\n\tint ret;\n\n\tDRM_INFO(\"%s\\n\", __func__);\n\n\thdmi = devm_kzalloc(dev, sizeof(*hdmi), GFP_KERNEL);\n\tif (!hdmi)\n\t\treturn -ENOMEM;\n\n\tddc = of_parse_phandle(pdev->dev.of_node, \"ddc\", 0);\n\tif (ddc) {\n\t\thdmi->ddc_adapt = of_get_i2c_adapter_by_node(ddc);\n\t\tof_node_put(ddc);\n\t\tif (!hdmi->ddc_adapt)\n\t\t\treturn -EPROBE_DEFER;\n\t}\n\n\thdmi->dev = pdev->dev;\n\n\t \n\tres = platform_get_resource_byname(pdev, IORESOURCE_MEM, \"hdmi-reg\");\n\tif (!res) {\n\t\tDRM_ERROR(\"Invalid hdmi resource\\n\");\n\t\tret = -ENOMEM;\n\t\tgoto release_adapter;\n\t}\n\thdmi->regs = devm_ioremap(dev, res->start, resource_size(res));\n\tif (!hdmi->regs) {\n\t\tret = -ENOMEM;\n\t\tgoto release_adapter;\n\t}\n\n\thdmi->phy_ops = (struct hdmi_phy_ops *)\n\t\tof_match_node(hdmi_of_match, np)->data;\n\n\t \n\thdmi->clk_pix = devm_clk_get(dev, \"pix\");\n\tif (IS_ERR(hdmi->clk_pix)) {\n\t\tDRM_ERROR(\"Cannot get hdmi_pix clock\\n\");\n\t\tret = PTR_ERR(hdmi->clk_pix);\n\t\tgoto release_adapter;\n\t}\n\n\thdmi->clk_tmds = devm_clk_get(dev, \"tmds\");\n\tif (IS_ERR(hdmi->clk_tmds)) {\n\t\tDRM_ERROR(\"Cannot get hdmi_tmds clock\\n\");\n\t\tret = PTR_ERR(hdmi->clk_tmds);\n\t\tgoto release_adapter;\n\t}\n\n\thdmi->clk_phy = devm_clk_get(dev, \"phy\");\n\tif (IS_ERR(hdmi->clk_phy)) {\n\t\tDRM_ERROR(\"Cannot get hdmi_phy clock\\n\");\n\t\tret = PTR_ERR(hdmi->clk_phy);\n\t\tgoto release_adapter;\n\t}\n\n\thdmi->clk_audio = devm_clk_get(dev, \"audio\");\n\tif (IS_ERR(hdmi->clk_audio)) {\n\t\tDRM_ERROR(\"Cannot get hdmi_audio clock\\n\");\n\t\tret = PTR_ERR(hdmi->clk_audio);\n\t\tgoto release_adapter;\n\t}\n\n\thdmi->hpd = readl(hdmi->regs + HDMI_STA) & HDMI_STA_HOT_PLUG;\n\n\tinit_waitqueue_head(&hdmi->wait_event);\n\n\thdmi->irq = platform_get_irq_byname(pdev, \"irq\");\n\tif (hdmi->irq < 0) {\n\t\tDRM_ERROR(\"Cannot get HDMI irq\\n\");\n\t\tret = hdmi->irq;\n\t\tgoto release_adapter;\n\t}\n\n\tret = devm_request_threaded_irq(dev, hdmi->irq, hdmi_irq,\n\t\t\thdmi_irq_thread, IRQF_ONESHOT, dev_name(dev), hdmi);\n\tif (ret) {\n\t\tDRM_ERROR(\"Failed to register HDMI interrupt\\n\");\n\t\tgoto release_adapter;\n\t}\n\n\thdmi->reset = devm_reset_control_get(dev, \"hdmi\");\n\t \n\tif (!IS_ERR(hdmi->reset))\n\t\treset_control_deassert(hdmi->reset);\n\n\tplatform_set_drvdata(pdev, hdmi);\n\n\treturn component_add(&pdev->dev, &sti_hdmi_ops);\n\n release_adapter:\n\ti2c_put_adapter(hdmi->ddc_adapt);\n\n\treturn ret;\n}\n\nstatic void sti_hdmi_remove(struct platform_device *pdev)\n{\n\tstruct sti_hdmi *hdmi = dev_get_drvdata(&pdev->dev);\n\n\ti2c_put_adapter(hdmi->ddc_adapt);\n\tif (hdmi->audio_pdev)\n\t\tplatform_device_unregister(hdmi->audio_pdev);\n\tcomponent_del(&pdev->dev, &sti_hdmi_ops);\n}\n\nstruct platform_driver sti_hdmi_driver = {\n\t.driver = {\n\t\t.name = \"sti-hdmi\",\n\t\t.owner = THIS_MODULE,\n\t\t.of_match_table = hdmi_of_match,\n\t},\n\t.probe = sti_hdmi_probe,\n\t.remove_new = sti_hdmi_remove,\n};\n\nMODULE_AUTHOR(\"Benjamin Gaignard <benjamin.gaignard@st.com>\");\nMODULE_DESCRIPTION(\"STMicroelectronics SoC DRM driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}