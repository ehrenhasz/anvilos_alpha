{
  "module_name": "sti_awg_utils.c",
  "hash_id": "61b226ee462609b16159cecf4a03f93e5499cd5f5350dcbd7d3e1b8d265d82a0",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/sti/sti_awg_utils.c",
  "human_readable_source": "\n \n\n#include <drm/drm_print.h>\n\n#include \"sti_awg_utils.h\"\n\n#define AWG_DELAY (-5)\n\n#define AWG_OPCODE_OFFSET 10\n#define AWG_MAX_ARG       0x3ff\n\nenum opcode {\n\tSET,\n\tRPTSET,\n\tRPLSET,\n\tSKIP,\n\tSTOP,\n\tREPEAT,\n\tREPLAY,\n\tJUMP,\n\tHOLD,\n};\n\nstatic int awg_generate_instr(enum opcode opcode,\n\t\t\t      long int arg,\n\t\t\t      long int mux_sel,\n\t\t\t      long int data_en,\n\t\t\t      struct awg_code_generation_params *fwparams)\n{\n\tu32 instruction = 0;\n\tu32 mux = (mux_sel << 8) & 0x1ff;\n\tu32 data_enable = (data_en << 9) & 0x2ff;\n\tlong int arg_tmp = arg;\n\n\t \n\n\twhile (arg_tmp > 0) {\n\t\targ = arg_tmp;\n\t\tif (fwparams->instruction_offset >= AWG_MAX_INST) {\n\t\t\tDRM_ERROR(\"too many number of instructions\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tswitch (opcode) {\n\t\tcase SKIP:\n\t\t\t \n\t\t\targ--;  \n\t\t\targ_tmp--;\n\n\t\t\tif (arg < 0) {\n\t\t\t\t \n\t\t\t\treturn 0;\n\t\t\t}\n\n\t\t\tif (arg == 0) {\n\t\t\t\t \n\t\t\t\topcode = SET;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tmux = 0;\n\t\t\tdata_enable = 0;\n\t\t\targ &= AWG_MAX_ARG;\n\t\t\tbreak;\n\t\tcase REPEAT:\n\t\tcase REPLAY:\n\t\t\tif (arg == 0) {\n\t\t\t\t \n\t\t\t\treturn 0;\n\t\t\t}\n\n\t\t\tmux = 0;\n\t\t\tdata_enable = 0;\n\t\t\targ &= AWG_MAX_ARG;\n\t\t\tbreak;\n\t\tcase JUMP:\n\t\t\tmux = 0;\n\t\t\tdata_enable = 0;\n\t\t\targ |= 0x40;  \n\t\t\targ &= AWG_MAX_ARG;\n\t\t\tbreak;\n\t\tcase STOP:\n\t\t\targ = 0;\n\t\t\tbreak;\n\t\tcase SET:\n\t\tcase RPTSET:\n\t\tcase RPLSET:\n\t\tcase HOLD:\n\t\t\targ &= (0x0ff);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tDRM_ERROR(\"instruction %d does not exist\\n\", opcode);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\targ_tmp = arg_tmp - arg;\n\n\t\targ = ((arg + mux) + data_enable);\n\n\t\tinstruction = ((opcode) << AWG_OPCODE_OFFSET) | arg;\n\t\tfwparams->ram_code[fwparams->instruction_offset] =\n\t\t\tinstruction & (0x3fff);\n\t\tfwparams->instruction_offset++;\n\t}\n\treturn 0;\n}\n\nstatic int awg_generate_line_signal(\n\t\tstruct awg_code_generation_params *fwparams,\n\t\tstruct awg_timing *timing)\n{\n\tlong int val;\n\tint ret = 0;\n\n\tif (timing->trailing_pixels > 0) {\n\t\t \n\t\tval = timing->blanking_level;\n\t\tret |= awg_generate_instr(RPLSET, val, 0, 0, fwparams);\n\n\t\tval = timing->trailing_pixels - 1 + AWG_DELAY;\n\t\tret |= awg_generate_instr(SKIP, val, 0, 0, fwparams);\n\t}\n\n\t \n\tval = timing->blanking_level;\n\tret |= awg_generate_instr((timing->trailing_pixels > 0) ? SET : RPLSET,\n\t\t\tval, 0, 1, fwparams);\n\n\tif (timing->blanking_pixels > 0) {\n\t\t \n\t\tval = timing->active_pixels - 1;\n\t\tret |= awg_generate_instr(SKIP, val, 0, 1, fwparams);\n\n\t\t \n\t\tval = timing->blanking_level;\n\t\tret |= awg_generate_instr(SET, val, 0, 0, fwparams);\n\t}\n\n\treturn ret;\n}\n\nint sti_awg_generate_code_data_enable_mode(\n\t\tstruct awg_code_generation_params *fwparams,\n\t\tstruct awg_timing *timing)\n{\n\tlong int val, tmp_val;\n\tint ret = 0;\n\n\tif (timing->trailing_lines > 0) {\n\t\t \n\t\tval = timing->blanking_level;\n\t\tret |= awg_generate_instr(RPLSET, val, 0, 0, fwparams);\n\n\t\tval = timing->trailing_lines - 1;\n\t\tret |= awg_generate_instr(REPLAY, val, 0, 0, fwparams);\n\t}\n\n\ttmp_val = timing->active_lines - 1;\n\n\twhile (tmp_val > 0) {\n\t\t \n\t\tret |= awg_generate_line_signal(fwparams, timing);\n\t\t \n\t\tret |= awg_generate_instr(REPLAY,\n\t\t\t\t\t  min_t(int, AWG_MAX_ARG, tmp_val),\n\t\t\t\t\t  0, 0, fwparams);\n\t\ttmp_val -= AWG_MAX_ARG;\n\t}\n\n\tif (timing->blanking_lines > 0) {\n\t\t \n\t\tval = timing->blanking_level;\n\t\tret |= awg_generate_instr(RPLSET, val, 0, 0, fwparams);\n\n\t\tval = timing->blanking_lines - 1;\n\t\tret |= awg_generate_instr(REPLAY, val, 0, 0, fwparams);\n\t}\n\n\treturn ret;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}