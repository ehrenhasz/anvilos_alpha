{
  "module_name": "sti_hqvdp.c",
  "hash_id": "b567b78ea07cc2844fc22b85c38db5b41b0c06e6ba4a5ec1dcf30d0064799781",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/sti/sti_hqvdp.c",
  "human_readable_source": "\n \n\n#include <linux/component.h>\n#include <linux/delay.h>\n#include <linux/dma-mapping.h>\n#include <linux/firmware.h>\n#include <linux/io.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/reset.h>\n#include <linux/seq_file.h>\n\n#include <drm/drm_atomic.h>\n#include <drm/drm_device.h>\n#include <drm/drm_fb_dma_helper.h>\n#include <drm/drm_fourcc.h>\n#include <drm/drm_framebuffer.h>\n#include <drm/drm_gem_dma_helper.h>\n\n#include \"sti_compositor.h\"\n#include \"sti_drv.h\"\n#include \"sti_hqvdp_lut.h\"\n#include \"sti_plane.h\"\n#include \"sti_vtg.h\"\n\n \n#define HQVDP_FMW_NAME          \"hqvdp-stih407.bin\"\n\n \n#define HQVDP_DMEM              0x00000000                \n#define HQVDP_PMEM              0x00040000                \n#define HQVDP_RD_PLUG           0x000E0000                \n#define HQVDP_RD_PLUG_CONTROL   (HQVDP_RD_PLUG + 0x1000)  \n#define HQVDP_RD_PLUG_PAGE_SIZE (HQVDP_RD_PLUG + 0x1004)  \n#define HQVDP_RD_PLUG_MIN_OPC   (HQVDP_RD_PLUG + 0x1008)  \n#define HQVDP_RD_PLUG_MAX_OPC   (HQVDP_RD_PLUG + 0x100C)  \n#define HQVDP_RD_PLUG_MAX_CHK   (HQVDP_RD_PLUG + 0x1010)  \n#define HQVDP_RD_PLUG_MAX_MSG   (HQVDP_RD_PLUG + 0x1014)  \n#define HQVDP_RD_PLUG_MIN_SPACE (HQVDP_RD_PLUG + 0x1018)  \n#define HQVDP_WR_PLUG           0x000E2000                \n#define HQVDP_WR_PLUG_CONTROL   (HQVDP_WR_PLUG + 0x1000)  \n#define HQVDP_WR_PLUG_PAGE_SIZE (HQVDP_WR_PLUG + 0x1004)  \n#define HQVDP_WR_PLUG_MIN_OPC   (HQVDP_WR_PLUG + 0x1008)  \n#define HQVDP_WR_PLUG_MAX_OPC   (HQVDP_WR_PLUG + 0x100C)  \n#define HQVDP_WR_PLUG_MAX_CHK   (HQVDP_WR_PLUG + 0x1010)  \n#define HQVDP_WR_PLUG_MAX_MSG   (HQVDP_WR_PLUG + 0x1014)  \n#define HQVDP_WR_PLUG_MIN_SPACE (HQVDP_WR_PLUG + 0x1018)  \n#define HQVDP_MBX               0x000E4000                \n#define HQVDP_MBX_IRQ_TO_XP70   (HQVDP_MBX + 0x0000)      \n#define HQVDP_MBX_INFO_HOST     (HQVDP_MBX + 0x0004)      \n#define HQVDP_MBX_IRQ_TO_HOST   (HQVDP_MBX + 0x0008)      \n#define HQVDP_MBX_INFO_XP70     (HQVDP_MBX + 0x000C)      \n#define HQVDP_MBX_SW_RESET_CTRL (HQVDP_MBX + 0x0010)      \n#define HQVDP_MBX_STARTUP_CTRL1 (HQVDP_MBX + 0x0014)      \n#define HQVDP_MBX_STARTUP_CTRL2 (HQVDP_MBX + 0x0018)      \n#define HQVDP_MBX_GP_STATUS     (HQVDP_MBX + 0x001C)      \n#define HQVDP_MBX_NEXT_CMD      (HQVDP_MBX + 0x0020)      \n#define HQVDP_MBX_CURRENT_CMD   (HQVDP_MBX + 0x0024)      \n#define HQVDP_MBX_SOFT_VSYNC    (HQVDP_MBX + 0x0028)      \n\n \n#define PLUG_CONTROL_ENABLE     0x00000001\n#define PLUG_PAGE_SIZE_256      0x00000002\n#define PLUG_MIN_OPC_8          0x00000003\n#define PLUG_MAX_OPC_64         0x00000006\n#define PLUG_MAX_CHK_2X         0x00000001\n#define PLUG_MAX_MSG_1X         0x00000000\n#define PLUG_MIN_SPACE_1        0x00000000\n\n \n#define SW_RESET_CTRL_FULL      BIT(0)\n#define SW_RESET_CTRL_CORE      BIT(1)\n\n \n#define STARTUP_CTRL1_RST_DONE  BIT(0)\n#define STARTUP_CTRL1_AUTH_IDLE BIT(2)\n\n \n#define STARTUP_CTRL2_FETCH_EN  BIT(1)\n\n \n#define INFO_XP70_FW_READY      BIT(15)\n#define INFO_XP70_FW_PROCESSING BIT(14)\n#define INFO_XP70_FW_INITQUEUES BIT(13)\n\n \n#define SOFT_VSYNC_HW           0x00000000\n#define SOFT_VSYNC_SW_CMD       0x00000001\n#define SOFT_VSYNC_SW_CTRL_IRQ  0x00000003\n\n \n#define POLL_MAX_ATTEMPT        50\n#define POLL_DELAY_MS           20\n\n#define SCALE_FACTOR            8192\n#define SCALE_MAX_FOR_LEG_LUT_F 4096\n#define SCALE_MAX_FOR_LEG_LUT_E 4915\n#define SCALE_MAX_FOR_LEG_LUT_D 6654\n#define SCALE_MAX_FOR_LEG_LUT_C 8192\n\nenum sti_hvsrc_orient {\n\tHVSRC_HORI,\n\tHVSRC_VERT\n};\n\n \nstruct sti_hqvdp_top {\n\tu32 config;\n\tu32 mem_format;\n\tu32 current_luma;\n\tu32 current_enh_luma;\n\tu32 current_right_luma;\n\tu32 current_enh_right_luma;\n\tu32 current_chroma;\n\tu32 current_enh_chroma;\n\tu32 current_right_chroma;\n\tu32 current_enh_right_chroma;\n\tu32 output_luma;\n\tu32 output_chroma;\n\tu32 luma_src_pitch;\n\tu32 luma_enh_src_pitch;\n\tu32 luma_right_src_pitch;\n\tu32 luma_enh_right_src_pitch;\n\tu32 chroma_src_pitch;\n\tu32 chroma_enh_src_pitch;\n\tu32 chroma_right_src_pitch;\n\tu32 chroma_enh_right_src_pitch;\n\tu32 luma_processed_pitch;\n\tu32 chroma_processed_pitch;\n\tu32 input_frame_size;\n\tu32 input_viewport_ori;\n\tu32 input_viewport_ori_right;\n\tu32 input_viewport_size;\n\tu32 left_view_border_width;\n\tu32 right_view_border_width;\n\tu32 left_view_3d_offset_width;\n\tu32 right_view_3d_offset_width;\n\tu32 side_stripe_color;\n\tu32 crc_reset_ctrl;\n};\n\n \n#define TOP_CONFIG_INTER_BTM            0x00000000\n#define TOP_CONFIG_INTER_TOP            0x00000002\n\n \n#define TOP_CONFIG_PROGRESSIVE          0x00000001\n\n \n#define TOP_MEM_FORMAT_DFLT             0x00018060\n\n \n#define MAX_WIDTH                       0x1FFF\n#define MAX_HEIGHT                      0x0FFF\n#define MIN_WIDTH                       0x0030\n#define MIN_HEIGHT                      0x0010\n\nstruct sti_hqvdp_vc1re {\n\tu32 ctrl_prv_csdi;\n\tu32 ctrl_cur_csdi;\n\tu32 ctrl_nxt_csdi;\n\tu32 ctrl_cur_fmd;\n\tu32 ctrl_nxt_fmd;\n};\n\nstruct sti_hqvdp_fmd {\n\tu32 config;\n\tu32 viewport_ori;\n\tu32 viewport_size;\n\tu32 next_next_luma;\n\tu32 next_next_right_luma;\n\tu32 next_next_next_luma;\n\tu32 next_next_next_right_luma;\n\tu32 threshold_scd;\n\tu32 threshold_rfd;\n\tu32 threshold_move;\n\tu32 threshold_cfd;\n};\n\nstruct sti_hqvdp_csdi {\n\tu32 config;\n\tu32 config2;\n\tu32 dcdi_config;\n\tu32 prev_luma;\n\tu32 prev_enh_luma;\n\tu32 prev_right_luma;\n\tu32 prev_enh_right_luma;\n\tu32 next_luma;\n\tu32 next_enh_luma;\n\tu32 next_right_luma;\n\tu32 next_enh_right_luma;\n\tu32 prev_chroma;\n\tu32 prev_enh_chroma;\n\tu32 prev_right_chroma;\n\tu32 prev_enh_right_chroma;\n\tu32 next_chroma;\n\tu32 next_enh_chroma;\n\tu32 next_right_chroma;\n\tu32 next_enh_right_chroma;\n\tu32 prev_motion;\n\tu32 prev_right_motion;\n\tu32 cur_motion;\n\tu32 cur_right_motion;\n\tu32 next_motion;\n\tu32 next_right_motion;\n};\n\n \n#define CSDI_CONFIG_PROG                0x00000000\n \n#define CSDI_CONFIG_INTER_DIR           0x00000016\n \n#define CSDI_CONFIG2_DFLT               0x000001B3\n#define CSDI_DCDI_CONFIG_DFLT           0x00203803\n\nstruct sti_hqvdp_hvsrc {\n\tu32 hor_panoramic_ctrl;\n\tu32 output_picture_size;\n\tu32 init_horizontal;\n\tu32 init_vertical;\n\tu32 param_ctrl;\n\tu32 yh_coef[NB_COEF];\n\tu32 ch_coef[NB_COEF];\n\tu32 yv_coef[NB_COEF];\n\tu32 cv_coef[NB_COEF];\n\tu32 hori_shift;\n\tu32 vert_shift;\n};\n\n \n#define HVSRC_PARAM_CTRL_DFLT           0xFFFFFFFF\n\nstruct sti_hqvdp_iqi {\n\tu32 config;\n\tu32 demo_wind_size;\n\tu32 pk_config;\n\tu32 coeff0_coeff1;\n\tu32 coeff2_coeff3;\n\tu32 coeff4;\n\tu32 pk_lut;\n\tu32 pk_gain;\n\tu32 pk_coring_level;\n\tu32 cti_config;\n\tu32 le_config;\n\tu32 le_lut[64];\n\tu32 con_bri;\n\tu32 sat_gain;\n\tu32 pxf_conf;\n\tu32 default_color;\n};\n\n \n#define IQI_CONFIG_DFLT                 0x00000001\n \n#define IQI_CON_BRI_DFLT                0x00000100\n \n#define IQI_SAT_GAIN_DFLT               0x00000100\n \n#define IQI_PXF_CONF_DFLT               0x00000001\n\nstruct sti_hqvdp_top_status {\n\tu32 processing_time;\n\tu32 input_y_crc;\n\tu32 input_uv_crc;\n};\n\nstruct sti_hqvdp_fmd_status {\n\tu32 fmd_repeat_move_status;\n\tu32 fmd_scene_count_status;\n\tu32 cfd_sum;\n\tu32 field_sum;\n\tu32 next_y_fmd_crc;\n\tu32 next_next_y_fmd_crc;\n\tu32 next_next_next_y_fmd_crc;\n};\n\nstruct sti_hqvdp_csdi_status {\n\tu32 prev_y_csdi_crc;\n\tu32 cur_y_csdi_crc;\n\tu32 next_y_csdi_crc;\n\tu32 prev_uv_csdi_crc;\n\tu32 cur_uv_csdi_crc;\n\tu32 next_uv_csdi_crc;\n\tu32 y_csdi_crc;\n\tu32 uv_csdi_crc;\n\tu32 uv_cup_crc;\n\tu32 mot_csdi_crc;\n\tu32 mot_cur_csdi_crc;\n\tu32 mot_prev_csdi_crc;\n};\n\nstruct sti_hqvdp_hvsrc_status {\n\tu32 y_hvsrc_crc;\n\tu32 u_hvsrc_crc;\n\tu32 v_hvsrc_crc;\n};\n\nstruct sti_hqvdp_iqi_status {\n\tu32 pxf_it_status;\n\tu32 y_iqi_crc;\n\tu32 u_iqi_crc;\n\tu32 v_iqi_crc;\n};\n\n \n#define NB_VDP_CMD\t2\n\nstruct sti_hqvdp_cmd {\n\tstruct sti_hqvdp_top top;\n\tstruct sti_hqvdp_vc1re vc1re;\n\tstruct sti_hqvdp_fmd fmd;\n\tstruct sti_hqvdp_csdi csdi;\n\tstruct sti_hqvdp_hvsrc hvsrc;\n\tstruct sti_hqvdp_iqi iqi;\n\tstruct sti_hqvdp_top_status top_status;\n\tstruct sti_hqvdp_fmd_status fmd_status;\n\tstruct sti_hqvdp_csdi_status csdi_status;\n\tstruct sti_hqvdp_hvsrc_status hvsrc_status;\n\tstruct sti_hqvdp_iqi_status iqi_status;\n};\n\n \nstruct sti_hqvdp {\n\tstruct device *dev;\n\tstruct drm_device *drm_dev;\n\tvoid __iomem *regs;\n\tstruct sti_plane plane;\n\tstruct clk *clk;\n\tstruct clk *clk_pix_main;\n\tstruct reset_control *reset;\n\tstruct notifier_block vtg_nb;\n\tbool btm_field_pending;\n\tvoid *hqvdp_cmd;\n\tu32 hqvdp_cmd_paddr;\n\tstruct sti_vtg *vtg;\n\tbool xp70_initialized;\n\tbool vtg_registered;\n};\n\n#define to_sti_hqvdp(x) container_of(x, struct sti_hqvdp, plane)\n\nstatic const uint32_t hqvdp_supported_formats[] = {\n\tDRM_FORMAT_NV12,\n};\n\n \nstatic int sti_hqvdp_get_free_cmd(struct sti_hqvdp *hqvdp)\n{\n\tu32 curr_cmd, next_cmd;\n\tu32 cmd = hqvdp->hqvdp_cmd_paddr;\n\tint i;\n\n\tcurr_cmd = readl(hqvdp->regs + HQVDP_MBX_CURRENT_CMD);\n\tnext_cmd = readl(hqvdp->regs + HQVDP_MBX_NEXT_CMD);\n\n\tfor (i = 0; i < NB_VDP_CMD; i++) {\n\t\tif ((cmd != curr_cmd) && (cmd != next_cmd))\n\t\t\treturn i * sizeof(struct sti_hqvdp_cmd);\n\t\tcmd += sizeof(struct sti_hqvdp_cmd);\n\t}\n\n\treturn -1;\n}\n\n \nstatic int sti_hqvdp_get_curr_cmd(struct sti_hqvdp *hqvdp)\n{\n\tu32 curr_cmd;\n\tu32 cmd = hqvdp->hqvdp_cmd_paddr;\n\tunsigned int i;\n\n\tcurr_cmd = readl(hqvdp->regs + HQVDP_MBX_CURRENT_CMD);\n\n\tfor (i = 0; i < NB_VDP_CMD; i++) {\n\t\tif (cmd == curr_cmd)\n\t\t\treturn i * sizeof(struct sti_hqvdp_cmd);\n\n\t\tcmd += sizeof(struct sti_hqvdp_cmd);\n\t}\n\n\treturn -1;\n}\n\n \nstatic int sti_hqvdp_get_next_cmd(struct sti_hqvdp *hqvdp)\n{\n\tint next_cmd;\n\tdma_addr_t cmd = hqvdp->hqvdp_cmd_paddr;\n\tunsigned int i;\n\n\tnext_cmd = readl(hqvdp->regs + HQVDP_MBX_NEXT_CMD);\n\n\tfor (i = 0; i < NB_VDP_CMD; i++) {\n\t\tif (cmd == next_cmd)\n\t\t\treturn i * sizeof(struct sti_hqvdp_cmd);\n\n\t\tcmd += sizeof(struct sti_hqvdp_cmd);\n\t}\n\n\treturn -1;\n}\n\n#define DBGFS_DUMP(reg) seq_printf(s, \"\\n  %-25s 0x%08X\", #reg, \\\n\t\t\t\t   readl(hqvdp->regs + reg))\n\nstatic const char *hqvdp_dbg_get_lut(u32 *coef)\n{\n\tif (!memcmp(coef, coef_lut_a_legacy, 16))\n\t\treturn \"LUT A\";\n\tif (!memcmp(coef, coef_lut_b, 16))\n\t\treturn \"LUT B\";\n\tif (!memcmp(coef, coef_lut_c_y_legacy, 16))\n\t\treturn \"LUT C Y\";\n\tif (!memcmp(coef, coef_lut_c_c_legacy, 16))\n\t\treturn \"LUT C C\";\n\tif (!memcmp(coef, coef_lut_d_y_legacy, 16))\n\t\treturn \"LUT D Y\";\n\tif (!memcmp(coef, coef_lut_d_c_legacy, 16))\n\t\treturn \"LUT D C\";\n\tif (!memcmp(coef, coef_lut_e_y_legacy, 16))\n\t\treturn \"LUT E Y\";\n\tif (!memcmp(coef, coef_lut_e_c_legacy, 16))\n\t\treturn \"LUT E C\";\n\tif (!memcmp(coef, coef_lut_f_y_legacy, 16))\n\t\treturn \"LUT F Y\";\n\tif (!memcmp(coef, coef_lut_f_c_legacy, 16))\n\t\treturn \"LUT F C\";\n\treturn \"<UNKNOWN>\";\n}\n\nstatic void hqvdp_dbg_dump_cmd(struct seq_file *s, struct sti_hqvdp_cmd *c)\n{\n\tint src_w, src_h, dst_w, dst_h;\n\n\tseq_puts(s, \"\\n\\tTOP:\");\n\tseq_printf(s, \"\\n\\t %-20s 0x%08X\", \"Config\", c->top.config);\n\tswitch (c->top.config) {\n\tcase TOP_CONFIG_PROGRESSIVE:\n\t\tseq_puts(s, \"\\tProgressive\");\n\t\tbreak;\n\tcase TOP_CONFIG_INTER_TOP:\n\t\tseq_puts(s, \"\\tInterlaced, top field\");\n\t\tbreak;\n\tcase TOP_CONFIG_INTER_BTM:\n\t\tseq_puts(s, \"\\tInterlaced, bottom field\");\n\t\tbreak;\n\tdefault:\n\t\tseq_puts(s, \"\\t<UNKNOWN>\");\n\t\tbreak;\n\t}\n\n\tseq_printf(s, \"\\n\\t %-20s 0x%08X\", \"MemFormat\", c->top.mem_format);\n\tseq_printf(s, \"\\n\\t %-20s 0x%08X\", \"CurrentY\", c->top.current_luma);\n\tseq_printf(s, \"\\n\\t %-20s 0x%08X\", \"CurrentC\", c->top.current_chroma);\n\tseq_printf(s, \"\\n\\t %-20s 0x%08X\", \"YSrcPitch\", c->top.luma_src_pitch);\n\tseq_printf(s, \"\\n\\t %-20s 0x%08X\", \"CSrcPitch\",\n\t\t   c->top.chroma_src_pitch);\n\tseq_printf(s, \"\\n\\t %-20s 0x%08X\", \"InputFrameSize\",\n\t\t   c->top.input_frame_size);\n\tseq_printf(s, \"\\t%dx%d\",\n\t\t   c->top.input_frame_size & 0x0000FFFF,\n\t\t   c->top.input_frame_size >> 16);\n\tseq_printf(s, \"\\n\\t %-20s 0x%08X\", \"InputViewportSize\",\n\t\t   c->top.input_viewport_size);\n\tsrc_w = c->top.input_viewport_size & 0x0000FFFF;\n\tsrc_h = c->top.input_viewport_size >> 16;\n\tseq_printf(s, \"\\t%dx%d\", src_w, src_h);\n\n\tseq_puts(s, \"\\n\\tHVSRC:\");\n\tseq_printf(s, \"\\n\\t %-20s 0x%08X\", \"OutputPictureSize\",\n\t\t   c->hvsrc.output_picture_size);\n\tdst_w = c->hvsrc.output_picture_size & 0x0000FFFF;\n\tdst_h = c->hvsrc.output_picture_size >> 16;\n\tseq_printf(s, \"\\t%dx%d\", dst_w, dst_h);\n\tseq_printf(s, \"\\n\\t %-20s 0x%08X\", \"ParamCtrl\", c->hvsrc.param_ctrl);\n\n\tseq_printf(s, \"\\n\\t %-20s %s\", \"yh_coef\",\n\t\t   hqvdp_dbg_get_lut(c->hvsrc.yh_coef));\n\tseq_printf(s, \"\\n\\t %-20s %s\", \"ch_coef\",\n\t\t   hqvdp_dbg_get_lut(c->hvsrc.ch_coef));\n\tseq_printf(s, \"\\n\\t %-20s %s\", \"yv_coef\",\n\t\t   hqvdp_dbg_get_lut(c->hvsrc.yv_coef));\n\tseq_printf(s, \"\\n\\t %-20s %s\", \"cv_coef\",\n\t\t   hqvdp_dbg_get_lut(c->hvsrc.cv_coef));\n\n\tseq_printf(s, \"\\n\\t %-20s\", \"ScaleH\");\n\tif (dst_w > src_w)\n\t\tseq_printf(s, \" %d/1\", dst_w / src_w);\n\telse\n\t\tseq_printf(s, \" 1/%d\", src_w / dst_w);\n\n\tseq_printf(s, \"\\n\\t %-20s\", \"tScaleV\");\n\tif (dst_h > src_h)\n\t\tseq_printf(s, \" %d/1\", dst_h / src_h);\n\telse\n\t\tseq_printf(s, \" 1/%d\", src_h / dst_h);\n\n\tseq_puts(s, \"\\n\\tCSDI:\");\n\tseq_printf(s, \"\\n\\t %-20s 0x%08X\\t\", \"Config\", c->csdi.config);\n\tswitch (c->csdi.config) {\n\tcase CSDI_CONFIG_PROG:\n\t\tseq_puts(s, \"Bypass\");\n\t\tbreak;\n\tcase CSDI_CONFIG_INTER_DIR:\n\t\tseq_puts(s, \"Deinterlace, directional\");\n\t\tbreak;\n\tdefault:\n\t\tseq_puts(s, \"<UNKNOWN>\");\n\t\tbreak;\n\t}\n\n\tseq_printf(s, \"\\n\\t %-20s 0x%08X\", \"Config2\", c->csdi.config2);\n\tseq_printf(s, \"\\n\\t %-20s 0x%08X\", \"DcdiConfig\", c->csdi.dcdi_config);\n}\n\nstatic int hqvdp_dbg_show(struct seq_file *s, void *data)\n{\n\tstruct drm_info_node *node = s->private;\n\tstruct sti_hqvdp *hqvdp = (struct sti_hqvdp *)node->info_ent->data;\n\tint cmd, cmd_offset, infoxp70;\n\tvoid *virt;\n\n\tseq_printf(s, \"%s: (vaddr = 0x%p)\",\n\t\t   sti_plane_to_str(&hqvdp->plane), hqvdp->regs);\n\n\tDBGFS_DUMP(HQVDP_MBX_IRQ_TO_XP70);\n\tDBGFS_DUMP(HQVDP_MBX_INFO_HOST);\n\tDBGFS_DUMP(HQVDP_MBX_IRQ_TO_HOST);\n\tDBGFS_DUMP(HQVDP_MBX_INFO_XP70);\n\tinfoxp70 = readl(hqvdp->regs + HQVDP_MBX_INFO_XP70);\n\tseq_puts(s, \"\\tFirmware state: \");\n\tif (infoxp70 & INFO_XP70_FW_READY)\n\t\tseq_puts(s, \"idle and ready\");\n\telse if (infoxp70 & INFO_XP70_FW_PROCESSING)\n\t\tseq_puts(s, \"processing a picture\");\n\telse if (infoxp70 & INFO_XP70_FW_INITQUEUES)\n\t\tseq_puts(s, \"programming queues\");\n\telse\n\t\tseq_puts(s, \"NOT READY\");\n\n\tDBGFS_DUMP(HQVDP_MBX_SW_RESET_CTRL);\n\tDBGFS_DUMP(HQVDP_MBX_STARTUP_CTRL1);\n\tif (readl(hqvdp->regs + HQVDP_MBX_STARTUP_CTRL1)\n\t\t\t\t\t& STARTUP_CTRL1_RST_DONE)\n\t\tseq_puts(s, \"\\tReset is done\");\n\telse\n\t\tseq_puts(s, \"\\tReset is NOT done\");\n\tDBGFS_DUMP(HQVDP_MBX_STARTUP_CTRL2);\n\tif (readl(hqvdp->regs + HQVDP_MBX_STARTUP_CTRL2)\n\t\t\t\t\t& STARTUP_CTRL2_FETCH_EN)\n\t\tseq_puts(s, \"\\tFetch is enabled\");\n\telse\n\t\tseq_puts(s, \"\\tFetch is NOT enabled\");\n\tDBGFS_DUMP(HQVDP_MBX_GP_STATUS);\n\tDBGFS_DUMP(HQVDP_MBX_NEXT_CMD);\n\tDBGFS_DUMP(HQVDP_MBX_CURRENT_CMD);\n\tDBGFS_DUMP(HQVDP_MBX_SOFT_VSYNC);\n\tif (!(readl(hqvdp->regs + HQVDP_MBX_SOFT_VSYNC) & 3))\n\t\tseq_puts(s, \"\\tHW Vsync\");\n\telse\n\t\tseq_puts(s, \"\\tSW Vsync ?!?!\");\n\n\t \n\tcmd = readl(hqvdp->regs + HQVDP_MBX_CURRENT_CMD);\n\tcmd_offset = sti_hqvdp_get_curr_cmd(hqvdp);\n\tif (cmd_offset == -1) {\n\t\tseq_puts(s, \"\\n\\n  Last command: unknown\");\n\t} else {\n\t\tvirt = hqvdp->hqvdp_cmd + cmd_offset;\n\t\tseq_printf(s, \"\\n\\n  Last command: address @ 0x%x (0x%p)\",\n\t\t\t   cmd, virt);\n\t\thqvdp_dbg_dump_cmd(s, (struct sti_hqvdp_cmd *)virt);\n\t}\n\n\t \n\tcmd = readl(hqvdp->regs + HQVDP_MBX_NEXT_CMD);\n\tcmd_offset = sti_hqvdp_get_next_cmd(hqvdp);\n\tif (cmd_offset == -1) {\n\t\tseq_puts(s, \"\\n\\n  Next command: unknown\");\n\t} else {\n\t\tvirt = hqvdp->hqvdp_cmd + cmd_offset;\n\t\tseq_printf(s, \"\\n\\n  Next command address: @ 0x%x (0x%p)\",\n\t\t\t   cmd, virt);\n\t\thqvdp_dbg_dump_cmd(s, (struct sti_hqvdp_cmd *)virt);\n\t}\n\n\tseq_putc(s, '\\n');\n\treturn 0;\n}\n\nstatic struct drm_info_list hqvdp_debugfs_files[] = {\n\t{ \"hqvdp\", hqvdp_dbg_show, 0, NULL },\n};\n\nstatic void hqvdp_debugfs_init(struct sti_hqvdp *hqvdp, struct drm_minor *minor)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < ARRAY_SIZE(hqvdp_debugfs_files); i++)\n\t\thqvdp_debugfs_files[i].data = hqvdp;\n\n\tdrm_debugfs_create_files(hqvdp_debugfs_files,\n\t\t\t\t ARRAY_SIZE(hqvdp_debugfs_files),\n\t\t\t\t minor->debugfs_root, minor);\n}\n\n \nstatic void sti_hqvdp_update_hvsrc(enum sti_hvsrc_orient orient, int scale,\n\t\tstruct sti_hqvdp_hvsrc *hvsrc)\n{\n\tconst int *coef_c, *coef_y;\n\tint shift_c, shift_y;\n\n\t \n\tif (scale < SCALE_MAX_FOR_LEG_LUT_F) {\n\t\tcoef_y = coef_lut_f_y_legacy;\n\t\tcoef_c = coef_lut_f_c_legacy;\n\t\tshift_y = SHIFT_LUT_F_Y_LEGACY;\n\t\tshift_c = SHIFT_LUT_F_C_LEGACY;\n\t} else if (scale < SCALE_MAX_FOR_LEG_LUT_E) {\n\t\tcoef_y = coef_lut_e_y_legacy;\n\t\tcoef_c = coef_lut_e_c_legacy;\n\t\tshift_y = SHIFT_LUT_E_Y_LEGACY;\n\t\tshift_c = SHIFT_LUT_E_C_LEGACY;\n\t} else if (scale < SCALE_MAX_FOR_LEG_LUT_D) {\n\t\tcoef_y = coef_lut_d_y_legacy;\n\t\tcoef_c = coef_lut_d_c_legacy;\n\t\tshift_y = SHIFT_LUT_D_Y_LEGACY;\n\t\tshift_c = SHIFT_LUT_D_C_LEGACY;\n\t} else if (scale < SCALE_MAX_FOR_LEG_LUT_C) {\n\t\tcoef_y = coef_lut_c_y_legacy;\n\t\tcoef_c = coef_lut_c_c_legacy;\n\t\tshift_y = SHIFT_LUT_C_Y_LEGACY;\n\t\tshift_c = SHIFT_LUT_C_C_LEGACY;\n\t} else if (scale == SCALE_MAX_FOR_LEG_LUT_C) {\n\t\tcoef_y = coef_c = coef_lut_b;\n\t\tshift_y = shift_c = SHIFT_LUT_B;\n\t} else {\n\t\tcoef_y = coef_c = coef_lut_a_legacy;\n\t\tshift_y = shift_c = SHIFT_LUT_A_LEGACY;\n\t}\n\n\tif (orient == HVSRC_HORI) {\n\t\thvsrc->hori_shift = (shift_c << 16) | shift_y;\n\t\tmemcpy(hvsrc->yh_coef, coef_y, sizeof(hvsrc->yh_coef));\n\t\tmemcpy(hvsrc->ch_coef, coef_c, sizeof(hvsrc->ch_coef));\n\t} else {\n\t\thvsrc->vert_shift = (shift_c << 16) | shift_y;\n\t\tmemcpy(hvsrc->yv_coef, coef_y, sizeof(hvsrc->yv_coef));\n\t\tmemcpy(hvsrc->cv_coef, coef_c, sizeof(hvsrc->cv_coef));\n\t}\n}\n\n \nstatic bool sti_hqvdp_check_hw_scaling(struct sti_hqvdp *hqvdp,\n\t\t\t\t       struct drm_display_mode *mode,\n\t\t\t\t       int src_w, int src_h,\n\t\t\t\t       int dst_w, int dst_h)\n{\n\tunsigned long lfw;\n\tunsigned int inv_zy;\n\n\tlfw = mode->htotal * (clk_get_rate(hqvdp->clk) / 1000000);\n\tlfw /= max(src_w, dst_w) * mode->clock / 1000;\n\n\tinv_zy = DIV_ROUND_UP(src_h, dst_h);\n\n\treturn (inv_zy <= lfw) ? true : false;\n}\n\n \nstatic void sti_hqvdp_disable(struct sti_hqvdp *hqvdp)\n{\n\tint i;\n\n\tDRM_DEBUG_DRIVER(\"%s\\n\", sti_plane_to_str(&hqvdp->plane));\n\n\t \n\tif (sti_vtg_unregister_client(hqvdp->vtg, &hqvdp->vtg_nb))\n\t\tDRM_DEBUG_DRIVER(\"Warning: cannot unregister VTG notifier\\n\");\n\n\t \n\twritel(0, hqvdp->regs + HQVDP_MBX_NEXT_CMD);\n\n\tfor (i = 0; i < POLL_MAX_ATTEMPT; i++) {\n\t\tif (readl(hqvdp->regs + HQVDP_MBX_INFO_XP70)\n\t\t\t\t& INFO_XP70_FW_READY)\n\t\t\tbreak;\n\t\tmsleep(POLL_DELAY_MS);\n\t}\n\n\t \n\tclk_disable_unprepare(hqvdp->clk_pix_main);\n\n\tif (i == POLL_MAX_ATTEMPT)\n\t\tDRM_ERROR(\"XP70 could not revert to idle\\n\");\n\n\thqvdp->plane.status = STI_PLANE_DISABLED;\n\thqvdp->vtg_registered = false;\n}\n\n \nstatic int sti_hqvdp_vtg_cb(struct notifier_block *nb, unsigned long evt, void *data)\n{\n\tstruct sti_hqvdp *hqvdp = container_of(nb, struct sti_hqvdp, vtg_nb);\n\tint btm_cmd_offset, top_cmd_offest;\n\tstruct sti_hqvdp_cmd *btm_cmd, *top_cmd;\n\n\tif ((evt != VTG_TOP_FIELD_EVENT) && (evt != VTG_BOTTOM_FIELD_EVENT)) {\n\t\tDRM_DEBUG_DRIVER(\"Unknown event\\n\");\n\t\treturn 0;\n\t}\n\n\tif (hqvdp->plane.status == STI_PLANE_FLUSHING) {\n\t\t \n\t\tDRM_DEBUG_DRIVER(\"Vsync event received => disable %s\\n\",\n\t\t\t\t sti_plane_to_str(&hqvdp->plane));\n\n\t\tsti_hqvdp_disable(hqvdp);\n\t}\n\n\tif (hqvdp->btm_field_pending) {\n\t\t \n\t\tbtm_cmd_offset = sti_hqvdp_get_free_cmd(hqvdp);\n\t\ttop_cmd_offest = sti_hqvdp_get_curr_cmd(hqvdp);\n\t\tif ((btm_cmd_offset == -1) || (top_cmd_offest == -1)) {\n\t\t\tDRM_DEBUG_DRIVER(\"Warning: no cmd, will skip field\\n\");\n\t\t\treturn -EBUSY;\n\t\t}\n\n\t\tbtm_cmd = hqvdp->hqvdp_cmd + btm_cmd_offset;\n\t\ttop_cmd = hqvdp->hqvdp_cmd + top_cmd_offest;\n\n\t\tmemcpy(btm_cmd, top_cmd, sizeof(*btm_cmd));\n\n\t\tbtm_cmd->top.config = TOP_CONFIG_INTER_BTM;\n\t\tbtm_cmd->top.current_luma +=\n\t\t\t\tbtm_cmd->top.luma_src_pitch / 2;\n\t\tbtm_cmd->top.current_chroma +=\n\t\t\t\tbtm_cmd->top.chroma_src_pitch / 2;\n\n\t\t \n\t\twritel(hqvdp->hqvdp_cmd_paddr + btm_cmd_offset,\n\t\t\t\thqvdp->regs + HQVDP_MBX_NEXT_CMD);\n\n\t\thqvdp->btm_field_pending = false;\n\n\t\tdev_dbg(hqvdp->dev, \"%s Posted command:0x%x\\n\",\n\t\t\t\t__func__, hqvdp->hqvdp_cmd_paddr);\n\n\t\tsti_plane_update_fps(&hqvdp->plane, false, true);\n\t}\n\n\treturn 0;\n}\n\nstatic void sti_hqvdp_init(struct sti_hqvdp *hqvdp)\n{\n\tint size;\n\tdma_addr_t dma_addr;\n\n\thqvdp->vtg_nb.notifier_call = sti_hqvdp_vtg_cb;\n\n\t \n\tsize = NB_VDP_CMD * sizeof(struct sti_hqvdp_cmd);\n\thqvdp->hqvdp_cmd = dma_alloc_wc(hqvdp->dev, size,\n\t\t\t\t\t&dma_addr,\n\t\t\t\t\tGFP_KERNEL | GFP_DMA);\n\tif (!hqvdp->hqvdp_cmd) {\n\t\tDRM_ERROR(\"Failed to allocate memory for VDP cmd\\n\");\n\t\treturn;\n\t}\n\n\thqvdp->hqvdp_cmd_paddr = (u32)dma_addr;\n\tmemset(hqvdp->hqvdp_cmd, 0, size);\n}\n\nstatic void sti_hqvdp_init_plugs(struct sti_hqvdp *hqvdp)\n{\n\t \n\twritel(PLUG_PAGE_SIZE_256, hqvdp->regs + HQVDP_RD_PLUG_PAGE_SIZE);\n\twritel(PLUG_MIN_OPC_8, hqvdp->regs + HQVDP_RD_PLUG_MIN_OPC);\n\twritel(PLUG_MAX_OPC_64, hqvdp->regs + HQVDP_RD_PLUG_MAX_OPC);\n\twritel(PLUG_MAX_CHK_2X, hqvdp->regs + HQVDP_RD_PLUG_MAX_CHK);\n\twritel(PLUG_MAX_MSG_1X, hqvdp->regs + HQVDP_RD_PLUG_MAX_MSG);\n\twritel(PLUG_MIN_SPACE_1, hqvdp->regs + HQVDP_RD_PLUG_MIN_SPACE);\n\twritel(PLUG_CONTROL_ENABLE, hqvdp->regs + HQVDP_RD_PLUG_CONTROL);\n\n\twritel(PLUG_PAGE_SIZE_256, hqvdp->regs + HQVDP_WR_PLUG_PAGE_SIZE);\n\twritel(PLUG_MIN_OPC_8, hqvdp->regs + HQVDP_WR_PLUG_MIN_OPC);\n\twritel(PLUG_MAX_OPC_64, hqvdp->regs + HQVDP_WR_PLUG_MAX_OPC);\n\twritel(PLUG_MAX_CHK_2X, hqvdp->regs + HQVDP_WR_PLUG_MAX_CHK);\n\twritel(PLUG_MAX_MSG_1X, hqvdp->regs + HQVDP_WR_PLUG_MAX_MSG);\n\twritel(PLUG_MIN_SPACE_1, hqvdp->regs + HQVDP_WR_PLUG_MIN_SPACE);\n\twritel(PLUG_CONTROL_ENABLE, hqvdp->regs + HQVDP_WR_PLUG_CONTROL);\n}\n\n \nstatic void sti_hqvdp_start_xp70(struct sti_hqvdp *hqvdp)\n{\n\tconst struct firmware *firmware;\n\tu32 *fw_rd_plug, *fw_wr_plug, *fw_pmem, *fw_dmem;\n\tu8 *data;\n\tint i;\n\tstruct fw_header {\n\t\tint rd_size;\n\t\tint wr_size;\n\t\tint pmem_size;\n\t\tint dmem_size;\n\t} *header;\n\n\tDRM_DEBUG_DRIVER(\"\\n\");\n\n\tif (hqvdp->xp70_initialized) {\n\t\tDRM_DEBUG_DRIVER(\"HQVDP XP70 already initialized\\n\");\n\t\treturn;\n\t}\n\n\t \n\tif (request_firmware(&firmware, HQVDP_FMW_NAME, hqvdp->dev)) {\n\t\tDRM_ERROR(\"Can't get HQVDP firmware\\n\");\n\t\treturn;\n\t}\n\n\t \n\tif (!firmware) {\n\t\tDRM_ERROR(\"Firmware not available\\n\");\n\t\treturn;\n\t}\n\n\theader = (struct fw_header *)firmware->data;\n\tif (firmware->size < sizeof(*header)) {\n\t\tDRM_ERROR(\"Invalid firmware size (%zu)\\n\", firmware->size);\n\t\tgoto out;\n\t}\n\tif ((sizeof(*header) + header->rd_size + header->wr_size +\n\t\theader->pmem_size + header->dmem_size) != firmware->size) {\n\t\tDRM_ERROR(\"Invalid fmw structure (%zu+%d+%d+%d+%d != %zu)\\n\",\n\t\t\t  sizeof(*header), header->rd_size, header->wr_size,\n\t\t\t  header->pmem_size, header->dmem_size,\n\t\t\t  firmware->size);\n\t\tgoto out;\n\t}\n\n\tdata = (u8 *)firmware->data;\n\tdata += sizeof(*header);\n\tfw_rd_plug = (void *)data;\n\tdata += header->rd_size;\n\tfw_wr_plug = (void *)data;\n\tdata += header->wr_size;\n\tfw_pmem = (void *)data;\n\tdata += header->pmem_size;\n\tfw_dmem = (void *)data;\n\n\t \n\tif (clk_prepare_enable(hqvdp->clk))\n\t\tDRM_ERROR(\"Failed to prepare/enable HQVDP clk\\n\");\n\n\t \n\twritel(SW_RESET_CTRL_FULL, hqvdp->regs + HQVDP_MBX_SW_RESET_CTRL);\n\n\tfor (i = 0; i < POLL_MAX_ATTEMPT; i++) {\n\t\tif (readl(hqvdp->regs + HQVDP_MBX_STARTUP_CTRL1)\n\t\t\t\t& STARTUP_CTRL1_RST_DONE)\n\t\t\tbreak;\n\t\tmsleep(POLL_DELAY_MS);\n\t}\n\tif (i == POLL_MAX_ATTEMPT) {\n\t\tDRM_ERROR(\"Could not reset\\n\");\n\t\tclk_disable_unprepare(hqvdp->clk);\n\t\tgoto out;\n\t}\n\n\t \n\tfor (i = 0; i < header->rd_size / 4; i++)\n\t\twritel(fw_rd_plug[i], hqvdp->regs + HQVDP_RD_PLUG + i * 4);\n\tfor (i = 0; i < header->wr_size / 4; i++)\n\t\twritel(fw_wr_plug[i], hqvdp->regs + HQVDP_WR_PLUG + i * 4);\n\n\tsti_hqvdp_init_plugs(hqvdp);\n\n\t \n\twritel(STARTUP_CTRL1_AUTH_IDLE, hqvdp->regs + HQVDP_MBX_STARTUP_CTRL1);\n\n\t \n\twritel(SOFT_VSYNC_SW_CTRL_IRQ, hqvdp->regs + HQVDP_MBX_SOFT_VSYNC);\n\twritel(0, hqvdp->regs + HQVDP_MBX_NEXT_CMD);\n\n\t \n\tfor (i = 0; i < header->pmem_size / 4; i++)\n\t\twritel(fw_pmem[i], hqvdp->regs + HQVDP_PMEM + i * 4);\n\tfor (i = 0; i < header->dmem_size / 4; i++)\n\t\twritel(fw_dmem[i], hqvdp->regs + HQVDP_DMEM + i * 4);\n\n\t \n\twritel(STARTUP_CTRL2_FETCH_EN, hqvdp->regs + HQVDP_MBX_STARTUP_CTRL2);\n\n\t \n\tfor (i = 0; i < POLL_MAX_ATTEMPT; i++) {\n\t\tif (readl(hqvdp->regs + HQVDP_MBX_INFO_XP70)\n\t\t\t\t& INFO_XP70_FW_READY)\n\t\t\tbreak;\n\t\tmsleep(POLL_DELAY_MS);\n\t}\n\tif (i == POLL_MAX_ATTEMPT) {\n\t\tDRM_ERROR(\"Could not boot\\n\");\n\t\tclk_disable_unprepare(hqvdp->clk);\n\t\tgoto out;\n\t}\n\n\t \n\twritel(SOFT_VSYNC_HW, hqvdp->regs + HQVDP_MBX_SOFT_VSYNC);\n\n\tDRM_INFO(\"HQVDP XP70 initialized\\n\");\n\n\thqvdp->xp70_initialized = true;\n\nout:\n\trelease_firmware(firmware);\n}\n\nstatic int sti_hqvdp_atomic_check(struct drm_plane *drm_plane,\n\t\t\t\t  struct drm_atomic_state *state)\n{\n\tstruct drm_plane_state *new_plane_state = drm_atomic_get_new_plane_state(state,\n\t\t\t\t\t\t\t\t\t\t drm_plane);\n\tstruct sti_plane *plane = to_sti_plane(drm_plane);\n\tstruct sti_hqvdp *hqvdp = to_sti_hqvdp(plane);\n\tstruct drm_crtc *crtc = new_plane_state->crtc;\n\tstruct drm_framebuffer *fb = new_plane_state->fb;\n\tstruct drm_crtc_state *crtc_state;\n\tstruct drm_display_mode *mode;\n\tint dst_x, dst_y, dst_w, dst_h;\n\tint src_x, src_y, src_w, src_h;\n\n\t \n\tif (!crtc || !fb)\n\t\treturn 0;\n\n\tcrtc_state = drm_atomic_get_crtc_state(state, crtc);\n\tmode = &crtc_state->mode;\n\tdst_x = new_plane_state->crtc_x;\n\tdst_y = new_plane_state->crtc_y;\n\tdst_w = clamp_val(new_plane_state->crtc_w, 0, mode->hdisplay - dst_x);\n\tdst_h = clamp_val(new_plane_state->crtc_h, 0, mode->vdisplay - dst_y);\n\t \n\tsrc_x = new_plane_state->src_x >> 16;\n\tsrc_y = new_plane_state->src_y >> 16;\n\tsrc_w = new_plane_state->src_w >> 16;\n\tsrc_h = new_plane_state->src_h >> 16;\n\n\tif (mode->clock && !sti_hqvdp_check_hw_scaling(hqvdp, mode,\n\t\t\t\t\t\t       src_w, src_h,\n\t\t\t\t\t\t       dst_w, dst_h)) {\n\t\tDRM_ERROR(\"Scaling beyond HW capabilities\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (!drm_fb_dma_get_gem_obj(fb, 0)) {\n\t\tDRM_ERROR(\"Can't get DMA GEM object for fb\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tdst_w = ALIGN(dst_w, 2);\n\tdst_h = ALIGN(dst_h, 2);\n\n\tif ((src_w > MAX_WIDTH) || (src_w < MIN_WIDTH) ||\n\t    (src_h > MAX_HEIGHT) || (src_h < MIN_HEIGHT) ||\n\t    (dst_w > MAX_WIDTH) || (dst_w < MIN_WIDTH) ||\n\t    (dst_h > MAX_HEIGHT) || (dst_h < MIN_HEIGHT)) {\n\t\tDRM_ERROR(\"Invalid in/out size %dx%d -> %dx%d\\n\",\n\t\t\t  src_w, src_h,\n\t\t\t  dst_w, dst_h);\n\t\treturn -EINVAL;\n\t}\n\n\tif (!hqvdp->xp70_initialized)\n\t\t \n\t\tsti_hqvdp_start_xp70(hqvdp);\n\n\tif (!hqvdp->vtg_registered) {\n\t\t \n\t\tif (clk_prepare_enable(hqvdp->clk_pix_main)) {\n\t\t\tDRM_ERROR(\"Failed to prepare/enable pix main clk\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\t \n\t\tif (sti_vtg_register_client(hqvdp->vtg,\n\t\t\t\t\t    &hqvdp->vtg_nb,\n\t\t\t\t\t    crtc)) {\n\t\t\tDRM_ERROR(\"Cannot register VTG notifier\\n\");\n\t\t\tclk_disable_unprepare(hqvdp->clk_pix_main);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\thqvdp->vtg_registered = true;\n\t}\n\n\tDRM_DEBUG_KMS(\"CRTC:%d (%s) drm plane:%d (%s)\\n\",\n\t\t      crtc->base.id, sti_mixer_to_str(to_sti_mixer(crtc)),\n\t\t      drm_plane->base.id, sti_plane_to_str(plane));\n\tDRM_DEBUG_KMS(\"%s dst=(%dx%d)@(%d,%d) - src=(%dx%d)@(%d,%d)\\n\",\n\t\t      sti_plane_to_str(plane),\n\t\t      dst_w, dst_h, dst_x, dst_y,\n\t\t      src_w, src_h, src_x, src_y);\n\n\treturn 0;\n}\n\nstatic void sti_hqvdp_atomic_update(struct drm_plane *drm_plane,\n\t\t\t\t    struct drm_atomic_state *state)\n{\n\tstruct drm_plane_state *oldstate = drm_atomic_get_old_plane_state(state,\n\t\t\t\t\t\t\t\t\t  drm_plane);\n\tstruct drm_plane_state *newstate = drm_atomic_get_new_plane_state(state,\n\t\t\t\t\t\t\t\t\t  drm_plane);\n\tstruct sti_plane *plane = to_sti_plane(drm_plane);\n\tstruct sti_hqvdp *hqvdp = to_sti_hqvdp(plane);\n\tstruct drm_crtc *crtc = newstate->crtc;\n\tstruct drm_framebuffer *fb = newstate->fb;\n\tstruct drm_display_mode *mode;\n\tint dst_x, dst_y, dst_w, dst_h;\n\tint src_x, src_y, src_w, src_h;\n\tstruct drm_gem_dma_object *dma_obj;\n\tstruct sti_hqvdp_cmd *cmd;\n\tint scale_h, scale_v;\n\tint cmd_offset;\n\n\tif (!crtc || !fb)\n\t\treturn;\n\n\tif ((oldstate->fb == newstate->fb) &&\n\t    (oldstate->crtc_x == newstate->crtc_x) &&\n\t    (oldstate->crtc_y == newstate->crtc_y) &&\n\t    (oldstate->crtc_w == newstate->crtc_w) &&\n\t    (oldstate->crtc_h == newstate->crtc_h) &&\n\t    (oldstate->src_x == newstate->src_x) &&\n\t    (oldstate->src_y == newstate->src_y) &&\n\t    (oldstate->src_w == newstate->src_w) &&\n\t    (oldstate->src_h == newstate->src_h)) {\n\t\t \n\t\tDRM_DEBUG_DRIVER(\"No change, not posting cmd\\n\");\n\t\tplane->status = STI_PLANE_UPDATED;\n\t\treturn;\n\t}\n\n\tmode = &crtc->mode;\n\tdst_x = newstate->crtc_x;\n\tdst_y = newstate->crtc_y;\n\tdst_w = clamp_val(newstate->crtc_w, 0, mode->hdisplay - dst_x);\n\tdst_h = clamp_val(newstate->crtc_h, 0, mode->vdisplay - dst_y);\n\t \n\tsrc_x = newstate->src_x >> 16;\n\tsrc_y = newstate->src_y >> 16;\n\tsrc_w = newstate->src_w >> 16;\n\tsrc_h = newstate->src_h >> 16;\n\n\tcmd_offset = sti_hqvdp_get_free_cmd(hqvdp);\n\tif (cmd_offset == -1) {\n\t\tDRM_DEBUG_DRIVER(\"Warning: no cmd, will skip frame\\n\");\n\t\treturn;\n\t}\n\tcmd = hqvdp->hqvdp_cmd + cmd_offset;\n\n\t \n\tcmd->top.config = TOP_CONFIG_PROGRESSIVE;\n\tcmd->top.mem_format = TOP_MEM_FORMAT_DFLT;\n\tcmd->hvsrc.param_ctrl = HVSRC_PARAM_CTRL_DFLT;\n\tcmd->csdi.config = CSDI_CONFIG_PROG;\n\n\t \n\tcmd->iqi.config = IQI_CONFIG_DFLT;\n\tcmd->iqi.con_bri = IQI_CON_BRI_DFLT;\n\tcmd->iqi.sat_gain = IQI_SAT_GAIN_DFLT;\n\tcmd->iqi.pxf_conf = IQI_PXF_CONF_DFLT;\n\n\tdma_obj = drm_fb_dma_get_gem_obj(fb, 0);\n\n\tDRM_DEBUG_DRIVER(\"drm FB:%d format:%.4s phys@:0x%lx\\n\", fb->base.id,\n\t\t\t (char *)&fb->format->format,\n\t\t\t (unsigned long) dma_obj->dma_addr);\n\n\t \n\tcmd->top.current_luma = (u32) dma_obj->dma_addr + fb->offsets[0];\n\tcmd->top.current_chroma = (u32) dma_obj->dma_addr + fb->offsets[1];\n\n\t \n\tcmd->top.luma_processed_pitch = fb->pitches[0];\n\tcmd->top.luma_src_pitch = fb->pitches[0];\n\tcmd->top.chroma_processed_pitch = fb->pitches[1];\n\tcmd->top.chroma_src_pitch = fb->pitches[1];\n\n\t \n\tdst_w = ALIGN(dst_w, 2);\n\tdst_h = ALIGN(dst_h, 2);\n\n\tcmd->top.input_viewport_size = src_h << 16 | src_w;\n\tcmd->top.input_frame_size = src_h << 16 | src_w;\n\tcmd->hvsrc.output_picture_size = dst_h << 16 | dst_w;\n\tcmd->top.input_viewport_ori = src_y << 16 | src_x;\n\n\t \n\tif (fb->flags & DRM_MODE_FB_INTERLACED) {\n\t\t \n\t\tcmd->top.config = TOP_CONFIG_INTER_TOP;\n\n\t\t \n\t\tcmd->top.input_frame_size = (src_h / 2) << 16 | src_w;\n\t\tcmd->top.luma_processed_pitch *= 2;\n\t\tcmd->top.luma_src_pitch *= 2;\n\t\tcmd->top.chroma_processed_pitch *= 2;\n\t\tcmd->top.chroma_src_pitch *= 2;\n\n\t\t \n\t\tcmd->csdi.config = CSDI_CONFIG_INTER_DIR;\n\t\tcmd->csdi.config2 = CSDI_CONFIG2_DFLT;\n\t\tcmd->csdi.dcdi_config = CSDI_DCDI_CONFIG_DFLT;\n\t}\n\n\t \n\tscale_h = SCALE_FACTOR * dst_w / src_w;\n\tsti_hqvdp_update_hvsrc(HVSRC_HORI, scale_h, &cmd->hvsrc);\n\n\tscale_v = SCALE_FACTOR * dst_h / src_h;\n\tsti_hqvdp_update_hvsrc(HVSRC_VERT, scale_v, &cmd->hvsrc);\n\n\twritel(hqvdp->hqvdp_cmd_paddr + cmd_offset,\n\t       hqvdp->regs + HQVDP_MBX_NEXT_CMD);\n\n\t \n\tif (fb->flags & DRM_MODE_FB_INTERLACED)\n\t\thqvdp->btm_field_pending = true;\n\n\tdev_dbg(hqvdp->dev, \"%s Posted command:0x%x\\n\",\n\t\t__func__, hqvdp->hqvdp_cmd_paddr + cmd_offset);\n\n\tsti_plane_update_fps(plane, true, true);\n\n\tplane->status = STI_PLANE_UPDATED;\n}\n\nstatic void sti_hqvdp_atomic_disable(struct drm_plane *drm_plane,\n\t\t\t\t     struct drm_atomic_state *state)\n{\n\tstruct drm_plane_state *oldstate = drm_atomic_get_old_plane_state(state,\n\t\t\t\t\t\t\t\t\t  drm_plane);\n\tstruct sti_plane *plane = to_sti_plane(drm_plane);\n\n\tif (!oldstate->crtc) {\n\t\tDRM_DEBUG_DRIVER(\"drm plane:%d not enabled\\n\",\n\t\t\t\t drm_plane->base.id);\n\t\treturn;\n\t}\n\n\tDRM_DEBUG_DRIVER(\"CRTC:%d (%s) drm plane:%d (%s)\\n\",\n\t\t\t oldstate->crtc->base.id,\n\t\t\t sti_mixer_to_str(to_sti_mixer(oldstate->crtc)),\n\t\t\t drm_plane->base.id, sti_plane_to_str(plane));\n\n\tplane->status = STI_PLANE_DISABLING;\n}\n\nstatic const struct drm_plane_helper_funcs sti_hqvdp_helpers_funcs = {\n\t.atomic_check = sti_hqvdp_atomic_check,\n\t.atomic_update = sti_hqvdp_atomic_update,\n\t.atomic_disable = sti_hqvdp_atomic_disable,\n};\n\nstatic int sti_hqvdp_late_register(struct drm_plane *drm_plane)\n{\n\tstruct sti_plane *plane = to_sti_plane(drm_plane);\n\tstruct sti_hqvdp *hqvdp = to_sti_hqvdp(plane);\n\n\thqvdp_debugfs_init(hqvdp, drm_plane->dev->primary);\n\n\treturn 0;\n}\n\nstatic const struct drm_plane_funcs sti_hqvdp_plane_helpers_funcs = {\n\t.update_plane = drm_atomic_helper_update_plane,\n\t.disable_plane = drm_atomic_helper_disable_plane,\n\t.destroy = drm_plane_cleanup,\n\t.reset = drm_atomic_helper_plane_reset,\n\t.atomic_duplicate_state = drm_atomic_helper_plane_duplicate_state,\n\t.atomic_destroy_state = drm_atomic_helper_plane_destroy_state,\n\t.late_register = sti_hqvdp_late_register,\n};\n\nstatic struct drm_plane *sti_hqvdp_create(struct drm_device *drm_dev,\n\t\t\t\t\t  struct device *dev, int desc)\n{\n\tstruct sti_hqvdp *hqvdp = dev_get_drvdata(dev);\n\tint res;\n\n\thqvdp->plane.desc = desc;\n\thqvdp->plane.status = STI_PLANE_DISABLED;\n\n\tsti_hqvdp_init(hqvdp);\n\n\tres = drm_universal_plane_init(drm_dev, &hqvdp->plane.drm_plane, 1,\n\t\t\t\t       &sti_hqvdp_plane_helpers_funcs,\n\t\t\t\t       hqvdp_supported_formats,\n\t\t\t\t       ARRAY_SIZE(hqvdp_supported_formats),\n\t\t\t\t       NULL, DRM_PLANE_TYPE_OVERLAY, NULL);\n\tif (res) {\n\t\tDRM_ERROR(\"Failed to initialize universal plane\\n\");\n\t\treturn NULL;\n\t}\n\n\tdrm_plane_helper_add(&hqvdp->plane.drm_plane, &sti_hqvdp_helpers_funcs);\n\n\tsti_plane_init_property(&hqvdp->plane, DRM_PLANE_TYPE_OVERLAY);\n\n\treturn &hqvdp->plane.drm_plane;\n}\n\nstatic int sti_hqvdp_bind(struct device *dev, struct device *master, void *data)\n{\n\tstruct sti_hqvdp *hqvdp = dev_get_drvdata(dev);\n\tstruct drm_device *drm_dev = data;\n\tstruct drm_plane *plane;\n\n\tDRM_DEBUG_DRIVER(\"\\n\");\n\n\thqvdp->drm_dev = drm_dev;\n\n\t \n\tplane = sti_hqvdp_create(drm_dev, hqvdp->dev, STI_HQVDP_0);\n\tif (!plane)\n\t\tDRM_ERROR(\"Can't create HQVDP plane\\n\");\n\n\treturn 0;\n}\n\nstatic void sti_hqvdp_unbind(struct device *dev,\n\t\tstruct device *master, void *data)\n{\n\t \n}\n\nstatic const struct component_ops sti_hqvdp_ops = {\n\t.bind = sti_hqvdp_bind,\n\t.unbind = sti_hqvdp_unbind,\n};\n\nstatic int sti_hqvdp_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct device_node *vtg_np;\n\tstruct sti_hqvdp *hqvdp;\n\tstruct resource *res;\n\n\tDRM_DEBUG_DRIVER(\"\\n\");\n\n\thqvdp = devm_kzalloc(dev, sizeof(*hqvdp), GFP_KERNEL);\n\tif (!hqvdp) {\n\t\tDRM_ERROR(\"Failed to allocate HQVDP context\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\thqvdp->dev = dev;\n\n\t \n\tres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\n\tif (!res) {\n\t\tDRM_ERROR(\"Get memory resource failed\\n\");\n\t\treturn -ENXIO;\n\t}\n\thqvdp->regs = devm_ioremap(dev, res->start, resource_size(res));\n\tif (!hqvdp->regs) {\n\t\tDRM_ERROR(\"Register mapping failed\\n\");\n\t\treturn -ENXIO;\n\t}\n\n\t \n\thqvdp->clk = devm_clk_get(dev, \"hqvdp\");\n\thqvdp->clk_pix_main = devm_clk_get(dev, \"pix_main\");\n\tif (IS_ERR(hqvdp->clk) || IS_ERR(hqvdp->clk_pix_main)) {\n\t\tDRM_ERROR(\"Cannot get clocks\\n\");\n\t\treturn -ENXIO;\n\t}\n\n\t \n\thqvdp->reset = devm_reset_control_get(dev, \"hqvdp\");\n\tif (!IS_ERR(hqvdp->reset))\n\t\treset_control_deassert(hqvdp->reset);\n\n\tvtg_np = of_parse_phandle(pdev->dev.of_node, \"st,vtg\", 0);\n\tif (vtg_np)\n\t\thqvdp->vtg = of_vtg_find(vtg_np);\n\tof_node_put(vtg_np);\n\n\tplatform_set_drvdata(pdev, hqvdp);\n\n\treturn component_add(&pdev->dev, &sti_hqvdp_ops);\n}\n\nstatic void sti_hqvdp_remove(struct platform_device *pdev)\n{\n\tcomponent_del(&pdev->dev, &sti_hqvdp_ops);\n}\n\nstatic const struct of_device_id hqvdp_of_match[] = {\n\t{ .compatible = \"st,stih407-hqvdp\", },\n\t{   }\n};\nMODULE_DEVICE_TABLE(of, hqvdp_of_match);\n\nstruct platform_driver sti_hqvdp_driver = {\n\t.driver = {\n\t\t.name = \"sti-hqvdp\",\n\t\t.owner = THIS_MODULE,\n\t\t.of_match_table = hqvdp_of_match,\n\t},\n\t.probe = sti_hqvdp_probe,\n\t.remove_new = sti_hqvdp_remove,\n};\n\nMODULE_AUTHOR(\"Benjamin Gaignard <benjamin.gaignard@st.com>\");\nMODULE_DESCRIPTION(\"STMicroelectronics SoC DRM driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}