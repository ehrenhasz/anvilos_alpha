{
  "module_name": "sti_dvo.c",
  "hash_id": "b82db0323449971883deda76e4310746ebc053e50698424907307fd1c24c13c1",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/sti/sti_dvo.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/component.h>\n#include <linux/debugfs.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n\n#include <drm/drm_atomic_helper.h>\n#include <drm/drm_bridge.h>\n#include <drm/drm_device.h>\n#include <drm/drm_panel.h>\n#include <drm/drm_print.h>\n#include <drm/drm_probe_helper.h>\n\n#include \"sti_awg_utils.h\"\n#include \"sti_drv.h\"\n#include \"sti_mixer.h\"\n\n \n#define DVO_AWG_DIGSYNC_CTRL      0x0000\n#define DVO_DOF_CFG               0x0004\n#define DVO_LUT_PROG_LOW          0x0008\n#define DVO_LUT_PROG_MID          0x000C\n#define DVO_LUT_PROG_HIGH         0x0010\n#define DVO_DIGSYNC_INSTR_I       0x0100\n\n#define DVO_AWG_CTRL_EN           BIT(0)\n#define DVO_AWG_FRAME_BASED_SYNC  BIT(2)\n\n#define DVO_DOF_EN_LOWBYTE        BIT(0)\n#define DVO_DOF_EN_MIDBYTE        BIT(1)\n#define DVO_DOF_EN_HIGHBYTE       BIT(2)\n#define DVO_DOF_EN                BIT(6)\n#define DVO_DOF_MOD_COUNT_SHIFT   8\n\n#define DVO_LUT_ZERO              0\n#define DVO_LUT_Y_G               1\n#define DVO_LUT_Y_G_DEL           2\n#define DVO_LUT_CB_B              3\n#define DVO_LUT_CB_B_DEL          4\n#define DVO_LUT_CR_R              5\n#define DVO_LUT_CR_R_DEL          6\n#define DVO_LUT_HOLD              7\n\nstruct dvo_config {\n\tu32 flags;\n\tu32 lowbyte;\n\tu32 midbyte;\n\tu32 highbyte;\n\tint (*awg_fwgen_fct)(\n\t\t\tstruct awg_code_generation_params *fw_gen_params,\n\t\t\tstruct awg_timing *timing);\n};\n\nstatic struct dvo_config rgb_24bit_de_cfg = {\n\t.flags         = (0L << DVO_DOF_MOD_COUNT_SHIFT),\n\t.lowbyte       = DVO_LUT_CR_R,\n\t.midbyte       = DVO_LUT_Y_G,\n\t.highbyte      = DVO_LUT_CB_B,\n\t.awg_fwgen_fct = sti_awg_generate_code_data_enable_mode,\n};\n\n \nstruct sti_dvo {\n\tstruct device dev;\n\tstruct drm_device *drm_dev;\n\tstruct drm_display_mode mode;\n\tvoid __iomem *regs;\n\tstruct clk *clk_pix;\n\tstruct clk *clk;\n\tstruct clk *clk_main_parent;\n\tstruct clk *clk_aux_parent;\n\tstruct device_node *panel_node;\n\tstruct drm_panel *panel;\n\tstruct dvo_config *config;\n\tbool enabled;\n\tstruct drm_encoder *encoder;\n\tstruct drm_bridge *bridge;\n};\n\nstruct sti_dvo_connector {\n\tstruct drm_connector drm_connector;\n\tstruct drm_encoder *encoder;\n\tstruct sti_dvo *dvo;\n};\n\n#define to_sti_dvo_connector(x) \\\n\tcontainer_of(x, struct sti_dvo_connector, drm_connector)\n\n#define BLANKING_LEVEL 16\nstatic int dvo_awg_generate_code(struct sti_dvo *dvo, u8 *ram_size, u32 *ram_code)\n{\n\tstruct drm_display_mode *mode = &dvo->mode;\n\tstruct dvo_config *config = dvo->config;\n\tstruct awg_code_generation_params fw_gen_params;\n\tstruct awg_timing timing;\n\n\tfw_gen_params.ram_code = ram_code;\n\tfw_gen_params.instruction_offset = 0;\n\n\ttiming.total_lines = mode->vtotal;\n\ttiming.active_lines = mode->vdisplay;\n\ttiming.blanking_lines = mode->vsync_start - mode->vdisplay;\n\ttiming.trailing_lines = mode->vtotal - mode->vsync_start;\n\ttiming.total_pixels = mode->htotal;\n\ttiming.active_pixels = mode->hdisplay;\n\ttiming.blanking_pixels = mode->hsync_start - mode->hdisplay;\n\ttiming.trailing_pixels = mode->htotal - mode->hsync_start;\n\ttiming.blanking_level = BLANKING_LEVEL;\n\n\tif (config->awg_fwgen_fct(&fw_gen_params, &timing)) {\n\t\tDRM_ERROR(\"AWG firmware not properly generated\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t*ram_size = fw_gen_params.instruction_offset;\n\n\treturn 0;\n}\n\n \nstatic void dvo_awg_configure(struct sti_dvo *dvo, u32 *awg_ram_code, int nb)\n{\n\tint i;\n\n\tDRM_DEBUG_DRIVER(\"\\n\");\n\n\tfor (i = 0; i < nb; i++)\n\t\twritel(awg_ram_code[i],\n\t\t       dvo->regs + DVO_DIGSYNC_INSTR_I + i * 4);\n\tfor (i = nb; i < AWG_MAX_INST; i++)\n\t\twritel(0, dvo->regs + DVO_DIGSYNC_INSTR_I + i * 4);\n\n\twritel(DVO_AWG_CTRL_EN, dvo->regs + DVO_AWG_DIGSYNC_CTRL);\n}\n\n#define DBGFS_DUMP(reg) seq_printf(s, \"\\n  %-25s 0x%08X\", #reg, \\\n\t\t\t\t   readl(dvo->regs + reg))\n\nstatic void dvo_dbg_awg_microcode(struct seq_file *s, void __iomem *reg)\n{\n\tunsigned int i;\n\n\tseq_puts(s, \"\\n\\n\");\n\tseq_puts(s, \"  DVO AWG microcode:\");\n\tfor (i = 0; i < AWG_MAX_INST; i++) {\n\t\tif (i % 8 == 0)\n\t\t\tseq_printf(s, \"\\n  %04X:\", i);\n\t\tseq_printf(s, \" %04X\", readl(reg + i * 4));\n\t}\n}\n\nstatic int dvo_dbg_show(struct seq_file *s, void *data)\n{\n\tstruct drm_info_node *node = s->private;\n\tstruct sti_dvo *dvo = (struct sti_dvo *)node->info_ent->data;\n\n\tseq_printf(s, \"DVO: (vaddr = 0x%p)\", dvo->regs);\n\tDBGFS_DUMP(DVO_AWG_DIGSYNC_CTRL);\n\tDBGFS_DUMP(DVO_DOF_CFG);\n\tDBGFS_DUMP(DVO_LUT_PROG_LOW);\n\tDBGFS_DUMP(DVO_LUT_PROG_MID);\n\tDBGFS_DUMP(DVO_LUT_PROG_HIGH);\n\tdvo_dbg_awg_microcode(s, dvo->regs + DVO_DIGSYNC_INSTR_I);\n\tseq_putc(s, '\\n');\n\treturn 0;\n}\n\nstatic struct drm_info_list dvo_debugfs_files[] = {\n\t{ \"dvo\", dvo_dbg_show, 0, NULL },\n};\n\nstatic void dvo_debugfs_init(struct sti_dvo *dvo, struct drm_minor *minor)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < ARRAY_SIZE(dvo_debugfs_files); i++)\n\t\tdvo_debugfs_files[i].data = dvo;\n\n\tdrm_debugfs_create_files(dvo_debugfs_files,\n\t\t\t\t ARRAY_SIZE(dvo_debugfs_files),\n\t\t\t\t minor->debugfs_root, minor);\n}\n\nstatic void sti_dvo_disable(struct drm_bridge *bridge)\n{\n\tstruct sti_dvo *dvo = bridge->driver_private;\n\n\tif (!dvo->enabled)\n\t\treturn;\n\n\tDRM_DEBUG_DRIVER(\"\\n\");\n\n\tif (dvo->config->awg_fwgen_fct)\n\t\twritel(0x00000000, dvo->regs + DVO_AWG_DIGSYNC_CTRL);\n\n\twritel(0x00000000, dvo->regs + DVO_DOF_CFG);\n\n\tdrm_panel_disable(dvo->panel);\n\n\t \n\tclk_disable_unprepare(dvo->clk_pix);\n\tclk_disable_unprepare(dvo->clk);\n\n\tdvo->enabled = false;\n}\n\nstatic void sti_dvo_pre_enable(struct drm_bridge *bridge)\n{\n\tstruct sti_dvo *dvo = bridge->driver_private;\n\tstruct dvo_config *config = dvo->config;\n\tu32 val;\n\n\tDRM_DEBUG_DRIVER(\"\\n\");\n\n\tif (dvo->enabled)\n\t\treturn;\n\n\t \n\twritel(0x00000000, dvo->regs + DVO_DOF_CFG);\n\twritel(0x00000000, dvo->regs + DVO_AWG_DIGSYNC_CTRL);\n\n\tif (config->awg_fwgen_fct) {\n\t\tu8 nb_instr;\n\t\tu32 awg_ram_code[AWG_MAX_INST];\n\t\t \n\t\tif (!dvo_awg_generate_code(dvo, &nb_instr, awg_ram_code))\n\t\t\tdvo_awg_configure(dvo, awg_ram_code, nb_instr);\n\t\telse\n\t\t\treturn;\n\t}\n\n\t \n\tif (clk_prepare_enable(dvo->clk_pix))\n\t\tDRM_ERROR(\"Failed to prepare/enable dvo_pix clk\\n\");\n\tif (clk_prepare_enable(dvo->clk))\n\t\tDRM_ERROR(\"Failed to prepare/enable dvo clk\\n\");\n\n\tdrm_panel_enable(dvo->panel);\n\n\t \n\twritel(config->lowbyte,  dvo->regs + DVO_LUT_PROG_LOW);\n\twritel(config->midbyte,  dvo->regs + DVO_LUT_PROG_MID);\n\twritel(config->highbyte, dvo->regs + DVO_LUT_PROG_HIGH);\n\n\t \n\tval = (config->flags | DVO_DOF_EN);\n\twritel(val, dvo->regs + DVO_DOF_CFG);\n\n\tdvo->enabled = true;\n}\n\nstatic void sti_dvo_set_mode(struct drm_bridge *bridge,\n\t\t\t     const struct drm_display_mode *mode,\n\t\t\t     const struct drm_display_mode *adjusted_mode)\n{\n\tstruct sti_dvo *dvo = bridge->driver_private;\n\tstruct sti_mixer *mixer = to_sti_mixer(dvo->encoder->crtc);\n\tint rate = mode->clock * 1000;\n\tstruct clk *clkp;\n\tint ret;\n\n\tDRM_DEBUG_DRIVER(\"\\n\");\n\n\tdrm_mode_copy(&dvo->mode, mode);\n\n\t \n\tif (mixer->id == STI_MIXER_MAIN)\n\t\tclkp = dvo->clk_main_parent;\n\telse\n\t\tclkp = dvo->clk_aux_parent;\n\n\tif (clkp) {\n\t\tclk_set_parent(dvo->clk_pix, clkp);\n\t\tclk_set_parent(dvo->clk, clkp);\n\t}\n\n\t \n\tret = clk_set_rate(dvo->clk_pix, rate);\n\tif (ret < 0) {\n\t\tDRM_ERROR(\"Cannot set rate (%dHz) for dvo_pix clk\\n\", rate);\n\t\treturn;\n\t}\n\n\tret = clk_set_rate(dvo->clk, rate);\n\tif (ret < 0) {\n\t\tDRM_ERROR(\"Cannot set rate (%dHz) for dvo clk\\n\", rate);\n\t\treturn;\n\t}\n\n\t \n\tdvo->config = &rgb_24bit_de_cfg;\n}\n\nstatic void sti_dvo_bridge_nope(struct drm_bridge *bridge)\n{\n\t \n}\n\nstatic const struct drm_bridge_funcs sti_dvo_bridge_funcs = {\n\t.pre_enable = sti_dvo_pre_enable,\n\t.enable = sti_dvo_bridge_nope,\n\t.disable = sti_dvo_disable,\n\t.post_disable = sti_dvo_bridge_nope,\n\t.mode_set = sti_dvo_set_mode,\n};\n\nstatic int sti_dvo_connector_get_modes(struct drm_connector *connector)\n{\n\tstruct sti_dvo_connector *dvo_connector\n\t\t= to_sti_dvo_connector(connector);\n\tstruct sti_dvo *dvo = dvo_connector->dvo;\n\n\tif (dvo->panel)\n\t\treturn drm_panel_get_modes(dvo->panel, connector);\n\n\treturn 0;\n}\n\n#define CLK_TOLERANCE_HZ 50\n\nstatic enum drm_mode_status\nsti_dvo_connector_mode_valid(struct drm_connector *connector,\n\t\t\t     struct drm_display_mode *mode)\n{\n\tint target = mode->clock * 1000;\n\tint target_min = target - CLK_TOLERANCE_HZ;\n\tint target_max = target + CLK_TOLERANCE_HZ;\n\tint result;\n\tstruct sti_dvo_connector *dvo_connector\n\t\t= to_sti_dvo_connector(connector);\n\tstruct sti_dvo *dvo = dvo_connector->dvo;\n\n\tresult = clk_round_rate(dvo->clk_pix, target);\n\n\tDRM_DEBUG_DRIVER(\"target rate = %d => available rate = %d\\n\",\n\t\t\t target, result);\n\n\tif ((result < target_min) || (result > target_max)) {\n\t\tDRM_DEBUG_DRIVER(\"dvo pixclk=%d not supported\\n\", target);\n\t\treturn MODE_BAD;\n\t}\n\n\treturn MODE_OK;\n}\n\nstatic const\nstruct drm_connector_helper_funcs sti_dvo_connector_helper_funcs = {\n\t.get_modes = sti_dvo_connector_get_modes,\n\t.mode_valid = sti_dvo_connector_mode_valid,\n};\n\nstatic enum drm_connector_status\nsti_dvo_connector_detect(struct drm_connector *connector, bool force)\n{\n\tstruct sti_dvo_connector *dvo_connector\n\t\t= to_sti_dvo_connector(connector);\n\tstruct sti_dvo *dvo = dvo_connector->dvo;\n\n\tDRM_DEBUG_DRIVER(\"\\n\");\n\n\tif (!dvo->panel) {\n\t\tdvo->panel = of_drm_find_panel(dvo->panel_node);\n\t\tif (IS_ERR(dvo->panel))\n\t\t\tdvo->panel = NULL;\n\t}\n\n\tif (dvo->panel)\n\t\treturn connector_status_connected;\n\n\treturn connector_status_disconnected;\n}\n\nstatic int sti_dvo_late_register(struct drm_connector *connector)\n{\n\tstruct sti_dvo_connector *dvo_connector\n\t\t= to_sti_dvo_connector(connector);\n\tstruct sti_dvo *dvo = dvo_connector->dvo;\n\n\tdvo_debugfs_init(dvo, dvo->drm_dev->primary);\n\n\treturn 0;\n}\n\nstatic const struct drm_connector_funcs sti_dvo_connector_funcs = {\n\t.fill_modes = drm_helper_probe_single_connector_modes,\n\t.detect = sti_dvo_connector_detect,\n\t.destroy = drm_connector_cleanup,\n\t.reset = drm_atomic_helper_connector_reset,\n\t.atomic_duplicate_state = drm_atomic_helper_connector_duplicate_state,\n\t.atomic_destroy_state = drm_atomic_helper_connector_destroy_state,\n\t.late_register = sti_dvo_late_register,\n};\n\nstatic struct drm_encoder *sti_dvo_find_encoder(struct drm_device *dev)\n{\n\tstruct drm_encoder *encoder;\n\n\tlist_for_each_entry(encoder, &dev->mode_config.encoder_list, head) {\n\t\tif (encoder->encoder_type == DRM_MODE_ENCODER_LVDS)\n\t\t\treturn encoder;\n\t}\n\n\treturn NULL;\n}\n\nstatic int sti_dvo_bind(struct device *dev, struct device *master, void *data)\n{\n\tstruct sti_dvo *dvo = dev_get_drvdata(dev);\n\tstruct drm_device *drm_dev = data;\n\tstruct drm_encoder *encoder;\n\tstruct sti_dvo_connector *connector;\n\tstruct drm_connector *drm_connector;\n\tstruct drm_bridge *bridge;\n\tint err;\n\n\t \n\tdvo->drm_dev = drm_dev;\n\n\tencoder = sti_dvo_find_encoder(drm_dev);\n\tif (!encoder)\n\t\treturn -ENOMEM;\n\n\tconnector = devm_kzalloc(dev, sizeof(*connector), GFP_KERNEL);\n\tif (!connector)\n\t\treturn -ENOMEM;\n\n\tconnector->dvo = dvo;\n\n\tbridge = devm_kzalloc(dev, sizeof(*bridge), GFP_KERNEL);\n\tif (!bridge)\n\t\treturn -ENOMEM;\n\n\tbridge->driver_private = dvo;\n\tbridge->funcs = &sti_dvo_bridge_funcs;\n\tbridge->of_node = dvo->dev.of_node;\n\tdrm_bridge_add(bridge);\n\n\terr = drm_bridge_attach(encoder, bridge, NULL, 0);\n\tif (err)\n\t\treturn err;\n\n\tdvo->bridge = bridge;\n\tconnector->encoder = encoder;\n\tdvo->encoder = encoder;\n\n\tdrm_connector = (struct drm_connector *)connector;\n\n\tdrm_connector->polled = DRM_CONNECTOR_POLL_HPD;\n\n\tdrm_connector_init(drm_dev, drm_connector,\n\t\t\t   &sti_dvo_connector_funcs, DRM_MODE_CONNECTOR_LVDS);\n\tdrm_connector_helper_add(drm_connector,\n\t\t\t\t &sti_dvo_connector_helper_funcs);\n\n\terr = drm_connector_attach_encoder(drm_connector, encoder);\n\tif (err) {\n\t\tDRM_ERROR(\"Failed to attach a connector to a encoder\\n\");\n\t\tgoto err_sysfs;\n\t}\n\n\treturn 0;\n\nerr_sysfs:\n\tdrm_bridge_remove(bridge);\n\treturn -EINVAL;\n}\n\nstatic void sti_dvo_unbind(struct device *dev,\n\t\t\t   struct device *master, void *data)\n{\n\tstruct sti_dvo *dvo = dev_get_drvdata(dev);\n\n\tdrm_bridge_remove(dvo->bridge);\n}\n\nstatic const struct component_ops sti_dvo_ops = {\n\t.bind = sti_dvo_bind,\n\t.unbind = sti_dvo_unbind,\n};\n\nstatic int sti_dvo_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct sti_dvo *dvo;\n\tstruct resource *res;\n\tstruct device_node *np = dev->of_node;\n\n\tDRM_INFO(\"%s\\n\", __func__);\n\n\tdvo = devm_kzalloc(dev, sizeof(*dvo), GFP_KERNEL);\n\tif (!dvo) {\n\t\tDRM_ERROR(\"Failed to allocate memory for DVO\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tdvo->dev = pdev->dev;\n\n\tres = platform_get_resource_byname(pdev, IORESOURCE_MEM, \"dvo-reg\");\n\tif (!res) {\n\t\tDRM_ERROR(\"Invalid dvo resource\\n\");\n\t\treturn -ENOMEM;\n\t}\n\tdvo->regs = devm_ioremap(dev, res->start,\n\t\t\tresource_size(res));\n\tif (!dvo->regs)\n\t\treturn -ENOMEM;\n\n\tdvo->clk_pix = devm_clk_get(dev, \"dvo_pix\");\n\tif (IS_ERR(dvo->clk_pix)) {\n\t\tDRM_ERROR(\"Cannot get dvo_pix clock\\n\");\n\t\treturn PTR_ERR(dvo->clk_pix);\n\t}\n\n\tdvo->clk = devm_clk_get(dev, \"dvo\");\n\tif (IS_ERR(dvo->clk)) {\n\t\tDRM_ERROR(\"Cannot get dvo clock\\n\");\n\t\treturn PTR_ERR(dvo->clk);\n\t}\n\n\tdvo->clk_main_parent = devm_clk_get(dev, \"main_parent\");\n\tif (IS_ERR(dvo->clk_main_parent)) {\n\t\tDRM_DEBUG_DRIVER(\"Cannot get main_parent clock\\n\");\n\t\tdvo->clk_main_parent = NULL;\n\t}\n\n\tdvo->clk_aux_parent = devm_clk_get(dev, \"aux_parent\");\n\tif (IS_ERR(dvo->clk_aux_parent)) {\n\t\tDRM_DEBUG_DRIVER(\"Cannot get aux_parent clock\\n\");\n\t\tdvo->clk_aux_parent = NULL;\n\t}\n\n\tdvo->panel_node = of_parse_phandle(np, \"sti,panel\", 0);\n\tif (!dvo->panel_node)\n\t\tDRM_ERROR(\"No panel associated to the dvo output\\n\");\n\tof_node_put(dvo->panel_node);\n\n\tplatform_set_drvdata(pdev, dvo);\n\n\treturn component_add(&pdev->dev, &sti_dvo_ops);\n}\n\nstatic void sti_dvo_remove(struct platform_device *pdev)\n{\n\tcomponent_del(&pdev->dev, &sti_dvo_ops);\n}\n\nstatic const struct of_device_id dvo_of_match[] = {\n\t{ .compatible = \"st,stih407-dvo\", },\n\t{   }\n};\nMODULE_DEVICE_TABLE(of, dvo_of_match);\n\nstruct platform_driver sti_dvo_driver = {\n\t.driver = {\n\t\t.name = \"sti-dvo\",\n\t\t.owner = THIS_MODULE,\n\t\t.of_match_table = dvo_of_match,\n\t},\n\t.probe = sti_dvo_probe,\n\t.remove_new = sti_dvo_remove,\n};\n\nMODULE_AUTHOR(\"Benjamin Gaignard <benjamin.gaignard@st.com>\");\nMODULE_DESCRIPTION(\"STMicroelectronics SoC DRM driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}