{
  "module_name": "sti_crtc.c",
  "hash_id": "8622075641a7d77a73bd8981331175b4b9b112e6662e00062d417c3be32a1a90",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/sti/sti_crtc.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n\n#include <drm/drm_atomic.h>\n#include <drm/drm_atomic_helper.h>\n#include <drm/drm_device.h>\n#include <drm/drm_print.h>\n#include <drm/drm_probe_helper.h>\n#include <drm/drm_vblank.h>\n\n#include \"sti_compositor.h\"\n#include \"sti_crtc.h\"\n#include \"sti_drv.h\"\n#include \"sti_vid.h\"\n#include \"sti_vtg.h\"\n\nstatic void sti_crtc_atomic_enable(struct drm_crtc *crtc,\n\t\t\t\t   struct drm_atomic_state *state)\n{\n\tstruct sti_mixer *mixer = to_sti_mixer(crtc);\n\n\tDRM_DEBUG_DRIVER(\"\\n\");\n\n\tmixer->status = STI_MIXER_READY;\n\n\tdrm_crtc_vblank_on(crtc);\n}\n\nstatic void sti_crtc_atomic_disable(struct drm_crtc *crtc,\n\t\t\t\t    struct drm_atomic_state *state)\n{\n\tstruct sti_mixer *mixer = to_sti_mixer(crtc);\n\n\tDRM_DEBUG_DRIVER(\"\\n\");\n\n\tmixer->status = STI_MIXER_DISABLING;\n\n\tdrm_crtc_wait_one_vblank(crtc);\n}\n\nstatic int\nsti_crtc_mode_set(struct drm_crtc *crtc, struct drm_display_mode *mode)\n{\n\tstruct sti_mixer *mixer = to_sti_mixer(crtc);\n\tstruct device *dev = mixer->dev;\n\tstruct sti_compositor *compo = dev_get_drvdata(dev);\n\tstruct clk *compo_clk, *pix_clk;\n\tint rate = mode->clock * 1000;\n\n\tDRM_DEBUG_KMS(\"CRTC:%d (%s) mode: (%s)\\n\",\n\t\t      crtc->base.id, sti_mixer_to_str(mixer), mode->name);\n\n\tDRM_DEBUG_KMS(DRM_MODE_FMT \"\\n\", DRM_MODE_ARG(mode));\n\n\tif (mixer->id == STI_MIXER_MAIN) {\n\t\tcompo_clk = compo->clk_compo_main;\n\t\tpix_clk = compo->clk_pix_main;\n\t} else {\n\t\tcompo_clk = compo->clk_compo_aux;\n\t\tpix_clk = compo->clk_pix_aux;\n\t}\n\n\t \n\tif (clk_prepare_enable(compo_clk)) {\n\t\tDRM_INFO(\"Failed to prepare/enable compositor clk\\n\");\n\t\tgoto compo_error;\n\t}\n\n\t \n\tif (clk_set_rate(pix_clk, rate) < 0) {\n\t\tDRM_ERROR(\"Cannot set rate (%dHz) for pix clk\\n\", rate);\n\t\tgoto pix_error;\n\t}\n\tif (clk_prepare_enable(pix_clk)) {\n\t\tDRM_ERROR(\"Failed to prepare/enable pix clk\\n\");\n\t\tgoto pix_error;\n\t}\n\n\tsti_vtg_set_config(compo->vtg[mixer->id], &crtc->mode);\n\n\tif (sti_mixer_active_video_area(mixer, &crtc->mode)) {\n\t\tDRM_ERROR(\"Can't set active video area\\n\");\n\t\tgoto mixer_error;\n\t}\n\n\treturn 0;\n\nmixer_error:\n\tclk_disable_unprepare(pix_clk);\npix_error:\n\tclk_disable_unprepare(compo_clk);\ncompo_error:\n\treturn -EINVAL;\n}\n\nstatic void sti_crtc_disable(struct drm_crtc *crtc)\n{\n\tstruct sti_mixer *mixer = to_sti_mixer(crtc);\n\tstruct device *dev = mixer->dev;\n\tstruct sti_compositor *compo = dev_get_drvdata(dev);\n\n\tDRM_DEBUG_KMS(\"CRTC:%d (%s)\\n\", crtc->base.id, sti_mixer_to_str(mixer));\n\n\t \n\tsti_mixer_set_background_status(mixer, false);\n\n\tdrm_crtc_vblank_off(crtc);\n\n\t \n\tif (mixer->id == STI_MIXER_MAIN) {\n\t\tclk_disable_unprepare(compo->clk_pix_main);\n\t\tclk_disable_unprepare(compo->clk_compo_main);\n\t} else {\n\t\tclk_disable_unprepare(compo->clk_pix_aux);\n\t\tclk_disable_unprepare(compo->clk_compo_aux);\n\t}\n\n\tmixer->status = STI_MIXER_DISABLED;\n}\n\nstatic void\nsti_crtc_mode_set_nofb(struct drm_crtc *crtc)\n{\n\tsti_crtc_mode_set(crtc, &crtc->state->adjusted_mode);\n}\n\nstatic void sti_crtc_atomic_flush(struct drm_crtc *crtc,\n\t\t\t\t  struct drm_atomic_state *state)\n{\n\tstruct drm_device *drm_dev = crtc->dev;\n\tstruct sti_mixer *mixer = to_sti_mixer(crtc);\n\tstruct sti_compositor *compo = dev_get_drvdata(mixer->dev);\n\tstruct drm_plane *p;\n\tstruct drm_pending_vblank_event *event;\n\tunsigned long flags;\n\n\tDRM_DEBUG_DRIVER(\"\\n\");\n\n\t \n\tlist_for_each_entry(p, &drm_dev->mode_config.plane_list, head) {\n\t\tstruct sti_plane *plane = to_sti_plane(p);\n\n\t\tswitch (plane->status) {\n\t\tcase STI_PLANE_UPDATED:\n\t\t\t \n\t\t\tif (p->state->crtc != crtc)\n\t\t\t\tcontinue;\n\n\t\t\t \n\t\t\tDRM_DEBUG_DRIVER(\"update plane %s\\n\",\n\t\t\t\t\t sti_plane_to_str(plane));\n\n\t\t\tif (sti_mixer_set_plane_depth(mixer, plane)) {\n\t\t\t\tDRM_ERROR(\"Cannot set plane %s depth\\n\",\n\t\t\t\t\t  sti_plane_to_str(plane));\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (sti_mixer_set_plane_status(mixer, plane, true)) {\n\t\t\t\tDRM_ERROR(\"Cannot enable plane %s at mixer\\n\",\n\t\t\t\t\t  sti_plane_to_str(plane));\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t \n\t\t\tif (plane->desc == STI_HQVDP_0)\n\t\t\t\tsti_vid_commit(compo->vid[0], p->state);\n\n\t\t\tplane->status = STI_PLANE_READY;\n\n\t\t\tbreak;\n\t\tcase STI_PLANE_DISABLING:\n\t\t\t \n\t\t\tDRM_DEBUG_DRIVER(\"disable plane %s from mixer\\n\",\n\t\t\t\t\t sti_plane_to_str(plane));\n\n\t\t\tif (sti_mixer_set_plane_status(mixer, plane, false)) {\n\t\t\t\tDRM_ERROR(\"Cannot disable plane %s at mixer\\n\",\n\t\t\t\t\t  sti_plane_to_str(plane));\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (plane->desc == STI_CURSOR)\n\t\t\t\t \n\t\t\t\tplane->status = STI_PLANE_DISABLED;\n\t\t\telse\n\t\t\t\t \n\t\t\t\tplane->status = STI_PLANE_FLUSHING;\n\n\t\t\t \n\t\t\tif (plane->desc == STI_HQVDP_0)\n\t\t\t\tsti_vid_disable(compo->vid[0]);\n\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t \n\t\t\tbreak;\n\t\t}\n\t}\n\n\tevent = crtc->state->event;\n\tif (event) {\n\t\tcrtc->state->event = NULL;\n\n\t\tspin_lock_irqsave(&crtc->dev->event_lock, flags);\n\t\tif (drm_crtc_vblank_get(crtc) == 0)\n\t\t\tdrm_crtc_arm_vblank_event(crtc, event);\n\t\telse\n\t\t\tdrm_crtc_send_vblank_event(crtc, event);\n\t\tspin_unlock_irqrestore(&crtc->dev->event_lock, flags);\n\t}\n}\n\nstatic const struct drm_crtc_helper_funcs sti_crtc_helper_funcs = {\n\t.mode_set_nofb = sti_crtc_mode_set_nofb,\n\t.atomic_flush = sti_crtc_atomic_flush,\n\t.atomic_enable = sti_crtc_atomic_enable,\n\t.atomic_disable = sti_crtc_atomic_disable,\n};\n\nstatic void sti_crtc_destroy(struct drm_crtc *crtc)\n{\n\tDRM_DEBUG_KMS(\"\\n\");\n\tdrm_crtc_cleanup(crtc);\n}\n\nstatic int sti_crtc_set_property(struct drm_crtc *crtc,\n\t\t\t\t struct drm_property *property,\n\t\t\t\t uint64_t val)\n{\n\tDRM_DEBUG_KMS(\"\\n\");\n\treturn 0;\n}\n\nint sti_crtc_vblank_cb(struct notifier_block *nb,\n\t\t       unsigned long event, void *data)\n{\n\tstruct sti_compositor *compo;\n\tstruct drm_crtc *crtc = data;\n\tstruct sti_mixer *mixer;\n\tunsigned int pipe;\n\n\tpipe = drm_crtc_index(crtc);\n\tcompo = container_of(nb, struct sti_compositor, vtg_vblank_nb[pipe]);\n\tmixer = compo->mixer[pipe];\n\n\tif ((event != VTG_TOP_FIELD_EVENT) &&\n\t    (event != VTG_BOTTOM_FIELD_EVENT)) {\n\t\tDRM_ERROR(\"unknown event: %lu\\n\", event);\n\t\treturn -EINVAL;\n\t}\n\n\tdrm_crtc_handle_vblank(crtc);\n\n\tif (mixer->status == STI_MIXER_DISABLING) {\n\t\tstruct drm_plane *p;\n\n\t\t \n\t\tlist_for_each_entry(p, &crtc->dev->mode_config.plane_list,\n\t\t\t\t    head) {\n\t\t\tstruct sti_plane *plane = to_sti_plane(p);\n\n\t\t\tif ((plane->desc & STI_PLANE_TYPE_MASK) <= STI_VDP)\n\t\t\t\tif (plane->status != STI_PLANE_DISABLED)\n\t\t\t\t\treturn 0;\n\t\t}\n\t\tsti_crtc_disable(crtc);\n\t}\n\n\treturn 0;\n}\n\nstatic int sti_crtc_enable_vblank(struct drm_crtc *crtc)\n{\n\tstruct drm_device *dev = crtc->dev;\n\tunsigned int pipe = crtc->index;\n\tstruct sti_private *dev_priv = dev->dev_private;\n\tstruct sti_compositor *compo = dev_priv->compo;\n\tstruct notifier_block *vtg_vblank_nb = &compo->vtg_vblank_nb[pipe];\n\tstruct sti_vtg *vtg = compo->vtg[pipe];\n\n\tDRM_DEBUG_DRIVER(\"\\n\");\n\n\tif (sti_vtg_register_client(vtg, vtg_vblank_nb, crtc)) {\n\t\tDRM_ERROR(\"Cannot register VTG notifier\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic void sti_crtc_disable_vblank(struct drm_crtc *crtc)\n{\n\tstruct drm_device *drm_dev = crtc->dev;\n\tunsigned int pipe = crtc->index;\n\tstruct sti_private *priv = drm_dev->dev_private;\n\tstruct sti_compositor *compo = priv->compo;\n\tstruct notifier_block *vtg_vblank_nb = &compo->vtg_vblank_nb[pipe];\n\tstruct sti_vtg *vtg = compo->vtg[pipe];\n\n\tDRM_DEBUG_DRIVER(\"\\n\");\n\n\tif (sti_vtg_unregister_client(vtg, vtg_vblank_nb))\n\t\tDRM_DEBUG_DRIVER(\"Warning: cannot unregister VTG notifier\\n\");\n}\n\nstatic int sti_crtc_late_register(struct drm_crtc *crtc)\n{\n\tstruct sti_mixer *mixer = to_sti_mixer(crtc);\n\tstruct sti_compositor *compo = dev_get_drvdata(mixer->dev);\n\n\tif (drm_crtc_index(crtc) == 0)\n\t\tsti_compositor_debugfs_init(compo, crtc->dev->primary);\n\n\treturn 0;\n}\n\nstatic const struct drm_crtc_funcs sti_crtc_funcs = {\n\t.set_config = drm_atomic_helper_set_config,\n\t.page_flip = drm_atomic_helper_page_flip,\n\t.destroy = sti_crtc_destroy,\n\t.set_property = sti_crtc_set_property,\n\t.reset = drm_atomic_helper_crtc_reset,\n\t.atomic_duplicate_state = drm_atomic_helper_crtc_duplicate_state,\n\t.atomic_destroy_state = drm_atomic_helper_crtc_destroy_state,\n\t.late_register = sti_crtc_late_register,\n\t.enable_vblank = sti_crtc_enable_vblank,\n\t.disable_vblank = sti_crtc_disable_vblank,\n};\n\nbool sti_crtc_is_main(struct drm_crtc *crtc)\n{\n\tstruct sti_mixer *mixer = to_sti_mixer(crtc);\n\n\tif (mixer->id == STI_MIXER_MAIN)\n\t\treturn true;\n\n\treturn false;\n}\n\nint sti_crtc_init(struct drm_device *drm_dev, struct sti_mixer *mixer,\n\t\t  struct drm_plane *primary, struct drm_plane *cursor)\n{\n\tstruct drm_crtc *crtc = &mixer->drm_crtc;\n\tint res;\n\n\tres = drm_crtc_init_with_planes(drm_dev, crtc, primary, cursor,\n\t\t\t\t\t&sti_crtc_funcs, NULL);\n\tif (res) {\n\t\tDRM_ERROR(\"Can't initialize CRTC\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tdrm_crtc_helper_add(crtc, &sti_crtc_helper_funcs);\n\n\tDRM_DEBUG_DRIVER(\"drm CRTC:%d mapped to %s\\n\",\n\t\t\t crtc->base.id, sti_mixer_to_str(mixer));\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}