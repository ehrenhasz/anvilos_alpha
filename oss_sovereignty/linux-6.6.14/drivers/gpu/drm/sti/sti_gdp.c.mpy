{
  "module_name": "sti_gdp.c",
  "hash_id": "e1796055ea5b7cd2fdf09f9353e37dfff4561f0bf387c394fdc3867c5be4281a",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/sti/sti_gdp.c",
  "human_readable_source": "\n \n\n#include <linux/dma-mapping.h>\n#include <linux/of.h>\n#include <linux/seq_file.h>\n\n#include <drm/drm_atomic.h>\n#include <drm/drm_device.h>\n#include <drm/drm_fb_dma_helper.h>\n#include <drm/drm_fourcc.h>\n#include <drm/drm_framebuffer.h>\n#include <drm/drm_gem_dma_helper.h>\n\n#include \"sti_compositor.h\"\n#include \"sti_gdp.h\"\n#include \"sti_plane.h\"\n#include \"sti_vtg.h\"\n\n#define ALPHASWITCH     BIT(6)\n#define ENA_COLOR_FILL  BIT(8)\n#define BIGNOTLITTLE    BIT(23)\n#define WAIT_NEXT_VSYNC BIT(31)\n\n \n#define GDP_RGB565      0x00\n#define GDP_RGB888      0x01\n#define GDP_RGB888_32   0x02\n#define GDP_XBGR8888    (GDP_RGB888_32 | BIGNOTLITTLE | ALPHASWITCH)\n#define GDP_ARGB8565    0x04\n#define GDP_ARGB8888    0x05\n#define GDP_ABGR8888    (GDP_ARGB8888 | BIGNOTLITTLE | ALPHASWITCH)\n#define GDP_ARGB1555    0x06\n#define GDP_ARGB4444    0x07\n\n#define GDP2STR(fmt) { GDP_ ## fmt, #fmt }\n\nstatic struct gdp_format_to_str {\n\tint format;\n\tchar name[20];\n} gdp_format_to_str[] = {\n\t\tGDP2STR(RGB565),\n\t\tGDP2STR(RGB888),\n\t\tGDP2STR(RGB888_32),\n\t\tGDP2STR(XBGR8888),\n\t\tGDP2STR(ARGB8565),\n\t\tGDP2STR(ARGB8888),\n\t\tGDP2STR(ABGR8888),\n\t\tGDP2STR(ARGB1555),\n\t\tGDP2STR(ARGB4444)\n\t\t};\n\n#define GAM_GDP_CTL_OFFSET      0x00\n#define GAM_GDP_AGC_OFFSET      0x04\n#define GAM_GDP_VPO_OFFSET      0x0C\n#define GAM_GDP_VPS_OFFSET      0x10\n#define GAM_GDP_PML_OFFSET      0x14\n#define GAM_GDP_PMP_OFFSET      0x18\n#define GAM_GDP_SIZE_OFFSET     0x1C\n#define GAM_GDP_NVN_OFFSET      0x24\n#define GAM_GDP_KEY1_OFFSET     0x28\n#define GAM_GDP_KEY2_OFFSET     0x2C\n#define GAM_GDP_PPT_OFFSET      0x34\n#define GAM_GDP_CML_OFFSET      0x3C\n#define GAM_GDP_MST_OFFSET      0x68\n\n#define GAM_GDP_ALPHARANGE_255  BIT(5)\n#define GAM_GDP_AGC_FULL_RANGE  0x00808080\n#define GAM_GDP_PPT_IGNORE      (BIT(1) | BIT(0))\n\n#define GAM_GDP_SIZE_MAX_WIDTH  3840\n#define GAM_GDP_SIZE_MAX_HEIGHT 2160\n\n#define GDP_NODE_NB_BANK        2\n#define GDP_NODE_PER_FIELD      2\n\nstruct sti_gdp_node {\n\tu32 gam_gdp_ctl;\n\tu32 gam_gdp_agc;\n\tu32 reserved1;\n\tu32 gam_gdp_vpo;\n\tu32 gam_gdp_vps;\n\tu32 gam_gdp_pml;\n\tu32 gam_gdp_pmp;\n\tu32 gam_gdp_size;\n\tu32 reserved2;\n\tu32 gam_gdp_nvn;\n\tu32 gam_gdp_key1;\n\tu32 gam_gdp_key2;\n\tu32 reserved3;\n\tu32 gam_gdp_ppt;\n\tu32 reserved4;\n\tu32 gam_gdp_cml;\n};\n\nstruct sti_gdp_node_list {\n\tstruct sti_gdp_node *top_field;\n\tdma_addr_t top_field_paddr;\n\tstruct sti_gdp_node *btm_field;\n\tdma_addr_t btm_field_paddr;\n};\n\n \nstruct sti_gdp {\n\tstruct sti_plane plane;\n\tstruct device *dev;\n\tvoid __iomem *regs;\n\tstruct clk *clk_pix;\n\tstruct clk *clk_main_parent;\n\tstruct clk *clk_aux_parent;\n\tstruct notifier_block vtg_field_nb;\n\tbool is_curr_top;\n\tstruct sti_gdp_node_list node_list[GDP_NODE_NB_BANK];\n\tstruct sti_vtg *vtg;\n};\n\n#define to_sti_gdp(x) container_of(x, struct sti_gdp, plane)\n\nstatic const uint32_t gdp_supported_formats[] = {\n\tDRM_FORMAT_XRGB8888,\n\tDRM_FORMAT_XBGR8888,\n\tDRM_FORMAT_ARGB8888,\n\tDRM_FORMAT_ABGR8888,\n\tDRM_FORMAT_ARGB4444,\n\tDRM_FORMAT_ARGB1555,\n\tDRM_FORMAT_RGB565,\n\tDRM_FORMAT_RGB888,\n};\n\n#define DBGFS_DUMP(reg) seq_printf(s, \"\\n  %-25s 0x%08X\", #reg, \\\n\t\t\t\t   readl(gdp->regs + reg ## _OFFSET))\n\nstatic void gdp_dbg_ctl(struct seq_file *s, int val)\n{\n\tint i;\n\n\tseq_puts(s, \"\\tColor:\");\n\tfor (i = 0; i < ARRAY_SIZE(gdp_format_to_str); i++) {\n\t\tif (gdp_format_to_str[i].format == (val & 0x1F)) {\n\t\t\tseq_puts(s, gdp_format_to_str[i].name);\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (i == ARRAY_SIZE(gdp_format_to_str))\n\t\tseq_puts(s, \"<UNKNOWN>\");\n\n\tseq_printf(s, \"\\tWaitNextVsync:%d\", val & WAIT_NEXT_VSYNC ? 1 : 0);\n}\n\nstatic void gdp_dbg_vpo(struct seq_file *s, int val)\n{\n\tseq_printf(s, \"\\txdo:%4d\\tydo:%4d\", val & 0xFFFF, (val >> 16) & 0xFFFF);\n}\n\nstatic void gdp_dbg_vps(struct seq_file *s, int val)\n{\n\tseq_printf(s, \"\\txds:%4d\\tyds:%4d\", val & 0xFFFF, (val >> 16) & 0xFFFF);\n}\n\nstatic void gdp_dbg_size(struct seq_file *s, int val)\n{\n\tseq_printf(s, \"\\t%d x %d\", val & 0xFFFF, (val >> 16) & 0xFFFF);\n}\n\nstatic void gdp_dbg_nvn(struct seq_file *s, struct sti_gdp *gdp, int val)\n{\n\tvoid *base = NULL;\n\tunsigned int i;\n\n\tfor (i = 0; i < GDP_NODE_NB_BANK; i++) {\n\t\tif (gdp->node_list[i].top_field_paddr == val) {\n\t\t\tbase = gdp->node_list[i].top_field;\n\t\t\tbreak;\n\t\t}\n\t\tif (gdp->node_list[i].btm_field_paddr == val) {\n\t\t\tbase = gdp->node_list[i].btm_field;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (base)\n\t\tseq_printf(s, \"\\tVirt @: %p\", base);\n}\n\nstatic void gdp_dbg_ppt(struct seq_file *s, int val)\n{\n\tif (val & GAM_GDP_PPT_IGNORE)\n\t\tseq_puts(s, \"\\tNot displayed on mixer!\");\n}\n\nstatic void gdp_dbg_mst(struct seq_file *s, int val)\n{\n\tif (val & 1)\n\t\tseq_puts(s, \"\\tBUFFER UNDERFLOW!\");\n}\n\nstatic int gdp_dbg_show(struct seq_file *s, void *data)\n{\n\tstruct drm_info_node *node = s->private;\n\tstruct sti_gdp *gdp = (struct sti_gdp *)node->info_ent->data;\n\tstruct drm_plane *drm_plane = &gdp->plane.drm_plane;\n\tstruct drm_crtc *crtc;\n\n\tdrm_modeset_lock(&drm_plane->mutex, NULL);\n\tcrtc = drm_plane->state->crtc;\n\tdrm_modeset_unlock(&drm_plane->mutex);\n\n\tseq_printf(s, \"%s: (vaddr = 0x%p)\",\n\t\t   sti_plane_to_str(&gdp->plane), gdp->regs);\n\n\tDBGFS_DUMP(GAM_GDP_CTL);\n\tgdp_dbg_ctl(s, readl(gdp->regs + GAM_GDP_CTL_OFFSET));\n\tDBGFS_DUMP(GAM_GDP_AGC);\n\tDBGFS_DUMP(GAM_GDP_VPO);\n\tgdp_dbg_vpo(s, readl(gdp->regs + GAM_GDP_VPO_OFFSET));\n\tDBGFS_DUMP(GAM_GDP_VPS);\n\tgdp_dbg_vps(s, readl(gdp->regs + GAM_GDP_VPS_OFFSET));\n\tDBGFS_DUMP(GAM_GDP_PML);\n\tDBGFS_DUMP(GAM_GDP_PMP);\n\tDBGFS_DUMP(GAM_GDP_SIZE);\n\tgdp_dbg_size(s, readl(gdp->regs + GAM_GDP_SIZE_OFFSET));\n\tDBGFS_DUMP(GAM_GDP_NVN);\n\tgdp_dbg_nvn(s, gdp, readl(gdp->regs + GAM_GDP_NVN_OFFSET));\n\tDBGFS_DUMP(GAM_GDP_KEY1);\n\tDBGFS_DUMP(GAM_GDP_KEY2);\n\tDBGFS_DUMP(GAM_GDP_PPT);\n\tgdp_dbg_ppt(s, readl(gdp->regs + GAM_GDP_PPT_OFFSET));\n\tDBGFS_DUMP(GAM_GDP_CML);\n\tDBGFS_DUMP(GAM_GDP_MST);\n\tgdp_dbg_mst(s, readl(gdp->regs + GAM_GDP_MST_OFFSET));\n\n\tseq_puts(s, \"\\n\\n\");\n\tif (!crtc)\n\t\tseq_puts(s, \"  Not connected to any DRM CRTC\\n\");\n\telse\n\t\tseq_printf(s, \"  Connected to DRM CRTC #%d (%s)\\n\",\n\t\t\t   crtc->base.id, sti_mixer_to_str(to_sti_mixer(crtc)));\n\n\treturn 0;\n}\n\nstatic void gdp_node_dump_node(struct seq_file *s, struct sti_gdp_node *node)\n{\n\tseq_printf(s, \"\\t@:0x%p\", node);\n\tseq_printf(s, \"\\n\\tCTL  0x%08X\", node->gam_gdp_ctl);\n\tgdp_dbg_ctl(s, node->gam_gdp_ctl);\n\tseq_printf(s, \"\\n\\tAGC  0x%08X\", node->gam_gdp_agc);\n\tseq_printf(s, \"\\n\\tVPO  0x%08X\", node->gam_gdp_vpo);\n\tgdp_dbg_vpo(s, node->gam_gdp_vpo);\n\tseq_printf(s, \"\\n\\tVPS  0x%08X\", node->gam_gdp_vps);\n\tgdp_dbg_vps(s, node->gam_gdp_vps);\n\tseq_printf(s, \"\\n\\tPML  0x%08X\", node->gam_gdp_pml);\n\tseq_printf(s, \"\\n\\tPMP  0x%08X\", node->gam_gdp_pmp);\n\tseq_printf(s, \"\\n\\tSIZE 0x%08X\", node->gam_gdp_size);\n\tgdp_dbg_size(s, node->gam_gdp_size);\n\tseq_printf(s, \"\\n\\tNVN  0x%08X\", node->gam_gdp_nvn);\n\tseq_printf(s, \"\\n\\tKEY1 0x%08X\", node->gam_gdp_key1);\n\tseq_printf(s, \"\\n\\tKEY2 0x%08X\", node->gam_gdp_key2);\n\tseq_printf(s, \"\\n\\tPPT  0x%08X\", node->gam_gdp_ppt);\n\tgdp_dbg_ppt(s, node->gam_gdp_ppt);\n\tseq_printf(s, \"\\n\\tCML  0x%08X\\n\", node->gam_gdp_cml);\n}\n\nstatic int gdp_node_dbg_show(struct seq_file *s, void *arg)\n{\n\tstruct drm_info_node *node = s->private;\n\tstruct sti_gdp *gdp = (struct sti_gdp *)node->info_ent->data;\n\tunsigned int b;\n\n\tfor (b = 0; b < GDP_NODE_NB_BANK; b++) {\n\t\tseq_printf(s, \"\\n%s[%d].top\", sti_plane_to_str(&gdp->plane), b);\n\t\tgdp_node_dump_node(s, gdp->node_list[b].top_field);\n\t\tseq_printf(s, \"\\n%s[%d].btm\", sti_plane_to_str(&gdp->plane), b);\n\t\tgdp_node_dump_node(s, gdp->node_list[b].btm_field);\n\t}\n\n\treturn 0;\n}\n\nstatic struct drm_info_list gdp0_debugfs_files[] = {\n\t{ \"gdp0\", gdp_dbg_show, 0, NULL },\n\t{ \"gdp0_node\", gdp_node_dbg_show, 0, NULL },\n};\n\nstatic struct drm_info_list gdp1_debugfs_files[] = {\n\t{ \"gdp1\", gdp_dbg_show, 0, NULL },\n\t{ \"gdp1_node\", gdp_node_dbg_show, 0, NULL },\n};\n\nstatic struct drm_info_list gdp2_debugfs_files[] = {\n\t{ \"gdp2\", gdp_dbg_show, 0, NULL },\n\t{ \"gdp2_node\", gdp_node_dbg_show, 0, NULL },\n};\n\nstatic struct drm_info_list gdp3_debugfs_files[] = {\n\t{ \"gdp3\", gdp_dbg_show, 0, NULL },\n\t{ \"gdp3_node\", gdp_node_dbg_show, 0, NULL },\n};\n\nstatic int gdp_debugfs_init(struct sti_gdp *gdp, struct drm_minor *minor)\n{\n\tunsigned int i;\n\tstruct drm_info_list *gdp_debugfs_files;\n\tint nb_files;\n\n\tswitch (gdp->plane.desc) {\n\tcase STI_GDP_0:\n\t\tgdp_debugfs_files = gdp0_debugfs_files;\n\t\tnb_files = ARRAY_SIZE(gdp0_debugfs_files);\n\t\tbreak;\n\tcase STI_GDP_1:\n\t\tgdp_debugfs_files = gdp1_debugfs_files;\n\t\tnb_files = ARRAY_SIZE(gdp1_debugfs_files);\n\t\tbreak;\n\tcase STI_GDP_2:\n\t\tgdp_debugfs_files = gdp2_debugfs_files;\n\t\tnb_files = ARRAY_SIZE(gdp2_debugfs_files);\n\t\tbreak;\n\tcase STI_GDP_3:\n\t\tgdp_debugfs_files = gdp3_debugfs_files;\n\t\tnb_files = ARRAY_SIZE(gdp3_debugfs_files);\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tfor (i = 0; i < nb_files; i++)\n\t\tgdp_debugfs_files[i].data = gdp;\n\n\tdrm_debugfs_create_files(gdp_debugfs_files,\n\t\t\t\t nb_files,\n\t\t\t\t minor->debugfs_root, minor);\n\treturn 0;\n}\n\nstatic int sti_gdp_fourcc2format(int fourcc)\n{\n\tswitch (fourcc) {\n\tcase DRM_FORMAT_XRGB8888:\n\t\treturn GDP_RGB888_32;\n\tcase DRM_FORMAT_XBGR8888:\n\t\treturn GDP_XBGR8888;\n\tcase DRM_FORMAT_ARGB8888:\n\t\treturn GDP_ARGB8888;\n\tcase DRM_FORMAT_ABGR8888:\n\t\treturn GDP_ABGR8888;\n\tcase DRM_FORMAT_ARGB4444:\n\t\treturn GDP_ARGB4444;\n\tcase DRM_FORMAT_ARGB1555:\n\t\treturn GDP_ARGB1555;\n\tcase DRM_FORMAT_RGB565:\n\t\treturn GDP_RGB565;\n\tcase DRM_FORMAT_RGB888:\n\t\treturn GDP_RGB888;\n\t}\n\treturn -1;\n}\n\nstatic int sti_gdp_get_alpharange(int format)\n{\n\tswitch (format) {\n\tcase GDP_ARGB8565:\n\tcase GDP_ARGB8888:\n\tcase GDP_ABGR8888:\n\t\treturn GAM_GDP_ALPHARANGE_255;\n\t}\n\treturn 0;\n}\n\n \nstatic struct sti_gdp_node_list *sti_gdp_get_free_nodes(struct sti_gdp *gdp)\n{\n\tint hw_nvn;\n\tunsigned int i;\n\n\thw_nvn = readl(gdp->regs + GAM_GDP_NVN_OFFSET);\n\tif (!hw_nvn)\n\t\tgoto end;\n\n\tfor (i = 0; i < GDP_NODE_NB_BANK; i++)\n\t\tif ((hw_nvn != gdp->node_list[i].btm_field_paddr) &&\n\t\t    (hw_nvn != gdp->node_list[i].top_field_paddr))\n\t\t\treturn &gdp->node_list[i];\n\n\t \n\tDRM_ERROR(\"inconsistent NVN for %s: 0x%08X\\n\",\n\t\t\tsti_plane_to_str(&gdp->plane), hw_nvn);\n\nend:\n\treturn &gdp->node_list[0];\n}\n\n \nstatic\nstruct sti_gdp_node_list *sti_gdp_get_current_nodes(struct sti_gdp *gdp)\n{\n\tint hw_nvn;\n\tunsigned int i;\n\n\thw_nvn = readl(gdp->regs + GAM_GDP_NVN_OFFSET);\n\tif (!hw_nvn)\n\t\tgoto end;\n\n\tfor (i = 0; i < GDP_NODE_NB_BANK; i++)\n\t\tif ((hw_nvn == gdp->node_list[i].btm_field_paddr) ||\n\t\t\t\t(hw_nvn == gdp->node_list[i].top_field_paddr))\n\t\t\treturn &gdp->node_list[i];\n\nend:\n\tDRM_DEBUG_DRIVER(\"Warning, NVN 0x%08X for %s does not match any node\\n\",\n\t\t\t\thw_nvn, sti_plane_to_str(&gdp->plane));\n\n\treturn NULL;\n}\n\n \nstatic void sti_gdp_disable(struct sti_gdp *gdp)\n{\n\tunsigned int i;\n\n\tDRM_DEBUG_DRIVER(\"%s\\n\", sti_plane_to_str(&gdp->plane));\n\n\t \n\tfor (i = 0; i < GDP_NODE_NB_BANK; i++) {\n\t\tgdp->node_list[i].top_field->gam_gdp_ppt |= GAM_GDP_PPT_IGNORE;\n\t\tgdp->node_list[i].btm_field->gam_gdp_ppt |= GAM_GDP_PPT_IGNORE;\n\t}\n\n\tif (sti_vtg_unregister_client(gdp->vtg, &gdp->vtg_field_nb))\n\t\tDRM_DEBUG_DRIVER(\"Warning: cannot unregister VTG notifier\\n\");\n\n\tif (gdp->clk_pix)\n\t\tclk_disable_unprepare(gdp->clk_pix);\n\n\tgdp->plane.status = STI_PLANE_DISABLED;\n\tgdp->vtg = NULL;\n}\n\n \nstatic int sti_gdp_field_cb(struct notifier_block *nb,\n\t\t\t    unsigned long event, void *data)\n{\n\tstruct sti_gdp *gdp = container_of(nb, struct sti_gdp, vtg_field_nb);\n\n\tif (gdp->plane.status == STI_PLANE_FLUSHING) {\n\t\t \n\t\tDRM_DEBUG_DRIVER(\"Vsync event received => disable %s\\n\",\n\t\t\t\t sti_plane_to_str(&gdp->plane));\n\n\t\tsti_gdp_disable(gdp);\n\t}\n\n\tswitch (event) {\n\tcase VTG_TOP_FIELD_EVENT:\n\t\tgdp->is_curr_top = true;\n\t\tbreak;\n\tcase VTG_BOTTOM_FIELD_EVENT:\n\t\tgdp->is_curr_top = false;\n\t\tbreak;\n\tdefault:\n\t\tDRM_ERROR(\"unsupported event: %lu\\n\", event);\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic void sti_gdp_init(struct sti_gdp *gdp)\n{\n\tstruct device_node *np = gdp->dev->of_node;\n\tdma_addr_t dma_addr;\n\tvoid *base;\n\tunsigned int i, size;\n\n\t \n\tsize = sizeof(struct sti_gdp_node) *\n\t    GDP_NODE_PER_FIELD * GDP_NODE_NB_BANK;\n\tbase = dma_alloc_wc(gdp->dev, size, &dma_addr, GFP_KERNEL);\n\n\tif (!base) {\n\t\tDRM_ERROR(\"Failed to allocate memory for GDP node\\n\");\n\t\treturn;\n\t}\n\tmemset(base, 0, size);\n\n\tfor (i = 0; i < GDP_NODE_NB_BANK; i++) {\n\t\tif (dma_addr & 0xF) {\n\t\t\tDRM_ERROR(\"Mem alignment failed\\n\");\n\t\t\treturn;\n\t\t}\n\t\tgdp->node_list[i].top_field = base;\n\t\tgdp->node_list[i].top_field_paddr = dma_addr;\n\n\t\tDRM_DEBUG_DRIVER(\"node[%d].top_field=%p\\n\", i, base);\n\t\tbase += sizeof(struct sti_gdp_node);\n\t\tdma_addr += sizeof(struct sti_gdp_node);\n\n\t\tif (dma_addr & 0xF) {\n\t\t\tDRM_ERROR(\"Mem alignment failed\\n\");\n\t\t\treturn;\n\t\t}\n\t\tgdp->node_list[i].btm_field = base;\n\t\tgdp->node_list[i].btm_field_paddr = dma_addr;\n\t\tDRM_DEBUG_DRIVER(\"node[%d].btm_field=%p\\n\", i, base);\n\t\tbase += sizeof(struct sti_gdp_node);\n\t\tdma_addr += sizeof(struct sti_gdp_node);\n\t}\n\n\tif (of_device_is_compatible(np, \"st,stih407-compositor\")) {\n\t\t \n\t\tchar *clk_name;\n\n\t\tswitch (gdp->plane.desc) {\n\t\tcase STI_GDP_0:\n\t\t\tclk_name = \"pix_gdp1\";\n\t\t\tbreak;\n\t\tcase STI_GDP_1:\n\t\t\tclk_name = \"pix_gdp2\";\n\t\t\tbreak;\n\t\tcase STI_GDP_2:\n\t\t\tclk_name = \"pix_gdp3\";\n\t\t\tbreak;\n\t\tcase STI_GDP_3:\n\t\t\tclk_name = \"pix_gdp4\";\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tDRM_ERROR(\"GDP id not recognized\\n\");\n\t\t\treturn;\n\t\t}\n\n\t\tgdp->clk_pix = devm_clk_get(gdp->dev, clk_name);\n\t\tif (IS_ERR(gdp->clk_pix))\n\t\t\tDRM_ERROR(\"Cannot get %s clock\\n\", clk_name);\n\n\t\tgdp->clk_main_parent = devm_clk_get(gdp->dev, \"main_parent\");\n\t\tif (IS_ERR(gdp->clk_main_parent))\n\t\t\tDRM_ERROR(\"Cannot get main_parent clock\\n\");\n\n\t\tgdp->clk_aux_parent = devm_clk_get(gdp->dev, \"aux_parent\");\n\t\tif (IS_ERR(gdp->clk_aux_parent))\n\t\t\tDRM_ERROR(\"Cannot get aux_parent clock\\n\");\n\t}\n}\n\n \nstatic int sti_gdp_get_dst(struct device *dev, int dst, int src)\n{\n\tif (dst == src)\n\t\treturn dst;\n\n\tif (dst < src) {\n\t\tdev_dbg(dev, \"WARNING: GDP scale not supported, will crop\\n\");\n\t\treturn dst;\n\t}\n\n\tdev_dbg(dev, \"WARNING: GDP scale not supported, will clamp\\n\");\n\treturn src;\n}\n\nstatic int sti_gdp_atomic_check(struct drm_plane *drm_plane,\n\t\t\t\tstruct drm_atomic_state *state)\n{\n\tstruct drm_plane_state *new_plane_state = drm_atomic_get_new_plane_state(state,\n\t\t\t\t\t\t\t\t\t\t drm_plane);\n\tstruct sti_plane *plane = to_sti_plane(drm_plane);\n\tstruct sti_gdp *gdp = to_sti_gdp(plane);\n\tstruct drm_crtc *crtc = new_plane_state->crtc;\n\tstruct drm_framebuffer *fb =  new_plane_state->fb;\n\tstruct drm_crtc_state *crtc_state;\n\tstruct sti_mixer *mixer;\n\tstruct drm_display_mode *mode;\n\tint dst_x, dst_y, dst_w, dst_h;\n\tint src_x, src_y, src_w, src_h;\n\tint format;\n\n\t \n\tif (!crtc || !fb)\n\t\treturn 0;\n\n\tmixer = to_sti_mixer(crtc);\n\tcrtc_state = drm_atomic_get_crtc_state(state, crtc);\n\tmode = &crtc_state->mode;\n\tdst_x = new_plane_state->crtc_x;\n\tdst_y = new_plane_state->crtc_y;\n\tdst_w = clamp_val(new_plane_state->crtc_w, 0, mode->hdisplay - dst_x);\n\tdst_h = clamp_val(new_plane_state->crtc_h, 0, mode->vdisplay - dst_y);\n\t \n\tsrc_x = new_plane_state->src_x >> 16;\n\tsrc_y = new_plane_state->src_y >> 16;\n\tsrc_w = clamp_val(new_plane_state->src_w >> 16, 0,\n\t\t\t  GAM_GDP_SIZE_MAX_WIDTH);\n\tsrc_h = clamp_val(new_plane_state->src_h >> 16, 0,\n\t\t\t  GAM_GDP_SIZE_MAX_HEIGHT);\n\n\tformat = sti_gdp_fourcc2format(fb->format->format);\n\tif (format == -1) {\n\t\tDRM_ERROR(\"Format not supported by GDP %.4s\\n\",\n\t\t\t  (char *)&fb->format->format);\n\t\treturn -EINVAL;\n\t}\n\n\tif (!drm_fb_dma_get_gem_obj(fb, 0)) {\n\t\tDRM_ERROR(\"Can't get DMA GEM object for fb\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (mode->clock && gdp->clk_pix) {\n\t\tstruct clk *clkp;\n\t\tint rate = mode->clock * 1000;\n\t\tint res;\n\n\t\t \n\t\tif (mixer->id == STI_MIXER_MAIN)\n\t\t\tclkp = gdp->clk_main_parent;\n\t\telse\n\t\t\tclkp = gdp->clk_aux_parent;\n\n\t\tif (clkp)\n\t\t\tclk_set_parent(gdp->clk_pix, clkp);\n\n\t\tres = clk_set_rate(gdp->clk_pix, rate);\n\t\tif (res < 0) {\n\t\t\tDRM_ERROR(\"Cannot set rate (%dHz) for gdp\\n\",\n\t\t\t\t  rate);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tDRM_DEBUG_KMS(\"CRTC:%d (%s) drm plane:%d (%s)\\n\",\n\t\t      crtc->base.id, sti_mixer_to_str(mixer),\n\t\t      drm_plane->base.id, sti_plane_to_str(plane));\n\tDRM_DEBUG_KMS(\"%s dst=(%dx%d)@(%d,%d) - src=(%dx%d)@(%d,%d)\\n\",\n\t\t      sti_plane_to_str(plane),\n\t\t      dst_w, dst_h, dst_x, dst_y,\n\t\t      src_w, src_h, src_x, src_y);\n\n\treturn 0;\n}\n\nstatic void sti_gdp_atomic_update(struct drm_plane *drm_plane,\n\t\t\t\t  struct drm_atomic_state *state)\n{\n\tstruct drm_plane_state *oldstate = drm_atomic_get_old_plane_state(state,\n\t\t\t\t\t\t\t\t\t  drm_plane);\n\tstruct drm_plane_state *newstate = drm_atomic_get_new_plane_state(state,\n\t\t\t\t\t\t\t\t\t  drm_plane);\n\tstruct sti_plane *plane = to_sti_plane(drm_plane);\n\tstruct sti_gdp *gdp = to_sti_gdp(plane);\n\tstruct drm_crtc *crtc = newstate->crtc;\n\tstruct drm_framebuffer *fb =  newstate->fb;\n\tstruct drm_display_mode *mode;\n\tint dst_x, dst_y, dst_w, dst_h;\n\tint src_x, src_y, src_w, src_h;\n\tstruct drm_gem_dma_object *dma_obj;\n\tstruct sti_gdp_node_list *list;\n\tstruct sti_gdp_node_list *curr_list;\n\tstruct sti_gdp_node *top_field, *btm_field;\n\tu32 dma_updated_top;\n\tu32 dma_updated_btm;\n\tint format;\n\tunsigned int bpp;\n\tu32 ydo, xdo, yds, xds;\n\n\tif (!crtc || !fb)\n\t\treturn;\n\n\tif ((oldstate->fb == newstate->fb) &&\n\t    (oldstate->crtc_x == newstate->crtc_x) &&\n\t    (oldstate->crtc_y == newstate->crtc_y) &&\n\t    (oldstate->crtc_w == newstate->crtc_w) &&\n\t    (oldstate->crtc_h == newstate->crtc_h) &&\n\t    (oldstate->src_x == newstate->src_x) &&\n\t    (oldstate->src_y == newstate->src_y) &&\n\t    (oldstate->src_w == newstate->src_w) &&\n\t    (oldstate->src_h == newstate->src_h)) {\n\t\t \n\t\tDRM_DEBUG_DRIVER(\"No change, not posting cmd\\n\");\n\t\tplane->status = STI_PLANE_UPDATED;\n\t\treturn;\n\t}\n\n\tif (!gdp->vtg) {\n\t\tstruct sti_compositor *compo = dev_get_drvdata(gdp->dev);\n\t\tstruct sti_mixer *mixer = to_sti_mixer(crtc);\n\n\t\t \n\t\tgdp->vtg = compo->vtg[mixer->id];\n\t\tsti_vtg_register_client(gdp->vtg, &gdp->vtg_field_nb, crtc);\n\t\tclk_prepare_enable(gdp->clk_pix);\n\t}\n\n\tmode = &crtc->mode;\n\tdst_x = newstate->crtc_x;\n\tdst_y = newstate->crtc_y;\n\tdst_w = clamp_val(newstate->crtc_w, 0, mode->hdisplay - dst_x);\n\tdst_h = clamp_val(newstate->crtc_h, 0, mode->vdisplay - dst_y);\n\t \n\tsrc_x = newstate->src_x >> 16;\n\tsrc_y = newstate->src_y >> 16;\n\tsrc_w = clamp_val(newstate->src_w >> 16, 0, GAM_GDP_SIZE_MAX_WIDTH);\n\tsrc_h = clamp_val(newstate->src_h >> 16, 0, GAM_GDP_SIZE_MAX_HEIGHT);\n\n\tlist = sti_gdp_get_free_nodes(gdp);\n\ttop_field = list->top_field;\n\tbtm_field = list->btm_field;\n\n\tdev_dbg(gdp->dev, \"%s %s top_node:0x%p btm_node:0x%p\\n\", __func__,\n\t\tsti_plane_to_str(plane), top_field, btm_field);\n\n\t \n\ttop_field->gam_gdp_agc = GAM_GDP_AGC_FULL_RANGE;\n\ttop_field->gam_gdp_ctl = WAIT_NEXT_VSYNC;\n\tformat = sti_gdp_fourcc2format(fb->format->format);\n\ttop_field->gam_gdp_ctl |= format;\n\ttop_field->gam_gdp_ctl |= sti_gdp_get_alpharange(format);\n\ttop_field->gam_gdp_ppt &= ~GAM_GDP_PPT_IGNORE;\n\n\tdma_obj = drm_fb_dma_get_gem_obj(fb, 0);\n\n\tDRM_DEBUG_DRIVER(\"drm FB:%d format:%.4s phys@:0x%lx\\n\", fb->base.id,\n\t\t\t (char *)&fb->format->format,\n\t\t\t (unsigned long) dma_obj->dma_addr);\n\n\t \n\tbpp = fb->format->cpp[0];\n\ttop_field->gam_gdp_pml = (u32) dma_obj->dma_addr + fb->offsets[0];\n\ttop_field->gam_gdp_pml += src_x * bpp;\n\ttop_field->gam_gdp_pml += src_y * fb->pitches[0];\n\n\t \n\tdst_w = sti_gdp_get_dst(gdp->dev, dst_w, src_w);\n\tdst_h = sti_gdp_get_dst(gdp->dev, dst_h, src_h);\n\tydo = sti_vtg_get_line_number(*mode, dst_y);\n\tyds = sti_vtg_get_line_number(*mode, dst_y + dst_h - 1);\n\txdo = sti_vtg_get_pixel_number(*mode, dst_x);\n\txds = sti_vtg_get_pixel_number(*mode, dst_x + dst_w - 1);\n\ttop_field->gam_gdp_vpo = (ydo << 16) | xdo;\n\ttop_field->gam_gdp_vps = (yds << 16) | xds;\n\n\t \n\tsrc_w = dst_w;\n\ttop_field->gam_gdp_pmp = fb->pitches[0];\n\ttop_field->gam_gdp_size = src_h << 16 | src_w;\n\n\t \n\tmemcpy(btm_field, top_field, sizeof(*btm_field));\n\ttop_field->gam_gdp_nvn = list->btm_field_paddr;\n\tbtm_field->gam_gdp_nvn = list->top_field_paddr;\n\n\t \n\tif (mode->flags & DRM_MODE_FLAG_INTERLACE)\n\t\tbtm_field->gam_gdp_pml = top_field->gam_gdp_pml +\n\t\t\t\t\t fb->pitches[0];\n\n\t \n\tcurr_list = sti_gdp_get_current_nodes(gdp);\n\tdma_updated_top = list->top_field_paddr;\n\tdma_updated_btm = list->btm_field_paddr;\n\n\tdev_dbg(gdp->dev, \"Current NVN:0x%X\\n\",\n\t\treadl(gdp->regs + GAM_GDP_NVN_OFFSET));\n\tdev_dbg(gdp->dev, \"Posted buff: %lx current buff: %x\\n\",\n\t\t(unsigned long) dma_obj->dma_addr,\n\t\treadl(gdp->regs + GAM_GDP_PML_OFFSET));\n\n\tif (!curr_list) {\n\t\t \n\t\tDRM_DEBUG_DRIVER(\"%s first update (or invalid node)\\n\",\n\t\t\t\t sti_plane_to_str(plane));\n\n\t\twritel(gdp->is_curr_top ?\n\t\t\t\tdma_updated_btm : dma_updated_top,\n\t\t\t\tgdp->regs + GAM_GDP_NVN_OFFSET);\n\t\tgoto end;\n\t}\n\n\tif (mode->flags & DRM_MODE_FLAG_INTERLACE) {\n\t\tif (gdp->is_curr_top) {\n\t\t\t \n\t\t\tcurr_list->btm_field->gam_gdp_nvn = dma_updated_top;\n\t\t} else {\n\t\t\t \n\t\t\twritel(dma_updated_top,\n\t\t\t       gdp->regs + GAM_GDP_NVN_OFFSET);\n\t\t}\n\t} else {\n\t\t \n\t\twritel(dma_updated_top, gdp->regs + GAM_GDP_NVN_OFFSET);\n\t}\n\nend:\n\tsti_plane_update_fps(plane, true, false);\n\n\tplane->status = STI_PLANE_UPDATED;\n}\n\nstatic void sti_gdp_atomic_disable(struct drm_plane *drm_plane,\n\t\t\t\t   struct drm_atomic_state *state)\n{\n\tstruct drm_plane_state *oldstate = drm_atomic_get_old_plane_state(state,\n\t\t\t\t\t\t\t\t\t  drm_plane);\n\tstruct sti_plane *plane = to_sti_plane(drm_plane);\n\n\tif (!oldstate->crtc) {\n\t\tDRM_DEBUG_DRIVER(\"drm plane:%d not enabled\\n\",\n\t\t\t\t drm_plane->base.id);\n\t\treturn;\n\t}\n\n\tDRM_DEBUG_DRIVER(\"CRTC:%d (%s) drm plane:%d (%s)\\n\",\n\t\t\t oldstate->crtc->base.id,\n\t\t\t sti_mixer_to_str(to_sti_mixer(oldstate->crtc)),\n\t\t\t drm_plane->base.id, sti_plane_to_str(plane));\n\n\tplane->status = STI_PLANE_DISABLING;\n}\n\nstatic const struct drm_plane_helper_funcs sti_gdp_helpers_funcs = {\n\t.atomic_check = sti_gdp_atomic_check,\n\t.atomic_update = sti_gdp_atomic_update,\n\t.atomic_disable = sti_gdp_atomic_disable,\n};\n\nstatic int sti_gdp_late_register(struct drm_plane *drm_plane)\n{\n\tstruct sti_plane *plane = to_sti_plane(drm_plane);\n\tstruct sti_gdp *gdp = to_sti_gdp(plane);\n\n\treturn gdp_debugfs_init(gdp, drm_plane->dev->primary);\n}\n\nstatic const struct drm_plane_funcs sti_gdp_plane_helpers_funcs = {\n\t.update_plane = drm_atomic_helper_update_plane,\n\t.disable_plane = drm_atomic_helper_disable_plane,\n\t.destroy = drm_plane_cleanup,\n\t.reset = drm_atomic_helper_plane_reset,\n\t.atomic_duplicate_state = drm_atomic_helper_plane_duplicate_state,\n\t.atomic_destroy_state = drm_atomic_helper_plane_destroy_state,\n\t.late_register = sti_gdp_late_register,\n};\n\nstruct drm_plane *sti_gdp_create(struct drm_device *drm_dev,\n\t\t\t\t struct device *dev, int desc,\n\t\t\t\t void __iomem *baseaddr,\n\t\t\t\t unsigned int possible_crtcs,\n\t\t\t\t enum drm_plane_type type)\n{\n\tstruct sti_gdp *gdp;\n\tint res;\n\n\tgdp = devm_kzalloc(dev, sizeof(*gdp), GFP_KERNEL);\n\tif (!gdp) {\n\t\tDRM_ERROR(\"Failed to allocate memory for GDP\\n\");\n\t\treturn NULL;\n\t}\n\n\tgdp->dev = dev;\n\tgdp->regs = baseaddr;\n\tgdp->plane.desc = desc;\n\tgdp->plane.status = STI_PLANE_DISABLED;\n\n\tgdp->vtg_field_nb.notifier_call = sti_gdp_field_cb;\n\n\tsti_gdp_init(gdp);\n\n\tres = drm_universal_plane_init(drm_dev, &gdp->plane.drm_plane,\n\t\t\t\t       possible_crtcs,\n\t\t\t\t       &sti_gdp_plane_helpers_funcs,\n\t\t\t\t       gdp_supported_formats,\n\t\t\t\t       ARRAY_SIZE(gdp_supported_formats),\n\t\t\t\t       NULL, type, NULL);\n\tif (res) {\n\t\tDRM_ERROR(\"Failed to initialize universal plane\\n\");\n\t\tgoto err;\n\t}\n\n\tdrm_plane_helper_add(&gdp->plane.drm_plane, &sti_gdp_helpers_funcs);\n\n\tsti_plane_init_property(&gdp->plane, type);\n\n\treturn &gdp->plane.drm_plane;\n\nerr:\n\tdevm_kfree(dev, gdp);\n\treturn NULL;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}