{
  "module_name": "sti_mixer.c",
  "hash_id": "d232e0f78a6b55229d2a07377be89a2180e2cf23d917ed5ae60f38575492f297",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/sti/sti_mixer.c",
  "human_readable_source": "\n \n\n#include <linux/moduleparam.h>\n#include <linux/seq_file.h>\n\n#include <drm/drm_print.h>\n\n#include \"sti_compositor.h\"\n#include \"sti_mixer.h\"\n#include \"sti_vtg.h\"\n\n \nstatic unsigned int bkg_color = 0x000000;\nMODULE_PARM_DESC(bkgcolor, \"Value of the background color 0xRRGGBB\");\nmodule_param_named(bkgcolor, bkg_color, int, 0644);\n\n \n#define GAM_MIXER_CTL      0x00\n#define GAM_MIXER_BKC      0x04\n#define GAM_MIXER_BCO      0x0C\n#define GAM_MIXER_BCS      0x10\n#define GAM_MIXER_AVO      0x28\n#define GAM_MIXER_AVS      0x2C\n#define GAM_MIXER_CRB      0x34\n#define GAM_MIXER_ACT      0x38\n#define GAM_MIXER_MBP      0x3C\n#define GAM_MIXER_MX0      0x80\n\n \n#define GAM_DEPTH_VID0_ID  1\n#define GAM_DEPTH_VID1_ID  2\n#define GAM_DEPTH_GDP0_ID  3\n#define GAM_DEPTH_GDP1_ID  4\n#define GAM_DEPTH_GDP2_ID  5\n#define GAM_DEPTH_GDP3_ID  6\n#define GAM_DEPTH_MASK_ID  7\n\n \n#define GAM_CTL_BACK_MASK  BIT(0)\n#define GAM_CTL_VID0_MASK  BIT(1)\n#define GAM_CTL_VID1_MASK  BIT(2)\n#define GAM_CTL_GDP0_MASK  BIT(3)\n#define GAM_CTL_GDP1_MASK  BIT(4)\n#define GAM_CTL_GDP2_MASK  BIT(5)\n#define GAM_CTL_GDP3_MASK  BIT(6)\n#define GAM_CTL_CURSOR_MASK BIT(9)\n\nconst char *sti_mixer_to_str(struct sti_mixer *mixer)\n{\n\tswitch (mixer->id) {\n\tcase STI_MIXER_MAIN:\n\t\treturn \"MAIN_MIXER\";\n\tcase STI_MIXER_AUX:\n\t\treturn \"AUX_MIXER\";\n\tdefault:\n\t\treturn \"<UNKNOWN MIXER>\";\n\t}\n}\n\nstatic inline u32 sti_mixer_reg_read(struct sti_mixer *mixer, u32 reg_id)\n{\n\treturn readl(mixer->regs + reg_id);\n}\n\nstatic inline void sti_mixer_reg_write(struct sti_mixer *mixer,\n\t\t\t\t       u32 reg_id, u32 val)\n{\n\twritel(val, mixer->regs + reg_id);\n}\n\n#define DBGFS_DUMP(reg) seq_printf(s, \"\\n  %-25s 0x%08X\", #reg, \\\n\t\t\t\t   sti_mixer_reg_read(mixer, reg))\n\nstatic void mixer_dbg_ctl(struct seq_file *s, int val)\n{\n\tunsigned int i;\n\tint count = 0;\n\tchar *const disp_layer[] = {\"BKG\", \"VID0\", \"VID1\", \"GDP0\",\n\t\t\t\t    \"GDP1\", \"GDP2\", \"GDP3\"};\n\n\tseq_puts(s, \"\\tEnabled: \");\n\tfor (i = 0; i < 7; i++) {\n\t\tif (val & 1) {\n\t\t\tseq_printf(s, \"%s \", disp_layer[i]);\n\t\t\tcount++;\n\t\t}\n\t\tval = val >> 1;\n\t}\n\n\tval = val >> 2;\n\tif (val & 1) {\n\t\tseq_puts(s, \"CURS \");\n\t\tcount++;\n\t}\n\tif (!count)\n\t\tseq_puts(s, \"Nothing\");\n}\n\nstatic void mixer_dbg_crb(struct seq_file *s, int val)\n{\n\tint i;\n\n\tseq_puts(s, \"\\tDepth: \");\n\tfor (i = 0; i < GAM_MIXER_NB_DEPTH_LEVEL; i++) {\n\t\tswitch (val & GAM_DEPTH_MASK_ID) {\n\t\tcase GAM_DEPTH_VID0_ID:\n\t\t\tseq_puts(s, \"VID0\");\n\t\t\tbreak;\n\t\tcase GAM_DEPTH_VID1_ID:\n\t\t\tseq_puts(s, \"VID1\");\n\t\t\tbreak;\n\t\tcase GAM_DEPTH_GDP0_ID:\n\t\t\tseq_puts(s, \"GDP0\");\n\t\t\tbreak;\n\t\tcase GAM_DEPTH_GDP1_ID:\n\t\t\tseq_puts(s, \"GDP1\");\n\t\t\tbreak;\n\t\tcase GAM_DEPTH_GDP2_ID:\n\t\t\tseq_puts(s, \"GDP2\");\n\t\t\tbreak;\n\t\tcase GAM_DEPTH_GDP3_ID:\n\t\t\tseq_puts(s, \"GDP3\");\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tseq_puts(s, \"---\");\n\t\t}\n\n\t\tif (i < GAM_MIXER_NB_DEPTH_LEVEL - 1)\n\t\t\tseq_puts(s, \" < \");\n\t\tval = val >> 3;\n\t}\n}\n\nstatic void mixer_dbg_mxn(struct seq_file *s, void *addr)\n{\n\tint i;\n\n\tfor (i = 1; i < 8; i++)\n\t\tseq_printf(s, \"-0x%08X\", (int)readl(addr + i * 4));\n}\n\nstatic int mixer_dbg_show(struct seq_file *s, void *arg)\n{\n\tstruct drm_info_node *node = s->private;\n\tstruct sti_mixer *mixer = (struct sti_mixer *)node->info_ent->data;\n\n\tseq_printf(s, \"%s: (vaddr = 0x%p)\",\n\t\t   sti_mixer_to_str(mixer), mixer->regs);\n\n\tDBGFS_DUMP(GAM_MIXER_CTL);\n\tmixer_dbg_ctl(s, sti_mixer_reg_read(mixer, GAM_MIXER_CTL));\n\tDBGFS_DUMP(GAM_MIXER_BKC);\n\tDBGFS_DUMP(GAM_MIXER_BCO);\n\tDBGFS_DUMP(GAM_MIXER_BCS);\n\tDBGFS_DUMP(GAM_MIXER_AVO);\n\tDBGFS_DUMP(GAM_MIXER_AVS);\n\tDBGFS_DUMP(GAM_MIXER_CRB);\n\tmixer_dbg_crb(s, sti_mixer_reg_read(mixer, GAM_MIXER_CRB));\n\tDBGFS_DUMP(GAM_MIXER_ACT);\n\tDBGFS_DUMP(GAM_MIXER_MBP);\n\tDBGFS_DUMP(GAM_MIXER_MX0);\n\tmixer_dbg_mxn(s, mixer->regs + GAM_MIXER_MX0);\n\tseq_putc(s, '\\n');\n\treturn 0;\n}\n\nstatic struct drm_info_list mixer0_debugfs_files[] = {\n\t{ \"mixer_main\", mixer_dbg_show, 0, NULL },\n};\n\nstatic struct drm_info_list mixer1_debugfs_files[] = {\n\t{ \"mixer_aux\", mixer_dbg_show, 0, NULL },\n};\n\nvoid sti_mixer_debugfs_init(struct sti_mixer *mixer, struct drm_minor *minor)\n{\n\tunsigned int i;\n\tstruct drm_info_list *mixer_debugfs_files;\n\tint nb_files;\n\n\tswitch (mixer->id) {\n\tcase STI_MIXER_MAIN:\n\t\tmixer_debugfs_files = mixer0_debugfs_files;\n\t\tnb_files = ARRAY_SIZE(mixer0_debugfs_files);\n\t\tbreak;\n\tcase STI_MIXER_AUX:\n\t\tmixer_debugfs_files = mixer1_debugfs_files;\n\t\tnb_files = ARRAY_SIZE(mixer1_debugfs_files);\n\t\tbreak;\n\tdefault:\n\t\treturn;\n\t}\n\n\tfor (i = 0; i < nb_files; i++)\n\t\tmixer_debugfs_files[i].data = mixer;\n\n\tdrm_debugfs_create_files(mixer_debugfs_files,\n\t\t\t\t nb_files,\n\t\t\t\t minor->debugfs_root, minor);\n}\n\nvoid sti_mixer_set_background_status(struct sti_mixer *mixer, bool enable)\n{\n\tu32 val = sti_mixer_reg_read(mixer, GAM_MIXER_CTL);\n\n\tval &= ~GAM_CTL_BACK_MASK;\n\tval |= enable;\n\tsti_mixer_reg_write(mixer, GAM_MIXER_CTL, val);\n}\n\nstatic void sti_mixer_set_background_color(struct sti_mixer *mixer,\n\t\t\t\t\t   unsigned int rgb)\n{\n\tsti_mixer_reg_write(mixer, GAM_MIXER_BKC, rgb);\n}\n\nstatic void sti_mixer_set_background_area(struct sti_mixer *mixer,\n\t\t\t\t\t  struct drm_display_mode *mode)\n{\n\tu32 ydo, xdo, yds, xds;\n\n\tydo = sti_vtg_get_line_number(*mode, 0);\n\tyds = sti_vtg_get_line_number(*mode, mode->vdisplay - 1);\n\txdo = sti_vtg_get_pixel_number(*mode, 0);\n\txds = sti_vtg_get_pixel_number(*mode, mode->hdisplay - 1);\n\n\tsti_mixer_reg_write(mixer, GAM_MIXER_BCO, ydo << 16 | xdo);\n\tsti_mixer_reg_write(mixer, GAM_MIXER_BCS, yds << 16 | xds);\n}\n\nint sti_mixer_set_plane_depth(struct sti_mixer *mixer, struct sti_plane *plane)\n{\n\tint plane_id, depth = plane->drm_plane.state->normalized_zpos;\n\tunsigned int i;\n\tu32 mask, val;\n\n\tswitch (plane->desc) {\n\tcase STI_GDP_0:\n\t\tplane_id = GAM_DEPTH_GDP0_ID;\n\t\tbreak;\n\tcase STI_GDP_1:\n\t\tplane_id = GAM_DEPTH_GDP1_ID;\n\t\tbreak;\n\tcase STI_GDP_2:\n\t\tplane_id = GAM_DEPTH_GDP2_ID;\n\t\tbreak;\n\tcase STI_GDP_3:\n\t\tplane_id = GAM_DEPTH_GDP3_ID;\n\t\tbreak;\n\tcase STI_HQVDP_0:\n\t\tplane_id = GAM_DEPTH_VID0_ID;\n\t\tbreak;\n\tcase STI_CURSOR:\n\t\t \n\t\treturn 0;\n\tdefault:\n\t\tDRM_ERROR(\"Unknown plane %d\\n\", plane->desc);\n\t\treturn 1;\n\t}\n\n\t \n\tval = sti_mixer_reg_read(mixer, GAM_MIXER_CRB);\n\tfor (i = 0; i < GAM_MIXER_NB_DEPTH_LEVEL; i++) {\n\t\tmask = GAM_DEPTH_MASK_ID << (3 * i);\n\t\tif ((val & mask) == plane_id << (3 * i))\n\t\t\tbreak;\n\t}\n\n\tmask |= GAM_DEPTH_MASK_ID << (3 * depth);\n\tplane_id = plane_id << (3 * depth);\n\n\tDRM_DEBUG_DRIVER(\"%s %s depth=%d\\n\", sti_mixer_to_str(mixer),\n\t\t\t sti_plane_to_str(plane), depth);\n\tdev_dbg(mixer->dev, \"GAM_MIXER_CRB val 0x%x mask 0x%x\\n\",\n\t\tplane_id, mask);\n\n\tval &= ~mask;\n\tval |= plane_id;\n\tsti_mixer_reg_write(mixer, GAM_MIXER_CRB, val);\n\n\tdev_dbg(mixer->dev, \"Read GAM_MIXER_CRB 0x%x\\n\",\n\t\tsti_mixer_reg_read(mixer, GAM_MIXER_CRB));\n\treturn 0;\n}\n\nint sti_mixer_active_video_area(struct sti_mixer *mixer,\n\t\t\t\tstruct drm_display_mode *mode)\n{\n\tu32 ydo, xdo, yds, xds;\n\n\tydo = sti_vtg_get_line_number(*mode, 0);\n\tyds = sti_vtg_get_line_number(*mode, mode->vdisplay - 1);\n\txdo = sti_vtg_get_pixel_number(*mode, 0);\n\txds = sti_vtg_get_pixel_number(*mode, mode->hdisplay - 1);\n\n\tDRM_DEBUG_DRIVER(\"%s active video area xdo:%d ydo:%d xds:%d yds:%d\\n\",\n\t\t\t sti_mixer_to_str(mixer), xdo, ydo, xds, yds);\n\tsti_mixer_reg_write(mixer, GAM_MIXER_AVO, ydo << 16 | xdo);\n\tsti_mixer_reg_write(mixer, GAM_MIXER_AVS, yds << 16 | xds);\n\n\tsti_mixer_set_background_color(mixer, bkg_color);\n\n\tsti_mixer_set_background_area(mixer, mode);\n\tsti_mixer_set_background_status(mixer, true);\n\treturn 0;\n}\n\nstatic u32 sti_mixer_get_plane_mask(struct sti_plane *plane)\n{\n\tswitch (plane->desc) {\n\tcase STI_BACK:\n\t\treturn GAM_CTL_BACK_MASK;\n\tcase STI_GDP_0:\n\t\treturn GAM_CTL_GDP0_MASK;\n\tcase STI_GDP_1:\n\t\treturn GAM_CTL_GDP1_MASK;\n\tcase STI_GDP_2:\n\t\treturn GAM_CTL_GDP2_MASK;\n\tcase STI_GDP_3:\n\t\treturn GAM_CTL_GDP3_MASK;\n\tcase STI_HQVDP_0:\n\t\treturn GAM_CTL_VID0_MASK;\n\tcase STI_CURSOR:\n\t\treturn GAM_CTL_CURSOR_MASK;\n\tdefault:\n\t\treturn 0;\n\t}\n}\n\nint sti_mixer_set_plane_status(struct sti_mixer *mixer,\n\t\t\t       struct sti_plane *plane, bool status)\n{\n\tu32 mask, val;\n\n\tDRM_DEBUG_DRIVER(\"%s %s %s\\n\", status ? \"enable\" : \"disable\",\n\t\t\t sti_mixer_to_str(mixer), sti_plane_to_str(plane));\n\n\tmask = sti_mixer_get_plane_mask(plane);\n\tif (!mask) {\n\t\tDRM_ERROR(\"Can't find layer mask\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tval = sti_mixer_reg_read(mixer, GAM_MIXER_CTL);\n\tval &= ~mask;\n\tval |= status ? mask : 0;\n\tsti_mixer_reg_write(mixer, GAM_MIXER_CTL, val);\n\n\treturn 0;\n}\n\nstruct sti_mixer *sti_mixer_create(struct device *dev,\n\t\t\t\t   struct drm_device *drm_dev,\n\t\t\t\t   int id,\n\t\t\t\t   void __iomem *baseaddr)\n{\n\tstruct sti_mixer *mixer = devm_kzalloc(dev, sizeof(*mixer), GFP_KERNEL);\n\n\tdev_dbg(dev, \"%s\\n\", __func__);\n\tif (!mixer) {\n\t\tDRM_ERROR(\"Failed to allocated memory for mixer\\n\");\n\t\treturn NULL;\n\t}\n\tmixer->regs = baseaddr;\n\tmixer->dev = dev;\n\tmixer->id = id;\n\n\tDRM_DEBUG_DRIVER(\"%s created. Regs=%p\\n\",\n\t\t\t sti_mixer_to_str(mixer), mixer->regs);\n\n\treturn mixer;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}