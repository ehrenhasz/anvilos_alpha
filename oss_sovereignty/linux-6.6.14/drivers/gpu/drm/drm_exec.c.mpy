{
  "module_name": "drm_exec.c",
  "hash_id": "24f158e261581a3e436003cede76b2098b28a0b922395032db7964fb9664ff96",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/drm_exec.c",
  "human_readable_source": "\n\n#include <drm/drm_exec.h>\n#include <drm/drm_gem.h>\n#include <linux/dma-resv.h>\n\n \n\n \n#define DRM_EXEC_DUMMY ((void *)~0)\n\n \nstatic void drm_exec_unlock_all(struct drm_exec *exec)\n{\n\tstruct drm_gem_object *obj;\n\tunsigned long index;\n\n\tdrm_exec_for_each_locked_object_reverse(exec, index, obj) {\n\t\tdma_resv_unlock(obj->resv);\n\t\tdrm_gem_object_put(obj);\n\t}\n\n\tdrm_gem_object_put(exec->prelocked);\n\texec->prelocked = NULL;\n}\n\n \nvoid drm_exec_init(struct drm_exec *exec, uint32_t flags)\n{\n\texec->flags = flags;\n\texec->objects = kmalloc(PAGE_SIZE, GFP_KERNEL);\n\n\t \n\texec->max_objects = exec->objects ? PAGE_SIZE / sizeof(void *) : 0;\n\texec->num_objects = 0;\n\texec->contended = DRM_EXEC_DUMMY;\n\texec->prelocked = NULL;\n}\nEXPORT_SYMBOL(drm_exec_init);\n\n \nvoid drm_exec_fini(struct drm_exec *exec)\n{\n\tdrm_exec_unlock_all(exec);\n\tkvfree(exec->objects);\n\tif (exec->contended != DRM_EXEC_DUMMY) {\n\t\tdrm_gem_object_put(exec->contended);\n\t\tww_acquire_fini(&exec->ticket);\n\t}\n}\nEXPORT_SYMBOL(drm_exec_fini);\n\n \nbool drm_exec_cleanup(struct drm_exec *exec)\n{\n\tif (likely(!exec->contended)) {\n\t\tww_acquire_done(&exec->ticket);\n\t\treturn false;\n\t}\n\n\tif (likely(exec->contended == DRM_EXEC_DUMMY)) {\n\t\texec->contended = NULL;\n\t\tww_acquire_init(&exec->ticket, &reservation_ww_class);\n\t\treturn true;\n\t}\n\n\tdrm_exec_unlock_all(exec);\n\texec->num_objects = 0;\n\treturn true;\n}\nEXPORT_SYMBOL(drm_exec_cleanup);\n\n \nstatic int drm_exec_obj_locked(struct drm_exec *exec,\n\t\t\t       struct drm_gem_object *obj)\n{\n\tif (unlikely(exec->num_objects == exec->max_objects)) {\n\t\tsize_t size = exec->max_objects * sizeof(void *);\n\t\tvoid *tmp;\n\n\t\ttmp = kvrealloc(exec->objects, size, size + PAGE_SIZE,\n\t\t\t\tGFP_KERNEL);\n\t\tif (!tmp)\n\t\t\treturn -ENOMEM;\n\n\t\texec->objects = tmp;\n\t\texec->max_objects += PAGE_SIZE / sizeof(void *);\n\t}\n\tdrm_gem_object_get(obj);\n\texec->objects[exec->num_objects++] = obj;\n\n\treturn 0;\n}\n\n \nstatic int drm_exec_lock_contended(struct drm_exec *exec)\n{\n\tstruct drm_gem_object *obj = exec->contended;\n\tint ret;\n\n\tif (likely(!obj))\n\t\treturn 0;\n\n\t \n\texec->contended = NULL;\n\tif (exec->flags & DRM_EXEC_INTERRUPTIBLE_WAIT) {\n\t\tret = dma_resv_lock_slow_interruptible(obj->resv,\n\t\t\t\t\t\t       &exec->ticket);\n\t\tif (unlikely(ret))\n\t\t\tgoto error_dropref;\n\t} else {\n\t\tdma_resv_lock_slow(obj->resv, &exec->ticket);\n\t}\n\n\tret = drm_exec_obj_locked(exec, obj);\n\tif (unlikely(ret))\n\t\tgoto error_unlock;\n\n\texec->prelocked = obj;\n\treturn 0;\n\nerror_unlock:\n\tdma_resv_unlock(obj->resv);\n\nerror_dropref:\n\tdrm_gem_object_put(obj);\n\treturn ret;\n}\n\n \nint drm_exec_lock_obj(struct drm_exec *exec, struct drm_gem_object *obj)\n{\n\tint ret;\n\n\tret = drm_exec_lock_contended(exec);\n\tif (unlikely(ret))\n\t\treturn ret;\n\n\tif (exec->prelocked == obj) {\n\t\tdrm_gem_object_put(exec->prelocked);\n\t\texec->prelocked = NULL;\n\t\treturn 0;\n\t}\n\n\tif (exec->flags & DRM_EXEC_INTERRUPTIBLE_WAIT)\n\t\tret = dma_resv_lock_interruptible(obj->resv, &exec->ticket);\n\telse\n\t\tret = dma_resv_lock(obj->resv, &exec->ticket);\n\n\tif (unlikely(ret == -EDEADLK)) {\n\t\tdrm_gem_object_get(obj);\n\t\texec->contended = obj;\n\t\treturn -EDEADLK;\n\t}\n\n\tif (unlikely(ret == -EALREADY) &&\n\t    exec->flags & DRM_EXEC_IGNORE_DUPLICATES)\n\t\treturn 0;\n\n\tif (unlikely(ret))\n\t\treturn ret;\n\n\tret = drm_exec_obj_locked(exec, obj);\n\tif (ret)\n\t\tgoto error_unlock;\n\n\treturn 0;\n\nerror_unlock:\n\tdma_resv_unlock(obj->resv);\n\treturn ret;\n}\nEXPORT_SYMBOL(drm_exec_lock_obj);\n\n \nvoid drm_exec_unlock_obj(struct drm_exec *exec, struct drm_gem_object *obj)\n{\n\tunsigned int i;\n\n\tfor (i = exec->num_objects; i--;) {\n\t\tif (exec->objects[i] == obj) {\n\t\t\tdma_resv_unlock(obj->resv);\n\t\t\tfor (++i; i < exec->num_objects; ++i)\n\t\t\t\texec->objects[i - 1] = exec->objects[i];\n\t\t\t--exec->num_objects;\n\t\t\tdrm_gem_object_put(obj);\n\t\t\treturn;\n\t\t}\n\n\t}\n}\nEXPORT_SYMBOL(drm_exec_unlock_obj);\n\n \nint drm_exec_prepare_obj(struct drm_exec *exec, struct drm_gem_object *obj,\n\t\t\t unsigned int num_fences)\n{\n\tint ret;\n\n\tret = drm_exec_lock_obj(exec, obj);\n\tif (ret)\n\t\treturn ret;\n\n\tret = dma_resv_reserve_fences(obj->resv, num_fences);\n\tif (ret) {\n\t\tdrm_exec_unlock_obj(exec, obj);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL(drm_exec_prepare_obj);\n\n \nint drm_exec_prepare_array(struct drm_exec *exec,\n\t\t\t   struct drm_gem_object **objects,\n\t\t\t   unsigned int num_objects,\n\t\t\t   unsigned int num_fences)\n{\n\tint ret;\n\n\tfor (unsigned int i = 0; i < num_objects; ++i) {\n\t\tret = drm_exec_prepare_obj(exec, objects[i], num_fences);\n\t\tif (unlikely(ret))\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL(drm_exec_prepare_array);\n\nMODULE_DESCRIPTION(\"DRM execution context\");\nMODULE_LICENSE(\"Dual MIT/GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}