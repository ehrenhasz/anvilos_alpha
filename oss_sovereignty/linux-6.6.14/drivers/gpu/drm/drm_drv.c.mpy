{
  "module_name": "drm_drv.c",
  "hash_id": "3b9c8d7b72c09391337e3d608c168d644b96162b02eea8331cf3649de9a63a2f",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/drm_drv.c",
  "human_readable_source": " \n\n#include <linux/debugfs.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n#include <linux/moduleparam.h>\n#include <linux/mount.h>\n#include <linux/pseudo_fs.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n\n#include <drm/drm_accel.h>\n#include <drm/drm_cache.h>\n#include <drm/drm_client.h>\n#include <drm/drm_color_mgmt.h>\n#include <drm/drm_drv.h>\n#include <drm/drm_file.h>\n#include <drm/drm_managed.h>\n#include <drm/drm_mode_object.h>\n#include <drm/drm_print.h>\n#include <drm/drm_privacy_screen_machine.h>\n\n#include \"drm_crtc_internal.h\"\n#include \"drm_internal.h\"\n#include \"drm_legacy.h\"\n\nMODULE_AUTHOR(\"Gareth Hughes, Leif Delgass, Jos\u00e9 Fonseca, Jon Smirl\");\nMODULE_DESCRIPTION(\"DRM shared core routines\");\nMODULE_LICENSE(\"GPL and additional rights\");\n\nstatic DEFINE_SPINLOCK(drm_minor_lock);\nstatic struct idr drm_minors_idr;\n\n \nstatic bool drm_core_init_complete;\n\nstatic struct dentry *drm_debugfs_root;\n\nDEFINE_STATIC_SRCU(drm_unplug_srcu);\n\n \n\nstatic struct drm_minor **drm_minor_get_slot(struct drm_device *dev,\n\t\t\t\t\t     enum drm_minor_type type)\n{\n\tswitch (type) {\n\tcase DRM_MINOR_PRIMARY:\n\t\treturn &dev->primary;\n\tcase DRM_MINOR_RENDER:\n\t\treturn &dev->render;\n\tcase DRM_MINOR_ACCEL:\n\t\treturn &dev->accel;\n\tdefault:\n\t\tBUG();\n\t}\n}\n\nstatic void drm_minor_alloc_release(struct drm_device *dev, void *data)\n{\n\tstruct drm_minor *minor = data;\n\tunsigned long flags;\n\n\tWARN_ON(dev != minor->dev);\n\n\tput_device(minor->kdev);\n\n\tif (minor->type == DRM_MINOR_ACCEL) {\n\t\taccel_minor_remove(minor->index);\n\t} else {\n\t\tspin_lock_irqsave(&drm_minor_lock, flags);\n\t\tidr_remove(&drm_minors_idr, minor->index);\n\t\tspin_unlock_irqrestore(&drm_minor_lock, flags);\n\t}\n}\n\nstatic int drm_minor_alloc(struct drm_device *dev, enum drm_minor_type type)\n{\n\tstruct drm_minor *minor;\n\tunsigned long flags;\n\tint r;\n\n\tminor = drmm_kzalloc(dev, sizeof(*minor), GFP_KERNEL);\n\tif (!minor)\n\t\treturn -ENOMEM;\n\n\tminor->type = type;\n\tminor->dev = dev;\n\n\tidr_preload(GFP_KERNEL);\n\tif (type == DRM_MINOR_ACCEL) {\n\t\tr = accel_minor_alloc();\n\t} else {\n\t\tspin_lock_irqsave(&drm_minor_lock, flags);\n\t\tr = idr_alloc(&drm_minors_idr,\n\t\t\tNULL,\n\t\t\t64 * type,\n\t\t\t64 * (type + 1),\n\t\t\tGFP_NOWAIT);\n\t\tspin_unlock_irqrestore(&drm_minor_lock, flags);\n\t}\n\tidr_preload_end();\n\n\tif (r < 0)\n\t\treturn r;\n\n\tminor->index = r;\n\n\tr = drmm_add_action_or_reset(dev, drm_minor_alloc_release, minor);\n\tif (r)\n\t\treturn r;\n\n\tminor->kdev = drm_sysfs_minor_alloc(minor);\n\tif (IS_ERR(minor->kdev))\n\t\treturn PTR_ERR(minor->kdev);\n\n\t*drm_minor_get_slot(dev, type) = minor;\n\treturn 0;\n}\n\nstatic int drm_minor_register(struct drm_device *dev, enum drm_minor_type type)\n{\n\tstruct drm_minor *minor;\n\tunsigned long flags;\n\tint ret;\n\n\tDRM_DEBUG(\"\\n\");\n\n\tminor = *drm_minor_get_slot(dev, type);\n\tif (!minor)\n\t\treturn 0;\n\n\tif (minor->type == DRM_MINOR_ACCEL) {\n\t\taccel_debugfs_init(minor, minor->index);\n\t} else {\n\t\tret = drm_debugfs_init(minor, minor->index, drm_debugfs_root);\n\t\tif (ret) {\n\t\t\tDRM_ERROR(\"DRM: Failed to initialize /sys/kernel/debug/dri.\\n\");\n\t\t\tgoto err_debugfs;\n\t\t}\n\t}\n\n\tret = device_add(minor->kdev);\n\tif (ret)\n\t\tgoto err_debugfs;\n\n\t \n\tif (minor->type == DRM_MINOR_ACCEL) {\n\t\taccel_minor_replace(minor, minor->index);\n\t} else {\n\t\tspin_lock_irqsave(&drm_minor_lock, flags);\n\t\tidr_replace(&drm_minors_idr, minor, minor->index);\n\t\tspin_unlock_irqrestore(&drm_minor_lock, flags);\n\t}\n\n\tDRM_DEBUG(\"new minor registered %d\\n\", minor->index);\n\treturn 0;\n\nerr_debugfs:\n\tdrm_debugfs_cleanup(minor);\n\treturn ret;\n}\n\nstatic void drm_minor_unregister(struct drm_device *dev, enum drm_minor_type type)\n{\n\tstruct drm_minor *minor;\n\tunsigned long flags;\n\n\tminor = *drm_minor_get_slot(dev, type);\n\tif (!minor || !device_is_registered(minor->kdev))\n\t\treturn;\n\n\t \n\tif (minor->type == DRM_MINOR_ACCEL) {\n\t\taccel_minor_replace(NULL, minor->index);\n\t} else {\n\t\tspin_lock_irqsave(&drm_minor_lock, flags);\n\t\tidr_replace(&drm_minors_idr, NULL, minor->index);\n\t\tspin_unlock_irqrestore(&drm_minor_lock, flags);\n\t}\n\n\tdevice_del(minor->kdev);\n\tdev_set_drvdata(minor->kdev, NULL);  \n\tdrm_debugfs_cleanup(minor);\n}\n\n \nstruct drm_minor *drm_minor_acquire(unsigned int minor_id)\n{\n\tstruct drm_minor *minor;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&drm_minor_lock, flags);\n\tminor = idr_find(&drm_minors_idr, minor_id);\n\tif (minor)\n\t\tdrm_dev_get(minor->dev);\n\tspin_unlock_irqrestore(&drm_minor_lock, flags);\n\n\tif (!minor) {\n\t\treturn ERR_PTR(-ENODEV);\n\t} else if (drm_dev_is_unplugged(minor->dev)) {\n\t\tdrm_dev_put(minor->dev);\n\t\treturn ERR_PTR(-ENODEV);\n\t}\n\n\treturn minor;\n}\n\nvoid drm_minor_release(struct drm_minor *minor)\n{\n\tdrm_dev_put(minor->dev);\n}\n\n \n\n \nvoid drm_put_dev(struct drm_device *dev)\n{\n\tDRM_DEBUG(\"\\n\");\n\n\tif (!dev) {\n\t\tDRM_ERROR(\"cleanup called no dev\\n\");\n\t\treturn;\n\t}\n\n\tdrm_dev_unregister(dev);\n\tdrm_dev_put(dev);\n}\nEXPORT_SYMBOL(drm_put_dev);\n\n \nbool drm_dev_enter(struct drm_device *dev, int *idx)\n{\n\t*idx = srcu_read_lock(&drm_unplug_srcu);\n\n\tif (dev->unplugged) {\n\t\tsrcu_read_unlock(&drm_unplug_srcu, *idx);\n\t\treturn false;\n\t}\n\n\treturn true;\n}\nEXPORT_SYMBOL(drm_dev_enter);\n\n \nvoid drm_dev_exit(int idx)\n{\n\tsrcu_read_unlock(&drm_unplug_srcu, idx);\n}\nEXPORT_SYMBOL(drm_dev_exit);\n\n \nvoid drm_dev_unplug(struct drm_device *dev)\n{\n\t \n\tdev->unplugged = true;\n\tsynchronize_srcu(&drm_unplug_srcu);\n\n\tdrm_dev_unregister(dev);\n\n\t \n\tunmap_mapping_range(dev->anon_inode->i_mapping, 0, 0, 1);\n}\nEXPORT_SYMBOL(drm_dev_unplug);\n\n \n\nstatic int drm_fs_cnt;\nstatic struct vfsmount *drm_fs_mnt;\n\nstatic int drm_fs_init_fs_context(struct fs_context *fc)\n{\n\treturn init_pseudo(fc, 0x010203ff) ? 0 : -ENOMEM;\n}\n\nstatic struct file_system_type drm_fs_type = {\n\t.name\t\t= \"drm\",\n\t.owner\t\t= THIS_MODULE,\n\t.init_fs_context = drm_fs_init_fs_context,\n\t.kill_sb\t= kill_anon_super,\n};\n\nstatic struct inode *drm_fs_inode_new(void)\n{\n\tstruct inode *inode;\n\tint r;\n\n\tr = simple_pin_fs(&drm_fs_type, &drm_fs_mnt, &drm_fs_cnt);\n\tif (r < 0) {\n\t\tDRM_ERROR(\"Cannot mount pseudo fs: %d\\n\", r);\n\t\treturn ERR_PTR(r);\n\t}\n\n\tinode = alloc_anon_inode(drm_fs_mnt->mnt_sb);\n\tif (IS_ERR(inode))\n\t\tsimple_release_fs(&drm_fs_mnt, &drm_fs_cnt);\n\n\treturn inode;\n}\n\nstatic void drm_fs_inode_free(struct inode *inode)\n{\n\tif (inode) {\n\t\tiput(inode);\n\t\tsimple_release_fs(&drm_fs_mnt, &drm_fs_cnt);\n\t}\n}\n\n \n\nstatic void drm_dev_init_release(struct drm_device *dev, void *res)\n{\n\tdrm_legacy_ctxbitmap_cleanup(dev);\n\tdrm_legacy_remove_map_hash(dev);\n\tdrm_fs_inode_free(dev->anon_inode);\n\n\tput_device(dev->dev);\n\t \n\tdev->dev = NULL;\n\tmutex_destroy(&dev->master_mutex);\n\tmutex_destroy(&dev->clientlist_mutex);\n\tmutex_destroy(&dev->filelist_mutex);\n\tmutex_destroy(&dev->struct_mutex);\n\tmutex_destroy(&dev->debugfs_mutex);\n\tdrm_legacy_destroy_members(dev);\n}\n\nstatic int drm_dev_init(struct drm_device *dev,\n\t\t\tconst struct drm_driver *driver,\n\t\t\tstruct device *parent)\n{\n\tstruct inode *inode;\n\tint ret;\n\n\tif (!drm_core_init_complete) {\n\t\tDRM_ERROR(\"DRM core is not initialized\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tif (WARN_ON(!parent))\n\t\treturn -EINVAL;\n\n\tkref_init(&dev->ref);\n\tdev->dev = get_device(parent);\n\tdev->driver = driver;\n\n\tINIT_LIST_HEAD(&dev->managed.resources);\n\tspin_lock_init(&dev->managed.lock);\n\n\t \n\tdev->driver_features = ~0u;\n\n\tif (drm_core_check_feature(dev, DRIVER_COMPUTE_ACCEL) &&\n\t\t\t\t(drm_core_check_feature(dev, DRIVER_RENDER) ||\n\t\t\t\tdrm_core_check_feature(dev, DRIVER_MODESET))) {\n\t\tDRM_ERROR(\"DRM driver can't be both a compute acceleration and graphics driver\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tdrm_legacy_init_members(dev);\n\tINIT_LIST_HEAD(&dev->filelist);\n\tINIT_LIST_HEAD(&dev->filelist_internal);\n\tINIT_LIST_HEAD(&dev->clientlist);\n\tINIT_LIST_HEAD(&dev->vblank_event_list);\n\tINIT_LIST_HEAD(&dev->debugfs_list);\n\n\tspin_lock_init(&dev->event_lock);\n\tmutex_init(&dev->struct_mutex);\n\tmutex_init(&dev->filelist_mutex);\n\tmutex_init(&dev->clientlist_mutex);\n\tmutex_init(&dev->master_mutex);\n\tmutex_init(&dev->debugfs_mutex);\n\n\tret = drmm_add_action_or_reset(dev, drm_dev_init_release, NULL);\n\tif (ret)\n\t\treturn ret;\n\n\tinode = drm_fs_inode_new();\n\tif (IS_ERR(inode)) {\n\t\tret = PTR_ERR(inode);\n\t\tDRM_ERROR(\"Cannot allocate anonymous inode: %d\\n\", ret);\n\t\tgoto err;\n\t}\n\n\tdev->anon_inode = inode;\n\n\tif (drm_core_check_feature(dev, DRIVER_COMPUTE_ACCEL)) {\n\t\tret = drm_minor_alloc(dev, DRM_MINOR_ACCEL);\n\t\tif (ret)\n\t\t\tgoto err;\n\t} else {\n\t\tif (drm_core_check_feature(dev, DRIVER_RENDER)) {\n\t\t\tret = drm_minor_alloc(dev, DRM_MINOR_RENDER);\n\t\t\tif (ret)\n\t\t\t\tgoto err;\n\t\t}\n\n\t\tret = drm_minor_alloc(dev, DRM_MINOR_PRIMARY);\n\t\tif (ret)\n\t\t\tgoto err;\n\t}\n\n\tret = drm_legacy_create_map_hash(dev);\n\tif (ret)\n\t\tgoto err;\n\n\tdrm_legacy_ctxbitmap_init(dev);\n\n\tif (drm_core_check_feature(dev, DRIVER_GEM)) {\n\t\tret = drm_gem_init(dev);\n\t\tif (ret) {\n\t\t\tDRM_ERROR(\"Cannot initialize graphics execution manager (GEM)\\n\");\n\t\t\tgoto err;\n\t\t}\n\t}\n\n\tdev->unique = drmm_kstrdup(dev, dev_name(parent), GFP_KERNEL);\n\tif (!dev->unique) {\n\t\tret = -ENOMEM;\n\t\tgoto err;\n\t}\n\n\treturn 0;\n\nerr:\n\tdrm_managed_release(dev);\n\n\treturn ret;\n}\n\nstatic void devm_drm_dev_init_release(void *data)\n{\n\tdrm_dev_put(data);\n}\n\nstatic int devm_drm_dev_init(struct device *parent,\n\t\t\t     struct drm_device *dev,\n\t\t\t     const struct drm_driver *driver)\n{\n\tint ret;\n\n\tret = drm_dev_init(dev, driver, parent);\n\tif (ret)\n\t\treturn ret;\n\n\treturn devm_add_action_or_reset(parent,\n\t\t\t\t\tdevm_drm_dev_init_release, dev);\n}\n\nvoid *__devm_drm_dev_alloc(struct device *parent,\n\t\t\t   const struct drm_driver *driver,\n\t\t\t   size_t size, size_t offset)\n{\n\tvoid *container;\n\tstruct drm_device *drm;\n\tint ret;\n\n\tcontainer = kzalloc(size, GFP_KERNEL);\n\tif (!container)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tdrm = container + offset;\n\tret = devm_drm_dev_init(parent, drm, driver);\n\tif (ret) {\n\t\tkfree(container);\n\t\treturn ERR_PTR(ret);\n\t}\n\tdrmm_add_final_kfree(drm, container);\n\n\treturn container;\n}\nEXPORT_SYMBOL(__devm_drm_dev_alloc);\n\n \nstruct drm_device *drm_dev_alloc(const struct drm_driver *driver,\n\t\t\t\t struct device *parent)\n{\n\tstruct drm_device *dev;\n\tint ret;\n\n\tdev = kzalloc(sizeof(*dev), GFP_KERNEL);\n\tif (!dev)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tret = drm_dev_init(dev, driver, parent);\n\tif (ret) {\n\t\tkfree(dev);\n\t\treturn ERR_PTR(ret);\n\t}\n\n\tdrmm_add_final_kfree(dev, dev);\n\n\treturn dev;\n}\nEXPORT_SYMBOL(drm_dev_alloc);\n\nstatic void drm_dev_release(struct kref *ref)\n{\n\tstruct drm_device *dev = container_of(ref, struct drm_device, ref);\n\n\tif (dev->driver->release)\n\t\tdev->driver->release(dev);\n\n\tdrm_managed_release(dev);\n\n\tkfree(dev->managed.final_kfree);\n}\n\n \nvoid drm_dev_get(struct drm_device *dev)\n{\n\tif (dev)\n\t\tkref_get(&dev->ref);\n}\nEXPORT_SYMBOL(drm_dev_get);\n\n \nvoid drm_dev_put(struct drm_device *dev)\n{\n\tif (dev)\n\t\tkref_put(&dev->ref, drm_dev_release);\n}\nEXPORT_SYMBOL(drm_dev_put);\n\nstatic int create_compat_control_link(struct drm_device *dev)\n{\n\tstruct drm_minor *minor;\n\tchar *name;\n\tint ret;\n\n\tif (!drm_core_check_feature(dev, DRIVER_MODESET))\n\t\treturn 0;\n\n\tminor = *drm_minor_get_slot(dev, DRM_MINOR_PRIMARY);\n\tif (!minor)\n\t\treturn 0;\n\n\t \n\tname = kasprintf(GFP_KERNEL, \"controlD%d\", minor->index + 64);\n\tif (!name)\n\t\treturn -ENOMEM;\n\n\tret = sysfs_create_link(minor->kdev->kobj.parent,\n\t\t\t\t&minor->kdev->kobj,\n\t\t\t\tname);\n\n\tkfree(name);\n\n\treturn ret;\n}\n\nstatic void remove_compat_control_link(struct drm_device *dev)\n{\n\tstruct drm_minor *minor;\n\tchar *name;\n\n\tif (!drm_core_check_feature(dev, DRIVER_MODESET))\n\t\treturn;\n\n\tminor = *drm_minor_get_slot(dev, DRM_MINOR_PRIMARY);\n\tif (!minor)\n\t\treturn;\n\n\tname = kasprintf(GFP_KERNEL, \"controlD%d\", minor->index + 64);\n\tif (!name)\n\t\treturn;\n\n\tsysfs_remove_link(minor->kdev->kobj.parent, name);\n\n\tkfree(name);\n}\n\n \nint drm_dev_register(struct drm_device *dev, unsigned long flags)\n{\n\tconst struct drm_driver *driver = dev->driver;\n\tint ret;\n\n\tif (!driver->load)\n\t\tdrm_mode_config_validate(dev);\n\n\tWARN_ON(!dev->managed.final_kfree);\n\n\tif (drm_dev_needs_global_mutex(dev))\n\t\tmutex_lock(&drm_global_mutex);\n\n\tret = drm_minor_register(dev, DRM_MINOR_RENDER);\n\tif (ret)\n\t\tgoto err_minors;\n\n\tret = drm_minor_register(dev, DRM_MINOR_PRIMARY);\n\tif (ret)\n\t\tgoto err_minors;\n\n\tret = drm_minor_register(dev, DRM_MINOR_ACCEL);\n\tif (ret)\n\t\tgoto err_minors;\n\n\tret = create_compat_control_link(dev);\n\tif (ret)\n\t\tgoto err_minors;\n\n\tdev->registered = true;\n\n\tif (driver->load) {\n\t\tret = driver->load(dev, flags);\n\t\tif (ret)\n\t\t\tgoto err_minors;\n\t}\n\n\tif (drm_core_check_feature(dev, DRIVER_MODESET)) {\n\t\tret = drm_modeset_register_all(dev);\n\t\tif (ret)\n\t\t\tgoto err_unload;\n\t}\n\n\tDRM_INFO(\"Initialized %s %d.%d.%d %s for %s on minor %d\\n\",\n\t\t driver->name, driver->major, driver->minor,\n\t\t driver->patchlevel, driver->date,\n\t\t dev->dev ? dev_name(dev->dev) : \"virtual device\",\n\t\t dev->primary ? dev->primary->index : dev->accel->index);\n\n\tgoto out_unlock;\n\nerr_unload:\n\tif (dev->driver->unload)\n\t\tdev->driver->unload(dev);\nerr_minors:\n\tremove_compat_control_link(dev);\n\tdrm_minor_unregister(dev, DRM_MINOR_ACCEL);\n\tdrm_minor_unregister(dev, DRM_MINOR_PRIMARY);\n\tdrm_minor_unregister(dev, DRM_MINOR_RENDER);\nout_unlock:\n\tif (drm_dev_needs_global_mutex(dev))\n\t\tmutex_unlock(&drm_global_mutex);\n\treturn ret;\n}\nEXPORT_SYMBOL(drm_dev_register);\n\n \nvoid drm_dev_unregister(struct drm_device *dev)\n{\n\tif (drm_core_check_feature(dev, DRIVER_LEGACY))\n\t\tdrm_lastclose(dev);\n\n\tdev->registered = false;\n\n\tdrm_client_dev_unregister(dev);\n\n\tif (drm_core_check_feature(dev, DRIVER_MODESET))\n\t\tdrm_modeset_unregister_all(dev);\n\n\tif (dev->driver->unload)\n\t\tdev->driver->unload(dev);\n\n\tdrm_legacy_pci_agp_destroy(dev);\n\tdrm_legacy_rmmaps(dev);\n\n\tremove_compat_control_link(dev);\n\tdrm_minor_unregister(dev, DRM_MINOR_ACCEL);\n\tdrm_minor_unregister(dev, DRM_MINOR_PRIMARY);\n\tdrm_minor_unregister(dev, DRM_MINOR_RENDER);\n}\nEXPORT_SYMBOL(drm_dev_unregister);\n\n \n\nstatic int drm_stub_open(struct inode *inode, struct file *filp)\n{\n\tconst struct file_operations *new_fops;\n\tstruct drm_minor *minor;\n\tint err;\n\n\tDRM_DEBUG(\"\\n\");\n\n\tminor = drm_minor_acquire(iminor(inode));\n\tif (IS_ERR(minor))\n\t\treturn PTR_ERR(minor);\n\n\tnew_fops = fops_get(minor->dev->driver->fops);\n\tif (!new_fops) {\n\t\terr = -ENODEV;\n\t\tgoto out;\n\t}\n\n\treplace_fops(filp, new_fops);\n\tif (filp->f_op->open)\n\t\terr = filp->f_op->open(inode, filp);\n\telse\n\t\terr = 0;\n\nout:\n\tdrm_minor_release(minor);\n\n\treturn err;\n}\n\nstatic const struct file_operations drm_stub_fops = {\n\t.owner = THIS_MODULE,\n\t.open = drm_stub_open,\n\t.llseek = noop_llseek,\n};\n\nstatic void drm_core_exit(void)\n{\n\tdrm_privacy_screen_lookup_exit();\n\taccel_core_exit();\n\tunregister_chrdev(DRM_MAJOR, \"drm\");\n\tdebugfs_remove(drm_debugfs_root);\n\tdrm_sysfs_destroy();\n\tidr_destroy(&drm_minors_idr);\n\tdrm_connector_ida_destroy();\n}\n\nstatic int __init drm_core_init(void)\n{\n\tint ret;\n\n\tdrm_connector_ida_init();\n\tidr_init(&drm_minors_idr);\n\tdrm_memcpy_init_early();\n\n\tret = drm_sysfs_init();\n\tif (ret < 0) {\n\t\tDRM_ERROR(\"Cannot create DRM class: %d\\n\", ret);\n\t\tgoto error;\n\t}\n\n\tdrm_debugfs_root = debugfs_create_dir(\"dri\", NULL);\n\n\tret = register_chrdev(DRM_MAJOR, \"drm\", &drm_stub_fops);\n\tif (ret < 0)\n\t\tgoto error;\n\n\tret = accel_core_init();\n\tif (ret < 0)\n\t\tgoto error;\n\n\tdrm_privacy_screen_lookup_init();\n\n\tdrm_core_init_complete = true;\n\n\tDRM_DEBUG(\"Initialized\\n\");\n\treturn 0;\n\nerror:\n\tdrm_core_exit();\n\treturn ret;\n}\n\nmodule_init(drm_core_init);\nmodule_exit(drm_core_exit);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}