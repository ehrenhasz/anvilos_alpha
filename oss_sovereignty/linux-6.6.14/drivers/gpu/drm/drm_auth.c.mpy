{
  "module_name": "drm_auth.c",
  "hash_id": "9dd90740397ff095f9b707927991c96e6c08b8eae5e2d82a7ea925696c1dc3b4",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/drm_auth.c",
  "human_readable_source": " \n\n#include <linux/slab.h>\n\n#include <drm/drm_auth.h>\n#include <drm/drm_drv.h>\n#include <drm/drm_file.h>\n#include <drm/drm_lease.h>\n#include <drm/drm_print.h>\n\n#include \"drm_internal.h\"\n#include \"drm_legacy.h\"\n\n \n\nstatic bool drm_is_current_master_locked(struct drm_file *fpriv)\n{\n\tlockdep_assert_once(lockdep_is_held(&fpriv->master_lookup_lock) ||\n\t\t\t    lockdep_is_held(&fpriv->minor->dev->master_mutex));\n\n\treturn fpriv->is_master && drm_lease_owner(fpriv->master) == fpriv->minor->dev->master;\n}\n\n \nbool drm_is_current_master(struct drm_file *fpriv)\n{\n\tbool ret;\n\n\tspin_lock(&fpriv->master_lookup_lock);\n\tret = drm_is_current_master_locked(fpriv);\n\tspin_unlock(&fpriv->master_lookup_lock);\n\n\treturn ret;\n}\nEXPORT_SYMBOL(drm_is_current_master);\n\nint drm_getmagic(struct drm_device *dev, void *data, struct drm_file *file_priv)\n{\n\tstruct drm_auth *auth = data;\n\tint ret = 0;\n\n\tmutex_lock(&dev->master_mutex);\n\tif (!file_priv->magic) {\n\t\tret = idr_alloc(&file_priv->master->magic_map, file_priv,\n\t\t\t\t1, 0, GFP_KERNEL);\n\t\tif (ret >= 0)\n\t\t\tfile_priv->magic = ret;\n\t}\n\tauth->magic = file_priv->magic;\n\tmutex_unlock(&dev->master_mutex);\n\n\tdrm_dbg_core(dev, \"%u\\n\", auth->magic);\n\n\treturn ret < 0 ? ret : 0;\n}\n\nint drm_authmagic(struct drm_device *dev, void *data,\n\t\t  struct drm_file *file_priv)\n{\n\tstruct drm_auth *auth = data;\n\tstruct drm_file *file;\n\n\tdrm_dbg_core(dev, \"%u\\n\", auth->magic);\n\n\tmutex_lock(&dev->master_mutex);\n\tfile = idr_find(&file_priv->master->magic_map, auth->magic);\n\tif (file) {\n\t\tfile->authenticated = 1;\n\t\tidr_replace(&file_priv->master->magic_map, NULL, auth->magic);\n\t}\n\tmutex_unlock(&dev->master_mutex);\n\n\treturn file ? 0 : -EINVAL;\n}\n\nstruct drm_master *drm_master_create(struct drm_device *dev)\n{\n\tstruct drm_master *master;\n\n\tmaster = kzalloc(sizeof(*master), GFP_KERNEL);\n\tif (!master)\n\t\treturn NULL;\n\n\tkref_init(&master->refcount);\n\tdrm_master_legacy_init(master);\n\tidr_init_base(&master->magic_map, 1);\n\tmaster->dev = dev;\n\n\t \n\tINIT_LIST_HEAD(&master->lessees);\n\tINIT_LIST_HEAD(&master->lessee_list);\n\tidr_init(&master->leases);\n\tidr_init_base(&master->lessee_idr, 1);\n\n\treturn master;\n}\n\nstatic void drm_set_master(struct drm_device *dev, struct drm_file *fpriv,\n\t\t\t   bool new_master)\n{\n\tdev->master = drm_master_get(fpriv->master);\n\tif (dev->driver->master_set)\n\t\tdev->driver->master_set(dev, fpriv, new_master);\n\n\tfpriv->was_master = true;\n}\n\nstatic int drm_new_set_master(struct drm_device *dev, struct drm_file *fpriv)\n{\n\tstruct drm_master *old_master;\n\tstruct drm_master *new_master;\n\n\tlockdep_assert_held_once(&dev->master_mutex);\n\n\tWARN_ON(fpriv->is_master);\n\told_master = fpriv->master;\n\tnew_master = drm_master_create(dev);\n\tif (!new_master)\n\t\treturn -ENOMEM;\n\tspin_lock(&fpriv->master_lookup_lock);\n\tfpriv->master = new_master;\n\tspin_unlock(&fpriv->master_lookup_lock);\n\n\tfpriv->is_master = 1;\n\tfpriv->authenticated = 1;\n\n\tdrm_set_master(dev, fpriv, true);\n\n\tif (old_master)\n\t\tdrm_master_put(&old_master);\n\n\treturn 0;\n}\n\n \nstatic int\ndrm_master_check_perm(struct drm_device *dev, struct drm_file *file_priv)\n{\n\tif (file_priv->was_master &&\n\t    rcu_access_pointer(file_priv->pid) == task_tgid(current))\n\t\treturn 0;\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EACCES;\n\n\treturn 0;\n}\n\nint drm_setmaster_ioctl(struct drm_device *dev, void *data,\n\t\t\tstruct drm_file *file_priv)\n{\n\tint ret;\n\n\tmutex_lock(&dev->master_mutex);\n\n\tret = drm_master_check_perm(dev, file_priv);\n\tif (ret)\n\t\tgoto out_unlock;\n\n\tif (drm_is_current_master_locked(file_priv))\n\t\tgoto out_unlock;\n\n\tif (dev->master) {\n\t\tret = -EBUSY;\n\t\tgoto out_unlock;\n\t}\n\n\tif (!file_priv->master) {\n\t\tret = -EINVAL;\n\t\tgoto out_unlock;\n\t}\n\n\tif (!file_priv->is_master) {\n\t\tret = drm_new_set_master(dev, file_priv);\n\t\tgoto out_unlock;\n\t}\n\n\tif (file_priv->master->lessor != NULL) {\n\t\tdrm_dbg_lease(dev,\n\t\t\t      \"Attempt to set lessee %d as master\\n\",\n\t\t\t      file_priv->master->lessee_id);\n\t\tret = -EINVAL;\n\t\tgoto out_unlock;\n\t}\n\n\tdrm_set_master(dev, file_priv, false);\nout_unlock:\n\tmutex_unlock(&dev->master_mutex);\n\treturn ret;\n}\n\nstatic void drm_drop_master(struct drm_device *dev,\n\t\t\t    struct drm_file *fpriv)\n{\n\tif (dev->driver->master_drop)\n\t\tdev->driver->master_drop(dev, fpriv);\n\tdrm_master_put(&dev->master);\n}\n\nint drm_dropmaster_ioctl(struct drm_device *dev, void *data,\n\t\t\t struct drm_file *file_priv)\n{\n\tint ret;\n\n\tmutex_lock(&dev->master_mutex);\n\n\tret = drm_master_check_perm(dev, file_priv);\n\tif (ret)\n\t\tgoto out_unlock;\n\n\tif (!drm_is_current_master_locked(file_priv)) {\n\t\tret = -EINVAL;\n\t\tgoto out_unlock;\n\t}\n\n\tif (!dev->master) {\n\t\tret = -EINVAL;\n\t\tgoto out_unlock;\n\t}\n\n\tif (file_priv->master->lessor != NULL) {\n\t\tdrm_dbg_lease(dev,\n\t\t\t      \"Attempt to drop lessee %d as master\\n\",\n\t\t\t      file_priv->master->lessee_id);\n\t\tret = -EINVAL;\n\t\tgoto out_unlock;\n\t}\n\n\tdrm_drop_master(dev, file_priv);\nout_unlock:\n\tmutex_unlock(&dev->master_mutex);\n\treturn ret;\n}\n\nint drm_master_open(struct drm_file *file_priv)\n{\n\tstruct drm_device *dev = file_priv->minor->dev;\n\tint ret = 0;\n\n\t \n\tmutex_lock(&dev->master_mutex);\n\tif (!dev->master) {\n\t\tret = drm_new_set_master(dev, file_priv);\n\t} else {\n\t\tspin_lock(&file_priv->master_lookup_lock);\n\t\tfile_priv->master = drm_master_get(dev->master);\n\t\tspin_unlock(&file_priv->master_lookup_lock);\n\t}\n\tmutex_unlock(&dev->master_mutex);\n\n\treturn ret;\n}\n\nvoid drm_master_release(struct drm_file *file_priv)\n{\n\tstruct drm_device *dev = file_priv->minor->dev;\n\tstruct drm_master *master;\n\n\tmutex_lock(&dev->master_mutex);\n\tmaster = file_priv->master;\n\tif (file_priv->magic)\n\t\tidr_remove(&file_priv->master->magic_map, file_priv->magic);\n\n\tif (!drm_is_current_master_locked(file_priv))\n\t\tgoto out;\n\n\tdrm_legacy_lock_master_cleanup(dev, master);\n\n\tif (dev->master == file_priv->master)\n\t\tdrm_drop_master(dev, file_priv);\nout:\n\tif (drm_core_check_feature(dev, DRIVER_MODESET) && file_priv->is_master) {\n\t\t \n\t\tdrm_lease_revoke(master);\n\t}\n\n\t \n\tif (file_priv->master)\n\t\tdrm_master_put(&file_priv->master);\n\tmutex_unlock(&dev->master_mutex);\n}\n\n \nstruct drm_master *drm_master_get(struct drm_master *master)\n{\n\tkref_get(&master->refcount);\n\treturn master;\n}\nEXPORT_SYMBOL(drm_master_get);\n\n \nstruct drm_master *drm_file_get_master(struct drm_file *file_priv)\n{\n\tstruct drm_master *master = NULL;\n\n\tspin_lock(&file_priv->master_lookup_lock);\n\tif (!file_priv->master)\n\t\tgoto unlock;\n\tmaster = drm_master_get(file_priv->master);\n\nunlock:\n\tspin_unlock(&file_priv->master_lookup_lock);\n\treturn master;\n}\nEXPORT_SYMBOL(drm_file_get_master);\n\nstatic void drm_master_destroy(struct kref *kref)\n{\n\tstruct drm_master *master = container_of(kref, struct drm_master, refcount);\n\tstruct drm_device *dev = master->dev;\n\n\tif (drm_core_check_feature(dev, DRIVER_MODESET))\n\t\tdrm_lease_destroy(master);\n\n\tdrm_legacy_master_rmmaps(dev, master);\n\n\tidr_destroy(&master->magic_map);\n\tidr_destroy(&master->leases);\n\tidr_destroy(&master->lessee_idr);\n\n\tkfree(master->unique);\n\tkfree(master);\n}\n\n \nvoid drm_master_put(struct drm_master **master)\n{\n\tkref_put(&(*master)->refcount, drm_master_destroy);\n\t*master = NULL;\n}\nEXPORT_SYMBOL(drm_master_put);\n\n \nbool drm_master_internal_acquire(struct drm_device *dev)\n{\n\tmutex_lock(&dev->master_mutex);\n\tif (dev->master) {\n\t\tmutex_unlock(&dev->master_mutex);\n\t\treturn false;\n\t}\n\n\treturn true;\n}\nEXPORT_SYMBOL(drm_master_internal_acquire);\n\n \nvoid drm_master_internal_release(struct drm_device *dev)\n{\n\tmutex_unlock(&dev->master_mutex);\n}\nEXPORT_SYMBOL(drm_master_internal_release);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}