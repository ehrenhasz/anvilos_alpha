{
  "module_name": "mcde_dsi.c",
  "hash_id": "96ede2549e2cd8433093c59f742131f976242b80eb696d75f3ffe09c199e7102",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/mcde/mcde_dsi.c",
  "human_readable_source": "\n#include <linux/clk.h>\n#include <linux/component.h>\n#include <linux/delay.h>\n#include <linux/io.h>\n#include <linux/mfd/syscon.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/regmap.h>\n#include <linux/regulator/consumer.h>\n#include <video/mipi_display.h>\n\n#include <drm/drm_atomic_helper.h>\n#include <drm/drm_bridge.h>\n#include <drm/drm_device.h>\n#include <drm/drm_drv.h>\n#include <drm/drm_encoder.h>\n#include <drm/drm_mipi_dsi.h>\n#include <drm/drm_modeset_helper_vtables.h>\n#include <drm/drm_of.h>\n#include <drm/drm_panel.h>\n#include <drm/drm_print.h>\n#include <drm/drm_probe_helper.h>\n\n#include \"mcde_drm.h\"\n#include \"mcde_dsi_regs.h\"\n\n#define DSI_DEFAULT_LP_FREQ_HZ\t19200000\n#define DSI_DEFAULT_HS_FREQ_HZ\t420160000\n\n \n#define PRCM_DSI_SW_RESET 0x324\n#define PRCM_DSI_SW_RESET_DSI0_SW_RESETN BIT(0)\n#define PRCM_DSI_SW_RESET_DSI1_SW_RESETN BIT(1)\n#define PRCM_DSI_SW_RESET_DSI2_SW_RESETN BIT(2)\n\nstruct mcde_dsi {\n\tstruct device *dev;\n\tstruct mcde *mcde;\n\tstruct drm_bridge bridge;\n\tstruct drm_panel *panel;\n\tstruct drm_bridge *bridge_out;\n\tstruct mipi_dsi_host dsi_host;\n\tstruct mipi_dsi_device *mdsi;\n\tconst struct drm_display_mode *mode;\n\tstruct clk *hs_clk;\n\tstruct clk *lp_clk;\n\tunsigned long hs_freq;\n\tunsigned long lp_freq;\n\tbool unused;\n\n\tvoid __iomem *regs;\n\tstruct regmap *prcmu;\n};\n\nstatic inline struct mcde_dsi *bridge_to_mcde_dsi(struct drm_bridge *bridge)\n{\n\treturn container_of(bridge, struct mcde_dsi, bridge);\n}\n\nstatic inline struct mcde_dsi *host_to_mcde_dsi(struct mipi_dsi_host *h)\n{\n\treturn container_of(h, struct mcde_dsi, dsi_host);\n}\n\nbool mcde_dsi_irq(struct mipi_dsi_device *mdsi)\n{\n\tstruct mcde_dsi *d;\n\tu32 val;\n\tbool te_received = false;\n\n\td = host_to_mcde_dsi(mdsi->host);\n\n\tdev_dbg(d->dev, \"%s called\\n\", __func__);\n\n\tval = readl(d->regs + DSI_DIRECT_CMD_STS_FLAG);\n\tif (val)\n\t\tdev_dbg(d->dev, \"DSI_DIRECT_CMD_STS_FLAG = %08x\\n\", val);\n\tif (val & DSI_DIRECT_CMD_STS_WRITE_COMPLETED)\n\t\tdev_dbg(d->dev, \"direct command write completed\\n\");\n\tif (val & DSI_DIRECT_CMD_STS_TE_RECEIVED) {\n\t\tte_received = true;\n\t\tdev_dbg(d->dev, \"direct command TE received\\n\");\n\t}\n\tif (val & DSI_DIRECT_CMD_STS_ACKNOWLEDGE_WITH_ERR_RECEIVED)\n\t\tdev_err(d->dev, \"direct command ACK ERR received\\n\");\n\tif (val & DSI_DIRECT_CMD_STS_READ_COMPLETED_WITH_ERR)\n\t\tdev_err(d->dev, \"direct command read ERR received\\n\");\n\t \n\twritel(val, d->regs + DSI_DIRECT_CMD_STS_CLR);\n\n\tval = readl(d->regs + DSI_CMD_MODE_STS_FLAG);\n\tif (val)\n\t\tdev_dbg(d->dev, \"DSI_CMD_MODE_STS_FLAG = %08x\\n\", val);\n\tif (val & DSI_CMD_MODE_STS_ERR_NO_TE)\n\t\t \n\t\tdev_dbg(d->dev, \"CMD mode no TE\\n\");\n\tif (val & DSI_CMD_MODE_STS_ERR_TE_MISS)\n\t\t \n\t\tdev_dbg(d->dev, \"CMD mode TE miss\\n\");\n\tif (val & DSI_CMD_MODE_STS_ERR_SDI1_UNDERRUN)\n\t\tdev_err(d->dev, \"CMD mode SD1 underrun\\n\");\n\tif (val & DSI_CMD_MODE_STS_ERR_SDI2_UNDERRUN)\n\t\tdev_err(d->dev, \"CMD mode SD2 underrun\\n\");\n\tif (val & DSI_CMD_MODE_STS_ERR_UNWANTED_RD)\n\t\tdev_err(d->dev, \"CMD mode unwanted RD\\n\");\n\twritel(val, d->regs + DSI_CMD_MODE_STS_CLR);\n\n\tval = readl(d->regs + DSI_DIRECT_CMD_RD_STS_FLAG);\n\tif (val)\n\t\tdev_dbg(d->dev, \"DSI_DIRECT_CMD_RD_STS_FLAG = %08x\\n\", val);\n\twritel(val, d->regs + DSI_DIRECT_CMD_RD_STS_CLR);\n\n\tval = readl(d->regs + DSI_TG_STS_FLAG);\n\tif (val)\n\t\tdev_dbg(d->dev, \"DSI_TG_STS_FLAG = %08x\\n\", val);\n\twritel(val, d->regs + DSI_TG_STS_CLR);\n\n\tval = readl(d->regs + DSI_VID_MODE_STS_FLAG);\n\tif (val)\n\t\tdev_dbg(d->dev, \"DSI_VID_MODE_STS_FLAG = %08x\\n\", val);\n\tif (val & DSI_VID_MODE_STS_VSG_RUNNING)\n\t\tdev_dbg(d->dev, \"VID mode VSG running\\n\");\n\tif (val & DSI_VID_MODE_STS_ERR_MISSING_DATA)\n\t\tdev_err(d->dev, \"VID mode missing data\\n\");\n\tif (val & DSI_VID_MODE_STS_ERR_MISSING_HSYNC)\n\t\tdev_err(d->dev, \"VID mode missing HSYNC\\n\");\n\tif (val & DSI_VID_MODE_STS_ERR_MISSING_VSYNC)\n\t\tdev_err(d->dev, \"VID mode missing VSYNC\\n\");\n\tif (val & DSI_VID_MODE_STS_REG_ERR_SMALL_LENGTH)\n\t\tdev_err(d->dev, \"VID mode less bytes than expected between two HSYNC\\n\");\n\tif (val & DSI_VID_MODE_STS_REG_ERR_SMALL_HEIGHT)\n\t\tdev_err(d->dev, \"VID mode less lines than expected between two VSYNC\\n\");\n\tif (val & (DSI_VID_MODE_STS_ERR_BURSTWRITE |\n\t\t   DSI_VID_MODE_STS_ERR_LINEWRITE |\n\t\t   DSI_VID_MODE_STS_ERR_LONGREAD))\n\t\tdev_err(d->dev, \"VID mode read/write error\\n\");\n\tif (val & DSI_VID_MODE_STS_ERR_VRS_WRONG_LENGTH)\n\t\tdev_err(d->dev, \"VID mode received packets differ from expected size\\n\");\n\tif (val & DSI_VID_MODE_STS_VSG_RECOVERY)\n\t\tdev_err(d->dev, \"VID mode VSG in recovery mode\\n\");\n\twritel(val, d->regs + DSI_VID_MODE_STS_CLR);\n\n\treturn te_received;\n}\n\nstatic void mcde_dsi_attach_to_mcde(struct mcde_dsi *d)\n{\n\td->mcde->mdsi = d->mdsi;\n\n\t \n\tif (d->mdsi->mode_flags & MIPI_DSI_MODE_VIDEO)\n\t\td->mcde->flow_mode = MCDE_VIDEO_FORMATTER_FLOW;\n\telse\n\t\td->mcde->flow_mode = MCDE_COMMAND_TE_FLOW;\n}\n\nstatic int mcde_dsi_host_attach(struct mipi_dsi_host *host,\n\t\t\t\tstruct mipi_dsi_device *mdsi)\n{\n\tstruct mcde_dsi *d = host_to_mcde_dsi(host);\n\n\tif (mdsi->lanes < 1 || mdsi->lanes > 2) {\n\t\tDRM_ERROR(\"dsi device params invalid, 1 or 2 lanes supported\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tdev_info(d->dev, \"attached DSI device with %d lanes\\n\", mdsi->lanes);\n\t \n\tdev_info(d->dev, \"format %08x, %dbpp\\n\", mdsi->format,\n\t\t mipi_dsi_pixel_format_to_bpp(mdsi->format));\n\tdev_info(d->dev, \"mode flags: %08lx\\n\", mdsi->mode_flags);\n\n\td->mdsi = mdsi;\n\tif (d->mcde)\n\t\tmcde_dsi_attach_to_mcde(d);\n\n\treturn 0;\n}\n\nstatic int mcde_dsi_host_detach(struct mipi_dsi_host *host,\n\t\t\t\tstruct mipi_dsi_device *mdsi)\n{\n\tstruct mcde_dsi *d = host_to_mcde_dsi(host);\n\n\td->mdsi = NULL;\n\tif (d->mcde)\n\t\td->mcde->mdsi = NULL;\n\n\treturn 0;\n}\n\n#define MCDE_DSI_HOST_IS_READ(type)\t\t\t    \\\n\t((type == MIPI_DSI_GENERIC_READ_REQUEST_0_PARAM) || \\\n\t (type == MIPI_DSI_GENERIC_READ_REQUEST_1_PARAM) || \\\n\t (type == MIPI_DSI_GENERIC_READ_REQUEST_2_PARAM) || \\\n\t (type == MIPI_DSI_DCS_READ))\n\nstatic int mcde_dsi_execute_transfer(struct mcde_dsi *d,\n\t\t\t\t     const struct mipi_dsi_msg *msg)\n{\n\tconst u32 loop_delay_us = 10;  \n\tu32 loop_counter;\n\tsize_t txlen = msg->tx_len;\n\tsize_t rxlen = msg->rx_len;\n\tint i;\n\tu32 val;\n\tint ret;\n\n\twritel(~0, d->regs + DSI_DIRECT_CMD_STS_CLR);\n\twritel(~0, d->regs + DSI_CMD_MODE_STS_CLR);\n\t \n\twritel(1, d->regs + DSI_DIRECT_CMD_SEND);\n\n\tloop_counter = 1000 * 1000 / loop_delay_us;\n\tif (MCDE_DSI_HOST_IS_READ(msg->type)) {\n\t\t \n\t\twhile (!(readl(d->regs + DSI_DIRECT_CMD_STS) &\n\t\t\t (DSI_DIRECT_CMD_STS_READ_COMPLETED |\n\t\t\t  DSI_DIRECT_CMD_STS_READ_COMPLETED_WITH_ERR))\n\t\t       && --loop_counter)\n\t\t\tusleep_range(loop_delay_us, (loop_delay_us * 3) / 2);\n\t\tif (!loop_counter) {\n\t\t\tdev_err(d->dev, \"DSI read timeout!\\n\");\n\t\t\t \n\t\t\treturn -ETIME;\n\t\t}\n\t} else {\n\t\t \n\t\twhile (!(readl(d->regs + DSI_DIRECT_CMD_STS) &\n\t\t\t DSI_DIRECT_CMD_STS_WRITE_COMPLETED)\n\t\t       && --loop_counter)\n\t\t\tusleep_range(loop_delay_us, (loop_delay_us * 3) / 2);\n\n\t\tif (!loop_counter) {\n\t\t\t \n\t\t\tdev_err(d->dev, \"DSI write timeout!\\n\");\n\t\t\treturn -ETIME;\n\t\t}\n\t}\n\n\tval = readl(d->regs + DSI_DIRECT_CMD_STS);\n\tif (val & DSI_DIRECT_CMD_STS_READ_COMPLETED_WITH_ERR) {\n\t\tdev_err(d->dev, \"read completed with error\\n\");\n\t\twritel(1, d->regs + DSI_DIRECT_CMD_RD_INIT);\n\t\treturn -EIO;\n\t}\n\tif (val & DSI_DIRECT_CMD_STS_ACKNOWLEDGE_WITH_ERR_RECEIVED) {\n\t\tval >>= DSI_DIRECT_CMD_STS_ACK_VAL_SHIFT;\n\t\tdev_err(d->dev, \"error during transmission: %04x\\n\",\n\t\t\tval);\n\t\treturn -EIO;\n\t}\n\n\tif (!MCDE_DSI_HOST_IS_READ(msg->type)) {\n\t\t \n\t\tret = txlen;\n\t} else {\n\t\t \n\t\tu32 rdsz;\n\t\tu32 rddat;\n\t\tu8 *rx = msg->rx_buf;\n\n\t\trdsz = readl(d->regs + DSI_DIRECT_CMD_RD_PROPERTY);\n\t\trdsz &= DSI_DIRECT_CMD_RD_PROPERTY_RD_SIZE_MASK;\n\t\trddat = readl(d->regs + DSI_DIRECT_CMD_RDDAT);\n\t\tif (rdsz < rxlen) {\n\t\t\tdev_err(d->dev, \"read error, requested %zd got %d\\n\",\n\t\t\t\trxlen, rdsz);\n\t\t\treturn -EIO;\n\t\t}\n\t\t \n\t\tfor (i = 0; i < 4 && i < rxlen; i++)\n\t\t\trx[i] = (rddat >> (i * 8)) & 0xff;\n\t\tret = rdsz;\n\t}\n\n\t \n\treturn ret;\n}\n\nstatic ssize_t mcde_dsi_host_transfer(struct mipi_dsi_host *host,\n\t\t\t\t      const struct mipi_dsi_msg *msg)\n{\n\tstruct mcde_dsi *d = host_to_mcde_dsi(host);\n\tconst u8 *tx = msg->tx_buf;\n\tsize_t txlen = msg->tx_len;\n\tsize_t rxlen = msg->rx_len;\n\tunsigned int retries = 0;\n\tu32 val;\n\tint ret;\n\tint i;\n\n\tif (txlen > 16) {\n\t\tdev_err(d->dev,\n\t\t\t\"dunno how to write more than 16 bytes yet\\n\");\n\t\treturn -EIO;\n\t}\n\tif (rxlen > 4) {\n\t\tdev_err(d->dev,\n\t\t\t\"dunno how to read more than 4 bytes yet\\n\");\n\t\treturn -EIO;\n\t}\n\n\tdev_dbg(d->dev,\n\t\t\"message to channel %d, write %zd bytes read %zd bytes\\n\",\n\t\tmsg->channel, txlen, rxlen);\n\n\t \n\tif (MCDE_DSI_HOST_IS_READ(msg->type))\n\t\t \n\t\tval = DSI_DIRECT_CMD_MAIN_SETTINGS_CMD_NAT_READ;\n\telse\n\t\tval = DSI_DIRECT_CMD_MAIN_SETTINGS_CMD_NAT_WRITE;\n\t \n\tif (mipi_dsi_packet_format_is_long(msg->type))\n\t\tval |= DSI_DIRECT_CMD_MAIN_SETTINGS_CMD_LONGNOTSHORT;\n\tval |= 0 << DSI_DIRECT_CMD_MAIN_SETTINGS_CMD_ID_SHIFT;\n\tval |= txlen << DSI_DIRECT_CMD_MAIN_SETTINGS_CMD_SIZE_SHIFT;\n\tval |= DSI_DIRECT_CMD_MAIN_SETTINGS_CMD_LP_EN;\n\tval |= msg->type << DSI_DIRECT_CMD_MAIN_SETTINGS_CMD_HEAD_SHIFT;\n\twritel(val, d->regs + DSI_DIRECT_CMD_MAIN_SETTINGS);\n\n\t \n\tif (txlen > 0) {\n\t\tval = 0;\n\t\tfor (i = 0; i < 4 && i < txlen; i++)\n\t\t\tval |= tx[i] << (i * 8);\n\t}\n\twritel(val, d->regs + DSI_DIRECT_CMD_WRDAT0);\n\tif (txlen > 4) {\n\t\tval = 0;\n\t\tfor (i = 0; i < 4 && (i + 4) < txlen; i++)\n\t\t\tval |= tx[i + 4] << (i * 8);\n\t\twritel(val, d->regs + DSI_DIRECT_CMD_WRDAT1);\n\t}\n\tif (txlen > 8) {\n\t\tval = 0;\n\t\tfor (i = 0; i < 4 && (i + 8) < txlen; i++)\n\t\t\tval |= tx[i + 8] << (i * 8);\n\t\twritel(val, d->regs + DSI_DIRECT_CMD_WRDAT2);\n\t}\n\tif (txlen > 12) {\n\t\tval = 0;\n\t\tfor (i = 0; i < 4 && (i + 12) < txlen; i++)\n\t\t\tval |= tx[i + 12] << (i * 8);\n\t\twritel(val, d->regs + DSI_DIRECT_CMD_WRDAT3);\n\t}\n\n\twhile (retries < 3) {\n\t\tret = mcde_dsi_execute_transfer(d, msg);\n\t\tif (ret >= 0)\n\t\t\tbreak;\n\t\tretries++;\n\t}\n\tif (ret < 0 && retries)\n\t\tdev_err(d->dev, \"gave up after %d retries\\n\", retries);\n\n\t \n\twritel(~0, d->regs + DSI_DIRECT_CMD_STS_CLR);\n\twritel(~0, d->regs + DSI_CMD_MODE_STS_CLR);\n\n\treturn ret;\n}\n\nstatic const struct mipi_dsi_host_ops mcde_dsi_host_ops = {\n\t.attach = mcde_dsi_host_attach,\n\t.detach = mcde_dsi_host_detach,\n\t.transfer = mcde_dsi_host_transfer,\n};\n\n \nvoid mcde_dsi_te_request(struct mipi_dsi_device *mdsi)\n{\n\tstruct mcde_dsi *d;\n\tu32 val;\n\n\td = host_to_mcde_dsi(mdsi->host);\n\n\t \n\tval = DSI_DIRECT_CMD_MAIN_SETTINGS_CMD_NAT_TE_REQ;\n\tval |= 0 << DSI_DIRECT_CMD_MAIN_SETTINGS_CMD_ID_SHIFT;\n\tval |= 2 << DSI_DIRECT_CMD_MAIN_SETTINGS_CMD_SIZE_SHIFT;\n\tval |= DSI_DIRECT_CMD_MAIN_SETTINGS_CMD_LP_EN;\n\tval |= MIPI_DSI_GENERIC_SHORT_WRITE_1_PARAM <<\n\t\tDSI_DIRECT_CMD_MAIN_SETTINGS_CMD_HEAD_SHIFT;\n\twritel(val, d->regs + DSI_DIRECT_CMD_MAIN_SETTINGS);\n\n\t \n\twritel(DSI_DIRECT_CMD_STS_CLR_TE_RECEIVED_CLR |\n\t       DSI_DIRECT_CMD_STS_CLR_ACKNOWLEDGE_WITH_ERR_RECEIVED_CLR,\n\t       d->regs + DSI_DIRECT_CMD_STS_CLR);\n\tval = readl(d->regs + DSI_DIRECT_CMD_STS_CTL);\n\tval |= DSI_DIRECT_CMD_STS_CTL_TE_RECEIVED_EN;\n\tval |= DSI_DIRECT_CMD_STS_CTL_ACKNOWLEDGE_WITH_ERR_EN;\n\twritel(val, d->regs + DSI_DIRECT_CMD_STS_CTL);\n\n\t \n\twritel(DSI_CMD_MODE_STS_CLR_ERR_NO_TE_CLR |\n\t       DSI_CMD_MODE_STS_CLR_ERR_TE_MISS_CLR,\n\t       d->regs + DSI_CMD_MODE_STS_CLR);\n\tval = readl(d->regs + DSI_CMD_MODE_STS_CTL);\n\tval |= DSI_CMD_MODE_STS_CTL_ERR_NO_TE_EN;\n\tval |= DSI_CMD_MODE_STS_CTL_ERR_TE_MISS_EN;\n\twritel(val, d->regs + DSI_CMD_MODE_STS_CTL);\n\n\t \n\twritel(1, d->regs + DSI_DIRECT_CMD_SEND);\n}\n\nstatic void mcde_dsi_setup_video_mode(struct mcde_dsi *d,\n\t\t\t\t      const struct drm_display_mode *mode)\n{\n\t \n\tu8 cpp = mipi_dsi_pixel_format_to_bpp(d->mdsi->format) / 8;\n\tu64 pclk;\n\tu64 bpl;\n\tint hfp;\n\tint hbp;\n\tint hsa;\n\tu32 blkline_pck, line_duration;\n\tu32 val;\n\n\tval = 0;\n\tif (d->mdsi->mode_flags & MIPI_DSI_MODE_VIDEO_BURST)\n\t\tval |= DSI_VID_MAIN_CTL_BURST_MODE;\n\tif (d->mdsi->mode_flags & MIPI_DSI_MODE_VIDEO_SYNC_PULSE) {\n\t\tval |= DSI_VID_MAIN_CTL_SYNC_PULSE_ACTIVE;\n\t\tval |= DSI_VID_MAIN_CTL_SYNC_PULSE_HORIZONTAL;\n\t}\n\t \n\tswitch (d->mdsi->format) {\n\tcase MIPI_DSI_FMT_RGB565:\n\t\tval |= MIPI_DSI_PACKED_PIXEL_STREAM_16 <<\n\t\t\tDSI_VID_MAIN_CTL_HEADER_SHIFT;\n\t\tval |= DSI_VID_MAIN_CTL_VID_PIXEL_MODE_16BITS;\n\t\tbreak;\n\tcase MIPI_DSI_FMT_RGB666_PACKED:\n\t\tval |= MIPI_DSI_PACKED_PIXEL_STREAM_18 <<\n\t\t\tDSI_VID_MAIN_CTL_HEADER_SHIFT;\n\t\tval |= DSI_VID_MAIN_CTL_VID_PIXEL_MODE_18BITS;\n\t\tbreak;\n\tcase MIPI_DSI_FMT_RGB666:\n\t\tval |= MIPI_DSI_PIXEL_STREAM_3BYTE_18\n\t\t\t<< DSI_VID_MAIN_CTL_HEADER_SHIFT;\n\t\tval |= DSI_VID_MAIN_CTL_VID_PIXEL_MODE_18BITS_LOOSE;\n\t\tbreak;\n\tcase MIPI_DSI_FMT_RGB888:\n\t\tval |= MIPI_DSI_PACKED_PIXEL_STREAM_24 <<\n\t\t\tDSI_VID_MAIN_CTL_HEADER_SHIFT;\n\t\tval |= DSI_VID_MAIN_CTL_VID_PIXEL_MODE_24BITS;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(d->dev, \"unknown pixel mode\\n\");\n\t\treturn;\n\t}\n\n\t \n\n\t \n\tval |= DSI_VID_MAIN_CTL_REG_BLKLINE_MODE_LP_0;\n\t \n\tval |= DSI_VID_MAIN_CTL_REG_BLKEOL_MODE_LP_0;\n\t \n\tval |= 1 << DSI_VID_MAIN_CTL_RECOVERY_MODE_SHIFT;\n\t \n\twritel(val, d->regs + DSI_VID_MAIN_CTL);\n\n\t \n\tval = mode->vdisplay << DSI_VID_VSIZE_VACT_LENGTH_SHIFT;\n\t \n\tval |= (mode->vsync_start - mode->vdisplay)\n\t\t<< DSI_VID_VSIZE_VFP_LENGTH_SHIFT;\n\t \n\tval |= (mode->vsync_end - mode->vsync_start)\n\t\t<< DSI_VID_VSIZE_VSA_LENGTH_SHIFT;\n\t \n\tval |= (mode->vtotal - mode->vsync_end)\n\t\t<< DSI_VID_VSIZE_VBP_LENGTH_SHIFT;\n\twritel(val, d->regs + DSI_VID_VSIZE);\n\n\t \n\thfp = (mode->hsync_start - mode->hdisplay) * cpp - 6 - 2;\n\tif (d->mdsi->mode_flags & MIPI_DSI_MODE_VIDEO_SYNC_PULSE) {\n\t\t \n\t\thbp = (mode->htotal - mode->hsync_end) * cpp - 4 - 6;\n\t\t \n\t\thsa = (mode->hsync_end - mode->hsync_start) * cpp - 4 - 4 - 6;\n\t} else {\n\t\t \n\t\thbp = (mode->htotal - mode->hsync_start) * cpp - 4 - 4 - 6;\n\t\t \n\t\thsa = 0;\n\t}\n\tif (hfp < 0) {\n\t\tdev_info(d->dev, \"hfp negative, set to 0\\n\");\n\t\thfp = 0;\n\t}\n\tif (hbp < 0) {\n\t\tdev_info(d->dev, \"hbp negative, set to 0\\n\");\n\t\thbp = 0;\n\t}\n\tif (hsa < 0) {\n\t\tdev_info(d->dev, \"hsa negative, set to 0\\n\");\n\t\thsa = 0;\n\t}\n\tdev_dbg(d->dev, \"hfp: %u, hbp: %u, hsa: %u bytes\\n\",\n\t\thfp, hbp, hsa);\n\n\t \n\tval = hsa << DSI_VID_HSIZE1_HSA_LENGTH_SHIFT;\n\t \n\tval |= hbp << DSI_VID_HSIZE1_HBP_LENGTH_SHIFT;\n\t \n\tval |= hfp << DSI_VID_HSIZE1_HFP_LENGTH_SHIFT;\n\twritel(val, d->regs + DSI_VID_HSIZE1);\n\n\t \n\tval = mode->hdisplay * cpp;\n\twritel(val, d->regs + DSI_VID_HSIZE2);\n\tdev_dbg(d->dev, \"RGB length, visible area on a line: %u bytes\\n\", val);\n\n\t \n\t \n\tpclk = DIV_ROUND_UP_ULL(1000000000000, (mode->clock * 1000));\n\tdev_dbg(d->dev, \"picoseconds between two pixels: %llu\\n\",\n\t\tpclk);\n\n\t \n\tbpl = pclk * mode->htotal;  \n\tdev_dbg(d->dev, \"picoseconds per line: %llu\\n\", bpl);\n\t \n\tbpl *= (d->mdsi->hs_rate / 8);\n\t \n\tbpl = DIV_ROUND_DOWN_ULL(bpl, 1000000);  \n\tbpl = DIV_ROUND_DOWN_ULL(bpl, 1000000);  \n\t \n\tbpl *= d->mdsi->lanes;\n\tdev_dbg(d->dev,\n\t\t\"calculated bytes per line: %llu @ %d Hz with HS %lu Hz\\n\",\n\t\tbpl, drm_mode_vrefresh(mode), d->mdsi->hs_rate);\n\n\t \n\tif (d->mdsi->mode_flags & MIPI_DSI_MODE_VIDEO_SYNC_PULSE) {\n\t\t \n\t\twritel(0, d->regs + DSI_VID_BLKSIZE1);\n\t\t \n\t\tblkline_pck = bpl - (mode->hsync_end - mode->hsync_start) - 6;\n\t\tval = blkline_pck << DSI_VID_BLKSIZE2_BLKLINE_PULSE_PCK_SHIFT;\n\t\twritel(val, d->regs + DSI_VID_BLKSIZE2);\n\t} else {\n\t\t \n\t\twritel(0, d->regs + DSI_VID_BLKSIZE2);\n\t\t \n\t\tblkline_pck = bpl - 4 - 6;\n\t\tif (blkline_pck > 0x1FFF)\n\t\t\tdev_err(d->dev, \"blkline_pck too big %d bytes\\n\",\n\t\t\t\tblkline_pck);\n\t\tval = blkline_pck << DSI_VID_BLKSIZE1_BLKLINE_EVENT_PCK_SHIFT;\n\t\tval &= DSI_VID_BLKSIZE1_BLKLINE_EVENT_PCK_MASK;\n\t\twritel(val, d->regs + DSI_VID_BLKSIZE1);\n\t}\n\n\t \n\tline_duration = blkline_pck + 6;\n\t \n\tif (d->mdsi->lanes == 2 && (hsa & 0x01) && (hfp & 0x01)\n\t    && (d->mdsi->mode_flags & MIPI_DSI_MODE_VIDEO_BURST))\n\t\tline_duration--;\n\tline_duration = DIV_ROUND_CLOSEST(line_duration, d->mdsi->lanes);\n\tdev_dbg(d->dev, \"line duration %u bytes\\n\", line_duration);\n\tval = line_duration << DSI_VID_DPHY_TIME_REG_LINE_DURATION_SHIFT;\n\t \n\tval |= 48 << DSI_VID_DPHY_TIME_REG_WAKEUP_TIME_SHIFT;\n\twritel(val, d->regs + DSI_VID_DPHY_TIME);\n\n\t \n\tif (d->mdsi->mode_flags & MIPI_DSI_MODE_VIDEO_BURST) {\n\t\tint blkeol_pck, blkeol_duration;\n\t\t \n\t\tblkeol_pck = bpl - (mode->htotal * cpp) - 6;\n\t\tif (blkeol_pck < 0) {\n\t\t\tdev_err(d->dev, \"video block does not fit on line!\\n\");\n\t\t\tdev_err(d->dev,\n\t\t\t\t\"calculated bytes per line: %llu @ %d Hz\\n\",\n\t\t\t\tbpl, drm_mode_vrefresh(mode));\n\t\t\tdev_err(d->dev,\n\t\t\t\t\"bytes per line (blkline_pck) %u bytes\\n\",\n\t\t\t\tblkline_pck);\n\t\t\tdev_err(d->dev,\n\t\t\t\t\"blkeol_pck becomes %d bytes\\n\", blkeol_pck);\n\t\t\treturn;\n\t\t}\n\t\tdev_dbg(d->dev, \"BLKEOL packet: %d bytes\\n\", blkeol_pck);\n\n\t\tval = readl(d->regs + DSI_VID_BLKSIZE1);\n\t\tval &= ~DSI_VID_BLKSIZE1_BLKEOL_PCK_MASK;\n\t\tval |= blkeol_pck << DSI_VID_BLKSIZE1_BLKEOL_PCK_SHIFT;\n\t\twritel(val, d->regs + DSI_VID_BLKSIZE1);\n\t\t \n\t\tval = blkeol_pck <<\n\t\t\tDSI_VID_VCA_SETTING2_EXACT_BURST_LIMIT_SHIFT;\n\t\tval &= DSI_VID_VCA_SETTING2_EXACT_BURST_LIMIT_MASK;\n\t\twritel(val, d->regs + DSI_VID_VCA_SETTING2);\n\t\t \n\t\tblkeol_duration = DIV_ROUND_CLOSEST(blkeol_pck + 6,\n\t\t\t\t\t\t    d->mdsi->lanes);\n\t\tdev_dbg(d->dev, \"BLKEOL duration: %d clock cycles\\n\",\n\t\t\tblkeol_duration);\n\n\t\tval = readl(d->regs + DSI_VID_PCK_TIME);\n\t\tval &= ~DSI_VID_PCK_TIME_BLKEOL_DURATION_MASK;\n\t\tval |= blkeol_duration <<\n\t\t\tDSI_VID_PCK_TIME_BLKEOL_DURATION_SHIFT;\n\t\twritel(val, d->regs + DSI_VID_PCK_TIME);\n\n\t\t \n\t\tval = readl(d->regs + DSI_VID_VCA_SETTING1);\n\t\tval &= ~DSI_VID_VCA_SETTING1_MAX_BURST_LIMIT_MASK;\n\t\tval |= (blkeol_pck - 6) <<\n\t\t\tDSI_VID_VCA_SETTING1_MAX_BURST_LIMIT_SHIFT;\n\t\twritel(val, d->regs + DSI_VID_VCA_SETTING1);\n\t}\n\n\t \n\tval = readl(d->regs + DSI_VID_VCA_SETTING2);\n\tval &= ~DSI_VID_VCA_SETTING2_MAX_LINE_LIMIT_MASK;\n\tval |= (blkline_pck - 6) <<\n\t\tDSI_VID_VCA_SETTING2_MAX_LINE_LIMIT_SHIFT;\n\twritel(val, d->regs + DSI_VID_VCA_SETTING2);\n\tdev_dbg(d->dev, \"blkline pck: %d bytes\\n\", blkline_pck - 6);\n}\n\nstatic void mcde_dsi_start(struct mcde_dsi *d)\n{\n\tunsigned long hs_freq;\n\tu32 val;\n\tint i;\n\n\t \n\twritel(0, d->regs + DSI_MCTL_INTEGRATION_MODE);\n\n\t \n\tval = DSI_MCTL_MAIN_DATA_CTL_LINK_EN |\n\t\tDSI_MCTL_MAIN_DATA_CTL_BTA_EN |\n\t\tDSI_MCTL_MAIN_DATA_CTL_READ_EN |\n\t\tDSI_MCTL_MAIN_DATA_CTL_REG_TE_EN;\n\tif (!(d->mdsi->mode_flags & MIPI_DSI_MODE_NO_EOT_PACKET))\n\t\tval |= DSI_MCTL_MAIN_DATA_CTL_HOST_EOT_GEN;\n\twritel(val, d->regs + DSI_MCTL_MAIN_DATA_CTL);\n\n\t \n\tval = 0x3ff << DSI_CMD_MODE_CTL_TE_TIMEOUT_SHIFT;\n\twritel(val, d->regs + DSI_CMD_MODE_CTL);\n\n\t \n\ths_freq = clk_get_rate(d->hs_clk);\n\ths_freq /= 1000000;  \n\tval = 4000 / hs_freq;\n\tdev_dbg(d->dev, \"UI value: %d\\n\", val);\n\tval <<= DSI_MCTL_DPHY_STATIC_UI_X4_SHIFT;\n\tval &= DSI_MCTL_DPHY_STATIC_UI_X4_MASK;\n\twritel(val, d->regs + DSI_MCTL_DPHY_STATIC);\n\n\t \n\tval = 0x0f << DSI_MCTL_MAIN_PHY_CTL_WAIT_BURST_TIME_SHIFT;\n\tif (d->mdsi->lanes == 2)\n\t\tval |= DSI_MCTL_MAIN_PHY_CTL_LANE2_EN;\n\tif (!(d->mdsi->mode_flags & MIPI_DSI_CLOCK_NON_CONTINUOUS))\n\t\tval |= DSI_MCTL_MAIN_PHY_CTL_CLK_CONTINUOUS;\n\tval |= DSI_MCTL_MAIN_PHY_CTL_CLK_ULPM_EN |\n\t\tDSI_MCTL_MAIN_PHY_CTL_DAT1_ULPM_EN |\n\t\tDSI_MCTL_MAIN_PHY_CTL_DAT2_ULPM_EN;\n\twritel(val, d->regs + DSI_MCTL_MAIN_PHY_CTL);\n\n\tval = (1 << DSI_MCTL_ULPOUT_TIME_CKLANE_ULPOUT_TIME_SHIFT) |\n\t\t(1 << DSI_MCTL_ULPOUT_TIME_DATA_ULPOUT_TIME_SHIFT);\n\twritel(val, d->regs + DSI_MCTL_ULPOUT_TIME);\n\n\twritel(DSI_DPHY_LANES_TRIM_DPHY_SPECS_90_81B_0_90,\n\t       d->regs + DSI_DPHY_LANES_TRIM);\n\n\t \n\tval = (0x0f << DSI_MCTL_DPHY_TIMEOUT_CLK_DIV_SHIFT) |\n\t\t(0x3fff << DSI_MCTL_DPHY_TIMEOUT_HSTX_TO_VAL_SHIFT) |\n\t\t(0x3fff << DSI_MCTL_DPHY_TIMEOUT_LPRX_TO_VAL_SHIFT);\n\twritel(val, d->regs + DSI_MCTL_DPHY_TIMEOUT);\n\n\tval = DSI_MCTL_MAIN_EN_PLL_START |\n\t\tDSI_MCTL_MAIN_EN_CKLANE_EN |\n\t\tDSI_MCTL_MAIN_EN_DAT1_EN |\n\t\tDSI_MCTL_MAIN_EN_IF1_EN;\n\tif (d->mdsi->lanes == 2)\n\t\tval |= DSI_MCTL_MAIN_EN_DAT2_EN;\n\twritel(val, d->regs + DSI_MCTL_MAIN_EN);\n\n\t \n\ti = 0;\n\tval = DSI_MCTL_MAIN_STS_PLL_LOCK |\n\t\tDSI_MCTL_MAIN_STS_CLKLANE_READY |\n\t\tDSI_MCTL_MAIN_STS_DAT1_READY;\n\tif (d->mdsi->lanes == 2)\n\t\tval |= DSI_MCTL_MAIN_STS_DAT2_READY;\n\twhile ((readl(d->regs + DSI_MCTL_MAIN_STS) & val) != val) {\n\t\t \n\t\tusleep_range(1000, 1500);\n\t\tif (i++ == 100) {\n\t\t\tdev_warn(d->dev, \"DSI lanes did not start up\\n\");\n\t\t\treturn;\n\t\t}\n\t}\n\n\t \n\n\t \n\tval = readl(d->regs + DSI_CMD_MODE_CTL);\n\t \n\tif (d->mdsi->mode_flags & MIPI_DSI_MODE_LPM)\n\t\tval |= DSI_CMD_MODE_CTL_IF1_LP_EN;\n\tval &= ~DSI_CMD_MODE_CTL_IF1_ID_MASK;\n\twritel(val, d->regs + DSI_CMD_MODE_CTL);\n\n\t \n\tusleep_range(100, 200);\n\tdev_info(d->dev, \"DSI link enabled\\n\");\n}\n\n \nvoid mcde_dsi_enable(struct drm_bridge *bridge)\n{\n\tstruct mcde_dsi *d = bridge_to_mcde_dsi(bridge);\n\tunsigned long hs_freq, lp_freq;\n\tu32 val;\n\tint ret;\n\n\t \n\tif (d->mdsi->lp_rate)\n\t\tlp_freq = d->mdsi->lp_rate;\n\telse\n\t\tlp_freq = DSI_DEFAULT_LP_FREQ_HZ;\n\tif (d->mdsi->hs_rate)\n\t\ths_freq = d->mdsi->hs_rate;\n\telse\n\t\ths_freq = DSI_DEFAULT_HS_FREQ_HZ;\n\n\t \n\td->lp_freq = clk_round_rate(d->lp_clk, lp_freq);\n\tret = clk_set_rate(d->lp_clk, d->lp_freq);\n\tif (ret)\n\t\tdev_err(d->dev, \"failed to set LP clock rate %lu Hz\\n\",\n\t\t\td->lp_freq);\n\n\td->hs_freq = clk_round_rate(d->hs_clk, hs_freq);\n\tret = clk_set_rate(d->hs_clk, d->hs_freq);\n\tif (ret)\n\t\tdev_err(d->dev, \"failed to set HS clock rate %lu Hz\\n\",\n\t\t\td->hs_freq);\n\n\t \n\tret = clk_prepare_enable(d->lp_clk);\n\tif (ret)\n\t\tdev_err(d->dev, \"failed to enable LP clock\\n\");\n\telse\n\t\tdev_info(d->dev, \"DSI LP clock rate %lu Hz\\n\",\n\t\t\t d->lp_freq);\n\tret = clk_prepare_enable(d->hs_clk);\n\tif (ret)\n\t\tdev_err(d->dev, \"failed to enable HS clock\\n\");\n\telse\n\t\tdev_info(d->dev, \"DSI HS clock rate %lu Hz\\n\",\n\t\t\t d->hs_freq);\n\n\t \n\t \n\tregmap_update_bits(d->prcmu, PRCM_DSI_SW_RESET,\n\t\t\t   PRCM_DSI_SW_RESET_DSI0_SW_RESETN, 0);\n\n\tusleep_range(100, 200);\n\n\t \n\tregmap_update_bits(d->prcmu, PRCM_DSI_SW_RESET,\n\t\t\t   PRCM_DSI_SW_RESET_DSI0_SW_RESETN,\n\t\t\t   PRCM_DSI_SW_RESET_DSI0_SW_RESETN);\n\n\t \n\tmcde_dsi_start(d);\n\n\tif (d->mdsi->mode_flags & MIPI_DSI_MODE_VIDEO) {\n\t\t \n\t\tmcde_dsi_setup_video_mode(d, d->mode);\n\n\t\t \n\t\tval = readl(d->regs + DSI_MCTL_MAIN_DATA_CTL);\n\t\tval |= DSI_MCTL_MAIN_DATA_CTL_IF1_MODE;\n\t\twritel(val, d->regs + DSI_MCTL_MAIN_DATA_CTL);\n\n\t\t \n\t\tval = readl(d->regs + DSI_CMD_MODE_CTL);\n\t\tval &= ~DSI_CMD_MODE_CTL_IF1_LP_EN;\n\t\twritel(val, d->regs + DSI_CMD_MODE_CTL);\n\n\t\t \n\t\tval = readl(d->regs + DSI_VID_MODE_STS_CTL);\n\t\tval |= DSI_VID_MODE_STS_CTL_ERR_MISSING_VSYNC;\n\t\tval |= DSI_VID_MODE_STS_CTL_ERR_MISSING_DATA;\n\t\twritel(val, d->regs + DSI_VID_MODE_STS_CTL);\n\n\t\t \n\t\tval = readl(d->regs + DSI_MCTL_MAIN_DATA_CTL);\n\t\tval |= DSI_MCTL_MAIN_DATA_CTL_VID_EN;\n\t\twritel(val, d->regs + DSI_MCTL_MAIN_DATA_CTL);\n\t} else {\n\t\t \n\t\tval = readl(d->regs + DSI_CMD_MODE_CTL);\n\t\t \n\t\tif (d->mdsi->mode_flags & MIPI_DSI_MODE_LPM)\n\t\t\tval |= DSI_CMD_MODE_CTL_IF1_LP_EN;\n\t\tval &= ~DSI_CMD_MODE_CTL_IF1_ID_MASK;\n\t\twritel(val, d->regs + DSI_CMD_MODE_CTL);\n\t}\n\n\tdev_info(d->dev, \"enabled MCDE DSI master\\n\");\n}\n\nstatic void mcde_dsi_bridge_mode_set(struct drm_bridge *bridge,\n\t\t\t\t     const struct drm_display_mode *mode,\n\t\t\t\t     const struct drm_display_mode *adj)\n{\n\tstruct mcde_dsi *d = bridge_to_mcde_dsi(bridge);\n\n\tif (!d->mdsi) {\n\t\tdev_err(d->dev, \"no DSI device attached to encoder!\\n\");\n\t\treturn;\n\t}\n\n\td->mode = mode;\n\n\tdev_info(d->dev, \"set DSI master to %dx%d %u Hz %s mode\\n\",\n\t\t mode->hdisplay, mode->vdisplay, mode->clock * 1000,\n\t\t (d->mdsi->mode_flags & MIPI_DSI_MODE_VIDEO) ? \"VIDEO\" : \"CMD\"\n\t\t);\n}\n\nstatic void mcde_dsi_wait_for_command_mode_stop(struct mcde_dsi *d)\n{\n\tu32 val;\n\tint i;\n\n\t \n\ti = 0;\n\tval = DSI_CMD_MODE_STS_CSM_RUNNING;\n\twhile ((readl(d->regs + DSI_CMD_MODE_STS) & val) == val) {\n\t\t \n\t\tusleep_range(1000, 2000);\n\t\tif (i++ == 100) {\n\t\t\tdev_warn(d->dev,\n\t\t\t\t \"could not get out of command mode\\n\");\n\t\t\treturn;\n\t\t}\n\t}\n}\n\nstatic void mcde_dsi_wait_for_video_mode_stop(struct mcde_dsi *d)\n{\n\tu32 val;\n\tint i;\n\n\t \n\ti = 0;\n\tval = DSI_VID_MODE_STS_VSG_RUNNING;\n\twhile ((readl(d->regs + DSI_VID_MODE_STS) & val) == val) {\n\t\t \n\t\tusleep_range(1000, 2000);\n\t\tif (i++ == 100) {\n\t\t\tdev_warn(d->dev,\n\t\t\t\t \"could not get out of video mode\\n\");\n\t\t\treturn;\n\t\t}\n\t}\n}\n\n \nvoid mcde_dsi_disable(struct drm_bridge *bridge)\n{\n\tstruct mcde_dsi *d = bridge_to_mcde_dsi(bridge);\n\tu32 val;\n\n\tif (d->mdsi->mode_flags & MIPI_DSI_MODE_VIDEO) {\n\t\t \n\t\tval = readl(d->regs + DSI_MCTL_MAIN_DATA_CTL);\n\t\tval &= ~DSI_MCTL_MAIN_DATA_CTL_VID_EN;\n\t\twritel(val, d->regs + DSI_MCTL_MAIN_DATA_CTL);\n\t\tmcde_dsi_wait_for_video_mode_stop(d);\n\t} else {\n\t\t \n\t\tmcde_dsi_wait_for_command_mode_stop(d);\n\t}\n\n\t \n\n\t \n\twritel(0, d->regs + DSI_VID_MODE_STS_CTL);\n\tclk_disable_unprepare(d->hs_clk);\n\tclk_disable_unprepare(d->lp_clk);\n}\n\nstatic int mcde_dsi_bridge_attach(struct drm_bridge *bridge,\n\t\t\t\t  enum drm_bridge_attach_flags flags)\n{\n\tstruct mcde_dsi *d = bridge_to_mcde_dsi(bridge);\n\tstruct drm_device *drm = bridge->dev;\n\n\tif (!drm_core_check_feature(drm, DRIVER_ATOMIC)) {\n\t\tdev_err(d->dev, \"we need atomic updates\\n\");\n\t\treturn -ENOTSUPP;\n\t}\n\n\t \n\treturn drm_bridge_attach(bridge->encoder, d->bridge_out, bridge, flags);\n}\n\nstatic const struct drm_bridge_funcs mcde_dsi_bridge_funcs = {\n\t.attach = mcde_dsi_bridge_attach,\n\t.mode_set = mcde_dsi_bridge_mode_set,\n};\n\nstatic int mcde_dsi_bind(struct device *dev, struct device *master,\n\t\t\t void *data)\n{\n\tstruct drm_device *drm = data;\n\tstruct mcde *mcde = to_mcde(drm);\n\tstruct mcde_dsi *d = dev_get_drvdata(dev);\n\tstruct device_node *child;\n\tstruct drm_panel *panel = NULL;\n\tstruct drm_bridge *bridge = NULL;\n\n\tif (!of_get_available_child_count(dev->of_node)) {\n\t\tdev_info(dev, \"unused DSI interface\\n\");\n\t\td->unused = true;\n\t\treturn 0;\n\t}\n\td->mcde = mcde;\n\t \n\tif (d->mdsi)\n\t\tmcde_dsi_attach_to_mcde(d);\n\n\t \n\td->hs_clk = devm_clk_get(dev, \"hs\");\n\tif (IS_ERR(d->hs_clk)) {\n\t\tdev_err(dev, \"unable to get HS clock\\n\");\n\t\treturn PTR_ERR(d->hs_clk);\n\t}\n\n\td->lp_clk = devm_clk_get(dev, \"lp\");\n\tif (IS_ERR(d->lp_clk)) {\n\t\tdev_err(dev, \"unable to get LP clock\\n\");\n\t\treturn PTR_ERR(d->lp_clk);\n\t}\n\n\t \n\tfor_each_available_child_of_node(dev->of_node, child) {\n\t\tpanel = of_drm_find_panel(child);\n\t\tif (IS_ERR(panel)) {\n\t\t\tdev_err(dev, \"failed to find panel try bridge (%ld)\\n\",\n\t\t\t\tPTR_ERR(panel));\n\t\t\tpanel = NULL;\n\n\t\t\tbridge = of_drm_find_bridge(child);\n\t\t\tif (!bridge) {\n\t\t\t\tdev_err(dev, \"failed to find bridge\\n\");\n\t\t\t\tof_node_put(child);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t}\n\t}\n\tif (panel) {\n\t\tbridge = drm_panel_bridge_add_typed(panel,\n\t\t\t\t\t\t    DRM_MODE_CONNECTOR_DSI);\n\t\tif (IS_ERR(bridge)) {\n\t\t\tdev_err(dev, \"error adding panel bridge\\n\");\n\t\t\treturn PTR_ERR(bridge);\n\t\t}\n\t\tdev_info(dev, \"connected to panel\\n\");\n\t\td->panel = panel;\n\t} else if (bridge) {\n\t\t \n\t\tdev_info(dev, \"connected to non-panel bridge (unsupported)\\n\");\n\t\treturn -ENODEV;\n\t} else {\n\t\tdev_err(dev, \"no panel or bridge\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\td->bridge_out = bridge;\n\n\t \n\td->bridge.funcs = &mcde_dsi_bridge_funcs;\n\td->bridge.of_node = dev->of_node;\n\tdrm_bridge_add(&d->bridge);\n\n\t \n\tmcde->bridge = &d->bridge;\n\n\tdev_info(dev, \"initialized MCDE DSI bridge\\n\");\n\n\treturn 0;\n}\n\nstatic void mcde_dsi_unbind(struct device *dev, struct device *master,\n\t\t\t    void *data)\n{\n\tstruct mcde_dsi *d = dev_get_drvdata(dev);\n\n\tif (d->panel)\n\t\tdrm_panel_bridge_remove(d->bridge_out);\n\tregmap_update_bits(d->prcmu, PRCM_DSI_SW_RESET,\n\t\t\t   PRCM_DSI_SW_RESET_DSI0_SW_RESETN, 0);\n}\n\nstatic const struct component_ops mcde_dsi_component_ops = {\n\t.bind   = mcde_dsi_bind,\n\t.unbind = mcde_dsi_unbind,\n};\n\nstatic int mcde_dsi_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct mcde_dsi *d;\n\tstruct mipi_dsi_host *host;\n\tu32 dsi_id;\n\tint ret;\n\n\td = devm_kzalloc(dev, sizeof(*d), GFP_KERNEL);\n\tif (!d)\n\t\treturn -ENOMEM;\n\td->dev = dev;\n\tplatform_set_drvdata(pdev, d);\n\n\t \n\td->prcmu =\n\t\tsyscon_regmap_lookup_by_compatible(\"stericsson,db8500-prcmu\");\n\tif (IS_ERR(d->prcmu)) {\n\t\tdev_err(dev, \"no PRCMU regmap\\n\");\n\t\treturn PTR_ERR(d->prcmu);\n\t}\n\n\td->regs = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(d->regs))\n\t\treturn PTR_ERR(d->regs);\n\n\tdsi_id = readl(d->regs + DSI_ID_REG);\n\tdev_info(dev, \"HW revision 0x%08x\\n\", dsi_id);\n\n\thost = &d->dsi_host;\n\thost->dev = dev;\n\thost->ops = &mcde_dsi_host_ops;\n\tret = mipi_dsi_host_register(host);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"failed to register DSI host: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\tdev_info(dev, \"registered DSI host\\n\");\n\n\tplatform_set_drvdata(pdev, d);\n\treturn component_add(dev, &mcde_dsi_component_ops);\n}\n\nstatic void mcde_dsi_remove(struct platform_device *pdev)\n{\n\tstruct mcde_dsi *d = platform_get_drvdata(pdev);\n\n\tcomponent_del(&pdev->dev, &mcde_dsi_component_ops);\n\tmipi_dsi_host_unregister(&d->dsi_host);\n}\n\nstatic const struct of_device_id mcde_dsi_of_match[] = {\n\t{\n\t\t.compatible = \"ste,mcde-dsi\",\n\t},\n\t{},\n};\n\nstruct platform_driver mcde_dsi_driver = {\n\t.driver = {\n\t\t.name           = \"mcde-dsi\",\n\t\t.of_match_table = mcde_dsi_of_match,\n\t},\n\t.probe = mcde_dsi_probe,\n\t.remove_new = mcde_dsi_remove,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}