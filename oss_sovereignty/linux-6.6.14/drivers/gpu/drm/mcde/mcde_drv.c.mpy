{
  "module_name": "mcde_drv.c",
  "hash_id": "706c04c9eb5471a7e297a8d749c9aaadaa69be18d6c69db8c36110818adfbc75",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/mcde/mcde_drv.c",
  "human_readable_source": "\n \n\n \n\n#include <linux/clk.h>\n#include <linux/component.h>\n#include <linux/dma-buf.h>\n#include <linux/irq.h>\n#include <linux/io.h>\n#include <linux/module.h>\n#include <linux/of_platform.h>\n#include <linux/platform_device.h>\n#include <linux/regulator/consumer.h>\n#include <linux/slab.h>\n#include <linux/delay.h>\n\n#include <drm/drm_atomic_helper.h>\n#include <drm/drm_bridge.h>\n#include <drm/drm_drv.h>\n#include <drm/drm_fb_dma_helper.h>\n#include <drm/drm_fbdev_dma.h>\n#include <drm/drm_gem.h>\n#include <drm/drm_gem_dma_helper.h>\n#include <drm/drm_gem_framebuffer_helper.h>\n#include <drm/drm_managed.h>\n#include <drm/drm_of.h>\n#include <drm/drm_probe_helper.h>\n#include <drm/drm_panel.h>\n#include <drm/drm_vblank.h>\n\n#include \"mcde_drm.h\"\n\n#define DRIVER_DESC\t\"DRM module for MCDE\"\n\n#define MCDE_PID 0x000001FC\n#define MCDE_PID_METALFIX_VERSION_SHIFT 0\n#define MCDE_PID_METALFIX_VERSION_MASK 0x000000FF\n#define MCDE_PID_DEVELOPMENT_VERSION_SHIFT 8\n#define MCDE_PID_DEVELOPMENT_VERSION_MASK 0x0000FF00\n#define MCDE_PID_MINOR_VERSION_SHIFT 16\n#define MCDE_PID_MINOR_VERSION_MASK 0x00FF0000\n#define MCDE_PID_MAJOR_VERSION_SHIFT 24\n#define MCDE_PID_MAJOR_VERSION_MASK 0xFF000000\n\nstatic const struct drm_mode_config_funcs mcde_mode_config_funcs = {\n\t.fb_create = drm_gem_fb_create,\n\t.atomic_check = drm_atomic_helper_check,\n\t.atomic_commit = drm_atomic_helper_commit,\n};\n\nstatic const struct drm_mode_config_helper_funcs mcde_mode_config_helpers = {\n\t \n\t.atomic_commit_tail = drm_atomic_helper_commit_tail_rpm,\n};\n\nstatic irqreturn_t mcde_irq(int irq, void *data)\n{\n\tstruct mcde *mcde = data;\n\tu32 val;\n\n\tval = readl(mcde->regs + MCDE_MISERR);\n\n\tmcde_display_irq(mcde);\n\n\tif (val)\n\t\tdev_info(mcde->dev, \"some error IRQ\\n\");\n\twritel(val, mcde->regs + MCDE_RISERR);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int mcde_modeset_init(struct drm_device *drm)\n{\n\tstruct drm_mode_config *mode_config;\n\tstruct mcde *mcde = to_mcde(drm);\n\tint ret;\n\n\t \n\tif (!mcde->bridge) {\n\t\tstruct drm_panel *panel;\n\t\tstruct drm_bridge *bridge;\n\n\t\tret = drm_of_find_panel_or_bridge(drm->dev->of_node,\n\t\t\t\t\t\t  0, 0, &panel, &bridge);\n\t\tif (ret) {\n\t\t\tdev_err(drm->dev,\n\t\t\t\t\"Could not locate any output bridge or panel\\n\");\n\t\t\treturn ret;\n\t\t}\n\t\tif (panel) {\n\t\t\tbridge = drm_panel_bridge_add_typed(panel,\n\t\t\t\t\tDRM_MODE_CONNECTOR_DPI);\n\t\t\tif (IS_ERR(bridge)) {\n\t\t\t\tdev_err(drm->dev,\n\t\t\t\t\t\"Could not connect panel bridge\\n\");\n\t\t\t\treturn PTR_ERR(bridge);\n\t\t\t}\n\t\t}\n\t\tmcde->dpi_output = true;\n\t\tmcde->bridge = bridge;\n\t\tmcde->flow_mode = MCDE_DPI_FORMATTER_FLOW;\n\t}\n\n\tmode_config = &drm->mode_config;\n\tmode_config->funcs = &mcde_mode_config_funcs;\n\tmode_config->helper_private = &mcde_mode_config_helpers;\n\t \n\tmode_config->min_width = 1;\n\tmode_config->max_width = 1920;\n\tmode_config->min_height = 1;\n\tmode_config->max_height = 1080;\n\n\tret = drm_vblank_init(drm, 1);\n\tif (ret) {\n\t\tdev_err(drm->dev, \"failed to init vblank\\n\");\n\t\treturn ret;\n\t}\n\n\tret = mcde_display_init(drm);\n\tif (ret) {\n\t\tdev_err(drm->dev, \"failed to init display\\n\");\n\t\treturn ret;\n\t}\n\n\t \n\tret = drm_simple_display_pipe_attach_bridge(&mcde->pipe,\n\t\t\t\t\t\t    mcde->bridge);\n\tif (ret) {\n\t\tdev_err(drm->dev, \"failed to attach display output bridge\\n\");\n\t\treturn ret;\n\t}\n\n\tdrm_mode_config_reset(drm);\n\tdrm_kms_helper_poll_init(drm);\n\n\treturn 0;\n}\n\nDEFINE_DRM_GEM_DMA_FOPS(drm_fops);\n\nstatic const struct drm_driver mcde_drm_driver = {\n\t.driver_features =\n\t\tDRIVER_MODESET | DRIVER_GEM | DRIVER_ATOMIC,\n\t.ioctls = NULL,\n\t.fops = &drm_fops,\n\t.name = \"mcde\",\n\t.desc = DRIVER_DESC,\n\t.date = \"20180529\",\n\t.major = 1,\n\t.minor = 0,\n\t.patchlevel = 0,\n\tDRM_GEM_DMA_DRIVER_OPS,\n};\n\nstatic int mcde_drm_bind(struct device *dev)\n{\n\tstruct drm_device *drm = dev_get_drvdata(dev);\n\tint ret;\n\n\tret = drmm_mode_config_init(drm);\n\tif (ret)\n\t\treturn ret;\n\n\tret = component_bind_all(drm->dev, drm);\n\tif (ret) {\n\t\tdev_err(dev, \"can't bind component devices\\n\");\n\t\treturn ret;\n\t}\n\n\tret = mcde_modeset_init(drm);\n\tif (ret)\n\t\tgoto unbind;\n\n\tret = drm_dev_register(drm, 0);\n\tif (ret < 0)\n\t\tgoto unbind;\n\n\tdrm_fbdev_dma_setup(drm, 32);\n\n\treturn 0;\n\nunbind:\n\tcomponent_unbind_all(drm->dev, drm);\n\treturn ret;\n}\n\nstatic void mcde_drm_unbind(struct device *dev)\n{\n\tstruct drm_device *drm = dev_get_drvdata(dev);\n\n\tdrm_dev_unregister(drm);\n\tdrm_atomic_helper_shutdown(drm);\n\tcomponent_unbind_all(drm->dev, drm);\n}\n\nstatic const struct component_master_ops mcde_drm_comp_ops = {\n\t.bind = mcde_drm_bind,\n\t.unbind = mcde_drm_unbind,\n};\n\nstatic struct platform_driver *const mcde_component_drivers[] = {\n\t&mcde_dsi_driver,\n};\n\nstatic int mcde_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct drm_device *drm;\n\tstruct mcde *mcde;\n\tstruct component_match *match = NULL;\n\tu32 pid;\n\tint irq;\n\tint ret;\n\tint i;\n\n\tmcde = devm_drm_dev_alloc(dev, &mcde_drm_driver, struct mcde, drm);\n\tif (IS_ERR(mcde))\n\t\treturn PTR_ERR(mcde);\n\tdrm = &mcde->drm;\n\tmcde->dev = dev;\n\tplatform_set_drvdata(pdev, drm);\n\n\t \n\tmcde->epod = devm_regulator_get(dev, \"epod\");\n\tif (IS_ERR(mcde->epod)) {\n\t\tret = PTR_ERR(mcde->epod);\n\t\tdev_err(dev, \"can't get EPOD regulator\\n\");\n\t\treturn ret;\n\t}\n\tret = regulator_enable(mcde->epod);\n\tif (ret) {\n\t\tdev_err(dev, \"can't enable EPOD regulator\\n\");\n\t\treturn ret;\n\t}\n\tmcde->vana = devm_regulator_get(dev, \"vana\");\n\tif (IS_ERR(mcde->vana)) {\n\t\tret = PTR_ERR(mcde->vana);\n\t\tdev_err(dev, \"can't get VANA regulator\\n\");\n\t\tgoto regulator_epod_off;\n\t}\n\tret = regulator_enable(mcde->vana);\n\tif (ret) {\n\t\tdev_err(dev, \"can't enable VANA regulator\\n\");\n\t\tgoto regulator_epod_off;\n\t}\n\t \n\n\t \n\tmcde->mcde_clk = devm_clk_get(dev, \"mcde\");\n\tif (IS_ERR(mcde->mcde_clk)) {\n\t\tdev_err(dev, \"unable to get MCDE main clock\\n\");\n\t\tret = PTR_ERR(mcde->mcde_clk);\n\t\tgoto regulator_off;\n\t}\n\tret = clk_prepare_enable(mcde->mcde_clk);\n\tif (ret) {\n\t\tdev_err(dev, \"failed to enable MCDE main clock\\n\");\n\t\tgoto regulator_off;\n\t}\n\tdev_info(dev, \"MCDE clk rate %lu Hz\\n\", clk_get_rate(mcde->mcde_clk));\n\n\tmcde->lcd_clk = devm_clk_get(dev, \"lcd\");\n\tif (IS_ERR(mcde->lcd_clk)) {\n\t\tdev_err(dev, \"unable to get LCD clock\\n\");\n\t\tret = PTR_ERR(mcde->lcd_clk);\n\t\tgoto clk_disable;\n\t}\n\tmcde->hdmi_clk = devm_clk_get(dev, \"hdmi\");\n\tif (IS_ERR(mcde->hdmi_clk)) {\n\t\tdev_err(dev, \"unable to get HDMI clock\\n\");\n\t\tret = PTR_ERR(mcde->hdmi_clk);\n\t\tgoto clk_disable;\n\t}\n\n\tmcde->regs = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(mcde->regs)) {\n\t\tdev_err(dev, \"no MCDE regs\\n\");\n\t\tret = -EINVAL;\n\t\tgoto clk_disable;\n\t}\n\n\tirq = platform_get_irq(pdev, 0);\n\tif (irq < 0) {\n\t\tret = irq;\n\t\tgoto clk_disable;\n\t}\n\n\tret = devm_request_irq(dev, irq, mcde_irq, 0, \"mcde\", mcde);\n\tif (ret) {\n\t\tdev_err(dev, \"failed to request irq %d\\n\", ret);\n\t\tgoto clk_disable;\n\t}\n\n\t \n\tpid = readl(mcde->regs + MCDE_PID);\n\tdev_info(dev, \"found MCDE HW revision %d.%d (dev %d, metal fix %d)\\n\",\n\t\t (pid & MCDE_PID_MAJOR_VERSION_MASK)\n\t\t >> MCDE_PID_MAJOR_VERSION_SHIFT,\n\t\t (pid & MCDE_PID_MINOR_VERSION_MASK)\n\t\t >> MCDE_PID_MINOR_VERSION_SHIFT,\n\t\t (pid & MCDE_PID_DEVELOPMENT_VERSION_MASK)\n\t\t >> MCDE_PID_DEVELOPMENT_VERSION_SHIFT,\n\t\t (pid & MCDE_PID_METALFIX_VERSION_MASK)\n\t\t >> MCDE_PID_METALFIX_VERSION_SHIFT);\n\tif (pid != 0x03000800) {\n\t\tdev_err(dev, \"unsupported hardware revision\\n\");\n\t\tret = -ENODEV;\n\t\tgoto clk_disable;\n\t}\n\n\t \n\tmcde_display_disable_irqs(mcde);\n\twritel(0, mcde->regs + MCDE_IMSCERR);\n\twritel(0xFFFFFFFF, mcde->regs + MCDE_RISERR);\n\n\t \n\tdevm_of_platform_populate(dev);\n\n\t \n\tfor (i = 0; i < ARRAY_SIZE(mcde_component_drivers); i++) {\n\t\tstruct device_driver *drv = &mcde_component_drivers[i]->driver;\n\t\tstruct device *p = NULL, *d;\n\n\t\twhile ((d = platform_find_device_by_driver(p, drv))) {\n\t\t\tput_device(p);\n\t\t\tcomponent_match_add(dev, &match, component_compare_dev, d);\n\t\t\tp = d;\n\t\t}\n\t\tput_device(p);\n\t}\n\tif (!match) {\n\t\tdev_err(dev, \"no matching components\\n\");\n\t\tret = -ENODEV;\n\t\tgoto clk_disable;\n\t}\n\tif (IS_ERR(match)) {\n\t\tdev_err(dev, \"could not create component match\\n\");\n\t\tret = PTR_ERR(match);\n\t\tgoto clk_disable;\n\t}\n\n\t \n\tret = regulator_disable(mcde->epod);\n\tif (ret) {\n\t\tdev_err(dev, \"can't disable EPOD regulator\\n\");\n\t\treturn ret;\n\t}\n\t \n\tusleep_range(50000, 70000);\n\n\tret = component_master_add_with_match(&pdev->dev, &mcde_drm_comp_ops,\n\t\t\t\t\t      match);\n\tif (ret) {\n\t\tdev_err(dev, \"failed to add component master\\n\");\n\t\t \n\t\tclk_disable_unprepare(mcde->mcde_clk);\n\t\tregulator_disable(mcde->vana);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n\nclk_disable:\n\tclk_disable_unprepare(mcde->mcde_clk);\nregulator_off:\n\tregulator_disable(mcde->vana);\nregulator_epod_off:\n\tregulator_disable(mcde->epod);\n\treturn ret;\n\n}\n\nstatic void mcde_remove(struct platform_device *pdev)\n{\n\tstruct drm_device *drm = platform_get_drvdata(pdev);\n\tstruct mcde *mcde = to_mcde(drm);\n\n\tcomponent_master_del(&pdev->dev, &mcde_drm_comp_ops);\n\tclk_disable_unprepare(mcde->mcde_clk);\n\tregulator_disable(mcde->vana);\n\tregulator_disable(mcde->epod);\n}\n\nstatic const struct of_device_id mcde_of_match[] = {\n\t{\n\t\t.compatible = \"ste,mcde\",\n\t},\n\t{},\n};\n\nstatic struct platform_driver mcde_driver = {\n\t.driver = {\n\t\t.name           = \"mcde\",\n\t\t.of_match_table = mcde_of_match,\n\t},\n\t.probe = mcde_probe,\n\t.remove_new = mcde_remove,\n};\n\nstatic struct platform_driver *const component_drivers[] = {\n\t&mcde_dsi_driver,\n};\n\nstatic int __init mcde_drm_register(void)\n{\n\tint ret;\n\n\tif (drm_firmware_drivers_only())\n\t\treturn -ENODEV;\n\n\tret = platform_register_drivers(component_drivers,\n\t\t\t\t\tARRAY_SIZE(component_drivers));\n\tif (ret)\n\t\treturn ret;\n\n\treturn platform_driver_register(&mcde_driver);\n}\n\nstatic void __exit mcde_drm_unregister(void)\n{\n\tplatform_unregister_drivers(component_drivers,\n\t\t\t\t    ARRAY_SIZE(component_drivers));\n\tplatform_driver_unregister(&mcde_driver);\n}\n\nmodule_init(mcde_drm_register);\nmodule_exit(mcde_drm_unregister);\n\nMODULE_ALIAS(\"platform:mcde-drm\");\nMODULE_DESCRIPTION(DRIVER_DESC);\nMODULE_AUTHOR(\"Linus Walleij <linus.walleij@linaro.org>\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}