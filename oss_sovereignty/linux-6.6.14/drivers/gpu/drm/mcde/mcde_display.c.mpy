{
  "module_name": "mcde_display.c",
  "hash_id": "32b66227a6bbad6e859df0df19391f74c6c0473dc6f02495c127a780d8a67099",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/mcde/mcde_display.c",
  "human_readable_source": "\n \n#include <linux/clk.h>\n#include <linux/delay.h>\n#include <linux/dma-buf.h>\n#include <linux/regulator/consumer.h>\n#include <linux/media-bus-format.h>\n\n#include <drm/drm_device.h>\n#include <drm/drm_fb_dma_helper.h>\n#include <drm/drm_fourcc.h>\n#include <drm/drm_framebuffer.h>\n#include <drm/drm_gem_atomic_helper.h>\n#include <drm/drm_gem_dma_helper.h>\n#include <drm/drm_mipi_dsi.h>\n#include <drm/drm_simple_kms_helper.h>\n#include <drm/drm_bridge.h>\n#include <drm/drm_vblank.h>\n#include <video/mipi_display.h>\n\n#include \"mcde_drm.h\"\n#include \"mcde_display_regs.h\"\n\nenum mcde_fifo {\n\tMCDE_FIFO_A,\n\tMCDE_FIFO_B,\n\t \n};\n\nenum mcde_channel {\n\tMCDE_CHANNEL_0 = 0,\n\tMCDE_CHANNEL_1,\n\tMCDE_CHANNEL_2,\n\tMCDE_CHANNEL_3,\n};\n\nenum mcde_extsrc {\n\tMCDE_EXTSRC_0 = 0,\n\tMCDE_EXTSRC_1,\n\tMCDE_EXTSRC_2,\n\tMCDE_EXTSRC_3,\n\tMCDE_EXTSRC_4,\n\tMCDE_EXTSRC_5,\n\tMCDE_EXTSRC_6,\n\tMCDE_EXTSRC_7,\n\tMCDE_EXTSRC_8,\n\tMCDE_EXTSRC_9,\n};\n\nenum mcde_overlay {\n\tMCDE_OVERLAY_0 = 0,\n\tMCDE_OVERLAY_1,\n\tMCDE_OVERLAY_2,\n\tMCDE_OVERLAY_3,\n\tMCDE_OVERLAY_4,\n\tMCDE_OVERLAY_5,\n};\n\nenum mcde_formatter {\n\tMCDE_DSI_FORMATTER_0 = 0,\n\tMCDE_DSI_FORMATTER_1,\n\tMCDE_DSI_FORMATTER_2,\n\tMCDE_DSI_FORMATTER_3,\n\tMCDE_DSI_FORMATTER_4,\n\tMCDE_DSI_FORMATTER_5,\n\tMCDE_DPI_FORMATTER_0,\n\tMCDE_DPI_FORMATTER_1,\n};\n\nvoid mcde_display_irq(struct mcde *mcde)\n{\n\tu32 mispp, misovl, mischnl;\n\tbool vblank = false;\n\n\t \n\tmispp = readl(mcde->regs + MCDE_MISPP);\n\tmisovl = readl(mcde->regs + MCDE_MISOVL);\n\tmischnl = readl(mcde->regs + MCDE_MISCHNL);\n\n\t \n\tif (!mcde->dpi_output && mcde_dsi_irq(mcde->mdsi)) {\n\t\tu32 val;\n\n\t\t \n\t\tif (mcde->flow_mode == MCDE_COMMAND_ONESHOT_FLOW) {\n\t\t\tspin_lock(&mcde->flow_lock);\n\t\t\tif (--mcde->flow_active == 0) {\n\t\t\t\tdev_dbg(mcde->dev, \"TE0 IRQ\\n\");\n\t\t\t\t \n\t\t\t\tval = readl(mcde->regs + MCDE_CRA0);\n\t\t\t\tval &= ~MCDE_CRX0_FLOEN;\n\t\t\t\twritel(val, mcde->regs + MCDE_CRA0);\n\t\t\t}\n\t\t\tspin_unlock(&mcde->flow_lock);\n\t\t}\n\t}\n\n\t \n\tif (mispp & MCDE_PP_VCMPA) {\n\t\tdev_dbg(mcde->dev, \"chnl A vblank IRQ\\n\");\n\t\tvblank = true;\n\t}\n\tif (mispp & MCDE_PP_VCMPB) {\n\t\tdev_dbg(mcde->dev, \"chnl B vblank IRQ\\n\");\n\t\tvblank = true;\n\t}\n\tif (mispp & MCDE_PP_VCMPC0)\n\t\tdev_dbg(mcde->dev, \"chnl C0 vblank IRQ\\n\");\n\tif (mispp & MCDE_PP_VCMPC1)\n\t\tdev_dbg(mcde->dev, \"chnl C1 vblank IRQ\\n\");\n\tif (mispp & MCDE_PP_VSCC0)\n\t\tdev_dbg(mcde->dev, \"chnl C0 TE IRQ\\n\");\n\tif (mispp & MCDE_PP_VSCC1)\n\t\tdev_dbg(mcde->dev, \"chnl C1 TE IRQ\\n\");\n\twritel(mispp, mcde->regs + MCDE_RISPP);\n\n\tif (vblank)\n\t\tdrm_crtc_handle_vblank(&mcde->pipe.crtc);\n\n\tif (misovl)\n\t\tdev_info(mcde->dev, \"some stray overlay IRQ %08x\\n\", misovl);\n\twritel(misovl, mcde->regs + MCDE_RISOVL);\n\n\tif (mischnl)\n\t\tdev_info(mcde->dev, \"some stray channel error IRQ %08x\\n\",\n\t\t\t mischnl);\n\twritel(mischnl, mcde->regs + MCDE_RISCHNL);\n}\n\nvoid mcde_display_disable_irqs(struct mcde *mcde)\n{\n\t \n\twritel(0, mcde->regs + MCDE_IMSCPP);\n\twritel(0, mcde->regs + MCDE_IMSCOVL);\n\twritel(0, mcde->regs + MCDE_IMSCCHNL);\n\n\t \n\twritel(0xFFFFFFFF, mcde->regs + MCDE_RISPP);\n\twritel(0xFFFFFFFF, mcde->regs + MCDE_RISOVL);\n\twritel(0xFFFFFFFF, mcde->regs + MCDE_RISCHNL);\n}\n\nstatic int mcde_display_check(struct drm_simple_display_pipe *pipe,\n\t\t\t      struct drm_plane_state *pstate,\n\t\t\t      struct drm_crtc_state *cstate)\n{\n\tconst struct drm_display_mode *mode = &cstate->mode;\n\tstruct drm_framebuffer *old_fb = pipe->plane.state->fb;\n\tstruct drm_framebuffer *fb = pstate->fb;\n\n\tif (fb) {\n\t\tu32 offset = drm_fb_dma_get_gem_addr(fb, pstate, 0);\n\n\t\t \n\t\tif (offset & 3) {\n\t\t\tDRM_DEBUG_KMS(\"FB not 32-bit aligned\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\t \n\t\tif (fb->pitches[0] != mode->hdisplay * fb->format->cpp[0]) {\n\t\t\tDRM_DEBUG_KMS(\"can't handle pitches\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\t \n\t\tif (old_fb && old_fb->format != fb->format)\n\t\t\tcstate->mode_changed = true;\n\t}\n\n\treturn 0;\n}\n\nstatic int mcde_configure_extsrc(struct mcde *mcde, enum mcde_extsrc src,\n\t\t\t\t u32 format)\n{\n\tu32 val;\n\tu32 conf;\n\tu32 cr;\n\n\tswitch (src) {\n\tcase MCDE_EXTSRC_0:\n\t\tconf = MCDE_EXTSRC0CONF;\n\t\tcr = MCDE_EXTSRC0CR;\n\t\tbreak;\n\tcase MCDE_EXTSRC_1:\n\t\tconf = MCDE_EXTSRC1CONF;\n\t\tcr = MCDE_EXTSRC1CR;\n\t\tbreak;\n\tcase MCDE_EXTSRC_2:\n\t\tconf = MCDE_EXTSRC2CONF;\n\t\tcr = MCDE_EXTSRC2CR;\n\t\tbreak;\n\tcase MCDE_EXTSRC_3:\n\t\tconf = MCDE_EXTSRC3CONF;\n\t\tcr = MCDE_EXTSRC3CR;\n\t\tbreak;\n\tcase MCDE_EXTSRC_4:\n\t\tconf = MCDE_EXTSRC4CONF;\n\t\tcr = MCDE_EXTSRC4CR;\n\t\tbreak;\n\tcase MCDE_EXTSRC_5:\n\t\tconf = MCDE_EXTSRC5CONF;\n\t\tcr = MCDE_EXTSRC5CR;\n\t\tbreak;\n\tcase MCDE_EXTSRC_6:\n\t\tconf = MCDE_EXTSRC6CONF;\n\t\tcr = MCDE_EXTSRC6CR;\n\t\tbreak;\n\tcase MCDE_EXTSRC_7:\n\t\tconf = MCDE_EXTSRC7CONF;\n\t\tcr = MCDE_EXTSRC7CR;\n\t\tbreak;\n\tcase MCDE_EXTSRC_8:\n\t\tconf = MCDE_EXTSRC8CONF;\n\t\tcr = MCDE_EXTSRC8CR;\n\t\tbreak;\n\tcase MCDE_EXTSRC_9:\n\t\tconf = MCDE_EXTSRC9CONF;\n\t\tcr = MCDE_EXTSRC9CR;\n\t\tbreak;\n\t}\n\n\t \n\tval = 0 << MCDE_EXTSRCXCONF_BUF_ID_SHIFT;\n\tval |= 1 << MCDE_EXTSRCXCONF_BUF_NB_SHIFT;\n\tval |= 0 << MCDE_EXTSRCXCONF_PRI_OVLID_SHIFT;\n\n\tswitch (format) {\n\tcase DRM_FORMAT_ARGB8888:\n\t\tval |= MCDE_EXTSRCXCONF_BPP_ARGB8888 <<\n\t\t\tMCDE_EXTSRCXCONF_BPP_SHIFT;\n\t\tbreak;\n\tcase DRM_FORMAT_ABGR8888:\n\t\tval |= MCDE_EXTSRCXCONF_BPP_ARGB8888 <<\n\t\t\tMCDE_EXTSRCXCONF_BPP_SHIFT;\n\t\tval |= MCDE_EXTSRCXCONF_BGR;\n\t\tbreak;\n\tcase DRM_FORMAT_XRGB8888:\n\t\tval |= MCDE_EXTSRCXCONF_BPP_XRGB8888 <<\n\t\t\tMCDE_EXTSRCXCONF_BPP_SHIFT;\n\t\tbreak;\n\tcase DRM_FORMAT_XBGR8888:\n\t\tval |= MCDE_EXTSRCXCONF_BPP_XRGB8888 <<\n\t\t\tMCDE_EXTSRCXCONF_BPP_SHIFT;\n\t\tval |= MCDE_EXTSRCXCONF_BGR;\n\t\tbreak;\n\tcase DRM_FORMAT_RGB888:\n\t\tval |= MCDE_EXTSRCXCONF_BPP_RGB888 <<\n\t\t\tMCDE_EXTSRCXCONF_BPP_SHIFT;\n\t\tbreak;\n\tcase DRM_FORMAT_BGR888:\n\t\tval |= MCDE_EXTSRCXCONF_BPP_RGB888 <<\n\t\t\tMCDE_EXTSRCXCONF_BPP_SHIFT;\n\t\tval |= MCDE_EXTSRCXCONF_BGR;\n\t\tbreak;\n\tcase DRM_FORMAT_ARGB4444:\n\t\tval |= MCDE_EXTSRCXCONF_BPP_ARGB4444 <<\n\t\t\tMCDE_EXTSRCXCONF_BPP_SHIFT;\n\t\tbreak;\n\tcase DRM_FORMAT_ABGR4444:\n\t\tval |= MCDE_EXTSRCXCONF_BPP_ARGB4444 <<\n\t\t\tMCDE_EXTSRCXCONF_BPP_SHIFT;\n\t\tval |= MCDE_EXTSRCXCONF_BGR;\n\t\tbreak;\n\tcase DRM_FORMAT_XRGB4444:\n\t\tval |= MCDE_EXTSRCXCONF_BPP_RGB444 <<\n\t\t\tMCDE_EXTSRCXCONF_BPP_SHIFT;\n\t\tbreak;\n\tcase DRM_FORMAT_XBGR4444:\n\t\tval |= MCDE_EXTSRCXCONF_BPP_RGB444 <<\n\t\t\tMCDE_EXTSRCXCONF_BPP_SHIFT;\n\t\tval |= MCDE_EXTSRCXCONF_BGR;\n\t\tbreak;\n\tcase DRM_FORMAT_XRGB1555:\n\t\tval |= MCDE_EXTSRCXCONF_BPP_IRGB1555 <<\n\t\t\tMCDE_EXTSRCXCONF_BPP_SHIFT;\n\t\tbreak;\n\tcase DRM_FORMAT_XBGR1555:\n\t\tval |= MCDE_EXTSRCXCONF_BPP_IRGB1555 <<\n\t\t\tMCDE_EXTSRCXCONF_BPP_SHIFT;\n\t\tval |= MCDE_EXTSRCXCONF_BGR;\n\t\tbreak;\n\tcase DRM_FORMAT_RGB565:\n\t\tval |= MCDE_EXTSRCXCONF_BPP_RGB565 <<\n\t\t\tMCDE_EXTSRCXCONF_BPP_SHIFT;\n\t\tbreak;\n\tcase DRM_FORMAT_BGR565:\n\t\tval |= MCDE_EXTSRCXCONF_BPP_RGB565 <<\n\t\t\tMCDE_EXTSRCXCONF_BPP_SHIFT;\n\t\tval |= MCDE_EXTSRCXCONF_BGR;\n\t\tbreak;\n\tcase DRM_FORMAT_YUV422:\n\t\tval |= MCDE_EXTSRCXCONF_BPP_YCBCR422 <<\n\t\t\tMCDE_EXTSRCXCONF_BPP_SHIFT;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(mcde->dev, \"Unknown pixel format 0x%08x\\n\",\n\t\t\tformat);\n\t\treturn -EINVAL;\n\t}\n\twritel(val, mcde->regs + conf);\n\n\t \n\tval = MCDE_EXTSRCXCR_SEL_MOD_SOFTWARE_SEL;\n\tval |= MCDE_EXTSRCXCR_MULTIOVL_CTRL_PRIMARY;\n\twritel(val, mcde->regs + cr);\n\n\treturn 0;\n}\n\nstatic void mcde_configure_overlay(struct mcde *mcde, enum mcde_overlay ovl,\n\t\t\t\t   enum mcde_extsrc src,\n\t\t\t\t   enum mcde_channel ch,\n\t\t\t\t   const struct drm_display_mode *mode,\n\t\t\t\t   u32 format, int cpp)\n{\n\tu32 val;\n\tu32 conf1;\n\tu32 conf2;\n\tu32 crop;\n\tu32 ljinc;\n\tu32 cr;\n\tu32 comp;\n\tu32 pixel_fetcher_watermark;\n\n\tswitch (ovl) {\n\tcase MCDE_OVERLAY_0:\n\t\tconf1 = MCDE_OVL0CONF;\n\t\tconf2 = MCDE_OVL0CONF2;\n\t\tcrop = MCDE_OVL0CROP;\n\t\tljinc = MCDE_OVL0LJINC;\n\t\tcr = MCDE_OVL0CR;\n\t\tcomp = MCDE_OVL0COMP;\n\t\tbreak;\n\tcase MCDE_OVERLAY_1:\n\t\tconf1 = MCDE_OVL1CONF;\n\t\tconf2 = MCDE_OVL1CONF2;\n\t\tcrop = MCDE_OVL1CROP;\n\t\tljinc = MCDE_OVL1LJINC;\n\t\tcr = MCDE_OVL1CR;\n\t\tcomp = MCDE_OVL1COMP;\n\t\tbreak;\n\tcase MCDE_OVERLAY_2:\n\t\tconf1 = MCDE_OVL2CONF;\n\t\tconf2 = MCDE_OVL2CONF2;\n\t\tcrop = MCDE_OVL2CROP;\n\t\tljinc = MCDE_OVL2LJINC;\n\t\tcr = MCDE_OVL2CR;\n\t\tcomp = MCDE_OVL2COMP;\n\t\tbreak;\n\tcase MCDE_OVERLAY_3:\n\t\tconf1 = MCDE_OVL3CONF;\n\t\tconf2 = MCDE_OVL3CONF2;\n\t\tcrop = MCDE_OVL3CROP;\n\t\tljinc = MCDE_OVL3LJINC;\n\t\tcr = MCDE_OVL3CR;\n\t\tcomp = MCDE_OVL3COMP;\n\t\tbreak;\n\tcase MCDE_OVERLAY_4:\n\t\tconf1 = MCDE_OVL4CONF;\n\t\tconf2 = MCDE_OVL4CONF2;\n\t\tcrop = MCDE_OVL4CROP;\n\t\tljinc = MCDE_OVL4LJINC;\n\t\tcr = MCDE_OVL4CR;\n\t\tcomp = MCDE_OVL4COMP;\n\t\tbreak;\n\tcase MCDE_OVERLAY_5:\n\t\tconf1 = MCDE_OVL5CONF;\n\t\tconf2 = MCDE_OVL5CONF2;\n\t\tcrop = MCDE_OVL5CROP;\n\t\tljinc = MCDE_OVL5LJINC;\n\t\tcr = MCDE_OVL5CR;\n\t\tcomp = MCDE_OVL5COMP;\n\t\tbreak;\n\t}\n\n\tval = mode->hdisplay << MCDE_OVLXCONF_PPL_SHIFT;\n\tval |= mode->vdisplay << MCDE_OVLXCONF_LPF_SHIFT;\n\t \n\tval |= src << MCDE_OVLXCONF_EXTSRC_ID_SHIFT;\n\twritel(val, mcde->regs + conf1);\n\n\tval = MCDE_OVLXCONF2_BP_PER_PIXEL_ALPHA;\n\tval |= 0xff << MCDE_OVLXCONF2_ALPHAVALUE_SHIFT;\n\t \n\tswitch (format) {\n\tcase DRM_FORMAT_ARGB8888:\n\tcase DRM_FORMAT_ABGR8888:\n\tcase DRM_FORMAT_ARGB4444:\n\tcase DRM_FORMAT_ABGR4444:\n\tcase DRM_FORMAT_XRGB1555:\n\tcase DRM_FORMAT_XBGR1555:\n\t\t \n\t\tbreak;\n\tcase DRM_FORMAT_XRGB8888:\n\tcase DRM_FORMAT_XBGR8888:\n\tcase DRM_FORMAT_RGB888:\n\tcase DRM_FORMAT_BGR888:\n\tcase DRM_FORMAT_RGB565:\n\tcase DRM_FORMAT_BGR565:\n\tcase DRM_FORMAT_YUV422:\n\t\tval |= MCDE_OVLXCONF2_OPQ;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(mcde->dev, \"Unknown pixel format 0x%08x\\n\",\n\t\t\tformat);\n\t\tbreak;\n\t}\n\n\t \n\tswitch (cpp) {\n\tcase 2:\n\t\tpixel_fetcher_watermark = 128;\n\t\tbreak;\n\tcase 3:\n\t\tpixel_fetcher_watermark = 96;\n\t\tbreak;\n\tcase 4:\n\t\tpixel_fetcher_watermark = 48;\n\t\tbreak;\n\tdefault:\n\t\tpixel_fetcher_watermark = 48;\n\t\tbreak;\n\t}\n\tdev_dbg(mcde->dev, \"pixel fetcher watermark level %d pixels\\n\",\n\t\tpixel_fetcher_watermark);\n\tval |= pixel_fetcher_watermark << MCDE_OVLXCONF2_PIXELFETCHERWATERMARKLEVEL_SHIFT;\n\twritel(val, mcde->regs + conf2);\n\n\t \n\twritel(mcde->stride, mcde->regs + ljinc);\n\t \n\twritel(0, mcde->regs + crop);\n\n\t \n\tval = MCDE_OVLXCR_OVLEN;\n\tval |= MCDE_OVLXCR_COLCCTRL_DISABLED;\n\tval |= MCDE_OVLXCR_BURSTSIZE_8W <<\n\t\tMCDE_OVLXCR_BURSTSIZE_SHIFT;\n\tval |= MCDE_OVLXCR_MAXOUTSTANDING_8_REQ <<\n\t\tMCDE_OVLXCR_MAXOUTSTANDING_SHIFT;\n\t \n\tval |= MCDE_OVLXCR_ROTBURSTSIZE_8W <<\n\t\tMCDE_OVLXCR_ROTBURSTSIZE_SHIFT;\n\twritel(val, mcde->regs + cr);\n\n\t \n\tval = ch << MCDE_OVLXCOMP_CH_ID_SHIFT;\n\twritel(val, mcde->regs + comp);\n}\n\nstatic void mcde_configure_channel(struct mcde *mcde, enum mcde_channel ch,\n\t\t\t\t   enum mcde_fifo fifo,\n\t\t\t\t   const struct drm_display_mode *mode)\n{\n\tu32 val;\n\tu32 conf;\n\tu32 sync;\n\tu32 stat;\n\tu32 bgcol;\n\tu32 mux;\n\n\tswitch (ch) {\n\tcase MCDE_CHANNEL_0:\n\t\tconf = MCDE_CHNL0CONF;\n\t\tsync = MCDE_CHNL0SYNCHMOD;\n\t\tstat = MCDE_CHNL0STAT;\n\t\tbgcol = MCDE_CHNL0BCKGNDCOL;\n\t\tmux = MCDE_CHNL0MUXING;\n\t\tbreak;\n\tcase MCDE_CHANNEL_1:\n\t\tconf = MCDE_CHNL1CONF;\n\t\tsync = MCDE_CHNL1SYNCHMOD;\n\t\tstat = MCDE_CHNL1STAT;\n\t\tbgcol = MCDE_CHNL1BCKGNDCOL;\n\t\tmux = MCDE_CHNL1MUXING;\n\t\tbreak;\n\tcase MCDE_CHANNEL_2:\n\t\tconf = MCDE_CHNL2CONF;\n\t\tsync = MCDE_CHNL2SYNCHMOD;\n\t\tstat = MCDE_CHNL2STAT;\n\t\tbgcol = MCDE_CHNL2BCKGNDCOL;\n\t\tmux = MCDE_CHNL2MUXING;\n\t\tbreak;\n\tcase MCDE_CHANNEL_3:\n\t\tconf = MCDE_CHNL3CONF;\n\t\tsync = MCDE_CHNL3SYNCHMOD;\n\t\tstat = MCDE_CHNL3STAT;\n\t\tbgcol = MCDE_CHNL3BCKGNDCOL;\n\t\tmux = MCDE_CHNL3MUXING;\n\t\treturn;\n\t}\n\n\t \n\tswitch (mcde->flow_mode) {\n\tcase MCDE_COMMAND_ONESHOT_FLOW:\n\t\t \n\t\tval = MCDE_CHNLXSYNCHMOD_SRC_SYNCH_SOFTWARE\n\t\t\t<< MCDE_CHNLXSYNCHMOD_SRC_SYNCH_SHIFT;\n\t\tbreak;\n\tcase MCDE_COMMAND_TE_FLOW:\n\t\tval = MCDE_CHNLXSYNCHMOD_SRC_SYNCH_HARDWARE\n\t\t\t<< MCDE_CHNLXSYNCHMOD_SRC_SYNCH_SHIFT;\n\t\tval |= MCDE_CHNLXSYNCHMOD_OUT_SYNCH_SRC_TE0\n\t\t\t<< MCDE_CHNLXSYNCHMOD_OUT_SYNCH_SRC_SHIFT;\n\t\tbreak;\n\tcase MCDE_COMMAND_BTA_TE_FLOW:\n\t\tval = MCDE_CHNLXSYNCHMOD_SRC_SYNCH_HARDWARE\n\t\t\t<< MCDE_CHNLXSYNCHMOD_SRC_SYNCH_SHIFT;\n\t\t \n\t\tval |= MCDE_CHNLXSYNCHMOD_OUT_SYNCH_SRC_FORMATTER\n\t\t\t<< MCDE_CHNLXSYNCHMOD_OUT_SYNCH_SRC_SHIFT;\n\t\tbreak;\n\tcase MCDE_VIDEO_TE_FLOW:\n\t\tval = MCDE_CHNLXSYNCHMOD_SRC_SYNCH_HARDWARE\n\t\t\t<< MCDE_CHNLXSYNCHMOD_SRC_SYNCH_SHIFT;\n\t\tval |= MCDE_CHNLXSYNCHMOD_OUT_SYNCH_SRC_TE0\n\t\t\t<< MCDE_CHNLXSYNCHMOD_OUT_SYNCH_SRC_SHIFT;\n\t\tbreak;\n\tcase MCDE_VIDEO_FORMATTER_FLOW:\n\tcase MCDE_DPI_FORMATTER_FLOW:\n\t\tval = MCDE_CHNLXSYNCHMOD_SRC_SYNCH_HARDWARE\n\t\t\t<< MCDE_CHNLXSYNCHMOD_SRC_SYNCH_SHIFT;\n\t\tval |= MCDE_CHNLXSYNCHMOD_OUT_SYNCH_SRC_FORMATTER\n\t\t\t<< MCDE_CHNLXSYNCHMOD_OUT_SYNCH_SRC_SHIFT;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(mcde->dev, \"unknown flow mode %d\\n\",\n\t\t\tmcde->flow_mode);\n\t\treturn;\n\t}\n\n\twritel(val, mcde->regs + sync);\n\n\t \n\tval = (mode->hdisplay - 1) << MCDE_CHNLXCONF_PPL_SHIFT;\n\tval |= (mode->vdisplay - 1) << MCDE_CHNLXCONF_LPF_SHIFT;\n\twritel(val, mcde->regs + conf);\n\n\t \n\tval = MCDE_CHNLXSTAT_CHNLBLBCKGND_EN |\n\t\tMCDE_CHNLXSTAT_CHNLRD;\n\twritel(val, mcde->regs + stat);\n\twritel(0, mcde->regs + bgcol);\n\n\t \n\tswitch (fifo) {\n\tcase MCDE_FIFO_A:\n\t\twritel(MCDE_CHNLXMUXING_FIFO_ID_FIFO_A,\n\t\t       mcde->regs + mux);\n\t\tbreak;\n\tcase MCDE_FIFO_B:\n\t\twritel(MCDE_CHNLXMUXING_FIFO_ID_FIFO_B,\n\t\t       mcde->regs + mux);\n\t\tbreak;\n\t}\n\n\t \n\tif (mcde->dpi_output) {\n\t\tu32 stripwidth;\n\n\t\tstripwidth = 0xF000 / (mode->vdisplay * 4);\n\t\tdev_info(mcde->dev, \"stripwidth: %d\\n\", stripwidth);\n\n\t\tval = MCDE_SYNCHCONF_HWREQVEVENT_ACTIVE_VIDEO |\n\t\t\t(mode->hdisplay - 1 - stripwidth) << MCDE_SYNCHCONF_HWREQVCNT_SHIFT |\n\t\t\tMCDE_SYNCHCONF_SWINTVEVENT_ACTIVE_VIDEO |\n\t\t\t(mode->hdisplay - 1 - stripwidth) << MCDE_SYNCHCONF_SWINTVCNT_SHIFT;\n\n\t\tswitch (fifo) {\n\t\tcase MCDE_FIFO_A:\n\t\t\twritel(val, mcde->regs + MCDE_SYNCHCONFA);\n\t\t\tbreak;\n\t\tcase MCDE_FIFO_B:\n\t\t\twritel(val, mcde->regs + MCDE_SYNCHCONFB);\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\nstatic void mcde_configure_fifo(struct mcde *mcde, enum mcde_fifo fifo,\n\t\t\t\tenum mcde_formatter fmt,\n\t\t\t\tint fifo_wtrmrk)\n{\n\tu32 val;\n\tu32 ctrl;\n\tu32 cr0, cr1;\n\n\tswitch (fifo) {\n\tcase MCDE_FIFO_A:\n\t\tctrl = MCDE_CTRLA;\n\t\tcr0 = MCDE_CRA0;\n\t\tcr1 = MCDE_CRA1;\n\t\tbreak;\n\tcase MCDE_FIFO_B:\n\t\tctrl = MCDE_CTRLB;\n\t\tcr0 = MCDE_CRB0;\n\t\tcr1 = MCDE_CRB1;\n\t\tbreak;\n\t}\n\n\tval = fifo_wtrmrk << MCDE_CTRLX_FIFOWTRMRK_SHIFT;\n\n\t \n\tswitch (fmt) {\n\tcase MCDE_DSI_FORMATTER_0:\n\t\tval |= MCDE_CTRLX_FORMTYPE_DSI << MCDE_CTRLX_FORMTYPE_SHIFT;\n\t\tval |= MCDE_CTRLX_FORMID_DSI0VID << MCDE_CTRLX_FORMID_SHIFT;\n\t\tbreak;\n\tcase MCDE_DSI_FORMATTER_1:\n\t\tval |= MCDE_CTRLX_FORMTYPE_DSI << MCDE_CTRLX_FORMTYPE_SHIFT;\n\t\tval |= MCDE_CTRLX_FORMID_DSI0CMD << MCDE_CTRLX_FORMID_SHIFT;\n\t\tbreak;\n\tcase MCDE_DSI_FORMATTER_2:\n\t\tval |= MCDE_CTRLX_FORMTYPE_DSI << MCDE_CTRLX_FORMTYPE_SHIFT;\n\t\tval |= MCDE_CTRLX_FORMID_DSI1VID << MCDE_CTRLX_FORMID_SHIFT;\n\t\tbreak;\n\tcase MCDE_DSI_FORMATTER_3:\n\t\tval |= MCDE_CTRLX_FORMTYPE_DSI << MCDE_CTRLX_FORMTYPE_SHIFT;\n\t\tval |= MCDE_CTRLX_FORMID_DSI1CMD << MCDE_CTRLX_FORMID_SHIFT;\n\t\tbreak;\n\tcase MCDE_DSI_FORMATTER_4:\n\t\tval |= MCDE_CTRLX_FORMTYPE_DSI << MCDE_CTRLX_FORMTYPE_SHIFT;\n\t\tval |= MCDE_CTRLX_FORMID_DSI2VID << MCDE_CTRLX_FORMID_SHIFT;\n\t\tbreak;\n\tcase MCDE_DSI_FORMATTER_5:\n\t\tval |= MCDE_CTRLX_FORMTYPE_DSI << MCDE_CTRLX_FORMTYPE_SHIFT;\n\t\tval |= MCDE_CTRLX_FORMID_DSI2CMD << MCDE_CTRLX_FORMID_SHIFT;\n\t\tbreak;\n\tcase MCDE_DPI_FORMATTER_0:\n\t\tval |= MCDE_CTRLX_FORMTYPE_DPITV << MCDE_CTRLX_FORMTYPE_SHIFT;\n\t\tval |= MCDE_CTRLX_FORMID_DPIA << MCDE_CTRLX_FORMID_SHIFT;\n\t\tbreak;\n\tcase MCDE_DPI_FORMATTER_1:\n\t\tval |= MCDE_CTRLX_FORMTYPE_DPITV << MCDE_CTRLX_FORMTYPE_SHIFT;\n\t\tval |= MCDE_CTRLX_FORMID_DPIB << MCDE_CTRLX_FORMID_SHIFT;\n\t\tbreak;\n\t}\n\twritel(val, mcde->regs + ctrl);\n\n\t \n\tval = MCDE_CRX0_BLENDEN |\n\t\t0xff << MCDE_CRX0_ALPHABLEND_SHIFT;\n\twritel(val, mcde->regs + cr0);\n\n\tspin_lock(&mcde->fifo_crx1_lock);\n\tval = readl(mcde->regs + cr1);\n\t \n\tif (mcde->dpi_output) {\n\t\tstruct drm_connector *connector = drm_panel_bridge_connector(mcde->bridge);\n\t\tu32 bus_format;\n\n\t\t \n\t\tif (!connector->display_info.num_bus_formats) {\n\t\t\tdev_info(mcde->dev, \"panel does not specify bus format, assume RGB888\\n\");\n\t\t\tbus_format = MEDIA_BUS_FMT_RGB888_1X24;\n\t\t} else {\n\t\t\tbus_format = connector->display_info.bus_formats[0];\n\t\t}\n\n\t\t \n\t\tval &= ~MCDE_CRX1_CDWIN_MASK;\n\t\tval &= ~MCDE_CRX1_OUTBPP_MASK;\n\t\tswitch (bus_format) {\n\t\tcase MEDIA_BUS_FMT_RGB888_1X24:\n\t\t\tval |= MCDE_CRX1_CDWIN_24BPP << MCDE_CRX1_CDWIN_SHIFT;\n\t\t\tval |= MCDE_CRX1_OUTBPP_24BPP << MCDE_CRX1_OUTBPP_SHIFT;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdev_err(mcde->dev, \"unknown bus format, assume RGB888\\n\");\n\t\t\tval |= MCDE_CRX1_CDWIN_24BPP << MCDE_CRX1_CDWIN_SHIFT;\n\t\t\tval |= MCDE_CRX1_OUTBPP_24BPP << MCDE_CRX1_OUTBPP_SHIFT;\n\t\t\tbreak;\n\t\t}\n\t} else {\n\t\t \n\t\tval &= ~MCDE_CRX1_CLKSEL_MASK;\n\t\tval |= MCDE_CRX1_CLKSEL_MCDECLK << MCDE_CRX1_CLKSEL_SHIFT;\n\t}\n\twritel(val, mcde->regs + cr1);\n\tspin_unlock(&mcde->fifo_crx1_lock);\n};\n\nstatic void mcde_configure_dsi_formatter(struct mcde *mcde,\n\t\t\t\t\t enum mcde_formatter fmt,\n\t\t\t\t\t u32 formatter_frame,\n\t\t\t\t\t int pkt_size)\n{\n\tu32 val;\n\tu32 conf0;\n\tu32 frame;\n\tu32 pkt;\n\tu32 sync;\n\tu32 cmdw;\n\tu32 delay0, delay1;\n\n\tswitch (fmt) {\n\tcase MCDE_DSI_FORMATTER_0:\n\t\tconf0 = MCDE_DSIVID0CONF0;\n\t\tframe = MCDE_DSIVID0FRAME;\n\t\tpkt = MCDE_DSIVID0PKT;\n\t\tsync = MCDE_DSIVID0SYNC;\n\t\tcmdw = MCDE_DSIVID0CMDW;\n\t\tdelay0 = MCDE_DSIVID0DELAY0;\n\t\tdelay1 = MCDE_DSIVID0DELAY1;\n\t\tbreak;\n\tcase MCDE_DSI_FORMATTER_1:\n\t\tconf0 = MCDE_DSIVID1CONF0;\n\t\tframe = MCDE_DSIVID1FRAME;\n\t\tpkt = MCDE_DSIVID1PKT;\n\t\tsync = MCDE_DSIVID1SYNC;\n\t\tcmdw = MCDE_DSIVID1CMDW;\n\t\tdelay0 = MCDE_DSIVID1DELAY0;\n\t\tdelay1 = MCDE_DSIVID1DELAY1;\n\t\tbreak;\n\tcase MCDE_DSI_FORMATTER_2:\n\t\tconf0 = MCDE_DSIVID2CONF0;\n\t\tframe = MCDE_DSIVID2FRAME;\n\t\tpkt = MCDE_DSIVID2PKT;\n\t\tsync = MCDE_DSIVID2SYNC;\n\t\tcmdw = MCDE_DSIVID2CMDW;\n\t\tdelay0 = MCDE_DSIVID2DELAY0;\n\t\tdelay1 = MCDE_DSIVID2DELAY1;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(mcde->dev, \"tried to configure a non-DSI formatter as DSI\\n\");\n\t\treturn;\n\t}\n\n\t \n\tval = MCDE_DSICONF0_CMD8 | MCDE_DSICONF0_DCSVID_NOTGEN;\n\tif (mcde->mdsi->mode_flags & MIPI_DSI_MODE_VIDEO)\n\t\tval |= MCDE_DSICONF0_VID_MODE_VID;\n\tswitch (mcde->mdsi->format) {\n\tcase MIPI_DSI_FMT_RGB888:\n\t\tval |= MCDE_DSICONF0_PACKING_RGB888 <<\n\t\t\tMCDE_DSICONF0_PACKING_SHIFT;\n\t\tbreak;\n\tcase MIPI_DSI_FMT_RGB666:\n\t\tval |= MCDE_DSICONF0_PACKING_RGB666 <<\n\t\t\tMCDE_DSICONF0_PACKING_SHIFT;\n\t\tbreak;\n\tcase MIPI_DSI_FMT_RGB666_PACKED:\n\t\tdev_err(mcde->dev,\n\t\t\t\"we cannot handle the packed RGB666 format\\n\");\n\t\tval |= MCDE_DSICONF0_PACKING_RGB666 <<\n\t\t\tMCDE_DSICONF0_PACKING_SHIFT;\n\t\tbreak;\n\tcase MIPI_DSI_FMT_RGB565:\n\t\tval |= MCDE_DSICONF0_PACKING_RGB565 <<\n\t\t\tMCDE_DSICONF0_PACKING_SHIFT;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(mcde->dev, \"unknown DSI format\\n\");\n\t\treturn;\n\t}\n\twritel(val, mcde->regs + conf0);\n\n\twritel(formatter_frame, mcde->regs + frame);\n\twritel(pkt_size, mcde->regs + pkt);\n\twritel(0, mcde->regs + sync);\n\t \n\tval = MIPI_DCS_WRITE_MEMORY_CONTINUE <<\n\t\tMCDE_DSIVIDXCMDW_CMDW_CONTINUE_SHIFT;\n\tval |= MIPI_DCS_WRITE_MEMORY_START <<\n\t\tMCDE_DSIVIDXCMDW_CMDW_START_SHIFT;\n\twritel(val, mcde->regs + cmdw);\n\n\t \n\twritel(0, mcde->regs + delay0);\n\twritel(0, mcde->regs + delay1);\n}\n\nstatic void mcde_enable_fifo(struct mcde *mcde, enum mcde_fifo fifo)\n{\n\tu32 val;\n\tu32 cr;\n\n\tswitch (fifo) {\n\tcase MCDE_FIFO_A:\n\t\tcr = MCDE_CRA0;\n\t\tbreak;\n\tcase MCDE_FIFO_B:\n\t\tcr = MCDE_CRB0;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(mcde->dev, \"cannot enable FIFO %c\\n\",\n\t\t\t'A' + fifo);\n\t\treturn;\n\t}\n\n\tspin_lock(&mcde->flow_lock);\n\tval = readl(mcde->regs + cr);\n\tval |= MCDE_CRX0_FLOEN;\n\twritel(val, mcde->regs + cr);\n\tmcde->flow_active++;\n\tspin_unlock(&mcde->flow_lock);\n}\n\nstatic void mcde_disable_fifo(struct mcde *mcde, enum mcde_fifo fifo,\n\t\t\t      bool wait_for_drain)\n{\n\tint timeout = 100;\n\tu32 val;\n\tu32 cr;\n\n\tswitch (fifo) {\n\tcase MCDE_FIFO_A:\n\t\tcr = MCDE_CRA0;\n\t\tbreak;\n\tcase MCDE_FIFO_B:\n\t\tcr = MCDE_CRB0;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(mcde->dev, \"cannot disable FIFO %c\\n\",\n\t\t\t'A' + fifo);\n\t\treturn;\n\t}\n\n\tspin_lock(&mcde->flow_lock);\n\tval = readl(mcde->regs + cr);\n\tval &= ~MCDE_CRX0_FLOEN;\n\twritel(val, mcde->regs + cr);\n\tmcde->flow_active = 0;\n\tspin_unlock(&mcde->flow_lock);\n\n\tif (!wait_for_drain)\n\t\treturn;\n\n\t \n\twhile (readl(mcde->regs + cr) & MCDE_CRX0_FLOEN) {\n\t\tusleep_range(1000, 1500);\n\t\tif (!--timeout) {\n\t\t\tdev_err(mcde->dev,\n\t\t\t\t\"FIFO timeout while clearing FIFO %c\\n\",\n\t\t\t\t'A' + fifo);\n\t\t\treturn;\n\t\t}\n\t}\n}\n\n \nstatic void mcde_drain_pipe(struct mcde *mcde, enum mcde_fifo fifo,\n\t\t\t    enum mcde_channel ch)\n{\n\tu32 val;\n\tu32 ctrl;\n\tu32 synsw;\n\n\tswitch (fifo) {\n\tcase MCDE_FIFO_A:\n\t\tctrl = MCDE_CTRLA;\n\t\tbreak;\n\tcase MCDE_FIFO_B:\n\t\tctrl = MCDE_CTRLB;\n\t\tbreak;\n\t}\n\n\tswitch (ch) {\n\tcase MCDE_CHANNEL_0:\n\t\tsynsw = MCDE_CHNL0SYNCHSW;\n\t\tbreak;\n\tcase MCDE_CHANNEL_1:\n\t\tsynsw = MCDE_CHNL1SYNCHSW;\n\t\tbreak;\n\tcase MCDE_CHANNEL_2:\n\t\tsynsw = MCDE_CHNL2SYNCHSW;\n\t\tbreak;\n\tcase MCDE_CHANNEL_3:\n\t\tsynsw = MCDE_CHNL3SYNCHSW;\n\t\treturn;\n\t}\n\n\tval = readl(mcde->regs + ctrl);\n\tif (!(val & MCDE_CTRLX_FIFOEMPTY)) {\n\t\tdev_err(mcde->dev, \"Channel A FIFO not empty (handover)\\n\");\n\t\t \n\t\tmcde_enable_fifo(mcde, fifo);\n\t\t \n\t\twritel(MCDE_CHNLXSYNCHSW_SW_TRIG, mcde->regs + synsw);\n\t\t \n\t\tmcde_disable_fifo(mcde, fifo, true);\n\t}\n}\n\nstatic int mcde_dsi_get_pkt_div(int ppl, int fifo_size)\n{\n\t \n\tint div;\n\tconst int max_div = DIV_ROUND_UP(MCDE_MAX_WIDTH, fifo_size);\n\n\tfor (div = 1; div < max_div; div++)\n\t\tif (ppl % div == 0 && ppl / div <= fifo_size)\n\t\t\treturn div;\n\treturn 1;\n}\n\nstatic void mcde_setup_dpi(struct mcde *mcde, const struct drm_display_mode *mode,\n\t\t\t   int *fifo_wtrmrk_lvl)\n{\n\tstruct drm_connector *connector = drm_panel_bridge_connector(mcde->bridge);\n\tu32 hsw, hfp, hbp;\n\tu32 vsw, vfp, vbp;\n\tu32 val;\n\n\t \n\thsw = mode->hsync_end - mode->hsync_start;\n\thfp = mode->hsync_start - mode->hdisplay;\n\thbp = mode->htotal - mode->hsync_end;\n\tvsw = mode->vsync_end - mode->vsync_start;\n\tvfp = mode->vsync_start - mode->vdisplay;\n\tvbp = mode->vtotal - mode->vsync_end;\n\n\tdev_info(mcde->dev, \"output on DPI LCD from channel A\\n\");\n\t \n\tdev_info(mcde->dev, \"HSW: %d, HFP: %d, HBP: %d, VSW: %d, VFP: %d, VBP: %d\\n\",\n\t\t hsw, hfp, hbp, vsw, vfp, vbp);\n\n\t \n\t*fifo_wtrmrk_lvl = 640;\n\n\t \n\tval = 7 << MCDE_CONF0_IFIFOCTRLWTRMRKLVL_SHIFT;\n\n\t \n\t \n\tval |= 0 << MCDE_CONF0_OUTMUX0_SHIFT;\n\t \n\tval |= 1 << MCDE_CONF0_OUTMUX1_SHIFT;\n\t \n\tval |= 0 << MCDE_CONF0_OUTMUX2_SHIFT;\n\t \n\tval |= 0 << MCDE_CONF0_OUTMUX3_SHIFT;\n\t \n\tval |= 2 << MCDE_CONF0_OUTMUX4_SHIFT;\n\t \n\twritel(val, mcde->regs + MCDE_CONF0);\n\n\t \n\twritel(0, mcde->regs + MCDE_TVCRA);\n\n\t \n\tval = (vsw << MCDE_TVBL1_BEL1_SHIFT);\n\tval |= (vfp << MCDE_TVBL1_BSL1_SHIFT);\n\twritel(val, mcde->regs + MCDE_TVBL1A);\n\t \n\twritel(val, mcde->regs + MCDE_TVBL2A);\n\n\t \n\tval = (vbp << MCDE_TVDVO_DVO1_SHIFT);\n\t \n\tval |= (vbp << MCDE_TVDVO_DVO2_SHIFT);\n\twritel(val, mcde->regs + MCDE_TVDVOA);\n\n\t \n\twritel((hbp - 1), mcde->regs + MCDE_TVTIM1A);\n\n\t \n\tval = ((hsw - 1) << MCDE_TVLBALW_LBW_SHIFT);\n\tval |= ((hfp - 1) << MCDE_TVLBALW_ALW_SHIFT);\n\twritel(val, mcde->regs + MCDE_TVLBALWA);\n\n\t \n\twritel(0, mcde->regs + MCDE_TVISLA);\n\twritel(0, mcde->regs + MCDE_TVBLUA);\n\n\t \n\tval = 0;\n\tif (mode->flags & DRM_MODE_FLAG_NHSYNC)\n\t\tval |= MCDE_LCDTIM1B_IHS;\n\tif (mode->flags & DRM_MODE_FLAG_NVSYNC)\n\t\tval |= MCDE_LCDTIM1B_IVS;\n\tif (connector->display_info.bus_flags & DRM_BUS_FLAG_DE_LOW)\n\t\tval |= MCDE_LCDTIM1B_IOE;\n\tif (connector->display_info.bus_flags & DRM_BUS_FLAG_PIXDATA_DRIVE_NEGEDGE)\n\t\tval |= MCDE_LCDTIM1B_IPC;\n\twritel(val, mcde->regs + MCDE_LCDTIM1A);\n}\n\nstatic void mcde_setup_dsi(struct mcde *mcde, const struct drm_display_mode *mode,\n\t\t\t   int cpp, int *fifo_wtrmrk_lvl, int *dsi_formatter_frame,\n\t\t\t   int *dsi_pkt_size)\n{\n\tu32 formatter_ppl = mode->hdisplay;  \n\tu32 formatter_lpf = mode->vdisplay;  \n\tint formatter_frame;\n\tint formatter_cpp;\n\tint fifo_wtrmrk;\n\tu32 pkt_div;\n\tint pkt_size;\n\tu32 val;\n\n\tdev_info(mcde->dev, \"output in %s mode, format %dbpp\\n\",\n\t\t (mcde->mdsi->mode_flags & MIPI_DSI_MODE_VIDEO) ?\n\t\t \"VIDEO\" : \"CMD\",\n\t\t mipi_dsi_pixel_format_to_bpp(mcde->mdsi->format));\n\tformatter_cpp =\n\t\tmipi_dsi_pixel_format_to_bpp(mcde->mdsi->format) / 8;\n\tdev_info(mcde->dev, \"Overlay CPP: %d bytes, DSI formatter CPP %d bytes\\n\",\n\t\t cpp, formatter_cpp);\n\n\t \n\tval = 7 << MCDE_CONF0_IFIFOCTRLWTRMRKLVL_SHIFT;\n\n\t \n\tval |= 3 << MCDE_CONF0_OUTMUX0_SHIFT;\n\tval |= 3 << MCDE_CONF0_OUTMUX1_SHIFT;\n\tval |= 0 << MCDE_CONF0_OUTMUX2_SHIFT;\n\tval |= 4 << MCDE_CONF0_OUTMUX3_SHIFT;\n\tval |= 5 << MCDE_CONF0_OUTMUX4_SHIFT;\n\twritel(val, mcde->regs + MCDE_CONF0);\n\n\t \n\n\t \n\tfifo_wtrmrk = mode->hdisplay;\n\tif (mcde->mdsi->mode_flags & MIPI_DSI_MODE_VIDEO) {\n\t\tfifo_wtrmrk = min(fifo_wtrmrk, 128);\n\t\tpkt_div = 1;\n\t} else {\n\t\tfifo_wtrmrk = min(fifo_wtrmrk, 48);\n\t\t \n\t\tpkt_div = mcde_dsi_get_pkt_div(mode->hdisplay, 640);\n\t}\n\tdev_dbg(mcde->dev, \"FIFO watermark after flooring: %d bytes\\n\",\n\t\tfifo_wtrmrk);\n\tdev_dbg(mcde->dev, \"Packet divisor: %d bytes\\n\", pkt_div);\n\n\t \n\tpkt_size = (formatter_ppl * formatter_cpp) / pkt_div;\n\t \n\tif (!(mcde->mdsi->mode_flags & MIPI_DSI_MODE_VIDEO))\n\t\tpkt_size++;\n\n\tdev_dbg(mcde->dev, \"DSI packet size: %d * %d bytes per line\\n\",\n\t\tpkt_size, pkt_div);\n\tdev_dbg(mcde->dev, \"Overlay frame size: %u bytes\\n\",\n\t\tmode->hdisplay * mode->vdisplay * cpp);\n\t \n\tformatter_frame = pkt_size * pkt_div * formatter_lpf;\n\tdev_dbg(mcde->dev, \"Formatter frame size: %u bytes\\n\", formatter_frame);\n\n\t*fifo_wtrmrk_lvl = fifo_wtrmrk;\n\t*dsi_pkt_size = pkt_size;\n\t*dsi_formatter_frame = formatter_frame;\n}\n\nstatic void mcde_display_enable(struct drm_simple_display_pipe *pipe,\n\t\t\t\tstruct drm_crtc_state *cstate,\n\t\t\t\tstruct drm_plane_state *plane_state)\n{\n\tstruct drm_crtc *crtc = &pipe->crtc;\n\tstruct drm_plane *plane = &pipe->plane;\n\tstruct drm_device *drm = crtc->dev;\n\tstruct mcde *mcde = to_mcde(drm);\n\tconst struct drm_display_mode *mode = &cstate->mode;\n\tstruct drm_framebuffer *fb = plane->state->fb;\n\tu32 format = fb->format->format;\n\tint dsi_pkt_size;\n\tint fifo_wtrmrk;\n\tint cpp = fb->format->cpp[0];\n\tu32 dsi_formatter_frame;\n\tu32 val;\n\tint ret;\n\n\t \n\tret = regulator_enable(mcde->epod);\n\tif (ret) {\n\t\tdev_err(drm->dev, \"can't re-enable EPOD regulator\\n\");\n\t\treturn;\n\t}\n\n\tdev_info(drm->dev, \"enable MCDE, %d x %d format %p4cc\\n\",\n\t\t mode->hdisplay, mode->vdisplay, &format);\n\n\n\t \n\tmcde_display_disable_irqs(mcde);\n\twritel(0, mcde->regs + MCDE_IMSCERR);\n\twritel(0xFFFFFFFF, mcde->regs + MCDE_RISERR);\n\n\tif (mcde->dpi_output)\n\t\tmcde_setup_dpi(mcde, mode, &fifo_wtrmrk);\n\telse\n\t\tmcde_setup_dsi(mcde, mode, cpp, &fifo_wtrmrk,\n\t\t\t       &dsi_formatter_frame, &dsi_pkt_size);\n\n\tmcde->stride = mode->hdisplay * cpp;\n\tdev_dbg(drm->dev, \"Overlay line stride: %u bytes\\n\",\n\t\t mcde->stride);\n\n\t \n\tmcde_drain_pipe(mcde, MCDE_FIFO_A, MCDE_CHANNEL_0);\n\n\t \n\tmcde_configure_extsrc(mcde, MCDE_EXTSRC_0, format);\n\n\t \n\tmcde_configure_overlay(mcde, MCDE_OVERLAY_0, MCDE_EXTSRC_0,\n\t\t\t       MCDE_CHANNEL_0, mode, format, cpp);\n\n\t \n\tmcde_configure_channel(mcde, MCDE_CHANNEL_0, MCDE_FIFO_A, mode);\n\n\tif (mcde->dpi_output) {\n\t\tunsigned long lcd_freq;\n\n\t\t \n\t\tmcde_configure_fifo(mcde, MCDE_FIFO_A, MCDE_DPI_FORMATTER_0,\n\t\t\t\t    fifo_wtrmrk);\n\n\t\t \n\t\tlcd_freq = clk_round_rate(mcde->fifoa_clk, mode->clock * 1000);\n\t\tret = clk_set_rate(mcde->fifoa_clk, lcd_freq);\n\t\tif (ret)\n\t\t\tdev_err(mcde->dev, \"failed to set LCD clock rate %lu Hz\\n\",\n\t\t\t\tlcd_freq);\n\t\tret = clk_prepare_enable(mcde->fifoa_clk);\n\t\tif (ret) {\n\t\t\tdev_err(mcde->dev, \"failed to enable FIFO A DPI clock\\n\");\n\t\t\treturn;\n\t\t}\n\t\tdev_info(mcde->dev, \"LCD FIFO A clk rate %lu Hz\\n\",\n\t\t\t clk_get_rate(mcde->fifoa_clk));\n\t} else {\n\t\t \n\t\tmcde_configure_fifo(mcde, MCDE_FIFO_A, MCDE_DSI_FORMATTER_0,\n\t\t\t\t    fifo_wtrmrk);\n\n\t\t \n\t\tmcde_dsi_enable(mcde->bridge);\n\n\t\t \n\t\tmcde_configure_dsi_formatter(mcde, MCDE_DSI_FORMATTER_0,\n\t\t\t\t\t     dsi_formatter_frame, dsi_pkt_size);\n\t}\n\n\tswitch (mcde->flow_mode) {\n\tcase MCDE_COMMAND_TE_FLOW:\n\tcase MCDE_COMMAND_BTA_TE_FLOW:\n\tcase MCDE_VIDEO_TE_FLOW:\n\t\t \n\t\tif (mode->flags & DRM_MODE_FLAG_NVSYNC)\n\t\t\tval = MCDE_VSCRC_VSPOL;\n\t\telse\n\t\t\tval = 0;\n\t\twritel(val, mcde->regs + MCDE_VSCRC0);\n\t\t \n\t\tval = readl(mcde->regs + MCDE_CRC);\n\t\tval |= MCDE_CRC_SYCEN0;\n\t\twritel(val, mcde->regs + MCDE_CRC);\n\t\tbreak;\n\tdefault:\n\t\t \n\t\tbreak;\n\t}\n\n\tdrm_crtc_vblank_on(crtc);\n\n\t \n\tif (mcde->flow_mode != MCDE_COMMAND_ONESHOT_FLOW) {\n\t\tmcde_enable_fifo(mcde, MCDE_FIFO_A);\n\t\tdev_dbg(mcde->dev, \"started MCDE video FIFO flow\\n\");\n\t}\n\n\t \n\tval = readl(mcde->regs + MCDE_CR);\n\tval |= MCDE_CR_MCDEEN | MCDE_CR_AUTOCLKG_EN;\n\twritel(val, mcde->regs + MCDE_CR);\n\n\tdev_info(drm->dev, \"MCDE display is enabled\\n\");\n}\n\nstatic void mcde_display_disable(struct drm_simple_display_pipe *pipe)\n{\n\tstruct drm_crtc *crtc = &pipe->crtc;\n\tstruct drm_device *drm = crtc->dev;\n\tstruct mcde *mcde = to_mcde(drm);\n\tstruct drm_pending_vblank_event *event;\n\tint ret;\n\n\tdrm_crtc_vblank_off(crtc);\n\n\t \n\tmcde_disable_fifo(mcde, MCDE_FIFO_A, true);\n\n\tif (mcde->dpi_output) {\n\t\tclk_disable_unprepare(mcde->fifoa_clk);\n\t} else {\n\t\t \n\t\tmcde_dsi_disable(mcde->bridge);\n\t}\n\n\tevent = crtc->state->event;\n\tif (event) {\n\t\tcrtc->state->event = NULL;\n\n\t\tspin_lock_irq(&crtc->dev->event_lock);\n\t\tdrm_crtc_send_vblank_event(crtc, event);\n\t\tspin_unlock_irq(&crtc->dev->event_lock);\n\t}\n\n\tret = regulator_disable(mcde->epod);\n\tif (ret)\n\t\tdev_err(drm->dev, \"can't disable EPOD regulator\\n\");\n\t \n\tusleep_range(50000, 70000);\n\n\tdev_info(drm->dev, \"MCDE display is disabled\\n\");\n}\n\nstatic void mcde_start_flow(struct mcde *mcde)\n{\n\t \n\tif (mcde->flow_mode == MCDE_COMMAND_BTA_TE_FLOW)\n\t\tmcde_dsi_te_request(mcde->mdsi);\n\n\t \n\tmcde_enable_fifo(mcde, MCDE_FIFO_A);\n\n\t \n\n\tif (mcde->flow_mode == MCDE_COMMAND_ONESHOT_FLOW) {\n\t\t \n\t\twritel(MCDE_CHNLXSYNCHSW_SW_TRIG,\n\t\t       mcde->regs + MCDE_CHNL0SYNCHSW);\n\n\t\t \n\t\tmcde_disable_fifo(mcde, MCDE_FIFO_A, true);\n\t}\n\n\tdev_dbg(mcde->dev, \"started MCDE FIFO flow\\n\");\n}\n\nstatic void mcde_set_extsrc(struct mcde *mcde, u32 buffer_address)\n{\n\t \n\twritel(buffer_address, mcde->regs + MCDE_EXTSRCXA0);\n\t \n\twritel(buffer_address + mcde->stride, mcde->regs + MCDE_EXTSRCXA1);\n}\n\nstatic void mcde_display_update(struct drm_simple_display_pipe *pipe,\n\t\t\t\tstruct drm_plane_state *old_pstate)\n{\n\tstruct drm_crtc *crtc = &pipe->crtc;\n\tstruct drm_device *drm = crtc->dev;\n\tstruct mcde *mcde = to_mcde(drm);\n\tstruct drm_pending_vblank_event *event = crtc->state->event;\n\tstruct drm_plane *plane = &pipe->plane;\n\tstruct drm_plane_state *pstate = plane->state;\n\tstruct drm_framebuffer *fb = pstate->fb;\n\n\t \n\tif (event) {\n\t\tcrtc->state->event = NULL;\n\n\t\tspin_lock_irq(&crtc->dev->event_lock);\n\t\t \n\t\tif (crtc->state->active && drm_crtc_vblank_get(crtc) == 0) {\n\t\t\tdev_dbg(mcde->dev, \"arm vblank event\\n\");\n\t\t\tdrm_crtc_arm_vblank_event(crtc, event);\n\t\t} else {\n\t\t\tdev_dbg(mcde->dev, \"insert fake vblank event\\n\");\n\t\t\tdrm_crtc_send_vblank_event(crtc, event);\n\t\t}\n\n\t\tspin_unlock_irq(&crtc->dev->event_lock);\n\t}\n\n\t \n\tif (fb) {\n\t\tmcde_set_extsrc(mcde, drm_fb_dma_get_gem_addr(fb, pstate, 0));\n\t\tdev_info_once(mcde->dev, \"first update of display contents\\n\");\n\t\t \n\t\tif (mcde->flow_active == 0)\n\t\t\tmcde_start_flow(mcde);\n\t} else {\n\t\t \n\t\tdev_info(mcde->dev, \"ignored a display update\\n\");\n\t}\n}\n\nstatic int mcde_display_enable_vblank(struct drm_simple_display_pipe *pipe)\n{\n\tstruct drm_crtc *crtc = &pipe->crtc;\n\tstruct drm_device *drm = crtc->dev;\n\tstruct mcde *mcde = to_mcde(drm);\n\tu32 val;\n\n\t \n\tval = MCDE_PP_VCMPA |\n\t\tMCDE_PP_VCMPB |\n\t\tMCDE_PP_VSCC0 |\n\t\tMCDE_PP_VSCC1 |\n\t\tMCDE_PP_VCMPC0 |\n\t\tMCDE_PP_VCMPC1;\n\twritel(val, mcde->regs + MCDE_IMSCPP);\n\n\treturn 0;\n}\n\nstatic void mcde_display_disable_vblank(struct drm_simple_display_pipe *pipe)\n{\n\tstruct drm_crtc *crtc = &pipe->crtc;\n\tstruct drm_device *drm = crtc->dev;\n\tstruct mcde *mcde = to_mcde(drm);\n\n\t \n\twritel(0, mcde->regs + MCDE_IMSCPP);\n\t \n\twritel(0xFFFFFFFF, mcde->regs + MCDE_RISPP);\n}\n\nstatic struct drm_simple_display_pipe_funcs mcde_display_funcs = {\n\t.check = mcde_display_check,\n\t.enable = mcde_display_enable,\n\t.disable = mcde_display_disable,\n\t.update = mcde_display_update,\n\t.enable_vblank = mcde_display_enable_vblank,\n\t.disable_vblank = mcde_display_disable_vblank,\n};\n\nint mcde_display_init(struct drm_device *drm)\n{\n\tstruct mcde *mcde = to_mcde(drm);\n\tint ret;\n\tstatic const u32 formats[] = {\n\t\tDRM_FORMAT_ARGB8888,\n\t\tDRM_FORMAT_ABGR8888,\n\t\tDRM_FORMAT_XRGB8888,\n\t\tDRM_FORMAT_XBGR8888,\n\t\tDRM_FORMAT_RGB888,\n\t\tDRM_FORMAT_BGR888,\n\t\tDRM_FORMAT_ARGB4444,\n\t\tDRM_FORMAT_ABGR4444,\n\t\tDRM_FORMAT_XRGB4444,\n\t\tDRM_FORMAT_XBGR4444,\n\t\t \n\t\tDRM_FORMAT_XRGB1555,\n\t\tDRM_FORMAT_XBGR1555,\n\t\tDRM_FORMAT_RGB565,\n\t\tDRM_FORMAT_BGR565,\n\t\tDRM_FORMAT_YUV422,\n\t};\n\n\tret = mcde_init_clock_divider(mcde);\n\tif (ret)\n\t\treturn ret;\n\n\tret = drm_simple_display_pipe_init(drm, &mcde->pipe,\n\t\t\t\t\t   &mcde_display_funcs,\n\t\t\t\t\t   formats, ARRAY_SIZE(formats),\n\t\t\t\t\t   NULL,\n\t\t\t\t\t   mcde->connector);\n\tif (ret)\n\t\treturn ret;\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(mcde_display_init);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}