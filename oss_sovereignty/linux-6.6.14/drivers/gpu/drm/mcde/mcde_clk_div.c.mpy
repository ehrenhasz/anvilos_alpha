{
  "module_name": "mcde_clk_div.c",
  "hash_id": "c6cbb487c1b9a9e70d37c0d7d22e5a158b3374d29d7a227591b620a9a3cacb24",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/mcde/mcde_clk_div.c",
  "human_readable_source": "\n#include <linux/clk-provider.h>\n#include <linux/io.h>\n#include <linux/regulator/consumer.h>\n\n#include \"mcde_drm.h\"\n#include \"mcde_display_regs.h\"\n\n \nstruct mcde_clk_div {\n\tstruct clk_hw hw;\n\tstruct mcde *mcde;\n\tu32 cr;\n\tu32 cr_div;\n};\n\nstatic int mcde_clk_div_enable(struct clk_hw *hw)\n{\n\tstruct mcde_clk_div *cdiv = container_of(hw, struct mcde_clk_div, hw);\n\tstruct mcde *mcde = cdiv->mcde;\n\tu32 val;\n\n\tspin_lock(&mcde->fifo_crx1_lock);\n\tval = readl(mcde->regs + cdiv->cr);\n\t \n\tval &= ~MCDE_CRX1_CLKSEL_MASK;\n\tval |= MCDE_CRX1_CLKSEL_CLKPLL72 << MCDE_CRX1_CLKSEL_SHIFT;\n\t \n\tval |= MCDE_CRA1_CLKTYPE_TVXCLKSEL1;\n\n\t \n\tval &= ~(MCDE_CRX1_BCD | MCDE_CRX1_PCD_MASK);\n\tval |= cdiv->cr_div;\n\n\twritel(val, mcde->regs + cdiv->cr);\n\tspin_unlock(&mcde->fifo_crx1_lock);\n\n\treturn 0;\n}\n\nstatic int mcde_clk_div_choose_div(struct clk_hw *hw, unsigned long rate,\n\t\t\t\t   unsigned long *prate, bool set_parent)\n{\n\tint best_div = 1, div;\n\tstruct clk_hw *parent = clk_hw_get_parent(hw);\n\tunsigned long best_prate = 0;\n\tunsigned long best_diff = ~0ul;\n\tint max_div = (1 << MCDE_CRX1_PCD_BITS) - 1;\n\n\tfor (div = 1; div < max_div; div++) {\n\t\tunsigned long this_prate, div_rate, diff;\n\n\t\tif (set_parent)\n\t\t\tthis_prate = clk_hw_round_rate(parent, rate * div);\n\t\telse\n\t\t\tthis_prate = *prate;\n\t\tdiv_rate = DIV_ROUND_UP_ULL(this_prate, div);\n\t\tdiff = abs(rate - div_rate);\n\n\t\tif (diff < best_diff) {\n\t\t\tbest_div = div;\n\t\t\tbest_diff = diff;\n\t\t\tbest_prate = this_prate;\n\t\t}\n\t}\n\n\t*prate = best_prate;\n\treturn best_div;\n}\n\nstatic long mcde_clk_div_round_rate(struct clk_hw *hw, unsigned long rate,\n\t\t\t\t     unsigned long *prate)\n{\n\tint div = mcde_clk_div_choose_div(hw, rate, prate, true);\n\n\treturn DIV_ROUND_UP_ULL(*prate, div);\n}\n\nstatic unsigned long mcde_clk_div_recalc_rate(struct clk_hw *hw,\n\t\t\t\t\t       unsigned long prate)\n{\n\tstruct mcde_clk_div *cdiv = container_of(hw, struct mcde_clk_div, hw);\n\tstruct mcde *mcde = cdiv->mcde;\n\tu32 cr;\n\tint div;\n\n\t \n\tif (!regulator_is_enabled(mcde->epod))\n\t\treturn DIV_ROUND_UP_ULL(prate, 2);\n\n\tcr = readl(mcde->regs + cdiv->cr);\n\tif (cr & MCDE_CRX1_BCD)\n\t\treturn prate;\n\n\t \n\tdiv = cr & MCDE_CRX1_PCD_MASK;\n\tdiv += 2;\n\n\treturn DIV_ROUND_UP_ULL(prate, div);\n}\n\nstatic int mcde_clk_div_set_rate(struct clk_hw *hw, unsigned long rate,\n\t\t\t\t  unsigned long prate)\n{\n\tstruct mcde_clk_div *cdiv = container_of(hw, struct mcde_clk_div, hw);\n\tint div = mcde_clk_div_choose_div(hw, rate, &prate, false);\n\tu32 cr = 0;\n\n\t \n\tif (div == 1) {\n\t\t \n\t\tcr |= MCDE_CRX1_BCD;\n\t} else {\n\t\tdiv -= 2;\n\t\tcr |= div & MCDE_CRX1_PCD_MASK;\n\t}\n\tcdiv->cr_div = cr;\n\n\treturn 0;\n}\n\nstatic const struct clk_ops mcde_clk_div_ops = {\n\t.enable = mcde_clk_div_enable,\n\t.recalc_rate = mcde_clk_div_recalc_rate,\n\t.round_rate = mcde_clk_div_round_rate,\n\t.set_rate = mcde_clk_div_set_rate,\n};\n\nint mcde_init_clock_divider(struct mcde *mcde)\n{\n\tstruct device *dev = mcde->dev;\n\tstruct mcde_clk_div *fifoa;\n\tstruct mcde_clk_div *fifob;\n\tconst char *parent_name;\n\tstruct clk_init_data fifoa_init = {\n\t\t.name = \"fifoa\",\n\t\t.ops = &mcde_clk_div_ops,\n\t\t.parent_names = &parent_name,\n\t\t.num_parents = 1,\n\t\t.flags = CLK_SET_RATE_PARENT,\n\t};\n\tstruct clk_init_data fifob_init = {\n\t\t.name = \"fifob\",\n\t\t.ops = &mcde_clk_div_ops,\n\t\t.parent_names = &parent_name,\n\t\t.num_parents = 1,\n\t\t.flags = CLK_SET_RATE_PARENT,\n\t};\n\tint ret;\n\n\tspin_lock_init(&mcde->fifo_crx1_lock);\n\tparent_name = __clk_get_name(mcde->lcd_clk);\n\n\t \n\tfifoa = devm_kzalloc(dev, sizeof(*fifoa), GFP_KERNEL);\n\tif (!fifoa)\n\t\treturn -ENOMEM;\n\tfifob = devm_kzalloc(dev, sizeof(*fifob), GFP_KERNEL);\n\tif (!fifob)\n\t\treturn -ENOMEM;\n\n\tfifoa->mcde = mcde;\n\tfifoa->cr = MCDE_CRA1;\n\tfifoa->hw.init = &fifoa_init;\n\tret = devm_clk_hw_register(dev, &fifoa->hw);\n\tif (ret) {\n\t\tdev_err(dev, \"error registering FIFO A clock divider\\n\");\n\t\treturn ret;\n\t}\n\tmcde->fifoa_clk = fifoa->hw.clk;\n\n\tfifob->mcde = mcde;\n\tfifob->cr = MCDE_CRB1;\n\tfifob->hw.init = &fifob_init;\n\tret = devm_clk_hw_register(dev, &fifob->hw);\n\tif (ret) {\n\t\tdev_err(dev, \"error registering FIFO B clock divider\\n\");\n\t\treturn ret;\n\t}\n\tmcde->fifob_clk = fifob->hw.clk;\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}