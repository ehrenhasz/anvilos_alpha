{
  "module_name": "drm_atomic_uapi.c",
  "hash_id": "72f391ebfabcacbb7ae2f6a168c1f50f3e44095ca2c0baf61ee0afb55bfc94f8",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/drm_atomic_uapi.c",
  "human_readable_source": " \n\n#include <drm/drm_atomic_uapi.h>\n#include <drm/drm_atomic.h>\n#include <drm/drm_framebuffer.h>\n#include <drm/drm_print.h>\n#include <drm/drm_drv.h>\n#include <drm/drm_writeback.h>\n#include <drm/drm_vblank.h>\n\n#include <linux/dma-fence.h>\n#include <linux/uaccess.h>\n#include <linux/sync_file.h>\n#include <linux/file.h>\n\n#include \"drm_crtc_internal.h\"\n\n \n\n \nint drm_atomic_set_mode_for_crtc(struct drm_crtc_state *state,\n\t\t\t\t const struct drm_display_mode *mode)\n{\n\tstruct drm_crtc *crtc = state->crtc;\n\tstruct drm_mode_modeinfo umode;\n\n\t \n\tif (mode && memcmp(&state->mode, mode, sizeof(*mode)) == 0)\n\t\treturn 0;\n\n\tdrm_property_blob_put(state->mode_blob);\n\tstate->mode_blob = NULL;\n\n\tif (mode) {\n\t\tstruct drm_property_blob *blob;\n\n\t\tdrm_mode_convert_to_umode(&umode, mode);\n\t\tblob = drm_property_create_blob(crtc->dev,\n\t\t\t\t\t\tsizeof(umode), &umode);\n\t\tif (IS_ERR(blob))\n\t\t\treturn PTR_ERR(blob);\n\n\t\tdrm_mode_copy(&state->mode, mode);\n\n\t\tstate->mode_blob = blob;\n\t\tstate->enable = true;\n\t\tdrm_dbg_atomic(crtc->dev,\n\t\t\t       \"Set [MODE:%s] for [CRTC:%d:%s] state %p\\n\",\n\t\t\t       mode->name, crtc->base.id, crtc->name, state);\n\t} else {\n\t\tmemset(&state->mode, 0, sizeof(state->mode));\n\t\tstate->enable = false;\n\t\tdrm_dbg_atomic(crtc->dev,\n\t\t\t       \"Set [NOMODE] for [CRTC:%d:%s] state %p\\n\",\n\t\t\t       crtc->base.id, crtc->name, state);\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL(drm_atomic_set_mode_for_crtc);\n\n \nint drm_atomic_set_mode_prop_for_crtc(struct drm_crtc_state *state,\n\t\t\t\t      struct drm_property_blob *blob)\n{\n\tstruct drm_crtc *crtc = state->crtc;\n\n\tif (blob == state->mode_blob)\n\t\treturn 0;\n\n\tdrm_property_blob_put(state->mode_blob);\n\tstate->mode_blob = NULL;\n\n\tmemset(&state->mode, 0, sizeof(state->mode));\n\n\tif (blob) {\n\t\tint ret;\n\n\t\tif (blob->length != sizeof(struct drm_mode_modeinfo)) {\n\t\t\tdrm_dbg_atomic(crtc->dev,\n\t\t\t\t       \"[CRTC:%d:%s] bad mode blob length: %zu\\n\",\n\t\t\t\t       crtc->base.id, crtc->name,\n\t\t\t\t       blob->length);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tret = drm_mode_convert_umode(crtc->dev,\n\t\t\t\t\t     &state->mode, blob->data);\n\t\tif (ret) {\n\t\t\tdrm_dbg_atomic(crtc->dev,\n\t\t\t\t       \"[CRTC:%d:%s] invalid mode (ret=%d, status=%s):\\n\",\n\t\t\t\t       crtc->base.id, crtc->name,\n\t\t\t\t       ret, drm_get_mode_status_name(state->mode.status));\n\t\t\tdrm_mode_debug_printmodeline(&state->mode);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tstate->mode_blob = drm_property_blob_get(blob);\n\t\tstate->enable = true;\n\t\tdrm_dbg_atomic(crtc->dev,\n\t\t\t       \"Set [MODE:%s] for [CRTC:%d:%s] state %p\\n\",\n\t\t\t       state->mode.name, crtc->base.id, crtc->name,\n\t\t\t       state);\n\t} else {\n\t\tstate->enable = false;\n\t\tdrm_dbg_atomic(crtc->dev,\n\t\t\t       \"Set [NOMODE] for [CRTC:%d:%s] state %p\\n\",\n\t\t\t       crtc->base.id, crtc->name, state);\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL(drm_atomic_set_mode_prop_for_crtc);\n\n \nint\ndrm_atomic_set_crtc_for_plane(struct drm_plane_state *plane_state,\n\t\t\t      struct drm_crtc *crtc)\n{\n\tstruct drm_plane *plane = plane_state->plane;\n\tstruct drm_crtc_state *crtc_state;\n\t \n\tif (plane_state->crtc == crtc)\n\t\treturn 0;\n\tif (plane_state->crtc) {\n\t\tcrtc_state = drm_atomic_get_crtc_state(plane_state->state,\n\t\t\t\t\t\t       plane_state->crtc);\n\t\tif (WARN_ON(IS_ERR(crtc_state)))\n\t\t\treturn PTR_ERR(crtc_state);\n\n\t\tcrtc_state->plane_mask &= ~drm_plane_mask(plane);\n\t}\n\n\tplane_state->crtc = crtc;\n\n\tif (crtc) {\n\t\tcrtc_state = drm_atomic_get_crtc_state(plane_state->state,\n\t\t\t\t\t\t       crtc);\n\t\tif (IS_ERR(crtc_state))\n\t\t\treturn PTR_ERR(crtc_state);\n\t\tcrtc_state->plane_mask |= drm_plane_mask(plane);\n\t}\n\n\tif (crtc)\n\t\tdrm_dbg_atomic(plane->dev,\n\t\t\t       \"Link [PLANE:%d:%s] state %p to [CRTC:%d:%s]\\n\",\n\t\t\t       plane->base.id, plane->name, plane_state,\n\t\t\t       crtc->base.id, crtc->name);\n\telse\n\t\tdrm_dbg_atomic(plane->dev,\n\t\t\t       \"Link [PLANE:%d:%s] state %p to [NOCRTC]\\n\",\n\t\t\t       plane->base.id, plane->name, plane_state);\n\n\treturn 0;\n}\nEXPORT_SYMBOL(drm_atomic_set_crtc_for_plane);\n\n \nvoid\ndrm_atomic_set_fb_for_plane(struct drm_plane_state *plane_state,\n\t\t\t    struct drm_framebuffer *fb)\n{\n\tstruct drm_plane *plane = plane_state->plane;\n\n\tif (fb)\n\t\tdrm_dbg_atomic(plane->dev,\n\t\t\t       \"Set [FB:%d] for [PLANE:%d:%s] state %p\\n\",\n\t\t\t       fb->base.id, plane->base.id, plane->name,\n\t\t\t       plane_state);\n\telse\n\t\tdrm_dbg_atomic(plane->dev,\n\t\t\t       \"Set [NOFB] for [PLANE:%d:%s] state %p\\n\",\n\t\t\t       plane->base.id, plane->name, plane_state);\n\n\tdrm_framebuffer_assign(&plane_state->fb, fb);\n}\nEXPORT_SYMBOL(drm_atomic_set_fb_for_plane);\n\n \nint\ndrm_atomic_set_crtc_for_connector(struct drm_connector_state *conn_state,\n\t\t\t\t  struct drm_crtc *crtc)\n{\n\tstruct drm_connector *connector = conn_state->connector;\n\tstruct drm_crtc_state *crtc_state;\n\n\tif (conn_state->crtc == crtc)\n\t\treturn 0;\n\n\tif (conn_state->crtc) {\n\t\tcrtc_state = drm_atomic_get_new_crtc_state(conn_state->state,\n\t\t\t\t\t\t\t   conn_state->crtc);\n\n\t\tcrtc_state->connector_mask &=\n\t\t\t~drm_connector_mask(conn_state->connector);\n\n\t\tdrm_connector_put(conn_state->connector);\n\t\tconn_state->crtc = NULL;\n\t}\n\n\tif (crtc) {\n\t\tcrtc_state = drm_atomic_get_crtc_state(conn_state->state, crtc);\n\t\tif (IS_ERR(crtc_state))\n\t\t\treturn PTR_ERR(crtc_state);\n\n\t\tcrtc_state->connector_mask |=\n\t\t\tdrm_connector_mask(conn_state->connector);\n\n\t\tdrm_connector_get(conn_state->connector);\n\t\tconn_state->crtc = crtc;\n\n\t\tdrm_dbg_atomic(connector->dev,\n\t\t\t       \"Link [CONNECTOR:%d:%s] state %p to [CRTC:%d:%s]\\n\",\n\t\t\t       connector->base.id, connector->name,\n\t\t\t       conn_state, crtc->base.id, crtc->name);\n\t} else {\n\t\tdrm_dbg_atomic(connector->dev,\n\t\t\t       \"Link [CONNECTOR:%d:%s] state %p to [NOCRTC]\\n\",\n\t\t\t       connector->base.id, connector->name,\n\t\t\t       conn_state);\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL(drm_atomic_set_crtc_for_connector);\n\nstatic void set_out_fence_for_crtc(struct drm_atomic_state *state,\n\t\t\t\t   struct drm_crtc *crtc, s32 __user *fence_ptr)\n{\n\tstate->crtcs[drm_crtc_index(crtc)].out_fence_ptr = fence_ptr;\n}\n\nstatic s32 __user *get_out_fence_for_crtc(struct drm_atomic_state *state,\n\t\t\t\t\t  struct drm_crtc *crtc)\n{\n\ts32 __user *fence_ptr;\n\n\tfence_ptr = state->crtcs[drm_crtc_index(crtc)].out_fence_ptr;\n\tstate->crtcs[drm_crtc_index(crtc)].out_fence_ptr = NULL;\n\n\treturn fence_ptr;\n}\n\nstatic int set_out_fence_for_connector(struct drm_atomic_state *state,\n\t\t\t\t\tstruct drm_connector *connector,\n\t\t\t\t\ts32 __user *fence_ptr)\n{\n\tunsigned int index = drm_connector_index(connector);\n\n\tif (!fence_ptr)\n\t\treturn 0;\n\n\tif (put_user(-1, fence_ptr))\n\t\treturn -EFAULT;\n\n\tstate->connectors[index].out_fence_ptr = fence_ptr;\n\n\treturn 0;\n}\n\nstatic s32 __user *get_out_fence_for_connector(struct drm_atomic_state *state,\n\t\t\t\t\t       struct drm_connector *connector)\n{\n\tunsigned int index = drm_connector_index(connector);\n\ts32 __user *fence_ptr;\n\n\tfence_ptr = state->connectors[index].out_fence_ptr;\n\tstate->connectors[index].out_fence_ptr = NULL;\n\n\treturn fence_ptr;\n}\n\nstatic int\ndrm_atomic_replace_property_blob_from_id(struct drm_device *dev,\n\t\t\t\t\t struct drm_property_blob **blob,\n\t\t\t\t\t uint64_t blob_id,\n\t\t\t\t\t ssize_t expected_size,\n\t\t\t\t\t ssize_t expected_elem_size,\n\t\t\t\t\t bool *replaced)\n{\n\tstruct drm_property_blob *new_blob = NULL;\n\n\tif (blob_id != 0) {\n\t\tnew_blob = drm_property_lookup_blob(dev, blob_id);\n\t\tif (new_blob == NULL) {\n\t\t\tdrm_dbg_atomic(dev,\n\t\t\t\t       \"cannot find blob ID %llu\\n\", blob_id);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (expected_size > 0 &&\n\t\t    new_blob->length != expected_size) {\n\t\t\tdrm_dbg_atomic(dev,\n\t\t\t\t       \"[BLOB:%d] length %zu different from expected %zu\\n\",\n\t\t\t\t       new_blob->base.id, new_blob->length, expected_size);\n\t\t\tdrm_property_blob_put(new_blob);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (expected_elem_size > 0 &&\n\t\t    new_blob->length % expected_elem_size != 0) {\n\t\t\tdrm_dbg_atomic(dev,\n\t\t\t\t       \"[BLOB:%d] length %zu not divisible by element size %zu\\n\",\n\t\t\t\t       new_blob->base.id, new_blob->length, expected_elem_size);\n\t\t\tdrm_property_blob_put(new_blob);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\t*replaced |= drm_property_replace_blob(blob, new_blob);\n\tdrm_property_blob_put(new_blob);\n\n\treturn 0;\n}\n\nstatic int drm_atomic_crtc_set_property(struct drm_crtc *crtc,\n\t\tstruct drm_crtc_state *state, struct drm_property *property,\n\t\tuint64_t val)\n{\n\tstruct drm_device *dev = crtc->dev;\n\tstruct drm_mode_config *config = &dev->mode_config;\n\tbool replaced = false;\n\tint ret;\n\n\tif (property == config->prop_active)\n\t\tstate->active = val;\n\telse if (property == config->prop_mode_id) {\n\t\tstruct drm_property_blob *mode =\n\t\t\tdrm_property_lookup_blob(dev, val);\n\t\tret = drm_atomic_set_mode_prop_for_crtc(state, mode);\n\t\tdrm_property_blob_put(mode);\n\t\treturn ret;\n\t} else if (property == config->prop_vrr_enabled) {\n\t\tstate->vrr_enabled = val;\n\t} else if (property == config->degamma_lut_property) {\n\t\tret = drm_atomic_replace_property_blob_from_id(dev,\n\t\t\t\t\t&state->degamma_lut,\n\t\t\t\t\tval,\n\t\t\t\t\t-1, sizeof(struct drm_color_lut),\n\t\t\t\t\t&replaced);\n\t\tstate->color_mgmt_changed |= replaced;\n\t\treturn ret;\n\t} else if (property == config->ctm_property) {\n\t\tret = drm_atomic_replace_property_blob_from_id(dev,\n\t\t\t\t\t&state->ctm,\n\t\t\t\t\tval,\n\t\t\t\t\tsizeof(struct drm_color_ctm), -1,\n\t\t\t\t\t&replaced);\n\t\tstate->color_mgmt_changed |= replaced;\n\t\treturn ret;\n\t} else if (property == config->gamma_lut_property) {\n\t\tret = drm_atomic_replace_property_blob_from_id(dev,\n\t\t\t\t\t&state->gamma_lut,\n\t\t\t\t\tval,\n\t\t\t\t\t-1, sizeof(struct drm_color_lut),\n\t\t\t\t\t&replaced);\n\t\tstate->color_mgmt_changed |= replaced;\n\t\treturn ret;\n\t} else if (property == config->prop_out_fence_ptr) {\n\t\ts32 __user *fence_ptr = u64_to_user_ptr(val);\n\n\t\tif (!fence_ptr)\n\t\t\treturn 0;\n\n\t\tif (put_user(-1, fence_ptr))\n\t\t\treturn -EFAULT;\n\n\t\tset_out_fence_for_crtc(state->state, crtc, fence_ptr);\n\t} else if (property == crtc->scaling_filter_property) {\n\t\tstate->scaling_filter = val;\n\t} else if (crtc->funcs->atomic_set_property) {\n\t\treturn crtc->funcs->atomic_set_property(crtc, state, property, val);\n\t} else {\n\t\tdrm_dbg_atomic(crtc->dev,\n\t\t\t       \"[CRTC:%d:%s] unknown property [PROP:%d:%s]\\n\",\n\t\t\t       crtc->base.id, crtc->name,\n\t\t\t       property->base.id, property->name);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int\ndrm_atomic_crtc_get_property(struct drm_crtc *crtc,\n\t\tconst struct drm_crtc_state *state,\n\t\tstruct drm_property *property, uint64_t *val)\n{\n\tstruct drm_device *dev = crtc->dev;\n\tstruct drm_mode_config *config = &dev->mode_config;\n\n\tif (property == config->prop_active)\n\t\t*val = drm_atomic_crtc_effectively_active(state);\n\telse if (property == config->prop_mode_id)\n\t\t*val = (state->mode_blob) ? state->mode_blob->base.id : 0;\n\telse if (property == config->prop_vrr_enabled)\n\t\t*val = state->vrr_enabled;\n\telse if (property == config->degamma_lut_property)\n\t\t*val = (state->degamma_lut) ? state->degamma_lut->base.id : 0;\n\telse if (property == config->ctm_property)\n\t\t*val = (state->ctm) ? state->ctm->base.id : 0;\n\telse if (property == config->gamma_lut_property)\n\t\t*val = (state->gamma_lut) ? state->gamma_lut->base.id : 0;\n\telse if (property == config->prop_out_fence_ptr)\n\t\t*val = 0;\n\telse if (property == crtc->scaling_filter_property)\n\t\t*val = state->scaling_filter;\n\telse if (crtc->funcs->atomic_get_property)\n\t\treturn crtc->funcs->atomic_get_property(crtc, state, property, val);\n\telse {\n\t\tdrm_dbg_atomic(dev,\n\t\t\t       \"[CRTC:%d:%s] unknown property [PROP:%d:%s]\\n\",\n\t\t\t       crtc->base.id, crtc->name,\n\t\t\t       property->base.id, property->name);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int drm_atomic_plane_set_property(struct drm_plane *plane,\n\t\tstruct drm_plane_state *state, struct drm_file *file_priv,\n\t\tstruct drm_property *property, uint64_t val)\n{\n\tstruct drm_device *dev = plane->dev;\n\tstruct drm_mode_config *config = &dev->mode_config;\n\tbool replaced = false;\n\tint ret;\n\n\tif (property == config->prop_fb_id) {\n\t\tstruct drm_framebuffer *fb;\n\n\t\tfb = drm_framebuffer_lookup(dev, file_priv, val);\n\t\tdrm_atomic_set_fb_for_plane(state, fb);\n\t\tif (fb)\n\t\t\tdrm_framebuffer_put(fb);\n\t} else if (property == config->prop_in_fence_fd) {\n\t\tif (state->fence)\n\t\t\treturn -EINVAL;\n\n\t\tif (U642I64(val) == -1)\n\t\t\treturn 0;\n\n\t\tstate->fence = sync_file_get_fence(val);\n\t\tif (!state->fence)\n\t\t\treturn -EINVAL;\n\n\t} else if (property == config->prop_crtc_id) {\n\t\tstruct drm_crtc *crtc = drm_crtc_find(dev, file_priv, val);\n\n\t\tif (val && !crtc) {\n\t\t\tdrm_dbg_atomic(dev,\n\t\t\t\t       \"[PROP:%d:%s] cannot find CRTC with ID %llu\\n\",\n\t\t\t\t       property->base.id, property->name, val);\n\t\t\treturn -EACCES;\n\t\t}\n\t\treturn drm_atomic_set_crtc_for_plane(state, crtc);\n\t} else if (property == config->prop_crtc_x) {\n\t\tstate->crtc_x = U642I64(val);\n\t} else if (property == config->prop_crtc_y) {\n\t\tstate->crtc_y = U642I64(val);\n\t} else if (property == config->prop_crtc_w) {\n\t\tstate->crtc_w = val;\n\t} else if (property == config->prop_crtc_h) {\n\t\tstate->crtc_h = val;\n\t} else if (property == config->prop_src_x) {\n\t\tstate->src_x = val;\n\t} else if (property == config->prop_src_y) {\n\t\tstate->src_y = val;\n\t} else if (property == config->prop_src_w) {\n\t\tstate->src_w = val;\n\t} else if (property == config->prop_src_h) {\n\t\tstate->src_h = val;\n\t} else if (property == plane->alpha_property) {\n\t\tstate->alpha = val;\n\t} else if (property == plane->blend_mode_property) {\n\t\tstate->pixel_blend_mode = val;\n\t} else if (property == plane->rotation_property) {\n\t\tif (!is_power_of_2(val & DRM_MODE_ROTATE_MASK)) {\n\t\t\tdrm_dbg_atomic(plane->dev,\n\t\t\t\t       \"[PLANE:%d:%s] bad rotation bitmask: 0x%llx\\n\",\n\t\t\t\t       plane->base.id, plane->name, val);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tstate->rotation = val;\n\t} else if (property == plane->zpos_property) {\n\t\tstate->zpos = val;\n\t} else if (property == plane->color_encoding_property) {\n\t\tstate->color_encoding = val;\n\t} else if (property == plane->color_range_property) {\n\t\tstate->color_range = val;\n\t} else if (property == config->prop_fb_damage_clips) {\n\t\tret = drm_atomic_replace_property_blob_from_id(dev,\n\t\t\t\t\t&state->fb_damage_clips,\n\t\t\t\t\tval,\n\t\t\t\t\t-1,\n\t\t\t\t\tsizeof(struct drm_rect),\n\t\t\t\t\t&replaced);\n\t\treturn ret;\n\t} else if (property == plane->scaling_filter_property) {\n\t\tstate->scaling_filter = val;\n\t} else if (plane->funcs->atomic_set_property) {\n\t\treturn plane->funcs->atomic_set_property(plane, state,\n\t\t\t\tproperty, val);\n\t} else {\n\t\tdrm_dbg_atomic(plane->dev,\n\t\t\t       \"[PLANE:%d:%s] unknown property [PROP:%d:%s]\\n\",\n\t\t\t       plane->base.id, plane->name,\n\t\t\t       property->base.id, property->name);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int\ndrm_atomic_plane_get_property(struct drm_plane *plane,\n\t\tconst struct drm_plane_state *state,\n\t\tstruct drm_property *property, uint64_t *val)\n{\n\tstruct drm_device *dev = plane->dev;\n\tstruct drm_mode_config *config = &dev->mode_config;\n\n\tif (property == config->prop_fb_id) {\n\t\t*val = (state->fb) ? state->fb->base.id : 0;\n\t} else if (property == config->prop_in_fence_fd) {\n\t\t*val = -1;\n\t} else if (property == config->prop_crtc_id) {\n\t\t*val = (state->crtc) ? state->crtc->base.id : 0;\n\t} else if (property == config->prop_crtc_x) {\n\t\t*val = I642U64(state->crtc_x);\n\t} else if (property == config->prop_crtc_y) {\n\t\t*val = I642U64(state->crtc_y);\n\t} else if (property == config->prop_crtc_w) {\n\t\t*val = state->crtc_w;\n\t} else if (property == config->prop_crtc_h) {\n\t\t*val = state->crtc_h;\n\t} else if (property == config->prop_src_x) {\n\t\t*val = state->src_x;\n\t} else if (property == config->prop_src_y) {\n\t\t*val = state->src_y;\n\t} else if (property == config->prop_src_w) {\n\t\t*val = state->src_w;\n\t} else if (property == config->prop_src_h) {\n\t\t*val = state->src_h;\n\t} else if (property == plane->alpha_property) {\n\t\t*val = state->alpha;\n\t} else if (property == plane->blend_mode_property) {\n\t\t*val = state->pixel_blend_mode;\n\t} else if (property == plane->rotation_property) {\n\t\t*val = state->rotation;\n\t} else if (property == plane->zpos_property) {\n\t\t*val = state->zpos;\n\t} else if (property == plane->color_encoding_property) {\n\t\t*val = state->color_encoding;\n\t} else if (property == plane->color_range_property) {\n\t\t*val = state->color_range;\n\t} else if (property == config->prop_fb_damage_clips) {\n\t\t*val = (state->fb_damage_clips) ?\n\t\t\tstate->fb_damage_clips->base.id : 0;\n\t} else if (property == plane->scaling_filter_property) {\n\t\t*val = state->scaling_filter;\n\t} else if (plane->funcs->atomic_get_property) {\n\t\treturn plane->funcs->atomic_get_property(plane, state, property, val);\n\t} else {\n\t\tdrm_dbg_atomic(dev,\n\t\t\t       \"[PLANE:%d:%s] unknown property [PROP:%d:%s]\\n\",\n\t\t\t       plane->base.id, plane->name,\n\t\t\t       property->base.id, property->name);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int drm_atomic_set_writeback_fb_for_connector(\n\t\tstruct drm_connector_state *conn_state,\n\t\tstruct drm_framebuffer *fb)\n{\n\tint ret;\n\tstruct drm_connector *conn = conn_state->connector;\n\n\tret = drm_writeback_set_fb(conn_state, fb);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (fb)\n\t\tdrm_dbg_atomic(conn->dev,\n\t\t\t       \"Set [FB:%d] for connector state %p\\n\",\n\t\t\t       fb->base.id, conn_state);\n\telse\n\t\tdrm_dbg_atomic(conn->dev,\n\t\t\t       \"Set [NOFB] for connector state %p\\n\",\n\t\t\t       conn_state);\n\n\treturn 0;\n}\n\nstatic int drm_atomic_connector_set_property(struct drm_connector *connector,\n\t\tstruct drm_connector_state *state, struct drm_file *file_priv,\n\t\tstruct drm_property *property, uint64_t val)\n{\n\tstruct drm_device *dev = connector->dev;\n\tstruct drm_mode_config *config = &dev->mode_config;\n\tbool replaced = false;\n\tint ret;\n\n\tif (property == config->prop_crtc_id) {\n\t\tstruct drm_crtc *crtc = drm_crtc_find(dev, file_priv, val);\n\n\t\tif (val && !crtc) {\n\t\t\tdrm_dbg_atomic(dev,\n\t\t\t\t       \"[PROP:%d:%s] cannot find CRTC with ID %llu\\n\",\n\t\t\t\t       property->base.id, property->name, val);\n\t\t\treturn -EACCES;\n\t\t}\n\t\treturn drm_atomic_set_crtc_for_connector(state, crtc);\n\t} else if (property == config->dpms_property) {\n\t\t \n\t\tdrm_dbg_atomic(dev,\n\t\t\t       \"legacy [PROP:%d:%s] can only be set via legacy uAPI\\n\",\n\t\t\t       property->base.id, property->name);\n\t\treturn -EINVAL;\n\t} else if (property == config->tv_select_subconnector_property) {\n\t\tstate->tv.select_subconnector = val;\n\t} else if (property == config->tv_subconnector_property) {\n\t\tstate->tv.subconnector = val;\n\t} else if (property == config->tv_left_margin_property) {\n\t\tstate->tv.margins.left = val;\n\t} else if (property == config->tv_right_margin_property) {\n\t\tstate->tv.margins.right = val;\n\t} else if (property == config->tv_top_margin_property) {\n\t\tstate->tv.margins.top = val;\n\t} else if (property == config->tv_bottom_margin_property) {\n\t\tstate->tv.margins.bottom = val;\n\t} else if (property == config->legacy_tv_mode_property) {\n\t\tstate->tv.legacy_mode = val;\n\t} else if (property == config->tv_mode_property) {\n\t\tstate->tv.mode = val;\n\t} else if (property == config->tv_brightness_property) {\n\t\tstate->tv.brightness = val;\n\t} else if (property == config->tv_contrast_property) {\n\t\tstate->tv.contrast = val;\n\t} else if (property == config->tv_flicker_reduction_property) {\n\t\tstate->tv.flicker_reduction = val;\n\t} else if (property == config->tv_overscan_property) {\n\t\tstate->tv.overscan = val;\n\t} else if (property == config->tv_saturation_property) {\n\t\tstate->tv.saturation = val;\n\t} else if (property == config->tv_hue_property) {\n\t\tstate->tv.hue = val;\n\t} else if (property == config->link_status_property) {\n\t\t \n\t\tif (state->link_status != DRM_LINK_STATUS_GOOD)\n\t\t\tstate->link_status = val;\n\t} else if (property == config->hdr_output_metadata_property) {\n\t\tret = drm_atomic_replace_property_blob_from_id(dev,\n\t\t\t\t&state->hdr_output_metadata,\n\t\t\t\tval,\n\t\t\t\tsizeof(struct hdr_output_metadata), -1,\n\t\t\t\t&replaced);\n\t\treturn ret;\n\t} else if (property == config->aspect_ratio_property) {\n\t\tstate->picture_aspect_ratio = val;\n\t} else if (property == config->content_type_property) {\n\t\tstate->content_type = val;\n\t} else if (property == connector->scaling_mode_property) {\n\t\tstate->scaling_mode = val;\n\t} else if (property == config->content_protection_property) {\n\t\tif (val == DRM_MODE_CONTENT_PROTECTION_ENABLED) {\n\t\t\tdrm_dbg_kms(dev, \"only drivers can set CP Enabled\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tstate->content_protection = val;\n\t} else if (property == config->hdcp_content_type_property) {\n\t\tstate->hdcp_content_type = val;\n\t} else if (property == connector->colorspace_property) {\n\t\tstate->colorspace = val;\n\t} else if (property == config->writeback_fb_id_property) {\n\t\tstruct drm_framebuffer *fb;\n\t\tint ret;\n\n\t\tfb = drm_framebuffer_lookup(dev, file_priv, val);\n\t\tret = drm_atomic_set_writeback_fb_for_connector(state, fb);\n\t\tif (fb)\n\t\t\tdrm_framebuffer_put(fb);\n\t\treturn ret;\n\t} else if (property == config->writeback_out_fence_ptr_property) {\n\t\ts32 __user *fence_ptr = u64_to_user_ptr(val);\n\n\t\treturn set_out_fence_for_connector(state->state, connector,\n\t\t\t\t\t\t   fence_ptr);\n\t} else if (property == connector->max_bpc_property) {\n\t\tstate->max_requested_bpc = val;\n\t} else if (property == connector->privacy_screen_sw_state_property) {\n\t\tstate->privacy_screen_sw_state = val;\n\t} else if (connector->funcs->atomic_set_property) {\n\t\treturn connector->funcs->atomic_set_property(connector,\n\t\t\t\tstate, property, val);\n\t} else {\n\t\tdrm_dbg_atomic(connector->dev,\n\t\t\t       \"[CONNECTOR:%d:%s] unknown property [PROP:%d:%s]\\n\",\n\t\t\t       connector->base.id, connector->name,\n\t\t\t       property->base.id, property->name);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int\ndrm_atomic_connector_get_property(struct drm_connector *connector,\n\t\tconst struct drm_connector_state *state,\n\t\tstruct drm_property *property, uint64_t *val)\n{\n\tstruct drm_device *dev = connector->dev;\n\tstruct drm_mode_config *config = &dev->mode_config;\n\n\tif (property == config->prop_crtc_id) {\n\t\t*val = (state->crtc) ? state->crtc->base.id : 0;\n\t} else if (property == config->dpms_property) {\n\t\tif (state->crtc && state->crtc->state->self_refresh_active)\n\t\t\t*val = DRM_MODE_DPMS_ON;\n\t\telse\n\t\t\t*val = connector->dpms;\n\t} else if (property == config->tv_select_subconnector_property) {\n\t\t*val = state->tv.select_subconnector;\n\t} else if (property == config->tv_subconnector_property) {\n\t\t*val = state->tv.subconnector;\n\t} else if (property == config->tv_left_margin_property) {\n\t\t*val = state->tv.margins.left;\n\t} else if (property == config->tv_right_margin_property) {\n\t\t*val = state->tv.margins.right;\n\t} else if (property == config->tv_top_margin_property) {\n\t\t*val = state->tv.margins.top;\n\t} else if (property == config->tv_bottom_margin_property) {\n\t\t*val = state->tv.margins.bottom;\n\t} else if (property == config->legacy_tv_mode_property) {\n\t\t*val = state->tv.legacy_mode;\n\t} else if (property == config->tv_mode_property) {\n\t\t*val = state->tv.mode;\n\t} else if (property == config->tv_brightness_property) {\n\t\t*val = state->tv.brightness;\n\t} else if (property == config->tv_contrast_property) {\n\t\t*val = state->tv.contrast;\n\t} else if (property == config->tv_flicker_reduction_property) {\n\t\t*val = state->tv.flicker_reduction;\n\t} else if (property == config->tv_overscan_property) {\n\t\t*val = state->tv.overscan;\n\t} else if (property == config->tv_saturation_property) {\n\t\t*val = state->tv.saturation;\n\t} else if (property == config->tv_hue_property) {\n\t\t*val = state->tv.hue;\n\t} else if (property == config->link_status_property) {\n\t\t*val = state->link_status;\n\t} else if (property == config->aspect_ratio_property) {\n\t\t*val = state->picture_aspect_ratio;\n\t} else if (property == config->content_type_property) {\n\t\t*val = state->content_type;\n\t} else if (property == connector->colorspace_property) {\n\t\t*val = state->colorspace;\n\t} else if (property == connector->scaling_mode_property) {\n\t\t*val = state->scaling_mode;\n\t} else if (property == config->hdr_output_metadata_property) {\n\t\t*val = state->hdr_output_metadata ?\n\t\t\tstate->hdr_output_metadata->base.id : 0;\n\t} else if (property == config->content_protection_property) {\n\t\t*val = state->content_protection;\n\t} else if (property == config->hdcp_content_type_property) {\n\t\t*val = state->hdcp_content_type;\n\t} else if (property == config->writeback_fb_id_property) {\n\t\t \n\t\t*val = 0;\n\t} else if (property == config->writeback_out_fence_ptr_property) {\n\t\t*val = 0;\n\t} else if (property == connector->max_bpc_property) {\n\t\t*val = state->max_requested_bpc;\n\t} else if (property == connector->privacy_screen_sw_state_property) {\n\t\t*val = state->privacy_screen_sw_state;\n\t} else if (connector->funcs->atomic_get_property) {\n\t\treturn connector->funcs->atomic_get_property(connector,\n\t\t\t\tstate, property, val);\n\t} else {\n\t\tdrm_dbg_atomic(dev,\n\t\t\t       \"[CONNECTOR:%d:%s] unknown property [PROP:%d:%s]\\n\",\n\t\t\t       connector->base.id, connector->name,\n\t\t\t       property->base.id, property->name);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nint drm_atomic_get_property(struct drm_mode_object *obj,\n\t\tstruct drm_property *property, uint64_t *val)\n{\n\tstruct drm_device *dev = property->dev;\n\tint ret;\n\n\tswitch (obj->type) {\n\tcase DRM_MODE_OBJECT_CONNECTOR: {\n\t\tstruct drm_connector *connector = obj_to_connector(obj);\n\n\t\tWARN_ON(!drm_modeset_is_locked(&dev->mode_config.connection_mutex));\n\t\tret = drm_atomic_connector_get_property(connector,\n\t\t\t\tconnector->state, property, val);\n\t\tbreak;\n\t}\n\tcase DRM_MODE_OBJECT_CRTC: {\n\t\tstruct drm_crtc *crtc = obj_to_crtc(obj);\n\n\t\tWARN_ON(!drm_modeset_is_locked(&crtc->mutex));\n\t\tret = drm_atomic_crtc_get_property(crtc,\n\t\t\t\tcrtc->state, property, val);\n\t\tbreak;\n\t}\n\tcase DRM_MODE_OBJECT_PLANE: {\n\t\tstruct drm_plane *plane = obj_to_plane(obj);\n\n\t\tWARN_ON(!drm_modeset_is_locked(&plane->mutex));\n\t\tret = drm_atomic_plane_get_property(plane,\n\t\t\t\tplane->state, property, val);\n\t\tbreak;\n\t}\n\tdefault:\n\t\tdrm_dbg_atomic(dev, \"[OBJECT:%d] has no properties\\n\", obj->id);\n\t\tret = -EINVAL;\n\t\tbreak;\n\t}\n\n\treturn ret;\n}\n\n \n\nstatic struct drm_pending_vblank_event *create_vblank_event(\n\t\tstruct drm_crtc *crtc, uint64_t user_data)\n{\n\tstruct drm_pending_vblank_event *e = NULL;\n\n\te = kzalloc(sizeof *e, GFP_KERNEL);\n\tif (!e)\n\t\treturn NULL;\n\n\te->event.base.type = DRM_EVENT_FLIP_COMPLETE;\n\te->event.base.length = sizeof(e->event);\n\te->event.vbl.crtc_id = crtc->base.id;\n\te->event.vbl.user_data = user_data;\n\n\treturn e;\n}\n\nint drm_atomic_connector_commit_dpms(struct drm_atomic_state *state,\n\t\t\t\t     struct drm_connector *connector,\n\t\t\t\t     int mode)\n{\n\tstruct drm_connector *tmp_connector;\n\tstruct drm_connector_state *new_conn_state;\n\tstruct drm_crtc *crtc;\n\tstruct drm_crtc_state *crtc_state;\n\tint i, ret, old_mode = connector->dpms;\n\tbool active = false;\n\n\tret = drm_modeset_lock(&state->dev->mode_config.connection_mutex,\n\t\t\t       state->acquire_ctx);\n\tif (ret)\n\t\treturn ret;\n\n\tif (mode != DRM_MODE_DPMS_ON)\n\t\tmode = DRM_MODE_DPMS_OFF;\n\tconnector->dpms = mode;\n\n\tcrtc = connector->state->crtc;\n\tif (!crtc)\n\t\tgoto out;\n\tret = drm_atomic_add_affected_connectors(state, crtc);\n\tif (ret)\n\t\tgoto out;\n\n\tcrtc_state = drm_atomic_get_crtc_state(state, crtc);\n\tif (IS_ERR(crtc_state)) {\n\t\tret = PTR_ERR(crtc_state);\n\t\tgoto out;\n\t}\n\n\tfor_each_new_connector_in_state(state, tmp_connector, new_conn_state, i) {\n\t\tif (new_conn_state->crtc != crtc)\n\t\t\tcontinue;\n\t\tif (tmp_connector->dpms == DRM_MODE_DPMS_ON) {\n\t\t\tactive = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tcrtc_state->active = active;\n\tret = drm_atomic_commit(state);\nout:\n\tif (ret != 0)\n\t\tconnector->dpms = old_mode;\n\treturn ret;\n}\n\nint drm_atomic_set_property(struct drm_atomic_state *state,\n\t\t\t    struct drm_file *file_priv,\n\t\t\t    struct drm_mode_object *obj,\n\t\t\t    struct drm_property *prop,\n\t\t\t    uint64_t prop_value)\n{\n\tstruct drm_mode_object *ref;\n\tint ret;\n\n\tif (!drm_property_change_valid_get(prop, prop_value, &ref))\n\t\treturn -EINVAL;\n\n\tswitch (obj->type) {\n\tcase DRM_MODE_OBJECT_CONNECTOR: {\n\t\tstruct drm_connector *connector = obj_to_connector(obj);\n\t\tstruct drm_connector_state *connector_state;\n\n\t\tconnector_state = drm_atomic_get_connector_state(state, connector);\n\t\tif (IS_ERR(connector_state)) {\n\t\t\tret = PTR_ERR(connector_state);\n\t\t\tbreak;\n\t\t}\n\n\t\tret = drm_atomic_connector_set_property(connector,\n\t\t\t\tconnector_state, file_priv,\n\t\t\t\tprop, prop_value);\n\t\tbreak;\n\t}\n\tcase DRM_MODE_OBJECT_CRTC: {\n\t\tstruct drm_crtc *crtc = obj_to_crtc(obj);\n\t\tstruct drm_crtc_state *crtc_state;\n\n\t\tcrtc_state = drm_atomic_get_crtc_state(state, crtc);\n\t\tif (IS_ERR(crtc_state)) {\n\t\t\tret = PTR_ERR(crtc_state);\n\t\t\tbreak;\n\t\t}\n\n\t\tret = drm_atomic_crtc_set_property(crtc,\n\t\t\t\tcrtc_state, prop, prop_value);\n\t\tbreak;\n\t}\n\tcase DRM_MODE_OBJECT_PLANE: {\n\t\tstruct drm_plane *plane = obj_to_plane(obj);\n\t\tstruct drm_plane_state *plane_state;\n\n\t\tplane_state = drm_atomic_get_plane_state(state, plane);\n\t\tif (IS_ERR(plane_state)) {\n\t\t\tret = PTR_ERR(plane_state);\n\t\t\tbreak;\n\t\t}\n\n\t\tret = drm_atomic_plane_set_property(plane,\n\t\t\t\tplane_state, file_priv,\n\t\t\t\tprop, prop_value);\n\t\tbreak;\n\t}\n\tdefault:\n\t\tdrm_dbg_atomic(prop->dev, \"[OBJECT:%d] has no properties\\n\", obj->id);\n\t\tret = -EINVAL;\n\t\tbreak;\n\t}\n\n\tdrm_property_change_valid_put(prop, ref);\n\treturn ret;\n}\n\n \n\nstruct drm_out_fence_state {\n\ts32 __user *out_fence_ptr;\n\tstruct sync_file *sync_file;\n\tint fd;\n};\n\nstatic int setup_out_fence(struct drm_out_fence_state *fence_state,\n\t\t\t   struct dma_fence *fence)\n{\n\tfence_state->fd = get_unused_fd_flags(O_CLOEXEC);\n\tif (fence_state->fd < 0)\n\t\treturn fence_state->fd;\n\n\tif (put_user(fence_state->fd, fence_state->out_fence_ptr))\n\t\treturn -EFAULT;\n\n\tfence_state->sync_file = sync_file_create(fence);\n\tif (!fence_state->sync_file)\n\t\treturn -ENOMEM;\n\n\treturn 0;\n}\n\nstatic int prepare_signaling(struct drm_device *dev,\n\t\t\t\t  struct drm_atomic_state *state,\n\t\t\t\t  struct drm_mode_atomic *arg,\n\t\t\t\t  struct drm_file *file_priv,\n\t\t\t\t  struct drm_out_fence_state **fence_state,\n\t\t\t\t  unsigned int *num_fences)\n{\n\tstruct drm_crtc *crtc;\n\tstruct drm_crtc_state *crtc_state;\n\tstruct drm_connector *conn;\n\tstruct drm_connector_state *conn_state;\n\tint i, c = 0, ret;\n\n\tif (arg->flags & DRM_MODE_ATOMIC_TEST_ONLY)\n\t\treturn 0;\n\n\tfor_each_new_crtc_in_state(state, crtc, crtc_state, i) {\n\t\ts32 __user *fence_ptr;\n\n\t\tfence_ptr = get_out_fence_for_crtc(crtc_state->state, crtc);\n\n\t\tif (arg->flags & DRM_MODE_PAGE_FLIP_EVENT || fence_ptr) {\n\t\t\tstruct drm_pending_vblank_event *e;\n\n\t\t\te = create_vblank_event(crtc, arg->user_data);\n\t\t\tif (!e)\n\t\t\t\treturn -ENOMEM;\n\n\t\t\tcrtc_state->event = e;\n\t\t}\n\n\t\tif (arg->flags & DRM_MODE_PAGE_FLIP_EVENT) {\n\t\t\tstruct drm_pending_vblank_event *e = crtc_state->event;\n\n\t\t\tif (!file_priv)\n\t\t\t\tcontinue;\n\n\t\t\tret = drm_event_reserve_init(dev, file_priv, &e->base,\n\t\t\t\t\t\t     &e->event.base);\n\t\t\tif (ret) {\n\t\t\t\tkfree(e);\n\t\t\t\tcrtc_state->event = NULL;\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t}\n\n\t\tif (fence_ptr) {\n\t\t\tstruct dma_fence *fence;\n\t\t\tstruct drm_out_fence_state *f;\n\n\t\t\tf = krealloc(*fence_state, sizeof(**fence_state) *\n\t\t\t\t     (*num_fences + 1), GFP_KERNEL);\n\t\t\tif (!f)\n\t\t\t\treturn -ENOMEM;\n\n\t\t\tmemset(&f[*num_fences], 0, sizeof(*f));\n\n\t\t\tf[*num_fences].out_fence_ptr = fence_ptr;\n\t\t\t*fence_state = f;\n\n\t\t\tfence = drm_crtc_create_fence(crtc);\n\t\t\tif (!fence)\n\t\t\t\treturn -ENOMEM;\n\n\t\t\tret = setup_out_fence(&f[(*num_fences)++], fence);\n\t\t\tif (ret) {\n\t\t\t\tdma_fence_put(fence);\n\t\t\t\treturn ret;\n\t\t\t}\n\n\t\t\tcrtc_state->event->base.fence = fence;\n\t\t}\n\n\t\tc++;\n\t}\n\n\tfor_each_new_connector_in_state(state, conn, conn_state, i) {\n\t\tstruct drm_writeback_connector *wb_conn;\n\t\tstruct drm_out_fence_state *f;\n\t\tstruct dma_fence *fence;\n\t\ts32 __user *fence_ptr;\n\n\t\tif (!conn_state->writeback_job)\n\t\t\tcontinue;\n\n\t\tfence_ptr = get_out_fence_for_connector(state, conn);\n\t\tif (!fence_ptr)\n\t\t\tcontinue;\n\n\t\tf = krealloc(*fence_state, sizeof(**fence_state) *\n\t\t\t     (*num_fences + 1), GFP_KERNEL);\n\t\tif (!f)\n\t\t\treturn -ENOMEM;\n\n\t\tmemset(&f[*num_fences], 0, sizeof(*f));\n\n\t\tf[*num_fences].out_fence_ptr = fence_ptr;\n\t\t*fence_state = f;\n\n\t\twb_conn = drm_connector_to_writeback(conn);\n\t\tfence = drm_writeback_get_out_fence(wb_conn);\n\t\tif (!fence)\n\t\t\treturn -ENOMEM;\n\n\t\tret = setup_out_fence(&f[(*num_fences)++], fence);\n\t\tif (ret) {\n\t\t\tdma_fence_put(fence);\n\t\t\treturn ret;\n\t\t}\n\n\t\tconn_state->writeback_job->out_fence = fence;\n\t}\n\n\t \n\tif (c == 0 && (arg->flags & DRM_MODE_PAGE_FLIP_EVENT)) {\n\t\tdrm_dbg_atomic(dev, \"need at least one CRTC for DRM_MODE_PAGE_FLIP_EVENT\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic void complete_signaling(struct drm_device *dev,\n\t\t\t       struct drm_atomic_state *state,\n\t\t\t       struct drm_out_fence_state *fence_state,\n\t\t\t       unsigned int num_fences,\n\t\t\t       bool install_fds)\n{\n\tstruct drm_crtc *crtc;\n\tstruct drm_crtc_state *crtc_state;\n\tint i;\n\n\tif (install_fds) {\n\t\tfor (i = 0; i < num_fences; i++)\n\t\t\tfd_install(fence_state[i].fd,\n\t\t\t\t   fence_state[i].sync_file->file);\n\n\t\tkfree(fence_state);\n\t\treturn;\n\t}\n\n\tfor_each_new_crtc_in_state(state, crtc, crtc_state, i) {\n\t\tstruct drm_pending_vblank_event *event = crtc_state->event;\n\t\t \n\t\tif (event && (event->base.fence || event->base.file_priv)) {\n\t\t\tdrm_event_cancel_free(dev, &event->base);\n\t\t\tcrtc_state->event = NULL;\n\t\t}\n\t}\n\n\tif (!fence_state)\n\t\treturn;\n\n\tfor (i = 0; i < num_fences; i++) {\n\t\tif (fence_state[i].sync_file)\n\t\t\tfput(fence_state[i].sync_file->file);\n\t\tif (fence_state[i].fd >= 0)\n\t\t\tput_unused_fd(fence_state[i].fd);\n\n\t\t \n\t\tif (fence_state[i].out_fence_ptr &&\n\t\t    put_user(-1, fence_state[i].out_fence_ptr))\n\t\t\tdrm_dbg_atomic(dev, \"Couldn't clear out_fence_ptr\\n\");\n\t}\n\n\tkfree(fence_state);\n}\n\nint drm_mode_atomic_ioctl(struct drm_device *dev,\n\t\t\t  void *data, struct drm_file *file_priv)\n{\n\tstruct drm_mode_atomic *arg = data;\n\tuint32_t __user *objs_ptr = (uint32_t __user *)(unsigned long)(arg->objs_ptr);\n\tuint32_t __user *count_props_ptr = (uint32_t __user *)(unsigned long)(arg->count_props_ptr);\n\tuint32_t __user *props_ptr = (uint32_t __user *)(unsigned long)(arg->props_ptr);\n\tuint64_t __user *prop_values_ptr = (uint64_t __user *)(unsigned long)(arg->prop_values_ptr);\n\tunsigned int copied_objs, copied_props;\n\tstruct drm_atomic_state *state;\n\tstruct drm_modeset_acquire_ctx ctx;\n\tstruct drm_out_fence_state *fence_state;\n\tint ret = 0;\n\tunsigned int i, j, num_fences;\n\n\t \n\tif (!drm_core_check_feature(dev, DRIVER_ATOMIC))\n\t\treturn -EOPNOTSUPP;\n\n\t \n\tif (!file_priv->atomic) {\n\t\tdrm_dbg_atomic(dev,\n\t\t\t       \"commit failed: atomic cap not enabled\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (arg->flags & ~DRM_MODE_ATOMIC_FLAGS) {\n\t\tdrm_dbg_atomic(dev, \"commit failed: invalid flag\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (arg->reserved) {\n\t\tdrm_dbg_atomic(dev, \"commit failed: reserved field set\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (arg->flags & DRM_MODE_PAGE_FLIP_ASYNC) {\n\t\tdrm_dbg_atomic(dev,\n\t\t\t       \"commit failed: invalid flag DRM_MODE_PAGE_FLIP_ASYNC\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif ((arg->flags & DRM_MODE_ATOMIC_TEST_ONLY) &&\n\t\t\t(arg->flags & DRM_MODE_PAGE_FLIP_EVENT)) {\n\t\tdrm_dbg_atomic(dev,\n\t\t\t       \"commit failed: page-flip event requested with test-only commit\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tstate = drm_atomic_state_alloc(dev);\n\tif (!state)\n\t\treturn -ENOMEM;\n\n\tdrm_modeset_acquire_init(&ctx, DRM_MODESET_ACQUIRE_INTERRUPTIBLE);\n\tstate->acquire_ctx = &ctx;\n\tstate->allow_modeset = !!(arg->flags & DRM_MODE_ATOMIC_ALLOW_MODESET);\n\nretry:\n\tcopied_objs = 0;\n\tcopied_props = 0;\n\tfence_state = NULL;\n\tnum_fences = 0;\n\n\tfor (i = 0; i < arg->count_objs; i++) {\n\t\tuint32_t obj_id, count_props;\n\t\tstruct drm_mode_object *obj;\n\n\t\tif (get_user(obj_id, objs_ptr + copied_objs)) {\n\t\t\tret = -EFAULT;\n\t\t\tgoto out;\n\t\t}\n\n\t\tobj = drm_mode_object_find(dev, file_priv, obj_id, DRM_MODE_OBJECT_ANY);\n\t\tif (!obj) {\n\t\t\tdrm_dbg_atomic(dev, \"cannot find object ID %d\", obj_id);\n\t\t\tret = -ENOENT;\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (!obj->properties) {\n\t\t\tdrm_dbg_atomic(dev, \"[OBJECT:%d] has no properties\", obj_id);\n\t\t\tdrm_mode_object_put(obj);\n\t\t\tret = -ENOENT;\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (get_user(count_props, count_props_ptr + copied_objs)) {\n\t\t\tdrm_mode_object_put(obj);\n\t\t\tret = -EFAULT;\n\t\t\tgoto out;\n\t\t}\n\n\t\tcopied_objs++;\n\n\t\tfor (j = 0; j < count_props; j++) {\n\t\t\tuint32_t prop_id;\n\t\t\tuint64_t prop_value;\n\t\t\tstruct drm_property *prop;\n\n\t\t\tif (get_user(prop_id, props_ptr + copied_props)) {\n\t\t\t\tdrm_mode_object_put(obj);\n\t\t\t\tret = -EFAULT;\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tprop = drm_mode_obj_find_prop_id(obj, prop_id);\n\t\t\tif (!prop) {\n\t\t\t\tdrm_dbg_atomic(dev,\n\t\t\t\t\t       \"[OBJECT:%d] cannot find property ID %d\",\n\t\t\t\t\t       obj_id, prop_id);\n\t\t\t\tdrm_mode_object_put(obj);\n\t\t\t\tret = -ENOENT;\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tif (copy_from_user(&prop_value,\n\t\t\t\t\t   prop_values_ptr + copied_props,\n\t\t\t\t\t   sizeof(prop_value))) {\n\t\t\t\tdrm_mode_object_put(obj);\n\t\t\t\tret = -EFAULT;\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tret = drm_atomic_set_property(state, file_priv,\n\t\t\t\t\t\t      obj, prop, prop_value);\n\t\t\tif (ret) {\n\t\t\t\tdrm_mode_object_put(obj);\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tcopied_props++;\n\t\t}\n\n\t\tdrm_mode_object_put(obj);\n\t}\n\n\tret = prepare_signaling(dev, state, arg, file_priv, &fence_state,\n\t\t\t\t&num_fences);\n\tif (ret)\n\t\tgoto out;\n\n\tif (arg->flags & DRM_MODE_ATOMIC_TEST_ONLY) {\n\t\tret = drm_atomic_check_only(state);\n\t} else if (arg->flags & DRM_MODE_ATOMIC_NONBLOCK) {\n\t\tret = drm_atomic_nonblocking_commit(state);\n\t} else {\n\t\tret = drm_atomic_commit(state);\n\t}\n\nout:\n\tcomplete_signaling(dev, state, fence_state, num_fences, !ret);\n\n\tif (ret == -EDEADLK) {\n\t\tdrm_atomic_state_clear(state);\n\t\tret = drm_modeset_backoff(&ctx);\n\t\tif (!ret)\n\t\t\tgoto retry;\n\t}\n\n\tdrm_atomic_state_put(state);\n\n\tdrm_modeset_drop_locks(&ctx);\n\tdrm_modeset_acquire_fini(&ctx);\n\n\treturn ret;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}