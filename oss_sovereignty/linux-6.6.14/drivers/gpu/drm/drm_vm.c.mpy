{
  "module_name": "drm_vm.c",
  "hash_id": "489ab386d49efbf32c60e28e22e0d95bd6af9b6745f50f25ca66f97545d93416",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/drm_vm.c",
  "human_readable_source": " \n\n \n\n#include <linux/export.h>\n#include <linux/pci.h>\n#include <linux/seq_file.h>\n#include <linux/vmalloc.h>\n#include <linux/pgtable.h>\n\n#if defined(__ia64__)\n#include <linux/efi.h>\n#include <linux/slab.h>\n#endif\n#include <linux/mem_encrypt.h>\n\n#include <drm/drm_device.h>\n#include <drm/drm_drv.h>\n#include <drm/drm_file.h>\n#include <drm/drm_framebuffer.h>\n#include <drm/drm_print.h>\n\n#include \"drm_internal.h\"\n#include \"drm_legacy.h\"\n\nstruct drm_vma_entry {\n\tstruct list_head head;\n\tstruct vm_area_struct *vma;\n\tpid_t pid;\n};\n\nstatic void drm_vm_open(struct vm_area_struct *vma);\nstatic void drm_vm_close(struct vm_area_struct *vma);\n\nstatic pgprot_t drm_io_prot(struct drm_local_map *map,\n\t\t\t    struct vm_area_struct *vma)\n{\n\tpgprot_t tmp = vm_get_page_prot(vma->vm_flags);\n\n#if defined(__i386__) || defined(__x86_64__) || defined(__powerpc__) || \\\n    defined(__mips__) || defined(__loongarch__)\n\tif (map->type == _DRM_REGISTERS && !(map->flags & _DRM_WRITE_COMBINING))\n\t\ttmp = pgprot_noncached(tmp);\n\telse\n\t\ttmp = pgprot_writecombine(tmp);\n#elif defined(__ia64__)\n\tif (efi_range_is_wc(vma->vm_start, vma->vm_end -\n\t\t\t\t    vma->vm_start))\n\t\ttmp = pgprot_writecombine(tmp);\n\telse\n\t\ttmp = pgprot_noncached(tmp);\n#elif defined(__sparc__) || defined(__arm__)\n\ttmp = pgprot_noncached(tmp);\n#endif\n\treturn tmp;\n}\n\nstatic pgprot_t drm_dma_prot(uint32_t map_type, struct vm_area_struct *vma)\n{\n\tpgprot_t tmp = vm_get_page_prot(vma->vm_flags);\n\n#if defined(__powerpc__) && defined(CONFIG_NOT_COHERENT_CACHE)\n\ttmp = pgprot_noncached_wc(tmp);\n#endif\n\treturn tmp;\n}\n\n \n#if IS_ENABLED(CONFIG_AGP)\nstatic vm_fault_t drm_vm_fault(struct vm_fault *vmf)\n{\n\tstruct vm_area_struct *vma = vmf->vma;\n\tstruct drm_file *priv = vma->vm_file->private_data;\n\tstruct drm_device *dev = priv->minor->dev;\n\tstruct drm_local_map *map = NULL;\n\tstruct drm_map_list *r_list;\n\tstruct drm_hash_item *hash;\n\n\t \n\tif (!dev->agp)\n\t\tgoto vm_fault_error;\n\n\tif (!dev->agp || !dev->agp->cant_use_aperture)\n\t\tgoto vm_fault_error;\n\n\tif (drm_ht_find_item(&dev->map_hash, vma->vm_pgoff, &hash))\n\t\tgoto vm_fault_error;\n\n\tr_list = drm_hash_entry(hash, struct drm_map_list, hash);\n\tmap = r_list->map;\n\n\tif (map && map->type == _DRM_AGP) {\n\t\t \n\t\tresource_size_t offset = vmf->address - vma->vm_start;\n\t\tresource_size_t baddr = map->offset + offset;\n\t\tstruct drm_agp_mem *agpmem;\n\t\tstruct page *page;\n\n#ifdef __alpha__\n\t\t \n\t\tbaddr -= dev->hose->mem_space->start;\n#endif\n\n\t\t \n\t\tlist_for_each_entry(agpmem, &dev->agp->memory, head) {\n\t\t\tif (agpmem->bound <= baddr &&\n\t\t\t    agpmem->bound + agpmem->pages * PAGE_SIZE > baddr)\n\t\t\t\tbreak;\n\t\t}\n\n\t\tif (&agpmem->head == &dev->agp->memory)\n\t\t\tgoto vm_fault_error;\n\n\t\t \n\t\toffset = (baddr - agpmem->bound) >> PAGE_SHIFT;\n\t\tpage = agpmem->memory->pages[offset];\n\t\tget_page(page);\n\t\tvmf->page = page;\n\n\t\tDRM_DEBUG\n\t\t    (\"baddr = 0x%llx page = 0x%p, offset = 0x%llx, count=%d\\n\",\n\t\t     (unsigned long long)baddr,\n\t\t     agpmem->memory->pages[offset],\n\t\t     (unsigned long long)offset,\n\t\t     page_count(page));\n\t\treturn 0;\n\t}\nvm_fault_error:\n\treturn VM_FAULT_SIGBUS;\t \n}\n#else\nstatic vm_fault_t drm_vm_fault(struct vm_fault *vmf)\n{\n\treturn VM_FAULT_SIGBUS;\n}\n#endif\n\n \nstatic vm_fault_t drm_vm_shm_fault(struct vm_fault *vmf)\n{\n\tstruct vm_area_struct *vma = vmf->vma;\n\tstruct drm_local_map *map = vma->vm_private_data;\n\tunsigned long offset;\n\tunsigned long i;\n\tstruct page *page;\n\n\tif (!map)\n\t\treturn VM_FAULT_SIGBUS;\t \n\n\toffset = vmf->address - vma->vm_start;\n\ti = (unsigned long)map->handle + offset;\n\tpage = vmalloc_to_page((void *)i);\n\tif (!page)\n\t\treturn VM_FAULT_SIGBUS;\n\tget_page(page);\n\tvmf->page = page;\n\n\tDRM_DEBUG(\"shm_fault 0x%lx\\n\", offset);\n\treturn 0;\n}\n\n \nstatic void drm_vm_shm_close(struct vm_area_struct *vma)\n{\n\tstruct drm_file *priv = vma->vm_file->private_data;\n\tstruct drm_device *dev = priv->minor->dev;\n\tstruct drm_vma_entry *pt, *temp;\n\tstruct drm_local_map *map;\n\tstruct drm_map_list *r_list;\n\tint found_maps = 0;\n\n\tDRM_DEBUG(\"0x%08lx,0x%08lx\\n\",\n\t\t  vma->vm_start, vma->vm_end - vma->vm_start);\n\n\tmap = vma->vm_private_data;\n\n\tmutex_lock(&dev->struct_mutex);\n\tlist_for_each_entry_safe(pt, temp, &dev->vmalist, head) {\n\t\tif (pt->vma->vm_private_data == map)\n\t\t\tfound_maps++;\n\t\tif (pt->vma == vma) {\n\t\t\tlist_del(&pt->head);\n\t\t\tkfree(pt);\n\t\t}\n\t}\n\n\t \n\tif (found_maps == 1 && map->flags & _DRM_REMOVABLE) {\n\t\t \n\t\tfound_maps = 0;\n\t\tlist_for_each_entry(r_list, &dev->maplist, head) {\n\t\t\tif (r_list->map == map)\n\t\t\t\tfound_maps++;\n\t\t}\n\n\t\tif (!found_maps) {\n\t\t\tswitch (map->type) {\n\t\t\tcase _DRM_REGISTERS:\n\t\t\tcase _DRM_FRAME_BUFFER:\n\t\t\t\tarch_phys_wc_del(map->mtrr);\n\t\t\t\tiounmap(map->handle);\n\t\t\t\tbreak;\n\t\t\tcase _DRM_SHM:\n\t\t\t\tvfree(map->handle);\n\t\t\t\tbreak;\n\t\t\tcase _DRM_AGP:\n\t\t\tcase _DRM_SCATTER_GATHER:\n\t\t\t\tbreak;\n\t\t\tcase _DRM_CONSISTENT:\n\t\t\t\tdma_free_coherent(dev->dev,\n\t\t\t\t\t\t  map->size,\n\t\t\t\t\t\t  map->handle,\n\t\t\t\t\t\t  map->offset);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tkfree(map);\n\t\t}\n\t}\n\tmutex_unlock(&dev->struct_mutex);\n}\n\n \nstatic vm_fault_t drm_vm_dma_fault(struct vm_fault *vmf)\n{\n\tstruct vm_area_struct *vma = vmf->vma;\n\tstruct drm_file *priv = vma->vm_file->private_data;\n\tstruct drm_device *dev = priv->minor->dev;\n\tstruct drm_device_dma *dma = dev->dma;\n\tunsigned long offset;\n\tunsigned long page_nr;\n\tstruct page *page;\n\n\tif (!dma)\n\t\treturn VM_FAULT_SIGBUS;\t \n\tif (!dma->pagelist)\n\t\treturn VM_FAULT_SIGBUS;\t \n\n\toffset = vmf->address - vma->vm_start;\n\t\t\t\t\t \n\tpage_nr = offset >> PAGE_SHIFT;  \n\tpage = virt_to_page((void *)dma->pagelist[page_nr]);\n\n\tget_page(page);\n\tvmf->page = page;\n\n\tDRM_DEBUG(\"dma_fault 0x%lx (page %lu)\\n\", offset, page_nr);\n\treturn 0;\n}\n\n \nstatic vm_fault_t drm_vm_sg_fault(struct vm_fault *vmf)\n{\n\tstruct vm_area_struct *vma = vmf->vma;\n\tstruct drm_local_map *map = vma->vm_private_data;\n\tstruct drm_file *priv = vma->vm_file->private_data;\n\tstruct drm_device *dev = priv->minor->dev;\n\tstruct drm_sg_mem *entry = dev->sg;\n\tunsigned long offset;\n\tunsigned long map_offset;\n\tunsigned long page_offset;\n\tstruct page *page;\n\n\tif (!entry)\n\t\treturn VM_FAULT_SIGBUS;\t \n\tif (!entry->pagelist)\n\t\treturn VM_FAULT_SIGBUS;\t \n\n\toffset = vmf->address - vma->vm_start;\n\tmap_offset = map->offset - (unsigned long)dev->sg->virtual;\n\tpage_offset = (offset >> PAGE_SHIFT) + (map_offset >> PAGE_SHIFT);\n\tpage = entry->pagelist[page_offset];\n\tget_page(page);\n\tvmf->page = page;\n\n\treturn 0;\n}\n\n \nstatic const struct vm_operations_struct drm_vm_ops = {\n\t.fault = drm_vm_fault,\n\t.open = drm_vm_open,\n\t.close = drm_vm_close,\n};\n\n \nstatic const struct vm_operations_struct drm_vm_shm_ops = {\n\t.fault = drm_vm_shm_fault,\n\t.open = drm_vm_open,\n\t.close = drm_vm_shm_close,\n};\n\n \nstatic const struct vm_operations_struct drm_vm_dma_ops = {\n\t.fault = drm_vm_dma_fault,\n\t.open = drm_vm_open,\n\t.close = drm_vm_close,\n};\n\n \nstatic const struct vm_operations_struct drm_vm_sg_ops = {\n\t.fault = drm_vm_sg_fault,\n\t.open = drm_vm_open,\n\t.close = drm_vm_close,\n};\n\nstatic void drm_vm_open_locked(struct drm_device *dev,\n\t\t\t       struct vm_area_struct *vma)\n{\n\tstruct drm_vma_entry *vma_entry;\n\n\tDRM_DEBUG(\"0x%08lx,0x%08lx\\n\",\n\t\t  vma->vm_start, vma->vm_end - vma->vm_start);\n\n\tvma_entry = kmalloc(sizeof(*vma_entry), GFP_KERNEL);\n\tif (vma_entry) {\n\t\tvma_entry->vma = vma;\n\t\tvma_entry->pid = current->pid;\n\t\tlist_add(&vma_entry->head, &dev->vmalist);\n\t}\n}\n\nstatic void drm_vm_open(struct vm_area_struct *vma)\n{\n\tstruct drm_file *priv = vma->vm_file->private_data;\n\tstruct drm_device *dev = priv->minor->dev;\n\n\tmutex_lock(&dev->struct_mutex);\n\tdrm_vm_open_locked(dev, vma);\n\tmutex_unlock(&dev->struct_mutex);\n}\n\nstatic void drm_vm_close_locked(struct drm_device *dev,\n\t\t\t\tstruct vm_area_struct *vma)\n{\n\tstruct drm_vma_entry *pt, *temp;\n\n\tDRM_DEBUG(\"0x%08lx,0x%08lx\\n\",\n\t\t  vma->vm_start, vma->vm_end - vma->vm_start);\n\n\tlist_for_each_entry_safe(pt, temp, &dev->vmalist, head) {\n\t\tif (pt->vma == vma) {\n\t\t\tlist_del(&pt->head);\n\t\t\tkfree(pt);\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\n \nstatic void drm_vm_close(struct vm_area_struct *vma)\n{\n\tstruct drm_file *priv = vma->vm_file->private_data;\n\tstruct drm_device *dev = priv->minor->dev;\n\n\tmutex_lock(&dev->struct_mutex);\n\tdrm_vm_close_locked(dev, vma);\n\tmutex_unlock(&dev->struct_mutex);\n}\n\n \nstatic int drm_mmap_dma(struct file *filp, struct vm_area_struct *vma)\n{\n\tstruct drm_file *priv = filp->private_data;\n\tstruct drm_device *dev;\n\tstruct drm_device_dma *dma;\n\tunsigned long length = vma->vm_end - vma->vm_start;\n\n\tdev = priv->minor->dev;\n\tdma = dev->dma;\n\tDRM_DEBUG(\"start = 0x%lx, end = 0x%lx, page offset = 0x%lx\\n\",\n\t\t  vma->vm_start, vma->vm_end, vma->vm_pgoff);\n\n\t \n\tif (!dma || (length >> PAGE_SHIFT) != dma->page_count) {\n\t\treturn -EINVAL;\n\t}\n\n\tif (!capable(CAP_SYS_ADMIN) &&\n\t    (dma->flags & _DRM_DMA_USE_PCI_RO)) {\n\t\tvm_flags_clear(vma, VM_WRITE | VM_MAYWRITE);\n#if defined(__i386__) || defined(__x86_64__)\n\t\tpgprot_val(vma->vm_page_prot) &= ~_PAGE_RW;\n#else\n\t\t \n\t\tvma->vm_page_prot =\n\t\t    __pgprot(pte_val\n\t\t\t     (pte_wrprotect\n\t\t\t      (__pte(pgprot_val(vma->vm_page_prot)))));\n#endif\n\t}\n\n\tvma->vm_ops = &drm_vm_dma_ops;\n\n\tvm_flags_set(vma, VM_DONTEXPAND | VM_DONTDUMP);\n\n\tdrm_vm_open_locked(dev, vma);\n\treturn 0;\n}\n\nstatic resource_size_t drm_core_get_reg_ofs(struct drm_device *dev)\n{\n#ifdef __alpha__\n\treturn dev->hose->dense_mem_base;\n#else\n\treturn 0;\n#endif\n}\n\n \nstatic int drm_mmap_locked(struct file *filp, struct vm_area_struct *vma)\n{\n\tstruct drm_file *priv = filp->private_data;\n\tstruct drm_device *dev = priv->minor->dev;\n\tstruct drm_local_map *map = NULL;\n\tresource_size_t offset = 0;\n\tstruct drm_hash_item *hash;\n\n\tDRM_DEBUG(\"start = 0x%lx, end = 0x%lx, page offset = 0x%lx\\n\",\n\t\t  vma->vm_start, vma->vm_end, vma->vm_pgoff);\n\n\tif (!priv->authenticated)\n\t\treturn -EACCES;\n\n\t \n\tif (!vma->vm_pgoff\n#if IS_ENABLED(CONFIG_AGP)\n\t    && (!dev->agp\n\t\t|| dev->agp->agp_info.device->vendor != PCI_VENDOR_ID_APPLE)\n#endif\n\t    )\n\t\treturn drm_mmap_dma(filp, vma);\n\n\tif (drm_ht_find_item(&dev->map_hash, vma->vm_pgoff, &hash)) {\n\t\tDRM_ERROR(\"Could not find map\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tmap = drm_hash_entry(hash, struct drm_map_list, hash)->map;\n\tif (!map || ((map->flags & _DRM_RESTRICTED) && !capable(CAP_SYS_ADMIN)))\n\t\treturn -EPERM;\n\n\t \n\tif (map->size < vma->vm_end - vma->vm_start)\n\t\treturn -EINVAL;\n\n\tif (!capable(CAP_SYS_ADMIN) && (map->flags & _DRM_READ_ONLY)) {\n\t\tvm_flags_clear(vma, VM_WRITE | VM_MAYWRITE);\n#if defined(__i386__) || defined(__x86_64__)\n\t\tpgprot_val(vma->vm_page_prot) &= ~_PAGE_RW;\n#else\n\t\t \n\t\tvma->vm_page_prot =\n\t\t    __pgprot(pte_val\n\t\t\t     (pte_wrprotect\n\t\t\t      (__pte(pgprot_val(vma->vm_page_prot)))));\n#endif\n\t}\n\n\tswitch (map->type) {\n#if !defined(__arm__)\n\tcase _DRM_AGP:\n\t\tif (dev->agp && dev->agp->cant_use_aperture) {\n\t\t\t \n#if defined(__powerpc__)\n\t\t\tvma->vm_page_prot = pgprot_noncached(vma->vm_page_prot);\n#endif\n\t\t\tvma->vm_ops = &drm_vm_ops;\n\t\t\tbreak;\n\t\t}\n\t\tfallthrough;\t \n#endif\n\tcase _DRM_FRAME_BUFFER:\n\tcase _DRM_REGISTERS:\n\t\toffset = drm_core_get_reg_ofs(dev);\n\t\tvma->vm_page_prot = drm_io_prot(map, vma);\n\t\tif (io_remap_pfn_range(vma, vma->vm_start,\n\t\t\t\t       (map->offset + offset) >> PAGE_SHIFT,\n\t\t\t\t       vma->vm_end - vma->vm_start,\n\t\t\t\t       vma->vm_page_prot))\n\t\t\treturn -EAGAIN;\n\t\tDRM_DEBUG(\"   Type = %d; start = 0x%lx, end = 0x%lx,\"\n\t\t\t  \" offset = 0x%llx\\n\",\n\t\t\t  map->type,\n\t\t\t  vma->vm_start, vma->vm_end, (unsigned long long)(map->offset + offset));\n\n\t\tvma->vm_ops = &drm_vm_ops;\n\t\tbreak;\n\tcase _DRM_CONSISTENT:\n\t\t \n\t\tif (remap_pfn_range(vma, vma->vm_start,\n\t\t    page_to_pfn(virt_to_page(map->handle)),\n\t\t    vma->vm_end - vma->vm_start, vma->vm_page_prot))\n\t\t\treturn -EAGAIN;\n\t\tvma->vm_page_prot = drm_dma_prot(map->type, vma);\n\t\tfallthrough;\t \n\tcase _DRM_SHM:\n\t\tvma->vm_ops = &drm_vm_shm_ops;\n\t\tvma->vm_private_data = (void *)map;\n\t\tbreak;\n\tcase _DRM_SCATTER_GATHER:\n\t\tvma->vm_ops = &drm_vm_sg_ops;\n\t\tvma->vm_private_data = (void *)map;\n\t\tvma->vm_page_prot = drm_dma_prot(map->type, vma);\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\t \n\t}\n\tvm_flags_set(vma, VM_DONTEXPAND | VM_DONTDUMP);\n\n\tdrm_vm_open_locked(dev, vma);\n\treturn 0;\n}\n\nint drm_legacy_mmap(struct file *filp, struct vm_area_struct *vma)\n{\n\tstruct drm_file *priv = filp->private_data;\n\tstruct drm_device *dev = priv->minor->dev;\n\tint ret;\n\n\tif (drm_dev_is_unplugged(dev))\n\t\treturn -ENODEV;\n\n\tmutex_lock(&dev->struct_mutex);\n\tret = drm_mmap_locked(filp, vma);\n\tmutex_unlock(&dev->struct_mutex);\n\n\treturn ret;\n}\nEXPORT_SYMBOL(drm_legacy_mmap);\n\n#if IS_ENABLED(CONFIG_DRM_LEGACY)\nvoid drm_legacy_vma_flush(struct drm_device *dev)\n{\n\tstruct drm_vma_entry *vma, *vma_temp;\n\n\t \n\tlist_for_each_entry_safe(vma, vma_temp, &dev->vmalist, head) {\n\t\tlist_del(&vma->head);\n\t\tkfree(vma);\n\t}\n}\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}