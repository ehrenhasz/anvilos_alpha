{
  "module_name": "drm_gem_atomic_helper.c",
  "hash_id": "ce83b39278e816e95f9f43a357d6e8181d365efc08292644bc88b15e2dd1c033",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/drm_gem_atomic_helper.c",
  "human_readable_source": "\n\n#include <linux/dma-resv.h>\n#include <linux/dma-fence-chain.h>\n\n#include <drm/drm_atomic_state_helper.h>\n#include <drm/drm_atomic_uapi.h>\n#include <drm/drm_framebuffer.h>\n#include <drm/drm_gem.h>\n#include <drm/drm_gem_atomic_helper.h>\n#include <drm/drm_gem_framebuffer_helper.h>\n#include <drm/drm_simple_kms_helper.h>\n\n#include \"drm_internal.h\"\n\n \n\n \n\n \nint drm_gem_plane_helper_prepare_fb(struct drm_plane *plane,\n\t\t\t\t    struct drm_plane_state *state)\n{\n\tstruct dma_fence *fence = dma_fence_get(state->fence);\n\tenum dma_resv_usage usage;\n\tsize_t i;\n\tint ret;\n\n\tif (!state->fb)\n\t\treturn 0;\n\n\t \n\tusage = fence ? DMA_RESV_USAGE_KERNEL : DMA_RESV_USAGE_WRITE;\n\n\tfor (i = 0; i < state->fb->format->num_planes; ++i) {\n\t\tstruct drm_gem_object *obj = drm_gem_fb_get_obj(state->fb, i);\n\t\tstruct dma_fence *new;\n\n\t\tif (!obj) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto error;\n\t\t}\n\n\t\tret = dma_resv_get_singleton(obj->resv, usage, &new);\n\t\tif (ret)\n\t\t\tgoto error;\n\n\t\tif (new && fence) {\n\t\t\tstruct dma_fence_chain *chain = dma_fence_chain_alloc();\n\n\t\t\tif (!chain) {\n\t\t\t\tret = -ENOMEM;\n\t\t\t\tgoto error;\n\t\t\t}\n\n\t\t\tdma_fence_chain_init(chain, fence, new, 1);\n\t\t\tfence = &chain->base;\n\n\t\t} else if (new) {\n\t\t\tfence = new;\n\t\t}\n\t}\n\n\tdma_fence_put(state->fence);\n\tstate->fence = fence;\n\treturn 0;\n\nerror:\n\tdma_fence_put(fence);\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(drm_gem_plane_helper_prepare_fb);\n\n \n\n \nvoid\n__drm_gem_duplicate_shadow_plane_state(struct drm_plane *plane,\n\t\t\t\t       struct drm_shadow_plane_state *new_shadow_plane_state)\n{\n\t__drm_atomic_helper_plane_duplicate_state(plane, &new_shadow_plane_state->base);\n}\nEXPORT_SYMBOL(__drm_gem_duplicate_shadow_plane_state);\n\n \nstruct drm_plane_state *\ndrm_gem_duplicate_shadow_plane_state(struct drm_plane *plane)\n{\n\tstruct drm_plane_state *plane_state = plane->state;\n\tstruct drm_shadow_plane_state *new_shadow_plane_state;\n\n\tif (!plane_state)\n\t\treturn NULL;\n\n\tnew_shadow_plane_state = kzalloc(sizeof(*new_shadow_plane_state), GFP_KERNEL);\n\tif (!new_shadow_plane_state)\n\t\treturn NULL;\n\t__drm_gem_duplicate_shadow_plane_state(plane, new_shadow_plane_state);\n\n\treturn &new_shadow_plane_state->base;\n}\nEXPORT_SYMBOL(drm_gem_duplicate_shadow_plane_state);\n\n \nvoid __drm_gem_destroy_shadow_plane_state(struct drm_shadow_plane_state *shadow_plane_state)\n{\n\t__drm_atomic_helper_plane_destroy_state(&shadow_plane_state->base);\n}\nEXPORT_SYMBOL(__drm_gem_destroy_shadow_plane_state);\n\n \nvoid drm_gem_destroy_shadow_plane_state(struct drm_plane *plane,\n\t\t\t\t\tstruct drm_plane_state *plane_state)\n{\n\tstruct drm_shadow_plane_state *shadow_plane_state =\n\t\tto_drm_shadow_plane_state(plane_state);\n\n\t__drm_gem_destroy_shadow_plane_state(shadow_plane_state);\n\tkfree(shadow_plane_state);\n}\nEXPORT_SYMBOL(drm_gem_destroy_shadow_plane_state);\n\n \nvoid __drm_gem_reset_shadow_plane(struct drm_plane *plane,\n\t\t\t\t  struct drm_shadow_plane_state *shadow_plane_state)\n{\n\t__drm_atomic_helper_plane_reset(plane, &shadow_plane_state->base);\n}\nEXPORT_SYMBOL(__drm_gem_reset_shadow_plane);\n\n \nvoid drm_gem_reset_shadow_plane(struct drm_plane *plane)\n{\n\tstruct drm_shadow_plane_state *shadow_plane_state;\n\n\tif (plane->state) {\n\t\tdrm_gem_destroy_shadow_plane_state(plane, plane->state);\n\t\tplane->state = NULL;  \n\t}\n\n\tshadow_plane_state = kzalloc(sizeof(*shadow_plane_state), GFP_KERNEL);\n\tif (!shadow_plane_state)\n\t\treturn;\n\t__drm_gem_reset_shadow_plane(plane, shadow_plane_state);\n}\nEXPORT_SYMBOL(drm_gem_reset_shadow_plane);\n\n \nint drm_gem_begin_shadow_fb_access(struct drm_plane *plane, struct drm_plane_state *plane_state)\n{\n\tstruct drm_shadow_plane_state *shadow_plane_state = to_drm_shadow_plane_state(plane_state);\n\tstruct drm_framebuffer *fb = plane_state->fb;\n\n\tif (!fb)\n\t\treturn 0;\n\n\treturn drm_gem_fb_vmap(fb, shadow_plane_state->map, shadow_plane_state->data);\n}\nEXPORT_SYMBOL(drm_gem_begin_shadow_fb_access);\n\n \nvoid drm_gem_end_shadow_fb_access(struct drm_plane *plane, struct drm_plane_state *plane_state)\n{\n\tstruct drm_shadow_plane_state *shadow_plane_state = to_drm_shadow_plane_state(plane_state);\n\tstruct drm_framebuffer *fb = plane_state->fb;\n\n\tif (!fb)\n\t\treturn;\n\n\tdrm_gem_fb_vunmap(fb, shadow_plane_state->map);\n}\nEXPORT_SYMBOL(drm_gem_end_shadow_fb_access);\n\n \nint drm_gem_simple_kms_begin_shadow_fb_access(struct drm_simple_display_pipe *pipe,\n\t\t\t\t\t      struct drm_plane_state *plane_state)\n{\n\treturn drm_gem_begin_shadow_fb_access(&pipe->plane, plane_state);\n}\nEXPORT_SYMBOL(drm_gem_simple_kms_begin_shadow_fb_access);\n\n \nvoid drm_gem_simple_kms_end_shadow_fb_access(struct drm_simple_display_pipe *pipe,\n\t\t\t\t\t     struct drm_plane_state *plane_state)\n{\n\tdrm_gem_end_shadow_fb_access(&pipe->plane, plane_state);\n}\nEXPORT_SYMBOL(drm_gem_simple_kms_end_shadow_fb_access);\n\n \nvoid drm_gem_simple_kms_reset_shadow_plane(struct drm_simple_display_pipe *pipe)\n{\n\tdrm_gem_reset_shadow_plane(&pipe->plane);\n}\nEXPORT_SYMBOL(drm_gem_simple_kms_reset_shadow_plane);\n\n \nstruct drm_plane_state *\ndrm_gem_simple_kms_duplicate_shadow_plane_state(struct drm_simple_display_pipe *pipe)\n{\n\treturn drm_gem_duplicate_shadow_plane_state(&pipe->plane);\n}\nEXPORT_SYMBOL(drm_gem_simple_kms_duplicate_shadow_plane_state);\n\n \nvoid drm_gem_simple_kms_destroy_shadow_plane_state(struct drm_simple_display_pipe *pipe,\n\t\t\t\t\t\t   struct drm_plane_state *plane_state)\n{\n\tdrm_gem_destroy_shadow_plane_state(&pipe->plane, plane_state);\n}\nEXPORT_SYMBOL(drm_gem_simple_kms_destroy_shadow_plane_state);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}