{
  "module_name": "drm_mode_config.c",
  "hash_id": "bbe3f3a64d05dfa6a4c42443721128e64d20ced775966b25f2d6b852e26c0fb0",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/drm_mode_config.c",
  "human_readable_source": " \n\n#include <linux/uaccess.h>\n\n#include <drm/drm_drv.h>\n#include <drm/drm_encoder.h>\n#include <drm/drm_file.h>\n#include <drm/drm_framebuffer.h>\n#include <drm/drm_managed.h>\n#include <drm/drm_mode_config.h>\n#include <drm/drm_print.h>\n#include <linux/dma-resv.h>\n\n#include \"drm_crtc_internal.h\"\n#include \"drm_internal.h\"\n\nint drm_modeset_register_all(struct drm_device *dev)\n{\n\tint ret;\n\n\tret = drm_plane_register_all(dev);\n\tif (ret)\n\t\tgoto err_plane;\n\n\tret = drm_crtc_register_all(dev);\n\tif  (ret)\n\t\tgoto err_crtc;\n\n\tret = drm_encoder_register_all(dev);\n\tif (ret)\n\t\tgoto err_encoder;\n\n\tret = drm_connector_register_all(dev);\n\tif (ret)\n\t\tgoto err_connector;\n\n\tdrm_debugfs_late_register(dev);\n\n\treturn 0;\n\nerr_connector:\n\tdrm_encoder_unregister_all(dev);\nerr_encoder:\n\tdrm_crtc_unregister_all(dev);\nerr_crtc:\n\tdrm_plane_unregister_all(dev);\nerr_plane:\n\treturn ret;\n}\n\nvoid drm_modeset_unregister_all(struct drm_device *dev)\n{\n\tdrm_connector_unregister_all(dev);\n\tdrm_encoder_unregister_all(dev);\n\tdrm_crtc_unregister_all(dev);\n\tdrm_plane_unregister_all(dev);\n}\n\n \nint drm_mode_getresources(struct drm_device *dev, void *data,\n\t\t\t  struct drm_file *file_priv)\n{\n\tstruct drm_mode_card_res *card_res = data;\n\tstruct drm_framebuffer *fb;\n\tstruct drm_connector *connector;\n\tstruct drm_crtc *crtc;\n\tstruct drm_encoder *encoder;\n\tint count, ret = 0;\n\tuint32_t __user *fb_id;\n\tuint32_t __user *crtc_id;\n\tuint32_t __user *connector_id;\n\tuint32_t __user *encoder_id;\n\tstruct drm_connector_list_iter conn_iter;\n\n\tif (!drm_core_check_feature(dev, DRIVER_MODESET))\n\t\treturn -EOPNOTSUPP;\n\n\tmutex_lock(&file_priv->fbs_lock);\n\tcount = 0;\n\tfb_id = u64_to_user_ptr(card_res->fb_id_ptr);\n\tlist_for_each_entry(fb, &file_priv->fbs, filp_head) {\n\t\tif (count < card_res->count_fbs &&\n\t\t    put_user(fb->base.id, fb_id + count)) {\n\t\t\tmutex_unlock(&file_priv->fbs_lock);\n\t\t\treturn -EFAULT;\n\t\t}\n\t\tcount++;\n\t}\n\tcard_res->count_fbs = count;\n\tmutex_unlock(&file_priv->fbs_lock);\n\n\tcard_res->max_height = dev->mode_config.max_height;\n\tcard_res->min_height = dev->mode_config.min_height;\n\tcard_res->max_width = dev->mode_config.max_width;\n\tcard_res->min_width = dev->mode_config.min_width;\n\n\tcount = 0;\n\tcrtc_id = u64_to_user_ptr(card_res->crtc_id_ptr);\n\tdrm_for_each_crtc(crtc, dev) {\n\t\tif (drm_lease_held(file_priv, crtc->base.id)) {\n\t\t\tif (count < card_res->count_crtcs &&\n\t\t\t    put_user(crtc->base.id, crtc_id + count))\n\t\t\t\treturn -EFAULT;\n\t\t\tcount++;\n\t\t}\n\t}\n\tcard_res->count_crtcs = count;\n\n\tcount = 0;\n\tencoder_id = u64_to_user_ptr(card_res->encoder_id_ptr);\n\tdrm_for_each_encoder(encoder, dev) {\n\t\tif (count < card_res->count_encoders &&\n\t\t    put_user(encoder->base.id, encoder_id + count))\n\t\t\treturn -EFAULT;\n\t\tcount++;\n\t}\n\tcard_res->count_encoders = count;\n\n\tdrm_connector_list_iter_begin(dev, &conn_iter);\n\tcount = 0;\n\tconnector_id = u64_to_user_ptr(card_res->connector_id_ptr);\n\tdrm_for_each_connector_iter(connector, &conn_iter) {\n\t\t \n\t\tif (!file_priv->writeback_connectors &&\n\t\t    (connector->connector_type == DRM_MODE_CONNECTOR_WRITEBACK))\n\t\t\tcontinue;\n\n\t\tif (drm_lease_held(file_priv, connector->base.id)) {\n\t\t\tif (count < card_res->count_connectors &&\n\t\t\t    put_user(connector->base.id, connector_id + count)) {\n\t\t\t\tdrm_connector_list_iter_end(&conn_iter);\n\t\t\t\treturn -EFAULT;\n\t\t\t}\n\t\t\tcount++;\n\t\t}\n\t}\n\tcard_res->count_connectors = count;\n\tdrm_connector_list_iter_end(&conn_iter);\n\n\treturn ret;\n}\n\n \nvoid drm_mode_config_reset(struct drm_device *dev)\n{\n\tstruct drm_crtc *crtc;\n\tstruct drm_plane *plane;\n\tstruct drm_encoder *encoder;\n\tstruct drm_connector *connector;\n\tstruct drm_connector_list_iter conn_iter;\n\n\tdrm_for_each_plane(plane, dev)\n\t\tif (plane->funcs->reset)\n\t\t\tplane->funcs->reset(plane);\n\n\tdrm_for_each_crtc(crtc, dev)\n\t\tif (crtc->funcs->reset)\n\t\t\tcrtc->funcs->reset(crtc);\n\n\tdrm_for_each_encoder(encoder, dev)\n\t\tif (encoder->funcs && encoder->funcs->reset)\n\t\t\tencoder->funcs->reset(encoder);\n\n\tdrm_connector_list_iter_begin(dev, &conn_iter);\n\tdrm_for_each_connector_iter(connector, &conn_iter)\n\t\tif (connector->funcs->reset)\n\t\t\tconnector->funcs->reset(connector);\n\tdrm_connector_list_iter_end(&conn_iter);\n}\nEXPORT_SYMBOL(drm_mode_config_reset);\n\n \nstatic const struct drm_prop_enum_list drm_plane_type_enum_list[] = {\n\t{ DRM_PLANE_TYPE_OVERLAY, \"Overlay\" },\n\t{ DRM_PLANE_TYPE_PRIMARY, \"Primary\" },\n\t{ DRM_PLANE_TYPE_CURSOR, \"Cursor\" },\n};\n\nstatic int drm_mode_create_standard_properties(struct drm_device *dev)\n{\n\tstruct drm_property *prop;\n\tint ret;\n\n\tret = drm_connector_create_standard_properties(dev);\n\tif (ret)\n\t\treturn ret;\n\n\tprop = drm_property_create_enum(dev, DRM_MODE_PROP_IMMUTABLE,\n\t\t\t\t\t\"type\", drm_plane_type_enum_list,\n\t\t\t\t\tARRAY_SIZE(drm_plane_type_enum_list));\n\tif (!prop)\n\t\treturn -ENOMEM;\n\tdev->mode_config.plane_type_property = prop;\n\n\tprop = drm_property_create_range(dev, DRM_MODE_PROP_ATOMIC,\n\t\t\t\"SRC_X\", 0, UINT_MAX);\n\tif (!prop)\n\t\treturn -ENOMEM;\n\tdev->mode_config.prop_src_x = prop;\n\n\tprop = drm_property_create_range(dev, DRM_MODE_PROP_ATOMIC,\n\t\t\t\"SRC_Y\", 0, UINT_MAX);\n\tif (!prop)\n\t\treturn -ENOMEM;\n\tdev->mode_config.prop_src_y = prop;\n\n\tprop = drm_property_create_range(dev, DRM_MODE_PROP_ATOMIC,\n\t\t\t\"SRC_W\", 0, UINT_MAX);\n\tif (!prop)\n\t\treturn -ENOMEM;\n\tdev->mode_config.prop_src_w = prop;\n\n\tprop = drm_property_create_range(dev, DRM_MODE_PROP_ATOMIC,\n\t\t\t\"SRC_H\", 0, UINT_MAX);\n\tif (!prop)\n\t\treturn -ENOMEM;\n\tdev->mode_config.prop_src_h = prop;\n\n\tprop = drm_property_create_signed_range(dev, DRM_MODE_PROP_ATOMIC,\n\t\t\t\"CRTC_X\", INT_MIN, INT_MAX);\n\tif (!prop)\n\t\treturn -ENOMEM;\n\tdev->mode_config.prop_crtc_x = prop;\n\n\tprop = drm_property_create_signed_range(dev, DRM_MODE_PROP_ATOMIC,\n\t\t\t\"CRTC_Y\", INT_MIN, INT_MAX);\n\tif (!prop)\n\t\treturn -ENOMEM;\n\tdev->mode_config.prop_crtc_y = prop;\n\n\tprop = drm_property_create_range(dev, DRM_MODE_PROP_ATOMIC,\n\t\t\t\"CRTC_W\", 0, INT_MAX);\n\tif (!prop)\n\t\treturn -ENOMEM;\n\tdev->mode_config.prop_crtc_w = prop;\n\n\tprop = drm_property_create_range(dev, DRM_MODE_PROP_ATOMIC,\n\t\t\t\"CRTC_H\", 0, INT_MAX);\n\tif (!prop)\n\t\treturn -ENOMEM;\n\tdev->mode_config.prop_crtc_h = prop;\n\n\tprop = drm_property_create_object(dev, DRM_MODE_PROP_ATOMIC,\n\t\t\t\"FB_ID\", DRM_MODE_OBJECT_FB);\n\tif (!prop)\n\t\treturn -ENOMEM;\n\tdev->mode_config.prop_fb_id = prop;\n\n\tprop = drm_property_create_signed_range(dev, DRM_MODE_PROP_ATOMIC,\n\t\t\t\"IN_FENCE_FD\", -1, INT_MAX);\n\tif (!prop)\n\t\treturn -ENOMEM;\n\tdev->mode_config.prop_in_fence_fd = prop;\n\n\tprop = drm_property_create_range(dev, DRM_MODE_PROP_ATOMIC,\n\t\t\t\"OUT_FENCE_PTR\", 0, U64_MAX);\n\tif (!prop)\n\t\treturn -ENOMEM;\n\tdev->mode_config.prop_out_fence_ptr = prop;\n\n\tprop = drm_property_create_object(dev, DRM_MODE_PROP_ATOMIC,\n\t\t\t\"CRTC_ID\", DRM_MODE_OBJECT_CRTC);\n\tif (!prop)\n\t\treturn -ENOMEM;\n\tdev->mode_config.prop_crtc_id = prop;\n\n\tprop = drm_property_create(dev,\n\t\t\tDRM_MODE_PROP_ATOMIC | DRM_MODE_PROP_BLOB,\n\t\t\t\"FB_DAMAGE_CLIPS\", 0);\n\tif (!prop)\n\t\treturn -ENOMEM;\n\tdev->mode_config.prop_fb_damage_clips = prop;\n\n\tprop = drm_property_create_bool(dev, DRM_MODE_PROP_ATOMIC,\n\t\t\t\"ACTIVE\");\n\tif (!prop)\n\t\treturn -ENOMEM;\n\tdev->mode_config.prop_active = prop;\n\n\tprop = drm_property_create(dev,\n\t\t\tDRM_MODE_PROP_ATOMIC | DRM_MODE_PROP_BLOB,\n\t\t\t\"MODE_ID\", 0);\n\tif (!prop)\n\t\treturn -ENOMEM;\n\tdev->mode_config.prop_mode_id = prop;\n\n\tprop = drm_property_create_bool(dev, 0,\n\t\t\t\"VRR_ENABLED\");\n\tif (!prop)\n\t\treturn -ENOMEM;\n\tdev->mode_config.prop_vrr_enabled = prop;\n\n\tprop = drm_property_create(dev,\n\t\t\tDRM_MODE_PROP_BLOB,\n\t\t\t\"DEGAMMA_LUT\", 0);\n\tif (!prop)\n\t\treturn -ENOMEM;\n\tdev->mode_config.degamma_lut_property = prop;\n\n\tprop = drm_property_create_range(dev,\n\t\t\tDRM_MODE_PROP_IMMUTABLE,\n\t\t\t\"DEGAMMA_LUT_SIZE\", 0, UINT_MAX);\n\tif (!prop)\n\t\treturn -ENOMEM;\n\tdev->mode_config.degamma_lut_size_property = prop;\n\n\tprop = drm_property_create(dev,\n\t\t\tDRM_MODE_PROP_BLOB,\n\t\t\t\"CTM\", 0);\n\tif (!prop)\n\t\treturn -ENOMEM;\n\tdev->mode_config.ctm_property = prop;\n\n\tprop = drm_property_create(dev,\n\t\t\tDRM_MODE_PROP_BLOB,\n\t\t\t\"GAMMA_LUT\", 0);\n\tif (!prop)\n\t\treturn -ENOMEM;\n\tdev->mode_config.gamma_lut_property = prop;\n\n\tprop = drm_property_create_range(dev,\n\t\t\tDRM_MODE_PROP_IMMUTABLE,\n\t\t\t\"GAMMA_LUT_SIZE\", 0, UINT_MAX);\n\tif (!prop)\n\t\treturn -ENOMEM;\n\tdev->mode_config.gamma_lut_size_property = prop;\n\n\tprop = drm_property_create(dev,\n\t\t\t\t   DRM_MODE_PROP_IMMUTABLE | DRM_MODE_PROP_BLOB,\n\t\t\t\t   \"IN_FORMATS\", 0);\n\tif (!prop)\n\t\treturn -ENOMEM;\n\tdev->mode_config.modifiers_property = prop;\n\n\treturn 0;\n}\n\nstatic void drm_mode_config_init_release(struct drm_device *dev, void *ptr)\n{\n\tdrm_mode_config_cleanup(dev);\n}\n\n \nint drmm_mode_config_init(struct drm_device *dev)\n{\n\tint ret;\n\n\tmutex_init(&dev->mode_config.mutex);\n\tdrm_modeset_lock_init(&dev->mode_config.connection_mutex);\n\tmutex_init(&dev->mode_config.idr_mutex);\n\tmutex_init(&dev->mode_config.fb_lock);\n\tmutex_init(&dev->mode_config.blob_lock);\n\tINIT_LIST_HEAD(&dev->mode_config.fb_list);\n\tINIT_LIST_HEAD(&dev->mode_config.crtc_list);\n\tINIT_LIST_HEAD(&dev->mode_config.connector_list);\n\tINIT_LIST_HEAD(&dev->mode_config.encoder_list);\n\tINIT_LIST_HEAD(&dev->mode_config.property_list);\n\tINIT_LIST_HEAD(&dev->mode_config.property_blob_list);\n\tINIT_LIST_HEAD(&dev->mode_config.plane_list);\n\tINIT_LIST_HEAD(&dev->mode_config.privobj_list);\n\tidr_init_base(&dev->mode_config.object_idr, 1);\n\tidr_init_base(&dev->mode_config.tile_idr, 1);\n\tida_init(&dev->mode_config.connector_ida);\n\tspin_lock_init(&dev->mode_config.connector_list_lock);\n\n\tinit_llist_head(&dev->mode_config.connector_free_list);\n\tINIT_WORK(&dev->mode_config.connector_free_work, drm_connector_free_work_fn);\n\n\tret = drm_mode_create_standard_properties(dev);\n\tif (ret) {\n\t\tdrm_mode_config_cleanup(dev);\n\t\treturn ret;\n\t}\n\n\t \n\tdev->mode_config.num_fb = 0;\n\tdev->mode_config.num_connector = 0;\n\tdev->mode_config.num_crtc = 0;\n\tdev->mode_config.num_encoder = 0;\n\tdev->mode_config.num_total_plane = 0;\n\n\tif (IS_ENABLED(CONFIG_LOCKDEP)) {\n\t\tstruct drm_modeset_acquire_ctx modeset_ctx;\n\t\tstruct ww_acquire_ctx resv_ctx;\n\t\tstruct dma_resv resv;\n\t\tint ret;\n\n\t\tdma_resv_init(&resv);\n\n\t\tdrm_modeset_acquire_init(&modeset_ctx, 0);\n\t\tret = drm_modeset_lock(&dev->mode_config.connection_mutex,\n\t\t\t\t       &modeset_ctx);\n\t\tif (ret == -EDEADLK)\n\t\t\tret = drm_modeset_backoff(&modeset_ctx);\n\n\t\tww_acquire_init(&resv_ctx, &reservation_ww_class);\n\t\tret = dma_resv_lock(&resv, &resv_ctx);\n\t\tif (ret == -EDEADLK)\n\t\t\tdma_resv_lock_slow(&resv, &resv_ctx);\n\n\t\tdma_resv_unlock(&resv);\n\t\tww_acquire_fini(&resv_ctx);\n\n\t\tdrm_modeset_drop_locks(&modeset_ctx);\n\t\tdrm_modeset_acquire_fini(&modeset_ctx);\n\t\tdma_resv_fini(&resv);\n\t}\n\n\treturn drmm_add_action_or_reset(dev, drm_mode_config_init_release,\n\t\t\t\t\tNULL);\n}\nEXPORT_SYMBOL(drmm_mode_config_init);\n\n \nvoid drm_mode_config_cleanup(struct drm_device *dev)\n{\n\tstruct drm_connector *connector;\n\tstruct drm_connector_list_iter conn_iter;\n\tstruct drm_crtc *crtc, *ct;\n\tstruct drm_encoder *encoder, *enct;\n\tstruct drm_framebuffer *fb, *fbt;\n\tstruct drm_property *property, *pt;\n\tstruct drm_property_blob *blob, *bt;\n\tstruct drm_plane *plane, *plt;\n\n\tlist_for_each_entry_safe(encoder, enct, &dev->mode_config.encoder_list,\n\t\t\t\t head) {\n\t\tencoder->funcs->destroy(encoder);\n\t}\n\n\tdrm_connector_list_iter_begin(dev, &conn_iter);\n\tdrm_for_each_connector_iter(connector, &conn_iter) {\n\t\t \n\t\tdrm_connector_put(connector);\n\t}\n\tdrm_connector_list_iter_end(&conn_iter);\n\t \n\tflush_work(&dev->mode_config.connector_free_work);\n\tif (WARN_ON(!list_empty(&dev->mode_config.connector_list))) {\n\t\tdrm_connector_list_iter_begin(dev, &conn_iter);\n\t\tdrm_for_each_connector_iter(connector, &conn_iter)\n\t\t\tDRM_ERROR(\"connector %s leaked!\\n\", connector->name);\n\t\tdrm_connector_list_iter_end(&conn_iter);\n\t}\n\n\tlist_for_each_entry_safe(property, pt, &dev->mode_config.property_list,\n\t\t\t\t head) {\n\t\tdrm_property_destroy(dev, property);\n\t}\n\n\tlist_for_each_entry_safe(plane, plt, &dev->mode_config.plane_list,\n\t\t\t\t head) {\n\t\tplane->funcs->destroy(plane);\n\t}\n\n\tlist_for_each_entry_safe(crtc, ct, &dev->mode_config.crtc_list, head) {\n\t\tcrtc->funcs->destroy(crtc);\n\t}\n\n\tlist_for_each_entry_safe(blob, bt, &dev->mode_config.property_blob_list,\n\t\t\t\t head_global) {\n\t\tdrm_property_blob_put(blob);\n\t}\n\n\t \n\tWARN_ON(!list_empty(&dev->mode_config.fb_list));\n\tlist_for_each_entry_safe(fb, fbt, &dev->mode_config.fb_list, head) {\n\t\tstruct drm_printer p = drm_debug_printer(\"[leaked fb]\");\n\n\t\tdrm_printf(&p, \"framebuffer[%u]:\\n\", fb->base.id);\n\t\tdrm_framebuffer_print_info(&p, 1, fb);\n\t\tdrm_framebuffer_free(&fb->base.refcount);\n\t}\n\n\tida_destroy(&dev->mode_config.connector_ida);\n\tidr_destroy(&dev->mode_config.tile_idr);\n\tidr_destroy(&dev->mode_config.object_idr);\n\tdrm_modeset_lock_fini(&dev->mode_config.connection_mutex);\n}\nEXPORT_SYMBOL(drm_mode_config_cleanup);\n\nstatic u32 full_encoder_mask(struct drm_device *dev)\n{\n\tstruct drm_encoder *encoder;\n\tu32 encoder_mask = 0;\n\n\tdrm_for_each_encoder(encoder, dev)\n\t\tencoder_mask |= drm_encoder_mask(encoder);\n\n\treturn encoder_mask;\n}\n\n \nstatic void fixup_encoder_possible_clones(struct drm_encoder *encoder)\n{\n\tif (encoder->possible_clones == 0)\n\t\tencoder->possible_clones = drm_encoder_mask(encoder);\n}\n\nstatic void validate_encoder_possible_clones(struct drm_encoder *encoder)\n{\n\tstruct drm_device *dev = encoder->dev;\n\tu32 encoder_mask = full_encoder_mask(dev);\n\tstruct drm_encoder *other;\n\n\tdrm_for_each_encoder(other, dev) {\n\t\tWARN(!!(encoder->possible_clones & drm_encoder_mask(other)) !=\n\t\t     !!(other->possible_clones & drm_encoder_mask(encoder)),\n\t\t     \"possible_clones mismatch: \"\n\t\t     \"[ENCODER:%d:%s] mask=0x%x possible_clones=0x%x vs. \"\n\t\t     \"[ENCODER:%d:%s] mask=0x%x possible_clones=0x%x\\n\",\n\t\t     encoder->base.id, encoder->name,\n\t\t     drm_encoder_mask(encoder), encoder->possible_clones,\n\t\t     other->base.id, other->name,\n\t\t     drm_encoder_mask(other), other->possible_clones);\n\t}\n\n\tWARN((encoder->possible_clones & drm_encoder_mask(encoder)) == 0 ||\n\t     (encoder->possible_clones & ~encoder_mask) != 0,\n\t     \"Bogus possible_clones: \"\n\t     \"[ENCODER:%d:%s] possible_clones=0x%x (full encoder mask=0x%x)\\n\",\n\t     encoder->base.id, encoder->name,\n\t     encoder->possible_clones, encoder_mask);\n}\n\nstatic u32 full_crtc_mask(struct drm_device *dev)\n{\n\tstruct drm_crtc *crtc;\n\tu32 crtc_mask = 0;\n\n\tdrm_for_each_crtc(crtc, dev)\n\t\tcrtc_mask |= drm_crtc_mask(crtc);\n\n\treturn crtc_mask;\n}\n\nstatic void validate_encoder_possible_crtcs(struct drm_encoder *encoder)\n{\n\tu32 crtc_mask = full_crtc_mask(encoder->dev);\n\n\tWARN((encoder->possible_crtcs & crtc_mask) == 0 ||\n\t     (encoder->possible_crtcs & ~crtc_mask) != 0,\n\t     \"Bogus possible_crtcs: \"\n\t     \"[ENCODER:%d:%s] possible_crtcs=0x%x (full crtc mask=0x%x)\\n\",\n\t     encoder->base.id, encoder->name,\n\t     encoder->possible_crtcs, crtc_mask);\n}\n\nvoid drm_mode_config_validate(struct drm_device *dev)\n{\n\tstruct drm_encoder *encoder;\n\tstruct drm_crtc *crtc;\n\tstruct drm_plane *plane;\n\tu32 primary_with_crtc = 0, cursor_with_crtc = 0;\n\tunsigned int num_primary = 0;\n\n\tif (!drm_core_check_feature(dev, DRIVER_MODESET))\n\t\treturn;\n\n\tdrm_for_each_encoder(encoder, dev)\n\t\tfixup_encoder_possible_clones(encoder);\n\n\tdrm_for_each_encoder(encoder, dev) {\n\t\tvalidate_encoder_possible_clones(encoder);\n\t\tvalidate_encoder_possible_crtcs(encoder);\n\t}\n\n\tdrm_for_each_crtc(crtc, dev) {\n\t\tWARN(!crtc->primary, \"Missing primary plane on [CRTC:%d:%s]\\n\",\n\t\t     crtc->base.id, crtc->name);\n\n\t\tWARN(crtc->cursor && crtc->funcs->cursor_set,\n\t\t     \"[CRTC:%d:%s] must not have both a cursor plane and a cursor_set func\",\n\t\t     crtc->base.id, crtc->name);\n\t\tWARN(crtc->cursor && crtc->funcs->cursor_set2,\n\t\t     \"[CRTC:%d:%s] must not have both a cursor plane and a cursor_set2 func\",\n\t\t     crtc->base.id, crtc->name);\n\t\tWARN(crtc->cursor && crtc->funcs->cursor_move,\n\t\t     \"[CRTC:%d:%s] must not have both a cursor plane and a cursor_move func\",\n\t\t     crtc->base.id, crtc->name);\n\n\t\tif (crtc->primary) {\n\t\t\tWARN(!(crtc->primary->possible_crtcs & drm_crtc_mask(crtc)),\n\t\t\t     \"Bogus primary plane possible_crtcs: [PLANE:%d:%s] must be compatible with [CRTC:%d:%s]\\n\",\n\t\t\t     crtc->primary->base.id, crtc->primary->name,\n\t\t\t     crtc->base.id, crtc->name);\n\t\t\tWARN(primary_with_crtc & drm_plane_mask(crtc->primary),\n\t\t\t     \"Primary plane [PLANE:%d:%s] used for multiple CRTCs\",\n\t\t\t     crtc->primary->base.id, crtc->primary->name);\n\t\t\tprimary_with_crtc |= drm_plane_mask(crtc->primary);\n\t\t}\n\t\tif (crtc->cursor) {\n\t\t\tWARN(!(crtc->cursor->possible_crtcs & drm_crtc_mask(crtc)),\n\t\t\t     \"Bogus cursor plane possible_crtcs: [PLANE:%d:%s] must be compatible with [CRTC:%d:%s]\\n\",\n\t\t\t     crtc->cursor->base.id, crtc->cursor->name,\n\t\t\t     crtc->base.id, crtc->name);\n\t\t\tWARN(cursor_with_crtc & drm_plane_mask(crtc->cursor),\n\t\t\t     \"Cursor plane [PLANE:%d:%s] used for multiple CRTCs\",\n\t\t\t     crtc->cursor->base.id, crtc->cursor->name);\n\t\t\tcursor_with_crtc |= drm_plane_mask(crtc->cursor);\n\t\t}\n\t}\n\n\tdrm_for_each_plane(plane, dev) {\n\t\tif (plane->type == DRM_PLANE_TYPE_PRIMARY)\n\t\t\tnum_primary++;\n\t}\n\n\tWARN(num_primary != dev->mode_config.num_crtc,\n\t     \"Must have as many primary planes as there are CRTCs, but have %u primary planes and %u CRTCs\",\n\t     num_primary, dev->mode_config.num_crtc);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}