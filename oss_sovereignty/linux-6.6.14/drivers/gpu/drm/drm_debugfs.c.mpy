{
  "module_name": "drm_debugfs.c",
  "hash_id": "06b1d22610f8d5eba9fb39a1af25922da773a430a271b6a7037e72ef8a91658f",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/drm_debugfs.c",
  "human_readable_source": " \n\n#include <linux/debugfs.h>\n#include <linux/export.h>\n#include <linux/seq_file.h>\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n\n#include <drm/drm_atomic.h>\n#include <drm/drm_auth.h>\n#include <drm/drm_bridge.h>\n#include <drm/drm_client.h>\n#include <drm/drm_debugfs.h>\n#include <drm/drm_device.h>\n#include <drm/drm_drv.h>\n#include <drm/drm_edid.h>\n#include <drm/drm_file.h>\n#include <drm/drm_gem.h>\n#include <drm/drm_managed.h>\n#include <drm/drm_gpuva_mgr.h>\n\n#include \"drm_crtc_internal.h\"\n#include \"drm_internal.h\"\n\n#if defined(CONFIG_DEBUG_FS)\n\n \n\nstatic int drm_name_info(struct seq_file *m, void *data)\n{\n\tstruct drm_debugfs_entry *entry = m->private;\n\tstruct drm_device *dev = entry->dev;\n\tstruct drm_master *master;\n\n\tmutex_lock(&dev->master_mutex);\n\tmaster = dev->master;\n\tseq_printf(m, \"%s\", dev->driver->name);\n\tif (dev->dev)\n\t\tseq_printf(m, \" dev=%s\", dev_name(dev->dev));\n\tif (master && master->unique)\n\t\tseq_printf(m, \" master=%s\", master->unique);\n\tif (dev->unique)\n\t\tseq_printf(m, \" unique=%s\", dev->unique);\n\tseq_printf(m, \"\\n\");\n\tmutex_unlock(&dev->master_mutex);\n\n\treturn 0;\n}\n\nstatic int drm_clients_info(struct seq_file *m, void *data)\n{\n\tstruct drm_debugfs_entry *entry = m->private;\n\tstruct drm_device *dev = entry->dev;\n\tstruct drm_file *priv;\n\tkuid_t uid;\n\n\tseq_printf(m,\n\t\t   \"%20s %5s %3s master a %5s %10s\\n\",\n\t\t   \"command\",\n\t\t   \"tgid\",\n\t\t   \"dev\",\n\t\t   \"uid\",\n\t\t   \"magic\");\n\n\t \n\tmutex_lock(&dev->filelist_mutex);\n\tlist_for_each_entry_reverse(priv, &dev->filelist, lhead) {\n\t\tbool is_current_master = drm_is_current_master(priv);\n\t\tstruct task_struct *task;\n\t\tstruct pid *pid;\n\n\t\trcu_read_lock();  \n\t\tpid = rcu_dereference(priv->pid);\n\t\ttask = pid_task(pid, PIDTYPE_TGID);\n\t\tuid = task ? __task_cred(task)->euid : GLOBAL_ROOT_UID;\n\t\tseq_printf(m, \"%20s %5d %3d   %c    %c %5d %10u\\n\",\n\t\t\t   task ? task->comm : \"<unknown>\",\n\t\t\t   pid_vnr(pid),\n\t\t\t   priv->minor->index,\n\t\t\t   is_current_master ? 'y' : 'n',\n\t\t\t   priv->authenticated ? 'y' : 'n',\n\t\t\t   from_kuid_munged(seq_user_ns(m), uid),\n\t\t\t   priv->magic);\n\t\trcu_read_unlock();\n\t}\n\tmutex_unlock(&dev->filelist_mutex);\n\treturn 0;\n}\n\nstatic int drm_gem_one_name_info(int id, void *ptr, void *data)\n{\n\tstruct drm_gem_object *obj = ptr;\n\tstruct seq_file *m = data;\n\n\tseq_printf(m, \"%6d %8zd %7d %8d\\n\",\n\t\t   obj->name, obj->size,\n\t\t   obj->handle_count,\n\t\t   kref_read(&obj->refcount));\n\treturn 0;\n}\n\nstatic int drm_gem_name_info(struct seq_file *m, void *data)\n{\n\tstruct drm_debugfs_entry *entry = m->private;\n\tstruct drm_device *dev = entry->dev;\n\n\tseq_printf(m, \"  name     size handles refcount\\n\");\n\n\tmutex_lock(&dev->object_name_lock);\n\tidr_for_each(&dev->object_name_idr, drm_gem_one_name_info, m);\n\tmutex_unlock(&dev->object_name_lock);\n\n\treturn 0;\n}\n\nstatic const struct drm_debugfs_info drm_debugfs_list[] = {\n\t{\"name\", drm_name_info, 0},\n\t{\"clients\", drm_clients_info, 0},\n\t{\"gem_names\", drm_gem_name_info, DRIVER_GEM},\n};\n#define DRM_DEBUGFS_ENTRIES ARRAY_SIZE(drm_debugfs_list)\n\n\nstatic int drm_debugfs_open(struct inode *inode, struct file *file)\n{\n\tstruct drm_info_node *node = inode->i_private;\n\n\treturn single_open(file, node->info_ent->show, node);\n}\n\nstatic int drm_debugfs_entry_open(struct inode *inode, struct file *file)\n{\n\tstruct drm_debugfs_entry *entry = inode->i_private;\n\tstruct drm_debugfs_info *node = &entry->file;\n\n\treturn single_open(file, node->show, entry);\n}\n\nstatic const struct file_operations drm_debugfs_entry_fops = {\n\t.owner = THIS_MODULE,\n\t.open = drm_debugfs_entry_open,\n\t.read = seq_read,\n\t.llseek = seq_lseek,\n\t.release = single_release,\n};\n\nstatic const struct file_operations drm_debugfs_fops = {\n\t.owner = THIS_MODULE,\n\t.open = drm_debugfs_open,\n\t.read = seq_read,\n\t.llseek = seq_lseek,\n\t.release = single_release,\n};\n\n \nint drm_debugfs_gpuva_info(struct seq_file *m,\n\t\t\t   struct drm_gpuva_manager *mgr)\n{\n\tstruct drm_gpuva *va, *kva = &mgr->kernel_alloc_node;\n\n\tif (!mgr->name)\n\t\treturn -ENODEV;\n\n\tseq_printf(m, \"DRM GPU VA space (%s) [0x%016llx;0x%016llx]\\n\",\n\t\t   mgr->name, mgr->mm_start, mgr->mm_start + mgr->mm_range);\n\tseq_printf(m, \"Kernel reserved node [0x%016llx;0x%016llx]\\n\",\n\t\t   kva->va.addr, kva->va.addr + kva->va.range);\n\tseq_puts(m, \"\\n\");\n\tseq_puts(m, \" VAs | start              | range              | end                | object             | object offset\\n\");\n\tseq_puts(m, \"-------------------------------------------------------------------------------------------------------------\\n\");\n\tdrm_gpuva_for_each_va(va, mgr) {\n\t\tif (unlikely(va == kva))\n\t\t\tcontinue;\n\n\t\tseq_printf(m, \"     | 0x%016llx | 0x%016llx | 0x%016llx | 0x%016llx | 0x%016llx\\n\",\n\t\t\t   va->va.addr, va->va.range, va->va.addr + va->va.range,\n\t\t\t   (u64)(uintptr_t)va->gem.obj, va->gem.offset);\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL(drm_debugfs_gpuva_info);\n\n \nvoid drm_debugfs_create_files(const struct drm_info_list *files, int count,\n\t\t\t      struct dentry *root, struct drm_minor *minor)\n{\n\tstruct drm_device *dev = minor->dev;\n\tstruct drm_info_node *tmp;\n\tint i;\n\n\tfor (i = 0; i < count; i++) {\n\t\tu32 features = files[i].driver_features;\n\n\t\tif (features && !drm_core_check_all_features(dev, features))\n\t\t\tcontinue;\n\n\t\ttmp = kmalloc(sizeof(struct drm_info_node), GFP_KERNEL);\n\t\tif (tmp == NULL)\n\t\t\tcontinue;\n\n\t\ttmp->minor = minor;\n\t\ttmp->dent = debugfs_create_file(files[i].name,\n\t\t\t\t\t\t0444, root, tmp,\n\t\t\t\t\t\t&drm_debugfs_fops);\n\t\ttmp->info_ent = &files[i];\n\n\t\tmutex_lock(&minor->debugfs_lock);\n\t\tlist_add(&tmp->list, &minor->debugfs_list);\n\t\tmutex_unlock(&minor->debugfs_lock);\n\t}\n}\nEXPORT_SYMBOL(drm_debugfs_create_files);\n\nint drm_debugfs_init(struct drm_minor *minor, int minor_id,\n\t\t     struct dentry *root)\n{\n\tstruct drm_device *dev = minor->dev;\n\tstruct drm_debugfs_entry *entry, *tmp;\n\tchar name[64];\n\n\tINIT_LIST_HEAD(&minor->debugfs_list);\n\tmutex_init(&minor->debugfs_lock);\n\tsprintf(name, \"%d\", minor_id);\n\tminor->debugfs_root = debugfs_create_dir(name, root);\n\n\tdrm_debugfs_add_files(minor->dev, drm_debugfs_list, DRM_DEBUGFS_ENTRIES);\n\n\tif (drm_drv_uses_atomic_modeset(dev)) {\n\t\tdrm_atomic_debugfs_init(minor);\n\t\tdrm_bridge_debugfs_init(minor);\n\t}\n\n\tif (drm_core_check_feature(dev, DRIVER_MODESET)) {\n\t\tdrm_framebuffer_debugfs_init(minor);\n\n\t\tdrm_client_debugfs_init(minor);\n\t}\n\n\tif (dev->driver->debugfs_init)\n\t\tdev->driver->debugfs_init(minor);\n\n\tlist_for_each_entry_safe(entry, tmp, &dev->debugfs_list, list) {\n\t\tdebugfs_create_file(entry->file.name, 0444,\n\t\t\t\t    minor->debugfs_root, entry, &drm_debugfs_entry_fops);\n\t\tlist_del(&entry->list);\n\t}\n\n\treturn 0;\n}\n\nvoid drm_debugfs_late_register(struct drm_device *dev)\n{\n\tstruct drm_minor *minor = dev->primary;\n\tstruct drm_debugfs_entry *entry, *tmp;\n\n\tif (!minor)\n\t\treturn;\n\n\tlist_for_each_entry_safe(entry, tmp, &dev->debugfs_list, list) {\n\t\tdebugfs_create_file(entry->file.name, 0444,\n\t\t\t\t    minor->debugfs_root, entry, &drm_debugfs_entry_fops);\n\t\tlist_del(&entry->list);\n\t}\n}\n\nint drm_debugfs_remove_files(const struct drm_info_list *files, int count,\n\t\t\t     struct drm_minor *minor)\n{\n\tstruct list_head *pos, *q;\n\tstruct drm_info_node *tmp;\n\tint i;\n\n\tmutex_lock(&minor->debugfs_lock);\n\tfor (i = 0; i < count; i++) {\n\t\tlist_for_each_safe(pos, q, &minor->debugfs_list) {\n\t\t\ttmp = list_entry(pos, struct drm_info_node, list);\n\t\t\tif (tmp->info_ent == &files[i]) {\n\t\t\t\tdebugfs_remove(tmp->dent);\n\t\t\t\tlist_del(pos);\n\t\t\t\tkfree(tmp);\n\t\t\t}\n\t\t}\n\t}\n\tmutex_unlock(&minor->debugfs_lock);\n\treturn 0;\n}\nEXPORT_SYMBOL(drm_debugfs_remove_files);\n\nstatic void drm_debugfs_remove_all_files(struct drm_minor *minor)\n{\n\tstruct drm_info_node *node, *tmp;\n\n\tmutex_lock(&minor->debugfs_lock);\n\tlist_for_each_entry_safe(node, tmp, &minor->debugfs_list, list) {\n\t\tdebugfs_remove(node->dent);\n\t\tlist_del(&node->list);\n\t\tkfree(node);\n\t}\n\tmutex_unlock(&minor->debugfs_lock);\n}\n\nvoid drm_debugfs_cleanup(struct drm_minor *minor)\n{\n\tif (!minor->debugfs_root)\n\t\treturn;\n\n\tdrm_debugfs_remove_all_files(minor);\n\n\tdebugfs_remove_recursive(minor->debugfs_root);\n\tminor->debugfs_root = NULL;\n}\n\n \nvoid drm_debugfs_add_file(struct drm_device *dev, const char *name,\n\t\t\t  int (*show)(struct seq_file*, void*), void *data)\n{\n\tstruct drm_debugfs_entry *entry = drmm_kzalloc(dev, sizeof(*entry), GFP_KERNEL);\n\n\tif (!entry)\n\t\treturn;\n\n\tentry->file.name = name;\n\tentry->file.show = show;\n\tentry->file.data = data;\n\tentry->dev = dev;\n\n\tmutex_lock(&dev->debugfs_mutex);\n\tlist_add(&entry->list, &dev->debugfs_list);\n\tmutex_unlock(&dev->debugfs_mutex);\n}\nEXPORT_SYMBOL(drm_debugfs_add_file);\n\n \nvoid drm_debugfs_add_files(struct drm_device *dev, const struct drm_debugfs_info *files, int count)\n{\n\tint i;\n\n\tfor (i = 0; i < count; i++)\n\t\tdrm_debugfs_add_file(dev, files[i].name, files[i].show, files[i].data);\n}\nEXPORT_SYMBOL(drm_debugfs_add_files);\n\nstatic int connector_show(struct seq_file *m, void *data)\n{\n\tstruct drm_connector *connector = m->private;\n\n\tseq_printf(m, \"%s\\n\", drm_get_connector_force_name(connector->force));\n\n\treturn 0;\n}\n\nstatic int connector_open(struct inode *inode, struct file *file)\n{\n\tstruct drm_connector *dev = inode->i_private;\n\n\treturn single_open(file, connector_show, dev);\n}\n\nstatic ssize_t connector_write(struct file *file, const char __user *ubuf,\n\t\t\t       size_t len, loff_t *offp)\n{\n\tstruct seq_file *m = file->private_data;\n\tstruct drm_connector *connector = m->private;\n\tchar buf[12];\n\n\tif (len > sizeof(buf) - 1)\n\t\treturn -EINVAL;\n\n\tif (copy_from_user(buf, ubuf, len))\n\t\treturn -EFAULT;\n\n\tbuf[len] = '\\0';\n\n\tif (sysfs_streq(buf, \"on\"))\n\t\tconnector->force = DRM_FORCE_ON;\n\telse if (sysfs_streq(buf, \"digital\"))\n\t\tconnector->force = DRM_FORCE_ON_DIGITAL;\n\telse if (sysfs_streq(buf, \"off\"))\n\t\tconnector->force = DRM_FORCE_OFF;\n\telse if (sysfs_streq(buf, \"unspecified\"))\n\t\tconnector->force = DRM_FORCE_UNSPECIFIED;\n\telse\n\t\treturn -EINVAL;\n\n\treturn len;\n}\n\nstatic int edid_show(struct seq_file *m, void *data)\n{\n\treturn drm_edid_override_show(m->private, m);\n}\n\nstatic int edid_open(struct inode *inode, struct file *file)\n{\n\tstruct drm_connector *dev = inode->i_private;\n\n\treturn single_open(file, edid_show, dev);\n}\n\nstatic ssize_t edid_write(struct file *file, const char __user *ubuf,\n\t\t\t  size_t len, loff_t *offp)\n{\n\tstruct seq_file *m = file->private_data;\n\tstruct drm_connector *connector = m->private;\n\tchar *buf;\n\tint ret;\n\n\tbuf = memdup_user(ubuf, len);\n\tif (IS_ERR(buf))\n\t\treturn PTR_ERR(buf);\n\n\tif (len == 5 && !strncmp(buf, \"reset\", 5))\n\t\tret = drm_edid_override_reset(connector);\n\telse\n\t\tret = drm_edid_override_set(connector, buf, len);\n\n\tkfree(buf);\n\n\treturn ret ? ret : len;\n}\n\n \nstatic int vrr_range_show(struct seq_file *m, void *data)\n{\n\tstruct drm_connector *connector = m->private;\n\n\tif (connector->status != connector_status_connected)\n\t\treturn -ENODEV;\n\n\tseq_printf(m, \"Min: %u\\n\", connector->display_info.monitor_range.min_vfreq);\n\tseq_printf(m, \"Max: %u\\n\", connector->display_info.monitor_range.max_vfreq);\n\n\treturn 0;\n}\nDEFINE_SHOW_ATTRIBUTE(vrr_range);\n\n \nstatic int output_bpc_show(struct seq_file *m, void *data)\n{\n\tstruct drm_connector *connector = m->private;\n\n\tif (connector->status != connector_status_connected)\n\t\treturn -ENODEV;\n\n\tseq_printf(m, \"Maximum: %u\\n\", connector->display_info.bpc);\n\n\treturn 0;\n}\nDEFINE_SHOW_ATTRIBUTE(output_bpc);\n\nstatic const struct file_operations drm_edid_fops = {\n\t.owner = THIS_MODULE,\n\t.open = edid_open,\n\t.read = seq_read,\n\t.llseek = seq_lseek,\n\t.release = single_release,\n\t.write = edid_write\n};\n\n\nstatic const struct file_operations drm_connector_fops = {\n\t.owner = THIS_MODULE,\n\t.open = connector_open,\n\t.read = seq_read,\n\t.llseek = seq_lseek,\n\t.release = single_release,\n\t.write = connector_write\n};\n\nvoid drm_debugfs_connector_add(struct drm_connector *connector)\n{\n\tstruct drm_minor *minor = connector->dev->primary;\n\tstruct dentry *root;\n\n\tif (!minor->debugfs_root)\n\t\treturn;\n\n\troot = debugfs_create_dir(connector->name, minor->debugfs_root);\n\tconnector->debugfs_entry = root;\n\n\t \n\tdebugfs_create_file(\"force\", 0644, root, connector,\n\t\t\t    &drm_connector_fops);\n\n\t \n\tdebugfs_create_file(\"edid_override\", 0644, root, connector,\n\t\t\t    &drm_edid_fops);\n\n\t \n\tdebugfs_create_file(\"vrr_range\", 0444, root, connector,\n\t\t\t    &vrr_range_fops);\n\n\t \n\tdebugfs_create_file(\"output_bpc\", 0444, root, connector,\n\t\t\t    &output_bpc_fops);\n\n\tif (connector->funcs->debugfs_init)\n\t\tconnector->funcs->debugfs_init(connector, root);\n}\n\nvoid drm_debugfs_connector_remove(struct drm_connector *connector)\n{\n\tif (!connector->debugfs_entry)\n\t\treturn;\n\n\tdebugfs_remove_recursive(connector->debugfs_entry);\n\n\tconnector->debugfs_entry = NULL;\n}\n\nvoid drm_debugfs_crtc_add(struct drm_crtc *crtc)\n{\n\tstruct drm_minor *minor = crtc->dev->primary;\n\tstruct dentry *root;\n\tchar *name;\n\n\tname = kasprintf(GFP_KERNEL, \"crtc-%d\", crtc->index);\n\tif (!name)\n\t\treturn;\n\n\troot = debugfs_create_dir(name, minor->debugfs_root);\n\tkfree(name);\n\n\tcrtc->debugfs_entry = root;\n\n\tdrm_debugfs_crtc_crc_add(crtc);\n}\n\nvoid drm_debugfs_crtc_remove(struct drm_crtc *crtc)\n{\n\tdebugfs_remove_recursive(crtc->debugfs_entry);\n\tcrtc->debugfs_entry = NULL;\n}\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}