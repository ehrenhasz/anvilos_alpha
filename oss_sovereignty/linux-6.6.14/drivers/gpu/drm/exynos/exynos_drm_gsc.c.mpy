{
  "module_name": "exynos_drm_gsc.c",
  "hash_id": "0ec5f14510433128cf34863064aeeadf291ad8613f75ffebf20616f946f81cc7",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/exynos/exynos_drm_gsc.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/component.h>\n#include <linux/kernel.h>\n#include <linux/mfd/syscon.h>\n#include <linux/of_device.h>\n#include <linux/platform_device.h>\n#include <linux/pm_runtime.h>\n#include <linux/regmap.h>\n\n#include <drm/drm_fourcc.h>\n#include <drm/drm_print.h>\n#include <drm/exynos_drm.h>\n\n#include \"exynos_drm_drv.h\"\n#include \"exynos_drm_ipp.h\"\n#include \"regs-gsc.h\"\n\n \n\n\n#define GSC_MAX_CLOCKS\t8\n#define GSC_MAX_SRC\t\t4\n#define GSC_MAX_DST\t\t16\n#define GSC_RESET_TIMEOUT\t50\n#define GSC_BUF_STOP\t1\n#define GSC_BUF_START\t2\n#define GSC_REG_SZ\t\t16\n#define GSC_WIDTH_ITU_709\t1280\n#define GSC_SC_UP_MAX_RATIO\t\t65536\n#define GSC_SC_DOWN_RATIO_7_8\t\t74898\n#define GSC_SC_DOWN_RATIO_6_8\t\t87381\n#define GSC_SC_DOWN_RATIO_5_8\t\t104857\n#define GSC_SC_DOWN_RATIO_4_8\t\t131072\n#define GSC_SC_DOWN_RATIO_3_8\t\t174762\n#define GSC_SC_DOWN_RATIO_2_8\t\t262144\n#define GSC_CROP_MAX\t8192\n#define GSC_CROP_MIN\t32\n#define GSC_SCALE_MAX\t4224\n#define GSC_SCALE_MIN\t32\n#define GSC_COEF_RATIO\t7\n#define GSC_COEF_PHASE\t9\n#define GSC_COEF_ATTR\t16\n#define GSC_COEF_H_8T\t8\n#define GSC_COEF_V_4T\t4\n#define GSC_COEF_DEPTH\t3\n#define GSC_AUTOSUSPEND_DELAY\t\t2000\n\n#define get_gsc_context(dev)\tdev_get_drvdata(dev)\n#define gsc_read(offset)\t\treadl(ctx->regs + (offset))\n#define gsc_write(cfg, offset)\twritel(cfg, ctx->regs + (offset))\n\n \nstruct gsc_scaler {\n\tbool\trange;\n\tu32\tpre_shfactor;\n\tu32\tpre_hratio;\n\tu32\tpre_vratio;\n\tunsigned long main_hratio;\n\tunsigned long main_vratio;\n};\n\n \nstruct gsc_context {\n\tstruct exynos_drm_ipp ipp;\n\tstruct drm_device *drm_dev;\n\tvoid\t\t*dma_priv;\n\tstruct device\t*dev;\n\tstruct exynos_drm_ipp_task\t*task;\n\tstruct exynos_drm_ipp_formats\t*formats;\n\tunsigned int\t\t\tnum_formats;\n\n\tvoid __iomem\t*regs;\n\tconst char\t**clk_names;\n\tstruct clk\t*clocks[GSC_MAX_CLOCKS];\n\tint\t\tnum_clocks;\n\tstruct gsc_scaler\tsc;\n\tint\tid;\n\tint\tirq;\n\tbool\trotation;\n};\n\n \nstruct gsc_driverdata {\n\tconst struct drm_exynos_ipp_limit *limits;\n\tint\t\tnum_limits;\n\tconst char\t*clk_names[GSC_MAX_CLOCKS];\n\tint\t\tnum_clocks;\n};\n\n \nstatic const int h_coef_8t[GSC_COEF_RATIO][GSC_COEF_ATTR][GSC_COEF_H_8T] = {\n\t{\t \n\t\t{  0,  0,   0, 128,   0,   0,  0,  0 },\n\t\t{ -1,  2,  -6, 127,   7,  -2,  1,  0 },\n\t\t{ -1,  4, -12, 125,  16,  -5,  1,  0 },\n\t\t{ -1,  5, -15, 120,  25,  -8,  2,  0 },\n\t\t{ -1,  6, -18, 114,  35, -10,  3, -1 },\n\t\t{ -1,  6, -20, 107,  46, -13,  4, -1 },\n\t\t{ -2,  7, -21,  99,  57, -16,  5, -1 },\n\t\t{ -1,  6, -20,  89,  68, -18,  5, -1 },\n\t\t{ -1,  6, -20,  79,  79, -20,  6, -1 },\n\t\t{ -1,  5, -18,  68,  89, -20,  6, -1 },\n\t\t{ -1,  5, -16,  57,  99, -21,  7, -2 },\n\t\t{ -1,  4, -13,  46, 107, -20,  6, -1 },\n\t\t{ -1,  3, -10,  35, 114, -18,  6, -1 },\n\t\t{  0,  2,  -8,  25, 120, -15,  5, -1 },\n\t\t{  0,  1,  -5,  16, 125, -12,  4, -1 },\n\t\t{  0,  1,  -2,   7, 127,  -6,  2, -1 }\n\t}, {\t \n\t\t{  3, -8,  14, 111,  13,  -8,  3,  0 },\n\t\t{  2, -6,   7, 112,  21, -10,  3, -1 },\n\t\t{  2, -4,   1, 110,  28, -12,  4, -1 },\n\t\t{  1, -2,  -3, 106,  36, -13,  4, -1 },\n\t\t{  1, -1,  -7, 103,  44, -15,  4, -1 },\n\t\t{  1,  1, -11,  97,  53, -16,  4, -1 },\n\t\t{  0,  2, -13,  91,  61, -16,  4, -1 },\n\t\t{  0,  3, -15,  85,  69, -17,  4, -1 },\n\t\t{  0,  3, -16,  77,  77, -16,  3,  0 },\n\t\t{ -1,  4, -17,  69,  85, -15,  3,  0 },\n\t\t{ -1,  4, -16,  61,  91, -13,  2,  0 },\n\t\t{ -1,  4, -16,  53,  97, -11,  1,  1 },\n\t\t{ -1,  4, -15,  44, 103,  -7, -1,  1 },\n\t\t{ -1,  4, -13,  36, 106,  -3, -2,  1 },\n\t\t{ -1,  4, -12,  28, 110,   1, -4,  2 },\n\t\t{ -1,  3, -10,  21, 112,   7, -6,  2 }\n\t}, {\t \n\t\t{ 2, -11,  25,  96, 25, -11,   2,  0 },\n\t\t{ 2, -10,  19,  96, 31, -12,   2,  0 },\n\t\t{ 2,  -9,  14,  94, 37, -12,   2,  0 },\n\t\t{ 2,  -8,  10,  92, 43, -12,   1,  0 },\n\t\t{ 2,  -7,   5,  90, 49, -12,   1,  0 },\n\t\t{ 2,  -5,   1,  86, 55, -12,   0,  1 },\n\t\t{ 2,  -4,  -2,  82, 61, -11,  -1,  1 },\n\t\t{ 1,  -3,  -5,  77, 67,  -9,  -1,  1 },\n\t\t{ 1,  -2,  -7,  72, 72,  -7,  -2,  1 },\n\t\t{ 1,  -1,  -9,  67, 77,  -5,  -3,  1 },\n\t\t{ 1,  -1, -11,  61, 82,  -2,  -4,  2 },\n\t\t{ 1,   0, -12,  55, 86,   1,  -5,  2 },\n\t\t{ 0,   1, -12,  49, 90,   5,  -7,  2 },\n\t\t{ 0,   1, -12,  43, 92,  10,  -8,  2 },\n\t\t{ 0,   2, -12,  37, 94,  14,  -9,  2 },\n\t\t{ 0,   2, -12,  31, 96,  19, -10,  2 }\n\t}, {\t \n\t\t{ -1,  -8, 33,  80, 33,  -8,  -1,  0 },\n\t\t{ -1,  -8, 28,  80, 37,  -7,  -2,  1 },\n\t\t{  0,  -8, 24,  79, 41,  -7,  -2,  1 },\n\t\t{  0,  -8, 20,  78, 46,  -6,  -3,  1 },\n\t\t{  0,  -8, 16,  76, 50,  -4,  -3,  1 },\n\t\t{  0,  -7, 13,  74, 54,  -3,  -4,  1 },\n\t\t{  1,  -7, 10,  71, 58,  -1,  -5,  1 },\n\t\t{  1,  -6,  6,  68, 62,   1,  -5,  1 },\n\t\t{  1,  -6,  4,  65, 65,   4,  -6,  1 },\n\t\t{  1,  -5,  1,  62, 68,   6,  -6,  1 },\n\t\t{  1,  -5, -1,  58, 71,  10,  -7,  1 },\n\t\t{  1,  -4, -3,  54, 74,  13,  -7,  0 },\n\t\t{  1,  -3, -4,  50, 76,  16,  -8,  0 },\n\t\t{  1,  -3, -6,  46, 78,  20,  -8,  0 },\n\t\t{  1,  -2, -7,  41, 79,  24,  -8,  0 },\n\t\t{  1,  -2, -7,  37, 80,  28,  -8, -1 }\n\t}, {\t \n\t\t{ -3,   0, 35,  64, 35,   0,  -3,  0 },\n\t\t{ -3,  -1, 32,  64, 38,   1,  -3,  0 },\n\t\t{ -2,  -2, 29,  63, 41,   2,  -3,  0 },\n\t\t{ -2,  -3, 27,  63, 43,   4,  -4,  0 },\n\t\t{ -2,  -3, 24,  61, 46,   6,  -4,  0 },\n\t\t{ -2,  -3, 21,  60, 49,   7,  -4,  0 },\n\t\t{ -1,  -4, 19,  59, 51,   9,  -4, -1 },\n\t\t{ -1,  -4, 16,  57, 53,  12,  -4, -1 },\n\t\t{ -1,  -4, 14,  55, 55,  14,  -4, -1 },\n\t\t{ -1,  -4, 12,  53, 57,  16,  -4, -1 },\n\t\t{ -1,  -4,  9,  51, 59,  19,  -4, -1 },\n\t\t{  0,  -4,  7,  49, 60,  21,  -3, -2 },\n\t\t{  0,  -4,  6,  46, 61,  24,  -3, -2 },\n\t\t{  0,  -4,  4,  43, 63,  27,  -3, -2 },\n\t\t{  0,  -3,  2,  41, 63,  29,  -2, -2 },\n\t\t{  0,  -3,  1,  38, 64,  32,  -1, -3 }\n\t}, {\t \n\t\t{ -1,   8, 33,  48, 33,   8,  -1,  0 },\n\t\t{ -1,   7, 31,  49, 35,   9,  -1, -1 },\n\t\t{ -1,   6, 30,  49, 36,  10,  -1, -1 },\n\t\t{ -1,   5, 28,  48, 38,  12,  -1, -1 },\n\t\t{ -1,   4, 26,  48, 39,  13,   0, -1 },\n\t\t{ -1,   3, 24,  47, 41,  15,   0, -1 },\n\t\t{ -1,   2, 23,  47, 42,  16,   0, -1 },\n\t\t{ -1,   2, 21,  45, 43,  18,   1, -1 },\n\t\t{ -1,   1, 19,  45, 45,  19,   1, -1 },\n\t\t{ -1,   1, 18,  43, 45,  21,   2, -1 },\n\t\t{ -1,   0, 16,  42, 47,  23,   2, -1 },\n\t\t{ -1,   0, 15,  41, 47,  24,   3, -1 },\n\t\t{ -1,   0, 13,  39, 48,  26,   4, -1 },\n\t\t{ -1,  -1, 12,  38, 48,  28,   5, -1 },\n\t\t{ -1,  -1, 10,  36, 49,  30,   6, -1 },\n\t\t{ -1,  -1,  9,  35, 49,  31,   7, -1 }\n\t}, {\t \n\t\t{  2,  13, 30,  38, 30,  13,   2,  0 },\n\t\t{  2,  12, 29,  38, 30,  14,   3,  0 },\n\t\t{  2,  11, 28,  38, 31,  15,   3,  0 },\n\t\t{  2,  10, 26,  38, 32,  16,   4,  0 },\n\t\t{  1,  10, 26,  37, 33,  17,   4,  0 },\n\t\t{  1,   9, 24,  37, 34,  18,   5,  0 },\n\t\t{  1,   8, 24,  37, 34,  19,   5,  0 },\n\t\t{  1,   7, 22,  36, 35,  20,   6,  1 },\n\t\t{  1,   6, 21,  36, 36,  21,   6,  1 },\n\t\t{  1,   6, 20,  35, 36,  22,   7,  1 },\n\t\t{  0,   5, 19,  34, 37,  24,   8,  1 },\n\t\t{  0,   5, 18,  34, 37,  24,   9,  1 },\n\t\t{  0,   4, 17,  33, 37,  26,  10,  1 },\n\t\t{  0,   4, 16,  32, 38,  26,  10,  2 },\n\t\t{  0,   3, 15,  31, 38,  28,  11,  2 },\n\t\t{  0,   3, 14,  30, 38,  29,  12,  2 }\n\t}\n};\n\n \nstatic const int v_coef_4t[GSC_COEF_RATIO][GSC_COEF_ATTR][GSC_COEF_V_4T] = {\n\t{\t \n\t\t{  0, 128,   0,  0 },\n\t\t{ -4, 127,   5,  0 },\n\t\t{ -6, 124,  11, -1 },\n\t\t{ -8, 118,  19, -1 },\n\t\t{ -8, 111,  27, -2 },\n\t\t{ -8, 102,  37, -3 },\n\t\t{ -8,  92,  48, -4 },\n\t\t{ -7,  81,  59, -5 },\n\t\t{ -6,  70,  70, -6 },\n\t\t{ -5,  59,  81, -7 },\n\t\t{ -4,  48,  92, -8 },\n\t\t{ -3,  37, 102, -8 },\n\t\t{ -2,  27, 111, -8 },\n\t\t{ -1,  19, 118, -8 },\n\t\t{ -1,  11, 124, -6 },\n\t\t{  0,   5, 127, -4 }\n\t}, {\t \n\t\t{  8, 112,   8,  0 },\n\t\t{  4, 111,  14, -1 },\n\t\t{  1, 109,  20, -2 },\n\t\t{ -2, 105,  27, -2 },\n\t\t{ -3, 100,  34, -3 },\n\t\t{ -5,  93,  43, -3 },\n\t\t{ -5,  86,  51, -4 },\n\t\t{ -5,  77,  60, -4 },\n\t\t{ -5,  69,  69, -5 },\n\t\t{ -4,  60,  77, -5 },\n\t\t{ -4,  51,  86, -5 },\n\t\t{ -3,  43,  93, -5 },\n\t\t{ -3,  34, 100, -3 },\n\t\t{ -2,  27, 105, -2 },\n\t\t{ -2,  20, 109,  1 },\n\t\t{ -1,  14, 111,  4 }\n\t}, {\t \n\t\t{ 16,  96,  16,  0 },\n\t\t{ 12,  97,  21, -2 },\n\t\t{  8,  96,  26, -2 },\n\t\t{  5,  93,  32, -2 },\n\t\t{  2,  89,  39, -2 },\n\t\t{  0,  84,  46, -2 },\n\t\t{ -1,  79,  53, -3 },\n\t\t{ -2,  73,  59, -2 },\n\t\t{ -2,  66,  66, -2 },\n\t\t{ -2,  59,  73, -2 },\n\t\t{ -3,  53,  79, -1 },\n\t\t{ -2,  46,  84,  0 },\n\t\t{ -2,  39,  89,  2 },\n\t\t{ -2,  32,  93,  5 },\n\t\t{ -2,  26,  96,  8 },\n\t\t{ -2,  21,  97, 12 }\n\t}, {\t \n\t\t{ 22,  84,  22,  0 },\n\t\t{ 18,  85,  26, -1 },\n\t\t{ 14,  84,  31, -1 },\n\t\t{ 11,  82,  36, -1 },\n\t\t{  8,  79,  42, -1 },\n\t\t{  6,  76,  47, -1 },\n\t\t{  4,  72,  52,  0 },\n\t\t{  2,  68,  58,  0 },\n\t\t{  1,  63,  63,  1 },\n\t\t{  0,  58,  68,  2 },\n\t\t{  0,  52,  72,  4 },\n\t\t{ -1,  47,  76,  6 },\n\t\t{ -1,  42,  79,  8 },\n\t\t{ -1,  36,  82, 11 },\n\t\t{ -1,  31,  84, 14 },\n\t\t{ -1,  26,  85, 18 }\n\t}, {\t \n\t\t{ 26,  76,  26,  0 },\n\t\t{ 22,  76,  30,  0 },\n\t\t{ 19,  75,  34,  0 },\n\t\t{ 16,  73,  38,  1 },\n\t\t{ 13,  71,  43,  1 },\n\t\t{ 10,  69,  47,  2 },\n\t\t{  8,  66,  51,  3 },\n\t\t{  6,  63,  55,  4 },\n\t\t{  5,  59,  59,  5 },\n\t\t{  4,  55,  63,  6 },\n\t\t{  3,  51,  66,  8 },\n\t\t{  2,  47,  69, 10 },\n\t\t{  1,  43,  71, 13 },\n\t\t{  1,  38,  73, 16 },\n\t\t{  0,  34,  75, 19 },\n\t\t{  0,  30,  76, 22 }\n\t}, {\t \n\t\t{ 29,  70,  29,  0 },\n\t\t{ 26,  68,  32,  2 },\n\t\t{ 23,  67,  36,  2 },\n\t\t{ 20,  66,  39,  3 },\n\t\t{ 17,  65,  43,  3 },\n\t\t{ 15,  63,  46,  4 },\n\t\t{ 12,  61,  50,  5 },\n\t\t{ 10,  58,  53,  7 },\n\t\t{  8,  56,  56,  8 },\n\t\t{  7,  53,  58, 10 },\n\t\t{  5,  50,  61, 12 },\n\t\t{  4,  46,  63, 15 },\n\t\t{  3,  43,  65, 17 },\n\t\t{  3,  39,  66, 20 },\n\t\t{  2,  36,  67, 23 },\n\t\t{  2,  32,  68, 26 }\n\t}, {\t \n\t\t{ 32,  64,  32,  0 },\n\t\t{ 28,  63,  34,  3 },\n\t\t{ 25,  62,  37,  4 },\n\t\t{ 22,  62,  40,  4 },\n\t\t{ 19,  61,  43,  5 },\n\t\t{ 17,  59,  46,  6 },\n\t\t{ 15,  58,  48,  7 },\n\t\t{ 13,  55,  51,  9 },\n\t\t{ 11,  53,  53, 11 },\n\t\t{  9,  51,  55, 13 },\n\t\t{  7,  48,  58, 15 },\n\t\t{  6,  46,  59, 17 },\n\t\t{  5,  43,  61, 19 },\n\t\t{  4,  40,  62, 22 },\n\t\t{  4,  37,  62, 25 },\n\t\t{  3,  34,  63, 28 }\n\t}\n};\n\nstatic int gsc_sw_reset(struct gsc_context *ctx)\n{\n\tu32 cfg;\n\tint count = GSC_RESET_TIMEOUT;\n\n\t \n\tcfg = (GSC_SW_RESET_SRESET);\n\tgsc_write(cfg, GSC_SW_RESET);\n\n\t \n\twhile (count--) {\n\t\tcfg = gsc_read(GSC_SW_RESET);\n\t\tif (!cfg)\n\t\t\tbreak;\n\t\tusleep_range(1000, 2000);\n\t}\n\n\tif (cfg) {\n\t\tDRM_DEV_ERROR(ctx->dev, \"failed to reset gsc h/w.\\n\");\n\t\treturn -EBUSY;\n\t}\n\n\t \n\tcfg = gsc_read(GSC_IN_BASE_ADDR_Y_MASK);\n\tcfg |= (GSC_IN_BASE_ADDR_MASK |\n\t\tGSC_IN_BASE_ADDR_PINGPONG(0));\n\tgsc_write(cfg, GSC_IN_BASE_ADDR_Y_MASK);\n\tgsc_write(cfg, GSC_IN_BASE_ADDR_CB_MASK);\n\tgsc_write(cfg, GSC_IN_BASE_ADDR_CR_MASK);\n\n\tcfg = gsc_read(GSC_OUT_BASE_ADDR_Y_MASK);\n\tcfg |= (GSC_OUT_BASE_ADDR_MASK |\n\t\tGSC_OUT_BASE_ADDR_PINGPONG(0));\n\tgsc_write(cfg, GSC_OUT_BASE_ADDR_Y_MASK);\n\tgsc_write(cfg, GSC_OUT_BASE_ADDR_CB_MASK);\n\tgsc_write(cfg, GSC_OUT_BASE_ADDR_CR_MASK);\n\n\treturn 0;\n}\n\nstatic void gsc_handle_irq(struct gsc_context *ctx, bool enable,\n\t\tbool overflow, bool done)\n{\n\tu32 cfg;\n\n\tDRM_DEV_DEBUG_KMS(ctx->dev, \"enable[%d]overflow[%d]level[%d]\\n\",\n\t\t\t  enable, overflow, done);\n\n\tcfg = gsc_read(GSC_IRQ);\n\tcfg |= (GSC_IRQ_OR_MASK | GSC_IRQ_FRMDONE_MASK);\n\n\tif (enable)\n\t\tcfg |= GSC_IRQ_ENABLE;\n\telse\n\t\tcfg &= ~GSC_IRQ_ENABLE;\n\n\tif (overflow)\n\t\tcfg &= ~GSC_IRQ_OR_MASK;\n\telse\n\t\tcfg |= GSC_IRQ_OR_MASK;\n\n\tif (done)\n\t\tcfg &= ~GSC_IRQ_FRMDONE_MASK;\n\telse\n\t\tcfg |= GSC_IRQ_FRMDONE_MASK;\n\n\tgsc_write(cfg, GSC_IRQ);\n}\n\n\nstatic void gsc_src_set_fmt(struct gsc_context *ctx, u32 fmt, bool tiled)\n{\n\tu32 cfg;\n\n\tDRM_DEV_DEBUG_KMS(ctx->dev, \"fmt[0x%x]\\n\", fmt);\n\n\tcfg = gsc_read(GSC_IN_CON);\n\tcfg &= ~(GSC_IN_RGB_TYPE_MASK | GSC_IN_YUV422_1P_ORDER_MASK |\n\t\t GSC_IN_CHROMA_ORDER_MASK | GSC_IN_FORMAT_MASK |\n\t\t GSC_IN_TILE_TYPE_MASK | GSC_IN_TILE_MODE |\n\t\t GSC_IN_CHROM_STRIDE_SEL_MASK | GSC_IN_RB_SWAP_MASK);\n\n\tswitch (fmt) {\n\tcase DRM_FORMAT_RGB565:\n\t\tcfg |= GSC_IN_RGB565;\n\t\tbreak;\n\tcase DRM_FORMAT_XRGB8888:\n\tcase DRM_FORMAT_ARGB8888:\n\t\tcfg |= GSC_IN_XRGB8888;\n\t\tbreak;\n\tcase DRM_FORMAT_BGRX8888:\n\t\tcfg |= (GSC_IN_XRGB8888 | GSC_IN_RB_SWAP);\n\t\tbreak;\n\tcase DRM_FORMAT_YUYV:\n\t\tcfg |= (GSC_IN_YUV422_1P |\n\t\t\tGSC_IN_YUV422_1P_ORDER_LSB_Y |\n\t\t\tGSC_IN_CHROMA_ORDER_CBCR);\n\t\tbreak;\n\tcase DRM_FORMAT_YVYU:\n\t\tcfg |= (GSC_IN_YUV422_1P |\n\t\t\tGSC_IN_YUV422_1P_ORDER_LSB_Y |\n\t\t\tGSC_IN_CHROMA_ORDER_CRCB);\n\t\tbreak;\n\tcase DRM_FORMAT_UYVY:\n\t\tcfg |= (GSC_IN_YUV422_1P |\n\t\t\tGSC_IN_YUV422_1P_OEDER_LSB_C |\n\t\t\tGSC_IN_CHROMA_ORDER_CBCR);\n\t\tbreak;\n\tcase DRM_FORMAT_VYUY:\n\t\tcfg |= (GSC_IN_YUV422_1P |\n\t\t\tGSC_IN_YUV422_1P_OEDER_LSB_C |\n\t\t\tGSC_IN_CHROMA_ORDER_CRCB);\n\t\tbreak;\n\tcase DRM_FORMAT_NV21:\n\t\tcfg |= (GSC_IN_CHROMA_ORDER_CRCB | GSC_IN_YUV420_2P);\n\t\tbreak;\n\tcase DRM_FORMAT_NV61:\n\t\tcfg |= (GSC_IN_CHROMA_ORDER_CRCB | GSC_IN_YUV422_2P);\n\t\tbreak;\n\tcase DRM_FORMAT_YUV422:\n\t\tcfg |= GSC_IN_YUV422_3P;\n\t\tbreak;\n\tcase DRM_FORMAT_YUV420:\n\t\tcfg |= (GSC_IN_CHROMA_ORDER_CBCR | GSC_IN_YUV420_3P);\n\t\tbreak;\n\tcase DRM_FORMAT_YVU420:\n\t\tcfg |= (GSC_IN_CHROMA_ORDER_CRCB | GSC_IN_YUV420_3P);\n\t\tbreak;\n\tcase DRM_FORMAT_NV12:\n\t\tcfg |= (GSC_IN_CHROMA_ORDER_CBCR | GSC_IN_YUV420_2P);\n\t\tbreak;\n\tcase DRM_FORMAT_NV16:\n\t\tcfg |= (GSC_IN_CHROMA_ORDER_CBCR | GSC_IN_YUV422_2P);\n\t\tbreak;\n\t}\n\n\tif (tiled)\n\t\tcfg |= (GSC_IN_TILE_C_16x8 | GSC_IN_TILE_MODE);\n\n\tgsc_write(cfg, GSC_IN_CON);\n}\n\nstatic void gsc_src_set_transf(struct gsc_context *ctx, unsigned int rotation)\n{\n\tunsigned int degree = rotation & DRM_MODE_ROTATE_MASK;\n\tu32 cfg;\n\n\tcfg = gsc_read(GSC_IN_CON);\n\tcfg &= ~GSC_IN_ROT_MASK;\n\n\tswitch (degree) {\n\tcase DRM_MODE_ROTATE_0:\n\t\tif (rotation & DRM_MODE_REFLECT_X)\n\t\t\tcfg |= GSC_IN_ROT_XFLIP;\n\t\tif (rotation & DRM_MODE_REFLECT_Y)\n\t\t\tcfg |= GSC_IN_ROT_YFLIP;\n\t\tbreak;\n\tcase DRM_MODE_ROTATE_90:\n\t\tcfg |= GSC_IN_ROT_90;\n\t\tif (rotation & DRM_MODE_REFLECT_X)\n\t\t\tcfg |= GSC_IN_ROT_XFLIP;\n\t\tif (rotation & DRM_MODE_REFLECT_Y)\n\t\t\tcfg |= GSC_IN_ROT_YFLIP;\n\t\tbreak;\n\tcase DRM_MODE_ROTATE_180:\n\t\tcfg |= GSC_IN_ROT_180;\n\t\tif (rotation & DRM_MODE_REFLECT_X)\n\t\t\tcfg &= ~GSC_IN_ROT_XFLIP;\n\t\tif (rotation & DRM_MODE_REFLECT_Y)\n\t\t\tcfg &= ~GSC_IN_ROT_YFLIP;\n\t\tbreak;\n\tcase DRM_MODE_ROTATE_270:\n\t\tcfg |= GSC_IN_ROT_270;\n\t\tif (rotation & DRM_MODE_REFLECT_X)\n\t\t\tcfg &= ~GSC_IN_ROT_XFLIP;\n\t\tif (rotation & DRM_MODE_REFLECT_Y)\n\t\t\tcfg &= ~GSC_IN_ROT_YFLIP;\n\t\tbreak;\n\t}\n\n\tgsc_write(cfg, GSC_IN_CON);\n\n\tctx->rotation = (cfg & GSC_IN_ROT_90) ? 1 : 0;\n}\n\nstatic void gsc_src_set_size(struct gsc_context *ctx,\n\t\t\t     struct exynos_drm_ipp_buffer *buf)\n{\n\tstruct gsc_scaler *sc = &ctx->sc;\n\tu32 cfg;\n\n\t \n\tcfg = (GSC_SRCIMG_OFFSET_X(buf->rect.x) |\n\t\tGSC_SRCIMG_OFFSET_Y(buf->rect.y));\n\tgsc_write(cfg, GSC_SRCIMG_OFFSET);\n\n\t \n\tcfg = (GSC_CROPPED_WIDTH(buf->rect.w) |\n\t\tGSC_CROPPED_HEIGHT(buf->rect.h));\n\tgsc_write(cfg, GSC_CROPPED_SIZE);\n\n\t \n\tcfg = gsc_read(GSC_SRCIMG_SIZE);\n\tcfg &= ~(GSC_SRCIMG_HEIGHT_MASK |\n\t\tGSC_SRCIMG_WIDTH_MASK);\n\n\tcfg |= (GSC_SRCIMG_WIDTH(buf->buf.pitch[0] / buf->format->cpp[0]) |\n\t\tGSC_SRCIMG_HEIGHT(buf->buf.height));\n\n\tgsc_write(cfg, GSC_SRCIMG_SIZE);\n\n\tcfg = gsc_read(GSC_IN_CON);\n\tcfg &= ~GSC_IN_RGB_TYPE_MASK;\n\n\tif (buf->rect.w >= GSC_WIDTH_ITU_709)\n\t\tif (sc->range)\n\t\t\tcfg |= GSC_IN_RGB_HD_WIDE;\n\t\telse\n\t\t\tcfg |= GSC_IN_RGB_HD_NARROW;\n\telse\n\t\tif (sc->range)\n\t\t\tcfg |= GSC_IN_RGB_SD_WIDE;\n\t\telse\n\t\t\tcfg |= GSC_IN_RGB_SD_NARROW;\n\n\tgsc_write(cfg, GSC_IN_CON);\n}\n\nstatic void gsc_src_set_buf_seq(struct gsc_context *ctx, u32 buf_id,\n\t\t\t       bool enqueue)\n{\n\tbool masked = !enqueue;\n\tu32 cfg;\n\tu32 mask = 0x00000001 << buf_id;\n\n\t \n\tcfg = gsc_read(GSC_IN_BASE_ADDR_Y_MASK);\n\n\t \n\tcfg &= ~mask;\n\tcfg |= masked << buf_id;\n\tgsc_write(cfg, GSC_IN_BASE_ADDR_Y_MASK);\n\tgsc_write(cfg, GSC_IN_BASE_ADDR_CB_MASK);\n\tgsc_write(cfg, GSC_IN_BASE_ADDR_CR_MASK);\n}\n\nstatic void gsc_src_set_addr(struct gsc_context *ctx, u32 buf_id,\n\t\t\t    struct exynos_drm_ipp_buffer *buf)\n{\n\t \n\tgsc_write(buf->dma_addr[0], GSC_IN_BASE_ADDR_Y(buf_id));\n\tgsc_write(buf->dma_addr[1], GSC_IN_BASE_ADDR_CB(buf_id));\n\tgsc_write(buf->dma_addr[2], GSC_IN_BASE_ADDR_CR(buf_id));\n\n\tgsc_src_set_buf_seq(ctx, buf_id, true);\n}\n\nstatic void gsc_dst_set_fmt(struct gsc_context *ctx, u32 fmt, bool tiled)\n{\n\tu32 cfg;\n\n\tDRM_DEV_DEBUG_KMS(ctx->dev, \"fmt[0x%x]\\n\", fmt);\n\n\tcfg = gsc_read(GSC_OUT_CON);\n\tcfg &= ~(GSC_OUT_RGB_TYPE_MASK | GSC_OUT_YUV422_1P_ORDER_MASK |\n\t\t GSC_OUT_CHROMA_ORDER_MASK | GSC_OUT_FORMAT_MASK |\n\t\t GSC_OUT_CHROM_STRIDE_SEL_MASK | GSC_OUT_RB_SWAP_MASK |\n\t\t GSC_OUT_GLOBAL_ALPHA_MASK);\n\n\tswitch (fmt) {\n\tcase DRM_FORMAT_RGB565:\n\t\tcfg |= GSC_OUT_RGB565;\n\t\tbreak;\n\tcase DRM_FORMAT_ARGB8888:\n\tcase DRM_FORMAT_XRGB8888:\n\t\tcfg |= (GSC_OUT_XRGB8888 | GSC_OUT_GLOBAL_ALPHA(0xff));\n\t\tbreak;\n\tcase DRM_FORMAT_BGRX8888:\n\t\tcfg |= (GSC_OUT_XRGB8888 | GSC_OUT_RB_SWAP);\n\t\tbreak;\n\tcase DRM_FORMAT_YUYV:\n\t\tcfg |= (GSC_OUT_YUV422_1P |\n\t\t\tGSC_OUT_YUV422_1P_ORDER_LSB_Y |\n\t\t\tGSC_OUT_CHROMA_ORDER_CBCR);\n\t\tbreak;\n\tcase DRM_FORMAT_YVYU:\n\t\tcfg |= (GSC_OUT_YUV422_1P |\n\t\t\tGSC_OUT_YUV422_1P_ORDER_LSB_Y |\n\t\t\tGSC_OUT_CHROMA_ORDER_CRCB);\n\t\tbreak;\n\tcase DRM_FORMAT_UYVY:\n\t\tcfg |= (GSC_OUT_YUV422_1P |\n\t\t\tGSC_OUT_YUV422_1P_OEDER_LSB_C |\n\t\t\tGSC_OUT_CHROMA_ORDER_CBCR);\n\t\tbreak;\n\tcase DRM_FORMAT_VYUY:\n\t\tcfg |= (GSC_OUT_YUV422_1P |\n\t\t\tGSC_OUT_YUV422_1P_OEDER_LSB_C |\n\t\t\tGSC_OUT_CHROMA_ORDER_CRCB);\n\t\tbreak;\n\tcase DRM_FORMAT_NV21:\n\t\tcfg |= (GSC_OUT_CHROMA_ORDER_CRCB | GSC_OUT_YUV420_2P);\n\t\tbreak;\n\tcase DRM_FORMAT_NV61:\n\t\tcfg |= (GSC_OUT_CHROMA_ORDER_CRCB | GSC_OUT_YUV422_2P);\n\t\tbreak;\n\tcase DRM_FORMAT_YUV422:\n\t\tcfg |= GSC_OUT_YUV422_3P;\n\t\tbreak;\n\tcase DRM_FORMAT_YUV420:\n\t\tcfg |= (GSC_OUT_CHROMA_ORDER_CBCR | GSC_OUT_YUV420_3P);\n\t\tbreak;\n\tcase DRM_FORMAT_YVU420:\n\t\tcfg |= (GSC_OUT_CHROMA_ORDER_CRCB | GSC_OUT_YUV420_3P);\n\t\tbreak;\n\tcase DRM_FORMAT_NV12:\n\t\tcfg |= (GSC_OUT_CHROMA_ORDER_CBCR | GSC_OUT_YUV420_2P);\n\t\tbreak;\n\tcase DRM_FORMAT_NV16:\n\t\tcfg |= (GSC_OUT_CHROMA_ORDER_CBCR | GSC_OUT_YUV422_2P);\n\t\tbreak;\n\t}\n\n\tif (tiled)\n\t\tcfg |= (GSC_IN_TILE_C_16x8 | GSC_OUT_TILE_MODE);\n\n\tgsc_write(cfg, GSC_OUT_CON);\n}\n\nstatic int gsc_get_ratio_shift(struct gsc_context *ctx, u32 src, u32 dst,\n\t\t\t       u32 *ratio)\n{\n\tDRM_DEV_DEBUG_KMS(ctx->dev, \"src[%d]dst[%d]\\n\", src, dst);\n\n\tif (src >= dst * 8) {\n\t\tDRM_DEV_ERROR(ctx->dev, \"failed to make ratio and shift.\\n\");\n\t\treturn -EINVAL;\n\t} else if (src >= dst * 4)\n\t\t*ratio = 4;\n\telse if (src >= dst * 2)\n\t\t*ratio = 2;\n\telse\n\t\t*ratio = 1;\n\n\treturn 0;\n}\n\nstatic void gsc_get_prescaler_shfactor(u32 hratio, u32 vratio, u32 *shfactor)\n{\n\tif (hratio == 4 && vratio == 4)\n\t\t*shfactor = 4;\n\telse if ((hratio == 4 && vratio == 2) ||\n\t\t (hratio == 2 && vratio == 4))\n\t\t*shfactor = 3;\n\telse if ((hratio == 4 && vratio == 1) ||\n\t\t (hratio == 1 && vratio == 4) ||\n\t\t (hratio == 2 && vratio == 2))\n\t\t*shfactor = 2;\n\telse if (hratio == 1 && vratio == 1)\n\t\t*shfactor = 0;\n\telse\n\t\t*shfactor = 1;\n}\n\nstatic int gsc_set_prescaler(struct gsc_context *ctx, struct gsc_scaler *sc,\n\t\t\t     struct drm_exynos_ipp_task_rect *src,\n\t\t\t     struct drm_exynos_ipp_task_rect *dst)\n{\n\tu32 cfg;\n\tu32 src_w, src_h, dst_w, dst_h;\n\tint ret = 0;\n\n\tsrc_w = src->w;\n\tsrc_h = src->h;\n\n\tif (ctx->rotation) {\n\t\tdst_w = dst->h;\n\t\tdst_h = dst->w;\n\t} else {\n\t\tdst_w = dst->w;\n\t\tdst_h = dst->h;\n\t}\n\n\tret = gsc_get_ratio_shift(ctx, src_w, dst_w, &sc->pre_hratio);\n\tif (ret) {\n\t\tDRM_DEV_ERROR(ctx->dev, \"failed to get ratio horizontal.\\n\");\n\t\treturn ret;\n\t}\n\n\tret = gsc_get_ratio_shift(ctx, src_h, dst_h, &sc->pre_vratio);\n\tif (ret) {\n\t\tDRM_DEV_ERROR(ctx->dev, \"failed to get ratio vertical.\\n\");\n\t\treturn ret;\n\t}\n\n\tDRM_DEV_DEBUG_KMS(ctx->dev, \"pre_hratio[%d]pre_vratio[%d]\\n\",\n\t\t\t  sc->pre_hratio, sc->pre_vratio);\n\n\tsc->main_hratio = (src_w << 16) / dst_w;\n\tsc->main_vratio = (src_h << 16) / dst_h;\n\n\tDRM_DEV_DEBUG_KMS(ctx->dev, \"main_hratio[%ld]main_vratio[%ld]\\n\",\n\t\t\t  sc->main_hratio, sc->main_vratio);\n\n\tgsc_get_prescaler_shfactor(sc->pre_hratio, sc->pre_vratio,\n\t\t&sc->pre_shfactor);\n\n\tDRM_DEV_DEBUG_KMS(ctx->dev, \"pre_shfactor[%d]\\n\", sc->pre_shfactor);\n\n\tcfg = (GSC_PRESC_SHFACTOR(sc->pre_shfactor) |\n\t\tGSC_PRESC_H_RATIO(sc->pre_hratio) |\n\t\tGSC_PRESC_V_RATIO(sc->pre_vratio));\n\tgsc_write(cfg, GSC_PRE_SCALE_RATIO);\n\n\treturn ret;\n}\n\nstatic void gsc_set_h_coef(struct gsc_context *ctx, unsigned long main_hratio)\n{\n\tint i, j, k, sc_ratio;\n\n\tif (main_hratio <= GSC_SC_UP_MAX_RATIO)\n\t\tsc_ratio = 0;\n\telse if (main_hratio <= GSC_SC_DOWN_RATIO_7_8)\n\t\tsc_ratio = 1;\n\telse if (main_hratio <= GSC_SC_DOWN_RATIO_6_8)\n\t\tsc_ratio = 2;\n\telse if (main_hratio <= GSC_SC_DOWN_RATIO_5_8)\n\t\tsc_ratio = 3;\n\telse if (main_hratio <= GSC_SC_DOWN_RATIO_4_8)\n\t\tsc_ratio = 4;\n\telse if (main_hratio <= GSC_SC_DOWN_RATIO_3_8)\n\t\tsc_ratio = 5;\n\telse\n\t\tsc_ratio = 6;\n\n\tfor (i = 0; i < GSC_COEF_PHASE; i++)\n\t\tfor (j = 0; j < GSC_COEF_H_8T; j++)\n\t\t\tfor (k = 0; k < GSC_COEF_DEPTH; k++)\n\t\t\t\tgsc_write(h_coef_8t[sc_ratio][i][j],\n\t\t\t\t\tGSC_HCOEF(i, j, k));\n}\n\nstatic void gsc_set_v_coef(struct gsc_context *ctx, unsigned long main_vratio)\n{\n\tint i, j, k, sc_ratio;\n\n\tif (main_vratio <= GSC_SC_UP_MAX_RATIO)\n\t\tsc_ratio = 0;\n\telse if (main_vratio <= GSC_SC_DOWN_RATIO_7_8)\n\t\tsc_ratio = 1;\n\telse if (main_vratio <= GSC_SC_DOWN_RATIO_6_8)\n\t\tsc_ratio = 2;\n\telse if (main_vratio <= GSC_SC_DOWN_RATIO_5_8)\n\t\tsc_ratio = 3;\n\telse if (main_vratio <= GSC_SC_DOWN_RATIO_4_8)\n\t\tsc_ratio = 4;\n\telse if (main_vratio <= GSC_SC_DOWN_RATIO_3_8)\n\t\tsc_ratio = 5;\n\telse\n\t\tsc_ratio = 6;\n\n\tfor (i = 0; i < GSC_COEF_PHASE; i++)\n\t\tfor (j = 0; j < GSC_COEF_V_4T; j++)\n\t\t\tfor (k = 0; k < GSC_COEF_DEPTH; k++)\n\t\t\t\tgsc_write(v_coef_4t[sc_ratio][i][j],\n\t\t\t\t\tGSC_VCOEF(i, j, k));\n}\n\nstatic void gsc_set_scaler(struct gsc_context *ctx, struct gsc_scaler *sc)\n{\n\tu32 cfg;\n\n\tDRM_DEV_DEBUG_KMS(ctx->dev, \"main_hratio[%ld]main_vratio[%ld]\\n\",\n\t\t\t  sc->main_hratio, sc->main_vratio);\n\n\tgsc_set_h_coef(ctx, sc->main_hratio);\n\tcfg = GSC_MAIN_H_RATIO_VALUE(sc->main_hratio);\n\tgsc_write(cfg, GSC_MAIN_H_RATIO);\n\n\tgsc_set_v_coef(ctx, sc->main_vratio);\n\tcfg = GSC_MAIN_V_RATIO_VALUE(sc->main_vratio);\n\tgsc_write(cfg, GSC_MAIN_V_RATIO);\n}\n\nstatic void gsc_dst_set_size(struct gsc_context *ctx,\n\t\t\t     struct exynos_drm_ipp_buffer *buf)\n{\n\tstruct gsc_scaler *sc = &ctx->sc;\n\tu32 cfg;\n\n\t \n\tcfg = (GSC_DSTIMG_OFFSET_X(buf->rect.x) |\n\t\tGSC_DSTIMG_OFFSET_Y(buf->rect.y));\n\tgsc_write(cfg, GSC_DSTIMG_OFFSET);\n\n\t \n\tif (ctx->rotation)\n\t\tcfg = (GSC_SCALED_WIDTH(buf->rect.h) |\n\t\t       GSC_SCALED_HEIGHT(buf->rect.w));\n\telse\n\t\tcfg = (GSC_SCALED_WIDTH(buf->rect.w) |\n\t\t       GSC_SCALED_HEIGHT(buf->rect.h));\n\tgsc_write(cfg, GSC_SCALED_SIZE);\n\n\t \n\tcfg = gsc_read(GSC_DSTIMG_SIZE);\n\tcfg &= ~(GSC_DSTIMG_HEIGHT_MASK | GSC_DSTIMG_WIDTH_MASK);\n\tcfg |= GSC_DSTIMG_WIDTH(buf->buf.pitch[0] / buf->format->cpp[0]) |\n\t       GSC_DSTIMG_HEIGHT(buf->buf.height);\n\tgsc_write(cfg, GSC_DSTIMG_SIZE);\n\n\tcfg = gsc_read(GSC_OUT_CON);\n\tcfg &= ~GSC_OUT_RGB_TYPE_MASK;\n\n\tif (buf->rect.w >= GSC_WIDTH_ITU_709)\n\t\tif (sc->range)\n\t\t\tcfg |= GSC_OUT_RGB_HD_WIDE;\n\t\telse\n\t\t\tcfg |= GSC_OUT_RGB_HD_NARROW;\n\telse\n\t\tif (sc->range)\n\t\t\tcfg |= GSC_OUT_RGB_SD_WIDE;\n\t\telse\n\t\t\tcfg |= GSC_OUT_RGB_SD_NARROW;\n\n\tgsc_write(cfg, GSC_OUT_CON);\n}\n\nstatic int gsc_dst_get_buf_seq(struct gsc_context *ctx)\n{\n\tu32 cfg, i, buf_num = GSC_REG_SZ;\n\tu32 mask = 0x00000001;\n\n\tcfg = gsc_read(GSC_OUT_BASE_ADDR_Y_MASK);\n\n\tfor (i = 0; i < GSC_REG_SZ; i++)\n\t\tif (cfg & (mask << i))\n\t\t\tbuf_num--;\n\n\tDRM_DEV_DEBUG_KMS(ctx->dev, \"buf_num[%d]\\n\", buf_num);\n\n\treturn buf_num;\n}\n\nstatic void gsc_dst_set_buf_seq(struct gsc_context *ctx, u32 buf_id,\n\t\t\t\tbool enqueue)\n{\n\tbool masked = !enqueue;\n\tu32 cfg;\n\tu32 mask = 0x00000001 << buf_id;\n\n\t \n\tcfg = gsc_read(GSC_OUT_BASE_ADDR_Y_MASK);\n\n\t \n\tcfg &= ~mask;\n\tcfg |= masked << buf_id;\n\tgsc_write(cfg, GSC_OUT_BASE_ADDR_Y_MASK);\n\tgsc_write(cfg, GSC_OUT_BASE_ADDR_CB_MASK);\n\tgsc_write(cfg, GSC_OUT_BASE_ADDR_CR_MASK);\n\n\t \n\tif (enqueue && gsc_dst_get_buf_seq(ctx) >= GSC_BUF_START)\n\t\tgsc_handle_irq(ctx, true, false, true);\n\n\t \n\tif (!enqueue && gsc_dst_get_buf_seq(ctx) <= GSC_BUF_STOP)\n\t\tgsc_handle_irq(ctx, false, false, true);\n}\n\nstatic void gsc_dst_set_addr(struct gsc_context *ctx,\n\t\t\t     u32 buf_id, struct exynos_drm_ipp_buffer *buf)\n{\n\t \n\tgsc_write(buf->dma_addr[0], GSC_OUT_BASE_ADDR_Y(buf_id));\n\tgsc_write(buf->dma_addr[1], GSC_OUT_BASE_ADDR_CB(buf_id));\n\tgsc_write(buf->dma_addr[2], GSC_OUT_BASE_ADDR_CR(buf_id));\n\n\tgsc_dst_set_buf_seq(ctx, buf_id, true);\n}\n\nstatic int gsc_get_src_buf_index(struct gsc_context *ctx)\n{\n\tu32 cfg, curr_index, i;\n\tu32 buf_id = GSC_MAX_SRC;\n\n\tDRM_DEV_DEBUG_KMS(ctx->dev, \"gsc id[%d]\\n\", ctx->id);\n\n\tcfg = gsc_read(GSC_IN_BASE_ADDR_Y_MASK);\n\tcurr_index = GSC_IN_CURR_GET_INDEX(cfg);\n\n\tfor (i = curr_index; i < GSC_MAX_SRC; i++) {\n\t\tif (!((cfg >> i) & 0x1)) {\n\t\t\tbuf_id = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tDRM_DEV_DEBUG_KMS(ctx->dev, \"cfg[0x%x]curr_index[%d]buf_id[%d]\\n\", cfg,\n\t\t\t  curr_index, buf_id);\n\n\tif (buf_id == GSC_MAX_SRC) {\n\t\tDRM_DEV_ERROR(ctx->dev, \"failed to get in buffer index.\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tgsc_src_set_buf_seq(ctx, buf_id, false);\n\n\treturn buf_id;\n}\n\nstatic int gsc_get_dst_buf_index(struct gsc_context *ctx)\n{\n\tu32 cfg, curr_index, i;\n\tu32 buf_id = GSC_MAX_DST;\n\n\tDRM_DEV_DEBUG_KMS(ctx->dev, \"gsc id[%d]\\n\", ctx->id);\n\n\tcfg = gsc_read(GSC_OUT_BASE_ADDR_Y_MASK);\n\tcurr_index = GSC_OUT_CURR_GET_INDEX(cfg);\n\n\tfor (i = curr_index; i < GSC_MAX_DST; i++) {\n\t\tif (!((cfg >> i) & 0x1)) {\n\t\t\tbuf_id = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (buf_id == GSC_MAX_DST) {\n\t\tDRM_DEV_ERROR(ctx->dev, \"failed to get out buffer index.\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tgsc_dst_set_buf_seq(ctx, buf_id, false);\n\n\tDRM_DEV_DEBUG_KMS(ctx->dev, \"cfg[0x%x]curr_index[%d]buf_id[%d]\\n\", cfg,\n\t\t\t  curr_index, buf_id);\n\n\treturn buf_id;\n}\n\nstatic irqreturn_t gsc_irq_handler(int irq, void *dev_id)\n{\n\tstruct gsc_context *ctx = dev_id;\n\tu32 status;\n\tint err = 0;\n\n\tDRM_DEV_DEBUG_KMS(ctx->dev, \"gsc id[%d]\\n\", ctx->id);\n\n\tstatus = gsc_read(GSC_IRQ);\n\tif (status & GSC_IRQ_STATUS_OR_IRQ) {\n\t\tdev_err(ctx->dev, \"occurred overflow at %d, status 0x%x.\\n\",\n\t\t\tctx->id, status);\n\t\terr = -EINVAL;\n\t}\n\n\tif (status & GSC_IRQ_STATUS_OR_FRM_DONE) {\n\t\tint src_buf_id, dst_buf_id;\n\n\t\tdev_dbg(ctx->dev, \"occurred frame done at %d, status 0x%x.\\n\",\n\t\t\tctx->id, status);\n\n\t\tsrc_buf_id = gsc_get_src_buf_index(ctx);\n\t\tdst_buf_id = gsc_get_dst_buf_index(ctx);\n\n\t\tDRM_DEV_DEBUG_KMS(ctx->dev, \"buf_id_src[%d]buf_id_dst[%d]\\n\",\n\t\t\t\t  src_buf_id, dst_buf_id);\n\n\t\tif (src_buf_id < 0 || dst_buf_id < 0)\n\t\t\terr = -EINVAL;\n\t}\n\n\tif (ctx->task) {\n\t\tstruct exynos_drm_ipp_task *task = ctx->task;\n\n\t\tctx->task = NULL;\n\t\tpm_runtime_mark_last_busy(ctx->dev);\n\t\tpm_runtime_put_autosuspend(ctx->dev);\n\t\texynos_drm_ipp_task_done(task, err);\n\t}\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int gsc_reset(struct gsc_context *ctx)\n{\n\tstruct gsc_scaler *sc = &ctx->sc;\n\tint ret;\n\n\t \n\tret = gsc_sw_reset(ctx);\n\tif (ret < 0) {\n\t\tdev_err(ctx->dev, \"failed to reset hardware.\\n\");\n\t\treturn ret;\n\t}\n\n\t \n\tmemset(&ctx->sc, 0x0, sizeof(ctx->sc));\n\tsc->range = true;\n\n\treturn 0;\n}\n\nstatic void gsc_start(struct gsc_context *ctx)\n{\n\tu32 cfg;\n\n\tgsc_handle_irq(ctx, true, false, true);\n\n\t \n\tcfg = gsc_read(GSC_ENABLE);\n\tcfg &= ~(GSC_ENABLE_ON_CLEAR_MASK |\n\t\tGSC_ENABLE_CLK_GATE_MODE_MASK);\n\tcfg |= GSC_ENABLE_ON_CLEAR_ONESHOT;\n\tgsc_write(cfg, GSC_ENABLE);\n\n\t \n\tcfg = gsc_read(GSC_IN_CON);\n\tcfg &= ~(GSC_IN_PATH_MASK | GSC_IN_LOCAL_SEL_MASK);\n\tcfg |= GSC_IN_PATH_MEMORY;\n\tgsc_write(cfg, GSC_IN_CON);\n\n\t \n\tcfg = gsc_read(GSC_OUT_CON);\n\tcfg |= GSC_OUT_PATH_MEMORY;\n\tgsc_write(cfg, GSC_OUT_CON);\n\n\tgsc_set_scaler(ctx, &ctx->sc);\n\n\tcfg = gsc_read(GSC_ENABLE);\n\tcfg |= GSC_ENABLE_ON;\n\tgsc_write(cfg, GSC_ENABLE);\n}\n\nstatic int gsc_commit(struct exynos_drm_ipp *ipp,\n\t\t\t  struct exynos_drm_ipp_task *task)\n{\n\tstruct gsc_context *ctx = container_of(ipp, struct gsc_context, ipp);\n\tint ret;\n\n\tret = pm_runtime_resume_and_get(ctx->dev);\n\tif (ret < 0) {\n\t\tdev_err(ctx->dev, \"failed to enable GScaler device.\\n\");\n\t\treturn ret;\n\t}\n\n\tctx->task = task;\n\n\tret = gsc_reset(ctx);\n\tif (ret) {\n\t\tpm_runtime_put_autosuspend(ctx->dev);\n\t\tctx->task = NULL;\n\t\treturn ret;\n\t}\n\n\tgsc_src_set_fmt(ctx, task->src.buf.fourcc, task->src.buf.modifier);\n\tgsc_src_set_transf(ctx, task->transform.rotation);\n\tgsc_src_set_size(ctx, &task->src);\n\tgsc_src_set_addr(ctx, 0, &task->src);\n\tgsc_dst_set_fmt(ctx, task->dst.buf.fourcc, task->dst.buf.modifier);\n\tgsc_dst_set_size(ctx, &task->dst);\n\tgsc_dst_set_addr(ctx, 0, &task->dst);\n\tgsc_set_prescaler(ctx, &ctx->sc, &task->src.rect, &task->dst.rect);\n\tgsc_start(ctx);\n\n\treturn 0;\n}\n\nstatic void gsc_abort(struct exynos_drm_ipp *ipp,\n\t\t\t  struct exynos_drm_ipp_task *task)\n{\n\tstruct gsc_context *ctx =\n\t\t\tcontainer_of(ipp, struct gsc_context, ipp);\n\n\tgsc_reset(ctx);\n\tif (ctx->task) {\n\t\tstruct exynos_drm_ipp_task *task = ctx->task;\n\n\t\tctx->task = NULL;\n\t\tpm_runtime_mark_last_busy(ctx->dev);\n\t\tpm_runtime_put_autosuspend(ctx->dev);\n\t\texynos_drm_ipp_task_done(task, -EIO);\n\t}\n}\n\nstatic struct exynos_drm_ipp_funcs ipp_funcs = {\n\t.commit = gsc_commit,\n\t.abort = gsc_abort,\n};\n\nstatic int gsc_bind(struct device *dev, struct device *master, void *data)\n{\n\tstruct gsc_context *ctx = dev_get_drvdata(dev);\n\tstruct drm_device *drm_dev = data;\n\tstruct exynos_drm_ipp *ipp = &ctx->ipp;\n\n\tctx->drm_dev = drm_dev;\n\tctx->drm_dev = drm_dev;\n\texynos_drm_register_dma(drm_dev, dev, &ctx->dma_priv);\n\n\texynos_drm_ipp_register(dev, ipp, &ipp_funcs,\n\t\t\tDRM_EXYNOS_IPP_CAP_CROP | DRM_EXYNOS_IPP_CAP_ROTATE |\n\t\t\tDRM_EXYNOS_IPP_CAP_SCALE | DRM_EXYNOS_IPP_CAP_CONVERT,\n\t\t\tctx->formats, ctx->num_formats, \"gsc\");\n\n\tdev_info(dev, \"The exynos gscaler has been probed successfully\\n\");\n\n\treturn 0;\n}\n\nstatic void gsc_unbind(struct device *dev, struct device *master,\n\t\t\tvoid *data)\n{\n\tstruct gsc_context *ctx = dev_get_drvdata(dev);\n\tstruct drm_device *drm_dev = data;\n\tstruct exynos_drm_ipp *ipp = &ctx->ipp;\n\n\texynos_drm_ipp_unregister(dev, ipp);\n\texynos_drm_unregister_dma(drm_dev, dev, &ctx->dma_priv);\n}\n\nstatic const struct component_ops gsc_component_ops = {\n\t.bind\t= gsc_bind,\n\t.unbind = gsc_unbind,\n};\n\nstatic const unsigned int gsc_formats[] = {\n\tDRM_FORMAT_ARGB8888,\n\tDRM_FORMAT_XRGB8888, DRM_FORMAT_RGB565, DRM_FORMAT_BGRX8888,\n\tDRM_FORMAT_NV12, DRM_FORMAT_NV16, DRM_FORMAT_NV21, DRM_FORMAT_NV61,\n\tDRM_FORMAT_UYVY, DRM_FORMAT_VYUY, DRM_FORMAT_YUYV, DRM_FORMAT_YVYU,\n\tDRM_FORMAT_YUV420, DRM_FORMAT_YVU420, DRM_FORMAT_YUV422,\n};\n\nstatic const unsigned int gsc_tiled_formats[] = {\n\tDRM_FORMAT_NV12, DRM_FORMAT_NV21,\n};\n\nstatic int gsc_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct gsc_driverdata *driver_data;\n\tstruct exynos_drm_ipp_formats *formats;\n\tstruct gsc_context *ctx;\n\tint num_formats, ret, i, j;\n\n\tctx = devm_kzalloc(dev, sizeof(*ctx), GFP_KERNEL);\n\tif (!ctx)\n\t\treturn -ENOMEM;\n\n\tdriver_data = (struct gsc_driverdata *)of_device_get_match_data(dev);\n\tctx->dev = dev;\n\tctx->num_clocks = driver_data->num_clocks;\n\tctx->clk_names = driver_data->clk_names;\n\n\t \n\tnum_formats = ARRAY_SIZE(gsc_formats) + ARRAY_SIZE(gsc_tiled_formats);\n\tformats = devm_kcalloc(dev, num_formats, sizeof(*formats), GFP_KERNEL);\n\tif (!formats)\n\t\treturn -ENOMEM;\n\n\t \n\tfor (i = 0; i < ARRAY_SIZE(gsc_formats); i++) {\n\t\tformats[i].fourcc = gsc_formats[i];\n\t\tformats[i].type = DRM_EXYNOS_IPP_FORMAT_SOURCE |\n\t\t\t\t  DRM_EXYNOS_IPP_FORMAT_DESTINATION;\n\t\tformats[i].limits = driver_data->limits;\n\t\tformats[i].num_limits = driver_data->num_limits;\n\t}\n\n\t \n\tfor (j = i, i = 0; i < ARRAY_SIZE(gsc_tiled_formats); j++, i++) {\n\t\tformats[j].fourcc = gsc_tiled_formats[i];\n\t\tformats[j].modifier = DRM_FORMAT_MOD_SAMSUNG_16_16_TILE;\n\t\tformats[j].type = DRM_EXYNOS_IPP_FORMAT_SOURCE |\n\t\t\t\t  DRM_EXYNOS_IPP_FORMAT_DESTINATION;\n\t\tformats[j].limits = driver_data->limits;\n\t\tformats[j].num_limits = driver_data->num_limits;\n\t}\n\n\tctx->formats = formats;\n\tctx->num_formats = num_formats;\n\n\t \n\tfor (i = 0; i < ctx->num_clocks; i++) {\n\t\tctx->clocks[i] = devm_clk_get(dev, ctx->clk_names[i]);\n\t\tif (IS_ERR(ctx->clocks[i])) {\n\t\t\tdev_err(dev, \"failed to get clock: %s\\n\",\n\t\t\t\tctx->clk_names[i]);\n\t\t\treturn PTR_ERR(ctx->clocks[i]);\n\t\t}\n\t}\n\n\tctx->regs = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(ctx->regs))\n\t\treturn PTR_ERR(ctx->regs);\n\n\t \n\tctx->irq = platform_get_irq(pdev, 0);\n\tif (ctx->irq < 0)\n\t\treturn ctx->irq;\n\n\tret = devm_request_irq(dev, ctx->irq, gsc_irq_handler, 0,\n\t\t\t       dev_name(dev), ctx);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"failed to request irq.\\n\");\n\t\treturn ret;\n\t}\n\n\t \n\tctx->id = pdev->id;\n\n\tplatform_set_drvdata(pdev, ctx);\n\n\tpm_runtime_use_autosuspend(dev);\n\tpm_runtime_set_autosuspend_delay(dev, GSC_AUTOSUSPEND_DELAY);\n\tpm_runtime_enable(dev);\n\n\tret = component_add(dev, &gsc_component_ops);\n\tif (ret)\n\t\tgoto err_pm_dis;\n\n\tdev_info(dev, \"drm gsc registered successfully.\\n\");\n\n\treturn 0;\n\nerr_pm_dis:\n\tpm_runtime_dont_use_autosuspend(dev);\n\tpm_runtime_disable(dev);\n\treturn ret;\n}\n\nstatic int gsc_remove(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\n\tcomponent_del(dev, &gsc_component_ops);\n\tpm_runtime_dont_use_autosuspend(dev);\n\tpm_runtime_disable(dev);\n\n\treturn 0;\n}\n\nstatic int __maybe_unused gsc_runtime_suspend(struct device *dev)\n{\n\tstruct gsc_context *ctx = get_gsc_context(dev);\n\tint i;\n\n\tDRM_DEV_DEBUG_KMS(dev, \"id[%d]\\n\", ctx->id);\n\n\tfor (i = ctx->num_clocks - 1; i >= 0; i--)\n\t\tclk_disable_unprepare(ctx->clocks[i]);\n\n\treturn 0;\n}\n\nstatic int __maybe_unused gsc_runtime_resume(struct device *dev)\n{\n\tstruct gsc_context *ctx = get_gsc_context(dev);\n\tint i, ret;\n\n\tDRM_DEV_DEBUG_KMS(dev, \"id[%d]\\n\", ctx->id);\n\n\tfor (i = 0; i < ctx->num_clocks; i++) {\n\t\tret = clk_prepare_enable(ctx->clocks[i]);\n\t\tif (ret) {\n\t\t\twhile (--i > 0)\n\t\t\t\tclk_disable_unprepare(ctx->clocks[i]);\n\t\t\treturn ret;\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic const struct dev_pm_ops gsc_pm_ops = {\n\tSET_SYSTEM_SLEEP_PM_OPS(pm_runtime_force_suspend,\n\t\t\t\tpm_runtime_force_resume)\n\tSET_RUNTIME_PM_OPS(gsc_runtime_suspend, gsc_runtime_resume, NULL)\n};\n\nstatic const struct drm_exynos_ipp_limit gsc_5250_limits[] = {\n\t{ IPP_SIZE_LIMIT(BUFFER, .h = { 32, 4800, 8 }, .v = { 16, 3344, 8 }) },\n\t{ IPP_SIZE_LIMIT(AREA, .h = { 16, 4800, 2 }, .v = { 8, 3344, 2 }) },\n\t{ IPP_SIZE_LIMIT(ROTATED, .h = { 32, 2048 }, .v = { 16, 2048 }) },\n\t{ IPP_SCALE_LIMIT(.h = { (1 << 16) / 16, (1 << 16) * 8 },\n\t\t\t  .v = { (1 << 16) / 16, (1 << 16) * 8 }) },\n};\n\nstatic const struct drm_exynos_ipp_limit gsc_5420_limits[] = {\n\t{ IPP_SIZE_LIMIT(BUFFER, .h = { 32, 4800, 8 }, .v = { 16, 3344, 8 }) },\n\t{ IPP_SIZE_LIMIT(AREA, .h = { 16, 4800, 2 }, .v = { 8, 3344, 2 }) },\n\t{ IPP_SIZE_LIMIT(ROTATED, .h = { 16, 2016 }, .v = { 8, 2016 }) },\n\t{ IPP_SCALE_LIMIT(.h = { (1 << 16) / 16, (1 << 16) * 8 },\n\t\t\t  .v = { (1 << 16) / 16, (1 << 16) * 8 }) },\n};\n\nstatic const struct drm_exynos_ipp_limit gsc_5433_limits[] = {\n\t{ IPP_SIZE_LIMIT(BUFFER, .h = { 32, 8191, 16 }, .v = { 16, 8191, 2 }) },\n\t{ IPP_SIZE_LIMIT(AREA, .h = { 16, 4800, 1 }, .v = { 8, 3344, 1 }) },\n\t{ IPP_SIZE_LIMIT(ROTATED, .h = { 32, 2047 }, .v = { 8, 8191 }) },\n\t{ IPP_SCALE_LIMIT(.h = { (1 << 16) / 16, (1 << 16) * 8 },\n\t\t\t  .v = { (1 << 16) / 16, (1 << 16) * 8 }) },\n};\n\nstatic struct gsc_driverdata gsc_exynos5250_drvdata = {\n\t.clk_names = {\"gscl\"},\n\t.num_clocks = 1,\n\t.limits = gsc_5250_limits,\n\t.num_limits = ARRAY_SIZE(gsc_5250_limits),\n};\n\nstatic struct gsc_driverdata gsc_exynos5420_drvdata = {\n\t.clk_names = {\"gscl\"},\n\t.num_clocks = 1,\n\t.limits = gsc_5420_limits,\n\t.num_limits = ARRAY_SIZE(gsc_5420_limits),\n};\n\nstatic struct gsc_driverdata gsc_exynos5433_drvdata = {\n\t.clk_names = {\"pclk\", \"aclk\", \"aclk_xiu\", \"aclk_gsclbend\"},\n\t.num_clocks = 4,\n\t.limits = gsc_5433_limits,\n\t.num_limits = ARRAY_SIZE(gsc_5433_limits),\n};\n\nstatic const struct of_device_id exynos_drm_gsc_of_match[] = {\n\t{\n\t\t.compatible = \"samsung,exynos5-gsc\",\n\t\t.data = &gsc_exynos5250_drvdata,\n\t}, {\n\t\t.compatible = \"samsung,exynos5250-gsc\",\n\t\t.data = &gsc_exynos5250_drvdata,\n\t}, {\n\t\t.compatible = \"samsung,exynos5420-gsc\",\n\t\t.data = &gsc_exynos5420_drvdata,\n\t}, {\n\t\t.compatible = \"samsung,exynos5433-gsc\",\n\t\t.data = &gsc_exynos5433_drvdata,\n\t}, {\n\t},\n};\nMODULE_DEVICE_TABLE(of, exynos_drm_gsc_of_match);\n\nstruct platform_driver gsc_driver = {\n\t.probe\t\t= gsc_probe,\n\t.remove\t\t= gsc_remove,\n\t.driver\t\t= {\n\t\t.name\t= \"exynos-drm-gsc\",\n\t\t.owner\t= THIS_MODULE,\n\t\t.pm\t= &gsc_pm_ops,\n\t\t.of_match_table = exynos_drm_gsc_of_match,\n\t},\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}