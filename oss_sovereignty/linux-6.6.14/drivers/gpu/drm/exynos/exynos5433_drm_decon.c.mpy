{
  "module_name": "exynos5433_drm_decon.c",
  "hash_id": "989205678fc9bcc1245bc24366a4f1eac643b2cd4c4a1703d11db09da64b9680",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/exynos/exynos5433_drm_decon.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/component.h>\n#include <linux/iopoll.h>\n#include <linux/irq.h>\n#include <linux/mfd/syscon.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/pm_runtime.h>\n#include <linux/regmap.h>\n\n#include <drm/drm_blend.h>\n#include <drm/drm_fourcc.h>\n#include <drm/drm_framebuffer.h>\n#include <drm/drm_vblank.h>\n\n#include \"exynos_drm_crtc.h\"\n#include \"exynos_drm_drv.h\"\n#include \"exynos_drm_fb.h\"\n#include \"exynos_drm_plane.h\"\n#include \"regs-decon5433.h\"\n\n#define DSD_CFG_MUX 0x1004\n#define DSD_CFG_MUX_TE_UNMASK_GLOBAL BIT(13)\n\n#define WINDOWS_NR\t5\n#define PRIMARY_WIN\t2\n#define CURSON_WIN\t4\n\n#define MIN_FB_WIDTH_FOR_16WORD_BURST\t128\n\n#define I80_HW_TRG\t(1 << 0)\n#define IFTYPE_HDMI\t(1 << 1)\n\nstatic const char * const decon_clks_name[] = {\n\t\"pclk\",\n\t\"aclk_decon\",\n\t\"aclk_smmu_decon0x\",\n\t\"aclk_xiu_decon0x\",\n\t\"pclk_smmu_decon0x\",\n\t\"aclk_smmu_decon1x\",\n\t\"aclk_xiu_decon1x\",\n\t\"pclk_smmu_decon1x\",\n\t\"sclk_decon_vclk\",\n\t\"sclk_decon_eclk\",\n};\n\nstruct decon_context {\n\tstruct device\t\t\t*dev;\n\tstruct drm_device\t\t*drm_dev;\n\tvoid\t\t\t\t*dma_priv;\n\tstruct exynos_drm_crtc\t\t*crtc;\n\tstruct exynos_drm_plane\t\tplanes[WINDOWS_NR];\n\tstruct exynos_drm_plane_config\tconfigs[WINDOWS_NR];\n\tvoid __iomem\t\t\t*addr;\n\tstruct regmap\t\t\t*sysreg;\n\tstruct clk\t\t\t*clks[ARRAY_SIZE(decon_clks_name)];\n\tunsigned int\t\t\tirq;\n\tunsigned int\t\t\tirq_vsync;\n\tunsigned int\t\t\tirq_lcd_sys;\n\tunsigned int\t\t\tte_irq;\n\tunsigned long\t\t\tout_type;\n\tint\t\t\t\tfirst_win;\n\tspinlock_t\t\t\tvblank_lock;\n\tu32\t\t\t\tframe_id;\n};\n\nstatic const uint32_t decon_formats[] = {\n\tDRM_FORMAT_XRGB1555,\n\tDRM_FORMAT_RGB565,\n\tDRM_FORMAT_XRGB8888,\n\tDRM_FORMAT_ARGB8888,\n};\n\nstatic const enum drm_plane_type decon_win_types[WINDOWS_NR] = {\n\t[PRIMARY_WIN] = DRM_PLANE_TYPE_PRIMARY,\n\t[CURSON_WIN] = DRM_PLANE_TYPE_CURSOR,\n};\n\nstatic const unsigned int capabilities[WINDOWS_NR] = {\n\t0,\n\tEXYNOS_DRM_PLANE_CAP_WIN_BLEND | EXYNOS_DRM_PLANE_CAP_PIX_BLEND,\n\tEXYNOS_DRM_PLANE_CAP_WIN_BLEND | EXYNOS_DRM_PLANE_CAP_PIX_BLEND,\n\tEXYNOS_DRM_PLANE_CAP_WIN_BLEND | EXYNOS_DRM_PLANE_CAP_PIX_BLEND,\n\tEXYNOS_DRM_PLANE_CAP_WIN_BLEND | EXYNOS_DRM_PLANE_CAP_PIX_BLEND,\n};\n\nstatic inline void decon_set_bits(struct decon_context *ctx, u32 reg, u32 mask,\n\t\t\t\t  u32 val)\n{\n\tval = (val & mask) | (readl(ctx->addr + reg) & ~mask);\n\twritel(val, ctx->addr + reg);\n}\n\nstatic int decon_enable_vblank(struct exynos_drm_crtc *crtc)\n{\n\tstruct decon_context *ctx = crtc->ctx;\n\tu32 val;\n\n\tval = VIDINTCON0_INTEN;\n\tif (crtc->i80_mode)\n\t\tval |= VIDINTCON0_FRAMEDONE;\n\telse\n\t\tval |= VIDINTCON0_INTFRMEN | VIDINTCON0_FRAMESEL_FP;\n\n\twritel(val, ctx->addr + DECON_VIDINTCON0);\n\n\tenable_irq(ctx->irq);\n\tif (!(ctx->out_type & I80_HW_TRG))\n\t\tenable_irq(ctx->te_irq);\n\n\treturn 0;\n}\n\nstatic void decon_disable_vblank(struct exynos_drm_crtc *crtc)\n{\n\tstruct decon_context *ctx = crtc->ctx;\n\n\tif (!(ctx->out_type & I80_HW_TRG))\n\t\tdisable_irq_nosync(ctx->te_irq);\n\tdisable_irq_nosync(ctx->irq);\n\n\twritel(0, ctx->addr + DECON_VIDINTCON0);\n}\n\n \nstatic u32 decon_get_frame_count(struct decon_context *ctx, bool end)\n{\n\tu32 frm, pfrm, status, cnt = 2;\n\n\t \n\tfrm = readl(ctx->addr + DECON_CRFMID);\n\tdo {\n\t\tstatus = readl(ctx->addr + DECON_VIDCON1);\n\t\tpfrm = frm;\n\t\tfrm = readl(ctx->addr + DECON_CRFMID);\n\t} while (frm != pfrm && --cnt);\n\n\t \n\tif (!frm)\n\t\treturn 0;\n\n\tswitch (status & (VIDCON1_VSTATUS_MASK | VIDCON1_I80_ACTIVE)) {\n\tcase VIDCON1_VSTATUS_VS:\n\t\tif (!(ctx->crtc->i80_mode))\n\t\t\t--frm;\n\t\tbreak;\n\tcase VIDCON1_VSTATUS_BP:\n\t\t--frm;\n\t\tbreak;\n\tcase VIDCON1_I80_ACTIVE:\n\tcase VIDCON1_VSTATUS_AC:\n\t\tif (end)\n\t\t\t--frm;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn frm;\n}\n\nstatic void decon_setup_trigger(struct decon_context *ctx)\n{\n\tif (!ctx->crtc->i80_mode && !(ctx->out_type & I80_HW_TRG))\n\t\treturn;\n\n\tif (!(ctx->out_type & I80_HW_TRG)) {\n\t\twritel(TRIGCON_TRIGEN_PER_F | TRIGCON_TRIGEN_F |\n\t\t       TRIGCON_TE_AUTO_MASK | TRIGCON_SWTRIGEN,\n\t\t       ctx->addr + DECON_TRIGCON);\n\t\treturn;\n\t}\n\n\twritel(TRIGCON_TRIGEN_PER_F | TRIGCON_TRIGEN_F | TRIGCON_HWTRIGMASK\n\t       | TRIGCON_HWTRIGEN, ctx->addr + DECON_TRIGCON);\n\n\tif (regmap_update_bits(ctx->sysreg, DSD_CFG_MUX,\n\t\t\t       DSD_CFG_MUX_TE_UNMASK_GLOBAL, ~0))\n\t\tDRM_DEV_ERROR(ctx->dev, \"Cannot update sysreg.\\n\");\n}\n\nstatic void decon_commit(struct exynos_drm_crtc *crtc)\n{\n\tstruct decon_context *ctx = crtc->ctx;\n\tstruct drm_display_mode *m = &crtc->base.mode;\n\tbool interlaced = false;\n\tu32 val;\n\n\tif (ctx->out_type & IFTYPE_HDMI) {\n\t\tm->crtc_hsync_start = m->crtc_hdisplay + 10;\n\t\tm->crtc_hsync_end = m->crtc_htotal - 92;\n\t\tm->crtc_vsync_start = m->crtc_vdisplay + 1;\n\t\tm->crtc_vsync_end = m->crtc_vsync_start + 1;\n\t\tif (m->flags & DRM_MODE_FLAG_INTERLACE)\n\t\t\tinterlaced = true;\n\t}\n\n\tdecon_setup_trigger(ctx);\n\n\t \n\tval = VIDOUT_LCD_ON;\n\tif (interlaced)\n\t\tval |= VIDOUT_INTERLACE_EN_F;\n\tif (crtc->i80_mode) {\n\t\tval |= VIDOUT_COMMAND_IF;\n\t} else {\n\t\tval |= VIDOUT_RGB_IF;\n\t}\n\n\twritel(val, ctx->addr + DECON_VIDOUTCON0);\n\n\tif (interlaced)\n\t\tval = VIDTCON2_LINEVAL(m->vdisplay / 2 - 1) |\n\t\t\tVIDTCON2_HOZVAL(m->hdisplay - 1);\n\telse\n\t\tval = VIDTCON2_LINEVAL(m->vdisplay - 1) |\n\t\t\tVIDTCON2_HOZVAL(m->hdisplay - 1);\n\twritel(val, ctx->addr + DECON_VIDTCON2);\n\n\tif (!crtc->i80_mode) {\n\t\tint vbp = m->crtc_vtotal - m->crtc_vsync_end;\n\t\tint vfp = m->crtc_vsync_start - m->crtc_vdisplay;\n\n\t\tif (interlaced)\n\t\t\tvbp = vbp / 2 - 1;\n\t\tval = VIDTCON00_VBPD_F(vbp - 1) | VIDTCON00_VFPD_F(vfp - 1);\n\t\twritel(val, ctx->addr + DECON_VIDTCON00);\n\n\t\tval = VIDTCON01_VSPW_F(\n\t\t\t\tm->crtc_vsync_end - m->crtc_vsync_start - 1);\n\t\twritel(val, ctx->addr + DECON_VIDTCON01);\n\n\t\tval = VIDTCON10_HBPD_F(\n\t\t\t\tm->crtc_htotal - m->crtc_hsync_end - 1) |\n\t\t\tVIDTCON10_HFPD_F(\n\t\t\t\tm->crtc_hsync_start - m->crtc_hdisplay - 1);\n\t\twritel(val, ctx->addr + DECON_VIDTCON10);\n\n\t\tval = VIDTCON11_HSPW_F(\n\t\t\t\tm->crtc_hsync_end - m->crtc_hsync_start - 1);\n\t\twritel(val, ctx->addr + DECON_VIDTCON11);\n\t}\n\n\t \n\tdecon_set_bits(ctx, DECON_VIDCON0, VIDCON0_ENVID | VIDCON0_ENVID_F, ~0);\n\n\tdecon_set_bits(ctx, DECON_UPDATE, STANDALONE_UPDATE_F, ~0);\n}\n\nstatic void decon_win_set_bldeq(struct decon_context *ctx, unsigned int win,\n\t\t\t\tunsigned int alpha, unsigned int pixel_alpha)\n{\n\tu32 mask = BLENDERQ_A_FUNC_F(0xf) | BLENDERQ_B_FUNC_F(0xf);\n\tu32 val = 0;\n\n\tswitch (pixel_alpha) {\n\tcase DRM_MODE_BLEND_PIXEL_NONE:\n\tcase DRM_MODE_BLEND_COVERAGE:\n\t\tval |= BLENDERQ_A_FUNC_F(BLENDERQ_ALPHA_A);\n\t\tval |= BLENDERQ_B_FUNC_F(BLENDERQ_ONE_MINUS_ALPHA_A);\n\t\tbreak;\n\tcase DRM_MODE_BLEND_PREMULTI:\n\tdefault:\n\t\tif (alpha != DRM_BLEND_ALPHA_OPAQUE) {\n\t\t\tval |= BLENDERQ_A_FUNC_F(BLENDERQ_ALPHA0);\n\t\t\tval |= BLENDERQ_B_FUNC_F(BLENDERQ_ONE_MINUS_ALPHA_A);\n\t\t} else {\n\t\t\tval |= BLENDERQ_A_FUNC_F(BLENDERQ_ONE);\n\t\t\tval |= BLENDERQ_B_FUNC_F(BLENDERQ_ONE_MINUS_ALPHA_A);\n\t\t}\n\t\tbreak;\n\t}\n\tdecon_set_bits(ctx, DECON_BLENDERQx(win), mask, val);\n}\n\nstatic void decon_win_set_bldmod(struct decon_context *ctx, unsigned int win,\n\t\t\t\t unsigned int alpha, unsigned int pixel_alpha)\n{\n\tu32 win_alpha = alpha >> 8;\n\tu32 val = 0;\n\n\tswitch (pixel_alpha) {\n\tcase DRM_MODE_BLEND_PIXEL_NONE:\n\t\tbreak;\n\tcase DRM_MODE_BLEND_COVERAGE:\n\tcase DRM_MODE_BLEND_PREMULTI:\n\tdefault:\n\t\tval |= WINCONx_ALPHA_SEL_F;\n\t\tval |= WINCONx_BLD_PIX_F;\n\t\tval |= WINCONx_ALPHA_MUL_F;\n\t\tbreak;\n\t}\n\tdecon_set_bits(ctx, DECON_WINCONx(win), WINCONx_BLEND_MODE_MASK, val);\n\n\tif (alpha != DRM_BLEND_ALPHA_OPAQUE) {\n\t\tval = VIDOSD_Wx_ALPHA_R_F(win_alpha) |\n\t\t      VIDOSD_Wx_ALPHA_G_F(win_alpha) |\n\t\t      VIDOSD_Wx_ALPHA_B_F(win_alpha);\n\t\tdecon_set_bits(ctx, DECON_VIDOSDxC(win),\n\t\t\t       VIDOSDxC_ALPHA0_RGB_MASK, val);\n\t\tdecon_set_bits(ctx, DECON_BLENDCON, BLEND_NEW, BLEND_NEW);\n\t}\n}\n\nstatic void decon_win_set_pixfmt(struct decon_context *ctx, unsigned int win,\n\t\t\t\t struct drm_framebuffer *fb)\n{\n\tstruct exynos_drm_plane plane = ctx->planes[win];\n\tstruct exynos_drm_plane_state *state =\n\t\tto_exynos_plane_state(plane.base.state);\n\tunsigned int alpha = state->base.alpha;\n\tunsigned int pixel_alpha;\n\tunsigned long val;\n\n\tif (fb->format->has_alpha)\n\t\tpixel_alpha = state->base.pixel_blend_mode;\n\telse\n\t\tpixel_alpha = DRM_MODE_BLEND_PIXEL_NONE;\n\n\tval = readl(ctx->addr + DECON_WINCONx(win));\n\tval &= WINCONx_ENWIN_F;\n\n\tswitch (fb->format->format) {\n\tcase DRM_FORMAT_XRGB1555:\n\t\tval |= WINCONx_BPPMODE_16BPP_I1555;\n\t\tval |= WINCONx_HAWSWP_F;\n\t\tval |= WINCONx_BURSTLEN_16WORD;\n\t\tbreak;\n\tcase DRM_FORMAT_RGB565:\n\t\tval |= WINCONx_BPPMODE_16BPP_565;\n\t\tval |= WINCONx_HAWSWP_F;\n\t\tval |= WINCONx_BURSTLEN_16WORD;\n\t\tbreak;\n\tcase DRM_FORMAT_XRGB8888:\n\t\tval |= WINCONx_BPPMODE_24BPP_888;\n\t\tval |= WINCONx_WSWP_F;\n\t\tval |= WINCONx_BURSTLEN_16WORD;\n\t\tbreak;\n\tcase DRM_FORMAT_ARGB8888:\n\tdefault:\n\t\tval |= WINCONx_BPPMODE_32BPP_A8888;\n\t\tval |= WINCONx_WSWP_F;\n\t\tval |= WINCONx_BURSTLEN_16WORD;\n\t\tbreak;\n\t}\n\n\tDRM_DEV_DEBUG_KMS(ctx->dev, \"cpp = %u\\n\", fb->format->cpp[0]);\n\n\t \n\n\tif (fb->width < MIN_FB_WIDTH_FOR_16WORD_BURST) {\n\t\tval &= ~WINCONx_BURSTLEN_MASK;\n\t\tval |= WINCONx_BURSTLEN_8WORD;\n\t}\n\tdecon_set_bits(ctx, DECON_WINCONx(win), ~WINCONx_BLEND_MODE_MASK, val);\n\n\tif (win > 0) {\n\t\tdecon_win_set_bldmod(ctx, win, alpha, pixel_alpha);\n\t\tdecon_win_set_bldeq(ctx, win, alpha, pixel_alpha);\n\t}\n}\n\nstatic void decon_shadow_protect(struct decon_context *ctx, bool protect)\n{\n\tdecon_set_bits(ctx, DECON_SHADOWCON, SHADOWCON_PROTECT_MASK,\n\t\t       protect ? ~0 : 0);\n}\n\nstatic void decon_atomic_begin(struct exynos_drm_crtc *crtc)\n{\n\tstruct decon_context *ctx = crtc->ctx;\n\n\tdecon_shadow_protect(ctx, true);\n}\n\n#define BIT_VAL(x, e, s) (((x) & ((1 << ((e) - (s) + 1)) - 1)) << (s))\n#define COORDINATE_X(x) BIT_VAL((x), 23, 12)\n#define COORDINATE_Y(x) BIT_VAL((x), 11, 0)\n\nstatic void decon_update_plane(struct exynos_drm_crtc *crtc,\n\t\t\t       struct exynos_drm_plane *plane)\n{\n\tstruct exynos_drm_plane_state *state =\n\t\t\t\tto_exynos_plane_state(plane->base.state);\n\tstruct decon_context *ctx = crtc->ctx;\n\tstruct drm_framebuffer *fb = state->base.fb;\n\tunsigned int win = plane->index;\n\tunsigned int cpp = fb->format->cpp[0];\n\tunsigned int pitch = fb->pitches[0];\n\tdma_addr_t dma_addr = exynos_drm_fb_dma_addr(fb, 0);\n\tu32 val;\n\n\tif (crtc->base.mode.flags & DRM_MODE_FLAG_INTERLACE) {\n\t\tval = COORDINATE_X(state->crtc.x) |\n\t\t\tCOORDINATE_Y(state->crtc.y / 2);\n\t\twritel(val, ctx->addr + DECON_VIDOSDxA(win));\n\n\t\tval = COORDINATE_X(state->crtc.x + state->crtc.w - 1) |\n\t\t\tCOORDINATE_Y((state->crtc.y + state->crtc.h) / 2 - 1);\n\t\twritel(val, ctx->addr + DECON_VIDOSDxB(win));\n\t} else {\n\t\tval = COORDINATE_X(state->crtc.x) | COORDINATE_Y(state->crtc.y);\n\t\twritel(val, ctx->addr + DECON_VIDOSDxA(win));\n\n\t\tval = COORDINATE_X(state->crtc.x + state->crtc.w - 1) |\n\t\t\t\tCOORDINATE_Y(state->crtc.y + state->crtc.h - 1);\n\t\twritel(val, ctx->addr + DECON_VIDOSDxB(win));\n\t}\n\n\tval = VIDOSD_Wx_ALPHA_R_F(0xff) | VIDOSD_Wx_ALPHA_G_F(0xff) |\n\t\tVIDOSD_Wx_ALPHA_B_F(0xff);\n\twritel(val, ctx->addr + DECON_VIDOSDxC(win));\n\n\tval = VIDOSD_Wx_ALPHA_R_F(0x0) | VIDOSD_Wx_ALPHA_G_F(0x0) |\n\t\tVIDOSD_Wx_ALPHA_B_F(0x0);\n\twritel(val, ctx->addr + DECON_VIDOSDxD(win));\n\n\twritel(dma_addr, ctx->addr + DECON_VIDW0xADD0B0(win));\n\n\tval = dma_addr + pitch * state->src.h;\n\twritel(val, ctx->addr + DECON_VIDW0xADD1B0(win));\n\n\tif (!(ctx->out_type & IFTYPE_HDMI))\n\t\tval = BIT_VAL(pitch - state->crtc.w * cpp, 27, 14)\n\t\t\t| BIT_VAL(state->crtc.w * cpp, 13, 0);\n\telse\n\t\tval = BIT_VAL(pitch - state->crtc.w * cpp, 29, 15)\n\t\t\t| BIT_VAL(state->crtc.w * cpp, 14, 0);\n\twritel(val, ctx->addr + DECON_VIDW0xADD2(win));\n\n\tdecon_win_set_pixfmt(ctx, win, fb);\n\n\t \n\tdecon_set_bits(ctx, DECON_WINCONx(win), WINCONx_ENWIN_F, ~0);\n}\n\nstatic void decon_disable_plane(struct exynos_drm_crtc *crtc,\n\t\t\t\tstruct exynos_drm_plane *plane)\n{\n\tstruct decon_context *ctx = crtc->ctx;\n\tunsigned int win = plane->index;\n\n\tdecon_set_bits(ctx, DECON_WINCONx(win), WINCONx_ENWIN_F, 0);\n}\n\nstatic void decon_atomic_flush(struct exynos_drm_crtc *crtc)\n{\n\tstruct decon_context *ctx = crtc->ctx;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&ctx->vblank_lock, flags);\n\n\tdecon_shadow_protect(ctx, false);\n\n\tdecon_set_bits(ctx, DECON_UPDATE, STANDALONE_UPDATE_F, ~0);\n\n\tctx->frame_id = decon_get_frame_count(ctx, true);\n\n\texynos_crtc_handle_event(crtc);\n\n\tspin_unlock_irqrestore(&ctx->vblank_lock, flags);\n}\n\nstatic void decon_swreset(struct decon_context *ctx)\n{\n\tunsigned long flags;\n\tu32 val;\n\tint ret;\n\n\twritel(0, ctx->addr + DECON_VIDCON0);\n\treadl_poll_timeout(ctx->addr + DECON_VIDCON0, val,\n\t\t\t   ~val & VIDCON0_STOP_STATUS, 12, 20000);\n\n\twritel(VIDCON0_SWRESET, ctx->addr + DECON_VIDCON0);\n\tret = readl_poll_timeout(ctx->addr + DECON_VIDCON0, val,\n\t\t\t\t ~val & VIDCON0_SWRESET, 12, 20000);\n\n\tWARN(ret < 0, \"failed to software reset DECON\\n\");\n\n\tspin_lock_irqsave(&ctx->vblank_lock, flags);\n\tctx->frame_id = 0;\n\tspin_unlock_irqrestore(&ctx->vblank_lock, flags);\n\n\tif (!(ctx->out_type & IFTYPE_HDMI))\n\t\treturn;\n\n\twritel(VIDCON0_CLKVALUP | VIDCON0_VLCKFREE, ctx->addr + DECON_VIDCON0);\n\tdecon_set_bits(ctx, DECON_CMU,\n\t\t       CMU_CLKGAGE_MODE_SFR_F | CMU_CLKGAGE_MODE_MEM_F, ~0);\n\twritel(VIDCON1_VCLK_RUN_VDEN_DISABLE, ctx->addr + DECON_VIDCON1);\n\twritel(CRCCTRL_CRCEN | CRCCTRL_CRCSTART_F | CRCCTRL_CRCCLKEN,\n\t       ctx->addr + DECON_CRCCTRL);\n}\n\nstatic void decon_atomic_enable(struct exynos_drm_crtc *crtc)\n{\n\tstruct decon_context *ctx = crtc->ctx;\n\tint ret;\n\n\tret = pm_runtime_resume_and_get(ctx->dev);\n\tif (ret < 0) {\n\t\tDRM_DEV_ERROR(ctx->dev, \"failed to enable DECON device.\\n\");\n\t\treturn;\n\t}\n\n\texynos_drm_pipe_clk_enable(crtc, true);\n\n\tdecon_swreset(ctx);\n\n\tdecon_commit(ctx->crtc);\n}\n\nstatic void decon_atomic_disable(struct exynos_drm_crtc *crtc)\n{\n\tstruct decon_context *ctx = crtc->ctx;\n\tint i;\n\n\tif (!(ctx->out_type & I80_HW_TRG))\n\t\tsynchronize_irq(ctx->te_irq);\n\tsynchronize_irq(ctx->irq);\n\n\t \n\tfor (i = ctx->first_win; i < WINDOWS_NR; i++)\n\t\tdecon_disable_plane(crtc, &ctx->planes[i]);\n\n\tdecon_swreset(ctx);\n\n\texynos_drm_pipe_clk_enable(crtc, false);\n\n\tpm_runtime_put_sync(ctx->dev);\n}\n\nstatic irqreturn_t decon_te_irq_handler(int irq, void *dev_id)\n{\n\tstruct decon_context *ctx = dev_id;\n\n\tdecon_set_bits(ctx, DECON_TRIGCON, TRIGCON_SWTRIGCMD, ~0);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic void decon_clear_channels(struct exynos_drm_crtc *crtc)\n{\n\tstruct decon_context *ctx = crtc->ctx;\n\tint win, i, ret;\n\n\tfor (i = 0; i < ARRAY_SIZE(decon_clks_name); i++) {\n\t\tret = clk_prepare_enable(ctx->clks[i]);\n\t\tif (ret < 0)\n\t\t\tgoto err;\n\t}\n\n\tdecon_shadow_protect(ctx, true);\n\tfor (win = 0; win < WINDOWS_NR; win++)\n\t\tdecon_set_bits(ctx, DECON_WINCONx(win), WINCONx_ENWIN_F, 0);\n\tdecon_shadow_protect(ctx, false);\n\n\tdecon_set_bits(ctx, DECON_UPDATE, STANDALONE_UPDATE_F, ~0);\n\n\t \n\tmsleep(50);\n\nerr:\n\twhile (--i >= 0)\n\t\tclk_disable_unprepare(ctx->clks[i]);\n}\n\nstatic enum drm_mode_status decon_mode_valid(struct exynos_drm_crtc *crtc,\n\t\tconst struct drm_display_mode *mode)\n{\n\tstruct decon_context *ctx = crtc->ctx;\n\n\tctx->irq = crtc->i80_mode ? ctx->irq_lcd_sys : ctx->irq_vsync;\n\n\tif (ctx->irq)\n\t\treturn MODE_OK;\n\n\tdev_info(ctx->dev, \"Sink requires %s mode, but appropriate interrupt is not provided.\\n\",\n\t\t\tcrtc->i80_mode ? \"command\" : \"video\");\n\n\treturn MODE_BAD;\n}\n\nstatic const struct exynos_drm_crtc_ops decon_crtc_ops = {\n\t.atomic_enable\t\t= decon_atomic_enable,\n\t.atomic_disable\t\t= decon_atomic_disable,\n\t.enable_vblank\t\t= decon_enable_vblank,\n\t.disable_vblank\t\t= decon_disable_vblank,\n\t.atomic_begin\t\t= decon_atomic_begin,\n\t.update_plane\t\t= decon_update_plane,\n\t.disable_plane\t\t= decon_disable_plane,\n\t.mode_valid\t\t= decon_mode_valid,\n\t.atomic_flush\t\t= decon_atomic_flush,\n};\n\nstatic int decon_bind(struct device *dev, struct device *master, void *data)\n{\n\tstruct decon_context *ctx = dev_get_drvdata(dev);\n\tstruct drm_device *drm_dev = data;\n\tstruct exynos_drm_plane *exynos_plane;\n\tenum exynos_drm_output_type out_type;\n\tunsigned int win;\n\tint ret;\n\n\tctx->drm_dev = drm_dev;\n\n\tfor (win = ctx->first_win; win < WINDOWS_NR; win++) {\n\t\tctx->configs[win].pixel_formats = decon_formats;\n\t\tctx->configs[win].num_pixel_formats = ARRAY_SIZE(decon_formats);\n\t\tctx->configs[win].zpos = win - ctx->first_win;\n\t\tctx->configs[win].type = decon_win_types[win];\n\t\tctx->configs[win].capabilities = capabilities[win];\n\n\t\tret = exynos_plane_init(drm_dev, &ctx->planes[win], win,\n\t\t\t\t\t&ctx->configs[win]);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\texynos_plane = &ctx->planes[PRIMARY_WIN];\n\tout_type = (ctx->out_type & IFTYPE_HDMI) ? EXYNOS_DISPLAY_TYPE_HDMI\n\t\t\t\t\t\t  : EXYNOS_DISPLAY_TYPE_LCD;\n\tctx->crtc = exynos_drm_crtc_create(drm_dev, &exynos_plane->base,\n\t\t\tout_type, &decon_crtc_ops, ctx);\n\tif (IS_ERR(ctx->crtc))\n\t\treturn PTR_ERR(ctx->crtc);\n\n\tdecon_clear_channels(ctx->crtc);\n\n\treturn exynos_drm_register_dma(drm_dev, dev, &ctx->dma_priv);\n}\n\nstatic void decon_unbind(struct device *dev, struct device *master, void *data)\n{\n\tstruct decon_context *ctx = dev_get_drvdata(dev);\n\n\tdecon_atomic_disable(ctx->crtc);\n\n\t \n\texynos_drm_unregister_dma(ctx->drm_dev, ctx->dev, &ctx->dma_priv);\n}\n\nstatic const struct component_ops decon_component_ops = {\n\t.bind\t= decon_bind,\n\t.unbind = decon_unbind,\n};\n\nstatic void decon_handle_vblank(struct decon_context *ctx)\n{\n\tu32 frm;\n\n\tspin_lock(&ctx->vblank_lock);\n\n\tfrm = decon_get_frame_count(ctx, true);\n\n\tif (frm != ctx->frame_id) {\n\t\t \n\t\tif ((s32)(frm - ctx->frame_id) > 0)\n\t\t\tdrm_crtc_handle_vblank(&ctx->crtc->base);\n\t\tctx->frame_id = frm;\n\t}\n\n\tspin_unlock(&ctx->vblank_lock);\n}\n\nstatic irqreturn_t decon_irq_handler(int irq, void *dev_id)\n{\n\tstruct decon_context *ctx = dev_id;\n\tu32 val;\n\n\tval = readl(ctx->addr + DECON_VIDINTCON1);\n\tval &= VIDINTCON1_INTFRMDONEPEND | VIDINTCON1_INTFRMPEND;\n\n\tif (val) {\n\t\twritel(val, ctx->addr + DECON_VIDINTCON1);\n\t\tif (ctx->out_type & IFTYPE_HDMI) {\n\t\t\tval = readl(ctx->addr + DECON_VIDOUTCON0);\n\t\t\tval &= VIDOUT_INTERLACE_EN_F | VIDOUT_INTERLACE_FIELD_F;\n\t\t\tif (val ==\n\t\t\t    (VIDOUT_INTERLACE_EN_F | VIDOUT_INTERLACE_FIELD_F))\n\t\t\t\treturn IRQ_HANDLED;\n\t\t}\n\t\tdecon_handle_vblank(ctx);\n\t}\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int exynos5433_decon_suspend(struct device *dev)\n{\n\tstruct decon_context *ctx = dev_get_drvdata(dev);\n\tint i = ARRAY_SIZE(decon_clks_name);\n\n\twhile (--i >= 0)\n\t\tclk_disable_unprepare(ctx->clks[i]);\n\n\treturn 0;\n}\n\nstatic int exynos5433_decon_resume(struct device *dev)\n{\n\tstruct decon_context *ctx = dev_get_drvdata(dev);\n\tint i, ret;\n\n\tfor (i = 0; i < ARRAY_SIZE(decon_clks_name); i++) {\n\t\tret = clk_prepare_enable(ctx->clks[i]);\n\t\tif (ret < 0)\n\t\t\tgoto err;\n\t}\n\n\treturn 0;\n\nerr:\n\twhile (--i >= 0)\n\t\tclk_disable_unprepare(ctx->clks[i]);\n\n\treturn ret;\n}\n\nstatic DEFINE_RUNTIME_DEV_PM_OPS(exynos5433_decon_pm_ops,\n\t\t\t\t exynos5433_decon_suspend,\n\t\t\t\t exynos5433_decon_resume, NULL);\n\nstatic const struct of_device_id exynos5433_decon_driver_dt_match[] = {\n\t{\n\t\t.compatible = \"samsung,exynos5433-decon\",\n\t\t.data = (void *)I80_HW_TRG\n\t},\n\t{\n\t\t.compatible = \"samsung,exynos5433-decon-tv\",\n\t\t.data = (void *)(I80_HW_TRG | IFTYPE_HDMI)\n\t},\n\t{},\n};\nMODULE_DEVICE_TABLE(of, exynos5433_decon_driver_dt_match);\n\nstatic int decon_conf_irq(struct decon_context *ctx, const char *name,\n\t\tirq_handler_t handler, unsigned long int flags)\n{\n\tstruct platform_device *pdev = to_platform_device(ctx->dev);\n\tint ret, irq = platform_get_irq_byname(pdev, name);\n\n\tif (irq < 0) {\n\t\tswitch (irq) {\n\t\tcase -EPROBE_DEFER:\n\t\t\treturn irq;\n\t\tcase -ENODATA:\n\t\tcase -ENXIO:\n\t\t\treturn 0;\n\t\tdefault:\n\t\t\tdev_err(ctx->dev, \"IRQ %s get failed, %d\\n\", name, irq);\n\t\t\treturn irq;\n\t\t}\n\t}\n\tret = devm_request_irq(ctx->dev, irq, handler,\n\t\t\t       flags | IRQF_NO_AUTOEN, \"drm_decon\", ctx);\n\tif (ret < 0) {\n\t\tdev_err(ctx->dev, \"IRQ %s request failed\\n\", name);\n\t\treturn ret;\n\t}\n\n\treturn irq;\n}\n\nstatic int exynos5433_decon_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct decon_context *ctx;\n\tint ret;\n\tint i;\n\n\tctx = devm_kzalloc(dev, sizeof(*ctx), GFP_KERNEL);\n\tif (!ctx)\n\t\treturn -ENOMEM;\n\n\tctx->dev = dev;\n\tctx->out_type = (unsigned long)of_device_get_match_data(dev);\n\tspin_lock_init(&ctx->vblank_lock);\n\n\tif (ctx->out_type & IFTYPE_HDMI)\n\t\tctx->first_win = 1;\n\n\tfor (i = 0; i < ARRAY_SIZE(decon_clks_name); i++) {\n\t\tstruct clk *clk;\n\n\t\tclk = devm_clk_get(ctx->dev, decon_clks_name[i]);\n\t\tif (IS_ERR(clk))\n\t\t\treturn PTR_ERR(clk);\n\n\t\tctx->clks[i] = clk;\n\t}\n\n\tctx->addr = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(ctx->addr))\n\t\treturn PTR_ERR(ctx->addr);\n\n\tret = decon_conf_irq(ctx, \"vsync\", decon_irq_handler, 0);\n\tif (ret < 0)\n\t\treturn ret;\n\tctx->irq_vsync = ret;\n\n\tret = decon_conf_irq(ctx, \"lcd_sys\", decon_irq_handler, 0);\n\tif (ret < 0)\n\t\treturn ret;\n\tctx->irq_lcd_sys = ret;\n\n\tret = decon_conf_irq(ctx, \"te\", decon_te_irq_handler,\n\t\t\tIRQF_TRIGGER_RISING);\n\tif (ret < 0)\n\t\t\treturn ret;\n\tif (ret) {\n\t\tctx->te_irq = ret;\n\t\tctx->out_type &= ~I80_HW_TRG;\n\t}\n\n\tif (ctx->out_type & I80_HW_TRG) {\n\t\tctx->sysreg = syscon_regmap_lookup_by_phandle(dev->of_node,\n\t\t\t\t\t\t\t\"samsung,disp-sysreg\");\n\t\tif (IS_ERR(ctx->sysreg)) {\n\t\t\tdev_err(dev, \"failed to get system register\\n\");\n\t\t\treturn PTR_ERR(ctx->sysreg);\n\t\t}\n\t}\n\n\tplatform_set_drvdata(pdev, ctx);\n\n\tpm_runtime_enable(dev);\n\n\tret = component_add(dev, &decon_component_ops);\n\tif (ret)\n\t\tgoto err_disable_pm_runtime;\n\n\treturn 0;\n\nerr_disable_pm_runtime:\n\tpm_runtime_disable(dev);\n\n\treturn ret;\n}\n\nstatic int exynos5433_decon_remove(struct platform_device *pdev)\n{\n\tpm_runtime_disable(&pdev->dev);\n\n\tcomponent_del(&pdev->dev, &decon_component_ops);\n\n\treturn 0;\n}\n\nstruct platform_driver exynos5433_decon_driver = {\n\t.probe\t\t= exynos5433_decon_probe,\n\t.remove\t\t= exynos5433_decon_remove,\n\t.driver\t\t= {\n\t\t.name\t= \"exynos5433-decon\",\n\t\t.pm\t= pm_ptr(&exynos5433_decon_pm_ops),\n\t\t.of_match_table = exynos5433_decon_driver_dt_match,\n\t},\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}