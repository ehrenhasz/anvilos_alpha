{
  "module_name": "exynos_drm_dpi.c",
  "hash_id": "2bd7692e77472c09838c6c45618b5aa819b85c672afbf008f981ada2a1503fd9",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/exynos/exynos_drm_dpi.c",
  "human_readable_source": "\n \n\n#include <linux/of.h>\n#include <linux/of_graph.h>\n#include <linux/regulator/consumer.h>\n\n#include <drm/drm_atomic_helper.h>\n#include <drm/drm_panel.h>\n#include <drm/drm_print.h>\n#include <drm/drm_probe_helper.h>\n#include <drm/drm_simple_kms_helper.h>\n\n#include <video/of_videomode.h>\n#include <video/videomode.h>\n\n#include \"exynos_drm_crtc.h\"\n\nstruct exynos_dpi {\n\tstruct drm_encoder encoder;\n\tstruct device *dev;\n\tstruct device_node *panel_node;\n\n\tstruct drm_panel *panel;\n\tstruct drm_connector connector;\n\n\tstruct videomode *vm;\n};\n\n#define connector_to_dpi(c) container_of(c, struct exynos_dpi, connector)\n\nstatic inline struct exynos_dpi *encoder_to_dpi(struct drm_encoder *e)\n{\n\treturn container_of(e, struct exynos_dpi, encoder);\n}\n\nstatic enum drm_connector_status\nexynos_dpi_detect(struct drm_connector *connector, bool force)\n{\n\treturn connector_status_connected;\n}\n\nstatic void exynos_dpi_connector_destroy(struct drm_connector *connector)\n{\n\tdrm_connector_unregister(connector);\n\tdrm_connector_cleanup(connector);\n}\n\nstatic const struct drm_connector_funcs exynos_dpi_connector_funcs = {\n\t.detect = exynos_dpi_detect,\n\t.fill_modes = drm_helper_probe_single_connector_modes,\n\t.destroy = exynos_dpi_connector_destroy,\n\t.reset = drm_atomic_helper_connector_reset,\n\t.atomic_duplicate_state = drm_atomic_helper_connector_duplicate_state,\n\t.atomic_destroy_state = drm_atomic_helper_connector_destroy_state,\n};\n\nstatic int exynos_dpi_get_modes(struct drm_connector *connector)\n{\n\tstruct exynos_dpi *ctx = connector_to_dpi(connector);\n\n\t \n\tif (ctx->vm) {\n\t\tstruct drm_display_mode *mode;\n\n\t\tmode = drm_mode_create(connector->dev);\n\t\tif (!mode) {\n\t\t\tDRM_DEV_ERROR(ctx->dev,\n\t\t\t\t      \"failed to create a new display mode\\n\");\n\t\t\treturn 0;\n\t\t}\n\t\tdrm_display_mode_from_videomode(ctx->vm, mode);\n\t\tmode->type = DRM_MODE_TYPE_DRIVER | DRM_MODE_TYPE_PREFERRED;\n\t\tdrm_mode_probed_add(connector, mode);\n\t\treturn 1;\n\t}\n\n\tif (ctx->panel)\n\t\treturn drm_panel_get_modes(ctx->panel, connector);\n\n\treturn 0;\n}\n\nstatic const struct drm_connector_helper_funcs exynos_dpi_connector_helper_funcs = {\n\t.get_modes = exynos_dpi_get_modes,\n};\n\nstatic int exynos_dpi_create_connector(struct drm_encoder *encoder)\n{\n\tstruct exynos_dpi *ctx = encoder_to_dpi(encoder);\n\tstruct drm_connector *connector = &ctx->connector;\n\tint ret;\n\n\tconnector->polled = DRM_CONNECTOR_POLL_HPD;\n\n\tret = drm_connector_init(encoder->dev, connector,\n\t\t\t\t &exynos_dpi_connector_funcs,\n\t\t\t\t DRM_MODE_CONNECTOR_VGA);\n\tif (ret) {\n\t\tDRM_DEV_ERROR(ctx->dev,\n\t\t\t      \"failed to initialize connector with drm\\n\");\n\t\treturn ret;\n\t}\n\n\tdrm_connector_helper_add(connector, &exynos_dpi_connector_helper_funcs);\n\tdrm_connector_attach_encoder(connector, encoder);\n\n\treturn 0;\n}\n\nstatic void exynos_dpi_mode_set(struct drm_encoder *encoder,\n\t\t\t\tstruct drm_display_mode *mode,\n\t\t\t\tstruct drm_display_mode *adjusted_mode)\n{\n}\n\nstatic void exynos_dpi_enable(struct drm_encoder *encoder)\n{\n\tstruct exynos_dpi *ctx = encoder_to_dpi(encoder);\n\n\tif (ctx->panel) {\n\t\tdrm_panel_prepare(ctx->panel);\n\t\tdrm_panel_enable(ctx->panel);\n\t}\n}\n\nstatic void exynos_dpi_disable(struct drm_encoder *encoder)\n{\n\tstruct exynos_dpi *ctx = encoder_to_dpi(encoder);\n\n\tif (ctx->panel) {\n\t\tdrm_panel_disable(ctx->panel);\n\t\tdrm_panel_unprepare(ctx->panel);\n\t}\n}\n\nstatic const struct drm_encoder_helper_funcs exynos_dpi_encoder_helper_funcs = {\n\t.mode_set = exynos_dpi_mode_set,\n\t.enable = exynos_dpi_enable,\n\t.disable = exynos_dpi_disable,\n};\n\nenum {\n\tFIMD_PORT_IN0,\n\tFIMD_PORT_IN1,\n\tFIMD_PORT_IN2,\n\tFIMD_PORT_RGB,\n\tFIMD_PORT_WRB,\n};\n\nstatic int exynos_dpi_parse_dt(struct exynos_dpi *ctx)\n{\n\tstruct device *dev = ctx->dev;\n\tstruct device_node *dn = dev->of_node;\n\tstruct device_node *np;\n\n\tctx->panel_node = of_graph_get_remote_node(dn, FIMD_PORT_RGB, 0);\n\n\tnp = of_get_child_by_name(dn, \"display-timings\");\n\tif (np) {\n\t\tstruct videomode *vm;\n\t\tint ret;\n\n\t\tof_node_put(np);\n\n\t\tvm = devm_kzalloc(dev, sizeof(*ctx->vm), GFP_KERNEL);\n\t\tif (!vm)\n\t\t\treturn -ENOMEM;\n\n\t\tret = of_get_videomode(dn, vm, 0);\n\t\tif (ret < 0) {\n\t\t\tdevm_kfree(dev, vm);\n\t\t\treturn ret;\n\t\t}\n\n\t\tctx->vm = vm;\n\n\t\treturn 0;\n\t}\n\n\tif (!ctx->panel_node)\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nint exynos_dpi_bind(struct drm_device *dev, struct drm_encoder *encoder)\n{\n\tint ret;\n\n\tdrm_simple_encoder_init(dev, encoder, DRM_MODE_ENCODER_TMDS);\n\n\tdrm_encoder_helper_add(encoder, &exynos_dpi_encoder_helper_funcs);\n\n\tret = exynos_drm_set_possible_crtcs(encoder, EXYNOS_DISPLAY_TYPE_LCD);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = exynos_dpi_create_connector(encoder);\n\tif (ret) {\n\t\tDRM_DEV_ERROR(encoder_to_dpi(encoder)->dev,\n\t\t\t      \"failed to create connector ret = %d\\n\", ret);\n\t\tdrm_encoder_cleanup(encoder);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstruct drm_encoder *exynos_dpi_probe(struct device *dev)\n{\n\tstruct exynos_dpi *ctx;\n\tint ret;\n\n\tctx = devm_kzalloc(dev, sizeof(*ctx), GFP_KERNEL);\n\tif (!ctx)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tctx->dev = dev;\n\n\tret = exynos_dpi_parse_dt(ctx);\n\tif (ret < 0) {\n\t\tdevm_kfree(dev, ctx);\n\t\treturn NULL;\n\t}\n\n\tif (ctx->panel_node) {\n\t\tctx->panel = of_drm_find_panel(ctx->panel_node);\n\t\tif (IS_ERR(ctx->panel))\n\t\t\treturn ERR_CAST(ctx->panel);\n\t}\n\n\treturn &ctx->encoder;\n}\n\nint exynos_dpi_remove(struct drm_encoder *encoder)\n{\n\tstruct exynos_dpi *ctx = encoder_to_dpi(encoder);\n\n\texynos_dpi_disable(&ctx->encoder);\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}