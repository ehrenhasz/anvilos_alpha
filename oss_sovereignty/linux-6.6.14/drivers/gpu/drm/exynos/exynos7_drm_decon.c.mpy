{
  "module_name": "exynos7_drm_decon.c",
  "hash_id": "33871c869d4ced132a44ac0d823828f16e0a9822bf682580b424dbd0e2e24fcb",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/exynos/exynos7_drm_decon.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/component.h>\n#include <linux/kernel.h>\n#include <linux/of.h>\n#include <linux/of_address.h>\n#include <linux/platform_device.h>\n#include <linux/pm_runtime.h>\n\n#include <video/of_display_timing.h>\n#include <video/of_videomode.h>\n\n#include <drm/drm_fourcc.h>\n#include <drm/drm_framebuffer.h>\n#include <drm/drm_vblank.h>\n#include <drm/exynos_drm.h>\n\n#include \"exynos_drm_crtc.h\"\n#include \"exynos_drm_drv.h\"\n#include \"exynos_drm_fb.h\"\n#include \"exynos_drm_plane.h\"\n#include \"regs-decon7.h\"\n\n \n\n#define MIN_FB_WIDTH_FOR_16WORD_BURST 128\n\n#define WINDOWS_NR\t2\n\nstruct decon_context {\n\tstruct device\t\t\t*dev;\n\tstruct drm_device\t\t*drm_dev;\n\tvoid\t\t\t\t*dma_priv;\n\tstruct exynos_drm_crtc\t\t*crtc;\n\tstruct exynos_drm_plane\t\tplanes[WINDOWS_NR];\n\tstruct exynos_drm_plane_config\tconfigs[WINDOWS_NR];\n\tstruct clk\t\t\t*pclk;\n\tstruct clk\t\t\t*aclk;\n\tstruct clk\t\t\t*eclk;\n\tstruct clk\t\t\t*vclk;\n\tvoid __iomem\t\t\t*regs;\n\tunsigned long\t\t\tirq_flags;\n\tbool\t\t\t\ti80_if;\n\tbool\t\t\t\tsuspended;\n\twait_queue_head_t\t\twait_vsync_queue;\n\tatomic_t\t\t\twait_vsync_event;\n\n\tstruct drm_encoder *encoder;\n};\n\nstatic const struct of_device_id decon_driver_dt_match[] = {\n\t{.compatible = \"samsung,exynos7-decon\"},\n\t{},\n};\nMODULE_DEVICE_TABLE(of, decon_driver_dt_match);\n\nstatic const uint32_t decon_formats[] = {\n\tDRM_FORMAT_RGB565,\n\tDRM_FORMAT_XRGB8888,\n\tDRM_FORMAT_XBGR8888,\n\tDRM_FORMAT_RGBX8888,\n\tDRM_FORMAT_BGRX8888,\n\tDRM_FORMAT_ARGB8888,\n\tDRM_FORMAT_ABGR8888,\n\tDRM_FORMAT_RGBA8888,\n\tDRM_FORMAT_BGRA8888,\n};\n\nstatic const enum drm_plane_type decon_win_types[WINDOWS_NR] = {\n\tDRM_PLANE_TYPE_PRIMARY,\n\tDRM_PLANE_TYPE_CURSOR,\n};\n\nstatic void decon_wait_for_vblank(struct exynos_drm_crtc *crtc)\n{\n\tstruct decon_context *ctx = crtc->ctx;\n\n\tif (ctx->suspended)\n\t\treturn;\n\n\tatomic_set(&ctx->wait_vsync_event, 1);\n\n\t \n\tif (!wait_event_timeout(ctx->wait_vsync_queue,\n\t\t\t\t!atomic_read(&ctx->wait_vsync_event),\n\t\t\t\tHZ/20))\n\t\tDRM_DEV_DEBUG_KMS(ctx->dev, \"vblank wait timed out.\\n\");\n}\n\nstatic void decon_clear_channels(struct exynos_drm_crtc *crtc)\n{\n\tstruct decon_context *ctx = crtc->ctx;\n\tunsigned int win, ch_enabled = 0;\n\n\t \n\tfor (win = 0; win < WINDOWS_NR; win++) {\n\t\tu32 val = readl(ctx->regs + WINCON(win));\n\n\t\tif (val & WINCONx_ENWIN) {\n\t\t\tval &= ~WINCONx_ENWIN;\n\t\t\twritel(val, ctx->regs + WINCON(win));\n\t\t\tch_enabled = 1;\n\t\t}\n\t}\n\n\t \n\tif (ch_enabled)\n\t\tdecon_wait_for_vblank(ctx->crtc);\n}\n\nstatic int decon_ctx_initialize(struct decon_context *ctx,\n\t\t\tstruct drm_device *drm_dev)\n{\n\tctx->drm_dev = drm_dev;\n\n\tdecon_clear_channels(ctx->crtc);\n\n\treturn exynos_drm_register_dma(drm_dev, ctx->dev, &ctx->dma_priv);\n}\n\nstatic void decon_ctx_remove(struct decon_context *ctx)\n{\n\t \n\texynos_drm_unregister_dma(ctx->drm_dev, ctx->dev, &ctx->dma_priv);\n}\n\nstatic u32 decon_calc_clkdiv(struct decon_context *ctx,\n\t\tconst struct drm_display_mode *mode)\n{\n\tunsigned long ideal_clk = mode->clock;\n\tu32 clkdiv;\n\n\t \n\tclkdiv = DIV_ROUND_UP(clk_get_rate(ctx->vclk), ideal_clk);\n\n\treturn (clkdiv < 0x100) ? clkdiv : 0xff;\n}\n\nstatic void decon_commit(struct exynos_drm_crtc *crtc)\n{\n\tstruct decon_context *ctx = crtc->ctx;\n\tstruct drm_display_mode *mode = &crtc->base.state->adjusted_mode;\n\tu32 val, clkdiv;\n\n\tif (ctx->suspended)\n\t\treturn;\n\n\t \n\tif (mode->htotal == 0 || mode->vtotal == 0)\n\t\treturn;\n\n\tif (!ctx->i80_if) {\n\t\tint vsync_len, vbpd, vfpd, hsync_len, hbpd, hfpd;\n\t       \n\t\tvsync_len = mode->crtc_vsync_end - mode->crtc_vsync_start;\n\t\tvbpd = mode->crtc_vtotal - mode->crtc_vsync_end;\n\t\tvfpd = mode->crtc_vsync_start - mode->crtc_vdisplay;\n\n\t\tval = VIDTCON0_VBPD(vbpd - 1) | VIDTCON0_VFPD(vfpd - 1);\n\t\twritel(val, ctx->regs + VIDTCON0);\n\n\t\tval = VIDTCON1_VSPW(vsync_len - 1);\n\t\twritel(val, ctx->regs + VIDTCON1);\n\n\t\t \n\t\thsync_len = mode->crtc_hsync_end - mode->crtc_hsync_start;\n\t\thbpd = mode->crtc_htotal - mode->crtc_hsync_end;\n\t\thfpd = mode->crtc_hsync_start - mode->crtc_hdisplay;\n\n\t\t \n\t\tval = VIDTCON2_HBPD(hbpd - 1) | VIDTCON2_HFPD(hfpd - 1);\n\t\twritel(val, ctx->regs + VIDTCON2);\n\n\t\tval = VIDTCON3_HSPW(hsync_len - 1);\n\t\twritel(val, ctx->regs + VIDTCON3);\n\t}\n\n\t \n\tval = VIDTCON4_LINEVAL(mode->vdisplay - 1) |\n\t       VIDTCON4_HOZVAL(mode->hdisplay - 1);\n\twritel(val, ctx->regs + VIDTCON4);\n\n\twritel(mode->vdisplay - 1, ctx->regs + LINECNT_OP_THRESHOLD);\n\n\t \n\tval = VIDCON0_ENVID | VIDCON0_ENVID_F;\n\twritel(val, ctx->regs + VIDCON0);\n\n\tclkdiv = decon_calc_clkdiv(ctx, mode);\n\tif (clkdiv > 1) {\n\t\tval = VCLKCON1_CLKVAL_NUM_VCLK(clkdiv - 1);\n\t\twritel(val, ctx->regs + VCLKCON1);\n\t\twritel(val, ctx->regs + VCLKCON2);\n\t}\n\n\tval = readl(ctx->regs + DECON_UPDATE);\n\tval |= DECON_UPDATE_STANDALONE_F;\n\twritel(val, ctx->regs + DECON_UPDATE);\n}\n\nstatic int decon_enable_vblank(struct exynos_drm_crtc *crtc)\n{\n\tstruct decon_context *ctx = crtc->ctx;\n\tu32 val;\n\n\tif (ctx->suspended)\n\t\treturn -EPERM;\n\n\tif (!test_and_set_bit(0, &ctx->irq_flags)) {\n\t\tval = readl(ctx->regs + VIDINTCON0);\n\n\t\tval |= VIDINTCON0_INT_ENABLE;\n\n\t\tif (!ctx->i80_if) {\n\t\t\tval |= VIDINTCON0_INT_FRAME;\n\t\t\tval &= ~VIDINTCON0_FRAMESEL0_MASK;\n\t\t\tval |= VIDINTCON0_FRAMESEL0_VSYNC;\n\t\t}\n\n\t\twritel(val, ctx->regs + VIDINTCON0);\n\t}\n\n\treturn 0;\n}\n\nstatic void decon_disable_vblank(struct exynos_drm_crtc *crtc)\n{\n\tstruct decon_context *ctx = crtc->ctx;\n\tu32 val;\n\n\tif (ctx->suspended)\n\t\treturn;\n\n\tif (test_and_clear_bit(0, &ctx->irq_flags)) {\n\t\tval = readl(ctx->regs + VIDINTCON0);\n\n\t\tval &= ~VIDINTCON0_INT_ENABLE;\n\t\tif (!ctx->i80_if)\n\t\t\tval &= ~VIDINTCON0_INT_FRAME;\n\n\t\twritel(val, ctx->regs + VIDINTCON0);\n\t}\n}\n\nstatic void decon_win_set_pixfmt(struct decon_context *ctx, unsigned int win,\n\t\t\t\t struct drm_framebuffer *fb)\n{\n\tunsigned long val;\n\tint padding;\n\n\tval = readl(ctx->regs + WINCON(win));\n\tval &= ~WINCONx_BPPMODE_MASK;\n\n\tswitch (fb->format->format) {\n\tcase DRM_FORMAT_RGB565:\n\t\tval |= WINCONx_BPPMODE_16BPP_565;\n\t\tval |= WINCONx_BURSTLEN_16WORD;\n\t\tbreak;\n\tcase DRM_FORMAT_XRGB8888:\n\t\tval |= WINCONx_BPPMODE_24BPP_xRGB;\n\t\tval |= WINCONx_BURSTLEN_16WORD;\n\t\tbreak;\n\tcase DRM_FORMAT_XBGR8888:\n\t\tval |= WINCONx_BPPMODE_24BPP_xBGR;\n\t\tval |= WINCONx_BURSTLEN_16WORD;\n\t\tbreak;\n\tcase DRM_FORMAT_RGBX8888:\n\t\tval |= WINCONx_BPPMODE_24BPP_RGBx;\n\t\tval |= WINCONx_BURSTLEN_16WORD;\n\t\tbreak;\n\tcase DRM_FORMAT_BGRX8888:\n\t\tval |= WINCONx_BPPMODE_24BPP_BGRx;\n\t\tval |= WINCONx_BURSTLEN_16WORD;\n\t\tbreak;\n\tcase DRM_FORMAT_ARGB8888:\n\t\tval |= WINCONx_BPPMODE_32BPP_ARGB | WINCONx_BLD_PIX |\n\t\t\tWINCONx_ALPHA_SEL;\n\t\tval |= WINCONx_BURSTLEN_16WORD;\n\t\tbreak;\n\tcase DRM_FORMAT_ABGR8888:\n\t\tval |= WINCONx_BPPMODE_32BPP_ABGR | WINCONx_BLD_PIX |\n\t\t\tWINCONx_ALPHA_SEL;\n\t\tval |= WINCONx_BURSTLEN_16WORD;\n\t\tbreak;\n\tcase DRM_FORMAT_RGBA8888:\n\t\tval |= WINCONx_BPPMODE_32BPP_RGBA | WINCONx_BLD_PIX |\n\t\t\tWINCONx_ALPHA_SEL;\n\t\tval |= WINCONx_BURSTLEN_16WORD;\n\t\tbreak;\n\tcase DRM_FORMAT_BGRA8888:\n\tdefault:\n\t\tval |= WINCONx_BPPMODE_32BPP_BGRA | WINCONx_BLD_PIX |\n\t\t\tWINCONx_ALPHA_SEL;\n\t\tval |= WINCONx_BURSTLEN_16WORD;\n\t\tbreak;\n\t}\n\n\tDRM_DEV_DEBUG_KMS(ctx->dev, \"cpp = %d\\n\", fb->format->cpp[0]);\n\n\t \n\n\tpadding = (fb->pitches[0] / fb->format->cpp[0]) - fb->width;\n\tif (fb->width + padding < MIN_FB_WIDTH_FOR_16WORD_BURST) {\n\t\tval &= ~WINCONx_BURSTLEN_MASK;\n\t\tval |= WINCONx_BURSTLEN_8WORD;\n\t}\n\n\twritel(val, ctx->regs + WINCON(win));\n}\n\nstatic void decon_win_set_colkey(struct decon_context *ctx, unsigned int win)\n{\n\tunsigned int keycon0 = 0, keycon1 = 0;\n\n\tkeycon0 = ~(WxKEYCON0_KEYBL_EN | WxKEYCON0_KEYEN_F |\n\t\t\tWxKEYCON0_DIRCON) | WxKEYCON0_COMPKEY(0);\n\n\tkeycon1 = WxKEYCON1_COLVAL(0xffffffff);\n\n\twritel(keycon0, ctx->regs + WKEYCON0_BASE(win));\n\twritel(keycon1, ctx->regs + WKEYCON1_BASE(win));\n}\n\n \nstatic void decon_shadow_protect_win(struct decon_context *ctx,\n\t\t\t\t     unsigned int win, bool protect)\n{\n\tu32 bits, val;\n\n\tbits = SHADOWCON_WINx_PROTECT(win);\n\n\tval = readl(ctx->regs + SHADOWCON);\n\tif (protect)\n\t\tval |= bits;\n\telse\n\t\tval &= ~bits;\n\twritel(val, ctx->regs + SHADOWCON);\n}\n\nstatic void decon_atomic_begin(struct exynos_drm_crtc *crtc)\n{\n\tstruct decon_context *ctx = crtc->ctx;\n\tint i;\n\n\tif (ctx->suspended)\n\t\treturn;\n\n\tfor (i = 0; i < WINDOWS_NR; i++)\n\t\tdecon_shadow_protect_win(ctx, i, true);\n}\n\nstatic void decon_update_plane(struct exynos_drm_crtc *crtc,\n\t\t\t       struct exynos_drm_plane *plane)\n{\n\tstruct exynos_drm_plane_state *state =\n\t\t\t\tto_exynos_plane_state(plane->base.state);\n\tstruct decon_context *ctx = crtc->ctx;\n\tstruct drm_framebuffer *fb = state->base.fb;\n\tint padding;\n\tunsigned long val, alpha;\n\tunsigned int last_x;\n\tunsigned int last_y;\n\tunsigned int win = plane->index;\n\tunsigned int cpp = fb->format->cpp[0];\n\tunsigned int pitch = fb->pitches[0];\n\n\tif (ctx->suspended)\n\t\treturn;\n\n\t \n\n\t \n\tval = (unsigned long)exynos_drm_fb_dma_addr(fb, 0);\n\twritel(val, ctx->regs + VIDW_BUF_START(win));\n\n\tpadding = (pitch / cpp) - fb->width;\n\n\t \n\twritel(fb->width + padding, ctx->regs + VIDW_WHOLE_X(win));\n\twritel(fb->height, ctx->regs + VIDW_WHOLE_Y(win));\n\n\t \n\twritel(state->src.x, ctx->regs + VIDW_OFFSET_X(win));\n\twritel(state->src.y, ctx->regs + VIDW_OFFSET_Y(win));\n\n\tDRM_DEV_DEBUG_KMS(ctx->dev, \"start addr = 0x%lx\\n\",\n\t\t\t(unsigned long)val);\n\tDRM_DEV_DEBUG_KMS(ctx->dev, \"ovl_width = %d, ovl_height = %d\\n\",\n\t\t\tstate->crtc.w, state->crtc.h);\n\n\tval = VIDOSDxA_TOPLEFT_X(state->crtc.x) |\n\t\tVIDOSDxA_TOPLEFT_Y(state->crtc.y);\n\twritel(val, ctx->regs + VIDOSD_A(win));\n\n\tlast_x = state->crtc.x + state->crtc.w;\n\tif (last_x)\n\t\tlast_x--;\n\tlast_y = state->crtc.y + state->crtc.h;\n\tif (last_y)\n\t\tlast_y--;\n\n\tval = VIDOSDxB_BOTRIGHT_X(last_x) | VIDOSDxB_BOTRIGHT_Y(last_y);\n\n\twritel(val, ctx->regs + VIDOSD_B(win));\n\n\tDRM_DEV_DEBUG_KMS(ctx->dev, \"osd pos: tx = %d, ty = %d, bx = %d, by = %d\\n\",\n\t\t\tstate->crtc.x, state->crtc.y, last_x, last_y);\n\n\t \n\talpha = VIDOSDxC_ALPHA0_R_F(0x0) |\n\t\t\tVIDOSDxC_ALPHA0_G_F(0x0) |\n\t\t\tVIDOSDxC_ALPHA0_B_F(0x0);\n\n\twritel(alpha, ctx->regs + VIDOSD_C(win));\n\n\talpha = VIDOSDxD_ALPHA1_R_F(0xff) |\n\t\t\tVIDOSDxD_ALPHA1_G_F(0xff) |\n\t\t\tVIDOSDxD_ALPHA1_B_F(0xff);\n\n\twritel(alpha, ctx->regs + VIDOSD_D(win));\n\n\tdecon_win_set_pixfmt(ctx, win, fb);\n\n\t \n\tif (win != 0)\n\t\tdecon_win_set_colkey(ctx, win);\n\n\t \n\tval = readl(ctx->regs + WINCON(win));\n\tval |= WINCONx_TRIPLE_BUF_MODE;\n\tval |= WINCONx_ENWIN;\n\twritel(val, ctx->regs + WINCON(win));\n\n\t \n\tdecon_shadow_protect_win(ctx, win, false);\n\n\tval = readl(ctx->regs + DECON_UPDATE);\n\tval |= DECON_UPDATE_STANDALONE_F;\n\twritel(val, ctx->regs + DECON_UPDATE);\n}\n\nstatic void decon_disable_plane(struct exynos_drm_crtc *crtc,\n\t\t\t\tstruct exynos_drm_plane *plane)\n{\n\tstruct decon_context *ctx = crtc->ctx;\n\tunsigned int win = plane->index;\n\tu32 val;\n\n\tif (ctx->suspended)\n\t\treturn;\n\n\t \n\tdecon_shadow_protect_win(ctx, win, true);\n\n\t \n\tval = readl(ctx->regs + WINCON(win));\n\tval &= ~WINCONx_ENWIN;\n\twritel(val, ctx->regs + WINCON(win));\n\n\tval = readl(ctx->regs + DECON_UPDATE);\n\tval |= DECON_UPDATE_STANDALONE_F;\n\twritel(val, ctx->regs + DECON_UPDATE);\n}\n\nstatic void decon_atomic_flush(struct exynos_drm_crtc *crtc)\n{\n\tstruct decon_context *ctx = crtc->ctx;\n\tint i;\n\n\tif (ctx->suspended)\n\t\treturn;\n\n\tfor (i = 0; i < WINDOWS_NR; i++)\n\t\tdecon_shadow_protect_win(ctx, i, false);\n\texynos_crtc_handle_event(crtc);\n}\n\nstatic void decon_init(struct decon_context *ctx)\n{\n\tu32 val;\n\n\twritel(VIDCON0_SWRESET, ctx->regs + VIDCON0);\n\n\tval = VIDOUTCON0_DISP_IF_0_ON;\n\tif (!ctx->i80_if)\n\t\tval |= VIDOUTCON0_RGBIF;\n\twritel(val, ctx->regs + VIDOUTCON0);\n\n\twritel(VCLKCON0_CLKVALUP | VCLKCON0_VCLKFREE, ctx->regs + VCLKCON0);\n\n\tif (!ctx->i80_if)\n\t\twritel(VIDCON1_VCLK_HOLD, ctx->regs + VIDCON1(0));\n}\n\nstatic void decon_atomic_enable(struct exynos_drm_crtc *crtc)\n{\n\tstruct decon_context *ctx = crtc->ctx;\n\tint ret;\n\n\tif (!ctx->suspended)\n\t\treturn;\n\n\tret = pm_runtime_resume_and_get(ctx->dev);\n\tif (ret < 0) {\n\t\tDRM_DEV_ERROR(ctx->dev, \"failed to enable DECON device.\\n\");\n\t\treturn;\n\t}\n\n\tdecon_init(ctx);\n\n\t \n\tif (test_and_clear_bit(0, &ctx->irq_flags))\n\t\tdecon_enable_vblank(ctx->crtc);\n\n\tdecon_commit(ctx->crtc);\n\n\tctx->suspended = false;\n}\n\nstatic void decon_atomic_disable(struct exynos_drm_crtc *crtc)\n{\n\tstruct decon_context *ctx = crtc->ctx;\n\tint i;\n\n\tif (ctx->suspended)\n\t\treturn;\n\n\t \n\tfor (i = 0; i < WINDOWS_NR; i++)\n\t\tdecon_disable_plane(crtc, &ctx->planes[i]);\n\n\tpm_runtime_put_sync(ctx->dev);\n\n\tctx->suspended = true;\n}\n\nstatic const struct exynos_drm_crtc_ops decon_crtc_ops = {\n\t.atomic_enable = decon_atomic_enable,\n\t.atomic_disable = decon_atomic_disable,\n\t.enable_vblank = decon_enable_vblank,\n\t.disable_vblank = decon_disable_vblank,\n\t.atomic_begin = decon_atomic_begin,\n\t.update_plane = decon_update_plane,\n\t.disable_plane = decon_disable_plane,\n\t.atomic_flush = decon_atomic_flush,\n};\n\n\nstatic irqreturn_t decon_irq_handler(int irq, void *dev_id)\n{\n\tstruct decon_context *ctx = (struct decon_context *)dev_id;\n\tu32 val, clear_bit;\n\n\tval = readl(ctx->regs + VIDINTCON1);\n\n\tclear_bit = ctx->i80_if ? VIDINTCON1_INT_I80 : VIDINTCON1_INT_FRAME;\n\tif (val & clear_bit)\n\t\twritel(clear_bit, ctx->regs + VIDINTCON1);\n\n\t \n\tif (!ctx->drm_dev)\n\t\tgoto out;\n\n\tif (!ctx->i80_if) {\n\t\tdrm_crtc_handle_vblank(&ctx->crtc->base);\n\n\t\t \n\t\tif (atomic_read(&ctx->wait_vsync_event)) {\n\t\t\tatomic_set(&ctx->wait_vsync_event, 0);\n\t\t\twake_up(&ctx->wait_vsync_queue);\n\t\t}\n\t}\nout:\n\treturn IRQ_HANDLED;\n}\n\nstatic int decon_bind(struct device *dev, struct device *master, void *data)\n{\n\tstruct decon_context *ctx = dev_get_drvdata(dev);\n\tstruct drm_device *drm_dev = data;\n\tstruct exynos_drm_plane *exynos_plane;\n\tunsigned int i;\n\tint ret;\n\n\tret = decon_ctx_initialize(ctx, drm_dev);\n\tif (ret) {\n\t\tDRM_DEV_ERROR(dev, \"decon_ctx_initialize failed.\\n\");\n\t\treturn ret;\n\t}\n\n\tfor (i = 0; i < WINDOWS_NR; i++) {\n\t\tctx->configs[i].pixel_formats = decon_formats;\n\t\tctx->configs[i].num_pixel_formats = ARRAY_SIZE(decon_formats);\n\t\tctx->configs[i].zpos = i;\n\t\tctx->configs[i].type = decon_win_types[i];\n\n\t\tret = exynos_plane_init(drm_dev, &ctx->planes[i], i,\n\t\t\t\t\t&ctx->configs[i]);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\texynos_plane = &ctx->planes[DEFAULT_WIN];\n\tctx->crtc = exynos_drm_crtc_create(drm_dev, &exynos_plane->base,\n\t\t\tEXYNOS_DISPLAY_TYPE_LCD, &decon_crtc_ops, ctx);\n\tif (IS_ERR(ctx->crtc)) {\n\t\tdecon_ctx_remove(ctx);\n\t\treturn PTR_ERR(ctx->crtc);\n\t}\n\n\tif (ctx->encoder)\n\t\texynos_dpi_bind(drm_dev, ctx->encoder);\n\n\treturn 0;\n\n}\n\nstatic void decon_unbind(struct device *dev, struct device *master,\n\t\t\tvoid *data)\n{\n\tstruct decon_context *ctx = dev_get_drvdata(dev);\n\n\tdecon_atomic_disable(ctx->crtc);\n\n\tif (ctx->encoder)\n\t\texynos_dpi_remove(ctx->encoder);\n\n\tdecon_ctx_remove(ctx);\n}\n\nstatic const struct component_ops decon_component_ops = {\n\t.bind\t= decon_bind,\n\t.unbind = decon_unbind,\n};\n\nstatic int decon_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct decon_context *ctx;\n\tstruct device_node *i80_if_timings;\n\tint ret;\n\n\tif (!dev->of_node)\n\t\treturn -ENODEV;\n\n\tctx = devm_kzalloc(dev, sizeof(*ctx), GFP_KERNEL);\n\tif (!ctx)\n\t\treturn -ENOMEM;\n\n\tctx->dev = dev;\n\tctx->suspended = true;\n\n\ti80_if_timings = of_get_child_by_name(dev->of_node, \"i80-if-timings\");\n\tif (i80_if_timings)\n\t\tctx->i80_if = true;\n\tof_node_put(i80_if_timings);\n\n\tctx->regs = of_iomap(dev->of_node, 0);\n\tif (!ctx->regs)\n\t\treturn -ENOMEM;\n\n\tctx->pclk = devm_clk_get(dev, \"pclk_decon0\");\n\tif (IS_ERR(ctx->pclk)) {\n\t\tdev_err(dev, \"failed to get bus clock pclk\\n\");\n\t\tret = PTR_ERR(ctx->pclk);\n\t\tgoto err_iounmap;\n\t}\n\n\tctx->aclk = devm_clk_get(dev, \"aclk_decon0\");\n\tif (IS_ERR(ctx->aclk)) {\n\t\tdev_err(dev, \"failed to get bus clock aclk\\n\");\n\t\tret = PTR_ERR(ctx->aclk);\n\t\tgoto err_iounmap;\n\t}\n\n\tctx->eclk = devm_clk_get(dev, \"decon0_eclk\");\n\tif (IS_ERR(ctx->eclk)) {\n\t\tdev_err(dev, \"failed to get eclock\\n\");\n\t\tret = PTR_ERR(ctx->eclk);\n\t\tgoto err_iounmap;\n\t}\n\n\tctx->vclk = devm_clk_get(dev, \"decon0_vclk\");\n\tif (IS_ERR(ctx->vclk)) {\n\t\tdev_err(dev, \"failed to get vclock\\n\");\n\t\tret = PTR_ERR(ctx->vclk);\n\t\tgoto err_iounmap;\n\t}\n\n\tret =  platform_get_irq_byname(pdev, ctx->i80_if ? \"lcd_sys\" : \"vsync\");\n\tif (ret < 0)\n\t\tgoto err_iounmap;\n\n\tret = devm_request_irq(dev, ret, decon_irq_handler, 0, \"drm_decon\", ctx);\n\tif (ret) {\n\t\tdev_err(dev, \"irq request failed.\\n\");\n\t\tgoto err_iounmap;\n\t}\n\n\tinit_waitqueue_head(&ctx->wait_vsync_queue);\n\tatomic_set(&ctx->wait_vsync_event, 0);\n\n\tplatform_set_drvdata(pdev, ctx);\n\n\tctx->encoder = exynos_dpi_probe(dev);\n\tif (IS_ERR(ctx->encoder)) {\n\t\tret = PTR_ERR(ctx->encoder);\n\t\tgoto err_iounmap;\n\t}\n\n\tpm_runtime_enable(dev);\n\n\tret = component_add(dev, &decon_component_ops);\n\tif (ret)\n\t\tgoto err_disable_pm_runtime;\n\n\treturn ret;\n\nerr_disable_pm_runtime:\n\tpm_runtime_disable(dev);\n\nerr_iounmap:\n\tiounmap(ctx->regs);\n\n\treturn ret;\n}\n\nstatic int decon_remove(struct platform_device *pdev)\n{\n\tstruct decon_context *ctx = dev_get_drvdata(&pdev->dev);\n\n\tpm_runtime_disable(&pdev->dev);\n\n\tiounmap(ctx->regs);\n\n\tcomponent_del(&pdev->dev, &decon_component_ops);\n\n\treturn 0;\n}\n\nstatic int exynos7_decon_suspend(struct device *dev)\n{\n\tstruct decon_context *ctx = dev_get_drvdata(dev);\n\n\tclk_disable_unprepare(ctx->vclk);\n\tclk_disable_unprepare(ctx->eclk);\n\tclk_disable_unprepare(ctx->aclk);\n\tclk_disable_unprepare(ctx->pclk);\n\n\treturn 0;\n}\n\nstatic int exynos7_decon_resume(struct device *dev)\n{\n\tstruct decon_context *ctx = dev_get_drvdata(dev);\n\tint ret;\n\n\tret = clk_prepare_enable(ctx->pclk);\n\tif (ret < 0) {\n\t\tDRM_DEV_ERROR(dev, \"Failed to prepare_enable the pclk [%d]\\n\",\n\t\t\t      ret);\n\t\tgoto err_pclk_enable;\n\t}\n\n\tret = clk_prepare_enable(ctx->aclk);\n\tif (ret < 0) {\n\t\tDRM_DEV_ERROR(dev, \"Failed to prepare_enable the aclk [%d]\\n\",\n\t\t\t      ret);\n\t\tgoto err_aclk_enable;\n\t}\n\n\tret = clk_prepare_enable(ctx->eclk);\n\tif  (ret < 0) {\n\t\tDRM_DEV_ERROR(dev, \"Failed to prepare_enable the eclk [%d]\\n\",\n\t\t\t      ret);\n\t\tgoto err_eclk_enable;\n\t}\n\n\tret = clk_prepare_enable(ctx->vclk);\n\tif  (ret < 0) {\n\t\tDRM_DEV_ERROR(dev, \"Failed to prepare_enable the vclk [%d]\\n\",\n\t\t\t      ret);\n\t\tgoto err_vclk_enable;\n\t}\n\n\treturn 0;\n\nerr_vclk_enable:\n\tclk_disable_unprepare(ctx->eclk);\nerr_eclk_enable:\n\tclk_disable_unprepare(ctx->aclk);\nerr_aclk_enable:\n\tclk_disable_unprepare(ctx->pclk);\nerr_pclk_enable:\n\treturn ret;\n}\n\nstatic DEFINE_RUNTIME_DEV_PM_OPS(exynos7_decon_pm_ops, exynos7_decon_suspend,\n\t\t\t\t exynos7_decon_resume, NULL);\n\nstruct platform_driver decon_driver = {\n\t.probe\t\t= decon_probe,\n\t.remove\t\t= decon_remove,\n\t.driver\t\t= {\n\t\t.name\t= \"exynos-decon\",\n\t\t.pm\t= pm_ptr(&exynos7_decon_pm_ops),\n\t\t.of_match_table = decon_driver_dt_match,\n\t},\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}