{
  "module_name": "exynos_drm_gem.c",
  "hash_id": "408718c1e1dd1c69d17c0a937c182d24227c4618489b6c791f397d2edace4522",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/exynos/exynos_drm_gem.c",
  "human_readable_source": "\n \n\n\n#include <linux/dma-buf.h>\n#include <linux/pfn_t.h>\n#include <linux/shmem_fs.h>\n#include <linux/module.h>\n\n#include <drm/drm_prime.h>\n#include <drm/drm_vma_manager.h>\n#include <drm/exynos_drm.h>\n\n#include \"exynos_drm_drv.h\"\n#include \"exynos_drm_gem.h\"\n\nMODULE_IMPORT_NS(DMA_BUF);\n\nstatic int exynos_drm_gem_mmap(struct drm_gem_object *obj, struct vm_area_struct *vma);\n\nstatic int exynos_drm_alloc_buf(struct exynos_drm_gem *exynos_gem, bool kvmap)\n{\n\tstruct drm_device *dev = exynos_gem->base.dev;\n\tunsigned long attr = 0;\n\n\tif (exynos_gem->dma_addr) {\n\t\tDRM_DEV_DEBUG_KMS(to_dma_dev(dev), \"already allocated.\\n\");\n\t\treturn 0;\n\t}\n\n\t \n\tif (!(exynos_gem->flags & EXYNOS_BO_NONCONTIG))\n\t\tattr |= DMA_ATTR_FORCE_CONTIGUOUS;\n\n\t \n\tif (exynos_gem->flags & EXYNOS_BO_WC ||\n\t\t\t!(exynos_gem->flags & EXYNOS_BO_CACHABLE))\n\t\tattr |= DMA_ATTR_WRITE_COMBINE;\n\n\t \n\tif (!kvmap)\n\t\tattr |= DMA_ATTR_NO_KERNEL_MAPPING;\n\n\texynos_gem->dma_attrs = attr;\n\texynos_gem->cookie = dma_alloc_attrs(to_dma_dev(dev), exynos_gem->size,\n\t\t\t\t\t     &exynos_gem->dma_addr, GFP_KERNEL,\n\t\t\t\t\t     exynos_gem->dma_attrs);\n\tif (!exynos_gem->cookie) {\n\t\tDRM_DEV_ERROR(to_dma_dev(dev), \"failed to allocate buffer.\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tif (kvmap)\n\t\texynos_gem->kvaddr = exynos_gem->cookie;\n\n\tDRM_DEV_DEBUG_KMS(to_dma_dev(dev), \"dma_addr(0x%lx), size(0x%lx)\\n\",\n\t\t\t(unsigned long)exynos_gem->dma_addr, exynos_gem->size);\n\treturn 0;\n}\n\nstatic void exynos_drm_free_buf(struct exynos_drm_gem *exynos_gem)\n{\n\tstruct drm_device *dev = exynos_gem->base.dev;\n\n\tif (!exynos_gem->dma_addr) {\n\t\tDRM_DEV_DEBUG_KMS(dev->dev, \"dma_addr is invalid.\\n\");\n\t\treturn;\n\t}\n\n\tDRM_DEV_DEBUG_KMS(dev->dev, \"dma_addr(0x%lx), size(0x%lx)\\n\",\n\t\t\t(unsigned long)exynos_gem->dma_addr, exynos_gem->size);\n\n\tdma_free_attrs(to_dma_dev(dev), exynos_gem->size, exynos_gem->cookie,\n\t\t\t(dma_addr_t)exynos_gem->dma_addr,\n\t\t\texynos_gem->dma_attrs);\n}\n\nstatic int exynos_drm_gem_handle_create(struct drm_gem_object *obj,\n\t\t\t\t\tstruct drm_file *file_priv,\n\t\t\t\t\tunsigned int *handle)\n{\n\tint ret;\n\n\t \n\tret = drm_gem_handle_create(file_priv, obj, handle);\n\tif (ret)\n\t\treturn ret;\n\n\tDRM_DEV_DEBUG_KMS(to_dma_dev(obj->dev), \"gem handle = 0x%x\\n\", *handle);\n\n\t \n\tdrm_gem_object_put(obj);\n\n\treturn 0;\n}\n\nvoid exynos_drm_gem_destroy(struct exynos_drm_gem *exynos_gem)\n{\n\tstruct drm_gem_object *obj = &exynos_gem->base;\n\n\tDRM_DEV_DEBUG_KMS(to_dma_dev(obj->dev), \"handle count = %d\\n\",\n\t\t\t  obj->handle_count);\n\n\t \n\tif (obj->import_attach)\n\t\tdrm_prime_gem_destroy(obj, exynos_gem->sgt);\n\telse\n\t\texynos_drm_free_buf(exynos_gem);\n\n\t \n\tdrm_gem_object_release(obj);\n\n\tkfree(exynos_gem);\n}\n\nstatic const struct vm_operations_struct exynos_drm_gem_vm_ops = {\n\t.open = drm_gem_vm_open,\n\t.close = drm_gem_vm_close,\n};\n\nstatic const struct drm_gem_object_funcs exynos_drm_gem_object_funcs = {\n\t.free = exynos_drm_gem_free_object,\n\t.get_sg_table = exynos_drm_gem_prime_get_sg_table,\n\t.mmap = exynos_drm_gem_mmap,\n\t.vm_ops = &exynos_drm_gem_vm_ops,\n};\n\nstatic struct exynos_drm_gem *exynos_drm_gem_init(struct drm_device *dev,\n\t\t\t\t\t\t  unsigned long size)\n{\n\tstruct exynos_drm_gem *exynos_gem;\n\tstruct drm_gem_object *obj;\n\tint ret;\n\n\texynos_gem = kzalloc(sizeof(*exynos_gem), GFP_KERNEL);\n\tif (!exynos_gem)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\texynos_gem->size = size;\n\tobj = &exynos_gem->base;\n\n\tobj->funcs = &exynos_drm_gem_object_funcs;\n\n\tret = drm_gem_object_init(dev, obj, size);\n\tif (ret < 0) {\n\t\tDRM_DEV_ERROR(dev->dev, \"failed to initialize gem object\\n\");\n\t\tkfree(exynos_gem);\n\t\treturn ERR_PTR(ret);\n\t}\n\n\tret = drm_gem_create_mmap_offset(obj);\n\tif (ret < 0) {\n\t\tdrm_gem_object_release(obj);\n\t\tkfree(exynos_gem);\n\t\treturn ERR_PTR(ret);\n\t}\n\n\tDRM_DEV_DEBUG_KMS(dev->dev, \"created file object = %pK\\n\", obj->filp);\n\n\treturn exynos_gem;\n}\n\nstruct exynos_drm_gem *exynos_drm_gem_create(struct drm_device *dev,\n\t\t\t\t\t     unsigned int flags,\n\t\t\t\t\t     unsigned long size,\n\t\t\t\t\t     bool kvmap)\n{\n\tstruct exynos_drm_gem *exynos_gem;\n\tint ret;\n\n\tif (flags & ~(EXYNOS_BO_MASK)) {\n\t\tDRM_DEV_ERROR(dev->dev,\n\t\t\t      \"invalid GEM buffer flags: %u\\n\", flags);\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\tif (!size) {\n\t\tDRM_DEV_ERROR(dev->dev, \"invalid GEM buffer size: %lu\\n\", size);\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\tsize = roundup(size, PAGE_SIZE);\n\n\texynos_gem = exynos_drm_gem_init(dev, size);\n\tif (IS_ERR(exynos_gem))\n\t\treturn exynos_gem;\n\n\tif (!is_drm_iommu_supported(dev) && (flags & EXYNOS_BO_NONCONTIG)) {\n\t\t \n\t\tflags &= ~EXYNOS_BO_NONCONTIG;\n\t\tDRM_WARN(\"Non-contiguous allocation is not supported without IOMMU, falling back to contiguous buffer\\n\");\n\t}\n\n\t \n\texynos_gem->flags = flags;\n\n\tret = exynos_drm_alloc_buf(exynos_gem, kvmap);\n\tif (ret < 0) {\n\t\tdrm_gem_object_release(&exynos_gem->base);\n\t\tkfree(exynos_gem);\n\t\treturn ERR_PTR(ret);\n\t}\n\n\treturn exynos_gem;\n}\n\nint exynos_drm_gem_create_ioctl(struct drm_device *dev, void *data,\n\t\t\t\tstruct drm_file *file_priv)\n{\n\tstruct drm_exynos_gem_create *args = data;\n\tstruct exynos_drm_gem *exynos_gem;\n\tint ret;\n\n\texynos_gem = exynos_drm_gem_create(dev, args->flags, args->size, false);\n\tif (IS_ERR(exynos_gem))\n\t\treturn PTR_ERR(exynos_gem);\n\n\tret = exynos_drm_gem_handle_create(&exynos_gem->base, file_priv,\n\t\t\t\t\t   &args->handle);\n\tif (ret) {\n\t\texynos_drm_gem_destroy(exynos_gem);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nint exynos_drm_gem_map_ioctl(struct drm_device *dev, void *data,\n\t\t\t     struct drm_file *file_priv)\n{\n\tstruct drm_exynos_gem_map *args = data;\n\n\treturn drm_gem_dumb_map_offset(file_priv, dev, args->handle,\n\t\t\t\t       &args->offset);\n}\n\nstruct exynos_drm_gem *exynos_drm_gem_get(struct drm_file *filp,\n\t\t\t\t\t  unsigned int gem_handle)\n{\n\tstruct drm_gem_object *obj;\n\n\tobj = drm_gem_object_lookup(filp, gem_handle);\n\tif (!obj)\n\t\treturn NULL;\n\treturn to_exynos_gem(obj);\n}\n\nstatic int exynos_drm_gem_mmap_buffer(struct exynos_drm_gem *exynos_gem,\n\t\t\t\t      struct vm_area_struct *vma)\n{\n\tstruct drm_device *drm_dev = exynos_gem->base.dev;\n\tunsigned long vm_size;\n\tint ret;\n\n\tvm_flags_clear(vma, VM_PFNMAP);\n\tvma->vm_pgoff = 0;\n\n\tvm_size = vma->vm_end - vma->vm_start;\n\n\t \n\tif (vm_size > exynos_gem->size)\n\t\treturn -EINVAL;\n\n\tret = dma_mmap_attrs(to_dma_dev(drm_dev), vma, exynos_gem->cookie,\n\t\t\t     exynos_gem->dma_addr, exynos_gem->size,\n\t\t\t     exynos_gem->dma_attrs);\n\tif (ret < 0) {\n\t\tDRM_ERROR(\"failed to mmap.\\n\");\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nint exynos_drm_gem_get_ioctl(struct drm_device *dev, void *data,\n\t\t\t\t      struct drm_file *file_priv)\n{\n\tstruct exynos_drm_gem *exynos_gem;\n\tstruct drm_exynos_gem_info *args = data;\n\tstruct drm_gem_object *obj;\n\n\tobj = drm_gem_object_lookup(file_priv, args->handle);\n\tif (!obj) {\n\t\tDRM_DEV_ERROR(dev->dev, \"failed to lookup gem object.\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\texynos_gem = to_exynos_gem(obj);\n\n\targs->flags = exynos_gem->flags;\n\targs->size = exynos_gem->size;\n\n\tdrm_gem_object_put(obj);\n\n\treturn 0;\n}\n\nvoid exynos_drm_gem_free_object(struct drm_gem_object *obj)\n{\n\texynos_drm_gem_destroy(to_exynos_gem(obj));\n}\n\nint exynos_drm_gem_dumb_create(struct drm_file *file_priv,\n\t\t\t       struct drm_device *dev,\n\t\t\t       struct drm_mode_create_dumb *args)\n{\n\tstruct exynos_drm_gem *exynos_gem;\n\tunsigned int flags;\n\tint ret;\n\n\t \n\n\targs->pitch = args->width * ((args->bpp + 7) / 8);\n\targs->size = args->pitch * args->height;\n\n\tif (is_drm_iommu_supported(dev))\n\t\tflags = EXYNOS_BO_NONCONTIG | EXYNOS_BO_WC;\n\telse\n\t\tflags = EXYNOS_BO_CONTIG | EXYNOS_BO_WC;\n\n\texynos_gem = exynos_drm_gem_create(dev, flags, args->size, false);\n\tif (IS_ERR(exynos_gem)) {\n\t\tdev_warn(dev->dev, \"FB allocation failed.\\n\");\n\t\treturn PTR_ERR(exynos_gem);\n\t}\n\n\tret = exynos_drm_gem_handle_create(&exynos_gem->base, file_priv,\n\t\t\t\t\t   &args->handle);\n\tif (ret) {\n\t\texynos_drm_gem_destroy(exynos_gem);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int exynos_drm_gem_mmap(struct drm_gem_object *obj, struct vm_area_struct *vma)\n{\n\tstruct exynos_drm_gem *exynos_gem = to_exynos_gem(obj);\n\tint ret;\n\n\tif (obj->import_attach)\n\t\treturn dma_buf_mmap(obj->dma_buf, vma, 0);\n\n\tvm_flags_set(vma, VM_IO | VM_DONTEXPAND | VM_DONTDUMP);\n\n\tDRM_DEV_DEBUG_KMS(to_dma_dev(obj->dev), \"flags = 0x%x\\n\",\n\t\t\t  exynos_gem->flags);\n\n\t \n\tif (exynos_gem->flags & EXYNOS_BO_CACHABLE)\n\t\tvma->vm_page_prot = vm_get_page_prot(vma->vm_flags);\n\telse if (exynos_gem->flags & EXYNOS_BO_WC)\n\t\tvma->vm_page_prot =\n\t\t\tpgprot_writecombine(vm_get_page_prot(vma->vm_flags));\n\telse\n\t\tvma->vm_page_prot =\n\t\t\tpgprot_noncached(vm_get_page_prot(vma->vm_flags));\n\n\tret = exynos_drm_gem_mmap_buffer(exynos_gem, vma);\n\tif (ret)\n\t\tgoto err_close_vm;\n\n\treturn ret;\n\nerr_close_vm:\n\tdrm_gem_vm_close(vma);\n\n\treturn ret;\n}\n\n \nstruct drm_gem_object *exynos_drm_gem_prime_import(struct drm_device *dev,\n\t\t\t\t\t    struct dma_buf *dma_buf)\n{\n\treturn drm_gem_prime_import_dev(dev, dma_buf, to_dma_dev(dev));\n}\n\nstruct sg_table *exynos_drm_gem_prime_get_sg_table(struct drm_gem_object *obj)\n{\n\tstruct exynos_drm_gem *exynos_gem = to_exynos_gem(obj);\n\tstruct drm_device *drm_dev = obj->dev;\n\tstruct sg_table *sgt;\n\tint ret;\n\n\tsgt = kzalloc(sizeof(*sgt), GFP_KERNEL);\n\tif (!sgt)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tret = dma_get_sgtable_attrs(to_dma_dev(drm_dev), sgt, exynos_gem->cookie,\n\t\t\t\t    exynos_gem->dma_addr, exynos_gem->size,\n\t\t\t\t    exynos_gem->dma_attrs);\n\tif (ret) {\n\t\tDRM_ERROR(\"failed to get sgtable, %d\\n\", ret);\n\t\tkfree(sgt);\n\t\treturn ERR_PTR(ret);\n\t}\n\n\treturn sgt;\n}\n\nstruct drm_gem_object *\nexynos_drm_gem_prime_import_sg_table(struct drm_device *dev,\n\t\t\t\t     struct dma_buf_attachment *attach,\n\t\t\t\t     struct sg_table *sgt)\n{\n\tstruct exynos_drm_gem *exynos_gem;\n\n\t \n\tif (drm_prime_get_contiguous_size(sgt) < attach->dmabuf->size) {\n\t\tDRM_ERROR(\"buffer chunks must be mapped contiguously\");\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\texynos_gem = exynos_drm_gem_init(dev, attach->dmabuf->size);\n\tif (IS_ERR(exynos_gem))\n\t\treturn ERR_CAST(exynos_gem);\n\n\t \n\tif (is_drm_iommu_supported(dev))\n\t\texynos_gem->flags |= EXYNOS_BO_NONCONTIG;\n\telse\n\t\texynos_gem->flags |= EXYNOS_BO_CONTIG;\n\n\texynos_gem->dma_addr = sg_dma_address(sgt->sgl);\n\texynos_gem->sgt = sgt;\n\treturn &exynos_gem->base;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}