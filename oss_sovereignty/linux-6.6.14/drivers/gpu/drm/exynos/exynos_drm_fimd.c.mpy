{
  "module_name": "exynos_drm_fimd.c",
  "hash_id": "3f6f48282815aa46f6751c5e56ca1e59b253f345c187fdb3b2a82af673073438",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/exynos/exynos_drm_fimd.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/component.h>\n#include <linux/kernel.h>\n#include <linux/mfd/syscon.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/pm_runtime.h>\n#include <linux/regmap.h>\n\n#include <video/of_display_timing.h>\n#include <video/of_videomode.h>\n#include <video/samsung_fimd.h>\n\n#include <drm/drm_blend.h>\n#include <drm/drm_fourcc.h>\n#include <drm/drm_framebuffer.h>\n#include <drm/drm_vblank.h>\n#include <drm/exynos_drm.h>\n\n#include \"exynos_drm_crtc.h\"\n#include \"exynos_drm_drv.h\"\n#include \"exynos_drm_fb.h\"\n#include \"exynos_drm_plane.h\"\n\n \n\n#define MIN_FB_WIDTH_FOR_16WORD_BURST 128\n\n \n#define VIDOSD_A(win)\t\t(VIDOSD_BASE + 0x00 + (win) * 16)\n#define VIDOSD_B(win)\t\t(VIDOSD_BASE + 0x04 + (win) * 16)\n \n#define VIDOSD_C(win)\t\t(VIDOSD_BASE + 0x08 + (win) * 16)\n \n#define VIDOSD_D(win)\t\t(VIDOSD_BASE + 0x0C + (win) * 16)\n\n#define VIDWnALPHA0(win)\t(VIDW_ALPHA + 0x00 + (win) * 8)\n#define VIDWnALPHA1(win)\t(VIDW_ALPHA + 0x04 + (win) * 8)\n\n#define VIDWx_BUF_START(win, buf)\t(VIDW_BUF_START(buf) + (win) * 8)\n#define VIDWx_BUF_START_S(win, buf)\t(VIDW_BUF_START_S(buf) + (win) * 8)\n#define VIDWx_BUF_END(win, buf)\t\t(VIDW_BUF_END(buf) + (win) * 8)\n#define VIDWx_BUF_SIZE(win, buf)\t(VIDW_BUF_SIZE(buf) + (win) * 4)\n\n \n#define WKEYCON0_BASE(x)\t\t((WKEYCON0 + 0x140) + ((x - 1) * 8))\n \n#define WKEYCON1_BASE(x)\t\t((WKEYCON1 + 0x140) + ((x - 1) * 8))\n\n \n#define TRIGCON\t\t\t\t0x1A4\n#define TRGMODE_ENABLE\t\t\t(1 << 0)\n#define SWTRGCMD_ENABLE\t\t\t(1 << 1)\n \n#define HWTRGEN_ENABLE\t\t\t(1 << 3)\n#define HWTRGMASK_ENABLE\t\t(1 << 4)\n \n#define HWTRIGEN_PER_ENABLE\t\t(1 << 31)\n\n \n#define VIDOUT_CON\t\t\t0x000\n#define VIDOUT_CON_F_I80_LDI0\t\t(0x2 << 8)\n\n \n#define I80IFCONFAx(x)\t\t\t(0x1B0 + (x) * 4)\n#define I80IFCONFBx(x)\t\t\t(0x1B8 + (x) * 4)\n#define LCD_CS_SETUP(x)\t\t\t((x) << 16)\n#define LCD_WR_SETUP(x)\t\t\t((x) << 12)\n#define LCD_WR_ACTIVE(x)\t\t((x) << 8)\n#define LCD_WR_HOLD(x)\t\t\t((x) << 4)\n#define I80IFEN_ENABLE\t\t\t(1 << 0)\n\n \n#define WINDOWS_NR\t5\n\n \n#define I80_HW_TRG     (1 << 1)\n\nstruct fimd_driver_data {\n\tunsigned int timing_base;\n\tunsigned int lcdblk_offset;\n\tunsigned int lcdblk_vt_shift;\n\tunsigned int lcdblk_bypass_shift;\n\tunsigned int lcdblk_mic_bypass_shift;\n\tunsigned int trg_type;\n\n\tunsigned int has_shadowcon:1;\n\tunsigned int has_clksel:1;\n\tunsigned int has_limited_fmt:1;\n\tunsigned int has_vidoutcon:1;\n\tunsigned int has_vtsel:1;\n\tunsigned int has_mic_bypass:1;\n\tunsigned int has_dp_clk:1;\n\tunsigned int has_hw_trigger:1;\n\tunsigned int has_trigger_per_te:1;\n\tunsigned int has_bgr_support:1;\n};\n\nstatic struct fimd_driver_data s3c64xx_fimd_driver_data = {\n\t.timing_base = 0x0,\n\t.has_clksel = 1,\n\t.has_limited_fmt = 1,\n};\n\nstatic struct fimd_driver_data s5pv210_fimd_driver_data = {\n\t.timing_base = 0x0,\n\t.has_shadowcon = 1,\n\t.has_clksel = 1,\n};\n\nstatic struct fimd_driver_data exynos3_fimd_driver_data = {\n\t.timing_base = 0x20000,\n\t.lcdblk_offset = 0x210,\n\t.lcdblk_bypass_shift = 1,\n\t.has_shadowcon = 1,\n\t.has_vidoutcon = 1,\n};\n\nstatic struct fimd_driver_data exynos4_fimd_driver_data = {\n\t.timing_base = 0x0,\n\t.lcdblk_offset = 0x210,\n\t.lcdblk_vt_shift = 10,\n\t.lcdblk_bypass_shift = 1,\n\t.has_shadowcon = 1,\n\t.has_vtsel = 1,\n\t.has_bgr_support = 1,\n};\n\nstatic struct fimd_driver_data exynos5_fimd_driver_data = {\n\t.timing_base = 0x20000,\n\t.lcdblk_offset = 0x214,\n\t.lcdblk_vt_shift = 24,\n\t.lcdblk_bypass_shift = 15,\n\t.has_shadowcon = 1,\n\t.has_vidoutcon = 1,\n\t.has_vtsel = 1,\n\t.has_dp_clk = 1,\n\t.has_bgr_support = 1,\n};\n\nstatic struct fimd_driver_data exynos5420_fimd_driver_data = {\n\t.timing_base = 0x20000,\n\t.lcdblk_offset = 0x214,\n\t.lcdblk_vt_shift = 24,\n\t.lcdblk_bypass_shift = 15,\n\t.lcdblk_mic_bypass_shift = 11,\n\t.has_shadowcon = 1,\n\t.has_vidoutcon = 1,\n\t.has_vtsel = 1,\n\t.has_mic_bypass = 1,\n\t.has_dp_clk = 1,\n\t.has_bgr_support = 1,\n};\n\nstruct fimd_context {\n\tstruct device\t\t\t*dev;\n\tstruct drm_device\t\t*drm_dev;\n\tvoid\t\t\t\t*dma_priv;\n\tstruct exynos_drm_crtc\t\t*crtc;\n\tstruct exynos_drm_plane\t\tplanes[WINDOWS_NR];\n\tstruct exynos_drm_plane_config\tconfigs[WINDOWS_NR];\n\tstruct clk\t\t\t*bus_clk;\n\tstruct clk\t\t\t*lcd_clk;\n\tvoid __iomem\t\t\t*regs;\n\tstruct regmap\t\t\t*sysreg;\n\tunsigned long\t\t\tirq_flags;\n\tu32\t\t\t\tvidcon0;\n\tu32\t\t\t\tvidcon1;\n\tu32\t\t\t\tvidout_con;\n\tu32\t\t\t\ti80ifcon;\n\tbool\t\t\t\ti80_if;\n\tbool\t\t\t\tsuspended;\n\twait_queue_head_t\t\twait_vsync_queue;\n\tatomic_t\t\t\twait_vsync_event;\n\tatomic_t\t\t\twin_updated;\n\tatomic_t\t\t\ttriggering;\n\tu32\t\t\t\tclkdiv;\n\n\tconst struct fimd_driver_data *driver_data;\n\tstruct drm_encoder *encoder;\n\tstruct exynos_drm_clk\t\tdp_clk;\n};\n\nstatic const struct of_device_id fimd_driver_dt_match[] = {\n\t{ .compatible = \"samsung,s3c6400-fimd\",\n\t  .data = &s3c64xx_fimd_driver_data },\n\t{ .compatible = \"samsung,s5pv210-fimd\",\n\t  .data = &s5pv210_fimd_driver_data },\n\t{ .compatible = \"samsung,exynos3250-fimd\",\n\t  .data = &exynos3_fimd_driver_data },\n\t{ .compatible = \"samsung,exynos4210-fimd\",\n\t  .data = &exynos4_fimd_driver_data },\n\t{ .compatible = \"samsung,exynos5250-fimd\",\n\t  .data = &exynos5_fimd_driver_data },\n\t{ .compatible = \"samsung,exynos5420-fimd\",\n\t  .data = &exynos5420_fimd_driver_data },\n\t{},\n};\nMODULE_DEVICE_TABLE(of, fimd_driver_dt_match);\n\nstatic const enum drm_plane_type fimd_win_types[WINDOWS_NR] = {\n\tDRM_PLANE_TYPE_PRIMARY,\n\tDRM_PLANE_TYPE_OVERLAY,\n\tDRM_PLANE_TYPE_OVERLAY,\n\tDRM_PLANE_TYPE_OVERLAY,\n\tDRM_PLANE_TYPE_CURSOR,\n};\n\nstatic const uint32_t fimd_formats[] = {\n\tDRM_FORMAT_C8,\n\tDRM_FORMAT_XRGB1555,\n\tDRM_FORMAT_RGB565,\n\tDRM_FORMAT_XRGB8888,\n\tDRM_FORMAT_ARGB8888,\n};\n\nstatic const uint32_t fimd_extended_formats[] = {\n\tDRM_FORMAT_C8,\n\tDRM_FORMAT_XRGB1555,\n\tDRM_FORMAT_XBGR1555,\n\tDRM_FORMAT_RGB565,\n\tDRM_FORMAT_BGR565,\n\tDRM_FORMAT_XRGB8888,\n\tDRM_FORMAT_XBGR8888,\n\tDRM_FORMAT_ARGB8888,\n\tDRM_FORMAT_ABGR8888,\n};\n\nstatic const unsigned int capabilities[WINDOWS_NR] = {\n\t0,\n\tEXYNOS_DRM_PLANE_CAP_WIN_BLEND | EXYNOS_DRM_PLANE_CAP_PIX_BLEND,\n\tEXYNOS_DRM_PLANE_CAP_WIN_BLEND | EXYNOS_DRM_PLANE_CAP_PIX_BLEND,\n\tEXYNOS_DRM_PLANE_CAP_WIN_BLEND | EXYNOS_DRM_PLANE_CAP_PIX_BLEND,\n\tEXYNOS_DRM_PLANE_CAP_WIN_BLEND | EXYNOS_DRM_PLANE_CAP_PIX_BLEND,\n};\n\nstatic inline void fimd_set_bits(struct fimd_context *ctx, u32 reg, u32 mask,\n\t\t\t\t u32 val)\n{\n\tval = (val & mask) | (readl(ctx->regs + reg) & ~mask);\n\twritel(val, ctx->regs + reg);\n}\n\nstatic int fimd_enable_vblank(struct exynos_drm_crtc *crtc)\n{\n\tstruct fimd_context *ctx = crtc->ctx;\n\tu32 val;\n\n\tif (ctx->suspended)\n\t\treturn -EPERM;\n\n\tif (!test_and_set_bit(0, &ctx->irq_flags)) {\n\t\tval = readl(ctx->regs + VIDINTCON0);\n\n\t\tval |= VIDINTCON0_INT_ENABLE;\n\n\t\tif (ctx->i80_if) {\n\t\t\tval |= VIDINTCON0_INT_I80IFDONE;\n\t\t\tval |= VIDINTCON0_INT_SYSMAINCON;\n\t\t\tval &= ~VIDINTCON0_INT_SYSSUBCON;\n\t\t} else {\n\t\t\tval |= VIDINTCON0_INT_FRAME;\n\n\t\t\tval &= ~VIDINTCON0_FRAMESEL0_MASK;\n\t\t\tval |= VIDINTCON0_FRAMESEL0_FRONTPORCH;\n\t\t\tval &= ~VIDINTCON0_FRAMESEL1_MASK;\n\t\t\tval |= VIDINTCON0_FRAMESEL1_NONE;\n\t\t}\n\n\t\twritel(val, ctx->regs + VIDINTCON0);\n\t}\n\n\treturn 0;\n}\n\nstatic void fimd_disable_vblank(struct exynos_drm_crtc *crtc)\n{\n\tstruct fimd_context *ctx = crtc->ctx;\n\tu32 val;\n\n\tif (ctx->suspended)\n\t\treturn;\n\n\tif (test_and_clear_bit(0, &ctx->irq_flags)) {\n\t\tval = readl(ctx->regs + VIDINTCON0);\n\n\t\tval &= ~VIDINTCON0_INT_ENABLE;\n\n\t\tif (ctx->i80_if) {\n\t\t\tval &= ~VIDINTCON0_INT_I80IFDONE;\n\t\t\tval &= ~VIDINTCON0_INT_SYSMAINCON;\n\t\t\tval &= ~VIDINTCON0_INT_SYSSUBCON;\n\t\t} else\n\t\t\tval &= ~VIDINTCON0_INT_FRAME;\n\n\t\twritel(val, ctx->regs + VIDINTCON0);\n\t}\n}\n\nstatic void fimd_wait_for_vblank(struct exynos_drm_crtc *crtc)\n{\n\tstruct fimd_context *ctx = crtc->ctx;\n\n\tif (ctx->suspended)\n\t\treturn;\n\n\tatomic_set(&ctx->wait_vsync_event, 1);\n\n\t \n\tif (!wait_event_timeout(ctx->wait_vsync_queue,\n\t\t\t\t!atomic_read(&ctx->wait_vsync_event),\n\t\t\t\tHZ/20))\n\t\tDRM_DEV_DEBUG_KMS(ctx->dev, \"vblank wait timed out.\\n\");\n}\n\nstatic void fimd_enable_video_output(struct fimd_context *ctx, unsigned int win,\n\t\t\t\t\tbool enable)\n{\n\tu32 val = readl(ctx->regs + WINCON(win));\n\n\tif (enable)\n\t\tval |= WINCONx_ENWIN;\n\telse\n\t\tval &= ~WINCONx_ENWIN;\n\n\twritel(val, ctx->regs + WINCON(win));\n}\n\nstatic void fimd_enable_shadow_channel_path(struct fimd_context *ctx,\n\t\t\t\t\t\tunsigned int win,\n\t\t\t\t\t\tbool enable)\n{\n\tu32 val = readl(ctx->regs + SHADOWCON);\n\n\tif (enable)\n\t\tval |= SHADOWCON_CHx_ENABLE(win);\n\telse\n\t\tval &= ~SHADOWCON_CHx_ENABLE(win);\n\n\twritel(val, ctx->regs + SHADOWCON);\n}\n\nstatic int fimd_clear_channels(struct exynos_drm_crtc *crtc)\n{\n\tstruct fimd_context *ctx = crtc->ctx;\n\tunsigned int win, ch_enabled = 0;\n\tint ret;\n\n\t \n\tret = pm_runtime_resume_and_get(ctx->dev);\n\tif (ret < 0) {\n\t\tdev_err(ctx->dev, \"failed to enable FIMD device.\\n\");\n\t\treturn ret;\n\t}\n\n\tclk_prepare_enable(ctx->bus_clk);\n\tclk_prepare_enable(ctx->lcd_clk);\n\n\t \n\tfor (win = 0; win < WINDOWS_NR; win++) {\n\t\tu32 val = readl(ctx->regs + WINCON(win));\n\n\t\tif (val & WINCONx_ENWIN) {\n\t\t\tfimd_enable_video_output(ctx, win, false);\n\n\t\t\tif (ctx->driver_data->has_shadowcon)\n\t\t\t\tfimd_enable_shadow_channel_path(ctx, win,\n\t\t\t\t\t\t\t\tfalse);\n\n\t\t\tch_enabled = 1;\n\t\t}\n\t}\n\n\t \n\tif (ch_enabled) {\n\t\tctx->suspended = false;\n\n\t\tfimd_enable_vblank(ctx->crtc);\n\t\tfimd_wait_for_vblank(ctx->crtc);\n\t\tfimd_disable_vblank(ctx->crtc);\n\n\t\tctx->suspended = true;\n\t}\n\n\tclk_disable_unprepare(ctx->lcd_clk);\n\tclk_disable_unprepare(ctx->bus_clk);\n\n\tpm_runtime_put(ctx->dev);\n\n\treturn 0;\n}\n\n\nstatic int fimd_atomic_check(struct exynos_drm_crtc *crtc,\n\t\tstruct drm_crtc_state *state)\n{\n\tstruct drm_display_mode *mode = &state->adjusted_mode;\n\tstruct fimd_context *ctx = crtc->ctx;\n\tunsigned long ideal_clk, lcd_rate;\n\tu32 clkdiv;\n\n\tif (mode->clock == 0) {\n\t\tDRM_DEV_ERROR(ctx->dev, \"Mode has zero clock value.\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tideal_clk = mode->clock * 1000;\n\n\tif (ctx->i80_if) {\n\t\t \n\t\tideal_clk *= 2;\n\t}\n\n\tlcd_rate = clk_get_rate(ctx->lcd_clk);\n\tif (2 * lcd_rate < ideal_clk) {\n\t\tDRM_DEV_ERROR(ctx->dev,\n\t\t\t      \"sclk_fimd clock too low(%lu) for requested pixel clock(%lu)\\n\",\n\t\t\t      lcd_rate, ideal_clk);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tclkdiv = DIV_ROUND_CLOSEST(lcd_rate, ideal_clk);\n\tif (clkdiv >= 0x200) {\n\t\tDRM_DEV_ERROR(ctx->dev, \"requested pixel clock(%lu) too low\\n\",\n\t\t\t      ideal_clk);\n\t\treturn -EINVAL;\n\t}\n\n\tctx->clkdiv = (clkdiv < 0x100) ? clkdiv : 0xff;\n\n\treturn 0;\n}\n\nstatic void fimd_setup_trigger(struct fimd_context *ctx)\n{\n\tvoid __iomem *timing_base = ctx->regs + ctx->driver_data->timing_base;\n\tu32 trg_type = ctx->driver_data->trg_type;\n\tu32 val = readl(timing_base + TRIGCON);\n\n\tval &= ~(TRGMODE_ENABLE);\n\n\tif (trg_type == I80_HW_TRG) {\n\t\tif (ctx->driver_data->has_hw_trigger)\n\t\t\tval |= HWTRGEN_ENABLE | HWTRGMASK_ENABLE;\n\t\tif (ctx->driver_data->has_trigger_per_te)\n\t\t\tval |= HWTRIGEN_PER_ENABLE;\n\t} else {\n\t\tval |= TRGMODE_ENABLE;\n\t}\n\n\twritel(val, timing_base + TRIGCON);\n}\n\nstatic void fimd_commit(struct exynos_drm_crtc *crtc)\n{\n\tstruct fimd_context *ctx = crtc->ctx;\n\tstruct drm_display_mode *mode = &crtc->base.state->adjusted_mode;\n\tconst struct fimd_driver_data *driver_data = ctx->driver_data;\n\tvoid *timing_base = ctx->regs + driver_data->timing_base;\n\tu32 val;\n\n\tif (ctx->suspended)\n\t\treturn;\n\n\t \n\tif (mode->htotal == 0 || mode->vtotal == 0)\n\t\treturn;\n\n\tif (ctx->i80_if) {\n\t\tval = ctx->i80ifcon | I80IFEN_ENABLE;\n\t\twritel(val, timing_base + I80IFCONFAx(0));\n\n\t\t \n\t\twritel(0, timing_base + I80IFCONFBx(0));\n\n\t\t \n\t\tif (driver_data->has_vtsel && ctx->sysreg &&\n\t\t\t\tregmap_update_bits(ctx->sysreg,\n\t\t\t\t\tdriver_data->lcdblk_offset,\n\t\t\t\t\t0x3 << driver_data->lcdblk_vt_shift,\n\t\t\t\t\t0x1 << driver_data->lcdblk_vt_shift)) {\n\t\t\tDRM_DEV_ERROR(ctx->dev,\n\t\t\t\t      \"Failed to update sysreg for I80 i/f.\\n\");\n\t\t\treturn;\n\t\t}\n\t} else {\n\t\tint vsync_len, vbpd, vfpd, hsync_len, hbpd, hfpd;\n\t\tu32 vidcon1;\n\n\t\t \n\t\tvidcon1 = ctx->vidcon1;\n\t\tif (mode->flags & DRM_MODE_FLAG_NVSYNC)\n\t\t\tvidcon1 |= VIDCON1_INV_VSYNC;\n\t\tif (mode->flags & DRM_MODE_FLAG_NHSYNC)\n\t\t\tvidcon1 |= VIDCON1_INV_HSYNC;\n\t\twritel(vidcon1, ctx->regs + driver_data->timing_base + VIDCON1);\n\n\t\t \n\t\tvsync_len = mode->crtc_vsync_end - mode->crtc_vsync_start;\n\t\tvbpd = mode->crtc_vtotal - mode->crtc_vsync_end;\n\t\tvfpd = mode->crtc_vsync_start - mode->crtc_vdisplay;\n\n\t\tval = VIDTCON0_VBPD(vbpd - 1) |\n\t\t\tVIDTCON0_VFPD(vfpd - 1) |\n\t\t\tVIDTCON0_VSPW(vsync_len - 1);\n\t\twritel(val, ctx->regs + driver_data->timing_base + VIDTCON0);\n\n\t\t \n\t\thsync_len = mode->crtc_hsync_end - mode->crtc_hsync_start;\n\t\thbpd = mode->crtc_htotal - mode->crtc_hsync_end;\n\t\thfpd = mode->crtc_hsync_start - mode->crtc_hdisplay;\n\n\t\tval = VIDTCON1_HBPD(hbpd - 1) |\n\t\t\tVIDTCON1_HFPD(hfpd - 1) |\n\t\t\tVIDTCON1_HSPW(hsync_len - 1);\n\t\twritel(val, ctx->regs + driver_data->timing_base + VIDTCON1);\n\t}\n\n\tif (driver_data->has_vidoutcon)\n\t\twritel(ctx->vidout_con, timing_base + VIDOUT_CON);\n\n\t \n\tif (ctx->sysreg && regmap_update_bits(ctx->sysreg,\n\t\t\t\tdriver_data->lcdblk_offset,\n\t\t\t\t0x1 << driver_data->lcdblk_bypass_shift,\n\t\t\t\t0x1 << driver_data->lcdblk_bypass_shift)) {\n\t\tDRM_DEV_ERROR(ctx->dev,\n\t\t\t      \"Failed to update sysreg for bypass setting.\\n\");\n\t\treturn;\n\t}\n\n\t \n\tif (driver_data->has_mic_bypass && ctx->sysreg &&\n\t    regmap_update_bits(ctx->sysreg,\n\t\t\t\tdriver_data->lcdblk_offset,\n\t\t\t\t0x1 << driver_data->lcdblk_mic_bypass_shift,\n\t\t\t\t0x1 << driver_data->lcdblk_mic_bypass_shift)) {\n\t\tDRM_DEV_ERROR(ctx->dev,\n\t\t\t      \"Failed to update sysreg for bypass mic.\\n\");\n\t\treturn;\n\t}\n\n\t \n\tval = VIDTCON2_LINEVAL(mode->vdisplay - 1) |\n\t       VIDTCON2_HOZVAL(mode->hdisplay - 1) |\n\t       VIDTCON2_LINEVAL_E(mode->vdisplay - 1) |\n\t       VIDTCON2_HOZVAL_E(mode->hdisplay - 1);\n\twritel(val, ctx->regs + driver_data->timing_base + VIDTCON2);\n\n\tfimd_setup_trigger(ctx);\n\n\t \n\tval = ctx->vidcon0;\n\tval |= VIDCON0_ENVID | VIDCON0_ENVID_F;\n\n\tif (ctx->driver_data->has_clksel)\n\t\tval |= VIDCON0_CLKSEL_LCD;\n\n\tif (ctx->clkdiv > 1)\n\t\tval |= VIDCON0_CLKVAL_F(ctx->clkdiv - 1) | VIDCON0_CLKDIR;\n\n\twritel(val, ctx->regs + VIDCON0);\n}\n\nstatic void fimd_win_set_bldeq(struct fimd_context *ctx, unsigned int win,\n\t\t\t       unsigned int alpha, unsigned int pixel_alpha)\n{\n\tu32 mask = BLENDEQ_A_FUNC_F(0xf) | BLENDEQ_B_FUNC_F(0xf);\n\tu32 val = 0;\n\n\tswitch (pixel_alpha) {\n\tcase DRM_MODE_BLEND_PIXEL_NONE:\n\tcase DRM_MODE_BLEND_COVERAGE:\n\t\tval |= BLENDEQ_A_FUNC_F(BLENDEQ_ALPHA_A);\n\t\tval |= BLENDEQ_B_FUNC_F(BLENDEQ_ONE_MINUS_ALPHA_A);\n\t\tbreak;\n\tcase DRM_MODE_BLEND_PREMULTI:\n\tdefault:\n\t\tif (alpha != DRM_BLEND_ALPHA_OPAQUE) {\n\t\t\tval |= BLENDEQ_A_FUNC_F(BLENDEQ_ALPHA0);\n\t\t\tval |= BLENDEQ_B_FUNC_F(BLENDEQ_ONE_MINUS_ALPHA_A);\n\t\t} else {\n\t\t\tval |= BLENDEQ_A_FUNC_F(BLENDEQ_ONE);\n\t\t\tval |= BLENDEQ_B_FUNC_F(BLENDEQ_ONE_MINUS_ALPHA_A);\n\t\t}\n\t\tbreak;\n\t}\n\tfimd_set_bits(ctx, BLENDEQx(win), mask, val);\n}\n\nstatic void fimd_win_set_bldmod(struct fimd_context *ctx, unsigned int win,\n\t\t\t\tunsigned int alpha, unsigned int pixel_alpha)\n{\n\tu32 win_alpha_l = (alpha >> 8) & 0xf;\n\tu32 win_alpha_h = alpha >> 12;\n\tu32 val = 0;\n\n\tswitch (pixel_alpha) {\n\tcase DRM_MODE_BLEND_PIXEL_NONE:\n\t\tbreak;\n\tcase DRM_MODE_BLEND_COVERAGE:\n\tcase DRM_MODE_BLEND_PREMULTI:\n\tdefault:\n\t\tval |= WINCON1_ALPHA_SEL;\n\t\tval |= WINCON1_BLD_PIX;\n\t\tval |= WINCON1_ALPHA_MUL;\n\t\tbreak;\n\t}\n\tfimd_set_bits(ctx, WINCON(win), WINCONx_BLEND_MODE_MASK, val);\n\n\t \n\tval = VIDISD14C_ALPHA0_R(win_alpha_h) |\n\t\tVIDISD14C_ALPHA0_G(win_alpha_h) |\n\t\tVIDISD14C_ALPHA0_B(win_alpha_h) |\n\t\tVIDISD14C_ALPHA1_R(0x0) |\n\t\tVIDISD14C_ALPHA1_G(0x0) |\n\t\tVIDISD14C_ALPHA1_B(0x0);\n\twritel(val, ctx->regs + VIDOSD_C(win));\n\n\tval = VIDW_ALPHA_R(win_alpha_l) | VIDW_ALPHA_G(win_alpha_l) |\n\t\tVIDW_ALPHA_B(win_alpha_l);\n\twritel(val, ctx->regs + VIDWnALPHA0(win));\n\n\tval = VIDW_ALPHA_R(0x0) | VIDW_ALPHA_G(0x0) |\n\t\tVIDW_ALPHA_B(0x0);\n\twritel(val, ctx->regs + VIDWnALPHA1(win));\n\n\tfimd_set_bits(ctx, BLENDCON, BLENDCON_NEW_MASK,\n\t\t\tBLENDCON_NEW_8BIT_ALPHA_VALUE);\n}\n\nstatic void fimd_win_set_pixfmt(struct fimd_context *ctx, unsigned int win,\n\t\t\t\tstruct drm_framebuffer *fb, int width)\n{\n\tstruct exynos_drm_plane plane = ctx->planes[win];\n\tstruct exynos_drm_plane_state *state =\n\t\tto_exynos_plane_state(plane.base.state);\n\tuint32_t pixel_format = fb->format->format;\n\tunsigned int alpha = state->base.alpha;\n\tu32 val = WINCONx_ENWIN;\n\tunsigned int pixel_alpha;\n\n\tif (fb->format->has_alpha)\n\t\tpixel_alpha = state->base.pixel_blend_mode;\n\telse\n\t\tpixel_alpha = DRM_MODE_BLEND_PIXEL_NONE;\n\n\t \n\tif (ctx->driver_data->has_limited_fmt && !win) {\n\t\tif (pixel_format == DRM_FORMAT_ARGB8888)\n\t\t\tpixel_format = DRM_FORMAT_XRGB8888;\n\t}\n\n\tswitch (pixel_format) {\n\tcase DRM_FORMAT_C8:\n\t\tval |= WINCON0_BPPMODE_8BPP_PALETTE;\n\t\tval |= WINCONx_BURSTLEN_8WORD;\n\t\tval |= WINCONx_BYTSWP;\n\t\tbreak;\n\tcase DRM_FORMAT_XRGB1555:\n\tcase DRM_FORMAT_XBGR1555:\n\t\tval |= WINCON0_BPPMODE_16BPP_1555;\n\t\tval |= WINCONx_HAWSWP;\n\t\tval |= WINCONx_BURSTLEN_16WORD;\n\t\tbreak;\n\tcase DRM_FORMAT_RGB565:\n\tcase DRM_FORMAT_BGR565:\n\t\tval |= WINCON0_BPPMODE_16BPP_565;\n\t\tval |= WINCONx_HAWSWP;\n\t\tval |= WINCONx_BURSTLEN_16WORD;\n\t\tbreak;\n\tcase DRM_FORMAT_XRGB8888:\n\tcase DRM_FORMAT_XBGR8888:\n\t\tval |= WINCON0_BPPMODE_24BPP_888;\n\t\tval |= WINCONx_WSWP;\n\t\tval |= WINCONx_BURSTLEN_16WORD;\n\t\tbreak;\n\tcase DRM_FORMAT_ARGB8888:\n\tcase DRM_FORMAT_ABGR8888:\n\tdefault:\n\t\tval |= WINCON1_BPPMODE_25BPP_A1888;\n\t\tval |= WINCONx_WSWP;\n\t\tval |= WINCONx_BURSTLEN_16WORD;\n\t\tbreak;\n\t}\n\n\tswitch (pixel_format) {\n\tcase DRM_FORMAT_XBGR1555:\n\tcase DRM_FORMAT_XBGR8888:\n\tcase DRM_FORMAT_ABGR8888:\n\tcase DRM_FORMAT_BGR565:\n\t\twritel(WIN_RGB_ORDER_REVERSE, ctx->regs + WIN_RGB_ORDER(win));\n\t\tbreak;\n\tdefault:\n\t\twritel(WIN_RGB_ORDER_FORWARD, ctx->regs + WIN_RGB_ORDER(win));\n\t\tbreak;\n\t}\n\n\t \n\n\tif (width < MIN_FB_WIDTH_FOR_16WORD_BURST) {\n\t\tval &= ~WINCONx_BURSTLEN_MASK;\n\t\tval |= WINCONx_BURSTLEN_4WORD;\n\t}\n\tfimd_set_bits(ctx, WINCON(win), ~WINCONx_BLEND_MODE_MASK, val);\n\n\t \n\tif (win != 0) {\n\t\tfimd_win_set_bldmod(ctx, win, alpha, pixel_alpha);\n\t\tfimd_win_set_bldeq(ctx, win, alpha, pixel_alpha);\n\t}\n}\n\nstatic void fimd_win_set_colkey(struct fimd_context *ctx, unsigned int win)\n{\n\tunsigned int keycon0 = 0, keycon1 = 0;\n\n\tkeycon0 = ~(WxKEYCON0_KEYBL_EN | WxKEYCON0_KEYEN_F |\n\t\t\tWxKEYCON0_DIRCON) | WxKEYCON0_COMPKEY(0);\n\n\tkeycon1 = WxKEYCON1_COLVAL(0xffffffff);\n\n\twritel(keycon0, ctx->regs + WKEYCON0_BASE(win));\n\twritel(keycon1, ctx->regs + WKEYCON1_BASE(win));\n}\n\n \nstatic void fimd_shadow_protect_win(struct fimd_context *ctx,\n\t\t\t\t    unsigned int win, bool protect)\n{\n\tu32 reg, bits, val;\n\n\t \n\n\tif (ctx->driver_data->has_shadowcon) {\n\t\treg = SHADOWCON;\n\t\tbits = SHADOWCON_WINx_PROTECT(win);\n\t} else {\n\t\treg = PRTCON;\n\t\tbits = PRTCON_PROTECT;\n\t}\n\n\tval = readl(ctx->regs + reg);\n\tif (protect)\n\t\tval |= bits;\n\telse\n\t\tval &= ~bits;\n\twritel(val, ctx->regs + reg);\n}\n\nstatic void fimd_atomic_begin(struct exynos_drm_crtc *crtc)\n{\n\tstruct fimd_context *ctx = crtc->ctx;\n\tint i;\n\n\tif (ctx->suspended)\n\t\treturn;\n\n\tfor (i = 0; i < WINDOWS_NR; i++)\n\t\tfimd_shadow_protect_win(ctx, i, true);\n}\n\nstatic void fimd_atomic_flush(struct exynos_drm_crtc *crtc)\n{\n\tstruct fimd_context *ctx = crtc->ctx;\n\tint i;\n\n\tif (ctx->suspended)\n\t\treturn;\n\n\tfor (i = 0; i < WINDOWS_NR; i++)\n\t\tfimd_shadow_protect_win(ctx, i, false);\n\n\texynos_crtc_handle_event(crtc);\n}\n\nstatic void fimd_update_plane(struct exynos_drm_crtc *crtc,\n\t\t\t      struct exynos_drm_plane *plane)\n{\n\tstruct exynos_drm_plane_state *state =\n\t\t\t\tto_exynos_plane_state(plane->base.state);\n\tstruct fimd_context *ctx = crtc->ctx;\n\tstruct drm_framebuffer *fb = state->base.fb;\n\tdma_addr_t dma_addr;\n\tunsigned long val, size, offset;\n\tunsigned int last_x, last_y, buf_offsize, line_size;\n\tunsigned int win = plane->index;\n\tunsigned int cpp = fb->format->cpp[0];\n\tunsigned int pitch = fb->pitches[0];\n\n\tif (ctx->suspended)\n\t\treturn;\n\n\toffset = state->src.x * cpp;\n\toffset += state->src.y * pitch;\n\n\t \n\tdma_addr = exynos_drm_fb_dma_addr(fb, 0) + offset;\n\tval = (unsigned long)dma_addr;\n\twritel(val, ctx->regs + VIDWx_BUF_START(win, 0));\n\n\t \n\tsize = pitch * state->crtc.h;\n\tval = (unsigned long)(dma_addr + size);\n\twritel(val, ctx->regs + VIDWx_BUF_END(win, 0));\n\n\tDRM_DEV_DEBUG_KMS(ctx->dev,\n\t\t\t  \"start addr = 0x%lx, end addr = 0x%lx, size = 0x%lx\\n\",\n\t\t\t  (unsigned long)dma_addr, val, size);\n\tDRM_DEV_DEBUG_KMS(ctx->dev, \"ovl_width = %d, ovl_height = %d\\n\",\n\t\t\t  state->crtc.w, state->crtc.h);\n\n\t \n\tbuf_offsize = pitch - (state->crtc.w * cpp);\n\tline_size = state->crtc.w * cpp;\n\tval = VIDW_BUF_SIZE_OFFSET(buf_offsize) |\n\t\tVIDW_BUF_SIZE_PAGEWIDTH(line_size) |\n\t\tVIDW_BUF_SIZE_OFFSET_E(buf_offsize) |\n\t\tVIDW_BUF_SIZE_PAGEWIDTH_E(line_size);\n\twritel(val, ctx->regs + VIDWx_BUF_SIZE(win, 0));\n\n\t \n\tval = VIDOSDxA_TOPLEFT_X(state->crtc.x) |\n\t\tVIDOSDxA_TOPLEFT_Y(state->crtc.y) |\n\t\tVIDOSDxA_TOPLEFT_X_E(state->crtc.x) |\n\t\tVIDOSDxA_TOPLEFT_Y_E(state->crtc.y);\n\twritel(val, ctx->regs + VIDOSD_A(win));\n\n\tlast_x = state->crtc.x + state->crtc.w;\n\tif (last_x)\n\t\tlast_x--;\n\tlast_y = state->crtc.y + state->crtc.h;\n\tif (last_y)\n\t\tlast_y--;\n\n\tval = VIDOSDxB_BOTRIGHT_X(last_x) | VIDOSDxB_BOTRIGHT_Y(last_y) |\n\t\tVIDOSDxB_BOTRIGHT_X_E(last_x) | VIDOSDxB_BOTRIGHT_Y_E(last_y);\n\n\twritel(val, ctx->regs + VIDOSD_B(win));\n\n\tDRM_DEV_DEBUG_KMS(ctx->dev,\n\t\t\t  \"osd pos: tx = %d, ty = %d, bx = %d, by = %d\\n\",\n\t\t\t  state->crtc.x, state->crtc.y, last_x, last_y);\n\n\t \n\tif (win != 3 && win != 4) {\n\t\tu32 offset = VIDOSD_D(win);\n\t\tif (win == 0)\n\t\t\toffset = VIDOSD_C(win);\n\t\tval = state->crtc.w * state->crtc.h;\n\t\twritel(val, ctx->regs + offset);\n\n\t\tDRM_DEV_DEBUG_KMS(ctx->dev, \"osd size = 0x%x\\n\",\n\t\t\t\t  (unsigned int)val);\n\t}\n\n\tfimd_win_set_pixfmt(ctx, win, fb, state->src.w);\n\n\t \n\tif (win != 0)\n\t\tfimd_win_set_colkey(ctx, win);\n\n\tfimd_enable_video_output(ctx, win, true);\n\n\tif (ctx->driver_data->has_shadowcon)\n\t\tfimd_enable_shadow_channel_path(ctx, win, true);\n\n\tif (ctx->i80_if)\n\t\tatomic_set(&ctx->win_updated, 1);\n}\n\nstatic void fimd_disable_plane(struct exynos_drm_crtc *crtc,\n\t\t\t       struct exynos_drm_plane *plane)\n{\n\tstruct fimd_context *ctx = crtc->ctx;\n\tunsigned int win = plane->index;\n\n\tif (ctx->suspended)\n\t\treturn;\n\n\tfimd_enable_video_output(ctx, win, false);\n\n\tif (ctx->driver_data->has_shadowcon)\n\t\tfimd_enable_shadow_channel_path(ctx, win, false);\n}\n\nstatic void fimd_atomic_enable(struct exynos_drm_crtc *crtc)\n{\n\tstruct fimd_context *ctx = crtc->ctx;\n\n\tif (!ctx->suspended)\n\t\treturn;\n\n\tctx->suspended = false;\n\n\tif (pm_runtime_resume_and_get(ctx->dev) < 0) {\n\t\tdev_warn(ctx->dev, \"failed to enable FIMD device.\\n\");\n\t\treturn;\n\t}\n\n\t \n\tif (test_and_clear_bit(0, &ctx->irq_flags))\n\t\tfimd_enable_vblank(ctx->crtc);\n\n\tfimd_commit(ctx->crtc);\n}\n\nstatic void fimd_atomic_disable(struct exynos_drm_crtc *crtc)\n{\n\tstruct fimd_context *ctx = crtc->ctx;\n\tint i;\n\n\tif (ctx->suspended)\n\t\treturn;\n\n\t \n\tfor (i = 0; i < WINDOWS_NR; i++)\n\t\tfimd_disable_plane(crtc, &ctx->planes[i]);\n\n\tfimd_enable_vblank(crtc);\n\tfimd_wait_for_vblank(crtc);\n\tfimd_disable_vblank(crtc);\n\n\twritel(0, ctx->regs + VIDCON0);\n\n\tpm_runtime_put_sync(ctx->dev);\n\tctx->suspended = true;\n}\n\nstatic void fimd_trigger(struct device *dev)\n{\n\tstruct fimd_context *ctx = dev_get_drvdata(dev);\n\tconst struct fimd_driver_data *driver_data = ctx->driver_data;\n\tvoid *timing_base = ctx->regs + driver_data->timing_base;\n\tu32 reg;\n\n\t  \n\tif (atomic_read(&ctx->triggering))\n\t\treturn;\n\n\t \n\tatomic_set(&ctx->triggering, 1);\n\n\treg = readl(timing_base + TRIGCON);\n\treg |= (TRGMODE_ENABLE | SWTRGCMD_ENABLE);\n\twritel(reg, timing_base + TRIGCON);\n\n\t \n\tif (!test_bit(0, &ctx->irq_flags))\n\t\tatomic_set(&ctx->triggering, 0);\n}\n\nstatic void fimd_te_handler(struct exynos_drm_crtc *crtc)\n{\n\tstruct fimd_context *ctx = crtc->ctx;\n\tu32 trg_type = ctx->driver_data->trg_type;\n\n\t \n\tif (!ctx->drm_dev)\n\t\treturn;\n\n\tif (trg_type == I80_HW_TRG)\n\t\tgoto out;\n\n\t \n\tif (atomic_add_unless(&ctx->win_updated, -1, 0))\n\t\tfimd_trigger(ctx->dev);\n\nout:\n\t \n\tif (atomic_read(&ctx->wait_vsync_event)) {\n\t\tatomic_set(&ctx->wait_vsync_event, 0);\n\t\twake_up(&ctx->wait_vsync_queue);\n\t}\n\n\tif (test_bit(0, &ctx->irq_flags))\n\t\tdrm_crtc_handle_vblank(&ctx->crtc->base);\n}\n\nstatic void fimd_dp_clock_enable(struct exynos_drm_clk *clk, bool enable)\n{\n\tstruct fimd_context *ctx = container_of(clk, struct fimd_context,\n\t\t\t\t\t\tdp_clk);\n\tu32 val = enable ? DP_MIE_CLK_DP_ENABLE : DP_MIE_CLK_DISABLE;\n\twritel(val, ctx->regs + DP_MIE_CLKCON);\n}\n\nstatic const struct exynos_drm_crtc_ops fimd_crtc_ops = {\n\t.atomic_enable = fimd_atomic_enable,\n\t.atomic_disable = fimd_atomic_disable,\n\t.enable_vblank = fimd_enable_vblank,\n\t.disable_vblank = fimd_disable_vblank,\n\t.atomic_begin = fimd_atomic_begin,\n\t.update_plane = fimd_update_plane,\n\t.disable_plane = fimd_disable_plane,\n\t.atomic_flush = fimd_atomic_flush,\n\t.atomic_check = fimd_atomic_check,\n\t.te_handler = fimd_te_handler,\n};\n\nstatic irqreturn_t fimd_irq_handler(int irq, void *dev_id)\n{\n\tstruct fimd_context *ctx = (struct fimd_context *)dev_id;\n\tu32 val, clear_bit;\n\n\tval = readl(ctx->regs + VIDINTCON1);\n\n\tclear_bit = ctx->i80_if ? VIDINTCON1_INT_I80 : VIDINTCON1_INT_FRAME;\n\tif (val & clear_bit)\n\t\twritel(clear_bit, ctx->regs + VIDINTCON1);\n\n\t \n\tif (!ctx->drm_dev)\n\t\tgoto out;\n\n\tif (!ctx->i80_if)\n\t\tdrm_crtc_handle_vblank(&ctx->crtc->base);\n\n\tif (ctx->i80_if) {\n\t\t \n\t\tatomic_set(&ctx->triggering, 0);\n\t} else {\n\t\t \n\t\tif (atomic_read(&ctx->wait_vsync_event)) {\n\t\t\tatomic_set(&ctx->wait_vsync_event, 0);\n\t\t\twake_up(&ctx->wait_vsync_queue);\n\t\t}\n\t}\n\nout:\n\treturn IRQ_HANDLED;\n}\n\nstatic int fimd_bind(struct device *dev, struct device *master, void *data)\n{\n\tstruct fimd_context *ctx = dev_get_drvdata(dev);\n\tstruct drm_device *drm_dev = data;\n\tstruct exynos_drm_plane *exynos_plane;\n\tunsigned int i;\n\tint ret;\n\n\tctx->drm_dev = drm_dev;\n\n\tfor (i = 0; i < WINDOWS_NR; i++) {\n\t\tif (ctx->driver_data->has_bgr_support) {\n\t\t\tctx->configs[i].pixel_formats = fimd_extended_formats;\n\t\t\tctx->configs[i].num_pixel_formats = ARRAY_SIZE(fimd_extended_formats);\n\t\t} else {\n\t\t\tctx->configs[i].pixel_formats = fimd_formats;\n\t\t\tctx->configs[i].num_pixel_formats = ARRAY_SIZE(fimd_formats);\n\t\t}\n\n\t\tctx->configs[i].zpos = i;\n\t\tctx->configs[i].type = fimd_win_types[i];\n\t\tctx->configs[i].capabilities = capabilities[i];\n\t\tret = exynos_plane_init(drm_dev, &ctx->planes[i], i,\n\t\t\t\t\t&ctx->configs[i]);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\texynos_plane = &ctx->planes[DEFAULT_WIN];\n\tctx->crtc = exynos_drm_crtc_create(drm_dev, &exynos_plane->base,\n\t\t\tEXYNOS_DISPLAY_TYPE_LCD, &fimd_crtc_ops, ctx);\n\tif (IS_ERR(ctx->crtc))\n\t\treturn PTR_ERR(ctx->crtc);\n\n\tif (ctx->driver_data->has_dp_clk) {\n\t\tctx->dp_clk.enable = fimd_dp_clock_enable;\n\t\tctx->crtc->pipe_clk = &ctx->dp_clk;\n\t}\n\n\tif (ctx->encoder)\n\t\texynos_dpi_bind(drm_dev, ctx->encoder);\n\n\tif (is_drm_iommu_supported(drm_dev)) {\n\t\tint ret;\n\n\t\tret = fimd_clear_channels(ctx->crtc);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\treturn exynos_drm_register_dma(drm_dev, dev, &ctx->dma_priv);\n}\n\nstatic void fimd_unbind(struct device *dev, struct device *master,\n\t\t\tvoid *data)\n{\n\tstruct fimd_context *ctx = dev_get_drvdata(dev);\n\n\tfimd_atomic_disable(ctx->crtc);\n\n\texynos_drm_unregister_dma(ctx->drm_dev, ctx->dev, &ctx->dma_priv);\n\n\tif (ctx->encoder)\n\t\texynos_dpi_remove(ctx->encoder);\n}\n\nstatic const struct component_ops fimd_component_ops = {\n\t.bind\t= fimd_bind,\n\t.unbind = fimd_unbind,\n};\n\nstatic int fimd_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct fimd_context *ctx;\n\tstruct device_node *i80_if_timings;\n\tint ret;\n\n\tif (!dev->of_node)\n\t\treturn -ENODEV;\n\n\tctx = devm_kzalloc(dev, sizeof(*ctx), GFP_KERNEL);\n\tif (!ctx)\n\t\treturn -ENOMEM;\n\n\tctx->dev = dev;\n\tctx->suspended = true;\n\tctx->driver_data = of_device_get_match_data(dev);\n\n\tif (of_property_read_bool(dev->of_node, \"samsung,invert-vden\"))\n\t\tctx->vidcon1 |= VIDCON1_INV_VDEN;\n\tif (of_property_read_bool(dev->of_node, \"samsung,invert-vclk\"))\n\t\tctx->vidcon1 |= VIDCON1_INV_VCLK;\n\n\ti80_if_timings = of_get_child_by_name(dev->of_node, \"i80-if-timings\");\n\tif (i80_if_timings) {\n\t\tu32 val;\n\n\t\tctx->i80_if = true;\n\n\t\tif (ctx->driver_data->has_vidoutcon)\n\t\t\tctx->vidout_con |= VIDOUT_CON_F_I80_LDI0;\n\t\telse\n\t\t\tctx->vidcon0 |= VIDCON0_VIDOUT_I80_LDI0;\n\t\t \n\t\tctx->vidcon0 |= VIDCON0_DSI_EN;\n\n\t\tif (of_property_read_u32(i80_if_timings, \"cs-setup\", &val))\n\t\t\tval = 0;\n\t\tctx->i80ifcon = LCD_CS_SETUP(val);\n\t\tif (of_property_read_u32(i80_if_timings, \"wr-setup\", &val))\n\t\t\tval = 0;\n\t\tctx->i80ifcon |= LCD_WR_SETUP(val);\n\t\tif (of_property_read_u32(i80_if_timings, \"wr-active\", &val))\n\t\t\tval = 1;\n\t\tctx->i80ifcon |= LCD_WR_ACTIVE(val);\n\t\tif (of_property_read_u32(i80_if_timings, \"wr-hold\", &val))\n\t\t\tval = 0;\n\t\tctx->i80ifcon |= LCD_WR_HOLD(val);\n\t}\n\tof_node_put(i80_if_timings);\n\n\tctx->sysreg = syscon_regmap_lookup_by_phandle(dev->of_node,\n\t\t\t\t\t\t\t\"samsung,sysreg\");\n\tif (IS_ERR(ctx->sysreg)) {\n\t\tdev_warn(dev, \"failed to get system register.\\n\");\n\t\tctx->sysreg = NULL;\n\t}\n\n\tctx->bus_clk = devm_clk_get(dev, \"fimd\");\n\tif (IS_ERR(ctx->bus_clk)) {\n\t\tdev_err(dev, \"failed to get bus clock\\n\");\n\t\treturn PTR_ERR(ctx->bus_clk);\n\t}\n\n\tctx->lcd_clk = devm_clk_get(dev, \"sclk_fimd\");\n\tif (IS_ERR(ctx->lcd_clk)) {\n\t\tdev_err(dev, \"failed to get lcd clock\\n\");\n\t\treturn PTR_ERR(ctx->lcd_clk);\n\t}\n\n\tctx->regs = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(ctx->regs))\n\t\treturn PTR_ERR(ctx->regs);\n\n\tret = platform_get_irq_byname(pdev, ctx->i80_if ? \"lcd_sys\" : \"vsync\");\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = devm_request_irq(dev, ret, fimd_irq_handler, 0, \"drm_fimd\", ctx);\n\tif (ret) {\n\t\tdev_err(dev, \"irq request failed.\\n\");\n\t\treturn ret;\n\t}\n\n\tinit_waitqueue_head(&ctx->wait_vsync_queue);\n\tatomic_set(&ctx->wait_vsync_event, 0);\n\n\tplatform_set_drvdata(pdev, ctx);\n\n\tctx->encoder = exynos_dpi_probe(dev);\n\tif (IS_ERR(ctx->encoder))\n\t\treturn PTR_ERR(ctx->encoder);\n\n\tpm_runtime_enable(dev);\n\n\tret = component_add(dev, &fimd_component_ops);\n\tif (ret)\n\t\tgoto err_disable_pm_runtime;\n\n\treturn ret;\n\nerr_disable_pm_runtime:\n\tpm_runtime_disable(dev);\n\n\treturn ret;\n}\n\nstatic int fimd_remove(struct platform_device *pdev)\n{\n\tpm_runtime_disable(&pdev->dev);\n\n\tcomponent_del(&pdev->dev, &fimd_component_ops);\n\n\treturn 0;\n}\n\nstatic int exynos_fimd_suspend(struct device *dev)\n{\n\tstruct fimd_context *ctx = dev_get_drvdata(dev);\n\n\tclk_disable_unprepare(ctx->lcd_clk);\n\tclk_disable_unprepare(ctx->bus_clk);\n\n\treturn 0;\n}\n\nstatic int exynos_fimd_resume(struct device *dev)\n{\n\tstruct fimd_context *ctx = dev_get_drvdata(dev);\n\tint ret;\n\n\tret = clk_prepare_enable(ctx->bus_clk);\n\tif (ret < 0) {\n\t\tDRM_DEV_ERROR(dev,\n\t\t\t      \"Failed to prepare_enable the bus clk [%d]\\n\",\n\t\t\t      ret);\n\t\treturn ret;\n\t}\n\n\tret = clk_prepare_enable(ctx->lcd_clk);\n\tif  (ret < 0) {\n\t\tDRM_DEV_ERROR(dev,\n\t\t\t      \"Failed to prepare_enable the lcd clk [%d]\\n\",\n\t\t\t      ret);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic DEFINE_RUNTIME_DEV_PM_OPS(exynos_fimd_pm_ops, exynos_fimd_suspend,\n\t\t\t\t exynos_fimd_resume, NULL);\n\nstruct platform_driver fimd_driver = {\n\t.probe\t\t= fimd_probe,\n\t.remove\t\t= fimd_remove,\n\t.driver\t\t= {\n\t\t.name\t= \"exynos4-fb\",\n\t\t.owner\t= THIS_MODULE,\n\t\t.pm\t= pm_ptr(&exynos_fimd_pm_ops),\n\t\t.of_match_table = fimd_driver_dt_match,\n\t},\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}