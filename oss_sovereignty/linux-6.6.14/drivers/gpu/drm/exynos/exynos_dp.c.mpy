{
  "module_name": "exynos_dp.c",
  "hash_id": "9cbcccb2cb23190a87cb6abf33ac712ffa4a2c6d6cb9ab151901242fe1593079",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/exynos/exynos_dp.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/component.h>\n#include <linux/err.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/of_graph.h>\n#include <linux/platform_device.h>\n#include <linux/pm_runtime.h>\n#include <video/of_display_timing.h>\n#include <video/of_videomode.h>\n#include <video/videomode.h>\n\n#include <drm/bridge/analogix_dp.h>\n#include <drm/drm_atomic_helper.h>\n#include <drm/drm_bridge.h>\n#include <drm/drm_crtc.h>\n#include <drm/drm_of.h>\n#include <drm/drm_panel.h>\n#include <drm/drm_print.h>\n#include <drm/drm_probe_helper.h>\n#include <drm/drm_simple_kms_helper.h>\n#include <drm/exynos_drm.h>\n\n#include \"exynos_drm_crtc.h\"\n\n#define to_dp(nm)\tcontainer_of(nm, struct exynos_dp_device, nm)\n\nstruct exynos_dp_device {\n\tstruct drm_encoder         encoder;\n\tstruct drm_connector       *connector;\n\tstruct drm_bridge          *ptn_bridge;\n\tstruct drm_device          *drm_dev;\n\tstruct device              *dev;\n\n\tstruct videomode           vm;\n\tstruct analogix_dp_device *adp;\n\tstruct analogix_dp_plat_data plat_data;\n};\n\nstatic int exynos_dp_crtc_clock_enable(struct analogix_dp_plat_data *plat_data,\n\t\t\t\tbool enable)\n{\n\tstruct exynos_dp_device *dp = to_dp(plat_data);\n\tstruct drm_encoder *encoder = &dp->encoder;\n\n\tif (!encoder->crtc)\n\t\treturn -EPERM;\n\n\texynos_drm_pipe_clk_enable(to_exynos_crtc(encoder->crtc), enable);\n\n\treturn 0;\n}\n\nstatic int exynos_dp_poweron(struct analogix_dp_plat_data *plat_data)\n{\n\treturn exynos_dp_crtc_clock_enable(plat_data, true);\n}\n\nstatic int exynos_dp_poweroff(struct analogix_dp_plat_data *plat_data)\n{\n\treturn exynos_dp_crtc_clock_enable(plat_data, false);\n}\n\nstatic int exynos_dp_get_modes(struct analogix_dp_plat_data *plat_data,\n\t\t\t       struct drm_connector *connector)\n{\n\tstruct exynos_dp_device *dp = to_dp(plat_data);\n\tstruct drm_display_mode *mode;\n\tint num_modes = 0;\n\n\tif (dp->plat_data.panel)\n\t\treturn num_modes;\n\n\tmode = drm_mode_create(connector->dev);\n\tif (!mode) {\n\t\tDRM_DEV_ERROR(dp->dev,\n\t\t\t      \"failed to create a new display mode.\\n\");\n\t\treturn num_modes;\n\t}\n\n\tdrm_display_mode_from_videomode(&dp->vm, mode);\n\tconnector->display_info.width_mm = mode->width_mm;\n\tconnector->display_info.height_mm = mode->height_mm;\n\n\tmode->type = DRM_MODE_TYPE_DRIVER | DRM_MODE_TYPE_PREFERRED;\n\tdrm_mode_set_name(mode);\n\tdrm_mode_probed_add(connector, mode);\n\n\treturn num_modes + 1;\n}\n\nstatic int exynos_dp_bridge_attach(struct analogix_dp_plat_data *plat_data,\n\t\t\t\t   struct drm_bridge *bridge,\n\t\t\t\t   struct drm_connector *connector)\n{\n\tstruct exynos_dp_device *dp = to_dp(plat_data);\n\tint ret;\n\n\tdp->connector = connector;\n\n\t \n\tif (dp->ptn_bridge) {\n\t\tret = drm_bridge_attach(&dp->encoder, dp->ptn_bridge, bridge,\n\t\t\t\t\t0);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic void exynos_dp_mode_set(struct drm_encoder *encoder,\n\t\t\t       struct drm_display_mode *mode,\n\t\t\t       struct drm_display_mode *adjusted_mode)\n{\n}\n\nstatic void exynos_dp_nop(struct drm_encoder *encoder)\n{\n\t \n}\n\nstatic const struct drm_encoder_helper_funcs exynos_dp_encoder_helper_funcs = {\n\t.mode_set = exynos_dp_mode_set,\n\t.enable = exynos_dp_nop,\n\t.disable = exynos_dp_nop,\n};\n\nstatic int exynos_dp_dt_parse_panel(struct exynos_dp_device *dp)\n{\n\tint ret;\n\n\tret = of_get_videomode(dp->dev->of_node, &dp->vm, OF_USE_NATIVE_MODE);\n\tif (ret) {\n\t\tDRM_DEV_ERROR(dp->dev,\n\t\t\t      \"failed: of_get_videomode() : %d\\n\", ret);\n\t\treturn ret;\n\t}\n\treturn 0;\n}\n\nstatic int exynos_dp_bind(struct device *dev, struct device *master, void *data)\n{\n\tstruct exynos_dp_device *dp = dev_get_drvdata(dev);\n\tstruct drm_encoder *encoder = &dp->encoder;\n\tstruct drm_device *drm_dev = data;\n\tint ret;\n\n\tdp->drm_dev = drm_dev;\n\n\tif (!dp->plat_data.panel && !dp->ptn_bridge) {\n\t\tret = exynos_dp_dt_parse_panel(dp);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tdrm_simple_encoder_init(drm_dev, encoder, DRM_MODE_ENCODER_TMDS);\n\n\tdrm_encoder_helper_add(encoder, &exynos_dp_encoder_helper_funcs);\n\n\tret = exynos_drm_set_possible_crtcs(encoder, EXYNOS_DISPLAY_TYPE_LCD);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tdp->plat_data.encoder = encoder;\n\n\tret = analogix_dp_bind(dp->adp, dp->drm_dev);\n\tif (ret)\n\t\tdp->encoder.funcs->destroy(&dp->encoder);\n\n\treturn ret;\n}\n\nstatic void exynos_dp_unbind(struct device *dev, struct device *master,\n\t\t\t     void *data)\n{\n\tstruct exynos_dp_device *dp = dev_get_drvdata(dev);\n\n\tanalogix_dp_unbind(dp->adp);\n\tdp->encoder.funcs->destroy(&dp->encoder);\n}\n\nstatic const struct component_ops exynos_dp_ops = {\n\t.bind\t= exynos_dp_bind,\n\t.unbind\t= exynos_dp_unbind,\n};\n\nstatic int exynos_dp_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct device_node *np;\n\tstruct exynos_dp_device *dp;\n\tstruct drm_panel *panel;\n\tstruct drm_bridge *bridge;\n\tint ret;\n\n\tdp = devm_kzalloc(&pdev->dev, sizeof(struct exynos_dp_device),\n\t\t\t  GFP_KERNEL);\n\tif (!dp)\n\t\treturn -ENOMEM;\n\n\tdp->dev = dev;\n\t \n\tplatform_set_drvdata(pdev, dp);\n\n\t \n\tnp = of_parse_phandle(dev->of_node, \"panel\", 0);\n\tif (np) {\n\t\tdp->plat_data.panel = of_drm_find_panel(np);\n\n\t\tof_node_put(np);\n\t\tif (IS_ERR(dp->plat_data.panel))\n\t\t\treturn PTR_ERR(dp->plat_data.panel);\n\n\t\tgoto out;\n\t}\n\n\tret = drm_of_find_panel_or_bridge(dev->of_node, 0, 0, &panel, &bridge);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tdp->plat_data.panel = panel;\n\tdp->plat_data.dev_type = EXYNOS_DP;\n\tdp->plat_data.power_on_start = exynos_dp_poweron;\n\tdp->plat_data.power_off = exynos_dp_poweroff;\n\tdp->plat_data.attach = exynos_dp_bridge_attach;\n\tdp->plat_data.get_modes = exynos_dp_get_modes;\n\tdp->plat_data.skip_connector = !!bridge;\n\n\tdp->ptn_bridge = bridge;\n\nout:\n\tdp->adp = analogix_dp_probe(dev, &dp->plat_data);\n\tif (IS_ERR(dp->adp))\n\t\treturn PTR_ERR(dp->adp);\n\n\treturn component_add(&pdev->dev, &exynos_dp_ops);\n}\n\nstatic int exynos_dp_remove(struct platform_device *pdev)\n{\n\tstruct exynos_dp_device *dp = platform_get_drvdata(pdev);\n\n\tcomponent_del(&pdev->dev, &exynos_dp_ops);\n\tanalogix_dp_remove(dp->adp);\n\n\treturn 0;\n}\n\nstatic int exynos_dp_suspend(struct device *dev)\n{\n\tstruct exynos_dp_device *dp = dev_get_drvdata(dev);\n\n\treturn analogix_dp_suspend(dp->adp);\n}\n\nstatic int exynos_dp_resume(struct device *dev)\n{\n\tstruct exynos_dp_device *dp = dev_get_drvdata(dev);\n\n\treturn analogix_dp_resume(dp->adp);\n}\n\nstatic DEFINE_RUNTIME_DEV_PM_OPS(exynos_dp_pm_ops, exynos_dp_suspend,\n\t\t\t\t exynos_dp_resume, NULL);\n\nstatic const struct of_device_id exynos_dp_match[] = {\n\t{ .compatible = \"samsung,exynos5-dp\" },\n\t{},\n};\nMODULE_DEVICE_TABLE(of, exynos_dp_match);\n\nstruct platform_driver dp_driver = {\n\t.probe\t\t= exynos_dp_probe,\n\t.remove\t\t= exynos_dp_remove,\n\t.driver\t\t= {\n\t\t.name\t= \"exynos-dp\",\n\t\t.owner\t= THIS_MODULE,\n\t\t.pm\t= pm_ptr(&exynos_dp_pm_ops),\n\t\t.of_match_table = exynos_dp_match,\n\t},\n};\n\nMODULE_AUTHOR(\"Jingoo Han <jg1.han@samsung.com>\");\nMODULE_DESCRIPTION(\"Samsung Specific Analogix-DP Driver Extension\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}