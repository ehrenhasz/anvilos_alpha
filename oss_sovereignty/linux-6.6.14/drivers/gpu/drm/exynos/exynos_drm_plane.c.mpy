{
  "module_name": "exynos_drm_plane.c",
  "hash_id": "3b13bde114b696e3e0a563c18421f8b45c3d6f70707c166275cb2bab7d074715",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/exynos/exynos_drm_plane.c",
  "human_readable_source": "\n \n\n\n#include <drm/drm_atomic.h>\n#include <drm/drm_atomic_helper.h>\n#include <drm/drm_blend.h>\n#include <drm/drm_framebuffer.h>\n#include <drm/exynos_drm.h>\n\n#include \"exynos_drm_crtc.h\"\n#include \"exynos_drm_drv.h\"\n#include \"exynos_drm_fb.h\"\n#include \"exynos_drm_gem.h\"\n#include \"exynos_drm_plane.h\"\n\n \nstatic int exynos_plane_get_size(int start, unsigned length, unsigned last)\n{\n\tint end = start + length;\n\tint size = 0;\n\n\tif (start <= 0) {\n\t\tif (end > 0)\n\t\t\tsize = min_t(unsigned, end, last);\n\t} else if (start <= last) {\n\t\tsize = min_t(unsigned, last - start, length);\n\t}\n\n\treturn size;\n}\n\nstatic void exynos_plane_mode_set(struct exynos_drm_plane_state *exynos_state)\n{\n\tstruct drm_plane_state *state = &exynos_state->base;\n\tstruct drm_crtc *crtc = state->crtc;\n\tstruct drm_crtc_state *crtc_state =\n\t\t\tdrm_atomic_get_existing_crtc_state(state->state, crtc);\n\tstruct drm_display_mode *mode = &crtc_state->adjusted_mode;\n\tint crtc_x, crtc_y;\n\tunsigned int crtc_w, crtc_h;\n\tunsigned int src_x, src_y;\n\tunsigned int src_w, src_h;\n\tunsigned int actual_w;\n\tunsigned int actual_h;\n\n\t \n\n\tcrtc_x = state->crtc_x;\n\tcrtc_y = state->crtc_y;\n\tcrtc_w = state->crtc_w;\n\tcrtc_h = state->crtc_h;\n\n\tsrc_x = state->src_x >> 16;\n\tsrc_y = state->src_y >> 16;\n\tsrc_w = state->src_w >> 16;\n\tsrc_h = state->src_h >> 16;\n\n\t \n\texynos_state->h_ratio = (src_w << 16) / crtc_w;\n\texynos_state->v_ratio = (src_h << 16) / crtc_h;\n\n\t \n\tactual_w = exynos_plane_get_size(crtc_x, crtc_w, mode->hdisplay);\n\tactual_h = exynos_plane_get_size(crtc_y, crtc_h, mode->vdisplay);\n\n\tif (crtc_x < 0) {\n\t\tif (actual_w)\n\t\t\tsrc_x += ((-crtc_x) * exynos_state->h_ratio) >> 16;\n\t\tcrtc_x = 0;\n\t}\n\n\tif (crtc_y < 0) {\n\t\tif (actual_h)\n\t\t\tsrc_y += ((-crtc_y) * exynos_state->v_ratio) >> 16;\n\t\tcrtc_y = 0;\n\t}\n\n\t \n\texynos_state->src.x = src_x;\n\texynos_state->src.y = src_y;\n\texynos_state->src.w = (actual_w * exynos_state->h_ratio) >> 16;\n\texynos_state->src.h = (actual_h * exynos_state->v_ratio) >> 16;\n\n\t \n\texynos_state->crtc.x = crtc_x;\n\texynos_state->crtc.y = crtc_y;\n\texynos_state->crtc.w = actual_w;\n\texynos_state->crtc.h = actual_h;\n\n\tDRM_DEV_DEBUG_KMS(crtc->dev->dev,\n\t\t\t  \"plane : offset_x/y(%d,%d), width/height(%d,%d)\",\n\t\t\t  exynos_state->crtc.x, exynos_state->crtc.y,\n\t\t\t  exynos_state->crtc.w, exynos_state->crtc.h);\n}\n\nstatic void exynos_drm_plane_reset(struct drm_plane *plane)\n{\n\tstruct exynos_drm_plane *exynos_plane = to_exynos_plane(plane);\n\tstruct exynos_drm_plane_state *exynos_state;\n\n\tif (plane->state) {\n\t\texynos_state = to_exynos_plane_state(plane->state);\n\t\t__drm_atomic_helper_plane_destroy_state(plane->state);\n\t\tkfree(exynos_state);\n\t\tplane->state = NULL;\n\t}\n\n\texynos_state = kzalloc(sizeof(*exynos_state), GFP_KERNEL);\n\tif (exynos_state) {\n\t\t__drm_atomic_helper_plane_reset(plane, &exynos_state->base);\n\t\tplane->state->zpos = exynos_plane->config->zpos;\n\t}\n}\n\nstatic struct drm_plane_state *\nexynos_drm_plane_duplicate_state(struct drm_plane *plane)\n{\n\tstruct exynos_drm_plane_state *exynos_state;\n\tstruct exynos_drm_plane_state *copy;\n\n\texynos_state = to_exynos_plane_state(plane->state);\n\tcopy = kzalloc(sizeof(*exynos_state), GFP_KERNEL);\n\tif (!copy)\n\t\treturn NULL;\n\n\t__drm_atomic_helper_plane_duplicate_state(plane, &copy->base);\n\treturn &copy->base;\n}\n\nstatic void exynos_drm_plane_destroy_state(struct drm_plane *plane,\n\t\t\t\t\t   struct drm_plane_state *old_state)\n{\n\tstruct exynos_drm_plane_state *old_exynos_state =\n\t\t\t\t\tto_exynos_plane_state(old_state);\n\t__drm_atomic_helper_plane_destroy_state(old_state);\n\tkfree(old_exynos_state);\n}\n\nstatic struct drm_plane_funcs exynos_plane_funcs = {\n\t.update_plane\t= drm_atomic_helper_update_plane,\n\t.disable_plane\t= drm_atomic_helper_disable_plane,\n\t.destroy\t= drm_plane_cleanup,\n\t.reset\t\t= exynos_drm_plane_reset,\n\t.atomic_duplicate_state = exynos_drm_plane_duplicate_state,\n\t.atomic_destroy_state = exynos_drm_plane_destroy_state,\n};\n\nstatic int\nexynos_drm_plane_check_format(const struct exynos_drm_plane_config *config,\n\t\t\t      struct exynos_drm_plane_state *state)\n{\n\tstruct drm_framebuffer *fb = state->base.fb;\n\tstruct drm_device *dev = fb->dev;\n\n\tswitch (fb->modifier) {\n\tcase DRM_FORMAT_MOD_SAMSUNG_64_32_TILE:\n\t\tif (!(config->capabilities & EXYNOS_DRM_PLANE_CAP_TILE))\n\t\t\treturn -ENOTSUPP;\n\t\tbreak;\n\n\tcase DRM_FORMAT_MOD_LINEAR:\n\t\tbreak;\n\n\tdefault:\n\t\tDRM_DEV_ERROR(dev->dev, \"unsupported pixel format modifier\");\n\t\treturn -ENOTSUPP;\n\t}\n\n\treturn 0;\n}\n\nstatic int\nexynos_drm_plane_check_size(const struct exynos_drm_plane_config *config,\n\t\t\t    struct exynos_drm_plane_state *state)\n{\n\tstruct drm_crtc *crtc = state->base.crtc;\n\tbool width_ok = false, height_ok = false;\n\n\tif (config->capabilities & EXYNOS_DRM_PLANE_CAP_SCALE)\n\t\treturn 0;\n\n\tif (state->src.w == state->crtc.w)\n\t\twidth_ok = true;\n\n\tif (state->src.h == state->crtc.h)\n\t\theight_ok = true;\n\n\tif ((config->capabilities & EXYNOS_DRM_PLANE_CAP_DOUBLE) &&\n\t    state->h_ratio == (1 << 15))\n\t\twidth_ok = true;\n\n\tif ((config->capabilities & EXYNOS_DRM_PLANE_CAP_DOUBLE) &&\n\t    state->v_ratio == (1 << 15))\n\t\theight_ok = true;\n\n\tif (width_ok && height_ok)\n\t\treturn 0;\n\n\tDRM_DEV_DEBUG_KMS(crtc->dev->dev, \"scaling mode is not supported\");\n\treturn -ENOTSUPP;\n}\n\nstatic int exynos_plane_atomic_check(struct drm_plane *plane,\n\t\t\t\t     struct drm_atomic_state *state)\n{\n\tstruct drm_plane_state *new_plane_state = drm_atomic_get_new_plane_state(state,\n\t\t\t\t\t\t\t\t\t\t plane);\n\tstruct exynos_drm_plane *exynos_plane = to_exynos_plane(plane);\n\tstruct exynos_drm_plane_state *exynos_state =\n\t\t\t\t\t\tto_exynos_plane_state(new_plane_state);\n\tint ret = 0;\n\n\tif (!new_plane_state->crtc || !new_plane_state->fb)\n\t\treturn 0;\n\n\t \n\texynos_plane_mode_set(exynos_state);\n\n\tret = exynos_drm_plane_check_format(exynos_plane->config, exynos_state);\n\tif (ret)\n\t\treturn ret;\n\n\tret = exynos_drm_plane_check_size(exynos_plane->config, exynos_state);\n\treturn ret;\n}\n\nstatic void exynos_plane_atomic_update(struct drm_plane *plane,\n\t\t\t\t       struct drm_atomic_state *state)\n{\n\tstruct drm_plane_state *new_state = drm_atomic_get_new_plane_state(state,\n\t\t\t\t\t\t\t\t           plane);\n\tstruct exynos_drm_crtc *exynos_crtc = to_exynos_crtc(new_state->crtc);\n\tstruct exynos_drm_plane *exynos_plane = to_exynos_plane(plane);\n\n\tif (!new_state->crtc)\n\t\treturn;\n\n\tif (exynos_crtc->ops->update_plane)\n\t\texynos_crtc->ops->update_plane(exynos_crtc, exynos_plane);\n}\n\nstatic void exynos_plane_atomic_disable(struct drm_plane *plane,\n\t\t\t\t\tstruct drm_atomic_state *state)\n{\n\tstruct drm_plane_state *old_state = drm_atomic_get_old_plane_state(state, plane);\n\tstruct exynos_drm_plane *exynos_plane = to_exynos_plane(plane);\n\tstruct exynos_drm_crtc *exynos_crtc = to_exynos_crtc(old_state->crtc);\n\n\tif (!old_state->crtc)\n\t\treturn;\n\n\tif (exynos_crtc->ops->disable_plane)\n\t\texynos_crtc->ops->disable_plane(exynos_crtc, exynos_plane);\n}\n\nstatic const struct drm_plane_helper_funcs plane_helper_funcs = {\n\t.atomic_check = exynos_plane_atomic_check,\n\t.atomic_update = exynos_plane_atomic_update,\n\t.atomic_disable = exynos_plane_atomic_disable,\n};\n\nstatic void exynos_plane_attach_zpos_property(struct drm_plane *plane,\n\t\t\t\t\t      int zpos, bool immutable)\n{\n\tif (immutable)\n\t\tdrm_plane_create_zpos_immutable_property(plane, zpos);\n\telse\n\t\tdrm_plane_create_zpos_property(plane, zpos, 0, MAX_PLANE - 1);\n}\n\nint exynos_plane_init(struct drm_device *dev,\n\t\t      struct exynos_drm_plane *exynos_plane, unsigned int index,\n\t\t      const struct exynos_drm_plane_config *config)\n{\n\tint err;\n\tunsigned int supported_modes = BIT(DRM_MODE_BLEND_PIXEL_NONE) |\n\t\t\t\t       BIT(DRM_MODE_BLEND_PREMULTI) |\n\t\t\t\t       BIT(DRM_MODE_BLEND_COVERAGE);\n\tstruct drm_plane *plane = &exynos_plane->base;\n\n\terr = drm_universal_plane_init(dev, &exynos_plane->base,\n\t\t\t\t       1 << dev->mode_config.num_crtc,\n\t\t\t\t       &exynos_plane_funcs,\n\t\t\t\t       config->pixel_formats,\n\t\t\t\t       config->num_pixel_formats,\n\t\t\t\t       NULL, config->type, NULL);\n\tif (err) {\n\t\tDRM_DEV_ERROR(dev->dev, \"failed to initialize plane\\n\");\n\t\treturn err;\n\t}\n\n\tdrm_plane_helper_add(&exynos_plane->base, &plane_helper_funcs);\n\n\texynos_plane->index = index;\n\texynos_plane->config = config;\n\n\texynos_plane_attach_zpos_property(&exynos_plane->base, config->zpos,\n\t\t\t   !(config->capabilities & EXYNOS_DRM_PLANE_CAP_ZPOS));\n\n\tif (config->capabilities & EXYNOS_DRM_PLANE_CAP_PIX_BLEND)\n\t\tdrm_plane_create_blend_mode_property(plane, supported_modes);\n\n\tif (config->capabilities & EXYNOS_DRM_PLANE_CAP_WIN_BLEND)\n\t\tdrm_plane_create_alpha_property(plane);\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}