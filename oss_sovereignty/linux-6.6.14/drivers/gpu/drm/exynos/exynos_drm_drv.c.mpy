{
  "module_name": "exynos_drm_drv.c",
  "hash_id": "74fa36a4082bf3cc265342e7df3b411538722678a469b652cab96ae48915301d",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/exynos/exynos_drm_drv.c",
  "human_readable_source": "\n \n\n#include <linux/component.h>\n#include <linux/dma-mapping.h>\n#include <linux/platform_device.h>\n#include <linux/pm_runtime.h>\n#include <linux/uaccess.h>\n\n#include <drm/drm_atomic.h>\n#include <drm/drm_atomic_helper.h>\n#include <drm/drm_drv.h>\n#include <drm/drm_file.h>\n#include <drm/drm_fourcc.h>\n#include <drm/drm_ioctl.h>\n#include <drm/drm_probe_helper.h>\n#include <drm/drm_vblank.h>\n#include <drm/exynos_drm.h>\n\n#include \"exynos_drm_drv.h\"\n#include \"exynos_drm_fb.h\"\n#include \"exynos_drm_fbdev.h\"\n#include \"exynos_drm_g2d.h\"\n#include \"exynos_drm_gem.h\"\n#include \"exynos_drm_ipp.h\"\n#include \"exynos_drm_plane.h\"\n#include \"exynos_drm_vidi.h\"\n\n#define DRIVER_NAME\t\"exynos\"\n#define DRIVER_DESC\t\"Samsung SoC DRM\"\n#define DRIVER_DATE\t\"20180330\"\n\n \n#define DRIVER_MAJOR\t1\n#define DRIVER_MINOR\t1\n\nstatic int exynos_drm_open(struct drm_device *dev, struct drm_file *file)\n{\n\tstruct drm_exynos_file_private *file_priv;\n\tint ret;\n\n\tfile_priv = kzalloc(sizeof(*file_priv), GFP_KERNEL);\n\tif (!file_priv)\n\t\treturn -ENOMEM;\n\n\tfile->driver_priv = file_priv;\n\tret = g2d_open(dev, file);\n\tif (ret)\n\t\tgoto err_file_priv_free;\n\n\treturn ret;\n\nerr_file_priv_free:\n\tkfree(file_priv);\n\tfile->driver_priv = NULL;\n\treturn ret;\n}\n\nstatic void exynos_drm_postclose(struct drm_device *dev, struct drm_file *file)\n{\n\tg2d_close(dev, file);\n\tkfree(file->driver_priv);\n\tfile->driver_priv = NULL;\n}\n\nstatic const struct drm_ioctl_desc exynos_ioctls[] = {\n\tDRM_IOCTL_DEF_DRV(EXYNOS_GEM_CREATE, exynos_drm_gem_create_ioctl,\n\t\t\tDRM_RENDER_ALLOW),\n\tDRM_IOCTL_DEF_DRV(EXYNOS_GEM_MAP, exynos_drm_gem_map_ioctl,\n\t\t\tDRM_RENDER_ALLOW),\n\tDRM_IOCTL_DEF_DRV(EXYNOS_GEM_GET, exynos_drm_gem_get_ioctl,\n\t\t\tDRM_RENDER_ALLOW),\n\tDRM_IOCTL_DEF_DRV(EXYNOS_VIDI_CONNECTION, vidi_connection_ioctl,\n\t\t\tDRM_AUTH),\n\tDRM_IOCTL_DEF_DRV(EXYNOS_G2D_GET_VER, exynos_g2d_get_ver_ioctl,\n\t\t\tDRM_RENDER_ALLOW),\n\tDRM_IOCTL_DEF_DRV(EXYNOS_G2D_SET_CMDLIST, exynos_g2d_set_cmdlist_ioctl,\n\t\t\tDRM_RENDER_ALLOW),\n\tDRM_IOCTL_DEF_DRV(EXYNOS_G2D_EXEC, exynos_g2d_exec_ioctl,\n\t\t\tDRM_RENDER_ALLOW),\n\tDRM_IOCTL_DEF_DRV(EXYNOS_IPP_GET_RESOURCES,\n\t\t\texynos_drm_ipp_get_res_ioctl,\n\t\t\tDRM_RENDER_ALLOW),\n\tDRM_IOCTL_DEF_DRV(EXYNOS_IPP_GET_CAPS, exynos_drm_ipp_get_caps_ioctl,\n\t\t\tDRM_RENDER_ALLOW),\n\tDRM_IOCTL_DEF_DRV(EXYNOS_IPP_GET_LIMITS,\n\t\t\texynos_drm_ipp_get_limits_ioctl,\n\t\t\tDRM_RENDER_ALLOW),\n\tDRM_IOCTL_DEF_DRV(EXYNOS_IPP_COMMIT, exynos_drm_ipp_commit_ioctl,\n\t\t\tDRM_RENDER_ALLOW),\n};\n\nDEFINE_DRM_GEM_FOPS(exynos_drm_driver_fops);\n\nstatic const struct drm_driver exynos_drm_driver = {\n\t.driver_features\t= DRIVER_MODESET | DRIVER_GEM\n\t\t\t\t  | DRIVER_ATOMIC | DRIVER_RENDER,\n\t.open\t\t\t= exynos_drm_open,\n\t.postclose\t\t= exynos_drm_postclose,\n\t.dumb_create\t\t= exynos_drm_gem_dumb_create,\n\t.gem_prime_import\t= exynos_drm_gem_prime_import,\n\t.gem_prime_import_sg_table\t= exynos_drm_gem_prime_import_sg_table,\n\t.ioctls\t\t\t= exynos_ioctls,\n\t.num_ioctls\t\t= ARRAY_SIZE(exynos_ioctls),\n\t.fops\t\t\t= &exynos_drm_driver_fops,\n\t.name\t= DRIVER_NAME,\n\t.desc\t= DRIVER_DESC,\n\t.date\t= DRIVER_DATE,\n\t.major\t= DRIVER_MAJOR,\n\t.minor\t= DRIVER_MINOR,\n};\n\nstatic int exynos_drm_suspend(struct device *dev)\n{\n\tstruct drm_device *drm_dev = dev_get_drvdata(dev);\n\n\treturn  drm_mode_config_helper_suspend(drm_dev);\n}\n\nstatic void exynos_drm_resume(struct device *dev)\n{\n\tstruct drm_device *drm_dev = dev_get_drvdata(dev);\n\n\tdrm_mode_config_helper_resume(drm_dev);\n}\n\nstatic const struct dev_pm_ops exynos_drm_pm_ops = {\n\t.prepare = exynos_drm_suspend,\n\t.complete = exynos_drm_resume,\n};\n\n \nstatic struct platform_driver exynos_drm_platform_driver;\n\nstruct exynos_drm_driver_info {\n\tstruct platform_driver *driver;\n\tunsigned int flags;\n};\n\n#define DRM_COMPONENT_DRIVER\tBIT(0)\t \n#define DRM_VIRTUAL_DEVICE\tBIT(1)\t \n#define DRM_FIMC_DEVICE\t\tBIT(2)\t \n\n#define DRV_PTR(drv, cond) (IS_ENABLED(cond) ? &drv : NULL)\n\n \nstatic struct exynos_drm_driver_info exynos_drm_drivers[] = {\n\t{\n\t\tDRV_PTR(fimd_driver, CONFIG_DRM_EXYNOS_FIMD),\n\t\tDRM_COMPONENT_DRIVER\n\t}, {\n\t\tDRV_PTR(exynos5433_decon_driver, CONFIG_DRM_EXYNOS5433_DECON),\n\t\tDRM_COMPONENT_DRIVER\n\t}, {\n\t\tDRV_PTR(decon_driver, CONFIG_DRM_EXYNOS7_DECON),\n\t\tDRM_COMPONENT_DRIVER\n\t}, {\n\t\tDRV_PTR(mixer_driver, CONFIG_DRM_EXYNOS_MIXER),\n\t\tDRM_COMPONENT_DRIVER\n\t}, {\n\t\tDRV_PTR(dp_driver, CONFIG_DRM_EXYNOS_DP),\n\t\tDRM_COMPONENT_DRIVER\n\t}, {\n\t\tDRV_PTR(dsi_driver, CONFIG_DRM_EXYNOS_DSI),\n\t\tDRM_COMPONENT_DRIVER\n\t}, {\n\t\tDRV_PTR(mic_driver, CONFIG_DRM_EXYNOS_MIC),\n\t\tDRM_COMPONENT_DRIVER\n\t}, {\n\t\tDRV_PTR(hdmi_driver, CONFIG_DRM_EXYNOS_HDMI),\n\t\tDRM_COMPONENT_DRIVER\n\t}, {\n\t\tDRV_PTR(vidi_driver, CONFIG_DRM_EXYNOS_VIDI),\n\t\tDRM_COMPONENT_DRIVER | DRM_VIRTUAL_DEVICE\n\t}, {\n\t\tDRV_PTR(g2d_driver, CONFIG_DRM_EXYNOS_G2D),\n\t\tDRM_COMPONENT_DRIVER\n\t}, {\n\t\tDRV_PTR(fimc_driver, CONFIG_DRM_EXYNOS_FIMC),\n\t\tDRM_COMPONENT_DRIVER | DRM_FIMC_DEVICE,\n\t}, {\n\t\tDRV_PTR(rotator_driver, CONFIG_DRM_EXYNOS_ROTATOR),\n\t\tDRM_COMPONENT_DRIVER\n\t}, {\n\t\tDRV_PTR(scaler_driver, CONFIG_DRM_EXYNOS_SCALER),\n\t\tDRM_COMPONENT_DRIVER\n\t}, {\n\t\tDRV_PTR(gsc_driver, CONFIG_DRM_EXYNOS_GSC),\n\t\tDRM_COMPONENT_DRIVER\n\t}, {\n\t\t&exynos_drm_platform_driver,\n\t\tDRM_VIRTUAL_DEVICE\n\t}\n};\n\nstatic struct component_match *exynos_drm_match_add(struct device *dev)\n{\n\tstruct component_match *match = NULL;\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(exynos_drm_drivers); ++i) {\n\t\tstruct exynos_drm_driver_info *info = &exynos_drm_drivers[i];\n\t\tstruct device *p = NULL, *d;\n\n\t\tif (!info->driver || !(info->flags & DRM_COMPONENT_DRIVER))\n\t\t\tcontinue;\n\n\t\twhile ((d = platform_find_device_by_driver(p, &info->driver->driver))) {\n\t\t\tput_device(p);\n\n\t\t\tif (!(info->flags & DRM_FIMC_DEVICE) ||\n\t\t\t    exynos_drm_check_fimc_device(d) == 0)\n\t\t\t\tcomponent_match_add(dev, &match, component_compare_dev, d);\n\t\t\tp = d;\n\t\t}\n\t\tput_device(p);\n\t}\n\n\treturn match ?: ERR_PTR(-ENODEV);\n}\n\nstatic int exynos_drm_bind(struct device *dev)\n{\n\tstruct exynos_drm_private *private;\n\tstruct drm_encoder *encoder;\n\tstruct drm_device *drm;\n\tunsigned int clone_mask;\n\tint ret;\n\n\tdrm = drm_dev_alloc(&exynos_drm_driver, dev);\n\tif (IS_ERR(drm))\n\t\treturn PTR_ERR(drm);\n\n\tprivate = kzalloc(sizeof(struct exynos_drm_private), GFP_KERNEL);\n\tif (!private) {\n\t\tret = -ENOMEM;\n\t\tgoto err_free_drm;\n\t}\n\n\tinit_waitqueue_head(&private->wait);\n\tspin_lock_init(&private->lock);\n\n\tdev_set_drvdata(dev, drm);\n\tdrm->dev_private = (void *)private;\n\n\tdrm_mode_config_init(drm);\n\n\texynos_drm_mode_config_init(drm);\n\n\t \n\tclone_mask = 0;\n\tlist_for_each_entry(encoder, &drm->mode_config.encoder_list, head)\n\t\tclone_mask |= drm_encoder_mask(encoder);\n\n\tlist_for_each_entry(encoder, &drm->mode_config.encoder_list, head)\n\t\tencoder->possible_clones = clone_mask;\n\n\t \n\tret = component_bind_all(drm->dev, drm);\n\tif (ret)\n\t\tgoto err_mode_config_cleanup;\n\n\tret = drm_vblank_init(drm, drm->mode_config.num_crtc);\n\tif (ret)\n\t\tgoto err_unbind_all;\n\n\tdrm_mode_config_reset(drm);\n\n\t \n\tdrm_kms_helper_poll_init(drm);\n\n\t \n\tret = drm_dev_register(drm, 0);\n\tif (ret < 0)\n\t\tgoto err_cleanup_poll;\n\n\texynos_drm_fbdev_setup(drm);\n\n\treturn 0;\n\nerr_cleanup_poll:\n\tdrm_kms_helper_poll_fini(drm);\nerr_unbind_all:\n\tcomponent_unbind_all(drm->dev, drm);\nerr_mode_config_cleanup:\n\tdrm_mode_config_cleanup(drm);\n\texynos_drm_cleanup_dma(drm);\n\tkfree(private);\nerr_free_drm:\n\tdrm_dev_put(drm);\n\n\treturn ret;\n}\n\nstatic void exynos_drm_unbind(struct device *dev)\n{\n\tstruct drm_device *drm = dev_get_drvdata(dev);\n\n\tdrm_dev_unregister(drm);\n\n\tdrm_kms_helper_poll_fini(drm);\n\n\tcomponent_unbind_all(drm->dev, drm);\n\tdrm_mode_config_cleanup(drm);\n\texynos_drm_cleanup_dma(drm);\n\n\tkfree(drm->dev_private);\n\tdrm->dev_private = NULL;\n\tdev_set_drvdata(dev, NULL);\n\n\tdrm_dev_put(drm);\n}\n\nstatic const struct component_master_ops exynos_drm_ops = {\n\t.bind\t\t= exynos_drm_bind,\n\t.unbind\t\t= exynos_drm_unbind,\n};\n\nstatic int exynos_drm_platform_probe(struct platform_device *pdev)\n{\n\tstruct component_match *match;\n\n\tpdev->dev.coherent_dma_mask = DMA_BIT_MASK(32);\n\n\tmatch = exynos_drm_match_add(&pdev->dev);\n\tif (IS_ERR(match))\n\t\treturn PTR_ERR(match);\n\n\treturn component_master_add_with_match(&pdev->dev, &exynos_drm_ops,\n\t\t\t\t\t       match);\n}\n\nstatic int exynos_drm_platform_remove(struct platform_device *pdev)\n{\n\tcomponent_master_del(&pdev->dev, &exynos_drm_ops);\n\treturn 0;\n}\n\nstatic struct platform_driver exynos_drm_platform_driver = {\n\t.probe\t= exynos_drm_platform_probe,\n\t.remove\t= exynos_drm_platform_remove,\n\t.driver\t= {\n\t\t.name\t= \"exynos-drm\",\n\t\t.pm\t= &exynos_drm_pm_ops,\n\t},\n};\n\nstatic void exynos_drm_unregister_devices(void)\n{\n\tint i;\n\n\tfor (i = ARRAY_SIZE(exynos_drm_drivers) - 1; i >= 0; --i) {\n\t\tstruct exynos_drm_driver_info *info = &exynos_drm_drivers[i];\n\t\tstruct device *dev;\n\n\t\tif (!info->driver || !(info->flags & DRM_VIRTUAL_DEVICE))\n\t\t\tcontinue;\n\n\t\twhile ((dev = platform_find_device_by_driver(NULL,\n\t\t\t\t\t\t&info->driver->driver))) {\n\t\t\tput_device(dev);\n\t\t\tplatform_device_unregister(to_platform_device(dev));\n\t\t}\n\t}\n}\n\nstatic int exynos_drm_register_devices(void)\n{\n\tstruct platform_device *pdev;\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(exynos_drm_drivers); ++i) {\n\t\tstruct exynos_drm_driver_info *info = &exynos_drm_drivers[i];\n\n\t\tif (!info->driver || !(info->flags & DRM_VIRTUAL_DEVICE))\n\t\t\tcontinue;\n\n\t\tpdev = platform_device_register_simple(\n\t\t\t\t\tinfo->driver->driver.name, -1, NULL, 0);\n\t\tif (IS_ERR(pdev))\n\t\t\tgoto fail;\n\t}\n\n\treturn 0;\nfail:\n\texynos_drm_unregister_devices();\n\treturn PTR_ERR(pdev);\n}\n\nstatic void exynos_drm_unregister_drivers(void)\n{\n\tint i;\n\n\tfor (i = ARRAY_SIZE(exynos_drm_drivers) - 1; i >= 0; --i) {\n\t\tstruct exynos_drm_driver_info *info = &exynos_drm_drivers[i];\n\n\t\tif (!info->driver)\n\t\t\tcontinue;\n\n\t\tplatform_driver_unregister(info->driver);\n\t}\n}\n\nstatic int exynos_drm_register_drivers(void)\n{\n\tint i, ret;\n\n\tfor (i = 0; i < ARRAY_SIZE(exynos_drm_drivers); ++i) {\n\t\tstruct exynos_drm_driver_info *info = &exynos_drm_drivers[i];\n\n\t\tif (!info->driver)\n\t\t\tcontinue;\n\n\t\tret = platform_driver_register(info->driver);\n\t\tif (ret)\n\t\t\tgoto fail;\n\t}\n\treturn 0;\nfail:\n\texynos_drm_unregister_drivers();\n\treturn ret;\n}\n\nstatic int exynos_drm_init(void)\n{\n\tint ret;\n\n\tif (drm_firmware_drivers_only())\n\t\treturn -ENODEV;\n\n\tret = exynos_drm_register_devices();\n\tif (ret)\n\t\treturn ret;\n\n\tret = exynos_drm_register_drivers();\n\tif (ret)\n\t\tgoto err_unregister_pdevs;\n\n\treturn 0;\n\nerr_unregister_pdevs:\n\texynos_drm_unregister_devices();\n\n\treturn ret;\n}\n\nstatic void exynos_drm_exit(void)\n{\n\texynos_drm_unregister_drivers();\n\texynos_drm_unregister_devices();\n}\n\nmodule_init(exynos_drm_init);\nmodule_exit(exynos_drm_exit);\n\nMODULE_AUTHOR(\"Inki Dae <inki.dae@samsung.com>\");\nMODULE_AUTHOR(\"Joonyoung Shim <jy0922.shim@samsung.com>\");\nMODULE_AUTHOR(\"Seung-Woo Kim <sw0312.kim@samsung.com>\");\nMODULE_DESCRIPTION(\"Samsung SoC DRM Driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}