{
  "module_name": "exynos_drm_drv.h",
  "hash_id": "cdf2d3b14cab3009be3cdd780717949f8361900bb1b147771eb50de3e17736db",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/exynos/exynos_drm_drv.h",
  "human_readable_source": " \n \n\n#ifndef _EXYNOS_DRM_DRV_H_\n#define _EXYNOS_DRM_DRV_H_\n\n#include <linux/module.h>\n\n#include <drm/drm_crtc.h>\n#include <drm/drm_device.h>\n#include <drm/drm_plane.h>\n\n#define MAX_CRTC\t3\n#define MAX_PLANE\t5\n#define MAX_FB_BUFFER\t4\n\n#define DEFAULT_WIN\t0\n\nstruct drm_crtc_state;\nstruct drm_display_mode;\n\n#define to_exynos_crtc(x)\tcontainer_of(x, struct exynos_drm_crtc, base)\n#define to_exynos_plane(x)\tcontainer_of(x, struct exynos_drm_plane, base)\n\n \nenum exynos_drm_output_type {\n\tEXYNOS_DISPLAY_TYPE_NONE,\n\t \n\tEXYNOS_DISPLAY_TYPE_LCD,\n\t \n\tEXYNOS_DISPLAY_TYPE_HDMI,\n\t \n\tEXYNOS_DISPLAY_TYPE_VIDI,\n};\n\nstruct exynos_drm_rect {\n\tunsigned int x, y;\n\tunsigned int w, h;\n};\n\n \n\nstruct exynos_drm_plane_state {\n\tstruct drm_plane_state base;\n\tstruct exynos_drm_rect crtc;\n\tstruct exynos_drm_rect src;\n\tunsigned int h_ratio;\n\tunsigned int v_ratio;\n};\n\nstatic inline struct exynos_drm_plane_state *\nto_exynos_plane_state(struct drm_plane_state *state)\n{\n\treturn container_of(state, struct exynos_drm_plane_state, base);\n}\n\n \n\nstruct exynos_drm_plane {\n\tstruct drm_plane base;\n\tconst struct exynos_drm_plane_config *config;\n\tunsigned int index;\n};\n\n#define EXYNOS_DRM_PLANE_CAP_DOUBLE\t(1 << 0)\n#define EXYNOS_DRM_PLANE_CAP_SCALE\t(1 << 1)\n#define EXYNOS_DRM_PLANE_CAP_ZPOS\t(1 << 2)\n#define EXYNOS_DRM_PLANE_CAP_TILE\t(1 << 3)\n#define EXYNOS_DRM_PLANE_CAP_PIX_BLEND\t(1 << 4)\n#define EXYNOS_DRM_PLANE_CAP_WIN_BLEND\t(1 << 5)\n\n \n\nstruct exynos_drm_plane_config {\n\tunsigned int zpos;\n\tenum drm_plane_type type;\n\tconst uint32_t *pixel_formats;\n\tunsigned int num_pixel_formats;\n\tunsigned int capabilities;\n};\n\n \nstruct exynos_drm_crtc;\nstruct exynos_drm_crtc_ops {\n\tvoid (*atomic_enable)(struct exynos_drm_crtc *crtc);\n\tvoid (*atomic_disable)(struct exynos_drm_crtc *crtc);\n\tint (*enable_vblank)(struct exynos_drm_crtc *crtc);\n\tvoid (*disable_vblank)(struct exynos_drm_crtc *crtc);\n\tenum drm_mode_status (*mode_valid)(struct exynos_drm_crtc *crtc,\n\t\tconst struct drm_display_mode *mode);\n\tbool (*mode_fixup)(struct exynos_drm_crtc *crtc,\n\t\t\t   const struct drm_display_mode *mode,\n\t\t\t   struct drm_display_mode *adjusted_mode);\n\tint (*atomic_check)(struct exynos_drm_crtc *crtc,\n\t\t\t    struct drm_crtc_state *state);\n\tvoid (*atomic_begin)(struct exynos_drm_crtc *crtc);\n\tvoid (*update_plane)(struct exynos_drm_crtc *crtc,\n\t\t\t     struct exynos_drm_plane *plane);\n\tvoid (*disable_plane)(struct exynos_drm_crtc *crtc,\n\t\t\t      struct exynos_drm_plane *plane);\n\tvoid (*atomic_flush)(struct exynos_drm_crtc *crtc);\n\tvoid (*te_handler)(struct exynos_drm_crtc *crtc);\n};\n\nstruct exynos_drm_clk {\n\tvoid (*enable)(struct exynos_drm_clk *clk, bool enable);\n};\n\n \nstruct exynos_drm_crtc {\n\tstruct drm_crtc\t\t\tbase;\n\tenum exynos_drm_output_type\ttype;\n\tconst struct exynos_drm_crtc_ops\t*ops;\n\tvoid\t\t\t\t*ctx;\n\tstruct exynos_drm_clk\t\t*pipe_clk;\n\tbool\t\t\t\ti80_mode : 1;\n};\n\nstatic inline void exynos_drm_pipe_clk_enable(struct exynos_drm_crtc *crtc,\n\t\t\t\t\t      bool enable)\n{\n\tif (crtc->pipe_clk)\n\t\tcrtc->pipe_clk->enable(crtc->pipe_clk, enable);\n}\n\nstruct drm_exynos_file_private {\n\t \n\tstruct list_head\tinuse_cmdlist;\n\tstruct list_head\tevent_list;\n\tstruct list_head\tuserptr_list;\n};\n\n \nstruct exynos_drm_private {\n\tstruct device *g2d_dev;\n\tstruct device *dma_dev;\n\tvoid *mapping;\n\n\t \n\tu32\t\t\tpending;\n\tspinlock_t\t\tlock;\n\twait_queue_head_t\twait;\n};\n\nstatic inline struct device *to_dma_dev(struct drm_device *dev)\n{\n\tstruct exynos_drm_private *priv = dev->dev_private;\n\n\treturn priv->dma_dev;\n}\n\nstatic inline bool is_drm_iommu_supported(struct drm_device *drm_dev)\n{\n\tstruct exynos_drm_private *priv = drm_dev->dev_private;\n\n\treturn priv->mapping ? true : false;\n}\n\nint exynos_drm_register_dma(struct drm_device *drm, struct device *dev,\n\t\t\t    void **dma_priv);\nvoid exynos_drm_unregister_dma(struct drm_device *drm, struct device *dev,\n\t\t\t       void **dma_priv);\nvoid exynos_drm_cleanup_dma(struct drm_device *drm);\n\n#ifdef CONFIG_DRM_EXYNOS_DPI\nstruct drm_encoder *exynos_dpi_probe(struct device *dev);\nint exynos_dpi_remove(struct drm_encoder *encoder);\nint exynos_dpi_bind(struct drm_device *dev, struct drm_encoder *encoder);\n#else\nstatic inline struct drm_encoder *\nexynos_dpi_probe(struct device *dev) { return NULL; }\nstatic inline int exynos_dpi_remove(struct drm_encoder *encoder)\n{\n\treturn 0;\n}\nstatic inline int exynos_dpi_bind(struct drm_device *dev,\n\t\t\t\t  struct drm_encoder *encoder)\n{\n\treturn 0;\n}\n#endif\n\n#ifdef CONFIG_DRM_EXYNOS_FIMC\nint exynos_drm_check_fimc_device(struct device *dev);\n#else\nstatic inline int exynos_drm_check_fimc_device(struct device *dev)\n{\n\treturn 0;\n}\n#endif\n\nint exynos_atomic_commit(struct drm_device *dev, struct drm_atomic_state *state,\n\t\t\t bool nonblock);\n\n\nextern struct platform_driver fimd_driver;\nextern struct platform_driver exynos5433_decon_driver;\nextern struct platform_driver decon_driver;\nextern struct platform_driver dp_driver;\nextern struct platform_driver dsi_driver;\nextern struct platform_driver mixer_driver;\nextern struct platform_driver hdmi_driver;\nextern struct platform_driver vidi_driver;\nextern struct platform_driver g2d_driver;\nextern struct platform_driver fimc_driver;\nextern struct platform_driver rotator_driver;\nextern struct platform_driver scaler_driver;\nextern struct platform_driver gsc_driver;\nextern struct platform_driver mic_driver;\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}