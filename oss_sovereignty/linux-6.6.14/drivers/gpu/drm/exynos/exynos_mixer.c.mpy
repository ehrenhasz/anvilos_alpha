{
  "module_name": "exynos_mixer.c",
  "hash_id": "6f65bf824557761094f1ff5ef73eefefb79665ffbc0e08af063ee23e7d01350a",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/exynos/exynos_mixer.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/component.h>\n#include <linux/delay.h>\n#include <linux/i2c.h>\n#include <linux/interrupt.h>\n#include <linux/irq.h>\n#include <linux/kernel.h>\n#include <linux/ktime.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/pm_runtime.h>\n#include <linux/regulator/consumer.h>\n#include <linux/spinlock.h>\n#include <linux/wait.h>\n\n#include <drm/drm_blend.h>\n#include <drm/drm_edid.h>\n#include <drm/drm_fourcc.h>\n#include <drm/drm_framebuffer.h>\n#include <drm/drm_vblank.h>\n#include <drm/exynos_drm.h>\n\n#include \"exynos_drm_crtc.h\"\n#include \"exynos_drm_drv.h\"\n#include \"exynos_drm_fb.h\"\n#include \"exynos_drm_plane.h\"\n#include \"regs-mixer.h\"\n#include \"regs-vp.h\"\n\n#define MIXER_WIN_NR\t\t3\n#define VP_DEFAULT_WIN\t\t2\n\n \n#define MXR_CSC_C(x) ((int)((x) * 512.0) & 0x3ff)\n#define MXR_CSC_CT(a0, a1, a2) \\\n  ((MXR_CSC_C(a0) << 20) | (MXR_CSC_C(a1) << 10) | (MXR_CSC_C(a2) << 0))\n\n \n#define MXR_YCBCR_VAL(y, cb, cr) (((y) << 16) | ((cb) << 8) | ((cr) << 0))\n\n \n#define MXR_FORMAT_RGB565\t4\n#define MXR_FORMAT_ARGB1555\t5\n#define MXR_FORMAT_ARGB4444\t6\n#define MXR_FORMAT_ARGB8888\t7\n\nenum mixer_version_id {\n\tMXR_VER_0_0_0_16,\n\tMXR_VER_16_0_33_0,\n\tMXR_VER_128_0_0_184,\n};\n\nenum mixer_flag_bits {\n\tMXR_BIT_POWERED,\n\tMXR_BIT_VSYNC,\n\tMXR_BIT_INTERLACE,\n\tMXR_BIT_VP_ENABLED,\n\tMXR_BIT_HAS_SCLK,\n};\n\nstatic const uint32_t mixer_formats[] = {\n\tDRM_FORMAT_XRGB4444,\n\tDRM_FORMAT_ARGB4444,\n\tDRM_FORMAT_XRGB1555,\n\tDRM_FORMAT_ARGB1555,\n\tDRM_FORMAT_RGB565,\n\tDRM_FORMAT_XRGB8888,\n\tDRM_FORMAT_ARGB8888,\n};\n\nstatic const uint32_t vp_formats[] = {\n\tDRM_FORMAT_NV12,\n\tDRM_FORMAT_NV21,\n};\n\nstruct mixer_context {\n\tstruct platform_device *pdev;\n\tstruct device\t\t*dev;\n\tstruct drm_device\t*drm_dev;\n\tvoid\t\t\t*dma_priv;\n\tstruct exynos_drm_crtc\t*crtc;\n\tstruct exynos_drm_plane\tplanes[MIXER_WIN_NR];\n\tunsigned long\t\tflags;\n\n\tint\t\t\tirq;\n\tvoid __iomem\t\t*mixer_regs;\n\tvoid __iomem\t\t*vp_regs;\n\tspinlock_t\t\treg_slock;\n\tstruct clk\t\t*mixer;\n\tstruct clk\t\t*vp;\n\tstruct clk\t\t*hdmi;\n\tstruct clk\t\t*sclk_mixer;\n\tstruct clk\t\t*sclk_hdmi;\n\tstruct clk\t\t*mout_mixer;\n\tenum mixer_version_id\tmxr_ver;\n\tint\t\t\tscan_value;\n};\n\nstruct mixer_drv_data {\n\tenum mixer_version_id\tversion;\n\tbool\t\t\t\t\tis_vp_enabled;\n\tbool\t\t\t\t\thas_sclk;\n};\n\nstatic const struct exynos_drm_plane_config plane_configs[MIXER_WIN_NR] = {\n\t{\n\t\t.zpos = 0,\n\t\t.type = DRM_PLANE_TYPE_PRIMARY,\n\t\t.pixel_formats = mixer_formats,\n\t\t.num_pixel_formats = ARRAY_SIZE(mixer_formats),\n\t\t.capabilities = EXYNOS_DRM_PLANE_CAP_DOUBLE |\n\t\t\t\tEXYNOS_DRM_PLANE_CAP_ZPOS |\n\t\t\t\tEXYNOS_DRM_PLANE_CAP_PIX_BLEND |\n\t\t\t\tEXYNOS_DRM_PLANE_CAP_WIN_BLEND,\n\t}, {\n\t\t.zpos = 1,\n\t\t.type = DRM_PLANE_TYPE_CURSOR,\n\t\t.pixel_formats = mixer_formats,\n\t\t.num_pixel_formats = ARRAY_SIZE(mixer_formats),\n\t\t.capabilities = EXYNOS_DRM_PLANE_CAP_DOUBLE |\n\t\t\t\tEXYNOS_DRM_PLANE_CAP_ZPOS |\n\t\t\t\tEXYNOS_DRM_PLANE_CAP_PIX_BLEND |\n\t\t\t\tEXYNOS_DRM_PLANE_CAP_WIN_BLEND,\n\t}, {\n\t\t.zpos = 2,\n\t\t.type = DRM_PLANE_TYPE_OVERLAY,\n\t\t.pixel_formats = vp_formats,\n\t\t.num_pixel_formats = ARRAY_SIZE(vp_formats),\n\t\t.capabilities = EXYNOS_DRM_PLANE_CAP_SCALE |\n\t\t\t\tEXYNOS_DRM_PLANE_CAP_ZPOS |\n\t\t\t\tEXYNOS_DRM_PLANE_CAP_TILE |\n\t\t\t\tEXYNOS_DRM_PLANE_CAP_WIN_BLEND,\n\t},\n};\n\nstatic const u8 filter_y_horiz_tap8[] = {\n\t0,\t-1,\t-1,\t-1,\t-1,\t-1,\t-1,\t-1,\n\t-1,\t-1,\t-1,\t-1,\t-1,\t0,\t0,\t0,\n\t0,\t2,\t4,\t5,\t6,\t6,\t6,\t6,\n\t6,\t5,\t5,\t4,\t3,\t2,\t1,\t1,\n\t0,\t-6,\t-12,\t-16,\t-18,\t-20,\t-21,\t-20,\n\t-20,\t-18,\t-16,\t-13,\t-10,\t-8,\t-5,\t-2,\n\t127,\t126,\t125,\t121,\t114,\t107,\t99,\t89,\n\t79,\t68,\t57,\t46,\t35,\t25,\t16,\t8,\n};\n\nstatic const u8 filter_y_vert_tap4[] = {\n\t0,\t-3,\t-6,\t-8,\t-8,\t-8,\t-8,\t-7,\n\t-6,\t-5,\t-4,\t-3,\t-2,\t-1,\t-1,\t0,\n\t127,\t126,\t124,\t118,\t111,\t102,\t92,\t81,\n\t70,\t59,\t48,\t37,\t27,\t19,\t11,\t5,\n\t0,\t5,\t11,\t19,\t27,\t37,\t48,\t59,\n\t70,\t81,\t92,\t102,\t111,\t118,\t124,\t126,\n\t0,\t0,\t-1,\t-1,\t-2,\t-3,\t-4,\t-5,\n\t-6,\t-7,\t-8,\t-8,\t-8,\t-8,\t-6,\t-3,\n};\n\nstatic const u8 filter_cr_horiz_tap4[] = {\n\t0,\t-3,\t-6,\t-8,\t-8,\t-8,\t-8,\t-7,\n\t-6,\t-5,\t-4,\t-3,\t-2,\t-1,\t-1,\t0,\n\t127,\t126,\t124,\t118,\t111,\t102,\t92,\t81,\n\t70,\t59,\t48,\t37,\t27,\t19,\t11,\t5,\n};\n\nstatic inline u32 vp_reg_read(struct mixer_context *ctx, u32 reg_id)\n{\n\treturn readl(ctx->vp_regs + reg_id);\n}\n\nstatic inline void vp_reg_write(struct mixer_context *ctx, u32 reg_id,\n\t\t\t\t u32 val)\n{\n\twritel(val, ctx->vp_regs + reg_id);\n}\n\nstatic inline void vp_reg_writemask(struct mixer_context *ctx, u32 reg_id,\n\t\t\t\t u32 val, u32 mask)\n{\n\tu32 old = vp_reg_read(ctx, reg_id);\n\n\tval = (val & mask) | (old & ~mask);\n\twritel(val, ctx->vp_regs + reg_id);\n}\n\nstatic inline u32 mixer_reg_read(struct mixer_context *ctx, u32 reg_id)\n{\n\treturn readl(ctx->mixer_regs + reg_id);\n}\n\nstatic inline void mixer_reg_write(struct mixer_context *ctx, u32 reg_id,\n\t\t\t\t u32 val)\n{\n\twritel(val, ctx->mixer_regs + reg_id);\n}\n\nstatic inline void mixer_reg_writemask(struct mixer_context *ctx,\n\t\t\t\t u32 reg_id, u32 val, u32 mask)\n{\n\tu32 old = mixer_reg_read(ctx, reg_id);\n\n\tval = (val & mask) | (old & ~mask);\n\twritel(val, ctx->mixer_regs + reg_id);\n}\n\nstatic void mixer_regs_dump(struct mixer_context *ctx)\n{\n#define DUMPREG(reg_id) \\\ndo { \\\n\tDRM_DEV_DEBUG_KMS(ctx->dev, #reg_id \" = %08x\\n\", \\\n\t\t\t (u32)readl(ctx->mixer_regs + reg_id)); \\\n} while (0)\n\n\tDUMPREG(MXR_STATUS);\n\tDUMPREG(MXR_CFG);\n\tDUMPREG(MXR_INT_EN);\n\tDUMPREG(MXR_INT_STATUS);\n\n\tDUMPREG(MXR_LAYER_CFG);\n\tDUMPREG(MXR_VIDEO_CFG);\n\n\tDUMPREG(MXR_GRAPHIC0_CFG);\n\tDUMPREG(MXR_GRAPHIC0_BASE);\n\tDUMPREG(MXR_GRAPHIC0_SPAN);\n\tDUMPREG(MXR_GRAPHIC0_WH);\n\tDUMPREG(MXR_GRAPHIC0_SXY);\n\tDUMPREG(MXR_GRAPHIC0_DXY);\n\n\tDUMPREG(MXR_GRAPHIC1_CFG);\n\tDUMPREG(MXR_GRAPHIC1_BASE);\n\tDUMPREG(MXR_GRAPHIC1_SPAN);\n\tDUMPREG(MXR_GRAPHIC1_WH);\n\tDUMPREG(MXR_GRAPHIC1_SXY);\n\tDUMPREG(MXR_GRAPHIC1_DXY);\n#undef DUMPREG\n}\n\nstatic void vp_regs_dump(struct mixer_context *ctx)\n{\n#define DUMPREG(reg_id) \\\ndo { \\\n\tDRM_DEV_DEBUG_KMS(ctx->dev, #reg_id \" = %08x\\n\", \\\n\t\t\t (u32) readl(ctx->vp_regs + reg_id)); \\\n} while (0)\n\n\tDUMPREG(VP_ENABLE);\n\tDUMPREG(VP_SRESET);\n\tDUMPREG(VP_SHADOW_UPDATE);\n\tDUMPREG(VP_FIELD_ID);\n\tDUMPREG(VP_MODE);\n\tDUMPREG(VP_IMG_SIZE_Y);\n\tDUMPREG(VP_IMG_SIZE_C);\n\tDUMPREG(VP_PER_RATE_CTRL);\n\tDUMPREG(VP_TOP_Y_PTR);\n\tDUMPREG(VP_BOT_Y_PTR);\n\tDUMPREG(VP_TOP_C_PTR);\n\tDUMPREG(VP_BOT_C_PTR);\n\tDUMPREG(VP_ENDIAN_MODE);\n\tDUMPREG(VP_SRC_H_POSITION);\n\tDUMPREG(VP_SRC_V_POSITION);\n\tDUMPREG(VP_SRC_WIDTH);\n\tDUMPREG(VP_SRC_HEIGHT);\n\tDUMPREG(VP_DST_H_POSITION);\n\tDUMPREG(VP_DST_V_POSITION);\n\tDUMPREG(VP_DST_WIDTH);\n\tDUMPREG(VP_DST_HEIGHT);\n\tDUMPREG(VP_H_RATIO);\n\tDUMPREG(VP_V_RATIO);\n\n#undef DUMPREG\n}\n\nstatic inline void vp_filter_set(struct mixer_context *ctx,\n\t\tint reg_id, const u8 *data, unsigned int size)\n{\n\t \n\tBUG_ON(size & 3);\n\tfor (; size; size -= 4, reg_id += 4, data += 4) {\n\t\tu32 val = (data[0] << 24) |  (data[1] << 16) |\n\t\t\t(data[2] << 8) | data[3];\n\t\tvp_reg_write(ctx, reg_id, val);\n\t}\n}\n\nstatic void vp_default_filter(struct mixer_context *ctx)\n{\n\tvp_filter_set(ctx, VP_POLY8_Y0_LL,\n\t\tfilter_y_horiz_tap8, sizeof(filter_y_horiz_tap8));\n\tvp_filter_set(ctx, VP_POLY4_Y0_LL,\n\t\tfilter_y_vert_tap4, sizeof(filter_y_vert_tap4));\n\tvp_filter_set(ctx, VP_POLY4_C0_LL,\n\t\tfilter_cr_horiz_tap4, sizeof(filter_cr_horiz_tap4));\n}\n\nstatic void mixer_cfg_gfx_blend(struct mixer_context *ctx, unsigned int win,\n\t\t\t\tunsigned int pixel_alpha, unsigned int alpha)\n{\n\tu32 win_alpha = alpha >> 8;\n\tu32 val;\n\n\tval  = MXR_GRP_CFG_COLOR_KEY_DISABLE;  \n\tswitch (pixel_alpha) {\n\tcase DRM_MODE_BLEND_PIXEL_NONE:\n\t\tbreak;\n\tcase DRM_MODE_BLEND_COVERAGE:\n\t\tval |= MXR_GRP_CFG_PIXEL_BLEND_EN;\n\t\tbreak;\n\tcase DRM_MODE_BLEND_PREMULTI:\n\tdefault:\n\t\tval |= MXR_GRP_CFG_BLEND_PRE_MUL;\n\t\tval |= MXR_GRP_CFG_PIXEL_BLEND_EN;\n\t\tbreak;\n\t}\n\n\tif (alpha != DRM_BLEND_ALPHA_OPAQUE) {\n\t\tval |= MXR_GRP_CFG_WIN_BLEND_EN;\n\t\tval |= win_alpha;\n\t}\n\tmixer_reg_writemask(ctx, MXR_GRAPHIC_CFG(win),\n\t\t\t    val, MXR_GRP_CFG_MISC_MASK);\n}\n\nstatic void mixer_cfg_vp_blend(struct mixer_context *ctx, unsigned int alpha)\n{\n\tu32 win_alpha = alpha >> 8;\n\tu32 val = 0;\n\n\tif (alpha != DRM_BLEND_ALPHA_OPAQUE) {\n\t\tval |= MXR_VID_CFG_BLEND_EN;\n\t\tval |= win_alpha;\n\t}\n\tmixer_reg_write(ctx, MXR_VIDEO_CFG, val);\n}\n\nstatic bool mixer_is_synced(struct mixer_context *ctx)\n{\n\tu32 base, shadow;\n\n\tif (ctx->mxr_ver == MXR_VER_16_0_33_0 ||\n\t    ctx->mxr_ver == MXR_VER_128_0_0_184)\n\t\treturn !(mixer_reg_read(ctx, MXR_CFG) &\n\t\t\t MXR_CFG_LAYER_UPDATE_COUNT_MASK);\n\n\tif (test_bit(MXR_BIT_VP_ENABLED, &ctx->flags) &&\n\t    vp_reg_read(ctx, VP_SHADOW_UPDATE))\n\t\treturn false;\n\n\tbase = mixer_reg_read(ctx, MXR_CFG);\n\tshadow = mixer_reg_read(ctx, MXR_CFG_S);\n\tif (base != shadow)\n\t\treturn false;\n\n\tbase = mixer_reg_read(ctx, MXR_GRAPHIC_BASE(0));\n\tshadow = mixer_reg_read(ctx, MXR_GRAPHIC_BASE_S(0));\n\tif (base != shadow)\n\t\treturn false;\n\n\tbase = mixer_reg_read(ctx, MXR_GRAPHIC_BASE(1));\n\tshadow = mixer_reg_read(ctx, MXR_GRAPHIC_BASE_S(1));\n\tif (base != shadow)\n\t\treturn false;\n\n\treturn true;\n}\n\nstatic int mixer_wait_for_sync(struct mixer_context *ctx)\n{\n\tktime_t timeout = ktime_add_us(ktime_get(), 100000);\n\n\twhile (!mixer_is_synced(ctx)) {\n\t\tusleep_range(1000, 2000);\n\t\tif (ktime_compare(ktime_get(), timeout) > 0)\n\t\t\treturn -ETIMEDOUT;\n\t}\n\treturn 0;\n}\n\nstatic void mixer_disable_sync(struct mixer_context *ctx)\n{\n\tmixer_reg_writemask(ctx, MXR_STATUS, 0, MXR_STATUS_SYNC_ENABLE);\n}\n\nstatic void mixer_enable_sync(struct mixer_context *ctx)\n{\n\tif (ctx->mxr_ver == MXR_VER_16_0_33_0 ||\n\t    ctx->mxr_ver == MXR_VER_128_0_0_184)\n\t\tmixer_reg_writemask(ctx, MXR_CFG, ~0, MXR_CFG_LAYER_UPDATE);\n\tmixer_reg_writemask(ctx, MXR_STATUS, ~0, MXR_STATUS_SYNC_ENABLE);\n\tif (test_bit(MXR_BIT_VP_ENABLED, &ctx->flags))\n\t\tvp_reg_write(ctx, VP_SHADOW_UPDATE, VP_SHADOW_UPDATE_ENABLE);\n}\n\nstatic void mixer_cfg_scan(struct mixer_context *ctx, int width, int height)\n{\n\tu32 val;\n\n\t \n\tval = test_bit(MXR_BIT_INTERLACE, &ctx->flags) ?\n\t\tMXR_CFG_SCAN_INTERLACE : MXR_CFG_SCAN_PROGRESSIVE;\n\n\tif (ctx->mxr_ver == MXR_VER_128_0_0_184)\n\t\tmixer_reg_write(ctx, MXR_RESOLUTION,\n\t\t\tMXR_MXR_RES_HEIGHT(height) | MXR_MXR_RES_WIDTH(width));\n\telse\n\t\tval |= ctx->scan_value;\n\n\tmixer_reg_writemask(ctx, MXR_CFG, val, MXR_CFG_SCAN_MASK);\n}\n\nstatic void mixer_cfg_rgb_fmt(struct mixer_context *ctx, struct drm_display_mode *mode)\n{\n\tenum hdmi_quantization_range range = drm_default_rgb_quant_range(mode);\n\tu32 val;\n\n\tif (mode->vdisplay < 720) {\n\t\tval = MXR_CFG_RGB601;\n\t} else {\n\t\tval = MXR_CFG_RGB709;\n\n\t\t \n\t\tmixer_reg_write(ctx, MXR_CM_COEFF_Y,\n\t\t\tMXR_CSC_CT( 0.184,  0.614,  0.063) |\n\t\t\tMXR_CM_COEFF_RGB_FULL);\n\t\tmixer_reg_write(ctx, MXR_CM_COEFF_CB,\n\t\t\tMXR_CSC_CT(-0.102, -0.338,  0.440));\n\t\tmixer_reg_write(ctx, MXR_CM_COEFF_CR,\n\t\t\tMXR_CSC_CT( 0.440, -0.399, -0.040));\n\t}\n\n\tif (range == HDMI_QUANTIZATION_RANGE_FULL)\n\t\tval |= MXR_CFG_QUANT_RANGE_FULL;\n\telse\n\t\tval |= MXR_CFG_QUANT_RANGE_LIMITED;\n\n\tmixer_reg_writemask(ctx, MXR_CFG, val, MXR_CFG_RGB_FMT_MASK);\n}\n\nstatic void mixer_cfg_layer(struct mixer_context *ctx, unsigned int win,\n\t\t\t    unsigned int priority, bool enable)\n{\n\tu32 val = enable ? ~0 : 0;\n\n\tswitch (win) {\n\tcase 0:\n\t\tmixer_reg_writemask(ctx, MXR_CFG, val, MXR_CFG_GRP0_ENABLE);\n\t\tmixer_reg_writemask(ctx, MXR_LAYER_CFG,\n\t\t\t\t    MXR_LAYER_CFG_GRP0_VAL(priority),\n\t\t\t\t    MXR_LAYER_CFG_GRP0_MASK);\n\t\tbreak;\n\tcase 1:\n\t\tmixer_reg_writemask(ctx, MXR_CFG, val, MXR_CFG_GRP1_ENABLE);\n\t\tmixer_reg_writemask(ctx, MXR_LAYER_CFG,\n\t\t\t\t    MXR_LAYER_CFG_GRP1_VAL(priority),\n\t\t\t\t    MXR_LAYER_CFG_GRP1_MASK);\n\n\t\tbreak;\n\tcase VP_DEFAULT_WIN:\n\t\tif (test_bit(MXR_BIT_VP_ENABLED, &ctx->flags)) {\n\t\t\tvp_reg_writemask(ctx, VP_ENABLE, val, VP_ENABLE_ON);\n\t\t\tmixer_reg_writemask(ctx, MXR_CFG, val,\n\t\t\t\tMXR_CFG_VP_ENABLE);\n\t\t\tmixer_reg_writemask(ctx, MXR_LAYER_CFG,\n\t\t\t\t\t    MXR_LAYER_CFG_VP_VAL(priority),\n\t\t\t\t\t    MXR_LAYER_CFG_VP_MASK);\n\t\t}\n\t\tbreak;\n\t}\n}\n\nstatic void mixer_run(struct mixer_context *ctx)\n{\n\tmixer_reg_writemask(ctx, MXR_STATUS, ~0, MXR_STATUS_REG_RUN);\n}\n\nstatic void mixer_stop(struct mixer_context *ctx)\n{\n\tint timeout = 20;\n\n\tmixer_reg_writemask(ctx, MXR_STATUS, 0, MXR_STATUS_REG_RUN);\n\n\twhile (!(mixer_reg_read(ctx, MXR_STATUS) & MXR_STATUS_REG_IDLE) &&\n\t\t\t--timeout)\n\t\tusleep_range(10000, 12000);\n}\n\nstatic void mixer_commit(struct mixer_context *ctx)\n{\n\tstruct drm_display_mode *mode = &ctx->crtc->base.state->adjusted_mode;\n\n\tmixer_cfg_scan(ctx, mode->hdisplay, mode->vdisplay);\n\tmixer_cfg_rgb_fmt(ctx, mode);\n\tmixer_run(ctx);\n}\n\nstatic void vp_video_buffer(struct mixer_context *ctx,\n\t\t\t    struct exynos_drm_plane *plane)\n{\n\tstruct exynos_drm_plane_state *state =\n\t\t\t\tto_exynos_plane_state(plane->base.state);\n\tstruct drm_framebuffer *fb = state->base.fb;\n\tunsigned int priority = state->base.normalized_zpos + 1;\n\tunsigned long flags;\n\tdma_addr_t luma_addr[2], chroma_addr[2];\n\tbool is_tiled, is_nv21;\n\tu32 val;\n\n\tis_nv21 = (fb->format->format == DRM_FORMAT_NV21);\n\tis_tiled = (fb->modifier == DRM_FORMAT_MOD_SAMSUNG_64_32_TILE);\n\n\tluma_addr[0] = exynos_drm_fb_dma_addr(fb, 0);\n\tchroma_addr[0] = exynos_drm_fb_dma_addr(fb, 1);\n\n\tif (test_bit(MXR_BIT_INTERLACE, &ctx->flags)) {\n\t\tif (is_tiled) {\n\t\t\tluma_addr[1] = luma_addr[0] + 0x40;\n\t\t\tchroma_addr[1] = chroma_addr[0] + 0x40;\n\t\t} else {\n\t\t\tluma_addr[1] = luma_addr[0] + fb->pitches[0];\n\t\t\tchroma_addr[1] = chroma_addr[0] + fb->pitches[1];\n\t\t}\n\t} else {\n\t\tluma_addr[1] = 0;\n\t\tchroma_addr[1] = 0;\n\t}\n\n\tspin_lock_irqsave(&ctx->reg_slock, flags);\n\n\t \n\tval = (test_bit(MXR_BIT_INTERLACE, &ctx->flags) ? ~0 : 0);\n\tvp_reg_writemask(ctx, VP_MODE, val, VP_MODE_LINE_SKIP);\n\n\t \n\tval = (is_nv21 ? VP_MODE_NV21 : VP_MODE_NV12);\n\tval |= (is_tiled ? VP_MODE_MEM_TILED : VP_MODE_MEM_LINEAR);\n\tvp_reg_writemask(ctx, VP_MODE, val, VP_MODE_FMT_MASK);\n\n\t \n\tvp_reg_write(ctx, VP_IMG_SIZE_Y, VP_IMG_HSIZE(fb->pitches[0]) |\n\t\tVP_IMG_VSIZE(fb->height));\n\t \n\tvp_reg_write(ctx, VP_IMG_SIZE_C, VP_IMG_HSIZE(fb->pitches[1]) |\n\t\tVP_IMG_VSIZE(fb->height / 2));\n\n\tvp_reg_write(ctx, VP_SRC_WIDTH, state->src.w);\n\tvp_reg_write(ctx, VP_SRC_H_POSITION,\n\t\t\tVP_SRC_H_POSITION_VAL(state->src.x));\n\tvp_reg_write(ctx, VP_DST_WIDTH, state->crtc.w);\n\tvp_reg_write(ctx, VP_DST_H_POSITION, state->crtc.x);\n\n\tif (test_bit(MXR_BIT_INTERLACE, &ctx->flags)) {\n\t\tvp_reg_write(ctx, VP_SRC_HEIGHT, state->src.h / 2);\n\t\tvp_reg_write(ctx, VP_SRC_V_POSITION, state->src.y / 2);\n\t\tvp_reg_write(ctx, VP_DST_HEIGHT, state->crtc.h / 2);\n\t\tvp_reg_write(ctx, VP_DST_V_POSITION, state->crtc.y / 2);\n\t} else {\n\t\tvp_reg_write(ctx, VP_SRC_HEIGHT, state->src.h);\n\t\tvp_reg_write(ctx, VP_SRC_V_POSITION, state->src.y);\n\t\tvp_reg_write(ctx, VP_DST_HEIGHT, state->crtc.h);\n\t\tvp_reg_write(ctx, VP_DST_V_POSITION, state->crtc.y);\n\t}\n\n\tvp_reg_write(ctx, VP_H_RATIO, state->h_ratio);\n\tvp_reg_write(ctx, VP_V_RATIO, state->v_ratio);\n\n\tvp_reg_write(ctx, VP_ENDIAN_MODE, VP_ENDIAN_MODE_LITTLE);\n\n\t \n\tvp_reg_write(ctx, VP_TOP_Y_PTR, luma_addr[0]);\n\tvp_reg_write(ctx, VP_BOT_Y_PTR, luma_addr[1]);\n\tvp_reg_write(ctx, VP_TOP_C_PTR, chroma_addr[0]);\n\tvp_reg_write(ctx, VP_BOT_C_PTR, chroma_addr[1]);\n\n\tmixer_cfg_layer(ctx, plane->index, priority, true);\n\tmixer_cfg_vp_blend(ctx, state->base.alpha);\n\n\tspin_unlock_irqrestore(&ctx->reg_slock, flags);\n\n\tmixer_regs_dump(ctx);\n\tvp_regs_dump(ctx);\n}\n\nstatic void mixer_graph_buffer(struct mixer_context *ctx,\n\t\t\t       struct exynos_drm_plane *plane)\n{\n\tstruct exynos_drm_plane_state *state =\n\t\t\t\tto_exynos_plane_state(plane->base.state);\n\tstruct drm_framebuffer *fb = state->base.fb;\n\tunsigned int priority = state->base.normalized_zpos + 1;\n\tunsigned long flags;\n\tunsigned int win = plane->index;\n\tunsigned int x_ratio = 0, y_ratio = 0;\n\tunsigned int dst_x_offset, dst_y_offset;\n\tunsigned int pixel_alpha;\n\tdma_addr_t dma_addr;\n\tunsigned int fmt;\n\tu32 val;\n\n\tif (fb->format->has_alpha)\n\t\tpixel_alpha = state->base.pixel_blend_mode;\n\telse\n\t\tpixel_alpha = DRM_MODE_BLEND_PIXEL_NONE;\n\n\tswitch (fb->format->format) {\n\tcase DRM_FORMAT_XRGB4444:\n\tcase DRM_FORMAT_ARGB4444:\n\t\tfmt = MXR_FORMAT_ARGB4444;\n\t\tbreak;\n\n\tcase DRM_FORMAT_XRGB1555:\n\tcase DRM_FORMAT_ARGB1555:\n\t\tfmt = MXR_FORMAT_ARGB1555;\n\t\tbreak;\n\n\tcase DRM_FORMAT_RGB565:\n\t\tfmt = MXR_FORMAT_RGB565;\n\t\tbreak;\n\n\tcase DRM_FORMAT_XRGB8888:\n\tcase DRM_FORMAT_ARGB8888:\n\tdefault:\n\t\tfmt = MXR_FORMAT_ARGB8888;\n\t\tbreak;\n\t}\n\n\t \n\tx_ratio = state->h_ratio == (1 << 15);\n\ty_ratio = state->v_ratio == (1 << 15);\n\n\tdst_x_offset = state->crtc.x;\n\tdst_y_offset = state->crtc.y;\n\n\t \n\tdma_addr = exynos_drm_fb_dma_addr(fb, 0)\n\t\t+ (state->src.x * fb->format->cpp[0])\n\t\t+ (state->src.y * fb->pitches[0]);\n\n\tspin_lock_irqsave(&ctx->reg_slock, flags);\n\n\t \n\tmixer_reg_writemask(ctx, MXR_GRAPHIC_CFG(win),\n\t\tMXR_GRP_CFG_FORMAT_VAL(fmt), MXR_GRP_CFG_FORMAT_MASK);\n\n\t \n\tmixer_reg_write(ctx, MXR_GRAPHIC_SPAN(win),\n\t\t\tfb->pitches[0] / fb->format->cpp[0]);\n\n\tval  = MXR_GRP_WH_WIDTH(state->src.w);\n\tval |= MXR_GRP_WH_HEIGHT(state->src.h);\n\tval |= MXR_GRP_WH_H_SCALE(x_ratio);\n\tval |= MXR_GRP_WH_V_SCALE(y_ratio);\n\tmixer_reg_write(ctx, MXR_GRAPHIC_WH(win), val);\n\n\t \n\tval  = MXR_GRP_DXY_DX(dst_x_offset);\n\tval |= MXR_GRP_DXY_DY(dst_y_offset);\n\tmixer_reg_write(ctx, MXR_GRAPHIC_DXY(win), val);\n\n\t \n\tmixer_reg_write(ctx, MXR_GRAPHIC_BASE(win), dma_addr);\n\n\tmixer_cfg_layer(ctx, win, priority, true);\n\tmixer_cfg_gfx_blend(ctx, win, pixel_alpha, state->base.alpha);\n\n\tspin_unlock_irqrestore(&ctx->reg_slock, flags);\n\n\tmixer_regs_dump(ctx);\n}\n\nstatic void vp_win_reset(struct mixer_context *ctx)\n{\n\tunsigned int tries = 100;\n\n\tvp_reg_write(ctx, VP_SRESET, VP_SRESET_PROCESSING);\n\twhile (--tries) {\n\t\t \n\t\tif (~vp_reg_read(ctx, VP_SRESET) & VP_SRESET_PROCESSING)\n\t\t\tbreak;\n\t\tmdelay(10);\n\t}\n\tWARN(tries == 0, \"failed to reset Video Processor\\n\");\n}\n\nstatic void mixer_win_reset(struct mixer_context *ctx)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&ctx->reg_slock, flags);\n\n\tmixer_reg_writemask(ctx, MXR_CFG, MXR_CFG_DST_HDMI, MXR_CFG_DST_MASK);\n\n\t \n\tmixer_reg_writemask(ctx, MXR_CFG, MXR_CFG_OUT_RGB888, MXR_CFG_OUT_MASK);\n\n\t \n\tmixer_reg_writemask(ctx, MXR_STATUS, MXR_STATUS_16_BURST,\n\t\tMXR_STATUS_BURST_MASK);\n\n\t \n\tmixer_reg_write(ctx, MXR_LAYER_CFG, 0);\n\n\t \n\tmixer_reg_write(ctx, MXR_BG_COLOR0, MXR_YCBCR_VAL(0, 128, 128));\n\tmixer_reg_write(ctx, MXR_BG_COLOR1, MXR_YCBCR_VAL(0, 128, 128));\n\tmixer_reg_write(ctx, MXR_BG_COLOR2, MXR_YCBCR_VAL(0, 128, 128));\n\n\tif (test_bit(MXR_BIT_VP_ENABLED, &ctx->flags)) {\n\t\t \n\t\tvp_win_reset(ctx);\n\t\tvp_default_filter(ctx);\n\t}\n\n\t \n\tmixer_reg_writemask(ctx, MXR_CFG, 0, MXR_CFG_GRP0_ENABLE);\n\tmixer_reg_writemask(ctx, MXR_CFG, 0, MXR_CFG_GRP1_ENABLE);\n\tif (test_bit(MXR_BIT_VP_ENABLED, &ctx->flags))\n\t\tmixer_reg_writemask(ctx, MXR_CFG, 0, MXR_CFG_VP_ENABLE);\n\n\t \n\tmixer_reg_write(ctx, MXR_GRAPHIC_SXY(0), 0);\n\tmixer_reg_write(ctx, MXR_GRAPHIC_SXY(1), 0);\n\n\tspin_unlock_irqrestore(&ctx->reg_slock, flags);\n}\n\nstatic irqreturn_t mixer_irq_handler(int irq, void *arg)\n{\n\tstruct mixer_context *ctx = arg;\n\tu32 val;\n\n\tspin_lock(&ctx->reg_slock);\n\n\t \n\tval = mixer_reg_read(ctx, MXR_INT_STATUS);\n\n\t \n\tif (val & MXR_INT_STATUS_VSYNC) {\n\t\t \n\t\tval |= MXR_INT_CLEAR_VSYNC;\n\t\tval &= ~MXR_INT_STATUS_VSYNC;\n\n\t\t \n\t\tif (test_bit(MXR_BIT_INTERLACE, &ctx->flags)\n\t\t    && !mixer_is_synced(ctx))\n\t\t\tgoto out;\n\n\t\tdrm_crtc_handle_vblank(&ctx->crtc->base);\n\t}\n\nout:\n\t \n\tmixer_reg_write(ctx, MXR_INT_STATUS, val);\n\n\tspin_unlock(&ctx->reg_slock);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int mixer_resources_init(struct mixer_context *mixer_ctx)\n{\n\tstruct device *dev = &mixer_ctx->pdev->dev;\n\tstruct resource *res;\n\tint ret;\n\n\tspin_lock_init(&mixer_ctx->reg_slock);\n\n\tmixer_ctx->mixer = devm_clk_get(dev, \"mixer\");\n\tif (IS_ERR(mixer_ctx->mixer)) {\n\t\tdev_err(dev, \"failed to get clock 'mixer'\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tmixer_ctx->hdmi = devm_clk_get(dev, \"hdmi\");\n\tif (IS_ERR(mixer_ctx->hdmi)) {\n\t\tdev_err(dev, \"failed to get clock 'hdmi'\\n\");\n\t\treturn PTR_ERR(mixer_ctx->hdmi);\n\t}\n\n\tmixer_ctx->sclk_hdmi = devm_clk_get(dev, \"sclk_hdmi\");\n\tif (IS_ERR(mixer_ctx->sclk_hdmi)) {\n\t\tdev_err(dev, \"failed to get clock 'sclk_hdmi'\\n\");\n\t\treturn -ENODEV;\n\t}\n\tres = platform_get_resource(mixer_ctx->pdev, IORESOURCE_MEM, 0);\n\tif (res == NULL) {\n\t\tdev_err(dev, \"get memory resource failed.\\n\");\n\t\treturn -ENXIO;\n\t}\n\n\tmixer_ctx->mixer_regs = devm_ioremap(dev, res->start,\n\t\t\t\t\t\t\tresource_size(res));\n\tif (mixer_ctx->mixer_regs == NULL) {\n\t\tdev_err(dev, \"register mapping failed.\\n\");\n\t\treturn -ENXIO;\n\t}\n\n\tret = platform_get_irq(mixer_ctx->pdev, 0);\n\tif (ret < 0)\n\t\treturn ret;\n\tmixer_ctx->irq = ret;\n\n\tret = devm_request_irq(dev, mixer_ctx->irq, mixer_irq_handler,\n\t\t\t       0, \"drm_mixer\", mixer_ctx);\n\tif (ret) {\n\t\tdev_err(dev, \"request interrupt failed.\\n\");\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int vp_resources_init(struct mixer_context *mixer_ctx)\n{\n\tstruct device *dev = &mixer_ctx->pdev->dev;\n\tstruct resource *res;\n\n\tmixer_ctx->vp = devm_clk_get(dev, \"vp\");\n\tif (IS_ERR(mixer_ctx->vp)) {\n\t\tdev_err(dev, \"failed to get clock 'vp'\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tif (test_bit(MXR_BIT_HAS_SCLK, &mixer_ctx->flags)) {\n\t\tmixer_ctx->sclk_mixer = devm_clk_get(dev, \"sclk_mixer\");\n\t\tif (IS_ERR(mixer_ctx->sclk_mixer)) {\n\t\t\tdev_err(dev, \"failed to get clock 'sclk_mixer'\\n\");\n\t\t\treturn -ENODEV;\n\t\t}\n\t\tmixer_ctx->mout_mixer = devm_clk_get(dev, \"mout_mixer\");\n\t\tif (IS_ERR(mixer_ctx->mout_mixer)) {\n\t\t\tdev_err(dev, \"failed to get clock 'mout_mixer'\\n\");\n\t\t\treturn -ENODEV;\n\t\t}\n\n\t\tif (mixer_ctx->sclk_hdmi && mixer_ctx->mout_mixer)\n\t\t\tclk_set_parent(mixer_ctx->mout_mixer,\n\t\t\t\t       mixer_ctx->sclk_hdmi);\n\t}\n\n\tres = platform_get_resource(mixer_ctx->pdev, IORESOURCE_MEM, 1);\n\tif (res == NULL) {\n\t\tdev_err(dev, \"get memory resource failed.\\n\");\n\t\treturn -ENXIO;\n\t}\n\n\tmixer_ctx->vp_regs = devm_ioremap(dev, res->start,\n\t\t\t\t\t\t\tresource_size(res));\n\tif (mixer_ctx->vp_regs == NULL) {\n\t\tdev_err(dev, \"register mapping failed.\\n\");\n\t\treturn -ENXIO;\n\t}\n\n\treturn 0;\n}\n\nstatic int mixer_initialize(struct mixer_context *mixer_ctx,\n\t\t\tstruct drm_device *drm_dev)\n{\n\tint ret;\n\n\tmixer_ctx->drm_dev = drm_dev;\n\n\t \n\tret = mixer_resources_init(mixer_ctx);\n\tif (ret) {\n\t\tDRM_DEV_ERROR(mixer_ctx->dev,\n\t\t\t      \"mixer_resources_init failed ret=%d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tif (test_bit(MXR_BIT_VP_ENABLED, &mixer_ctx->flags)) {\n\t\t \n\t\tret = vp_resources_init(mixer_ctx);\n\t\tif (ret) {\n\t\t\tDRM_DEV_ERROR(mixer_ctx->dev,\n\t\t\t\t      \"vp_resources_init failed ret=%d\\n\", ret);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn exynos_drm_register_dma(drm_dev, mixer_ctx->dev,\n\t\t\t\t       &mixer_ctx->dma_priv);\n}\n\nstatic void mixer_ctx_remove(struct mixer_context *mixer_ctx)\n{\n\texynos_drm_unregister_dma(mixer_ctx->drm_dev, mixer_ctx->dev,\n\t\t\t\t  &mixer_ctx->dma_priv);\n}\n\nstatic int mixer_enable_vblank(struct exynos_drm_crtc *crtc)\n{\n\tstruct mixer_context *mixer_ctx = crtc->ctx;\n\n\t__set_bit(MXR_BIT_VSYNC, &mixer_ctx->flags);\n\tif (!test_bit(MXR_BIT_POWERED, &mixer_ctx->flags))\n\t\treturn 0;\n\n\t \n\tmixer_reg_writemask(mixer_ctx, MXR_INT_STATUS, ~0, MXR_INT_CLEAR_VSYNC);\n\tmixer_reg_writemask(mixer_ctx, MXR_INT_EN, ~0, MXR_INT_EN_VSYNC);\n\n\treturn 0;\n}\n\nstatic void mixer_disable_vblank(struct exynos_drm_crtc *crtc)\n{\n\tstruct mixer_context *mixer_ctx = crtc->ctx;\n\n\t__clear_bit(MXR_BIT_VSYNC, &mixer_ctx->flags);\n\n\tif (!test_bit(MXR_BIT_POWERED, &mixer_ctx->flags))\n\t\treturn;\n\n\t \n\tmixer_reg_writemask(mixer_ctx, MXR_INT_STATUS, ~0, MXR_INT_CLEAR_VSYNC);\n\tmixer_reg_writemask(mixer_ctx, MXR_INT_EN, 0, MXR_INT_EN_VSYNC);\n}\n\nstatic void mixer_atomic_begin(struct exynos_drm_crtc *crtc)\n{\n\tstruct mixer_context *ctx = crtc->ctx;\n\n\tif (!test_bit(MXR_BIT_POWERED, &ctx->flags))\n\t\treturn;\n\n\tif (mixer_wait_for_sync(ctx))\n\t\tdev_err(ctx->dev, \"timeout waiting for VSYNC\\n\");\n\tmixer_disable_sync(ctx);\n}\n\nstatic void mixer_update_plane(struct exynos_drm_crtc *crtc,\n\t\t\t       struct exynos_drm_plane *plane)\n{\n\tstruct mixer_context *mixer_ctx = crtc->ctx;\n\n\tDRM_DEV_DEBUG_KMS(mixer_ctx->dev, \"win: %d\\n\", plane->index);\n\n\tif (!test_bit(MXR_BIT_POWERED, &mixer_ctx->flags))\n\t\treturn;\n\n\tif (plane->index == VP_DEFAULT_WIN)\n\t\tvp_video_buffer(mixer_ctx, plane);\n\telse\n\t\tmixer_graph_buffer(mixer_ctx, plane);\n}\n\nstatic void mixer_disable_plane(struct exynos_drm_crtc *crtc,\n\t\t\t\tstruct exynos_drm_plane *plane)\n{\n\tstruct mixer_context *mixer_ctx = crtc->ctx;\n\tunsigned long flags;\n\n\tDRM_DEV_DEBUG_KMS(mixer_ctx->dev, \"win: %d\\n\", plane->index);\n\n\tif (!test_bit(MXR_BIT_POWERED, &mixer_ctx->flags))\n\t\treturn;\n\n\tspin_lock_irqsave(&mixer_ctx->reg_slock, flags);\n\tmixer_cfg_layer(mixer_ctx, plane->index, 0, false);\n\tspin_unlock_irqrestore(&mixer_ctx->reg_slock, flags);\n}\n\nstatic void mixer_atomic_flush(struct exynos_drm_crtc *crtc)\n{\n\tstruct mixer_context *mixer_ctx = crtc->ctx;\n\n\tif (!test_bit(MXR_BIT_POWERED, &mixer_ctx->flags))\n\t\treturn;\n\n\tmixer_enable_sync(mixer_ctx);\n\texynos_crtc_handle_event(crtc);\n}\n\nstatic void mixer_atomic_enable(struct exynos_drm_crtc *crtc)\n{\n\tstruct mixer_context *ctx = crtc->ctx;\n\tint ret;\n\n\tif (test_bit(MXR_BIT_POWERED, &ctx->flags))\n\t\treturn;\n\n\tret = pm_runtime_resume_and_get(ctx->dev);\n\tif (ret < 0) {\n\t\tdev_err(ctx->dev, \"failed to enable MIXER device.\\n\");\n\t\treturn;\n\t}\n\n\texynos_drm_pipe_clk_enable(crtc, true);\n\n\tmixer_disable_sync(ctx);\n\n\tmixer_reg_writemask(ctx, MXR_STATUS, ~0, MXR_STATUS_SOFT_RESET);\n\n\tif (test_bit(MXR_BIT_VSYNC, &ctx->flags)) {\n\t\tmixer_reg_writemask(ctx, MXR_INT_STATUS, ~0,\n\t\t\t\t\tMXR_INT_CLEAR_VSYNC);\n\t\tmixer_reg_writemask(ctx, MXR_INT_EN, ~0, MXR_INT_EN_VSYNC);\n\t}\n\tmixer_win_reset(ctx);\n\n\tmixer_commit(ctx);\n\n\tmixer_enable_sync(ctx);\n\n\tset_bit(MXR_BIT_POWERED, &ctx->flags);\n}\n\nstatic void mixer_atomic_disable(struct exynos_drm_crtc *crtc)\n{\n\tstruct mixer_context *ctx = crtc->ctx;\n\tint i;\n\n\tif (!test_bit(MXR_BIT_POWERED, &ctx->flags))\n\t\treturn;\n\n\tmixer_stop(ctx);\n\tmixer_regs_dump(ctx);\n\n\tfor (i = 0; i < MIXER_WIN_NR; i++)\n\t\tmixer_disable_plane(crtc, &ctx->planes[i]);\n\n\texynos_drm_pipe_clk_enable(crtc, false);\n\n\tpm_runtime_put(ctx->dev);\n\n\tclear_bit(MXR_BIT_POWERED, &ctx->flags);\n}\n\nstatic enum drm_mode_status mixer_mode_valid(struct exynos_drm_crtc *crtc,\n\t\tconst struct drm_display_mode *mode)\n{\n\tstruct mixer_context *ctx = crtc->ctx;\n\tu32 w = mode->hdisplay, h = mode->vdisplay;\n\n\tDRM_DEV_DEBUG_KMS(ctx->dev, \"xres=%d, yres=%d, refresh=%d, intl=%d\\n\",\n\t\t\t  w, h, drm_mode_vrefresh(mode),\n\t\t\t  !!(mode->flags & DRM_MODE_FLAG_INTERLACE));\n\n\tif (ctx->mxr_ver == MXR_VER_128_0_0_184)\n\t\treturn MODE_OK;\n\n\tif ((w >= 464 && w <= 720 && h >= 261 && h <= 576) ||\n\t    (w >= 1024 && w <= 1280 && h >= 576 && h <= 720) ||\n\t    (w >= 1664 && w <= 1920 && h >= 936 && h <= 1080))\n\t\treturn MODE_OK;\n\n\tif ((w == 1024 && h == 768) ||\n\t    (w == 1366 && h == 768) ||\n\t    (w == 1280 && h == 1024))\n\t\treturn MODE_OK;\n\n\treturn MODE_BAD;\n}\n\nstatic bool mixer_mode_fixup(struct exynos_drm_crtc *crtc,\n\t\t   const struct drm_display_mode *mode,\n\t\t   struct drm_display_mode *adjusted_mode)\n{\n\tstruct mixer_context *ctx = crtc->ctx;\n\tint width = mode->hdisplay, height = mode->vdisplay, i;\n\n\tstatic const struct {\n\t\tint hdisplay, vdisplay, htotal, vtotal, scan_val;\n\t} modes[] = {\n\t\t{ 720, 480, 858, 525, MXR_CFG_SCAN_NTSC | MXR_CFG_SCAN_SD },\n\t\t{ 720, 576, 864, 625, MXR_CFG_SCAN_PAL | MXR_CFG_SCAN_SD },\n\t\t{ 1280, 720, 1650, 750, MXR_CFG_SCAN_HD_720 | MXR_CFG_SCAN_HD },\n\t\t{ 1920, 1080, 2200, 1125, MXR_CFG_SCAN_HD_1080 |\n\t\t\t\t\t\tMXR_CFG_SCAN_HD }\n\t};\n\n\tif (mode->flags & DRM_MODE_FLAG_INTERLACE)\n\t\t__set_bit(MXR_BIT_INTERLACE, &ctx->flags);\n\telse\n\t\t__clear_bit(MXR_BIT_INTERLACE, &ctx->flags);\n\n\tif (ctx->mxr_ver == MXR_VER_128_0_0_184)\n\t\treturn true;\n\n\tfor (i = 0; i < ARRAY_SIZE(modes); ++i)\n\t\tif (width <= modes[i].hdisplay && height <= modes[i].vdisplay) {\n\t\t\tctx->scan_value = modes[i].scan_val;\n\t\t\tif (width < modes[i].hdisplay ||\n\t\t\t    height < modes[i].vdisplay) {\n\t\t\t\tadjusted_mode->hdisplay = modes[i].hdisplay;\n\t\t\t\tadjusted_mode->hsync_start = modes[i].hdisplay;\n\t\t\t\tadjusted_mode->hsync_end = modes[i].htotal;\n\t\t\t\tadjusted_mode->htotal = modes[i].htotal;\n\t\t\t\tadjusted_mode->vdisplay = modes[i].vdisplay;\n\t\t\t\tadjusted_mode->vsync_start = modes[i].vdisplay;\n\t\t\t\tadjusted_mode->vsync_end = modes[i].vtotal;\n\t\t\t\tadjusted_mode->vtotal = modes[i].vtotal;\n\t\t\t}\n\n\t\t\treturn true;\n\t\t}\n\n\treturn false;\n}\n\nstatic const struct exynos_drm_crtc_ops mixer_crtc_ops = {\n\t.atomic_enable\t\t= mixer_atomic_enable,\n\t.atomic_disable\t\t= mixer_atomic_disable,\n\t.enable_vblank\t\t= mixer_enable_vblank,\n\t.disable_vblank\t\t= mixer_disable_vblank,\n\t.atomic_begin\t\t= mixer_atomic_begin,\n\t.update_plane\t\t= mixer_update_plane,\n\t.disable_plane\t\t= mixer_disable_plane,\n\t.atomic_flush\t\t= mixer_atomic_flush,\n\t.mode_valid\t\t= mixer_mode_valid,\n\t.mode_fixup\t\t= mixer_mode_fixup,\n};\n\nstatic const struct mixer_drv_data exynos5420_mxr_drv_data = {\n\t.version = MXR_VER_128_0_0_184,\n\t.is_vp_enabled = 0,\n};\n\nstatic const struct mixer_drv_data exynos5250_mxr_drv_data = {\n\t.version = MXR_VER_16_0_33_0,\n\t.is_vp_enabled = 0,\n};\n\nstatic const struct mixer_drv_data exynos4212_mxr_drv_data = {\n\t.version = MXR_VER_0_0_0_16,\n\t.is_vp_enabled = 1,\n};\n\nstatic const struct mixer_drv_data exynos4210_mxr_drv_data = {\n\t.version = MXR_VER_0_0_0_16,\n\t.is_vp_enabled = 1,\n\t.has_sclk = 1,\n};\n\nstatic const struct of_device_id mixer_match_types[] = {\n\t{\n\t\t.compatible = \"samsung,exynos4210-mixer\",\n\t\t.data\t= &exynos4210_mxr_drv_data,\n\t}, {\n\t\t.compatible = \"samsung,exynos4212-mixer\",\n\t\t.data\t= &exynos4212_mxr_drv_data,\n\t}, {\n\t\t.compatible = \"samsung,exynos5-mixer\",\n\t\t.data\t= &exynos5250_mxr_drv_data,\n\t}, {\n\t\t.compatible = \"samsung,exynos5250-mixer\",\n\t\t.data\t= &exynos5250_mxr_drv_data,\n\t}, {\n\t\t.compatible = \"samsung,exynos5420-mixer\",\n\t\t.data\t= &exynos5420_mxr_drv_data,\n\t}, {\n\t\t \n\t}\n};\nMODULE_DEVICE_TABLE(of, mixer_match_types);\n\nstatic int mixer_bind(struct device *dev, struct device *manager, void *data)\n{\n\tstruct mixer_context *ctx = dev_get_drvdata(dev);\n\tstruct drm_device *drm_dev = data;\n\tstruct exynos_drm_plane *exynos_plane;\n\tunsigned int i;\n\tint ret;\n\n\tret = mixer_initialize(ctx, drm_dev);\n\tif (ret)\n\t\treturn ret;\n\n\tfor (i = 0; i < MIXER_WIN_NR; i++) {\n\t\tif (i == VP_DEFAULT_WIN && !test_bit(MXR_BIT_VP_ENABLED,\n\t\t\t\t\t\t     &ctx->flags))\n\t\t\tcontinue;\n\n\t\tret = exynos_plane_init(drm_dev, &ctx->planes[i], i,\n\t\t\t\t\t&plane_configs[i]);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\texynos_plane = &ctx->planes[DEFAULT_WIN];\n\tctx->crtc = exynos_drm_crtc_create(drm_dev, &exynos_plane->base,\n\t\t\tEXYNOS_DISPLAY_TYPE_HDMI, &mixer_crtc_ops, ctx);\n\tif (IS_ERR(ctx->crtc)) {\n\t\tmixer_ctx_remove(ctx);\n\t\tret = PTR_ERR(ctx->crtc);\n\t\tgoto free_ctx;\n\t}\n\n\treturn 0;\n\nfree_ctx:\n\tdevm_kfree(dev, ctx);\n\treturn ret;\n}\n\nstatic void mixer_unbind(struct device *dev, struct device *master, void *data)\n{\n\tstruct mixer_context *ctx = dev_get_drvdata(dev);\n\n\tmixer_ctx_remove(ctx);\n}\n\nstatic const struct component_ops mixer_component_ops = {\n\t.bind\t= mixer_bind,\n\t.unbind\t= mixer_unbind,\n};\n\nstatic int mixer_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tconst struct mixer_drv_data *drv;\n\tstruct mixer_context *ctx;\n\tint ret;\n\n\tctx = devm_kzalloc(&pdev->dev, sizeof(*ctx), GFP_KERNEL);\n\tif (!ctx) {\n\t\tDRM_DEV_ERROR(dev, \"failed to alloc mixer context.\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tdrv = of_device_get_match_data(dev);\n\n\tctx->pdev = pdev;\n\tctx->dev = dev;\n\tctx->mxr_ver = drv->version;\n\n\tif (drv->is_vp_enabled)\n\t\t__set_bit(MXR_BIT_VP_ENABLED, &ctx->flags);\n\tif (drv->has_sclk)\n\t\t__set_bit(MXR_BIT_HAS_SCLK, &ctx->flags);\n\n\tplatform_set_drvdata(pdev, ctx);\n\n\tpm_runtime_enable(dev);\n\n\tret = component_add(&pdev->dev, &mixer_component_ops);\n\tif (ret)\n\t\tpm_runtime_disable(dev);\n\n\treturn ret;\n}\n\nstatic int mixer_remove(struct platform_device *pdev)\n{\n\tpm_runtime_disable(&pdev->dev);\n\n\tcomponent_del(&pdev->dev, &mixer_component_ops);\n\n\treturn 0;\n}\n\nstatic int __maybe_unused exynos_mixer_suspend(struct device *dev)\n{\n\tstruct mixer_context *ctx = dev_get_drvdata(dev);\n\n\tclk_disable_unprepare(ctx->hdmi);\n\tclk_disable_unprepare(ctx->mixer);\n\tif (test_bit(MXR_BIT_VP_ENABLED, &ctx->flags)) {\n\t\tclk_disable_unprepare(ctx->vp);\n\t\tif (test_bit(MXR_BIT_HAS_SCLK, &ctx->flags))\n\t\t\tclk_disable_unprepare(ctx->sclk_mixer);\n\t}\n\n\treturn 0;\n}\n\nstatic int __maybe_unused exynos_mixer_resume(struct device *dev)\n{\n\tstruct mixer_context *ctx = dev_get_drvdata(dev);\n\tint ret;\n\n\tret = clk_prepare_enable(ctx->mixer);\n\tif (ret < 0) {\n\t\tDRM_DEV_ERROR(ctx->dev,\n\t\t\t      \"Failed to prepare_enable the mixer clk [%d]\\n\",\n\t\t\t      ret);\n\t\treturn ret;\n\t}\n\tret = clk_prepare_enable(ctx->hdmi);\n\tif (ret < 0) {\n\t\tDRM_DEV_ERROR(dev,\n\t\t\t      \"Failed to prepare_enable the hdmi clk [%d]\\n\",\n\t\t\t      ret);\n\t\treturn ret;\n\t}\n\tif (test_bit(MXR_BIT_VP_ENABLED, &ctx->flags)) {\n\t\tret = clk_prepare_enable(ctx->vp);\n\t\tif (ret < 0) {\n\t\t\tDRM_DEV_ERROR(dev,\n\t\t\t\t      \"Failed to prepare_enable the vp clk [%d]\\n\",\n\t\t\t\t      ret);\n\t\t\treturn ret;\n\t\t}\n\t\tif (test_bit(MXR_BIT_HAS_SCLK, &ctx->flags)) {\n\t\t\tret = clk_prepare_enable(ctx->sclk_mixer);\n\t\t\tif (ret < 0) {\n\t\t\t\tDRM_DEV_ERROR(dev,\n\t\t\t\t\t   \"Failed to prepare_enable the \" \\\n\t\t\t\t\t   \"sclk_mixer clk [%d]\\n\",\n\t\t\t\t\t   ret);\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic const struct dev_pm_ops exynos_mixer_pm_ops = {\n\tSET_RUNTIME_PM_OPS(exynos_mixer_suspend, exynos_mixer_resume, NULL)\n\tSET_SYSTEM_SLEEP_PM_OPS(pm_runtime_force_suspend,\n\t\t\t\tpm_runtime_force_resume)\n};\n\nstruct platform_driver mixer_driver = {\n\t.driver = {\n\t\t.name = \"exynos-mixer\",\n\t\t.owner = THIS_MODULE,\n\t\t.pm = &exynos_mixer_pm_ops,\n\t\t.of_match_table = mixer_match_types,\n\t},\n\t.probe = mixer_probe,\n\t.remove = mixer_remove,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}