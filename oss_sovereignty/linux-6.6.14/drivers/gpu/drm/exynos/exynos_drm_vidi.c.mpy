{
  "module_name": "exynos_drm_vidi.c",
  "hash_id": "b87b9bb52b17a33ff8c3be9ed8e2926bbe13f573bbb274fa8a525a09e4814df3",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/exynos/exynos_drm_vidi.c",
  "human_readable_source": "\n \n\n#include <linux/component.h>\n#include <linux/kernel.h>\n#include <linux/platform_device.h>\n#include <linux/timer.h>\n\n#include <drm/drm_atomic_helper.h>\n#include <drm/drm_edid.h>\n#include <drm/drm_framebuffer.h>\n#include <drm/drm_probe_helper.h>\n#include <drm/drm_simple_kms_helper.h>\n#include <drm/drm_vblank.h>\n#include <drm/exynos_drm.h>\n\n#include \"exynos_drm_crtc.h\"\n#include \"exynos_drm_drv.h\"\n#include \"exynos_drm_fb.h\"\n#include \"exynos_drm_plane.h\"\n#include \"exynos_drm_vidi.h\"\n\n \n#define VIDI_REFRESH_TIME (1000 / 50)\n\n \n#define WINDOWS_NR\t\t3\n\n#define ctx_from_connector(c)\tcontainer_of(c, struct vidi_context, \\\n\t\t\t\t\tconnector)\n\nstruct vidi_context {\n\tstruct drm_encoder\t\tencoder;\n\tstruct drm_device\t\t*drm_dev;\n\tstruct device\t\t\t*dev;\n\tstruct exynos_drm_crtc\t\t*crtc;\n\tstruct drm_connector\t\tconnector;\n\tstruct exynos_drm_plane\t\tplanes[WINDOWS_NR];\n\tstruct edid\t\t\t*raw_edid;\n\tunsigned int\t\t\tclkdiv;\n\tunsigned int\t\t\tconnected;\n\tbool\t\t\t\tsuspended;\n\tstruct timer_list\t\ttimer;\n\tstruct mutex\t\t\tlock;\n};\n\nstatic inline struct vidi_context *encoder_to_vidi(struct drm_encoder *e)\n{\n\treturn container_of(e, struct vidi_context, encoder);\n}\n\nstatic const char fake_edid_info[] = {\n\t0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x4c, 0x2d, 0x05, 0x05,\n\t0x00, 0x00, 0x00, 0x00, 0x30, 0x12, 0x01, 0x03, 0x80, 0x10, 0x09, 0x78,\n\t0x0a, 0xee, 0x91, 0xa3, 0x54, 0x4c, 0x99, 0x26, 0x0f, 0x50, 0x54, 0xbd,\n\t0xee, 0x00, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,\n\t0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x66, 0x21, 0x50, 0xb0, 0x51, 0x00,\n\t0x1b, 0x30, 0x40, 0x70, 0x36, 0x00, 0xa0, 0x5a, 0x00, 0x00, 0x00, 0x1e,\n\t0x01, 0x1d, 0x00, 0x72, 0x51, 0xd0, 0x1e, 0x20, 0x6e, 0x28, 0x55, 0x00,\n\t0xa0, 0x5a, 0x00, 0x00, 0x00, 0x1e, 0x00, 0x00, 0x00, 0xfd, 0x00, 0x18,\n\t0x4b, 0x1a, 0x44, 0x17, 0x00, 0x0a, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,\n\t0x00, 0x00, 0x00, 0xfc, 0x00, 0x53, 0x41, 0x4d, 0x53, 0x55, 0x4e, 0x47,\n\t0x0a, 0x20, 0x20, 0x20, 0x20, 0x20, 0x01, 0xbc, 0x02, 0x03, 0x1e, 0xf1,\n\t0x46, 0x84, 0x05, 0x03, 0x10, 0x20, 0x22, 0x23, 0x09, 0x07, 0x07, 0x83,\n\t0x01, 0x00, 0x00, 0xe2, 0x00, 0x0f, 0x67, 0x03, 0x0c, 0x00, 0x10, 0x00,\n\t0xb8, 0x2d, 0x01, 0x1d, 0x80, 0x18, 0x71, 0x1c, 0x16, 0x20, 0x58, 0x2c,\n\t0x25, 0x00, 0xa0, 0x5a, 0x00, 0x00, 0x00, 0x9e, 0x8c, 0x0a, 0xd0, 0x8a,\n\t0x20, 0xe0, 0x2d, 0x10, 0x10, 0x3e, 0x96, 0x00, 0xa0, 0x5a, 0x00, 0x00,\n\t0x00, 0x18, 0x02, 0x3a, 0x80, 0x18, 0x71, 0x38, 0x2d, 0x40, 0x58, 0x2c,\n\t0x45, 0x00, 0xa0, 0x5a, 0x00, 0x00, 0x00, 0x1e, 0x00, 0x00, 0x00, 0x00,\n\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n\t0x00, 0x00, 0x00, 0x06\n};\n\nstatic const uint32_t formats[] = {\n\tDRM_FORMAT_XRGB8888,\n\tDRM_FORMAT_ARGB8888,\n\tDRM_FORMAT_NV12,\n};\n\nstatic const enum drm_plane_type vidi_win_types[WINDOWS_NR] = {\n\tDRM_PLANE_TYPE_PRIMARY,\n\tDRM_PLANE_TYPE_OVERLAY,\n\tDRM_PLANE_TYPE_CURSOR,\n};\n\nstatic int vidi_enable_vblank(struct exynos_drm_crtc *crtc)\n{\n\tstruct vidi_context *ctx = crtc->ctx;\n\n\tif (ctx->suspended)\n\t\treturn -EPERM;\n\n\tmod_timer(&ctx->timer,\n\t\tjiffies + msecs_to_jiffies(VIDI_REFRESH_TIME) - 1);\n\n\treturn 0;\n}\n\nstatic void vidi_disable_vblank(struct exynos_drm_crtc *crtc)\n{\n}\n\nstatic void vidi_update_plane(struct exynos_drm_crtc *crtc,\n\t\t\t      struct exynos_drm_plane *plane)\n{\n\tstruct drm_plane_state *state = plane->base.state;\n\tstruct vidi_context *ctx = crtc->ctx;\n\tdma_addr_t addr;\n\n\tif (ctx->suspended)\n\t\treturn;\n\n\taddr = exynos_drm_fb_dma_addr(state->fb, 0);\n\tDRM_DEV_DEBUG_KMS(ctx->dev, \"dma_addr = %pad\\n\", &addr);\n}\n\nstatic void vidi_atomic_enable(struct exynos_drm_crtc *crtc)\n{\n\tstruct vidi_context *ctx = crtc->ctx;\n\n\tmutex_lock(&ctx->lock);\n\n\tctx->suspended = false;\n\n\tmutex_unlock(&ctx->lock);\n\n\tdrm_crtc_vblank_on(&crtc->base);\n}\n\nstatic void vidi_atomic_disable(struct exynos_drm_crtc *crtc)\n{\n\tstruct vidi_context *ctx = crtc->ctx;\n\n\tdrm_crtc_vblank_off(&crtc->base);\n\n\tmutex_lock(&ctx->lock);\n\n\tctx->suspended = true;\n\n\tmutex_unlock(&ctx->lock);\n}\n\nstatic const struct exynos_drm_crtc_ops vidi_crtc_ops = {\n\t.atomic_enable = vidi_atomic_enable,\n\t.atomic_disable = vidi_atomic_disable,\n\t.enable_vblank = vidi_enable_vblank,\n\t.disable_vblank = vidi_disable_vblank,\n\t.update_plane = vidi_update_plane,\n\t.atomic_flush = exynos_crtc_handle_event,\n};\n\nstatic void vidi_fake_vblank_timer(struct timer_list *t)\n{\n\tstruct vidi_context *ctx = from_timer(ctx, t, timer);\n\n\tif (drm_crtc_handle_vblank(&ctx->crtc->base))\n\t\tmod_timer(&ctx->timer,\n\t\t\tjiffies + msecs_to_jiffies(VIDI_REFRESH_TIME) - 1);\n}\n\nstatic ssize_t vidi_show_connection(struct device *dev,\n\t\t\t\tstruct device_attribute *attr, char *buf)\n{\n\tstruct vidi_context *ctx = dev_get_drvdata(dev);\n\tint rc;\n\n\tmutex_lock(&ctx->lock);\n\n\trc = sprintf(buf, \"%d\\n\", ctx->connected);\n\n\tmutex_unlock(&ctx->lock);\n\n\treturn rc;\n}\n\nstatic ssize_t vidi_store_connection(struct device *dev,\n\t\t\t\tstruct device_attribute *attr,\n\t\t\t\tconst char *buf, size_t len)\n{\n\tstruct vidi_context *ctx = dev_get_drvdata(dev);\n\tint ret;\n\n\tret = kstrtoint(buf, 0, &ctx->connected);\n\tif (ret)\n\t\treturn ret;\n\n\tif (ctx->connected > 1)\n\t\treturn -EINVAL;\n\n\t \n\tif (!ctx->raw_edid)\n\t\tctx->raw_edid = (struct edid *)fake_edid_info;\n\n\t \n\tif (ctx->raw_edid != (struct edid *)fake_edid_info) {\n\t\tDRM_DEV_DEBUG_KMS(dev, \"edid data is not fake data.\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tDRM_DEV_DEBUG_KMS(dev, \"requested connection.\\n\");\n\n\tdrm_helper_hpd_irq_event(ctx->drm_dev);\n\n\treturn len;\n}\n\nstatic DEVICE_ATTR(connection, 0644, vidi_show_connection,\n\t\t\tvidi_store_connection);\n\nstatic struct attribute *vidi_attrs[] = {\n\t&dev_attr_connection.attr,\n\tNULL,\n};\nATTRIBUTE_GROUPS(vidi);\n\nint vidi_connection_ioctl(struct drm_device *drm_dev, void *data,\n\t\t\t\tstruct drm_file *file_priv)\n{\n\tstruct vidi_context *ctx = dev_get_drvdata(drm_dev->dev);\n\tstruct drm_exynos_vidi_connection *vidi = data;\n\n\tif (!vidi) {\n\t\tDRM_DEV_DEBUG_KMS(ctx->dev,\n\t\t\t\t  \"user data for vidi is null.\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (vidi->connection > 1) {\n\t\tDRM_DEV_DEBUG_KMS(ctx->dev,\n\t\t\t\t  \"connection should be 0 or 1.\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (ctx->connected == vidi->connection) {\n\t\tDRM_DEV_DEBUG_KMS(ctx->dev,\n\t\t\t\t  \"same connection request.\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (vidi->connection) {\n\t\tstruct edid *raw_edid;\n\n\t\traw_edid = (struct edid *)(unsigned long)vidi->edid;\n\t\tif (!drm_edid_is_valid(raw_edid)) {\n\t\t\tDRM_DEV_DEBUG_KMS(ctx->dev,\n\t\t\t\t\t  \"edid data is invalid.\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tctx->raw_edid = drm_edid_duplicate(raw_edid);\n\t\tif (!ctx->raw_edid) {\n\t\t\tDRM_DEV_DEBUG_KMS(ctx->dev,\n\t\t\t\t\t  \"failed to allocate raw_edid.\\n\");\n\t\t\treturn -ENOMEM;\n\t\t}\n\t} else {\n\t\t \n\t\tif (ctx->raw_edid && ctx->raw_edid !=\n\t\t\t\t(struct edid *)fake_edid_info) {\n\t\t\tkfree(ctx->raw_edid);\n\t\t\tctx->raw_edid = NULL;\n\t\t}\n\t}\n\n\tctx->connected = vidi->connection;\n\tdrm_helper_hpd_irq_event(ctx->drm_dev);\n\n\treturn 0;\n}\n\nstatic enum drm_connector_status vidi_detect(struct drm_connector *connector,\n\t\t\tbool force)\n{\n\tstruct vidi_context *ctx = ctx_from_connector(connector);\n\n\t \n\treturn ctx->connected ? connector_status_connected :\n\t\t\tconnector_status_disconnected;\n}\n\nstatic void vidi_connector_destroy(struct drm_connector *connector)\n{\n}\n\nstatic const struct drm_connector_funcs vidi_connector_funcs = {\n\t.fill_modes = drm_helper_probe_single_connector_modes,\n\t.detect = vidi_detect,\n\t.destroy = vidi_connector_destroy,\n\t.reset = drm_atomic_helper_connector_reset,\n\t.atomic_duplicate_state = drm_atomic_helper_connector_duplicate_state,\n\t.atomic_destroy_state = drm_atomic_helper_connector_destroy_state,\n};\n\nstatic int vidi_get_modes(struct drm_connector *connector)\n{\n\tstruct vidi_context *ctx = ctx_from_connector(connector);\n\tstruct edid *edid;\n\tint edid_len;\n\n\t \n\tif (!ctx->raw_edid) {\n\t\tDRM_DEV_DEBUG_KMS(ctx->dev, \"raw_edid is null.\\n\");\n\t\treturn -EFAULT;\n\t}\n\n\tedid_len = (1 + ctx->raw_edid->extensions) * EDID_LENGTH;\n\tedid = kmemdup(ctx->raw_edid, edid_len, GFP_KERNEL);\n\tif (!edid) {\n\t\tDRM_DEV_DEBUG_KMS(ctx->dev, \"failed to allocate edid\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tdrm_connector_update_edid_property(connector, edid);\n\n\treturn drm_add_edid_modes(connector, edid);\n}\n\nstatic const struct drm_connector_helper_funcs vidi_connector_helper_funcs = {\n\t.get_modes = vidi_get_modes,\n};\n\nstatic int vidi_create_connector(struct drm_encoder *encoder)\n{\n\tstruct vidi_context *ctx = encoder_to_vidi(encoder);\n\tstruct drm_connector *connector = &ctx->connector;\n\tint ret;\n\n\tconnector->polled = DRM_CONNECTOR_POLL_HPD;\n\n\tret = drm_connector_init(ctx->drm_dev, connector,\n\t\t\t&vidi_connector_funcs, DRM_MODE_CONNECTOR_VIRTUAL);\n\tif (ret) {\n\t\tDRM_DEV_ERROR(ctx->dev,\n\t\t\t      \"Failed to initialize connector with drm\\n\");\n\t\treturn ret;\n\t}\n\n\tdrm_connector_helper_add(connector, &vidi_connector_helper_funcs);\n\tdrm_connector_attach_encoder(connector, encoder);\n\n\treturn 0;\n}\n\nstatic void exynos_vidi_mode_set(struct drm_encoder *encoder,\n\t\t\t       struct drm_display_mode *mode,\n\t\t\t       struct drm_display_mode *adjusted_mode)\n{\n}\n\nstatic void exynos_vidi_enable(struct drm_encoder *encoder)\n{\n}\n\nstatic void exynos_vidi_disable(struct drm_encoder *encoder)\n{\n}\n\nstatic const struct drm_encoder_helper_funcs exynos_vidi_encoder_helper_funcs = {\n\t.mode_set = exynos_vidi_mode_set,\n\t.enable = exynos_vidi_enable,\n\t.disable = exynos_vidi_disable,\n};\n\nstatic int vidi_bind(struct device *dev, struct device *master, void *data)\n{\n\tstruct vidi_context *ctx = dev_get_drvdata(dev);\n\tstruct drm_device *drm_dev = data;\n\tstruct drm_encoder *encoder = &ctx->encoder;\n\tstruct exynos_drm_plane *exynos_plane;\n\tstruct exynos_drm_plane_config plane_config = { 0 };\n\tunsigned int i;\n\tint ret;\n\n\tctx->drm_dev = drm_dev;\n\n\tplane_config.pixel_formats = formats;\n\tplane_config.num_pixel_formats = ARRAY_SIZE(formats);\n\n\tfor (i = 0; i < WINDOWS_NR; i++) {\n\t\tplane_config.zpos = i;\n\t\tplane_config.type = vidi_win_types[i];\n\n\t\tret = exynos_plane_init(drm_dev, &ctx->planes[i], i,\n\t\t\t\t\t&plane_config);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\texynos_plane = &ctx->planes[DEFAULT_WIN];\n\tctx->crtc = exynos_drm_crtc_create(drm_dev, &exynos_plane->base,\n\t\t\tEXYNOS_DISPLAY_TYPE_VIDI, &vidi_crtc_ops, ctx);\n\tif (IS_ERR(ctx->crtc)) {\n\t\tDRM_DEV_ERROR(dev, \"failed to create crtc.\\n\");\n\t\treturn PTR_ERR(ctx->crtc);\n\t}\n\n\tdrm_simple_encoder_init(drm_dev, encoder, DRM_MODE_ENCODER_TMDS);\n\n\tdrm_encoder_helper_add(encoder, &exynos_vidi_encoder_helper_funcs);\n\n\tret = exynos_drm_set_possible_crtcs(encoder, EXYNOS_DISPLAY_TYPE_VIDI);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = vidi_create_connector(encoder);\n\tif (ret) {\n\t\tDRM_DEV_ERROR(dev, \"failed to create connector ret = %d\\n\",\n\t\t\t      ret);\n\t\tdrm_encoder_cleanup(encoder);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\n\nstatic void vidi_unbind(struct device *dev, struct device *master, void *data)\n{\n\tstruct vidi_context *ctx = dev_get_drvdata(dev);\n\n\tdel_timer_sync(&ctx->timer);\n}\n\nstatic const struct component_ops vidi_component_ops = {\n\t.bind\t= vidi_bind,\n\t.unbind = vidi_unbind,\n};\n\nstatic int vidi_probe(struct platform_device *pdev)\n{\n\tstruct vidi_context *ctx;\n\tstruct device *dev = &pdev->dev;\n\n\tctx = devm_kzalloc(dev, sizeof(*ctx), GFP_KERNEL);\n\tif (!ctx)\n\t\treturn -ENOMEM;\n\n\tctx->dev = dev;\n\n\ttimer_setup(&ctx->timer, vidi_fake_vblank_timer, 0);\n\n\tmutex_init(&ctx->lock);\n\n\tplatform_set_drvdata(pdev, ctx);\n\n\treturn component_add(dev, &vidi_component_ops);\n}\n\nstatic int vidi_remove(struct platform_device *pdev)\n{\n\tstruct vidi_context *ctx = platform_get_drvdata(pdev);\n\n\tif (ctx->raw_edid != (struct edid *)fake_edid_info) {\n\t\tkfree(ctx->raw_edid);\n\t\tctx->raw_edid = NULL;\n\t}\n\n\tcomponent_del(&pdev->dev, &vidi_component_ops);\n\n\treturn 0;\n}\n\nstruct platform_driver vidi_driver = {\n\t.probe\t\t= vidi_probe,\n\t.remove\t\t= vidi_remove,\n\t.driver\t\t= {\n\t\t.name\t= \"exynos-drm-vidi\",\n\t\t.owner\t= THIS_MODULE,\n\t\t.dev_groups = vidi_groups,\n\t},\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}