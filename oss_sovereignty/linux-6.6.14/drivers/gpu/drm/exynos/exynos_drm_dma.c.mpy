{
  "module_name": "exynos_drm_dma.c",
  "hash_id": "bc35a7e0bf57faedd3bbd157e6300075422d287fe5d950bd2efc73bc1eb26dd0",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/exynos/exynos_drm_dma.c",
  "human_readable_source": "\n\n\n\n\n\n#include <linux/dma-map-ops.h>\n#include <linux/iommu.h>\n#include <linux/platform_device.h>\n\n#include <drm/drm_print.h>\n#include <drm/exynos_drm.h>\n\n#include \"exynos_drm_drv.h\"\n\n#if defined(CONFIG_ARM_DMA_USE_IOMMU)\n#include <asm/dma-iommu.h>\n#else\n#define arm_iommu_create_mapping(...)\t({ NULL; })\n#define arm_iommu_attach_device(...)\t({ -ENODEV; })\n#define arm_iommu_release_mapping(...)\t({ })\n#define arm_iommu_detach_device(...)\t({ })\n#define to_dma_iommu_mapping(dev) NULL\n#endif\n\n#if !defined(CONFIG_IOMMU_DMA)\n#define iommu_dma_init_domain(...) ({ -EINVAL; })\n#endif\n\n#define EXYNOS_DEV_ADDR_START\t0x20000000\n#define EXYNOS_DEV_ADDR_SIZE\t0x40000000\n\n \nstatic int drm_iommu_attach_device(struct drm_device *drm_dev,\n\t\t\t\tstruct device *subdrv_dev, void **dma_priv)\n{\n\tstruct exynos_drm_private *priv = drm_dev->dev_private;\n\tint ret = 0;\n\n\tif (get_dma_ops(priv->dma_dev) != get_dma_ops(subdrv_dev)) {\n\t\tDRM_DEV_ERROR(subdrv_dev, \"Device %s lacks support for IOMMU\\n\",\n\t\t\t  dev_name(subdrv_dev));\n\t\treturn -EINVAL;\n\t}\n\n\tdma_set_max_seg_size(subdrv_dev, DMA_BIT_MASK(32));\n\tif (IS_ENABLED(CONFIG_ARM_DMA_USE_IOMMU)) {\n\t\t \n\t\t*dma_priv = to_dma_iommu_mapping(subdrv_dev);\n\t\tif (*dma_priv)\n\t\t\tarm_iommu_detach_device(subdrv_dev);\n\n\t\tret = arm_iommu_attach_device(subdrv_dev, priv->mapping);\n\t} else if (IS_ENABLED(CONFIG_IOMMU_DMA)) {\n\t\tret = iommu_attach_device(priv->mapping, subdrv_dev);\n\t}\n\n\treturn ret;\n}\n\n \nstatic void drm_iommu_detach_device(struct drm_device *drm_dev,\n\t\t\t\t    struct device *subdrv_dev, void **dma_priv)\n{\n\tstruct exynos_drm_private *priv = drm_dev->dev_private;\n\n\tif (IS_ENABLED(CONFIG_ARM_DMA_USE_IOMMU)) {\n\t\tarm_iommu_detach_device(subdrv_dev);\n\t\tarm_iommu_attach_device(subdrv_dev, *dma_priv);\n\t} else if (IS_ENABLED(CONFIG_IOMMU_DMA))\n\t\tiommu_detach_device(priv->mapping, subdrv_dev);\n}\n\nint exynos_drm_register_dma(struct drm_device *drm, struct device *dev,\n\t\t\t    void **dma_priv)\n{\n\tstruct exynos_drm_private *priv = drm->dev_private;\n\n\tif (!priv->dma_dev) {\n\t\tpriv->dma_dev = dev;\n\t\tDRM_INFO(\"Exynos DRM: using %s device for DMA mapping operations\\n\",\n\t\t\t dev_name(dev));\n\t}\n\n\tif (!IS_ENABLED(CONFIG_EXYNOS_IOMMU))\n\t\treturn 0;\n\n\tif (!priv->mapping) {\n\t\tvoid *mapping = NULL;\n\n\t\tif (IS_ENABLED(CONFIG_ARM_DMA_USE_IOMMU))\n\t\t\tmapping = arm_iommu_create_mapping(&platform_bus_type,\n\t\t\t\tEXYNOS_DEV_ADDR_START, EXYNOS_DEV_ADDR_SIZE);\n\t\telse if (IS_ENABLED(CONFIG_IOMMU_DMA))\n\t\t\tmapping = iommu_get_domain_for_dev(priv->dma_dev);\n\n\t\tif (!mapping)\n\t\t\treturn -ENODEV;\n\t\tpriv->mapping = mapping;\n\t}\n\n\treturn drm_iommu_attach_device(drm, dev, dma_priv);\n}\n\nvoid exynos_drm_unregister_dma(struct drm_device *drm, struct device *dev,\n\t\t\t       void **dma_priv)\n{\n\tif (IS_ENABLED(CONFIG_EXYNOS_IOMMU))\n\t\tdrm_iommu_detach_device(drm, dev, dma_priv);\n}\n\nvoid exynos_drm_cleanup_dma(struct drm_device *drm)\n{\n\tstruct exynos_drm_private *priv = drm->dev_private;\n\n\tif (!IS_ENABLED(CONFIG_EXYNOS_IOMMU))\n\t\treturn;\n\n\tarm_iommu_release_mapping(priv->mapping);\n\tpriv->mapping = NULL;\n\tpriv->dma_dev = NULL;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}