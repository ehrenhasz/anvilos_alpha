{
  "module_name": "exynos_drm_ipp.h",
  "hash_id": "0b0b6acdc9722933c0e103692fe71f8e3b0ad48c569d5429d4d141fefce1bf67",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/exynos/exynos_drm_ipp.h",
  "human_readable_source": " \n \n\n#ifndef _EXYNOS_DRM_IPP_H_\n#define _EXYNOS_DRM_IPP_H_\n\nstruct exynos_drm_ipp;\nstruct exynos_drm_ipp_task;\n\n \nstruct exynos_drm_ipp_funcs {\n\t \n\tint (*commit)(struct exynos_drm_ipp *ipp,\n\t\t      struct exynos_drm_ipp_task *task);\n\n\t \n\tvoid (*abort)(struct exynos_drm_ipp *ipp,\n\t\t      struct exynos_drm_ipp_task *task);\n};\n\n \nstruct exynos_drm_ipp {\n\tstruct drm_device *drm_dev;\n\tstruct device *dev;\n\tstruct list_head head;\n\tunsigned int id;\n\n\tconst char *name;\n\tconst struct exynos_drm_ipp_funcs *funcs;\n\tunsigned int capabilities;\n\tconst struct exynos_drm_ipp_formats *formats;\n\tunsigned int num_formats;\n\tatomic_t sequence;\n\n\tspinlock_t lock;\n\tstruct exynos_drm_ipp_task *task;\n\tstruct list_head todo_list;\n\twait_queue_head_t done_wq;\n};\n\nstruct exynos_drm_ipp_buffer {\n\tstruct drm_exynos_ipp_task_buffer buf;\n\tstruct drm_exynos_ipp_task_rect rect;\n\n\tstruct exynos_drm_gem *exynos_gem[MAX_FB_BUFFER];\n\tconst struct drm_format_info *format;\n\tdma_addr_t dma_addr[MAX_FB_BUFFER];\n};\n\n \nstruct exynos_drm_ipp_task {\n\tstruct device *dev;\n\tstruct exynos_drm_ipp *ipp;\n\tstruct list_head head;\n\n\tstruct exynos_drm_ipp_buffer src;\n\tstruct exynos_drm_ipp_buffer dst;\n\n\tstruct drm_exynos_ipp_task_transform transform;\n\tstruct drm_exynos_ipp_task_alpha alpha;\n\n\tstruct work_struct cleanup_work;\n\tunsigned int flags;\n\tint ret;\n\n\tstruct drm_pending_exynos_ipp_event *event;\n};\n\n#define DRM_EXYNOS_IPP_TASK_DONE\t(1 << 0)\n#define DRM_EXYNOS_IPP_TASK_ASYNC\t(1 << 1)\n\nstruct exynos_drm_ipp_formats {\n\tuint32_t fourcc;\n\tuint32_t type;\n\tuint64_t modifier;\n\tconst struct drm_exynos_ipp_limit *limits;\n\tunsigned int num_limits;\n};\n\n \n#define IPP_SRCDST_MFORMAT(f, m, l) \\\n\t.fourcc = DRM_FORMAT_##f, .modifier = m, .limits = l, \\\n\t.num_limits = ARRAY_SIZE(l), \\\n\t.type = (DRM_EXYNOS_IPP_FORMAT_SOURCE | \\\n\t\t DRM_EXYNOS_IPP_FORMAT_DESTINATION)\n\n#define IPP_SRCDST_FORMAT(f, l) IPP_SRCDST_MFORMAT(f, 0, l)\n\n#define IPP_SIZE_LIMIT(l, val...)\t\\\n\t.type = (DRM_EXYNOS_IPP_LIMIT_TYPE_SIZE | \\\n\t\t DRM_EXYNOS_IPP_LIMIT_SIZE_##l), val\n\n#define IPP_SCALE_LIMIT(val...)\t\t\\\n\t.type = (DRM_EXYNOS_IPP_LIMIT_TYPE_SCALE), val\n\nint exynos_drm_ipp_register(struct device *dev, struct exynos_drm_ipp *ipp,\n\t\tconst struct exynos_drm_ipp_funcs *funcs, unsigned int caps,\n\t\tconst struct exynos_drm_ipp_formats *formats,\n\t\tunsigned int num_formats, const char *name);\nvoid exynos_drm_ipp_unregister(struct device *dev,\n\t\t\t       struct exynos_drm_ipp *ipp);\n\nvoid exynos_drm_ipp_task_done(struct exynos_drm_ipp_task *task, int ret);\n\n#ifdef CONFIG_DRM_EXYNOS_IPP\nint exynos_drm_ipp_get_res_ioctl(struct drm_device *dev, void *data,\n\t\t\t\t struct drm_file *file_priv);\nint exynos_drm_ipp_get_caps_ioctl(struct drm_device *dev, void *data,\n\t\t\t\t  struct drm_file *file_priv);\nint exynos_drm_ipp_get_limits_ioctl(struct drm_device *dev, void *data,\n\t\t\t\t    struct drm_file *file_priv);\nint exynos_drm_ipp_commit_ioctl(struct drm_device *dev,\n\t\t\t\tvoid *data, struct drm_file *file_priv);\n#else\nstatic inline int exynos_drm_ipp_get_res_ioctl(struct drm_device *dev,\n\t void *data, struct drm_file *file_priv)\n{\n\tstruct drm_exynos_ioctl_ipp_get_res *resp = data;\n\n\tresp->count_ipps = 0;\n\treturn 0;\n}\nstatic inline int exynos_drm_ipp_get_caps_ioctl(struct drm_device *dev,\n\t void *data, struct drm_file *file_priv)\n{\n\treturn -ENODEV;\n}\nstatic inline int exynos_drm_ipp_get_limits_ioctl(struct drm_device *dev,\n\t void *data, struct drm_file *file_priv)\n{\n\treturn -ENODEV;\n}\nstatic inline int exynos_drm_ipp_commit_ioctl(struct drm_device *dev,\n\t void *data, struct drm_file *file_priv)\n{\n\treturn -ENODEV;\n}\n#endif\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}