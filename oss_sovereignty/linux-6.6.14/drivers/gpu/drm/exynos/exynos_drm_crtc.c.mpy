{
  "module_name": "exynos_drm_crtc.c",
  "hash_id": "4b03cb1bcea7b222dd0e884acf8bc4798205de61e5813268a578687a3aa5bf47",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/exynos/exynos_drm_crtc.c",
  "human_readable_source": "\n \n\n#include <drm/drm_atomic.h>\n#include <drm/drm_atomic_helper.h>\n#include <drm/drm_encoder.h>\n#include <drm/drm_probe_helper.h>\n#include <drm/drm_vblank.h>\n\n#include \"exynos_drm_crtc.h\"\n#include \"exynos_drm_drv.h\"\n#include \"exynos_drm_plane.h\"\n\nstatic void exynos_drm_crtc_atomic_enable(struct drm_crtc *crtc,\n\t\t\t\t\t  struct drm_atomic_state *state)\n{\n\tstruct exynos_drm_crtc *exynos_crtc = to_exynos_crtc(crtc);\n\n\tif (exynos_crtc->ops->atomic_enable)\n\t\texynos_crtc->ops->atomic_enable(exynos_crtc);\n\n\tdrm_crtc_vblank_on(crtc);\n}\n\nstatic void exynos_drm_crtc_atomic_disable(struct drm_crtc *crtc,\n\t\t\t\t\t   struct drm_atomic_state *state)\n{\n\tstruct exynos_drm_crtc *exynos_crtc = to_exynos_crtc(crtc);\n\n\tdrm_crtc_vblank_off(crtc);\n\n\tif (exynos_crtc->ops->atomic_disable)\n\t\texynos_crtc->ops->atomic_disable(exynos_crtc);\n\n\tspin_lock_irq(&crtc->dev->event_lock);\n\tif (crtc->state->event && !crtc->state->active) {\n\t\tdrm_crtc_send_vblank_event(crtc, crtc->state->event);\n\t\tcrtc->state->event = NULL;\n\t}\n\tspin_unlock_irq(&crtc->dev->event_lock);\n}\n\nstatic int exynos_crtc_atomic_check(struct drm_crtc *crtc,\n\t\t\t\t     struct drm_atomic_state *state)\n{\n\tstruct drm_crtc_state *crtc_state = drm_atomic_get_new_crtc_state(state,\n\t\t\t\t\t\t\t\t\t  crtc);\n\tstruct exynos_drm_crtc *exynos_crtc = to_exynos_crtc(crtc);\n\n\tif (!crtc_state->enable)\n\t\treturn 0;\n\n\tif (exynos_crtc->ops->atomic_check)\n\t\treturn exynos_crtc->ops->atomic_check(exynos_crtc, crtc_state);\n\n\treturn 0;\n}\n\nstatic void exynos_crtc_atomic_begin(struct drm_crtc *crtc,\n\t\t\t\t     struct drm_atomic_state *state)\n{\n\tstruct exynos_drm_crtc *exynos_crtc = to_exynos_crtc(crtc);\n\n\tif (exynos_crtc->ops->atomic_begin)\n\t\texynos_crtc->ops->atomic_begin(exynos_crtc);\n}\n\nstatic void exynos_crtc_atomic_flush(struct drm_crtc *crtc,\n\t\t\t\t     struct drm_atomic_state *state)\n{\n\tstruct exynos_drm_crtc *exynos_crtc = to_exynos_crtc(crtc);\n\n\tif (exynos_crtc->ops->atomic_flush)\n\t\texynos_crtc->ops->atomic_flush(exynos_crtc);\n}\n\nstatic enum drm_mode_status exynos_crtc_mode_valid(struct drm_crtc *crtc,\n\tconst struct drm_display_mode *mode)\n{\n\tstruct exynos_drm_crtc *exynos_crtc = to_exynos_crtc(crtc);\n\n\tif (exynos_crtc->ops->mode_valid)\n\t\treturn exynos_crtc->ops->mode_valid(exynos_crtc, mode);\n\n\treturn MODE_OK;\n}\n\nstatic bool exynos_crtc_mode_fixup(struct drm_crtc *crtc,\n\t\tconst struct drm_display_mode *mode,\n\t\tstruct drm_display_mode *adjusted_mode)\n{\n\tstruct exynos_drm_crtc *exynos_crtc = to_exynos_crtc(crtc);\n\n\tif (exynos_crtc->ops->mode_fixup)\n\t\treturn exynos_crtc->ops->mode_fixup(exynos_crtc, mode,\n\t\t\t\tadjusted_mode);\n\n\treturn true;\n}\n\n\nstatic const struct drm_crtc_helper_funcs exynos_crtc_helper_funcs = {\n\t.mode_valid\t= exynos_crtc_mode_valid,\n\t.mode_fixup\t= exynos_crtc_mode_fixup,\n\t.atomic_check\t= exynos_crtc_atomic_check,\n\t.atomic_begin\t= exynos_crtc_atomic_begin,\n\t.atomic_flush\t= exynos_crtc_atomic_flush,\n\t.atomic_enable\t= exynos_drm_crtc_atomic_enable,\n\t.atomic_disable\t= exynos_drm_crtc_atomic_disable,\n};\n\nvoid exynos_crtc_handle_event(struct exynos_drm_crtc *exynos_crtc)\n{\n\tstruct drm_crtc *crtc = &exynos_crtc->base;\n\tstruct drm_pending_vblank_event *event = crtc->state->event;\n\tunsigned long flags;\n\n\tif (!event)\n\t\treturn;\n\tcrtc->state->event = NULL;\n\n\tWARN_ON(drm_crtc_vblank_get(crtc) != 0);\n\n\tspin_lock_irqsave(&crtc->dev->event_lock, flags);\n\tdrm_crtc_arm_vblank_event(crtc, event);\n\tspin_unlock_irqrestore(&crtc->dev->event_lock, flags);\n}\n\nstatic void exynos_drm_crtc_destroy(struct drm_crtc *crtc)\n{\n\tstruct exynos_drm_crtc *exynos_crtc = to_exynos_crtc(crtc);\n\n\tdrm_crtc_cleanup(crtc);\n\tkfree(exynos_crtc);\n}\n\nstatic int exynos_drm_crtc_enable_vblank(struct drm_crtc *crtc)\n{\n\tstruct exynos_drm_crtc *exynos_crtc = to_exynos_crtc(crtc);\n\n\tif (exynos_crtc->ops->enable_vblank)\n\t\treturn exynos_crtc->ops->enable_vblank(exynos_crtc);\n\n\treturn 0;\n}\n\nstatic void exynos_drm_crtc_disable_vblank(struct drm_crtc *crtc)\n{\n\tstruct exynos_drm_crtc *exynos_crtc = to_exynos_crtc(crtc);\n\n\tif (exynos_crtc->ops->disable_vblank)\n\t\texynos_crtc->ops->disable_vblank(exynos_crtc);\n}\n\nstatic const struct drm_crtc_funcs exynos_crtc_funcs = {\n\t.set_config\t= drm_atomic_helper_set_config,\n\t.page_flip\t= drm_atomic_helper_page_flip,\n\t.destroy\t= exynos_drm_crtc_destroy,\n\t.reset = drm_atomic_helper_crtc_reset,\n\t.atomic_duplicate_state = drm_atomic_helper_crtc_duplicate_state,\n\t.atomic_destroy_state = drm_atomic_helper_crtc_destroy_state,\n\t.enable_vblank = exynos_drm_crtc_enable_vblank,\n\t.disable_vblank = exynos_drm_crtc_disable_vblank,\n};\n\nstruct exynos_drm_crtc *exynos_drm_crtc_create(struct drm_device *drm_dev,\n\t\t\t\t\tstruct drm_plane *plane,\n\t\t\t\t\tenum exynos_drm_output_type type,\n\t\t\t\t\tconst struct exynos_drm_crtc_ops *ops,\n\t\t\t\t\tvoid *ctx)\n{\n\tstruct exynos_drm_crtc *exynos_crtc;\n\tstruct drm_crtc *crtc;\n\tint ret;\n\n\texynos_crtc = kzalloc(sizeof(*exynos_crtc), GFP_KERNEL);\n\tif (!exynos_crtc)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\texynos_crtc->type = type;\n\texynos_crtc->ops = ops;\n\texynos_crtc->ctx = ctx;\n\n\tcrtc = &exynos_crtc->base;\n\n\tret = drm_crtc_init_with_planes(drm_dev, crtc, plane, NULL,\n\t\t\t\t\t&exynos_crtc_funcs, NULL);\n\tif (ret < 0)\n\t\tgoto err_crtc;\n\n\tdrm_crtc_helper_add(crtc, &exynos_crtc_helper_funcs);\n\n\treturn exynos_crtc;\n\nerr_crtc:\n\tplane->funcs->destroy(plane);\n\tkfree(exynos_crtc);\n\treturn ERR_PTR(ret);\n}\n\nstruct exynos_drm_crtc *exynos_drm_crtc_get_by_type(struct drm_device *drm_dev,\n\t\t\t\t       enum exynos_drm_output_type out_type)\n{\n\tstruct drm_crtc *crtc;\n\n\tdrm_for_each_crtc(crtc, drm_dev)\n\t\tif (to_exynos_crtc(crtc)->type == out_type)\n\t\t\treturn to_exynos_crtc(crtc);\n\n\treturn ERR_PTR(-ENODEV);\n}\n\nint exynos_drm_set_possible_crtcs(struct drm_encoder *encoder,\n\t\tenum exynos_drm_output_type out_type)\n{\n\tstruct exynos_drm_crtc *crtc = exynos_drm_crtc_get_by_type(encoder->dev,\n\t\t\t\t\t\tout_type);\n\n\tif (IS_ERR(crtc))\n\t\treturn PTR_ERR(crtc);\n\n\tencoder->possible_crtcs = drm_crtc_mask(&crtc->base);\n\n\treturn 0;\n}\n\nvoid exynos_drm_crtc_te_handler(struct drm_crtc *crtc)\n{\n\tstruct exynos_drm_crtc *exynos_crtc = to_exynos_crtc(crtc);\n\n\tif (exynos_crtc->ops->te_handler)\n\t\texynos_crtc->ops->te_handler(exynos_crtc);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}