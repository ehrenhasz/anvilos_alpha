{
  "module_name": "exynos_drm_mic.c",
  "hash_id": "dbe34d350f5b01f92f3abad10ee47988f27c0e7283a9cfbb7d71272970bfc772",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/exynos/exynos_drm_mic.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/component.h>\n#include <linux/delay.h>\n#include <linux/mfd/syscon.h>\n#include <linux/module.h>\n#include <linux/mutex.h>\n#include <linux/of.h>\n#include <linux/of_address.h>\n#include <linux/of_graph.h>\n#include <linux/platform_device.h>\n#include <linux/pm_runtime.h>\n#include <linux/regmap.h>\n\n#include <video/of_videomode.h>\n#include <video/videomode.h>\n\n#include <drm/drm_bridge.h>\n#include <drm/drm_encoder.h>\n#include <drm/drm_print.h>\n\n#include \"exynos_drm_drv.h\"\n#include \"exynos_drm_crtc.h\"\n\n \n#define DSD_CFG_MUX\t0x1004\n#define MIC0_RGB_MUX\t(1 << 0)\n#define MIC0_I80_MUX\t(1 << 1)\n#define MIC0_ON_MUX\t(1 << 5)\n\n \n#define MIC_OP\t\t\t\t0x0\n#define MIC_IP_VER\t\t\t0x0004\n#define MIC_V_TIMING_0\t\t\t0x0008\n#define MIC_V_TIMING_1\t\t\t0x000C\n#define MIC_IMG_SIZE\t\t\t0x0010\n#define MIC_INPUT_TIMING_0\t\t0x0014\n#define MIC_INPUT_TIMING_1\t\t0x0018\n#define MIC_2D_OUTPUT_TIMING_0\t\t0x001C\n#define MIC_2D_OUTPUT_TIMING_1\t\t0x0020\n#define MIC_2D_OUTPUT_TIMING_2\t\t0x0024\n#define MIC_3D_OUTPUT_TIMING_0\t\t0x0028\n#define MIC_3D_OUTPUT_TIMING_1\t\t0x002C\n#define MIC_3D_OUTPUT_TIMING_2\t\t0x0030\n#define MIC_CORE_PARA_0\t\t\t0x0034\n#define MIC_CORE_PARA_1\t\t\t0x0038\n#define MIC_CTC_CTRL\t\t\t0x0040\n#define MIC_RD_DATA\t\t\t0x0044\n\n#define MIC_UPD_REG\t\t\t(1 << 31)\n#define MIC_ON_REG\t\t\t(1 << 30)\n#define MIC_TD_ON_REG\t\t\t(1 << 29)\n#define MIC_BS_CHG_OUT\t\t\t(1 << 16)\n#define MIC_VIDEO_TYPE(x)\t\t(((x) & 0xf) << 12)\n#define MIC_PSR_EN\t\t\t(1 << 5)\n#define MIC_SW_RST\t\t\t(1 << 4)\n#define MIC_ALL_RST\t\t\t(1 << 3)\n#define MIC_CORE_VER_CONTROL\t\t(1 << 2)\n#define MIC_MODE_SEL_COMMAND_MODE\t(1 << 1)\n#define MIC_MODE_SEL_MASK\t\t(1 << 1)\n#define MIC_CORE_EN\t\t\t(1 << 0)\n\n#define MIC_V_PULSE_WIDTH(x)\t\t(((x) & 0x3fff) << 16)\n#define MIC_V_PERIOD_LINE(x)\t\t((x) & 0x3fff)\n\n#define MIC_VBP_SIZE(x)\t\t\t(((x) & 0x3fff) << 16)\n#define MIC_VFP_SIZE(x)\t\t\t((x) & 0x3fff)\n\n#define MIC_IMG_V_SIZE(x)\t\t(((x) & 0x3fff) << 16)\n#define MIC_IMG_H_SIZE(x)\t\t((x) & 0x3fff)\n\n#define MIC_H_PULSE_WIDTH_IN(x)\t\t(((x) & 0x3fff) << 16)\n#define MIC_H_PERIOD_PIXEL_IN(x)\t((x) & 0x3fff)\n\n#define MIC_HBP_SIZE_IN(x)\t\t(((x) & 0x3fff) << 16)\n#define MIC_HFP_SIZE_IN(x)\t\t((x) & 0x3fff)\n\n#define MIC_H_PULSE_WIDTH_2D(x)\t\t(((x) & 0x3fff) << 16)\n#define MIC_H_PERIOD_PIXEL_2D(x)\t((x) & 0x3fff)\n\n#define MIC_HBP_SIZE_2D(x)\t\t(((x) & 0x3fff) << 16)\n#define MIC_HFP_SIZE_2D(x)\t\t((x) & 0x3fff)\n\n#define MIC_BS_SIZE_2D(x)\t((x) & 0x3fff)\n\nstatic const char *const clk_names[] = { \"pclk_mic0\", \"sclk_rgb_vclk_to_mic0\" };\n#define NUM_CLKS\t\tARRAY_SIZE(clk_names)\nstatic DEFINE_MUTEX(mic_mutex);\n\nstruct exynos_mic {\n\tstruct device *dev;\n\tvoid __iomem *reg;\n\tstruct regmap *sysreg;\n\tstruct clk *clks[NUM_CLKS];\n\n\tbool i80_mode;\n\tstruct videomode vm;\n\tstruct drm_bridge bridge;\n\n\tbool enabled;\n};\n\nstatic void mic_set_path(struct exynos_mic *mic, bool enable)\n{\n\tint ret;\n\tunsigned int val;\n\n\tret = regmap_read(mic->sysreg, DSD_CFG_MUX, &val);\n\tif (ret) {\n\t\tDRM_DEV_ERROR(mic->dev,\n\t\t\t      \"mic: Failed to read system register\\n\");\n\t\treturn;\n\t}\n\n\tif (enable) {\n\t\tif (mic->i80_mode)\n\t\t\tval |= MIC0_I80_MUX;\n\t\telse\n\t\t\tval |= MIC0_RGB_MUX;\n\n\t\tval |=  MIC0_ON_MUX;\n\t} else\n\t\tval &= ~(MIC0_RGB_MUX | MIC0_I80_MUX | MIC0_ON_MUX);\n\n\tret = regmap_write(mic->sysreg, DSD_CFG_MUX, val);\n\tif (ret)\n\t\tDRM_DEV_ERROR(mic->dev,\n\t\t\t      \"mic: Failed to read system register\\n\");\n}\n\nstatic int mic_sw_reset(struct exynos_mic *mic)\n{\n\tunsigned int retry = 100;\n\tint ret;\n\n\twritel(MIC_SW_RST, mic->reg + MIC_OP);\n\n\twhile (retry-- > 0) {\n\t\tret = readl(mic->reg + MIC_OP);\n\t\tif (!(ret & MIC_SW_RST))\n\t\t\treturn 0;\n\n\t\tudelay(10);\n\t}\n\n\treturn -ETIMEDOUT;\n}\n\nstatic void mic_set_porch_timing(struct exynos_mic *mic)\n{\n\tstruct videomode vm = mic->vm;\n\tu32 reg;\n\n\treg = MIC_V_PULSE_WIDTH(vm.vsync_len) +\n\t\tMIC_V_PERIOD_LINE(vm.vsync_len + vm.vactive +\n\t\t\t\tvm.vback_porch + vm.vfront_porch);\n\twritel(reg, mic->reg + MIC_V_TIMING_0);\n\n\treg = MIC_VBP_SIZE(vm.vback_porch) +\n\t\tMIC_VFP_SIZE(vm.vfront_porch);\n\twritel(reg, mic->reg + MIC_V_TIMING_1);\n\n\treg = MIC_V_PULSE_WIDTH(vm.hsync_len) +\n\t\tMIC_V_PERIOD_LINE(vm.hsync_len + vm.hactive +\n\t\t\t\tvm.hback_porch + vm.hfront_porch);\n\twritel(reg, mic->reg + MIC_INPUT_TIMING_0);\n\n\treg = MIC_VBP_SIZE(vm.hback_porch) +\n\t\tMIC_VFP_SIZE(vm.hfront_porch);\n\twritel(reg, mic->reg + MIC_INPUT_TIMING_1);\n}\n\nstatic void mic_set_img_size(struct exynos_mic *mic)\n{\n\tstruct videomode *vm = &mic->vm;\n\tu32 reg;\n\n\treg = MIC_IMG_H_SIZE(vm->hactive) +\n\t\tMIC_IMG_V_SIZE(vm->vactive);\n\n\twritel(reg, mic->reg + MIC_IMG_SIZE);\n}\n\nstatic void mic_set_output_timing(struct exynos_mic *mic)\n{\n\tstruct videomode vm = mic->vm;\n\tu32 reg, bs_size_2d;\n\n\tDRM_DEV_DEBUG(mic->dev, \"w: %u, h: %u\\n\", vm.hactive, vm.vactive);\n\tbs_size_2d = ((vm.hactive >> 2) << 1) + (vm.vactive % 4);\n\treg = MIC_BS_SIZE_2D(bs_size_2d);\n\twritel(reg, mic->reg + MIC_2D_OUTPUT_TIMING_2);\n\n\tif (!mic->i80_mode) {\n\t\treg = MIC_H_PULSE_WIDTH_2D(vm.hsync_len) +\n\t\t\tMIC_H_PERIOD_PIXEL_2D(vm.hsync_len + bs_size_2d +\n\t\t\t\t\tvm.hback_porch + vm.hfront_porch);\n\t\twritel(reg, mic->reg + MIC_2D_OUTPUT_TIMING_0);\n\n\t\treg = MIC_HBP_SIZE_2D(vm.hback_porch) +\n\t\t\tMIC_H_PERIOD_PIXEL_2D(vm.hfront_porch);\n\t\twritel(reg, mic->reg + MIC_2D_OUTPUT_TIMING_1);\n\t}\n}\n\nstatic void mic_set_reg_on(struct exynos_mic *mic, bool enable)\n{\n\tu32 reg = readl(mic->reg + MIC_OP);\n\n\tif (enable) {\n\t\treg &= ~(MIC_MODE_SEL_MASK | MIC_CORE_VER_CONTROL | MIC_PSR_EN);\n\t\treg |= (MIC_CORE_EN | MIC_BS_CHG_OUT | MIC_ON_REG);\n\n\t\treg  &= ~MIC_MODE_SEL_COMMAND_MODE;\n\t\tif (mic->i80_mode)\n\t\t\treg |= MIC_MODE_SEL_COMMAND_MODE;\n\t} else {\n\t\treg &= ~MIC_CORE_EN;\n\t}\n\n\treg |= MIC_UPD_REG;\n\twritel(reg, mic->reg + MIC_OP);\n}\n\nstatic void mic_post_disable(struct drm_bridge *bridge)\n{\n\tstruct exynos_mic *mic = bridge->driver_private;\n\n\tmutex_lock(&mic_mutex);\n\tif (!mic->enabled)\n\t\tgoto already_disabled;\n\n\tmic_set_path(mic, 0);\n\n\tpm_runtime_put(mic->dev);\n\tmic->enabled = 0;\n\nalready_disabled:\n\tmutex_unlock(&mic_mutex);\n}\n\nstatic void mic_mode_set(struct drm_bridge *bridge,\n\t\t\t const struct drm_display_mode *mode,\n\t\t\t const struct drm_display_mode *adjusted_mode)\n{\n\tstruct exynos_mic *mic = bridge->driver_private;\n\n\tmutex_lock(&mic_mutex);\n\tdrm_display_mode_to_videomode(mode, &mic->vm);\n\tmic->i80_mode = to_exynos_crtc(bridge->encoder->crtc)->i80_mode;\n\tmutex_unlock(&mic_mutex);\n}\n\nstatic void mic_pre_enable(struct drm_bridge *bridge)\n{\n\tstruct exynos_mic *mic = bridge->driver_private;\n\tint ret;\n\n\tmutex_lock(&mic_mutex);\n\tif (mic->enabled)\n\t\tgoto unlock;\n\n\tret = pm_runtime_resume_and_get(mic->dev);\n\tif (ret < 0)\n\t\tgoto unlock;\n\n\tmic_set_path(mic, 1);\n\n\tret = mic_sw_reset(mic);\n\tif (ret) {\n\t\tDRM_DEV_ERROR(mic->dev, \"Failed to reset\\n\");\n\t\tgoto turn_off;\n\t}\n\n\tif (!mic->i80_mode)\n\t\tmic_set_porch_timing(mic);\n\tmic_set_img_size(mic);\n\tmic_set_output_timing(mic);\n\tmic_set_reg_on(mic, 1);\n\tmic->enabled = 1;\n\tmutex_unlock(&mic_mutex);\n\n\treturn;\n\nturn_off:\n\tpm_runtime_put(mic->dev);\nunlock:\n\tmutex_unlock(&mic_mutex);\n}\n\nstatic const struct drm_bridge_funcs mic_bridge_funcs = {\n\t.post_disable = mic_post_disable,\n\t.mode_set = mic_mode_set,\n\t.pre_enable = mic_pre_enable,\n};\n\nstatic int exynos_mic_bind(struct device *dev, struct device *master,\n\t\t\t   void *data)\n{\n\tstruct exynos_mic *mic = dev_get_drvdata(dev);\n\tstruct drm_device *drm_dev = data;\n\tstruct exynos_drm_crtc *crtc = exynos_drm_crtc_get_by_type(drm_dev,\n\t\t\t\t\t\t       EXYNOS_DISPLAY_TYPE_LCD);\n\tstruct drm_encoder *e, *encoder = NULL;\n\n\tdrm_for_each_encoder(e, drm_dev)\n\t\tif (e->possible_crtcs == drm_crtc_mask(&crtc->base))\n\t\t\tencoder = e;\n\tif (!encoder)\n\t\treturn -ENODEV;\n\n\tmic->bridge.driver_private = mic;\n\n\treturn drm_bridge_attach(encoder, &mic->bridge, NULL, 0);\n}\n\nstatic void exynos_mic_unbind(struct device *dev, struct device *master,\n\t\t\t      void *data)\n{\n\tstruct exynos_mic *mic = dev_get_drvdata(dev);\n\n\tmutex_lock(&mic_mutex);\n\tif (!mic->enabled)\n\t\tgoto already_disabled;\n\n\tpm_runtime_put(mic->dev);\n\nalready_disabled:\n\tmutex_unlock(&mic_mutex);\n}\n\nstatic const struct component_ops exynos_mic_component_ops = {\n\t.bind\t= exynos_mic_bind,\n\t.unbind\t= exynos_mic_unbind,\n};\n\nstatic int exynos_mic_suspend(struct device *dev)\n{\n\tstruct exynos_mic *mic = dev_get_drvdata(dev);\n\tint i;\n\n\tfor (i = NUM_CLKS - 1; i > -1; i--)\n\t\tclk_disable_unprepare(mic->clks[i]);\n\n\treturn 0;\n}\n\nstatic int exynos_mic_resume(struct device *dev)\n{\n\tstruct exynos_mic *mic = dev_get_drvdata(dev);\n\tint ret, i;\n\n\tfor (i = 0; i < NUM_CLKS; i++) {\n\t\tret = clk_prepare_enable(mic->clks[i]);\n\t\tif (ret < 0) {\n\t\t\tDRM_DEV_ERROR(dev, \"Failed to enable clock (%s)\\n\",\n\t\t\t\t      clk_names[i]);\n\t\t\twhile (--i > -1)\n\t\t\t\tclk_disable_unprepare(mic->clks[i]);\n\t\t\treturn ret;\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic DEFINE_RUNTIME_DEV_PM_OPS(exynos_mic_pm_ops, exynos_mic_suspend,\n\t\t\t\t exynos_mic_resume, NULL);\n\nstatic int exynos_mic_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct exynos_mic *mic;\n\tstruct resource res;\n\tint ret, i;\n\n\tmic = devm_kzalloc(dev, sizeof(*mic), GFP_KERNEL);\n\tif (!mic) {\n\t\tDRM_DEV_ERROR(dev,\n\t\t\t      \"mic: Failed to allocate memory for MIC object\\n\");\n\t\tret = -ENOMEM;\n\t\tgoto err;\n\t}\n\n\tmic->dev = dev;\n\n\tret = of_address_to_resource(dev->of_node, 0, &res);\n\tif (ret) {\n\t\tDRM_DEV_ERROR(dev, \"mic: Failed to get mem region for MIC\\n\");\n\t\tgoto err;\n\t}\n\tmic->reg = devm_ioremap(dev, res.start, resource_size(&res));\n\tif (!mic->reg) {\n\t\tDRM_DEV_ERROR(dev, \"mic: Failed to remap for MIC\\n\");\n\t\tret = -ENOMEM;\n\t\tgoto err;\n\t}\n\n\tmic->sysreg = syscon_regmap_lookup_by_phandle(dev->of_node,\n\t\t\t\t\t\t\t\"samsung,disp-syscon\");\n\tif (IS_ERR(mic->sysreg)) {\n\t\tDRM_DEV_ERROR(dev, \"mic: Failed to get system register.\\n\");\n\t\tret = PTR_ERR(mic->sysreg);\n\t\tgoto err;\n\t}\n\n\tfor (i = 0; i < NUM_CLKS; i++) {\n\t\tmic->clks[i] = devm_clk_get(dev, clk_names[i]);\n\t\tif (IS_ERR(mic->clks[i])) {\n\t\t\tDRM_DEV_ERROR(dev, \"mic: Failed to get clock (%s)\\n\",\n\t\t\t\t      clk_names[i]);\n\t\t\tret = PTR_ERR(mic->clks[i]);\n\t\t\tgoto err;\n\t\t}\n\t}\n\n\tplatform_set_drvdata(pdev, mic);\n\n\tmic->bridge.funcs = &mic_bridge_funcs;\n\tmic->bridge.of_node = dev->of_node;\n\n\tdrm_bridge_add(&mic->bridge);\n\n\tpm_runtime_enable(dev);\n\n\tret = component_add(dev, &exynos_mic_component_ops);\n\tif (ret)\n\t\tgoto err_pm;\n\n\tDRM_DEV_DEBUG_KMS(dev, \"MIC has been probed\\n\");\n\n\treturn 0;\n\nerr_pm:\n\tpm_runtime_disable(dev);\nerr:\n\treturn ret;\n}\n\nstatic int exynos_mic_remove(struct platform_device *pdev)\n{\n\tstruct exynos_mic *mic = platform_get_drvdata(pdev);\n\n\tcomponent_del(&pdev->dev, &exynos_mic_component_ops);\n\tpm_runtime_disable(&pdev->dev);\n\n\tdrm_bridge_remove(&mic->bridge);\n\n\treturn 0;\n}\n\nstatic const struct of_device_id exynos_mic_of_match[] = {\n\t{ .compatible = \"samsung,exynos5433-mic\" },\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, exynos_mic_of_match);\n\nstruct platform_driver mic_driver = {\n\t.probe\t\t= exynos_mic_probe,\n\t.remove\t\t= exynos_mic_remove,\n\t.driver\t\t= {\n\t\t.name\t= \"exynos-mic\",\n\t\t.pm\t= pm_ptr(&exynos_mic_pm_ops),\n\t\t.owner\t= THIS_MODULE,\n\t\t.of_match_table = exynos_mic_of_match,\n\t},\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}