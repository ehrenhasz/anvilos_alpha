{
  "module_name": "exynos_drm_rotator.c",
  "hash_id": "079c45e83a6d21ba188d2e990652619211169eac42b2304915cb7823c4b308c4",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/exynos/exynos_drm_rotator.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/component.h>\n#include <linux/err.h>\n#include <linux/interrupt.h>\n#include <linux/io.h>\n#include <linux/kernel.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/pm_runtime.h>\n#include <linux/sizes.h>\n\n#include <drm/drm_fourcc.h>\n#include <drm/exynos_drm.h>\n\n#include \"exynos_drm_drv.h\"\n#include \"exynos_drm_ipp.h\"\n#include \"regs-rotator.h\"\n\n \n\n#define ROTATOR_AUTOSUSPEND_DELAY\t2000\n\n#define rot_read(offset)\treadl(rot->regs + (offset))\n#define rot_write(cfg, offset)\twritel(cfg, rot->regs + (offset))\n\nenum rot_irq_status {\n\tROT_IRQ_STATUS_COMPLETE\t= 8,\n\tROT_IRQ_STATUS_ILLEGAL\t= 9,\n};\n\nstruct rot_variant {\n\tconst struct exynos_drm_ipp_formats *formats;\n\tunsigned int\tnum_formats;\n};\n\n \nstruct rot_context {\n\tstruct exynos_drm_ipp ipp;\n\tstruct drm_device *drm_dev;\n\tvoid\t\t*dma_priv;\n\tstruct device\t*dev;\n\tvoid __iomem\t*regs;\n\tstruct clk\t*clock;\n\tconst struct exynos_drm_ipp_formats *formats;\n\tunsigned int\tnum_formats;\n\tstruct exynos_drm_ipp_task\t*task;\n};\n\nstatic void rotator_reg_set_irq(struct rot_context *rot, bool enable)\n{\n\tu32 val = rot_read(ROT_CONFIG);\n\n\tif (enable == true)\n\t\tval |= ROT_CONFIG_IRQ;\n\telse\n\t\tval &= ~ROT_CONFIG_IRQ;\n\n\trot_write(val, ROT_CONFIG);\n}\n\nstatic enum rot_irq_status rotator_reg_get_irq_status(struct rot_context *rot)\n{\n\tu32 val = rot_read(ROT_STATUS);\n\n\tval = ROT_STATUS_IRQ(val);\n\n\tif (val == ROT_STATUS_IRQ_VAL_COMPLETE)\n\t\treturn ROT_IRQ_STATUS_COMPLETE;\n\n\treturn ROT_IRQ_STATUS_ILLEGAL;\n}\n\nstatic irqreturn_t rotator_irq_handler(int irq, void *arg)\n{\n\tstruct rot_context *rot = arg;\n\tenum rot_irq_status irq_status;\n\tu32 val;\n\n\t \n\tirq_status = rotator_reg_get_irq_status(rot);\n\n\t \n\tval = rot_read(ROT_STATUS);\n\tval |= ROT_STATUS_IRQ_PENDING((u32)irq_status);\n\trot_write(val, ROT_STATUS);\n\n\tif (rot->task) {\n\t\tstruct exynos_drm_ipp_task *task = rot->task;\n\n\t\trot->task = NULL;\n\t\tpm_runtime_mark_last_busy(rot->dev);\n\t\tpm_runtime_put_autosuspend(rot->dev);\n\t\texynos_drm_ipp_task_done(task,\n\t\t\tirq_status == ROT_IRQ_STATUS_COMPLETE ? 0 : -EINVAL);\n\t}\n\n\treturn IRQ_HANDLED;\n}\n\nstatic void rotator_src_set_fmt(struct rot_context *rot, u32 fmt)\n{\n\tu32 val;\n\n\tval = rot_read(ROT_CONTROL);\n\tval &= ~ROT_CONTROL_FMT_MASK;\n\n\tswitch (fmt) {\n\tcase DRM_FORMAT_NV12:\n\t\tval |= ROT_CONTROL_FMT_YCBCR420_2P;\n\t\tbreak;\n\tcase DRM_FORMAT_XRGB8888:\n\t\tval |= ROT_CONTROL_FMT_RGB888;\n\t\tbreak;\n\t}\n\n\trot_write(val, ROT_CONTROL);\n}\n\nstatic void rotator_src_set_buf(struct rot_context *rot,\n\t\t\t\tstruct exynos_drm_ipp_buffer *buf)\n{\n\tu32 val;\n\n\t \n\tval = ROT_SET_BUF_SIZE_H(buf->buf.height) |\n\t      ROT_SET_BUF_SIZE_W(buf->buf.pitch[0] / buf->format->cpp[0]);\n\trot_write(val, ROT_SRC_BUF_SIZE);\n\n\t \n\tval = ROT_CROP_POS_Y(buf->rect.y) | ROT_CROP_POS_X(buf->rect.x);\n\trot_write(val, ROT_SRC_CROP_POS);\n\tval = ROT_SRC_CROP_SIZE_H(buf->rect.h) |\n\t      ROT_SRC_CROP_SIZE_W(buf->rect.w);\n\trot_write(val, ROT_SRC_CROP_SIZE);\n\n\t \n\trot_write(buf->dma_addr[0], ROT_SRC_BUF_ADDR(0));\n\trot_write(buf->dma_addr[1], ROT_SRC_BUF_ADDR(1));\n}\n\nstatic void rotator_dst_set_transf(struct rot_context *rot,\n\t\t\t\t   unsigned int rotation)\n{\n\tu32 val;\n\n\t \n\tval = rot_read(ROT_CONTROL);\n\tval &= ~ROT_CONTROL_FLIP_MASK;\n\n\tif (rotation & DRM_MODE_REFLECT_X)\n\t\tval |= ROT_CONTROL_FLIP_VERTICAL;\n\tif (rotation & DRM_MODE_REFLECT_Y)\n\t\tval |= ROT_CONTROL_FLIP_HORIZONTAL;\n\n\tval &= ~ROT_CONTROL_ROT_MASK;\n\n\tif (rotation & DRM_MODE_ROTATE_90)\n\t\tval |= ROT_CONTROL_ROT_90;\n\telse if (rotation & DRM_MODE_ROTATE_180)\n\t\tval |= ROT_CONTROL_ROT_180;\n\telse if (rotation & DRM_MODE_ROTATE_270)\n\t\tval |= ROT_CONTROL_ROT_270;\n\n\trot_write(val, ROT_CONTROL);\n}\n\nstatic void rotator_dst_set_buf(struct rot_context *rot,\n\t\t\t\tstruct exynos_drm_ipp_buffer *buf)\n{\n\tu32 val;\n\n\t \n\tval = ROT_SET_BUF_SIZE_H(buf->buf.height) |\n\t      ROT_SET_BUF_SIZE_W(buf->buf.pitch[0] / buf->format->cpp[0]);\n\trot_write(val, ROT_DST_BUF_SIZE);\n\n\t \n\tval = ROT_CROP_POS_Y(buf->rect.y) | ROT_CROP_POS_X(buf->rect.x);\n\trot_write(val, ROT_DST_CROP_POS);\n\n\t \n\trot_write(buf->dma_addr[0], ROT_DST_BUF_ADDR(0));\n\trot_write(buf->dma_addr[1], ROT_DST_BUF_ADDR(1));\n}\n\nstatic void rotator_start(struct rot_context *rot)\n{\n\tu32 val;\n\n\t \n\trotator_reg_set_irq(rot, true);\n\n\tval = rot_read(ROT_CONTROL);\n\tval |= ROT_CONTROL_START;\n\trot_write(val, ROT_CONTROL);\n}\n\nstatic int rotator_commit(struct exynos_drm_ipp *ipp,\n\t\t\t  struct exynos_drm_ipp_task *task)\n{\n\tstruct rot_context *rot =\n\t\t\tcontainer_of(ipp, struct rot_context, ipp);\n\tint ret;\n\n\tret = pm_runtime_resume_and_get(rot->dev);\n\tif (ret < 0) {\n\t\tdev_err(rot->dev, \"failed to enable ROTATOR device.\\n\");\n\t\treturn ret;\n\t}\n\trot->task = task;\n\n\trotator_src_set_fmt(rot, task->src.buf.fourcc);\n\trotator_src_set_buf(rot, &task->src);\n\trotator_dst_set_transf(rot, task->transform.rotation);\n\trotator_dst_set_buf(rot, &task->dst);\n\trotator_start(rot);\n\n\treturn 0;\n}\n\nstatic const struct exynos_drm_ipp_funcs ipp_funcs = {\n\t.commit = rotator_commit,\n};\n\nstatic int rotator_bind(struct device *dev, struct device *master, void *data)\n{\n\tstruct rot_context *rot = dev_get_drvdata(dev);\n\tstruct drm_device *drm_dev = data;\n\tstruct exynos_drm_ipp *ipp = &rot->ipp;\n\n\trot->drm_dev = drm_dev;\n\tipp->drm_dev = drm_dev;\n\texynos_drm_register_dma(drm_dev, dev, &rot->dma_priv);\n\n\texynos_drm_ipp_register(dev, ipp, &ipp_funcs,\n\t\t\t   DRM_EXYNOS_IPP_CAP_CROP | DRM_EXYNOS_IPP_CAP_ROTATE,\n\t\t\t   rot->formats, rot->num_formats, \"rotator\");\n\n\tdev_info(dev, \"The exynos rotator has been probed successfully\\n\");\n\n\treturn 0;\n}\n\nstatic void rotator_unbind(struct device *dev, struct device *master,\n\t\t\tvoid *data)\n{\n\tstruct rot_context *rot = dev_get_drvdata(dev);\n\tstruct exynos_drm_ipp *ipp = &rot->ipp;\n\n\texynos_drm_ipp_unregister(dev, ipp);\n\texynos_drm_unregister_dma(rot->drm_dev, rot->dev, &rot->dma_priv);\n}\n\nstatic const struct component_ops rotator_component_ops = {\n\t.bind\t= rotator_bind,\n\t.unbind = rotator_unbind,\n};\n\nstatic int rotator_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct rot_context *rot;\n\tconst struct rot_variant *variant;\n\tint irq;\n\tint ret;\n\n\trot = devm_kzalloc(dev, sizeof(*rot), GFP_KERNEL);\n\tif (!rot)\n\t\treturn -ENOMEM;\n\n\tvariant = of_device_get_match_data(dev);\n\trot->formats = variant->formats;\n\trot->num_formats = variant->num_formats;\n\trot->dev = dev;\n\trot->regs = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(rot->regs))\n\t\treturn PTR_ERR(rot->regs);\n\n\tirq = platform_get_irq(pdev, 0);\n\tif (irq < 0)\n\t\treturn irq;\n\n\tret = devm_request_irq(dev, irq, rotator_irq_handler, 0, dev_name(dev),\n\t\t\t       rot);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"failed to request irq\\n\");\n\t\treturn ret;\n\t}\n\n\trot->clock = devm_clk_get(dev, \"rotator\");\n\tif (IS_ERR(rot->clock)) {\n\t\tdev_err(dev, \"failed to get clock\\n\");\n\t\treturn PTR_ERR(rot->clock);\n\t}\n\n\tpm_runtime_use_autosuspend(dev);\n\tpm_runtime_set_autosuspend_delay(dev, ROTATOR_AUTOSUSPEND_DELAY);\n\tpm_runtime_enable(dev);\n\tplatform_set_drvdata(pdev, rot);\n\n\tret = component_add(dev, &rotator_component_ops);\n\tif (ret)\n\t\tgoto err_component;\n\n\treturn 0;\n\nerr_component:\n\tpm_runtime_dont_use_autosuspend(dev);\n\tpm_runtime_disable(dev);\n\treturn ret;\n}\n\nstatic int rotator_remove(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\n\tcomponent_del(dev, &rotator_component_ops);\n\tpm_runtime_dont_use_autosuspend(dev);\n\tpm_runtime_disable(dev);\n\n\treturn 0;\n}\n\nstatic int rotator_runtime_suspend(struct device *dev)\n{\n\tstruct rot_context *rot = dev_get_drvdata(dev);\n\n\tclk_disable_unprepare(rot->clock);\n\treturn 0;\n}\n\nstatic int rotator_runtime_resume(struct device *dev)\n{\n\tstruct rot_context *rot = dev_get_drvdata(dev);\n\n\treturn clk_prepare_enable(rot->clock);\n}\n\nstatic const struct drm_exynos_ipp_limit rotator_s5pv210_rbg888_limits[] = {\n\t{ IPP_SIZE_LIMIT(BUFFER, .h = { 8, SZ_16K }, .v = { 8, SZ_16K }) },\n\t{ IPP_SIZE_LIMIT(AREA, .h.align = 2, .v.align = 2) },\n};\n\nstatic const struct drm_exynos_ipp_limit rotator_4210_rbg888_limits[] = {\n\t{ IPP_SIZE_LIMIT(BUFFER, .h = { 8, SZ_16K }, .v = { 8, SZ_16K }) },\n\t{ IPP_SIZE_LIMIT(AREA, .h.align = 4, .v.align = 4) },\n};\n\nstatic const struct drm_exynos_ipp_limit rotator_4412_rbg888_limits[] = {\n\t{ IPP_SIZE_LIMIT(BUFFER, .h = { 8, SZ_8K }, .v = { 8, SZ_8K }) },\n\t{ IPP_SIZE_LIMIT(AREA, .h.align = 4, .v.align = 4) },\n};\n\nstatic const struct drm_exynos_ipp_limit rotator_5250_rbg888_limits[] = {\n\t{ IPP_SIZE_LIMIT(BUFFER, .h = { 8, SZ_8K }, .v = { 8, SZ_8K }) },\n\t{ IPP_SIZE_LIMIT(AREA, .h.align = 2, .v.align = 2) },\n};\n\nstatic const struct drm_exynos_ipp_limit rotator_s5pv210_yuv_limits[] = {\n\t{ IPP_SIZE_LIMIT(BUFFER, .h = { 32, SZ_64K }, .v = { 32, SZ_64K }) },\n\t{ IPP_SIZE_LIMIT(AREA, .h.align = 8, .v.align = 8) },\n};\n\nstatic const struct drm_exynos_ipp_limit rotator_4210_yuv_limits[] = {\n\t{ IPP_SIZE_LIMIT(BUFFER, .h = { 32, SZ_64K }, .v = { 32, SZ_64K }) },\n\t{ IPP_SIZE_LIMIT(AREA, .h.align = 8, .v.align = 8) },\n};\n\nstatic const struct drm_exynos_ipp_limit rotator_4412_yuv_limits[] = {\n\t{ IPP_SIZE_LIMIT(BUFFER, .h = { 32, SZ_32K }, .v = { 32, SZ_32K }) },\n\t{ IPP_SIZE_LIMIT(AREA, .h.align = 8, .v.align = 8) },\n};\n\nstatic const struct exynos_drm_ipp_formats rotator_s5pv210_formats[] = {\n\t{ IPP_SRCDST_FORMAT(XRGB8888, rotator_s5pv210_rbg888_limits) },\n\t{ IPP_SRCDST_FORMAT(NV12, rotator_s5pv210_yuv_limits) },\n};\n\nstatic const struct exynos_drm_ipp_formats rotator_4210_formats[] = {\n\t{ IPP_SRCDST_FORMAT(XRGB8888, rotator_4210_rbg888_limits) },\n\t{ IPP_SRCDST_FORMAT(NV12, rotator_4210_yuv_limits) },\n};\n\nstatic const struct exynos_drm_ipp_formats rotator_4412_formats[] = {\n\t{ IPP_SRCDST_FORMAT(XRGB8888, rotator_4412_rbg888_limits) },\n\t{ IPP_SRCDST_FORMAT(NV12, rotator_4412_yuv_limits) },\n};\n\nstatic const struct exynos_drm_ipp_formats rotator_5250_formats[] = {\n\t{ IPP_SRCDST_FORMAT(XRGB8888, rotator_5250_rbg888_limits) },\n\t{ IPP_SRCDST_FORMAT(NV12, rotator_4412_yuv_limits) },\n};\n\nstatic const struct rot_variant rotator_s5pv210_data = {\n\t.formats = rotator_s5pv210_formats,\n\t.num_formats = ARRAY_SIZE(rotator_s5pv210_formats),\n};\n\nstatic const struct rot_variant rotator_4210_data = {\n\t.formats = rotator_4210_formats,\n\t.num_formats = ARRAY_SIZE(rotator_4210_formats),\n};\n\nstatic const struct rot_variant rotator_4412_data = {\n\t.formats = rotator_4412_formats,\n\t.num_formats = ARRAY_SIZE(rotator_4412_formats),\n};\n\nstatic const struct rot_variant rotator_5250_data = {\n\t.formats = rotator_5250_formats,\n\t.num_formats = ARRAY_SIZE(rotator_5250_formats),\n};\n\nstatic const struct of_device_id exynos_rotator_match[] = {\n\t{\n\t\t.compatible = \"samsung,s5pv210-rotator\",\n\t\t.data = &rotator_s5pv210_data,\n\t}, {\n\t\t.compatible = \"samsung,exynos4210-rotator\",\n\t\t.data = &rotator_4210_data,\n\t}, {\n\t\t.compatible = \"samsung,exynos4212-rotator\",\n\t\t.data = &rotator_4412_data,\n\t}, {\n\t\t.compatible = \"samsung,exynos5250-rotator\",\n\t\t.data = &rotator_5250_data,\n\t}, {\n\t},\n};\nMODULE_DEVICE_TABLE(of, exynos_rotator_match);\n\nstatic DEFINE_RUNTIME_DEV_PM_OPS(rotator_pm_ops, rotator_runtime_suspend,\n\t\t\t\t rotator_runtime_resume, NULL);\n\nstruct platform_driver rotator_driver = {\n\t.probe\t\t= rotator_probe,\n\t.remove\t\t= rotator_remove,\n\t.driver\t\t= {\n\t\t.name\t= \"exynos-rotator\",\n\t\t.owner\t= THIS_MODULE,\n\t\t.pm\t= pm_ptr(&rotator_pm_ops),\n\t\t.of_match_table = exynos_rotator_match,\n\t},\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}