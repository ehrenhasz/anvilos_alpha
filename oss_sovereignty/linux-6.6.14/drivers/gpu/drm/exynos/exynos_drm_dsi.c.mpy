{
  "module_name": "exynos_drm_dsi.c",
  "hash_id": "1654528eb638866bd39dd4f3844009d69550cb864f05a7621d100cfe075ff436",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/exynos/exynos_drm_dsi.c",
  "human_readable_source": "\n \n\n#include <linux/component.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n\n#include <drm/bridge/samsung-dsim.h>\n#include <drm/drm_probe_helper.h>\n#include <drm/drm_simple_kms_helper.h>\n\n#include \"exynos_drm_crtc.h\"\n#include \"exynos_drm_drv.h\"\n\nstruct exynos_dsi {\n\tstruct drm_encoder encoder;\n};\n\nstatic irqreturn_t exynos_dsi_te_irq_handler(struct samsung_dsim *dsim)\n{\n\tstruct exynos_dsi *dsi = dsim->priv;\n\tstruct drm_encoder *encoder = &dsi->encoder;\n\n\tif (dsim->state & DSIM_STATE_VIDOUT_AVAILABLE)\n\t\texynos_drm_crtc_te_handler(encoder->crtc);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int exynos_dsi_host_attach(struct samsung_dsim *dsim,\n\t\t\t\t  struct mipi_dsi_device *device)\n{\n\tstruct exynos_dsi *dsi = dsim->priv;\n\tstruct drm_encoder *encoder = &dsi->encoder;\n\tstruct drm_device *drm = encoder->dev;\n\n\tdrm_bridge_attach(encoder, &dsim->bridge,\n\t\t\t  list_first_entry_or_null(&encoder->bridge_chain,\n\t\t\t\t\t\t   struct drm_bridge,\n\t\t\t\t\t\t   chain_node), 0);\n\n\tmutex_lock(&drm->mode_config.mutex);\n\n\tdsim->lanes = device->lanes;\n\tdsim->format = device->format;\n\tdsim->mode_flags = device->mode_flags;\n\texynos_drm_crtc_get_by_type(drm, EXYNOS_DISPLAY_TYPE_LCD)->i80_mode =\n\t\t\t!(dsim->mode_flags & MIPI_DSI_MODE_VIDEO);\n\n\tmutex_unlock(&drm->mode_config.mutex);\n\n\tif (drm->mode_config.poll_enabled)\n\t\tdrm_kms_helper_hotplug_event(drm);\n\n\treturn 0;\n}\n\nstatic void exynos_dsi_host_detach(struct samsung_dsim *dsim,\n\t\t\t\t   struct mipi_dsi_device *device)\n{\n\tstruct exynos_dsi *dsi = dsim->priv;\n\tstruct drm_device *drm = dsi->encoder.dev;\n\n\tif (drm->mode_config.poll_enabled)\n\t\tdrm_kms_helper_hotplug_event(drm);\n}\n\nstatic int exynos_dsi_bind(struct device *dev, struct device *master, void *data)\n{\n\tstruct samsung_dsim *dsim = dev_get_drvdata(dev);\n\tstruct exynos_dsi *dsi = dsim->priv;\n\tstruct drm_encoder *encoder = &dsi->encoder;\n\tstruct drm_device *drm_dev = data;\n\tint ret;\n\n\tdrm_simple_encoder_init(drm_dev, encoder, DRM_MODE_ENCODER_TMDS);\n\n\tret = exynos_drm_set_possible_crtcs(encoder, EXYNOS_DISPLAY_TYPE_LCD);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn mipi_dsi_host_register(&dsim->dsi_host);\n}\n\nstatic void exynos_dsi_unbind(struct device *dev, struct device *master, void *data)\n{\n\tstruct samsung_dsim *dsim = dev_get_drvdata(dev);\n\n\tdsim->bridge.funcs->atomic_disable(&dsim->bridge, NULL);\n\n\tmipi_dsi_host_unregister(&dsim->dsi_host);\n}\n\nstatic const struct component_ops exynos_dsi_component_ops = {\n\t.bind\t= exynos_dsi_bind,\n\t.unbind\t= exynos_dsi_unbind,\n};\n\nstatic int exynos_dsi_register_host(struct samsung_dsim *dsim)\n{\n\tstruct exynos_dsi *dsi;\n\n\tdsi = devm_kzalloc(dsim->dev, sizeof(*dsi), GFP_KERNEL);\n\tif (!dsi)\n\t\treturn -ENOMEM;\n\n\tdsim->priv = dsi;\n\tdsim->bridge.pre_enable_prev_first = true;\n\n\treturn component_add(dsim->dev, &exynos_dsi_component_ops);\n}\n\nstatic void exynos_dsi_unregister_host(struct samsung_dsim *dsim)\n{\n\tcomponent_del(dsim->dev, &exynos_dsi_component_ops);\n}\n\nstatic const struct samsung_dsim_host_ops exynos_dsi_exynos_host_ops = {\n\t.register_host = exynos_dsi_register_host,\n\t.unregister_host = exynos_dsi_unregister_host,\n\t.attach = exynos_dsi_host_attach,\n\t.detach = exynos_dsi_host_detach,\n\t.te_irq_handler = exynos_dsi_te_irq_handler,\n};\n\nstatic const struct samsung_dsim_plat_data exynos3250_dsi_pdata = {\n\t.hw_type = DSIM_TYPE_EXYNOS3250,\n\t.host_ops = &exynos_dsi_exynos_host_ops,\n};\n\nstatic const struct samsung_dsim_plat_data exynos4210_dsi_pdata = {\n\t.hw_type = DSIM_TYPE_EXYNOS4210,\n\t.host_ops = &exynos_dsi_exynos_host_ops,\n};\n\nstatic const struct samsung_dsim_plat_data exynos5410_dsi_pdata = {\n\t.hw_type = DSIM_TYPE_EXYNOS5410,\n\t.host_ops = &exynos_dsi_exynos_host_ops,\n};\n\nstatic const struct samsung_dsim_plat_data exynos5422_dsi_pdata = {\n\t.hw_type = DSIM_TYPE_EXYNOS5422,\n\t.host_ops = &exynos_dsi_exynos_host_ops,\n};\n\nstatic const struct samsung_dsim_plat_data exynos5433_dsi_pdata = {\n\t.hw_type = DSIM_TYPE_EXYNOS5433,\n\t.host_ops = &exynos_dsi_exynos_host_ops,\n};\n\nstatic const struct of_device_id exynos_dsi_of_match[] = {\n\t{\n\t\t.compatible = \"samsung,exynos3250-mipi-dsi\",\n\t\t.data = &exynos3250_dsi_pdata,\n\t},\n\t{\n\t\t.compatible = \"samsung,exynos4210-mipi-dsi\",\n\t\t.data = &exynos4210_dsi_pdata,\n\t},\n\t{\n\t\t.compatible = \"samsung,exynos5410-mipi-dsi\",\n\t\t.data = &exynos5410_dsi_pdata,\n\t},\n\t{\n\t\t.compatible = \"samsung,exynos5422-mipi-dsi\",\n\t\t.data = &exynos5422_dsi_pdata,\n\t},\n\t{\n\t\t.compatible = \"samsung,exynos5433-mipi-dsi\",\n\t\t.data = &exynos5433_dsi_pdata,\n\t},\n\t{   }\n};\nMODULE_DEVICE_TABLE(of, exynos_dsi_of_match);\n\nstruct platform_driver dsi_driver = {\n\t.probe = samsung_dsim_probe,\n\t.remove = samsung_dsim_remove,\n\t.driver = {\n\t\t   .name = \"exynos-dsi\",\n\t\t   .owner = THIS_MODULE,\n\t\t   .pm = &samsung_dsim_pm_ops,\n\t\t   .of_match_table = exynos_dsi_of_match,\n\t},\n};\n\nMODULE_AUTHOR(\"Tomasz Figa <t.figa@samsung.com>\");\nMODULE_AUTHOR(\"Andrzej Hajda <a.hajda@samsung.com>\");\nMODULE_DESCRIPTION(\"Samsung SoC MIPI DSI Master\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}