{
  "module_name": "exynos_drm_ipp.c",
  "hash_id": "d1aaf963e9f968976eba65221272bd259daf282a37bfd4113f034786221da4be",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/exynos/exynos_drm_ipp.c",
  "human_readable_source": " \n\n#include <linux/uaccess.h>\n\n#include <drm/drm_blend.h>\n#include <drm/drm_file.h>\n#include <drm/drm_fourcc.h>\n#include <drm/drm_mode.h>\n#include <drm/exynos_drm.h>\n\n#include \"exynos_drm_drv.h\"\n#include \"exynos_drm_gem.h\"\n#include \"exynos_drm_ipp.h\"\n\nstatic int num_ipp;\nstatic LIST_HEAD(ipp_list);\n\n \nint exynos_drm_ipp_register(struct device *dev, struct exynos_drm_ipp *ipp,\n\t\tconst struct exynos_drm_ipp_funcs *funcs, unsigned int caps,\n\t\tconst struct exynos_drm_ipp_formats *formats,\n\t\tunsigned int num_formats, const char *name)\n{\n\tWARN_ON(!ipp);\n\tWARN_ON(!funcs);\n\tWARN_ON(!formats);\n\tWARN_ON(!num_formats);\n\n\tspin_lock_init(&ipp->lock);\n\tINIT_LIST_HEAD(&ipp->todo_list);\n\tinit_waitqueue_head(&ipp->done_wq);\n\tipp->dev = dev;\n\tipp->funcs = funcs;\n\tipp->capabilities = caps;\n\tipp->name = name;\n\tipp->formats = formats;\n\tipp->num_formats = num_formats;\n\n\t \n\tlist_add_tail(&ipp->head, &ipp_list);\n\tipp->id = num_ipp++;\n\n\tDRM_DEV_DEBUG_DRIVER(dev, \"Registered ipp %d\\n\", ipp->id);\n\n\treturn 0;\n}\n\n \nvoid exynos_drm_ipp_unregister(struct device *dev,\n\t\t\t       struct exynos_drm_ipp *ipp)\n{\n\tWARN_ON(ipp->task);\n\tWARN_ON(!list_empty(&ipp->todo_list));\n\tlist_del(&ipp->head);\n}\n\n \nint exynos_drm_ipp_get_res_ioctl(struct drm_device *dev, void *data,\n\t\t\t\t struct drm_file *file_priv)\n{\n\tstruct drm_exynos_ioctl_ipp_get_res *resp = data;\n\tstruct exynos_drm_ipp *ipp;\n\tuint32_t __user *ipp_ptr = (uint32_t __user *)\n\t\t\t\t\t\t(unsigned long)resp->ipp_id_ptr;\n\tunsigned int count = num_ipp, copied = 0;\n\n\t \n\tif (count && resp->count_ipps >= count) {\n\t\tlist_for_each_entry(ipp, &ipp_list, head) {\n\t\t\tif (put_user(ipp->id, ipp_ptr + copied))\n\t\t\t\treturn -EFAULT;\n\t\t\tcopied++;\n\t\t}\n\t}\n\tresp->count_ipps = count;\n\n\treturn 0;\n}\n\nstatic inline struct exynos_drm_ipp *__ipp_get(uint32_t id)\n{\n\tstruct exynos_drm_ipp *ipp;\n\n\tlist_for_each_entry(ipp, &ipp_list, head)\n\t\tif (ipp->id == id)\n\t\t\treturn ipp;\n\treturn NULL;\n}\n\n \nint exynos_drm_ipp_get_caps_ioctl(struct drm_device *dev, void *data,\n\t\t\t\t  struct drm_file *file_priv)\n{\n\tstruct drm_exynos_ioctl_ipp_get_caps *resp = data;\n\tvoid __user *ptr = (void __user *)(unsigned long)resp->formats_ptr;\n\tstruct exynos_drm_ipp *ipp;\n\tint i;\n\n\tipp = __ipp_get(resp->ipp_id);\n\tif (!ipp)\n\t\treturn -ENOENT;\n\n\tresp->ipp_id = ipp->id;\n\tresp->capabilities = ipp->capabilities;\n\n\t \n\tif (resp->formats_count >= ipp->num_formats) {\n\t\tfor (i = 0; i < ipp->num_formats; i++) {\n\t\t\tstruct drm_exynos_ipp_format tmp = {\n\t\t\t\t.fourcc = ipp->formats[i].fourcc,\n\t\t\t\t.type = ipp->formats[i].type,\n\t\t\t\t.modifier = ipp->formats[i].modifier,\n\t\t\t};\n\n\t\t\tif (copy_to_user(ptr, &tmp, sizeof(tmp)))\n\t\t\t\treturn -EFAULT;\n\t\t\tptr += sizeof(tmp);\n\t\t}\n\t}\n\tresp->formats_count = ipp->num_formats;\n\n\treturn 0;\n}\n\nstatic inline const struct exynos_drm_ipp_formats *__ipp_format_get(\n\t\t\t\tstruct exynos_drm_ipp *ipp, uint32_t fourcc,\n\t\t\t\tuint64_t mod, unsigned int type)\n{\n\tint i;\n\n\tfor (i = 0; i < ipp->num_formats; i++) {\n\t\tif ((ipp->formats[i].type & type) &&\n\t\t    ipp->formats[i].fourcc == fourcc &&\n\t\t    ipp->formats[i].modifier == mod)\n\t\t\treturn &ipp->formats[i];\n\t}\n\treturn NULL;\n}\n\n \nint exynos_drm_ipp_get_limits_ioctl(struct drm_device *dev, void *data,\n\t\t\t\t    struct drm_file *file_priv)\n{\n\tstruct drm_exynos_ioctl_ipp_get_limits *resp = data;\n\tvoid __user *ptr = (void __user *)(unsigned long)resp->limits_ptr;\n\tconst struct exynos_drm_ipp_formats *format;\n\tstruct exynos_drm_ipp *ipp;\n\n\tif (resp->type != DRM_EXYNOS_IPP_FORMAT_SOURCE &&\n\t    resp->type != DRM_EXYNOS_IPP_FORMAT_DESTINATION)\n\t\treturn -EINVAL;\n\n\tipp = __ipp_get(resp->ipp_id);\n\tif (!ipp)\n\t\treturn -ENOENT;\n\n\tformat = __ipp_format_get(ipp, resp->fourcc, resp->modifier,\n\t\t\t\t  resp->type);\n\tif (!format)\n\t\treturn -EINVAL;\n\n\t \n\tif (format->num_limits && resp->limits_count >= format->num_limits)\n\t\tif (copy_to_user((void __user *)ptr, format->limits,\n\t\t\t\t sizeof(*format->limits) * format->num_limits))\n\t\t\treturn -EFAULT;\n\tresp->limits_count = format->num_limits;\n\n\treturn 0;\n}\n\nstruct drm_pending_exynos_ipp_event {\n\tstruct drm_pending_event base;\n\tstruct drm_exynos_ipp_event event;\n};\n\nstatic inline struct exynos_drm_ipp_task *\n\t\t\texynos_drm_ipp_task_alloc(struct exynos_drm_ipp *ipp)\n{\n\tstruct exynos_drm_ipp_task *task;\n\n\ttask = kzalloc(sizeof(*task), GFP_KERNEL);\n\tif (!task)\n\t\treturn NULL;\n\n\ttask->dev = ipp->dev;\n\ttask->ipp = ipp;\n\n\t \n\ttask->src.rect.w = task->dst.rect.w = UINT_MAX;\n\ttask->src.rect.h = task->dst.rect.h = UINT_MAX;\n\ttask->transform.rotation = DRM_MODE_ROTATE_0;\n\n\tDRM_DEV_DEBUG_DRIVER(task->dev, \"Allocated task %pK\\n\", task);\n\n\treturn task;\n}\n\nstatic const struct exynos_drm_param_map {\n\tunsigned int id;\n\tunsigned int size;\n\tunsigned int offset;\n} exynos_drm_ipp_params_maps[] = {\n\t{\n\t\tDRM_EXYNOS_IPP_TASK_BUFFER | DRM_EXYNOS_IPP_TASK_TYPE_SOURCE,\n\t\tsizeof(struct drm_exynos_ipp_task_buffer),\n\t\toffsetof(struct exynos_drm_ipp_task, src.buf),\n\t}, {\n\t\tDRM_EXYNOS_IPP_TASK_BUFFER |\n\t\t\tDRM_EXYNOS_IPP_TASK_TYPE_DESTINATION,\n\t\tsizeof(struct drm_exynos_ipp_task_buffer),\n\t\toffsetof(struct exynos_drm_ipp_task, dst.buf),\n\t}, {\n\t\tDRM_EXYNOS_IPP_TASK_RECTANGLE | DRM_EXYNOS_IPP_TASK_TYPE_SOURCE,\n\t\tsizeof(struct drm_exynos_ipp_task_rect),\n\t\toffsetof(struct exynos_drm_ipp_task, src.rect),\n\t}, {\n\t\tDRM_EXYNOS_IPP_TASK_RECTANGLE |\n\t\t\tDRM_EXYNOS_IPP_TASK_TYPE_DESTINATION,\n\t\tsizeof(struct drm_exynos_ipp_task_rect),\n\t\toffsetof(struct exynos_drm_ipp_task, dst.rect),\n\t}, {\n\t\tDRM_EXYNOS_IPP_TASK_TRANSFORM,\n\t\tsizeof(struct drm_exynos_ipp_task_transform),\n\t\toffsetof(struct exynos_drm_ipp_task, transform),\n\t}, {\n\t\tDRM_EXYNOS_IPP_TASK_ALPHA,\n\t\tsizeof(struct drm_exynos_ipp_task_alpha),\n\t\toffsetof(struct exynos_drm_ipp_task, alpha),\n\t},\n};\n\nstatic int exynos_drm_ipp_task_set(struct exynos_drm_ipp_task *task,\n\t\t\t\t   struct drm_exynos_ioctl_ipp_commit *arg)\n{\n\tconst struct exynos_drm_param_map *map = exynos_drm_ipp_params_maps;\n\tvoid __user *params = (void __user *)(unsigned long)arg->params_ptr;\n\tunsigned int size = arg->params_size;\n\tuint32_t id;\n\tint i;\n\n\twhile (size) {\n\t\tif (get_user(id, (uint32_t __user *)params))\n\t\t\treturn -EFAULT;\n\n\t\tfor (i = 0; i < ARRAY_SIZE(exynos_drm_ipp_params_maps); i++)\n\t\t\tif (map[i].id == id)\n\t\t\t\tbreak;\n\t\tif (i == ARRAY_SIZE(exynos_drm_ipp_params_maps) ||\n\t\t    map[i].size > size)\n\t\t\treturn -EINVAL;\n\n\t\tif (copy_from_user((void *)task + map[i].offset, params,\n\t\t\t\t   map[i].size))\n\t\t\treturn -EFAULT;\n\n\t\tparams += map[i].size;\n\t\tsize -= map[i].size;\n\t}\n\n\tDRM_DEV_DEBUG_DRIVER(task->dev,\n\t\t\t     \"Got task %pK configuration from userspace\\n\",\n\t\t\t     task);\n\treturn 0;\n}\n\nstatic int exynos_drm_ipp_task_setup_buffer(struct exynos_drm_ipp_buffer *buf,\n\t\t\t\t\t    struct drm_file *filp)\n{\n\tint ret = 0;\n\tint i;\n\n\t \n\tfor (i = 0; i < buf->format->num_planes; i++) {\n\t\tunsigned int height = (i == 0) ? buf->buf.height :\n\t\t\t     DIV_ROUND_UP(buf->buf.height, buf->format->vsub);\n\t\tunsigned long size = height * buf->buf.pitch[i];\n\t\tstruct exynos_drm_gem *gem = exynos_drm_gem_get(filp,\n\t\t\t\t\t\t\t    buf->buf.gem_id[i]);\n\t\tif (!gem) {\n\t\t\tret = -ENOENT;\n\t\t\tgoto gem_free;\n\t\t}\n\t\tbuf->exynos_gem[i] = gem;\n\n\t\tif (size + buf->buf.offset[i] > buf->exynos_gem[i]->size) {\n\t\t\ti++;\n\t\t\tret = -EINVAL;\n\t\t\tgoto gem_free;\n\t\t}\n\t\tbuf->dma_addr[i] = buf->exynos_gem[i]->dma_addr +\n\t\t\t\t   buf->buf.offset[i];\n\t}\n\n\treturn 0;\ngem_free:\n\twhile (i--) {\n\t\texynos_drm_gem_put(buf->exynos_gem[i]);\n\t\tbuf->exynos_gem[i] = NULL;\n\t}\n\treturn ret;\n}\n\nstatic void exynos_drm_ipp_task_release_buf(struct exynos_drm_ipp_buffer *buf)\n{\n\tint i;\n\n\tif (!buf->exynos_gem[0])\n\t\treturn;\n\tfor (i = 0; i < buf->format->num_planes; i++)\n\t\texynos_drm_gem_put(buf->exynos_gem[i]);\n}\n\nstatic void exynos_drm_ipp_task_free(struct exynos_drm_ipp *ipp,\n\t\t\t\t struct exynos_drm_ipp_task *task)\n{\n\tDRM_DEV_DEBUG_DRIVER(task->dev, \"Freeing task %pK\\n\", task);\n\n\texynos_drm_ipp_task_release_buf(&task->src);\n\texynos_drm_ipp_task_release_buf(&task->dst);\n\tif (task->event)\n\t\tdrm_event_cancel_free(ipp->drm_dev, &task->event->base);\n\tkfree(task);\n}\n\nstruct drm_ipp_limit {\n\tstruct drm_exynos_ipp_limit_val h;\n\tstruct drm_exynos_ipp_limit_val v;\n};\n\nenum drm_ipp_size_id {\n\tIPP_LIMIT_BUFFER, IPP_LIMIT_AREA, IPP_LIMIT_ROTATED, IPP_LIMIT_MAX\n};\n\nstatic const enum drm_exynos_ipp_limit_type limit_id_fallback[IPP_LIMIT_MAX][4] = {\n\t[IPP_LIMIT_BUFFER]  = { DRM_EXYNOS_IPP_LIMIT_SIZE_BUFFER },\n\t[IPP_LIMIT_AREA]    = { DRM_EXYNOS_IPP_LIMIT_SIZE_AREA,\n\t\t\t\tDRM_EXYNOS_IPP_LIMIT_SIZE_BUFFER },\n\t[IPP_LIMIT_ROTATED] = { DRM_EXYNOS_IPP_LIMIT_SIZE_ROTATED,\n\t\t\t\tDRM_EXYNOS_IPP_LIMIT_SIZE_AREA,\n\t\t\t\tDRM_EXYNOS_IPP_LIMIT_SIZE_BUFFER },\n};\n\nstatic inline void __limit_set_val(unsigned int *ptr, unsigned int val)\n{\n\tif (!*ptr)\n\t\t*ptr = val;\n}\n\nstatic void __get_size_limit(const struct drm_exynos_ipp_limit *limits,\n\t\t\t     unsigned int num_limits, enum drm_ipp_size_id id,\n\t\t\t     struct drm_ipp_limit *res)\n{\n\tconst struct drm_exynos_ipp_limit *l = limits;\n\tint i = 0;\n\n\tmemset(res, 0, sizeof(*res));\n\tfor (i = 0; limit_id_fallback[id][i]; i++)\n\t\tfor (l = limits; l - limits < num_limits; l++) {\n\t\t\tif (((l->type & DRM_EXYNOS_IPP_LIMIT_TYPE_MASK) !=\n\t\t\t      DRM_EXYNOS_IPP_LIMIT_TYPE_SIZE) ||\n\t\t\t    ((l->type & DRM_EXYNOS_IPP_LIMIT_SIZE_MASK) !=\n\t\t\t\t\t\t     limit_id_fallback[id][i]))\n\t\t\t\tcontinue;\n\t\t\t__limit_set_val(&res->h.min, l->h.min);\n\t\t\t__limit_set_val(&res->h.max, l->h.max);\n\t\t\t__limit_set_val(&res->h.align, l->h.align);\n\t\t\t__limit_set_val(&res->v.min, l->v.min);\n\t\t\t__limit_set_val(&res->v.max, l->v.max);\n\t\t\t__limit_set_val(&res->v.align, l->v.align);\n\t\t}\n}\n\nstatic inline bool __align_check(unsigned int val, unsigned int align)\n{\n\tif (align && (val & (align - 1))) {\n\t\tDRM_DEBUG_DRIVER(\"Value %d exceeds HW limits (align %d)\\n\",\n\t\t\t\t val, align);\n\t\treturn false;\n\t}\n\treturn true;\n}\n\nstatic inline bool __size_limit_check(unsigned int val,\n\t\t\t\t struct drm_exynos_ipp_limit_val *l)\n{\n\tif ((l->min && val < l->min) || (l->max && val > l->max)) {\n\t\tDRM_DEBUG_DRIVER(\"Value %d exceeds HW limits (min %d, max %d)\\n\",\n\t\t\t\t val, l->min, l->max);\n\t\treturn false;\n\t}\n\treturn __align_check(val, l->align);\n}\n\nstatic int exynos_drm_ipp_check_size_limits(struct exynos_drm_ipp_buffer *buf,\n\tconst struct drm_exynos_ipp_limit *limits, unsigned int num_limits,\n\tbool rotate, bool swap)\n{\n\tenum drm_ipp_size_id id = rotate ? IPP_LIMIT_ROTATED : IPP_LIMIT_AREA;\n\tstruct drm_ipp_limit l;\n\tstruct drm_exynos_ipp_limit_val *lh = &l.h, *lv = &l.v;\n\tint real_width = buf->buf.pitch[0] / buf->format->cpp[0];\n\n\tif (!limits)\n\t\treturn 0;\n\n\t__get_size_limit(limits, num_limits, IPP_LIMIT_BUFFER, &l);\n\tif (!__size_limit_check(real_width, &l.h) ||\n\t    !__size_limit_check(buf->buf.height, &l.v))\n\t\treturn -EINVAL;\n\n\tif (swap) {\n\t\tlv = &l.h;\n\t\tlh = &l.v;\n\t}\n\t__get_size_limit(limits, num_limits, id, &l);\n\tif (!__size_limit_check(buf->rect.w, lh) ||\n\t    !__align_check(buf->rect.x, lh->align) ||\n\t    !__size_limit_check(buf->rect.h, lv) ||\n\t    !__align_check(buf->rect.y, lv->align))\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nstatic inline bool __scale_limit_check(unsigned int src, unsigned int dst,\n\t\t\t\t       unsigned int min, unsigned int max)\n{\n\tif ((max && (dst << 16) > src * max) ||\n\t    (min && (dst << 16) < src * min)) {\n\t\tDRM_DEBUG_DRIVER(\"Scale from %d to %d exceeds HW limits (ratio min %d.%05d, max %d.%05d)\\n\",\n\t\t\t src, dst,\n\t\t\t min >> 16, 100000 * (min & 0xffff) / (1 << 16),\n\t\t\t max >> 16, 100000 * (max & 0xffff) / (1 << 16));\n\t\treturn false;\n\t}\n\treturn true;\n}\n\nstatic int exynos_drm_ipp_check_scale_limits(\n\t\t\t\tstruct drm_exynos_ipp_task_rect *src,\n\t\t\t\tstruct drm_exynos_ipp_task_rect *dst,\n\t\t\t\tconst struct drm_exynos_ipp_limit *limits,\n\t\t\t\tunsigned int num_limits, bool swap)\n{\n\tconst struct drm_exynos_ipp_limit_val *lh, *lv;\n\tint dw, dh;\n\n\tfor (; num_limits; limits++, num_limits--)\n\t\tif ((limits->type & DRM_EXYNOS_IPP_LIMIT_TYPE_MASK) ==\n\t\t    DRM_EXYNOS_IPP_LIMIT_TYPE_SCALE)\n\t\t\tbreak;\n\tif (!num_limits)\n\t\treturn 0;\n\n\tlh = (!swap) ? &limits->h : &limits->v;\n\tlv = (!swap) ? &limits->v : &limits->h;\n\tdw = (!swap) ? dst->w : dst->h;\n\tdh = (!swap) ? dst->h : dst->w;\n\n\tif (!__scale_limit_check(src->w, dw, lh->min, lh->max) ||\n\t    !__scale_limit_check(src->h, dh, lv->min, lv->max))\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nstatic int exynos_drm_ipp_check_format(struct exynos_drm_ipp_task *task,\n\t\t\t\t       struct exynos_drm_ipp_buffer *buf,\n\t\t\t\t       struct exynos_drm_ipp_buffer *src,\n\t\t\t\t       struct exynos_drm_ipp_buffer *dst,\n\t\t\t\t       bool rotate, bool swap)\n{\n\tconst struct exynos_drm_ipp_formats *fmt;\n\tint ret, i;\n\n\tfmt = __ipp_format_get(task->ipp, buf->buf.fourcc, buf->buf.modifier,\n\t\t\t       buf == src ? DRM_EXYNOS_IPP_FORMAT_SOURCE :\n\t\t\t\t\t    DRM_EXYNOS_IPP_FORMAT_DESTINATION);\n\tif (!fmt) {\n\t\tDRM_DEV_DEBUG_DRIVER(task->dev,\n\t\t\t\t     \"Task %pK: %s format not supported\\n\",\n\t\t\t\t     task, buf == src ? \"src\" : \"dst\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (buf->buf.width == 0 || buf->buf.height == 0)\n\t\treturn -EINVAL;\n\n\tbuf->format = drm_format_info(buf->buf.fourcc);\n\tfor (i = 0; i < buf->format->num_planes; i++) {\n\t\tunsigned int width = (i == 0) ? buf->buf.width :\n\t\t\t     DIV_ROUND_UP(buf->buf.width, buf->format->hsub);\n\n\t\tif (buf->buf.pitch[i] == 0)\n\t\t\tbuf->buf.pitch[i] = width * buf->format->cpp[i];\n\t\tif (buf->buf.pitch[i] < width * buf->format->cpp[i])\n\t\t\treturn -EINVAL;\n\t\tif (!buf->buf.gem_id[i])\n\t\t\treturn -ENOENT;\n\t}\n\n\t \n\tif (buf->format->num_planes > 2 &&\n\t    buf->buf.pitch[1] != buf->buf.pitch[2])\n\t\treturn -EINVAL;\n\n\t \n\tret = exynos_drm_ipp_check_size_limits(buf, fmt->limits,\n\t\t\t\t\t       fmt->num_limits,\n\t\t\t\t\t       rotate,\n\t\t\t\t\t       buf == dst ? swap : false);\n\tif (ret)\n\t\treturn ret;\n\tret = exynos_drm_ipp_check_scale_limits(&src->rect, &dst->rect,\n\t\t\t\t\t\tfmt->limits,\n\t\t\t\t\t\tfmt->num_limits, swap);\n\treturn ret;\n}\n\nstatic int exynos_drm_ipp_task_check(struct exynos_drm_ipp_task *task)\n{\n\tstruct exynos_drm_ipp *ipp = task->ipp;\n\tstruct exynos_drm_ipp_buffer *src = &task->src, *dst = &task->dst;\n\tunsigned int rotation = task->transform.rotation;\n\tint ret = 0;\n\tbool swap = drm_rotation_90_or_270(rotation);\n\tbool rotate = (rotation != DRM_MODE_ROTATE_0);\n\tbool scale = false;\n\n\tDRM_DEV_DEBUG_DRIVER(task->dev, \"Checking task %pK\\n\", task);\n\n\tif (src->rect.w == UINT_MAX)\n\t\tsrc->rect.w = src->buf.width;\n\tif (src->rect.h == UINT_MAX)\n\t\tsrc->rect.h = src->buf.height;\n\tif (dst->rect.w == UINT_MAX)\n\t\tdst->rect.w = dst->buf.width;\n\tif (dst->rect.h == UINT_MAX)\n\t\tdst->rect.h = dst->buf.height;\n\n\tif (src->rect.x + src->rect.w > (src->buf.width) ||\n\t    src->rect.y + src->rect.h > (src->buf.height) ||\n\t    dst->rect.x + dst->rect.w > (dst->buf.width) ||\n\t    dst->rect.y + dst->rect.h > (dst->buf.height)) {\n\t\tDRM_DEV_DEBUG_DRIVER(task->dev,\n\t\t\t\t     \"Task %pK: defined area is outside provided buffers\\n\",\n\t\t\t\t     task);\n\t\treturn -EINVAL;\n\t}\n\n\tif ((!swap && (src->rect.w != dst->rect.w ||\n\t\t       src->rect.h != dst->rect.h)) ||\n\t    (swap && (src->rect.w != dst->rect.h ||\n\t\t      src->rect.h != dst->rect.w)))\n\t\tscale = true;\n\n\tif ((!(ipp->capabilities & DRM_EXYNOS_IPP_CAP_CROP) &&\n\t     (src->rect.x || src->rect.y || dst->rect.x || dst->rect.y)) ||\n\t    (!(ipp->capabilities & DRM_EXYNOS_IPP_CAP_ROTATE) && rotate) ||\n\t    (!(ipp->capabilities & DRM_EXYNOS_IPP_CAP_SCALE) && scale) ||\n\t    (!(ipp->capabilities & DRM_EXYNOS_IPP_CAP_CONVERT) &&\n\t     src->buf.fourcc != dst->buf.fourcc)) {\n\t\tDRM_DEV_DEBUG_DRIVER(task->dev, \"Task %pK: hw capabilities exceeded\\n\",\n\t\t\t\t     task);\n\t\treturn -EINVAL;\n\t}\n\n\tret = exynos_drm_ipp_check_format(task, src, src, dst, rotate, swap);\n\tif (ret)\n\t\treturn ret;\n\n\tret = exynos_drm_ipp_check_format(task, dst, src, dst, false, swap);\n\tif (ret)\n\t\treturn ret;\n\n\tDRM_DEV_DEBUG_DRIVER(ipp->dev, \"Task %pK: all checks done.\\n\",\n\t\t\t     task);\n\n\treturn ret;\n}\n\nstatic int exynos_drm_ipp_task_setup_buffers(struct exynos_drm_ipp_task *task,\n\t\t\t\t     struct drm_file *filp)\n{\n\tstruct exynos_drm_ipp_buffer *src = &task->src, *dst = &task->dst;\n\tint ret = 0;\n\n\tDRM_DEV_DEBUG_DRIVER(task->dev, \"Setting buffer for task %pK\\n\",\n\t\t\t     task);\n\n\tret = exynos_drm_ipp_task_setup_buffer(src, filp);\n\tif (ret) {\n\t\tDRM_DEV_DEBUG_DRIVER(task->dev,\n\t\t\t\t     \"Task %pK: src buffer setup failed\\n\",\n\t\t\t\t     task);\n\t\treturn ret;\n\t}\n\tret = exynos_drm_ipp_task_setup_buffer(dst, filp);\n\tif (ret) {\n\t\tDRM_DEV_DEBUG_DRIVER(task->dev,\n\t\t\t\t     \"Task %pK: dst buffer setup failed\\n\",\n\t\t\t\t     task);\n\t\treturn ret;\n\t}\n\n\tDRM_DEV_DEBUG_DRIVER(task->dev, \"Task %pK: buffers prepared.\\n\",\n\t\t\t     task);\n\n\treturn ret;\n}\n\n\nstatic int exynos_drm_ipp_event_create(struct exynos_drm_ipp_task *task,\n\t\t\t\t struct drm_file *file_priv, uint64_t user_data)\n{\n\tstruct drm_pending_exynos_ipp_event *e = NULL;\n\tint ret;\n\n\te = kzalloc(sizeof(*e), GFP_KERNEL);\n\tif (!e)\n\t\treturn -ENOMEM;\n\n\te->event.base.type = DRM_EXYNOS_IPP_EVENT;\n\te->event.base.length = sizeof(e->event);\n\te->event.user_data = user_data;\n\n\tret = drm_event_reserve_init(task->ipp->drm_dev, file_priv, &e->base,\n\t\t\t\t     &e->event.base);\n\tif (ret)\n\t\tgoto free;\n\n\ttask->event = e;\n\treturn 0;\nfree:\n\tkfree(e);\n\treturn ret;\n}\n\nstatic void exynos_drm_ipp_event_send(struct exynos_drm_ipp_task *task)\n{\n\tstruct timespec64 now;\n\n\tktime_get_ts64(&now);\n\ttask->event->event.tv_sec = now.tv_sec;\n\ttask->event->event.tv_usec = now.tv_nsec / NSEC_PER_USEC;\n\ttask->event->event.sequence = atomic_inc_return(&task->ipp->sequence);\n\n\tdrm_send_event(task->ipp->drm_dev, &task->event->base);\n}\n\nstatic int exynos_drm_ipp_task_cleanup(struct exynos_drm_ipp_task *task)\n{\n\tint ret = task->ret;\n\n\tif (ret == 0 && task->event) {\n\t\texynos_drm_ipp_event_send(task);\n\t\t \n\t\ttask->event = NULL;\n\t}\n\n\texynos_drm_ipp_task_free(task->ipp, task);\n\treturn ret;\n}\n\nstatic void exynos_drm_ipp_cleanup_work(struct work_struct *work)\n{\n\tstruct exynos_drm_ipp_task *task = container_of(work,\n\t\t\t\t      struct exynos_drm_ipp_task, cleanup_work);\n\n\texynos_drm_ipp_task_cleanup(task);\n}\n\nstatic void exynos_drm_ipp_next_task(struct exynos_drm_ipp *ipp);\n\n \nvoid exynos_drm_ipp_task_done(struct exynos_drm_ipp_task *task, int ret)\n{\n\tstruct exynos_drm_ipp *ipp = task->ipp;\n\tunsigned long flags;\n\n\tDRM_DEV_DEBUG_DRIVER(task->dev, \"ipp: %d, task %pK done: %d\\n\",\n\t\t\t     ipp->id, task, ret);\n\n\tspin_lock_irqsave(&ipp->lock, flags);\n\tif (ipp->task == task)\n\t\tipp->task = NULL;\n\ttask->flags |= DRM_EXYNOS_IPP_TASK_DONE;\n\ttask->ret = ret;\n\tspin_unlock_irqrestore(&ipp->lock, flags);\n\n\texynos_drm_ipp_next_task(ipp);\n\twake_up(&ipp->done_wq);\n\n\tif (task->flags & DRM_EXYNOS_IPP_TASK_ASYNC) {\n\t\tINIT_WORK(&task->cleanup_work, exynos_drm_ipp_cleanup_work);\n\t\tschedule_work(&task->cleanup_work);\n\t}\n}\n\nstatic void exynos_drm_ipp_next_task(struct exynos_drm_ipp *ipp)\n{\n\tstruct exynos_drm_ipp_task *task;\n\tunsigned long flags;\n\tint ret;\n\n\tDRM_DEV_DEBUG_DRIVER(ipp->dev, \"ipp: %d, try to run new task\\n\",\n\t\t\t     ipp->id);\n\n\tspin_lock_irqsave(&ipp->lock, flags);\n\n\tif (ipp->task || list_empty(&ipp->todo_list)) {\n\t\tspin_unlock_irqrestore(&ipp->lock, flags);\n\t\treturn;\n\t}\n\n\ttask = list_first_entry(&ipp->todo_list, struct exynos_drm_ipp_task,\n\t\t\t\thead);\n\tlist_del_init(&task->head);\n\tipp->task = task;\n\n\tspin_unlock_irqrestore(&ipp->lock, flags);\n\n\tDRM_DEV_DEBUG_DRIVER(ipp->dev,\n\t\t\t     \"ipp: %d, selected task %pK to run\\n\", ipp->id,\n\t\t\t     task);\n\n\tret = ipp->funcs->commit(ipp, task);\n\tif (ret)\n\t\texynos_drm_ipp_task_done(task, ret);\n}\n\nstatic void exynos_drm_ipp_schedule_task(struct exynos_drm_ipp *ipp,\n\t\t\t\t\t struct exynos_drm_ipp_task *task)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&ipp->lock, flags);\n\tlist_add(&task->head, &ipp->todo_list);\n\tspin_unlock_irqrestore(&ipp->lock, flags);\n\n\texynos_drm_ipp_next_task(ipp);\n}\n\nstatic void exynos_drm_ipp_task_abort(struct exynos_drm_ipp *ipp,\n\t\t\t\t      struct exynos_drm_ipp_task *task)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&ipp->lock, flags);\n\tif (task->flags & DRM_EXYNOS_IPP_TASK_DONE) {\n\t\t \n\t\texynos_drm_ipp_task_cleanup(task);\n\t} else if (ipp->task != task) {\n\t\t \n\t\tlist_del_init(&task->head);\n\t\texynos_drm_ipp_task_cleanup(task);\n\t} else {\n\t\t \n\t\ttask->flags |= DRM_EXYNOS_IPP_TASK_ASYNC;\n\t\tspin_unlock_irqrestore(&ipp->lock, flags);\n\t\tif (ipp->funcs->abort)\n\t\t\tipp->funcs->abort(ipp, task);\n\t\treturn;\n\t}\n\tspin_unlock_irqrestore(&ipp->lock, flags);\n}\n\n \nint exynos_drm_ipp_commit_ioctl(struct drm_device *dev, void *data,\n\t\t\t\tstruct drm_file *file_priv)\n{\n\tstruct drm_exynos_ioctl_ipp_commit *arg = data;\n\tstruct exynos_drm_ipp *ipp;\n\tstruct exynos_drm_ipp_task *task;\n\tint ret = 0;\n\n\tif ((arg->flags & ~DRM_EXYNOS_IPP_FLAGS) || arg->reserved)\n\t\treturn -EINVAL;\n\n\t \n\tif ((arg->flags & DRM_EXYNOS_IPP_FLAG_TEST_ONLY) &&\n\t\t\t(arg->flags & DRM_EXYNOS_IPP_FLAG_EVENT))\n\t\treturn -EINVAL;\n\n\tipp = __ipp_get(arg->ipp_id);\n\tif (!ipp)\n\t\treturn -ENOENT;\n\n\ttask = exynos_drm_ipp_task_alloc(ipp);\n\tif (!task)\n\t\treturn -ENOMEM;\n\n\tret = exynos_drm_ipp_task_set(task, arg);\n\tif (ret)\n\t\tgoto free;\n\n\tret = exynos_drm_ipp_task_check(task);\n\tif (ret)\n\t\tgoto free;\n\n\tret = exynos_drm_ipp_task_setup_buffers(task, file_priv);\n\tif (ret || arg->flags & DRM_EXYNOS_IPP_FLAG_TEST_ONLY)\n\t\tgoto free;\n\n\tif (arg->flags & DRM_EXYNOS_IPP_FLAG_EVENT) {\n\t\tret = exynos_drm_ipp_event_create(task, file_priv,\n\t\t\t\t\t\t arg->user_data);\n\t\tif (ret)\n\t\t\tgoto free;\n\t}\n\n\t \n\tif (arg->flags & DRM_EXYNOS_IPP_FLAG_NONBLOCK) {\n\t\tDRM_DEV_DEBUG_DRIVER(ipp->dev,\n\t\t\t\t     \"ipp: %d, nonblocking processing task %pK\\n\",\n\t\t\t\t     ipp->id, task);\n\n\t\ttask->flags |= DRM_EXYNOS_IPP_TASK_ASYNC;\n\t\texynos_drm_ipp_schedule_task(task->ipp, task);\n\t\tret = 0;\n\t} else {\n\t\tDRM_DEV_DEBUG_DRIVER(ipp->dev, \"ipp: %d, processing task %pK\\n\",\n\t\t\t\t     ipp->id, task);\n\t\texynos_drm_ipp_schedule_task(ipp, task);\n\t\tret = wait_event_interruptible(ipp->done_wq,\n\t\t\t\t\ttask->flags & DRM_EXYNOS_IPP_TASK_DONE);\n\t\tif (ret)\n\t\t\texynos_drm_ipp_task_abort(ipp, task);\n\t\telse\n\t\t\tret = exynos_drm_ipp_task_cleanup(task);\n\t}\n\treturn ret;\nfree:\n\texynos_drm_ipp_task_free(ipp, task);\n\n\treturn ret;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}