{
  "module_name": "exynos_drm_scaler.c",
  "hash_id": "e50ce7375e2f82fae17b63a924a8cc386dfe27ff1441ab2fc7f9dc15785a383e",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/exynos/exynos_drm_scaler.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/component.h>\n#include <linux/err.h>\n#include <linux/interrupt.h>\n#include <linux/io.h>\n#include <linux/kernel.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/pm_runtime.h>\n\n#include <drm/drm_blend.h>\n#include <drm/drm_fourcc.h>\n#include <drm/exynos_drm.h>\n\n#include \"exynos_drm_drv.h\"\n#include \"exynos_drm_fb.h\"\n#include \"exynos_drm_ipp.h\"\n#include \"regs-scaler.h\"\n\n#define scaler_read(offset)\t\treadl(scaler->regs + (offset))\n#define scaler_write(cfg, offset)\twritel(cfg, scaler->regs + (offset))\n#define SCALER_MAX_CLK\t\t\t4\n#define SCALER_AUTOSUSPEND_DELAY\t2000\n#define SCALER_RESET_WAIT_RETRIES\t100\n\nstruct scaler_data {\n\tconst char\t*clk_name[SCALER_MAX_CLK];\n\tunsigned int\tnum_clk;\n\tconst struct exynos_drm_ipp_formats *formats;\n\tunsigned int\tnum_formats;\n};\n\nstruct scaler_context {\n\tstruct exynos_drm_ipp\t\tipp;\n\tstruct drm_device\t\t*drm_dev;\n\tvoid\t\t\t\t*dma_priv;\n\tstruct device\t\t\t*dev;\n\tvoid __iomem\t\t\t*regs;\n\tstruct clk\t\t\t*clock[SCALER_MAX_CLK];\n\tstruct exynos_drm_ipp_task\t*task;\n\tconst struct scaler_data\t*scaler_data;\n};\n\nstruct scaler_format {\n\tu32\tdrm_fmt;\n\tu32\tinternal_fmt;\n\tu32\tchroma_tile_w;\n\tu32\tchroma_tile_h;\n};\n\nstatic const struct scaler_format scaler_formats[] = {\n\t{ DRM_FORMAT_NV12, SCALER_YUV420_2P_UV, 8, 8 },\n\t{ DRM_FORMAT_NV21, SCALER_YUV420_2P_VU, 8, 8 },\n\t{ DRM_FORMAT_YUV420, SCALER_YUV420_3P, 8, 8 },\n\t{ DRM_FORMAT_YUYV, SCALER_YUV422_1P_YUYV, 16, 16 },\n\t{ DRM_FORMAT_UYVY, SCALER_YUV422_1P_UYVY, 16, 16 },\n\t{ DRM_FORMAT_YVYU, SCALER_YUV422_1P_YVYU, 16, 16 },\n\t{ DRM_FORMAT_NV16, SCALER_YUV422_2P_UV, 8, 16 },\n\t{ DRM_FORMAT_NV61, SCALER_YUV422_2P_VU, 8, 16 },\n\t{ DRM_FORMAT_YUV422, SCALER_YUV422_3P, 8, 16 },\n\t{ DRM_FORMAT_NV24, SCALER_YUV444_2P_UV, 16, 16 },\n\t{ DRM_FORMAT_NV42, SCALER_YUV444_2P_VU, 16, 16 },\n\t{ DRM_FORMAT_YUV444, SCALER_YUV444_3P, 16, 16 },\n\t{ DRM_FORMAT_RGB565, SCALER_RGB_565, 0, 0 },\n\t{ DRM_FORMAT_XRGB1555, SCALER_ARGB1555, 0, 0 },\n\t{ DRM_FORMAT_ARGB1555, SCALER_ARGB1555, 0, 0 },\n\t{ DRM_FORMAT_XRGB4444, SCALER_ARGB4444, 0, 0 },\n\t{ DRM_FORMAT_ARGB4444, SCALER_ARGB4444, 0, 0 },\n\t{ DRM_FORMAT_XRGB8888, SCALER_ARGB8888, 0, 0 },\n\t{ DRM_FORMAT_ARGB8888, SCALER_ARGB8888, 0, 0 },\n\t{ DRM_FORMAT_RGBX8888, SCALER_RGBA8888, 0, 0 },\n\t{ DRM_FORMAT_RGBA8888, SCALER_RGBA8888, 0, 0 },\n};\n\nstatic const struct scaler_format *scaler_get_format(u32 drm_fmt)\n{\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(scaler_formats); i++)\n\t\tif (scaler_formats[i].drm_fmt == drm_fmt)\n\t\t\treturn &scaler_formats[i];\n\n\treturn NULL;\n}\n\nstatic inline int scaler_reset(struct scaler_context *scaler)\n{\n\tint retry = SCALER_RESET_WAIT_RETRIES;\n\n\tscaler_write(SCALER_CFG_SOFT_RESET, SCALER_CFG);\n\tdo {\n\t\tcpu_relax();\n\t} while (--retry > 1 &&\n\t\t scaler_read(SCALER_CFG) & SCALER_CFG_SOFT_RESET);\n\tdo {\n\t\tcpu_relax();\n\t\tscaler_write(1, SCALER_INT_EN);\n\t} while (--retry > 0 && scaler_read(SCALER_INT_EN) != 1);\n\n\treturn retry ? 0 : -EIO;\n}\n\nstatic inline void scaler_enable_int(struct scaler_context *scaler)\n{\n\tu32 val;\n\n\tval = SCALER_INT_EN_TIMEOUT |\n\t\tSCALER_INT_EN_ILLEGAL_BLEND |\n\t\tSCALER_INT_EN_ILLEGAL_RATIO |\n\t\tSCALER_INT_EN_ILLEGAL_DST_HEIGHT |\n\t\tSCALER_INT_EN_ILLEGAL_DST_WIDTH |\n\t\tSCALER_INT_EN_ILLEGAL_DST_V_POS |\n\t\tSCALER_INT_EN_ILLEGAL_DST_H_POS |\n\t\tSCALER_INT_EN_ILLEGAL_DST_C_SPAN |\n\t\tSCALER_INT_EN_ILLEGAL_DST_Y_SPAN |\n\t\tSCALER_INT_EN_ILLEGAL_DST_CR_BASE |\n\t\tSCALER_INT_EN_ILLEGAL_DST_CB_BASE |\n\t\tSCALER_INT_EN_ILLEGAL_DST_Y_BASE |\n\t\tSCALER_INT_EN_ILLEGAL_DST_COLOR |\n\t\tSCALER_INT_EN_ILLEGAL_SRC_HEIGHT |\n\t\tSCALER_INT_EN_ILLEGAL_SRC_WIDTH |\n\t\tSCALER_INT_EN_ILLEGAL_SRC_CV_POS |\n\t\tSCALER_INT_EN_ILLEGAL_SRC_CH_POS |\n\t\tSCALER_INT_EN_ILLEGAL_SRC_YV_POS |\n\t\tSCALER_INT_EN_ILLEGAL_SRC_YH_POS |\n\t\tSCALER_INT_EN_ILLEGAL_DST_SPAN |\n\t\tSCALER_INT_EN_ILLEGAL_SRC_Y_SPAN |\n\t\tSCALER_INT_EN_ILLEGAL_SRC_CR_BASE |\n\t\tSCALER_INT_EN_ILLEGAL_SRC_CB_BASE |\n\t\tSCALER_INT_EN_ILLEGAL_SRC_Y_BASE |\n\t\tSCALER_INT_EN_ILLEGAL_SRC_COLOR |\n\t\tSCALER_INT_EN_FRAME_END;\n\tscaler_write(val, SCALER_INT_EN);\n}\n\nstatic inline void scaler_set_src_fmt(struct scaler_context *scaler,\n\tu32 src_fmt, u32 tile)\n{\n\tu32 val;\n\n\tval = SCALER_SRC_CFG_SET_COLOR_FORMAT(src_fmt) | (tile << 10);\n\tscaler_write(val, SCALER_SRC_CFG);\n}\n\nstatic inline void scaler_set_src_base(struct scaler_context *scaler,\n\tstruct exynos_drm_ipp_buffer *src_buf)\n{\n\tstatic unsigned int bases[] = {\n\t\tSCALER_SRC_Y_BASE,\n\t\tSCALER_SRC_CB_BASE,\n\t\tSCALER_SRC_CR_BASE,\n\t};\n\tint i;\n\n\tfor (i = 0; i < src_buf->format->num_planes; ++i)\n\t\tscaler_write(src_buf->dma_addr[i], bases[i]);\n}\n\nstatic inline void scaler_set_src_span(struct scaler_context *scaler,\n\tstruct exynos_drm_ipp_buffer *src_buf)\n{\n\tu32 val;\n\n\tval = SCALER_SRC_SPAN_SET_Y_SPAN(src_buf->buf.pitch[0] /\n\t\tsrc_buf->format->cpp[0]);\n\n\tif (src_buf->format->num_planes > 1)\n\t\tval |= SCALER_SRC_SPAN_SET_C_SPAN(src_buf->buf.pitch[1]);\n\n\tscaler_write(val, SCALER_SRC_SPAN);\n}\n\nstatic inline void scaler_set_src_luma_chroma_pos(struct scaler_context *scaler,\n\t\t\tstruct drm_exynos_ipp_task_rect *src_pos,\n\t\t\tconst struct scaler_format *fmt)\n{\n\tu32 val;\n\n\tval = SCALER_SRC_Y_POS_SET_YH_POS(src_pos->x << 2);\n\tval |=  SCALER_SRC_Y_POS_SET_YV_POS(src_pos->y << 2);\n\tscaler_write(val, SCALER_SRC_Y_POS);\n\tval = SCALER_SRC_C_POS_SET_CH_POS(\n\t\t(src_pos->x * fmt->chroma_tile_w / 16) << 2);\n\tval |=  SCALER_SRC_C_POS_SET_CV_POS(\n\t\t(src_pos->y * fmt->chroma_tile_h / 16) << 2);\n\tscaler_write(val, SCALER_SRC_C_POS);\n}\n\nstatic inline void scaler_set_src_wh(struct scaler_context *scaler,\n\tstruct drm_exynos_ipp_task_rect *src_pos)\n{\n\tu32 val;\n\n\tval = SCALER_SRC_WH_SET_WIDTH(src_pos->w);\n\tval |= SCALER_SRC_WH_SET_HEIGHT(src_pos->h);\n\tscaler_write(val, SCALER_SRC_WH);\n}\n\nstatic inline void scaler_set_dst_fmt(struct scaler_context *scaler,\n\tu32 dst_fmt)\n{\n\tu32 val;\n\n\tval = SCALER_DST_CFG_SET_COLOR_FORMAT(dst_fmt);\n\tscaler_write(val, SCALER_DST_CFG);\n}\n\nstatic inline void scaler_set_dst_base(struct scaler_context *scaler,\n\tstruct exynos_drm_ipp_buffer *dst_buf)\n{\n\tstatic unsigned int bases[] = {\n\t\tSCALER_DST_Y_BASE,\n\t\tSCALER_DST_CB_BASE,\n\t\tSCALER_DST_CR_BASE,\n\t};\n\tint i;\n\n\tfor (i = 0; i < dst_buf->format->num_planes; ++i)\n\t\tscaler_write(dst_buf->dma_addr[i], bases[i]);\n}\n\nstatic inline void scaler_set_dst_span(struct scaler_context *scaler,\n\tstruct exynos_drm_ipp_buffer *dst_buf)\n{\n\tu32 val;\n\n\tval = SCALER_DST_SPAN_SET_Y_SPAN(dst_buf->buf.pitch[0] /\n\t\tdst_buf->format->cpp[0]);\n\n\tif (dst_buf->format->num_planes > 1)\n\t\tval |= SCALER_DST_SPAN_SET_C_SPAN(dst_buf->buf.pitch[1]);\n\n\tscaler_write(val, SCALER_DST_SPAN);\n}\n\nstatic inline void scaler_set_dst_luma_pos(struct scaler_context *scaler,\n\tstruct drm_exynos_ipp_task_rect *dst_pos)\n{\n\tu32 val;\n\n\tval = SCALER_DST_WH_SET_WIDTH(dst_pos->w);\n\tval |= SCALER_DST_WH_SET_HEIGHT(dst_pos->h);\n\tscaler_write(val, SCALER_DST_WH);\n}\n\nstatic inline void scaler_set_dst_wh(struct scaler_context *scaler,\n\tstruct drm_exynos_ipp_task_rect *dst_pos)\n{\n\tu32 val;\n\n\tval = SCALER_DST_POS_SET_H_POS(dst_pos->x);\n\tval |= SCALER_DST_POS_SET_V_POS(dst_pos->y);\n\tscaler_write(val, SCALER_DST_POS);\n}\n\nstatic inline void scaler_set_hv_ratio(struct scaler_context *scaler,\n\tunsigned int rotation,\n\tstruct drm_exynos_ipp_task_rect *src_pos,\n\tstruct drm_exynos_ipp_task_rect *dst_pos)\n{\n\tu32 val, h_ratio, v_ratio;\n\n\tif (drm_rotation_90_or_270(rotation)) {\n\t\th_ratio = (src_pos->h << 16) / dst_pos->w;\n\t\tv_ratio = (src_pos->w << 16) / dst_pos->h;\n\t} else {\n\t\th_ratio = (src_pos->w << 16) / dst_pos->w;\n\t\tv_ratio = (src_pos->h << 16) / dst_pos->h;\n\t}\n\n\tval = SCALER_H_RATIO_SET(h_ratio);\n\tscaler_write(val, SCALER_H_RATIO);\n\n\tval = SCALER_V_RATIO_SET(v_ratio);\n\tscaler_write(val, SCALER_V_RATIO);\n}\n\nstatic inline void scaler_set_rotation(struct scaler_context *scaler,\n\tunsigned int rotation)\n{\n\tu32 val = 0;\n\n\tif (rotation & DRM_MODE_ROTATE_90)\n\t\tval |= SCALER_ROT_CFG_SET_ROTMODE(SCALER_ROT_MODE_90);\n\telse if (rotation & DRM_MODE_ROTATE_180)\n\t\tval |= SCALER_ROT_CFG_SET_ROTMODE(SCALER_ROT_MODE_180);\n\telse if (rotation & DRM_MODE_ROTATE_270)\n\t\tval |= SCALER_ROT_CFG_SET_ROTMODE(SCALER_ROT_MODE_270);\n\tif (rotation & DRM_MODE_REFLECT_X)\n\t\tval |= SCALER_ROT_CFG_FLIP_X_EN;\n\tif (rotation & DRM_MODE_REFLECT_Y)\n\t\tval |= SCALER_ROT_CFG_FLIP_Y_EN;\n\tscaler_write(val, SCALER_ROT_CFG);\n}\n\nstatic inline void scaler_set_csc(struct scaler_context *scaler,\n\tconst struct drm_format_info *fmt)\n{\n\tstatic const u32 csc_mtx[2][3][3] = {\n\t\t{  \n\t\t\t{0x254, 0x000, 0x331},\n\t\t\t{0x254, 0xf38, 0xe60},\n\t\t\t{0x254, 0x409, 0x000},\n\t\t},\n\t\t{  \n\t\t\t{0x084, 0x102, 0x032},\n\t\t\t{0xfb4, 0xf6b, 0x0e1},\n\t\t\t{0x0e1, 0xf44, 0xfdc},\n\t\t},\n\t};\n\tint i, j, dir;\n\n\tswitch (fmt->format) {\n\tcase DRM_FORMAT_RGB565:\n\tcase DRM_FORMAT_XRGB1555:\n\tcase DRM_FORMAT_ARGB1555:\n\tcase DRM_FORMAT_XRGB4444:\n\tcase DRM_FORMAT_ARGB4444:\n\tcase DRM_FORMAT_XRGB8888:\n\tcase DRM_FORMAT_ARGB8888:\n\tcase DRM_FORMAT_RGBX8888:\n\tcase DRM_FORMAT_RGBA8888:\n\t\tdir = 1;\n\t\tbreak;\n\tdefault:\n\t\tdir = 0;\n\t}\n\n\tfor (i = 0; i < 3; i++)\n\t\tfor (j = 0; j < 3; j++)\n\t\t\tscaler_write(csc_mtx[dir][i][j], SCALER_CSC_COEF(j, i));\n}\n\nstatic inline void scaler_set_timer(struct scaler_context *scaler,\n\tunsigned int timer, unsigned int divider)\n{\n\tu32 val;\n\n\tval = SCALER_TIMEOUT_CTRL_TIMER_ENABLE;\n\tval |= SCALER_TIMEOUT_CTRL_SET_TIMER_VALUE(timer);\n\tval |= SCALER_TIMEOUT_CTRL_SET_TIMER_DIV(divider);\n\tscaler_write(val, SCALER_TIMEOUT_CTRL);\n}\n\nstatic inline void scaler_start_hw(struct scaler_context *scaler)\n{\n\tscaler_write(SCALER_CFG_START_CMD, SCALER_CFG);\n}\n\nstatic int scaler_commit(struct exynos_drm_ipp *ipp,\n\t\t\t  struct exynos_drm_ipp_task *task)\n{\n\tstruct scaler_context *scaler =\n\t\t\tcontainer_of(ipp, struct scaler_context, ipp);\n\n\tstruct drm_exynos_ipp_task_rect *src_pos = &task->src.rect;\n\tstruct drm_exynos_ipp_task_rect *dst_pos = &task->dst.rect;\n\tconst struct scaler_format *src_fmt, *dst_fmt;\n\tint ret = 0;\n\n\tsrc_fmt = scaler_get_format(task->src.buf.fourcc);\n\tdst_fmt = scaler_get_format(task->dst.buf.fourcc);\n\n\tret = pm_runtime_resume_and_get(scaler->dev);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (scaler_reset(scaler))\n\t\treturn -EIO;\n\n\tscaler->task = task;\n\n\tscaler_set_src_fmt(\n\t\tscaler, src_fmt->internal_fmt, task->src.buf.modifier != 0);\n\tscaler_set_src_base(scaler, &task->src);\n\tscaler_set_src_span(scaler, &task->src);\n\tscaler_set_src_luma_chroma_pos(scaler, src_pos, src_fmt);\n\tscaler_set_src_wh(scaler, src_pos);\n\n\tscaler_set_dst_fmt(scaler, dst_fmt->internal_fmt);\n\tscaler_set_dst_base(scaler, &task->dst);\n\tscaler_set_dst_span(scaler, &task->dst);\n\tscaler_set_dst_luma_pos(scaler, dst_pos);\n\tscaler_set_dst_wh(scaler, dst_pos);\n\n\tscaler_set_hv_ratio(scaler, task->transform.rotation, src_pos, dst_pos);\n\tscaler_set_rotation(scaler, task->transform.rotation);\n\n\tscaler_set_csc(scaler, task->src.format);\n\n\tscaler_set_timer(scaler, 0xffff, 0xf);\n\n\tscaler_enable_int(scaler);\n\tscaler_start_hw(scaler);\n\n\treturn 0;\n}\n\nstatic struct exynos_drm_ipp_funcs ipp_funcs = {\n\t.commit = scaler_commit,\n};\n\nstatic inline void scaler_disable_int(struct scaler_context *scaler)\n{\n\tscaler_write(0, SCALER_INT_EN);\n}\n\nstatic inline u32 scaler_get_int_status(struct scaler_context *scaler)\n{\n\tu32 val = scaler_read(SCALER_INT_STATUS);\n\n\tscaler_write(val, SCALER_INT_STATUS);\n\n\treturn val;\n}\n\nstatic inline int scaler_task_done(u32 val)\n{\n\treturn val & SCALER_INT_STATUS_FRAME_END ? 0 : -EINVAL;\n}\n\nstatic irqreturn_t scaler_irq_handler(int irq, void *arg)\n{\n\tstruct scaler_context *scaler = arg;\n\n\tu32 val = scaler_get_int_status(scaler);\n\n\tscaler_disable_int(scaler);\n\n\tif (scaler->task) {\n\t\tstruct exynos_drm_ipp_task *task = scaler->task;\n\n\t\tscaler->task = NULL;\n\t\tpm_runtime_mark_last_busy(scaler->dev);\n\t\tpm_runtime_put_autosuspend(scaler->dev);\n\t\texynos_drm_ipp_task_done(task, scaler_task_done(val));\n\t}\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int scaler_bind(struct device *dev, struct device *master, void *data)\n{\n\tstruct scaler_context *scaler = dev_get_drvdata(dev);\n\tstruct drm_device *drm_dev = data;\n\tstruct exynos_drm_ipp *ipp = &scaler->ipp;\n\n\tscaler->drm_dev = drm_dev;\n\tipp->drm_dev = drm_dev;\n\texynos_drm_register_dma(drm_dev, dev, &scaler->dma_priv);\n\n\texynos_drm_ipp_register(dev, ipp, &ipp_funcs,\n\t\t\tDRM_EXYNOS_IPP_CAP_CROP | DRM_EXYNOS_IPP_CAP_ROTATE |\n\t\t\tDRM_EXYNOS_IPP_CAP_SCALE | DRM_EXYNOS_IPP_CAP_CONVERT,\n\t\t\tscaler->scaler_data->formats,\n\t\t\tscaler->scaler_data->num_formats, \"scaler\");\n\n\tdev_info(dev, \"The exynos scaler has been probed successfully\\n\");\n\n\treturn 0;\n}\n\nstatic void scaler_unbind(struct device *dev, struct device *master,\n\t\t\tvoid *data)\n{\n\tstruct scaler_context *scaler = dev_get_drvdata(dev);\n\tstruct exynos_drm_ipp *ipp = &scaler->ipp;\n\n\texynos_drm_ipp_unregister(dev, ipp);\n\texynos_drm_unregister_dma(scaler->drm_dev, scaler->dev,\n\t\t\t\t  &scaler->dma_priv);\n}\n\nstatic const struct component_ops scaler_component_ops = {\n\t.bind\t= scaler_bind,\n\t.unbind = scaler_unbind,\n};\n\nstatic int scaler_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct scaler_context *scaler;\n\tint irq;\n\tint ret, i;\n\n\tscaler = devm_kzalloc(dev, sizeof(*scaler), GFP_KERNEL);\n\tif (!scaler)\n\t\treturn -ENOMEM;\n\n\tscaler->scaler_data =\n\t\t(struct scaler_data *)of_device_get_match_data(dev);\n\n\tscaler->dev = dev;\n\tscaler->regs = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(scaler->regs))\n\t\treturn PTR_ERR(scaler->regs);\n\n\tirq = platform_get_irq(pdev, 0);\n\tif (irq < 0)\n\t\treturn irq;\n\n\tret = devm_request_threaded_irq(dev, irq, NULL,\tscaler_irq_handler,\n\t\t\t\t\tIRQF_ONESHOT, \"drm_scaler\", scaler);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"failed to request irq\\n\");\n\t\treturn ret;\n\t}\n\n\tfor (i = 0; i < scaler->scaler_data->num_clk; ++i) {\n\t\tscaler->clock[i] = devm_clk_get(dev,\n\t\t\t\t\t      scaler->scaler_data->clk_name[i]);\n\t\tif (IS_ERR(scaler->clock[i])) {\n\t\t\tdev_err(dev, \"failed to get clock\\n\");\n\t\t\treturn PTR_ERR(scaler->clock[i]);\n\t\t}\n\t}\n\n\tpm_runtime_use_autosuspend(dev);\n\tpm_runtime_set_autosuspend_delay(dev, SCALER_AUTOSUSPEND_DELAY);\n\tpm_runtime_enable(dev);\n\tplatform_set_drvdata(pdev, scaler);\n\n\tret = component_add(dev, &scaler_component_ops);\n\tif (ret)\n\t\tgoto err_ippdrv_register;\n\n\treturn 0;\n\nerr_ippdrv_register:\n\tpm_runtime_dont_use_autosuspend(dev);\n\tpm_runtime_disable(dev);\n\treturn ret;\n}\n\nstatic int scaler_remove(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\n\tcomponent_del(dev, &scaler_component_ops);\n\tpm_runtime_dont_use_autosuspend(dev);\n\tpm_runtime_disable(dev);\n\n\treturn 0;\n}\n\nstatic int clk_disable_unprepare_wrapper(struct clk *clk)\n{\n\tclk_disable_unprepare(clk);\n\n\treturn 0;\n}\n\nstatic int scaler_clk_ctrl(struct scaler_context *scaler, bool enable)\n{\n\tint (*clk_fun)(struct clk *clk), i;\n\n\tclk_fun = enable ? clk_prepare_enable : clk_disable_unprepare_wrapper;\n\n\tfor (i = 0; i < scaler->scaler_data->num_clk; ++i)\n\t\tclk_fun(scaler->clock[i]);\n\n\treturn 0;\n}\n\nstatic int scaler_runtime_suspend(struct device *dev)\n{\n\tstruct scaler_context *scaler = dev_get_drvdata(dev);\n\n\treturn  scaler_clk_ctrl(scaler, false);\n}\n\nstatic int scaler_runtime_resume(struct device *dev)\n{\n\tstruct scaler_context *scaler = dev_get_drvdata(dev);\n\n\treturn  scaler_clk_ctrl(scaler, true);\n}\n\nstatic DEFINE_RUNTIME_DEV_PM_OPS(scaler_pm_ops, scaler_runtime_suspend,\n\t\t\t\t scaler_runtime_resume, NULL);\n\nstatic const struct drm_exynos_ipp_limit scaler_5420_two_pixel_hv_limits[] = {\n\t{ IPP_SIZE_LIMIT(BUFFER, .h = { 16, SZ_8K }, .v = { 16, SZ_8K }) },\n\t{ IPP_SIZE_LIMIT(AREA, .h.align = 2, .v.align = 2) },\n\t{ IPP_SCALE_LIMIT(.h = { 65536 * 1 / 4, 65536 * 16 },\n\t\t\t  .v = { 65536 * 1 / 4, 65536 * 16 }) },\n};\n\nstatic const struct drm_exynos_ipp_limit scaler_5420_two_pixel_h_limits[] = {\n\t{ IPP_SIZE_LIMIT(BUFFER, .h = { 16, SZ_8K }, .v = { 16, SZ_8K }) },\n\t{ IPP_SIZE_LIMIT(AREA, .h.align = 2, .v.align = 1) },\n\t{ IPP_SCALE_LIMIT(.h = { 65536 * 1 / 4, 65536 * 16 },\n\t\t\t  .v = { 65536 * 1 / 4, 65536 * 16 }) },\n};\n\nstatic const struct drm_exynos_ipp_limit scaler_5420_one_pixel_limits[] = {\n\t{ IPP_SIZE_LIMIT(BUFFER, .h = { 16, SZ_8K }, .v = { 16, SZ_8K }) },\n\t{ IPP_SCALE_LIMIT(.h = { 65536 * 1 / 4, 65536 * 16 },\n\t\t\t  .v = { 65536 * 1 / 4, 65536 * 16 }) },\n};\n\nstatic const struct drm_exynos_ipp_limit scaler_5420_tile_limits[] = {\n\t{ IPP_SIZE_LIMIT(BUFFER, .h = { 16, SZ_8K }, .v = { 16, SZ_8K })},\n\t{ IPP_SIZE_LIMIT(AREA, .h.align = 16, .v.align = 16) },\n\t{ IPP_SCALE_LIMIT(.h = {1, 1}, .v = {1, 1})},\n\t{ }\n};\n\n#define IPP_SRCDST_TILE_FORMAT(f, l)\t\\\n\tIPP_SRCDST_MFORMAT(f, DRM_FORMAT_MOD_SAMSUNG_16_16_TILE, (l))\n\nstatic const struct exynos_drm_ipp_formats exynos5420_formats[] = {\n\t \n\t{ IPP_SRCDST_FORMAT(NV21, scaler_5420_two_pixel_hv_limits) },\n\n\t \n\t{ IPP_SRCDST_FORMAT(NV12, scaler_5420_two_pixel_hv_limits) },\n\n\t \n\t{ IPP_SRCDST_FORMAT(YUV420, scaler_5420_two_pixel_hv_limits) },\n\n\t \n\t{ IPP_SRCDST_FORMAT(YUYV, scaler_5420_two_pixel_h_limits) },\n\n\t \n\t{ IPP_SRCDST_FORMAT(UYVY, scaler_5420_two_pixel_h_limits) },\n\n\t \n\t{ IPP_SRCDST_FORMAT(YVYU, scaler_5420_two_pixel_h_limits) },\n\n\t \n\t{ IPP_SRCDST_FORMAT(NV61, scaler_5420_two_pixel_h_limits) },\n\n\t \n\t{ IPP_SRCDST_FORMAT(NV16, scaler_5420_two_pixel_h_limits) },\n\n\t \n\t{ IPP_SRCDST_FORMAT(YUV422, scaler_5420_two_pixel_h_limits) },\n\n\t \n\t{ IPP_SRCDST_FORMAT(NV42, scaler_5420_one_pixel_limits) },\n\n\t \n\t{ IPP_SRCDST_FORMAT(NV24, scaler_5420_one_pixel_limits) },\n\n\t \n\t{ IPP_SRCDST_FORMAT(YUV444, scaler_5420_one_pixel_limits) },\n\n\t \n\t{ IPP_SRCDST_FORMAT(RGB565, scaler_5420_one_pixel_limits) },\n\n\t \n\t{ IPP_SRCDST_FORMAT(XRGB1555, scaler_5420_one_pixel_limits) },\n\n\t \n\t{ IPP_SRCDST_FORMAT(ARGB1555, scaler_5420_one_pixel_limits) },\n\n\t \n\t{ IPP_SRCDST_FORMAT(XRGB4444, scaler_5420_one_pixel_limits) },\n\n\t \n\t{ IPP_SRCDST_FORMAT(ARGB4444, scaler_5420_one_pixel_limits) },\n\n\t \n\t{ IPP_SRCDST_FORMAT(XRGB8888, scaler_5420_one_pixel_limits) },\n\n\t \n\t{ IPP_SRCDST_FORMAT(ARGB8888, scaler_5420_one_pixel_limits) },\n\n\t \n\t{ IPP_SRCDST_FORMAT(RGBX8888, scaler_5420_one_pixel_limits) },\n\n\t \n\t{ IPP_SRCDST_FORMAT(RGBA8888, scaler_5420_one_pixel_limits) },\n\n\t \n\t{ IPP_SRCDST_TILE_FORMAT(NV21, scaler_5420_tile_limits) },\n\n\t \n\t{ IPP_SRCDST_TILE_FORMAT(NV12, scaler_5420_tile_limits) },\n\n\t \n\t{ IPP_SRCDST_TILE_FORMAT(YUV420, scaler_5420_tile_limits) },\n\n\t \n\t{ IPP_SRCDST_TILE_FORMAT(YUYV, scaler_5420_tile_limits) },\n};\n\nstatic const struct scaler_data exynos5420_data = {\n\t.clk_name\t= {\"mscl\"},\n\t.num_clk\t= 1,\n\t.formats\t= exynos5420_formats,\n\t.num_formats\t= ARRAY_SIZE(exynos5420_formats),\n};\n\nstatic const struct scaler_data exynos5433_data = {\n\t.clk_name\t= {\"pclk\", \"aclk\", \"aclk_xiu\"},\n\t.num_clk\t= 3,\n\t.formats\t= exynos5420_formats,  \n\t.num_formats\t= ARRAY_SIZE(exynos5420_formats),\n};\n\nstatic const struct of_device_id exynos_scaler_match[] = {\n\t{\n\t\t.compatible = \"samsung,exynos5420-scaler\",\n\t\t.data = &exynos5420_data,\n\t}, {\n\t\t.compatible = \"samsung,exynos5433-scaler\",\n\t\t.data = &exynos5433_data,\n\t}, {\n\t},\n};\nMODULE_DEVICE_TABLE(of, exynos_scaler_match);\n\nstruct platform_driver scaler_driver = {\n\t.probe\t\t= scaler_probe,\n\t.remove\t\t= scaler_remove,\n\t.driver\t\t= {\n\t\t.name\t= \"exynos-scaler\",\n\t\t.owner\t= THIS_MODULE,\n\t\t.pm\t= pm_ptr(&scaler_pm_ops),\n\t\t.of_match_table = exynos_scaler_match,\n\t},\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}