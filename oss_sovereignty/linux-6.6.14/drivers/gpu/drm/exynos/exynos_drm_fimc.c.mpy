{
  "module_name": "exynos_drm_fimc.c",
  "hash_id": "ec6f619448aab96a4b98ae8ba97bbe7b1302128395dd8b587eac6a317d5daa5e",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/exynos/exynos_drm_fimc.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/component.h>\n#include <linux/kernel.h>\n#include <linux/mfd/syscon.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/pm_runtime.h>\n#include <linux/regmap.h>\n#include <linux/spinlock.h>\n\n#include <drm/drm_fourcc.h>\n#include <drm/drm_print.h>\n#include <drm/exynos_drm.h>\n\n#include \"exynos_drm_drv.h\"\n#include \"exynos_drm_ipp.h\"\n#include \"regs-fimc.h\"\n\n \n\n#define FIMC_MAX_DEVS\t4\n#define FIMC_MAX_SRC\t2\n#define FIMC_MAX_DST\t32\n#define FIMC_SHFACTOR\t10\n#define FIMC_BUF_STOP\t1\n#define FIMC_BUF_START\t2\n#define FIMC_WIDTH_ITU_709\t1280\n#define FIMC_AUTOSUSPEND_DELAY\t2000\n\nstatic unsigned int fimc_mask = 0xc;\nmodule_param_named(fimc_devs, fimc_mask, uint, 0644);\nMODULE_PARM_DESC(fimc_devs, \"Alias mask for assigning FIMC devices to Exynos DRM\");\n\n#define get_fimc_context(dev)\tdev_get_drvdata(dev)\n\nenum {\n\tFIMC_CLK_LCLK,\n\tFIMC_CLK_GATE,\n\tFIMC_CLK_WB_A,\n\tFIMC_CLK_WB_B,\n\tFIMC_CLKS_MAX\n};\n\nstatic const char * const fimc_clock_names[] = {\n\t[FIMC_CLK_LCLK]   = \"sclk_fimc\",\n\t[FIMC_CLK_GATE]   = \"fimc\",\n\t[FIMC_CLK_WB_A]   = \"pxl_async0\",\n\t[FIMC_CLK_WB_B]   = \"pxl_async1\",\n};\n\n \nstruct fimc_scaler {\n\tbool range;\n\tbool bypass;\n\tbool up_h;\n\tbool up_v;\n\tu32 hratio;\n\tu32 vratio;\n};\n\n \nstruct fimc_context {\n\tstruct exynos_drm_ipp ipp;\n\tstruct drm_device *drm_dev;\n\tvoid\t\t*dma_priv;\n\tstruct device\t*dev;\n\tstruct exynos_drm_ipp_task\t*task;\n\tstruct exynos_drm_ipp_formats\t*formats;\n\tunsigned int\t\t\tnum_formats;\n\n\tvoid __iomem\t*regs;\n\tspinlock_t\tlock;\n\tstruct clk\t*clocks[FIMC_CLKS_MAX];\n\tstruct fimc_scaler\tsc;\n\tint\tid;\n\tint\tirq;\n};\n\nstatic u32 fimc_read(struct fimc_context *ctx, u32 reg)\n{\n\treturn readl(ctx->regs + reg);\n}\n\nstatic void fimc_write(struct fimc_context *ctx, u32 val, u32 reg)\n{\n\twritel(val, ctx->regs + reg);\n}\n\nstatic void fimc_set_bits(struct fimc_context *ctx, u32 reg, u32 bits)\n{\n\tvoid __iomem *r = ctx->regs + reg;\n\n\twritel(readl(r) | bits, r);\n}\n\nstatic void fimc_clear_bits(struct fimc_context *ctx, u32 reg, u32 bits)\n{\n\tvoid __iomem *r = ctx->regs + reg;\n\n\twritel(readl(r) & ~bits, r);\n}\n\nstatic void fimc_sw_reset(struct fimc_context *ctx)\n{\n\tu32 cfg;\n\n\t \n\tcfg = fimc_read(ctx, EXYNOS_CISTATUS);\n\tif (EXYNOS_CISTATUS_GET_ENVID_STATUS(cfg))\n\t\tfimc_clear_bits(ctx, EXYNOS_MSCTRL, EXYNOS_MSCTRL_ENVID);\n\n\tfimc_set_bits(ctx, EXYNOS_CISRCFMT, EXYNOS_CISRCFMT_ITU601_8BIT);\n\n\t \n\tfimc_clear_bits(ctx, EXYNOS_CIIMGCPT,\n\t\tEXYNOS_CIIMGCPT_IMGCPTEN_SC | EXYNOS_CIIMGCPT_IMGCPTEN);\n\n\t \n\tfimc_set_bits(ctx, EXYNOS_CIGCTRL, EXYNOS_CIGCTRL_SWRST);\n\n\t \n\tfimc_clear_bits(ctx, EXYNOS_CIGCTRL, EXYNOS_CIGCTRL_SWRST);\n\n\t \n\tfimc_write(ctx, 0x0, EXYNOS_CIFCNTSEQ);\n}\n\nstatic void fimc_set_type_ctrl(struct fimc_context *ctx)\n{\n\tu32 cfg;\n\n\tcfg = fimc_read(ctx, EXYNOS_CIGCTRL);\n\tcfg &= ~(EXYNOS_CIGCTRL_TESTPATTERN_MASK |\n\t\tEXYNOS_CIGCTRL_SELCAM_ITU_MASK |\n\t\tEXYNOS_CIGCTRL_SELCAM_MIPI_MASK |\n\t\tEXYNOS_CIGCTRL_SELCAM_FIMC_MASK |\n\t\tEXYNOS_CIGCTRL_SELWB_CAMIF_MASK |\n\t\tEXYNOS_CIGCTRL_SELWRITEBACK_MASK);\n\n\tcfg |= (EXYNOS_CIGCTRL_SELCAM_ITU_A |\n\t\tEXYNOS_CIGCTRL_SELWRITEBACK_A |\n\t\tEXYNOS_CIGCTRL_SELCAM_MIPI_A |\n\t\tEXYNOS_CIGCTRL_SELCAM_FIMC_ITU);\n\n\tfimc_write(ctx, cfg, EXYNOS_CIGCTRL);\n}\n\nstatic void fimc_handle_jpeg(struct fimc_context *ctx, bool enable)\n{\n\tu32 cfg;\n\n\tDRM_DEV_DEBUG_KMS(ctx->dev, \"enable[%d]\\n\", enable);\n\n\tcfg = fimc_read(ctx, EXYNOS_CIGCTRL);\n\tif (enable)\n\t\tcfg |= EXYNOS_CIGCTRL_CAM_JPEG;\n\telse\n\t\tcfg &= ~EXYNOS_CIGCTRL_CAM_JPEG;\n\n\tfimc_write(ctx, cfg, EXYNOS_CIGCTRL);\n}\n\nstatic void fimc_mask_irq(struct fimc_context *ctx, bool enable)\n{\n\tu32 cfg;\n\n\tDRM_DEV_DEBUG_KMS(ctx->dev, \"enable[%d]\\n\", enable);\n\n\tcfg = fimc_read(ctx, EXYNOS_CIGCTRL);\n\tif (enable) {\n\t\tcfg &= ~EXYNOS_CIGCTRL_IRQ_OVFEN;\n\t\tcfg |= EXYNOS_CIGCTRL_IRQ_ENABLE | EXYNOS_CIGCTRL_IRQ_LEVEL;\n\t} else\n\t\tcfg &= ~EXYNOS_CIGCTRL_IRQ_ENABLE;\n\tfimc_write(ctx, cfg, EXYNOS_CIGCTRL);\n}\n\nstatic void fimc_clear_irq(struct fimc_context *ctx)\n{\n\tfimc_set_bits(ctx, EXYNOS_CIGCTRL, EXYNOS_CIGCTRL_IRQ_CLR);\n}\n\nstatic bool fimc_check_ovf(struct fimc_context *ctx)\n{\n\tu32 status, flag;\n\n\tstatus = fimc_read(ctx, EXYNOS_CISTATUS);\n\tflag = EXYNOS_CISTATUS_OVFIY | EXYNOS_CISTATUS_OVFICB |\n\t\tEXYNOS_CISTATUS_OVFICR;\n\n\tDRM_DEV_DEBUG_KMS(ctx->dev, \"flag[0x%x]\\n\", flag);\n\n\tif (status & flag) {\n\t\tfimc_set_bits(ctx, EXYNOS_CIWDOFST,\n\t\t\tEXYNOS_CIWDOFST_CLROVFIY | EXYNOS_CIWDOFST_CLROVFICB |\n\t\t\tEXYNOS_CIWDOFST_CLROVFICR);\n\n\t\tDRM_DEV_ERROR(ctx->dev,\n\t\t\t      \"occurred overflow at %d, status 0x%x.\\n\",\n\t\t\t      ctx->id, status);\n\t\treturn true;\n\t}\n\n\treturn false;\n}\n\nstatic bool fimc_check_frame_end(struct fimc_context *ctx)\n{\n\tu32 cfg;\n\n\tcfg = fimc_read(ctx, EXYNOS_CISTATUS);\n\n\tDRM_DEV_DEBUG_KMS(ctx->dev, \"cfg[0x%x]\\n\", cfg);\n\n\tif (!(cfg & EXYNOS_CISTATUS_FRAMEEND))\n\t\treturn false;\n\n\tcfg &= ~(EXYNOS_CISTATUS_FRAMEEND);\n\tfimc_write(ctx, cfg, EXYNOS_CISTATUS);\n\n\treturn true;\n}\n\nstatic int fimc_get_buf_id(struct fimc_context *ctx)\n{\n\tu32 cfg;\n\tint frame_cnt, buf_id;\n\n\tcfg = fimc_read(ctx, EXYNOS_CISTATUS2);\n\tframe_cnt = EXYNOS_CISTATUS2_GET_FRAMECOUNT_BEFORE(cfg);\n\n\tif (frame_cnt == 0)\n\t\tframe_cnt = EXYNOS_CISTATUS2_GET_FRAMECOUNT_PRESENT(cfg);\n\n\tDRM_DEV_DEBUG_KMS(ctx->dev, \"present[%d]before[%d]\\n\",\n\t\t\t  EXYNOS_CISTATUS2_GET_FRAMECOUNT_PRESENT(cfg),\n\t\t\t  EXYNOS_CISTATUS2_GET_FRAMECOUNT_BEFORE(cfg));\n\n\tif (frame_cnt == 0) {\n\t\tDRM_DEV_ERROR(ctx->dev, \"failed to get frame count.\\n\");\n\t\treturn -EIO;\n\t}\n\n\tbuf_id = frame_cnt - 1;\n\tDRM_DEV_DEBUG_KMS(ctx->dev, \"buf_id[%d]\\n\", buf_id);\n\n\treturn buf_id;\n}\n\nstatic void fimc_handle_lastend(struct fimc_context *ctx, bool enable)\n{\n\tu32 cfg;\n\n\tDRM_DEV_DEBUG_KMS(ctx->dev, \"enable[%d]\\n\", enable);\n\n\tcfg = fimc_read(ctx, EXYNOS_CIOCTRL);\n\tif (enable)\n\t\tcfg |= EXYNOS_CIOCTRL_LASTENDEN;\n\telse\n\t\tcfg &= ~EXYNOS_CIOCTRL_LASTENDEN;\n\n\tfimc_write(ctx, cfg, EXYNOS_CIOCTRL);\n}\n\nstatic void fimc_src_set_fmt_order(struct fimc_context *ctx, u32 fmt)\n{\n\tu32 cfg;\n\n\tDRM_DEV_DEBUG_KMS(ctx->dev, \"fmt[0x%x]\\n\", fmt);\n\n\t \n\tcfg = fimc_read(ctx, EXYNOS_CISCCTRL);\n\tcfg &= ~EXYNOS_CISCCTRL_INRGB_FMT_RGB_MASK;\n\n\tswitch (fmt) {\n\tcase DRM_FORMAT_RGB565:\n\t\tcfg |= EXYNOS_CISCCTRL_INRGB_FMT_RGB565;\n\t\tfimc_write(ctx, cfg, EXYNOS_CISCCTRL);\n\t\treturn;\n\tcase DRM_FORMAT_RGB888:\n\tcase DRM_FORMAT_XRGB8888:\n\t\tcfg |= EXYNOS_CISCCTRL_INRGB_FMT_RGB888;\n\t\tfimc_write(ctx, cfg, EXYNOS_CISCCTRL);\n\t\treturn;\n\tdefault:\n\t\t \n\t\tbreak;\n\t}\n\n\t \n\tcfg = fimc_read(ctx, EXYNOS_MSCTRL);\n\tcfg &= ~(EXYNOS_MSCTRL_ORDER2P_SHIFT_MASK |\n\t\tEXYNOS_MSCTRL_C_INT_IN_2PLANE |\n\t\tEXYNOS_MSCTRL_ORDER422_YCBYCR);\n\n\tswitch (fmt) {\n\tcase DRM_FORMAT_YUYV:\n\t\tcfg |= EXYNOS_MSCTRL_ORDER422_YCBYCR;\n\t\tbreak;\n\tcase DRM_FORMAT_YVYU:\n\t\tcfg |= EXYNOS_MSCTRL_ORDER422_YCRYCB;\n\t\tbreak;\n\tcase DRM_FORMAT_UYVY:\n\t\tcfg |= EXYNOS_MSCTRL_ORDER422_CBYCRY;\n\t\tbreak;\n\tcase DRM_FORMAT_VYUY:\n\tcase DRM_FORMAT_YUV444:\n\t\tcfg |= EXYNOS_MSCTRL_ORDER422_CRYCBY;\n\t\tbreak;\n\tcase DRM_FORMAT_NV21:\n\tcase DRM_FORMAT_NV61:\n\t\tcfg |= (EXYNOS_MSCTRL_ORDER2P_LSB_CRCB |\n\t\t\tEXYNOS_MSCTRL_C_INT_IN_2PLANE);\n\t\tbreak;\n\tcase DRM_FORMAT_YUV422:\n\tcase DRM_FORMAT_YUV420:\n\tcase DRM_FORMAT_YVU420:\n\t\tcfg |= EXYNOS_MSCTRL_C_INT_IN_3PLANE;\n\t\tbreak;\n\tcase DRM_FORMAT_NV12:\n\tcase DRM_FORMAT_NV16:\n\t\tcfg |= (EXYNOS_MSCTRL_ORDER2P_LSB_CBCR |\n\t\t\tEXYNOS_MSCTRL_C_INT_IN_2PLANE);\n\t\tbreak;\n\t}\n\n\tfimc_write(ctx, cfg, EXYNOS_MSCTRL);\n}\n\nstatic void fimc_src_set_fmt(struct fimc_context *ctx, u32 fmt, bool tiled)\n{\n\tu32 cfg;\n\n\tDRM_DEV_DEBUG_KMS(ctx->dev, \"fmt[0x%x]\\n\", fmt);\n\n\tcfg = fimc_read(ctx, EXYNOS_MSCTRL);\n\tcfg &= ~EXYNOS_MSCTRL_INFORMAT_RGB;\n\n\tswitch (fmt) {\n\tcase DRM_FORMAT_RGB565:\n\tcase DRM_FORMAT_RGB888:\n\tcase DRM_FORMAT_XRGB8888:\n\t\tcfg |= EXYNOS_MSCTRL_INFORMAT_RGB;\n\t\tbreak;\n\tcase DRM_FORMAT_YUV444:\n\t\tcfg |= EXYNOS_MSCTRL_INFORMAT_YCBCR420;\n\t\tbreak;\n\tcase DRM_FORMAT_YUYV:\n\tcase DRM_FORMAT_YVYU:\n\tcase DRM_FORMAT_UYVY:\n\tcase DRM_FORMAT_VYUY:\n\t\tcfg |= EXYNOS_MSCTRL_INFORMAT_YCBCR422_1PLANE;\n\t\tbreak;\n\tcase DRM_FORMAT_NV16:\n\tcase DRM_FORMAT_NV61:\n\tcase DRM_FORMAT_YUV422:\n\t\tcfg |= EXYNOS_MSCTRL_INFORMAT_YCBCR422;\n\t\tbreak;\n\tcase DRM_FORMAT_YUV420:\n\tcase DRM_FORMAT_YVU420:\n\tcase DRM_FORMAT_NV12:\n\tcase DRM_FORMAT_NV21:\n\t\tcfg |= EXYNOS_MSCTRL_INFORMAT_YCBCR420;\n\t\tbreak;\n\t}\n\n\tfimc_write(ctx, cfg, EXYNOS_MSCTRL);\n\n\tcfg = fimc_read(ctx, EXYNOS_CIDMAPARAM);\n\tcfg &= ~EXYNOS_CIDMAPARAM_R_MODE_MASK;\n\n\tif (tiled)\n\t\tcfg |= EXYNOS_CIDMAPARAM_R_MODE_64X32;\n\telse\n\t\tcfg |= EXYNOS_CIDMAPARAM_R_MODE_LINEAR;\n\n\tfimc_write(ctx, cfg, EXYNOS_CIDMAPARAM);\n\n\tfimc_src_set_fmt_order(ctx, fmt);\n}\n\nstatic void fimc_src_set_transf(struct fimc_context *ctx, unsigned int rotation)\n{\n\tunsigned int degree = rotation & DRM_MODE_ROTATE_MASK;\n\tu32 cfg1, cfg2;\n\n\tDRM_DEV_DEBUG_KMS(ctx->dev, \"rotation[%x]\\n\", rotation);\n\n\tcfg1 = fimc_read(ctx, EXYNOS_MSCTRL);\n\tcfg1 &= ~(EXYNOS_MSCTRL_FLIP_X_MIRROR |\n\t\tEXYNOS_MSCTRL_FLIP_Y_MIRROR);\n\n\tcfg2 = fimc_read(ctx, EXYNOS_CITRGFMT);\n\tcfg2 &= ~EXYNOS_CITRGFMT_INROT90_CLOCKWISE;\n\n\tswitch (degree) {\n\tcase DRM_MODE_ROTATE_0:\n\t\tif (rotation & DRM_MODE_REFLECT_X)\n\t\t\tcfg1 |= EXYNOS_MSCTRL_FLIP_X_MIRROR;\n\t\tif (rotation & DRM_MODE_REFLECT_Y)\n\t\t\tcfg1 |= EXYNOS_MSCTRL_FLIP_Y_MIRROR;\n\t\tbreak;\n\tcase DRM_MODE_ROTATE_90:\n\t\tcfg2 |= EXYNOS_CITRGFMT_INROT90_CLOCKWISE;\n\t\tif (rotation & DRM_MODE_REFLECT_X)\n\t\t\tcfg1 |= EXYNOS_MSCTRL_FLIP_X_MIRROR;\n\t\tif (rotation & DRM_MODE_REFLECT_Y)\n\t\t\tcfg1 |= EXYNOS_MSCTRL_FLIP_Y_MIRROR;\n\t\tbreak;\n\tcase DRM_MODE_ROTATE_180:\n\t\tcfg1 |= (EXYNOS_MSCTRL_FLIP_X_MIRROR |\n\t\t\tEXYNOS_MSCTRL_FLIP_Y_MIRROR);\n\t\tif (rotation & DRM_MODE_REFLECT_X)\n\t\t\tcfg1 &= ~EXYNOS_MSCTRL_FLIP_X_MIRROR;\n\t\tif (rotation & DRM_MODE_REFLECT_Y)\n\t\t\tcfg1 &= ~EXYNOS_MSCTRL_FLIP_Y_MIRROR;\n\t\tbreak;\n\tcase DRM_MODE_ROTATE_270:\n\t\tcfg1 |= (EXYNOS_MSCTRL_FLIP_X_MIRROR |\n\t\t\tEXYNOS_MSCTRL_FLIP_Y_MIRROR);\n\t\tcfg2 |= EXYNOS_CITRGFMT_INROT90_CLOCKWISE;\n\t\tif (rotation & DRM_MODE_REFLECT_X)\n\t\t\tcfg1 &= ~EXYNOS_MSCTRL_FLIP_X_MIRROR;\n\t\tif (rotation & DRM_MODE_REFLECT_Y)\n\t\t\tcfg1 &= ~EXYNOS_MSCTRL_FLIP_Y_MIRROR;\n\t\tbreak;\n\t}\n\n\tfimc_write(ctx, cfg1, EXYNOS_MSCTRL);\n\tfimc_write(ctx, cfg2, EXYNOS_CITRGFMT);\n}\n\nstatic void fimc_set_window(struct fimc_context *ctx,\n\t\t\t    struct exynos_drm_ipp_buffer *buf)\n{\n\tunsigned int real_width = buf->buf.pitch[0] / buf->format->cpp[0];\n\tu32 cfg, h1, h2, v1, v2;\n\n\t \n\th1 = buf->rect.x;\n\th2 = real_width - buf->rect.w - buf->rect.x;\n\tv1 = buf->rect.y;\n\tv2 = buf->buf.height - buf->rect.h - buf->rect.y;\n\n\tDRM_DEV_DEBUG_KMS(ctx->dev, \"x[%d]y[%d]w[%d]h[%d]hsize[%d]vsize[%d]\\n\",\n\t\t\t  buf->rect.x, buf->rect.y, buf->rect.w, buf->rect.h,\n\t\t\t  real_width, buf->buf.height);\n\tDRM_DEV_DEBUG_KMS(ctx->dev, \"h1[%d]h2[%d]v1[%d]v2[%d]\\n\", h1, h2, v1,\n\t\t\t  v2);\n\n\t \n\tcfg = fimc_read(ctx, EXYNOS_CIWDOFST);\n\tcfg &= ~(EXYNOS_CIWDOFST_WINHOROFST_MASK |\n\t\tEXYNOS_CIWDOFST_WINVEROFST_MASK);\n\tcfg |= (EXYNOS_CIWDOFST_WINHOROFST(h1) |\n\t\tEXYNOS_CIWDOFST_WINVEROFST(v1));\n\tcfg |= EXYNOS_CIWDOFST_WINOFSEN;\n\tfimc_write(ctx, cfg, EXYNOS_CIWDOFST);\n\n\tcfg = (EXYNOS_CIWDOFST2_WINHOROFST2(h2) |\n\t\tEXYNOS_CIWDOFST2_WINVEROFST2(v2));\n\tfimc_write(ctx, cfg, EXYNOS_CIWDOFST2);\n}\n\nstatic void fimc_src_set_size(struct fimc_context *ctx,\n\t\t\t      struct exynos_drm_ipp_buffer *buf)\n{\n\tunsigned int real_width = buf->buf.pitch[0] / buf->format->cpp[0];\n\tu32 cfg;\n\n\tDRM_DEV_DEBUG_KMS(ctx->dev, \"hsize[%d]vsize[%d]\\n\", real_width,\n\t\t\t  buf->buf.height);\n\n\t \n\tcfg = (EXYNOS_ORGISIZE_HORIZONTAL(real_width) |\n\t\tEXYNOS_ORGISIZE_VERTICAL(buf->buf.height));\n\n\tfimc_write(ctx, cfg, EXYNOS_ORGISIZE);\n\n\tDRM_DEV_DEBUG_KMS(ctx->dev, \"x[%d]y[%d]w[%d]h[%d]\\n\", buf->rect.x,\n\t\t\t  buf->rect.y, buf->rect.w, buf->rect.h);\n\n\t \n\tcfg = fimc_read(ctx, EXYNOS_CIREAL_ISIZE);\n\tcfg &= ~(EXYNOS_CIREAL_ISIZE_HEIGHT_MASK |\n\t\tEXYNOS_CIREAL_ISIZE_WIDTH_MASK);\n\tcfg |= (EXYNOS_CIREAL_ISIZE_WIDTH(buf->rect.w) |\n\t\tEXYNOS_CIREAL_ISIZE_HEIGHT(buf->rect.h));\n\tfimc_write(ctx, cfg, EXYNOS_CIREAL_ISIZE);\n\n\t \n\tcfg = (EXYNOS_CISRCFMT_ITU601_8BIT |\n\t\tEXYNOS_CISRCFMT_SOURCEHSIZE(real_width) |\n\t\tEXYNOS_CISRCFMT_SOURCEVSIZE(buf->buf.height));\n\tfimc_write(ctx, cfg, EXYNOS_CISRCFMT);\n\n\t \n\tcfg = (EXYNOS_CIIYOFF_HORIZONTAL(buf->rect.x) |\n\t\tEXYNOS_CIIYOFF_VERTICAL(buf->rect.y));\n\tfimc_write(ctx, cfg, EXYNOS_CIIYOFF);\n\tcfg = (EXYNOS_CIICBOFF_HORIZONTAL(buf->rect.x) |\n\t\tEXYNOS_CIICBOFF_VERTICAL(buf->rect.y));\n\tfimc_write(ctx, cfg, EXYNOS_CIICBOFF);\n\tcfg = (EXYNOS_CIICROFF_HORIZONTAL(buf->rect.x) |\n\t\tEXYNOS_CIICROFF_VERTICAL(buf->rect.y));\n\tfimc_write(ctx, cfg, EXYNOS_CIICROFF);\n\n\tfimc_set_window(ctx, buf);\n}\n\nstatic void fimc_src_set_addr(struct fimc_context *ctx,\n\t\t\t      struct exynos_drm_ipp_buffer *buf)\n{\n\tfimc_write(ctx, buf->dma_addr[0], EXYNOS_CIIYSA(0));\n\tfimc_write(ctx, buf->dma_addr[1], EXYNOS_CIICBSA(0));\n\tfimc_write(ctx, buf->dma_addr[2], EXYNOS_CIICRSA(0));\n}\n\nstatic void fimc_dst_set_fmt_order(struct fimc_context *ctx, u32 fmt)\n{\n\tu32 cfg;\n\n\tDRM_DEV_DEBUG_KMS(ctx->dev, \"fmt[0x%x]\\n\", fmt);\n\n\t \n\tcfg = fimc_read(ctx, EXYNOS_CISCCTRL);\n\tcfg &= ~EXYNOS_CISCCTRL_OUTRGB_FMT_RGB_MASK;\n\n\tswitch (fmt) {\n\tcase DRM_FORMAT_RGB565:\n\t\tcfg |= EXYNOS_CISCCTRL_OUTRGB_FMT_RGB565;\n\t\tfimc_write(ctx, cfg, EXYNOS_CISCCTRL);\n\t\treturn;\n\tcase DRM_FORMAT_RGB888:\n\t\tcfg |= EXYNOS_CISCCTRL_OUTRGB_FMT_RGB888;\n\t\tfimc_write(ctx, cfg, EXYNOS_CISCCTRL);\n\t\treturn;\n\tcase DRM_FORMAT_XRGB8888:\n\t\tcfg |= (EXYNOS_CISCCTRL_OUTRGB_FMT_RGB888 |\n\t\t\tEXYNOS_CISCCTRL_EXTRGB_EXTENSION);\n\t\tfimc_write(ctx, cfg, EXYNOS_CISCCTRL);\n\t\tbreak;\n\tdefault:\n\t\t \n\t\tbreak;\n\t}\n\n\t \n\tcfg = fimc_read(ctx, EXYNOS_CIOCTRL);\n\tcfg &= ~(EXYNOS_CIOCTRL_ORDER2P_MASK |\n\t\tEXYNOS_CIOCTRL_ORDER422_MASK |\n\t\tEXYNOS_CIOCTRL_YCBCR_PLANE_MASK);\n\n\tswitch (fmt) {\n\tcase DRM_FORMAT_XRGB8888:\n\t\tcfg |= EXYNOS_CIOCTRL_ALPHA_OUT;\n\t\tbreak;\n\tcase DRM_FORMAT_YUYV:\n\t\tcfg |= EXYNOS_CIOCTRL_ORDER422_YCBYCR;\n\t\tbreak;\n\tcase DRM_FORMAT_YVYU:\n\t\tcfg |= EXYNOS_CIOCTRL_ORDER422_YCRYCB;\n\t\tbreak;\n\tcase DRM_FORMAT_UYVY:\n\t\tcfg |= EXYNOS_CIOCTRL_ORDER422_CBYCRY;\n\t\tbreak;\n\tcase DRM_FORMAT_VYUY:\n\t\tcfg |= EXYNOS_CIOCTRL_ORDER422_CRYCBY;\n\t\tbreak;\n\tcase DRM_FORMAT_NV21:\n\tcase DRM_FORMAT_NV61:\n\t\tcfg |= EXYNOS_CIOCTRL_ORDER2P_LSB_CRCB;\n\t\tcfg |= EXYNOS_CIOCTRL_YCBCR_2PLANE;\n\t\tbreak;\n\tcase DRM_FORMAT_YUV422:\n\tcase DRM_FORMAT_YUV420:\n\tcase DRM_FORMAT_YVU420:\n\t\tcfg |= EXYNOS_CIOCTRL_YCBCR_3PLANE;\n\t\tbreak;\n\tcase DRM_FORMAT_NV12:\n\tcase DRM_FORMAT_NV16:\n\t\tcfg |= EXYNOS_CIOCTRL_ORDER2P_LSB_CBCR;\n\t\tcfg |= EXYNOS_CIOCTRL_YCBCR_2PLANE;\n\t\tbreak;\n\t}\n\n\tfimc_write(ctx, cfg, EXYNOS_CIOCTRL);\n}\n\nstatic void fimc_dst_set_fmt(struct fimc_context *ctx, u32 fmt, bool tiled)\n{\n\tu32 cfg;\n\n\tDRM_DEV_DEBUG_KMS(ctx->dev, \"fmt[0x%x]\\n\", fmt);\n\n\tcfg = fimc_read(ctx, EXYNOS_CIEXTEN);\n\n\tif (fmt == DRM_FORMAT_AYUV) {\n\t\tcfg |= EXYNOS_CIEXTEN_YUV444_OUT;\n\t\tfimc_write(ctx, cfg, EXYNOS_CIEXTEN);\n\t} else {\n\t\tcfg &= ~EXYNOS_CIEXTEN_YUV444_OUT;\n\t\tfimc_write(ctx, cfg, EXYNOS_CIEXTEN);\n\n\t\tcfg = fimc_read(ctx, EXYNOS_CITRGFMT);\n\t\tcfg &= ~EXYNOS_CITRGFMT_OUTFORMAT_MASK;\n\n\t\tswitch (fmt) {\n\t\tcase DRM_FORMAT_RGB565:\n\t\tcase DRM_FORMAT_RGB888:\n\t\tcase DRM_FORMAT_XRGB8888:\n\t\t\tcfg |= EXYNOS_CITRGFMT_OUTFORMAT_RGB;\n\t\t\tbreak;\n\t\tcase DRM_FORMAT_YUYV:\n\t\tcase DRM_FORMAT_YVYU:\n\t\tcase DRM_FORMAT_UYVY:\n\t\tcase DRM_FORMAT_VYUY:\n\t\t\tcfg |= EXYNOS_CITRGFMT_OUTFORMAT_YCBCR422_1PLANE;\n\t\t\tbreak;\n\t\tcase DRM_FORMAT_NV16:\n\t\tcase DRM_FORMAT_NV61:\n\t\tcase DRM_FORMAT_YUV422:\n\t\t\tcfg |= EXYNOS_CITRGFMT_OUTFORMAT_YCBCR422;\n\t\t\tbreak;\n\t\tcase DRM_FORMAT_YUV420:\n\t\tcase DRM_FORMAT_YVU420:\n\t\tcase DRM_FORMAT_NV12:\n\t\tcase DRM_FORMAT_NV21:\n\t\t\tcfg |= EXYNOS_CITRGFMT_OUTFORMAT_YCBCR420;\n\t\t\tbreak;\n\t\t}\n\n\t\tfimc_write(ctx, cfg, EXYNOS_CITRGFMT);\n\t}\n\n\tcfg = fimc_read(ctx, EXYNOS_CIDMAPARAM);\n\tcfg &= ~EXYNOS_CIDMAPARAM_W_MODE_MASK;\n\n\tif (tiled)\n\t\tcfg |= EXYNOS_CIDMAPARAM_W_MODE_64X32;\n\telse\n\t\tcfg |= EXYNOS_CIDMAPARAM_W_MODE_LINEAR;\n\n\tfimc_write(ctx, cfg, EXYNOS_CIDMAPARAM);\n\n\tfimc_dst_set_fmt_order(ctx, fmt);\n}\n\nstatic void fimc_dst_set_transf(struct fimc_context *ctx, unsigned int rotation)\n{\n\tunsigned int degree = rotation & DRM_MODE_ROTATE_MASK;\n\tu32 cfg;\n\n\tDRM_DEV_DEBUG_KMS(ctx->dev, \"rotation[0x%x]\\n\", rotation);\n\n\tcfg = fimc_read(ctx, EXYNOS_CITRGFMT);\n\tcfg &= ~EXYNOS_CITRGFMT_FLIP_MASK;\n\tcfg &= ~EXYNOS_CITRGFMT_OUTROT90_CLOCKWISE;\n\n\tswitch (degree) {\n\tcase DRM_MODE_ROTATE_0:\n\t\tif (rotation & DRM_MODE_REFLECT_X)\n\t\t\tcfg |= EXYNOS_CITRGFMT_FLIP_X_MIRROR;\n\t\tif (rotation & DRM_MODE_REFLECT_Y)\n\t\t\tcfg |= EXYNOS_CITRGFMT_FLIP_Y_MIRROR;\n\t\tbreak;\n\tcase DRM_MODE_ROTATE_90:\n\t\tcfg |= EXYNOS_CITRGFMT_OUTROT90_CLOCKWISE;\n\t\tif (rotation & DRM_MODE_REFLECT_X)\n\t\t\tcfg |= EXYNOS_CITRGFMT_FLIP_X_MIRROR;\n\t\tif (rotation & DRM_MODE_REFLECT_Y)\n\t\t\tcfg |= EXYNOS_CITRGFMT_FLIP_Y_MIRROR;\n\t\tbreak;\n\tcase DRM_MODE_ROTATE_180:\n\t\tcfg |= (EXYNOS_CITRGFMT_FLIP_X_MIRROR |\n\t\t\tEXYNOS_CITRGFMT_FLIP_Y_MIRROR);\n\t\tif (rotation & DRM_MODE_REFLECT_X)\n\t\t\tcfg &= ~EXYNOS_CITRGFMT_FLIP_X_MIRROR;\n\t\tif (rotation & DRM_MODE_REFLECT_Y)\n\t\t\tcfg &= ~EXYNOS_CITRGFMT_FLIP_Y_MIRROR;\n\t\tbreak;\n\tcase DRM_MODE_ROTATE_270:\n\t\tcfg |= (EXYNOS_CITRGFMT_OUTROT90_CLOCKWISE |\n\t\t\tEXYNOS_CITRGFMT_FLIP_X_MIRROR |\n\t\t\tEXYNOS_CITRGFMT_FLIP_Y_MIRROR);\n\t\tif (rotation & DRM_MODE_REFLECT_X)\n\t\t\tcfg &= ~EXYNOS_CITRGFMT_FLIP_X_MIRROR;\n\t\tif (rotation & DRM_MODE_REFLECT_Y)\n\t\t\tcfg &= ~EXYNOS_CITRGFMT_FLIP_Y_MIRROR;\n\t\tbreak;\n\t}\n\n\tfimc_write(ctx, cfg, EXYNOS_CITRGFMT);\n}\n\nstatic int fimc_set_prescaler(struct fimc_context *ctx, struct fimc_scaler *sc,\n\t\t\t      struct drm_exynos_ipp_task_rect *src,\n\t\t\t      struct drm_exynos_ipp_task_rect *dst)\n{\n\tu32 cfg, cfg_ext, shfactor;\n\tu32 pre_dst_width, pre_dst_height;\n\tu32 hfactor, vfactor;\n\tint ret = 0;\n\tu32 src_w, src_h, dst_w, dst_h;\n\n\tcfg_ext = fimc_read(ctx, EXYNOS_CITRGFMT);\n\tif (cfg_ext & EXYNOS_CITRGFMT_INROT90_CLOCKWISE) {\n\t\tsrc_w = src->h;\n\t\tsrc_h = src->w;\n\t} else {\n\t\tsrc_w = src->w;\n\t\tsrc_h = src->h;\n\t}\n\n\tif (cfg_ext & EXYNOS_CITRGFMT_OUTROT90_CLOCKWISE) {\n\t\tdst_w = dst->h;\n\t\tdst_h = dst->w;\n\t} else {\n\t\tdst_w = dst->w;\n\t\tdst_h = dst->h;\n\t}\n\n\t \n\thfactor = fls(src_w / dst_w / 2);\n\tif (hfactor > FIMC_SHFACTOR / 2) {\n\t\tdev_err(ctx->dev, \"failed to get ratio horizontal.\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tvfactor = fls(src_h / dst_h / 2);\n\tif (vfactor > FIMC_SHFACTOR / 2) {\n\t\tdev_err(ctx->dev, \"failed to get ratio vertical.\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tpre_dst_width = src_w >> hfactor;\n\tpre_dst_height = src_h >> vfactor;\n\tDRM_DEV_DEBUG_KMS(ctx->dev, \"pre_dst_width[%d]pre_dst_height[%d]\\n\",\n\t\t\t  pre_dst_width, pre_dst_height);\n\tDRM_DEV_DEBUG_KMS(ctx->dev, \"hfactor[%d]vfactor[%d]\\n\", hfactor,\n\t\t\t  vfactor);\n\n\tsc->hratio = (src_w << 14) / (dst_w << hfactor);\n\tsc->vratio = (src_h << 14) / (dst_h << vfactor);\n\tsc->up_h = (dst_w >= src_w);\n\tsc->up_v = (dst_h >= src_h);\n\tDRM_DEV_DEBUG_KMS(ctx->dev, \"hratio[%d]vratio[%d]up_h[%d]up_v[%d]\\n\",\n\t\t\t  sc->hratio, sc->vratio, sc->up_h, sc->up_v);\n\n\tshfactor = FIMC_SHFACTOR - (hfactor + vfactor);\n\tDRM_DEV_DEBUG_KMS(ctx->dev, \"shfactor[%d]\\n\", shfactor);\n\n\tcfg = (EXYNOS_CISCPRERATIO_SHFACTOR(shfactor) |\n\t\tEXYNOS_CISCPRERATIO_PREHORRATIO(1 << hfactor) |\n\t\tEXYNOS_CISCPRERATIO_PREVERRATIO(1 << vfactor));\n\tfimc_write(ctx, cfg, EXYNOS_CISCPRERATIO);\n\n\tcfg = (EXYNOS_CISCPREDST_PREDSTWIDTH(pre_dst_width) |\n\t\tEXYNOS_CISCPREDST_PREDSTHEIGHT(pre_dst_height));\n\tfimc_write(ctx, cfg, EXYNOS_CISCPREDST);\n\n\treturn ret;\n}\n\nstatic void fimc_set_scaler(struct fimc_context *ctx, struct fimc_scaler *sc)\n{\n\tu32 cfg, cfg_ext;\n\n\tDRM_DEV_DEBUG_KMS(ctx->dev, \"range[%d]bypass[%d]up_h[%d]up_v[%d]\\n\",\n\t\t\t  sc->range, sc->bypass, sc->up_h, sc->up_v);\n\tDRM_DEV_DEBUG_KMS(ctx->dev, \"hratio[%d]vratio[%d]\\n\",\n\t\t\t  sc->hratio, sc->vratio);\n\n\tcfg = fimc_read(ctx, EXYNOS_CISCCTRL);\n\tcfg &= ~(EXYNOS_CISCCTRL_SCALERBYPASS |\n\t\tEXYNOS_CISCCTRL_SCALEUP_H | EXYNOS_CISCCTRL_SCALEUP_V |\n\t\tEXYNOS_CISCCTRL_MAIN_V_RATIO_MASK |\n\t\tEXYNOS_CISCCTRL_MAIN_H_RATIO_MASK |\n\t\tEXYNOS_CISCCTRL_CSCR2Y_WIDE |\n\t\tEXYNOS_CISCCTRL_CSCY2R_WIDE);\n\n\tif (sc->range)\n\t\tcfg |= (EXYNOS_CISCCTRL_CSCR2Y_WIDE |\n\t\t\tEXYNOS_CISCCTRL_CSCY2R_WIDE);\n\tif (sc->bypass)\n\t\tcfg |= EXYNOS_CISCCTRL_SCALERBYPASS;\n\tif (sc->up_h)\n\t\tcfg |= EXYNOS_CISCCTRL_SCALEUP_H;\n\tif (sc->up_v)\n\t\tcfg |= EXYNOS_CISCCTRL_SCALEUP_V;\n\n\tcfg |= (EXYNOS_CISCCTRL_MAINHORRATIO((sc->hratio >> 6)) |\n\t\tEXYNOS_CISCCTRL_MAINVERRATIO((sc->vratio >> 6)));\n\tfimc_write(ctx, cfg, EXYNOS_CISCCTRL);\n\n\tcfg_ext = fimc_read(ctx, EXYNOS_CIEXTEN);\n\tcfg_ext &= ~EXYNOS_CIEXTEN_MAINHORRATIO_EXT_MASK;\n\tcfg_ext &= ~EXYNOS_CIEXTEN_MAINVERRATIO_EXT_MASK;\n\tcfg_ext |= (EXYNOS_CIEXTEN_MAINHORRATIO_EXT(sc->hratio) |\n\t\tEXYNOS_CIEXTEN_MAINVERRATIO_EXT(sc->vratio));\n\tfimc_write(ctx, cfg_ext, EXYNOS_CIEXTEN);\n}\n\nstatic void fimc_dst_set_size(struct fimc_context *ctx,\n\t\t\t     struct exynos_drm_ipp_buffer *buf)\n{\n\tunsigned int real_width = buf->buf.pitch[0] / buf->format->cpp[0];\n\tu32 cfg, cfg_ext;\n\n\tDRM_DEV_DEBUG_KMS(ctx->dev, \"hsize[%d]vsize[%d]\\n\", real_width,\n\t\t\t  buf->buf.height);\n\n\t \n\tcfg = (EXYNOS_ORGOSIZE_HORIZONTAL(real_width) |\n\t\tEXYNOS_ORGOSIZE_VERTICAL(buf->buf.height));\n\n\tfimc_write(ctx, cfg, EXYNOS_ORGOSIZE);\n\n\tDRM_DEV_DEBUG_KMS(ctx->dev, \"x[%d]y[%d]w[%d]h[%d]\\n\", buf->rect.x,\n\t\t\t  buf->rect.y,\n\t\t\t  buf->rect.w, buf->rect.h);\n\n\t \n\tcfg = fimc_read(ctx, EXYNOS_CIGCTRL);\n\tcfg &= ~EXYNOS_CIGCTRL_CSC_MASK;\n\n\tif (buf->buf.width >= FIMC_WIDTH_ITU_709)\n\t\tcfg |= EXYNOS_CIGCTRL_CSC_ITU709;\n\telse\n\t\tcfg |= EXYNOS_CIGCTRL_CSC_ITU601;\n\n\tfimc_write(ctx, cfg, EXYNOS_CIGCTRL);\n\n\tcfg_ext = fimc_read(ctx, EXYNOS_CITRGFMT);\n\n\t \n\tcfg = fimc_read(ctx, EXYNOS_CITRGFMT);\n\tcfg &= ~(EXYNOS_CITRGFMT_TARGETH_MASK |\n\t\tEXYNOS_CITRGFMT_TARGETV_MASK);\n\tif (cfg_ext & EXYNOS_CITRGFMT_OUTROT90_CLOCKWISE)\n\t\tcfg |= (EXYNOS_CITRGFMT_TARGETHSIZE(buf->rect.h) |\n\t\t\tEXYNOS_CITRGFMT_TARGETVSIZE(buf->rect.w));\n\telse\n\t\tcfg |= (EXYNOS_CITRGFMT_TARGETHSIZE(buf->rect.w) |\n\t\t\tEXYNOS_CITRGFMT_TARGETVSIZE(buf->rect.h));\n\tfimc_write(ctx, cfg, EXYNOS_CITRGFMT);\n\n\t \n\tcfg = EXYNOS_CITAREA_TARGET_AREA(buf->rect.w * buf->rect.h);\n\tfimc_write(ctx, cfg, EXYNOS_CITAREA);\n\n\t \n\tcfg = (EXYNOS_CIOYOFF_HORIZONTAL(buf->rect.x) |\n\t\tEXYNOS_CIOYOFF_VERTICAL(buf->rect.y));\n\tfimc_write(ctx, cfg, EXYNOS_CIOYOFF);\n\tcfg = (EXYNOS_CIOCBOFF_HORIZONTAL(buf->rect.x) |\n\t\tEXYNOS_CIOCBOFF_VERTICAL(buf->rect.y));\n\tfimc_write(ctx, cfg, EXYNOS_CIOCBOFF);\n\tcfg = (EXYNOS_CIOCROFF_HORIZONTAL(buf->rect.x) |\n\t\tEXYNOS_CIOCROFF_VERTICAL(buf->rect.y));\n\tfimc_write(ctx, cfg, EXYNOS_CIOCROFF);\n}\n\nstatic void fimc_dst_set_buf_seq(struct fimc_context *ctx, u32 buf_id,\n\t\tbool enqueue)\n{\n\tunsigned long flags;\n\tu32 buf_num;\n\tu32 cfg;\n\n\tDRM_DEV_DEBUG_KMS(ctx->dev, \"buf_id[%d]enqueu[%d]\\n\", buf_id, enqueue);\n\n\tspin_lock_irqsave(&ctx->lock, flags);\n\n\tcfg = fimc_read(ctx, EXYNOS_CIFCNTSEQ);\n\n\tif (enqueue)\n\t\tcfg |= (1 << buf_id);\n\telse\n\t\tcfg &= ~(1 << buf_id);\n\n\tfimc_write(ctx, cfg, EXYNOS_CIFCNTSEQ);\n\n\tbuf_num = hweight32(cfg);\n\n\tif (enqueue && buf_num >= FIMC_BUF_START)\n\t\tfimc_mask_irq(ctx, true);\n\telse if (!enqueue && buf_num <= FIMC_BUF_STOP)\n\t\tfimc_mask_irq(ctx, false);\n\n\tspin_unlock_irqrestore(&ctx->lock, flags);\n}\n\nstatic void fimc_dst_set_addr(struct fimc_context *ctx,\n\t\t\t     struct exynos_drm_ipp_buffer *buf)\n{\n\tfimc_write(ctx, buf->dma_addr[0], EXYNOS_CIOYSA(0));\n\tfimc_write(ctx, buf->dma_addr[1], EXYNOS_CIOCBSA(0));\n\tfimc_write(ctx, buf->dma_addr[2], EXYNOS_CIOCRSA(0));\n\n\tfimc_dst_set_buf_seq(ctx, 0, true);\n}\n\nstatic void fimc_stop(struct fimc_context *ctx);\n\nstatic irqreturn_t fimc_irq_handler(int irq, void *dev_id)\n{\n\tstruct fimc_context *ctx = dev_id;\n\tint buf_id;\n\n\tDRM_DEV_DEBUG_KMS(ctx->dev, \"fimc id[%d]\\n\", ctx->id);\n\n\tfimc_clear_irq(ctx);\n\tif (fimc_check_ovf(ctx))\n\t\treturn IRQ_NONE;\n\n\tif (!fimc_check_frame_end(ctx))\n\t\treturn IRQ_NONE;\n\n\tbuf_id = fimc_get_buf_id(ctx);\n\tif (buf_id < 0)\n\t\treturn IRQ_HANDLED;\n\n\tDRM_DEV_DEBUG_KMS(ctx->dev, \"buf_id[%d]\\n\", buf_id);\n\n\tif (ctx->task) {\n\t\tstruct exynos_drm_ipp_task *task = ctx->task;\n\n\t\tctx->task = NULL;\n\t\tpm_runtime_mark_last_busy(ctx->dev);\n\t\tpm_runtime_put_autosuspend(ctx->dev);\n\t\texynos_drm_ipp_task_done(task, 0);\n\t}\n\n\tfimc_dst_set_buf_seq(ctx, buf_id, false);\n\tfimc_stop(ctx);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic void fimc_clear_addr(struct fimc_context *ctx)\n{\n\tint i;\n\n\tfor (i = 0; i < FIMC_MAX_SRC; i++) {\n\t\tfimc_write(ctx, 0, EXYNOS_CIIYSA(i));\n\t\tfimc_write(ctx, 0, EXYNOS_CIICBSA(i));\n\t\tfimc_write(ctx, 0, EXYNOS_CIICRSA(i));\n\t}\n\n\tfor (i = 0; i < FIMC_MAX_DST; i++) {\n\t\tfimc_write(ctx, 0, EXYNOS_CIOYSA(i));\n\t\tfimc_write(ctx, 0, EXYNOS_CIOCBSA(i));\n\t\tfimc_write(ctx, 0, EXYNOS_CIOCRSA(i));\n\t}\n}\n\nstatic void fimc_reset(struct fimc_context *ctx)\n{\n\t \n\tfimc_sw_reset(ctx);\n\n\t \n\tmemset(&ctx->sc, 0x0, sizeof(ctx->sc));\n\n\tfimc_clear_addr(ctx);\n}\n\nstatic void fimc_start(struct fimc_context *ctx)\n{\n\tu32 cfg0, cfg1;\n\n\tfimc_mask_irq(ctx, true);\n\n\t \n\tfimc_handle_jpeg(ctx, false);\n\tfimc_set_scaler(ctx, &ctx->sc);\n\n\tfimc_set_type_ctrl(ctx);\n\tfimc_handle_lastend(ctx, false);\n\n\t \n\tcfg0 = fimc_read(ctx, EXYNOS_MSCTRL);\n\tcfg0 &= ~EXYNOS_MSCTRL_INPUT_MASK;\n\tcfg0 |= EXYNOS_MSCTRL_INPUT_MEMORY;\n\tfimc_write(ctx, cfg0, EXYNOS_MSCTRL);\n\n\t \n\tfimc_write(ctx, 0x0, EXYNOS_CISTATUS);\n\n\tcfg0 = fimc_read(ctx, EXYNOS_CIIMGCPT);\n\tcfg0 &= ~EXYNOS_CIIMGCPT_IMGCPTEN_SC;\n\tcfg0 |= EXYNOS_CIIMGCPT_IMGCPTEN_SC;\n\n\t \n\tcfg1 = fimc_read(ctx, EXYNOS_CISCCTRL);\n\tcfg1 &= ~EXYNOS_CISCCTRL_SCAN_MASK;\n\tcfg1 |= (EXYNOS_CISCCTRL_PROGRESSIVE |\n\t\tEXYNOS_CISCCTRL_SCALERSTART);\n\n\tfimc_write(ctx, cfg1, EXYNOS_CISCCTRL);\n\n\t \n\tcfg0 |= EXYNOS_CIIMGCPT_IMGCPTEN;\n\tfimc_write(ctx, cfg0, EXYNOS_CIIMGCPT);\n\n\t \n\tfimc_clear_bits(ctx, EXYNOS_CIGCTRL, EXYNOS_CIGCTRL_IRQ_END_DISABLE);\n\n\tfimc_clear_bits(ctx, EXYNOS_CIOCTRL, EXYNOS_CIOCTRL_WEAVE_MASK);\n\n\tfimc_set_bits(ctx, EXYNOS_MSCTRL, EXYNOS_MSCTRL_ENVID);\n}\n\nstatic void fimc_stop(struct fimc_context *ctx)\n{\n\tu32 cfg;\n\n\t \n\tcfg = fimc_read(ctx, EXYNOS_MSCTRL);\n\tcfg &= ~EXYNOS_MSCTRL_INPUT_MASK;\n\tcfg &= ~EXYNOS_MSCTRL_ENVID;\n\tfimc_write(ctx, cfg, EXYNOS_MSCTRL);\n\n\tfimc_mask_irq(ctx, false);\n\n\t \n\tfimc_write(ctx, 0x0, EXYNOS_CIFCNTSEQ);\n\n\t \n\tfimc_clear_bits(ctx, EXYNOS_CISCCTRL, EXYNOS_CISCCTRL_SCALERSTART);\n\n\t \n\tfimc_clear_bits(ctx, EXYNOS_CIIMGCPT,\n\t\tEXYNOS_CIIMGCPT_IMGCPTEN_SC | EXYNOS_CIIMGCPT_IMGCPTEN);\n\n\t \n\tfimc_set_bits(ctx, EXYNOS_CIGCTRL, EXYNOS_CIGCTRL_IRQ_END_DISABLE);\n}\n\nstatic int fimc_commit(struct exynos_drm_ipp *ipp,\n\t\t\t  struct exynos_drm_ipp_task *task)\n{\n\tstruct fimc_context *ctx =\n\t\t\tcontainer_of(ipp, struct fimc_context, ipp);\n\tint ret;\n\n\tret = pm_runtime_resume_and_get(ctx->dev);\n\tif (ret < 0) {\n\t\tdev_err(ctx->dev, \"failed to enable FIMC device.\\n\");\n\t\treturn ret;\n\t}\n\n\tctx->task = task;\n\n\tfimc_src_set_fmt(ctx, task->src.buf.fourcc, task->src.buf.modifier);\n\tfimc_src_set_size(ctx, &task->src);\n\tfimc_src_set_transf(ctx, DRM_MODE_ROTATE_0);\n\tfimc_src_set_addr(ctx, &task->src);\n\tfimc_dst_set_fmt(ctx, task->dst.buf.fourcc, task->dst.buf.modifier);\n\tfimc_dst_set_transf(ctx, task->transform.rotation);\n\tfimc_dst_set_size(ctx, &task->dst);\n\tfimc_dst_set_addr(ctx, &task->dst);\n\tfimc_set_prescaler(ctx, &ctx->sc, &task->src.rect, &task->dst.rect);\n\tfimc_start(ctx);\n\n\treturn 0;\n}\n\nstatic void fimc_abort(struct exynos_drm_ipp *ipp,\n\t\t\t  struct exynos_drm_ipp_task *task)\n{\n\tstruct fimc_context *ctx =\n\t\t\tcontainer_of(ipp, struct fimc_context, ipp);\n\n\tfimc_reset(ctx);\n\n\tif (ctx->task) {\n\t\tstruct exynos_drm_ipp_task *task = ctx->task;\n\n\t\tctx->task = NULL;\n\t\tpm_runtime_mark_last_busy(ctx->dev);\n\t\tpm_runtime_put_autosuspend(ctx->dev);\n\t\texynos_drm_ipp_task_done(task, -EIO);\n\t}\n}\n\nstatic struct exynos_drm_ipp_funcs ipp_funcs = {\n\t.commit = fimc_commit,\n\t.abort = fimc_abort,\n};\n\nstatic int fimc_bind(struct device *dev, struct device *master, void *data)\n{\n\tstruct fimc_context *ctx = dev_get_drvdata(dev);\n\tstruct drm_device *drm_dev = data;\n\tstruct exynos_drm_ipp *ipp = &ctx->ipp;\n\n\tctx->drm_dev = drm_dev;\n\tipp->drm_dev = drm_dev;\n\texynos_drm_register_dma(drm_dev, dev, &ctx->dma_priv);\n\n\texynos_drm_ipp_register(dev, ipp, &ipp_funcs,\n\t\t\tDRM_EXYNOS_IPP_CAP_CROP | DRM_EXYNOS_IPP_CAP_ROTATE |\n\t\t\tDRM_EXYNOS_IPP_CAP_SCALE | DRM_EXYNOS_IPP_CAP_CONVERT,\n\t\t\tctx->formats, ctx->num_formats, \"fimc\");\n\n\tdev_info(dev, \"The exynos fimc has been probed successfully\\n\");\n\n\treturn 0;\n}\n\nstatic void fimc_unbind(struct device *dev, struct device *master,\n\t\t\tvoid *data)\n{\n\tstruct fimc_context *ctx = dev_get_drvdata(dev);\n\tstruct drm_device *drm_dev = data;\n\tstruct exynos_drm_ipp *ipp = &ctx->ipp;\n\n\texynos_drm_ipp_unregister(dev, ipp);\n\texynos_drm_unregister_dma(drm_dev, dev, &ctx->dma_priv);\n}\n\nstatic const struct component_ops fimc_component_ops = {\n\t.bind\t= fimc_bind,\n\t.unbind = fimc_unbind,\n};\n\nstatic void fimc_put_clocks(struct fimc_context *ctx)\n{\n\tint i;\n\n\tfor (i = 0; i < FIMC_CLKS_MAX; i++) {\n\t\tif (IS_ERR(ctx->clocks[i]))\n\t\t\tcontinue;\n\t\tclk_put(ctx->clocks[i]);\n\t\tctx->clocks[i] = ERR_PTR(-EINVAL);\n\t}\n}\n\nstatic int fimc_setup_clocks(struct fimc_context *ctx)\n{\n\tstruct device *fimc_dev = ctx->dev;\n\tstruct device *dev;\n\tint ret, i;\n\n\tfor (i = 0; i < FIMC_CLKS_MAX; i++)\n\t\tctx->clocks[i] = ERR_PTR(-EINVAL);\n\n\tfor (i = 0; i < FIMC_CLKS_MAX; i++) {\n\t\tif (i == FIMC_CLK_WB_A || i == FIMC_CLK_WB_B)\n\t\t\tdev = fimc_dev->parent;\n\t\telse\n\t\t\tdev = fimc_dev;\n\n\t\tctx->clocks[i] = clk_get(dev, fimc_clock_names[i]);\n\t\tif (IS_ERR(ctx->clocks[i])) {\n\t\t\tret = PTR_ERR(ctx->clocks[i]);\n\t\t\tdev_err(fimc_dev, \"failed to get clock: %s\\n\",\n\t\t\t\t\t\tfimc_clock_names[i]);\n\t\t\tgoto e_clk_free;\n\t\t}\n\t}\n\n\tret = clk_prepare_enable(ctx->clocks[FIMC_CLK_LCLK]);\n\tif (!ret)\n\t\treturn ret;\ne_clk_free:\n\tfimc_put_clocks(ctx);\n\treturn ret;\n}\n\nint exynos_drm_check_fimc_device(struct device *dev)\n{\n\tint id = of_alias_get_id(dev->of_node, \"fimc\");\n\n\tif (id >= 0 && (BIT(id) & fimc_mask))\n\t\treturn 0;\n\treturn -ENODEV;\n}\n\nstatic const unsigned int fimc_formats[] = {\n\tDRM_FORMAT_XRGB8888, DRM_FORMAT_RGB565,\n\tDRM_FORMAT_NV12, DRM_FORMAT_NV16, DRM_FORMAT_NV21, DRM_FORMAT_NV61,\n\tDRM_FORMAT_UYVY, DRM_FORMAT_VYUY, DRM_FORMAT_YUYV, DRM_FORMAT_YVYU,\n\tDRM_FORMAT_YUV420, DRM_FORMAT_YVU420, DRM_FORMAT_YUV422,\n\tDRM_FORMAT_YUV444,\n};\n\nstatic const unsigned int fimc_tiled_formats[] = {\n\tDRM_FORMAT_NV12, DRM_FORMAT_NV21,\n};\n\nstatic const struct drm_exynos_ipp_limit fimc_4210_limits_v1[] = {\n\t{ IPP_SIZE_LIMIT(BUFFER, .h = { 16, 8192, 8 }, .v = { 16, 8192, 2 }) },\n\t{ IPP_SIZE_LIMIT(AREA, .h = { 16, 4224, 2 }, .v = { 16, 0, 2 }) },\n\t{ IPP_SIZE_LIMIT(ROTATED, .h = { 128, 1920 }, .v = { 128, 0 }) },\n\t{ IPP_SCALE_LIMIT(.h = { (1 << 16) / 64, (1 << 16) * 64 },\n\t\t\t  .v = { (1 << 16) / 64, (1 << 16) * 64 }) },\n};\n\nstatic const struct drm_exynos_ipp_limit fimc_4210_limits_v2[] = {\n\t{ IPP_SIZE_LIMIT(BUFFER, .h = { 16, 8192, 8 }, .v = { 16, 8192, 2 }) },\n\t{ IPP_SIZE_LIMIT(AREA, .h = { 16, 1920, 2 }, .v = { 16, 0, 2 }) },\n\t{ IPP_SIZE_LIMIT(ROTATED, .h = { 128, 1366 }, .v = { 128, 0 }) },\n\t{ IPP_SCALE_LIMIT(.h = { (1 << 16) / 64, (1 << 16) * 64 },\n\t\t\t  .v = { (1 << 16) / 64, (1 << 16) * 64 }) },\n};\n\nstatic const struct drm_exynos_ipp_limit fimc_4210_limits_tiled_v1[] = {\n\t{ IPP_SIZE_LIMIT(BUFFER, .h = { 128, 1920, 128 }, .v = { 32, 1920, 32 }) },\n\t{ IPP_SIZE_LIMIT(AREA, .h = { 128, 1920, 2 }, .v = { 128, 0, 2 }) },\n\t{ IPP_SCALE_LIMIT(.h = { (1 << 16) / 64, (1 << 16) * 64 },\n\t\t\t  .v = { (1 << 16) / 64, (1 << 16) * 64 }) },\n};\n\nstatic const struct drm_exynos_ipp_limit fimc_4210_limits_tiled_v2[] = {\n\t{ IPP_SIZE_LIMIT(BUFFER, .h = { 128, 1920, 128 }, .v = { 32, 1920, 32 }) },\n\t{ IPP_SIZE_LIMIT(AREA, .h = { 128, 1366, 2 }, .v = { 128, 0, 2 }) },\n\t{ IPP_SCALE_LIMIT(.h = { (1 << 16) / 64, (1 << 16) * 64 },\n\t\t\t  .v = { (1 << 16) / 64, (1 << 16) * 64 }) },\n};\n\nstatic int fimc_probe(struct platform_device *pdev)\n{\n\tconst struct drm_exynos_ipp_limit *limits;\n\tstruct exynos_drm_ipp_formats *formats;\n\tstruct device *dev = &pdev->dev;\n\tstruct fimc_context *ctx;\n\tint ret;\n\tint i, j, num_limits, num_formats;\n\n\tif (exynos_drm_check_fimc_device(dev) != 0)\n\t\treturn -ENODEV;\n\n\tctx = devm_kzalloc(dev, sizeof(*ctx), GFP_KERNEL);\n\tif (!ctx)\n\t\treturn -ENOMEM;\n\n\tctx->dev = dev;\n\tctx->id = of_alias_get_id(dev->of_node, \"fimc\");\n\n\t \n\tnum_formats = ARRAY_SIZE(fimc_formats) + ARRAY_SIZE(fimc_tiled_formats);\n\tformats = devm_kcalloc(dev, num_formats, sizeof(*formats),\n\t\t\t       GFP_KERNEL);\n\tif (!formats)\n\t\treturn -ENOMEM;\n\n\t \n\tif (ctx->id < 3) {\n\t\tlimits = fimc_4210_limits_v1;\n\t\tnum_limits = ARRAY_SIZE(fimc_4210_limits_v1);\n\t} else {\n\t\tlimits = fimc_4210_limits_v2;\n\t\tnum_limits = ARRAY_SIZE(fimc_4210_limits_v2);\n\t}\n\tfor (i = 0; i < ARRAY_SIZE(fimc_formats); i++) {\n\t\tformats[i].fourcc = fimc_formats[i];\n\t\tformats[i].type = DRM_EXYNOS_IPP_FORMAT_SOURCE |\n\t\t\t\t  DRM_EXYNOS_IPP_FORMAT_DESTINATION;\n\t\tformats[i].limits = limits;\n\t\tformats[i].num_limits = num_limits;\n\t}\n\n\t \n\tif (ctx->id < 3) {\n\t\tlimits = fimc_4210_limits_tiled_v1;\n\t\tnum_limits = ARRAY_SIZE(fimc_4210_limits_tiled_v1);\n\t} else {\n\t\tlimits = fimc_4210_limits_tiled_v2;\n\t\tnum_limits = ARRAY_SIZE(fimc_4210_limits_tiled_v2);\n\t}\n\tfor (j = i, i = 0; i < ARRAY_SIZE(fimc_tiled_formats); j++, i++) {\n\t\tformats[j].fourcc = fimc_tiled_formats[i];\n\t\tformats[j].modifier = DRM_FORMAT_MOD_SAMSUNG_64_32_TILE;\n\t\tformats[j].type = DRM_EXYNOS_IPP_FORMAT_SOURCE |\n\t\t\t\t  DRM_EXYNOS_IPP_FORMAT_DESTINATION;\n\t\tformats[j].limits = limits;\n\t\tformats[j].num_limits = num_limits;\n\t}\n\n\tctx->formats = formats;\n\tctx->num_formats = num_formats;\n\n\t \n\tctx->regs = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(ctx->regs))\n\t\treturn PTR_ERR(ctx->regs);\n\n\t \n\tret = platform_get_irq(pdev, 0);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = devm_request_irq(dev, ret, fimc_irq_handler,\n\t\t\t       0, dev_name(dev), ctx);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"failed to request irq.\\n\");\n\t\treturn ret;\n\t}\n\n\tret = fimc_setup_clocks(ctx);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tspin_lock_init(&ctx->lock);\n\tplatform_set_drvdata(pdev, ctx);\n\n\tpm_runtime_use_autosuspend(dev);\n\tpm_runtime_set_autosuspend_delay(dev, FIMC_AUTOSUSPEND_DELAY);\n\tpm_runtime_enable(dev);\n\n\tret = component_add(dev, &fimc_component_ops);\n\tif (ret)\n\t\tgoto err_pm_dis;\n\n\tdev_info(dev, \"drm fimc registered successfully.\\n\");\n\n\treturn 0;\n\nerr_pm_dis:\n\tpm_runtime_dont_use_autosuspend(dev);\n\tpm_runtime_disable(dev);\n\tfimc_put_clocks(ctx);\n\n\treturn ret;\n}\n\nstatic int fimc_remove(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct fimc_context *ctx = get_fimc_context(dev);\n\n\tcomponent_del(dev, &fimc_component_ops);\n\tpm_runtime_dont_use_autosuspend(dev);\n\tpm_runtime_disable(dev);\n\n\tfimc_put_clocks(ctx);\n\n\treturn 0;\n}\n\nstatic int fimc_runtime_suspend(struct device *dev)\n{\n\tstruct fimc_context *ctx = get_fimc_context(dev);\n\n\tDRM_DEV_DEBUG_KMS(dev, \"id[%d]\\n\", ctx->id);\n\tclk_disable_unprepare(ctx->clocks[FIMC_CLK_GATE]);\n\treturn 0;\n}\n\nstatic int fimc_runtime_resume(struct device *dev)\n{\n\tstruct fimc_context *ctx = get_fimc_context(dev);\n\n\tDRM_DEV_DEBUG_KMS(dev, \"id[%d]\\n\", ctx->id);\n\treturn clk_prepare_enable(ctx->clocks[FIMC_CLK_GATE]);\n}\n\nstatic DEFINE_RUNTIME_DEV_PM_OPS(fimc_pm_ops, fimc_runtime_suspend,\n\t\t\t\t fimc_runtime_resume, NULL);\n\nstatic const struct of_device_id fimc_of_match[] = {\n\t{ .compatible = \"samsung,exynos4210-fimc\" },\n\t{ .compatible = \"samsung,exynos4212-fimc\" },\n\t{ },\n};\nMODULE_DEVICE_TABLE(of, fimc_of_match);\n\nstruct platform_driver fimc_driver = {\n\t.probe\t\t= fimc_probe,\n\t.remove\t\t= fimc_remove,\n\t.driver\t\t= {\n\t\t.of_match_table = fimc_of_match,\n\t\t.name\t= \"exynos-drm-fimc\",\n\t\t.owner\t= THIS_MODULE,\n\t\t.pm\t= pm_ptr(&fimc_pm_ops),\n\t},\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}