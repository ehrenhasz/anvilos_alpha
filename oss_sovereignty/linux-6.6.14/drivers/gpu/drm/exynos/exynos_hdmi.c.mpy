{
  "module_name": "exynos_hdmi.c",
  "hash_id": "bffc7f5a46b2e38ccac092e45971e1c183784362ecbb7ed6dae9fc7241ee150e",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/exynos/exynos_hdmi.c",
  "human_readable_source": "\n \n\n#include <drm/exynos_drm.h>\n#include <linux/clk.h>\n#include <linux/component.h>\n#include <linux/delay.h>\n#include <linux/gpio/consumer.h>\n#include <linux/hdmi.h>\n#include <linux/i2c.h>\n#include <linux/interrupt.h>\n#include <linux/io.h>\n#include <linux/irq.h>\n#include <linux/kernel.h>\n#include <linux/mfd/syscon.h>\n#include <linux/of.h>\n#include <linux/of_address.h>\n#include <linux/of_graph.h>\n#include <linux/platform_device.h>\n#include <linux/pm_runtime.h>\n#include <linux/regmap.h>\n#include <linux/regulator/consumer.h>\n#include <linux/wait.h>\n\n#include <sound/hdmi-codec.h>\n#include <media/cec-notifier.h>\n\n#include <drm/drm_atomic_helper.h>\n#include <drm/drm_bridge.h>\n#include <drm/drm_edid.h>\n#include <drm/drm_print.h>\n#include <drm/drm_probe_helper.h>\n#include <drm/drm_simple_kms_helper.h>\n\n#include \"exynos_drm_crtc.h\"\n#include \"regs-hdmi.h\"\n\n#define HOTPLUG_DEBOUNCE_MS\t\t1100\n\nenum hdmi_type {\n\tHDMI_TYPE13,\n\tHDMI_TYPE14,\n\tHDMI_TYPE_COUNT\n};\n\n#define HDMI_MAPPED_BASE 0xffff0000\n\nenum hdmi_mapped_regs {\n\tHDMI_PHY_STATUS = HDMI_MAPPED_BASE,\n\tHDMI_PHY_RSTOUT,\n\tHDMI_ACR_CON,\n\tHDMI_ACR_MCTS0,\n\tHDMI_ACR_CTS0,\n\tHDMI_ACR_N0\n};\n\nstatic const u32 hdmi_reg_map[][HDMI_TYPE_COUNT] = {\n\t{ HDMI_V13_PHY_STATUS, HDMI_PHY_STATUS_0 },\n\t{ HDMI_V13_PHY_RSTOUT, HDMI_V14_PHY_RSTOUT },\n\t{ HDMI_V13_ACR_CON, HDMI_V14_ACR_CON },\n\t{ HDMI_V13_ACR_MCTS0, HDMI_V14_ACR_MCTS0 },\n\t{ HDMI_V13_ACR_CTS0, HDMI_V14_ACR_CTS0 },\n\t{ HDMI_V13_ACR_N0, HDMI_V14_ACR_N0 },\n};\n\nstatic const char * const supply[] = {\n\t\"vdd\",\n\t\"vdd_osc\",\n\t\"vdd_pll\",\n};\n\nstruct hdmiphy_config {\n\tint pixel_clock;\n\tu8 conf[32];\n};\n\nstruct hdmiphy_configs {\n\tint count;\n\tconst struct hdmiphy_config *data;\n};\n\nstruct string_array_spec {\n\tint count;\n\tconst char * const *data;\n};\n\n#define INIT_ARRAY_SPEC(a) { .count = ARRAY_SIZE(a), .data = a }\n\nstruct hdmi_driver_data {\n\tunsigned int type;\n\tunsigned int is_apb_phy:1;\n\tunsigned int has_sysreg:1;\n\tstruct hdmiphy_configs phy_confs;\n\tstruct string_array_spec clk_gates;\n\t \n\tstruct string_array_spec clk_muxes;\n};\n\nstruct hdmi_audio {\n\tstruct platform_device\t\t*pdev;\n\tstruct hdmi_audio_infoframe\tinfoframe;\n\tstruct hdmi_codec_params\tparams;\n\tbool\t\t\t\tmute;\n};\n\nstruct hdmi_context {\n\tstruct drm_encoder\t\tencoder;\n\tstruct device\t\t\t*dev;\n\tstruct drm_device\t\t*drm_dev;\n\tstruct drm_connector\t\tconnector;\n\tbool\t\t\t\tdvi_mode;\n\tstruct delayed_work\t\thotplug_work;\n\tstruct cec_notifier\t\t*notifier;\n\tconst struct hdmi_driver_data\t*drv_data;\n\n\tvoid __iomem\t\t\t*regs;\n\tvoid __iomem\t\t\t*regs_hdmiphy;\n\tstruct i2c_client\t\t*hdmiphy_port;\n\tstruct i2c_adapter\t\t*ddc_adpt;\n\tstruct gpio_desc\t\t*hpd_gpio;\n\tint\t\t\t\tirq;\n\tstruct regmap\t\t\t*pmureg;\n\tstruct regmap\t\t\t*sysreg;\n\tstruct clk\t\t\t**clk_gates;\n\tstruct clk\t\t\t**clk_muxes;\n\tstruct regulator_bulk_data\tregul_bulk[ARRAY_SIZE(supply)];\n\tstruct regulator\t\t*reg_hdmi_en;\n\tstruct exynos_drm_clk\t\tphy_clk;\n\tstruct drm_bridge\t\t*bridge;\n\n\t \n\tstruct mutex\t\t\tmutex;\n\tstruct hdmi_audio\t\taudio;\n\tbool\t\t\t\tpowered;\n};\n\nstatic inline struct hdmi_context *encoder_to_hdmi(struct drm_encoder *e)\n{\n\treturn container_of(e, struct hdmi_context, encoder);\n}\n\nstatic inline struct hdmi_context *connector_to_hdmi(struct drm_connector *c)\n{\n\treturn container_of(c, struct hdmi_context, connector);\n}\n\nstatic const struct hdmiphy_config hdmiphy_v13_configs[] = {\n\t{\n\t\t.pixel_clock = 27000000,\n\t\t.conf = {\n\t\t\t0x01, 0x05, 0x00, 0xD8, 0x10, 0x1C, 0x30, 0x40,\n\t\t\t0x6B, 0x10, 0x02, 0x51, 0xDF, 0xF2, 0x54, 0x87,\n\t\t\t0x84, 0x00, 0x30, 0x38, 0x00, 0x08, 0x10, 0xE0,\n\t\t\t0x22, 0x40, 0xE3, 0x26, 0x00, 0x00, 0x00, 0x80,\n\t\t},\n\t},\n\t{\n\t\t.pixel_clock = 27027000,\n\t\t.conf = {\n\t\t\t0x01, 0x05, 0x00, 0xD4, 0x10, 0x9C, 0x09, 0x64,\n\t\t\t0x6B, 0x10, 0x02, 0x51, 0xDF, 0xF2, 0x54, 0x87,\n\t\t\t0x84, 0x00, 0x30, 0x38, 0x00, 0x08, 0x10, 0xE0,\n\t\t\t0x22, 0x40, 0xE3, 0x26, 0x00, 0x00, 0x00, 0x80,\n\t\t},\n\t},\n\t{\n\t\t.pixel_clock = 74176000,\n\t\t.conf = {\n\t\t\t0x01, 0x05, 0x00, 0xD8, 0x10, 0x9C, 0xef, 0x5B,\n\t\t\t0x6D, 0x10, 0x01, 0x51, 0xef, 0xF3, 0x54, 0xb9,\n\t\t\t0x84, 0x00, 0x30, 0x38, 0x00, 0x08, 0x10, 0xE0,\n\t\t\t0x22, 0x40, 0xa5, 0x26, 0x01, 0x00, 0x00, 0x80,\n\t\t},\n\t},\n\t{\n\t\t.pixel_clock = 74250000,\n\t\t.conf = {\n\t\t\t0x01, 0x05, 0x00, 0xd8, 0x10, 0x9c, 0xf8, 0x40,\n\t\t\t0x6a, 0x10, 0x01, 0x51, 0xff, 0xf1, 0x54, 0xba,\n\t\t\t0x84, 0x00, 0x10, 0x38, 0x00, 0x08, 0x10, 0xe0,\n\t\t\t0x22, 0x40, 0xa4, 0x26, 0x01, 0x00, 0x00, 0x80,\n\t\t},\n\t},\n\t{\n\t\t.pixel_clock = 148500000,\n\t\t.conf = {\n\t\t\t0x01, 0x05, 0x00, 0xD8, 0x10, 0x9C, 0xf8, 0x40,\n\t\t\t0x6A, 0x18, 0x00, 0x51, 0xff, 0xF1, 0x54, 0xba,\n\t\t\t0x84, 0x00, 0x10, 0x38, 0x00, 0x08, 0x10, 0xE0,\n\t\t\t0x22, 0x40, 0xa4, 0x26, 0x02, 0x00, 0x00, 0x80,\n\t\t},\n\t},\n};\n\nstatic const struct hdmiphy_config hdmiphy_v14_configs[] = {\n\t{\n\t\t.pixel_clock = 25200000,\n\t\t.conf = {\n\t\t\t0x01, 0x51, 0x2A, 0x75, 0x40, 0x01, 0x00, 0x08,\n\t\t\t0x82, 0x80, 0xfc, 0xd8, 0x45, 0xa0, 0xac, 0x80,\n\t\t\t0x08, 0x80, 0x11, 0x04, 0x02, 0x22, 0x44, 0x86,\n\t\t\t0x54, 0xf4, 0x24, 0x00, 0x00, 0x00, 0x01, 0x80,\n\t\t},\n\t},\n\t{\n\t\t.pixel_clock = 27000000,\n\t\t.conf = {\n\t\t\t0x01, 0xd1, 0x22, 0x51, 0x40, 0x08, 0xfc, 0x20,\n\t\t\t0x98, 0xa0, 0xcb, 0xd8, 0x45, 0xa0, 0xac, 0x80,\n\t\t\t0x06, 0x80, 0x11, 0x04, 0x02, 0x22, 0x44, 0x86,\n\t\t\t0x54, 0xe4, 0x24, 0x00, 0x00, 0x00, 0x01, 0x80,\n\t\t},\n\t},\n\t{\n\t\t.pixel_clock = 27027000,\n\t\t.conf = {\n\t\t\t0x01, 0xd1, 0x2d, 0x72, 0x40, 0x64, 0x12, 0x08,\n\t\t\t0x43, 0xa0, 0x0e, 0xd9, 0x45, 0xa0, 0xac, 0x80,\n\t\t\t0x08, 0x80, 0x11, 0x04, 0x02, 0x22, 0x44, 0x86,\n\t\t\t0x54, 0xe3, 0x24, 0x00, 0x00, 0x00, 0x01, 0x80,\n\t\t},\n\t},\n\t{\n\t\t.pixel_clock = 36000000,\n\t\t.conf = {\n\t\t\t0x01, 0x51, 0x2d, 0x55, 0x40, 0x01, 0x00, 0x08,\n\t\t\t0x82, 0x80, 0x0e, 0xd9, 0x45, 0xa0, 0xac, 0x80,\n\t\t\t0x08, 0x80, 0x11, 0x04, 0x02, 0x22, 0x44, 0x86,\n\t\t\t0x54, 0xab, 0x24, 0x00, 0x00, 0x00, 0x01, 0x80,\n\t\t},\n\t},\n\t{\n\t\t.pixel_clock = 40000000,\n\t\t.conf = {\n\t\t\t0x01, 0x51, 0x32, 0x55, 0x40, 0x01, 0x00, 0x08,\n\t\t\t0x82, 0x80, 0x2c, 0xd9, 0x45, 0xa0, 0xac, 0x80,\n\t\t\t0x08, 0x80, 0x11, 0x04, 0x02, 0x22, 0x44, 0x86,\n\t\t\t0x54, 0x9a, 0x24, 0x00, 0x00, 0x00, 0x01, 0x80,\n\t\t},\n\t},\n\t{\n\t\t.pixel_clock = 65000000,\n\t\t.conf = {\n\t\t\t0x01, 0xd1, 0x36, 0x34, 0x40, 0x1e, 0x0a, 0x08,\n\t\t\t0x82, 0xa0, 0x45, 0xd9, 0x45, 0xa0, 0xac, 0x80,\n\t\t\t0x08, 0x80, 0x11, 0x04, 0x02, 0x22, 0x44, 0x86,\n\t\t\t0x54, 0xbd, 0x24, 0x01, 0x00, 0x00, 0x01, 0x80,\n\t\t},\n\t},\n\t{\n\t\t.pixel_clock = 71000000,\n\t\t.conf = {\n\t\t\t0x01, 0xd1, 0x3b, 0x35, 0x40, 0x0c, 0x04, 0x08,\n\t\t\t0x85, 0xa0, 0x63, 0xd9, 0x45, 0xa0, 0xac, 0x80,\n\t\t\t0x08, 0x80, 0x11, 0x04, 0x02, 0x22, 0x44, 0x86,\n\t\t\t0x54, 0xad, 0x24, 0x01, 0x00, 0x00, 0x01, 0x80,\n\t\t},\n\t},\n\t{\n\t\t.pixel_clock = 73250000,\n\t\t.conf = {\n\t\t\t0x01, 0xd1, 0x3d, 0x35, 0x40, 0x18, 0x02, 0x08,\n\t\t\t0x83, 0xa0, 0x6e, 0xd9, 0x45, 0xa0, 0xac, 0x80,\n\t\t\t0x08, 0x80, 0x11, 0x04, 0x02, 0x22, 0x44, 0x86,\n\t\t\t0x54, 0xa8, 0x24, 0x01, 0x00, 0x00, 0x01, 0x80,\n\t\t},\n\t},\n\t{\n\t\t.pixel_clock = 74176000,\n\t\t.conf = {\n\t\t\t0x01, 0xd1, 0x3e, 0x35, 0x40, 0x5b, 0xde, 0x08,\n\t\t\t0x82, 0xa0, 0x73, 0xd9, 0x45, 0xa0, 0xac, 0x80,\n\t\t\t0x56, 0x80, 0x11, 0x04, 0x02, 0x22, 0x44, 0x86,\n\t\t\t0x54, 0xa6, 0x24, 0x01, 0x00, 0x00, 0x01, 0x80,\n\t\t},\n\t},\n\t{\n\t\t.pixel_clock = 74250000,\n\t\t.conf = {\n\t\t\t0x01, 0xd1, 0x1f, 0x10, 0x40, 0x40, 0xf8, 0x08,\n\t\t\t0x81, 0xa0, 0xba, 0xd8, 0x45, 0xa0, 0xac, 0x80,\n\t\t\t0x3c, 0x80, 0x11, 0x04, 0x02, 0x22, 0x44, 0x86,\n\t\t\t0x54, 0xa5, 0x24, 0x01, 0x00, 0x00, 0x01, 0x80,\n\t\t},\n\t},\n\t{\n\t\t.pixel_clock = 83500000,\n\t\t.conf = {\n\t\t\t0x01, 0xd1, 0x23, 0x11, 0x40, 0x0c, 0xfb, 0x08,\n\t\t\t0x85, 0xa0, 0xd1, 0xd8, 0x45, 0xa0, 0xac, 0x80,\n\t\t\t0x08, 0x80, 0x11, 0x04, 0x02, 0x22, 0x44, 0x86,\n\t\t\t0x54, 0x93, 0x24, 0x01, 0x00, 0x00, 0x01, 0x80,\n\t\t},\n\t},\n\t{\n\t\t.pixel_clock = 85500000,\n\t\t.conf = {\n\t\t\t0x01, 0xd1, 0x24, 0x11, 0x40, 0x40, 0xd0, 0x08,\n\t\t\t0x84, 0xa0, 0xd6, 0xd8, 0x45, 0xa0, 0xac, 0x80,\n\t\t\t0x08, 0x80, 0x11, 0x04, 0x02, 0x22, 0x44, 0x86,\n\t\t\t0x54, 0x90, 0x24, 0x01, 0x00, 0x00, 0x01, 0x80,\n\t\t},\n\t},\n\t{\n\t\t.pixel_clock = 106500000,\n\t\t.conf = {\n\t\t\t0x01, 0xd1, 0x2c, 0x12, 0x40, 0x0c, 0x09, 0x08,\n\t\t\t0x84, 0xa0, 0x0a, 0xd9, 0x45, 0xa0, 0xac, 0x80,\n\t\t\t0x08, 0x80, 0x11, 0x04, 0x02, 0x22, 0x44, 0x86,\n\t\t\t0x54, 0x73, 0x24, 0x01, 0x00, 0x00, 0x01, 0x80,\n\t\t},\n\t},\n\t{\n\t\t.pixel_clock = 108000000,\n\t\t.conf = {\n\t\t\t0x01, 0x51, 0x2d, 0x15, 0x40, 0x01, 0x00, 0x08,\n\t\t\t0x82, 0x80, 0x0e, 0xd9, 0x45, 0xa0, 0xac, 0x80,\n\t\t\t0x08, 0x80, 0x11, 0x04, 0x02, 0x22, 0x44, 0x86,\n\t\t\t0x54, 0xc7, 0x25, 0x03, 0x00, 0x00, 0x01, 0x80,\n\t\t},\n\t},\n\t{\n\t\t.pixel_clock = 115500000,\n\t\t.conf = {\n\t\t\t0x01, 0xd1, 0x30, 0x12, 0x40, 0x40, 0x10, 0x08,\n\t\t\t0x80, 0x80, 0x21, 0xd9, 0x45, 0xa0, 0xac, 0x80,\n\t\t\t0x08, 0x80, 0x11, 0x04, 0x02, 0x22, 0x44, 0x86,\n\t\t\t0x54, 0xaa, 0x25, 0x03, 0x00, 0x00, 0x01, 0x80,\n\t\t},\n\t},\n\t{\n\t\t.pixel_clock = 119000000,\n\t\t.conf = {\n\t\t\t0x01, 0xd1, 0x32, 0x1a, 0x40, 0x30, 0xd8, 0x08,\n\t\t\t0x04, 0xa0, 0x2a, 0xd9, 0x45, 0xa0, 0xac, 0x80,\n\t\t\t0x08, 0x80, 0x11, 0x04, 0x02, 0x22, 0x44, 0x86,\n\t\t\t0x54, 0x9d, 0x25, 0x03, 0x00, 0x00, 0x01, 0x80,\n\t\t},\n\t},\n\t{\n\t\t.pixel_clock = 146250000,\n\t\t.conf = {\n\t\t\t0x01, 0xd1, 0x3d, 0x15, 0x40, 0x18, 0xfd, 0x08,\n\t\t\t0x83, 0xa0, 0x6e, 0xd9, 0x45, 0xa0, 0xac, 0x80,\n\t\t\t0x08, 0x80, 0x11, 0x04, 0x02, 0x22, 0x44, 0x86,\n\t\t\t0x54, 0x50, 0x25, 0x03, 0x00, 0x00, 0x01, 0x80,\n\t\t},\n\t},\n\t{\n\t\t.pixel_clock = 148500000,\n\t\t.conf = {\n\t\t\t0x01, 0xd1, 0x1f, 0x00, 0x40, 0x40, 0xf8, 0x08,\n\t\t\t0x81, 0xa0, 0xba, 0xd8, 0x45, 0xa0, 0xac, 0x80,\n\t\t\t0x3c, 0x80, 0x11, 0x04, 0x02, 0x22, 0x44, 0x86,\n\t\t\t0x54, 0x4b, 0x25, 0x03, 0x00, 0x00, 0x01, 0x80,\n\t\t},\n\t},\n};\n\nstatic const struct hdmiphy_config hdmiphy_5420_configs[] = {\n\t{\n\t\t.pixel_clock = 25200000,\n\t\t.conf = {\n\t\t\t0x01, 0x52, 0x3F, 0x55, 0x40, 0x01, 0x00, 0xC8,\n\t\t\t0x82, 0xC8, 0xBD, 0xD8, 0x45, 0xA0, 0xAC, 0x80,\n\t\t\t0x06, 0x80, 0x01, 0x84, 0x05, 0x02, 0x24, 0x66,\n\t\t\t0x54, 0xF4, 0x24, 0x00, 0x00, 0x00, 0x01, 0x80,\n\t\t},\n\t},\n\t{\n\t\t.pixel_clock = 27000000,\n\t\t.conf = {\n\t\t\t0x01, 0xD1, 0x22, 0x51, 0x40, 0x08, 0xFC, 0xE0,\n\t\t\t0x98, 0xE8, 0xCB, 0xD8, 0x45, 0xA0, 0xAC, 0x80,\n\t\t\t0x06, 0x80, 0x09, 0x84, 0x05, 0x02, 0x24, 0x66,\n\t\t\t0x54, 0xE4, 0x24, 0x00, 0x00, 0x00, 0x01, 0x80,\n\t\t},\n\t},\n\t{\n\t\t.pixel_clock = 27027000,\n\t\t.conf = {\n\t\t\t0x01, 0xD1, 0x2D, 0x72, 0x40, 0x64, 0x12, 0xC8,\n\t\t\t0x43, 0xE8, 0x0E, 0xD9, 0x45, 0xA0, 0xAC, 0x80,\n\t\t\t0x26, 0x80, 0x09, 0x84, 0x05, 0x02, 0x24, 0x66,\n\t\t\t0x54, 0xE3, 0x24, 0x00, 0x00, 0x00, 0x01, 0x80,\n\t\t},\n\t},\n\t{\n\t\t.pixel_clock = 36000000,\n\t\t.conf = {\n\t\t\t0x01, 0x51, 0x2D, 0x55, 0x40, 0x40, 0x00, 0xC8,\n\t\t\t0x02, 0xC8, 0x0E, 0xD9, 0x45, 0xA0, 0xAC, 0x80,\n\t\t\t0x08, 0x80, 0x09, 0x84, 0x05, 0x02, 0x24, 0x66,\n\t\t\t0x54, 0xAB, 0x24, 0x00, 0x00, 0x00, 0x01, 0x80,\n\t\t},\n\t},\n\t{\n\t\t.pixel_clock = 40000000,\n\t\t.conf = {\n\t\t\t0x01, 0xD1, 0x21, 0x31, 0x40, 0x3C, 0x28, 0xC8,\n\t\t\t0x87, 0xE8, 0xC8, 0xD8, 0x45, 0xA0, 0xAC, 0x80,\n\t\t\t0x08, 0x80, 0x09, 0x84, 0x05, 0x02, 0x24, 0x66,\n\t\t\t0x54, 0x9A, 0x24, 0x00, 0x00, 0x00, 0x01, 0x80,\n\t\t},\n\t},\n\t{\n\t\t.pixel_clock = 65000000,\n\t\t.conf = {\n\t\t\t0x01, 0xD1, 0x36, 0x34, 0x40, 0x0C, 0x04, 0xC8,\n\t\t\t0x82, 0xE8, 0x45, 0xD9, 0x45, 0xA0, 0xAC, 0x80,\n\t\t\t0x08, 0x80, 0x09, 0x84, 0x05, 0x02, 0x24, 0x66,\n\t\t\t0x54, 0xBD, 0x24, 0x01, 0x00, 0x00, 0x01, 0x80,\n\t\t},\n\t},\n\t{\n\t\t.pixel_clock = 71000000,\n\t\t.conf = {\n\t\t\t0x01, 0xD1, 0x3B, 0x35, 0x40, 0x0C, 0x04, 0xC8,\n\t\t\t0x85, 0xE8, 0x63, 0xD9, 0x45, 0xA0, 0xAC, 0x80,\n\t\t\t0x08, 0x80, 0x09, 0x84, 0x05, 0x02, 0x24, 0x66,\n\t\t\t0x54, 0x57, 0x24, 0x00, 0x00, 0x00, 0x01, 0x80,\n\t\t},\n\t},\n\t{\n\t\t.pixel_clock = 73250000,\n\t\t.conf = {\n\t\t\t0x01, 0xD1, 0x1F, 0x10, 0x40, 0x78, 0x8D, 0xC8,\n\t\t\t0x81, 0xE8, 0xB7, 0xD8, 0x45, 0xA0, 0xAC, 0x80,\n\t\t\t0x56, 0x80, 0x09, 0x84, 0x05, 0x02, 0x24, 0x66,\n\t\t\t0x54, 0xA8, 0x24, 0x01, 0x00, 0x00, 0x01, 0x80,\n\t\t},\n\t},\n\t{\n\t\t.pixel_clock = 74176000,\n\t\t.conf = {\n\t\t\t0x01, 0xD1, 0x1F, 0x10, 0x40, 0x5B, 0xEF, 0xC8,\n\t\t\t0x81, 0xE8, 0xB9, 0xD8, 0x45, 0xA0, 0xAC, 0x80,\n\t\t\t0x56, 0x80, 0x09, 0x84, 0x05, 0x02, 0x24, 0x66,\n\t\t\t0x54, 0xA6, 0x24, 0x01, 0x00, 0x00, 0x01, 0x80,\n\t\t},\n\t},\n\t{\n\t\t.pixel_clock = 74250000,\n\t\t.conf = {\n\t\t\t0x01, 0xD1, 0x1F, 0x10, 0x40, 0x40, 0xF8, 0x08,\n\t\t\t0x81, 0xE8, 0xBA, 0xD8, 0x45, 0xA0, 0xAC, 0x80,\n\t\t\t0x26, 0x80, 0x09, 0x84, 0x05, 0x22, 0x24, 0x66,\n\t\t\t0x54, 0xA5, 0x24, 0x01, 0x00, 0x00, 0x01, 0x80,\n\t\t},\n\t},\n\t{\n\t\t.pixel_clock = 83500000,\n\t\t.conf = {\n\t\t\t0x01, 0xD1, 0x23, 0x11, 0x40, 0x0C, 0xFB, 0xC8,\n\t\t\t0x85, 0xE8, 0xD1, 0xD8, 0x45, 0xA0, 0xAC, 0x80,\n\t\t\t0x08, 0x80, 0x09, 0x84, 0x05, 0x02, 0x24, 0x66,\n\t\t\t0x54, 0x4A, 0x24, 0x00, 0x00, 0x00, 0x01, 0x80,\n\t\t},\n\t},\n\t{\n\t\t.pixel_clock = 88750000,\n\t\t.conf = {\n\t\t\t0x01, 0xD1, 0x25, 0x11, 0x40, 0x18, 0xFF, 0xC8,\n\t\t\t0x83, 0xE8, 0xDE, 0xD8, 0x45, 0xA0, 0xAC, 0x80,\n\t\t\t0x08, 0x80, 0x09, 0x84, 0x05, 0x02, 0x24, 0x66,\n\t\t\t0x54, 0x45, 0x24, 0x00, 0x00, 0x00, 0x01, 0x80,\n\t\t},\n\t},\n\t{\n\t\t.pixel_clock = 106500000,\n\t\t.conf = {\n\t\t\t0x01, 0xD1, 0x2C, 0x12, 0x40, 0x0C, 0x09, 0xC8,\n\t\t\t0x84, 0xE8, 0x0A, 0xD9, 0x45, 0xA0, 0xAC, 0x80,\n\t\t\t0x08, 0x80, 0x09, 0x84, 0x05, 0x02, 0x24, 0x66,\n\t\t\t0x54, 0x73, 0x24, 0x01, 0x00, 0x00, 0x01, 0x80,\n\t\t},\n\t},\n\t{\n\t\t.pixel_clock = 108000000,\n\t\t.conf = {\n\t\t\t0x01, 0x51, 0x2D, 0x15, 0x40, 0x01, 0x00, 0xC8,\n\t\t\t0x82, 0xC8, 0x0E, 0xD9, 0x45, 0xA0, 0xAC, 0x80,\n\t\t\t0x08, 0x80, 0x09, 0x84, 0x05, 0x02, 0x24, 0x66,\n\t\t\t0x54, 0xC7, 0x25, 0x03, 0x00, 0x00, 0x01, 0x80,\n\t\t},\n\t},\n\t{\n\t\t.pixel_clock = 115500000,\n\t\t.conf = {\n\t\t\t0x01, 0xD1, 0x30, 0x14, 0x40, 0x0C, 0x03, 0xC8,\n\t\t\t0x88, 0xE8, 0x21, 0xD9, 0x45, 0xA0, 0xAC, 0x80,\n\t\t\t0x08, 0x80, 0x09, 0x84, 0x05, 0x02, 0x24, 0x66,\n\t\t\t0x54, 0x6A, 0x24, 0x01, 0x00, 0x00, 0x01, 0x80,\n\t\t},\n\t},\n\t{\n\t\t.pixel_clock = 146250000,\n\t\t.conf = {\n\t\t\t0x01, 0xD1, 0x3D, 0x15, 0x40, 0x18, 0xFD, 0xC8,\n\t\t\t0x83, 0xE8, 0x6E, 0xD9, 0x45, 0xA0, 0xAC, 0x80,\n\t\t\t0x08, 0x80, 0x09, 0x84, 0x05, 0x02, 0x24, 0x66,\n\t\t\t0x54, 0x54, 0x24, 0x01, 0x00, 0x00, 0x01, 0x80,\n\t\t},\n\t},\n\t{\n\t\t.pixel_clock = 148500000,\n\t\t.conf = {\n\t\t\t0x01, 0xD1, 0x1F, 0x00, 0x40, 0x40, 0xF8, 0x08,\n\t\t\t0x81, 0xE8, 0xBA, 0xD8, 0x45, 0xA0, 0xAC, 0x80,\n\t\t\t0x26, 0x80, 0x09, 0x84, 0x05, 0x22, 0x24, 0x66,\n\t\t\t0x54, 0x4B, 0x25, 0x03, 0x00, 0x80, 0x01, 0x80,\n\t\t},\n\t},\n\t{\n\t\t.pixel_clock = 154000000,\n\t\t.conf = {\n\t\t\t0x01, 0xD1, 0x20, 0x01, 0x40, 0x30, 0x08, 0xCC,\n\t\t\t0x8C, 0xE8, 0xC1, 0xD8, 0x45, 0xA0, 0xAC, 0x80,\n\t\t\t0x08, 0x80, 0x09, 0x84, 0x05, 0x02, 0x24, 0x86,\n\t\t\t0x54, 0x3F, 0x25, 0x03, 0x00, 0x00, 0x01, 0x80,\n\t\t},\n\t},\n};\n\nstatic const struct hdmiphy_config hdmiphy_5433_configs[] = {\n\t{\n\t\t.pixel_clock = 27000000,\n\t\t.conf = {\n\t\t\t0x01, 0x51, 0x2d, 0x75, 0x01, 0x00, 0x88, 0x02,\n\t\t\t0x72, 0x50, 0x44, 0x8c, 0x27, 0x00, 0x7c, 0xac,\n\t\t\t0xd6, 0x2b, 0x67, 0x00, 0x00, 0x04, 0x00, 0x30,\n\t\t\t0x08, 0x10, 0x01, 0x01, 0x48, 0x40, 0x00, 0x40,\n\t\t},\n\t},\n\t{\n\t\t.pixel_clock = 27027000,\n\t\t.conf = {\n\t\t\t0x01, 0x51, 0x2d, 0x72, 0x64, 0x09, 0x88, 0xc3,\n\t\t\t0x71, 0x50, 0x44, 0x8c, 0x27, 0x00, 0x7c, 0xac,\n\t\t\t0xd6, 0x2b, 0x67, 0x00, 0x00, 0x04, 0x00, 0x30,\n\t\t\t0x08, 0x10, 0x01, 0x01, 0x48, 0x40, 0x00, 0x40,\n\t\t},\n\t},\n\t{\n\t\t.pixel_clock = 40000000,\n\t\t.conf = {\n\t\t\t0x01, 0x51, 0x32, 0x55, 0x01, 0x00, 0x88, 0x02,\n\t\t\t0x4d, 0x50, 0x44, 0x8C, 0x27, 0x00, 0x7C, 0xAC,\n\t\t\t0xD6, 0x2B, 0x67, 0x00, 0x00, 0x04, 0x00, 0x30,\n\t\t\t0x08, 0x10, 0x01, 0x01, 0x48, 0x40, 0x00, 0x40,\n\t\t},\n\t},\n\t{\n\t\t.pixel_clock = 50000000,\n\t\t.conf = {\n\t\t\t0x01, 0x51, 0x34, 0x40, 0x64, 0x09, 0x88, 0xc3,\n\t\t\t0x3d, 0x50, 0x44, 0x8C, 0x27, 0x00, 0x7C, 0xAC,\n\t\t\t0xD6, 0x2B, 0x67, 0x00, 0x00, 0x04, 0x00, 0x30,\n\t\t\t0x08, 0x10, 0x01, 0x01, 0x48, 0x40, 0x00, 0x40,\n\t\t},\n\t},\n\t{\n\t\t.pixel_clock = 65000000,\n\t\t.conf = {\n\t\t\t0x01, 0x51, 0x36, 0x31, 0x40, 0x10, 0x04, 0xc6,\n\t\t\t0x2e, 0xe8, 0x44, 0x8C, 0x27, 0x00, 0x7C, 0xAC,\n\t\t\t0xD6, 0x2B, 0x67, 0x00, 0x00, 0x04, 0x00, 0x30,\n\t\t\t0x08, 0x10, 0x01, 0x01, 0x48, 0x40, 0x00, 0x40,\n\t\t},\n\t},\n\t{\n\t\t.pixel_clock = 74176000,\n\t\t.conf = {\n\t\t\t0x01, 0x51, 0x3E, 0x35, 0x5B, 0xDE, 0x88, 0x42,\n\t\t\t0x53, 0x51, 0x44, 0x8C, 0x27, 0x00, 0x7C, 0xAC,\n\t\t\t0xD6, 0x2B, 0x67, 0x00, 0x00, 0x04, 0x00, 0x30,\n\t\t\t0x08, 0x10, 0x01, 0x01, 0x48, 0x40, 0x00, 0x40,\n\t\t},\n\t},\n\t{\n\t\t.pixel_clock = 74250000,\n\t\t.conf = {\n\t\t\t0x01, 0x51, 0x3E, 0x35, 0x40, 0xF0, 0x88, 0xC2,\n\t\t\t0x52, 0x51, 0x44, 0x8C, 0x27, 0x00, 0x7C, 0xAC,\n\t\t\t0xD6, 0x2B, 0x67, 0x00, 0x00, 0x04, 0x00, 0x30,\n\t\t\t0x08, 0x10, 0x01, 0x01, 0x48, 0x40, 0x00, 0x40,\n\t\t},\n\t},\n\t{\n\t\t.pixel_clock = 108000000,\n\t\t.conf = {\n\t\t\t0x01, 0x51, 0x2d, 0x15, 0x01, 0x00, 0x88, 0x02,\n\t\t\t0x72, 0x52, 0x44, 0x8C, 0x27, 0x00, 0x7C, 0xAC,\n\t\t\t0xD6, 0x2B, 0x67, 0x00, 0x00, 0x04, 0x00, 0x30,\n\t\t\t0x08, 0x10, 0x01, 0x01, 0x48, 0x40, 0x00, 0x40,\n\t\t},\n\t},\n\t{\n\t\t.pixel_clock = 148500000,\n\t\t.conf = {\n\t\t\t0x01, 0x51, 0x1f, 0x00, 0x40, 0xf8, 0x88, 0xc1,\n\t\t\t0x52, 0x52, 0x24, 0x0c, 0x24, 0x0f, 0x7c, 0xa5,\n\t\t\t0xd4, 0x2b, 0x87, 0x00, 0x00, 0x04, 0x00, 0x30,\n\t\t\t0x08, 0x10, 0x01, 0x01, 0x48, 0x4a, 0x00, 0x40,\n\t\t},\n\t},\n\t{\n\t\t.pixel_clock = 297000000,\n\t\t.conf = {\n\t\t\t0x01, 0x51, 0x3E, 0x05, 0x40, 0xF0, 0x88, 0xC2,\n\t\t\t0x52, 0x53, 0x44, 0x8C, 0x27, 0x00, 0x7C, 0xAC,\n\t\t\t0xD6, 0x2B, 0x67, 0x00, 0x00, 0x04, 0x00, 0x30,\n\t\t\t0x08, 0x10, 0x01, 0x01, 0x48, 0x40, 0x00, 0x40,\n\t\t},\n\t},\n};\n\nstatic const char * const hdmi_clk_gates4[] = {\n\t\"hdmi\", \"sclk_hdmi\"\n};\n\nstatic const char * const hdmi_clk_muxes4[] = {\n\t\"sclk_pixel\", \"sclk_hdmiphy\", \"mout_hdmi\"\n};\n\nstatic const char * const hdmi_clk_gates5433[] = {\n\t\"hdmi_pclk\", \"hdmi_i_pclk\", \"i_tmds_clk\", \"i_pixel_clk\", \"i_spdif_clk\"\n};\n\nstatic const char * const hdmi_clk_muxes5433[] = {\n\t\"oscclk\", \"tmds_clko\", \"tmds_clko_user\",\n\t\"oscclk\", \"pixel_clko\", \"pixel_clko_user\"\n};\n\nstatic const struct hdmi_driver_data exynos4210_hdmi_driver_data = {\n\t.type\t\t= HDMI_TYPE13,\n\t.phy_confs\t= INIT_ARRAY_SPEC(hdmiphy_v13_configs),\n\t.clk_gates\t= INIT_ARRAY_SPEC(hdmi_clk_gates4),\n\t.clk_muxes\t= INIT_ARRAY_SPEC(hdmi_clk_muxes4),\n};\n\nstatic const struct hdmi_driver_data exynos4212_hdmi_driver_data = {\n\t.type\t\t= HDMI_TYPE14,\n\t.phy_confs\t= INIT_ARRAY_SPEC(hdmiphy_v14_configs),\n\t.clk_gates\t= INIT_ARRAY_SPEC(hdmi_clk_gates4),\n\t.clk_muxes\t= INIT_ARRAY_SPEC(hdmi_clk_muxes4),\n};\n\nstatic const struct hdmi_driver_data exynos5420_hdmi_driver_data = {\n\t.type\t\t= HDMI_TYPE14,\n\t.is_apb_phy\t= 1,\n\t.phy_confs\t= INIT_ARRAY_SPEC(hdmiphy_5420_configs),\n\t.clk_gates\t= INIT_ARRAY_SPEC(hdmi_clk_gates4),\n\t.clk_muxes\t= INIT_ARRAY_SPEC(hdmi_clk_muxes4),\n};\n\nstatic const struct hdmi_driver_data exynos5433_hdmi_driver_data = {\n\t.type\t\t= HDMI_TYPE14,\n\t.is_apb_phy\t= 1,\n\t.has_sysreg     = 1,\n\t.phy_confs\t= INIT_ARRAY_SPEC(hdmiphy_5433_configs),\n\t.clk_gates\t= INIT_ARRAY_SPEC(hdmi_clk_gates5433),\n\t.clk_muxes\t= INIT_ARRAY_SPEC(hdmi_clk_muxes5433),\n};\n\nstatic inline u32 hdmi_map_reg(struct hdmi_context *hdata, u32 reg_id)\n{\n\tif ((reg_id & 0xffff0000) == HDMI_MAPPED_BASE)\n\t\treturn hdmi_reg_map[reg_id & 0xffff][hdata->drv_data->type];\n\treturn reg_id;\n}\n\nstatic inline u32 hdmi_reg_read(struct hdmi_context *hdata, u32 reg_id)\n{\n\treturn readl(hdata->regs + hdmi_map_reg(hdata, reg_id));\n}\n\nstatic inline void hdmi_reg_writeb(struct hdmi_context *hdata,\n\t\t\t\t u32 reg_id, u8 value)\n{\n\twritel(value, hdata->regs + hdmi_map_reg(hdata, reg_id));\n}\n\nstatic inline void hdmi_reg_writev(struct hdmi_context *hdata, u32 reg_id,\n\t\t\t\t   int bytes, u32 val)\n{\n\treg_id = hdmi_map_reg(hdata, reg_id);\n\n\twhile (--bytes >= 0) {\n\t\twritel(val & 0xff, hdata->regs + reg_id);\n\t\tval >>= 8;\n\t\treg_id += 4;\n\t}\n}\n\nstatic inline void hdmi_reg_write_buf(struct hdmi_context *hdata, u32 reg_id,\n\t\t\t\t      u8 *buf, int size)\n{\n\tfor (reg_id = hdmi_map_reg(hdata, reg_id); size; --size, reg_id += 4)\n\t\twritel(*buf++, hdata->regs + reg_id);\n}\n\nstatic inline void hdmi_reg_writemask(struct hdmi_context *hdata,\n\t\t\t\t u32 reg_id, u32 value, u32 mask)\n{\n\tu32 old;\n\n\treg_id = hdmi_map_reg(hdata, reg_id);\n\told = readl(hdata->regs + reg_id);\n\tvalue = (value & mask) | (old & ~mask);\n\twritel(value, hdata->regs + reg_id);\n}\n\nstatic int hdmiphy_reg_write_buf(struct hdmi_context *hdata,\n\t\t\tu32 reg_offset, const u8 *buf, u32 len)\n{\n\tif ((reg_offset + len) > 32)\n\t\treturn -EINVAL;\n\n\tif (hdata->hdmiphy_port) {\n\t\tint ret;\n\n\t\tret = i2c_master_send(hdata->hdmiphy_port, buf, len);\n\t\tif (ret == len)\n\t\t\treturn 0;\n\t\treturn ret;\n\t} else {\n\t\tint i;\n\t\tfor (i = 0; i < len; i++)\n\t\t\twritel(buf[i], hdata->regs_hdmiphy +\n\t\t\t\t((reg_offset + i)<<2));\n\t\treturn 0;\n\t}\n}\n\nstatic int hdmi_clk_enable_gates(struct hdmi_context *hdata)\n{\n\tint i, ret;\n\n\tfor (i = 0; i < hdata->drv_data->clk_gates.count; ++i) {\n\t\tret = clk_prepare_enable(hdata->clk_gates[i]);\n\t\tif (!ret)\n\t\t\tcontinue;\n\n\t\tdev_err(hdata->dev, \"Cannot enable clock '%s', %d\\n\",\n\t\t\thdata->drv_data->clk_gates.data[i], ret);\n\t\twhile (i--)\n\t\t\tclk_disable_unprepare(hdata->clk_gates[i]);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic void hdmi_clk_disable_gates(struct hdmi_context *hdata)\n{\n\tint i = hdata->drv_data->clk_gates.count;\n\n\twhile (i--)\n\t\tclk_disable_unprepare(hdata->clk_gates[i]);\n}\n\nstatic int hdmi_clk_set_parents(struct hdmi_context *hdata, bool to_phy)\n{\n\tstruct device *dev = hdata->dev;\n\tint ret = 0;\n\tint i;\n\n\tfor (i = 0; i < hdata->drv_data->clk_muxes.count; i += 3) {\n\t\tstruct clk **c = &hdata->clk_muxes[i];\n\n\t\tret = clk_set_parent(c[2], c[to_phy]);\n\t\tif (!ret)\n\t\t\tcontinue;\n\n\t\tdev_err(dev, \"Cannot set clock parent of '%s' to '%s', %d\\n\",\n\t\t\thdata->drv_data->clk_muxes.data[i + 2],\n\t\t\thdata->drv_data->clk_muxes.data[i + to_phy], ret);\n\t}\n\n\treturn ret;\n}\n\nstatic int hdmi_audio_infoframe_apply(struct hdmi_context *hdata)\n{\n\tstruct hdmi_audio_infoframe *infoframe = &hdata->audio.infoframe;\n\tu8 buf[HDMI_INFOFRAME_SIZE(AUDIO)];\n\tint len;\n\n\tlen = hdmi_audio_infoframe_pack(infoframe, buf, sizeof(buf));\n\tif (len < 0)\n\t\treturn len;\n\n\thdmi_reg_writeb(hdata, HDMI_AUI_CON, HDMI_AUI_CON_EVERY_VSYNC);\n\thdmi_reg_write_buf(hdata, HDMI_AUI_HEADER0, buf, len);\n\n\treturn 0;\n}\n\nstatic void hdmi_reg_infoframes(struct hdmi_context *hdata)\n{\n\tstruct drm_display_mode *m = &hdata->encoder.crtc->state->mode;\n\tunion hdmi_infoframe frm;\n\tu8 buf[25];\n\tint ret;\n\n\tif (hdata->dvi_mode) {\n\t\thdmi_reg_writeb(hdata, HDMI_AVI_CON,\n\t\t\t\tHDMI_AVI_CON_DO_NOT_TRANSMIT);\n\t\thdmi_reg_writeb(hdata, HDMI_VSI_CON,\n\t\t\t\tHDMI_VSI_CON_DO_NOT_TRANSMIT);\n\t\thdmi_reg_writeb(hdata, HDMI_AUI_CON, HDMI_AUI_CON_NO_TRAN);\n\t\treturn;\n\t}\n\n\tret = drm_hdmi_avi_infoframe_from_display_mode(&frm.avi,\n\t\t\t\t\t\t       &hdata->connector, m);\n\tif (!ret)\n\t\tret = hdmi_avi_infoframe_pack(&frm.avi, buf, sizeof(buf));\n\tif (ret > 0) {\n\t\thdmi_reg_writeb(hdata, HDMI_AVI_CON, HDMI_AVI_CON_EVERY_VSYNC);\n\t\thdmi_reg_write_buf(hdata, HDMI_AVI_HEADER0, buf, ret);\n\t} else {\n\t\tDRM_INFO(\"%s: invalid AVI infoframe (%d)\\n\", __func__, ret);\n\t}\n\n\tret = drm_hdmi_vendor_infoframe_from_display_mode(&frm.vendor.hdmi,\n\t\t\t\t\t\t\t  &hdata->connector, m);\n\tif (!ret)\n\t\tret = hdmi_vendor_infoframe_pack(&frm.vendor.hdmi, buf,\n\t\t\t\tsizeof(buf));\n\tif (ret > 0) {\n\t\thdmi_reg_writeb(hdata, HDMI_VSI_CON, HDMI_VSI_CON_EVERY_VSYNC);\n\t\thdmi_reg_write_buf(hdata, HDMI_VSI_HEADER0, buf, 3);\n\t\thdmi_reg_write_buf(hdata, HDMI_VSI_DATA(0), buf + 3, ret - 3);\n\t}\n\n\thdmi_audio_infoframe_apply(hdata);\n}\n\nstatic enum drm_connector_status hdmi_detect(struct drm_connector *connector,\n\t\t\t\tbool force)\n{\n\tstruct hdmi_context *hdata = connector_to_hdmi(connector);\n\n\tif (gpiod_get_value(hdata->hpd_gpio))\n\t\treturn connector_status_connected;\n\n\tcec_notifier_set_phys_addr(hdata->notifier, CEC_PHYS_ADDR_INVALID);\n\treturn connector_status_disconnected;\n}\n\nstatic void hdmi_connector_destroy(struct drm_connector *connector)\n{\n\tstruct hdmi_context *hdata = connector_to_hdmi(connector);\n\n\tcec_notifier_conn_unregister(hdata->notifier);\n\n\tdrm_connector_unregister(connector);\n\tdrm_connector_cleanup(connector);\n}\n\nstatic const struct drm_connector_funcs hdmi_connector_funcs = {\n\t.fill_modes = drm_helper_probe_single_connector_modes,\n\t.detect = hdmi_detect,\n\t.destroy = hdmi_connector_destroy,\n\t.reset = drm_atomic_helper_connector_reset,\n\t.atomic_duplicate_state = drm_atomic_helper_connector_duplicate_state,\n\t.atomic_destroy_state = drm_atomic_helper_connector_destroy_state,\n};\n\nstatic int hdmi_get_modes(struct drm_connector *connector)\n{\n\tstruct hdmi_context *hdata = connector_to_hdmi(connector);\n\tstruct edid *edid;\n\tint ret;\n\n\tif (!hdata->ddc_adpt)\n\t\treturn -ENODEV;\n\n\tedid = drm_get_edid(connector, hdata->ddc_adpt);\n\tif (!edid)\n\t\treturn -ENODEV;\n\n\thdata->dvi_mode = !connector->display_info.is_hdmi;\n\tDRM_DEV_DEBUG_KMS(hdata->dev, \"%s : width[%d] x height[%d]\\n\",\n\t\t\t  (hdata->dvi_mode ? \"dvi monitor\" : \"hdmi monitor\"),\n\t\t\t  edid->width_cm, edid->height_cm);\n\n\tdrm_connector_update_edid_property(connector, edid);\n\tcec_notifier_set_phys_addr_from_edid(hdata->notifier, edid);\n\n\tret = drm_add_edid_modes(connector, edid);\n\n\tkfree(edid);\n\n\treturn ret;\n}\n\nstatic int hdmi_find_phy_conf(struct hdmi_context *hdata, u32 pixel_clock)\n{\n\tconst struct hdmiphy_configs *confs = &hdata->drv_data->phy_confs;\n\tint i;\n\n\tfor (i = 0; i < confs->count; i++)\n\t\tif (confs->data[i].pixel_clock == pixel_clock)\n\t\t\treturn i;\n\n\tDRM_DEV_DEBUG_KMS(hdata->dev, \"Could not find phy config for %d\\n\",\n\t\t\t  pixel_clock);\n\treturn -EINVAL;\n}\n\nstatic enum drm_mode_status hdmi_mode_valid(struct drm_connector *connector,\n\t\t\t\t\t    struct drm_display_mode *mode)\n{\n\tstruct hdmi_context *hdata = connector_to_hdmi(connector);\n\tint ret;\n\n\tDRM_DEV_DEBUG_KMS(hdata->dev,\n\t\t\t  \"xres=%d, yres=%d, refresh=%d, intl=%d clock=%d\\n\",\n\t\t\t  mode->hdisplay, mode->vdisplay,\n\t\t\t  drm_mode_vrefresh(mode),\n\t\t\t  (mode->flags & DRM_MODE_FLAG_INTERLACE) ? true :\n\t\t\t  false, mode->clock * 1000);\n\n\tret = hdmi_find_phy_conf(hdata, mode->clock * 1000);\n\tif (ret < 0)\n\t\treturn MODE_BAD;\n\n\treturn MODE_OK;\n}\n\nstatic const struct drm_connector_helper_funcs hdmi_connector_helper_funcs = {\n\t.get_modes = hdmi_get_modes,\n\t.mode_valid = hdmi_mode_valid,\n};\n\nstatic int hdmi_create_connector(struct drm_encoder *encoder)\n{\n\tstruct hdmi_context *hdata = encoder_to_hdmi(encoder);\n\tstruct drm_connector *connector = &hdata->connector;\n\tstruct cec_connector_info conn_info;\n\tint ret;\n\n\tconnector->interlace_allowed = true;\n\tconnector->polled = DRM_CONNECTOR_POLL_HPD;\n\n\tret = drm_connector_init_with_ddc(hdata->drm_dev, connector,\n\t\t\t\t\t  &hdmi_connector_funcs,\n\t\t\t\t\t  DRM_MODE_CONNECTOR_HDMIA,\n\t\t\t\t\t  hdata->ddc_adpt);\n\tif (ret) {\n\t\tDRM_DEV_ERROR(hdata->dev,\n\t\t\t      \"Failed to initialize connector with drm\\n\");\n\t\treturn ret;\n\t}\n\n\tdrm_connector_helper_add(connector, &hdmi_connector_helper_funcs);\n\tdrm_connector_attach_encoder(connector, encoder);\n\n\tif (hdata->bridge)\n\t\tret = drm_bridge_attach(encoder, hdata->bridge, NULL, 0);\n\n\tcec_fill_conn_info_from_drm(&conn_info, connector);\n\n\thdata->notifier = cec_notifier_conn_register(hdata->dev, NULL,\n\t\t\t\t\t\t     &conn_info);\n\tif (!hdata->notifier) {\n\t\tret = -ENOMEM;\n\t\tDRM_DEV_ERROR(hdata->dev, \"Failed to allocate CEC notifier\\n\");\n\t}\n\n\treturn ret;\n}\n\nstatic bool hdmi_mode_fixup(struct drm_encoder *encoder,\n\t\t\t    const struct drm_display_mode *mode,\n\t\t\t    struct drm_display_mode *adjusted_mode)\n{\n\tstruct drm_device *dev = encoder->dev;\n\tstruct drm_connector *connector;\n\tstruct drm_display_mode *m;\n\tstruct drm_connector_list_iter conn_iter;\n\tint mode_ok;\n\n\tdrm_mode_set_crtcinfo(adjusted_mode, 0);\n\n\tdrm_connector_list_iter_begin(dev, &conn_iter);\n\tdrm_for_each_connector_iter(connector, &conn_iter) {\n\t\tif (connector->encoder == encoder)\n\t\t\tbreak;\n\t}\n\tif (connector)\n\t\tdrm_connector_get(connector);\n\tdrm_connector_list_iter_end(&conn_iter);\n\n\tif (!connector)\n\t\treturn true;\n\n\tmode_ok = hdmi_mode_valid(connector, adjusted_mode);\n\n\tif (mode_ok == MODE_OK)\n\t\tgoto cleanup;\n\n\t \n\tlist_for_each_entry(m, &connector->modes, head) {\n\t\tmode_ok = hdmi_mode_valid(connector, m);\n\n\t\tif (mode_ok == MODE_OK) {\n\t\t\tDRM_INFO(\"desired mode doesn't exist so\\n\");\n\t\t\tDRM_INFO(\"use the most suitable mode among modes.\\n\");\n\n\t\t\tDRM_DEV_DEBUG_KMS(dev->dev,\n\t\t\t\t\t  \"Adjusted Mode: [%d]x[%d] [%d]Hz\\n\",\n\t\t\t\t\t  m->hdisplay, m->vdisplay,\n\t\t\t\t\t  drm_mode_vrefresh(m));\n\n\t\t\tdrm_mode_copy(adjusted_mode, m);\n\t\t\tbreak;\n\t\t}\n\t}\n\ncleanup:\n\tdrm_connector_put(connector);\n\n\treturn true;\n}\n\nstatic void hdmi_reg_acr(struct hdmi_context *hdata, u32 freq)\n{\n\tu32 n, cts;\n\n\tcts = (freq % 9) ? 27000 : 30000;\n\tn = 128 * freq / (27000000 / cts);\n\n\thdmi_reg_writev(hdata, HDMI_ACR_N0, 3, n);\n\thdmi_reg_writev(hdata, HDMI_ACR_MCTS0, 3, cts);\n\thdmi_reg_writev(hdata, HDMI_ACR_CTS0, 3, cts);\n\thdmi_reg_writeb(hdata, HDMI_ACR_CON, 4);\n}\n\nstatic void hdmi_audio_config(struct hdmi_context *hdata)\n{\n\tu32 bit_ch = 1;\n\tu32 data_num, val;\n\tint i;\n\n\tswitch (hdata->audio.params.sample_width) {\n\tcase 20:\n\t\tdata_num = 2;\n\t\tbreak;\n\tcase 24:\n\t\tdata_num = 3;\n\t\tbreak;\n\tdefault:\n\t\tdata_num = 1;\n\t\tbit_ch = 0;\n\t\tbreak;\n\t}\n\n\thdmi_reg_acr(hdata, hdata->audio.params.sample_rate);\n\n\thdmi_reg_writeb(hdata, HDMI_I2S_MUX_CON, HDMI_I2S_IN_DISABLE\n\t\t\t\t| HDMI_I2S_AUD_I2S | HDMI_I2S_CUV_I2S_ENABLE\n\t\t\t\t| HDMI_I2S_MUX_ENABLE);\n\n\thdmi_reg_writeb(hdata, HDMI_I2S_MUX_CH, HDMI_I2S_CH0_EN\n\t\t\t| HDMI_I2S_CH1_EN | HDMI_I2S_CH2_EN);\n\n\thdmi_reg_writeb(hdata, HDMI_I2S_MUX_CUV, HDMI_I2S_CUV_RL_EN);\n\thdmi_reg_writeb(hdata, HDMI_I2S_CLK_CON, HDMI_I2S_CLK_DIS);\n\thdmi_reg_writeb(hdata, HDMI_I2S_CLK_CON, HDMI_I2S_CLK_EN);\n\n\tval = hdmi_reg_read(hdata, HDMI_I2S_DSD_CON) | 0x01;\n\thdmi_reg_writeb(hdata, HDMI_I2S_DSD_CON, val);\n\n\t \n\thdmi_reg_writeb(hdata, HDMI_I2S_PIN_SEL_0, HDMI_I2S_SEL_SCLK(5)\n\t\t\t| HDMI_I2S_SEL_LRCK(6));\n\n\thdmi_reg_writeb(hdata, HDMI_I2S_PIN_SEL_1, HDMI_I2S_SEL_SDATA1(3)\n\t\t\t| HDMI_I2S_SEL_SDATA0(4));\n\n\thdmi_reg_writeb(hdata, HDMI_I2S_PIN_SEL_2, HDMI_I2S_SEL_SDATA3(1)\n\t\t\t| HDMI_I2S_SEL_SDATA2(2));\n\n\thdmi_reg_writeb(hdata, HDMI_I2S_PIN_SEL_3, HDMI_I2S_SEL_DSD(0));\n\n\t \n\thdmi_reg_writeb(hdata, HDMI_I2S_CON_1, HDMI_I2S_SCLK_FALLING_EDGE\n\t\t\t| HDMI_I2S_L_CH_LOW_POL);\n\thdmi_reg_writeb(hdata, HDMI_I2S_CON_2, HDMI_I2S_MSB_FIRST_MODE\n\t\t\t| HDMI_I2S_SET_BIT_CH(bit_ch)\n\t\t\t| HDMI_I2S_SET_SDATA_BIT(data_num)\n\t\t\t| HDMI_I2S_BASIC_FORMAT);\n\n\t \n\tfor (i = 0; i < HDMI_I2S_CH_ST_MAXNUM; i++)\n\t\thdmi_reg_writeb(hdata, HDMI_I2S_CH_ST(i),\n\t\t\t\thdata->audio.params.iec.status[i]);\n\n\thdmi_reg_writeb(hdata, HDMI_I2S_CH_ST_CON, HDMI_I2S_CH_STATUS_RELOAD);\n}\n\nstatic void hdmi_audio_control(struct hdmi_context *hdata)\n{\n\tbool enable = !hdata->audio.mute;\n\n\tif (hdata->dvi_mode)\n\t\treturn;\n\n\thdmi_reg_writeb(hdata, HDMI_AUI_CON, enable ?\n\t\t\tHDMI_AVI_CON_EVERY_VSYNC : HDMI_AUI_CON_NO_TRAN);\n\thdmi_reg_writemask(hdata, HDMI_CON_0, enable ?\n\t\t\tHDMI_ASP_EN : HDMI_ASP_DIS, HDMI_ASP_MASK);\n}\n\nstatic void hdmi_start(struct hdmi_context *hdata, bool start)\n{\n\tstruct drm_display_mode *m = &hdata->encoder.crtc->state->mode;\n\tu32 val = start ? HDMI_TG_EN : 0;\n\n\tif (m->flags & DRM_MODE_FLAG_INTERLACE)\n\t\tval |= HDMI_FIELD_EN;\n\n\thdmi_reg_writemask(hdata, HDMI_CON_0, val, HDMI_EN);\n\thdmi_reg_writemask(hdata, HDMI_TG_CMD, val, HDMI_TG_EN | HDMI_FIELD_EN);\n}\n\nstatic void hdmi_conf_init(struct hdmi_context *hdata)\n{\n\t \n\thdmi_reg_writemask(hdata, HDMI_INTC_CON, 0, HDMI_INTC_EN_GLOBAL |\n\t\tHDMI_INTC_EN_HPD_PLUG | HDMI_INTC_EN_HPD_UNPLUG);\n\n\t \n\thdmi_reg_writemask(hdata, HDMI_MODE_SEL,\n\t\tHDMI_MODE_HDMI_EN, HDMI_MODE_MASK);\n\t \n\thdmi_reg_writeb(hdata, HDMI_CON_2, 0);\n\t \n\thdmi_reg_writemask(hdata, HDMI_CON_0, 0, HDMI_BLUE_SCR_EN);\n\n\tif (hdata->dvi_mode) {\n\t\thdmi_reg_writemask(hdata, HDMI_MODE_SEL,\n\t\t\t\tHDMI_MODE_DVI_EN, HDMI_MODE_MASK);\n\t\thdmi_reg_writeb(hdata, HDMI_CON_2,\n\t\t\t\tHDMI_VID_PREAMBLE_DIS | HDMI_GUARD_BAND_DIS);\n\t}\n\n\tif (hdata->drv_data->type == HDMI_TYPE13) {\n\t\t \n\t\thdmi_reg_writeb(hdata, HDMI_V13_BLUE_SCREEN_0, 0x12);\n\t\thdmi_reg_writeb(hdata, HDMI_V13_BLUE_SCREEN_1, 0x34);\n\t\thdmi_reg_writeb(hdata, HDMI_V13_BLUE_SCREEN_2, 0x56);\n\n\t\t \n\t\thdmi_reg_writeb(hdata, HDMI_V13_AVI_CON, 0x02);\n\t\t \n\t\thdmi_reg_writeb(hdata, HDMI_V13_AVI_BYTE(0), 0 << 5);\n\t\thdmi_reg_writemask(hdata, HDMI_CON_1, 0x10 << 5, 0x11 << 5);\n\n\t\thdmi_reg_writeb(hdata, HDMI_V13_SPD_CON, 0x02);\n\t\thdmi_reg_writeb(hdata, HDMI_V13_AUI_CON, 0x02);\n\t\thdmi_reg_writeb(hdata, HDMI_V13_ACR_CON, 0x04);\n\t} else {\n\t\thdmi_reg_infoframes(hdata);\n\n\t\t \n\t\thdmi_reg_writemask(hdata, HDMI_CON_1, 2, 3 << 5);\n\t}\n}\n\nstatic void hdmiphy_wait_for_pll(struct hdmi_context *hdata)\n{\n\tint tries;\n\n\tfor (tries = 0; tries < 10; ++tries) {\n\t\tu32 val = hdmi_reg_read(hdata, HDMI_PHY_STATUS);\n\n\t\tif (val & HDMI_PHY_STATUS_READY) {\n\t\t\tDRM_DEV_DEBUG_KMS(hdata->dev,\n\t\t\t\t\t  \"PLL stabilized after %d tries\\n\",\n\t\t\t\t\t  tries);\n\t\t\treturn;\n\t\t}\n\t\tusleep_range(10, 20);\n\t}\n\n\tDRM_DEV_ERROR(hdata->dev, \"PLL could not reach steady state\\n\");\n}\n\nstatic void hdmi_v13_mode_apply(struct hdmi_context *hdata)\n{\n\tstruct drm_display_mode *m = &hdata->encoder.crtc->state->mode;\n\tunsigned int val;\n\n\thdmi_reg_writev(hdata, HDMI_H_BLANK_0, 2, m->htotal - m->hdisplay);\n\thdmi_reg_writev(hdata, HDMI_V13_H_V_LINE_0, 3,\n\t\t\t(m->htotal << 12) | m->vtotal);\n\n\tval = (m->flags & DRM_MODE_FLAG_NVSYNC) ? 1 : 0;\n\thdmi_reg_writev(hdata, HDMI_VSYNC_POL, 1, val);\n\n\tval = (m->flags & DRM_MODE_FLAG_INTERLACE) ? 1 : 0;\n\thdmi_reg_writev(hdata, HDMI_INT_PRO_MODE, 1, val);\n\n\tval = (m->hsync_start - m->hdisplay - 2);\n\tval |= ((m->hsync_end - m->hdisplay - 2) << 10);\n\tval |= ((m->flags & DRM_MODE_FLAG_NHSYNC) ? 1 : 0)<<20;\n\thdmi_reg_writev(hdata, HDMI_V13_H_SYNC_GEN_0, 3, val);\n\n\t \n\n\t \n\tif (m->flags & DRM_MODE_FLAG_INTERLACE) {\n\t\tval = ((m->vsync_end - m->vdisplay) / 2);\n\t\tval |= ((m->vsync_start - m->vdisplay) / 2) << 12;\n\t\thdmi_reg_writev(hdata, HDMI_V13_V_SYNC_GEN_1_0, 3, val);\n\n\t\tval = m->vtotal / 2;\n\t\tval |= ((m->vtotal - m->vdisplay) / 2) << 11;\n\t\thdmi_reg_writev(hdata, HDMI_V13_V_BLANK_0, 3, val);\n\n\t\tval = (m->vtotal +\n\t\t\t((m->vsync_end - m->vsync_start) * 4) + 5) / 2;\n\t\tval |= m->vtotal << 11;\n\t\thdmi_reg_writev(hdata, HDMI_V13_V_BLANK_F_0, 3, val);\n\n\t\tval = ((m->vtotal / 2) + 7);\n\t\tval |= ((m->vtotal / 2) + 2) << 12;\n\t\thdmi_reg_writev(hdata, HDMI_V13_V_SYNC_GEN_2_0, 3, val);\n\n\t\tval = ((m->htotal / 2) + (m->hsync_start - m->hdisplay));\n\t\tval |= ((m->htotal / 2) +\n\t\t\t(m->hsync_start - m->hdisplay)) << 12;\n\t\thdmi_reg_writev(hdata, HDMI_V13_V_SYNC_GEN_3_0, 3, val);\n\n\t\thdmi_reg_writev(hdata, HDMI_TG_VACT_ST_L, 2,\n\t\t\t\t(m->vtotal - m->vdisplay) / 2);\n\t\thdmi_reg_writev(hdata, HDMI_TG_VACT_SZ_L, 2, m->vdisplay / 2);\n\n\t\thdmi_reg_writev(hdata, HDMI_TG_VACT_ST2_L, 2, 0x249);\n\t} else {\n\t\tval = m->vtotal;\n\t\tval |= (m->vtotal - m->vdisplay) << 11;\n\t\thdmi_reg_writev(hdata, HDMI_V13_V_BLANK_0, 3, val);\n\n\t\thdmi_reg_writev(hdata, HDMI_V13_V_BLANK_F_0, 3, 0);\n\n\t\tval = (m->vsync_end - m->vdisplay);\n\t\tval |= ((m->vsync_start - m->vdisplay) << 12);\n\t\thdmi_reg_writev(hdata, HDMI_V13_V_SYNC_GEN_1_0, 3, val);\n\n\t\thdmi_reg_writev(hdata, HDMI_V13_V_SYNC_GEN_2_0, 3, 0x1001);\n\t\thdmi_reg_writev(hdata, HDMI_V13_V_SYNC_GEN_3_0, 3, 0x1001);\n\t\thdmi_reg_writev(hdata, HDMI_TG_VACT_ST_L, 2,\n\t\t\t\tm->vtotal - m->vdisplay);\n\t\thdmi_reg_writev(hdata, HDMI_TG_VACT_SZ_L, 2, m->vdisplay);\n\t}\n\n\thdmi_reg_writev(hdata, HDMI_TG_H_FSZ_L, 2, m->htotal);\n\thdmi_reg_writev(hdata, HDMI_TG_HACT_ST_L, 2, m->htotal - m->hdisplay);\n\thdmi_reg_writev(hdata, HDMI_TG_HACT_SZ_L, 2, m->hdisplay);\n\thdmi_reg_writev(hdata, HDMI_TG_V_FSZ_L, 2, m->vtotal);\n}\n\nstatic void hdmi_v14_mode_apply(struct hdmi_context *hdata)\n{\n\tstruct drm_display_mode *m = &hdata->encoder.crtc->state->mode;\n\tstruct drm_display_mode *am =\n\t\t\t\t&hdata->encoder.crtc->state->adjusted_mode;\n\tint hquirk = 0;\n\n\t \n\tif ((m->vdisplay != am->vdisplay) &&\n\t    (m->hdisplay == 1280 || m->hdisplay == 1024 || m->hdisplay == 1366))\n\t\thquirk = 258;\n\n\thdmi_reg_writev(hdata, HDMI_H_BLANK_0, 2, m->htotal - m->hdisplay);\n\thdmi_reg_writev(hdata, HDMI_V_LINE_0, 2, m->vtotal);\n\thdmi_reg_writev(hdata, HDMI_H_LINE_0, 2, m->htotal);\n\thdmi_reg_writev(hdata, HDMI_HSYNC_POL, 1,\n\t\t\t(m->flags & DRM_MODE_FLAG_NHSYNC) ? 1 : 0);\n\thdmi_reg_writev(hdata, HDMI_VSYNC_POL, 1,\n\t\t\t(m->flags & DRM_MODE_FLAG_NVSYNC) ? 1 : 0);\n\thdmi_reg_writev(hdata, HDMI_INT_PRO_MODE, 1,\n\t\t\t(m->flags & DRM_MODE_FLAG_INTERLACE) ? 1 : 0);\n\n\t \n\n\t \n\tif (m->flags & DRM_MODE_FLAG_INTERLACE) {\n\t\thdmi_reg_writev(hdata, HDMI_V_SYNC_LINE_BEF_2_0, 2,\n\t\t\t(m->vsync_end - m->vdisplay) / 2);\n\t\thdmi_reg_writev(hdata, HDMI_V_SYNC_LINE_BEF_1_0, 2,\n\t\t\t(m->vsync_start - m->vdisplay) / 2);\n\t\thdmi_reg_writev(hdata, HDMI_V2_BLANK_0, 2, m->vtotal / 2);\n\t\thdmi_reg_writev(hdata, HDMI_V1_BLANK_0, 2,\n\t\t\t\t(m->vtotal - m->vdisplay) / 2);\n\t\thdmi_reg_writev(hdata, HDMI_V_BLANK_F0_0, 2,\n\t\t\t\tm->vtotal - m->vdisplay / 2);\n\t\thdmi_reg_writev(hdata, HDMI_V_BLANK_F1_0, 2, m->vtotal);\n\t\thdmi_reg_writev(hdata, HDMI_V_SYNC_LINE_AFT_2_0, 2,\n\t\t\t\t(m->vtotal / 2) + 7);\n\t\thdmi_reg_writev(hdata, HDMI_V_SYNC_LINE_AFT_1_0, 2,\n\t\t\t\t(m->vtotal / 2) + 2);\n\t\thdmi_reg_writev(hdata, HDMI_V_SYNC_LINE_AFT_PXL_2_0, 2,\n\t\t\t(m->htotal / 2) + (m->hsync_start - m->hdisplay));\n\t\thdmi_reg_writev(hdata, HDMI_V_SYNC_LINE_AFT_PXL_1_0, 2,\n\t\t\t(m->htotal / 2) + (m->hsync_start - m->hdisplay));\n\t\thdmi_reg_writev(hdata, HDMI_TG_VACT_ST_L, 2,\n\t\t\t\t(m->vtotal - m->vdisplay) / 2);\n\t\thdmi_reg_writev(hdata, HDMI_TG_VACT_SZ_L, 2, m->vdisplay / 2);\n\t\thdmi_reg_writev(hdata, HDMI_TG_VACT_ST2_L, 2,\n\t\t\t\tm->vtotal - m->vdisplay / 2);\n\t\thdmi_reg_writev(hdata, HDMI_TG_VSYNC2_L, 2,\n\t\t\t\t(m->vtotal / 2) + 1);\n\t\thdmi_reg_writev(hdata, HDMI_TG_VSYNC_BOT_HDMI_L, 2,\n\t\t\t\t(m->vtotal / 2) + 1);\n\t\thdmi_reg_writev(hdata, HDMI_TG_FIELD_BOT_HDMI_L, 2,\n\t\t\t\t(m->vtotal / 2) + 1);\n\t\thdmi_reg_writev(hdata, HDMI_TG_VACT_ST3_L, 2, 0x0);\n\t\thdmi_reg_writev(hdata, HDMI_TG_VACT_ST4_L, 2, 0x0);\n\t} else {\n\t\thdmi_reg_writev(hdata, HDMI_V_SYNC_LINE_BEF_2_0, 2,\n\t\t\tm->vsync_end - m->vdisplay);\n\t\thdmi_reg_writev(hdata, HDMI_V_SYNC_LINE_BEF_1_0, 2,\n\t\t\tm->vsync_start - m->vdisplay);\n\t\thdmi_reg_writev(hdata, HDMI_V2_BLANK_0, 2, m->vtotal);\n\t\thdmi_reg_writev(hdata, HDMI_V1_BLANK_0, 2,\n\t\t\t\tm->vtotal - m->vdisplay);\n\t\thdmi_reg_writev(hdata, HDMI_V_BLANK_F0_0, 2, 0xffff);\n\t\thdmi_reg_writev(hdata, HDMI_V_BLANK_F1_0, 2, 0xffff);\n\t\thdmi_reg_writev(hdata, HDMI_V_SYNC_LINE_AFT_2_0, 2, 0xffff);\n\t\thdmi_reg_writev(hdata, HDMI_V_SYNC_LINE_AFT_1_0, 2, 0xffff);\n\t\thdmi_reg_writev(hdata, HDMI_V_SYNC_LINE_AFT_PXL_2_0, 2, 0xffff);\n\t\thdmi_reg_writev(hdata, HDMI_V_SYNC_LINE_AFT_PXL_1_0, 2, 0xffff);\n\t\thdmi_reg_writev(hdata, HDMI_TG_VACT_ST_L, 2,\n\t\t\t\tm->vtotal - m->vdisplay);\n\t\thdmi_reg_writev(hdata, HDMI_TG_VACT_SZ_L, 2, m->vdisplay);\n\t}\n\n\thdmi_reg_writev(hdata, HDMI_H_SYNC_START_0, 2,\n\t\t\tm->hsync_start - m->hdisplay - 2);\n\thdmi_reg_writev(hdata, HDMI_H_SYNC_END_0, 2,\n\t\t\tm->hsync_end - m->hdisplay - 2);\n\thdmi_reg_writev(hdata, HDMI_VACT_SPACE_1_0, 2, 0xffff);\n\thdmi_reg_writev(hdata, HDMI_VACT_SPACE_2_0, 2, 0xffff);\n\thdmi_reg_writev(hdata, HDMI_VACT_SPACE_3_0, 2, 0xffff);\n\thdmi_reg_writev(hdata, HDMI_VACT_SPACE_4_0, 2, 0xffff);\n\thdmi_reg_writev(hdata, HDMI_VACT_SPACE_5_0, 2, 0xffff);\n\thdmi_reg_writev(hdata, HDMI_VACT_SPACE_6_0, 2, 0xffff);\n\thdmi_reg_writev(hdata, HDMI_V_BLANK_F2_0, 2, 0xffff);\n\thdmi_reg_writev(hdata, HDMI_V_BLANK_F3_0, 2, 0xffff);\n\thdmi_reg_writev(hdata, HDMI_V_BLANK_F4_0, 2, 0xffff);\n\thdmi_reg_writev(hdata, HDMI_V_BLANK_F5_0, 2, 0xffff);\n\thdmi_reg_writev(hdata, HDMI_V_SYNC_LINE_AFT_3_0, 2, 0xffff);\n\thdmi_reg_writev(hdata, HDMI_V_SYNC_LINE_AFT_4_0, 2, 0xffff);\n\thdmi_reg_writev(hdata, HDMI_V_SYNC_LINE_AFT_5_0, 2, 0xffff);\n\thdmi_reg_writev(hdata, HDMI_V_SYNC_LINE_AFT_6_0, 2, 0xffff);\n\thdmi_reg_writev(hdata, HDMI_V_SYNC_LINE_AFT_PXL_3_0, 2, 0xffff);\n\thdmi_reg_writev(hdata, HDMI_V_SYNC_LINE_AFT_PXL_4_0, 2, 0xffff);\n\thdmi_reg_writev(hdata, HDMI_V_SYNC_LINE_AFT_PXL_5_0, 2, 0xffff);\n\thdmi_reg_writev(hdata, HDMI_V_SYNC_LINE_AFT_PXL_6_0, 2, 0xffff);\n\n\thdmi_reg_writev(hdata, HDMI_TG_H_FSZ_L, 2, m->htotal);\n\thdmi_reg_writev(hdata, HDMI_TG_HACT_ST_L, 2,\n\t\t\t\t\tm->htotal - m->hdisplay - hquirk);\n\thdmi_reg_writev(hdata, HDMI_TG_HACT_SZ_L, 2, m->hdisplay + hquirk);\n\thdmi_reg_writev(hdata, HDMI_TG_V_FSZ_L, 2, m->vtotal);\n\tif (hdata->drv_data == &exynos5433_hdmi_driver_data)\n\t\thdmi_reg_writeb(hdata, HDMI_TG_DECON_EN, 1);\n}\n\nstatic void hdmi_mode_apply(struct hdmi_context *hdata)\n{\n\tif (hdata->drv_data->type == HDMI_TYPE13)\n\t\thdmi_v13_mode_apply(hdata);\n\telse\n\t\thdmi_v14_mode_apply(hdata);\n\n\thdmi_start(hdata, true);\n}\n\nstatic void hdmiphy_conf_reset(struct hdmi_context *hdata)\n{\n\thdmi_reg_writemask(hdata, HDMI_CORE_RSTOUT, 0, 1);\n\tusleep_range(10000, 12000);\n\thdmi_reg_writemask(hdata, HDMI_CORE_RSTOUT, ~0, 1);\n\tusleep_range(10000, 12000);\n\thdmi_reg_writemask(hdata, HDMI_PHY_RSTOUT, ~0, HDMI_PHY_SW_RSTOUT);\n\tusleep_range(10000, 12000);\n\thdmi_reg_writemask(hdata, HDMI_PHY_RSTOUT, 0, HDMI_PHY_SW_RSTOUT);\n\tusleep_range(10000, 12000);\n}\n\nstatic void hdmiphy_enable_mode_set(struct hdmi_context *hdata, bool enable)\n{\n\tu8 v = enable ? HDMI_PHY_ENABLE_MODE_SET : HDMI_PHY_DISABLE_MODE_SET;\n\n\tif (hdata->drv_data == &exynos5433_hdmi_driver_data)\n\t\twritel(v, hdata->regs_hdmiphy + HDMIPHY5433_MODE_SET_DONE);\n}\n\nstatic void hdmiphy_conf_apply(struct hdmi_context *hdata)\n{\n\tstruct drm_display_mode *m = &hdata->encoder.crtc->state->mode;\n\tint ret;\n\tconst u8 *phy_conf;\n\n\tret = hdmi_find_phy_conf(hdata, m->clock * 1000);\n\tif (ret < 0) {\n\t\tDRM_DEV_ERROR(hdata->dev, \"failed to find hdmiphy conf\\n\");\n\t\treturn;\n\t}\n\tphy_conf = hdata->drv_data->phy_confs.data[ret].conf;\n\n\thdmi_clk_set_parents(hdata, false);\n\n\thdmiphy_conf_reset(hdata);\n\n\thdmiphy_enable_mode_set(hdata, true);\n\tret = hdmiphy_reg_write_buf(hdata, 0, phy_conf, 32);\n\tif (ret) {\n\t\tDRM_DEV_ERROR(hdata->dev, \"failed to configure hdmiphy\\n\");\n\t\treturn;\n\t}\n\thdmiphy_enable_mode_set(hdata, false);\n\thdmi_clk_set_parents(hdata, true);\n\tusleep_range(10000, 12000);\n\thdmiphy_wait_for_pll(hdata);\n}\n\n \nstatic void hdmi_conf_apply(struct hdmi_context *hdata)\n{\n\thdmi_start(hdata, false);\n\thdmi_conf_init(hdata);\n\thdmi_audio_config(hdata);\n\thdmi_mode_apply(hdata);\n\thdmi_audio_control(hdata);\n}\n\nstatic void hdmi_set_refclk(struct hdmi_context *hdata, bool on)\n{\n\tif (!hdata->sysreg)\n\t\treturn;\n\n\tregmap_update_bits(hdata->sysreg, EXYNOS5433_SYSREG_DISP_HDMI_PHY,\n\t\t\t   SYSREG_HDMI_REFCLK_INT_CLK, on ? ~0 : 0);\n}\n\n \nstatic void hdmiphy_enable(struct hdmi_context *hdata)\n{\n\tint ret;\n\n\tif (hdata->powered)\n\t\treturn;\n\n\tret = pm_runtime_resume_and_get(hdata->dev);\n\tif (ret < 0) {\n\t\tdev_err(hdata->dev, \"failed to enable HDMIPHY device.\\n\");\n\t\treturn;\n\t}\n\n\tif (regulator_bulk_enable(ARRAY_SIZE(supply), hdata->regul_bulk))\n\t\tDRM_DEV_DEBUG_KMS(hdata->dev,\n\t\t\t\t  \"failed to enable regulator bulk\\n\");\n\n\tregmap_update_bits(hdata->pmureg, PMU_HDMI_PHY_CONTROL,\n\t\t\tPMU_HDMI_PHY_ENABLE_BIT, 1);\n\n\thdmi_set_refclk(hdata, true);\n\n\thdmi_reg_writemask(hdata, HDMI_PHY_CON_0, 0, HDMI_PHY_POWER_OFF_EN);\n\n\thdmiphy_conf_apply(hdata);\n\n\thdata->powered = true;\n}\n\n \nstatic void hdmiphy_disable(struct hdmi_context *hdata)\n{\n\tif (!hdata->powered)\n\t\treturn;\n\n\thdmi_reg_writemask(hdata, HDMI_CON_0, 0, HDMI_EN);\n\n\thdmi_reg_writemask(hdata, HDMI_PHY_CON_0, ~0, HDMI_PHY_POWER_OFF_EN);\n\n\thdmi_set_refclk(hdata, false);\n\n\tregmap_update_bits(hdata->pmureg, PMU_HDMI_PHY_CONTROL,\n\t\t\tPMU_HDMI_PHY_ENABLE_BIT, 0);\n\n\tregulator_bulk_disable(ARRAY_SIZE(supply), hdata->regul_bulk);\n\n\tpm_runtime_put_sync(hdata->dev);\n\n\thdata->powered = false;\n}\n\nstatic void hdmi_enable(struct drm_encoder *encoder)\n{\n\tstruct hdmi_context *hdata = encoder_to_hdmi(encoder);\n\n\tmutex_lock(&hdata->mutex);\n\n\thdmiphy_enable(hdata);\n\thdmi_conf_apply(hdata);\n\n\tmutex_unlock(&hdata->mutex);\n}\n\nstatic void hdmi_disable(struct drm_encoder *encoder)\n{\n\tstruct hdmi_context *hdata = encoder_to_hdmi(encoder);\n\n\tmutex_lock(&hdata->mutex);\n\n\tif (hdata->powered) {\n\t\t \n\t\tmutex_unlock(&hdata->mutex);\n\t\tcancel_delayed_work(&hdata->hotplug_work);\n\t\tif (hdata->notifier)\n\t\t\tcec_notifier_phys_addr_invalidate(hdata->notifier);\n\t\treturn;\n\t}\n\n\tmutex_unlock(&hdata->mutex);\n}\n\nstatic const struct drm_encoder_helper_funcs exynos_hdmi_encoder_helper_funcs = {\n\t.mode_fixup\t= hdmi_mode_fixup,\n\t.enable\t\t= hdmi_enable,\n\t.disable\t= hdmi_disable,\n};\n\nstatic void hdmi_audio_shutdown(struct device *dev, void *data)\n{\n\tstruct hdmi_context *hdata = dev_get_drvdata(dev);\n\n\tmutex_lock(&hdata->mutex);\n\n\thdata->audio.mute = true;\n\n\tif (hdata->powered)\n\t\thdmi_audio_control(hdata);\n\n\tmutex_unlock(&hdata->mutex);\n}\n\nstatic int hdmi_audio_hw_params(struct device *dev, void *data,\n\t\t\t\tstruct hdmi_codec_daifmt *daifmt,\n\t\t\t\tstruct hdmi_codec_params *params)\n{\n\tstruct hdmi_context *hdata = dev_get_drvdata(dev);\n\n\tif (daifmt->fmt != HDMI_I2S || daifmt->bit_clk_inv ||\n\t    daifmt->frame_clk_inv || daifmt->bit_clk_provider ||\n\t    daifmt->frame_clk_provider) {\n\t\tdev_err(dev, \"%s: Bad flags %d %d %d %d\\n\", __func__,\n\t\t\tdaifmt->bit_clk_inv, daifmt->frame_clk_inv,\n\t\t\tdaifmt->bit_clk_provider,\n\t\t\tdaifmt->frame_clk_provider);\n\t\treturn -EINVAL;\n\t}\n\n\tmutex_lock(&hdata->mutex);\n\n\thdata->audio.params = *params;\n\n\tif (hdata->powered) {\n\t\thdmi_audio_config(hdata);\n\t\thdmi_audio_infoframe_apply(hdata);\n\t}\n\n\tmutex_unlock(&hdata->mutex);\n\n\treturn 0;\n}\n\nstatic int hdmi_audio_mute(struct device *dev, void *data,\n\t\t\t   bool mute, int direction)\n{\n\tstruct hdmi_context *hdata = dev_get_drvdata(dev);\n\n\tmutex_lock(&hdata->mutex);\n\n\thdata->audio.mute = mute;\n\n\tif (hdata->powered)\n\t\thdmi_audio_control(hdata);\n\n\tmutex_unlock(&hdata->mutex);\n\n\treturn 0;\n}\n\nstatic int hdmi_audio_get_eld(struct device *dev, void *data, uint8_t *buf,\n\t\t\t      size_t len)\n{\n\tstruct hdmi_context *hdata = dev_get_drvdata(dev);\n\tstruct drm_connector *connector = &hdata->connector;\n\n\tmemcpy(buf, connector->eld, min(sizeof(connector->eld), len));\n\n\treturn 0;\n}\n\nstatic const struct hdmi_codec_ops audio_codec_ops = {\n\t.hw_params = hdmi_audio_hw_params,\n\t.audio_shutdown = hdmi_audio_shutdown,\n\t.mute_stream = hdmi_audio_mute,\n\t.get_eld = hdmi_audio_get_eld,\n\t.no_capture_mute = 1,\n};\n\nstatic int hdmi_register_audio_device(struct hdmi_context *hdata)\n{\n\tstruct hdmi_codec_pdata codec_data = {\n\t\t.ops = &audio_codec_ops,\n\t\t.max_i2s_channels = 6,\n\t\t.i2s = 1,\n\t};\n\n\thdata->audio.pdev = platform_device_register_data(\n\t\thdata->dev, HDMI_CODEC_DRV_NAME, PLATFORM_DEVID_AUTO,\n\t\t&codec_data, sizeof(codec_data));\n\n\treturn PTR_ERR_OR_ZERO(hdata->audio.pdev);\n}\n\nstatic void hdmi_hotplug_work_func(struct work_struct *work)\n{\n\tstruct hdmi_context *hdata;\n\n\thdata = container_of(work, struct hdmi_context, hotplug_work.work);\n\n\tif (hdata->drm_dev)\n\t\tdrm_helper_hpd_irq_event(hdata->drm_dev);\n}\n\nstatic irqreturn_t hdmi_irq_thread(int irq, void *arg)\n{\n\tstruct hdmi_context *hdata = arg;\n\n\tmod_delayed_work(system_wq, &hdata->hotplug_work,\n\t\t\tmsecs_to_jiffies(HOTPLUG_DEBOUNCE_MS));\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int hdmi_clks_get(struct hdmi_context *hdata,\n\t\t\t const struct string_array_spec *names,\n\t\t\t struct clk **clks)\n{\n\tstruct device *dev = hdata->dev;\n\tint i;\n\n\tfor (i = 0; i < names->count; ++i) {\n\t\tstruct clk *clk = devm_clk_get(dev, names->data[i]);\n\n\t\tif (IS_ERR(clk)) {\n\t\t\tint ret = PTR_ERR(clk);\n\n\t\t\tdev_err(dev, \"Cannot get clock %s, %d\\n\",\n\t\t\t\tnames->data[i], ret);\n\n\t\t\treturn ret;\n\t\t}\n\n\t\tclks[i] = clk;\n\t}\n\n\treturn 0;\n}\n\nstatic int hdmi_clk_init(struct hdmi_context *hdata)\n{\n\tconst struct hdmi_driver_data *drv_data = hdata->drv_data;\n\tint count = drv_data->clk_gates.count + drv_data->clk_muxes.count;\n\tstruct device *dev = hdata->dev;\n\tstruct clk **clks;\n\tint ret;\n\n\tif (!count)\n\t\treturn 0;\n\n\tclks = devm_kcalloc(dev, count, sizeof(*clks), GFP_KERNEL);\n\tif (!clks)\n\t\treturn -ENOMEM;\n\n\thdata->clk_gates = clks;\n\thdata->clk_muxes = clks + drv_data->clk_gates.count;\n\n\tret = hdmi_clks_get(hdata, &drv_data->clk_gates, hdata->clk_gates);\n\tif (ret)\n\t\treturn ret;\n\n\treturn hdmi_clks_get(hdata, &drv_data->clk_muxes, hdata->clk_muxes);\n}\n\n\nstatic void hdmiphy_clk_enable(struct exynos_drm_clk *clk, bool enable)\n{\n\tstruct hdmi_context *hdata = container_of(clk, struct hdmi_context,\n\t\t\t\t\t\t  phy_clk);\n\tmutex_lock(&hdata->mutex);\n\n\tif (enable)\n\t\thdmiphy_enable(hdata);\n\telse\n\t\thdmiphy_disable(hdata);\n\n\tmutex_unlock(&hdata->mutex);\n}\n\nstatic int hdmi_bridge_init(struct hdmi_context *hdata)\n{\n\tstruct device *dev = hdata->dev;\n\tstruct device_node *ep, *np;\n\n\tep = of_graph_get_endpoint_by_regs(dev->of_node, 1, -1);\n\tif (!ep)\n\t\treturn 0;\n\n\tnp = of_graph_get_remote_port_parent(ep);\n\tof_node_put(ep);\n\tif (!np) {\n\t\tDRM_DEV_ERROR(dev, \"failed to get remote port parent\");\n\t\treturn -EINVAL;\n\t}\n\n\thdata->bridge = of_drm_find_bridge(np);\n\tof_node_put(np);\n\n\tif (!hdata->bridge)\n\t\treturn -EPROBE_DEFER;\n\n\treturn 0;\n}\n\nstatic int hdmi_resources_init(struct hdmi_context *hdata)\n{\n\tstruct device *dev = hdata->dev;\n\tint i, ret;\n\n\tDRM_DEV_DEBUG_KMS(dev, \"HDMI resource init\\n\");\n\n\thdata->hpd_gpio = devm_gpiod_get(dev, \"hpd\", GPIOD_IN);\n\tif (IS_ERR(hdata->hpd_gpio)) {\n\t\tDRM_DEV_ERROR(dev, \"cannot get hpd gpio property\\n\");\n\t\treturn PTR_ERR(hdata->hpd_gpio);\n\t}\n\n\thdata->irq = gpiod_to_irq(hdata->hpd_gpio);\n\tif (hdata->irq < 0) {\n\t\tDRM_DEV_ERROR(dev, \"failed to get GPIO irq\\n\");\n\t\treturn  hdata->irq;\n\t}\n\n\tret = hdmi_clk_init(hdata);\n\tif (ret)\n\t\treturn ret;\n\n\tret = hdmi_clk_set_parents(hdata, false);\n\tif (ret)\n\t\treturn ret;\n\n\tfor (i = 0; i < ARRAY_SIZE(supply); ++i)\n\t\thdata->regul_bulk[i].supply = supply[i];\n\n\tret = devm_regulator_bulk_get(dev, ARRAY_SIZE(supply), hdata->regul_bulk);\n\tif (ret)\n\t\treturn dev_err_probe(dev, ret, \"failed to get regulators\\n\");\n\n\thdata->reg_hdmi_en = devm_regulator_get_optional(dev, \"hdmi-en\");\n\n\tif (PTR_ERR(hdata->reg_hdmi_en) != -ENODEV)\n\t\tif (IS_ERR(hdata->reg_hdmi_en))\n\t\t\treturn PTR_ERR(hdata->reg_hdmi_en);\n\n\treturn hdmi_bridge_init(hdata);\n}\n\nstatic const struct of_device_id hdmi_match_types[] = {\n\t{\n\t\t.compatible = \"samsung,exynos4210-hdmi\",\n\t\t.data = &exynos4210_hdmi_driver_data,\n\t}, {\n\t\t.compatible = \"samsung,exynos4212-hdmi\",\n\t\t.data = &exynos4212_hdmi_driver_data,\n\t}, {\n\t\t.compatible = \"samsung,exynos5420-hdmi\",\n\t\t.data = &exynos5420_hdmi_driver_data,\n\t}, {\n\t\t.compatible = \"samsung,exynos5433-hdmi\",\n\t\t.data = &exynos5433_hdmi_driver_data,\n\t}, {\n\t\t \n\t}\n};\nMODULE_DEVICE_TABLE (of, hdmi_match_types);\n\nstatic int hdmi_bind(struct device *dev, struct device *master, void *data)\n{\n\tstruct drm_device *drm_dev = data;\n\tstruct hdmi_context *hdata = dev_get_drvdata(dev);\n\tstruct drm_encoder *encoder = &hdata->encoder;\n\tstruct exynos_drm_crtc *crtc;\n\tint ret;\n\n\thdata->drm_dev = drm_dev;\n\n\thdata->phy_clk.enable = hdmiphy_clk_enable;\n\n\tdrm_simple_encoder_init(drm_dev, encoder, DRM_MODE_ENCODER_TMDS);\n\n\tdrm_encoder_helper_add(encoder, &exynos_hdmi_encoder_helper_funcs);\n\n\tret = exynos_drm_set_possible_crtcs(encoder, EXYNOS_DISPLAY_TYPE_HDMI);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tcrtc = exynos_drm_crtc_get_by_type(drm_dev, EXYNOS_DISPLAY_TYPE_HDMI);\n\tif (IS_ERR(crtc))\n\t\treturn PTR_ERR(crtc);\n\tcrtc->pipe_clk = &hdata->phy_clk;\n\n\tret = hdmi_create_connector(encoder);\n\tif (ret) {\n\t\tDRM_DEV_ERROR(dev, \"failed to create connector ret = %d\\n\",\n\t\t\t      ret);\n\t\tdrm_encoder_cleanup(encoder);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic void hdmi_unbind(struct device *dev, struct device *master, void *data)\n{\n}\n\nstatic const struct component_ops hdmi_component_ops = {\n\t.bind\t= hdmi_bind,\n\t.unbind = hdmi_unbind,\n};\n\nstatic int hdmi_get_ddc_adapter(struct hdmi_context *hdata)\n{\n\tconst char *compatible_str = \"samsung,exynos4210-hdmiddc\";\n\tstruct device_node *np;\n\tstruct i2c_adapter *adpt;\n\n\tnp = of_find_compatible_node(NULL, NULL, compatible_str);\n\tif (np)\n\t\tnp = of_get_next_parent(np);\n\telse\n\t\tnp = of_parse_phandle(hdata->dev->of_node, \"ddc\", 0);\n\n\tif (!np) {\n\t\tDRM_DEV_ERROR(hdata->dev,\n\t\t\t      \"Failed to find ddc node in device tree\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tadpt = of_find_i2c_adapter_by_node(np);\n\tof_node_put(np);\n\n\tif (!adpt) {\n\t\tDRM_INFO(\"Failed to get ddc i2c adapter by node\\n\");\n\t\treturn -EPROBE_DEFER;\n\t}\n\n\thdata->ddc_adpt = adpt;\n\n\treturn 0;\n}\n\nstatic int hdmi_get_phy_io(struct hdmi_context *hdata)\n{\n\tconst char *compatible_str = \"samsung,exynos4212-hdmiphy\";\n\tstruct device_node *np;\n\tint ret = 0;\n\n\tnp = of_find_compatible_node(NULL, NULL, compatible_str);\n\tif (!np) {\n\t\tnp = of_parse_phandle(hdata->dev->of_node, \"phy\", 0);\n\t\tif (!np) {\n\t\t\tDRM_DEV_ERROR(hdata->dev,\n\t\t\t\t      \"Failed to find hdmiphy node in device tree\\n\");\n\t\t\treturn -ENODEV;\n\t\t}\n\t}\n\n\tif (hdata->drv_data->is_apb_phy) {\n\t\thdata->regs_hdmiphy = of_iomap(np, 0);\n\t\tif (!hdata->regs_hdmiphy) {\n\t\t\tDRM_DEV_ERROR(hdata->dev,\n\t\t\t\t      \"failed to ioremap hdmi phy\\n\");\n\t\t\tret = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t} else {\n\t\thdata->hdmiphy_port = of_find_i2c_device_by_node(np);\n\t\tif (!hdata->hdmiphy_port) {\n\t\t\tDRM_INFO(\"Failed to get hdmi phy i2c client\\n\");\n\t\t\tret = -EPROBE_DEFER;\n\t\t\tgoto out;\n\t\t}\n\t}\n\nout:\n\tof_node_put(np);\n\treturn ret;\n}\n\nstatic int hdmi_probe(struct platform_device *pdev)\n{\n\tstruct hdmi_audio_infoframe *audio_infoframe;\n\tstruct device *dev = &pdev->dev;\n\tstruct hdmi_context *hdata;\n\tint ret;\n\n\thdata = devm_kzalloc(dev, sizeof(struct hdmi_context), GFP_KERNEL);\n\tif (!hdata)\n\t\treturn -ENOMEM;\n\n\thdata->drv_data = of_device_get_match_data(dev);\n\n\tplatform_set_drvdata(pdev, hdata);\n\n\thdata->dev = dev;\n\n\tmutex_init(&hdata->mutex);\n\n\tret = hdmi_resources_init(hdata);\n\tif (ret) {\n\t\tif (ret != -EPROBE_DEFER)\n\t\t\tDRM_DEV_ERROR(dev, \"hdmi_resources_init failed\\n\");\n\t\treturn ret;\n\t}\n\n\thdata->regs = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(hdata->regs)) {\n\t\tret = PTR_ERR(hdata->regs);\n\t\treturn ret;\n\t}\n\n\tret = hdmi_get_ddc_adapter(hdata);\n\tif (ret)\n\t\treturn ret;\n\n\tret = hdmi_get_phy_io(hdata);\n\tif (ret)\n\t\tgoto err_ddc;\n\n\tINIT_DELAYED_WORK(&hdata->hotplug_work, hdmi_hotplug_work_func);\n\n\tret = devm_request_threaded_irq(dev, hdata->irq, NULL,\n\t\t\thdmi_irq_thread, IRQF_TRIGGER_RISING |\n\t\t\tIRQF_TRIGGER_FALLING | IRQF_ONESHOT,\n\t\t\t\"hdmi\", hdata);\n\tif (ret) {\n\t\tDRM_DEV_ERROR(dev, \"failed to register hdmi interrupt\\n\");\n\t\tgoto err_hdmiphy;\n\t}\n\n\thdata->pmureg = syscon_regmap_lookup_by_phandle(dev->of_node,\n\t\t\t\"samsung,syscon-phandle\");\n\tif (IS_ERR(hdata->pmureg)) {\n\t\tDRM_DEV_ERROR(dev, \"syscon regmap lookup failed.\\n\");\n\t\tret = -EPROBE_DEFER;\n\t\tgoto err_hdmiphy;\n\t}\n\n\tif (hdata->drv_data->has_sysreg) {\n\t\thdata->sysreg = syscon_regmap_lookup_by_phandle(dev->of_node,\n\t\t\t\t\"samsung,sysreg-phandle\");\n\t\tif (IS_ERR(hdata->sysreg)) {\n\t\t\tDRM_DEV_ERROR(dev, \"sysreg regmap lookup failed.\\n\");\n\t\t\tret = -EPROBE_DEFER;\n\t\t\tgoto err_hdmiphy;\n\t\t}\n\t}\n\n\tif (!IS_ERR(hdata->reg_hdmi_en)) {\n\t\tret = regulator_enable(hdata->reg_hdmi_en);\n\t\tif (ret) {\n\t\t\tDRM_DEV_ERROR(dev,\n\t\t\t      \"failed to enable hdmi-en regulator\\n\");\n\t\t\tgoto err_hdmiphy;\n\t\t}\n\t}\n\n\tpm_runtime_enable(dev);\n\n\taudio_infoframe = &hdata->audio.infoframe;\n\thdmi_audio_infoframe_init(audio_infoframe);\n\taudio_infoframe->coding_type = HDMI_AUDIO_CODING_TYPE_STREAM;\n\taudio_infoframe->sample_size = HDMI_AUDIO_SAMPLE_SIZE_STREAM;\n\taudio_infoframe->sample_frequency = HDMI_AUDIO_SAMPLE_FREQUENCY_STREAM;\n\taudio_infoframe->channels = 2;\n\n\tret = hdmi_register_audio_device(hdata);\n\tif (ret)\n\t\tgoto err_rpm_disable;\n\n\tret = component_add(&pdev->dev, &hdmi_component_ops);\n\tif (ret)\n\t\tgoto err_unregister_audio;\n\n\treturn ret;\n\nerr_unregister_audio:\n\tplatform_device_unregister(hdata->audio.pdev);\n\nerr_rpm_disable:\n\tpm_runtime_disable(dev);\n\tif (!IS_ERR(hdata->reg_hdmi_en))\n\t\tregulator_disable(hdata->reg_hdmi_en);\nerr_hdmiphy:\n\tif (hdata->hdmiphy_port)\n\t\tput_device(&hdata->hdmiphy_port->dev);\n\tif (hdata->regs_hdmiphy)\n\t\tiounmap(hdata->regs_hdmiphy);\nerr_ddc:\n\tput_device(&hdata->ddc_adpt->dev);\n\n\treturn ret;\n}\n\nstatic int hdmi_remove(struct platform_device *pdev)\n{\n\tstruct hdmi_context *hdata = platform_get_drvdata(pdev);\n\n\tcancel_delayed_work_sync(&hdata->hotplug_work);\n\n\tcomponent_del(&pdev->dev, &hdmi_component_ops);\n\tplatform_device_unregister(hdata->audio.pdev);\n\n\tpm_runtime_disable(&pdev->dev);\n\n\tif (!IS_ERR(hdata->reg_hdmi_en))\n\t\tregulator_disable(hdata->reg_hdmi_en);\n\n\tif (hdata->hdmiphy_port)\n\t\tput_device(&hdata->hdmiphy_port->dev);\n\n\tif (hdata->regs_hdmiphy)\n\t\tiounmap(hdata->regs_hdmiphy);\n\n\tput_device(&hdata->ddc_adpt->dev);\n\n\tmutex_destroy(&hdata->mutex);\n\n\treturn 0;\n}\n\nstatic int __maybe_unused exynos_hdmi_suspend(struct device *dev)\n{\n\tstruct hdmi_context *hdata = dev_get_drvdata(dev);\n\n\thdmi_clk_disable_gates(hdata);\n\n\treturn 0;\n}\n\nstatic int __maybe_unused exynos_hdmi_resume(struct device *dev)\n{\n\tstruct hdmi_context *hdata = dev_get_drvdata(dev);\n\tint ret;\n\n\tret = hdmi_clk_enable_gates(hdata);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn 0;\n}\n\nstatic const struct dev_pm_ops exynos_hdmi_pm_ops = {\n\tSET_RUNTIME_PM_OPS(exynos_hdmi_suspend, exynos_hdmi_resume, NULL)\n\tSET_SYSTEM_SLEEP_PM_OPS(pm_runtime_force_suspend,\n\t\t\t\tpm_runtime_force_resume)\n};\n\nstruct platform_driver hdmi_driver = {\n\t.probe\t\t= hdmi_probe,\n\t.remove\t\t= hdmi_remove,\n\t.driver\t\t= {\n\t\t.name\t= \"exynos-hdmi\",\n\t\t.owner\t= THIS_MODULE,\n\t\t.pm\t= &exynos_hdmi_pm_ops,\n\t\t.of_match_table = hdmi_match_types,\n\t},\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}