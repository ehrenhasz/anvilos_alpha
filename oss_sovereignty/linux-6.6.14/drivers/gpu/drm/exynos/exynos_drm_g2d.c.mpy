{
  "module_name": "exynos_drm_g2d.c",
  "hash_id": "90a6b1bf10e94ad48b9fbc4b46d52b1be9140e65d46b190c812f828dfdc9fca5",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/exynos/exynos_drm_g2d.c",
  "human_readable_source": "\n \n\n#include <linux/refcount.h>\n#include <linux/clk.h>\n#include <linux/component.h>\n#include <linux/delay.h>\n#include <linux/dma-mapping.h>\n#include <linux/err.h>\n#include <linux/interrupt.h>\n#include <linux/io.h>\n#include <linux/kernel.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/pm_runtime.h>\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/workqueue.h>\n\n#include <drm/drm_file.h>\n#include <drm/exynos_drm.h>\n\n#include \"exynos_drm_drv.h\"\n#include \"exynos_drm_g2d.h\"\n#include \"exynos_drm_gem.h\"\n\n#define G2D_HW_MAJOR_VER\t\t4\n#define G2D_HW_MINOR_VER\t\t1\n\n \n#define G2D_VALID_START\t\t\t0x0104\n#define G2D_VALID_END\t\t\t0x0880\n\n \n#define G2D_SOFT_RESET\t\t\t0x0000\n#define G2D_INTEN\t\t\t0x0004\n#define G2D_INTC_PEND\t\t\t0x000C\n#define G2D_DMA_SFR_BASE_ADDR\t\t0x0080\n#define G2D_DMA_COMMAND\t\t\t0x0084\n#define G2D_DMA_STATUS\t\t\t0x008C\n#define G2D_DMA_HOLD_CMD\t\t0x0090\n\n \n#define G2D_BITBLT_START\t\t0x0100\n\n \n#define G2D_SRC_BASE_ADDR\t\t0x0304\n#define G2D_SRC_STRIDE\t\t\t0x0308\n#define G2D_SRC_COLOR_MODE\t\t0x030C\n#define G2D_SRC_LEFT_TOP\t\t0x0310\n#define G2D_SRC_RIGHT_BOTTOM\t\t0x0314\n#define G2D_SRC_PLANE2_BASE_ADDR\t0x0318\n#define G2D_DST_BASE_ADDR\t\t0x0404\n#define G2D_DST_STRIDE\t\t\t0x0408\n#define G2D_DST_COLOR_MODE\t\t0x040C\n#define G2D_DST_LEFT_TOP\t\t0x0410\n#define G2D_DST_RIGHT_BOTTOM\t\t0x0414\n#define G2D_DST_PLANE2_BASE_ADDR\t0x0418\n#define G2D_PAT_BASE_ADDR\t\t0x0500\n#define G2D_MSK_BASE_ADDR\t\t0x0520\n\n \n#define G2D_SFRCLEAR\t\t\t(1 << 1)\n#define G2D_R\t\t\t\t(1 << 0)\n\n \n#define G2D_INTEN_ACF\t\t\t(1 << 3)\n#define G2D_INTEN_UCF\t\t\t(1 << 2)\n#define G2D_INTEN_GCF\t\t\t(1 << 1)\n#define G2D_INTEN_SCF\t\t\t(1 << 0)\n\n \n#define G2D_INTP_ACMD_FIN\t\t(1 << 3)\n#define G2D_INTP_UCMD_FIN\t\t(1 << 2)\n#define G2D_INTP_GCMD_FIN\t\t(1 << 1)\n#define G2D_INTP_SCMD_FIN\t\t(1 << 0)\n\n \n#define G2D_DMA_HALT\t\t\t(1 << 2)\n#define G2D_DMA_CONTINUE\t\t(1 << 1)\n#define G2D_DMA_START\t\t\t(1 << 0)\n\n \n#define G2D_DMA_LIST_DONE_COUNT\t\t(0xFF << 17)\n#define G2D_DMA_BITBLT_DONE_COUNT\t(0xFFFF << 1)\n#define G2D_DMA_DONE\t\t\t(1 << 0)\n#define G2D_DMA_LIST_DONE_COUNT_OFFSET\t17\n\n \n#define G2D_USER_HOLD\t\t\t(1 << 2)\n#define G2D_LIST_HOLD\t\t\t(1 << 1)\n#define G2D_BITBLT_HOLD\t\t\t(1 << 0)\n\n \n#define G2D_START_CASESEL\t\t(1 << 2)\n#define G2D_START_NHOLT\t\t\t(1 << 1)\n#define G2D_START_BITBLT\t\t(1 << 0)\n\n \n#define G2D_FMT_XRGB8888\t\t0\n#define G2D_FMT_ARGB8888\t\t1\n#define G2D_FMT_RGB565\t\t\t2\n#define G2D_FMT_XRGB1555\t\t3\n#define G2D_FMT_ARGB1555\t\t4\n#define G2D_FMT_XRGB4444\t\t5\n#define G2D_FMT_ARGB4444\t\t6\n#define G2D_FMT_PACKED_RGB888\t\t7\n#define G2D_FMT_A8\t\t\t11\n#define G2D_FMT_L8\t\t\t12\n\n \n#define G2D_LEN_MIN\t\t\t1\n#define G2D_LEN_MAX\t\t\t8000\n\n#define G2D_CMDLIST_SIZE\t\t(PAGE_SIZE / 4)\n#define G2D_CMDLIST_NUM\t\t\t64\n#define G2D_CMDLIST_POOL_SIZE\t\t(G2D_CMDLIST_SIZE * G2D_CMDLIST_NUM)\n#define G2D_CMDLIST_DATA_NUM\t\t(G2D_CMDLIST_SIZE / sizeof(u32) - 2)\n\n \n#define MAX_POOL\t\t(64 * 1024 * 1024)\n\nenum {\n\tBUF_TYPE_GEM = 1,\n\tBUF_TYPE_USERPTR,\n};\n\nenum g2d_reg_type {\n\tREG_TYPE_NONE = -1,\n\tREG_TYPE_SRC,\n\tREG_TYPE_SRC_PLANE2,\n\tREG_TYPE_DST,\n\tREG_TYPE_DST_PLANE2,\n\tREG_TYPE_PAT,\n\tREG_TYPE_MSK,\n\tMAX_REG_TYPE_NR\n};\n\nenum g2d_flag_bits {\n\t \n\tG2D_BIT_SUSPEND_RUNQUEUE,\n\t \n\tG2D_BIT_ENGINE_BUSY,\n};\n\n \nstruct g2d_cmdlist {\n\tu32\t\thead;\n\tunsigned long\tdata[G2D_CMDLIST_DATA_NUM];\n\tu32\t\tlast;\t \n};\n\n \nstruct g2d_buf_desc {\n\tunsigned int\tformat;\n\tunsigned int\tstride;\n\tunsigned int\tleft_x;\n\tunsigned int\ttop_y;\n\tunsigned int\tright_x;\n\tunsigned int\tbottom_y;\n};\n\n \nstruct g2d_buf_info {\n\tunsigned int\t\tmap_nr;\n\tenum g2d_reg_type\treg_types[MAX_REG_TYPE_NR];\n\tvoid\t\t\t*obj[MAX_REG_TYPE_NR];\n\tunsigned int\t\ttypes[MAX_REG_TYPE_NR];\n\tstruct g2d_buf_desc\tdescs[MAX_REG_TYPE_NR];\n};\n\nstruct drm_exynos_pending_g2d_event {\n\tstruct drm_pending_event\tbase;\n\tstruct drm_exynos_g2d_event\tevent;\n};\n\nstruct g2d_cmdlist_userptr {\n\tstruct list_head\tlist;\n\tdma_addr_t\t\tdma_addr;\n\tunsigned long\t\tuserptr;\n\tunsigned long\t\tsize;\n\tstruct page\t\t**pages;\n\tunsigned int\t\tnpages;\n\tstruct sg_table\t\t*sgt;\n\trefcount_t\t\trefcount;\n\tbool\t\t\tin_pool;\n\tbool\t\t\tout_of_list;\n};\nstruct g2d_cmdlist_node {\n\tstruct list_head\tlist;\n\tstruct g2d_cmdlist\t*cmdlist;\n\tdma_addr_t\t\tdma_addr;\n\tstruct g2d_buf_info\tbuf_info;\n\n\tstruct drm_exynos_pending_g2d_event\t*event;\n};\n\nstruct g2d_runqueue_node {\n\tstruct list_head\tlist;\n\tstruct list_head\trun_cmdlist;\n\tstruct list_head\tevent_list;\n\tstruct drm_file\t\t*filp;\n\tpid_t\t\t\tpid;\n\tstruct completion\tcomplete;\n\tint\t\t\tasync;\n};\n\nstruct g2d_data {\n\tstruct device\t\t\t*dev;\n\tvoid\t\t\t\t*dma_priv;\n\tstruct clk\t\t\t*gate_clk;\n\tvoid __iomem\t\t\t*regs;\n\tint\t\t\t\tirq;\n\tstruct workqueue_struct\t\t*g2d_workq;\n\tstruct work_struct\t\trunqueue_work;\n\tstruct drm_device\t\t*drm_dev;\n\tunsigned long\t\t\tflags;\n\n\t \n\tstruct g2d_cmdlist_node\t\t*cmdlist_node;\n\tstruct list_head\t\tfree_cmdlist;\n\tstruct mutex\t\t\tcmdlist_mutex;\n\tdma_addr_t\t\t\tcmdlist_pool;\n\tvoid\t\t\t\t*cmdlist_pool_virt;\n\tunsigned long\t\t\tcmdlist_dma_attrs;\n\n\t \n\tstruct g2d_runqueue_node\t*runqueue_node;\n\tstruct list_head\t\trunqueue;\n\tstruct mutex\t\t\trunqueue_mutex;\n\tstruct kmem_cache\t\t*runqueue_slab;\n\n\tunsigned long\t\t\tcurrent_pool;\n\tunsigned long\t\t\tmax_pool;\n};\n\nstatic inline void g2d_hw_reset(struct g2d_data *g2d)\n{\n\twritel(G2D_R | G2D_SFRCLEAR, g2d->regs + G2D_SOFT_RESET);\n\tclear_bit(G2D_BIT_ENGINE_BUSY, &g2d->flags);\n}\n\nstatic int g2d_init_cmdlist(struct g2d_data *g2d)\n{\n\tstruct device *dev = g2d->dev;\n\tstruct g2d_cmdlist_node *node;\n\tint nr;\n\tint ret;\n\tstruct g2d_buf_info *buf_info;\n\n\tg2d->cmdlist_dma_attrs = DMA_ATTR_WRITE_COMBINE;\n\n\tg2d->cmdlist_pool_virt = dma_alloc_attrs(to_dma_dev(g2d->drm_dev),\n\t\t\t\t\t\tG2D_CMDLIST_POOL_SIZE,\n\t\t\t\t\t\t&g2d->cmdlist_pool, GFP_KERNEL,\n\t\t\t\t\t\tg2d->cmdlist_dma_attrs);\n\tif (!g2d->cmdlist_pool_virt) {\n\t\tdev_err(dev, \"failed to allocate dma memory\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tnode = kcalloc(G2D_CMDLIST_NUM, sizeof(*node), GFP_KERNEL);\n\tif (!node) {\n\t\tret = -ENOMEM;\n\t\tgoto err;\n\t}\n\n\tfor (nr = 0; nr < G2D_CMDLIST_NUM; nr++) {\n\t\tunsigned int i;\n\n\t\tnode[nr].cmdlist =\n\t\t\tg2d->cmdlist_pool_virt + nr * G2D_CMDLIST_SIZE;\n\t\tnode[nr].dma_addr =\n\t\t\tg2d->cmdlist_pool + nr * G2D_CMDLIST_SIZE;\n\n\t\tbuf_info = &node[nr].buf_info;\n\t\tfor (i = 0; i < MAX_REG_TYPE_NR; i++)\n\t\t\tbuf_info->reg_types[i] = REG_TYPE_NONE;\n\n\t\tlist_add_tail(&node[nr].list, &g2d->free_cmdlist);\n\t}\n\n\treturn 0;\n\nerr:\n\tdma_free_attrs(to_dma_dev(g2d->drm_dev), G2D_CMDLIST_POOL_SIZE,\n\t\t\tg2d->cmdlist_pool_virt,\n\t\t\tg2d->cmdlist_pool, g2d->cmdlist_dma_attrs);\n\treturn ret;\n}\n\nstatic void g2d_fini_cmdlist(struct g2d_data *g2d)\n{\n\tkfree(g2d->cmdlist_node);\n\n\tif (g2d->cmdlist_pool_virt && g2d->cmdlist_pool) {\n\t\tdma_free_attrs(to_dma_dev(g2d->drm_dev),\n\t\t\t\tG2D_CMDLIST_POOL_SIZE,\n\t\t\t\tg2d->cmdlist_pool_virt,\n\t\t\t\tg2d->cmdlist_pool, g2d->cmdlist_dma_attrs);\n\t}\n}\n\nstatic struct g2d_cmdlist_node *g2d_get_cmdlist(struct g2d_data *g2d)\n{\n\tstruct device *dev = g2d->dev;\n\tstruct g2d_cmdlist_node *node;\n\n\tmutex_lock(&g2d->cmdlist_mutex);\n\tif (list_empty(&g2d->free_cmdlist)) {\n\t\tdev_err(dev, \"there is no free cmdlist\\n\");\n\t\tmutex_unlock(&g2d->cmdlist_mutex);\n\t\treturn NULL;\n\t}\n\n\tnode = list_first_entry(&g2d->free_cmdlist, struct g2d_cmdlist_node,\n\t\t\t\tlist);\n\tlist_del_init(&node->list);\n\tmutex_unlock(&g2d->cmdlist_mutex);\n\n\treturn node;\n}\n\nstatic void g2d_put_cmdlist(struct g2d_data *g2d, struct g2d_cmdlist_node *node)\n{\n\tmutex_lock(&g2d->cmdlist_mutex);\n\tlist_move_tail(&node->list, &g2d->free_cmdlist);\n\tmutex_unlock(&g2d->cmdlist_mutex);\n}\n\nstatic void g2d_add_cmdlist_to_inuse(struct drm_exynos_file_private *file_priv,\n\t\t\t\t     struct g2d_cmdlist_node *node)\n{\n\tstruct g2d_cmdlist_node *lnode;\n\n\tif (list_empty(&file_priv->inuse_cmdlist))\n\t\tgoto add_to_list;\n\n\t \n\tlnode = list_entry(file_priv->inuse_cmdlist.prev,\n\t\t\t\tstruct g2d_cmdlist_node, list);\n\tlnode->cmdlist->data[lnode->cmdlist->last] = node->dma_addr;\n\nadd_to_list:\n\tlist_add_tail(&node->list, &file_priv->inuse_cmdlist);\n\n\tif (node->event)\n\t\tlist_add_tail(&node->event->base.link, &file_priv->event_list);\n}\n\nstatic void g2d_userptr_put_dma_addr(struct g2d_data *g2d,\n\t\t\t\t\tvoid *obj,\n\t\t\t\t\tbool force)\n{\n\tstruct g2d_cmdlist_userptr *g2d_userptr = obj;\n\n\tif (!obj)\n\t\treturn;\n\n\tif (force)\n\t\tgoto out;\n\n\trefcount_dec(&g2d_userptr->refcount);\n\n\tif (refcount_read(&g2d_userptr->refcount) > 0)\n\t\treturn;\n\n\tif (g2d_userptr->in_pool)\n\t\treturn;\n\nout:\n\tdma_unmap_sgtable(to_dma_dev(g2d->drm_dev), g2d_userptr->sgt,\n\t\t\t  DMA_BIDIRECTIONAL, 0);\n\n\tunpin_user_pages_dirty_lock(g2d_userptr->pages, g2d_userptr->npages,\n\t\t\t\t    true);\n\tkvfree(g2d_userptr->pages);\n\n\tif (!g2d_userptr->out_of_list)\n\t\tlist_del_init(&g2d_userptr->list);\n\n\tsg_free_table(g2d_userptr->sgt);\n\tkfree(g2d_userptr->sgt);\n\tkfree(g2d_userptr);\n}\n\nstatic dma_addr_t *g2d_userptr_get_dma_addr(struct g2d_data *g2d,\n\t\t\t\t\tunsigned long userptr,\n\t\t\t\t\tunsigned long size,\n\t\t\t\t\tstruct drm_file *filp,\n\t\t\t\t\tvoid **obj)\n{\n\tstruct drm_exynos_file_private *file_priv = filp->driver_priv;\n\tstruct g2d_cmdlist_userptr *g2d_userptr;\n\tstruct sg_table\t*sgt;\n\tunsigned long start, end;\n\tunsigned int npages, offset;\n\tint ret;\n\n\tif (!size) {\n\t\tDRM_DEV_ERROR(g2d->dev, \"invalid userptr size.\\n\");\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\t \n\tlist_for_each_entry(g2d_userptr, &file_priv->userptr_list, list) {\n\t\tif (g2d_userptr->userptr == userptr) {\n\t\t\t \n\t\t\tif (g2d_userptr->size == size) {\n\t\t\t\trefcount_inc(&g2d_userptr->refcount);\n\t\t\t\t*obj = g2d_userptr;\n\n\t\t\t\treturn &g2d_userptr->dma_addr;\n\t\t\t}\n\n\t\t\t \n\t\t\tg2d_userptr->out_of_list = true;\n\t\t\tg2d_userptr->in_pool = false;\n\t\t\tlist_del_init(&g2d_userptr->list);\n\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tg2d_userptr = kzalloc(sizeof(*g2d_userptr), GFP_KERNEL);\n\tif (!g2d_userptr)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\trefcount_set(&g2d_userptr->refcount, 1);\n\tg2d_userptr->size = size;\n\n\tstart = userptr & PAGE_MASK;\n\toffset = userptr & ~PAGE_MASK;\n\tend = PAGE_ALIGN(userptr + size);\n\tnpages = (end - start) >> PAGE_SHIFT;\n\tg2d_userptr->pages = kvmalloc_array(npages, sizeof(*g2d_userptr->pages),\n\t\t\t\t\t    GFP_KERNEL);\n\tif (!g2d_userptr->pages) {\n\t\tret = -ENOMEM;\n\t\tgoto err_free;\n\t}\n\n\tret = pin_user_pages_fast(start, npages,\n\t\t\t\t  FOLL_WRITE | FOLL_LONGTERM,\n\t\t\t\t  g2d_userptr->pages);\n\tif (ret != npages) {\n\t\tDRM_DEV_ERROR(g2d->dev,\n\t\t\t      \"failed to get user pages from userptr.\\n\");\n\t\tif (ret < 0)\n\t\t\tgoto err_destroy_pages;\n\t\tnpages = ret;\n\t\tret = -EFAULT;\n\t\tgoto err_unpin_pages;\n\t}\n\tg2d_userptr->npages = npages;\n\n\tsgt = kzalloc(sizeof(*sgt), GFP_KERNEL);\n\tif (!sgt) {\n\t\tret = -ENOMEM;\n\t\tgoto err_unpin_pages;\n\t}\n\n\tret = sg_alloc_table_from_pages(sgt,\n\t\t\t\t\tg2d_userptr->pages,\n\t\t\t\t\tnpages, offset, size, GFP_KERNEL);\n\tif (ret < 0) {\n\t\tDRM_DEV_ERROR(g2d->dev, \"failed to get sgt from pages.\\n\");\n\t\tgoto err_free_sgt;\n\t}\n\n\tg2d_userptr->sgt = sgt;\n\n\tret = dma_map_sgtable(to_dma_dev(g2d->drm_dev), sgt,\n\t\t\t      DMA_BIDIRECTIONAL, 0);\n\tif (ret) {\n\t\tDRM_DEV_ERROR(g2d->dev, \"failed to map sgt with dma region.\\n\");\n\t\tgoto err_sg_free_table;\n\t}\n\n\tg2d_userptr->dma_addr = sgt->sgl[0].dma_address;\n\tg2d_userptr->userptr = userptr;\n\n\tlist_add_tail(&g2d_userptr->list, &file_priv->userptr_list);\n\n\tif (g2d->current_pool + (npages << PAGE_SHIFT) < g2d->max_pool) {\n\t\tg2d->current_pool += npages << PAGE_SHIFT;\n\t\tg2d_userptr->in_pool = true;\n\t}\n\n\t*obj = g2d_userptr;\n\n\treturn &g2d_userptr->dma_addr;\n\nerr_sg_free_table:\n\tsg_free_table(sgt);\n\nerr_free_sgt:\n\tkfree(sgt);\n\nerr_unpin_pages:\n\tunpin_user_pages(g2d_userptr->pages, npages);\n\nerr_destroy_pages:\n\tkvfree(g2d_userptr->pages);\n\nerr_free:\n\tkfree(g2d_userptr);\n\n\treturn ERR_PTR(ret);\n}\n\nstatic void g2d_userptr_free_all(struct g2d_data *g2d, struct drm_file *filp)\n{\n\tstruct drm_exynos_file_private *file_priv = filp->driver_priv;\n\tstruct g2d_cmdlist_userptr *g2d_userptr, *n;\n\n\tlist_for_each_entry_safe(g2d_userptr, n, &file_priv->userptr_list, list)\n\t\tif (g2d_userptr->in_pool)\n\t\t\tg2d_userptr_put_dma_addr(g2d, g2d_userptr, true);\n\n\tg2d->current_pool = 0;\n}\n\nstatic enum g2d_reg_type g2d_get_reg_type(struct g2d_data *g2d, int reg_offset)\n{\n\tenum g2d_reg_type reg_type;\n\n\tswitch (reg_offset) {\n\tcase G2D_SRC_BASE_ADDR:\n\tcase G2D_SRC_STRIDE:\n\tcase G2D_SRC_COLOR_MODE:\n\tcase G2D_SRC_LEFT_TOP:\n\tcase G2D_SRC_RIGHT_BOTTOM:\n\t\treg_type = REG_TYPE_SRC;\n\t\tbreak;\n\tcase G2D_SRC_PLANE2_BASE_ADDR:\n\t\treg_type = REG_TYPE_SRC_PLANE2;\n\t\tbreak;\n\tcase G2D_DST_BASE_ADDR:\n\tcase G2D_DST_STRIDE:\n\tcase G2D_DST_COLOR_MODE:\n\tcase G2D_DST_LEFT_TOP:\n\tcase G2D_DST_RIGHT_BOTTOM:\n\t\treg_type = REG_TYPE_DST;\n\t\tbreak;\n\tcase G2D_DST_PLANE2_BASE_ADDR:\n\t\treg_type = REG_TYPE_DST_PLANE2;\n\t\tbreak;\n\tcase G2D_PAT_BASE_ADDR:\n\t\treg_type = REG_TYPE_PAT;\n\t\tbreak;\n\tcase G2D_MSK_BASE_ADDR:\n\t\treg_type = REG_TYPE_MSK;\n\t\tbreak;\n\tdefault:\n\t\treg_type = REG_TYPE_NONE;\n\t\tDRM_DEV_ERROR(g2d->dev, \"Unknown register offset![%d]\\n\",\n\t\t\t      reg_offset);\n\t\tbreak;\n\t}\n\n\treturn reg_type;\n}\n\nstatic unsigned long g2d_get_buf_bpp(unsigned int format)\n{\n\tunsigned long bpp;\n\n\tswitch (format) {\n\tcase G2D_FMT_XRGB8888:\n\tcase G2D_FMT_ARGB8888:\n\t\tbpp = 4;\n\t\tbreak;\n\tcase G2D_FMT_RGB565:\n\tcase G2D_FMT_XRGB1555:\n\tcase G2D_FMT_ARGB1555:\n\tcase G2D_FMT_XRGB4444:\n\tcase G2D_FMT_ARGB4444:\n\t\tbpp = 2;\n\t\tbreak;\n\tcase G2D_FMT_PACKED_RGB888:\n\t\tbpp = 3;\n\t\tbreak;\n\tdefault:\n\t\tbpp = 1;\n\t\tbreak;\n\t}\n\n\treturn bpp;\n}\n\nstatic bool g2d_check_buf_desc_is_valid(struct g2d_data *g2d,\n\t\t\t\t\tstruct g2d_buf_desc *buf_desc,\n\t\t\t\t\tenum g2d_reg_type reg_type,\n\t\t\t\t\tunsigned long size)\n{\n\tint width, height;\n\tunsigned long bpp, last_pos;\n\n\t \n\tif (reg_type != REG_TYPE_SRC && reg_type != REG_TYPE_DST)\n\t\treturn true;\n\n\t \n\twidth = (int)buf_desc->right_x - (int)buf_desc->left_x;\n\tif (width < G2D_LEN_MIN || width > G2D_LEN_MAX) {\n\t\tDRM_DEV_ERROR(g2d->dev, \"width[%d] is out of range!\\n\", width);\n\t\treturn false;\n\t}\n\n\t \n\theight = (int)buf_desc->bottom_y - (int)buf_desc->top_y;\n\tif (height < G2D_LEN_MIN || height > G2D_LEN_MAX) {\n\t\tDRM_DEV_ERROR(g2d->dev,\n\t\t\t      \"height[%d] is out of range!\\n\", height);\n\t\treturn false;\n\t}\n\n\tbpp = g2d_get_buf_bpp(buf_desc->format);\n\n\t \n\tlast_pos = ((unsigned long)buf_desc->bottom_y - 1) *\n\t\t(unsigned long)buf_desc->stride +\n\t\t(unsigned long)buf_desc->right_x * bpp - 1;\n\n\t \n\n\tif (last_pos >= size) {\n\t\tDRM_DEV_ERROR(g2d->dev, \"last engine access position [%lu] \"\n\t\t\t      \"is out of range [%lu]!\\n\", last_pos, size);\n\t\treturn false;\n\t}\n\n\treturn true;\n}\n\nstatic int g2d_map_cmdlist_gem(struct g2d_data *g2d,\n\t\t\t\tstruct g2d_cmdlist_node *node,\n\t\t\t\tstruct drm_device *drm_dev,\n\t\t\t\tstruct drm_file *file)\n{\n\tstruct g2d_cmdlist *cmdlist = node->cmdlist;\n\tstruct g2d_buf_info *buf_info = &node->buf_info;\n\tint offset;\n\tint ret;\n\tint i;\n\n\tfor (i = 0; i < buf_info->map_nr; i++) {\n\t\tstruct g2d_buf_desc *buf_desc;\n\t\tenum g2d_reg_type reg_type;\n\t\tint reg_pos;\n\t\tunsigned long handle;\n\t\tdma_addr_t *addr;\n\n\t\treg_pos = cmdlist->last - 2 * (i + 1);\n\n\t\toffset = cmdlist->data[reg_pos];\n\t\thandle = cmdlist->data[reg_pos + 1];\n\n\t\treg_type = g2d_get_reg_type(g2d, offset);\n\t\tif (reg_type == REG_TYPE_NONE) {\n\t\t\tret = -EFAULT;\n\t\t\tgoto err;\n\t\t}\n\n\t\tbuf_desc = &buf_info->descs[reg_type];\n\n\t\tif (buf_info->types[reg_type] == BUF_TYPE_GEM) {\n\t\t\tstruct exynos_drm_gem *exynos_gem;\n\n\t\t\texynos_gem = exynos_drm_gem_get(file, handle);\n\t\t\tif (!exynos_gem) {\n\t\t\t\tret = -EFAULT;\n\t\t\t\tgoto err;\n\t\t\t}\n\n\t\t\tif (!g2d_check_buf_desc_is_valid(g2d, buf_desc,\n\t\t\t\t\t\t\t reg_type, exynos_gem->size)) {\n\t\t\t\texynos_drm_gem_put(exynos_gem);\n\t\t\t\tret = -EFAULT;\n\t\t\t\tgoto err;\n\t\t\t}\n\n\t\t\taddr = &exynos_gem->dma_addr;\n\t\t\tbuf_info->obj[reg_type] = exynos_gem;\n\t\t} else {\n\t\t\tstruct drm_exynos_g2d_userptr g2d_userptr;\n\n\t\t\tif (copy_from_user(&g2d_userptr, (void __user *)handle,\n\t\t\t\tsizeof(struct drm_exynos_g2d_userptr))) {\n\t\t\t\tret = -EFAULT;\n\t\t\t\tgoto err;\n\t\t\t}\n\n\t\t\tif (!g2d_check_buf_desc_is_valid(g2d, buf_desc,\n\t\t\t\t\t\t\t reg_type,\n\t\t\t\t\t\t\t g2d_userptr.size)) {\n\t\t\t\tret = -EFAULT;\n\t\t\t\tgoto err;\n\t\t\t}\n\n\t\t\taddr = g2d_userptr_get_dma_addr(g2d,\n\t\t\t\t\t\t\tg2d_userptr.userptr,\n\t\t\t\t\t\t\tg2d_userptr.size,\n\t\t\t\t\t\t\tfile,\n\t\t\t\t\t\t\t&buf_info->obj[reg_type]);\n\t\t\tif (IS_ERR(addr)) {\n\t\t\t\tret = -EFAULT;\n\t\t\t\tgoto err;\n\t\t\t}\n\t\t}\n\n\t\tcmdlist->data[reg_pos + 1] = *addr;\n\t\tbuf_info->reg_types[i] = reg_type;\n\t}\n\n\treturn 0;\n\nerr:\n\tbuf_info->map_nr = i;\n\treturn ret;\n}\n\nstatic void g2d_unmap_cmdlist_gem(struct g2d_data *g2d,\n\t\t\t\t  struct g2d_cmdlist_node *node,\n\t\t\t\t  struct drm_file *filp)\n{\n\tstruct g2d_buf_info *buf_info = &node->buf_info;\n\tint i;\n\n\tfor (i = 0; i < buf_info->map_nr; i++) {\n\t\tstruct g2d_buf_desc *buf_desc;\n\t\tenum g2d_reg_type reg_type;\n\t\tvoid *obj;\n\n\t\treg_type = buf_info->reg_types[i];\n\n\t\tbuf_desc = &buf_info->descs[reg_type];\n\t\tobj = buf_info->obj[reg_type];\n\n\t\tif (buf_info->types[reg_type] == BUF_TYPE_GEM)\n\t\t\texynos_drm_gem_put(obj);\n\t\telse\n\t\t\tg2d_userptr_put_dma_addr(g2d, obj, false);\n\n\t\tbuf_info->reg_types[i] = REG_TYPE_NONE;\n\t\tbuf_info->obj[reg_type] = NULL;\n\t\tbuf_info->types[reg_type] = 0;\n\t\tmemset(buf_desc, 0x00, sizeof(*buf_desc));\n\t}\n\n\tbuf_info->map_nr = 0;\n}\n\nstatic void g2d_dma_start(struct g2d_data *g2d,\n\t\t\t  struct g2d_runqueue_node *runqueue_node)\n{\n\tstruct g2d_cmdlist_node *node =\n\t\t\t\tlist_first_entry(&runqueue_node->run_cmdlist,\n\t\t\t\t\t\tstruct g2d_cmdlist_node, list);\n\n\tset_bit(G2D_BIT_ENGINE_BUSY, &g2d->flags);\n\twritel_relaxed(node->dma_addr, g2d->regs + G2D_DMA_SFR_BASE_ADDR);\n\twritel_relaxed(G2D_DMA_START, g2d->regs + G2D_DMA_COMMAND);\n}\n\nstatic struct g2d_runqueue_node *g2d_get_runqueue_node(struct g2d_data *g2d)\n{\n\tstruct g2d_runqueue_node *runqueue_node;\n\n\tif (list_empty(&g2d->runqueue))\n\t\treturn NULL;\n\n\trunqueue_node = list_first_entry(&g2d->runqueue,\n\t\t\t\t\t struct g2d_runqueue_node, list);\n\tlist_del_init(&runqueue_node->list);\n\treturn runqueue_node;\n}\n\nstatic void g2d_free_runqueue_node(struct g2d_data *g2d,\n\t\t\t\t   struct g2d_runqueue_node *runqueue_node)\n{\n\tstruct g2d_cmdlist_node *node;\n\n\tmutex_lock(&g2d->cmdlist_mutex);\n\t \n\tlist_for_each_entry(node, &runqueue_node->run_cmdlist, list)\n\t\tg2d_unmap_cmdlist_gem(g2d, node, runqueue_node->filp);\n\tlist_splice_tail_init(&runqueue_node->run_cmdlist, &g2d->free_cmdlist);\n\tmutex_unlock(&g2d->cmdlist_mutex);\n\n\tkmem_cache_free(g2d->runqueue_slab, runqueue_node);\n}\n\n \nstatic void g2d_remove_runqueue_nodes(struct g2d_data *g2d, struct drm_file *file)\n{\n\tstruct g2d_runqueue_node *node, *n;\n\n\tif (list_empty(&g2d->runqueue))\n\t\treturn;\n\n\tlist_for_each_entry_safe(node, n, &g2d->runqueue, list) {\n\t\tif (file && node->filp != file)\n\t\t\tcontinue;\n\n\t\tlist_del_init(&node->list);\n\t\tg2d_free_runqueue_node(g2d, node);\n\t}\n}\n\nstatic void g2d_runqueue_worker(struct work_struct *work)\n{\n\tstruct g2d_data *g2d = container_of(work, struct g2d_data,\n\t\t\t\t\t    runqueue_work);\n\tstruct g2d_runqueue_node *runqueue_node;\n\n\t \n\tif (test_bit(G2D_BIT_ENGINE_BUSY, &g2d->flags))\n\t\treturn;\n\n\tmutex_lock(&g2d->runqueue_mutex);\n\n\trunqueue_node = g2d->runqueue_node;\n\tg2d->runqueue_node = NULL;\n\n\tif (runqueue_node) {\n\t\tpm_runtime_mark_last_busy(g2d->dev);\n\t\tpm_runtime_put_autosuspend(g2d->dev);\n\n\t\tcomplete(&runqueue_node->complete);\n\t\tif (runqueue_node->async)\n\t\t\tg2d_free_runqueue_node(g2d, runqueue_node);\n\t}\n\n\tif (!test_bit(G2D_BIT_SUSPEND_RUNQUEUE, &g2d->flags)) {\n\t\tg2d->runqueue_node = g2d_get_runqueue_node(g2d);\n\n\t\tif (g2d->runqueue_node) {\n\t\t\tint ret;\n\n\t\t\tret = pm_runtime_resume_and_get(g2d->dev);\n\t\t\tif (ret < 0) {\n\t\t\t\tdev_err(g2d->dev, \"failed to enable G2D device.\\n\");\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tg2d_dma_start(g2d, g2d->runqueue_node);\n\t\t}\n\t}\n\nout:\n\tmutex_unlock(&g2d->runqueue_mutex);\n}\n\nstatic void g2d_finish_event(struct g2d_data *g2d, u32 cmdlist_no)\n{\n\tstruct drm_device *drm_dev = g2d->drm_dev;\n\tstruct g2d_runqueue_node *runqueue_node = g2d->runqueue_node;\n\tstruct drm_exynos_pending_g2d_event *e;\n\tstruct timespec64 now;\n\n\tif (list_empty(&runqueue_node->event_list))\n\t\treturn;\n\n\te = list_first_entry(&runqueue_node->event_list,\n\t\t\t     struct drm_exynos_pending_g2d_event, base.link);\n\n\tktime_get_ts64(&now);\n\te->event.tv_sec = now.tv_sec;\n\te->event.tv_usec = now.tv_nsec / NSEC_PER_USEC;\n\te->event.cmdlist_no = cmdlist_no;\n\n\tdrm_send_event(drm_dev, &e->base);\n}\n\nstatic irqreturn_t g2d_irq_handler(int irq, void *dev_id)\n{\n\tstruct g2d_data *g2d = dev_id;\n\tu32 pending;\n\n\tpending = readl_relaxed(g2d->regs + G2D_INTC_PEND);\n\tif (pending)\n\t\twritel_relaxed(pending, g2d->regs + G2D_INTC_PEND);\n\n\tif (pending & G2D_INTP_GCMD_FIN) {\n\t\tu32 cmdlist_no = readl_relaxed(g2d->regs + G2D_DMA_STATUS);\n\n\t\tcmdlist_no = (cmdlist_no & G2D_DMA_LIST_DONE_COUNT) >>\n\t\t\t\t\t\tG2D_DMA_LIST_DONE_COUNT_OFFSET;\n\n\t\tg2d_finish_event(g2d, cmdlist_no);\n\n\t\twritel_relaxed(0, g2d->regs + G2D_DMA_HOLD_CMD);\n\t\tif (!(pending & G2D_INTP_ACMD_FIN)) {\n\t\t\twritel_relaxed(G2D_DMA_CONTINUE,\n\t\t\t\t\tg2d->regs + G2D_DMA_COMMAND);\n\t\t}\n\t}\n\n\tif (pending & G2D_INTP_ACMD_FIN) {\n\t\tclear_bit(G2D_BIT_ENGINE_BUSY, &g2d->flags);\n\t\tqueue_work(g2d->g2d_workq, &g2d->runqueue_work);\n\t}\n\n\treturn IRQ_HANDLED;\n}\n\n \nstatic void g2d_wait_finish(struct g2d_data *g2d, struct drm_file *file)\n{\n\tstruct device *dev = g2d->dev;\n\n\tstruct g2d_runqueue_node *runqueue_node = NULL;\n\tunsigned int tries = 10;\n\n\tmutex_lock(&g2d->runqueue_mutex);\n\n\t \n\tif (!g2d->runqueue_node)\n\t\tgoto out;\n\n\trunqueue_node = g2d->runqueue_node;\n\n\t \n\tif (file && runqueue_node->filp != file)\n\t\tgoto out;\n\n\tmutex_unlock(&g2d->runqueue_mutex);\n\n\t \n\twhile (tries-- && (g2d->runqueue_node == runqueue_node))\n\t\tmdelay(10);\n\n\tmutex_lock(&g2d->runqueue_mutex);\n\n\tif (g2d->runqueue_node != runqueue_node)\n\t\tgoto out;\n\n\tdev_err(dev, \"wait timed out, resetting engine...\\n\");\n\tg2d_hw_reset(g2d);\n\n\t \n\tpm_runtime_mark_last_busy(dev);\n\tpm_runtime_put_autosuspend(dev);\n\n\tcomplete(&runqueue_node->complete);\n\tif (runqueue_node->async)\n\t\tg2d_free_runqueue_node(g2d, runqueue_node);\n\nout:\n\tmutex_unlock(&g2d->runqueue_mutex);\n}\n\nstatic int g2d_check_reg_offset(struct g2d_data *g2d,\n\t\t\t\tstruct g2d_cmdlist_node *node,\n\t\t\t\tint nr, bool for_addr)\n{\n\tstruct g2d_cmdlist *cmdlist = node->cmdlist;\n\tint reg_offset;\n\tint index;\n\tint i;\n\n\tfor (i = 0; i < nr; i++) {\n\t\tstruct g2d_buf_info *buf_info = &node->buf_info;\n\t\tstruct g2d_buf_desc *buf_desc;\n\t\tenum g2d_reg_type reg_type;\n\t\tunsigned long value;\n\n\t\tindex = cmdlist->last - 2 * (i + 1);\n\n\t\treg_offset = cmdlist->data[index] & ~0xfffff000;\n\t\tif (reg_offset < G2D_VALID_START || reg_offset > G2D_VALID_END)\n\t\t\tgoto err;\n\t\tif (reg_offset % 4)\n\t\t\tgoto err;\n\n\t\tswitch (reg_offset) {\n\t\tcase G2D_SRC_BASE_ADDR:\n\t\tcase G2D_SRC_PLANE2_BASE_ADDR:\n\t\tcase G2D_DST_BASE_ADDR:\n\t\tcase G2D_DST_PLANE2_BASE_ADDR:\n\t\tcase G2D_PAT_BASE_ADDR:\n\t\tcase G2D_MSK_BASE_ADDR:\n\t\t\tif (!for_addr)\n\t\t\t\tgoto err;\n\n\t\t\treg_type = g2d_get_reg_type(g2d, reg_offset);\n\n\t\t\t \n\t\t\tif ((cmdlist->data[index] & ~0x7fffffff) >> 31) {\n\t\t\t\tbuf_info->types[reg_type] = BUF_TYPE_USERPTR;\n\t\t\t\tcmdlist->data[index] &= ~G2D_BUF_USERPTR;\n\t\t\t} else\n\t\t\t\tbuf_info->types[reg_type] = BUF_TYPE_GEM;\n\t\t\tbreak;\n\t\tcase G2D_SRC_STRIDE:\n\t\tcase G2D_DST_STRIDE:\n\t\t\tif (for_addr)\n\t\t\t\tgoto err;\n\n\t\t\treg_type = g2d_get_reg_type(g2d, reg_offset);\n\n\t\t\tbuf_desc = &buf_info->descs[reg_type];\n\t\t\tbuf_desc->stride = cmdlist->data[index + 1];\n\t\t\tbreak;\n\t\tcase G2D_SRC_COLOR_MODE:\n\t\tcase G2D_DST_COLOR_MODE:\n\t\t\tif (for_addr)\n\t\t\t\tgoto err;\n\n\t\t\treg_type = g2d_get_reg_type(g2d, reg_offset);\n\n\t\t\tbuf_desc = &buf_info->descs[reg_type];\n\t\t\tvalue = cmdlist->data[index + 1];\n\n\t\t\tbuf_desc->format = value & 0xf;\n\t\t\tbreak;\n\t\tcase G2D_SRC_LEFT_TOP:\n\t\tcase G2D_DST_LEFT_TOP:\n\t\t\tif (for_addr)\n\t\t\t\tgoto err;\n\n\t\t\treg_type = g2d_get_reg_type(g2d, reg_offset);\n\n\t\t\tbuf_desc = &buf_info->descs[reg_type];\n\t\t\tvalue = cmdlist->data[index + 1];\n\n\t\t\tbuf_desc->left_x = value & 0x1fff;\n\t\t\tbuf_desc->top_y = (value & 0x1fff0000) >> 16;\n\t\t\tbreak;\n\t\tcase G2D_SRC_RIGHT_BOTTOM:\n\t\tcase G2D_DST_RIGHT_BOTTOM:\n\t\t\tif (for_addr)\n\t\t\t\tgoto err;\n\n\t\t\treg_type = g2d_get_reg_type(g2d, reg_offset);\n\n\t\t\tbuf_desc = &buf_info->descs[reg_type];\n\t\t\tvalue = cmdlist->data[index + 1];\n\n\t\t\tbuf_desc->right_x = value & 0x1fff;\n\t\t\tbuf_desc->bottom_y = (value & 0x1fff0000) >> 16;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tif (for_addr)\n\t\t\t\tgoto err;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn 0;\n\nerr:\n\tdev_err(g2d->dev, \"Bad register offset: 0x%lx\\n\", cmdlist->data[index]);\n\treturn -EINVAL;\n}\n\n \nint exynos_g2d_get_ver_ioctl(struct drm_device *drm_dev, void *data,\n\t\t\t     struct drm_file *file)\n{\n\tstruct drm_exynos_g2d_get_ver *ver = data;\n\n\tver->major = G2D_HW_MAJOR_VER;\n\tver->minor = G2D_HW_MINOR_VER;\n\n\treturn 0;\n}\n\nint exynos_g2d_set_cmdlist_ioctl(struct drm_device *drm_dev, void *data,\n\t\t\t\t struct drm_file *file)\n{\n\tstruct drm_exynos_file_private *file_priv = file->driver_priv;\n\tstruct exynos_drm_private *priv = drm_dev->dev_private;\n\tstruct g2d_data *g2d = dev_get_drvdata(priv->g2d_dev);\n\tstruct drm_exynos_g2d_set_cmdlist *req = data;\n\tstruct drm_exynos_g2d_cmd *cmd;\n\tstruct drm_exynos_pending_g2d_event *e;\n\tstruct g2d_cmdlist_node *node;\n\tstruct g2d_cmdlist *cmdlist;\n\tint size;\n\tint ret;\n\n\tnode = g2d_get_cmdlist(g2d);\n\tif (!node)\n\t\treturn -ENOMEM;\n\n\t \n\tif (req->cmd_nr > G2D_CMDLIST_DATA_NUM ||\n\t    req->cmd_buf_nr > G2D_CMDLIST_DATA_NUM) {\n\t\tdev_err(g2d->dev, \"number of submitted G2D commands exceeds limit\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tnode->event = NULL;\n\n\tif (req->event_type != G2D_EVENT_NOT) {\n\t\te = kzalloc(sizeof(*node->event), GFP_KERNEL);\n\t\tif (!e) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto err;\n\t\t}\n\n\t\te->event.base.type = DRM_EXYNOS_G2D_EVENT;\n\t\te->event.base.length = sizeof(e->event);\n\t\te->event.user_data = req->user_data;\n\n\t\tret = drm_event_reserve_init(drm_dev, file, &e->base, &e->event.base);\n\t\tif (ret) {\n\t\t\tkfree(e);\n\t\t\tgoto err;\n\t\t}\n\n\t\tnode->event = e;\n\t}\n\n\tcmdlist = node->cmdlist;\n\n\tcmdlist->last = 0;\n\n\t \n\tcmdlist->data[cmdlist->last++] = G2D_SOFT_RESET;\n\tcmdlist->data[cmdlist->last++] = G2D_SFRCLEAR;\n\tcmdlist->data[cmdlist->last++] = G2D_SRC_BASE_ADDR;\n\tcmdlist->data[cmdlist->last++] = 0;\n\n\t \n\tif (node->event) {\n\t\tcmdlist->data[cmdlist->last++] = G2D_INTEN;\n\t\tcmdlist->data[cmdlist->last++] = G2D_INTEN_ACF | G2D_INTEN_GCF;\n\t\tcmdlist->data[cmdlist->last++] = G2D_DMA_HOLD_CMD;\n\t\tcmdlist->data[cmdlist->last++] = G2D_LIST_HOLD;\n\t} else {\n\t\tcmdlist->data[cmdlist->last++] = G2D_INTEN;\n\t\tcmdlist->data[cmdlist->last++] = G2D_INTEN_ACF;\n\t}\n\n\t \n\tsize = cmdlist->last + req->cmd_nr * 2 + req->cmd_buf_nr * 2 + 2;\n\tif (size > G2D_CMDLIST_DATA_NUM) {\n\t\tdev_err(g2d->dev, \"cmdlist size is too big\\n\");\n\t\tret = -EINVAL;\n\t\tgoto err_free_event;\n\t}\n\n\tcmd = (struct drm_exynos_g2d_cmd *)(unsigned long)req->cmd;\n\n\tif (copy_from_user(cmdlist->data + cmdlist->last,\n\t\t\t\t(void __user *)cmd,\n\t\t\t\tsizeof(*cmd) * req->cmd_nr)) {\n\t\tret = -EFAULT;\n\t\tgoto err_free_event;\n\t}\n\tcmdlist->last += req->cmd_nr * 2;\n\n\tret = g2d_check_reg_offset(g2d, node, req->cmd_nr, false);\n\tif (ret < 0)\n\t\tgoto err_free_event;\n\n\tnode->buf_info.map_nr = req->cmd_buf_nr;\n\tif (req->cmd_buf_nr) {\n\t\tstruct drm_exynos_g2d_cmd *cmd_buf;\n\n\t\tcmd_buf = (struct drm_exynos_g2d_cmd *)\n\t\t\t\t(unsigned long)req->cmd_buf;\n\n\t\tif (copy_from_user(cmdlist->data + cmdlist->last,\n\t\t\t\t\t(void __user *)cmd_buf,\n\t\t\t\t\tsizeof(*cmd_buf) * req->cmd_buf_nr)) {\n\t\t\tret = -EFAULT;\n\t\t\tgoto err_free_event;\n\t\t}\n\t\tcmdlist->last += req->cmd_buf_nr * 2;\n\n\t\tret = g2d_check_reg_offset(g2d, node, req->cmd_buf_nr, true);\n\t\tif (ret < 0)\n\t\t\tgoto err_free_event;\n\n\t\tret = g2d_map_cmdlist_gem(g2d, node, drm_dev, file);\n\t\tif (ret < 0)\n\t\t\tgoto err_unmap;\n\t}\n\n\tcmdlist->data[cmdlist->last++] = G2D_BITBLT_START;\n\tcmdlist->data[cmdlist->last++] = G2D_START_BITBLT;\n\n\t \n\tcmdlist->head = cmdlist->last / 2;\n\n\t \n\tcmdlist->data[cmdlist->last] = 0;\n\n\tg2d_add_cmdlist_to_inuse(file_priv, node);\n\n\treturn 0;\n\nerr_unmap:\n\tg2d_unmap_cmdlist_gem(g2d, node, file);\nerr_free_event:\n\tif (node->event)\n\t\tdrm_event_cancel_free(drm_dev, &node->event->base);\nerr:\n\tg2d_put_cmdlist(g2d, node);\n\treturn ret;\n}\n\nint exynos_g2d_exec_ioctl(struct drm_device *drm_dev, void *data,\n\t\t\t  struct drm_file *file)\n{\n\tstruct drm_exynos_file_private *file_priv = file->driver_priv;\n\tstruct exynos_drm_private *priv = drm_dev->dev_private;\n\tstruct g2d_data *g2d = dev_get_drvdata(priv->g2d_dev);\n\tstruct drm_exynos_g2d_exec *req = data;\n\tstruct g2d_runqueue_node *runqueue_node;\n\tstruct list_head *run_cmdlist;\n\tstruct list_head *event_list;\n\n\trunqueue_node = kmem_cache_alloc(g2d->runqueue_slab, GFP_KERNEL);\n\tif (!runqueue_node)\n\t\treturn -ENOMEM;\n\n\trun_cmdlist = &runqueue_node->run_cmdlist;\n\tevent_list = &runqueue_node->event_list;\n\tINIT_LIST_HEAD(run_cmdlist);\n\tINIT_LIST_HEAD(event_list);\n\tinit_completion(&runqueue_node->complete);\n\trunqueue_node->async = req->async;\n\n\tlist_splice_init(&file_priv->inuse_cmdlist, run_cmdlist);\n\tlist_splice_init(&file_priv->event_list, event_list);\n\n\tif (list_empty(run_cmdlist)) {\n\t\tdev_err(g2d->dev, \"there is no inuse cmdlist\\n\");\n\t\tkmem_cache_free(g2d->runqueue_slab, runqueue_node);\n\t\treturn -EPERM;\n\t}\n\n\tmutex_lock(&g2d->runqueue_mutex);\n\trunqueue_node->pid = current->pid;\n\trunqueue_node->filp = file;\n\tlist_add_tail(&runqueue_node->list, &g2d->runqueue);\n\tmutex_unlock(&g2d->runqueue_mutex);\n\n\t \n\tqueue_work(g2d->g2d_workq, &g2d->runqueue_work);\n\n\tif (req->async)\n\t\tgoto out;\n\n\twait_for_completion(&runqueue_node->complete);\n\tg2d_free_runqueue_node(g2d, runqueue_node);\n\nout:\n\treturn 0;\n}\n\nint g2d_open(struct drm_device *drm_dev, struct drm_file *file)\n{\n\tstruct drm_exynos_file_private *file_priv = file->driver_priv;\n\n\tINIT_LIST_HEAD(&file_priv->inuse_cmdlist);\n\tINIT_LIST_HEAD(&file_priv->event_list);\n\tINIT_LIST_HEAD(&file_priv->userptr_list);\n\n\treturn 0;\n}\n\nvoid g2d_close(struct drm_device *drm_dev, struct drm_file *file)\n{\n\tstruct drm_exynos_file_private *file_priv = file->driver_priv;\n\tstruct exynos_drm_private *priv = drm_dev->dev_private;\n\tstruct g2d_data *g2d;\n\tstruct g2d_cmdlist_node *node, *n;\n\n\tif (!priv->g2d_dev)\n\t\treturn;\n\n\tg2d = dev_get_drvdata(priv->g2d_dev);\n\n\t \n\tmutex_lock(&g2d->runqueue_mutex);\n\tg2d_remove_runqueue_nodes(g2d, file);\n\tmutex_unlock(&g2d->runqueue_mutex);\n\n\t \n\tg2d_wait_finish(g2d, file);\n\n\t \n\tmutex_lock(&g2d->cmdlist_mutex);\n\tlist_for_each_entry_safe(node, n, &file_priv->inuse_cmdlist, list) {\n\t\tg2d_unmap_cmdlist_gem(g2d, node, file);\n\t\tlist_move_tail(&node->list, &g2d->free_cmdlist);\n\t}\n\tmutex_unlock(&g2d->cmdlist_mutex);\n\n\t \n\tg2d_userptr_free_all(g2d, file);\n}\n\nstatic int g2d_bind(struct device *dev, struct device *master, void *data)\n{\n\tstruct g2d_data *g2d = dev_get_drvdata(dev);\n\tstruct drm_device *drm_dev = data;\n\tstruct exynos_drm_private *priv = drm_dev->dev_private;\n\tint ret;\n\n\tg2d->drm_dev = drm_dev;\n\n\t \n\tret = g2d_init_cmdlist(g2d);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"cmdlist init failed\\n\");\n\t\treturn ret;\n\t}\n\n\tret = exynos_drm_register_dma(drm_dev, dev, &g2d->dma_priv);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"failed to enable iommu.\\n\");\n\t\tg2d_fini_cmdlist(g2d);\n\t\treturn ret;\n\t}\n\tpriv->g2d_dev = dev;\n\n\tdev_info(dev, \"The Exynos G2D (ver %d.%d) successfully registered.\\n\",\n\t\t\tG2D_HW_MAJOR_VER, G2D_HW_MINOR_VER);\n\treturn 0;\n}\n\nstatic void g2d_unbind(struct device *dev, struct device *master, void *data)\n{\n\tstruct g2d_data *g2d = dev_get_drvdata(dev);\n\tstruct drm_device *drm_dev = data;\n\tstruct exynos_drm_private *priv = drm_dev->dev_private;\n\n\t \n\tset_bit(G2D_BIT_SUSPEND_RUNQUEUE, &g2d->flags);\n\tg2d_wait_finish(g2d, NULL);\n\tpriv->g2d_dev = NULL;\n\n\tcancel_work_sync(&g2d->runqueue_work);\n\texynos_drm_unregister_dma(g2d->drm_dev, dev, &g2d->dma_priv);\n}\n\nstatic const struct component_ops g2d_component_ops = {\n\t.bind\t= g2d_bind,\n\t.unbind = g2d_unbind,\n};\n\nstatic int g2d_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct g2d_data *g2d;\n\tint ret;\n\n\tg2d = devm_kzalloc(dev, sizeof(*g2d), GFP_KERNEL);\n\tif (!g2d)\n\t\treturn -ENOMEM;\n\n\tg2d->runqueue_slab = kmem_cache_create(\"g2d_runqueue_slab\",\n\t\t\tsizeof(struct g2d_runqueue_node), 0, 0, NULL);\n\tif (!g2d->runqueue_slab)\n\t\treturn -ENOMEM;\n\n\tg2d->dev = dev;\n\n\tg2d->g2d_workq = create_singlethread_workqueue(\"g2d\");\n\tif (!g2d->g2d_workq) {\n\t\tdev_err(dev, \"failed to create workqueue\\n\");\n\t\tret = -EINVAL;\n\t\tgoto err_destroy_slab;\n\t}\n\n\tINIT_WORK(&g2d->runqueue_work, g2d_runqueue_worker);\n\tINIT_LIST_HEAD(&g2d->free_cmdlist);\n\tINIT_LIST_HEAD(&g2d->runqueue);\n\n\tmutex_init(&g2d->cmdlist_mutex);\n\tmutex_init(&g2d->runqueue_mutex);\n\n\tg2d->gate_clk = devm_clk_get(dev, \"fimg2d\");\n\tif (IS_ERR(g2d->gate_clk)) {\n\t\tdev_err(dev, \"failed to get gate clock\\n\");\n\t\tret = PTR_ERR(g2d->gate_clk);\n\t\tgoto err_destroy_workqueue;\n\t}\n\n\tpm_runtime_use_autosuspend(dev);\n\tpm_runtime_set_autosuspend_delay(dev, 2000);\n\tpm_runtime_enable(dev);\n\tclear_bit(G2D_BIT_SUSPEND_RUNQUEUE, &g2d->flags);\n\tclear_bit(G2D_BIT_ENGINE_BUSY, &g2d->flags);\n\n\tg2d->regs = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(g2d->regs)) {\n\t\tret = PTR_ERR(g2d->regs);\n\t\tgoto err_put_clk;\n\t}\n\n\tg2d->irq = platform_get_irq(pdev, 0);\n\tif (g2d->irq < 0) {\n\t\tret = g2d->irq;\n\t\tgoto err_put_clk;\n\t}\n\n\tret = devm_request_irq(dev, g2d->irq, g2d_irq_handler, 0,\n\t\t\t\t\t\t\t\t\"drm_g2d\", g2d);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"irq request failed\\n\");\n\t\tgoto err_put_clk;\n\t}\n\n\tg2d->max_pool = MAX_POOL;\n\n\tplatform_set_drvdata(pdev, g2d);\n\n\tret = component_add(dev, &g2d_component_ops);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"failed to register drm g2d device\\n\");\n\t\tgoto err_put_clk;\n\t}\n\n\treturn 0;\n\nerr_put_clk:\n\tpm_runtime_disable(dev);\nerr_destroy_workqueue:\n\tdestroy_workqueue(g2d->g2d_workq);\nerr_destroy_slab:\n\tkmem_cache_destroy(g2d->runqueue_slab);\n\treturn ret;\n}\n\nstatic int g2d_remove(struct platform_device *pdev)\n{\n\tstruct g2d_data *g2d = platform_get_drvdata(pdev);\n\n\tcomponent_del(&pdev->dev, &g2d_component_ops);\n\n\t \n\tg2d_remove_runqueue_nodes(g2d, NULL);\n\n\tpm_runtime_dont_use_autosuspend(&pdev->dev);\n\tpm_runtime_disable(&pdev->dev);\n\n\tg2d_fini_cmdlist(g2d);\n\tdestroy_workqueue(g2d->g2d_workq);\n\tkmem_cache_destroy(g2d->runqueue_slab);\n\n\treturn 0;\n}\n\nstatic int g2d_suspend(struct device *dev)\n{\n\tstruct g2d_data *g2d = dev_get_drvdata(dev);\n\n\t \n\tset_bit(G2D_BIT_SUSPEND_RUNQUEUE, &g2d->flags);\n\tg2d_wait_finish(g2d, NULL);\n\tflush_work(&g2d->runqueue_work);\n\n\treturn 0;\n}\n\nstatic int g2d_resume(struct device *dev)\n{\n\tstruct g2d_data *g2d = dev_get_drvdata(dev);\n\n\tclear_bit(G2D_BIT_SUSPEND_RUNQUEUE, &g2d->flags);\n\tqueue_work(g2d->g2d_workq, &g2d->runqueue_work);\n\n\treturn 0;\n}\n\nstatic int g2d_runtime_suspend(struct device *dev)\n{\n\tstruct g2d_data *g2d = dev_get_drvdata(dev);\n\n\tclk_disable_unprepare(g2d->gate_clk);\n\n\treturn 0;\n}\n\nstatic int g2d_runtime_resume(struct device *dev)\n{\n\tstruct g2d_data *g2d = dev_get_drvdata(dev);\n\tint ret;\n\n\tret = clk_prepare_enable(g2d->gate_clk);\n\tif (ret < 0)\n\t\tdev_warn(dev, \"failed to enable clock.\\n\");\n\n\treturn ret;\n}\n\nstatic const struct dev_pm_ops g2d_pm_ops = {\n\tSYSTEM_SLEEP_PM_OPS(g2d_suspend, g2d_resume)\n\tRUNTIME_PM_OPS(g2d_runtime_suspend, g2d_runtime_resume, NULL)\n};\n\nstatic const struct of_device_id exynos_g2d_match[] = {\n\t{ .compatible = \"samsung,exynos5250-g2d\" },\n\t{ .compatible = \"samsung,exynos4212-g2d\" },\n\t{},\n};\nMODULE_DEVICE_TABLE(of, exynos_g2d_match);\n\nstruct platform_driver g2d_driver = {\n\t.probe\t\t= g2d_probe,\n\t.remove\t\t= g2d_remove,\n\t.driver\t\t= {\n\t\t.name\t= \"exynos-drm-g2d\",\n\t\t.owner\t= THIS_MODULE,\n\t\t.pm\t= pm_ptr(&g2d_pm_ops),\n\t\t.of_match_table = exynos_g2d_match,\n\t},\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}