{
  "module_name": "drm_color_mgmt.c",
  "hash_id": "3ce583929a3e3e356d05fd471d378279f78b0a2c3708b46b19056d94797e4ef8",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/drm_color_mgmt.c",
  "human_readable_source": " \n\n#include <linux/uaccess.h>\n\n#include <drm/drm_atomic.h>\n#include <drm/drm_color_mgmt.h>\n#include <drm/drm_crtc.h>\n#include <drm/drm_device.h>\n#include <drm/drm_drv.h>\n#include <drm/drm_print.h>\n\n#include \"drm_crtc_internal.h\"\n\n \n\n \nu64 drm_color_ctm_s31_32_to_qm_n(u64 user_input, u32 m, u32 n)\n{\n\tu64 mag = (user_input & ~BIT_ULL(63)) >> (32 - n);\n\tbool negative = !!(user_input & BIT_ULL(63));\n\ts64 val;\n\n\tWARN_ON(m > 32 || n > 32);\n\n\tval = clamp_val(mag, 0, negative ?\n\t\t\t\tBIT_ULL(n + m - 1) : BIT_ULL(n + m - 1) - 1);\n\n\treturn negative ? -val : val;\n}\nEXPORT_SYMBOL(drm_color_ctm_s31_32_to_qm_n);\n\n \nvoid drm_crtc_enable_color_mgmt(struct drm_crtc *crtc,\n\t\t\t\tuint degamma_lut_size,\n\t\t\t\tbool has_ctm,\n\t\t\t\tuint gamma_lut_size)\n{\n\tstruct drm_device *dev = crtc->dev;\n\tstruct drm_mode_config *config = &dev->mode_config;\n\n\tif (degamma_lut_size) {\n\t\tdrm_object_attach_property(&crtc->base,\n\t\t\t\t\t   config->degamma_lut_property, 0);\n\t\tdrm_object_attach_property(&crtc->base,\n\t\t\t\t\t   config->degamma_lut_size_property,\n\t\t\t\t\t   degamma_lut_size);\n\t}\n\n\tif (has_ctm)\n\t\tdrm_object_attach_property(&crtc->base,\n\t\t\t\t\t   config->ctm_property, 0);\n\n\tif (gamma_lut_size) {\n\t\tdrm_object_attach_property(&crtc->base,\n\t\t\t\t\t   config->gamma_lut_property, 0);\n\t\tdrm_object_attach_property(&crtc->base,\n\t\t\t\t\t   config->gamma_lut_size_property,\n\t\t\t\t\t   gamma_lut_size);\n\t}\n}\nEXPORT_SYMBOL(drm_crtc_enable_color_mgmt);\n\n \nint drm_mode_crtc_set_gamma_size(struct drm_crtc *crtc,\n\t\t\t\t int gamma_size)\n{\n\tuint16_t *r_base, *g_base, *b_base;\n\tint i;\n\n\tcrtc->gamma_size = gamma_size;\n\n\tcrtc->gamma_store = kcalloc(gamma_size, sizeof(uint16_t) * 3,\n\t\t\t\t    GFP_KERNEL);\n\tif (!crtc->gamma_store) {\n\t\tcrtc->gamma_size = 0;\n\t\treturn -ENOMEM;\n\t}\n\n\tr_base = crtc->gamma_store;\n\tg_base = r_base + gamma_size;\n\tb_base = g_base + gamma_size;\n\tfor (i = 0; i < gamma_size; i++) {\n\t\tr_base[i] = i << 8;\n\t\tg_base[i] = i << 8;\n\t\tb_base[i] = i << 8;\n\t}\n\n\n\treturn 0;\n}\nEXPORT_SYMBOL(drm_mode_crtc_set_gamma_size);\n\n \nstatic bool drm_crtc_supports_legacy_gamma(struct drm_crtc *crtc)\n{\n\tu32 gamma_id = crtc->dev->mode_config.gamma_lut_property->base.id;\n\tu32 degamma_id = crtc->dev->mode_config.degamma_lut_property->base.id;\n\n\tif (!crtc->gamma_size)\n\t\treturn false;\n\n\tif (crtc->funcs->gamma_set)\n\t\treturn true;\n\n\treturn !!(drm_mode_obj_find_prop_id(&crtc->base, gamma_id) ||\n\t\t  drm_mode_obj_find_prop_id(&crtc->base, degamma_id));\n}\n\n \nstatic int drm_crtc_legacy_gamma_set(struct drm_crtc *crtc,\n\t\t\t\t     u16 *red, u16 *green, u16 *blue,\n\t\t\t\t     u32 size,\n\t\t\t\t     struct drm_modeset_acquire_ctx *ctx)\n{\n\tstruct drm_device *dev = crtc->dev;\n\tstruct drm_atomic_state *state;\n\tstruct drm_crtc_state *crtc_state;\n\tstruct drm_property_blob *blob;\n\tstruct drm_color_lut *blob_data;\n\tu32 gamma_id = dev->mode_config.gamma_lut_property->base.id;\n\tu32 degamma_id = dev->mode_config.degamma_lut_property->base.id;\n\tbool use_gamma_lut;\n\tint i, ret = 0;\n\tbool replaced;\n\n\tif (crtc->funcs->gamma_set)\n\t\treturn crtc->funcs->gamma_set(crtc, red, green, blue, size, ctx);\n\n\tif (drm_mode_obj_find_prop_id(&crtc->base, gamma_id))\n\t\tuse_gamma_lut = true;\n\telse if (drm_mode_obj_find_prop_id(&crtc->base, degamma_id))\n\t\tuse_gamma_lut = false;\n\telse\n\t\treturn -ENODEV;\n\n\tstate = drm_atomic_state_alloc(crtc->dev);\n\tif (!state)\n\t\treturn -ENOMEM;\n\n\tblob = drm_property_create_blob(dev,\n\t\t\t\t\tsizeof(struct drm_color_lut) * size,\n\t\t\t\t\tNULL);\n\tif (IS_ERR(blob)) {\n\t\tret = PTR_ERR(blob);\n\t\tblob = NULL;\n\t\tgoto fail;\n\t}\n\n\t \n\tblob_data = blob->data;\n\tfor (i = 0; i < size; i++) {\n\t\tblob_data[i].red = red[i];\n\t\tblob_data[i].green = green[i];\n\t\tblob_data[i].blue = blue[i];\n\t}\n\n\tstate->acquire_ctx = ctx;\n\tcrtc_state = drm_atomic_get_crtc_state(state, crtc);\n\tif (IS_ERR(crtc_state)) {\n\t\tret = PTR_ERR(crtc_state);\n\t\tgoto fail;\n\t}\n\n\t \n\treplaced = drm_property_replace_blob(&crtc_state->degamma_lut,\n\t\t\t\t\t     use_gamma_lut ? NULL : blob);\n\treplaced |= drm_property_replace_blob(&crtc_state->ctm, NULL);\n\treplaced |= drm_property_replace_blob(&crtc_state->gamma_lut,\n\t\t\t\t\t      use_gamma_lut ? blob : NULL);\n\tcrtc_state->color_mgmt_changed |= replaced;\n\n\tret = drm_atomic_commit(state);\n\nfail:\n\tdrm_atomic_state_put(state);\n\tdrm_property_blob_put(blob);\n\treturn ret;\n}\n\n \nint drm_mode_gamma_set_ioctl(struct drm_device *dev,\n\t\t\t     void *data, struct drm_file *file_priv)\n{\n\tstruct drm_mode_crtc_lut *crtc_lut = data;\n\tstruct drm_crtc *crtc;\n\tvoid *r_base, *g_base, *b_base;\n\tint size;\n\tstruct drm_modeset_acquire_ctx ctx;\n\tint ret = 0;\n\n\tif (!drm_core_check_feature(dev, DRIVER_MODESET))\n\t\treturn -EOPNOTSUPP;\n\n\tcrtc = drm_crtc_find(dev, file_priv, crtc_lut->crtc_id);\n\tif (!crtc)\n\t\treturn -ENOENT;\n\n\tif (!drm_crtc_supports_legacy_gamma(crtc))\n\t\treturn -ENOSYS;\n\n\t \n\tif (crtc_lut->gamma_size != crtc->gamma_size)\n\t\treturn -EINVAL;\n\n\tDRM_MODESET_LOCK_ALL_BEGIN(dev, ctx, 0, ret);\n\n\tsize = crtc_lut->gamma_size * (sizeof(uint16_t));\n\tr_base = crtc->gamma_store;\n\tif (copy_from_user(r_base, (void __user *)(unsigned long)crtc_lut->red, size)) {\n\t\tret = -EFAULT;\n\t\tgoto out;\n\t}\n\n\tg_base = r_base + size;\n\tif (copy_from_user(g_base, (void __user *)(unsigned long)crtc_lut->green, size)) {\n\t\tret = -EFAULT;\n\t\tgoto out;\n\t}\n\n\tb_base = g_base + size;\n\tif (copy_from_user(b_base, (void __user *)(unsigned long)crtc_lut->blue, size)) {\n\t\tret = -EFAULT;\n\t\tgoto out;\n\t}\n\n\tret = drm_crtc_legacy_gamma_set(crtc, r_base, g_base, b_base,\n\t\t\t\t\tcrtc->gamma_size, &ctx);\n\nout:\n\tDRM_MODESET_LOCK_ALL_END(dev, ctx, ret);\n\treturn ret;\n\n}\n\n \nint drm_mode_gamma_get_ioctl(struct drm_device *dev,\n\t\t\t     void *data, struct drm_file *file_priv)\n{\n\tstruct drm_mode_crtc_lut *crtc_lut = data;\n\tstruct drm_crtc *crtc;\n\tvoid *r_base, *g_base, *b_base;\n\tint size;\n\tint ret = 0;\n\n\tif (!drm_core_check_feature(dev, DRIVER_MODESET))\n\t\treturn -EOPNOTSUPP;\n\n\tcrtc = drm_crtc_find(dev, file_priv, crtc_lut->crtc_id);\n\tif (!crtc)\n\t\treturn -ENOENT;\n\n\t \n\tif (crtc_lut->gamma_size != crtc->gamma_size)\n\t\treturn -EINVAL;\n\n\tdrm_modeset_lock(&crtc->mutex, NULL);\n\tsize = crtc_lut->gamma_size * (sizeof(uint16_t));\n\tr_base = crtc->gamma_store;\n\tif (copy_to_user((void __user *)(unsigned long)crtc_lut->red, r_base, size)) {\n\t\tret = -EFAULT;\n\t\tgoto out;\n\t}\n\n\tg_base = r_base + size;\n\tif (copy_to_user((void __user *)(unsigned long)crtc_lut->green, g_base, size)) {\n\t\tret = -EFAULT;\n\t\tgoto out;\n\t}\n\n\tb_base = g_base + size;\n\tif (copy_to_user((void __user *)(unsigned long)crtc_lut->blue, b_base, size)) {\n\t\tret = -EFAULT;\n\t\tgoto out;\n\t}\nout:\n\tdrm_modeset_unlock(&crtc->mutex);\n\treturn ret;\n}\n\nstatic const char * const color_encoding_name[] = {\n\t[DRM_COLOR_YCBCR_BT601] = \"ITU-R BT.601 YCbCr\",\n\t[DRM_COLOR_YCBCR_BT709] = \"ITU-R BT.709 YCbCr\",\n\t[DRM_COLOR_YCBCR_BT2020] = \"ITU-R BT.2020 YCbCr\",\n};\n\nstatic const char * const color_range_name[] = {\n\t[DRM_COLOR_YCBCR_FULL_RANGE] = \"YCbCr full range\",\n\t[DRM_COLOR_YCBCR_LIMITED_RANGE] = \"YCbCr limited range\",\n};\n\n \nconst char *drm_get_color_encoding_name(enum drm_color_encoding encoding)\n{\n\tif (WARN_ON(encoding >= ARRAY_SIZE(color_encoding_name)))\n\t\treturn \"unknown\";\n\n\treturn color_encoding_name[encoding];\n}\n\n \nconst char *drm_get_color_range_name(enum drm_color_range range)\n{\n\tif (WARN_ON(range >= ARRAY_SIZE(color_range_name)))\n\t\treturn \"unknown\";\n\n\treturn color_range_name[range];\n}\n\n \nint drm_plane_create_color_properties(struct drm_plane *plane,\n\t\t\t\t      u32 supported_encodings,\n\t\t\t\t      u32 supported_ranges,\n\t\t\t\t      enum drm_color_encoding default_encoding,\n\t\t\t\t      enum drm_color_range default_range)\n{\n\tstruct drm_device *dev = plane->dev;\n\tstruct drm_property *prop;\n\tstruct drm_prop_enum_list enum_list[max_t(int, DRM_COLOR_ENCODING_MAX,\n\t\t\t\t\t\t       DRM_COLOR_RANGE_MAX)];\n\tint i, len;\n\n\tif (WARN_ON(supported_encodings == 0 ||\n\t\t    (supported_encodings & -BIT(DRM_COLOR_ENCODING_MAX)) != 0 ||\n\t\t    (supported_encodings & BIT(default_encoding)) == 0))\n\t\treturn -EINVAL;\n\n\tif (WARN_ON(supported_ranges == 0 ||\n\t\t    (supported_ranges & -BIT(DRM_COLOR_RANGE_MAX)) != 0 ||\n\t\t    (supported_ranges & BIT(default_range)) == 0))\n\t\treturn -EINVAL;\n\n\tlen = 0;\n\tfor (i = 0; i < DRM_COLOR_ENCODING_MAX; i++) {\n\t\tif ((supported_encodings & BIT(i)) == 0)\n\t\t\tcontinue;\n\n\t\tenum_list[len].type = i;\n\t\tenum_list[len].name = color_encoding_name[i];\n\t\tlen++;\n\t}\n\n\tprop = drm_property_create_enum(dev, 0, \"COLOR_ENCODING\",\n\t\t\t\t\tenum_list, len);\n\tif (!prop)\n\t\treturn -ENOMEM;\n\tplane->color_encoding_property = prop;\n\tdrm_object_attach_property(&plane->base, prop, default_encoding);\n\tif (plane->state)\n\t\tplane->state->color_encoding = default_encoding;\n\n\tlen = 0;\n\tfor (i = 0; i < DRM_COLOR_RANGE_MAX; i++) {\n\t\tif ((supported_ranges & BIT(i)) == 0)\n\t\t\tcontinue;\n\n\t\tenum_list[len].type = i;\n\t\tenum_list[len].name = color_range_name[i];\n\t\tlen++;\n\t}\n\n\tprop = drm_property_create_enum(dev, 0, \"COLOR_RANGE\",\n\t\t\t\t\tenum_list, len);\n\tif (!prop)\n\t\treturn -ENOMEM;\n\tplane->color_range_property = prop;\n\tdrm_object_attach_property(&plane->base, prop, default_range);\n\tif (plane->state)\n\t\tplane->state->color_range = default_range;\n\n\treturn 0;\n}\nEXPORT_SYMBOL(drm_plane_create_color_properties);\n\n \nint drm_color_lut_check(const struct drm_property_blob *lut, u32 tests)\n{\n\tconst struct drm_color_lut *entry;\n\tint i;\n\n\tif (!lut || !tests)\n\t\treturn 0;\n\n\tentry = lut->data;\n\tfor (i = 0; i < drm_color_lut_size(lut); i++) {\n\t\tif (tests & DRM_COLOR_LUT_EQUAL_CHANNELS) {\n\t\t\tif (entry[i].red != entry[i].blue ||\n\t\t\t    entry[i].red != entry[i].green) {\n\t\t\t\tDRM_DEBUG_KMS(\"All LUT entries must have equal r/g/b\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t}\n\n\t\tif (i > 0 && tests & DRM_COLOR_LUT_NON_DECREASING) {\n\t\t\tif (entry[i].red < entry[i - 1].red ||\n\t\t\t    entry[i].green < entry[i - 1].green ||\n\t\t\t    entry[i].blue < entry[i - 1].blue) {\n\t\t\t\tDRM_DEBUG_KMS(\"LUT entries must never decrease.\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL(drm_color_lut_check);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}