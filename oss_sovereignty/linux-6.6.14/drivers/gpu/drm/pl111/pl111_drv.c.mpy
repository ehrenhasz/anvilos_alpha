{
  "module_name": "pl111_drv.c",
  "hash_id": "2d24e4f891c81bc47140d5bbda19ee99d0a31b977ff8a54e29af745d16dc3354",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/pl111/pl111_drv.c",
  "human_readable_source": "\n \n\n \n\n#include <linux/amba/bus.h>\n#include <linux/dma-buf.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/of_graph.h>\n#include <linux/of_reserved_mem.h>\n#include <linux/shmem_fs.h>\n#include <linux/slab.h>\n\n#include <drm/drm_atomic_helper.h>\n#include <drm/drm_bridge.h>\n#include <drm/drm_drv.h>\n#include <drm/drm_fbdev_dma.h>\n#include <drm/drm_fourcc.h>\n#include <drm/drm_gem_dma_helper.h>\n#include <drm/drm_gem_framebuffer_helper.h>\n#include <drm/drm_of.h>\n#include <drm/drm_panel.h>\n#include <drm/drm_probe_helper.h>\n#include <drm/drm_vblank.h>\n\n#include \"pl111_drm.h\"\n#include \"pl111_versatile.h\"\n#include \"pl111_nomadik.h\"\n\n#define DRIVER_DESC      \"DRM module for PL111\"\n\nstatic const struct drm_mode_config_funcs mode_config_funcs = {\n\t.fb_create = drm_gem_fb_create,\n\t.atomic_check = drm_atomic_helper_check,\n\t.atomic_commit = drm_atomic_helper_commit,\n};\n\nstatic int pl111_modeset_init(struct drm_device *dev)\n{\n\tstruct drm_mode_config *mode_config;\n\tstruct pl111_drm_dev_private *priv = dev->dev_private;\n\tstruct device_node *np = dev->dev->of_node;\n\tstruct device_node *remote;\n\tstruct drm_panel *panel = NULL;\n\tstruct drm_bridge *bridge = NULL;\n\tbool defer = false;\n\tint ret;\n\tint i;\n\n\tret = drmm_mode_config_init(dev);\n\tif (ret)\n\t\treturn ret;\n\n\tmode_config = &dev->mode_config;\n\tmode_config->funcs = &mode_config_funcs;\n\tmode_config->min_width = 1;\n\tmode_config->max_width = 1024;\n\tmode_config->min_height = 1;\n\tmode_config->max_height = 768;\n\n\ti = 0;\n\tfor_each_endpoint_of_node(np, remote) {\n\t\tstruct drm_panel *tmp_panel;\n\t\tstruct drm_bridge *tmp_bridge;\n\n\t\tdev_dbg(dev->dev, \"checking endpoint %d\\n\", i);\n\n\t\tret = drm_of_find_panel_or_bridge(dev->dev->of_node,\n\t\t\t\t\t\t  0, i,\n\t\t\t\t\t\t  &tmp_panel,\n\t\t\t\t\t\t  &tmp_bridge);\n\t\tif (ret) {\n\t\t\tif (ret == -EPROBE_DEFER) {\n\t\t\t\t \n\t\t\t\tdefer = true;\n\t\t\t} else if (ret != -ENODEV) {\n\t\t\t\t \n\t\t\t\tdev_err(dev->dev,\n\t\t\t\t\t\"endpoint %d returns %d\\n\", i, ret);\n\t\t\t}\n\t\t}\n\n\t\tif (tmp_panel) {\n\t\t\tdev_info(dev->dev,\n\t\t\t\t \"found panel on endpoint %d\\n\", i);\n\t\t\tpanel = tmp_panel;\n\t\t}\n\t\tif (tmp_bridge) {\n\t\t\tdev_info(dev->dev,\n\t\t\t\t \"found bridge on endpoint %d\\n\", i);\n\t\t\tbridge = tmp_bridge;\n\t\t}\n\n\t\ti++;\n\t}\n\n\t \n\tif ((!panel && !bridge) && defer)\n\t\treturn -EPROBE_DEFER;\n\n\tif (panel) {\n\t\tbridge = drm_panel_bridge_add_typed(panel,\n\t\t\t\t\t\t    DRM_MODE_CONNECTOR_Unknown);\n\t\tif (IS_ERR(bridge)) {\n\t\t\tret = PTR_ERR(bridge);\n\t\t\tgoto finish;\n\t\t}\n\t} else if (bridge) {\n\t\tdev_info(dev->dev, \"Using non-panel bridge\\n\");\n\t} else {\n\t\tdev_err(dev->dev, \"No bridge, exiting\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tpriv->bridge = bridge;\n\tif (panel) {\n\t\tpriv->panel = panel;\n\t\tpriv->connector = drm_panel_bridge_connector(bridge);\n\t}\n\n\tret = pl111_display_init(dev);\n\tif (ret != 0) {\n\t\tdev_err(dev->dev, \"Failed to init display\\n\");\n\t\tgoto out_bridge;\n\t}\n\n\tret = drm_simple_display_pipe_attach_bridge(&priv->pipe,\n\t\t\t\t\t\t    bridge);\n\tif (ret)\n\t\treturn ret;\n\n\tif (!priv->variant->broken_vblank) {\n\t\tret = drm_vblank_init(dev, 1);\n\t\tif (ret != 0) {\n\t\t\tdev_err(dev->dev, \"Failed to init vblank\\n\");\n\t\t\tgoto out_bridge;\n\t\t}\n\t}\n\n\tdrm_mode_config_reset(dev);\n\n\tdrm_kms_helper_poll_init(dev);\n\n\tgoto finish;\n\nout_bridge:\n\tif (panel)\n\t\tdrm_panel_bridge_remove(bridge);\nfinish:\n\treturn ret;\n}\n\nstatic struct drm_gem_object *\npl111_gem_import_sg_table(struct drm_device *dev,\n\t\t\t  struct dma_buf_attachment *attach,\n\t\t\t  struct sg_table *sgt)\n{\n\tstruct pl111_drm_dev_private *priv = dev->dev_private;\n\n\t \n\tif (priv->use_device_memory)\n\t\treturn ERR_PTR(-EINVAL);\n\n\treturn drm_gem_dma_prime_import_sg_table(dev, attach, sgt);\n}\n\nDEFINE_DRM_GEM_DMA_FOPS(drm_fops);\n\nstatic const struct drm_driver pl111_drm_driver = {\n\t.driver_features =\n\t\tDRIVER_MODESET | DRIVER_GEM | DRIVER_ATOMIC,\n\t.ioctls = NULL,\n\t.fops = &drm_fops,\n\t.name = \"pl111\",\n\t.desc = DRIVER_DESC,\n\t.date = \"20170317\",\n\t.major = 1,\n\t.minor = 0,\n\t.patchlevel = 0,\n\t.dumb_create = drm_gem_dma_dumb_create,\n\t.gem_prime_import_sg_table = pl111_gem_import_sg_table,\n\n#if defined(CONFIG_DEBUG_FS)\n\t.debugfs_init = pl111_debugfs_init,\n#endif\n};\n\nstatic int pl111_amba_probe(struct amba_device *amba_dev,\n\t\t\t    const struct amba_id *id)\n{\n\tstruct device *dev = &amba_dev->dev;\n\tstruct pl111_drm_dev_private *priv;\n\tconst struct pl111_variant_data *variant = id->data;\n\tstruct drm_device *drm;\n\tint ret;\n\n\tpriv = devm_kzalloc(dev, sizeof(*priv), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\n\tdrm = drm_dev_alloc(&pl111_drm_driver, dev);\n\tif (IS_ERR(drm))\n\t\treturn PTR_ERR(drm);\n\tamba_set_drvdata(amba_dev, drm);\n\tpriv->drm = drm;\n\tdrm->dev_private = priv;\n\tpriv->variant = variant;\n\n\tret = of_reserved_mem_device_init(dev);\n\tif (!ret) {\n\t\tdev_info(dev, \"using device-specific reserved memory\\n\");\n\t\tpriv->use_device_memory = true;\n\t}\n\n\tif (of_property_read_u32(dev->of_node, \"max-memory-bandwidth\",\n\t\t\t\t &priv->memory_bw)) {\n\t\tdev_info(dev, \"no max memory bandwidth specified, assume unlimited\\n\");\n\t\tpriv->memory_bw = 0;\n\t}\n\n\t \n\tif (variant->is_pl110 || variant->is_lcdc) {\n\t\tpriv->ienb = CLCD_PL110_IENB;\n\t\tpriv->ctrl = CLCD_PL110_CNTL;\n\t} else {\n\t\tpriv->ienb = CLCD_PL111_IENB;\n\t\tpriv->ctrl = CLCD_PL111_CNTL;\n\t}\n\n\tpriv->regs = devm_ioremap_resource(dev, &amba_dev->res);\n\tif (IS_ERR(priv->regs)) {\n\t\tdev_err(dev, \"%s failed mmio\\n\", __func__);\n\t\tret = PTR_ERR(priv->regs);\n\t\tgoto dev_put;\n\t}\n\n\t \n\tret = pl111_versatile_init(dev, priv);\n\tif (ret)\n\t\tgoto dev_put;\n\n\tpl111_nomadik_init(dev);\n\n\t \n\twritel(0, priv->regs + priv->ienb);\n\n\tret = devm_request_irq(dev, amba_dev->irq[0], pl111_irq, 0,\n\t\t\t       variant->name, priv);\n\tif (ret != 0) {\n\t\tdev_err(dev, \"%s failed irq %d\\n\", __func__, ret);\n\t\treturn ret;\n\t}\n\n\tret = pl111_modeset_init(drm);\n\tif (ret != 0)\n\t\tgoto dev_put;\n\n\tret = drm_dev_register(drm, 0);\n\tif (ret < 0)\n\t\tgoto dev_put;\n\n\tdrm_fbdev_dma_setup(drm, priv->variant->fb_depth);\n\n\treturn 0;\n\ndev_put:\n\tdrm_dev_put(drm);\n\tof_reserved_mem_device_release(dev);\n\n\treturn ret;\n}\n\nstatic void pl111_amba_remove(struct amba_device *amba_dev)\n{\n\tstruct device *dev = &amba_dev->dev;\n\tstruct drm_device *drm = amba_get_drvdata(amba_dev);\n\tstruct pl111_drm_dev_private *priv = drm->dev_private;\n\n\tdrm_dev_unregister(drm);\n\tdrm_atomic_helper_shutdown(drm);\n\tif (priv->panel)\n\t\tdrm_panel_bridge_remove(priv->bridge);\n\tdrm_dev_put(drm);\n\tof_reserved_mem_device_release(dev);\n}\n\nstatic void pl111_amba_shutdown(struct amba_device *amba_dev)\n{\n\tdrm_atomic_helper_shutdown(amba_get_drvdata(amba_dev));\n}\n\n \nstatic const u32 pl110_pixel_formats[] = {\n\tDRM_FORMAT_ABGR8888,\n\tDRM_FORMAT_XBGR8888,\n\tDRM_FORMAT_ARGB8888,\n\tDRM_FORMAT_XRGB8888,\n\tDRM_FORMAT_ABGR1555,\n\tDRM_FORMAT_XBGR1555,\n\tDRM_FORMAT_ARGB1555,\n\tDRM_FORMAT_XRGB1555,\n};\n\nstatic const struct pl111_variant_data pl110_variant = {\n\t.name = \"PL110\",\n\t.is_pl110 = true,\n\t.formats = pl110_pixel_formats,\n\t.nformats = ARRAY_SIZE(pl110_pixel_formats),\n\t.fb_depth = 16,\n};\n\n \nstatic const u32 pl111_pixel_formats[] = {\n\tDRM_FORMAT_ABGR8888,\n\tDRM_FORMAT_XBGR8888,\n\tDRM_FORMAT_ARGB8888,\n\tDRM_FORMAT_XRGB8888,\n\tDRM_FORMAT_BGR565,\n\tDRM_FORMAT_RGB565,\n\tDRM_FORMAT_ABGR1555,\n\tDRM_FORMAT_XBGR1555,\n\tDRM_FORMAT_ARGB1555,\n\tDRM_FORMAT_XRGB1555,\n\tDRM_FORMAT_ABGR4444,\n\tDRM_FORMAT_XBGR4444,\n\tDRM_FORMAT_ARGB4444,\n\tDRM_FORMAT_XRGB4444,\n};\n\nstatic const struct pl111_variant_data pl111_variant = {\n\t.name = \"PL111\",\n\t.formats = pl111_pixel_formats,\n\t.nformats = ARRAY_SIZE(pl111_pixel_formats),\n\t.fb_depth = 32,\n};\n\nstatic const u32 pl110_nomadik_pixel_formats[] = {\n\tDRM_FORMAT_RGB888,\n\tDRM_FORMAT_BGR888,\n\tDRM_FORMAT_ABGR8888,\n\tDRM_FORMAT_XBGR8888,\n\tDRM_FORMAT_ARGB8888,\n\tDRM_FORMAT_XRGB8888,\n\tDRM_FORMAT_BGR565,\n\tDRM_FORMAT_RGB565,\n\tDRM_FORMAT_ABGR1555,\n\tDRM_FORMAT_XBGR1555,\n\tDRM_FORMAT_ARGB1555,\n\tDRM_FORMAT_XRGB1555,\n\tDRM_FORMAT_ABGR4444,\n\tDRM_FORMAT_XBGR4444,\n\tDRM_FORMAT_ARGB4444,\n\tDRM_FORMAT_XRGB4444,\n};\n\nstatic const struct pl111_variant_data pl110_nomadik_variant = {\n\t.name = \"LCDC (PL110 Nomadik)\",\n\t.formats = pl110_nomadik_pixel_formats,\n\t.nformats = ARRAY_SIZE(pl110_nomadik_pixel_formats),\n\t.is_lcdc = true,\n\t.st_bitmux_control = true,\n\t.broken_vblank = true,\n\t.fb_depth = 16,\n};\n\nstatic const struct amba_id pl111_id_table[] = {\n\t{\n\t\t.id = 0x00041110,\n\t\t.mask = 0x000fffff,\n\t\t.data = (void *)&pl110_variant,\n\t},\n\t{\n\t\t.id = 0x00180110,\n\t\t.mask = 0x00fffffe,\n\t\t.data = (void *)&pl110_nomadik_variant,\n\t},\n\t{\n\t\t.id = 0x00041111,\n\t\t.mask = 0x000fffff,\n\t\t.data = (void *)&pl111_variant,\n\t},\n\t{0, 0},\n};\nMODULE_DEVICE_TABLE(amba, pl111_id_table);\n\nstatic struct amba_driver pl111_amba_driver __maybe_unused = {\n\t.drv = {\n\t\t.name = \"drm-clcd-pl111\",\n\t},\n\t.probe = pl111_amba_probe,\n\t.remove = pl111_amba_remove,\n\t.shutdown = pl111_amba_shutdown,\n\t.id_table = pl111_id_table,\n};\n\n#ifdef CONFIG_ARM_AMBA\nmodule_amba_driver(pl111_amba_driver);\n#endif\n\nMODULE_DESCRIPTION(DRIVER_DESC);\nMODULE_AUTHOR(\"ARM Ltd.\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}