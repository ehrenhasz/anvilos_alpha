{
  "module_name": "pl111_display.c",
  "hash_id": "c2ea7506d5946d613d70472c9d336728ffac4469b31654d38e3e655425f24c40",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/pl111/pl111_display.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/delay.h>\n#include <linux/dma-buf.h>\n#include <linux/media-bus-format.h>\n#include <linux/of_graph.h>\n\n#include <drm/drm_fb_dma_helper.h>\n#include <drm/drm_fourcc.h>\n#include <drm/drm_framebuffer.h>\n#include <drm/drm_gem_atomic_helper.h>\n#include <drm/drm_gem_dma_helper.h>\n#include <drm/drm_vblank.h>\n\n#include \"pl111_drm.h\"\n\nirqreturn_t pl111_irq(int irq, void *data)\n{\n\tstruct pl111_drm_dev_private *priv = data;\n\tu32 irq_stat;\n\tirqreturn_t status = IRQ_NONE;\n\n\tirq_stat = readl(priv->regs + CLCD_PL111_MIS);\n\n\tif (!irq_stat)\n\t\treturn IRQ_NONE;\n\n\tif (irq_stat & CLCD_IRQ_NEXTBASE_UPDATE) {\n\t\tdrm_crtc_handle_vblank(&priv->pipe.crtc);\n\n\t\tstatus = IRQ_HANDLED;\n\t}\n\n\t \n\twritel(irq_stat, priv->regs + CLCD_PL111_ICR);\n\n\treturn status;\n}\n\nstatic enum drm_mode_status\npl111_mode_valid(struct drm_simple_display_pipe *pipe,\n\t\t const struct drm_display_mode *mode)\n{\n\tstruct drm_device *drm = pipe->crtc.dev;\n\tstruct pl111_drm_dev_private *priv = drm->dev_private;\n\tu32 cpp = DIV_ROUND_UP(priv->variant->fb_depth, 8);\n\tu64 bw;\n\n\t \n\tbw = mode->clock * 1000ULL;  \n\tbw = bw * mode->hdisplay * mode->vdisplay * cpp;\n\tbw = div_u64(bw, mode->htotal * mode->vtotal);\n\n\t \n\tif (priv->memory_bw && (bw > priv->memory_bw)) {\n\t\tDRM_DEBUG_KMS(\"%d x %d @ %d Hz, %d cpp, bw %llu too fast\\n\",\n\t\t\t      mode->hdisplay, mode->vdisplay,\n\t\t\t      mode->clock * 1000, cpp, bw);\n\n\t\treturn MODE_BAD;\n\t}\n\tDRM_DEBUG_KMS(\"%d x %d @ %d Hz, %d cpp, bw %llu bytes/s OK\\n\",\n\t\t      mode->hdisplay, mode->vdisplay,\n\t\t      mode->clock * 1000, cpp, bw);\n\n\treturn MODE_OK;\n}\n\nstatic int pl111_display_check(struct drm_simple_display_pipe *pipe,\n\t\t\t       struct drm_plane_state *pstate,\n\t\t\t       struct drm_crtc_state *cstate)\n{\n\tconst struct drm_display_mode *mode = &cstate->mode;\n\tstruct drm_framebuffer *old_fb = pipe->plane.state->fb;\n\tstruct drm_framebuffer *fb = pstate->fb;\n\n\tif (mode->hdisplay % 16)\n\t\treturn -EINVAL;\n\n\tif (fb) {\n\t\tu32 offset = drm_fb_dma_get_gem_addr(fb, pstate, 0);\n\n\t\t \n\t\tif (offset & 3)\n\t\t\treturn -EINVAL;\n\n\t\t \n\t\tif (fb->pitches[0] != mode->hdisplay * fb->format->cpp[0])\n\t\t\treturn -EINVAL;\n\n\t\t \n\t\tif (old_fb && old_fb->format != fb->format)\n\t\t\tcstate->mode_changed = true;\n\t}\n\n\treturn 0;\n}\n\nstatic void pl111_display_enable(struct drm_simple_display_pipe *pipe,\n\t\t\t\t struct drm_crtc_state *cstate,\n\t\t\t\t struct drm_plane_state *plane_state)\n{\n\tstruct drm_crtc *crtc = &pipe->crtc;\n\tstruct drm_plane *plane = &pipe->plane;\n\tstruct drm_device *drm = crtc->dev;\n\tstruct pl111_drm_dev_private *priv = drm->dev_private;\n\tconst struct drm_display_mode *mode = &cstate->mode;\n\tstruct drm_framebuffer *fb = plane->state->fb;\n\tstruct drm_connector *connector = priv->connector;\n\tstruct drm_bridge *bridge = priv->bridge;\n\tbool grayscale = false;\n\tu32 cntl;\n\tu32 ppl, hsw, hfp, hbp;\n\tu32 lpp, vsw, vfp, vbp;\n\tu32 cpl, tim2;\n\tint ret;\n\n\tret = clk_set_rate(priv->clk, mode->clock * 1000);\n\tif (ret) {\n\t\tdev_err(drm->dev,\n\t\t\t\"Failed to set pixel clock rate to %d: %d\\n\",\n\t\t\tmode->clock * 1000, ret);\n\t}\n\n\tclk_prepare_enable(priv->clk);\n\n\tppl = (mode->hdisplay / 16) - 1;\n\thsw = mode->hsync_end - mode->hsync_start - 1;\n\thfp = mode->hsync_start - mode->hdisplay - 1;\n\thbp = mode->htotal - mode->hsync_end - 1;\n\n\tlpp = mode->vdisplay - 1;\n\tvsw = mode->vsync_end - mode->vsync_start - 1;\n\tvfp = mode->vsync_start - mode->vdisplay;\n\tvbp = mode->vtotal - mode->vsync_end;\n\n\tcpl = mode->hdisplay - 1;\n\n\twritel((ppl << 2) |\n\t       (hsw << 8) |\n\t       (hfp << 16) |\n\t       (hbp << 24),\n\t       priv->regs + CLCD_TIM0);\n\twritel(lpp |\n\t       (vsw << 10) |\n\t       (vfp << 16) |\n\t       (vbp << 24),\n\t       priv->regs + CLCD_TIM1);\n\n\tspin_lock(&priv->tim2_lock);\n\n\ttim2 = readl(priv->regs + CLCD_TIM2);\n\ttim2 &= (TIM2_BCD | TIM2_PCD_LO_MASK | TIM2_PCD_HI_MASK);\n\n\tif (priv->variant->broken_clockdivider)\n\t\ttim2 |= TIM2_BCD;\n\n\tif (mode->flags & DRM_MODE_FLAG_NHSYNC)\n\t\ttim2 |= TIM2_IHS;\n\n\tif (mode->flags & DRM_MODE_FLAG_NVSYNC)\n\t\ttim2 |= TIM2_IVS;\n\n\tif (connector) {\n\t\tif (connector->display_info.bus_flags & DRM_BUS_FLAG_DE_LOW)\n\t\t\ttim2 |= TIM2_IOE;\n\n\t\tif (connector->display_info.bus_flags &\n\t\t    DRM_BUS_FLAG_PIXDATA_DRIVE_NEGEDGE)\n\t\t\ttim2 |= TIM2_IPC;\n\n\t\tif (connector->display_info.num_bus_formats == 1 &&\n\t\t    connector->display_info.bus_formats[0] ==\n\t\t    MEDIA_BUS_FMT_Y8_1X8)\n\t\t\tgrayscale = true;\n\n\t\t \n\t\tif (grayscale)\n\t\t\ttim2 |= TIM2_ACB_MASK;\n\t}\n\n\tif (bridge) {\n\t\tconst struct drm_bridge_timings *btimings = bridge->timings;\n\n\t\t \n\t\tif (btimings && btimings->setup_time_ps >= 3000)\n\t\t\ttim2 ^= TIM2_IPC;\n\t}\n\n\ttim2 |= cpl << 16;\n\twritel(tim2, priv->regs + CLCD_TIM2);\n\tspin_unlock(&priv->tim2_lock);\n\n\twritel(0, priv->regs + CLCD_TIM3);\n\n\t \n\tif (grayscale)\n\t\tcntl = CNTL_LCDEN | CNTL_LCDMONO8;\n\telse\n\t\t \n\t\tcntl = CNTL_LCDEN | CNTL_LCDTFT | CNTL_LCDVCOMP(1);\n\n\t \n\tif (priv->variant->st_bitmux_control)\n\t\tcntl |= CNTL_ST_CDWID_24;\n\n\t \n\tswitch (fb->format->format) {\n\tcase DRM_FORMAT_BGR888:\n\t\t \n\t\tif (priv->variant->st_bitmux_control)\n\t\t\tcntl |= CNTL_ST_LCDBPP24_PACKED | CNTL_BGR;\n\t\tbreak;\n\tcase DRM_FORMAT_RGB888:\n\t\t \n\t\tif (priv->variant->st_bitmux_control)\n\t\t\tcntl |= CNTL_ST_LCDBPP24_PACKED;\n\t\tbreak;\n\tcase DRM_FORMAT_ABGR8888:\n\tcase DRM_FORMAT_XBGR8888:\n\t\tif (priv->variant->st_bitmux_control)\n\t\t\tcntl |= CNTL_LCDBPP24 | CNTL_BGR;\n\t\telse\n\t\t\tcntl |= CNTL_LCDBPP24;\n\t\tbreak;\n\tcase DRM_FORMAT_ARGB8888:\n\tcase DRM_FORMAT_XRGB8888:\n\t\tif (priv->variant->st_bitmux_control)\n\t\t\tcntl |= CNTL_LCDBPP24;\n\t\telse\n\t\t\tcntl |= CNTL_LCDBPP24 | CNTL_BGR;\n\t\tbreak;\n\tcase DRM_FORMAT_BGR565:\n\t\tif (priv->variant->is_pl110)\n\t\t\tcntl |= CNTL_LCDBPP16;\n\t\telse if (priv->variant->st_bitmux_control)\n\t\t\tcntl |= CNTL_LCDBPP16 | CNTL_ST_1XBPP_565 | CNTL_BGR;\n\t\telse\n\t\t\tcntl |= CNTL_LCDBPP16_565;\n\t\tbreak;\n\tcase DRM_FORMAT_RGB565:\n\t\tif (priv->variant->is_pl110)\n\t\t\tcntl |= CNTL_LCDBPP16 | CNTL_BGR;\n\t\telse if (priv->variant->st_bitmux_control)\n\t\t\tcntl |= CNTL_LCDBPP16 | CNTL_ST_1XBPP_565;\n\t\telse\n\t\t\tcntl |= CNTL_LCDBPP16_565 | CNTL_BGR;\n\t\tbreak;\n\tcase DRM_FORMAT_ABGR1555:\n\tcase DRM_FORMAT_XBGR1555:\n\t\tcntl |= CNTL_LCDBPP16;\n\t\tif (priv->variant->st_bitmux_control)\n\t\t\tcntl |= CNTL_ST_1XBPP_5551 | CNTL_BGR;\n\t\tbreak;\n\tcase DRM_FORMAT_ARGB1555:\n\tcase DRM_FORMAT_XRGB1555:\n\t\tcntl |= CNTL_LCDBPP16;\n\t\tif (priv->variant->st_bitmux_control)\n\t\t\tcntl |= CNTL_ST_1XBPP_5551;\n\t\telse\n\t\t\tcntl |= CNTL_BGR;\n\t\tbreak;\n\tcase DRM_FORMAT_ABGR4444:\n\tcase DRM_FORMAT_XBGR4444:\n\t\tcntl |= CNTL_LCDBPP16_444;\n\t\tif (priv->variant->st_bitmux_control)\n\t\t\tcntl |= CNTL_ST_1XBPP_444 | CNTL_BGR;\n\t\tbreak;\n\tcase DRM_FORMAT_ARGB4444:\n\tcase DRM_FORMAT_XRGB4444:\n\t\tcntl |= CNTL_LCDBPP16_444;\n\t\tif (priv->variant->st_bitmux_control)\n\t\t\tcntl |= CNTL_ST_1XBPP_444;\n\t\telse\n\t\t\tcntl |= CNTL_BGR;\n\t\tbreak;\n\tdefault:\n\t\tWARN_ONCE(true, \"Unknown FB format 0x%08x\\n\",\n\t\t\t  fb->format->format);\n\t\tbreak;\n\t}\n\n\t \n\tif (priv->variant->external_bgr)\n\t\tcntl &= ~CNTL_BGR;\n\n\t \n\twritel(cntl, priv->regs + priv->ctrl);\n\n\t \n\tmsleep(20);\n\n\tif (priv->variant_display_enable)\n\t\tpriv->variant_display_enable(drm, fb->format->format);\n\n\t \n\tcntl |= CNTL_LCDPWR;\n\twritel(cntl, priv->regs + priv->ctrl);\n\n\tif (!priv->variant->broken_vblank)\n\t\tdrm_crtc_vblank_on(crtc);\n}\n\nstatic void pl111_display_disable(struct drm_simple_display_pipe *pipe)\n{\n\tstruct drm_crtc *crtc = &pipe->crtc;\n\tstruct drm_device *drm = crtc->dev;\n\tstruct pl111_drm_dev_private *priv = drm->dev_private;\n\tu32 cntl;\n\n\tif (!priv->variant->broken_vblank)\n\t\tdrm_crtc_vblank_off(crtc);\n\n\t \n\tcntl = readl(priv->regs + priv->ctrl);\n\tif (cntl & CNTL_LCDPWR) {\n\t\tcntl &= ~CNTL_LCDPWR;\n\t\twritel(cntl, priv->regs + priv->ctrl);\n\t}\n\n\t \n\tmsleep(20);\n\n\tif (priv->variant_display_disable)\n\t\tpriv->variant_display_disable(drm);\n\n\t \n\twritel(0, priv->regs + priv->ctrl);\n\n\tclk_disable_unprepare(priv->clk);\n}\n\nstatic void pl111_display_update(struct drm_simple_display_pipe *pipe,\n\t\t\t\t struct drm_plane_state *old_pstate)\n{\n\tstruct drm_crtc *crtc = &pipe->crtc;\n\tstruct drm_device *drm = crtc->dev;\n\tstruct pl111_drm_dev_private *priv = drm->dev_private;\n\tstruct drm_pending_vblank_event *event = crtc->state->event;\n\tstruct drm_plane *plane = &pipe->plane;\n\tstruct drm_plane_state *pstate = plane->state;\n\tstruct drm_framebuffer *fb = pstate->fb;\n\n\tif (fb) {\n\t\tu32 addr = drm_fb_dma_get_gem_addr(fb, pstate, 0);\n\n\t\twritel(addr, priv->regs + CLCD_UBAS);\n\t}\n\n\tif (event) {\n\t\tcrtc->state->event = NULL;\n\n\t\tspin_lock_irq(&crtc->dev->event_lock);\n\t\tif (crtc->state->active && drm_crtc_vblank_get(crtc) == 0)\n\t\t\tdrm_crtc_arm_vblank_event(crtc, event);\n\t\telse\n\t\t\tdrm_crtc_send_vblank_event(crtc, event);\n\t\tspin_unlock_irq(&crtc->dev->event_lock);\n\t}\n}\n\nstatic int pl111_display_enable_vblank(struct drm_simple_display_pipe *pipe)\n{\n\tstruct drm_crtc *crtc = &pipe->crtc;\n\tstruct drm_device *drm = crtc->dev;\n\tstruct pl111_drm_dev_private *priv = drm->dev_private;\n\n\twritel(CLCD_IRQ_NEXTBASE_UPDATE, priv->regs + priv->ienb);\n\n\treturn 0;\n}\n\nstatic void pl111_display_disable_vblank(struct drm_simple_display_pipe *pipe)\n{\n\tstruct drm_crtc *crtc = &pipe->crtc;\n\tstruct drm_device *drm = crtc->dev;\n\tstruct pl111_drm_dev_private *priv = drm->dev_private;\n\n\twritel(0, priv->regs + priv->ienb);\n}\n\nstatic struct drm_simple_display_pipe_funcs pl111_display_funcs = {\n\t.mode_valid = pl111_mode_valid,\n\t.check = pl111_display_check,\n\t.enable = pl111_display_enable,\n\t.disable = pl111_display_disable,\n\t.update = pl111_display_update,\n};\n\nstatic int pl111_clk_div_choose_div(struct clk_hw *hw, unsigned long rate,\n\t\t\t\t    unsigned long *prate, bool set_parent)\n{\n\tint best_div = 1, div;\n\tstruct clk_hw *parent = clk_hw_get_parent(hw);\n\tunsigned long best_prate = 0;\n\tunsigned long best_diff = ~0ul;\n\tint max_div = (1 << (TIM2_PCD_LO_BITS + TIM2_PCD_HI_BITS)) - 1;\n\n\tfor (div = 1; div < max_div; div++) {\n\t\tunsigned long this_prate, div_rate, diff;\n\n\t\tif (set_parent)\n\t\t\tthis_prate = clk_hw_round_rate(parent, rate * div);\n\t\telse\n\t\t\tthis_prate = *prate;\n\t\tdiv_rate = DIV_ROUND_UP_ULL(this_prate, div);\n\t\tdiff = abs(rate - div_rate);\n\n\t\tif (diff < best_diff) {\n\t\t\tbest_div = div;\n\t\t\tbest_diff = diff;\n\t\t\tbest_prate = this_prate;\n\t\t}\n\t}\n\n\t*prate = best_prate;\n\treturn best_div;\n}\n\nstatic long pl111_clk_div_round_rate(struct clk_hw *hw, unsigned long rate,\n\t\t\t\t     unsigned long *prate)\n{\n\tint div = pl111_clk_div_choose_div(hw, rate, prate, true);\n\n\treturn DIV_ROUND_UP_ULL(*prate, div);\n}\n\nstatic unsigned long pl111_clk_div_recalc_rate(struct clk_hw *hw,\n\t\t\t\t\t       unsigned long prate)\n{\n\tstruct pl111_drm_dev_private *priv =\n\t\tcontainer_of(hw, struct pl111_drm_dev_private, clk_div);\n\tu32 tim2 = readl(priv->regs + CLCD_TIM2);\n\tint div;\n\n\tif (tim2 & TIM2_BCD)\n\t\treturn prate;\n\n\tdiv = tim2 & TIM2_PCD_LO_MASK;\n\tdiv |= (tim2 & TIM2_PCD_HI_MASK) >>\n\t\t(TIM2_PCD_HI_SHIFT - TIM2_PCD_LO_BITS);\n\tdiv += 2;\n\n\treturn DIV_ROUND_UP_ULL(prate, div);\n}\n\nstatic int pl111_clk_div_set_rate(struct clk_hw *hw, unsigned long rate,\n\t\t\t\t  unsigned long prate)\n{\n\tstruct pl111_drm_dev_private *priv =\n\t\tcontainer_of(hw, struct pl111_drm_dev_private, clk_div);\n\tint div = pl111_clk_div_choose_div(hw, rate, &prate, false);\n\tu32 tim2;\n\n\tspin_lock(&priv->tim2_lock);\n\ttim2 = readl(priv->regs + CLCD_TIM2);\n\ttim2 &= ~(TIM2_BCD | TIM2_PCD_LO_MASK | TIM2_PCD_HI_MASK);\n\n\tif (div == 1) {\n\t\ttim2 |= TIM2_BCD;\n\t} else {\n\t\tdiv -= 2;\n\t\ttim2 |= div & TIM2_PCD_LO_MASK;\n\t\ttim2 |= (div >> TIM2_PCD_LO_BITS) << TIM2_PCD_HI_SHIFT;\n\t}\n\n\twritel(tim2, priv->regs + CLCD_TIM2);\n\tspin_unlock(&priv->tim2_lock);\n\n\treturn 0;\n}\n\nstatic const struct clk_ops pl111_clk_div_ops = {\n\t.recalc_rate = pl111_clk_div_recalc_rate,\n\t.round_rate = pl111_clk_div_round_rate,\n\t.set_rate = pl111_clk_div_set_rate,\n};\n\nstatic int\npl111_init_clock_divider(struct drm_device *drm)\n{\n\tstruct pl111_drm_dev_private *priv = drm->dev_private;\n\tstruct clk *parent = devm_clk_get(drm->dev, \"clcdclk\");\n\tstruct clk_hw *div = &priv->clk_div;\n\tconst char *parent_name;\n\tstruct clk_init_data init = {\n\t\t.name = \"pl111_div\",\n\t\t.ops = &pl111_clk_div_ops,\n\t\t.parent_names = &parent_name,\n\t\t.num_parents = 1,\n\t\t.flags = CLK_SET_RATE_PARENT,\n\t};\n\tint ret;\n\n\tif (IS_ERR(parent)) {\n\t\tdev_err(drm->dev, \"CLCD: unable to get clcdclk.\\n\");\n\t\treturn PTR_ERR(parent);\n\t}\n\n\tspin_lock_init(&priv->tim2_lock);\n\n\t \n\tif (priv->variant->broken_clockdivider) {\n\t\tpriv->clk = parent;\n\t\treturn 0;\n\t}\n\tparent_name = __clk_get_name(parent);\n\tdiv->init = &init;\n\n\tret = devm_clk_hw_register(drm->dev, div);\n\n\tpriv->clk = div->clk;\n\treturn ret;\n}\n\nint pl111_display_init(struct drm_device *drm)\n{\n\tstruct pl111_drm_dev_private *priv = drm->dev_private;\n\tint ret;\n\n\tret = pl111_init_clock_divider(drm);\n\tif (ret)\n\t\treturn ret;\n\n\tif (!priv->variant->broken_vblank) {\n\t\tpl111_display_funcs.enable_vblank = pl111_display_enable_vblank;\n\t\tpl111_display_funcs.disable_vblank = pl111_display_disable_vblank;\n\t}\n\n\tret = drm_simple_display_pipe_init(drm, &priv->pipe,\n\t\t\t\t\t   &pl111_display_funcs,\n\t\t\t\t\t   priv->variant->formats,\n\t\t\t\t\t   priv->variant->nformats,\n\t\t\t\t\t   NULL,\n\t\t\t\t\t   priv->connector);\n\tif (ret)\n\t\treturn ret;\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}