{
  "module_name": "drm_debugfs_crc.c",
  "hash_id": "b6d1b0b73909505c3f5333742e96ae70b3b9a74b81f141d60c025fac7b8ebe67",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/drm_debugfs_crc.c",
  "human_readable_source": " \n\n#include <linux/circ_buf.h>\n#include <linux/ctype.h>\n#include <linux/debugfs.h>\n#include <linux/poll.h>\n#include <linux/uaccess.h>\n\n#include <drm/drm_crtc.h>\n#include <drm/drm_debugfs_crc.h>\n#include <drm/drm_drv.h>\n#include <drm/drm_print.h>\n\n#include \"drm_internal.h\"\n\n \n\nstatic int crc_control_show(struct seq_file *m, void *data)\n{\n\tstruct drm_crtc *crtc = m->private;\n\n\tif (crtc->funcs->get_crc_sources) {\n\t\tsize_t count;\n\t\tconst char *const *sources = crtc->funcs->get_crc_sources(crtc,\n\t\t\t\t\t\t\t\t\t&count);\n\t\tsize_t values_cnt;\n\t\tint i;\n\n\t\tif (count == 0 || !sources)\n\t\t\tgoto out;\n\n\t\tfor (i = 0; i < count; i++)\n\t\t\tif (!crtc->funcs->verify_crc_source(crtc, sources[i],\n\t\t\t\t\t\t\t    &values_cnt)) {\n\t\t\t\tif (strcmp(sources[i], crtc->crc.source))\n\t\t\t\t\tseq_printf(m, \"%s\\n\", sources[i]);\n\t\t\t\telse\n\t\t\t\t\tseq_printf(m, \"%s*\\n\", sources[i]);\n\t\t\t}\n\t}\n\treturn 0;\n\nout:\n\tseq_printf(m, \"%s*\\n\", crtc->crc.source);\n\treturn 0;\n}\n\nstatic int crc_control_open(struct inode *inode, struct file *file)\n{\n\tstruct drm_crtc *crtc = inode->i_private;\n\n\treturn single_open(file, crc_control_show, crtc);\n}\n\nstatic ssize_t crc_control_write(struct file *file, const char __user *ubuf,\n\t\t\t\t size_t len, loff_t *offp)\n{\n\tstruct seq_file *m = file->private_data;\n\tstruct drm_crtc *crtc = m->private;\n\tstruct drm_crtc_crc *crc = &crtc->crc;\n\tchar *source;\n\tsize_t values_cnt;\n\tint ret;\n\n\tif (len == 0)\n\t\treturn 0;\n\n\tif (len > PAGE_SIZE - 1) {\n\t\tDRM_DEBUG_KMS(\"Expected < %lu bytes into crtc crc control\\n\",\n\t\t\t      PAGE_SIZE);\n\t\treturn -E2BIG;\n\t}\n\n\tsource = memdup_user_nul(ubuf, len);\n\tif (IS_ERR(source))\n\t\treturn PTR_ERR(source);\n\n\tif (source[len - 1] == '\\n')\n\t\tsource[len - 1] = '\\0';\n\n\tret = crtc->funcs->verify_crc_source(crtc, source, &values_cnt);\n\tif (ret) {\n\t\tkfree(source);\n\t\treturn ret;\n\t}\n\n\tspin_lock_irq(&crc->lock);\n\n\tif (crc->opened) {\n\t\tspin_unlock_irq(&crc->lock);\n\t\tkfree(source);\n\t\treturn -EBUSY;\n\t}\n\n\tkfree(crc->source);\n\tcrc->source = source;\n\n\tspin_unlock_irq(&crc->lock);\n\n\t*offp += len;\n\treturn len;\n}\n\nstatic const struct file_operations drm_crtc_crc_control_fops = {\n\t.owner = THIS_MODULE,\n\t.open = crc_control_open,\n\t.read = seq_read,\n\t.llseek = seq_lseek,\n\t.release = single_release,\n\t.write = crc_control_write\n};\n\nstatic int crtc_crc_data_count(struct drm_crtc_crc *crc)\n{\n\tassert_spin_locked(&crc->lock);\n\treturn CIRC_CNT(crc->head, crc->tail, DRM_CRC_ENTRIES_NR);\n}\n\nstatic void crtc_crc_cleanup(struct drm_crtc_crc *crc)\n{\n\tkfree(crc->entries);\n\tcrc->overflow = false;\n\tcrc->entries = NULL;\n\tcrc->head = 0;\n\tcrc->tail = 0;\n\tcrc->values_cnt = 0;\n\tcrc->opened = false;\n}\n\nstatic int crtc_crc_open(struct inode *inode, struct file *filep)\n{\n\tstruct drm_crtc *crtc = inode->i_private;\n\tstruct drm_crtc_crc *crc = &crtc->crc;\n\tstruct drm_crtc_crc_entry *entries = NULL;\n\tsize_t values_cnt;\n\tint ret = 0;\n\n\tif (drm_drv_uses_atomic_modeset(crtc->dev)) {\n\t\tret = drm_modeset_lock_single_interruptible(&crtc->mutex);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tif (!crtc->state->active)\n\t\t\tret = -EIO;\n\t\tdrm_modeset_unlock(&crtc->mutex);\n\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tret = crtc->funcs->verify_crc_source(crtc, crc->source, &values_cnt);\n\tif (ret)\n\t\treturn ret;\n\n\tif (WARN_ON(values_cnt > DRM_MAX_CRC_NR))\n\t\treturn -EINVAL;\n\n\tif (WARN_ON(values_cnt == 0))\n\t\treturn -EINVAL;\n\n\tentries = kcalloc(DRM_CRC_ENTRIES_NR, sizeof(*entries), GFP_KERNEL);\n\tif (!entries)\n\t\treturn -ENOMEM;\n\n\tspin_lock_irq(&crc->lock);\n\tif (!crc->opened) {\n\t\tcrc->opened = true;\n\t\tcrc->entries = entries;\n\t\tcrc->values_cnt = values_cnt;\n\t} else {\n\t\tret = -EBUSY;\n\t}\n\tspin_unlock_irq(&crc->lock);\n\n\tif (ret) {\n\t\tkfree(entries);\n\t\treturn ret;\n\t}\n\n\tret = crtc->funcs->set_crc_source(crtc, crc->source);\n\tif (ret)\n\t\tgoto err;\n\n\treturn 0;\n\nerr:\n\tspin_lock_irq(&crc->lock);\n\tcrtc_crc_cleanup(crc);\n\tspin_unlock_irq(&crc->lock);\n\treturn ret;\n}\n\nstatic int crtc_crc_release(struct inode *inode, struct file *filep)\n{\n\tstruct drm_crtc *crtc = filep->f_inode->i_private;\n\tstruct drm_crtc_crc *crc = &crtc->crc;\n\n\t \n\tspin_lock_irq(&crc->lock);\n\tcrc->opened = false;\n\tspin_unlock_irq(&crc->lock);\n\n\tcrtc->funcs->set_crc_source(crtc, NULL);\n\n\tspin_lock_irq(&crc->lock);\n\tcrtc_crc_cleanup(crc);\n\tspin_unlock_irq(&crc->lock);\n\n\treturn 0;\n}\n\n \n#define LINE_LEN(values_cnt)\t(10 + 11 * values_cnt + 1 + 1)\n#define MAX_LINE_LEN\t\t(LINE_LEN(DRM_MAX_CRC_NR))\n\nstatic ssize_t crtc_crc_read(struct file *filep, char __user *user_buf,\n\t\t\t     size_t count, loff_t *pos)\n{\n\tstruct drm_crtc *crtc = filep->f_inode->i_private;\n\tstruct drm_crtc_crc *crc = &crtc->crc;\n\tstruct drm_crtc_crc_entry *entry;\n\tchar buf[MAX_LINE_LEN];\n\tint ret, i;\n\n\tspin_lock_irq(&crc->lock);\n\n\tif (!crc->source) {\n\t\tspin_unlock_irq(&crc->lock);\n\t\treturn 0;\n\t}\n\n\t \n\twhile (crtc_crc_data_count(crc) == 0) {\n\t\tif (filep->f_flags & O_NONBLOCK) {\n\t\t\tspin_unlock_irq(&crc->lock);\n\t\t\treturn -EAGAIN;\n\t\t}\n\n\t\tret = wait_event_interruptible_lock_irq(crc->wq,\n\t\t\t\t\t\t\tcrtc_crc_data_count(crc),\n\t\t\t\t\t\t\tcrc->lock);\n\t\tif (ret) {\n\t\t\tspin_unlock_irq(&crc->lock);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\t \n\tentry = &crc->entries[crc->tail];\n\n\tif (count < LINE_LEN(crc->values_cnt)) {\n\t\tspin_unlock_irq(&crc->lock);\n\t\treturn -EINVAL;\n\t}\n\n\tBUILD_BUG_ON_NOT_POWER_OF_2(DRM_CRC_ENTRIES_NR);\n\tcrc->tail = (crc->tail + 1) & (DRM_CRC_ENTRIES_NR - 1);\n\n\tspin_unlock_irq(&crc->lock);\n\n\tif (entry->has_frame_counter)\n\t\tsprintf(buf, \"0x%08x\", entry->frame);\n\telse\n\t\tsprintf(buf, \"XXXXXXXXXX\");\n\n\tfor (i = 0; i < crc->values_cnt; i++)\n\t\tsprintf(buf + 10 + i * 11, \" 0x%08x\", entry->crcs[i]);\n\tsprintf(buf + 10 + crc->values_cnt * 11, \"\\n\");\n\n\tif (copy_to_user(user_buf, buf, LINE_LEN(crc->values_cnt)))\n\t\treturn -EFAULT;\n\n\treturn LINE_LEN(crc->values_cnt);\n}\n\nstatic __poll_t crtc_crc_poll(struct file *file, poll_table *wait)\n{\n\tstruct drm_crtc *crtc = file->f_inode->i_private;\n\tstruct drm_crtc_crc *crc = &crtc->crc;\n\t__poll_t ret = 0;\n\n\tpoll_wait(file, &crc->wq, wait);\n\n\tspin_lock_irq(&crc->lock);\n\tif (crc->source && crtc_crc_data_count(crc))\n\t\tret |= EPOLLIN | EPOLLRDNORM;\n\tspin_unlock_irq(&crc->lock);\n\n\treturn ret;\n}\n\nstatic const struct file_operations drm_crtc_crc_data_fops = {\n\t.owner = THIS_MODULE,\n\t.open = crtc_crc_open,\n\t.read = crtc_crc_read,\n\t.poll = crtc_crc_poll,\n\t.release = crtc_crc_release,\n};\n\nvoid drm_debugfs_crtc_crc_add(struct drm_crtc *crtc)\n{\n\tstruct dentry *crc_ent;\n\n\tif (!crtc->funcs->set_crc_source || !crtc->funcs->verify_crc_source)\n\t\treturn;\n\n\tcrc_ent = debugfs_create_dir(\"crc\", crtc->debugfs_entry);\n\n\tdebugfs_create_file(\"control\", S_IRUGO | S_IWUSR, crc_ent, crtc,\n\t\t\t    &drm_crtc_crc_control_fops);\n\tdebugfs_create_file(\"data\", S_IRUGO, crc_ent, crtc,\n\t\t\t    &drm_crtc_crc_data_fops);\n}\n\n \nint drm_crtc_add_crc_entry(struct drm_crtc *crtc, bool has_frame,\n\t\t\t   uint32_t frame, uint32_t *crcs)\n{\n\tstruct drm_crtc_crc *crc = &crtc->crc;\n\tstruct drm_crtc_crc_entry *entry;\n\tint head, tail;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&crc->lock, flags);\n\n\t \n\tif (!crc->entries) {\n\t\tspin_unlock_irqrestore(&crc->lock, flags);\n\t\treturn -EINVAL;\n\t}\n\n\thead = crc->head;\n\ttail = crc->tail;\n\n\tif (CIRC_SPACE(head, tail, DRM_CRC_ENTRIES_NR) < 1) {\n\t\tbool was_overflow = crc->overflow;\n\n\t\tcrc->overflow = true;\n\t\tspin_unlock_irqrestore(&crc->lock, flags);\n\n\t\tif (!was_overflow)\n\t\t\tDRM_ERROR(\"Overflow of CRC buffer, userspace reads too slow.\\n\");\n\n\t\treturn -ENOBUFS;\n\t}\n\n\tentry = &crc->entries[head];\n\tentry->frame = frame;\n\tentry->has_frame_counter = has_frame;\n\tmemcpy(&entry->crcs, crcs, sizeof(*crcs) * crc->values_cnt);\n\n\thead = (head + 1) & (DRM_CRC_ENTRIES_NR - 1);\n\tcrc->head = head;\n\n\tspin_unlock_irqrestore(&crc->lock, flags);\n\n\twake_up_interruptible(&crc->wq);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(drm_crtc_add_crc_entry);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}