{
  "module_name": "drm_fb_helper.c",
  "hash_id": "6a1be95a16f8e9a5c013074817c3a6c26a893f22f23e2ae557e9351550b48ab2",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/drm_fb_helper.c",
  "human_readable_source": " \n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/console.h>\n#include <linux/pci.h>\n#include <linux/sysrq.h>\n#include <linux/vga_switcheroo.h>\n\n#include <drm/drm_atomic.h>\n#include <drm/drm_drv.h>\n#include <drm/drm_fb_helper.h>\n#include <drm/drm_fourcc.h>\n#include <drm/drm_framebuffer.h>\n#include <drm/drm_modeset_helper_vtables.h>\n#include <drm/drm_print.h>\n#include <drm/drm_vblank.h>\n\n#include \"drm_internal.h\"\n\nstatic bool drm_fbdev_emulation = true;\nmodule_param_named(fbdev_emulation, drm_fbdev_emulation, bool, 0600);\nMODULE_PARM_DESC(fbdev_emulation,\n\t\t \"Enable legacy fbdev emulation [default=true]\");\n\nstatic int drm_fbdev_overalloc = CONFIG_DRM_FBDEV_OVERALLOC;\nmodule_param(drm_fbdev_overalloc, int, 0444);\nMODULE_PARM_DESC(drm_fbdev_overalloc,\n\t\t \"Overallocation of the fbdev buffer (%) [default=\"\n\t\t __MODULE_STRING(CONFIG_DRM_FBDEV_OVERALLOC) \"]\");\n\n \nstatic bool drm_leak_fbdev_smem;\n#if IS_ENABLED(CONFIG_DRM_FBDEV_LEAK_PHYS_SMEM)\nmodule_param_unsafe(drm_leak_fbdev_smem, bool, 0600);\nMODULE_PARM_DESC(drm_leak_fbdev_smem,\n\t\t \"Allow unsafe leaking fbdev physical smem address [default=false]\");\n#endif\n\nstatic LIST_HEAD(kernel_fb_helper_list);\nstatic DEFINE_MUTEX(kernel_fb_helper_lock);\n\n \n\nstatic void drm_fb_helper_restore_lut_atomic(struct drm_crtc *crtc)\n{\n\tuint16_t *r_base, *g_base, *b_base;\n\n\tif (crtc->funcs->gamma_set == NULL)\n\t\treturn;\n\n\tr_base = crtc->gamma_store;\n\tg_base = r_base + crtc->gamma_size;\n\tb_base = g_base + crtc->gamma_size;\n\n\tcrtc->funcs->gamma_set(crtc, r_base, g_base, b_base,\n\t\t\t       crtc->gamma_size, NULL);\n}\n\n \nint drm_fb_helper_debug_enter(struct fb_info *info)\n{\n\tstruct drm_fb_helper *helper = info->par;\n\tconst struct drm_crtc_helper_funcs *funcs;\n\tstruct drm_mode_set *mode_set;\n\n\tlist_for_each_entry(helper, &kernel_fb_helper_list, kernel_fb_list) {\n\t\tmutex_lock(&helper->client.modeset_mutex);\n\t\tdrm_client_for_each_modeset(mode_set, &helper->client) {\n\t\t\tif (!mode_set->crtc->enabled)\n\t\t\t\tcontinue;\n\n\t\t\tfuncs =\tmode_set->crtc->helper_private;\n\t\t\tif (funcs->mode_set_base_atomic == NULL)\n\t\t\t\tcontinue;\n\n\t\t\tif (drm_drv_uses_atomic_modeset(mode_set->crtc->dev))\n\t\t\t\tcontinue;\n\n\t\t\tfuncs->mode_set_base_atomic(mode_set->crtc,\n\t\t\t\t\t\t    mode_set->fb,\n\t\t\t\t\t\t    mode_set->x,\n\t\t\t\t\t\t    mode_set->y,\n\t\t\t\t\t\t    ENTER_ATOMIC_MODE_SET);\n\t\t}\n\t\tmutex_unlock(&helper->client.modeset_mutex);\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL(drm_fb_helper_debug_enter);\n\n \nint drm_fb_helper_debug_leave(struct fb_info *info)\n{\n\tstruct drm_fb_helper *helper = info->par;\n\tstruct drm_client_dev *client = &helper->client;\n\tstruct drm_device *dev = helper->dev;\n\tstruct drm_crtc *crtc;\n\tconst struct drm_crtc_helper_funcs *funcs;\n\tstruct drm_mode_set *mode_set;\n\tstruct drm_framebuffer *fb;\n\n\tmutex_lock(&client->modeset_mutex);\n\tdrm_client_for_each_modeset(mode_set, client) {\n\t\tcrtc = mode_set->crtc;\n\t\tif (drm_drv_uses_atomic_modeset(crtc->dev))\n\t\t\tcontinue;\n\n\t\tfuncs = crtc->helper_private;\n\t\tfb = crtc->primary->fb;\n\n\t\tif (!crtc->enabled)\n\t\t\tcontinue;\n\n\t\tif (!fb) {\n\t\t\tdrm_err(dev, \"no fb to restore?\\n\");\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (funcs->mode_set_base_atomic == NULL)\n\t\t\tcontinue;\n\n\t\tdrm_fb_helper_restore_lut_atomic(mode_set->crtc);\n\t\tfuncs->mode_set_base_atomic(mode_set->crtc, fb, crtc->x,\n\t\t\t\t\t    crtc->y, LEAVE_ATOMIC_MODE_SET);\n\t}\n\tmutex_unlock(&client->modeset_mutex);\n\n\treturn 0;\n}\nEXPORT_SYMBOL(drm_fb_helper_debug_leave);\n\nstatic int\n__drm_fb_helper_restore_fbdev_mode_unlocked(struct drm_fb_helper *fb_helper,\n\t\t\t\t\t    bool force)\n{\n\tbool do_delayed;\n\tint ret;\n\n\tif (!drm_fbdev_emulation || !fb_helper)\n\t\treturn -ENODEV;\n\n\tif (READ_ONCE(fb_helper->deferred_setup))\n\t\treturn 0;\n\n\tmutex_lock(&fb_helper->lock);\n\tif (force) {\n\t\t \n\t\tret = drm_client_modeset_commit_locked(&fb_helper->client);\n\t} else {\n\t\tret = drm_client_modeset_commit(&fb_helper->client);\n\t}\n\n\tdo_delayed = fb_helper->delayed_hotplug;\n\tif (do_delayed)\n\t\tfb_helper->delayed_hotplug = false;\n\tmutex_unlock(&fb_helper->lock);\n\n\tif (do_delayed)\n\t\tdrm_fb_helper_hotplug_event(fb_helper);\n\n\treturn ret;\n}\n\n \nint drm_fb_helper_restore_fbdev_mode_unlocked(struct drm_fb_helper *fb_helper)\n{\n\treturn __drm_fb_helper_restore_fbdev_mode_unlocked(fb_helper, false);\n}\nEXPORT_SYMBOL(drm_fb_helper_restore_fbdev_mode_unlocked);\n\n#ifdef CONFIG_MAGIC_SYSRQ\n \nstatic void drm_fb_helper_restore_work_fn(struct work_struct *ignored)\n{\n\tstruct drm_fb_helper *helper;\n\n\tmutex_lock(&kernel_fb_helper_lock);\n\tlist_for_each_entry(helper, &kernel_fb_helper_list, kernel_fb_list) {\n\t\tstruct drm_device *dev = helper->dev;\n\n\t\tif (dev->switch_power_state == DRM_SWITCH_POWER_OFF)\n\t\t\tcontinue;\n\n\t\tmutex_lock(&helper->lock);\n\t\tdrm_client_modeset_commit_locked(&helper->client);\n\t\tmutex_unlock(&helper->lock);\n\t}\n\tmutex_unlock(&kernel_fb_helper_lock);\n}\n\nstatic DECLARE_WORK(drm_fb_helper_restore_work, drm_fb_helper_restore_work_fn);\n\nstatic void drm_fb_helper_sysrq(u8 dummy1)\n{\n\tschedule_work(&drm_fb_helper_restore_work);\n}\n\nstatic const struct sysrq_key_op sysrq_drm_fb_helper_restore_op = {\n\t.handler = drm_fb_helper_sysrq,\n\t.help_msg = \"force-fb(v)\",\n\t.action_msg = \"Restore framebuffer console\",\n};\n#else\nstatic const struct sysrq_key_op sysrq_drm_fb_helper_restore_op = { };\n#endif\n\nstatic void drm_fb_helper_dpms(struct fb_info *info, int dpms_mode)\n{\n\tstruct drm_fb_helper *fb_helper = info->par;\n\n\tmutex_lock(&fb_helper->lock);\n\tdrm_client_modeset_dpms(&fb_helper->client, dpms_mode);\n\tmutex_unlock(&fb_helper->lock);\n}\n\n \nint drm_fb_helper_blank(int blank, struct fb_info *info)\n{\n\tif (oops_in_progress)\n\t\treturn -EBUSY;\n\n\tswitch (blank) {\n\t \n\tcase FB_BLANK_UNBLANK:\n\t\tdrm_fb_helper_dpms(info, DRM_MODE_DPMS_ON);\n\t\tbreak;\n\t \n\tcase FB_BLANK_NORMAL:\n\t\tdrm_fb_helper_dpms(info, DRM_MODE_DPMS_STANDBY);\n\t\tbreak;\n\t \n\tcase FB_BLANK_HSYNC_SUSPEND:\n\t\tdrm_fb_helper_dpms(info, DRM_MODE_DPMS_STANDBY);\n\t\tbreak;\n\t \n\tcase FB_BLANK_VSYNC_SUSPEND:\n\t\tdrm_fb_helper_dpms(info, DRM_MODE_DPMS_SUSPEND);\n\t\tbreak;\n\t \n\tcase FB_BLANK_POWERDOWN:\n\t\tdrm_fb_helper_dpms(info, DRM_MODE_DPMS_OFF);\n\t\tbreak;\n\t}\n\treturn 0;\n}\nEXPORT_SYMBOL(drm_fb_helper_blank);\n\nstatic void drm_fb_helper_resume_worker(struct work_struct *work)\n{\n\tstruct drm_fb_helper *helper = container_of(work, struct drm_fb_helper,\n\t\t\t\t\t\t    resume_work);\n\n\tconsole_lock();\n\tfb_set_suspend(helper->info, 0);\n\tconsole_unlock();\n}\n\nstatic void drm_fb_helper_fb_dirty(struct drm_fb_helper *helper)\n{\n\tstruct drm_device *dev = helper->dev;\n\tstruct drm_clip_rect *clip = &helper->damage_clip;\n\tstruct drm_clip_rect clip_copy;\n\tunsigned long flags;\n\tint ret;\n\n\tif (drm_WARN_ON_ONCE(dev, !helper->funcs->fb_dirty))\n\t\treturn;\n\n\tspin_lock_irqsave(&helper->damage_lock, flags);\n\tclip_copy = *clip;\n\tclip->x1 = clip->y1 = ~0;\n\tclip->x2 = clip->y2 = 0;\n\tspin_unlock_irqrestore(&helper->damage_lock, flags);\n\n\tret = helper->funcs->fb_dirty(helper, &clip_copy);\n\tif (ret)\n\t\tgoto err;\n\n\treturn;\n\nerr:\n\t \n\tspin_lock_irqsave(&helper->damage_lock, flags);\n\tclip->x1 = min_t(u32, clip->x1, clip_copy.x1);\n\tclip->y1 = min_t(u32, clip->y1, clip_copy.y1);\n\tclip->x2 = max_t(u32, clip->x2, clip_copy.x2);\n\tclip->y2 = max_t(u32, clip->y2, clip_copy.y2);\n\tspin_unlock_irqrestore(&helper->damage_lock, flags);\n}\n\nstatic void drm_fb_helper_damage_work(struct work_struct *work)\n{\n\tstruct drm_fb_helper *helper = container_of(work, struct drm_fb_helper, damage_work);\n\n\tdrm_fb_helper_fb_dirty(helper);\n}\n\n \nvoid drm_fb_helper_prepare(struct drm_device *dev, struct drm_fb_helper *helper,\n\t\t\t   unsigned int preferred_bpp,\n\t\t\t   const struct drm_fb_helper_funcs *funcs)\n{\n\t \n\tif (!preferred_bpp)\n\t\tpreferred_bpp = 32;\n\n\tINIT_LIST_HEAD(&helper->kernel_fb_list);\n\tspin_lock_init(&helper->damage_lock);\n\tINIT_WORK(&helper->resume_work, drm_fb_helper_resume_worker);\n\tINIT_WORK(&helper->damage_work, drm_fb_helper_damage_work);\n\thelper->damage_clip.x1 = helper->damage_clip.y1 = ~0;\n\tmutex_init(&helper->lock);\n\thelper->funcs = funcs;\n\thelper->dev = dev;\n\thelper->preferred_bpp = preferred_bpp;\n}\nEXPORT_SYMBOL(drm_fb_helper_prepare);\n\n \nvoid drm_fb_helper_unprepare(struct drm_fb_helper *fb_helper)\n{\n\tmutex_destroy(&fb_helper->lock);\n}\nEXPORT_SYMBOL(drm_fb_helper_unprepare);\n\n \nint drm_fb_helper_init(struct drm_device *dev,\n\t\t       struct drm_fb_helper *fb_helper)\n{\n\tint ret;\n\n\t \n\tif (!fb_helper->client.funcs) {\n\t\tret = drm_client_init(dev, &fb_helper->client, \"drm_fb_helper\", NULL);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tdev->fb_helper = fb_helper;\n\n\treturn 0;\n}\nEXPORT_SYMBOL(drm_fb_helper_init);\n\n \nstruct fb_info *drm_fb_helper_alloc_info(struct drm_fb_helper *fb_helper)\n{\n\tstruct device *dev = fb_helper->dev->dev;\n\tstruct fb_info *info;\n\tint ret;\n\n\tinfo = framebuffer_alloc(0, dev);\n\tif (!info)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tret = fb_alloc_cmap(&info->cmap, 256, 0);\n\tif (ret)\n\t\tgoto err_release;\n\n\tfb_helper->info = info;\n\tinfo->skip_vt_switch = true;\n\n\treturn info;\n\nerr_release:\n\tframebuffer_release(info);\n\treturn ERR_PTR(ret);\n}\nEXPORT_SYMBOL(drm_fb_helper_alloc_info);\n\n \nvoid drm_fb_helper_release_info(struct drm_fb_helper *fb_helper)\n{\n\tstruct fb_info *info = fb_helper->info;\n\n\tif (!info)\n\t\treturn;\n\n\tfb_helper->info = NULL;\n\n\tif (info->cmap.len)\n\t\tfb_dealloc_cmap(&info->cmap);\n\tframebuffer_release(info);\n}\nEXPORT_SYMBOL(drm_fb_helper_release_info);\n\n \nvoid drm_fb_helper_unregister_info(struct drm_fb_helper *fb_helper)\n{\n\tif (fb_helper && fb_helper->info)\n\t\tunregister_framebuffer(fb_helper->info);\n}\nEXPORT_SYMBOL(drm_fb_helper_unregister_info);\n\n \nvoid drm_fb_helper_fini(struct drm_fb_helper *fb_helper)\n{\n\tif (!fb_helper)\n\t\treturn;\n\n\tfb_helper->dev->fb_helper = NULL;\n\n\tif (!drm_fbdev_emulation)\n\t\treturn;\n\n\tcancel_work_sync(&fb_helper->resume_work);\n\tcancel_work_sync(&fb_helper->damage_work);\n\n\tdrm_fb_helper_release_info(fb_helper);\n\n\tmutex_lock(&kernel_fb_helper_lock);\n\tif (!list_empty(&fb_helper->kernel_fb_list)) {\n\t\tlist_del(&fb_helper->kernel_fb_list);\n\t\tif (list_empty(&kernel_fb_helper_list))\n\t\t\tunregister_sysrq_key('v', &sysrq_drm_fb_helper_restore_op);\n\t}\n\tmutex_unlock(&kernel_fb_helper_lock);\n\n\tif (!fb_helper->client.funcs)\n\t\tdrm_client_release(&fb_helper->client);\n}\nEXPORT_SYMBOL(drm_fb_helper_fini);\n\nstatic void drm_fb_helper_add_damage_clip(struct drm_fb_helper *helper, u32 x, u32 y,\n\t\t\t\t\t  u32 width, u32 height)\n{\n\tstruct drm_clip_rect *clip = &helper->damage_clip;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&helper->damage_lock, flags);\n\tclip->x1 = min_t(u32, clip->x1, x);\n\tclip->y1 = min_t(u32, clip->y1, y);\n\tclip->x2 = max_t(u32, clip->x2, x + width);\n\tclip->y2 = max_t(u32, clip->y2, y + height);\n\tspin_unlock_irqrestore(&helper->damage_lock, flags);\n}\n\nstatic void drm_fb_helper_damage(struct drm_fb_helper *helper, u32 x, u32 y,\n\t\t\t\t u32 width, u32 height)\n{\n\tdrm_fb_helper_add_damage_clip(helper, x, y, width, height);\n\n\tschedule_work(&helper->damage_work);\n}\n\n \nstatic void drm_fb_helper_memory_range_to_clip(struct fb_info *info, off_t off, size_t len,\n\t\t\t\t\t       struct drm_rect *clip)\n{\n\tu32 line_length = info->fix.line_length;\n\tu32 fb_height = info->var.yres;\n\toff_t end = off + len;\n\tu32 x1 = 0;\n\tu32 y1 = off / line_length;\n\tu32 x2 = info->var.xres;\n\tu32 y2 = DIV_ROUND_UP(end, line_length);\n\n\t \n\tif (y1 > fb_height)\n\t\ty1 = fb_height;\n\tif (y2 > fb_height)\n\t\ty2 = fb_height;\n\n\tif ((y2 - y1) == 1) {\n\t\t \n\t\toff_t bit_off = (off % line_length) * 8;\n\t\toff_t bit_end = (end % line_length) * 8;\n\n\t\tx1 = bit_off / info->var.bits_per_pixel;\n\t\tx2 = DIV_ROUND_UP(bit_end, info->var.bits_per_pixel);\n\t}\n\n\tdrm_rect_init(clip, x1, y1, x2 - x1, y2 - y1);\n}\n\n \nvoid drm_fb_helper_damage_range(struct fb_info *info, off_t off, size_t len)\n{\n\tstruct drm_fb_helper *fb_helper = info->par;\n\tstruct drm_rect damage_area;\n\n\tdrm_fb_helper_memory_range_to_clip(info, off, len, &damage_area);\n\tdrm_fb_helper_damage(fb_helper, damage_area.x1, damage_area.y1,\n\t\t\t     drm_rect_width(&damage_area),\n\t\t\t     drm_rect_height(&damage_area));\n}\nEXPORT_SYMBOL(drm_fb_helper_damage_range);\n\n \nvoid drm_fb_helper_damage_area(struct fb_info *info, u32 x, u32 y, u32 width, u32 height)\n{\n\tstruct drm_fb_helper *fb_helper = info->par;\n\n\tdrm_fb_helper_damage(fb_helper, x, y, width, height);\n}\nEXPORT_SYMBOL(drm_fb_helper_damage_area);\n\n \nvoid drm_fb_helper_deferred_io(struct fb_info *info, struct list_head *pagereflist)\n{\n\tstruct drm_fb_helper *helper = info->par;\n\tunsigned long start, end, min_off, max_off, total_size;\n\tstruct fb_deferred_io_pageref *pageref;\n\tstruct drm_rect damage_area;\n\n\tmin_off = ULONG_MAX;\n\tmax_off = 0;\n\tlist_for_each_entry(pageref, pagereflist, list) {\n\t\tstart = pageref->offset;\n\t\tend = start + PAGE_SIZE;\n\t\tmin_off = min(min_off, start);\n\t\tmax_off = max(max_off, end);\n\t}\n\n\t \n\tif (info->screen_size)\n\t\ttotal_size = info->screen_size;\n\telse\n\t\ttotal_size = info->fix.smem_len;\n\tmax_off = min(max_off, total_size);\n\n\tif (min_off < max_off) {\n\t\tdrm_fb_helper_memory_range_to_clip(info, min_off, max_off - min_off, &damage_area);\n\t\tdrm_fb_helper_damage(helper, damage_area.x1, damage_area.y1,\n\t\t\t\t     drm_rect_width(&damage_area),\n\t\t\t\t     drm_rect_height(&damage_area));\n\t}\n}\nEXPORT_SYMBOL(drm_fb_helper_deferred_io);\n\n \nvoid drm_fb_helper_set_suspend(struct drm_fb_helper *fb_helper, bool suspend)\n{\n\tif (fb_helper && fb_helper->info)\n\t\tfb_set_suspend(fb_helper->info, suspend);\n}\nEXPORT_SYMBOL(drm_fb_helper_set_suspend);\n\n \nvoid drm_fb_helper_set_suspend_unlocked(struct drm_fb_helper *fb_helper,\n\t\t\t\t\tbool suspend)\n{\n\tif (!fb_helper || !fb_helper->info)\n\t\treturn;\n\n\t \n\tflush_work(&fb_helper->resume_work);\n\n\tif (suspend) {\n\t\tif (fb_helper->info->state != FBINFO_STATE_RUNNING)\n\t\t\treturn;\n\n\t\tconsole_lock();\n\n\t} else {\n\t\tif (fb_helper->info->state == FBINFO_STATE_RUNNING)\n\t\t\treturn;\n\n\t\tif (!console_trylock()) {\n\t\t\tschedule_work(&fb_helper->resume_work);\n\t\t\treturn;\n\t\t}\n\t}\n\n\tfb_set_suspend(fb_helper->info, suspend);\n\tconsole_unlock();\n}\nEXPORT_SYMBOL(drm_fb_helper_set_suspend_unlocked);\n\nstatic int setcmap_pseudo_palette(struct fb_cmap *cmap, struct fb_info *info)\n{\n\tu32 *palette = (u32 *)info->pseudo_palette;\n\tint i;\n\n\tif (cmap->start + cmap->len > 16)\n\t\treturn -EINVAL;\n\n\tfor (i = 0; i < cmap->len; ++i) {\n\t\tu16 red = cmap->red[i];\n\t\tu16 green = cmap->green[i];\n\t\tu16 blue = cmap->blue[i];\n\t\tu32 value;\n\n\t\tred >>= 16 - info->var.red.length;\n\t\tgreen >>= 16 - info->var.green.length;\n\t\tblue >>= 16 - info->var.blue.length;\n\t\tvalue = (red << info->var.red.offset) |\n\t\t\t(green << info->var.green.offset) |\n\t\t\t(blue << info->var.blue.offset);\n\t\tif (info->var.transp.length > 0) {\n\t\t\tu32 mask = (1 << info->var.transp.length) - 1;\n\n\t\t\tmask <<= info->var.transp.offset;\n\t\t\tvalue |= mask;\n\t\t}\n\t\tpalette[cmap->start + i] = value;\n\t}\n\n\treturn 0;\n}\n\nstatic int setcmap_legacy(struct fb_cmap *cmap, struct fb_info *info)\n{\n\tstruct drm_fb_helper *fb_helper = info->par;\n\tstruct drm_mode_set *modeset;\n\tstruct drm_crtc *crtc;\n\tu16 *r, *g, *b;\n\tint ret = 0;\n\n\tdrm_modeset_lock_all(fb_helper->dev);\n\tdrm_client_for_each_modeset(modeset, &fb_helper->client) {\n\t\tcrtc = modeset->crtc;\n\t\tif (!crtc->funcs->gamma_set || !crtc->gamma_size) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (cmap->start + cmap->len > crtc->gamma_size) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t\tr = crtc->gamma_store;\n\t\tg = r + crtc->gamma_size;\n\t\tb = g + crtc->gamma_size;\n\n\t\tmemcpy(r + cmap->start, cmap->red, cmap->len * sizeof(*r));\n\t\tmemcpy(g + cmap->start, cmap->green, cmap->len * sizeof(*g));\n\t\tmemcpy(b + cmap->start, cmap->blue, cmap->len * sizeof(*b));\n\n\t\tret = crtc->funcs->gamma_set(crtc, r, g, b,\n\t\t\t\t\t     crtc->gamma_size, NULL);\n\t\tif (ret)\n\t\t\tgoto out;\n\t}\nout:\n\tdrm_modeset_unlock_all(fb_helper->dev);\n\n\treturn ret;\n}\n\nstatic struct drm_property_blob *setcmap_new_gamma_lut(struct drm_crtc *crtc,\n\t\t\t\t\t\t       struct fb_cmap *cmap)\n{\n\tstruct drm_device *dev = crtc->dev;\n\tstruct drm_property_blob *gamma_lut;\n\tstruct drm_color_lut *lut;\n\tint size = crtc->gamma_size;\n\tint i;\n\n\tif (!size || cmap->start + cmap->len > size)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tgamma_lut = drm_property_create_blob(dev, sizeof(*lut) * size, NULL);\n\tif (IS_ERR(gamma_lut))\n\t\treturn gamma_lut;\n\n\tlut = gamma_lut->data;\n\tif (cmap->start || cmap->len != size) {\n\t\tu16 *r = crtc->gamma_store;\n\t\tu16 *g = r + crtc->gamma_size;\n\t\tu16 *b = g + crtc->gamma_size;\n\n\t\tfor (i = 0; i < cmap->start; i++) {\n\t\t\tlut[i].red = r[i];\n\t\t\tlut[i].green = g[i];\n\t\t\tlut[i].blue = b[i];\n\t\t}\n\t\tfor (i = cmap->start + cmap->len; i < size; i++) {\n\t\t\tlut[i].red = r[i];\n\t\t\tlut[i].green = g[i];\n\t\t\tlut[i].blue = b[i];\n\t\t}\n\t}\n\n\tfor (i = 0; i < cmap->len; i++) {\n\t\tlut[cmap->start + i].red = cmap->red[i];\n\t\tlut[cmap->start + i].green = cmap->green[i];\n\t\tlut[cmap->start + i].blue = cmap->blue[i];\n\t}\n\n\treturn gamma_lut;\n}\n\nstatic int setcmap_atomic(struct fb_cmap *cmap, struct fb_info *info)\n{\n\tstruct drm_fb_helper *fb_helper = info->par;\n\tstruct drm_device *dev = fb_helper->dev;\n\tstruct drm_property_blob *gamma_lut = NULL;\n\tstruct drm_modeset_acquire_ctx ctx;\n\tstruct drm_crtc_state *crtc_state;\n\tstruct drm_atomic_state *state;\n\tstruct drm_mode_set *modeset;\n\tstruct drm_crtc *crtc;\n\tu16 *r, *g, *b;\n\tbool replaced;\n\tint ret = 0;\n\n\tdrm_modeset_acquire_init(&ctx, 0);\n\n\tstate = drm_atomic_state_alloc(dev);\n\tif (!state) {\n\t\tret = -ENOMEM;\n\t\tgoto out_ctx;\n\t}\n\n\tstate->acquire_ctx = &ctx;\nretry:\n\tdrm_client_for_each_modeset(modeset, &fb_helper->client) {\n\t\tcrtc = modeset->crtc;\n\n\t\tif (!gamma_lut)\n\t\t\tgamma_lut = setcmap_new_gamma_lut(crtc, cmap);\n\t\tif (IS_ERR(gamma_lut)) {\n\t\t\tret = PTR_ERR(gamma_lut);\n\t\t\tgamma_lut = NULL;\n\t\t\tgoto out_state;\n\t\t}\n\n\t\tcrtc_state = drm_atomic_get_crtc_state(state, crtc);\n\t\tif (IS_ERR(crtc_state)) {\n\t\t\tret = PTR_ERR(crtc_state);\n\t\t\tgoto out_state;\n\t\t}\n\n\t\t \n\t\treplaced  = drm_property_replace_blob(&crtc_state->degamma_lut,\n\t\t\t\t\t\t      NULL);\n\t\treplaced |= drm_property_replace_blob(&crtc_state->ctm, NULL);\n\t\treplaced |= drm_property_replace_blob(&crtc_state->gamma_lut,\n\t\t\t\t\t\t      gamma_lut);\n\t\tcrtc_state->color_mgmt_changed |= replaced;\n\t}\n\n\tret = drm_atomic_commit(state);\n\tif (ret)\n\t\tgoto out_state;\n\n\tdrm_client_for_each_modeset(modeset, &fb_helper->client) {\n\t\tcrtc = modeset->crtc;\n\n\t\tr = crtc->gamma_store;\n\t\tg = r + crtc->gamma_size;\n\t\tb = g + crtc->gamma_size;\n\n\t\tmemcpy(r + cmap->start, cmap->red, cmap->len * sizeof(*r));\n\t\tmemcpy(g + cmap->start, cmap->green, cmap->len * sizeof(*g));\n\t\tmemcpy(b + cmap->start, cmap->blue, cmap->len * sizeof(*b));\n\t}\n\nout_state:\n\tif (ret == -EDEADLK)\n\t\tgoto backoff;\n\n\tdrm_property_blob_put(gamma_lut);\n\tdrm_atomic_state_put(state);\nout_ctx:\n\tdrm_modeset_drop_locks(&ctx);\n\tdrm_modeset_acquire_fini(&ctx);\n\n\treturn ret;\n\nbackoff:\n\tdrm_atomic_state_clear(state);\n\tdrm_modeset_backoff(&ctx);\n\tgoto retry;\n}\n\n \nint drm_fb_helper_setcmap(struct fb_cmap *cmap, struct fb_info *info)\n{\n\tstruct drm_fb_helper *fb_helper = info->par;\n\tstruct drm_device *dev = fb_helper->dev;\n\tint ret;\n\n\tif (oops_in_progress)\n\t\treturn -EBUSY;\n\n\tmutex_lock(&fb_helper->lock);\n\n\tif (!drm_master_internal_acquire(dev)) {\n\t\tret = -EBUSY;\n\t\tgoto unlock;\n\t}\n\n\tmutex_lock(&fb_helper->client.modeset_mutex);\n\tif (info->fix.visual == FB_VISUAL_TRUECOLOR)\n\t\tret = setcmap_pseudo_palette(cmap, info);\n\telse if (drm_drv_uses_atomic_modeset(fb_helper->dev))\n\t\tret = setcmap_atomic(cmap, info);\n\telse\n\t\tret = setcmap_legacy(cmap, info);\n\tmutex_unlock(&fb_helper->client.modeset_mutex);\n\n\tdrm_master_internal_release(dev);\nunlock:\n\tmutex_unlock(&fb_helper->lock);\n\n\treturn ret;\n}\nEXPORT_SYMBOL(drm_fb_helper_setcmap);\n\n \nint drm_fb_helper_ioctl(struct fb_info *info, unsigned int cmd,\n\t\t\tunsigned long arg)\n{\n\tstruct drm_fb_helper *fb_helper = info->par;\n\tstruct drm_device *dev = fb_helper->dev;\n\tstruct drm_crtc *crtc;\n\tint ret = 0;\n\n\tmutex_lock(&fb_helper->lock);\n\tif (!drm_master_internal_acquire(dev)) {\n\t\tret = -EBUSY;\n\t\tgoto unlock;\n\t}\n\n\tswitch (cmd) {\n\tcase FBIO_WAITFORVSYNC:\n\t\t \n\t\tcrtc = fb_helper->client.modesets[0].crtc;\n\n\t\t \n\t\tret = drm_crtc_vblank_get(crtc);\n\t\tif (!ret) {\n\t\t\tdrm_crtc_wait_one_vblank(crtc);\n\t\t\tdrm_crtc_vblank_put(crtc);\n\t\t}\n\n\t\tret = 0;\n\t\tbreak;\n\tdefault:\n\t\tret = -ENOTTY;\n\t}\n\n\tdrm_master_internal_release(dev);\nunlock:\n\tmutex_unlock(&fb_helper->lock);\n\treturn ret;\n}\nEXPORT_SYMBOL(drm_fb_helper_ioctl);\n\nstatic bool drm_fb_pixel_format_equal(const struct fb_var_screeninfo *var_1,\n\t\t\t\t      const struct fb_var_screeninfo *var_2)\n{\n\treturn var_1->bits_per_pixel == var_2->bits_per_pixel &&\n\t       var_1->grayscale == var_2->grayscale &&\n\t       var_1->red.offset == var_2->red.offset &&\n\t       var_1->red.length == var_2->red.length &&\n\t       var_1->red.msb_right == var_2->red.msb_right &&\n\t       var_1->green.offset == var_2->green.offset &&\n\t       var_1->green.length == var_2->green.length &&\n\t       var_1->green.msb_right == var_2->green.msb_right &&\n\t       var_1->blue.offset == var_2->blue.offset &&\n\t       var_1->blue.length == var_2->blue.length &&\n\t       var_1->blue.msb_right == var_2->blue.msb_right &&\n\t       var_1->transp.offset == var_2->transp.offset &&\n\t       var_1->transp.length == var_2->transp.length &&\n\t       var_1->transp.msb_right == var_2->transp.msb_right;\n}\n\nstatic void drm_fb_helper_fill_pixel_fmt(struct fb_var_screeninfo *var,\n\t\t\t\t\t const struct drm_format_info *format)\n{\n\tu8 depth = format->depth;\n\n\tif (format->is_color_indexed) {\n\t\tvar->red.offset = 0;\n\t\tvar->green.offset = 0;\n\t\tvar->blue.offset = 0;\n\t\tvar->red.length = depth;\n\t\tvar->green.length = depth;\n\t\tvar->blue.length = depth;\n\t\tvar->transp.offset = 0;\n\t\tvar->transp.length = 0;\n\t\treturn;\n\t}\n\n\tswitch (depth) {\n\tcase 15:\n\t\tvar->red.offset = 10;\n\t\tvar->green.offset = 5;\n\t\tvar->blue.offset = 0;\n\t\tvar->red.length = 5;\n\t\tvar->green.length = 5;\n\t\tvar->blue.length = 5;\n\t\tvar->transp.offset = 15;\n\t\tvar->transp.length = 1;\n\t\tbreak;\n\tcase 16:\n\t\tvar->red.offset = 11;\n\t\tvar->green.offset = 5;\n\t\tvar->blue.offset = 0;\n\t\tvar->red.length = 5;\n\t\tvar->green.length = 6;\n\t\tvar->blue.length = 5;\n\t\tvar->transp.offset = 0;\n\t\tbreak;\n\tcase 24:\n\t\tvar->red.offset = 16;\n\t\tvar->green.offset = 8;\n\t\tvar->blue.offset = 0;\n\t\tvar->red.length = 8;\n\t\tvar->green.length = 8;\n\t\tvar->blue.length = 8;\n\t\tvar->transp.offset = 0;\n\t\tvar->transp.length = 0;\n\t\tbreak;\n\tcase 32:\n\t\tvar->red.offset = 16;\n\t\tvar->green.offset = 8;\n\t\tvar->blue.offset = 0;\n\t\tvar->red.length = 8;\n\t\tvar->green.length = 8;\n\t\tvar->blue.length = 8;\n\t\tvar->transp.offset = 24;\n\t\tvar->transp.length = 8;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}\n\nstatic void __fill_var(struct fb_var_screeninfo *var, struct fb_info *info,\n\t\t       struct drm_framebuffer *fb)\n{\n\tint i;\n\n\tvar->xres_virtual = fb->width;\n\tvar->yres_virtual = fb->height;\n\tvar->accel_flags = 0;\n\tvar->bits_per_pixel = drm_format_info_bpp(fb->format, 0);\n\n\tvar->height = info->var.height;\n\tvar->width = info->var.width;\n\n\tvar->left_margin = var->right_margin = 0;\n\tvar->upper_margin = var->lower_margin = 0;\n\tvar->hsync_len = var->vsync_len = 0;\n\tvar->sync = var->vmode = 0;\n\tvar->rotate = 0;\n\tvar->colorspace = 0;\n\tfor (i = 0; i < 4; i++)\n\t\tvar->reserved[i] = 0;\n}\n\n \nint drm_fb_helper_check_var(struct fb_var_screeninfo *var,\n\t\t\t    struct fb_info *info)\n{\n\tstruct drm_fb_helper *fb_helper = info->par;\n\tstruct drm_framebuffer *fb = fb_helper->fb;\n\tconst struct drm_format_info *format = fb->format;\n\tstruct drm_device *dev = fb_helper->dev;\n\tunsigned int bpp;\n\n\tif (in_dbg_master())\n\t\treturn -EINVAL;\n\n\tif (var->pixclock != 0) {\n\t\tdrm_dbg_kms(dev, \"fbdev emulation doesn't support changing the pixel clock, value of pixclock is ignored\\n\");\n\t\tvar->pixclock = 0;\n\t}\n\n\tswitch (format->format) {\n\tcase DRM_FORMAT_C1:\n\tcase DRM_FORMAT_C2:\n\tcase DRM_FORMAT_C4:\n\t\t \n\t\tbreak;\n\n\tdefault:\n\t\tif ((drm_format_info_block_width(format, 0) > 1) ||\n\t\t    (drm_format_info_block_height(format, 0) > 1))\n\t\t\treturn -EINVAL;\n\t\tbreak;\n\t}\n\n\t \n\tbpp = drm_format_info_bpp(format, 0);\n\tif (var->bits_per_pixel > bpp ||\n\t    var->xres > fb->width || var->yres > fb->height ||\n\t    var->xres_virtual > fb->width || var->yres_virtual > fb->height) {\n\t\tdrm_dbg_kms(dev, \"fb requested width/height/bpp can't fit in current fb \"\n\t\t\t  \"request %dx%d-%d (virtual %dx%d) > %dx%d-%d\\n\",\n\t\t\t  var->xres, var->yres, var->bits_per_pixel,\n\t\t\t  var->xres_virtual, var->yres_virtual,\n\t\t\t  fb->width, fb->height, bpp);\n\t\treturn -EINVAL;\n\t}\n\n\t__fill_var(var, info, fb);\n\n\t \n\tif (var->yoffset > var->yres_virtual - var->yres ||\n\t    var->xoffset > var->xres_virtual - var->xres)\n\t\treturn -EINVAL;\n\n\t \n\tif (var->grayscale > 0)\n\t\treturn -EINVAL;\n\n\tif (var->nonstd)\n\t\treturn -EINVAL;\n\n\t \n\tif (!var->red.offset     && !var->green.offset    &&\n\t    !var->blue.offset    && !var->transp.offset   &&\n\t    !var->red.length     && !var->green.length    &&\n\t    !var->blue.length    && !var->transp.length   &&\n\t    !var->red.msb_right  && !var->green.msb_right &&\n\t    !var->blue.msb_right && !var->transp.msb_right) {\n\t\tdrm_fb_helper_fill_pixel_fmt(var, format);\n\t}\n\n\t \n\tif (!drm_fb_pixel_format_equal(var, &info->var)) {\n\t\tdrm_dbg_kms(dev, \"fbdev emulation doesn't support changing the pixel format\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL(drm_fb_helper_check_var);\n\n \nint drm_fb_helper_set_par(struct fb_info *info)\n{\n\tstruct drm_fb_helper *fb_helper = info->par;\n\tstruct fb_var_screeninfo *var = &info->var;\n\tbool force;\n\n\tif (oops_in_progress)\n\t\treturn -EBUSY;\n\n\t \n\tforce = var->activate & FB_ACTIVATE_KD_TEXT;\n\n\t__drm_fb_helper_restore_fbdev_mode_unlocked(fb_helper, force);\n\n\treturn 0;\n}\nEXPORT_SYMBOL(drm_fb_helper_set_par);\n\nstatic void pan_set(struct drm_fb_helper *fb_helper, int x, int y)\n{\n\tstruct drm_mode_set *mode_set;\n\n\tmutex_lock(&fb_helper->client.modeset_mutex);\n\tdrm_client_for_each_modeset(mode_set, &fb_helper->client) {\n\t\tmode_set->x = x;\n\t\tmode_set->y = y;\n\t}\n\tmutex_unlock(&fb_helper->client.modeset_mutex);\n}\n\nstatic int pan_display_atomic(struct fb_var_screeninfo *var,\n\t\t\t      struct fb_info *info)\n{\n\tstruct drm_fb_helper *fb_helper = info->par;\n\tint ret;\n\n\tpan_set(fb_helper, var->xoffset, var->yoffset);\n\n\tret = drm_client_modeset_commit_locked(&fb_helper->client);\n\tif (!ret) {\n\t\tinfo->var.xoffset = var->xoffset;\n\t\tinfo->var.yoffset = var->yoffset;\n\t} else\n\t\tpan_set(fb_helper, info->var.xoffset, info->var.yoffset);\n\n\treturn ret;\n}\n\nstatic int pan_display_legacy(struct fb_var_screeninfo *var,\n\t\t\t      struct fb_info *info)\n{\n\tstruct drm_fb_helper *fb_helper = info->par;\n\tstruct drm_client_dev *client = &fb_helper->client;\n\tstruct drm_mode_set *modeset;\n\tint ret = 0;\n\n\tmutex_lock(&client->modeset_mutex);\n\tdrm_modeset_lock_all(fb_helper->dev);\n\tdrm_client_for_each_modeset(modeset, client) {\n\t\tmodeset->x = var->xoffset;\n\t\tmodeset->y = var->yoffset;\n\n\t\tif (modeset->num_connectors) {\n\t\t\tret = drm_mode_set_config_internal(modeset);\n\t\t\tif (!ret) {\n\t\t\t\tinfo->var.xoffset = var->xoffset;\n\t\t\t\tinfo->var.yoffset = var->yoffset;\n\t\t\t}\n\t\t}\n\t}\n\tdrm_modeset_unlock_all(fb_helper->dev);\n\tmutex_unlock(&client->modeset_mutex);\n\n\treturn ret;\n}\n\n \nint drm_fb_helper_pan_display(struct fb_var_screeninfo *var,\n\t\t\t      struct fb_info *info)\n{\n\tstruct drm_fb_helper *fb_helper = info->par;\n\tstruct drm_device *dev = fb_helper->dev;\n\tint ret;\n\n\tif (oops_in_progress)\n\t\treturn -EBUSY;\n\n\tmutex_lock(&fb_helper->lock);\n\tif (!drm_master_internal_acquire(dev)) {\n\t\tret = -EBUSY;\n\t\tgoto unlock;\n\t}\n\n\tif (drm_drv_uses_atomic_modeset(dev))\n\t\tret = pan_display_atomic(var, info);\n\telse\n\t\tret = pan_display_legacy(var, info);\n\n\tdrm_master_internal_release(dev);\nunlock:\n\tmutex_unlock(&fb_helper->lock);\n\n\treturn ret;\n}\nEXPORT_SYMBOL(drm_fb_helper_pan_display);\n\nstatic uint32_t drm_fb_helper_find_format(struct drm_fb_helper *fb_helper, const uint32_t *formats,\n\t\t\t\t\t  size_t format_count, uint32_t bpp, uint32_t depth)\n{\n\tstruct drm_device *dev = fb_helper->dev;\n\tuint32_t format;\n\tsize_t i;\n\n\t \n\tformat = drm_mode_legacy_fb_format(bpp, depth);\n\tif (!format)\n\t\tgoto err;\n\n\tfor (i = 0; i < format_count; ++i) {\n\t\tif (formats[i] == format)\n\t\t\treturn format;\n\t}\n\nerr:\n\t \n\tdrm_warn(dev, \"bpp/depth value of %u/%u not supported\\n\", bpp, depth);\n\n\treturn DRM_FORMAT_INVALID;\n}\n\nstatic uint32_t drm_fb_helper_find_color_mode_format(struct drm_fb_helper *fb_helper,\n\t\t\t\t\t\t     const uint32_t *formats, size_t format_count,\n\t\t\t\t\t\t     unsigned int color_mode)\n{\n\tstruct drm_device *dev = fb_helper->dev;\n\tuint32_t bpp, depth;\n\n\tswitch (color_mode) {\n\tcase 1:\n\tcase 2:\n\tcase 4:\n\tcase 8:\n\tcase 16:\n\tcase 24:\n\t\tbpp = depth = color_mode;\n\t\tbreak;\n\tcase 15:\n\t\tbpp = 16;\n\t\tdepth = 15;\n\t\tbreak;\n\tcase 32:\n\t\tbpp = 32;\n\t\tdepth = 24;\n\t\tbreak;\n\tdefault:\n\t\tdrm_info(dev, \"unsupported color mode of %d\\n\", color_mode);\n\t\treturn DRM_FORMAT_INVALID;\n\t}\n\n\treturn drm_fb_helper_find_format(fb_helper, formats, format_count, bpp, depth);\n}\n\nstatic int __drm_fb_helper_find_sizes(struct drm_fb_helper *fb_helper,\n\t\t\t\t      struct drm_fb_helper_surface_size *sizes)\n{\n\tstruct drm_client_dev *client = &fb_helper->client;\n\tstruct drm_device *dev = fb_helper->dev;\n\tint crtc_count = 0;\n\tstruct drm_connector_list_iter conn_iter;\n\tstruct drm_connector *connector;\n\tstruct drm_mode_set *mode_set;\n\tuint32_t surface_format = DRM_FORMAT_INVALID;\n\tconst struct drm_format_info *info;\n\n\tmemset(sizes, 0, sizeof(*sizes));\n\tsizes->fb_width = (u32)-1;\n\tsizes->fb_height = (u32)-1;\n\n\tdrm_client_for_each_modeset(mode_set, client) {\n\t\tstruct drm_crtc *crtc = mode_set->crtc;\n\t\tstruct drm_plane *plane = crtc->primary;\n\n\t\tdrm_dbg_kms(dev, \"test CRTC %u primary plane\\n\", drm_crtc_index(crtc));\n\n\t\tdrm_connector_list_iter_begin(fb_helper->dev, &conn_iter);\n\t\tdrm_client_for_each_connector_iter(connector, &conn_iter) {\n\t\t\tstruct drm_cmdline_mode *cmdline_mode = &connector->cmdline_mode;\n\n\t\t\tif (!cmdline_mode->bpp_specified)\n\t\t\t\tcontinue;\n\n\t\t\tsurface_format = drm_fb_helper_find_color_mode_format(fb_helper,\n\t\t\t\t\t\t\t\t\t      plane->format_types,\n\t\t\t\t\t\t\t\t\t      plane->format_count,\n\t\t\t\t\t\t\t\t\t      cmdline_mode->bpp);\n\t\t\tif (surface_format != DRM_FORMAT_INVALID)\n\t\t\t\tbreak;  \n\t\t}\n\t\tdrm_connector_list_iter_end(&conn_iter);\n\n\t\tif (surface_format != DRM_FORMAT_INVALID)\n\t\t\tbreak;  \n\n\t\t \n\t\tsurface_format = drm_fb_helper_find_color_mode_format(fb_helper,\n\t\t\t\t\t\t\t\t      plane->format_types,\n\t\t\t\t\t\t\t\t      plane->format_count,\n\t\t\t\t\t\t\t\t      fb_helper->preferred_bpp);\n\t\tif (surface_format != DRM_FORMAT_INVALID)\n\t\t\tbreak;  \n\t}\n\n\tif (surface_format == DRM_FORMAT_INVALID) {\n\t\t \n\t\tdrm_warn(dev, \"No compatible format found\\n\");\n\t\tsurface_format = drm_driver_legacy_fb_format(dev, 32, 24);\n\t}\n\n\tinfo = drm_format_info(surface_format);\n\tsizes->surface_bpp = drm_format_info_bpp(info, 0);\n\tsizes->surface_depth = info->depth;\n\n\t \n\tcrtc_count = 0;\n\tdrm_client_for_each_modeset(mode_set, client) {\n\t\tstruct drm_display_mode *desired_mode;\n\t\tint x, y, j;\n\t\t \n\t\tbool lastv = true, lasth = true;\n\n\t\tdesired_mode = mode_set->mode;\n\n\t\tif (!desired_mode)\n\t\t\tcontinue;\n\n\t\tcrtc_count++;\n\n\t\tx = mode_set->x;\n\t\ty = mode_set->y;\n\n\t\tsizes->surface_width  =\n\t\t\tmax_t(u32, desired_mode->hdisplay + x, sizes->surface_width);\n\t\tsizes->surface_height =\n\t\t\tmax_t(u32, desired_mode->vdisplay + y, sizes->surface_height);\n\n\t\tfor (j = 0; j < mode_set->num_connectors; j++) {\n\t\t\tstruct drm_connector *connector = mode_set->connectors[j];\n\n\t\t\tif (connector->has_tile &&\n\t\t\t    desired_mode->hdisplay == connector->tile_h_size &&\n\t\t\t    desired_mode->vdisplay == connector->tile_v_size) {\n\t\t\t\tlasth = (connector->tile_h_loc == (connector->num_h_tile - 1));\n\t\t\t\tlastv = (connector->tile_v_loc == (connector->num_v_tile - 1));\n\t\t\t\t \n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (lasth)\n\t\t\tsizes->fb_width  = min_t(u32, desired_mode->hdisplay + x, sizes->fb_width);\n\t\tif (lastv)\n\t\t\tsizes->fb_height = min_t(u32, desired_mode->vdisplay + y, sizes->fb_height);\n\t}\n\n\tif (crtc_count == 0 || sizes->fb_width == -1 || sizes->fb_height == -1) {\n\t\tdrm_info(dev, \"Cannot find any crtc or sizes\\n\");\n\t\treturn -EAGAIN;\n\t}\n\n\treturn 0;\n}\n\nstatic int drm_fb_helper_find_sizes(struct drm_fb_helper *fb_helper,\n\t\t\t\t    struct drm_fb_helper_surface_size *sizes)\n{\n\tstruct drm_client_dev *client = &fb_helper->client;\n\tstruct drm_device *dev = fb_helper->dev;\n\tstruct drm_mode_config *config = &dev->mode_config;\n\tint ret;\n\n\tmutex_lock(&client->modeset_mutex);\n\tret = __drm_fb_helper_find_sizes(fb_helper, sizes);\n\tmutex_unlock(&client->modeset_mutex);\n\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tsizes->surface_height *= drm_fbdev_overalloc;\n\tsizes->surface_height /= 100;\n\tif (sizes->surface_height > config->max_height) {\n\t\tdrm_dbg_kms(dev, \"Fbdev over-allocation too large; clamping height to %d\\n\",\n\t\t\t    config->max_height);\n\t\tsizes->surface_height = config->max_height;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int drm_fb_helper_single_fb_probe(struct drm_fb_helper *fb_helper)\n{\n\tstruct drm_client_dev *client = &fb_helper->client;\n\tstruct drm_device *dev = fb_helper->dev;\n\tstruct drm_fb_helper_surface_size sizes;\n\tint ret;\n\n\tret = drm_fb_helper_find_sizes(fb_helper, &sizes);\n\tif (ret) {\n\t\t \n\t\tif (!fb_helper->deferred_setup)\n\t\t\tdrm_client_modeset_commit(client);\n\t\treturn ret;\n\t}\n\n\t \n\tret = (*fb_helper->funcs->fb_probe)(fb_helper, &sizes);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tstrcpy(fb_helper->fb->comm, \"[fbcon]\");\n\n\t \n\tif (dev_is_pci(dev->dev))\n\t\tvga_switcheroo_client_fb_set(to_pci_dev(dev->dev), fb_helper->info);\n\n\treturn 0;\n}\n\nstatic void drm_fb_helper_fill_fix(struct fb_info *info, uint32_t pitch,\n\t\t\t\t   bool is_color_indexed)\n{\n\tinfo->fix.type = FB_TYPE_PACKED_PIXELS;\n\tinfo->fix.visual = is_color_indexed ? FB_VISUAL_PSEUDOCOLOR\n\t\t\t\t\t    : FB_VISUAL_TRUECOLOR;\n\tinfo->fix.mmio_start = 0;\n\tinfo->fix.mmio_len = 0;\n\tinfo->fix.type_aux = 0;\n\tinfo->fix.xpanstep = 1;  \n\tinfo->fix.ypanstep = 1;  \n\tinfo->fix.ywrapstep = 0;\n\tinfo->fix.accel = FB_ACCEL_NONE;\n\n\tinfo->fix.line_length = pitch;\n}\n\nstatic void drm_fb_helper_fill_var(struct fb_info *info,\n\t\t\t\t   struct drm_fb_helper *fb_helper,\n\t\t\t\t   uint32_t fb_width, uint32_t fb_height)\n{\n\tstruct drm_framebuffer *fb = fb_helper->fb;\n\tconst struct drm_format_info *format = fb->format;\n\n\tswitch (format->format) {\n\tcase DRM_FORMAT_C1:\n\tcase DRM_FORMAT_C2:\n\tcase DRM_FORMAT_C4:\n\t\t \n\t\tbreak;\n\n\tdefault:\n\t\tWARN_ON((drm_format_info_block_width(format, 0) > 1) ||\n\t\t\t(drm_format_info_block_height(format, 0) > 1));\n\t\tbreak;\n\t}\n\n\tinfo->pseudo_palette = fb_helper->pseudo_palette;\n\tinfo->var.xoffset = 0;\n\tinfo->var.yoffset = 0;\n\t__fill_var(&info->var, info, fb);\n\tinfo->var.activate = FB_ACTIVATE_NOW;\n\n\tdrm_fb_helper_fill_pixel_fmt(&info->var, format);\n\n\tinfo->var.xres = fb_width;\n\tinfo->var.yres = fb_height;\n}\n\n \nvoid drm_fb_helper_fill_info(struct fb_info *info,\n\t\t\t     struct drm_fb_helper *fb_helper,\n\t\t\t     struct drm_fb_helper_surface_size *sizes)\n{\n\tstruct drm_framebuffer *fb = fb_helper->fb;\n\n\tdrm_fb_helper_fill_fix(info, fb->pitches[0],\n\t\t\t       fb->format->is_color_indexed);\n\tdrm_fb_helper_fill_var(info, fb_helper,\n\t\t\t       sizes->fb_width, sizes->fb_height);\n\n\tinfo->par = fb_helper;\n\t \n\tsnprintf(info->fix.id, sizeof(info->fix.id), \"%sdrmfb\",\n\t\t fb_helper->dev->driver->name);\n\n}\nEXPORT_SYMBOL(drm_fb_helper_fill_info);\n\n \nstatic void drm_setup_crtcs_fb(struct drm_fb_helper *fb_helper)\n{\n\tstruct drm_client_dev *client = &fb_helper->client;\n\tstruct drm_connector_list_iter conn_iter;\n\tstruct fb_info *info = fb_helper->info;\n\tunsigned int rotation, sw_rotations = 0;\n\tstruct drm_connector *connector;\n\tstruct drm_mode_set *modeset;\n\n\tmutex_lock(&client->modeset_mutex);\n\tdrm_client_for_each_modeset(modeset, client) {\n\t\tif (!modeset->num_connectors)\n\t\t\tcontinue;\n\n\t\tmodeset->fb = fb_helper->fb;\n\n\t\tif (drm_client_rotation(modeset, &rotation))\n\t\t\t \n\t\t\tsw_rotations |= DRM_MODE_ROTATE_0;\n\t\telse\n\t\t\tsw_rotations |= rotation;\n\t}\n\tmutex_unlock(&client->modeset_mutex);\n\n\tdrm_connector_list_iter_begin(fb_helper->dev, &conn_iter);\n\tdrm_client_for_each_connector_iter(connector, &conn_iter) {\n\n\t\t \n\t\tif (connector->status == connector_status_connected) {\n\t\t\tinfo->var.width = connector->display_info.width_mm;\n\t\t\tinfo->var.height = connector->display_info.height_mm;\n\t\t\tbreak;\n\t\t}\n\t}\n\tdrm_connector_list_iter_end(&conn_iter);\n\n\tswitch (sw_rotations) {\n\tcase DRM_MODE_ROTATE_0:\n\t\tinfo->fbcon_rotate_hint = FB_ROTATE_UR;\n\t\tbreak;\n\tcase DRM_MODE_ROTATE_90:\n\t\tinfo->fbcon_rotate_hint = FB_ROTATE_CCW;\n\t\tbreak;\n\tcase DRM_MODE_ROTATE_180:\n\t\tinfo->fbcon_rotate_hint = FB_ROTATE_UD;\n\t\tbreak;\n\tcase DRM_MODE_ROTATE_270:\n\t\tinfo->fbcon_rotate_hint = FB_ROTATE_CW;\n\t\tbreak;\n\tdefault:\n\t\t \n\t\tinfo->fbcon_rotate_hint = FB_ROTATE_UR;\n\t}\n}\n\n \nstatic int\n__drm_fb_helper_initial_config_and_unlock(struct drm_fb_helper *fb_helper)\n{\n\tstruct drm_device *dev = fb_helper->dev;\n\tstruct fb_info *info;\n\tunsigned int width, height;\n\tint ret;\n\n\twidth = dev->mode_config.max_width;\n\theight = dev->mode_config.max_height;\n\n\tdrm_client_modeset_probe(&fb_helper->client, width, height);\n\tret = drm_fb_helper_single_fb_probe(fb_helper);\n\tif (ret < 0) {\n\t\tif (ret == -EAGAIN) {\n\t\t\tfb_helper->deferred_setup = true;\n\t\t\tret = 0;\n\t\t}\n\t\tmutex_unlock(&fb_helper->lock);\n\n\t\treturn ret;\n\t}\n\tdrm_setup_crtcs_fb(fb_helper);\n\n\tfb_helper->deferred_setup = false;\n\n\tinfo = fb_helper->info;\n\tinfo->var.pixclock = 0;\n\n\tif (!drm_leak_fbdev_smem)\n\t\tinfo->flags |= FBINFO_HIDE_SMEM_START;\n\n\t \n\tmutex_unlock(&fb_helper->lock);\n\n\tret = register_framebuffer(info);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tdrm_info(dev, \"fb%d: %s frame buffer device\\n\",\n\t\t info->node, info->fix.id);\n\n\tmutex_lock(&kernel_fb_helper_lock);\n\tif (list_empty(&kernel_fb_helper_list))\n\t\tregister_sysrq_key('v', &sysrq_drm_fb_helper_restore_op);\n\n\tlist_add(&fb_helper->kernel_fb_list, &kernel_fb_helper_list);\n\tmutex_unlock(&kernel_fb_helper_lock);\n\n\treturn 0;\n}\n\n \nint drm_fb_helper_initial_config(struct drm_fb_helper *fb_helper)\n{\n\tint ret;\n\n\tif (!drm_fbdev_emulation)\n\t\treturn 0;\n\n\tmutex_lock(&fb_helper->lock);\n\tret = __drm_fb_helper_initial_config_and_unlock(fb_helper);\n\n\treturn ret;\n}\nEXPORT_SYMBOL(drm_fb_helper_initial_config);\n\n \nint drm_fb_helper_hotplug_event(struct drm_fb_helper *fb_helper)\n{\n\tint err = 0;\n\n\tif (!drm_fbdev_emulation || !fb_helper)\n\t\treturn 0;\n\n\tmutex_lock(&fb_helper->lock);\n\tif (fb_helper->deferred_setup) {\n\t\terr = __drm_fb_helper_initial_config_and_unlock(fb_helper);\n\t\treturn err;\n\t}\n\n\tif (!fb_helper->fb || !drm_master_internal_acquire(fb_helper->dev)) {\n\t\tfb_helper->delayed_hotplug = true;\n\t\tmutex_unlock(&fb_helper->lock);\n\t\treturn err;\n\t}\n\n\tdrm_master_internal_release(fb_helper->dev);\n\n\tdrm_dbg_kms(fb_helper->dev, \"\\n\");\n\n\tdrm_client_modeset_probe(&fb_helper->client, fb_helper->fb->width, fb_helper->fb->height);\n\tdrm_setup_crtcs_fb(fb_helper);\n\tmutex_unlock(&fb_helper->lock);\n\n\tdrm_fb_helper_set_par(fb_helper->info);\n\n\treturn 0;\n}\nEXPORT_SYMBOL(drm_fb_helper_hotplug_event);\n\n \nvoid drm_fb_helper_lastclose(struct drm_device *dev)\n{\n\tdrm_fb_helper_restore_fbdev_mode_unlocked(dev->fb_helper);\n}\nEXPORT_SYMBOL(drm_fb_helper_lastclose);\n\n \nvoid drm_fb_helper_output_poll_changed(struct drm_device *dev)\n{\n\tdrm_fb_helper_hotplug_event(dev->fb_helper);\n}\nEXPORT_SYMBOL(drm_fb_helper_output_poll_changed);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}