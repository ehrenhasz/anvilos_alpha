{
  "module_name": "sun6i_mipi_dsi.c",
  "hash_id": "2222e4f65823932296c8bd68826c7dc91aff5a8eab88115a9e1876d3b4a8ac82",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/sun4i/sun6i_mipi_dsi.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/component.h>\n#include <linux/crc-ccitt.h>\n#include <linux/module.h>\n#include <linux/of_address.h>\n#include <linux/phy/phy-mipi-dphy.h>\n#include <linux/phy/phy.h>\n#include <linux/platform_device.h>\n#include <linux/regmap.h>\n#include <linux/regulator/consumer.h>\n#include <linux/reset.h>\n#include <linux/slab.h>\n\n#include <drm/drm_atomic_helper.h>\n#include <drm/drm_mipi_dsi.h>\n#include <drm/drm_panel.h>\n#include <drm/drm_print.h>\n#include <drm/drm_probe_helper.h>\n#include <drm/drm_simple_kms_helper.h>\n\n#include \"sun4i_crtc.h\"\n#include \"sun4i_tcon.h\"\n#include \"sun6i_mipi_dsi.h\"\n\n#include <video/mipi_display.h>\n\n#define SUN6I_DSI_CTL_REG\t\t0x000\n#define SUN6I_DSI_CTL_EN\t\t\tBIT(0)\n\n#define SUN6I_DSI_BASIC_CTL_REG\t\t0x00c\n#define SUN6I_DSI_BASIC_CTL_TRAIL_INV(n)\t\t(((n) & 0xf) << 4)\n#define SUN6I_DSI_BASIC_CTL_TRAIL_FILL\t\tBIT(3)\n#define SUN6I_DSI_BASIC_CTL_HBP_DIS\t\tBIT(2)\n#define SUN6I_DSI_BASIC_CTL_HSA_HSE_DIS\t\tBIT(1)\n#define SUN6I_DSI_BASIC_CTL_VIDEO_BURST\t\tBIT(0)\n\n#define SUN6I_DSI_BASIC_CTL0_REG\t0x010\n#define SUN6I_DSI_BASIC_CTL0_HS_EOTP_EN\t\tBIT(18)\n#define SUN6I_DSI_BASIC_CTL0_CRC_EN\t\tBIT(17)\n#define SUN6I_DSI_BASIC_CTL0_ECC_EN\t\tBIT(16)\n#define SUN6I_DSI_BASIC_CTL0_INST_ST\t\tBIT(0)\n\n#define SUN6I_DSI_BASIC_CTL1_REG\t0x014\n#define SUN6I_DSI_BASIC_CTL1_VIDEO_ST_DELAY(n)\t(((n) & 0x1fff) << 4)\n#define SUN6I_DSI_BASIC_CTL1_VIDEO_FILL\t\tBIT(2)\n#define SUN6I_DSI_BASIC_CTL1_VIDEO_PRECISION\tBIT(1)\n#define SUN6I_DSI_BASIC_CTL1_VIDEO_MODE\t\tBIT(0)\n\n#define SUN6I_DSI_BASIC_SIZE0_REG\t0x018\n#define SUN6I_DSI_BASIC_SIZE0_VBP(n)\t\t(((n) & 0xfff) << 16)\n#define SUN6I_DSI_BASIC_SIZE0_VSA(n)\t\t((n) & 0xfff)\n\n#define SUN6I_DSI_BASIC_SIZE1_REG\t0x01c\n#define SUN6I_DSI_BASIC_SIZE1_VT(n)\t\t(((n) & 0xfff) << 16)\n#define SUN6I_DSI_BASIC_SIZE1_VACT(n)\t\t((n) & 0xfff)\n\n#define SUN6I_DSI_INST_FUNC_REG(n)\t(0x020 + (n) * 0x04)\n#define SUN6I_DSI_INST_FUNC_INST_MODE(n)\t(((n) & 0xf) << 28)\n#define SUN6I_DSI_INST_FUNC_ESCAPE_ENTRY(n)\t(((n) & 0xf) << 24)\n#define SUN6I_DSI_INST_FUNC_TRANS_PACKET(n)\t(((n) & 0xf) << 20)\n#define SUN6I_DSI_INST_FUNC_LANE_CEN\t\tBIT(4)\n#define SUN6I_DSI_INST_FUNC_LANE_DEN(n)\t\t((n) & 0xf)\n\n#define SUN6I_DSI_INST_LOOP_SEL_REG\t0x040\n\n#define SUN6I_DSI_INST_LOOP_NUM_REG(n)\t(0x044 + (n) * 0x10)\n#define SUN6I_DSI_INST_LOOP_NUM_N1(n)\t\t(((n) & 0xfff) << 16)\n#define SUN6I_DSI_INST_LOOP_NUM_N0(n)\t\t((n) & 0xfff)\n\n#define SUN6I_DSI_INST_JUMP_SEL_REG\t0x048\n\n#define SUN6I_DSI_INST_JUMP_CFG_REG(n)\t(0x04c + (n) * 0x04)\n#define SUN6I_DSI_INST_JUMP_CFG_TO(n)\t\t(((n) & 0xf) << 20)\n#define SUN6I_DSI_INST_JUMP_CFG_POINT(n)\t(((n) & 0xf) << 16)\n#define SUN6I_DSI_INST_JUMP_CFG_NUM(n)\t\t((n) & 0xffff)\n\n#define SUN6I_DSI_TRANS_START_REG\t0x060\n\n#define SUN6I_DSI_TRANS_ZERO_REG\t0x078\n\n#define SUN6I_DSI_TCON_DRQ_REG\t\t0x07c\n#define SUN6I_DSI_TCON_DRQ_ENABLE_MODE\t\tBIT(28)\n#define SUN6I_DSI_TCON_DRQ_SET(n)\t\t((n) & 0x3ff)\n\n#define SUN6I_DSI_PIXEL_CTL0_REG\t0x080\n#define SUN6I_DSI_PIXEL_CTL0_PD_PLUG_DISABLE\tBIT(16)\n#define SUN6I_DSI_PIXEL_CTL0_FORMAT(n)\t\t((n) & 0xf)\n\n#define SUN6I_DSI_PIXEL_CTL1_REG\t0x084\n\n#define SUN6I_DSI_PIXEL_PH_REG\t\t0x090\n#define SUN6I_DSI_PIXEL_PH_ECC(n)\t\t(((n) & 0xff) << 24)\n#define SUN6I_DSI_PIXEL_PH_WC(n)\t\t(((n) & 0xffff) << 8)\n#define SUN6I_DSI_PIXEL_PH_VC(n)\t\t(((n) & 3) << 6)\n#define SUN6I_DSI_PIXEL_PH_DT(n)\t\t((n) & 0x3f)\n\n#define SUN6I_DSI_PIXEL_PF0_REG\t\t0x098\n#define SUN6I_DSI_PIXEL_PF0_CRC_FORCE(n)\t((n) & 0xffff)\n\n#define SUN6I_DSI_PIXEL_PF1_REG\t\t0x09c\n#define SUN6I_DSI_PIXEL_PF1_CRC_INIT_LINEN(n)\t(((n) & 0xffff) << 16)\n#define SUN6I_DSI_PIXEL_PF1_CRC_INIT_LINE0(n)\t((n) & 0xffff)\n\n#define SUN6I_DSI_SYNC_HSS_REG\t\t0x0b0\n\n#define SUN6I_DSI_SYNC_HSE_REG\t\t0x0b4\n\n#define SUN6I_DSI_SYNC_VSS_REG\t\t0x0b8\n\n#define SUN6I_DSI_SYNC_VSE_REG\t\t0x0bc\n\n#define SUN6I_DSI_BLK_HSA0_REG\t\t0x0c0\n\n#define SUN6I_DSI_BLK_HSA1_REG\t\t0x0c4\n#define SUN6I_DSI_BLK_PF(n)\t\t\t(((n) & 0xffff) << 16)\n#define SUN6I_DSI_BLK_PD(n)\t\t\t((n) & 0xff)\n\n#define SUN6I_DSI_BLK_HBP0_REG\t\t0x0c8\n\n#define SUN6I_DSI_BLK_HBP1_REG\t\t0x0cc\n\n#define SUN6I_DSI_BLK_HFP0_REG\t\t0x0d0\n\n#define SUN6I_DSI_BLK_HFP1_REG\t\t0x0d4\n\n#define SUN6I_DSI_BLK_HBLK0_REG\t\t0x0e0\n\n#define SUN6I_DSI_BLK_HBLK1_REG\t\t0x0e4\n\n#define SUN6I_DSI_BLK_VBLK0_REG\t\t0x0e8\n\n#define SUN6I_DSI_BLK_VBLK1_REG\t\t0x0ec\n\n#define SUN6I_DSI_BURST_LINE_REG\t0x0f0\n#define SUN6I_DSI_BURST_LINE_SYNC_POINT(n)\t(((n) & 0xffff) << 16)\n#define SUN6I_DSI_BURST_LINE_NUM(n)\t\t((n) & 0xffff)\n\n#define SUN6I_DSI_BURST_DRQ_REG\t\t0x0f4\n#define SUN6I_DSI_BURST_DRQ_EDGE1(n)\t\t(((n) & 0xffff) << 16)\n#define SUN6I_DSI_BURST_DRQ_EDGE0(n)\t\t((n) & 0xffff)\n\n#define SUN6I_DSI_CMD_CTL_REG\t\t0x200\n#define SUN6I_DSI_CMD_CTL_RX_OVERFLOW\t\tBIT(26)\n#define SUN6I_DSI_CMD_CTL_RX_FLAG\t\tBIT(25)\n#define SUN6I_DSI_CMD_CTL_TX_FLAG\t\tBIT(9)\n\n#define SUN6I_DSI_CMD_RX_REG(n)\t\t(0x240 + (n) * 0x04)\n\n#define SUN6I_DSI_DEBUG_DATA_REG\t0x2f8\n\n#define SUN6I_DSI_CMD_TX_REG(n)\t\t(0x300 + (n) * 0x04)\n\n#define SUN6I_DSI_SYNC_POINT\t\t40\n\nenum sun6i_dsi_start_inst {\n\tDSI_START_LPRX,\n\tDSI_START_LPTX,\n\tDSI_START_HSC,\n\tDSI_START_HSD,\n};\n\nenum sun6i_dsi_inst_id {\n\tDSI_INST_ID_LP11\t= 0,\n\tDSI_INST_ID_TBA,\n\tDSI_INST_ID_HSC,\n\tDSI_INST_ID_HSD,\n\tDSI_INST_ID_LPDT,\n\tDSI_INST_ID_HSCEXIT,\n\tDSI_INST_ID_NOP,\n\tDSI_INST_ID_DLY,\n\tDSI_INST_ID_END\t\t= 15,\n};\n\nenum sun6i_dsi_inst_mode {\n\tDSI_INST_MODE_STOP\t= 0,\n\tDSI_INST_MODE_TBA,\n\tDSI_INST_MODE_HS,\n\tDSI_INST_MODE_ESCAPE,\n\tDSI_INST_MODE_HSCEXIT,\n\tDSI_INST_MODE_NOP,\n};\n\nenum sun6i_dsi_inst_escape {\n\tDSI_INST_ESCA_LPDT\t= 0,\n\tDSI_INST_ESCA_ULPS,\n\tDSI_INST_ESCA_UN1,\n\tDSI_INST_ESCA_UN2,\n\tDSI_INST_ESCA_RESET,\n\tDSI_INST_ESCA_UN3,\n\tDSI_INST_ESCA_UN4,\n\tDSI_INST_ESCA_UN5,\n};\n\nenum sun6i_dsi_inst_packet {\n\tDSI_INST_PACK_PIXEL\t= 0,\n\tDSI_INST_PACK_COMMAND,\n};\n\nstatic const u32 sun6i_dsi_ecc_array[] = {\n\t[0] = (BIT(0) | BIT(1) | BIT(2) | BIT(4) | BIT(5) | BIT(7) | BIT(10) |\n\t       BIT(11) | BIT(13) | BIT(16) | BIT(20) | BIT(21) | BIT(22) |\n\t       BIT(23)),\n\t[1] = (BIT(0) | BIT(1) | BIT(3) | BIT(4) | BIT(6) | BIT(8) | BIT(10) |\n\t       BIT(12) | BIT(14) | BIT(17) | BIT(20) | BIT(21) | BIT(22) |\n\t       BIT(23)),\n\t[2] = (BIT(0) | BIT(2) | BIT(3) | BIT(5) | BIT(6) | BIT(9) | BIT(11) |\n\t       BIT(12) | BIT(15) | BIT(18) | BIT(20) | BIT(21) | BIT(22)),\n\t[3] = (BIT(1) | BIT(2) | BIT(3) | BIT(7) | BIT(8) | BIT(9) | BIT(13) |\n\t       BIT(14) | BIT(15) | BIT(19) | BIT(20) | BIT(21) | BIT(23)),\n\t[4] = (BIT(4) | BIT(5) | BIT(6) | BIT(7) | BIT(8) | BIT(9) | BIT(16) |\n\t       BIT(17) | BIT(18) | BIT(19) | BIT(20) | BIT(22) | BIT(23)),\n\t[5] = (BIT(10) | BIT(11) | BIT(12) | BIT(13) | BIT(14) | BIT(15) |\n\t       BIT(16) | BIT(17) | BIT(18) | BIT(19) | BIT(21) | BIT(22) |\n\t       BIT(23)),\n};\n\nstatic u32 sun6i_dsi_ecc_compute(unsigned int data)\n{\n\tint i;\n\tu8 ecc = 0;\n\n\tfor (i = 0; i < ARRAY_SIZE(sun6i_dsi_ecc_array); i++) {\n\t\tu32 field = sun6i_dsi_ecc_array[i];\n\t\tbool init = false;\n\t\tu8 val = 0;\n\t\tint j;\n\n\t\tfor (j = 0; j < 24; j++) {\n\t\t\tif (!(BIT(j) & field))\n\t\t\t\tcontinue;\n\n\t\t\tif (!init) {\n\t\t\t\tval = (BIT(j) & data) ? 1 : 0;\n\t\t\t\tinit = true;\n\t\t\t} else {\n\t\t\t\tval ^= (BIT(j) & data) ? 1 : 0;\n\t\t\t}\n\t\t}\n\n\t\tecc |= val << i;\n\t}\n\n\treturn ecc;\n}\n\nstatic u16 sun6i_dsi_crc_compute(u8 const *buffer, size_t len)\n{\n\treturn crc_ccitt(0xffff, buffer, len);\n}\n\nstatic u16 sun6i_dsi_crc_repeat(u8 pd, u8 *buffer, size_t len)\n{\n\tmemset(buffer, pd, len);\n\n\treturn sun6i_dsi_crc_compute(buffer, len);\n}\n\nstatic u32 sun6i_dsi_build_sync_pkt(u8 dt, u8 vc, u8 d0, u8 d1)\n{\n\tu32 val = dt & 0x3f;\n\n\tval |= (vc & 3) << 6;\n\tval |= (d0 & 0xff) << 8;\n\tval |= (d1 & 0xff) << 16;\n\tval |= sun6i_dsi_ecc_compute(val) << 24;\n\n\treturn val;\n}\n\nstatic u32 sun6i_dsi_build_blk0_pkt(u8 vc, u16 wc)\n{\n\treturn sun6i_dsi_build_sync_pkt(MIPI_DSI_BLANKING_PACKET, vc,\n\t\t\t\t\twc & 0xff, wc >> 8);\n}\n\nstatic u32 sun6i_dsi_build_blk1_pkt(u16 pd, u8 *buffer, size_t len)\n{\n\tu32 val = SUN6I_DSI_BLK_PD(pd);\n\n\treturn val | SUN6I_DSI_BLK_PF(sun6i_dsi_crc_repeat(pd, buffer, len));\n}\n\nstatic void sun6i_dsi_inst_abort(struct sun6i_dsi *dsi)\n{\n\tregmap_update_bits(dsi->regs, SUN6I_DSI_BASIC_CTL0_REG,\n\t\t\t   SUN6I_DSI_BASIC_CTL0_INST_ST, 0);\n}\n\nstatic void sun6i_dsi_inst_commit(struct sun6i_dsi *dsi)\n{\n\tregmap_update_bits(dsi->regs, SUN6I_DSI_BASIC_CTL0_REG,\n\t\t\t   SUN6I_DSI_BASIC_CTL0_INST_ST,\n\t\t\t   SUN6I_DSI_BASIC_CTL0_INST_ST);\n}\n\nstatic int sun6i_dsi_inst_wait_for_completion(struct sun6i_dsi *dsi)\n{\n\tu32 val;\n\n\treturn regmap_read_poll_timeout(dsi->regs, SUN6I_DSI_BASIC_CTL0_REG,\n\t\t\t\t\tval,\n\t\t\t\t\t!(val & SUN6I_DSI_BASIC_CTL0_INST_ST),\n\t\t\t\t\t100, 5000);\n}\n\nstatic void sun6i_dsi_inst_setup(struct sun6i_dsi *dsi,\n\t\t\t\t enum sun6i_dsi_inst_id id,\n\t\t\t\t enum sun6i_dsi_inst_mode mode,\n\t\t\t\t bool clock, u8 data,\n\t\t\t\t enum sun6i_dsi_inst_packet packet,\n\t\t\t\t enum sun6i_dsi_inst_escape escape)\n{\n\tregmap_write(dsi->regs, SUN6I_DSI_INST_FUNC_REG(id),\n\t\t     SUN6I_DSI_INST_FUNC_INST_MODE(mode) |\n\t\t     SUN6I_DSI_INST_FUNC_ESCAPE_ENTRY(escape) |\n\t\t     SUN6I_DSI_INST_FUNC_TRANS_PACKET(packet) |\n\t\t     (clock ? SUN6I_DSI_INST_FUNC_LANE_CEN : 0) |\n\t\t     SUN6I_DSI_INST_FUNC_LANE_DEN(data));\n}\n\nstatic void sun6i_dsi_inst_init(struct sun6i_dsi *dsi,\n\t\t\t\tstruct mipi_dsi_device *device)\n{\n\tu8 lanes_mask = GENMASK(device->lanes - 1, 0);\n\n\tsun6i_dsi_inst_setup(dsi, DSI_INST_ID_LP11, DSI_INST_MODE_STOP,\n\t\t\t     true, lanes_mask, 0, 0);\n\n\tsun6i_dsi_inst_setup(dsi, DSI_INST_ID_TBA, DSI_INST_MODE_TBA,\n\t\t\t     false, 1, 0, 0);\n\n\tsun6i_dsi_inst_setup(dsi, DSI_INST_ID_HSC, DSI_INST_MODE_HS,\n\t\t\t     true, 0, DSI_INST_PACK_PIXEL, 0);\n\n\tsun6i_dsi_inst_setup(dsi, DSI_INST_ID_HSD, DSI_INST_MODE_HS,\n\t\t\t     false, lanes_mask, DSI_INST_PACK_PIXEL, 0);\n\n\tsun6i_dsi_inst_setup(dsi, DSI_INST_ID_LPDT, DSI_INST_MODE_ESCAPE,\n\t\t\t     false, 1, DSI_INST_PACK_COMMAND,\n\t\t\t     DSI_INST_ESCA_LPDT);\n\n\tsun6i_dsi_inst_setup(dsi, DSI_INST_ID_HSCEXIT, DSI_INST_MODE_HSCEXIT,\n\t\t\t     true, 0, 0, 0);\n\n\tsun6i_dsi_inst_setup(dsi, DSI_INST_ID_NOP, DSI_INST_MODE_STOP,\n\t\t\t     false, lanes_mask, 0, 0);\n\n\tsun6i_dsi_inst_setup(dsi, DSI_INST_ID_DLY, DSI_INST_MODE_NOP,\n\t\t\t     true, lanes_mask, 0, 0);\n\n\tregmap_write(dsi->regs, SUN6I_DSI_INST_JUMP_CFG_REG(0),\n\t\t     SUN6I_DSI_INST_JUMP_CFG_POINT(DSI_INST_ID_NOP) |\n\t\t     SUN6I_DSI_INST_JUMP_CFG_TO(DSI_INST_ID_HSCEXIT) |\n\t\t     SUN6I_DSI_INST_JUMP_CFG_NUM(1));\n};\n\nstatic u16 sun6i_dsi_get_video_start_delay(struct sun6i_dsi *dsi,\n\t\t\t\t\t   struct drm_display_mode *mode)\n{\n\tu16 delay = mode->vtotal - (mode->vsync_start - mode->vdisplay) + 1;\n\n\tif (delay > mode->vtotal)\n\t\tdelay = delay % mode->vtotal;\n\n\treturn max_t(u16, delay, 1);\n}\n\nstatic u16 sun6i_dsi_get_line_num(struct sun6i_dsi *dsi,\n\t\t\t\t  struct drm_display_mode *mode)\n{\n\tstruct mipi_dsi_device *device = dsi->device;\n\tunsigned int Bpp = mipi_dsi_pixel_format_to_bpp(device->format) / 8;\n\n\treturn mode->htotal * Bpp / device->lanes;\n}\n\nstatic u16 sun6i_dsi_get_drq_edge0(struct sun6i_dsi *dsi,\n\t\t\t\t   struct drm_display_mode *mode,\n\t\t\t\t   u16 line_num, u16 edge1)\n{\n\tu16 edge0 = edge1;\n\n\tedge0 += (mode->hdisplay + 40) * SUN6I_DSI_TCON_DIV / 8;\n\n\tif (edge0 > line_num)\n\t\treturn edge0 - line_num;\n\n\treturn 1;\n}\n\nstatic u16 sun6i_dsi_get_drq_edge1(struct sun6i_dsi *dsi,\n\t\t\t\t   struct drm_display_mode *mode,\n\t\t\t\t   u16 line_num)\n{\n\tstruct mipi_dsi_device *device = dsi->device;\n\tunsigned int Bpp = mipi_dsi_pixel_format_to_bpp(device->format) / 8;\n\tunsigned int hbp = mode->htotal - mode->hsync_end;\n\tu16 edge1;\n\n\tedge1 = SUN6I_DSI_SYNC_POINT;\n\tedge1 += (mode->hdisplay + hbp + 20) * Bpp / device->lanes;\n\n\tif (edge1 > line_num)\n\t\treturn line_num;\n\n\treturn edge1;\n}\n\nstatic void sun6i_dsi_setup_burst(struct sun6i_dsi *dsi,\n\t\t\t\t  struct drm_display_mode *mode)\n{\n\tstruct mipi_dsi_device *device = dsi->device;\n\tu32 val = 0;\n\n\tif (device->mode_flags & MIPI_DSI_MODE_VIDEO_BURST) {\n\t\tu16 line_num = sun6i_dsi_get_line_num(dsi, mode);\n\t\tu16 edge0, edge1;\n\n\t\tedge1 = sun6i_dsi_get_drq_edge1(dsi, mode, line_num);\n\t\tedge0 = sun6i_dsi_get_drq_edge0(dsi, mode, line_num, edge1);\n\n\t\tregmap_write(dsi->regs, SUN6I_DSI_BURST_DRQ_REG,\n\t\t\t     SUN6I_DSI_BURST_DRQ_EDGE0(edge0) |\n\t\t\t     SUN6I_DSI_BURST_DRQ_EDGE1(edge1));\n\n\t\tregmap_write(dsi->regs, SUN6I_DSI_BURST_LINE_REG,\n\t\t\t     SUN6I_DSI_BURST_LINE_NUM(line_num) |\n\t\t\t     SUN6I_DSI_BURST_LINE_SYNC_POINT(SUN6I_DSI_SYNC_POINT));\n\n\t\tval = SUN6I_DSI_TCON_DRQ_ENABLE_MODE;\n\t} else if ((mode->hsync_start - mode->hdisplay) > 20) {\n\t\t \n\t\tu16 drq = (mode->hsync_start - mode->hdisplay) - 20;\n\n\t\tdrq *= mipi_dsi_pixel_format_to_bpp(device->format);\n\t\tdrq /= 32;\n\n\t\tval = (SUN6I_DSI_TCON_DRQ_ENABLE_MODE |\n\t\t       SUN6I_DSI_TCON_DRQ_SET(drq));\n\t}\n\n\tregmap_write(dsi->regs, SUN6I_DSI_TCON_DRQ_REG, val);\n}\n\nstatic void sun6i_dsi_setup_inst_loop(struct sun6i_dsi *dsi,\n\t\t\t\t      struct drm_display_mode *mode)\n{\n\tstruct mipi_dsi_device *device = dsi->device;\n\tu16 delay = 50 - 1;\n\n\tif (device->mode_flags & MIPI_DSI_MODE_VIDEO_BURST) {\n\t\tu32 hsync_porch = (mode->htotal - mode->hdisplay) * 150;\n\n\t\tdelay = (hsync_porch / ((mode->clock / 1000) * 8));\n\t\tdelay -= 50;\n\t}\n\n\tregmap_write(dsi->regs, SUN6I_DSI_INST_LOOP_SEL_REG,\n\t\t     2 << (4 * DSI_INST_ID_LP11) |\n\t\t     3 << (4 * DSI_INST_ID_DLY));\n\n\tregmap_write(dsi->regs, SUN6I_DSI_INST_LOOP_NUM_REG(0),\n\t\t     SUN6I_DSI_INST_LOOP_NUM_N0(50 - 1) |\n\t\t     SUN6I_DSI_INST_LOOP_NUM_N1(delay));\n\tregmap_write(dsi->regs, SUN6I_DSI_INST_LOOP_NUM_REG(1),\n\t\t     SUN6I_DSI_INST_LOOP_NUM_N0(50 - 1) |\n\t\t     SUN6I_DSI_INST_LOOP_NUM_N1(delay));\n}\n\nstatic void sun6i_dsi_setup_format(struct sun6i_dsi *dsi,\n\t\t\t\t   struct drm_display_mode *mode)\n{\n\tstruct mipi_dsi_device *device = dsi->device;\n\tu32 val = SUN6I_DSI_PIXEL_PH_VC(device->channel);\n\tu8 dt, fmt;\n\tu16 wc;\n\n\t \n\tswitch (device->format) {\n\tcase MIPI_DSI_FMT_RGB888:\n\t\tdt = MIPI_DSI_PACKED_PIXEL_STREAM_24;\n\t\tfmt = 8;\n\t\tbreak;\n\tcase MIPI_DSI_FMT_RGB666:\n\t\tdt = MIPI_DSI_PIXEL_STREAM_3BYTE_18;\n\t\tfmt = 9;\n\t\tbreak;\n\tcase MIPI_DSI_FMT_RGB666_PACKED:\n\t\tdt = MIPI_DSI_PACKED_PIXEL_STREAM_18;\n\t\tfmt = 10;\n\t\tbreak;\n\tcase MIPI_DSI_FMT_RGB565:\n\t\tdt = MIPI_DSI_PACKED_PIXEL_STREAM_16;\n\t\tfmt = 11;\n\t\tbreak;\n\tdefault:\n\t\treturn;\n\t}\n\tval |= SUN6I_DSI_PIXEL_PH_DT(dt);\n\n\twc = mode->hdisplay * mipi_dsi_pixel_format_to_bpp(device->format) / 8;\n\tval |= SUN6I_DSI_PIXEL_PH_WC(wc);\n\tval |= SUN6I_DSI_PIXEL_PH_ECC(sun6i_dsi_ecc_compute(val));\n\n\tregmap_write(dsi->regs, SUN6I_DSI_PIXEL_PH_REG, val);\n\n\tregmap_write(dsi->regs, SUN6I_DSI_PIXEL_PF0_REG,\n\t\t     SUN6I_DSI_PIXEL_PF0_CRC_FORCE(0xffff));\n\n\tregmap_write(dsi->regs, SUN6I_DSI_PIXEL_PF1_REG,\n\t\t     SUN6I_DSI_PIXEL_PF1_CRC_INIT_LINE0(0xffff) |\n\t\t     SUN6I_DSI_PIXEL_PF1_CRC_INIT_LINEN(0xffff));\n\n\tregmap_write(dsi->regs, SUN6I_DSI_PIXEL_CTL0_REG,\n\t\t     SUN6I_DSI_PIXEL_CTL0_PD_PLUG_DISABLE |\n\t\t     SUN6I_DSI_PIXEL_CTL0_FORMAT(fmt));\n}\n\nstatic void sun6i_dsi_setup_timings(struct sun6i_dsi *dsi,\n\t\t\t\t    struct drm_display_mode *mode)\n{\n\tstruct mipi_dsi_device *device = dsi->device;\n\tint Bpp = mipi_dsi_pixel_format_to_bpp(device->format) / 8;\n\tu16 hbp = 0, hfp = 0, hsa = 0, hblk = 0, vblk = 0;\n\tu32 basic_ctl = 0;\n\tsize_t bytes;\n\tu8 *buffer;\n\n\t \n\n\tif (device->mode_flags & MIPI_DSI_MODE_VIDEO_BURST) {\n\t\thblk = mode->hdisplay * Bpp;\n\t\tbasic_ctl = SUN6I_DSI_BASIC_CTL_VIDEO_BURST |\n\t\t\t    SUN6I_DSI_BASIC_CTL_HSA_HSE_DIS |\n\t\t\t    SUN6I_DSI_BASIC_CTL_HBP_DIS;\n\n\t\tif (device->lanes == 4)\n\t\t\tbasic_ctl |= SUN6I_DSI_BASIC_CTL_TRAIL_FILL |\n\t\t\t\t     SUN6I_DSI_BASIC_CTL_TRAIL_INV(0xc);\n\t} else {\n\t\t \n#define HSA_PACKET_OVERHEAD\t10\n\t\thsa = max(HSA_PACKET_OVERHEAD,\n\t\t\t  (mode->hsync_end - mode->hsync_start) * Bpp - HSA_PACKET_OVERHEAD);\n\n\t\t \n#define HBP_PACKET_OVERHEAD\t6\n\t\thbp = max(HBP_PACKET_OVERHEAD,\n\t\t\t  (mode->htotal - mode->hsync_end) * Bpp - HBP_PACKET_OVERHEAD);\n\n\t\t \n#define HFP_PACKET_OVERHEAD\t16\n\t\thfp = max(HFP_PACKET_OVERHEAD,\n\t\t\t  (mode->hsync_start - mode->hdisplay) * Bpp - HFP_PACKET_OVERHEAD);\n\n\t\t \n#define HBLK_PACKET_OVERHEAD\t10\n\t\thblk = max(HBLK_PACKET_OVERHEAD,\n\t\t\t   (mode->htotal - (mode->hsync_end - mode->hsync_start)) * Bpp -\n\t\t\t   HBLK_PACKET_OVERHEAD);\n\n\t\t \n\t\tvblk = 0;\n\t}\n\n\t \n\tbytes = max_t(size_t, max(max(hfp, hblk), max(hsa, hbp)), vblk);\n\tbuffer = kmalloc(bytes, GFP_KERNEL);\n\tif (WARN_ON(!buffer))\n\t\treturn;\n\n\tregmap_write(dsi->regs, SUN6I_DSI_BASIC_CTL_REG, basic_ctl);\n\n\tregmap_write(dsi->regs, SUN6I_DSI_SYNC_HSS_REG,\n\t\t     sun6i_dsi_build_sync_pkt(MIPI_DSI_H_SYNC_START,\n\t\t\t\t\t      device->channel,\n\t\t\t\t\t      0, 0));\n\n\tregmap_write(dsi->regs, SUN6I_DSI_SYNC_HSE_REG,\n\t\t     sun6i_dsi_build_sync_pkt(MIPI_DSI_H_SYNC_END,\n\t\t\t\t\t      device->channel,\n\t\t\t\t\t      0, 0));\n\n\tregmap_write(dsi->regs, SUN6I_DSI_SYNC_VSS_REG,\n\t\t     sun6i_dsi_build_sync_pkt(MIPI_DSI_V_SYNC_START,\n\t\t\t\t\t      device->channel,\n\t\t\t\t\t      0, 0));\n\n\tregmap_write(dsi->regs, SUN6I_DSI_SYNC_VSE_REG,\n\t\t     sun6i_dsi_build_sync_pkt(MIPI_DSI_V_SYNC_END,\n\t\t\t\t\t      device->channel,\n\t\t\t\t\t      0, 0));\n\n\tregmap_write(dsi->regs, SUN6I_DSI_BASIC_SIZE0_REG,\n\t\t     SUN6I_DSI_BASIC_SIZE0_VSA(mode->vsync_end -\n\t\t\t\t\t       mode->vsync_start) |\n\t\t     SUN6I_DSI_BASIC_SIZE0_VBP(mode->vtotal -\n\t\t\t\t\t       mode->vsync_end));\n\n\tregmap_write(dsi->regs, SUN6I_DSI_BASIC_SIZE1_REG,\n\t\t     SUN6I_DSI_BASIC_SIZE1_VACT(mode->vdisplay) |\n\t\t     SUN6I_DSI_BASIC_SIZE1_VT(mode->vtotal));\n\n\t \n\tregmap_write(dsi->regs, SUN6I_DSI_BLK_HSA0_REG,\n\t\t     sun6i_dsi_build_blk0_pkt(device->channel, hsa));\n\tregmap_write(dsi->regs, SUN6I_DSI_BLK_HSA1_REG,\n\t\t     sun6i_dsi_build_blk1_pkt(0, buffer, hsa));\n\n\t \n\tregmap_write(dsi->regs, SUN6I_DSI_BLK_HBP0_REG,\n\t\t     sun6i_dsi_build_blk0_pkt(device->channel, hbp));\n\tregmap_write(dsi->regs, SUN6I_DSI_BLK_HBP1_REG,\n\t\t     sun6i_dsi_build_blk1_pkt(0, buffer, hbp));\n\n\t \n\tregmap_write(dsi->regs, SUN6I_DSI_BLK_HFP0_REG,\n\t\t     sun6i_dsi_build_blk0_pkt(device->channel, hfp));\n\tregmap_write(dsi->regs, SUN6I_DSI_BLK_HFP1_REG,\n\t\t     sun6i_dsi_build_blk1_pkt(0, buffer, hfp));\n\n\t \n\tregmap_write(dsi->regs, SUN6I_DSI_BLK_HBLK0_REG,\n\t\t     sun6i_dsi_build_blk0_pkt(device->channel, hblk));\n\tregmap_write(dsi->regs, SUN6I_DSI_BLK_HBLK1_REG,\n\t\t     sun6i_dsi_build_blk1_pkt(0, buffer, hblk));\n\n\t \n\tregmap_write(dsi->regs, SUN6I_DSI_BLK_VBLK0_REG,\n\t\t     sun6i_dsi_build_blk0_pkt(device->channel, vblk));\n\tregmap_write(dsi->regs, SUN6I_DSI_BLK_VBLK1_REG,\n\t\t     sun6i_dsi_build_blk1_pkt(0, buffer, vblk));\n\n\tkfree(buffer);\n}\n\nstatic int sun6i_dsi_start(struct sun6i_dsi *dsi,\n\t\t\t   enum sun6i_dsi_start_inst func)\n{\n\tswitch (func) {\n\tcase DSI_START_LPTX:\n\t\tregmap_write(dsi->regs, SUN6I_DSI_INST_JUMP_SEL_REG,\n\t\t\t     DSI_INST_ID_LPDT << (4 * DSI_INST_ID_LP11) |\n\t\t\t     DSI_INST_ID_END  << (4 * DSI_INST_ID_LPDT));\n\t\tbreak;\n\tcase DSI_START_LPRX:\n\t\tregmap_write(dsi->regs, SUN6I_DSI_INST_JUMP_SEL_REG,\n\t\t\t     DSI_INST_ID_LPDT << (4 * DSI_INST_ID_LP11) |\n\t\t\t     DSI_INST_ID_DLY  << (4 * DSI_INST_ID_LPDT) |\n\t\t\t     DSI_INST_ID_TBA  << (4 * DSI_INST_ID_DLY) |\n\t\t\t     DSI_INST_ID_END  << (4 * DSI_INST_ID_TBA));\n\t\tbreak;\n\tcase DSI_START_HSC:\n\t\tregmap_write(dsi->regs, SUN6I_DSI_INST_JUMP_SEL_REG,\n\t\t\t     DSI_INST_ID_HSC  << (4 * DSI_INST_ID_LP11) |\n\t\t\t     DSI_INST_ID_END  << (4 * DSI_INST_ID_HSC));\n\t\tbreak;\n\tcase DSI_START_HSD:\n\t\tregmap_write(dsi->regs, SUN6I_DSI_INST_JUMP_SEL_REG,\n\t\t\t     DSI_INST_ID_NOP  << (4 * DSI_INST_ID_LP11) |\n\t\t\t     DSI_INST_ID_HSD  << (4 * DSI_INST_ID_NOP) |\n\t\t\t     DSI_INST_ID_DLY  << (4 * DSI_INST_ID_HSD) |\n\t\t\t     DSI_INST_ID_NOP  << (4 * DSI_INST_ID_DLY) |\n\t\t\t     DSI_INST_ID_END  << (4 * DSI_INST_ID_HSCEXIT));\n\t\tbreak;\n\tdefault:\n\t\tregmap_write(dsi->regs, SUN6I_DSI_INST_JUMP_SEL_REG,\n\t\t\t     DSI_INST_ID_END  << (4 * DSI_INST_ID_LP11));\n\t\tbreak;\n\t}\n\n\tsun6i_dsi_inst_abort(dsi);\n\tsun6i_dsi_inst_commit(dsi);\n\n\tif (func == DSI_START_HSC)\n\t\tregmap_write_bits(dsi->regs,\n\t\t\t\t  SUN6I_DSI_INST_FUNC_REG(DSI_INST_ID_LP11),\n\t\t\t\t  SUN6I_DSI_INST_FUNC_LANE_CEN, 0);\n\n\treturn 0;\n}\n\nstatic void sun6i_dsi_encoder_enable(struct drm_encoder *encoder)\n{\n\tstruct drm_display_mode *mode = &encoder->crtc->state->adjusted_mode;\n\tstruct sun6i_dsi *dsi = encoder_to_sun6i_dsi(encoder);\n\tstruct mipi_dsi_device *device = dsi->device;\n\tunion phy_configure_opts opts = { };\n\tstruct phy_configure_opts_mipi_dphy *cfg = &opts.mipi_dphy;\n\tu16 delay;\n\tint err;\n\n\tDRM_DEBUG_DRIVER(\"Enabling DSI output\\n\");\n\n\terr = regulator_enable(dsi->regulator);\n\tif (err)\n\t\tdev_warn(dsi->dev, \"failed to enable VCC-DSI supply: %d\\n\", err);\n\n\treset_control_deassert(dsi->reset);\n\tclk_prepare_enable(dsi->mod_clk);\n\n\t \n\tregmap_write(dsi->regs, SUN6I_DSI_CTL_REG, SUN6I_DSI_CTL_EN);\n\n\tregmap_write(dsi->regs, SUN6I_DSI_BASIC_CTL0_REG,\n\t\t     SUN6I_DSI_BASIC_CTL0_ECC_EN | SUN6I_DSI_BASIC_CTL0_CRC_EN);\n\n\tregmap_write(dsi->regs, SUN6I_DSI_TRANS_START_REG, 10);\n\tregmap_write(dsi->regs, SUN6I_DSI_TRANS_ZERO_REG, 0);\n\n\tsun6i_dsi_inst_init(dsi, dsi->device);\n\n\tregmap_write(dsi->regs, SUN6I_DSI_DEBUG_DATA_REG, 0xff);\n\n\tdelay = sun6i_dsi_get_video_start_delay(dsi, mode);\n\tregmap_write(dsi->regs, SUN6I_DSI_BASIC_CTL1_REG,\n\t\t     SUN6I_DSI_BASIC_CTL1_VIDEO_ST_DELAY(delay) |\n\t\t     SUN6I_DSI_BASIC_CTL1_VIDEO_FILL |\n\t\t     SUN6I_DSI_BASIC_CTL1_VIDEO_PRECISION |\n\t\t     SUN6I_DSI_BASIC_CTL1_VIDEO_MODE);\n\n\tsun6i_dsi_setup_burst(dsi, mode);\n\tsun6i_dsi_setup_inst_loop(dsi, mode);\n\tsun6i_dsi_setup_format(dsi, mode);\n\tsun6i_dsi_setup_timings(dsi, mode);\n\n\tphy_init(dsi->dphy);\n\n\tphy_mipi_dphy_get_default_config(mode->clock * 1000,\n\t\t\t\t\t mipi_dsi_pixel_format_to_bpp(device->format),\n\t\t\t\t\t device->lanes, cfg);\n\n\tphy_set_mode(dsi->dphy, PHY_MODE_MIPI_DPHY);\n\tphy_configure(dsi->dphy, &opts);\n\tphy_power_on(dsi->dphy);\n\n\tif (dsi->panel)\n\t\tdrm_panel_prepare(dsi->panel);\n\n\t \n\tif (dsi->panel)\n\t\tdrm_panel_enable(dsi->panel);\n\n\tsun6i_dsi_start(dsi, DSI_START_HSC);\n\n\tudelay(1000);\n\n\tsun6i_dsi_start(dsi, DSI_START_HSD);\n}\n\nstatic void sun6i_dsi_encoder_disable(struct drm_encoder *encoder)\n{\n\tstruct sun6i_dsi *dsi = encoder_to_sun6i_dsi(encoder);\n\n\tDRM_DEBUG_DRIVER(\"Disabling DSI output\\n\");\n\n\tif (dsi->panel) {\n\t\tdrm_panel_disable(dsi->panel);\n\t\tdrm_panel_unprepare(dsi->panel);\n\t}\n\n\tphy_power_off(dsi->dphy);\n\tphy_exit(dsi->dphy);\n\n\tclk_disable_unprepare(dsi->mod_clk);\n\treset_control_assert(dsi->reset);\n\tregulator_disable(dsi->regulator);\n}\n\nstatic int sun6i_dsi_get_modes(struct drm_connector *connector)\n{\n\tstruct sun6i_dsi *dsi = connector_to_sun6i_dsi(connector);\n\n\treturn drm_panel_get_modes(dsi->panel, connector);\n}\n\nstatic const struct drm_connector_helper_funcs sun6i_dsi_connector_helper_funcs = {\n\t.get_modes\t= sun6i_dsi_get_modes,\n};\n\nstatic enum drm_connector_status\nsun6i_dsi_connector_detect(struct drm_connector *connector, bool force)\n{\n\tstruct sun6i_dsi *dsi = connector_to_sun6i_dsi(connector);\n\n\treturn dsi->panel ? connector_status_connected :\n\t\t\t    connector_status_disconnected;\n}\n\nstatic const struct drm_connector_funcs sun6i_dsi_connector_funcs = {\n\t.detect\t\t\t= sun6i_dsi_connector_detect,\n\t.fill_modes\t\t= drm_helper_probe_single_connector_modes,\n\t.destroy\t\t= drm_connector_cleanup,\n\t.reset\t\t\t= drm_atomic_helper_connector_reset,\n\t.atomic_duplicate_state\t= drm_atomic_helper_connector_duplicate_state,\n\t.atomic_destroy_state\t= drm_atomic_helper_connector_destroy_state,\n};\n\nstatic const struct drm_encoder_helper_funcs sun6i_dsi_enc_helper_funcs = {\n\t.disable\t= sun6i_dsi_encoder_disable,\n\t.enable\t\t= sun6i_dsi_encoder_enable,\n};\n\nstatic u32 sun6i_dsi_dcs_build_pkt_hdr(struct sun6i_dsi *dsi,\n\t\t\t\t       const struct mipi_dsi_msg *msg)\n{\n\tu32 pkt = msg->type;\n\n\tif (msg->type == MIPI_DSI_DCS_LONG_WRITE) {\n\t\tpkt |= ((msg->tx_len) & 0xffff) << 8;\n\t\tpkt |= (((msg->tx_len) >> 8) & 0xffff) << 16;\n\t} else {\n\t\tpkt |= (((u8 *)msg->tx_buf)[0] << 8);\n\t\tif (msg->tx_len > 1)\n\t\t\tpkt |= (((u8 *)msg->tx_buf)[1] << 16);\n\t}\n\n\tpkt |= sun6i_dsi_ecc_compute(pkt) << 24;\n\n\treturn pkt;\n}\n\nstatic int sun6i_dsi_dcs_write_short(struct sun6i_dsi *dsi,\n\t\t\t\t     const struct mipi_dsi_msg *msg)\n{\n\tregmap_write(dsi->regs, SUN6I_DSI_CMD_TX_REG(0),\n\t\t     sun6i_dsi_dcs_build_pkt_hdr(dsi, msg));\n\tregmap_write_bits(dsi->regs, SUN6I_DSI_CMD_CTL_REG,\n\t\t\t  0xff, (4 - 1));\n\n\tsun6i_dsi_start(dsi, DSI_START_LPTX);\n\n\treturn msg->tx_len;\n}\n\nstatic int sun6i_dsi_dcs_write_long(struct sun6i_dsi *dsi,\n\t\t\t\t    const struct mipi_dsi_msg *msg)\n{\n\tint ret, len = 0;\n\tu8 *bounce;\n\tu16 crc;\n\n\tregmap_write(dsi->regs, SUN6I_DSI_CMD_TX_REG(0),\n\t\t     sun6i_dsi_dcs_build_pkt_hdr(dsi, msg));\n\n\tbounce = kzalloc(ALIGN(msg->tx_len + sizeof(crc), 4), GFP_KERNEL);\n\tif (!bounce)\n\t\treturn -ENOMEM;\n\n\tmemcpy(bounce, msg->tx_buf, msg->tx_len);\n\tlen += msg->tx_len;\n\n\tcrc = sun6i_dsi_crc_compute(bounce, msg->tx_len);\n\tmemcpy((u8 *)bounce + msg->tx_len, &crc, sizeof(crc));\n\tlen += sizeof(crc);\n\n\tregmap_bulk_write(dsi->regs, SUN6I_DSI_CMD_TX_REG(1), bounce, DIV_ROUND_UP(len, 4));\n\tregmap_write(dsi->regs, SUN6I_DSI_CMD_CTL_REG, len + 4 - 1);\n\tkfree(bounce);\n\n\tsun6i_dsi_start(dsi, DSI_START_LPTX);\n\n\tret = sun6i_dsi_inst_wait_for_completion(dsi);\n\tif (ret < 0) {\n\t\tsun6i_dsi_inst_abort(dsi);\n\t\treturn ret;\n\t}\n\n\t \n\treturn msg->tx_len;\n}\n\nstatic int sun6i_dsi_dcs_read(struct sun6i_dsi *dsi,\n\t\t\t      const struct mipi_dsi_msg *msg)\n{\n\tu32 val;\n\tint ret;\n\tu8 byte0;\n\n\tregmap_write(dsi->regs, SUN6I_DSI_CMD_TX_REG(0),\n\t\t     sun6i_dsi_dcs_build_pkt_hdr(dsi, msg));\n\tregmap_write(dsi->regs, SUN6I_DSI_CMD_CTL_REG,\n\t\t     (4 - 1));\n\n\tsun6i_dsi_start(dsi, DSI_START_LPRX);\n\n\tret = sun6i_dsi_inst_wait_for_completion(dsi);\n\tif (ret < 0) {\n\t\tsun6i_dsi_inst_abort(dsi);\n\t\treturn ret;\n\t}\n\n\t \n\tregmap_read(dsi->regs, SUN6I_DSI_CMD_CTL_REG, &val);\n\tif (val & SUN6I_DSI_CMD_CTL_RX_OVERFLOW)\n\t\treturn -EIO;\n\n\tregmap_read(dsi->regs, SUN6I_DSI_CMD_RX_REG(0), &val);\n\tbyte0 = val & 0xff;\n\tif (byte0 == MIPI_DSI_RX_ACKNOWLEDGE_AND_ERROR_REPORT)\n\t\treturn -EIO;\n\n\t((u8 *)msg->rx_buf)[0] = (val >> 8);\n\n\treturn 1;\n}\n\nstatic int sun6i_dsi_attach(struct mipi_dsi_host *host,\n\t\t\t    struct mipi_dsi_device *device)\n{\n\tstruct sun6i_dsi *dsi = host_to_sun6i_dsi(host);\n\tstruct drm_panel *panel = of_drm_find_panel(device->dev.of_node);\n\n\tif (IS_ERR(panel))\n\t\treturn PTR_ERR(panel);\n\tif (!dsi->drm || !dsi->drm->registered)\n\t\treturn -EPROBE_DEFER;\n\n\tdsi->panel = panel;\n\tdsi->device = device;\n\n\tdrm_kms_helper_hotplug_event(dsi->drm);\n\n\tdev_info(host->dev, \"Attached device %s\\n\", device->name);\n\n\treturn 0;\n}\n\nstatic int sun6i_dsi_detach(struct mipi_dsi_host *host,\n\t\t\t    struct mipi_dsi_device *device)\n{\n\tstruct sun6i_dsi *dsi = host_to_sun6i_dsi(host);\n\n\tdsi->panel = NULL;\n\tdsi->device = NULL;\n\n\tdrm_kms_helper_hotplug_event(dsi->drm);\n\n\treturn 0;\n}\n\nstatic ssize_t sun6i_dsi_transfer(struct mipi_dsi_host *host,\n\t\t\t\t  const struct mipi_dsi_msg *msg)\n{\n\tstruct sun6i_dsi *dsi = host_to_sun6i_dsi(host);\n\tint ret;\n\n\tret = sun6i_dsi_inst_wait_for_completion(dsi);\n\tif (ret < 0)\n\t\tsun6i_dsi_inst_abort(dsi);\n\n\tregmap_write(dsi->regs, SUN6I_DSI_CMD_CTL_REG,\n\t\t     SUN6I_DSI_CMD_CTL_RX_OVERFLOW |\n\t\t     SUN6I_DSI_CMD_CTL_RX_FLAG |\n\t\t     SUN6I_DSI_CMD_CTL_TX_FLAG);\n\n\tswitch (msg->type) {\n\tcase MIPI_DSI_DCS_SHORT_WRITE:\n\tcase MIPI_DSI_DCS_SHORT_WRITE_PARAM:\n\tcase MIPI_DSI_GENERIC_SHORT_WRITE_2_PARAM:\n\t\tret = sun6i_dsi_dcs_write_short(dsi, msg);\n\t\tbreak;\n\n\tcase MIPI_DSI_DCS_LONG_WRITE:\n\t\tret = sun6i_dsi_dcs_write_long(dsi, msg);\n\t\tbreak;\n\n\tcase MIPI_DSI_DCS_READ:\n\t\tif (msg->rx_len == 1) {\n\t\t\tret = sun6i_dsi_dcs_read(dsi, msg);\n\t\t\tbreak;\n\t\t}\n\t\tfallthrough;\n\n\tdefault:\n\t\tret = -EINVAL;\n\t}\n\n\treturn ret;\n}\n\nstatic const struct mipi_dsi_host_ops sun6i_dsi_host_ops = {\n\t.attach\t\t= sun6i_dsi_attach,\n\t.detach\t\t= sun6i_dsi_detach,\n\t.transfer\t= sun6i_dsi_transfer,\n};\n\nstatic const struct regmap_config sun6i_dsi_regmap_config = {\n\t.reg_bits\t= 32,\n\t.val_bits\t= 32,\n\t.reg_stride\t= 4,\n\t.max_register\t= SUN6I_DSI_CMD_TX_REG(255),\n\t.name\t\t= \"mipi-dsi\",\n};\n\nstatic int sun6i_dsi_bind(struct device *dev, struct device *master,\n\t\t\t void *data)\n{\n\tstruct drm_device *drm = data;\n\tstruct sun6i_dsi *dsi = dev_get_drvdata(dev);\n\tint ret;\n\n\tdrm_encoder_helper_add(&dsi->encoder,\n\t\t\t       &sun6i_dsi_enc_helper_funcs);\n\tret = drm_simple_encoder_init(drm, &dsi->encoder,\n\t\t\t\t      DRM_MODE_ENCODER_DSI);\n\tif (ret) {\n\t\tdev_err(dsi->dev, \"Couldn't initialise the DSI encoder\\n\");\n\t\treturn ret;\n\t}\n\tdsi->encoder.possible_crtcs = BIT(0);\n\n\tdrm_connector_helper_add(&dsi->connector,\n\t\t\t\t &sun6i_dsi_connector_helper_funcs);\n\tret = drm_connector_init(drm, &dsi->connector,\n\t\t\t\t &sun6i_dsi_connector_funcs,\n\t\t\t\t DRM_MODE_CONNECTOR_DSI);\n\tif (ret) {\n\t\tdev_err(dsi->dev,\n\t\t\t\"Couldn't initialise the DSI connector\\n\");\n\t\tgoto err_cleanup_connector;\n\t}\n\n\tdrm_connector_attach_encoder(&dsi->connector, &dsi->encoder);\n\n\tdsi->drm = drm;\n\n\treturn 0;\n\nerr_cleanup_connector:\n\tdrm_encoder_cleanup(&dsi->encoder);\n\treturn ret;\n}\n\nstatic void sun6i_dsi_unbind(struct device *dev, struct device *master,\n\t\t\t    void *data)\n{\n\tstruct sun6i_dsi *dsi = dev_get_drvdata(dev);\n\n\tdsi->drm = NULL;\n}\n\nstatic const struct component_ops sun6i_dsi_ops = {\n\t.bind\t= sun6i_dsi_bind,\n\t.unbind\t= sun6i_dsi_unbind,\n};\n\nstatic int sun6i_dsi_probe(struct platform_device *pdev)\n{\n\tconst struct sun6i_dsi_variant *variant;\n\tstruct device *dev = &pdev->dev;\n\tstruct sun6i_dsi *dsi;\n\tvoid __iomem *base;\n\tint ret;\n\n\tvariant = device_get_match_data(dev);\n\tif (!variant)\n\t\treturn -EINVAL;\n\n\tdsi = devm_kzalloc(dev, sizeof(*dsi), GFP_KERNEL);\n\tif (!dsi)\n\t\treturn -ENOMEM;\n\tdev_set_drvdata(dev, dsi);\n\tdsi->dev = dev;\n\tdsi->host.ops = &sun6i_dsi_host_ops;\n\tdsi->host.dev = dev;\n\tdsi->variant = variant;\n\n\tbase = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(base)) {\n\t\tdev_err(dev, \"Couldn't map the DSI encoder registers\\n\");\n\t\treturn PTR_ERR(base);\n\t}\n\n\tdsi->regulator = devm_regulator_get(dev, \"vcc-dsi\");\n\tif (IS_ERR(dsi->regulator))\n\t\treturn dev_err_probe(dev, PTR_ERR(dsi->regulator),\n\t\t\t\t     \"Couldn't get VCC-DSI supply\\n\");\n\n\tdsi->reset = devm_reset_control_get_shared(dev, NULL);\n\tif (IS_ERR(dsi->reset)) {\n\t\tdev_err(dev, \"Couldn't get our reset line\\n\");\n\t\treturn PTR_ERR(dsi->reset);\n\t}\n\n\tdsi->regs = devm_regmap_init_mmio(dev, base, &sun6i_dsi_regmap_config);\n\tif (IS_ERR(dsi->regs)) {\n\t\tdev_err(dev, \"Couldn't init regmap\\n\");\n\t\treturn PTR_ERR(dsi->regs);\n\t}\n\n\tdsi->bus_clk = devm_clk_get(dev, variant->has_mod_clk ? \"bus\" : NULL);\n\tif (IS_ERR(dsi->bus_clk))\n\t\treturn dev_err_probe(dev, PTR_ERR(dsi->bus_clk),\n\t\t\t\t     \"Couldn't get the DSI bus clock\\n\");\n\n\tret = regmap_mmio_attach_clk(dsi->regs, dsi->bus_clk);\n\tif (ret)\n\t\treturn ret;\n\n\tif (variant->has_mod_clk) {\n\t\tdsi->mod_clk = devm_clk_get(dev, \"mod\");\n\t\tif (IS_ERR(dsi->mod_clk)) {\n\t\t\tdev_err(dev, \"Couldn't get the DSI mod clock\\n\");\n\t\t\tret = PTR_ERR(dsi->mod_clk);\n\t\t\tgoto err_attach_clk;\n\t\t}\n\n\t\t \n\t\tif (variant->set_mod_clk)\n\t\t\tclk_set_rate_exclusive(dsi->mod_clk, 297000000);\n\t}\n\n\tdsi->dphy = devm_phy_get(dev, \"dphy\");\n\tif (IS_ERR(dsi->dphy)) {\n\t\tdev_err(dev, \"Couldn't get the MIPI D-PHY\\n\");\n\t\tret = PTR_ERR(dsi->dphy);\n\t\tgoto err_unprotect_clk;\n\t}\n\n\tret = mipi_dsi_host_register(&dsi->host);\n\tif (ret) {\n\t\tdev_err(dev, \"Couldn't register MIPI-DSI host\\n\");\n\t\tgoto err_unprotect_clk;\n\t}\n\n\tret = component_add(&pdev->dev, &sun6i_dsi_ops);\n\tif (ret) {\n\t\tdev_err(dev, \"Couldn't register our component\\n\");\n\t\tgoto err_remove_dsi_host;\n\t}\n\n\treturn 0;\n\nerr_remove_dsi_host:\n\tmipi_dsi_host_unregister(&dsi->host);\nerr_unprotect_clk:\n\tif (dsi->variant->has_mod_clk && dsi->variant->set_mod_clk)\n\t\tclk_rate_exclusive_put(dsi->mod_clk);\nerr_attach_clk:\n\tregmap_mmio_detach_clk(dsi->regs);\n\n\treturn ret;\n}\n\nstatic void sun6i_dsi_remove(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct sun6i_dsi *dsi = dev_get_drvdata(dev);\n\n\tcomponent_del(&pdev->dev, &sun6i_dsi_ops);\n\tmipi_dsi_host_unregister(&dsi->host);\n\tif (dsi->variant->has_mod_clk && dsi->variant->set_mod_clk)\n\t\tclk_rate_exclusive_put(dsi->mod_clk);\n\n\tregmap_mmio_detach_clk(dsi->regs);\n}\n\nstatic const struct sun6i_dsi_variant sun6i_a31_mipi_dsi_variant = {\n\t.has_mod_clk\t= true,\n\t.set_mod_clk\t= true,\n};\n\nstatic const struct sun6i_dsi_variant sun50i_a64_mipi_dsi_variant = {\n};\n\nstatic const struct sun6i_dsi_variant sun50i_a100_mipi_dsi_variant = {\n\t.has_mod_clk\t= true,\n};\n\nstatic const struct of_device_id sun6i_dsi_of_table[] = {\n\t{\n\t\t.compatible\t= \"allwinner,sun6i-a31-mipi-dsi\",\n\t\t.data\t\t= &sun6i_a31_mipi_dsi_variant,\n\t},\n\t{\n\t\t.compatible\t= \"allwinner,sun50i-a64-mipi-dsi\",\n\t\t.data\t\t= &sun50i_a64_mipi_dsi_variant,\n\t},\n\t{\n\t\t.compatible\t= \"allwinner,sun50i-a100-mipi-dsi\",\n\t\t.data\t\t= &sun50i_a100_mipi_dsi_variant,\n\t},\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, sun6i_dsi_of_table);\n\nstatic struct platform_driver sun6i_dsi_platform_driver = {\n\t.probe\t\t= sun6i_dsi_probe,\n\t.remove_new\t= sun6i_dsi_remove,\n\t.driver\t\t= {\n\t\t.name\t\t= \"sun6i-mipi-dsi\",\n\t\t.of_match_table\t= sun6i_dsi_of_table,\n\t},\n};\nmodule_platform_driver(sun6i_dsi_platform_driver);\n\nMODULE_AUTHOR(\"Maxime Ripard <maxime.ripard@free-electrons.com>\");\nMODULE_DESCRIPTION(\"Allwinner A31 DSI Driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}