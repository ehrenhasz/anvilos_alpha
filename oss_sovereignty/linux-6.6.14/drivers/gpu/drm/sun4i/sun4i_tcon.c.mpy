{
  "module_name": "sun4i_tcon.c",
  "hash_id": "4e1362c6ed9539073ebf810e9016b65a3ca827b5e23a80d4968f322d9caf9faa",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/sun4i/sun4i_tcon.c",
  "human_readable_source": "\n \n\n#include <linux/component.h>\n#include <linux/ioport.h>\n#include <linux/media-bus-format.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/of_platform.h>\n#include <linux/platform_device.h>\n#include <linux/regmap.h>\n#include <linux/reset.h>\n\n#include <drm/drm_atomic_helper.h>\n#include <drm/drm_bridge.h>\n#include <drm/drm_connector.h>\n#include <drm/drm_crtc.h>\n#include <drm/drm_encoder.h>\n#include <drm/drm_modes.h>\n#include <drm/drm_of.h>\n#include <drm/drm_panel.h>\n#include <drm/drm_print.h>\n#include <drm/drm_probe_helper.h>\n#include <drm/drm_vblank.h>\n\n#include <uapi/drm/drm_mode.h>\n\n#include \"sun4i_crtc.h\"\n#include \"sun4i_drv.h\"\n#include \"sun4i_lvds.h\"\n#include \"sun4i_rgb.h\"\n#include \"sun4i_tcon.h\"\n#include \"sun6i_mipi_dsi.h\"\n#include \"sun4i_tcon_dclk.h\"\n#include \"sun8i_tcon_top.h\"\n#include \"sunxi_engine.h\"\n\nstatic struct drm_connector *sun4i_tcon_get_connector(const struct drm_encoder *encoder)\n{\n\tstruct drm_connector *connector;\n\tstruct drm_connector_list_iter iter;\n\n\tdrm_connector_list_iter_begin(encoder->dev, &iter);\n\tdrm_for_each_connector_iter(connector, &iter)\n\t\tif (connector->encoder == encoder) {\n\t\t\tdrm_connector_list_iter_end(&iter);\n\t\t\treturn connector;\n\t\t}\n\tdrm_connector_list_iter_end(&iter);\n\n\treturn NULL;\n}\n\nstatic int sun4i_tcon_get_pixel_depth(const struct drm_encoder *encoder)\n{\n\tstruct drm_connector *connector;\n\tstruct drm_display_info *info;\n\n\tconnector = sun4i_tcon_get_connector(encoder);\n\tif (!connector)\n\t\treturn -EINVAL;\n\n\tinfo = &connector->display_info;\n\tif (info->num_bus_formats != 1)\n\t\treturn -EINVAL;\n\n\tswitch (info->bus_formats[0]) {\n\tcase MEDIA_BUS_FMT_RGB666_1X7X3_SPWG:\n\t\treturn 18;\n\n\tcase MEDIA_BUS_FMT_RGB888_1X7X4_JEIDA:\n\tcase MEDIA_BUS_FMT_RGB888_1X7X4_SPWG:\n\t\treturn 24;\n\t}\n\n\treturn -EINVAL;\n}\n\nstatic void sun4i_tcon_channel_set_status(struct sun4i_tcon *tcon, int channel,\n\t\t\t\t\t  bool enabled)\n{\n\tstruct clk *clk;\n\n\tswitch (channel) {\n\tcase 0:\n\t\tWARN_ON(!tcon->quirks->has_channel_0);\n\t\tregmap_update_bits(tcon->regs, SUN4I_TCON0_CTL_REG,\n\t\t\t\t   SUN4I_TCON0_CTL_TCON_ENABLE,\n\t\t\t\t   enabled ? SUN4I_TCON0_CTL_TCON_ENABLE : 0);\n\t\tclk = tcon->dclk;\n\t\tbreak;\n\tcase 1:\n\t\tWARN_ON(!tcon->quirks->has_channel_1);\n\t\tregmap_update_bits(tcon->regs, SUN4I_TCON1_CTL_REG,\n\t\t\t\t   SUN4I_TCON1_CTL_TCON_ENABLE,\n\t\t\t\t   enabled ? SUN4I_TCON1_CTL_TCON_ENABLE : 0);\n\t\tclk = tcon->sclk1;\n\t\tbreak;\n\tdefault:\n\t\tDRM_WARN(\"Unknown channel... doing nothing\\n\");\n\t\treturn;\n\t}\n\n\tif (enabled) {\n\t\tclk_prepare_enable(clk);\n\t\tclk_rate_exclusive_get(clk);\n\t} else {\n\t\tclk_rate_exclusive_put(clk);\n\t\tclk_disable_unprepare(clk);\n\t}\n}\n\nstatic void sun4i_tcon_setup_lvds_phy(struct sun4i_tcon *tcon,\n\t\t\t\t      const struct drm_encoder *encoder)\n{\n\tregmap_write(tcon->regs, SUN4I_TCON0_LVDS_ANA0_REG,\n\t\t     SUN4I_TCON0_LVDS_ANA0_CK_EN |\n\t\t     SUN4I_TCON0_LVDS_ANA0_REG_V |\n\t\t     SUN4I_TCON0_LVDS_ANA0_REG_C |\n\t\t     SUN4I_TCON0_LVDS_ANA0_EN_MB |\n\t\t     SUN4I_TCON0_LVDS_ANA0_PD |\n\t\t     SUN4I_TCON0_LVDS_ANA0_DCHS);\n\n\tudelay(2);  \n\tregmap_update_bits(tcon->regs, SUN4I_TCON0_LVDS_ANA1_REG,\n\t\t\t   SUN4I_TCON0_LVDS_ANA1_INIT,\n\t\t\t   SUN4I_TCON0_LVDS_ANA1_INIT);\n\tudelay(1);  \n\tregmap_update_bits(tcon->regs, SUN4I_TCON0_LVDS_ANA1_REG,\n\t\t\t   SUN4I_TCON0_LVDS_ANA1_UPDATE,\n\t\t\t   SUN4I_TCON0_LVDS_ANA1_UPDATE);\n\tregmap_update_bits(tcon->regs, SUN4I_TCON0_LVDS_ANA0_REG,\n\t\t\t   SUN4I_TCON0_LVDS_ANA0_EN_MB,\n\t\t\t   SUN4I_TCON0_LVDS_ANA0_EN_MB);\n}\n\nstatic void sun6i_tcon_setup_lvds_phy(struct sun4i_tcon *tcon,\n\t\t\t\t      const struct drm_encoder *encoder)\n{\n\tu8 val;\n\n\tregmap_write(tcon->regs, SUN4I_TCON0_LVDS_ANA0_REG,\n\t\t     SUN6I_TCON0_LVDS_ANA0_C(2) |\n\t\t     SUN6I_TCON0_LVDS_ANA0_V(3) |\n\t\t     SUN6I_TCON0_LVDS_ANA0_PD(2) |\n\t\t     SUN6I_TCON0_LVDS_ANA0_EN_LDO);\n\tudelay(2);\n\n\tregmap_update_bits(tcon->regs, SUN4I_TCON0_LVDS_ANA0_REG,\n\t\t\t   SUN6I_TCON0_LVDS_ANA0_EN_MB,\n\t\t\t   SUN6I_TCON0_LVDS_ANA0_EN_MB);\n\tudelay(2);\n\n\tregmap_update_bits(tcon->regs, SUN4I_TCON0_LVDS_ANA0_REG,\n\t\t\t   SUN6I_TCON0_LVDS_ANA0_EN_DRVC,\n\t\t\t   SUN6I_TCON0_LVDS_ANA0_EN_DRVC);\n\n\tif (sun4i_tcon_get_pixel_depth(encoder) == 18)\n\t\tval = 7;\n\telse\n\t\tval = 0xf;\n\n\tregmap_write_bits(tcon->regs, SUN4I_TCON0_LVDS_ANA0_REG,\n\t\t\t  SUN6I_TCON0_LVDS_ANA0_EN_DRVD(0xf),\n\t\t\t  SUN6I_TCON0_LVDS_ANA0_EN_DRVD(val));\n}\n\nstatic void sun4i_tcon_lvds_set_status(struct sun4i_tcon *tcon,\n\t\t\t\t       const struct drm_encoder *encoder,\n\t\t\t\t       bool enabled)\n{\n\tif (enabled) {\n\t\tregmap_update_bits(tcon->regs, SUN4I_TCON0_LVDS_IF_REG,\n\t\t\t\t   SUN4I_TCON0_LVDS_IF_EN,\n\t\t\t\t   SUN4I_TCON0_LVDS_IF_EN);\n\t\tif (tcon->quirks->setup_lvds_phy)\n\t\t\ttcon->quirks->setup_lvds_phy(tcon, encoder);\n\t} else {\n\t\tregmap_update_bits(tcon->regs, SUN4I_TCON0_LVDS_IF_REG,\n\t\t\t\t   SUN4I_TCON0_LVDS_IF_EN, 0);\n\t}\n}\n\nvoid sun4i_tcon_set_status(struct sun4i_tcon *tcon,\n\t\t\t   const struct drm_encoder *encoder,\n\t\t\t   bool enabled)\n{\n\tbool is_lvds = false;\n\tint channel;\n\n\tswitch (encoder->encoder_type) {\n\tcase DRM_MODE_ENCODER_LVDS:\n\t\tis_lvds = true;\n\t\tfallthrough;\n\tcase DRM_MODE_ENCODER_DSI:\n\tcase DRM_MODE_ENCODER_NONE:\n\t\tchannel = 0;\n\t\tbreak;\n\tcase DRM_MODE_ENCODER_TMDS:\n\tcase DRM_MODE_ENCODER_TVDAC:\n\t\tchannel = 1;\n\t\tbreak;\n\tdefault:\n\t\tDRM_DEBUG_DRIVER(\"Unknown encoder type, doing nothing...\\n\");\n\t\treturn;\n\t}\n\n\tif (is_lvds && !enabled)\n\t\tsun4i_tcon_lvds_set_status(tcon, encoder, false);\n\n\tregmap_update_bits(tcon->regs, SUN4I_TCON_GCTL_REG,\n\t\t\t   SUN4I_TCON_GCTL_TCON_ENABLE,\n\t\t\t   enabled ? SUN4I_TCON_GCTL_TCON_ENABLE : 0);\n\n\tif (is_lvds && enabled)\n\t\tsun4i_tcon_lvds_set_status(tcon, encoder, true);\n\n\tsun4i_tcon_channel_set_status(tcon, channel, enabled);\n}\n\nvoid sun4i_tcon_enable_vblank(struct sun4i_tcon *tcon, bool enable)\n{\n\tu32 mask, val = 0;\n\n\tDRM_DEBUG_DRIVER(\"%sabling VBLANK interrupt\\n\", enable ? \"En\" : \"Dis\");\n\n\tmask = SUN4I_TCON_GINT0_VBLANK_ENABLE(0) |\n\t\tSUN4I_TCON_GINT0_VBLANK_ENABLE(1) |\n\t\tSUN4I_TCON_GINT0_TCON0_TRI_FINISH_ENABLE;\n\n\tif (enable)\n\t\tval = mask;\n\n\tregmap_update_bits(tcon->regs, SUN4I_TCON_GINT0_REG, mask, val);\n}\nEXPORT_SYMBOL(sun4i_tcon_enable_vblank);\n\n \nstatic struct sun4i_tcon *sun4i_get_tcon0(struct drm_device *drm)\n{\n\tstruct sun4i_drv *drv = drm->dev_private;\n\tstruct sun4i_tcon *tcon;\n\n\tlist_for_each_entry(tcon, &drv->tcon_list, list)\n\t\tif (tcon->id == 0)\n\t\t\treturn tcon;\n\n\tdev_warn(drm->dev,\n\t\t \"TCON0 not found, display output muxing may not work\\n\");\n\n\treturn NULL;\n}\n\nstatic void sun4i_tcon_set_mux(struct sun4i_tcon *tcon, int channel,\n\t\t\t       const struct drm_encoder *encoder)\n{\n\tint ret = -ENOTSUPP;\n\n\tif (tcon->quirks->set_mux)\n\t\tret = tcon->quirks->set_mux(tcon, encoder);\n\n\tDRM_DEBUG_DRIVER(\"Muxing encoder %s to CRTC %s: %d\\n\",\n\t\t\t encoder->name, encoder->crtc->name, ret);\n}\n\nstatic int sun4i_tcon_get_clk_delay(const struct drm_display_mode *mode,\n\t\t\t\t    int channel)\n{\n\tint delay = mode->vtotal - mode->vdisplay;\n\n\tif (mode->flags & DRM_MODE_FLAG_INTERLACE)\n\t\tdelay /= 2;\n\n\tif (channel == 1)\n\t\tdelay -= 2;\n\n\tdelay = min(delay, 30);\n\n\tDRM_DEBUG_DRIVER(\"TCON %d clock delay %u\\n\", channel, delay);\n\n\treturn delay;\n}\n\nstatic void sun4i_tcon0_mode_set_dithering(struct sun4i_tcon *tcon,\n\t\t\t\t\t   const struct drm_connector *connector)\n{\n\tu32 bus_format = 0;\n\tu32 val = 0;\n\n\t \n\tif (!connector)\n\t\treturn;\n\n\t \n\tregmap_write(tcon->regs, SUN4I_TCON0_FRM_SEED_PR_REG, 0x11111111);\n\tregmap_write(tcon->regs, SUN4I_TCON0_FRM_SEED_PG_REG, 0x11111111);\n\tregmap_write(tcon->regs, SUN4I_TCON0_FRM_SEED_PB_REG, 0x11111111);\n\tregmap_write(tcon->regs, SUN4I_TCON0_FRM_SEED_LR_REG, 0x11111111);\n\tregmap_write(tcon->regs, SUN4I_TCON0_FRM_SEED_LG_REG, 0x11111111);\n\tregmap_write(tcon->regs, SUN4I_TCON0_FRM_SEED_LB_REG, 0x11111111);\n\tregmap_write(tcon->regs, SUN4I_TCON0_FRM_TBL0_REG, 0x01010000);\n\tregmap_write(tcon->regs, SUN4I_TCON0_FRM_TBL1_REG, 0x15151111);\n\tregmap_write(tcon->regs, SUN4I_TCON0_FRM_TBL2_REG, 0x57575555);\n\tregmap_write(tcon->regs, SUN4I_TCON0_FRM_TBL3_REG, 0x7f7f7777);\n\n\t \n\tif (connector->display_info.bpc == 6)\n\t\tval |= SUN4I_TCON0_FRM_CTL_EN;\n\n\tif (connector->display_info.num_bus_formats == 1)\n\t\tbus_format = connector->display_info.bus_formats[0];\n\n\t \n\tswitch (bus_format) {\n\tcase MEDIA_BUS_FMT_RGB565_1X16:\n\t\t \n\t\tval |= SUN4I_TCON0_FRM_CTL_MODE_R;\n\t\tval |= SUN4I_TCON0_FRM_CTL_MODE_B;\n\t\tfallthrough;\n\tcase MEDIA_BUS_FMT_RGB666_1X18:\n\tcase MEDIA_BUS_FMT_RGB666_1X7X3_SPWG:\n\t\t \n\t\tval |= SUN4I_TCON0_FRM_CTL_EN;\n\t\tbreak;\n\t}\n\n\t \n\tregmap_write(tcon->regs, SUN4I_TCON_FRM_CTL_REG, val);\n}\n\nstatic void sun4i_tcon0_mode_set_cpu(struct sun4i_tcon *tcon,\n\t\t\t\t     const struct drm_encoder *encoder,\n\t\t\t\t     const struct drm_display_mode *mode)\n{\n\t \n\tstruct sun6i_dsi *dsi = encoder_to_sun6i_dsi(encoder);\n\tstruct mipi_dsi_device *device = dsi->device;\n\tu8 bpp = mipi_dsi_pixel_format_to_bpp(device->format);\n\tu8 lanes = device->lanes;\n\tu32 block_space, start_delay;\n\tu32 tcon_div;\n\n\t \n\ttcon->dclk_min_div = SUN6I_DSI_TCON_DIV;\n\ttcon->dclk_max_div = SUN6I_DSI_TCON_DIV;\n\tclk_set_rate(tcon->dclk, mode->crtc_clock * 1000 * (bpp / lanes)\n\t\t\t\t\t\t  / SUN6I_DSI_TCON_DIV);\n\n\t \n\tregmap_write(tcon->regs, SUN4I_TCON0_BASIC0_REG,\n\t\t     SUN4I_TCON0_BASIC0_X(mode->crtc_hdisplay) |\n\t\t     SUN4I_TCON0_BASIC0_Y(mode->crtc_vdisplay));\n\n\t \n\tsun4i_tcon0_mode_set_dithering(tcon, sun4i_tcon_get_connector(encoder));\n\n\tregmap_update_bits(tcon->regs, SUN4I_TCON0_CTL_REG,\n\t\t\t   SUN4I_TCON0_CTL_IF_MASK,\n\t\t\t   SUN4I_TCON0_CTL_IF_8080);\n\n\tregmap_write(tcon->regs, SUN4I_TCON_ECC_FIFO_REG,\n\t\t     SUN4I_TCON_ECC_FIFO_EN);\n\n\tregmap_write(tcon->regs, SUN4I_TCON0_CPU_IF_REG,\n\t\t     SUN4I_TCON0_CPU_IF_MODE_DSI |\n\t\t     SUN4I_TCON0_CPU_IF_TRI_FIFO_FLUSH |\n\t\t     SUN4I_TCON0_CPU_IF_TRI_FIFO_EN |\n\t\t     SUN4I_TCON0_CPU_IF_TRI_EN);\n\n\t \n\tregmap_read(tcon->regs, SUN4I_TCON0_DCLK_REG, &tcon_div);\n\ttcon_div &= GENMASK(6, 0);\n\tblock_space = mode->htotal * bpp / (tcon_div * lanes);\n\tblock_space -= mode->hdisplay + 40;\n\n\tregmap_write(tcon->regs, SUN4I_TCON0_CPU_TRI0_REG,\n\t\t     SUN4I_TCON0_CPU_TRI0_BLOCK_SPACE(block_space) |\n\t\t     SUN4I_TCON0_CPU_TRI0_BLOCK_SIZE(mode->hdisplay));\n\n\tregmap_write(tcon->regs, SUN4I_TCON0_CPU_TRI1_REG,\n\t\t     SUN4I_TCON0_CPU_TRI1_BLOCK_NUM(mode->vdisplay));\n\n\tstart_delay = (mode->crtc_vtotal - mode->crtc_vdisplay - 10 - 1);\n\tstart_delay = start_delay * mode->crtc_htotal * 149;\n\tstart_delay = start_delay / (mode->crtc_clock / 1000) / 8;\n\tregmap_write(tcon->regs, SUN4I_TCON0_CPU_TRI2_REG,\n\t\t     SUN4I_TCON0_CPU_TRI2_TRANS_START_SET(10) |\n\t\t     SUN4I_TCON0_CPU_TRI2_START_DELAY(start_delay));\n\n\t \n\tregmap_write(tcon->regs, SUN4I_TCON_SAFE_PERIOD_REG,\n\t\t     SUN4I_TCON_SAFE_PERIOD_NUM(3000) |\n\t\t     SUN4I_TCON_SAFE_PERIOD_MODE(3));\n\n\t \n\tregmap_write(tcon->regs, SUN4I_TCON0_IO_TRI_REG,\n\t\t     0xe0000000);\n}\n\nstatic void sun4i_tcon0_mode_set_lvds(struct sun4i_tcon *tcon,\n\t\t\t\t      const struct drm_encoder *encoder,\n\t\t\t\t      const struct drm_display_mode *mode)\n{\n\tunsigned int bp;\n\tu8 clk_delay;\n\tu32 reg, val = 0;\n\n\tWARN_ON(!tcon->quirks->has_channel_0);\n\n\ttcon->dclk_min_div = 7;\n\ttcon->dclk_max_div = 7;\n\tclk_set_rate(tcon->dclk, mode->crtc_clock * 1000);\n\n\t \n\tregmap_write(tcon->regs, SUN4I_TCON0_BASIC0_REG,\n\t\t     SUN4I_TCON0_BASIC0_X(mode->crtc_hdisplay) |\n\t\t     SUN4I_TCON0_BASIC0_Y(mode->crtc_vdisplay));\n\n\t \n\tsun4i_tcon0_mode_set_dithering(tcon, sun4i_tcon_get_connector(encoder));\n\n\t \n\tclk_delay = sun4i_tcon_get_clk_delay(mode, 0);\n\tregmap_update_bits(tcon->regs, SUN4I_TCON0_CTL_REG,\n\t\t\t   SUN4I_TCON0_CTL_CLK_DELAY_MASK,\n\t\t\t   SUN4I_TCON0_CTL_CLK_DELAY(clk_delay));\n\n\t \n\tbp = mode->crtc_htotal - mode->crtc_hsync_start;\n\tDRM_DEBUG_DRIVER(\"Setting horizontal total %d, backporch %d\\n\",\n\t\t\t mode->crtc_htotal, bp);\n\n\t \n\tregmap_write(tcon->regs, SUN4I_TCON0_BASIC1_REG,\n\t\t     SUN4I_TCON0_BASIC1_H_TOTAL(mode->htotal) |\n\t\t     SUN4I_TCON0_BASIC1_H_BACKPORCH(bp));\n\n\t \n\tbp = mode->crtc_vtotal - mode->crtc_vsync_start;\n\tDRM_DEBUG_DRIVER(\"Setting vertical total %d, backporch %d\\n\",\n\t\t\t mode->crtc_vtotal, bp);\n\n\t \n\tregmap_write(tcon->regs, SUN4I_TCON0_BASIC2_REG,\n\t\t     SUN4I_TCON0_BASIC2_V_TOTAL(mode->crtc_vtotal * 2) |\n\t\t     SUN4I_TCON0_BASIC2_V_BACKPORCH(bp));\n\n\treg = SUN4I_TCON0_LVDS_IF_CLK_SEL_TCON0;\n\tif (sun4i_tcon_get_pixel_depth(encoder) == 24)\n\t\treg |= SUN4I_TCON0_LVDS_IF_BITWIDTH_24BITS;\n\telse\n\t\treg |= SUN4I_TCON0_LVDS_IF_BITWIDTH_18BITS;\n\n\tregmap_write(tcon->regs, SUN4I_TCON0_LVDS_IF_REG, reg);\n\n\t \n\tif (!(mode->flags & DRM_MODE_FLAG_PHSYNC))\n\t\tval |= SUN4I_TCON0_IO_POL_HSYNC_POSITIVE;\n\n\tif (!(mode->flags & DRM_MODE_FLAG_PVSYNC))\n\t\tval |= SUN4I_TCON0_IO_POL_VSYNC_POSITIVE;\n\n\tregmap_write(tcon->regs, SUN4I_TCON0_IO_POL_REG, val);\n\n\t \n\tregmap_update_bits(tcon->regs, SUN4I_TCON_GCTL_REG,\n\t\t\t   SUN4I_TCON_GCTL_IOMAP_MASK,\n\t\t\t   SUN4I_TCON_GCTL_IOMAP_TCON0);\n\n\t \n\tregmap_write(tcon->regs, SUN4I_TCON0_IO_TRI_REG, 0xe0000000);\n}\n\nstatic void sun4i_tcon0_mode_set_rgb(struct sun4i_tcon *tcon,\n\t\t\t\t     const struct drm_encoder *encoder,\n\t\t\t\t     const struct drm_display_mode *mode)\n{\n\tstruct drm_connector *connector = sun4i_tcon_get_connector(encoder);\n\tconst struct drm_display_info *info = &connector->display_info;\n\tunsigned int bp, hsync, vsync;\n\tu8 clk_delay;\n\tu32 val = 0;\n\n\tWARN_ON(!tcon->quirks->has_channel_0);\n\n\ttcon->dclk_min_div = tcon->quirks->dclk_min_div;\n\ttcon->dclk_max_div = 127;\n\tclk_set_rate(tcon->dclk, mode->crtc_clock * 1000);\n\n\t \n\tregmap_write(tcon->regs, SUN4I_TCON0_BASIC0_REG,\n\t\t     SUN4I_TCON0_BASIC0_X(mode->crtc_hdisplay) |\n\t\t     SUN4I_TCON0_BASIC0_Y(mode->crtc_vdisplay));\n\n\t \n\tsun4i_tcon0_mode_set_dithering(tcon, connector);\n\n\t \n\tclk_delay = sun4i_tcon_get_clk_delay(mode, 0);\n\tregmap_update_bits(tcon->regs, SUN4I_TCON0_CTL_REG,\n\t\t\t   SUN4I_TCON0_CTL_CLK_DELAY_MASK,\n\t\t\t   SUN4I_TCON0_CTL_CLK_DELAY(clk_delay));\n\n\t \n\tbp = mode->crtc_htotal - mode->crtc_hsync_start;\n\tDRM_DEBUG_DRIVER(\"Setting horizontal total %d, backporch %d\\n\",\n\t\t\t mode->crtc_htotal, bp);\n\n\t \n\tregmap_write(tcon->regs, SUN4I_TCON0_BASIC1_REG,\n\t\t     SUN4I_TCON0_BASIC1_H_TOTAL(mode->crtc_htotal) |\n\t\t     SUN4I_TCON0_BASIC1_H_BACKPORCH(bp));\n\n\t \n\tbp = mode->crtc_vtotal - mode->crtc_vsync_start;\n\tDRM_DEBUG_DRIVER(\"Setting vertical total %d, backporch %d\\n\",\n\t\t\t mode->crtc_vtotal, bp);\n\n\t \n\tregmap_write(tcon->regs, SUN4I_TCON0_BASIC2_REG,\n\t\t     SUN4I_TCON0_BASIC2_V_TOTAL(mode->crtc_vtotal * 2) |\n\t\t     SUN4I_TCON0_BASIC2_V_BACKPORCH(bp));\n\n\t \n\thsync = mode->crtc_hsync_end - mode->crtc_hsync_start;\n\tvsync = mode->crtc_vsync_end - mode->crtc_vsync_start;\n\tDRM_DEBUG_DRIVER(\"Setting HSYNC %d, VSYNC %d\\n\", hsync, vsync);\n\tregmap_write(tcon->regs, SUN4I_TCON0_BASIC3_REG,\n\t\t     SUN4I_TCON0_BASIC3_V_SYNC(vsync) |\n\t\t     SUN4I_TCON0_BASIC3_H_SYNC(hsync));\n\n\t \n\tif (mode->flags & DRM_MODE_FLAG_PHSYNC)\n\t\tval |= SUN4I_TCON0_IO_POL_HSYNC_POSITIVE;\n\n\tif (mode->flags & DRM_MODE_FLAG_PVSYNC)\n\t\tval |= SUN4I_TCON0_IO_POL_VSYNC_POSITIVE;\n\n\tif (info->bus_flags & DRM_BUS_FLAG_DE_LOW)\n\t\tval |= SUN4I_TCON0_IO_POL_DE_NEGATIVE;\n\n\tif (info->bus_flags & DRM_BUS_FLAG_PIXDATA_DRIVE_NEGEDGE)\n\t\tval |= SUN4I_TCON0_IO_POL_DCLK_DRIVE_NEGEDGE;\n\n\tregmap_update_bits(tcon->regs, SUN4I_TCON0_IO_POL_REG,\n\t\t\t   SUN4I_TCON0_IO_POL_HSYNC_POSITIVE |\n\t\t\t   SUN4I_TCON0_IO_POL_VSYNC_POSITIVE |\n\t\t\t   SUN4I_TCON0_IO_POL_DCLK_DRIVE_NEGEDGE |\n\t\t\t   SUN4I_TCON0_IO_POL_DE_NEGATIVE,\n\t\t\t   val);\n\n\t \n\tregmap_update_bits(tcon->regs, SUN4I_TCON_GCTL_REG,\n\t\t\t   SUN4I_TCON_GCTL_IOMAP_MASK,\n\t\t\t   SUN4I_TCON_GCTL_IOMAP_TCON0);\n\n\t \n\tregmap_write(tcon->regs, SUN4I_TCON0_IO_TRI_REG, 0);\n}\n\nstatic void sun4i_tcon1_mode_set(struct sun4i_tcon *tcon,\n\t\t\t\t const struct drm_display_mode *mode)\n{\n\tunsigned int bp, hsync, vsync, vtotal;\n\tu8 clk_delay;\n\tu32 val;\n\n\tWARN_ON(!tcon->quirks->has_channel_1);\n\n\t \n\tclk_set_rate(tcon->sclk1, mode->crtc_clock * 1000);\n\n\t \n\tclk_delay = sun4i_tcon_get_clk_delay(mode, 1);\n\tregmap_update_bits(tcon->regs, SUN4I_TCON1_CTL_REG,\n\t\t\t   SUN4I_TCON1_CTL_CLK_DELAY_MASK,\n\t\t\t   SUN4I_TCON1_CTL_CLK_DELAY(clk_delay));\n\n\t \n\tif (mode->flags & DRM_MODE_FLAG_INTERLACE)\n\t\tval = SUN4I_TCON1_CTL_INTERLACE_ENABLE;\n\telse\n\t\tval = 0;\n\tregmap_update_bits(tcon->regs, SUN4I_TCON1_CTL_REG,\n\t\t\t   SUN4I_TCON1_CTL_INTERLACE_ENABLE,\n\t\t\t   val);\n\n\t \n\tregmap_write(tcon->regs, SUN4I_TCON1_BASIC0_REG,\n\t\t     SUN4I_TCON1_BASIC0_X(mode->crtc_hdisplay) |\n\t\t     SUN4I_TCON1_BASIC0_Y(mode->crtc_vdisplay));\n\n\t \n\tregmap_write(tcon->regs, SUN4I_TCON1_BASIC1_REG,\n\t\t     SUN4I_TCON1_BASIC1_X(mode->crtc_hdisplay) |\n\t\t     SUN4I_TCON1_BASIC1_Y(mode->crtc_vdisplay));\n\n\t \n\tregmap_write(tcon->regs, SUN4I_TCON1_BASIC2_REG,\n\t\t     SUN4I_TCON1_BASIC2_X(mode->crtc_hdisplay) |\n\t\t     SUN4I_TCON1_BASIC2_Y(mode->crtc_vdisplay));\n\n\t \n\tbp = mode->crtc_htotal - mode->crtc_hsync_start;\n\tDRM_DEBUG_DRIVER(\"Setting horizontal total %d, backporch %d\\n\",\n\t\t\t mode->htotal, bp);\n\tregmap_write(tcon->regs, SUN4I_TCON1_BASIC3_REG,\n\t\t     SUN4I_TCON1_BASIC3_H_TOTAL(mode->crtc_htotal) |\n\t\t     SUN4I_TCON1_BASIC3_H_BACKPORCH(bp));\n\n\tbp = mode->crtc_vtotal - mode->crtc_vsync_start;\n\tDRM_DEBUG_DRIVER(\"Setting vertical total %d, backporch %d\\n\",\n\t\t\t mode->crtc_vtotal, bp);\n\n\t \n\tvtotal = mode->vtotal;\n\tif (!(mode->flags & DRM_MODE_FLAG_INTERLACE))\n\t\tvtotal = vtotal * 2;\n\n\t \n\tregmap_write(tcon->regs, SUN4I_TCON1_BASIC4_REG,\n\t\t     SUN4I_TCON1_BASIC4_V_TOTAL(vtotal) |\n\t\t     SUN4I_TCON1_BASIC4_V_BACKPORCH(bp));\n\n\t \n\thsync = mode->crtc_hsync_end - mode->crtc_hsync_start;\n\tvsync = mode->crtc_vsync_end - mode->crtc_vsync_start;\n\tDRM_DEBUG_DRIVER(\"Setting HSYNC %d, VSYNC %d\\n\", hsync, vsync);\n\tregmap_write(tcon->regs, SUN4I_TCON1_BASIC5_REG,\n\t\t     SUN4I_TCON1_BASIC5_V_SYNC(vsync) |\n\t\t     SUN4I_TCON1_BASIC5_H_SYNC(hsync));\n\n\t \n\tif (tcon->quirks->polarity_in_ch0) {\n\t\tval = 0;\n\n\t\tif (mode->flags & DRM_MODE_FLAG_PHSYNC)\n\t\t\tval |= SUN4I_TCON0_IO_POL_HSYNC_POSITIVE;\n\n\t\tif (mode->flags & DRM_MODE_FLAG_PVSYNC)\n\t\t\tval |= SUN4I_TCON0_IO_POL_VSYNC_POSITIVE;\n\n\t\tregmap_write(tcon->regs, SUN4I_TCON0_IO_POL_REG, val);\n\t} else {\n\t\t \n\t\tval = SUN4I_TCON1_IO_POL_UNKNOWN;\n\n\t\tif (mode->flags & DRM_MODE_FLAG_PHSYNC)\n\t\t\tval |= SUN4I_TCON1_IO_POL_HSYNC_POSITIVE;\n\n\t\tif (mode->flags & DRM_MODE_FLAG_PVSYNC)\n\t\t\tval |= SUN4I_TCON1_IO_POL_VSYNC_POSITIVE;\n\n\t\tregmap_write(tcon->regs, SUN4I_TCON1_IO_POL_REG, val);\n\t}\n\n\t \n\tregmap_update_bits(tcon->regs, SUN4I_TCON_GCTL_REG,\n\t\t\t   SUN4I_TCON_GCTL_IOMAP_MASK,\n\t\t\t   SUN4I_TCON_GCTL_IOMAP_TCON1);\n}\n\nvoid sun4i_tcon_mode_set(struct sun4i_tcon *tcon,\n\t\t\t const struct drm_encoder *encoder,\n\t\t\t const struct drm_display_mode *mode)\n{\n\tswitch (encoder->encoder_type) {\n\tcase DRM_MODE_ENCODER_DSI:\n\t\t \n\t\tsun4i_tcon0_mode_set_cpu(tcon, encoder, mode);\n\t\tbreak;\n\tcase DRM_MODE_ENCODER_LVDS:\n\t\tsun4i_tcon0_mode_set_lvds(tcon, encoder, mode);\n\t\tbreak;\n\tcase DRM_MODE_ENCODER_NONE:\n\t\tsun4i_tcon0_mode_set_rgb(tcon, encoder, mode);\n\t\tsun4i_tcon_set_mux(tcon, 0, encoder);\n\t\tbreak;\n\tcase DRM_MODE_ENCODER_TVDAC:\n\tcase DRM_MODE_ENCODER_TMDS:\n\t\tsun4i_tcon1_mode_set(tcon, mode);\n\t\tsun4i_tcon_set_mux(tcon, 1, encoder);\n\t\tbreak;\n\tdefault:\n\t\tDRM_DEBUG_DRIVER(\"Unknown encoder type, doing nothing...\\n\");\n\t}\n}\nEXPORT_SYMBOL(sun4i_tcon_mode_set);\n\nstatic void sun4i_tcon_finish_page_flip(struct drm_device *dev,\n\t\t\t\t\tstruct sun4i_crtc *scrtc)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&dev->event_lock, flags);\n\tif (scrtc->event) {\n\t\tdrm_crtc_send_vblank_event(&scrtc->crtc, scrtc->event);\n\t\tdrm_crtc_vblank_put(&scrtc->crtc);\n\t\tscrtc->event = NULL;\n\t}\n\tspin_unlock_irqrestore(&dev->event_lock, flags);\n}\n\nstatic irqreturn_t sun4i_tcon_handler(int irq, void *private)\n{\n\tstruct sun4i_tcon *tcon = private;\n\tstruct drm_device *drm = tcon->drm;\n\tstruct sun4i_crtc *scrtc = tcon->crtc;\n\tstruct sunxi_engine *engine = scrtc->engine;\n\tunsigned int status;\n\n\tregmap_read(tcon->regs, SUN4I_TCON_GINT0_REG, &status);\n\n\tif (!(status & (SUN4I_TCON_GINT0_VBLANK_INT(0) |\n\t\t\tSUN4I_TCON_GINT0_VBLANK_INT(1) |\n\t\t\tSUN4I_TCON_GINT0_TCON0_TRI_FINISH_INT)))\n\t\treturn IRQ_NONE;\n\n\tdrm_crtc_handle_vblank(&scrtc->crtc);\n\tsun4i_tcon_finish_page_flip(drm, scrtc);\n\n\t \n\tregmap_update_bits(tcon->regs, SUN4I_TCON_GINT0_REG,\n\t\t\t   SUN4I_TCON_GINT0_VBLANK_INT(0) |\n\t\t\t   SUN4I_TCON_GINT0_VBLANK_INT(1) |\n\t\t\t   SUN4I_TCON_GINT0_TCON0_TRI_FINISH_INT,\n\t\t\t   0);\n\n\tif (engine->ops->vblank_quirk)\n\t\tengine->ops->vblank_quirk(engine);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int sun4i_tcon_init_clocks(struct device *dev,\n\t\t\t\t  struct sun4i_tcon *tcon)\n{\n\ttcon->clk = devm_clk_get_enabled(dev, \"ahb\");\n\tif (IS_ERR(tcon->clk)) {\n\t\tdev_err(dev, \"Couldn't get the TCON bus clock\\n\");\n\t\treturn PTR_ERR(tcon->clk);\n\t}\n\n\tif (tcon->quirks->has_channel_0) {\n\t\ttcon->sclk0 = devm_clk_get_enabled(dev, \"tcon-ch0\");\n\t\tif (IS_ERR(tcon->sclk0)) {\n\t\t\tdev_err(dev, \"Couldn't get the TCON channel 0 clock\\n\");\n\t\t\treturn PTR_ERR(tcon->sclk0);\n\t\t}\n\t}\n\n\tif (tcon->quirks->has_channel_1) {\n\t\ttcon->sclk1 = devm_clk_get(dev, \"tcon-ch1\");\n\t\tif (IS_ERR(tcon->sclk1)) {\n\t\t\tdev_err(dev, \"Couldn't get the TCON channel 1 clock\\n\");\n\t\t\treturn PTR_ERR(tcon->sclk1);\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int sun4i_tcon_init_irq(struct device *dev,\n\t\t\t       struct sun4i_tcon *tcon)\n{\n\tstruct platform_device *pdev = to_platform_device(dev);\n\tint irq, ret;\n\n\tirq = platform_get_irq(pdev, 0);\n\tif (irq < 0)\n\t\treturn irq;\n\n\tret = devm_request_irq(dev, irq, sun4i_tcon_handler, 0,\n\t\t\t       dev_name(dev), tcon);\n\tif (ret) {\n\t\tdev_err(dev, \"Couldn't request the IRQ\\n\");\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic const struct regmap_config sun4i_tcon_regmap_config = {\n\t.reg_bits\t= 32,\n\t.val_bits\t= 32,\n\t.reg_stride\t= 4,\n\t.max_register\t= 0x800,\n};\n\nstatic int sun4i_tcon_init_regmap(struct device *dev,\n\t\t\t\t  struct sun4i_tcon *tcon)\n{\n\tstruct platform_device *pdev = to_platform_device(dev);\n\tvoid __iomem *regs;\n\n\tregs = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(regs))\n\t\treturn PTR_ERR(regs);\n\n\ttcon->regs = devm_regmap_init_mmio(dev, regs,\n\t\t\t\t\t   &sun4i_tcon_regmap_config);\n\tif (IS_ERR(tcon->regs)) {\n\t\tdev_err(dev, \"Couldn't create the TCON regmap\\n\");\n\t\treturn PTR_ERR(tcon->regs);\n\t}\n\n\t \n\tregmap_write(tcon->regs, SUN4I_TCON_GCTL_REG, 0);\n\tregmap_write(tcon->regs, SUN4I_TCON_GINT0_REG, 0);\n\tregmap_write(tcon->regs, SUN4I_TCON_GINT1_REG, 0);\n\n\t \n\tregmap_write(tcon->regs, SUN4I_TCON0_IO_TRI_REG, ~0);\n\tregmap_write(tcon->regs, SUN4I_TCON1_IO_TRI_REG, ~0);\n\n\treturn 0;\n}\n\n \nstatic struct sunxi_engine *\nsun4i_tcon_find_engine_traverse(struct sun4i_drv *drv,\n\t\t\t\tstruct device_node *node,\n\t\t\t\tu32 port_id)\n{\n\tstruct device_node *port, *ep, *remote;\n\tstruct sunxi_engine *engine = ERR_PTR(-EINVAL);\n\tu32 reg = 0;\n\n\tport = of_graph_get_port_by_id(node, port_id);\n\tif (!port)\n\t\treturn ERR_PTR(-EINVAL);\n\n\t \n\tif (of_get_available_child_count(port) != 1)\n\t\tgoto out_put_port;\n\n\t \n\tep = of_get_next_available_child(port, NULL);\n\tif (!ep)\n\t\tgoto out_put_port;\n\n\tremote = of_graph_get_remote_port_parent(ep);\n\tif (!remote)\n\t\tgoto out_put_ep;\n\n\t \n\tlist_for_each_entry(engine, &drv->engine_list, list)\n\t\tif (remote == engine->node)\n\t\t\tgoto out_put_remote;\n\n\t \n\tof_node_put(port);\n\tport = of_graph_get_remote_port(ep);\n\tif (!of_property_read_u32(port, \"reg\", &reg) && reg > 0)\n\t\treg -= 1;\n\n\t \n\tengine = sun4i_tcon_find_engine_traverse(drv, remote, reg);\n\nout_put_remote:\n\tof_node_put(remote);\nout_put_ep:\n\tof_node_put(ep);\nout_put_port:\n\tof_node_put(port);\n\n\treturn engine;\n}\n\n \nstatic int sun4i_tcon_of_get_id_from_port(struct device_node *port)\n{\n\tstruct device_node *ep;\n\tint ret = -EINVAL;\n\n\t \n\tfor_each_available_child_of_node(port, ep) {\n\t\tstruct device_node *remote;\n\t\tu32 reg;\n\n\t\tremote = of_graph_get_remote_endpoint(ep);\n\t\tif (!remote)\n\t\t\tcontinue;\n\n\t\tret = of_property_read_u32(remote, \"reg\", &reg);\n\t\tif (ret)\n\t\t\tcontinue;\n\n\t\tret = reg;\n\t}\n\n\treturn ret;\n}\n\n \nstatic struct sunxi_engine *sun4i_tcon_get_engine_by_id(struct sun4i_drv *drv,\n\t\t\t\t\t\t\tint id)\n{\n\tstruct sunxi_engine *engine;\n\n\tlist_for_each_entry(engine, &drv->engine_list, list)\n\t\tif (engine->id == id)\n\t\t\treturn engine;\n\n\treturn ERR_PTR(-EINVAL);\n}\n\nstatic bool sun4i_tcon_connected_to_tcon_top(struct device_node *node)\n{\n\tstruct device_node *remote;\n\tbool ret = false;\n\n\tremote = of_graph_get_remote_node(node, 0, -1);\n\tif (remote) {\n\t\tret = !!(IS_ENABLED(CONFIG_DRM_SUN8I_TCON_TOP) &&\n\t\t\t of_match_node(sun8i_tcon_top_of_table, remote));\n\t\tof_node_put(remote);\n\t}\n\n\treturn ret;\n}\n\nstatic int sun4i_tcon_get_index(struct sun4i_drv *drv)\n{\n\tstruct list_head *pos;\n\tint size = 0;\n\n\t \n\tlist_for_each(pos, &drv->tcon_list)\n\t\t++size;\n\n\treturn size;\n}\n\n \nstatic struct sunxi_engine *sun4i_tcon_find_engine(struct sun4i_drv *drv,\n\t\t\t\t\t\t   struct device_node *node)\n{\n\tstruct device_node *port;\n\tstruct sunxi_engine *engine;\n\n\tport = of_graph_get_port_by_id(node, 0);\n\tif (!port)\n\t\treturn ERR_PTR(-EINVAL);\n\n\t \n\tif (of_get_child_count(port) > 1) {\n\t\tint id;\n\n\t\t \n\t\tif (sun4i_tcon_connected_to_tcon_top(node))\n\t\t\tid = sun4i_tcon_get_index(drv);\n\t\telse\n\t\t\tid = sun4i_tcon_of_get_id_from_port(port);\n\n\t\t \n\t\tengine = sun4i_tcon_get_engine_by_id(drv, id);\n\n\t\tof_node_put(port);\n\t\treturn engine;\n\t}\n\n\t \n\tof_node_put(port);\n\treturn sun4i_tcon_find_engine_traverse(drv, node, 0);\n}\n\nstatic int sun4i_tcon_bind(struct device *dev, struct device *master,\n\t\t\t   void *data)\n{\n\tstruct drm_device *drm = data;\n\tstruct sun4i_drv *drv = drm->dev_private;\n\tstruct sunxi_engine *engine;\n\tstruct device_node *remote;\n\tstruct sun4i_tcon *tcon;\n\tstruct reset_control *edp_rstc;\n\tbool has_lvds_rst, has_lvds_alt, can_lvds;\n\tint ret;\n\n\tengine = sun4i_tcon_find_engine(drv, dev->of_node);\n\tif (IS_ERR(engine)) {\n\t\tdev_err(dev, \"Couldn't find matching engine\\n\");\n\t\treturn -EPROBE_DEFER;\n\t}\n\n\ttcon = devm_kzalloc(dev, sizeof(*tcon), GFP_KERNEL);\n\tif (!tcon)\n\t\treturn -ENOMEM;\n\tdev_set_drvdata(dev, tcon);\n\ttcon->drm = drm;\n\ttcon->dev = dev;\n\ttcon->id = engine->id;\n\ttcon->quirks = of_device_get_match_data(dev);\n\n\ttcon->lcd_rst = devm_reset_control_get(dev, \"lcd\");\n\tif (IS_ERR(tcon->lcd_rst)) {\n\t\tdev_err(dev, \"Couldn't get our reset line\\n\");\n\t\treturn PTR_ERR(tcon->lcd_rst);\n\t}\n\n\tif (tcon->quirks->needs_edp_reset) {\n\t\tedp_rstc = devm_reset_control_get_shared(dev, \"edp\");\n\t\tif (IS_ERR(edp_rstc)) {\n\t\t\tdev_err(dev, \"Couldn't get edp reset line\\n\");\n\t\t\treturn PTR_ERR(edp_rstc);\n\t\t}\n\n\t\tret = reset_control_deassert(edp_rstc);\n\t\tif (ret) {\n\t\t\tdev_err(dev, \"Couldn't deassert edp reset line\\n\");\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\t \n\tret = reset_control_reset(tcon->lcd_rst);\n\tif (ret) {\n\t\tdev_err(dev, \"Couldn't deassert our reset line\\n\");\n\t\treturn ret;\n\t}\n\n\tif (tcon->quirks->supports_lvds) {\n\t\t \n\t\ttcon->lvds_rst = devm_reset_control_get_optional(dev, \"lvds\");\n\t\tif (IS_ERR(tcon->lvds_rst)) {\n\t\t\tdev_err(dev, \"Couldn't get our reset line\\n\");\n\t\t\treturn PTR_ERR(tcon->lvds_rst);\n\t\t} else if (tcon->lvds_rst) {\n\t\t\thas_lvds_rst = true;\n\t\t\treset_control_reset(tcon->lvds_rst);\n\t\t} else {\n\t\t\thas_lvds_rst = false;\n\t\t}\n\n\t\t \n\t\tif (tcon->quirks->has_lvds_alt) {\n\t\t\ttcon->lvds_pll = devm_clk_get(dev, \"lvds-alt\");\n\t\t\tif (IS_ERR(tcon->lvds_pll)) {\n\t\t\t\tif (PTR_ERR(tcon->lvds_pll) == -ENOENT) {\n\t\t\t\t\thas_lvds_alt = false;\n\t\t\t\t} else {\n\t\t\t\t\tdev_err(dev, \"Couldn't get the LVDS PLL\\n\");\n\t\t\t\t\treturn PTR_ERR(tcon->lvds_pll);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\thas_lvds_alt = true;\n\t\t\t}\n\t\t}\n\n\t\tif (!has_lvds_rst ||\n\t\t    (tcon->quirks->has_lvds_alt && !has_lvds_alt)) {\n\t\t\tdev_warn(dev, \"Missing LVDS properties, Please upgrade your DT\\n\");\n\t\t\tdev_warn(dev, \"LVDS output disabled\\n\");\n\t\t\tcan_lvds = false;\n\t\t} else {\n\t\t\tcan_lvds = true;\n\t\t}\n\t} else {\n\t\tcan_lvds = false;\n\t}\n\n\tret = sun4i_tcon_init_clocks(dev, tcon);\n\tif (ret) {\n\t\tdev_err(dev, \"Couldn't init our TCON clocks\\n\");\n\t\tgoto err_assert_reset;\n\t}\n\n\tret = sun4i_tcon_init_regmap(dev, tcon);\n\tif (ret) {\n\t\tdev_err(dev, \"Couldn't init our TCON regmap\\n\");\n\t\tgoto err_assert_reset;\n\t}\n\n\tif (tcon->quirks->has_channel_0) {\n\t\tret = sun4i_dclk_create(dev, tcon);\n\t\tif (ret) {\n\t\t\tdev_err(dev, \"Couldn't create our TCON dot clock\\n\");\n\t\t\tgoto err_assert_reset;\n\t\t}\n\t}\n\n\tret = sun4i_tcon_init_irq(dev, tcon);\n\tif (ret) {\n\t\tdev_err(dev, \"Couldn't init our TCON interrupts\\n\");\n\t\tgoto err_free_dclk;\n\t}\n\n\ttcon->crtc = sun4i_crtc_init(drm, engine, tcon);\n\tif (IS_ERR(tcon->crtc)) {\n\t\tdev_err(dev, \"Couldn't create our CRTC\\n\");\n\t\tret = PTR_ERR(tcon->crtc);\n\t\tgoto err_free_dclk;\n\t}\n\n\tif (tcon->quirks->has_channel_0) {\n\t\t \n\t\tremote = of_graph_get_remote_node(dev->of_node, 1, 0);\n\t\tif (of_device_is_compatible(remote, \"panel-lvds\"))\n\t\t\tif (can_lvds)\n\t\t\t\tret = sun4i_lvds_init(drm, tcon);\n\t\t\telse\n\t\t\t\tret = -EINVAL;\n\t\telse\n\t\t\tret = sun4i_rgb_init(drm, tcon);\n\t\tof_node_put(remote);\n\n\t\tif (ret < 0)\n\t\t\tgoto err_free_dclk;\n\t}\n\n\tif (tcon->quirks->needs_de_be_mux) {\n\t\t \n\t\tregmap_update_bits(tcon->regs, SUN4I_TCON0_CTL_REG,\n\t\t\t\t   SUN4I_TCON0_CTL_SRC_SEL_MASK,\n\t\t\t\t   tcon->id);\n\t\tregmap_update_bits(tcon->regs, SUN4I_TCON1_CTL_REG,\n\t\t\t\t   SUN4I_TCON1_CTL_SRC_SEL_MASK,\n\t\t\t\t   tcon->id);\n\t}\n\n\tlist_add_tail(&tcon->list, &drv->tcon_list);\n\n\treturn 0;\n\nerr_free_dclk:\n\tif (tcon->quirks->has_channel_0)\n\t\tsun4i_dclk_free(tcon);\nerr_assert_reset:\n\treset_control_assert(tcon->lcd_rst);\n\treturn ret;\n}\n\nstatic void sun4i_tcon_unbind(struct device *dev, struct device *master,\n\t\t\t      void *data)\n{\n\tstruct sun4i_tcon *tcon = dev_get_drvdata(dev);\n\n\tlist_del(&tcon->list);\n\tif (tcon->quirks->has_channel_0)\n\t\tsun4i_dclk_free(tcon);\n}\n\nstatic const struct component_ops sun4i_tcon_ops = {\n\t.bind\t= sun4i_tcon_bind,\n\t.unbind\t= sun4i_tcon_unbind,\n};\n\nstatic int sun4i_tcon_probe(struct platform_device *pdev)\n{\n\tstruct device_node *node = pdev->dev.of_node;\n\tconst struct sun4i_tcon_quirks *quirks;\n\tstruct drm_bridge *bridge;\n\tstruct drm_panel *panel;\n\tint ret;\n\n\tquirks = of_device_get_match_data(&pdev->dev);\n\n\t \n\tif (quirks->has_channel_0) {\n\t\tret = drm_of_find_panel_or_bridge(node, 1, 0, &panel, &bridge);\n\t\tif (ret == -EPROBE_DEFER)\n\t\t\treturn ret;\n\t}\n\n\treturn component_add(&pdev->dev, &sun4i_tcon_ops);\n}\n\nstatic void sun4i_tcon_remove(struct platform_device *pdev)\n{\n\tcomponent_del(&pdev->dev, &sun4i_tcon_ops);\n}\n\n \nstatic int sun4i_a10_tcon_set_mux(struct sun4i_tcon *tcon,\n\t\t\t\t  const struct drm_encoder *encoder)\n{\n\tstruct sun4i_tcon *tcon0 = sun4i_get_tcon0(encoder->dev);\n\tu32 shift;\n\n\tif (!tcon0)\n\t\treturn -EINVAL;\n\n\tswitch (encoder->encoder_type) {\n\tcase DRM_MODE_ENCODER_TMDS:\n\t\t \n\t\tshift = 8;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tregmap_update_bits(tcon0->regs, SUN4I_TCON_MUX_CTRL_REG,\n\t\t\t   0x3 << shift, tcon->id << shift);\n\n\treturn 0;\n}\n\nstatic int sun5i_a13_tcon_set_mux(struct sun4i_tcon *tcon,\n\t\t\t\t  const struct drm_encoder *encoder)\n{\n\tu32 val;\n\n\tif (encoder->encoder_type == DRM_MODE_ENCODER_TVDAC)\n\t\tval = 1;\n\telse\n\t\tval = 0;\n\n\t \n\treturn regmap_write(tcon->regs, SUN4I_TCON_MUX_CTRL_REG, val);\n}\n\nstatic int sun6i_tcon_set_mux(struct sun4i_tcon *tcon,\n\t\t\t      const struct drm_encoder *encoder)\n{\n\tstruct sun4i_tcon *tcon0 = sun4i_get_tcon0(encoder->dev);\n\tu32 shift;\n\n\tif (!tcon0)\n\t\treturn -EINVAL;\n\n\tswitch (encoder->encoder_type) {\n\tcase DRM_MODE_ENCODER_TMDS:\n\t\t \n\t\tshift = 8;\n\t\tbreak;\n\tdefault:\n\t\t \n\t\treturn -EINVAL;\n\t}\n\n\tregmap_update_bits(tcon0->regs, SUN4I_TCON_MUX_CTRL_REG,\n\t\t\t   0x3 << shift, tcon->id << shift);\n\n\treturn 0;\n}\n\nstatic int sun8i_r40_tcon_tv_set_mux(struct sun4i_tcon *tcon,\n\t\t\t\t     const struct drm_encoder *encoder)\n{\n\tstruct device_node *port, *remote;\n\tstruct platform_device *pdev;\n\tint id, ret;\n\n\t \n\n\tport = of_graph_get_port_by_id(tcon->dev->of_node, 0);\n\tif (!port)\n\t\treturn -EINVAL;\n\n\tid = sun4i_tcon_of_get_id_from_port(port);\n\tof_node_put(port);\n\n\tremote = of_graph_get_remote_node(tcon->dev->of_node, 0, -1);\n\tif (!remote)\n\t\treturn -EINVAL;\n\n\tpdev = of_find_device_by_node(remote);\n\tof_node_put(remote);\n\tif (!pdev)\n\t\treturn -EINVAL;\n\n\tif (IS_ENABLED(CONFIG_DRM_SUN8I_TCON_TOP) &&\n\t    encoder->encoder_type == DRM_MODE_ENCODER_TMDS) {\n\t\tret = sun8i_tcon_top_set_hdmi_src(&pdev->dev, id);\n\t\tif (ret) {\n\t\t\tput_device(&pdev->dev);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tif (IS_ENABLED(CONFIG_DRM_SUN8I_TCON_TOP)) {\n\t\tret = sun8i_tcon_top_de_config(&pdev->dev, tcon->id, id);\n\t\tif (ret) {\n\t\t\tput_device(&pdev->dev);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic const struct sun4i_tcon_quirks sun4i_a10_quirks = {\n\t.has_channel_0\t\t= true,\n\t.has_channel_1\t\t= true,\n\t.dclk_min_div\t\t= 4,\n\t.set_mux\t\t= sun4i_a10_tcon_set_mux,\n};\n\nstatic const struct sun4i_tcon_quirks sun5i_a13_quirks = {\n\t.has_channel_0\t\t= true,\n\t.has_channel_1\t\t= true,\n\t.dclk_min_div\t\t= 4,\n\t.set_mux\t\t= sun5i_a13_tcon_set_mux,\n};\n\nstatic const struct sun4i_tcon_quirks sun6i_a31_quirks = {\n\t.has_channel_0\t\t= true,\n\t.has_channel_1\t\t= true,\n\t.has_lvds_alt\t\t= true,\n\t.needs_de_be_mux\t= true,\n\t.dclk_min_div\t\t= 1,\n\t.set_mux\t\t= sun6i_tcon_set_mux,\n};\n\nstatic const struct sun4i_tcon_quirks sun6i_a31s_quirks = {\n\t.has_channel_0\t\t= true,\n\t.has_channel_1\t\t= true,\n\t.needs_de_be_mux\t= true,\n\t.dclk_min_div\t\t= 1,\n};\n\nstatic const struct sun4i_tcon_quirks sun7i_a20_tcon0_quirks = {\n\t.supports_lvds\t\t= true,\n\t.has_channel_0\t\t= true,\n\t.has_channel_1\t\t= true,\n\t.dclk_min_div\t\t= 4,\n\t \n\t.set_mux\t\t= sun4i_a10_tcon_set_mux,\n\t.setup_lvds_phy\t\t= sun4i_tcon_setup_lvds_phy,\n};\n\nstatic const struct sun4i_tcon_quirks sun7i_a20_quirks = {\n\t.has_channel_0\t\t= true,\n\t.has_channel_1\t\t= true,\n\t.dclk_min_div\t\t= 4,\n\t \n\t.set_mux\t\t= sun4i_a10_tcon_set_mux,\n};\n\nstatic const struct sun4i_tcon_quirks sun8i_a33_quirks = {\n\t.has_channel_0\t\t= true,\n\t.has_lvds_alt\t\t= true,\n\t.dclk_min_div\t\t= 1,\n\t.setup_lvds_phy\t\t= sun6i_tcon_setup_lvds_phy,\n\t.supports_lvds\t\t= true,\n};\n\nstatic const struct sun4i_tcon_quirks sun8i_a83t_lcd_quirks = {\n\t.supports_lvds\t\t= true,\n\t.has_channel_0\t\t= true,\n\t.dclk_min_div\t\t= 1,\n\t.setup_lvds_phy\t\t= sun6i_tcon_setup_lvds_phy,\n};\n\nstatic const struct sun4i_tcon_quirks sun8i_a83t_tv_quirks = {\n\t.has_channel_1\t\t= true,\n};\n\nstatic const struct sun4i_tcon_quirks sun8i_r40_tv_quirks = {\n\t.has_channel_1\t\t= true,\n\t.polarity_in_ch0\t= true,\n\t.set_mux\t\t= sun8i_r40_tcon_tv_set_mux,\n};\n\nstatic const struct sun4i_tcon_quirks sun8i_v3s_quirks = {\n\t.has_channel_0\t\t= true,\n\t.dclk_min_div\t\t= 1,\n};\n\nstatic const struct sun4i_tcon_quirks sun9i_a80_tcon_lcd_quirks = {\n\t.has_channel_0\t\t= true,\n\t.needs_edp_reset\t= true,\n\t.dclk_min_div\t\t= 1,\n};\n\nstatic const struct sun4i_tcon_quirks sun9i_a80_tcon_tv_quirks = {\n\t.has_channel_1\t= true,\n\t.needs_edp_reset = true,\n};\n\nstatic const struct sun4i_tcon_quirks sun20i_d1_lcd_quirks = {\n\t.has_channel_0\t\t= true,\n\t.dclk_min_div\t\t= 1,\n\t.set_mux\t\t= sun8i_r40_tcon_tv_set_mux,\n};\n\n \nconst struct of_device_id sun4i_tcon_of_table[] = {\n\t{ .compatible = \"allwinner,sun4i-a10-tcon\", .data = &sun4i_a10_quirks },\n\t{ .compatible = \"allwinner,sun5i-a13-tcon\", .data = &sun5i_a13_quirks },\n\t{ .compatible = \"allwinner,sun6i-a31-tcon\", .data = &sun6i_a31_quirks },\n\t{ .compatible = \"allwinner,sun6i-a31s-tcon\", .data = &sun6i_a31s_quirks },\n\t{ .compatible = \"allwinner,sun7i-a20-tcon\", .data = &sun7i_a20_quirks },\n\t{ .compatible = \"allwinner,sun7i-a20-tcon0\", .data = &sun7i_a20_tcon0_quirks },\n\t{ .compatible = \"allwinner,sun7i-a20-tcon1\", .data = &sun7i_a20_quirks },\n\t{ .compatible = \"allwinner,sun8i-a23-tcon\", .data = &sun8i_a33_quirks },\n\t{ .compatible = \"allwinner,sun8i-a33-tcon\", .data = &sun8i_a33_quirks },\n\t{ .compatible = \"allwinner,sun8i-a83t-tcon-lcd\", .data = &sun8i_a83t_lcd_quirks },\n\t{ .compatible = \"allwinner,sun8i-a83t-tcon-tv\", .data = &sun8i_a83t_tv_quirks },\n\t{ .compatible = \"allwinner,sun8i-r40-tcon-tv\", .data = &sun8i_r40_tv_quirks },\n\t{ .compatible = \"allwinner,sun8i-v3s-tcon\", .data = &sun8i_v3s_quirks },\n\t{ .compatible = \"allwinner,sun9i-a80-tcon-lcd\", .data = &sun9i_a80_tcon_lcd_quirks },\n\t{ .compatible = \"allwinner,sun9i-a80-tcon-tv\", .data = &sun9i_a80_tcon_tv_quirks },\n\t{ .compatible = \"allwinner,sun20i-d1-tcon-lcd\", .data = &sun20i_d1_lcd_quirks },\n\t{ .compatible = \"allwinner,sun20i-d1-tcon-tv\", .data = &sun8i_r40_tv_quirks },\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, sun4i_tcon_of_table);\nEXPORT_SYMBOL(sun4i_tcon_of_table);\n\nstatic struct platform_driver sun4i_tcon_platform_driver = {\n\t.probe\t\t= sun4i_tcon_probe,\n\t.remove_new\t= sun4i_tcon_remove,\n\t.driver\t\t= {\n\t\t.name\t\t= \"sun4i-tcon\",\n\t\t.of_match_table\t= sun4i_tcon_of_table,\n\t},\n};\nmodule_platform_driver(sun4i_tcon_platform_driver);\n\nMODULE_AUTHOR(\"Maxime Ripard <maxime.ripard@free-electrons.com>\");\nMODULE_DESCRIPTION(\"Allwinner A10 Timing Controller Driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}