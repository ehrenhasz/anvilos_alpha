{
  "module_name": "sun8i_tcon_top.c",
  "hash_id": "aa25cc0db541bd70296319ef392c11c57fd0320a9966fb6459708ebdb3a431da",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/sun4i/sun8i_tcon_top.c",
  "human_readable_source": "\n \n\n\n#include <linux/bitfield.h>\n#include <linux/component.h>\n#include <linux/device.h>\n#include <linux/io.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/of_graph.h>\n#include <linux/platform_device.h>\n\n#include <dt-bindings/clock/sun8i-tcon-top.h>\n\n#include \"sun8i_tcon_top.h\"\n\nstruct sun8i_tcon_top_quirks {\n\tbool has_tcon_tv1;\n\tbool has_dsi;\n};\n\nstatic bool sun8i_tcon_top_node_is_tcon_top(struct device_node *node)\n{\n\treturn !!of_match_node(sun8i_tcon_top_of_table, node);\n}\n\nint sun8i_tcon_top_set_hdmi_src(struct device *dev, int tcon)\n{\n\tstruct sun8i_tcon_top *tcon_top = dev_get_drvdata(dev);\n\tunsigned long flags;\n\tu32 val;\n\n\tif (!sun8i_tcon_top_node_is_tcon_top(dev->of_node)) {\n\t\tdev_err(dev, \"Device is not TCON TOP!\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (tcon < 2 || tcon > 3) {\n\t\tdev_err(dev, \"TCON index must be 2 or 3!\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tspin_lock_irqsave(&tcon_top->reg_lock, flags);\n\n\tval = readl(tcon_top->regs + TCON_TOP_GATE_SRC_REG);\n\tval &= ~TCON_TOP_HDMI_SRC_MSK;\n\tval |= FIELD_PREP(TCON_TOP_HDMI_SRC_MSK, tcon - 1);\n\twritel(val, tcon_top->regs + TCON_TOP_GATE_SRC_REG);\n\n\tspin_unlock_irqrestore(&tcon_top->reg_lock, flags);\n\n\treturn 0;\n}\nEXPORT_SYMBOL(sun8i_tcon_top_set_hdmi_src);\n\nint sun8i_tcon_top_de_config(struct device *dev, int mixer, int tcon)\n{\n\tstruct sun8i_tcon_top *tcon_top = dev_get_drvdata(dev);\n\tunsigned long flags;\n\tu32 reg;\n\n\tif (!sun8i_tcon_top_node_is_tcon_top(dev->of_node)) {\n\t\tdev_err(dev, \"Device is not TCON TOP!\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (mixer > 1) {\n\t\tdev_err(dev, \"Mixer index is too high!\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (tcon > 3) {\n\t\tdev_err(dev, \"TCON index is too high!\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tspin_lock_irqsave(&tcon_top->reg_lock, flags);\n\n\treg = readl(tcon_top->regs + TCON_TOP_PORT_SEL_REG);\n\tif (mixer == 0) {\n\t\treg &= ~TCON_TOP_PORT_DE0_MSK;\n\t\treg |= FIELD_PREP(TCON_TOP_PORT_DE0_MSK, tcon);\n\t} else {\n\t\treg &= ~TCON_TOP_PORT_DE1_MSK;\n\t\treg |= FIELD_PREP(TCON_TOP_PORT_DE1_MSK, tcon);\n\t}\n\twritel(reg, tcon_top->regs + TCON_TOP_PORT_SEL_REG);\n\n\tspin_unlock_irqrestore(&tcon_top->reg_lock, flags);\n\n\treturn 0;\n}\nEXPORT_SYMBOL(sun8i_tcon_top_de_config);\n\n\nstatic struct clk_hw *sun8i_tcon_top_register_gate(struct device *dev,\n\t\t\t\t\t\t   const char *parent,\n\t\t\t\t\t\t   void __iomem *regs,\n\t\t\t\t\t\t   spinlock_t *lock,\n\t\t\t\t\t\t   u8 bit, int name_index)\n{\n\tconst char *clk_name, *parent_name;\n\tint ret, index;\n\n\tindex = of_property_match_string(dev->of_node, \"clock-names\", parent);\n\tif (index < 0)\n\t\treturn ERR_PTR(index);\n\n\tparent_name = of_clk_get_parent_name(dev->of_node, index);\n\n\tret = of_property_read_string_index(dev->of_node,\n\t\t\t\t\t    \"clock-output-names\", name_index,\n\t\t\t\t\t    &clk_name);\n\tif (ret)\n\t\treturn ERR_PTR(ret);\n\n\treturn clk_hw_register_gate(dev, clk_name, parent_name,\n\t\t\t\t    CLK_SET_RATE_PARENT,\n\t\t\t\t    regs + TCON_TOP_GATE_SRC_REG,\n\t\t\t\t    bit, 0, lock);\n};\n\nstatic int sun8i_tcon_top_bind(struct device *dev, struct device *master,\n\t\t\t       void *data)\n{\n\tstruct platform_device *pdev = to_platform_device(dev);\n\tstruct clk_hw_onecell_data *clk_data;\n\tstruct sun8i_tcon_top *tcon_top;\n\tconst struct sun8i_tcon_top_quirks *quirks;\n\tvoid __iomem *regs;\n\tint ret, i;\n\n\tquirks = of_device_get_match_data(&pdev->dev);\n\n\ttcon_top = devm_kzalloc(dev, sizeof(*tcon_top), GFP_KERNEL);\n\tif (!tcon_top)\n\t\treturn -ENOMEM;\n\n\tclk_data = devm_kzalloc(dev, struct_size(clk_data, hws, CLK_NUM),\n\t\t\t\tGFP_KERNEL);\n\tif (!clk_data)\n\t\treturn -ENOMEM;\n\tclk_data->num = CLK_NUM;\n\ttcon_top->clk_data = clk_data;\n\n\tspin_lock_init(&tcon_top->reg_lock);\n\n\ttcon_top->rst = devm_reset_control_get(dev, NULL);\n\tif (IS_ERR(tcon_top->rst)) {\n\t\tdev_err(dev, \"Couldn't get our reset line\\n\");\n\t\treturn PTR_ERR(tcon_top->rst);\n\t}\n\n\ttcon_top->bus = devm_clk_get(dev, \"bus\");\n\tif (IS_ERR(tcon_top->bus)) {\n\t\tdev_err(dev, \"Couldn't get the bus clock\\n\");\n\t\treturn PTR_ERR(tcon_top->bus);\n\t}\n\n\tregs = devm_platform_ioremap_resource(pdev, 0);\n\ttcon_top->regs = regs;\n\tif (IS_ERR(regs))\n\t\treturn PTR_ERR(regs);\n\n\tret = reset_control_deassert(tcon_top->rst);\n\tif (ret) {\n\t\tdev_err(dev, \"Could not deassert ctrl reset control\\n\");\n\t\treturn ret;\n\t}\n\n\tret = clk_prepare_enable(tcon_top->bus);\n\tif (ret) {\n\t\tdev_err(dev, \"Could not enable bus clock\\n\");\n\t\tgoto err_assert_reset;\n\t}\n\n\t \n\twritel(0, regs + TCON_TOP_PORT_SEL_REG);\n\twritel(0, regs + TCON_TOP_GATE_SRC_REG);\n\n\t \n\ti = 0;\n\tclk_data->hws[CLK_TCON_TOP_TV0] =\n\t\tsun8i_tcon_top_register_gate(dev, \"tcon-tv0\", regs,\n\t\t\t\t\t     &tcon_top->reg_lock,\n\t\t\t\t\t     TCON_TOP_TCON_TV0_GATE, i++);\n\n\tif (quirks->has_tcon_tv1)\n\t\tclk_data->hws[CLK_TCON_TOP_TV1] =\n\t\t\tsun8i_tcon_top_register_gate(dev, \"tcon-tv1\", regs,\n\t\t\t\t\t\t     &tcon_top->reg_lock,\n\t\t\t\t\t\t     TCON_TOP_TCON_TV1_GATE, i++);\n\n\tif (quirks->has_dsi)\n\t\tclk_data->hws[CLK_TCON_TOP_DSI] =\n\t\t\tsun8i_tcon_top_register_gate(dev, \"dsi\", regs,\n\t\t\t\t\t\t     &tcon_top->reg_lock,\n\t\t\t\t\t\t     TCON_TOP_TCON_DSI_GATE, i++);\n\n\tfor (i = 0; i < CLK_NUM; i++)\n\t\tif (IS_ERR(clk_data->hws[i])) {\n\t\t\tret = PTR_ERR(clk_data->hws[i]);\n\t\t\tgoto err_unregister_gates;\n\t\t}\n\n\tret = of_clk_add_hw_provider(dev->of_node, of_clk_hw_onecell_get,\n\t\t\t\t     clk_data);\n\tif (ret)\n\t\tgoto err_unregister_gates;\n\n\tdev_set_drvdata(dev, tcon_top);\n\n\treturn 0;\n\nerr_unregister_gates:\n\tfor (i = 0; i < CLK_NUM; i++)\n\t\tif (!IS_ERR_OR_NULL(clk_data->hws[i]))\n\t\t\tclk_hw_unregister_gate(clk_data->hws[i]);\n\tclk_disable_unprepare(tcon_top->bus);\nerr_assert_reset:\n\treset_control_assert(tcon_top->rst);\n\n\treturn ret;\n}\n\nstatic void sun8i_tcon_top_unbind(struct device *dev, struct device *master,\n\t\t\t\t  void *data)\n{\n\tstruct sun8i_tcon_top *tcon_top = dev_get_drvdata(dev);\n\tstruct clk_hw_onecell_data *clk_data = tcon_top->clk_data;\n\tint i;\n\n\tof_clk_del_provider(dev->of_node);\n\tfor (i = 0; i < CLK_NUM; i++)\n\t\tif (clk_data->hws[i])\n\t\t\tclk_hw_unregister_gate(clk_data->hws[i]);\n\n\tclk_disable_unprepare(tcon_top->bus);\n\treset_control_assert(tcon_top->rst);\n}\n\nstatic const struct component_ops sun8i_tcon_top_ops = {\n\t.bind\t= sun8i_tcon_top_bind,\n\t.unbind\t= sun8i_tcon_top_unbind,\n};\n\nstatic int sun8i_tcon_top_probe(struct platform_device *pdev)\n{\n\treturn component_add(&pdev->dev, &sun8i_tcon_top_ops);\n}\n\nstatic void sun8i_tcon_top_remove(struct platform_device *pdev)\n{\n\tcomponent_del(&pdev->dev, &sun8i_tcon_top_ops);\n}\n\nstatic const struct sun8i_tcon_top_quirks sun8i_r40_tcon_top_quirks = {\n\t.has_tcon_tv1\t= true,\n\t.has_dsi\t= true,\n};\n\nstatic const struct sun8i_tcon_top_quirks sun20i_d1_tcon_top_quirks = {\n\t.has_dsi\t= true,\n};\n\nstatic const struct sun8i_tcon_top_quirks sun50i_h6_tcon_top_quirks = {\n\t \n};\n\n \nconst struct of_device_id sun8i_tcon_top_of_table[] = {\n\t{\n\t\t.compatible = \"allwinner,sun8i-r40-tcon-top\",\n\t\t.data = &sun8i_r40_tcon_top_quirks\n\t},\n\t{\n\t\t.compatible = \"allwinner,sun20i-d1-tcon-top\",\n\t\t.data = &sun20i_d1_tcon_top_quirks\n\t},\n\t{\n\t\t.compatible = \"allwinner,sun50i-h6-tcon-top\",\n\t\t.data = &sun50i_h6_tcon_top_quirks\n\t},\n\t{   }\n};\nMODULE_DEVICE_TABLE(of, sun8i_tcon_top_of_table);\nEXPORT_SYMBOL(sun8i_tcon_top_of_table);\n\nstatic struct platform_driver sun8i_tcon_top_platform_driver = {\n\t.probe\t\t= sun8i_tcon_top_probe,\n\t.remove_new\t= sun8i_tcon_top_remove,\n\t.driver\t\t= {\n\t\t.name\t\t= \"sun8i-tcon-top\",\n\t\t.of_match_table\t= sun8i_tcon_top_of_table,\n\t},\n};\nmodule_platform_driver(sun8i_tcon_top_platform_driver);\n\nMODULE_AUTHOR(\"Jernej Skrabec <jernej.skrabec@siol.net>\");\nMODULE_DESCRIPTION(\"Allwinner R40 TCON TOP driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}