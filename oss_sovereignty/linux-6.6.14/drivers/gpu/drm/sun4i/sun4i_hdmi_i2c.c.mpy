{
  "module_name": "sun4i_hdmi_i2c.c",
  "hash_id": "fe2c91b9c2dbe51dff8f2962f85c616a741ee6754ecbfca4861286982faca474",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/sun4i/sun4i_hdmi_i2c.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/i2c.h>\n#include <linux/iopoll.h>\n\n#include \"sun4i_hdmi.h\"\n\n#define SUN4I_HDMI_DDC_INT_STATUS_ERROR_MASK ( \\\n\tSUN4I_HDMI_DDC_INT_STATUS_ILLEGAL_FIFO_OPERATION | \\\n\tSUN4I_HDMI_DDC_INT_STATUS_DDC_RX_FIFO_UNDERFLOW | \\\n\tSUN4I_HDMI_DDC_INT_STATUS_DDC_TX_FIFO_OVERFLOW | \\\n\tSUN4I_HDMI_DDC_INT_STATUS_ARBITRATION_ERROR | \\\n\tSUN4I_HDMI_DDC_INT_STATUS_ACK_ERROR | \\\n\tSUN4I_HDMI_DDC_INT_STATUS_BUS_ERROR \\\n)\n\n \n#define RX_THRESHOLD SUN4I_HDMI_DDC_FIFO_CTRL_RX_THRES_MAX\n\nstatic int fifo_transfer(struct sun4i_hdmi *hdmi, u8 *buf, int len, bool read)\n{\n\t \n\tconst unsigned long byte_time_ns = 100;\n\tconst u32 mask = SUN4I_HDMI_DDC_INT_STATUS_ERROR_MASK |\n\t\t\t SUN4I_HDMI_DDC_INT_STATUS_FIFO_REQUEST |\n\t\t\t SUN4I_HDMI_DDC_INT_STATUS_TRANSFER_COMPLETE;\n\tu32 reg;\n\t \n\tint read_len = RX_THRESHOLD +\n\t\t(hdmi->variant->ddc_fifo_thres_incl ? 0 : 1);\n\n\t \n\tlen = min_t(int, len, read ? read_len : SUN4I_HDMI_DDC_FIFO_SIZE);\n\n\t \n\tif (regmap_field_read_poll_timeout(hdmi->field_ddc_int_status, reg,\n\t\t\t\t\t   reg & mask, len * byte_time_ns,\n\t\t\t\t\t   100000))\n\t\treturn -ETIMEDOUT;\n\n\tif (reg & SUN4I_HDMI_DDC_INT_STATUS_ERROR_MASK)\n\t\treturn -EIO;\n\n\tif (read)\n\t\tioread8_rep(hdmi->base + hdmi->variant->ddc_fifo_reg, buf, len);\n\telse\n\t\tiowrite8_rep(hdmi->base + hdmi->variant->ddc_fifo_reg, buf, len);\n\n\t \n\tregmap_field_force_write(hdmi->field_ddc_int_status,\n\t\t\t\t SUN4I_HDMI_DDC_INT_STATUS_FIFO_REQUEST);\n\n\treturn len;\n}\n\nstatic int xfer_msg(struct sun4i_hdmi *hdmi, struct i2c_msg *msg)\n{\n\tint i, len;\n\tu32 reg;\n\n\t \n\tif (hdmi->variant->ddc_fifo_has_dir) {\n\t\treg = readl(hdmi->base + SUN4I_HDMI_DDC_CTRL_REG);\n\t\treg &= ~SUN4I_HDMI_DDC_CTRL_FIFO_DIR_MASK;\n\t\treg |= (msg->flags & I2C_M_RD) ?\n\t\t       SUN4I_HDMI_DDC_CTRL_FIFO_DIR_READ :\n\t\t       SUN4I_HDMI_DDC_CTRL_FIFO_DIR_WRITE;\n\t\twritel(reg, hdmi->base + SUN4I_HDMI_DDC_CTRL_REG);\n\t}\n\n\t \n\tregmap_field_write(hdmi->field_ddc_addr_reg, 0);\n\n\t \n\tregmap_field_write(hdmi->field_ddc_slave_addr, msg->addr);\n\n\t \n\tregmap_field_write(hdmi->field_ddc_fifo_tx_thres,\n\t\t\t   hdmi->variant->ddc_fifo_thres_incl ? 0 : 1);\n\tregmap_field_write(hdmi->field_ddc_fifo_rx_thres, RX_THRESHOLD);\n\tregmap_field_write(hdmi->field_ddc_fifo_clear, 1);\n\tif (regmap_field_read_poll_timeout(hdmi->field_ddc_fifo_clear,\n\t\t\t\t\t   reg, !reg, 100, 2000))\n\t\treturn -EIO;\n\n\t \n\tregmap_field_write(hdmi->field_ddc_byte_count, msg->len);\n\n\t \n\tregmap_field_write(hdmi->field_ddc_cmd,\n\t\t\t   msg->flags & I2C_M_RD ?\n\t\t\t   SUN4I_HDMI_DDC_CMD_IMPLICIT_READ :\n\t\t\t   SUN4I_HDMI_DDC_CMD_IMPLICIT_WRITE);\n\n\t \n\tregmap_field_force_write(hdmi->field_ddc_int_status,\n\t\t\t\t SUN4I_HDMI_DDC_INT_STATUS_ERROR_MASK |\n\t\t\t\t SUN4I_HDMI_DDC_INT_STATUS_FIFO_REQUEST |\n\t\t\t\t SUN4I_HDMI_DDC_INT_STATUS_TRANSFER_COMPLETE);\n\n\t \n\tregmap_field_write(hdmi->field_ddc_start, 1);\n\n\t \n\tfor (i = 0; i < msg->len; i += len) {\n\t\tlen = fifo_transfer(hdmi, msg->buf + i, msg->len - i,\n\t\t\t\t    msg->flags & I2C_M_RD);\n\t\tif (len <= 0)\n\t\t\treturn len;\n\t}\n\n\t \n\tif (regmap_field_read_poll_timeout(hdmi->field_ddc_start,\n\t\t\t\t\t   reg, !reg, 100, 100000))\n\t\treturn -EIO;\n\n\t \n\tregmap_field_read(hdmi->field_ddc_int_status, &reg);\n\tif ((reg & SUN4I_HDMI_DDC_INT_STATUS_ERROR_MASK) ||\n\t    !(reg & SUN4I_HDMI_DDC_INT_STATUS_TRANSFER_COMPLETE)) {\n\t\treturn -EIO;\n\t}\n\n\treturn 0;\n}\n\nstatic int sun4i_hdmi_i2c_xfer(struct i2c_adapter *adap,\n\t\t\t       struct i2c_msg *msgs, int num)\n{\n\tstruct sun4i_hdmi *hdmi = i2c_get_adapdata(adap);\n\tu32 reg;\n\tint err, i, ret = num;\n\n\tfor (i = 0; i < num; i++) {\n\t\tif (!msgs[i].len)\n\t\t\treturn -EINVAL;\n\t\tif (msgs[i].len > SUN4I_HDMI_DDC_BYTE_COUNT_MAX)\n\t\t\treturn -EINVAL;\n\t}\n\n\t \n\tclk_prepare_enable(hdmi->ddc_clk);\n\tclk_set_rate(hdmi->ddc_clk, 100000);\n\n\t \n\tregmap_field_write(hdmi->field_ddc_en, 1);\n\tregmap_field_write(hdmi->field_ddc_reset, 1);\n\tif (regmap_field_read_poll_timeout(hdmi->field_ddc_reset,\n\t\t\t\t\t   reg, !reg, 100, 2000)) {\n\t\tclk_disable_unprepare(hdmi->ddc_clk);\n\t\treturn -EIO;\n\t}\n\n\tregmap_field_write(hdmi->field_ddc_sck_en, 1);\n\tregmap_field_write(hdmi->field_ddc_sda_en, 1);\n\n\tfor (i = 0; i < num; i++) {\n\t\terr = xfer_msg(hdmi, &msgs[i]);\n\t\tif (err) {\n\t\t\tret = err;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tclk_disable_unprepare(hdmi->ddc_clk);\n\treturn ret;\n}\n\nstatic u32 sun4i_hdmi_i2c_func(struct i2c_adapter *adap)\n{\n\treturn I2C_FUNC_I2C | I2C_FUNC_SMBUS_EMUL;\n}\n\nstatic const struct i2c_algorithm sun4i_hdmi_i2c_algorithm = {\n\t.master_xfer\t= sun4i_hdmi_i2c_xfer,\n\t.functionality\t= sun4i_hdmi_i2c_func,\n};\n\nstatic int sun4i_hdmi_init_regmap_fields(struct sun4i_hdmi *hdmi)\n{\n\thdmi->field_ddc_en =\n\t\tdevm_regmap_field_alloc(hdmi->dev, hdmi->regmap,\n\t\t\t\t\thdmi->variant->field_ddc_en);\n\tif (IS_ERR(hdmi->field_ddc_en))\n\t\treturn PTR_ERR(hdmi->field_ddc_en);\n\n\thdmi->field_ddc_start =\n\t\tdevm_regmap_field_alloc(hdmi->dev, hdmi->regmap,\n\t\t\t\t\thdmi->variant->field_ddc_start);\n\tif (IS_ERR(hdmi->field_ddc_start))\n\t\treturn PTR_ERR(hdmi->field_ddc_start);\n\n\thdmi->field_ddc_reset =\n\t\tdevm_regmap_field_alloc(hdmi->dev, hdmi->regmap,\n\t\t\t\t\thdmi->variant->field_ddc_reset);\n\tif (IS_ERR(hdmi->field_ddc_reset))\n\t\treturn PTR_ERR(hdmi->field_ddc_reset);\n\n\thdmi->field_ddc_addr_reg =\n\t\tdevm_regmap_field_alloc(hdmi->dev, hdmi->regmap,\n\t\t\t\t\thdmi->variant->field_ddc_addr_reg);\n\tif (IS_ERR(hdmi->field_ddc_addr_reg))\n\t\treturn PTR_ERR(hdmi->field_ddc_addr_reg);\n\n\thdmi->field_ddc_slave_addr =\n\t\tdevm_regmap_field_alloc(hdmi->dev, hdmi->regmap,\n\t\t\t\t\thdmi->variant->field_ddc_slave_addr);\n\tif (IS_ERR(hdmi->field_ddc_slave_addr))\n\t\treturn PTR_ERR(hdmi->field_ddc_slave_addr);\n\n\thdmi->field_ddc_int_mask =\n\t\tdevm_regmap_field_alloc(hdmi->dev, hdmi->regmap,\n\t\t\t\t\thdmi->variant->field_ddc_int_mask);\n\tif (IS_ERR(hdmi->field_ddc_int_mask))\n\t\treturn PTR_ERR(hdmi->field_ddc_int_mask);\n\n\thdmi->field_ddc_int_status =\n\t\tdevm_regmap_field_alloc(hdmi->dev, hdmi->regmap,\n\t\t\t\t\thdmi->variant->field_ddc_int_status);\n\tif (IS_ERR(hdmi->field_ddc_int_status))\n\t\treturn PTR_ERR(hdmi->field_ddc_int_status);\n\n\thdmi->field_ddc_fifo_clear =\n\t\tdevm_regmap_field_alloc(hdmi->dev, hdmi->regmap,\n\t\t\t\t\thdmi->variant->field_ddc_fifo_clear);\n\tif (IS_ERR(hdmi->field_ddc_fifo_clear))\n\t\treturn PTR_ERR(hdmi->field_ddc_fifo_clear);\n\n\thdmi->field_ddc_fifo_rx_thres =\n\t\tdevm_regmap_field_alloc(hdmi->dev, hdmi->regmap,\n\t\t\t\t\thdmi->variant->field_ddc_fifo_rx_thres);\n\tif (IS_ERR(hdmi->field_ddc_fifo_rx_thres))\n\t\treturn PTR_ERR(hdmi->field_ddc_fifo_rx_thres);\n\n\thdmi->field_ddc_fifo_tx_thres =\n\t\tdevm_regmap_field_alloc(hdmi->dev, hdmi->regmap,\n\t\t\t\t\thdmi->variant->field_ddc_fifo_tx_thres);\n\tif (IS_ERR(hdmi->field_ddc_fifo_tx_thres))\n\t\treturn PTR_ERR(hdmi->field_ddc_fifo_tx_thres);\n\n\thdmi->field_ddc_byte_count =\n\t\tdevm_regmap_field_alloc(hdmi->dev, hdmi->regmap,\n\t\t\t\t\thdmi->variant->field_ddc_byte_count);\n\tif (IS_ERR(hdmi->field_ddc_byte_count))\n\t\treturn PTR_ERR(hdmi->field_ddc_byte_count);\n\n\thdmi->field_ddc_cmd =\n\t\tdevm_regmap_field_alloc(hdmi->dev, hdmi->regmap,\n\t\t\t\t\thdmi->variant->field_ddc_cmd);\n\tif (IS_ERR(hdmi->field_ddc_cmd))\n\t\treturn PTR_ERR(hdmi->field_ddc_cmd);\n\n\thdmi->field_ddc_sda_en =\n\t\tdevm_regmap_field_alloc(hdmi->dev, hdmi->regmap,\n\t\t\t\t\thdmi->variant->field_ddc_sda_en);\n\tif (IS_ERR(hdmi->field_ddc_sda_en))\n\t\treturn PTR_ERR(hdmi->field_ddc_sda_en);\n\n\thdmi->field_ddc_sck_en =\n\t\tdevm_regmap_field_alloc(hdmi->dev, hdmi->regmap,\n\t\t\t\t\thdmi->variant->field_ddc_sck_en);\n\tif (IS_ERR(hdmi->field_ddc_sck_en))\n\t\treturn PTR_ERR(hdmi->field_ddc_sck_en);\n\n\treturn 0;\n}\n\nint sun4i_hdmi_i2c_create(struct device *dev, struct sun4i_hdmi *hdmi)\n{\n\tstruct i2c_adapter *adap;\n\tint ret = 0;\n\n\tret = sun4i_ddc_create(hdmi, hdmi->ddc_parent_clk);\n\tif (ret)\n\t\treturn ret;\n\n\tret = sun4i_hdmi_init_regmap_fields(hdmi);\n\tif (ret)\n\t\treturn ret;\n\n\tadap = devm_kzalloc(dev, sizeof(*adap), GFP_KERNEL);\n\tif (!adap)\n\t\treturn -ENOMEM;\n\n\tadap->owner = THIS_MODULE;\n\tadap->class = I2C_CLASS_DDC;\n\tadap->algo = &sun4i_hdmi_i2c_algorithm;\n\tstrscpy(adap->name, \"sun4i_hdmi_i2c adapter\", sizeof(adap->name));\n\ti2c_set_adapdata(adap, hdmi);\n\n\tret = i2c_add_adapter(adap);\n\tif (ret)\n\t\treturn ret;\n\n\thdmi->i2c = adap;\n\n\treturn ret;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}