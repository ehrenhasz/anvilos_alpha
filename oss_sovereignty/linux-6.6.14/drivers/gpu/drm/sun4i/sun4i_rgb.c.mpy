{
  "module_name": "sun4i_rgb.c",
  "hash_id": "27e44971e5054788687375c9950914fa3fda12f2a23afe9d05243e8792a96285",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/sun4i/sun4i_rgb.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n\n#include <drm/drm_atomic_helper.h>\n#include <drm/drm_bridge.h>\n#include <drm/drm_of.h>\n#include <drm/drm_panel.h>\n#include <drm/drm_print.h>\n#include <drm/drm_probe_helper.h>\n#include <drm/drm_simple_kms_helper.h>\n\n#include \"sun4i_crtc.h\"\n#include \"sun4i_tcon.h\"\n#include \"sun4i_rgb.h\"\n\nstruct sun4i_rgb {\n\tstruct drm_connector\tconnector;\n\tstruct drm_encoder\tencoder;\n\n\tstruct sun4i_tcon\t*tcon;\n\tstruct drm_panel\t*panel;\n\tstruct drm_bridge\t*bridge;\n};\n\nstatic inline struct sun4i_rgb *\ndrm_connector_to_sun4i_rgb(struct drm_connector *connector)\n{\n\treturn container_of(connector, struct sun4i_rgb,\n\t\t\t    connector);\n}\n\nstatic inline struct sun4i_rgb *\ndrm_encoder_to_sun4i_rgb(struct drm_encoder *encoder)\n{\n\treturn container_of(encoder, struct sun4i_rgb,\n\t\t\t    encoder);\n}\n\nstatic int sun4i_rgb_get_modes(struct drm_connector *connector)\n{\n\tstruct sun4i_rgb *rgb =\n\t\tdrm_connector_to_sun4i_rgb(connector);\n\n\treturn drm_panel_get_modes(rgb->panel, connector);\n}\n\n \n#define SUN4I_RGB_DOTCLOCK_TOLERANCE_PER_MILLE\t5\n\nstatic enum drm_mode_status sun4i_rgb_mode_valid(struct drm_encoder *crtc,\n\t\t\t\t\t\t const struct drm_display_mode *mode)\n{\n\tstruct sun4i_rgb *rgb = drm_encoder_to_sun4i_rgb(crtc);\n\tstruct sun4i_tcon *tcon = rgb->tcon;\n\tu32 hsync = mode->hsync_end - mode->hsync_start;\n\tu32 vsync = mode->vsync_end - mode->vsync_start;\n\tunsigned long long rate = mode->clock * 1000;\n\tunsigned long long lowest, highest;\n\tunsigned long long rounded_rate;\n\n\tDRM_DEBUG_DRIVER(\"Validating modes...\\n\");\n\n\tif (hsync < 1)\n\t\treturn MODE_HSYNC_NARROW;\n\n\tif (hsync > 0x3ff)\n\t\treturn MODE_HSYNC_WIDE;\n\n\tif ((mode->hdisplay < 1) || (mode->htotal < 1))\n\t\treturn MODE_H_ILLEGAL;\n\n\tif ((mode->hdisplay > 0x7ff) || (mode->htotal > 0xfff))\n\t\treturn MODE_BAD_HVALUE;\n\n\tDRM_DEBUG_DRIVER(\"Horizontal parameters OK\\n\");\n\n\tif (vsync < 1)\n\t\treturn MODE_VSYNC_NARROW;\n\n\tif (vsync > 0x3ff)\n\t\treturn MODE_VSYNC_WIDE;\n\n\tif ((mode->vdisplay < 1) || (mode->vtotal < 1))\n\t\treturn MODE_V_ILLEGAL;\n\n\tif ((mode->vdisplay > 0x7ff) || (mode->vtotal > 0xfff))\n\t\treturn MODE_BAD_VVALUE;\n\n\tDRM_DEBUG_DRIVER(\"Vertical parameters OK\\n\");\n\n\t \n\tif (rgb->panel) {\n\t\tDRM_DEBUG_DRIVER(\"RGB panel used, skipping clock rate checks\");\n\t\tgoto out;\n\t}\n\n\t \n\tif (!rgb->bridge)\n\t\tgoto out;\n\n\ttcon->dclk_min_div = 6;\n\ttcon->dclk_max_div = 127;\n\trounded_rate = clk_round_rate(tcon->dclk, rate);\n\n\tlowest = rate * (1000 - SUN4I_RGB_DOTCLOCK_TOLERANCE_PER_MILLE);\n\tdo_div(lowest, 1000);\n\tif (rounded_rate < lowest)\n\t\treturn MODE_CLOCK_LOW;\n\n\thighest = rate * (1000 + SUN4I_RGB_DOTCLOCK_TOLERANCE_PER_MILLE);\n\tdo_div(highest, 1000);\n\tif (rounded_rate > highest)\n\t\treturn MODE_CLOCK_HIGH;\n\nout:\n\tDRM_DEBUG_DRIVER(\"Clock rate OK\\n\");\n\n\treturn MODE_OK;\n}\n\nstatic const struct drm_connector_helper_funcs sun4i_rgb_con_helper_funcs = {\n\t.get_modes\t= sun4i_rgb_get_modes,\n};\n\nstatic void\nsun4i_rgb_connector_destroy(struct drm_connector *connector)\n{\n\tdrm_connector_cleanup(connector);\n}\n\nstatic const struct drm_connector_funcs sun4i_rgb_con_funcs = {\n\t.fill_modes\t\t= drm_helper_probe_single_connector_modes,\n\t.destroy\t\t= sun4i_rgb_connector_destroy,\n\t.reset\t\t\t= drm_atomic_helper_connector_reset,\n\t.atomic_duplicate_state\t= drm_atomic_helper_connector_duplicate_state,\n\t.atomic_destroy_state\t= drm_atomic_helper_connector_destroy_state,\n};\n\nstatic void sun4i_rgb_encoder_enable(struct drm_encoder *encoder)\n{\n\tstruct sun4i_rgb *rgb = drm_encoder_to_sun4i_rgb(encoder);\n\n\tDRM_DEBUG_DRIVER(\"Enabling RGB output\\n\");\n\n\tif (rgb->panel) {\n\t\tdrm_panel_prepare(rgb->panel);\n\t\tdrm_panel_enable(rgb->panel);\n\t}\n}\n\nstatic void sun4i_rgb_encoder_disable(struct drm_encoder *encoder)\n{\n\tstruct sun4i_rgb *rgb = drm_encoder_to_sun4i_rgb(encoder);\n\n\tDRM_DEBUG_DRIVER(\"Disabling RGB output\\n\");\n\n\tif (rgb->panel) {\n\t\tdrm_panel_disable(rgb->panel);\n\t\tdrm_panel_unprepare(rgb->panel);\n\t}\n}\n\nstatic const struct drm_encoder_helper_funcs sun4i_rgb_enc_helper_funcs = {\n\t.disable\t= sun4i_rgb_encoder_disable,\n\t.enable\t\t= sun4i_rgb_encoder_enable,\n\t.mode_valid\t= sun4i_rgb_mode_valid,\n};\n\nint sun4i_rgb_init(struct drm_device *drm, struct sun4i_tcon *tcon)\n{\n\tstruct drm_encoder *encoder;\n\tstruct sun4i_rgb *rgb;\n\tint ret;\n\n\trgb = devm_kzalloc(drm->dev, sizeof(*rgb), GFP_KERNEL);\n\tif (!rgb)\n\t\treturn -ENOMEM;\n\trgb->tcon = tcon;\n\tencoder = &rgb->encoder;\n\n\tret = drm_of_find_panel_or_bridge(tcon->dev->of_node, 1, 0,\n\t\t\t\t\t  &rgb->panel, &rgb->bridge);\n\tif (ret) {\n\t\tdev_info(drm->dev, \"No panel or bridge found... RGB output disabled\\n\");\n\t\treturn 0;\n\t}\n\n\tdrm_encoder_helper_add(&rgb->encoder,\n\t\t\t       &sun4i_rgb_enc_helper_funcs);\n\tret = drm_simple_encoder_init(drm, &rgb->encoder,\n\t\t\t\t      DRM_MODE_ENCODER_NONE);\n\tif (ret) {\n\t\tdev_err(drm->dev, \"Couldn't initialise the rgb encoder\\n\");\n\t\tgoto err_out;\n\t}\n\n\t \n\trgb->encoder.possible_crtcs = drm_crtc_mask(&tcon->crtc->crtc);\n\n\tif (rgb->panel) {\n\t\tdrm_connector_helper_add(&rgb->connector,\n\t\t\t\t\t &sun4i_rgb_con_helper_funcs);\n\t\tret = drm_connector_init(drm, &rgb->connector,\n\t\t\t\t\t &sun4i_rgb_con_funcs,\n\t\t\t\t\t DRM_MODE_CONNECTOR_Unknown);\n\t\tif (ret) {\n\t\t\tdev_err(drm->dev, \"Couldn't initialise the rgb connector\\n\");\n\t\t\tgoto err_cleanup_connector;\n\t\t}\n\n\t\tdrm_connector_attach_encoder(&rgb->connector,\n\t\t\t\t\t\t  &rgb->encoder);\n\t}\n\n\tif (rgb->bridge) {\n\t\tret = drm_bridge_attach(encoder, rgb->bridge, NULL, 0);\n\t\tif (ret)\n\t\t\tgoto err_cleanup_connector;\n\t}\n\n\treturn 0;\n\nerr_cleanup_connector:\n\tdrm_encoder_cleanup(&rgb->encoder);\nerr_out:\n\treturn ret;\n}\nEXPORT_SYMBOL(sun4i_rgb_init);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}