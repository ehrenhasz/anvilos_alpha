{
  "module_name": "sun4i_hdmi_ddc_clk.c",
  "hash_id": "2a5fec4732379d536cae465e8f104104141733bcafa5579874f3a8bd234c67ad",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/sun4i/sun4i_hdmi_ddc_clk.c",
  "human_readable_source": "\n \n\n#include <linux/clk-provider.h>\n#include <linux/regmap.h>\n\n#include \"sun4i_hdmi.h\"\n\nstruct sun4i_ddc {\n\tstruct clk_hw\t\thw;\n\tstruct sun4i_hdmi\t*hdmi;\n\tstruct regmap_field\t*reg;\n\tu8\t\t\tpre_div;\n\tu8\t\t\tm_offset;\n};\n\nstatic inline struct sun4i_ddc *hw_to_ddc(struct clk_hw *hw)\n{\n\treturn container_of(hw, struct sun4i_ddc, hw);\n}\n\nstatic unsigned long sun4i_ddc_calc_divider(unsigned long rate,\n\t\t\t\t\t    unsigned long parent_rate,\n\t\t\t\t\t    const u8 pre_div,\n\t\t\t\t\t    const u8 m_offset,\n\t\t\t\t\t    u8 *m, u8 *n)\n{\n\tunsigned long best_rate = 0;\n\tu8 best_m = 0, best_n = 0, _m, _n;\n\n\tfor (_m = 0; _m < 16; _m++) {\n\t\tfor (_n = 0; _n < 8; _n++) {\n\t\t\tunsigned long tmp_rate;\n\n\t\t\ttmp_rate = (((parent_rate / pre_div) / 10) >> _n) /\n\t\t\t\t(_m + m_offset);\n\n\t\t\tif (tmp_rate > rate)\n\t\t\t\tcontinue;\n\n\t\t\tif (abs(rate - tmp_rate) < abs(rate - best_rate)) {\n\t\t\t\tbest_rate = tmp_rate;\n\t\t\t\tbest_m = _m;\n\t\t\t\tbest_n = _n;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (m && n) {\n\t\t*m = best_m;\n\t\t*n = best_n;\n\t}\n\n\treturn best_rate;\n}\n\nstatic long sun4i_ddc_round_rate(struct clk_hw *hw, unsigned long rate,\n\t\t\t\t unsigned long *prate)\n{\n\tstruct sun4i_ddc *ddc = hw_to_ddc(hw);\n\n\treturn sun4i_ddc_calc_divider(rate, *prate, ddc->pre_div,\n\t\t\t\t      ddc->m_offset, NULL, NULL);\n}\n\nstatic unsigned long sun4i_ddc_recalc_rate(struct clk_hw *hw,\n\t\t\t\t\t    unsigned long parent_rate)\n{\n\tstruct sun4i_ddc *ddc = hw_to_ddc(hw);\n\tunsigned int reg;\n\tu8 m, n;\n\n\tregmap_field_read(ddc->reg, &reg);\n\tm = (reg >> 3) & 0xf;\n\tn = reg & 0x7;\n\n\treturn (((parent_rate / ddc->pre_div) / 10) >> n) /\n\t       (m + ddc->m_offset);\n}\n\nstatic int sun4i_ddc_set_rate(struct clk_hw *hw, unsigned long rate,\n\t\t\t      unsigned long parent_rate)\n{\n\tstruct sun4i_ddc *ddc = hw_to_ddc(hw);\n\tu8 div_m, div_n;\n\n\tsun4i_ddc_calc_divider(rate, parent_rate, ddc->pre_div,\n\t\t\t       ddc->m_offset, &div_m, &div_n);\n\n\tregmap_field_write(ddc->reg,\n\t\t\t   SUN4I_HDMI_DDC_CLK_M(div_m) |\n\t\t\t   SUN4I_HDMI_DDC_CLK_N(div_n));\n\n\treturn 0;\n}\n\nstatic const struct clk_ops sun4i_ddc_ops = {\n\t.recalc_rate\t= sun4i_ddc_recalc_rate,\n\t.round_rate\t= sun4i_ddc_round_rate,\n\t.set_rate\t= sun4i_ddc_set_rate,\n};\n\nint sun4i_ddc_create(struct sun4i_hdmi *hdmi, struct clk *parent)\n{\n\tstruct clk_init_data init;\n\tstruct sun4i_ddc *ddc;\n\tconst char *parent_name;\n\n\tparent_name = __clk_get_name(parent);\n\tif (!parent_name)\n\t\treturn -ENODEV;\n\n\tddc = devm_kzalloc(hdmi->dev, sizeof(*ddc), GFP_KERNEL);\n\tif (!ddc)\n\t\treturn -ENOMEM;\n\n\tddc->reg = devm_regmap_field_alloc(hdmi->dev, hdmi->regmap,\n\t\t\t\t\t   hdmi->variant->ddc_clk_reg);\n\tif (IS_ERR(ddc->reg))\n\t\treturn PTR_ERR(ddc->reg);\n\n\tinit.name = \"hdmi-ddc\";\n\tinit.ops = &sun4i_ddc_ops;\n\tinit.parent_names = &parent_name;\n\tinit.num_parents = 1;\n\n\tddc->hdmi = hdmi;\n\tddc->hw.init = &init;\n\tddc->pre_div = hdmi->variant->ddc_clk_pre_divider;\n\tddc->m_offset = hdmi->variant->ddc_clk_m_offset;\n\n\thdmi->ddc_clk = devm_clk_register(hdmi->dev, &ddc->hw);\n\tif (IS_ERR(hdmi->ddc_clk))\n\t\treturn PTR_ERR(hdmi->ddc_clk);\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}