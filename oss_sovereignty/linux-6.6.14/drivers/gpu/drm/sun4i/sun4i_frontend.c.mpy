{
  "module_name": "sun4i_frontend.c",
  "hash_id": "beb8f3cf1a98260798a88fdc3caeadc7b6c2b67d76af830d60de2f05730cb7ae",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/sun4i/sun4i_frontend.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/component.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/pm_runtime.h>\n#include <linux/regmap.h>\n#include <linux/reset.h>\n\n#include <drm/drm_device.h>\n#include <drm/drm_fb_dma_helper.h>\n#include <drm/drm_fourcc.h>\n#include <drm/drm_framebuffer.h>\n#include <drm/drm_gem_dma_helper.h>\n#include <drm/drm_plane.h>\n\n#include \"sun4i_drv.h\"\n#include \"sun4i_frontend.h\"\n\nstatic const u32 sun4i_frontend_vert_coef[32] = {\n\t0x00004000, 0x000140ff, 0x00033ffe, 0x00043ffd,\n\t0x00063efc, 0xff083dfc, 0x000a3bfb, 0xff0d39fb,\n\t0xff0f37fb, 0xff1136fa, 0xfe1433fb, 0xfe1631fb,\n\t0xfd192ffb, 0xfd1c2cfb, 0xfd1f29fb, 0xfc2127fc,\n\t0xfc2424fc, 0xfc2721fc, 0xfb291ffd, 0xfb2c1cfd,\n\t0xfb2f19fd, 0xfb3116fe, 0xfb3314fe, 0xfa3611ff,\n\t0xfb370fff, 0xfb390dff, 0xfb3b0a00, 0xfc3d08ff,\n\t0xfc3e0600, 0xfd3f0400, 0xfe3f0300, 0xff400100,\n};\n\nstatic const u32 sun4i_frontend_horz_coef[64] = {\n\t0x40000000, 0x00000000, 0x40fe0000, 0x0000ff03,\n\t0x3ffd0000, 0x0000ff05, 0x3ffc0000, 0x0000ff06,\n\t0x3efb0000, 0x0000ff08, 0x3dfb0000, 0x0000ff09,\n\t0x3bfa0000, 0x0000fe0d, 0x39fa0000, 0x0000fe0f,\n\t0x38fa0000, 0x0000fe10, 0x36fa0000, 0x0000fe12,\n\t0x33fa0000, 0x0000fd16, 0x31fa0000, 0x0000fd18,\n\t0x2ffa0000, 0x0000fd1a, 0x2cfa0000, 0x0000fc1e,\n\t0x29fa0000, 0x0000fc21, 0x27fb0000, 0x0000fb23,\n\t0x24fb0000, 0x0000fb26, 0x21fb0000, 0x0000fb29,\n\t0x1ffc0000, 0x0000fa2b, 0x1cfc0000, 0x0000fa2e,\n\t0x19fd0000, 0x0000fa30, 0x16fd0000, 0x0000fa33,\n\t0x14fd0000, 0x0000fa35, 0x11fe0000, 0x0000fa37,\n\t0x0ffe0000, 0x0000fa39, 0x0dfe0000, 0x0000fa3b,\n\t0x0afe0000, 0x0000fa3e, 0x08ff0000, 0x0000fb3e,\n\t0x06ff0000, 0x0000fb40, 0x05ff0000, 0x0000fc40,\n\t0x03ff0000, 0x0000fd41, 0x01ff0000, 0x0000fe42,\n};\n\n \nconst u32 sunxi_bt601_yuv2rgb_coef[12] = {\n\t0x000004a7, 0x00001e6f, 0x00001cbf, 0x00000877,\n\t0x000004a7, 0x00000000, 0x00000662, 0x00003211,\n\t0x000004a7, 0x00000812, 0x00000000, 0x00002eb1,\n};\nEXPORT_SYMBOL(sunxi_bt601_yuv2rgb_coef);\n\nstatic void sun4i_frontend_scaler_init(struct sun4i_frontend *frontend)\n{\n\tint i;\n\n\tif (frontend->data->has_coef_access_ctrl)\n\t\tregmap_write_bits(frontend->regs, SUN4I_FRONTEND_FRM_CTRL_REG,\n\t\t\t\t  SUN4I_FRONTEND_FRM_CTRL_COEF_ACCESS_CTRL,\n\t\t\t\t  SUN4I_FRONTEND_FRM_CTRL_COEF_ACCESS_CTRL);\n\n\tfor (i = 0; i < 32; i++) {\n\t\tregmap_write(frontend->regs, SUN4I_FRONTEND_CH0_HORZCOEF0_REG(i),\n\t\t\t     sun4i_frontend_horz_coef[2 * i]);\n\t\tregmap_write(frontend->regs, SUN4I_FRONTEND_CH1_HORZCOEF0_REG(i),\n\t\t\t     sun4i_frontend_horz_coef[2 * i]);\n\t\tregmap_write(frontend->regs, SUN4I_FRONTEND_CH0_HORZCOEF1_REG(i),\n\t\t\t     sun4i_frontend_horz_coef[2 * i + 1]);\n\t\tregmap_write(frontend->regs, SUN4I_FRONTEND_CH1_HORZCOEF1_REG(i),\n\t\t\t     sun4i_frontend_horz_coef[2 * i + 1]);\n\t\tregmap_write(frontend->regs, SUN4I_FRONTEND_CH0_VERTCOEF_REG(i),\n\t\t\t     sun4i_frontend_vert_coef[i]);\n\t\tregmap_write(frontend->regs, SUN4I_FRONTEND_CH1_VERTCOEF_REG(i),\n\t\t\t     sun4i_frontend_vert_coef[i]);\n\t}\n\n\tif (frontend->data->has_coef_rdy)\n\t\tregmap_write_bits(frontend->regs,\n\t\t\t\t  SUN4I_FRONTEND_FRM_CTRL_REG,\n\t\t\t\t  SUN4I_FRONTEND_FRM_CTRL_COEF_RDY,\n\t\t\t\t  SUN4I_FRONTEND_FRM_CTRL_COEF_RDY);\n}\n\nint sun4i_frontend_init(struct sun4i_frontend *frontend)\n{\n\treturn pm_runtime_get_sync(frontend->dev);\n}\nEXPORT_SYMBOL(sun4i_frontend_init);\n\nvoid sun4i_frontend_exit(struct sun4i_frontend *frontend)\n{\n\tpm_runtime_put(frontend->dev);\n}\nEXPORT_SYMBOL(sun4i_frontend_exit);\n\nstatic bool sun4i_frontend_format_chroma_requires_swap(uint32_t fmt)\n{\n\tswitch (fmt) {\n\tcase DRM_FORMAT_YVU411:\n\tcase DRM_FORMAT_YVU420:\n\tcase DRM_FORMAT_YVU422:\n\tcase DRM_FORMAT_YVU444:\n\t\treturn true;\n\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nstatic bool sun4i_frontend_format_supports_tiling(uint32_t fmt)\n{\n\tswitch (fmt) {\n\tcase DRM_FORMAT_NV12:\n\tcase DRM_FORMAT_NV16:\n\tcase DRM_FORMAT_NV21:\n\tcase DRM_FORMAT_NV61:\n\tcase DRM_FORMAT_YUV411:\n\tcase DRM_FORMAT_YUV420:\n\tcase DRM_FORMAT_YUV422:\n\tcase DRM_FORMAT_YVU420:\n\tcase DRM_FORMAT_YVU422:\n\tcase DRM_FORMAT_YVU411:\n\t\treturn true;\n\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nvoid sun4i_frontend_update_buffer(struct sun4i_frontend *frontend,\n\t\t\t\t  struct drm_plane *plane)\n{\n\tstruct drm_plane_state *state = plane->state;\n\tstruct drm_framebuffer *fb = state->fb;\n\tunsigned int strides[3] = {};\n\n\tdma_addr_t dma_addr;\n\tbool swap;\n\n\tif (fb->modifier == DRM_FORMAT_MOD_ALLWINNER_TILED) {\n\t\tunsigned int width = state->src_w >> 16;\n\t\tunsigned int offset;\n\n\t\tstrides[0] = SUN4I_FRONTEND_LINESTRD_TILED(fb->pitches[0]);\n\n\t\t \n\t\toffset = (width - 1) & (32 - 1);\n\n\t\tregmap_write(frontend->regs, SUN4I_FRONTEND_TB_OFF0_REG,\n\t\t\t     SUN4I_FRONTEND_TB_OFF_X1(offset));\n\n\t\tif (fb->format->num_planes > 1) {\n\t\t\tstrides[1] =\n\t\t\t\tSUN4I_FRONTEND_LINESTRD_TILED(fb->pitches[1]);\n\n\t\t\tregmap_write(frontend->regs, SUN4I_FRONTEND_TB_OFF1_REG,\n\t\t\t\t     SUN4I_FRONTEND_TB_OFF_X1(offset));\n\t\t}\n\n\t\tif (fb->format->num_planes > 2) {\n\t\t\tstrides[2] =\n\t\t\t\tSUN4I_FRONTEND_LINESTRD_TILED(fb->pitches[2]);\n\n\t\t\tregmap_write(frontend->regs, SUN4I_FRONTEND_TB_OFF2_REG,\n\t\t\t\t     SUN4I_FRONTEND_TB_OFF_X1(offset));\n\t\t}\n\t} else {\n\t\tstrides[0] = fb->pitches[0];\n\n\t\tif (fb->format->num_planes > 1)\n\t\t\tstrides[1] = fb->pitches[1];\n\n\t\tif (fb->format->num_planes > 2)\n\t\t\tstrides[2] = fb->pitches[2];\n\t}\n\n\t \n\tDRM_DEBUG_DRIVER(\"Frontend stride: %d bytes\\n\", fb->pitches[0]);\n\tregmap_write(frontend->regs, SUN4I_FRONTEND_LINESTRD0_REG,\n\t\t     strides[0]);\n\n\tif (fb->format->num_planes > 1)\n\t\tregmap_write(frontend->regs, SUN4I_FRONTEND_LINESTRD1_REG,\n\t\t\t     strides[1]);\n\n\tif (fb->format->num_planes > 2)\n\t\tregmap_write(frontend->regs, SUN4I_FRONTEND_LINESTRD2_REG,\n\t\t\t     strides[2]);\n\n\t \n\tswap = sun4i_frontend_format_chroma_requires_swap(fb->format->format);\n\n\t \n\tdma_addr = drm_fb_dma_get_gem_addr(fb, state, 0);\n\tDRM_DEBUG_DRIVER(\"Setting buffer #0 address to %pad\\n\", &dma_addr);\n\tregmap_write(frontend->regs, SUN4I_FRONTEND_BUF_ADDR0_REG, dma_addr);\n\n\tif (fb->format->num_planes > 1) {\n\t\tdma_addr = drm_fb_dma_get_gem_addr(fb, state, swap ? 2 : 1);\n\t\tDRM_DEBUG_DRIVER(\"Setting buffer #1 address to %pad\\n\",\n\t\t\t\t &dma_addr);\n\t\tregmap_write(frontend->regs, SUN4I_FRONTEND_BUF_ADDR1_REG,\n\t\t\t     dma_addr);\n\t}\n\n\tif (fb->format->num_planes > 2) {\n\t\tdma_addr = drm_fb_dma_get_gem_addr(fb, state, swap ? 1 : 2);\n\t\tDRM_DEBUG_DRIVER(\"Setting buffer #2 address to %pad\\n\",\n\t\t\t\t &dma_addr);\n\t\tregmap_write(frontend->regs, SUN4I_FRONTEND_BUF_ADDR2_REG,\n\t\t\t     dma_addr);\n\t}\n}\nEXPORT_SYMBOL(sun4i_frontend_update_buffer);\n\nstatic int\nsun4i_frontend_drm_format_to_input_fmt(const struct drm_format_info *format,\n\t\t\t\t       u32 *val)\n{\n\tif (!format->is_yuv)\n\t\t*val = SUN4I_FRONTEND_INPUT_FMT_DATA_FMT_RGB;\n\telse if (drm_format_info_is_yuv_sampling_411(format))\n\t\t*val = SUN4I_FRONTEND_INPUT_FMT_DATA_FMT_YUV411;\n\telse if (drm_format_info_is_yuv_sampling_420(format))\n\t\t*val = SUN4I_FRONTEND_INPUT_FMT_DATA_FMT_YUV420;\n\telse if (drm_format_info_is_yuv_sampling_422(format))\n\t\t*val = SUN4I_FRONTEND_INPUT_FMT_DATA_FMT_YUV422;\n\telse if (drm_format_info_is_yuv_sampling_444(format))\n\t\t*val = SUN4I_FRONTEND_INPUT_FMT_DATA_FMT_YUV444;\n\telse\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nstatic int\nsun4i_frontend_drm_format_to_input_mode(const struct drm_format_info *format,\n\t\t\t\t\tuint64_t modifier, u32 *val)\n{\n\tbool tiled = (modifier == DRM_FORMAT_MOD_ALLWINNER_TILED);\n\n\tswitch (format->num_planes) {\n\tcase 1:\n\t\t*val = SUN4I_FRONTEND_INPUT_FMT_DATA_MOD_PACKED;\n\t\treturn 0;\n\n\tcase 2:\n\t\t*val = tiled ? SUN4I_FRONTEND_INPUT_FMT_DATA_MOD_MB32_SEMIPLANAR\n\t\t\t     : SUN4I_FRONTEND_INPUT_FMT_DATA_MOD_SEMIPLANAR;\n\t\treturn 0;\n\n\tcase 3:\n\t\t*val = tiled ? SUN4I_FRONTEND_INPUT_FMT_DATA_MOD_MB32_PLANAR\n\t\t\t     : SUN4I_FRONTEND_INPUT_FMT_DATA_MOD_PLANAR;\n\t\treturn 0;\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic int\nsun4i_frontend_drm_format_to_input_sequence(const struct drm_format_info *format,\n\t\t\t\t\t    u32 *val)\n{\n\t \n\tif (drm_format_info_is_yuv_planar(format)) {\n\t\t*val = 0;\n\t\treturn 0;\n\t}\n\n\tswitch (format->format) {\n\tcase DRM_FORMAT_BGRX8888:\n\t\t*val = SUN4I_FRONTEND_INPUT_FMT_DATA_PS_BGRX;\n\t\treturn 0;\n\n\tcase DRM_FORMAT_NV12:\n\t\t*val = SUN4I_FRONTEND_INPUT_FMT_DATA_PS_UV;\n\t\treturn 0;\n\n\tcase DRM_FORMAT_NV16:\n\t\t*val = SUN4I_FRONTEND_INPUT_FMT_DATA_PS_UV;\n\t\treturn 0;\n\n\tcase DRM_FORMAT_NV21:\n\t\t*val = SUN4I_FRONTEND_INPUT_FMT_DATA_PS_VU;\n\t\treturn 0;\n\n\tcase DRM_FORMAT_NV61:\n\t\t*val = SUN4I_FRONTEND_INPUT_FMT_DATA_PS_VU;\n\t\treturn 0;\n\n\tcase DRM_FORMAT_UYVY:\n\t\t*val = SUN4I_FRONTEND_INPUT_FMT_DATA_PS_UYVY;\n\t\treturn 0;\n\n\tcase DRM_FORMAT_VYUY:\n\t\t*val = SUN4I_FRONTEND_INPUT_FMT_DATA_PS_VYUY;\n\t\treturn 0;\n\n\tcase DRM_FORMAT_XRGB8888:\n\t\t*val = SUN4I_FRONTEND_INPUT_FMT_DATA_PS_XRGB;\n\t\treturn 0;\n\n\tcase DRM_FORMAT_YUYV:\n\t\t*val = SUN4I_FRONTEND_INPUT_FMT_DATA_PS_YUYV;\n\t\treturn 0;\n\n\tcase DRM_FORMAT_YVYU:\n\t\t*val = SUN4I_FRONTEND_INPUT_FMT_DATA_PS_YVYU;\n\t\treturn 0;\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic int sun4i_frontend_drm_format_to_output_fmt(uint32_t fmt, u32 *val)\n{\n\tswitch (fmt) {\n\tcase DRM_FORMAT_BGRX8888:\n\t\t*val = SUN4I_FRONTEND_OUTPUT_FMT_DATA_FMT_BGRX8888;\n\t\treturn 0;\n\n\tcase DRM_FORMAT_XRGB8888:\n\t\t*val = SUN4I_FRONTEND_OUTPUT_FMT_DATA_FMT_XRGB8888;\n\t\treturn 0;\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic const uint32_t sun4i_frontend_formats[] = {\n\tDRM_FORMAT_BGRX8888,\n\tDRM_FORMAT_NV12,\n\tDRM_FORMAT_NV16,\n\tDRM_FORMAT_NV21,\n\tDRM_FORMAT_NV61,\n\tDRM_FORMAT_UYVY,\n\tDRM_FORMAT_VYUY,\n\tDRM_FORMAT_XRGB8888,\n\tDRM_FORMAT_YUV411,\n\tDRM_FORMAT_YUV420,\n\tDRM_FORMAT_YUV422,\n\tDRM_FORMAT_YUV444,\n\tDRM_FORMAT_YUYV,\n\tDRM_FORMAT_YVU411,\n\tDRM_FORMAT_YVU420,\n\tDRM_FORMAT_YVU422,\n\tDRM_FORMAT_YVU444,\n\tDRM_FORMAT_YVYU,\n};\n\nbool sun4i_frontend_format_is_supported(uint32_t fmt, uint64_t modifier)\n{\n\tunsigned int i;\n\n\tif (modifier == DRM_FORMAT_MOD_ALLWINNER_TILED)\n\t\treturn sun4i_frontend_format_supports_tiling(fmt);\n\telse if (modifier != DRM_FORMAT_MOD_LINEAR)\n\t\treturn false;\n\n\tfor (i = 0; i < ARRAY_SIZE(sun4i_frontend_formats); i++)\n\t\tif (sun4i_frontend_formats[i] == fmt)\n\t\t\treturn true;\n\n\treturn false;\n}\nEXPORT_SYMBOL(sun4i_frontend_format_is_supported);\n\nint sun4i_frontend_update_formats(struct sun4i_frontend *frontend,\n\t\t\t\t  struct drm_plane *plane, uint32_t out_fmt)\n{\n\tstruct drm_plane_state *state = plane->state;\n\tstruct drm_framebuffer *fb = state->fb;\n\tconst struct drm_format_info *format = fb->format;\n\tuint64_t modifier = fb->modifier;\n\tunsigned int ch1_phase_idx;\n\tu32 out_fmt_val;\n\tu32 in_fmt_val, in_mod_val, in_ps_val;\n\tunsigned int i;\n\tu32 bypass;\n\tint ret;\n\n\tret = sun4i_frontend_drm_format_to_input_fmt(format, &in_fmt_val);\n\tif (ret) {\n\t\tDRM_DEBUG_DRIVER(\"Invalid input format\\n\");\n\t\treturn ret;\n\t}\n\n\tret = sun4i_frontend_drm_format_to_input_mode(format, modifier,\n\t\t\t\t\t\t      &in_mod_val);\n\tif (ret) {\n\t\tDRM_DEBUG_DRIVER(\"Invalid input mode\\n\");\n\t\treturn ret;\n\t}\n\n\tret = sun4i_frontend_drm_format_to_input_sequence(format, &in_ps_val);\n\tif (ret) {\n\t\tDRM_DEBUG_DRIVER(\"Invalid pixel sequence\\n\");\n\t\treturn ret;\n\t}\n\n\tret = sun4i_frontend_drm_format_to_output_fmt(out_fmt, &out_fmt_val);\n\tif (ret) {\n\t\tDRM_DEBUG_DRIVER(\"Invalid output format\\n\");\n\t\treturn ret;\n\t}\n\n\t \n\tch1_phase_idx = (format->num_planes > 1) ? 1 : 0;\n\tregmap_write(frontend->regs, SUN4I_FRONTEND_CH0_HORZPHASE_REG,\n\t\t     frontend->data->ch_phase[0]);\n\tregmap_write(frontend->regs, SUN4I_FRONTEND_CH1_HORZPHASE_REG,\n\t\t     frontend->data->ch_phase[ch1_phase_idx]);\n\tregmap_write(frontend->regs, SUN4I_FRONTEND_CH0_VERTPHASE0_REG,\n\t\t     frontend->data->ch_phase[0]);\n\tregmap_write(frontend->regs, SUN4I_FRONTEND_CH1_VERTPHASE0_REG,\n\t\t     frontend->data->ch_phase[ch1_phase_idx]);\n\tregmap_write(frontend->regs, SUN4I_FRONTEND_CH0_VERTPHASE1_REG,\n\t\t     frontend->data->ch_phase[0]);\n\tregmap_write(frontend->regs, SUN4I_FRONTEND_CH1_VERTPHASE1_REG,\n\t\t     frontend->data->ch_phase[ch1_phase_idx]);\n\n\t \n\tif (format->is_yuv) {\n\t\t \n\t\tbypass = 0;\n\n\t\tfor (i = 0; i < ARRAY_SIZE(sunxi_bt601_yuv2rgb_coef); i++)\n\t\t\tregmap_write(frontend->regs,\n\t\t\t\t     SUN4I_FRONTEND_CSC_COEF_REG(i),\n\t\t\t\t     sunxi_bt601_yuv2rgb_coef[i]);\n\t} else {\n\t\tbypass = SUN4I_FRONTEND_BYPASS_CSC_EN;\n\t}\n\n\tregmap_update_bits(frontend->regs, SUN4I_FRONTEND_BYPASS_REG,\n\t\t\t   SUN4I_FRONTEND_BYPASS_CSC_EN, bypass);\n\n\tregmap_write(frontend->regs, SUN4I_FRONTEND_INPUT_FMT_REG,\n\t\t     in_mod_val | in_fmt_val | in_ps_val);\n\n\t \n\tregmap_write(frontend->regs, SUN4I_FRONTEND_OUTPUT_FMT_REG,\n\t\t     out_fmt_val);\n\n\treturn 0;\n}\nEXPORT_SYMBOL(sun4i_frontend_update_formats);\n\nvoid sun4i_frontend_update_coord(struct sun4i_frontend *frontend,\n\t\t\t\t struct drm_plane *plane)\n{\n\tstruct drm_plane_state *state = plane->state;\n\tstruct drm_framebuffer *fb = state->fb;\n\tuint32_t luma_width, luma_height;\n\tuint32_t chroma_width, chroma_height;\n\n\t \n\tDRM_DEBUG_DRIVER(\"Frontend size W: %u H: %u\\n\",\n\t\t\t state->crtc_w, state->crtc_h);\n\n\tluma_width = state->src_w >> 16;\n\tluma_height = state->src_h >> 16;\n\n\tchroma_width = DIV_ROUND_UP(luma_width, fb->format->hsub);\n\tchroma_height = DIV_ROUND_UP(luma_height, fb->format->vsub);\n\n\tregmap_write(frontend->regs, SUN4I_FRONTEND_CH0_INSIZE_REG,\n\t\t     SUN4I_FRONTEND_INSIZE(luma_height, luma_width));\n\tregmap_write(frontend->regs, SUN4I_FRONTEND_CH1_INSIZE_REG,\n\t\t     SUN4I_FRONTEND_INSIZE(chroma_height, chroma_width));\n\n\tregmap_write(frontend->regs, SUN4I_FRONTEND_CH0_OUTSIZE_REG,\n\t\t     SUN4I_FRONTEND_OUTSIZE(state->crtc_h, state->crtc_w));\n\tregmap_write(frontend->regs, SUN4I_FRONTEND_CH1_OUTSIZE_REG,\n\t\t     SUN4I_FRONTEND_OUTSIZE(state->crtc_h, state->crtc_w));\n\n\tregmap_write(frontend->regs, SUN4I_FRONTEND_CH0_HORZFACT_REG,\n\t\t     (luma_width << 16) / state->crtc_w);\n\tregmap_write(frontend->regs, SUN4I_FRONTEND_CH1_HORZFACT_REG,\n\t\t     (chroma_width << 16) / state->crtc_w);\n\n\tregmap_write(frontend->regs, SUN4I_FRONTEND_CH0_VERTFACT_REG,\n\t\t     (luma_height << 16) / state->crtc_h);\n\tregmap_write(frontend->regs, SUN4I_FRONTEND_CH1_VERTFACT_REG,\n\t\t     (chroma_height << 16) / state->crtc_h);\n\n\tregmap_write_bits(frontend->regs, SUN4I_FRONTEND_FRM_CTRL_REG,\n\t\t\t  SUN4I_FRONTEND_FRM_CTRL_REG_RDY,\n\t\t\t  SUN4I_FRONTEND_FRM_CTRL_REG_RDY);\n}\nEXPORT_SYMBOL(sun4i_frontend_update_coord);\n\nint sun4i_frontend_enable(struct sun4i_frontend *frontend)\n{\n\tregmap_write_bits(frontend->regs, SUN4I_FRONTEND_FRM_CTRL_REG,\n\t\t\t  SUN4I_FRONTEND_FRM_CTRL_FRM_START,\n\t\t\t  SUN4I_FRONTEND_FRM_CTRL_FRM_START);\n\n\treturn 0;\n}\nEXPORT_SYMBOL(sun4i_frontend_enable);\n\nstatic const struct regmap_config sun4i_frontend_regmap_config = {\n\t.reg_bits\t= 32,\n\t.val_bits\t= 32,\n\t.reg_stride\t= 4,\n\t.max_register\t= 0x0a14,\n};\n\nstatic int sun4i_frontend_bind(struct device *dev, struct device *master,\n\t\t\t void *data)\n{\n\tstruct platform_device *pdev = to_platform_device(dev);\n\tstruct sun4i_frontend *frontend;\n\tstruct drm_device *drm = data;\n\tstruct sun4i_drv *drv = drm->dev_private;\n\tvoid __iomem *regs;\n\n\tfrontend = devm_kzalloc(dev, sizeof(*frontend), GFP_KERNEL);\n\tif (!frontend)\n\t\treturn -ENOMEM;\n\n\tdev_set_drvdata(dev, frontend);\n\tfrontend->dev = dev;\n\tfrontend->node = dev->of_node;\n\n\tfrontend->data = of_device_get_match_data(dev);\n\tif (!frontend->data)\n\t\treturn -ENODEV;\n\n\tregs = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(regs))\n\t\treturn PTR_ERR(regs);\n\n\tfrontend->regs = devm_regmap_init_mmio(dev, regs,\n\t\t\t\t\t       &sun4i_frontend_regmap_config);\n\tif (IS_ERR(frontend->regs)) {\n\t\tdev_err(dev, \"Couldn't create the frontend regmap\\n\");\n\t\treturn PTR_ERR(frontend->regs);\n\t}\n\n\tfrontend->reset = devm_reset_control_get(dev, NULL);\n\tif (IS_ERR(frontend->reset)) {\n\t\tdev_err(dev, \"Couldn't get our reset line\\n\");\n\t\treturn PTR_ERR(frontend->reset);\n\t}\n\n\tfrontend->bus_clk = devm_clk_get(dev, \"ahb\");\n\tif (IS_ERR(frontend->bus_clk)) {\n\t\tdev_err(dev, \"Couldn't get our bus clock\\n\");\n\t\treturn PTR_ERR(frontend->bus_clk);\n\t}\n\n\tfrontend->mod_clk = devm_clk_get(dev, \"mod\");\n\tif (IS_ERR(frontend->mod_clk)) {\n\t\tdev_err(dev, \"Couldn't get our mod clock\\n\");\n\t\treturn PTR_ERR(frontend->mod_clk);\n\t}\n\n\tfrontend->ram_clk = devm_clk_get(dev, \"ram\");\n\tif (IS_ERR(frontend->ram_clk)) {\n\t\tdev_err(dev, \"Couldn't get our ram clock\\n\");\n\t\treturn PTR_ERR(frontend->ram_clk);\n\t}\n\n\tlist_add_tail(&frontend->list, &drv->frontend_list);\n\tpm_runtime_enable(dev);\n\n\treturn 0;\n}\n\nstatic void sun4i_frontend_unbind(struct device *dev, struct device *master,\n\t\t\t    void *data)\n{\n\tstruct sun4i_frontend *frontend = dev_get_drvdata(dev);\n\n\tlist_del(&frontend->list);\n\tpm_runtime_force_suspend(dev);\n}\n\nstatic const struct component_ops sun4i_frontend_ops = {\n\t.bind\t= sun4i_frontend_bind,\n\t.unbind\t= sun4i_frontend_unbind,\n};\n\nstatic int sun4i_frontend_probe(struct platform_device *pdev)\n{\n\treturn component_add(&pdev->dev, &sun4i_frontend_ops);\n}\n\nstatic void sun4i_frontend_remove(struct platform_device *pdev)\n{\n\tcomponent_del(&pdev->dev, &sun4i_frontend_ops);\n}\n\nstatic int sun4i_frontend_runtime_resume(struct device *dev)\n{\n\tstruct sun4i_frontend *frontend = dev_get_drvdata(dev);\n\tint ret;\n\n\tclk_set_rate(frontend->mod_clk, 300000000);\n\n\tclk_prepare_enable(frontend->bus_clk);\n\tclk_prepare_enable(frontend->mod_clk);\n\tclk_prepare_enable(frontend->ram_clk);\n\n\tret = reset_control_reset(frontend->reset);\n\tif (ret) {\n\t\tdev_err(dev, \"Couldn't reset our device\\n\");\n\t\treturn ret;\n\t}\n\n\tregmap_update_bits(frontend->regs, SUN4I_FRONTEND_EN_REG,\n\t\t\t   SUN4I_FRONTEND_EN_EN,\n\t\t\t   SUN4I_FRONTEND_EN_EN);\n\n\tsun4i_frontend_scaler_init(frontend);\n\n\treturn 0;\n}\n\nstatic int sun4i_frontend_runtime_suspend(struct device *dev)\n{\n\tstruct sun4i_frontend *frontend = dev_get_drvdata(dev);\n\n\tclk_disable_unprepare(frontend->ram_clk);\n\tclk_disable_unprepare(frontend->mod_clk);\n\tclk_disable_unprepare(frontend->bus_clk);\n\n\treset_control_assert(frontend->reset);\n\n\treturn 0;\n}\n\nstatic const struct dev_pm_ops sun4i_frontend_pm_ops = {\n\t.runtime_resume\t\t= sun4i_frontend_runtime_resume,\n\t.runtime_suspend\t= sun4i_frontend_runtime_suspend,\n};\n\nstatic const struct sun4i_frontend_data sun4i_a10_frontend = {\n\t.ch_phase\t\t= { 0x000, 0xfc000 },\n\t.has_coef_rdy\t\t= true,\n};\n\nstatic const struct sun4i_frontend_data sun8i_a33_frontend = {\n\t.ch_phase\t\t= { 0x400, 0xfc400 },\n\t.has_coef_access_ctrl\t= true,\n};\n\nconst struct of_device_id sun4i_frontend_of_table[] = {\n\t{\n\t\t.compatible = \"allwinner,sun4i-a10-display-frontend\",\n\t\t.data = &sun4i_a10_frontend\n\t},\n\t{\n\t\t.compatible = \"allwinner,sun7i-a20-display-frontend\",\n\t\t.data = &sun4i_a10_frontend\n\t},\n\t{\n\t\t.compatible = \"allwinner,sun8i-a23-display-frontend\",\n\t\t.data = &sun8i_a33_frontend\n\t},\n\t{\n\t\t.compatible = \"allwinner,sun8i-a33-display-frontend\",\n\t\t.data = &sun8i_a33_frontend\n\t},\n\t{ }\n};\nEXPORT_SYMBOL(sun4i_frontend_of_table);\nMODULE_DEVICE_TABLE(of, sun4i_frontend_of_table);\n\nstatic struct platform_driver sun4i_frontend_driver = {\n\t.probe\t\t= sun4i_frontend_probe,\n\t.remove_new\t= sun4i_frontend_remove,\n\t.driver\t\t= {\n\t\t.name\t\t= \"sun4i-frontend\",\n\t\t.of_match_table\t= sun4i_frontend_of_table,\n\t\t.pm\t\t= &sun4i_frontend_pm_ops,\n\t},\n};\nmodule_platform_driver(sun4i_frontend_driver);\n\nMODULE_AUTHOR(\"Maxime Ripard <maxime.ripard@free-electrons.com>\");\nMODULE_DESCRIPTION(\"Allwinner A10 Display Engine Frontend Driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}