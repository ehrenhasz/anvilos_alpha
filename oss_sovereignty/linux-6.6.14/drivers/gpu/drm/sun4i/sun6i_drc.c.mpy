{
  "module_name": "sun6i_drc.c",
  "hash_id": "97b4a09b70e0b2bc8532919630fa6e58cc873151c070513686d0e8d6ee36822f",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/sun4i/sun6i_drc.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/component.h>\n#include <linux/module.h>\n#include <linux/mod_devicetable.h>\n#include <linux/platform_device.h>\n#include <linux/regmap.h>\n#include <linux/reset.h>\n\nstruct sun6i_drc {\n\tstruct clk\t\t*bus_clk;\n\tstruct clk\t\t*mod_clk;\n\tstruct reset_control\t*reset;\n};\n\nstatic int sun6i_drc_bind(struct device *dev, struct device *master,\n\t\t\t void *data)\n{\n\tstruct sun6i_drc *drc;\n\tint ret;\n\n\tdrc = devm_kzalloc(dev, sizeof(*drc), GFP_KERNEL);\n\tif (!drc)\n\t\treturn -ENOMEM;\n\tdev_set_drvdata(dev, drc);\n\n\tdrc->reset = devm_reset_control_get(dev, NULL);\n\tif (IS_ERR(drc->reset)) {\n\t\tdev_err(dev, \"Couldn't get our reset line\\n\");\n\t\treturn PTR_ERR(drc->reset);\n\t}\n\n\tret = reset_control_deassert(drc->reset);\n\tif (ret) {\n\t\tdev_err(dev, \"Couldn't deassert our reset line\\n\");\n\t\treturn ret;\n\t}\n\n\tdrc->bus_clk = devm_clk_get(dev, \"ahb\");\n\tif (IS_ERR(drc->bus_clk)) {\n\t\tdev_err(dev, \"Couldn't get our bus clock\\n\");\n\t\tret = PTR_ERR(drc->bus_clk);\n\t\tgoto err_assert_reset;\n\t}\n\tclk_prepare_enable(drc->bus_clk);\n\n\tdrc->mod_clk = devm_clk_get(dev, \"mod\");\n\tif (IS_ERR(drc->mod_clk)) {\n\t\tdev_err(dev, \"Couldn't get our mod clock\\n\");\n\t\tret = PTR_ERR(drc->mod_clk);\n\t\tgoto err_disable_bus_clk;\n\t}\n\n\tret = clk_set_rate_exclusive(drc->mod_clk, 300000000);\n\tif (ret) {\n\t\tdev_err(dev, \"Couldn't set the module clock frequency\\n\");\n\t\tgoto err_disable_bus_clk;\n\t}\n\n\tclk_prepare_enable(drc->mod_clk);\n\n\treturn 0;\n\nerr_disable_bus_clk:\n\tclk_disable_unprepare(drc->bus_clk);\nerr_assert_reset:\n\treset_control_assert(drc->reset);\n\treturn ret;\n}\n\nstatic void sun6i_drc_unbind(struct device *dev, struct device *master,\n\t\t\t    void *data)\n{\n\tstruct sun6i_drc *drc = dev_get_drvdata(dev);\n\n\tclk_rate_exclusive_put(drc->mod_clk);\n\tclk_disable_unprepare(drc->mod_clk);\n\tclk_disable_unprepare(drc->bus_clk);\n\treset_control_assert(drc->reset);\n}\n\nstatic const struct component_ops sun6i_drc_ops = {\n\t.bind\t= sun6i_drc_bind,\n\t.unbind\t= sun6i_drc_unbind,\n};\n\nstatic int sun6i_drc_probe(struct platform_device *pdev)\n{\n\treturn component_add(&pdev->dev, &sun6i_drc_ops);\n}\n\nstatic void sun6i_drc_remove(struct platform_device *pdev)\n{\n\tcomponent_del(&pdev->dev, &sun6i_drc_ops);\n}\n\nstatic const struct of_device_id sun6i_drc_of_table[] = {\n\t{ .compatible = \"allwinner,sun6i-a31-drc\" },\n\t{ .compatible = \"allwinner,sun6i-a31s-drc\" },\n\t{ .compatible = \"allwinner,sun8i-a23-drc\" },\n\t{ .compatible = \"allwinner,sun8i-a33-drc\" },\n\t{ .compatible = \"allwinner,sun9i-a80-drc\" },\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, sun6i_drc_of_table);\n\nstatic struct platform_driver sun6i_drc_platform_driver = {\n\t.probe\t\t= sun6i_drc_probe,\n\t.remove_new\t= sun6i_drc_remove,\n\t.driver\t\t= {\n\t\t.name\t\t= \"sun6i-drc\",\n\t\t.of_match_table\t= sun6i_drc_of_table,\n\t},\n};\nmodule_platform_driver(sun6i_drc_platform_driver);\n\nMODULE_AUTHOR(\"Maxime Ripard <maxime.ripard@free-electrons.com>\");\nMODULE_DESCRIPTION(\"Allwinner A31 Dynamic Range Control (DRC) Driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}