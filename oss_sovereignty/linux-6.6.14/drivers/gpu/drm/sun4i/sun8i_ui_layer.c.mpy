{
  "module_name": "sun8i_ui_layer.c",
  "hash_id": "88a16c40a40c1f2a77cd13d3ac72701dcab687e8a4bee03501297ececfb0af1c",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/sun4i/sun8i_ui_layer.c",
  "human_readable_source": "\n \n\n#include <drm/drm_atomic.h>\n#include <drm/drm_atomic_helper.h>\n#include <drm/drm_blend.h>\n#include <drm/drm_crtc.h>\n#include <drm/drm_fb_dma_helper.h>\n#include <drm/drm_fourcc.h>\n#include <drm/drm_framebuffer.h>\n#include <drm/drm_gem_atomic_helper.h>\n#include <drm/drm_gem_dma_helper.h>\n#include <drm/drm_probe_helper.h>\n\n#include \"sun8i_mixer.h\"\n#include \"sun8i_ui_layer.h\"\n#include \"sun8i_ui_scaler.h\"\n\nstatic void sun8i_ui_layer_enable(struct sun8i_mixer *mixer, int channel,\n\t\t\t\t  int overlay, bool enable, unsigned int zpos,\n\t\t\t\t  unsigned int old_zpos)\n{\n\tu32 val, bld_base, ch_base;\n\n\tbld_base = sun8i_blender_base(mixer);\n\tch_base = sun8i_channel_base(mixer, channel);\n\n\tDRM_DEBUG_DRIVER(\"%sabling channel %d overlay %d\\n\",\n\t\t\t enable ? \"En\" : \"Dis\", channel, overlay);\n\n\tif (enable)\n\t\tval = SUN8I_MIXER_CHAN_UI_LAYER_ATTR_EN;\n\telse\n\t\tval = 0;\n\n\tregmap_update_bits(mixer->engine.regs,\n\t\t\t   SUN8I_MIXER_CHAN_UI_LAYER_ATTR(ch_base, overlay),\n\t\t\t   SUN8I_MIXER_CHAN_UI_LAYER_ATTR_EN, val);\n\n\tif (!enable || zpos != old_zpos) {\n\t\tregmap_update_bits(mixer->engine.regs,\n\t\t\t\t   SUN8I_MIXER_BLEND_PIPE_CTL(bld_base),\n\t\t\t\t   SUN8I_MIXER_BLEND_PIPE_CTL_EN(old_zpos),\n\t\t\t\t   0);\n\n\t\tregmap_update_bits(mixer->engine.regs,\n\t\t\t\t   SUN8I_MIXER_BLEND_ROUTE(bld_base),\n\t\t\t\t   SUN8I_MIXER_BLEND_ROUTE_PIPE_MSK(old_zpos),\n\t\t\t\t   0);\n\t}\n\n\tif (enable) {\n\t\tval = SUN8I_MIXER_BLEND_PIPE_CTL_EN(zpos);\n\n\t\tregmap_update_bits(mixer->engine.regs,\n\t\t\t\t   SUN8I_MIXER_BLEND_PIPE_CTL(bld_base),\n\t\t\t\t   val, val);\n\n\t\tval = channel << SUN8I_MIXER_BLEND_ROUTE_PIPE_SHIFT(zpos);\n\n\t\tregmap_update_bits(mixer->engine.regs,\n\t\t\t\t   SUN8I_MIXER_BLEND_ROUTE(bld_base),\n\t\t\t\t   SUN8I_MIXER_BLEND_ROUTE_PIPE_MSK(zpos),\n\t\t\t\t   val);\n\t}\n}\n\nstatic void sun8i_ui_layer_update_alpha(struct sun8i_mixer *mixer, int channel,\n\t\t\t\t\tint overlay, struct drm_plane *plane)\n{\n\tu32 mask, val, ch_base;\n\n\tch_base = sun8i_channel_base(mixer, channel);\n\n\tmask = SUN8I_MIXER_CHAN_UI_LAYER_ATTR_ALPHA_MODE_MASK |\n\t\tSUN8I_MIXER_CHAN_UI_LAYER_ATTR_ALPHA_MASK;\n\n\tval = SUN8I_MIXER_CHAN_UI_LAYER_ATTR_ALPHA(plane->state->alpha >> 8);\n\n\tval |= (plane->state->alpha == DRM_BLEND_ALPHA_OPAQUE) ?\n\t\tSUN8I_MIXER_CHAN_UI_LAYER_ATTR_ALPHA_MODE_PIXEL :\n\t\tSUN8I_MIXER_CHAN_UI_LAYER_ATTR_ALPHA_MODE_COMBINED;\n\n\tregmap_update_bits(mixer->engine.regs,\n\t\t\t   SUN8I_MIXER_CHAN_UI_LAYER_ATTR(ch_base, overlay),\n\t\t\t   mask, val);\n}\n\nstatic int sun8i_ui_layer_update_coord(struct sun8i_mixer *mixer, int channel,\n\t\t\t\t       int overlay, struct drm_plane *plane,\n\t\t\t\t       unsigned int zpos)\n{\n\tstruct drm_plane_state *state = plane->state;\n\tu32 src_w, src_h, dst_w, dst_h;\n\tu32 bld_base, ch_base;\n\tu32 outsize, insize;\n\tu32 hphase, vphase;\n\n\tDRM_DEBUG_DRIVER(\"Updating UI channel %d overlay %d\\n\",\n\t\t\t channel, overlay);\n\n\tbld_base = sun8i_blender_base(mixer);\n\tch_base = sun8i_channel_base(mixer, channel);\n\n\tsrc_w = drm_rect_width(&state->src) >> 16;\n\tsrc_h = drm_rect_height(&state->src) >> 16;\n\tdst_w = drm_rect_width(&state->dst);\n\tdst_h = drm_rect_height(&state->dst);\n\n\thphase = state->src.x1 & 0xffff;\n\tvphase = state->src.y1 & 0xffff;\n\n\tinsize = SUN8I_MIXER_SIZE(src_w, src_h);\n\toutsize = SUN8I_MIXER_SIZE(dst_w, dst_h);\n\n\t \n\tDRM_DEBUG_DRIVER(\"Layer source offset X: %d Y: %d\\n\",\n\t\t\t state->src.x1 >> 16, state->src.y1 >> 16);\n\tDRM_DEBUG_DRIVER(\"Layer source size W: %d H: %d\\n\", src_w, src_h);\n\tregmap_write(mixer->engine.regs,\n\t\t     SUN8I_MIXER_CHAN_UI_LAYER_SIZE(ch_base, overlay),\n\t\t     insize);\n\tregmap_write(mixer->engine.regs,\n\t\t     SUN8I_MIXER_CHAN_UI_OVL_SIZE(ch_base),\n\t\t     insize);\n\n\tif (insize != outsize || hphase || vphase) {\n\t\tu32 hscale, vscale;\n\n\t\tDRM_DEBUG_DRIVER(\"HW scaling is enabled\\n\");\n\n\t\thscale = state->src_w / state->crtc_w;\n\t\tvscale = state->src_h / state->crtc_h;\n\n\t\tsun8i_ui_scaler_setup(mixer, channel, src_w, src_h, dst_w,\n\t\t\t\t      dst_h, hscale, vscale, hphase, vphase);\n\t\tsun8i_ui_scaler_enable(mixer, channel, true);\n\t} else {\n\t\tDRM_DEBUG_DRIVER(\"HW scaling is not needed\\n\");\n\t\tsun8i_ui_scaler_enable(mixer, channel, false);\n\t}\n\n\t \n\tDRM_DEBUG_DRIVER(\"Layer destination coordinates X: %d Y: %d\\n\",\n\t\t\t state->dst.x1, state->dst.y1);\n\tDRM_DEBUG_DRIVER(\"Layer destination size W: %d H: %d\\n\", dst_w, dst_h);\n\tregmap_write(mixer->engine.regs,\n\t\t     SUN8I_MIXER_BLEND_ATTR_COORD(bld_base, zpos),\n\t\t     SUN8I_MIXER_COORD(state->dst.x1, state->dst.y1));\n\tregmap_write(mixer->engine.regs,\n\t\t     SUN8I_MIXER_BLEND_ATTR_INSIZE(bld_base, zpos),\n\t\t     outsize);\n\n\treturn 0;\n}\n\nstatic int sun8i_ui_layer_update_formats(struct sun8i_mixer *mixer, int channel,\n\t\t\t\t\t int overlay, struct drm_plane *plane)\n{\n\tstruct drm_plane_state *state = plane->state;\n\tconst struct drm_format_info *fmt;\n\tu32 val, ch_base, hw_fmt;\n\tint ret;\n\n\tch_base = sun8i_channel_base(mixer, channel);\n\n\tfmt = state->fb->format;\n\tret = sun8i_mixer_drm_format_to_hw(fmt->format, &hw_fmt);\n\tif (ret || fmt->is_yuv) {\n\t\tDRM_DEBUG_DRIVER(\"Invalid format\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tval = hw_fmt << SUN8I_MIXER_CHAN_UI_LAYER_ATTR_FBFMT_OFFSET;\n\tregmap_update_bits(mixer->engine.regs,\n\t\t\t   SUN8I_MIXER_CHAN_UI_LAYER_ATTR(ch_base, overlay),\n\t\t\t   SUN8I_MIXER_CHAN_UI_LAYER_ATTR_FBFMT_MASK, val);\n\n\treturn 0;\n}\n\nstatic int sun8i_ui_layer_update_buffer(struct sun8i_mixer *mixer, int channel,\n\t\t\t\t\tint overlay, struct drm_plane *plane)\n{\n\tstruct drm_plane_state *state = plane->state;\n\tstruct drm_framebuffer *fb = state->fb;\n\tstruct drm_gem_dma_object *gem;\n\tdma_addr_t dma_addr;\n\tu32 ch_base;\n\tint bpp;\n\n\tch_base = sun8i_channel_base(mixer, channel);\n\n\t \n\tgem = drm_fb_dma_get_gem_obj(fb, 0);\n\n\tDRM_DEBUG_DRIVER(\"Using GEM @ %pad\\n\", &gem->dma_addr);\n\n\t \n\tbpp = fb->format->cpp[0];\n\tdma_addr = gem->dma_addr + fb->offsets[0];\n\n\t \n\tdma_addr += (state->src.x1 >> 16) * bpp;\n\tdma_addr += (state->src.y1 >> 16) * fb->pitches[0];\n\n\t \n\tDRM_DEBUG_DRIVER(\"Layer line width: %d bytes\\n\", fb->pitches[0]);\n\tregmap_write(mixer->engine.regs,\n\t\t     SUN8I_MIXER_CHAN_UI_LAYER_PITCH(ch_base, overlay),\n\t\t     fb->pitches[0]);\n\n\tDRM_DEBUG_DRIVER(\"Setting buffer address to %pad\\n\", &dma_addr);\n\n\tregmap_write(mixer->engine.regs,\n\t\t     SUN8I_MIXER_CHAN_UI_LAYER_TOP_LADDR(ch_base, overlay),\n\t\t     lower_32_bits(dma_addr));\n\n\treturn 0;\n}\n\nstatic int sun8i_ui_layer_atomic_check(struct drm_plane *plane,\n\t\t\t\t       struct drm_atomic_state *state)\n{\n\tstruct drm_plane_state *new_plane_state = drm_atomic_get_new_plane_state(state,\n\t\t\t\t\t\t\t\t\t\t plane);\n\tstruct sun8i_ui_layer *layer = plane_to_sun8i_ui_layer(plane);\n\tstruct drm_crtc *crtc = new_plane_state->crtc;\n\tstruct drm_crtc_state *crtc_state;\n\tint min_scale, max_scale;\n\n\tif (!crtc)\n\t\treturn 0;\n\n\tcrtc_state = drm_atomic_get_existing_crtc_state(state,\n\t\t\t\t\t\t\tcrtc);\n\tif (WARN_ON(!crtc_state))\n\t\treturn -EINVAL;\n\n\tmin_scale = DRM_PLANE_NO_SCALING;\n\tmax_scale = DRM_PLANE_NO_SCALING;\n\n\tif (layer->mixer->cfg->scaler_mask & BIT(layer->channel)) {\n\t\tmin_scale = SUN8I_UI_SCALER_SCALE_MIN;\n\t\tmax_scale = SUN8I_UI_SCALER_SCALE_MAX;\n\t}\n\n\treturn drm_atomic_helper_check_plane_state(new_plane_state,\n\t\t\t\t\t\t   crtc_state,\n\t\t\t\t\t\t   min_scale, max_scale,\n\t\t\t\t\t\t   true, true);\n}\n\nstatic void sun8i_ui_layer_atomic_disable(struct drm_plane *plane,\n\t\t\t\t\t  struct drm_atomic_state *state)\n{\n\tstruct drm_plane_state *old_state = drm_atomic_get_old_plane_state(state,\n\t\t\t\t\t\t\t\t\t   plane);\n\tstruct sun8i_ui_layer *layer = plane_to_sun8i_ui_layer(plane);\n\tunsigned int old_zpos = old_state->normalized_zpos;\n\tstruct sun8i_mixer *mixer = layer->mixer;\n\n\tsun8i_ui_layer_enable(mixer, layer->channel, layer->overlay, false, 0,\n\t\t\t      old_zpos);\n}\n\nstatic void sun8i_ui_layer_atomic_update(struct drm_plane *plane,\n\t\t\t\t\t struct drm_atomic_state *state)\n{\n\tstruct drm_plane_state *old_state = drm_atomic_get_old_plane_state(state,\n\t\t\t\t\t\t\t\t\t   plane);\n\tstruct drm_plane_state *new_state = drm_atomic_get_new_plane_state(state,\n\t\t\t\t\t\t\t\t\t   plane);\n\tstruct sun8i_ui_layer *layer = plane_to_sun8i_ui_layer(plane);\n\tunsigned int zpos = new_state->normalized_zpos;\n\tunsigned int old_zpos = old_state->normalized_zpos;\n\tstruct sun8i_mixer *mixer = layer->mixer;\n\n\tif (!new_state->visible) {\n\t\tsun8i_ui_layer_enable(mixer, layer->channel,\n\t\t\t\t      layer->overlay, false, 0, old_zpos);\n\t\treturn;\n\t}\n\n\tsun8i_ui_layer_update_coord(mixer, layer->channel,\n\t\t\t\t    layer->overlay, plane, zpos);\n\tsun8i_ui_layer_update_alpha(mixer, layer->channel,\n\t\t\t\t    layer->overlay, plane);\n\tsun8i_ui_layer_update_formats(mixer, layer->channel,\n\t\t\t\t      layer->overlay, plane);\n\tsun8i_ui_layer_update_buffer(mixer, layer->channel,\n\t\t\t\t     layer->overlay, plane);\n\tsun8i_ui_layer_enable(mixer, layer->channel, layer->overlay,\n\t\t\t      true, zpos, old_zpos);\n}\n\nstatic const struct drm_plane_helper_funcs sun8i_ui_layer_helper_funcs = {\n\t.atomic_check\t= sun8i_ui_layer_atomic_check,\n\t.atomic_disable\t= sun8i_ui_layer_atomic_disable,\n\t.atomic_update\t= sun8i_ui_layer_atomic_update,\n};\n\nstatic const struct drm_plane_funcs sun8i_ui_layer_funcs = {\n\t.atomic_destroy_state\t= drm_atomic_helper_plane_destroy_state,\n\t.atomic_duplicate_state\t= drm_atomic_helper_plane_duplicate_state,\n\t.destroy\t\t= drm_plane_cleanup,\n\t.disable_plane\t\t= drm_atomic_helper_disable_plane,\n\t.reset\t\t\t= drm_atomic_helper_plane_reset,\n\t.update_plane\t\t= drm_atomic_helper_update_plane,\n};\n\nstatic const u32 sun8i_ui_layer_formats[] = {\n\tDRM_FORMAT_ABGR1555,\n\tDRM_FORMAT_ABGR4444,\n\tDRM_FORMAT_ABGR8888,\n\tDRM_FORMAT_ARGB1555,\n\tDRM_FORMAT_ARGB4444,\n\tDRM_FORMAT_ARGB8888,\n\tDRM_FORMAT_BGR565,\n\tDRM_FORMAT_BGR888,\n\tDRM_FORMAT_BGRA5551,\n\tDRM_FORMAT_BGRA4444,\n\tDRM_FORMAT_BGRA8888,\n\tDRM_FORMAT_BGRX8888,\n\tDRM_FORMAT_RGB565,\n\tDRM_FORMAT_RGB888,\n\tDRM_FORMAT_RGBA4444,\n\tDRM_FORMAT_RGBA5551,\n\tDRM_FORMAT_RGBA8888,\n\tDRM_FORMAT_RGBX8888,\n\tDRM_FORMAT_XBGR8888,\n\tDRM_FORMAT_XRGB8888,\n};\n\nstatic const uint64_t sun8i_layer_modifiers[] = {\n\tDRM_FORMAT_MOD_LINEAR,\n\tDRM_FORMAT_MOD_INVALID\n};\n\nstruct sun8i_ui_layer *sun8i_ui_layer_init_one(struct drm_device *drm,\n\t\t\t\t\t       struct sun8i_mixer *mixer,\n\t\t\t\t\t       int index)\n{\n\tenum drm_plane_type type = DRM_PLANE_TYPE_OVERLAY;\n\tint channel = mixer->cfg->vi_num + index;\n\tstruct sun8i_ui_layer *layer;\n\tunsigned int plane_cnt;\n\tint ret;\n\n\tlayer = devm_kzalloc(drm->dev, sizeof(*layer), GFP_KERNEL);\n\tif (!layer)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tif (index == 0)\n\t\ttype = DRM_PLANE_TYPE_PRIMARY;\n\n\t \n\tret = drm_universal_plane_init(drm, &layer->plane, 0,\n\t\t\t\t       &sun8i_ui_layer_funcs,\n\t\t\t\t       sun8i_ui_layer_formats,\n\t\t\t\t       ARRAY_SIZE(sun8i_ui_layer_formats),\n\t\t\t\t       sun8i_layer_modifiers, type, NULL);\n\tif (ret) {\n\t\tdev_err(drm->dev, \"Couldn't initialize layer\\n\");\n\t\treturn ERR_PTR(ret);\n\t}\n\n\tplane_cnt = mixer->cfg->ui_num + mixer->cfg->vi_num;\n\n\tret = drm_plane_create_alpha_property(&layer->plane);\n\tif (ret) {\n\t\tdev_err(drm->dev, \"Couldn't add alpha property\\n\");\n\t\treturn ERR_PTR(ret);\n\t}\n\n\tret = drm_plane_create_zpos_property(&layer->plane, channel,\n\t\t\t\t\t     0, plane_cnt - 1);\n\tif (ret) {\n\t\tdev_err(drm->dev, \"Couldn't add zpos property\\n\");\n\t\treturn ERR_PTR(ret);\n\t}\n\n\tdrm_plane_helper_add(&layer->plane, &sun8i_ui_layer_helper_funcs);\n\tlayer->mixer = mixer;\n\tlayer->channel = channel;\n\tlayer->overlay = 0;\n\n\treturn layer;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}