{
  "module_name": "sun4i_crtc.c",
  "hash_id": "d48c37ae716e1eb5cbad074b84d6d3910520a42323225b0fb3f907b122da3da7",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/sun4i/sun4i_crtc.c",
  "human_readable_source": "\n \n\n#include <linux/clk-provider.h>\n#include <linux/ioport.h>\n#include <linux/of_address.h>\n#include <linux/of_graph.h>\n#include <linux/of_irq.h>\n#include <linux/regmap.h>\n\n#include <video/videomode.h>\n\n#include <drm/drm_atomic.h>\n#include <drm/drm_atomic_helper.h>\n#include <drm/drm_crtc.h>\n#include <drm/drm_modes.h>\n#include <drm/drm_print.h>\n#include <drm/drm_probe_helper.h>\n#include <drm/drm_vblank.h>\n\n#include \"sun4i_backend.h\"\n#include \"sun4i_crtc.h\"\n#include \"sun4i_drv.h\"\n#include \"sunxi_engine.h\"\n#include \"sun4i_tcon.h\"\n\n \nstatic struct drm_encoder *sun4i_crtc_get_encoder(struct drm_crtc *crtc)\n{\n\tstruct drm_encoder *encoder;\n\n\tdrm_for_each_encoder(encoder, crtc->dev)\n\t\tif (encoder->crtc == crtc)\n\t\t\treturn encoder;\n\n\treturn NULL;\n}\n\nstatic int sun4i_crtc_atomic_check(struct drm_crtc *crtc,\n\t\t\t\t    struct drm_atomic_state *state)\n{\n\tstruct drm_crtc_state *crtc_state = drm_atomic_get_new_crtc_state(state,\n\t\t\t\t\t\t\t\t\t  crtc);\n\tstruct sun4i_crtc *scrtc = drm_crtc_to_sun4i_crtc(crtc);\n\tstruct sunxi_engine *engine = scrtc->engine;\n\tint ret = 0;\n\n\tif (engine && engine->ops && engine->ops->atomic_check)\n\t\tret = engine->ops->atomic_check(engine, crtc_state);\n\n\treturn ret;\n}\n\nstatic void sun4i_crtc_atomic_begin(struct drm_crtc *crtc,\n\t\t\t\t    struct drm_atomic_state *state)\n{\n\tstruct drm_crtc_state *old_state = drm_atomic_get_old_crtc_state(state,\n\t\t\t\t\t\t\t\t\t crtc);\n\tstruct sun4i_crtc *scrtc = drm_crtc_to_sun4i_crtc(crtc);\n\tstruct drm_device *dev = crtc->dev;\n\tstruct sunxi_engine *engine = scrtc->engine;\n\tunsigned long flags;\n\n\tif (crtc->state->event) {\n\t\tWARN_ON(drm_crtc_vblank_get(crtc) != 0);\n\n\t\tspin_lock_irqsave(&dev->event_lock, flags);\n\t\tscrtc->event = crtc->state->event;\n\t\tspin_unlock_irqrestore(&dev->event_lock, flags);\n\t\tcrtc->state->event = NULL;\n\t}\n\n\tif (engine->ops->atomic_begin)\n\t\tengine->ops->atomic_begin(engine, old_state);\n}\n\nstatic void sun4i_crtc_atomic_flush(struct drm_crtc *crtc,\n\t\t\t\t    struct drm_atomic_state *state)\n{\n\tstruct sun4i_crtc *scrtc = drm_crtc_to_sun4i_crtc(crtc);\n\tstruct drm_pending_vblank_event *event = crtc->state->event;\n\n\tDRM_DEBUG_DRIVER(\"Committing plane changes\\n\");\n\n\tsunxi_engine_commit(scrtc->engine);\n\n\tif (event) {\n\t\tcrtc->state->event = NULL;\n\n\t\tspin_lock_irq(&crtc->dev->event_lock);\n\t\tif (drm_crtc_vblank_get(crtc) == 0)\n\t\t\tdrm_crtc_arm_vblank_event(crtc, event);\n\t\telse\n\t\t\tdrm_crtc_send_vblank_event(crtc, event);\n\t\tspin_unlock_irq(&crtc->dev->event_lock);\n\t}\n}\n\nstatic void sun4i_crtc_atomic_disable(struct drm_crtc *crtc,\n\t\t\t\t      struct drm_atomic_state *state)\n{\n\tstruct drm_encoder *encoder = sun4i_crtc_get_encoder(crtc);\n\tstruct sun4i_crtc *scrtc = drm_crtc_to_sun4i_crtc(crtc);\n\n\tDRM_DEBUG_DRIVER(\"Disabling the CRTC\\n\");\n\n\tdrm_crtc_vblank_off(crtc);\n\n\tsun4i_tcon_set_status(scrtc->tcon, encoder, false);\n\n\tif (crtc->state->event && !crtc->state->active) {\n\t\tspin_lock_irq(&crtc->dev->event_lock);\n\t\tdrm_crtc_send_vblank_event(crtc, crtc->state->event);\n\t\tspin_unlock_irq(&crtc->dev->event_lock);\n\n\t\tcrtc->state->event = NULL;\n\t}\n}\n\nstatic void sun4i_crtc_atomic_enable(struct drm_crtc *crtc,\n\t\t\t\t     struct drm_atomic_state *state)\n{\n\tstruct drm_encoder *encoder = sun4i_crtc_get_encoder(crtc);\n\tstruct sun4i_crtc *scrtc = drm_crtc_to_sun4i_crtc(crtc);\n\n\tDRM_DEBUG_DRIVER(\"Enabling the CRTC\\n\");\n\n\tsun4i_tcon_set_status(scrtc->tcon, encoder, true);\n\n\tdrm_crtc_vblank_on(crtc);\n}\n\nstatic void sun4i_crtc_mode_set_nofb(struct drm_crtc *crtc)\n{\n\tstruct drm_display_mode *mode = &crtc->state->adjusted_mode;\n\tstruct drm_encoder *encoder = sun4i_crtc_get_encoder(crtc);\n\tstruct sun4i_crtc *scrtc = drm_crtc_to_sun4i_crtc(crtc);\n\n\tsun4i_tcon_mode_set(scrtc->tcon, encoder, mode);\n\tsunxi_engine_mode_set(scrtc->engine, mode);\n}\n\nstatic const struct drm_crtc_helper_funcs sun4i_crtc_helper_funcs = {\n\t.atomic_check\t= sun4i_crtc_atomic_check,\n\t.atomic_begin\t= sun4i_crtc_atomic_begin,\n\t.atomic_flush\t= sun4i_crtc_atomic_flush,\n\t.atomic_enable\t= sun4i_crtc_atomic_enable,\n\t.atomic_disable\t= sun4i_crtc_atomic_disable,\n\t.mode_set_nofb\t= sun4i_crtc_mode_set_nofb,\n};\n\nstatic int sun4i_crtc_enable_vblank(struct drm_crtc *crtc)\n{\n\tstruct sun4i_crtc *scrtc = drm_crtc_to_sun4i_crtc(crtc);\n\n\tDRM_DEBUG_DRIVER(\"Enabling VBLANK on crtc %p\\n\", crtc);\n\n\tsun4i_tcon_enable_vblank(scrtc->tcon, true);\n\n\treturn 0;\n}\n\nstatic void sun4i_crtc_disable_vblank(struct drm_crtc *crtc)\n{\n\tstruct sun4i_crtc *scrtc = drm_crtc_to_sun4i_crtc(crtc);\n\n\tDRM_DEBUG_DRIVER(\"Disabling VBLANK on crtc %p\\n\", crtc);\n\n\tsun4i_tcon_enable_vblank(scrtc->tcon, false);\n}\n\nstatic const struct drm_crtc_funcs sun4i_crtc_funcs = {\n\t.atomic_destroy_state\t= drm_atomic_helper_crtc_destroy_state,\n\t.atomic_duplicate_state\t= drm_atomic_helper_crtc_duplicate_state,\n\t.destroy\t\t= drm_crtc_cleanup,\n\t.page_flip\t\t= drm_atomic_helper_page_flip,\n\t.reset\t\t\t= drm_atomic_helper_crtc_reset,\n\t.set_config\t\t= drm_atomic_helper_set_config,\n\t.enable_vblank\t\t= sun4i_crtc_enable_vblank,\n\t.disable_vblank\t\t= sun4i_crtc_disable_vblank,\n};\n\nstruct sun4i_crtc *sun4i_crtc_init(struct drm_device *drm,\n\t\t\t\t   struct sunxi_engine *engine,\n\t\t\t\t   struct sun4i_tcon *tcon)\n{\n\tstruct sun4i_crtc *scrtc;\n\tstruct drm_plane **planes;\n\tstruct drm_plane *primary = NULL, *cursor = NULL;\n\tint ret, i;\n\n\tscrtc = devm_kzalloc(drm->dev, sizeof(*scrtc), GFP_KERNEL);\n\tif (!scrtc)\n\t\treturn ERR_PTR(-ENOMEM);\n\tscrtc->engine = engine;\n\tscrtc->tcon = tcon;\n\n\t \n\tplanes = sunxi_engine_layers_init(drm, engine);\n\tif (IS_ERR(planes)) {\n\t\tdev_err(drm->dev, \"Couldn't create the planes\\n\");\n\t\treturn NULL;\n\t}\n\n\t \n\tfor (i = 0; planes[i]; i++) {\n\t\tstruct drm_plane *plane = planes[i];\n\n\t\tswitch (plane->type) {\n\t\tcase DRM_PLANE_TYPE_PRIMARY:\n\t\t\tprimary = plane;\n\t\t\tbreak;\n\t\tcase DRM_PLANE_TYPE_CURSOR:\n\t\t\tcursor = plane;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tret = drm_crtc_init_with_planes(drm, &scrtc->crtc,\n\t\t\t\t\tprimary,\n\t\t\t\t\tcursor,\n\t\t\t\t\t&sun4i_crtc_funcs,\n\t\t\t\t\tNULL);\n\tif (ret) {\n\t\tdev_err(drm->dev, \"Couldn't init DRM CRTC\\n\");\n\t\treturn ERR_PTR(ret);\n\t}\n\n\tdrm_crtc_helper_add(&scrtc->crtc, &sun4i_crtc_helper_funcs);\n\n\t \n\tscrtc->crtc.port = of_graph_get_port_by_id(scrtc->tcon->dev->of_node,\n\t\t\t\t\t\t   1);\n\n\t \n\tfor (i = 0; planes[i]; i++) {\n\t\tuint32_t possible_crtcs = drm_crtc_mask(&scrtc->crtc);\n\t\tstruct drm_plane *plane = planes[i];\n\n\t\tif (plane->type == DRM_PLANE_TYPE_OVERLAY)\n\t\t\tplane->possible_crtcs = possible_crtcs;\n\t}\n\n\treturn scrtc;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}