{
  "module_name": "sun8i_vi_layer.c",
  "hash_id": "44e5d2bc57f142ef04bdca95106aa54367dc61d8cfddeb25f87f39174bf35315",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/sun4i/sun8i_vi_layer.c",
  "human_readable_source": "\n \n\n#include <drm/drm_atomic.h>\n#include <drm/drm_atomic_helper.h>\n#include <drm/drm_blend.h>\n#include <drm/drm_crtc.h>\n#include <drm/drm_fb_dma_helper.h>\n#include <drm/drm_framebuffer.h>\n#include <drm/drm_gem_atomic_helper.h>\n#include <drm/drm_gem_dma_helper.h>\n#include <drm/drm_probe_helper.h>\n\n#include \"sun8i_csc.h\"\n#include \"sun8i_mixer.h\"\n#include \"sun8i_vi_layer.h\"\n#include \"sun8i_vi_scaler.h\"\n\nstatic void sun8i_vi_layer_enable(struct sun8i_mixer *mixer, int channel,\n\t\t\t\t  int overlay, bool enable, unsigned int zpos,\n\t\t\t\t  unsigned int old_zpos)\n{\n\tu32 val, bld_base, ch_base;\n\n\tbld_base = sun8i_blender_base(mixer);\n\tch_base = sun8i_channel_base(mixer, channel);\n\n\tDRM_DEBUG_DRIVER(\"%sabling VI channel %d overlay %d\\n\",\n\t\t\t enable ? \"En\" : \"Dis\", channel, overlay);\n\n\tif (enable)\n\t\tval = SUN8I_MIXER_CHAN_VI_LAYER_ATTR_EN;\n\telse\n\t\tval = 0;\n\n\tregmap_update_bits(mixer->engine.regs,\n\t\t\t   SUN8I_MIXER_CHAN_VI_LAYER_ATTR(ch_base, overlay),\n\t\t\t   SUN8I_MIXER_CHAN_VI_LAYER_ATTR_EN, val);\n\n\tif (!enable || zpos != old_zpos) {\n\t\tregmap_update_bits(mixer->engine.regs,\n\t\t\t\t   SUN8I_MIXER_BLEND_PIPE_CTL(bld_base),\n\t\t\t\t   SUN8I_MIXER_BLEND_PIPE_CTL_EN(old_zpos),\n\t\t\t\t   0);\n\n\t\tregmap_update_bits(mixer->engine.regs,\n\t\t\t\t   SUN8I_MIXER_BLEND_ROUTE(bld_base),\n\t\t\t\t   SUN8I_MIXER_BLEND_ROUTE_PIPE_MSK(old_zpos),\n\t\t\t\t   0);\n\t}\n\n\tif (enable) {\n\t\tval = SUN8I_MIXER_BLEND_PIPE_CTL_EN(zpos);\n\n\t\tregmap_update_bits(mixer->engine.regs,\n\t\t\t\t   SUN8I_MIXER_BLEND_PIPE_CTL(bld_base),\n\t\t\t\t   val, val);\n\n\t\tval = channel << SUN8I_MIXER_BLEND_ROUTE_PIPE_SHIFT(zpos);\n\n\t\tregmap_update_bits(mixer->engine.regs,\n\t\t\t\t   SUN8I_MIXER_BLEND_ROUTE(bld_base),\n\t\t\t\t   SUN8I_MIXER_BLEND_ROUTE_PIPE_MSK(zpos),\n\t\t\t\t   val);\n\t}\n}\n\nstatic void sun8i_vi_layer_update_alpha(struct sun8i_mixer *mixer, int channel,\n\t\t\t\t\tint overlay, struct drm_plane *plane)\n{\n\tu32 mask, val, ch_base;\n\n\tch_base = sun8i_channel_base(mixer, channel);\n\n\tif (mixer->cfg->is_de3) {\n\t\tmask = SUN50I_MIXER_CHAN_VI_LAYER_ATTR_ALPHA_MASK |\n\t\t       SUN50I_MIXER_CHAN_VI_LAYER_ATTR_ALPHA_MODE_MASK;\n\t\tval = SUN50I_MIXER_CHAN_VI_LAYER_ATTR_ALPHA\n\t\t\t(plane->state->alpha >> 8);\n\n\t\tval |= (plane->state->alpha == DRM_BLEND_ALPHA_OPAQUE) ?\n\t\t\tSUN50I_MIXER_CHAN_VI_LAYER_ATTR_ALPHA_MODE_PIXEL :\n\t\t\tSUN50I_MIXER_CHAN_VI_LAYER_ATTR_ALPHA_MODE_COMBINED;\n\n\t\tregmap_update_bits(mixer->engine.regs,\n\t\t\t\t   SUN8I_MIXER_CHAN_VI_LAYER_ATTR(ch_base,\n\t\t\t\t\t\t\t\t  overlay),\n\t\t\t\t   mask, val);\n\t} else if (mixer->cfg->vi_num == 1) {\n\t\tregmap_update_bits(mixer->engine.regs,\n\t\t\t\t   SUN8I_MIXER_FCC_GLOBAL_ALPHA_REG,\n\t\t\t\t   SUN8I_MIXER_FCC_GLOBAL_ALPHA_MASK,\n\t\t\t\t   SUN8I_MIXER_FCC_GLOBAL_ALPHA\n\t\t\t\t\t(plane->state->alpha >> 8));\n\t}\n}\n\nstatic int sun8i_vi_layer_update_coord(struct sun8i_mixer *mixer, int channel,\n\t\t\t\t       int overlay, struct drm_plane *plane,\n\t\t\t\t       unsigned int zpos)\n{\n\tstruct drm_plane_state *state = plane->state;\n\tconst struct drm_format_info *format = state->fb->format;\n\tu32 src_w, src_h, dst_w, dst_h;\n\tu32 bld_base, ch_base;\n\tu32 outsize, insize;\n\tu32 hphase, vphase;\n\tu32 hn = 0, hm = 0;\n\tu32 vn = 0, vm = 0;\n\tbool subsampled;\n\n\tDRM_DEBUG_DRIVER(\"Updating VI channel %d overlay %d\\n\",\n\t\t\t channel, overlay);\n\n\tbld_base = sun8i_blender_base(mixer);\n\tch_base = sun8i_channel_base(mixer, channel);\n\n\tsrc_w = drm_rect_width(&state->src) >> 16;\n\tsrc_h = drm_rect_height(&state->src) >> 16;\n\tdst_w = drm_rect_width(&state->dst);\n\tdst_h = drm_rect_height(&state->dst);\n\n\thphase = state->src.x1 & 0xffff;\n\tvphase = state->src.y1 & 0xffff;\n\n\t \n\tif (format->hsub > 1) {\n\t\tint mask, remainder;\n\n\t\tmask = format->hsub - 1;\n\t\tremainder = (state->src.x1 >> 16) & mask;\n\t\tsrc_w = (src_w + remainder) & ~mask;\n\t\thphase += remainder << 16;\n\t}\n\n\tif (format->vsub > 1) {\n\t\tint mask, remainder;\n\n\t\tmask = format->vsub - 1;\n\t\tremainder = (state->src.y1 >> 16) & mask;\n\t\tsrc_h = (src_h + remainder) & ~mask;\n\t\tvphase += remainder << 16;\n\t}\n\n\tinsize = SUN8I_MIXER_SIZE(src_w, src_h);\n\toutsize = SUN8I_MIXER_SIZE(dst_w, dst_h);\n\n\t \n\tDRM_DEBUG_DRIVER(\"Layer source offset X: %d Y: %d\\n\",\n\t\t\t (state->src.x1 >> 16) & ~(format->hsub - 1),\n\t\t\t (state->src.y1 >> 16) & ~(format->vsub - 1));\n\tDRM_DEBUG_DRIVER(\"Layer source size W: %d H: %d\\n\", src_w, src_h);\n\tregmap_write(mixer->engine.regs,\n\t\t     SUN8I_MIXER_CHAN_VI_LAYER_SIZE(ch_base, overlay),\n\t\t     insize);\n\tregmap_write(mixer->engine.regs,\n\t\t     SUN8I_MIXER_CHAN_VI_OVL_SIZE(ch_base),\n\t\t     insize);\n\n\t \n\tsubsampled = format->hsub > 1 || format->vsub > 1;\n\n\tif (insize != outsize || subsampled || hphase || vphase) {\n\t\tunsigned int scanline, required;\n\t\tstruct drm_display_mode *mode;\n\t\tu32 hscale, vscale, fps;\n\t\tu64 ability;\n\n\t\tDRM_DEBUG_DRIVER(\"HW scaling is enabled\\n\");\n\n\t\tmode = &plane->state->crtc->state->mode;\n\t\tfps = (mode->clock * 1000) / (mode->vtotal * mode->htotal);\n\t\tability = clk_get_rate(mixer->mod_clk);\n\t\t \n\t\tability *= 80;\n\t\tdo_div(ability, mode->vdisplay * fps * max(src_w, dst_w));\n\n\t\trequired = src_h * 100 / dst_h;\n\n\t\tif (ability < required) {\n\t\t\tDRM_DEBUG_DRIVER(\"Using vertical coarse scaling\\n\");\n\t\t\tvm = src_h;\n\t\t\tvn = (u32)ability * dst_h / 100;\n\t\t\tsrc_h = vn;\n\t\t}\n\n\t\t \n\t\tscanline = subsampled ? mixer->cfg->scanline_yuv : 2048;\n\n\t\tif (src_w > scanline) {\n\t\t\tDRM_DEBUG_DRIVER(\"Using horizontal coarse scaling\\n\");\n\t\t\thm = src_w;\n\t\t\thn = scanline;\n\t\t\tsrc_w = hn;\n\t\t}\n\n\t\thscale = (src_w << 16) / dst_w;\n\t\tvscale = (src_h << 16) / dst_h;\n\n\t\tsun8i_vi_scaler_setup(mixer, channel, src_w, src_h, dst_w,\n\t\t\t\t      dst_h, hscale, vscale, hphase, vphase,\n\t\t\t\t      format);\n\t\tsun8i_vi_scaler_enable(mixer, channel, true);\n\t} else {\n\t\tDRM_DEBUG_DRIVER(\"HW scaling is not needed\\n\");\n\t\tsun8i_vi_scaler_enable(mixer, channel, false);\n\t}\n\n\tregmap_write(mixer->engine.regs,\n\t\t     SUN8I_MIXER_CHAN_VI_HDS_Y(ch_base),\n\t\t     SUN8I_MIXER_CHAN_VI_DS_N(hn) |\n\t\t     SUN8I_MIXER_CHAN_VI_DS_M(hm));\n\tregmap_write(mixer->engine.regs,\n\t\t     SUN8I_MIXER_CHAN_VI_HDS_UV(ch_base),\n\t\t     SUN8I_MIXER_CHAN_VI_DS_N(hn) |\n\t\t     SUN8I_MIXER_CHAN_VI_DS_M(hm));\n\tregmap_write(mixer->engine.regs,\n\t\t     SUN8I_MIXER_CHAN_VI_VDS_Y(ch_base),\n\t\t     SUN8I_MIXER_CHAN_VI_DS_N(vn) |\n\t\t     SUN8I_MIXER_CHAN_VI_DS_M(vm));\n\tregmap_write(mixer->engine.regs,\n\t\t     SUN8I_MIXER_CHAN_VI_VDS_UV(ch_base),\n\t\t     SUN8I_MIXER_CHAN_VI_DS_N(vn) |\n\t\t     SUN8I_MIXER_CHAN_VI_DS_M(vm));\n\n\t \n\tDRM_DEBUG_DRIVER(\"Layer destination coordinates X: %d Y: %d\\n\",\n\t\t\t state->dst.x1, state->dst.y1);\n\tDRM_DEBUG_DRIVER(\"Layer destination size W: %d H: %d\\n\", dst_w, dst_h);\n\tregmap_write(mixer->engine.regs,\n\t\t     SUN8I_MIXER_BLEND_ATTR_COORD(bld_base, zpos),\n\t\t     SUN8I_MIXER_COORD(state->dst.x1, state->dst.y1));\n\tregmap_write(mixer->engine.regs,\n\t\t     SUN8I_MIXER_BLEND_ATTR_INSIZE(bld_base, zpos),\n\t\t     outsize);\n\n\treturn 0;\n}\n\nstatic u32 sun8i_vi_layer_get_csc_mode(const struct drm_format_info *format)\n{\n\tif (!format->is_yuv)\n\t\treturn SUN8I_CSC_MODE_OFF;\n\n\tswitch (format->format) {\n\tcase DRM_FORMAT_YVU411:\n\tcase DRM_FORMAT_YVU420:\n\tcase DRM_FORMAT_YVU422:\n\tcase DRM_FORMAT_YVU444:\n\t\treturn SUN8I_CSC_MODE_YVU2RGB;\n\tdefault:\n\t\treturn SUN8I_CSC_MODE_YUV2RGB;\n\t}\n}\n\nstatic int sun8i_vi_layer_update_formats(struct sun8i_mixer *mixer, int channel,\n\t\t\t\t\t int overlay, struct drm_plane *plane)\n{\n\tstruct drm_plane_state *state = plane->state;\n\tu32 val, ch_base, csc_mode, hw_fmt;\n\tconst struct drm_format_info *fmt;\n\tint ret;\n\n\tch_base = sun8i_channel_base(mixer, channel);\n\n\tfmt = state->fb->format;\n\tret = sun8i_mixer_drm_format_to_hw(fmt->format, &hw_fmt);\n\tif (ret) {\n\t\tDRM_DEBUG_DRIVER(\"Invalid format\\n\");\n\t\treturn ret;\n\t}\n\n\tval = hw_fmt << SUN8I_MIXER_CHAN_VI_LAYER_ATTR_FBFMT_OFFSET;\n\tregmap_update_bits(mixer->engine.regs,\n\t\t\t   SUN8I_MIXER_CHAN_VI_LAYER_ATTR(ch_base, overlay),\n\t\t\t   SUN8I_MIXER_CHAN_VI_LAYER_ATTR_FBFMT_MASK, val);\n\n\tcsc_mode = sun8i_vi_layer_get_csc_mode(fmt);\n\tif (csc_mode != SUN8I_CSC_MODE_OFF) {\n\t\tsun8i_csc_set_ccsc_coefficients(mixer, channel, csc_mode,\n\t\t\t\t\t\tstate->color_encoding,\n\t\t\t\t\t\tstate->color_range);\n\t\tsun8i_csc_enable_ccsc(mixer, channel, true);\n\t} else {\n\t\tsun8i_csc_enable_ccsc(mixer, channel, false);\n\t}\n\n\tif (!fmt->is_yuv)\n\t\tval = SUN8I_MIXER_CHAN_VI_LAYER_ATTR_RGB_MODE;\n\telse\n\t\tval = 0;\n\n\tregmap_update_bits(mixer->engine.regs,\n\t\t\t   SUN8I_MIXER_CHAN_VI_LAYER_ATTR(ch_base, overlay),\n\t\t\t   SUN8I_MIXER_CHAN_VI_LAYER_ATTR_RGB_MODE, val);\n\n\treturn 0;\n}\n\nstatic int sun8i_vi_layer_update_buffer(struct sun8i_mixer *mixer, int channel,\n\t\t\t\t\tint overlay, struct drm_plane *plane)\n{\n\tstruct drm_plane_state *state = plane->state;\n\tstruct drm_framebuffer *fb = state->fb;\n\tconst struct drm_format_info *format = fb->format;\n\tstruct drm_gem_dma_object *gem;\n\tu32 dx, dy, src_x, src_y;\n\tdma_addr_t dma_addr;\n\tu32 ch_base;\n\tint i;\n\n\tch_base = sun8i_channel_base(mixer, channel);\n\n\t \n\tsrc_x = (state->src.x1 >> 16) & ~(format->hsub - 1);\n\tsrc_y = (state->src.y1 >> 16) & ~(format->vsub - 1);\n\n\tfor (i = 0; i < format->num_planes; i++) {\n\t\t \n\t\tgem = drm_fb_dma_get_gem_obj(fb, i);\n\n\t\tDRM_DEBUG_DRIVER(\"Using GEM @ %pad\\n\", &gem->dma_addr);\n\n\t\t \n\t\tdma_addr = gem->dma_addr + fb->offsets[i];\n\n\t\tdx = src_x;\n\t\tdy = src_y;\n\n\t\tif (i > 0) {\n\t\t\tdx /= format->hsub;\n\t\t\tdy /= format->vsub;\n\t\t}\n\n\t\t \n\t\tdma_addr += dx * format->cpp[i];\n\t\tdma_addr += dy * fb->pitches[i];\n\n\t\t \n\t\tDRM_DEBUG_DRIVER(\"Layer %d. line width: %d bytes\\n\",\n\t\t\t\t i + 1, fb->pitches[i]);\n\t\tregmap_write(mixer->engine.regs,\n\t\t\t     SUN8I_MIXER_CHAN_VI_LAYER_PITCH(ch_base,\n\t\t\t\t\t\t\t     overlay, i),\n\t\t\t     fb->pitches[i]);\n\n\t\tDRM_DEBUG_DRIVER(\"Setting %d. buffer address to %pad\\n\",\n\t\t\t\t i + 1, &dma_addr);\n\n\t\tregmap_write(mixer->engine.regs,\n\t\t\t     SUN8I_MIXER_CHAN_VI_LAYER_TOP_LADDR(ch_base,\n\t\t\t\t\t\t\t\t overlay, i),\n\t\t\t     lower_32_bits(dma_addr));\n\t}\n\n\treturn 0;\n}\n\nstatic int sun8i_vi_layer_atomic_check(struct drm_plane *plane,\n\t\t\t\t       struct drm_atomic_state *state)\n{\n\tstruct drm_plane_state *new_plane_state = drm_atomic_get_new_plane_state(state,\n\t\t\t\t\t\t\t\t\t\t plane);\n\tstruct sun8i_vi_layer *layer = plane_to_sun8i_vi_layer(plane);\n\tstruct drm_crtc *crtc = new_plane_state->crtc;\n\tstruct drm_crtc_state *crtc_state;\n\tint min_scale, max_scale;\n\n\tif (!crtc)\n\t\treturn 0;\n\n\tcrtc_state = drm_atomic_get_existing_crtc_state(state,\n\t\t\t\t\t\t\tcrtc);\n\tif (WARN_ON(!crtc_state))\n\t\treturn -EINVAL;\n\n\tmin_scale = DRM_PLANE_NO_SCALING;\n\tmax_scale = DRM_PLANE_NO_SCALING;\n\n\tif (layer->mixer->cfg->scaler_mask & BIT(layer->channel)) {\n\t\tmin_scale = SUN8I_VI_SCALER_SCALE_MIN;\n\t\tmax_scale = SUN8I_VI_SCALER_SCALE_MAX;\n\t}\n\n\treturn drm_atomic_helper_check_plane_state(new_plane_state,\n\t\t\t\t\t\t   crtc_state,\n\t\t\t\t\t\t   min_scale, max_scale,\n\t\t\t\t\t\t   true, true);\n}\n\nstatic void sun8i_vi_layer_atomic_disable(struct drm_plane *plane,\n\t\t\t\t\t  struct drm_atomic_state *state)\n{\n\tstruct drm_plane_state *old_state = drm_atomic_get_old_plane_state(state,\n\t\t\t\t\t\t\t\t\t   plane);\n\tstruct sun8i_vi_layer *layer = plane_to_sun8i_vi_layer(plane);\n\tunsigned int old_zpos = old_state->normalized_zpos;\n\tstruct sun8i_mixer *mixer = layer->mixer;\n\n\tsun8i_vi_layer_enable(mixer, layer->channel, layer->overlay, false, 0,\n\t\t\t      old_zpos);\n}\n\nstatic void sun8i_vi_layer_atomic_update(struct drm_plane *plane,\n\t\t\t\t\t struct drm_atomic_state *state)\n{\n\tstruct drm_plane_state *old_state = drm_atomic_get_old_plane_state(state,\n\t\t\t\t\t\t\t\t\t   plane);\n\tstruct drm_plane_state *new_state = drm_atomic_get_new_plane_state(state,\n\t\t\t\t\t\t\t\t\t   plane);\n\tstruct sun8i_vi_layer *layer = plane_to_sun8i_vi_layer(plane);\n\tunsigned int zpos = new_state->normalized_zpos;\n\tunsigned int old_zpos = old_state->normalized_zpos;\n\tstruct sun8i_mixer *mixer = layer->mixer;\n\n\tif (!new_state->visible) {\n\t\tsun8i_vi_layer_enable(mixer, layer->channel,\n\t\t\t\t      layer->overlay, false, 0, old_zpos);\n\t\treturn;\n\t}\n\n\tsun8i_vi_layer_update_coord(mixer, layer->channel,\n\t\t\t\t    layer->overlay, plane, zpos);\n\tsun8i_vi_layer_update_alpha(mixer, layer->channel,\n\t\t\t\t    layer->overlay, plane);\n\tsun8i_vi_layer_update_formats(mixer, layer->channel,\n\t\t\t\t      layer->overlay, plane);\n\tsun8i_vi_layer_update_buffer(mixer, layer->channel,\n\t\t\t\t     layer->overlay, plane);\n\tsun8i_vi_layer_enable(mixer, layer->channel, layer->overlay,\n\t\t\t      true, zpos, old_zpos);\n}\n\nstatic const struct drm_plane_helper_funcs sun8i_vi_layer_helper_funcs = {\n\t.atomic_check\t= sun8i_vi_layer_atomic_check,\n\t.atomic_disable\t= sun8i_vi_layer_atomic_disable,\n\t.atomic_update\t= sun8i_vi_layer_atomic_update,\n};\n\nstatic const struct drm_plane_funcs sun8i_vi_layer_funcs = {\n\t.atomic_destroy_state\t= drm_atomic_helper_plane_destroy_state,\n\t.atomic_duplicate_state\t= drm_atomic_helper_plane_duplicate_state,\n\t.destroy\t\t= drm_plane_cleanup,\n\t.disable_plane\t\t= drm_atomic_helper_disable_plane,\n\t.reset\t\t\t= drm_atomic_helper_plane_reset,\n\t.update_plane\t\t= drm_atomic_helper_update_plane,\n};\n\n \nstatic const u32 sun8i_vi_layer_formats[] = {\n\tDRM_FORMAT_BGR565,\n\tDRM_FORMAT_BGR888,\n\tDRM_FORMAT_BGRX4444,\n\tDRM_FORMAT_BGRX5551,\n\tDRM_FORMAT_BGRX8888,\n\tDRM_FORMAT_RGB565,\n\tDRM_FORMAT_RGB888,\n\tDRM_FORMAT_RGBX4444,\n\tDRM_FORMAT_RGBX5551,\n\tDRM_FORMAT_RGBX8888,\n\tDRM_FORMAT_XBGR1555,\n\tDRM_FORMAT_XBGR4444,\n\tDRM_FORMAT_XBGR8888,\n\tDRM_FORMAT_XRGB1555,\n\tDRM_FORMAT_XRGB4444,\n\tDRM_FORMAT_XRGB8888,\n\n\tDRM_FORMAT_NV16,\n\tDRM_FORMAT_NV12,\n\tDRM_FORMAT_NV21,\n\tDRM_FORMAT_NV61,\n\tDRM_FORMAT_UYVY,\n\tDRM_FORMAT_VYUY,\n\tDRM_FORMAT_YUYV,\n\tDRM_FORMAT_YVYU,\n\tDRM_FORMAT_YUV411,\n\tDRM_FORMAT_YUV420,\n\tDRM_FORMAT_YUV422,\n\tDRM_FORMAT_YVU411,\n\tDRM_FORMAT_YVU420,\n\tDRM_FORMAT_YVU422,\n};\n\nstatic const u32 sun8i_vi_layer_de3_formats[] = {\n\tDRM_FORMAT_ABGR1555,\n\tDRM_FORMAT_ABGR2101010,\n\tDRM_FORMAT_ABGR4444,\n\tDRM_FORMAT_ABGR8888,\n\tDRM_FORMAT_ARGB1555,\n\tDRM_FORMAT_ARGB2101010,\n\tDRM_FORMAT_ARGB4444,\n\tDRM_FORMAT_ARGB8888,\n\tDRM_FORMAT_BGR565,\n\tDRM_FORMAT_BGR888,\n\tDRM_FORMAT_BGRA1010102,\n\tDRM_FORMAT_BGRA5551,\n\tDRM_FORMAT_BGRA4444,\n\tDRM_FORMAT_BGRA8888,\n\tDRM_FORMAT_BGRX8888,\n\tDRM_FORMAT_RGB565,\n\tDRM_FORMAT_RGB888,\n\tDRM_FORMAT_RGBA1010102,\n\tDRM_FORMAT_RGBA4444,\n\tDRM_FORMAT_RGBA5551,\n\tDRM_FORMAT_RGBA8888,\n\tDRM_FORMAT_RGBX8888,\n\tDRM_FORMAT_XBGR8888,\n\tDRM_FORMAT_XRGB8888,\n\n\tDRM_FORMAT_NV16,\n\tDRM_FORMAT_NV12,\n\tDRM_FORMAT_NV21,\n\tDRM_FORMAT_NV61,\n\tDRM_FORMAT_P010,\n\tDRM_FORMAT_P210,\n\tDRM_FORMAT_UYVY,\n\tDRM_FORMAT_VYUY,\n\tDRM_FORMAT_YUYV,\n\tDRM_FORMAT_YVYU,\n\tDRM_FORMAT_YUV411,\n\tDRM_FORMAT_YUV420,\n\tDRM_FORMAT_YUV422,\n\tDRM_FORMAT_YVU411,\n\tDRM_FORMAT_YVU420,\n\tDRM_FORMAT_YVU422,\n};\n\nstatic const uint64_t sun8i_layer_modifiers[] = {\n\tDRM_FORMAT_MOD_LINEAR,\n\tDRM_FORMAT_MOD_INVALID\n};\n\nstruct sun8i_vi_layer *sun8i_vi_layer_init_one(struct drm_device *drm,\n\t\t\t\t\t       struct sun8i_mixer *mixer,\n\t\t\t\t\t       int index)\n{\n\tenum drm_plane_type type = DRM_PLANE_TYPE_OVERLAY;\n\tu32 supported_encodings, supported_ranges;\n\tunsigned int plane_cnt, format_count;\n\tstruct sun8i_vi_layer *layer;\n\tconst u32 *formats;\n\tint ret;\n\n\tlayer = devm_kzalloc(drm->dev, sizeof(*layer), GFP_KERNEL);\n\tif (!layer)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tif (mixer->cfg->is_de3) {\n\t\tformats = sun8i_vi_layer_de3_formats;\n\t\tformat_count = ARRAY_SIZE(sun8i_vi_layer_de3_formats);\n\t} else {\n\t\tformats = sun8i_vi_layer_formats;\n\t\tformat_count = ARRAY_SIZE(sun8i_vi_layer_formats);\n\t}\n\n\tif (!mixer->cfg->ui_num && index == 0)\n\t\ttype = DRM_PLANE_TYPE_PRIMARY;\n\n\t \n\tret = drm_universal_plane_init(drm, &layer->plane, 0,\n\t\t\t\t       &sun8i_vi_layer_funcs,\n\t\t\t\t       formats, format_count,\n\t\t\t\t       sun8i_layer_modifiers,\n\t\t\t\t       type, NULL);\n\tif (ret) {\n\t\tdev_err(drm->dev, \"Couldn't initialize layer\\n\");\n\t\treturn ERR_PTR(ret);\n\t}\n\n\tplane_cnt = mixer->cfg->ui_num + mixer->cfg->vi_num;\n\n\tif (mixer->cfg->vi_num == 1 || mixer->cfg->is_de3) {\n\t\tret = drm_plane_create_alpha_property(&layer->plane);\n\t\tif (ret) {\n\t\t\tdev_err(drm->dev, \"Couldn't add alpha property\\n\");\n\t\t\treturn ERR_PTR(ret);\n\t\t}\n\t}\n\n\tret = drm_plane_create_zpos_property(&layer->plane, index,\n\t\t\t\t\t     0, plane_cnt - 1);\n\tif (ret) {\n\t\tdev_err(drm->dev, \"Couldn't add zpos property\\n\");\n\t\treturn ERR_PTR(ret);\n\t}\n\n\tsupported_encodings = BIT(DRM_COLOR_YCBCR_BT601) |\n\t\t\t      BIT(DRM_COLOR_YCBCR_BT709);\n\tif (mixer->cfg->is_de3)\n\t\tsupported_encodings |= BIT(DRM_COLOR_YCBCR_BT2020);\n\n\tsupported_ranges = BIT(DRM_COLOR_YCBCR_LIMITED_RANGE) |\n\t\t\t   BIT(DRM_COLOR_YCBCR_FULL_RANGE);\n\n\tret = drm_plane_create_color_properties(&layer->plane,\n\t\t\t\t\t\tsupported_encodings,\n\t\t\t\t\t\tsupported_ranges,\n\t\t\t\t\t\tDRM_COLOR_YCBCR_BT709,\n\t\t\t\t\t\tDRM_COLOR_YCBCR_LIMITED_RANGE);\n\tif (ret) {\n\t\tdev_err(drm->dev, \"Couldn't add encoding and range properties!\\n\");\n\t\treturn ERR_PTR(ret);\n\t}\n\n\tdrm_plane_helper_add(&layer->plane, &sun8i_vi_layer_helper_funcs);\n\tlayer->mixer = mixer;\n\tlayer->channel = index;\n\tlayer->overlay = 0;\n\n\treturn layer;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}