{
  "module_name": "sun4i_backend.c",
  "hash_id": "bdbb4cf4ea82dbfbbcb364695a8b3ec37a340312a6b540a46fce163b6d36d4f2",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/sun4i/sun4i_backend.c",
  "human_readable_source": "\n \n\n#include <linux/component.h>\n#include <linux/list.h>\n#include <linux/module.h>\n#include <linux/of_device.h>\n#include <linux/of_graph.h>\n#include <linux/dma-mapping.h>\n#include <linux/platform_device.h>\n#include <linux/reset.h>\n\n#include <drm/drm_atomic.h>\n#include <drm/drm_atomic_helper.h>\n#include <drm/drm_blend.h>\n#include <drm/drm_crtc.h>\n#include <drm/drm_fb_dma_helper.h>\n#include <drm/drm_fourcc.h>\n#include <drm/drm_framebuffer.h>\n#include <drm/drm_gem_dma_helper.h>\n#include <drm/drm_probe_helper.h>\n\n#include \"sun4i_backend.h\"\n#include \"sun4i_drv.h\"\n#include \"sun4i_frontend.h\"\n#include \"sun4i_layer.h\"\n#include \"sunxi_engine.h\"\n\nstruct sun4i_backend_quirks {\n\t \n\tbool needs_output_muxing;\n\n\t \n\tbool supports_lowest_plane_alpha;\n};\n\nstatic const u32 sunxi_rgb2yuv_coef[12] = {\n\t0x00000107, 0x00000204, 0x00000064, 0x00000108,\n\t0x00003f69, 0x00003ed6, 0x000001c1, 0x00000808,\n\t0x000001c1, 0x00003e88, 0x00003fb8, 0x00000808\n};\n\nstatic void sun4i_backend_apply_color_correction(struct sunxi_engine *engine)\n{\n\tint i;\n\n\tDRM_DEBUG_DRIVER(\"Applying RGB to YUV color correction\\n\");\n\n\t \n\tregmap_write(engine->regs, SUN4I_BACKEND_OCCTL_REG,\n\t\t     SUN4I_BACKEND_OCCTL_ENABLE);\n\n\tfor (i = 0; i < 12; i++)\n\t\tregmap_write(engine->regs, SUN4I_BACKEND_OCRCOEF_REG(i),\n\t\t\t     sunxi_rgb2yuv_coef[i]);\n}\n\nstatic void sun4i_backend_disable_color_correction(struct sunxi_engine *engine)\n{\n\tDRM_DEBUG_DRIVER(\"Disabling color correction\\n\");\n\n\t \n\tregmap_update_bits(engine->regs, SUN4I_BACKEND_OCCTL_REG,\n\t\t\t   SUN4I_BACKEND_OCCTL_ENABLE, 0);\n}\n\nstatic void sun4i_backend_commit(struct sunxi_engine *engine)\n{\n\tDRM_DEBUG_DRIVER(\"Committing changes\\n\");\n\n\tregmap_write(engine->regs, SUN4I_BACKEND_REGBUFFCTL_REG,\n\t\t     SUN4I_BACKEND_REGBUFFCTL_AUTOLOAD_DIS |\n\t\t     SUN4I_BACKEND_REGBUFFCTL_LOADCTL);\n}\n\nvoid sun4i_backend_layer_enable(struct sun4i_backend *backend,\n\t\t\t\tint layer, bool enable)\n{\n\tu32 val;\n\n\tDRM_DEBUG_DRIVER(\"%sabling layer %d\\n\", enable ? \"En\" : \"Dis\",\n\t\t\t layer);\n\n\tif (enable)\n\t\tval = SUN4I_BACKEND_MODCTL_LAY_EN(layer);\n\telse\n\t\tval = 0;\n\n\tregmap_update_bits(backend->engine.regs, SUN4I_BACKEND_MODCTL_REG,\n\t\t\t   SUN4I_BACKEND_MODCTL_LAY_EN(layer), val);\n}\n\nstatic int sun4i_backend_drm_format_to_layer(u32 format, u32 *mode)\n{\n\tswitch (format) {\n\tcase DRM_FORMAT_ARGB8888:\n\t\t*mode = SUN4I_BACKEND_LAY_FBFMT_ARGB8888;\n\t\tbreak;\n\n\tcase DRM_FORMAT_ARGB4444:\n\t\t*mode = SUN4I_BACKEND_LAY_FBFMT_ARGB4444;\n\t\tbreak;\n\n\tcase DRM_FORMAT_ARGB1555:\n\t\t*mode = SUN4I_BACKEND_LAY_FBFMT_ARGB1555;\n\t\tbreak;\n\n\tcase DRM_FORMAT_RGBA5551:\n\t\t*mode = SUN4I_BACKEND_LAY_FBFMT_RGBA5551;\n\t\tbreak;\n\n\tcase DRM_FORMAT_RGBA4444:\n\t\t*mode = SUN4I_BACKEND_LAY_FBFMT_RGBA4444;\n\t\tbreak;\n\n\tcase DRM_FORMAT_XRGB8888:\n\t\t*mode = SUN4I_BACKEND_LAY_FBFMT_XRGB8888;\n\t\tbreak;\n\n\tcase DRM_FORMAT_RGB888:\n\t\t*mode = SUN4I_BACKEND_LAY_FBFMT_RGB888;\n\t\tbreak;\n\n\tcase DRM_FORMAT_RGB565:\n\t\t*mode = SUN4I_BACKEND_LAY_FBFMT_RGB565;\n\t\tbreak;\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic const uint32_t sun4i_backend_formats[] = {\n\tDRM_FORMAT_ARGB1555,\n\tDRM_FORMAT_ARGB4444,\n\tDRM_FORMAT_ARGB8888,\n\tDRM_FORMAT_RGB565,\n\tDRM_FORMAT_RGB888,\n\tDRM_FORMAT_RGBA4444,\n\tDRM_FORMAT_RGBA5551,\n\tDRM_FORMAT_UYVY,\n\tDRM_FORMAT_VYUY,\n\tDRM_FORMAT_XRGB8888,\n\tDRM_FORMAT_YUYV,\n\tDRM_FORMAT_YVYU,\n};\n\nbool sun4i_backend_format_is_supported(uint32_t fmt, uint64_t modifier)\n{\n\tunsigned int i;\n\n\tif (modifier != DRM_FORMAT_MOD_LINEAR)\n\t\treturn false;\n\n\tfor (i = 0; i < ARRAY_SIZE(sun4i_backend_formats); i++)\n\t\tif (sun4i_backend_formats[i] == fmt)\n\t\t\treturn true;\n\n\treturn false;\n}\n\nint sun4i_backend_update_layer_coord(struct sun4i_backend *backend,\n\t\t\t\t     int layer, struct drm_plane *plane)\n{\n\tstruct drm_plane_state *state = plane->state;\n\n\tDRM_DEBUG_DRIVER(\"Updating layer %d\\n\", layer);\n\n\t \n\tDRM_DEBUG_DRIVER(\"Layer size W: %u H: %u\\n\",\n\t\t\t state->crtc_w, state->crtc_h);\n\tregmap_write(backend->engine.regs, SUN4I_BACKEND_LAYSIZE_REG(layer),\n\t\t     SUN4I_BACKEND_LAYSIZE(state->crtc_w,\n\t\t\t\t\t   state->crtc_h));\n\n\t \n\tDRM_DEBUG_DRIVER(\"Layer coordinates X: %d Y: %d\\n\",\n\t\t\t state->crtc_x, state->crtc_y);\n\tregmap_write(backend->engine.regs, SUN4I_BACKEND_LAYCOOR_REG(layer),\n\t\t     SUN4I_BACKEND_LAYCOOR(state->crtc_x,\n\t\t\t\t\t   state->crtc_y));\n\n\treturn 0;\n}\n\nstatic int sun4i_backend_update_yuv_format(struct sun4i_backend *backend,\n\t\t\t\t\t   int layer, struct drm_plane *plane)\n{\n\tstruct drm_plane_state *state = plane->state;\n\tstruct drm_framebuffer *fb = state->fb;\n\tconst struct drm_format_info *format = fb->format;\n\tconst uint32_t fmt = format->format;\n\tu32 val = SUN4I_BACKEND_IYUVCTL_EN;\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(sunxi_bt601_yuv2rgb_coef); i++)\n\t\tregmap_write(backend->engine.regs,\n\t\t\t     SUN4I_BACKEND_YGCOEF_REG(i),\n\t\t\t     sunxi_bt601_yuv2rgb_coef[i]);\n\n\t \n\tregmap_update_bits(backend->engine.regs, SUN4I_BACKEND_ATTCTL_REG0(layer),\n\t\t\t   SUN4I_BACKEND_ATTCTL_REG0_LAY_YUVEN,\n\t\t\t   SUN4I_BACKEND_ATTCTL_REG0_LAY_YUVEN);\n\n\t \n\tif (drm_format_info_is_yuv_packed(format) &&\n\t    drm_format_info_is_yuv_sampling_422(format))\n\t\tval |= SUN4I_BACKEND_IYUVCTL_FBFMT_PACKED_YUV422;\n\telse\n\t\tDRM_DEBUG_DRIVER(\"Unsupported YUV format (0x%x)\\n\", fmt);\n\n\t \n\tswitch (fmt) {\n\tcase DRM_FORMAT_YUYV:\n\t\tval |= SUN4I_BACKEND_IYUVCTL_FBPS_VYUY;\n\t\tbreak;\n\tcase DRM_FORMAT_YVYU:\n\t\tval |= SUN4I_BACKEND_IYUVCTL_FBPS_UYVY;\n\t\tbreak;\n\tcase DRM_FORMAT_UYVY:\n\t\tval |= SUN4I_BACKEND_IYUVCTL_FBPS_YVYU;\n\t\tbreak;\n\tcase DRM_FORMAT_VYUY:\n\t\tval |= SUN4I_BACKEND_IYUVCTL_FBPS_YUYV;\n\t\tbreak;\n\tdefault:\n\t\tDRM_DEBUG_DRIVER(\"Unsupported YUV pixel sequence (0x%x)\\n\",\n\t\t\t\t fmt);\n\t}\n\n\tregmap_write(backend->engine.regs, SUN4I_BACKEND_IYUVCTL_REG, val);\n\n\treturn 0;\n}\n\nint sun4i_backend_update_layer_formats(struct sun4i_backend *backend,\n\t\t\t\t       int layer, struct drm_plane *plane)\n{\n\tstruct drm_plane_state *state = plane->state;\n\tstruct drm_framebuffer *fb = state->fb;\n\tu32 val;\n\tint ret;\n\n\t \n\tregmap_update_bits(backend->engine.regs, SUN4I_BACKEND_ATTCTL_REG0(layer),\n\t\t\t   SUN4I_BACKEND_ATTCTL_REG0_LAY_YUVEN, 0);\n\n\tval = SUN4I_BACKEND_ATTCTL_REG0_LAY_GLBALPHA(state->alpha >> 8);\n\tif (state->alpha != DRM_BLEND_ALPHA_OPAQUE)\n\t\tval |= SUN4I_BACKEND_ATTCTL_REG0_LAY_GLBALPHA_EN;\n\tregmap_update_bits(backend->engine.regs,\n\t\t\t   SUN4I_BACKEND_ATTCTL_REG0(layer),\n\t\t\t   SUN4I_BACKEND_ATTCTL_REG0_LAY_GLBALPHA_MASK |\n\t\t\t   SUN4I_BACKEND_ATTCTL_REG0_LAY_GLBALPHA_EN,\n\t\t\t   val);\n\n\tif (fb->format->is_yuv)\n\t\treturn sun4i_backend_update_yuv_format(backend, layer, plane);\n\n\tret = sun4i_backend_drm_format_to_layer(fb->format->format, &val);\n\tif (ret) {\n\t\tDRM_DEBUG_DRIVER(\"Invalid format\\n\");\n\t\treturn ret;\n\t}\n\n\tregmap_update_bits(backend->engine.regs,\n\t\t\t   SUN4I_BACKEND_ATTCTL_REG1(layer),\n\t\t\t   SUN4I_BACKEND_ATTCTL_REG1_LAY_FBFMT, val);\n\n\treturn 0;\n}\n\nint sun4i_backend_update_layer_frontend(struct sun4i_backend *backend,\n\t\t\t\t\tint layer, uint32_t fmt)\n{\n\tu32 val;\n\tint ret;\n\n\tret = sun4i_backend_drm_format_to_layer(fmt, &val);\n\tif (ret) {\n\t\tDRM_DEBUG_DRIVER(\"Invalid format\\n\");\n\t\treturn ret;\n\t}\n\n\tregmap_update_bits(backend->engine.regs,\n\t\t\t   SUN4I_BACKEND_ATTCTL_REG0(layer),\n\t\t\t   SUN4I_BACKEND_ATTCTL_REG0_LAY_VDOEN,\n\t\t\t   SUN4I_BACKEND_ATTCTL_REG0_LAY_VDOEN);\n\n\tregmap_update_bits(backend->engine.regs,\n\t\t\t   SUN4I_BACKEND_ATTCTL_REG1(layer),\n\t\t\t   SUN4I_BACKEND_ATTCTL_REG1_LAY_FBFMT, val);\n\n\treturn 0;\n}\n\nstatic int sun4i_backend_update_yuv_buffer(struct sun4i_backend *backend,\n\t\t\t\t\t   struct drm_framebuffer *fb,\n\t\t\t\t\t   dma_addr_t paddr)\n{\n\t \n\tDRM_DEBUG_DRIVER(\"Setting packed YUV buffer address to %pad\\n\", &paddr);\n\tregmap_write(backend->engine.regs, SUN4I_BACKEND_IYUVADD_REG(0), paddr);\n\n\tDRM_DEBUG_DRIVER(\"Layer line width: %d bits\\n\", fb->pitches[0] * 8);\n\tregmap_write(backend->engine.regs, SUN4I_BACKEND_IYUVLINEWIDTH_REG(0),\n\t\t     fb->pitches[0] * 8);\n\n\treturn 0;\n}\n\nint sun4i_backend_update_layer_buffer(struct sun4i_backend *backend,\n\t\t\t\t      int layer, struct drm_plane *plane)\n{\n\tstruct drm_plane_state *state = plane->state;\n\tstruct drm_framebuffer *fb = state->fb;\n\tu32 lo_paddr, hi_paddr;\n\tdma_addr_t dma_addr;\n\n\t \n\tDRM_DEBUG_DRIVER(\"Layer line width: %d bits\\n\", fb->pitches[0] * 8);\n\tregmap_write(backend->engine.regs,\n\t\t     SUN4I_BACKEND_LAYLINEWIDTH_REG(layer),\n\t\t     fb->pitches[0] * 8);\n\n\t \n\tdma_addr = drm_fb_dma_get_gem_addr(fb, state, 0);\n\tDRM_DEBUG_DRIVER(\"Setting buffer address to %pad\\n\", &dma_addr);\n\n\tif (fb->format->is_yuv)\n\t\treturn sun4i_backend_update_yuv_buffer(backend, fb, dma_addr);\n\n\t \n\tlo_paddr = dma_addr << 3;\n\tDRM_DEBUG_DRIVER(\"Setting address lower bits to 0x%x\\n\", lo_paddr);\n\tregmap_write(backend->engine.regs,\n\t\t     SUN4I_BACKEND_LAYFB_L32ADD_REG(layer),\n\t\t     lo_paddr);\n\n\t \n\thi_paddr = dma_addr >> 29;\n\tDRM_DEBUG_DRIVER(\"Setting address high bits to 0x%x\\n\", hi_paddr);\n\tregmap_update_bits(backend->engine.regs, SUN4I_BACKEND_LAYFB_H4ADD_REG,\n\t\t\t   SUN4I_BACKEND_LAYFB_H4ADD_MSK(layer),\n\t\t\t   SUN4I_BACKEND_LAYFB_H4ADD(layer, hi_paddr));\n\n\treturn 0;\n}\n\nint sun4i_backend_update_layer_zpos(struct sun4i_backend *backend, int layer,\n\t\t\t\t    struct drm_plane *plane)\n{\n\tstruct drm_plane_state *state = plane->state;\n\tstruct sun4i_layer_state *p_state = state_to_sun4i_layer_state(state);\n\tunsigned int priority = state->normalized_zpos;\n\tunsigned int pipe = p_state->pipe;\n\n\tDRM_DEBUG_DRIVER(\"Setting layer %d's priority to %d and pipe %d\\n\",\n\t\t\t layer, priority, pipe);\n\tregmap_update_bits(backend->engine.regs, SUN4I_BACKEND_ATTCTL_REG0(layer),\n\t\t\t   SUN4I_BACKEND_ATTCTL_REG0_LAY_PIPESEL_MASK |\n\t\t\t   SUN4I_BACKEND_ATTCTL_REG0_LAY_PRISEL_MASK,\n\t\t\t   SUN4I_BACKEND_ATTCTL_REG0_LAY_PIPESEL(p_state->pipe) |\n\t\t\t   SUN4I_BACKEND_ATTCTL_REG0_LAY_PRISEL(priority));\n\n\treturn 0;\n}\n\nvoid sun4i_backend_cleanup_layer(struct sun4i_backend *backend,\n\t\t\t\t int layer)\n{\n\tregmap_update_bits(backend->engine.regs,\n\t\t\t   SUN4I_BACKEND_ATTCTL_REG0(layer),\n\t\t\t   SUN4I_BACKEND_ATTCTL_REG0_LAY_VDOEN |\n\t\t\t   SUN4I_BACKEND_ATTCTL_REG0_LAY_YUVEN, 0);\n}\n\nstatic bool sun4i_backend_plane_uses_scaler(struct drm_plane_state *state)\n{\n\tu16 src_h = state->src_h >> 16;\n\tu16 src_w = state->src_w >> 16;\n\n\tDRM_DEBUG_DRIVER(\"Input size %dx%d, output size %dx%d\\n\",\n\t\t\t src_w, src_h, state->crtc_w, state->crtc_h);\n\n\tif ((state->crtc_h != src_h) || (state->crtc_w != src_w))\n\t\treturn true;\n\n\treturn false;\n}\n\nstatic bool sun4i_backend_plane_uses_frontend(struct drm_plane_state *state)\n{\n\tstruct sun4i_layer *layer = plane_to_sun4i_layer(state->plane);\n\tstruct sun4i_backend *backend = layer->backend;\n\tuint32_t format = state->fb->format->format;\n\tuint64_t modifier = state->fb->modifier;\n\n\tif (IS_ERR(backend->frontend))\n\t\treturn false;\n\n\tif (!sun4i_frontend_format_is_supported(format, modifier))\n\t\treturn false;\n\n\tif (!sun4i_backend_format_is_supported(format, modifier))\n\t\treturn true;\n\n\t \n\n\tif (sun4i_backend_plane_uses_scaler(state))\n\t\treturn true;\n\n\t \n\treturn false;\n}\n\nstatic bool sun4i_backend_plane_is_supported(struct drm_plane_state *state,\n\t\t\t\t\t     bool *uses_frontend)\n{\n\tif (sun4i_backend_plane_uses_frontend(state)) {\n\t\t*uses_frontend = true;\n\t\treturn true;\n\t}\n\n\t*uses_frontend = false;\n\n\t \n\tif (sun4i_backend_plane_uses_scaler(state))\n\t\treturn false;\n\n\treturn true;\n}\n\nstatic void sun4i_backend_atomic_begin(struct sunxi_engine *engine,\n\t\t\t\t       struct drm_crtc_state *old_state)\n{\n\tu32 val;\n\n\tWARN_ON(regmap_read_poll_timeout(engine->regs,\n\t\t\t\t\t SUN4I_BACKEND_REGBUFFCTL_REG,\n\t\t\t\t\t val, !(val & SUN4I_BACKEND_REGBUFFCTL_LOADCTL),\n\t\t\t\t\t 100, 50000));\n}\n\nstatic int sun4i_backend_atomic_check(struct sunxi_engine *engine,\n\t\t\t\t      struct drm_crtc_state *crtc_state)\n{\n\tstruct drm_plane_state *plane_states[SUN4I_BACKEND_NUM_LAYERS] = { 0 };\n\tstruct sun4i_backend *backend = engine_to_sun4i_backend(engine);\n\tstruct drm_atomic_state *state = crtc_state->state;\n\tstruct drm_device *drm = state->dev;\n\tstruct drm_plane *plane;\n\tunsigned int num_planes = 0;\n\tunsigned int num_alpha_planes = 0;\n\tunsigned int num_frontend_planes = 0;\n\tunsigned int num_alpha_planes_max = 1;\n\tunsigned int num_yuv_planes = 0;\n\tunsigned int current_pipe = 0;\n\tunsigned int i;\n\n\tDRM_DEBUG_DRIVER(\"Starting checking our planes\\n\");\n\n\tif (!crtc_state->planes_changed)\n\t\treturn 0;\n\n\tdrm_for_each_plane_mask(plane, drm, crtc_state->plane_mask) {\n\t\tstruct drm_plane_state *plane_state =\n\t\t\tdrm_atomic_get_plane_state(state, plane);\n\t\tstruct sun4i_layer_state *layer_state =\n\t\t\tstate_to_sun4i_layer_state(plane_state);\n\t\tstruct drm_framebuffer *fb = plane_state->fb;\n\n\t\tif (!sun4i_backend_plane_is_supported(plane_state,\n\t\t\t\t\t\t      &layer_state->uses_frontend))\n\t\t\treturn -EINVAL;\n\n\t\tif (layer_state->uses_frontend) {\n\t\t\tDRM_DEBUG_DRIVER(\"Using the frontend for plane %d\\n\",\n\t\t\t\t\t plane->index);\n\t\t\tnum_frontend_planes++;\n\t\t} else {\n\t\t\tif (fb->format->is_yuv) {\n\t\t\t\tDRM_DEBUG_DRIVER(\"Plane FB format is YUV\\n\");\n\t\t\t\tnum_yuv_planes++;\n\t\t\t}\n\t\t}\n\n\t\tDRM_DEBUG_DRIVER(\"Plane FB format is %p4cc\\n\",\n\t\t\t\t &fb->format->format);\n\t\tif (fb->format->has_alpha || (plane_state->alpha != DRM_BLEND_ALPHA_OPAQUE))\n\t\t\tnum_alpha_planes++;\n\n\t\tDRM_DEBUG_DRIVER(\"Plane zpos is %d\\n\",\n\t\t\t\t plane_state->normalized_zpos);\n\n\t\t \n\t\tplane_states[plane_state->normalized_zpos] = plane_state;\n\n\t\tnum_planes++;\n\t}\n\n\t \n\tif (!num_planes)\n\t\treturn 0;\n\n\t \n\n\t \n\tif (backend->quirks->supports_lowest_plane_alpha)\n\t\tnum_alpha_planes_max++;\n\n\tif (num_alpha_planes > num_alpha_planes_max) {\n\t\tDRM_DEBUG_DRIVER(\"Too many planes with alpha, rejecting...\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (!backend->quirks->supports_lowest_plane_alpha &&\n\t    (plane_states[0]->alpha != DRM_BLEND_ALPHA_OPAQUE))\n\t\treturn -EINVAL;\n\n\tfor (i = 1; i < num_planes; i++) {\n\t\tstruct drm_plane_state *p_state = plane_states[i];\n\t\tstruct drm_framebuffer *fb = p_state->fb;\n\t\tstruct sun4i_layer_state *s_state = state_to_sun4i_layer_state(p_state);\n\n\t\t \n\t\tif (fb->format->has_alpha || (p_state->alpha != DRM_BLEND_ALPHA_OPAQUE))\n\t\t\tcurrent_pipe++;\n\n\t\ts_state->pipe = current_pipe;\n\t}\n\n\t \n\tif (num_yuv_planes > SUN4I_BACKEND_NUM_YUV_PLANES) {\n\t\tDRM_DEBUG_DRIVER(\"Too many planes with YUV, rejecting...\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (num_frontend_planes > SUN4I_BACKEND_NUM_FRONTEND_LAYERS) {\n\t\tDRM_DEBUG_DRIVER(\"Too many planes going through the frontend, rejecting\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tDRM_DEBUG_DRIVER(\"State valid with %u planes, %u alpha, %u video, %u YUV\\n\",\n\t\t\t num_planes, num_alpha_planes, num_frontend_planes,\n\t\t\t num_yuv_planes);\n\n\treturn 0;\n}\n\nstatic void sun4i_backend_vblank_quirk(struct sunxi_engine *engine)\n{\n\tstruct sun4i_backend *backend = engine_to_sun4i_backend(engine);\n\tstruct sun4i_frontend *frontend = backend->frontend;\n\n\tif (!frontend)\n\t\treturn;\n\n\t \n\tspin_lock(&backend->frontend_lock);\n\tif (backend->frontend_teardown) {\n\t\tsun4i_frontend_exit(frontend);\n\t\tbackend->frontend_teardown = false;\n\t}\n\tspin_unlock(&backend->frontend_lock);\n};\n\nstatic void sun4i_backend_mode_set(struct sunxi_engine *engine,\n\t\t\t\t   const struct drm_display_mode *mode)\n{\n\tbool interlaced = !!(mode->flags & DRM_MODE_FLAG_INTERLACE);\n\n\tDRM_DEBUG_DRIVER(\"Updating global size W: %u H: %u\\n\",\n\t\t\t mode->hdisplay, mode->vdisplay);\n\n\tregmap_write(engine->regs, SUN4I_BACKEND_DISSIZE_REG,\n\t\t     SUN4I_BACKEND_DISSIZE(mode->hdisplay, mode->vdisplay));\n\n\tregmap_update_bits(engine->regs, SUN4I_BACKEND_MODCTL_REG,\n\t\t\t   SUN4I_BACKEND_MODCTL_ITLMOD_EN,\n\t\t\t   interlaced ? SUN4I_BACKEND_MODCTL_ITLMOD_EN : 0);\n\n\tDRM_DEBUG_DRIVER(\"Switching display backend interlaced mode %s\\n\",\n\t\t\t interlaced ? \"on\" : \"off\");\n}\n\nstatic int sun4i_backend_init_sat(struct device *dev) {\n\tstruct sun4i_backend *backend = dev_get_drvdata(dev);\n\tint ret;\n\n\tbackend->sat_reset = devm_reset_control_get(dev, \"sat\");\n\tif (IS_ERR(backend->sat_reset)) {\n\t\tdev_err(dev, \"Couldn't get the SAT reset line\\n\");\n\t\treturn PTR_ERR(backend->sat_reset);\n\t}\n\n\tret = reset_control_deassert(backend->sat_reset);\n\tif (ret) {\n\t\tdev_err(dev, \"Couldn't deassert the SAT reset line\\n\");\n\t\treturn ret;\n\t}\n\n\tbackend->sat_clk = devm_clk_get(dev, \"sat\");\n\tif (IS_ERR(backend->sat_clk)) {\n\t\tdev_err(dev, \"Couldn't get our SAT clock\\n\");\n\t\tret = PTR_ERR(backend->sat_clk);\n\t\tgoto err_assert_reset;\n\t}\n\n\tret = clk_prepare_enable(backend->sat_clk);\n\tif (ret) {\n\t\tdev_err(dev, \"Couldn't enable the SAT clock\\n\");\n\t\treturn ret;\n\t}\n\n\treturn 0;\n\nerr_assert_reset:\n\treset_control_assert(backend->sat_reset);\n\treturn ret;\n}\n\nstatic int sun4i_backend_free_sat(struct device *dev) {\n\tstruct sun4i_backend *backend = dev_get_drvdata(dev);\n\n\tclk_disable_unprepare(backend->sat_clk);\n\treset_control_assert(backend->sat_reset);\n\n\treturn 0;\n}\n\n \nstatic int sun4i_backend_of_get_id(struct device_node *node)\n{\n\tstruct device_node *ep, *remote;\n\tstruct of_endpoint of_ep;\n\n\t \n\tep = of_graph_get_endpoint_by_regs(node, 0, -1);\n\tif (!ep)\n\t\treturn -EINVAL;\n\n\tremote = of_graph_get_remote_endpoint(ep);\n\tof_node_put(ep);\n\tif (!remote)\n\t\treturn -EINVAL;\n\n\tof_graph_parse_endpoint(remote, &of_ep);\n\tof_node_put(remote);\n\treturn of_ep.id;\n}\n\n \nstatic struct sun4i_frontend *sun4i_backend_find_frontend(struct sun4i_drv *drv,\n\t\t\t\t\t\t\t  struct device_node *node)\n{\n\tstruct device_node *port, *ep, *remote;\n\tstruct sun4i_frontend *frontend;\n\n\tport = of_graph_get_port_by_id(node, 0);\n\tif (!port)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tfor_each_available_child_of_node(port, ep) {\n\t\tremote = of_graph_get_remote_port_parent(ep);\n\t\tif (!remote)\n\t\t\tcontinue;\n\t\tof_node_put(remote);\n\n\t\t \n\t\tlist_for_each_entry(frontend, &drv->frontend_list, list) {\n\t\t\tif (remote == frontend->node) {\n\t\t\t\tof_node_put(port);\n\t\t\t\tof_node_put(ep);\n\t\t\t\treturn frontend;\n\t\t\t}\n\t\t}\n\t}\n\tof_node_put(port);\n\treturn ERR_PTR(-EINVAL);\n}\n\nstatic const struct sunxi_engine_ops sun4i_backend_engine_ops = {\n\t.atomic_begin\t\t\t= sun4i_backend_atomic_begin,\n\t.atomic_check\t\t\t= sun4i_backend_atomic_check,\n\t.commit\t\t\t\t= sun4i_backend_commit,\n\t.layers_init\t\t\t= sun4i_layers_init,\n\t.apply_color_correction\t\t= sun4i_backend_apply_color_correction,\n\t.disable_color_correction\t= sun4i_backend_disable_color_correction,\n\t.vblank_quirk\t\t\t= sun4i_backend_vblank_quirk,\n\t.mode_set\t\t\t= sun4i_backend_mode_set,\n};\n\nstatic const struct regmap_config sun4i_backend_regmap_config = {\n\t.reg_bits\t= 32,\n\t.val_bits\t= 32,\n\t.reg_stride\t= 4,\n\t.max_register\t= 0x5800,\n};\n\nstatic int sun4i_backend_bind(struct device *dev, struct device *master,\n\t\t\t      void *data)\n{\n\tstruct platform_device *pdev = to_platform_device(dev);\n\tstruct drm_device *drm = data;\n\tstruct sun4i_drv *drv = drm->dev_private;\n\tstruct sun4i_backend *backend;\n\tconst struct sun4i_backend_quirks *quirks;\n\tvoid __iomem *regs;\n\tint i, ret;\n\n\tbackend = devm_kzalloc(dev, sizeof(*backend), GFP_KERNEL);\n\tif (!backend)\n\t\treturn -ENOMEM;\n\tdev_set_drvdata(dev, backend);\n\tspin_lock_init(&backend->frontend_lock);\n\n\tif (of_property_present(dev->of_node, \"interconnects\")) {\n\t\t \n\t\tret = of_dma_configure(drm->dev, dev->of_node, true);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tbackend->engine.node = dev->of_node;\n\tbackend->engine.ops = &sun4i_backend_engine_ops;\n\tbackend->engine.id = sun4i_backend_of_get_id(dev->of_node);\n\tif (backend->engine.id < 0)\n\t\treturn backend->engine.id;\n\n\tbackend->frontend = sun4i_backend_find_frontend(drv, dev->of_node);\n\tif (IS_ERR(backend->frontend))\n\t\tdev_warn(dev, \"Couldn't find matching frontend, frontend features disabled\\n\");\n\n\tregs = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(regs))\n\t\treturn PTR_ERR(regs);\n\n\tbackend->reset = devm_reset_control_get(dev, NULL);\n\tif (IS_ERR(backend->reset)) {\n\t\tdev_err(dev, \"Couldn't get our reset line\\n\");\n\t\treturn PTR_ERR(backend->reset);\n\t}\n\n\tret = reset_control_deassert(backend->reset);\n\tif (ret) {\n\t\tdev_err(dev, \"Couldn't deassert our reset line\\n\");\n\t\treturn ret;\n\t}\n\n\tbackend->bus_clk = devm_clk_get(dev, \"ahb\");\n\tif (IS_ERR(backend->bus_clk)) {\n\t\tdev_err(dev, \"Couldn't get the backend bus clock\\n\");\n\t\tret = PTR_ERR(backend->bus_clk);\n\t\tgoto err_assert_reset;\n\t}\n\tclk_prepare_enable(backend->bus_clk);\n\n\tbackend->mod_clk = devm_clk_get(dev, \"mod\");\n\tif (IS_ERR(backend->mod_clk)) {\n\t\tdev_err(dev, \"Couldn't get the backend module clock\\n\");\n\t\tret = PTR_ERR(backend->mod_clk);\n\t\tgoto err_disable_bus_clk;\n\t}\n\n\tret = clk_set_rate_exclusive(backend->mod_clk, 300000000);\n\tif (ret) {\n\t\tdev_err(dev, \"Couldn't set the module clock frequency\\n\");\n\t\tgoto err_disable_bus_clk;\n\t}\n\n\tclk_prepare_enable(backend->mod_clk);\n\n\tbackend->ram_clk = devm_clk_get(dev, \"ram\");\n\tif (IS_ERR(backend->ram_clk)) {\n\t\tdev_err(dev, \"Couldn't get the backend RAM clock\\n\");\n\t\tret = PTR_ERR(backend->ram_clk);\n\t\tgoto err_disable_mod_clk;\n\t}\n\tclk_prepare_enable(backend->ram_clk);\n\n\tif (of_device_is_compatible(dev->of_node,\n\t\t\t\t    \"allwinner,sun8i-a33-display-backend\")) {\n\t\tret = sun4i_backend_init_sat(dev);\n\t\tif (ret) {\n\t\t\tdev_err(dev, \"Couldn't init SAT resources\\n\");\n\t\t\tgoto err_disable_ram_clk;\n\t\t}\n\t}\n\n\tbackend->engine.regs = devm_regmap_init_mmio(dev, regs,\n\t\t\t\t\t\t     &sun4i_backend_regmap_config);\n\tif (IS_ERR(backend->engine.regs)) {\n\t\tdev_err(dev, \"Couldn't create the backend regmap\\n\");\n\t\treturn PTR_ERR(backend->engine.regs);\n\t}\n\n\tlist_add_tail(&backend->engine.list, &drv->engine_list);\n\n\t \n\tfor (i = 0x800; i < 0x1000; i += 4)\n\t\tregmap_write(backend->engine.regs, i, 0);\n\n\t \n\tregmap_write(backend->engine.regs, SUN4I_BACKEND_REGBUFFCTL_REG,\n\t\t     SUN4I_BACKEND_REGBUFFCTL_AUTOLOAD_DIS);\n\n\t \n\tregmap_write(backend->engine.regs, SUN4I_BACKEND_MODCTL_REG,\n\t\t     SUN4I_BACKEND_MODCTL_DEBE_EN |\n\t\t     SUN4I_BACKEND_MODCTL_START_CTL);\n\n\t \n\tquirks = of_device_get_match_data(dev);\n\tif (quirks->needs_output_muxing) {\n\t\t \n\t\tregmap_update_bits(backend->engine.regs,\n\t\t\t\t   SUN4I_BACKEND_MODCTL_REG,\n\t\t\t\t   SUN4I_BACKEND_MODCTL_OUT_SEL,\n\t\t\t\t   (backend->engine.id\n\t\t\t\t    ? SUN4I_BACKEND_MODCTL_OUT_LCD1\n\t\t\t\t    : SUN4I_BACKEND_MODCTL_OUT_LCD0));\n\t}\n\n\tbackend->quirks = quirks;\n\n\treturn 0;\n\nerr_disable_ram_clk:\n\tclk_disable_unprepare(backend->ram_clk);\nerr_disable_mod_clk:\n\tclk_rate_exclusive_put(backend->mod_clk);\n\tclk_disable_unprepare(backend->mod_clk);\nerr_disable_bus_clk:\n\tclk_disable_unprepare(backend->bus_clk);\nerr_assert_reset:\n\treset_control_assert(backend->reset);\n\treturn ret;\n}\n\nstatic void sun4i_backend_unbind(struct device *dev, struct device *master,\n\t\t\t\t void *data)\n{\n\tstruct sun4i_backend *backend = dev_get_drvdata(dev);\n\n\tlist_del(&backend->engine.list);\n\n\tif (of_device_is_compatible(dev->of_node,\n\t\t\t\t    \"allwinner,sun8i-a33-display-backend\"))\n\t\tsun4i_backend_free_sat(dev);\n\n\tclk_disable_unprepare(backend->ram_clk);\n\tclk_rate_exclusive_put(backend->mod_clk);\n\tclk_disable_unprepare(backend->mod_clk);\n\tclk_disable_unprepare(backend->bus_clk);\n\treset_control_assert(backend->reset);\n}\n\nstatic const struct component_ops sun4i_backend_ops = {\n\t.bind\t= sun4i_backend_bind,\n\t.unbind\t= sun4i_backend_unbind,\n};\n\nstatic int sun4i_backend_probe(struct platform_device *pdev)\n{\n\treturn component_add(&pdev->dev, &sun4i_backend_ops);\n}\n\nstatic void sun4i_backend_remove(struct platform_device *pdev)\n{\n\tcomponent_del(&pdev->dev, &sun4i_backend_ops);\n}\n\nstatic const struct sun4i_backend_quirks sun4i_backend_quirks = {\n\t.needs_output_muxing = true,\n};\n\nstatic const struct sun4i_backend_quirks sun5i_backend_quirks = {\n};\n\nstatic const struct sun4i_backend_quirks sun6i_backend_quirks = {\n};\n\nstatic const struct sun4i_backend_quirks sun7i_backend_quirks = {\n\t.needs_output_muxing = true,\n};\n\nstatic const struct sun4i_backend_quirks sun8i_a33_backend_quirks = {\n\t.supports_lowest_plane_alpha = true,\n};\n\nstatic const struct sun4i_backend_quirks sun9i_backend_quirks = {\n};\n\nstatic const struct of_device_id sun4i_backend_of_table[] = {\n\t{\n\t\t.compatible = \"allwinner,sun4i-a10-display-backend\",\n\t\t.data = &sun4i_backend_quirks,\n\t},\n\t{\n\t\t.compatible = \"allwinner,sun5i-a13-display-backend\",\n\t\t.data = &sun5i_backend_quirks,\n\t},\n\t{\n\t\t.compatible = \"allwinner,sun6i-a31-display-backend\",\n\t\t.data = &sun6i_backend_quirks,\n\t},\n\t{\n\t\t.compatible = \"allwinner,sun7i-a20-display-backend\",\n\t\t.data = &sun7i_backend_quirks,\n\t},\n\t{\n\t\t.compatible = \"allwinner,sun8i-a23-display-backend\",\n\t\t.data = &sun8i_a33_backend_quirks,\n\t},\n\t{\n\t\t.compatible = \"allwinner,sun8i-a33-display-backend\",\n\t\t.data = &sun8i_a33_backend_quirks,\n\t},\n\t{\n\t\t.compatible = \"allwinner,sun9i-a80-display-backend\",\n\t\t.data = &sun9i_backend_quirks,\n\t},\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, sun4i_backend_of_table);\n\nstatic struct platform_driver sun4i_backend_platform_driver = {\n\t.probe\t\t= sun4i_backend_probe,\n\t.remove_new\t= sun4i_backend_remove,\n\t.driver\t\t= {\n\t\t.name\t\t= \"sun4i-backend\",\n\t\t.of_match_table\t= sun4i_backend_of_table,\n\t},\n};\nmodule_platform_driver(sun4i_backend_platform_driver);\n\nMODULE_AUTHOR(\"Maxime Ripard <maxime.ripard@free-electrons.com>\");\nMODULE_DESCRIPTION(\"Allwinner A10 Display Backend Driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}