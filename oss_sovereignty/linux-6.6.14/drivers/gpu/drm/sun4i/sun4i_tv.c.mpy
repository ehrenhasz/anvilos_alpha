{
  "module_name": "sun4i_tv.c",
  "hash_id": "15237e0564cd3e6678beaec5d82667b0f5fb657dd3ea2120e580ab6f6f55d878",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/sun4i/sun4i_tv.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/component.h>\n#include <linux/module.h>\n#include <linux/of_address.h>\n#include <linux/platform_device.h>\n#include <linux/regmap.h>\n#include <linux/reset.h>\n\n#include <drm/drm_atomic.h>\n#include <drm/drm_atomic_helper.h>\n#include <drm/drm_of.h>\n#include <drm/drm_panel.h>\n#include <drm/drm_print.h>\n#include <drm/drm_probe_helper.h>\n#include <drm/drm_simple_kms_helper.h>\n\n#include \"sun4i_crtc.h\"\n#include \"sun4i_drv.h\"\n#include \"sunxi_engine.h\"\n\n#define SUN4I_TVE_EN_REG\t\t0x000\n#define SUN4I_TVE_EN_DAC_MAP_MASK\t\tGENMASK(19, 4)\n#define SUN4I_TVE_EN_DAC_MAP(dac, out)\t\t(((out) & 0xf) << (dac + 1) * 4)\n#define SUN4I_TVE_EN_ENABLE\t\t\tBIT(0)\n\n#define SUN4I_TVE_CFG0_REG\t\t0x004\n#define SUN4I_TVE_CFG0_DAC_CONTROL_54M\t\tBIT(26)\n#define SUN4I_TVE_CFG0_CORE_DATAPATH_54M\tBIT(25)\n#define SUN4I_TVE_CFG0_CORE_CONTROL_54M\t\tBIT(24)\n#define SUN4I_TVE_CFG0_YC_EN\t\t\tBIT(17)\n#define SUN4I_TVE_CFG0_COMP_EN\t\t\tBIT(16)\n#define SUN4I_TVE_CFG0_RES(x)\t\t\t((x) & 0xf)\n#define SUN4I_TVE_CFG0_RES_480i\t\t\tSUN4I_TVE_CFG0_RES(0)\n#define SUN4I_TVE_CFG0_RES_576i\t\t\tSUN4I_TVE_CFG0_RES(1)\n\n#define SUN4I_TVE_DAC0_REG\t\t0x008\n#define SUN4I_TVE_DAC0_CLOCK_INVERT\t\tBIT(24)\n#define SUN4I_TVE_DAC0_LUMA(x)\t\t\t(((x) & 3) << 20)\n#define SUN4I_TVE_DAC0_LUMA_0_4\t\t\tSUN4I_TVE_DAC0_LUMA(3)\n#define SUN4I_TVE_DAC0_CHROMA(x)\t\t(((x) & 3) << 18)\n#define SUN4I_TVE_DAC0_CHROMA_0_75\t\tSUN4I_TVE_DAC0_CHROMA(3)\n#define SUN4I_TVE_DAC0_INTERNAL_DAC(x)\t\t(((x) & 3) << 16)\n#define SUN4I_TVE_DAC0_INTERNAL_DAC_37_5_OHMS\tSUN4I_TVE_DAC0_INTERNAL_DAC(3)\n#define SUN4I_TVE_DAC0_DAC_EN(dac)\t\tBIT(dac)\n\n#define SUN4I_TVE_NOTCH_REG\t\t0x00c\n#define SUN4I_TVE_NOTCH_DAC0_TO_DAC_DLY(dac, x)\t((4 - (x)) << (dac * 3))\n\n#define SUN4I_TVE_CHROMA_FREQ_REG\t0x010\n\n#define SUN4I_TVE_PORCH_REG\t\t0x014\n#define SUN4I_TVE_PORCH_BACK(x)\t\t\t((x) << 16)\n#define SUN4I_TVE_PORCH_FRONT(x)\t\t(x)\n\n#define SUN4I_TVE_LINE_REG\t\t0x01c\n#define SUN4I_TVE_LINE_FIRST(x)\t\t\t((x) << 16)\n#define SUN4I_TVE_LINE_NUMBER(x)\t\t(x)\n\n#define SUN4I_TVE_LEVEL_REG\t\t0x020\n#define SUN4I_TVE_LEVEL_BLANK(x)\t\t((x) << 16)\n#define SUN4I_TVE_LEVEL_BLACK(x)\t\t(x)\n\n#define SUN4I_TVE_DAC1_REG\t\t0x024\n#define SUN4I_TVE_DAC1_AMPLITUDE(dac, x)\t((x) << (dac * 8))\n\n#define SUN4I_TVE_DETECT_STA_REG\t0x038\n#define SUN4I_TVE_DETECT_STA_DAC(dac)\t\tBIT((dac * 8))\n#define SUN4I_TVE_DETECT_STA_UNCONNECTED\t\t0\n#define SUN4I_TVE_DETECT_STA_CONNECTED\t\t\t1\n#define SUN4I_TVE_DETECT_STA_GROUND\t\t\t2\n\n#define SUN4I_TVE_CB_CR_LVL_REG\t\t0x10c\n#define SUN4I_TVE_CB_CR_LVL_CR_BURST(x)\t\t((x) << 8)\n#define SUN4I_TVE_CB_CR_LVL_CB_BURST(x)\t\t(x)\n\n#define SUN4I_TVE_TINT_BURST_PHASE_REG\t0x110\n#define SUN4I_TVE_TINT_BURST_PHASE_CHROMA(x)\t(x)\n\n#define SUN4I_TVE_BURST_WIDTH_REG\t0x114\n#define SUN4I_TVE_BURST_WIDTH_BREEZEWAY(x)\t((x) << 16)\n#define SUN4I_TVE_BURST_WIDTH_BURST_WIDTH(x)\t((x) << 8)\n#define SUN4I_TVE_BURST_WIDTH_HSYNC_WIDTH(x)\t(x)\n\n#define SUN4I_TVE_CB_CR_GAIN_REG\t0x118\n#define SUN4I_TVE_CB_CR_GAIN_CR(x)\t\t((x) << 8)\n#define SUN4I_TVE_CB_CR_GAIN_CB(x)\t\t(x)\n\n#define SUN4I_TVE_SYNC_VBI_REG\t\t0x11c\n#define SUN4I_TVE_SYNC_VBI_SYNC(x)\t\t((x) << 16)\n#define SUN4I_TVE_SYNC_VBI_VBLANK(x)\t\t(x)\n\n#define SUN4I_TVE_ACTIVE_LINE_REG\t0x124\n#define SUN4I_TVE_ACTIVE_LINE(x)\t\t(x)\n\n#define SUN4I_TVE_CHROMA_REG\t\t0x128\n#define SUN4I_TVE_CHROMA_COMP_GAIN(x)\t\t((x) & 3)\n#define SUN4I_TVE_CHROMA_COMP_GAIN_50\t\tSUN4I_TVE_CHROMA_COMP_GAIN(2)\n\n#define SUN4I_TVE_12C_REG\t\t0x12c\n#define SUN4I_TVE_12C_NOTCH_WIDTH_WIDE\t\tBIT(8)\n#define SUN4I_TVE_12C_COMP_YUV_EN\t\tBIT(0)\n\n#define SUN4I_TVE_RESYNC_REG\t\t0x130\n#define SUN4I_TVE_RESYNC_FIELD\t\t\tBIT(31)\n#define SUN4I_TVE_RESYNC_LINE(x)\t\t((x) << 16)\n#define SUN4I_TVE_RESYNC_PIXEL(x)\t\t(x)\n\n#define SUN4I_TVE_SLAVE_REG\t\t0x134\n\n#define SUN4I_TVE_WSS_DATA2_REG\t\t0x244\n\nstruct color_gains {\n\tu16\tcb;\n\tu16\tcr;\n};\n\nstruct burst_levels {\n\tu16\tcb;\n\tu16\tcr;\n};\n\nstruct video_levels {\n\tu16\tblack;\n\tu16\tblank;\n};\n\nstruct resync_parameters {\n\tbool\tfield;\n\tu16\tline;\n\tu16\tpixel;\n};\n\nstruct tv_mode {\n\tchar\t\t*name;\n\n\tunsigned int\ttv_mode;\n\n\tu32\t\tmode;\n\tu32\t\tchroma_freq;\n\tu16\t\tback_porch;\n\tu16\t\tfront_porch;\n\tu16\t\tvblank_level;\n\n\tbool\t\tyc_en;\n\tbool\t\tdac3_en;\n\tbool\t\tdac_bit25_en;\n\n\tconst struct color_gains\t*color_gains;\n\tconst struct burst_levels\t*burst_levels;\n\tconst struct video_levels\t*video_levels;\n\tconst struct resync_parameters\t*resync_params;\n};\n\nstruct sun4i_tv {\n\tstruct drm_connector\tconnector;\n\tstruct drm_encoder\tencoder;\n\n\tstruct clk\t\t*clk;\n\tstruct regmap\t\t*regs;\n\tstruct reset_control\t*reset;\n\n\tstruct sun4i_drv\t*drv;\n};\n\nstatic const struct video_levels ntsc_video_levels = {\n\t.black = 282,\t.blank = 240,\n};\n\nstatic const struct video_levels pal_video_levels = {\n\t.black = 252,\t.blank = 252,\n};\n\nstatic const struct burst_levels ntsc_burst_levels = {\n\t.cb = 79,\t.cr = 0,\n};\n\nstatic const struct burst_levels pal_burst_levels = {\n\t.cb = 40,\t.cr = 40,\n};\n\nstatic const struct color_gains ntsc_color_gains = {\n\t.cb = 160,\t.cr = 160,\n};\n\nstatic const struct color_gains pal_color_gains = {\n\t.cb = 224,\t.cr = 224,\n};\n\nstatic const struct resync_parameters ntsc_resync_parameters = {\n\t.field = false,\t.line = 14,\t.pixel = 12,\n};\n\nstatic const struct resync_parameters pal_resync_parameters = {\n\t.field = true,\t.line = 13,\t.pixel = 12,\n};\n\nstatic const struct tv_mode tv_modes[] = {\n\t{\n\t\t.tv_mode\t= DRM_MODE_TV_MODE_NTSC,\n\t\t.mode\t\t= SUN4I_TVE_CFG0_RES_480i,\n\t\t.chroma_freq\t= 0x21f07c1f,\n\t\t.yc_en\t\t= true,\n\t\t.dac3_en\t= true,\n\t\t.dac_bit25_en\t= true,\n\n\t\t.back_porch\t= 118,\n\t\t.front_porch\t= 32,\n\n\t\t.vblank_level\t= 240,\n\n\t\t.color_gains\t= &ntsc_color_gains,\n\t\t.burst_levels\t= &ntsc_burst_levels,\n\t\t.video_levels\t= &ntsc_video_levels,\n\t\t.resync_params\t= &ntsc_resync_parameters,\n\t},\n\t{\n\t\t.tv_mode\t= DRM_MODE_TV_MODE_PAL,\n\t\t.mode\t\t= SUN4I_TVE_CFG0_RES_576i,\n\t\t.chroma_freq\t= 0x2a098acb,\n\n\t\t.back_porch\t= 138,\n\t\t.front_porch\t= 24,\n\n\t\t.vblank_level\t= 252,\n\n\t\t.color_gains\t= &pal_color_gains,\n\t\t.burst_levels\t= &pal_burst_levels,\n\t\t.video_levels\t= &pal_video_levels,\n\t\t.resync_params\t= &pal_resync_parameters,\n\t},\n};\n\nstatic inline struct sun4i_tv *\ndrm_encoder_to_sun4i_tv(struct drm_encoder *encoder)\n{\n\treturn container_of(encoder, struct sun4i_tv,\n\t\t\t    encoder);\n}\n\nstatic const struct tv_mode *\nsun4i_tv_find_tv_by_mode(unsigned int mode)\n{\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(tv_modes); i++) {\n\t\tconst struct tv_mode *tv_mode = &tv_modes[i];\n\n\t\tif (tv_mode->tv_mode == mode)\n\t\t\treturn tv_mode;\n\t}\n\n\treturn NULL;\n}\n\nstatic void sun4i_tv_disable(struct drm_encoder *encoder,\n\t\t\t    struct drm_atomic_state *state)\n{\n\tstruct sun4i_tv *tv = drm_encoder_to_sun4i_tv(encoder);\n\tstruct sun4i_crtc *crtc = drm_crtc_to_sun4i_crtc(encoder->crtc);\n\n\tDRM_DEBUG_DRIVER(\"Disabling the TV Output\\n\");\n\n\tregmap_update_bits(tv->regs, SUN4I_TVE_EN_REG,\n\t\t\t   SUN4I_TVE_EN_ENABLE,\n\t\t\t   0);\n\n\tsunxi_engine_disable_color_correction(crtc->engine);\n}\n\nstatic void sun4i_tv_enable(struct drm_encoder *encoder,\n\t\t\t    struct drm_atomic_state *state)\n{\n\tstruct sun4i_tv *tv = drm_encoder_to_sun4i_tv(encoder);\n\tstruct sun4i_crtc *crtc = drm_crtc_to_sun4i_crtc(encoder->crtc);\n\tstruct drm_crtc_state *crtc_state =\n\t\tdrm_atomic_get_new_crtc_state(state, encoder->crtc);\n\tstruct drm_display_mode *mode = &crtc_state->mode;\n\tstruct drm_connector *connector = &tv->connector;\n\tstruct drm_connector_state *conn_state =\n\t\tdrm_atomic_get_new_connector_state(state, connector);\n\tconst struct tv_mode *tv_mode =\n\t\tsun4i_tv_find_tv_by_mode(conn_state->tv.mode);\n\n\tDRM_DEBUG_DRIVER(\"Enabling the TV Output\\n\");\n\n\t \n\tregmap_update_bits(tv->regs, SUN4I_TVE_EN_REG,\n\t\t\t   SUN4I_TVE_EN_DAC_MAP_MASK,\n\t\t\t   SUN4I_TVE_EN_DAC_MAP(0, 1) |\n\t\t\t   SUN4I_TVE_EN_DAC_MAP(1, 2) |\n\t\t\t   SUN4I_TVE_EN_DAC_MAP(2, 3) |\n\t\t\t   SUN4I_TVE_EN_DAC_MAP(3, 4));\n\n\t \n\tregmap_write(tv->regs, SUN4I_TVE_CFG0_REG,\n\t\t     tv_mode->mode |\n\t\t     (tv_mode->yc_en ? SUN4I_TVE_CFG0_YC_EN : 0) |\n\t\t     SUN4I_TVE_CFG0_COMP_EN |\n\t\t     SUN4I_TVE_CFG0_DAC_CONTROL_54M |\n\t\t     SUN4I_TVE_CFG0_CORE_DATAPATH_54M |\n\t\t     SUN4I_TVE_CFG0_CORE_CONTROL_54M);\n\n\t \n\tregmap_write(tv->regs, SUN4I_TVE_DAC0_REG,\n\t\t     SUN4I_TVE_DAC0_DAC_EN(0) |\n\t\t     (tv_mode->dac3_en ? SUN4I_TVE_DAC0_DAC_EN(3) : 0) |\n\t\t     SUN4I_TVE_DAC0_INTERNAL_DAC_37_5_OHMS |\n\t\t     SUN4I_TVE_DAC0_CHROMA_0_75 |\n\t\t     SUN4I_TVE_DAC0_LUMA_0_4 |\n\t\t     SUN4I_TVE_DAC0_CLOCK_INVERT |\n\t\t     (tv_mode->dac_bit25_en ? BIT(25) : 0) |\n\t\t     BIT(30));\n\n\t \n\tregmap_write(tv->regs, SUN4I_TVE_NOTCH_REG,\n\t\t     SUN4I_TVE_NOTCH_DAC0_TO_DAC_DLY(1, 0) |\n\t\t     SUN4I_TVE_NOTCH_DAC0_TO_DAC_DLY(2, 0));\n\n\tregmap_write(tv->regs, SUN4I_TVE_CHROMA_FREQ_REG,\n\t\t     tv_mode->chroma_freq);\n\n\t \n\tregmap_write(tv->regs, SUN4I_TVE_PORCH_REG,\n\t\t     SUN4I_TVE_PORCH_BACK(tv_mode->back_porch) |\n\t\t     SUN4I_TVE_PORCH_FRONT(tv_mode->front_porch));\n\n\t \n\tregmap_write(tv->regs, SUN4I_TVE_LINE_REG,\n\t\t     SUN4I_TVE_LINE_FIRST(22) |\n\t\t     SUN4I_TVE_LINE_NUMBER(mode->vtotal));\n\n\tregmap_write(tv->regs, SUN4I_TVE_LEVEL_REG,\n\t\t     SUN4I_TVE_LEVEL_BLANK(tv_mode->video_levels->blank) |\n\t\t     SUN4I_TVE_LEVEL_BLACK(tv_mode->video_levels->black));\n\n\tregmap_write(tv->regs, SUN4I_TVE_DAC1_REG,\n\t\t     SUN4I_TVE_DAC1_AMPLITUDE(0, 0x18) |\n\t\t     SUN4I_TVE_DAC1_AMPLITUDE(1, 0x18) |\n\t\t     SUN4I_TVE_DAC1_AMPLITUDE(2, 0x18) |\n\t\t     SUN4I_TVE_DAC1_AMPLITUDE(3, 0x18));\n\n\tregmap_write(tv->regs, SUN4I_TVE_CB_CR_LVL_REG,\n\t\t     SUN4I_TVE_CB_CR_LVL_CB_BURST(tv_mode->burst_levels->cb) |\n\t\t     SUN4I_TVE_CB_CR_LVL_CR_BURST(tv_mode->burst_levels->cr));\n\n\t \n\tregmap_write(tv->regs, SUN4I_TVE_BURST_WIDTH_REG,\n\t\t     SUN4I_TVE_BURST_WIDTH_HSYNC_WIDTH(126) |\n\t\t     SUN4I_TVE_BURST_WIDTH_BURST_WIDTH(68) |\n\t\t     SUN4I_TVE_BURST_WIDTH_BREEZEWAY(22));\n\n\tregmap_write(tv->regs, SUN4I_TVE_CB_CR_GAIN_REG,\n\t\t     SUN4I_TVE_CB_CR_GAIN_CB(tv_mode->color_gains->cb) |\n\t\t     SUN4I_TVE_CB_CR_GAIN_CR(tv_mode->color_gains->cr));\n\n\tregmap_write(tv->regs, SUN4I_TVE_SYNC_VBI_REG,\n\t\t     SUN4I_TVE_SYNC_VBI_SYNC(0x10) |\n\t\t     SUN4I_TVE_SYNC_VBI_VBLANK(tv_mode->vblank_level));\n\n\tregmap_write(tv->regs, SUN4I_TVE_ACTIVE_LINE_REG,\n\t\t     SUN4I_TVE_ACTIVE_LINE(1440));\n\n\t \n\tregmap_write(tv->regs, SUN4I_TVE_CHROMA_REG,\n\t\t     SUN4I_TVE_CHROMA_COMP_GAIN_50);\n\n\tregmap_write(tv->regs, SUN4I_TVE_12C_REG,\n\t\t     SUN4I_TVE_12C_COMP_YUV_EN |\n\t\t     SUN4I_TVE_12C_NOTCH_WIDTH_WIDE);\n\n\tregmap_write(tv->regs, SUN4I_TVE_RESYNC_REG,\n\t\t     SUN4I_TVE_RESYNC_PIXEL(tv_mode->resync_params->pixel) |\n\t\t     SUN4I_TVE_RESYNC_LINE(tv_mode->resync_params->line) |\n\t\t     (tv_mode->resync_params->field ?\n\t\t      SUN4I_TVE_RESYNC_FIELD : 0));\n\n\tregmap_write(tv->regs, SUN4I_TVE_SLAVE_REG, 0);\n\n\tsunxi_engine_apply_color_correction(crtc->engine);\n\n\tregmap_update_bits(tv->regs, SUN4I_TVE_EN_REG,\n\t\t\t   SUN4I_TVE_EN_ENABLE,\n\t\t\t   SUN4I_TVE_EN_ENABLE);\n}\n\nstatic const struct drm_encoder_helper_funcs sun4i_tv_helper_funcs = {\n\t.atomic_disable\t= sun4i_tv_disable,\n\t.atomic_enable\t= sun4i_tv_enable,\n};\n\nstatic const struct drm_connector_helper_funcs sun4i_tv_comp_connector_helper_funcs = {\n\t.atomic_check\t= drm_atomic_helper_connector_tv_check,\n\t.get_modes\t= drm_connector_helper_tv_get_modes,\n};\n\nstatic void sun4i_tv_connector_reset(struct drm_connector *connector)\n{\n\tdrm_atomic_helper_connector_reset(connector);\n\tdrm_atomic_helper_connector_tv_reset(connector);\n}\n\nstatic const struct drm_connector_funcs sun4i_tv_comp_connector_funcs = {\n\t.fill_modes\t\t= drm_helper_probe_single_connector_modes,\n\t.destroy\t\t= drm_connector_cleanup,\n\t.reset\t\t\t= sun4i_tv_connector_reset,\n\t.atomic_duplicate_state\t= drm_atomic_helper_connector_duplicate_state,\n\t.atomic_destroy_state\t= drm_atomic_helper_connector_destroy_state,\n};\n\nstatic const struct regmap_config sun4i_tv_regmap_config = {\n\t.reg_bits\t= 32,\n\t.val_bits\t= 32,\n\t.reg_stride\t= 4,\n\t.max_register\t= SUN4I_TVE_WSS_DATA2_REG,\n\t.name\t\t= \"tv-encoder\",\n};\n\nstatic int sun4i_tv_bind(struct device *dev, struct device *master,\n\t\t\t void *data)\n{\n\tstruct platform_device *pdev = to_platform_device(dev);\n\tstruct drm_device *drm = data;\n\tstruct sun4i_drv *drv = drm->dev_private;\n\tstruct sun4i_tv *tv;\n\tvoid __iomem *regs;\n\tint ret;\n\n\ttv = devm_kzalloc(dev, sizeof(*tv), GFP_KERNEL);\n\tif (!tv)\n\t\treturn -ENOMEM;\n\ttv->drv = drv;\n\tdev_set_drvdata(dev, tv);\n\n\tregs = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(regs)) {\n\t\tdev_err(dev, \"Couldn't map the TV encoder registers\\n\");\n\t\treturn PTR_ERR(regs);\n\t}\n\n\ttv->regs = devm_regmap_init_mmio(dev, regs,\n\t\t\t\t\t &sun4i_tv_regmap_config);\n\tif (IS_ERR(tv->regs)) {\n\t\tdev_err(dev, \"Couldn't create the TV encoder regmap\\n\");\n\t\treturn PTR_ERR(tv->regs);\n\t}\n\n\ttv->reset = devm_reset_control_get(dev, NULL);\n\tif (IS_ERR(tv->reset)) {\n\t\tdev_err(dev, \"Couldn't get our reset line\\n\");\n\t\treturn PTR_ERR(tv->reset);\n\t}\n\n\tret = reset_control_deassert(tv->reset);\n\tif (ret) {\n\t\tdev_err(dev, \"Couldn't deassert our reset line\\n\");\n\t\treturn ret;\n\t}\n\n\ttv->clk = devm_clk_get(dev, NULL);\n\tif (IS_ERR(tv->clk)) {\n\t\tdev_err(dev, \"Couldn't get the TV encoder clock\\n\");\n\t\tret = PTR_ERR(tv->clk);\n\t\tgoto err_assert_reset;\n\t}\n\tclk_prepare_enable(tv->clk);\n\n\tdrm_encoder_helper_add(&tv->encoder,\n\t\t\t       &sun4i_tv_helper_funcs);\n\tret = drm_simple_encoder_init(drm, &tv->encoder,\n\t\t\t\t      DRM_MODE_ENCODER_TVDAC);\n\tif (ret) {\n\t\tdev_err(dev, \"Couldn't initialise the TV encoder\\n\");\n\t\tgoto err_disable_clk;\n\t}\n\n\ttv->encoder.possible_crtcs = drm_of_find_possible_crtcs(drm,\n\t\t\t\t\t\t\t\tdev->of_node);\n\tif (!tv->encoder.possible_crtcs) {\n\t\tret = -EPROBE_DEFER;\n\t\tgoto err_disable_clk;\n\t}\n\n\tdrm_connector_helper_add(&tv->connector,\n\t\t\t\t &sun4i_tv_comp_connector_helper_funcs);\n\tret = drm_connector_init(drm, &tv->connector,\n\t\t\t\t &sun4i_tv_comp_connector_funcs,\n\t\t\t\t DRM_MODE_CONNECTOR_Composite);\n\tif (ret) {\n\t\tdev_err(dev,\n\t\t\t\"Couldn't initialise the Composite connector\\n\");\n\t\tgoto err_cleanup_encoder;\n\t}\n\ttv->connector.interlace_allowed = true;\n\n\tdrm_connector_attach_encoder(&tv->connector, &tv->encoder);\n\n\tret = drm_mode_create_tv_properties(drm,\n\t\t\t\t\t    BIT(DRM_MODE_TV_MODE_NTSC) |\n\t\t\t\t\t    BIT(DRM_MODE_TV_MODE_PAL));\n\tif (ret)\n\t\tgoto err_cleanup_connector;\n\n\tdrm_object_attach_property(&tv->connector.base,\n\t\t\t\t   drm->mode_config.tv_mode_property,\n\t\t\t\t   DRM_MODE_TV_MODE_NTSC);\n\n\treturn 0;\n\nerr_cleanup_connector:\n\tdrm_connector_cleanup(&tv->connector);\nerr_cleanup_encoder:\n\tdrm_encoder_cleanup(&tv->encoder);\nerr_disable_clk:\n\tclk_disable_unprepare(tv->clk);\nerr_assert_reset:\n\treset_control_assert(tv->reset);\n\treturn ret;\n}\n\nstatic void sun4i_tv_unbind(struct device *dev, struct device *master,\n\t\t\t    void *data)\n{\n\tstruct sun4i_tv *tv = dev_get_drvdata(dev);\n\n\tdrm_connector_cleanup(&tv->connector);\n\tdrm_encoder_cleanup(&tv->encoder);\n\tclk_disable_unprepare(tv->clk);\n\treset_control_assert(tv->reset);\n}\n\nstatic const struct component_ops sun4i_tv_ops = {\n\t.bind\t= sun4i_tv_bind,\n\t.unbind\t= sun4i_tv_unbind,\n};\n\nstatic int sun4i_tv_probe(struct platform_device *pdev)\n{\n\treturn component_add(&pdev->dev, &sun4i_tv_ops);\n}\n\nstatic void sun4i_tv_remove(struct platform_device *pdev)\n{\n\tcomponent_del(&pdev->dev, &sun4i_tv_ops);\n}\n\nstatic const struct of_device_id sun4i_tv_of_table[] = {\n\t{ .compatible = \"allwinner,sun4i-a10-tv-encoder\" },\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, sun4i_tv_of_table);\n\nstatic struct platform_driver sun4i_tv_platform_driver = {\n\t.probe\t\t= sun4i_tv_probe,\n\t.remove_new\t= sun4i_tv_remove,\n\t.driver\t\t= {\n\t\t.name\t\t= \"sun4i-tve\",\n\t\t.of_match_table\t= sun4i_tv_of_table,\n\t},\n};\nmodule_platform_driver(sun4i_tv_platform_driver);\n\nMODULE_AUTHOR(\"Maxime Ripard <maxime.ripard@free-electrons.com>\");\nMODULE_DESCRIPTION(\"Allwinner A10 TV Encoder Driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}