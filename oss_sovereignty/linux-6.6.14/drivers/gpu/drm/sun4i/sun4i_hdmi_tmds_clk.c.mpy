{
  "module_name": "sun4i_hdmi_tmds_clk.c",
  "hash_id": "896f549e09cb709821a755b27f9aa46e27443b1cedf2a34407b43b7cf1135e2b",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/sun4i/sun4i_hdmi_tmds_clk.c",
  "human_readable_source": "\n \n\n#include <linux/clk-provider.h>\n#include <linux/io.h>\n\n#include \"sun4i_hdmi.h\"\n\nstruct sun4i_tmds {\n\tstruct clk_hw\t\thw;\n\tstruct sun4i_hdmi\t*hdmi;\n\n\tu8\t\t\tdiv_offset;\n};\n\nstatic inline struct sun4i_tmds *hw_to_tmds(struct clk_hw *hw)\n{\n\treturn container_of(hw, struct sun4i_tmds, hw);\n}\n\n\nstatic unsigned long sun4i_tmds_calc_divider(unsigned long rate,\n\t\t\t\t\t     unsigned long parent_rate,\n\t\t\t\t\t     u8 div_offset,\n\t\t\t\t\t     u8 *div,\n\t\t\t\t\t     bool *half)\n{\n\tunsigned long best_rate = 0;\n\tu8 best_m = 0, m;\n\tbool is_double = false;\n\n\tfor (m = div_offset ?: 1; m < (16 + div_offset); m++) {\n\t\tu8 d;\n\n\t\tfor (d = 1; d < 3; d++) {\n\t\t\tunsigned long tmp_rate;\n\n\t\t\ttmp_rate = parent_rate / m / d;\n\n\t\t\tif (tmp_rate > rate)\n\t\t\t\tcontinue;\n\n\t\t\tif (!best_rate ||\n\t\t\t    (rate - tmp_rate) < (rate - best_rate)) {\n\t\t\t\tbest_rate = tmp_rate;\n\t\t\t\tbest_m = m;\n\t\t\t\tis_double = (d == 2) ? true : false;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (div && half) {\n\t\t*div = best_m;\n\t\t*half = is_double;\n\t}\n\n\treturn best_rate;\n}\n\n\nstatic int sun4i_tmds_determine_rate(struct clk_hw *hw,\n\t\t\t\t     struct clk_rate_request *req)\n{\n\tstruct sun4i_tmds *tmds = hw_to_tmds(hw);\n\tstruct clk_hw *parent = NULL;\n\tunsigned long best_parent = 0;\n\tunsigned long rate = req->rate;\n\tint best_div = 1, best_half = 1;\n\tint i, j, p;\n\n\t \n\n\tfor (p = 0; p < clk_hw_get_num_parents(hw); p++) {\n\t\tparent = clk_hw_get_parent_by_index(hw, p);\n\t\tif (!parent)\n\t\t\tcontinue;\n\n\t\tfor (i = 1; i < 3; i++) {\n\t\t\tfor (j = tmds->div_offset ?: 1;\n\t\t\t     j < (16 + tmds->div_offset); j++) {\n\t\t\t\tunsigned long ideal = rate * i * j;\n\t\t\t\tunsigned long rounded;\n\n\t\t\t\trounded = clk_hw_round_rate(parent, ideal);\n\n\t\t\t\tif (rounded == ideal) {\n\t\t\t\t\tbest_parent = rounded;\n\t\t\t\t\tbest_half = i;\n\t\t\t\t\tbest_div = j;\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\n\t\t\t\tif (!best_parent ||\n\t\t\t\t    abs(rate - rounded / i / j) <\n\t\t\t\t    abs(rate - best_parent / best_half /\n\t\t\t\t\tbest_div)) {\n\t\t\t\t\tbest_parent = rounded;\n\t\t\t\t\tbest_half = i;\n\t\t\t\t\tbest_div = j;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tif (!parent)\n\t\treturn -EINVAL;\n\nout:\n\treq->rate = best_parent / best_half / best_div;\n\treq->best_parent_rate = best_parent;\n\treq->best_parent_hw = parent;\n\n\treturn 0;\n}\n\nstatic unsigned long sun4i_tmds_recalc_rate(struct clk_hw *hw,\n\t\t\t\t\t    unsigned long parent_rate)\n{\n\tstruct sun4i_tmds *tmds = hw_to_tmds(hw);\n\tu32 reg;\n\n\treg = readl(tmds->hdmi->base + SUN4I_HDMI_PAD_CTRL1_REG);\n\tif (reg & SUN4I_HDMI_PAD_CTRL1_HALVE_CLK)\n\t\tparent_rate /= 2;\n\n\treg = readl(tmds->hdmi->base + SUN4I_HDMI_PLL_CTRL_REG);\n\treg = ((reg >> 4) & 0xf) + tmds->div_offset;\n\tif (!reg)\n\t\treg = 1;\n\n\treturn parent_rate / reg;\n}\n\nstatic int sun4i_tmds_set_rate(struct clk_hw *hw, unsigned long rate,\n\t\t\t       unsigned long parent_rate)\n{\n\tstruct sun4i_tmds *tmds = hw_to_tmds(hw);\n\tbool half;\n\tu32 reg;\n\tu8 div;\n\n\tsun4i_tmds_calc_divider(rate, parent_rate, tmds->div_offset,\n\t\t\t\t&div, &half);\n\n\treg = readl(tmds->hdmi->base + SUN4I_HDMI_PAD_CTRL1_REG);\n\treg &= ~SUN4I_HDMI_PAD_CTRL1_HALVE_CLK;\n\tif (half)\n\t\treg |= SUN4I_HDMI_PAD_CTRL1_HALVE_CLK;\n\twritel(reg, tmds->hdmi->base + SUN4I_HDMI_PAD_CTRL1_REG);\n\n\treg = readl(tmds->hdmi->base + SUN4I_HDMI_PLL_CTRL_REG);\n\treg &= ~SUN4I_HDMI_PLL_CTRL_DIV_MASK;\n\twritel(reg | SUN4I_HDMI_PLL_CTRL_DIV(div - tmds->div_offset),\n\t       tmds->hdmi->base + SUN4I_HDMI_PLL_CTRL_REG);\n\n\treturn 0;\n}\n\nstatic u8 sun4i_tmds_get_parent(struct clk_hw *hw)\n{\n\tstruct sun4i_tmds *tmds = hw_to_tmds(hw);\n\tu32 reg;\n\n\treg = readl(tmds->hdmi->base + SUN4I_HDMI_PLL_DBG0_REG);\n\treturn ((reg & SUN4I_HDMI_PLL_DBG0_TMDS_PARENT_MASK) >>\n\t\tSUN4I_HDMI_PLL_DBG0_TMDS_PARENT_SHIFT);\n}\n\nstatic int sun4i_tmds_set_parent(struct clk_hw *hw, u8 index)\n{\n\tstruct sun4i_tmds *tmds = hw_to_tmds(hw);\n\tu32 reg;\n\n\tif (index > 1)\n\t\treturn -EINVAL;\n\n\treg = readl(tmds->hdmi->base + SUN4I_HDMI_PLL_DBG0_REG);\n\treg &= ~SUN4I_HDMI_PLL_DBG0_TMDS_PARENT_MASK;\n\twritel(reg | SUN4I_HDMI_PLL_DBG0_TMDS_PARENT(index),\n\t       tmds->hdmi->base + SUN4I_HDMI_PLL_DBG0_REG);\n\n\treturn 0;\n}\n\nstatic const struct clk_ops sun4i_tmds_ops = {\n\t.determine_rate\t= sun4i_tmds_determine_rate,\n\t.recalc_rate\t= sun4i_tmds_recalc_rate,\n\t.set_rate\t= sun4i_tmds_set_rate,\n\n\t.get_parent\t= sun4i_tmds_get_parent,\n\t.set_parent\t= sun4i_tmds_set_parent,\n};\n\nint sun4i_tmds_create(struct sun4i_hdmi *hdmi)\n{\n\tstruct clk_init_data init;\n\tstruct sun4i_tmds *tmds;\n\tconst char *parents[2];\n\n\tparents[0] = __clk_get_name(hdmi->pll0_clk);\n\tif (!parents[0])\n\t\treturn -ENODEV;\n\n\tparents[1] = __clk_get_name(hdmi->pll1_clk);\n\tif (!parents[1])\n\t\treturn -ENODEV;\n\n\ttmds = devm_kzalloc(hdmi->dev, sizeof(*tmds), GFP_KERNEL);\n\tif (!tmds)\n\t\treturn -ENOMEM;\n\n\tinit.name = \"hdmi-tmds\";\n\tinit.ops = &sun4i_tmds_ops;\n\tinit.parent_names = parents;\n\tinit.num_parents = 2;\n\tinit.flags = CLK_SET_RATE_PARENT;\n\n\ttmds->hdmi = hdmi;\n\ttmds->hw.init = &init;\n\ttmds->div_offset = hdmi->variant->tmds_clk_div_offset;\n\n\thdmi->tmds_clk = devm_clk_register(hdmi->dev, &tmds->hw);\n\tif (IS_ERR(hdmi->tmds_clk))\n\t\treturn PTR_ERR(hdmi->tmds_clk);\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}