{
  "module_name": "sun4i_drv.c",
  "hash_id": "e996e0350908ad97f7f8f1f05564ac87f8dea20d746d07e430ccd0bcc474f7ee",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/sun4i/sun4i_drv.c",
  "human_readable_source": "\n \n\n#include <linux/component.h>\n#include <linux/dma-mapping.h>\n#include <linux/kfifo.h>\n#include <linux/module.h>\n#include <linux/of_graph.h>\n#include <linux/of_reserved_mem.h>\n#include <linux/platform_device.h>\n\n#include <drm/drm_aperture.h>\n#include <drm/drm_atomic_helper.h>\n#include <drm/drm_drv.h>\n#include <drm/drm_fbdev_dma.h>\n#include <drm/drm_gem_dma_helper.h>\n#include <drm/drm_module.h>\n#include <drm/drm_of.h>\n#include <drm/drm_probe_helper.h>\n#include <drm/drm_vblank.h>\n\n#include \"sun4i_drv.h\"\n#include \"sun4i_frontend.h\"\n#include \"sun4i_framebuffer.h\"\n#include \"sun4i_tcon.h\"\n#include \"sun8i_tcon_top.h\"\n\nstatic int drm_sun4i_gem_dumb_create(struct drm_file *file_priv,\n\t\t\t\t     struct drm_device *drm,\n\t\t\t\t     struct drm_mode_create_dumb *args)\n{\n\t \n\targs->pitch = ALIGN(DIV_ROUND_UP(args->width * args->bpp, 8), 2);\n\n\treturn drm_gem_dma_dumb_create_internal(file_priv, drm, args);\n}\n\nDEFINE_DRM_GEM_DMA_FOPS(sun4i_drv_fops);\n\nstatic const struct drm_driver sun4i_drv_driver = {\n\t.driver_features\t= DRIVER_GEM | DRIVER_MODESET | DRIVER_ATOMIC,\n\n\t \n\t.fops\t\t\t= &sun4i_drv_fops,\n\t.name\t\t\t= \"sun4i-drm\",\n\t.desc\t\t\t= \"Allwinner sun4i Display Engine\",\n\t.date\t\t\t= \"20150629\",\n\t.major\t\t\t= 1,\n\t.minor\t\t\t= 0,\n\n\t \n\tDRM_GEM_DMA_DRIVER_OPS_WITH_DUMB_CREATE(drm_sun4i_gem_dumb_create),\n};\n\nstatic int sun4i_drv_bind(struct device *dev)\n{\n\tstruct drm_device *drm;\n\tstruct sun4i_drv *drv;\n\tint ret;\n\n\tdrm = drm_dev_alloc(&sun4i_drv_driver, dev);\n\tif (IS_ERR(drm))\n\t\treturn PTR_ERR(drm);\n\n\tdrv = devm_kzalloc(dev, sizeof(*drv), GFP_KERNEL);\n\tif (!drv) {\n\t\tret = -ENOMEM;\n\t\tgoto free_drm;\n\t}\n\n\tdrm->dev_private = drv;\n\tINIT_LIST_HEAD(&drv->frontend_list);\n\tINIT_LIST_HEAD(&drv->engine_list);\n\tINIT_LIST_HEAD(&drv->tcon_list);\n\n\tret = of_reserved_mem_device_init(dev);\n\tif (ret && ret != -ENODEV) {\n\t\tdev_err(drm->dev, \"Couldn't claim our memory region\\n\");\n\t\tgoto free_drm;\n\t}\n\n\tdrm_mode_config_init(drm);\n\n\tret = component_bind_all(drm->dev, drm);\n\tif (ret) {\n\t\tdev_err(drm->dev, \"Couldn't bind all pipelines components\\n\");\n\t\tgoto cleanup_mode_config;\n\t}\n\n\t \n\tret = drm_vblank_init(drm, drm->mode_config.num_crtc);\n\tif (ret)\n\t\tgoto unbind_all;\n\n\t \n\tret = drm_aperture_remove_framebuffers(&sun4i_drv_driver);\n\tif (ret)\n\t\tgoto unbind_all;\n\n\tsun4i_framebuffer_init(drm);\n\n\t \n\tdrm_kms_helper_poll_init(drm);\n\n\tret = drm_dev_register(drm, 0);\n\tif (ret)\n\t\tgoto finish_poll;\n\n\tdrm_fbdev_dma_setup(drm, 32);\n\n\tdev_set_drvdata(dev, drm);\n\n\treturn 0;\n\nfinish_poll:\n\tdrm_kms_helper_poll_fini(drm);\nunbind_all:\n\tcomponent_unbind_all(dev, NULL);\ncleanup_mode_config:\n\tdrm_mode_config_cleanup(drm);\n\tof_reserved_mem_device_release(dev);\nfree_drm:\n\tdrm_dev_put(drm);\n\treturn ret;\n}\n\nstatic void sun4i_drv_unbind(struct device *dev)\n{\n\tstruct drm_device *drm = dev_get_drvdata(dev);\n\n\tdev_set_drvdata(dev, NULL);\n\tdrm_dev_unregister(drm);\n\tdrm_kms_helper_poll_fini(drm);\n\tdrm_atomic_helper_shutdown(drm);\n\tdrm_mode_config_cleanup(drm);\n\n\tcomponent_unbind_all(dev, NULL);\n\tof_reserved_mem_device_release(dev);\n\n\tdrm_dev_put(drm);\n}\n\nstatic const struct component_master_ops sun4i_drv_master_ops = {\n\t.bind\t= sun4i_drv_bind,\n\t.unbind\t= sun4i_drv_unbind,\n};\n\nstatic bool sun4i_drv_node_is_connector(struct device_node *node)\n{\n\treturn of_device_is_compatible(node, \"hdmi-connector\");\n}\n\nstatic bool sun4i_drv_node_is_frontend(struct device_node *node)\n{\n\treturn of_device_is_compatible(node, \"allwinner,sun4i-a10-display-frontend\") ||\n\t\tof_device_is_compatible(node, \"allwinner,sun5i-a13-display-frontend\") ||\n\t\tof_device_is_compatible(node, \"allwinner,sun6i-a31-display-frontend\") ||\n\t\tof_device_is_compatible(node, \"allwinner,sun7i-a20-display-frontend\") ||\n\t\tof_device_is_compatible(node, \"allwinner,sun8i-a23-display-frontend\") ||\n\t\tof_device_is_compatible(node, \"allwinner,sun8i-a33-display-frontend\") ||\n\t\tof_device_is_compatible(node, \"allwinner,sun9i-a80-display-frontend\");\n}\n\nstatic bool sun4i_drv_node_is_deu(struct device_node *node)\n{\n\treturn of_device_is_compatible(node, \"allwinner,sun9i-a80-deu\");\n}\n\nstatic bool sun4i_drv_node_is_supported_frontend(struct device_node *node)\n{\n\tif (IS_ENABLED(CONFIG_DRM_SUN4I_BACKEND))\n\t\treturn !!of_match_node(sun4i_frontend_of_table, node);\n\n\treturn false;\n}\n\nstatic bool sun4i_drv_node_is_tcon(struct device_node *node)\n{\n\treturn !!of_match_node(sun4i_tcon_of_table, node);\n}\n\nstatic bool sun4i_drv_node_is_tcon_with_ch0(struct device_node *node)\n{\n\tconst struct of_device_id *match;\n\n\tmatch = of_match_node(sun4i_tcon_of_table, node);\n\tif (match) {\n\t\tstruct sun4i_tcon_quirks *quirks;\n\n\t\tquirks = (struct sun4i_tcon_quirks *)match->data;\n\n\t\treturn quirks->has_channel_0;\n\t}\n\n\treturn false;\n}\n\nstatic bool sun4i_drv_node_is_tcon_top(struct device_node *node)\n{\n\treturn IS_ENABLED(CONFIG_DRM_SUN8I_TCON_TOP) &&\n\t\t!!of_match_node(sun8i_tcon_top_of_table, node);\n}\n\n \nstruct endpoint_list {\n\tDECLARE_KFIFO(fifo, struct device_node *, 16);\n};\n\nstatic void sun4i_drv_traverse_endpoints(struct endpoint_list *list,\n\t\t\t\t\t struct device_node *node,\n\t\t\t\t\t int port_id)\n{\n\tstruct device_node *ep, *remote, *port;\n\n\tport = of_graph_get_port_by_id(node, port_id);\n\tif (!port) {\n\t\tDRM_DEBUG_DRIVER(\"No output to bind on port %d\\n\", port_id);\n\t\treturn;\n\t}\n\n\tfor_each_available_child_of_node(port, ep) {\n\t\tremote = of_graph_get_remote_port_parent(ep);\n\t\tif (!remote) {\n\t\t\tDRM_DEBUG_DRIVER(\"Error retrieving the output node\\n\");\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (sun4i_drv_node_is_tcon(node)) {\n\t\t\t \n\t\t\tif (sun4i_drv_node_is_tcon_top(remote)) {\n\t\t\t\tDRM_DEBUG_DRIVER(\"TCON output endpoint is TCON TOP... skipping\\n\");\n\t\t\t\tof_node_put(remote);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t \n\t\t\tif (sun4i_drv_node_is_tcon_with_ch0(node)) {\n\t\t\t\tstruct of_endpoint endpoint;\n\n\t\t\t\tif (of_graph_parse_endpoint(ep, &endpoint)) {\n\t\t\t\t\tDRM_DEBUG_DRIVER(\"Couldn't parse endpoint\\n\");\n\t\t\t\t\tof_node_put(remote);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tif (!endpoint.id) {\n\t\t\t\t\tDRM_DEBUG_DRIVER(\"Endpoint is our panel... skipping\\n\");\n\t\t\t\t\tof_node_put(remote);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tkfifo_put(&list->fifo, remote);\n\t}\n}\n\nstatic int sun4i_drv_add_endpoints(struct device *dev,\n\t\t\t\t   struct endpoint_list *list,\n\t\t\t\t   struct component_match **match,\n\t\t\t\t   struct device_node *node)\n{\n\tint count = 0;\n\n\t \n\tif (!sun4i_drv_node_is_frontend(node) &&\n\t    !of_device_is_available(node))\n\t\treturn 0;\n\n\t \n\tif (sun4i_drv_node_is_connector(node))\n\t\treturn 0;\n\n\t \n\tif (!(sun4i_drv_node_is_frontend(node) ||\n\t      sun4i_drv_node_is_deu(node)) ||\n\t    (sun4i_drv_node_is_supported_frontend(node) &&\n\t     of_device_is_available(node))) {\n\t\t \n\t\tDRM_DEBUG_DRIVER(\"Adding component %pOF\\n\", node);\n\t\tdrm_of_component_match_add(dev, match, component_compare_of, node);\n\t\tcount++;\n\t}\n\n\t \n\tsun4i_drv_traverse_endpoints(list, node, 1);\n\n\t \n\tif (sun4i_drv_node_is_tcon_top(node)) {\n\t\tsun4i_drv_traverse_endpoints(list, node, 3);\n\t\tsun4i_drv_traverse_endpoints(list, node, 5);\n\t}\n\n\treturn count;\n}\n\n#ifdef CONFIG_PM_SLEEP\nstatic int sun4i_drv_drm_sys_suspend(struct device *dev)\n{\n\tstruct drm_device *drm = dev_get_drvdata(dev);\n\n\treturn drm_mode_config_helper_suspend(drm);\n}\n\nstatic int sun4i_drv_drm_sys_resume(struct device *dev)\n{\n\tstruct drm_device *drm = dev_get_drvdata(dev);\n\n\treturn drm_mode_config_helper_resume(drm);\n}\n#endif\n\nstatic const struct dev_pm_ops sun4i_drv_drm_pm_ops = {\n\tSET_SYSTEM_SLEEP_PM_OPS(sun4i_drv_drm_sys_suspend,\n\t\t\t\tsun4i_drv_drm_sys_resume)\n};\n\nstatic int sun4i_drv_probe(struct platform_device *pdev)\n{\n\tstruct component_match *match = NULL;\n\tstruct device_node *np = pdev->dev.of_node, *endpoint;\n\tstruct endpoint_list list;\n\tint i, ret, count = 0;\n\n\tINIT_KFIFO(list.fifo);\n\n\t \n\tdma_set_mask_and_coherent(&pdev->dev, DMA_BIT_MASK(32));\n\tdma_set_max_seg_size(&pdev->dev, UINT_MAX);\n\n\tfor (i = 0;; i++) {\n\t\tstruct device_node *pipeline = of_parse_phandle(np,\n\t\t\t\t\t\t\t\t\"allwinner,pipelines\",\n\t\t\t\t\t\t\t\ti);\n\t\tif (!pipeline)\n\t\t\tbreak;\n\n\t\tkfifo_put(&list.fifo, pipeline);\n\t}\n\n\twhile (kfifo_get(&list.fifo, &endpoint)) {\n\t\t \n\t\tret = sun4i_drv_add_endpoints(&pdev->dev, &list, &match,\n\t\t\t\t\t      endpoint);\n\n\t\t \n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tcount += ret;\n\t}\n\n\tif (count)\n\t\treturn component_master_add_with_match(&pdev->dev,\n\t\t\t\t\t\t       &sun4i_drv_master_ops,\n\t\t\t\t\t\t       match);\n\telse\n\t\treturn 0;\n}\n\nstatic void sun4i_drv_remove(struct platform_device *pdev)\n{\n\tcomponent_master_del(&pdev->dev, &sun4i_drv_master_ops);\n}\n\nstatic const struct of_device_id sun4i_drv_of_table[] = {\n\t{ .compatible = \"allwinner,sun4i-a10-display-engine\" },\n\t{ .compatible = \"allwinner,sun5i-a10s-display-engine\" },\n\t{ .compatible = \"allwinner,sun5i-a13-display-engine\" },\n\t{ .compatible = \"allwinner,sun6i-a31-display-engine\" },\n\t{ .compatible = \"allwinner,sun6i-a31s-display-engine\" },\n\t{ .compatible = \"allwinner,sun7i-a20-display-engine\" },\n\t{ .compatible = \"allwinner,sun8i-a23-display-engine\" },\n\t{ .compatible = \"allwinner,sun8i-a33-display-engine\" },\n\t{ .compatible = \"allwinner,sun8i-a83t-display-engine\" },\n\t{ .compatible = \"allwinner,sun8i-h3-display-engine\" },\n\t{ .compatible = \"allwinner,sun8i-r40-display-engine\" },\n\t{ .compatible = \"allwinner,sun8i-v3s-display-engine\" },\n\t{ .compatible = \"allwinner,sun9i-a80-display-engine\" },\n\t{ .compatible = \"allwinner,sun20i-d1-display-engine\" },\n\t{ .compatible = \"allwinner,sun50i-a64-display-engine\" },\n\t{ .compatible = \"allwinner,sun50i-h6-display-engine\" },\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, sun4i_drv_of_table);\n\nstatic struct platform_driver sun4i_drv_platform_driver = {\n\t.probe\t\t= sun4i_drv_probe,\n\t.remove_new\t= sun4i_drv_remove,\n\t.driver\t\t= {\n\t\t.name\t\t= \"sun4i-drm\",\n\t\t.of_match_table\t= sun4i_drv_of_table,\n\t\t.pm = &sun4i_drv_drm_pm_ops,\n\t},\n};\ndrm_module_platform_driver(sun4i_drv_platform_driver);\n\nMODULE_AUTHOR(\"Boris Brezillon <boris.brezillon@free-electrons.com>\");\nMODULE_AUTHOR(\"Maxime Ripard <maxime.ripard@free-electrons.com>\");\nMODULE_DESCRIPTION(\"Allwinner A10 Display Engine DRM/KMS Driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}