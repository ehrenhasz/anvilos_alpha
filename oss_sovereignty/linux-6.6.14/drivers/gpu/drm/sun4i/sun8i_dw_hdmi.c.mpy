{
  "module_name": "sun8i_dw_hdmi.c",
  "hash_id": "4cc8722b7daab234d13b7df7fad55fe6b3c884fe1a262b1483be0e9ba0bb1176",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/sun4i/sun8i_dw_hdmi.c",
  "human_readable_source": "\n \n\n#include <linux/component.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n\n#include <drm/drm_modeset_helper_vtables.h>\n#include <drm/drm_of.h>\n#include <drm/drm_simple_kms_helper.h>\n\n#include \"sun8i_dw_hdmi.h\"\n#include \"sun8i_tcon_top.h\"\n\nstatic void sun8i_dw_hdmi_encoder_mode_set(struct drm_encoder *encoder,\n\t\t\t\t\t   struct drm_display_mode *mode,\n\t\t\t\t\t   struct drm_display_mode *adj_mode)\n{\n\tstruct sun8i_dw_hdmi *hdmi = encoder_to_sun8i_dw_hdmi(encoder);\n\n\tclk_set_rate(hdmi->clk_tmds, mode->crtc_clock * 1000);\n}\n\nstatic const struct drm_encoder_helper_funcs\nsun8i_dw_hdmi_encoder_helper_funcs = {\n\t.mode_set = sun8i_dw_hdmi_encoder_mode_set,\n};\n\nstatic enum drm_mode_status\nsun8i_dw_hdmi_mode_valid_a83t(struct dw_hdmi *hdmi, void *data,\n\t\t\t      const struct drm_display_info *info,\n\t\t\t      const struct drm_display_mode *mode)\n{\n\tif (mode->clock > 297000)\n\t\treturn MODE_CLOCK_HIGH;\n\n\treturn MODE_OK;\n}\n\nstatic enum drm_mode_status\nsun8i_dw_hdmi_mode_valid_h6(struct dw_hdmi *hdmi, void *data,\n\t\t\t    const struct drm_display_info *info,\n\t\t\t    const struct drm_display_mode *mode)\n{\n\t \n\tif (mode->clock > 594000)\n\t\treturn MODE_CLOCK_HIGH;\n\n\treturn MODE_OK;\n}\n\nstatic bool sun8i_dw_hdmi_node_is_tcon_top(struct device_node *node)\n{\n\treturn IS_ENABLED(CONFIG_DRM_SUN8I_TCON_TOP) &&\n\t\t!!of_match_node(sun8i_tcon_top_of_table, node);\n}\n\nstatic u32 sun8i_dw_hdmi_find_possible_crtcs(struct drm_device *drm,\n\t\t\t\t\t     struct device_node *node)\n{\n\tstruct device_node *port, *ep, *remote, *remote_port;\n\tu32 crtcs = 0;\n\n\tremote = of_graph_get_remote_node(node, 0, -1);\n\tif (!remote)\n\t\treturn 0;\n\n\tif (sun8i_dw_hdmi_node_is_tcon_top(remote)) {\n\t\tport = of_graph_get_port_by_id(remote, 4);\n\t\tif (!port)\n\t\t\tgoto crtcs_exit;\n\n\t\tfor_each_child_of_node(port, ep) {\n\t\t\tremote_port = of_graph_get_remote_port(ep);\n\t\t\tif (remote_port) {\n\t\t\t\tcrtcs |= drm_of_crtc_port_mask(drm, remote_port);\n\t\t\t\tof_node_put(remote_port);\n\t\t\t}\n\t\t}\n\t} else {\n\t\tcrtcs = drm_of_find_possible_crtcs(drm, node);\n\t}\n\ncrtcs_exit:\n\tof_node_put(remote);\n\n\treturn crtcs;\n}\n\nstatic int sun8i_dw_hdmi_bind(struct device *dev, struct device *master,\n\t\t\t      void *data)\n{\n\tstruct platform_device *pdev = to_platform_device(dev);\n\tstruct dw_hdmi_plat_data *plat_data;\n\tstruct drm_device *drm = data;\n\tstruct device_node *phy_node;\n\tstruct drm_encoder *encoder;\n\tstruct sun8i_dw_hdmi *hdmi;\n\tint ret;\n\n\tif (!pdev->dev.of_node)\n\t\treturn -ENODEV;\n\n\thdmi = devm_kzalloc(&pdev->dev, sizeof(*hdmi), GFP_KERNEL);\n\tif (!hdmi)\n\t\treturn -ENOMEM;\n\n\tplat_data = &hdmi->plat_data;\n\thdmi->dev = &pdev->dev;\n\tencoder = &hdmi->encoder;\n\n\thdmi->quirks = of_device_get_match_data(dev);\n\n\tencoder->possible_crtcs =\n\t\tsun8i_dw_hdmi_find_possible_crtcs(drm, dev->of_node);\n\t \n\tif (encoder->possible_crtcs == 0)\n\t\treturn -EPROBE_DEFER;\n\n\thdmi->rst_ctrl = devm_reset_control_get(dev, \"ctrl\");\n\tif (IS_ERR(hdmi->rst_ctrl))\n\t\treturn dev_err_probe(dev, PTR_ERR(hdmi->rst_ctrl),\n\t\t\t\t     \"Could not get ctrl reset control\\n\");\n\n\thdmi->clk_tmds = devm_clk_get(dev, \"tmds\");\n\tif (IS_ERR(hdmi->clk_tmds))\n\t\treturn dev_err_probe(dev, PTR_ERR(hdmi->clk_tmds),\n\t\t\t\t     \"Couldn't get the tmds clock\\n\");\n\n\thdmi->regulator = devm_regulator_get(dev, \"hvcc\");\n\tif (IS_ERR(hdmi->regulator))\n\t\treturn dev_err_probe(dev, PTR_ERR(hdmi->regulator),\n\t\t\t\t     \"Couldn't get regulator\\n\");\n\n\tret = regulator_enable(hdmi->regulator);\n\tif (ret) {\n\t\tdev_err(dev, \"Failed to enable regulator\\n\");\n\t\treturn ret;\n\t}\n\n\tret = reset_control_deassert(hdmi->rst_ctrl);\n\tif (ret) {\n\t\tdev_err(dev, \"Could not deassert ctrl reset control\\n\");\n\t\tgoto err_disable_regulator;\n\t}\n\n\tret = clk_prepare_enable(hdmi->clk_tmds);\n\tif (ret) {\n\t\tdev_err(dev, \"Could not enable tmds clock\\n\");\n\t\tgoto err_assert_ctrl_reset;\n\t}\n\n\tphy_node = of_parse_phandle(dev->of_node, \"phys\", 0);\n\tif (!phy_node) {\n\t\tdev_err(dev, \"Can't found PHY phandle\\n\");\n\t\tret = -EINVAL;\n\t\tgoto err_disable_clk_tmds;\n\t}\n\n\tret = sun8i_hdmi_phy_get(hdmi, phy_node);\n\tof_node_put(phy_node);\n\tif (ret) {\n\t\tdev_err(dev, \"Couldn't get the HDMI PHY\\n\");\n\t\tgoto err_disable_clk_tmds;\n\t}\n\n\tret = sun8i_hdmi_phy_init(hdmi->phy);\n\tif (ret)\n\t\tgoto err_disable_clk_tmds;\n\n\tdrm_encoder_helper_add(encoder, &sun8i_dw_hdmi_encoder_helper_funcs);\n\tdrm_simple_encoder_init(drm, encoder, DRM_MODE_ENCODER_TMDS);\n\n\tplat_data->mode_valid = hdmi->quirks->mode_valid;\n\tplat_data->use_drm_infoframe = hdmi->quirks->use_drm_infoframe;\n\tsun8i_hdmi_phy_set_ops(hdmi->phy, plat_data);\n\n\tplatform_set_drvdata(pdev, hdmi);\n\n\thdmi->hdmi = dw_hdmi_bind(pdev, encoder, plat_data);\n\n\t \n\tif (IS_ERR(hdmi->hdmi)) {\n\t\tret = PTR_ERR(hdmi->hdmi);\n\t\tgoto cleanup_encoder;\n\t}\n\n\treturn 0;\n\ncleanup_encoder:\n\tdrm_encoder_cleanup(encoder);\nerr_disable_clk_tmds:\n\tclk_disable_unprepare(hdmi->clk_tmds);\nerr_assert_ctrl_reset:\n\treset_control_assert(hdmi->rst_ctrl);\nerr_disable_regulator:\n\tregulator_disable(hdmi->regulator);\n\n\treturn ret;\n}\n\nstatic void sun8i_dw_hdmi_unbind(struct device *dev, struct device *master,\n\t\t\t\t void *data)\n{\n\tstruct sun8i_dw_hdmi *hdmi = dev_get_drvdata(dev);\n\n\tdw_hdmi_unbind(hdmi->hdmi);\n\tsun8i_hdmi_phy_deinit(hdmi->phy);\n\tclk_disable_unprepare(hdmi->clk_tmds);\n\treset_control_assert(hdmi->rst_ctrl);\n\tregulator_disable(hdmi->regulator);\n}\n\nstatic const struct component_ops sun8i_dw_hdmi_ops = {\n\t.bind\t= sun8i_dw_hdmi_bind,\n\t.unbind\t= sun8i_dw_hdmi_unbind,\n};\n\nstatic int sun8i_dw_hdmi_probe(struct platform_device *pdev)\n{\n\treturn component_add(&pdev->dev, &sun8i_dw_hdmi_ops);\n}\n\nstatic void sun8i_dw_hdmi_remove(struct platform_device *pdev)\n{\n\tcomponent_del(&pdev->dev, &sun8i_dw_hdmi_ops);\n}\n\nstatic const struct sun8i_dw_hdmi_quirks sun8i_a83t_quirks = {\n\t.mode_valid = sun8i_dw_hdmi_mode_valid_a83t,\n};\n\nstatic const struct sun8i_dw_hdmi_quirks sun50i_h6_quirks = {\n\t.mode_valid = sun8i_dw_hdmi_mode_valid_h6,\n\t.use_drm_infoframe = true,\n};\n\nstatic const struct of_device_id sun8i_dw_hdmi_dt_ids[] = {\n\t{\n\t\t.compatible = \"allwinner,sun8i-a83t-dw-hdmi\",\n\t\t.data = &sun8i_a83t_quirks,\n\t},\n\t{\n\t\t.compatible = \"allwinner,sun50i-h6-dw-hdmi\",\n\t\t.data = &sun50i_h6_quirks,\n\t},\n\t{   },\n};\nMODULE_DEVICE_TABLE(of, sun8i_dw_hdmi_dt_ids);\n\nstatic struct platform_driver sun8i_dw_hdmi_pltfm_driver = {\n\t.probe  = sun8i_dw_hdmi_probe,\n\t.remove_new = sun8i_dw_hdmi_remove,\n\t.driver = {\n\t\t.name = \"sun8i-dw-hdmi\",\n\t\t.of_match_table = sun8i_dw_hdmi_dt_ids,\n\t},\n};\n\nstatic int __init sun8i_dw_hdmi_init(void)\n{\n\tint ret;\n\n\tret = platform_driver_register(&sun8i_dw_hdmi_pltfm_driver);\n\tif (ret)\n\t\treturn ret;\n\n\tret = platform_driver_register(&sun8i_hdmi_phy_driver);\n\tif (ret) {\n\t\tplatform_driver_unregister(&sun8i_dw_hdmi_pltfm_driver);\n\t\treturn ret;\n\t}\n\n\treturn ret;\n}\n\nstatic void __exit sun8i_dw_hdmi_exit(void)\n{\n\tplatform_driver_unregister(&sun8i_dw_hdmi_pltfm_driver);\n\tplatform_driver_unregister(&sun8i_hdmi_phy_driver);\n}\n\nmodule_init(sun8i_dw_hdmi_init);\nmodule_exit(sun8i_dw_hdmi_exit);\n\nMODULE_AUTHOR(\"Jernej Skrabec <jernej.skrabec@siol.net>\");\nMODULE_DESCRIPTION(\"Allwinner DW HDMI bridge\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}