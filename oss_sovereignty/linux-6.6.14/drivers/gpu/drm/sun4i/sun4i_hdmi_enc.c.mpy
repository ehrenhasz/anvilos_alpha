{
  "module_name": "sun4i_hdmi_enc.c",
  "hash_id": "4d89ce2f2b9638d6ec7e50f32fedd7e71cc2566df2e9848f6a178a34b04cc29d",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/sun4i/sun4i_hdmi_enc.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/component.h>\n#include <linux/i2c.h>\n#include <linux/iopoll.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/pm_runtime.h>\n#include <linux/regmap.h>\n#include <linux/reset.h>\n\n#include <drm/drm_atomic_helper.h>\n#include <drm/drm_edid.h>\n#include <drm/drm_encoder.h>\n#include <drm/drm_of.h>\n#include <drm/drm_panel.h>\n#include <drm/drm_print.h>\n#include <drm/drm_probe_helper.h>\n#include <drm/drm_simple_kms_helper.h>\n\n#include \"sun4i_backend.h\"\n#include \"sun4i_crtc.h\"\n#include \"sun4i_drv.h\"\n#include \"sun4i_hdmi.h\"\n\nstatic inline struct sun4i_hdmi *\ndrm_encoder_to_sun4i_hdmi(struct drm_encoder *encoder)\n{\n\treturn container_of(encoder, struct sun4i_hdmi,\n\t\t\t    encoder);\n}\n\nstatic inline struct sun4i_hdmi *\ndrm_connector_to_sun4i_hdmi(struct drm_connector *connector)\n{\n\treturn container_of(connector, struct sun4i_hdmi,\n\t\t\t    connector);\n}\n\nstatic int sun4i_hdmi_setup_avi_infoframes(struct sun4i_hdmi *hdmi,\n\t\t\t\t\t   struct drm_display_mode *mode)\n{\n\tstruct hdmi_avi_infoframe frame;\n\tu8 buffer[17];\n\tint i, ret;\n\n\tret = drm_hdmi_avi_infoframe_from_display_mode(&frame,\n\t\t\t\t\t\t       &hdmi->connector, mode);\n\tif (ret < 0) {\n\t\tDRM_ERROR(\"Failed to get infoframes from mode\\n\");\n\t\treturn ret;\n\t}\n\n\tret = hdmi_avi_infoframe_pack(&frame, buffer, sizeof(buffer));\n\tif (ret < 0) {\n\t\tDRM_ERROR(\"Failed to pack infoframes\\n\");\n\t\treturn ret;\n\t}\n\n\tfor (i = 0; i < sizeof(buffer); i++)\n\t\twriteb(buffer[i], hdmi->base + SUN4I_HDMI_AVI_INFOFRAME_REG(i));\n\n\treturn 0;\n}\n\nstatic int sun4i_hdmi_atomic_check(struct drm_encoder *encoder,\n\t\t\t\t   struct drm_crtc_state *crtc_state,\n\t\t\t\t   struct drm_connector_state *conn_state)\n{\n\tstruct drm_display_mode *mode = &crtc_state->mode;\n\n\tif (mode->flags & DRM_MODE_FLAG_DBLCLK)\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nstatic void sun4i_hdmi_disable(struct drm_encoder *encoder)\n{\n\tstruct sun4i_hdmi *hdmi = drm_encoder_to_sun4i_hdmi(encoder);\n\tu32 val;\n\n\tDRM_DEBUG_DRIVER(\"Disabling the HDMI Output\\n\");\n\n\tval = readl(hdmi->base + SUN4I_HDMI_VID_CTRL_REG);\n\tval &= ~SUN4I_HDMI_VID_CTRL_ENABLE;\n\twritel(val, hdmi->base + SUN4I_HDMI_VID_CTRL_REG);\n\n\tclk_disable_unprepare(hdmi->tmds_clk);\n}\n\nstatic void sun4i_hdmi_enable(struct drm_encoder *encoder)\n{\n\tstruct drm_display_mode *mode = &encoder->crtc->state->adjusted_mode;\n\tstruct sun4i_hdmi *hdmi = drm_encoder_to_sun4i_hdmi(encoder);\n\tstruct drm_display_info *display = &hdmi->connector.display_info;\n\tu32 val = 0;\n\n\tDRM_DEBUG_DRIVER(\"Enabling the HDMI Output\\n\");\n\n\tclk_prepare_enable(hdmi->tmds_clk);\n\n\tsun4i_hdmi_setup_avi_infoframes(hdmi, mode);\n\tval |= SUN4I_HDMI_PKT_CTRL_TYPE(0, SUN4I_HDMI_PKT_AVI);\n\tval |= SUN4I_HDMI_PKT_CTRL_TYPE(1, SUN4I_HDMI_PKT_END);\n\twritel(val, hdmi->base + SUN4I_HDMI_PKT_CTRL_REG(0));\n\n\tval = SUN4I_HDMI_VID_CTRL_ENABLE;\n\tif (display->is_hdmi)\n\t\tval |= SUN4I_HDMI_VID_CTRL_HDMI_MODE;\n\n\twritel(val, hdmi->base + SUN4I_HDMI_VID_CTRL_REG);\n}\n\nstatic void sun4i_hdmi_mode_set(struct drm_encoder *encoder,\n\t\t\t\tstruct drm_display_mode *mode,\n\t\t\t\tstruct drm_display_mode *adjusted_mode)\n{\n\tstruct sun4i_hdmi *hdmi = drm_encoder_to_sun4i_hdmi(encoder);\n\tunsigned int x, y;\n\tu32 val;\n\n\tclk_set_rate(hdmi->mod_clk, mode->crtc_clock * 1000);\n\tclk_set_rate(hdmi->tmds_clk, mode->crtc_clock * 1000);\n\n\t \n\twritel(SUN4I_HDMI_UNKNOWN_INPUT_SYNC,\n\t       hdmi->base + SUN4I_HDMI_UNKNOWN_REG);\n\n\t \n\tval = readl(hdmi->base + SUN4I_HDMI_PAD_CTRL1_REG);\n\tval &= SUN4I_HDMI_PAD_CTRL1_HALVE_CLK;\n\tval |= hdmi->variant->pad_ctrl1_init_val;\n\twritel(val, hdmi->base + SUN4I_HDMI_PAD_CTRL1_REG);\n\tval = readl(hdmi->base + SUN4I_HDMI_PAD_CTRL1_REG);\n\n\t \n\twritel(SUN4I_HDMI_VID_TIMING_X(mode->hdisplay) |\n\t       SUN4I_HDMI_VID_TIMING_Y(mode->vdisplay),\n\t       hdmi->base + SUN4I_HDMI_VID_TIMING_ACT_REG);\n\n\tx = mode->htotal - mode->hsync_start;\n\ty = mode->vtotal - mode->vsync_start;\n\twritel(SUN4I_HDMI_VID_TIMING_X(x) | SUN4I_HDMI_VID_TIMING_Y(y),\n\t       hdmi->base + SUN4I_HDMI_VID_TIMING_BP_REG);\n\n\tx = mode->hsync_start - mode->hdisplay;\n\ty = mode->vsync_start - mode->vdisplay;\n\twritel(SUN4I_HDMI_VID_TIMING_X(x) | SUN4I_HDMI_VID_TIMING_Y(y),\n\t       hdmi->base + SUN4I_HDMI_VID_TIMING_FP_REG);\n\n\tx = mode->hsync_end - mode->hsync_start;\n\ty = mode->vsync_end - mode->vsync_start;\n\twritel(SUN4I_HDMI_VID_TIMING_X(x) | SUN4I_HDMI_VID_TIMING_Y(y),\n\t       hdmi->base + SUN4I_HDMI_VID_TIMING_SPW_REG);\n\n\tval = SUN4I_HDMI_VID_TIMING_POL_TX_CLK;\n\tif (mode->flags & DRM_MODE_FLAG_PHSYNC)\n\t\tval |= SUN4I_HDMI_VID_TIMING_POL_HSYNC;\n\n\tif (mode->flags & DRM_MODE_FLAG_PVSYNC)\n\t\tval |= SUN4I_HDMI_VID_TIMING_POL_VSYNC;\n\n\twritel(val, hdmi->base + SUN4I_HDMI_VID_TIMING_POL_REG);\n}\n\nstatic enum drm_mode_status sun4i_hdmi_mode_valid(struct drm_encoder *encoder,\n\t\t\t\t\tconst struct drm_display_mode *mode)\n{\n\tstruct sun4i_hdmi *hdmi = drm_encoder_to_sun4i_hdmi(encoder);\n\tunsigned long rate = mode->clock * 1000;\n\tunsigned long diff = rate / 200;  \n\tlong rounded_rate;\n\n\t \n\tif (rate > 165000000)\n\t\treturn MODE_CLOCK_HIGH;\n\trounded_rate = clk_round_rate(hdmi->tmds_clk, rate);\n\tif (rounded_rate > 0 &&\n\t    max_t(unsigned long, rounded_rate, rate) -\n\t    min_t(unsigned long, rounded_rate, rate) < diff)\n\t\treturn MODE_OK;\n\treturn MODE_NOCLOCK;\n}\n\nstatic const struct drm_encoder_helper_funcs sun4i_hdmi_helper_funcs = {\n\t.atomic_check\t= sun4i_hdmi_atomic_check,\n\t.disable\t= sun4i_hdmi_disable,\n\t.enable\t\t= sun4i_hdmi_enable,\n\t.mode_set\t= sun4i_hdmi_mode_set,\n\t.mode_valid\t= sun4i_hdmi_mode_valid,\n};\n\nstatic int sun4i_hdmi_get_modes(struct drm_connector *connector)\n{\n\tstruct sun4i_hdmi *hdmi = drm_connector_to_sun4i_hdmi(connector);\n\tstruct edid *edid;\n\tint ret;\n\n\tedid = drm_get_edid(connector, hdmi->ddc_i2c ?: hdmi->i2c);\n\tif (!edid)\n\t\treturn 0;\n\n\tDRM_DEBUG_DRIVER(\"Monitor is %s monitor\\n\",\n\t\t\t connector->display_info.is_hdmi ? \"an HDMI\" : \"a DVI\");\n\n\tdrm_connector_update_edid_property(connector, edid);\n\tcec_s_phys_addr_from_edid(hdmi->cec_adap, edid);\n\tret = drm_add_edid_modes(connector, edid);\n\tkfree(edid);\n\n\treturn ret;\n}\n\nstatic struct i2c_adapter *sun4i_hdmi_get_ddc(struct device *dev)\n{\n\tstruct device_node *phandle, *remote;\n\tstruct i2c_adapter *ddc;\n\n\tremote = of_graph_get_remote_node(dev->of_node, 1, -1);\n\tif (!remote)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tphandle = of_parse_phandle(remote, \"ddc-i2c-bus\", 0);\n\tof_node_put(remote);\n\tif (!phandle)\n\t\treturn ERR_PTR(-ENODEV);\n\n\tddc = of_get_i2c_adapter_by_node(phandle);\n\tof_node_put(phandle);\n\tif (!ddc)\n\t\treturn ERR_PTR(-EPROBE_DEFER);\n\n\treturn ddc;\n}\n\nstatic const struct drm_connector_helper_funcs sun4i_hdmi_connector_helper_funcs = {\n\t.get_modes\t= sun4i_hdmi_get_modes,\n};\n\nstatic enum drm_connector_status\nsun4i_hdmi_connector_detect(struct drm_connector *connector, bool force)\n{\n\tstruct sun4i_hdmi *hdmi = drm_connector_to_sun4i_hdmi(connector);\n\tunsigned long reg;\n\n\treg = readl(hdmi->base + SUN4I_HDMI_HPD_REG);\n\tif (!(reg & SUN4I_HDMI_HPD_HIGH)) {\n\t\tcec_phys_addr_invalidate(hdmi->cec_adap);\n\t\treturn connector_status_disconnected;\n\t}\n\n\treturn connector_status_connected;\n}\n\nstatic const struct drm_connector_funcs sun4i_hdmi_connector_funcs = {\n\t.detect\t\t\t= sun4i_hdmi_connector_detect,\n\t.fill_modes\t\t= drm_helper_probe_single_connector_modes,\n\t.destroy\t\t= drm_connector_cleanup,\n\t.reset\t\t\t= drm_atomic_helper_connector_reset,\n\t.atomic_duplicate_state\t= drm_atomic_helper_connector_duplicate_state,\n\t.atomic_destroy_state\t= drm_atomic_helper_connector_destroy_state,\n};\n\n#ifdef CONFIG_DRM_SUN4I_HDMI_CEC\nstatic int sun4i_hdmi_cec_pin_read(struct cec_adapter *adap)\n{\n\tstruct sun4i_hdmi *hdmi = cec_get_drvdata(adap);\n\n\treturn readl(hdmi->base + SUN4I_HDMI_CEC) & SUN4I_HDMI_CEC_RX;\n}\n\nstatic void sun4i_hdmi_cec_pin_low(struct cec_adapter *adap)\n{\n\tstruct sun4i_hdmi *hdmi = cec_get_drvdata(adap);\n\n\t \n\twritel(SUN4I_HDMI_CEC_ENABLE, hdmi->base + SUN4I_HDMI_CEC);\n}\n\nstatic void sun4i_hdmi_cec_pin_high(struct cec_adapter *adap)\n{\n\tstruct sun4i_hdmi *hdmi = cec_get_drvdata(adap);\n\n\t \n\twritel(0, hdmi->base + SUN4I_HDMI_CEC);\n}\n\nstatic const struct cec_pin_ops sun4i_hdmi_cec_pin_ops = {\n\t.read = sun4i_hdmi_cec_pin_read,\n\t.low = sun4i_hdmi_cec_pin_low,\n\t.high = sun4i_hdmi_cec_pin_high,\n};\n#endif\n\n#define SUN4I_HDMI_PAD_CTRL1_MASK\t(GENMASK(24, 7) | GENMASK(5, 0))\n#define SUN4I_HDMI_PLL_CTRL_MASK\t(GENMASK(31, 8) | GENMASK(3, 0))\n\n \nstatic const struct sun4i_hdmi_variant sun4i_variant = {\n\t.pad_ctrl0_init_val\t= SUN4I_HDMI_PAD_CTRL0_TXEN |\n\t\t\t\t  SUN4I_HDMI_PAD_CTRL0_CKEN |\n\t\t\t\t  SUN4I_HDMI_PAD_CTRL0_PWENG |\n\t\t\t\t  SUN4I_HDMI_PAD_CTRL0_PWEND |\n\t\t\t\t  SUN4I_HDMI_PAD_CTRL0_PWENC |\n\t\t\t\t  SUN4I_HDMI_PAD_CTRL0_LDODEN |\n\t\t\t\t  SUN4I_HDMI_PAD_CTRL0_LDOCEN |\n\t\t\t\t  SUN4I_HDMI_PAD_CTRL0_BIASEN,\n\t.pad_ctrl1_init_val\t= SUN4I_HDMI_PAD_CTRL1_REG_AMP(4) |\n\t\t\t\t  SUN4I_HDMI_PAD_CTRL1_REG_EMP(2) |\n\t\t\t\t  SUN4I_HDMI_PAD_CTRL1_REG_DENCK |\n\t\t\t\t  SUN4I_HDMI_PAD_CTRL1_REG_DEN |\n\t\t\t\t  SUN4I_HDMI_PAD_CTRL1_EMPCK_OPT |\n\t\t\t\t  SUN4I_HDMI_PAD_CTRL1_EMP_OPT |\n\t\t\t\t  SUN4I_HDMI_PAD_CTRL1_AMPCK_OPT |\n\t\t\t\t  SUN4I_HDMI_PAD_CTRL1_AMP_OPT,\n\t.pll_ctrl_init_val\t= SUN4I_HDMI_PLL_CTRL_VCO_S(8) |\n\t\t\t\t  SUN4I_HDMI_PLL_CTRL_CS(7) |\n\t\t\t\t  SUN4I_HDMI_PLL_CTRL_CP_S(15) |\n\t\t\t\t  SUN4I_HDMI_PLL_CTRL_S(7) |\n\t\t\t\t  SUN4I_HDMI_PLL_CTRL_VCO_GAIN(4) |\n\t\t\t\t  SUN4I_HDMI_PLL_CTRL_SDIV2 |\n\t\t\t\t  SUN4I_HDMI_PLL_CTRL_LDO2_EN |\n\t\t\t\t  SUN4I_HDMI_PLL_CTRL_LDO1_EN |\n\t\t\t\t  SUN4I_HDMI_PLL_CTRL_HV_IS_33 |\n\t\t\t\t  SUN4I_HDMI_PLL_CTRL_BWS |\n\t\t\t\t  SUN4I_HDMI_PLL_CTRL_PLL_EN,\n\n\t.ddc_clk_reg\t\t= REG_FIELD(SUN4I_HDMI_DDC_CLK_REG, 0, 6),\n\t.ddc_clk_pre_divider\t= 2,\n\t.ddc_clk_m_offset\t= 1,\n\n\t.field_ddc_en\t\t= REG_FIELD(SUN4I_HDMI_DDC_CTRL_REG, 31, 31),\n\t.field_ddc_start\t= REG_FIELD(SUN4I_HDMI_DDC_CTRL_REG, 30, 30),\n\t.field_ddc_reset\t= REG_FIELD(SUN4I_HDMI_DDC_CTRL_REG, 0, 0),\n\t.field_ddc_addr_reg\t= REG_FIELD(SUN4I_HDMI_DDC_ADDR_REG, 0, 31),\n\t.field_ddc_slave_addr\t= REG_FIELD(SUN4I_HDMI_DDC_ADDR_REG, 0, 6),\n\t.field_ddc_int_status\t= REG_FIELD(SUN4I_HDMI_DDC_INT_STATUS_REG, 0, 8),\n\t.field_ddc_fifo_clear\t= REG_FIELD(SUN4I_HDMI_DDC_FIFO_CTRL_REG, 31, 31),\n\t.field_ddc_fifo_rx_thres = REG_FIELD(SUN4I_HDMI_DDC_FIFO_CTRL_REG, 4, 7),\n\t.field_ddc_fifo_tx_thres = REG_FIELD(SUN4I_HDMI_DDC_FIFO_CTRL_REG, 0, 3),\n\t.field_ddc_byte_count\t= REG_FIELD(SUN4I_HDMI_DDC_BYTE_COUNT_REG, 0, 9),\n\t.field_ddc_cmd\t\t= REG_FIELD(SUN4I_HDMI_DDC_CMD_REG, 0, 2),\n\t.field_ddc_sda_en\t= REG_FIELD(SUN4I_HDMI_DDC_LINE_CTRL_REG, 9, 9),\n\t.field_ddc_sck_en\t= REG_FIELD(SUN4I_HDMI_DDC_LINE_CTRL_REG, 8, 8),\n\n\t.ddc_fifo_reg\t\t= SUN4I_HDMI_DDC_FIFO_DATA_REG,\n\t.ddc_fifo_has_dir\t= true,\n};\n\nstatic const struct sun4i_hdmi_variant sun5i_variant = {\n\t.pad_ctrl0_init_val\t= SUN4I_HDMI_PAD_CTRL0_TXEN |\n\t\t\t\t  SUN4I_HDMI_PAD_CTRL0_CKEN |\n\t\t\t\t  SUN4I_HDMI_PAD_CTRL0_PWENG |\n\t\t\t\t  SUN4I_HDMI_PAD_CTRL0_PWEND |\n\t\t\t\t  SUN4I_HDMI_PAD_CTRL0_PWENC |\n\t\t\t\t  SUN4I_HDMI_PAD_CTRL0_LDODEN |\n\t\t\t\t  SUN4I_HDMI_PAD_CTRL0_LDOCEN |\n\t\t\t\t  SUN4I_HDMI_PAD_CTRL0_BIASEN,\n\t.pad_ctrl1_init_val\t= SUN4I_HDMI_PAD_CTRL1_REG_AMP(6) |\n\t\t\t\t  SUN4I_HDMI_PAD_CTRL1_REG_EMP(2) |\n\t\t\t\t  SUN4I_HDMI_PAD_CTRL1_REG_DENCK |\n\t\t\t\t  SUN4I_HDMI_PAD_CTRL1_REG_DEN |\n\t\t\t\t  SUN4I_HDMI_PAD_CTRL1_EMPCK_OPT |\n\t\t\t\t  SUN4I_HDMI_PAD_CTRL1_EMP_OPT |\n\t\t\t\t  SUN4I_HDMI_PAD_CTRL1_AMPCK_OPT |\n\t\t\t\t  SUN4I_HDMI_PAD_CTRL1_AMP_OPT,\n\t.pll_ctrl_init_val\t= SUN4I_HDMI_PLL_CTRL_VCO_S(8) |\n\t\t\t\t  SUN4I_HDMI_PLL_CTRL_CS(7) |\n\t\t\t\t  SUN4I_HDMI_PLL_CTRL_CP_S(15) |\n\t\t\t\t  SUN4I_HDMI_PLL_CTRL_S(7) |\n\t\t\t\t  SUN4I_HDMI_PLL_CTRL_VCO_GAIN(4) |\n\t\t\t\t  SUN4I_HDMI_PLL_CTRL_SDIV2 |\n\t\t\t\t  SUN4I_HDMI_PLL_CTRL_LDO2_EN |\n\t\t\t\t  SUN4I_HDMI_PLL_CTRL_LDO1_EN |\n\t\t\t\t  SUN4I_HDMI_PLL_CTRL_HV_IS_33 |\n\t\t\t\t  SUN4I_HDMI_PLL_CTRL_BWS |\n\t\t\t\t  SUN4I_HDMI_PLL_CTRL_PLL_EN,\n\n\t.ddc_clk_reg\t\t= REG_FIELD(SUN4I_HDMI_DDC_CLK_REG, 0, 6),\n\t.ddc_clk_pre_divider\t= 2,\n\t.ddc_clk_m_offset\t= 1,\n\n\t.field_ddc_en\t\t= REG_FIELD(SUN4I_HDMI_DDC_CTRL_REG, 31, 31),\n\t.field_ddc_start\t= REG_FIELD(SUN4I_HDMI_DDC_CTRL_REG, 30, 30),\n\t.field_ddc_reset\t= REG_FIELD(SUN4I_HDMI_DDC_CTRL_REG, 0, 0),\n\t.field_ddc_addr_reg\t= REG_FIELD(SUN4I_HDMI_DDC_ADDR_REG, 0, 31),\n\t.field_ddc_slave_addr\t= REG_FIELD(SUN4I_HDMI_DDC_ADDR_REG, 0, 6),\n\t.field_ddc_int_status\t= REG_FIELD(SUN4I_HDMI_DDC_INT_STATUS_REG, 0, 8),\n\t.field_ddc_fifo_clear\t= REG_FIELD(SUN4I_HDMI_DDC_FIFO_CTRL_REG, 31, 31),\n\t.field_ddc_fifo_rx_thres = REG_FIELD(SUN4I_HDMI_DDC_FIFO_CTRL_REG, 4, 7),\n\t.field_ddc_fifo_tx_thres = REG_FIELD(SUN4I_HDMI_DDC_FIFO_CTRL_REG, 0, 3),\n\t.field_ddc_byte_count\t= REG_FIELD(SUN4I_HDMI_DDC_BYTE_COUNT_REG, 0, 9),\n\t.field_ddc_cmd\t\t= REG_FIELD(SUN4I_HDMI_DDC_CMD_REG, 0, 2),\n\t.field_ddc_sda_en\t= REG_FIELD(SUN4I_HDMI_DDC_LINE_CTRL_REG, 9, 9),\n\t.field_ddc_sck_en\t= REG_FIELD(SUN4I_HDMI_DDC_LINE_CTRL_REG, 8, 8),\n\n\t.ddc_fifo_reg\t\t= SUN4I_HDMI_DDC_FIFO_DATA_REG,\n\t.ddc_fifo_has_dir\t= true,\n};\n\nstatic const struct sun4i_hdmi_variant sun6i_variant = {\n\t.has_ddc_parent_clk\t= true,\n\t.has_reset_control\t= true,\n\t.pad_ctrl0_init_val\t= 0xff |\n\t\t\t\t  SUN4I_HDMI_PAD_CTRL0_TXEN |\n\t\t\t\t  SUN4I_HDMI_PAD_CTRL0_CKEN |\n\t\t\t\t  SUN4I_HDMI_PAD_CTRL0_PWENG |\n\t\t\t\t  SUN4I_HDMI_PAD_CTRL0_PWEND |\n\t\t\t\t  SUN4I_HDMI_PAD_CTRL0_PWENC |\n\t\t\t\t  SUN4I_HDMI_PAD_CTRL0_LDODEN |\n\t\t\t\t  SUN4I_HDMI_PAD_CTRL0_LDOCEN,\n\t.pad_ctrl1_init_val\t= SUN4I_HDMI_PAD_CTRL1_REG_AMP(6) |\n\t\t\t\t  SUN4I_HDMI_PAD_CTRL1_REG_EMP(4) |\n\t\t\t\t  SUN4I_HDMI_PAD_CTRL1_REG_DENCK |\n\t\t\t\t  SUN4I_HDMI_PAD_CTRL1_REG_DEN |\n\t\t\t\t  SUN4I_HDMI_PAD_CTRL1_EMPCK_OPT |\n\t\t\t\t  SUN4I_HDMI_PAD_CTRL1_EMP_OPT |\n\t\t\t\t  SUN4I_HDMI_PAD_CTRL1_PWSDT |\n\t\t\t\t  SUN4I_HDMI_PAD_CTRL1_PWSCK |\n\t\t\t\t  SUN4I_HDMI_PAD_CTRL1_AMPCK_OPT |\n\t\t\t\t  SUN4I_HDMI_PAD_CTRL1_AMP_OPT |\n\t\t\t\t  SUN4I_HDMI_PAD_CTRL1_UNKNOWN,\n\t.pll_ctrl_init_val\t= SUN4I_HDMI_PLL_CTRL_VCO_S(8) |\n\t\t\t\t  SUN4I_HDMI_PLL_CTRL_CS(3) |\n\t\t\t\t  SUN4I_HDMI_PLL_CTRL_CP_S(10) |\n\t\t\t\t  SUN4I_HDMI_PLL_CTRL_S(4) |\n\t\t\t\t  SUN4I_HDMI_PLL_CTRL_VCO_GAIN(4) |\n\t\t\t\t  SUN4I_HDMI_PLL_CTRL_SDIV2 |\n\t\t\t\t  SUN4I_HDMI_PLL_CTRL_LDO2_EN |\n\t\t\t\t  SUN4I_HDMI_PLL_CTRL_LDO1_EN |\n\t\t\t\t  SUN4I_HDMI_PLL_CTRL_HV_IS_33 |\n\t\t\t\t  SUN4I_HDMI_PLL_CTRL_PLL_EN,\n\n\t.ddc_clk_reg\t\t= REG_FIELD(SUN6I_HDMI_DDC_CLK_REG, 0, 6),\n\t.ddc_clk_pre_divider\t= 1,\n\t.ddc_clk_m_offset\t= 2,\n\n\t.tmds_clk_div_offset\t= 1,\n\n\t.field_ddc_en\t\t= REG_FIELD(SUN6I_HDMI_DDC_CTRL_REG, 0, 0),\n\t.field_ddc_start\t= REG_FIELD(SUN6I_HDMI_DDC_CTRL_REG, 27, 27),\n\t.field_ddc_reset\t= REG_FIELD(SUN6I_HDMI_DDC_CTRL_REG, 31, 31),\n\t.field_ddc_addr_reg\t= REG_FIELD(SUN6I_HDMI_DDC_ADDR_REG, 1, 31),\n\t.field_ddc_slave_addr\t= REG_FIELD(SUN6I_HDMI_DDC_ADDR_REG, 1, 7),\n\t.field_ddc_int_status\t= REG_FIELD(SUN6I_HDMI_DDC_INT_STATUS_REG, 0, 8),\n\t.field_ddc_fifo_clear\t= REG_FIELD(SUN6I_HDMI_DDC_FIFO_CTRL_REG, 18, 18),\n\t.field_ddc_fifo_rx_thres = REG_FIELD(SUN6I_HDMI_DDC_FIFO_CTRL_REG, 4, 7),\n\t.field_ddc_fifo_tx_thres = REG_FIELD(SUN6I_HDMI_DDC_FIFO_CTRL_REG, 0, 3),\n\t.field_ddc_byte_count\t= REG_FIELD(SUN6I_HDMI_DDC_CMD_REG, 16, 25),\n\t.field_ddc_cmd\t\t= REG_FIELD(SUN6I_HDMI_DDC_CMD_REG, 0, 2),\n\t.field_ddc_sda_en\t= REG_FIELD(SUN6I_HDMI_DDC_CTRL_REG, 6, 6),\n\t.field_ddc_sck_en\t= REG_FIELD(SUN6I_HDMI_DDC_CTRL_REG, 4, 4),\n\n\t.ddc_fifo_reg\t\t= SUN6I_HDMI_DDC_FIFO_DATA_REG,\n\t.ddc_fifo_thres_incl\t= true,\n};\n\nstatic const struct regmap_config sun4i_hdmi_regmap_config = {\n\t.reg_bits\t= 32,\n\t.val_bits\t= 32,\n\t.reg_stride\t= 4,\n\t.max_register\t= 0x580,\n};\n\nstatic int sun4i_hdmi_bind(struct device *dev, struct device *master,\n\t\t\t   void *data)\n{\n\tstruct platform_device *pdev = to_platform_device(dev);\n\tstruct drm_device *drm = data;\n\tstruct cec_connector_info conn_info;\n\tstruct sun4i_drv *drv = drm->dev_private;\n\tstruct sun4i_hdmi *hdmi;\n\tu32 reg;\n\tint ret;\n\n\thdmi = devm_kzalloc(dev, sizeof(*hdmi), GFP_KERNEL);\n\tif (!hdmi)\n\t\treturn -ENOMEM;\n\tdev_set_drvdata(dev, hdmi);\n\thdmi->dev = dev;\n\thdmi->drv = drv;\n\n\thdmi->variant = of_device_get_match_data(dev);\n\tif (!hdmi->variant)\n\t\treturn -EINVAL;\n\n\thdmi->base = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(hdmi->base)) {\n\t\tdev_err(dev, \"Couldn't map the HDMI encoder registers\\n\");\n\t\treturn PTR_ERR(hdmi->base);\n\t}\n\n\tif (hdmi->variant->has_reset_control) {\n\t\thdmi->reset = devm_reset_control_get(dev, NULL);\n\t\tif (IS_ERR(hdmi->reset)) {\n\t\t\tdev_err(dev, \"Couldn't get the HDMI reset control\\n\");\n\t\t\treturn PTR_ERR(hdmi->reset);\n\t\t}\n\n\t\tret = reset_control_deassert(hdmi->reset);\n\t\tif (ret) {\n\t\t\tdev_err(dev, \"Couldn't deassert HDMI reset\\n\");\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\thdmi->bus_clk = devm_clk_get(dev, \"ahb\");\n\tif (IS_ERR(hdmi->bus_clk)) {\n\t\tdev_err(dev, \"Couldn't get the HDMI bus clock\\n\");\n\t\tret = PTR_ERR(hdmi->bus_clk);\n\t\tgoto err_assert_reset;\n\t}\n\tclk_prepare_enable(hdmi->bus_clk);\n\n\thdmi->mod_clk = devm_clk_get(dev, \"mod\");\n\tif (IS_ERR(hdmi->mod_clk)) {\n\t\tdev_err(dev, \"Couldn't get the HDMI mod clock\\n\");\n\t\tret = PTR_ERR(hdmi->mod_clk);\n\t\tgoto err_disable_bus_clk;\n\t}\n\tclk_prepare_enable(hdmi->mod_clk);\n\n\thdmi->pll0_clk = devm_clk_get(dev, \"pll-0\");\n\tif (IS_ERR(hdmi->pll0_clk)) {\n\t\tdev_err(dev, \"Couldn't get the HDMI PLL 0 clock\\n\");\n\t\tret = PTR_ERR(hdmi->pll0_clk);\n\t\tgoto err_disable_mod_clk;\n\t}\n\n\thdmi->pll1_clk = devm_clk_get(dev, \"pll-1\");\n\tif (IS_ERR(hdmi->pll1_clk)) {\n\t\tdev_err(dev, \"Couldn't get the HDMI PLL 1 clock\\n\");\n\t\tret = PTR_ERR(hdmi->pll1_clk);\n\t\tgoto err_disable_mod_clk;\n\t}\n\n\thdmi->regmap = devm_regmap_init_mmio(dev, hdmi->base,\n\t\t\t\t\t     &sun4i_hdmi_regmap_config);\n\tif (IS_ERR(hdmi->regmap)) {\n\t\tdev_err(dev, \"Couldn't create HDMI encoder regmap\\n\");\n\t\tret = PTR_ERR(hdmi->regmap);\n\t\tgoto err_disable_mod_clk;\n\t}\n\n\tret = sun4i_tmds_create(hdmi);\n\tif (ret) {\n\t\tdev_err(dev, \"Couldn't create the TMDS clock\\n\");\n\t\tgoto err_disable_mod_clk;\n\t}\n\n\tif (hdmi->variant->has_ddc_parent_clk) {\n\t\thdmi->ddc_parent_clk = devm_clk_get(dev, \"ddc\");\n\t\tif (IS_ERR(hdmi->ddc_parent_clk)) {\n\t\t\tdev_err(dev, \"Couldn't get the HDMI DDC clock\\n\");\n\t\t\tret = PTR_ERR(hdmi->ddc_parent_clk);\n\t\t\tgoto err_disable_mod_clk;\n\t\t}\n\t} else {\n\t\thdmi->ddc_parent_clk = hdmi->tmds_clk;\n\t}\n\n\twritel(SUN4I_HDMI_CTRL_ENABLE, hdmi->base + SUN4I_HDMI_CTRL_REG);\n\n\twritel(hdmi->variant->pad_ctrl0_init_val,\n\t       hdmi->base + SUN4I_HDMI_PAD_CTRL0_REG);\n\n\treg = readl(hdmi->base + SUN4I_HDMI_PLL_CTRL_REG);\n\treg &= SUN4I_HDMI_PLL_CTRL_DIV_MASK;\n\treg |= hdmi->variant->pll_ctrl_init_val;\n\twritel(reg, hdmi->base + SUN4I_HDMI_PLL_CTRL_REG);\n\n\tret = sun4i_hdmi_i2c_create(dev, hdmi);\n\tif (ret) {\n\t\tdev_err(dev, \"Couldn't create the HDMI I2C adapter\\n\");\n\t\tgoto err_disable_mod_clk;\n\t}\n\n\thdmi->ddc_i2c = sun4i_hdmi_get_ddc(dev);\n\tif (IS_ERR(hdmi->ddc_i2c)) {\n\t\tret = PTR_ERR(hdmi->ddc_i2c);\n\t\tif (ret == -ENODEV)\n\t\t\thdmi->ddc_i2c = NULL;\n\t\telse\n\t\t\tgoto err_del_i2c_adapter;\n\t}\n\n\tdrm_encoder_helper_add(&hdmi->encoder,\n\t\t\t       &sun4i_hdmi_helper_funcs);\n\tret = drm_simple_encoder_init(drm, &hdmi->encoder,\n\t\t\t\t      DRM_MODE_ENCODER_TMDS);\n\tif (ret) {\n\t\tdev_err(dev, \"Couldn't initialise the HDMI encoder\\n\");\n\t\tgoto err_put_ddc_i2c;\n\t}\n\n\thdmi->encoder.possible_crtcs = drm_of_find_possible_crtcs(drm,\n\t\t\t\t\t\t\t\t  dev->of_node);\n\tif (!hdmi->encoder.possible_crtcs) {\n\t\tret = -EPROBE_DEFER;\n\t\tgoto err_put_ddc_i2c;\n\t}\n\n#ifdef CONFIG_DRM_SUN4I_HDMI_CEC\n\thdmi->cec_adap = cec_pin_allocate_adapter(&sun4i_hdmi_cec_pin_ops,\n\t\thdmi, \"sun4i\", CEC_CAP_DEFAULTS | CEC_CAP_CONNECTOR_INFO);\n\tret = PTR_ERR_OR_ZERO(hdmi->cec_adap);\n\tif (ret < 0)\n\t\tgoto err_cleanup_connector;\n\twritel(readl(hdmi->base + SUN4I_HDMI_CEC) & ~SUN4I_HDMI_CEC_TX,\n\t       hdmi->base + SUN4I_HDMI_CEC);\n#endif\n\n\tdrm_connector_helper_add(&hdmi->connector,\n\t\t\t\t &sun4i_hdmi_connector_helper_funcs);\n\tret = drm_connector_init_with_ddc(drm, &hdmi->connector,\n\t\t\t\t\t  &sun4i_hdmi_connector_funcs,\n\t\t\t\t\t  DRM_MODE_CONNECTOR_HDMIA,\n\t\t\t\t\t  hdmi->ddc_i2c);\n\tif (ret) {\n\t\tdev_err(dev,\n\t\t\t\"Couldn't initialise the HDMI connector\\n\");\n\t\tgoto err_cleanup_connector;\n\t}\n\tcec_fill_conn_info_from_drm(&conn_info, &hdmi->connector);\n\tcec_s_conn_info(hdmi->cec_adap, &conn_info);\n\n\t \n\thdmi->connector.polled = DRM_CONNECTOR_POLL_CONNECT |\n\t\tDRM_CONNECTOR_POLL_DISCONNECT;\n\n\tret = cec_register_adapter(hdmi->cec_adap, dev);\n\tif (ret < 0)\n\t\tgoto err_cleanup_connector;\n\tdrm_connector_attach_encoder(&hdmi->connector, &hdmi->encoder);\n\n\treturn 0;\n\nerr_cleanup_connector:\n\tcec_delete_adapter(hdmi->cec_adap);\n\tdrm_encoder_cleanup(&hdmi->encoder);\nerr_put_ddc_i2c:\n\ti2c_put_adapter(hdmi->ddc_i2c);\nerr_del_i2c_adapter:\n\ti2c_del_adapter(hdmi->i2c);\nerr_disable_mod_clk:\n\tclk_disable_unprepare(hdmi->mod_clk);\nerr_disable_bus_clk:\n\tclk_disable_unprepare(hdmi->bus_clk);\nerr_assert_reset:\n\treset_control_assert(hdmi->reset);\n\treturn ret;\n}\n\nstatic void sun4i_hdmi_unbind(struct device *dev, struct device *master,\n\t\t\t    void *data)\n{\n\tstruct sun4i_hdmi *hdmi = dev_get_drvdata(dev);\n\n\tcec_unregister_adapter(hdmi->cec_adap);\n\ti2c_del_adapter(hdmi->i2c);\n\ti2c_put_adapter(hdmi->ddc_i2c);\n\tclk_disable_unprepare(hdmi->mod_clk);\n\tclk_disable_unprepare(hdmi->bus_clk);\n}\n\nstatic const struct component_ops sun4i_hdmi_ops = {\n\t.bind\t= sun4i_hdmi_bind,\n\t.unbind\t= sun4i_hdmi_unbind,\n};\n\nstatic int sun4i_hdmi_probe(struct platform_device *pdev)\n{\n\treturn component_add(&pdev->dev, &sun4i_hdmi_ops);\n}\n\nstatic void sun4i_hdmi_remove(struct platform_device *pdev)\n{\n\tcomponent_del(&pdev->dev, &sun4i_hdmi_ops);\n}\n\nstatic const struct of_device_id sun4i_hdmi_of_table[] = {\n\t{ .compatible = \"allwinner,sun4i-a10-hdmi\", .data = &sun4i_variant, },\n\t{ .compatible = \"allwinner,sun5i-a10s-hdmi\", .data = &sun5i_variant, },\n\t{ .compatible = \"allwinner,sun6i-a31-hdmi\", .data = &sun6i_variant, },\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, sun4i_hdmi_of_table);\n\nstatic struct platform_driver sun4i_hdmi_driver = {\n\t.probe\t\t= sun4i_hdmi_probe,\n\t.remove_new\t= sun4i_hdmi_remove,\n\t.driver\t\t= {\n\t\t.name\t\t= \"sun4i-hdmi\",\n\t\t.of_match_table\t= sun4i_hdmi_of_table,\n\t},\n};\nmodule_platform_driver(sun4i_hdmi_driver);\n\nMODULE_AUTHOR(\"Maxime Ripard <maxime.ripard@free-electrons.com>\");\nMODULE_DESCRIPTION(\"Allwinner A10 HDMI Driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}