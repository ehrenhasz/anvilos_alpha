{
  "module_name": "sun4i_layer.c",
  "hash_id": "fc13a3ade2c6e90ca5c62abb299ae73fab04e93a05e7ae516f9ce79dec96f1b9",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/sun4i/sun4i_layer.c",
  "human_readable_source": "\n \n\n#include <drm/drm_atomic.h>\n#include <drm/drm_atomic_helper.h>\n#include <drm/drm_blend.h>\n#include <drm/drm_gem_atomic_helper.h>\n\n#include \"sun4i_backend.h\"\n#include \"sun4i_frontend.h\"\n#include \"sun4i_layer.h\"\n#include \"sunxi_engine.h\"\n\nstatic void sun4i_backend_layer_reset(struct drm_plane *plane)\n{\n\tstruct sun4i_layer_state *state;\n\n\tif (plane->state) {\n\t\tstate = state_to_sun4i_layer_state(plane->state);\n\n\t\t__drm_atomic_helper_plane_destroy_state(&state->state);\n\n\t\tkfree(state);\n\t\tplane->state = NULL;\n\t}\n\n\tstate = kzalloc(sizeof(*state), GFP_KERNEL);\n\tif (state)\n\t\t__drm_atomic_helper_plane_reset(plane, &state->state);\n}\n\nstatic struct drm_plane_state *\nsun4i_backend_layer_duplicate_state(struct drm_plane *plane)\n{\n\tstruct sun4i_layer_state *orig = state_to_sun4i_layer_state(plane->state);\n\tstruct sun4i_layer_state *copy;\n\n\tcopy = kzalloc(sizeof(*copy), GFP_KERNEL);\n\tif (!copy)\n\t\treturn NULL;\n\n\t__drm_atomic_helper_plane_duplicate_state(plane, &copy->state);\n\tcopy->uses_frontend = orig->uses_frontend;\n\n\treturn &copy->state;\n}\n\nstatic void sun4i_backend_layer_destroy_state(struct drm_plane *plane,\n\t\t\t\t\t      struct drm_plane_state *state)\n{\n\tstruct sun4i_layer_state *s_state = state_to_sun4i_layer_state(state);\n\n\t__drm_atomic_helper_plane_destroy_state(state);\n\n\tkfree(s_state);\n}\n\nstatic void sun4i_backend_layer_atomic_disable(struct drm_plane *plane,\n\t\t\t\t\t       struct drm_atomic_state *state)\n{\n\tstruct drm_plane_state *old_state = drm_atomic_get_old_plane_state(state,\n\t\t\t\t\t\t\t\t\t   plane);\n\tstruct sun4i_layer_state *layer_state = state_to_sun4i_layer_state(old_state);\n\tstruct sun4i_layer *layer = plane_to_sun4i_layer(plane);\n\tstruct sun4i_backend *backend = layer->backend;\n\n\tsun4i_backend_layer_enable(backend, layer->id, false);\n\n\tif (layer_state->uses_frontend) {\n\t\tunsigned long flags;\n\n\t\tspin_lock_irqsave(&backend->frontend_lock, flags);\n\t\tbackend->frontend_teardown = true;\n\t\tspin_unlock_irqrestore(&backend->frontend_lock, flags);\n\t}\n}\n\nstatic void sun4i_backend_layer_atomic_update(struct drm_plane *plane,\n\t\t\t\t\t      struct drm_atomic_state *state)\n{\n\tstruct drm_plane_state *new_state = drm_atomic_get_new_plane_state(state,\n\t\t\t\t\t\t\t\t\t   plane);\n\tstruct sun4i_layer_state *layer_state = state_to_sun4i_layer_state(new_state);\n\tstruct sun4i_layer *layer = plane_to_sun4i_layer(plane);\n\tstruct sun4i_backend *backend = layer->backend;\n\tstruct sun4i_frontend *frontend = backend->frontend;\n\n\tsun4i_backend_cleanup_layer(backend, layer->id);\n\n\tif (layer_state->uses_frontend) {\n\t\tsun4i_frontend_init(frontend);\n\t\tsun4i_frontend_update_coord(frontend, plane);\n\t\tsun4i_frontend_update_buffer(frontend, plane);\n\t\tsun4i_frontend_update_formats(frontend, plane,\n\t\t\t\t\t      DRM_FORMAT_XRGB8888);\n\t\tsun4i_backend_update_layer_frontend(backend, layer->id,\n\t\t\t\t\t\t    DRM_FORMAT_XRGB8888);\n\t\tsun4i_frontend_enable(frontend);\n\t} else {\n\t\tsun4i_backend_update_layer_formats(backend, layer->id, plane);\n\t\tsun4i_backend_update_layer_buffer(backend, layer->id, plane);\n\t}\n\n\tsun4i_backend_update_layer_coord(backend, layer->id, plane);\n\tsun4i_backend_update_layer_zpos(backend, layer->id, plane);\n\tsun4i_backend_layer_enable(backend, layer->id, true);\n}\n\nstatic bool sun4i_layer_format_mod_supported(struct drm_plane *plane,\n\t\t\t\t\t     uint32_t format, uint64_t modifier)\n{\n\tstruct sun4i_layer *layer = plane_to_sun4i_layer(plane);\n\n\tif (IS_ERR_OR_NULL(layer->backend->frontend))\n\t\treturn sun4i_backend_format_is_supported(format, modifier);\n\n\treturn sun4i_backend_format_is_supported(format, modifier) ||\n\t       sun4i_frontend_format_is_supported(format, modifier);\n}\n\nstatic const struct drm_plane_helper_funcs sun4i_backend_layer_helper_funcs = {\n\t.atomic_disable\t= sun4i_backend_layer_atomic_disable,\n\t.atomic_update\t= sun4i_backend_layer_atomic_update,\n};\n\nstatic const struct drm_plane_funcs sun4i_backend_layer_funcs = {\n\t.atomic_destroy_state\t= sun4i_backend_layer_destroy_state,\n\t.atomic_duplicate_state\t= sun4i_backend_layer_duplicate_state,\n\t.destroy\t\t= drm_plane_cleanup,\n\t.disable_plane\t\t= drm_atomic_helper_disable_plane,\n\t.reset\t\t\t= sun4i_backend_layer_reset,\n\t.update_plane\t\t= drm_atomic_helper_update_plane,\n\t.format_mod_supported\t= sun4i_layer_format_mod_supported,\n};\n\nstatic const uint32_t sun4i_layer_formats[] = {\n\tDRM_FORMAT_ARGB8888,\n\tDRM_FORMAT_ARGB4444,\n\tDRM_FORMAT_ARGB1555,\n\tDRM_FORMAT_BGRX8888,\n\tDRM_FORMAT_RGBA5551,\n\tDRM_FORMAT_RGBA4444,\n\tDRM_FORMAT_RGB888,\n\tDRM_FORMAT_RGB565,\n\tDRM_FORMAT_NV12,\n\tDRM_FORMAT_NV16,\n\tDRM_FORMAT_NV21,\n\tDRM_FORMAT_NV61,\n\tDRM_FORMAT_UYVY,\n\tDRM_FORMAT_VYUY,\n\tDRM_FORMAT_XRGB8888,\n\tDRM_FORMAT_YUV411,\n\tDRM_FORMAT_YUV420,\n\tDRM_FORMAT_YUV422,\n\tDRM_FORMAT_YUV444,\n\tDRM_FORMAT_YUYV,\n\tDRM_FORMAT_YVU411,\n\tDRM_FORMAT_YVU420,\n\tDRM_FORMAT_YVU422,\n\tDRM_FORMAT_YVU444,\n\tDRM_FORMAT_YVYU,\n};\n\nstatic const uint32_t sun4i_backend_layer_formats[] = {\n\tDRM_FORMAT_ARGB8888,\n\tDRM_FORMAT_ARGB4444,\n\tDRM_FORMAT_ARGB1555,\n\tDRM_FORMAT_RGBA5551,\n\tDRM_FORMAT_RGBA4444,\n\tDRM_FORMAT_RGB888,\n\tDRM_FORMAT_RGB565,\n\tDRM_FORMAT_UYVY,\n\tDRM_FORMAT_VYUY,\n\tDRM_FORMAT_XRGB8888,\n\tDRM_FORMAT_YUYV,\n\tDRM_FORMAT_YVYU,\n};\n\nstatic const uint64_t sun4i_layer_modifiers[] = {\n\tDRM_FORMAT_MOD_LINEAR,\n\tDRM_FORMAT_MOD_ALLWINNER_TILED,\n\tDRM_FORMAT_MOD_INVALID\n};\n\nstatic struct sun4i_layer *sun4i_layer_init_one(struct drm_device *drm,\n\t\t\t\t\t\tstruct sun4i_backend *backend,\n\t\t\t\t\t\tenum drm_plane_type type,\n\t\t\t\t\t\tunsigned int id)\n{\n\tconst uint64_t *modifiers = sun4i_layer_modifiers;\n\tconst uint32_t *formats = sun4i_layer_formats;\n\tunsigned int formats_len = ARRAY_SIZE(sun4i_layer_formats);\n\tstruct sun4i_layer *layer;\n\tint ret;\n\n\tlayer = devm_kzalloc(drm->dev, sizeof(*layer), GFP_KERNEL);\n\tif (!layer)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tlayer->id = id;\n\tlayer->backend = backend;\n\n\tif (IS_ERR_OR_NULL(backend->frontend)) {\n\t\tformats = sun4i_backend_layer_formats;\n\t\tformats_len = ARRAY_SIZE(sun4i_backend_layer_formats);\n\t\tmodifiers = NULL;\n\t}\n\n\t \n\tret = drm_universal_plane_init(drm, &layer->plane, 0,\n\t\t\t\t       &sun4i_backend_layer_funcs,\n\t\t\t\t       formats, formats_len,\n\t\t\t\t       modifiers, type, NULL);\n\tif (ret) {\n\t\tdev_err(drm->dev, \"Couldn't initialize layer\\n\");\n\t\treturn ERR_PTR(ret);\n\t}\n\n\tdrm_plane_helper_add(&layer->plane,\n\t\t\t     &sun4i_backend_layer_helper_funcs);\n\n\tdrm_plane_create_alpha_property(&layer->plane);\n\tdrm_plane_create_zpos_property(&layer->plane, layer->id,\n\t\t\t\t       0, SUN4I_BACKEND_NUM_LAYERS - 1);\n\n\treturn layer;\n}\n\nstruct drm_plane **sun4i_layers_init(struct drm_device *drm,\n\t\t\t\t     struct sunxi_engine *engine)\n{\n\tstruct drm_plane **planes;\n\tstruct sun4i_backend *backend = engine_to_sun4i_backend(engine);\n\tint i;\n\n\t \n\tplanes = devm_kcalloc(drm->dev, SUN4I_BACKEND_NUM_LAYERS + 1,\n\t\t\t      sizeof(*planes), GFP_KERNEL);\n\tif (!planes)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tfor (i = 0; i < SUN4I_BACKEND_NUM_LAYERS; i++) {\n\t\tenum drm_plane_type type = i ? DRM_PLANE_TYPE_OVERLAY : DRM_PLANE_TYPE_PRIMARY;\n\t\tstruct sun4i_layer *layer;\n\n\t\tlayer = sun4i_layer_init_one(drm, backend, type, i);\n\t\tif (IS_ERR(layer)) {\n\t\t\tdev_err(drm->dev, \"Couldn't initialize %s plane\\n\",\n\t\t\t\ti ? \"overlay\" : \"primary\");\n\t\t\treturn ERR_CAST(layer);\n\t\t}\n\n\t\tplanes[i] = &layer->plane;\n\t}\n\n\treturn planes;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}