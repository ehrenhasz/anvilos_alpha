{
  "module_name": "qxl_drv.c",
  "hash_id": "0fd8e2ad74ee76b37036e765e476cd5668708ed01f2ea8db1c2ac12342185c37",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/qxl/qxl_drv.c",
  "human_readable_source": " \n\n#include \"qxl_drv.h\"\n\n#include <linux/module.h>\n#include <linux/pci.h>\n#include <linux/vgaarb.h>\n\n#include <drm/drm.h>\n#include <drm/drm_aperture.h>\n#include <drm/drm_atomic_helper.h>\n#include <drm/drm_drv.h>\n#include <drm/drm_fbdev_generic.h>\n#include <drm/drm_file.h>\n#include <drm/drm_gem_ttm_helper.h>\n#include <drm/drm_module.h>\n#include <drm/drm_modeset_helper.h>\n#include <drm/drm_prime.h>\n#include <drm/drm_probe_helper.h>\n\n#include \"qxl_object.h\"\n\nstatic const struct pci_device_id pciidlist[] = {\n\t{ 0x1b36, 0x100, PCI_ANY_ID, PCI_ANY_ID, PCI_CLASS_DISPLAY_VGA << 8,\n\t  0xffff00, 0 },\n\t{ 0x1b36, 0x100, PCI_ANY_ID, PCI_ANY_ID, PCI_CLASS_DISPLAY_OTHER << 8,\n\t  0xffff00, 0 },\n\t{ 0, 0, 0 },\n};\nMODULE_DEVICE_TABLE(pci, pciidlist);\n\nstatic int qxl_modeset = -1;\nint qxl_num_crtc = 4;\n\nMODULE_PARM_DESC(modeset, \"Disable/Enable modesetting\");\nmodule_param_named(modeset, qxl_modeset, int, 0400);\n\nMODULE_PARM_DESC(num_heads, \"Number of virtual crtcs to expose (default 4)\");\nmodule_param_named(num_heads, qxl_num_crtc, int, 0400);\n\nstatic struct drm_driver qxl_driver;\nstatic struct pci_driver qxl_pci_driver;\n\nstatic bool is_vga(struct pci_dev *pdev)\n{\n\treturn pdev->class == PCI_CLASS_DISPLAY_VGA << 8;\n}\n\nstatic int\nqxl_pci_probe(struct pci_dev *pdev, const struct pci_device_id *ent)\n{\n\tstruct qxl_device *qdev;\n\tint ret;\n\n\tif (pdev->revision < 4) {\n\t\tDRM_ERROR(\"qxl too old, doesn't support client_monitors_config,\"\n\t\t\t  \" use xf86-video-qxl in user mode\");\n\t\treturn -EINVAL;  \n\t}\n\n\tqdev = devm_drm_dev_alloc(&pdev->dev, &qxl_driver,\n\t\t\t\t  struct qxl_device, ddev);\n\tif (IS_ERR(qdev)) {\n\t\tpr_err(\"Unable to init drm dev\");\n\t\treturn -ENOMEM;\n\t}\n\n\tret = pci_enable_device(pdev);\n\tif (ret)\n\t\treturn ret;\n\n\tret = drm_aperture_remove_conflicting_pci_framebuffers(pdev, &qxl_driver);\n\tif (ret)\n\t\tgoto disable_pci;\n\n\tif (is_vga(pdev) && pdev->revision < 5) {\n\t\tret = vga_get_interruptible(pdev, VGA_RSRC_LEGACY_IO);\n\t\tif (ret) {\n\t\t\tDRM_ERROR(\"can't get legacy vga ioports\\n\");\n\t\t\tgoto disable_pci;\n\t\t}\n\t}\n\n\tret = qxl_device_init(qdev, pdev);\n\tif (ret)\n\t\tgoto put_vga;\n\n\tret = qxl_modeset_init(qdev);\n\tif (ret)\n\t\tgoto unload;\n\n\tdrm_kms_helper_poll_init(&qdev->ddev);\n\n\t \n\tret = drm_dev_register(&qdev->ddev, ent->driver_data);\n\tif (ret)\n\t\tgoto modeset_cleanup;\n\n\tdrm_fbdev_generic_setup(&qdev->ddev, 32);\n\treturn 0;\n\nmodeset_cleanup:\n\tqxl_modeset_fini(qdev);\nunload:\n\tqxl_device_fini(qdev);\nput_vga:\n\tif (is_vga(pdev) && pdev->revision < 5)\n\t\tvga_put(pdev, VGA_RSRC_LEGACY_IO);\ndisable_pci:\n\tpci_disable_device(pdev);\n\n\treturn ret;\n}\n\nstatic void qxl_drm_release(struct drm_device *dev)\n{\n\tstruct qxl_device *qdev = to_qxl(dev);\n\n\t \n\tqxl_modeset_fini(qdev);\n\tqxl_device_fini(qdev);\n}\n\nstatic void\nqxl_pci_remove(struct pci_dev *pdev)\n{\n\tstruct drm_device *dev = pci_get_drvdata(pdev);\n\n\tdrm_dev_unregister(dev);\n\tdrm_atomic_helper_shutdown(dev);\n\tif (is_vga(pdev) && pdev->revision < 5)\n\t\tvga_put(pdev, VGA_RSRC_LEGACY_IO);\n}\n\nDEFINE_DRM_GEM_FOPS(qxl_fops);\n\nstatic int qxl_drm_freeze(struct drm_device *dev)\n{\n\tstruct pci_dev *pdev = to_pci_dev(dev->dev);\n\tstruct qxl_device *qdev = to_qxl(dev);\n\tint ret;\n\n\tret = drm_mode_config_helper_suspend(dev);\n\tif (ret)\n\t\treturn ret;\n\n\tqxl_destroy_monitors_object(qdev);\n\tqxl_surf_evict(qdev);\n\tqxl_vram_evict(qdev);\n\n\twhile (!qxl_check_idle(qdev->command_ring));\n\twhile (!qxl_check_idle(qdev->release_ring))\n\t\tqxl_queue_garbage_collect(qdev, 1);\n\n\tpci_save_state(pdev);\n\n\treturn 0;\n}\n\nstatic int qxl_drm_resume(struct drm_device *dev, bool thaw)\n{\n\tstruct qxl_device *qdev = to_qxl(dev);\n\n\tqdev->ram_header->int_mask = QXL_INTERRUPT_MASK;\n\tif (!thaw) {\n\t\tqxl_reinit_memslots(qdev);\n\t}\n\n\tqxl_create_monitors_object(qdev);\n\treturn drm_mode_config_helper_resume(dev);\n}\n\nstatic int qxl_pm_suspend(struct device *dev)\n{\n\tstruct pci_dev *pdev = to_pci_dev(dev);\n\tstruct drm_device *drm_dev = pci_get_drvdata(pdev);\n\tint error;\n\n\terror = qxl_drm_freeze(drm_dev);\n\tif (error)\n\t\treturn error;\n\n\tpci_disable_device(pdev);\n\tpci_set_power_state(pdev, PCI_D3hot);\n\treturn 0;\n}\n\nstatic int qxl_pm_resume(struct device *dev)\n{\n\tstruct pci_dev *pdev = to_pci_dev(dev);\n\tstruct drm_device *drm_dev = pci_get_drvdata(pdev);\n\tstruct qxl_device *qdev = to_qxl(drm_dev);\n\n\tpci_set_power_state(pdev, PCI_D0);\n\tpci_restore_state(pdev);\n\tif (pci_enable_device(pdev)) {\n\t\treturn -EIO;\n\t}\n\n\tqxl_io_reset(qdev);\n\treturn qxl_drm_resume(drm_dev, false);\n}\n\nstatic int qxl_pm_thaw(struct device *dev)\n{\n\tstruct drm_device *drm_dev = dev_get_drvdata(dev);\n\n\treturn qxl_drm_resume(drm_dev, true);\n}\n\nstatic int qxl_pm_freeze(struct device *dev)\n{\n\tstruct drm_device *drm_dev = dev_get_drvdata(dev);\n\n\treturn qxl_drm_freeze(drm_dev);\n}\n\nstatic int qxl_pm_restore(struct device *dev)\n{\n\tstruct pci_dev *pdev = to_pci_dev(dev);\n\tstruct drm_device *drm_dev = pci_get_drvdata(pdev);\n\tstruct qxl_device *qdev = to_qxl(drm_dev);\n\n\tqxl_io_reset(qdev);\n\treturn qxl_drm_resume(drm_dev, false);\n}\n\nstatic const struct dev_pm_ops qxl_pm_ops = {\n\t.suspend = qxl_pm_suspend,\n\t.resume = qxl_pm_resume,\n\t.freeze = qxl_pm_freeze,\n\t.thaw = qxl_pm_thaw,\n\t.poweroff = qxl_pm_freeze,\n\t.restore = qxl_pm_restore,\n};\nstatic struct pci_driver qxl_pci_driver = {\n\t .name = DRIVER_NAME,\n\t .id_table = pciidlist,\n\t .probe = qxl_pci_probe,\n\t .remove = qxl_pci_remove,\n\t .driver.pm = &qxl_pm_ops,\n};\n\nstatic const struct drm_ioctl_desc qxl_ioctls[] = {\n\tDRM_IOCTL_DEF_DRV(QXL_ALLOC, qxl_alloc_ioctl, DRM_AUTH),\n\tDRM_IOCTL_DEF_DRV(QXL_MAP, qxl_map_ioctl, DRM_AUTH),\n\tDRM_IOCTL_DEF_DRV(QXL_EXECBUFFER, qxl_execbuffer_ioctl, DRM_AUTH),\n\tDRM_IOCTL_DEF_DRV(QXL_UPDATE_AREA, qxl_update_area_ioctl, DRM_AUTH),\n\tDRM_IOCTL_DEF_DRV(QXL_GETPARAM, qxl_getparam_ioctl, DRM_AUTH),\n\tDRM_IOCTL_DEF_DRV(QXL_CLIENTCAP, qxl_clientcap_ioctl, DRM_AUTH),\n\tDRM_IOCTL_DEF_DRV(QXL_ALLOC_SURF, qxl_alloc_surf_ioctl, DRM_AUTH),\n};\n\nstatic struct drm_driver qxl_driver = {\n\t.driver_features = DRIVER_GEM | DRIVER_MODESET | DRIVER_ATOMIC,\n\n\t.dumb_create = qxl_mode_dumb_create,\n\t.dumb_map_offset = drm_gem_ttm_dumb_map_offset,\n#if defined(CONFIG_DEBUG_FS)\n\t.debugfs_init = qxl_debugfs_init,\n#endif\n\t.gem_prime_import_sg_table = qxl_gem_prime_import_sg_table,\n\t.fops = &qxl_fops,\n\t.ioctls = qxl_ioctls,\n\t.num_ioctls = ARRAY_SIZE(qxl_ioctls),\n\t.name = DRIVER_NAME,\n\t.desc = DRIVER_DESC,\n\t.date = DRIVER_DATE,\n\t.major = 0,\n\t.minor = 1,\n\t.patchlevel = 0,\n\n\t.release = qxl_drm_release,\n};\n\ndrm_module_pci_driver_if_modeset(qxl_pci_driver, qxl_modeset);\n\nMODULE_AUTHOR(DRIVER_AUTHOR);\nMODULE_DESCRIPTION(DRIVER_DESC);\nMODULE_LICENSE(\"GPL and additional rights\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}