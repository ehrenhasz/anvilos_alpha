{
  "module_name": "qxl_draw.c",
  "hash_id": "c4737eb02ac053ba6bd768022c37430de3bcdb23f3348777a4f9f57ae2a31bec",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/qxl/qxl_draw.c",
  "human_readable_source": " \n\n#include <linux/iosys-map.h>\n\n#include <drm/drm_fourcc.h>\n#include <drm/drm_framebuffer.h>\n\n#include \"qxl_drv.h\"\n#include \"qxl_object.h\"\n\nstatic int alloc_clips(struct qxl_device *qdev,\n\t\t       struct qxl_release *release,\n\t\t       unsigned int num_clips,\n\t\t       struct qxl_bo **clips_bo)\n{\n\tint size = sizeof(struct qxl_clip_rects) + sizeof(struct qxl_rect) * num_clips;\n\n\treturn qxl_alloc_bo_reserved(qdev, release, size, clips_bo);\n}\n\n \nstatic struct qxl_rect *drawable_set_clipping(struct qxl_device *qdev,\n\t\t\t\t\t      unsigned int num_clips,\n\t\t\t\t\t      struct qxl_bo *clips_bo)\n{\n\tstruct iosys_map map;\n\tstruct qxl_clip_rects *dev_clips;\n\tint ret;\n\n\tret = qxl_bo_vmap_locked(clips_bo, &map);\n\tif (ret)\n\t\treturn NULL;\n\tdev_clips = map.vaddr;  \n\n\tdev_clips->num_rects = num_clips;\n\tdev_clips->chunk.next_chunk = 0;\n\tdev_clips->chunk.prev_chunk = 0;\n\tdev_clips->chunk.data_size = sizeof(struct qxl_rect) * num_clips;\n\treturn (struct qxl_rect *)dev_clips->chunk.data;\n}\n\nstatic int\nalloc_drawable(struct qxl_device *qdev, struct qxl_release **release)\n{\n\treturn qxl_alloc_release_reserved(qdev, sizeof(struct qxl_drawable),\n\t\t\t\t\t  QXL_RELEASE_DRAWABLE, release, NULL);\n}\n\nstatic void\nfree_drawable(struct qxl_device *qdev, struct qxl_release *release)\n{\n\tqxl_release_free(qdev, release);\n}\n\n \nstatic int\nmake_drawable(struct qxl_device *qdev, int surface, uint8_t type,\n\t      const struct qxl_rect *rect,\n\t      struct qxl_release *release)\n{\n\tstruct qxl_drawable *drawable;\n\tint i;\n\n\tdrawable = (struct qxl_drawable *)qxl_release_map(qdev, release);\n\tif (!drawable)\n\t\treturn -ENOMEM;\n\n\tdrawable->type = type;\n\n\tdrawable->surface_id = surface;\t\t \n\tdrawable->effect = QXL_EFFECT_OPAQUE;\n\tdrawable->self_bitmap = 0;\n\tdrawable->self_bitmap_area.top = 0;\n\tdrawable->self_bitmap_area.left = 0;\n\tdrawable->self_bitmap_area.bottom = 0;\n\tdrawable->self_bitmap_area.right = 0;\n\t \n\tdrawable->clip.type = SPICE_CLIP_TYPE_NONE;\n\n\t \n\tfor (i = 0; i < 3; ++i)\n\t\tdrawable->surfaces_dest[i] = -1;\n\n\tif (rect)\n\t\tdrawable->bbox = *rect;\n\n\tdrawable->mm_time = qdev->rom->mm_clock;\n\tqxl_release_unmap(qdev, release, &drawable->release_info);\n\treturn 0;\n}\n\n \nvoid qxl_draw_dirty_fb(struct qxl_device *qdev,\n\t\t       struct drm_framebuffer *fb,\n\t\t       struct qxl_bo *bo,\n\t\t       unsigned int flags, unsigned int color,\n\t\t       struct drm_clip_rect *clips,\n\t\t       unsigned int num_clips, int inc,\n\t\t       uint32_t dumb_shadow_offset)\n{\n\t \n\tstruct drm_clip_rect *clips_ptr;\n\tint i;\n\tint left, right, top, bottom;\n\tint width, height;\n\tstruct qxl_drawable *drawable;\n\tstruct qxl_rect drawable_rect;\n\tstruct qxl_rect *rects;\n\tint stride = fb->pitches[0];\n\t \n\tint depth = fb->format->cpp[0] * 8;\n\tstruct iosys_map surface_map;\n\tuint8_t *surface_base;\n\tstruct qxl_release *release;\n\tstruct qxl_bo *clips_bo;\n\tstruct qxl_drm_image *dimage;\n\tint ret;\n\n\tret = alloc_drawable(qdev, &release);\n\tif (ret)\n\t\treturn;\n\n\tclips->x1 += dumb_shadow_offset;\n\tclips->x2 += dumb_shadow_offset;\n\n\tleft = clips->x1;\n\tright = clips->x2;\n\ttop = clips->y1;\n\tbottom = clips->y2;\n\n\t \n\tfor (i = 1, clips_ptr = clips + inc;\n\t     i < num_clips; i++, clips_ptr += inc) {\n\t\tleft = min_t(int, left, (int)clips_ptr->x1);\n\t\tright = max_t(int, right, (int)clips_ptr->x2);\n\t\ttop = min_t(int, top, (int)clips_ptr->y1);\n\t\tbottom = max_t(int, bottom, (int)clips_ptr->y2);\n\t}\n\n\twidth = right - left;\n\theight = bottom - top;\n\n\tret = alloc_clips(qdev, release, num_clips, &clips_bo);\n\tif (ret)\n\t\tgoto out_free_drawable;\n\n\tret = qxl_image_alloc_objects(qdev, release,\n\t\t\t\t      &dimage,\n\t\t\t\t      height, stride);\n\tif (ret)\n\t\tgoto out_free_clips;\n\n\t \n\tret = qxl_release_reserve_list(release, true);\n\tif (ret)\n\t\tgoto out_free_image;\n\n\tdrawable_rect.left = left;\n\tdrawable_rect.right = right;\n\tdrawable_rect.top = top;\n\tdrawable_rect.bottom = bottom;\n\n\tret = make_drawable(qdev, 0, QXL_DRAW_COPY, &drawable_rect,\n\t\t\t    release);\n\tif (ret)\n\t\tgoto out_release_backoff;\n\n\tret = qxl_bo_vmap_locked(bo, &surface_map);\n\tif (ret)\n\t\tgoto out_release_backoff;\n\tsurface_base = surface_map.vaddr;  \n\n\tret = qxl_image_init(qdev, release, dimage, surface_base,\n\t\t\t     left - dumb_shadow_offset,\n\t\t\t     top, width, height, depth, stride);\n\tqxl_bo_vunmap_locked(bo);\n\tif (ret)\n\t\tgoto out_release_backoff;\n\n\trects = drawable_set_clipping(qdev, num_clips, clips_bo);\n\tif (!rects) {\n\t\tret = -EINVAL;\n\t\tgoto out_release_backoff;\n\t}\n\tdrawable = (struct qxl_drawable *)qxl_release_map(qdev, release);\n\n\tdrawable->clip.type = SPICE_CLIP_TYPE_RECTS;\n\tdrawable->clip.data = qxl_bo_physical_address(qdev,\n\t\t\t\t\t\t      clips_bo, 0);\n\n\tdrawable->u.copy.src_area.top = 0;\n\tdrawable->u.copy.src_area.bottom = height;\n\tdrawable->u.copy.src_area.left = 0;\n\tdrawable->u.copy.src_area.right = width;\n\n\tdrawable->u.copy.rop_descriptor = SPICE_ROPD_OP_PUT;\n\tdrawable->u.copy.scale_mode = 0;\n\tdrawable->u.copy.mask.flags = 0;\n\tdrawable->u.copy.mask.pos.x = 0;\n\tdrawable->u.copy.mask.pos.y = 0;\n\tdrawable->u.copy.mask.bitmap = 0;\n\n\tdrawable->u.copy.src_bitmap = qxl_bo_physical_address(qdev, dimage->bo, 0);\n\tqxl_release_unmap(qdev, release, &drawable->release_info);\n\n\tclips_ptr = clips;\n\tfor (i = 0; i < num_clips; i++, clips_ptr += inc) {\n\t\trects[i].left   = clips_ptr->x1;\n\t\trects[i].right  = clips_ptr->x2;\n\t\trects[i].top    = clips_ptr->y1;\n\t\trects[i].bottom = clips_ptr->y2;\n\t}\n\tqxl_bo_vunmap_locked(clips_bo);\n\n\tqxl_release_fence_buffer_objects(release);\n\tqxl_push_command_ring_release(qdev, release, QXL_CMD_DRAW, false);\n\nout_release_backoff:\n\tif (ret)\n\t\tqxl_release_backoff_reserve_list(release);\nout_free_image:\n\tqxl_image_free_objects(qdev, dimage);\nout_free_clips:\n\tqxl_bo_unref(&clips_bo);\nout_free_drawable:\n\t \n\tif (ret)\n\t\tfree_drawable(qdev, release);\n\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}