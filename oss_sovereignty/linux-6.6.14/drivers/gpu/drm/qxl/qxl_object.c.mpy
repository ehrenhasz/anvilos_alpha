{
  "module_name": "qxl_object.c",
  "hash_id": "b1429a4171d0ac9164befcb7482a4178e9794f6d9bbfe838f3191abae3aa63e5",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/qxl/qxl_object.c",
  "human_readable_source": " \n\n#include <linux/iosys-map.h>\n#include <linux/io-mapping.h>\n\n#include \"qxl_drv.h\"\n#include \"qxl_object.h\"\n\nstatic int __qxl_bo_pin(struct qxl_bo *bo);\nstatic void __qxl_bo_unpin(struct qxl_bo *bo);\n\nstatic void qxl_ttm_bo_destroy(struct ttm_buffer_object *tbo)\n{\n\tstruct qxl_bo *bo;\n\tstruct qxl_device *qdev;\n\n\tbo = to_qxl_bo(tbo);\n\tqdev = to_qxl(bo->tbo.base.dev);\n\n\tqxl_surface_evict(qdev, bo, false);\n\tWARN_ON_ONCE(bo->map_count > 0);\n\tmutex_lock(&qdev->gem.mutex);\n\tlist_del_init(&bo->list);\n\tmutex_unlock(&qdev->gem.mutex);\n\tdrm_gem_object_release(&bo->tbo.base);\n\tkfree(bo);\n}\n\nbool qxl_ttm_bo_is_qxl_bo(struct ttm_buffer_object *bo)\n{\n\tif (bo->destroy == &qxl_ttm_bo_destroy)\n\t\treturn true;\n\treturn false;\n}\n\nvoid qxl_ttm_placement_from_domain(struct qxl_bo *qbo, u32 domain)\n{\n\tu32 c = 0;\n\tu32 pflag = 0;\n\tunsigned int i;\n\n\tif (qbo->tbo.base.size <= PAGE_SIZE)\n\t\tpflag |= TTM_PL_FLAG_TOPDOWN;\n\n\tqbo->placement.placement = qbo->placements;\n\tqbo->placement.busy_placement = qbo->placements;\n\tif (domain == QXL_GEM_DOMAIN_VRAM) {\n\t\tqbo->placements[c].mem_type = TTM_PL_VRAM;\n\t\tqbo->placements[c++].flags = pflag;\n\t}\n\tif (domain == QXL_GEM_DOMAIN_SURFACE) {\n\t\tqbo->placements[c].mem_type = TTM_PL_PRIV;\n\t\tqbo->placements[c++].flags = pflag;\n\t\tqbo->placements[c].mem_type = TTM_PL_VRAM;\n\t\tqbo->placements[c++].flags = pflag;\n\t}\n\tif (domain == QXL_GEM_DOMAIN_CPU) {\n\t\tqbo->placements[c].mem_type = TTM_PL_SYSTEM;\n\t\tqbo->placements[c++].flags = pflag;\n\t}\n\tif (!c) {\n\t\tqbo->placements[c].mem_type = TTM_PL_SYSTEM;\n\t\tqbo->placements[c++].flags = 0;\n\t}\n\tqbo->placement.num_placement = c;\n\tqbo->placement.num_busy_placement = c;\n\tfor (i = 0; i < c; ++i) {\n\t\tqbo->placements[i].fpfn = 0;\n\t\tqbo->placements[i].lpfn = 0;\n\t}\n}\n\nstatic const struct drm_gem_object_funcs qxl_object_funcs = {\n\t.free = qxl_gem_object_free,\n\t.open = qxl_gem_object_open,\n\t.close = qxl_gem_object_close,\n\t.pin = qxl_gem_prime_pin,\n\t.unpin = qxl_gem_prime_unpin,\n\t.get_sg_table = qxl_gem_prime_get_sg_table,\n\t.vmap = qxl_gem_prime_vmap,\n\t.vunmap = qxl_gem_prime_vunmap,\n\t.mmap = drm_gem_ttm_mmap,\n\t.print_info = drm_gem_ttm_print_info,\n};\n\nint qxl_bo_create(struct qxl_device *qdev, unsigned long size,\n\t\t  bool kernel, bool pinned, u32 domain, u32 priority,\n\t\t  struct qxl_surface *surf,\n\t\t  struct qxl_bo **bo_ptr)\n{\n\tstruct ttm_operation_ctx ctx = { !kernel, false };\n\tstruct qxl_bo *bo;\n\tenum ttm_bo_type type;\n\tint r;\n\n\tif (kernel)\n\t\ttype = ttm_bo_type_kernel;\n\telse\n\t\ttype = ttm_bo_type_device;\n\t*bo_ptr = NULL;\n\tbo = kzalloc(sizeof(struct qxl_bo), GFP_KERNEL);\n\tif (bo == NULL)\n\t\treturn -ENOMEM;\n\tsize = roundup(size, PAGE_SIZE);\n\tr = drm_gem_object_init(&qdev->ddev, &bo->tbo.base, size);\n\tif (unlikely(r)) {\n\t\tkfree(bo);\n\t\treturn r;\n\t}\n\tbo->tbo.base.funcs = &qxl_object_funcs;\n\tbo->type = domain;\n\tbo->surface_id = 0;\n\tINIT_LIST_HEAD(&bo->list);\n\n\tif (surf)\n\t\tbo->surf = *surf;\n\n\tqxl_ttm_placement_from_domain(bo, domain);\n\n\tbo->tbo.priority = priority;\n\tr = ttm_bo_init_reserved(&qdev->mman.bdev, &bo->tbo, type,\n\t\t\t\t &bo->placement, 0, &ctx, NULL, NULL,\n\t\t\t\t &qxl_ttm_bo_destroy);\n\tif (unlikely(r != 0)) {\n\t\tif (r != -ERESTARTSYS)\n\t\t\tdev_err(qdev->ddev.dev,\n\t\t\t\t\"object_init failed for (%lu, 0x%08X)\\n\",\n\t\t\t\tsize, domain);\n\t\treturn r;\n\t}\n\tif (pinned)\n\t\tttm_bo_pin(&bo->tbo);\n\tttm_bo_unreserve(&bo->tbo);\n\t*bo_ptr = bo;\n\treturn 0;\n}\n\nint qxl_bo_vmap_locked(struct qxl_bo *bo, struct iosys_map *map)\n{\n\tint r;\n\n\tdma_resv_assert_held(bo->tbo.base.resv);\n\n\tif (bo->kptr) {\n\t\tbo->map_count++;\n\t\tgoto out;\n\t}\n\n\tr = __qxl_bo_pin(bo);\n\tif (r)\n\t\treturn r;\n\n\tr = ttm_bo_vmap(&bo->tbo, &bo->map);\n\tif (r) {\n\t\t__qxl_bo_unpin(bo);\n\t\treturn r;\n\t}\n\tbo->map_count = 1;\n\n\t \n\tif (bo->map.is_iomem)\n\t\tbo->kptr = (void *)bo->map.vaddr_iomem;\n\telse\n\t\tbo->kptr = bo->map.vaddr;\n\nout:\n\t*map = bo->map;\n\treturn 0;\n}\n\nint qxl_bo_vmap(struct qxl_bo *bo, struct iosys_map *map)\n{\n\tint r;\n\n\tr = qxl_bo_reserve(bo);\n\tif (r)\n\t\treturn r;\n\n\tr = qxl_bo_vmap_locked(bo, map);\n\tqxl_bo_unreserve(bo);\n\treturn r;\n}\n\nvoid *qxl_bo_kmap_atomic_page(struct qxl_device *qdev,\n\t\t\t      struct qxl_bo *bo, int page_offset)\n{\n\tunsigned long offset;\n\tvoid *rptr;\n\tint ret;\n\tstruct io_mapping *map;\n\tstruct iosys_map bo_map;\n\n\tif (bo->tbo.resource->mem_type == TTM_PL_VRAM)\n\t\tmap = qdev->vram_mapping;\n\telse if (bo->tbo.resource->mem_type == TTM_PL_PRIV)\n\t\tmap = qdev->surface_mapping;\n\telse\n\t\tgoto fallback;\n\n\toffset = bo->tbo.resource->start << PAGE_SHIFT;\n\treturn io_mapping_map_atomic_wc(map, offset + page_offset);\nfallback:\n\tif (bo->kptr) {\n\t\trptr = bo->kptr + (page_offset * PAGE_SIZE);\n\t\treturn rptr;\n\t}\n\n\tret = qxl_bo_vmap_locked(bo, &bo_map);\n\tif (ret)\n\t\treturn NULL;\n\trptr = bo_map.vaddr;  \n\n\trptr += page_offset * PAGE_SIZE;\n\treturn rptr;\n}\n\nvoid qxl_bo_vunmap_locked(struct qxl_bo *bo)\n{\n\tdma_resv_assert_held(bo->tbo.base.resv);\n\n\tif (bo->kptr == NULL)\n\t\treturn;\n\tbo->map_count--;\n\tif (bo->map_count > 0)\n\t\treturn;\n\tbo->kptr = NULL;\n\tttm_bo_vunmap(&bo->tbo, &bo->map);\n\t__qxl_bo_unpin(bo);\n}\n\nint qxl_bo_vunmap(struct qxl_bo *bo)\n{\n\tint r;\n\n\tr = qxl_bo_reserve(bo);\n\tif (r)\n\t\treturn r;\n\n\tqxl_bo_vunmap_locked(bo);\n\tqxl_bo_unreserve(bo);\n\treturn 0;\n}\n\nvoid qxl_bo_kunmap_atomic_page(struct qxl_device *qdev,\n\t\t\t       struct qxl_bo *bo, void *pmap)\n{\n\tif ((bo->tbo.resource->mem_type != TTM_PL_VRAM) &&\n\t    (bo->tbo.resource->mem_type != TTM_PL_PRIV))\n\t\tgoto fallback;\n\n\tio_mapping_unmap_atomic(pmap);\n\treturn;\n fallback:\n\tqxl_bo_vunmap_locked(bo);\n}\n\nvoid qxl_bo_unref(struct qxl_bo **bo)\n{\n\tif ((*bo) == NULL)\n\t\treturn;\n\n\tdrm_gem_object_put(&(*bo)->tbo.base);\n\t*bo = NULL;\n}\n\nstruct qxl_bo *qxl_bo_ref(struct qxl_bo *bo)\n{\n\tdrm_gem_object_get(&bo->tbo.base);\n\treturn bo;\n}\n\nstatic int __qxl_bo_pin(struct qxl_bo *bo)\n{\n\tstruct ttm_operation_ctx ctx = { false, false };\n\tstruct drm_device *ddev = bo->tbo.base.dev;\n\tint r;\n\n\tif (bo->tbo.pin_count) {\n\t\tttm_bo_pin(&bo->tbo);\n\t\treturn 0;\n\t}\n\tqxl_ttm_placement_from_domain(bo, bo->type);\n\tr = ttm_bo_validate(&bo->tbo, &bo->placement, &ctx);\n\tif (likely(r == 0))\n\t\tttm_bo_pin(&bo->tbo);\n\tif (unlikely(r != 0))\n\t\tdev_err(ddev->dev, \"%p pin failed\\n\", bo);\n\treturn r;\n}\n\nstatic void __qxl_bo_unpin(struct qxl_bo *bo)\n{\n\tttm_bo_unpin(&bo->tbo);\n}\n\n \nint qxl_bo_pin(struct qxl_bo *bo)\n{\n\tint r;\n\n\tr = qxl_bo_reserve(bo);\n\tif (r)\n\t\treturn r;\n\n\tr = __qxl_bo_pin(bo);\n\tqxl_bo_unreserve(bo);\n\treturn r;\n}\n\n \nint qxl_bo_unpin(struct qxl_bo *bo)\n{\n\tint r;\n\n\tr = qxl_bo_reserve(bo);\n\tif (r)\n\t\treturn r;\n\n\t__qxl_bo_unpin(bo);\n\tqxl_bo_unreserve(bo);\n\treturn 0;\n}\n\nvoid qxl_bo_force_delete(struct qxl_device *qdev)\n{\n\tstruct qxl_bo *bo, *n;\n\n\tif (list_empty(&qdev->gem.objects))\n\t\treturn;\n\tdev_err(qdev->ddev.dev, \"Userspace still has active objects !\\n\");\n\tlist_for_each_entry_safe(bo, n, &qdev->gem.objects, list) {\n\t\tdev_err(qdev->ddev.dev, \"%p %p %lu %lu force free\\n\",\n\t\t\t&bo->tbo.base, bo, (unsigned long)bo->tbo.base.size,\n\t\t\t*((unsigned long *)&bo->tbo.base.refcount));\n\t\tmutex_lock(&qdev->gem.mutex);\n\t\tlist_del_init(&bo->list);\n\t\tmutex_unlock(&qdev->gem.mutex);\n\t\t \n\t\tdrm_gem_object_put(&bo->tbo.base);\n\t}\n}\n\nint qxl_bo_init(struct qxl_device *qdev)\n{\n\treturn qxl_ttm_init(qdev);\n}\n\nvoid qxl_bo_fini(struct qxl_device *qdev)\n{\n\tqxl_ttm_fini(qdev);\n}\n\nint qxl_bo_check_id(struct qxl_device *qdev, struct qxl_bo *bo)\n{\n\tint ret;\n\n\tif (bo->type == QXL_GEM_DOMAIN_SURFACE && bo->surface_id == 0) {\n\t\t \n\t\tret = qxl_surface_id_alloc(qdev, bo);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tret = qxl_hw_surface_alloc(qdev, bo);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\treturn 0;\n}\n\nint qxl_surf_evict(struct qxl_device *qdev)\n{\n\tstruct ttm_resource_manager *man;\n\n\tman = ttm_manager_type(&qdev->mman.bdev, TTM_PL_PRIV);\n\treturn ttm_resource_manager_evict_all(&qdev->mman.bdev, man);\n}\n\nint qxl_vram_evict(struct qxl_device *qdev)\n{\n\tstruct ttm_resource_manager *man;\n\n\tman = ttm_manager_type(&qdev->mman.bdev, TTM_PL_VRAM);\n\treturn ttm_resource_manager_evict_all(&qdev->mman.bdev, man);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}