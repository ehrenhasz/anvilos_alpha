{
  "module_name": "qxl_kms.c",
  "hash_id": "a38795bbb85f134f91e7feea1d3c62f392c6ae14b598ff0b07b64c333c54f38d",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/qxl/qxl_kms.c",
  "human_readable_source": " \n\n#include <linux/io-mapping.h>\n#include <linux/pci.h>\n\n#include <drm/drm_drv.h>\n#include <drm/drm_managed.h>\n#include <drm/drm_probe_helper.h>\n\n#include \"qxl_drv.h\"\n#include \"qxl_object.h\"\n\nstatic bool qxl_check_device(struct qxl_device *qdev)\n{\n\tstruct qxl_rom *rom = qdev->rom;\n\n\tif (rom->magic != 0x4f525851) {\n\t\tDRM_ERROR(\"bad rom signature %x\\n\", rom->magic);\n\t\treturn false;\n\t}\n\n\tDRM_INFO(\"Device Version %d.%d\\n\", rom->id, rom->update_id);\n\tDRM_INFO(\"Compression level %d log level %d\\n\", rom->compression_level,\n\t\t rom->log_level);\n\tDRM_INFO(\"%d io pages at offset 0x%x\\n\",\n\t\t rom->num_io_pages, rom->pages_offset);\n\tDRM_INFO(\"%d byte draw area at offset 0x%x\\n\",\n\t\t rom->surface0_area_size, rom->draw_area_offset);\n\n\tqdev->vram_size = rom->surface0_area_size;\n\tDRM_INFO(\"RAM header offset: 0x%x\\n\", rom->ram_header_offset);\n\treturn true;\n}\n\nstatic void setup_hw_slot(struct qxl_device *qdev, struct qxl_memslot *slot)\n{\n\tqdev->ram_header->mem_slot.mem_start = slot->start_phys_addr;\n\tqdev->ram_header->mem_slot.mem_end = slot->start_phys_addr + slot->size;\n\tqxl_io_memslot_add(qdev, qdev->rom->slots_start + slot->index);\n}\n\nstatic void setup_slot(struct qxl_device *qdev,\n\t\t       struct qxl_memslot *slot,\n\t\t       unsigned int slot_index,\n\t\t       const char *slot_name,\n\t\t       unsigned long start_phys_addr,\n\t\t       unsigned long size)\n{\n\tuint64_t high_bits;\n\n\tslot->index = slot_index;\n\tslot->name = slot_name;\n\tslot->start_phys_addr = start_phys_addr;\n\tslot->size = size;\n\n\tsetup_hw_slot(qdev, slot);\n\n\tslot->generation = qdev->rom->slot_generation;\n\thigh_bits = (qdev->rom->slots_start + slot->index)\n\t\t<< qdev->rom->slot_gen_bits;\n\thigh_bits |= slot->generation;\n\thigh_bits <<= (64 - (qdev->rom->slot_gen_bits + qdev->rom->slot_id_bits));\n\tslot->high_bits = high_bits;\n\n\tDRM_INFO(\"slot %d (%s): base 0x%08lx, size 0x%08lx\\n\",\n\t\t slot->index, slot->name,\n\t\t (unsigned long)slot->start_phys_addr,\n\t\t (unsigned long)slot->size);\n}\n\nvoid qxl_reinit_memslots(struct qxl_device *qdev)\n{\n\tsetup_hw_slot(qdev, &qdev->main_slot);\n\tsetup_hw_slot(qdev, &qdev->surfaces_slot);\n}\n\nstatic void qxl_gc_work(struct work_struct *work)\n{\n\tstruct qxl_device *qdev = container_of(work, struct qxl_device, gc_work);\n\n\tqxl_garbage_collect(qdev);\n}\n\nint qxl_device_init(struct qxl_device *qdev,\n\t\t    struct pci_dev *pdev)\n{\n\tint r, sb;\n\n\tpci_set_drvdata(pdev, &qdev->ddev);\n\n\tmutex_init(&qdev->gem.mutex);\n\tmutex_init(&qdev->update_area_mutex);\n\tmutex_init(&qdev->release_mutex);\n\tmutex_init(&qdev->surf_evict_mutex);\n\tqxl_gem_init(qdev);\n\n\tqdev->rom_base = pci_resource_start(pdev, 2);\n\tqdev->rom_size = pci_resource_len(pdev, 2);\n\tqdev->vram_base = pci_resource_start(pdev, 0);\n\tqdev->io_base = pci_resource_start(pdev, 3);\n\n\tqdev->vram_mapping = io_mapping_create_wc(qdev->vram_base, pci_resource_len(pdev, 0));\n\tif (!qdev->vram_mapping) {\n\t\tpr_err(\"Unable to create vram_mapping\");\n\t\treturn -ENOMEM;\n\t}\n\n\tif (pci_resource_len(pdev, 4) > 0) {\n\t\t \n\t\tsb = 4;\n\t\tqdev->surfaceram_base = pci_resource_start(pdev, sb);\n\t\tqdev->surfaceram_size = pci_resource_len(pdev, sb);\n\t\tqdev->surface_mapping =\n\t\t\tio_mapping_create_wc(qdev->surfaceram_base,\n\t\t\t\t\t     qdev->surfaceram_size);\n\t}\n\tif (qdev->surface_mapping == NULL) {\n\t\t \n\t\tsb = 1;\n\t\tqdev->surfaceram_base = pci_resource_start(pdev, sb);\n\t\tqdev->surfaceram_size = pci_resource_len(pdev, sb);\n\t\tqdev->surface_mapping =\n\t\t\tio_mapping_create_wc(qdev->surfaceram_base,\n\t\t\t\t\t     qdev->surfaceram_size);\n\t\tif (!qdev->surface_mapping) {\n\t\t\tpr_err(\"Unable to create surface_mapping\");\n\t\t\tr = -ENOMEM;\n\t\t\tgoto vram_mapping_free;\n\t\t}\n\t}\n\n\tDRM_DEBUG_KMS(\"qxl: vram %llx-%llx(%dM %dk), surface %llx-%llx(%dM %dk, %s)\\n\",\n\t\t (unsigned long long)qdev->vram_base,\n\t\t (unsigned long long)pci_resource_end(pdev, 0),\n\t\t (int)pci_resource_len(pdev, 0) / 1024 / 1024,\n\t\t (int)pci_resource_len(pdev, 0) / 1024,\n\t\t (unsigned long long)qdev->surfaceram_base,\n\t\t (unsigned long long)pci_resource_end(pdev, sb),\n\t\t (int)qdev->surfaceram_size / 1024 / 1024,\n\t\t (int)qdev->surfaceram_size / 1024,\n\t\t (sb == 4) ? \"64bit\" : \"32bit\");\n\n\tqdev->rom = ioremap_wc(qdev->rom_base, qdev->rom_size);\n\tif (!qdev->rom) {\n\t\tpr_err(\"Unable to ioremap ROM\\n\");\n\t\tr = -ENOMEM;\n\t\tgoto surface_mapping_free;\n\t}\n\n\tif (!qxl_check_device(qdev)) {\n\t\tr = -ENODEV;\n\t\tgoto rom_unmap;\n\t}\n\n\tr = qxl_bo_init(qdev);\n\tif (r) {\n\t\tDRM_ERROR(\"bo init failed %d\\n\", r);\n\t\tgoto rom_unmap;\n\t}\n\n\tqdev->ram_header = ioremap_wc(qdev->vram_base +\n\t\t\t\t   qdev->rom->ram_header_offset,\n\t\t\t\t   sizeof(*qdev->ram_header));\n\tif (!qdev->ram_header) {\n\t\tDRM_ERROR(\"Unable to ioremap RAM header\\n\");\n\t\tr = -ENOMEM;\n\t\tgoto bo_fini;\n\t}\n\n\tqdev->command_ring = qxl_ring_create(&(qdev->ram_header->cmd_ring_hdr),\n\t\t\t\t\t     sizeof(struct qxl_command),\n\t\t\t\t\t     QXL_COMMAND_RING_SIZE,\n\t\t\t\t\t     qdev->io_base + QXL_IO_NOTIFY_CMD,\n\t\t\t\t\t     &qdev->display_event);\n\tif (!qdev->command_ring) {\n\t\tDRM_ERROR(\"Unable to create command ring\\n\");\n\t\tr = -ENOMEM;\n\t\tgoto ram_header_unmap;\n\t}\n\n\tqdev->cursor_ring = qxl_ring_create(\n\t\t\t\t&(qdev->ram_header->cursor_ring_hdr),\n\t\t\t\tsizeof(struct qxl_command),\n\t\t\t\tQXL_CURSOR_RING_SIZE,\n\t\t\t\tqdev->io_base + QXL_IO_NOTIFY_CURSOR,\n\t\t\t\t&qdev->cursor_event);\n\n\tif (!qdev->cursor_ring) {\n\t\tDRM_ERROR(\"Unable to create cursor ring\\n\");\n\t\tr = -ENOMEM;\n\t\tgoto command_ring_free;\n\t}\n\n\tqdev->release_ring = qxl_ring_create(\n\t\t\t\t&(qdev->ram_header->release_ring_hdr),\n\t\t\t\tsizeof(uint64_t),\n\t\t\t\tQXL_RELEASE_RING_SIZE, 0,\n\t\t\t\tNULL);\n\n\tif (!qdev->release_ring) {\n\t\tDRM_ERROR(\"Unable to create release ring\\n\");\n\t\tr = -ENOMEM;\n\t\tgoto cursor_ring_free;\n\t}\n\n\tidr_init_base(&qdev->release_idr, 1);\n\tspin_lock_init(&qdev->release_idr_lock);\n\tspin_lock_init(&qdev->release_lock);\n\n\tidr_init_base(&qdev->surf_id_idr, 1);\n\tspin_lock_init(&qdev->surf_id_idr_lock);\n\n\tmutex_init(&qdev->async_io_mutex);\n\n\t \n\tqxl_io_reset(qdev);\n\n\t \n\tr = qxl_irq_init(qdev);\n\tif (r) {\n\t\tDRM_ERROR(\"Unable to init qxl irq\\n\");\n\t\tgoto release_ring_free;\n\t}\n\n\t \n\tsetup_slot(qdev, &qdev->main_slot, 0, \"main\",\n\t\t   (unsigned long)qdev->vram_base,\n\t\t   (unsigned long)qdev->rom->ram_header_offset);\n\tsetup_slot(qdev, &qdev->surfaces_slot, 1, \"surfaces\",\n\t\t   (unsigned long)qdev->surfaceram_base,\n\t\t   (unsigned long)qdev->surfaceram_size);\n\n\tINIT_WORK(&qdev->gc_work, qxl_gc_work);\n\n\treturn 0;\n\nrelease_ring_free:\n\tqxl_ring_free(qdev->release_ring);\ncursor_ring_free:\n\tqxl_ring_free(qdev->cursor_ring);\ncommand_ring_free:\n\tqxl_ring_free(qdev->command_ring);\nram_header_unmap:\n\tiounmap(qdev->ram_header);\nbo_fini:\n\tqxl_bo_fini(qdev);\nrom_unmap:\n\tiounmap(qdev->rom);\nsurface_mapping_free:\n\tio_mapping_free(qdev->surface_mapping);\nvram_mapping_free:\n\tio_mapping_free(qdev->vram_mapping);\n\treturn r;\n}\n\nvoid qxl_device_fini(struct qxl_device *qdev)\n{\n\tint cur_idx;\n\n\t \n\tif (!qdev->gc_work.func)\n\t\treturn;\n\n\tfor (cur_idx = 0; cur_idx < 3; cur_idx++) {\n\t\tif (!qdev->current_release_bo[cur_idx])\n\t\t\tcontinue;\n\t\tqxl_bo_unpin(qdev->current_release_bo[cur_idx]);\n\t\tqxl_bo_unref(&qdev->current_release_bo[cur_idx]);\n\t\tqdev->current_release_bo_offset[cur_idx] = 0;\n\t\tqdev->current_release_bo[cur_idx] = NULL;\n\t}\n\n\t \n\tqxl_io_notify_oom(qdev);\n\twait_event_timeout(qdev->release_event,\n\t\t\t   atomic_read(&qdev->release_count) == 0,\n\t\t\t   HZ);\n\tflush_work(&qdev->gc_work);\n\tqxl_surf_evict(qdev);\n\tqxl_vram_evict(qdev);\n\n\tqxl_gem_fini(qdev);\n\tqxl_bo_fini(qdev);\n\tqxl_ring_free(qdev->command_ring);\n\tqxl_ring_free(qdev->cursor_ring);\n\tqxl_ring_free(qdev->release_ring);\n\tio_mapping_free(qdev->surface_mapping);\n\tio_mapping_free(qdev->vram_mapping);\n\tiounmap(qdev->ram_header);\n\tiounmap(qdev->rom);\n\tqdev->rom = NULL;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}