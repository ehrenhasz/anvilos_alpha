{
  "module_name": "qxl_ttm.c",
  "hash_id": "89da7f89487c8e1ca02feea9f77d8915d0945fba60fb3b38dbe7dca0e662bbb8",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/qxl/qxl_ttm.c",
  "human_readable_source": " \n\n#include <linux/delay.h>\n\n#include <drm/drm.h>\n#include <drm/drm_file.h>\n#include <drm/drm_debugfs.h>\n#include <drm/qxl_drm.h>\n#include <drm/ttm/ttm_bo.h>\n#include <drm/ttm/ttm_placement.h>\n#include <drm/ttm/ttm_range_manager.h>\n#include <drm/ttm/ttm_tt.h>\n\n#include \"qxl_drv.h\"\n#include \"qxl_object.h\"\n\nstatic struct qxl_device *qxl_get_qdev(struct ttm_device *bdev)\n{\n\tstruct qxl_mman *mman;\n\tstruct qxl_device *qdev;\n\n\tmman = container_of(bdev, struct qxl_mman, bdev);\n\tqdev = container_of(mman, struct qxl_device, mman);\n\treturn qdev;\n}\n\nstatic void qxl_evict_flags(struct ttm_buffer_object *bo,\n\t\t\t\tstruct ttm_placement *placement)\n{\n\tstruct qxl_bo *qbo;\n\tstatic const struct ttm_place placements = {\n\t\t.fpfn = 0,\n\t\t.lpfn = 0,\n\t\t.mem_type = TTM_PL_SYSTEM,\n\t\t.flags = 0\n\t};\n\n\tif (!qxl_ttm_bo_is_qxl_bo(bo)) {\n\t\tplacement->placement = &placements;\n\t\tplacement->busy_placement = &placements;\n\t\tplacement->num_placement = 1;\n\t\tplacement->num_busy_placement = 1;\n\t\treturn;\n\t}\n\tqbo = to_qxl_bo(bo);\n\tqxl_ttm_placement_from_domain(qbo, QXL_GEM_DOMAIN_CPU);\n\t*placement = qbo->placement;\n}\n\nint qxl_ttm_io_mem_reserve(struct ttm_device *bdev,\n\t\t\t   struct ttm_resource *mem)\n{\n\tstruct qxl_device *qdev = qxl_get_qdev(bdev);\n\n\tswitch (mem->mem_type) {\n\tcase TTM_PL_SYSTEM:\n\t\t \n\t\treturn 0;\n\tcase TTM_PL_VRAM:\n\t\tmem->bus.is_iomem = true;\n\t\tmem->bus.offset = (mem->start << PAGE_SHIFT) + qdev->vram_base;\n\t\tmem->bus.caching = ttm_write_combined;\n\t\tbreak;\n\tcase TTM_PL_PRIV:\n\t\tmem->bus.is_iomem = true;\n\t\tmem->bus.offset = (mem->start << PAGE_SHIFT) +\n\t\t\tqdev->surfaceram_base;\n\t\tmem->bus.caching = ttm_write_combined;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}\n\n \nstatic void qxl_ttm_backend_destroy(struct ttm_device *bdev, struct ttm_tt *ttm)\n{\n\tttm_tt_fini(ttm);\n\tkfree(ttm);\n}\n\nstatic struct ttm_tt *qxl_ttm_tt_create(struct ttm_buffer_object *bo,\n\t\t\t\t\tuint32_t page_flags)\n{\n\tstruct ttm_tt *ttm;\n\n\tttm = kzalloc(sizeof(struct ttm_tt), GFP_KERNEL);\n\tif (ttm == NULL)\n\t\treturn NULL;\n\tif (ttm_tt_init(ttm, bo, page_flags, ttm_cached, 0)) {\n\t\tkfree(ttm);\n\t\treturn NULL;\n\t}\n\treturn ttm;\n}\n\nstatic void qxl_bo_move_notify(struct ttm_buffer_object *bo,\n\t\t\t       struct ttm_resource *new_mem)\n{\n\tstruct qxl_bo *qbo;\n\tstruct qxl_device *qdev;\n\n\tif (!qxl_ttm_bo_is_qxl_bo(bo) || !bo->resource)\n\t\treturn;\n\tqbo = to_qxl_bo(bo);\n\tqdev = to_qxl(qbo->tbo.base.dev);\n\n\tif (bo->resource->mem_type == TTM_PL_PRIV && qbo->surface_id)\n\t\tqxl_surface_evict(qdev, qbo, new_mem ? true : false);\n}\n\nstatic int qxl_bo_move(struct ttm_buffer_object *bo, bool evict,\n\t\t       struct ttm_operation_ctx *ctx,\n\t\t       struct ttm_resource *new_mem,\n\t\t       struct ttm_place *hop)\n{\n\tstruct ttm_resource *old_mem = bo->resource;\n\tint ret;\n\n\tif (!old_mem) {\n\t\tif (new_mem->mem_type != TTM_PL_SYSTEM) {\n\t\t\thop->mem_type = TTM_PL_SYSTEM;\n\t\t\thop->flags = TTM_PL_FLAG_TEMPORARY;\n\t\t\treturn -EMULTIHOP;\n\t\t}\n\n\t\tttm_bo_move_null(bo, new_mem);\n\t\treturn 0;\n\t}\n\n\tqxl_bo_move_notify(bo, new_mem);\n\n\tret = ttm_bo_wait_ctx(bo, ctx);\n\tif (ret)\n\t\treturn ret;\n\n\tif (old_mem->mem_type == TTM_PL_SYSTEM && bo->ttm == NULL) {\n\t\tttm_bo_move_null(bo, new_mem);\n\t\treturn 0;\n\t}\n\treturn ttm_bo_move_memcpy(bo, ctx, new_mem);\n}\n\nstatic void qxl_bo_delete_mem_notify(struct ttm_buffer_object *bo)\n{\n\tqxl_bo_move_notify(bo, NULL);\n}\n\nstatic struct ttm_device_funcs qxl_bo_driver = {\n\t.ttm_tt_create = &qxl_ttm_tt_create,\n\t.ttm_tt_destroy = &qxl_ttm_backend_destroy,\n\t.eviction_valuable = ttm_bo_eviction_valuable,\n\t.evict_flags = &qxl_evict_flags,\n\t.move = &qxl_bo_move,\n\t.io_mem_reserve = &qxl_ttm_io_mem_reserve,\n\t.delete_mem_notify = &qxl_bo_delete_mem_notify,\n};\n\nstatic int qxl_ttm_init_mem_type(struct qxl_device *qdev,\n\t\t\t\t unsigned int type,\n\t\t\t\t uint64_t size)\n{\n\treturn ttm_range_man_init(&qdev->mman.bdev, type, false, size);\n}\n\nint qxl_ttm_init(struct qxl_device *qdev)\n{\n\tint r;\n\tint num_io_pages;  \n\n\t \n\tr = ttm_device_init(&qdev->mman.bdev, &qxl_bo_driver, NULL,\n\t\t\t    qdev->ddev.anon_inode->i_mapping,\n\t\t\t    qdev->ddev.vma_offset_manager,\n\t\t\t    false, false);\n\tif (r) {\n\t\tDRM_ERROR(\"failed initializing buffer object driver(%d).\\n\", r);\n\t\treturn r;\n\t}\n\t \n\tnum_io_pages = qdev->rom->ram_header_offset / PAGE_SIZE;\n\tr = qxl_ttm_init_mem_type(qdev, TTM_PL_VRAM, num_io_pages);\n\tif (r) {\n\t\tDRM_ERROR(\"Failed initializing VRAM heap.\\n\");\n\t\treturn r;\n\t}\n\tr = qxl_ttm_init_mem_type(qdev, TTM_PL_PRIV,\n\t\t\t\t  qdev->surfaceram_size / PAGE_SIZE);\n\tif (r) {\n\t\tDRM_ERROR(\"Failed initializing Surfaces heap.\\n\");\n\t\treturn r;\n\t}\n\tDRM_INFO(\"qxl: %uM of VRAM memory size\\n\",\n\t\t (unsigned int)qdev->vram_size / (1024 * 1024));\n\tDRM_INFO(\"qxl: %luM of IO pages memory ready (VRAM domain)\\n\",\n\t\t ((unsigned int)num_io_pages * PAGE_SIZE) / (1024 * 1024));\n\tDRM_INFO(\"qxl: %uM of Surface memory size\\n\",\n\t\t (unsigned int)qdev->surfaceram_size / (1024 * 1024));\n\treturn 0;\n}\n\nvoid qxl_ttm_fini(struct qxl_device *qdev)\n{\n\tttm_range_man_fini(&qdev->mman.bdev, TTM_PL_VRAM);\n\tttm_range_man_fini(&qdev->mman.bdev, TTM_PL_PRIV);\n\tttm_device_fini(&qdev->mman.bdev);\n\tDRM_INFO(\"qxl: ttm finalized\\n\");\n}\n\nvoid qxl_ttm_debugfs_init(struct qxl_device *qdev)\n{\n#if defined(CONFIG_DEBUG_FS)\n\tttm_resource_manager_create_debugfs(ttm_manager_type(&qdev->mman.bdev,\n\t\t\t\t\t\t\t     TTM_PL_VRAM),\n\t\t\t\t\t    qdev->ddev.primary->debugfs_root, \"qxl_mem_mm\");\n\tttm_resource_manager_create_debugfs(ttm_manager_type(&qdev->mman.bdev,\n\t\t\t\t\t\t\t     TTM_PL_PRIV),\n\t\t\t\t\t    qdev->ddev.primary->debugfs_root, \"qxl_surf_mm\");\n#endif\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}