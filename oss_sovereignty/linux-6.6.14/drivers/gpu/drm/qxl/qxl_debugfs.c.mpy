{
  "module_name": "qxl_debugfs.c",
  "hash_id": "563b023b5ef0139b0f3c583d502dd3df8a8f098b5849fc9d4f309da1fa4fbc48",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/qxl/qxl_debugfs.c",
  "human_readable_source": " \n\n \n\n#include <drm/drm_debugfs.h>\n#include <drm/drm_file.h>\n\n#include \"qxl_drv.h\"\n#include \"qxl_object.h\"\n\n#if defined(CONFIG_DEBUG_FS)\nstatic int\nqxl_debugfs_irq_received(struct seq_file *m, void *data)\n{\n\tstruct drm_info_node *node = (struct drm_info_node *) m->private;\n\tstruct qxl_device *qdev = to_qxl(node->minor->dev);\n\n\tseq_printf(m, \"%d\\n\", atomic_read(&qdev->irq_received));\n\tseq_printf(m, \"%d\\n\", atomic_read(&qdev->irq_received_display));\n\tseq_printf(m, \"%d\\n\", atomic_read(&qdev->irq_received_cursor));\n\tseq_printf(m, \"%d\\n\", atomic_read(&qdev->irq_received_io_cmd));\n\tseq_printf(m, \"%d\\n\", qdev->irq_received_error);\n\treturn 0;\n}\n\nstatic int\nqxl_debugfs_buffers_info(struct seq_file *m, void *data)\n{\n\tstruct drm_info_node *node = (struct drm_info_node *) m->private;\n\tstruct qxl_device *qdev = to_qxl(node->minor->dev);\n\tstruct qxl_bo *bo;\n\n\tlist_for_each_entry(bo, &qdev->gem.objects, list) {\n\t\tstruct dma_resv_iter cursor;\n\t\tstruct dma_fence *fence;\n\t\tint rel = 0;\n\n\t\tdma_resv_iter_begin(&cursor, bo->tbo.base.resv,\n\t\t\t\t    DMA_RESV_USAGE_BOOKKEEP);\n\t\tdma_resv_for_each_fence_unlocked(&cursor, fence) {\n\t\t\tif (dma_resv_iter_is_restarted(&cursor))\n\t\t\t\trel = 0;\n\t\t\t++rel;\n\t\t}\n\n\t\tseq_printf(m, \"size %ld, pc %d, num releases %d\\n\",\n\t\t\t   (unsigned long)bo->tbo.base.size,\n\t\t\t   bo->tbo.pin_count, rel);\n\t}\n\treturn 0;\n}\n\nstatic struct drm_info_list qxl_debugfs_list[] = {\n\t{ \"irq_received\", qxl_debugfs_irq_received, 0, NULL },\n\t{ \"qxl_buffers\", qxl_debugfs_buffers_info, 0, NULL },\n};\n#define QXL_DEBUGFS_ENTRIES ARRAY_SIZE(qxl_debugfs_list)\n#endif\n\nvoid\nqxl_debugfs_init(struct drm_minor *minor)\n{\n#if defined(CONFIG_DEBUG_FS)\n\tstruct qxl_device *dev = to_qxl(minor->dev);\n\n\tdrm_debugfs_create_files(qxl_debugfs_list, QXL_DEBUGFS_ENTRIES,\n\t\t\t\t minor->debugfs_root, minor);\n\n\tqxl_ttm_debugfs_init(dev);\n#endif\n}\n\nvoid qxl_debugfs_add_files(struct qxl_device *qdev,\n\t\t\t   struct drm_info_list *files,\n\t\t\t   unsigned int nfiles)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < qdev->debugfs_count; i++) {\n\t\tif (qdev->debugfs[i].files == files) {\n\t\t\t \n\t\t\treturn;\n\t\t}\n\t}\n\n\ti = qdev->debugfs_count + 1;\n\tif (i > QXL_DEBUGFS_MAX_COMPONENTS) {\n\t\tDRM_ERROR(\"Reached maximum number of debugfs components.\\n\");\n\t\tDRM_ERROR(\"Report so we increase QXL_DEBUGFS_MAX_COMPONENTS.\\n\");\n\t\treturn;\n\t}\n\tqdev->debugfs[qdev->debugfs_count].files = files;\n\tqdev->debugfs[qdev->debugfs_count].num_files = nfiles;\n\tqdev->debugfs_count = i;\n#if defined(CONFIG_DEBUG_FS)\n\tdrm_debugfs_create_files(files, nfiles,\n\t\t\t\t qdev->ddev.primary->debugfs_root,\n\t\t\t\t qdev->ddev.primary);\n#endif\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}