{
  "module_name": "qxl_drv.h",
  "hash_id": "3f513de9b6b583b24037e7163a082347410fa5e628be3a85b6242d1456d8c9e6",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/qxl/qxl_drv.h",
  "human_readable_source": " \n\n#ifndef QXL_DRV_H\n#define QXL_DRV_H\n\n \n\n#include <linux/iosys-map.h>\n#include <linux/dma-fence.h>\n#include <linux/firmware.h>\n#include <linux/platform_device.h>\n#include <linux/workqueue.h>\n\n#include <drm/drm_crtc.h>\n#include <drm/drm_encoder.h>\n#include <drm/drm_gem_ttm_helper.h>\n#include <drm/drm_ioctl.h>\n#include <drm/drm_gem.h>\n#include <drm/qxl_drm.h>\n#include <drm/ttm/ttm_bo.h>\n#include <drm/ttm/ttm_execbuf_util.h>\n#include <drm/ttm/ttm_placement.h>\n\n#include \"qxl_dev.h\"\n\nstruct iosys_map;\n\n#define DRIVER_AUTHOR\t\t\"Dave Airlie\"\n\n#define DRIVER_NAME\t\t\"qxl\"\n#define DRIVER_DESC\t\t\"RH QXL\"\n#define DRIVER_DATE\t\t\"20120117\"\n\n#define DRIVER_MAJOR 0\n#define DRIVER_MINOR 1\n#define DRIVER_PATCHLEVEL 0\n\n#define QXL_DEBUGFS_MAX_COMPONENTS\t\t32\n\nextern int qxl_num_crtc;\n\n#define QXL_INTERRUPT_MASK (\\\n\tQXL_INTERRUPT_DISPLAY |\\\n\tQXL_INTERRUPT_CURSOR |\\\n\tQXL_INTERRUPT_IO_CMD |\\\n\tQXL_INTERRUPT_CLIENT_MONITORS_CONFIG)\n\nstruct qxl_bo {\n\tstruct ttm_buffer_object\ttbo;\n\n\t \n\tstruct list_head\t\tlist;\n\t \n\tstruct ttm_place\t\tplacements[3];\n\tstruct ttm_placement\t\tplacement;\n\tstruct iosys_map\t\tmap;\n\tvoid\t\t\t\t*kptr;\n\tunsigned int                    map_count;\n\tint                             type;\n\n\t \n\tunsigned int is_primary:1;  \n\tunsigned int is_dumb:1;\n\tstruct qxl_bo *shadow;\n\tunsigned int hw_surf_alloc:1;\n\tstruct qxl_surface surf;\n\tuint32_t surface_id;\n\tstruct qxl_release *surf_create;\n};\n#define gem_to_qxl_bo(gobj) container_of((gobj), struct qxl_bo, tbo.base)\n#define to_qxl_bo(tobj) container_of((tobj), struct qxl_bo, tbo)\n\nstruct qxl_gem {\n\tstruct mutex\t\tmutex;\n\tstruct list_head\tobjects;\n};\n\nstruct qxl_bo_list {\n\tstruct ttm_validate_buffer tv;\n};\n\nstruct qxl_crtc {\n\tstruct drm_crtc base;\n\tint index;\n\n\tstruct qxl_bo *cursor_bo;\n};\n\nstruct qxl_output {\n\tint index;\n\tstruct drm_connector base;\n\tstruct drm_encoder enc;\n};\n\n#define to_qxl_crtc(x) container_of(x, struct qxl_crtc, base)\n#define drm_connector_to_qxl_output(x) container_of(x, struct qxl_output, base)\n#define drm_encoder_to_qxl_output(x) container_of(x, struct qxl_output, enc)\n\nstruct qxl_mman {\n\tstruct ttm_device\t\tbdev;\n};\n\nstruct qxl_memslot {\n\tint             index;\n\tconst char      *name;\n\tuint8_t\t\tgeneration;\n\tuint64_t\tstart_phys_addr;\n\tuint64_t\tsize;\n\tuint64_t\thigh_bits;\n};\n\nenum {\n\tQXL_RELEASE_DRAWABLE,\n\tQXL_RELEASE_SURFACE_CMD,\n\tQXL_RELEASE_CURSOR_CMD,\n};\n\n \n#define QXL_MAX_RES 96\nstruct qxl_release {\n\tstruct dma_fence base;\n\n\tint id;\n\tint type;\n\tstruct qxl_bo *release_bo;\n\tuint32_t release_offset;\n\tuint32_t surface_release_id;\n\tstruct ww_acquire_ctx ticket;\n\tstruct list_head bos;\n};\n\nstruct qxl_drm_chunk {\n\tstruct list_head head;\n\tstruct qxl_bo *bo;\n};\n\nstruct qxl_drm_image {\n\tstruct qxl_bo *bo;\n\tstruct list_head chunk_list;\n};\n\n \nstruct qxl_debugfs {\n\tstruct drm_info_list\t*files;\n\tunsigned int num_files;\n};\n\nstruct qxl_device {\n\tstruct drm_device ddev;\n\n\tresource_size_t vram_base, vram_size;\n\tresource_size_t surfaceram_base, surfaceram_size;\n\tresource_size_t rom_base, rom_size;\n\tstruct qxl_rom *rom;\n\n\tstruct qxl_mode *modes;\n\tstruct qxl_bo *monitors_config_bo;\n\tstruct qxl_monitors_config *monitors_config;\n\n\t \n\tstruct qxl_monitors_config *client_monitors_config;\n\n\tint io_base;\n\tvoid *ram;\n\tstruct qxl_mman\t\tmman;\n\tstruct qxl_gem\t\tgem;\n\n\tvoid *ram_physical;\n\n\tstruct qxl_ring *release_ring;\n\tstruct qxl_ring *command_ring;\n\tstruct qxl_ring *cursor_ring;\n\n\tstruct qxl_ram_header *ram_header;\n\n\tstruct qxl_bo *primary_bo;\n\tstruct qxl_bo *dumb_shadow_bo;\n\tstruct qxl_head *dumb_heads;\n\n\tstruct qxl_memslot main_slot;\n\tstruct qxl_memslot surfaces_slot;\n\n\tspinlock_t\trelease_lock;\n\tstruct idr\trelease_idr;\n\tuint32_t\trelease_seqno;\n\tatomic_t\trelease_count;\n\twait_queue_head_t release_event;\n\tspinlock_t release_idr_lock;\n\tstruct mutex\tasync_io_mutex;\n\tunsigned int last_sent_io_cmd;\n\n\t \n\tatomic_t irq_received;\n\tatomic_t irq_received_display;\n\tatomic_t irq_received_cursor;\n\tatomic_t irq_received_io_cmd;\n\tunsigned int irq_received_error;\n\twait_queue_head_t display_event;\n\twait_queue_head_t cursor_event;\n\twait_queue_head_t io_cmd_event;\n\tstruct work_struct client_monitors_config_work;\n\n\t \n\tstruct qxl_debugfs\tdebugfs[QXL_DEBUGFS_MAX_COMPONENTS];\n\tunsigned int debugfs_count;\n\n\tstruct mutex\t\tupdate_area_mutex;\n\n\tstruct idr\tsurf_id_idr;\n\tspinlock_t surf_id_idr_lock;\n\tint last_alloced_surf_id;\n\n\tstruct mutex surf_evict_mutex;\n\tstruct io_mapping *vram_mapping;\n\tstruct io_mapping *surface_mapping;\n\n\t \n\tstruct mutex release_mutex;\n\tstruct qxl_bo *current_release_bo[3];\n\tint current_release_bo_offset[3];\n\n\tstruct work_struct gc_work;\n\n\tstruct drm_property *hotplug_mode_update_property;\n\tint monitors_config_width;\n\tint monitors_config_height;\n};\n\n#define to_qxl(dev) container_of(dev, struct qxl_device, ddev)\n\nint qxl_debugfs_fence_init(struct qxl_device *rdev);\n\nint qxl_device_init(struct qxl_device *qdev, struct pci_dev *pdev);\nvoid qxl_device_fini(struct qxl_device *qdev);\n\nint qxl_modeset_init(struct qxl_device *qdev);\nvoid qxl_modeset_fini(struct qxl_device *qdev);\n\nint qxl_bo_init(struct qxl_device *qdev);\nvoid qxl_bo_fini(struct qxl_device *qdev);\n\nvoid qxl_reinit_memslots(struct qxl_device *qdev);\nint qxl_surf_evict(struct qxl_device *qdev);\nint qxl_vram_evict(struct qxl_device *qdev);\n\nstruct qxl_ring *qxl_ring_create(struct qxl_ring_header *header,\n\t\t\t\t int element_size,\n\t\t\t\t int n_elements,\n\t\t\t\t int prod_notify,\n\t\t\t\t wait_queue_head_t *push_event);\nvoid qxl_ring_free(struct qxl_ring *ring);\nint qxl_check_idle(struct qxl_ring *ring);\n\nstatic inline uint64_t\nqxl_bo_physical_address(struct qxl_device *qdev, struct qxl_bo *bo,\n\t\t\tunsigned long offset)\n{\n\tstruct qxl_memslot *slot =\n\t\t(bo->tbo.resource->mem_type == TTM_PL_VRAM)\n\t\t? &qdev->main_slot : &qdev->surfaces_slot;\n\n        \n\n\treturn slot->high_bits | ((bo->tbo.resource->start << PAGE_SHIFT) + offset);\n}\n\n \nvoid qxl_display_read_client_monitors_config(struct qxl_device *qdev);\nint qxl_create_monitors_object(struct qxl_device *qdev);\nint qxl_destroy_monitors_object(struct qxl_device *qdev);\n\n \nvoid qxl_gem_init(struct qxl_device *qdev);\nvoid qxl_gem_fini(struct qxl_device *qdev);\nint qxl_gem_object_create(struct qxl_device *qdev, int size,\n\t\t\t  int alignment, int initial_domain,\n\t\t\t  bool discardable, bool kernel,\n\t\t\t  struct qxl_surface *surf,\n\t\t\t  struct drm_gem_object **obj);\nint qxl_gem_object_create_with_handle(struct qxl_device *qdev,\n\t\t\t\t      struct drm_file *file_priv,\n\t\t\t\t      u32 domain,\n\t\t\t\t      size_t size,\n\t\t\t\t      struct qxl_surface *surf,\n\t\t\t\t      struct drm_gem_object **gobj,\n\t\t\t\t      uint32_t *handle);\nvoid qxl_gem_object_free(struct drm_gem_object *gobj);\nint qxl_gem_object_open(struct drm_gem_object *obj, struct drm_file *file_priv);\nvoid qxl_gem_object_close(struct drm_gem_object *obj,\n\t\t\t  struct drm_file *file_priv);\nvoid qxl_bo_force_delete(struct qxl_device *qdev);\n\n \nint qxl_mode_dumb_create(struct drm_file *file_priv,\n\t\t\t struct drm_device *dev,\n\t\t\t struct drm_mode_create_dumb *args);\n\n \nint qxl_ttm_init(struct qxl_device *qdev);\nvoid qxl_ttm_fini(struct qxl_device *qdev);\nint qxl_ttm_io_mem_reserve(struct ttm_device *bdev,\n\t\t\t   struct ttm_resource *mem);\n\n \n\nint qxl_image_init(struct qxl_device *qdev,\n\t\t   struct qxl_release *release,\n\t\t   struct qxl_drm_image *dimage,\n\t\t   const uint8_t *data,\n\t\t   int x, int y, int width, int height,\n\t\t   int depth, int stride);\nint\nqxl_image_alloc_objects(struct qxl_device *qdev,\n\t\t\tstruct qxl_release *release,\n\t\t\tstruct qxl_drm_image **image_ptr,\n\t\t\tint height, int stride);\nvoid qxl_image_free_objects(struct qxl_device *qdev, struct qxl_drm_image *dimage);\n\nvoid qxl_update_screen(struct qxl_device *qxl);\n\n \n\nvoid qxl_io_create_primary(struct qxl_device *qdev,\n\t\t\t   struct qxl_bo *bo);\nvoid qxl_io_destroy_primary(struct qxl_device *qdev);\nvoid qxl_io_memslot_add(struct qxl_device *qdev, uint8_t id);\nvoid qxl_io_notify_oom(struct qxl_device *qdev);\n\nint qxl_io_update_area(struct qxl_device *qdev, struct qxl_bo *surf,\n\t\t       const struct qxl_rect *area);\n\nvoid qxl_io_reset(struct qxl_device *qdev);\nvoid qxl_io_monitors_config(struct qxl_device *qdev);\nint qxl_ring_push(struct qxl_ring *ring, const void *new_elt, bool interruptible);\nvoid qxl_io_flush_release(struct qxl_device *qdev);\nvoid qxl_io_flush_surfaces(struct qxl_device *qdev);\n\nunion qxl_release_info *qxl_release_map(struct qxl_device *qdev,\n\t\t\t\t\tstruct qxl_release *release);\nvoid qxl_release_unmap(struct qxl_device *qdev,\n\t\t       struct qxl_release *release,\n\t\t       union qxl_release_info *info);\nint qxl_release_list_add(struct qxl_release *release, struct qxl_bo *bo);\nint qxl_release_reserve_list(struct qxl_release *release, bool no_intr);\nvoid qxl_release_backoff_reserve_list(struct qxl_release *release);\nvoid qxl_release_fence_buffer_objects(struct qxl_release *release);\n\nint qxl_alloc_surface_release_reserved(struct qxl_device *qdev,\n\t\t\t\t       enum qxl_surface_cmd_type surface_cmd_type,\n\t\t\t\t       struct qxl_release *create_rel,\n\t\t\t\t       struct qxl_release **release);\nint qxl_alloc_release_reserved(struct qxl_device *qdev, unsigned long size,\n\t\t\t       int type, struct qxl_release **release,\n\t\t\t       struct qxl_bo **rbo);\n\nint\nqxl_push_command_ring_release(struct qxl_device *qdev, struct qxl_release *release,\n\t\t\t      uint32_t type, bool interruptible);\nint\nqxl_push_cursor_ring_release(struct qxl_device *qdev, struct qxl_release *release,\n\t\t\t     uint32_t type, bool interruptible);\nint qxl_alloc_bo_reserved(struct qxl_device *qdev,\n\t\t\t  struct qxl_release *release,\n\t\t\t  unsigned long size,\n\t\t\t  struct qxl_bo **_bo);\n \n\nvoid qxl_draw_dirty_fb(struct qxl_device *qdev,\n\t\t       struct drm_framebuffer *fb,\n\t\t       struct qxl_bo *bo,\n\t\t       unsigned int flags, unsigned int color,\n\t\t       struct drm_clip_rect *clips,\n\t\t       unsigned int num_clips, int inc,\n\t\t       uint32_t dumb_shadow_offset);\n\nvoid qxl_release_free(struct qxl_device *qdev,\n\t\t      struct qxl_release *release);\n\n \nstruct qxl_release *qxl_release_from_id_locked(struct qxl_device *qdev,\n\t\t\t\t\t\t   uint64_t id);\n\nbool qxl_queue_garbage_collect(struct qxl_device *qdev, bool flush);\nint qxl_garbage_collect(struct qxl_device *qdev);\n\n \n\nvoid qxl_debugfs_init(struct drm_minor *minor);\nvoid qxl_ttm_debugfs_init(struct qxl_device *qdev);\n\n \nint qxl_gem_prime_pin(struct drm_gem_object *obj);\nvoid qxl_gem_prime_unpin(struct drm_gem_object *obj);\nstruct sg_table *qxl_gem_prime_get_sg_table(struct drm_gem_object *obj);\nstruct drm_gem_object *qxl_gem_prime_import_sg_table(\n\tstruct drm_device *dev, struct dma_buf_attachment *attach,\n\tstruct sg_table *sgt);\nint qxl_gem_prime_vmap(struct drm_gem_object *obj, struct iosys_map *map);\nvoid qxl_gem_prime_vunmap(struct drm_gem_object *obj,\n\t\t\t  struct iosys_map *map);\n\n \nint qxl_irq_init(struct qxl_device *qdev);\n\nvoid qxl_debugfs_add_files(struct qxl_device *qdev,\n\t\t\t   struct drm_info_list *files,\n\t\t\t   unsigned int nfiles);\n\nint qxl_surface_id_alloc(struct qxl_device *qdev,\n\t\t\t struct qxl_bo *surf);\nvoid qxl_surface_id_dealloc(struct qxl_device *qdev,\n\t\t\t    uint32_t surface_id);\nint qxl_hw_surface_alloc(struct qxl_device *qdev,\n\t\t\t struct qxl_bo *surf);\nint qxl_hw_surface_dealloc(struct qxl_device *qdev,\n\t\t\t   struct qxl_bo *surf);\n\nint qxl_bo_check_id(struct qxl_device *qdev, struct qxl_bo *bo);\n\nstruct qxl_drv_surface *\nqxl_surface_lookup(struct drm_device *dev, int surface_id);\nvoid qxl_surface_evict(struct qxl_device *qdev, struct qxl_bo *surf, bool freeing);\n\n \nint qxl_alloc_ioctl(struct drm_device *dev, void *data, struct drm_file *file_priv);\nint qxl_map_ioctl(struct drm_device *dev, void *data, struct drm_file *file_priv);\nint qxl_execbuffer_ioctl(struct drm_device *dev, void *data, struct drm_file *file_priv);\nint qxl_update_area_ioctl(struct drm_device *dev, void *data, struct drm_file *file);\nint qxl_getparam_ioctl(struct drm_device *dev, void *data, struct drm_file *file_priv);\nint qxl_clientcap_ioctl(struct drm_device *dev, void *data, struct drm_file *file_priv);\nint qxl_alloc_surf_ioctl(struct drm_device *dev, void *data, struct drm_file *file);\n\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}