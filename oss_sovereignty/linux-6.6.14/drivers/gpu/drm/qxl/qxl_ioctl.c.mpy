{
  "module_name": "qxl_ioctl.c",
  "hash_id": "a2c0664b8e071924c271f892b1ef1904f29300e49a4d6e29b85568d2fe020503",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/qxl/qxl_ioctl.c",
  "human_readable_source": " \n\n#include <linux/pci.h>\n#include <linux/uaccess.h>\n\n#include \"qxl_drv.h\"\n#include \"qxl_object.h\"\n\n \nint qxl_alloc_ioctl(struct drm_device *dev, void *data, struct drm_file *file_priv)\n{\n\tstruct qxl_device *qdev = to_qxl(dev);\n\tstruct drm_qxl_alloc *qxl_alloc = data;\n\tint ret;\n\tuint32_t handle;\n\tu32 domain = QXL_GEM_DOMAIN_VRAM;\n\n\tif (qxl_alloc->size == 0) {\n\t\tDRM_ERROR(\"invalid size %d\\n\", qxl_alloc->size);\n\t\treturn -EINVAL;\n\t}\n\tret = qxl_gem_object_create_with_handle(qdev, file_priv,\n\t\t\t\t\t\tdomain,\n\t\t\t\t\t\tqxl_alloc->size,\n\t\t\t\t\t\tNULL,\n\t\t\t\t\t\tNULL, &handle);\n\tif (ret) {\n\t\tDRM_ERROR(\"%s: failed to create gem ret=%d\\n\",\n\t\t\t  __func__, ret);\n\t\treturn -ENOMEM;\n\t}\n\tqxl_alloc->handle = handle;\n\treturn 0;\n}\n\nint qxl_map_ioctl(struct drm_device *dev, void *data, struct drm_file *file_priv)\n{\n\tstruct qxl_device *qdev = to_qxl(dev);\n\tstruct drm_qxl_map *qxl_map = data;\n\n\treturn drm_gem_ttm_dumb_map_offset(file_priv, &qdev->ddev, qxl_map->handle,\n\t\t\t\t\t   &qxl_map->offset);\n}\n\nstruct qxl_reloc_info {\n\tint type;\n\tstruct qxl_bo *dst_bo;\n\tuint32_t dst_offset;\n\tstruct qxl_bo *src_bo;\n\tint src_offset;\n};\n\n \nstatic void\napply_reloc(struct qxl_device *qdev, struct qxl_reloc_info *info)\n{\n\tvoid *reloc_page;\n\n\treloc_page = qxl_bo_kmap_atomic_page(qdev, info->dst_bo, info->dst_offset & PAGE_MASK);\n\t*(uint64_t *)(reloc_page + (info->dst_offset & ~PAGE_MASK)) = qxl_bo_physical_address(qdev,\n\t\t\t\t\t\t\t\t\t\t\t      info->src_bo,\n\t\t\t\t\t\t\t\t\t\t\t      info->src_offset);\n\tqxl_bo_kunmap_atomic_page(qdev, info->dst_bo, reloc_page);\n}\n\nstatic void\napply_surf_reloc(struct qxl_device *qdev, struct qxl_reloc_info *info)\n{\n\tuint32_t id = 0;\n\tvoid *reloc_page;\n\n\tif (info->src_bo && !info->src_bo->is_primary)\n\t\tid = info->src_bo->surface_id;\n\n\treloc_page = qxl_bo_kmap_atomic_page(qdev, info->dst_bo, info->dst_offset & PAGE_MASK);\n\t*(uint32_t *)(reloc_page + (info->dst_offset & ~PAGE_MASK)) = id;\n\tqxl_bo_kunmap_atomic_page(qdev, info->dst_bo, reloc_page);\n}\n\n \nstatic int qxlhw_handle_to_bo(struct drm_file *file_priv, uint64_t handle,\n\t\t\t      struct qxl_release *release, struct qxl_bo **qbo_p)\n{\n\tstruct drm_gem_object *gobj;\n\tstruct qxl_bo *qobj;\n\tint ret;\n\n\tgobj = drm_gem_object_lookup(file_priv, handle);\n\tif (!gobj)\n\t\treturn -EINVAL;\n\n\tqobj = gem_to_qxl_bo(gobj);\n\n\tret = qxl_release_list_add(release, qobj);\n\tdrm_gem_object_put(gobj);\n\tif (ret)\n\t\treturn ret;\n\n\t*qbo_p = qobj;\n\treturn 0;\n}\n\n \nstatic int qxl_process_single_command(struct qxl_device *qdev,\n\t\t\t\t      struct drm_qxl_command *cmd,\n\t\t\t\t      struct drm_file *file_priv)\n{\n\tstruct qxl_reloc_info *reloc_info;\n\tint release_type;\n\tstruct qxl_release *release;\n\tstruct qxl_bo *cmd_bo;\n\tvoid *fb_cmd;\n\tint i, ret, num_relocs;\n\tint unwritten;\n\n\tswitch (cmd->type) {\n\tcase QXL_CMD_DRAW:\n\t\trelease_type = QXL_RELEASE_DRAWABLE;\n\t\tbreak;\n\tcase QXL_CMD_SURFACE:\n\tcase QXL_CMD_CURSOR:\n\tdefault:\n\t\tDRM_DEBUG(\"Only draw commands in execbuffers\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (cmd->command_size > PAGE_SIZE - sizeof(union qxl_release_info))\n\t\treturn -EINVAL;\n\n\tif (!access_ok(u64_to_user_ptr(cmd->command),\n\t\t       cmd->command_size))\n\t\treturn -EFAULT;\n\n\treloc_info = kmalloc_array(cmd->relocs_num,\n\t\t\t\t   sizeof(struct qxl_reloc_info), GFP_KERNEL);\n\tif (!reloc_info)\n\t\treturn -ENOMEM;\n\n\tret = qxl_alloc_release_reserved(qdev,\n\t\t\t\t\t sizeof(union qxl_release_info) +\n\t\t\t\t\t cmd->command_size,\n\t\t\t\t\t release_type,\n\t\t\t\t\t &release,\n\t\t\t\t\t &cmd_bo);\n\tif (ret)\n\t\tgoto out_free_reloc;\n\n\t \n\tfb_cmd = qxl_bo_kmap_atomic_page(qdev, cmd_bo, (release->release_offset & PAGE_MASK));\n\tunwritten = __copy_from_user_inatomic_nocache\n\t\t(fb_cmd + sizeof(union qxl_release_info) + (release->release_offset & ~PAGE_MASK),\n\t\t u64_to_user_ptr(cmd->command), cmd->command_size);\n\n\t{\n\t\tstruct qxl_drawable *draw = fb_cmd;\n\n\t\tdraw->mm_time = qdev->rom->mm_clock;\n\t}\n\n\tqxl_bo_kunmap_atomic_page(qdev, cmd_bo, fb_cmd);\n\tif (unwritten) {\n\t\tDRM_ERROR(\"got unwritten %d\\n\", unwritten);\n\t\tret = -EFAULT;\n\t\tgoto out_free_release;\n\t}\n\n\t \n\tnum_relocs = 0;\n\tfor (i = 0; i < cmd->relocs_num; ++i) {\n\t\tstruct drm_qxl_reloc reloc;\n\t\tstruct drm_qxl_reloc __user *u = u64_to_user_ptr(cmd->relocs);\n\n\t\tif (copy_from_user(&reloc, u + i, sizeof(reloc))) {\n\t\t\tret = -EFAULT;\n\t\t\tgoto out_free_bos;\n\t\t}\n\n\t\t \n\t\tif (reloc.reloc_type != QXL_RELOC_TYPE_BO && reloc.reloc_type != QXL_RELOC_TYPE_SURF) {\n\t\t\tDRM_DEBUG(\"unknown reloc type %d\\n\", reloc.reloc_type);\n\n\t\t\tret = -EINVAL;\n\t\t\tgoto out_free_bos;\n\t\t}\n\t\treloc_info[i].type = reloc.reloc_type;\n\n\t\tif (reloc.dst_handle) {\n\t\t\tret = qxlhw_handle_to_bo(file_priv, reloc.dst_handle, release,\n\t\t\t\t\t\t &reloc_info[i].dst_bo);\n\t\t\tif (ret)\n\t\t\t\tgoto out_free_bos;\n\t\t\treloc_info[i].dst_offset = reloc.dst_offset;\n\t\t} else {\n\t\t\treloc_info[i].dst_bo = cmd_bo;\n\t\t\treloc_info[i].dst_offset = reloc.dst_offset + release->release_offset;\n\t\t}\n\t\tnum_relocs++;\n\n\t\t \n\t\tif (reloc.reloc_type == QXL_RELOC_TYPE_BO || reloc.src_handle) {\n\t\t\tret = qxlhw_handle_to_bo(file_priv, reloc.src_handle, release,\n\t\t\t\t\t\t &reloc_info[i].src_bo);\n\t\t\tif (ret)\n\t\t\t\tgoto out_free_bos;\n\t\t\treloc_info[i].src_offset = reloc.src_offset;\n\t\t} else {\n\t\t\treloc_info[i].src_bo = NULL;\n\t\t\treloc_info[i].src_offset = 0;\n\t\t}\n\t}\n\n\t \n\tret = qxl_release_reserve_list(release, false);\n\tif (ret)\n\t\tgoto out_free_bos;\n\n\tfor (i = 0; i < cmd->relocs_num; ++i) {\n\t\tif (reloc_info[i].type == QXL_RELOC_TYPE_BO)\n\t\t\tapply_reloc(qdev, &reloc_info[i]);\n\t\telse if (reloc_info[i].type == QXL_RELOC_TYPE_SURF)\n\t\t\tapply_surf_reloc(qdev, &reloc_info[i]);\n\t}\n\n\tqxl_release_fence_buffer_objects(release);\n\tret = qxl_push_command_ring_release(qdev, release, cmd->type, true);\n\nout_free_bos:\nout_free_release:\n\tif (ret)\n\t\tqxl_release_free(qdev, release);\nout_free_reloc:\n\tkfree(reloc_info);\n\treturn ret;\n}\n\nint qxl_execbuffer_ioctl(struct drm_device *dev, void *data, struct drm_file *file_priv)\n{\n\tstruct qxl_device *qdev = to_qxl(dev);\n\tstruct drm_qxl_execbuffer *execbuffer = data;\n\tstruct drm_qxl_command user_cmd;\n\tint cmd_num;\n\tint ret;\n\n\tfor (cmd_num = 0; cmd_num < execbuffer->commands_num; ++cmd_num) {\n\n\t\tstruct drm_qxl_command __user *commands =\n\t\t\tu64_to_user_ptr(execbuffer->commands);\n\n\t\tif (copy_from_user(&user_cmd, commands + cmd_num,\n\t\t\t\t       sizeof(user_cmd)))\n\t\t\treturn -EFAULT;\n\n\t\tret = qxl_process_single_command(qdev, &user_cmd, file_priv);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\treturn 0;\n}\n\nint qxl_update_area_ioctl(struct drm_device *dev, void *data, struct drm_file *file)\n{\n\tstruct qxl_device *qdev = to_qxl(dev);\n\tstruct drm_qxl_update_area *update_area = data;\n\tstruct qxl_rect area = {.left = update_area->left,\n\t\t\t\t.top = update_area->top,\n\t\t\t\t.right = update_area->right,\n\t\t\t\t.bottom = update_area->bottom};\n\tint ret;\n\tstruct drm_gem_object *gobj = NULL;\n\tstruct qxl_bo *qobj = NULL;\n\tstruct ttm_operation_ctx ctx = { true, false };\n\n\tif (update_area->left >= update_area->right ||\n\t    update_area->top >= update_area->bottom)\n\t\treturn -EINVAL;\n\n\tgobj = drm_gem_object_lookup(file, update_area->handle);\n\tif (gobj == NULL)\n\t\treturn -ENOENT;\n\n\tqobj = gem_to_qxl_bo(gobj);\n\n\tret = qxl_bo_reserve(qobj);\n\tif (ret)\n\t\tgoto out;\n\n\tif (!qobj->tbo.pin_count) {\n\t\tqxl_ttm_placement_from_domain(qobj, qobj->type);\n\t\tret = ttm_bo_validate(&qobj->tbo, &qobj->placement, &ctx);\n\t\tif (unlikely(ret))\n\t\t\tgoto out;\n\t}\n\n\tret = qxl_bo_check_id(qdev, qobj);\n\tif (ret)\n\t\tgoto out2;\n\tif (!qobj->surface_id)\n\t\tDRM_ERROR(\"got update area for surface with no id %d\\n\", update_area->handle);\n\tret = qxl_io_update_area(qdev, qobj, &area);\n\nout2:\n\tqxl_bo_unreserve(qobj);\n\nout:\n\tdrm_gem_object_put(gobj);\n\treturn ret;\n}\n\nint qxl_getparam_ioctl(struct drm_device *dev, void *data, struct drm_file *file_priv)\n{\n\tstruct qxl_device *qdev = to_qxl(dev);\n\tstruct drm_qxl_getparam *param = data;\n\n\tswitch (param->param) {\n\tcase QXL_PARAM_NUM_SURFACES:\n\t\tparam->value = qdev->rom->n_surfaces;\n\t\tbreak;\n\tcase QXL_PARAM_MAX_RELOCS:\n\t\tparam->value = QXL_MAX_RES;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}\n\nint qxl_clientcap_ioctl(struct drm_device *dev, void *data, struct drm_file *file_priv)\n{\n\tstruct qxl_device *qdev = to_qxl(dev);\n\tstruct pci_dev *pdev = to_pci_dev(dev->dev);\n\tstruct drm_qxl_clientcap *param = data;\n\tint byte, idx;\n\n\tbyte = param->index / 8;\n\tidx = param->index % 8;\n\n\tif (pdev->revision < 4)\n\t\treturn -ENOSYS;\n\n\tif (byte >= 58)\n\t\treturn -ENOSYS;\n\n\tif (qdev->rom->client_capabilities[byte] & (1 << idx))\n\t\treturn 0;\n\treturn -ENOSYS;\n}\n\nint qxl_alloc_surf_ioctl(struct drm_device *dev, void *data, struct drm_file *file)\n{\n\tstruct qxl_device *qdev = to_qxl(dev);\n\tstruct drm_qxl_alloc_surf *param = data;\n\tint handle;\n\tint ret;\n\tint size, actual_stride;\n\tstruct qxl_surface surf;\n\n\t \n\tactual_stride = param->stride < 0 ? -param->stride : param->stride;\n\tsize = actual_stride * param->height + actual_stride;\n\n\tsurf.format = param->format;\n\tsurf.width = param->width;\n\tsurf.height = param->height;\n\tsurf.stride = param->stride;\n\tsurf.data = 0;\n\n\tret = qxl_gem_object_create_with_handle(qdev, file,\n\t\t\t\t\t\tQXL_GEM_DOMAIN_SURFACE,\n\t\t\t\t\t\tsize,\n\t\t\t\t\t\t&surf,\n\t\t\t\t\t\tNULL, &handle);\n\tif (ret) {\n\t\tDRM_ERROR(\"%s: failed to create gem ret=%d\\n\",\n\t\t\t  __func__, ret);\n\t\treturn -ENOMEM;\n\t} else\n\t\tparam->handle = handle;\n\treturn ret;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}