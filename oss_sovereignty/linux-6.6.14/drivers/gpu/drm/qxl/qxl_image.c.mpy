{
  "module_name": "qxl_image.c",
  "hash_id": "b41f23017fcedc636bb1cfbb8d876aedba2e5fd50683e831d3c7e488342e4684",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/qxl/qxl_image.c",
  "human_readable_source": " \n\n#include <linux/gfp.h>\n#include <linux/slab.h>\n\n#include \"qxl_drv.h\"\n#include \"qxl_object.h\"\n\nstatic int\nqxl_allocate_chunk(struct qxl_device *qdev,\n\t\t   struct qxl_release *release,\n\t\t   struct qxl_drm_image *image,\n\t\t   unsigned int chunk_size)\n{\n\tstruct qxl_drm_chunk *chunk;\n\tint ret;\n\n\tchunk = kmalloc(sizeof(struct qxl_drm_chunk), GFP_KERNEL);\n\tif (!chunk)\n\t\treturn -ENOMEM;\n\n\tret = qxl_alloc_bo_reserved(qdev, release, chunk_size, &chunk->bo);\n\tif (ret) {\n\t\tkfree(chunk);\n\t\treturn ret;\n\t}\n\n\tlist_add_tail(&chunk->head, &image->chunk_list);\n\treturn 0;\n}\n\nint\nqxl_image_alloc_objects(struct qxl_device *qdev,\n\t\t\tstruct qxl_release *release,\n\t\t\tstruct qxl_drm_image **image_ptr,\n\t\t\tint height, int stride)\n{\n\tstruct qxl_drm_image *image;\n\tint ret;\n\n\timage = kmalloc(sizeof(struct qxl_drm_image), GFP_KERNEL);\n\tif (!image)\n\t\treturn -ENOMEM;\n\n\tINIT_LIST_HEAD(&image->chunk_list);\n\n\tret = qxl_alloc_bo_reserved(qdev, release, sizeof(struct qxl_image), &image->bo);\n\tif (ret) {\n\t\tkfree(image);\n\t\treturn ret;\n\t}\n\n\tret = qxl_allocate_chunk(qdev, release, image, sizeof(struct qxl_data_chunk) + stride * height);\n\tif (ret) {\n\t\tqxl_bo_unref(&image->bo);\n\t\tkfree(image);\n\t\treturn ret;\n\t}\n\t*image_ptr = image;\n\treturn 0;\n}\n\nvoid qxl_image_free_objects(struct qxl_device *qdev, struct qxl_drm_image *dimage)\n{\n\tstruct qxl_drm_chunk *chunk, *tmp;\n\n\tlist_for_each_entry_safe(chunk, tmp, &dimage->chunk_list, head) {\n\t\tqxl_bo_unref(&chunk->bo);\n\t\tkfree(chunk);\n\t}\n\n\tqxl_bo_unref(&dimage->bo);\n\tkfree(dimage);\n}\n\nstatic int\nqxl_image_init_helper(struct qxl_device *qdev,\n\t\t      struct qxl_release *release,\n\t\t      struct qxl_drm_image *dimage,\n\t\t      const uint8_t *data,\n\t\t      int width, int height,\n\t\t      int depth, unsigned int hash,\n\t\t      int stride)\n{\n\tstruct qxl_drm_chunk *drv_chunk;\n\tstruct qxl_image *image;\n\tstruct qxl_data_chunk *chunk;\n\tint i;\n\tint chunk_stride;\n\tint linesize = width * depth / 8;\n\tstruct qxl_bo *chunk_bo, *image_bo;\n\tvoid *ptr;\n\t \n\t \n\t \n\n\tdrv_chunk = list_first_entry(&dimage->chunk_list, struct qxl_drm_chunk, head);\n\n\tchunk_bo = drv_chunk->bo;\n\tchunk_stride = stride;  \n\n\tptr = qxl_bo_kmap_atomic_page(qdev, chunk_bo, 0);\n\tchunk = ptr;\n\tchunk->data_size = height * chunk_stride;\n\tchunk->prev_chunk = 0;\n\tchunk->next_chunk = 0;\n\tqxl_bo_kunmap_atomic_page(qdev, chunk_bo, ptr);\n\n\t{\n\t\tvoid *k_data, *i_data;\n\t\tint remain;\n\t\tint page;\n\t\tint size;\n\n\t\tif (stride == linesize && chunk_stride == stride) {\n\t\t\tremain = linesize * height;\n\t\t\tpage = 0;\n\t\t\ti_data = (void *)data;\n\n\t\t\twhile (remain > 0) {\n\t\t\t\tptr = qxl_bo_kmap_atomic_page(qdev, chunk_bo, page << PAGE_SHIFT);\n\n\t\t\t\tif (page == 0) {\n\t\t\t\t\tchunk = ptr;\n\t\t\t\t\tk_data = chunk->data;\n\t\t\t\t\tsize = PAGE_SIZE - offsetof(struct qxl_data_chunk, data);\n\t\t\t\t} else {\n\t\t\t\t\tk_data = ptr;\n\t\t\t\t\tsize = PAGE_SIZE;\n\t\t\t\t}\n\t\t\t\tsize = min(size, remain);\n\n\t\t\t\tmemcpy(k_data, i_data, size);\n\n\t\t\t\tqxl_bo_kunmap_atomic_page(qdev, chunk_bo, ptr);\n\t\t\t\ti_data += size;\n\t\t\t\tremain -= size;\n\t\t\t\tpage++;\n\t\t\t}\n\t\t} else {\n\t\t\tunsigned int page_base, page_offset, out_offset;\n\n\t\t\tfor (i = 0 ; i < height ; ++i) {\n\t\t\t\ti_data = (void *)data + i * stride;\n\t\t\t\tremain = linesize;\n\t\t\t\tout_offset = offsetof(struct qxl_data_chunk, data) + i * chunk_stride;\n\n\t\t\t\twhile (remain > 0) {\n\t\t\t\t\tpage_base = out_offset & PAGE_MASK;\n\t\t\t\t\tpage_offset = offset_in_page(out_offset);\n\t\t\t\t\tsize = min((int)(PAGE_SIZE - page_offset), remain);\n\n\t\t\t\t\tptr = qxl_bo_kmap_atomic_page(qdev, chunk_bo, page_base);\n\t\t\t\t\tk_data = ptr + page_offset;\n\t\t\t\t\tmemcpy(k_data, i_data, size);\n\t\t\t\t\tqxl_bo_kunmap_atomic_page(qdev, chunk_bo, ptr);\n\t\t\t\t\tremain -= size;\n\t\t\t\t\ti_data += size;\n\t\t\t\t\tout_offset += size;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tqxl_bo_vunmap_locked(chunk_bo);\n\n\timage_bo = dimage->bo;\n\tptr = qxl_bo_kmap_atomic_page(qdev, image_bo, 0);\n\timage = ptr;\n\n\timage->descriptor.id = 0;\n\timage->descriptor.type = SPICE_IMAGE_TYPE_BITMAP;\n\n\timage->descriptor.flags = 0;\n\timage->descriptor.width = width;\n\timage->descriptor.height = height;\n\n\tswitch (depth) {\n\tcase 1:\n\t\t \n\t\timage->u.bitmap.format = SPICE_BITMAP_FMT_1BIT_BE;\n\t\tbreak;\n\tcase 24:\n\t\timage->u.bitmap.format = SPICE_BITMAP_FMT_24BIT;\n\t\tbreak;\n\tcase 32:\n\t\timage->u.bitmap.format = SPICE_BITMAP_FMT_32BIT;\n\t\tbreak;\n\tdefault:\n\t\tDRM_ERROR(\"unsupported image bit depth\\n\");\n\t\tqxl_bo_kunmap_atomic_page(qdev, image_bo, ptr);\n\t\treturn -EINVAL;\n\t}\n\timage->u.bitmap.flags = QXL_BITMAP_TOP_DOWN;\n\timage->u.bitmap.x = width;\n\timage->u.bitmap.y = height;\n\timage->u.bitmap.stride = chunk_stride;\n\timage->u.bitmap.palette = 0;\n\timage->u.bitmap.data = qxl_bo_physical_address(qdev, chunk_bo, 0);\n\n\tqxl_bo_kunmap_atomic_page(qdev, image_bo, ptr);\n\n\treturn 0;\n}\n\nint qxl_image_init(struct qxl_device *qdev,\n\t\t     struct qxl_release *release,\n\t\t     struct qxl_drm_image *dimage,\n\t\t     const uint8_t *data,\n\t\t     int x, int y, int width, int height,\n\t\t     int depth, int stride)\n{\n\tdata += y * stride + x * (depth / 8);\n\treturn qxl_image_init_helper(qdev, release, dimage, data,\n\t\t\t\t       width, height, depth, 0, stride);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}