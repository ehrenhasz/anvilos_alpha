{
  "module_name": "qxl_cmd.c",
  "hash_id": "75cf89531ae994f0d945dd72db6fcc23bc824ef1f85eef02549a46d501b6d9af",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/qxl/qxl_cmd.c",
  "human_readable_source": " \n\n \n\n#include <linux/delay.h>\n\n#include <drm/drm_util.h>\n\n#include \"qxl_drv.h\"\n#include \"qxl_object.h\"\n\nstatic int qxl_reap_surface_id(struct qxl_device *qdev, int max_to_reap);\n\nstruct ring {\n\tstruct qxl_ring_header      header;\n\tuint8_t                     elements[];\n};\n\nstruct qxl_ring {\n\tstruct ring\t       *ring;\n\tint\t\t\telement_size;\n\tint\t\t\tn_elements;\n\tint\t\t\tprod_notify;\n\twait_queue_head_t      *push_event;\n\tspinlock_t             lock;\n};\n\nvoid qxl_ring_free(struct qxl_ring *ring)\n{\n\tkfree(ring);\n}\n\nstruct qxl_ring *\nqxl_ring_create(struct qxl_ring_header *header,\n\t\tint element_size,\n\t\tint n_elements,\n\t\tint prod_notify,\n\t\twait_queue_head_t *push_event)\n{\n\tstruct qxl_ring *ring;\n\n\tring = kmalloc(sizeof(*ring), GFP_KERNEL);\n\tif (!ring)\n\t\treturn NULL;\n\n\tring->ring = (struct ring *)header;\n\tring->element_size = element_size;\n\tring->n_elements = n_elements;\n\tring->prod_notify = prod_notify;\n\tring->push_event = push_event;\n\tspin_lock_init(&ring->lock);\n\treturn ring;\n}\n\nstatic int qxl_check_header(struct qxl_ring *ring)\n{\n\tint ret;\n\tstruct qxl_ring_header *header = &(ring->ring->header);\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&ring->lock, flags);\n\tret = header->prod - header->cons < header->num_items;\n\tif (ret == 0)\n\t\theader->notify_on_cons = header->cons + 1;\n\tspin_unlock_irqrestore(&ring->lock, flags);\n\treturn ret;\n}\n\nint qxl_check_idle(struct qxl_ring *ring)\n{\n\tint ret;\n\tstruct qxl_ring_header *header = &(ring->ring->header);\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&ring->lock, flags);\n\tret = header->prod == header->cons;\n\tspin_unlock_irqrestore(&ring->lock, flags);\n\treturn ret;\n}\n\nint qxl_ring_push(struct qxl_ring *ring,\n\t\t  const void *new_elt, bool interruptible)\n{\n\tstruct qxl_ring_header *header = &(ring->ring->header);\n\tuint8_t *elt;\n\tint idx, ret;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&ring->lock, flags);\n\tif (header->prod - header->cons == header->num_items) {\n\t\theader->notify_on_cons = header->cons + 1;\n\t\tmb();\n\t\tspin_unlock_irqrestore(&ring->lock, flags);\n\t\tif (!drm_can_sleep()) {\n\t\t\twhile (!qxl_check_header(ring))\n\t\t\t\tudelay(1);\n\t\t} else {\n\t\t\tif (interruptible) {\n\t\t\t\tret = wait_event_interruptible(*ring->push_event,\n\t\t\t\t\t\t\t       qxl_check_header(ring));\n\t\t\t\tif (ret)\n\t\t\t\t\treturn ret;\n\t\t\t} else {\n\t\t\t\twait_event(*ring->push_event,\n\t\t\t\t\t   qxl_check_header(ring));\n\t\t\t}\n\n\t\t}\n\t\tspin_lock_irqsave(&ring->lock, flags);\n\t}\n\n\tidx = header->prod & (ring->n_elements - 1);\n\telt = ring->ring->elements + idx * ring->element_size;\n\n\tmemcpy((void *)elt, new_elt, ring->element_size);\n\n\theader->prod++;\n\n\tmb();\n\n\tif (header->prod == header->notify_on_prod)\n\t\toutb(0, ring->prod_notify);\n\n\tspin_unlock_irqrestore(&ring->lock, flags);\n\treturn 0;\n}\n\nstatic bool qxl_ring_pop(struct qxl_ring *ring,\n\t\t\t void *element)\n{\n\tvolatile struct qxl_ring_header *header = &(ring->ring->header);\n\tvolatile uint8_t *ring_elt;\n\tint idx;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&ring->lock, flags);\n\tif (header->cons == header->prod) {\n\t\theader->notify_on_prod = header->cons + 1;\n\t\tspin_unlock_irqrestore(&ring->lock, flags);\n\t\treturn false;\n\t}\n\n\tidx = header->cons & (ring->n_elements - 1);\n\tring_elt = ring->ring->elements + idx * ring->element_size;\n\n\tmemcpy(element, (void *)ring_elt, ring->element_size);\n\n\theader->cons++;\n\n\tspin_unlock_irqrestore(&ring->lock, flags);\n\treturn true;\n}\n\nint\nqxl_push_command_ring_release(struct qxl_device *qdev, struct qxl_release *release,\n\t\t\t      uint32_t type, bool interruptible)\n{\n\tstruct qxl_command cmd;\n\n\tcmd.type = type;\n\tcmd.data = qxl_bo_physical_address(qdev, release->release_bo, release->release_offset);\n\n\treturn qxl_ring_push(qdev->command_ring, &cmd, interruptible);\n}\n\nint\nqxl_push_cursor_ring_release(struct qxl_device *qdev, struct qxl_release *release,\n\t\t\t     uint32_t type, bool interruptible)\n{\n\tstruct qxl_command cmd;\n\n\tcmd.type = type;\n\tcmd.data = qxl_bo_physical_address(qdev, release->release_bo, release->release_offset);\n\n\treturn qxl_ring_push(qdev->cursor_ring, &cmd, interruptible);\n}\n\nbool qxl_queue_garbage_collect(struct qxl_device *qdev, bool flush)\n{\n\tif (!qxl_check_idle(qdev->release_ring)) {\n\t\tschedule_work(&qdev->gc_work);\n\t\tif (flush)\n\t\t\tflush_work(&qdev->gc_work);\n\t\treturn true;\n\t}\n\treturn false;\n}\n\nint qxl_garbage_collect(struct qxl_device *qdev)\n{\n\tstruct qxl_release *release;\n\tuint64_t id, next_id;\n\tint i = 0;\n\tunion qxl_release_info *info;\n\n\twhile (qxl_ring_pop(qdev->release_ring, &id)) {\n\t\tDRM_DEBUG_DRIVER(\"popped %lld\\n\", id);\n\t\twhile (id) {\n\t\t\trelease = qxl_release_from_id_locked(qdev, id);\n\t\t\tif (release == NULL)\n\t\t\t\tbreak;\n\n\t\t\tinfo = qxl_release_map(qdev, release);\n\t\t\tnext_id = info->next;\n\t\t\tqxl_release_unmap(qdev, release, info);\n\n\t\t\tDRM_DEBUG_DRIVER(\"popped %lld, next %lld\\n\", id,\n\t\t\t\t\t next_id);\n\n\t\t\tswitch (release->type) {\n\t\t\tcase QXL_RELEASE_DRAWABLE:\n\t\t\tcase QXL_RELEASE_SURFACE_CMD:\n\t\t\tcase QXL_RELEASE_CURSOR_CMD:\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tDRM_ERROR(\"unexpected release type\\n\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tid = next_id;\n\n\t\t\tqxl_release_free(qdev, release);\n\t\t\t++i;\n\t\t}\n\t}\n\n\twake_up_all(&qdev->release_event);\n\tDRM_DEBUG_DRIVER(\"%d\\n\", i);\n\n\treturn i;\n}\n\nint qxl_alloc_bo_reserved(struct qxl_device *qdev,\n\t\t\t  struct qxl_release *release,\n\t\t\t  unsigned long size,\n\t\t\t  struct qxl_bo **_bo)\n{\n\tstruct qxl_bo *bo;\n\tint ret;\n\n\tret = qxl_bo_create(qdev, size, false  ,\n\t\t\t    false, QXL_GEM_DOMAIN_VRAM, 0, NULL, &bo);\n\tif (ret) {\n\t\tDRM_ERROR(\"failed to allocate VRAM BO\\n\");\n\t\treturn ret;\n\t}\n\tret = qxl_release_list_add(release, bo);\n\tif (ret)\n\t\tgoto out_unref;\n\n\t*_bo = bo;\n\treturn 0;\nout_unref:\n\tqxl_bo_unref(&bo);\n\treturn ret;\n}\n\nstatic int wait_for_io_cmd_user(struct qxl_device *qdev, uint8_t val, long port, bool intr)\n{\n\tint irq_num;\n\tlong addr = qdev->io_base + port;\n\tint ret;\n\n\tmutex_lock(&qdev->async_io_mutex);\n\tirq_num = atomic_read(&qdev->irq_received_io_cmd);\n\tif (qdev->last_sent_io_cmd > irq_num) {\n\t\tif (intr)\n\t\t\tret = wait_event_interruptible_timeout(qdev->io_cmd_event,\n\t\t\t\t\t\t\t       atomic_read(&qdev->irq_received_io_cmd) > irq_num, 5*HZ);\n\t\telse\n\t\t\tret = wait_event_timeout(qdev->io_cmd_event,\n\t\t\t\t\t\t atomic_read(&qdev->irq_received_io_cmd) > irq_num, 5*HZ);\n\t\t \n\t\tif (ret <= 0)\n\t\t\tgoto out;\n\t\tirq_num = atomic_read(&qdev->irq_received_io_cmd);\n\t}\n\toutb(val, addr);\n\tqdev->last_sent_io_cmd = irq_num + 1;\n\tif (intr)\n\t\tret = wait_event_interruptible_timeout(qdev->io_cmd_event,\n\t\t\t\t\t\t       atomic_read(&qdev->irq_received_io_cmd) > irq_num, 5*HZ);\n\telse\n\t\tret = wait_event_timeout(qdev->io_cmd_event,\n\t\t\t\t\t atomic_read(&qdev->irq_received_io_cmd) > irq_num, 5*HZ);\nout:\n\tif (ret > 0)\n\t\tret = 0;\n\tmutex_unlock(&qdev->async_io_mutex);\n\treturn ret;\n}\n\nstatic void wait_for_io_cmd(struct qxl_device *qdev, uint8_t val, long port)\n{\n\tint ret;\n\nrestart:\n\tret = wait_for_io_cmd_user(qdev, val, port, false);\n\tif (ret == -ERESTARTSYS)\n\t\tgoto restart;\n}\n\nint qxl_io_update_area(struct qxl_device *qdev, struct qxl_bo *surf,\n\t\t\tconst struct qxl_rect *area)\n{\n\tint surface_id;\n\tuint32_t surface_width, surface_height;\n\tint ret;\n\n\tif (!surf->hw_surf_alloc)\n\t\tDRM_ERROR(\"got io update area with no hw surface\\n\");\n\n\tif (surf->is_primary)\n\t\tsurface_id = 0;\n\telse\n\t\tsurface_id = surf->surface_id;\n\tsurface_width = surf->surf.width;\n\tsurface_height = surf->surf.height;\n\n\tif (area->left < 0 || area->top < 0 ||\n\t    area->right > surface_width || area->bottom > surface_height)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&qdev->update_area_mutex);\n\tqdev->ram_header->update_area = *area;\n\tqdev->ram_header->update_surface = surface_id;\n\tret = wait_for_io_cmd_user(qdev, 0, QXL_IO_UPDATE_AREA_ASYNC, true);\n\tmutex_unlock(&qdev->update_area_mutex);\n\treturn ret;\n}\n\nvoid qxl_io_notify_oom(struct qxl_device *qdev)\n{\n\toutb(0, qdev->io_base + QXL_IO_NOTIFY_OOM);\n}\n\nvoid qxl_io_flush_release(struct qxl_device *qdev)\n{\n\toutb(0, qdev->io_base + QXL_IO_FLUSH_RELEASE);\n}\n\nvoid qxl_io_flush_surfaces(struct qxl_device *qdev)\n{\n\twait_for_io_cmd(qdev, 0, QXL_IO_FLUSH_SURFACES_ASYNC);\n}\n\nvoid qxl_io_destroy_primary(struct qxl_device *qdev)\n{\n\twait_for_io_cmd(qdev, 0, QXL_IO_DESTROY_PRIMARY_ASYNC);\n\tqdev->primary_bo->is_primary = false;\n\tdrm_gem_object_put(&qdev->primary_bo->tbo.base);\n\tqdev->primary_bo = NULL;\n}\n\nvoid qxl_io_create_primary(struct qxl_device *qdev, struct qxl_bo *bo)\n{\n\tstruct qxl_surface_create *create;\n\n\tif (WARN_ON(qdev->primary_bo))\n\t\treturn;\n\n\tDRM_DEBUG_DRIVER(\"qdev %p, ram_header %p\\n\", qdev, qdev->ram_header);\n\tcreate = &qdev->ram_header->create_surface;\n\tcreate->format = bo->surf.format;\n\tcreate->width = bo->surf.width;\n\tcreate->height = bo->surf.height;\n\tcreate->stride = bo->surf.stride;\n\tcreate->mem = qxl_bo_physical_address(qdev, bo, 0);\n\n\tDRM_DEBUG_DRIVER(\"mem = %llx, from %p\\n\", create->mem, bo->kptr);\n\n\tcreate->flags = QXL_SURF_FLAG_KEEP_DATA;\n\tcreate->type = QXL_SURF_TYPE_PRIMARY;\n\n\twait_for_io_cmd(qdev, 0, QXL_IO_CREATE_PRIMARY_ASYNC);\n\tqdev->primary_bo = bo;\n\tqdev->primary_bo->is_primary = true;\n\tdrm_gem_object_get(&qdev->primary_bo->tbo.base);\n}\n\nvoid qxl_io_memslot_add(struct qxl_device *qdev, uint8_t id)\n{\n\tDRM_DEBUG_DRIVER(\"qxl_memslot_add %d\\n\", id);\n\twait_for_io_cmd(qdev, id, QXL_IO_MEMSLOT_ADD_ASYNC);\n}\n\nvoid qxl_io_reset(struct qxl_device *qdev)\n{\n\toutb(0, qdev->io_base + QXL_IO_RESET);\n}\n\nvoid qxl_io_monitors_config(struct qxl_device *qdev)\n{\n\twait_for_io_cmd(qdev, 0, QXL_IO_MONITORS_CONFIG_ASYNC);\n}\n\nint qxl_surface_id_alloc(struct qxl_device *qdev,\n\t\t      struct qxl_bo *surf)\n{\n\tuint32_t handle;\n\tint idr_ret;\n\tint count = 0;\nagain:\n\tidr_preload(GFP_ATOMIC);\n\tspin_lock(&qdev->surf_id_idr_lock);\n\tidr_ret = idr_alloc(&qdev->surf_id_idr, NULL, 1, 0, GFP_NOWAIT);\n\tspin_unlock(&qdev->surf_id_idr_lock);\n\tidr_preload_end();\n\tif (idr_ret < 0)\n\t\treturn idr_ret;\n\thandle = idr_ret;\n\n\tif (handle >= qdev->rom->n_surfaces) {\n\t\tcount++;\n\t\tspin_lock(&qdev->surf_id_idr_lock);\n\t\tidr_remove(&qdev->surf_id_idr, handle);\n\t\tspin_unlock(&qdev->surf_id_idr_lock);\n\t\tqxl_reap_surface_id(qdev, 2);\n\t\tgoto again;\n\t}\n\tsurf->surface_id = handle;\n\n\tspin_lock(&qdev->surf_id_idr_lock);\n\tqdev->last_alloced_surf_id = handle;\n\tspin_unlock(&qdev->surf_id_idr_lock);\n\treturn 0;\n}\n\nvoid qxl_surface_id_dealloc(struct qxl_device *qdev,\n\t\t\t    uint32_t surface_id)\n{\n\tspin_lock(&qdev->surf_id_idr_lock);\n\tidr_remove(&qdev->surf_id_idr, surface_id);\n\tspin_unlock(&qdev->surf_id_idr_lock);\n}\n\nint qxl_hw_surface_alloc(struct qxl_device *qdev,\n\t\t\t struct qxl_bo *surf)\n{\n\tstruct qxl_surface_cmd *cmd;\n\tstruct qxl_release *release;\n\tint ret;\n\n\tif (surf->hw_surf_alloc)\n\t\treturn 0;\n\n\tret = qxl_alloc_surface_release_reserved(qdev, QXL_SURFACE_CMD_CREATE,\n\t\t\t\t\t\t NULL,\n\t\t\t\t\t\t &release);\n\tif (ret)\n\t\treturn ret;\n\n\tret = qxl_release_reserve_list(release, true);\n\tif (ret) {\n\t\tqxl_release_free(qdev, release);\n\t\treturn ret;\n\t}\n\tcmd = (struct qxl_surface_cmd *)qxl_release_map(qdev, release);\n\tcmd->type = QXL_SURFACE_CMD_CREATE;\n\tcmd->flags = QXL_SURF_FLAG_KEEP_DATA;\n\tcmd->u.surface_create.format = surf->surf.format;\n\tcmd->u.surface_create.width = surf->surf.width;\n\tcmd->u.surface_create.height = surf->surf.height;\n\tcmd->u.surface_create.stride = surf->surf.stride;\n\tcmd->u.surface_create.data = qxl_bo_physical_address(qdev, surf, 0);\n\tcmd->surface_id = surf->surface_id;\n\tqxl_release_unmap(qdev, release, &cmd->release_info);\n\n\tsurf->surf_create = release;\n\n\t \n\tqxl_release_fence_buffer_objects(release);\n\tqxl_push_command_ring_release(qdev, release, QXL_CMD_SURFACE, false);\n\n\tsurf->hw_surf_alloc = true;\n\tspin_lock(&qdev->surf_id_idr_lock);\n\tidr_replace(&qdev->surf_id_idr, surf, surf->surface_id);\n\tspin_unlock(&qdev->surf_id_idr_lock);\n\treturn 0;\n}\n\nint qxl_hw_surface_dealloc(struct qxl_device *qdev,\n\t\t\t   struct qxl_bo *surf)\n{\n\tstruct qxl_surface_cmd *cmd;\n\tstruct qxl_release *release;\n\tint ret;\n\tint id;\n\n\tif (!surf->hw_surf_alloc)\n\t\treturn 0;\n\n\tret = qxl_alloc_surface_release_reserved(qdev, QXL_SURFACE_CMD_DESTROY,\n\t\t\t\t\t\t surf->surf_create,\n\t\t\t\t\t\t &release);\n\tif (ret)\n\t\treturn ret;\n\n\tsurf->surf_create = NULL;\n\t \n\tspin_lock(&qdev->surf_id_idr_lock);\n\tidr_replace(&qdev->surf_id_idr, NULL, surf->surface_id);\n\tspin_unlock(&qdev->surf_id_idr_lock);\n\tsurf->hw_surf_alloc = false;\n\n\tid = surf->surface_id;\n\tsurf->surface_id = 0;\n\n\trelease->surface_release_id = id;\n\tcmd = (struct qxl_surface_cmd *)qxl_release_map(qdev, release);\n\tcmd->type = QXL_SURFACE_CMD_DESTROY;\n\tcmd->surface_id = id;\n\tqxl_release_unmap(qdev, release, &cmd->release_info);\n\n\tqxl_release_fence_buffer_objects(release);\n\tqxl_push_command_ring_release(qdev, release, QXL_CMD_SURFACE, false);\n\n\treturn 0;\n}\n\nstatic int qxl_update_surface(struct qxl_device *qdev, struct qxl_bo *surf)\n{\n\tstruct qxl_rect rect;\n\tint ret;\n\n\t \n\trect.left = 0;\n\trect.right = surf->surf.width;\n\trect.top = 0;\n\trect.bottom = surf->surf.height;\nretry:\n\tret = qxl_io_update_area(qdev, surf, &rect);\n\tif (ret == -ERESTARTSYS)\n\t\tgoto retry;\n\treturn ret;\n}\n\nstatic void qxl_surface_evict_locked(struct qxl_device *qdev, struct qxl_bo *surf, bool do_update_area)\n{\n\t \n\tif (do_update_area)\n\t\tqxl_update_surface(qdev, surf);\n\n\t \n\tqxl_hw_surface_dealloc(qdev, surf);\n}\n\nvoid qxl_surface_evict(struct qxl_device *qdev, struct qxl_bo *surf, bool do_update_area)\n{\n\tmutex_lock(&qdev->surf_evict_mutex);\n\tqxl_surface_evict_locked(qdev, surf, do_update_area);\n\tmutex_unlock(&qdev->surf_evict_mutex);\n}\n\nstatic int qxl_reap_surf(struct qxl_device *qdev, struct qxl_bo *surf, bool stall)\n{\n\tlong ret;\n\n\tret = qxl_bo_reserve(surf);\n\tif (ret)\n\t\treturn ret;\n\n\tif (stall)\n\t\tmutex_unlock(&qdev->surf_evict_mutex);\n\n\tif (stall) {\n\t\tret = dma_resv_wait_timeout(surf->tbo.base.resv,\n\t\t\t\t\t    DMA_RESV_USAGE_BOOKKEEP, true,\n\t\t\t\t\t    15 * HZ);\n\t\tif (ret > 0)\n\t\t\tret = 0;\n\t\telse if (ret == 0)\n\t\t\tret = -EBUSY;\n\t} else {\n\t\tret = dma_resv_test_signaled(surf->tbo.base.resv,\n\t\t\t\t\t     DMA_RESV_USAGE_BOOKKEEP);\n\t\tret = ret ? -EBUSY : 0;\n\t}\n\n\tif (stall)\n\t\tmutex_lock(&qdev->surf_evict_mutex);\n\tif (ret) {\n\t\tqxl_bo_unreserve(surf);\n\t\treturn ret;\n\t}\n\n\tqxl_surface_evict_locked(qdev, surf, true);\n\tqxl_bo_unreserve(surf);\n\treturn 0;\n}\n\nstatic int qxl_reap_surface_id(struct qxl_device *qdev, int max_to_reap)\n{\n\tint num_reaped = 0;\n\tint i, ret;\n\tbool stall = false;\n\tint start = 0;\n\n\tmutex_lock(&qdev->surf_evict_mutex);\nagain:\n\n\tspin_lock(&qdev->surf_id_idr_lock);\n\tstart = qdev->last_alloced_surf_id + 1;\n\tspin_unlock(&qdev->surf_id_idr_lock);\n\n\tfor (i = start; i < start + qdev->rom->n_surfaces; i++) {\n\t\tvoid *objptr;\n\t\tint surfid = i % qdev->rom->n_surfaces;\n\n\t\t \n\t\tspin_lock(&qdev->surf_id_idr_lock);\n\t\tobjptr = idr_find(&qdev->surf_id_idr, surfid);\n\t\tspin_unlock(&qdev->surf_id_idr_lock);\n\n\t\tif (!objptr)\n\t\t\tcontinue;\n\n\t\tret = qxl_reap_surf(qdev, objptr, stall);\n\t\tif (ret == 0)\n\t\t\tnum_reaped++;\n\t\tif (num_reaped >= max_to_reap)\n\t\t\tbreak;\n\t}\n\tif (num_reaped == 0 && stall == false) {\n\t\tstall = true;\n\t\tgoto again;\n\t}\n\n\tmutex_unlock(&qdev->surf_evict_mutex);\n\tif (num_reaped) {\n\t\tusleep_range(500, 1000);\n\t\tqxl_queue_garbage_collect(qdev, true);\n\t}\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}