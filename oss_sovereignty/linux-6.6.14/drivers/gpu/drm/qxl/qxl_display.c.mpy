{
  "module_name": "qxl_display.c",
  "hash_id": "8d1158f59cfa17c9da74ca8293a6a1834068e2b1b04847bbebfee351112529d3",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/qxl/qxl_display.c",
  "human_readable_source": " \n\n#include <linux/crc32.h>\n#include <linux/delay.h>\n#include <linux/iosys-map.h>\n\n#include <drm/drm_drv.h>\n#include <drm/drm_atomic.h>\n#include <drm/drm_atomic_helper.h>\n#include <drm/drm_edid.h>\n#include <drm/drm_framebuffer.h>\n#include <drm/drm_gem_framebuffer_helper.h>\n#include <drm/drm_plane_helper.h>\n#include <drm/drm_probe_helper.h>\n#include <drm/drm_simple_kms_helper.h>\n#include <drm/drm_gem_atomic_helper.h>\n\n#include \"qxl_drv.h\"\n#include \"qxl_object.h\"\n\nstatic bool qxl_head_enabled(struct qxl_head *head)\n{\n\treturn head->width && head->height;\n}\n\nstatic int qxl_alloc_client_monitors_config(struct qxl_device *qdev,\n\t\tunsigned int count)\n{\n\tif (qdev->client_monitors_config &&\n\t    count > qdev->client_monitors_config->count) {\n\t\tkfree(qdev->client_monitors_config);\n\t\tqdev->client_monitors_config = NULL;\n\t}\n\tif (!qdev->client_monitors_config) {\n\t\tqdev->client_monitors_config = kzalloc(\n\t\t\t\tstruct_size(qdev->client_monitors_config,\n\t\t\t\theads, count), GFP_KERNEL);\n\t\tif (!qdev->client_monitors_config)\n\t\t\treturn -ENOMEM;\n\t}\n\tqdev->client_monitors_config->count = count;\n\treturn 0;\n}\n\nenum {\n\tMONITORS_CONFIG_MODIFIED,\n\tMONITORS_CONFIG_UNCHANGED,\n\tMONITORS_CONFIG_BAD_CRC,\n\tMONITORS_CONFIG_ERROR,\n};\n\nstatic int qxl_display_copy_rom_client_monitors_config(struct qxl_device *qdev)\n{\n\tint i;\n\tint num_monitors;\n\tuint32_t crc;\n\tint status = MONITORS_CONFIG_UNCHANGED;\n\n\tnum_monitors = qdev->rom->client_monitors_config.count;\n\tcrc = crc32(0, (const uint8_t *)&qdev->rom->client_monitors_config,\n\t\t  sizeof(qdev->rom->client_monitors_config));\n\tif (crc != qdev->rom->client_monitors_config_crc)\n\t\treturn MONITORS_CONFIG_BAD_CRC;\n\tif (!num_monitors) {\n\t\tDRM_DEBUG_KMS(\"no client monitors configured\\n\");\n\t\treturn status;\n\t}\n\tif (num_monitors > qxl_num_crtc) {\n\t\tDRM_DEBUG_KMS(\"client monitors list will be truncated: %d < %d\\n\",\n\t\t\t      qxl_num_crtc, num_monitors);\n\t\tnum_monitors = qxl_num_crtc;\n\t} else {\n\t\tnum_monitors = qdev->rom->client_monitors_config.count;\n\t}\n\tif (qdev->client_monitors_config\n\t      && (num_monitors != qdev->client_monitors_config->count)) {\n\t\tstatus = MONITORS_CONFIG_MODIFIED;\n\t}\n\tif (qxl_alloc_client_monitors_config(qdev, num_monitors)) {\n\t\tstatus = MONITORS_CONFIG_ERROR;\n\t\treturn status;\n\t}\n\t \n\tqdev->client_monitors_config->max_allowed = qxl_num_crtc;\n\tfor (i = 0 ; i < qdev->client_monitors_config->count ; ++i) {\n\t\tstruct qxl_urect *c_rect =\n\t\t\t&qdev->rom->client_monitors_config.heads[i];\n\t\tstruct qxl_head *client_head =\n\t\t\t&qdev->client_monitors_config->heads[i];\n\t\tif (client_head->x != c_rect->left) {\n\t\t\tclient_head->x = c_rect->left;\n\t\t\tstatus = MONITORS_CONFIG_MODIFIED;\n\t\t}\n\t\tif (client_head->y != c_rect->top) {\n\t\t\tclient_head->y = c_rect->top;\n\t\t\tstatus = MONITORS_CONFIG_MODIFIED;\n\t\t}\n\t\tif (client_head->width != c_rect->right - c_rect->left) {\n\t\t\tclient_head->width = c_rect->right - c_rect->left;\n\t\t\tstatus = MONITORS_CONFIG_MODIFIED;\n\t\t}\n\t\tif (client_head->height != c_rect->bottom - c_rect->top) {\n\t\t\tclient_head->height = c_rect->bottom - c_rect->top;\n\t\t\tstatus = MONITORS_CONFIG_MODIFIED;\n\t\t}\n\t\tif (client_head->surface_id != 0) {\n\t\t\tclient_head->surface_id = 0;\n\t\t\tstatus = MONITORS_CONFIG_MODIFIED;\n\t\t}\n\t\tif (client_head->id != i) {\n\t\t\tclient_head->id = i;\n\t\t\tstatus = MONITORS_CONFIG_MODIFIED;\n\t\t}\n\t\tif (client_head->flags != 0) {\n\t\t\tclient_head->flags = 0;\n\t\t\tstatus = MONITORS_CONFIG_MODIFIED;\n\t\t}\n\t\tDRM_DEBUG_KMS(\"read %dx%d+%d+%d\\n\", client_head->width, client_head->height,\n\t\t\t  client_head->x, client_head->y);\n\t}\n\n\treturn status;\n}\n\nstatic void qxl_update_offset_props(struct qxl_device *qdev)\n{\n\tstruct drm_device *dev = &qdev->ddev;\n\tstruct drm_connector *connector;\n\tstruct qxl_output *output;\n\tstruct qxl_head *head;\n\n\tlist_for_each_entry(connector, &dev->mode_config.connector_list, head) {\n\t\toutput = drm_connector_to_qxl_output(connector);\n\n\t\thead = &qdev->client_monitors_config->heads[output->index];\n\n\t\tdrm_object_property_set_value(&connector->base,\n\t\t\tdev->mode_config.suggested_x_property, head->x);\n\t\tdrm_object_property_set_value(&connector->base,\n\t\t\tdev->mode_config.suggested_y_property, head->y);\n\t}\n}\n\nvoid qxl_display_read_client_monitors_config(struct qxl_device *qdev)\n{\n\tstruct drm_device *dev = &qdev->ddev;\n\tstruct drm_modeset_acquire_ctx ctx;\n\tint status, retries, ret;\n\n\tfor (retries = 0; retries < 10; retries++) {\n\t\tstatus = qxl_display_copy_rom_client_monitors_config(qdev);\n\t\tif (status != MONITORS_CONFIG_BAD_CRC)\n\t\t\tbreak;\n\t\tudelay(5);\n\t}\n\tif (status == MONITORS_CONFIG_ERROR) {\n\t\tDRM_DEBUG_KMS(\"ignoring client monitors config: error\");\n\t\treturn;\n\t}\n\tif (status == MONITORS_CONFIG_BAD_CRC) {\n\t\tDRM_DEBUG_KMS(\"ignoring client monitors config: bad crc\");\n\t\treturn;\n\t}\n\tif (status == MONITORS_CONFIG_UNCHANGED) {\n\t\tDRM_DEBUG_KMS(\"ignoring client monitors config: unchanged\");\n\t\treturn;\n\t}\n\n\tDRM_MODESET_LOCK_ALL_BEGIN(dev, ctx, DRM_MODESET_ACQUIRE_INTERRUPTIBLE, ret);\n\tqxl_update_offset_props(qdev);\n\tDRM_MODESET_LOCK_ALL_END(dev, ctx, ret);\n\tif (!drm_helper_hpd_irq_event(dev)) {\n\t\t \n\t\tdrm_kms_helper_hotplug_event(dev);\n\t}\n}\n\nstatic int qxl_check_mode(struct qxl_device *qdev,\n\t\t\t  unsigned int width,\n\t\t\t  unsigned int height)\n{\n\tunsigned int stride;\n\tunsigned int size;\n\n\tif (check_mul_overflow(width, 4u, &stride))\n\t\treturn -EINVAL;\n\tif (check_mul_overflow(stride, height, &size))\n\t\treturn -EINVAL;\n\tif (size > qdev->vram_size)\n\t\treturn -ENOMEM;\n\treturn 0;\n}\n\nstatic int qxl_check_framebuffer(struct qxl_device *qdev,\n\t\t\t\t struct qxl_bo *bo)\n{\n\treturn qxl_check_mode(qdev, bo->surf.width, bo->surf.height);\n}\n\nstatic int qxl_add_mode(struct drm_connector *connector,\n\t\t\tunsigned int width,\n\t\t\tunsigned int height,\n\t\t\tbool preferred)\n{\n\tstruct drm_device *dev = connector->dev;\n\tstruct qxl_device *qdev = to_qxl(dev);\n\tstruct drm_display_mode *mode = NULL;\n\tint rc;\n\n\trc = qxl_check_mode(qdev, width, height);\n\tif (rc != 0)\n\t\treturn 0;\n\n\tmode = drm_cvt_mode(dev, width, height, 60, false, false, false);\n\tif (preferred)\n\t\tmode->type |= DRM_MODE_TYPE_PREFERRED;\n\tmode->hdisplay = width;\n\tmode->vdisplay = height;\n\tdrm_mode_set_name(mode);\n\tdrm_mode_probed_add(connector, mode);\n\treturn 1;\n}\n\nstatic int qxl_add_monitors_config_modes(struct drm_connector *connector)\n{\n\tstruct drm_device *dev = connector->dev;\n\tstruct qxl_device *qdev = to_qxl(dev);\n\tstruct qxl_output *output = drm_connector_to_qxl_output(connector);\n\tint h = output->index;\n\tstruct qxl_head *head;\n\n\tif (!qdev->monitors_config)\n\t\treturn 0;\n\tif (h >= qxl_num_crtc)\n\t\treturn 0;\n\tif (!qdev->client_monitors_config)\n\t\treturn 0;\n\tif (h >= qdev->client_monitors_config->count)\n\t\treturn 0;\n\n\thead = &qdev->client_monitors_config->heads[h];\n\tDRM_DEBUG_KMS(\"head %d is %dx%d\\n\", h, head->width, head->height);\n\n\treturn qxl_add_mode(connector, head->width, head->height, true);\n}\n\nstatic struct mode_size {\n\tint w;\n\tint h;\n} extra_modes[] = {\n\t{ 720,  480},\n\t{1152,  768},\n\t{1280,  854},\n};\n\nstatic int qxl_add_extra_modes(struct drm_connector *connector)\n{\n\tint i, ret = 0;\n\n\tfor (i = 0; i < ARRAY_SIZE(extra_modes); i++)\n\t\tret += qxl_add_mode(connector,\n\t\t\t\t    extra_modes[i].w,\n\t\t\t\t    extra_modes[i].h,\n\t\t\t\t    false);\n\treturn ret;\n}\n\nstatic void qxl_send_monitors_config(struct qxl_device *qdev)\n{\n\tint i;\n\n\tBUG_ON(!qdev->ram_header->monitors_config);\n\n\tif (qdev->monitors_config->count == 0)\n\t\treturn;\n\n\tfor (i = 0 ; i < qdev->monitors_config->count ; ++i) {\n\t\tstruct qxl_head *head = &qdev->monitors_config->heads[i];\n\n\t\tif (head->y > 8192 || head->x > 8192 ||\n\t\t    head->width > 8192 || head->height > 8192) {\n\t\t\tDRM_ERROR(\"head %d wrong: %dx%d+%d+%d\\n\",\n\t\t\t\t  i, head->width, head->height,\n\t\t\t\t  head->x, head->y);\n\t\t\treturn;\n\t\t}\n\t}\n\tqxl_io_monitors_config(qdev);\n}\n\nstatic void qxl_crtc_update_monitors_config(struct drm_crtc *crtc,\n\t\t\t\t\t    const char *reason)\n{\n\tstruct drm_device *dev = crtc->dev;\n\tstruct qxl_device *qdev = to_qxl(dev);\n\tstruct qxl_crtc *qcrtc = to_qxl_crtc(crtc);\n\tstruct qxl_head head;\n\tint oldcount, i = qcrtc->index;\n\n\tif (!qdev->primary_bo) {\n\t\tDRM_DEBUG_KMS(\"no primary surface, skip (%s)\\n\", reason);\n\t\treturn;\n\t}\n\n\tif (!qdev->monitors_config || qxl_num_crtc <= i)\n\t\treturn;\n\n\thead.id = i;\n\thead.flags = 0;\n\thead.surface_id = 0;\n\toldcount = qdev->monitors_config->count;\n\tif (crtc->state->active) {\n\t\tstruct drm_display_mode *mode = &crtc->mode;\n\n\t\thead.width = mode->hdisplay;\n\t\thead.height = mode->vdisplay;\n\t\thead.x = crtc->x;\n\t\thead.y = crtc->y;\n\t\tif (qdev->monitors_config->count < i + 1)\n\t\t\tqdev->monitors_config->count = i + 1;\n\t\tif (qdev->primary_bo == qdev->dumb_shadow_bo)\n\t\t\thead.x += qdev->dumb_heads[i].x;\n\t} else if (i > 0) {\n\t\thead.width = 0;\n\t\thead.height = 0;\n\t\thead.x = 0;\n\t\thead.y = 0;\n\t\tif (qdev->monitors_config->count == i + 1)\n\t\t\tqdev->monitors_config->count = i;\n\t} else {\n\t\tDRM_DEBUG_KMS(\"inactive head 0, skip (%s)\\n\", reason);\n\t\treturn;\n\t}\n\n\tif (head.width  == qdev->monitors_config->heads[i].width  &&\n\t    head.height == qdev->monitors_config->heads[i].height &&\n\t    head.x      == qdev->monitors_config->heads[i].x      &&\n\t    head.y      == qdev->monitors_config->heads[i].y      &&\n\t    oldcount    == qdev->monitors_config->count)\n\t\treturn;\n\n\tDRM_DEBUG_KMS(\"head %d, %dx%d, at +%d+%d, %s (%s)\\n\",\n\t\t      i, head.width, head.height, head.x, head.y,\n\t\t      crtc->state->active ? \"on\" : \"off\", reason);\n\tif (oldcount != qdev->monitors_config->count)\n\t\tDRM_DEBUG_KMS(\"active heads %d -> %d (%d total)\\n\",\n\t\t\t      oldcount, qdev->monitors_config->count,\n\t\t\t      qxl_num_crtc);\n\n\tqdev->monitors_config->heads[i] = head;\n\tqdev->monitors_config->max_allowed = qxl_num_crtc;\n\tqxl_send_monitors_config(qdev);\n}\n\nstatic void qxl_crtc_atomic_flush(struct drm_crtc *crtc,\n\t\t\t\t  struct drm_atomic_state *state)\n{\n\tqxl_crtc_update_monitors_config(crtc, \"flush\");\n}\n\nstatic void qxl_crtc_destroy(struct drm_crtc *crtc)\n{\n\tstruct qxl_crtc *qxl_crtc = to_qxl_crtc(crtc);\n\n\tqxl_bo_unref(&qxl_crtc->cursor_bo);\n\tdrm_crtc_cleanup(crtc);\n\tkfree(qxl_crtc);\n}\n\nstatic const struct drm_crtc_funcs qxl_crtc_funcs = {\n\t.set_config = drm_atomic_helper_set_config,\n\t.destroy = qxl_crtc_destroy,\n\t.page_flip = drm_atomic_helper_page_flip,\n\t.reset = drm_atomic_helper_crtc_reset,\n\t.atomic_duplicate_state = drm_atomic_helper_crtc_duplicate_state,\n\t.atomic_destroy_state = drm_atomic_helper_crtc_destroy_state,\n};\n\nstatic int qxl_framebuffer_surface_dirty(struct drm_framebuffer *fb,\n\t\t\t\t\t struct drm_file *file_priv,\n\t\t\t\t\t unsigned int flags, unsigned int color,\n\t\t\t\t\t struct drm_clip_rect *clips,\n\t\t\t\t\t unsigned int num_clips)\n{\n\t \n\tstruct qxl_device *qdev = to_qxl(fb->dev);\n\tstruct drm_clip_rect norect;\n\tstruct qxl_bo *qobj;\n\tstruct drm_modeset_acquire_ctx ctx;\n\tbool is_primary;\n\tint inc = 1, ret;\n\n\tDRM_MODESET_LOCK_ALL_BEGIN(fb->dev, ctx, DRM_MODESET_ACQUIRE_INTERRUPTIBLE, ret);\n\n\tqobj = gem_to_qxl_bo(fb->obj[0]);\n\t \n\tis_primary = qobj->shadow ? qobj->shadow->is_primary : qobj->is_primary;\n\tif (!is_primary)\n\t\tgoto out_lock_end;\n\n\tif (!num_clips) {\n\t\tnum_clips = 1;\n\t\tclips = &norect;\n\t\tnorect.x1 = norect.y1 = 0;\n\t\tnorect.x2 = fb->width;\n\t\tnorect.y2 = fb->height;\n\t} else if (flags & DRM_MODE_FB_DIRTY_ANNOTATE_COPY) {\n\t\tnum_clips /= 2;\n\t\tinc = 2;  \n\t}\n\n\tqxl_draw_dirty_fb(qdev, fb, qobj, flags, color,\n\t\t\t  clips, num_clips, inc, 0);\n\nout_lock_end:\n\tDRM_MODESET_LOCK_ALL_END(fb->dev, ctx, ret);\n\n\treturn 0;\n}\n\nstatic const struct drm_framebuffer_funcs qxl_fb_funcs = {\n\t.destroy = drm_gem_fb_destroy,\n\t.dirty = qxl_framebuffer_surface_dirty,\n\t.create_handle = drm_gem_fb_create_handle,\n};\n\nstatic void qxl_crtc_atomic_enable(struct drm_crtc *crtc,\n\t\t\t\t   struct drm_atomic_state *state)\n{\n\tqxl_crtc_update_monitors_config(crtc, \"enable\");\n}\n\nstatic void qxl_crtc_atomic_disable(struct drm_crtc *crtc,\n\t\t\t\t    struct drm_atomic_state *state)\n{\n\tqxl_crtc_update_monitors_config(crtc, \"disable\");\n}\n\nstatic const struct drm_crtc_helper_funcs qxl_crtc_helper_funcs = {\n\t.atomic_flush = qxl_crtc_atomic_flush,\n\t.atomic_enable = qxl_crtc_atomic_enable,\n\t.atomic_disable = qxl_crtc_atomic_disable,\n};\n\nstatic int qxl_primary_atomic_check(struct drm_plane *plane,\n\t\t\t\t    struct drm_atomic_state *state)\n{\n\tstruct drm_plane_state *new_plane_state = drm_atomic_get_new_plane_state(state,\n\t\t\t\t\t\t\t\t\t\t plane);\n\tstruct qxl_device *qdev = to_qxl(plane->dev);\n\tstruct qxl_bo *bo;\n\n\tif (!new_plane_state->crtc || !new_plane_state->fb)\n\t\treturn 0;\n\n\tbo = gem_to_qxl_bo(new_plane_state->fb->obj[0]);\n\n\treturn qxl_check_framebuffer(qdev, bo);\n}\n\nstatic int qxl_primary_apply_cursor(struct qxl_device *qdev,\n\t\t\t\t    struct drm_plane_state *plane_state)\n{\n\tstruct drm_framebuffer *fb = plane_state->fb;\n\tstruct qxl_crtc *qcrtc = to_qxl_crtc(plane_state->crtc);\n\tstruct qxl_cursor_cmd *cmd;\n\tstruct qxl_release *release;\n\tint ret = 0;\n\n\tif (!qcrtc->cursor_bo)\n\t\treturn 0;\n\n\tret = qxl_alloc_release_reserved(qdev, sizeof(*cmd),\n\t\t\t\t\t QXL_RELEASE_CURSOR_CMD,\n\t\t\t\t\t &release, NULL);\n\tif (ret)\n\t\treturn ret;\n\n\tret = qxl_release_list_add(release, qcrtc->cursor_bo);\n\tif (ret)\n\t\tgoto out_free_release;\n\n\tret = qxl_release_reserve_list(release, false);\n\tif (ret)\n\t\tgoto out_free_release;\n\n\tcmd = (struct qxl_cursor_cmd *)qxl_release_map(qdev, release);\n\tcmd->type = QXL_CURSOR_SET;\n\tcmd->u.set.position.x = plane_state->crtc_x + fb->hot_x;\n\tcmd->u.set.position.y = plane_state->crtc_y + fb->hot_y;\n\n\tcmd->u.set.shape = qxl_bo_physical_address(qdev, qcrtc->cursor_bo, 0);\n\n\tcmd->u.set.visible = 1;\n\tqxl_release_unmap(qdev, release, &cmd->release_info);\n\n\tqxl_release_fence_buffer_objects(release);\n\tqxl_push_cursor_ring_release(qdev, release, QXL_CMD_CURSOR, false);\n\n\treturn ret;\n\nout_free_release:\n\tqxl_release_free(qdev, release);\n\treturn ret;\n}\n\nstatic int qxl_primary_move_cursor(struct qxl_device *qdev,\n\t\t\t\t   struct drm_plane_state *plane_state)\n{\n\tstruct drm_framebuffer *fb = plane_state->fb;\n\tstruct qxl_crtc *qcrtc = to_qxl_crtc(plane_state->crtc);\n\tstruct qxl_cursor_cmd *cmd;\n\tstruct qxl_release *release;\n\tint ret = 0;\n\n\tif (!qcrtc->cursor_bo)\n\t\treturn 0;\n\n\tret = qxl_alloc_release_reserved(qdev, sizeof(*cmd),\n\t\t\t\t\t QXL_RELEASE_CURSOR_CMD,\n\t\t\t\t\t &release, NULL);\n\tif (ret)\n\t\treturn ret;\n\n\tret = qxl_release_reserve_list(release, true);\n\tif (ret) {\n\t\tqxl_release_free(qdev, release);\n\t\treturn ret;\n\t}\n\n\tcmd = (struct qxl_cursor_cmd *)qxl_release_map(qdev, release);\n\tcmd->type = QXL_CURSOR_MOVE;\n\tcmd->u.position.x = plane_state->crtc_x + fb->hot_x;\n\tcmd->u.position.y = plane_state->crtc_y + fb->hot_y;\n\tqxl_release_unmap(qdev, release, &cmd->release_info);\n\n\tqxl_release_fence_buffer_objects(release);\n\tqxl_push_cursor_ring_release(qdev, release, QXL_CMD_CURSOR, false);\n\treturn ret;\n}\n\nstatic struct qxl_bo *qxl_create_cursor(struct qxl_device *qdev,\n\t\t\t\t\tstruct qxl_bo *user_bo,\n\t\t\t\t\tint hot_x, int hot_y)\n{\n\tstatic const u32 size = 64 * 64 * 4;\n\tstruct qxl_bo *cursor_bo;\n\tstruct iosys_map cursor_map;\n\tstruct iosys_map user_map;\n\tstruct qxl_cursor cursor;\n\tint ret;\n\n\tif (!user_bo)\n\t\treturn NULL;\n\n\tret = qxl_bo_create(qdev, sizeof(struct qxl_cursor) + size,\n\t\t\t    false, true, QXL_GEM_DOMAIN_VRAM, 1,\n\t\t\t    NULL, &cursor_bo);\n\tif (ret)\n\t\tgoto err;\n\n\tret = qxl_bo_vmap(cursor_bo, &cursor_map);\n\tif (ret)\n\t\tgoto err_unref;\n\n\tret = qxl_bo_vmap(user_bo, &user_map);\n\tif (ret)\n\t\tgoto err_unmap;\n\n\tcursor.header.unique = 0;\n\tcursor.header.type = SPICE_CURSOR_TYPE_ALPHA;\n\tcursor.header.width = 64;\n\tcursor.header.height = 64;\n\tcursor.header.hot_spot_x = hot_x;\n\tcursor.header.hot_spot_y = hot_y;\n\tcursor.data_size = size;\n\tcursor.chunk.next_chunk = 0;\n\tcursor.chunk.prev_chunk = 0;\n\tcursor.chunk.data_size = size;\n\tif (cursor_map.is_iomem) {\n\t\tmemcpy_toio(cursor_map.vaddr_iomem,\n\t\t\t    &cursor, sizeof(cursor));\n\t\tmemcpy_toio(cursor_map.vaddr_iomem + sizeof(cursor),\n\t\t\t    user_map.vaddr, size);\n\t} else {\n\t\tmemcpy(cursor_map.vaddr,\n\t\t       &cursor, sizeof(cursor));\n\t\tmemcpy(cursor_map.vaddr + sizeof(cursor),\n\t\t       user_map.vaddr, size);\n\t}\n\n\tqxl_bo_vunmap(user_bo);\n\tqxl_bo_vunmap(cursor_bo);\n\treturn cursor_bo;\n\nerr_unmap:\n\tqxl_bo_vunmap(cursor_bo);\nerr_unref:\n\tqxl_bo_unpin(cursor_bo);\n\tqxl_bo_unref(&cursor_bo);\nerr:\n\treturn NULL;\n}\n\nstatic void qxl_free_cursor(struct qxl_bo *cursor_bo)\n{\n\tif (!cursor_bo)\n\t\treturn;\n\n\tqxl_bo_unpin(cursor_bo);\n\tqxl_bo_unref(&cursor_bo);\n}\n\nstatic void qxl_primary_atomic_update(struct drm_plane *plane,\n\t\t\t\t      struct drm_atomic_state *state)\n{\n\tstruct drm_plane_state *new_state = drm_atomic_get_new_plane_state(state,\n\t\t\t\t\t\t\t\t\t   plane);\n\tstruct qxl_device *qdev = to_qxl(plane->dev);\n\tstruct qxl_bo *bo = gem_to_qxl_bo(new_state->fb->obj[0]);\n\tstruct qxl_bo *primary;\n\tstruct drm_clip_rect norect = {\n\t    .x1 = 0,\n\t    .y1 = 0,\n\t    .x2 = new_state->fb->width,\n\t    .y2 = new_state->fb->height\n\t};\n\tuint32_t dumb_shadow_offset = 0;\n\n\tprimary = bo->shadow ? bo->shadow : bo;\n\n\tif (!primary->is_primary) {\n\t\tif (qdev->primary_bo)\n\t\t\tqxl_io_destroy_primary(qdev);\n\t\tqxl_io_create_primary(qdev, primary);\n\t\tqxl_primary_apply_cursor(qdev, plane->state);\n\t}\n\n\tif (bo->is_dumb)\n\t\tdumb_shadow_offset =\n\t\t\tqdev->dumb_heads[new_state->crtc->index].x;\n\n\tqxl_draw_dirty_fb(qdev, new_state->fb, bo, 0, 0, &norect, 1, 1,\n\t\t\t  dumb_shadow_offset);\n}\n\nstatic void qxl_primary_atomic_disable(struct drm_plane *plane,\n\t\t\t\t       struct drm_atomic_state *state)\n{\n\tstruct drm_plane_state *old_state = drm_atomic_get_old_plane_state(state,\n\t\t\t\t\t\t\t\t\t   plane);\n\tstruct qxl_device *qdev = to_qxl(plane->dev);\n\n\tif (old_state->fb) {\n\t\tstruct qxl_bo *bo = gem_to_qxl_bo(old_state->fb->obj[0]);\n\n\t\tif (bo->shadow)\n\t\t\tbo = bo->shadow;\n\t\tif (bo->is_primary)\n\t\t\tqxl_io_destroy_primary(qdev);\n\t}\n}\n\nstatic void qxl_cursor_atomic_update(struct drm_plane *plane,\n\t\t\t\t     struct drm_atomic_state *state)\n{\n\tstruct drm_plane_state *old_state = drm_atomic_get_old_plane_state(state,\n\t\t\t\t\t\t\t\t\t   plane);\n\tstruct drm_plane_state *new_state = drm_atomic_get_new_plane_state(state,\n\t\t\t\t\t\t\t\t\t   plane);\n\tstruct qxl_device *qdev = to_qxl(plane->dev);\n\tstruct drm_framebuffer *fb = new_state->fb;\n\n\tif (fb != old_state->fb) {\n\t\tqxl_primary_apply_cursor(qdev, new_state);\n\t} else {\n\t\tqxl_primary_move_cursor(qdev, new_state);\n\t}\n}\n\nstatic void qxl_cursor_atomic_disable(struct drm_plane *plane,\n\t\t\t\t      struct drm_atomic_state *state)\n{\n\tstruct drm_plane_state *old_state = drm_atomic_get_old_plane_state(state,\n\t\t\t\t\t\t\t\t\t   plane);\n\tstruct qxl_device *qdev = to_qxl(plane->dev);\n\tstruct qxl_crtc *qcrtc;\n\tstruct qxl_release *release;\n\tstruct qxl_cursor_cmd *cmd;\n\tint ret;\n\n\tret = qxl_alloc_release_reserved(qdev, sizeof(*cmd),\n\t\t\t\t\t QXL_RELEASE_CURSOR_CMD,\n\t\t\t\t\t &release, NULL);\n\tif (ret)\n\t\treturn;\n\n\tret = qxl_release_reserve_list(release, true);\n\tif (ret) {\n\t\tqxl_release_free(qdev, release);\n\t\treturn;\n\t}\n\n\tcmd = (struct qxl_cursor_cmd *)qxl_release_map(qdev, release);\n\tcmd->type = QXL_CURSOR_HIDE;\n\tqxl_release_unmap(qdev, release, &cmd->release_info);\n\n\tqxl_release_fence_buffer_objects(release);\n\tqxl_push_cursor_ring_release(qdev, release, QXL_CMD_CURSOR, false);\n\n\tqcrtc = to_qxl_crtc(old_state->crtc);\n\tqxl_free_cursor(qcrtc->cursor_bo);\n\tqcrtc->cursor_bo = NULL;\n}\n\nstatic void qxl_update_dumb_head(struct qxl_device *qdev,\n\t\t\t\t int index, struct qxl_bo *bo)\n{\n\tuint32_t width, height;\n\n\tif (index >= qdev->monitors_config->max_allowed)\n\t\treturn;\n\n\tif (bo && bo->is_dumb) {\n\t\twidth = bo->surf.width;\n\t\theight = bo->surf.height;\n\t} else {\n\t\twidth = 0;\n\t\theight = 0;\n\t}\n\n\tif (qdev->dumb_heads[index].width == width &&\n\t    qdev->dumb_heads[index].height == height)\n\t\treturn;\n\n\tDRM_DEBUG(\"#%d: %dx%d -> %dx%d\\n\", index,\n\t\t  qdev->dumb_heads[index].width,\n\t\t  qdev->dumb_heads[index].height,\n\t\t  width, height);\n\tqdev->dumb_heads[index].width = width;\n\tqdev->dumb_heads[index].height = height;\n}\n\nstatic void qxl_calc_dumb_shadow(struct qxl_device *qdev,\n\t\t\t\t struct qxl_surface *surf)\n{\n\tstruct qxl_head *head;\n\tint i;\n\n\tmemset(surf, 0, sizeof(*surf));\n\tfor (i = 0; i < qdev->monitors_config->max_allowed; i++) {\n\t\thead = qdev->dumb_heads + i;\n\t\thead->x = surf->width;\n\t\tsurf->width += head->width;\n\t\tif (surf->height < head->height)\n\t\t\tsurf->height = head->height;\n\t}\n\tif (surf->width < 64)\n\t\tsurf->width = 64;\n\tif (surf->height < 64)\n\t\tsurf->height = 64;\n\tsurf->format = SPICE_SURFACE_FMT_32_xRGB;\n\tsurf->stride = surf->width * 4;\n\n\tif (!qdev->dumb_shadow_bo ||\n\t    qdev->dumb_shadow_bo->surf.width != surf->width ||\n\t    qdev->dumb_shadow_bo->surf.height != surf->height)\n\t\tDRM_DEBUG(\"%dx%d\\n\", surf->width, surf->height);\n}\n\nstatic void qxl_prepare_shadow(struct qxl_device *qdev, struct qxl_bo *user_bo,\n\t\t\t       int crtc_index)\n{\n\tstruct qxl_surface surf;\n\n\tqxl_update_dumb_head(qdev, crtc_index,\n\t\t\t     user_bo);\n\tqxl_calc_dumb_shadow(qdev, &surf);\n\tif (!qdev->dumb_shadow_bo ||\n\t    qdev->dumb_shadow_bo->surf.width  != surf.width ||\n\t    qdev->dumb_shadow_bo->surf.height != surf.height) {\n\t\tif (qdev->dumb_shadow_bo) {\n\t\t\tqxl_bo_unpin(qdev->dumb_shadow_bo);\n\t\t\tdrm_gem_object_put\n\t\t\t\t(&qdev->dumb_shadow_bo->tbo.base);\n\t\t\tqdev->dumb_shadow_bo = NULL;\n\t\t}\n\t\tqxl_bo_create(qdev, surf.height * surf.stride,\n\t\t\t      true, true, QXL_GEM_DOMAIN_SURFACE, 0,\n\t\t\t      &surf, &qdev->dumb_shadow_bo);\n\t}\n\tif (user_bo->shadow != qdev->dumb_shadow_bo) {\n\t\tif (user_bo->shadow) {\n\t\t\tqxl_bo_unpin(user_bo->shadow);\n\t\t\tdrm_gem_object_put\n\t\t\t\t(&user_bo->shadow->tbo.base);\n\t\t\tuser_bo->shadow = NULL;\n\t\t}\n\t\tdrm_gem_object_get(&qdev->dumb_shadow_bo->tbo.base);\n\t\tuser_bo->shadow = qdev->dumb_shadow_bo;\n\t\tqxl_bo_pin(user_bo->shadow);\n\t}\n}\n\nstatic int qxl_plane_prepare_fb(struct drm_plane *plane,\n\t\t\t\tstruct drm_plane_state *new_state)\n{\n\tstruct qxl_device *qdev = to_qxl(plane->dev);\n\tstruct drm_gem_object *obj;\n\tstruct qxl_bo *user_bo;\n\tint ret;\n\n\tif (!new_state->fb)\n\t\treturn 0;\n\n\tobj = new_state->fb->obj[0];\n\tuser_bo = gem_to_qxl_bo(obj);\n\n\tif (plane->type == DRM_PLANE_TYPE_PRIMARY &&\n\t    user_bo->is_dumb) {\n\t\tqxl_prepare_shadow(qdev, user_bo, new_state->crtc->index);\n\t}\n\n\tif (plane->type == DRM_PLANE_TYPE_CURSOR &&\n\t    plane->state->fb != new_state->fb) {\n\t\tstruct qxl_crtc *qcrtc = to_qxl_crtc(new_state->crtc);\n\t\tstruct qxl_bo *old_cursor_bo = qcrtc->cursor_bo;\n\n\t\tqcrtc->cursor_bo = qxl_create_cursor(qdev, user_bo,\n\t\t\t\t\t\t     new_state->fb->hot_x,\n\t\t\t\t\t\t     new_state->fb->hot_y);\n\t\tqxl_free_cursor(old_cursor_bo);\n\t}\n\n\tret = qxl_bo_pin(user_bo);\n\tif (ret)\n\t\treturn ret;\n\n\treturn drm_gem_plane_helper_prepare_fb(plane, new_state);\n}\n\nstatic void qxl_plane_cleanup_fb(struct drm_plane *plane,\n\t\t\t\t struct drm_plane_state *old_state)\n{\n\tstruct drm_gem_object *obj;\n\tstruct qxl_bo *user_bo;\n\n\tif (!old_state->fb) {\n\t\t \n\t\treturn;\n\t}\n\n\tobj = old_state->fb->obj[0];\n\tuser_bo = gem_to_qxl_bo(obj);\n\tqxl_bo_unpin(user_bo);\n\n\tif (old_state->fb != plane->state->fb && user_bo->shadow) {\n\t\tqxl_bo_unpin(user_bo->shadow);\n\t\tdrm_gem_object_put(&user_bo->shadow->tbo.base);\n\t\tuser_bo->shadow = NULL;\n\t}\n}\n\nstatic const uint32_t qxl_cursor_plane_formats[] = {\n\tDRM_FORMAT_ARGB8888,\n};\n\nstatic const struct drm_plane_helper_funcs qxl_cursor_helper_funcs = {\n\t.atomic_update = qxl_cursor_atomic_update,\n\t.atomic_disable = qxl_cursor_atomic_disable,\n\t.prepare_fb = qxl_plane_prepare_fb,\n\t.cleanup_fb = qxl_plane_cleanup_fb,\n};\n\nstatic const struct drm_plane_funcs qxl_cursor_plane_funcs = {\n\t.update_plane\t= drm_atomic_helper_update_plane,\n\t.disable_plane\t= drm_atomic_helper_disable_plane,\n\t.destroy\t= drm_plane_helper_destroy,\n\t.reset\t\t= drm_atomic_helper_plane_reset,\n\t.atomic_duplicate_state = drm_atomic_helper_plane_duplicate_state,\n\t.atomic_destroy_state = drm_atomic_helper_plane_destroy_state,\n};\n\nstatic const uint32_t qxl_primary_plane_formats[] = {\n\tDRM_FORMAT_XRGB8888,\n\tDRM_FORMAT_ARGB8888,\n};\n\nstatic const struct drm_plane_helper_funcs primary_helper_funcs = {\n\t.atomic_check = qxl_primary_atomic_check,\n\t.atomic_update = qxl_primary_atomic_update,\n\t.atomic_disable = qxl_primary_atomic_disable,\n\t.prepare_fb = qxl_plane_prepare_fb,\n\t.cleanup_fb = qxl_plane_cleanup_fb,\n};\n\nstatic const struct drm_plane_funcs qxl_primary_plane_funcs = {\n\t.update_plane\t= drm_atomic_helper_update_plane,\n\t.disable_plane\t= drm_atomic_helper_disable_plane,\n\t.destroy\t= drm_plane_helper_destroy,\n\t.reset\t\t= drm_atomic_helper_plane_reset,\n\t.atomic_duplicate_state = drm_atomic_helper_plane_duplicate_state,\n\t.atomic_destroy_state = drm_atomic_helper_plane_destroy_state,\n};\n\nstatic struct drm_plane *qxl_create_plane(struct qxl_device *qdev,\n\t\t\t\t\t  unsigned int possible_crtcs,\n\t\t\t\t\t  enum drm_plane_type type)\n{\n\tconst struct drm_plane_helper_funcs *helper_funcs = NULL;\n\tstruct drm_plane *plane;\n\tconst struct drm_plane_funcs *funcs;\n\tconst uint32_t *formats;\n\tint num_formats;\n\tint err;\n\n\tif (type == DRM_PLANE_TYPE_PRIMARY) {\n\t\tfuncs = &qxl_primary_plane_funcs;\n\t\tformats = qxl_primary_plane_formats;\n\t\tnum_formats = ARRAY_SIZE(qxl_primary_plane_formats);\n\t\thelper_funcs = &primary_helper_funcs;\n\t} else if (type == DRM_PLANE_TYPE_CURSOR) {\n\t\tfuncs = &qxl_cursor_plane_funcs;\n\t\tformats = qxl_cursor_plane_formats;\n\t\thelper_funcs = &qxl_cursor_helper_funcs;\n\t\tnum_formats = ARRAY_SIZE(qxl_cursor_plane_formats);\n\t} else {\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\tplane = kzalloc(sizeof(*plane), GFP_KERNEL);\n\tif (!plane)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\terr = drm_universal_plane_init(&qdev->ddev, plane, possible_crtcs,\n\t\t\t\t       funcs, formats, num_formats,\n\t\t\t\t       NULL, type, NULL);\n\tif (err)\n\t\tgoto free_plane;\n\n\tdrm_plane_helper_add(plane, helper_funcs);\n\n\treturn plane;\n\nfree_plane:\n\tkfree(plane);\n\treturn ERR_PTR(-EINVAL);\n}\n\nstatic int qdev_crtc_init(struct drm_device *dev, int crtc_id)\n{\n\tstruct qxl_crtc *qxl_crtc;\n\tstruct drm_plane *primary, *cursor;\n\tstruct qxl_device *qdev = to_qxl(dev);\n\tint r;\n\n\tqxl_crtc = kzalloc(sizeof(struct qxl_crtc), GFP_KERNEL);\n\tif (!qxl_crtc)\n\t\treturn -ENOMEM;\n\n\tprimary = qxl_create_plane(qdev, 1 << crtc_id, DRM_PLANE_TYPE_PRIMARY);\n\tif (IS_ERR(primary)) {\n\t\tr = -ENOMEM;\n\t\tgoto free_mem;\n\t}\n\n\tcursor = qxl_create_plane(qdev, 1 << crtc_id, DRM_PLANE_TYPE_CURSOR);\n\tif (IS_ERR(cursor)) {\n\t\tr = -ENOMEM;\n\t\tgoto clean_primary;\n\t}\n\n\tr = drm_crtc_init_with_planes(dev, &qxl_crtc->base, primary, cursor,\n\t\t\t\t      &qxl_crtc_funcs, NULL);\n\tif (r)\n\t\tgoto clean_cursor;\n\n\tqxl_crtc->index = crtc_id;\n\tdrm_crtc_helper_add(&qxl_crtc->base, &qxl_crtc_helper_funcs);\n\treturn 0;\n\nclean_cursor:\n\tdrm_plane_cleanup(cursor);\n\tkfree(cursor);\nclean_primary:\n\tdrm_plane_cleanup(primary);\n\tkfree(primary);\nfree_mem:\n\tkfree(qxl_crtc);\n\treturn r;\n}\n\nstatic int qxl_conn_get_modes(struct drm_connector *connector)\n{\n\tstruct drm_device *dev = connector->dev;\n\tstruct qxl_device *qdev = to_qxl(dev);\n\tstruct qxl_output *output = drm_connector_to_qxl_output(connector);\n\tunsigned int pwidth = 1024;\n\tunsigned int pheight = 768;\n\tint ret = 0;\n\n\tif (qdev->client_monitors_config) {\n\t\tstruct qxl_head *head;\n\t\thead = &qdev->client_monitors_config->heads[output->index];\n\t\tif (head->width)\n\t\t\tpwidth = head->width;\n\t\tif (head->height)\n\t\t\tpheight = head->height;\n\t}\n\n\tret += drm_add_modes_noedid(connector, 8192, 8192);\n\tret += qxl_add_extra_modes(connector);\n\tret += qxl_add_monitors_config_modes(connector);\n\tdrm_set_preferred_mode(connector, pwidth, pheight);\n\treturn ret;\n}\n\nstatic enum drm_mode_status qxl_conn_mode_valid(struct drm_connector *connector,\n\t\t\t       struct drm_display_mode *mode)\n{\n\tstruct drm_device *ddev = connector->dev;\n\tstruct qxl_device *qdev = to_qxl(ddev);\n\n\tif (qxl_check_mode(qdev, mode->hdisplay, mode->vdisplay) != 0)\n\t\treturn MODE_BAD;\n\n\treturn MODE_OK;\n}\n\nstatic struct drm_encoder *qxl_best_encoder(struct drm_connector *connector)\n{\n\tstruct qxl_output *qxl_output =\n\t\tdrm_connector_to_qxl_output(connector);\n\n\tDRM_DEBUG(\"\\n\");\n\treturn &qxl_output->enc;\n}\n\nstatic const struct drm_connector_helper_funcs qxl_connector_helper_funcs = {\n\t.get_modes = qxl_conn_get_modes,\n\t.mode_valid = qxl_conn_mode_valid,\n\t.best_encoder = qxl_best_encoder,\n};\n\nstatic enum drm_connector_status qxl_conn_detect(\n\t\t\tstruct drm_connector *connector,\n\t\t\tbool force)\n{\n\tstruct qxl_output *output =\n\t\tdrm_connector_to_qxl_output(connector);\n\tstruct drm_device *ddev = connector->dev;\n\tstruct qxl_device *qdev = to_qxl(ddev);\n\tbool connected = false;\n\n\t \n\tif (!qdev->client_monitors_config) {\n\t\tif (output->index == 0)\n\t\t\tconnected = true;\n\t} else\n\t\tconnected = qdev->client_monitors_config->count > output->index &&\n\t\t     qxl_head_enabled(&qdev->client_monitors_config->heads[output->index]);\n\n\tDRM_DEBUG(\"#%d connected: %d\\n\", output->index, connected);\n\n\treturn connected ? connector_status_connected\n\t\t\t : connector_status_disconnected;\n}\n\nstatic void qxl_conn_destroy(struct drm_connector *connector)\n{\n\tstruct qxl_output *qxl_output =\n\t\tdrm_connector_to_qxl_output(connector);\n\n\tdrm_connector_unregister(connector);\n\tdrm_connector_cleanup(connector);\n\tkfree(qxl_output);\n}\n\nstatic const struct drm_connector_funcs qxl_connector_funcs = {\n\t.detect = qxl_conn_detect,\n\t.fill_modes = drm_helper_probe_single_connector_modes,\n\t.destroy = qxl_conn_destroy,\n\t.reset = drm_atomic_helper_connector_reset,\n\t.atomic_duplicate_state = drm_atomic_helper_connector_duplicate_state,\n\t.atomic_destroy_state = drm_atomic_helper_connector_destroy_state,\n};\n\nstatic int qxl_mode_create_hotplug_mode_update_property(struct qxl_device *qdev)\n{\n\tif (qdev->hotplug_mode_update_property)\n\t\treturn 0;\n\n\tqdev->hotplug_mode_update_property =\n\t\tdrm_property_create_range(&qdev->ddev, DRM_MODE_PROP_IMMUTABLE,\n\t\t\t\t\t  \"hotplug_mode_update\", 0, 1);\n\n\treturn 0;\n}\n\nstatic int qdev_output_init(struct drm_device *dev, int num_output)\n{\n\tstruct qxl_device *qdev = to_qxl(dev);\n\tstruct qxl_output *qxl_output;\n\tstruct drm_connector *connector;\n\tstruct drm_encoder *encoder;\n\tint ret;\n\n\tqxl_output = kzalloc(sizeof(struct qxl_output), GFP_KERNEL);\n\tif (!qxl_output)\n\t\treturn -ENOMEM;\n\n\tqxl_output->index = num_output;\n\n\tconnector = &qxl_output->base;\n\tencoder = &qxl_output->enc;\n\tdrm_connector_init(dev, &qxl_output->base,\n\t\t\t   &qxl_connector_funcs, DRM_MODE_CONNECTOR_VIRTUAL);\n\n\tret = drm_simple_encoder_init(dev, &qxl_output->enc,\n\t\t\t\t      DRM_MODE_ENCODER_VIRTUAL);\n\tif (ret) {\n\t\tdrm_err(dev, \"drm_simple_encoder_init() failed, error %d\\n\",\n\t\t\tret);\n\t\tgoto err_drm_connector_cleanup;\n\t}\n\n\t \n\tconnector->polled = DRM_CONNECTOR_POLL_HPD;\n\tencoder->possible_crtcs = 1 << num_output;\n\tdrm_connector_attach_encoder(&qxl_output->base,\n\t\t\t\t\t  &qxl_output->enc);\n\tdrm_connector_helper_add(connector, &qxl_connector_helper_funcs);\n\n\tdrm_object_attach_property(&connector->base,\n\t\t\t\t   qdev->hotplug_mode_update_property, 0);\n\tdrm_object_attach_property(&connector->base,\n\t\t\t\t   dev->mode_config.suggested_x_property, 0);\n\tdrm_object_attach_property(&connector->base,\n\t\t\t\t   dev->mode_config.suggested_y_property, 0);\n\treturn 0;\n\nerr_drm_connector_cleanup:\n\tdrm_connector_cleanup(&qxl_output->base);\n\tkfree(qxl_output);\n\treturn ret;\n}\n\nstatic struct drm_framebuffer *\nqxl_user_framebuffer_create(struct drm_device *dev,\n\t\t\t    struct drm_file *file_priv,\n\t\t\t    const struct drm_mode_fb_cmd2 *mode_cmd)\n{\n\treturn drm_gem_fb_create_with_funcs(dev, file_priv, mode_cmd,\n\t\t\t\t\t    &qxl_fb_funcs);\n}\n\nstatic const struct drm_mode_config_funcs qxl_mode_funcs = {\n\t.fb_create = qxl_user_framebuffer_create,\n\t.atomic_check = drm_atomic_helper_check,\n\t.atomic_commit = drm_atomic_helper_commit,\n};\n\nint qxl_create_monitors_object(struct qxl_device *qdev)\n{\n\tint ret;\n\tstruct drm_gem_object *gobj;\n\tstruct iosys_map map;\n\tint monitors_config_size = sizeof(struct qxl_monitors_config) +\n\t\tqxl_num_crtc * sizeof(struct qxl_head);\n\n\tret = qxl_gem_object_create(qdev, monitors_config_size, 0,\n\t\t\t\t    QXL_GEM_DOMAIN_VRAM,\n\t\t\t\t    false, false, NULL, &gobj);\n\tif (ret) {\n\t\tDRM_ERROR(\"%s: failed to create gem ret=%d\\n\", __func__, ret);\n\t\treturn -ENOMEM;\n\t}\n\tqdev->monitors_config_bo = gem_to_qxl_bo(gobj);\n\n\tret = qxl_bo_vmap(qdev->monitors_config_bo, &map);\n\tif (ret)\n\t\treturn ret;\n\n\tqdev->monitors_config = qdev->monitors_config_bo->kptr;\n\tqdev->ram_header->monitors_config =\n\t\tqxl_bo_physical_address(qdev, qdev->monitors_config_bo, 0);\n\n\tmemset(qdev->monitors_config, 0, monitors_config_size);\n\tqdev->dumb_heads = kcalloc(qxl_num_crtc, sizeof(qdev->dumb_heads[0]),\n\t\t\t\t   GFP_KERNEL);\n\tif (!qdev->dumb_heads) {\n\t\tqxl_destroy_monitors_object(qdev);\n\t\treturn -ENOMEM;\n\t}\n\treturn 0;\n}\n\nint qxl_destroy_monitors_object(struct qxl_device *qdev)\n{\n\tint ret;\n\n\tif (!qdev->monitors_config_bo)\n\t\treturn 0;\n\n\tkfree(qdev->dumb_heads);\n\tqdev->dumb_heads = NULL;\n\n\tqdev->monitors_config = NULL;\n\tqdev->ram_header->monitors_config = 0;\n\n\tret = qxl_bo_vunmap(qdev->monitors_config_bo);\n\tif (ret)\n\t\treturn ret;\n\n\tqxl_bo_unref(&qdev->monitors_config_bo);\n\treturn 0;\n}\n\nint qxl_modeset_init(struct qxl_device *qdev)\n{\n\tint i;\n\tint ret;\n\n\tret = drmm_mode_config_init(&qdev->ddev);\n\tif (ret)\n\t\treturn ret;\n\n\tret = qxl_create_monitors_object(qdev);\n\tif (ret)\n\t\treturn ret;\n\n\tqdev->ddev.mode_config.funcs = (void *)&qxl_mode_funcs;\n\n\t \n\tqdev->ddev.mode_config.min_width = 0;\n\tqdev->ddev.mode_config.min_height = 0;\n\tqdev->ddev.mode_config.max_width = 8192;\n\tqdev->ddev.mode_config.max_height = 8192;\n\n\tdrm_mode_create_suggested_offset_properties(&qdev->ddev);\n\tqxl_mode_create_hotplug_mode_update_property(qdev);\n\n\tfor (i = 0 ; i < qxl_num_crtc; ++i) {\n\t\tqdev_crtc_init(&qdev->ddev, i);\n\t\tqdev_output_init(&qdev->ddev, i);\n\t}\n\n\tqxl_display_read_client_monitors_config(qdev);\n\n\tdrm_mode_config_reset(&qdev->ddev);\n\treturn 0;\n}\n\nvoid qxl_modeset_fini(struct qxl_device *qdev)\n{\n\tif (qdev->dumb_shadow_bo) {\n\t\tqxl_bo_unpin(qdev->dumb_shadow_bo);\n\t\tdrm_gem_object_put(&qdev->dumb_shadow_bo->tbo.base);\n\t\tqdev->dumb_shadow_bo = NULL;\n\t}\n\tqxl_destroy_monitors_object(qdev);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}