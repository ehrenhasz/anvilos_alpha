{
  "module_name": "drm_fb_dma_helper.c",
  "hash_id": "af22d9af1440a259e7ff52cb14e594365c9768afda3f74cd44fc5c5cb716868c",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/drm_fb_dma_helper.c",
  "human_readable_source": "\n \n\n#include <drm/drm_damage_helper.h>\n#include <drm/drm_fb_dma_helper.h>\n#include <drm/drm_fourcc.h>\n#include <drm/drm_framebuffer.h>\n#include <drm/drm_gem_dma_helper.h>\n#include <drm/drm_gem_framebuffer_helper.h>\n#include <drm/drm_plane.h>\n#include <linux/dma-mapping.h>\n#include <linux/module.h>\n\n \n\n \nstruct drm_gem_dma_object *drm_fb_dma_get_gem_obj(struct drm_framebuffer *fb,\n\t\t\t\t\t\t  unsigned int plane)\n{\n\tstruct drm_gem_object *gem;\n\n\tgem = drm_gem_fb_get_obj(fb, plane);\n\tif (!gem)\n\t\treturn NULL;\n\n\treturn to_drm_gem_dma_obj(gem);\n}\nEXPORT_SYMBOL_GPL(drm_fb_dma_get_gem_obj);\n\n \ndma_addr_t drm_fb_dma_get_gem_addr(struct drm_framebuffer *fb,\n\t\t\t\t   struct drm_plane_state *state,\n\t\t\t\t   unsigned int plane)\n{\n\tstruct drm_gem_dma_object *obj;\n\tdma_addr_t dma_addr;\n\tu8 h_div = 1, v_div = 1;\n\tu32 block_w = drm_format_info_block_width(fb->format, plane);\n\tu32 block_h = drm_format_info_block_height(fb->format, plane);\n\tu32 block_size = fb->format->char_per_block[plane];\n\tu32 sample_x;\n\tu32 sample_y;\n\tu32 block_start_y;\n\tu32 num_hblocks;\n\n\tobj = drm_fb_dma_get_gem_obj(fb, plane);\n\tif (!obj)\n\t\treturn 0;\n\n\tdma_addr = obj->dma_addr + fb->offsets[plane];\n\n\tif (plane > 0) {\n\t\th_div = fb->format->hsub;\n\t\tv_div = fb->format->vsub;\n\t}\n\n\tsample_x = (state->src_x >> 16) / h_div;\n\tsample_y = (state->src_y >> 16) / v_div;\n\tblock_start_y = (sample_y / block_h) * block_h;\n\tnum_hblocks = sample_x / block_w;\n\n\tdma_addr += fb->pitches[plane] * block_start_y;\n\tdma_addr += block_size * num_hblocks;\n\n\treturn dma_addr;\n}\nEXPORT_SYMBOL_GPL(drm_fb_dma_get_gem_addr);\n\n \nvoid drm_fb_dma_sync_non_coherent(struct drm_device *drm,\n\t\t\t\t  struct drm_plane_state *old_state,\n\t\t\t\t  struct drm_plane_state *state)\n{\n\tconst struct drm_format_info *finfo = state->fb->format;\n\tstruct drm_atomic_helper_damage_iter iter;\n\tconst struct drm_gem_dma_object *dma_obj;\n\tunsigned int offset, i;\n\tstruct drm_rect clip;\n\tdma_addr_t daddr;\n\tsize_t nb_bytes;\n\n\tfor (i = 0; i < finfo->num_planes; i++) {\n\t\tdma_obj = drm_fb_dma_get_gem_obj(state->fb, i);\n\t\tif (!dma_obj->map_noncoherent)\n\t\t\tcontinue;\n\n\t\tdaddr = drm_fb_dma_get_gem_addr(state->fb, state, i);\n\t\tdrm_atomic_helper_damage_iter_init(&iter, old_state, state);\n\n\t\tdrm_atomic_for_each_plane_damage(&iter, &clip) {\n\t\t\t \n\t\t\toffset = clip.y1 * state->fb->pitches[i];\n\n\t\t\tnb_bytes = (clip.y2 - clip.y1) * state->fb->pitches[i];\n\t\t\tdma_sync_single_for_device(drm->dev, daddr + offset,\n\t\t\t\t\t\t   nb_bytes, DMA_TO_DEVICE);\n\t\t}\n\t}\n}\nEXPORT_SYMBOL_GPL(drm_fb_dma_sync_non_coherent);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}