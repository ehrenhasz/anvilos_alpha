{
  "module_name": "lsdc_gfxpll.c",
  "hash_id": "d00a7e60cb71fbf5c15eae43f30e81b099a04e8a2fddf8d1228a873b7a0d1ab1",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/loongson/lsdc_gfxpll.c",
  "human_readable_source": "\n \n\n#include <linux/delay.h>\n\n#include <drm/drm_file.h>\n#include <drm/drm_managed.h>\n#include <drm/drm_print.h>\n\n#include \"lsdc_drv.h\"\n\n \n\nstruct loongson_gfxpll_bitmap {\n\t \n\tunsigned div_out_dc    : 7;   \n\tunsigned div_out_gmc   : 7;   \n\tunsigned div_out_gpu   : 7;   \n\tunsigned loopc         : 9;   \n\tunsigned _reserved_1_  : 2;   \n\n\t \n\tunsigned div_ref       : 7;    \n\tunsigned locked        : 1;    \n\tunsigned sel_out_dc    : 1;    \n\tunsigned sel_out_gmc   : 1;    \n\tunsigned sel_out_gpu   : 1;    \n\tunsigned set_param     : 1;    \n\tunsigned bypass        : 1;    \n\tunsigned powerdown     : 1;    \n\tunsigned _reserved_2_  : 18;   \n};\n\nunion loongson_gfxpll_reg_bitmap {\n\tstruct loongson_gfxpll_bitmap bitmap;\n\tu32 w[2];\n\tu64 d;\n};\n\nstatic void __gfxpll_rreg(struct loongson_gfxpll *this,\n\t\t\t  union loongson_gfxpll_reg_bitmap *reg)\n{\n#if defined(CONFIG_64BIT)\n\treg->d = readq(this->mmio);\n#else\n\treg->w[0] = readl(this->mmio);\n\treg->w[1] = readl(this->mmio + 4);\n#endif\n}\n\n \n\nstatic int loongson_gfxpll_update(struct loongson_gfxpll * const this,\n\t\t\t\t  struct loongson_gfxpll_parms const *pin)\n{\n\t \n\n\treturn 0;\n}\n\nstatic void loongson_gfxpll_get_rates(struct loongson_gfxpll * const this,\n\t\t\t\t      unsigned int *dc,\n\t\t\t\t      unsigned int *gmc,\n\t\t\t\t      unsigned int *gpu)\n{\n\tstruct loongson_gfxpll_parms *pparms = &this->parms;\n\tunion loongson_gfxpll_reg_bitmap gfxpll_reg;\n\tunsigned int pre_output;\n\tunsigned int dc_mhz;\n\tunsigned int gmc_mhz;\n\tunsigned int gpu_mhz;\n\n\t__gfxpll_rreg(this, &gfxpll_reg);\n\n\tpparms->div_ref = gfxpll_reg.bitmap.div_ref;\n\tpparms->loopc = gfxpll_reg.bitmap.loopc;\n\n\tpparms->div_out_dc = gfxpll_reg.bitmap.div_out_dc;\n\tpparms->div_out_gmc = gfxpll_reg.bitmap.div_out_gmc;\n\tpparms->div_out_gpu = gfxpll_reg.bitmap.div_out_gpu;\n\n\tpre_output = pparms->ref_clock / pparms->div_ref * pparms->loopc;\n\n\tdc_mhz = pre_output / pparms->div_out_dc / 1000;\n\tgmc_mhz = pre_output / pparms->div_out_gmc / 1000;\n\tgpu_mhz = pre_output / pparms->div_out_gpu / 1000;\n\n\tif (dc)\n\t\t*dc = dc_mhz;\n\n\tif (gmc)\n\t\t*gmc = gmc_mhz;\n\n\tif (gpu)\n\t\t*gpu = gpu_mhz;\n}\n\nstatic void loongson_gfxpll_print(struct loongson_gfxpll * const this,\n\t\t\t\t  struct drm_printer *p,\n\t\t\t\t  bool verbose)\n{\n\tstruct loongson_gfxpll_parms *parms = &this->parms;\n\tunsigned int dc, gmc, gpu;\n\n\tif (verbose) {\n\t\tdrm_printf(p, \"reference clock: %u\\n\", parms->ref_clock);\n\t\tdrm_printf(p, \"div_ref = %u\\n\", parms->div_ref);\n\t\tdrm_printf(p, \"loopc = %u\\n\", parms->loopc);\n\n\t\tdrm_printf(p, \"div_out_dc = %u\\n\", parms->div_out_dc);\n\t\tdrm_printf(p, \"div_out_gmc = %u\\n\", parms->div_out_gmc);\n\t\tdrm_printf(p, \"div_out_gpu = %u\\n\", parms->div_out_gpu);\n\t}\n\n\tthis->funcs->get_rates(this, &dc, &gmc, &gpu);\n\n\tdrm_printf(p, \"dc: %uMHz, gmc: %uMHz, gpu: %uMHz\\n\", dc, gmc, gpu);\n}\n\n \n\nstatic void loongson_gfxpll_fini(struct drm_device *ddev, void *data)\n{\n\tstruct loongson_gfxpll *this = (struct loongson_gfxpll *)data;\n\n\tiounmap(this->mmio);\n\n\tkfree(this);\n}\n\nstatic int loongson_gfxpll_init(struct loongson_gfxpll * const this)\n{\n\tstruct loongson_gfxpll_parms *pparms = &this->parms;\n\tstruct drm_printer printer = drm_info_printer(this->ddev->dev);\n\n\tpparms->ref_clock = LSDC_PLL_REF_CLK_KHZ;\n\n\tthis->mmio = ioremap(this->reg_base, this->reg_size);\n\tif (IS_ERR_OR_NULL(this->mmio))\n\t\treturn -ENOMEM;\n\n\tthis->funcs->print(this, &printer, false);\n\n\treturn 0;\n}\n\nstatic const struct loongson_gfxpll_funcs lsdc_gmc_gpu_funcs = {\n\t.init = loongson_gfxpll_init,\n\t.update = loongson_gfxpll_update,\n\t.get_rates = loongson_gfxpll_get_rates,\n\t.print = loongson_gfxpll_print,\n};\n\nint loongson_gfxpll_create(struct drm_device *ddev,\n\t\t\t   struct loongson_gfxpll **ppout)\n{\n\tstruct lsdc_device *ldev = to_lsdc(ddev);\n\tconst struct loongson_gfx_desc *gfx = to_loongson_gfx(ldev->descp);\n\tstruct loongson_gfxpll *this;\n\tint ret;\n\n\tthis = kzalloc(sizeof(*this), GFP_KERNEL);\n\tif (IS_ERR_OR_NULL(this))\n\t\treturn -ENOMEM;\n\n\tthis->ddev = ddev;\n\tthis->reg_size = gfx->gfxpll.reg_size;\n\tthis->reg_base = gfx->conf_reg_base + gfx->gfxpll.reg_offset;\n\tthis->funcs = &lsdc_gmc_gpu_funcs;\n\n\tret = this->funcs->init(this);\n\tif (unlikely(ret)) {\n\t\tkfree(this);\n\t\treturn ret;\n\t}\n\n\t*ppout = this;\n\n\treturn drmm_add_action_or_reset(ddev, loongson_gfxpll_fini, this);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}