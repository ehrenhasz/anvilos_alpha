{
  "module_name": "lsdc_plane.c",
  "hash_id": "fb53db3cc0608450deb731d37798323b0475a9cea1ad119986789b4f4a8d5fe1",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/loongson/lsdc_plane.c",
  "human_readable_source": "\n \n\n#include <linux/delay.h>\n\n#include <drm/drm_atomic.h>\n#include <drm/drm_atomic_helper.h>\n#include <drm/drm_framebuffer.h>\n#include <drm/drm_gem_atomic_helper.h>\n#include <drm/drm_plane_helper.h>\n\n#include \"lsdc_drv.h\"\n#include \"lsdc_regs.h\"\n#include \"lsdc_ttm.h\"\n\nstatic const u32 lsdc_primary_formats[] = {\n\tDRM_FORMAT_XRGB8888,\n};\n\nstatic const u32 lsdc_cursor_formats[] = {\n\tDRM_FORMAT_ARGB8888,\n};\n\nstatic const u64 lsdc_fb_format_modifiers[] = {\n\tDRM_FORMAT_MOD_LINEAR,\n\tDRM_FORMAT_MOD_INVALID\n};\n\nstatic unsigned int lsdc_get_fb_offset(struct drm_framebuffer *fb,\n\t\t\t\t       struct drm_plane_state *state)\n{\n\tunsigned int offset = fb->offsets[0];\n\n\toffset += fb->format->cpp[0] * (state->src_x >> 16);\n\toffset += fb->pitches[0] * (state->src_y >> 16);\n\n\treturn offset;\n}\n\nstatic u64 lsdc_fb_base_addr(struct drm_framebuffer *fb)\n{\n\tstruct lsdc_device *ldev = to_lsdc(fb->dev);\n\tstruct lsdc_bo *lbo = gem_to_lsdc_bo(fb->obj[0]);\n\n\treturn lsdc_bo_gpu_offset(lbo) + ldev->vram_base;\n}\n\nstatic int lsdc_primary_atomic_check(struct drm_plane *plane,\n\t\t\t\t     struct drm_atomic_state *state)\n{\n\tstruct drm_plane_state *new_plane_state = drm_atomic_get_new_plane_state(state, plane);\n\tstruct drm_crtc *crtc = new_plane_state->crtc;\n\tstruct drm_crtc_state *new_crtc_state;\n\n\tif (!crtc)\n\t\treturn 0;\n\n\tnew_crtc_state = drm_atomic_get_new_crtc_state(state, crtc);\n\n\treturn drm_atomic_helper_check_plane_state(new_plane_state,\n\t\t\t\t\t\t   new_crtc_state,\n\t\t\t\t\t\t   DRM_PLANE_NO_SCALING,\n\t\t\t\t\t\t   DRM_PLANE_NO_SCALING,\n\t\t\t\t\t\t   false, true);\n}\n\nstatic void lsdc_primary_atomic_update(struct drm_plane *plane,\n\t\t\t\t       struct drm_atomic_state *state)\n{\n\tstruct lsdc_primary *primary = to_lsdc_primary(plane);\n\tconst struct lsdc_primary_plane_ops *ops = primary->ops;\n\tstruct drm_plane_state *old_plane_state = drm_atomic_get_old_plane_state(state, plane);\n\tstruct drm_plane_state *new_plane_state = drm_atomic_get_new_plane_state(state, plane);\n\tstruct drm_framebuffer *new_fb = new_plane_state->fb;\n\tstruct drm_framebuffer *old_fb = old_plane_state->fb;\n\tu64 fb_addr = lsdc_fb_base_addr(new_fb);\n\n\tfb_addr += lsdc_get_fb_offset(new_fb, new_plane_state);\n\n\tops->update_fb_addr(primary, fb_addr);\n\tops->update_fb_stride(primary, new_fb->pitches[0]);\n\n\tif (!old_fb || old_fb->format != new_fb->format)\n\t\tops->update_fb_format(primary, new_fb->format);\n}\n\nstatic void lsdc_primary_atomic_disable(struct drm_plane *plane,\n\t\t\t\t\tstruct drm_atomic_state *state)\n{\n\t \n\tdrm_dbg(plane->dev, \"%s disabled\\n\", plane->name);\n}\n\nstatic int lsdc_plane_prepare_fb(struct drm_plane *plane,\n\t\t\t\t struct drm_plane_state *new_state)\n{\n\tstruct drm_framebuffer *fb = new_state->fb;\n\tstruct lsdc_bo *lbo;\n\tu64 gpu_vaddr;\n\tint ret;\n\n\tif (!fb)\n\t\treturn 0;\n\n\tlbo = gem_to_lsdc_bo(fb->obj[0]);\n\n\tret = lsdc_bo_reserve(lbo);\n\tif (unlikely(ret)) {\n\t\tdrm_err(plane->dev, \"bo %p reserve failed\\n\", lbo);\n\t\treturn ret;\n\t}\n\n\tret = lsdc_bo_pin(lbo, LSDC_GEM_DOMAIN_VRAM, &gpu_vaddr);\n\n\tlsdc_bo_unreserve(lbo);\n\n\tif (unlikely(ret)) {\n\t\tdrm_err(plane->dev, \"bo %p pin failed\\n\", lbo);\n\t\treturn ret;\n\t}\n\n\tlsdc_bo_ref(lbo);\n\n\tif (plane->type != DRM_PLANE_TYPE_CURSOR)\n\t\tdrm_dbg(plane->dev,\n\t\t\t\"%s[%p] pin at 0x%llx, bo size: %zu\\n\",\n\t\t\tplane->name, lbo, gpu_vaddr, lsdc_bo_size(lbo));\n\n\treturn drm_gem_plane_helper_prepare_fb(plane, new_state);\n}\n\nstatic void lsdc_plane_cleanup_fb(struct drm_plane *plane,\n\t\t\t\t  struct drm_plane_state *old_state)\n{\n\tstruct drm_framebuffer *fb = old_state->fb;\n\tstruct lsdc_bo *lbo;\n\tint ret;\n\n\tif (!fb)\n\t\treturn;\n\n\tlbo = gem_to_lsdc_bo(fb->obj[0]);\n\n\tret = lsdc_bo_reserve(lbo);\n\tif (unlikely(ret)) {\n\t\tdrm_err(plane->dev, \"%p reserve failed\\n\", lbo);\n\t\treturn;\n\t}\n\n\tlsdc_bo_unpin(lbo);\n\n\tlsdc_bo_unreserve(lbo);\n\n\tlsdc_bo_unref(lbo);\n\n\tif (plane->type != DRM_PLANE_TYPE_CURSOR)\n\t\tdrm_dbg(plane->dev, \"%s unpin\\n\", plane->name);\n}\n\nstatic const struct drm_plane_helper_funcs lsdc_primary_helper_funcs = {\n\t.prepare_fb = lsdc_plane_prepare_fb,\n\t.cleanup_fb = lsdc_plane_cleanup_fb,\n\t.atomic_check = lsdc_primary_atomic_check,\n\t.atomic_update = lsdc_primary_atomic_update,\n\t.atomic_disable = lsdc_primary_atomic_disable,\n};\n\nstatic int lsdc_cursor_plane_atomic_async_check(struct drm_plane *plane,\n\t\t\t\t\t\tstruct drm_atomic_state *state)\n{\n\tstruct drm_plane_state *new_state;\n\tstruct drm_crtc_state *crtc_state;\n\n\tnew_state = drm_atomic_get_new_plane_state(state, plane);\n\n\tif (!plane->state || !plane->state->fb) {\n\t\tdrm_dbg(plane->dev, \"%s: state is NULL\\n\", plane->name);\n\t\treturn -EINVAL;\n\t}\n\n\tif (new_state->crtc_w != new_state->crtc_h) {\n\t\tdrm_dbg(plane->dev, \"unsupported cursor size: %ux%u\\n\",\n\t\t\tnew_state->crtc_w, new_state->crtc_h);\n\t\treturn -EINVAL;\n\t}\n\n\tif (new_state->crtc_w != 64 && new_state->crtc_w != 32) {\n\t\tdrm_dbg(plane->dev, \"unsupported cursor size: %ux%u\\n\",\n\t\t\tnew_state->crtc_w, new_state->crtc_h);\n\t\treturn -EINVAL;\n\t}\n\n\tcrtc_state = drm_atomic_get_existing_crtc_state(state, new_state->crtc);\n\tif (!crtc_state->active)\n\t\treturn -EINVAL;\n\n\tif (plane->state->crtc != new_state->crtc ||\n\t    plane->state->src_w != new_state->src_w ||\n\t    plane->state->src_h != new_state->src_h ||\n\t    plane->state->crtc_w != new_state->crtc_w ||\n\t    plane->state->crtc_h != new_state->crtc_h)\n\t\treturn -EINVAL;\n\n\tif (new_state->visible != plane->state->visible)\n\t\treturn -EINVAL;\n\n\treturn drm_atomic_helper_check_plane_state(plane->state,\n\t\t\t\t\t\t   crtc_state,\n\t\t\t\t\t\t   DRM_PLANE_NO_SCALING,\n\t\t\t\t\t\t   DRM_PLANE_NO_SCALING,\n\t\t\t\t\t\t   true, true);\n}\n\nstatic void lsdc_cursor_plane_atomic_async_update(struct drm_plane *plane,\n\t\t\t\t\t\t  struct drm_atomic_state *state)\n{\n\tstruct lsdc_cursor *cursor = to_lsdc_cursor(plane);\n\tconst struct lsdc_cursor_plane_ops *ops = cursor->ops;\n\tstruct drm_framebuffer *old_fb = plane->state->fb;\n\tstruct drm_framebuffer *new_fb;\n\tstruct drm_plane_state *new_state;\n\n\tnew_state = drm_atomic_get_new_plane_state(state, plane);\n\n\tnew_fb = plane->state->fb;\n\n\tplane->state->crtc_x = new_state->crtc_x;\n\tplane->state->crtc_y = new_state->crtc_y;\n\tplane->state->crtc_h = new_state->crtc_h;\n\tplane->state->crtc_w = new_state->crtc_w;\n\tplane->state->src_x = new_state->src_x;\n\tplane->state->src_y = new_state->src_y;\n\tplane->state->src_h = new_state->src_h;\n\tplane->state->src_w = new_state->src_w;\n\tswap(plane->state->fb, new_state->fb);\n\n\tif (new_state->visible) {\n\t\tenum lsdc_cursor_size cursor_size;\n\n\t\tswitch (new_state->crtc_w) {\n\t\tcase 64:\n\t\t\tcursor_size = CURSOR_SIZE_64X64;\n\t\t\tbreak;\n\t\tcase 32:\n\t\t\tcursor_size = CURSOR_SIZE_32X32;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tcursor_size = CURSOR_SIZE_32X32;\n\t\t\tbreak;\n\t\t}\n\n\t\tops->update_position(cursor, new_state->crtc_x, new_state->crtc_y);\n\n\t\tops->update_cfg(cursor, cursor_size, CURSOR_FORMAT_ARGB8888);\n\n\t\tif (!old_fb || old_fb != new_fb)\n\t\t\tops->update_bo_addr(cursor, lsdc_fb_base_addr(new_fb));\n\t}\n}\n\n \n\nstatic int ls7a1000_cursor_plane_atomic_check(struct drm_plane *plane,\n\t\t\t\t\t      struct drm_atomic_state *state)\n{\n\tstruct drm_plane_state *new_plane_state;\n\tstruct drm_crtc_state *new_crtc_state;\n\tstruct drm_crtc *crtc;\n\n\tnew_plane_state = drm_atomic_get_new_plane_state(state, plane);\n\n\tcrtc = new_plane_state->crtc;\n\tif (!crtc) {\n\t\tdrm_dbg(plane->dev, \"%s is not bind to a crtc\\n\", plane->name);\n\t\treturn 0;\n\t}\n\n\tif (new_plane_state->crtc_w != 32 || new_plane_state->crtc_h != 32) {\n\t\tdrm_dbg(plane->dev, \"unsupported cursor size: %ux%u\\n\",\n\t\t\tnew_plane_state->crtc_w, new_plane_state->crtc_h);\n\t\treturn -EINVAL;\n\t}\n\n\tnew_crtc_state = drm_atomic_get_new_crtc_state(state, crtc);\n\n\treturn drm_atomic_helper_check_plane_state(new_plane_state,\n\t\t\t\t\t\t   new_crtc_state,\n\t\t\t\t\t\t   DRM_PLANE_NO_SCALING,\n\t\t\t\t\t\t   DRM_PLANE_NO_SCALING,\n\t\t\t\t\t\t   true, true);\n}\n\nstatic void ls7a1000_cursor_plane_atomic_update(struct drm_plane *plane,\n\t\t\t\t\t\tstruct drm_atomic_state *state)\n{\n\tstruct lsdc_cursor *cursor = to_lsdc_cursor(plane);\n\tstruct drm_plane_state *old_plane_state = drm_atomic_get_old_plane_state(state, plane);\n\tstruct drm_plane_state *new_plane_state = drm_atomic_get_new_plane_state(state, plane);\n\tstruct drm_framebuffer *new_fb = new_plane_state->fb;\n\tstruct drm_framebuffer *old_fb = old_plane_state->fb;\n\tconst struct lsdc_cursor_plane_ops *ops = cursor->ops;\n\tu64 addr = lsdc_fb_base_addr(new_fb);\n\n\tif (!new_plane_state->visible)\n\t\treturn;\n\n\tops->update_position(cursor, new_plane_state->crtc_x, new_plane_state->crtc_y);\n\n\tif (!old_fb || old_fb != new_fb)\n\t\tops->update_bo_addr(cursor, addr);\n\n\tops->update_cfg(cursor, CURSOR_SIZE_32X32, CURSOR_FORMAT_ARGB8888);\n}\n\nstatic void ls7a1000_cursor_plane_atomic_disable(struct drm_plane *plane,\n\t\t\t\t\t\t struct drm_atomic_state *state)\n{\n\tstruct lsdc_cursor *cursor = to_lsdc_cursor(plane);\n\tconst struct lsdc_cursor_plane_ops *ops = cursor->ops;\n\n\tops->update_cfg(cursor, CURSOR_SIZE_32X32, CURSOR_FORMAT_DISABLE);\n}\n\nstatic const struct drm_plane_helper_funcs ls7a1000_cursor_plane_helper_funcs = {\n\t.prepare_fb = lsdc_plane_prepare_fb,\n\t.cleanup_fb = lsdc_plane_cleanup_fb,\n\t.atomic_check = ls7a1000_cursor_plane_atomic_check,\n\t.atomic_update = ls7a1000_cursor_plane_atomic_update,\n\t.atomic_disable = ls7a1000_cursor_plane_atomic_disable,\n\t.atomic_async_check = lsdc_cursor_plane_atomic_async_check,\n\t.atomic_async_update = lsdc_cursor_plane_atomic_async_update,\n};\n\n \n\nstatic int ls7a2000_cursor_plane_atomic_check(struct drm_plane *plane,\n\t\t\t\t\t      struct drm_atomic_state *state)\n{\n\tstruct drm_plane_state *new_plane_state;\n\tstruct drm_crtc_state *new_crtc_state;\n\tstruct drm_crtc *crtc;\n\n\tnew_plane_state = drm_atomic_get_new_plane_state(state, plane);\n\n\tcrtc = new_plane_state->crtc;\n\tif (!crtc) {\n\t\tdrm_dbg(plane->dev, \"%s is not bind to a crtc\\n\", plane->name);\n\t\treturn 0;\n\t}\n\n\tif (new_plane_state->crtc_w != new_plane_state->crtc_h) {\n\t\tdrm_dbg(plane->dev, \"unsupported cursor size: %ux%u\\n\",\n\t\t\tnew_plane_state->crtc_w, new_plane_state->crtc_h);\n\t\treturn -EINVAL;\n\t}\n\n\tif (new_plane_state->crtc_w != 64 && new_plane_state->crtc_w != 32) {\n\t\tdrm_dbg(plane->dev, \"unsupported cursor size: %ux%u\\n\",\n\t\t\tnew_plane_state->crtc_w, new_plane_state->crtc_h);\n\t\treturn -EINVAL;\n\t}\n\n\tnew_crtc_state = drm_atomic_get_new_crtc_state(state, crtc);\n\n\treturn drm_atomic_helper_check_plane_state(new_plane_state,\n\t\t\t\t\t\t   new_crtc_state,\n\t\t\t\t\t\t   DRM_PLANE_NO_SCALING,\n\t\t\t\t\t\t   DRM_PLANE_NO_SCALING,\n\t\t\t\t\t\t   true, true);\n}\n\n \n\nstatic void ls7a2000_cursor_plane_atomic_update(struct drm_plane *plane,\n\t\t\t\t\t\tstruct drm_atomic_state *state)\n{\n\tstruct lsdc_cursor *cursor = to_lsdc_cursor(plane);\n\tstruct drm_plane_state *old_plane_state = drm_atomic_get_old_plane_state(state, plane);\n\tstruct drm_plane_state *new_plane_state = drm_atomic_get_new_plane_state(state, plane);\n\tstruct drm_framebuffer *new_fb = new_plane_state->fb;\n\tstruct drm_framebuffer *old_fb = old_plane_state->fb;\n\tconst struct lsdc_cursor_plane_ops *ops = cursor->ops;\n\tenum lsdc_cursor_size cursor_size;\n\n\tif (!new_plane_state->visible)\n\t\treturn;\n\n\tops->update_position(cursor, new_plane_state->crtc_x, new_plane_state->crtc_y);\n\n\tif (!old_fb || new_fb != old_fb) {\n\t\tu64 addr = lsdc_fb_base_addr(new_fb);\n\n\t\tops->update_bo_addr(cursor, addr);\n\t}\n\n\tswitch (new_plane_state->crtc_w) {\n\tcase 64:\n\t\tcursor_size = CURSOR_SIZE_64X64;\n\t\tbreak;\n\tcase 32:\n\t\tcursor_size = CURSOR_SIZE_32X32;\n\t\tbreak;\n\tdefault:\n\t\tcursor_size = CURSOR_SIZE_64X64;\n\t\tbreak;\n\t}\n\n\tops->update_cfg(cursor, cursor_size, CURSOR_FORMAT_ARGB8888);\n}\n\nstatic void ls7a2000_cursor_plane_atomic_disable(struct drm_plane *plane,\n\t\t\t\t\t\t struct drm_atomic_state *state)\n{\n\tstruct lsdc_cursor *cursor = to_lsdc_cursor(plane);\n\tconst struct lsdc_cursor_plane_ops *hw_ops = cursor->ops;\n\n\thw_ops->update_cfg(cursor, CURSOR_SIZE_64X64, CURSOR_FORMAT_DISABLE);\n}\n\nstatic const struct drm_plane_helper_funcs ls7a2000_cursor_plane_helper_funcs = {\n\t.prepare_fb = lsdc_plane_prepare_fb,\n\t.cleanup_fb = lsdc_plane_cleanup_fb,\n\t.atomic_check = ls7a2000_cursor_plane_atomic_check,\n\t.atomic_update = ls7a2000_cursor_plane_atomic_update,\n\t.atomic_disable = ls7a2000_cursor_plane_atomic_disable,\n\t.atomic_async_check = lsdc_cursor_plane_atomic_async_check,\n\t.atomic_async_update = lsdc_cursor_plane_atomic_async_update,\n};\n\nstatic void lsdc_plane_atomic_print_state(struct drm_printer *p,\n\t\t\t\t\t  const struct drm_plane_state *state)\n{\n\tstruct drm_framebuffer *fb = state->fb;\n\tu64 addr;\n\n\tif (!fb)\n\t\treturn;\n\n\taddr = lsdc_fb_base_addr(fb);\n\n\tdrm_printf(p, \"\\tdma addr=%llx\\n\", addr);\n}\n\nstatic const struct drm_plane_funcs lsdc_plane_funcs = {\n\t.update_plane = drm_atomic_helper_update_plane,\n\t.disable_plane = drm_atomic_helper_disable_plane,\n\t.destroy = drm_plane_cleanup,\n\t.reset = drm_atomic_helper_plane_reset,\n\t.atomic_duplicate_state = drm_atomic_helper_plane_duplicate_state,\n\t.atomic_destroy_state = drm_atomic_helper_plane_destroy_state,\n\t.atomic_print_state = lsdc_plane_atomic_print_state,\n};\n\n \n\nstatic void lsdc_primary0_update_fb_addr(struct lsdc_primary *primary, u64 addr)\n{\n\tstruct lsdc_device *ldev = primary->ldev;\n\tu32 status;\n\tu32 lo, hi;\n\n\t \n\tlo = addr & 0xFFFFFFFF;\n\thi = (addr >> 32) & 0xFF;\n\n\tstatus = lsdc_rreg32(ldev, LSDC_CRTC0_CFG_REG);\n\tif (status & FB_REG_IN_USING) {\n\t\tlsdc_wreg32(ldev, LSDC_CRTC0_FB1_ADDR_LO_REG, lo);\n\t\tlsdc_wreg32(ldev, LSDC_CRTC0_FB1_ADDR_HI_REG, hi);\n\t} else {\n\t\tlsdc_wreg32(ldev, LSDC_CRTC0_FB0_ADDR_LO_REG, lo);\n\t\tlsdc_wreg32(ldev, LSDC_CRTC0_FB0_ADDR_HI_REG, hi);\n\t}\n}\n\nstatic void lsdc_primary0_update_fb_stride(struct lsdc_primary *primary, u32 stride)\n{\n\tstruct lsdc_device *ldev = primary->ldev;\n\n\tlsdc_wreg32(ldev, LSDC_CRTC0_STRIDE_REG, stride);\n}\n\nstatic void lsdc_primary0_update_fb_format(struct lsdc_primary *primary,\n\t\t\t\t\t   const struct drm_format_info *format)\n{\n\tstruct lsdc_device *ldev = primary->ldev;\n\tu32 status;\n\n\tstatus = lsdc_rreg32(ldev, LSDC_CRTC0_CFG_REG);\n\n\t \n\tstatus &= ~CFG_PIX_FMT_MASK;\n\tstatus |= LSDC_PF_XRGB8888;\n\n\tlsdc_wreg32(ldev, LSDC_CRTC0_CFG_REG, status);\n}\n\n \n\nstatic void lsdc_primary1_update_fb_addr(struct lsdc_primary *primary, u64 addr)\n{\n\tstruct lsdc_device *ldev = primary->ldev;\n\tu32 status;\n\tu32 lo, hi;\n\n\t \n\tlo = addr & 0xFFFFFFFF;\n\thi = (addr >> 32) & 0xFF;\n\n\tstatus = lsdc_rreg32(ldev, LSDC_CRTC1_CFG_REG);\n\tif (status & FB_REG_IN_USING) {\n\t\tlsdc_wreg32(ldev, LSDC_CRTC1_FB1_ADDR_LO_REG, lo);\n\t\tlsdc_wreg32(ldev, LSDC_CRTC1_FB1_ADDR_HI_REG, hi);\n\t} else {\n\t\tlsdc_wreg32(ldev, LSDC_CRTC1_FB0_ADDR_LO_REG, lo);\n\t\tlsdc_wreg32(ldev, LSDC_CRTC1_FB0_ADDR_HI_REG, hi);\n\t}\n}\n\nstatic void lsdc_primary1_update_fb_stride(struct lsdc_primary *primary, u32 stride)\n{\n\tstruct lsdc_device *ldev = primary->ldev;\n\n\tlsdc_wreg32(ldev, LSDC_CRTC1_STRIDE_REG, stride);\n}\n\nstatic void lsdc_primary1_update_fb_format(struct lsdc_primary *primary,\n\t\t\t\t\t   const struct drm_format_info *format)\n{\n\tstruct lsdc_device *ldev = primary->ldev;\n\tu32 status;\n\n\tstatus = lsdc_rreg32(ldev, LSDC_CRTC1_CFG_REG);\n\n\t \n\tstatus &= ~CFG_PIX_FMT_MASK;\n\tstatus |= LSDC_PF_XRGB8888;\n\n\tlsdc_wreg32(ldev, LSDC_CRTC1_CFG_REG, status);\n}\n\nstatic const struct lsdc_primary_plane_ops lsdc_primary_plane_hw_ops[2] = {\n\t{\n\t\t.update_fb_addr = lsdc_primary0_update_fb_addr,\n\t\t.update_fb_stride = lsdc_primary0_update_fb_stride,\n\t\t.update_fb_format = lsdc_primary0_update_fb_format,\n\t},\n\t{\n\t\t.update_fb_addr = lsdc_primary1_update_fb_addr,\n\t\t.update_fb_stride = lsdc_primary1_update_fb_stride,\n\t\t.update_fb_format = lsdc_primary1_update_fb_format,\n\t},\n};\n\n \n\n \n\nstatic void lsdc_cursor0_update_bo_addr(struct lsdc_cursor *cursor, u64 addr)\n{\n\tstruct lsdc_device *ldev = cursor->ldev;\n\n\t \n\tlsdc_wreg32(ldev, LSDC_CURSOR0_ADDR_HI_REG, (addr >> 32) & 0xFF);\n\tlsdc_wreg32(ldev, LSDC_CURSOR0_ADDR_LO_REG, addr);\n}\n\nstatic void lsdc_cursor0_update_position(struct lsdc_cursor *cursor, int x, int y)\n{\n\tstruct lsdc_device *ldev = cursor->ldev;\n\n\tif (x < 0)\n\t\tx = 0;\n\n\tif (y < 0)\n\t\ty = 0;\n\n\tlsdc_wreg32(ldev, LSDC_CURSOR0_POSITION_REG, (y << 16) | x);\n}\n\nstatic void lsdc_cursor0_update_cfg(struct lsdc_cursor *cursor,\n\t\t\t\t    enum lsdc_cursor_size cursor_size,\n\t\t\t\t    enum lsdc_cursor_format fmt)\n{\n\tstruct lsdc_device *ldev = cursor->ldev;\n\tu32 cfg;\n\n\tcfg = CURSOR_ON_CRTC0 << CURSOR_LOCATION_SHIFT |\n\t      cursor_size << CURSOR_SIZE_SHIFT |\n\t      fmt << CURSOR_FORMAT_SHIFT;\n\n\tlsdc_wreg32(ldev, LSDC_CURSOR0_CFG_REG, cfg);\n}\n\n \n\nstatic void lsdc_cursor1_update_bo_addr(struct lsdc_cursor *cursor, u64 addr)\n{\n\tstruct lsdc_device *ldev = cursor->ldev;\n\n\t \n\tlsdc_wreg32(ldev, LSDC_CURSOR1_ADDR_HI_REG, (addr >> 32) & 0xFF);\n\tlsdc_wreg32(ldev, LSDC_CURSOR1_ADDR_LO_REG, addr);\n}\n\nstatic void lsdc_cursor1_update_position(struct lsdc_cursor *cursor, int x, int y)\n{\n\tstruct lsdc_device *ldev = cursor->ldev;\n\n\tif (x < 0)\n\t\tx = 0;\n\n\tif (y < 0)\n\t\ty = 0;\n\n\tlsdc_wreg32(ldev, LSDC_CURSOR1_POSITION_REG, (y << 16) | x);\n}\n\nstatic void lsdc_cursor1_update_cfg(struct lsdc_cursor *cursor,\n\t\t\t\t    enum lsdc_cursor_size cursor_size,\n\t\t\t\t    enum lsdc_cursor_format fmt)\n{\n\tstruct lsdc_device *ldev = cursor->ldev;\n\tu32 cfg;\n\n\tcfg = CURSOR_ON_CRTC1 << CURSOR_LOCATION_SHIFT |\n\t      cursor_size << CURSOR_SIZE_SHIFT |\n\t      fmt << CURSOR_FORMAT_SHIFT;\n\n\tlsdc_wreg32(ldev, LSDC_CURSOR1_CFG_REG, cfg);\n}\n\n \n\nstatic const struct lsdc_cursor_plane_ops ls7a2000_cursor_hw_ops[2] = {\n\t{\n\t\t.update_bo_addr = lsdc_cursor0_update_bo_addr,\n\t\t.update_cfg = lsdc_cursor0_update_cfg,\n\t\t.update_position = lsdc_cursor0_update_position,\n\t},\n\t{\n\t\t.update_bo_addr = lsdc_cursor1_update_bo_addr,\n\t\t.update_cfg = lsdc_cursor1_update_cfg,\n\t\t.update_position = lsdc_cursor1_update_position,\n\t},\n};\n\n \n\nstatic void lsdc_cursor1_update_bo_addr_quirk(struct lsdc_cursor *cursor, u64 addr)\n{\n\tstruct lsdc_device *ldev = cursor->ldev;\n\n\t \n\tlsdc_wreg32(ldev, LSDC_CURSOR0_ADDR_HI_REG, (addr >> 32) & 0xFF);\n\tlsdc_wreg32(ldev, LSDC_CURSOR0_ADDR_LO_REG, addr);\n}\n\nstatic void lsdc_cursor1_update_position_quirk(struct lsdc_cursor *cursor, int x, int y)\n{\n\tstruct lsdc_device *ldev = cursor->ldev;\n\n\tif (x < 0)\n\t\tx = 0;\n\n\tif (y < 0)\n\t\ty = 0;\n\n\tlsdc_wreg32(ldev, LSDC_CURSOR0_POSITION_REG, (y << 16) | x);\n}\n\nstatic void lsdc_cursor1_update_cfg_quirk(struct lsdc_cursor *cursor,\n\t\t\t\t\t  enum lsdc_cursor_size cursor_size,\n\t\t\t\t\t  enum lsdc_cursor_format fmt)\n{\n\tstruct lsdc_device *ldev = cursor->ldev;\n\tu32 cfg;\n\n\tcfg = CURSOR_ON_CRTC1 << CURSOR_LOCATION_SHIFT |\n\t      cursor_size << CURSOR_SIZE_SHIFT |\n\t      fmt << CURSOR_FORMAT_SHIFT;\n\n\tlsdc_wreg32(ldev, LSDC_CURSOR0_CFG_REG, cfg);\n}\n\n \nstatic const struct lsdc_cursor_plane_ops ls7a1000_cursor_hw_ops[2] = {\n\t{\n\t\t.update_bo_addr = lsdc_cursor0_update_bo_addr,\n\t\t.update_cfg = lsdc_cursor0_update_cfg,\n\t\t.update_position = lsdc_cursor0_update_position,\n\t},\n\t{\n\t\t.update_bo_addr = lsdc_cursor1_update_bo_addr_quirk,\n\t\t.update_cfg = lsdc_cursor1_update_cfg_quirk,\n\t\t.update_position = lsdc_cursor1_update_position_quirk,\n\t},\n};\n\nint lsdc_primary_plane_init(struct drm_device *ddev,\n\t\t\t    struct drm_plane *plane,\n\t\t\t    unsigned int index)\n{\n\tstruct lsdc_primary *primary = to_lsdc_primary(plane);\n\tint ret;\n\n\tret = drm_universal_plane_init(ddev, plane, 1 << index,\n\t\t\t\t       &lsdc_plane_funcs,\n\t\t\t\t       lsdc_primary_formats,\n\t\t\t\t       ARRAY_SIZE(lsdc_primary_formats),\n\t\t\t\t       lsdc_fb_format_modifiers,\n\t\t\t\t       DRM_PLANE_TYPE_PRIMARY,\n\t\t\t\t       \"ls-primary-plane-%u\", index);\n\tif (ret)\n\t\treturn ret;\n\n\tdrm_plane_helper_add(plane, &lsdc_primary_helper_funcs);\n\n\tprimary->ldev = to_lsdc(ddev);\n\tprimary->ops = &lsdc_primary_plane_hw_ops[index];\n\n\treturn 0;\n}\n\nint ls7a1000_cursor_plane_init(struct drm_device *ddev,\n\t\t\t       struct drm_plane *plane,\n\t\t\t       unsigned int index)\n{\n\tstruct lsdc_cursor *cursor = to_lsdc_cursor(plane);\n\tint ret;\n\n\tret = drm_universal_plane_init(ddev, plane, 1 << index,\n\t\t\t\t       &lsdc_plane_funcs,\n\t\t\t\t       lsdc_cursor_formats,\n\t\t\t\t       ARRAY_SIZE(lsdc_cursor_formats),\n\t\t\t\t       lsdc_fb_format_modifiers,\n\t\t\t\t       DRM_PLANE_TYPE_CURSOR,\n\t\t\t\t       \"ls-cursor-plane-%u\", index);\n\tif (ret)\n\t\treturn ret;\n\n\tcursor->ldev = to_lsdc(ddev);\n\tcursor->ops = &ls7a1000_cursor_hw_ops[index];\n\n\tdrm_plane_helper_add(plane, &ls7a1000_cursor_plane_helper_funcs);\n\n\treturn 0;\n}\n\nint ls7a2000_cursor_plane_init(struct drm_device *ddev,\n\t\t\t       struct drm_plane *plane,\n\t\t\t       unsigned int index)\n{\n\tstruct lsdc_cursor *cursor = to_lsdc_cursor(plane);\n\tint ret;\n\n\tret = drm_universal_plane_init(ddev, plane, 1 << index,\n\t\t\t\t       &lsdc_plane_funcs,\n\t\t\t\t       lsdc_cursor_formats,\n\t\t\t\t       ARRAY_SIZE(lsdc_cursor_formats),\n\t\t\t\t       lsdc_fb_format_modifiers,\n\t\t\t\t       DRM_PLANE_TYPE_CURSOR,\n\t\t\t\t       \"ls-cursor-plane-%u\", index);\n\tif (ret)\n\t\treturn ret;\n\n\tcursor->ldev = to_lsdc(ddev);\n\tcursor->ops = &ls7a2000_cursor_hw_ops[index];\n\n\tdrm_plane_helper_add(plane, &ls7a2000_cursor_plane_helper_funcs);\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}