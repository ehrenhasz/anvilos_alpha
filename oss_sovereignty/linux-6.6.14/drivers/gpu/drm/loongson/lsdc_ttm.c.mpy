{
  "module_name": "lsdc_ttm.c",
  "hash_id": "be0970bd3fa61a16f938a953b134740c2368ec80845713532cfd01e25871516c",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/loongson/lsdc_ttm.c",
  "human_readable_source": "\n \n\n#include <drm/drm_drv.h>\n#include <drm/drm_file.h>\n#include <drm/drm_gem.h>\n#include <drm/drm_managed.h>\n#include <drm/drm_prime.h>\n\n#include \"lsdc_drv.h\"\n#include \"lsdc_ttm.h\"\n\nconst char *lsdc_mem_type_to_str(uint32_t mem_type)\n{\n\tswitch (mem_type) {\n\tcase TTM_PL_VRAM:\n\t\treturn \"VRAM\";\n\tcase TTM_PL_TT:\n\t\treturn \"GTT\";\n\tcase TTM_PL_SYSTEM:\n\t\treturn \"SYSTEM\";\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn \"Unknown\";\n}\n\nconst char *lsdc_domain_to_str(u32 domain)\n{\n\tswitch (domain) {\n\tcase LSDC_GEM_DOMAIN_VRAM:\n\t\treturn \"VRAM\";\n\tcase LSDC_GEM_DOMAIN_GTT:\n\t\treturn \"GTT\";\n\tcase LSDC_GEM_DOMAIN_SYSTEM:\n\t\treturn \"SYSTEM\";\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn \"Unknown\";\n}\n\nstatic void lsdc_bo_set_placement(struct lsdc_bo *lbo, u32 domain)\n{\n\tu32 c = 0;\n\tu32 pflags = 0;\n\tu32 i;\n\n\tif (lbo->tbo.base.size <= PAGE_SIZE)\n\t\tpflags |= TTM_PL_FLAG_TOPDOWN;\n\n\tlbo->placement.placement = lbo->placements;\n\tlbo->placement.busy_placement = lbo->placements;\n\n\tif (domain & LSDC_GEM_DOMAIN_VRAM) {\n\t\tlbo->placements[c].mem_type = TTM_PL_VRAM;\n\t\tlbo->placements[c++].flags = pflags;\n\t}\n\n\tif (domain & LSDC_GEM_DOMAIN_GTT) {\n\t\tlbo->placements[c].mem_type = TTM_PL_TT;\n\t\tlbo->placements[c++].flags = pflags;\n\t}\n\n\tif (domain & LSDC_GEM_DOMAIN_SYSTEM) {\n\t\tlbo->placements[c].mem_type = TTM_PL_SYSTEM;\n\t\tlbo->placements[c++].flags = 0;\n\t}\n\n\tif (!c) {\n\t\tlbo->placements[c].mem_type = TTM_PL_SYSTEM;\n\t\tlbo->placements[c++].flags = 0;\n\t}\n\n\tlbo->placement.num_placement = c;\n\tlbo->placement.num_busy_placement = c;\n\n\tfor (i = 0; i < c; ++i) {\n\t\tlbo->placements[i].fpfn = 0;\n\t\tlbo->placements[i].lpfn = 0;\n\t}\n}\n\nstatic void lsdc_ttm_tt_destroy(struct ttm_device *bdev, struct ttm_tt *tt)\n{\n\tttm_tt_fini(tt);\n\tkfree(tt);\n}\n\nstatic struct ttm_tt *\nlsdc_ttm_tt_create(struct ttm_buffer_object *tbo, uint32_t page_flags)\n{\n\tstruct ttm_tt *tt;\n\tint ret;\n\n\ttt = kzalloc(sizeof(*tt), GFP_KERNEL);\n\tif (!tt)\n\t\treturn NULL;\n\n\tret = ttm_sg_tt_init(tt, tbo, page_flags, ttm_cached);\n\tif (ret < 0) {\n\t\tkfree(tt);\n\t\treturn NULL;\n\t}\n\n\treturn tt;\n}\n\nstatic int lsdc_ttm_tt_populate(struct ttm_device *bdev,\n\t\t\t\tstruct ttm_tt *ttm,\n\t\t\t\tstruct ttm_operation_ctx *ctx)\n{\n\tbool slave = !!(ttm->page_flags & TTM_TT_FLAG_EXTERNAL);\n\n\tif (slave && ttm->sg) {\n\t\tdrm_prime_sg_to_dma_addr_array(ttm->sg,\n\t\t\t\t\t       ttm->dma_address,\n\t\t\t\t\t       ttm->num_pages);\n\n\t\treturn 0;\n\t}\n\n\treturn ttm_pool_alloc(&bdev->pool, ttm, ctx);\n}\n\nstatic void lsdc_ttm_tt_unpopulate(struct ttm_device *bdev,\n\t\t\t\t   struct ttm_tt *ttm)\n{\n\tbool slave = !!(ttm->page_flags & TTM_TT_FLAG_EXTERNAL);\n\n\tif (slave)\n\t\treturn;\n\n\treturn ttm_pool_free(&bdev->pool, ttm);\n}\n\nstatic void lsdc_bo_evict_flags(struct ttm_buffer_object *tbo,\n\t\t\t\tstruct ttm_placement *tplacement)\n{\n\tstruct ttm_resource *resource = tbo->resource;\n\tstruct lsdc_bo *lbo = to_lsdc_bo(tbo);\n\n\tswitch (resource->mem_type) {\n\tcase TTM_PL_VRAM:\n\t\tlsdc_bo_set_placement(lbo, LSDC_GEM_DOMAIN_GTT);\n\t\tbreak;\n\tcase TTM_PL_TT:\n\tdefault:\n\t\tlsdc_bo_set_placement(lbo, LSDC_GEM_DOMAIN_SYSTEM);\n\t\tbreak;\n\t}\n\n\t*tplacement = lbo->placement;\n}\n\nstatic int lsdc_bo_move(struct ttm_buffer_object *tbo,\n\t\t\tbool evict,\n\t\t\tstruct ttm_operation_ctx *ctx,\n\t\t\tstruct ttm_resource *new_mem,\n\t\t\tstruct ttm_place *hop)\n{\n\tstruct drm_device *ddev = tbo->base.dev;\n\tstruct ttm_resource *old_mem = tbo->resource;\n\tstruct lsdc_bo *lbo = to_lsdc_bo(tbo);\n\tint ret;\n\n\tif (unlikely(tbo->pin_count > 0)) {\n\t\tdrm_warn(ddev, \"Can't move a pinned BO\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tret = ttm_bo_wait_ctx(tbo, ctx);\n\tif (ret)\n\t\treturn ret;\n\n\tif (!old_mem) {\n\t\tdrm_dbg(ddev, \"bo[%p] move: NULL to %s, size: %zu\\n\",\n\t\t\tlbo, lsdc_mem_type_to_str(new_mem->mem_type),\n\t\t\tlsdc_bo_size(lbo));\n\t\tttm_bo_move_null(tbo, new_mem);\n\t\treturn 0;\n\t}\n\n\tif (old_mem->mem_type == TTM_PL_SYSTEM && !tbo->ttm) {\n\t\tttm_bo_move_null(tbo, new_mem);\n\t\tdrm_dbg(ddev, \"bo[%p] move: SYSTEM to NULL, size: %zu\\n\",\n\t\t\tlbo, lsdc_bo_size(lbo));\n\t\treturn 0;\n\t}\n\n\tif (old_mem->mem_type == TTM_PL_SYSTEM &&\n\t    new_mem->mem_type == TTM_PL_TT) {\n\t\tdrm_dbg(ddev, \"bo[%p] move: SYSTEM to GTT, size: %zu\\n\",\n\t\t\tlbo, lsdc_bo_size(lbo));\n\t\tttm_bo_move_null(tbo, new_mem);\n\t\treturn 0;\n\t}\n\n\tif (old_mem->mem_type == TTM_PL_TT &&\n\t    new_mem->mem_type == TTM_PL_SYSTEM) {\n\t\tdrm_dbg(ddev, \"bo[%p] move: GTT to SYSTEM, size: %zu\\n\",\n\t\t\tlbo, lsdc_bo_size(lbo));\n\t\tttm_resource_free(tbo, &tbo->resource);\n\t\tttm_bo_assign_mem(tbo, new_mem);\n\t\treturn 0;\n\t}\n\n\tdrm_dbg(ddev, \"bo[%p] move: %s to %s, size: %zu\\n\",\n\t\tlbo,\n\t\tlsdc_mem_type_to_str(old_mem->mem_type),\n\t\tlsdc_mem_type_to_str(new_mem->mem_type),\n\t\tlsdc_bo_size(lbo));\n\n\treturn ttm_bo_move_memcpy(tbo, ctx, new_mem);\n}\n\nstatic int lsdc_bo_reserve_io_mem(struct ttm_device *bdev,\n\t\t\t\t  struct ttm_resource *mem)\n{\n\tstruct lsdc_device *ldev = tdev_to_ldev(bdev);\n\n\tswitch (mem->mem_type) {\n\tcase TTM_PL_SYSTEM:\n\t\tbreak;\n\tcase TTM_PL_TT:\n\t\tbreak;\n\tcase TTM_PL_VRAM:\n\t\tmem->bus.offset = (mem->start << PAGE_SHIFT) + ldev->vram_base;\n\t\tmem->bus.is_iomem = true;\n\t\tmem->bus.caching = ttm_write_combined;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic struct ttm_device_funcs lsdc_bo_driver = {\n\t.ttm_tt_create = lsdc_ttm_tt_create,\n\t.ttm_tt_populate = lsdc_ttm_tt_populate,\n\t.ttm_tt_unpopulate = lsdc_ttm_tt_unpopulate,\n\t.ttm_tt_destroy = lsdc_ttm_tt_destroy,\n\t.eviction_valuable = ttm_bo_eviction_valuable,\n\t.evict_flags = lsdc_bo_evict_flags,\n\t.move = lsdc_bo_move,\n\t.io_mem_reserve = lsdc_bo_reserve_io_mem,\n};\n\nu64 lsdc_bo_gpu_offset(struct lsdc_bo *lbo)\n{\n\tstruct ttm_buffer_object *tbo = &lbo->tbo;\n\tstruct drm_device *ddev = tbo->base.dev;\n\tstruct ttm_resource *resource = tbo->resource;\n\n\tif (unlikely(!tbo->pin_count)) {\n\t\tdrm_err(ddev, \"unpinned bo, gpu virtual address is invalid\\n\");\n\t\treturn 0;\n\t}\n\n\tif (unlikely(resource->mem_type == TTM_PL_SYSTEM))\n\t\treturn 0;\n\n\treturn resource->start << PAGE_SHIFT;\n}\n\nsize_t lsdc_bo_size(struct lsdc_bo *lbo)\n{\n\tstruct ttm_buffer_object *tbo = &lbo->tbo;\n\n\treturn tbo->base.size;\n}\n\nint lsdc_bo_reserve(struct lsdc_bo *lbo)\n{\n\treturn ttm_bo_reserve(&lbo->tbo, true, false, NULL);\n}\n\nvoid lsdc_bo_unreserve(struct lsdc_bo *lbo)\n{\n\treturn ttm_bo_unreserve(&lbo->tbo);\n}\n\nint lsdc_bo_pin(struct lsdc_bo *lbo, u32 domain, u64 *gpu_addr)\n{\n\tstruct ttm_operation_ctx ctx = { false, false };\n\tstruct ttm_buffer_object *tbo = &lbo->tbo;\n\tstruct lsdc_device *ldev = tdev_to_ldev(tbo->bdev);\n\tint ret;\n\n\tif (tbo->pin_count)\n\t\tgoto bo_pinned;\n\n\tif (lbo->sharing_count && domain == LSDC_GEM_DOMAIN_VRAM)\n\t\treturn -EINVAL;\n\n\tif (domain)\n\t\tlsdc_bo_set_placement(lbo, domain);\n\n\tret = ttm_bo_validate(tbo, &lbo->placement, &ctx);\n\tif (unlikely(ret)) {\n\t\tdrm_err(&ldev->base, \"%p validate failed: %d\\n\", lbo, ret);\n\t\treturn ret;\n\t}\n\n\tif (domain == LSDC_GEM_DOMAIN_VRAM)\n\t\tldev->vram_pinned_size += lsdc_bo_size(lbo);\n\telse if (domain == LSDC_GEM_DOMAIN_GTT)\n\t\tldev->gtt_pinned_size += lsdc_bo_size(lbo);\n\nbo_pinned:\n\tttm_bo_pin(tbo);\n\n\tif (gpu_addr)\n\t\t*gpu_addr = lsdc_bo_gpu_offset(lbo);\n\n\treturn 0;\n}\n\nvoid lsdc_bo_unpin(struct lsdc_bo *lbo)\n{\n\tstruct ttm_buffer_object *tbo = &lbo->tbo;\n\tstruct lsdc_device *ldev = tdev_to_ldev(tbo->bdev);\n\n\tif (unlikely(!tbo->pin_count)) {\n\t\tdrm_dbg(&ldev->base, \"%p unpin is not necessary\\n\", lbo);\n\t\treturn;\n\t}\n\n\tttm_bo_unpin(tbo);\n\n\tif (!tbo->pin_count) {\n\t\tif (tbo->resource->mem_type == TTM_PL_VRAM)\n\t\t\tldev->vram_pinned_size -= lsdc_bo_size(lbo);\n\t\telse if (tbo->resource->mem_type == TTM_PL_TT)\n\t\t\tldev->gtt_pinned_size -= lsdc_bo_size(lbo);\n\t}\n}\n\nvoid lsdc_bo_ref(struct lsdc_bo *lbo)\n{\n\tstruct ttm_buffer_object *tbo = &lbo->tbo;\n\n\tttm_bo_get(tbo);\n}\n\nvoid lsdc_bo_unref(struct lsdc_bo *lbo)\n{\n\tstruct ttm_buffer_object *tbo = &lbo->tbo;\n\n\tttm_bo_put(tbo);\n}\n\nint lsdc_bo_kmap(struct lsdc_bo *lbo)\n{\n\tstruct ttm_buffer_object *tbo = &lbo->tbo;\n\tstruct drm_gem_object *gem = &tbo->base;\n\tstruct drm_device *ddev = gem->dev;\n\tlong ret;\n\tint err;\n\n\tret = dma_resv_wait_timeout(gem->resv, DMA_RESV_USAGE_KERNEL, false,\n\t\t\t\t    MAX_SCHEDULE_TIMEOUT);\n\tif (ret < 0) {\n\t\tdrm_warn(ddev, \"wait fence timeout\\n\");\n\t\treturn ret;\n\t}\n\n\tif (lbo->kptr)\n\t\treturn 0;\n\n\terr = ttm_bo_kmap(tbo, 0, PFN_UP(lsdc_bo_size(lbo)), &lbo->kmap);\n\tif (err) {\n\t\tdrm_err(ddev, \"kmap %p failed: %d\\n\", lbo, err);\n\t\treturn err;\n\t}\n\n\tlbo->kptr = ttm_kmap_obj_virtual(&lbo->kmap, &lbo->is_iomem);\n\n\treturn 0;\n}\n\nvoid lsdc_bo_kunmap(struct lsdc_bo *lbo)\n{\n\tif (!lbo->kptr)\n\t\treturn;\n\n\tlbo->kptr = NULL;\n\tttm_bo_kunmap(&lbo->kmap);\n}\n\nvoid lsdc_bo_clear(struct lsdc_bo *lbo)\n{\n\tlsdc_bo_kmap(lbo);\n\n\tif (lbo->is_iomem)\n\t\tmemset_io((void __iomem *)lbo->kptr, 0, lbo->size);\n\telse\n\t\tmemset(lbo->kptr, 0, lbo->size);\n\n\tlsdc_bo_kunmap(lbo);\n}\n\nint lsdc_bo_evict_vram(struct drm_device *ddev)\n{\n\tstruct lsdc_device *ldev = to_lsdc(ddev);\n\tstruct ttm_device *bdev = &ldev->bdev;\n\tstruct ttm_resource_manager *man;\n\n\tman = ttm_manager_type(bdev, TTM_PL_VRAM);\n\tif (unlikely(!man))\n\t\treturn 0;\n\n\treturn ttm_resource_manager_evict_all(bdev, man);\n}\n\nstatic void lsdc_bo_destroy(struct ttm_buffer_object *tbo)\n{\n\tstruct lsdc_device *ldev = tdev_to_ldev(tbo->bdev);\n\tstruct lsdc_bo *lbo = to_lsdc_bo(tbo);\n\n\tmutex_lock(&ldev->gem.mutex);\n\tlist_del_init(&lbo->list);\n\tmutex_unlock(&ldev->gem.mutex);\n\n\tdrm_gem_object_release(&tbo->base);\n\n\tkfree(lbo);\n}\n\nstruct lsdc_bo *lsdc_bo_create(struct drm_device *ddev,\n\t\t\t       u32 domain,\n\t\t\t       size_t size,\n\t\t\t       bool kernel,\n\t\t\t       struct sg_table *sg,\n\t\t\t       struct dma_resv *resv)\n{\n\tstruct lsdc_device *ldev = to_lsdc(ddev);\n\tstruct ttm_device *bdev = &ldev->bdev;\n\tstruct ttm_buffer_object *tbo;\n\tstruct lsdc_bo *lbo;\n\tenum ttm_bo_type bo_type;\n\tint ret;\n\n\tlbo = kzalloc(sizeof(*lbo), GFP_KERNEL);\n\tif (!lbo)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tINIT_LIST_HEAD(&lbo->list);\n\n\tlbo->initial_domain = domain & (LSDC_GEM_DOMAIN_VRAM |\n\t\t\t\t\tLSDC_GEM_DOMAIN_GTT |\n\t\t\t\t\tLSDC_GEM_DOMAIN_SYSTEM);\n\n\ttbo = &lbo->tbo;\n\n\tsize = ALIGN(size, PAGE_SIZE);\n\n\tret = drm_gem_object_init(ddev, &tbo->base, size);\n\tif (ret) {\n\t\tkfree(lbo);\n\t\treturn ERR_PTR(ret);\n\t}\n\n\ttbo->bdev = bdev;\n\n\tif (kernel)\n\t\tbo_type = ttm_bo_type_kernel;\n\telse if (sg)\n\t\tbo_type = ttm_bo_type_sg;\n\telse\n\t\tbo_type = ttm_bo_type_device;\n\n\tlsdc_bo_set_placement(lbo, domain);\n\tlbo->size = size;\n\n\tret = ttm_bo_init_validate(bdev, tbo, bo_type, &lbo->placement, 0,\n\t\t\t\t   false, sg, resv, lsdc_bo_destroy);\n\tif (ret) {\n\t\tkfree(lbo);\n\t\treturn ERR_PTR(ret);\n\t}\n\n\treturn lbo;\n}\n\nstruct lsdc_bo *lsdc_bo_create_kernel_pinned(struct drm_device *ddev,\n\t\t\t\t\t     u32 domain,\n\t\t\t\t\t     size_t size)\n{\n\tstruct lsdc_bo *lbo;\n\tint ret;\n\n\tlbo = lsdc_bo_create(ddev, domain, size, true, NULL, NULL);\n\tif (IS_ERR(lbo))\n\t\treturn ERR_CAST(lbo);\n\n\tret = lsdc_bo_reserve(lbo);\n\tif (unlikely(ret)) {\n\t\tlsdc_bo_unref(lbo);\n\t\treturn ERR_PTR(ret);\n\t}\n\n\tret = lsdc_bo_pin(lbo, domain, NULL);\n\tlsdc_bo_unreserve(lbo);\n\tif (unlikely(ret)) {\n\t\tlsdc_bo_unref(lbo);\n\t\treturn ERR_PTR(ret);\n\t}\n\n\treturn lbo;\n}\n\nvoid lsdc_bo_free_kernel_pinned(struct lsdc_bo *lbo)\n{\n\tint ret;\n\n\tret = lsdc_bo_reserve(lbo);\n\tif (unlikely(ret))\n\t\treturn;\n\n\tlsdc_bo_unpin(lbo);\n\tlsdc_bo_unreserve(lbo);\n\n\tlsdc_bo_unref(lbo);\n}\n\nstatic void lsdc_ttm_fini(struct drm_device *ddev, void *data)\n{\n\tstruct lsdc_device *ldev = (struct lsdc_device *)data;\n\n\tttm_range_man_fini(&ldev->bdev, TTM_PL_VRAM);\n\tttm_range_man_fini(&ldev->bdev, TTM_PL_TT);\n\n\tttm_device_fini(&ldev->bdev);\n\n\tdrm_dbg(ddev, \"ttm finished\\n\");\n}\n\nint lsdc_ttm_init(struct lsdc_device *ldev)\n{\n\tstruct drm_device *ddev = &ldev->base;\n\tunsigned long num_vram_pages;\n\tunsigned long num_gtt_pages;\n\tint ret;\n\n\tret = ttm_device_init(&ldev->bdev, &lsdc_bo_driver, ddev->dev,\n\t\t\t      ddev->anon_inode->i_mapping,\n\t\t\t      ddev->vma_offset_manager, false, true);\n\tif (ret)\n\t\treturn ret;\n\n\tnum_vram_pages = ldev->vram_size >> PAGE_SHIFT;\n\n\tret = ttm_range_man_init(&ldev->bdev, TTM_PL_VRAM, false, num_vram_pages);\n\tif (unlikely(ret))\n\t\treturn ret;\n\n\tdrm_info(ddev, \"VRAM: %lu pages ready\\n\", num_vram_pages);\n\n\t \n\tldev->gtt_size = 512 << 20;\n\n\tnum_gtt_pages = ldev->gtt_size >> PAGE_SHIFT;\n\n\tret = ttm_range_man_init(&ldev->bdev, TTM_PL_TT, true, num_gtt_pages);\n\tif (unlikely(ret))\n\t\treturn ret;\n\n\tdrm_info(ddev, \"GTT: %lu pages ready\\n\", num_gtt_pages);\n\n\treturn drmm_add_action_or_reset(ddev, lsdc_ttm_fini, ldev);\n}\n\nvoid lsdc_ttm_debugfs_init(struct lsdc_device *ldev)\n{\n\tstruct ttm_device *bdev = &ldev->bdev;\n\tstruct drm_device *ddev = &ldev->base;\n\tstruct drm_minor *minor = ddev->primary;\n\tstruct dentry *root = minor->debugfs_root;\n\tstruct ttm_resource_manager *vram_man;\n\tstruct ttm_resource_manager *gtt_man;\n\n\tvram_man = ttm_manager_type(bdev, TTM_PL_VRAM);\n\tgtt_man = ttm_manager_type(bdev, TTM_PL_TT);\n\n\tttm_resource_manager_create_debugfs(vram_man, root, \"vram_mm\");\n\tttm_resource_manager_create_debugfs(gtt_man, root, \"gtt_mm\");\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}