{
  "module_name": "lsdc_output_7a2000.c",
  "hash_id": "16681117ab908ad1ec1ddc9d41dcae8efbfd1ad1e8e4d4ca2d3cf5cb51ba8e51",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/loongson/lsdc_output_7a2000.c",
  "human_readable_source": "\n \n\n#include <linux/delay.h>\n\n#include <drm/drm_atomic_helper.h>\n#include <drm/drm_debugfs.h>\n#include <drm/drm_edid.h>\n#include <drm/drm_probe_helper.h>\n\n#include \"lsdc_drv.h\"\n#include \"lsdc_output.h\"\n\n \n\nstatic int ls7a2000_connector_get_modes(struct drm_connector *connector)\n{\n\tunsigned int num = 0;\n\tstruct edid *edid;\n\n\tif (connector->ddc) {\n\t\tedid = drm_get_edid(connector, connector->ddc);\n\t\tif (edid) {\n\t\t\tdrm_connector_update_edid_property(connector, edid);\n\t\t\tnum = drm_add_edid_modes(connector, edid);\n\t\t\tkfree(edid);\n\t\t}\n\n\t\treturn num;\n\t}\n\n\tnum = drm_add_modes_noedid(connector, 1920, 1200);\n\n\tdrm_set_preferred_mode(connector, 1024, 768);\n\n\treturn num;\n}\n\nstatic struct drm_encoder *\nls7a2000_connector_get_best_encoder(struct drm_connector *connector,\n\t\t\t\t    struct drm_atomic_state *state)\n{\n\tstruct lsdc_output *output = connector_to_lsdc_output(connector);\n\n\treturn &output->encoder;\n}\n\nstatic const struct drm_connector_helper_funcs ls7a2000_connector_helpers = {\n\t.atomic_best_encoder = ls7a2000_connector_get_best_encoder,\n\t.get_modes = ls7a2000_connector_get_modes,\n};\n\n \n\n#define LSDC_HDMI_REG(i, reg) {                               \\\n\t.name = __stringify_1(LSDC_HDMI##i##_##reg##_REG),    \\\n\t.offset = LSDC_HDMI##i##_##reg##_REG,                 \\\n}\n\nstatic const struct lsdc_reg32 ls7a2000_hdmi0_encoder_regs[] = {\n\tLSDC_HDMI_REG(0, ZONE),\n\tLSDC_HDMI_REG(0, INTF_CTRL),\n\tLSDC_HDMI_REG(0, PHY_CTRL),\n\tLSDC_HDMI_REG(0, PHY_PLL),\n\tLSDC_HDMI_REG(0, AVI_INFO_CRTL),\n\tLSDC_HDMI_REG(0, PHY_CAL),\n\tLSDC_HDMI_REG(0, AUDIO_PLL_LO),\n\tLSDC_HDMI_REG(0, AUDIO_PLL_HI),\n\t{NULL, 0},   \n};\n\nstatic const struct lsdc_reg32 ls7a2000_hdmi1_encoder_regs[] = {\n\tLSDC_HDMI_REG(1, ZONE),\n\tLSDC_HDMI_REG(1, INTF_CTRL),\n\tLSDC_HDMI_REG(1, PHY_CTRL),\n\tLSDC_HDMI_REG(1, PHY_PLL),\n\tLSDC_HDMI_REG(1, AVI_INFO_CRTL),\n\tLSDC_HDMI_REG(1, PHY_CAL),\n\tLSDC_HDMI_REG(1, AUDIO_PLL_LO),\n\tLSDC_HDMI_REG(1, AUDIO_PLL_HI),\n\t{NULL, 0},   \n};\n\nstatic int ls7a2000_hdmi_encoder_regs_show(struct seq_file *m, void *data)\n{\n\tstruct drm_info_node *node = (struct drm_info_node *)m->private;\n\tstruct drm_device *ddev = node->minor->dev;\n\tstruct lsdc_device *ldev = to_lsdc(ddev);\n\tconst struct lsdc_reg32 *preg;\n\n\tpreg = (const struct lsdc_reg32 *)node->info_ent->data;\n\n\twhile (preg->name) {\n\t\tu32 offset = preg->offset;\n\n\t\tseq_printf(m, \"%s (0x%04x): 0x%08x\\n\",\n\t\t\t   preg->name, offset, lsdc_rreg32(ldev, offset));\n\t\t++preg;\n\t}\n\n\treturn 0;\n}\n\nstatic const struct drm_info_list ls7a2000_hdmi0_debugfs_files[] = {\n\t{ \"regs\", ls7a2000_hdmi_encoder_regs_show, 0, (void *)ls7a2000_hdmi0_encoder_regs },\n};\n\nstatic const struct drm_info_list ls7a2000_hdmi1_debugfs_files[] = {\n\t{ \"regs\", ls7a2000_hdmi_encoder_regs_show, 0, (void *)ls7a2000_hdmi1_encoder_regs },\n};\n\nstatic void ls7a2000_hdmi0_late_register(struct drm_connector *connector,\n\t\t\t\t\t struct dentry *root)\n{\n\tstruct drm_device *ddev = connector->dev;\n\tstruct drm_minor *minor = ddev->primary;\n\n\tdrm_debugfs_create_files(ls7a2000_hdmi0_debugfs_files,\n\t\t\t\t ARRAY_SIZE(ls7a2000_hdmi0_debugfs_files),\n\t\t\t\t root, minor);\n}\n\nstatic void ls7a2000_hdmi1_late_register(struct drm_connector *connector,\n\t\t\t\t\t struct dentry *root)\n{\n\tstruct drm_device *ddev = connector->dev;\n\tstruct drm_minor *minor = ddev->primary;\n\n\tdrm_debugfs_create_files(ls7a2000_hdmi1_debugfs_files,\n\t\t\t\t ARRAY_SIZE(ls7a2000_hdmi1_debugfs_files),\n\t\t\t\t root, minor);\n}\n\n \n\nstatic enum drm_connector_status\nls7a2000_hdmi0_vga_connector_detect(struct drm_connector *connector, bool force)\n{\n\tstruct drm_device *ddev = connector->dev;\n\tstruct lsdc_device *ldev = to_lsdc(ddev);\n\tu32 val;\n\n\tval = lsdc_rreg32(ldev, LSDC_HDMI_HPD_STATUS_REG);\n\n\tif (val & HDMI0_HPD_FLAG)\n\t\treturn connector_status_connected;\n\n\tif (connector->ddc) {\n\t\tif (drm_probe_ddc(connector->ddc))\n\t\t\treturn connector_status_connected;\n\n\t\treturn connector_status_disconnected;\n\t}\n\n\treturn connector_status_unknown;\n}\n\nstatic enum drm_connector_status\nls7a2000_hdmi1_connector_detect(struct drm_connector *connector, bool force)\n{\n\tstruct lsdc_device *ldev = to_lsdc(connector->dev);\n\tu32 val;\n\n\tval = lsdc_rreg32(ldev, LSDC_HDMI_HPD_STATUS_REG);\n\n\tif (val & HDMI1_HPD_FLAG)\n\t\treturn connector_status_connected;\n\n\treturn connector_status_disconnected;\n}\n\nstatic const struct drm_connector_funcs ls7a2000_hdmi_connector_funcs[2] = {\n\t{\n\t\t.detect = ls7a2000_hdmi0_vga_connector_detect,\n\t\t.fill_modes = drm_helper_probe_single_connector_modes,\n\t\t.destroy = drm_connector_cleanup,\n\t\t.reset = drm_atomic_helper_connector_reset,\n\t\t.atomic_duplicate_state = drm_atomic_helper_connector_duplicate_state,\n\t\t.atomic_destroy_state = drm_atomic_helper_connector_destroy_state,\n\t\t.debugfs_init = ls7a2000_hdmi0_late_register,\n\t},\n\t{\n\t\t.detect = ls7a2000_hdmi1_connector_detect,\n\t\t.fill_modes = drm_helper_probe_single_connector_modes,\n\t\t.destroy = drm_connector_cleanup,\n\t\t.reset = drm_atomic_helper_connector_reset,\n\t\t.atomic_duplicate_state = drm_atomic_helper_connector_duplicate_state,\n\t\t.atomic_destroy_state = drm_atomic_helper_connector_destroy_state,\n\t\t.debugfs_init = ls7a2000_hdmi1_late_register,\n\t},\n};\n\n \nstatic void ls7a2000_hdmi0_encoder_reset(struct drm_encoder *encoder)\n{\n\tstruct drm_device *ddev = encoder->dev;\n\tstruct lsdc_device *ldev = to_lsdc(ddev);\n\tu32 val;\n\n\tval = PHY_CLOCK_POL | PHY_CLOCK_EN | PHY_DATA_EN;\n\tlsdc_wreg32(ldev, LSDC_CRTC0_DVO_CONF_REG, val);\n\n\t \n\tval = lsdc_rreg32(ldev, LSDC_HDMI0_INTF_CTRL_REG);\n\tval &= ~HW_I2C_EN;\n\tlsdc_wreg32(ldev, LSDC_HDMI0_INTF_CTRL_REG, val);\n\n\t \n\tlsdc_wreg32(ldev, LSDC_HDMI0_PHY_CTRL_REG, HDMI_PHY_RESET_N);\n\n\tmdelay(20);\n\n\tdrm_dbg(ddev, \"HDMI-0 Reset\\n\");\n}\n\nstatic void ls7a2000_hdmi1_encoder_reset(struct drm_encoder *encoder)\n{\n\tstruct drm_device *ddev = encoder->dev;\n\tstruct lsdc_device *ldev = to_lsdc(ddev);\n\tu32 val;\n\n\tval = PHY_CLOCK_POL | PHY_CLOCK_EN | PHY_DATA_EN;\n\tlsdc_wreg32(ldev, LSDC_CRTC1_DVO_CONF_REG, val);\n\n\t \n\tval = lsdc_rreg32(ldev, LSDC_HDMI1_INTF_CTRL_REG);\n\tval &= ~HW_I2C_EN;\n\tlsdc_wreg32(ldev, LSDC_HDMI1_INTF_CTRL_REG, val);\n\n\t \n\tlsdc_wreg32(ldev, LSDC_HDMI1_PHY_CTRL_REG, HDMI_PHY_RESET_N);\n\n\tmdelay(20);\n\n\tdrm_dbg(ddev, \"HDMI-1 Reset\\n\");\n}\n\nstatic const struct drm_encoder_funcs ls7a2000_encoder_funcs[2] = {\n\t{\n\t\t.reset = ls7a2000_hdmi0_encoder_reset,\n\t\t.destroy = drm_encoder_cleanup,\n\t},\n\t{\n\t\t.reset = ls7a2000_hdmi1_encoder_reset,\n\t\t.destroy = drm_encoder_cleanup,\n\t},\n};\n\nstatic int ls7a2000_hdmi_set_avi_infoframe(struct drm_encoder *encoder,\n\t\t\t\t\t   struct drm_display_mode *mode)\n{\n\tstruct lsdc_output *output = encoder_to_lsdc_output(encoder);\n\tstruct lsdc_display_pipe *dispipe = output_to_display_pipe(output);\n\tunsigned int index = dispipe->index;\n\tstruct drm_device *ddev = encoder->dev;\n\tstruct lsdc_device *ldev = to_lsdc(ddev);\n\tstruct hdmi_avi_infoframe infoframe;\n\tu8 buffer[HDMI_INFOFRAME_SIZE(AVI)];\n\tunsigned char *ptr = &buffer[HDMI_INFOFRAME_HEADER_SIZE];\n\tunsigned int content0, content1, content2, content3;\n\tint err;\n\n\terr = drm_hdmi_avi_infoframe_from_display_mode(&infoframe,\n\t\t\t\t\t\t       &output->connector,\n\t\t\t\t\t\t       mode);\n\tif (err < 0) {\n\t\tdrm_err(ddev, \"failed to setup AVI infoframe: %d\\n\", err);\n\t\treturn err;\n\t}\n\n\t \n\tinfoframe.colorspace = HDMI_COLORSPACE_RGB;\n\tinfoframe.quantization_range = HDMI_QUANTIZATION_RANGE_DEFAULT;\n\tinfoframe.colorimetry = HDMI_COLORIMETRY_NONE;\n\n\terr = hdmi_avi_infoframe_pack(&infoframe, buffer, sizeof(buffer));\n\tif (err < 0) {\n\t\tdrm_err(ddev, \"failed to pack AVI infoframe: %d\\n\", err);\n\t\t\treturn err;\n\t}\n\n\tcontent0 = *(unsigned int *)ptr;\n\tcontent1 = *(ptr + 4);\n\tcontent2 = *(unsigned int *)(ptr + 5);\n\tcontent3 = *(unsigned int *)(ptr + 9);\n\n\tlsdc_pipe_wreg32(ldev, LSDC_HDMI0_AVI_CONTENT0, index, content0);\n\tlsdc_pipe_wreg32(ldev, LSDC_HDMI0_AVI_CONTENT1, index, content1);\n\tlsdc_pipe_wreg32(ldev, LSDC_HDMI0_AVI_CONTENT2, index, content2);\n\tlsdc_pipe_wreg32(ldev, LSDC_HDMI0_AVI_CONTENT3, index, content3);\n\n\tlsdc_pipe_wreg32(ldev, LSDC_HDMI0_AVI_INFO_CRTL_REG, index,\n\t\t\t AVI_PKT_ENABLE | AVI_PKT_UPDATE);\n\n\tdrm_dbg(ddev, \"Update HDMI-%u avi infoframe\\n\", index);\n\n\treturn 0;\n}\n\nstatic void ls7a2000_hdmi_atomic_disable(struct drm_encoder *encoder,\n\t\t\t\t\t struct drm_atomic_state *state)\n{\n\tstruct lsdc_output *output = encoder_to_lsdc_output(encoder);\n\tstruct lsdc_display_pipe *dispipe = output_to_display_pipe(output);\n\tunsigned int index = dispipe->index;\n\tstruct drm_device *ddev = encoder->dev;\n\tstruct lsdc_device *ldev = to_lsdc(ddev);\n\tu32 val;\n\n\t \n\tval = lsdc_pipe_rreg32(ldev, LSDC_HDMI0_PHY_CTRL_REG, index);\n\tval &= ~HDMI_PHY_EN;\n\tlsdc_pipe_wreg32(ldev, LSDC_HDMI0_PHY_CTRL_REG, index, val);\n\n\t \n\tval = lsdc_pipe_rreg32(ldev, LSDC_HDMI0_INTF_CTRL_REG, index);\n\tval &= ~HDMI_INTERFACE_EN;\n\tlsdc_pipe_wreg32(ldev, LSDC_HDMI0_INTF_CTRL_REG, index, val);\n\n\tdrm_dbg(ddev, \"HDMI-%u disabled\\n\", index);\n}\n\nstatic void ls7a2000_hdmi_atomic_enable(struct drm_encoder *encoder,\n\t\t\t\t\tstruct drm_atomic_state *state)\n{\n\tstruct drm_device *ddev = encoder->dev;\n\tstruct lsdc_device *ldev = to_lsdc(ddev);\n\tstruct lsdc_output *output = encoder_to_lsdc_output(encoder);\n\tstruct lsdc_display_pipe *dispipe = output_to_display_pipe(output);\n\tunsigned int index = dispipe->index;\n\tu32 val;\n\n\t \n\tval = 64 << HDMI_H_ZONE_IDLE_SHIFT | 64 << HDMI_V_ZONE_IDLE_SHIFT;\n\n\tlsdc_pipe_wreg32(ldev, LSDC_HDMI0_ZONE_REG, index, val);\n\n\tval = HDMI_PHY_TERM_STATUS |\n\t      HDMI_PHY_TERM_DET_EN |\n\t      HDMI_PHY_TERM_H_EN |\n\t      HDMI_PHY_TERM_L_EN |\n\t      HDMI_PHY_RESET_N |\n\t      HDMI_PHY_EN;\n\n\tlsdc_pipe_wreg32(ldev, LSDC_HDMI0_PHY_CTRL_REG, index, val);\n\n\tudelay(2);\n\n\tval = HDMI_CTL_PERIOD_MODE |\n\t      HDMI_AUDIO_EN |\n\t      HDMI_PACKET_EN |\n\t      HDMI_INTERFACE_EN |\n\t      (8 << HDMI_VIDEO_PREAMBLE_SHIFT);\n\n\tlsdc_pipe_wreg32(ldev, LSDC_HDMI0_INTF_CTRL_REG, index, val);\n\n\tdrm_dbg(ddev, \"HDMI-%u enabled\\n\", index);\n}\n\n \nstatic void ls7a2000_hdmi_phy_pll_config(struct lsdc_device *ldev,\n\t\t\t\t\t int fin,\n\t\t\t\t\t unsigned int index)\n{\n\tstruct drm_device *ddev = &ldev->base;\n\tint count = 0;\n\tu32 val;\n\n\t \n\tlsdc_pipe_wreg32(ldev, LSDC_HDMI0_PHY_PLL_REG, index, 0x0);\n\n\t \n\n\tif (fin >= 170000)\n\t\tval = (16 << HDMI_PLL_IDF_SHIFT) |\n\t\t      (40 << HDMI_PLL_LF_SHIFT) |\n\t\t      (0 << HDMI_PLL_ODF_SHIFT);\n\telse if (fin >= 85000)\n\t\tval = (8 << HDMI_PLL_IDF_SHIFT) |\n\t\t      (40 << HDMI_PLL_LF_SHIFT) |\n\t\t      (1 << HDMI_PLL_ODF_SHIFT);\n\telse if (fin >= 42500)\n\t\tval = (4 << HDMI_PLL_IDF_SHIFT) |\n\t\t      (40 << HDMI_PLL_LF_SHIFT) |\n\t\t      (2 << HDMI_PLL_ODF_SHIFT);\n\telse if  (fin >= 21250)\n\t\tval = (2 << HDMI_PLL_IDF_SHIFT) |\n\t\t      (40 << HDMI_PLL_LF_SHIFT) |\n\t\t      (3 << HDMI_PLL_ODF_SHIFT);\n\telse\n\t\tval = (1 << HDMI_PLL_IDF_SHIFT) |\n\t\t      (40 << HDMI_PLL_LF_SHIFT) |\n\t\t      (4 << HDMI_PLL_ODF_SHIFT);\n\n\tlsdc_pipe_wreg32(ldev, LSDC_HDMI0_PHY_PLL_REG, index, val);\n\n\tval |= HDMI_PLL_ENABLE;\n\n\tlsdc_pipe_wreg32(ldev, LSDC_HDMI0_PHY_PLL_REG, index, val);\n\n\tudelay(2);\n\n\tdrm_dbg(ddev, \"Fin of HDMI-%u: %d kHz\\n\", index, fin);\n\n\t \n\tdo {\n\t\tval = lsdc_pipe_rreg32(ldev, LSDC_HDMI0_PHY_PLL_REG, index);\n\n\t\tif (val & HDMI_PLL_LOCKED) {\n\t\t\tdrm_dbg(ddev, \"Setting HDMI-%u PLL take %d cycles\\n\",\n\t\t\t\tindex, count);\n\t\t\tbreak;\n\t\t}\n\t\t++count;\n\t} while (count < 1000);\n\n\tlsdc_pipe_wreg32(ldev, LSDC_HDMI0_PHY_CAL_REG, index, 0x0f000ff0);\n\n\tif (count >= 1000)\n\t\tdrm_err(ddev, \"Setting HDMI-%u PLL failed\\n\", index);\n}\n\nstatic void ls7a2000_hdmi_atomic_mode_set(struct drm_encoder *encoder,\n\t\t\t\t\t  struct drm_crtc_state *crtc_state,\n\t\t\t\t\t  struct drm_connector_state *conn_state)\n{\n\tstruct lsdc_output *output = encoder_to_lsdc_output(encoder);\n\tstruct lsdc_display_pipe *dispipe = output_to_display_pipe(output);\n\tunsigned int index = dispipe->index;\n\tstruct drm_device *ddev = encoder->dev;\n\tstruct lsdc_device *ldev = to_lsdc(ddev);\n\tstruct drm_display_mode *mode = &crtc_state->mode;\n\n\tls7a2000_hdmi_phy_pll_config(ldev, mode->clock, index);\n\n\tls7a2000_hdmi_set_avi_infoframe(encoder, mode);\n\n\tdrm_dbg(ddev, \"%s modeset finished\\n\", encoder->name);\n}\n\nstatic const struct drm_encoder_helper_funcs ls7a2000_encoder_helper_funcs = {\n\t.atomic_disable = ls7a2000_hdmi_atomic_disable,\n\t.atomic_enable = ls7a2000_hdmi_atomic_enable,\n\t.atomic_mode_set = ls7a2000_hdmi_atomic_mode_set,\n};\n\n \nint ls7a2000_output_init(struct drm_device *ddev,\n\t\t\t struct lsdc_display_pipe *dispipe,\n\t\t\t struct i2c_adapter *ddc,\n\t\t\t unsigned int pipe)\n{\n\tstruct lsdc_output *output = &dispipe->output;\n\tstruct drm_encoder *encoder = &output->encoder;\n\tstruct drm_connector *connector = &output->connector;\n\tint ret;\n\n\tret = drm_encoder_init(ddev, encoder, &ls7a2000_encoder_funcs[pipe],\n\t\t\t       DRM_MODE_ENCODER_TMDS, \"encoder-%u\", pipe);\n\tif (ret)\n\t\treturn ret;\n\n\tencoder->possible_crtcs = BIT(pipe);\n\n\tdrm_encoder_helper_add(encoder, &ls7a2000_encoder_helper_funcs);\n\n\tret = drm_connector_init_with_ddc(ddev, connector,\n\t\t\t\t\t  &ls7a2000_hdmi_connector_funcs[pipe],\n\t\t\t\t\t  DRM_MODE_CONNECTOR_HDMIA, ddc);\n\tif (ret)\n\t\treturn ret;\n\n\tdrm_info(ddev, \"display pipe-%u has HDMI %s\\n\", pipe, pipe ? \"\" : \"and/or VGA\");\n\n\tdrm_connector_helper_add(connector, &ls7a2000_connector_helpers);\n\n\tdrm_connector_attach_encoder(connector, encoder);\n\n\tconnector->polled = DRM_CONNECTOR_POLL_CONNECT |\n\t\t\t    DRM_CONNECTOR_POLL_DISCONNECT;\n\n\tconnector->interlace_allowed = 0;\n\tconnector->doublescan_allowed = 0;\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}