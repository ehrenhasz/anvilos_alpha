{
  "module_name": "lsdc_i2c.c",
  "hash_id": "01fe8ec5978fbda1aa7b7ce1feda5399250e301fe0cc5b9307f0e6959ae3111d",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/loongson/lsdc_i2c.c",
  "human_readable_source": "\n \n\n#include <drm/drm_managed.h>\n\n#include \"lsdc_drv.h\"\n#include \"lsdc_output.h\"\n\n \nstatic void __lsdc_gpio_i2c_set(struct lsdc_i2c * const li2c, int mask, int state)\n{\n\tstruct lsdc_device *ldev = to_lsdc(li2c->ddev);\n\tunsigned long flags;\n\tu8 val;\n\n\tspin_lock_irqsave(&ldev->reglock, flags);\n\n\tif (state) {\n\t\t \n\t\tval = readb(li2c->dir_reg);\n\t\tval |= mask;\n\t\twriteb(val, li2c->dir_reg);\n\t} else {\n\t\t \n\t\tval = readb(li2c->dir_reg);\n\t\tval &= ~mask;\n\t\twriteb(val, li2c->dir_reg);\n\n\t\t \n\t\tval = readb(li2c->dat_reg);\n\t\tval &= ~mask;\n\t\twriteb(val, li2c->dat_reg);\n\t}\n\n\tspin_unlock_irqrestore(&ldev->reglock, flags);\n}\n\n \nstatic int __lsdc_gpio_i2c_get(struct lsdc_i2c * const li2c, int mask)\n{\n\tstruct lsdc_device *ldev = to_lsdc(li2c->ddev);\n\tunsigned long flags;\n\tu8 val;\n\n\tspin_lock_irqsave(&ldev->reglock, flags);\n\n\t \n\tval = readb(li2c->dir_reg);\n\tval |= mask;\n\twriteb(val, li2c->dir_reg);\n\n\t \n\tval = readb(li2c->dat_reg);\n\n\tspin_unlock_irqrestore(&ldev->reglock, flags);\n\n\treturn (val & mask) ? 1 : 0;\n}\n\nstatic void lsdc_gpio_i2c_set_sda(void *i2c, int state)\n{\n\tstruct lsdc_i2c * const li2c = (struct lsdc_i2c *)i2c;\n\t \n\treturn __lsdc_gpio_i2c_set(li2c, li2c->sda, state);\n}\n\nstatic void lsdc_gpio_i2c_set_scl(void *i2c, int state)\n{\n\tstruct lsdc_i2c * const li2c = (struct lsdc_i2c *)i2c;\n\t \n\treturn __lsdc_gpio_i2c_set(li2c, li2c->scl, state);\n}\n\nstatic int lsdc_gpio_i2c_get_sda(void *i2c)\n{\n\tstruct lsdc_i2c * const li2c = (struct lsdc_i2c *)i2c;\n\t \n\treturn __lsdc_gpio_i2c_get(li2c, li2c->sda);\n}\n\nstatic int lsdc_gpio_i2c_get_scl(void *i2c)\n{\n\tstruct lsdc_i2c * const li2c = (struct lsdc_i2c *)i2c;\n\t \n\treturn __lsdc_gpio_i2c_get(li2c, li2c->scl);\n}\n\nstatic void lsdc_destroy_i2c(struct drm_device *ddev, void *data)\n{\n\tstruct lsdc_i2c *li2c = (struct lsdc_i2c *)data;\n\n\tif (li2c) {\n\t\ti2c_del_adapter(&li2c->adapter);\n\t\tkfree(li2c);\n\t}\n}\n\n \nint lsdc_create_i2c_chan(struct drm_device *ddev,\n\t\t\t struct lsdc_display_pipe *dispipe,\n\t\t\t unsigned int index)\n{\n\tstruct lsdc_device *ldev = to_lsdc(ddev);\n\tstruct i2c_adapter *adapter;\n\tstruct lsdc_i2c *li2c;\n\tint ret;\n\n\tli2c = kzalloc(sizeof(*li2c), GFP_KERNEL);\n\tif (!li2c)\n\t\treturn -ENOMEM;\n\n\tdispipe->li2c = li2c;\n\n\tif (index == 0) {\n\t\tli2c->sda = 0x01;   \n\t\tli2c->scl = 0x02;   \n\t} else if (index == 1) {\n\t\tli2c->sda = 0x04;   \n\t\tli2c->scl = 0x08;   \n\t} else {\n\t\treturn -ENOENT;\n\t}\n\n\tli2c->ddev = ddev;\n\tli2c->dir_reg = ldev->reg_base + LS7A_DC_GPIO_DIR_REG;\n\tli2c->dat_reg = ldev->reg_base + LS7A_DC_GPIO_DAT_REG;\n\n\tli2c->bit.setsda = lsdc_gpio_i2c_set_sda;\n\tli2c->bit.setscl = lsdc_gpio_i2c_set_scl;\n\tli2c->bit.getsda = lsdc_gpio_i2c_get_sda;\n\tli2c->bit.getscl = lsdc_gpio_i2c_get_scl;\n\tli2c->bit.udelay = 5;\n\tli2c->bit.timeout = usecs_to_jiffies(2200);\n\tli2c->bit.data = li2c;\n\n\tadapter = &li2c->adapter;\n\tadapter->algo_data = &li2c->bit;\n\tadapter->owner = THIS_MODULE;\n\tadapter->class = I2C_CLASS_DDC;\n\tadapter->dev.parent = ddev->dev;\n\tadapter->nr = -1;\n\n\tsnprintf(adapter->name, sizeof(adapter->name), \"lsdc-i2c%u\", index);\n\n\ti2c_set_adapdata(adapter, li2c);\n\n\tret = i2c_bit_add_bus(adapter);\n\tif (ret) {\n\t\tkfree(li2c);\n\t\treturn ret;\n\t}\n\n\tret = drmm_add_action_or_reset(ddev, lsdc_destroy_i2c, li2c);\n\tif (ret)\n\t\treturn ret;\n\n\tdrm_info(ddev, \"%s(sda pin mask=%u, scl pin mask=%u) created\\n\",\n\t\t adapter->name, li2c->sda, li2c->scl);\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}