{
  "module_name": "lsdc_output_7a1000.c",
  "hash_id": "9618995ea28fe50bd3c880591ee76d4c14a3bc5bc402cf2ab25135aae03b13ba",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/loongson/lsdc_output_7a1000.c",
  "human_readable_source": "\n \n\n#include <drm/drm_atomic_helper.h>\n#include <drm/drm_edid.h>\n#include <drm/drm_probe_helper.h>\n\n#include \"lsdc_drv.h\"\n#include \"lsdc_output.h\"\n\n \n\nstatic int ls7a1000_dpi_connector_get_modes(struct drm_connector *conn)\n{\n\tunsigned int num = 0;\n\tstruct edid *edid;\n\n\tif (conn->ddc) {\n\t\tedid = drm_get_edid(conn, conn->ddc);\n\t\tif (edid) {\n\t\t\tdrm_connector_update_edid_property(conn, edid);\n\t\t\tnum = drm_add_edid_modes(conn, edid);\n\t\t\tkfree(edid);\n\t\t}\n\n\t\treturn num;\n\t}\n\n\tnum = drm_add_modes_noedid(conn, 1920, 1200);\n\n\tdrm_set_preferred_mode(conn, 1024, 768);\n\n\treturn num;\n}\n\nstatic struct drm_encoder *\nls7a1000_dpi_connector_get_best_encoder(struct drm_connector *connector,\n\t\t\t\t\tstruct drm_atomic_state *state)\n{\n\tstruct lsdc_output *output = connector_to_lsdc_output(connector);\n\n\treturn &output->encoder;\n}\n\nstatic const struct drm_connector_helper_funcs\nls7a1000_dpi_connector_helpers = {\n\t.atomic_best_encoder = ls7a1000_dpi_connector_get_best_encoder,\n\t.get_modes = ls7a1000_dpi_connector_get_modes,\n};\n\nstatic enum drm_connector_status\nls7a1000_dpi_connector_detect(struct drm_connector *connector, bool force)\n{\n\tstruct i2c_adapter *ddc = connector->ddc;\n\n\tif (ddc) {\n\t\tif (drm_probe_ddc(ddc))\n\t\t\treturn connector_status_connected;\n\n\t\treturn connector_status_disconnected;\n\t}\n\n\treturn connector_status_unknown;\n}\n\nstatic const struct drm_connector_funcs ls7a1000_dpi_connector_funcs = {\n\t.detect = ls7a1000_dpi_connector_detect,\n\t.fill_modes = drm_helper_probe_single_connector_modes,\n\t.destroy = drm_connector_cleanup,\n\t.reset = drm_atomic_helper_connector_reset,\n\t.atomic_duplicate_state = drm_atomic_helper_connector_duplicate_state,\n\t.atomic_destroy_state = drm_atomic_helper_connector_destroy_state\n};\n\nstatic void ls7a1000_pipe0_encoder_reset(struct drm_encoder *encoder)\n{\n\tstruct drm_device *ddev = encoder->dev;\n\tstruct lsdc_device *ldev = to_lsdc(ddev);\n\n\t \n\tlsdc_wreg32(ldev, LSDC_CRTC0_DVO_CONF_REG,\n\t\t    PHY_CLOCK_POL | PHY_CLOCK_EN | PHY_DATA_EN);\n}\n\nstatic void ls7a1000_pipe1_encoder_reset(struct drm_encoder *encoder)\n{\n\tstruct drm_device *ddev = encoder->dev;\n\tstruct lsdc_device *ldev = to_lsdc(ddev);\n\n\t \n\n\t \n\tlsdc_wreg32(ldev, LSDC_CRTC1_DVO_CONF_REG,\n\t\t    BIT(31) | PHY_CLOCK_POL | PHY_CLOCK_EN | PHY_DATA_EN);\n}\n\nstatic const struct drm_encoder_funcs ls7a1000_encoder_funcs[2] = {\n\t{\n\t\t.reset = ls7a1000_pipe0_encoder_reset,\n\t\t.destroy = drm_encoder_cleanup,\n\t},\n\t{\n\t\t.reset = ls7a1000_pipe1_encoder_reset,\n\t\t.destroy = drm_encoder_cleanup,\n\t},\n};\n\nint ls7a1000_output_init(struct drm_device *ddev,\n\t\t\t struct lsdc_display_pipe *dispipe,\n\t\t\t struct i2c_adapter *ddc,\n\t\t\t unsigned int index)\n{\n\tstruct lsdc_output *output = &dispipe->output;\n\tstruct drm_encoder *encoder = &output->encoder;\n\tstruct drm_connector *connector = &output->connector;\n\tint ret;\n\n\tret = drm_encoder_init(ddev, encoder, &ls7a1000_encoder_funcs[index],\n\t\t\t       DRM_MODE_ENCODER_TMDS, \"encoder-%u\", index);\n\tif (ret)\n\t\treturn ret;\n\n\tencoder->possible_crtcs = BIT(index);\n\n\tret = drm_connector_init_with_ddc(ddev, connector,\n\t\t\t\t\t  &ls7a1000_dpi_connector_funcs,\n\t\t\t\t\t  DRM_MODE_CONNECTOR_DPI, ddc);\n\tif (ret)\n\t\treturn ret;\n\n\tdrm_info(ddev, \"display pipe-%u has a DVO\\n\", index);\n\n\tdrm_connector_helper_add(connector, &ls7a1000_dpi_connector_helpers);\n\n\tdrm_connector_attach_encoder(connector, encoder);\n\n\tconnector->polled = DRM_CONNECTOR_POLL_CONNECT |\n\t\t\t    DRM_CONNECTOR_POLL_DISCONNECT;\n\n\tconnector->interlace_allowed = 0;\n\tconnector->doublescan_allowed = 0;\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}