{
  "module_name": "lsdc_crtc.c",
  "hash_id": "3bcd895572e86c2492875a0fed8b7e11ecc161b8555135a27e47f4903c9f337e",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/loongson/lsdc_crtc.c",
  "human_readable_source": "\n \n\n#include <linux/delay.h>\n\n#include <drm/drm_atomic.h>\n#include <drm/drm_atomic_helper.h>\n#include <drm/drm_debugfs.h>\n#include <drm/drm_vblank.h>\n\n#include \"lsdc_drv.h\"\n\n \n\nstatic void lsdc_crtc0_soft_reset(struct lsdc_crtc *lcrtc)\n{\n\tstruct lsdc_device *ldev = lcrtc->ldev;\n\tu32 val;\n\n\tval = lsdc_rreg32(ldev, LSDC_CRTC0_CFG_REG);\n\n\tval &= CFG_VALID_BITS_MASK;\n\n\t \n\tval &= ~CFG_RESET_N;\n\n\tval &= ~CFG_PIX_FMT_MASK;\n\n\tlsdc_wreg32(ldev, LSDC_CRTC0_CFG_REG, val);\n\n\tudelay(1);\n\n\tval |= CFG_RESET_N | LSDC_PF_XRGB8888 | CFG_OUTPUT_ENABLE;\n\n\tlsdc_wreg32(ldev, LSDC_CRTC0_CFG_REG, val);\n\n\t \n\tmdelay(20);\n}\n\nstatic void lsdc_crtc1_soft_reset(struct lsdc_crtc *lcrtc)\n{\n\tstruct lsdc_device *ldev = lcrtc->ldev;\n\tu32 val;\n\n\tval = lsdc_rreg32(ldev, LSDC_CRTC1_CFG_REG);\n\n\tval &= CFG_VALID_BITS_MASK;\n\n\t \n\tval &= ~CFG_RESET_N;\n\n\tval &= ~CFG_PIX_FMT_MASK;\n\n\tlsdc_wreg32(ldev, LSDC_CRTC1_CFG_REG, val);\n\n\tudelay(1);\n\n\tval |= CFG_RESET_N | LSDC_PF_XRGB8888 | CFG_OUTPUT_ENABLE;\n\n\tlsdc_wreg32(ldev, LSDC_CRTC1_CFG_REG, val);\n\n\t \n\tmsleep(20);\n}\n\nstatic void lsdc_crtc0_enable(struct lsdc_crtc *lcrtc)\n{\n\tstruct lsdc_device *ldev = lcrtc->ldev;\n\tu32 val;\n\n\tval = lsdc_rreg32(ldev, LSDC_CRTC0_CFG_REG);\n\n\t \n\tif (val & CRTC_ANCHORED) {\n\t\tdrm_warn(&ldev->base, \"%s stall\\n\", lcrtc->base.name);\n\t\treturn lsdc_crtc0_soft_reset(lcrtc);\n\t}\n\n\tlsdc_wreg32(ldev, LSDC_CRTC0_CFG_REG, val | CFG_OUTPUT_ENABLE);\n}\n\nstatic void lsdc_crtc0_disable(struct lsdc_crtc *lcrtc)\n{\n\tstruct lsdc_device *ldev = lcrtc->ldev;\n\n\tlsdc_ureg32_clr(ldev, LSDC_CRTC0_CFG_REG, CFG_OUTPUT_ENABLE);\n\n\tudelay(9);\n}\n\nstatic void lsdc_crtc1_enable(struct lsdc_crtc *lcrtc)\n{\n\tstruct lsdc_device *ldev = lcrtc->ldev;\n\tu32 val;\n\n\t \n\tval = lsdc_rreg32(ldev, LSDC_CRTC1_CFG_REG);\n\tif (val & CRTC_ANCHORED) {\n\t\tdrm_warn(&ldev->base, \"%s stall\\n\", lcrtc->base.name);\n\t\treturn lsdc_crtc1_soft_reset(lcrtc);\n\t}\n\n\tlsdc_wreg32(ldev, LSDC_CRTC1_CFG_REG, val | CFG_OUTPUT_ENABLE);\n}\n\nstatic void lsdc_crtc1_disable(struct lsdc_crtc *lcrtc)\n{\n\tstruct lsdc_device *ldev = lcrtc->ldev;\n\n\tlsdc_ureg32_clr(ldev, LSDC_CRTC1_CFG_REG, CFG_OUTPUT_ENABLE);\n\n\tudelay(9);\n}\n\n \n\nstatic void lsdc_crtc0_scan_pos(struct lsdc_crtc *lcrtc, int *hpos, int *vpos)\n{\n\tstruct lsdc_device *ldev = lcrtc->ldev;\n\tu32 val;\n\n\tval = lsdc_rreg32(ldev, LSDC_CRTC0_SCAN_POS_REG);\n\n\t*hpos = val >> 16;\n\t*vpos = val & 0xffff;\n}\n\nstatic void lsdc_crtc1_scan_pos(struct lsdc_crtc *lcrtc, int *hpos, int *vpos)\n{\n\tstruct lsdc_device *ldev = lcrtc->ldev;\n\tu32 val;\n\n\tval = lsdc_rreg32(ldev, LSDC_CRTC1_SCAN_POS_REG);\n\n\t*hpos = val >> 16;\n\t*vpos = val & 0xffff;\n}\n\nstatic void lsdc_crtc0_enable_vblank(struct lsdc_crtc *lcrtc)\n{\n\tstruct lsdc_device *ldev = lcrtc->ldev;\n\n\tlsdc_ureg32_set(ldev, LSDC_INT_REG, INT_CRTC0_VSYNC_EN);\n}\n\nstatic void lsdc_crtc0_disable_vblank(struct lsdc_crtc *lcrtc)\n{\n\tstruct lsdc_device *ldev = lcrtc->ldev;\n\n\tlsdc_ureg32_clr(ldev, LSDC_INT_REG, INT_CRTC0_VSYNC_EN);\n}\n\nstatic void lsdc_crtc1_enable_vblank(struct lsdc_crtc *lcrtc)\n{\n\tstruct lsdc_device *ldev = lcrtc->ldev;\n\n\tlsdc_ureg32_set(ldev, LSDC_INT_REG, INT_CRTC1_VSYNC_EN);\n}\n\nstatic void lsdc_crtc1_disable_vblank(struct lsdc_crtc *lcrtc)\n{\n\tstruct lsdc_device *ldev = lcrtc->ldev;\n\n\tlsdc_ureg32_clr(ldev, LSDC_INT_REG, INT_CRTC1_VSYNC_EN);\n}\n\nstatic void lsdc_crtc0_flip(struct lsdc_crtc *lcrtc)\n{\n\tstruct lsdc_device *ldev = lcrtc->ldev;\n\n\tlsdc_ureg32_set(ldev, LSDC_CRTC0_CFG_REG, CFG_PAGE_FLIP);\n}\n\nstatic void lsdc_crtc1_flip(struct lsdc_crtc *lcrtc)\n{\n\tstruct lsdc_device *ldev = lcrtc->ldev;\n\n\tlsdc_ureg32_set(ldev, LSDC_CRTC1_CFG_REG, CFG_PAGE_FLIP);\n}\n\n \n\nstatic void lsdc_crtc0_clone(struct lsdc_crtc *lcrtc)\n{\n\tstruct lsdc_device *ldev = lcrtc->ldev;\n\n\tlsdc_ureg32_set(ldev, LSDC_CRTC0_CFG_REG, CFG_HW_CLONE);\n}\n\nstatic void lsdc_crtc1_clone(struct lsdc_crtc *lcrtc)\n{\n\tstruct lsdc_device *ldev = lcrtc->ldev;\n\n\tlsdc_ureg32_set(ldev, LSDC_CRTC1_CFG_REG, CFG_HW_CLONE);\n}\n\nstatic void lsdc_crtc0_set_mode(struct lsdc_crtc *lcrtc,\n\t\t\t\tconst struct drm_display_mode *mode)\n{\n\tstruct lsdc_device *ldev = lcrtc->ldev;\n\n\tlsdc_wreg32(ldev, LSDC_CRTC0_HDISPLAY_REG,\n\t\t    (mode->crtc_htotal << 16) | mode->crtc_hdisplay);\n\n\tlsdc_wreg32(ldev, LSDC_CRTC0_VDISPLAY_REG,\n\t\t    (mode->crtc_vtotal << 16) | mode->crtc_vdisplay);\n\n\tlsdc_wreg32(ldev, LSDC_CRTC0_HSYNC_REG,\n\t\t    (mode->crtc_hsync_end << 16) | mode->crtc_hsync_start | HSYNC_EN);\n\n\tlsdc_wreg32(ldev, LSDC_CRTC0_VSYNC_REG,\n\t\t    (mode->crtc_vsync_end << 16) | mode->crtc_vsync_start | VSYNC_EN);\n}\n\nstatic void lsdc_crtc1_set_mode(struct lsdc_crtc *lcrtc,\n\t\t\t\tconst struct drm_display_mode *mode)\n{\n\tstruct lsdc_device *ldev = lcrtc->ldev;\n\n\tlsdc_wreg32(ldev, LSDC_CRTC1_HDISPLAY_REG,\n\t\t    (mode->crtc_htotal << 16) | mode->crtc_hdisplay);\n\n\tlsdc_wreg32(ldev, LSDC_CRTC1_VDISPLAY_REG,\n\t\t    (mode->crtc_vtotal << 16) | mode->crtc_vdisplay);\n\n\tlsdc_wreg32(ldev, LSDC_CRTC1_HSYNC_REG,\n\t\t    (mode->crtc_hsync_end << 16) | mode->crtc_hsync_start | HSYNC_EN);\n\n\tlsdc_wreg32(ldev, LSDC_CRTC1_VSYNC_REG,\n\t\t    (mode->crtc_vsync_end << 16) | mode->crtc_vsync_start | VSYNC_EN);\n}\n\n \n\nstatic void lsdc_crtc0_reset(struct lsdc_crtc *lcrtc)\n{\n\tstruct lsdc_device *ldev = lcrtc->ldev;\n\n\tlsdc_wreg32(ldev, LSDC_CRTC0_CFG_REG, CFG_RESET_N | LSDC_PF_XRGB8888);\n}\n\nstatic void lsdc_crtc1_reset(struct lsdc_crtc *lcrtc)\n{\n\tstruct lsdc_device *ldev = lcrtc->ldev;\n\n\tlsdc_wreg32(ldev, LSDC_CRTC1_CFG_REG, CFG_RESET_N | LSDC_PF_XRGB8888);\n}\n\nstatic const struct lsdc_crtc_hw_ops ls7a1000_crtc_hw_ops[2] = {\n\t{\n\t\t.enable = lsdc_crtc0_enable,\n\t\t.disable = lsdc_crtc0_disable,\n\t\t.enable_vblank = lsdc_crtc0_enable_vblank,\n\t\t.disable_vblank = lsdc_crtc0_disable_vblank,\n\t\t.flip = lsdc_crtc0_flip,\n\t\t.clone = lsdc_crtc0_clone,\n\t\t.set_mode = lsdc_crtc0_set_mode,\n\t\t.get_scan_pos = lsdc_crtc0_scan_pos,\n\t\t.soft_reset = lsdc_crtc0_soft_reset,\n\t\t.reset = lsdc_crtc0_reset,\n\t},\n\t{\n\t\t.enable = lsdc_crtc1_enable,\n\t\t.disable = lsdc_crtc1_disable,\n\t\t.enable_vblank = lsdc_crtc1_enable_vblank,\n\t\t.disable_vblank = lsdc_crtc1_disable_vblank,\n\t\t.flip = lsdc_crtc1_flip,\n\t\t.clone = lsdc_crtc1_clone,\n\t\t.set_mode = lsdc_crtc1_set_mode,\n\t\t.get_scan_pos = lsdc_crtc1_scan_pos,\n\t\t.soft_reset = lsdc_crtc1_soft_reset,\n\t\t.reset = lsdc_crtc1_reset,\n\t},\n};\n\n \n\nstatic u32 lsdc_crtc0_get_vblank_count(struct lsdc_crtc *lcrtc)\n{\n\tstruct lsdc_device *ldev = lcrtc->ldev;\n\n\treturn lsdc_rreg32(ldev, LSDC_CRTC0_VSYNC_COUNTER_REG);\n}\n\nstatic u32 lsdc_crtc1_get_vblank_count(struct lsdc_crtc *lcrtc)\n{\n\tstruct lsdc_device *ldev = lcrtc->ldev;\n\n\treturn lsdc_rreg32(ldev, LSDC_CRTC1_VSYNC_COUNTER_REG);\n}\n\n \n\nstatic void lsdc_crtc0_set_dma_step(struct lsdc_crtc *lcrtc,\n\t\t\t\t    enum lsdc_dma_steps dma_step)\n{\n\tstruct lsdc_device *ldev = lcrtc->ldev;\n\tu32 val = lsdc_rreg32(ldev, LSDC_CRTC0_CFG_REG);\n\n\tval &= ~CFG_DMA_STEP_MASK;\n\tval |= dma_step << CFG_DMA_STEP_SHIFT;\n\n\tlsdc_wreg32(ldev, LSDC_CRTC0_CFG_REG, val);\n}\n\nstatic void lsdc_crtc1_set_dma_step(struct lsdc_crtc *lcrtc,\n\t\t\t\t    enum lsdc_dma_steps dma_step)\n{\n\tstruct lsdc_device *ldev = lcrtc->ldev;\n\tu32 val = lsdc_rreg32(ldev, LSDC_CRTC1_CFG_REG);\n\n\tval &= ~CFG_DMA_STEP_MASK;\n\tval |= dma_step << CFG_DMA_STEP_SHIFT;\n\n\tlsdc_wreg32(ldev, LSDC_CRTC1_CFG_REG, val);\n}\n\nstatic const struct lsdc_crtc_hw_ops ls7a2000_crtc_hw_ops[2] = {\n\t{\n\t\t.enable = lsdc_crtc0_enable,\n\t\t.disable = lsdc_crtc0_disable,\n\t\t.enable_vblank = lsdc_crtc0_enable_vblank,\n\t\t.disable_vblank = lsdc_crtc0_disable_vblank,\n\t\t.flip = lsdc_crtc0_flip,\n\t\t.clone = lsdc_crtc0_clone,\n\t\t.set_mode = lsdc_crtc0_set_mode,\n\t\t.soft_reset = lsdc_crtc0_soft_reset,\n\t\t.get_scan_pos = lsdc_crtc0_scan_pos,\n\t\t.set_dma_step = lsdc_crtc0_set_dma_step,\n\t\t.get_vblank_counter = lsdc_crtc0_get_vblank_count,\n\t\t.reset = lsdc_crtc0_reset,\n\t},\n\t{\n\t\t.enable = lsdc_crtc1_enable,\n\t\t.disable = lsdc_crtc1_disable,\n\t\t.enable_vblank = lsdc_crtc1_enable_vblank,\n\t\t.disable_vblank = lsdc_crtc1_disable_vblank,\n\t\t.flip = lsdc_crtc1_flip,\n\t\t.clone = lsdc_crtc1_clone,\n\t\t.set_mode = lsdc_crtc1_set_mode,\n\t\t.get_scan_pos = lsdc_crtc1_scan_pos,\n\t\t.soft_reset = lsdc_crtc1_soft_reset,\n\t\t.set_dma_step = lsdc_crtc1_set_dma_step,\n\t\t.get_vblank_counter = lsdc_crtc1_get_vblank_count,\n\t\t.reset = lsdc_crtc1_reset,\n\t},\n};\n\nstatic void lsdc_crtc_reset(struct drm_crtc *crtc)\n{\n\tstruct lsdc_crtc *lcrtc = to_lsdc_crtc(crtc);\n\tconst struct lsdc_crtc_hw_ops *ops = lcrtc->hw_ops;\n\tstruct lsdc_crtc_state *priv_crtc_state;\n\n\tif (crtc->state)\n\t\tcrtc->funcs->atomic_destroy_state(crtc, crtc->state);\n\n\tpriv_crtc_state = kzalloc(sizeof(*priv_crtc_state), GFP_KERNEL);\n\n\tif (!priv_crtc_state)\n\t\t__drm_atomic_helper_crtc_reset(crtc, NULL);\n\telse\n\t\t__drm_atomic_helper_crtc_reset(crtc, &priv_crtc_state->base);\n\n\t \n\tops->reset(lcrtc);\n}\n\nstatic void lsdc_crtc_atomic_destroy_state(struct drm_crtc *crtc,\n\t\t\t\t\t   struct drm_crtc_state *state)\n{\n\tstruct lsdc_crtc_state *priv_state = to_lsdc_crtc_state(state);\n\n\t__drm_atomic_helper_crtc_destroy_state(&priv_state->base);\n\n\tkfree(priv_state);\n}\n\nstatic struct drm_crtc_state *\nlsdc_crtc_atomic_duplicate_state(struct drm_crtc *crtc)\n{\n\tstruct lsdc_crtc_state *new_priv_state;\n\tstruct lsdc_crtc_state *old_priv_state;\n\n\tnew_priv_state = kzalloc(sizeof(*new_priv_state), GFP_KERNEL);\n\tif (!new_priv_state)\n\t\treturn NULL;\n\n\t__drm_atomic_helper_crtc_duplicate_state(crtc, &new_priv_state->base);\n\n\told_priv_state = to_lsdc_crtc_state(crtc->state);\n\n\tmemcpy(&new_priv_state->pparms, &old_priv_state->pparms,\n\t       sizeof(new_priv_state->pparms));\n\n\treturn &new_priv_state->base;\n}\n\nstatic u32 lsdc_crtc_get_vblank_counter(struct drm_crtc *crtc)\n{\n\tstruct lsdc_crtc *lcrtc = to_lsdc_crtc(crtc);\n\n\t \n\treturn lcrtc->hw_ops->get_vblank_counter(lcrtc);\n}\n\nstatic int lsdc_crtc_enable_vblank(struct drm_crtc *crtc)\n{\n\tstruct lsdc_crtc *lcrtc = to_lsdc_crtc(crtc);\n\n\tif (!lcrtc->has_vblank)\n\t\treturn -EINVAL;\n\n\tlcrtc->hw_ops->enable_vblank(lcrtc);\n\n\treturn 0;\n}\n\nstatic void lsdc_crtc_disable_vblank(struct drm_crtc *crtc)\n{\n\tstruct lsdc_crtc *lcrtc = to_lsdc_crtc(crtc);\n\n\tif (!lcrtc->has_vblank)\n\t\treturn;\n\n\tlcrtc->hw_ops->disable_vblank(lcrtc);\n}\n\n \n\n#define REG_DEF(reg) { \\\n\t.name = __stringify_1(LSDC_##reg##_REG), \\\n\t.offset = LSDC_##reg##_REG, \\\n}\n\nstatic const struct lsdc_reg32 lsdc_crtc_regs_array[2][21] = {\n\t[0] = {\n\t\tREG_DEF(CRTC0_CFG),\n\t\tREG_DEF(CRTC0_FB_ORIGIN),\n\t\tREG_DEF(CRTC0_DVO_CONF),\n\t\tREG_DEF(CRTC0_HDISPLAY),\n\t\tREG_DEF(CRTC0_HSYNC),\n\t\tREG_DEF(CRTC0_VDISPLAY),\n\t\tREG_DEF(CRTC0_VSYNC),\n\t\tREG_DEF(CRTC0_GAMMA_INDEX),\n\t\tREG_DEF(CRTC0_GAMMA_DATA),\n\t\tREG_DEF(CRTC0_SYNC_DEVIATION),\n\t\tREG_DEF(CRTC0_VSYNC_COUNTER),\n\t\tREG_DEF(CRTC0_SCAN_POS),\n\t\tREG_DEF(CRTC0_STRIDE),\n\t\tREG_DEF(CRTC0_FB1_ADDR_HI),\n\t\tREG_DEF(CRTC0_FB1_ADDR_LO),\n\t\tREG_DEF(CRTC0_FB0_ADDR_HI),\n\t\tREG_DEF(CRTC0_FB0_ADDR_LO),\n\t\tREG_DEF(CURSOR0_CFG),\n\t\tREG_DEF(CURSOR0_POSITION),\n\t\tREG_DEF(CURSOR0_BG_COLOR),\n\t\tREG_DEF(CURSOR0_FG_COLOR),\n\t},\n\t[1] = {\n\t\tREG_DEF(CRTC1_CFG),\n\t\tREG_DEF(CRTC1_FB_ORIGIN),\n\t\tREG_DEF(CRTC1_DVO_CONF),\n\t\tREG_DEF(CRTC1_HDISPLAY),\n\t\tREG_DEF(CRTC1_HSYNC),\n\t\tREG_DEF(CRTC1_VDISPLAY),\n\t\tREG_DEF(CRTC1_VSYNC),\n\t\tREG_DEF(CRTC1_GAMMA_INDEX),\n\t\tREG_DEF(CRTC1_GAMMA_DATA),\n\t\tREG_DEF(CRTC1_SYNC_DEVIATION),\n\t\tREG_DEF(CRTC1_VSYNC_COUNTER),\n\t\tREG_DEF(CRTC1_SCAN_POS),\n\t\tREG_DEF(CRTC1_STRIDE),\n\t\tREG_DEF(CRTC1_FB1_ADDR_HI),\n\t\tREG_DEF(CRTC1_FB1_ADDR_LO),\n\t\tREG_DEF(CRTC1_FB0_ADDR_HI),\n\t\tREG_DEF(CRTC1_FB0_ADDR_LO),\n\t\tREG_DEF(CURSOR1_CFG),\n\t\tREG_DEF(CURSOR1_POSITION),\n\t\tREG_DEF(CURSOR1_BG_COLOR),\n\t\tREG_DEF(CURSOR1_FG_COLOR),\n\t},\n};\n\nstatic int lsdc_crtc_show_regs(struct seq_file *m, void *arg)\n{\n\tstruct drm_info_node *node = (struct drm_info_node *)m->private;\n\tstruct lsdc_crtc *lcrtc = (struct lsdc_crtc *)node->info_ent->data;\n\tstruct lsdc_device *ldev = lcrtc->ldev;\n\tunsigned int i;\n\n\tfor (i = 0; i < lcrtc->nreg; i++) {\n\t\tconst struct lsdc_reg32 *preg = &lcrtc->preg[i];\n\t\tu32 offset = preg->offset;\n\n\t\tseq_printf(m, \"%s (0x%04x): 0x%08x\\n\",\n\t\t\t   preg->name, offset, lsdc_rreg32(ldev, offset));\n\t}\n\n\treturn 0;\n}\n\nstatic int lsdc_crtc_show_scan_position(struct seq_file *m, void *arg)\n{\n\tstruct drm_info_node *node = (struct drm_info_node *)m->private;\n\tstruct lsdc_crtc *lcrtc = (struct lsdc_crtc *)node->info_ent->data;\n\tint x, y;\n\n\tlcrtc->hw_ops->get_scan_pos(lcrtc, &x, &y);\n\tseq_printf(m, \"Scanout position: x: %08u, y: %08u\\n\", x, y);\n\n\treturn 0;\n}\n\nstatic int lsdc_crtc_show_vblank_counter(struct seq_file *m, void *arg)\n{\n\tstruct drm_info_node *node = (struct drm_info_node *)m->private;\n\tstruct lsdc_crtc *lcrtc = (struct lsdc_crtc *)node->info_ent->data;\n\n\tif (lcrtc->hw_ops->get_vblank_counter)\n\t\tseq_printf(m, \"%s vblank counter: %08u\\n\\n\", lcrtc->base.name,\n\t\t\t   lcrtc->hw_ops->get_vblank_counter(lcrtc));\n\n\treturn 0;\n}\n\nstatic int lsdc_pixpll_show_clock(struct seq_file *m, void *arg)\n{\n\tstruct drm_info_node *node = (struct drm_info_node *)m->private;\n\tstruct lsdc_crtc *lcrtc = (struct lsdc_crtc *)node->info_ent->data;\n\tstruct lsdc_pixpll *pixpll = &lcrtc->pixpll;\n\tconst struct lsdc_pixpll_funcs *funcs = pixpll->funcs;\n\tstruct drm_crtc *crtc = &lcrtc->base;\n\tstruct drm_display_mode *mode = &crtc->state->mode;\n\tstruct drm_printer printer = drm_seq_file_printer(m);\n\tunsigned int out_khz;\n\n\tout_khz = funcs->get_rate(pixpll);\n\n\tseq_printf(m, \"%s: %dx%d@%d\\n\", crtc->name,\n\t\t   mode->hdisplay, mode->vdisplay, drm_mode_vrefresh(mode));\n\n\tseq_printf(m, \"Pixel clock required: %d kHz\\n\", mode->clock);\n\tseq_printf(m, \"Actual frequency output: %u kHz\\n\", out_khz);\n\tseq_printf(m, \"Diff: %d kHz\\n\", out_khz - mode->clock);\n\n\tfuncs->print(pixpll, &printer);\n\n\treturn 0;\n}\n\nstatic struct drm_info_list lsdc_crtc_debugfs_list[2][4] = {\n\t[0] = {\n\t\t{ \"regs\", lsdc_crtc_show_regs, 0, NULL },\n\t\t{ \"pixclk\", lsdc_pixpll_show_clock, 0, NULL },\n\t\t{ \"scanpos\", lsdc_crtc_show_scan_position, 0, NULL },\n\t\t{ \"vblanks\", lsdc_crtc_show_vblank_counter, 0, NULL },\n\t},\n\t[1] = {\n\t\t{ \"regs\", lsdc_crtc_show_regs, 0, NULL },\n\t\t{ \"pixclk\", lsdc_pixpll_show_clock, 0, NULL },\n\t\t{ \"scanpos\", lsdc_crtc_show_scan_position, 0, NULL },\n\t\t{ \"vblanks\", lsdc_crtc_show_vblank_counter, 0, NULL },\n\t},\n};\n\n \n\nstatic int lsdc_crtc_man_op_show(struct seq_file *m, void *data)\n{\n\tseq_puts(m, \"soft_reset: soft reset this CRTC\\n\");\n\tseq_puts(m, \"enable: enable this CRTC\\n\");\n\tseq_puts(m, \"disable: disable this CRTC\\n\");\n\tseq_puts(m, \"flip: trigger the page flip\\n\");\n\tseq_puts(m, \"clone: clone the another crtc with hardware logic\\n\");\n\n\treturn 0;\n}\n\nstatic int lsdc_crtc_man_op_open(struct inode *inode, struct file *file)\n{\n\tstruct drm_crtc *crtc = inode->i_private;\n\n\treturn single_open(file, lsdc_crtc_man_op_show, crtc);\n}\n\nstatic ssize_t lsdc_crtc_man_op_write(struct file *file,\n\t\t\t\t      const char __user *ubuf,\n\t\t\t\t      size_t len,\n\t\t\t\t      loff_t *offp)\n{\n\tstruct seq_file *m = file->private_data;\n\tstruct lsdc_crtc *lcrtc = m->private;\n\tconst struct lsdc_crtc_hw_ops *ops = lcrtc->hw_ops;\n\tchar buf[16];\n\n\tif (len > sizeof(buf) - 1)\n\t\treturn -EINVAL;\n\n\tif (copy_from_user(buf, ubuf, len))\n\t\treturn -EFAULT;\n\n\tbuf[len] = '\\0';\n\n\tif (sysfs_streq(buf, \"soft_reset\"))\n\t\tops->soft_reset(lcrtc);\n\telse if (sysfs_streq(buf, \"enable\"))\n\t\tops->enable(lcrtc);\n\telse if (sysfs_streq(buf, \"disable\"))\n\t\tops->disable(lcrtc);\n\telse if (sysfs_streq(buf, \"flip\"))\n\t\tops->flip(lcrtc);\n\telse if (sysfs_streq(buf, \"clone\"))\n\t\tops->clone(lcrtc);\n\n\treturn len;\n}\n\nstatic const struct file_operations lsdc_crtc_man_op_fops = {\n\t.owner = THIS_MODULE,\n\t.open = lsdc_crtc_man_op_open,\n\t.read = seq_read,\n\t.llseek = seq_lseek,\n\t.release = single_release,\n\t.write = lsdc_crtc_man_op_write,\n};\n\nstatic int lsdc_crtc_late_register(struct drm_crtc *crtc)\n{\n\tstruct lsdc_display_pipe *dispipe = crtc_to_display_pipe(crtc);\n\tstruct lsdc_crtc *lcrtc = to_lsdc_crtc(crtc);\n\tstruct drm_minor *minor = crtc->dev->primary;\n\tunsigned int index = dispipe->index;\n\tunsigned int i;\n\n\tlcrtc->preg = lsdc_crtc_regs_array[index];\n\tlcrtc->nreg = ARRAY_SIZE(lsdc_crtc_regs_array[index]);\n\tlcrtc->p_info_list = lsdc_crtc_debugfs_list[index];\n\tlcrtc->n_info_list = ARRAY_SIZE(lsdc_crtc_debugfs_list[index]);\n\n\tfor (i = 0; i < lcrtc->n_info_list; ++i)\n\t\tlcrtc->p_info_list[i].data = lcrtc;\n\n\tdrm_debugfs_create_files(lcrtc->p_info_list, lcrtc->n_info_list,\n\t\t\t\t crtc->debugfs_entry, minor);\n\n\t \n\tdebugfs_create_file(\"ops\", 0644, crtc->debugfs_entry, lcrtc,\n\t\t\t    &lsdc_crtc_man_op_fops);\n\n\treturn 0;\n}\n\nstatic void lsdc_crtc_atomic_print_state(struct drm_printer *p,\n\t\t\t\t\t const struct drm_crtc_state *state)\n{\n\tconst struct lsdc_crtc_state *priv_state;\n\tconst struct lsdc_pixpll_parms *pparms;\n\n\tpriv_state = container_of_const(state, struct lsdc_crtc_state, base);\n\tpparms = &priv_state->pparms;\n\n\tdrm_printf(p, \"\\tInput clock divider = %u\\n\", pparms->div_ref);\n\tdrm_printf(p, \"\\tMedium clock multiplier = %u\\n\", pparms->loopc);\n\tdrm_printf(p, \"\\tOutput clock divider = %u\\n\", pparms->div_out);\n}\n\nstatic const struct drm_crtc_funcs ls7a1000_crtc_funcs = {\n\t.reset = lsdc_crtc_reset,\n\t.destroy = drm_crtc_cleanup,\n\t.set_config = drm_atomic_helper_set_config,\n\t.page_flip = drm_atomic_helper_page_flip,\n\t.atomic_duplicate_state = lsdc_crtc_atomic_duplicate_state,\n\t.atomic_destroy_state = lsdc_crtc_atomic_destroy_state,\n\t.late_register = lsdc_crtc_late_register,\n\t.enable_vblank = lsdc_crtc_enable_vblank,\n\t.disable_vblank = lsdc_crtc_disable_vblank,\n\t.get_vblank_timestamp = drm_crtc_vblank_helper_get_vblank_timestamp,\n\t.atomic_print_state = lsdc_crtc_atomic_print_state,\n};\n\nstatic const struct drm_crtc_funcs ls7a2000_crtc_funcs = {\n\t.reset = lsdc_crtc_reset,\n\t.destroy = drm_crtc_cleanup,\n\t.set_config = drm_atomic_helper_set_config,\n\t.page_flip = drm_atomic_helper_page_flip,\n\t.atomic_duplicate_state = lsdc_crtc_atomic_duplicate_state,\n\t.atomic_destroy_state = lsdc_crtc_atomic_destroy_state,\n\t.late_register = lsdc_crtc_late_register,\n\t.get_vblank_counter = lsdc_crtc_get_vblank_counter,\n\t.enable_vblank = lsdc_crtc_enable_vblank,\n\t.disable_vblank = lsdc_crtc_disable_vblank,\n\t.get_vblank_timestamp = drm_crtc_vblank_helper_get_vblank_timestamp,\n\t.atomic_print_state = lsdc_crtc_atomic_print_state,\n};\n\nstatic enum drm_mode_status\nlsdc_crtc_mode_valid(struct drm_crtc *crtc, const struct drm_display_mode *mode)\n{\n\tstruct drm_device *ddev = crtc->dev;\n\tstruct lsdc_device *ldev = to_lsdc(ddev);\n\tconst struct lsdc_desc *descp = ldev->descp;\n\tunsigned int pitch;\n\n\tif (mode->hdisplay > descp->max_width)\n\t\treturn MODE_BAD_HVALUE;\n\n\tif (mode->vdisplay > descp->max_height)\n\t\treturn MODE_BAD_VVALUE;\n\n\tif (mode->clock > descp->max_pixel_clk) {\n\t\tdrm_dbg_kms(ddev, \"mode %dx%d, pixel clock=%d is too high\\n\",\n\t\t\t    mode->hdisplay, mode->vdisplay, mode->clock);\n\t\treturn MODE_CLOCK_HIGH;\n\t}\n\n\t \n\tpitch = mode->hdisplay * 4;\n\n\tif (pitch % descp->pitch_align) {\n\t\tdrm_dbg_kms(ddev, \"align to %u bytes is required: %u\\n\",\n\t\t\t    descp->pitch_align, pitch);\n\t\treturn MODE_BAD_WIDTH;\n\t}\n\n\treturn MODE_OK;\n}\n\nstatic int lsdc_pixpll_atomic_check(struct drm_crtc *crtc,\n\t\t\t\t    struct drm_crtc_state *state)\n{\n\tstruct lsdc_crtc *lcrtc = to_lsdc_crtc(crtc);\n\tstruct lsdc_pixpll *pixpll = &lcrtc->pixpll;\n\tconst struct lsdc_pixpll_funcs *pfuncs = pixpll->funcs;\n\tstruct lsdc_crtc_state *priv_state = to_lsdc_crtc_state(state);\n\tunsigned int clock = state->mode.clock;\n\tint ret;\n\n\tret = pfuncs->compute(pixpll, clock, &priv_state->pparms);\n\tif (ret) {\n\t\tdrm_warn(crtc->dev, \"Failed to find PLL params for %ukHz\\n\",\n\t\t\t clock);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int lsdc_crtc_helper_atomic_check(struct drm_crtc *crtc,\n\t\t\t\t\t struct drm_atomic_state *state)\n{\n\tstruct drm_crtc_state *crtc_state = drm_atomic_get_new_crtc_state(state, crtc);\n\n\tif (!crtc_state->enable)\n\t\treturn 0;\n\n\treturn lsdc_pixpll_atomic_check(crtc, crtc_state);\n}\n\nstatic void lsdc_crtc_mode_set_nofb(struct drm_crtc *crtc)\n{\n\tstruct lsdc_crtc *lcrtc = to_lsdc_crtc(crtc);\n\tconst struct lsdc_crtc_hw_ops *crtc_hw_ops = lcrtc->hw_ops;\n\tstruct lsdc_pixpll *pixpll = &lcrtc->pixpll;\n\tconst struct lsdc_pixpll_funcs *pixpll_funcs = pixpll->funcs;\n\tstruct drm_crtc_state *state = crtc->state;\n\tstruct drm_display_mode *mode = &state->mode;\n\tstruct lsdc_crtc_state *priv_state = to_lsdc_crtc_state(state);\n\n\tpixpll_funcs->update(pixpll, &priv_state->pparms);\n\n\tif (crtc_hw_ops->set_dma_step) {\n\t\tunsigned int width_in_bytes = mode->hdisplay * 4;\n\t\tenum lsdc_dma_steps dma_step;\n\n\t\t \n\t\tif (width_in_bytes % 256 == 0)\n\t\t\tdma_step = LSDC_DMA_STEP_256_BYTES;\n\t\telse if (width_in_bytes % 128 == 0)\n\t\t\tdma_step = LSDC_DMA_STEP_128_BYTES;\n\t\telse if (width_in_bytes % 64 == 0)\n\t\t\tdma_step = LSDC_DMA_STEP_64_BYTES;\n\t\telse   \n\t\t\tdma_step = LSDC_DMA_STEP_32_BYTES;\n\n\t\tcrtc_hw_ops->set_dma_step(lcrtc, dma_step);\n\t}\n\n\tcrtc_hw_ops->set_mode(lcrtc, mode);\n}\n\nstatic void lsdc_crtc_send_vblank(struct drm_crtc *crtc)\n{\n\tstruct drm_device *ddev = crtc->dev;\n\tunsigned long flags;\n\n\tif (!crtc->state || !crtc->state->event)\n\t\treturn;\n\n\tdrm_dbg(ddev, \"Send vblank manually\\n\");\n\n\tspin_lock_irqsave(&ddev->event_lock, flags);\n\tdrm_crtc_send_vblank_event(crtc, crtc->state->event);\n\tcrtc->state->event = NULL;\n\tspin_unlock_irqrestore(&ddev->event_lock, flags);\n}\n\nstatic void lsdc_crtc_atomic_enable(struct drm_crtc *crtc,\n\t\t\t\t    struct drm_atomic_state *state)\n{\n\tstruct lsdc_crtc *lcrtc = to_lsdc_crtc(crtc);\n\n\tif (lcrtc->has_vblank)\n\t\tdrm_crtc_vblank_on(crtc);\n\n\tlcrtc->hw_ops->enable(lcrtc);\n}\n\nstatic void lsdc_crtc_atomic_disable(struct drm_crtc *crtc,\n\t\t\t\t     struct drm_atomic_state *state)\n{\n\tstruct lsdc_crtc *lcrtc = to_lsdc_crtc(crtc);\n\n\tif (lcrtc->has_vblank)\n\t\tdrm_crtc_vblank_off(crtc);\n\n\tlcrtc->hw_ops->disable(lcrtc);\n\n\t \n\tlsdc_crtc_send_vblank(crtc);\n}\n\nstatic void lsdc_crtc_atomic_flush(struct drm_crtc *crtc,\n\t\t\t\t   struct drm_atomic_state *state)\n{\n\tspin_lock_irq(&crtc->dev->event_lock);\n\tif (crtc->state->event) {\n\t\tif (drm_crtc_vblank_get(crtc) == 0)\n\t\t\tdrm_crtc_arm_vblank_event(crtc, crtc->state->event);\n\t\telse\n\t\t\tdrm_crtc_send_vblank_event(crtc, crtc->state->event);\n\t\tcrtc->state->event = NULL;\n\t}\n\tspin_unlock_irq(&crtc->dev->event_lock);\n}\n\nstatic bool lsdc_crtc_get_scanout_position(struct drm_crtc *crtc,\n\t\t\t\t\t   bool in_vblank_irq,\n\t\t\t\t\t   int *vpos,\n\t\t\t\t\t   int *hpos,\n\t\t\t\t\t   ktime_t *stime,\n\t\t\t\t\t   ktime_t *etime,\n\t\t\t\t\t   const struct drm_display_mode *mode)\n{\n\tstruct lsdc_crtc *lcrtc = to_lsdc_crtc(crtc);\n\tconst struct lsdc_crtc_hw_ops *ops = lcrtc->hw_ops;\n\tint vsw, vbp, vactive_start, vactive_end, vfp_end;\n\tint x, y;\n\n\tvsw = mode->crtc_vsync_end - mode->crtc_vsync_start;\n\tvbp = mode->crtc_vtotal - mode->crtc_vsync_end;\n\n\tvactive_start = vsw + vbp + 1;\n\tvactive_end = vactive_start + mode->crtc_vdisplay;\n\n\t \n\tvfp_end = mode->crtc_vtotal;\n\n\tif (stime)\n\t\t*stime = ktime_get();\n\n\tops->get_scan_pos(lcrtc, &x, &y);\n\n\tif (y > vactive_end)\n\t\ty = y - vfp_end - vactive_start;\n\telse\n\t\ty -= vactive_start;\n\n\t*vpos = y;\n\t*hpos = 0;\n\n\tif (etime)\n\t\t*etime = ktime_get();\n\n\treturn true;\n}\n\nstatic const struct drm_crtc_helper_funcs lsdc_crtc_helper_funcs = {\n\t.mode_valid = lsdc_crtc_mode_valid,\n\t.mode_set_nofb = lsdc_crtc_mode_set_nofb,\n\t.atomic_enable = lsdc_crtc_atomic_enable,\n\t.atomic_disable = lsdc_crtc_atomic_disable,\n\t.atomic_check = lsdc_crtc_helper_atomic_check,\n\t.atomic_flush = lsdc_crtc_atomic_flush,\n\t.get_scanout_position = lsdc_crtc_get_scanout_position,\n};\n\nint ls7a1000_crtc_init(struct drm_device *ddev,\n\t\t       struct drm_crtc *crtc,\n\t\t       struct drm_plane *primary,\n\t\t       struct drm_plane *cursor,\n\t\t       unsigned int index,\n\t\t       bool has_vblank)\n{\n\tstruct lsdc_crtc *lcrtc = to_lsdc_crtc(crtc);\n\tint ret;\n\n\tret = lsdc_pixpll_init(&lcrtc->pixpll, ddev, index);\n\tif (ret) {\n\t\tdrm_err(ddev, \"pixel pll init failed: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tlcrtc->ldev = to_lsdc(ddev);\n\tlcrtc->has_vblank = has_vblank;\n\tlcrtc->hw_ops = &ls7a1000_crtc_hw_ops[index];\n\n\tret = drm_crtc_init_with_planes(ddev, crtc, primary, cursor,\n\t\t\t\t\t&ls7a1000_crtc_funcs,\n\t\t\t\t\t\"LS-CRTC-%d\", index);\n\tif (ret) {\n\t\tdrm_err(ddev, \"crtc init with planes failed: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tdrm_crtc_helper_add(crtc, &lsdc_crtc_helper_funcs);\n\n\tret = drm_mode_crtc_set_gamma_size(crtc, 256);\n\tif (ret)\n\t\treturn ret;\n\n\tdrm_crtc_enable_color_mgmt(crtc, 0, false, 256);\n\n\treturn 0;\n}\n\nint ls7a2000_crtc_init(struct drm_device *ddev,\n\t\t       struct drm_crtc *crtc,\n\t\t       struct drm_plane *primary,\n\t\t       struct drm_plane *cursor,\n\t\t       unsigned int index,\n\t\t       bool has_vblank)\n{\n\tstruct lsdc_crtc *lcrtc = to_lsdc_crtc(crtc);\n\tint ret;\n\n\tret = lsdc_pixpll_init(&lcrtc->pixpll, ddev, index);\n\tif (ret) {\n\t\tdrm_err(ddev, \"crtc init with pll failed: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tlcrtc->ldev = to_lsdc(ddev);\n\tlcrtc->has_vblank = has_vblank;\n\tlcrtc->hw_ops = &ls7a2000_crtc_hw_ops[index];\n\n\tret = drm_crtc_init_with_planes(ddev, crtc, primary, cursor,\n\t\t\t\t\t&ls7a2000_crtc_funcs,\n\t\t\t\t\t\"LS-CRTC-%u\", index);\n\tif (ret) {\n\t\tdrm_err(ddev, \"crtc init with planes failed: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tdrm_crtc_helper_add(crtc, &lsdc_crtc_helper_funcs);\n\n\tret = drm_mode_crtc_set_gamma_size(crtc, 256);\n\tif (ret)\n\t\treturn ret;\n\n\tdrm_crtc_enable_color_mgmt(crtc, 0, false, 256);\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}