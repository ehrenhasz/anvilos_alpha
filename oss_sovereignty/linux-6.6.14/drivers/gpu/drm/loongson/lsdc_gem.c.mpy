{
  "module_name": "lsdc_gem.c",
  "hash_id": "47a87685c76085a7bbc1e7bd99ebb5354b496a6698f033259622e5748f544edd",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/loongson/lsdc_gem.c",
  "human_readable_source": "\n \n\n#include <linux/dma-buf.h>\n\n#include <drm/drm_debugfs.h>\n#include <drm/drm_file.h>\n#include <drm/drm_gem.h>\n#include <drm/drm_prime.h>\n\n#include \"lsdc_drv.h\"\n#include \"lsdc_gem.h\"\n#include \"lsdc_ttm.h\"\n\nstatic int lsdc_gem_prime_pin(struct drm_gem_object *obj)\n{\n\tstruct lsdc_bo *lbo = gem_to_lsdc_bo(obj);\n\tint ret;\n\n\tret = lsdc_bo_reserve(lbo);\n\tif (unlikely(ret))\n\t\treturn ret;\n\n\tret = lsdc_bo_pin(lbo, LSDC_GEM_DOMAIN_GTT, NULL);\n\tif (likely(ret == 0))\n\t\tlbo->sharing_count++;\n\n\tlsdc_bo_unreserve(lbo);\n\n\treturn ret;\n}\n\nstatic void lsdc_gem_prime_unpin(struct drm_gem_object *obj)\n{\n\tstruct lsdc_bo *lbo = gem_to_lsdc_bo(obj);\n\tint ret;\n\n\tret = lsdc_bo_reserve(lbo);\n\tif (unlikely(ret))\n\t\treturn;\n\n\tlsdc_bo_unpin(lbo);\n\tif (lbo->sharing_count)\n\t\tlbo->sharing_count--;\n\n\tlsdc_bo_unreserve(lbo);\n}\n\nstatic struct sg_table *lsdc_gem_prime_get_sg_table(struct drm_gem_object *obj)\n{\n\tstruct ttm_buffer_object *tbo = to_ttm_bo(obj);\n\tstruct ttm_tt *tt = tbo->ttm;\n\n\tif (!tt) {\n\t\tdrm_err(obj->dev, \"sharing a buffer without backing memory\\n\");\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\n\treturn drm_prime_pages_to_sg(obj->dev, tt->pages, tt->num_pages);\n}\n\nstatic void lsdc_gem_object_free(struct drm_gem_object *obj)\n{\n\tstruct ttm_buffer_object *tbo = to_ttm_bo(obj);\n\n\tif (tbo)\n\t\tttm_bo_put(tbo);\n}\n\nstatic int lsdc_gem_object_vmap(struct drm_gem_object *obj, struct iosys_map *map)\n{\n\tstruct ttm_buffer_object *tbo = to_ttm_bo(obj);\n\tstruct lsdc_bo *lbo = to_lsdc_bo(tbo);\n\tint ret;\n\n\tif (lbo->vmap_count > 0) {\n\t\t++lbo->vmap_count;\n\t\tgoto out;\n\t}\n\n\tret = lsdc_bo_pin(lbo, 0, NULL);\n\tif (unlikely(ret)) {\n\t\tdrm_err(obj->dev, \"pin %p for vmap failed\\n\", lbo);\n\t\treturn ret;\n\t}\n\n\tret = ttm_bo_vmap(tbo, &lbo->map);\n\tif (ret) {\n\t\tdrm_err(obj->dev, \"ttm bo vmap failed\\n\");\n\t\tlsdc_bo_unpin(lbo);\n\t\treturn ret;\n\t}\n\n\tlbo->vmap_count = 1;\n\nout:\n\t*map = lbo->map;\n\n\treturn 0;\n}\n\nstatic void lsdc_gem_object_vunmap(struct drm_gem_object *obj, struct iosys_map *map)\n{\n\tstruct ttm_buffer_object *tbo = to_ttm_bo(obj);\n\tstruct lsdc_bo *lbo = to_lsdc_bo(tbo);\n\n\tif (unlikely(!lbo->vmap_count)) {\n\t\tdrm_warn(obj->dev, \"%p is not mapped\\n\", lbo);\n\t\treturn;\n\t}\n\n\t--lbo->vmap_count;\n\tif (lbo->vmap_count == 0) {\n\t\tttm_bo_vunmap(tbo, &lbo->map);\n\n\t\tlsdc_bo_unpin(lbo);\n\t}\n}\n\nstatic int lsdc_gem_object_mmap(struct drm_gem_object *obj, struct vm_area_struct *vma)\n{\n\tstruct ttm_buffer_object *tbo = to_ttm_bo(obj);\n\tint ret;\n\n\tret = ttm_bo_mmap_obj(vma, tbo);\n\tif (unlikely(ret)) {\n\t\tdrm_warn(obj->dev, \"mmap %p failed\\n\", tbo);\n\t\treturn ret;\n\t}\n\n\tdrm_gem_object_put(obj);\n\n\treturn 0;\n}\n\nstatic const struct drm_gem_object_funcs lsdc_gem_object_funcs = {\n\t.free = lsdc_gem_object_free,\n\t.export = drm_gem_prime_export,\n\t.pin = lsdc_gem_prime_pin,\n\t.unpin = lsdc_gem_prime_unpin,\n\t.get_sg_table = lsdc_gem_prime_get_sg_table,\n\t.vmap = lsdc_gem_object_vmap,\n\t.vunmap = lsdc_gem_object_vunmap,\n\t.mmap = lsdc_gem_object_mmap,\n};\n\nstruct drm_gem_object *lsdc_gem_object_create(struct drm_device *ddev,\n\t\t\t\t\t      u32 domain,\n\t\t\t\t\t      size_t size,\n\t\t\t\t\t      bool kerenl,\n\t\t\t\t\t      struct sg_table *sg,\n\t\t\t\t\t      struct dma_resv *resv)\n{\n\tstruct lsdc_device *ldev = to_lsdc(ddev);\n\tstruct drm_gem_object *gobj;\n\tstruct lsdc_bo *lbo;\n\tint ret;\n\n\tlbo = lsdc_bo_create(ddev, domain, size, kerenl, sg, resv);\n\tif (IS_ERR(lbo)) {\n\t\tret = PTR_ERR(lbo);\n\t\treturn ERR_PTR(ret);\n\t}\n\n\tif (!sg) {\n\t\t \n\t\tlsdc_bo_clear(lbo);\n\t}\n\n\tgobj = &lbo->tbo.base;\n\tgobj->funcs = &lsdc_gem_object_funcs;\n\n\t \n\tmutex_lock(&ldev->gem.mutex);\n\tlist_add_tail(&lbo->list, &ldev->gem.objects);\n\tmutex_unlock(&ldev->gem.mutex);\n\n\treturn gobj;\n}\n\nstruct drm_gem_object *\nlsdc_prime_import_sg_table(struct drm_device *ddev,\n\t\t\t   struct dma_buf_attachment *attach,\n\t\t\t   struct sg_table *sg)\n{\n\tstruct dma_resv *resv = attach->dmabuf->resv;\n\tu64 size = attach->dmabuf->size;\n\tstruct drm_gem_object *gobj;\n\tstruct lsdc_bo *lbo;\n\n\tdma_resv_lock(resv, NULL);\n\tgobj = lsdc_gem_object_create(ddev, LSDC_GEM_DOMAIN_GTT, size, false,\n\t\t\t\t      sg, resv);\n\tdma_resv_unlock(resv);\n\n\tif (IS_ERR(gobj)) {\n\t\tdrm_err(ddev, \"Failed to import sg table\\n\");\n\t\treturn gobj;\n\t}\n\n\tlbo = gem_to_lsdc_bo(gobj);\n\tlbo->sharing_count = 1;\n\n\treturn gobj;\n}\n\nint lsdc_dumb_create(struct drm_file *file, struct drm_device *ddev,\n\t\t     struct drm_mode_create_dumb *args)\n{\n\tstruct lsdc_device *ldev = to_lsdc(ddev);\n\tconst struct lsdc_desc *descp = ldev->descp;\n\tu32 domain = LSDC_GEM_DOMAIN_VRAM;\n\tstruct drm_gem_object *gobj;\n\tsize_t size;\n\tu32 pitch;\n\tu32 handle;\n\tint ret;\n\n\tif (!args->width || !args->height)\n\t\treturn -EINVAL;\n\n\tif (args->bpp != 32 && args->bpp != 16)\n\t\treturn -EINVAL;\n\n\tpitch = args->width * args->bpp / 8;\n\tpitch = ALIGN(pitch, descp->pitch_align);\n\tsize = pitch * args->height;\n\tsize = ALIGN(size, PAGE_SIZE);\n\n\t \n\tif (size > ldev->vram_size / 2) {\n\t\tdrm_err(ddev, \"Requesting(%zuMiB) failed\\n\", size >> 20);\n\t\treturn -ENOMEM;\n\t}\n\n\tgobj = lsdc_gem_object_create(ddev, domain, size, false, NULL, NULL);\n\tif (IS_ERR(gobj)) {\n\t\tdrm_err(ddev, \"Failed to create gem object\\n\");\n\t\treturn PTR_ERR(gobj);\n\t}\n\n\tret = drm_gem_handle_create(file, gobj, &handle);\n\n\t \n\tdrm_gem_object_put(gobj);\n\tif (ret)\n\t\treturn ret;\n\n\targs->pitch = pitch;\n\targs->size = size;\n\targs->handle = handle;\n\n\treturn 0;\n}\n\nint lsdc_dumb_map_offset(struct drm_file *filp, struct drm_device *ddev,\n\t\t\t u32 handle, uint64_t *offset)\n{\n\tstruct drm_gem_object *gobj;\n\n\tgobj = drm_gem_object_lookup(filp, handle);\n\tif (!gobj)\n\t\treturn -ENOENT;\n\n\t*offset = drm_vma_node_offset_addr(&gobj->vma_node);\n\n\tdrm_gem_object_put(gobj);\n\n\treturn 0;\n}\n\nvoid lsdc_gem_init(struct drm_device *ddev)\n{\n\tstruct lsdc_device *ldev = to_lsdc(ddev);\n\n\tmutex_init(&ldev->gem.mutex);\n\tINIT_LIST_HEAD(&ldev->gem.objects);\n}\n\nint lsdc_show_buffer_object(struct seq_file *m, void *arg)\n{\n\tstruct drm_info_node *node = (struct drm_info_node *)m->private;\n\tstruct drm_device *ddev = node->minor->dev;\n\tstruct lsdc_device *ldev = to_lsdc(ddev);\n\tstruct lsdc_bo *lbo;\n\tunsigned int i;\n\n\tmutex_lock(&ldev->gem.mutex);\n\n\ti = 0;\n\n\tlist_for_each_entry(lbo, &ldev->gem.objects, list) {\n\t\tstruct ttm_buffer_object *tbo = &lbo->tbo;\n\t\tstruct ttm_resource *resource = tbo->resource;\n\n\t\tseq_printf(m, \"bo[%04u][%p]: size: %8zuKiB %s offset: %8llx\\n\",\n\t\t\t   i, lbo, lsdc_bo_size(lbo) >> 10,\n\t\t\t   lsdc_mem_type_to_str(resource->mem_type),\n\t\t\t   lsdc_bo_gpu_offset(lbo));\n\t\ti++;\n\t}\n\n\tmutex_unlock(&ldev->gem.mutex);\n\n\tseq_printf(m, \"Pinned BO size: VRAM: %zuKiB, GTT: %zu KiB\\n\",\n\t\t   ldev->vram_pinned_size >> 10, ldev->gtt_pinned_size >> 10);\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}