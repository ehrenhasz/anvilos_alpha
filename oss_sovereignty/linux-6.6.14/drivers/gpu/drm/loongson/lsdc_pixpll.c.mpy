{
  "module_name": "lsdc_pixpll.c",
  "hash_id": "4676850c0a812195ae3371ac1339044968220b3f73fa4ccbe407d55519d01171",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/loongson/lsdc_pixpll.c",
  "human_readable_source": "\n \n\n#include <linux/delay.h>\n\n#include <drm/drm_managed.h>\n\n#include \"lsdc_drv.h\"\n\n \n\n \nstruct lsdc_pixpll_reg {\n\t \n\tunsigned div_out       : 7;    \n\tunsigned _reserved_1_  : 14;   \n\tunsigned loopc         : 9;    \n\tunsigned _reserved_2_  : 2;    \n\n\t \n\tunsigned div_ref       : 7;    \n\tunsigned locked        : 1;    \n\tunsigned sel_out       : 1;    \n\tunsigned _reserved_3_  : 2;    \n\tunsigned set_param     : 1;    \n\tunsigned bypass        : 1;    \n\tunsigned powerdown     : 1;    \n\tunsigned _reserved_4_  : 18;   \n};\n\nunion lsdc_pixpll_reg_bitmap {\n\tstruct lsdc_pixpll_reg bitmap;\n\tu32 w[2];\n\tu64 d;\n};\n\nstruct clk_to_pixpll_parms_lookup_t {\n\tunsigned int clock;         \n\n\tunsigned short width;\n\tunsigned short height;\n\tunsigned short vrefresh;\n\n\t \n\tunsigned short div_out;\n\tunsigned short loopc;\n\tunsigned short div_ref;\n};\n\nstatic const struct clk_to_pixpll_parms_lookup_t pixpll_parms_table[] = {\n\t{148500, 1920, 1080, 60,  11, 49,  3},    \n\t{141750, 1920, 1080, 60,  11, 78,  5},    \n\t\t\t\t\t\t  \n\t{174500, 1920, 1080, 75,  17, 89,  3},    \n\t{181250, 2560, 1080, 75,  8,  58,  4},    \n\t{297000, 2560, 1080, 30,  8,  95,  4},    \n\t{301992, 1920, 1080, 100, 10, 151, 5},    \n\t{146250, 1680, 1050, 60,  16, 117, 5},    \n\t{135000, 1280, 1024, 75,  10, 54,  4},    \n\t{119000, 1680, 1050, 60,  20, 119, 5},    \n\t{108000, 1600, 900,  60,  15, 81,  5},    \n\t\t\t\t\t\t  \n\t\t\t\t\t\t  \n\t\t\t\t\t\t  \n\n\t{106500, 1440, 900,  60,  19, 81,  4},    \n\t{88750,  1440, 900,  60,  16, 71,  5},    \n\t{83500,  1280, 800,  60,  17, 71,  5},    \n\t{71000,  1280, 800,  60,  20, 71,  5},    \n\n\t{74250,  1280, 720,  60,  22, 49,  3},    \n\t\t\t\t\t\t  \n\n\t{78750,  1024, 768,  75,  16, 63,  5},    \n\t{75000,  1024, 768,  70,  29, 87,  4},    \n\t{65000,  1024, 768,  60,  20, 39,  3},    \n\n\t{51200,  1024, 600,  60,  25, 64,  5},    \n\n\t{57284,  832,  624,  75,  24, 55,  4},    \n\t{49500,  800,  600,  75,  40, 99,  5},    \n\t{50000,  800,  600,  72,  44, 88,  4},    \n\t{40000,  800,  600,  60,  30, 36,  3},    \n\t{36000,  800,  600,  56,  50, 72,  4},    \n\t{31500,  640,  480,  75,  40, 63,  5},    \n\t\t\t\t\t\t  \n\n\t{30240,  640,  480,  67,  62, 75,  4},    \n\t{27000,  720,  576,  50,  50, 54,  4},    \n\t{25175,  640,  480,  60,  85, 107, 5},    \n\t{25200,  640,  480,  60,  50, 63,  5},    \n\t\t\t\t\t\t  \n};\n\nstatic void lsdc_pixel_pll_free(struct drm_device *ddev, void *data)\n{\n\tstruct lsdc_pixpll *this = (struct lsdc_pixpll *)data;\n\n\tiounmap(this->mmio);\n\n\tkfree(this->priv);\n\n\tdrm_dbg(ddev, \"pixpll private data freed\\n\");\n}\n\n \nstatic int lsdc_pixel_pll_setup(struct lsdc_pixpll * const this)\n{\n\tstruct lsdc_pixpll_parms *pparms;\n\n\tthis->mmio = ioremap(this->reg_base, this->reg_size);\n\tif (!this->mmio)\n\t\treturn -ENOMEM;\n\n\tpparms = kzalloc(sizeof(*pparms), GFP_KERNEL);\n\tif (!pparms) {\n\t\tiounmap(this->mmio);\n\t\treturn -ENOMEM;\n\t}\n\n\tpparms->ref_clock = LSDC_PLL_REF_CLK_KHZ;\n\n\tthis->priv = pparms;\n\n\treturn drmm_add_action_or_reset(this->ddev, lsdc_pixel_pll_free, this);\n}\n\n \nstatic int lsdc_pixpll_find(struct lsdc_pixpll * const this,\n\t\t\t    unsigned int clock,\n\t\t\t    struct lsdc_pixpll_parms *pout)\n{\n\tunsigned int num = ARRAY_SIZE(pixpll_parms_table);\n\tconst struct clk_to_pixpll_parms_lookup_t *pt;\n\tunsigned int i;\n\n\tfor (i = 0; i < num; ++i) {\n\t\tpt = &pixpll_parms_table[i];\n\n\t\tif (clock == pt->clock) {\n\t\t\tpout->div_ref = pt->div_ref;\n\t\t\tpout->loopc   = pt->loopc;\n\t\t\tpout->div_out = pt->div_out;\n\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tdrm_dbg_kms(this->ddev, \"pixel clock %u: miss\\n\", clock);\n\n\treturn -1;\n}\n\n \nstatic int lsdc_pixel_pll_compute(struct lsdc_pixpll * const this,\n\t\t\t\t  unsigned int clock,\n\t\t\t\t  struct lsdc_pixpll_parms *pout)\n{\n\tstruct lsdc_pixpll_parms *pparms = this->priv;\n\tunsigned int refclk = pparms->ref_clock;\n\tconst unsigned int tolerance = 1000;\n\tunsigned int min = tolerance;\n\tunsigned int div_out, loopc, div_ref;\n\tunsigned int computed;\n\n\tif (!lsdc_pixpll_find(this, clock, pout))\n\t\treturn 0;\n\n\tfor (div_out = 6; div_out < 64; div_out++) {\n\t\tfor (div_ref = 3; div_ref < 6; div_ref++) {\n\t\t\tfor (loopc = 6; loopc < 161; loopc++) {\n\t\t\t\tunsigned int diff = 0;\n\n\t\t\t\tif (loopc < 12 * div_ref)\n\t\t\t\t\tcontinue;\n\t\t\t\tif (loopc > 32 * div_ref)\n\t\t\t\t\tcontinue;\n\n\t\t\t\tcomputed = refclk / div_ref * loopc / div_out;\n\n\t\t\t\tif (clock >= computed)\n\t\t\t\t\tdiff = clock - computed;\n\t\t\t\telse\n\t\t\t\t\tdiff = computed - clock;\n\n\t\t\t\tif (diff < min) {\n\t\t\t\t\tmin = diff;\n\t\t\t\t\tpparms->div_ref = div_ref;\n\t\t\t\t\tpparms->div_out = div_out;\n\t\t\t\t\tpparms->loopc = loopc;\n\n\t\t\t\t\tif (diff == 0) {\n\t\t\t\t\t\t*pout = *pparms;\n\t\t\t\t\t\treturn 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t \n\tif (min < tolerance) {\n\t\t*pout = *pparms;\n\t\treturn 0;\n\t}\n\n\tdrm_dbg(this->ddev, \"can't find suitable params for %u khz\\n\", clock);\n\n\treturn min;\n}\n\n \n\nstatic void __pixpll_rreg(struct lsdc_pixpll *this,\n\t\t\t  union lsdc_pixpll_reg_bitmap *dst)\n{\n#if defined(CONFIG_64BIT)\n\tdst->d = readq(this->mmio);\n#else\n\tdst->w[0] = readl(this->mmio);\n\tdst->w[1] = readl(this->mmio + 4);\n#endif\n}\n\nstatic void __pixpll_wreg(struct lsdc_pixpll *this,\n\t\t\t  union lsdc_pixpll_reg_bitmap *src)\n{\n#if defined(CONFIG_64BIT)\n\twriteq(src->d, this->mmio);\n#else\n\twritel(src->w[0], this->mmio);\n\twritel(src->w[1], this->mmio + 4);\n#endif\n}\n\nstatic void __pixpll_ops_powerup(struct lsdc_pixpll * const this)\n{\n\tunion lsdc_pixpll_reg_bitmap pixpll_reg;\n\n\t__pixpll_rreg(this, &pixpll_reg);\n\n\tpixpll_reg.bitmap.powerdown = 0;\n\n\t__pixpll_wreg(this, &pixpll_reg);\n}\n\nstatic void __pixpll_ops_powerdown(struct lsdc_pixpll * const this)\n{\n\tunion lsdc_pixpll_reg_bitmap pixpll_reg;\n\n\t__pixpll_rreg(this, &pixpll_reg);\n\n\tpixpll_reg.bitmap.powerdown = 1;\n\n\t__pixpll_wreg(this, &pixpll_reg);\n}\n\nstatic void __pixpll_ops_on(struct lsdc_pixpll * const this)\n{\n\tunion lsdc_pixpll_reg_bitmap pixpll_reg;\n\n\t__pixpll_rreg(this, &pixpll_reg);\n\n\tpixpll_reg.bitmap.sel_out = 1;\n\n\t__pixpll_wreg(this, &pixpll_reg);\n}\n\nstatic void __pixpll_ops_off(struct lsdc_pixpll * const this)\n{\n\tunion lsdc_pixpll_reg_bitmap pixpll_reg;\n\n\t__pixpll_rreg(this, &pixpll_reg);\n\n\tpixpll_reg.bitmap.sel_out = 0;\n\n\t__pixpll_wreg(this, &pixpll_reg);\n}\n\nstatic void __pixpll_ops_bypass(struct lsdc_pixpll * const this)\n{\n\tunion lsdc_pixpll_reg_bitmap pixpll_reg;\n\n\t__pixpll_rreg(this, &pixpll_reg);\n\n\tpixpll_reg.bitmap.bypass = 1;\n\n\t__pixpll_wreg(this, &pixpll_reg);\n}\n\nstatic void __pixpll_ops_unbypass(struct lsdc_pixpll * const this)\n{\n\tunion lsdc_pixpll_reg_bitmap pixpll_reg;\n\n\t__pixpll_rreg(this, &pixpll_reg);\n\n\tpixpll_reg.bitmap.bypass = 0;\n\n\t__pixpll_wreg(this, &pixpll_reg);\n}\n\nstatic void __pixpll_ops_untoggle_param(struct lsdc_pixpll * const this)\n{\n\tunion lsdc_pixpll_reg_bitmap pixpll_reg;\n\n\t__pixpll_rreg(this, &pixpll_reg);\n\n\tpixpll_reg.bitmap.set_param = 0;\n\n\t__pixpll_wreg(this, &pixpll_reg);\n}\n\nstatic void __pixpll_ops_set_param(struct lsdc_pixpll * const this,\n\t\t\t\t   struct lsdc_pixpll_parms const *p)\n{\n\tunion lsdc_pixpll_reg_bitmap pixpll_reg;\n\n\t__pixpll_rreg(this, &pixpll_reg);\n\n\tpixpll_reg.bitmap.div_ref = p->div_ref;\n\tpixpll_reg.bitmap.loopc = p->loopc;\n\tpixpll_reg.bitmap.div_out = p->div_out;\n\n\t__pixpll_wreg(this, &pixpll_reg);\n}\n\nstatic void __pixpll_ops_toggle_param(struct lsdc_pixpll * const this)\n{\n\tunion lsdc_pixpll_reg_bitmap pixpll_reg;\n\n\t__pixpll_rreg(this, &pixpll_reg);\n\n\tpixpll_reg.bitmap.set_param = 1;\n\n\t__pixpll_wreg(this, &pixpll_reg);\n}\n\nstatic void __pixpll_ops_wait_locked(struct lsdc_pixpll * const this)\n{\n\tunion lsdc_pixpll_reg_bitmap pixpll_reg;\n\tunsigned int counter = 0;\n\n\tdo {\n\t\t__pixpll_rreg(this, &pixpll_reg);\n\n\t\tif (pixpll_reg.bitmap.locked)\n\t\t\tbreak;\n\n\t\t++counter;\n\t} while (counter < 2000);\n\n\tdrm_dbg(this->ddev, \"%u loop waited\\n\", counter);\n}\n\n \nstatic int lsdc_pixpll_update(struct lsdc_pixpll * const this,\n\t\t\t      struct lsdc_pixpll_parms const *pin)\n{\n\t__pixpll_ops_bypass(this);\n\n\t__pixpll_ops_off(this);\n\n\t__pixpll_ops_powerdown(this);\n\n\t__pixpll_ops_toggle_param(this);\n\n\t__pixpll_ops_set_param(this, pin);\n\n\t__pixpll_ops_untoggle_param(this);\n\n\t__pixpll_ops_powerup(this);\n\n\tudelay(2);\n\n\t__pixpll_ops_wait_locked(this);\n\n\t__pixpll_ops_on(this);\n\n\t__pixpll_ops_unbypass(this);\n\n\treturn 0;\n}\n\nstatic unsigned int lsdc_pixpll_get_freq(struct lsdc_pixpll * const this)\n{\n\tstruct lsdc_pixpll_parms *ppar = this->priv;\n\tunion lsdc_pixpll_reg_bitmap pix_pll_reg;\n\tunsigned int freq;\n\n\t__pixpll_rreg(this, &pix_pll_reg);\n\n\tppar->div_ref = pix_pll_reg.bitmap.div_ref;\n\tppar->loopc = pix_pll_reg.bitmap.loopc;\n\tppar->div_out = pix_pll_reg.bitmap.div_out;\n\n\tfreq = ppar->ref_clock / ppar->div_ref * ppar->loopc / ppar->div_out;\n\n\treturn freq;\n}\n\nstatic void lsdc_pixpll_print(struct lsdc_pixpll * const this,\n\t\t\t      struct drm_printer *p)\n{\n\tstruct lsdc_pixpll_parms *parms = this->priv;\n\n\tdrm_printf(p, \"div_ref: %u, loopc: %u, div_out: %u\\n\",\n\t\t   parms->div_ref, parms->loopc, parms->div_out);\n}\n\n \nstatic const struct lsdc_pixpll_funcs __pixpll_default_funcs = {\n\t.setup = lsdc_pixel_pll_setup,\n\t.compute = lsdc_pixel_pll_compute,\n\t.update = lsdc_pixpll_update,\n\t.get_rate = lsdc_pixpll_get_freq,\n\t.print = lsdc_pixpll_print,\n};\n\n \n\nint lsdc_pixpll_init(struct lsdc_pixpll * const this,\n\t\t     struct drm_device *ddev,\n\t\t     unsigned int index)\n{\n\tstruct lsdc_device *ldev = to_lsdc(ddev);\n\tconst struct lsdc_desc *descp = ldev->descp;\n\tconst struct loongson_gfx_desc *gfx = to_loongson_gfx(descp);\n\n\tthis->ddev = ddev;\n\tthis->reg_size = 8;\n\tthis->reg_base = gfx->conf_reg_base + gfx->pixpll[index].reg_offset;\n\tthis->funcs = &__pixpll_default_funcs;\n\n\treturn this->funcs->setup(this);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}