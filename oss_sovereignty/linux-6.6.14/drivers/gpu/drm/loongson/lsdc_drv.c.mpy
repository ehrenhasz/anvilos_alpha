{
  "module_name": "lsdc_drv.c",
  "hash_id": "93e3d77af5fd8be1d41f75e5a23f553fa03914900dc8032f7108408955c47754",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/loongson/lsdc_drv.c",
  "human_readable_source": "\n \n\n#include <linux/pci.h>\n#include <linux/vgaarb.h>\n\n#include <drm/drm_aperture.h>\n#include <drm/drm_atomic.h>\n#include <drm/drm_atomic_helper.h>\n#include <drm/drm_drv.h>\n#include <drm/drm_fbdev_generic.h>\n#include <drm/drm_gem_framebuffer_helper.h>\n#include <drm/drm_ioctl.h>\n#include <drm/drm_modeset_helper.h>\n#include <drm/drm_probe_helper.h>\n#include <drm/drm_vblank.h>\n\n#include \"loongson_module.h\"\n#include \"lsdc_drv.h\"\n#include \"lsdc_gem.h\"\n#include \"lsdc_ttm.h\"\n\n#define DRIVER_AUTHOR               \"Sui Jingfeng <suijingfeng@loongson.cn>\"\n#define DRIVER_NAME                 \"loongson\"\n#define DRIVER_DESC                 \"drm driver for loongson graphics\"\n#define DRIVER_DATE                 \"20220701\"\n#define DRIVER_MAJOR                1\n#define DRIVER_MINOR                0\n#define DRIVER_PATCHLEVEL           0\n\nDEFINE_DRM_GEM_FOPS(lsdc_gem_fops);\n\nstatic const struct drm_driver lsdc_drm_driver = {\n\t.driver_features = DRIVER_MODESET | DRIVER_RENDER | DRIVER_GEM | DRIVER_ATOMIC,\n\t.fops = &lsdc_gem_fops,\n\n\t.name = DRIVER_NAME,\n\t.desc = DRIVER_DESC,\n\t.date = DRIVER_DATE,\n\t.major = DRIVER_MAJOR,\n\t.minor = DRIVER_MINOR,\n\t.patchlevel = DRIVER_PATCHLEVEL,\n\n\t.debugfs_init = lsdc_debugfs_init,\n\t.dumb_create = lsdc_dumb_create,\n\t.dumb_map_offset = lsdc_dumb_map_offset,\n\t.gem_prime_import_sg_table = lsdc_prime_import_sg_table,\n};\n\nstatic const struct drm_mode_config_funcs lsdc_mode_config_funcs = {\n\t.fb_create = drm_gem_fb_create,\n\t.atomic_check = drm_atomic_helper_check,\n\t.atomic_commit = drm_atomic_helper_commit,\n};\n\n \n\nstatic int lsdc_modeset_init(struct lsdc_device *ldev,\n\t\t\t     unsigned int num_crtc,\n\t\t\t     const struct lsdc_kms_funcs *funcs,\n\t\t\t     bool has_vblank)\n{\n\tstruct drm_device *ddev = &ldev->base;\n\tstruct lsdc_display_pipe *dispipe;\n\tunsigned int i;\n\tint ret;\n\n\tfor (i = 0; i < num_crtc; i++) {\n\t\tdispipe = &ldev->dispipe[i];\n\n\t\t \n\t\tdispipe->index = i;\n\n\t\tret = funcs->create_i2c(ddev, dispipe, i);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tfor (i = 0; i < num_crtc; i++) {\n\t\tstruct i2c_adapter *ddc = NULL;\n\n\t\tdispipe = &ldev->dispipe[i];\n\t\tif (dispipe->li2c)\n\t\t\tddc = &dispipe->li2c->adapter;\n\n\t\tret = funcs->output_init(ddev, dispipe, ddc, i);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tldev->num_output++;\n\t}\n\n\tfor (i = 0; i < num_crtc; i++) {\n\t\tdispipe = &ldev->dispipe[i];\n\n\t\tret = funcs->primary_plane_init(ddev, &dispipe->primary.base, i);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tret = funcs->cursor_plane_init(ddev, &dispipe->cursor.base, i);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tret = funcs->crtc_init(ddev, &dispipe->crtc.base,\n\t\t\t\t       &dispipe->primary.base,\n\t\t\t\t       &dispipe->cursor.base,\n\t\t\t\t       i, has_vblank);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tdrm_info(ddev, \"Total %u outputs\\n\", ldev->num_output);\n\n\treturn 0;\n}\n\nstatic const struct drm_mode_config_helper_funcs lsdc_mode_config_helper_funcs = {\n\t.atomic_commit_tail = drm_atomic_helper_commit_tail,\n};\n\nstatic int lsdc_mode_config_init(struct drm_device *ddev,\n\t\t\t\t const struct lsdc_desc *descp)\n{\n\tint ret;\n\n\tret = drmm_mode_config_init(ddev);\n\tif (ret)\n\t\treturn ret;\n\n\tddev->mode_config.funcs = &lsdc_mode_config_funcs;\n\tddev->mode_config.min_width = 1;\n\tddev->mode_config.min_height = 1;\n\tddev->mode_config.max_width = descp->max_width * LSDC_NUM_CRTC;\n\tddev->mode_config.max_height = descp->max_height * LSDC_NUM_CRTC;\n\tddev->mode_config.preferred_depth = 24;\n\tddev->mode_config.prefer_shadow = 1;\n\n\tddev->mode_config.cursor_width = descp->hw_cursor_h;\n\tddev->mode_config.cursor_height = descp->hw_cursor_h;\n\n\tddev->mode_config.helper_private = &lsdc_mode_config_helper_funcs;\n\n\tif (descp->has_vblank_counter)\n\t\tddev->max_vblank_count = 0xffffffff;\n\n\treturn ret;\n}\n\n \nstatic int lsdc_get_dedicated_vram(struct lsdc_device *ldev,\n\t\t\t\t   struct pci_dev *pdev_dc,\n\t\t\t\t   const struct lsdc_desc *descp)\n{\n\tstruct drm_device *ddev = &ldev->base;\n\tstruct pci_dev *pdev_gpu;\n\tresource_size_t base, size;\n\n\t \n\tpdev_gpu = pci_get_domain_bus_and_slot(pci_domain_nr(pdev_dc->bus),\n\t\t\t\t\t       pdev_dc->bus->number,\n\t\t\t\t\t       PCI_DEVFN(6, 0));\n\tif (!pdev_gpu) {\n\t\tdrm_err(ddev, \"No GPU device, then no VRAM\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tbase = pci_resource_start(pdev_gpu, 2);\n\tsize = pci_resource_len(pdev_gpu, 2);\n\n\tldev->vram_base = base;\n\tldev->vram_size = size;\n\tldev->gpu = pdev_gpu;\n\n\tdrm_info(ddev, \"Dedicated vram start: 0x%llx, size: %uMiB\\n\",\n\t\t (u64)base, (u32)(size >> 20));\n\n\treturn 0;\n}\n\nstatic struct lsdc_device *\nlsdc_create_device(struct pci_dev *pdev,\n\t\t   const struct lsdc_desc *descp,\n\t\t   const struct drm_driver *driver)\n{\n\tstruct lsdc_device *ldev;\n\tstruct drm_device *ddev;\n\tint ret;\n\n\tldev = devm_drm_dev_alloc(&pdev->dev, driver, struct lsdc_device, base);\n\tif (IS_ERR(ldev))\n\t\treturn ldev;\n\n\tldev->dc = pdev;\n\tldev->descp = descp;\n\n\tddev = &ldev->base;\n\n\tloongson_gfxpll_create(ddev, &ldev->gfxpll);\n\n\tret = lsdc_get_dedicated_vram(ldev, pdev, descp);\n\tif (ret) {\n\t\tdrm_err(ddev, \"Init VRAM failed: %d\\n\", ret);\n\t\treturn ERR_PTR(ret);\n\t}\n\n\tret = drm_aperture_remove_conflicting_framebuffers(ldev->vram_base,\n\t\t\t\t\t\t\t   ldev->vram_size,\n\t\t\t\t\t\t\t   driver);\n\tif (ret) {\n\t\tdrm_err(ddev, \"Remove firmware framebuffers failed: %d\\n\", ret);\n\t\treturn ERR_PTR(ret);\n\t}\n\n\tret = lsdc_ttm_init(ldev);\n\tif (ret) {\n\t\tdrm_err(ddev, \"Memory manager init failed: %d\\n\", ret);\n\t\treturn ERR_PTR(ret);\n\t}\n\n\tlsdc_gem_init(ddev);\n\n\t \n\tldev->reg_base = pcim_iomap(pdev, 0, 0);\n\tif (!ldev->reg_base)\n\t\treturn ERR_PTR(-ENODEV);\n\n\tspin_lock_init(&ldev->reglock);\n\n\tret = lsdc_mode_config_init(ddev, descp);\n\tif (ret)\n\t\treturn ERR_PTR(ret);\n\n\tret = lsdc_modeset_init(ldev, descp->num_of_crtc, descp->funcs,\n\t\t\t\tloongson_vblank);\n\tif (ret)\n\t\treturn ERR_PTR(ret);\n\n\tdrm_mode_config_reset(ddev);\n\n\treturn ldev;\n}\n\n \n\nstatic unsigned int lsdc_vga_set_decode(struct pci_dev *pdev, bool state)\n{\n\treturn VGA_RSRC_NORMAL_IO | VGA_RSRC_NORMAL_MEM;\n}\n\nstatic int lsdc_pci_probe(struct pci_dev *pdev, const struct pci_device_id *ent)\n{\n\tconst struct lsdc_desc *descp;\n\tstruct drm_device *ddev;\n\tstruct lsdc_device *ldev;\n\tint ret;\n\n\tdescp = lsdc_device_probe(pdev, ent->driver_data);\n\tif (IS_ERR_OR_NULL(descp))\n\t\treturn -ENODEV;\n\n\tpci_set_master(pdev);\n\n\tret = dma_set_mask_and_coherent(&pdev->dev, DMA_BIT_MASK(40));\n\tif (ret)\n\t\treturn ret;\n\n\tret = pcim_enable_device(pdev);\n\tif (ret)\n\t\treturn ret;\n\n\tdev_info(&pdev->dev, \"Found %s, revision: %u\",\n\t\t to_loongson_gfx(descp)->model, pdev->revision);\n\n\tldev = lsdc_create_device(pdev, descp, &lsdc_drm_driver);\n\tif (IS_ERR(ldev))\n\t\treturn PTR_ERR(ldev);\n\n\tddev = &ldev->base;\n\n\tpci_set_drvdata(pdev, ddev);\n\n\tvga_client_register(pdev, lsdc_vga_set_decode);\n\n\tdrm_kms_helper_poll_init(ddev);\n\n\tif (loongson_vblank) {\n\t\tret = drm_vblank_init(ddev, descp->num_of_crtc);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tret = devm_request_irq(&pdev->dev, pdev->irq,\n\t\t\t\t       descp->funcs->irq_handler,\n\t\t\t\t       IRQF_SHARED,\n\t\t\t\t       dev_name(&pdev->dev), ddev);\n\t\tif (ret) {\n\t\t\tdrm_err(ddev, \"Failed to register interrupt: %d\\n\", ret);\n\t\t\treturn ret;\n\t\t}\n\n\t\tdrm_info(ddev, \"registered irq: %u\\n\", pdev->irq);\n\t}\n\n\tret = drm_dev_register(ddev, 0);\n\tif (ret)\n\t\treturn ret;\n\n\tdrm_fbdev_generic_setup(ddev, 32);\n\n\treturn 0;\n}\n\nstatic void lsdc_pci_remove(struct pci_dev *pdev)\n{\n\tstruct drm_device *ddev = pci_get_drvdata(pdev);\n\n\tdrm_dev_unregister(ddev);\n\tdrm_atomic_helper_shutdown(ddev);\n}\n\nstatic int lsdc_drm_freeze(struct drm_device *ddev)\n{\n\tstruct lsdc_device *ldev = to_lsdc(ddev);\n\tstruct lsdc_bo *lbo;\n\tint ret;\n\n\t \n\tmutex_lock(&ldev->gem.mutex);\n\tlist_for_each_entry(lbo, &ldev->gem.objects, list) {\n\t\tstruct ttm_buffer_object *tbo = &lbo->tbo;\n\t\tstruct ttm_resource *resource = tbo->resource;\n\t\tunsigned int pin_count = tbo->pin_count;\n\n\t\tdrm_dbg(ddev, \"bo[%p], size: %zuKiB, type: %s, pin count: %u\\n\",\n\t\t\tlbo, lsdc_bo_size(lbo) >> 10,\n\t\t\tlsdc_mem_type_to_str(resource->mem_type), pin_count);\n\n\t\tif (!pin_count)\n\t\t\tcontinue;\n\n\t\tif (resource->mem_type == TTM_PL_VRAM) {\n\t\t\tret = lsdc_bo_reserve(lbo);\n\t\t\tif (unlikely(ret)) {\n\t\t\t\tdrm_err(ddev, \"bo reserve failed: %d\\n\", ret);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tdo {\n\t\t\t\tlsdc_bo_unpin(lbo);\n\t\t\t\t--pin_count;\n\t\t\t} while (pin_count);\n\n\t\t\tlsdc_bo_unreserve(lbo);\n\t\t}\n\t}\n\tmutex_unlock(&ldev->gem.mutex);\n\n\tlsdc_bo_evict_vram(ddev);\n\n\tret = drm_mode_config_helper_suspend(ddev);\n\tif (unlikely(ret)) {\n\t\tdrm_err(ddev, \"Freeze error: %d\", ret);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int lsdc_drm_resume(struct device *dev)\n{\n\tstruct pci_dev *pdev = to_pci_dev(dev);\n\tstruct drm_device *ddev = pci_get_drvdata(pdev);\n\n\treturn drm_mode_config_helper_resume(ddev);\n}\n\nstatic int lsdc_pm_freeze(struct device *dev)\n{\n\tstruct pci_dev *pdev = to_pci_dev(dev);\n\tstruct drm_device *ddev = pci_get_drvdata(pdev);\n\n\treturn lsdc_drm_freeze(ddev);\n}\n\nstatic int lsdc_pm_thaw(struct device *dev)\n{\n\treturn lsdc_drm_resume(dev);\n}\n\nstatic int lsdc_pm_suspend(struct device *dev)\n{\n\tstruct pci_dev *pdev = to_pci_dev(dev);\n\tint error;\n\n\terror = lsdc_pm_freeze(dev);\n\tif (error)\n\t\treturn error;\n\n\tpci_save_state(pdev);\n\t \n\tpci_disable_device(pdev);\n\tpci_set_power_state(pdev, PCI_D3hot);\n\n\treturn 0;\n}\n\nstatic int lsdc_pm_resume(struct device *dev)\n{\n\tstruct pci_dev *pdev = to_pci_dev(dev);\n\n\tpci_set_power_state(pdev, PCI_D0);\n\n\tpci_restore_state(pdev);\n\n\tif (pcim_enable_device(pdev))\n\t\treturn -EIO;\n\n\treturn lsdc_pm_thaw(dev);\n}\n\nstatic const struct dev_pm_ops lsdc_pm_ops = {\n\t.suspend = lsdc_pm_suspend,\n\t.resume = lsdc_pm_resume,\n\t.freeze = lsdc_pm_freeze,\n\t.thaw = lsdc_pm_thaw,\n\t.poweroff = lsdc_pm_freeze,\n\t.restore = lsdc_pm_resume,\n};\n\nstatic const struct pci_device_id lsdc_pciid_list[] = {\n\t{PCI_VDEVICE(LOONGSON, 0x7a06), CHIP_LS7A1000},\n\t{PCI_VDEVICE(LOONGSON, 0x7a36), CHIP_LS7A2000},\n\t{ }\n};\n\nstruct pci_driver lsdc_pci_driver = {\n\t.name = DRIVER_NAME,\n\t.id_table = lsdc_pciid_list,\n\t.probe = lsdc_pci_probe,\n\t.remove = lsdc_pci_remove,\n\t.driver.pm = &lsdc_pm_ops,\n};\n\nMODULE_DEVICE_TABLE(pci, lsdc_pciid_list);\nMODULE_AUTHOR(DRIVER_AUTHOR);\nMODULE_DESCRIPTION(DRIVER_DESC);\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}