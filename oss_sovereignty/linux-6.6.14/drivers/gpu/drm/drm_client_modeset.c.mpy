{
  "module_name": "drm_client_modeset.c",
  "hash_id": "1f839bbf04ae7686c41f6c59c810257ae70668fc18e9ef9b9732604cf63922e2",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/drm_client_modeset.c",
  "human_readable_source": "\n \n\n#include \"drm/drm_modeset_lock.h\"\n#include <linux/module.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/string_helpers.h>\n\n#include <drm/drm_atomic.h>\n#include <drm/drm_client.h>\n#include <drm/drm_connector.h>\n#include <drm/drm_crtc.h>\n#include <drm/drm_device.h>\n#include <drm/drm_drv.h>\n#include <drm/drm_edid.h>\n#include <drm/drm_encoder.h>\n#include <drm/drm_print.h>\n\n#include \"drm_crtc_internal.h\"\n#include \"drm_internal.h\"\n\n#define DRM_CLIENT_MAX_CLONED_CONNECTORS\t8\n\nstruct drm_client_offset {\n\tint x, y;\n};\n\nint drm_client_modeset_create(struct drm_client_dev *client)\n{\n\tstruct drm_device *dev = client->dev;\n\tunsigned int num_crtc = dev->mode_config.num_crtc;\n\tunsigned int max_connector_count = 1;\n\tstruct drm_mode_set *modeset;\n\tstruct drm_crtc *crtc;\n\tunsigned int i = 0;\n\n\t \n\tclient->modesets = kcalloc(num_crtc + 1, sizeof(*client->modesets), GFP_KERNEL);\n\tif (!client->modesets)\n\t\treturn -ENOMEM;\n\n\tmutex_init(&client->modeset_mutex);\n\n\tdrm_for_each_crtc(crtc, dev)\n\t\tclient->modesets[i++].crtc = crtc;\n\n\t \n\tif (num_crtc == 1)\n\t\tmax_connector_count = DRM_CLIENT_MAX_CLONED_CONNECTORS;\n\n\tfor (modeset = client->modesets; modeset->crtc; modeset++) {\n\t\tmodeset->connectors = kcalloc(max_connector_count,\n\t\t\t\t\t      sizeof(*modeset->connectors), GFP_KERNEL);\n\t\tif (!modeset->connectors)\n\t\t\tgoto err_free;\n\t}\n\n\treturn 0;\n\nerr_free:\n\tdrm_client_modeset_free(client);\n\n\treturn -ENOMEM;\n}\n\nstatic void drm_client_modeset_release(struct drm_client_dev *client)\n{\n\tstruct drm_mode_set *modeset;\n\tunsigned int i;\n\n\tdrm_client_for_each_modeset(modeset, client) {\n\t\tdrm_mode_destroy(client->dev, modeset->mode);\n\t\tmodeset->mode = NULL;\n\t\tmodeset->fb = NULL;\n\n\t\tfor (i = 0; i < modeset->num_connectors; i++) {\n\t\t\tdrm_connector_put(modeset->connectors[i]);\n\t\t\tmodeset->connectors[i] = NULL;\n\t\t}\n\t\tmodeset->num_connectors = 0;\n\t}\n}\n\nvoid drm_client_modeset_free(struct drm_client_dev *client)\n{\n\tstruct drm_mode_set *modeset;\n\n\tmutex_lock(&client->modeset_mutex);\n\n\tdrm_client_modeset_release(client);\n\n\tdrm_client_for_each_modeset(modeset, client)\n\t\tkfree(modeset->connectors);\n\n\tmutex_unlock(&client->modeset_mutex);\n\n\tmutex_destroy(&client->modeset_mutex);\n\tkfree(client->modesets);\n}\n\nstatic struct drm_mode_set *\ndrm_client_find_modeset(struct drm_client_dev *client, struct drm_crtc *crtc)\n{\n\tstruct drm_mode_set *modeset;\n\n\tdrm_client_for_each_modeset(modeset, client)\n\t\tif (modeset->crtc == crtc)\n\t\t\treturn modeset;\n\n\treturn NULL;\n}\n\nstatic struct drm_display_mode *\ndrm_connector_get_tiled_mode(struct drm_connector *connector)\n{\n\tstruct drm_display_mode *mode;\n\n\tlist_for_each_entry(mode, &connector->modes, head) {\n\t\tif (mode->hdisplay == connector->tile_h_size &&\n\t\t    mode->vdisplay == connector->tile_v_size)\n\t\t\treturn mode;\n\t}\n\treturn NULL;\n}\n\nstatic struct drm_display_mode *\ndrm_connector_fallback_non_tiled_mode(struct drm_connector *connector)\n{\n\tstruct drm_display_mode *mode;\n\n\tlist_for_each_entry(mode, &connector->modes, head) {\n\t\tif (mode->hdisplay == connector->tile_h_size &&\n\t\t    mode->vdisplay == connector->tile_v_size)\n\t\t\tcontinue;\n\t\treturn mode;\n\t}\n\treturn NULL;\n}\n\nstatic struct drm_display_mode *\ndrm_connector_has_preferred_mode(struct drm_connector *connector, int width, int height)\n{\n\tstruct drm_display_mode *mode;\n\n\tlist_for_each_entry(mode, &connector->modes, head) {\n\t\tif (mode->hdisplay > width ||\n\t\t    mode->vdisplay > height)\n\t\t\tcontinue;\n\t\tif (mode->type & DRM_MODE_TYPE_PREFERRED)\n\t\t\treturn mode;\n\t}\n\treturn NULL;\n}\n\nstatic struct drm_display_mode *drm_connector_pick_cmdline_mode(struct drm_connector *connector)\n{\n\tstruct drm_cmdline_mode *cmdline_mode;\n\tstruct drm_display_mode *mode;\n\tbool prefer_non_interlace;\n\n\t \n\n\tlist_for_each_entry(mode, &connector->modes, head) {\n\t\tif (mode->type & DRM_MODE_TYPE_USERDEF)\n\t\t\treturn mode;\n\t}\n\n\tcmdline_mode = &connector->cmdline_mode;\n\tif (cmdline_mode->specified == false)\n\t\treturn NULL;\n\n\t \n\n\tprefer_non_interlace = !cmdline_mode->interlace;\nagain:\n\tlist_for_each_entry(mode, &connector->modes, head) {\n\t\t \n\t\tif (mode->hdisplay != cmdline_mode->xres ||\n\t\t    mode->vdisplay != cmdline_mode->yres)\n\t\t\tcontinue;\n\n\t\tif (cmdline_mode->refresh_specified) {\n\t\t\tif (drm_mode_vrefresh(mode) != cmdline_mode->refresh)\n\t\t\t\tcontinue;\n\t\t}\n\n\t\tif (cmdline_mode->interlace) {\n\t\t\tif (!(mode->flags & DRM_MODE_FLAG_INTERLACE))\n\t\t\t\tcontinue;\n\t\t} else if (prefer_non_interlace) {\n\t\t\tif (mode->flags & DRM_MODE_FLAG_INTERLACE)\n\t\t\t\tcontinue;\n\t\t}\n\t\treturn mode;\n\t}\n\n\tif (prefer_non_interlace) {\n\t\tprefer_non_interlace = false;\n\t\tgoto again;\n\t}\n\n\treturn NULL;\n}\n\nstatic bool drm_connector_enabled(struct drm_connector *connector, bool strict)\n{\n\tbool enable;\n\n\tif (connector->display_info.non_desktop)\n\t\treturn false;\n\n\tif (strict)\n\t\tenable = connector->status == connector_status_connected;\n\telse\n\t\tenable = connector->status != connector_status_disconnected;\n\n\treturn enable;\n}\n\nstatic void drm_client_connectors_enabled(struct drm_connector **connectors,\n\t\t\t\t\t  unsigned int connector_count,\n\t\t\t\t\t  bool *enabled)\n{\n\tbool any_enabled = false;\n\tstruct drm_connector *connector;\n\tint i = 0;\n\n\tfor (i = 0; i < connector_count; i++) {\n\t\tconnector = connectors[i];\n\t\tenabled[i] = drm_connector_enabled(connector, true);\n\t\tDRM_DEBUG_KMS(\"connector %d enabled? %s\\n\", connector->base.id,\n\t\t\t      connector->display_info.non_desktop ? \"non desktop\" : str_yes_no(enabled[i]));\n\n\t\tany_enabled |= enabled[i];\n\t}\n\n\tif (any_enabled)\n\t\treturn;\n\n\tfor (i = 0; i < connector_count; i++)\n\t\tenabled[i] = drm_connector_enabled(connectors[i], false);\n}\n\nstatic bool drm_client_target_cloned(struct drm_device *dev,\n\t\t\t\t     struct drm_connector **connectors,\n\t\t\t\t     unsigned int connector_count,\n\t\t\t\t     struct drm_display_mode **modes,\n\t\t\t\t     struct drm_client_offset *offsets,\n\t\t\t\t     bool *enabled, int width, int height)\n{\n\tint count, i, j;\n\tbool can_clone = false;\n\tstruct drm_display_mode *dmt_mode, *mode;\n\n\t \n\tif (dev->mode_config.num_crtc > 1)\n\t\treturn false;\n\n\tcount = 0;\n\tfor (i = 0; i < connector_count; i++) {\n\t\tif (enabled[i])\n\t\t\tcount++;\n\t}\n\n\t \n\tif (count <= 1)\n\t\treturn false;\n\n\t \n\tcan_clone = true;\n\tfor (i = 0; i < connector_count; i++) {\n\t\tif (!enabled[i])\n\t\t\tcontinue;\n\t\tmodes[i] = drm_connector_pick_cmdline_mode(connectors[i]);\n\t\tif (!modes[i]) {\n\t\t\tcan_clone = false;\n\t\t\tbreak;\n\t\t}\n\t\tfor (j = 0; j < i; j++) {\n\t\t\tif (!enabled[j])\n\t\t\t\tcontinue;\n\t\t\tif (!drm_mode_match(modes[j], modes[i],\n\t\t\t\t\t    DRM_MODE_MATCH_TIMINGS |\n\t\t\t\t\t    DRM_MODE_MATCH_CLOCK |\n\t\t\t\t\t    DRM_MODE_MATCH_FLAGS |\n\t\t\t\t\t    DRM_MODE_MATCH_3D_FLAGS))\n\t\t\t\tcan_clone = false;\n\t\t}\n\t}\n\n\tif (can_clone) {\n\t\tDRM_DEBUG_KMS(\"can clone using command line\\n\");\n\t\treturn true;\n\t}\n\n\t \n\tcan_clone = true;\n\tdmt_mode = drm_mode_find_dmt(dev, 1024, 768, 60, false);\n\n\tif (!dmt_mode)\n\t\tgoto fail;\n\n\tfor (i = 0; i < connector_count; i++) {\n\t\tif (!enabled[i])\n\t\t\tcontinue;\n\n\t\tlist_for_each_entry(mode, &connectors[i]->modes, head) {\n\t\t\tif (drm_mode_match(mode, dmt_mode,\n\t\t\t\t\t   DRM_MODE_MATCH_TIMINGS |\n\t\t\t\t\t   DRM_MODE_MATCH_CLOCK |\n\t\t\t\t\t   DRM_MODE_MATCH_FLAGS |\n\t\t\t\t\t   DRM_MODE_MATCH_3D_FLAGS))\n\t\t\t\tmodes[i] = mode;\n\t\t}\n\t\tif (!modes[i])\n\t\t\tcan_clone = false;\n\t}\n\tkfree(dmt_mode);\n\n\tif (can_clone) {\n\t\tDRM_DEBUG_KMS(\"can clone using 1024x768\\n\");\n\t\treturn true;\n\t}\nfail:\n\tDRM_INFO(\"kms: can't enable cloning when we probably wanted to.\\n\");\n\treturn false;\n}\n\nstatic int drm_client_get_tile_offsets(struct drm_connector **connectors,\n\t\t\t\t       unsigned int connector_count,\n\t\t\t\t       struct drm_display_mode **modes,\n\t\t\t\t       struct drm_client_offset *offsets,\n\t\t\t\t       int idx,\n\t\t\t\t       int h_idx, int v_idx)\n{\n\tstruct drm_connector *connector;\n\tint i;\n\tint hoffset = 0, voffset = 0;\n\n\tfor (i = 0; i < connector_count; i++) {\n\t\tconnector = connectors[i];\n\t\tif (!connector->has_tile)\n\t\t\tcontinue;\n\n\t\tif (!modes[i] && (h_idx || v_idx)) {\n\t\t\tDRM_DEBUG_KMS(\"no modes for connector tiled %d %d\\n\", i,\n\t\t\t\t      connector->base.id);\n\t\t\tcontinue;\n\t\t}\n\t\tif (connector->tile_h_loc < h_idx)\n\t\t\thoffset += modes[i]->hdisplay;\n\n\t\tif (connector->tile_v_loc < v_idx)\n\t\t\tvoffset += modes[i]->vdisplay;\n\t}\n\toffsets[idx].x = hoffset;\n\toffsets[idx].y = voffset;\n\tDRM_DEBUG_KMS(\"returned %d %d for %d %d\\n\", hoffset, voffset, h_idx, v_idx);\n\treturn 0;\n}\n\nstatic bool drm_client_target_preferred(struct drm_connector **connectors,\n\t\t\t\t\tunsigned int connector_count,\n\t\t\t\t\tstruct drm_display_mode **modes,\n\t\t\t\t\tstruct drm_client_offset *offsets,\n\t\t\t\t\tbool *enabled, int width, int height)\n{\n\tconst u64 mask = BIT_ULL(connector_count) - 1;\n\tstruct drm_connector *connector;\n\tu64 conn_configured = 0;\n\tint tile_pass = 0;\n\tint num_tiled_conns = 0;\n\tint i;\n\n\tfor (i = 0; i < connector_count; i++) {\n\t\tif (connectors[i]->has_tile &&\n\t\t    connectors[i]->status == connector_status_connected)\n\t\t\tnum_tiled_conns++;\n\t}\n\nretry:\n\tfor (i = 0; i < connector_count; i++) {\n\t\tconnector = connectors[i];\n\n\t\tif (conn_configured & BIT_ULL(i))\n\t\t\tcontinue;\n\n\t\tif (enabled[i] == false) {\n\t\t\tconn_configured |= BIT_ULL(i);\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\tif (tile_pass == 0 && connector->has_tile)\n\t\t\tcontinue;\n\n\t\tif (tile_pass == 1) {\n\t\t\tif (connector->tile_h_loc != 0 ||\n\t\t\t    connector->tile_v_loc != 0)\n\t\t\t\tcontinue;\n\n\t\t} else {\n\t\t\tif (connector->tile_h_loc != tile_pass - 1 &&\n\t\t\t    connector->tile_v_loc != tile_pass - 1)\n\t\t\t \n\t\t\t\tcontinue;\n\n\t\t\t \n\t\t\tdrm_client_get_tile_offsets(connectors, connector_count, modes, offsets, i,\n\t\t\t\t\t\t    connector->tile_h_loc, connector->tile_v_loc);\n\t\t}\n\t\tDRM_DEBUG_KMS(\"looking for cmdline mode on connector %d\\n\",\n\t\t\t      connector->base.id);\n\n\t\t \n\t\tmodes[i] = drm_connector_pick_cmdline_mode(connector);\n\t\tif (!modes[i]) {\n\t\t\tDRM_DEBUG_KMS(\"looking for preferred mode on connector %d %d\\n\",\n\t\t\t\t      connector->base.id, connector->tile_group ? connector->tile_group->id : 0);\n\t\t\tmodes[i] = drm_connector_has_preferred_mode(connector, width, height);\n\t\t}\n\t\t \n\t\tif (!modes[i] && !list_empty(&connector->modes)) {\n\t\t\tlist_for_each_entry(modes[i], &connector->modes, head)\n\t\t\t\tbreak;\n\t\t}\n\t\t \n\t\tif (connector->has_tile) {\n\t\t\tif (num_tiled_conns <\n\t\t\t    connector->num_h_tile * connector->num_v_tile ||\n\t\t\t    (connector->tile_h_loc == 0 &&\n\t\t\t     connector->tile_v_loc == 0 &&\n\t\t\t     !drm_connector_get_tiled_mode(connector))) {\n\t\t\t\tDRM_DEBUG_KMS(\"Falling back to non tiled mode on Connector %d\\n\",\n\t\t\t\t\t      connector->base.id);\n\t\t\t\tmodes[i] = drm_connector_fallback_non_tiled_mode(connector);\n\t\t\t} else {\n\t\t\t\tmodes[i] = drm_connector_get_tiled_mode(connector);\n\t\t\t}\n\t\t}\n\n\t\tDRM_DEBUG_KMS(\"found mode %s\\n\", modes[i] ? modes[i]->name :\n\t\t\t  \"none\");\n\t\tconn_configured |= BIT_ULL(i);\n\t}\n\n\tif ((conn_configured & mask) != mask) {\n\t\ttile_pass++;\n\t\tgoto retry;\n\t}\n\treturn true;\n}\n\nstatic bool connector_has_possible_crtc(struct drm_connector *connector,\n\t\t\t\t\tstruct drm_crtc *crtc)\n{\n\tstruct drm_encoder *encoder;\n\n\tdrm_connector_for_each_possible_encoder(connector, encoder) {\n\t\tif (encoder->possible_crtcs & drm_crtc_mask(crtc))\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}\n\nstatic int drm_client_pick_crtcs(struct drm_client_dev *client,\n\t\t\t\t struct drm_connector **connectors,\n\t\t\t\t unsigned int connector_count,\n\t\t\t\t struct drm_crtc **best_crtcs,\n\t\t\t\t struct drm_display_mode **modes,\n\t\t\t\t int n, int width, int height)\n{\n\tstruct drm_device *dev = client->dev;\n\tstruct drm_connector *connector;\n\tint my_score, best_score, score;\n\tstruct drm_crtc **crtcs, *crtc;\n\tstruct drm_mode_set *modeset;\n\tint o;\n\n\tif (n == connector_count)\n\t\treturn 0;\n\n\tconnector = connectors[n];\n\n\tbest_crtcs[n] = NULL;\n\tbest_score = drm_client_pick_crtcs(client, connectors, connector_count,\n\t\t\t\t\t   best_crtcs, modes, n + 1, width, height);\n\tif (modes[n] == NULL)\n\t\treturn best_score;\n\n\tcrtcs = kcalloc(connector_count, sizeof(*crtcs), GFP_KERNEL);\n\tif (!crtcs)\n\t\treturn best_score;\n\n\tmy_score = 1;\n\tif (connector->status == connector_status_connected)\n\t\tmy_score++;\n\tif (connector->cmdline_mode.specified)\n\t\tmy_score++;\n\tif (drm_connector_has_preferred_mode(connector, width, height))\n\t\tmy_score++;\n\n\t \n\tdrm_client_for_each_modeset(modeset, client) {\n\t\tcrtc = modeset->crtc;\n\n\t\tif (!connector_has_possible_crtc(connector, crtc))\n\t\t\tcontinue;\n\n\t\tfor (o = 0; o < n; o++)\n\t\t\tif (best_crtcs[o] == crtc)\n\t\t\t\tbreak;\n\n\t\tif (o < n) {\n\t\t\t \n\t\t\tif (dev->mode_config.num_crtc > 1)\n\t\t\t\tcontinue;\n\n\t\t\tif (!drm_mode_equal(modes[o], modes[n]))\n\t\t\t\tcontinue;\n\t\t}\n\n\t\tcrtcs[n] = crtc;\n\t\tmemcpy(crtcs, best_crtcs, n * sizeof(*crtcs));\n\t\tscore = my_score + drm_client_pick_crtcs(client, connectors, connector_count,\n\t\t\t\t\t\t\t crtcs, modes, n + 1, width, height);\n\t\tif (score > best_score) {\n\t\t\tbest_score = score;\n\t\t\tmemcpy(best_crtcs, crtcs, connector_count * sizeof(*crtcs));\n\t\t}\n\t}\n\n\tkfree(crtcs);\n\treturn best_score;\n}\n\n \nstatic bool drm_client_firmware_config(struct drm_client_dev *client,\n\t\t\t\t       struct drm_connector **connectors,\n\t\t\t\t       unsigned int connector_count,\n\t\t\t\t       struct drm_crtc **crtcs,\n\t\t\t\t       struct drm_display_mode **modes,\n\t\t\t\t       struct drm_client_offset *offsets,\n\t\t\t\t       bool *enabled, int width, int height)\n{\n\tconst int count = min_t(unsigned int, connector_count, BITS_PER_LONG);\n\tunsigned long conn_configured, conn_seq, mask;\n\tstruct drm_device *dev = client->dev;\n\tint i, j;\n\tbool *save_enabled;\n\tbool fallback = true, ret = true;\n\tint num_connectors_enabled = 0;\n\tint num_connectors_detected = 0;\n\tint num_tiled_conns = 0;\n\tstruct drm_modeset_acquire_ctx ctx;\n\n\tif (!drm_drv_uses_atomic_modeset(dev))\n\t\treturn false;\n\n\tif (WARN_ON(count <= 0))\n\t\treturn false;\n\n\tsave_enabled = kcalloc(count, sizeof(bool), GFP_KERNEL);\n\tif (!save_enabled)\n\t\treturn false;\n\n\tdrm_modeset_acquire_init(&ctx, 0);\n\n\twhile (drm_modeset_lock_all_ctx(dev, &ctx) != 0)\n\t\tdrm_modeset_backoff(&ctx);\n\n\tmemcpy(save_enabled, enabled, count);\n\tmask = GENMASK(count - 1, 0);\n\tconn_configured = 0;\n\tfor (i = 0; i < count; i++) {\n\t\tif (connectors[i]->has_tile &&\n\t\t    connectors[i]->status == connector_status_connected)\n\t\t\tnum_tiled_conns++;\n\t}\nretry:\n\tconn_seq = conn_configured;\n\tfor (i = 0; i < count; i++) {\n\t\tstruct drm_connector *connector;\n\t\tstruct drm_encoder *encoder;\n\t\tstruct drm_crtc *new_crtc;\n\n\t\tconnector = connectors[i];\n\n\t\tif (conn_configured & BIT(i))\n\t\t\tcontinue;\n\n\t\tif (conn_seq == 0 && !connector->has_tile)\n\t\t\tcontinue;\n\n\t\tif (connector->status == connector_status_connected)\n\t\t\tnum_connectors_detected++;\n\n\t\tif (!enabled[i]) {\n\t\t\tDRM_DEBUG_KMS(\"connector %s not enabled, skipping\\n\",\n\t\t\t\t      connector->name);\n\t\t\tconn_configured |= BIT(i);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (connector->force == DRM_FORCE_OFF) {\n\t\t\tDRM_DEBUG_KMS(\"connector %s is disabled by user, skipping\\n\",\n\t\t\t\t      connector->name);\n\t\t\tenabled[i] = false;\n\t\t\tcontinue;\n\t\t}\n\n\t\tencoder = connector->state->best_encoder;\n\t\tif (!encoder || WARN_ON(!connector->state->crtc)) {\n\t\t\tif (connector->force > DRM_FORCE_OFF)\n\t\t\t\tgoto bail;\n\n\t\t\tDRM_DEBUG_KMS(\"connector %s has no encoder or crtc, skipping\\n\",\n\t\t\t\t      connector->name);\n\t\t\tenabled[i] = false;\n\t\t\tconn_configured |= BIT(i);\n\t\t\tcontinue;\n\t\t}\n\n\t\tnum_connectors_enabled++;\n\n\t\tnew_crtc = connector->state->crtc;\n\n\t\t \n\t\tfor (j = 0; j < count; j++) {\n\t\t\tif (crtcs[j] == new_crtc) {\n\t\t\t\tDRM_DEBUG_KMS(\"fallback: cloned configuration\\n\");\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t}\n\n\t\tDRM_DEBUG_KMS(\"looking for cmdline mode on connector %s\\n\",\n\t\t\t      connector->name);\n\n\t\t \n\t\tmodes[i] = drm_connector_pick_cmdline_mode(connector);\n\n\t\t \n\t\tif (!modes[i]) {\n\t\t\tDRM_DEBUG_KMS(\"looking for preferred mode on connector %s %d\\n\",\n\t\t\t\t      connector->name, connector->has_tile);\n\t\t\tmodes[i] = drm_connector_has_preferred_mode(connector, width, height);\n\t\t}\n\n\t\t \n\t\tif (!modes[i] && !list_empty(&connector->modes)) {\n\t\t\tDRM_DEBUG_KMS(\"using first mode listed on connector %s\\n\",\n\t\t\t\t      connector->name);\n\t\t\tmodes[i] = list_first_entry(&connector->modes,\n\t\t\t\t\t\t    struct drm_display_mode,\n\t\t\t\t\t\t    head);\n\t\t}\n\n\t\t \n\t\tif (!modes[i]) {\n\t\t\t \n\t\t\tDRM_DEBUG_KMS(\"looking for current mode on connector %s\\n\",\n\t\t\t\t      connector->name);\n\t\t\tmodes[i] = &connector->state->crtc->mode;\n\t\t}\n\t\t \n\t\tif (connector->has_tile &&\n\t\t    num_tiled_conns < connector->num_h_tile * connector->num_v_tile) {\n\t\t\tDRM_DEBUG_KMS(\"Falling back to non tiled mode on Connector %d\\n\",\n\t\t\t\t      connector->base.id);\n\t\t\tmodes[i] = drm_connector_fallback_non_tiled_mode(connector);\n\t\t}\n\t\tcrtcs[i] = new_crtc;\n\n\t\tDRM_DEBUG_KMS(\"connector %s on [CRTC:%d:%s]: %dx%d%s\\n\",\n\t\t\t      connector->name,\n\t\t\t      connector->state->crtc->base.id,\n\t\t\t      connector->state->crtc->name,\n\t\t\t      modes[i]->hdisplay, modes[i]->vdisplay,\n\t\t\t      modes[i]->flags & DRM_MODE_FLAG_INTERLACE ? \"i\" : \"\");\n\n\t\tfallback = false;\n\t\tconn_configured |= BIT(i);\n\t}\n\n\tif ((conn_configured & mask) != mask && conn_configured != conn_seq)\n\t\tgoto retry;\n\n\t \n\tif (num_connectors_enabled != num_connectors_detected &&\n\t    num_connectors_enabled < dev->mode_config.num_crtc) {\n\t\tDRM_DEBUG_KMS(\"fallback: Not all outputs enabled\\n\");\n\t\tDRM_DEBUG_KMS(\"Enabled: %i, detected: %i\\n\", num_connectors_enabled,\n\t\t\t      num_connectors_detected);\n\t\tfallback = true;\n\t}\n\n\tif (fallback) {\nbail:\n\t\tDRM_DEBUG_KMS(\"Not using firmware configuration\\n\");\n\t\tmemcpy(enabled, save_enabled, count);\n\t\tret = false;\n\t}\n\n\tdrm_modeset_drop_locks(&ctx);\n\tdrm_modeset_acquire_fini(&ctx);\n\n\tkfree(save_enabled);\n\treturn ret;\n}\n\n \nint drm_client_modeset_probe(struct drm_client_dev *client, unsigned int width, unsigned int height)\n{\n\tstruct drm_connector *connector, **connectors = NULL;\n\tstruct drm_connector_list_iter conn_iter;\n\tstruct drm_device *dev = client->dev;\n\tunsigned int total_modes_count = 0;\n\tstruct drm_client_offset *offsets;\n\tunsigned int connector_count = 0;\n\tstruct drm_display_mode **modes;\n\tstruct drm_crtc **crtcs;\n\tint i, ret = 0;\n\tbool *enabled;\n\n\tDRM_DEBUG_KMS(\"\\n\");\n\n\tif (!width)\n\t\twidth = dev->mode_config.max_width;\n\tif (!height)\n\t\theight = dev->mode_config.max_height;\n\n\tdrm_connector_list_iter_begin(dev, &conn_iter);\n\tdrm_client_for_each_connector_iter(connector, &conn_iter) {\n\t\tstruct drm_connector **tmp;\n\n\t\ttmp = krealloc(connectors, (connector_count + 1) * sizeof(*connectors), GFP_KERNEL);\n\t\tif (!tmp) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto free_connectors;\n\t\t}\n\n\t\tconnectors = tmp;\n\t\tdrm_connector_get(connector);\n\t\tconnectors[connector_count++] = connector;\n\t}\n\tdrm_connector_list_iter_end(&conn_iter);\n\n\tif (!connector_count)\n\t\treturn 0;\n\n\tcrtcs = kcalloc(connector_count, sizeof(*crtcs), GFP_KERNEL);\n\tmodes = kcalloc(connector_count, sizeof(*modes), GFP_KERNEL);\n\toffsets = kcalloc(connector_count, sizeof(*offsets), GFP_KERNEL);\n\tenabled = kcalloc(connector_count, sizeof(bool), GFP_KERNEL);\n\tif (!crtcs || !modes || !enabled || !offsets) {\n\t\tDRM_ERROR(\"Memory allocation failed\\n\");\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tmutex_lock(&client->modeset_mutex);\n\n\tmutex_lock(&dev->mode_config.mutex);\n\tfor (i = 0; i < connector_count; i++)\n\t\ttotal_modes_count += connectors[i]->funcs->fill_modes(connectors[i], width, height);\n\tif (!total_modes_count)\n\t\tDRM_DEBUG_KMS(\"No connectors reported connected with modes\\n\");\n\tdrm_client_connectors_enabled(connectors, connector_count, enabled);\n\n\tif (!drm_client_firmware_config(client, connectors, connector_count, crtcs,\n\t\t\t\t\tmodes, offsets, enabled, width, height)) {\n\t\tmemset(modes, 0, connector_count * sizeof(*modes));\n\t\tmemset(crtcs, 0, connector_count * sizeof(*crtcs));\n\t\tmemset(offsets, 0, connector_count * sizeof(*offsets));\n\n\t\tif (!drm_client_target_cloned(dev, connectors, connector_count, modes,\n\t\t\t\t\t      offsets, enabled, width, height) &&\n\t\t    !drm_client_target_preferred(connectors, connector_count, modes,\n\t\t\t\t\t\t offsets, enabled, width, height))\n\t\t\tDRM_ERROR(\"Unable to find initial modes\\n\");\n\n\t\tDRM_DEBUG_KMS(\"picking CRTCs for %dx%d config\\n\",\n\t\t\t      width, height);\n\n\t\tdrm_client_pick_crtcs(client, connectors, connector_count,\n\t\t\t\t      crtcs, modes, 0, width, height);\n\t}\n\tmutex_unlock(&dev->mode_config.mutex);\n\n\tdrm_client_modeset_release(client);\n\n\tfor (i = 0; i < connector_count; i++) {\n\t\tstruct drm_display_mode *mode = modes[i];\n\t\tstruct drm_crtc *crtc = crtcs[i];\n\t\tstruct drm_client_offset *offset = &offsets[i];\n\n\t\tif (mode && crtc) {\n\t\t\tstruct drm_mode_set *modeset = drm_client_find_modeset(client, crtc);\n\t\t\tstruct drm_connector *connector = connectors[i];\n\n\t\t\tDRM_DEBUG_KMS(\"desired mode %s set on crtc %d (%d,%d)\\n\",\n\t\t\t\t      mode->name, crtc->base.id, offset->x, offset->y);\n\n\t\t\tif (WARN_ON_ONCE(modeset->num_connectors == DRM_CLIENT_MAX_CLONED_CONNECTORS ||\n\t\t\t\t\t (dev->mode_config.num_crtc > 1 && modeset->num_connectors == 1))) {\n\t\t\t\tret = -EINVAL;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tkfree(modeset->mode);\n\t\t\tmodeset->mode = drm_mode_duplicate(dev, mode);\n\t\t\tdrm_connector_get(connector);\n\t\t\tmodeset->connectors[modeset->num_connectors++] = connector;\n\t\t\tmodeset->x = offset->x;\n\t\t\tmodeset->y = offset->y;\n\t\t}\n\t}\n\n\tmutex_unlock(&client->modeset_mutex);\nout:\n\tkfree(crtcs);\n\tkfree(modes);\n\tkfree(offsets);\n\tkfree(enabled);\nfree_connectors:\n\tfor (i = 0; i < connector_count; i++)\n\t\tdrm_connector_put(connectors[i]);\n\tkfree(connectors);\n\n\treturn ret;\n}\nEXPORT_SYMBOL(drm_client_modeset_probe);\n\n \nbool drm_client_rotation(struct drm_mode_set *modeset, unsigned int *rotation)\n{\n\tstruct drm_connector *connector = modeset->connectors[0];\n\tstruct drm_plane *plane = modeset->crtc->primary;\n\tstruct drm_cmdline_mode *cmdline;\n\tu64 valid_mask = 0;\n\tunsigned int i;\n\n\tif (!modeset->num_connectors)\n\t\treturn false;\n\n\tswitch (connector->display_info.panel_orientation) {\n\tcase DRM_MODE_PANEL_ORIENTATION_BOTTOM_UP:\n\t\t*rotation = DRM_MODE_ROTATE_180;\n\t\tbreak;\n\tcase DRM_MODE_PANEL_ORIENTATION_LEFT_UP:\n\t\t*rotation = DRM_MODE_ROTATE_90;\n\t\tbreak;\n\tcase DRM_MODE_PANEL_ORIENTATION_RIGHT_UP:\n\t\t*rotation = DRM_MODE_ROTATE_270;\n\t\tbreak;\n\tdefault:\n\t\t*rotation = DRM_MODE_ROTATE_0;\n\t}\n\n\t \n\tcmdline = &connector->cmdline_mode;\n\tif (cmdline->specified && cmdline->rotation_reflection) {\n\t\tunsigned int cmdline_rest, panel_rest;\n\t\tunsigned int cmdline_rot, panel_rot;\n\t\tunsigned int sum_rot, sum_rest;\n\n\t\tpanel_rot = ilog2(*rotation & DRM_MODE_ROTATE_MASK);\n\t\tcmdline_rot = ilog2(cmdline->rotation_reflection & DRM_MODE_ROTATE_MASK);\n\t\tsum_rot = (panel_rot + cmdline_rot) % 4;\n\n\t\tpanel_rest = *rotation & ~DRM_MODE_ROTATE_MASK;\n\t\tcmdline_rest = cmdline->rotation_reflection & ~DRM_MODE_ROTATE_MASK;\n\t\tsum_rest = panel_rest ^ cmdline_rest;\n\n\t\t*rotation = (1 << sum_rot) | sum_rest;\n\t}\n\n\t \n\tif (((*rotation & DRM_MODE_ROTATE_MASK) != DRM_MODE_ROTATE_0 &&\n\t     (*rotation & DRM_MODE_ROTATE_MASK) != DRM_MODE_ROTATE_180) ||\n\t    !plane->rotation_property)\n\t\treturn false;\n\n\tfor (i = 0; i < plane->rotation_property->num_values; i++)\n\t\tvalid_mask |= (1ULL << plane->rotation_property->values[i]);\n\n\tif (!(*rotation & valid_mask))\n\t\treturn false;\n\n\treturn true;\n}\nEXPORT_SYMBOL(drm_client_rotation);\n\nstatic int drm_client_modeset_commit_atomic(struct drm_client_dev *client, bool active, bool check)\n{\n\tstruct drm_device *dev = client->dev;\n\tstruct drm_plane *plane;\n\tstruct drm_atomic_state *state;\n\tstruct drm_modeset_acquire_ctx ctx;\n\tstruct drm_mode_set *mode_set;\n\tint ret;\n\n\tdrm_modeset_acquire_init(&ctx, 0);\n\n\tstate = drm_atomic_state_alloc(dev);\n\tif (!state) {\n\t\tret = -ENOMEM;\n\t\tgoto out_ctx;\n\t}\n\n\tstate->acquire_ctx = &ctx;\nretry:\n\tdrm_for_each_plane(plane, dev) {\n\t\tstruct drm_plane_state *plane_state;\n\n\t\tplane_state = drm_atomic_get_plane_state(state, plane);\n\t\tif (IS_ERR(plane_state)) {\n\t\t\tret = PTR_ERR(plane_state);\n\t\t\tgoto out_state;\n\t\t}\n\n\t\tplane_state->rotation = DRM_MODE_ROTATE_0;\n\n\t\t \n\t\tif (plane->type == DRM_PLANE_TYPE_PRIMARY)\n\t\t\tcontinue;\n\n\t\tret = __drm_atomic_helper_disable_plane(plane, plane_state);\n\t\tif (ret != 0)\n\t\t\tgoto out_state;\n\t}\n\n\tdrm_client_for_each_modeset(mode_set, client) {\n\t\tstruct drm_plane *primary = mode_set->crtc->primary;\n\t\tunsigned int rotation;\n\n\t\tif (drm_client_rotation(mode_set, &rotation)) {\n\t\t\tstruct drm_plane_state *plane_state;\n\n\t\t\t \n\t\t\tplane_state = drm_atomic_get_new_plane_state(state, primary);\n\t\t\tplane_state->rotation = rotation;\n\t\t}\n\n\t\tret = __drm_atomic_helper_set_config(mode_set, state);\n\t\tif (ret != 0)\n\t\t\tgoto out_state;\n\n\t\t \n\t\tif (!active) {\n\t\t\tstruct drm_crtc *crtc = mode_set->crtc;\n\t\t\tstruct drm_crtc_state *crtc_state = drm_atomic_get_new_crtc_state(state, crtc);\n\n\t\t\tcrtc_state->active = false;\n\t\t}\n\t}\n\n\tif (check)\n\t\tret = drm_atomic_check_only(state);\n\telse\n\t\tret = drm_atomic_commit(state);\n\nout_state:\n\tif (ret == -EDEADLK)\n\t\tgoto backoff;\n\n\tdrm_atomic_state_put(state);\nout_ctx:\n\tdrm_modeset_drop_locks(&ctx);\n\tdrm_modeset_acquire_fini(&ctx);\n\n\treturn ret;\n\nbackoff:\n\tdrm_atomic_state_clear(state);\n\tdrm_modeset_backoff(&ctx);\n\n\tgoto retry;\n}\n\nstatic int drm_client_modeset_commit_legacy(struct drm_client_dev *client)\n{\n\tstruct drm_device *dev = client->dev;\n\tstruct drm_mode_set *mode_set;\n\tstruct drm_plane *plane;\n\tint ret = 0;\n\n\tdrm_modeset_lock_all(dev);\n\tdrm_for_each_plane(plane, dev) {\n\t\tif (plane->type != DRM_PLANE_TYPE_PRIMARY)\n\t\t\tdrm_plane_force_disable(plane);\n\n\t\tif (plane->rotation_property)\n\t\t\tdrm_mode_plane_set_obj_prop(plane,\n\t\t\t\t\t\t    plane->rotation_property,\n\t\t\t\t\t\t    DRM_MODE_ROTATE_0);\n\t}\n\n\tdrm_client_for_each_modeset(mode_set, client) {\n\t\tstruct drm_crtc *crtc = mode_set->crtc;\n\n\t\tif (crtc->funcs->cursor_set2) {\n\t\t\tret = crtc->funcs->cursor_set2(crtc, NULL, 0, 0, 0, 0, 0);\n\t\t\tif (ret)\n\t\t\t\tgoto out;\n\t\t} else if (crtc->funcs->cursor_set) {\n\t\t\tret = crtc->funcs->cursor_set(crtc, NULL, 0, 0, 0);\n\t\t\tif (ret)\n\t\t\t\tgoto out;\n\t\t}\n\n\t\tret = drm_mode_set_config_internal(mode_set);\n\t\tif (ret)\n\t\t\tgoto out;\n\t}\nout:\n\tdrm_modeset_unlock_all(dev);\n\n\treturn ret;\n}\n\n \nint drm_client_modeset_check(struct drm_client_dev *client)\n{\n\tint ret;\n\n\tif (!drm_drv_uses_atomic_modeset(client->dev))\n\t\treturn 0;\n\n\tmutex_lock(&client->modeset_mutex);\n\tret = drm_client_modeset_commit_atomic(client, true, true);\n\tmutex_unlock(&client->modeset_mutex);\n\n\treturn ret;\n}\nEXPORT_SYMBOL(drm_client_modeset_check);\n\n \nint drm_client_modeset_commit_locked(struct drm_client_dev *client)\n{\n\tstruct drm_device *dev = client->dev;\n\tint ret;\n\n\tmutex_lock(&client->modeset_mutex);\n\tif (drm_drv_uses_atomic_modeset(dev))\n\t\tret = drm_client_modeset_commit_atomic(client, true, false);\n\telse\n\t\tret = drm_client_modeset_commit_legacy(client);\n\tmutex_unlock(&client->modeset_mutex);\n\n\treturn ret;\n}\nEXPORT_SYMBOL(drm_client_modeset_commit_locked);\n\n \nint drm_client_modeset_commit(struct drm_client_dev *client)\n{\n\tstruct drm_device *dev = client->dev;\n\tint ret;\n\n\tif (!drm_master_internal_acquire(dev))\n\t\treturn -EBUSY;\n\n\tret = drm_client_modeset_commit_locked(client);\n\n\tdrm_master_internal_release(dev);\n\n\treturn ret;\n}\nEXPORT_SYMBOL(drm_client_modeset_commit);\n\nstatic void drm_client_modeset_dpms_legacy(struct drm_client_dev *client, int dpms_mode)\n{\n\tstruct drm_device *dev = client->dev;\n\tstruct drm_connector *connector;\n\tstruct drm_mode_set *modeset;\n\tstruct drm_modeset_acquire_ctx ctx;\n\tint j;\n\tint ret;\n\n\tDRM_MODESET_LOCK_ALL_BEGIN(dev, ctx, 0, ret);\n\tdrm_client_for_each_modeset(modeset, client) {\n\t\tif (!modeset->crtc->enabled)\n\t\t\tcontinue;\n\n\t\tfor (j = 0; j < modeset->num_connectors; j++) {\n\t\t\tconnector = modeset->connectors[j];\n\t\t\tconnector->funcs->dpms(connector, dpms_mode);\n\t\t\tdrm_object_property_set_value(&connector->base,\n\t\t\t\tdev->mode_config.dpms_property, dpms_mode);\n\t\t}\n\t}\n\tDRM_MODESET_LOCK_ALL_END(dev, ctx, ret);\n}\n\n \nint drm_client_modeset_dpms(struct drm_client_dev *client, int mode)\n{\n\tstruct drm_device *dev = client->dev;\n\tint ret = 0;\n\n\tif (!drm_master_internal_acquire(dev))\n\t\treturn -EBUSY;\n\n\tmutex_lock(&client->modeset_mutex);\n\tif (drm_drv_uses_atomic_modeset(dev))\n\t\tret = drm_client_modeset_commit_atomic(client, mode == DRM_MODE_DPMS_ON, false);\n\telse\n\t\tdrm_client_modeset_dpms_legacy(client, mode);\n\tmutex_unlock(&client->modeset_mutex);\n\n\tdrm_master_internal_release(dev);\n\n\treturn ret;\n}\nEXPORT_SYMBOL(drm_client_modeset_dpms);\n\n#ifdef CONFIG_DRM_KUNIT_TEST\n#include \"tests/drm_client_modeset_test.c\"\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}