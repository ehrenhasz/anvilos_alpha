{
  "module_name": "drm_ioc32.c",
  "hash_id": "516f61188f2d2ccd685262b62e5b3c9537b06f4646697b4cdb2becc4c0f8a53c",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/drm_ioc32.c",
  "human_readable_source": " \n#include <linux/compat.h>\n#include <linux/ratelimit.h>\n#include <linux/export.h>\n\n#include <drm/drm_file.h>\n#include <drm/drm_print.h>\n\n#include \"drm_crtc_internal.h\"\n#include \"drm_internal.h\"\n#include \"drm_legacy.h\"\n\n#define DRM_IOCTL_VERSION32\t\tDRM_IOWR(0x00, drm_version32_t)\n#define DRM_IOCTL_GET_UNIQUE32\t\tDRM_IOWR(0x01, drm_unique32_t)\n#define DRM_IOCTL_GET_MAP32\t\tDRM_IOWR(0x04, drm_map32_t)\n#define DRM_IOCTL_GET_CLIENT32\t\tDRM_IOWR(0x05, drm_client32_t)\n#define DRM_IOCTL_GET_STATS32\t\tDRM_IOR( 0x06, drm_stats32_t)\n\n#define DRM_IOCTL_SET_UNIQUE32\t\tDRM_IOW( 0x10, drm_unique32_t)\n#define DRM_IOCTL_ADD_MAP32\t\tDRM_IOWR(0x15, drm_map32_t)\n#define DRM_IOCTL_ADD_BUFS32\t\tDRM_IOWR(0x16, drm_buf_desc32_t)\n#define DRM_IOCTL_MARK_BUFS32\t\tDRM_IOW( 0x17, drm_buf_desc32_t)\n#define DRM_IOCTL_INFO_BUFS32\t\tDRM_IOWR(0x18, drm_buf_info32_t)\n#define DRM_IOCTL_MAP_BUFS32\t\tDRM_IOWR(0x19, drm_buf_map32_t)\n#define DRM_IOCTL_FREE_BUFS32\t\tDRM_IOW( 0x1a, drm_buf_free32_t)\n\n#define DRM_IOCTL_RM_MAP32\t\tDRM_IOW( 0x1b, drm_map32_t)\n\n#define DRM_IOCTL_SET_SAREA_CTX32\tDRM_IOW( 0x1c, drm_ctx_priv_map32_t)\n#define DRM_IOCTL_GET_SAREA_CTX32\tDRM_IOWR(0x1d, drm_ctx_priv_map32_t)\n\n#define DRM_IOCTL_RES_CTX32\t\tDRM_IOWR(0x26, drm_ctx_res32_t)\n#define DRM_IOCTL_DMA32\t\t\tDRM_IOWR(0x29, drm_dma32_t)\n\n#define DRM_IOCTL_AGP_ENABLE32\t\tDRM_IOW( 0x32, drm_agp_mode32_t)\n#define DRM_IOCTL_AGP_INFO32\t\tDRM_IOR( 0x33, drm_agp_info32_t)\n#define DRM_IOCTL_AGP_ALLOC32\t\tDRM_IOWR(0x34, drm_agp_buffer32_t)\n#define DRM_IOCTL_AGP_FREE32\t\tDRM_IOW( 0x35, drm_agp_buffer32_t)\n#define DRM_IOCTL_AGP_BIND32\t\tDRM_IOW( 0x36, drm_agp_binding32_t)\n#define DRM_IOCTL_AGP_UNBIND32\t\tDRM_IOW( 0x37, drm_agp_binding32_t)\n\n#define DRM_IOCTL_SG_ALLOC32\t\tDRM_IOW( 0x38, drm_scatter_gather32_t)\n#define DRM_IOCTL_SG_FREE32\t\tDRM_IOW( 0x39, drm_scatter_gather32_t)\n\n#define DRM_IOCTL_UPDATE_DRAW32\t\tDRM_IOW( 0x3f, drm_update_draw32_t)\n\n#define DRM_IOCTL_WAIT_VBLANK32\t\tDRM_IOWR(0x3a, drm_wait_vblank32_t)\n\n#define DRM_IOCTL_MODE_ADDFB232\t\tDRM_IOWR(0xb8, drm_mode_fb_cmd232_t)\n\ntypedef struct drm_version_32 {\n\tint version_major;\t   \n\tint version_minor;\t   \n\tint version_patchlevel;\t    \n\tu32 name_len;\t\t   \n\tu32 name;\t\t   \n\tu32 date_len;\t\t   \n\tu32 date;\t\t   \n\tu32 desc_len;\t\t   \n\tu32 desc;\t\t   \n} drm_version32_t;\n\nstatic int compat_drm_version(struct file *file, unsigned int cmd,\n\t\t\t      unsigned long arg)\n{\n\tdrm_version32_t v32;\n\tstruct drm_version v;\n\tint err;\n\n\tif (copy_from_user(&v32, (void __user *)arg, sizeof(v32)))\n\t\treturn -EFAULT;\n\n\tmemset(&v, 0, sizeof(v));\n\n\tv = (struct drm_version) {\n\t\t.name_len = v32.name_len,\n\t\t.name = compat_ptr(v32.name),\n\t\t.date_len = v32.date_len,\n\t\t.date = compat_ptr(v32.date),\n\t\t.desc_len = v32.desc_len,\n\t\t.desc = compat_ptr(v32.desc),\n\t};\n\terr = drm_ioctl_kernel(file, drm_version, &v,\n\t\t\t       DRM_RENDER_ALLOW);\n\tif (err)\n\t\treturn err;\n\n\tv32.version_major = v.version_major;\n\tv32.version_minor = v.version_minor;\n\tv32.version_patchlevel = v.version_patchlevel;\n\tv32.name_len = v.name_len;\n\tv32.date_len = v.date_len;\n\tv32.desc_len = v.desc_len;\n\tif (copy_to_user((void __user *)arg, &v32, sizeof(v32)))\n\t\treturn -EFAULT;\n\treturn 0;\n}\n\ntypedef struct drm_unique32 {\n\tu32 unique_len;\t \n\tu32 unique;\t \n} drm_unique32_t;\n\nstatic int compat_drm_getunique(struct file *file, unsigned int cmd,\n\t\t\t\tunsigned long arg)\n{\n\tdrm_unique32_t uq32;\n\tstruct drm_unique uq;\n\tint err;\n\n\tif (copy_from_user(&uq32, (void __user *)arg, sizeof(uq32)))\n\t\treturn -EFAULT;\n\n\tmemset(&uq, 0, sizeof(uq));\n\n\tuq = (struct drm_unique){\n\t\t.unique_len = uq32.unique_len,\n\t\t.unique = compat_ptr(uq32.unique),\n\t};\n\n\terr = drm_ioctl_kernel(file, drm_getunique, &uq, 0);\n\tif (err)\n\t\treturn err;\n\n\tuq32.unique_len = uq.unique_len;\n\tif (copy_to_user((void __user *)arg, &uq32, sizeof(uq32)))\n\t\treturn -EFAULT;\n\treturn 0;\n}\n\nstatic int compat_drm_setunique(struct file *file, unsigned int cmd,\n\t\t\t\tunsigned long arg)\n{\n\t \n\treturn -EINVAL;\n}\n\n#if IS_ENABLED(CONFIG_DRM_LEGACY)\ntypedef struct drm_map32 {\n\tu32 offset;\t\t \n\tu32 size;\t\t \n\tenum drm_map_type type;\t \n\tenum drm_map_flags flags;\t \n\tu32 handle;\t\t \n\tint mtrr;\t\t \n} drm_map32_t;\n\nstatic int compat_drm_getmap(struct file *file, unsigned int cmd,\n\t\t\t     unsigned long arg)\n{\n\tdrm_map32_t __user *argp = (void __user *)arg;\n\tdrm_map32_t m32;\n\tstruct drm_map map;\n\tint err;\n\n\tif (copy_from_user(&m32, argp, sizeof(m32)))\n\t\treturn -EFAULT;\n\n\tmap.offset = m32.offset;\n\terr = drm_ioctl_kernel(file, drm_legacy_getmap_ioctl, &map, 0);\n\tif (err)\n\t\treturn err;\n\n\tm32.offset = map.offset;\n\tm32.size = map.size;\n\tm32.type = map.type;\n\tm32.flags = map.flags;\n\tm32.handle = ptr_to_compat((void __user *)map.handle);\n\tm32.mtrr = map.mtrr;\n\tif (copy_to_user(argp, &m32, sizeof(m32)))\n\t\treturn -EFAULT;\n\treturn 0;\n\n}\n\nstatic int compat_drm_addmap(struct file *file, unsigned int cmd,\n\t\t\t     unsigned long arg)\n{\n\tdrm_map32_t __user *argp = (void __user *)arg;\n\tdrm_map32_t m32;\n\tstruct drm_map map;\n\tint err;\n\n\tif (copy_from_user(&m32, argp, sizeof(m32)))\n\t\treturn -EFAULT;\n\n\tmap.offset = m32.offset;\n\tmap.size = m32.size;\n\tmap.type = m32.type;\n\tmap.flags = m32.flags;\n\n\terr = drm_ioctl_kernel(file, drm_legacy_addmap_ioctl, &map,\n\t\t\t\tDRM_AUTH|DRM_MASTER|DRM_ROOT_ONLY);\n\tif (err)\n\t\treturn err;\n\n\tm32.offset = map.offset;\n\tm32.mtrr = map.mtrr;\n\tm32.handle = ptr_to_compat((void __user *)map.handle);\n\tif (map.handle != compat_ptr(m32.handle))\n\t\tpr_err_ratelimited(\"compat_drm_addmap truncated handle %p for type %d offset %x\\n\",\n\t\t\t\t   map.handle, m32.type, m32.offset);\n\n\tif (copy_to_user(argp, &m32, sizeof(m32)))\n\t\treturn -EFAULT;\n\n\treturn 0;\n}\n\nstatic int compat_drm_rmmap(struct file *file, unsigned int cmd,\n\t\t\t    unsigned long arg)\n{\n\tdrm_map32_t __user *argp = (void __user *)arg;\n\tstruct drm_map map;\n\tu32 handle;\n\n\tif (get_user(handle, &argp->handle))\n\t\treturn -EFAULT;\n\tmap.handle = compat_ptr(handle);\n\treturn drm_ioctl_kernel(file, drm_legacy_rmmap_ioctl, &map, DRM_AUTH);\n}\n#endif\n\ntypedef struct drm_client32 {\n\tint idx;\t \n\tint auth;\t \n\tu32 pid;\t \n\tu32 uid;\t \n\tu32 magic;\t \n\tu32 iocs;\t \n} drm_client32_t;\n\nstatic int compat_drm_getclient(struct file *file, unsigned int cmd,\n\t\t\t\tunsigned long arg)\n{\n\tdrm_client32_t c32;\n\tdrm_client32_t __user *argp = (void __user *)arg;\n\tstruct drm_client client;\n\tint err;\n\n\tif (copy_from_user(&c32, argp, sizeof(c32)))\n\t\treturn -EFAULT;\n\n\tmemset(&client, 0, sizeof(client));\n\n\tclient.idx = c32.idx;\n\n\terr = drm_ioctl_kernel(file, drm_getclient, &client, 0);\n\tif (err)\n\t\treturn err;\n\n\tc32.idx = client.idx;\n\tc32.auth = client.auth;\n\tc32.pid = client.pid;\n\tc32.uid = client.uid;\n\tc32.magic = client.magic;\n\tc32.iocs = client.iocs;\n\n\tif (copy_to_user(argp, &c32, sizeof(c32)))\n\t\treturn -EFAULT;\n\treturn 0;\n}\n\ntypedef struct drm_stats32 {\n\tu32 count;\n\tstruct {\n\t\tu32 value;\n\t\tenum drm_stat_type type;\n\t} data[15];\n} drm_stats32_t;\n\nstatic int compat_drm_getstats(struct file *file, unsigned int cmd,\n\t\t\t       unsigned long arg)\n{\n\tdrm_stats32_t __user *argp = (void __user *)arg;\n\n\t \n\tif (clear_user(argp, sizeof(drm_stats32_t)))\n\t\treturn -EFAULT;\n\treturn 0;\n}\n\n#if IS_ENABLED(CONFIG_DRM_LEGACY)\ntypedef struct drm_buf_desc32 {\n\tint count;\t\t  \n\tint size;\t\t  \n\tint low_mark;\t\t  \n\tint high_mark;\t\t  \n\tint flags;\n\tu32 agp_start;\t\t  \n} drm_buf_desc32_t;\n\nstatic int compat_drm_addbufs(struct file *file, unsigned int cmd,\n\t\t\t      unsigned long arg)\n{\n\tdrm_buf_desc32_t __user *argp = (void __user *)arg;\n\tdrm_buf_desc32_t desc32;\n\tstruct drm_buf_desc desc;\n\tint err;\n\n\tif (copy_from_user(&desc32, argp, sizeof(drm_buf_desc32_t)))\n\t\treturn -EFAULT;\n\n\tdesc = (struct drm_buf_desc){\n\t\tdesc32.count, desc32.size, desc32.low_mark, desc32.high_mark,\n\t\tdesc32.flags, desc32.agp_start\n\t};\n\n\terr = drm_ioctl_kernel(file, drm_legacy_addbufs, &desc,\n\t\t\t\t   DRM_AUTH|DRM_MASTER|DRM_ROOT_ONLY);\n\tif (err)\n\t\treturn err;\n\n\tdesc32 = (drm_buf_desc32_t){\n\t\tdesc.count, desc.size, desc.low_mark, desc.high_mark,\n\t\tdesc.flags, desc.agp_start\n\t};\n\tif (copy_to_user(argp, &desc32, sizeof(drm_buf_desc32_t)))\n\t\treturn -EFAULT;\n\n\treturn 0;\n}\n\nstatic int compat_drm_markbufs(struct file *file, unsigned int cmd,\n\t\t\t       unsigned long arg)\n{\n\tdrm_buf_desc32_t b32;\n\tdrm_buf_desc32_t __user *argp = (void __user *)arg;\n\tstruct drm_buf_desc buf;\n\n\tif (copy_from_user(&b32, argp, sizeof(b32)))\n\t\treturn -EFAULT;\n\n\tbuf.size = b32.size;\n\tbuf.low_mark = b32.low_mark;\n\tbuf.high_mark = b32.high_mark;\n\n\treturn drm_ioctl_kernel(file, drm_legacy_markbufs, &buf,\n\t\t\t\tDRM_AUTH|DRM_MASTER|DRM_ROOT_ONLY);\n}\n\ntypedef struct drm_buf_info32 {\n\tint count;\t\t \n\tu32 list;\n} drm_buf_info32_t;\n\nstatic int copy_one_buf32(void *data, int count, struct drm_buf_entry *from)\n{\n\tdrm_buf_info32_t *request = data;\n\tdrm_buf_desc32_t __user *to = compat_ptr(request->list);\n\tdrm_buf_desc32_t v = {.count = from->buf_count,\n\t\t\t      .size = from->buf_size,\n\t\t\t      .low_mark = from->low_mark,\n\t\t\t      .high_mark = from->high_mark};\n\n\tif (copy_to_user(to + count, &v, offsetof(drm_buf_desc32_t, flags)))\n\t\treturn -EFAULT;\n\treturn 0;\n}\n\nstatic int drm_legacy_infobufs32(struct drm_device *dev, void *data,\n\t\t\tstruct drm_file *file_priv)\n{\n\tdrm_buf_info32_t *request = data;\n\n\treturn __drm_legacy_infobufs(dev, data, &request->count, copy_one_buf32);\n}\n\nstatic int compat_drm_infobufs(struct file *file, unsigned int cmd,\n\t\t\t       unsigned long arg)\n{\n\tdrm_buf_info32_t req32;\n\tdrm_buf_info32_t __user *argp = (void __user *)arg;\n\tint err;\n\n\tif (copy_from_user(&req32, argp, sizeof(req32)))\n\t\treturn -EFAULT;\n\n\tif (req32.count < 0)\n\t\treq32.count = 0;\n\n\terr = drm_ioctl_kernel(file, drm_legacy_infobufs32, &req32, DRM_AUTH);\n\tif (err)\n\t\treturn err;\n\n\tif (put_user(req32.count, &argp->count))\n\t\treturn -EFAULT;\n\n\treturn 0;\n}\n\ntypedef struct drm_buf_pub32 {\n\tint idx;\t\t \n\tint total;\t\t \n\tint used;\t\t \n\tu32 address;\t\t \n} drm_buf_pub32_t;\n\ntypedef struct drm_buf_map32 {\n\tint count;\t\t \n\tu32 virtual;\t\t \n\tu32 list;\t\t \n} drm_buf_map32_t;\n\nstatic int map_one_buf32(void *data, int idx, unsigned long virtual,\n\t\t\tstruct drm_buf *buf)\n{\n\tdrm_buf_map32_t *request = data;\n\tdrm_buf_pub32_t __user *to = compat_ptr(request->list) + idx;\n\tdrm_buf_pub32_t v;\n\n\tv.idx = buf->idx;\n\tv.total = buf->total;\n\tv.used = 0;\n\tv.address = virtual + buf->offset;\n\tif (copy_to_user(to, &v, sizeof(v)))\n\t\treturn -EFAULT;\n\treturn 0;\n}\n\nstatic int drm_legacy_mapbufs32(struct drm_device *dev, void *data,\n\t\t       struct drm_file *file_priv)\n{\n\tdrm_buf_map32_t *request = data;\n\tvoid __user *v;\n\tint err = __drm_legacy_mapbufs(dev, data, &request->count,\n\t\t\t\t    &v, map_one_buf32,\n\t\t\t\t    file_priv);\n\trequest->virtual = ptr_to_compat(v);\n\treturn err;\n}\n\nstatic int compat_drm_mapbufs(struct file *file, unsigned int cmd,\n\t\t\t      unsigned long arg)\n{\n\tdrm_buf_map32_t __user *argp = (void __user *)arg;\n\tdrm_buf_map32_t req32;\n\tint err;\n\n\tif (copy_from_user(&req32, argp, sizeof(req32)))\n\t\treturn -EFAULT;\n\tif (req32.count < 0)\n\t\treturn -EINVAL;\n\n\terr = drm_ioctl_kernel(file, drm_legacy_mapbufs32, &req32, DRM_AUTH);\n\tif (err)\n\t\treturn err;\n\n\tif (put_user(req32.count, &argp->count)\n\t    || put_user(req32.virtual, &argp->virtual))\n\t\treturn -EFAULT;\n\n\treturn 0;\n}\n\ntypedef struct drm_buf_free32 {\n\tint count;\n\tu32 list;\n} drm_buf_free32_t;\n\nstatic int compat_drm_freebufs(struct file *file, unsigned int cmd,\n\t\t\t       unsigned long arg)\n{\n\tdrm_buf_free32_t req32;\n\tstruct drm_buf_free request;\n\tdrm_buf_free32_t __user *argp = (void __user *)arg;\n\n\tif (copy_from_user(&req32, argp, sizeof(req32)))\n\t\treturn -EFAULT;\n\n\trequest.count = req32.count;\n\trequest.list = compat_ptr(req32.list);\n\treturn drm_ioctl_kernel(file, drm_legacy_freebufs, &request, DRM_AUTH);\n}\n\ntypedef struct drm_ctx_priv_map32 {\n\tunsigned int ctx_id;\t  \n\tu32 handle;\t\t \n} drm_ctx_priv_map32_t;\n\nstatic int compat_drm_setsareactx(struct file *file, unsigned int cmd,\n\t\t\t\t  unsigned long arg)\n{\n\tdrm_ctx_priv_map32_t req32;\n\tstruct drm_ctx_priv_map request;\n\tdrm_ctx_priv_map32_t __user *argp = (void __user *)arg;\n\n\tif (copy_from_user(&req32, argp, sizeof(req32)))\n\t\treturn -EFAULT;\n\n\trequest.ctx_id = req32.ctx_id;\n\trequest.handle = compat_ptr(req32.handle);\n\treturn drm_ioctl_kernel(file, drm_legacy_setsareactx, &request,\n\t\t\t\tDRM_AUTH|DRM_MASTER|DRM_ROOT_ONLY);\n}\n\nstatic int compat_drm_getsareactx(struct file *file, unsigned int cmd,\n\t\t\t\t  unsigned long arg)\n{\n\tstruct drm_ctx_priv_map req;\n\tdrm_ctx_priv_map32_t req32;\n\tdrm_ctx_priv_map32_t __user *argp = (void __user *)arg;\n\tint err;\n\n\tif (copy_from_user(&req32, argp, sizeof(req32)))\n\t\treturn -EFAULT;\n\n\treq.ctx_id = req32.ctx_id;\n\terr = drm_ioctl_kernel(file, drm_legacy_getsareactx, &req, DRM_AUTH);\n\tif (err)\n\t\treturn err;\n\n\treq32.handle = ptr_to_compat((void __user *)req.handle);\n\tif (copy_to_user(argp, &req32, sizeof(req32)))\n\t\treturn -EFAULT;\n\n\treturn 0;\n}\n\ntypedef struct drm_ctx_res32 {\n\tint count;\n\tu32 contexts;\n} drm_ctx_res32_t;\n\nstatic int compat_drm_resctx(struct file *file, unsigned int cmd,\n\t\t\t     unsigned long arg)\n{\n\tdrm_ctx_res32_t __user *argp = (void __user *)arg;\n\tdrm_ctx_res32_t res32;\n\tstruct drm_ctx_res res;\n\tint err;\n\n\tif (copy_from_user(&res32, argp, sizeof(res32)))\n\t\treturn -EFAULT;\n\n\tres.count = res32.count;\n\tres.contexts = compat_ptr(res32.contexts);\n\terr = drm_ioctl_kernel(file, drm_legacy_resctx, &res, DRM_AUTH);\n\tif (err)\n\t\treturn err;\n\n\tres32.count = res.count;\n\tif (copy_to_user(argp, &res32, sizeof(res32)))\n\t\treturn -EFAULT;\n\n\treturn 0;\n}\n\ntypedef struct drm_dma32 {\n\tint context;\t\t   \n\tint send_count;\t\t   \n\tu32 send_indices;\t   \n\tu32 send_sizes;\t\t   \n\tenum drm_dma_flags flags;\t\t   \n\tint request_count;\t   \n\tint request_size;\t   \n\tu32 request_indices;\t   \n\tu32 request_sizes;\n\tint granted_count;\t   \n} drm_dma32_t;\n\nstatic int compat_drm_dma(struct file *file, unsigned int cmd,\n\t\t\t  unsigned long arg)\n{\n\tdrm_dma32_t d32;\n\tdrm_dma32_t __user *argp = (void __user *)arg;\n\tstruct drm_dma d;\n\tint err;\n\n\tif (copy_from_user(&d32, argp, sizeof(d32)))\n\t\treturn -EFAULT;\n\n\td.context = d32.context;\n\td.send_count = d32.send_count;\n\td.send_indices = compat_ptr(d32.send_indices);\n\td.send_sizes = compat_ptr(d32.send_sizes);\n\td.flags = d32.flags;\n\td.request_count = d32.request_count;\n\td.request_indices = compat_ptr(d32.request_indices);\n\td.request_sizes = compat_ptr(d32.request_sizes);\n\terr = drm_ioctl_kernel(file, drm_legacy_dma_ioctl, &d, DRM_AUTH);\n\tif (err)\n\t\treturn err;\n\n\tif (put_user(d.request_size, &argp->request_size)\n\t    || put_user(d.granted_count, &argp->granted_count))\n\t\treturn -EFAULT;\n\n\treturn 0;\n}\n#endif\n\n#if IS_ENABLED(CONFIG_DRM_LEGACY)\n#if IS_ENABLED(CONFIG_AGP)\ntypedef struct drm_agp_mode32 {\n\tu32 mode;\t \n} drm_agp_mode32_t;\n\nstatic int compat_drm_agp_enable(struct file *file, unsigned int cmd,\n\t\t\t\t unsigned long arg)\n{\n\tdrm_agp_mode32_t __user *argp = (void __user *)arg;\n\tstruct drm_agp_mode mode;\n\n\tif (get_user(mode.mode, &argp->mode))\n\t\treturn -EFAULT;\n\n\treturn drm_ioctl_kernel(file,  drm_legacy_agp_enable_ioctl, &mode,\n\t\t\t\tDRM_AUTH|DRM_MASTER|DRM_ROOT_ONLY);\n}\n\ntypedef struct drm_agp_info32 {\n\tint agp_version_major;\n\tint agp_version_minor;\n\tu32 mode;\n\tu32 aperture_base;\t \n\tu32 aperture_size;\t \n\tu32 memory_allowed;\t \n\tu32 memory_used;\n\n\t \n\tunsigned short id_vendor;\n\tunsigned short id_device;\n} drm_agp_info32_t;\n\nstatic int compat_drm_agp_info(struct file *file, unsigned int cmd,\n\t\t\t       unsigned long arg)\n{\n\tdrm_agp_info32_t __user *argp = (void __user *)arg;\n\tdrm_agp_info32_t i32;\n\tstruct drm_agp_info info;\n\tint err;\n\n\terr = drm_ioctl_kernel(file, drm_legacy_agp_info_ioctl, &info, DRM_AUTH);\n\tif (err)\n\t\treturn err;\n\n\ti32.agp_version_major = info.agp_version_major;\n\ti32.agp_version_minor = info.agp_version_minor;\n\ti32.mode = info.mode;\n\ti32.aperture_base = info.aperture_base;\n\ti32.aperture_size = info.aperture_size;\n\ti32.memory_allowed = info.memory_allowed;\n\ti32.memory_used = info.memory_used;\n\ti32.id_vendor = info.id_vendor;\n\ti32.id_device = info.id_device;\n\tif (copy_to_user(argp, &i32, sizeof(i32)))\n\t\treturn -EFAULT;\n\n\treturn 0;\n}\n\ntypedef struct drm_agp_buffer32 {\n\tu32 size;\t \n\tu32 handle;\t \n\tu32 type;\t \n\tu32 physical;\t \n} drm_agp_buffer32_t;\n\nstatic int compat_drm_agp_alloc(struct file *file, unsigned int cmd,\n\t\t\t\tunsigned long arg)\n{\n\tdrm_agp_buffer32_t __user *argp = (void __user *)arg;\n\tdrm_agp_buffer32_t req32;\n\tstruct drm_agp_buffer request;\n\tint err;\n\n\tif (copy_from_user(&req32, argp, sizeof(req32)))\n\t\treturn -EFAULT;\n\n\trequest.size = req32.size;\n\trequest.type = req32.type;\n\terr = drm_ioctl_kernel(file, drm_legacy_agp_alloc_ioctl, &request,\n\t\t\t\tDRM_AUTH|DRM_MASTER|DRM_ROOT_ONLY);\n\tif (err)\n\t\treturn err;\n\n\treq32.handle = request.handle;\n\treq32.physical = request.physical;\n\tif (copy_to_user(argp, &req32, sizeof(req32))) {\n\t\tdrm_ioctl_kernel(file, drm_legacy_agp_free_ioctl, &request,\n\t\t\t\tDRM_AUTH|DRM_MASTER|DRM_ROOT_ONLY);\n\t\treturn -EFAULT;\n\t}\n\n\treturn 0;\n}\n\nstatic int compat_drm_agp_free(struct file *file, unsigned int cmd,\n\t\t\t       unsigned long arg)\n{\n\tdrm_agp_buffer32_t __user *argp = (void __user *)arg;\n\tstruct drm_agp_buffer request;\n\n\tif (get_user(request.handle, &argp->handle))\n\t\treturn -EFAULT;\n\n\treturn drm_ioctl_kernel(file, drm_legacy_agp_free_ioctl, &request,\n\t\t\t\tDRM_AUTH|DRM_MASTER|DRM_ROOT_ONLY);\n}\n\ntypedef struct drm_agp_binding32 {\n\tu32 handle;\t \n\tu32 offset;\t \n} drm_agp_binding32_t;\n\nstatic int compat_drm_agp_bind(struct file *file, unsigned int cmd,\n\t\t\t       unsigned long arg)\n{\n\tdrm_agp_binding32_t __user *argp = (void __user *)arg;\n\tdrm_agp_binding32_t req32;\n\tstruct drm_agp_binding request;\n\n\tif (copy_from_user(&req32, argp, sizeof(req32)))\n\t\treturn -EFAULT;\n\n\trequest.handle = req32.handle;\n\trequest.offset = req32.offset;\n\treturn drm_ioctl_kernel(file, drm_legacy_agp_bind_ioctl, &request,\n\t\t\t\tDRM_AUTH|DRM_MASTER|DRM_ROOT_ONLY);\n}\n\nstatic int compat_drm_agp_unbind(struct file *file, unsigned int cmd,\n\t\t\t\t unsigned long arg)\n{\n\tdrm_agp_binding32_t __user *argp = (void __user *)arg;\n\tstruct drm_agp_binding request;\n\n\tif (get_user(request.handle, &argp->handle))\n\t\treturn -EFAULT;\n\n\treturn drm_ioctl_kernel(file, drm_legacy_agp_unbind_ioctl, &request,\n\t\t\t\tDRM_AUTH|DRM_MASTER|DRM_ROOT_ONLY);\n}\n#endif  \n\ntypedef struct drm_scatter_gather32 {\n\tu32 size;\t \n\tu32 handle;\t \n} drm_scatter_gather32_t;\n\nstatic int compat_drm_sg_alloc(struct file *file, unsigned int cmd,\n\t\t\t       unsigned long arg)\n{\n\tdrm_scatter_gather32_t __user *argp = (void __user *)arg;\n\tstruct drm_scatter_gather request;\n\tint err;\n\n\tif (get_user(request.size, &argp->size))\n\t\treturn -EFAULT;\n\n\terr = drm_ioctl_kernel(file, drm_legacy_sg_alloc, &request,\n\t\t\t\tDRM_AUTH|DRM_MASTER|DRM_ROOT_ONLY);\n\tif (err)\n\t\treturn err;\n\n\t \n\tif (put_user(request.handle >> PAGE_SHIFT, &argp->handle))\n\t\treturn -EFAULT;\n\n\treturn 0;\n}\n\nstatic int compat_drm_sg_free(struct file *file, unsigned int cmd,\n\t\t\t      unsigned long arg)\n{\n\tdrm_scatter_gather32_t __user *argp = (void __user *)arg;\n\tstruct drm_scatter_gather request;\n\tunsigned long x;\n\n\tif (get_user(x, &argp->handle))\n\t\treturn -EFAULT;\n\trequest.handle = x << PAGE_SHIFT;\n\treturn drm_ioctl_kernel(file, drm_legacy_sg_free, &request,\n\t\t\t\tDRM_AUTH|DRM_MASTER|DRM_ROOT_ONLY);\n}\n#endif\n#if defined(CONFIG_X86)\ntypedef struct drm_update_draw32 {\n\tdrm_drawable_t handle;\n\tunsigned int type;\n\tunsigned int num;\n\t \n\tu64 data;\t \n} __attribute__((packed)) drm_update_draw32_t;\n\nstatic int compat_drm_update_draw(struct file *file, unsigned int cmd,\n\t\t\t\t  unsigned long arg)\n{\n\t \n\treturn 0;\n}\n#endif\n\nstruct drm_wait_vblank_request32 {\n\tenum drm_vblank_seq_type type;\n\tunsigned int sequence;\n\tu32 signal;\n};\n\nstruct drm_wait_vblank_reply32 {\n\tenum drm_vblank_seq_type type;\n\tunsigned int sequence;\n\ts32 tval_sec;\n\ts32 tval_usec;\n};\n\ntypedef union drm_wait_vblank32 {\n\tstruct drm_wait_vblank_request32 request;\n\tstruct drm_wait_vblank_reply32 reply;\n} drm_wait_vblank32_t;\n\nstatic int compat_drm_wait_vblank(struct file *file, unsigned int cmd,\n\t\t\t\t  unsigned long arg)\n{\n\tdrm_wait_vblank32_t __user *argp = (void __user *)arg;\n\tdrm_wait_vblank32_t req32;\n\tunion drm_wait_vblank req;\n\tint err;\n\n\tif (copy_from_user(&req32, argp, sizeof(req32)))\n\t\treturn -EFAULT;\n\n\tmemset(&req, 0, sizeof(req));\n\n\treq.request.type = req32.request.type;\n\treq.request.sequence = req32.request.sequence;\n\treq.request.signal = req32.request.signal;\n\terr = drm_ioctl_kernel(file, drm_wait_vblank_ioctl, &req, DRM_UNLOCKED);\n\n\treq32.reply.type = req.reply.type;\n\treq32.reply.sequence = req.reply.sequence;\n\treq32.reply.tval_sec = req.reply.tval_sec;\n\treq32.reply.tval_usec = req.reply.tval_usec;\n\tif (copy_to_user(argp, &req32, sizeof(req32)))\n\t\treturn -EFAULT;\n\n\treturn err;\n}\n\n#if defined(CONFIG_X86)\ntypedef struct drm_mode_fb_cmd232 {\n\tu32 fb_id;\n\tu32 width;\n\tu32 height;\n\tu32 pixel_format;\n\tu32 flags;\n\tu32 handles[4];\n\tu32 pitches[4];\n\tu32 offsets[4];\n\tu64 modifier[4];\n} __attribute__((packed)) drm_mode_fb_cmd232_t;\n\nstatic int compat_drm_mode_addfb2(struct file *file, unsigned int cmd,\n\t\t\t\t  unsigned long arg)\n{\n\tstruct drm_mode_fb_cmd232 __user *argp = (void __user *)arg;\n\tstruct drm_mode_fb_cmd2 req64;\n\tint err;\n\n\tmemset(&req64, 0, sizeof(req64));\n\n\tif (copy_from_user(&req64, argp,\n\t\t\t   offsetof(drm_mode_fb_cmd232_t, modifier)))\n\t\treturn -EFAULT;\n\n\tif (copy_from_user(&req64.modifier, &argp->modifier,\n\t\t\t   sizeof(req64.modifier)))\n\t\treturn -EFAULT;\n\n\terr = drm_ioctl_kernel(file, drm_mode_addfb2, &req64, 0);\n\tif (err)\n\t\treturn err;\n\n\tif (put_user(req64.fb_id, &argp->fb_id))\n\t\treturn -EFAULT;\n\n\treturn 0;\n}\n#endif\n\nstatic struct {\n\tdrm_ioctl_compat_t *fn;\n\tchar *name;\n} drm_compat_ioctls[] = {\n#define DRM_IOCTL32_DEF(n, f) [DRM_IOCTL_NR(n##32)] = {.fn = f, .name = #n}\n\tDRM_IOCTL32_DEF(DRM_IOCTL_VERSION, compat_drm_version),\n\tDRM_IOCTL32_DEF(DRM_IOCTL_GET_UNIQUE, compat_drm_getunique),\n#if IS_ENABLED(CONFIG_DRM_LEGACY)\n\tDRM_IOCTL32_DEF(DRM_IOCTL_GET_MAP, compat_drm_getmap),\n#endif\n\tDRM_IOCTL32_DEF(DRM_IOCTL_GET_CLIENT, compat_drm_getclient),\n\tDRM_IOCTL32_DEF(DRM_IOCTL_GET_STATS, compat_drm_getstats),\n\tDRM_IOCTL32_DEF(DRM_IOCTL_SET_UNIQUE, compat_drm_setunique),\n#if IS_ENABLED(CONFIG_DRM_LEGACY)\n\tDRM_IOCTL32_DEF(DRM_IOCTL_ADD_MAP, compat_drm_addmap),\n\tDRM_IOCTL32_DEF(DRM_IOCTL_ADD_BUFS, compat_drm_addbufs),\n\tDRM_IOCTL32_DEF(DRM_IOCTL_MARK_BUFS, compat_drm_markbufs),\n\tDRM_IOCTL32_DEF(DRM_IOCTL_INFO_BUFS, compat_drm_infobufs),\n\tDRM_IOCTL32_DEF(DRM_IOCTL_MAP_BUFS, compat_drm_mapbufs),\n\tDRM_IOCTL32_DEF(DRM_IOCTL_FREE_BUFS, compat_drm_freebufs),\n\tDRM_IOCTL32_DEF(DRM_IOCTL_RM_MAP, compat_drm_rmmap),\n\tDRM_IOCTL32_DEF(DRM_IOCTL_SET_SAREA_CTX, compat_drm_setsareactx),\n\tDRM_IOCTL32_DEF(DRM_IOCTL_GET_SAREA_CTX, compat_drm_getsareactx),\n\tDRM_IOCTL32_DEF(DRM_IOCTL_RES_CTX, compat_drm_resctx),\n\tDRM_IOCTL32_DEF(DRM_IOCTL_DMA, compat_drm_dma),\n#if IS_ENABLED(CONFIG_AGP)\n\tDRM_IOCTL32_DEF(DRM_IOCTL_AGP_ENABLE, compat_drm_agp_enable),\n\tDRM_IOCTL32_DEF(DRM_IOCTL_AGP_INFO, compat_drm_agp_info),\n\tDRM_IOCTL32_DEF(DRM_IOCTL_AGP_ALLOC, compat_drm_agp_alloc),\n\tDRM_IOCTL32_DEF(DRM_IOCTL_AGP_FREE, compat_drm_agp_free),\n\tDRM_IOCTL32_DEF(DRM_IOCTL_AGP_BIND, compat_drm_agp_bind),\n\tDRM_IOCTL32_DEF(DRM_IOCTL_AGP_UNBIND, compat_drm_agp_unbind),\n#endif\n#endif\n#if IS_ENABLED(CONFIG_DRM_LEGACY)\n\tDRM_IOCTL32_DEF(DRM_IOCTL_SG_ALLOC, compat_drm_sg_alloc),\n\tDRM_IOCTL32_DEF(DRM_IOCTL_SG_FREE, compat_drm_sg_free),\n#endif\n#if defined(CONFIG_X86) || defined(CONFIG_IA64)\n\tDRM_IOCTL32_DEF(DRM_IOCTL_UPDATE_DRAW, compat_drm_update_draw),\n#endif\n\tDRM_IOCTL32_DEF(DRM_IOCTL_WAIT_VBLANK, compat_drm_wait_vblank),\n#if defined(CONFIG_X86) || defined(CONFIG_IA64)\n\tDRM_IOCTL32_DEF(DRM_IOCTL_MODE_ADDFB2, compat_drm_mode_addfb2),\n#endif\n};\n\n \nlong drm_compat_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)\n{\n\tunsigned int nr = DRM_IOCTL_NR(cmd);\n\tstruct drm_file *file_priv = filp->private_data;\n\tstruct drm_device *dev = file_priv->minor->dev;\n\tdrm_ioctl_compat_t *fn;\n\tint ret;\n\n\t \n\tif (nr >= ARRAY_SIZE(drm_compat_ioctls))\n\t\treturn drm_ioctl(filp, cmd, arg);\n\n\tfn = drm_compat_ioctls[nr].fn;\n\tif (!fn)\n\t\treturn drm_ioctl(filp, cmd, arg);\n\n\tdrm_dbg_core(dev, \"comm=\\\"%s\\\", pid=%d, dev=0x%lx, auth=%d, %s\\n\",\n\t\t     current->comm, task_pid_nr(current),\n\t\t     (long)old_encode_dev(file_priv->minor->kdev->devt),\n\t\t     file_priv->authenticated,\n\t\t     drm_compat_ioctls[nr].name);\n\tret = (*fn)(filp, cmd, arg);\n\tif (ret)\n\t\tdrm_dbg_core(dev, \"ret = %d\\n\", ret);\n\treturn ret;\n}\nEXPORT_SYMBOL(drm_compat_ioctl);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}