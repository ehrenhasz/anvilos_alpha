{
  "module_name": "drm_mipi_dbi.c",
  "hash_id": "273c510cff0a6d3f25a948280c561de470cd6882ec0d3ed83fa0ce53d5f80f33",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/drm_mipi_dbi.c",
  "human_readable_source": "\n \n\n#include <linux/backlight.h>\n#include <linux/debugfs.h>\n#include <linux/delay.h>\n#include <linux/gpio/consumer.h>\n#include <linux/module.h>\n#include <linux/regulator/consumer.h>\n#include <linux/spi/spi.h>\n\n#include <drm/drm_connector.h>\n#include <drm/drm_damage_helper.h>\n#include <drm/drm_drv.h>\n#include <drm/drm_file.h>\n#include <drm/drm_format_helper.h>\n#include <drm/drm_fourcc.h>\n#include <drm/drm_framebuffer.h>\n#include <drm/drm_gem.h>\n#include <drm/drm_gem_atomic_helper.h>\n#include <drm/drm_gem_framebuffer_helper.h>\n#include <drm/drm_mipi_dbi.h>\n#include <drm/drm_modes.h>\n#include <drm/drm_probe_helper.h>\n#include <drm/drm_rect.h>\n#include <video/mipi_display.h>\n\n#define MIPI_DBI_MAX_SPI_READ_SPEED 2000000  \n\n#define DCS_POWER_MODE_DISPLAY\t\t\tBIT(2)\n#define DCS_POWER_MODE_DISPLAY_NORMAL_MODE\tBIT(3)\n#define DCS_POWER_MODE_SLEEP_MODE\t\tBIT(4)\n#define DCS_POWER_MODE_PARTIAL_MODE\t\tBIT(5)\n#define DCS_POWER_MODE_IDLE_MODE\t\tBIT(6)\n#define DCS_POWER_MODE_RESERVED_MASK\t\t(BIT(0) | BIT(1) | BIT(7))\n\n \n\n#define MIPI_DBI_DEBUG_COMMAND(cmd, data, len) \\\n({ \\\n\tif (!len) \\\n\t\tDRM_DEBUG_DRIVER(\"cmd=%02x\\n\", cmd); \\\n\telse if (len <= 32) \\\n\t\tDRM_DEBUG_DRIVER(\"cmd=%02x, par=%*ph\\n\", cmd, (int)len, data);\\\n\telse \\\n\t\tDRM_DEBUG_DRIVER(\"cmd=%02x, len=%zu\\n\", cmd, len); \\\n})\n\nstatic const u8 mipi_dbi_dcs_read_commands[] = {\n\tMIPI_DCS_GET_DISPLAY_ID,\n\tMIPI_DCS_GET_RED_CHANNEL,\n\tMIPI_DCS_GET_GREEN_CHANNEL,\n\tMIPI_DCS_GET_BLUE_CHANNEL,\n\tMIPI_DCS_GET_DISPLAY_STATUS,\n\tMIPI_DCS_GET_POWER_MODE,\n\tMIPI_DCS_GET_ADDRESS_MODE,\n\tMIPI_DCS_GET_PIXEL_FORMAT,\n\tMIPI_DCS_GET_DISPLAY_MODE,\n\tMIPI_DCS_GET_SIGNAL_MODE,\n\tMIPI_DCS_GET_DIAGNOSTIC_RESULT,\n\tMIPI_DCS_READ_MEMORY_START,\n\tMIPI_DCS_READ_MEMORY_CONTINUE,\n\tMIPI_DCS_GET_SCANLINE,\n\tMIPI_DCS_GET_DISPLAY_BRIGHTNESS,\n\tMIPI_DCS_GET_CONTROL_DISPLAY,\n\tMIPI_DCS_GET_POWER_SAVE,\n\tMIPI_DCS_GET_CABC_MIN_BRIGHTNESS,\n\tMIPI_DCS_READ_DDB_START,\n\tMIPI_DCS_READ_DDB_CONTINUE,\n\t0,  \n};\n\nstatic bool mipi_dbi_command_is_read(struct mipi_dbi *dbi, u8 cmd)\n{\n\tunsigned int i;\n\n\tif (!dbi->read_commands)\n\t\treturn false;\n\n\tfor (i = 0; i < 0xff; i++) {\n\t\tif (!dbi->read_commands[i])\n\t\t\treturn false;\n\t\tif (cmd == dbi->read_commands[i])\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}\n\n \nint mipi_dbi_command_read(struct mipi_dbi *dbi, u8 cmd, u8 *val)\n{\n\tif (!dbi->read_commands)\n\t\treturn -EACCES;\n\n\tif (!mipi_dbi_command_is_read(dbi, cmd))\n\t\treturn -EINVAL;\n\n\treturn mipi_dbi_command_buf(dbi, cmd, val, 1);\n}\nEXPORT_SYMBOL(mipi_dbi_command_read);\n\n \nint mipi_dbi_command_buf(struct mipi_dbi *dbi, u8 cmd, u8 *data, size_t len)\n{\n\tu8 *cmdbuf;\n\tint ret;\n\n\t \n\tcmdbuf = kmemdup(&cmd, 1, GFP_KERNEL);\n\tif (!cmdbuf)\n\t\treturn -ENOMEM;\n\n\tmutex_lock(&dbi->cmdlock);\n\tret = dbi->command(dbi, cmdbuf, data, len);\n\tmutex_unlock(&dbi->cmdlock);\n\n\tkfree(cmdbuf);\n\n\treturn ret;\n}\nEXPORT_SYMBOL(mipi_dbi_command_buf);\n\n \nint mipi_dbi_command_stackbuf(struct mipi_dbi *dbi, u8 cmd, const u8 *data,\n\t\t\t      size_t len)\n{\n\tu8 *buf;\n\tint ret;\n\n\tbuf = kmemdup(data, len, GFP_KERNEL);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\tret = mipi_dbi_command_buf(dbi, cmd, buf, len);\n\n\tkfree(buf);\n\n\treturn ret;\n}\nEXPORT_SYMBOL(mipi_dbi_command_stackbuf);\n\n \nint mipi_dbi_buf_copy(void *dst, struct iosys_map *src, struct drm_framebuffer *fb,\n\t\t      struct drm_rect *clip, bool swap)\n{\n\tstruct drm_gem_object *gem = drm_gem_fb_get_obj(fb, 0);\n\tstruct iosys_map dst_map = IOSYS_MAP_INIT_VADDR(dst);\n\tint ret;\n\n\tret = drm_gem_fb_begin_cpu_access(fb, DMA_FROM_DEVICE);\n\tif (ret)\n\t\treturn ret;\n\n\tswitch (fb->format->format) {\n\tcase DRM_FORMAT_RGB565:\n\t\tif (swap)\n\t\t\tdrm_fb_swab(&dst_map, NULL, src, fb, clip, !gem->import_attach);\n\t\telse\n\t\t\tdrm_fb_memcpy(&dst_map, NULL, src, fb, clip);\n\t\tbreak;\n\tcase DRM_FORMAT_XRGB8888:\n\t\tdrm_fb_xrgb8888_to_rgb565(&dst_map, NULL, src, fb, clip, swap);\n\t\tbreak;\n\tdefault:\n\t\tdrm_err_once(fb->dev, \"Format is not supported: %p4cc\\n\",\n\t\t\t     &fb->format->format);\n\t\tret = -EINVAL;\n\t}\n\n\tdrm_gem_fb_end_cpu_access(fb, DMA_FROM_DEVICE);\n\n\treturn ret;\n}\nEXPORT_SYMBOL(mipi_dbi_buf_copy);\n\nstatic void mipi_dbi_set_window_address(struct mipi_dbi_dev *dbidev,\n\t\t\t\t\tunsigned int xs, unsigned int xe,\n\t\t\t\t\tunsigned int ys, unsigned int ye)\n{\n\tstruct mipi_dbi *dbi = &dbidev->dbi;\n\n\txs += dbidev->left_offset;\n\txe += dbidev->left_offset;\n\tys += dbidev->top_offset;\n\tye += dbidev->top_offset;\n\n\tmipi_dbi_command(dbi, MIPI_DCS_SET_COLUMN_ADDRESS, (xs >> 8) & 0xff,\n\t\t\t xs & 0xff, (xe >> 8) & 0xff, xe & 0xff);\n\tmipi_dbi_command(dbi, MIPI_DCS_SET_PAGE_ADDRESS, (ys >> 8) & 0xff,\n\t\t\t ys & 0xff, (ye >> 8) & 0xff, ye & 0xff);\n}\n\nstatic void mipi_dbi_fb_dirty(struct iosys_map *src, struct drm_framebuffer *fb,\n\t\t\t      struct drm_rect *rect)\n{\n\tstruct mipi_dbi_dev *dbidev = drm_to_mipi_dbi_dev(fb->dev);\n\tunsigned int height = rect->y2 - rect->y1;\n\tunsigned int width = rect->x2 - rect->x1;\n\tstruct mipi_dbi *dbi = &dbidev->dbi;\n\tbool swap = dbi->swap_bytes;\n\tint ret = 0;\n\tbool full;\n\tvoid *tr;\n\n\tfull = width == fb->width && height == fb->height;\n\n\tDRM_DEBUG_KMS(\"Flushing [FB:%d] \" DRM_RECT_FMT \"\\n\", fb->base.id, DRM_RECT_ARG(rect));\n\n\tif (!dbi->dc || !full || swap ||\n\t    fb->format->format == DRM_FORMAT_XRGB8888) {\n\t\ttr = dbidev->tx_buf;\n\t\tret = mipi_dbi_buf_copy(tr, src, fb, rect, swap);\n\t\tif (ret)\n\t\t\tgoto err_msg;\n\t} else {\n\t\ttr = src->vaddr;  \n\t}\n\n\tmipi_dbi_set_window_address(dbidev, rect->x1, rect->x2 - 1, rect->y1,\n\t\t\t\t    rect->y2 - 1);\n\n\tret = mipi_dbi_command_buf(dbi, MIPI_DCS_WRITE_MEMORY_START, tr,\n\t\t\t\t   width * height * 2);\nerr_msg:\n\tif (ret)\n\t\tdrm_err_once(fb->dev, \"Failed to update display %d\\n\", ret);\n}\n\n \nenum drm_mode_status mipi_dbi_pipe_mode_valid(struct drm_simple_display_pipe *pipe,\n\t\t\t\t\t      const struct drm_display_mode *mode)\n{\n\tstruct mipi_dbi_dev *dbidev = drm_to_mipi_dbi_dev(pipe->crtc.dev);\n\n\treturn drm_crtc_helper_mode_valid_fixed(&pipe->crtc, mode, &dbidev->mode);\n}\nEXPORT_SYMBOL(mipi_dbi_pipe_mode_valid);\n\n \nvoid mipi_dbi_pipe_update(struct drm_simple_display_pipe *pipe,\n\t\t\t  struct drm_plane_state *old_state)\n{\n\tstruct drm_plane_state *state = pipe->plane.state;\n\tstruct drm_shadow_plane_state *shadow_plane_state = to_drm_shadow_plane_state(state);\n\tstruct drm_framebuffer *fb = state->fb;\n\tstruct drm_rect rect;\n\tint idx;\n\n\tif (!pipe->crtc.state->active)\n\t\treturn;\n\n\tif (WARN_ON(!fb))\n\t\treturn;\n\n\tif (!drm_dev_enter(fb->dev, &idx))\n\t\treturn;\n\n\tif (drm_atomic_helper_damage_merged(old_state, state, &rect))\n\t\tmipi_dbi_fb_dirty(&shadow_plane_state->data[0], fb, &rect);\n\n\tdrm_dev_exit(idx);\n}\nEXPORT_SYMBOL(mipi_dbi_pipe_update);\n\n \nvoid mipi_dbi_enable_flush(struct mipi_dbi_dev *dbidev,\n\t\t\t   struct drm_crtc_state *crtc_state,\n\t\t\t   struct drm_plane_state *plane_state)\n{\n\tstruct drm_shadow_plane_state *shadow_plane_state = to_drm_shadow_plane_state(plane_state);\n\tstruct drm_framebuffer *fb = plane_state->fb;\n\tstruct drm_rect rect = {\n\t\t.x1 = 0,\n\t\t.x2 = fb->width,\n\t\t.y1 = 0,\n\t\t.y2 = fb->height,\n\t};\n\tint idx;\n\n\tif (!drm_dev_enter(&dbidev->drm, &idx))\n\t\treturn;\n\n\tmipi_dbi_fb_dirty(&shadow_plane_state->data[0], fb, &rect);\n\tbacklight_enable(dbidev->backlight);\n\n\tdrm_dev_exit(idx);\n}\nEXPORT_SYMBOL(mipi_dbi_enable_flush);\n\nstatic void mipi_dbi_blank(struct mipi_dbi_dev *dbidev)\n{\n\tstruct drm_device *drm = &dbidev->drm;\n\tu16 height = drm->mode_config.min_height;\n\tu16 width = drm->mode_config.min_width;\n\tstruct mipi_dbi *dbi = &dbidev->dbi;\n\tsize_t len = width * height * 2;\n\tint idx;\n\n\tif (!drm_dev_enter(drm, &idx))\n\t\treturn;\n\n\tmemset(dbidev->tx_buf, 0, len);\n\n\tmipi_dbi_set_window_address(dbidev, 0, width - 1, 0, height - 1);\n\tmipi_dbi_command_buf(dbi, MIPI_DCS_WRITE_MEMORY_START,\n\t\t\t     (u8 *)dbidev->tx_buf, len);\n\n\tdrm_dev_exit(idx);\n}\n\n \nvoid mipi_dbi_pipe_disable(struct drm_simple_display_pipe *pipe)\n{\n\tstruct mipi_dbi_dev *dbidev = drm_to_mipi_dbi_dev(pipe->crtc.dev);\n\n\tDRM_DEBUG_KMS(\"\\n\");\n\n\tif (dbidev->backlight)\n\t\tbacklight_disable(dbidev->backlight);\n\telse\n\t\tmipi_dbi_blank(dbidev);\n\n\tif (dbidev->regulator)\n\t\tregulator_disable(dbidev->regulator);\n\tif (dbidev->io_regulator)\n\t\tregulator_disable(dbidev->io_regulator);\n}\nEXPORT_SYMBOL(mipi_dbi_pipe_disable);\n\n \nint mipi_dbi_pipe_begin_fb_access(struct drm_simple_display_pipe *pipe,\n\t\t\t\t  struct drm_plane_state *plane_state)\n{\n\treturn drm_gem_begin_shadow_fb_access(&pipe->plane, plane_state);\n}\nEXPORT_SYMBOL(mipi_dbi_pipe_begin_fb_access);\n\n \nvoid mipi_dbi_pipe_end_fb_access(struct drm_simple_display_pipe *pipe,\n\t\t\t\t struct drm_plane_state *plane_state)\n{\n\tdrm_gem_end_shadow_fb_access(&pipe->plane, plane_state);\n}\nEXPORT_SYMBOL(mipi_dbi_pipe_end_fb_access);\n\n \nvoid mipi_dbi_pipe_reset_plane(struct drm_simple_display_pipe *pipe)\n{\n\tdrm_gem_reset_shadow_plane(&pipe->plane);\n}\nEXPORT_SYMBOL(mipi_dbi_pipe_reset_plane);\n\n \nstruct drm_plane_state *mipi_dbi_pipe_duplicate_plane_state(struct drm_simple_display_pipe *pipe)\n{\n\treturn drm_gem_duplicate_shadow_plane_state(&pipe->plane);\n}\nEXPORT_SYMBOL(mipi_dbi_pipe_duplicate_plane_state);\n\n \nvoid mipi_dbi_pipe_destroy_plane_state(struct drm_simple_display_pipe *pipe,\n\t\t\t\t       struct drm_plane_state *plane_state)\n{\n\tdrm_gem_destroy_shadow_plane_state(&pipe->plane, plane_state);\n}\nEXPORT_SYMBOL(mipi_dbi_pipe_destroy_plane_state);\n\nstatic int mipi_dbi_connector_get_modes(struct drm_connector *connector)\n{\n\tstruct mipi_dbi_dev *dbidev = drm_to_mipi_dbi_dev(connector->dev);\n\n\treturn drm_connector_helper_get_modes_fixed(connector, &dbidev->mode);\n}\n\nstatic const struct drm_connector_helper_funcs mipi_dbi_connector_hfuncs = {\n\t.get_modes = mipi_dbi_connector_get_modes,\n};\n\nstatic const struct drm_connector_funcs mipi_dbi_connector_funcs = {\n\t.reset = drm_atomic_helper_connector_reset,\n\t.fill_modes = drm_helper_probe_single_connector_modes,\n\t.destroy = drm_connector_cleanup,\n\t.atomic_duplicate_state = drm_atomic_helper_connector_duplicate_state,\n\t.atomic_destroy_state = drm_atomic_helper_connector_destroy_state,\n};\n\nstatic int mipi_dbi_rotate_mode(struct drm_display_mode *mode,\n\t\t\t\tunsigned int rotation)\n{\n\tif (rotation == 0 || rotation == 180) {\n\t\treturn 0;\n\t} else if (rotation == 90 || rotation == 270) {\n\t\tswap(mode->hdisplay, mode->vdisplay);\n\t\tswap(mode->hsync_start, mode->vsync_start);\n\t\tswap(mode->hsync_end, mode->vsync_end);\n\t\tswap(mode->htotal, mode->vtotal);\n\t\tswap(mode->width_mm, mode->height_mm);\n\t\treturn 0;\n\t} else {\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic const struct drm_mode_config_funcs mipi_dbi_mode_config_funcs = {\n\t.fb_create = drm_gem_fb_create_with_dirty,\n\t.atomic_check = drm_atomic_helper_check,\n\t.atomic_commit = drm_atomic_helper_commit,\n};\n\nstatic const uint32_t mipi_dbi_formats[] = {\n\tDRM_FORMAT_RGB565,\n\tDRM_FORMAT_XRGB8888,\n};\n\n \nint mipi_dbi_dev_init_with_formats(struct mipi_dbi_dev *dbidev,\n\t\t\t\t   const struct drm_simple_display_pipe_funcs *funcs,\n\t\t\t\t   const uint32_t *formats, unsigned int format_count,\n\t\t\t\t   const struct drm_display_mode *mode,\n\t\t\t\t   unsigned int rotation, size_t tx_buf_size)\n{\n\tstatic const uint64_t modifiers[] = {\n\t\tDRM_FORMAT_MOD_LINEAR,\n\t\tDRM_FORMAT_MOD_INVALID\n\t};\n\tstruct drm_device *drm = &dbidev->drm;\n\tint ret;\n\n\tif (!dbidev->dbi.command)\n\t\treturn -EINVAL;\n\n\tret = drmm_mode_config_init(drm);\n\tif (ret)\n\t\treturn ret;\n\n\tdbidev->tx_buf = devm_kmalloc(drm->dev, tx_buf_size, GFP_KERNEL);\n\tif (!dbidev->tx_buf)\n\t\treturn -ENOMEM;\n\n\tdrm_mode_copy(&dbidev->mode, mode);\n\tret = mipi_dbi_rotate_mode(&dbidev->mode, rotation);\n\tif (ret) {\n\t\tDRM_ERROR(\"Illegal rotation value %u\\n\", rotation);\n\t\treturn -EINVAL;\n\t}\n\n\tdrm_connector_helper_add(&dbidev->connector, &mipi_dbi_connector_hfuncs);\n\tret = drm_connector_init(drm, &dbidev->connector, &mipi_dbi_connector_funcs,\n\t\t\t\t DRM_MODE_CONNECTOR_SPI);\n\tif (ret)\n\t\treturn ret;\n\n\tret = drm_simple_display_pipe_init(drm, &dbidev->pipe, funcs, formats, format_count,\n\t\t\t\t\t   modifiers, &dbidev->connector);\n\tif (ret)\n\t\treturn ret;\n\n\tdrm_plane_enable_fb_damage_clips(&dbidev->pipe.plane);\n\n\tdrm->mode_config.funcs = &mipi_dbi_mode_config_funcs;\n\tdrm->mode_config.min_width = dbidev->mode.hdisplay;\n\tdrm->mode_config.max_width = dbidev->mode.hdisplay;\n\tdrm->mode_config.min_height = dbidev->mode.vdisplay;\n\tdrm->mode_config.max_height = dbidev->mode.vdisplay;\n\tdbidev->rotation = rotation;\n\n\tDRM_DEBUG_KMS(\"rotation = %u\\n\", rotation);\n\n\treturn 0;\n}\nEXPORT_SYMBOL(mipi_dbi_dev_init_with_formats);\n\n \nint mipi_dbi_dev_init(struct mipi_dbi_dev *dbidev,\n\t\t      const struct drm_simple_display_pipe_funcs *funcs,\n\t\t      const struct drm_display_mode *mode, unsigned int rotation)\n{\n\tsize_t bufsize = mode->vdisplay * mode->hdisplay * sizeof(u16);\n\n\tdbidev->drm.mode_config.preferred_depth = 16;\n\n\treturn mipi_dbi_dev_init_with_formats(dbidev, funcs, mipi_dbi_formats,\n\t\t\t\t\t      ARRAY_SIZE(mipi_dbi_formats), mode,\n\t\t\t\t\t      rotation, bufsize);\n}\nEXPORT_SYMBOL(mipi_dbi_dev_init);\n\n \nvoid mipi_dbi_hw_reset(struct mipi_dbi *dbi)\n{\n\tif (!dbi->reset)\n\t\treturn;\n\n\tgpiod_set_value_cansleep(dbi->reset, 0);\n\tusleep_range(20, 1000);\n\tgpiod_set_value_cansleep(dbi->reset, 1);\n\tmsleep(120);\n}\nEXPORT_SYMBOL(mipi_dbi_hw_reset);\n\n \nbool mipi_dbi_display_is_on(struct mipi_dbi *dbi)\n{\n\tu8 val;\n\n\tif (mipi_dbi_command_read(dbi, MIPI_DCS_GET_POWER_MODE, &val))\n\t\treturn false;\n\n\tval &= ~DCS_POWER_MODE_RESERVED_MASK;\n\n\t \n\tif (val != (DCS_POWER_MODE_DISPLAY |\n\t    DCS_POWER_MODE_DISPLAY_NORMAL_MODE | DCS_POWER_MODE_SLEEP_MODE))\n\t\treturn false;\n\n\tDRM_DEBUG_DRIVER(\"Display is ON\\n\");\n\n\treturn true;\n}\nEXPORT_SYMBOL(mipi_dbi_display_is_on);\n\nstatic int mipi_dbi_poweron_reset_conditional(struct mipi_dbi_dev *dbidev, bool cond)\n{\n\tstruct device *dev = dbidev->drm.dev;\n\tstruct mipi_dbi *dbi = &dbidev->dbi;\n\tint ret;\n\n\tif (dbidev->regulator) {\n\t\tret = regulator_enable(dbidev->regulator);\n\t\tif (ret) {\n\t\t\tDRM_DEV_ERROR(dev, \"Failed to enable regulator (%d)\\n\", ret);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tif (dbidev->io_regulator) {\n\t\tret = regulator_enable(dbidev->io_regulator);\n\t\tif (ret) {\n\t\t\tDRM_DEV_ERROR(dev, \"Failed to enable I/O regulator (%d)\\n\", ret);\n\t\t\tif (dbidev->regulator)\n\t\t\t\tregulator_disable(dbidev->regulator);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tif (cond && mipi_dbi_display_is_on(dbi))\n\t\treturn 1;\n\n\tmipi_dbi_hw_reset(dbi);\n\tret = mipi_dbi_command(dbi, MIPI_DCS_SOFT_RESET);\n\tif (ret) {\n\t\tDRM_DEV_ERROR(dev, \"Failed to send reset command (%d)\\n\", ret);\n\t\tif (dbidev->regulator)\n\t\t\tregulator_disable(dbidev->regulator);\n\t\tif (dbidev->io_regulator)\n\t\t\tregulator_disable(dbidev->io_regulator);\n\t\treturn ret;\n\t}\n\n\t \n\tif (dbi->reset)\n\t\tusleep_range(5000, 20000);\n\telse\n\t\tmsleep(120);\n\n\treturn 0;\n}\n\n \nint mipi_dbi_poweron_reset(struct mipi_dbi_dev *dbidev)\n{\n\treturn mipi_dbi_poweron_reset_conditional(dbidev, false);\n}\nEXPORT_SYMBOL(mipi_dbi_poweron_reset);\n\n \nint mipi_dbi_poweron_conditional_reset(struct mipi_dbi_dev *dbidev)\n{\n\treturn mipi_dbi_poweron_reset_conditional(dbidev, true);\n}\nEXPORT_SYMBOL(mipi_dbi_poweron_conditional_reset);\n\n#if IS_ENABLED(CONFIG_SPI)\n\n \nu32 mipi_dbi_spi_cmd_max_speed(struct spi_device *spi, size_t len)\n{\n\tif (len > 64)\n\t\treturn 0;  \n\n\treturn min_t(u32, 10000000, spi->max_speed_hz);\n}\nEXPORT_SYMBOL(mipi_dbi_spi_cmd_max_speed);\n\nstatic bool mipi_dbi_machine_little_endian(void)\n{\n#if defined(__LITTLE_ENDIAN)\n\treturn true;\n#else\n\treturn false;\n#endif\n}\n\n \n\nstatic int mipi_dbi_spi1e_transfer(struct mipi_dbi *dbi, int dc,\n\t\t\t\t   const void *buf, size_t len,\n\t\t\t\t   unsigned int bpw)\n{\n\tbool swap_bytes = (bpw == 16 && mipi_dbi_machine_little_endian());\n\tsize_t chunk, max_chunk = dbi->tx_buf9_len;\n\tstruct spi_device *spi = dbi->spi;\n\tstruct spi_transfer tr = {\n\t\t.tx_buf = dbi->tx_buf9,\n\t\t.bits_per_word = 8,\n\t};\n\tstruct spi_message m;\n\tconst u8 *src = buf;\n\tint i, ret;\n\tu8 *dst;\n\n\tif (drm_debug_enabled(DRM_UT_DRIVER))\n\t\tpr_debug(\"[drm:%s] dc=%d, max_chunk=%zu, transfers:\\n\",\n\t\t\t __func__, dc, max_chunk);\n\n\ttr.speed_hz = mipi_dbi_spi_cmd_max_speed(spi, len);\n\tspi_message_init_with_transfers(&m, &tr, 1);\n\n\tif (!dc) {\n\t\tif (WARN_ON_ONCE(len != 1))\n\t\t\treturn -EINVAL;\n\n\t\t \n\t\tdst = dbi->tx_buf9;\n\t\tmemset(dst, 0, 9);\n\t\tdst[8] = *src;\n\t\ttr.len = 9;\n\n\t\treturn spi_sync(spi, &m);\n\t}\n\n\t \n\tmax_chunk = max_chunk / 9 * 8;\n\t \n\tmax_chunk = min(max_chunk, len);\n\t \n\tmax_chunk = max_t(size_t, 8, max_chunk & ~0x7);\n\n\twhile (len) {\n\t\tsize_t added = 0;\n\n\t\tchunk = min(len, max_chunk);\n\t\tlen -= chunk;\n\t\tdst = dbi->tx_buf9;\n\n\t\tif (chunk < 8) {\n\t\t\tu8 val, carry = 0;\n\n\t\t\t \n\t\t\tmemset(dst, 0, 9);\n\n\t\t\tif (swap_bytes) {\n\t\t\t\tfor (i = 1; i < (chunk + 1); i++) {\n\t\t\t\t\tval = src[1];\n\t\t\t\t\t*dst++ = carry | BIT(8 - i) | (val >> i);\n\t\t\t\t\tcarry = val << (8 - i);\n\t\t\t\t\ti++;\n\t\t\t\t\tval = src[0];\n\t\t\t\t\t*dst++ = carry | BIT(8 - i) | (val >> i);\n\t\t\t\t\tcarry = val << (8 - i);\n\t\t\t\t\tsrc += 2;\n\t\t\t\t}\n\t\t\t\t*dst++ = carry;\n\t\t\t} else {\n\t\t\t\tfor (i = 1; i < (chunk + 1); i++) {\n\t\t\t\t\tval = *src++;\n\t\t\t\t\t*dst++ = carry | BIT(8 - i) | (val >> i);\n\t\t\t\t\tcarry = val << (8 - i);\n\t\t\t\t}\n\t\t\t\t*dst++ = carry;\n\t\t\t}\n\n\t\t\tchunk = 8;\n\t\t\tadded = 1;\n\t\t} else {\n\t\t\tfor (i = 0; i < chunk; i += 8) {\n\t\t\t\tif (swap_bytes) {\n\t\t\t\t\t*dst++ =                 BIT(7) | (src[1] >> 1);\n\t\t\t\t\t*dst++ = (src[1] << 7) | BIT(6) | (src[0] >> 2);\n\t\t\t\t\t*dst++ = (src[0] << 6) | BIT(5) | (src[3] >> 3);\n\t\t\t\t\t*dst++ = (src[3] << 5) | BIT(4) | (src[2] >> 4);\n\t\t\t\t\t*dst++ = (src[2] << 4) | BIT(3) | (src[5] >> 5);\n\t\t\t\t\t*dst++ = (src[5] << 3) | BIT(2) | (src[4] >> 6);\n\t\t\t\t\t*dst++ = (src[4] << 2) | BIT(1) | (src[7] >> 7);\n\t\t\t\t\t*dst++ = (src[7] << 1) | BIT(0);\n\t\t\t\t\t*dst++ = src[6];\n\t\t\t\t} else {\n\t\t\t\t\t*dst++ =                 BIT(7) | (src[0] >> 1);\n\t\t\t\t\t*dst++ = (src[0] << 7) | BIT(6) | (src[1] >> 2);\n\t\t\t\t\t*dst++ = (src[1] << 6) | BIT(5) | (src[2] >> 3);\n\t\t\t\t\t*dst++ = (src[2] << 5) | BIT(4) | (src[3] >> 4);\n\t\t\t\t\t*dst++ = (src[3] << 4) | BIT(3) | (src[4] >> 5);\n\t\t\t\t\t*dst++ = (src[4] << 3) | BIT(2) | (src[5] >> 6);\n\t\t\t\t\t*dst++ = (src[5] << 2) | BIT(1) | (src[6] >> 7);\n\t\t\t\t\t*dst++ = (src[6] << 1) | BIT(0);\n\t\t\t\t\t*dst++ = src[7];\n\t\t\t\t}\n\n\t\t\t\tsrc += 8;\n\t\t\t\tadded++;\n\t\t\t}\n\t\t}\n\n\t\ttr.len = chunk + added;\n\n\t\tret = spi_sync(spi, &m);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int mipi_dbi_spi1_transfer(struct mipi_dbi *dbi, int dc,\n\t\t\t\t  const void *buf, size_t len,\n\t\t\t\t  unsigned int bpw)\n{\n\tstruct spi_device *spi = dbi->spi;\n\tstruct spi_transfer tr = {\n\t\t.bits_per_word = 9,\n\t};\n\tconst u16 *src16 = buf;\n\tconst u8 *src8 = buf;\n\tstruct spi_message m;\n\tsize_t max_chunk;\n\tu16 *dst16;\n\tint ret;\n\n\tif (!spi_is_bpw_supported(spi, 9))\n\t\treturn mipi_dbi_spi1e_transfer(dbi, dc, buf, len, bpw);\n\n\ttr.speed_hz = mipi_dbi_spi_cmd_max_speed(spi, len);\n\tmax_chunk = dbi->tx_buf9_len;\n\tdst16 = dbi->tx_buf9;\n\n\tif (drm_debug_enabled(DRM_UT_DRIVER))\n\t\tpr_debug(\"[drm:%s] dc=%d, max_chunk=%zu, transfers:\\n\",\n\t\t\t __func__, dc, max_chunk);\n\n\tmax_chunk = min(max_chunk / 2, len);\n\n\tspi_message_init_with_transfers(&m, &tr, 1);\n\ttr.tx_buf = dst16;\n\n\twhile (len) {\n\t\tsize_t chunk = min(len, max_chunk);\n\t\tunsigned int i;\n\n\t\tif (bpw == 16 && mipi_dbi_machine_little_endian()) {\n\t\t\tfor (i = 0; i < (chunk * 2); i += 2) {\n\t\t\t\tdst16[i]     = *src16 >> 8;\n\t\t\t\tdst16[i + 1] = *src16++ & 0xFF;\n\t\t\t\tif (dc) {\n\t\t\t\t\tdst16[i]     |= 0x0100;\n\t\t\t\t\tdst16[i + 1] |= 0x0100;\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tfor (i = 0; i < chunk; i++) {\n\t\t\t\tdst16[i] = *src8++;\n\t\t\t\tif (dc)\n\t\t\t\t\tdst16[i] |= 0x0100;\n\t\t\t}\n\t\t}\n\n\t\ttr.len = chunk * 2;\n\t\tlen -= chunk;\n\n\t\tret = spi_sync(spi, &m);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int mipi_dbi_typec1_command_read(struct mipi_dbi *dbi, u8 *cmd,\n\t\t\t\t\tu8 *data, size_t len)\n{\n\tstruct spi_device *spi = dbi->spi;\n\tu32 speed_hz = min_t(u32, MIPI_DBI_MAX_SPI_READ_SPEED,\n\t\t\t     spi->max_speed_hz / 2);\n\tstruct spi_transfer tr[2] = {\n\t\t{\n\t\t\t.speed_hz = speed_hz,\n\t\t\t.bits_per_word = 9,\n\t\t\t.tx_buf = dbi->tx_buf9,\n\t\t\t.len = 2,\n\t\t}, {\n\t\t\t.speed_hz = speed_hz,\n\t\t\t.bits_per_word = 8,\n\t\t\t.len = len,\n\t\t\t.rx_buf = data,\n\t\t},\n\t};\n\tstruct spi_message m;\n\tu16 *dst16;\n\tint ret;\n\n\tif (!len)\n\t\treturn -EINVAL;\n\n\tif (!spi_is_bpw_supported(spi, 9)) {\n\t\t \n\t\tdev_err(&spi->dev,\n\t\t\t\"reading on host not supporting 9 bpw not yet implemented\\n\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\t \n\tdst16 = dbi->tx_buf9;\n\tdst16[0] = *cmd;\n\n\tspi_message_init_with_transfers(&m, tr, ARRAY_SIZE(tr));\n\tret = spi_sync(spi, &m);\n\n\tif (!ret)\n\t\tMIPI_DBI_DEBUG_COMMAND(*cmd, data, len);\n\n\treturn ret;\n}\n\nstatic int mipi_dbi_typec1_command(struct mipi_dbi *dbi, u8 *cmd,\n\t\t\t\t   u8 *parameters, size_t num)\n{\n\tunsigned int bpw = (*cmd == MIPI_DCS_WRITE_MEMORY_START) ? 16 : 8;\n\tint ret;\n\n\tif (mipi_dbi_command_is_read(dbi, *cmd))\n\t\treturn mipi_dbi_typec1_command_read(dbi, cmd, parameters, num);\n\n\tMIPI_DBI_DEBUG_COMMAND(*cmd, parameters, num);\n\n\tret = mipi_dbi_spi1_transfer(dbi, 0, cmd, 1, 8);\n\tif (ret || !num)\n\t\treturn ret;\n\n\treturn mipi_dbi_spi1_transfer(dbi, 1, parameters, num, bpw);\n}\n\n \n\nstatic int mipi_dbi_typec3_command_read(struct mipi_dbi *dbi, u8 *cmd,\n\t\t\t\t\tu8 *data, size_t len)\n{\n\tstruct spi_device *spi = dbi->spi;\n\tu32 speed_hz = min_t(u32, MIPI_DBI_MAX_SPI_READ_SPEED,\n\t\t\t     spi->max_speed_hz / 2);\n\tstruct spi_transfer tr[2] = {\n\t\t{\n\t\t\t.speed_hz = speed_hz,\n\t\t\t.tx_buf = cmd,\n\t\t\t.len = 1,\n\t\t}, {\n\t\t\t.speed_hz = speed_hz,\n\t\t\t.len = len,\n\t\t},\n\t};\n\tstruct spi_message m;\n\tu8 *buf;\n\tint ret;\n\n\tif (!len)\n\t\treturn -EINVAL;\n\n\t \n\tif (*cmd == MIPI_DCS_GET_DISPLAY_ID ||\n\t    *cmd == MIPI_DCS_GET_DISPLAY_STATUS) {\n\t\tif (!(len == 3 || len == 4))\n\t\t\treturn -EINVAL;\n\n\t\ttr[1].len = len + 1;\n\t}\n\n\tbuf = kmalloc(tr[1].len, GFP_KERNEL);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\ttr[1].rx_buf = buf;\n\n\tspi_bus_lock(spi->controller);\n\tgpiod_set_value_cansleep(dbi->dc, 0);\n\n\tspi_message_init_with_transfers(&m, tr, ARRAY_SIZE(tr));\n\tret = spi_sync_locked(spi, &m);\n\tspi_bus_unlock(spi->controller);\n\tif (ret)\n\t\tgoto err_free;\n\n\tif (tr[1].len == len) {\n\t\tmemcpy(data, buf, len);\n\t} else {\n\t\tunsigned int i;\n\n\t\tfor (i = 0; i < len; i++)\n\t\t\tdata[i] = (buf[i] << 1) | (buf[i + 1] >> 7);\n\t}\n\n\tMIPI_DBI_DEBUG_COMMAND(*cmd, data, len);\n\nerr_free:\n\tkfree(buf);\n\n\treturn ret;\n}\n\nstatic int mipi_dbi_typec3_command(struct mipi_dbi *dbi, u8 *cmd,\n\t\t\t\t   u8 *par, size_t num)\n{\n\tstruct spi_device *spi = dbi->spi;\n\tunsigned int bpw = 8;\n\tu32 speed_hz;\n\tint ret;\n\n\tif (mipi_dbi_command_is_read(dbi, *cmd))\n\t\treturn mipi_dbi_typec3_command_read(dbi, cmd, par, num);\n\n\tMIPI_DBI_DEBUG_COMMAND(*cmd, par, num);\n\n\tspi_bus_lock(spi->controller);\n\tgpiod_set_value_cansleep(dbi->dc, 0);\n\tspeed_hz = mipi_dbi_spi_cmd_max_speed(spi, 1);\n\tret = mipi_dbi_spi_transfer(spi, speed_hz, 8, cmd, 1);\n\tspi_bus_unlock(spi->controller);\n\tif (ret || !num)\n\t\treturn ret;\n\n\tif (*cmd == MIPI_DCS_WRITE_MEMORY_START && !dbi->swap_bytes)\n\t\tbpw = 16;\n\n\tspi_bus_lock(spi->controller);\n\tgpiod_set_value_cansleep(dbi->dc, 1);\n\tspeed_hz = mipi_dbi_spi_cmd_max_speed(spi, num);\n\tret = mipi_dbi_spi_transfer(spi, speed_hz, bpw, par, num);\n\tspi_bus_unlock(spi->controller);\n\n\treturn ret;\n}\n\n \nint mipi_dbi_spi_init(struct spi_device *spi, struct mipi_dbi *dbi,\n\t\t      struct gpio_desc *dc)\n{\n\tstruct device *dev = &spi->dev;\n\tint ret;\n\n\t \n\tif (!dev->coherent_dma_mask) {\n\t\tret = dma_coerce_mask_and_coherent(dev, DMA_BIT_MASK(32));\n\t\tif (ret) {\n\t\t\tdev_warn(dev, \"Failed to set dma mask %d\\n\", ret);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tdbi->spi = spi;\n\tdbi->read_commands = mipi_dbi_dcs_read_commands;\n\n\tif (dc) {\n\t\tdbi->command = mipi_dbi_typec3_command;\n\t\tdbi->dc = dc;\n\t\tif (mipi_dbi_machine_little_endian() && !spi_is_bpw_supported(spi, 16))\n\t\t\tdbi->swap_bytes = true;\n\t} else {\n\t\tdbi->command = mipi_dbi_typec1_command;\n\t\tdbi->tx_buf9_len = SZ_16K;\n\t\tdbi->tx_buf9 = devm_kmalloc(dev, dbi->tx_buf9_len, GFP_KERNEL);\n\t\tif (!dbi->tx_buf9)\n\t\t\treturn -ENOMEM;\n\t}\n\n\tmutex_init(&dbi->cmdlock);\n\n\tDRM_DEBUG_DRIVER(\"SPI speed: %uMHz\\n\", spi->max_speed_hz / 1000000);\n\n\treturn 0;\n}\nEXPORT_SYMBOL(mipi_dbi_spi_init);\n\n \nint mipi_dbi_spi_transfer(struct spi_device *spi, u32 speed_hz,\n\t\t\t  u8 bpw, const void *buf, size_t len)\n{\n\tsize_t max_chunk = spi_max_transfer_size(spi);\n\tstruct spi_transfer tr = {\n\t\t.bits_per_word = bpw,\n\t\t.speed_hz = speed_hz,\n\t};\n\tstruct spi_message m;\n\tsize_t chunk;\n\tint ret;\n\n\t \n\tmax_chunk = ALIGN_DOWN(max_chunk, 2);\n\n\tspi_message_init_with_transfers(&m, &tr, 1);\n\n\twhile (len) {\n\t\tchunk = min(len, max_chunk);\n\n\t\ttr.tx_buf = buf;\n\t\ttr.len = chunk;\n\t\tbuf += chunk;\n\t\tlen -= chunk;\n\n\t\tret = spi_sync_locked(spi, &m);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL(mipi_dbi_spi_transfer);\n\n#endif  \n\n#ifdef CONFIG_DEBUG_FS\n\nstatic ssize_t mipi_dbi_debugfs_command_write(struct file *file,\n\t\t\t\t\t      const char __user *ubuf,\n\t\t\t\t\t      size_t count, loff_t *ppos)\n{\n\tstruct seq_file *m = file->private_data;\n\tstruct mipi_dbi_dev *dbidev = m->private;\n\tu8 val, cmd = 0, parameters[64];\n\tchar *buf, *pos, *token;\n\tint i, ret, idx;\n\n\tif (!drm_dev_enter(&dbidev->drm, &idx))\n\t\treturn -ENODEV;\n\n\tbuf = memdup_user_nul(ubuf, count);\n\tif (IS_ERR(buf)) {\n\t\tret = PTR_ERR(buf);\n\t\tgoto err_exit;\n\t}\n\n\t \n\tfor (i = count - 1; i > 0; i--)\n\t\tif (isspace(buf[i]))\n\t\t\tbuf[i] = '\\0';\n\t\telse\n\t\t\tbreak;\n\ti = 0;\n\tpos = buf;\n\twhile (pos) {\n\t\ttoken = strsep(&pos, \" \");\n\t\tif (!token) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto err_free;\n\t\t}\n\n\t\tret = kstrtou8(token, 16, &val);\n\t\tif (ret < 0)\n\t\t\tgoto err_free;\n\n\t\tif (token == buf)\n\t\t\tcmd = val;\n\t\telse\n\t\t\tparameters[i++] = val;\n\n\t\tif (i == 64) {\n\t\t\tret = -E2BIG;\n\t\t\tgoto err_free;\n\t\t}\n\t}\n\n\tret = mipi_dbi_command_buf(&dbidev->dbi, cmd, parameters, i);\n\nerr_free:\n\tkfree(buf);\nerr_exit:\n\tdrm_dev_exit(idx);\n\n\treturn ret < 0 ? ret : count;\n}\n\nstatic int mipi_dbi_debugfs_command_show(struct seq_file *m, void *unused)\n{\n\tstruct mipi_dbi_dev *dbidev = m->private;\n\tstruct mipi_dbi *dbi = &dbidev->dbi;\n\tu8 cmd, val[4];\n\tint ret, idx;\n\tsize_t len;\n\n\tif (!drm_dev_enter(&dbidev->drm, &idx))\n\t\treturn -ENODEV;\n\n\tfor (cmd = 0; cmd < 255; cmd++) {\n\t\tif (!mipi_dbi_command_is_read(dbi, cmd))\n\t\t\tcontinue;\n\n\t\tswitch (cmd) {\n\t\tcase MIPI_DCS_READ_MEMORY_START:\n\t\tcase MIPI_DCS_READ_MEMORY_CONTINUE:\n\t\t\tlen = 2;\n\t\t\tbreak;\n\t\tcase MIPI_DCS_GET_DISPLAY_ID:\n\t\t\tlen = 3;\n\t\t\tbreak;\n\t\tcase MIPI_DCS_GET_DISPLAY_STATUS:\n\t\t\tlen = 4;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tlen = 1;\n\t\t\tbreak;\n\t\t}\n\n\t\tseq_printf(m, \"%02x: \", cmd);\n\t\tret = mipi_dbi_command_buf(dbi, cmd, val, len);\n\t\tif (ret) {\n\t\t\tseq_puts(m, \"XX\\n\");\n\t\t\tcontinue;\n\t\t}\n\t\tseq_printf(m, \"%*phN\\n\", (int)len, val);\n\t}\n\n\tdrm_dev_exit(idx);\n\n\treturn 0;\n}\n\nstatic int mipi_dbi_debugfs_command_open(struct inode *inode,\n\t\t\t\t\t struct file *file)\n{\n\treturn single_open(file, mipi_dbi_debugfs_command_show,\n\t\t\t   inode->i_private);\n}\n\nstatic const struct file_operations mipi_dbi_debugfs_command_fops = {\n\t.owner = THIS_MODULE,\n\t.open = mipi_dbi_debugfs_command_open,\n\t.read = seq_read,\n\t.llseek = seq_lseek,\n\t.release = single_release,\n\t.write = mipi_dbi_debugfs_command_write,\n};\n\n \nvoid mipi_dbi_debugfs_init(struct drm_minor *minor)\n{\n\tstruct mipi_dbi_dev *dbidev = drm_to_mipi_dbi_dev(minor->dev);\n\tumode_t mode = S_IFREG | S_IWUSR;\n\n\tif (dbidev->dbi.read_commands)\n\t\tmode |= S_IRUGO;\n\tdebugfs_create_file(\"command\", mode, minor->debugfs_root, dbidev,\n\t\t\t    &mipi_dbi_debugfs_command_fops);\n}\nEXPORT_SYMBOL(mipi_dbi_debugfs_init);\n\n#endif\n\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}