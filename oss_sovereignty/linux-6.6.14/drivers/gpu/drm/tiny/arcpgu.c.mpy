{
  "module_name": "arcpgu.c",
  "hash_id": "1c337009c396e11a9f139fbecbd31d924540e38375ba5a5396c4e8921b19513e",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/tiny/arcpgu.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <drm/drm_atomic_helper.h>\n#include <drm/drm_debugfs.h>\n#include <drm/drm_device.h>\n#include <drm/drm_drv.h>\n#include <drm/drm_edid.h>\n#include <drm/drm_fb_dma_helper.h>\n#include <drm/drm_fbdev_dma.h>\n#include <drm/drm_fourcc.h>\n#include <drm/drm_framebuffer.h>\n#include <drm/drm_gem_dma_helper.h>\n#include <drm/drm_gem_framebuffer_helper.h>\n#include <drm/drm_module.h>\n#include <drm/drm_of.h>\n#include <drm/drm_probe_helper.h>\n#include <drm/drm_simple_kms_helper.h>\n#include <linux/dma-mapping.h>\n#include <linux/module.h>\n#include <linux/of_reserved_mem.h>\n#include <linux/platform_device.h>\n\n#define ARCPGU_REG_CTRL\t\t0x00\n#define ARCPGU_REG_STAT\t\t0x04\n#define ARCPGU_REG_FMT\t\t0x10\n#define ARCPGU_REG_HSYNC\t0x14\n#define ARCPGU_REG_VSYNC\t0x18\n#define ARCPGU_REG_ACTIVE\t0x1c\n#define ARCPGU_REG_BUF0_ADDR\t0x40\n#define ARCPGU_REG_STRIDE\t0x50\n#define ARCPGU_REG_START_SET\t0x84\n\n#define ARCPGU_REG_ID\t\t0x3FC\n\n#define ARCPGU_CTRL_ENABLE_MASK\t0x02\n#define ARCPGU_CTRL_VS_POL_MASK\t0x1\n#define ARCPGU_CTRL_VS_POL_OFST\t0x3\n#define ARCPGU_CTRL_HS_POL_MASK\t0x1\n#define ARCPGU_CTRL_HS_POL_OFST\t0x4\n#define ARCPGU_MODE_XRGB8888\tBIT(2)\n#define ARCPGU_STAT_BUSY_MASK\t0x02\n\nstruct arcpgu_drm_private {\n\tstruct drm_device\tdrm;\n\tvoid __iomem\t\t*regs;\n\tstruct clk\t\t*clk;\n\tstruct drm_simple_display_pipe pipe;\n\tstruct drm_connector\tsim_conn;\n};\n\n#define dev_to_arcpgu(x) container_of(x, struct arcpgu_drm_private, drm)\n\n#define pipe_to_arcpgu_priv(x) container_of(x, struct arcpgu_drm_private, pipe)\n\nstatic inline void arc_pgu_write(struct arcpgu_drm_private *arcpgu,\n\t\t\t\t unsigned int reg, u32 value)\n{\n\tiowrite32(value, arcpgu->regs + reg);\n}\n\nstatic inline u32 arc_pgu_read(struct arcpgu_drm_private *arcpgu,\n\t\t\t       unsigned int reg)\n{\n\treturn ioread32(arcpgu->regs + reg);\n}\n\n#define XRES_DEF\t640\n#define YRES_DEF\t480\n\n#define XRES_MAX\t8192\n#define YRES_MAX\t8192\n\nstatic int arcpgu_drm_connector_get_modes(struct drm_connector *connector)\n{\n\tint count;\n\n\tcount = drm_add_modes_noedid(connector, XRES_MAX, YRES_MAX);\n\tdrm_set_preferred_mode(connector, XRES_DEF, YRES_DEF);\n\treturn count;\n}\n\nstatic const struct drm_connector_helper_funcs\narcpgu_drm_connector_helper_funcs = {\n\t.get_modes = arcpgu_drm_connector_get_modes,\n};\n\nstatic const struct drm_connector_funcs arcpgu_drm_connector_funcs = {\n\t.reset = drm_atomic_helper_connector_reset,\n\t.fill_modes = drm_helper_probe_single_connector_modes,\n\t.destroy = drm_connector_cleanup,\n\t.atomic_duplicate_state = drm_atomic_helper_connector_duplicate_state,\n\t.atomic_destroy_state = drm_atomic_helper_connector_destroy_state,\n};\n\nstatic int arcpgu_drm_sim_init(struct drm_device *drm, struct drm_connector *connector)\n{\n\tdrm_connector_helper_add(connector, &arcpgu_drm_connector_helper_funcs);\n\treturn drm_connector_init(drm, connector, &arcpgu_drm_connector_funcs,\n\t\t\t\t  DRM_MODE_CONNECTOR_VIRTUAL);\n}\n\n#define ENCODE_PGU_XY(x, y)\t((((x) - 1) << 16) | ((y) - 1))\n\nstatic const u32 arc_pgu_supported_formats[] = {\n\tDRM_FORMAT_RGB565,\n\tDRM_FORMAT_XRGB8888,\n\tDRM_FORMAT_ARGB8888,\n};\n\nstatic void arc_pgu_set_pxl_fmt(struct arcpgu_drm_private *arcpgu)\n{\n\tconst struct drm_framebuffer *fb = arcpgu->pipe.plane.state->fb;\n\tuint32_t pixel_format = fb->format->format;\n\tu32 format = DRM_FORMAT_INVALID;\n\tint i;\n\tu32 reg_ctrl;\n\n\tfor (i = 0; i < ARRAY_SIZE(arc_pgu_supported_formats); i++) {\n\t\tif (arc_pgu_supported_formats[i] == pixel_format)\n\t\t\tformat = arc_pgu_supported_formats[i];\n\t}\n\n\tif (WARN_ON(format == DRM_FORMAT_INVALID))\n\t\treturn;\n\n\treg_ctrl = arc_pgu_read(arcpgu, ARCPGU_REG_CTRL);\n\tif (format == DRM_FORMAT_RGB565)\n\t\treg_ctrl &= ~ARCPGU_MODE_XRGB8888;\n\telse\n\t\treg_ctrl |= ARCPGU_MODE_XRGB8888;\n\tarc_pgu_write(arcpgu, ARCPGU_REG_CTRL, reg_ctrl);\n}\n\nstatic enum drm_mode_status arc_pgu_mode_valid(struct drm_simple_display_pipe *pipe,\n\t\t\t\t\t       const struct drm_display_mode *mode)\n{\n\tstruct arcpgu_drm_private *arcpgu = pipe_to_arcpgu_priv(pipe);\n\tlong rate, clk_rate = mode->clock * 1000;\n\tlong diff = clk_rate / 200;  \n\n\trate = clk_round_rate(arcpgu->clk, clk_rate);\n\tif ((max(rate, clk_rate) - min(rate, clk_rate) < diff) && (rate > 0))\n\t\treturn MODE_OK;\n\n\treturn MODE_NOCLOCK;\n}\n\nstatic void arc_pgu_mode_set(struct arcpgu_drm_private *arcpgu)\n{\n\tstruct drm_display_mode *m = &arcpgu->pipe.crtc.state->adjusted_mode;\n\tu32 val;\n\n\tarc_pgu_write(arcpgu, ARCPGU_REG_FMT,\n\t\t      ENCODE_PGU_XY(m->crtc_htotal, m->crtc_vtotal));\n\n\tarc_pgu_write(arcpgu, ARCPGU_REG_HSYNC,\n\t\t      ENCODE_PGU_XY(m->crtc_hsync_start - m->crtc_hdisplay,\n\t\t\t\t    m->crtc_hsync_end - m->crtc_hdisplay));\n\n\tarc_pgu_write(arcpgu, ARCPGU_REG_VSYNC,\n\t\t      ENCODE_PGU_XY(m->crtc_vsync_start - m->crtc_vdisplay,\n\t\t\t\t    m->crtc_vsync_end - m->crtc_vdisplay));\n\n\tarc_pgu_write(arcpgu, ARCPGU_REG_ACTIVE,\n\t\t      ENCODE_PGU_XY(m->crtc_hblank_end - m->crtc_hblank_start,\n\t\t\t\t    m->crtc_vblank_end - m->crtc_vblank_start));\n\n\tval = arc_pgu_read(arcpgu, ARCPGU_REG_CTRL);\n\n\tif (m->flags & DRM_MODE_FLAG_PVSYNC)\n\t\tval |= ARCPGU_CTRL_VS_POL_MASK << ARCPGU_CTRL_VS_POL_OFST;\n\telse\n\t\tval &= ~(ARCPGU_CTRL_VS_POL_MASK << ARCPGU_CTRL_VS_POL_OFST);\n\n\tif (m->flags & DRM_MODE_FLAG_PHSYNC)\n\t\tval |= ARCPGU_CTRL_HS_POL_MASK << ARCPGU_CTRL_HS_POL_OFST;\n\telse\n\t\tval &= ~(ARCPGU_CTRL_HS_POL_MASK << ARCPGU_CTRL_HS_POL_OFST);\n\n\tarc_pgu_write(arcpgu, ARCPGU_REG_CTRL, val);\n\tarc_pgu_write(arcpgu, ARCPGU_REG_STRIDE, 0);\n\tarc_pgu_write(arcpgu, ARCPGU_REG_START_SET, 1);\n\n\tarc_pgu_set_pxl_fmt(arcpgu);\n\n\tclk_set_rate(arcpgu->clk, m->crtc_clock * 1000);\n}\n\nstatic void arc_pgu_enable(struct drm_simple_display_pipe *pipe,\n\t\t\t   struct drm_crtc_state *crtc_state,\n\t\t\t   struct drm_plane_state *plane_state)\n{\n\tstruct arcpgu_drm_private *arcpgu = pipe_to_arcpgu_priv(pipe);\n\n\tarc_pgu_mode_set(arcpgu);\n\n\tclk_prepare_enable(arcpgu->clk);\n\tarc_pgu_write(arcpgu, ARCPGU_REG_CTRL,\n\t\t      arc_pgu_read(arcpgu, ARCPGU_REG_CTRL) |\n\t\t      ARCPGU_CTRL_ENABLE_MASK);\n}\n\nstatic void arc_pgu_disable(struct drm_simple_display_pipe *pipe)\n{\n\tstruct arcpgu_drm_private *arcpgu = pipe_to_arcpgu_priv(pipe);\n\n\tclk_disable_unprepare(arcpgu->clk);\n\tarc_pgu_write(arcpgu, ARCPGU_REG_CTRL,\n\t\t\t      arc_pgu_read(arcpgu, ARCPGU_REG_CTRL) &\n\t\t\t      ~ARCPGU_CTRL_ENABLE_MASK);\n}\n\nstatic void arc_pgu_update(struct drm_simple_display_pipe *pipe,\n\t\t\t   struct drm_plane_state *state)\n{\n\tstruct arcpgu_drm_private *arcpgu;\n\tstruct drm_gem_dma_object *gem;\n\n\tif (!pipe->plane.state->fb)\n\t\treturn;\n\n\tarcpgu = pipe_to_arcpgu_priv(pipe);\n\tgem = drm_fb_dma_get_gem_obj(pipe->plane.state->fb, 0);\n\tarc_pgu_write(arcpgu, ARCPGU_REG_BUF0_ADDR, gem->dma_addr);\n}\n\nstatic const struct drm_simple_display_pipe_funcs arc_pgu_pipe_funcs = {\n\t.update = arc_pgu_update,\n\t.mode_valid = arc_pgu_mode_valid,\n\t.enable\t= arc_pgu_enable,\n\t.disable = arc_pgu_disable,\n};\n\nstatic const struct drm_mode_config_funcs arcpgu_drm_modecfg_funcs = {\n\t.fb_create  = drm_gem_fb_create,\n\t.atomic_check = drm_atomic_helper_check,\n\t.atomic_commit = drm_atomic_helper_commit,\n};\n\nDEFINE_DRM_GEM_DMA_FOPS(arcpgu_drm_ops);\n\nstatic int arcpgu_load(struct arcpgu_drm_private *arcpgu)\n{\n\tstruct platform_device *pdev = to_platform_device(arcpgu->drm.dev);\n\tstruct device_node *encoder_node = NULL, *endpoint_node = NULL;\n\tstruct drm_connector *connector = NULL;\n\tstruct drm_device *drm = &arcpgu->drm;\n\tstruct resource *res;\n\tint ret;\n\n\tarcpgu->clk = devm_clk_get(drm->dev, \"pxlclk\");\n\tif (IS_ERR(arcpgu->clk))\n\t\treturn PTR_ERR(arcpgu->clk);\n\n\tret = drmm_mode_config_init(drm);\n\tif (ret)\n\t\treturn ret;\n\n\tdrm->mode_config.min_width = 0;\n\tdrm->mode_config.min_height = 0;\n\tdrm->mode_config.max_width = 1920;\n\tdrm->mode_config.max_height = 1080;\n\tdrm->mode_config.funcs = &arcpgu_drm_modecfg_funcs;\n\n\tres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\n\tarcpgu->regs = devm_ioremap_resource(&pdev->dev, res);\n\tif (IS_ERR(arcpgu->regs))\n\t\treturn PTR_ERR(arcpgu->regs);\n\n\tdev_info(drm->dev, \"arc_pgu ID: 0x%x\\n\",\n\t\t arc_pgu_read(arcpgu, ARCPGU_REG_ID));\n\n\t \n\tret = of_reserved_mem_device_init(drm->dev);\n\tif (ret && ret != -ENODEV)\n\t\treturn ret;\n\n\tif (dma_set_mask_and_coherent(drm->dev, DMA_BIT_MASK(32)))\n\t\treturn -ENODEV;\n\n\t \n\tendpoint_node = of_graph_get_next_endpoint(pdev->dev.of_node, NULL);\n\tif (endpoint_node) {\n\t\tencoder_node = of_graph_get_remote_port_parent(endpoint_node);\n\t\tof_node_put(endpoint_node);\n\t} else {\n\t\tconnector = &arcpgu->sim_conn;\n\t\tdev_info(drm->dev, \"no encoder found. Assumed virtual LCD on simulation platform\\n\");\n\t\tret = arcpgu_drm_sim_init(drm, connector);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\tret = drm_simple_display_pipe_init(drm, &arcpgu->pipe, &arc_pgu_pipe_funcs,\n\t\t\t\t\t   arc_pgu_supported_formats,\n\t\t\t\t\t   ARRAY_SIZE(arc_pgu_supported_formats),\n\t\t\t\t\t   NULL, connector);\n\tif (ret)\n\t\treturn ret;\n\n\tif (encoder_node) {\n\t\tstruct drm_bridge *bridge;\n\n\t\t \n\t\tbridge = of_drm_find_bridge(encoder_node);\n\t\tif (!bridge)\n\t\t\treturn -EPROBE_DEFER;\n\n\t\tret = drm_simple_display_pipe_attach_bridge(&arcpgu->pipe, bridge);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tdrm_mode_config_reset(drm);\n\tdrm_kms_helper_poll_init(drm);\n\n\tplatform_set_drvdata(pdev, drm);\n\treturn 0;\n}\n\nstatic int arcpgu_unload(struct drm_device *drm)\n{\n\tdrm_kms_helper_poll_fini(drm);\n\tdrm_atomic_helper_shutdown(drm);\n\n\treturn 0;\n}\n\n#ifdef CONFIG_DEBUG_FS\nstatic int arcpgu_show_pxlclock(struct seq_file *m, void *arg)\n{\n\tstruct drm_info_node *node = (struct drm_info_node *)m->private;\n\tstruct drm_device *drm = node->minor->dev;\n\tstruct arcpgu_drm_private *arcpgu = dev_to_arcpgu(drm);\n\tunsigned long clkrate = clk_get_rate(arcpgu->clk);\n\tunsigned long mode_clock = arcpgu->pipe.crtc.mode.crtc_clock * 1000;\n\n\tseq_printf(m, \"hw  : %lu\\n\", clkrate);\n\tseq_printf(m, \"mode: %lu\\n\", mode_clock);\n\treturn 0;\n}\n\nstatic struct drm_info_list arcpgu_debugfs_list[] = {\n\t{ \"clocks\", arcpgu_show_pxlclock, 0 },\n};\n\nstatic void arcpgu_debugfs_init(struct drm_minor *minor)\n{\n\tdrm_debugfs_create_files(arcpgu_debugfs_list,\n\t\t\t\t ARRAY_SIZE(arcpgu_debugfs_list),\n\t\t\t\t minor->debugfs_root, minor);\n}\n#endif\n\nstatic const struct drm_driver arcpgu_drm_driver = {\n\t.driver_features = DRIVER_MODESET | DRIVER_GEM | DRIVER_ATOMIC,\n\t.name = \"arcpgu\",\n\t.desc = \"ARC PGU Controller\",\n\t.date = \"20160219\",\n\t.major = 1,\n\t.minor = 0,\n\t.patchlevel = 0,\n\t.fops = &arcpgu_drm_ops,\n\tDRM_GEM_DMA_DRIVER_OPS,\n#ifdef CONFIG_DEBUG_FS\n\t.debugfs_init = arcpgu_debugfs_init,\n#endif\n};\n\nstatic int arcpgu_probe(struct platform_device *pdev)\n{\n\tstruct arcpgu_drm_private *arcpgu;\n\tint ret;\n\n\tarcpgu = devm_drm_dev_alloc(&pdev->dev, &arcpgu_drm_driver,\n\t\t\t\t    struct arcpgu_drm_private, drm);\n\tif (IS_ERR(arcpgu))\n\t\treturn PTR_ERR(arcpgu);\n\n\tret = arcpgu_load(arcpgu);\n\tif (ret)\n\t\treturn ret;\n\n\tret = drm_dev_register(&arcpgu->drm, 0);\n\tif (ret)\n\t\tgoto err_unload;\n\n\tdrm_fbdev_dma_setup(&arcpgu->drm, 16);\n\n\treturn 0;\n\nerr_unload:\n\tarcpgu_unload(&arcpgu->drm);\n\n\treturn ret;\n}\n\nstatic int arcpgu_remove(struct platform_device *pdev)\n{\n\tstruct drm_device *drm = platform_get_drvdata(pdev);\n\n\tdrm_dev_unregister(drm);\n\tarcpgu_unload(drm);\n\n\treturn 0;\n}\n\nstatic const struct of_device_id arcpgu_of_table[] = {\n\t{.compatible = \"snps,arcpgu\"},\n\t{}\n};\n\nMODULE_DEVICE_TABLE(of, arcpgu_of_table);\n\nstatic struct platform_driver arcpgu_platform_driver = {\n\t.probe = arcpgu_probe,\n\t.remove = arcpgu_remove,\n\t.driver = {\n\t\t   .name = \"arcpgu\",\n\t\t   .of_match_table = arcpgu_of_table,\n\t\t   },\n};\n\ndrm_module_platform_driver(arcpgu_platform_driver);\n\nMODULE_AUTHOR(\"Carlos Palminha <palminha@synopsys.com>\");\nMODULE_DESCRIPTION(\"ARC PGU DRM driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}