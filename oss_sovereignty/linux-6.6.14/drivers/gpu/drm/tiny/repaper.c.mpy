{
  "module_name": "repaper.c",
  "hash_id": "a90edb656357c72c225f4a0965d45890e675f5a29f400c91fad15ac9ad18ec35",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/tiny/repaper.c",
  "human_readable_source": "\n \n\n#include <linux/delay.h>\n#include <linux/gpio/consumer.h>\n#include <linux/module.h>\n#include <linux/property.h>\n#include <linux/sched/clock.h>\n#include <linux/spi/spi.h>\n#include <linux/thermal.h>\n\n#include <drm/drm_atomic_helper.h>\n#include <drm/drm_connector.h>\n#include <drm/drm_damage_helper.h>\n#include <drm/drm_drv.h>\n#include <drm/drm_fb_dma_helper.h>\n#include <drm/drm_fbdev_generic.h>\n#include <drm/drm_format_helper.h>\n#include <drm/drm_framebuffer.h>\n#include <drm/drm_gem_atomic_helper.h>\n#include <drm/drm_gem_dma_helper.h>\n#include <drm/drm_gem_framebuffer_helper.h>\n#include <drm/drm_managed.h>\n#include <drm/drm_modes.h>\n#include <drm/drm_rect.h>\n#include <drm/drm_probe_helper.h>\n#include <drm/drm_simple_kms_helper.h>\n\n#define REPAPER_RID_G2_COG_ID\t0x12\n\nenum repaper_model {\n\t \n\tE1144CS021 = 1,\n\tE1190CS021,\n\tE2200CS021,\n\tE2271CS021,\n};\n\nenum repaper_stage {          \n\tREPAPER_COMPENSATE,   \n\tREPAPER_WHITE,        \n\tREPAPER_INVERSE,      \n\tREPAPER_NORMAL        \n};\n\nenum repaper_epd_border_byte {\n\tREPAPER_BORDER_BYTE_NONE,\n\tREPAPER_BORDER_BYTE_ZERO,\n\tREPAPER_BORDER_BYTE_SET,\n};\n\nstruct repaper_epd {\n\tstruct drm_device drm;\n\tstruct drm_simple_display_pipe pipe;\n\tconst struct drm_display_mode *mode;\n\tstruct drm_connector connector;\n\tstruct spi_device *spi;\n\n\tstruct gpio_desc *panel_on;\n\tstruct gpio_desc *border;\n\tstruct gpio_desc *discharge;\n\tstruct gpio_desc *reset;\n\tstruct gpio_desc *busy;\n\n\tstruct thermal_zone_device *thermal;\n\n\tunsigned int height;\n\tunsigned int width;\n\tunsigned int bytes_per_scan;\n\tconst u8 *channel_select;\n\tunsigned int stage_time;\n\tunsigned int factored_stage_time;\n\tbool middle_scan;\n\tbool pre_border_byte;\n\tenum repaper_epd_border_byte border_byte;\n\n\tu8 *line_buffer;\n\tvoid *current_frame;\n\n\tbool cleared;\n\tbool partial;\n};\n\nstatic inline struct repaper_epd *drm_to_epd(struct drm_device *drm)\n{\n\treturn container_of(drm, struct repaper_epd, drm);\n}\n\nstatic int repaper_spi_transfer(struct spi_device *spi, u8 header,\n\t\t\t\tconst void *tx, void *rx, size_t len)\n{\n\tvoid *txbuf = NULL, *rxbuf = NULL;\n\tstruct spi_transfer tr[2] = {};\n\tu8 *headerbuf;\n\tint ret;\n\n\theaderbuf = kmalloc(1, GFP_KERNEL);\n\tif (!headerbuf)\n\t\treturn -ENOMEM;\n\n\theaderbuf[0] = header;\n\ttr[0].tx_buf = headerbuf;\n\ttr[0].len = 1;\n\n\t \n\tif (tx && len <= 32) {\n\t\ttxbuf = kmemdup(tx, len, GFP_KERNEL);\n\t\tif (!txbuf) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto out_free;\n\t\t}\n\t}\n\n\tif (rx) {\n\t\trxbuf = kmalloc(len, GFP_KERNEL);\n\t\tif (!rxbuf) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto out_free;\n\t\t}\n\t}\n\n\ttr[1].tx_buf = txbuf ? txbuf : tx;\n\ttr[1].rx_buf = rxbuf;\n\ttr[1].len = len;\n\n\tndelay(80);\n\tret = spi_sync_transfer(spi, tr, 2);\n\tif (rx && !ret)\n\t\tmemcpy(rx, rxbuf, len);\n\nout_free:\n\tkfree(headerbuf);\n\tkfree(txbuf);\n\tkfree(rxbuf);\n\n\treturn ret;\n}\n\nstatic int repaper_write_buf(struct spi_device *spi, u8 reg,\n\t\t\t     const u8 *buf, size_t len)\n{\n\tint ret;\n\n\tret = repaper_spi_transfer(spi, 0x70, &reg, NULL, 1);\n\tif (ret)\n\t\treturn ret;\n\n\treturn repaper_spi_transfer(spi, 0x72, buf, NULL, len);\n}\n\nstatic int repaper_write_val(struct spi_device *spi, u8 reg, u8 val)\n{\n\treturn repaper_write_buf(spi, reg, &val, 1);\n}\n\nstatic int repaper_read_val(struct spi_device *spi, u8 reg)\n{\n\tint ret;\n\tu8 val;\n\n\tret = repaper_spi_transfer(spi, 0x70, &reg, NULL, 1);\n\tif (ret)\n\t\treturn ret;\n\n\tret = repaper_spi_transfer(spi, 0x73, NULL, &val, 1);\n\n\treturn ret ? ret : val;\n}\n\nstatic int repaper_read_id(struct spi_device *spi)\n{\n\tint ret;\n\tu8 id;\n\n\tret = repaper_spi_transfer(spi, 0x71, NULL, &id, 1);\n\n\treturn ret ? ret : id;\n}\n\nstatic void repaper_spi_mosi_low(struct spi_device *spi)\n{\n\tconst u8 buf[1] = { 0 };\n\n\tspi_write(spi, buf, 1);\n}\n\n \nstatic void repaper_even_pixels(struct repaper_epd *epd, u8 **pp,\n\t\t\t\tconst u8 *data, u8 fixed_value, const u8 *mask,\n\t\t\t\tenum repaper_stage stage)\n{\n\tunsigned int b;\n\n\tfor (b = 0; b < (epd->width / 8); b++) {\n\t\tif (data) {\n\t\t\tu8 pixels = data[b] & 0xaa;\n\t\t\tu8 pixel_mask = 0xff;\n\t\t\tu8 p1, p2, p3, p4;\n\n\t\t\tif (mask) {\n\t\t\t\tpixel_mask = (mask[b] ^ pixels) & 0xaa;\n\t\t\t\tpixel_mask |= pixel_mask >> 1;\n\t\t\t}\n\n\t\t\tswitch (stage) {\n\t\t\tcase REPAPER_COMPENSATE:  \n\t\t\t\tpixels = 0xaa | ((pixels ^ 0xaa) >> 1);\n\t\t\t\tbreak;\n\t\t\tcase REPAPER_WHITE:       \n\t\t\t\tpixels = 0x55 + ((pixels ^ 0xaa) >> 1);\n\t\t\t\tbreak;\n\t\t\tcase REPAPER_INVERSE:     \n\t\t\t\tpixels = 0x55 | (pixels ^ 0xaa);\n\t\t\t\tbreak;\n\t\t\tcase REPAPER_NORMAL:      \n\t\t\t\tpixels = 0xaa | (pixels >> 1);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tpixels = (pixels & pixel_mask) | (~pixel_mask & 0x55);\n\t\t\tp1 = (pixels >> 6) & 0x03;\n\t\t\tp2 = (pixels >> 4) & 0x03;\n\t\t\tp3 = (pixels >> 2) & 0x03;\n\t\t\tp4 = (pixels >> 0) & 0x03;\n\t\t\tpixels = (p1 << 0) | (p2 << 2) | (p3 << 4) | (p4 << 6);\n\t\t\t*(*pp)++ = pixels;\n\t\t} else {\n\t\t\t*(*pp)++ = fixed_value;\n\t\t}\n\t}\n}\n\n \nstatic void repaper_odd_pixels(struct repaper_epd *epd, u8 **pp,\n\t\t\t       const u8 *data, u8 fixed_value, const u8 *mask,\n\t\t\t       enum repaper_stage stage)\n{\n\tunsigned int b;\n\n\tfor (b = epd->width / 8; b > 0; b--) {\n\t\tif (data) {\n\t\t\tu8 pixels = data[b - 1] & 0x55;\n\t\t\tu8 pixel_mask = 0xff;\n\n\t\t\tif (mask) {\n\t\t\t\tpixel_mask = (mask[b - 1] ^ pixels) & 0x55;\n\t\t\t\tpixel_mask |= pixel_mask << 1;\n\t\t\t}\n\n\t\t\tswitch (stage) {\n\t\t\tcase REPAPER_COMPENSATE:  \n\t\t\t\tpixels = 0xaa | (pixels ^ 0x55);\n\t\t\t\tbreak;\n\t\t\tcase REPAPER_WHITE:       \n\t\t\t\tpixels = 0x55 + (pixels ^ 0x55);\n\t\t\t\tbreak;\n\t\t\tcase REPAPER_INVERSE:     \n\t\t\t\tpixels = 0x55 | ((pixels ^ 0x55) << 1);\n\t\t\t\tbreak;\n\t\t\tcase REPAPER_NORMAL:      \n\t\t\t\tpixels = 0xaa | pixels;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tpixels = (pixels & pixel_mask) | (~pixel_mask & 0x55);\n\t\t\t*(*pp)++ = pixels;\n\t\t} else {\n\t\t\t*(*pp)++ = fixed_value;\n\t\t}\n\t}\n}\n\n \nstatic inline u16 repaper_interleave_bits(u16 value)\n{\n\tvalue = (value | (value << 4)) & 0x0f0f;\n\tvalue = (value | (value << 2)) & 0x3333;\n\tvalue = (value | (value << 1)) & 0x5555;\n\n\treturn value;\n}\n\n \nstatic void repaper_all_pixels(struct repaper_epd *epd, u8 **pp,\n\t\t\t       const u8 *data, u8 fixed_value, const u8 *mask,\n\t\t\t       enum repaper_stage stage)\n{\n\tunsigned int b;\n\n\tfor (b = epd->width / 8; b > 0; b--) {\n\t\tif (data) {\n\t\t\tu16 pixels = repaper_interleave_bits(data[b - 1]);\n\t\t\tu16 pixel_mask = 0xffff;\n\n\t\t\tif (mask) {\n\t\t\t\tpixel_mask = repaper_interleave_bits(mask[b - 1]);\n\n\t\t\t\tpixel_mask = (pixel_mask ^ pixels) & 0x5555;\n\t\t\t\tpixel_mask |= pixel_mask << 1;\n\t\t\t}\n\n\t\t\tswitch (stage) {\n\t\t\tcase REPAPER_COMPENSATE:  \n\t\t\t\tpixels = 0xaaaa | (pixels ^ 0x5555);\n\t\t\t\tbreak;\n\t\t\tcase REPAPER_WHITE:       \n\t\t\t\tpixels = 0x5555 + (pixels ^ 0x5555);\n\t\t\t\tbreak;\n\t\t\tcase REPAPER_INVERSE:     \n\t\t\t\tpixels = 0x5555 | ((pixels ^ 0x5555) << 1);\n\t\t\t\tbreak;\n\t\t\tcase REPAPER_NORMAL:      \n\t\t\t\tpixels = 0xaaaa | pixels;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tpixels = (pixels & pixel_mask) | (~pixel_mask & 0x5555);\n\t\t\t*(*pp)++ = pixels >> 8;\n\t\t\t*(*pp)++ = pixels;\n\t\t} else {\n\t\t\t*(*pp)++ = fixed_value;\n\t\t\t*(*pp)++ = fixed_value;\n\t\t}\n\t}\n}\n\n \nstatic void repaper_one_line(struct repaper_epd *epd, unsigned int line,\n\t\t\t     const u8 *data, u8 fixed_value, const u8 *mask,\n\t\t\t     enum repaper_stage stage)\n{\n\tu8 *p = epd->line_buffer;\n\tunsigned int b;\n\n\trepaper_spi_mosi_low(epd->spi);\n\n\tif (epd->pre_border_byte)\n\t\t*p++ = 0x00;\n\n\tif (epd->middle_scan) {\n\t\t \n\t\trepaper_odd_pixels(epd, &p, data, fixed_value, mask, stage);\n\n\t\t \n\t\tfor (b = epd->bytes_per_scan; b > 0; b--) {\n\t\t\tif (line / 4 == b - 1)\n\t\t\t\t*p++ = 0x03 << (2 * (line & 0x03));\n\t\t\telse\n\t\t\t\t*p++ = 0x00;\n\t\t}\n\n\t\t \n\t\trepaper_even_pixels(epd, &p, data, fixed_value, mask, stage);\n\t} else {\n\t\t \n\t\tfor (b = 0; b < epd->bytes_per_scan; b++) {\n\t\t\tif (0 != (line & 0x01) && line / 8 == b)\n\t\t\t\t*p++ = 0xc0 >> (line & 0x06);\n\t\t\telse\n\t\t\t\t*p++ = 0x00;\n\t\t}\n\n\t\t \n\t\trepaper_all_pixels(epd, &p, data, fixed_value, mask, stage);\n\n\t\t \n\t\tfor (b = epd->bytes_per_scan; b > 0; b--) {\n\t\t\tif (0 == (line & 0x01) && line / 8 == b - 1)\n\t\t\t\t*p++ = 0x03 << (line & 0x06);\n\t\t\telse\n\t\t\t\t*p++ = 0x00;\n\t\t}\n\t}\n\n\tswitch (epd->border_byte) {\n\tcase REPAPER_BORDER_BYTE_NONE:\n\t\tbreak;\n\n\tcase REPAPER_BORDER_BYTE_ZERO:\n\t\t*p++ = 0x00;\n\t\tbreak;\n\n\tcase REPAPER_BORDER_BYTE_SET:\n\t\tswitch (stage) {\n\t\tcase REPAPER_COMPENSATE:\n\t\tcase REPAPER_WHITE:\n\t\tcase REPAPER_INVERSE:\n\t\t\t*p++ = 0x00;\n\t\t\tbreak;\n\t\tcase REPAPER_NORMAL:\n\t\t\t*p++ = 0xaa;\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\t}\n\n\trepaper_write_buf(epd->spi, 0x0a, epd->line_buffer,\n\t\t\t  p - epd->line_buffer);\n\n\t \n\trepaper_write_val(epd->spi, 0x02, 0x07);\n\n\trepaper_spi_mosi_low(epd->spi);\n}\n\nstatic void repaper_frame_fixed(struct repaper_epd *epd, u8 fixed_value,\n\t\t\t\tenum repaper_stage stage)\n{\n\tunsigned int line;\n\n\tfor (line = 0; line < epd->height; line++)\n\t\trepaper_one_line(epd, line, NULL, fixed_value, NULL, stage);\n}\n\nstatic void repaper_frame_data(struct repaper_epd *epd, const u8 *image,\n\t\t\t       const u8 *mask, enum repaper_stage stage)\n{\n\tunsigned int line;\n\n\tif (!mask) {\n\t\tfor (line = 0; line < epd->height; line++) {\n\t\t\trepaper_one_line(epd, line,\n\t\t\t\t\t &image[line * (epd->width / 8)],\n\t\t\t\t\t 0, NULL, stage);\n\t\t}\n\t} else {\n\t\tfor (line = 0; line < epd->height; line++) {\n\t\t\tsize_t n = line * epd->width / 8;\n\n\t\t\trepaper_one_line(epd, line, &image[n], 0, &mask[n],\n\t\t\t\t\t stage);\n\t\t}\n\t}\n}\n\nstatic void repaper_frame_fixed_repeat(struct repaper_epd *epd, u8 fixed_value,\n\t\t\t\t       enum repaper_stage stage)\n{\n\tu64 start = local_clock();\n\tu64 end = start + (epd->factored_stage_time * 1000 * 1000);\n\n\tdo {\n\t\trepaper_frame_fixed(epd, fixed_value, stage);\n\t} while (local_clock() < end);\n}\n\nstatic void repaper_frame_data_repeat(struct repaper_epd *epd, const u8 *image,\n\t\t\t\t      const u8 *mask, enum repaper_stage stage)\n{\n\tu64 start = local_clock();\n\tu64 end = start + (epd->factored_stage_time * 1000 * 1000);\n\n\tdo {\n\t\trepaper_frame_data(epd, image, mask, stage);\n\t} while (local_clock() < end);\n}\n\nstatic void repaper_get_temperature(struct repaper_epd *epd)\n{\n\tint ret, temperature = 0;\n\tunsigned int factor10x;\n\n\tif (!epd->thermal)\n\t\treturn;\n\n\tret = thermal_zone_get_temp(epd->thermal, &temperature);\n\tif (ret) {\n\t\tDRM_DEV_ERROR(&epd->spi->dev, \"Failed to get temperature (%d)\\n\", ret);\n\t\treturn;\n\t}\n\n\ttemperature /= 1000;\n\n\tif (temperature <= -10)\n\t\tfactor10x = 170;\n\telse if (temperature <= -5)\n\t\tfactor10x = 120;\n\telse if (temperature <= 5)\n\t\tfactor10x = 80;\n\telse if (temperature <= 10)\n\t\tfactor10x = 40;\n\telse if (temperature <= 15)\n\t\tfactor10x = 30;\n\telse if (temperature <= 20)\n\t\tfactor10x = 20;\n\telse if (temperature <= 40)\n\t\tfactor10x = 10;\n\telse\n\t\tfactor10x = 7;\n\n\tepd->factored_stage_time = epd->stage_time * factor10x / 10;\n}\n\nstatic int repaper_fb_dirty(struct drm_framebuffer *fb)\n{\n\tstruct drm_gem_dma_object *dma_obj = drm_fb_dma_get_gem_obj(fb, 0);\n\tstruct repaper_epd *epd = drm_to_epd(fb->dev);\n\tunsigned int dst_pitch = 0;\n\tstruct iosys_map dst, vmap;\n\tstruct drm_rect clip;\n\tint idx, ret = 0;\n\tu8 *buf = NULL;\n\n\tif (!drm_dev_enter(fb->dev, &idx))\n\t\treturn -ENODEV;\n\n\t \n\tclip.x1 = 0;\n\tclip.x2 = fb->width;\n\tclip.y1 = 0;\n\tclip.y2 = fb->height;\n\n\trepaper_get_temperature(epd);\n\n\tDRM_DEBUG(\"Flushing [FB:%d] st=%ums\\n\", fb->base.id,\n\t\t  epd->factored_stage_time);\n\n\tbuf = kmalloc(fb->width * fb->height / 8, GFP_KERNEL);\n\tif (!buf) {\n\t\tret = -ENOMEM;\n\t\tgoto out_exit;\n\t}\n\n\tret = drm_gem_fb_begin_cpu_access(fb, DMA_FROM_DEVICE);\n\tif (ret)\n\t\tgoto out_free;\n\n\tiosys_map_set_vaddr(&dst, buf);\n\tiosys_map_set_vaddr(&vmap, dma_obj->vaddr);\n\tdrm_fb_xrgb8888_to_mono(&dst, &dst_pitch, &vmap, fb, &clip);\n\n\tdrm_gem_fb_end_cpu_access(fb, DMA_FROM_DEVICE);\n\n\tif (epd->partial) {\n\t\trepaper_frame_data_repeat(epd, buf, epd->current_frame,\n\t\t\t\t\t  REPAPER_NORMAL);\n\t} else if (epd->cleared) {\n\t\trepaper_frame_data_repeat(epd, epd->current_frame, NULL,\n\t\t\t\t\t  REPAPER_COMPENSATE);\n\t\trepaper_frame_data_repeat(epd, epd->current_frame, NULL,\n\t\t\t\t\t  REPAPER_WHITE);\n\t\trepaper_frame_data_repeat(epd, buf, NULL, REPAPER_INVERSE);\n\t\trepaper_frame_data_repeat(epd, buf, NULL, REPAPER_NORMAL);\n\n\t\tepd->partial = true;\n\t} else {\n\t\t \n\t\trepaper_frame_fixed_repeat(epd, 0xff, REPAPER_COMPENSATE);\n\t\trepaper_frame_fixed_repeat(epd, 0xff, REPAPER_WHITE);\n\t\trepaper_frame_fixed_repeat(epd, 0xaa, REPAPER_INVERSE);\n\t\trepaper_frame_fixed_repeat(epd, 0xaa, REPAPER_NORMAL);\n\n\t\t \n\t\trepaper_frame_fixed_repeat(epd, 0xaa, REPAPER_COMPENSATE);\n\t\trepaper_frame_fixed_repeat(epd, 0xaa, REPAPER_WHITE);\n\t\trepaper_frame_data_repeat(epd, buf, NULL, REPAPER_INVERSE);\n\t\trepaper_frame_data_repeat(epd, buf, NULL, REPAPER_NORMAL);\n\n\t\tepd->cleared = true;\n\t\tepd->partial = true;\n\t}\n\n\tmemcpy(epd->current_frame, buf, fb->width * fb->height / 8);\n\n\t \n\tif (epd->pre_border_byte) {\n\t\tunsigned int x;\n\n\t\tfor (x = 0; x < (fb->width / 8); x++)\n\t\t\tif (buf[x + (fb->width * (fb->height - 1) / 8)]) {\n\t\t\t\trepaper_frame_data_repeat(epd, buf,\n\t\t\t\t\t\t\t  epd->current_frame,\n\t\t\t\t\t\t\t  REPAPER_NORMAL);\n\t\t\t\tbreak;\n\t\t\t}\n\t}\n\nout_free:\n\tkfree(buf);\nout_exit:\n\tdrm_dev_exit(idx);\n\n\treturn ret;\n}\n\nstatic void power_off(struct repaper_epd *epd)\n{\n\t \n\tgpiod_set_value_cansleep(epd->reset, 0);\n\tgpiod_set_value_cansleep(epd->panel_on, 0);\n\tif (epd->border)\n\t\tgpiod_set_value_cansleep(epd->border, 0);\n\n\t \n\trepaper_spi_mosi_low(epd->spi);\n\n\t \n\tgpiod_set_value_cansleep(epd->discharge, 1);\n\tmsleep(150);\n\tgpiod_set_value_cansleep(epd->discharge, 0);\n}\n\nstatic enum drm_mode_status repaper_pipe_mode_valid(struct drm_simple_display_pipe *pipe,\n\t\t\t\t\t\t    const struct drm_display_mode *mode)\n{\n\tstruct drm_crtc *crtc = &pipe->crtc;\n\tstruct repaper_epd *epd = drm_to_epd(crtc->dev);\n\n\treturn drm_crtc_helper_mode_valid_fixed(crtc, mode, epd->mode);\n}\n\nstatic void repaper_pipe_enable(struct drm_simple_display_pipe *pipe,\n\t\t\t\tstruct drm_crtc_state *crtc_state,\n\t\t\t\tstruct drm_plane_state *plane_state)\n{\n\tstruct repaper_epd *epd = drm_to_epd(pipe->crtc.dev);\n\tstruct spi_device *spi = epd->spi;\n\tstruct device *dev = &spi->dev;\n\tbool dc_ok = false;\n\tint i, ret, idx;\n\n\tif (!drm_dev_enter(pipe->crtc.dev, &idx))\n\t\treturn;\n\n\tDRM_DEBUG_DRIVER(\"\\n\");\n\n\t \n\tgpiod_set_value_cansleep(epd->reset, 0);\n\tgpiod_set_value_cansleep(epd->panel_on, 0);\n\tgpiod_set_value_cansleep(epd->discharge, 0);\n\tif (epd->border)\n\t\tgpiod_set_value_cansleep(epd->border, 0);\n\trepaper_spi_mosi_low(spi);\n\tusleep_range(5000, 10000);\n\n\tgpiod_set_value_cansleep(epd->panel_on, 1);\n\t \n\tusleep_range(10000, 15000);\n\tgpiod_set_value_cansleep(epd->reset, 1);\n\tif (epd->border)\n\t\tgpiod_set_value_cansleep(epd->border, 1);\n\tusleep_range(5000, 10000);\n\tgpiod_set_value_cansleep(epd->reset, 0);\n\tusleep_range(5000, 10000);\n\tgpiod_set_value_cansleep(epd->reset, 1);\n\tusleep_range(5000, 10000);\n\n\t \n\tfor (i = 100; i > 0; i--) {\n\t\tif (!gpiod_get_value_cansleep(epd->busy))\n\t\t\tbreak;\n\n\t\tusleep_range(10, 100);\n\t}\n\n\tif (!i) {\n\t\tDRM_DEV_ERROR(dev, \"timeout waiting for panel to become ready.\\n\");\n\t\tpower_off(epd);\n\t\tgoto out_exit;\n\t}\n\n\trepaper_read_id(spi);\n\tret = repaper_read_id(spi);\n\tif (ret != REPAPER_RID_G2_COG_ID) {\n\t\tif (ret < 0)\n\t\t\tdev_err(dev, \"failed to read chip (%d)\\n\", ret);\n\t\telse\n\t\t\tdev_err(dev, \"wrong COG ID 0x%02x\\n\", ret);\n\t\tpower_off(epd);\n\t\tgoto out_exit;\n\t}\n\n\t \n\trepaper_write_val(spi, 0x02, 0x40);\n\n\tret = repaper_read_val(spi, 0x0f);\n\tif (ret < 0 || !(ret & 0x80)) {\n\t\tif (ret < 0)\n\t\t\tDRM_DEV_ERROR(dev, \"failed to read chip (%d)\\n\", ret);\n\t\telse\n\t\t\tDRM_DEV_ERROR(dev, \"panel is reported broken\\n\");\n\t\tpower_off(epd);\n\t\tgoto out_exit;\n\t}\n\n\t \n\trepaper_write_val(spi, 0x0b, 0x02);\n\t \n\trepaper_write_buf(spi, 0x01, epd->channel_select, 8);\n\t \n\trepaper_write_val(spi, 0x07, 0xd1);\n\t \n\trepaper_write_val(spi, 0x08, 0x02);\n\t \n\trepaper_write_val(spi, 0x09, 0xc2);\n\t \n\trepaper_write_val(spi, 0x04, 0x03);\n\t \n\trepaper_write_val(spi, 0x03, 0x01);\n\t \n\trepaper_write_val(spi, 0x03, 0x00);\n\tusleep_range(5000, 10000);\n\n\t \n\tfor (i = 0; i < 4; ++i) {\n\t\t \n\t\trepaper_write_val(spi, 0x05, 0x01);\n\t\tmsleep(240);\n\n\t\t \n\t\trepaper_write_val(spi, 0x05, 0x03);\n\t\tmsleep(40);\n\n\t\t \n\t\trepaper_write_val(spi, 0x05, 0x0f);\n\t\tmsleep(40);\n\n\t\t \n\t\tret = repaper_read_val(spi, 0x0f);\n\t\tif (ret < 0) {\n\t\t\tDRM_DEV_ERROR(dev, \"failed to read chip (%d)\\n\", ret);\n\t\t\tpower_off(epd);\n\t\t\tgoto out_exit;\n\t\t}\n\n\t\tif (ret & 0x40) {\n\t\t\tdc_ok = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!dc_ok) {\n\t\tDRM_DEV_ERROR(dev, \"dc/dc failed\\n\");\n\t\tpower_off(epd);\n\t\tgoto out_exit;\n\t}\n\n\t \n\trepaper_write_val(spi, 0x02, 0x04);\n\n\tepd->partial = false;\nout_exit:\n\tdrm_dev_exit(idx);\n}\n\nstatic void repaper_pipe_disable(struct drm_simple_display_pipe *pipe)\n{\n\tstruct repaper_epd *epd = drm_to_epd(pipe->crtc.dev);\n\tstruct spi_device *spi = epd->spi;\n\tunsigned int line;\n\n\t \n\n\tDRM_DEBUG_DRIVER(\"\\n\");\n\n\t \n\tfor (line = 0; line < epd->height; line++)\n\t\trepaper_one_line(epd, 0x7fffu, NULL, 0x00, NULL,\n\t\t\t\t REPAPER_COMPENSATE);\n\n\t \n\tif (epd->border) {\n\t\t \n\t\trepaper_one_line(epd, 0x7fffu, NULL, 0x00, NULL,\n\t\t\t\t REPAPER_COMPENSATE);\n\t\tmsleep(25);\n\t\tgpiod_set_value_cansleep(epd->border, 0);\n\t\tmsleep(200);\n\t\tgpiod_set_value_cansleep(epd->border, 1);\n\t} else {\n\t\t \n\t\trepaper_one_line(epd, 0x7fffu, NULL, 0x00, NULL,\n\t\t\t\t REPAPER_NORMAL);\n\t\tmsleep(200);\n\t}\n\n\t \n\trepaper_write_val(spi, 0x0b, 0x00);\n\t \n\trepaper_write_val(spi, 0x03, 0x01);\n\t \n\trepaper_write_val(spi, 0x05, 0x03);\n\t \n\trepaper_write_val(spi, 0x05, 0x01);\n\tmsleep(120);\n\t \n\trepaper_write_val(spi, 0x04, 0x80);\n\t \n\trepaper_write_val(spi, 0x05, 0x00);\n\t \n\trepaper_write_val(spi, 0x07, 0x01);\n\tmsleep(50);\n\n\tpower_off(epd);\n}\n\nstatic void repaper_pipe_update(struct drm_simple_display_pipe *pipe,\n\t\t\t\tstruct drm_plane_state *old_state)\n{\n\tstruct drm_plane_state *state = pipe->plane.state;\n\tstruct drm_rect rect;\n\n\tif (!pipe->crtc.state->active)\n\t\treturn;\n\n\tif (drm_atomic_helper_damage_merged(old_state, state, &rect))\n\t\trepaper_fb_dirty(state->fb);\n}\n\nstatic const struct drm_simple_display_pipe_funcs repaper_pipe_funcs = {\n\t.mode_valid = repaper_pipe_mode_valid,\n\t.enable = repaper_pipe_enable,\n\t.disable = repaper_pipe_disable,\n\t.update = repaper_pipe_update,\n};\n\nstatic int repaper_connector_get_modes(struct drm_connector *connector)\n{\n\tstruct repaper_epd *epd = drm_to_epd(connector->dev);\n\n\treturn drm_connector_helper_get_modes_fixed(connector, epd->mode);\n}\n\nstatic const struct drm_connector_helper_funcs repaper_connector_hfuncs = {\n\t.get_modes = repaper_connector_get_modes,\n};\n\nstatic const struct drm_connector_funcs repaper_connector_funcs = {\n\t.reset = drm_atomic_helper_connector_reset,\n\t.fill_modes = drm_helper_probe_single_connector_modes,\n\t.destroy = drm_connector_cleanup,\n\t.atomic_duplicate_state = drm_atomic_helper_connector_duplicate_state,\n\t.atomic_destroy_state = drm_atomic_helper_connector_destroy_state,\n};\n\nstatic const struct drm_mode_config_funcs repaper_mode_config_funcs = {\n\t.fb_create = drm_gem_fb_create_with_dirty,\n\t.atomic_check = drm_atomic_helper_check,\n\t.atomic_commit = drm_atomic_helper_commit,\n};\n\nstatic const uint32_t repaper_formats[] = {\n\tDRM_FORMAT_XRGB8888,\n};\n\nstatic const struct drm_display_mode repaper_e1144cs021_mode = {\n\tDRM_SIMPLE_MODE(128, 96, 29, 22),\n};\n\nstatic const u8 repaper_e1144cs021_cs[] = { 0x00, 0x00, 0x00, 0x00,\n\t\t\t\t\t    0x00, 0x0f, 0xff, 0x00 };\n\nstatic const struct drm_display_mode repaper_e1190cs021_mode = {\n\tDRM_SIMPLE_MODE(144, 128, 36, 32),\n};\n\nstatic const u8 repaper_e1190cs021_cs[] = { 0x00, 0x00, 0x00, 0x03,\n\t\t\t\t\t    0xfc, 0x00, 0x00, 0xff };\n\nstatic const struct drm_display_mode repaper_e2200cs021_mode = {\n\tDRM_SIMPLE_MODE(200, 96, 46, 22),\n};\n\nstatic const u8 repaper_e2200cs021_cs[] = { 0x00, 0x00, 0x00, 0x00,\n\t\t\t\t\t    0x01, 0xff, 0xe0, 0x00 };\n\nstatic const struct drm_display_mode repaper_e2271cs021_mode = {\n\tDRM_SIMPLE_MODE(264, 176, 57, 38),\n};\n\nstatic const u8 repaper_e2271cs021_cs[] = { 0x00, 0x00, 0x00, 0x7f,\n\t\t\t\t\t    0xff, 0xfe, 0x00, 0x00 };\n\nDEFINE_DRM_GEM_DMA_FOPS(repaper_fops);\n\nstatic const struct drm_driver repaper_driver = {\n\t.driver_features\t= DRIVER_GEM | DRIVER_MODESET | DRIVER_ATOMIC,\n\t.fops\t\t\t= &repaper_fops,\n\tDRM_GEM_DMA_DRIVER_OPS_VMAP,\n\t.name\t\t\t= \"repaper\",\n\t.desc\t\t\t= \"Pervasive Displays RePaper e-ink panels\",\n\t.date\t\t\t= \"20170405\",\n\t.major\t\t\t= 1,\n\t.minor\t\t\t= 0,\n};\n\nstatic const struct of_device_id repaper_of_match[] = {\n\t{ .compatible = \"pervasive,e1144cs021\", .data = (void *)E1144CS021 },\n\t{ .compatible = \"pervasive,e1190cs021\", .data = (void *)E1190CS021 },\n\t{ .compatible = \"pervasive,e2200cs021\", .data = (void *)E2200CS021 },\n\t{ .compatible = \"pervasive,e2271cs021\", .data = (void *)E2271CS021 },\n\t{},\n};\nMODULE_DEVICE_TABLE(of, repaper_of_match);\n\nstatic const struct spi_device_id repaper_id[] = {\n\t{ \"e1144cs021\", E1144CS021 },\n\t{ \"e1190cs021\", E1190CS021 },\n\t{ \"e2200cs021\", E2200CS021 },\n\t{ \"e2271cs021\", E2271CS021 },\n\t{ },\n};\nMODULE_DEVICE_TABLE(spi, repaper_id);\n\nstatic int repaper_probe(struct spi_device *spi)\n{\n\tconst struct drm_display_mode *mode;\n\tconst struct spi_device_id *spi_id;\n\tstruct device *dev = &spi->dev;\n\tenum repaper_model model;\n\tconst char *thermal_zone;\n\tstruct repaper_epd *epd;\n\tsize_t line_buffer_size;\n\tstruct drm_device *drm;\n\tconst void *match;\n\tint ret;\n\n\tmatch = device_get_match_data(dev);\n\tif (match) {\n\t\tmodel = (enum repaper_model)match;\n\t} else {\n\t\tspi_id = spi_get_device_id(spi);\n\t\tmodel = (enum repaper_model)spi_id->driver_data;\n\t}\n\n\t \n\tif (!dev->coherent_dma_mask) {\n\t\tret = dma_coerce_mask_and_coherent(dev, DMA_BIT_MASK(32));\n\t\tif (ret) {\n\t\t\tdev_warn(dev, \"Failed to set dma mask %d\\n\", ret);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tepd = devm_drm_dev_alloc(dev, &repaper_driver,\n\t\t\t\t struct repaper_epd, drm);\n\tif (IS_ERR(epd))\n\t\treturn PTR_ERR(epd);\n\n\tdrm = &epd->drm;\n\n\tret = drmm_mode_config_init(drm);\n\tif (ret)\n\t\treturn ret;\n\tdrm->mode_config.funcs = &repaper_mode_config_funcs;\n\n\tepd->spi = spi;\n\n\tepd->panel_on = devm_gpiod_get(dev, \"panel-on\", GPIOD_OUT_LOW);\n\tif (IS_ERR(epd->panel_on)) {\n\t\tret = PTR_ERR(epd->panel_on);\n\t\tif (ret != -EPROBE_DEFER)\n\t\t\tDRM_DEV_ERROR(dev, \"Failed to get gpio 'panel-on'\\n\");\n\t\treturn ret;\n\t}\n\n\tepd->discharge = devm_gpiod_get(dev, \"discharge\", GPIOD_OUT_LOW);\n\tif (IS_ERR(epd->discharge)) {\n\t\tret = PTR_ERR(epd->discharge);\n\t\tif (ret != -EPROBE_DEFER)\n\t\t\tDRM_DEV_ERROR(dev, \"Failed to get gpio 'discharge'\\n\");\n\t\treturn ret;\n\t}\n\n\tepd->reset = devm_gpiod_get(dev, \"reset\", GPIOD_OUT_LOW);\n\tif (IS_ERR(epd->reset)) {\n\t\tret = PTR_ERR(epd->reset);\n\t\tif (ret != -EPROBE_DEFER)\n\t\t\tDRM_DEV_ERROR(dev, \"Failed to get gpio 'reset'\\n\");\n\t\treturn ret;\n\t}\n\n\tepd->busy = devm_gpiod_get(dev, \"busy\", GPIOD_IN);\n\tif (IS_ERR(epd->busy)) {\n\t\tret = PTR_ERR(epd->busy);\n\t\tif (ret != -EPROBE_DEFER)\n\t\t\tDRM_DEV_ERROR(dev, \"Failed to get gpio 'busy'\\n\");\n\t\treturn ret;\n\t}\n\n\tif (!device_property_read_string(dev, \"pervasive,thermal-zone\",\n\t\t\t\t\t &thermal_zone)) {\n\t\tepd->thermal = thermal_zone_get_zone_by_name(thermal_zone);\n\t\tif (IS_ERR(epd->thermal)) {\n\t\t\tDRM_DEV_ERROR(dev, \"Failed to get thermal zone: %s\\n\", thermal_zone);\n\t\t\treturn PTR_ERR(epd->thermal);\n\t\t}\n\t}\n\n\tswitch (model) {\n\tcase E1144CS021:\n\t\tmode = &repaper_e1144cs021_mode;\n\t\tepd->channel_select = repaper_e1144cs021_cs;\n\t\tepd->stage_time = 480;\n\t\tepd->bytes_per_scan = 96 / 4;\n\t\tepd->middle_scan = true;  \n\t\tepd->pre_border_byte = false;\n\t\tepd->border_byte = REPAPER_BORDER_BYTE_ZERO;\n\t\tbreak;\n\n\tcase E1190CS021:\n\t\tmode = &repaper_e1190cs021_mode;\n\t\tepd->channel_select = repaper_e1190cs021_cs;\n\t\tepd->stage_time = 480;\n\t\tepd->bytes_per_scan = 128 / 4 / 2;\n\t\tepd->middle_scan = false;  \n\t\tepd->pre_border_byte = false;\n\t\tepd->border_byte = REPAPER_BORDER_BYTE_SET;\n\t\tbreak;\n\n\tcase E2200CS021:\n\t\tmode = &repaper_e2200cs021_mode;\n\t\tepd->channel_select = repaper_e2200cs021_cs;\n\t\tepd->stage_time = 480;\n\t\tepd->bytes_per_scan = 96 / 4;\n\t\tepd->middle_scan = true;  \n\t\tepd->pre_border_byte = true;\n\t\tepd->border_byte = REPAPER_BORDER_BYTE_NONE;\n\t\tbreak;\n\n\tcase E2271CS021:\n\t\tepd->border = devm_gpiod_get(dev, \"border\", GPIOD_OUT_LOW);\n\t\tif (IS_ERR(epd->border)) {\n\t\t\tret = PTR_ERR(epd->border);\n\t\t\tif (ret != -EPROBE_DEFER)\n\t\t\t\tDRM_DEV_ERROR(dev, \"Failed to get gpio 'border'\\n\");\n\t\t\treturn ret;\n\t\t}\n\n\t\tmode = &repaper_e2271cs021_mode;\n\t\tepd->channel_select = repaper_e2271cs021_cs;\n\t\tepd->stage_time = 630;\n\t\tepd->bytes_per_scan = 176 / 4;\n\t\tepd->middle_scan = true;  \n\t\tepd->pre_border_byte = true;\n\t\tepd->border_byte = REPAPER_BORDER_BYTE_NONE;\n\t\tbreak;\n\n\tdefault:\n\t\treturn -ENODEV;\n\t}\n\n\tepd->mode = mode;\n\tepd->width = mode->hdisplay;\n\tepd->height = mode->vdisplay;\n\tepd->factored_stage_time = epd->stage_time;\n\n\tline_buffer_size = 2 * epd->width / 8 + epd->bytes_per_scan + 2;\n\tepd->line_buffer = devm_kzalloc(dev, line_buffer_size, GFP_KERNEL);\n\tif (!epd->line_buffer)\n\t\treturn -ENOMEM;\n\n\tepd->current_frame = devm_kzalloc(dev, epd->width * epd->height / 8,\n\t\t\t\t\t  GFP_KERNEL);\n\tif (!epd->current_frame)\n\t\treturn -ENOMEM;\n\n\tdrm->mode_config.min_width = mode->hdisplay;\n\tdrm->mode_config.max_width = mode->hdisplay;\n\tdrm->mode_config.min_height = mode->vdisplay;\n\tdrm->mode_config.max_height = mode->vdisplay;\n\n\tdrm_connector_helper_add(&epd->connector, &repaper_connector_hfuncs);\n\tret = drm_connector_init(drm, &epd->connector, &repaper_connector_funcs,\n\t\t\t\t DRM_MODE_CONNECTOR_SPI);\n\tif (ret)\n\t\treturn ret;\n\n\tret = drm_simple_display_pipe_init(drm, &epd->pipe, &repaper_pipe_funcs,\n\t\t\t\t\t   repaper_formats, ARRAY_SIZE(repaper_formats),\n\t\t\t\t\t   NULL, &epd->connector);\n\tif (ret)\n\t\treturn ret;\n\n\tdrm_mode_config_reset(drm);\n\n\tret = drm_dev_register(drm, 0);\n\tif (ret)\n\t\treturn ret;\n\n\tspi_set_drvdata(spi, drm);\n\n\tDRM_DEBUG_DRIVER(\"SPI speed: %uMHz\\n\", spi->max_speed_hz / 1000000);\n\n\tdrm_fbdev_generic_setup(drm, 0);\n\n\treturn 0;\n}\n\nstatic void repaper_remove(struct spi_device *spi)\n{\n\tstruct drm_device *drm = spi_get_drvdata(spi);\n\n\tdrm_dev_unplug(drm);\n\tdrm_atomic_helper_shutdown(drm);\n}\n\nstatic void repaper_shutdown(struct spi_device *spi)\n{\n\tdrm_atomic_helper_shutdown(spi_get_drvdata(spi));\n}\n\nstatic struct spi_driver repaper_spi_driver = {\n\t.driver = {\n\t\t.name = \"repaper\",\n\t\t.of_match_table = repaper_of_match,\n\t},\n\t.id_table = repaper_id,\n\t.probe = repaper_probe,\n\t.remove = repaper_remove,\n\t.shutdown = repaper_shutdown,\n};\nmodule_spi_driver(repaper_spi_driver);\n\nMODULE_DESCRIPTION(\"Pervasive Displays RePaper DRM driver\");\nMODULE_AUTHOR(\"Noralf Tr\u00f8nnes\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}