{
  "module_name": "hx8357d.c",
  "hash_id": "b427846c645950d7d87f1ef5c1f35bebdd1eb37962cd7dbe703d93545196ee5a",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/tiny/hx8357d.c",
  "human_readable_source": "\n \n\n#include <linux/backlight.h>\n#include <linux/delay.h>\n#include <linux/gpio/consumer.h>\n#include <linux/module.h>\n#include <linux/property.h>\n#include <linux/spi/spi.h>\n\n#include <drm/drm_atomic_helper.h>\n#include <drm/drm_drv.h>\n#include <drm/drm_fbdev_generic.h>\n#include <drm/drm_gem_atomic_helper.h>\n#include <drm/drm_gem_dma_helper.h>\n#include <drm/drm_managed.h>\n#include <drm/drm_mipi_dbi.h>\n#include <drm/drm_modeset_helper.h>\n#include <video/mipi_display.h>\n\n#define HX8357D_SETOSC 0xb0\n#define HX8357D_SETPOWER 0xb1\n#define HX8357D_SETRGB 0xb3\n#define HX8357D_SETCYC 0xb3\n#define HX8357D_SETCOM 0xb6\n#define HX8357D_SETEXTC 0xb9\n#define HX8357D_SETSTBA 0xc0\n#define HX8357D_SETPANEL 0xcc\n#define HX8357D_SETGAMMA 0xe0\n\n#define HX8357D_MADCTL_MY  0x80\n#define HX8357D_MADCTL_MX  0x40\n#define HX8357D_MADCTL_MV  0x20\n#define HX8357D_MADCTL_ML  0x10\n#define HX8357D_MADCTL_RGB 0x00\n#define HX8357D_MADCTL_BGR 0x08\n#define HX8357D_MADCTL_MH  0x04\n\nstatic void yx240qv29_enable(struct drm_simple_display_pipe *pipe,\n\t\t\t     struct drm_crtc_state *crtc_state,\n\t\t\t     struct drm_plane_state *plane_state)\n{\n\tstruct mipi_dbi_dev *dbidev = drm_to_mipi_dbi_dev(pipe->crtc.dev);\n\tstruct mipi_dbi *dbi = &dbidev->dbi;\n\tu8 addr_mode;\n\tint ret, idx;\n\n\tif (!drm_dev_enter(pipe->crtc.dev, &idx))\n\t\treturn;\n\n\tDRM_DEBUG_KMS(\"\\n\");\n\n\tret = mipi_dbi_poweron_conditional_reset(dbidev);\n\tif (ret < 0)\n\t\tgoto out_exit;\n\tif (ret == 1)\n\t\tgoto out_enable;\n\n\t \n\tmipi_dbi_command(dbi, HX8357D_SETEXTC, 0xFF, 0x83, 0x57);\n\tmsleep(150);\n\n\t \n\tmipi_dbi_command(dbi, HX8357D_SETRGB, 0x00, 0x00, 0x06, 0x06);\n\n\t \n\tmipi_dbi_command(dbi, HX8357D_SETCOM, 0x25);\n\n\t \n\tmipi_dbi_command(dbi, HX8357D_SETOSC, 0x68);\n\n\t \n\tmipi_dbi_command(dbi, HX8357D_SETPANEL, 0x05);\n\n\tmipi_dbi_command(dbi, HX8357D_SETPOWER,\n\t\t\t 0x00,   \n\t\t\t 0x15,   \n\t\t\t 0x1C,   \n\t\t\t 0x1C,   \n\t\t\t 0x83,   \n\t\t\t 0xAA);   \n\n\tmipi_dbi_command(dbi, HX8357D_SETSTBA,\n\t\t\t 0x50,   \n\t\t\t 0x50,   \n\t\t\t 0x01,   \n\t\t\t 0x3C,   \n\t\t\t 0x1E,   \n\t\t\t 0x08);   \n\n\tmipi_dbi_command(dbi, HX8357D_SETCYC,\n\t\t\t 0x02,   \n\t\t\t 0x40,   \n\t\t\t 0x00,   \n\t\t\t 0x2A,   \n\t\t\t 0x2A,   \n\t\t\t 0x0D,   \n\t\t\t 0x78);   \n\n\tmipi_dbi_command(dbi, HX8357D_SETGAMMA,\n\t\t\t 0x02,\n\t\t\t 0x0A,\n\t\t\t 0x11,\n\t\t\t 0x1d,\n\t\t\t 0x23,\n\t\t\t 0x35,\n\t\t\t 0x41,\n\t\t\t 0x4b,\n\t\t\t 0x4b,\n\t\t\t 0x42,\n\t\t\t 0x3A,\n\t\t\t 0x27,\n\t\t\t 0x1B,\n\t\t\t 0x08,\n\t\t\t 0x09,\n\t\t\t 0x03,\n\t\t\t 0x02,\n\t\t\t 0x0A,\n\t\t\t 0x11,\n\t\t\t 0x1d,\n\t\t\t 0x23,\n\t\t\t 0x35,\n\t\t\t 0x41,\n\t\t\t 0x4b,\n\t\t\t 0x4b,\n\t\t\t 0x42,\n\t\t\t 0x3A,\n\t\t\t 0x27,\n\t\t\t 0x1B,\n\t\t\t 0x08,\n\t\t\t 0x09,\n\t\t\t 0x03,\n\t\t\t 0x00,\n\t\t\t 0x01);\n\n\t \n\tmipi_dbi_command(dbi, MIPI_DCS_SET_PIXEL_FORMAT,\n\t\t\t MIPI_DCS_PIXEL_FMT_16BIT);\n\n\t \n\tmipi_dbi_command(dbi, MIPI_DCS_SET_TEAR_ON, 0x00);\n\n\t \n\tmipi_dbi_command(dbi, MIPI_DCS_SET_TEAR_SCANLINE, 0x00, 0x02);\n\n\t \n\tmipi_dbi_command(dbi, MIPI_DCS_EXIT_SLEEP_MODE);\n\tmsleep(150);\n\n\t \n\tmipi_dbi_command(dbi, MIPI_DCS_SET_DISPLAY_ON);\n\tusleep_range(5000, 7000);\n\nout_enable:\n\tswitch (dbidev->rotation) {\n\tdefault:\n\t\taddr_mode = HX8357D_MADCTL_MX | HX8357D_MADCTL_MY;\n\t\tbreak;\n\tcase 90:\n\t\taddr_mode = HX8357D_MADCTL_MV | HX8357D_MADCTL_MY;\n\t\tbreak;\n\tcase 180:\n\t\taddr_mode = 0;\n\t\tbreak;\n\tcase 270:\n\t\taddr_mode = HX8357D_MADCTL_MV | HX8357D_MADCTL_MX;\n\t\tbreak;\n\t}\n\tmipi_dbi_command(dbi, MIPI_DCS_SET_ADDRESS_MODE, addr_mode);\n\tmipi_dbi_enable_flush(dbidev, crtc_state, plane_state);\nout_exit:\n\tdrm_dev_exit(idx);\n}\n\nstatic const struct drm_simple_display_pipe_funcs hx8357d_pipe_funcs = {\n\tDRM_MIPI_DBI_SIMPLE_DISPLAY_PIPE_FUNCS(yx240qv29_enable),\n};\n\nstatic const struct drm_display_mode yx350hv15_mode = {\n\tDRM_SIMPLE_MODE(320, 480, 60, 75),\n};\n\nDEFINE_DRM_GEM_DMA_FOPS(hx8357d_fops);\n\nstatic const struct drm_driver hx8357d_driver = {\n\t.driver_features\t= DRIVER_GEM | DRIVER_MODESET | DRIVER_ATOMIC,\n\t.fops\t\t\t= &hx8357d_fops,\n\tDRM_GEM_DMA_DRIVER_OPS_VMAP,\n\t.debugfs_init\t\t= mipi_dbi_debugfs_init,\n\t.name\t\t\t= \"hx8357d\",\n\t.desc\t\t\t= \"HX8357D\",\n\t.date\t\t\t= \"20181023\",\n\t.major\t\t\t= 1,\n\t.minor\t\t\t= 0,\n};\n\nstatic const struct of_device_id hx8357d_of_match[] = {\n\t{ .compatible = \"adafruit,yx350hv15\" },\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, hx8357d_of_match);\n\nstatic const struct spi_device_id hx8357d_id[] = {\n\t{ \"yx350hv15\", 0 },\n\t{ }\n};\nMODULE_DEVICE_TABLE(spi, hx8357d_id);\n\nstatic int hx8357d_probe(struct spi_device *spi)\n{\n\tstruct device *dev = &spi->dev;\n\tstruct mipi_dbi_dev *dbidev;\n\tstruct drm_device *drm;\n\tstruct gpio_desc *dc;\n\tu32 rotation = 0;\n\tint ret;\n\n\tdbidev = devm_drm_dev_alloc(dev, &hx8357d_driver,\n\t\t\t\t    struct mipi_dbi_dev, drm);\n\tif (IS_ERR(dbidev))\n\t\treturn PTR_ERR(dbidev);\n\n\tdrm = &dbidev->drm;\n\n\tdc = devm_gpiod_get(dev, \"dc\", GPIOD_OUT_LOW);\n\tif (IS_ERR(dc))\n\t\treturn dev_err_probe(dev, PTR_ERR(dc), \"Failed to get GPIO 'dc'\\n\");\n\n\tdbidev->backlight = devm_of_find_backlight(dev);\n\tif (IS_ERR(dbidev->backlight))\n\t\treturn PTR_ERR(dbidev->backlight);\n\n\tdevice_property_read_u32(dev, \"rotation\", &rotation);\n\n\tret = mipi_dbi_spi_init(spi, &dbidev->dbi, dc);\n\tif (ret)\n\t\treturn ret;\n\n\tret = mipi_dbi_dev_init(dbidev, &hx8357d_pipe_funcs, &yx350hv15_mode, rotation);\n\tif (ret)\n\t\treturn ret;\n\n\tdrm_mode_config_reset(drm);\n\n\tret = drm_dev_register(drm, 0);\n\tif (ret)\n\t\treturn ret;\n\n\tspi_set_drvdata(spi, drm);\n\n\tdrm_fbdev_generic_setup(drm, 0);\n\n\treturn 0;\n}\n\nstatic void hx8357d_remove(struct spi_device *spi)\n{\n\tstruct drm_device *drm = spi_get_drvdata(spi);\n\n\tdrm_dev_unplug(drm);\n\tdrm_atomic_helper_shutdown(drm);\n}\n\nstatic void hx8357d_shutdown(struct spi_device *spi)\n{\n\tdrm_atomic_helper_shutdown(spi_get_drvdata(spi));\n}\n\nstatic struct spi_driver hx8357d_spi_driver = {\n\t.driver = {\n\t\t.name = \"hx8357d\",\n\t\t.of_match_table = hx8357d_of_match,\n\t},\n\t.id_table = hx8357d_id,\n\t.probe = hx8357d_probe,\n\t.remove = hx8357d_remove,\n\t.shutdown = hx8357d_shutdown,\n};\nmodule_spi_driver(hx8357d_spi_driver);\n\nMODULE_DESCRIPTION(\"HX8357D DRM driver\");\nMODULE_AUTHOR(\"Eric Anholt <eric@anholt.net>\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}