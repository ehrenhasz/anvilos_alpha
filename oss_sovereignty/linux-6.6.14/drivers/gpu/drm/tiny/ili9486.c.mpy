{
  "module_name": "ili9486.c",
  "hash_id": "93a6e5eb1ebeffb6d59b1798009281ad0e3eeb49e3f6b0f98317d4bbf2e88e3d",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/tiny/ili9486.c",
  "human_readable_source": "\n \n\n#include <linux/backlight.h>\n#include <linux/delay.h>\n#include <linux/gpio/consumer.h>\n#include <linux/module.h>\n#include <linux/property.h>\n#include <linux/spi/spi.h>\n\n#include <video/mipi_display.h>\n\n#include <drm/drm_atomic_helper.h>\n#include <drm/drm_drv.h>\n#include <drm/drm_fbdev_generic.h>\n#include <drm/drm_gem_atomic_helper.h>\n#include <drm/drm_gem_dma_helper.h>\n#include <drm/drm_managed.h>\n#include <drm/drm_mipi_dbi.h>\n#include <drm/drm_modeset_helper.h>\n\n#define ILI9486_ITFCTR1         0xb0\n#define ILI9486_PWCTRL1         0xc2\n#define ILI9486_VMCTRL1         0xc5\n#define ILI9486_PGAMCTRL        0xe0\n#define ILI9486_NGAMCTRL        0xe1\n#define ILI9486_DGAMCTRL        0xe2\n#define ILI9486_MADCTL_BGR      BIT(3)\n#define ILI9486_MADCTL_MV       BIT(5)\n#define ILI9486_MADCTL_MX       BIT(6)\n#define ILI9486_MADCTL_MY       BIT(7)\n\n \nstatic int waveshare_command(struct mipi_dbi *mipi, u8 *cmd, u8 *par,\n\t\t\t     size_t num)\n{\n\tstruct spi_device *spi = mipi->spi;\n\tunsigned int bpw = 8;\n\tvoid *data = par;\n\tu32 speed_hz;\n\tint i, ret;\n\t__be16 *buf;\n\n\tbuf = kmalloc(32 * sizeof(u16), GFP_KERNEL);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\t \n\tbuf[0] = cpu_to_be16(*cmd);\n\tspi_bus_lock(spi->controller);\n\tgpiod_set_value_cansleep(mipi->dc, 0);\n\tspeed_hz = mipi_dbi_spi_cmd_max_speed(spi, 2);\n\tret = mipi_dbi_spi_transfer(spi, speed_hz, 8, buf, 2);\n\tspi_bus_unlock(spi->controller);\n\tif (ret || !num)\n\t\tgoto free;\n\n\t \n\tif (num <= 32) {\n\t\tfor (i = 0; i < num; i++)\n\t\t\tbuf[i] = cpu_to_be16(par[i]);\n\t\tnum *= 2;\n\t\tdata = buf;\n\t}\n\n\t \n\tif (*cmd == MIPI_DCS_WRITE_MEMORY_START && !mipi->swap_bytes)\n\t\tbpw = 16;\n\n\tspi_bus_lock(spi->controller);\n\tgpiod_set_value_cansleep(mipi->dc, 1);\n\tspeed_hz = mipi_dbi_spi_cmd_max_speed(spi, num);\n\tret = mipi_dbi_spi_transfer(spi, speed_hz, bpw, data, num);\n\tspi_bus_unlock(spi->controller);\n free:\n\tkfree(buf);\n\n\treturn ret;\n}\n\nstatic void waveshare_enable(struct drm_simple_display_pipe *pipe,\n\t\t\t     struct drm_crtc_state *crtc_state,\n\t\t\t     struct drm_plane_state *plane_state)\n{\n\tstruct mipi_dbi_dev *dbidev = drm_to_mipi_dbi_dev(pipe->crtc.dev);\n\tstruct mipi_dbi *dbi = &dbidev->dbi;\n\tu8 addr_mode;\n\tint ret, idx;\n\n\tif (!drm_dev_enter(pipe->crtc.dev, &idx))\n\t\treturn;\n\n\tDRM_DEBUG_KMS(\"\\n\");\n\n\tret = mipi_dbi_poweron_conditional_reset(dbidev);\n\tif (ret < 0)\n\t\tgoto out_exit;\n\tif (ret == 1)\n\t\tgoto out_enable;\n\n\tmipi_dbi_command(dbi, ILI9486_ITFCTR1);\n\tmipi_dbi_command(dbi, MIPI_DCS_EXIT_SLEEP_MODE);\n\tmsleep(250);\n\n\tmipi_dbi_command(dbi, MIPI_DCS_SET_PIXEL_FORMAT, 0x55);\n\n\tmipi_dbi_command(dbi, ILI9486_PWCTRL1, 0x44);\n\n\tmipi_dbi_command(dbi, ILI9486_VMCTRL1, 0x00, 0x00, 0x00, 0x00);\n\n\tmipi_dbi_command(dbi, ILI9486_PGAMCTRL,\n\t\t\t 0x0F, 0x1F, 0x1C, 0x0C, 0x0F, 0x08, 0x48, 0x98,\n\t\t\t 0x37, 0x0A, 0x13, 0x04, 0x11, 0x0D, 0x0);\n\tmipi_dbi_command(dbi, ILI9486_NGAMCTRL,\n\t\t\t 0x0F, 0x32, 0x2E, 0x0B, 0x0D, 0x05, 0x47, 0x75,\n\t\t\t 0x37, 0x06, 0x10, 0x03, 0x24, 0x20, 0x00);\n\tmipi_dbi_command(dbi, ILI9486_DGAMCTRL,\n\t\t\t 0x0F, 0x32, 0x2E, 0x0B, 0x0D, 0x05, 0x47, 0x75,\n\t\t\t 0x37, 0x06, 0x10, 0x03, 0x24, 0x20, 0x00);\n\n\tmipi_dbi_command(dbi, MIPI_DCS_SET_DISPLAY_ON);\n\tmsleep(100);\n\n out_enable:\n\tswitch (dbidev->rotation) {\n\tcase 90:\n\t\taddr_mode = ILI9486_MADCTL_MY;\n\t\tbreak;\n\tcase 180:\n\t\taddr_mode = ILI9486_MADCTL_MV;\n\t\tbreak;\n\tcase 270:\n\t\taddr_mode = ILI9486_MADCTL_MX;\n\t\tbreak;\n\tdefault:\n\t\taddr_mode = ILI9486_MADCTL_MV | ILI9486_MADCTL_MY |\n\t\t\tILI9486_MADCTL_MX;\n\t\tbreak;\n\t}\n\taddr_mode |= ILI9486_MADCTL_BGR;\n\tmipi_dbi_command(dbi, MIPI_DCS_SET_ADDRESS_MODE, addr_mode);\n\tmipi_dbi_enable_flush(dbidev, crtc_state, plane_state);\n out_exit:\n\tdrm_dev_exit(idx);\n}\n\nstatic const struct drm_simple_display_pipe_funcs waveshare_pipe_funcs = {\n\tDRM_MIPI_DBI_SIMPLE_DISPLAY_PIPE_FUNCS(waveshare_enable),\n};\n\nstatic const struct drm_display_mode waveshare_mode = {\n\tDRM_SIMPLE_MODE(480, 320, 73, 49),\n};\n\nDEFINE_DRM_GEM_DMA_FOPS(ili9486_fops);\n\nstatic const struct drm_driver ili9486_driver = {\n\t.driver_features\t= DRIVER_GEM | DRIVER_MODESET | DRIVER_ATOMIC,\n\t.fops\t\t\t= &ili9486_fops,\n\tDRM_GEM_DMA_DRIVER_OPS_VMAP,\n\t.debugfs_init\t\t= mipi_dbi_debugfs_init,\n\t.name\t\t\t= \"ili9486\",\n\t.desc\t\t\t= \"Ilitek ILI9486\",\n\t.date\t\t\t= \"20200118\",\n\t.major\t\t\t= 1,\n\t.minor\t\t\t= 0,\n};\n\nstatic const struct of_device_id ili9486_of_match[] = {\n\t{ .compatible = \"waveshare,rpi-lcd-35\" },\n\t{ .compatible = \"ozzmaker,piscreen\" },\n\t{},\n};\nMODULE_DEVICE_TABLE(of, ili9486_of_match);\n\nstatic const struct spi_device_id ili9486_id[] = {\n\t{ \"ili9486\", 0 },\n\t{ \"rpi-lcd-35\", 0 },\n\t{ \"piscreen\", 0 },\n\t{ }\n};\nMODULE_DEVICE_TABLE(spi, ili9486_id);\n\nstatic int ili9486_probe(struct spi_device *spi)\n{\n\tstruct device *dev = &spi->dev;\n\tstruct mipi_dbi_dev *dbidev;\n\tstruct drm_device *drm;\n\tstruct mipi_dbi *dbi;\n\tstruct gpio_desc *dc;\n\tu32 rotation = 0;\n\tint ret;\n\n\tdbidev = devm_drm_dev_alloc(dev, &ili9486_driver,\n\t\t\t\t    struct mipi_dbi_dev, drm);\n\tif (IS_ERR(dbidev))\n\t\treturn PTR_ERR(dbidev);\n\n\tdbi = &dbidev->dbi;\n\tdrm = &dbidev->drm;\n\n\tdbi->reset = devm_gpiod_get(dev, \"reset\", GPIOD_OUT_HIGH);\n\tif (IS_ERR(dbi->reset))\n\t\treturn dev_err_probe(dev, PTR_ERR(dbi->reset), \"Failed to get GPIO 'reset'\\n\");\n\n\tdc = devm_gpiod_get(dev, \"dc\", GPIOD_OUT_LOW);\n\tif (IS_ERR(dc))\n\t\treturn dev_err_probe(dev, PTR_ERR(dc), \"Failed to get GPIO 'dc'\\n\");\n\n\tdbidev->backlight = devm_of_find_backlight(dev);\n\tif (IS_ERR(dbidev->backlight))\n\t\treturn PTR_ERR(dbidev->backlight);\n\n\tdevice_property_read_u32(dev, \"rotation\", &rotation);\n\n\tret = mipi_dbi_spi_init(spi, dbi, dc);\n\tif (ret)\n\t\treturn ret;\n\n\tdbi->command = waveshare_command;\n\tdbi->read_commands = NULL;\n\n\tret = mipi_dbi_dev_init(dbidev, &waveshare_pipe_funcs,\n\t\t\t\t&waveshare_mode, rotation);\n\tif (ret)\n\t\treturn ret;\n\n\tdrm_mode_config_reset(drm);\n\n\tret = drm_dev_register(drm, 0);\n\tif (ret)\n\t\treturn ret;\n\n\tspi_set_drvdata(spi, drm);\n\n\tdrm_fbdev_generic_setup(drm, 0);\n\n\treturn 0;\n}\n\nstatic void ili9486_remove(struct spi_device *spi)\n{\n\tstruct drm_device *drm = spi_get_drvdata(spi);\n\n\tdrm_dev_unplug(drm);\n\tdrm_atomic_helper_shutdown(drm);\n}\n\nstatic void ili9486_shutdown(struct spi_device *spi)\n{\n\tdrm_atomic_helper_shutdown(spi_get_drvdata(spi));\n}\n\nstatic struct spi_driver ili9486_spi_driver = {\n\t.driver = {\n\t\t.name = \"ili9486\",\n\t\t.of_match_table = ili9486_of_match,\n\t},\n\t.id_table = ili9486_id,\n\t.probe = ili9486_probe,\n\t.remove = ili9486_remove,\n\t.shutdown = ili9486_shutdown,\n};\nmodule_spi_driver(ili9486_spi_driver);\n\nMODULE_DESCRIPTION(\"Ilitek ILI9486 DRM driver\");\nMODULE_AUTHOR(\"Kamlesh Gurudasani <kamlesh.gurudasani@gmail.com>\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}