{
  "module_name": "st7586.c",
  "hash_id": "00c8b6face0960196d4a92f82a8a95efe354287b7a96b762f03e10e1db8f9409",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/tiny/st7586.c",
  "human_readable_source": "\n \n\n#include <linux/delay.h>\n#include <linux/gpio/consumer.h>\n#include <linux/module.h>\n#include <linux/property.h>\n#include <linux/spi/spi.h>\n#include <video/mipi_display.h>\n\n#include <drm/drm_atomic_helper.h>\n#include <drm/drm_damage_helper.h>\n#include <drm/drm_drv.h>\n#include <drm/drm_fb_dma_helper.h>\n#include <drm/drm_fbdev_generic.h>\n#include <drm/drm_format_helper.h>\n#include <drm/drm_framebuffer.h>\n#include <drm/drm_gem_atomic_helper.h>\n#include <drm/drm_gem_dma_helper.h>\n#include <drm/drm_gem_framebuffer_helper.h>\n#include <drm/drm_managed.h>\n#include <drm/drm_mipi_dbi.h>\n#include <drm/drm_rect.h>\n\n \n#define ST7586_DISP_MODE_GRAY\t0x38\n#define ST7586_DISP_MODE_MONO\t0x39\n#define ST7586_ENABLE_DDRAM\t0x3a\n#define ST7586_SET_DISP_DUTY\t0xb0\n#define ST7586_SET_PART_DISP\t0xb4\n#define ST7586_SET_NLINE_INV\t0xb5\n#define ST7586_SET_VOP\t\t0xc0\n#define ST7586_SET_BIAS_SYSTEM\t0xc3\n#define ST7586_SET_BOOST_LEVEL\t0xc4\n#define ST7586_SET_VOP_OFFSET\t0xc7\n#define ST7586_ENABLE_ANALOG\t0xd0\n#define ST7586_AUTO_READ_CTRL\t0xd7\n#define ST7586_OTP_RW_CTRL\t0xe0\n#define ST7586_OTP_CTRL_OUT\t0xe1\n#define ST7586_OTP_READ\t\t0xe3\n\n#define ST7586_DISP_CTRL_MX\tBIT(6)\n#define ST7586_DISP_CTRL_MY\tBIT(7)\n\n \n\nstatic const u8 st7586_lookup[] = { 0x7, 0x4, 0x2, 0x0 };\n\nstatic void st7586_xrgb8888_to_gray332(u8 *dst, void *vaddr,\n\t\t\t\t       struct drm_framebuffer *fb,\n\t\t\t\t       struct drm_rect *clip)\n{\n\tsize_t len = (clip->x2 - clip->x1) * (clip->y2 - clip->y1);\n\tunsigned int x, y;\n\tu8 *src, *buf, val;\n\tstruct iosys_map dst_map, vmap;\n\n\tbuf = kmalloc(len, GFP_KERNEL);\n\tif (!buf)\n\t\treturn;\n\n\tiosys_map_set_vaddr(&dst_map, buf);\n\tiosys_map_set_vaddr(&vmap, vaddr);\n\tdrm_fb_xrgb8888_to_gray8(&dst_map, NULL, &vmap, fb, clip);\n\tsrc = buf;\n\n\tfor (y = clip->y1; y < clip->y2; y++) {\n\t\tfor (x = clip->x1; x < clip->x2; x += 3) {\n\t\t\tval = st7586_lookup[*src++ >> 6] << 5;\n\t\t\tval |= st7586_lookup[*src++ >> 6] << 2;\n\t\t\tval |= st7586_lookup[*src++ >> 6] >> 1;\n\t\t\t*dst++ = val;\n\t\t}\n\t}\n\n\tkfree(buf);\n}\n\nstatic int st7586_buf_copy(void *dst, struct iosys_map *src, struct drm_framebuffer *fb,\n\t\t\t   struct drm_rect *clip)\n{\n\tint ret;\n\n\tret = drm_gem_fb_begin_cpu_access(fb, DMA_FROM_DEVICE);\n\tif (ret)\n\t\treturn ret;\n\n\tst7586_xrgb8888_to_gray332(dst, src->vaddr, fb, clip);\n\n\tdrm_gem_fb_end_cpu_access(fb, DMA_FROM_DEVICE);\n\n\treturn 0;\n}\n\nstatic void st7586_fb_dirty(struct iosys_map *src, struct drm_framebuffer *fb,\n\t\t\t    struct drm_rect *rect)\n{\n\tstruct mipi_dbi_dev *dbidev = drm_to_mipi_dbi_dev(fb->dev);\n\tstruct mipi_dbi *dbi = &dbidev->dbi;\n\tint start, end, ret = 0;\n\n\t \n\trect->x1 = rounddown(rect->x1, 3);\n\trect->x2 = roundup(rect->x2, 3);\n\n\tDRM_DEBUG_KMS(\"Flushing [FB:%d] \" DRM_RECT_FMT \"\\n\", fb->base.id, DRM_RECT_ARG(rect));\n\n\tret = st7586_buf_copy(dbidev->tx_buf, src, fb, rect);\n\tif (ret)\n\t\tgoto err_msg;\n\n\t \n\tstart = rect->x1 / 3;\n\tend = rect->x2 / 3;\n\n\tmipi_dbi_command(dbi, MIPI_DCS_SET_COLUMN_ADDRESS,\n\t\t\t (start >> 8) & 0xFF, start & 0xFF,\n\t\t\t (end >> 8) & 0xFF, (end - 1) & 0xFF);\n\tmipi_dbi_command(dbi, MIPI_DCS_SET_PAGE_ADDRESS,\n\t\t\t (rect->y1 >> 8) & 0xFF, rect->y1 & 0xFF,\n\t\t\t (rect->y2 >> 8) & 0xFF, (rect->y2 - 1) & 0xFF);\n\n\tret = mipi_dbi_command_buf(dbi, MIPI_DCS_WRITE_MEMORY_START,\n\t\t\t\t   (u8 *)dbidev->tx_buf,\n\t\t\t\t   (end - start) * (rect->y2 - rect->y1));\nerr_msg:\n\tif (ret)\n\t\tdev_err_once(fb->dev->dev, \"Failed to update display %d\\n\", ret);\n}\n\nstatic void st7586_pipe_update(struct drm_simple_display_pipe *pipe,\n\t\t\t       struct drm_plane_state *old_state)\n{\n\tstruct drm_plane_state *state = pipe->plane.state;\n\tstruct drm_shadow_plane_state *shadow_plane_state = to_drm_shadow_plane_state(state);\n\tstruct drm_framebuffer *fb = state->fb;\n\tstruct drm_rect rect;\n\tint idx;\n\n\tif (!pipe->crtc.state->active)\n\t\treturn;\n\n\tif (!drm_dev_enter(fb->dev, &idx))\n\t\treturn;\n\n\tif (drm_atomic_helper_damage_merged(old_state, state, &rect))\n\t\tst7586_fb_dirty(&shadow_plane_state->data[0], fb, &rect);\n\n\tdrm_dev_exit(idx);\n}\n\nstatic void st7586_pipe_enable(struct drm_simple_display_pipe *pipe,\n\t\t\t       struct drm_crtc_state *crtc_state,\n\t\t\t       struct drm_plane_state *plane_state)\n{\n\tstruct mipi_dbi_dev *dbidev = drm_to_mipi_dbi_dev(pipe->crtc.dev);\n\tstruct drm_shadow_plane_state *shadow_plane_state = to_drm_shadow_plane_state(plane_state);\n\tstruct drm_framebuffer *fb = plane_state->fb;\n\tstruct mipi_dbi *dbi = &dbidev->dbi;\n\tstruct drm_rect rect = {\n\t\t.x1 = 0,\n\t\t.x2 = fb->width,\n\t\t.y1 = 0,\n\t\t.y2 = fb->height,\n\t};\n\tint idx, ret;\n\tu8 addr_mode;\n\n\tif (!drm_dev_enter(pipe->crtc.dev, &idx))\n\t\treturn;\n\n\tDRM_DEBUG_KMS(\"\\n\");\n\n\tret = mipi_dbi_poweron_reset(dbidev);\n\tif (ret)\n\t\tgoto out_exit;\n\n\tmipi_dbi_command(dbi, ST7586_AUTO_READ_CTRL, 0x9f);\n\tmipi_dbi_command(dbi, ST7586_OTP_RW_CTRL, 0x00);\n\n\tmsleep(10);\n\n\tmipi_dbi_command(dbi, ST7586_OTP_READ);\n\n\tmsleep(20);\n\n\tmipi_dbi_command(dbi, ST7586_OTP_CTRL_OUT);\n\tmipi_dbi_command(dbi, MIPI_DCS_EXIT_SLEEP_MODE);\n\tmipi_dbi_command(dbi, MIPI_DCS_SET_DISPLAY_OFF);\n\n\tmsleep(50);\n\n\tmipi_dbi_command(dbi, ST7586_SET_VOP_OFFSET, 0x00);\n\tmipi_dbi_command(dbi, ST7586_SET_VOP, 0xe3, 0x00);\n\tmipi_dbi_command(dbi, ST7586_SET_BIAS_SYSTEM, 0x02);\n\tmipi_dbi_command(dbi, ST7586_SET_BOOST_LEVEL, 0x04);\n\tmipi_dbi_command(dbi, ST7586_ENABLE_ANALOG, 0x1d);\n\tmipi_dbi_command(dbi, ST7586_SET_NLINE_INV, 0x00);\n\tmipi_dbi_command(dbi, ST7586_DISP_MODE_GRAY);\n\tmipi_dbi_command(dbi, ST7586_ENABLE_DDRAM, 0x02);\n\n\tswitch (dbidev->rotation) {\n\tdefault:\n\t\taddr_mode = 0x00;\n\t\tbreak;\n\tcase 90:\n\t\taddr_mode = ST7586_DISP_CTRL_MY;\n\t\tbreak;\n\tcase 180:\n\t\taddr_mode = ST7586_DISP_CTRL_MX | ST7586_DISP_CTRL_MY;\n\t\tbreak;\n\tcase 270:\n\t\taddr_mode = ST7586_DISP_CTRL_MX;\n\t\tbreak;\n\t}\n\tmipi_dbi_command(dbi, MIPI_DCS_SET_ADDRESS_MODE, addr_mode);\n\n\tmipi_dbi_command(dbi, ST7586_SET_DISP_DUTY, 0x7f);\n\tmipi_dbi_command(dbi, ST7586_SET_PART_DISP, 0xa0);\n\tmipi_dbi_command(dbi, MIPI_DCS_SET_PARTIAL_ROWS, 0x00, 0x00, 0x00, 0x77);\n\tmipi_dbi_command(dbi, MIPI_DCS_EXIT_INVERT_MODE);\n\n\tmsleep(100);\n\n\tst7586_fb_dirty(&shadow_plane_state->data[0], fb, &rect);\n\n\tmipi_dbi_command(dbi, MIPI_DCS_SET_DISPLAY_ON);\nout_exit:\n\tdrm_dev_exit(idx);\n}\n\nstatic void st7586_pipe_disable(struct drm_simple_display_pipe *pipe)\n{\n\tstruct mipi_dbi_dev *dbidev = drm_to_mipi_dbi_dev(pipe->crtc.dev);\n\n\t \n\n\tDRM_DEBUG_KMS(\"\\n\");\n\n\tmipi_dbi_command(&dbidev->dbi, MIPI_DCS_SET_DISPLAY_OFF);\n}\n\nstatic const u32 st7586_formats[] = {\n\tDRM_FORMAT_XRGB8888,\n};\n\nstatic const struct drm_simple_display_pipe_funcs st7586_pipe_funcs = {\n\t.mode_valid\t= mipi_dbi_pipe_mode_valid,\n\t.enable\t\t= st7586_pipe_enable,\n\t.disable\t= st7586_pipe_disable,\n\t.update\t\t= st7586_pipe_update,\n\t.begin_fb_access = mipi_dbi_pipe_begin_fb_access,\n\t.end_fb_access\t= mipi_dbi_pipe_end_fb_access,\n\t.reset_plane\t= mipi_dbi_pipe_reset_plane,\n\t.duplicate_plane_state = mipi_dbi_pipe_duplicate_plane_state,\n\t.destroy_plane_state = mipi_dbi_pipe_destroy_plane_state,\n};\n\nstatic const struct drm_display_mode st7586_mode = {\n\tDRM_SIMPLE_MODE(178, 128, 37, 27),\n};\n\nDEFINE_DRM_GEM_DMA_FOPS(st7586_fops);\n\nstatic const struct drm_driver st7586_driver = {\n\t.driver_features\t= DRIVER_GEM | DRIVER_MODESET | DRIVER_ATOMIC,\n\t.fops\t\t\t= &st7586_fops,\n\tDRM_GEM_DMA_DRIVER_OPS_VMAP,\n\t.debugfs_init\t\t= mipi_dbi_debugfs_init,\n\t.name\t\t\t= \"st7586\",\n\t.desc\t\t\t= \"Sitronix ST7586\",\n\t.date\t\t\t= \"20170801\",\n\t.major\t\t\t= 1,\n\t.minor\t\t\t= 0,\n};\n\nstatic const struct of_device_id st7586_of_match[] = {\n\t{ .compatible = \"lego,ev3-lcd\" },\n\t{},\n};\nMODULE_DEVICE_TABLE(of, st7586_of_match);\n\nstatic const struct spi_device_id st7586_id[] = {\n\t{ \"ev3-lcd\", 0 },\n\t{ },\n};\nMODULE_DEVICE_TABLE(spi, st7586_id);\n\nstatic int st7586_probe(struct spi_device *spi)\n{\n\tstruct device *dev = &spi->dev;\n\tstruct mipi_dbi_dev *dbidev;\n\tstruct drm_device *drm;\n\tstruct mipi_dbi *dbi;\n\tstruct gpio_desc *a0;\n\tu32 rotation = 0;\n\tsize_t bufsize;\n\tint ret;\n\n\tdbidev = devm_drm_dev_alloc(dev, &st7586_driver,\n\t\t\t\t    struct mipi_dbi_dev, drm);\n\tif (IS_ERR(dbidev))\n\t\treturn PTR_ERR(dbidev);\n\n\tdbi = &dbidev->dbi;\n\tdrm = &dbidev->drm;\n\n\tbufsize = (st7586_mode.vdisplay + 2) / 3 * st7586_mode.hdisplay;\n\n\tdbi->reset = devm_gpiod_get(dev, \"reset\", GPIOD_OUT_HIGH);\n\tif (IS_ERR(dbi->reset))\n\t\treturn dev_err_probe(dev, PTR_ERR(dbi->reset), \"Failed to get GPIO 'reset'\\n\");\n\n\ta0 = devm_gpiod_get(dev, \"a0\", GPIOD_OUT_LOW);\n\tif (IS_ERR(a0))\n\t\treturn dev_err_probe(dev, PTR_ERR(a0), \"Failed to get GPIO 'a0'\\n\");\n\n\tdevice_property_read_u32(dev, \"rotation\", &rotation);\n\n\tret = mipi_dbi_spi_init(spi, dbi, a0);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tdbi->read_commands = NULL;\n\n\tret = mipi_dbi_dev_init_with_formats(dbidev, &st7586_pipe_funcs,\n\t\t\t\t\t     st7586_formats, ARRAY_SIZE(st7586_formats),\n\t\t\t\t\t     &st7586_mode, rotation, bufsize);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tdbi->swap_bytes = true;\n\n\tdrm_mode_config_reset(drm);\n\n\tret = drm_dev_register(drm, 0);\n\tif (ret)\n\t\treturn ret;\n\n\tspi_set_drvdata(spi, drm);\n\n\tdrm_fbdev_generic_setup(drm, 0);\n\n\treturn 0;\n}\n\nstatic void st7586_remove(struct spi_device *spi)\n{\n\tstruct drm_device *drm = spi_get_drvdata(spi);\n\n\tdrm_dev_unplug(drm);\n\tdrm_atomic_helper_shutdown(drm);\n}\n\nstatic void st7586_shutdown(struct spi_device *spi)\n{\n\tdrm_atomic_helper_shutdown(spi_get_drvdata(spi));\n}\n\nstatic struct spi_driver st7586_spi_driver = {\n\t.driver = {\n\t\t.name = \"st7586\",\n\t\t.owner = THIS_MODULE,\n\t\t.of_match_table = st7586_of_match,\n\t},\n\t.id_table = st7586_id,\n\t.probe = st7586_probe,\n\t.remove = st7586_remove,\n\t.shutdown = st7586_shutdown,\n};\nmodule_spi_driver(st7586_spi_driver);\n\nMODULE_DESCRIPTION(\"Sitronix ST7586 DRM driver\");\nMODULE_AUTHOR(\"David Lechner <david@lechnology.com>\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}