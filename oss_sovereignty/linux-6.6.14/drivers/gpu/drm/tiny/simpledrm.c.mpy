{
  "module_name": "simpledrm.c",
  "hash_id": "b725e1cc940db103265d83f83642522af175c4529d87e62e0af14596982308e4",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/tiny/simpledrm.c",
  "human_readable_source": "\n\n#include <linux/clk.h>\n#include <linux/of_clk.h>\n#include <linux/minmax.h>\n#include <linux/of_address.h>\n#include <linux/platform_data/simplefb.h>\n#include <linux/platform_device.h>\n#include <linux/regulator/consumer.h>\n\n#include <drm/drm_aperture.h>\n#include <drm/drm_atomic.h>\n#include <drm/drm_atomic_state_helper.h>\n#include <drm/drm_connector.h>\n#include <drm/drm_crtc_helper.h>\n#include <drm/drm_damage_helper.h>\n#include <drm/drm_device.h>\n#include <drm/drm_drv.h>\n#include <drm/drm_fbdev_generic.h>\n#include <drm/drm_format_helper.h>\n#include <drm/drm_gem_atomic_helper.h>\n#include <drm/drm_gem_framebuffer_helper.h>\n#include <drm/drm_gem_shmem_helper.h>\n#include <drm/drm_managed.h>\n#include <drm/drm_modeset_helper_vtables.h>\n#include <drm/drm_plane_helper.h>\n#include <drm/drm_probe_helper.h>\n\n#define DRIVER_NAME\t\"simpledrm\"\n#define DRIVER_DESC\t\"DRM driver for simple-framebuffer platform devices\"\n#define DRIVER_DATE\t\"20200625\"\n#define DRIVER_MAJOR\t1\n#define DRIVER_MINOR\t0\n\n \n\nstatic int\nsimplefb_get_validated_int(struct drm_device *dev, const char *name,\n\t\t\t   uint32_t value)\n{\n\tif (value > INT_MAX) {\n\t\tdrm_err(dev, \"simplefb: invalid framebuffer %s of %u\\n\",\n\t\t\tname, value);\n\t\treturn -EINVAL;\n\t}\n\treturn (int)value;\n}\n\nstatic int\nsimplefb_get_validated_int0(struct drm_device *dev, const char *name,\n\t\t\t    uint32_t value)\n{\n\tif (!value) {\n\t\tdrm_err(dev, \"simplefb: invalid framebuffer %s of %u\\n\",\n\t\t\tname, value);\n\t\treturn -EINVAL;\n\t}\n\treturn simplefb_get_validated_int(dev, name, value);\n}\n\nstatic const struct drm_format_info *\nsimplefb_get_validated_format(struct drm_device *dev, const char *format_name)\n{\n\tstatic const struct simplefb_format formats[] = SIMPLEFB_FORMATS;\n\tconst struct simplefb_format *fmt = formats;\n\tconst struct simplefb_format *end = fmt + ARRAY_SIZE(formats);\n\tconst struct drm_format_info *info;\n\n\tif (!format_name) {\n\t\tdrm_err(dev, \"simplefb: missing framebuffer format\\n\");\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\twhile (fmt < end) {\n\t\tif (!strcmp(format_name, fmt->name)) {\n\t\t\tinfo = drm_format_info(fmt->fourcc);\n\t\t\tif (!info)\n\t\t\t\treturn ERR_PTR(-EINVAL);\n\t\t\treturn info;\n\t\t}\n\t\t++fmt;\n\t}\n\n\tdrm_err(dev, \"simplefb: unknown framebuffer format %s\\n\",\n\t\tformat_name);\n\n\treturn ERR_PTR(-EINVAL);\n}\n\nstatic int\nsimplefb_get_width_pd(struct drm_device *dev,\n\t\t      const struct simplefb_platform_data *pd)\n{\n\treturn simplefb_get_validated_int0(dev, \"width\", pd->width);\n}\n\nstatic int\nsimplefb_get_height_pd(struct drm_device *dev,\n\t\t       const struct simplefb_platform_data *pd)\n{\n\treturn simplefb_get_validated_int0(dev, \"height\", pd->height);\n}\n\nstatic int\nsimplefb_get_stride_pd(struct drm_device *dev,\n\t\t       const struct simplefb_platform_data *pd)\n{\n\treturn simplefb_get_validated_int(dev, \"stride\", pd->stride);\n}\n\nstatic const struct drm_format_info *\nsimplefb_get_format_pd(struct drm_device *dev,\n\t\t       const struct simplefb_platform_data *pd)\n{\n\treturn simplefb_get_validated_format(dev, pd->format);\n}\n\nstatic int\nsimplefb_read_u32_of(struct drm_device *dev, struct device_node *of_node,\n\t\t     const char *name, u32 *value)\n{\n\tint ret = of_property_read_u32(of_node, name, value);\n\n\tif (ret)\n\t\tdrm_err(dev, \"simplefb: cannot parse framebuffer %s: error %d\\n\",\n\t\t\tname, ret);\n\treturn ret;\n}\n\nstatic int\nsimplefb_read_string_of(struct drm_device *dev, struct device_node *of_node,\n\t\t\tconst char *name, const char **value)\n{\n\tint ret = of_property_read_string(of_node, name, value);\n\n\tif (ret)\n\t\tdrm_err(dev, \"simplefb: cannot parse framebuffer %s: error %d\\n\",\n\t\t\tname, ret);\n\treturn ret;\n}\n\nstatic int\nsimplefb_get_width_of(struct drm_device *dev, struct device_node *of_node)\n{\n\tu32 width;\n\tint ret = simplefb_read_u32_of(dev, of_node, \"width\", &width);\n\n\tif (ret)\n\t\treturn ret;\n\treturn simplefb_get_validated_int0(dev, \"width\", width);\n}\n\nstatic int\nsimplefb_get_height_of(struct drm_device *dev, struct device_node *of_node)\n{\n\tu32 height;\n\tint ret = simplefb_read_u32_of(dev, of_node, \"height\", &height);\n\n\tif (ret)\n\t\treturn ret;\n\treturn simplefb_get_validated_int0(dev, \"height\", height);\n}\n\nstatic int\nsimplefb_get_stride_of(struct drm_device *dev, struct device_node *of_node)\n{\n\tu32 stride;\n\tint ret = simplefb_read_u32_of(dev, of_node, \"stride\", &stride);\n\n\tif (ret)\n\t\treturn ret;\n\treturn simplefb_get_validated_int(dev, \"stride\", stride);\n}\n\nstatic const struct drm_format_info *\nsimplefb_get_format_of(struct drm_device *dev, struct device_node *of_node)\n{\n\tconst char *format;\n\tint ret = simplefb_read_string_of(dev, of_node, \"format\", &format);\n\n\tif (ret)\n\t\treturn ERR_PTR(ret);\n\treturn simplefb_get_validated_format(dev, format);\n}\n\nstatic struct resource *\nsimplefb_get_memory_of(struct drm_device *dev, struct device_node *of_node)\n{\n\tstruct device_node *np;\n\tstruct resource *res;\n\tint err;\n\n\tnp = of_parse_phandle(of_node, \"memory-region\", 0);\n\tif (!np)\n\t\treturn NULL;\n\n\tres = devm_kzalloc(dev->dev, sizeof(*res), GFP_KERNEL);\n\tif (!res)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\terr = of_address_to_resource(np, 0, res);\n\tif (err)\n\t\treturn ERR_PTR(err);\n\n\tif (of_property_present(of_node, \"reg\"))\n\t\tdrm_warn(dev, \"preferring \\\"memory-region\\\" over \\\"reg\\\" property\\n\");\n\n\treturn res;\n}\n\n \n\nstruct simpledrm_device {\n\tstruct drm_device dev;\n\n\t \n#if defined CONFIG_OF && defined CONFIG_COMMON_CLK\n\tunsigned int clk_count;\n\tstruct clk **clks;\n#endif\n\t \n#if defined CONFIG_OF && defined CONFIG_REGULATOR\n\tunsigned int regulator_count;\n\tstruct regulator **regulators;\n#endif\n\n\t \n\tstruct drm_display_mode mode;\n\tconst struct drm_format_info *format;\n\tunsigned int pitch;\n\n\t \n\tstruct iosys_map screen_base;\n\n\t \n\tuint32_t formats[8];\n\tsize_t nformats;\n\tstruct drm_plane primary_plane;\n\tstruct drm_crtc crtc;\n\tstruct drm_encoder encoder;\n\tstruct drm_connector connector;\n};\n\nstatic struct simpledrm_device *simpledrm_device_of_dev(struct drm_device *dev)\n{\n\treturn container_of(dev, struct simpledrm_device, dev);\n}\n\n \n\n#if defined CONFIG_OF && defined CONFIG_COMMON_CLK\n \n\nstatic void simpledrm_device_release_clocks(void *res)\n{\n\tstruct simpledrm_device *sdev = simpledrm_device_of_dev(res);\n\tunsigned int i;\n\n\tfor (i = 0; i < sdev->clk_count; ++i) {\n\t\tif (sdev->clks[i]) {\n\t\t\tclk_disable_unprepare(sdev->clks[i]);\n\t\t\tclk_put(sdev->clks[i]);\n\t\t}\n\t}\n}\n\nstatic int simpledrm_device_init_clocks(struct simpledrm_device *sdev)\n{\n\tstruct drm_device *dev = &sdev->dev;\n\tstruct platform_device *pdev = to_platform_device(dev->dev);\n\tstruct device_node *of_node = pdev->dev.of_node;\n\tstruct clk *clock;\n\tunsigned int i;\n\tint ret;\n\n\tif (dev_get_platdata(&pdev->dev) || !of_node)\n\t\treturn 0;\n\n\tsdev->clk_count = of_clk_get_parent_count(of_node);\n\tif (!sdev->clk_count)\n\t\treturn 0;\n\n\tsdev->clks = drmm_kzalloc(dev, sdev->clk_count * sizeof(sdev->clks[0]),\n\t\t\t\t  GFP_KERNEL);\n\tif (!sdev->clks)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < sdev->clk_count; ++i) {\n\t\tclock = of_clk_get(of_node, i);\n\t\tif (IS_ERR(clock)) {\n\t\t\tret = PTR_ERR(clock);\n\t\t\tif (ret == -EPROBE_DEFER)\n\t\t\t\tgoto err;\n\t\t\tdrm_err(dev, \"clock %u not found: %d\\n\", i, ret);\n\t\t\tcontinue;\n\t\t}\n\t\tret = clk_prepare_enable(clock);\n\t\tif (ret) {\n\t\t\tdrm_err(dev, \"failed to enable clock %u: %d\\n\",\n\t\t\t\ti, ret);\n\t\t\tclk_put(clock);\n\t\t\tcontinue;\n\t\t}\n\t\tsdev->clks[i] = clock;\n\t}\n\n\treturn devm_add_action_or_reset(&pdev->dev,\n\t\t\t\t\tsimpledrm_device_release_clocks,\n\t\t\t\t\tsdev);\n\nerr:\n\twhile (i) {\n\t\t--i;\n\t\tif (sdev->clks[i]) {\n\t\t\tclk_disable_unprepare(sdev->clks[i]);\n\t\t\tclk_put(sdev->clks[i]);\n\t\t}\n\t}\n\treturn ret;\n}\n#else\nstatic int simpledrm_device_init_clocks(struct simpledrm_device *sdev)\n{\n\treturn 0;\n}\n#endif\n\n#if defined CONFIG_OF && defined CONFIG_REGULATOR\n\n#define SUPPLY_SUFFIX \"-supply\"\n\n \n\nstatic void simpledrm_device_release_regulators(void *res)\n{\n\tstruct simpledrm_device *sdev = simpledrm_device_of_dev(res);\n\tunsigned int i;\n\n\tfor (i = 0; i < sdev->regulator_count; ++i) {\n\t\tif (sdev->regulators[i]) {\n\t\t\tregulator_disable(sdev->regulators[i]);\n\t\t\tregulator_put(sdev->regulators[i]);\n\t\t}\n\t}\n}\n\nstatic int simpledrm_device_init_regulators(struct simpledrm_device *sdev)\n{\n\tstruct drm_device *dev = &sdev->dev;\n\tstruct platform_device *pdev = to_platform_device(dev->dev);\n\tstruct device_node *of_node = pdev->dev.of_node;\n\tstruct property *prop;\n\tstruct regulator *regulator;\n\tconst char *p;\n\tunsigned int count = 0, i = 0;\n\tint ret;\n\n\tif (dev_get_platdata(&pdev->dev) || !of_node)\n\t\treturn 0;\n\n\t \n\tfor_each_property_of_node(of_node, prop) {\n\t\tp = strstr(prop->name, SUPPLY_SUFFIX);\n\t\tif (p && p != prop->name)\n\t\t\t++count;\n\t}\n\n\tif (!count)\n\t\treturn 0;\n\n\tsdev->regulators = drmm_kzalloc(dev,\n\t\t\t\t\tcount * sizeof(sdev->regulators[0]),\n\t\t\t\t\tGFP_KERNEL);\n\tif (!sdev->regulators)\n\t\treturn -ENOMEM;\n\n\tfor_each_property_of_node(of_node, prop) {\n\t\tchar name[32];  \n\t\tsize_t len;\n\n\t\tp = strstr(prop->name, SUPPLY_SUFFIX);\n\t\tif (!p || p == prop->name)\n\t\t\tcontinue;\n\t\tlen = strlen(prop->name) - strlen(SUPPLY_SUFFIX) + 1;\n\t\tstrscpy(name, prop->name, min(sizeof(name), len));\n\n\t\tregulator = regulator_get_optional(&pdev->dev, name);\n\t\tif (IS_ERR(regulator)) {\n\t\t\tret = PTR_ERR(regulator);\n\t\t\tif (ret == -EPROBE_DEFER)\n\t\t\t\tgoto err;\n\t\t\tdrm_err(dev, \"regulator %s not found: %d\\n\",\n\t\t\t\tname, ret);\n\t\t\tcontinue;\n\t\t}\n\n\t\tret = regulator_enable(regulator);\n\t\tif (ret) {\n\t\t\tdrm_err(dev, \"failed to enable regulator %u: %d\\n\",\n\t\t\t\ti, ret);\n\t\t\tregulator_put(regulator);\n\t\t\tcontinue;\n\t\t}\n\n\t\tsdev->regulators[i++] = regulator;\n\t}\n\tsdev->regulator_count = i;\n\n\treturn devm_add_action_or_reset(&pdev->dev,\n\t\t\t\t\tsimpledrm_device_release_regulators,\n\t\t\t\t\tsdev);\n\nerr:\n\twhile (i) {\n\t\t--i;\n\t\tif (sdev->regulators[i]) {\n\t\t\tregulator_disable(sdev->regulators[i]);\n\t\t\tregulator_put(sdev->regulators[i]);\n\t\t}\n\t}\n\treturn ret;\n}\n#else\nstatic int simpledrm_device_init_regulators(struct simpledrm_device *sdev)\n{\n\treturn 0;\n}\n#endif\n\n \n\nstatic const uint64_t simpledrm_primary_plane_format_modifiers[] = {\n\tDRM_FORMAT_MOD_LINEAR,\n\tDRM_FORMAT_MOD_INVALID\n};\n\nstatic void simpledrm_primary_plane_helper_atomic_update(struct drm_plane *plane,\n\t\t\t\t\t\t\t struct drm_atomic_state *state)\n{\n\tstruct drm_plane_state *plane_state = drm_atomic_get_new_plane_state(state, plane);\n\tstruct drm_plane_state *old_plane_state = drm_atomic_get_old_plane_state(state, plane);\n\tstruct drm_shadow_plane_state *shadow_plane_state = to_drm_shadow_plane_state(plane_state);\n\tstruct drm_framebuffer *fb = plane_state->fb;\n\tstruct drm_device *dev = plane->dev;\n\tstruct simpledrm_device *sdev = simpledrm_device_of_dev(dev);\n\tstruct drm_atomic_helper_damage_iter iter;\n\tstruct drm_rect damage;\n\tint ret, idx;\n\n\tret = drm_gem_fb_begin_cpu_access(fb, DMA_FROM_DEVICE);\n\tif (ret)\n\t\treturn;\n\n\tif (!drm_dev_enter(dev, &idx))\n\t\tgoto out_drm_gem_fb_end_cpu_access;\n\n\tdrm_atomic_helper_damage_iter_init(&iter, old_plane_state, plane_state);\n\tdrm_atomic_for_each_plane_damage(&iter, &damage) {\n\t\tstruct drm_rect dst_clip = plane_state->dst;\n\t\tstruct iosys_map dst = sdev->screen_base;\n\n\t\tif (!drm_rect_intersect(&dst_clip, &damage))\n\t\t\tcontinue;\n\n\t\tiosys_map_incr(&dst, drm_fb_clip_offset(sdev->pitch, sdev->format, &dst_clip));\n\t\tdrm_fb_blit(&dst, &sdev->pitch, sdev->format->format, shadow_plane_state->data,\n\t\t\t    fb, &damage);\n\t}\n\n\tdrm_dev_exit(idx);\nout_drm_gem_fb_end_cpu_access:\n\tdrm_gem_fb_end_cpu_access(fb, DMA_FROM_DEVICE);\n}\n\nstatic void simpledrm_primary_plane_helper_atomic_disable(struct drm_plane *plane,\n\t\t\t\t\t\t\t  struct drm_atomic_state *state)\n{\n\tstruct drm_device *dev = plane->dev;\n\tstruct simpledrm_device *sdev = simpledrm_device_of_dev(dev);\n\tint idx;\n\n\tif (!drm_dev_enter(dev, &idx))\n\t\treturn;\n\n\t \n\tiosys_map_memset(&sdev->screen_base, 0, 0, sdev->pitch * sdev->mode.vdisplay);\n\n\tdrm_dev_exit(idx);\n}\n\nstatic const struct drm_plane_helper_funcs simpledrm_primary_plane_helper_funcs = {\n\tDRM_GEM_SHADOW_PLANE_HELPER_FUNCS,\n\t.atomic_check = drm_plane_helper_atomic_check,\n\t.atomic_update = simpledrm_primary_plane_helper_atomic_update,\n\t.atomic_disable = simpledrm_primary_plane_helper_atomic_disable,\n};\n\nstatic const struct drm_plane_funcs simpledrm_primary_plane_funcs = {\n\t.update_plane = drm_atomic_helper_update_plane,\n\t.disable_plane = drm_atomic_helper_disable_plane,\n\t.destroy = drm_plane_cleanup,\n\tDRM_GEM_SHADOW_PLANE_FUNCS,\n};\n\nstatic enum drm_mode_status simpledrm_crtc_helper_mode_valid(struct drm_crtc *crtc,\n\t\t\t\t\t\t\t     const struct drm_display_mode *mode)\n{\n\tstruct simpledrm_device *sdev = simpledrm_device_of_dev(crtc->dev);\n\n\treturn drm_crtc_helper_mode_valid_fixed(crtc, mode, &sdev->mode);\n}\n\n \nstatic const struct drm_crtc_helper_funcs simpledrm_crtc_helper_funcs = {\n\t.mode_valid = simpledrm_crtc_helper_mode_valid,\n\t.atomic_check = drm_crtc_helper_atomic_check,\n};\n\nstatic const struct drm_crtc_funcs simpledrm_crtc_funcs = {\n\t.reset = drm_atomic_helper_crtc_reset,\n\t.destroy = drm_crtc_cleanup,\n\t.set_config = drm_atomic_helper_set_config,\n\t.page_flip = drm_atomic_helper_page_flip,\n\t.atomic_duplicate_state = drm_atomic_helper_crtc_duplicate_state,\n\t.atomic_destroy_state = drm_atomic_helper_crtc_destroy_state,\n};\n\nstatic const struct drm_encoder_funcs simpledrm_encoder_funcs = {\n\t.destroy = drm_encoder_cleanup,\n};\n\nstatic int simpledrm_connector_helper_get_modes(struct drm_connector *connector)\n{\n\tstruct simpledrm_device *sdev = simpledrm_device_of_dev(connector->dev);\n\n\treturn drm_connector_helper_get_modes_fixed(connector, &sdev->mode);\n}\n\nstatic const struct drm_connector_helper_funcs simpledrm_connector_helper_funcs = {\n\t.get_modes = simpledrm_connector_helper_get_modes,\n};\n\nstatic const struct drm_connector_funcs simpledrm_connector_funcs = {\n\t.reset = drm_atomic_helper_connector_reset,\n\t.fill_modes = drm_helper_probe_single_connector_modes,\n\t.destroy = drm_connector_cleanup,\n\t.atomic_duplicate_state = drm_atomic_helper_connector_duplicate_state,\n\t.atomic_destroy_state = drm_atomic_helper_connector_destroy_state,\n};\n\nstatic const struct drm_mode_config_funcs simpledrm_mode_config_funcs = {\n\t.fb_create = drm_gem_fb_create_with_dirty,\n\t.atomic_check = drm_atomic_helper_check,\n\t.atomic_commit = drm_atomic_helper_commit,\n};\n\n \n\nstatic struct drm_display_mode simpledrm_mode(unsigned int width,\n\t\t\t\t\t      unsigned int height,\n\t\t\t\t\t      unsigned int width_mm,\n\t\t\t\t\t      unsigned int height_mm)\n{\n\tconst struct drm_display_mode mode = {\n\t\tDRM_MODE_INIT(60, width, height, width_mm, height_mm)\n\t};\n\n\treturn mode;\n}\n\nstatic struct simpledrm_device *simpledrm_device_create(struct drm_driver *drv,\n\t\t\t\t\t\t\tstruct platform_device *pdev)\n{\n\tconst struct simplefb_platform_data *pd = dev_get_platdata(&pdev->dev);\n\tstruct device_node *of_node = pdev->dev.of_node;\n\tstruct simpledrm_device *sdev;\n\tstruct drm_device *dev;\n\tint width, height, stride;\n\tint width_mm = 0, height_mm = 0;\n\tstruct device_node *panel_node;\n\tconst struct drm_format_info *format;\n\tstruct resource *res, *mem = NULL;\n\tstruct drm_plane *primary_plane;\n\tstruct drm_crtc *crtc;\n\tstruct drm_encoder *encoder;\n\tstruct drm_connector *connector;\n\tunsigned long max_width, max_height;\n\tsize_t nformats;\n\tint ret;\n\n\tsdev = devm_drm_dev_alloc(&pdev->dev, drv, struct simpledrm_device, dev);\n\tif (IS_ERR(sdev))\n\t\treturn ERR_CAST(sdev);\n\tdev = &sdev->dev;\n\tplatform_set_drvdata(pdev, sdev);\n\n\t \n\n\tret = simpledrm_device_init_clocks(sdev);\n\tif (ret)\n\t\treturn ERR_PTR(ret);\n\tret = simpledrm_device_init_regulators(sdev);\n\tif (ret)\n\t\treturn ERR_PTR(ret);\n\n\tif (pd) {\n\t\twidth = simplefb_get_width_pd(dev, pd);\n\t\tif (width < 0)\n\t\t\treturn ERR_PTR(width);\n\t\theight = simplefb_get_height_pd(dev, pd);\n\t\tif (height < 0)\n\t\t\treturn ERR_PTR(height);\n\t\tstride = simplefb_get_stride_pd(dev, pd);\n\t\tif (stride < 0)\n\t\t\treturn ERR_PTR(stride);\n\t\tformat = simplefb_get_format_pd(dev, pd);\n\t\tif (IS_ERR(format))\n\t\t\treturn ERR_CAST(format);\n\t} else if (of_node) {\n\t\twidth = simplefb_get_width_of(dev, of_node);\n\t\tif (width < 0)\n\t\t\treturn ERR_PTR(width);\n\t\theight = simplefb_get_height_of(dev, of_node);\n\t\tif (height < 0)\n\t\t\treturn ERR_PTR(height);\n\t\tstride = simplefb_get_stride_of(dev, of_node);\n\t\tif (stride < 0)\n\t\t\treturn ERR_PTR(stride);\n\t\tformat = simplefb_get_format_of(dev, of_node);\n\t\tif (IS_ERR(format))\n\t\t\treturn ERR_CAST(format);\n\t\tmem = simplefb_get_memory_of(dev, of_node);\n\t\tif (IS_ERR(mem))\n\t\t\treturn ERR_CAST(mem);\n\t\tpanel_node = of_parse_phandle(of_node, \"panel\", 0);\n\t\tif (panel_node) {\n\t\t\tsimplefb_read_u32_of(dev, panel_node, \"width-mm\", &width_mm);\n\t\t\tsimplefb_read_u32_of(dev, panel_node, \"height-mm\", &height_mm);\n\t\t\tof_node_put(panel_node);\n\t\t}\n\t} else {\n\t\tdrm_err(dev, \"no simplefb configuration found\\n\");\n\t\treturn ERR_PTR(-ENODEV);\n\t}\n\tif (!stride) {\n\t\tstride = drm_format_info_min_pitch(format, 0, width);\n\t\tif (drm_WARN_ON(dev, !stride))\n\t\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\t \n\tif (!width_mm)\n\t\twidth_mm = DRM_MODE_RES_MM(width, 96ul);\n\tif (!height_mm)\n\t\theight_mm = DRM_MODE_RES_MM(height, 96ul);\n\n\tsdev->mode = simpledrm_mode(width, height, width_mm, height_mm);\n\tsdev->format = format;\n\tsdev->pitch = stride;\n\n\tdrm_dbg(dev, \"display mode={\" DRM_MODE_FMT \"}\\n\", DRM_MODE_ARG(&sdev->mode));\n\tdrm_dbg(dev, \"framebuffer format=%p4cc, size=%dx%d, stride=%d byte\\n\",\n\t\t&format->format, width, height, stride);\n\n\t \n\n\tif (mem) {\n\t\tvoid *screen_base;\n\n\t\tret = devm_aperture_acquire_from_firmware(dev, mem->start, resource_size(mem));\n\t\tif (ret) {\n\t\t\tdrm_err(dev, \"could not acquire memory range %pr: %d\\n\", mem, ret);\n\t\t\treturn ERR_PTR(ret);\n\t\t}\n\n\t\tdrm_dbg(dev, \"using system memory framebuffer at %pr\\n\", mem);\n\n\t\tscreen_base = devm_memremap(dev->dev, mem->start, resource_size(mem), MEMREMAP_WC);\n\t\tif (IS_ERR(screen_base))\n\t\t\treturn screen_base;\n\n\t\tiosys_map_set_vaddr(&sdev->screen_base, screen_base);\n\t} else {\n\t\tvoid __iomem *screen_base;\n\n\t\tres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\n\t\tif (!res)\n\t\t\treturn ERR_PTR(-EINVAL);\n\n\t\tret = devm_aperture_acquire_from_firmware(dev, res->start, resource_size(res));\n\t\tif (ret) {\n\t\t\tdrm_err(dev, \"could not acquire memory range %pr: %d\\n\", res, ret);\n\t\t\treturn ERR_PTR(ret);\n\t\t}\n\n\t\tdrm_dbg(dev, \"using I/O memory framebuffer at %pr\\n\", res);\n\n\t\tmem = devm_request_mem_region(&pdev->dev, res->start, resource_size(res),\n\t\t\t\t\t      drv->name);\n\t\tif (!mem) {\n\t\t\t \n\t\t\tdrm_warn(dev, \"could not acquire memory region %pr\\n\", res);\n\t\t\tmem = res;\n\t\t}\n\n\t\tscreen_base = devm_ioremap_wc(&pdev->dev, mem->start, resource_size(mem));\n\t\tif (!screen_base)\n\t\t\treturn ERR_PTR(-ENOMEM);\n\n\t\tiosys_map_set_vaddr_iomem(&sdev->screen_base, screen_base);\n\t}\n\n\t \n\n\tret = drmm_mode_config_init(dev);\n\tif (ret)\n\t\treturn ERR_PTR(ret);\n\n\tmax_width = max_t(unsigned long, width, DRM_SHADOW_PLANE_MAX_WIDTH);\n\tmax_height = max_t(unsigned long, height, DRM_SHADOW_PLANE_MAX_HEIGHT);\n\n\tdev->mode_config.min_width = width;\n\tdev->mode_config.max_width = max_width;\n\tdev->mode_config.min_height = height;\n\tdev->mode_config.max_height = max_height;\n\tdev->mode_config.preferred_depth = format->depth;\n\tdev->mode_config.funcs = &simpledrm_mode_config_funcs;\n\n\t \n\n\tnformats = drm_fb_build_fourcc_list(dev, &format->format, 1,\n\t\t\t\t\t    sdev->formats, ARRAY_SIZE(sdev->formats));\n\n\tprimary_plane = &sdev->primary_plane;\n\tret = drm_universal_plane_init(dev, primary_plane, 0, &simpledrm_primary_plane_funcs,\n\t\t\t\t       sdev->formats, nformats,\n\t\t\t\t       simpledrm_primary_plane_format_modifiers,\n\t\t\t\t       DRM_PLANE_TYPE_PRIMARY, NULL);\n\tif (ret)\n\t\treturn ERR_PTR(ret);\n\tdrm_plane_helper_add(primary_plane, &simpledrm_primary_plane_helper_funcs);\n\tdrm_plane_enable_fb_damage_clips(primary_plane);\n\n\t \n\n\tcrtc = &sdev->crtc;\n\tret = drm_crtc_init_with_planes(dev, crtc, primary_plane, NULL,\n\t\t\t\t\t&simpledrm_crtc_funcs, NULL);\n\tif (ret)\n\t\treturn ERR_PTR(ret);\n\tdrm_crtc_helper_add(crtc, &simpledrm_crtc_helper_funcs);\n\n\t \n\n\tencoder = &sdev->encoder;\n\tret = drm_encoder_init(dev, encoder, &simpledrm_encoder_funcs,\n\t\t\t       DRM_MODE_ENCODER_NONE, NULL);\n\tif (ret)\n\t\treturn ERR_PTR(ret);\n\tencoder->possible_crtcs = drm_crtc_mask(crtc);\n\n\t \n\n\tconnector = &sdev->connector;\n\tret = drm_connector_init(dev, connector, &simpledrm_connector_funcs,\n\t\t\t\t DRM_MODE_CONNECTOR_Unknown);\n\tif (ret)\n\t\treturn ERR_PTR(ret);\n\tdrm_connector_helper_add(connector, &simpledrm_connector_helper_funcs);\n\tdrm_connector_set_panel_orientation_with_quirk(connector,\n\t\t\t\t\t\t       DRM_MODE_PANEL_ORIENTATION_UNKNOWN,\n\t\t\t\t\t\t       width, height);\n\n\tret = drm_connector_attach_encoder(connector, encoder);\n\tif (ret)\n\t\treturn ERR_PTR(ret);\n\n\tdrm_mode_config_reset(dev);\n\n\treturn sdev;\n}\n\n \n\nDEFINE_DRM_GEM_FOPS(simpledrm_fops);\n\nstatic struct drm_driver simpledrm_driver = {\n\tDRM_GEM_SHMEM_DRIVER_OPS,\n\t.name\t\t\t= DRIVER_NAME,\n\t.desc\t\t\t= DRIVER_DESC,\n\t.date\t\t\t= DRIVER_DATE,\n\t.major\t\t\t= DRIVER_MAJOR,\n\t.minor\t\t\t= DRIVER_MINOR,\n\t.driver_features\t= DRIVER_ATOMIC | DRIVER_GEM | DRIVER_MODESET,\n\t.fops\t\t\t= &simpledrm_fops,\n};\n\n \n\nstatic int simpledrm_probe(struct platform_device *pdev)\n{\n\tstruct simpledrm_device *sdev;\n\tstruct drm_device *dev;\n\tunsigned int color_mode;\n\tint ret;\n\n\tsdev = simpledrm_device_create(&simpledrm_driver, pdev);\n\tif (IS_ERR(sdev))\n\t\treturn PTR_ERR(sdev);\n\tdev = &sdev->dev;\n\n\tret = drm_dev_register(dev, 0);\n\tif (ret)\n\t\treturn ret;\n\n\tcolor_mode = drm_format_info_bpp(sdev->format, 0);\n\tif (color_mode == 16)\n\t\tcolor_mode = sdev->format->depth; \n\n\tdrm_fbdev_generic_setup(dev, color_mode);\n\n\treturn 0;\n}\n\nstatic void simpledrm_remove(struct platform_device *pdev)\n{\n\tstruct simpledrm_device *sdev = platform_get_drvdata(pdev);\n\tstruct drm_device *dev = &sdev->dev;\n\n\tdrm_dev_unplug(dev);\n}\n\nstatic const struct of_device_id simpledrm_of_match_table[] = {\n\t{ .compatible = \"simple-framebuffer\", },\n\t{ },\n};\nMODULE_DEVICE_TABLE(of, simpledrm_of_match_table);\n\nstatic struct platform_driver simpledrm_platform_driver = {\n\t.driver = {\n\t\t.name = \"simple-framebuffer\",  \n\t\t.of_match_table = simpledrm_of_match_table,\n\t},\n\t.probe = simpledrm_probe,\n\t.remove_new = simpledrm_remove,\n};\n\nmodule_platform_driver(simpledrm_platform_driver);\n\nMODULE_DESCRIPTION(DRIVER_DESC);\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}