{
  "module_name": "bochs.c",
  "hash_id": "57b3fbc6c48d36a3250e5877e9dcfe2bad0283b416c9f4147cf33cb2f06f5474",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/tiny/bochs.c",
  "human_readable_source": "\n\n#include <linux/module.h>\n#include <linux/pci.h>\n\n#include <drm/drm_aperture.h>\n#include <drm/drm_atomic_helper.h>\n#include <drm/drm_drv.h>\n#include <drm/drm_edid.h>\n#include <drm/drm_fbdev_generic.h>\n#include <drm/drm_fourcc.h>\n#include <drm/drm_framebuffer.h>\n#include <drm/drm_gem_framebuffer_helper.h>\n#include <drm/drm_gem_vram_helper.h>\n#include <drm/drm_managed.h>\n#include <drm/drm_module.h>\n#include <drm/drm_probe_helper.h>\n#include <drm/drm_simple_kms_helper.h>\n\n#include <video/vga.h>\n\n \n\n#define VBE_DISPI_IOPORT_INDEX           0x01CE\n#define VBE_DISPI_IOPORT_DATA            0x01CF\n\n#define VBE_DISPI_INDEX_ID               0x0\n#define VBE_DISPI_INDEX_XRES             0x1\n#define VBE_DISPI_INDEX_YRES             0x2\n#define VBE_DISPI_INDEX_BPP              0x3\n#define VBE_DISPI_INDEX_ENABLE           0x4\n#define VBE_DISPI_INDEX_BANK             0x5\n#define VBE_DISPI_INDEX_VIRT_WIDTH       0x6\n#define VBE_DISPI_INDEX_VIRT_HEIGHT      0x7\n#define VBE_DISPI_INDEX_X_OFFSET         0x8\n#define VBE_DISPI_INDEX_Y_OFFSET         0x9\n#define VBE_DISPI_INDEX_VIDEO_MEMORY_64K 0xa\n\n#define VBE_DISPI_ID0                    0xB0C0\n#define VBE_DISPI_ID1                    0xB0C1\n#define VBE_DISPI_ID2                    0xB0C2\n#define VBE_DISPI_ID3                    0xB0C3\n#define VBE_DISPI_ID4                    0xB0C4\n#define VBE_DISPI_ID5                    0xB0C5\n\n#define VBE_DISPI_DISABLED               0x00\n#define VBE_DISPI_ENABLED                0x01\n#define VBE_DISPI_GETCAPS                0x02\n#define VBE_DISPI_8BIT_DAC               0x20\n#define VBE_DISPI_LFB_ENABLED            0x40\n#define VBE_DISPI_NOCLEARMEM             0x80\n\nstatic int bochs_modeset = -1;\nstatic int defx = 1024;\nstatic int defy = 768;\n\nmodule_param_named(modeset, bochs_modeset, int, 0444);\nMODULE_PARM_DESC(modeset, \"enable/disable kernel modesetting\");\n\nmodule_param(defx, int, 0444);\nmodule_param(defy, int, 0444);\nMODULE_PARM_DESC(defx, \"default x resolution\");\nMODULE_PARM_DESC(defy, \"default y resolution\");\n\n \n\nenum bochs_types {\n\tBOCHS_QEMU_STDVGA,\n\tBOCHS_SIMICS,\n\tBOCHS_UNKNOWN,\n};\n\nstruct bochs_device {\n\t \n\tvoid __iomem   *mmio;\n\tint            ioports;\n\tvoid __iomem   *fb_map;\n\tunsigned long  fb_base;\n\tunsigned long  fb_size;\n\tunsigned long  qext_size;\n\n\t \n\tu16 xres;\n\tu16 yres;\n\tu16 yres_virtual;\n\tu32 stride;\n\tu32 bpp;\n\tstruct edid *edid;\n\n\t \n\tstruct drm_device *dev;\n\tstruct drm_simple_display_pipe pipe;\n\tstruct drm_connector connector;\n};\n\n \n\nstatic void bochs_vga_writeb(struct bochs_device *bochs, u16 ioport, u8 val)\n{\n\tif (WARN_ON(ioport < 0x3c0 || ioport > 0x3df))\n\t\treturn;\n\n\tif (bochs->mmio) {\n\t\tint offset = ioport - 0x3c0 + 0x400;\n\n\t\twriteb(val, bochs->mmio + offset);\n\t} else {\n\t\toutb(val, ioport);\n\t}\n}\n\nstatic u8 bochs_vga_readb(struct bochs_device *bochs, u16 ioport)\n{\n\tif (WARN_ON(ioport < 0x3c0 || ioport > 0x3df))\n\t\treturn 0xff;\n\n\tif (bochs->mmio) {\n\t\tint offset = ioport - 0x3c0 + 0x400;\n\n\t\treturn readb(bochs->mmio + offset);\n\t} else {\n\t\treturn inb(ioport);\n\t}\n}\n\nstatic u16 bochs_dispi_read(struct bochs_device *bochs, u16 reg)\n{\n\tu16 ret = 0;\n\n\tif (bochs->mmio) {\n\t\tint offset = 0x500 + (reg << 1);\n\n\t\tret = readw(bochs->mmio + offset);\n\t} else {\n\t\toutw(reg, VBE_DISPI_IOPORT_INDEX);\n\t\tret = inw(VBE_DISPI_IOPORT_DATA);\n\t}\n\treturn ret;\n}\n\nstatic void bochs_dispi_write(struct bochs_device *bochs, u16 reg, u16 val)\n{\n\tif (bochs->mmio) {\n\t\tint offset = 0x500 + (reg << 1);\n\n\t\twritew(val, bochs->mmio + offset);\n\t} else {\n\t\toutw(reg, VBE_DISPI_IOPORT_INDEX);\n\t\toutw(val, VBE_DISPI_IOPORT_DATA);\n\t}\n}\n\nstatic void bochs_hw_set_big_endian(struct bochs_device *bochs)\n{\n\tif (bochs->qext_size < 8)\n\t\treturn;\n\n\twritel(0xbebebebe, bochs->mmio + 0x604);\n}\n\nstatic void bochs_hw_set_little_endian(struct bochs_device *bochs)\n{\n\tif (bochs->qext_size < 8)\n\t\treturn;\n\n\twritel(0x1e1e1e1e, bochs->mmio + 0x604);\n}\n\n#ifdef __BIG_ENDIAN\n#define bochs_hw_set_native_endian(_b) bochs_hw_set_big_endian(_b)\n#else\n#define bochs_hw_set_native_endian(_b) bochs_hw_set_little_endian(_b)\n#endif\n\nstatic int bochs_get_edid_block(void *data, u8 *buf,\n\t\t\t\tunsigned int block, size_t len)\n{\n\tstruct bochs_device *bochs = data;\n\tsize_t i, start = block * EDID_LENGTH;\n\n\tif (start + len > 0x400  )\n\t\treturn -1;\n\n\tfor (i = 0; i < len; i++)\n\t\tbuf[i] = readb(bochs->mmio + start + i);\n\n\treturn 0;\n}\n\nstatic int bochs_hw_load_edid(struct bochs_device *bochs)\n{\n\tu8 header[8];\n\n\tif (!bochs->mmio)\n\t\treturn -1;\n\n\t \n\tbochs_get_edid_block(bochs, header, 0, ARRAY_SIZE(header));\n\tif (drm_edid_header_is_valid(header) != 8)\n\t\treturn -1;\n\n\tkfree(bochs->edid);\n\tbochs->edid = drm_do_get_edid(&bochs->connector,\n\t\t\t\t      bochs_get_edid_block, bochs);\n\tif (bochs->edid == NULL)\n\t\treturn -1;\n\n\treturn 0;\n}\n\nstatic int bochs_hw_init(struct drm_device *dev)\n{\n\tstruct bochs_device *bochs = dev->dev_private;\n\tstruct pci_dev *pdev = to_pci_dev(dev->dev);\n\tunsigned long addr, size, mem, ioaddr, iosize;\n\tu16 id;\n\n\tif (pdev->resource[2].flags & IORESOURCE_MEM) {\n\t\t \n\t\tif (pci_request_region(pdev, 2, \"bochs-drm\") != 0) {\n\t\t\tDRM_ERROR(\"Cannot request mmio region\\n\");\n\t\t\treturn -EBUSY;\n\t\t}\n\t\tioaddr = pci_resource_start(pdev, 2);\n\t\tiosize = pci_resource_len(pdev, 2);\n\t\tbochs->mmio = ioremap(ioaddr, iosize);\n\t\tif (bochs->mmio == NULL) {\n\t\t\tDRM_ERROR(\"Cannot map mmio region\\n\");\n\t\t\treturn -ENOMEM;\n\t\t}\n\t} else {\n\t\tioaddr = VBE_DISPI_IOPORT_INDEX;\n\t\tiosize = 2;\n\t\tif (!request_region(ioaddr, iosize, \"bochs-drm\")) {\n\t\t\tDRM_ERROR(\"Cannot request ioports\\n\");\n\t\t\treturn -EBUSY;\n\t\t}\n\t\tbochs->ioports = 1;\n\t}\n\n\tid = bochs_dispi_read(bochs, VBE_DISPI_INDEX_ID);\n\tmem = bochs_dispi_read(bochs, VBE_DISPI_INDEX_VIDEO_MEMORY_64K)\n\t\t* 64 * 1024;\n\tif ((id & 0xfff0) != VBE_DISPI_ID0) {\n\t\tDRM_ERROR(\"ID mismatch\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tif ((pdev->resource[0].flags & IORESOURCE_MEM) == 0)\n\t\treturn -ENODEV;\n\taddr = pci_resource_start(pdev, 0);\n\tsize = pci_resource_len(pdev, 0);\n\tif (addr == 0)\n\t\treturn -ENODEV;\n\tif (size != mem) {\n\t\tDRM_ERROR(\"Size mismatch: pci=%ld, bochs=%ld\\n\",\n\t\t\tsize, mem);\n\t\tsize = min(size, mem);\n\t}\n\n\tif (pci_request_region(pdev, 0, \"bochs-drm\") != 0)\n\t\tDRM_WARN(\"Cannot request framebuffer, boot fb still active?\\n\");\n\n\tbochs->fb_map = ioremap(addr, size);\n\tif (bochs->fb_map == NULL) {\n\t\tDRM_ERROR(\"Cannot map framebuffer\\n\");\n\t\treturn -ENOMEM;\n\t}\n\tbochs->fb_base = addr;\n\tbochs->fb_size = size;\n\n\tDRM_INFO(\"Found bochs VGA, ID 0x%x.\\n\", id);\n\tDRM_INFO(\"Framebuffer size %ld kB @ 0x%lx, %s @ 0x%lx.\\n\",\n\t\t size / 1024, addr,\n\t\t bochs->ioports ? \"ioports\" : \"mmio\",\n\t\t ioaddr);\n\n\tif (bochs->mmio && pdev->revision >= 2) {\n\t\tbochs->qext_size = readl(bochs->mmio + 0x600);\n\t\tif (bochs->qext_size < 4 || bochs->qext_size > iosize) {\n\t\t\tbochs->qext_size = 0;\n\t\t\tgoto noext;\n\t\t}\n\t\tDRM_DEBUG(\"Found qemu ext regs, size %ld\\n\",\n\t\t\t  bochs->qext_size);\n\t\tbochs_hw_set_native_endian(bochs);\n\t}\n\nnoext:\n\treturn 0;\n}\n\nstatic void bochs_hw_fini(struct drm_device *dev)\n{\n\tstruct bochs_device *bochs = dev->dev_private;\n\n\t \n\n\tif (bochs->mmio)\n\t\tiounmap(bochs->mmio);\n\tif (bochs->ioports)\n\t\trelease_region(VBE_DISPI_IOPORT_INDEX, 2);\n\tif (bochs->fb_map)\n\t\tiounmap(bochs->fb_map);\n\tpci_release_regions(to_pci_dev(dev->dev));\n\tkfree(bochs->edid);\n}\n\nstatic void bochs_hw_blank(struct bochs_device *bochs, bool blank)\n{\n\tDRM_DEBUG_DRIVER(\"hw_blank %d\\n\", blank);\n\t \n\tbochs_vga_writeb(bochs, VGA_MIS_W, VGA_MIS_COLOR);\n\t \n\t(void)bochs_vga_readb(bochs, VGA_IS1_RC);\n\t \n\tbochs_vga_writeb(bochs, VGA_ATT_W, blank ? 0 : 0x20);\n}\n\nstatic void bochs_hw_setmode(struct bochs_device *bochs, struct drm_display_mode *mode)\n{\n\tint idx;\n\n\tif (!drm_dev_enter(bochs->dev, &idx))\n\t\treturn;\n\n\tbochs->xres = mode->hdisplay;\n\tbochs->yres = mode->vdisplay;\n\tbochs->bpp = 32;\n\tbochs->stride = mode->hdisplay * (bochs->bpp / 8);\n\tbochs->yres_virtual = bochs->fb_size / bochs->stride;\n\n\tDRM_DEBUG_DRIVER(\"%dx%d @ %d bpp, vy %d\\n\",\n\t\t\t bochs->xres, bochs->yres, bochs->bpp,\n\t\t\t bochs->yres_virtual);\n\n\tbochs_hw_blank(bochs, false);\n\n\tbochs_dispi_write(bochs, VBE_DISPI_INDEX_ENABLE,      0);\n\tbochs_dispi_write(bochs, VBE_DISPI_INDEX_BPP,         bochs->bpp);\n\tbochs_dispi_write(bochs, VBE_DISPI_INDEX_XRES,        bochs->xres);\n\tbochs_dispi_write(bochs, VBE_DISPI_INDEX_YRES,        bochs->yres);\n\tbochs_dispi_write(bochs, VBE_DISPI_INDEX_BANK,        0);\n\tbochs_dispi_write(bochs, VBE_DISPI_INDEX_VIRT_WIDTH,  bochs->xres);\n\tbochs_dispi_write(bochs, VBE_DISPI_INDEX_VIRT_HEIGHT,\n\t\t\t  bochs->yres_virtual);\n\tbochs_dispi_write(bochs, VBE_DISPI_INDEX_X_OFFSET,    0);\n\tbochs_dispi_write(bochs, VBE_DISPI_INDEX_Y_OFFSET,    0);\n\n\tbochs_dispi_write(bochs, VBE_DISPI_INDEX_ENABLE,\n\t\t\t  VBE_DISPI_ENABLED | VBE_DISPI_LFB_ENABLED);\n\n\tdrm_dev_exit(idx);\n}\n\nstatic void bochs_hw_setformat(struct bochs_device *bochs, const struct drm_format_info *format)\n{\n\tint idx;\n\n\tif (!drm_dev_enter(bochs->dev, &idx))\n\t\treturn;\n\n\tDRM_DEBUG_DRIVER(\"format %c%c%c%c\\n\",\n\t\t\t (format->format >>  0) & 0xff,\n\t\t\t (format->format >>  8) & 0xff,\n\t\t\t (format->format >> 16) & 0xff,\n\t\t\t (format->format >> 24) & 0xff);\n\n\tswitch (format->format) {\n\tcase DRM_FORMAT_XRGB8888:\n\t\tbochs_hw_set_little_endian(bochs);\n\t\tbreak;\n\tcase DRM_FORMAT_BGRX8888:\n\t\tbochs_hw_set_big_endian(bochs);\n\t\tbreak;\n\tdefault:\n\t\t \n\t\tDRM_ERROR(\"%s: Huh? Got framebuffer format 0x%x\",\n\t\t\t  __func__, format->format);\n\t\tbreak;\n\t}\n\n\tdrm_dev_exit(idx);\n}\n\nstatic void bochs_hw_setbase(struct bochs_device *bochs, int x, int y, int stride, u64 addr)\n{\n\tunsigned long offset;\n\tunsigned int vx, vy, vwidth, idx;\n\n\tif (!drm_dev_enter(bochs->dev, &idx))\n\t\treturn;\n\n\tbochs->stride = stride;\n\toffset = (unsigned long)addr +\n\t\ty * bochs->stride +\n\t\tx * (bochs->bpp / 8);\n\tvy = offset / bochs->stride;\n\tvx = (offset % bochs->stride) * 8 / bochs->bpp;\n\tvwidth = stride * 8 / bochs->bpp;\n\n\tDRM_DEBUG_DRIVER(\"x %d, y %d, addr %llx -> offset %lx, vx %d, vy %d\\n\",\n\t\t\t x, y, addr, offset, vx, vy);\n\tbochs_dispi_write(bochs, VBE_DISPI_INDEX_VIRT_WIDTH, vwidth);\n\tbochs_dispi_write(bochs, VBE_DISPI_INDEX_X_OFFSET, vx);\n\tbochs_dispi_write(bochs, VBE_DISPI_INDEX_Y_OFFSET, vy);\n\n\tdrm_dev_exit(idx);\n}\n\n \n\nstatic const uint32_t bochs_formats[] = {\n\tDRM_FORMAT_XRGB8888,\n\tDRM_FORMAT_BGRX8888,\n};\n\nstatic void bochs_plane_update(struct bochs_device *bochs, struct drm_plane_state *state)\n{\n\tstruct drm_gem_vram_object *gbo;\n\ts64 gpu_addr;\n\n\tif (!state->fb || !bochs->stride)\n\t\treturn;\n\n\tgbo = drm_gem_vram_of_gem(state->fb->obj[0]);\n\tgpu_addr = drm_gem_vram_offset(gbo);\n\tif (WARN_ON_ONCE(gpu_addr < 0))\n\t\treturn;  \n\n\tbochs_hw_setbase(bochs,\n\t\t\t state->crtc_x,\n\t\t\t state->crtc_y,\n\t\t\t state->fb->pitches[0],\n\t\t\t state->fb->offsets[0] + gpu_addr);\n\tbochs_hw_setformat(bochs, state->fb->format);\n}\n\nstatic void bochs_pipe_enable(struct drm_simple_display_pipe *pipe,\n\t\t\t      struct drm_crtc_state *crtc_state,\n\t\t\t      struct drm_plane_state *plane_state)\n{\n\tstruct bochs_device *bochs = pipe->crtc.dev->dev_private;\n\n\tbochs_hw_setmode(bochs, &crtc_state->mode);\n\tbochs_plane_update(bochs, plane_state);\n}\n\nstatic void bochs_pipe_disable(struct drm_simple_display_pipe *pipe)\n{\n\tstruct bochs_device *bochs = pipe->crtc.dev->dev_private;\n\n\tbochs_hw_blank(bochs, true);\n}\n\nstatic void bochs_pipe_update(struct drm_simple_display_pipe *pipe,\n\t\t\t      struct drm_plane_state *old_state)\n{\n\tstruct bochs_device *bochs = pipe->crtc.dev->dev_private;\n\n\tbochs_plane_update(bochs, pipe->plane.state);\n}\n\nstatic const struct drm_simple_display_pipe_funcs bochs_pipe_funcs = {\n\t.enable\t    = bochs_pipe_enable,\n\t.disable    = bochs_pipe_disable,\n\t.update\t    = bochs_pipe_update,\n\t.prepare_fb = drm_gem_vram_simple_display_pipe_prepare_fb,\n\t.cleanup_fb = drm_gem_vram_simple_display_pipe_cleanup_fb,\n};\n\nstatic int bochs_connector_get_modes(struct drm_connector *connector)\n{\n\tstruct bochs_device *bochs =\n\t\tcontainer_of(connector, struct bochs_device, connector);\n\tint count = 0;\n\n\tif (bochs->edid)\n\t\tcount = drm_add_edid_modes(connector, bochs->edid);\n\n\tif (!count) {\n\t\tcount = drm_add_modes_noedid(connector, 8192, 8192);\n\t\tdrm_set_preferred_mode(connector, defx, defy);\n\t}\n\treturn count;\n}\n\nstatic const struct drm_connector_helper_funcs bochs_connector_connector_helper_funcs = {\n\t.get_modes = bochs_connector_get_modes,\n};\n\nstatic const struct drm_connector_funcs bochs_connector_connector_funcs = {\n\t.fill_modes = drm_helper_probe_single_connector_modes,\n\t.destroy = drm_connector_cleanup,\n\t.reset = drm_atomic_helper_connector_reset,\n\t.atomic_duplicate_state = drm_atomic_helper_connector_duplicate_state,\n\t.atomic_destroy_state = drm_atomic_helper_connector_destroy_state,\n};\n\nstatic void bochs_connector_init(struct drm_device *dev)\n{\n\tstruct bochs_device *bochs = dev->dev_private;\n\tstruct drm_connector *connector = &bochs->connector;\n\n\tdrm_connector_init(dev, connector, &bochs_connector_connector_funcs,\n\t\t\t   DRM_MODE_CONNECTOR_VIRTUAL);\n\tdrm_connector_helper_add(connector, &bochs_connector_connector_helper_funcs);\n\n\tbochs_hw_load_edid(bochs);\n\tif (bochs->edid) {\n\t\tDRM_INFO(\"Found EDID data blob.\\n\");\n\t\tdrm_connector_attach_edid_property(connector);\n\t\tdrm_connector_update_edid_property(connector, bochs->edid);\n\t}\n}\n\nstatic struct drm_framebuffer *\nbochs_gem_fb_create(struct drm_device *dev, struct drm_file *file,\n\t\t    const struct drm_mode_fb_cmd2 *mode_cmd)\n{\n\tif (mode_cmd->pixel_format != DRM_FORMAT_XRGB8888 &&\n\t    mode_cmd->pixel_format != DRM_FORMAT_BGRX8888)\n\t\treturn ERR_PTR(-EINVAL);\n\n\treturn drm_gem_fb_create(dev, file, mode_cmd);\n}\n\nstatic const struct drm_mode_config_funcs bochs_mode_funcs = {\n\t.fb_create = bochs_gem_fb_create,\n\t.mode_valid = drm_vram_helper_mode_valid,\n\t.atomic_check = drm_atomic_helper_check,\n\t.atomic_commit = drm_atomic_helper_commit,\n};\n\nstatic int bochs_kms_init(struct bochs_device *bochs)\n{\n\tint ret;\n\n\tret = drmm_mode_config_init(bochs->dev);\n\tif (ret)\n\t\treturn ret;\n\n\tbochs->dev->mode_config.max_width = 8192;\n\tbochs->dev->mode_config.max_height = 8192;\n\n\tbochs->dev->mode_config.preferred_depth = 24;\n\tbochs->dev->mode_config.prefer_shadow = 0;\n\tbochs->dev->mode_config.quirk_addfb_prefer_host_byte_order = true;\n\n\tbochs->dev->mode_config.funcs = &bochs_mode_funcs;\n\n\tbochs_connector_init(bochs->dev);\n\tdrm_simple_display_pipe_init(bochs->dev,\n\t\t\t\t     &bochs->pipe,\n\t\t\t\t     &bochs_pipe_funcs,\n\t\t\t\t     bochs_formats,\n\t\t\t\t     ARRAY_SIZE(bochs_formats),\n\t\t\t\t     NULL,\n\t\t\t\t     &bochs->connector);\n\n\tdrm_mode_config_reset(bochs->dev);\n\n\treturn 0;\n}\n\n \n \n\nstatic int bochs_load(struct drm_device *dev)\n{\n\tstruct bochs_device *bochs;\n\tint ret;\n\n\tbochs = drmm_kzalloc(dev, sizeof(*bochs), GFP_KERNEL);\n\tif (bochs == NULL)\n\t\treturn -ENOMEM;\n\tdev->dev_private = bochs;\n\tbochs->dev = dev;\n\n\tret = bochs_hw_init(dev);\n\tif (ret)\n\t\treturn ret;\n\n\tret = drmm_vram_helper_init(dev, bochs->fb_base, bochs->fb_size);\n\tif (ret)\n\t\tgoto err_hw_fini;\n\n\tret = bochs_kms_init(bochs);\n\tif (ret)\n\t\tgoto err_hw_fini;\n\n\treturn 0;\n\nerr_hw_fini:\n\tbochs_hw_fini(dev);\n\treturn ret;\n}\n\nDEFINE_DRM_GEM_FOPS(bochs_fops);\n\nstatic const struct drm_driver bochs_driver = {\n\t.driver_features\t= DRIVER_GEM | DRIVER_MODESET | DRIVER_ATOMIC,\n\t.fops\t\t\t= &bochs_fops,\n\t.name\t\t\t= \"bochs-drm\",\n\t.desc\t\t\t= \"bochs dispi vga interface (qemu stdvga)\",\n\t.date\t\t\t= \"20130925\",\n\t.major\t\t\t= 1,\n\t.minor\t\t\t= 0,\n\tDRM_GEM_VRAM_DRIVER,\n};\n\n \n \n\n#ifdef CONFIG_PM_SLEEP\nstatic int bochs_pm_suspend(struct device *dev)\n{\n\tstruct drm_device *drm_dev = dev_get_drvdata(dev);\n\n\treturn drm_mode_config_helper_suspend(drm_dev);\n}\n\nstatic int bochs_pm_resume(struct device *dev)\n{\n\tstruct drm_device *drm_dev = dev_get_drvdata(dev);\n\n\treturn drm_mode_config_helper_resume(drm_dev);\n}\n#endif\n\nstatic const struct dev_pm_ops bochs_pm_ops = {\n\tSET_SYSTEM_SLEEP_PM_OPS(bochs_pm_suspend,\n\t\t\t\tbochs_pm_resume)\n};\n\n \n \n\nstatic int bochs_pci_probe(struct pci_dev *pdev, const struct pci_device_id *ent)\n{\n\tstruct drm_device *dev;\n\tunsigned long fbsize;\n\tint ret;\n\n\tfbsize = pci_resource_len(pdev, 0);\n\tif (fbsize < 4 * 1024 * 1024) {\n\t\tDRM_ERROR(\"less than 4 MB video memory, ignoring device\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tret = drm_aperture_remove_conflicting_pci_framebuffers(pdev, &bochs_driver);\n\tif (ret)\n\t\treturn ret;\n\n\tdev = drm_dev_alloc(&bochs_driver, &pdev->dev);\n\tif (IS_ERR(dev))\n\t\treturn PTR_ERR(dev);\n\n\tret = pcim_enable_device(pdev);\n\tif (ret)\n\t\tgoto err_free_dev;\n\n\tpci_set_drvdata(pdev, dev);\n\n\tret = bochs_load(dev);\n\tif (ret)\n\t\tgoto err_free_dev;\n\n\tret = drm_dev_register(dev, 0);\n\tif (ret)\n\t\tgoto err_hw_fini;\n\n\tdrm_fbdev_generic_setup(dev, 32);\n\treturn ret;\n\nerr_hw_fini:\n\tbochs_hw_fini(dev);\nerr_free_dev:\n\tdrm_dev_put(dev);\n\treturn ret;\n}\n\nstatic void bochs_pci_remove(struct pci_dev *pdev)\n{\n\tstruct drm_device *dev = pci_get_drvdata(pdev);\n\n\tdrm_dev_unplug(dev);\n\tdrm_atomic_helper_shutdown(dev);\n\tbochs_hw_fini(dev);\n\tdrm_dev_put(dev);\n}\n\nstatic const struct pci_device_id bochs_pci_tbl[] = {\n\t{\n\t\t.vendor      = 0x1234,\n\t\t.device      = 0x1111,\n\t\t.subvendor   = PCI_SUBVENDOR_ID_REDHAT_QUMRANET,\n\t\t.subdevice   = PCI_SUBDEVICE_ID_QEMU,\n\t\t.driver_data = BOCHS_QEMU_STDVGA,\n\t},\n\t{\n\t\t.vendor      = 0x1234,\n\t\t.device      = 0x1111,\n\t\t.subvendor   = PCI_ANY_ID,\n\t\t.subdevice   = PCI_ANY_ID,\n\t\t.driver_data = BOCHS_UNKNOWN,\n\t},\n\t{\n\t\t.vendor      = 0x4321,\n\t\t.device      = 0x1111,\n\t\t.subvendor   = PCI_ANY_ID,\n\t\t.subdevice   = PCI_ANY_ID,\n\t\t.driver_data = BOCHS_SIMICS,\n\t},\n\t{   }\n};\n\nstatic struct pci_driver bochs_pci_driver = {\n\t.name =\t\t\"bochs-drm\",\n\t.id_table =\tbochs_pci_tbl,\n\t.probe =\tbochs_pci_probe,\n\t.remove =\tbochs_pci_remove,\n\t.driver.pm =    &bochs_pm_ops,\n};\n\n \n \n\ndrm_module_pci_driver_if_modeset(bochs_pci_driver, bochs_modeset);\n\nMODULE_DEVICE_TABLE(pci, bochs_pci_tbl);\nMODULE_AUTHOR(\"Gerd Hoffmann <kraxel@redhat.com>\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}