{
  "module_name": "ofdrm.c",
  "hash_id": "f27dcdca0997f32708b0197993f30b87cfd0af1189087da053aefa92662b28b9",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/tiny/ofdrm.c",
  "human_readable_source": "\n\n#include <linux/of_address.h>\n#include <linux/pci.h>\n#include <linux/platform_device.h>\n\n#include <drm/drm_aperture.h>\n#include <drm/drm_atomic.h>\n#include <drm/drm_atomic_state_helper.h>\n#include <drm/drm_connector.h>\n#include <drm/drm_damage_helper.h>\n#include <drm/drm_device.h>\n#include <drm/drm_drv.h>\n#include <drm/drm_fbdev_generic.h>\n#include <drm/drm_format_helper.h>\n#include <drm/drm_framebuffer.h>\n#include <drm/drm_gem_atomic_helper.h>\n#include <drm/drm_gem_framebuffer_helper.h>\n#include <drm/drm_gem_shmem_helper.h>\n#include <drm/drm_managed.h>\n#include <drm/drm_modeset_helper_vtables.h>\n#include <drm/drm_plane_helper.h>\n#include <drm/drm_probe_helper.h>\n#include <drm/drm_simple_kms_helper.h>\n\n#define DRIVER_NAME\t\"ofdrm\"\n#define DRIVER_DESC\t\"DRM driver for OF platform devices\"\n#define DRIVER_DATE\t\"20220501\"\n#define DRIVER_MAJOR\t1\n#define DRIVER_MINOR\t0\n\n#define PCI_VENDOR_ID_ATI_R520\t0x7100\n#define PCI_VENDOR_ID_ATI_R600\t0x9400\n\n#define OFDRM_GAMMA_LUT_SIZE\t256\n\n \n#define AVIVO_DC_LUT_RW_SELECT                  0x6480\n#define AVIVO_DC_LUT_RW_MODE                    0x6484\n#define AVIVO_DC_LUT_RW_INDEX                   0x6488\n#define AVIVO_DC_LUT_SEQ_COLOR                  0x648c\n#define AVIVO_DC_LUT_PWL_DATA                   0x6490\n#define AVIVO_DC_LUT_30_COLOR                   0x6494\n#define AVIVO_DC_LUT_READ_PIPE_SELECT           0x6498\n#define AVIVO_DC_LUT_WRITE_EN_MASK              0x649c\n#define AVIVO_DC_LUT_AUTOFILL                   0x64a0\n#define AVIVO_DC_LUTA_CONTROL                   0x64c0\n#define AVIVO_DC_LUTA_BLACK_OFFSET_BLUE         0x64c4\n#define AVIVO_DC_LUTA_BLACK_OFFSET_GREEN        0x64c8\n#define AVIVO_DC_LUTA_BLACK_OFFSET_RED          0x64cc\n#define AVIVO_DC_LUTA_WHITE_OFFSET_BLUE         0x64d0\n#define AVIVO_DC_LUTA_WHITE_OFFSET_GREEN        0x64d4\n#define AVIVO_DC_LUTA_WHITE_OFFSET_RED          0x64d8\n#define AVIVO_DC_LUTB_CONTROL                   0x6cc0\n#define AVIVO_DC_LUTB_BLACK_OFFSET_BLUE         0x6cc4\n#define AVIVO_DC_LUTB_BLACK_OFFSET_GREEN        0x6cc8\n#define AVIVO_DC_LUTB_BLACK_OFFSET_RED          0x6ccc\n#define AVIVO_DC_LUTB_WHITE_OFFSET_BLUE         0x6cd0\n#define AVIVO_DC_LUTB_WHITE_OFFSET_GREEN        0x6cd4\n#define AVIVO_DC_LUTB_WHITE_OFFSET_RED          0x6cd8\n\nenum ofdrm_model {\n\tOFDRM_MODEL_UNKNOWN,\n\tOFDRM_MODEL_MACH64,  \n\tOFDRM_MODEL_RAGE128,  \n\tOFDRM_MODEL_RAGE_M3A,  \n\tOFDRM_MODEL_RAGE_M3B,  \n\tOFDRM_MODEL_RADEON,  \n\tOFDRM_MODEL_GXT2000,  \n\tOFDRM_MODEL_AVIVO,  \n\tOFDRM_MODEL_QEMU,  \n};\n\n \n\nstatic int display_get_validated_int(struct drm_device *dev, const char *name, uint32_t value)\n{\n\tif (value > INT_MAX) {\n\t\tdrm_err(dev, \"invalid framebuffer %s of %u\\n\", name, value);\n\t\treturn -EINVAL;\n\t}\n\treturn (int)value;\n}\n\nstatic int display_get_validated_int0(struct drm_device *dev, const char *name, uint32_t value)\n{\n\tif (!value) {\n\t\tdrm_err(dev, \"invalid framebuffer %s of %u\\n\", name, value);\n\t\treturn -EINVAL;\n\t}\n\treturn display_get_validated_int(dev, name, value);\n}\n\nstatic const struct drm_format_info *display_get_validated_format(struct drm_device *dev,\n\t\t\t\t\t\t\t\t  u32 depth, bool big_endian)\n{\n\tconst struct drm_format_info *info;\n\tu32 format;\n\n\tswitch (depth) {\n\tcase 8:\n\t\tformat = drm_mode_legacy_fb_format(8, 8);\n\t\tbreak;\n\tcase 15:\n\tcase 16:\n\t\tformat = drm_mode_legacy_fb_format(16, depth);\n\t\tbreak;\n\tcase 32:\n\t\tformat = drm_mode_legacy_fb_format(32, 24);\n\t\tbreak;\n\tdefault:\n\t\tdrm_err(dev, \"unsupported framebuffer depth %u\\n\", depth);\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\t \n\tif (big_endian) {\n\t\tswitch (format) {\n\t\tcase DRM_FORMAT_XRGB8888:\n\t\t\tformat = DRM_FORMAT_BGRX8888;\n\t\t\tbreak;\n\t\tcase DRM_FORMAT_ARGB8888:\n\t\t\tformat = DRM_FORMAT_BGRA8888;\n\t\t\tbreak;\n\t\tcase DRM_FORMAT_RGB565:\n\t\t\tformat = DRM_FORMAT_RGB565 | DRM_FORMAT_BIG_ENDIAN;\n\t\t\tbreak;\n\t\tcase DRM_FORMAT_XRGB1555:\n\t\t\tformat = DRM_FORMAT_XRGB1555 | DRM_FORMAT_BIG_ENDIAN;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tinfo = drm_format_info(format);\n\tif (!info) {\n\t\tdrm_err(dev, \"cannot find framebuffer format for depth %u\\n\", depth);\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\treturn info;\n}\n\nstatic int display_read_u32_of(struct drm_device *dev, struct device_node *of_node,\n\t\t\t       const char *name, u32 *value)\n{\n\tint ret = of_property_read_u32(of_node, name, value);\n\n\tif (ret)\n\t\tdrm_err(dev, \"cannot parse framebuffer %s: error %d\\n\", name, ret);\n\treturn ret;\n}\n\nstatic bool display_get_big_endian_of(struct drm_device *dev, struct device_node *of_node)\n{\n\tbool big_endian;\n\n#ifdef __BIG_ENDIAN\n\tbig_endian = !of_property_read_bool(of_node, \"little-endian\");\n#else\n\tbig_endian = of_property_read_bool(of_node, \"big-endian\");\n#endif\n\n\treturn big_endian;\n}\n\nstatic int display_get_width_of(struct drm_device *dev, struct device_node *of_node)\n{\n\tu32 width;\n\tint ret = display_read_u32_of(dev, of_node, \"width\", &width);\n\n\tif (ret)\n\t\treturn ret;\n\treturn display_get_validated_int0(dev, \"width\", width);\n}\n\nstatic int display_get_height_of(struct drm_device *dev, struct device_node *of_node)\n{\n\tu32 height;\n\tint ret = display_read_u32_of(dev, of_node, \"height\", &height);\n\n\tif (ret)\n\t\treturn ret;\n\treturn display_get_validated_int0(dev, \"height\", height);\n}\n\nstatic int display_get_depth_of(struct drm_device *dev, struct device_node *of_node)\n{\n\tu32 depth;\n\tint ret = display_read_u32_of(dev, of_node, \"depth\", &depth);\n\n\tif (ret)\n\t\treturn ret;\n\treturn display_get_validated_int0(dev, \"depth\", depth);\n}\n\nstatic int display_get_linebytes_of(struct drm_device *dev, struct device_node *of_node)\n{\n\tu32 linebytes;\n\tint ret = display_read_u32_of(dev, of_node, \"linebytes\", &linebytes);\n\n\tif (ret)\n\t\treturn ret;\n\treturn display_get_validated_int(dev, \"linebytes\", linebytes);\n}\n\nstatic u64 display_get_address_of(struct drm_device *dev, struct device_node *of_node)\n{\n\tu32 address;\n\tint ret;\n\n\t \n\tret = of_property_read_u32(of_node, \"address\", &address);\n\tif (ret)\n\t\treturn OF_BAD_ADDR;\n\n\treturn address;\n}\n\nstatic bool is_avivo(u32 vendor, u32 device)\n{\n\t \n\treturn (vendor == PCI_VENDOR_ID_ATI) &&\n\t       ((device >= PCI_VENDOR_ID_ATI_R520 && device < 0x7800) ||\n\t\t(PCI_VENDOR_ID_ATI_R600 >= 0x9400));\n}\n\nstatic enum ofdrm_model display_get_model_of(struct drm_device *dev, struct device_node *of_node)\n{\n\tenum ofdrm_model model = OFDRM_MODEL_UNKNOWN;\n\n\tif (of_node_name_prefix(of_node, \"ATY,Rage128\")) {\n\t\tmodel = OFDRM_MODEL_RAGE128;\n\t} else if (of_node_name_prefix(of_node, \"ATY,RageM3pA\") ||\n\t\t   of_node_name_prefix(of_node, \"ATY,RageM3p12A\")) {\n\t\tmodel = OFDRM_MODEL_RAGE_M3A;\n\t} else if (of_node_name_prefix(of_node, \"ATY,RageM3pB\")) {\n\t\tmodel = OFDRM_MODEL_RAGE_M3B;\n\t} else if (of_node_name_prefix(of_node, \"ATY,Rage6\")) {\n\t\tmodel = OFDRM_MODEL_RADEON;\n\t} else if (of_node_name_prefix(of_node, \"ATY,\")) {\n\t\treturn OFDRM_MODEL_MACH64;\n\t} else if (of_device_is_compatible(of_node, \"pci1014,b7\") ||\n\t\t   of_device_is_compatible(of_node, \"pci1014,21c\")) {\n\t\tmodel = OFDRM_MODEL_GXT2000;\n\t} else if (of_node_name_prefix(of_node, \"vga,Display-\")) {\n\t\tstruct device_node *of_parent;\n\t\tconst __be32 *vendor_p, *device_p;\n\n\t\t \n\t\tof_parent = of_get_parent(of_node);\n\t\tvendor_p = of_get_property(of_parent, \"vendor-id\", NULL);\n\t\tdevice_p = of_get_property(of_parent, \"device-id\", NULL);\n\t\tif (vendor_p && device_p) {\n\t\t\tu32 vendor = be32_to_cpup(vendor_p);\n\t\t\tu32 device = be32_to_cpup(device_p);\n\n\t\t\tif (is_avivo(vendor, device))\n\t\t\t\tmodel = OFDRM_MODEL_AVIVO;\n\t\t}\n\t\tof_node_put(of_parent);\n\t} else if (of_device_is_compatible(of_node, \"qemu,std-vga\")) {\n\t\tmodel = OFDRM_MODEL_QEMU;\n\t}\n\n\treturn model;\n}\n\n \n\nstruct ofdrm_device;\n\nstruct ofdrm_device_funcs {\n\tvoid __iomem *(*cmap_ioremap)(struct ofdrm_device *odev,\n\t\t\t\t      struct device_node *of_node,\n\t\t\t\t      u64 fb_bas);\n\tvoid (*cmap_write)(struct ofdrm_device *odev, unsigned char index,\n\t\t\t   unsigned char r, unsigned char g, unsigned char b);\n};\n\nstruct ofdrm_device {\n\tstruct drm_device dev;\n\tstruct platform_device *pdev;\n\n\tconst struct ofdrm_device_funcs *funcs;\n\n\t \n\tstruct iosys_map screen_base;\n\tstruct drm_display_mode mode;\n\tconst struct drm_format_info *format;\n\tunsigned int pitch;\n\n\t \n\tvoid __iomem *cmap_base;\n\n\t \n\tuint32_t formats[8];\n\tstruct drm_plane primary_plane;\n\tstruct drm_crtc crtc;\n\tstruct drm_encoder encoder;\n\tstruct drm_connector connector;\n};\n\nstatic struct ofdrm_device *ofdrm_device_of_dev(struct drm_device *dev)\n{\n\treturn container_of(dev, struct ofdrm_device, dev);\n}\n\n \n\n#if defined(CONFIG_PCI)\nstatic struct pci_dev *display_get_pci_dev_of(struct drm_device *dev, struct device_node *of_node)\n{\n\tconst __be32 *vendor_p, *device_p;\n\tu32 vendor, device;\n\tstruct pci_dev *pcidev;\n\n\tvendor_p = of_get_property(of_node, \"vendor-id\", NULL);\n\tif (!vendor_p)\n\t\treturn ERR_PTR(-ENODEV);\n\tvendor = be32_to_cpup(vendor_p);\n\n\tdevice_p = of_get_property(of_node, \"device-id\", NULL);\n\tif (!device_p)\n\t\treturn ERR_PTR(-ENODEV);\n\tdevice = be32_to_cpup(device_p);\n\n\tpcidev = pci_get_device(vendor, device, NULL);\n\tif (!pcidev)\n\t\treturn ERR_PTR(-ENODEV);\n\n\treturn pcidev;\n}\n\nstatic void ofdrm_pci_release(void *data)\n{\n\tstruct pci_dev *pcidev = data;\n\n\tpci_disable_device(pcidev);\n}\n\nstatic int ofdrm_device_init_pci(struct ofdrm_device *odev)\n{\n\tstruct drm_device *dev = &odev->dev;\n\tstruct platform_device *pdev = to_platform_device(dev->dev);\n\tstruct device_node *of_node = pdev->dev.of_node;\n\tstruct pci_dev *pcidev;\n\tint ret;\n\n\t \n\tpcidev = display_get_pci_dev_of(dev, of_node);\n\tif (IS_ERR(pcidev))\n\t\treturn 0;  \n\n\tret = pci_enable_device(pcidev);\n\tif (ret) {\n\t\tdrm_err(dev, \"pci_enable_device(%s) failed: %d\\n\",\n\t\t\tdev_name(&pcidev->dev), ret);\n\t\treturn ret;\n\t}\n\tret = devm_add_action_or_reset(&pdev->dev, ofdrm_pci_release, pcidev);\n\tif (ret)\n\t\treturn ret;\n\n\treturn 0;\n}\n#else\nstatic int ofdrm_device_init_pci(struct ofdrm_device *odev)\n{\n\treturn 0;\n}\n#endif\n\n \n\nstatic struct resource *ofdrm_find_fb_resource(struct ofdrm_device *odev,\n\t\t\t\t\t       struct resource *fb_res)\n{\n\tstruct platform_device *pdev = to_platform_device(odev->dev.dev);\n\tstruct resource *res, *max_res = NULL;\n\tu32 i;\n\n\tfor (i = 0; pdev->num_resources; ++i) {\n\t\tres = platform_get_resource(pdev, IORESOURCE_MEM, i);\n\t\tif (!res)\n\t\t\tbreak;  \n\t\tif (resource_size(res) < resource_size(fb_res))\n\t\t\tcontinue;  \n\t\tif (fb_res->start && resource_contains(res, fb_res))\n\t\t\treturn res;  \n\t\tif (!max_res || resource_size(res) > resource_size(max_res))\n\t\t\tmax_res = res;  \n\t}\n\n\treturn max_res;\n}\n\n \n\nstatic void __iomem *get_cmap_address_of(struct ofdrm_device *odev, struct device_node *of_node,\n\t\t\t\t\t int bar_no, unsigned long offset, unsigned long size)\n{\n\tstruct drm_device *dev = &odev->dev;\n\tconst __be32 *addr_p;\n\tu64 max_size, address;\n\tunsigned int flags;\n\tvoid __iomem *mem;\n\n\taddr_p = of_get_pci_address(of_node, bar_no, &max_size, &flags);\n\tif (!addr_p)\n\t\taddr_p = of_get_address(of_node, bar_no, &max_size, &flags);\n\tif (!addr_p)\n\t\treturn IOMEM_ERR_PTR(-ENODEV);\n\n\tif ((flags & (IORESOURCE_IO | IORESOURCE_MEM)) == 0)\n\t\treturn IOMEM_ERR_PTR(-ENODEV);\n\n\tif ((offset + size) >= max_size)\n\t\treturn IOMEM_ERR_PTR(-ENODEV);\n\n\taddress = of_translate_address(of_node, addr_p);\n\tif (address == OF_BAD_ADDR)\n\t\treturn IOMEM_ERR_PTR(-ENODEV);\n\n\tmem = devm_ioremap(dev->dev, address + offset, size);\n\tif (!mem)\n\t\treturn IOMEM_ERR_PTR(-ENOMEM);\n\n\treturn mem;\n}\n\nstatic void __iomem *ofdrm_mach64_cmap_ioremap(struct ofdrm_device *odev,\n\t\t\t\t\t       struct device_node *of_node,\n\t\t\t\t\t       u64 fb_base)\n{\n\tstruct drm_device *dev = &odev->dev;\n\tu64 address;\n\tvoid __iomem *cmap_base;\n\n\taddress = fb_base & 0xff000000ul;\n\taddress += 0x7ff000;\n\n\tcmap_base = devm_ioremap(dev->dev, address, 0x1000);\n\tif (!cmap_base)\n\t\treturn IOMEM_ERR_PTR(-ENOMEM);\n\n\treturn cmap_base;\n}\n\nstatic void ofdrm_mach64_cmap_write(struct ofdrm_device *odev, unsigned char index,\n\t\t\t\t    unsigned char r, unsigned char g, unsigned char b)\n{\n\tvoid __iomem *addr = odev->cmap_base + 0xcc0;\n\tvoid __iomem *data = odev->cmap_base + 0xcc0 + 1;\n\n\twriteb(index, addr);\n\twriteb(r, data);\n\twriteb(g, data);\n\twriteb(b, data);\n}\n\nstatic void __iomem *ofdrm_rage128_cmap_ioremap(struct ofdrm_device *odev,\n\t\t\t\t\t\tstruct device_node *of_node,\n\t\t\t\t\t\tu64 fb_base)\n{\n\treturn get_cmap_address_of(odev, of_node, 2, 0, 0x1fff);\n}\n\nstatic void ofdrm_rage128_cmap_write(struct ofdrm_device *odev, unsigned char index,\n\t\t\t\t     unsigned char r, unsigned char g, unsigned char b)\n{\n\tvoid __iomem *addr = odev->cmap_base + 0xb0;\n\tvoid __iomem *data = odev->cmap_base + 0xb4;\n\tu32 color = (r << 16) | (g << 8) | b;\n\n\twriteb(index, addr);\n\twritel(color, data);\n}\n\nstatic void __iomem *ofdrm_rage_m3a_cmap_ioremap(struct ofdrm_device *odev,\n\t\t\t\t\t\t struct device_node *of_node,\n\t\t\t\t\t\t u64 fb_base)\n{\n\treturn get_cmap_address_of(odev, of_node, 2, 0, 0x1fff);\n}\n\nstatic void ofdrm_rage_m3a_cmap_write(struct ofdrm_device *odev, unsigned char index,\n\t\t\t\t      unsigned char r, unsigned char g, unsigned char b)\n{\n\tvoid __iomem *dac_ctl = odev->cmap_base + 0x58;\n\tvoid __iomem *addr = odev->cmap_base + 0xb0;\n\tvoid __iomem *data = odev->cmap_base + 0xb4;\n\tu32 color = (r << 16) | (g << 8) | b;\n\tu32 val;\n\n\t \n\tval = readl(dac_ctl);\n\tval &= ~0x20;\n\twritel(val, dac_ctl);\n\n\t \n\twriteb(index, addr);\n\twritel(color, data);\n}\n\nstatic void __iomem *ofdrm_rage_m3b_cmap_ioremap(struct ofdrm_device *odev,\n\t\t\t\t\t\t struct device_node *of_node,\n\t\t\t\t\t\t u64 fb_base)\n{\n\treturn get_cmap_address_of(odev, of_node, 2, 0, 0x1fff);\n}\n\nstatic void ofdrm_rage_m3b_cmap_write(struct ofdrm_device *odev, unsigned char index,\n\t\t\t\t      unsigned char r, unsigned char g, unsigned char b)\n{\n\tvoid __iomem *dac_ctl = odev->cmap_base + 0x58;\n\tvoid __iomem *addr = odev->cmap_base + 0xb0;\n\tvoid __iomem *data = odev->cmap_base + 0xb4;\n\tu32 color = (r << 16) | (g << 8) | b;\n\tu32 val;\n\n\t \n\tval = readl(dac_ctl);\n\tval |= 0x20;\n\twritel(val, dac_ctl);\n\n\t \n\twriteb(index, addr);\n\twritel(color, data);\n}\n\nstatic void __iomem *ofdrm_radeon_cmap_ioremap(struct ofdrm_device *odev,\n\t\t\t\t\t       struct device_node *of_node,\n\t\t\t\t\t       u64 fb_base)\n{\n\treturn get_cmap_address_of(odev, of_node, 1, 0, 0x1fff);\n}\n\nstatic void __iomem *ofdrm_gxt2000_cmap_ioremap(struct ofdrm_device *odev,\n\t\t\t\t\t\tstruct device_node *of_node,\n\t\t\t\t\t\tu64 fb_base)\n{\n\treturn get_cmap_address_of(odev, of_node, 0, 0x6000, 0x1000);\n}\n\nstatic void ofdrm_gxt2000_cmap_write(struct ofdrm_device *odev, unsigned char index,\n\t\t\t\t     unsigned char r, unsigned char g, unsigned char b)\n{\n\tvoid __iomem *data = ((unsigned int __iomem *)odev->cmap_base) + index;\n\tu32 color = (r << 16) | (g << 8) | b;\n\n\twritel(color, data);\n}\n\nstatic void __iomem *ofdrm_avivo_cmap_ioremap(struct ofdrm_device *odev,\n\t\t\t\t\t      struct device_node *of_node,\n\t\t\t\t\t      u64 fb_base)\n{\n\tstruct device_node *of_parent;\n\tvoid __iomem *cmap_base;\n\n\tof_parent = of_get_parent(of_node);\n\tcmap_base = get_cmap_address_of(odev, of_parent, 0, 0, 0x10000);\n\tof_node_put(of_parent);\n\n\treturn cmap_base;\n}\n\nstatic void ofdrm_avivo_cmap_write(struct ofdrm_device *odev, unsigned char index,\n\t\t\t\t   unsigned char r, unsigned char g, unsigned char b)\n{\n\tvoid __iomem *lutsel = odev->cmap_base + AVIVO_DC_LUT_RW_SELECT;\n\tvoid __iomem *addr = odev->cmap_base + AVIVO_DC_LUT_RW_INDEX;\n\tvoid __iomem *data = odev->cmap_base + AVIVO_DC_LUT_30_COLOR;\n\tu32 color = (r << 22) | (g << 12) | (b << 2);\n\n\t \n\n\twritel(1, lutsel);\n\twriteb(index, addr);\n\twritel(color, data);\n\n\twritel(0, lutsel);\n\twriteb(index, addr);\n\twritel(color, data);\n}\n\nstatic void __iomem *ofdrm_qemu_cmap_ioremap(struct ofdrm_device *odev,\n\t\t\t\t\t     struct device_node *of_node,\n\t\t\t\t\t     u64 fb_base)\n{\n\tstatic const __be32 io_of_addr[3] = {\n\t\tcpu_to_be32(0x01000000),\n\t\tcpu_to_be32(0x00),\n\t\tcpu_to_be32(0x00),\n\t};\n\n\tstruct drm_device *dev = &odev->dev;\n\tu64 address;\n\tvoid __iomem *cmap_base;\n\n\taddress = of_translate_address(of_node, io_of_addr);\n\tif (address == OF_BAD_ADDR)\n\t\treturn IOMEM_ERR_PTR(-ENODEV);\n\n\tcmap_base = devm_ioremap(dev->dev, address + 0x3c8, 2);\n\tif (!cmap_base)\n\t\treturn IOMEM_ERR_PTR(-ENOMEM);\n\n\treturn cmap_base;\n}\n\nstatic void ofdrm_qemu_cmap_write(struct ofdrm_device *odev, unsigned char index,\n\t\t\t\t  unsigned char r, unsigned char g, unsigned char b)\n{\n\tvoid __iomem *addr = odev->cmap_base;\n\tvoid __iomem *data = odev->cmap_base + 1;\n\n\twriteb(index, addr);\n\twriteb(r, data);\n\twriteb(g, data);\n\twriteb(b, data);\n}\n\nstatic void ofdrm_device_set_gamma_linear(struct ofdrm_device *odev,\n\t\t\t\t\t  const struct drm_format_info *format)\n{\n\tstruct drm_device *dev = &odev->dev;\n\tint i;\n\n\tswitch (format->format) {\n\tcase DRM_FORMAT_RGB565:\n\tcase DRM_FORMAT_RGB565 | DRM_FORMAT_BIG_ENDIAN:\n\t\t \n\t\tfor (i = 0; i < OFDRM_GAMMA_LUT_SIZE / 8; i++) {\n\t\t\tunsigned char r = i * 8 + i / 4;\n\t\t\tunsigned char g = i * 4 + i / 16;\n\t\t\tunsigned char b = i * 8 + i / 4;\n\n\t\t\todev->funcs->cmap_write(odev, i, r, g, b);\n\t\t}\n\t\t \n\t\tfor (i = OFDRM_GAMMA_LUT_SIZE / 8; i < OFDRM_GAMMA_LUT_SIZE / 4; i++) {\n\t\t\tunsigned char r = 0;\n\t\t\tunsigned char g = i * 4 + i / 16;\n\t\t\tunsigned char b = 0;\n\n\t\t\todev->funcs->cmap_write(odev, i, r, g, b);\n\t\t}\n\t\tbreak;\n\tcase DRM_FORMAT_XRGB8888:\n\tcase DRM_FORMAT_BGRX8888:\n\t\tfor (i = 0; i < OFDRM_GAMMA_LUT_SIZE; i++)\n\t\t\todev->funcs->cmap_write(odev, i, i, i, i);\n\t\tbreak;\n\tdefault:\n\t\tdrm_warn_once(dev, \"Unsupported format %p4cc for gamma correction\\n\",\n\t\t\t      &format->format);\n\t\tbreak;\n\t}\n}\n\nstatic void ofdrm_device_set_gamma(struct ofdrm_device *odev,\n\t\t\t\t   const struct drm_format_info *format,\n\t\t\t\t   struct drm_color_lut *lut)\n{\n\tstruct drm_device *dev = &odev->dev;\n\tint i;\n\n\tswitch (format->format) {\n\tcase DRM_FORMAT_RGB565:\n\tcase DRM_FORMAT_RGB565 | DRM_FORMAT_BIG_ENDIAN:\n\t\t \n\t\tfor (i = 0; i < OFDRM_GAMMA_LUT_SIZE / 8; i++) {\n\t\t\tunsigned char r = lut[i * 8 + i / 4].red >> 8;\n\t\t\tunsigned char g = lut[i * 4 + i / 16].green >> 8;\n\t\t\tunsigned char b = lut[i * 8 + i / 4].blue >> 8;\n\n\t\t\todev->funcs->cmap_write(odev, i, r, g, b);\n\t\t}\n\t\t \n\t\tfor (i = OFDRM_GAMMA_LUT_SIZE / 8; i < OFDRM_GAMMA_LUT_SIZE / 4; i++) {\n\t\t\tunsigned char r = 0;\n\t\t\tunsigned char g = lut[i * 4 + i / 16].green >> 8;\n\t\t\tunsigned char b = 0;\n\n\t\t\todev->funcs->cmap_write(odev, i, r, g, b);\n\t\t}\n\t\tbreak;\n\tcase DRM_FORMAT_XRGB8888:\n\tcase DRM_FORMAT_BGRX8888:\n\t\tfor (i = 0; i < OFDRM_GAMMA_LUT_SIZE; i++) {\n\t\t\tunsigned char r = lut[i].red >> 8;\n\t\t\tunsigned char g = lut[i].green >> 8;\n\t\t\tunsigned char b = lut[i].blue >> 8;\n\n\t\t\todev->funcs->cmap_write(odev, i, r, g, b);\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tdrm_warn_once(dev, \"Unsupported format %p4cc for gamma correction\\n\",\n\t\t\t      &format->format);\n\t\tbreak;\n\t}\n}\n\n \n\nstruct ofdrm_crtc_state {\n\tstruct drm_crtc_state base;\n\n\t \n\tconst struct drm_format_info *format;\n};\n\nstatic struct ofdrm_crtc_state *to_ofdrm_crtc_state(struct drm_crtc_state *base)\n{\n\treturn container_of(base, struct ofdrm_crtc_state, base);\n}\n\nstatic void ofdrm_crtc_state_destroy(struct ofdrm_crtc_state *ofdrm_crtc_state)\n{\n\t__drm_atomic_helper_crtc_destroy_state(&ofdrm_crtc_state->base);\n\tkfree(ofdrm_crtc_state);\n}\n\nstatic const uint64_t ofdrm_primary_plane_format_modifiers[] = {\n\tDRM_FORMAT_MOD_LINEAR,\n\tDRM_FORMAT_MOD_INVALID\n};\n\nstatic int ofdrm_primary_plane_helper_atomic_check(struct drm_plane *plane,\n\t\t\t\t\t\t   struct drm_atomic_state *new_state)\n{\n\tstruct drm_plane_state *new_plane_state = drm_atomic_get_new_plane_state(new_state, plane);\n\tstruct drm_framebuffer *new_fb = new_plane_state->fb;\n\tstruct drm_crtc *new_crtc = new_plane_state->crtc;\n\tstruct drm_crtc_state *new_crtc_state = NULL;\n\tstruct ofdrm_crtc_state *new_ofdrm_crtc_state;\n\tint ret;\n\n\tif (new_crtc)\n\t\tnew_crtc_state = drm_atomic_get_new_crtc_state(new_state, new_plane_state->crtc);\n\n\tret = drm_atomic_helper_check_plane_state(new_plane_state, new_crtc_state,\n\t\t\t\t\t\t  DRM_PLANE_NO_SCALING,\n\t\t\t\t\t\t  DRM_PLANE_NO_SCALING,\n\t\t\t\t\t\t  false, false);\n\tif (ret)\n\t\treturn ret;\n\telse if (!new_plane_state->visible)\n\t\treturn 0;\n\n\tnew_crtc_state = drm_atomic_get_new_crtc_state(new_state, new_plane_state->crtc);\n\n\tnew_ofdrm_crtc_state = to_ofdrm_crtc_state(new_crtc_state);\n\tnew_ofdrm_crtc_state->format = new_fb->format;\n\n\treturn 0;\n}\n\nstatic void ofdrm_primary_plane_helper_atomic_update(struct drm_plane *plane,\n\t\t\t\t\t\t     struct drm_atomic_state *state)\n{\n\tstruct drm_device *dev = plane->dev;\n\tstruct ofdrm_device *odev = ofdrm_device_of_dev(dev);\n\tstruct drm_plane_state *plane_state = drm_atomic_get_new_plane_state(state, plane);\n\tstruct drm_plane_state *old_plane_state = drm_atomic_get_old_plane_state(state, plane);\n\tstruct drm_shadow_plane_state *shadow_plane_state = to_drm_shadow_plane_state(plane_state);\n\tstruct drm_framebuffer *fb = plane_state->fb;\n\tunsigned int dst_pitch = odev->pitch;\n\tconst struct drm_format_info *dst_format = odev->format;\n\tstruct drm_atomic_helper_damage_iter iter;\n\tstruct drm_rect damage;\n\tint ret, idx;\n\n\tret = drm_gem_fb_begin_cpu_access(fb, DMA_FROM_DEVICE);\n\tif (ret)\n\t\treturn;\n\n\tif (!drm_dev_enter(dev, &idx))\n\t\tgoto out_drm_gem_fb_end_cpu_access;\n\n\tdrm_atomic_helper_damage_iter_init(&iter, old_plane_state, plane_state);\n\tdrm_atomic_for_each_plane_damage(&iter, &damage) {\n\t\tstruct iosys_map dst = odev->screen_base;\n\t\tstruct drm_rect dst_clip = plane_state->dst;\n\n\t\tif (!drm_rect_intersect(&dst_clip, &damage))\n\t\t\tcontinue;\n\n\t\tiosys_map_incr(&dst, drm_fb_clip_offset(dst_pitch, dst_format, &dst_clip));\n\t\tdrm_fb_blit(&dst, &dst_pitch, dst_format->format, shadow_plane_state->data, fb,\n\t\t\t    &damage);\n\t}\n\n\tdrm_dev_exit(idx);\nout_drm_gem_fb_end_cpu_access:\n\tdrm_gem_fb_end_cpu_access(fb, DMA_FROM_DEVICE);\n}\n\nstatic void ofdrm_primary_plane_helper_atomic_disable(struct drm_plane *plane,\n\t\t\t\t\t\t      struct drm_atomic_state *state)\n{\n\tstruct drm_device *dev = plane->dev;\n\tstruct ofdrm_device *odev = ofdrm_device_of_dev(dev);\n\tstruct iosys_map dst = odev->screen_base;\n\tstruct drm_plane_state *plane_state = drm_atomic_get_new_plane_state(state, plane);\n\tvoid __iomem *dst_vmap = dst.vaddr_iomem;  \n\tunsigned int dst_pitch = odev->pitch;\n\tconst struct drm_format_info *dst_format = odev->format;\n\tstruct drm_rect dst_clip;\n\tunsigned long lines, linepixels, i;\n\tint idx;\n\n\tdrm_rect_init(&dst_clip,\n\t\t      plane_state->src_x >> 16, plane_state->src_y >> 16,\n\t\t      plane_state->src_w >> 16, plane_state->src_h >> 16);\n\n\tlines = drm_rect_height(&dst_clip);\n\tlinepixels = drm_rect_width(&dst_clip);\n\n\tif (!drm_dev_enter(dev, &idx))\n\t\treturn;\n\n\t \n\tdst_vmap += drm_fb_clip_offset(dst_pitch, dst_format, &dst_clip);\n\tfor (i = 0; i < lines; ++i) {\n\t\tmemset_io(dst_vmap, 0, linepixels * dst_format->cpp[0]);\n\t\tdst_vmap += dst_pitch;\n\t}\n\n\tdrm_dev_exit(idx);\n}\n\nstatic const struct drm_plane_helper_funcs ofdrm_primary_plane_helper_funcs = {\n\tDRM_GEM_SHADOW_PLANE_HELPER_FUNCS,\n\t.atomic_check = ofdrm_primary_plane_helper_atomic_check,\n\t.atomic_update = ofdrm_primary_plane_helper_atomic_update,\n\t.atomic_disable = ofdrm_primary_plane_helper_atomic_disable,\n};\n\nstatic const struct drm_plane_funcs ofdrm_primary_plane_funcs = {\n\t.update_plane = drm_atomic_helper_update_plane,\n\t.disable_plane = drm_atomic_helper_disable_plane,\n\t.destroy = drm_plane_cleanup,\n\tDRM_GEM_SHADOW_PLANE_FUNCS,\n};\n\nstatic enum drm_mode_status ofdrm_crtc_helper_mode_valid(struct drm_crtc *crtc,\n\t\t\t\t\t\t\t const struct drm_display_mode *mode)\n{\n\tstruct ofdrm_device *odev = ofdrm_device_of_dev(crtc->dev);\n\n\treturn drm_crtc_helper_mode_valid_fixed(crtc, mode, &odev->mode);\n}\n\nstatic int ofdrm_crtc_helper_atomic_check(struct drm_crtc *crtc,\n\t\t\t\t\t  struct drm_atomic_state *new_state)\n{\n\tstatic const size_t gamma_lut_length = OFDRM_GAMMA_LUT_SIZE * sizeof(struct drm_color_lut);\n\n\tstruct drm_device *dev = crtc->dev;\n\tstruct drm_crtc_state *new_crtc_state = drm_atomic_get_new_crtc_state(new_state, crtc);\n\tint ret;\n\n\tif (!new_crtc_state->enable)\n\t\treturn 0;\n\n\tret = drm_atomic_helper_check_crtc_primary_plane(new_crtc_state);\n\tif (ret)\n\t\treturn ret;\n\n\tif (new_crtc_state->color_mgmt_changed) {\n\t\tstruct drm_property_blob *gamma_lut = new_crtc_state->gamma_lut;\n\n\t\tif (gamma_lut && (gamma_lut->length != gamma_lut_length)) {\n\t\t\tdrm_dbg(dev, \"Incorrect gamma_lut length %zu\\n\", gamma_lut->length);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic void ofdrm_crtc_helper_atomic_flush(struct drm_crtc *crtc, struct drm_atomic_state *state)\n{\n\tstruct ofdrm_device *odev = ofdrm_device_of_dev(crtc->dev);\n\tstruct drm_crtc_state *crtc_state = drm_atomic_get_new_crtc_state(state, crtc);\n\tstruct ofdrm_crtc_state *ofdrm_crtc_state = to_ofdrm_crtc_state(crtc_state);\n\n\tif (crtc_state->enable && crtc_state->color_mgmt_changed) {\n\t\tconst struct drm_format_info *format = ofdrm_crtc_state->format;\n\n\t\tif (crtc_state->gamma_lut)\n\t\t\tofdrm_device_set_gamma(odev, format, crtc_state->gamma_lut->data);\n\t\telse\n\t\t\tofdrm_device_set_gamma_linear(odev, format);\n\t}\n}\n\n \nstatic const struct drm_crtc_helper_funcs ofdrm_crtc_helper_funcs = {\n\t.mode_valid = ofdrm_crtc_helper_mode_valid,\n\t.atomic_check = ofdrm_crtc_helper_atomic_check,\n\t.atomic_flush = ofdrm_crtc_helper_atomic_flush,\n};\n\nstatic void ofdrm_crtc_reset(struct drm_crtc *crtc)\n{\n\tstruct ofdrm_crtc_state *ofdrm_crtc_state =\n\t\tkzalloc(sizeof(*ofdrm_crtc_state), GFP_KERNEL);\n\n\tif (crtc->state)\n\t\tofdrm_crtc_state_destroy(to_ofdrm_crtc_state(crtc->state));\n\n\tif (ofdrm_crtc_state)\n\t\t__drm_atomic_helper_crtc_reset(crtc, &ofdrm_crtc_state->base);\n\telse\n\t\t__drm_atomic_helper_crtc_reset(crtc, NULL);\n}\n\nstatic struct drm_crtc_state *ofdrm_crtc_atomic_duplicate_state(struct drm_crtc *crtc)\n{\n\tstruct drm_device *dev = crtc->dev;\n\tstruct drm_crtc_state *crtc_state = crtc->state;\n\tstruct ofdrm_crtc_state *new_ofdrm_crtc_state;\n\tstruct ofdrm_crtc_state *ofdrm_crtc_state;\n\n\tif (drm_WARN_ON(dev, !crtc_state))\n\t\treturn NULL;\n\n\tnew_ofdrm_crtc_state = kzalloc(sizeof(*new_ofdrm_crtc_state), GFP_KERNEL);\n\tif (!new_ofdrm_crtc_state)\n\t\treturn NULL;\n\n\tofdrm_crtc_state = to_ofdrm_crtc_state(crtc_state);\n\n\t__drm_atomic_helper_crtc_duplicate_state(crtc, &new_ofdrm_crtc_state->base);\n\tnew_ofdrm_crtc_state->format = ofdrm_crtc_state->format;\n\n\treturn &new_ofdrm_crtc_state->base;\n}\n\nstatic void ofdrm_crtc_atomic_destroy_state(struct drm_crtc *crtc,\n\t\t\t\t\t    struct drm_crtc_state *crtc_state)\n{\n\tofdrm_crtc_state_destroy(to_ofdrm_crtc_state(crtc_state));\n}\n\nstatic const struct drm_crtc_funcs ofdrm_crtc_funcs = {\n\t.reset = ofdrm_crtc_reset,\n\t.destroy = drm_crtc_cleanup,\n\t.set_config = drm_atomic_helper_set_config,\n\t.page_flip = drm_atomic_helper_page_flip,\n\t.atomic_duplicate_state = ofdrm_crtc_atomic_duplicate_state,\n\t.atomic_destroy_state = ofdrm_crtc_atomic_destroy_state,\n};\n\nstatic int ofdrm_connector_helper_get_modes(struct drm_connector *connector)\n{\n\tstruct ofdrm_device *odev = ofdrm_device_of_dev(connector->dev);\n\n\treturn drm_connector_helper_get_modes_fixed(connector, &odev->mode);\n}\n\nstatic const struct drm_connector_helper_funcs ofdrm_connector_helper_funcs = {\n\t.get_modes = ofdrm_connector_helper_get_modes,\n};\n\nstatic const struct drm_connector_funcs ofdrm_connector_funcs = {\n\t.reset = drm_atomic_helper_connector_reset,\n\t.fill_modes = drm_helper_probe_single_connector_modes,\n\t.destroy = drm_connector_cleanup,\n\t.atomic_duplicate_state = drm_atomic_helper_connector_duplicate_state,\n\t.atomic_destroy_state = drm_atomic_helper_connector_destroy_state,\n};\n\nstatic const struct drm_mode_config_funcs ofdrm_mode_config_funcs = {\n\t.fb_create = drm_gem_fb_create_with_dirty,\n\t.atomic_check = drm_atomic_helper_check,\n\t.atomic_commit = drm_atomic_helper_commit,\n};\n\n \n\nstatic const struct ofdrm_device_funcs ofdrm_unknown_device_funcs = {\n};\n\nstatic const struct ofdrm_device_funcs ofdrm_mach64_device_funcs = {\n\t.cmap_ioremap = ofdrm_mach64_cmap_ioremap,\n\t.cmap_write = ofdrm_mach64_cmap_write,\n};\n\nstatic const struct ofdrm_device_funcs ofdrm_rage128_device_funcs = {\n\t.cmap_ioremap = ofdrm_rage128_cmap_ioremap,\n\t.cmap_write = ofdrm_rage128_cmap_write,\n};\n\nstatic const struct ofdrm_device_funcs ofdrm_rage_m3a_device_funcs = {\n\t.cmap_ioremap = ofdrm_rage_m3a_cmap_ioremap,\n\t.cmap_write = ofdrm_rage_m3a_cmap_write,\n};\n\nstatic const struct ofdrm_device_funcs ofdrm_rage_m3b_device_funcs = {\n\t.cmap_ioremap = ofdrm_rage_m3b_cmap_ioremap,\n\t.cmap_write = ofdrm_rage_m3b_cmap_write,\n};\n\nstatic const struct ofdrm_device_funcs ofdrm_radeon_device_funcs = {\n\t.cmap_ioremap = ofdrm_radeon_cmap_ioremap,\n\t.cmap_write = ofdrm_rage128_cmap_write,  \n};\n\nstatic const struct ofdrm_device_funcs ofdrm_gxt2000_device_funcs = {\n\t.cmap_ioremap = ofdrm_gxt2000_cmap_ioremap,\n\t.cmap_write = ofdrm_gxt2000_cmap_write,\n};\n\nstatic const struct ofdrm_device_funcs ofdrm_avivo_device_funcs = {\n\t.cmap_ioremap = ofdrm_avivo_cmap_ioremap,\n\t.cmap_write = ofdrm_avivo_cmap_write,\n};\n\nstatic const struct ofdrm_device_funcs ofdrm_qemu_device_funcs = {\n\t.cmap_ioremap = ofdrm_qemu_cmap_ioremap,\n\t.cmap_write = ofdrm_qemu_cmap_write,\n};\n\nstatic struct drm_display_mode ofdrm_mode(unsigned int width, unsigned int height)\n{\n\t \n\tconst struct drm_display_mode mode = {\n\t\tDRM_MODE_INIT(60, width, height,\n\t\t\t      DRM_MODE_RES_MM(width, 96ul),\n\t\t\t      DRM_MODE_RES_MM(height, 96ul))\n\t};\n\n\treturn mode;\n}\n\nstatic struct ofdrm_device *ofdrm_device_create(struct drm_driver *drv,\n\t\t\t\t\t\tstruct platform_device *pdev)\n{\n\tstruct device_node *of_node = pdev->dev.of_node;\n\tstruct ofdrm_device *odev;\n\tstruct drm_device *dev;\n\tenum ofdrm_model model;\n\tbool big_endian;\n\tint width, height, depth, linebytes;\n\tconst struct drm_format_info *format;\n\tu64 address;\n\tresource_size_t fb_size, fb_base, fb_pgbase, fb_pgsize;\n\tstruct resource *res, *mem;\n\tvoid __iomem *screen_base;\n\tstruct drm_plane *primary_plane;\n\tstruct drm_crtc *crtc;\n\tstruct drm_encoder *encoder;\n\tstruct drm_connector *connector;\n\tunsigned long max_width, max_height;\n\tsize_t nformats;\n\tint ret;\n\n\todev = devm_drm_dev_alloc(&pdev->dev, drv, struct ofdrm_device, dev);\n\tif (IS_ERR(odev))\n\t\treturn ERR_CAST(odev);\n\tdev = &odev->dev;\n\tplatform_set_drvdata(pdev, dev);\n\n\tret = ofdrm_device_init_pci(odev);\n\tif (ret)\n\t\treturn ERR_PTR(ret);\n\n\t \n\n\tmodel = display_get_model_of(dev, of_node);\n\tdrm_dbg(dev, \"detected model %d\\n\", model);\n\n\tswitch (model) {\n\tcase OFDRM_MODEL_UNKNOWN:\n\t\todev->funcs = &ofdrm_unknown_device_funcs;\n\t\tbreak;\n\tcase OFDRM_MODEL_MACH64:\n\t\todev->funcs = &ofdrm_mach64_device_funcs;\n\t\tbreak;\n\tcase OFDRM_MODEL_RAGE128:\n\t\todev->funcs = &ofdrm_rage128_device_funcs;\n\t\tbreak;\n\tcase OFDRM_MODEL_RAGE_M3A:\n\t\todev->funcs = &ofdrm_rage_m3a_device_funcs;\n\t\tbreak;\n\tcase OFDRM_MODEL_RAGE_M3B:\n\t\todev->funcs = &ofdrm_rage_m3b_device_funcs;\n\t\tbreak;\n\tcase OFDRM_MODEL_RADEON:\n\t\todev->funcs = &ofdrm_radeon_device_funcs;\n\t\tbreak;\n\tcase OFDRM_MODEL_GXT2000:\n\t\todev->funcs = &ofdrm_gxt2000_device_funcs;\n\t\tbreak;\n\tcase OFDRM_MODEL_AVIVO:\n\t\todev->funcs = &ofdrm_avivo_device_funcs;\n\t\tbreak;\n\tcase OFDRM_MODEL_QEMU:\n\t\todev->funcs = &ofdrm_qemu_device_funcs;\n\t\tbreak;\n\t}\n\n\tbig_endian = display_get_big_endian_of(dev, of_node);\n\n\twidth = display_get_width_of(dev, of_node);\n\tif (width < 0)\n\t\treturn ERR_PTR(width);\n\theight = display_get_height_of(dev, of_node);\n\tif (height < 0)\n\t\treturn ERR_PTR(height);\n\tdepth = display_get_depth_of(dev, of_node);\n\tif (depth < 0)\n\t\treturn ERR_PTR(depth);\n\tlinebytes = display_get_linebytes_of(dev, of_node);\n\tif (linebytes < 0)\n\t\treturn ERR_PTR(linebytes);\n\n\tformat = display_get_validated_format(dev, depth, big_endian);\n\tif (IS_ERR(format))\n\t\treturn ERR_CAST(format);\n\tif (!linebytes) {\n\t\tlinebytes = drm_format_info_min_pitch(format, 0, width);\n\t\tif (drm_WARN_ON(dev, !linebytes))\n\t\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\tfb_size = linebytes * height;\n\n\t \n\taddress = display_get_address_of(dev, of_node);\n\tif (address != OF_BAD_ADDR) {\n\t\tstruct resource fb_res = DEFINE_RES_MEM(address, fb_size);\n\n\t\tres = ofdrm_find_fb_resource(odev, &fb_res);\n\t\tif (!res)\n\t\t\treturn ERR_PTR(-EINVAL);\n\t\tif (resource_contains(res, &fb_res))\n\t\t\tfb_base = address;\n\t\telse\n\t\t\tfb_base = res->start;\n\t} else {\n\t\tstruct resource fb_res = DEFINE_RES_MEM(0u, fb_size);\n\n\t\tres = ofdrm_find_fb_resource(odev, &fb_res);\n\t\tif (!res)\n\t\t\treturn ERR_PTR(-EINVAL);\n\t\tfb_base = res->start;\n\t}\n\n\t \n\n\tfb_pgbase = round_down(fb_base, PAGE_SIZE);\n\tfb_pgsize = fb_base - fb_pgbase + round_up(fb_size, PAGE_SIZE);\n\n\tret = devm_aperture_acquire_from_firmware(dev, fb_pgbase, fb_pgsize);\n\tif (ret) {\n\t\tdrm_err(dev, \"could not acquire memory range %pr: error %d\\n\", &res, ret);\n\t\treturn ERR_PTR(ret);\n\t}\n\n\tmem = devm_request_mem_region(&pdev->dev, fb_pgbase, fb_pgsize, drv->name);\n\tif (!mem) {\n\t\tdrm_warn(dev, \"could not acquire memory region %pr\\n\", &res);\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\n\tscreen_base = devm_ioremap(&pdev->dev, mem->start, resource_size(mem));\n\tif (!screen_base)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tif (odev->funcs->cmap_ioremap) {\n\t\tvoid __iomem *cmap_base = odev->funcs->cmap_ioremap(odev, of_node, fb_base);\n\n\t\tif (IS_ERR(cmap_base)) {\n\t\t\t \n\t\t\tdrm_warn(dev, \"could not find colormap: error %ld\\n\", PTR_ERR(cmap_base));\n\t\t} else {\n\t\t\todev->cmap_base = cmap_base;\n\t\t}\n\t}\n\n\t \n\n\tiosys_map_set_vaddr_iomem(&odev->screen_base, screen_base);\n\todev->mode = ofdrm_mode(width, height);\n\todev->format = format;\n\todev->pitch = linebytes;\n\n\tdrm_dbg(dev, \"display mode={\" DRM_MODE_FMT \"}\\n\", DRM_MODE_ARG(&odev->mode));\n\tdrm_dbg(dev, \"framebuffer format=%p4cc, size=%dx%d, linebytes=%d byte\\n\",\n\t\t&format->format, width, height, linebytes);\n\n\t \n\n\tret = drmm_mode_config_init(dev);\n\tif (ret)\n\t\treturn ERR_PTR(ret);\n\n\tmax_width = max_t(unsigned long, width, DRM_SHADOW_PLANE_MAX_WIDTH);\n\tmax_height = max_t(unsigned long, height, DRM_SHADOW_PLANE_MAX_HEIGHT);\n\n\tdev->mode_config.min_width = width;\n\tdev->mode_config.max_width = max_width;\n\tdev->mode_config.min_height = height;\n\tdev->mode_config.max_height = max_height;\n\tdev->mode_config.funcs = &ofdrm_mode_config_funcs;\n\tdev->mode_config.preferred_depth = format->depth;\n\tdev->mode_config.quirk_addfb_prefer_host_byte_order = true;\n\n\t \n\n\tnformats = drm_fb_build_fourcc_list(dev, &format->format, 1,\n\t\t\t\t\t    odev->formats, ARRAY_SIZE(odev->formats));\n\n\tprimary_plane = &odev->primary_plane;\n\tret = drm_universal_plane_init(dev, primary_plane, 0, &ofdrm_primary_plane_funcs,\n\t\t\t\t       odev->formats, nformats,\n\t\t\t\t       ofdrm_primary_plane_format_modifiers,\n\t\t\t\t       DRM_PLANE_TYPE_PRIMARY, NULL);\n\tif (ret)\n\t\treturn ERR_PTR(ret);\n\tdrm_plane_helper_add(primary_plane, &ofdrm_primary_plane_helper_funcs);\n\tdrm_plane_enable_fb_damage_clips(primary_plane);\n\n\t \n\n\tcrtc = &odev->crtc;\n\tret = drm_crtc_init_with_planes(dev, crtc, primary_plane, NULL,\n\t\t\t\t\t&ofdrm_crtc_funcs, NULL);\n\tif (ret)\n\t\treturn ERR_PTR(ret);\n\tdrm_crtc_helper_add(crtc, &ofdrm_crtc_helper_funcs);\n\n\tif (odev->cmap_base) {\n\t\tdrm_mode_crtc_set_gamma_size(crtc, OFDRM_GAMMA_LUT_SIZE);\n\t\tdrm_crtc_enable_color_mgmt(crtc, 0, false, OFDRM_GAMMA_LUT_SIZE);\n\t}\n\n\t \n\n\tencoder = &odev->encoder;\n\tret = drm_simple_encoder_init(dev, encoder, DRM_MODE_ENCODER_NONE);\n\tif (ret)\n\t\treturn ERR_PTR(ret);\n\tencoder->possible_crtcs = drm_crtc_mask(crtc);\n\n\t \n\n\tconnector = &odev->connector;\n\tret = drm_connector_init(dev, connector, &ofdrm_connector_funcs,\n\t\t\t\t DRM_MODE_CONNECTOR_Unknown);\n\tif (ret)\n\t\treturn ERR_PTR(ret);\n\tdrm_connector_helper_add(connector, &ofdrm_connector_helper_funcs);\n\tdrm_connector_set_panel_orientation_with_quirk(connector,\n\t\t\t\t\t\t       DRM_MODE_PANEL_ORIENTATION_UNKNOWN,\n\t\t\t\t\t\t       width, height);\n\n\tret = drm_connector_attach_encoder(connector, encoder);\n\tif (ret)\n\t\treturn ERR_PTR(ret);\n\n\tdrm_mode_config_reset(dev);\n\n\treturn odev;\n}\n\n \n\nDEFINE_DRM_GEM_FOPS(ofdrm_fops);\n\nstatic struct drm_driver ofdrm_driver = {\n\tDRM_GEM_SHMEM_DRIVER_OPS,\n\t.name\t\t\t= DRIVER_NAME,\n\t.desc\t\t\t= DRIVER_DESC,\n\t.date\t\t\t= DRIVER_DATE,\n\t.major\t\t\t= DRIVER_MAJOR,\n\t.minor\t\t\t= DRIVER_MINOR,\n\t.driver_features\t= DRIVER_ATOMIC | DRIVER_GEM | DRIVER_MODESET,\n\t.fops\t\t\t= &ofdrm_fops,\n};\n\n \n\nstatic int ofdrm_probe(struct platform_device *pdev)\n{\n\tstruct ofdrm_device *odev;\n\tstruct drm_device *dev;\n\tunsigned int color_mode;\n\tint ret;\n\n\todev = ofdrm_device_create(&ofdrm_driver, pdev);\n\tif (IS_ERR(odev))\n\t\treturn PTR_ERR(odev);\n\tdev = &odev->dev;\n\n\tret = drm_dev_register(dev, 0);\n\tif (ret)\n\t\treturn ret;\n\n\tcolor_mode = drm_format_info_bpp(odev->format, 0);\n\tif (color_mode == 16)\n\t\tcolor_mode = odev->format->depth; \n\n\tdrm_fbdev_generic_setup(dev, color_mode);\n\n\treturn 0;\n}\n\nstatic void ofdrm_remove(struct platform_device *pdev)\n{\n\tstruct drm_device *dev = platform_get_drvdata(pdev);\n\n\tdrm_dev_unplug(dev);\n}\n\nstatic const struct of_device_id ofdrm_of_match_display[] = {\n\t{ .compatible = \"display\", },\n\t{ },\n};\nMODULE_DEVICE_TABLE(of, ofdrm_of_match_display);\n\nstatic struct platform_driver ofdrm_platform_driver = {\n\t.driver = {\n\t\t.name = \"of-display\",\n\t\t.of_match_table = ofdrm_of_match_display,\n\t},\n\t.probe = ofdrm_probe,\n\t.remove_new = ofdrm_remove,\n};\n\nmodule_platform_driver(ofdrm_platform_driver);\n\nMODULE_DESCRIPTION(DRIVER_DESC);\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}