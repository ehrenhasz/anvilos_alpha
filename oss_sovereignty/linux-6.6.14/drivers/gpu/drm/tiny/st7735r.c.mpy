{
  "module_name": "st7735r.c",
  "hash_id": "f2aad9c90907ecb40be71a95610479e1e0226c23bf67146e40a9e2f4296dde77",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/tiny/st7735r.c",
  "human_readable_source": "\n \n\n#include <linux/backlight.h>\n#include <linux/delay.h>\n#include <linux/dma-buf.h>\n#include <linux/gpio/consumer.h>\n#include <linux/module.h>\n#include <linux/property.h>\n#include <linux/spi/spi.h>\n#include <video/mipi_display.h>\n\n#include <drm/drm_atomic_helper.h>\n#include <drm/drm_drv.h>\n#include <drm/drm_fbdev_generic.h>\n#include <drm/drm_gem_atomic_helper.h>\n#include <drm/drm_gem_dma_helper.h>\n#include <drm/drm_managed.h>\n#include <drm/drm_mipi_dbi.h>\n\n#define ST7735R_FRMCTR1\t\t0xb1\n#define ST7735R_FRMCTR2\t\t0xb2\n#define ST7735R_FRMCTR3\t\t0xb3\n#define ST7735R_INVCTR\t\t0xb4\n#define ST7735R_PWCTR1\t\t0xc0\n#define ST7735R_PWCTR2\t\t0xc1\n#define ST7735R_PWCTR3\t\t0xc2\n#define ST7735R_PWCTR4\t\t0xc3\n#define ST7735R_PWCTR5\t\t0xc4\n#define ST7735R_VMCTR1\t\t0xc5\n#define ST7735R_GAMCTRP1\t0xe0\n#define ST7735R_GAMCTRN1\t0xe1\n\n#define ST7735R_MY\tBIT(7)\n#define ST7735R_MX\tBIT(6)\n#define ST7735R_MV\tBIT(5)\n#define ST7735R_RGB\tBIT(3)\n\nstruct st7735r_cfg {\n\tconst struct drm_display_mode mode;\n\tunsigned int left_offset;\n\tunsigned int top_offset;\n\tunsigned int write_only:1;\n\tunsigned int rgb:1;\t\t \n};\n\nstruct st7735r_priv {\n\tstruct mipi_dbi_dev dbidev;\t \n\tconst struct st7735r_cfg *cfg;\n};\n\nstatic void st7735r_pipe_enable(struct drm_simple_display_pipe *pipe,\n\t\t\t\tstruct drm_crtc_state *crtc_state,\n\t\t\t\tstruct drm_plane_state *plane_state)\n{\n\tstruct mipi_dbi_dev *dbidev = drm_to_mipi_dbi_dev(pipe->crtc.dev);\n\tstruct st7735r_priv *priv = container_of(dbidev, struct st7735r_priv,\n\t\t\t\t\t\t dbidev);\n\tstruct mipi_dbi *dbi = &dbidev->dbi;\n\tint ret, idx;\n\tu8 addr_mode;\n\n\tif (!drm_dev_enter(pipe->crtc.dev, &idx))\n\t\treturn;\n\n\tDRM_DEBUG_KMS(\"\\n\");\n\n\tret = mipi_dbi_poweron_reset(dbidev);\n\tif (ret)\n\t\tgoto out_exit;\n\n\tmsleep(150);\n\n\tmipi_dbi_command(dbi, MIPI_DCS_EXIT_SLEEP_MODE);\n\tmsleep(500);\n\n\tmipi_dbi_command(dbi, ST7735R_FRMCTR1, 0x01, 0x2c, 0x2d);\n\tmipi_dbi_command(dbi, ST7735R_FRMCTR2, 0x01, 0x2c, 0x2d);\n\tmipi_dbi_command(dbi, ST7735R_FRMCTR3, 0x01, 0x2c, 0x2d, 0x01, 0x2c,\n\t\t\t 0x2d);\n\tmipi_dbi_command(dbi, ST7735R_INVCTR, 0x07);\n\tmipi_dbi_command(dbi, ST7735R_PWCTR1, 0xa2, 0x02, 0x84);\n\tmipi_dbi_command(dbi, ST7735R_PWCTR2, 0xc5);\n\tmipi_dbi_command(dbi, ST7735R_PWCTR3, 0x0a, 0x00);\n\tmipi_dbi_command(dbi, ST7735R_PWCTR4, 0x8a, 0x2a);\n\tmipi_dbi_command(dbi, ST7735R_PWCTR5, 0x8a, 0xee);\n\tmipi_dbi_command(dbi, ST7735R_VMCTR1, 0x0e);\n\tmipi_dbi_command(dbi, MIPI_DCS_EXIT_INVERT_MODE);\n\tswitch (dbidev->rotation) {\n\tdefault:\n\t\taddr_mode = ST7735R_MX | ST7735R_MY;\n\t\tbreak;\n\tcase 90:\n\t\taddr_mode = ST7735R_MX | ST7735R_MV;\n\t\tbreak;\n\tcase 180:\n\t\taddr_mode = 0;\n\t\tbreak;\n\tcase 270:\n\t\taddr_mode = ST7735R_MY | ST7735R_MV;\n\t\tbreak;\n\t}\n\n\tif (priv->cfg->rgb)\n\t\taddr_mode |= ST7735R_RGB;\n\n\tmipi_dbi_command(dbi, MIPI_DCS_SET_ADDRESS_MODE, addr_mode);\n\tmipi_dbi_command(dbi, MIPI_DCS_SET_PIXEL_FORMAT,\n\t\t\t MIPI_DCS_PIXEL_FMT_16BIT);\n\tmipi_dbi_command(dbi, ST7735R_GAMCTRP1, 0x02, 0x1c, 0x07, 0x12, 0x37,\n\t\t\t 0x32, 0x29, 0x2d, 0x29, 0x25, 0x2b, 0x39, 0x00, 0x01,\n\t\t\t 0x03, 0x10);\n\tmipi_dbi_command(dbi, ST7735R_GAMCTRN1, 0x03, 0x1d, 0x07, 0x06, 0x2e,\n\t\t\t 0x2c, 0x29, 0x2d, 0x2e, 0x2e, 0x37, 0x3f, 0x00, 0x00,\n\t\t\t 0x02, 0x10);\n\tmipi_dbi_command(dbi, MIPI_DCS_SET_DISPLAY_ON);\n\n\tmsleep(100);\n\n\tmipi_dbi_command(dbi, MIPI_DCS_ENTER_NORMAL_MODE);\n\n\tmsleep(20);\n\n\tmipi_dbi_enable_flush(dbidev, crtc_state, plane_state);\nout_exit:\n\tdrm_dev_exit(idx);\n}\n\nstatic const struct drm_simple_display_pipe_funcs st7735r_pipe_funcs = {\n\tDRM_MIPI_DBI_SIMPLE_DISPLAY_PIPE_FUNCS(st7735r_pipe_enable),\n};\n\nstatic const struct st7735r_cfg jd_t18003_t01_cfg = {\n\t.mode\t\t= { DRM_SIMPLE_MODE(128, 160, 28, 35) },\n\t \n\t.write_only\t= true,\n};\n\nstatic const struct st7735r_cfg rh128128t_cfg = {\n\t.mode\t\t= { DRM_SIMPLE_MODE(128, 128, 25, 26) },\n\t.left_offset\t= 2,\n\t.top_offset\t= 3,\n\t.rgb\t\t= true,\n};\n\nDEFINE_DRM_GEM_DMA_FOPS(st7735r_fops);\n\nstatic const struct drm_driver st7735r_driver = {\n\t.driver_features\t= DRIVER_GEM | DRIVER_MODESET | DRIVER_ATOMIC,\n\t.fops\t\t\t= &st7735r_fops,\n\tDRM_GEM_DMA_DRIVER_OPS_VMAP,\n\t.debugfs_init\t\t= mipi_dbi_debugfs_init,\n\t.name\t\t\t= \"st7735r\",\n\t.desc\t\t\t= \"Sitronix ST7735R\",\n\t.date\t\t\t= \"20171128\",\n\t.major\t\t\t= 1,\n\t.minor\t\t\t= 0,\n};\n\nstatic const struct of_device_id st7735r_of_match[] = {\n\t{ .compatible = \"jianda,jd-t18003-t01\", .data = &jd_t18003_t01_cfg },\n\t{ .compatible = \"okaya,rh128128t\", .data = &rh128128t_cfg },\n\t{ },\n};\nMODULE_DEVICE_TABLE(of, st7735r_of_match);\n\nstatic const struct spi_device_id st7735r_id[] = {\n\t{ \"jd-t18003-t01\", (uintptr_t)&jd_t18003_t01_cfg },\n\t{ \"rh128128t\", (uintptr_t)&rh128128t_cfg },\n\t{ },\n};\nMODULE_DEVICE_TABLE(spi, st7735r_id);\n\nstatic int st7735r_probe(struct spi_device *spi)\n{\n\tstruct device *dev = &spi->dev;\n\tconst struct st7735r_cfg *cfg;\n\tstruct mipi_dbi_dev *dbidev;\n\tstruct st7735r_priv *priv;\n\tstruct drm_device *drm;\n\tstruct mipi_dbi *dbi;\n\tstruct gpio_desc *dc;\n\tu32 rotation = 0;\n\tint ret;\n\n\tcfg = device_get_match_data(&spi->dev);\n\tif (!cfg)\n\t\tcfg = (void *)spi_get_device_id(spi)->driver_data;\n\n\tpriv = devm_drm_dev_alloc(dev, &st7735r_driver,\n\t\t\t\t  struct st7735r_priv, dbidev.drm);\n\tif (IS_ERR(priv))\n\t\treturn PTR_ERR(priv);\n\n\tdbidev = &priv->dbidev;\n\tpriv->cfg = cfg;\n\n\tdbi = &dbidev->dbi;\n\tdrm = &dbidev->drm;\n\n\tdbi->reset = devm_gpiod_get(dev, \"reset\", GPIOD_OUT_HIGH);\n\tif (IS_ERR(dbi->reset))\n\t\treturn dev_err_probe(dev, PTR_ERR(dbi->reset), \"Failed to get GPIO 'reset'\\n\");\n\n\tdc = devm_gpiod_get(dev, \"dc\", GPIOD_OUT_LOW);\n\tif (IS_ERR(dc))\n\t\treturn dev_err_probe(dev, PTR_ERR(dc), \"Failed to get GPIO 'dc'\\n\");\n\n\tdbidev->backlight = devm_of_find_backlight(dev);\n\tif (IS_ERR(dbidev->backlight))\n\t\treturn PTR_ERR(dbidev->backlight);\n\n\tdevice_property_read_u32(dev, \"rotation\", &rotation);\n\n\tret = mipi_dbi_spi_init(spi, dbi, dc);\n\tif (ret)\n\t\treturn ret;\n\n\tif (cfg->write_only)\n\t\tdbi->read_commands = NULL;\n\n\tdbidev->left_offset = cfg->left_offset;\n\tdbidev->top_offset = cfg->top_offset;\n\n\tret = mipi_dbi_dev_init(dbidev, &st7735r_pipe_funcs, &cfg->mode,\n\t\t\t\trotation);\n\tif (ret)\n\t\treturn ret;\n\n\tdrm_mode_config_reset(drm);\n\n\tret = drm_dev_register(drm, 0);\n\tif (ret)\n\t\treturn ret;\n\n\tspi_set_drvdata(spi, drm);\n\n\tdrm_fbdev_generic_setup(drm, 0);\n\n\treturn 0;\n}\n\nstatic void st7735r_remove(struct spi_device *spi)\n{\n\tstruct drm_device *drm = spi_get_drvdata(spi);\n\n\tdrm_dev_unplug(drm);\n\tdrm_atomic_helper_shutdown(drm);\n}\n\nstatic void st7735r_shutdown(struct spi_device *spi)\n{\n\tdrm_atomic_helper_shutdown(spi_get_drvdata(spi));\n}\n\nstatic struct spi_driver st7735r_spi_driver = {\n\t.driver = {\n\t\t.name = \"st7735r\",\n\t\t.of_match_table = st7735r_of_match,\n\t},\n\t.id_table = st7735r_id,\n\t.probe = st7735r_probe,\n\t.remove = st7735r_remove,\n\t.shutdown = st7735r_shutdown,\n};\nmodule_spi_driver(st7735r_spi_driver);\n\nMODULE_DESCRIPTION(\"Sitronix ST7735R DRM driver\");\nMODULE_AUTHOR(\"David Lechner <david@lechnology.com>\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}