{
  "module_name": "cirrus.c",
  "hash_id": "9328117220926f068295a1eb09908c1c995f6ef5f7e5ce7482bd3b8b33bc2fdb",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/tiny/cirrus.c",
  "human_readable_source": " \n \n\n#include <linux/iosys-map.h>\n#include <linux/module.h>\n#include <linux/pci.h>\n\n#include <video/cirrus.h>\n#include <video/vga.h>\n\n#include <drm/drm_aperture.h>\n#include <drm/drm_atomic.h>\n#include <drm/drm_atomic_helper.h>\n#include <drm/drm_atomic_state_helper.h>\n#include <drm/drm_connector.h>\n#include <drm/drm_damage_helper.h>\n#include <drm/drm_drv.h>\n#include <drm/drm_edid.h>\n#include <drm/drm_fbdev_generic.h>\n#include <drm/drm_file.h>\n#include <drm/drm_format_helper.h>\n#include <drm/drm_fourcc.h>\n#include <drm/drm_framebuffer.h>\n#include <drm/drm_gem_atomic_helper.h>\n#include <drm/drm_gem_framebuffer_helper.h>\n#include <drm/drm_gem_shmem_helper.h>\n#include <drm/drm_ioctl.h>\n#include <drm/drm_managed.h>\n#include <drm/drm_modeset_helper_vtables.h>\n#include <drm/drm_module.h>\n#include <drm/drm_probe_helper.h>\n\n#define DRIVER_NAME \"cirrus\"\n#define DRIVER_DESC \"qemu cirrus vga\"\n#define DRIVER_DATE \"2019\"\n#define DRIVER_MAJOR 2\n#define DRIVER_MINOR 0\n\n#define CIRRUS_MAX_PITCH (0x1FF << 3)       \n#define CIRRUS_VRAM_SIZE (4 * 1024 * 1024)  \n\nstruct cirrus_device {\n\tstruct drm_device\t       dev;\n\n\t \n\tstruct drm_plane\t       primary_plane;\n\tstruct drm_crtc\t\t       crtc;\n\tstruct drm_encoder\t       encoder;\n\tstruct drm_connector\t       connector;\n\n\t \n\tvoid __iomem\t\t       *vram;\n\tvoid __iomem\t\t       *mmio;\n};\n\n#define to_cirrus(_dev) container_of(_dev, struct cirrus_device, dev)\n\nstruct cirrus_primary_plane_state {\n\tstruct drm_shadow_plane_state base;\n\n\t \n\tconst struct drm_format_info   *format;\n\tunsigned int\t\t       pitch;\n};\n\nstatic inline struct cirrus_primary_plane_state *\nto_cirrus_primary_plane_state(struct drm_plane_state *plane_state)\n{\n\treturn container_of(plane_state, struct cirrus_primary_plane_state, base.base);\n};\n\n \n \n\n#define SEQ_INDEX 4\n#define SEQ_DATA 5\n\nstatic u8 rreg_seq(struct cirrus_device *cirrus, u8 reg)\n{\n\tiowrite8(reg, cirrus->mmio + SEQ_INDEX);\n\treturn ioread8(cirrus->mmio + SEQ_DATA);\n}\n\nstatic void wreg_seq(struct cirrus_device *cirrus, u8 reg, u8 val)\n{\n\tiowrite8(reg, cirrus->mmio + SEQ_INDEX);\n\tiowrite8(val, cirrus->mmio + SEQ_DATA);\n}\n\n#define CRT_INDEX 0x14\n#define CRT_DATA 0x15\n\nstatic u8 rreg_crt(struct cirrus_device *cirrus, u8 reg)\n{\n\tiowrite8(reg, cirrus->mmio + CRT_INDEX);\n\treturn ioread8(cirrus->mmio + CRT_DATA);\n}\n\nstatic void wreg_crt(struct cirrus_device *cirrus, u8 reg, u8 val)\n{\n\tiowrite8(reg, cirrus->mmio + CRT_INDEX);\n\tiowrite8(val, cirrus->mmio + CRT_DATA);\n}\n\n#define GFX_INDEX 0xe\n#define GFX_DATA 0xf\n\nstatic void wreg_gfx(struct cirrus_device *cirrus, u8 reg, u8 val)\n{\n\tiowrite8(reg, cirrus->mmio + GFX_INDEX);\n\tiowrite8(val, cirrus->mmio + GFX_DATA);\n}\n\n#define VGA_DAC_MASK  0x06\n\nstatic void wreg_hdr(struct cirrus_device *cirrus, u8 val)\n{\n\tioread8(cirrus->mmio + VGA_DAC_MASK);\n\tioread8(cirrus->mmio + VGA_DAC_MASK);\n\tioread8(cirrus->mmio + VGA_DAC_MASK);\n\tioread8(cirrus->mmio + VGA_DAC_MASK);\n\tiowrite8(val, cirrus->mmio + VGA_DAC_MASK);\n}\n\nstatic const struct drm_format_info *cirrus_convert_to(struct drm_framebuffer *fb)\n{\n\tif (fb->format->format == DRM_FORMAT_XRGB8888 && fb->pitches[0] > CIRRUS_MAX_PITCH) {\n\t\tif (fb->width * 3 <= CIRRUS_MAX_PITCH)\n\t\t\t \n\t\t\treturn drm_format_info(DRM_FORMAT_RGB888);\n\t\telse\n\t\t\t \n\t\t\treturn drm_format_info(DRM_FORMAT_RGB565);\n\t}\n\treturn NULL;\n}\n\nstatic const struct drm_format_info *cirrus_format(struct drm_framebuffer *fb)\n{\n\tconst struct drm_format_info *format = cirrus_convert_to(fb);\n\n\tif (format)\n\t\treturn format;\n\treturn fb->format;\n}\n\nstatic int cirrus_pitch(struct drm_framebuffer *fb)\n{\n\tconst struct drm_format_info *format = cirrus_convert_to(fb);\n\n\tif (format)\n\t\treturn drm_format_info_min_pitch(format, 0, fb->width);\n\treturn fb->pitches[0];\n}\n\nstatic void cirrus_set_start_address(struct cirrus_device *cirrus, u32 offset)\n{\n\tu32 addr;\n\tu8 tmp;\n\n\taddr = offset >> 2;\n\twreg_crt(cirrus, 0x0c, (u8)((addr >> 8) & 0xff));\n\twreg_crt(cirrus, 0x0d, (u8)(addr & 0xff));\n\n\ttmp = rreg_crt(cirrus, 0x1b);\n\ttmp &= 0xf2;\n\ttmp |= (addr >> 16) & 0x01;\n\ttmp |= (addr >> 15) & 0x0c;\n\twreg_crt(cirrus, 0x1b, tmp);\n\n\ttmp = rreg_crt(cirrus, 0x1d);\n\ttmp &= 0x7f;\n\ttmp |= (addr >> 12) & 0x80;\n\twreg_crt(cirrus, 0x1d, tmp);\n}\n\nstatic void cirrus_mode_set(struct cirrus_device *cirrus,\n\t\t\t    struct drm_display_mode *mode)\n{\n\tint hsyncstart, hsyncend, htotal, hdispend;\n\tint vtotal, vdispend;\n\tint tmp;\n\n\thtotal = mode->htotal / 8;\n\thsyncend = mode->hsync_end / 8;\n\thsyncstart = mode->hsync_start / 8;\n\thdispend = mode->hdisplay / 8;\n\n\tvtotal = mode->vtotal;\n\tvdispend = mode->vdisplay;\n\n\tvdispend -= 1;\n\tvtotal -= 2;\n\n\thtotal -= 5;\n\thdispend -= 1;\n\thsyncstart += 1;\n\thsyncend += 1;\n\n\twreg_crt(cirrus, VGA_CRTC_V_SYNC_END, 0x20);\n\twreg_crt(cirrus, VGA_CRTC_H_TOTAL, htotal);\n\twreg_crt(cirrus, VGA_CRTC_H_DISP, hdispend);\n\twreg_crt(cirrus, VGA_CRTC_H_SYNC_START, hsyncstart);\n\twreg_crt(cirrus, VGA_CRTC_H_SYNC_END, hsyncend);\n\twreg_crt(cirrus, VGA_CRTC_V_TOTAL, vtotal & 0xff);\n\twreg_crt(cirrus, VGA_CRTC_V_DISP_END, vdispend & 0xff);\n\n\ttmp = 0x40;\n\tif ((vdispend + 1) & 512)\n\t\ttmp |= 0x20;\n\twreg_crt(cirrus, VGA_CRTC_MAX_SCAN, tmp);\n\n\t \n\ttmp = 0x10;\n\tif (vtotal & 0x100)\n\t\ttmp |= 0x01;\n\tif (vdispend & 0x100)\n\t\ttmp |= 0x02;\n\tif ((vdispend + 1) & 0x100)\n\t\ttmp |= 0x08;\n\tif (vtotal & 0x200)\n\t\ttmp |= 0x20;\n\tif (vdispend & 0x200)\n\t\ttmp |= 0x40;\n\twreg_crt(cirrus, VGA_CRTC_OVERFLOW, tmp);\n\n\ttmp = 0;\n\n\t \n\n\tif ((htotal + 5) & 0x40)\n\t\ttmp |= 0x10;\n\tif ((htotal + 5) & 0x80)\n\t\ttmp |= 0x20;\n\tif (vtotal & 0x100)\n\t\ttmp |= 0x40;\n\tif (vtotal & 0x200)\n\t\ttmp |= 0x80;\n\n\twreg_crt(cirrus, CL_CRT1A, tmp);\n\n\t \n\twreg_crt(cirrus, VGA_CRTC_MODE, 0x03);\n}\n\nstatic void cirrus_format_set(struct cirrus_device *cirrus,\n\t\t\t      const struct drm_format_info *format)\n{\n\tu8 sr07, hdr;\n\n\tsr07 = rreg_seq(cirrus, 0x07);\n\tsr07 &= 0xe0;\n\n\tswitch (format->format) {\n\tcase DRM_FORMAT_C8:\n\t\tsr07 |= 0x11;\n\t\thdr = 0x00;\n\t\tbreak;\n\tcase DRM_FORMAT_RGB565:\n\t\tsr07 |= 0x17;\n\t\thdr = 0xc1;\n\t\tbreak;\n\tcase DRM_FORMAT_RGB888:\n\t\tsr07 |= 0x15;\n\t\thdr = 0xc5;\n\t\tbreak;\n\tcase DRM_FORMAT_XRGB8888:\n\t\tsr07 |= 0x19;\n\t\thdr = 0xc5;\n\t\tbreak;\n\tdefault:\n\t\treturn;\n\t}\n\n\twreg_seq(cirrus, 0x7, sr07);\n\n\t \n\twreg_gfx(cirrus, VGA_GFX_MODE, 0x40);\n\n\t \n\twreg_gfx(cirrus, VGA_GFX_MISC, 0x01);\n\n\twreg_hdr(cirrus, hdr);\n}\n\nstatic void cirrus_pitch_set(struct cirrus_device *cirrus, unsigned int pitch)\n{\n\tu8 cr13, cr1b;\n\n\t \n\tcr13 = pitch / 8;\n\twreg_crt(cirrus, VGA_CRTC_OFFSET, cr13);\n\n\t \n\tcr1b = 0x22;\n\tcr1b |= (pitch >> 7) & 0x10;\n\tcr1b |= (pitch >> 6) & 0x40;\n\twreg_crt(cirrus, 0x1b, cr1b);\n\n\tcirrus_set_start_address(cirrus, 0);\n}\n\n \n \n\nstatic const uint32_t cirrus_primary_plane_formats[] = {\n\tDRM_FORMAT_RGB565,\n\tDRM_FORMAT_RGB888,\n\tDRM_FORMAT_XRGB8888,\n};\n\nstatic const uint64_t cirrus_primary_plane_format_modifiers[] = {\n\tDRM_FORMAT_MOD_LINEAR,\n\tDRM_FORMAT_MOD_INVALID\n};\n\nstatic int cirrus_primary_plane_helper_atomic_check(struct drm_plane *plane,\n\t\t\t\t\t\t    struct drm_atomic_state *state)\n{\n\tstruct drm_plane_state *new_plane_state = drm_atomic_get_new_plane_state(state, plane);\n\tstruct cirrus_primary_plane_state *new_primary_plane_state =\n\t\tto_cirrus_primary_plane_state(new_plane_state);\n\tstruct drm_framebuffer *fb = new_plane_state->fb;\n\tstruct drm_crtc *new_crtc = new_plane_state->crtc;\n\tstruct drm_crtc_state *new_crtc_state = NULL;\n\tint ret;\n\tunsigned int pitch;\n\n\tif (new_crtc)\n\t\tnew_crtc_state = drm_atomic_get_new_crtc_state(state, new_crtc);\n\n\tret = drm_atomic_helper_check_plane_state(new_plane_state, new_crtc_state,\n\t\t\t\t\t\t  DRM_PLANE_NO_SCALING,\n\t\t\t\t\t\t  DRM_PLANE_NO_SCALING,\n\t\t\t\t\t\t  false, false);\n\tif (ret)\n\t\treturn ret;\n\telse if (!new_plane_state->visible)\n\t\treturn 0;\n\n\tpitch = cirrus_pitch(fb);\n\n\t \n\tif (pitch > CIRRUS_MAX_PITCH)\n\t\treturn -EINVAL;\n\telse if (pitch * fb->height > CIRRUS_VRAM_SIZE)\n\t\treturn -EINVAL;\n\n\tnew_primary_plane_state->format = cirrus_format(fb);\n\tnew_primary_plane_state->pitch = pitch;\n\n\treturn 0;\n}\n\nstatic void cirrus_primary_plane_helper_atomic_update(struct drm_plane *plane,\n\t\t\t\t\t\t      struct drm_atomic_state *state)\n{\n\tstruct cirrus_device *cirrus = to_cirrus(plane->dev);\n\tstruct drm_plane_state *plane_state = drm_atomic_get_new_plane_state(state, plane);\n\tstruct cirrus_primary_plane_state *primary_plane_state =\n\t\tto_cirrus_primary_plane_state(plane_state);\n\tstruct drm_shadow_plane_state *shadow_plane_state = to_drm_shadow_plane_state(plane_state);\n\tstruct drm_framebuffer *fb = plane_state->fb;\n\tconst struct drm_format_info *format = primary_plane_state->format;\n\tunsigned int pitch = primary_plane_state->pitch;\n\tstruct drm_plane_state *old_plane_state = drm_atomic_get_old_plane_state(state, plane);\n\tstruct cirrus_primary_plane_state *old_primary_plane_state =\n\t\tto_cirrus_primary_plane_state(old_plane_state);\n\tstruct iosys_map vaddr = IOSYS_MAP_INIT_VADDR_IOMEM(cirrus->vram);\n\tstruct drm_atomic_helper_damage_iter iter;\n\tstruct drm_rect damage;\n\tint idx;\n\n\tif (!fb)\n\t\treturn;\n\n\tif (!drm_dev_enter(&cirrus->dev, &idx))\n\t\treturn;\n\n\tif (old_primary_plane_state->format != format)\n\t\tcirrus_format_set(cirrus, format);\n\tif (old_primary_plane_state->pitch != pitch)\n\t\tcirrus_pitch_set(cirrus, pitch);\n\n\tdrm_atomic_helper_damage_iter_init(&iter, old_plane_state, plane_state);\n\tdrm_atomic_for_each_plane_damage(&iter, &damage) {\n\t\tunsigned int offset = drm_fb_clip_offset(pitch, format, &damage);\n\t\tstruct iosys_map dst = IOSYS_MAP_INIT_OFFSET(&vaddr, offset);\n\n\t\tdrm_fb_blit(&dst, &pitch, format->format, shadow_plane_state->data, fb, &damage);\n\t}\n\n\tdrm_dev_exit(idx);\n}\n\nstatic const struct drm_plane_helper_funcs cirrus_primary_plane_helper_funcs = {\n\tDRM_GEM_SHADOW_PLANE_HELPER_FUNCS,\n\t.atomic_check = cirrus_primary_plane_helper_atomic_check,\n\t.atomic_update = cirrus_primary_plane_helper_atomic_update,\n};\n\nstatic struct drm_plane_state *\ncirrus_primary_plane_atomic_duplicate_state(struct drm_plane *plane)\n{\n\tstruct drm_plane_state *plane_state = plane->state;\n\tstruct cirrus_primary_plane_state *primary_plane_state =\n\t\tto_cirrus_primary_plane_state(plane_state);\n\tstruct cirrus_primary_plane_state *new_primary_plane_state;\n\tstruct drm_shadow_plane_state *new_shadow_plane_state;\n\n\tif (!plane_state)\n\t\treturn NULL;\n\n\tnew_primary_plane_state = kzalloc(sizeof(*new_primary_plane_state), GFP_KERNEL);\n\tif (!new_primary_plane_state)\n\t\treturn NULL;\n\tnew_shadow_plane_state = &new_primary_plane_state->base;\n\n\t__drm_gem_duplicate_shadow_plane_state(plane, new_shadow_plane_state);\n\tnew_primary_plane_state->format = primary_plane_state->format;\n\tnew_primary_plane_state->pitch = primary_plane_state->pitch;\n\n\treturn &new_shadow_plane_state->base;\n}\n\nstatic void cirrus_primary_plane_atomic_destroy_state(struct drm_plane *plane,\n\t\t\t\t\t\t      struct drm_plane_state *plane_state)\n{\n\tstruct cirrus_primary_plane_state *primary_plane_state =\n\t\tto_cirrus_primary_plane_state(plane_state);\n\n\t__drm_gem_destroy_shadow_plane_state(&primary_plane_state->base);\n\tkfree(primary_plane_state);\n}\n\nstatic void cirrus_reset_primary_plane(struct drm_plane *plane)\n{\n\tstruct cirrus_primary_plane_state *primary_plane_state;\n\n\tif (plane->state) {\n\t\tcirrus_primary_plane_atomic_destroy_state(plane, plane->state);\n\t\tplane->state = NULL;  \n\t}\n\n\tprimary_plane_state = kzalloc(sizeof(*primary_plane_state), GFP_KERNEL);\n\tif (!primary_plane_state)\n\t\treturn;\n\t__drm_gem_reset_shadow_plane(plane, &primary_plane_state->base);\n}\n\nstatic const struct drm_plane_funcs cirrus_primary_plane_funcs = {\n\t.update_plane = drm_atomic_helper_update_plane,\n\t.disable_plane = drm_atomic_helper_disable_plane,\n\t.destroy = drm_plane_cleanup,\n\t.reset = cirrus_reset_primary_plane,\n\t.atomic_duplicate_state = cirrus_primary_plane_atomic_duplicate_state,\n\t.atomic_destroy_state = cirrus_primary_plane_atomic_destroy_state,\n};\n\nstatic int cirrus_crtc_helper_atomic_check(struct drm_crtc *crtc, struct drm_atomic_state *state)\n{\n\tstruct drm_crtc_state *crtc_state = drm_atomic_get_new_crtc_state(state, crtc);\n\tint ret;\n\n\tif (!crtc_state->enable)\n\t\treturn 0;\n\n\tret = drm_atomic_helper_check_crtc_primary_plane(crtc_state);\n\tif (ret)\n\t\treturn ret;\n\n\treturn 0;\n}\n\nstatic void cirrus_crtc_helper_atomic_enable(struct drm_crtc *crtc,\n\t\t\t\t\t     struct drm_atomic_state *state)\n{\n\tstruct cirrus_device *cirrus = to_cirrus(crtc->dev);\n\tstruct drm_crtc_state *crtc_state = drm_atomic_get_new_crtc_state(state, crtc);\n\tint idx;\n\n\tif (!drm_dev_enter(&cirrus->dev, &idx))\n\t\treturn;\n\n\tcirrus_mode_set(cirrus, &crtc_state->mode);\n\n\t \n\toutb(VGA_AR_ENABLE_DISPLAY, VGA_ATT_W);\n\n\tdrm_dev_exit(idx);\n}\n\nstatic const struct drm_crtc_helper_funcs cirrus_crtc_helper_funcs = {\n\t.atomic_check = cirrus_crtc_helper_atomic_check,\n\t.atomic_enable = cirrus_crtc_helper_atomic_enable,\n};\n\nstatic const struct drm_crtc_funcs cirrus_crtc_funcs = {\n\t.reset = drm_atomic_helper_crtc_reset,\n\t.destroy = drm_crtc_cleanup,\n\t.set_config = drm_atomic_helper_set_config,\n\t.page_flip = drm_atomic_helper_page_flip,\n\t.atomic_duplicate_state = drm_atomic_helper_crtc_duplicate_state,\n\t.atomic_destroy_state = drm_atomic_helper_crtc_destroy_state,\n};\n\nstatic const struct drm_encoder_funcs cirrus_encoder_funcs = {\n\t.destroy = drm_encoder_cleanup,\n};\n\nstatic int cirrus_connector_helper_get_modes(struct drm_connector *connector)\n{\n\tint count;\n\n\tcount = drm_add_modes_noedid(connector,\n\t\t\t\t     connector->dev->mode_config.max_width,\n\t\t\t\t     connector->dev->mode_config.max_height);\n\tdrm_set_preferred_mode(connector, 1024, 768);\n\treturn count;\n}\n\nstatic const struct drm_connector_helper_funcs cirrus_connector_helper_funcs = {\n\t.get_modes = cirrus_connector_helper_get_modes,\n};\n\nstatic const struct drm_connector_funcs cirrus_connector_funcs = {\n\t.fill_modes = drm_helper_probe_single_connector_modes,\n\t.destroy = drm_connector_cleanup,\n\t.reset = drm_atomic_helper_connector_reset,\n\t.atomic_duplicate_state = drm_atomic_helper_connector_duplicate_state,\n\t.atomic_destroy_state = drm_atomic_helper_connector_destroy_state,\n};\n\nstatic int cirrus_pipe_init(struct cirrus_device *cirrus)\n{\n\tstruct drm_device *dev = &cirrus->dev;\n\tstruct drm_plane *primary_plane;\n\tstruct drm_crtc *crtc;\n\tstruct drm_encoder *encoder;\n\tstruct drm_connector *connector;\n\tint ret;\n\n\tprimary_plane = &cirrus->primary_plane;\n\tret = drm_universal_plane_init(dev, primary_plane, 0,\n\t\t\t\t       &cirrus_primary_plane_funcs,\n\t\t\t\t       cirrus_primary_plane_formats,\n\t\t\t\t       ARRAY_SIZE(cirrus_primary_plane_formats),\n\t\t\t\t       cirrus_primary_plane_format_modifiers,\n\t\t\t\t       DRM_PLANE_TYPE_PRIMARY, NULL);\n\tif (ret)\n\t\treturn ret;\n\tdrm_plane_helper_add(primary_plane, &cirrus_primary_plane_helper_funcs);\n\tdrm_plane_enable_fb_damage_clips(primary_plane);\n\n\tcrtc = &cirrus->crtc;\n\tret = drm_crtc_init_with_planes(dev, crtc, primary_plane, NULL,\n\t\t\t\t\t&cirrus_crtc_funcs, NULL);\n\tif (ret)\n\t\treturn ret;\n\tdrm_crtc_helper_add(crtc, &cirrus_crtc_helper_funcs);\n\n\tencoder = &cirrus->encoder;\n\tret = drm_encoder_init(dev, encoder, &cirrus_encoder_funcs,\n\t\t\t       DRM_MODE_ENCODER_DAC, NULL);\n\tif (ret)\n\t\treturn ret;\n\tencoder->possible_crtcs = drm_crtc_mask(crtc);\n\n\tconnector = &cirrus->connector;\n\tret = drm_connector_init(dev, connector, &cirrus_connector_funcs,\n\t\t\t\t DRM_MODE_CONNECTOR_VGA);\n\tif (ret)\n\t\treturn ret;\n\tdrm_connector_helper_add(connector, &cirrus_connector_helper_funcs);\n\n\tret = drm_connector_attach_encoder(connector, encoder);\n\tif (ret)\n\t\treturn ret;\n\n\treturn 0;\n}\n\n \n \n\nstatic enum drm_mode_status cirrus_mode_config_mode_valid(struct drm_device *dev,\n\t\t\t\t\t\t\t  const struct drm_display_mode *mode)\n{\n\tconst struct drm_format_info *format = drm_format_info(DRM_FORMAT_XRGB8888);\n\tuint64_t pitch = drm_format_info_min_pitch(format, 0, mode->hdisplay);\n\n\tif (pitch * mode->vdisplay > CIRRUS_VRAM_SIZE)\n\t\treturn MODE_MEM;\n\n\treturn MODE_OK;\n}\n\nstatic const struct drm_mode_config_funcs cirrus_mode_config_funcs = {\n\t.fb_create = drm_gem_fb_create_with_dirty,\n\t.mode_valid = cirrus_mode_config_mode_valid,\n\t.atomic_check = drm_atomic_helper_check,\n\t.atomic_commit = drm_atomic_helper_commit,\n};\n\nstatic int cirrus_mode_config_init(struct cirrus_device *cirrus)\n{\n\tstruct drm_device *dev = &cirrus->dev;\n\tint ret;\n\n\tret = drmm_mode_config_init(dev);\n\tif (ret)\n\t\treturn ret;\n\n\tdev->mode_config.min_width = 0;\n\tdev->mode_config.min_height = 0;\n\tdev->mode_config.max_width = CIRRUS_MAX_PITCH / 2;\n\tdev->mode_config.max_height = 1024;\n\tdev->mode_config.preferred_depth = 16;\n\tdev->mode_config.prefer_shadow = 0;\n\tdev->mode_config.funcs = &cirrus_mode_config_funcs;\n\n\treturn 0;\n}\n\n \n\nDEFINE_DRM_GEM_FOPS(cirrus_fops);\n\nstatic const struct drm_driver cirrus_driver = {\n\t.driver_features = DRIVER_MODESET | DRIVER_GEM | DRIVER_ATOMIC,\n\n\t.name\t\t = DRIVER_NAME,\n\t.desc\t\t = DRIVER_DESC,\n\t.date\t\t = DRIVER_DATE,\n\t.major\t\t = DRIVER_MAJOR,\n\t.minor\t\t = DRIVER_MINOR,\n\n\t.fops\t\t = &cirrus_fops,\n\tDRM_GEM_SHMEM_DRIVER_OPS,\n};\n\nstatic int cirrus_pci_probe(struct pci_dev *pdev,\n\t\t\t    const struct pci_device_id *ent)\n{\n\tstruct drm_device *dev;\n\tstruct cirrus_device *cirrus;\n\tint ret;\n\n\tret = drm_aperture_remove_conflicting_pci_framebuffers(pdev, &cirrus_driver);\n\tif (ret)\n\t\treturn ret;\n\n\tret = pcim_enable_device(pdev);\n\tif (ret)\n\t\treturn ret;\n\n\tret = pci_request_regions(pdev, DRIVER_NAME);\n\tif (ret)\n\t\treturn ret;\n\n\tret = -ENOMEM;\n\tcirrus = devm_drm_dev_alloc(&pdev->dev, &cirrus_driver,\n\t\t\t\t    struct cirrus_device, dev);\n\tif (IS_ERR(cirrus))\n\t\treturn PTR_ERR(cirrus);\n\n\tdev = &cirrus->dev;\n\n\tcirrus->vram = devm_ioremap(&pdev->dev, pci_resource_start(pdev, 0),\n\t\t\t\t    pci_resource_len(pdev, 0));\n\tif (cirrus->vram == NULL)\n\t\treturn -ENOMEM;\n\n\tcirrus->mmio = devm_ioremap(&pdev->dev, pci_resource_start(pdev, 1),\n\t\t\t\t    pci_resource_len(pdev, 1));\n\tif (cirrus->mmio == NULL)\n\t\treturn -ENOMEM;\n\n\tret = cirrus_mode_config_init(cirrus);\n\tif (ret)\n\t\treturn ret;\n\n\tret = cirrus_pipe_init(cirrus);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tdrm_mode_config_reset(dev);\n\n\tpci_set_drvdata(pdev, dev);\n\tret = drm_dev_register(dev, 0);\n\tif (ret)\n\t\treturn ret;\n\n\tdrm_fbdev_generic_setup(dev, 16);\n\treturn 0;\n}\n\nstatic void cirrus_pci_remove(struct pci_dev *pdev)\n{\n\tstruct drm_device *dev = pci_get_drvdata(pdev);\n\n\tdrm_dev_unplug(dev);\n\tdrm_atomic_helper_shutdown(dev);\n}\n\nstatic const struct pci_device_id pciidlist[] = {\n\t{\n\t\t.vendor    = PCI_VENDOR_ID_CIRRUS,\n\t\t.device    = PCI_DEVICE_ID_CIRRUS_5446,\n\t\t \n\t\t.subvendor = PCI_SUBVENDOR_ID_REDHAT_QUMRANET,\n\t\t.subdevice = PCI_SUBDEVICE_ID_QEMU,\n\t}, {\n\t\t.vendor    = PCI_VENDOR_ID_CIRRUS,\n\t\t.device    = PCI_DEVICE_ID_CIRRUS_5446,\n\t\t.subvendor = PCI_VENDOR_ID_XEN,\n\t\t.subdevice = 0x0001,\n\t},\n\t{   }\n};\n\nstatic struct pci_driver cirrus_pci_driver = {\n\t.name = DRIVER_NAME,\n\t.id_table = pciidlist,\n\t.probe = cirrus_pci_probe,\n\t.remove = cirrus_pci_remove,\n};\n\ndrm_module_pci_driver(cirrus_pci_driver)\n\nMODULE_DEVICE_TABLE(pci, pciidlist);\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}