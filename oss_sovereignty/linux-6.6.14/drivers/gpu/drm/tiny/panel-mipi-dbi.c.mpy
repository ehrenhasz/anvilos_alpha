{
  "module_name": "panel-mipi-dbi.c",
  "hash_id": "730371462b33384841f7a2957c05f96711fecfff4a6b6549e0ac84d9ba50b4b7",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/tiny/panel-mipi-dbi.c",
  "human_readable_source": "\n \n\n#include <linux/backlight.h>\n#include <linux/delay.h>\n#include <linux/firmware.h>\n#include <linux/gpio/consumer.h>\n#include <linux/module.h>\n#include <linux/property.h>\n#include <linux/regulator/consumer.h>\n#include <linux/spi/spi.h>\n\n#include <drm/drm_atomic_helper.h>\n#include <drm/drm_drv.h>\n#include <drm/drm_fbdev_generic.h>\n#include <drm/drm_gem_atomic_helper.h>\n#include <drm/drm_gem_dma_helper.h>\n#include <drm/drm_managed.h>\n#include <drm/drm_mipi_dbi.h>\n#include <drm/drm_modes.h>\n#include <drm/drm_modeset_helper.h>\n\n#include <video/mipi_display.h>\n\nstatic const u8 panel_mipi_dbi_magic[15] = { 'M', 'I', 'P', 'I', ' ', 'D', 'B', 'I',\n\t\t\t\t\t     0, 0, 0, 0, 0, 0, 0 };\n\n \nstruct panel_mipi_dbi_config {\n\t \n\tu8 magic[15];\n\n\t \n\tu8 file_format_version;\n\n\t \n\tu8 commands[];\n};\n\nstruct panel_mipi_dbi_commands {\n\tconst u8 *buf;\n\tsize_t len;\n};\n\nstatic struct panel_mipi_dbi_commands *\npanel_mipi_dbi_check_commands(struct device *dev, const struct firmware *fw)\n{\n\tconst struct panel_mipi_dbi_config *config = (struct panel_mipi_dbi_config *)fw->data;\n\tstruct panel_mipi_dbi_commands *commands;\n\tsize_t size = fw->size, commands_len;\n\tunsigned int i = 0;\n\n\tif (size < sizeof(*config) + 2) {  \n\t\tdev_err(dev, \"config: file size=%zu is too small\\n\", size);\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\tif (memcmp(config->magic, panel_mipi_dbi_magic, sizeof(config->magic))) {\n\t\tdev_err(dev, \"config: Bad magic: %15ph\\n\", config->magic);\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\tif (config->file_format_version != 1) {\n\t\tdev_err(dev, \"config: version=%u is not supported\\n\", config->file_format_version);\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\tdrm_dev_dbg(dev, DRM_UT_DRIVER, \"size=%zu version=%u\\n\", size, config->file_format_version);\n\n\tcommands_len = size - sizeof(*config);\n\n\twhile ((i + 1) < commands_len) {\n\t\tu8 command = config->commands[i++];\n\t\tu8 num_parameters = config->commands[i++];\n\t\tconst u8 *parameters = &config->commands[i];\n\n\t\ti += num_parameters;\n\t\tif (i > commands_len) {\n\t\t\tdev_err(dev, \"config: command=0x%02x num_parameters=%u overflows\\n\",\n\t\t\t\tcommand, num_parameters);\n\t\t\treturn ERR_PTR(-EINVAL);\n\t\t}\n\n\t\tif (command == 0x00 && num_parameters == 1)\n\t\t\tdrm_dev_dbg(dev, DRM_UT_DRIVER, \"sleep %ums\\n\", parameters[0]);\n\t\telse\n\t\t\tdrm_dev_dbg(dev, DRM_UT_DRIVER, \"command %02x %*ph\\n\",\n\t\t\t\t    command, num_parameters, parameters);\n\t}\n\n\tif (i != commands_len) {\n\t\tdev_err(dev, \"config: malformed command array\\n\");\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\tcommands = devm_kzalloc(dev, sizeof(*commands), GFP_KERNEL);\n\tif (!commands)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tcommands->len = commands_len;\n\tcommands->buf = devm_kmemdup(dev, config->commands, commands->len, GFP_KERNEL);\n\tif (!commands->buf)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\treturn commands;\n}\n\nstatic struct panel_mipi_dbi_commands *panel_mipi_dbi_commands_from_fw(struct device *dev)\n{\n\tstruct panel_mipi_dbi_commands *commands;\n\tconst struct firmware *fw;\n\tconst char *compatible;\n\tchar fw_name[40];\n\tint ret;\n\n\tret = of_property_read_string_index(dev->of_node, \"compatible\", 0, &compatible);\n\tif (ret)\n\t\treturn ERR_PTR(ret);\n\n\tsnprintf(fw_name, sizeof(fw_name), \"%s.bin\", compatible);\n\tret = request_firmware(&fw, fw_name, dev);\n\tif (ret) {\n\t\tdev_err(dev, \"No config file found for compatible '%s' (error=%d)\\n\",\n\t\t\tcompatible, ret);\n\n\t\treturn ERR_PTR(ret);\n\t}\n\n\tcommands = panel_mipi_dbi_check_commands(dev, fw);\n\trelease_firmware(fw);\n\n\treturn commands;\n}\n\nstatic void panel_mipi_dbi_commands_execute(struct mipi_dbi *dbi,\n\t\t\t\t\t    struct panel_mipi_dbi_commands *commands)\n{\n\tunsigned int i = 0;\n\n\tif (!commands)\n\t\treturn;\n\n\twhile (i < commands->len) {\n\t\tu8 command = commands->buf[i++];\n\t\tu8 num_parameters = commands->buf[i++];\n\t\tconst u8 *parameters = &commands->buf[i];\n\n\t\tif (command == 0x00 && num_parameters == 1)\n\t\t\tmsleep(parameters[0]);\n\t\telse if (num_parameters)\n\t\t\tmipi_dbi_command_stackbuf(dbi, command, parameters, num_parameters);\n\t\telse\n\t\t\tmipi_dbi_command(dbi, command);\n\n\t\ti += num_parameters;\n\t}\n}\n\nstatic void panel_mipi_dbi_enable(struct drm_simple_display_pipe *pipe,\n\t\t\t\t  struct drm_crtc_state *crtc_state,\n\t\t\t\t  struct drm_plane_state *plane_state)\n{\n\tstruct mipi_dbi_dev *dbidev = drm_to_mipi_dbi_dev(pipe->crtc.dev);\n\tstruct mipi_dbi *dbi = &dbidev->dbi;\n\tint ret, idx;\n\n\tif (!drm_dev_enter(pipe->crtc.dev, &idx))\n\t\treturn;\n\n\tdrm_dbg(pipe->crtc.dev, \"\\n\");\n\n\tret = mipi_dbi_poweron_conditional_reset(dbidev);\n\tif (ret < 0)\n\t\tgoto out_exit;\n\tif (!ret)\n\t\tpanel_mipi_dbi_commands_execute(dbi, dbidev->driver_private);\n\n\tmipi_dbi_enable_flush(dbidev, crtc_state, plane_state);\nout_exit:\n\tdrm_dev_exit(idx);\n}\n\nstatic const struct drm_simple_display_pipe_funcs panel_mipi_dbi_pipe_funcs = {\n\tDRM_MIPI_DBI_SIMPLE_DISPLAY_PIPE_FUNCS(panel_mipi_dbi_enable),\n};\n\nDEFINE_DRM_GEM_DMA_FOPS(panel_mipi_dbi_fops);\n\nstatic const struct drm_driver panel_mipi_dbi_driver = {\n\t.driver_features\t= DRIVER_GEM | DRIVER_MODESET | DRIVER_ATOMIC,\n\t.fops\t\t\t= &panel_mipi_dbi_fops,\n\tDRM_GEM_DMA_DRIVER_OPS_VMAP,\n\t.debugfs_init\t\t= mipi_dbi_debugfs_init,\n\t.name\t\t\t= \"panel-mipi-dbi\",\n\t.desc\t\t\t= \"MIPI DBI compatible display panel\",\n\t.date\t\t\t= \"20220103\",\n\t.major\t\t\t= 1,\n\t.minor\t\t\t= 0,\n};\n\nstatic int panel_mipi_dbi_get_mode(struct mipi_dbi_dev *dbidev, struct drm_display_mode *mode)\n{\n\tstruct device *dev = dbidev->drm.dev;\n\tu16 hback_porch, vback_porch;\n\tint ret;\n\n\tret = of_get_drm_panel_display_mode(dev->of_node, mode, NULL);\n\tif (ret) {\n\t\tdev_err(dev, \"%pOF: failed to get panel-timing (error=%d)\\n\", dev->of_node, ret);\n\t\treturn ret;\n\t}\n\n\tmode->type = DRM_MODE_TYPE_DRIVER | DRM_MODE_TYPE_PREFERRED;\n\n\thback_porch = mode->htotal - mode->hsync_end;\n\tvback_porch = mode->vtotal - mode->vsync_end;\n\n\t \n\tif (!mode->hdisplay || !mode->vdisplay || mode->flags ||\n\t    mode->hsync_end > mode->hdisplay || (hback_porch + mode->hdisplay) > 0xffff ||\n\t    mode->vsync_end > mode->vdisplay || (vback_porch + mode->vdisplay) > 0xffff) {\n\t\tdev_err(dev, \"%pOF: panel-timing out of bounds\\n\", dev->of_node);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (!mode->clock)\n\t\tmode->clock = mode->htotal * mode->vtotal * 60 / 1000;\n\n\tdbidev->top_offset = vback_porch;\n\tdbidev->left_offset = hback_porch;\n\n\treturn 0;\n}\n\nstatic int panel_mipi_dbi_spi_probe(struct spi_device *spi)\n{\n\tstruct device *dev = &spi->dev;\n\tstruct drm_display_mode mode;\n\tstruct mipi_dbi_dev *dbidev;\n\tstruct drm_device *drm;\n\tstruct mipi_dbi *dbi;\n\tstruct gpio_desc *dc;\n\tint ret;\n\n\tdbidev = devm_drm_dev_alloc(dev, &panel_mipi_dbi_driver, struct mipi_dbi_dev, drm);\n\tif (IS_ERR(dbidev))\n\t\treturn PTR_ERR(dbidev);\n\n\tdbi = &dbidev->dbi;\n\tdrm = &dbidev->drm;\n\n\tret = panel_mipi_dbi_get_mode(dbidev, &mode);\n\tif (ret)\n\t\treturn ret;\n\n\tdbidev->regulator = devm_regulator_get(dev, \"power\");\n\tif (IS_ERR(dbidev->regulator))\n\t\treturn dev_err_probe(dev, PTR_ERR(dbidev->regulator),\n\t\t\t\t     \"Failed to get regulator 'power'\\n\");\n\n\tdbidev->io_regulator = devm_regulator_get(dev, \"io\");\n\tif (IS_ERR(dbidev->io_regulator))\n\t\treturn dev_err_probe(dev, PTR_ERR(dbidev->io_regulator),\n\t\t\t\t     \"Failed to get regulator 'io'\\n\");\n\n\tdbidev->backlight = devm_of_find_backlight(dev);\n\tif (IS_ERR(dbidev->backlight))\n\t\treturn dev_err_probe(dev, PTR_ERR(dbidev->backlight), \"Failed to get backlight\\n\");\n\n\tdbi->reset = devm_gpiod_get_optional(dev, \"reset\", GPIOD_OUT_HIGH);\n\tif (IS_ERR(dbi->reset))\n\t\treturn dev_err_probe(dev, PTR_ERR(dbi->reset), \"Failed to get GPIO 'reset'\\n\");\n\n\t \n\tdc = devm_gpiod_get_optional(dev, \"dc\", GPIOD_OUT_LOW | GPIOD_FLAGS_BIT_NONEXCLUSIVE);\n\tif (IS_ERR(dc))\n\t\treturn dev_err_probe(dev, PTR_ERR(dc), \"Failed to get GPIO 'dc'\\n\");\n\n\tret = mipi_dbi_spi_init(spi, dbi, dc);\n\tif (ret)\n\t\treturn ret;\n\n\tif (device_property_present(dev, \"write-only\"))\n\t\tdbi->read_commands = NULL;\n\n\tdbidev->driver_private = panel_mipi_dbi_commands_from_fw(dev);\n\tif (IS_ERR(dbidev->driver_private))\n\t\treturn PTR_ERR(dbidev->driver_private);\n\n\tret = mipi_dbi_dev_init(dbidev, &panel_mipi_dbi_pipe_funcs, &mode, 0);\n\tif (ret)\n\t\treturn ret;\n\n\tdrm_mode_config_reset(drm);\n\n\tret = drm_dev_register(drm, 0);\n\tif (ret)\n\t\treturn ret;\n\n\tspi_set_drvdata(spi, drm);\n\n\tdrm_fbdev_generic_setup(drm, 0);\n\n\treturn 0;\n}\n\nstatic void panel_mipi_dbi_spi_remove(struct spi_device *spi)\n{\n\tstruct drm_device *drm = spi_get_drvdata(spi);\n\n\tdrm_dev_unplug(drm);\n\tdrm_atomic_helper_shutdown(drm);\n}\n\nstatic void panel_mipi_dbi_spi_shutdown(struct spi_device *spi)\n{\n\tdrm_atomic_helper_shutdown(spi_get_drvdata(spi));\n}\n\nstatic int __maybe_unused panel_mipi_dbi_pm_suspend(struct device *dev)\n{\n\treturn drm_mode_config_helper_suspend(dev_get_drvdata(dev));\n}\n\nstatic int __maybe_unused panel_mipi_dbi_pm_resume(struct device *dev)\n{\n\tdrm_mode_config_helper_resume(dev_get_drvdata(dev));\n\n\treturn 0;\n}\n\nstatic const struct dev_pm_ops panel_mipi_dbi_pm_ops = {\n\tSET_SYSTEM_SLEEP_PM_OPS(panel_mipi_dbi_pm_suspend, panel_mipi_dbi_pm_resume)\n};\n\nstatic const struct of_device_id panel_mipi_dbi_spi_of_match[] = {\n\t{ .compatible = \"panel-mipi-dbi-spi\" },\n\t{},\n};\nMODULE_DEVICE_TABLE(of, panel_mipi_dbi_spi_of_match);\n\nstatic const struct spi_device_id panel_mipi_dbi_spi_id[] = {\n\t{ \"panel-mipi-dbi-spi\", 0 },\n\t{ },\n};\nMODULE_DEVICE_TABLE(spi, panel_mipi_dbi_spi_id);\n\nstatic struct spi_driver panel_mipi_dbi_spi_driver = {\n\t.driver = {\n\t\t.name = \"panel-mipi-dbi-spi\",\n\t\t.owner = THIS_MODULE,\n\t\t.of_match_table = panel_mipi_dbi_spi_of_match,\n\t\t.pm = &panel_mipi_dbi_pm_ops,\n\t},\n\t.id_table = panel_mipi_dbi_spi_id,\n\t.probe = panel_mipi_dbi_spi_probe,\n\t.remove = panel_mipi_dbi_spi_remove,\n\t.shutdown = panel_mipi_dbi_spi_shutdown,\n};\nmodule_spi_driver(panel_mipi_dbi_spi_driver);\n\nMODULE_DESCRIPTION(\"MIPI DBI compatible display panel driver\");\nMODULE_AUTHOR(\"Noralf Tr\u00f8nnes\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}