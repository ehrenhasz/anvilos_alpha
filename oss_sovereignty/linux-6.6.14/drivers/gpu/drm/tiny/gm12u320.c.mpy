{
  "module_name": "gm12u320.c",
  "hash_id": "9e28937dc907d8b4d33c72d202c140a75f8916ec9fb9854fb65b291b1f4eca8e",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/tiny/gm12u320.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/pm.h>\n#include <linux/usb.h>\n\n#include <drm/drm_atomic_helper.h>\n#include <drm/drm_atomic_state_helper.h>\n#include <drm/drm_connector.h>\n#include <drm/drm_damage_helper.h>\n#include <drm/drm_drv.h>\n#include <drm/drm_edid.h>\n#include <drm/drm_fbdev_generic.h>\n#include <drm/drm_file.h>\n#include <drm/drm_format_helper.h>\n#include <drm/drm_fourcc.h>\n#include <drm/drm_framebuffer.h>\n#include <drm/drm_gem_atomic_helper.h>\n#include <drm/drm_gem_framebuffer_helper.h>\n#include <drm/drm_gem_shmem_helper.h>\n#include <drm/drm_ioctl.h>\n#include <drm/drm_managed.h>\n#include <drm/drm_modeset_helper_vtables.h>\n#include <drm/drm_probe_helper.h>\n#include <drm/drm_simple_kms_helper.h>\n\nstatic bool eco_mode;\nmodule_param(eco_mode, bool, 0644);\nMODULE_PARM_DESC(eco_mode, \"Turn on Eco mode (less bright, more silent)\");\n\n#define DRIVER_NAME\t\t\"gm12u320\"\n#define DRIVER_DESC\t\t\"Grain Media GM12U320 USB projector display\"\n#define DRIVER_DATE\t\t\"2019\"\n#define DRIVER_MAJOR\t\t1\n#define DRIVER_MINOR\t\t0\n\n \n#define GM12U320_USER_WIDTH\t\t848\n#define GM12U320_REAL_WIDTH\t\t854\n#define GM12U320_HEIGHT\t\t\t480\n\n#define GM12U320_BLOCK_COUNT\t\t20\n\n#define GM12U320_ERR(fmt, ...) \\\n\tDRM_DEV_ERROR(gm12u320->dev.dev, fmt, ##__VA_ARGS__)\n\n#define MISC_RCV_EPT\t\t\t1\n#define DATA_RCV_EPT\t\t\t2\n#define DATA_SND_EPT\t\t\t3\n#define MISC_SND_EPT\t\t\t4\n\n#define DATA_BLOCK_HEADER_SIZE\t\t84\n#define DATA_BLOCK_CONTENT_SIZE\t\t64512\n#define DATA_BLOCK_FOOTER_SIZE\t\t20\n#define DATA_BLOCK_SIZE\t\t\t(DATA_BLOCK_HEADER_SIZE + \\\n\t\t\t\t\t DATA_BLOCK_CONTENT_SIZE + \\\n\t\t\t\t\t DATA_BLOCK_FOOTER_SIZE)\n#define DATA_LAST_BLOCK_CONTENT_SIZE\t4032\n#define DATA_LAST_BLOCK_SIZE\t\t(DATA_BLOCK_HEADER_SIZE + \\\n\t\t\t\t\t DATA_LAST_BLOCK_CONTENT_SIZE + \\\n\t\t\t\t\t DATA_BLOCK_FOOTER_SIZE)\n\n#define CMD_SIZE\t\t\t31\n#define READ_STATUS_SIZE\t\t13\n#define MISC_VALUE_SIZE\t\t\t4\n\n#define CMD_TIMEOUT\t\t\t200\n#define DATA_TIMEOUT\t\t\t1000\n#define IDLE_TIMEOUT\t\t\t2000\n#define FIRST_FRAME_TIMEOUT\t\t2000\n\n#define MISC_REQ_GET_SET_ECO_A\t\t0xff\n#define MISC_REQ_GET_SET_ECO_B\t\t0x35\n \n#define MISC_REQ_UNKNOWN1_A\t\t0xff\n#define MISC_REQ_UNKNOWN1_B\t\t0x38\n \n#define MISC_REQ_UNKNOWN2_A\t\t0xa5\n#define MISC_REQ_UNKNOWN2_B\t\t0x00\n\nstruct gm12u320_device {\n\tstruct drm_device\t         dev;\n\tstruct device                   *dmadev;\n\tstruct drm_simple_display_pipe   pipe;\n\tstruct drm_connector\t         conn;\n\tunsigned char                   *cmd_buf;\n\tunsigned char                   *data_buf[GM12U320_BLOCK_COUNT];\n\tstruct {\n\t\tstruct delayed_work       work;\n\t\tstruct mutex             lock;\n\t\tstruct drm_framebuffer  *fb;\n\t\tstruct drm_rect          rect;\n\t\tint frame;\n\t\tint draw_status_timeout;\n\t\tstruct iosys_map src_map;\n\t} fb_update;\n};\n\n#define to_gm12u320(__dev) container_of(__dev, struct gm12u320_device, dev)\n\nstatic const char cmd_data[CMD_SIZE] = {\n\t0x55, 0x53, 0x42, 0x43, 0x00, 0x00, 0x00, 0x00,\n\t0x68, 0xfc, 0x00, 0x00, 0x00, 0x00, 0x10, 0xff,\n\t0x00, 0x00, 0x00, 0x00, 0xfc, 0x00, 0x80, 0x00,\n\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00\n};\n\nstatic const char cmd_draw[CMD_SIZE] = {\n\t0x55, 0x53, 0x42, 0x43, 0x00, 0x00, 0x00, 0x00,\n\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0xfe,\n\t0x00, 0x00, 0x00, 0xc0, 0xd1, 0x05, 0x00, 0x40,\n\t0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00\n};\n\nstatic const char cmd_misc[CMD_SIZE] = {\n\t0x55, 0x53, 0x42, 0x43, 0x00, 0x00, 0x00, 0x00,\n\t0x04, 0x00, 0x00, 0x00, 0x80, 0x01, 0x10, 0xfd,\n\t0x00, 0x00, 0x00, 0xc0, 0x00, 0x00, 0x00, 0x00,\n\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00\n};\n\nstatic const char data_block_header[DATA_BLOCK_HEADER_SIZE] = {\n\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n\t0xfb, 0x14, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n\t0x00, 0x04, 0x15, 0x00, 0x00, 0xfc, 0x00, 0x00,\n\t0x01, 0x00, 0x00, 0xdb\n};\n\nstatic const char data_last_block_header[DATA_BLOCK_HEADER_SIZE] = {\n\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n\t0xfb, 0x14, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n\t0x2a, 0x00, 0x20, 0x00, 0xc0, 0x0f, 0x00, 0x00,\n\t0x01, 0x00, 0x00, 0xd7\n};\n\nstatic const char data_block_footer[DATA_BLOCK_FOOTER_SIZE] = {\n\t0xfb, 0x14, 0x02, 0x20, 0x00, 0x00, 0x00, 0x00,\n\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n\t0x80, 0x00, 0x00, 0x4f\n};\n\nstatic inline struct usb_device *gm12u320_to_usb_device(struct gm12u320_device *gm12u320)\n{\n\treturn interface_to_usbdev(to_usb_interface(gm12u320->dev.dev));\n}\n\nstatic int gm12u320_usb_alloc(struct gm12u320_device *gm12u320)\n{\n\tint i, block_size;\n\tconst char *hdr;\n\n\tgm12u320->cmd_buf = drmm_kmalloc(&gm12u320->dev, CMD_SIZE, GFP_KERNEL);\n\tif (!gm12u320->cmd_buf)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < GM12U320_BLOCK_COUNT; i++) {\n\t\tif (i == GM12U320_BLOCK_COUNT - 1) {\n\t\t\tblock_size = DATA_LAST_BLOCK_SIZE;\n\t\t\thdr = data_last_block_header;\n\t\t} else {\n\t\t\tblock_size = DATA_BLOCK_SIZE;\n\t\t\thdr = data_block_header;\n\t\t}\n\n\t\tgm12u320->data_buf[i] = drmm_kzalloc(&gm12u320->dev,\n\t\t\t\t\t\t     block_size, GFP_KERNEL);\n\t\tif (!gm12u320->data_buf[i])\n\t\t\treturn -ENOMEM;\n\n\t\tmemcpy(gm12u320->data_buf[i], hdr, DATA_BLOCK_HEADER_SIZE);\n\t\tmemcpy(gm12u320->data_buf[i] +\n\t\t\t\t(block_size - DATA_BLOCK_FOOTER_SIZE),\n\t\t       data_block_footer, DATA_BLOCK_FOOTER_SIZE);\n\t}\n\n\treturn 0;\n}\n\nstatic int gm12u320_misc_request(struct gm12u320_device *gm12u320,\n\t\t\t\t u8 req_a, u8 req_b,\n\t\t\t\t u8 arg_a, u8 arg_b, u8 arg_c, u8 arg_d)\n{\n\tstruct usb_device *udev = gm12u320_to_usb_device(gm12u320);\n\tint ret, len;\n\n\tmemcpy(gm12u320->cmd_buf, &cmd_misc, CMD_SIZE);\n\tgm12u320->cmd_buf[20] = req_a;\n\tgm12u320->cmd_buf[21] = req_b;\n\tgm12u320->cmd_buf[22] = arg_a;\n\tgm12u320->cmd_buf[23] = arg_b;\n\tgm12u320->cmd_buf[24] = arg_c;\n\tgm12u320->cmd_buf[25] = arg_d;\n\n\t \n\tret = usb_bulk_msg(udev, usb_sndbulkpipe(udev, MISC_SND_EPT),\n\t\t\t   gm12u320->cmd_buf, CMD_SIZE, &len, CMD_TIMEOUT);\n\tif (ret || len != CMD_SIZE) {\n\t\tGM12U320_ERR(\"Misc. req. error %d\\n\", ret);\n\t\treturn -EIO;\n\t}\n\n\t \n\tret = usb_bulk_msg(udev, usb_rcvbulkpipe(udev, MISC_RCV_EPT),\n\t\t\t   gm12u320->cmd_buf, MISC_VALUE_SIZE, &len,\n\t\t\t   DATA_TIMEOUT);\n\tif (ret || len != MISC_VALUE_SIZE) {\n\t\tGM12U320_ERR(\"Misc. value error %d\\n\", ret);\n\t\treturn -EIO;\n\t}\n\t \n\n\t \n\tret = usb_bulk_msg(udev, usb_rcvbulkpipe(udev, MISC_RCV_EPT),\n\t\t\t   gm12u320->cmd_buf, READ_STATUS_SIZE, &len,\n\t\t\t   CMD_TIMEOUT);\n\tif (ret || len != READ_STATUS_SIZE) {\n\t\tGM12U320_ERR(\"Misc. status error %d\\n\", ret);\n\t\treturn -EIO;\n\t}\n\n\treturn 0;\n}\n\nstatic void gm12u320_32bpp_to_24bpp_packed(u8 *dst, u8 *src, int len)\n{\n\twhile (len--) {\n\t\t*dst++ = *src++;\n\t\t*dst++ = *src++;\n\t\t*dst++ = *src++;\n\t\tsrc++;\n\t}\n}\n\nstatic void gm12u320_copy_fb_to_blocks(struct gm12u320_device *gm12u320)\n{\n\tint block, dst_offset, len, remain, ret, x1, x2, y1, y2;\n\tstruct drm_framebuffer *fb;\n\tvoid *vaddr;\n\tu8 *src;\n\n\tmutex_lock(&gm12u320->fb_update.lock);\n\n\tif (!gm12u320->fb_update.fb)\n\t\tgoto unlock;\n\n\tfb = gm12u320->fb_update.fb;\n\tx1 = gm12u320->fb_update.rect.x1;\n\tx2 = gm12u320->fb_update.rect.x2;\n\ty1 = gm12u320->fb_update.rect.y1;\n\ty2 = gm12u320->fb_update.rect.y2;\n\tvaddr = gm12u320->fb_update.src_map.vaddr;  \n\n\tret = drm_gem_fb_begin_cpu_access(fb, DMA_FROM_DEVICE);\n\tif (ret) {\n\t\tGM12U320_ERR(\"drm_gem_fb_begin_cpu_access err: %d\\n\", ret);\n\t\tgoto put_fb;\n\t}\n\n\tsrc = vaddr + y1 * fb->pitches[0] + x1 * 4;\n\n\tx1 += (GM12U320_REAL_WIDTH - GM12U320_USER_WIDTH) / 2;\n\tx2 += (GM12U320_REAL_WIDTH - GM12U320_USER_WIDTH) / 2;\n\n\tfor (; y1 < y2; y1++) {\n\t\tremain = 0;\n\t\tlen = (x2 - x1) * 3;\n\t\tdst_offset = (y1 * GM12U320_REAL_WIDTH + x1) * 3;\n\t\tblock = dst_offset / DATA_BLOCK_CONTENT_SIZE;\n\t\tdst_offset %= DATA_BLOCK_CONTENT_SIZE;\n\n\t\tif ((dst_offset + len) > DATA_BLOCK_CONTENT_SIZE) {\n\t\t\tremain = dst_offset + len - DATA_BLOCK_CONTENT_SIZE;\n\t\t\tlen = DATA_BLOCK_CONTENT_SIZE - dst_offset;\n\t\t}\n\n\t\tdst_offset += DATA_BLOCK_HEADER_SIZE;\n\t\tlen /= 3;\n\n\t\tgm12u320_32bpp_to_24bpp_packed(\n\t\t\tgm12u320->data_buf[block] + dst_offset,\n\t\t\tsrc, len);\n\n\t\tif (remain) {\n\t\t\tblock++;\n\t\t\tdst_offset = DATA_BLOCK_HEADER_SIZE;\n\t\t\tgm12u320_32bpp_to_24bpp_packed(\n\t\t\t\tgm12u320->data_buf[block] + dst_offset,\n\t\t\t\tsrc + len * 4, remain / 3);\n\t\t}\n\t\tsrc += fb->pitches[0];\n\t}\n\n\tdrm_gem_fb_end_cpu_access(fb, DMA_FROM_DEVICE);\nput_fb:\n\tdrm_framebuffer_put(fb);\n\tgm12u320->fb_update.fb = NULL;\nunlock:\n\tmutex_unlock(&gm12u320->fb_update.lock);\n}\n\nstatic void gm12u320_fb_update_work(struct work_struct *work)\n{\n\tstruct gm12u320_device *gm12u320 =\n\t\tcontainer_of(to_delayed_work(work), struct gm12u320_device,\n\t\t\t     fb_update.work);\n\tstruct usb_device *udev = gm12u320_to_usb_device(gm12u320);\n\tint block, block_size, len;\n\tint ret = 0;\n\n\tgm12u320_copy_fb_to_blocks(gm12u320);\n\n\tfor (block = 0; block < GM12U320_BLOCK_COUNT; block++) {\n\t\tif (block == GM12U320_BLOCK_COUNT - 1)\n\t\t\tblock_size = DATA_LAST_BLOCK_SIZE;\n\t\telse\n\t\t\tblock_size = DATA_BLOCK_SIZE;\n\n\t\t \n\t\tmemcpy(gm12u320->cmd_buf, cmd_data, CMD_SIZE);\n\t\tgm12u320->cmd_buf[8] = block_size & 0xff;\n\t\tgm12u320->cmd_buf[9] = block_size >> 8;\n\t\tgm12u320->cmd_buf[20] = 0xfc - block * 4;\n\t\tgm12u320->cmd_buf[21] =\n\t\t\tblock | (gm12u320->fb_update.frame << 7);\n\n\t\tret = usb_bulk_msg(udev,\n\t\t\t\t   usb_sndbulkpipe(udev, DATA_SND_EPT),\n\t\t\t\t   gm12u320->cmd_buf, CMD_SIZE, &len,\n\t\t\t\t   CMD_TIMEOUT);\n\t\tif (ret || len != CMD_SIZE)\n\t\t\tgoto err;\n\n\t\t \n\t\tret = usb_bulk_msg(udev,\n\t\t\t\t   usb_sndbulkpipe(udev, DATA_SND_EPT),\n\t\t\t\t   gm12u320->data_buf[block], block_size,\n\t\t\t\t   &len, DATA_TIMEOUT);\n\t\tif (ret || len != block_size)\n\t\t\tgoto err;\n\n\t\t \n\t\tret = usb_bulk_msg(udev,\n\t\t\t\t   usb_rcvbulkpipe(udev, DATA_RCV_EPT),\n\t\t\t\t   gm12u320->cmd_buf, READ_STATUS_SIZE, &len,\n\t\t\t\t   CMD_TIMEOUT);\n\t\tif (ret || len != READ_STATUS_SIZE)\n\t\t\tgoto err;\n\t}\n\n\t \n\tmemcpy(gm12u320->cmd_buf, cmd_draw, CMD_SIZE);\n\tret = usb_bulk_msg(udev, usb_sndbulkpipe(udev, DATA_SND_EPT),\n\t\t\t   gm12u320->cmd_buf, CMD_SIZE, &len, CMD_TIMEOUT);\n\tif (ret || len != CMD_SIZE)\n\t\tgoto err;\n\n\t \n\tret = usb_bulk_msg(udev, usb_rcvbulkpipe(udev, DATA_RCV_EPT),\n\t\t\t   gm12u320->cmd_buf, READ_STATUS_SIZE, &len,\n\t\t\t   gm12u320->fb_update.draw_status_timeout);\n\tif (ret || len != READ_STATUS_SIZE)\n\t\tgoto err;\n\n\tgm12u320->fb_update.draw_status_timeout = CMD_TIMEOUT;\n\tgm12u320->fb_update.frame = !gm12u320->fb_update.frame;\n\n\t \n\tqueue_delayed_work(system_long_wq, &gm12u320->fb_update.work,\n\t\t\t   msecs_to_jiffies(IDLE_TIMEOUT));\n\n\treturn;\nerr:\n\t \n\tif (ret != -ENODEV && ret != -ECONNRESET && ret != -ESHUTDOWN)\n\t\tGM12U320_ERR(\"Frame update error: %d\\n\", ret);\n}\n\nstatic void gm12u320_fb_mark_dirty(struct drm_framebuffer *fb,\n\t\t\t\t   const struct iosys_map *map,\n\t\t\t\t   struct drm_rect *dirty)\n{\n\tstruct gm12u320_device *gm12u320 = to_gm12u320(fb->dev);\n\tstruct drm_framebuffer *old_fb = NULL;\n\tbool wakeup = false;\n\n\tmutex_lock(&gm12u320->fb_update.lock);\n\n\tif (gm12u320->fb_update.fb != fb) {\n\t\told_fb = gm12u320->fb_update.fb;\n\t\tdrm_framebuffer_get(fb);\n\t\tgm12u320->fb_update.fb = fb;\n\t\tgm12u320->fb_update.rect = *dirty;\n\t\tgm12u320->fb_update.src_map = *map;\n\t\twakeup = true;\n\t} else {\n\t\tstruct drm_rect *rect = &gm12u320->fb_update.rect;\n\n\t\trect->x1 = min(rect->x1, dirty->x1);\n\t\trect->y1 = min(rect->y1, dirty->y1);\n\t\trect->x2 = max(rect->x2, dirty->x2);\n\t\trect->y2 = max(rect->y2, dirty->y2);\n\t}\n\n\tmutex_unlock(&gm12u320->fb_update.lock);\n\n\tif (wakeup)\n\t\tmod_delayed_work(system_long_wq, &gm12u320->fb_update.work, 0);\n\n\tif (old_fb)\n\t\tdrm_framebuffer_put(old_fb);\n}\n\nstatic void gm12u320_stop_fb_update(struct gm12u320_device *gm12u320)\n{\n\tstruct drm_framebuffer *old_fb;\n\n\tcancel_delayed_work_sync(&gm12u320->fb_update.work);\n\n\tmutex_lock(&gm12u320->fb_update.lock);\n\told_fb = gm12u320->fb_update.fb;\n\tgm12u320->fb_update.fb = NULL;\n\tiosys_map_clear(&gm12u320->fb_update.src_map);\n\tmutex_unlock(&gm12u320->fb_update.lock);\n\n\tdrm_framebuffer_put(old_fb);\n}\n\nstatic int gm12u320_set_ecomode(struct gm12u320_device *gm12u320)\n{\n\treturn gm12u320_misc_request(gm12u320, MISC_REQ_GET_SET_ECO_A,\n\t\t\t\t     MISC_REQ_GET_SET_ECO_B, 0x01  ,\n\t\t\t\t     eco_mode ? 0x01 : 0x00, 0x00, 0x01);\n}\n\n \n \n\n \nstatic struct edid gm12u320_edid = {\n\t.header\t\t= { 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00 },\n\t.mfg_id\t\t= { 0x04, 0x72 },\t \n\t.prod_code\t= { 0x20, 0xc1 },\t \n\t.serial\t\t= 0xaa55aa55,\n\t.mfg_week\t= 1,\n\t.mfg_year\t= 16,\n\t.version\t= 1,\t\t\t \n\t.revision\t= 3,\t\t\t \n\t.input\t\t= 0x08,\t\t\t \n\t.features\t= 0x0a,\t\t\t \n\t.standard_timings = { { 1, 1 }, { 1, 1 }, { 1, 1 }, { 1, 1 },\n\t\t\t      { 1, 1 }, { 1, 1 }, { 1, 1 }, { 1, 1 } },\n\t.detailed_timings = { {\n\t\t.pixel_clock = 3383,\n\t\t \n\t\t.data.pixel_data.hactive_lo = 0x50,\n\t\t.data.pixel_data.hblank_lo = 0x00,\n\t\t.data.pixel_data.hactive_hblank_hi = 0x31,\n\t\t \n\t\t.data.pixel_data.vactive_lo = 0xe0,\n\t\t.data.pixel_data.vblank_lo = 0x1c,\n\t\t.data.pixel_data.vactive_vblank_hi = 0x10,\n\t\t \n\t\t.data.pixel_data.hsync_offset_lo = 0x28,\n\t\t.data.pixel_data.hsync_pulse_width_lo = 0x80,\n\t\t.data.pixel_data.vsync_offset_pulse_width_lo = 0x14,\n\t\t.data.pixel_data.hsync_vsync_offset_pulse_width_hi = 0x00,\n\t\t \n\t\t.data.pixel_data.misc = 0x1e,\n\t}, {\n\t\t.pixel_clock = 0,\n\t\t.data.other_data.type = 0xfd,  \n\t\t.data.other_data.data.range.min_vfreq = 59,\n\t\t.data.other_data.data.range.max_vfreq = 61,\n\t\t.data.other_data.data.range.min_hfreq_khz = 29,\n\t\t.data.other_data.data.range.max_hfreq_khz = 32,\n\t\t.data.other_data.data.range.pixel_clock_mhz = 4,  \n\t\t.data.other_data.data.range.flags = 0,\n\t\t.data.other_data.data.range.formula.cvt = {\n\t\t\t0xa0, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20 },\n\t}, {\n\t\t.pixel_clock = 0,\n\t\t.data.other_data.type = 0xfc,  \n\t\t.data.other_data.data.str.str = {\n\t\t\t'P', 'r', 'o', 'j', 'e', 'c', 't', 'o', 'r', '\\n',\n\t\t\t' ', ' ',  ' ' },\n\t}, {\n\t\t.pixel_clock = 0,\n\t\t.data.other_data.type = 0xfe,  \n\t\t.data.other_data.data.str.str = {\n\t\t\t'\\n', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ',\n\t\t\t' ', ' ',  ' ' },\n\t} },\n\t.checksum = 0x13,\n};\n\nstatic int gm12u320_conn_get_modes(struct drm_connector *connector)\n{\n\tdrm_connector_update_edid_property(connector, &gm12u320_edid);\n\treturn drm_add_edid_modes(connector, &gm12u320_edid);\n}\n\nstatic const struct drm_connector_helper_funcs gm12u320_conn_helper_funcs = {\n\t.get_modes = gm12u320_conn_get_modes,\n};\n\nstatic const struct drm_connector_funcs gm12u320_conn_funcs = {\n\t.fill_modes = drm_helper_probe_single_connector_modes,\n\t.destroy = drm_connector_cleanup,\n\t.reset = drm_atomic_helper_connector_reset,\n\t.atomic_duplicate_state = drm_atomic_helper_connector_duplicate_state,\n\t.atomic_destroy_state = drm_atomic_helper_connector_destroy_state,\n};\n\nstatic int gm12u320_conn_init(struct gm12u320_device *gm12u320)\n{\n\tdrm_connector_helper_add(&gm12u320->conn, &gm12u320_conn_helper_funcs);\n\treturn drm_connector_init(&gm12u320->dev, &gm12u320->conn,\n\t\t\t\t  &gm12u320_conn_funcs, DRM_MODE_CONNECTOR_VGA);\n}\n\n \n \n\nstatic void gm12u320_pipe_enable(struct drm_simple_display_pipe *pipe,\n\t\t\t\t struct drm_crtc_state *crtc_state,\n\t\t\t\t struct drm_plane_state *plane_state)\n{\n\tstruct drm_rect rect = { 0, 0, GM12U320_USER_WIDTH, GM12U320_HEIGHT };\n\tstruct gm12u320_device *gm12u320 = to_gm12u320(pipe->crtc.dev);\n\tstruct drm_shadow_plane_state *shadow_plane_state = to_drm_shadow_plane_state(plane_state);\n\n\tgm12u320->fb_update.draw_status_timeout = FIRST_FRAME_TIMEOUT;\n\tgm12u320_fb_mark_dirty(plane_state->fb, &shadow_plane_state->data[0], &rect);\n}\n\nstatic void gm12u320_pipe_disable(struct drm_simple_display_pipe *pipe)\n{\n\tstruct gm12u320_device *gm12u320 = to_gm12u320(pipe->crtc.dev);\n\n\tgm12u320_stop_fb_update(gm12u320);\n}\n\nstatic void gm12u320_pipe_update(struct drm_simple_display_pipe *pipe,\n\t\t\t\t struct drm_plane_state *old_state)\n{\n\tstruct drm_plane_state *state = pipe->plane.state;\n\tstruct drm_shadow_plane_state *shadow_plane_state = to_drm_shadow_plane_state(state);\n\tstruct drm_rect rect;\n\n\tif (drm_atomic_helper_damage_merged(old_state, state, &rect))\n\t\tgm12u320_fb_mark_dirty(state->fb, &shadow_plane_state->data[0], &rect);\n}\n\nstatic const struct drm_simple_display_pipe_funcs gm12u320_pipe_funcs = {\n\t.enable\t    = gm12u320_pipe_enable,\n\t.disable    = gm12u320_pipe_disable,\n\t.update\t    = gm12u320_pipe_update,\n\tDRM_GEM_SIMPLE_DISPLAY_PIPE_SHADOW_PLANE_FUNCS,\n};\n\nstatic const uint32_t gm12u320_pipe_formats[] = {\n\tDRM_FORMAT_XRGB8888,\n};\n\nstatic const uint64_t gm12u320_pipe_modifiers[] = {\n\tDRM_FORMAT_MOD_LINEAR,\n\tDRM_FORMAT_MOD_INVALID\n};\n\n \nstatic struct drm_gem_object *gm12u320_gem_prime_import(struct drm_device *dev,\n\t\t\t\t\t\t\tstruct dma_buf *dma_buf)\n{\n\tstruct gm12u320_device *gm12u320 = to_gm12u320(dev);\n\n\tif (!gm12u320->dmadev)\n\t\treturn ERR_PTR(-ENODEV);\n\n\treturn drm_gem_prime_import_dev(dev, dma_buf, gm12u320->dmadev);\n}\n\nDEFINE_DRM_GEM_FOPS(gm12u320_fops);\n\nstatic const struct drm_driver gm12u320_drm_driver = {\n\t.driver_features = DRIVER_MODESET | DRIVER_GEM | DRIVER_ATOMIC,\n\n\t.name\t\t = DRIVER_NAME,\n\t.desc\t\t = DRIVER_DESC,\n\t.date\t\t = DRIVER_DATE,\n\t.major\t\t = DRIVER_MAJOR,\n\t.minor\t\t = DRIVER_MINOR,\n\n\t.fops\t\t = &gm12u320_fops,\n\tDRM_GEM_SHMEM_DRIVER_OPS,\n\t.gem_prime_import = gm12u320_gem_prime_import,\n};\n\nstatic const struct drm_mode_config_funcs gm12u320_mode_config_funcs = {\n\t.fb_create = drm_gem_fb_create_with_dirty,\n\t.atomic_check = drm_atomic_helper_check,\n\t.atomic_commit = drm_atomic_helper_commit,\n};\n\nstatic int gm12u320_usb_probe(struct usb_interface *interface,\n\t\t\t      const struct usb_device_id *id)\n{\n\tstruct gm12u320_device *gm12u320;\n\tstruct drm_device *dev;\n\tint ret;\n\n\t \n\tif (interface->cur_altsetting->desc.bInterfaceNumber != 0)\n\t\treturn -ENODEV;\n\n\tgm12u320 = devm_drm_dev_alloc(&interface->dev, &gm12u320_drm_driver,\n\t\t\t\t      struct gm12u320_device, dev);\n\tif (IS_ERR(gm12u320))\n\t\treturn PTR_ERR(gm12u320);\n\tdev = &gm12u320->dev;\n\n\tgm12u320->dmadev = usb_intf_get_dma_device(to_usb_interface(dev->dev));\n\tif (!gm12u320->dmadev)\n\t\tdrm_warn(dev, \"buffer sharing not supported\");  \n\n\tINIT_DELAYED_WORK(&gm12u320->fb_update.work, gm12u320_fb_update_work);\n\tmutex_init(&gm12u320->fb_update.lock);\n\n\tret = drmm_mode_config_init(dev);\n\tif (ret)\n\t\tgoto err_put_device;\n\n\tdev->mode_config.min_width = GM12U320_USER_WIDTH;\n\tdev->mode_config.max_width = GM12U320_USER_WIDTH;\n\tdev->mode_config.min_height = GM12U320_HEIGHT;\n\tdev->mode_config.max_height = GM12U320_HEIGHT;\n\tdev->mode_config.funcs = &gm12u320_mode_config_funcs;\n\n\tret = gm12u320_usb_alloc(gm12u320);\n\tif (ret)\n\t\tgoto err_put_device;\n\n\tret = gm12u320_set_ecomode(gm12u320);\n\tif (ret)\n\t\tgoto err_put_device;\n\n\tret = gm12u320_conn_init(gm12u320);\n\tif (ret)\n\t\tgoto err_put_device;\n\n\tret = drm_simple_display_pipe_init(&gm12u320->dev,\n\t\t\t\t\t   &gm12u320->pipe,\n\t\t\t\t\t   &gm12u320_pipe_funcs,\n\t\t\t\t\t   gm12u320_pipe_formats,\n\t\t\t\t\t   ARRAY_SIZE(gm12u320_pipe_formats),\n\t\t\t\t\t   gm12u320_pipe_modifiers,\n\t\t\t\t\t   &gm12u320->conn);\n\tif (ret)\n\t\tgoto err_put_device;\n\n\tdrm_mode_config_reset(dev);\n\n\tusb_set_intfdata(interface, dev);\n\tret = drm_dev_register(dev, 0);\n\tif (ret)\n\t\tgoto err_put_device;\n\n\tdrm_fbdev_generic_setup(dev, 0);\n\n\treturn 0;\n\nerr_put_device:\n\tput_device(gm12u320->dmadev);\n\treturn ret;\n}\n\nstatic void gm12u320_usb_disconnect(struct usb_interface *interface)\n{\n\tstruct drm_device *dev = usb_get_intfdata(interface);\n\tstruct gm12u320_device *gm12u320 = to_gm12u320(dev);\n\n\tput_device(gm12u320->dmadev);\n\tgm12u320->dmadev = NULL;\n\tdrm_dev_unplug(dev);\n\tdrm_atomic_helper_shutdown(dev);\n}\n\nstatic int gm12u320_suspend(struct usb_interface *interface,\n\t\t\t    pm_message_t message)\n{\n\tstruct drm_device *dev = usb_get_intfdata(interface);\n\n\treturn drm_mode_config_helper_suspend(dev);\n}\n\nstatic int gm12u320_resume(struct usb_interface *interface)\n{\n\tstruct drm_device *dev = usb_get_intfdata(interface);\n\tstruct gm12u320_device *gm12u320 = to_gm12u320(dev);\n\n\tgm12u320_set_ecomode(gm12u320);\n\n\treturn drm_mode_config_helper_resume(dev);\n}\n\nstatic const struct usb_device_id id_table[] = {\n\t{ USB_DEVICE(0x1de1, 0xc102) },\n\t{},\n};\nMODULE_DEVICE_TABLE(usb, id_table);\n\nstatic struct usb_driver gm12u320_usb_driver = {\n\t.name = \"gm12u320\",\n\t.probe = gm12u320_usb_probe,\n\t.disconnect = gm12u320_usb_disconnect,\n\t.id_table = id_table,\n\t.suspend = pm_ptr(gm12u320_suspend),\n\t.resume = pm_ptr(gm12u320_resume),\n\t.reset_resume = pm_ptr(gm12u320_resume),\n};\n\nmodule_usb_driver(gm12u320_usb_driver);\nMODULE_AUTHOR(\"Hans de Goede <hdegoede@redhat.com>\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}