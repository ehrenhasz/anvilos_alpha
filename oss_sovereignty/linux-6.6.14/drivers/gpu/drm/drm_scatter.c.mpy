{
  "module_name": "drm_scatter.c",
  "hash_id": "fd881f871ff8afa74dd0b7c5579cd3d063d04cd3d9e269a3a900de2147ad0591",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/drm_scatter.c",
  "human_readable_source": " \n\n \n\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n\n#include <drm/drm.h>\n#include <drm/drm_drv.h>\n#include <drm/drm_print.h>\n\n#include \"drm_legacy.h\"\n\n#define DEBUG_SCATTER 0\n\nstatic void drm_sg_cleanup(struct drm_sg_mem * entry)\n{\n\tstruct page *page;\n\tint i;\n\n\tfor (i = 0; i < entry->pages; i++) {\n\t\tpage = entry->pagelist[i];\n\t\tif (page)\n\t\t\tClearPageReserved(page);\n\t}\n\n\tvfree(entry->virtual);\n\n\tkfree(entry->busaddr);\n\tkfree(entry->pagelist);\n\tkfree(entry);\n}\n\nvoid drm_legacy_sg_cleanup(struct drm_device *dev)\n{\n\tif (drm_core_check_feature(dev, DRIVER_SG) && dev->sg &&\n\t    drm_core_check_feature(dev, DRIVER_LEGACY)) {\n\t\tdrm_sg_cleanup(dev->sg);\n\t\tdev->sg = NULL;\n\t}\n}\n#ifdef _LP64\n# define ScatterHandle(x) (unsigned int)((x >> 32) + (x & ((1L << 32) - 1)))\n#else\n# define ScatterHandle(x) (unsigned int)(x)\n#endif\n\nint drm_legacy_sg_alloc(struct drm_device *dev, void *data,\n\t\t\tstruct drm_file *file_priv)\n{\n\tstruct drm_scatter_gather *request = data;\n\tstruct drm_sg_mem *entry;\n\tunsigned long pages, i, j;\n\n\tDRM_DEBUG(\"\\n\");\n\n\tif (!drm_core_check_feature(dev, DRIVER_LEGACY))\n\t\treturn -EOPNOTSUPP;\n\n\tif (!drm_core_check_feature(dev, DRIVER_SG))\n\t\treturn -EOPNOTSUPP;\n\n\tif (request->size > SIZE_MAX - PAGE_SIZE)\n\t\treturn -EINVAL;\n\n\tif (dev->sg)\n\t\treturn -EINVAL;\n\n\tentry = kzalloc(sizeof(*entry), GFP_KERNEL);\n\tif (!entry)\n\t\treturn -ENOMEM;\n\n\tpages = (request->size + PAGE_SIZE - 1) / PAGE_SIZE;\n\tDRM_DEBUG(\"size=%ld pages=%ld\\n\", request->size, pages);\n\n\tentry->pages = pages;\n\tentry->pagelist = kcalloc(pages, sizeof(*entry->pagelist), GFP_KERNEL);\n\tif (!entry->pagelist) {\n\t\tkfree(entry);\n\t\treturn -ENOMEM;\n\t}\n\n\tentry->busaddr = kcalloc(pages, sizeof(*entry->busaddr), GFP_KERNEL);\n\tif (!entry->busaddr) {\n\t\tkfree(entry->pagelist);\n\t\tkfree(entry);\n\t\treturn -ENOMEM;\n\t}\n\n\tentry->virtual = vmalloc_32(pages << PAGE_SHIFT);\n\tif (!entry->virtual) {\n\t\tkfree(entry->busaddr);\n\t\tkfree(entry->pagelist);\n\t\tkfree(entry);\n\t\treturn -ENOMEM;\n\t}\n\n\t \n\tmemset(entry->virtual, 0, pages << PAGE_SHIFT);\n\n\tentry->handle = ScatterHandle((unsigned long)entry->virtual);\n\n\tDRM_DEBUG(\"handle  = %08lx\\n\", entry->handle);\n\tDRM_DEBUG(\"virtual = %p\\n\", entry->virtual);\n\n\tfor (i = (unsigned long)entry->virtual, j = 0; j < pages;\n\t     i += PAGE_SIZE, j++) {\n\t\tentry->pagelist[j] = vmalloc_to_page((void *)i);\n\t\tif (!entry->pagelist[j])\n\t\t\tgoto failed;\n\t\tSetPageReserved(entry->pagelist[j]);\n\t}\n\n\trequest->handle = entry->handle;\n\n\tdev->sg = entry;\n\n#if DEBUG_SCATTER\n\t \n\t{\n\t\tint error = 0;\n\n\t\tfor (i = 0; i < pages; i++) {\n\t\t\tunsigned long *tmp;\n\n\t\t\ttmp = page_address(entry->pagelist[i]);\n\t\t\tfor (j = 0;\n\t\t\t     j < PAGE_SIZE / sizeof(unsigned long);\n\t\t\t     j++, tmp++) {\n\t\t\t\t*tmp = 0xcafebabe;\n\t\t\t}\n\t\t\ttmp = (unsigned long *)((u8 *) entry->virtual +\n\t\t\t\t\t\t(PAGE_SIZE * i));\n\t\t\tfor (j = 0;\n\t\t\t     j < PAGE_SIZE / sizeof(unsigned long);\n\t\t\t     j++, tmp++) {\n\t\t\t\tif (*tmp != 0xcafebabe && error == 0) {\n\t\t\t\t\terror = 1;\n\t\t\t\t\tDRM_ERROR(\"Scatter allocation error, \"\n\t\t\t\t\t\t  \"pagelist does not match \"\n\t\t\t\t\t\t  \"virtual mapping\\n\");\n\t\t\t\t}\n\t\t\t}\n\t\t\ttmp = page_address(entry->pagelist[i]);\n\t\t\tfor (j = 0;\n\t\t\t     j < PAGE_SIZE / sizeof(unsigned long);\n\t\t\t     j++, tmp++) {\n\t\t\t\t*tmp = 0;\n\t\t\t}\n\t\t}\n\t\tif (error == 0)\n\t\t\tDRM_ERROR(\"Scatter allocation matches pagelist\\n\");\n\t}\n#endif\n\n\treturn 0;\n\n      failed:\n\tdrm_sg_cleanup(entry);\n\treturn -ENOMEM;\n}\n\nint drm_legacy_sg_free(struct drm_device *dev, void *data,\n\t\t       struct drm_file *file_priv)\n{\n\tstruct drm_scatter_gather *request = data;\n\tstruct drm_sg_mem *entry;\n\n\tif (!drm_core_check_feature(dev, DRIVER_LEGACY))\n\t\treturn -EOPNOTSUPP;\n\n\tif (!drm_core_check_feature(dev, DRIVER_SG))\n\t\treturn -EOPNOTSUPP;\n\n\tentry = dev->sg;\n\tdev->sg = NULL;\n\n\tif (!entry || entry->handle != request->handle)\n\t\treturn -EINVAL;\n\n\tDRM_DEBUG(\"virtual  = %p\\n\", entry->virtual);\n\n\tdrm_sg_cleanup(entry);\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}