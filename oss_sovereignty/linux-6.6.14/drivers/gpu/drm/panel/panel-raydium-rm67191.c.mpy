{
  "module_name": "panel-raydium-rm67191.c",
  "hash_id": "7cb7edf68c23e9ef3b0e172933c76ca06f9f8cf978c57fb296b976c1a6794969",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/panel/panel-raydium-rm67191.c",
  "human_readable_source": "\n \n\n#include <linux/backlight.h>\n#include <linux/delay.h>\n#include <linux/gpio/consumer.h>\n#include <linux/media-bus-format.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/regulator/consumer.h>\n\n#include <video/mipi_display.h>\n#include <video/of_videomode.h>\n#include <video/videomode.h>\n\n#include <drm/drm_crtc.h>\n#include <drm/drm_mipi_dsi.h>\n#include <drm/drm_panel.h>\n\n \n#define COL_FMT_16BPP 0x55\n#define COL_FMT_18BPP 0x66\n#define COL_FMT_24BPP 0x77\n\n \n#define WRMAUCCTR 0xFE\n\n \nstruct cmd_set_entry {\n\tu8 cmd;\n\tu8 param;\n};\n\n \nstatic const struct cmd_set_entry manufacturer_cmd_set[] = {\n\t{0xFE, 0x0B},\n\t{0x28, 0x40},\n\t{0x29, 0x4F},\n\t{0xFE, 0x0E},\n\t{0x4B, 0x00},\n\t{0x4C, 0x0F},\n\t{0x4D, 0x20},\n\t{0x4E, 0x40},\n\t{0x4F, 0x60},\n\t{0x50, 0xA0},\n\t{0x51, 0xC0},\n\t{0x52, 0xE0},\n\t{0x53, 0xFF},\n\t{0xFE, 0x0D},\n\t{0x18, 0x08},\n\t{0x42, 0x00},\n\t{0x08, 0x41},\n\t{0x46, 0x02},\n\t{0x72, 0x09},\n\t{0xFE, 0x0A},\n\t{0x24, 0x17},\n\t{0x04, 0x07},\n\t{0x1A, 0x0C},\n\t{0x0F, 0x44},\n\t{0xFE, 0x04},\n\t{0x00, 0x0C},\n\t{0x05, 0x08},\n\t{0x06, 0x08},\n\t{0x08, 0x08},\n\t{0x09, 0x08},\n\t{0x0A, 0xE6},\n\t{0x0B, 0x8C},\n\t{0x1A, 0x12},\n\t{0x1E, 0xE0},\n\t{0x29, 0x93},\n\t{0x2A, 0x93},\n\t{0x2F, 0x02},\n\t{0x31, 0x02},\n\t{0x33, 0x05},\n\t{0x37, 0x2D},\n\t{0x38, 0x2D},\n\t{0x3A, 0x1E},\n\t{0x3B, 0x1E},\n\t{0x3D, 0x27},\n\t{0x3F, 0x80},\n\t{0x40, 0x40},\n\t{0x41, 0xE0},\n\t{0x4F, 0x2F},\n\t{0x50, 0x1E},\n\t{0xFE, 0x06},\n\t{0x00, 0xCC},\n\t{0x05, 0x05},\n\t{0x07, 0xA2},\n\t{0x08, 0xCC},\n\t{0x0D, 0x03},\n\t{0x0F, 0xA2},\n\t{0x32, 0xCC},\n\t{0x37, 0x05},\n\t{0x39, 0x83},\n\t{0x3A, 0xCC},\n\t{0x41, 0x04},\n\t{0x43, 0x83},\n\t{0x44, 0xCC},\n\t{0x49, 0x05},\n\t{0x4B, 0xA2},\n\t{0x4C, 0xCC},\n\t{0x51, 0x03},\n\t{0x53, 0xA2},\n\t{0x75, 0xCC},\n\t{0x7A, 0x03},\n\t{0x7C, 0x83},\n\t{0x7D, 0xCC},\n\t{0x82, 0x02},\n\t{0x84, 0x83},\n\t{0x85, 0xEC},\n\t{0x86, 0x0F},\n\t{0x87, 0xFF},\n\t{0x88, 0x00},\n\t{0x8A, 0x02},\n\t{0x8C, 0xA2},\n\t{0x8D, 0xEA},\n\t{0x8E, 0x01},\n\t{0x8F, 0xE8},\n\t{0xFE, 0x06},\n\t{0x90, 0x0A},\n\t{0x92, 0x06},\n\t{0x93, 0xA0},\n\t{0x94, 0xA8},\n\t{0x95, 0xEC},\n\t{0x96, 0x0F},\n\t{0x97, 0xFF},\n\t{0x98, 0x00},\n\t{0x9A, 0x02},\n\t{0x9C, 0xA2},\n\t{0xAC, 0x04},\n\t{0xFE, 0x06},\n\t{0xB1, 0x12},\n\t{0xB2, 0x17},\n\t{0xB3, 0x17},\n\t{0xB4, 0x17},\n\t{0xB5, 0x17},\n\t{0xB6, 0x11},\n\t{0xB7, 0x08},\n\t{0xB8, 0x09},\n\t{0xB9, 0x06},\n\t{0xBA, 0x07},\n\t{0xBB, 0x17},\n\t{0xBC, 0x17},\n\t{0xBD, 0x17},\n\t{0xBE, 0x17},\n\t{0xBF, 0x17},\n\t{0xC0, 0x17},\n\t{0xC1, 0x17},\n\t{0xC2, 0x17},\n\t{0xC3, 0x17},\n\t{0xC4, 0x0F},\n\t{0xC5, 0x0E},\n\t{0xC6, 0x00},\n\t{0xC7, 0x01},\n\t{0xC8, 0x10},\n\t{0xFE, 0x06},\n\t{0x95, 0xEC},\n\t{0x8D, 0xEE},\n\t{0x44, 0xEC},\n\t{0x4C, 0xEC},\n\t{0x32, 0xEC},\n\t{0x3A, 0xEC},\n\t{0x7D, 0xEC},\n\t{0x75, 0xEC},\n\t{0x00, 0xEC},\n\t{0x08, 0xEC},\n\t{0x85, 0xEC},\n\t{0xA6, 0x21},\n\t{0xA7, 0x05},\n\t{0xA9, 0x06},\n\t{0x82, 0x06},\n\t{0x41, 0x06},\n\t{0x7A, 0x07},\n\t{0x37, 0x07},\n\t{0x05, 0x06},\n\t{0x49, 0x06},\n\t{0x0D, 0x04},\n\t{0x51, 0x04},\n};\n\nstatic const u32 rad_bus_formats[] = {\n\tMEDIA_BUS_FMT_RGB888_1X24,\n\tMEDIA_BUS_FMT_RGB666_1X18,\n\tMEDIA_BUS_FMT_RGB565_1X16,\n};\n\nstatic const u32 rad_bus_flags = DRM_BUS_FLAG_DE_LOW |\n\t\t\t\t DRM_BUS_FLAG_PIXDATA_SAMPLE_POSEDGE;\n\nstruct rad_panel {\n\tstruct drm_panel panel;\n\tstruct mipi_dsi_device *dsi;\n\n\tstruct gpio_desc *reset;\n\tstruct backlight_device *backlight;\n\n\tstruct regulator_bulk_data *supplies;\n\tunsigned int num_supplies;\n\n\tbool prepared;\n\tbool enabled;\n};\n\nstatic const struct drm_display_mode default_mode = {\n\t.clock = 132000,\n\t.hdisplay = 1080,\n\t.hsync_start = 1080 + 20,\n\t.hsync_end = 1080 + 20 + 2,\n\t.htotal = 1080 + 20 + 2 + 34,\n\t.vdisplay = 1920,\n\t.vsync_start = 1920 + 10,\n\t.vsync_end = 1920 + 10 + 2,\n\t.vtotal = 1920 + 10 + 2 + 4,\n\t.width_mm = 68,\n\t.height_mm = 121,\n\t.flags = DRM_MODE_FLAG_NHSYNC |\n\t\t DRM_MODE_FLAG_NVSYNC,\n};\n\nstatic inline struct rad_panel *to_rad_panel(struct drm_panel *panel)\n{\n\treturn container_of(panel, struct rad_panel, panel);\n}\n\nstatic int rad_panel_push_cmd_list(struct mipi_dsi_device *dsi)\n{\n\tsize_t i;\n\tsize_t count = ARRAY_SIZE(manufacturer_cmd_set);\n\tint ret = 0;\n\n\tfor (i = 0; i < count; i++) {\n\t\tconst struct cmd_set_entry *entry = &manufacturer_cmd_set[i];\n\t\tu8 buffer[2] = { entry->cmd, entry->param };\n\n\t\tret = mipi_dsi_generic_write(dsi, &buffer, sizeof(buffer));\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\treturn ret;\n};\n\nstatic int color_format_from_dsi_format(enum mipi_dsi_pixel_format format)\n{\n\tswitch (format) {\n\tcase MIPI_DSI_FMT_RGB565:\n\t\treturn COL_FMT_16BPP;\n\tcase MIPI_DSI_FMT_RGB666:\n\tcase MIPI_DSI_FMT_RGB666_PACKED:\n\t\treturn COL_FMT_18BPP;\n\tcase MIPI_DSI_FMT_RGB888:\n\t\treturn COL_FMT_24BPP;\n\tdefault:\n\t\treturn COL_FMT_24BPP;  \n\t}\n};\n\nstatic int rad_panel_prepare(struct drm_panel *panel)\n{\n\tstruct rad_panel *rad = to_rad_panel(panel);\n\tint ret;\n\n\tif (rad->prepared)\n\t\treturn 0;\n\n\tret = regulator_bulk_enable(rad->num_supplies, rad->supplies);\n\tif (ret)\n\t\treturn ret;\n\n\tif (rad->reset) {\n\t\tgpiod_set_value_cansleep(rad->reset, 1);\n\t\tusleep_range(3000, 5000);\n\t\tgpiod_set_value_cansleep(rad->reset, 0);\n\t\tusleep_range(18000, 20000);\n\t}\n\n\trad->prepared = true;\n\n\treturn 0;\n}\n\nstatic int rad_panel_unprepare(struct drm_panel *panel)\n{\n\tstruct rad_panel *rad = to_rad_panel(panel);\n\tint ret;\n\n\tif (!rad->prepared)\n\t\treturn 0;\n\n\t \n\tif (rad->reset) {\n\t\tgpiod_set_value_cansleep(rad->reset, 1);\n\t\tusleep_range(15000, 17000);\n\t\tgpiod_set_value_cansleep(rad->reset, 0);\n\t}\n\n\tret = regulator_bulk_disable(rad->num_supplies, rad->supplies);\n\tif (ret)\n\t\treturn ret;\n\n\trad->prepared = false;\n\n\treturn 0;\n}\n\nstatic int rad_panel_enable(struct drm_panel *panel)\n{\n\tstruct rad_panel *rad = to_rad_panel(panel);\n\tstruct mipi_dsi_device *dsi = rad->dsi;\n\tstruct device *dev = &dsi->dev;\n\tint color_format = color_format_from_dsi_format(dsi->format);\n\tint ret;\n\n\tif (rad->enabled)\n\t\treturn 0;\n\n\tdsi->mode_flags |= MIPI_DSI_MODE_LPM;\n\n\tret = rad_panel_push_cmd_list(dsi);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"Failed to send MCS (%d)\\n\", ret);\n\t\tgoto fail;\n\t}\n\n\t \n\tret = mipi_dsi_generic_write(dsi, (u8[]){ WRMAUCCTR, 0x00 }, 2);\n\tif (ret < 0)\n\t\tgoto fail;\n\n\t \n\tret = mipi_dsi_dcs_soft_reset(dsi);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"Failed to do Software Reset (%d)\\n\", ret);\n\t\tgoto fail;\n\t}\n\n\tusleep_range(15000, 17000);\n\n\t \n\tret = mipi_dsi_generic_write(dsi, (u8[]){ 0xC2, 0x0B }, 2);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"Failed to set DSI mode (%d)\\n\", ret);\n\t\tgoto fail;\n\t}\n\t \n\tret = mipi_dsi_dcs_set_tear_on(dsi, MIPI_DSI_DCS_TEAR_MODE_VBLANK);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"Failed to set tear ON (%d)\\n\", ret);\n\t\tgoto fail;\n\t}\n\t \n\tret = mipi_dsi_dcs_set_tear_scanline(dsi, 0x380);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"Failed to set tear scanline (%d)\\n\", ret);\n\t\tgoto fail;\n\t}\n\t \n\tret = mipi_dsi_dcs_set_pixel_format(dsi, color_format);\n\tdev_dbg(dev, \"Interface color format set to 0x%x\\n\", color_format);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"Failed to set pixel format (%d)\\n\", ret);\n\t\tgoto fail;\n\t}\n\t \n\tret = mipi_dsi_dcs_exit_sleep_mode(dsi);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"Failed to exit sleep mode (%d)\\n\", ret);\n\t\tgoto fail;\n\t}\n\n\tusleep_range(5000, 7000);\n\n\tret = mipi_dsi_dcs_set_display_on(dsi);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"Failed to set display ON (%d)\\n\", ret);\n\t\tgoto fail;\n\t}\n\n\tbacklight_enable(rad->backlight);\n\n\trad->enabled = true;\n\n\treturn 0;\n\nfail:\n\tgpiod_set_value_cansleep(rad->reset, 1);\n\n\treturn ret;\n}\n\nstatic int rad_panel_disable(struct drm_panel *panel)\n{\n\tstruct rad_panel *rad = to_rad_panel(panel);\n\tstruct mipi_dsi_device *dsi = rad->dsi;\n\tstruct device *dev = &dsi->dev;\n\tint ret;\n\n\tif (!rad->enabled)\n\t\treturn 0;\n\n\tdsi->mode_flags |= MIPI_DSI_MODE_LPM;\n\n\tbacklight_disable(rad->backlight);\n\n\tusleep_range(10000, 12000);\n\n\tret = mipi_dsi_dcs_set_display_off(dsi);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"Failed to set display OFF (%d)\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tusleep_range(5000, 10000);\n\n\tret = mipi_dsi_dcs_enter_sleep_mode(dsi);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"Failed to enter sleep mode (%d)\\n\", ret);\n\t\treturn ret;\n\t}\n\n\trad->enabled = false;\n\n\treturn 0;\n}\n\nstatic int rad_panel_get_modes(struct drm_panel *panel,\n\t\t\t       struct drm_connector *connector)\n{\n\tstruct drm_display_mode *mode;\n\n\tmode = drm_mode_duplicate(connector->dev, &default_mode);\n\tif (!mode) {\n\t\tdev_err(panel->dev, \"failed to add mode %ux%u@%u\\n\",\n\t\t\tdefault_mode.hdisplay, default_mode.vdisplay,\n\t\t\tdrm_mode_vrefresh(&default_mode));\n\t\treturn -ENOMEM;\n\t}\n\n\tdrm_mode_set_name(mode);\n\tmode->type = DRM_MODE_TYPE_DRIVER | DRM_MODE_TYPE_PREFERRED;\n\tdrm_mode_probed_add(connector, mode);\n\n\tconnector->display_info.width_mm = mode->width_mm;\n\tconnector->display_info.height_mm = mode->height_mm;\n\tconnector->display_info.bus_flags = rad_bus_flags;\n\n\tdrm_display_info_set_bus_formats(&connector->display_info,\n\t\t\t\t\t rad_bus_formats,\n\t\t\t\t\t ARRAY_SIZE(rad_bus_formats));\n\treturn 1;\n}\n\nstatic int rad_bl_get_brightness(struct backlight_device *bl)\n{\n\tstruct mipi_dsi_device *dsi = bl_get_data(bl);\n\tstruct rad_panel *rad = mipi_dsi_get_drvdata(dsi);\n\tu16 brightness;\n\tint ret;\n\n\tif (!rad->prepared)\n\t\treturn 0;\n\n\tdsi->mode_flags &= ~MIPI_DSI_MODE_LPM;\n\n\tret = mipi_dsi_dcs_get_display_brightness(dsi, &brightness);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tbl->props.brightness = brightness;\n\n\treturn brightness & 0xff;\n}\n\nstatic int rad_bl_update_status(struct backlight_device *bl)\n{\n\tstruct mipi_dsi_device *dsi = bl_get_data(bl);\n\tstruct rad_panel *rad = mipi_dsi_get_drvdata(dsi);\n\tint ret = 0;\n\n\tif (!rad->prepared)\n\t\treturn 0;\n\n\tdsi->mode_flags &= ~MIPI_DSI_MODE_LPM;\n\n\tret = mipi_dsi_dcs_set_display_brightness(dsi, bl->props.brightness);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn 0;\n}\n\nstatic const struct backlight_ops rad_bl_ops = {\n\t.update_status = rad_bl_update_status,\n\t.get_brightness = rad_bl_get_brightness,\n};\n\nstatic const struct drm_panel_funcs rad_panel_funcs = {\n\t.prepare = rad_panel_prepare,\n\t.unprepare = rad_panel_unprepare,\n\t.enable = rad_panel_enable,\n\t.disable = rad_panel_disable,\n\t.get_modes = rad_panel_get_modes,\n};\n\nstatic const char * const rad_supply_names[] = {\n\t\"v3p3\",\n\t\"v1p8\",\n};\n\nstatic int rad_init_regulators(struct rad_panel *rad)\n{\n\tstruct device *dev = &rad->dsi->dev;\n\tint i;\n\n\trad->num_supplies = ARRAY_SIZE(rad_supply_names);\n\trad->supplies = devm_kcalloc(dev, rad->num_supplies,\n\t\t\t\t     sizeof(*rad->supplies), GFP_KERNEL);\n\tif (!rad->supplies)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < rad->num_supplies; i++)\n\t\trad->supplies[i].supply = rad_supply_names[i];\n\n\treturn devm_regulator_bulk_get(dev, rad->num_supplies, rad->supplies);\n};\n\nstatic int rad_panel_probe(struct mipi_dsi_device *dsi)\n{\n\tstruct device *dev = &dsi->dev;\n\tstruct device_node *np = dev->of_node;\n\tstruct rad_panel *panel;\n\tstruct backlight_properties bl_props;\n\tint ret;\n\tu32 video_mode;\n\n\tpanel = devm_kzalloc(&dsi->dev, sizeof(*panel), GFP_KERNEL);\n\tif (!panel)\n\t\treturn -ENOMEM;\n\n\tmipi_dsi_set_drvdata(dsi, panel);\n\n\tpanel->dsi = dsi;\n\n\tdsi->format = MIPI_DSI_FMT_RGB888;\n\tdsi->mode_flags =  MIPI_DSI_MODE_VIDEO_HSE | MIPI_DSI_MODE_VIDEO;\n\n\tret = of_property_read_u32(np, \"video-mode\", &video_mode);\n\tif (!ret) {\n\t\tswitch (video_mode) {\n\t\tcase 0:\n\t\t\t \n\t\t\tdsi->mode_flags |= MIPI_DSI_MODE_VIDEO_BURST;\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\t \n\t\t\tbreak;\n\t\tcase 2:\n\t\t\t \n\t\t\tdsi->mode_flags |= MIPI_DSI_MODE_VIDEO_SYNC_PULSE;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdev_warn(dev, \"invalid video mode %d\\n\", video_mode);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tret = of_property_read_u32(np, \"dsi-lanes\", &dsi->lanes);\n\tif (ret) {\n\t\tdev_err(dev, \"Failed to get dsi-lanes property (%d)\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tpanel->reset = devm_gpiod_get_optional(dev, \"reset\", GPIOD_OUT_LOW);\n\tif (IS_ERR(panel->reset))\n\t\treturn PTR_ERR(panel->reset);\n\n\tmemset(&bl_props, 0, sizeof(bl_props));\n\tbl_props.type = BACKLIGHT_RAW;\n\tbl_props.brightness = 255;\n\tbl_props.max_brightness = 255;\n\n\tpanel->backlight = devm_backlight_device_register(dev, dev_name(dev),\n\t\t\t\t\t\t\t  dev, dsi, &rad_bl_ops,\n\t\t\t\t\t\t\t  &bl_props);\n\tif (IS_ERR(panel->backlight)) {\n\t\tret = PTR_ERR(panel->backlight);\n\t\tdev_err(dev, \"Failed to register backlight (%d)\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = rad_init_regulators(panel);\n\tif (ret)\n\t\treturn ret;\n\n\tdrm_panel_init(&panel->panel, dev, &rad_panel_funcs,\n\t\t       DRM_MODE_CONNECTOR_DSI);\n\tdev_set_drvdata(dev, panel);\n\n\tdrm_panel_add(&panel->panel);\n\n\tret = mipi_dsi_attach(dsi);\n\tif (ret)\n\t\tdrm_panel_remove(&panel->panel);\n\n\treturn ret;\n}\n\nstatic void rad_panel_remove(struct mipi_dsi_device *dsi)\n{\n\tstruct rad_panel *rad = mipi_dsi_get_drvdata(dsi);\n\tstruct device *dev = &dsi->dev;\n\tint ret;\n\n\tret = mipi_dsi_detach(dsi);\n\tif (ret)\n\t\tdev_err(dev, \"Failed to detach from host (%d)\\n\", ret);\n\n\tdrm_panel_remove(&rad->panel);\n}\n\nstatic void rad_panel_shutdown(struct mipi_dsi_device *dsi)\n{\n\tstruct rad_panel *rad = mipi_dsi_get_drvdata(dsi);\n\n\trad_panel_disable(&rad->panel);\n\trad_panel_unprepare(&rad->panel);\n}\n\nstatic const struct of_device_id rad_of_match[] = {\n\t{ .compatible = \"raydium,rm67191\", },\n\t{   }\n};\nMODULE_DEVICE_TABLE(of, rad_of_match);\n\nstatic struct mipi_dsi_driver rad_panel_driver = {\n\t.driver = {\n\t\t.name = \"panel-raydium-rm67191\",\n\t\t.of_match_table = rad_of_match,\n\t},\n\t.probe = rad_panel_probe,\n\t.remove = rad_panel_remove,\n\t.shutdown = rad_panel_shutdown,\n};\nmodule_mipi_dsi_driver(rad_panel_driver);\n\nMODULE_AUTHOR(\"Robert Chiras <robert.chiras@nxp.com>\");\nMODULE_DESCRIPTION(\"DRM Driver for Raydium RM67191 MIPI DSI panel\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}