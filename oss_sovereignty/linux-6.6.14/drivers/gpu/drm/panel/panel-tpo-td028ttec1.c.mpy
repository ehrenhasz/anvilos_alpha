{
  "module_name": "panel-tpo-td028ttec1.c",
  "hash_id": "4b4f18da9139107dbbfbbc1562f745ff56108909ff87959530bafc344fd26fbd",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/panel/panel-tpo-td028ttec1.c",
  "human_readable_source": "\n \n\n#include <linux/delay.h>\n#include <linux/module.h>\n#include <linux/spi/spi.h>\n\n#include <drm/drm_connector.h>\n#include <drm/drm_modes.h>\n#include <drm/drm_panel.h>\n\n#define JBT_COMMAND\t\t\t0x000\n#define JBT_DATA\t\t\t0x100\n\n#define JBT_REG_SLEEP_IN\t\t0x10\n#define JBT_REG_SLEEP_OUT\t\t0x11\n\n#define JBT_REG_DISPLAY_OFF\t\t0x28\n#define JBT_REG_DISPLAY_ON\t\t0x29\n\n#define JBT_REG_RGB_FORMAT\t\t0x3a\n#define JBT_REG_QUAD_RATE\t\t0x3b\n\n#define JBT_REG_POWER_ON_OFF\t\t0xb0\n#define JBT_REG_BOOSTER_OP\t\t0xb1\n#define JBT_REG_BOOSTER_MODE\t\t0xb2\n#define JBT_REG_BOOSTER_FREQ\t\t0xb3\n#define JBT_REG_OPAMP_SYSCLK\t\t0xb4\n#define JBT_REG_VSC_VOLTAGE\t\t0xb5\n#define JBT_REG_VCOM_VOLTAGE\t\t0xb6\n#define JBT_REG_EXT_DISPL\t\t0xb7\n#define JBT_REG_OUTPUT_CONTROL\t\t0xb8\n#define JBT_REG_DCCLK_DCEV\t\t0xb9\n#define JBT_REG_DISPLAY_MODE1\t\t0xba\n#define JBT_REG_DISPLAY_MODE2\t\t0xbb\n#define JBT_REG_DISPLAY_MODE\t\t0xbc\n#define JBT_REG_ASW_SLEW\t\t0xbd\n#define JBT_REG_DUMMY_DISPLAY\t\t0xbe\n#define JBT_REG_DRIVE_SYSTEM\t\t0xbf\n\n#define JBT_REG_SLEEP_OUT_FR_A\t\t0xc0\n#define JBT_REG_SLEEP_OUT_FR_B\t\t0xc1\n#define JBT_REG_SLEEP_OUT_FR_C\t\t0xc2\n#define JBT_REG_SLEEP_IN_LCCNT_D\t0xc3\n#define JBT_REG_SLEEP_IN_LCCNT_E\t0xc4\n#define JBT_REG_SLEEP_IN_LCCNT_F\t0xc5\n#define JBT_REG_SLEEP_IN_LCCNT_G\t0xc6\n\n#define JBT_REG_GAMMA1_FINE_1\t\t0xc7\n#define JBT_REG_GAMMA1_FINE_2\t\t0xc8\n#define JBT_REG_GAMMA1_INCLINATION\t0xc9\n#define JBT_REG_GAMMA1_BLUE_OFFSET\t0xca\n\n#define JBT_REG_BLANK_CONTROL\t\t0xcf\n#define JBT_REG_BLANK_TH_TV\t\t0xd0\n#define JBT_REG_CKV_ON_OFF\t\t0xd1\n#define JBT_REG_CKV_1_2\t\t\t0xd2\n#define JBT_REG_OEV_TIMING\t\t0xd3\n#define JBT_REG_ASW_TIMING_1\t\t0xd4\n#define JBT_REG_ASW_TIMING_2\t\t0xd5\n\n#define JBT_REG_HCLOCK_VGA\t\t0xec\n#define JBT_REG_HCLOCK_QVGA\t\t0xed\n\nstruct td028ttec1_panel {\n\tstruct drm_panel panel;\n\n\tstruct spi_device *spi;\n};\n\n#define to_td028ttec1_device(p) container_of(p, struct td028ttec1_panel, panel)\n\n \nstatic int noinline_for_stack\njbt_ret_write_0(struct td028ttec1_panel *lcd, u8 reg, int *err)\n{\n\tstruct spi_device *spi = lcd->spi;\n\tu16 tx_buf = JBT_COMMAND | reg;\n\tint ret;\n\n\tif (err && *err)\n\t\treturn *err;\n\n\tret = spi_write(spi, (u8 *)&tx_buf, sizeof(tx_buf));\n\tif (ret < 0) {\n\t\tdev_err(&spi->dev, \"%s: SPI write failed: %d\\n\", __func__, ret);\n\t\tif (err)\n\t\t\t*err = ret;\n\t}\n\n\treturn ret;\n}\n\nstatic int noinline_for_stack\njbt_reg_write_1(struct td028ttec1_panel *lcd,\n\t\tu8 reg, u8 data, int *err)\n{\n\tstruct spi_device *spi = lcd->spi;\n\tu16 tx_buf[2];\n\tint ret;\n\n\tif (err && *err)\n\t\treturn *err;\n\n\ttx_buf[0] = JBT_COMMAND | reg;\n\ttx_buf[1] = JBT_DATA | data;\n\n\tret = spi_write(spi, (u8 *)tx_buf, sizeof(tx_buf));\n\tif (ret < 0) {\n\t\tdev_err(&spi->dev, \"%s: SPI write failed: %d\\n\", __func__, ret);\n\t\tif (err)\n\t\t\t*err = ret;\n\t}\n\n\treturn ret;\n}\n\nstatic int noinline_for_stack\njbt_reg_write_2(struct td028ttec1_panel *lcd,\n\t\tu8 reg, u16 data, int *err)\n{\n\tstruct spi_device *spi = lcd->spi;\n\tu16 tx_buf[3];\n\tint ret;\n\n\tif (err && *err)\n\t\treturn *err;\n\n\ttx_buf[0] = JBT_COMMAND | reg;\n\ttx_buf[1] = JBT_DATA | (data >> 8);\n\ttx_buf[2] = JBT_DATA | (data & 0xff);\n\n\tret = spi_write(spi, (u8 *)tx_buf, sizeof(tx_buf));\n\tif (ret < 0) {\n\t\tdev_err(&spi->dev, \"%s: SPI write failed: %d\\n\", __func__, ret);\n\t\tif (err)\n\t\t\t*err = ret;\n\t}\n\n\treturn ret;\n}\n\nstatic int td028ttec1_prepare(struct drm_panel *panel)\n{\n\tstruct td028ttec1_panel *lcd = to_td028ttec1_device(panel);\n\tunsigned int i;\n\tint ret = 0;\n\n\t \n\tfor (i = 0; i < 3; ++i) {\n\t\tjbt_ret_write_0(lcd, 0x00, &ret);\n\t\tusleep_range(1000, 2000);\n\t}\n\n\t \n\tjbt_reg_write_1(lcd, JBT_REG_POWER_ON_OFF, 0x17, &ret);\n\n\t \n\tjbt_reg_write_1(lcd, JBT_REG_DISPLAY_MODE, 0x80, &ret);\n\n\t \n\tjbt_reg_write_1(lcd, JBT_REG_QUAD_RATE, 0x00, &ret);\n\n\t \n\tjbt_reg_write_1(lcd, JBT_REG_POWER_ON_OFF, 0x16, &ret);\n\n\t \n\tjbt_reg_write_2(lcd, JBT_REG_OUTPUT_CONTROL, 0xfff9, &ret);\n\n\t \n\tjbt_ret_write_0(lcd, JBT_REG_SLEEP_OUT, &ret);\n\n\t \n\n\t \n\tjbt_reg_write_1(lcd, JBT_REG_DISPLAY_MODE1, 0x01, &ret);\n\tjbt_reg_write_1(lcd, JBT_REG_DISPLAY_MODE2, 0x00, &ret);\n\tjbt_reg_write_1(lcd, JBT_REG_RGB_FORMAT, 0x60, &ret);\n\tjbt_reg_write_1(lcd, JBT_REG_DRIVE_SYSTEM, 0x10, &ret);\n\tjbt_reg_write_1(lcd, JBT_REG_BOOSTER_OP, 0x56, &ret);\n\tjbt_reg_write_1(lcd, JBT_REG_BOOSTER_MODE, 0x33, &ret);\n\tjbt_reg_write_1(lcd, JBT_REG_BOOSTER_FREQ, 0x11, &ret);\n\tjbt_reg_write_1(lcd, JBT_REG_BOOSTER_FREQ, 0x11, &ret);\n\tjbt_reg_write_1(lcd, JBT_REG_OPAMP_SYSCLK, 0x02, &ret);\n\tjbt_reg_write_1(lcd, JBT_REG_VSC_VOLTAGE, 0x2b, &ret);\n\tjbt_reg_write_1(lcd, JBT_REG_VCOM_VOLTAGE, 0x40, &ret);\n\tjbt_reg_write_1(lcd, JBT_REG_EXT_DISPL, 0x03, &ret);\n\tjbt_reg_write_1(lcd, JBT_REG_DCCLK_DCEV, 0x04, &ret);\n\t \n\tjbt_reg_write_1(lcd, JBT_REG_ASW_SLEW, 0x04, &ret);\n\tjbt_reg_write_1(lcd, JBT_REG_DUMMY_DISPLAY, 0x00, &ret);\n\n\tjbt_reg_write_1(lcd, JBT_REG_SLEEP_OUT_FR_A, 0x11, &ret);\n\tjbt_reg_write_1(lcd, JBT_REG_SLEEP_OUT_FR_B, 0x11, &ret);\n\tjbt_reg_write_1(lcd, JBT_REG_SLEEP_OUT_FR_C, 0x11, &ret);\n\tjbt_reg_write_2(lcd, JBT_REG_SLEEP_IN_LCCNT_D, 0x2040, &ret);\n\tjbt_reg_write_2(lcd, JBT_REG_SLEEP_IN_LCCNT_E, 0x60c0, &ret);\n\tjbt_reg_write_2(lcd, JBT_REG_SLEEP_IN_LCCNT_F, 0x1020, &ret);\n\tjbt_reg_write_2(lcd, JBT_REG_SLEEP_IN_LCCNT_G, 0x60c0, &ret);\n\n\tjbt_reg_write_2(lcd, JBT_REG_GAMMA1_FINE_1, 0x5533, &ret);\n\tjbt_reg_write_1(lcd, JBT_REG_GAMMA1_FINE_2, 0x00, &ret);\n\tjbt_reg_write_1(lcd, JBT_REG_GAMMA1_INCLINATION, 0x00, &ret);\n\tjbt_reg_write_1(lcd, JBT_REG_GAMMA1_BLUE_OFFSET, 0x00, &ret);\n\n\tjbt_reg_write_2(lcd, JBT_REG_HCLOCK_VGA, 0x1f0, &ret);\n\tjbt_reg_write_1(lcd, JBT_REG_BLANK_CONTROL, 0x02, &ret);\n\tjbt_reg_write_2(lcd, JBT_REG_BLANK_TH_TV, 0x0804, &ret);\n\n\tjbt_reg_write_1(lcd, JBT_REG_CKV_ON_OFF, 0x01, &ret);\n\tjbt_reg_write_2(lcd, JBT_REG_CKV_1_2, 0x0000, &ret);\n\n\tjbt_reg_write_2(lcd, JBT_REG_OEV_TIMING, 0x0d0e, &ret);\n\tjbt_reg_write_2(lcd, JBT_REG_ASW_TIMING_1, 0x11a4, &ret);\n\tjbt_reg_write_1(lcd, JBT_REG_ASW_TIMING_2, 0x0e, &ret);\n\n\treturn ret;\n}\n\nstatic int td028ttec1_enable(struct drm_panel *panel)\n{\n\tstruct td028ttec1_panel *lcd = to_td028ttec1_device(panel);\n\n\treturn jbt_ret_write_0(lcd, JBT_REG_DISPLAY_ON, NULL);\n}\n\nstatic int td028ttec1_disable(struct drm_panel *panel)\n{\n\tstruct td028ttec1_panel *lcd = to_td028ttec1_device(panel);\n\n\tjbt_ret_write_0(lcd, JBT_REG_DISPLAY_OFF, NULL);\n\n\treturn 0;\n}\n\nstatic int td028ttec1_unprepare(struct drm_panel *panel)\n{\n\tstruct td028ttec1_panel *lcd = to_td028ttec1_device(panel);\n\n\tjbt_reg_write_2(lcd, JBT_REG_OUTPUT_CONTROL, 0x8002, NULL);\n\tjbt_ret_write_0(lcd, JBT_REG_SLEEP_IN, NULL);\n\tjbt_reg_write_1(lcd, JBT_REG_POWER_ON_OFF, 0x00, NULL);\n\n\treturn 0;\n}\n\nstatic const struct drm_display_mode td028ttec1_mode = {\n\t.clock = 22153,\n\t.hdisplay = 480,\n\t.hsync_start = 480 + 24,\n\t.hsync_end = 480 + 24 + 8,\n\t.htotal = 480 + 24 + 8 + 8,\n\t.vdisplay = 640,\n\t.vsync_start = 640 + 4,\n\t.vsync_end = 640 + 4 + 2,\n\t.vtotal = 640 + 4 + 2 + 2,\n\t.type = DRM_MODE_TYPE_DRIVER | DRM_MODE_TYPE_PREFERRED,\n\t.flags = DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_NVSYNC,\n\t.width_mm = 43,\n\t.height_mm = 58,\n};\n\nstatic int td028ttec1_get_modes(struct drm_panel *panel,\n\t\t\t\tstruct drm_connector *connector)\n{\n\tstruct drm_display_mode *mode;\n\n\tmode = drm_mode_duplicate(connector->dev, &td028ttec1_mode);\n\tif (!mode)\n\t\treturn -ENOMEM;\n\n\tdrm_mode_set_name(mode);\n\tdrm_mode_probed_add(connector, mode);\n\n\tconnector->display_info.width_mm = td028ttec1_mode.width_mm;\n\tconnector->display_info.height_mm = td028ttec1_mode.height_mm;\n\t \n\tconnector->display_info.bus_flags = DRM_BUS_FLAG_DE_HIGH\n\t\t\t\t\t  | DRM_BUS_FLAG_SYNC_SAMPLE_NEGEDGE\n\t\t\t\t\t  | DRM_BUS_FLAG_PIXDATA_SAMPLE_POSEDGE;\n\n\treturn 1;\n}\n\nstatic const struct drm_panel_funcs td028ttec1_funcs = {\n\t.prepare = td028ttec1_prepare,\n\t.enable = td028ttec1_enable,\n\t.disable = td028ttec1_disable,\n\t.unprepare = td028ttec1_unprepare,\n\t.get_modes = td028ttec1_get_modes,\n};\n\nstatic int td028ttec1_probe(struct spi_device *spi)\n{\n\tstruct td028ttec1_panel *lcd;\n\tint ret;\n\n\tlcd = devm_kzalloc(&spi->dev, sizeof(*lcd), GFP_KERNEL);\n\tif (!lcd)\n\t\treturn -ENOMEM;\n\n\tspi_set_drvdata(spi, lcd);\n\tlcd->spi = spi;\n\n\tspi->mode = SPI_MODE_3;\n\tspi->bits_per_word = 9;\n\n\tret = spi_setup(spi);\n\tif (ret < 0) {\n\t\tdev_err(&spi->dev, \"failed to setup SPI: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tdrm_panel_init(&lcd->panel, &lcd->spi->dev, &td028ttec1_funcs,\n\t\t       DRM_MODE_CONNECTOR_DPI);\n\n\tret = drm_panel_of_backlight(&lcd->panel);\n\tif (ret)\n\t\treturn ret;\n\n\tdrm_panel_add(&lcd->panel);\n\n\treturn 0;\n}\n\nstatic void td028ttec1_remove(struct spi_device *spi)\n{\n\tstruct td028ttec1_panel *lcd = spi_get_drvdata(spi);\n\n\tdrm_panel_remove(&lcd->panel);\n\tdrm_panel_disable(&lcd->panel);\n\tdrm_panel_unprepare(&lcd->panel);\n}\n\nstatic const struct of_device_id td028ttec1_of_match[] = {\n\t{ .compatible = \"tpo,td028ttec1\", },\n\t \n\t{ .compatible = \"toppoly,td028ttec1\", },\n\t{   },\n};\n\nMODULE_DEVICE_TABLE(of, td028ttec1_of_match);\n\nstatic const struct spi_device_id td028ttec1_ids[] = {\n\t{ \"td028ttec1\", 0 },\n\t{   }\n};\n\nMODULE_DEVICE_TABLE(spi, td028ttec1_ids);\n\nstatic struct spi_driver td028ttec1_driver = {\n\t.probe\t\t= td028ttec1_probe,\n\t.remove\t\t= td028ttec1_remove,\n\t.id_table\t= td028ttec1_ids,\n\t.driver\t\t= {\n\t\t.name   = \"panel-tpo-td028ttec1\",\n\t\t.of_match_table = td028ttec1_of_match,\n\t},\n};\n\nmodule_spi_driver(td028ttec1_driver);\n\nMODULE_AUTHOR(\"H. Nikolaus Schaller <hns@goldelico.com>\");\nMODULE_DESCRIPTION(\"Toppoly TD028TTEC1 panel driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}