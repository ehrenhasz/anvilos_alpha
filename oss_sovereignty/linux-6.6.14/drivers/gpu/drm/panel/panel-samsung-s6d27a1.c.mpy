{
  "module_name": "panel-samsung-s6d27a1.c",
  "hash_id": "95d617db90ed263920ace1cc96c00e9a0ebfc79789456d305f2dbf24d755d2bf",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/panel/panel-samsung-s6d27a1.c",
  "human_readable_source": "\n \n\n#include <drm/drm_mipi_dbi.h>\n#include <drm/drm_modes.h>\n#include <drm/drm_panel.h>\n\n#include <linux/delay.h>\n#include <linux/gpio/consumer.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/media-bus-format.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/regulator/consumer.h>\n#include <linux/spi/spi.h>\n\n#include <video/mipi_display.h>\n\n#define S6D27A1_PASSWD_L2\t0xF0\t \n#define S6D27A1_RESCTL\t\t0xB3\t \n#define S6D27A1_PANELCTL2\t0xB4\t \n#define S6D27A1_READID1\t\t0xDA\t \n#define S6D27A1_READID2\t\t0xDB\t \n#define S6D27A1_READID3\t\t0xDC\t \n#define S6D27A1_DISPCTL\t\t0xF2\t \n#define S6D27A1_MANPWR\t\t0xF3\t \n#define S6D27A1_PWRCTL1\t\t0xF4\t \n#define S6D27A1_SRCCTL\t\t0xF6\t \n#define S6D27A1_PANELCTL\t0xF7\t \n\nstatic const u8 s6d27a1_dbi_read_commands[] = {\n\tS6D27A1_READID1,\n\tS6D27A1_READID2,\n\tS6D27A1_READID3,\n\t0,  \n};\n\nstruct s6d27a1 {\n\tstruct device *dev;\n\tstruct mipi_dbi dbi;\n\tstruct drm_panel panel;\n\tstruct gpio_desc *reset;\n\tstruct regulator_bulk_data regulators[2];\n};\n\nstatic const struct drm_display_mode s6d27a1_480_800_mode = {\n\t \n\t.clock = 24960,\n\t.hdisplay = 480,\n\t.hsync_start = 480 + 63,\n\t.hsync_end = 480 + 63 + 2,\n\t.htotal = 480 + 63 + 2 + 63,\n\t.vdisplay = 800,\n\t.vsync_start = 800 + 11,\n\t.vsync_end = 800 + 11 + 2,\n\t.vtotal = 800 + 11 + 2 + 10,\n\t.width_mm = 50,\n\t.height_mm = 84,\n\t.flags = DRM_MODE_FLAG_NVSYNC | DRM_MODE_FLAG_NHSYNC,\n};\n\nstatic inline struct s6d27a1 *to_s6d27a1(struct drm_panel *panel)\n{\n\treturn container_of(panel, struct s6d27a1, panel);\n}\n\nstatic void s6d27a1_read_mtp_id(struct s6d27a1 *ctx)\n{\n\tstruct mipi_dbi *dbi = &ctx->dbi;\n\tu8 id1, id2, id3;\n\tint ret;\n\n\tret = mipi_dbi_command_read(dbi, S6D27A1_READID1, &id1);\n\tif (ret) {\n\t\tdev_err(ctx->dev, \"unable to read MTP ID 1\\n\");\n\t\treturn;\n\t}\n\tret = mipi_dbi_command_read(dbi, S6D27A1_READID2, &id2);\n\tif (ret) {\n\t\tdev_err(ctx->dev, \"unable to read MTP ID 2\\n\");\n\t\treturn;\n\t}\n\tret = mipi_dbi_command_read(dbi, S6D27A1_READID3, &id3);\n\tif (ret) {\n\t\tdev_err(ctx->dev, \"unable to read MTP ID 3\\n\");\n\t\treturn;\n\t}\n\tdev_info(ctx->dev, \"MTP ID: %02x %02x %02x\\n\", id1, id2, id3);\n}\n\nstatic int s6d27a1_power_on(struct s6d27a1 *ctx)\n{\n\tstruct mipi_dbi *dbi = &ctx->dbi;\n\tint ret;\n\n\t \n\tret = regulator_bulk_enable(ARRAY_SIZE(ctx->regulators),\n\t\t\t\t    ctx->regulators);\n\tif (ret) {\n\t\tdev_err(ctx->dev, \"failed to enable regulators: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tmsleep(20);\n\n\t \n\tgpiod_set_value_cansleep(ctx->reset, 1);\n\tusleep_range(1000, 5000);\n\t \n\tgpiod_set_value_cansleep(ctx->reset, 0);\n\t \n\tmsleep(20);\n\n\t \n\tmipi_dbi_command(dbi, MIPI_DCS_EXIT_SLEEP_MODE);\n\tmipi_dbi_command(dbi, MIPI_DCS_EXIT_SLEEP_MODE);\n\tmsleep(120);\n\n\t \n\tmipi_dbi_command(dbi, S6D27A1_PASSWD_L2, 0x5A, 0x5A);\n\n\t \n\tmipi_dbi_command(dbi, S6D27A1_RESCTL, 0x22);\n\n\tmipi_dbi_command(dbi, S6D27A1_PANELCTL2, 0x00, 0x02, 0x03, 0x04, 0x05, 0x08, 0x00, 0x0c);\n\n\tmipi_dbi_command(dbi, S6D27A1_MANPWR, 0x01, 0x00, 0x00, 0x08, 0x08, 0x02, 0x00);\n\n\tmipi_dbi_command(dbi, S6D27A1_DISPCTL, 0x19, 0x00, 0x08, 0x0D, 0x03, 0x41, 0x3F);\n\n\tmipi_dbi_command(dbi, S6D27A1_PWRCTL1, 0x00, 0x00, 0x00, 0x00, 0x55,\n\t\t\t\t\t0x44, 0x05, 0x88, 0x4B, 0x50);\n\n\tmipi_dbi_command(dbi, S6D27A1_SRCCTL, 0x03, 0x09, 0x8A, 0x00, 0x01, 0x16);\n\n\tmipi_dbi_command(dbi, S6D27A1_PANELCTL, 0x00, 0x05, 0x06, 0x07, 0x08,\n\t\t\t\t\t0x01, 0x09, 0x0D, 0x0A, 0x0E,\n\t\t\t\t\t0x0B, 0x0F, 0x0C, 0x10, 0x01,\n\t\t\t\t\t0x11, 0x12, 0x13, 0x14, 0x05,\n\t\t\t\t\t0x06, 0x07, 0x08, 0x01, 0x09,\n\t\t\t\t\t0x0D, 0x0A, 0x0E, 0x0B, 0x0F,\n\t\t\t\t\t0x0C, 0x10, 0x01, 0x11, 0x12,\n\t\t\t\t\t0x13, 0x14);\n\n\t \n\tmipi_dbi_command(dbi, S6D27A1_PASSWD_L2, 0xA5, 0xA5);\n\n\ts6d27a1_read_mtp_id(ctx);\n\n\treturn 0;\n}\n\nstatic int s6d27a1_power_off(struct s6d27a1 *ctx)\n{\n\t \n\tgpiod_set_value_cansleep(ctx->reset, 1);\n\treturn regulator_bulk_disable(ARRAY_SIZE(ctx->regulators),\n\t\t\t\t      ctx->regulators);\n}\n\nstatic int s6d27a1_unprepare(struct drm_panel *panel)\n{\n\tstruct s6d27a1 *ctx = to_s6d27a1(panel);\n\tstruct mipi_dbi *dbi = &ctx->dbi;\n\n\tmipi_dbi_command(dbi, MIPI_DCS_ENTER_SLEEP_MODE);\n\tmsleep(120);\n\treturn s6d27a1_power_off(to_s6d27a1(panel));\n}\n\nstatic int s6d27a1_disable(struct drm_panel *panel)\n{\n\tstruct s6d27a1 *ctx = to_s6d27a1(panel);\n\tstruct mipi_dbi *dbi = &ctx->dbi;\n\n\tmipi_dbi_command(dbi, MIPI_DCS_SET_DISPLAY_OFF);\n\tmsleep(25);\n\n\treturn 0;\n}\n\nstatic int s6d27a1_prepare(struct drm_panel *panel)\n{\n\treturn s6d27a1_power_on(to_s6d27a1(panel));\n}\n\nstatic int s6d27a1_enable(struct drm_panel *panel)\n{\n\tstruct s6d27a1 *ctx = to_s6d27a1(panel);\n\tstruct mipi_dbi *dbi = &ctx->dbi;\n\n\tmipi_dbi_command(dbi, MIPI_DCS_SET_DISPLAY_ON);\n\n\treturn 0;\n}\n\nstatic int s6d27a1_get_modes(struct drm_panel *panel,\n\t\t\t    struct drm_connector *connector)\n{\n\tstruct s6d27a1 *ctx = to_s6d27a1(panel);\n\tstruct drm_display_mode *mode;\n\tstatic const u32 bus_format = MEDIA_BUS_FMT_RGB888_1X24;\n\n\tmode = drm_mode_duplicate(connector->dev, &s6d27a1_480_800_mode);\n\tif (!mode) {\n\t\tdev_err(ctx->dev, \"failed to add mode\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tconnector->display_info.bpc = 8;\n\tconnector->display_info.width_mm = mode->width_mm;\n\tconnector->display_info.height_mm = mode->height_mm;\n\tconnector->display_info.bus_flags =\n\t\tDRM_BUS_FLAG_PIXDATA_DRIVE_NEGEDGE;\n\tdrm_display_info_set_bus_formats(&connector->display_info,\n\t\t\t\t\t &bus_format, 1);\n\n\tdrm_mode_set_name(mode);\n\tmode->type = DRM_MODE_TYPE_DRIVER | DRM_MODE_TYPE_PREFERRED;\n\n\tdrm_mode_probed_add(connector, mode);\n\n\treturn 1;\n}\n\nstatic const struct drm_panel_funcs s6d27a1_drm_funcs = {\n\t.disable = s6d27a1_disable,\n\t.unprepare = s6d27a1_unprepare,\n\t.prepare = s6d27a1_prepare,\n\t.enable = s6d27a1_enable,\n\t.get_modes = s6d27a1_get_modes,\n};\n\nstatic int s6d27a1_probe(struct spi_device *spi)\n{\n\tstruct device *dev = &spi->dev;\n\tstruct s6d27a1 *ctx;\n\tint ret;\n\n\tctx = devm_kzalloc(dev, sizeof(*ctx), GFP_KERNEL);\n\tif (!ctx)\n\t\treturn -ENOMEM;\n\n\tctx->dev = dev;\n\n\t \n\tctx->regulators[0].supply = \"vci\";\n\tctx->regulators[1].supply = \"vccio\";\n\tret = devm_regulator_bulk_get(dev,\n\t\t\t\t      ARRAY_SIZE(ctx->regulators),\n\t\t\t\t      ctx->regulators);\n\tif (ret)\n\t\treturn dev_err_probe(dev, ret, \"failed to get regulators\\n\");\n\n\tctx->reset = devm_gpiod_get(dev, \"reset\", GPIOD_OUT_HIGH);\n\tif (IS_ERR(ctx->reset)) {\n\t\tret = PTR_ERR(ctx->reset);\n\t\treturn dev_err_probe(dev, ret, \"no RESET GPIO\\n\");\n\t}\n\n\tret = mipi_dbi_spi_init(spi, &ctx->dbi, NULL);\n\tif (ret)\n\t\treturn dev_err_probe(dev, ret, \"MIPI DBI init failed\\n\");\n\n\tctx->dbi.read_commands = s6d27a1_dbi_read_commands;\n\n\tdrm_panel_init(&ctx->panel, dev, &s6d27a1_drm_funcs,\n\t\t       DRM_MODE_CONNECTOR_DPI);\n\n\tret = drm_panel_of_backlight(&ctx->panel);\n\tif (ret)\n\t\treturn dev_err_probe(dev, ret, \"failed to add backlight\\n\");\n\n\tspi_set_drvdata(spi, ctx);\n\n\tdrm_panel_add(&ctx->panel);\n\n\treturn 0;\n}\n\nstatic void s6d27a1_remove(struct spi_device *spi)\n{\n\tstruct s6d27a1 *ctx = spi_get_drvdata(spi);\n\n\tdrm_panel_remove(&ctx->panel);\n}\n\nstatic const struct of_device_id s6d27a1_match[] = {\n\t{ .compatible = \"samsung,s6d27a1\", },\n\t{   },\n};\nMODULE_DEVICE_TABLE(of, s6d27a1_match);\n\nstatic struct spi_driver s6d27a1_driver = {\n\t.probe\t\t= s6d27a1_probe,\n\t.remove\t\t= s6d27a1_remove,\n\t.driver\t\t= {\n\t\t.name\t= \"s6d27a1-panel\",\n\t\t.of_match_table = s6d27a1_match,\n\t},\n};\nmodule_spi_driver(s6d27a1_driver);\n\nMODULE_AUTHOR(\"Markuss Broks <markuss.broks@gmail.com>\");\nMODULE_DESCRIPTION(\"Samsung S6D27A1 panel driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}