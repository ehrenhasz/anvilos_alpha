{
  "module_name": "panel-dsi-cm.c",
  "hash_id": "8ed570950f9ec9094ab6a2a6c63650a81b7e55a717fa382519bda63c53f9307e",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/panel/panel-dsi-cm.c",
  "human_readable_source": "\n \n\n#include <linux/backlight.h>\n#include <linux/delay.h>\n#include <linux/gpio/consumer.h>\n#include <linux/jiffies.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/regulator/consumer.h>\n\n#include <drm/drm_connector.h>\n#include <drm/drm_mipi_dsi.h>\n#include <drm/drm_modes.h>\n#include <drm/drm_panel.h>\n\n#include <video/mipi_display.h>\n\n#define DCS_GET_ID1\t\t0xda\n#define DCS_GET_ID2\t\t0xdb\n#define DCS_GET_ID3\t\t0xdc\n\n#define DCS_REGULATOR_SUPPLY_NUM 2\n\nstatic const struct of_device_id dsicm_of_match[];\n\nstruct dsic_panel_data {\n\tu32 xres;\n\tu32 yres;\n\tu32 refresh;\n\tu32 width_mm;\n\tu32 height_mm;\n\tu32 max_hs_rate;\n\tu32 max_lp_rate;\n\tbool te_support;\n};\n\nstruct panel_drv_data {\n\tstruct mipi_dsi_device *dsi;\n\tstruct drm_panel panel;\n\tstruct drm_display_mode mode;\n\n\tstruct mutex lock;\n\n\tstruct backlight_device *bldev;\n\tstruct backlight_device *extbldev;\n\n\tunsigned long\thw_guard_end;\t \n\tunsigned long\thw_guard_wait;\t \n\n\tconst struct dsic_panel_data *panel_data;\n\n\tstruct gpio_desc *reset_gpio;\n\n\tstruct regulator_bulk_data supplies[DCS_REGULATOR_SUPPLY_NUM];\n\n\tbool use_dsi_backlight;\n\n\t \n\tbool enabled;\n\n\tbool intro_printed;\n};\n\nstatic inline struct panel_drv_data *panel_to_ddata(struct drm_panel *panel)\n{\n\treturn container_of(panel, struct panel_drv_data, panel);\n}\n\nstatic void dsicm_bl_power(struct panel_drv_data *ddata, bool enable)\n{\n\tstruct backlight_device *backlight;\n\n\tif (ddata->bldev)\n\t\tbacklight = ddata->bldev;\n\telse if (ddata->extbldev)\n\t\tbacklight = ddata->extbldev;\n\telse\n\t\treturn;\n\n\tif (enable)\n\t\tbacklight_enable(backlight);\n\telse\n\t\tbacklight_disable(backlight);\n}\n\nstatic void hw_guard_start(struct panel_drv_data *ddata, int guard_msec)\n{\n\tddata->hw_guard_wait = msecs_to_jiffies(guard_msec);\n\tddata->hw_guard_end = jiffies + ddata->hw_guard_wait;\n}\n\nstatic void hw_guard_wait(struct panel_drv_data *ddata)\n{\n\tunsigned long wait = ddata->hw_guard_end - jiffies;\n\n\tif ((long)wait > 0 && wait <= ddata->hw_guard_wait) {\n\t\tset_current_state(TASK_UNINTERRUPTIBLE);\n\t\tschedule_timeout(wait);\n\t}\n}\n\nstatic int dsicm_dcs_read_1(struct panel_drv_data *ddata, u8 dcs_cmd, u8 *data)\n{\n\treturn mipi_dsi_dcs_read(ddata->dsi, dcs_cmd, data, 1);\n}\n\nstatic int dsicm_dcs_write_1(struct panel_drv_data *ddata, u8 dcs_cmd, u8 param)\n{\n\treturn mipi_dsi_dcs_write(ddata->dsi, dcs_cmd, &param, 1);\n}\n\nstatic int dsicm_sleep_in(struct panel_drv_data *ddata)\n\n{\n\tint r;\n\n\thw_guard_wait(ddata);\n\n\tr = mipi_dsi_dcs_enter_sleep_mode(ddata->dsi);\n\tif (r)\n\t\treturn r;\n\n\thw_guard_start(ddata, 120);\n\n\tusleep_range(5000, 10000);\n\n\treturn 0;\n}\n\nstatic int dsicm_sleep_out(struct panel_drv_data *ddata)\n{\n\tint r;\n\n\thw_guard_wait(ddata);\n\n\tr = mipi_dsi_dcs_exit_sleep_mode(ddata->dsi);\n\tif (r)\n\t\treturn r;\n\n\thw_guard_start(ddata, 120);\n\n\tusleep_range(5000, 10000);\n\n\treturn 0;\n}\n\nstatic int dsicm_get_id(struct panel_drv_data *ddata, u8 *id1, u8 *id2, u8 *id3)\n{\n\tint r;\n\n\tr = dsicm_dcs_read_1(ddata, DCS_GET_ID1, id1);\n\tif (r)\n\t\treturn r;\n\tr = dsicm_dcs_read_1(ddata, DCS_GET_ID2, id2);\n\tif (r)\n\t\treturn r;\n\tr = dsicm_dcs_read_1(ddata, DCS_GET_ID3, id3);\n\tif (r)\n\t\treturn r;\n\n\treturn 0;\n}\n\nstatic int dsicm_set_update_window(struct panel_drv_data *ddata)\n{\n\tstruct mipi_dsi_device *dsi = ddata->dsi;\n\tint r;\n\n\tr = mipi_dsi_dcs_set_column_address(dsi, 0, ddata->mode.hdisplay - 1);\n\tif (r < 0)\n\t\treturn r;\n\n\tr = mipi_dsi_dcs_set_page_address(dsi, 0, ddata->mode.vdisplay - 1);\n\tif (r < 0)\n\t\treturn r;\n\n\treturn 0;\n}\n\nstatic int dsicm_bl_update_status(struct backlight_device *dev)\n{\n\tstruct panel_drv_data *ddata = dev_get_drvdata(&dev->dev);\n\tint r = 0;\n\tint level = backlight_get_brightness(dev);\n\n\tdev_dbg(&ddata->dsi->dev, \"update brightness to %d\\n\", level);\n\n\tmutex_lock(&ddata->lock);\n\n\tif (ddata->enabled)\n\t\tr = dsicm_dcs_write_1(ddata, MIPI_DCS_SET_DISPLAY_BRIGHTNESS,\n\t\t\t\t      level);\n\n\tmutex_unlock(&ddata->lock);\n\n\treturn r;\n}\n\nstatic int dsicm_bl_get_intensity(struct backlight_device *dev)\n{\n\treturn backlight_get_brightness(dev);\n}\n\nstatic const struct backlight_ops dsicm_bl_ops = {\n\t.get_brightness = dsicm_bl_get_intensity,\n\t.update_status  = dsicm_bl_update_status,\n};\n\nstatic ssize_t num_dsi_errors_show(struct device *dev,\n\t\tstruct device_attribute *attr, char *buf)\n{\n\tstruct panel_drv_data *ddata = dev_get_drvdata(dev);\n\tu8 errors = 0;\n\tint r = -ENODEV;\n\n\tmutex_lock(&ddata->lock);\n\n\tif (ddata->enabled)\n\t\tr = dsicm_dcs_read_1(ddata, MIPI_DCS_GET_ERROR_COUNT_ON_DSI, &errors);\n\n\tmutex_unlock(&ddata->lock);\n\n\tif (r)\n\t\treturn r;\n\n\treturn sysfs_emit(buf, \"%d\\n\", errors);\n}\n\nstatic ssize_t hw_revision_show(struct device *dev,\n\t\tstruct device_attribute *attr, char *buf)\n{\n\tstruct panel_drv_data *ddata = dev_get_drvdata(dev);\n\tu8 id1, id2, id3;\n\tint r = -ENODEV;\n\n\tmutex_lock(&ddata->lock);\n\n\tif (ddata->enabled)\n\t\tr = dsicm_get_id(ddata, &id1, &id2, &id3);\n\n\tmutex_unlock(&ddata->lock);\n\n\tif (r)\n\t\treturn r;\n\n\treturn sysfs_emit(buf, \"%02x.%02x.%02x\\n\", id1, id2, id3);\n}\n\nstatic DEVICE_ATTR_RO(num_dsi_errors);\nstatic DEVICE_ATTR_RO(hw_revision);\n\nstatic struct attribute *dsicm_attrs[] = {\n\t&dev_attr_num_dsi_errors.attr,\n\t&dev_attr_hw_revision.attr,\n\tNULL,\n};\n\nstatic const struct attribute_group dsicm_attr_group = {\n\t.attrs = dsicm_attrs,\n};\n\nstatic void dsicm_hw_reset(struct panel_drv_data *ddata)\n{\n\tgpiod_set_value(ddata->reset_gpio, 1);\n\tudelay(10);\n\t \n\tgpiod_set_value(ddata->reset_gpio, 0);\n\t \n\tudelay(10);\n\tgpiod_set_value(ddata->reset_gpio, 1);\n\t \n\tusleep_range(5000, 10000);\n}\n\nstatic int dsicm_power_on(struct panel_drv_data *ddata)\n{\n\tu8 id1, id2, id3;\n\tint r;\n\n\tdsicm_hw_reset(ddata);\n\n\tddata->dsi->mode_flags |= MIPI_DSI_MODE_LPM;\n\n\tr = dsicm_sleep_out(ddata);\n\tif (r)\n\t\tgoto err;\n\n\tr = dsicm_get_id(ddata, &id1, &id2, &id3);\n\tif (r)\n\t\tgoto err;\n\n\tr = dsicm_dcs_write_1(ddata, MIPI_DCS_SET_DISPLAY_BRIGHTNESS, 0xff);\n\tif (r)\n\t\tgoto err;\n\n\tr = dsicm_dcs_write_1(ddata, MIPI_DCS_WRITE_CONTROL_DISPLAY,\n\t\t\t(1<<2) | (1<<5));\t \n\tif (r)\n\t\tgoto err;\n\n\tr = mipi_dsi_dcs_set_pixel_format(ddata->dsi, MIPI_DCS_PIXEL_FMT_24BIT);\n\tif (r)\n\t\tgoto err;\n\n\tr = dsicm_set_update_window(ddata);\n\tif (r)\n\t\tgoto err;\n\n\tr = mipi_dsi_dcs_set_display_on(ddata->dsi);\n\tif (r)\n\t\tgoto err;\n\n\tif (ddata->panel_data->te_support) {\n\t\tr = mipi_dsi_dcs_set_tear_on(ddata->dsi, MIPI_DSI_DCS_TEAR_MODE_VBLANK);\n\t\tif (r)\n\t\t\tgoto err;\n\t}\n\n\t \n\tmsleep(100);\n\n\tddata->enabled = true;\n\n\tif (!ddata->intro_printed) {\n\t\tdev_info(&ddata->dsi->dev, \"panel revision %02x.%02x.%02x\\n\",\n\t\t\tid1, id2, id3);\n\t\tddata->intro_printed = true;\n\t}\n\n\tddata->dsi->mode_flags &= ~MIPI_DSI_MODE_LPM;\n\n\treturn 0;\nerr:\n\tdev_err(&ddata->dsi->dev, \"error while enabling panel, issuing HW reset\\n\");\n\n\tdsicm_hw_reset(ddata);\n\n\treturn r;\n}\n\nstatic int dsicm_power_off(struct panel_drv_data *ddata)\n{\n\tint r;\n\n\tddata->enabled = false;\n\n\tr = mipi_dsi_dcs_set_display_off(ddata->dsi);\n\tif (!r)\n\t\tr = dsicm_sleep_in(ddata);\n\n\tif (r) {\n\t\tdev_err(&ddata->dsi->dev,\n\t\t\t\t\"error disabling panel, issuing HW reset\\n\");\n\t\tdsicm_hw_reset(ddata);\n\t}\n\n\treturn r;\n}\n\nstatic int dsicm_prepare(struct drm_panel *panel)\n{\n\tstruct panel_drv_data *ddata = panel_to_ddata(panel);\n\tint r;\n\n\tr = regulator_bulk_enable(ARRAY_SIZE(ddata->supplies), ddata->supplies);\n\tif (r)\n\t\tdev_err(&ddata->dsi->dev, \"failed to enable supplies: %d\\n\", r);\n\n\treturn r;\n}\n\nstatic int dsicm_enable(struct drm_panel *panel)\n{\n\tstruct panel_drv_data *ddata = panel_to_ddata(panel);\n\tint r;\n\n\tmutex_lock(&ddata->lock);\n\n\tr = dsicm_power_on(ddata);\n\tif (r)\n\t\tgoto err;\n\n\tmutex_unlock(&ddata->lock);\n\n\tdsicm_bl_power(ddata, true);\n\n\treturn 0;\nerr:\n\tdev_err(&ddata->dsi->dev, \"enable failed (%d)\\n\", r);\n\tmutex_unlock(&ddata->lock);\n\treturn r;\n}\n\nstatic int dsicm_unprepare(struct drm_panel *panel)\n{\n\tstruct panel_drv_data *ddata = panel_to_ddata(panel);\n\tint r;\n\n\tr = regulator_bulk_disable(ARRAY_SIZE(ddata->supplies), ddata->supplies);\n\tif (r)\n\t\tdev_err(&ddata->dsi->dev, \"failed to disable supplies: %d\\n\", r);\n\n\treturn r;\n}\n\nstatic int dsicm_disable(struct drm_panel *panel)\n{\n\tstruct panel_drv_data *ddata = panel_to_ddata(panel);\n\tint r;\n\n\tdsicm_bl_power(ddata, false);\n\n\tmutex_lock(&ddata->lock);\n\n\tr = dsicm_power_off(ddata);\n\n\tmutex_unlock(&ddata->lock);\n\n\treturn r;\n}\n\nstatic int dsicm_get_modes(struct drm_panel *panel,\n\t\t\t   struct drm_connector *connector)\n{\n\tstruct panel_drv_data *ddata = panel_to_ddata(panel);\n\tstruct drm_display_mode *mode;\n\n\tmode = drm_mode_duplicate(connector->dev, &ddata->mode);\n\tif (!mode) {\n\t\tdev_err(&ddata->dsi->dev, \"failed to add mode %ux%ux@%u kHz\\n\",\n\t\t\tddata->mode.hdisplay, ddata->mode.vdisplay,\n\t\t\tddata->mode.clock);\n\t\treturn -ENOMEM;\n\t}\n\n\tconnector->display_info.width_mm = ddata->panel_data->width_mm;\n\tconnector->display_info.height_mm = ddata->panel_data->height_mm;\n\n\tdrm_mode_probed_add(connector, mode);\n\n\treturn 1;\n}\n\nstatic const struct drm_panel_funcs dsicm_panel_funcs = {\n\t.unprepare = dsicm_unprepare,\n\t.disable = dsicm_disable,\n\t.prepare = dsicm_prepare,\n\t.enable = dsicm_enable,\n\t.get_modes = dsicm_get_modes,\n};\n\nstatic int dsicm_probe_of(struct mipi_dsi_device *dsi)\n{\n\tstruct backlight_device *backlight;\n\tstruct panel_drv_data *ddata = mipi_dsi_get_drvdata(dsi);\n\tint err;\n\tstruct drm_display_mode *mode = &ddata->mode;\n\n\tddata->reset_gpio = devm_gpiod_get(&dsi->dev, \"reset\", GPIOD_OUT_LOW);\n\tif (IS_ERR(ddata->reset_gpio)) {\n\t\terr = PTR_ERR(ddata->reset_gpio);\n\t\tdev_err(&dsi->dev, \"reset gpio request failed: %d\", err);\n\t\treturn err;\n\t}\n\n\tmode->hdisplay = mode->hsync_start = mode->hsync_end = mode->htotal =\n\t\tddata->panel_data->xres;\n\tmode->vdisplay = mode->vsync_start = mode->vsync_end = mode->vtotal =\n\t\tddata->panel_data->yres;\n\tmode->clock = ddata->panel_data->xres * ddata->panel_data->yres *\n\t\tddata->panel_data->refresh / 1000;\n\tmode->width_mm = ddata->panel_data->width_mm;\n\tmode->height_mm = ddata->panel_data->height_mm;\n\tmode->type = DRM_MODE_TYPE_DRIVER | DRM_MODE_TYPE_PREFERRED;\n\tdrm_mode_set_name(mode);\n\n\tddata->supplies[0].supply = \"vpnl\";\n\tddata->supplies[1].supply = \"vddi\";\n\terr = devm_regulator_bulk_get(&dsi->dev, ARRAY_SIZE(ddata->supplies),\n\t\t\t\t      ddata->supplies);\n\tif (err)\n\t\treturn err;\n\n\tbacklight = devm_of_find_backlight(&dsi->dev);\n\tif (IS_ERR(backlight))\n\t\treturn PTR_ERR(backlight);\n\n\t \n\tif (backlight)\n\t\tddata->extbldev = backlight;\n\telse\n\t\tddata->use_dsi_backlight = true;\n\n\treturn 0;\n}\n\nstatic int dsicm_probe(struct mipi_dsi_device *dsi)\n{\n\tstruct panel_drv_data *ddata;\n\tstruct backlight_device *bldev = NULL;\n\tstruct device *dev = &dsi->dev;\n\tint r;\n\n\tdev_dbg(dev, \"probe\\n\");\n\n\tddata = devm_kzalloc(dev, sizeof(*ddata), GFP_KERNEL);\n\tif (!ddata)\n\t\treturn -ENOMEM;\n\n\tmipi_dsi_set_drvdata(dsi, ddata);\n\tddata->dsi = dsi;\n\n\tddata->panel_data = of_device_get_match_data(dev);\n\tif (!ddata->panel_data)\n\t\treturn -ENODEV;\n\n\tr = dsicm_probe_of(dsi);\n\tif (r)\n\t\treturn r;\n\n\tmutex_init(&ddata->lock);\n\n\tdsicm_hw_reset(ddata);\n\n\tdrm_panel_init(&ddata->panel, dev, &dsicm_panel_funcs,\n\t\t       DRM_MODE_CONNECTOR_DSI);\n\n\tif (ddata->use_dsi_backlight) {\n\t\tstruct backlight_properties props = { 0 };\n\t\tprops.max_brightness = 255;\n\t\tprops.type = BACKLIGHT_RAW;\n\n\t\tbldev = devm_backlight_device_register(dev, dev_name(dev),\n\t\t\tdev, ddata, &dsicm_bl_ops, &props);\n\t\tif (IS_ERR(bldev)) {\n\t\t\tr = PTR_ERR(bldev);\n\t\t\tgoto err_bl;\n\t\t}\n\n\t\tddata->bldev = bldev;\n\t}\n\n\tr = sysfs_create_group(&dev->kobj, &dsicm_attr_group);\n\tif (r) {\n\t\tdev_err(dev, \"failed to create sysfs files\\n\");\n\t\tgoto err_bl;\n\t}\n\n\tdsi->lanes = 2;\n\tdsi->format = MIPI_DSI_FMT_RGB888;\n\tdsi->mode_flags = MIPI_DSI_CLOCK_NON_CONTINUOUS |\n\t\t\t  MIPI_DSI_MODE_NO_EOT_PACKET;\n\tdsi->hs_rate = ddata->panel_data->max_hs_rate;\n\tdsi->lp_rate = ddata->panel_data->max_lp_rate;\n\n\tdrm_panel_add(&ddata->panel);\n\n\tr = mipi_dsi_attach(dsi);\n\tif (r < 0)\n\t\tgoto err_dsi_attach;\n\n\treturn 0;\n\nerr_dsi_attach:\n\tdrm_panel_remove(&ddata->panel);\n\tsysfs_remove_group(&dsi->dev.kobj, &dsicm_attr_group);\nerr_bl:\n\tif (ddata->extbldev)\n\t\tput_device(&ddata->extbldev->dev);\n\n\treturn r;\n}\n\nstatic void dsicm_remove(struct mipi_dsi_device *dsi)\n{\n\tstruct panel_drv_data *ddata = mipi_dsi_get_drvdata(dsi);\n\n\tdev_dbg(&dsi->dev, \"remove\\n\");\n\n\tmipi_dsi_detach(dsi);\n\n\tdrm_panel_remove(&ddata->panel);\n\n\tsysfs_remove_group(&dsi->dev.kobj, &dsicm_attr_group);\n\n\tif (ddata->extbldev)\n\t\tput_device(&ddata->extbldev->dev);\n}\n\nstatic const struct dsic_panel_data taal_data = {\n\t.xres = 864,\n\t.yres = 480,\n\t.refresh = 60,\n\t.width_mm = 0,\n\t.height_mm = 0,\n\t.max_hs_rate = 300000000,\n\t.max_lp_rate = 10000000,\n\t.te_support = true,\n};\n\nstatic const struct dsic_panel_data himalaya_data = {\n\t.xres = 480,\n\t.yres = 864,\n\t.refresh = 60,\n\t.width_mm = 49,\n\t.height_mm = 88,\n\t.max_hs_rate = 300000000,\n\t.max_lp_rate = 10000000,\n\t.te_support = false,\n};\n\nstatic const struct dsic_panel_data droid4_data = {\n\t.xres = 540,\n\t.yres = 960,\n\t.refresh = 60,\n\t.width_mm = 50,\n\t.height_mm = 89,\n\t.max_hs_rate = 300000000,\n\t.max_lp_rate = 10000000,\n\t.te_support = false,\n};\n\nstatic const struct of_device_id dsicm_of_match[] = {\n\t{ .compatible = \"tpo,taal\", .data = &taal_data },\n\t{ .compatible = \"nokia,himalaya\", &himalaya_data },\n\t{ .compatible = \"motorola,droid4-panel\", &droid4_data },\n\t{},\n};\n\nMODULE_DEVICE_TABLE(of, dsicm_of_match);\n\nstatic struct mipi_dsi_driver dsicm_driver = {\n\t.probe = dsicm_probe,\n\t.remove = dsicm_remove,\n\t.driver = {\n\t\t.name = \"panel-dsi-cm\",\n\t\t.of_match_table = dsicm_of_match,\n\t},\n};\nmodule_mipi_dsi_driver(dsicm_driver);\n\nMODULE_AUTHOR(\"Tomi Valkeinen <tomi.valkeinen@ti.com>\");\nMODULE_DESCRIPTION(\"Generic DSI Command Mode Panel Driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}