{
  "module_name": "panel-sony-td4353-jdi.c",
  "hash_id": "94464886736981d7d4d89b8cf75fd50af34d798d2e5bbbe04f96d131b20d34f0",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/panel/panel-sony-td4353-jdi.c",
  "human_readable_source": "\n \n\n#include <linux/delay.h>\n#include <linux/gpio/consumer.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/regulator/consumer.h>\n\n#include <video/mipi_display.h>\n\n#include <drm/drm_mipi_dsi.h>\n#include <drm/drm_modes.h>\n#include <drm/drm_panel.h>\n\nenum {\n\tTYPE_TAMA_60HZ,\n\t \n};\n\nstruct sony_td4353_jdi {\n\tstruct drm_panel panel;\n\tstruct mipi_dsi_device *dsi;\n\tstruct regulator_bulk_data supplies[3];\n\tstruct gpio_desc *panel_reset_gpio;\n\tstruct gpio_desc *touch_reset_gpio;\n\tbool prepared;\n\tint type;\n};\n\nstatic inline struct sony_td4353_jdi *to_sony_td4353_jdi(struct drm_panel *panel)\n{\n\treturn container_of(panel, struct sony_td4353_jdi, panel);\n}\n\nstatic int sony_td4353_jdi_on(struct sony_td4353_jdi *ctx)\n{\n\tstruct mipi_dsi_device *dsi = ctx->dsi;\n\tstruct device *dev = &dsi->dev;\n\tint ret;\n\n\tdsi->mode_flags |= MIPI_DSI_MODE_LPM;\n\n\tret = mipi_dsi_dcs_set_column_address(dsi, 0x0000, 1080 - 1);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"Failed to set column address: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = mipi_dsi_dcs_set_page_address(dsi, 0x0000, 2160 - 1);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"Failed to set page address: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = mipi_dsi_dcs_set_tear_scanline(dsi, 0);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"Failed to set tear scanline: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = mipi_dsi_dcs_set_tear_on(dsi, MIPI_DSI_DCS_TEAR_MODE_VBLANK);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"Failed to set tear on: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tmipi_dsi_dcs_write_seq(dsi, MIPI_DCS_SET_ADDRESS_MODE, 0x00);\n\n\tret = mipi_dsi_dcs_set_pixel_format(dsi, 0x77);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"Failed to set pixel format: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tmipi_dsi_dcs_write_seq(dsi, MIPI_DCS_SET_PARTIAL_ROWS,\n\t\t\t  0x00, 0x00, 0x08, 0x6f);\n\n\tret = mipi_dsi_dcs_exit_sleep_mode(dsi);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"Failed to exit sleep mode: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\tmsleep(70);\n\n\tmipi_dsi_dcs_write_seq(dsi, MIPI_DCS_WRITE_MEMORY_START);\n\n\tret = mipi_dsi_dcs_set_display_on(dsi);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"Failed to turn display on: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int sony_td4353_jdi_off(struct sony_td4353_jdi *ctx)\n{\n\tstruct mipi_dsi_device *dsi = ctx->dsi;\n\tstruct device *dev = &dsi->dev;\n\tint ret;\n\n\tdsi->mode_flags &= ~MIPI_DSI_MODE_LPM;\n\n\tret = mipi_dsi_dcs_set_display_off(dsi);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"Failed to set display off: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\tmsleep(22);\n\n\tret = mipi_dsi_dcs_set_tear_off(dsi);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"Failed to set tear off: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = mipi_dsi_dcs_enter_sleep_mode(dsi);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"Failed to enter sleep mode: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\tmsleep(80);\n\n\treturn 0;\n}\n\nstatic void sony_td4353_assert_reset_gpios(struct sony_td4353_jdi *ctx, int mode)\n{\n\tgpiod_set_value_cansleep(ctx->touch_reset_gpio, mode);\n\tgpiod_set_value_cansleep(ctx->panel_reset_gpio, mode);\n\tusleep_range(5000, 5100);\n}\n\nstatic int sony_td4353_jdi_prepare(struct drm_panel *panel)\n{\n\tstruct sony_td4353_jdi *ctx = to_sony_td4353_jdi(panel);\n\tstruct device *dev = &ctx->dsi->dev;\n\tint ret;\n\n\tif (ctx->prepared)\n\t\treturn 0;\n\n\tret = regulator_bulk_enable(ARRAY_SIZE(ctx->supplies), ctx->supplies);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"Failed to enable regulators: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tmsleep(100);\n\n\tsony_td4353_assert_reset_gpios(ctx, 1);\n\n\tret = sony_td4353_jdi_on(ctx);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"Failed to power on panel: %d\\n\", ret);\n\t\tsony_td4353_assert_reset_gpios(ctx, 0);\n\t\tregulator_bulk_disable(ARRAY_SIZE(ctx->supplies), ctx->supplies);\n\t\treturn ret;\n\t}\n\n\tctx->prepared = true;\n\treturn 0;\n}\n\nstatic int sony_td4353_jdi_unprepare(struct drm_panel *panel)\n{\n\tstruct sony_td4353_jdi *ctx = to_sony_td4353_jdi(panel);\n\tstruct device *dev = &ctx->dsi->dev;\n\tint ret;\n\n\tif (!ctx->prepared)\n\t\treturn 0;\n\n\tret = sony_td4353_jdi_off(ctx);\n\tif (ret < 0)\n\t\tdev_err(dev, \"Failed to power off panel: %d\\n\", ret);\n\n\tsony_td4353_assert_reset_gpios(ctx, 0);\n\tregulator_bulk_disable(ARRAY_SIZE(ctx->supplies), ctx->supplies);\n\n\tctx->prepared = false;\n\treturn 0;\n}\n\nstatic const struct drm_display_mode sony_td4353_jdi_mode_tama_60hz = {\n\t.clock = (1080 + 4 + 8 + 8) * (2160 + 259 + 8 + 8) * 60 / 1000,\n\t.hdisplay = 1080,\n\t.hsync_start = 1080 + 4,\n\t.hsync_end = 1080 + 4 + 8,\n\t.htotal = 1080 + 4 + 8 + 8,\n\t.vdisplay = 2160,\n\t.vsync_start = 2160 + 259,\n\t.vsync_end = 2160 + 259 + 8,\n\t.vtotal = 2160 + 259 + 8 + 8,\n\t.width_mm = 64,\n\t.height_mm = 128,\n};\n\nstatic int sony_td4353_jdi_get_modes(struct drm_panel *panel,\n\t\t\t\t   struct drm_connector *connector)\n{\n\tstruct sony_td4353_jdi *ctx = to_sony_td4353_jdi(panel);\n\tstruct drm_display_mode *mode = NULL;\n\n\tif (ctx->type == TYPE_TAMA_60HZ)\n\t\tmode = drm_mode_duplicate(connector->dev, &sony_td4353_jdi_mode_tama_60hz);\n\telse\n\t\treturn -EINVAL;\n\n\tif (!mode)\n\t\treturn -ENOMEM;\n\n\tdrm_mode_set_name(mode);\n\n\tmode->type = DRM_MODE_TYPE_DRIVER | DRM_MODE_TYPE_PREFERRED;\n\tconnector->display_info.width_mm = mode->width_mm;\n\tconnector->display_info.height_mm = mode->height_mm;\n\tdrm_mode_probed_add(connector, mode);\n\n\treturn 1;\n}\n\nstatic const struct drm_panel_funcs sony_td4353_jdi_panel_funcs = {\n\t.prepare = sony_td4353_jdi_prepare,\n\t.unprepare = sony_td4353_jdi_unprepare,\n\t.get_modes = sony_td4353_jdi_get_modes,\n};\n\nstatic int sony_td4353_jdi_probe(struct mipi_dsi_device *dsi)\n{\n\tstruct device *dev = &dsi->dev;\n\tstruct sony_td4353_jdi *ctx;\n\tint ret;\n\n\tctx = devm_kzalloc(dev, sizeof(*ctx), GFP_KERNEL);\n\tif (!ctx)\n\t\treturn -ENOMEM;\n\n\tctx->type = (uintptr_t)of_device_get_match_data(dev);\n\n\tctx->supplies[0].supply = \"vddio\";\n\tctx->supplies[1].supply = \"vsp\";\n\tctx->supplies[2].supply = \"vsn\";\n\tret = devm_regulator_bulk_get(dev, ARRAY_SIZE(ctx->supplies),\n\t\t\t\t      ctx->supplies);\n\tif (ret < 0)\n\t\treturn dev_err_probe(dev, ret, \"Failed to get regulators\\n\");\n\n\tctx->panel_reset_gpio = devm_gpiod_get(dev, \"panel-reset\", GPIOD_ASIS);\n\tif (IS_ERR(ctx->panel_reset_gpio))\n\t\treturn dev_err_probe(dev, PTR_ERR(ctx->panel_reset_gpio),\n\t\t\t\t     \"Failed to get panel-reset-gpios\\n\");\n\n\tctx->touch_reset_gpio = devm_gpiod_get(dev, \"touch-reset\", GPIOD_ASIS);\n\tif (IS_ERR(ctx->touch_reset_gpio))\n\t\treturn dev_err_probe(dev, PTR_ERR(ctx->touch_reset_gpio),\n\t\t\t\t     \"Failed to get touch-reset-gpios\\n\");\n\n\tctx->dsi = dsi;\n\tmipi_dsi_set_drvdata(dsi, ctx);\n\n\tdsi->lanes = 4;\n\tdsi->format = MIPI_DSI_FMT_RGB888;\n\tdsi->mode_flags = MIPI_DSI_CLOCK_NON_CONTINUOUS;\n\n\tdrm_panel_init(&ctx->panel, dev, &sony_td4353_jdi_panel_funcs,\n\t\t       DRM_MODE_CONNECTOR_DSI);\n\n\tret = drm_panel_of_backlight(&ctx->panel);\n\tif (ret)\n\t\treturn dev_err_probe(dev, ret, \"Failed to get backlight\\n\");\n\n\tdrm_panel_add(&ctx->panel);\n\n\tret = mipi_dsi_attach(dsi);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"Failed to attach to DSI host: %d\\n\", ret);\n\t\tdrm_panel_remove(&ctx->panel);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic void sony_td4353_jdi_remove(struct mipi_dsi_device *dsi)\n{\n\tstruct sony_td4353_jdi *ctx = mipi_dsi_get_drvdata(dsi);\n\tint ret;\n\n\tret = mipi_dsi_detach(dsi);\n\tif (ret < 0)\n\t\tdev_err(&dsi->dev, \"Failed to detach from DSI host: %d\\n\", ret);\n\n\tdrm_panel_remove(&ctx->panel);\n}\n\nstatic const struct of_device_id sony_td4353_jdi_of_match[] = {\n\t{ .compatible = \"sony,td4353-jdi-tama\", .data = (void *)TYPE_TAMA_60HZ },\n\t{   }\n};\nMODULE_DEVICE_TABLE(of, sony_td4353_jdi_of_match);\n\nstatic struct mipi_dsi_driver sony_td4353_jdi_driver = {\n\t.probe = sony_td4353_jdi_probe,\n\t.remove = sony_td4353_jdi_remove,\n\t.driver = {\n\t\t.name = \"panel-sony-td4353-jdi\",\n\t\t.of_match_table = sony_td4353_jdi_of_match,\n\t},\n};\nmodule_mipi_dsi_driver(sony_td4353_jdi_driver);\n\nMODULE_AUTHOR(\"Konrad Dybcio <konrad.dybcio@somainline.org>\");\nMODULE_DESCRIPTION(\"DRM panel driver for SONY Xperia XZ2/XZ2c JDI panel\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}