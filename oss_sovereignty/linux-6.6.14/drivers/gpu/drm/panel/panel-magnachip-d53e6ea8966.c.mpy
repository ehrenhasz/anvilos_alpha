{
  "module_name": "panel-magnachip-d53e6ea8966.c",
  "hash_id": "59d062115c6f72928feb51472ed62f33547d2acca95aabf5f074389795adc0be",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/panel/panel-magnachip-d53e6ea8966.c",
  "human_readable_source": "\n \n\n#include <drm/drm_mipi_dbi.h>\n#include <drm/drm_mipi_dsi.h>\n#include <drm/drm_modes.h>\n#include <drm/drm_of.h>\n#include <drm/drm_panel.h>\n\n#include <linux/backlight.h>\n#include <linux/delay.h>\n#include <linux/gpio/consumer.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/media-bus-format.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/regulator/consumer.h>\n#include <linux/spi/spi.h>\n\n#include <video/mipi_display.h>\n\n \nstruct d53e6ea8966;\n\n \nstruct d53e6ea8966_panel_info {\n\t \n\tconst struct drm_display_mode *display_modes;\n\t \n\tunsigned int num_modes;\n\t \n\tu16 width_mm;\n\t \n\tu16 height_mm;\n\t \n\tu32 bus_flags;\n\t \n\tvoid (*panel_init_seq)(struct d53e6ea8966 *db);\n\t \n\tint (*backlight_register)(struct d53e6ea8966 *db);\n};\n\nstruct d53e6ea8966 {\n\t \n\tstruct device *dev;\n\t \n\tstruct mipi_dbi dbi;\n\t \n\tstruct drm_panel panel;\n\t \n\tstruct gpio_desc *reset;\n\t \n\tstruct gpio_desc *enable;\n\t \n\tstruct regulator *reg_vdd;\n\t \n\tstruct regulator *reg_elvdd;\n\t \n\tstruct mipi_dsi_device *dsi_dev;\n\t \n\tstruct backlight_device *bl_dev;\n\t \n\tconst struct d53e6ea8966_panel_info *panel_info;\n};\n\n#define NUM_GAMMA_LEVELS\t16\n#define GAMMA_TABLE_COUNT\t23\n#define MAX_BRIGHTNESS\t\t(NUM_GAMMA_LEVELS - 1)\n\n#define MCS_ELVSS_ON\t\t\t0xb1\n#define MCS_TEMP_SWIRE\t\t\t0xb2\n#define MCS_PASSWORD_0\t\t\t0xf0\n#define MCS_PASSWORD_1\t\t\t0xf1\n#define MCS_ANALOG_PWR_CTL_0\t\t0xf4\n#define MCS_ANALOG_PWR_CTL_1\t\t0xf5\n#define MCS_GTCON_SET\t\t\t0xf7\n#define MCS_GATELESS_SIGNAL_SET\t\t0xf8\n#define MCS_SET_GAMMA\t\t\t0xf9\n\nstatic inline struct d53e6ea8966 *to_d53e6ea8966(struct drm_panel *panel)\n{\n\treturn container_of(panel, struct d53e6ea8966, panel);\n}\n\n \nstatic u8 ams495qa01_gamma[NUM_GAMMA_LEVELS][GAMMA_TABLE_COUNT] = {\n\t{0x01, 0x79, 0x78, 0x8d, 0xd9, 0xdf, 0xd5, 0xcb, 0xcf, 0xc5,\n\t 0xe5, 0xe0, 0xe4, 0xdc, 0xb8, 0xd4, 0xfa, 0xed, 0xe6, 0x2f,\n\t 0x00, 0x2f},\n\t{0x01, 0x7d, 0x7c, 0x92, 0xd7, 0xdd, 0xd2, 0xcb, 0xd0, 0xc6,\n\t 0xe5, 0xe1, 0xe3, 0xda, 0xbd, 0xd3, 0xfa, 0xed, 0xe6, 0x2f,\n\t 0x00, 0x2f},\n\t{0x01, 0x7f, 0x7e, 0x95, 0xd7, 0xde, 0xd2, 0xcb, 0xcf, 0xc5,\n\t 0xe5, 0xe3, 0xe3, 0xda, 0xbf, 0xd3, 0xfa, 0xed, 0xe6, 0x2f,\n\t 0x00, 0x2f},\n\t{0x01, 0x82, 0x81, 0x99, 0xd6, 0xdd, 0xd1, 0xca, 0xcf, 0xc3,\n\t 0xe4, 0xe3, 0xe3, 0xda, 0xc2, 0xd3, 0xfa, 0xed, 0xe6, 0x2f,\n\t 0x00, 0x2f},\n\t{0x01, 0x84, 0x83, 0x9b, 0xd7, 0xde, 0xd2, 0xc8, 0xce, 0xc2,\n\t 0xe4, 0xe3, 0xe2, 0xd9, 0xc3, 0xd3, 0xfa, 0xed, 0xe6, 0x2f,\n\t 0x00, 0x2f},\n\t{0x01, 0x87, 0x86, 0x9f, 0xd6, 0xdd, 0xd1, 0xc7, 0xce, 0xc1,\n\t 0xe4, 0xe3, 0xe2, 0xd9, 0xc6, 0xd3, 0xfa, 0xed, 0xe6, 0x2f,\n\t 0x00, 0x2f},\n\t{0x01, 0x89, 0x89, 0xa2, 0xd5, 0xdb, 0xcf, 0xc8, 0xcf, 0xc2,\n\t 0xe3, 0xe3, 0xe1, 0xd9, 0xc7, 0xd3, 0xfa, 0xed, 0xe6, 0x2f,\n\t 0x00, 0x2f},\n\t{0x01, 0x8b, 0x8b, 0xa5, 0xd5, 0xdb, 0xcf, 0xc7, 0xce, 0xc0,\n\t 0xe3, 0xe3, 0xe1, 0xd8, 0xc7, 0xd3, 0xfa, 0xed, 0xe6, 0x2f,\n\t 0x00, 0x2f},\n\t{0x01, 0x8d, 0x8d, 0xa7, 0xd5, 0xdb, 0xcf, 0xc6, 0xce, 0xc0,\n\t 0xe4, 0xe4, 0xe1, 0xd7, 0xc8, 0xd3, 0xfa, 0xed, 0xe6, 0x2f,\n\t 0x00, 0x2f},\n\t{0x01, 0x8f, 0x8f, 0xaa, 0xd4, 0xdb, 0xce, 0xc6, 0xcd, 0xbf,\n\t 0xe3, 0xe3, 0xe1, 0xd7, 0xca, 0xd3, 0xfa, 0xed, 0xe6, 0x2f,\n\t 0x00, 0x2f},\n\t{0x01, 0x91, 0x91, 0xac, 0xd3, 0xda, 0xce, 0xc5, 0xcd, 0xbe,\n\t 0xe3, 0xe3, 0xe0, 0xd7, 0xca, 0xd3, 0xfa, 0xed, 0xe6, 0x2f,\n\t 0x00, 0x2f},\n\t{0x01, 0x93, 0x93, 0xaf, 0xd3, 0xda, 0xcd, 0xc5, 0xcd, 0xbe,\n\t 0xe2, 0xe3, 0xdf, 0xd6, 0xca, 0xd3, 0xfa, 0xed, 0xe6, 0x2f,\n\t 0x00, 0x2f},\n\t{0x01, 0x95, 0x95, 0xb1, 0xd2, 0xd9, 0xcc, 0xc4, 0xcd, 0xbe,\n\t 0xe2, 0xe3, 0xdf, 0xd7, 0xcc, 0xd3, 0xfa, 0xed, 0xe6, 0x2f,\n\t 0x00, 0x2f},\n\t{0x01, 0x99, 0x99, 0xb6, 0xd1, 0xd9, 0xcc, 0xc3, 0xcb, 0xbc,\n\t 0xe2, 0xe4, 0xdf, 0xd6, 0xcc, 0xd3, 0xfa, 0xed, 0xe6, 0x2f,\n\t 0x00, 0x2f},\n\t{0x01, 0x9c, 0x9c, 0xba, 0xd0, 0xd8, 0xcb, 0xc3, 0xcb, 0xbb,\n\t 0xe2, 0xe4, 0xdf, 0xd6, 0xce, 0xd3, 0xfa, 0xed, 0xe6, 0x2f,\n\t 0x00, 0x2f},\n\t{0x01, 0x9f, 0x9f, 0xbe, 0xcf, 0xd7, 0xc9, 0xc2, 0xcb, 0xbb,\n\t 0xe1, 0xe3, 0xde, 0xd6, 0xd0, 0xd3, 0xfa, 0xed, 0xe6, 0x2f,\n\t 0x00, 0x2f},\n};\n\n \nstatic u8 ams495qa01_elvss[NUM_GAMMA_LEVELS] = {\n\t0x15, 0x15, 0x15, 0x15, 0x15, 0x15, 0x15, 0x15, 0x15, 0x15,\n\t0x15, 0x15, 0x14, 0x14, 0x13, 0x12,\n};\n\nstatic int ams495qa01_update_gamma(struct mipi_dbi *dbi, int brightness)\n{\n\tint tmp = brightness;\n\n\tmipi_dbi_command_buf(dbi, MCS_SET_GAMMA, ams495qa01_gamma[tmp],\n\t\t\t     ARRAY_SIZE(ams495qa01_gamma[tmp]));\n\tmipi_dbi_command(dbi, MCS_SET_GAMMA, 0x00);\n\n\t \n\tmipi_dbi_command(dbi, 0x26, 0x00);\n\n\tmipi_dbi_command(dbi, MCS_TEMP_SWIRE, ams495qa01_elvss[tmp]);\n\n\treturn 0;\n}\n\nstatic void ams495qa01_panel_init(struct d53e6ea8966 *db)\n{\n\tstruct mipi_dbi *dbi = &db->dbi;\n\n\tmipi_dbi_command(dbi, MCS_PASSWORD_0, 0x5a, 0x5a);\n\tmipi_dbi_command(dbi, MCS_PASSWORD_1, 0x5a, 0x5a);\n\n\t \n\tmipi_dbi_command(dbi, 0xb0, 0x02);\n\tmipi_dbi_command(dbi, 0xf3, 0x3b);\n\n\tmipi_dbi_command(dbi, MCS_ANALOG_PWR_CTL_0, 0x33, 0x42, 0x00, 0x08);\n\tmipi_dbi_command(dbi, MCS_ANALOG_PWR_CTL_1, 0x00, 0x06, 0x26, 0x35, 0x03);\n\n\t \n\tmipi_dbi_command(dbi, 0xf6, 0x02);\n\tmipi_dbi_command(dbi, 0xc6, 0x0b, 0x00, 0x00, 0x3c, 0x00, 0x22,\n\t\t\t 0x00, 0x00, 0x00, 0x00);\n\n\tmipi_dbi_command(dbi, MCS_GTCON_SET, 0x20);\n\tmipi_dbi_command(dbi, MCS_TEMP_SWIRE, 0x06, 0x06, 0x06, 0x06);\n\tmipi_dbi_command(dbi, MCS_ELVSS_ON, 0x07, 0x00, 0x10);\n\tmipi_dbi_command(dbi, MCS_GATELESS_SIGNAL_SET, 0x7f, 0x7a,\n\t\t\t 0x89, 0x67, 0x26, 0x38, 0x00, 0x00, 0x09,\n\t\t\t 0x67, 0x70, 0x88, 0x7a, 0x76, 0x05, 0x09,\n\t\t\t 0x23, 0x23, 0x23);\n\n\t \n\tmipi_dbi_command(dbi, 0xb5, 0xff, 0xef, 0x35, 0x42, 0x0d, 0xd7,\n\t\t\t 0xff, 0x07, 0xff, 0xff, 0xfd, 0x00, 0x01,\n\t\t\t 0xff, 0x05, 0x12, 0x0f, 0xff, 0xff, 0xff,\n\t\t\t 0xff);\n\tmipi_dbi_command(dbi, 0xb4, 0x15);\n\tmipi_dbi_command(dbi, 0xb3, 0x00);\n\n\tams495qa01_update_gamma(dbi, MAX_BRIGHTNESS);\n}\n\nstatic int d53e6ea8966_prepare(struct drm_panel *panel)\n{\n\tstruct d53e6ea8966 *db = to_d53e6ea8966(panel);\n\tint ret;\n\n\t \n\tret = regulator_enable(db->reg_vdd);\n\tif (ret) {\n\t\tdev_err(db->dev, \"failed to enable vdd regulator: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tif (db->reg_elvdd) {\n\t\tret = regulator_enable(db->reg_elvdd);\n\t\tif (ret) {\n\t\t\tdev_err(db->dev,\n\t\t\t\t\"failed to enable elvdd regulator: %d\\n\", ret);\n\t\t\tregulator_disable(db->reg_vdd);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\t \n\tif (db->enable)\n\t\tgpiod_set_value_cansleep(db->enable, 1);\n\n\tmsleep(50);\n\n\t \n\tgpiod_set_value_cansleep(db->reset, 1);\n\tusleep_range(1000, 5000);\n\tgpiod_set_value_cansleep(db->reset, 0);\n\tmsleep(20);\n\n\tdb->panel_info->panel_init_seq(db);\n\n\treturn 0;\n}\n\nstatic int d53e6ea8966_enable(struct drm_panel *panel)\n{\n\tstruct d53e6ea8966 *db = to_d53e6ea8966(panel);\n\tstruct mipi_dbi *dbi = &db->dbi;\n\n\tmipi_dbi_command(dbi, MIPI_DCS_EXIT_SLEEP_MODE);\n\tmsleep(200);\n\tmipi_dbi_command(dbi, MIPI_DCS_SET_DISPLAY_ON);\n\tusleep_range(10000, 15000);\n\n\treturn 0;\n}\n\nstatic int d53e6ea8966_disable(struct drm_panel *panel)\n{\n\tstruct d53e6ea8966 *db = to_d53e6ea8966(panel);\n\tstruct mipi_dbi *dbi = &db->dbi;\n\n\tmipi_dbi_command(dbi, MIPI_DCS_SET_DISPLAY_OFF);\n\tmsleep(20);\n\tmipi_dbi_command(dbi, MIPI_DCS_ENTER_SLEEP_MODE);\n\tmsleep(100);\n\n\treturn 0;\n}\n\nstatic int d53e6ea8966_unprepare(struct drm_panel *panel)\n{\n\tstruct d53e6ea8966 *db = to_d53e6ea8966(panel);\n\n\tif (db->enable)\n\t\tgpiod_set_value_cansleep(db->enable, 0);\n\n\tgpiod_set_value_cansleep(db->reset, 1);\n\n\tif (db->reg_elvdd)\n\t\tregulator_disable(db->reg_elvdd);\n\n\tregulator_disable(db->reg_vdd);\n\tmsleep(100);\n\n\treturn 0;\n}\n\nstatic int d53e6ea8966_get_modes(struct drm_panel *panel,\n\t\t\t\t struct drm_connector *connector)\n{\n\tstruct d53e6ea8966 *db = to_d53e6ea8966(panel);\n\tconst struct d53e6ea8966_panel_info *panel_info = db->panel_info;\n\tstruct drm_display_mode *mode;\n\tstatic const u32 bus_format = MEDIA_BUS_FMT_RGB888_1X24;\n\tunsigned int i;\n\n\tfor (i = 0; i < panel_info->num_modes; i++) {\n\t\tmode = drm_mode_duplicate(connector->dev,\n\t\t\t\t\t  &panel_info->display_modes[i]);\n\t\tif (!mode)\n\t\t\treturn -ENOMEM;\n\n\t\tdrm_mode_set_name(mode);\n\t\tdrm_mode_probed_add(connector, mode);\n\t}\n\n\tconnector->display_info.bpc = 8;\n\tconnector->display_info.width_mm = panel_info->width_mm;\n\tconnector->display_info.height_mm = panel_info->height_mm;\n\tconnector->display_info.bus_flags = panel_info->bus_flags;\n\n\tdrm_display_info_set_bus_formats(&connector->display_info,\n\t\t\t\t\t &bus_format, 1);\n\n\treturn 1;\n}\n\nstatic const struct drm_panel_funcs d53e6ea8966_panel_funcs = {\n\t.disable = d53e6ea8966_disable,\n\t.enable = d53e6ea8966_enable,\n\t.get_modes = d53e6ea8966_get_modes,\n\t.prepare = d53e6ea8966_prepare,\n\t.unprepare = d53e6ea8966_unprepare,\n};\n\nstatic int ams495qa01_set_brightness(struct backlight_device *bd)\n{\n\tstruct d53e6ea8966 *db = bl_get_data(bd);\n\tstruct mipi_dbi *dbi = &db->dbi;\n\tint brightness = backlight_get_brightness(bd);\n\n\tams495qa01_update_gamma(dbi, brightness);\n\n\treturn 0;\n}\n\nstatic const struct backlight_ops ams495qa01_backlight_ops = {\n\t.update_status\t= ams495qa01_set_brightness,\n};\n\nstatic int ams495qa01_backlight_register(struct d53e6ea8966 *db)\n{\n\tstruct backlight_properties props = {\n\t\t.type\t\t= BACKLIGHT_RAW,\n\t\t.brightness\t= MAX_BRIGHTNESS,\n\t\t.max_brightness = MAX_BRIGHTNESS,\n\t};\n\tstruct device *dev = db->dev;\n\tint ret = 0;\n\n\tdb->bl_dev = devm_backlight_device_register(dev, \"panel\", dev, db,\n\t\t\t\t\t\t    &ams495qa01_backlight_ops,\n\t\t\t\t\t\t    &props);\n\tif (IS_ERR(db->bl_dev)) {\n\t\tret = PTR_ERR(db->bl_dev);\n\t\tdev_err(dev, \"error registering backlight device (%d)\\n\", ret);\n\t}\n\n\treturn ret;\n}\n\nstatic int d53e6ea8966_probe(struct spi_device *spi)\n{\n\tstruct device *dev = &spi->dev;\n\tstruct mipi_dsi_host *dsi_host;\n\tstruct d53e6ea8966 *db;\n\tint ret;\n\tstruct mipi_dsi_device_info info = {\n\t\t.type = \"d53e6ea8966\",\n\t\t.channel = 0,\n\t\t.node = NULL,\n\t};\n\n\tdb = devm_kzalloc(dev, sizeof(*db), GFP_KERNEL);\n\tif (!db)\n\t\treturn -ENOMEM;\n\n\tspi_set_drvdata(spi, db);\n\n\tdb->dev = dev;\n\n\tdb->panel_info = of_device_get_match_data(dev);\n\tif (!db->panel_info)\n\t\treturn -EINVAL;\n\n\tdb->reg_vdd = devm_regulator_get(dev, \"vdd\");\n\tif (IS_ERR(db->reg_vdd))\n\t\treturn dev_err_probe(dev, PTR_ERR(db->reg_vdd),\n\t\t\t\t     \"Failed to get vdd supply\\n\");\n\n\tdb->reg_elvdd = devm_regulator_get_optional(dev, \"elvdd\");\n\tif (IS_ERR(db->reg_elvdd))\n\t\tdb->reg_elvdd = NULL;\n\n\tdb->reset = devm_gpiod_get(dev, \"reset\", GPIOD_OUT_HIGH);\n\tif (IS_ERR(db->reset)) {\n\t\tret = PTR_ERR(db->reset);\n\t\treturn dev_err_probe(dev, ret, \"no RESET GPIO\\n\");\n\t}\n\n\tdb->enable = devm_gpiod_get_optional(dev, \"enable\", GPIOD_OUT_LOW);\n\tif (IS_ERR(db->enable)) {\n\t\tret = PTR_ERR(db->enable);\n\t\treturn dev_err_probe(dev, ret, \"cannot get ENABLE GPIO\\n\");\n\t}\n\n\tret = mipi_dbi_spi_init(spi, &db->dbi, NULL);\n\tif (ret)\n\t\treturn dev_err_probe(dev, ret, \"MIPI DBI init failed\\n\");\n\n\tdsi_host = drm_of_get_dsi_bus(dev);\n\tif (IS_ERR(dsi_host)) {\n\t\tret = PTR_ERR(dsi_host);\n\t\treturn dev_err_probe(dev, ret, \"Error attaching DSI bus\\n\");\n\t}\n\n\tdb->dsi_dev = devm_mipi_dsi_device_register_full(dev, dsi_host, &info);\n\tif (IS_ERR(db->dsi_dev)) {\n\t\tdev_err(dev, \"failed to register dsi device: %ld\\n\",\n\t\t\tPTR_ERR(db->dsi_dev));\n\t\treturn PTR_ERR(db->dsi_dev);\n\t}\n\n\tdb->dsi_dev->lanes = 2;\n\tdb->dsi_dev->format = MIPI_DSI_FMT_RGB888;\n\tdb->dsi_dev->mode_flags = MIPI_DSI_MODE_VIDEO | MIPI_DSI_MODE_VIDEO_BURST |\n\t\t\t  MIPI_DSI_MODE_LPM | MIPI_DSI_MODE_NO_EOT_PACKET;\n\n\tdrm_panel_init(&db->panel, dev, &d53e6ea8966_panel_funcs,\n\t\t       DRM_MODE_CONNECTOR_DSI);\n\n\tif (db->panel_info->backlight_register) {\n\t\tret = db->panel_info->backlight_register(db);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tdb->panel.backlight = db->bl_dev;\n\t}\n\n\tdrm_panel_add(&db->panel);\n\n\tret = devm_mipi_dsi_attach(dev, db->dsi_dev);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"mipi_dsi_attach failed: %d\\n\", ret);\n\t\tdrm_panel_remove(&db->panel);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic void d53e6ea8966_remove(struct spi_device *spi)\n{\n\tstruct d53e6ea8966 *db = spi_get_drvdata(spi);\n\n\tdrm_panel_remove(&db->panel);\n}\n\nstatic const struct drm_display_mode ams495qa01_modes[] = {\n\t{  \n\t\t.clock = 33500,\n\t\t.hdisplay = 960,\n\t\t.hsync_start = 960 + 10,\n\t\t.hsync_end = 960 + 10 + 2,\n\t\t.htotal = 960 + 10 + 2 + 10,\n\t\t.vdisplay = 544,\n\t\t.vsync_start = 544 + 10,\n\t\t.vsync_end = 544 + 10 + 2,\n\t\t.vtotal = 544 + 10 + 2 + 10,\n\t\t.flags = DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_NVSYNC,\n\t\t.type = DRM_MODE_TYPE_DRIVER | DRM_MODE_TYPE_PREFERRED,\n\t\t},\n\t{  \n\t\t.clock = 27800,\n\t\t.hdisplay = 960,\n\t\t.hsync_start = 960 + 10,\n\t\t.hsync_end = 960 + 10 + 2,\n\t\t.htotal = 960 + 10 + 2 + 10,\n\t\t.vdisplay = 544,\n\t\t.vsync_start = 544 + 10,\n\t\t.vsync_end = 544 + 10 + 2,\n\t\t.vtotal = 544 + 10 + 2 + 10,\n\t\t.flags = DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_NVSYNC,\n\t\t.type = DRM_MODE_TYPE_DRIVER,\n\t},\n};\n\nstatic const struct d53e6ea8966_panel_info ams495qa01_info = {\n\t.display_modes = ams495qa01_modes,\n\t.num_modes = ARRAY_SIZE(ams495qa01_modes),\n\t.width_mm = 117,\n\t.height_mm = 74,\n\t.bus_flags = DRM_BUS_FLAG_DE_LOW | DRM_BUS_FLAG_PIXDATA_DRIVE_NEGEDGE,\n\t.panel_init_seq = ams495qa01_panel_init,\n\t.backlight_register = ams495qa01_backlight_register,\n};\n\nstatic const struct of_device_id d53e6ea8966_match[] = {\n\t{ .compatible = \"samsung,ams495qa01\", .data = &ams495qa01_info },\n\t{   },\n};\nMODULE_DEVICE_TABLE(of, d53e6ea8966_match);\n\nstatic const struct spi_device_id d53e6ea8966_ids[] = {\n\t{ \"ams495qa01\", 0 },\n\t{   },\n};\nMODULE_DEVICE_TABLE(spi, d53e6ea8966_ids);\n\nstatic struct spi_driver d53e6ea8966_driver = {\n\t.driver\t\t= {\n\t\t.name\t= \"d53e6ea8966-panel\",\n\t\t.of_match_table = d53e6ea8966_match,\n\t},\n\t.id_table\t= d53e6ea8966_ids,\n\t.probe\t\t= d53e6ea8966_probe,\n\t.remove\t\t= d53e6ea8966_remove,\n};\nmodule_spi_driver(d53e6ea8966_driver);\n\nMODULE_AUTHOR(\"Chris Morgan <macromorgan@hotmail.com>\");\nMODULE_DESCRIPTION(\"Magnachip d53e6ea8966 panel driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}