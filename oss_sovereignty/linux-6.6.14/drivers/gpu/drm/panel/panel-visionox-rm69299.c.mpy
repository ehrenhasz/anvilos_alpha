{
  "module_name": "panel-visionox-rm69299.c",
  "hash_id": "ccf7365265202cacbee4ace7de1329a5ee5cef68f87a472f59511e180879e4d6",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/panel/panel-visionox-rm69299.c",
  "human_readable_source": "\n \n\n#include <linux/delay.h>\n#include <linux/module.h>\n#include <linux/mod_devicetable.h>\n#include <linux/gpio/consumer.h>\n#include <linux/regulator/consumer.h>\n\n#include <video/mipi_display.h>\n\n#include <drm/drm_mipi_dsi.h>\n#include <drm/drm_modes.h>\n#include <drm/drm_panel.h>\n\nstruct visionox_rm69299 {\n\tstruct drm_panel panel;\n\tstruct regulator_bulk_data supplies[2];\n\tstruct gpio_desc *reset_gpio;\n\tstruct mipi_dsi_device *dsi;\n\tbool prepared;\n\tbool enabled;\n};\n\nstatic inline struct visionox_rm69299 *panel_to_ctx(struct drm_panel *panel)\n{\n\treturn container_of(panel, struct visionox_rm69299, panel);\n}\n\nstatic int visionox_rm69299_power_on(struct visionox_rm69299 *ctx)\n{\n\tint ret;\n\n\tret = regulator_bulk_enable(ARRAY_SIZE(ctx->supplies), ctx->supplies);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tgpiod_set_value(ctx->reset_gpio, 1);\n\tusleep_range(10000, 20000);\n\tgpiod_set_value(ctx->reset_gpio, 0);\n\tusleep_range(10000, 20000);\n\tgpiod_set_value(ctx->reset_gpio, 1);\n\tusleep_range(10000, 20000);\n\n\treturn 0;\n}\n\nstatic int visionox_rm69299_power_off(struct visionox_rm69299 *ctx)\n{\n\tgpiod_set_value(ctx->reset_gpio, 0);\n\n\treturn regulator_bulk_disable(ARRAY_SIZE(ctx->supplies), ctx->supplies);\n}\n\nstatic int visionox_rm69299_unprepare(struct drm_panel *panel)\n{\n\tstruct visionox_rm69299 *ctx = panel_to_ctx(panel);\n\tint ret;\n\n\tctx->dsi->mode_flags = 0;\n\n\tret = mipi_dsi_dcs_write(ctx->dsi, MIPI_DCS_SET_DISPLAY_OFF, NULL, 0);\n\tif (ret < 0)\n\t\tdev_err(ctx->panel.dev, \"set_display_off cmd failed ret = %d\\n\", ret);\n\n\t \n\tmsleep(120);\n\n\tret = mipi_dsi_dcs_write(ctx->dsi, MIPI_DCS_ENTER_SLEEP_MODE, NULL, 0);\n\tif (ret < 0) {\n\t\tdev_err(ctx->panel.dev, \"enter_sleep cmd failed ret = %d\\n\", ret);\n\t}\n\n\tret = visionox_rm69299_power_off(ctx);\n\n\tctx->prepared = false;\n\treturn ret;\n}\n\nstatic int visionox_rm69299_prepare(struct drm_panel *panel)\n{\n\tstruct visionox_rm69299 *ctx = panel_to_ctx(panel);\n\tint ret;\n\n\tif (ctx->prepared)\n\t\treturn 0;\n\n\tret = visionox_rm69299_power_on(ctx);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tctx->dsi->mode_flags |= MIPI_DSI_MODE_LPM;\n\n\tret = mipi_dsi_dcs_write_buffer(ctx->dsi, (u8[]) { 0xfe, 0x00 }, 2);\n\tif (ret < 0) {\n\t\tdev_err(ctx->panel.dev, \"cmd set tx 0 failed, ret = %d\\n\", ret);\n\t\tgoto power_off;\n\t}\n\n\tret = mipi_dsi_dcs_write_buffer(ctx->dsi, (u8[]) { 0xc2, 0x08 }, 2);\n\tif (ret < 0) {\n\t\tdev_err(ctx->panel.dev, \"cmd set tx 1 failed, ret = %d\\n\", ret);\n\t\tgoto power_off;\n\t}\n\n\tret = mipi_dsi_dcs_write_buffer(ctx->dsi, (u8[]) { 0x35, 0x00 }, 2);\n\tif (ret < 0) {\n\t\tdev_err(ctx->panel.dev, \"cmd set tx 2 failed, ret = %d\\n\", ret);\n\t\tgoto power_off;\n\t}\n\n\tret = mipi_dsi_dcs_write_buffer(ctx->dsi, (u8[]) { 0x51, 0xff }, 2);\n\tif (ret < 0) {\n\t\tdev_err(ctx->panel.dev, \"cmd set tx 3 failed, ret = %d\\n\", ret);\n\t\tgoto power_off;\n\t}\n\n\tret = mipi_dsi_dcs_write(ctx->dsi, MIPI_DCS_EXIT_SLEEP_MODE, NULL, 0);\n\tif (ret < 0) {\n\t\tdev_err(ctx->panel.dev, \"exit_sleep_mode cmd failed ret = %d\\n\", ret);\n\t\tgoto power_off;\n\t}\n\n\t \n\tmsleep(120);\n\n\tret = mipi_dsi_dcs_write(ctx->dsi, MIPI_DCS_SET_DISPLAY_ON, NULL, 0);\n\tif (ret < 0) {\n\t\tdev_err(ctx->panel.dev, \"set_display_on cmd failed ret = %d\\n\", ret);\n\t\tgoto power_off;\n\t}\n\n\t \n\tmsleep(120);\n\n\tctx->prepared = true;\n\n\treturn 0;\n\npower_off:\n\treturn ret;\n}\n\nstatic const struct drm_display_mode visionox_rm69299_1080x2248_60hz = {\n\t.name = \"1080x2248\",\n\t.clock = 158695,\n\t.hdisplay = 1080,\n\t.hsync_start = 1080 + 26,\n\t.hsync_end = 1080 + 26 + 2,\n\t.htotal = 1080 + 26 + 2 + 36,\n\t.vdisplay = 2248,\n\t.vsync_start = 2248 + 56,\n\t.vsync_end = 2248 + 56 + 4,\n\t.vtotal = 2248 + 56 + 4 + 4,\n\t.flags = 0,\n};\n\nstatic int visionox_rm69299_get_modes(struct drm_panel *panel,\n\t\t\t\t      struct drm_connector *connector)\n{\n\tstruct visionox_rm69299 *ctx = panel_to_ctx(panel);\n\tstruct drm_display_mode *mode;\n\n\tmode = drm_mode_duplicate(connector->dev,\n\t\t\t\t  &visionox_rm69299_1080x2248_60hz);\n\tif (!mode) {\n\t\tdev_err(ctx->panel.dev, \"failed to create a new display mode\\n\");\n\t\treturn 0;\n\t}\n\n\tconnector->display_info.width_mm = 74;\n\tconnector->display_info.height_mm = 131;\n\tmode->type = DRM_MODE_TYPE_DRIVER | DRM_MODE_TYPE_PREFERRED;\n\tdrm_mode_probed_add(connector, mode);\n\n\treturn 1;\n}\n\nstatic const struct drm_panel_funcs visionox_rm69299_drm_funcs = {\n\t.unprepare = visionox_rm69299_unprepare,\n\t.prepare = visionox_rm69299_prepare,\n\t.get_modes = visionox_rm69299_get_modes,\n};\n\nstatic int visionox_rm69299_probe(struct mipi_dsi_device *dsi)\n{\n\tstruct device *dev = &dsi->dev;\n\tstruct visionox_rm69299 *ctx;\n\tint ret;\n\n\tctx = devm_kzalloc(dev, sizeof(*ctx), GFP_KERNEL);\n\tif (!ctx)\n\t\treturn -ENOMEM;\n\n\tmipi_dsi_set_drvdata(dsi, ctx);\n\n\tctx->panel.dev = dev;\n\tctx->dsi = dsi;\n\n\tctx->supplies[0].supply = \"vdda\";\n\tctx->supplies[1].supply = \"vdd3p3\";\n\n\tret = devm_regulator_bulk_get(ctx->panel.dev, ARRAY_SIZE(ctx->supplies),\n\t\t\t\t      ctx->supplies);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tctx->reset_gpio = devm_gpiod_get(ctx->panel.dev,\n\t\t\t\t\t \"reset\", GPIOD_OUT_LOW);\n\tif (IS_ERR(ctx->reset_gpio)) {\n\t\tdev_err(dev, \"cannot get reset gpio %ld\\n\", PTR_ERR(ctx->reset_gpio));\n\t\treturn PTR_ERR(ctx->reset_gpio);\n\t}\n\n\tdrm_panel_init(&ctx->panel, dev, &visionox_rm69299_drm_funcs,\n\t\t       DRM_MODE_CONNECTOR_DSI);\n\tctx->panel.dev = dev;\n\tctx->panel.funcs = &visionox_rm69299_drm_funcs;\n\tdrm_panel_add(&ctx->panel);\n\n\tdsi->lanes = 4;\n\tdsi->format = MIPI_DSI_FMT_RGB888;\n\tdsi->mode_flags = MIPI_DSI_MODE_VIDEO | MIPI_DSI_MODE_LPM |\n\t\t\t  MIPI_DSI_CLOCK_NON_CONTINUOUS;\n\tret = mipi_dsi_attach(dsi);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"dsi attach failed ret = %d\\n\", ret);\n\t\tgoto err_dsi_attach;\n\t}\n\n\tret = regulator_set_load(ctx->supplies[0].consumer, 32000);\n\tif (ret) {\n\t\tdev_err(dev, \"regulator set load failed for vdda supply ret = %d\\n\", ret);\n\t\tgoto err_set_load;\n\t}\n\n\tret = regulator_set_load(ctx->supplies[1].consumer, 13200);\n\tif (ret) {\n\t\tdev_err(dev, \"regulator set load failed for vdd3p3 supply ret = %d\\n\", ret);\n\t\tgoto err_set_load;\n\t}\n\n\treturn 0;\n\nerr_set_load:\n\tmipi_dsi_detach(dsi);\nerr_dsi_attach:\n\tdrm_panel_remove(&ctx->panel);\n\treturn ret;\n}\n\nstatic void visionox_rm69299_remove(struct mipi_dsi_device *dsi)\n{\n\tstruct visionox_rm69299 *ctx = mipi_dsi_get_drvdata(dsi);\n\n\tmipi_dsi_detach(ctx->dsi);\n\tmipi_dsi_device_unregister(ctx->dsi);\n\n\tdrm_panel_remove(&ctx->panel);\n}\n\nstatic const struct of_device_id visionox_rm69299_of_match[] = {\n\t{ .compatible = \"visionox,rm69299-1080p-display\", },\n\t{   }\n};\nMODULE_DEVICE_TABLE(of, visionox_rm69299_of_match);\n\nstatic struct mipi_dsi_driver visionox_rm69299_driver = {\n\t.driver = {\n\t\t.name = \"panel-visionox-rm69299\",\n\t\t.of_match_table = visionox_rm69299_of_match,\n\t},\n\t.probe = visionox_rm69299_probe,\n\t.remove = visionox_rm69299_remove,\n};\nmodule_mipi_dsi_driver(visionox_rm69299_driver);\n\nMODULE_DESCRIPTION(\"Visionox RM69299 DSI Panel Driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}