{
  "module_name": "panel-ilitek-ili9341.c",
  "hash_id": "c862a28af426a2dcafc0a1a18c9de7312beae01b6f8b499deaae5e68a998a8be",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/panel/panel-ilitek-ili9341.c",
  "human_readable_source": "\n \n\n#include <linux/backlight.h>\n#include <linux/bitops.h>\n#include <linux/delay.h>\n#include <linux/gpio/consumer.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/regulator/consumer.h>\n#include <linux/spi/spi.h>\n\n#include <video/mipi_display.h>\n\n#include <drm/drm_atomic_helper.h>\n#include <drm/drm_drv.h>\n#include <drm/drm_fbdev_generic.h>\n#include <drm/drm_gem_atomic_helper.h>\n#include <drm/drm_gem_dma_helper.h>\n#include <drm/drm_gem_framebuffer_helper.h>\n#include <drm/drm_mipi_dbi.h>\n#include <drm/drm_modes.h>\n#include <drm/drm_panel.h>\n#include <drm/drm_print.h>\n\n#define ILI9341_RGB_INTERFACE  0xb0    \n#define ILI9341_FRC            0xb1    \n#define ILI9341_DFC            0xb6    \n#define ILI9341_POWER1         0xc0    \n#define ILI9341_POWER2         0xc1    \n#define ILI9341_VCOM1          0xc5    \n#define ILI9341_VCOM2          0xc7    \n#define ILI9341_POWERA         0xcb    \n#define ILI9341_POWERB         0xcf    \n#define ILI9341_PGAMMA         0xe0    \n#define ILI9341_NGAMMA         0xe1    \n#define ILI9341_DTCA           0xe8    \n#define ILI9341_DTCB           0xea    \n#define ILI9341_POWER_SEQ      0xed    \n#define ILI9341_3GAMMA_EN      0xf2    \n#define ILI9341_INTERFACE      0xf6    \n#define ILI9341_PRC            0xf7    \n#define ILI9341_ETMOD\t       0xb7    \n\n#define ILI9341_MADCTL_BGR\tBIT(3)\n#define ILI9341_MADCTL_MV\tBIT(5)\n#define ILI9341_MADCTL_MX\tBIT(6)\n#define ILI9341_MADCTL_MY\tBIT(7)\n\n#define ILI9341_POWER_B_LEN\t3\n#define ILI9341_POWER_SEQ_LEN\t4\n#define ILI9341_DTCA_LEN\t3\n#define ILI9341_DTCB_LEN\t2\n#define ILI9341_POWER_A_LEN\t5\n#define ILI9341_DFC_1_LEN\t2\n#define ILI9341_FRC_LEN\t\t2\n#define ILI9341_VCOM_1_LEN\t2\n#define ILI9341_DFC_2_LEN\t4\n#define ILI9341_COLUMN_ADDR_LEN\t4\n#define ILI9341_PAGE_ADDR_LEN\t4\n#define ILI9341_INTERFACE_LEN\t3\n#define ILI9341_PGAMMA_LEN\t15\n#define ILI9341_NGAMMA_LEN\t15\n#define ILI9341_CA_LEN\t\t3\n\n#define ILI9341_PIXEL_DPI_16_BITS\t(BIT(6) | BIT(4))\n#define ILI9341_PIXEL_DPI_18_BITS\t(BIT(6) | BIT(5))\n#define ILI9341_GAMMA_CURVE_1\t\tBIT(0)\n#define ILI9341_IF_WE_MODE\t\tBIT(0)\n#define ILI9341_IF_BIG_ENDIAN\t\t0x00\n#define ILI9341_IF_DM_RGB\t\tBIT(2)\n#define ILI9341_IF_DM_INTERNAL\t\t0x00\n#define ILI9341_IF_DM_VSYNC\t\tBIT(3)\n#define ILI9341_IF_RM_RGB\t\tBIT(1)\n#define ILI9341_IF_RIM_RGB\t\t0x00\n\n#define ILI9341_COLUMN_ADDR\t\t0x00ef\n#define ILI9341_PAGE_ADDR\t\t0x013f\n\n#define ILI9341_RGB_EPL\t\t\tBIT(0)\n#define ILI9341_RGB_DPL\t\t\tBIT(1)\n#define ILI9341_RGB_HSPL\t\tBIT(2)\n#define ILI9341_RGB_VSPL\t\tBIT(3)\n#define ILI9341_RGB_DE_MODE\t\tBIT(6)\n#define ILI9341_RGB_DISP_PATH_MEM\tBIT(7)\n\n#define ILI9341_DBI_VCOMH_4P6V\t\t0x23\n#define ILI9341_DBI_PWR_2_DEFAULT\t0x10\n#define ILI9341_DBI_PRC_NORMAL\t\t0x20\n#define ILI9341_DBI_VCOM_1_VMH_4P25V\t0x3e\n#define ILI9341_DBI_VCOM_1_VML_1P5V\t0x28\n#define ILI9341_DBI_VCOM_2_DEC_58\t0x86\n#define ILI9341_DBI_FRC_DIVA\t\t0x00\n#define ILI9341_DBI_FRC_RTNA\t\t0x1b\n#define ILI9341_DBI_EMS_GAS\t\tBIT(0)\n#define ILI9341_DBI_EMS_DTS\t\tBIT(1)\n#define ILI9341_DBI_EMS_GON\t\tBIT(2)\n\n \nstruct ili9341_config {\n\tu32 max_spi_speed;\n\t \n\tconst struct drm_display_mode mode;\n\t \n\tu8 ca[ILI9341_CA_LEN];\n\t \n\tu8 power_b[ILI9341_POWER_B_LEN];\n\t \n\tu8 power_seq[ILI9341_POWER_SEQ_LEN];\n\t \n\tu8 dtca[ILI9341_DTCA_LEN];\n\t \n\tu8 dtcb[ILI9341_DTCB_LEN];\n\t \n\tu8 power_a[ILI9341_POWER_A_LEN];\n\t \n\tu8 frc[ILI9341_FRC_LEN];\n\t \n\tu8 prc;\n\t \n\tu8 dfc_1[ILI9341_DFC_1_LEN];\n\t \n\tu8 power_1;\n\t \n\tu8 power_2;\n\t \n\tu8 vcom_1[ILI9341_VCOM_1_LEN];\n\t \n\tu8 vcom_2;\n\t \n\tu8 address_mode;\n\t \n\tu8 g3amma_en;\n\t \n\tu8 rgb_interface;\n\t \n\tu8 dfc_2[ILI9341_DFC_2_LEN];\n\t \n\tu8 column_addr[ILI9341_COLUMN_ADDR_LEN];\n\t \n\tu8 page_addr[ILI9341_PAGE_ADDR_LEN];\n\t \n\tu8 interface[ILI9341_INTERFACE_LEN];\n\t \n\tu8 pixel_format;\n\t \n\tu8 gamma_curve;\n\t \n\tu8 pgamma[ILI9341_PGAMMA_LEN];\n\t \n\tu8 ngamma[ILI9341_NGAMMA_LEN];\n};\n\nstruct ili9341 {\n\tstruct device *dev;\n\tconst struct ili9341_config *conf;\n\tstruct drm_panel panel;\n\tstruct gpio_desc *reset_gpio;\n\tstruct gpio_desc *dc_gpio;\n\tstruct mipi_dbi *dbi;\n\tu32 max_spi_speed;\n\tstruct regulator_bulk_data supplies[3];\n};\n\n \nstatic const struct ili9341_config ili9341_stm32f429_disco_data = {\n\t.max_spi_speed = 10000000,\n\t.mode = {\n\t\t.clock = 6100,\n\t\t.hdisplay = 240,\n\t\t.hsync_start = 240 + 10, \n\t\t.hsync_end = 240 + 10 + 10, \n\t\t.htotal = 240 + 10 + 10 + 20, \n\t\t.vdisplay = 320,\n\t\t.vsync_start = 320 + 4, \n\t\t.vsync_end = 320 + 4 + 2, \n\t\t.vtotal = 320 + 4 + 2 + 2, \n\t\t.flags = 0,\n\t\t.width_mm = 65,\n\t\t.height_mm = 50,\n\t\t.type = DRM_MODE_TYPE_DRIVER | DRM_MODE_TYPE_PREFERRED,\n\t},\n\t.ca = {0xc3, 0x08, 0x50},\n\t.power_b = {0x00, 0xc1, 0x30},\n\t.power_seq = {0x64, 0x03, 0x12, 0x81},\n\t.dtca = {0x85, 0x00, 0x78},\n\t.power_a = {0x39, 0x2c, 0x00, 0x34, 0x02},\n\t.prc = 0x20,\n\t.dtcb = {0x00, 0x00},\n\t \n\t.frc = {0x00, 0x1b},\n\t \n\t.dfc_1 = {0x0a, 0xa2},\n\t \n\t.power_1 = 0x10,\n\t \n\t.power_2 = 0x10,\n\t \n\t.vcom_1 = {0x45, 0x15},\n\t \n\t.vcom_2 = 0x90,\n\t \n\t.address_mode = 0xc8,\n\t.g3amma_en = 0x00,\n\t \n\t.rgb_interface = ILI9341_RGB_DISP_PATH_MEM |\n\t\t\tILI9341_RGB_DE_MODE |\n\t\t\tILI9341_RGB_DPL,\n\t \n\t.dfc_2 = {0x0a, 0xa7, 0x27, 0x04},\n\t \n\t.column_addr = {0x00, 0x00, (ILI9341_COLUMN_ADDR >> 4) & 0xff,\n\t\t\t\tILI9341_COLUMN_ADDR & 0xff},\n\t \n\t.page_addr = {0x00, 0x00, (ILI9341_PAGE_ADDR >> 4) & 0xff,\n\t\t\t\tILI9341_PAGE_ADDR & 0xff},\n\t \n\t.interface = {ILI9341_IF_WE_MODE, 0x00,\n\t\t\tILI9341_IF_DM_RGB | ILI9341_IF_RM_RGB},\n\t \n\t.pixel_format = ILI9341_PIXEL_DPI_16_BITS,\n\t \n\t.gamma_curve = ILI9341_GAMMA_CURVE_1,\n\t.pgamma = {0x0f, 0x29, 0x24, 0x0c, 0x0e,\n\t\t\t0x09, 0x4e, 0x78, 0x3c, 0x09,\n\t\t\t0x13, 0x05, 0x17, 0x11, 0x00},\n\t.ngamma = {0x00, 0x16, 0x1b, 0x04, 0x11,\n\t\t\t0x07, 0x31, 0x33, 0x42, 0x05,\n\t\t\t0x0c, 0x0a, 0x28, 0x2f, 0x0f},\n};\n\nstatic inline struct ili9341 *panel_to_ili9341(struct drm_panel *panel)\n{\n\treturn container_of(panel, struct ili9341, panel);\n}\n\nstatic void ili9341_dpi_init(struct ili9341 *ili)\n{\n\tstruct device *dev = (&ili->panel)->dev;\n\tstruct mipi_dbi *dbi = ili->dbi;\n\tstruct ili9341_config *cfg = (struct ili9341_config *)ili->conf;\n\n\t \n\tmipi_dbi_command_stackbuf(dbi, 0xca, cfg->ca, ILI9341_CA_LEN);\n\tmipi_dbi_command_stackbuf(dbi, ILI9341_POWERB, cfg->power_b,\n\t\t\t\t  ILI9341_POWER_B_LEN);\n\tmipi_dbi_command_stackbuf(dbi, ILI9341_POWER_SEQ, cfg->power_seq,\n\t\t\t\t  ILI9341_POWER_SEQ_LEN);\n\tmipi_dbi_command_stackbuf(dbi, ILI9341_DTCA, cfg->dtca,\n\t\t\t\t  ILI9341_DTCA_LEN);\n\tmipi_dbi_command_stackbuf(dbi, ILI9341_POWERA, cfg->power_a,\n\t\t\t\t  ILI9341_POWER_A_LEN);\n\tmipi_dbi_command(ili->dbi, ILI9341_PRC, cfg->prc);\n\tmipi_dbi_command_stackbuf(dbi, ILI9341_DTCB, cfg->dtcb,\n\t\t\t\t  ILI9341_DTCB_LEN);\n\tmipi_dbi_command_stackbuf(dbi, ILI9341_FRC, cfg->frc, ILI9341_FRC_LEN);\n\tmipi_dbi_command_stackbuf(dbi, ILI9341_DFC, cfg->dfc_1,\n\t\t\t\t  ILI9341_DFC_1_LEN);\n\tmipi_dbi_command(dbi, ILI9341_POWER1, cfg->power_1);\n\tmipi_dbi_command(dbi, ILI9341_POWER2, cfg->power_2);\n\n\t \n\tmipi_dbi_command_stackbuf(dbi, ILI9341_VCOM1, cfg->vcom_1,\n\t\t\t\t  ILI9341_VCOM_1_LEN);\n\tmipi_dbi_command(dbi, ILI9341_VCOM2, cfg->vcom_2);\n\tmipi_dbi_command(dbi, MIPI_DCS_SET_ADDRESS_MODE, cfg->address_mode);\n\n\t \n\tmipi_dbi_command(dbi, ILI9341_3GAMMA_EN, cfg->g3amma_en);\n\tmipi_dbi_command(dbi, ILI9341_RGB_INTERFACE, cfg->rgb_interface);\n\tmipi_dbi_command_stackbuf(dbi, ILI9341_DFC, cfg->dfc_2,\n\t\t\t\t  ILI9341_DFC_2_LEN);\n\n\t \n\tmipi_dbi_command_stackbuf(dbi, MIPI_DCS_SET_COLUMN_ADDRESS,\n\t\t\t\t  cfg->column_addr, ILI9341_COLUMN_ADDR_LEN);\n\n\t \n\tmipi_dbi_command_stackbuf(dbi, MIPI_DCS_SET_PAGE_ADDRESS,\n\t\t\t\t  cfg->page_addr, ILI9341_PAGE_ADDR_LEN);\n\tmipi_dbi_command_stackbuf(dbi, ILI9341_INTERFACE, cfg->interface,\n\t\t\t\t  ILI9341_INTERFACE_LEN);\n\n\t \n\tmipi_dbi_command(dbi, MIPI_DCS_SET_PIXEL_FORMAT, cfg->pixel_format);\n\tmipi_dbi_command(dbi, MIPI_DCS_WRITE_MEMORY_START);\n\tmsleep(200);\n\tmipi_dbi_command(dbi, MIPI_DCS_SET_GAMMA_CURVE, cfg->gamma_curve);\n\tmipi_dbi_command_stackbuf(dbi, ILI9341_PGAMMA, cfg->pgamma,\n\t\t\t\t  ILI9341_PGAMMA_LEN);\n\tmipi_dbi_command_stackbuf(dbi, ILI9341_NGAMMA, cfg->ngamma,\n\t\t\t\t  ILI9341_NGAMMA_LEN);\n\tmipi_dbi_command(dbi, MIPI_DCS_EXIT_SLEEP_MODE);\n\tmsleep(200);\n\tmipi_dbi_command(dbi, MIPI_DCS_SET_DISPLAY_ON);\n\tmipi_dbi_command(dbi, MIPI_DCS_WRITE_MEMORY_START);\n\n\tdev_info(dev, \"Initialized display rgb interface\\n\");\n}\n\nstatic int ili9341_dpi_power_on(struct ili9341 *ili)\n{\n\tstruct device *dev = (&ili->panel)->dev;\n\tint ret = 0;\n\n\t \n\tgpiod_set_value(ili->reset_gpio, 1);\n\n\t \n\tret = regulator_bulk_enable(ARRAY_SIZE(ili->supplies),\n\t\t\t\t    ili->supplies);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"unable to enable vcc\\n\");\n\t\treturn ret;\n\t}\n\tmsleep(20);\n\n\t \n\tgpiod_set_value(ili->reset_gpio, 0);\n\tmsleep(20);\n\n\treturn 0;\n}\n\nstatic int ili9341_dpi_power_off(struct ili9341 *ili)\n{\n\t \n\tgpiod_set_value(ili->reset_gpio, 1);\n\n\t \n\treturn regulator_bulk_disable(ARRAY_SIZE(ili->supplies),\n\t\t\t\t      ili->supplies);\n}\n\nstatic int ili9341_dpi_disable(struct drm_panel *panel)\n{\n\tstruct ili9341 *ili = panel_to_ili9341(panel);\n\n\tmipi_dbi_command(ili->dbi, MIPI_DCS_SET_DISPLAY_OFF);\n\treturn 0;\n}\n\nstatic int ili9341_dpi_unprepare(struct drm_panel *panel)\n{\n\tstruct ili9341 *ili = panel_to_ili9341(panel);\n\n\treturn ili9341_dpi_power_off(ili);\n}\n\nstatic int ili9341_dpi_prepare(struct drm_panel *panel)\n{\n\tstruct ili9341 *ili = panel_to_ili9341(panel);\n\tint ret;\n\n\tret = ili9341_dpi_power_on(ili);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tili9341_dpi_init(ili);\n\n\treturn ret;\n}\n\nstatic int ili9341_dpi_enable(struct drm_panel *panel)\n{\n\tstruct ili9341 *ili = panel_to_ili9341(panel);\n\n\tmipi_dbi_command(ili->dbi, MIPI_DCS_SET_DISPLAY_ON);\n\treturn 0;\n}\n\nstatic int ili9341_dpi_get_modes(struct drm_panel *panel,\n\t\t\t\t struct drm_connector *connector)\n{\n\tstruct ili9341 *ili = panel_to_ili9341(panel);\n\tstruct drm_device *drm = connector->dev;\n\tstruct drm_display_mode *mode;\n\tstruct drm_display_info *info;\n\n\tinfo = &connector->display_info;\n\tinfo->width_mm = ili->conf->mode.width_mm;\n\tinfo->height_mm = ili->conf->mode.height_mm;\n\n\tif (ili->conf->rgb_interface & ILI9341_RGB_DPL)\n\t\tinfo->bus_flags |= DRM_BUS_FLAG_PIXDATA_DRIVE_POSEDGE;\n\telse\n\t\tinfo->bus_flags |= DRM_BUS_FLAG_PIXDATA_DRIVE_NEGEDGE;\n\n\tif (ili->conf->rgb_interface & ILI9341_RGB_EPL)\n\t\tinfo->bus_flags |= DRM_BUS_FLAG_DE_LOW;\n\telse\n\t\tinfo->bus_flags |= DRM_BUS_FLAG_DE_HIGH;\n\n\tmode = drm_mode_duplicate(drm, &ili->conf->mode);\n\tif (!mode) {\n\t\tdrm_err(drm, \"bad mode or failed to add mode\\n\");\n\t\treturn -EINVAL;\n\t}\n\tdrm_mode_set_name(mode);\n\n\t \n\tif (ili->conf->rgb_interface & ILI9341_RGB_HSPL)\n\t\tmode->flags |= DRM_MODE_FLAG_PHSYNC;\n\telse\n\t\tmode->flags |= DRM_MODE_FLAG_NHSYNC;\n\n\tif (ili->conf->rgb_interface & ILI9341_RGB_VSPL)\n\t\tmode->flags |= DRM_MODE_FLAG_PVSYNC;\n\telse\n\t\tmode->flags |= DRM_MODE_FLAG_NVSYNC;\n\n\tdrm_mode_probed_add(connector, mode);\n\n\treturn 1;  \n}\n\nstatic const struct drm_panel_funcs ili9341_dpi_funcs = {\n\t.disable = ili9341_dpi_disable,\n\t.unprepare = ili9341_dpi_unprepare,\n\t.prepare = ili9341_dpi_prepare,\n\t.enable = ili9341_dpi_enable,\n\t.get_modes = ili9341_dpi_get_modes,\n};\n\nstatic void ili9341_dbi_enable(struct drm_simple_display_pipe *pipe,\n\t\t\t       struct drm_crtc_state *crtc_state,\n\t\t\t       struct drm_plane_state *plane_state)\n{\n\tstruct mipi_dbi_dev *dbidev = drm_to_mipi_dbi_dev(pipe->crtc.dev);\n\tstruct mipi_dbi *dbi = &dbidev->dbi;\n\tu8 addr_mode;\n\tint ret, idx;\n\n\tif (!drm_dev_enter(pipe->crtc.dev, &idx))\n\t\treturn;\n\n\tret = mipi_dbi_poweron_conditional_reset(dbidev);\n\tif (ret < 0)\n\t\tgoto out_exit;\n\tif (ret == 1)\n\t\tgoto out_enable;\n\n\tmipi_dbi_command(dbi, MIPI_DCS_SET_DISPLAY_OFF);\n\n\tmipi_dbi_command(dbi, ILI9341_POWERB, 0x00, 0xc1, 0x30);\n\tmipi_dbi_command(dbi, ILI9341_POWER_SEQ, 0x64, 0x03, 0x12, 0x81);\n\tmipi_dbi_command(dbi, ILI9341_DTCA, 0x85, 0x00, 0x78);\n\tmipi_dbi_command(dbi, ILI9341_POWERA, 0x39, 0x2c, 0x00, 0x34, 0x02);\n\tmipi_dbi_command(dbi, ILI9341_PRC, ILI9341_DBI_PRC_NORMAL);\n\tmipi_dbi_command(dbi, ILI9341_DTCB, 0x00, 0x00);\n\n\t \n\tmipi_dbi_command(dbi, ILI9341_POWER1, ILI9341_DBI_VCOMH_4P6V);\n\tmipi_dbi_command(dbi, ILI9341_POWER2, ILI9341_DBI_PWR_2_DEFAULT);\n\t \n\tmipi_dbi_command(dbi, ILI9341_VCOM1, ILI9341_DBI_VCOM_1_VMH_4P25V,\n\t\t\t ILI9341_DBI_VCOM_1_VML_1P5V);\n\tmipi_dbi_command(dbi, ILI9341_VCOM2, ILI9341_DBI_VCOM_2_DEC_58);\n\n\t \n\tmipi_dbi_command(dbi, MIPI_DCS_SET_PIXEL_FORMAT,\n\t\t\t MIPI_DCS_PIXEL_FMT_16BIT);\n\n\t \n\tmipi_dbi_command(dbi, ILI9341_FRC, ILI9341_DBI_FRC_DIVA & 0x03,\n\t\t\t ILI9341_DBI_FRC_RTNA & 0x1f);\n\n\t \n\tmipi_dbi_command(dbi, ILI9341_3GAMMA_EN, 0x00);\n\tmipi_dbi_command(dbi, MIPI_DCS_SET_GAMMA_CURVE, ILI9341_GAMMA_CURVE_1);\n\tmipi_dbi_command(dbi, ILI9341_PGAMMA,\n\t\t\t 0x0f, 0x31, 0x2b, 0x0c, 0x0e, 0x08, 0x4e, 0xf1,\n\t\t\t 0x37, 0x07, 0x10, 0x03, 0x0e, 0x09, 0x00);\n\tmipi_dbi_command(dbi, ILI9341_NGAMMA,\n\t\t\t 0x00, 0x0e, 0x14, 0x03, 0x11, 0x07, 0x31, 0xc1,\n\t\t\t 0x48, 0x08, 0x0f, 0x0c, 0x31, 0x36, 0x0f);\n\n\t \n\tmipi_dbi_command(dbi, ILI9341_ETMOD, ILI9341_DBI_EMS_GAS |\n\t\t\t ILI9341_DBI_EMS_DTS |\n\t\t\t ILI9341_DBI_EMS_GON);\n\n\t \n\tmipi_dbi_command(dbi, ILI9341_DFC, 0x08, 0x82, 0x27, 0x00);\n\tmipi_dbi_command(dbi, MIPI_DCS_EXIT_SLEEP_MODE);\n\tmsleep(100);\n\n\tmipi_dbi_command(dbi, MIPI_DCS_SET_DISPLAY_ON);\n\tmsleep(100);\n\nout_enable:\n\tswitch (dbidev->rotation) {\n\tdefault:\n\t\taddr_mode = ILI9341_MADCTL_MX;\n\t\tbreak;\n\tcase 90:\n\t\taddr_mode = ILI9341_MADCTL_MV;\n\t\tbreak;\n\tcase 180:\n\t\taddr_mode = ILI9341_MADCTL_MY;\n\t\tbreak;\n\tcase 270:\n\t\taddr_mode = ILI9341_MADCTL_MV | ILI9341_MADCTL_MY |\n\t\t\t    ILI9341_MADCTL_MX;\n\t\tbreak;\n\t}\n\n\taddr_mode |= ILI9341_MADCTL_BGR;\n\tmipi_dbi_command(dbi, MIPI_DCS_SET_ADDRESS_MODE, addr_mode);\n\tmipi_dbi_enable_flush(dbidev, crtc_state, plane_state);\n\tdrm_info(&dbidev->drm, \"Initialized display serial interface\\n\");\nout_exit:\n\tdrm_dev_exit(idx);\n}\n\nstatic const struct drm_simple_display_pipe_funcs ili9341_dbi_funcs = {\n\tDRM_MIPI_DBI_SIMPLE_DISPLAY_PIPE_FUNCS(ili9341_dbi_enable),\n};\n\nstatic const struct drm_display_mode ili9341_dbi_mode = {\n\tDRM_SIMPLE_MODE(240, 320, 37, 49),\n};\n\nDEFINE_DRM_GEM_DMA_FOPS(ili9341_dbi_fops);\n\nstatic struct drm_driver ili9341_dbi_driver = {\n\t.driver_features\t= DRIVER_GEM | DRIVER_MODESET | DRIVER_ATOMIC,\n\t.fops\t\t\t= &ili9341_dbi_fops,\n\tDRM_GEM_DMA_DRIVER_OPS_VMAP,\n\t.debugfs_init\t\t= mipi_dbi_debugfs_init,\n\t.name\t\t\t= \"ili9341\",\n\t.desc\t\t\t= \"Ilitek ILI9341\",\n\t.date\t\t\t= \"20210716\",\n\t.major\t\t\t= 1,\n\t.minor\t\t\t= 0,\n};\n\nstatic int ili9341_dbi_probe(struct spi_device *spi, struct gpio_desc *dc,\n\t\t\t     struct gpio_desc *reset)\n{\n\tstruct device *dev = &spi->dev;\n\tstruct mipi_dbi_dev *dbidev;\n\tstruct mipi_dbi *dbi;\n\tstruct drm_device *drm;\n\tstruct regulator *vcc;\n\tu32 rotation = 0;\n\tint ret;\n\n\tvcc = devm_regulator_get_optional(dev, \"vcc\");\n\tif (IS_ERR(vcc)) {\n\t\tdev_err(dev, \"get optional vcc failed\\n\");\n\t\tvcc = NULL;\n\t}\n\n\tdbidev = devm_drm_dev_alloc(dev, &ili9341_dbi_driver,\n\t\t\t\t    struct mipi_dbi_dev, drm);\n\tif (IS_ERR(dbidev))\n\t\treturn PTR_ERR(dbidev);\n\n\tdbi = &dbidev->dbi;\n\tdrm = &dbidev->drm;\n\tdbi->reset = reset;\n\tdbidev->regulator = vcc;\n\n\tdrm_mode_config_init(drm);\n\n\tdbidev->backlight = devm_of_find_backlight(dev);\n\tif (IS_ERR(dbidev->backlight))\n\t\treturn PTR_ERR(dbidev->backlight);\n\n\tdevice_property_read_u32(dev, \"rotation\", &rotation);\n\n\tret = mipi_dbi_spi_init(spi, dbi, dc);\n\tif (ret)\n\t\treturn ret;\n\n\tret = mipi_dbi_dev_init(dbidev, &ili9341_dbi_funcs,\n\t\t\t\t&ili9341_dbi_mode, rotation);\n\tif (ret)\n\t\treturn ret;\n\n\tdrm_mode_config_reset(drm);\n\n\tret = drm_dev_register(drm, 0);\n\tif (ret)\n\t\treturn ret;\n\n\tspi_set_drvdata(spi, drm);\n\n\tdrm_fbdev_generic_setup(drm, 0);\n\n\treturn 0;\n}\n\nstatic int ili9341_dpi_probe(struct spi_device *spi, struct gpio_desc *dc,\n\t\t\t     struct gpio_desc *reset)\n{\n\tstruct device *dev = &spi->dev;\n\tstruct ili9341 *ili;\n\tint ret;\n\n\tili = devm_kzalloc(dev, sizeof(struct ili9341), GFP_KERNEL);\n\tif (!ili)\n\t\treturn -ENOMEM;\n\n\tili->dbi = devm_kzalloc(dev, sizeof(struct mipi_dbi),\n\t\t\t\tGFP_KERNEL);\n\tif (!ili->dbi)\n\t\treturn -ENOMEM;\n\n\tili->supplies[0].supply = \"vci\";\n\tili->supplies[1].supply = \"vddi\";\n\tili->supplies[2].supply = \"vddi-led\";\n\tret = devm_regulator_bulk_get(dev, ARRAY_SIZE(ili->supplies),\n\t\t\t\t      ili->supplies);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"failed to get regulators: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = mipi_dbi_spi_init(spi, ili->dbi, dc);\n\tif (ret)\n\t\treturn ret;\n\n\tspi_set_drvdata(spi, ili);\n\tili->reset_gpio = reset;\n\t \n\tili->conf = of_device_get_match_data(dev);\n\tif (!ili->conf) {\n\t\tdev_err(dev, \"missing device configuration\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tili->max_spi_speed = ili->conf->max_spi_speed;\n\tdrm_panel_init(&ili->panel, dev, &ili9341_dpi_funcs,\n\t\t       DRM_MODE_CONNECTOR_DPI);\n\tdrm_panel_add(&ili->panel);\n\n\treturn 0;\n}\n\nstatic int ili9341_probe(struct spi_device *spi)\n{\n\tstruct device *dev = &spi->dev;\n\tstruct gpio_desc *dc;\n\tstruct gpio_desc *reset;\n\tconst struct spi_device_id *id = spi_get_device_id(spi);\n\n\treset = devm_gpiod_get_optional(dev, \"reset\", GPIOD_OUT_HIGH);\n\tif (IS_ERR(reset))\n\t\tdev_err(dev, \"Failed to get gpio 'reset'\\n\");\n\n\tdc = devm_gpiod_get_optional(dev, \"dc\", GPIOD_OUT_LOW);\n\tif (IS_ERR(dc))\n\t\tdev_err(dev, \"Failed to get gpio 'dc'\\n\");\n\n\tif (!strcmp(id->name, \"sf-tc240t-9370-t\"))\n\t\treturn ili9341_dpi_probe(spi, dc, reset);\n\telse if (!strcmp(id->name, \"yx240qv29\"))\n\t\treturn ili9341_dbi_probe(spi, dc, reset);\n\n\treturn -1;\n}\n\nstatic void ili9341_remove(struct spi_device *spi)\n{\n\tconst struct spi_device_id *id = spi_get_device_id(spi);\n\tstruct ili9341 *ili = spi_get_drvdata(spi);\n\tstruct drm_device *drm = spi_get_drvdata(spi);\n\n\tif (!strcmp(id->name, \"sf-tc240t-9370-t\")) {\n\t\tili9341_dpi_power_off(ili);\n\t\tdrm_panel_remove(&ili->panel);\n\t} else if (!strcmp(id->name, \"yx240qv29\")) {\n\t\tdrm_dev_unplug(drm);\n\t\tdrm_atomic_helper_shutdown(drm);\n\t}\n}\n\nstatic void ili9341_shutdown(struct spi_device *spi)\n{\n\tconst struct spi_device_id *id = spi_get_device_id(spi);\n\n\tif (!strcmp(id->name, \"yx240qv29\"))\n\t\tdrm_atomic_helper_shutdown(spi_get_drvdata(spi));\n}\n\nstatic const struct of_device_id ili9341_of_match[] = {\n\t{\n\t\t.compatible = \"st,sf-tc240t-9370-t\",\n\t\t.data = &ili9341_stm32f429_disco_data,\n\t},\n\t{\n\t\t \n\t\t.compatible = \"adafruit,yx240qv29\",\n\t\t.data = NULL,\n\t},\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, ili9341_of_match);\n\nstatic const struct spi_device_id ili9341_id[] = {\n\t{ \"yx240qv29\", 0 },\n\t{ \"sf-tc240t-9370-t\", 0 },\n\t{ }\n};\nMODULE_DEVICE_TABLE(spi, ili9341_id);\n\nstatic struct spi_driver ili9341_driver = {\n\t.probe = ili9341_probe,\n\t.remove = ili9341_remove,\n\t.shutdown = ili9341_shutdown,\n\t.id_table = ili9341_id,\n\t.driver = {\n\t\t.name = \"panel-ilitek-ili9341\",\n\t\t.of_match_table = ili9341_of_match,\n\t},\n};\nmodule_spi_driver(ili9341_driver);\n\nMODULE_AUTHOR(\"Dillon Min <dillon.minfei@gmail.com>\");\nMODULE_DESCRIPTION(\"ILI9341 LCD panel driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}