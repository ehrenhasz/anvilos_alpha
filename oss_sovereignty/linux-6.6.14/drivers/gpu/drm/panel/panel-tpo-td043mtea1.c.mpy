{
  "module_name": "panel-tpo-td043mtea1.c",
  "hash_id": "77f5bd7120db2efd39916a078b8161c2cfb54e27fbc5ffe1544f1d84441ef552",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/panel/panel-tpo-td043mtea1.c",
  "human_readable_source": "\n \n\n#include <linux/delay.h>\n#include <linux/module.h>\n#include <linux/regulator/consumer.h>\n#include <linux/spi/spi.h>\n\n#include <drm/drm_connector.h>\n#include <drm/drm_modes.h>\n#include <drm/drm_panel.h>\n\n#define TPO_R02_MODE(x)\t\t\t((x) & 7)\n#define TPO_R02_MODE_800x480\t\t7\n#define TPO_R02_NCLK_RISING\t\tBIT(3)\n#define TPO_R02_HSYNC_HIGH\t\tBIT(4)\n#define TPO_R02_VSYNC_HIGH\t\tBIT(5)\n\n#define TPO_R03_NSTANDBY\t\tBIT(0)\n#define TPO_R03_EN_CP_CLK\t\tBIT(1)\n#define TPO_R03_EN_VGL_PUMP\t\tBIT(2)\n#define TPO_R03_EN_PWM\t\t\tBIT(3)\n#define TPO_R03_DRIVING_CAP_100\t\tBIT(4)\n#define TPO_R03_EN_PRE_CHARGE\t\tBIT(6)\n#define TPO_R03_SOFTWARE_CTL\t\tBIT(7)\n\n#define TPO_R04_NFLIP_H\t\t\tBIT(0)\n#define TPO_R04_NFLIP_V\t\t\tBIT(1)\n#define TPO_R04_CP_CLK_FREQ_1H\t\tBIT(2)\n#define TPO_R04_VGL_FREQ_1H\t\tBIT(4)\n\n#define TPO_R03_VAL_NORMAL \\\n\t(TPO_R03_NSTANDBY | TPO_R03_EN_CP_CLK | TPO_R03_EN_VGL_PUMP | \\\n\t TPO_R03_EN_PWM | TPO_R03_DRIVING_CAP_100 | TPO_R03_EN_PRE_CHARGE | \\\n\t TPO_R03_SOFTWARE_CTL)\n\n#define TPO_R03_VAL_STANDBY \\\n\t(TPO_R03_DRIVING_CAP_100 | TPO_R03_EN_PRE_CHARGE | \\\n\t TPO_R03_SOFTWARE_CTL)\n\nstatic const u16 td043mtea1_def_gamma[12] = {\n\t105, 315, 381, 431, 490, 537, 579, 686, 780, 837, 880, 1023\n};\n\nstruct td043mtea1_panel {\n\tstruct drm_panel panel;\n\n\tstruct spi_device *spi;\n\tstruct regulator *vcc_reg;\n\tstruct gpio_desc *reset_gpio;\n\n\tunsigned int mode;\n\tu16 gamma[12];\n\tbool vmirror;\n\tbool powered_on;\n\tbool spi_suspended;\n\tbool power_on_resume;\n};\n\n#define to_td043mtea1_device(p) container_of(p, struct td043mtea1_panel, panel)\n\n \n\nstatic int td043mtea1_write(struct td043mtea1_panel *lcd, u8 addr, u8 value)\n{\n\tstruct spi_message msg;\n\tstruct spi_transfer xfer;\n\tu16 data;\n\tint ret;\n\n\tspi_message_init(&msg);\n\n\tmemset(&xfer, 0, sizeof(xfer));\n\n\tdata = ((u16)addr << 10) | (1 << 8) | value;\n\txfer.tx_buf = &data;\n\txfer.bits_per_word = 16;\n\txfer.len = 2;\n\tspi_message_add_tail(&xfer, &msg);\n\n\tret = spi_sync(lcd->spi, &msg);\n\tif (ret < 0)\n\t\tdev_warn(&lcd->spi->dev, \"failed to write to LCD reg (%d)\\n\",\n\t\t\t ret);\n\n\treturn ret;\n}\n\nstatic void td043mtea1_write_gamma(struct td043mtea1_panel *lcd)\n{\n\tconst u16 *gamma = lcd->gamma;\n\tunsigned int i;\n\tu8 val;\n\n\t \n\tfor (val = i = 0; i < 4; i++)\n\t\tval |= (gamma[i] & 0x300) >> ((i + 1) * 2);\n\ttd043mtea1_write(lcd, 0x11, val);\n\n\tfor (val = i = 0; i < 4; i++)\n\t\tval |= (gamma[i + 4] & 0x300) >> ((i + 1) * 2);\n\ttd043mtea1_write(lcd, 0x12, val);\n\n\tfor (val = i = 0; i < 4; i++)\n\t\tval |= (gamma[i + 8] & 0x300) >> ((i + 1) * 2);\n\ttd043mtea1_write(lcd, 0x13, val);\n\n\t \n\tfor (i = 0; i < 12; i++)\n\t\ttd043mtea1_write(lcd, 0x14 + i, gamma[i] & 0xff);\n}\n\nstatic int td043mtea1_write_mirror(struct td043mtea1_panel *lcd)\n{\n\tu8 reg4 = TPO_R04_NFLIP_H | TPO_R04_NFLIP_V |\n\t\tTPO_R04_CP_CLK_FREQ_1H | TPO_R04_VGL_FREQ_1H;\n\tif (lcd->vmirror)\n\t\treg4 &= ~TPO_R04_NFLIP_V;\n\n\treturn td043mtea1_write(lcd, 4, reg4);\n}\n\nstatic int td043mtea1_power_on(struct td043mtea1_panel *lcd)\n{\n\tint ret;\n\n\tif (lcd->powered_on)\n\t\treturn 0;\n\n\tret = regulator_enable(lcd->vcc_reg);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tmsleep(160);\n\n\tgpiod_set_value(lcd->reset_gpio, 0);\n\n\ttd043mtea1_write(lcd, 2, TPO_R02_MODE(lcd->mode) | TPO_R02_NCLK_RISING);\n\ttd043mtea1_write(lcd, 3, TPO_R03_VAL_NORMAL);\n\ttd043mtea1_write(lcd, 0x20, 0xf0);\n\ttd043mtea1_write(lcd, 0x21, 0xf0);\n\ttd043mtea1_write_mirror(lcd);\n\ttd043mtea1_write_gamma(lcd);\n\n\tlcd->powered_on = true;\n\n\treturn 0;\n}\n\nstatic void td043mtea1_power_off(struct td043mtea1_panel *lcd)\n{\n\tif (!lcd->powered_on)\n\t\treturn;\n\n\ttd043mtea1_write(lcd, 3, TPO_R03_VAL_STANDBY | TPO_R03_EN_PWM);\n\n\tgpiod_set_value(lcd->reset_gpio, 1);\n\n\t \n\tmsleep(50);\n\n\ttd043mtea1_write(lcd, 3, TPO_R03_VAL_STANDBY);\n\n\tregulator_disable(lcd->vcc_reg);\n\n\tlcd->powered_on = false;\n}\n\n \n\nstatic ssize_t vmirror_show(struct device *dev, struct device_attribute *attr,\n\t\t\t    char *buf)\n{\n\tstruct td043mtea1_panel *lcd = dev_get_drvdata(dev);\n\n\treturn sysfs_emit(buf, \"%d\\n\", lcd->vmirror);\n}\n\nstatic ssize_t vmirror_store(struct device *dev, struct device_attribute *attr,\n\t\t\t     const char *buf, size_t count)\n{\n\tstruct td043mtea1_panel *lcd = dev_get_drvdata(dev);\n\tint val;\n\tint ret;\n\n\tret = kstrtoint(buf, 0, &val);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tlcd->vmirror = !!val;\n\n\tret = td043mtea1_write_mirror(lcd);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn count;\n}\n\nstatic ssize_t mode_show(struct device *dev, struct device_attribute *attr,\n\t\t\t char *buf)\n{\n\tstruct td043mtea1_panel *lcd = dev_get_drvdata(dev);\n\n\treturn sysfs_emit(buf, \"%d\\n\", lcd->mode);\n}\n\nstatic ssize_t mode_store(struct device *dev, struct device_attribute *attr,\n\t\t\t  const char *buf, size_t count)\n{\n\tstruct td043mtea1_panel *lcd = dev_get_drvdata(dev);\n\tlong val;\n\tint ret;\n\n\tret = kstrtol(buf, 0, &val);\n\tif (ret != 0 || val & ~7)\n\t\treturn -EINVAL;\n\n\tlcd->mode = val;\n\n\tval |= TPO_R02_NCLK_RISING;\n\ttd043mtea1_write(lcd, 2, val);\n\n\treturn count;\n}\n\nstatic ssize_t gamma_show(struct device *dev, struct device_attribute *attr,\n\t\t\t  char *buf)\n{\n\tstruct td043mtea1_panel *lcd = dev_get_drvdata(dev);\n\tssize_t len = 0;\n\tunsigned int i;\n\tint ret;\n\n\tfor (i = 0; i < ARRAY_SIZE(lcd->gamma); i++) {\n\t\tret = snprintf(buf + len, PAGE_SIZE - len, \"%u \",\n\t\t\t       lcd->gamma[i]);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tlen += ret;\n\t}\n\tbuf[len - 1] = '\\n';\n\n\treturn len;\n}\n\nstatic ssize_t gamma_store(struct device *dev, struct device_attribute *attr,\n\t\t\t   const char *buf, size_t count)\n{\n\tstruct td043mtea1_panel *lcd = dev_get_drvdata(dev);\n\tunsigned int g[12];\n\tunsigned int i;\n\tint ret;\n\n\tret = sscanf(buf, \"%u %u %u %u %u %u %u %u %u %u %u %u\",\n\t\t     &g[0], &g[1], &g[2], &g[3], &g[4], &g[5],\n\t\t     &g[6], &g[7], &g[8], &g[9], &g[10], &g[11]);\n\tif (ret != 12)\n\t\treturn -EINVAL;\n\n\tfor (i = 0; i < 12; i++)\n\t\tlcd->gamma[i] = g[i];\n\n\ttd043mtea1_write_gamma(lcd);\n\n\treturn count;\n}\n\nstatic DEVICE_ATTR_RW(vmirror);\nstatic DEVICE_ATTR_RW(mode);\nstatic DEVICE_ATTR_RW(gamma);\n\nstatic struct attribute *td043mtea1_attrs[] = {\n\t&dev_attr_vmirror.attr,\n\t&dev_attr_mode.attr,\n\t&dev_attr_gamma.attr,\n\tNULL,\n};\n\nstatic const struct attribute_group td043mtea1_attr_group = {\n\t.attrs = td043mtea1_attrs,\n};\n\n \n\nstatic int td043mtea1_unprepare(struct drm_panel *panel)\n{\n\tstruct td043mtea1_panel *lcd = to_td043mtea1_device(panel);\n\n\tif (!lcd->spi_suspended)\n\t\ttd043mtea1_power_off(lcd);\n\n\treturn 0;\n}\n\nstatic int td043mtea1_prepare(struct drm_panel *panel)\n{\n\tstruct td043mtea1_panel *lcd = to_td043mtea1_device(panel);\n\tint ret;\n\n\t \n\tif (lcd->spi_suspended)\n\t\treturn 0;\n\n\tret = td043mtea1_power_on(lcd);\n\tif (ret) {\n\t\tdev_err(&lcd->spi->dev, \"%s: power on failed (%d)\\n\",\n\t\t\t__func__, ret);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic const struct drm_display_mode td043mtea1_mode = {\n\t.clock = 36000,\n\t.hdisplay = 800,\n\t.hsync_start = 800 + 68,\n\t.hsync_end = 800 + 68 + 1,\n\t.htotal = 800 + 68 + 1 + 214,\n\t.vdisplay = 480,\n\t.vsync_start = 480 + 39,\n\t.vsync_end = 480 + 39 + 1,\n\t.vtotal = 480 + 39 + 1 + 34,\n\t.type = DRM_MODE_TYPE_DRIVER | DRM_MODE_TYPE_PREFERRED,\n\t.flags = DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_NVSYNC,\n\t.width_mm = 94,\n\t.height_mm = 56,\n};\n\nstatic int td043mtea1_get_modes(struct drm_panel *panel,\n\t\t\t\tstruct drm_connector *connector)\n{\n\tstruct drm_display_mode *mode;\n\n\tmode = drm_mode_duplicate(connector->dev, &td043mtea1_mode);\n\tif (!mode)\n\t\treturn -ENOMEM;\n\n\tdrm_mode_set_name(mode);\n\tdrm_mode_probed_add(connector, mode);\n\n\tconnector->display_info.width_mm = td043mtea1_mode.width_mm;\n\tconnector->display_info.height_mm = td043mtea1_mode.height_mm;\n\t \n\tconnector->display_info.bus_flags = DRM_BUS_FLAG_DE_HIGH\n\t\t\t\t\t  | DRM_BUS_FLAG_SYNC_SAMPLE_NEGEDGE\n\t\t\t\t\t  | DRM_BUS_FLAG_PIXDATA_SAMPLE_POSEDGE;\n\n\treturn 1;\n}\n\nstatic const struct drm_panel_funcs td043mtea1_funcs = {\n\t.unprepare = td043mtea1_unprepare,\n\t.prepare = td043mtea1_prepare,\n\t.get_modes = td043mtea1_get_modes,\n};\n\n \n\nstatic int __maybe_unused td043mtea1_suspend(struct device *dev)\n{\n\tstruct td043mtea1_panel *lcd = dev_get_drvdata(dev);\n\n\tif (lcd->powered_on) {\n\t\ttd043mtea1_power_off(lcd);\n\t\tlcd->powered_on = true;\n\t}\n\n\tlcd->spi_suspended = true;\n\n\treturn 0;\n}\n\nstatic int __maybe_unused td043mtea1_resume(struct device *dev)\n{\n\tstruct td043mtea1_panel *lcd = dev_get_drvdata(dev);\n\tint ret;\n\n\tlcd->spi_suspended = false;\n\n\tif (lcd->powered_on) {\n\t\tlcd->powered_on = false;\n\t\tret = td043mtea1_power_on(lcd);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic SIMPLE_DEV_PM_OPS(td043mtea1_pm_ops, td043mtea1_suspend,\n\t\t\t td043mtea1_resume);\n\nstatic int td043mtea1_probe(struct spi_device *spi)\n{\n\tstruct td043mtea1_panel *lcd;\n\tint ret;\n\n\tlcd = devm_kzalloc(&spi->dev, sizeof(*lcd), GFP_KERNEL);\n\tif (lcd == NULL)\n\t\treturn -ENOMEM;\n\n\tspi_set_drvdata(spi, lcd);\n\tlcd->spi = spi;\n\tlcd->mode = TPO_R02_MODE_800x480;\n\tmemcpy(lcd->gamma, td043mtea1_def_gamma, sizeof(lcd->gamma));\n\n\tlcd->vcc_reg = devm_regulator_get(&spi->dev, \"vcc\");\n\tif (IS_ERR(lcd->vcc_reg))\n\t\treturn dev_err_probe(&spi->dev, PTR_ERR(lcd->vcc_reg),\n\t\t\t\t     \"failed to get VCC regulator\\n\");\n\n\tlcd->reset_gpio = devm_gpiod_get(&spi->dev, \"reset\", GPIOD_OUT_HIGH);\n\tif (IS_ERR(lcd->reset_gpio))\n\t\treturn dev_err_probe(&spi->dev, PTR_ERR(lcd->reset_gpio),\n\t\t\t\t     \"failed to get reset GPIO\\n\");\n\n\tspi->bits_per_word = 16;\n\tspi->mode = SPI_MODE_0;\n\n\tret = spi_setup(spi);\n\tif (ret < 0) {\n\t\tdev_err(&spi->dev, \"failed to setup SPI: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = sysfs_create_group(&spi->dev.kobj, &td043mtea1_attr_group);\n\tif (ret < 0) {\n\t\tdev_err(&spi->dev, \"failed to create sysfs files\\n\");\n\t\treturn ret;\n\t}\n\n\tdrm_panel_init(&lcd->panel, &lcd->spi->dev, &td043mtea1_funcs,\n\t\t       DRM_MODE_CONNECTOR_DPI);\n\n\tdrm_panel_add(&lcd->panel);\n\n\treturn 0;\n}\n\nstatic void td043mtea1_remove(struct spi_device *spi)\n{\n\tstruct td043mtea1_panel *lcd = spi_get_drvdata(spi);\n\n\tdrm_panel_remove(&lcd->panel);\n\tdrm_panel_disable(&lcd->panel);\n\tdrm_panel_unprepare(&lcd->panel);\n\n\tsysfs_remove_group(&spi->dev.kobj, &td043mtea1_attr_group);\n}\n\nstatic const struct of_device_id td043mtea1_of_match[] = {\n\t{ .compatible = \"tpo,td043mtea1\", },\n\t{   },\n};\n\nMODULE_DEVICE_TABLE(of, td043mtea1_of_match);\n\nstatic const struct spi_device_id td043mtea1_ids[] = {\n\t{ \"td043mtea1\", 0 },\n\t{   }\n};\n\nMODULE_DEVICE_TABLE(spi, td043mtea1_ids);\n\nstatic struct spi_driver td043mtea1_driver = {\n\t.probe\t\t= td043mtea1_probe,\n\t.remove\t\t= td043mtea1_remove,\n\t.id_table\t= td043mtea1_ids,\n\t.driver\t\t= {\n\t\t.name\t= \"panel-tpo-td043mtea1\",\n\t\t.pm\t= &td043mtea1_pm_ops,\n\t\t.of_match_table = td043mtea1_of_match,\n\t},\n};\n\nmodule_spi_driver(td043mtea1_driver);\n\nMODULE_AUTHOR(\"Gra\u017evydas Ignotas <notasas@gmail.com>\");\nMODULE_DESCRIPTION(\"TPO TD043MTEA1 Panel Driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}