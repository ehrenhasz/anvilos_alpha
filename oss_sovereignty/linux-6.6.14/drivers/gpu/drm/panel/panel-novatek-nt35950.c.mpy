{
  "module_name": "panel-novatek-nt35950.c",
  "hash_id": "f4bd11c4a92cc04a273ce65028ec39e618051a007778fae8d1683a52657805c4",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/panel/panel-novatek-nt35950.c",
  "human_readable_source": "\n \n#include <linux/delay.h>\n#include <linux/gpio/consumer.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/of_graph.h>\n#include <linux/regulator/consumer.h>\n\n#include <drm/drm_connector.h>\n#include <drm/drm_crtc.h>\n#include <drm/drm_mipi_dsi.h>\n#include <drm/drm_modes.h>\n#include <drm/drm_panel.h>\n\n#define MCS_CMD_MAUCCTR\t\t\t0xf0  \n#define MCS_PARAM_SCALER_FUNCTION\t0x58  \n#define MCS_PARAM_SCALEUP_MODE\t\t0xc9\n #define MCS_SCALEUP_SIMPLE\t\t0x0\n #define MCS_SCALEUP_BILINEAR\t\tBIT(0)\n #define MCS_SCALEUP_DUPLICATE\t\t(BIT(0) | BIT(4))\n\n \n#define MCS_PARAM_VESA_DSC_ON\t\t0x03\n\n \n#define MCS_PARAM_DATA_COMPRESSION\t0x90\n #define MCS_DATA_COMPRESSION_NONE\t0x00\n #define MCS_DATA_COMPRESSION_FBC\t0x02\n #define MCS_DATA_COMPRESSION_DSC\t0x03\n\n \n#define MCS_PARAM_DISP_OUTPUT_CTRL\t0xb4\n #define MCS_DISP_OUT_SRAM_EN\t\tBIT(0)\n #define MCS_DISP_OUT_VIDEO_MODE\tBIT(4)\n\n \n#define MCS_PARAM_VESA_DSC_SETTING\t0xc0\n\n \n#define MCS_PARAM_SPR_EN\t\t0xe3\n#define MCS_PARAM_SPR_MODE\t\t0xef\n #define MCS_SPR_MODE_YYG_RAINBOW_RGB\t0x01\n\n#define NT35950_VREG_MAX\t\t4\n\nstruct nt35950 {\n\tstruct drm_panel panel;\n\tstruct drm_connector *connector;\n\tstruct mipi_dsi_device *dsi[2];\n\tstruct regulator_bulk_data vregs[NT35950_VREG_MAX];\n\tstruct gpio_desc *reset_gpio;\n\tconst struct nt35950_panel_desc *desc;\n\n\tint cur_mode;\n\tu8 last_page;\n\tbool prepared;\n};\n\nstruct nt35950_panel_mode {\n\tconst struct drm_display_mode mode;\n\n\tbool enable_sram;\n\tbool is_video_mode;\n\tu8 scaler_on;\n\tu8 scaler_mode;\n\tu8 compression;\n\tu8 spr_en;\n\tu8 spr_mode;\n};\n\nstruct nt35950_panel_desc {\n\tconst char *model_name;\n\tconst struct mipi_dsi_device_info dsi_info;\n\tconst struct nt35950_panel_mode *mode_data;\n\n\tbool is_dual_dsi;\n\tu8 num_lanes;\n\tu8 num_modes;\n};\n\nstatic inline struct nt35950 *to_nt35950(struct drm_panel *panel)\n{\n\treturn container_of(panel, struct nt35950, panel);\n}\n\nstatic void nt35950_reset(struct nt35950 *nt)\n{\n\tgpiod_set_value_cansleep(nt->reset_gpio, 1);\n\tusleep_range(12000, 13000);\n\tgpiod_set_value_cansleep(nt->reset_gpio, 0);\n\tusleep_range(300, 400);\n\tgpiod_set_value_cansleep(nt->reset_gpio, 1);\n\tusleep_range(12000, 13000);\n}\n\n \nstatic int nt35950_set_cmd2_page(struct nt35950 *nt, u8 page)\n{\n\tconst u8 mauc_cmd2_page[] = { MCS_CMD_MAUCCTR, 0x55, 0xaa, 0x52,\n\t\t\t\t      0x08, page };\n\tint ret;\n\n\tret = mipi_dsi_dcs_write_buffer(nt->dsi[0], mauc_cmd2_page,\n\t\t\t\t\tARRAY_SIZE(mauc_cmd2_page));\n\tif (ret < 0)\n\t\treturn ret;\n\n\tnt->last_page = page;\n\treturn 0;\n}\n\n \nstatic int nt35950_set_data_compression(struct nt35950 *nt, u8 comp_mode)\n{\n\tu8 cmd_data_compression[] = { MCS_PARAM_DATA_COMPRESSION, comp_mode };\n\tu8 cmd_vesa_dsc_on[] = { MCS_PARAM_VESA_DSC_ON, !!comp_mode };\n\tu8 cmd_vesa_dsc_setting[] = { MCS_PARAM_VESA_DSC_SETTING, 0x03 };\n\tu8 last_page = nt->last_page;\n\tint ret;\n\n\t \n\tif (last_page != 0) {\n\t\tret = nt35950_set_cmd2_page(nt, 0);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\tret = mipi_dsi_dcs_write_buffer(nt->dsi[0], cmd_data_compression,\n\t\t\t\t\tARRAY_SIZE(cmd_data_compression));\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = mipi_dsi_dcs_write_buffer(nt->dsi[0], cmd_vesa_dsc_on,\n\t\t\t\t\tARRAY_SIZE(cmd_vesa_dsc_on));\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tret = nt35950_set_cmd2_page(nt, 4);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tret = mipi_dsi_dcs_write_buffer(nt->dsi[0], cmd_vesa_dsc_setting,\n\t\t\t\t\tARRAY_SIZE(cmd_vesa_dsc_setting));\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\treturn nt35950_set_cmd2_page(nt, last_page);\n}\n\n \nstatic int nt35950_set_scaler(struct nt35950 *nt, u8 scale_up)\n{\n\tu8 cmd_scaler[] = { MCS_PARAM_SCALER_FUNCTION, scale_up };\n\n\treturn mipi_dsi_dcs_write_buffer(nt->dsi[0], cmd_scaler,\n\t\t\t\t\t ARRAY_SIZE(cmd_scaler));\n}\n\n \nstatic int nt35950_set_scale_mode(struct nt35950 *nt, u8 mode)\n{\n\tu8 cmd_scaler[] = { MCS_PARAM_SCALEUP_MODE, mode };\n\n\treturn mipi_dsi_dcs_write_buffer(nt->dsi[0], cmd_scaler,\n\t\t\t\t\t ARRAY_SIZE(cmd_scaler));\n}\n\n \nstatic int nt35950_inject_black_image(struct nt35950 *nt)\n{\n\tconst u8 cmd0_black_img[] = { 0x6f, 0x01 };\n\tconst u8 cmd1_black_img[] = { 0xf3, 0x10 };\n\tu8 cmd_test[] = { 0xff, 0xaa, 0x55, 0xa5, 0x80 };\n\tint ret;\n\n\t \n\tret = mipi_dsi_dcs_write_buffer(nt->dsi[0], cmd_test, ARRAY_SIZE(cmd_test));\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tret = mipi_dsi_dcs_write_buffer(nt->dsi[0], cmd0_black_img,\n\t\t\t\t\tARRAY_SIZE(cmd0_black_img));\n\tif (ret < 0)\n\t\treturn ret;\n\tret = mipi_dsi_dcs_write_buffer(nt->dsi[0], cmd1_black_img,\n\t\t\t\t\tARRAY_SIZE(cmd1_black_img));\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tcmd_test[ARRAY_SIZE(cmd_test) - 1] = 0x00;\n\treturn mipi_dsi_dcs_write_buffer(nt->dsi[0], cmd_test, ARRAY_SIZE(cmd_test));\n}\n\n \nstatic int nt35950_set_dispout(struct nt35950 *nt)\n{\n\tu8 cmd_dispout[] = { MCS_PARAM_DISP_OUTPUT_CTRL, 0x00 };\n\tconst struct nt35950_panel_mode *mode_data = nt->desc->mode_data;\n\n\tif (mode_data[nt->cur_mode].is_video_mode)\n\t\tcmd_dispout[1] |= MCS_DISP_OUT_VIDEO_MODE;\n\tif (mode_data[nt->cur_mode].enable_sram)\n\t\tcmd_dispout[1] |= MCS_DISP_OUT_SRAM_EN;\n\n\treturn mipi_dsi_dcs_write_buffer(nt->dsi[0], cmd_dispout,\n\t\t\t\t\t ARRAY_SIZE(cmd_dispout));\n}\n\nstatic int nt35950_get_current_mode(struct nt35950 *nt)\n{\n\tstruct drm_connector *connector = nt->connector;\n\tstruct drm_crtc_state *crtc_state;\n\tint i;\n\n\t \n\tif (!connector->state || !connector->state->crtc)\n\t\treturn 0;\n\n\tcrtc_state = connector->state->crtc->state;\n\n\tfor (i = 0; i < nt->desc->num_modes; i++) {\n\t\tif (drm_mode_match(&crtc_state->mode,\n\t\t\t\t   &nt->desc->mode_data[i].mode,\n\t\t\t\t   DRM_MODE_MATCH_TIMINGS | DRM_MODE_MATCH_CLOCK))\n\t\t\treturn i;\n\t}\n\n\treturn 0;\n}\n\nstatic int nt35950_on(struct nt35950 *nt)\n{\n\tconst struct nt35950_panel_mode *mode_data = nt->desc->mode_data;\n\tstruct mipi_dsi_device *dsi = nt->dsi[0];\n\tstruct device *dev = &dsi->dev;\n\tint ret;\n\n\tnt->cur_mode = nt35950_get_current_mode(nt);\n\tnt->dsi[0]->mode_flags |= MIPI_DSI_MODE_LPM;\n\tnt->dsi[1]->mode_flags |= MIPI_DSI_MODE_LPM;\n\n\tret = nt35950_set_cmd2_page(nt, 0);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = nt35950_set_data_compression(nt, mode_data[nt->cur_mode].compression);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = nt35950_set_scale_mode(nt, mode_data[nt->cur_mode].scaler_mode);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = nt35950_set_scaler(nt, mode_data[nt->cur_mode].scaler_on);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = nt35950_set_dispout(nt);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = mipi_dsi_dcs_set_tear_on(dsi, MIPI_DSI_DCS_TEAR_MODE_VBLANK);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"Failed to set tear on: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = mipi_dsi_dcs_set_tear_scanline(dsi, 0);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"Failed to set tear scanline: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\t \n\tret = nt35950_set_cmd2_page(nt, 1);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tmipi_dsi_dcs_write_seq(dsi, 0xd4, 0x88, 0x88);\n\n\t \n\tret = nt35950_set_cmd2_page(nt, 7);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tmipi_dsi_dcs_write_seq(dsi, MCS_PARAM_SPR_EN, 0x01);\n\n\t \n\tmipi_dsi_dcs_write_seq(dsi, MCS_PARAM_SPR_MODE, MCS_SPR_MODE_YYG_RAINBOW_RGB);\n\n\t \n\tret = nt35950_inject_black_image(nt);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = mipi_dsi_dcs_exit_sleep_mode(dsi);\n\tif (ret < 0)\n\t\treturn ret;\n\tmsleep(120);\n\n\tret = mipi_dsi_dcs_set_display_on(dsi);\n\tif (ret < 0)\n\t\treturn ret;\n\tmsleep(120);\n\n\tnt->dsi[0]->mode_flags &= ~MIPI_DSI_MODE_LPM;\n\tnt->dsi[1]->mode_flags &= ~MIPI_DSI_MODE_LPM;\n\n\treturn 0;\n}\n\nstatic int nt35950_off(struct nt35950 *nt)\n{\n\tstruct device *dev = &nt->dsi[0]->dev;\n\tint ret;\n\n\tret = mipi_dsi_dcs_set_display_off(nt->dsi[0]);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"Failed to set display off: %d\\n\", ret);\n\t\tgoto set_lpm;\n\t}\n\tusleep_range(10000, 11000);\n\n\tret = mipi_dsi_dcs_enter_sleep_mode(nt->dsi[0]);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"Failed to enter sleep mode: %d\\n\", ret);\n\t\tgoto set_lpm;\n\t}\n\tmsleep(150);\n\nset_lpm:\n\tnt->dsi[0]->mode_flags |= MIPI_DSI_MODE_LPM;\n\tnt->dsi[1]->mode_flags |= MIPI_DSI_MODE_LPM;\n\n\treturn 0;\n}\n\nstatic int nt35950_sharp_init_vregs(struct nt35950 *nt, struct device *dev)\n{\n\tint ret;\n\n\tnt->vregs[0].supply = \"vddio\";\n\tnt->vregs[1].supply = \"avdd\";\n\tnt->vregs[2].supply = \"avee\";\n\tnt->vregs[3].supply = \"dvdd\";\n\tret = devm_regulator_bulk_get(dev, ARRAY_SIZE(nt->vregs),\n\t\t\t\t      nt->vregs);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = regulator_is_supported_voltage(nt->vregs[0].consumer,\n\t\t\t\t\t     1750000, 1950000);\n\tif (!ret)\n\t\treturn -EINVAL;\n\tret = regulator_is_supported_voltage(nt->vregs[1].consumer,\n\t\t\t\t\t     5200000, 5900000);\n\tif (!ret)\n\t\treturn -EINVAL;\n\t \n\tret = regulator_is_supported_voltage(nt->vregs[2].consumer,\n\t\t\t\t\t     5200000, 5900000);\n\tif (!ret)\n\t\treturn -EINVAL;\n\n\tret = regulator_is_supported_voltage(nt->vregs[3].consumer,\n\t\t\t\t\t     1300000, 1400000);\n\tif (!ret)\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nstatic int nt35950_prepare(struct drm_panel *panel)\n{\n\tstruct nt35950 *nt = to_nt35950(panel);\n\tstruct device *dev = &nt->dsi[0]->dev;\n\tint ret;\n\n\tif (nt->prepared)\n\t\treturn 0;\n\n\tret = regulator_enable(nt->vregs[0].consumer);\n\tif (ret)\n\t\treturn ret;\n\tusleep_range(2000, 5000);\n\n\tret = regulator_enable(nt->vregs[3].consumer);\n\tif (ret)\n\t\tgoto end;\n\tusleep_range(15000, 18000);\n\n\tret = regulator_enable(nt->vregs[1].consumer);\n\tif (ret)\n\t\tgoto end;\n\n\tret = regulator_enable(nt->vregs[2].consumer);\n\tif (ret)\n\t\tgoto end;\n\tusleep_range(12000, 13000);\n\n\tnt35950_reset(nt);\n\n\tret = nt35950_on(nt);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"Failed to initialize panel: %d\\n\", ret);\n\t\tgoto end;\n\t}\n\tnt->prepared = true;\n\nend:\n\tif (ret < 0) {\n\t\tregulator_bulk_disable(ARRAY_SIZE(nt->vregs), nt->vregs);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int nt35950_unprepare(struct drm_panel *panel)\n{\n\tstruct nt35950 *nt = to_nt35950(panel);\n\tstruct device *dev = &nt->dsi[0]->dev;\n\tint ret;\n\n\tif (!nt->prepared)\n\t\treturn 0;\n\n\tret = nt35950_off(nt);\n\tif (ret < 0)\n\t\tdev_err(dev, \"Failed to deinitialize panel: %d\\n\", ret);\n\n\tgpiod_set_value_cansleep(nt->reset_gpio, 0);\n\tregulator_bulk_disable(ARRAY_SIZE(nt->vregs), nt->vregs);\n\n\tnt->prepared = false;\n\treturn 0;\n}\n\nstatic int nt35950_get_modes(struct drm_panel *panel,\n\t\t\t     struct drm_connector *connector)\n{\n\tstruct nt35950 *nt = to_nt35950(panel);\n\tint i;\n\n\tfor (i = 0; i < nt->desc->num_modes; i++) {\n\t\tstruct drm_display_mode *mode;\n\n\t\tmode = drm_mode_duplicate(connector->dev,\n\t\t\t\t\t  &nt->desc->mode_data[i].mode);\n\t\tif (!mode)\n\t\t\treturn -ENOMEM;\n\n\t\tdrm_mode_set_name(mode);\n\n\t\tmode->type |= DRM_MODE_TYPE_DRIVER;\n\t\tif (nt->desc->num_modes == 1)\n\t\t\tmode->type |= DRM_MODE_TYPE_PREFERRED;\n\n\t\tdrm_mode_probed_add(connector, mode);\n\t}\n\n\tconnector->display_info.bpc = 8;\n\tconnector->display_info.height_mm = nt->desc->mode_data[0].mode.height_mm;\n\tconnector->display_info.width_mm = nt->desc->mode_data[0].mode.width_mm;\n\tnt->connector = connector;\n\n\treturn nt->desc->num_modes;\n}\n\nstatic const struct drm_panel_funcs nt35950_panel_funcs = {\n\t.prepare = nt35950_prepare,\n\t.unprepare = nt35950_unprepare,\n\t.get_modes = nt35950_get_modes,\n};\n\nstatic int nt35950_probe(struct mipi_dsi_device *dsi)\n{\n\tstruct device *dev = &dsi->dev;\n\tstruct device_node *dsi_r;\n\tstruct mipi_dsi_host *dsi_r_host;\n\tstruct nt35950 *nt;\n\tconst struct mipi_dsi_device_info *info;\n\tint i, num_dsis = 1, ret;\n\n\tnt = devm_kzalloc(dev, sizeof(*nt), GFP_KERNEL);\n\tif (!nt)\n\t\treturn -ENOMEM;\n\n\tret = nt35950_sharp_init_vregs(nt, dev);\n\tif (ret)\n\t\treturn dev_err_probe(dev, ret, \"Regulator init failure.\\n\");\n\n\tnt->desc = of_device_get_match_data(dev);\n\tif (!nt->desc)\n\t\treturn -ENODEV;\n\n\tnt->reset_gpio = devm_gpiod_get(dev, \"reset\", GPIOD_ASIS);\n\tif (IS_ERR(nt->reset_gpio)) {\n\t\treturn dev_err_probe(dev, PTR_ERR(nt->reset_gpio),\n\t\t\t\t     \"Failed to get reset gpio\\n\");\n\t}\n\n\t \n\tif (nt->desc->is_dual_dsi) {\n\t\tinfo = &nt->desc->dsi_info;\n\t\tdsi_r = of_graph_get_remote_node(dsi->dev.of_node, 1, -1);\n\t\tif (!dsi_r) {\n\t\t\tdev_err(dev, \"Cannot get secondary DSI node.\\n\");\n\t\t\treturn -ENODEV;\n\t\t}\n\t\tdsi_r_host = of_find_mipi_dsi_host_by_node(dsi_r);\n\t\tof_node_put(dsi_r);\n\t\tif (!dsi_r_host) {\n\t\t\tdev_err(dev, \"Cannot get secondary DSI host\\n\");\n\t\t\treturn -EPROBE_DEFER;\n\t\t}\n\n\t\tnt->dsi[1] = mipi_dsi_device_register_full(dsi_r_host, info);\n\t\tif (!nt->dsi[1]) {\n\t\t\tdev_err(dev, \"Cannot get secondary DSI node\\n\");\n\t\t\treturn -ENODEV;\n\t\t}\n\t\tnum_dsis++;\n\t}\n\n\tnt->dsi[0] = dsi;\n\tmipi_dsi_set_drvdata(dsi, nt);\n\n\tdrm_panel_init(&nt->panel, dev, &nt35950_panel_funcs,\n\t\t       DRM_MODE_CONNECTOR_DSI);\n\n\tret = drm_panel_of_backlight(&nt->panel);\n\tif (ret) {\n\t\tif (num_dsis == 2)\n\t\t\tmipi_dsi_device_unregister(nt->dsi[1]);\n\n\t\treturn dev_err_probe(dev, ret, \"Failed to get backlight\\n\");\n\t}\n\n\tdrm_panel_add(&nt->panel);\n\n\tfor (i = 0; i < num_dsis; i++) {\n\t\tnt->dsi[i]->lanes = nt->desc->num_lanes;\n\t\tnt->dsi[i]->format = MIPI_DSI_FMT_RGB888;\n\n\t\tnt->dsi[i]->mode_flags = MIPI_DSI_CLOCK_NON_CONTINUOUS |\n\t\t\t\t\t MIPI_DSI_MODE_LPM;\n\n\t\tif (nt->desc->mode_data[0].is_video_mode)\n\t\t\tnt->dsi[i]->mode_flags |= MIPI_DSI_MODE_VIDEO;\n\n\t\tret = mipi_dsi_attach(nt->dsi[i]);\n\t\tif (ret < 0) {\n\t\t\t \n\t\t\tif (num_dsis == 2)\n\t\t\t\tmipi_dsi_device_unregister(nt->dsi[1]);\n\n\t\t\treturn dev_err_probe(dev, ret,\n\t\t\t\t\t     \"Cannot attach to DSI%d host.\\n\", i);\n\t\t}\n\t}\n\n\t \n\tgpiod_set_value_cansleep(nt->reset_gpio, 0);\n\treturn 0;\n}\n\nstatic void nt35950_remove(struct mipi_dsi_device *dsi)\n{\n\tstruct nt35950 *nt = mipi_dsi_get_drvdata(dsi);\n\tint ret;\n\n\tret = mipi_dsi_detach(nt->dsi[0]);\n\tif (ret < 0)\n\t\tdev_err(&dsi->dev,\n\t\t\t\"Failed to detach from DSI0 host: %d\\n\", ret);\n\n\tif (nt->dsi[1]) {\n\t\tret = mipi_dsi_detach(nt->dsi[1]);\n\t\tif (ret < 0)\n\t\t\tdev_err(&dsi->dev,\n\t\t\t\t\"Failed to detach from DSI1 host: %d\\n\", ret);\n\t\tmipi_dsi_device_unregister(nt->dsi[1]);\n\t}\n\n\tdrm_panel_remove(&nt->panel);\n}\n\nstatic const struct nt35950_panel_mode sharp_ls055d1sx04_modes[] = {\n\t{\n\t\t \n\t\t.mode = {\n\t\t\t.clock = 214537,\n\t\t\t.hdisplay = 1080,\n\t\t\t.hsync_start = 1080 + 400,\n\t\t\t.hsync_end = 1080 + 400 + 40,\n\t\t\t.htotal = 1080 + 400 + 40 + 300,\n\t\t\t.vdisplay = 1920,\n\t\t\t.vsync_start = 1920 + 12,\n\t\t\t.vsync_end = 1920 + 12 + 2,\n\t\t\t.vtotal = 1920 + 12 + 2 + 10,\n\t\t\t.width_mm = 68,\n\t\t\t.height_mm = 121,\n\t\t},\n\t\t.compression = MCS_DATA_COMPRESSION_NONE,\n\t\t.enable_sram = true,\n\t\t.is_video_mode = false,\n\t\t.scaler_on = 1,\n\t\t.scaler_mode = MCS_SCALEUP_DUPLICATE,\n\t},\n\t \n};\n\nstatic const struct nt35950_panel_desc sharp_ls055d1sx04 = {\n\t.model_name = \"Sharp LS055D1SX04\",\n\t.dsi_info = {\n\t\t.type = \"LS055D1SX04\",\n\t\t.channel = 0,\n\t\t.node = NULL,\n\t},\n\t.mode_data = sharp_ls055d1sx04_modes,\n\t.num_modes = ARRAY_SIZE(sharp_ls055d1sx04_modes),\n\t.is_dual_dsi = true,\n\t.num_lanes = 4,\n};\n\nstatic const struct of_device_id nt35950_of_match[] = {\n\t{ .compatible = \"sharp,ls055d1sx04\", .data = &sharp_ls055d1sx04 },\n\t{  }\n};\nMODULE_DEVICE_TABLE(of, nt35950_of_match);\n\nstatic struct mipi_dsi_driver nt35950_driver = {\n\t.probe = nt35950_probe,\n\t.remove = nt35950_remove,\n\t.driver = {\n\t\t.name = \"panel-novatek-nt35950\",\n\t\t.of_match_table = nt35950_of_match,\n\t},\n};\nmodule_mipi_dsi_driver(nt35950_driver);\n\nMODULE_AUTHOR(\"AngeloGioacchino Del Regno <angelogioacchino.delregno@somainline.org>\");\nMODULE_DESCRIPTION(\"Novatek NT35950 DriverIC panels driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}