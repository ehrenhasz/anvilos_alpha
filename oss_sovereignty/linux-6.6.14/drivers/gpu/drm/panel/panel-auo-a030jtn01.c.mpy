{
  "module_name": "panel-auo-a030jtn01.c",
  "hash_id": "0b53621c4dfeea57dbac5d2a0f22fae1091c37bf7d61a846983d8b9a569d055e",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/panel/panel-auo-a030jtn01.c",
  "human_readable_source": "\n \n\n#include <linux/bitfield.h>\n#include <linux/delay.h>\n#include <linux/device.h>\n#include <linux/gpio/consumer.h>\n#include <linux/media-bus-format.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include <linux/regmap.h>\n#include <linux/regulator/consumer.h>\n#include <linux/spi/spi.h>\n\n#include <drm/drm_modes.h>\n#include <drm/drm_panel.h>\n\n#define REG05\t\t\t0x05\n#define REG06\t\t\t0x06\n#define REG07\t\t\t0x07\n\n#define REG05_STDBY\t\tBIT(0)\n#define REG06_VBLK\t\tGENMASK(4, 0)\n#define REG07_HBLK\t\tGENMASK(7, 0)\n\n\nstruct a030jtn01_info {\n\tconst struct drm_display_mode *display_modes;\n\tunsigned int num_modes;\n\tu16 width_mm, height_mm;\n\tu32 bus_format, bus_flags;\n};\n\nstruct a030jtn01 {\n\tstruct drm_panel panel;\n\tstruct spi_device *spi;\n\tstruct regmap *map;\n\n\tconst struct a030jtn01_info *panel_info;\n\n\tstruct regulator *supply;\n\tstruct gpio_desc *reset_gpio;\n};\n\nstatic inline struct a030jtn01 *to_a030jtn01(struct drm_panel *panel)\n{\n\treturn container_of(panel, struct a030jtn01, panel);\n}\n\nstatic int a030jtn01_prepare(struct drm_panel *panel)\n{\n\tstruct a030jtn01 *priv = to_a030jtn01(panel);\n\tstruct device *dev = &priv->spi->dev;\n\tunsigned int dummy;\n\tint err;\n\n\terr = regulator_enable(priv->supply);\n\tif (err) {\n\t\tdev_err(dev, \"Failed to enable power supply: %d\\n\", err);\n\t\treturn err;\n\t}\n\n\tusleep_range(1000, 8000);\n\n\t \n\tgpiod_set_value_cansleep(priv->reset_gpio, 1);\n\tusleep_range(100, 8000);\n\tgpiod_set_value_cansleep(priv->reset_gpio, 0);\n\tusleep_range(2000, 8000);\n\n\t \n\terr = regmap_read(priv->map, REG05, &dummy);\n\tif (err)\n\t\tgoto err_disable_regulator;\n\n\t \n\terr = regmap_write(priv->map, REG06, FIELD_PREP(REG06_VBLK, 0x1e));\n\tif (err)\n\t\tgoto err_disable_regulator;\n\n\t \n\terr = regmap_write(priv->map, REG07, FIELD_PREP(REG07_HBLK, 0xd8));\n\tif (err)\n\t\tgoto err_disable_regulator;\n\n\treturn 0;\n\nerr_disable_regulator:\n\tgpiod_set_value_cansleep(priv->reset_gpio, 1);\n\tregulator_disable(priv->supply);\n\treturn err;\n}\n\nstatic int a030jtn01_unprepare(struct drm_panel *panel)\n{\n\tstruct a030jtn01 *priv = to_a030jtn01(panel);\n\n\tgpiod_set_value_cansleep(priv->reset_gpio, 1);\n\tregulator_disable(priv->supply);\n\n\treturn 0;\n}\n\nstatic int a030jtn01_enable(struct drm_panel *panel)\n{\n\tstruct a030jtn01 *priv = to_a030jtn01(panel);\n\tint ret;\n\n\tret = regmap_set_bits(priv->map, REG05, REG05_STDBY);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tif (panel->backlight)\n\t\tmsleep(100);\n\n\treturn 0;\n}\n\nstatic int a030jtn01_disable(struct drm_panel *panel)\n{\n\tstruct a030jtn01 *priv = to_a030jtn01(panel);\n\n\treturn regmap_clear_bits(priv->map, REG05, REG05_STDBY);\n}\n\nstatic int a030jtn01_get_modes(struct drm_panel *panel,\n\t\t\t\tstruct drm_connector *connector)\n{\n\tstruct a030jtn01 *priv = to_a030jtn01(panel);\n\tconst struct a030jtn01_info *panel_info = priv->panel_info;\n\tstruct drm_display_mode *mode;\n\tunsigned int i;\n\n\tfor (i = 0; i < panel_info->num_modes; i++) {\n\t\tmode = drm_mode_duplicate(connector->dev,\n\t\t\t\t\t  &panel_info->display_modes[i]);\n\t\tif (!mode)\n\t\t\treturn -ENOMEM;\n\n\t\tdrm_mode_set_name(mode);\n\n\t\tmode->type = DRM_MODE_TYPE_DRIVER;\n\t\tif (panel_info->num_modes == 1)\n\t\t\tmode->type |= DRM_MODE_TYPE_PREFERRED;\n\n\t\tdrm_mode_probed_add(connector, mode);\n\t}\n\n\tconnector->display_info.bpc = 8;\n\tconnector->display_info.width_mm = panel_info->width_mm;\n\tconnector->display_info.height_mm = panel_info->height_mm;\n\n\tdrm_display_info_set_bus_formats(&connector->display_info,\n\t\t\t\t\t &panel_info->bus_format, 1);\n\tconnector->display_info.bus_flags = panel_info->bus_flags;\n\n\treturn panel_info->num_modes;\n}\n\nstatic const struct drm_panel_funcs a030jtn01_funcs = {\n\t.prepare\t= a030jtn01_prepare,\n\t.unprepare\t= a030jtn01_unprepare,\n\t.enable\t\t= a030jtn01_enable,\n\t.disable\t= a030jtn01_disable,\n\t.get_modes\t= a030jtn01_get_modes,\n};\n\nstatic bool a030jtn01_has_reg(struct device *dev, unsigned int reg)\n{\n\tstatic const u32 a030jtn01_regs_mask = 0x001823f1fb;\n\n\treturn a030jtn01_regs_mask & BIT(reg);\n};\n\nstatic const struct regmap_config a030jtn01_regmap_config = {\n\t.reg_bits = 8,\n\t.val_bits = 8,\n\t.read_flag_mask = 0x40,\n\t.max_register = 0x1c,\n\t.readable_reg = a030jtn01_has_reg,\n\t.writeable_reg = a030jtn01_has_reg,\n};\n\nstatic int a030jtn01_probe(struct spi_device *spi)\n{\n\tstruct device *dev = &spi->dev;\n\tstruct a030jtn01 *priv;\n\tint err;\n\n\tspi->mode |= SPI_MODE_3 | SPI_3WIRE;\n\n\tpriv = devm_kzalloc(dev, sizeof(*priv), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\n\tpriv->spi = spi;\n\tspi_set_drvdata(spi, priv);\n\n\tpriv->map = devm_regmap_init_spi(spi, &a030jtn01_regmap_config);\n\tif (IS_ERR(priv->map))\n\t\treturn dev_err_probe(dev, PTR_ERR(priv->map), \"Unable to init regmap\");\n\n\tpriv->panel_info = spi_get_device_match_data(spi);\n\tif (!priv->panel_info)\n\t\treturn -EINVAL;\n\n\tpriv->supply = devm_regulator_get(dev, \"power\");\n\tif (IS_ERR(priv->supply))\n\t\treturn dev_err_probe(dev, PTR_ERR(priv->supply), \"Failed to get power supply\");\n\n\tpriv->reset_gpio = devm_gpiod_get(dev, \"reset\", GPIOD_OUT_HIGH);\n\tif (IS_ERR(priv->reset_gpio))\n\t\treturn dev_err_probe(dev, PTR_ERR(priv->reset_gpio), \"Failed to get reset GPIO\");\n\n\tdrm_panel_init(&priv->panel, dev, &a030jtn01_funcs,\n\t\t       DRM_MODE_CONNECTOR_DPI);\n\n\terr = drm_panel_of_backlight(&priv->panel);\n\tif (err)\n\t\treturn err;\n\n\tdrm_panel_add(&priv->panel);\n\n\treturn 0;\n}\n\nstatic void a030jtn01_remove(struct spi_device *spi)\n{\n\tstruct a030jtn01 *priv = spi_get_drvdata(spi);\n\n\tdrm_panel_remove(&priv->panel);\n\tdrm_panel_disable(&priv->panel);\n\tdrm_panel_unprepare(&priv->panel);\n}\n\nstatic const struct drm_display_mode a030jtn01_modes[] = {\n\t{  \n\t\t.clock = 14400,\n\t\t.hdisplay = 320,\n\t\t.hsync_start = 320 + 8,\n\t\t.hsync_end = 320 + 8 + 42,\n\t\t.htotal = 320 + 8 + 42 + 30,\n\t\t.vdisplay = 480,\n\t\t.vsync_start = 480 + 90,\n\t\t.vsync_end = 480 + 90 + 24,\n\t\t.vtotal = 480 + 90 + 24 + 6,\n\t\t.flags = DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_NVSYNC,\n\t},\n\t{  \n\t\t.clock = 12000,\n\t\t.hdisplay = 320,\n\t\t.hsync_start = 320 + 8,\n\t\t.hsync_end = 320 + 8 + 42,\n\t\t.htotal = 320 + 8 + 42 + 30,\n\t\t.vdisplay = 480,\n\t\t.vsync_start = 480 + 90,\n\t\t.vsync_end = 480 + 90 + 24,\n\t\t.vtotal = 480 + 90 + 24 + 6,\n\t\t.flags = DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_NVSYNC,\n\t},\n};\n\nstatic const struct a030jtn01_info a030jtn01_info = {\n\t.display_modes = a030jtn01_modes,\n\t.num_modes = ARRAY_SIZE(a030jtn01_modes),\n\t.width_mm = 70,\n\t.height_mm = 51,\n\t.bus_format = MEDIA_BUS_FMT_RGB888_3X8_DELTA,\n\t.bus_flags = DRM_BUS_FLAG_PIXDATA_DRIVE_NEGEDGE,\n};\n\nstatic const struct spi_device_id a030jtn01_id[] = {\n\t{ \"a030jtn01\", (kernel_ulong_t) &a030jtn01_info },\n\t{   }\n};\nMODULE_DEVICE_TABLE(spi, a030jtn01_id);\n\nstatic const struct of_device_id a030jtn01_of_match[] = {\n\t{ .compatible = \"auo,a030jtn01\" },\n\t{   }\n};\nMODULE_DEVICE_TABLE(of, a030jtn01_of_match);\n\nstatic struct spi_driver a030jtn01_driver = {\n\t.driver = {\n\t\t.name = \"auo-a030jtn01\",\n\t\t.of_match_table = a030jtn01_of_match,\n\t},\n\t.id_table = a030jtn01_id,\n\t.probe = a030jtn01_probe,\n\t.remove = a030jtn01_remove,\n};\nmodule_spi_driver(a030jtn01_driver);\n\nMODULE_AUTHOR(\"Paul Cercueil <paul@crapouillou.net>\");\nMODULE_AUTHOR(\"Christophe Branchereau <cbranchereau@gmail.com>\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}