{
  "module_name": "panel-olimex-lcd-olinuxino.c",
  "hash_id": "1e2501741b9df74d9c9412cb75e0e91603f1b089881fb1e0773cc7e303037007",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/panel/panel-olimex-lcd-olinuxino.c",
  "human_readable_source": "\n \n\n#include <linux/crc32.h>\n#include <linux/gpio/consumer.h>\n#include <linux/i2c.h>\n#include <linux/module.h>\n#include <linux/mutex.h>\n#include <linux/of.h>\n#include <linux/regulator/consumer.h>\n\n#include <video/videomode.h>\n#include <video/display_timing.h>\n\n#include <drm/drm_device.h>\n#include <drm/drm_modes.h>\n#include <drm/drm_panel.h>\n\n#define LCD_OLINUXINO_HEADER_MAGIC\t0x4F4CB727\n#define LCD_OLINUXINO_DATA_LEN\t\t256\n\nstruct lcd_olinuxino_mode {\n\tu32 pixelclock;\n\tu32 hactive;\n\tu32 hfp;\n\tu32 hbp;\n\tu32 hpw;\n\tu32 vactive;\n\tu32 vfp;\n\tu32 vbp;\n\tu32 vpw;\n\tu32 refresh;\n\tu32 flags;\n};\n\nstruct lcd_olinuxino_info {\n\tchar name[32];\n\tu32 width_mm;\n\tu32 height_mm;\n\tu32 bpc;\n\tu32 bus_format;\n\tu32 bus_flag;\n} __attribute__((__packed__));\n\nstruct lcd_olinuxino_eeprom {\n\tu32 header;\n\tu32 id;\n\tchar revision[4];\n\tu32 serial;\n\tstruct lcd_olinuxino_info info;\n\tu32 num_modes;\n\tu8 reserved[180];\n\tu32 checksum;\n} __attribute__((__packed__));\n\nstruct lcd_olinuxino {\n\tstruct drm_panel panel;\n\tstruct device *dev;\n\tstruct i2c_client *client;\n\tstruct mutex mutex;\n\n\tbool prepared;\n\tbool enabled;\n\n\tstruct regulator *supply;\n\tstruct gpio_desc *enable_gpio;\n\n\tstruct lcd_olinuxino_eeprom eeprom;\n};\n\nstatic inline struct lcd_olinuxino *to_lcd_olinuxino(struct drm_panel *panel)\n{\n\treturn container_of(panel, struct lcd_olinuxino, panel);\n}\n\nstatic int lcd_olinuxino_disable(struct drm_panel *panel)\n{\n\tstruct lcd_olinuxino *lcd = to_lcd_olinuxino(panel);\n\n\tif (!lcd->enabled)\n\t\treturn 0;\n\n\tlcd->enabled = false;\n\n\treturn 0;\n}\n\nstatic int lcd_olinuxino_unprepare(struct drm_panel *panel)\n{\n\tstruct lcd_olinuxino *lcd = to_lcd_olinuxino(panel);\n\n\tif (!lcd->prepared)\n\t\treturn 0;\n\n\tgpiod_set_value_cansleep(lcd->enable_gpio, 0);\n\tregulator_disable(lcd->supply);\n\n\tlcd->prepared = false;\n\n\treturn 0;\n}\n\nstatic int lcd_olinuxino_prepare(struct drm_panel *panel)\n{\n\tstruct lcd_olinuxino *lcd = to_lcd_olinuxino(panel);\n\tint ret;\n\n\tif (lcd->prepared)\n\t\treturn 0;\n\n\tret = regulator_enable(lcd->supply);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tgpiod_set_value_cansleep(lcd->enable_gpio, 1);\n\tlcd->prepared = true;\n\n\treturn 0;\n}\n\nstatic int lcd_olinuxino_enable(struct drm_panel *panel)\n{\n\tstruct lcd_olinuxino *lcd = to_lcd_olinuxino(panel);\n\n\tif (lcd->enabled)\n\t\treturn 0;\n\n\tlcd->enabled = true;\n\n\treturn 0;\n}\n\nstatic int lcd_olinuxino_get_modes(struct drm_panel *panel,\n\t\t\t\t   struct drm_connector *connector)\n{\n\tstruct lcd_olinuxino *lcd = to_lcd_olinuxino(panel);\n\tstruct lcd_olinuxino_info *lcd_info = &lcd->eeprom.info;\n\tstruct lcd_olinuxino_mode *lcd_mode;\n\tstruct drm_display_mode *mode;\n\tu32 i, num = 0;\n\n\tfor (i = 0; i < lcd->eeprom.num_modes; i++) {\n\t\tlcd_mode = (struct lcd_olinuxino_mode *)\n\t\t\t   &lcd->eeprom.reserved[i * sizeof(*lcd_mode)];\n\n\t\tmode = drm_mode_create(connector->dev);\n\t\tif (!mode) {\n\t\t\tdev_err(panel->dev, \"failed to add mode %ux%u@%u\\n\",\n\t\t\t\tlcd_mode->hactive,\n\t\t\t\tlcd_mode->vactive,\n\t\t\t\tlcd_mode->refresh);\n\t\t\tcontinue;\n\t\t}\n\n\t\tmode->clock = lcd_mode->pixelclock;\n\t\tmode->hdisplay = lcd_mode->hactive;\n\t\tmode->hsync_start = lcd_mode->hactive + lcd_mode->hfp;\n\t\tmode->hsync_end = lcd_mode->hactive + lcd_mode->hfp +\n\t\t\t\t  lcd_mode->hpw;\n\t\tmode->htotal = lcd_mode->hactive + lcd_mode->hfp +\n\t\t\t       lcd_mode->hpw + lcd_mode->hbp;\n\t\tmode->vdisplay = lcd_mode->vactive;\n\t\tmode->vsync_start = lcd_mode->vactive + lcd_mode->vfp;\n\t\tmode->vsync_end = lcd_mode->vactive + lcd_mode->vfp +\n\t\t\t\t  lcd_mode->vpw;\n\t\tmode->vtotal = lcd_mode->vactive + lcd_mode->vfp +\n\t\t\t       lcd_mode->vpw + lcd_mode->vbp;\n\n\t\t \n\t\tif (i == 0)\n\t\t\tmode->type |= DRM_MODE_TYPE_PREFERRED;\n\t\tmode->type |= DRM_MODE_TYPE_DRIVER;\n\n\t\tdrm_mode_set_name(mode);\n\t\tdrm_mode_probed_add(connector, mode);\n\n\t\tnum++;\n\t}\n\n\tconnector->display_info.width_mm = lcd_info->width_mm;\n\tconnector->display_info.height_mm = lcd_info->height_mm;\n\tconnector->display_info.bpc = lcd_info->bpc;\n\n\tif (lcd_info->bus_format)\n\t\tdrm_display_info_set_bus_formats(&connector->display_info,\n\t\t\t\t\t\t &lcd_info->bus_format, 1);\n\tconnector->display_info.bus_flags = lcd_info->bus_flag;\n\n\treturn num;\n}\n\nstatic const struct drm_panel_funcs lcd_olinuxino_funcs = {\n\t.disable = lcd_olinuxino_disable,\n\t.unprepare = lcd_olinuxino_unprepare,\n\t.prepare = lcd_olinuxino_prepare,\n\t.enable = lcd_olinuxino_enable,\n\t.get_modes = lcd_olinuxino_get_modes,\n};\n\nstatic int lcd_olinuxino_probe(struct i2c_client *client)\n{\n\tstruct device *dev = &client->dev;\n\tstruct lcd_olinuxino *lcd;\n\tu32 checksum, i;\n\tint ret = 0;\n\n\tif (!i2c_check_functionality(client->adapter, I2C_FUNC_I2C |\n\t\t\t\t     I2C_FUNC_SMBUS_READ_I2C_BLOCK))\n\t\treturn -ENODEV;\n\n\tlcd = devm_kzalloc(dev, sizeof(*lcd), GFP_KERNEL);\n\tif (!lcd)\n\t\treturn -ENOMEM;\n\n\ti2c_set_clientdata(client, lcd);\n\tlcd->dev = dev;\n\tlcd->client = client;\n\n\tmutex_init(&lcd->mutex);\n\n\t \n\tfor (i = 0; i < LCD_OLINUXINO_DATA_LEN; i += I2C_SMBUS_BLOCK_MAX) {\n\t\tmutex_lock(&lcd->mutex);\n\t\tret = i2c_smbus_read_i2c_block_data(client,\n\t\t\t\t\t\t    i,\n\t\t\t\t\t\t    I2C_SMBUS_BLOCK_MAX,\n\t\t\t\t\t\t    (u8 *)&lcd->eeprom + i);\n\t\tmutex_unlock(&lcd->mutex);\n\t\tif (ret < 0) {\n\t\t\tdev_err(dev, \"error reading from device at %02x\\n\", i);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\t \n\tchecksum = ~crc32(~0, (u8 *)&lcd->eeprom, 252);\n\tif (checksum != lcd->eeprom.checksum) {\n\t\tdev_err(dev, \"configuration checksum does not match!\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (lcd->eeprom.header != LCD_OLINUXINO_HEADER_MAGIC) {\n\t\tdev_err(dev, \"magic header does not match\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tdev_info(dev, \"Detected %s, Rev. %s, Serial: %08x\\n\",\n\t\t lcd->eeprom.info.name,\n\t\t lcd->eeprom.revision,\n\t\t lcd->eeprom.serial);\n\n\t \n\tif (lcd->eeprom.num_modes > 4) {\n\t\tdev_warn(dev, \"invalid number of modes, falling back to 4\\n\");\n\t\tlcd->eeprom.num_modes = 4;\n\t}\n\n\tlcd->enabled = false;\n\tlcd->prepared = false;\n\n\tlcd->supply = devm_regulator_get(dev, \"power\");\n\tif (IS_ERR(lcd->supply))\n\t\treturn PTR_ERR(lcd->supply);\n\n\tlcd->enable_gpio = devm_gpiod_get(dev, \"enable\", GPIOD_OUT_LOW);\n\tif (IS_ERR(lcd->enable_gpio))\n\t\treturn PTR_ERR(lcd->enable_gpio);\n\n\tdrm_panel_init(&lcd->panel, dev, &lcd_olinuxino_funcs,\n\t\t       DRM_MODE_CONNECTOR_DPI);\n\n\tret = drm_panel_of_backlight(&lcd->panel);\n\tif (ret)\n\t\treturn ret;\n\n\tdrm_panel_add(&lcd->panel);\n\n\treturn 0;\n}\n\nstatic void lcd_olinuxino_remove(struct i2c_client *client)\n{\n\tstruct lcd_olinuxino *panel = i2c_get_clientdata(client);\n\n\tdrm_panel_remove(&panel->panel);\n\n\tdrm_panel_disable(&panel->panel);\n\tdrm_panel_unprepare(&panel->panel);\n}\n\nstatic const struct of_device_id lcd_olinuxino_of_ids[] = {\n\t{ .compatible = \"olimex,lcd-olinuxino\" },\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, lcd_olinuxino_of_ids);\n\nstatic struct i2c_driver lcd_olinuxino_driver = {\n\t.driver = {\n\t\t.name = \"lcd_olinuxino\",\n\t\t.of_match_table = lcd_olinuxino_of_ids,\n\t},\n\t.probe = lcd_olinuxino_probe,\n\t.remove = lcd_olinuxino_remove,\n};\n\nmodule_i2c_driver(lcd_olinuxino_driver);\n\nMODULE_AUTHOR(\"Stefan Mavrodiev <stefan@olimex.com>\");\nMODULE_DESCRIPTION(\"LCD-OLinuXino driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}