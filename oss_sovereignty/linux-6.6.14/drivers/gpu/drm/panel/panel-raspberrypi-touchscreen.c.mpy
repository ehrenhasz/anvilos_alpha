{
  "module_name": "panel-raspberrypi-touchscreen.c",
  "hash_id": "e26b9716f1c2fe6e5baf3fb6ab3073cd748e6bdf6dd2e24f1991988e3839e531",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/panel/panel-raspberrypi-touchscreen.c",
  "human_readable_source": " \n\n \n\n#include <linux/delay.h>\n#include <linux/err.h>\n#include <linux/i2c.h>\n#include <linux/media-bus-format.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/of_graph.h>\n#include <linux/pm.h>\n\n#include <drm/drm_crtc.h>\n#include <drm/drm_device.h>\n#include <drm/drm_mipi_dsi.h>\n#include <drm/drm_panel.h>\n\n#define RPI_DSI_DRIVER_NAME \"rpi-ts-dsi\"\n\n \nenum REG_ADDR {\n\tREG_ID = 0x80,\n\tREG_PORTA,  \n\tREG_PORTB,\n\tREG_PORTC,\n\tREG_PORTD,\n\tREG_POWERON,\n\tREG_PWM,\n\tREG_DDRA,\n\tREG_DDRB,\n\tREG_DDRC,\n\tREG_DDRD,\n\tREG_TEST,\n\tREG_WR_ADDRL,\n\tREG_WR_ADDRH,\n\tREG_READH,\n\tREG_READL,\n\tREG_WRITEH,\n\tREG_WRITEL,\n\tREG_ID2,\n};\n\n \n#define D0W_DPHYCONTTX\t\t0x0004\n#define CLW_DPHYCONTRX\t\t0x0020\n#define D0W_DPHYCONTRX\t\t0x0024\n#define D1W_DPHYCONTRX\t\t0x0028\n#define COM_DPHYCONTRX\t\t0x0038\n#define CLW_CNTRL\t\t0x0040\n#define D0W_CNTRL\t\t0x0044\n#define D1W_CNTRL\t\t0x0048\n#define DFTMODE_CNTRL\t\t0x0054\n\n \n#define PPI_STARTPPI\t\t0x0104\n#define PPI_BUSYPPI\t\t0x0108\n#define PPI_LINEINITCNT\t\t0x0110\n#define PPI_LPTXTIMECNT\t\t0x0114\n#define PPI_CLS_ATMR\t\t0x0140\n#define PPI_D0S_ATMR\t\t0x0144\n#define PPI_D1S_ATMR\t\t0x0148\n#define PPI_D0S_CLRSIPOCOUNT\t0x0164\n#define PPI_D1S_CLRSIPOCOUNT\t0x0168\n#define CLS_PRE\t\t\t0x0180\n#define D0S_PRE\t\t\t0x0184\n#define D1S_PRE\t\t\t0x0188\n#define CLS_PREP\t\t0x01A0\n#define D0S_PREP\t\t0x01A4\n#define D1S_PREP\t\t0x01A8\n#define CLS_ZERO\t\t0x01C0\n#define D0S_ZERO\t\t0x01C4\n#define D1S_ZERO\t\t0x01C8\n#define PPI_CLRFLG\t\t0x01E0\n#define PPI_CLRSIPO\t\t0x01E4\n#define HSTIMEOUT\t\t0x01F0\n#define HSTIMEOUTENABLE\t\t0x01F4\n\n \n#define DSI_STARTDSI\t\t0x0204\n#define DSI_BUSYDSI\t\t0x0208\n#define DSI_LANEENABLE\t\t0x0210\n# define DSI_LANEENABLE_CLOCK\t\tBIT(0)\n# define DSI_LANEENABLE_D0\t\tBIT(1)\n# define DSI_LANEENABLE_D1\t\tBIT(2)\n\n#define DSI_LANESTATUS0\t\t0x0214\n#define DSI_LANESTATUS1\t\t0x0218\n#define DSI_INTSTATUS\t\t0x0220\n#define DSI_INTMASK\t\t0x0224\n#define DSI_INTCLR\t\t0x0228\n#define DSI_LPTXTO\t\t0x0230\n#define DSI_MODE\t\t0x0260\n#define DSI_PAYLOAD0\t\t0x0268\n#define DSI_PAYLOAD1\t\t0x026C\n#define DSI_SHORTPKTDAT\t\t0x0270\n#define DSI_SHORTPKTREQ\t\t0x0274\n#define DSI_BTASTA\t\t0x0278\n#define DSI_BTACLR\t\t0x027C\n\n \n#define DSIERRCNT\t\t0x0300\n#define DSISIGMOD\t\t0x0304\n\n \n#define APLCTRL\t\t\t0x0400\n#define APLSTAT\t\t\t0x0404\n#define APLERR\t\t\t0x0408\n#define PWRMOD\t\t\t0x040C\n#define RDPKTLN\t\t\t0x0410\n#define PXLFMT\t\t\t0x0414\n#define MEMWRCMD\t\t0x0418\n\n \n#define LCDCTRL\t\t\t0x0420\n#define HSR\t\t\t0x0424\n#define HDISPR\t\t\t0x0428\n#define VSR\t\t\t0x042C\n#define VDISPR\t\t\t0x0430\n#define VFUEN\t\t\t0x0434\n\n \n#define DBIBCTRL\t\t0x0440\n\n \n#define SPICMR\t\t\t0x0450\n#define SPITCR\t\t\t0x0454\n\n \n#define SYSSTAT\t\t\t0x0460\n#define SYSCTRL\t\t\t0x0464\n#define SYSPLL1\t\t\t0x0468\n#define SYSPLL2\t\t\t0x046C\n#define SYSPLL3\t\t\t0x0470\n#define SYSPMCTRL\t\t0x047C\n\n \n#define GPIOC\t\t\t0x0480\n#define GPIOO\t\t\t0x0484\n#define GPIOI\t\t\t0x0488\n\n \n#define I2CCLKCTRL\t\t0x0490\n\n \n#define IDREG\t\t\t0x04A0\n\n \n#define WCMDQUEUE\t\t0x0500\n#define RCMDQUEUE\t\t0x0504\n\nstruct rpi_touchscreen {\n\tstruct drm_panel base;\n\tstruct mipi_dsi_device *dsi;\n\tstruct i2c_client *i2c;\n};\n\nstatic const struct drm_display_mode rpi_touchscreen_modes[] = {\n\t{\n\t\t \n\t\t.clock = 25979400 / 1000,\n\t\t.hdisplay = 800,\n\t\t.hsync_start = 800 + 1,\n\t\t.hsync_end = 800 + 1 + 2,\n\t\t.htotal = 800 + 1 + 2 + 46,\n\t\t.vdisplay = 480,\n\t\t.vsync_start = 480 + 7,\n\t\t.vsync_end = 480 + 7 + 2,\n\t\t.vtotal = 480 + 7 + 2 + 21,\n\t},\n};\n\nstatic struct rpi_touchscreen *panel_to_ts(struct drm_panel *panel)\n{\n\treturn container_of(panel, struct rpi_touchscreen, base);\n}\n\nstatic int rpi_touchscreen_i2c_read(struct rpi_touchscreen *ts, u8 reg)\n{\n\treturn i2c_smbus_read_byte_data(ts->i2c, reg);\n}\n\nstatic void rpi_touchscreen_i2c_write(struct rpi_touchscreen *ts,\n\t\t\t\t      u8 reg, u8 val)\n{\n\tint ret;\n\n\tret = i2c_smbus_write_byte_data(ts->i2c, reg, val);\n\tif (ret)\n\t\tdev_err(&ts->i2c->dev, \"I2C write failed: %d\\n\", ret);\n}\n\nstatic int rpi_touchscreen_write(struct rpi_touchscreen *ts, u16 reg, u32 val)\n{\n\tu8 msg[] = {\n\t\treg,\n\t\treg >> 8,\n\t\tval,\n\t\tval >> 8,\n\t\tval >> 16,\n\t\tval >> 24,\n\t};\n\n\tmipi_dsi_generic_write(ts->dsi, msg, sizeof(msg));\n\n\treturn 0;\n}\n\nstatic int rpi_touchscreen_disable(struct drm_panel *panel)\n{\n\tstruct rpi_touchscreen *ts = panel_to_ts(panel);\n\n\trpi_touchscreen_i2c_write(ts, REG_PWM, 0);\n\n\trpi_touchscreen_i2c_write(ts, REG_POWERON, 0);\n\tudelay(1);\n\n\treturn 0;\n}\n\nstatic int rpi_touchscreen_noop(struct drm_panel *panel)\n{\n\treturn 0;\n}\n\nstatic int rpi_touchscreen_prepare(struct drm_panel *panel)\n{\n\tstruct rpi_touchscreen *ts = panel_to_ts(panel);\n\tint i;\n\n\trpi_touchscreen_i2c_write(ts, REG_POWERON, 1);\n\t \n\tfor (i = 0; i < 100; i++) {\n\t\tif (rpi_touchscreen_i2c_read(ts, REG_PORTB) & 1)\n\t\t\tbreak;\n\t}\n\n\trpi_touchscreen_write(ts, DSI_LANEENABLE,\n\t\t\t      DSI_LANEENABLE_CLOCK |\n\t\t\t      DSI_LANEENABLE_D0);\n\trpi_touchscreen_write(ts, PPI_D0S_CLRSIPOCOUNT, 0x05);\n\trpi_touchscreen_write(ts, PPI_D1S_CLRSIPOCOUNT, 0x05);\n\trpi_touchscreen_write(ts, PPI_D0S_ATMR, 0x00);\n\trpi_touchscreen_write(ts, PPI_D1S_ATMR, 0x00);\n\trpi_touchscreen_write(ts, PPI_LPTXTIMECNT, 0x03);\n\n\trpi_touchscreen_write(ts, SPICMR, 0x00);\n\trpi_touchscreen_write(ts, LCDCTRL, 0x00100150);\n\trpi_touchscreen_write(ts, SYSCTRL, 0x040f);\n\tmsleep(100);\n\n\trpi_touchscreen_write(ts, PPI_STARTPPI, 0x01);\n\trpi_touchscreen_write(ts, DSI_STARTDSI, 0x01);\n\tmsleep(100);\n\n\treturn 0;\n}\n\nstatic int rpi_touchscreen_enable(struct drm_panel *panel)\n{\n\tstruct rpi_touchscreen *ts = panel_to_ts(panel);\n\n\t \n\trpi_touchscreen_i2c_write(ts, REG_PWM, 255);\n\n\t \n\trpi_touchscreen_i2c_write(ts, REG_PORTA, BIT(2));\n\n\treturn 0;\n}\n\nstatic int rpi_touchscreen_get_modes(struct drm_panel *panel,\n\t\t\t\t     struct drm_connector *connector)\n{\n\tunsigned int i, num = 0;\n\tstatic const u32 bus_format = MEDIA_BUS_FMT_RGB888_1X24;\n\n\tfor (i = 0; i < ARRAY_SIZE(rpi_touchscreen_modes); i++) {\n\t\tconst struct drm_display_mode *m = &rpi_touchscreen_modes[i];\n\t\tstruct drm_display_mode *mode;\n\n\t\tmode = drm_mode_duplicate(connector->dev, m);\n\t\tif (!mode) {\n\t\t\tdev_err(panel->dev, \"failed to add mode %ux%u@%u\\n\",\n\t\t\t\tm->hdisplay, m->vdisplay,\n\t\t\t\tdrm_mode_vrefresh(m));\n\t\t\tcontinue;\n\t\t}\n\n\t\tmode->type |= DRM_MODE_TYPE_DRIVER;\n\n\t\tif (i == 0)\n\t\t\tmode->type |= DRM_MODE_TYPE_PREFERRED;\n\n\t\tdrm_mode_set_name(mode);\n\n\t\tdrm_mode_probed_add(connector, mode);\n\t\tnum++;\n\t}\n\n\tconnector->display_info.bpc = 8;\n\tconnector->display_info.width_mm = 154;\n\tconnector->display_info.height_mm = 86;\n\tdrm_display_info_set_bus_formats(&connector->display_info,\n\t\t\t\t\t &bus_format, 1);\n\n\treturn num;\n}\n\nstatic const struct drm_panel_funcs rpi_touchscreen_funcs = {\n\t.disable = rpi_touchscreen_disable,\n\t.unprepare = rpi_touchscreen_noop,\n\t.prepare = rpi_touchscreen_prepare,\n\t.enable = rpi_touchscreen_enable,\n\t.get_modes = rpi_touchscreen_get_modes,\n};\n\nstatic int rpi_touchscreen_probe(struct i2c_client *i2c)\n{\n\tstruct device *dev = &i2c->dev;\n\tstruct rpi_touchscreen *ts;\n\tstruct device_node *endpoint, *dsi_host_node;\n\tstruct mipi_dsi_host *host;\n\tint ver;\n\tstruct mipi_dsi_device_info info = {\n\t\t.type = RPI_DSI_DRIVER_NAME,\n\t\t.channel = 0,\n\t\t.node = NULL,\n\t};\n\n\tts = devm_kzalloc(dev, sizeof(*ts), GFP_KERNEL);\n\tif (!ts)\n\t\treturn -ENOMEM;\n\n\ti2c_set_clientdata(i2c, ts);\n\n\tts->i2c = i2c;\n\n\tver = rpi_touchscreen_i2c_read(ts, REG_ID);\n\tif (ver < 0) {\n\t\tdev_err(dev, \"Atmel I2C read failed: %d\\n\", ver);\n\t\treturn -ENODEV;\n\t}\n\n\tswitch (ver) {\n\tcase 0xde:  \n\tcase 0xc3:  \n\t\tbreak;\n\tdefault:\n\t\tdev_err(dev, \"Unknown Atmel firmware revision: 0x%02x\\n\", ver);\n\t\treturn -ENODEV;\n\t}\n\n\t \n\trpi_touchscreen_i2c_write(ts, REG_POWERON, 0);\n\n\t \n\tendpoint = of_graph_get_next_endpoint(dev->of_node, NULL);\n\tif (!endpoint)\n\t\treturn -ENODEV;\n\n\tdsi_host_node = of_graph_get_remote_port_parent(endpoint);\n\tif (!dsi_host_node)\n\t\tgoto error;\n\n\thost = of_find_mipi_dsi_host_by_node(dsi_host_node);\n\tof_node_put(dsi_host_node);\n\tif (!host) {\n\t\tof_node_put(endpoint);\n\t\treturn -EPROBE_DEFER;\n\t}\n\n\tinfo.node = of_graph_get_remote_port(endpoint);\n\tif (!info.node)\n\t\tgoto error;\n\n\tof_node_put(endpoint);\n\n\tts->dsi = mipi_dsi_device_register_full(host, &info);\n\tif (IS_ERR(ts->dsi)) {\n\t\tdev_err(dev, \"DSI device registration failed: %ld\\n\",\n\t\t\tPTR_ERR(ts->dsi));\n\t\treturn PTR_ERR(ts->dsi);\n\t}\n\n\tdrm_panel_init(&ts->base, dev, &rpi_touchscreen_funcs,\n\t\t       DRM_MODE_CONNECTOR_DSI);\n\n\t \n\tdrm_panel_add(&ts->base);\n\n\treturn 0;\n\nerror:\n\tof_node_put(endpoint);\n\treturn -ENODEV;\n}\n\nstatic void rpi_touchscreen_remove(struct i2c_client *i2c)\n{\n\tstruct rpi_touchscreen *ts = i2c_get_clientdata(i2c);\n\n\tmipi_dsi_detach(ts->dsi);\n\n\tdrm_panel_remove(&ts->base);\n\n\tmipi_dsi_device_unregister(ts->dsi);\n}\n\nstatic int rpi_touchscreen_dsi_probe(struct mipi_dsi_device *dsi)\n{\n\tint ret;\n\n\tdsi->mode_flags = (MIPI_DSI_MODE_VIDEO |\n\t\t\t   MIPI_DSI_MODE_VIDEO_SYNC_PULSE |\n\t\t\t   MIPI_DSI_MODE_LPM);\n\tdsi->format = MIPI_DSI_FMT_RGB888;\n\tdsi->lanes = 1;\n\n\tret = mipi_dsi_attach(dsi);\n\n\tif (ret)\n\t\tdev_err(&dsi->dev, \"failed to attach dsi to host: %d\\n\", ret);\n\n\treturn ret;\n}\n\nstatic struct mipi_dsi_driver rpi_touchscreen_dsi_driver = {\n\t.driver.name = RPI_DSI_DRIVER_NAME,\n\t.probe = rpi_touchscreen_dsi_probe,\n};\n\nstatic const struct of_device_id rpi_touchscreen_of_ids[] = {\n\t{ .compatible = \"raspberrypi,7inch-touchscreen-panel\" },\n\t{ }  \n};\nMODULE_DEVICE_TABLE(of, rpi_touchscreen_of_ids);\n\nstatic struct i2c_driver rpi_touchscreen_driver = {\n\t.driver = {\n\t\t.name = \"rpi_touchscreen\",\n\t\t.of_match_table = rpi_touchscreen_of_ids,\n\t},\n\t.probe = rpi_touchscreen_probe,\n\t.remove = rpi_touchscreen_remove,\n};\n\nstatic int __init rpi_touchscreen_init(void)\n{\n\tmipi_dsi_driver_register(&rpi_touchscreen_dsi_driver);\n\treturn i2c_add_driver(&rpi_touchscreen_driver);\n}\nmodule_init(rpi_touchscreen_init);\n\nstatic void __exit rpi_touchscreen_exit(void)\n{\n\ti2c_del_driver(&rpi_touchscreen_driver);\n\tmipi_dsi_driver_unregister(&rpi_touchscreen_dsi_driver);\n}\nmodule_exit(rpi_touchscreen_exit);\n\nMODULE_AUTHOR(\"Eric Anholt <eric@anholt.net>\");\nMODULE_DESCRIPTION(\"Raspberry Pi 7-inch touchscreen driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}