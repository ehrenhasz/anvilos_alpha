{
  "module_name": "panel-raydium-rm68200.c",
  "hash_id": "c885491e1ed8bbc2a0f6b83d3c6a88f81f6605f683ea9f397ad63b3b9ad50306",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/panel/panel-raydium-rm68200.c",
  "human_readable_source": "\n \n\n#include <linux/delay.h>\n#include <linux/gpio/consumer.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include <linux/regulator/consumer.h>\n\n#include <video/mipi_display.h>\n\n#include <drm/drm_mipi_dsi.h>\n#include <drm/drm_modes.h>\n#include <drm/drm_panel.h>\n\n \n#define MCS_CMD_MODE_SW\t\t0xFE  \n#define MCS_CMD1_UCS\t\t0x00  \n#define MCS_CMD2_P0\t\t0x01  \n#define MCS_CMD2_P1\t\t0x02  \n#define MCS_CMD2_P2\t\t0x03  \n#define MCS_CMD2_P3\t\t0x04  \n\n \n#define MCS_STBCTR\t\t0x12  \n#define MCS_SGOPCTR\t\t0x16  \n#define MCS_SDCTR\t\t0x1A  \n#define MCS_INVCTR\t\t0x1B  \n#define MCS_EXT_PWR_IC\t\t0x24  \n#define MCS_SETAVDD\t\t0x27  \n#define MCS_SETAVEE\t\t0x29  \n#define MCS_BT2CTR\t\t0x2B  \n#define MCS_BT3CTR\t\t0x2F  \n#define MCS_BT4CTR\t\t0x34  \n#define MCS_VCMCTR\t\t0x46  \n#define MCS_SETVGN\t\t0x52  \n#define MCS_SETVGP\t\t0x54  \n#define MCS_SW_CTRL\t\t0x5F  \n\n \n#define GOA_VSTV1\t\t0x00\n#define GOA_VSTV2\t\t0x07\n#define GOA_VCLK1\t\t0x0E\n#define GOA_VCLK2\t\t0x17\n#define GOA_VCLK_OPT1\t\t0x20\n#define GOA_BICLK1\t\t0x2A\n#define GOA_BICLK2\t\t0x37\n#define GOA_BICLK3\t\t0x44\n#define GOA_BICLK4\t\t0x4F\n#define GOA_BICLK_OPT1\t\t0x5B\n#define GOA_BICLK_OPT2\t\t0x60\n#define MCS_GOA_GPO1\t\t0x6D\n#define MCS_GOA_GPO2\t\t0x71\n#define MCS_GOA_EQ\t\t0x74\n#define MCS_GOA_CLK_GALLON\t0x7C\n#define MCS_GOA_FS_SEL0\t\t0x7E\n#define MCS_GOA_FS_SEL1\t\t0x87\n#define MCS_GOA_FS_SEL2\t\t0x91\n#define MCS_GOA_FS_SEL3\t\t0x9B\n#define MCS_GOA_BS_SEL0\t\t0xAC\n#define MCS_GOA_BS_SEL1\t\t0xB5\n#define MCS_GOA_BS_SEL2\t\t0xBF\n#define MCS_GOA_BS_SEL3\t\t0xC9\n#define MCS_GOA_BS_SEL4\t\t0xD3\n\n \n#define MCS_GAMMA_VP\t\t0x60  \n#define MCS_GAMMA_VN\t\t0x70  \n\nstruct rm68200 {\n\tstruct device *dev;\n\tstruct drm_panel panel;\n\tstruct gpio_desc *reset_gpio;\n\tstruct regulator *supply;\n\tbool prepared;\n\tbool enabled;\n};\n\nstatic const struct drm_display_mode default_mode = {\n\t.clock = 54000,\n\t.hdisplay = 720,\n\t.hsync_start = 720 + 48,\n\t.hsync_end = 720 + 48 + 9,\n\t.htotal = 720 + 48 + 9 + 48,\n\t.vdisplay = 1280,\n\t.vsync_start = 1280 + 12,\n\t.vsync_end = 1280 + 12 + 5,\n\t.vtotal = 1280 + 12 + 5 + 12,\n\t.flags = 0,\n\t.width_mm = 68,\n\t.height_mm = 122,\n};\n\nstatic inline struct rm68200 *panel_to_rm68200(struct drm_panel *panel)\n{\n\treturn container_of(panel, struct rm68200, panel);\n}\n\nstatic void rm68200_dcs_write_buf(struct rm68200 *ctx, const void *data,\n\t\t\t\t  size_t len)\n{\n\tstruct mipi_dsi_device *dsi = to_mipi_dsi_device(ctx->dev);\n\tint err;\n\n\terr = mipi_dsi_dcs_write_buffer(dsi, data, len);\n\tif (err < 0)\n\t\tdev_err_ratelimited(ctx->dev, \"MIPI DSI DCS write buffer failed: %d\\n\", err);\n}\n\nstatic void rm68200_dcs_write_cmd(struct rm68200 *ctx, u8 cmd, u8 value)\n{\n\tstruct mipi_dsi_device *dsi = to_mipi_dsi_device(ctx->dev);\n\tint err;\n\n\terr = mipi_dsi_dcs_write(dsi, cmd, &value, 1);\n\tif (err < 0)\n\t\tdev_err_ratelimited(ctx->dev, \"MIPI DSI DCS write failed: %d\\n\", err);\n}\n\n#define dcs_write_seq(ctx, seq...)\t\t\t\t\\\n({\t\t\t\t\t\t\t\t\\\n\tstatic const u8 d[] = { seq };\t\t\t\t\\\n\t\t\t\t\t\t\t\t\\\n\trm68200_dcs_write_buf(ctx, d, ARRAY_SIZE(d));\t\t\\\n})\n\n \n#define dcs_write_cmd_seq(ctx, cmd, seq...)\t\t\t\\\n({\t\t\t\t\t\t\t\t\\\n\tstatic const u8 d[] = { seq };\t\t\t\t\\\n\tunsigned int i;\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\\\n\tfor (i = 0; i < ARRAY_SIZE(d) ; i++)\t\t\t\\\n\t\trm68200_dcs_write_cmd(ctx, cmd + i, d[i]);\t\\\n})\n\nstatic void rm68200_init_sequence(struct rm68200 *ctx)\n{\n\t \n\tdcs_write_seq(ctx, MCS_CMD_MODE_SW, MCS_CMD2_P0);\n\tdcs_write_cmd_seq(ctx, MCS_EXT_PWR_IC, 0xC0, 0x53, 0x00);\n\tdcs_write_seq(ctx, MCS_BT2CTR, 0xE5);\n\tdcs_write_seq(ctx, MCS_SETAVDD, 0x0A);\n\tdcs_write_seq(ctx, MCS_SETAVEE, 0x0A);\n\tdcs_write_seq(ctx, MCS_SGOPCTR, 0x52);\n\tdcs_write_seq(ctx, MCS_BT3CTR, 0x53);\n\tdcs_write_seq(ctx, MCS_BT4CTR, 0x5A);\n\tdcs_write_seq(ctx, MCS_INVCTR, 0x00);\n\tdcs_write_seq(ctx, MCS_STBCTR, 0x0A);\n\tdcs_write_seq(ctx, MCS_SDCTR, 0x06);\n\tdcs_write_seq(ctx, MCS_VCMCTR, 0x56);\n\tdcs_write_seq(ctx, MCS_SETVGN, 0xA0, 0x00);\n\tdcs_write_seq(ctx, MCS_SETVGP, 0xA0, 0x00);\n\tdcs_write_seq(ctx, MCS_SW_CTRL, 0x11);  \n\n\tdcs_write_seq(ctx, MCS_CMD_MODE_SW, MCS_CMD2_P2);\n\tdcs_write_seq(ctx, GOA_VSTV1, 0x05);\n\tdcs_write_seq(ctx, 0x02, 0x0B);\n\tdcs_write_seq(ctx, 0x03, 0x0F);\n\tdcs_write_seq(ctx, 0x04, 0x7D, 0x00, 0x50);\n\tdcs_write_cmd_seq(ctx, GOA_VSTV2, 0x05, 0x16, 0x0D, 0x11, 0x7D, 0x00,\n\t\t\t  0x50);\n\tdcs_write_cmd_seq(ctx, GOA_VCLK1, 0x07, 0x08, 0x01, 0x02, 0x00, 0x7D,\n\t\t\t  0x00, 0x85, 0x08);\n\tdcs_write_cmd_seq(ctx, GOA_VCLK2, 0x03, 0x04, 0x05, 0x06, 0x00, 0x7D,\n\t\t\t  0x00, 0x85, 0x08);\n\tdcs_write_seq(ctx, GOA_VCLK_OPT1, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n\t\t      0x00, 0x00, 0x00, 0x00);\n\tdcs_write_cmd_seq(ctx, GOA_BICLK1, 0x07, 0x08);\n\tdcs_write_seq(ctx, 0x2D, 0x01);\n\tdcs_write_seq(ctx, 0x2F, 0x02, 0x00, 0x40, 0x05, 0x08, 0x54, 0x7D,\n\t\t      0x00);\n\tdcs_write_cmd_seq(ctx, GOA_BICLK2, 0x03, 0x04, 0x05, 0x06, 0x00);\n\tdcs_write_seq(ctx, 0x3D, 0x40);\n\tdcs_write_seq(ctx, 0x3F, 0x05, 0x08, 0x54, 0x7D, 0x00);\n\tdcs_write_seq(ctx, GOA_BICLK3, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n\t\t      0x00, 0x00, 0x00, 0x00, 0x00);\n\tdcs_write_seq(ctx, GOA_BICLK4, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n\t\t      0x00, 0x00);\n\tdcs_write_seq(ctx, 0x58, 0x00, 0x00, 0x00);\n\tdcs_write_seq(ctx, GOA_BICLK_OPT1, 0x00, 0x00, 0x00, 0x00, 0x00);\n\tdcs_write_seq(ctx, GOA_BICLK_OPT2, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n\t\t      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00);\n\tdcs_write_seq(ctx, MCS_GOA_GPO1, 0x00, 0x00, 0x00, 0x00);\n\tdcs_write_seq(ctx, MCS_GOA_GPO2, 0x00, 0x20, 0x00);\n\tdcs_write_seq(ctx, MCS_GOA_EQ, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08,\n\t\t      0x00, 0x00);\n\tdcs_write_seq(ctx, MCS_GOA_CLK_GALLON, 0x00, 0x00);\n\tdcs_write_cmd_seq(ctx, MCS_GOA_FS_SEL0, 0xBF, 0x02, 0x06, 0x14, 0x10,\n\t\t\t  0x16, 0x12, 0x08, 0x3F);\n\tdcs_write_cmd_seq(ctx, MCS_GOA_FS_SEL1, 0x3F, 0x3F, 0x3F, 0x3F, 0x0C,\n\t\t\t  0x0A, 0x0E, 0x3F, 0x3F, 0x00);\n\tdcs_write_cmd_seq(ctx, MCS_GOA_FS_SEL2, 0x04, 0x3F, 0x3F, 0x3F, 0x3F,\n\t\t\t  0x05, 0x01, 0x3F, 0x3F, 0x0F);\n\tdcs_write_cmd_seq(ctx, MCS_GOA_FS_SEL3, 0x0B, 0x0D, 0x3F, 0x3F, 0x3F,\n\t\t\t  0x3F);\n\tdcs_write_cmd_seq(ctx, 0xA2, 0x3F, 0x09, 0x13, 0x17, 0x11, 0x15);\n\tdcs_write_cmd_seq(ctx, 0xA9, 0x07, 0x03, 0x3F);\n\tdcs_write_cmd_seq(ctx, MCS_GOA_BS_SEL0, 0x3F, 0x05, 0x01, 0x17, 0x13,\n\t\t\t  0x15, 0x11, 0x0F, 0x3F);\n\tdcs_write_cmd_seq(ctx, MCS_GOA_BS_SEL1, 0x3F, 0x3F, 0x3F, 0x3F, 0x0B,\n\t\t\t  0x0D, 0x09, 0x3F, 0x3F, 0x07);\n\tdcs_write_cmd_seq(ctx, MCS_GOA_BS_SEL2, 0x03, 0x3F, 0x3F, 0x3F, 0x3F,\n\t\t\t  0x02, 0x06, 0x3F, 0x3F, 0x08);\n\tdcs_write_cmd_seq(ctx, MCS_GOA_BS_SEL3, 0x0C, 0x0A, 0x3F, 0x3F, 0x3F,\n\t\t\t  0x3F, 0x3F, 0x0E, 0x10, 0x14);\n\tdcs_write_cmd_seq(ctx, MCS_GOA_BS_SEL4, 0x12, 0x16, 0x00, 0x04, 0x3F);\n\tdcs_write_seq(ctx, 0xDC, 0x02);\n\tdcs_write_seq(ctx, 0xDE, 0x12);\n\n\tdcs_write_seq(ctx, MCS_CMD_MODE_SW, 0x0E);  \n\tdcs_write_seq(ctx, 0x01, 0x75);\n\n\tdcs_write_seq(ctx, MCS_CMD_MODE_SW, MCS_CMD2_P3);\n\tdcs_write_cmd_seq(ctx, MCS_GAMMA_VP, 0x00, 0x0C, 0x12, 0x0E, 0x06,\n\t\t\t  0x12, 0x0E, 0x0B, 0x15, 0x0B, 0x10, 0x07, 0x0F,\n\t\t\t  0x12, 0x0C, 0x00);\n\tdcs_write_cmd_seq(ctx, MCS_GAMMA_VN, 0x00, 0x0C, 0x12, 0x0E, 0x06,\n\t\t\t  0x12, 0x0E, 0x0B, 0x15, 0x0B, 0x10, 0x07, 0x0F,\n\t\t\t  0x12, 0x0C, 0x00);\n\n\t \n\tdcs_write_seq(ctx, MCS_CMD_MODE_SW, MCS_CMD1_UCS);\n}\n\nstatic int rm68200_disable(struct drm_panel *panel)\n{\n\tstruct rm68200 *ctx = panel_to_rm68200(panel);\n\n\tif (!ctx->enabled)\n\t\treturn 0;\n\n\tctx->enabled = false;\n\n\treturn 0;\n}\n\nstatic int rm68200_unprepare(struct drm_panel *panel)\n{\n\tstruct rm68200 *ctx = panel_to_rm68200(panel);\n\tstruct mipi_dsi_device *dsi = to_mipi_dsi_device(ctx->dev);\n\tint ret;\n\n\tif (!ctx->prepared)\n\t\treturn 0;\n\n\tret = mipi_dsi_dcs_set_display_off(dsi);\n\tif (ret)\n\t\tdev_warn(panel->dev, \"failed to set display off: %d\\n\", ret);\n\n\tret = mipi_dsi_dcs_enter_sleep_mode(dsi);\n\tif (ret)\n\t\tdev_warn(panel->dev, \"failed to enter sleep mode: %d\\n\", ret);\n\n\tmsleep(120);\n\n\tif (ctx->reset_gpio) {\n\t\tgpiod_set_value_cansleep(ctx->reset_gpio, 1);\n\t\tmsleep(20);\n\t}\n\n\tregulator_disable(ctx->supply);\n\n\tctx->prepared = false;\n\n\treturn 0;\n}\n\nstatic int rm68200_prepare(struct drm_panel *panel)\n{\n\tstruct rm68200 *ctx = panel_to_rm68200(panel);\n\tstruct mipi_dsi_device *dsi = to_mipi_dsi_device(ctx->dev);\n\tint ret;\n\n\tif (ctx->prepared)\n\t\treturn 0;\n\n\tret = regulator_enable(ctx->supply);\n\tif (ret < 0) {\n\t\tdev_err(ctx->dev, \"failed to enable supply: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tif (ctx->reset_gpio) {\n\t\tgpiod_set_value_cansleep(ctx->reset_gpio, 1);\n\t\tmsleep(20);\n\t\tgpiod_set_value_cansleep(ctx->reset_gpio, 0);\n\t\tmsleep(100);\n\t}\n\n\trm68200_init_sequence(ctx);\n\n\tret = mipi_dsi_dcs_exit_sleep_mode(dsi);\n\tif (ret)\n\t\treturn ret;\n\n\tmsleep(125);\n\n\tret = mipi_dsi_dcs_set_display_on(dsi);\n\tif (ret)\n\t\treturn ret;\n\n\tmsleep(20);\n\n\tctx->prepared = true;\n\n\treturn 0;\n}\n\nstatic int rm68200_enable(struct drm_panel *panel)\n{\n\tstruct rm68200 *ctx = panel_to_rm68200(panel);\n\n\tif (ctx->enabled)\n\t\treturn 0;\n\n\tctx->enabled = true;\n\n\treturn 0;\n}\n\nstatic int rm68200_get_modes(struct drm_panel *panel,\n\t\t\t     struct drm_connector *connector)\n{\n\tstruct drm_display_mode *mode;\n\n\tmode = drm_mode_duplicate(connector->dev, &default_mode);\n\tif (!mode) {\n\t\tdev_err(panel->dev, \"failed to add mode %ux%u@%u\\n\",\n\t\t\tdefault_mode.hdisplay, default_mode.vdisplay,\n\t\t\tdrm_mode_vrefresh(&default_mode));\n\t\treturn -ENOMEM;\n\t}\n\n\tdrm_mode_set_name(mode);\n\n\tmode->type = DRM_MODE_TYPE_DRIVER | DRM_MODE_TYPE_PREFERRED;\n\tdrm_mode_probed_add(connector, mode);\n\n\tconnector->display_info.width_mm = mode->width_mm;\n\tconnector->display_info.height_mm = mode->height_mm;\n\n\treturn 1;\n}\n\nstatic const struct drm_panel_funcs rm68200_drm_funcs = {\n\t.disable = rm68200_disable,\n\t.unprepare = rm68200_unprepare,\n\t.prepare = rm68200_prepare,\n\t.enable = rm68200_enable,\n\t.get_modes = rm68200_get_modes,\n};\n\nstatic int rm68200_probe(struct mipi_dsi_device *dsi)\n{\n\tstruct device *dev = &dsi->dev;\n\tstruct rm68200 *ctx;\n\tint ret;\n\n\tctx = devm_kzalloc(dev, sizeof(*ctx), GFP_KERNEL);\n\tif (!ctx)\n\t\treturn -ENOMEM;\n\n\tctx->reset_gpio = devm_gpiod_get_optional(dev, \"reset\", GPIOD_OUT_LOW);\n\tif (IS_ERR(ctx->reset_gpio)) {\n\t\tret = PTR_ERR(ctx->reset_gpio);\n\t\tdev_err(dev, \"cannot get reset GPIO: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tctx->supply = devm_regulator_get(dev, \"power\");\n\tif (IS_ERR(ctx->supply)) {\n\t\tret = PTR_ERR(ctx->supply);\n\t\tif (ret != -EPROBE_DEFER)\n\t\t\tdev_err(dev, \"cannot get regulator: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tmipi_dsi_set_drvdata(dsi, ctx);\n\n\tctx->dev = dev;\n\n\tdsi->lanes = 2;\n\tdsi->format = MIPI_DSI_FMT_RGB888;\n\tdsi->mode_flags = MIPI_DSI_MODE_VIDEO | MIPI_DSI_MODE_VIDEO_BURST |\n\t\t\t  MIPI_DSI_MODE_LPM | MIPI_DSI_CLOCK_NON_CONTINUOUS;\n\n\tdrm_panel_init(&ctx->panel, dev, &rm68200_drm_funcs,\n\t\t       DRM_MODE_CONNECTOR_DSI);\n\n\tret = drm_panel_of_backlight(&ctx->panel);\n\tif (ret)\n\t\treturn ret;\n\n\tdrm_panel_add(&ctx->panel);\n\n\tret = mipi_dsi_attach(dsi);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"mipi_dsi_attach() failed: %d\\n\", ret);\n\t\tdrm_panel_remove(&ctx->panel);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic void rm68200_remove(struct mipi_dsi_device *dsi)\n{\n\tstruct rm68200 *ctx = mipi_dsi_get_drvdata(dsi);\n\n\tmipi_dsi_detach(dsi);\n\tdrm_panel_remove(&ctx->panel);\n}\n\nstatic const struct of_device_id raydium_rm68200_of_match[] = {\n\t{ .compatible = \"raydium,rm68200\" },\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, raydium_rm68200_of_match);\n\nstatic struct mipi_dsi_driver raydium_rm68200_driver = {\n\t.probe = rm68200_probe,\n\t.remove = rm68200_remove,\n\t.driver = {\n\t\t.name = \"panel-raydium-rm68200\",\n\t\t.of_match_table = raydium_rm68200_of_match,\n\t},\n};\nmodule_mipi_dsi_driver(raydium_rm68200_driver);\n\nMODULE_AUTHOR(\"Philippe Cornu <philippe.cornu@st.com>\");\nMODULE_AUTHOR(\"Yannick Fertre <yannick.fertre@st.com>\");\nMODULE_DESCRIPTION(\"DRM Driver for Raydium RM68200 MIPI DSI panel\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}