{
  "module_name": "panel-orisetech-otm8009a.c",
  "hash_id": "f56eb89611188cf673d54cebc76e159ae100299e307c7265a1652467ece36b90",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/panel/panel-orisetech-otm8009a.c",
  "human_readable_source": "\n \n\n#include <linux/backlight.h>\n#include <linux/delay.h>\n#include <linux/gpio/consumer.h>\n#include <linux/module.h>\n#include <linux/regulator/consumer.h>\n\n#include <video/mipi_display.h>\n\n#include <drm/drm_mipi_dsi.h>\n#include <drm/drm_modes.h>\n#include <drm/drm_panel.h>\n\n#define OTM8009A_BACKLIGHT_DEFAULT\t240\n#define OTM8009A_BACKLIGHT_MAX\t\t255\n\n \n#define MCS_ADRSFT\t0x0000\t \n#define MCS_PANSET\t0xB3A6\t \n#define MCS_SD_CTRL\t0xC0A2\t \n#define MCS_P_DRV_M\t0xC0B4\t \n#define MCS_OSC_ADJ\t0xC181\t \n#define MCS_RGB_VID_SET\t0xC1A1\t \n#define MCS_SD_PCH_CTRL\t0xC480\t \n#define MCS_NO_DOC1\t0xC48A\t \n#define MCS_PWR_CTRL1\t0xC580\t \n#define MCS_PWR_CTRL2\t0xC590\t \n#define MCS_PWR_CTRL4\t0xC5B0\t \n#define MCS_PANCTRLSET1\t0xCB80\t \n#define MCS_PANCTRLSET2\t0xCB90\t \n#define MCS_PANCTRLSET3\t0xCBA0\t \n#define MCS_PANCTRLSET4\t0xCBB0\t \n#define MCS_PANCTRLSET5\t0xCBC0\t \n#define MCS_PANCTRLSET6\t0xCBD0\t \n#define MCS_PANCTRLSET7\t0xCBE0\t \n#define MCS_PANCTRLSET8\t0xCBF0\t \n#define MCS_PANU2D1\t0xCC80\t \n#define MCS_PANU2D2\t0xCC90\t \n#define MCS_PANU2D3\t0xCCA0\t \n#define MCS_PAND2U1\t0xCCB0\t \n#define MCS_PAND2U2\t0xCCC0\t \n#define MCS_PAND2U3\t0xCCD0\t \n#define MCS_GOAVST\t0xCE80\t \n#define MCS_GOACLKA1\t0xCEA0\t \n#define MCS_GOACLKA3\t0xCEB0\t \n#define MCS_GOAECLK\t0xCFC0\t \n#define MCS_NO_DOC2\t0xCFD0\t \n#define MCS_GVDDSET\t0xD800\t \n#define MCS_VCOMDC\t0xD900\t \n#define MCS_GMCT2_2P\t0xE100\t \n#define MCS_GMCT2_2N\t0xE200\t \n#define MCS_NO_DOC3\t0xF5B6\t \n#define MCS_CMD2_ENA1\t0xFF00\t \n#define MCS_CMD2_ENA2\t0xFF80\t \n\n#define OTM8009A_HDISPLAY\t480\n#define OTM8009A_VDISPLAY\t800\n\nstruct otm8009a {\n\tstruct device *dev;\n\tstruct drm_panel panel;\n\tstruct backlight_device *bl_dev;\n\tstruct gpio_desc *reset_gpio;\n\tstruct regulator *supply;\n\tbool prepared;\n\tbool enabled;\n};\n\nstatic const struct drm_display_mode modes[] = {\n\t{  \n\t\t.clock = 29700,\n\t\t.hdisplay = 480,\n\t\t.hsync_start = 480 + 98,\n\t\t.hsync_end = 480 + 98 + 32,\n\t\t.htotal = 480 + 98 + 32 + 98,\n\t\t.vdisplay = 800,\n\t\t.vsync_start = 800 + 15,\n\t\t.vsync_end = 800 + 15 + 10,\n\t\t.vtotal = 800 + 15 + 10 + 14,\n\t\t.flags = DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_NVSYNC,\n\t\t.width_mm = 52,\n\t\t.height_mm = 86,\n\t},\n\t{  \n\t\t.clock = 33000,\n\t\t.hdisplay = 480,\n\t\t.hsync_start = 480 + 70,\n\t\t.hsync_end = 480 + 70 + 32,\n\t\t.htotal = 480 + 70 + 32 + 72,\n\t\t.vdisplay = 800,\n\t\t.vsync_start = 800 + 15,\n\t\t.vsync_end = 800 + 15 + 10,\n\t\t.vtotal = 800 + 15 + 10 + 16,\n\t\t.flags = DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_NVSYNC,\n\t\t.width_mm = 52,\n\t\t.height_mm = 86,\n\t},\n};\n\nstatic inline struct otm8009a *panel_to_otm8009a(struct drm_panel *panel)\n{\n\treturn container_of(panel, struct otm8009a, panel);\n}\n\nstatic void otm8009a_dcs_write_buf(struct otm8009a *ctx, const void *data,\n\t\t\t\t   size_t len)\n{\n\tstruct mipi_dsi_device *dsi = to_mipi_dsi_device(ctx->dev);\n\n\tif (mipi_dsi_dcs_write_buffer(dsi, data, len) < 0)\n\t\tdev_warn(ctx->dev, \"mipi dsi dcs write buffer failed\\n\");\n}\n\n#define dcs_write_seq(ctx, seq...)\t\t\t\\\n({\t\t\t\t\t\t\t\\\n\tstatic const u8 d[] = { seq };\t\t\t\\\n\totm8009a_dcs_write_buf(ctx, d, ARRAY_SIZE(d));\t\\\n})\n\n#define dcs_write_cmd_at(ctx, cmd, seq...)\t\t\\\n({\t\t\t\t\t\t\t\\\n\tdcs_write_seq(ctx, MCS_ADRSFT, (cmd) & 0xFF);\t\\\n\tdcs_write_seq(ctx, (cmd) >> 8, seq);\t\t\\\n})\n\nstatic int otm8009a_init_sequence(struct otm8009a *ctx)\n{\n\tstruct mipi_dsi_device *dsi = to_mipi_dsi_device(ctx->dev);\n\tint ret;\n\n\t \n\tdcs_write_cmd_at(ctx, MCS_CMD2_ENA1, 0x80, 0x09, 0x01);\n\n\t \n\tdcs_write_cmd_at(ctx, MCS_CMD2_ENA2, 0x80, 0x09);\n\n\tdcs_write_cmd_at(ctx, MCS_SD_PCH_CTRL, 0x30);\n\tmdelay(10);\n\n\tdcs_write_cmd_at(ctx, MCS_NO_DOC1, 0x40);\n\tmdelay(10);\n\n\tdcs_write_cmd_at(ctx, MCS_PWR_CTRL4 + 1, 0xA9);\n\tdcs_write_cmd_at(ctx, MCS_PWR_CTRL2 + 1, 0x34);\n\tdcs_write_cmd_at(ctx, MCS_P_DRV_M, 0x50);\n\tdcs_write_cmd_at(ctx, MCS_VCOMDC, 0x4E);\n\tdcs_write_cmd_at(ctx, MCS_OSC_ADJ, 0x66);  \n\tdcs_write_cmd_at(ctx, MCS_PWR_CTRL2 + 2, 0x01);\n\tdcs_write_cmd_at(ctx, MCS_PWR_CTRL2 + 5, 0x34);\n\tdcs_write_cmd_at(ctx, MCS_PWR_CTRL2 + 4, 0x33);\n\tdcs_write_cmd_at(ctx, MCS_GVDDSET, 0x79, 0x79);\n\tdcs_write_cmd_at(ctx, MCS_SD_CTRL + 1, 0x1B);\n\tdcs_write_cmd_at(ctx, MCS_PWR_CTRL1 + 2, 0x83);\n\tdcs_write_cmd_at(ctx, MCS_SD_PCH_CTRL + 1, 0x83);\n\tdcs_write_cmd_at(ctx, MCS_RGB_VID_SET, 0x0E);\n\tdcs_write_cmd_at(ctx, MCS_PANSET, 0x00, 0x01);\n\n\tdcs_write_cmd_at(ctx, MCS_GOAVST, 0x85, 0x01, 0x00, 0x84, 0x01, 0x00);\n\tdcs_write_cmd_at(ctx, MCS_GOACLKA1, 0x18, 0x04, 0x03, 0x39, 0x00, 0x00,\n\t\t\t 0x00, 0x18, 0x03, 0x03, 0x3A, 0x00, 0x00, 0x00);\n\tdcs_write_cmd_at(ctx, MCS_GOACLKA3, 0x18, 0x02, 0x03, 0x3B, 0x00, 0x00,\n\t\t\t 0x00, 0x18, 0x01, 0x03, 0x3C, 0x00, 0x00, 0x00);\n\tdcs_write_cmd_at(ctx, MCS_GOAECLK, 0x01, 0x01, 0x20, 0x20, 0x00, 0x00,\n\t\t\t 0x01, 0x02, 0x00, 0x00);\n\n\tdcs_write_cmd_at(ctx, MCS_NO_DOC2, 0x00);\n\n\tdcs_write_cmd_at(ctx, MCS_PANCTRLSET1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);\n\tdcs_write_cmd_at(ctx, MCS_PANCTRLSET2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t\t\t 0, 0, 0, 0, 0);\n\tdcs_write_cmd_at(ctx, MCS_PANCTRLSET3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t\t\t 0, 0, 0, 0, 0);\n\tdcs_write_cmd_at(ctx, MCS_PANCTRLSET4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);\n\tdcs_write_cmd_at(ctx, MCS_PANCTRLSET5, 0, 4, 4, 4, 4, 4, 0, 0, 0, 0,\n\t\t\t 0, 0, 0, 0, 0);\n\tdcs_write_cmd_at(ctx, MCS_PANCTRLSET6, 0, 0, 0, 0, 0, 0, 4, 4, 4, 4,\n\t\t\t 4, 0, 0, 0, 0);\n\tdcs_write_cmd_at(ctx, MCS_PANCTRLSET7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);\n\tdcs_write_cmd_at(ctx, MCS_PANCTRLSET8, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,\n\t\t\t 0xFF, 0xFF, 0xFF, 0xFF, 0xFF);\n\n\tdcs_write_cmd_at(ctx, MCS_PANU2D1, 0x00, 0x26, 0x09, 0x0B, 0x01, 0x25,\n\t\t\t 0x00, 0x00, 0x00, 0x00);\n\tdcs_write_cmd_at(ctx, MCS_PANU2D2, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n\t\t\t 0x00, 0x00, 0x00, 0x00, 0x00, 0x26, 0x0A, 0x0C, 0x02);\n\tdcs_write_cmd_at(ctx, MCS_PANU2D3, 0x25, 0x00, 0x00, 0x00, 0x00, 0x00,\n\t\t\t 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00);\n\tdcs_write_cmd_at(ctx, MCS_PAND2U1, 0x00, 0x25, 0x0C, 0x0A, 0x02, 0x26,\n\t\t\t 0x00, 0x00, 0x00, 0x00);\n\tdcs_write_cmd_at(ctx, MCS_PAND2U2, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n\t\t\t 0x00, 0x00, 0x00, 0x00, 0x00, 0x25, 0x0B, 0x09, 0x01);\n\tdcs_write_cmd_at(ctx, MCS_PAND2U3, 0x26, 0x00, 0x00, 0x00, 0x00, 0x00,\n\t\t\t 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00);\n\n\tdcs_write_cmd_at(ctx, MCS_PWR_CTRL1 + 1, 0x66);\n\n\tdcs_write_cmd_at(ctx, MCS_NO_DOC3, 0x06);\n\n\tdcs_write_cmd_at(ctx, MCS_GMCT2_2P, 0x00, 0x09, 0x0F, 0x0E, 0x07, 0x10,\n\t\t\t 0x0B, 0x0A, 0x04, 0x07, 0x0B, 0x08, 0x0F, 0x10, 0x0A,\n\t\t\t 0x01);\n\tdcs_write_cmd_at(ctx, MCS_GMCT2_2N, 0x00, 0x09, 0x0F, 0x0E, 0x07, 0x10,\n\t\t\t 0x0B, 0x0A, 0x04, 0x07, 0x0B, 0x08, 0x0F, 0x10, 0x0A,\n\t\t\t 0x01);\n\n\t \n\tdcs_write_cmd_at(ctx, MCS_CMD2_ENA1, 0xFF, 0xFF, 0xFF);\n\n\tret = mipi_dsi_dcs_nop(dsi);\n\tif (ret)\n\t\treturn ret;\n\n\tret = mipi_dsi_dcs_exit_sleep_mode(dsi);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tmdelay(120);\n\n\t \n\tdcs_write_seq(ctx, MIPI_DCS_SET_ADDRESS_MODE, 0x00);\n\n\tret = mipi_dsi_dcs_set_column_address(dsi, 0, OTM8009A_HDISPLAY - 1);\n\tif (ret)\n\t\treturn ret;\n\n\tret = mipi_dsi_dcs_set_page_address(dsi, 0, OTM8009A_VDISPLAY - 1);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tret = mipi_dsi_dcs_set_pixel_format(dsi, MIPI_DCS_PIXEL_FMT_24BIT |\n\t\t\t\t\t    MIPI_DCS_PIXEL_FMT_24BIT << 4);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tdcs_write_seq(ctx, MIPI_DCS_WRITE_POWER_SAVE, 0x00);\n\n\tret = mipi_dsi_dcs_set_display_on(dsi);\n\tif (ret)\n\t\treturn ret;\n\n\tret = mipi_dsi_dcs_nop(dsi);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tdcs_write_seq(ctx, MIPI_DCS_WRITE_MEMORY_START);\n\n\t \n\tmdelay(10);\n\n\treturn 0;\n}\n\nstatic int otm8009a_disable(struct drm_panel *panel)\n{\n\tstruct otm8009a *ctx = panel_to_otm8009a(panel);\n\tstruct mipi_dsi_device *dsi = to_mipi_dsi_device(ctx->dev);\n\tint ret;\n\n\tif (!ctx->enabled)\n\t\treturn 0;  \n\n\tbacklight_disable(ctx->bl_dev);\n\n\tret = mipi_dsi_dcs_set_display_off(dsi);\n\tif (ret)\n\t\treturn ret;\n\n\tret = mipi_dsi_dcs_enter_sleep_mode(dsi);\n\tif (ret)\n\t\treturn ret;\n\n\tmsleep(120);\n\n\tctx->enabled = false;\n\n\treturn 0;\n}\n\nstatic int otm8009a_unprepare(struct drm_panel *panel)\n{\n\tstruct otm8009a *ctx = panel_to_otm8009a(panel);\n\n\tif (!ctx->prepared)\n\t\treturn 0;\n\n\tif (ctx->reset_gpio) {\n\t\tgpiod_set_value_cansleep(ctx->reset_gpio, 1);\n\t\tmsleep(20);\n\t}\n\n\tregulator_disable(ctx->supply);\n\n\tctx->prepared = false;\n\n\treturn 0;\n}\n\nstatic int otm8009a_prepare(struct drm_panel *panel)\n{\n\tstruct otm8009a *ctx = panel_to_otm8009a(panel);\n\tint ret;\n\n\tif (ctx->prepared)\n\t\treturn 0;\n\n\tret = regulator_enable(ctx->supply);\n\tif (ret < 0) {\n\t\tdev_err(panel->dev, \"failed to enable supply: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tif (ctx->reset_gpio) {\n\t\tgpiod_set_value_cansleep(ctx->reset_gpio, 0);\n\t\tgpiod_set_value_cansleep(ctx->reset_gpio, 1);\n\t\tmsleep(20);\n\t\tgpiod_set_value_cansleep(ctx->reset_gpio, 0);\n\t\tmsleep(100);\n\t}\n\n\tret = otm8009a_init_sequence(ctx);\n\tif (ret)\n\t\treturn ret;\n\n\tctx->prepared = true;\n\n\treturn 0;\n}\n\nstatic int otm8009a_enable(struct drm_panel *panel)\n{\n\tstruct otm8009a *ctx = panel_to_otm8009a(panel);\n\n\tif (ctx->enabled)\n\t\treturn 0;\n\n\tbacklight_enable(ctx->bl_dev);\n\n\tctx->enabled = true;\n\n\treturn 0;\n}\n\nstatic int otm8009a_get_modes(struct drm_panel *panel,\n\t\t\t      struct drm_connector *connector)\n{\n\tstruct drm_display_mode *mode;\n\tunsigned int num_modes = ARRAY_SIZE(modes);\n\tunsigned int i;\n\n\tfor (i = 0; i < num_modes; i++) {\n\t\tmode = drm_mode_duplicate(connector->dev, &modes[i]);\n\t\tif (!mode) {\n\t\t\tdev_err(panel->dev, \"failed to add mode %ux%u@%u\\n\",\n\t\t\t\tmodes[i].hdisplay,\n\t\t\t\tmodes[i].vdisplay,\n\t\t\t\tdrm_mode_vrefresh(&modes[i]));\n\t\t\treturn -ENOMEM;\n\t\t}\n\n\t\tmode->type = DRM_MODE_TYPE_DRIVER;\n\n\t\t \n\t\tif (!i)\n\t\t\tmode->type |=  DRM_MODE_TYPE_PREFERRED;\n\n\t\tdrm_mode_set_name(mode);\n\t\tdrm_mode_probed_add(connector, mode);\n\t}\n\n\tconnector->display_info.width_mm = mode->width_mm;\n\tconnector->display_info.height_mm = mode->height_mm;\n\n\treturn num_modes;\n}\n\nstatic const struct drm_panel_funcs otm8009a_drm_funcs = {\n\t.disable   = otm8009a_disable,\n\t.unprepare = otm8009a_unprepare,\n\t.prepare   = otm8009a_prepare,\n\t.enable    = otm8009a_enable,\n\t.get_modes = otm8009a_get_modes,\n};\n\n \n\nstatic int otm8009a_backlight_update_status(struct backlight_device *bd)\n{\n\tstruct otm8009a *ctx = bl_get_data(bd);\n\tu8 data[2];\n\n\tif (!ctx->prepared) {\n\t\tdev_dbg(&bd->dev, \"lcd not ready yet for setting its backlight!\\n\");\n\t\treturn -ENXIO;\n\t}\n\n\tif (bd->props.power <= FB_BLANK_NORMAL) {\n\t\t \n\t\tdata[0] = MIPI_DCS_SET_DISPLAY_BRIGHTNESS;\n\t\tdata[1] = bd->props.brightness;\n\t\totm8009a_dcs_write_buf(ctx, data, ARRAY_SIZE(data));\n\n\t\t \n\t\tdata[1] = 0x24;\n\n\t} else {\n\t\t \n\t\tdata[1] = 0;\n\t}\n\n\t \n\tdata[0] = MIPI_DCS_WRITE_CONTROL_DISPLAY;\n\totm8009a_dcs_write_buf(ctx, data, ARRAY_SIZE(data));\n\n\treturn 0;\n}\n\nstatic const struct backlight_ops otm8009a_backlight_ops = {\n\t.update_status = otm8009a_backlight_update_status,\n};\n\nstatic int otm8009a_probe(struct mipi_dsi_device *dsi)\n{\n\tstruct device *dev = &dsi->dev;\n\tstruct otm8009a *ctx;\n\tint ret;\n\n\tctx = devm_kzalloc(dev, sizeof(*ctx), GFP_KERNEL);\n\tif (!ctx)\n\t\treturn -ENOMEM;\n\n\tctx->reset_gpio = devm_gpiod_get_optional(dev, \"reset\", GPIOD_OUT_LOW);\n\tif (IS_ERR(ctx->reset_gpio)) {\n\t\tdev_err(dev, \"cannot get reset-gpio\\n\");\n\t\treturn PTR_ERR(ctx->reset_gpio);\n\t}\n\n\tctx->supply = devm_regulator_get(dev, \"power\");\n\tif (IS_ERR(ctx->supply)) {\n\t\tret = PTR_ERR(ctx->supply);\n\t\tif (ret != -EPROBE_DEFER)\n\t\t\tdev_err(dev, \"failed to request regulator: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tmipi_dsi_set_drvdata(dsi, ctx);\n\n\tctx->dev = dev;\n\n\tdsi->lanes = 2;\n\tdsi->format = MIPI_DSI_FMT_RGB888;\n\tdsi->mode_flags = MIPI_DSI_MODE_VIDEO | MIPI_DSI_MODE_VIDEO_BURST |\n\t\t\t  MIPI_DSI_MODE_LPM | MIPI_DSI_CLOCK_NON_CONTINUOUS;\n\n\tdrm_panel_init(&ctx->panel, dev, &otm8009a_drm_funcs,\n\t\t       DRM_MODE_CONNECTOR_DSI);\n\n\tctx->bl_dev = devm_backlight_device_register(dev, dev_name(dev),\n\t\t\t\t\t\t     dev, ctx,\n\t\t\t\t\t\t     &otm8009a_backlight_ops,\n\t\t\t\t\t\t     NULL);\n\tif (IS_ERR(ctx->bl_dev)) {\n\t\tret = PTR_ERR(ctx->bl_dev);\n\t\tdev_err(dev, \"failed to register backlight: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tctx->bl_dev->props.max_brightness = OTM8009A_BACKLIGHT_MAX;\n\tctx->bl_dev->props.brightness = OTM8009A_BACKLIGHT_DEFAULT;\n\tctx->bl_dev->props.power = FB_BLANK_POWERDOWN;\n\tctx->bl_dev->props.type = BACKLIGHT_RAW;\n\n\tdrm_panel_add(&ctx->panel);\n\n\tret = mipi_dsi_attach(dsi);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"mipi_dsi_attach failed. Is host ready?\\n\");\n\t\tdrm_panel_remove(&ctx->panel);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic void otm8009a_remove(struct mipi_dsi_device *dsi)\n{\n\tstruct otm8009a *ctx = mipi_dsi_get_drvdata(dsi);\n\n\tmipi_dsi_detach(dsi);\n\tdrm_panel_remove(&ctx->panel);\n}\n\nstatic const struct of_device_id orisetech_otm8009a_of_match[] = {\n\t{ .compatible = \"orisetech,otm8009a\" },\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, orisetech_otm8009a_of_match);\n\nstatic struct mipi_dsi_driver orisetech_otm8009a_driver = {\n\t.probe  = otm8009a_probe,\n\t.remove = otm8009a_remove,\n\t.driver = {\n\t\t.name = \"panel-orisetech-otm8009a\",\n\t\t.of_match_table = orisetech_otm8009a_of_match,\n\t},\n};\nmodule_mipi_dsi_driver(orisetech_otm8009a_driver);\n\nMODULE_AUTHOR(\"Philippe Cornu <philippe.cornu@st.com>\");\nMODULE_AUTHOR(\"Yannick Fertre <yannick.fertre@st.com>\");\nMODULE_DESCRIPTION(\"DRM driver for Orise Tech OTM8009A MIPI DSI panel\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}