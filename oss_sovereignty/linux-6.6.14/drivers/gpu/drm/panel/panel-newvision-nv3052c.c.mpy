{
  "module_name": "panel-newvision-nv3052c.c",
  "hash_id": "db50af5133682498b76adbfe4f499d9fd054dc12fd3f891949932cbfe58cec6d",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/panel/panel-newvision-nv3052c.c",
  "human_readable_source": "\n \n\n#include <linux/delay.h>\n#include <linux/device.h>\n#include <linux/gpio/consumer.h>\n#include <linux/media-bus-format.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/regulator/consumer.h>\n#include <linux/spi/spi.h>\n#include <video/mipi_display.h>\n#include <drm/drm_mipi_dbi.h>\n#include <drm/drm_modes.h>\n#include <drm/drm_panel.h>\n\nstruct nv3052c_panel_info {\n\tconst struct drm_display_mode *display_modes;\n\tunsigned int num_modes;\n\tu16 width_mm, height_mm;\n\tu32 bus_format, bus_flags;\n};\n\nstruct nv3052c {\n\tstruct device *dev;\n\tstruct drm_panel panel;\n\tstruct mipi_dbi dbi;\n\tconst struct nv3052c_panel_info *panel_info;\n\tstruct regulator *supply;\n\tstruct gpio_desc *reset_gpio;\n};\n\nstruct nv3052c_reg {\n\tu8 cmd;\n\tu8 val;\n};\n\nstatic const struct nv3052c_reg nv3052c_panel_regs[] = {\n\t{ 0xff, 0x30 },\n\t{ 0xff, 0x52 },\n\t{ 0xff, 0x01 },\n\t{ 0xe3, 0x00 },\n\t{ 0x40, 0x00 },\n\t{ 0x03, 0x40 },\n\t{ 0x04, 0x00 },\n\t{ 0x05, 0x03 },\n\t{ 0x08, 0x00 },\n\t{ 0x09, 0x07 },\n\t{ 0x0a, 0x01 },\n\t{ 0x0b, 0x32 },\n\t{ 0x0c, 0x32 },\n\t{ 0x0d, 0x0b },\n\t{ 0x0e, 0x00 },\n\t{ 0x23, 0xa0 },\n\t{ 0x24, 0x0c },\n\t{ 0x25, 0x06 },\n\t{ 0x26, 0x14 },\n\t{ 0x27, 0x14 },\n\t{ 0x38, 0xcc },\n\t{ 0x39, 0xd7 },\n\t{ 0x3a, 0x4a },\n\t{ 0x28, 0x40 },\n\t{ 0x29, 0x01 },\n\t{ 0x2a, 0xdf },\n\t{ 0x49, 0x3c },\n\t{ 0x91, 0x77 },\n\t{ 0x92, 0x77 },\n\t{ 0xa0, 0x55 },\n\t{ 0xa1, 0x50 },\n\t{ 0xa4, 0x9c },\n\t{ 0xa7, 0x02 },\n\t{ 0xa8, 0x01 },\n\t{ 0xa9, 0x01 },\n\t{ 0xaa, 0xfc },\n\t{ 0xab, 0x28 },\n\t{ 0xac, 0x06 },\n\t{ 0xad, 0x06 },\n\t{ 0xae, 0x06 },\n\t{ 0xaf, 0x03 },\n\t{ 0xb0, 0x08 },\n\t{ 0xb1, 0x26 },\n\t{ 0xb2, 0x28 },\n\t{ 0xb3, 0x28 },\n\t{ 0xb4, 0x33 },\n\t{ 0xb5, 0x08 },\n\t{ 0xb6, 0x26 },\n\t{ 0xb7, 0x08 },\n\t{ 0xb8, 0x26 },\n\t{ 0xf0, 0x00 },\n\t{ 0xf6, 0xc0 },\n\t{ 0xff, 0x30 },\n\t{ 0xff, 0x52 },\n\t{ 0xff, 0x02 },\n\t{ 0xb0, 0x0b },\n\t{ 0xb1, 0x16 },\n\t{ 0xb2, 0x17 },\n\t{ 0xb3, 0x2c },\n\t{ 0xb4, 0x32 },\n\t{ 0xb5, 0x3b },\n\t{ 0xb6, 0x29 },\n\t{ 0xb7, 0x40 },\n\t{ 0xb8, 0x0d },\n\t{ 0xb9, 0x05 },\n\t{ 0xba, 0x12 },\n\t{ 0xbb, 0x10 },\n\t{ 0xbc, 0x12 },\n\t{ 0xbd, 0x15 },\n\t{ 0xbe, 0x19 },\n\t{ 0xbf, 0x0e },\n\t{ 0xc0, 0x16 },\n\t{ 0xc1, 0x0a },\n\t{ 0xd0, 0x0c },\n\t{ 0xd1, 0x17 },\n\t{ 0xd2, 0x14 },\n\t{ 0xd3, 0x2e },\n\t{ 0xd4, 0x32 },\n\t{ 0xd5, 0x3c },\n\t{ 0xd6, 0x22 },\n\t{ 0xd7, 0x3d },\n\t{ 0xd8, 0x0d },\n\t{ 0xd9, 0x07 },\n\t{ 0xda, 0x13 },\n\t{ 0xdb, 0x13 },\n\t{ 0xdc, 0x11 },\n\t{ 0xdd, 0x15 },\n\t{ 0xde, 0x19 },\n\t{ 0xdf, 0x10 },\n\t{ 0xe0, 0x17 },\n\t{ 0xe1, 0x0a },\n\t{ 0xff, 0x30 },\n\t{ 0xff, 0x52 },\n\t{ 0xff, 0x03 },\n\t{ 0x00, 0x2a },\n\t{ 0x01, 0x2a },\n\t{ 0x02, 0x2a },\n\t{ 0x03, 0x2a },\n\t{ 0x04, 0x61 },\n\t{ 0x05, 0x80 },\n\t{ 0x06, 0xc7 },\n\t{ 0x07, 0x01 },\n\t{ 0x08, 0x03 },\n\t{ 0x09, 0x04 },\n\t{ 0x70, 0x22 },\n\t{ 0x71, 0x80 },\n\t{ 0x30, 0x2a },\n\t{ 0x31, 0x2a },\n\t{ 0x32, 0x2a },\n\t{ 0x33, 0x2a },\n\t{ 0x34, 0x61 },\n\t{ 0x35, 0xc5 },\n\t{ 0x36, 0x80 },\n\t{ 0x37, 0x23 },\n\t{ 0x40, 0x03 },\n\t{ 0x41, 0x04 },\n\t{ 0x42, 0x05 },\n\t{ 0x43, 0x06 },\n\t{ 0x44, 0x11 },\n\t{ 0x45, 0xe8 },\n\t{ 0x46, 0xe9 },\n\t{ 0x47, 0x11 },\n\t{ 0x48, 0xea },\n\t{ 0x49, 0xeb },\n\t{ 0x50, 0x07 },\n\t{ 0x51, 0x08 },\n\t{ 0x52, 0x09 },\n\t{ 0x53, 0x0a },\n\t{ 0x54, 0x11 },\n\t{ 0x55, 0xec },\n\t{ 0x56, 0xed },\n\t{ 0x57, 0x11 },\n\t{ 0x58, 0xef },\n\t{ 0x59, 0xf0 },\n\t{ 0xb1, 0x01 },\n\t{ 0xb4, 0x15 },\n\t{ 0xb5, 0x16 },\n\t{ 0xb6, 0x09 },\n\t{ 0xb7, 0x0f },\n\t{ 0xb8, 0x0d },\n\t{ 0xb9, 0x0b },\n\t{ 0xba, 0x00 },\n\t{ 0xc7, 0x02 },\n\t{ 0xca, 0x17 },\n\t{ 0xcb, 0x18 },\n\t{ 0xcc, 0x0a },\n\t{ 0xcd, 0x10 },\n\t{ 0xce, 0x0e },\n\t{ 0xcf, 0x0c },\n\t{ 0xd0, 0x00 },\n\t{ 0x81, 0x00 },\n\t{ 0x84, 0x15 },\n\t{ 0x85, 0x16 },\n\t{ 0x86, 0x10 },\n\t{ 0x87, 0x0a },\n\t{ 0x88, 0x0c },\n\t{ 0x89, 0x0e },\n\t{ 0x8a, 0x02 },\n\t{ 0x97, 0x00 },\n\t{ 0x9a, 0x17 },\n\t{ 0x9b, 0x18 },\n\t{ 0x9c, 0x0f },\n\t{ 0x9d, 0x09 },\n\t{ 0x9e, 0x0b },\n\t{ 0x9f, 0x0d },\n\t{ 0xa0, 0x01 },\n\t{ 0xff, 0x30 },\n\t{ 0xff, 0x52 },\n\t{ 0xff, 0x02 },\n\t{ 0x01, 0x01 },\n\t{ 0x02, 0xda },\n\t{ 0x03, 0xba },\n\t{ 0x04, 0xa8 },\n\t{ 0x05, 0x9a },\n\t{ 0x06, 0x70 },\n\t{ 0x07, 0xff },\n\t{ 0x08, 0x91 },\n\t{ 0x09, 0x90 },\n\t{ 0x0a, 0xff },\n\t{ 0x0b, 0x8f },\n\t{ 0x0c, 0x60 },\n\t{ 0x0d, 0x58 },\n\t{ 0x0e, 0x48 },\n\t{ 0x0f, 0x38 },\n\t{ 0x10, 0x2b },\n\t{ 0xff, 0x30 },\n\t{ 0xff, 0x52 },\n\t{ 0xff, 0x00 },\n\t{ 0x36, 0x0a },\n};\n\nstatic inline struct nv3052c *to_nv3052c(struct drm_panel *panel)\n{\n\treturn container_of(panel, struct nv3052c, panel);\n}\n\nstatic int nv3052c_prepare(struct drm_panel *panel)\n{\n\tstruct nv3052c *priv = to_nv3052c(panel);\n\tstruct mipi_dbi *dbi = &priv->dbi;\n\tunsigned int i;\n\tint err;\n\n\terr = regulator_enable(priv->supply);\n\tif (err) {\n\t\tdev_err(priv->dev, \"Failed to enable power supply: %d\\n\", err);\n\t\treturn err;\n\t}\n\n\t \n\tgpiod_set_value_cansleep(priv->reset_gpio, 1);\n\tusleep_range(10, 1000);\n\tgpiod_set_value_cansleep(priv->reset_gpio, 0);\n\tusleep_range(5000, 20000);\n\n\tfor (i = 0; i < ARRAY_SIZE(nv3052c_panel_regs); i++) {\n\t\terr = mipi_dbi_command(dbi, nv3052c_panel_regs[i].cmd,\n\t\t\t\t       nv3052c_panel_regs[i].val);\n\n\t\tif (err) {\n\t\t\tdev_err(priv->dev, \"Unable to set register: %d\\n\", err);\n\t\t\tgoto err_disable_regulator;\n\t\t}\n\t}\n\n\terr = mipi_dbi_command(dbi, MIPI_DCS_EXIT_SLEEP_MODE);\n\tif (err) {\n\t\tdev_err(priv->dev, \"Unable to exit sleep mode: %d\\n\", err);\n\t\tgoto err_disable_regulator;\n\t}\n\n\treturn 0;\n\nerr_disable_regulator:\n\tregulator_disable(priv->supply);\n\treturn err;\n}\n\nstatic int nv3052c_unprepare(struct drm_panel *panel)\n{\n\tstruct nv3052c *priv = to_nv3052c(panel);\n\tstruct mipi_dbi *dbi = &priv->dbi;\n\tint err;\n\n\terr = mipi_dbi_command(dbi, MIPI_DCS_ENTER_SLEEP_MODE);\n\tif (err)\n\t\tdev_err(priv->dev, \"Unable to enter sleep mode: %d\\n\", err);\n\n\tgpiod_set_value_cansleep(priv->reset_gpio, 1);\n\tregulator_disable(priv->supply);\n\n\treturn 0;\n}\n\nstatic int nv3052c_enable(struct drm_panel *panel)\n{\n\tstruct nv3052c *priv = to_nv3052c(panel);\n\tstruct mipi_dbi *dbi = &priv->dbi;\n\tint err;\n\n\terr = mipi_dbi_command(dbi, MIPI_DCS_SET_DISPLAY_ON);\n\tif (err) {\n\t\tdev_err(priv->dev, \"Unable to enable display: %d\\n\", err);\n\t\treturn err;\n\t}\n\n\tif (panel->backlight) {\n\t\t \n\t\tmsleep(120);\n\t}\n\n\treturn 0;\n}\n\nstatic int nv3052c_disable(struct drm_panel *panel)\n{\n\tstruct nv3052c *priv = to_nv3052c(panel);\n\tstruct mipi_dbi *dbi = &priv->dbi;\n\tint err;\n\n\terr = mipi_dbi_command(dbi, MIPI_DCS_SET_DISPLAY_OFF);\n\tif (err) {\n\t\tdev_err(priv->dev, \"Unable to disable display: %d\\n\", err);\n\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\nstatic int nv3052c_get_modes(struct drm_panel *panel,\n\t\t\t     struct drm_connector *connector)\n{\n\tstruct nv3052c *priv = to_nv3052c(panel);\n\tconst struct nv3052c_panel_info *panel_info = priv->panel_info;\n\tstruct drm_display_mode *mode;\n\tunsigned int i;\n\n\tfor (i = 0; i < panel_info->num_modes; i++) {\n\t\tmode = drm_mode_duplicate(connector->dev,\n\t\t\t\t\t  &panel_info->display_modes[i]);\n\t\tif (!mode)\n\t\t\treturn -ENOMEM;\n\n\t\tdrm_mode_set_name(mode);\n\n\t\tmode->type = DRM_MODE_TYPE_DRIVER;\n\t\tif (panel_info->num_modes == 1)\n\t\t\tmode->type |= DRM_MODE_TYPE_PREFERRED;\n\n\t\tdrm_mode_probed_add(connector, mode);\n\t}\n\n\tconnector->display_info.bpc = 8;\n\tconnector->display_info.width_mm = panel_info->width_mm;\n\tconnector->display_info.height_mm = panel_info->height_mm;\n\n\tdrm_display_info_set_bus_formats(&connector->display_info,\n\t\t\t\t\t &panel_info->bus_format, 1);\n\tconnector->display_info.bus_flags = panel_info->bus_flags;\n\n\treturn panel_info->num_modes;\n}\n\nstatic const struct drm_panel_funcs nv3052c_funcs = {\n\t.prepare\t= nv3052c_prepare,\n\t.unprepare\t= nv3052c_unprepare,\n\t.enable\t\t= nv3052c_enable,\n\t.disable\t= nv3052c_disable,\n\t.get_modes\t= nv3052c_get_modes,\n};\n\nstatic int nv3052c_probe(struct spi_device *spi)\n{\n\tstruct device *dev = &spi->dev;\n\tstruct nv3052c *priv;\n\tint err;\n\n\tpriv = devm_kzalloc(dev, sizeof(*priv), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\n\tpriv->dev = dev;\n\n\tpriv->panel_info = of_device_get_match_data(dev);\n\tif (!priv->panel_info)\n\t\treturn -EINVAL;\n\n\tpriv->supply = devm_regulator_get(dev, \"power\");\n\tif (IS_ERR(priv->supply))\n\t\treturn dev_err_probe(dev, PTR_ERR(priv->supply), \"Failed to get power supply\\n\");\n\n\tpriv->reset_gpio = devm_gpiod_get(dev, \"reset\", GPIOD_OUT_HIGH);\n\tif (IS_ERR(priv->reset_gpio))\n\t\treturn dev_err_probe(dev, PTR_ERR(priv->reset_gpio), \"Failed to get reset GPIO\\n\");\n\n\terr = mipi_dbi_spi_init(spi, &priv->dbi, NULL);\n\tif (err)\n\t\treturn dev_err_probe(dev, err, \"MIPI DBI init failed\\n\");\n\n\tpriv->dbi.read_commands = NULL;\n\n\tspi_set_drvdata(spi, priv);\n\n\tdrm_panel_init(&priv->panel, dev, &nv3052c_funcs,\n\t\t       DRM_MODE_CONNECTOR_DPI);\n\n\terr = drm_panel_of_backlight(&priv->panel);\n\tif (err)\n\t\treturn dev_err_probe(dev, err, \"Failed to attach backlight\\n\");\n\n\tdrm_panel_add(&priv->panel);\n\n\treturn 0;\n}\n\nstatic void nv3052c_remove(struct spi_device *spi)\n{\n\tstruct nv3052c *priv = spi_get_drvdata(spi);\n\n\tdrm_panel_remove(&priv->panel);\n\tdrm_panel_disable(&priv->panel);\n\tdrm_panel_unprepare(&priv->panel);\n}\n\nstatic const struct drm_display_mode ltk035c5444t_modes[] = {\n\t{  \n\t\t.clock = 24000,\n\t\t.hdisplay = 640,\n\t\t.hsync_start = 640 + 96,\n\t\t.hsync_end = 640 + 96 + 16,\n\t\t.htotal = 640 + 96 + 16 + 48,\n\t\t.vdisplay = 480,\n\t\t.vsync_start = 480 + 5,\n\t\t.vsync_end = 480 + 5 + 2,\n\t\t.vtotal = 480 + 5 + 2 + 13,\n\t\t.flags = DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_NVSYNC,\n\t},\n\t{  \n\t\t.clock = 18000,\n\t\t.hdisplay = 640,\n\t\t.hsync_start = 640 + 39,\n\t\t.hsync_end = 640 + 39 + 2,\n\t\t.htotal = 640 + 39 + 2 + 39,\n\t\t.vdisplay = 480,\n\t\t.vsync_start = 480 + 5,\n\t\t.vsync_end = 480 + 5 + 2,\n\t\t.vtotal = 480 + 5 + 2 + 13,\n\t\t.flags = DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_NVSYNC,\n\t},\n};\n\nstatic const struct nv3052c_panel_info ltk035c5444t_panel_info = {\n\t.display_modes = ltk035c5444t_modes,\n\t.num_modes = ARRAY_SIZE(ltk035c5444t_modes),\n\t.width_mm = 77,\n\t.height_mm = 64,\n\t.bus_format = MEDIA_BUS_FMT_RGB888_1X24,\n\t.bus_flags = DRM_BUS_FLAG_DE_HIGH | DRM_BUS_FLAG_PIXDATA_DRIVE_NEGEDGE,\n};\n\nstatic const struct of_device_id nv3052c_of_match[] = {\n\t{ .compatible = \"leadtek,ltk035c5444t\", .data = &ltk035c5444t_panel_info },\n\t{   }\n};\nMODULE_DEVICE_TABLE(of, nv3052c_of_match);\n\nstatic struct spi_driver nv3052c_driver = {\n\t.driver = {\n\t\t.name = \"nv3052c\",\n\t\t.of_match_table = nv3052c_of_match,\n\t},\n\t.probe = nv3052c_probe,\n\t.remove = nv3052c_remove,\n};\nmodule_spi_driver(nv3052c_driver);\n\nMODULE_AUTHOR(\"Paul Cercueil <paul@crapouillou.net>\");\nMODULE_AUTHOR(\"Christophe Branchereau <cbranchereau@gmail.com>\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}