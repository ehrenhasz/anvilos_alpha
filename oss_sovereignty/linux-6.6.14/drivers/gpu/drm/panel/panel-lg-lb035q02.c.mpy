{
  "module_name": "panel-lg-lb035q02.c",
  "hash_id": "97c996423044ea42a544344eaa9cf113bbf63142cc4275b92a75d56694069b6a",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/panel/panel-lg-lb035q02.c",
  "human_readable_source": "\n \n\n#include <linux/gpio/consumer.h>\n#include <linux/module.h>\n#include <linux/spi/spi.h>\n\n#include <drm/drm_connector.h>\n#include <drm/drm_modes.h>\n#include <drm/drm_panel.h>\n\nstruct lb035q02_device {\n\tstruct drm_panel panel;\n\n\tstruct spi_device *spi;\n\tstruct gpio_desc *enable_gpio;\n};\n\n#define to_lb035q02_device(p) container_of(p, struct lb035q02_device, panel)\n\nstatic int lb035q02_write(struct lb035q02_device *lcd, u16 reg, u16 val)\n{\n\tstruct spi_message msg;\n\tstruct spi_transfer index_xfer = {\n\t\t.len\t\t= 3,\n\t\t.cs_change\t= 1,\n\t};\n\tstruct spi_transfer value_xfer = {\n\t\t.len\t\t= 3,\n\t};\n\tu8\tbuffer[16];\n\n\tspi_message_init(&msg);\n\n\t \n\tbuffer[0] = 0x70;\n\tbuffer[1] = 0x00;\n\tbuffer[2] = reg & 0x7f;\n\tindex_xfer.tx_buf = buffer;\n\tspi_message_add_tail(&index_xfer, &msg);\n\n\t \n\tbuffer[4] = 0x72;\n\tbuffer[5] = val >> 8;\n\tbuffer[6] = val;\n\tvalue_xfer.tx_buf = buffer + 4;\n\tspi_message_add_tail(&value_xfer, &msg);\n\n\treturn spi_sync(lcd->spi, &msg);\n}\n\nstatic int lb035q02_init(struct lb035q02_device *lcd)\n{\n\t \n\tstatic const struct {\n\t\tu16 index;\n\t\tu16 value;\n\t} init_data[] = {\n\t\t{ 0x01, 0x6300 },\n\t\t{ 0x02, 0x0200 },\n\t\t{ 0x03, 0x0177 },\n\t\t{ 0x04, 0x04c7 },\n\t\t{ 0x05, 0xffc0 },\n\t\t{ 0x06, 0xe806 },\n\t\t{ 0x0a, 0x4008 },\n\t\t{ 0x0b, 0x0000 },\n\t\t{ 0x0d, 0x0030 },\n\t\t{ 0x0e, 0x2800 },\n\t\t{ 0x0f, 0x0000 },\n\t\t{ 0x16, 0x9f80 },\n\t\t{ 0x17, 0x0a0f },\n\t\t{ 0x1e, 0x00c1 },\n\t\t{ 0x30, 0x0300 },\n\t\t{ 0x31, 0x0007 },\n\t\t{ 0x32, 0x0000 },\n\t\t{ 0x33, 0x0000 },\n\t\t{ 0x34, 0x0707 },\n\t\t{ 0x35, 0x0004 },\n\t\t{ 0x36, 0x0302 },\n\t\t{ 0x37, 0x0202 },\n\t\t{ 0x3a, 0x0a0d },\n\t\t{ 0x3b, 0x0806 },\n\t};\n\n\tunsigned int i;\n\tint ret;\n\n\tfor (i = 0; i < ARRAY_SIZE(init_data); ++i) {\n\t\tret = lb035q02_write(lcd, init_data[i].index,\n\t\t\t\t     init_data[i].value);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int lb035q02_disable(struct drm_panel *panel)\n{\n\tstruct lb035q02_device *lcd = to_lb035q02_device(panel);\n\n\tgpiod_set_value_cansleep(lcd->enable_gpio, 0);\n\n\treturn 0;\n}\n\nstatic int lb035q02_enable(struct drm_panel *panel)\n{\n\tstruct lb035q02_device *lcd = to_lb035q02_device(panel);\n\n\tgpiod_set_value_cansleep(lcd->enable_gpio, 1);\n\n\treturn 0;\n}\n\nstatic const struct drm_display_mode lb035q02_mode = {\n\t.clock = 6500,\n\t.hdisplay = 320,\n\t.hsync_start = 320 + 20,\n\t.hsync_end = 320 + 20 + 2,\n\t.htotal = 320 + 20 + 2 + 68,\n\t.vdisplay = 240,\n\t.vsync_start = 240 + 4,\n\t.vsync_end = 240 + 4 + 2,\n\t.vtotal = 240 + 4 + 2 + 18,\n\t.type = DRM_MODE_TYPE_DRIVER | DRM_MODE_TYPE_PREFERRED,\n\t.flags = DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_NVSYNC,\n\t.width_mm = 70,\n\t.height_mm = 53,\n};\n\nstatic int lb035q02_get_modes(struct drm_panel *panel,\n\t\t\t      struct drm_connector *connector)\n{\n\tstruct drm_display_mode *mode;\n\n\tmode = drm_mode_duplicate(connector->dev, &lb035q02_mode);\n\tif (!mode)\n\t\treturn -ENOMEM;\n\n\tdrm_mode_set_name(mode);\n\tdrm_mode_probed_add(connector, mode);\n\n\tconnector->display_info.width_mm = lb035q02_mode.width_mm;\n\tconnector->display_info.height_mm = lb035q02_mode.height_mm;\n\t \n\tconnector->display_info.bus_flags = DRM_BUS_FLAG_DE_HIGH\n\t\t\t\t\t  | DRM_BUS_FLAG_SYNC_SAMPLE_POSEDGE\n\t\t\t\t\t  | DRM_BUS_FLAG_PIXDATA_SAMPLE_NEGEDGE;\n\n\treturn 1;\n}\n\nstatic const struct drm_panel_funcs lb035q02_funcs = {\n\t.disable = lb035q02_disable,\n\t.enable = lb035q02_enable,\n\t.get_modes = lb035q02_get_modes,\n};\n\nstatic int lb035q02_probe(struct spi_device *spi)\n{\n\tstruct lb035q02_device *lcd;\n\tint ret;\n\n\tlcd = devm_kzalloc(&spi->dev, sizeof(*lcd), GFP_KERNEL);\n\tif (!lcd)\n\t\treturn -ENOMEM;\n\n\tspi_set_drvdata(spi, lcd);\n\tlcd->spi = spi;\n\n\tlcd->enable_gpio = devm_gpiod_get(&spi->dev, \"enable\", GPIOD_OUT_LOW);\n\tif (IS_ERR(lcd->enable_gpio)) {\n\t\tdev_err(&spi->dev, \"failed to parse enable gpio\\n\");\n\t\treturn PTR_ERR(lcd->enable_gpio);\n\t}\n\n\tret = lb035q02_init(lcd);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tdrm_panel_init(&lcd->panel, &lcd->spi->dev, &lb035q02_funcs,\n\t\t       DRM_MODE_CONNECTOR_DPI);\n\n\tdrm_panel_add(&lcd->panel);\n\n\treturn 0;\n}\n\nstatic void lb035q02_remove(struct spi_device *spi)\n{\n\tstruct lb035q02_device *lcd = spi_get_drvdata(spi);\n\n\tdrm_panel_remove(&lcd->panel);\n\tdrm_panel_disable(&lcd->panel);\n}\n\nstatic const struct of_device_id lb035q02_of_match[] = {\n\t{ .compatible = \"lgphilips,lb035q02\", },\n\t{   },\n};\n\nMODULE_DEVICE_TABLE(of, lb035q02_of_match);\n\nstatic const struct spi_device_id lb035q02_ids[] = {\n\t{ \"lb035q02\", 0 },\n\t{   }\n};\n\nMODULE_DEVICE_TABLE(spi, lb035q02_ids);\n\nstatic struct spi_driver lb035q02_driver = {\n\t.probe\t\t= lb035q02_probe,\n\t.remove\t\t= lb035q02_remove,\n\t.id_table\t= lb035q02_ids,\n\t.driver\t\t= {\n\t\t.name\t= \"panel-lg-lb035q02\",\n\t\t.of_match_table = lb035q02_of_match,\n\t},\n};\n\nmodule_spi_driver(lb035q02_driver);\n\nMODULE_AUTHOR(\"Tomi Valkeinen <tomi.valkeinen@ti.com>\");\nMODULE_DESCRIPTION(\"LG.Philips LB035Q02 LCD Panel driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}