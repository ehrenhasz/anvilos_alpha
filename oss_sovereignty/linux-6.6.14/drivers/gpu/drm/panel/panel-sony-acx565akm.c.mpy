{
  "module_name": "panel-sony-acx565akm.c",
  "hash_id": "5ad17257ff3c1b7efd00dceb6e2aa2ba0c70f317ea2657700f53cf3d6289769c",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/panel/panel-sony-acx565akm.c",
  "human_readable_source": "\n \n\n \n\n#include <linux/backlight.h>\n#include <linux/delay.h>\n#include <linux/gpio/consumer.h>\n#include <linux/jiffies.h>\n#include <linux/module.h>\n#include <linux/mutex.h>\n#include <linux/sched.h>\n#include <linux/spi/spi.h>\n#include <video/mipi_display.h>\n\n#include <drm/drm_connector.h>\n#include <drm/drm_modes.h>\n#include <drm/drm_panel.h>\n\n#define CTRL_DISP_BRIGHTNESS_CTRL_ON\t\tBIT(5)\n#define CTRL_DISP_AMBIENT_LIGHT_CTRL_ON\t\tBIT(4)\n#define CTRL_DISP_BACKLIGHT_ON\t\t\tBIT(2)\n#define CTRL_DISP_AUTO_BRIGHTNESS_ON\t\tBIT(1)\n\n#define MIPID_CMD_WRITE_CABC\t\t0x55\n#define MIPID_CMD_READ_CABC\t\t0x56\n\n#define MIPID_VER_LPH8923\t\t3\n#define MIPID_VER_LS041Y3\t\t4\n#define MIPID_VER_L4F00311\t\t8\n#define MIPID_VER_ACX565AKM\t\t9\n\nstruct acx565akm_panel {\n\tstruct drm_panel panel;\n\n\tstruct spi_device *spi;\n\tstruct gpio_desc *reset_gpio;\n\tstruct backlight_device *backlight;\n\n\tstruct mutex mutex;\n\n\tconst char *name;\n\tu8 display_id[3];\n\tint model;\n\tint revision;\n\tbool has_bc;\n\tbool has_cabc;\n\n\tbool enabled;\n\tunsigned int cabc_mode;\n\t \n\tunsigned long hw_guard_end;\n\tunsigned long hw_guard_wait;\t\t \n};\n\n#define to_acx565akm_device(p) container_of(p, struct acx565akm_panel, panel)\n\nstatic void acx565akm_transfer(struct acx565akm_panel *lcd, int cmd,\n\t\t\t      const u8 *wbuf, int wlen, u8 *rbuf, int rlen)\n{\n\tstruct spi_message\tm;\n\tstruct spi_transfer\t*x, xfer[5];\n\tint\t\t\tret;\n\n\tspi_message_init(&m);\n\n\tmemset(xfer, 0, sizeof(xfer));\n\tx = &xfer[0];\n\n\tcmd &=  0xff;\n\tx->tx_buf = &cmd;\n\tx->bits_per_word = 9;\n\tx->len = 2;\n\n\tif (rlen > 1 && wlen == 0) {\n\t\t \n\t\tx->bits_per_word = 10;\n\t\tcmd <<= 1;\n\t}\n\tspi_message_add_tail(x, &m);\n\n\tif (wlen) {\n\t\tx++;\n\t\tx->tx_buf = wbuf;\n\t\tx->len = wlen;\n\t\tx->bits_per_word = 9;\n\t\tspi_message_add_tail(x, &m);\n\t}\n\n\tif (rlen) {\n\t\tx++;\n\t\tx->rx_buf\t= rbuf;\n\t\tx->len\t\t= rlen;\n\t\tspi_message_add_tail(x, &m);\n\t}\n\n\tret = spi_sync(lcd->spi, &m);\n\tif (ret < 0)\n\t\tdev_dbg(&lcd->spi->dev, \"spi_sync %d\\n\", ret);\n}\n\nstatic inline void acx565akm_cmd(struct acx565akm_panel *lcd, int cmd)\n{\n\tacx565akm_transfer(lcd, cmd, NULL, 0, NULL, 0);\n}\n\nstatic inline void acx565akm_write(struct acx565akm_panel *lcd,\n\t\t\t       int reg, const u8 *buf, int len)\n{\n\tacx565akm_transfer(lcd, reg, buf, len, NULL, 0);\n}\n\nstatic inline void acx565akm_read(struct acx565akm_panel *lcd,\n\t\t\t      int reg, u8 *buf, int len)\n{\n\tacx565akm_transfer(lcd, reg, NULL, 0, buf, len);\n}\n\n \n\nstatic unsigned int acx565akm_get_cabc_mode(struct acx565akm_panel *lcd)\n{\n\treturn lcd->cabc_mode;\n}\n\nstatic void acx565akm_set_cabc_mode(struct acx565akm_panel *lcd,\n\t\t\t\t    unsigned int mode)\n{\n\tu16 cabc_ctrl;\n\n\tlcd->cabc_mode = mode;\n\tif (!lcd->enabled)\n\t\treturn;\n\tcabc_ctrl = 0;\n\tacx565akm_read(lcd, MIPID_CMD_READ_CABC, (u8 *)&cabc_ctrl, 1);\n\tcabc_ctrl &= ~3;\n\tcabc_ctrl |= (1 << 8) | (mode & 3);\n\tacx565akm_write(lcd, MIPID_CMD_WRITE_CABC, (u8 *)&cabc_ctrl, 2);\n}\n\nstatic unsigned int acx565akm_get_hw_cabc_mode(struct acx565akm_panel *lcd)\n{\n\tu8 cabc_ctrl;\n\n\tacx565akm_read(lcd, MIPID_CMD_READ_CABC, &cabc_ctrl, 1);\n\treturn cabc_ctrl & 3;\n}\n\nstatic const char * const acx565akm_cabc_modes[] = {\n\t\"off\",\t\t \n\t\"ui\",\n\t\"still-image\",\n\t\"moving-image\",\n};\n\nstatic ssize_t cabc_mode_show(struct device *dev,\n\t\t\t      struct device_attribute *attr,\n\t\t\t      char *buf)\n{\n\tstruct acx565akm_panel *lcd = dev_get_drvdata(dev);\n\tconst char *mode_str;\n\tint mode;\n\n\tif (!lcd->has_cabc)\n\t\tmode = 0;\n\telse\n\t\tmode = acx565akm_get_cabc_mode(lcd);\n\n\tmode_str = \"unknown\";\n\tif (mode >= 0 && mode < ARRAY_SIZE(acx565akm_cabc_modes))\n\t\tmode_str = acx565akm_cabc_modes[mode];\n\n\treturn sprintf(buf, \"%s\\n\", mode_str);\n}\n\nstatic ssize_t cabc_mode_store(struct device *dev,\n\t\t\t       struct device_attribute *attr,\n\t\t\t       const char *buf, size_t count)\n{\n\tstruct acx565akm_panel *lcd = dev_get_drvdata(dev);\n\tunsigned int i;\n\n\tfor (i = 0; i < ARRAY_SIZE(acx565akm_cabc_modes); i++) {\n\t\tconst char *mode_str = acx565akm_cabc_modes[i];\n\t\tint cmp_len = strlen(mode_str);\n\n\t\tif (count > 0 && buf[count - 1] == '\\n')\n\t\t\tcount--;\n\t\tif (count != cmp_len)\n\t\t\tcontinue;\n\n\t\tif (strncmp(buf, mode_str, cmp_len) == 0)\n\t\t\tbreak;\n\t}\n\n\tif (i == ARRAY_SIZE(acx565akm_cabc_modes))\n\t\treturn -EINVAL;\n\n\tif (!lcd->has_cabc && i != 0)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&lcd->mutex);\n\tacx565akm_set_cabc_mode(lcd, i);\n\tmutex_unlock(&lcd->mutex);\n\n\treturn count;\n}\n\nstatic ssize_t cabc_available_modes_show(struct device *dev,\n\t\t\t\t\t struct device_attribute *attr,\n\t\t\t\t\t char *buf)\n{\n\tstruct acx565akm_panel *lcd = dev_get_drvdata(dev);\n\tunsigned int i;\n\tsize_t len = 0;\n\n\tif (!lcd->has_cabc)\n\t\treturn sprintf(buf, \"%s\\n\", acx565akm_cabc_modes[0]);\n\n\tfor (i = 0; i < ARRAY_SIZE(acx565akm_cabc_modes); i++)\n\t\tlen += sprintf(&buf[len], \"%s%s\", i ? \" \" : \"\",\n\t\t\t       acx565akm_cabc_modes[i]);\n\n\tbuf[len++] = '\\n';\n\n\treturn len;\n}\n\nstatic DEVICE_ATTR_RW(cabc_mode);\nstatic DEVICE_ATTR_RO(cabc_available_modes);\n\nstatic struct attribute *acx565akm_cabc_attrs[] = {\n\t&dev_attr_cabc_mode.attr,\n\t&dev_attr_cabc_available_modes.attr,\n\tNULL,\n};\n\nstatic const struct attribute_group acx565akm_cabc_attr_group = {\n\t.attrs = acx565akm_cabc_attrs,\n};\n\n \n\nstatic int acx565akm_get_actual_brightness(struct acx565akm_panel *lcd)\n{\n\tu8 bv;\n\n\tacx565akm_read(lcd, MIPI_DCS_GET_DISPLAY_BRIGHTNESS, &bv, 1);\n\n\treturn bv;\n}\n\nstatic void acx565akm_set_brightness(struct acx565akm_panel *lcd, int level)\n{\n\tu16 ctrl;\n\tint bv;\n\n\tbv = level | (1 << 8);\n\tacx565akm_write(lcd, MIPI_DCS_SET_DISPLAY_BRIGHTNESS, (u8 *)&bv, 2);\n\n\tacx565akm_read(lcd, MIPI_DCS_GET_CONTROL_DISPLAY, (u8 *)&ctrl, 1);\n\tif (level)\n\t\tctrl |= CTRL_DISP_BRIGHTNESS_CTRL_ON |\n\t\t\tCTRL_DISP_BACKLIGHT_ON;\n\telse\n\t\tctrl &= ~(CTRL_DISP_BRIGHTNESS_CTRL_ON |\n\t\t\t  CTRL_DISP_BACKLIGHT_ON);\n\n\tctrl |= 1 << 8;\n\tacx565akm_write(lcd, MIPI_DCS_WRITE_CONTROL_DISPLAY, (u8 *)&ctrl, 2);\n}\n\nstatic int acx565akm_bl_update_status_locked(struct backlight_device *dev)\n{\n\tstruct acx565akm_panel *lcd = dev_get_drvdata(&dev->dev);\n\tint level = backlight_get_brightness(dev);\n\n\tacx565akm_set_brightness(lcd, level);\n\n\treturn 0;\n}\n\nstatic int acx565akm_bl_update_status(struct backlight_device *dev)\n{\n\tstruct acx565akm_panel *lcd = dev_get_drvdata(&dev->dev);\n\tint ret;\n\n\tmutex_lock(&lcd->mutex);\n\tret = acx565akm_bl_update_status_locked(dev);\n\tmutex_unlock(&lcd->mutex);\n\n\treturn ret;\n}\n\nstatic int acx565akm_bl_get_intensity(struct backlight_device *dev)\n{\n\tstruct acx565akm_panel *lcd = dev_get_drvdata(&dev->dev);\n\tunsigned int intensity;\n\n\tmutex_lock(&lcd->mutex);\n\n\tif (!backlight_is_blank(dev))\n\t\tintensity = acx565akm_get_actual_brightness(lcd);\n\telse\n\t\tintensity = 0;\n\n\tmutex_unlock(&lcd->mutex);\n\n\treturn intensity;\n}\n\nstatic const struct backlight_ops acx565akm_bl_ops = {\n\t.get_brightness = acx565akm_bl_get_intensity,\n\t.update_status  = acx565akm_bl_update_status,\n};\n\nstatic int acx565akm_backlight_init(struct acx565akm_panel *lcd)\n{\n\tstruct backlight_properties props = {\n\t\t.power = FB_BLANK_UNBLANK,\n\t\t.type = BACKLIGHT_RAW,\n\t};\n\tint ret;\n\n\tlcd->backlight = backlight_device_register(lcd->name, &lcd->spi->dev,\n\t\t\t\t\t\t   lcd, &acx565akm_bl_ops,\n\t\t\t\t\t\t   &props);\n\tif (IS_ERR(lcd->backlight)) {\n\t\tret = PTR_ERR(lcd->backlight);\n\t\tlcd->backlight = NULL;\n\t\treturn ret;\n\t}\n\n\tif (lcd->has_cabc) {\n\t\tret = sysfs_create_group(&lcd->backlight->dev.kobj,\n\t\t\t\t\t &acx565akm_cabc_attr_group);\n\t\tif (ret < 0) {\n\t\t\tdev_err(&lcd->spi->dev,\n\t\t\t\t\"%s failed to create sysfs files\\n\", __func__);\n\t\t\tbacklight_device_unregister(lcd->backlight);\n\t\t\treturn ret;\n\t\t}\n\n\t\tlcd->cabc_mode = acx565akm_get_hw_cabc_mode(lcd);\n\t}\n\n\tlcd->backlight->props.max_brightness = 255;\n\tlcd->backlight->props.brightness = acx565akm_get_actual_brightness(lcd);\n\n\tacx565akm_bl_update_status_locked(lcd->backlight);\n\n\treturn 0;\n}\n\nstatic void acx565akm_backlight_cleanup(struct acx565akm_panel *lcd)\n{\n\tif (lcd->has_cabc)\n\t\tsysfs_remove_group(&lcd->backlight->dev.kobj,\n\t\t\t\t   &acx565akm_cabc_attr_group);\n\n\tbacklight_device_unregister(lcd->backlight);\n}\n\n \n\nstatic void acx565akm_set_sleep_mode(struct acx565akm_panel *lcd, int on)\n{\n\tint cmd = on ? MIPI_DCS_ENTER_SLEEP_MODE : MIPI_DCS_EXIT_SLEEP_MODE;\n\tunsigned long wait;\n\n\t \n\twait = lcd->hw_guard_end - jiffies;\n\tif ((long)wait > 0 && wait <= lcd->hw_guard_wait) {\n\t\tset_current_state(TASK_UNINTERRUPTIBLE);\n\t\tschedule_timeout(wait);\n\t}\n\n\tacx565akm_cmd(lcd, cmd);\n\n\tlcd->hw_guard_wait = msecs_to_jiffies(120);\n\tlcd->hw_guard_end = jiffies + lcd->hw_guard_wait;\n}\n\nstatic void acx565akm_set_display_state(struct acx565akm_panel *lcd,\n\t\t\t\t\tint enabled)\n{\n\tint cmd = enabled ? MIPI_DCS_SET_DISPLAY_ON : MIPI_DCS_SET_DISPLAY_OFF;\n\n\tacx565akm_cmd(lcd, cmd);\n}\n\nstatic int acx565akm_power_on(struct acx565akm_panel *lcd)\n{\n\t \n\tmsleep(50);\n\n\tgpiod_set_value(lcd->reset_gpio, 1);\n\n\tif (lcd->enabled) {\n\t\tdev_dbg(&lcd->spi->dev, \"panel already enabled\\n\");\n\t\treturn 0;\n\t}\n\n\t \n\tmsleep(120);\n\n\tacx565akm_set_sleep_mode(lcd, 0);\n\tlcd->enabled = true;\n\n\t \n\tusleep_range(5000, 10000);\n\tacx565akm_set_display_state(lcd, 1);\n\tacx565akm_set_cabc_mode(lcd, lcd->cabc_mode);\n\n\treturn acx565akm_bl_update_status_locked(lcd->backlight);\n}\n\nstatic void acx565akm_power_off(struct acx565akm_panel *lcd)\n{\n\tif (!lcd->enabled)\n\t\treturn;\n\n\tacx565akm_set_display_state(lcd, 0);\n\tacx565akm_set_sleep_mode(lcd, 1);\n\tlcd->enabled = false;\n\t \n\tmsleep(50);\n\n\tgpiod_set_value(lcd->reset_gpio, 0);\n\n\t \n\tmsleep(100);\n}\n\nstatic int acx565akm_disable(struct drm_panel *panel)\n{\n\tstruct acx565akm_panel *lcd = to_acx565akm_device(panel);\n\n\tmutex_lock(&lcd->mutex);\n\tacx565akm_power_off(lcd);\n\tmutex_unlock(&lcd->mutex);\n\n\treturn 0;\n}\n\nstatic int acx565akm_enable(struct drm_panel *panel)\n{\n\tstruct acx565akm_panel *lcd = to_acx565akm_device(panel);\n\n\tmutex_lock(&lcd->mutex);\n\tacx565akm_power_on(lcd);\n\tmutex_unlock(&lcd->mutex);\n\n\treturn 0;\n}\n\nstatic const struct drm_display_mode acx565akm_mode = {\n\t.clock = 24000,\n\t.hdisplay = 800,\n\t.hsync_start = 800 + 28,\n\t.hsync_end = 800 + 28 + 4,\n\t.htotal = 800 + 28 + 4 + 24,\n\t.vdisplay = 480,\n\t.vsync_start = 480 + 3,\n\t.vsync_end = 480 + 3 + 3,\n\t.vtotal = 480 + 3 + 3 + 4,\n\t.type = DRM_MODE_TYPE_DRIVER | DRM_MODE_TYPE_PREFERRED,\n\t.flags = DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_NVSYNC,\n\t.width_mm = 77,\n\t.height_mm = 46,\n};\n\nstatic int acx565akm_get_modes(struct drm_panel *panel,\n\t\t\t       struct drm_connector *connector)\n{\n\tstruct drm_display_mode *mode;\n\n\tmode = drm_mode_duplicate(connector->dev, &acx565akm_mode);\n\tif (!mode)\n\t\treturn -ENOMEM;\n\n\tdrm_mode_set_name(mode);\n\tdrm_mode_probed_add(connector, mode);\n\n\tconnector->display_info.width_mm = acx565akm_mode.width_mm;\n\tconnector->display_info.height_mm = acx565akm_mode.height_mm;\n\tconnector->display_info.bus_flags = DRM_BUS_FLAG_DE_HIGH\n\t\t\t\t\t  | DRM_BUS_FLAG_SYNC_SAMPLE_POSEDGE\n\t\t\t\t\t  | DRM_BUS_FLAG_PIXDATA_SAMPLE_NEGEDGE;\n\n\treturn 1;\n}\n\nstatic const struct drm_panel_funcs acx565akm_funcs = {\n\t.disable = acx565akm_disable,\n\t.enable = acx565akm_enable,\n\t.get_modes = acx565akm_get_modes,\n};\n\n \n\nstatic int acx565akm_detect(struct acx565akm_panel *lcd)\n{\n\t__be32 value;\n\tu32 status;\n\tint ret = 0;\n\n\t \n\tgpiod_set_value(lcd->reset_gpio, 1);\n\tusleep_range(5000, 10000);\n\n\tacx565akm_read(lcd, MIPI_DCS_GET_DISPLAY_STATUS, (u8 *)&value, 4);\n\tstatus = __be32_to_cpu(value);\n\tlcd->enabled = (status & (1 << 17)) && (status & (1 << 10));\n\n\tdev_dbg(&lcd->spi->dev,\n\t\t\"LCD panel %s by bootloader (status 0x%04x)\\n\",\n\t\tlcd->enabled ? \"enabled\" : \"disabled \", status);\n\n\tacx565akm_read(lcd, MIPI_DCS_GET_DISPLAY_ID, lcd->display_id, 3);\n\tdev_dbg(&lcd->spi->dev, \"MIPI display ID: %02x%02x%02x\\n\",\n\t\tlcd->display_id[0], lcd->display_id[1], lcd->display_id[2]);\n\n\tswitch (lcd->display_id[0]) {\n\tcase 0x10:\n\t\tlcd->model = MIPID_VER_ACX565AKM;\n\t\tlcd->name = \"acx565akm\";\n\t\tlcd->has_bc = 1;\n\t\tlcd->has_cabc = 1;\n\t\tbreak;\n\tcase 0x29:\n\t\tlcd->model = MIPID_VER_L4F00311;\n\t\tlcd->name = \"l4f00311\";\n\t\tbreak;\n\tcase 0x45:\n\t\tlcd->model = MIPID_VER_LPH8923;\n\t\tlcd->name = \"lph8923\";\n\t\tbreak;\n\tcase 0x83:\n\t\tlcd->model = MIPID_VER_LS041Y3;\n\t\tlcd->name = \"ls041y3\";\n\t\tbreak;\n\tdefault:\n\t\tlcd->name = \"unknown\";\n\t\tdev_err(&lcd->spi->dev, \"unknown display ID\\n\");\n\t\tret = -ENODEV;\n\t\tgoto done;\n\t}\n\n\tlcd->revision = lcd->display_id[1];\n\n\tdev_info(&lcd->spi->dev, \"%s rev %02x panel detected\\n\",\n\t\t lcd->name, lcd->revision);\n\ndone:\n\tif (!lcd->enabled)\n\t\tgpiod_set_value(lcd->reset_gpio, 0);\n\n\treturn ret;\n}\n\nstatic int acx565akm_probe(struct spi_device *spi)\n{\n\tstruct acx565akm_panel *lcd;\n\tint ret;\n\n\tlcd = devm_kzalloc(&spi->dev, sizeof(*lcd), GFP_KERNEL);\n\tif (!lcd)\n\t\treturn -ENOMEM;\n\n\tspi_set_drvdata(spi, lcd);\n\tspi->mode = SPI_MODE_3;\n\n\tlcd->spi = spi;\n\tmutex_init(&lcd->mutex);\n\n\tlcd->reset_gpio = devm_gpiod_get(&spi->dev, \"reset\", GPIOD_OUT_HIGH);\n\tif (IS_ERR(lcd->reset_gpio)) {\n\t\tdev_err(&spi->dev, \"failed to get reset GPIO\\n\");\n\t\treturn PTR_ERR(lcd->reset_gpio);\n\t}\n\n\tret = acx565akm_detect(lcd);\n\tif (ret < 0) {\n\t\tdev_err(&spi->dev, \"panel detection failed\\n\");\n\t\treturn ret;\n\t}\n\n\tif (lcd->has_bc) {\n\t\tret = acx565akm_backlight_init(lcd);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\tdrm_panel_init(&lcd->panel, &lcd->spi->dev, &acx565akm_funcs,\n\t\t       DRM_MODE_CONNECTOR_DPI);\n\n\tdrm_panel_add(&lcd->panel);\n\n\treturn 0;\n}\n\nstatic void acx565akm_remove(struct spi_device *spi)\n{\n\tstruct acx565akm_panel *lcd = spi_get_drvdata(spi);\n\n\tdrm_panel_remove(&lcd->panel);\n\n\tif (lcd->has_bc)\n\t\tacx565akm_backlight_cleanup(lcd);\n\n\tdrm_panel_disable(&lcd->panel);\n\tdrm_panel_unprepare(&lcd->panel);\n}\n\nstatic const struct of_device_id acx565akm_of_match[] = {\n\t{ .compatible = \"sony,acx565akm\", },\n\t{   },\n};\n\nMODULE_DEVICE_TABLE(of, acx565akm_of_match);\n\nstatic const struct spi_device_id acx565akm_ids[] = {\n\t{ \"acx565akm\", 0 },\n\t{   }\n};\n\nMODULE_DEVICE_TABLE(spi, acx565akm_ids);\n\nstatic struct spi_driver acx565akm_driver = {\n\t.probe\t\t= acx565akm_probe,\n\t.remove\t\t= acx565akm_remove,\n\t.id_table\t= acx565akm_ids,\n\t.driver\t\t= {\n\t\t.name\t= \"panel-sony-acx565akm\",\n\t\t.of_match_table = acx565akm_of_match,\n\t},\n};\n\nmodule_spi_driver(acx565akm_driver);\n\nMODULE_AUTHOR(\"Nokia Corporation\");\nMODULE_DESCRIPTION(\"Sony ACX565AKM LCD Panel Driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}