{
  "module_name": "panel-novatek-nt39016.c",
  "hash_id": "b8d7c95ee8e0da41df1d23d06a9cfeb589ccd755aef4370b04da4e21a6597a3b",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/panel/panel-novatek-nt39016.c",
  "human_readable_source": "\n \n\n#include <linux/delay.h>\n#include <linux/device.h>\n#include <linux/gpio/consumer.h>\n#include <linux/media-bus-format.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/regmap.h>\n#include <linux/regulator/consumer.h>\n#include <linux/spi/spi.h>\n\n#include <drm/drm_modes.h>\n#include <drm/drm_panel.h>\n\nenum nt39016_regs {\n\tNT39016_REG_SYSTEM,\n\tNT39016_REG_TIMING,\n\tNT39016_REG_OP,\n\tNT39016_REG_DATA_IN,\n\tNT39016_REG_SRC_TIMING_DELAY,\n\tNT39016_REG_GATE_TIMING_DELAY,\n\tNT39016_REG_RESERVED,\n\tNT39016_REG_INITIAL_FUNC,\n\tNT39016_REG_CONTRAST,\n\tNT39016_REG_BRIGHTNESS,\n\tNT39016_REG_HUE_SATURATION,\n\tNT39016_REG_RB_SUBCONTRAST,\n\tNT39016_REG_R_SUBBRIGHTNESS,\n\tNT39016_REG_B_SUBBRIGHTNESS,\n\tNT39016_REG_VCOMDC,\n\tNT39016_REG_VCOMAC,\n\tNT39016_REG_VGAM2,\n\tNT39016_REG_VGAM34,\n\tNT39016_REG_VGAM56,\n\tNT39016_REG_VCOMDC_TRIM = 0x1e,\n\tNT39016_REG_DISPLAY_MODE = 0x20,\n};\n\n#define NT39016_SYSTEM_RESET_N\tBIT(0)\n#define NT39016_SYSTEM_STANDBY\tBIT(1)\n\nstruct nt39016_panel_info {\n\tconst struct drm_display_mode *display_modes;\n\tunsigned int num_modes;\n\tu16 width_mm, height_mm;\n\tu32 bus_format, bus_flags;\n};\n\nstruct nt39016 {\n\tstruct drm_panel drm_panel;\n\tstruct regmap *map;\n\tstruct regulator *supply;\n\tconst struct nt39016_panel_info *panel_info;\n\n\tstruct gpio_desc *reset_gpio;\n};\n\nstatic inline struct nt39016 *to_nt39016(struct drm_panel *panel)\n{\n\treturn container_of(panel, struct nt39016, drm_panel);\n}\n\n#define RV(REG, VAL) { .reg = (REG), .def = (VAL), .delay_us = 2 }\nstatic const struct reg_sequence nt39016_panel_regs[] = {\n\tRV(NT39016_REG_SYSTEM, 0x00),\n\tRV(NT39016_REG_TIMING, 0x00),\n\tRV(NT39016_REG_OP, 0x03),\n\tRV(NT39016_REG_DATA_IN, 0xCC),\n\tRV(NT39016_REG_SRC_TIMING_DELAY, 0x46),\n\tRV(NT39016_REG_GATE_TIMING_DELAY, 0x05),\n\tRV(NT39016_REG_RESERVED, 0x00),\n\tRV(NT39016_REG_INITIAL_FUNC, 0x00),\n\tRV(NT39016_REG_CONTRAST, 0x08),\n\tRV(NT39016_REG_BRIGHTNESS, 0x40),\n\tRV(NT39016_REG_HUE_SATURATION, 0x88),\n\tRV(NT39016_REG_RB_SUBCONTRAST, 0x88),\n\tRV(NT39016_REG_R_SUBBRIGHTNESS, 0x20),\n\tRV(NT39016_REG_B_SUBBRIGHTNESS, 0x20),\n\tRV(NT39016_REG_VCOMDC, 0x67),\n\tRV(NT39016_REG_VCOMAC, 0xA4),\n\tRV(NT39016_REG_VGAM2, 0x04),\n\tRV(NT39016_REG_VGAM34, 0x24),\n\tRV(NT39016_REG_VGAM56, 0x24),\n\tRV(NT39016_REG_DISPLAY_MODE, 0x00),\n};\n\n#undef RV\n\nstatic const struct regmap_range nt39016_regmap_no_ranges[] = {\n\tregmap_reg_range(0x13, 0x1D),\n\tregmap_reg_range(0x1F, 0x1F),\n};\n\nstatic const struct regmap_access_table nt39016_regmap_access_table = {\n\t.no_ranges = nt39016_regmap_no_ranges,\n\t.n_no_ranges = ARRAY_SIZE(nt39016_regmap_no_ranges),\n};\n\nstatic const struct regmap_config nt39016_regmap_config = {\n\t.reg_bits = 6,\n\t.pad_bits = 2,\n\t.val_bits = 8,\n\n\t.max_register = NT39016_REG_DISPLAY_MODE,\n\t.wr_table = &nt39016_regmap_access_table,\n\t.write_flag_mask = 0x02,\n\n\t.cache_type = REGCACHE_FLAT,\n};\n\nstatic int nt39016_prepare(struct drm_panel *drm_panel)\n{\n\tstruct nt39016 *panel = to_nt39016(drm_panel);\n\tint err;\n\n\terr = regulator_enable(panel->supply);\n\tif (err) {\n\t\tdev_err(drm_panel->dev, \"Failed to enable power supply: %d\\n\", err);\n\t\treturn err;\n\t}\n\n\t \n\tgpiod_set_value_cansleep(panel->reset_gpio, 1);\n\tusleep_range(100, 1000);\n\tgpiod_set_value_cansleep(panel->reset_gpio, 0);\n\tudelay(2);\n\n\t \n\terr = regmap_multi_reg_write(panel->map, nt39016_panel_regs,\n\t\t\t\t     ARRAY_SIZE(nt39016_panel_regs));\n\tif (err) {\n\t\tdev_err(drm_panel->dev, \"Failed to init registers: %d\\n\", err);\n\t\tgoto err_disable_regulator;\n\t}\n\n\treturn 0;\n\nerr_disable_regulator:\n\tregulator_disable(panel->supply);\n\treturn err;\n}\n\nstatic int nt39016_unprepare(struct drm_panel *drm_panel)\n{\n\tstruct nt39016 *panel = to_nt39016(drm_panel);\n\n\tgpiod_set_value_cansleep(panel->reset_gpio, 1);\n\n\tregulator_disable(panel->supply);\n\n\treturn 0;\n}\n\nstatic int nt39016_enable(struct drm_panel *drm_panel)\n{\n\tstruct nt39016 *panel = to_nt39016(drm_panel);\n\tint ret;\n\n\tret = regmap_write(panel->map, NT39016_REG_SYSTEM,\n\t\t\t   NT39016_SYSTEM_RESET_N | NT39016_SYSTEM_STANDBY);\n\tif (ret) {\n\t\tdev_err(drm_panel->dev, \"Unable to enable panel: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tif (drm_panel->backlight) {\n\t\t \n\t\tmsleep(150);\n\t}\n\n\treturn 0;\n}\n\nstatic int nt39016_disable(struct drm_panel *drm_panel)\n{\n\tstruct nt39016 *panel = to_nt39016(drm_panel);\n\tint err;\n\n\terr = regmap_write(panel->map, NT39016_REG_SYSTEM,\n\t\t\t   NT39016_SYSTEM_RESET_N);\n\tif (err) {\n\t\tdev_err(drm_panel->dev, \"Unable to disable panel: %d\\n\", err);\n\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\nstatic int nt39016_get_modes(struct drm_panel *drm_panel,\n\t\t\t     struct drm_connector *connector)\n{\n\tstruct nt39016 *panel = to_nt39016(drm_panel);\n\tconst struct nt39016_panel_info *panel_info = panel->panel_info;\n\tstruct drm_display_mode *mode;\n\tunsigned int i;\n\n\tfor (i = 0; i < panel_info->num_modes; i++) {\n\t\tmode = drm_mode_duplicate(connector->dev,\n\t\t\t\t\t  &panel_info->display_modes[i]);\n\t\tif (!mode)\n\t\t\treturn -ENOMEM;\n\n\t\tdrm_mode_set_name(mode);\n\n\t\tmode->type = DRM_MODE_TYPE_DRIVER;\n\t\tif (panel_info->num_modes == 1)\n\t\t\tmode->type |= DRM_MODE_TYPE_PREFERRED;\n\n\t\tdrm_mode_probed_add(connector, mode);\n\t}\n\n\tconnector->display_info.bpc = 8;\n\tconnector->display_info.width_mm = panel_info->width_mm;\n\tconnector->display_info.height_mm = panel_info->height_mm;\n\n\tdrm_display_info_set_bus_formats(&connector->display_info,\n\t\t\t\t\t &panel_info->bus_format, 1);\n\tconnector->display_info.bus_flags = panel_info->bus_flags;\n\n\treturn panel_info->num_modes;\n}\n\nstatic const struct drm_panel_funcs nt39016_funcs = {\n\t.prepare\t= nt39016_prepare,\n\t.unprepare\t= nt39016_unprepare,\n\t.enable\t\t= nt39016_enable,\n\t.disable\t= nt39016_disable,\n\t.get_modes\t= nt39016_get_modes,\n};\n\nstatic int nt39016_probe(struct spi_device *spi)\n{\n\tstruct device *dev = &spi->dev;\n\tstruct nt39016 *panel;\n\tint err;\n\n\tpanel = devm_kzalloc(dev, sizeof(*panel), GFP_KERNEL);\n\tif (!panel)\n\t\treturn -ENOMEM;\n\n\tspi_set_drvdata(spi, panel);\n\n\tpanel->panel_info = of_device_get_match_data(dev);\n\tif (!panel->panel_info)\n\t\treturn -EINVAL;\n\n\tpanel->supply = devm_regulator_get(dev, \"power\");\n\tif (IS_ERR(panel->supply))\n\t\treturn dev_err_probe(dev, PTR_ERR(panel->supply),\n\t\t\t\t     \"Failed to get power supply\\n\");\n\n\tpanel->reset_gpio = devm_gpiod_get(dev, \"reset\", GPIOD_OUT_HIGH);\n\tif (IS_ERR(panel->reset_gpio))\n\t\treturn dev_err_probe(dev, PTR_ERR(panel->reset_gpio), \"Failed to get reset GPIO\\n\");\n\n\tspi->bits_per_word = 8;\n\tspi->mode = SPI_MODE_3 | SPI_3WIRE;\n\terr = spi_setup(spi);\n\tif (err) {\n\t\tdev_err(dev, \"Failed to setup SPI\\n\");\n\t\treturn err;\n\t}\n\n\tpanel->map = devm_regmap_init_spi(spi, &nt39016_regmap_config);\n\tif (IS_ERR(panel->map)) {\n\t\tdev_err(dev, \"Failed to init regmap\\n\");\n\t\treturn PTR_ERR(panel->map);\n\t}\n\n\tdrm_panel_init(&panel->drm_panel, dev, &nt39016_funcs,\n\t\t       DRM_MODE_CONNECTOR_DPI);\n\n\terr = drm_panel_of_backlight(&panel->drm_panel);\n\tif (err)\n\t\treturn dev_err_probe(dev, err, \"Failed to get backlight handle\\n\");\n\n\tdrm_panel_add(&panel->drm_panel);\n\n\treturn 0;\n}\n\nstatic void nt39016_remove(struct spi_device *spi)\n{\n\tstruct nt39016 *panel = spi_get_drvdata(spi);\n\n\tdrm_panel_remove(&panel->drm_panel);\n\n\tnt39016_disable(&panel->drm_panel);\n\tnt39016_unprepare(&panel->drm_panel);\n}\n\nstatic const struct drm_display_mode kd035g6_display_modes[] = {\n\t{\t \n\t\t.clock = 6000,\n\t\t.hdisplay = 320,\n\t\t.hsync_start = 320 + 10,\n\t\t.hsync_end = 320 + 10 + 50,\n\t\t.htotal = 320 + 10 + 50 + 20,\n\t\t.vdisplay = 240,\n\t\t.vsync_start = 240 + 5,\n\t\t.vsync_end = 240 + 5 + 1,\n\t\t.vtotal = 240 + 5 + 1 + 4,\n\t\t.flags = DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_NVSYNC,\n\t},\n\t{\t \n\t\t.clock = 5400,\n\t\t.hdisplay = 320,\n\t\t.hsync_start = 320 + 42,\n\t\t.hsync_end = 320 + 42 + 50,\n\t\t.htotal = 320 + 42 + 50 + 20,\n\t\t.vdisplay = 240,\n\t\t.vsync_start = 240 + 5,\n\t\t.vsync_end = 240 + 5 + 1,\n\t\t.vtotal = 240 + 5 + 1 + 4,\n\t\t.flags = DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_NVSYNC,\n\t},\n};\n\nstatic const struct nt39016_panel_info kd035g6_info = {\n\t.display_modes = kd035g6_display_modes,\n\t.num_modes = ARRAY_SIZE(kd035g6_display_modes),\n\t.width_mm = 71,\n\t.height_mm = 53,\n\t.bus_format = MEDIA_BUS_FMT_RGB888_1X24,\n\t.bus_flags = DRM_BUS_FLAG_PIXDATA_SAMPLE_POSEDGE,\n};\n\nstatic const struct of_device_id nt39016_of_match[] = {\n\t{ .compatible = \"kingdisplay,kd035g6-54nt\", .data = &kd035g6_info },\n\t{   }\n};\nMODULE_DEVICE_TABLE(of, nt39016_of_match);\n\nstatic struct spi_driver nt39016_driver = {\n\t.driver = {\n\t\t.name = \"nt39016\",\n\t\t.of_match_table = nt39016_of_match,\n\t},\n\t.probe = nt39016_probe,\n\t.remove = nt39016_remove,\n};\n\nmodule_spi_driver(nt39016_driver);\n\nMODULE_AUTHOR(\"Maarten ter Huurne <maarten@treewalker.org>\");\nMODULE_AUTHOR(\"Paul Cercueil <paul@crapouillou.net>\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}