{
  "module_name": "panel-seiko-43wvf1g.c",
  "hash_id": "0371fff7b8e03f8f9389360333343dfbd7455c5c3ab01d9280a8463ab63373af",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/panel/panel-seiko-43wvf1g.c",
  "human_readable_source": "\n \n\n#include <linux/delay.h>\n#include <linux/gpio/consumer.h>\n#include <linux/media-bus-format.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/regulator/consumer.h>\n\n#include <video/display_timing.h>\n#include <video/videomode.h>\n\n#include <drm/drm_crtc.h>\n#include <drm/drm_device.h>\n#include <drm/drm_panel.h>\n\nstruct seiko_panel_desc {\n\tconst struct drm_display_mode *modes;\n\tunsigned int num_modes;\n\tconst struct display_timing *timings;\n\tunsigned int num_timings;\n\n\tunsigned int bpc;\n\n\t \n\tstruct {\n\t\tunsigned int width;\n\t\tunsigned int height;\n\t} size;\n\n\tu32 bus_format;\n\tu32 bus_flags;\n};\n\nstruct seiko_panel {\n\tstruct drm_panel base;\n\tbool prepared;\n\tbool enabled;\n\tconst struct seiko_panel_desc *desc;\n\tstruct regulator *dvdd;\n\tstruct regulator *avdd;\n\tstruct gpio_desc *enable_gpio;\n};\n\nstatic inline struct seiko_panel *to_seiko_panel(struct drm_panel *panel)\n{\n\treturn container_of(panel, struct seiko_panel, base);\n}\n\nstatic int seiko_panel_get_fixed_modes(struct seiko_panel *panel,\n\t\t\t\t       struct drm_connector *connector)\n{\n\tstruct drm_display_mode *mode;\n\tunsigned int i, num = 0;\n\n\tif (!panel->desc)\n\t\treturn 0;\n\n\tfor (i = 0; i < panel->desc->num_timings; i++) {\n\t\tconst struct display_timing *dt = &panel->desc->timings[i];\n\t\tstruct videomode vm;\n\n\t\tvideomode_from_timing(dt, &vm);\n\t\tmode = drm_mode_create(connector->dev);\n\t\tif (!mode) {\n\t\t\tdev_err(panel->base.dev, \"failed to add mode %ux%u\\n\",\n\t\t\t\tdt->hactive.typ, dt->vactive.typ);\n\t\t\tcontinue;\n\t\t}\n\n\t\tdrm_display_mode_from_videomode(&vm, mode);\n\n\t\tmode->type |= DRM_MODE_TYPE_DRIVER;\n\n\t\tif (panel->desc->num_timings == 1)\n\t\t\tmode->type |= DRM_MODE_TYPE_PREFERRED;\n\n\t\tdrm_mode_probed_add(connector, mode);\n\t\tnum++;\n\t}\n\n\tfor (i = 0; i < panel->desc->num_modes; i++) {\n\t\tconst struct drm_display_mode *m = &panel->desc->modes[i];\n\n\t\tmode = drm_mode_duplicate(connector->dev, m);\n\t\tif (!mode) {\n\t\t\tdev_err(panel->base.dev, \"failed to add mode %ux%u@%u\\n\",\n\t\t\t\tm->hdisplay, m->vdisplay,\n\t\t\t\tdrm_mode_vrefresh(m));\n\t\t\tcontinue;\n\t\t}\n\n\t\tmode->type |= DRM_MODE_TYPE_DRIVER;\n\n\t\tif (panel->desc->num_modes == 1)\n\t\t\tmode->type |= DRM_MODE_TYPE_PREFERRED;\n\n\t\tdrm_mode_set_name(mode);\n\n\t\tdrm_mode_probed_add(connector, mode);\n\t\tnum++;\n\t}\n\n\tconnector->display_info.bpc = panel->desc->bpc;\n\tconnector->display_info.width_mm = panel->desc->size.width;\n\tconnector->display_info.height_mm = panel->desc->size.height;\n\tif (panel->desc->bus_format)\n\t\tdrm_display_info_set_bus_formats(&connector->display_info,\n\t\t\t\t\t\t &panel->desc->bus_format, 1);\n\tconnector->display_info.bus_flags = panel->desc->bus_flags;\n\n\treturn num;\n}\n\nstatic int seiko_panel_disable(struct drm_panel *panel)\n{\n\tstruct seiko_panel *p = to_seiko_panel(panel);\n\n\tif (!p->enabled)\n\t\treturn 0;\n\n\tp->enabled = false;\n\n\treturn 0;\n}\n\nstatic int seiko_panel_unprepare(struct drm_panel *panel)\n{\n\tstruct seiko_panel *p = to_seiko_panel(panel);\n\n\tif (!p->prepared)\n\t\treturn 0;\n\n\tgpiod_set_value_cansleep(p->enable_gpio, 0);\n\n\tregulator_disable(p->avdd);\n\n\t \n\tmsleep(100);\n\n\tregulator_disable(p->dvdd);\n\n\tp->prepared = false;\n\n\treturn 0;\n}\n\nstatic int seiko_panel_prepare(struct drm_panel *panel)\n{\n\tstruct seiko_panel *p = to_seiko_panel(panel);\n\tint err;\n\n\tif (p->prepared)\n\t\treturn 0;\n\n\terr = regulator_enable(p->dvdd);\n\tif (err < 0) {\n\t\tdev_err(panel->dev, \"failed to enable dvdd: %d\\n\", err);\n\t\treturn err;\n\t}\n\n\t \n\tmsleep(100);\n\n\terr = regulator_enable(p->avdd);\n\tif (err < 0) {\n\t\tdev_err(panel->dev, \"failed to enable avdd: %d\\n\", err);\n\t\tgoto disable_dvdd;\n\t}\n\n\tgpiod_set_value_cansleep(p->enable_gpio, 1);\n\n\tp->prepared = true;\n\n\treturn 0;\n\ndisable_dvdd:\n\tregulator_disable(p->dvdd);\n\treturn err;\n}\n\nstatic int seiko_panel_enable(struct drm_panel *panel)\n{\n\tstruct seiko_panel *p = to_seiko_panel(panel);\n\n\tif (p->enabled)\n\t\treturn 0;\n\n\tp->enabled = true;\n\n\treturn 0;\n}\n\nstatic int seiko_panel_get_modes(struct drm_panel *panel,\n\t\t\t\t struct drm_connector *connector)\n{\n\tstruct seiko_panel *p = to_seiko_panel(panel);\n\n\t \n\treturn seiko_panel_get_fixed_modes(p, connector);\n}\n\nstatic int seiko_panel_get_timings(struct drm_panel *panel,\n\t\t\t\t    unsigned int num_timings,\n\t\t\t\t    struct display_timing *timings)\n{\n\tstruct seiko_panel *p = to_seiko_panel(panel);\n\tunsigned int i;\n\n\tif (p->desc->num_timings < num_timings)\n\t\tnum_timings = p->desc->num_timings;\n\n\tif (timings)\n\t\tfor (i = 0; i < num_timings; i++)\n\t\t\ttimings[i] = p->desc->timings[i];\n\n\treturn p->desc->num_timings;\n}\n\nstatic const struct drm_panel_funcs seiko_panel_funcs = {\n\t.disable = seiko_panel_disable,\n\t.unprepare = seiko_panel_unprepare,\n\t.prepare = seiko_panel_prepare,\n\t.enable = seiko_panel_enable,\n\t.get_modes = seiko_panel_get_modes,\n\t.get_timings = seiko_panel_get_timings,\n};\n\nstatic int seiko_panel_probe(struct device *dev,\n\t\t\t\t\tconst struct seiko_panel_desc *desc)\n{\n\tstruct seiko_panel *panel;\n\tint err;\n\n\tpanel = devm_kzalloc(dev, sizeof(*panel), GFP_KERNEL);\n\tif (!panel)\n\t\treturn -ENOMEM;\n\n\tpanel->enabled = false;\n\tpanel->prepared = false;\n\tpanel->desc = desc;\n\n\tpanel->dvdd = devm_regulator_get(dev, \"dvdd\");\n\tif (IS_ERR(panel->dvdd))\n\t\treturn PTR_ERR(panel->dvdd);\n\n\tpanel->avdd = devm_regulator_get(dev, \"avdd\");\n\tif (IS_ERR(panel->avdd))\n\t\treturn PTR_ERR(panel->avdd);\n\n\tpanel->enable_gpio = devm_gpiod_get_optional(dev, \"enable\",\n\t\t\t\t\t\t     GPIOD_OUT_LOW);\n\tif (IS_ERR(panel->enable_gpio))\n\t\treturn dev_err_probe(dev, PTR_ERR(panel->enable_gpio),\n\t\t\t\t     \"failed to request GPIO\\n\");\n\n\tdrm_panel_init(&panel->base, dev, &seiko_panel_funcs,\n\t\t       DRM_MODE_CONNECTOR_DPI);\n\n\terr = drm_panel_of_backlight(&panel->base);\n\tif (err)\n\t\treturn err;\n\n\tdrm_panel_add(&panel->base);\n\n\tdev_set_drvdata(dev, panel);\n\n\treturn 0;\n}\n\nstatic void seiko_panel_remove(struct platform_device *pdev)\n{\n\tstruct seiko_panel *panel = platform_get_drvdata(pdev);\n\n\tdrm_panel_remove(&panel->base);\n\tdrm_panel_disable(&panel->base);\n}\n\nstatic void seiko_panel_shutdown(struct platform_device *pdev)\n{\n\tstruct seiko_panel *panel = platform_get_drvdata(pdev);\n\n\tdrm_panel_disable(&panel->base);\n}\n\nstatic const struct display_timing seiko_43wvf1g_timing = {\n\t.pixelclock = { 33500000, 33500000, 33500000 },\n\t.hactive = { 800, 800, 800 },\n\t.hfront_porch = {  164, 164, 164 },\n\t.hback_porch = { 89, 89, 89 },\n\t.hsync_len = { 10, 10, 10 },\n\t.vactive = { 480, 480, 480 },\n\t.vfront_porch = { 10, 10, 10 },\n\t.vback_porch = { 23, 23, 23 },\n\t.vsync_len = { 10, 10, 10 },\n\t.flags = DISPLAY_FLAGS_DE_LOW,\n};\n\nstatic const struct seiko_panel_desc seiko_43wvf1g = {\n\t.timings = &seiko_43wvf1g_timing,\n\t.num_timings = 1,\n\t.bpc = 8,\n\t.size = {\n\t\t.width = 93,\n\t\t.height = 57,\n\t},\n\t.bus_format = MEDIA_BUS_FMT_RGB888_1X24,\n\t.bus_flags = DRM_BUS_FLAG_DE_HIGH | DRM_BUS_FLAG_PIXDATA_DRIVE_NEGEDGE,\n};\n\nstatic const struct of_device_id platform_of_match[] = {\n\t{\n\t\t.compatible = \"sii,43wvf1g\",\n\t\t.data = &seiko_43wvf1g,\n\t}, {\n\t\t \n\t}\n};\nMODULE_DEVICE_TABLE(of, platform_of_match);\n\nstatic int seiko_panel_platform_probe(struct platform_device *pdev)\n{\n\tconst struct of_device_id *id;\n\n\tid = of_match_node(platform_of_match, pdev->dev.of_node);\n\tif (!id)\n\t\treturn -ENODEV;\n\n\treturn seiko_panel_probe(&pdev->dev, id->data);\n}\n\nstatic struct platform_driver seiko_panel_platform_driver = {\n\t.driver = {\n\t\t.name = \"seiko_panel\",\n\t\t.of_match_table = platform_of_match,\n\t},\n\t.probe = seiko_panel_platform_probe,\n\t.remove_new = seiko_panel_remove,\n\t.shutdown = seiko_panel_shutdown,\n};\nmodule_platform_driver(seiko_panel_platform_driver);\n\nMODULE_AUTHOR(\"Marco Franchi <marco.franchi@nxp.com>\");\nMODULE_DESCRIPTION(\"Seiko 43WVF1G panel driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}