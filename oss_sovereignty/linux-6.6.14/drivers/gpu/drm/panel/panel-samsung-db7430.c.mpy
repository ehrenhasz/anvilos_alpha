{
  "module_name": "panel-samsung-db7430.c",
  "hash_id": "28d896a5275ae70fce8a5e76aa862f3eb6bf7c473592f025dd2f2af52b8c39c7",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/panel/panel-samsung-db7430.c",
  "human_readable_source": "\n \n#include <drm/drm_mipi_dbi.h>\n#include <drm/drm_modes.h>\n#include <drm/drm_panel.h>\n\n#include <linux/delay.h>\n#include <linux/gpio/consumer.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/media-bus-format.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/regulator/consumer.h>\n#include <linux/spi/spi.h>\n\n#include <video/mipi_display.h>\n\n#define DB7430_ACCESS_PROT_OFF\t\t0xb0\n#define DB7430_UNKNOWN_B4\t\t0xb4\n#define DB7430_USER_SELECT\t\t0xb5\n#define DB7430_UNKNOWN_B7\t\t0xb7\n#define DB7430_UNKNOWN_B8\t\t0xb8\n#define DB7430_PANEL_DRIVING\t\t0xc0\n#define DB7430_SOURCE_CONTROL\t\t0xc1\n#define DB7430_GATE_INTERFACE\t\t0xc4\n#define DB7430_DISPLAY_H_TIMING\t\t0xc5\n#define DB7430_RGB_SYNC_OPTION\t\t0xc6\n#define DB7430_GAMMA_SET_RED\t\t0xc8\n#define DB7430_GAMMA_SET_GREEN\t\t0xc9\n#define DB7430_GAMMA_SET_BLUE\t\t0xca\n#define DB7430_BIAS_CURRENT_CTRL\t0xd1\n#define DB7430_DDV_CTRL\t\t\t0xd2\n#define DB7430_GAMMA_CTRL_REF\t\t0xd3\n#define DB7430_UNKNOWN_D4\t\t0xd4\n#define DB7430_DCDC_CTRL\t\t0xd5\n#define DB7430_VCL_CTRL\t\t\t0xd6\n#define DB7430_UNKNOWN_F8\t\t0xf8\n#define DB7430_UNKNOWN_FC\t\t0xfc\n\n#define DATA_MASK\t0x100\n\n \nstruct db7430 {\n\t \n\tstruct device *dev;\n\t \n\tstruct mipi_dbi dbi;\n\t \n\tstruct drm_panel panel;\n\t \n\tstruct gpio_desc *reset;\n\t \n\tstruct regulator_bulk_data regulators[2];\n};\n\nstatic const struct drm_display_mode db7430_480_800_mode = {\n\t \n\t.clock = 32258,\n\t.hdisplay = 480,\n\t.hsync_start = 480 + 10,\n\t.hsync_end = 480 + 10 + 4,\n\t.htotal = 480 + 10 + 4 + 40,\n\t.vdisplay = 800,\n\t.vsync_start = 800 + 6,\n\t.vsync_end = 800 + 6 + 1,\n\t.vtotal = 800 + 6 + 1 + 7,\n\t.width_mm = 53,\n\t.height_mm = 87,\n\t.flags = DRM_MODE_FLAG_NVSYNC | DRM_MODE_FLAG_NHSYNC,\n};\n\nstatic inline struct db7430 *to_db7430(struct drm_panel *panel)\n{\n\treturn container_of(panel, struct db7430, panel);\n}\n\nstatic int db7430_power_on(struct db7430 *db)\n{\n\tstruct mipi_dbi *dbi = &db->dbi;\n\tint ret;\n\n\t \n\tret = regulator_bulk_enable(ARRAY_SIZE(db->regulators),\n\t\t\t\t    db->regulators);\n\tif (ret) {\n\t\tdev_err(db->dev, \"failed to enable regulators: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\tmsleep(50);\n\n\t \n\tgpiod_set_value_cansleep(db->reset, 1);\n\tusleep_range(1000, 5000);\n\t \n\tgpiod_set_value_cansleep(db->reset, 0);\n\t \n\tmsleep(10);\n\tdev_dbg(db->dev, \"de-asserted RESET\\n\");\n\n\t \n\tmipi_dbi_command(dbi, MIPI_DCS_SET_ADDRESS_MODE, 0x0a);\n\tmipi_dbi_command(dbi, MIPI_DCS_SET_ADDRESS_MODE, 0x0a);\n\tmipi_dbi_command(dbi, DB7430_ACCESS_PROT_OFF, 0x00);\n\tmipi_dbi_command(dbi, DB7430_PANEL_DRIVING, 0x28, 0x08);\n\tmipi_dbi_command(dbi, DB7430_SOURCE_CONTROL,\n\t\t\t 0x01, 0x30, 0x15, 0x05, 0x22);\n\tmipi_dbi_command(dbi, DB7430_GATE_INTERFACE,\n\t\t\t 0x10, 0x01, 0x00);\n\tmipi_dbi_command(dbi, DB7430_DISPLAY_H_TIMING,\n\t\t\t 0x06, 0x55, 0x03, 0x07, 0x0b,\n\t\t\t 0x33, 0x00, 0x01, 0x03);\n\t \n\tmipi_dbi_command(dbi, DB7430_RGB_SYNC_OPTION, 0x01);\n\tmipi_dbi_command(dbi, DB7430_GAMMA_SET_RED,\n\t\t  0x00,\n\t\t0x0A, 0x31, 0x3B, 0x4E, 0x58, 0x59, 0x5B, 0x58, 0x5E, 0x62,\n\t\t0x60, 0x61, 0x5E, 0x62, 0x55, 0x55, 0x7F, 0x08,\n\t\t  0x00,\n\t\t0x0A, 0x31, 0x3B, 0x4E, 0x58, 0x59, 0x5B, 0x58, 0x5E, 0x62,\n\t\t0x60, 0x61, 0x5E, 0x62, 0x55, 0x55, 0x7F, 0x08);\n\tmipi_dbi_command(dbi, DB7430_GAMMA_SET_GREEN,\n\t\t  0x00,\n\t\t0x25, 0x15, 0x28, 0x3D, 0x4A, 0x48, 0x4C, 0x4A, 0x52, 0x59,\n\t\t0x59, 0x5B, 0x56, 0x60, 0x5D, 0x55, 0x7F, 0x0A,\n\t\t  0x00,\n\t\t0x25, 0x15, 0x28, 0x3D, 0x4A, 0x48, 0x4C, 0x4A, 0x52, 0x59,\n\t\t0x59, 0x5B, 0x56, 0x60, 0x5D, 0x55, 0x7F, 0x0A);\n\tmipi_dbi_command(dbi, DB7430_GAMMA_SET_BLUE,\n\t\t  0x00,\n\t\t0x48, 0x10, 0x1F, 0x2F, 0x35, 0x38, 0x3D, 0x3C, 0x45, 0x4D,\n\t\t0x4E, 0x52, 0x51, 0x60, 0x7F, 0x7E, 0x7F, 0x0C,\n\t\t  0x00,\n\t\t0x48, 0x10, 0x1F, 0x2F, 0x35, 0x38, 0x3D, 0x3C, 0x45, 0x4D,\n\t\t0x4E, 0x52, 0x51, 0x60, 0x7F, 0x7E, 0x7F, 0x0C);\n\tmipi_dbi_command(dbi, DB7430_BIAS_CURRENT_CTRL, 0x33, 0x13);\n\tmipi_dbi_command(dbi, DB7430_DDV_CTRL, 0x11, 0x00, 0x00);\n\tmipi_dbi_command(dbi, DB7430_GAMMA_CTRL_REF, 0x50, 0x50);\n\tmipi_dbi_command(dbi, DB7430_DCDC_CTRL, 0x2f, 0x11, 0x1e, 0x46);\n\tmipi_dbi_command(dbi, DB7430_VCL_CTRL, 0x11, 0x0a);\n\n\treturn 0;\n}\n\nstatic int db7430_power_off(struct db7430 *db)\n{\n\t \n\tgpiod_set_value_cansleep(db->reset, 1);\n\treturn regulator_bulk_disable(ARRAY_SIZE(db->regulators),\n\t\t\t\t      db->regulators);\n}\n\nstatic int db7430_unprepare(struct drm_panel *panel)\n{\n\treturn db7430_power_off(to_db7430(panel));\n}\n\nstatic int db7430_disable(struct drm_panel *panel)\n{\n\tstruct db7430 *db = to_db7430(panel);\n\tstruct mipi_dbi *dbi = &db->dbi;\n\n\tmipi_dbi_command(dbi, MIPI_DCS_SET_DISPLAY_OFF);\n\tmsleep(25);\n\tmipi_dbi_command(dbi, MIPI_DCS_ENTER_SLEEP_MODE);\n\tmsleep(120);\n\n\treturn 0;\n}\n\nstatic int db7430_prepare(struct drm_panel *panel)\n{\n\treturn db7430_power_on(to_db7430(panel));\n}\n\nstatic int db7430_enable(struct drm_panel *panel)\n{\n\tstruct db7430 *db = to_db7430(panel);\n\tstruct mipi_dbi *dbi = &db->dbi;\n\n\t \n\tmipi_dbi_command(dbi, MIPI_DCS_EXIT_SLEEP_MODE);\n\tmsleep(20);\n\n\t \n\tmipi_dbi_command(dbi, DB7430_UNKNOWN_D4, 0x52, 0x5e);\n\tmipi_dbi_command(dbi, DB7430_UNKNOWN_F8, 0x01, 0xf5, 0xf2, 0x71, 0x44);\n\tmipi_dbi_command(dbi, DB7430_UNKNOWN_FC, 0x00, 0x08);\n\tmsleep(150);\n\n\t \n\tmipi_dbi_command(dbi, DB7430_UNKNOWN_B4, 0x0f, 0x00, 0x50);\n\tmipi_dbi_command(dbi, DB7430_USER_SELECT, 0x80);\n\tmipi_dbi_command(dbi, DB7430_UNKNOWN_B7, 0x24);\n\tmipi_dbi_command(dbi, DB7430_UNKNOWN_B8, 0x01);\n\n\t \n\tmipi_dbi_command(dbi, MIPI_DCS_SET_DISPLAY_ON);\n\n\treturn 0;\n}\n\n \nstatic int db7430_get_modes(struct drm_panel *panel,\n\t\t\t    struct drm_connector *connector)\n{\n\tstruct db7430 *db = to_db7430(panel);\n\tstruct drm_display_mode *mode;\n\tstatic const u32 bus_format = MEDIA_BUS_FMT_RGB888_1X24;\n\n\tmode = drm_mode_duplicate(connector->dev, &db7430_480_800_mode);\n\tif (!mode) {\n\t\tdev_err(db->dev, \"failed to add mode\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tconnector->display_info.bpc = 8;\n\tconnector->display_info.width_mm = mode->width_mm;\n\tconnector->display_info.height_mm = mode->height_mm;\n\tconnector->display_info.bus_flags =\n\t\tDRM_BUS_FLAG_PIXDATA_DRIVE_NEGEDGE;\n\tdrm_display_info_set_bus_formats(&connector->display_info,\n\t\t\t\t\t &bus_format, 1);\n\n\tdrm_mode_set_name(mode);\n\tmode->type = DRM_MODE_TYPE_DRIVER | DRM_MODE_TYPE_PREFERRED;\n\n\tdrm_mode_probed_add(connector, mode);\n\n\treturn 1;\n}\n\nstatic const struct drm_panel_funcs db7430_drm_funcs = {\n\t.disable = db7430_disable,\n\t.unprepare = db7430_unprepare,\n\t.prepare = db7430_prepare,\n\t.enable = db7430_enable,\n\t.get_modes = db7430_get_modes,\n};\n\nstatic int db7430_probe(struct spi_device *spi)\n{\n\tstruct device *dev = &spi->dev;\n\tstruct db7430 *db;\n\tint ret;\n\n\tdb = devm_kzalloc(dev, sizeof(*db), GFP_KERNEL);\n\tif (!db)\n\t\treturn -ENOMEM;\n\tdb->dev = dev;\n\n\t \n\tdb->regulators[0].supply = \"vci\";\n\tdb->regulators[1].supply = \"vccio\";\n\tret = devm_regulator_bulk_get(dev,\n\t\t\t\t      ARRAY_SIZE(db->regulators),\n\t\t\t\t      db->regulators);\n\tif (ret)\n\t\treturn dev_err_probe(dev, ret, \"failed to get regulators\\n\");\n\n\tdb->reset = devm_gpiod_get(dev, \"reset\", GPIOD_OUT_HIGH);\n\tif (IS_ERR(db->reset)) {\n\t\tret = PTR_ERR(db->reset);\n\t\treturn dev_err_probe(dev, ret, \"no RESET GPIO\\n\");\n\t}\n\n\tret = mipi_dbi_spi_init(spi, &db->dbi, NULL);\n\tif (ret)\n\t\treturn dev_err_probe(dev, ret, \"MIPI DBI init failed\\n\");\n\n\tdrm_panel_init(&db->panel, dev, &db7430_drm_funcs,\n\t\t       DRM_MODE_CONNECTOR_DPI);\n\n\t \n\tret = drm_panel_of_backlight(&db->panel);\n\tif (ret)\n\t\treturn dev_err_probe(dev, ret, \"failed to add backlight\\n\");\n\n\tspi_set_drvdata(spi, db);\n\n\tdrm_panel_add(&db->panel);\n\tdev_dbg(dev, \"added panel\\n\");\n\n\treturn 0;\n}\n\nstatic void db7430_remove(struct spi_device *spi)\n{\n\tstruct db7430 *db = spi_get_drvdata(spi);\n\n\tdrm_panel_remove(&db->panel);\n}\n\n \nstatic const struct of_device_id db7430_match[] = {\n\t{ .compatible = \"samsung,lms397kf04\", },\n\t{},\n};\nMODULE_DEVICE_TABLE(of, db7430_match);\n\nstatic const struct spi_device_id db7430_ids[] = {\n\t{ \"lms397kf04\" },\n\t{ },\n};\nMODULE_DEVICE_TABLE(spi, db7430_ids);\n\nstatic struct spi_driver db7430_driver = {\n\t.probe\t\t= db7430_probe,\n\t.remove\t\t= db7430_remove,\n\t.id_table\t= db7430_ids,\n\t.driver\t\t= {\n\t\t.name\t= \"db7430-panel\",\n\t\t.of_match_table = db7430_match,\n\t},\n};\nmodule_spi_driver(db7430_driver);\n\nMODULE_AUTHOR(\"Linus Walleij <linus.walleij@linaro.org>\");\nMODULE_DESCRIPTION(\"Samsung DB7430 panel driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}