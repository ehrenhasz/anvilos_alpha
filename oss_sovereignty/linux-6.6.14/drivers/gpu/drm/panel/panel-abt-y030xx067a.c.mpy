{
  "module_name": "panel-abt-y030xx067a.c",
  "hash_id": "01347d3cffe2c6b424ed49d4c240a258b8d591e8643fa73a1c504661d256d3b1",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/panel/panel-abt-y030xx067a.c",
  "human_readable_source": "\n \n\n#include <linux/delay.h>\n#include <linux/device.h>\n#include <linux/gpio/consumer.h>\n#include <linux/media-bus-format.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/regmap.h>\n#include <linux/regulator/consumer.h>\n#include <linux/spi/spi.h>\n\n#include <drm/drm_modes.h>\n#include <drm/drm_panel.h>\n\n#define REG00_VBRT_CTRL(val)\t\t(val)\n\n#define REG01_COM_DC(val)\t\t(val)\n\n#define REG02_DA_CONTRAST(val)\t\t(val)\n#define REG02_VESA_SEL(val)\t\t((val) << 5)\n#define REG02_COMDC_SW\t\t\tBIT(7)\n\n#define REG03_VPOSITION(val)\t\t(val)\n#define REG03_BSMOUNT\t\t\tBIT(5)\n#define REG03_COMTST\t\t\tBIT(6)\n#define REG03_HPOSITION1\t\tBIT(7)\n\n#define REG04_HPOSITION1(val)\t\t(val)\n\n#define REG05_CLIP\t\t\tBIT(0)\n#define REG05_NVM_VREFRESH\t\tBIT(1)\n#define REG05_SLFR\t\t\tBIT(2)\n#define REG05_SLBRCHARGE(val)\t\t((val) << 3)\n#define REG05_PRECHARGE_LEVEL(val)\t((val) << 6)\n\n#define REG06_TEST5\t\t\tBIT(0)\n#define REG06_SLDWN\t\t\tBIT(1)\n#define REG06_SLRGT\t\t\tBIT(2)\n#define REG06_TEST2\t\t\tBIT(3)\n#define REG06_XPSAVE\t\t\tBIT(4)\n#define REG06_GAMMA_SEL(val)\t\t((val) << 5)\n#define REG06_NT\t\t\tBIT(7)\n\n#define REG07_TEST1\t\t\tBIT(0)\n#define REG07_HDVD_POL\t\t\tBIT(1)\n#define REG07_CK_POL\t\t\tBIT(2)\n#define REG07_TEST3\t\t\tBIT(3)\n#define REG07_TEST4\t\t\tBIT(4)\n#define REG07_480_LINEMASK\t\tBIT(5)\n#define REG07_AMPTST(val)\t\t((val) << 6)\n\n#define REG08_SLHRC(val)\t\t(val)\n#define REG08_CLOCK_DIV(val)\t\t((val) << 2)\n#define REG08_PANEL(val)\t\t((val) << 5)\n\n#define REG09_SUB_BRIGHT_R(val)\t\t(val)\n#define REG09_NW_NB\t\t\tBIT(6)\n#define REG09_IPCON\t\t\tBIT(7)\n\n#define REG0A_SUB_BRIGHT_B(val)\t\t(val)\n#define REG0A_PAIR\t\t\tBIT(6)\n#define REG0A_DE_SEL\t\t\tBIT(7)\n\n#define REG0B_MBK_POSITION(val)\t\t(val)\n#define REG0B_HD_FREERUN\t\tBIT(4)\n#define REG0B_VD_FREERUN\t\tBIT(5)\n#define REG0B_YUV2BIN(val)\t\t((val) << 6)\n\n#define REG0C_CONTRAST_R(val)\t\t(val)\n#define REG0C_DOUBLEREAD\t\tBIT(7)\n\n#define REG0D_CONTRAST_G(val)\t\t(val)\n#define REG0D_RGB_YUV\t\t\tBIT(7)\n\n#define REG0E_CONTRAST_B(val)\t\t(val)\n#define REG0E_PIXELCOLORDRIVE\t\tBIT(7)\n\n#define REG0F_ASPECT\t\t\tBIT(0)\n#define REG0F_OVERSCAN(val)\t\t((val) << 1)\n#define REG0F_FRAMEWIDTH(val)\t\t((val) << 3)\n\n#define REG10_BRIGHT(val)\t\t(val)\n\n#define REG11_SIG_GAIN(val)\t\t(val)\n#define REG11_SIGC_CNTL\t\t\tBIT(6)\n#define REG11_SIGC_POL\t\t\tBIT(7)\n\n#define REG12_COLOR(val)\t\t(val)\n#define REG12_PWCKSEL(val)\t\t((val) << 6)\n\n#define REG13_4096LEVEL_CNTL(val)\t(val)\n#define REG13_SL4096(val)\t\t((val) << 4)\n#define REG13_LIMITER_CONTROL\t\tBIT(7)\n\n#define REG14_PANEL_TEST(val)\t\t(val)\n\n#define REG15_NVM_LINK0\t\t\tBIT(0)\n#define REG15_NVM_LINK1\t\t\tBIT(1)\n#define REG15_NVM_LINK2\t\t\tBIT(2)\n#define REG15_NVM_LINK3\t\t\tBIT(3)\n#define REG15_NVM_LINK4\t\t\tBIT(4)\n#define REG15_NVM_LINK5\t\t\tBIT(5)\n#define REG15_NVM_LINK6\t\t\tBIT(6)\n#define REG15_NVM_LINK7\t\t\tBIT(7)\n\nstruct y030xx067a_info {\n\tconst struct drm_display_mode *display_modes;\n\tunsigned int num_modes;\n\tu16 width_mm, height_mm;\n\tu32 bus_format, bus_flags;\n};\n\nstruct y030xx067a {\n\tstruct drm_panel panel;\n\tstruct spi_device *spi;\n\tstruct regmap *map;\n\n\tconst struct y030xx067a_info *panel_info;\n\n\tstruct regulator *supply;\n\tstruct gpio_desc *reset_gpio;\n};\n\nstatic inline struct y030xx067a *to_y030xx067a(struct drm_panel *panel)\n{\n\treturn container_of(panel, struct y030xx067a, panel);\n}\n\nstatic const struct reg_sequence y030xx067a_init_sequence[] = {\n\t{ 0x00, REG00_VBRT_CTRL(0x7f) },\n\t{ 0x01, REG01_COM_DC(0x3c) },\n\t{ 0x02, REG02_VESA_SEL(0x3) | REG02_DA_CONTRAST(0x1f) },\n\t{ 0x03, REG03_VPOSITION(0x0a) },\n\t{ 0x04, REG04_HPOSITION1(0xd2) },\n\t{ 0x05, REG05_CLIP | REG05_NVM_VREFRESH | REG05_SLBRCHARGE(0x2) },\n\t{ 0x06, REG06_NT },\n\t{ 0x07, 0 },\n\t{ 0x08, REG08_PANEL(0x1) | REG08_CLOCK_DIV(0x2) },\n\t{ 0x09, REG09_SUB_BRIGHT_R(0x20) },\n\t{ 0x0a, REG0A_SUB_BRIGHT_B(0x20) },\n\t{ 0x0b, REG0B_HD_FREERUN | REG0B_VD_FREERUN },\n\t{ 0x0c, REG0C_CONTRAST_R(0x00) },\n\t{ 0x0d, REG0D_CONTRAST_G(0x00) },\n\t{ 0x0e, REG0E_CONTRAST_B(0x10) },\n\t{ 0x0f, 0 },\n\t{ 0x10, REG10_BRIGHT(0x7f) },\n\t{ 0x11, REG11_SIGC_CNTL | REG11_SIG_GAIN(0x3f) },\n\t{ 0x12, REG12_COLOR(0x20) | REG12_PWCKSEL(0x1) },\n\t{ 0x13, REG13_4096LEVEL_CNTL(0x8) },\n\t{ 0x14, 0 },\n\t{ 0x15, 0 },\n};\n\nstatic int y030xx067a_prepare(struct drm_panel *panel)\n{\n\tstruct y030xx067a *priv = to_y030xx067a(panel);\n\tstruct device *dev = &priv->spi->dev;\n\tint err;\n\n\terr = regulator_enable(priv->supply);\n\tif (err) {\n\t\tdev_err(dev, \"Failed to enable power supply: %d\\n\", err);\n\t\treturn err;\n\t}\n\n\t \n\tgpiod_set_value_cansleep(priv->reset_gpio, 1);\n\tusleep_range(1000, 20000);\n\tgpiod_set_value_cansleep(priv->reset_gpio, 0);\n\tusleep_range(1000, 20000);\n\n\terr = regmap_multi_reg_write(priv->map, y030xx067a_init_sequence,\n\t\t\t\t     ARRAY_SIZE(y030xx067a_init_sequence));\n\tif (err) {\n\t\tdev_err(dev, \"Failed to init registers: %d\\n\", err);\n\t\tgoto err_disable_regulator;\n\t}\n\n\treturn 0;\n\nerr_disable_regulator:\n\tregulator_disable(priv->supply);\n\treturn err;\n}\n\nstatic int y030xx067a_unprepare(struct drm_panel *panel)\n{\n\tstruct y030xx067a *priv = to_y030xx067a(panel);\n\n\tgpiod_set_value_cansleep(priv->reset_gpio, 1);\n\tregulator_disable(priv->supply);\n\n\treturn 0;\n}\n\nstatic int y030xx067a_enable(struct drm_panel *panel)\n{\n\tstruct y030xx067a *priv = to_y030xx067a(panel);\n\n\tregmap_set_bits(priv->map, 0x06, REG06_XPSAVE);\n\n\tif (panel->backlight) {\n\t\t \n\t\tmsleep(120);\n\t}\n\n\treturn 0;\n}\n\nstatic int y030xx067a_disable(struct drm_panel *panel)\n{\n\tstruct y030xx067a *priv = to_y030xx067a(panel);\n\n\tregmap_clear_bits(priv->map, 0x06, REG06_XPSAVE);\n\n\treturn 0;\n}\n\nstatic int y030xx067a_get_modes(struct drm_panel *panel,\n\t\t\t\tstruct drm_connector *connector)\n{\n\tstruct y030xx067a *priv = to_y030xx067a(panel);\n\tconst struct y030xx067a_info *panel_info = priv->panel_info;\n\tstruct drm_display_mode *mode;\n\tunsigned int i;\n\n\tfor (i = 0; i < panel_info->num_modes; i++) {\n\t\tmode = drm_mode_duplicate(connector->dev,\n\t\t\t\t\t  &panel_info->display_modes[i]);\n\t\tif (!mode)\n\t\t\treturn -ENOMEM;\n\n\t\tdrm_mode_set_name(mode);\n\n\t\tmode->type = DRM_MODE_TYPE_DRIVER;\n\t\tif (panel_info->num_modes == 1)\n\t\t\tmode->type |= DRM_MODE_TYPE_PREFERRED;\n\n\t\tdrm_mode_probed_add(connector, mode);\n\t}\n\n\tconnector->display_info.bpc = 8;\n\tconnector->display_info.width_mm = panel_info->width_mm;\n\tconnector->display_info.height_mm = panel_info->height_mm;\n\n\tdrm_display_info_set_bus_formats(&connector->display_info,\n\t\t\t\t\t &panel_info->bus_format, 1);\n\tconnector->display_info.bus_flags = panel_info->bus_flags;\n\n\treturn panel_info->num_modes;\n}\n\nstatic const struct drm_panel_funcs y030xx067a_funcs = {\n\t.prepare\t= y030xx067a_prepare,\n\t.unprepare\t= y030xx067a_unprepare,\n\t.enable\t\t= y030xx067a_enable,\n\t.disable\t= y030xx067a_disable,\n\t.get_modes\t= y030xx067a_get_modes,\n};\n\nstatic const struct regmap_config y030xx067a_regmap_config = {\n\t.reg_bits = 8,\n\t.val_bits = 8,\n\t.max_register = 0x15,\n\t.cache_type = REGCACHE_FLAT,\n};\n\nstatic int y030xx067a_probe(struct spi_device *spi)\n{\n\tstruct device *dev = &spi->dev;\n\tstruct y030xx067a *priv;\n\tint err;\n\n\tpriv = devm_kzalloc(dev, sizeof(*priv), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\n\tpriv->spi = spi;\n\tspi_set_drvdata(spi, priv);\n\n\tpriv->map = devm_regmap_init_spi(spi, &y030xx067a_regmap_config);\n\tif (IS_ERR(priv->map)) {\n\t\tdev_err(dev, \"Unable to init regmap\\n\");\n\t\treturn PTR_ERR(priv->map);\n\t}\n\n\tpriv->panel_info = of_device_get_match_data(dev);\n\tif (!priv->panel_info)\n\t\treturn -EINVAL;\n\n\tpriv->supply = devm_regulator_get(dev, \"power\");\n\tif (IS_ERR(priv->supply))\n\t\treturn dev_err_probe(dev, PTR_ERR(priv->supply),\n\t\t\t\t     \"Failed to get power supply\\n\");\n\n\tpriv->reset_gpio = devm_gpiod_get(dev, \"reset\", GPIOD_OUT_HIGH);\n\tif (IS_ERR(priv->reset_gpio))\n\t\treturn dev_err_probe(dev, PTR_ERR(priv->reset_gpio),\n\t\t\t\t     \"Failed to get reset GPIO\\n\");\n\n\tdrm_panel_init(&priv->panel, dev, &y030xx067a_funcs,\n\t\t       DRM_MODE_CONNECTOR_DPI);\n\n\terr = drm_panel_of_backlight(&priv->panel);\n\tif (err)\n\t\treturn err;\n\n\tdrm_panel_add(&priv->panel);\n\n\treturn 0;\n}\n\nstatic void y030xx067a_remove(struct spi_device *spi)\n{\n\tstruct y030xx067a *priv = spi_get_drvdata(spi);\n\n\tdrm_panel_remove(&priv->panel);\n\tdrm_panel_disable(&priv->panel);\n\tdrm_panel_unprepare(&priv->panel);\n}\n\nstatic const struct drm_display_mode y030xx067a_modes[] = {\n\t{  \n\t\t.clock = 14400,\n\t\t.hdisplay = 320,\n\t\t.hsync_start = 320 + 10,\n\t\t.hsync_end = 320 + 10 + 37,\n\t\t.htotal = 320 + 10 + 37 + 33,\n\t\t.vdisplay = 480,\n\t\t.vsync_start = 480 + 84,\n\t\t.vsync_end = 480 + 84 + 20,\n\t\t.vtotal = 480 + 84 + 20 + 16,\n\t\t.flags = DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_NVSYNC,\n\t},\n\t{  \n\t\t.clock = 12000,\n\t\t.hdisplay = 320,\n\t\t.hsync_start = 320 + 10,\n\t\t.hsync_end = 320 + 10 + 37,\n\t\t.htotal = 320 + 10 + 37 + 33,\n\t\t.vdisplay = 480,\n\t\t.vsync_start = 480 + 84,\n\t\t.vsync_end = 480 + 84 + 20,\n\t\t.vtotal = 480 + 84 + 20 + 16,\n\t\t.flags = DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_NVSYNC,\n\t},\n};\n\nstatic const struct y030xx067a_info y030xx067a_info = {\n\t.display_modes = y030xx067a_modes,\n\t.num_modes = ARRAY_SIZE(y030xx067a_modes),\n\t.width_mm = 69,\n\t.height_mm = 51,\n\t.bus_format = MEDIA_BUS_FMT_RGB888_3X8_DELTA,\n\t.bus_flags = DRM_BUS_FLAG_PIXDATA_SAMPLE_POSEDGE | DRM_BUS_FLAG_DE_LOW,\n};\n\nstatic const struct of_device_id y030xx067a_of_match[] = {\n\t{ .compatible = \"abt,y030xx067a\", .data = &y030xx067a_info },\n\t{   }\n};\nMODULE_DEVICE_TABLE(of, y030xx067a_of_match);\n\nstatic struct spi_driver y030xx067a_driver = {\n\t.driver = {\n\t\t.name = \"abt-y030xx067a\",\n\t\t.of_match_table = y030xx067a_of_match,\n\t},\n\t.probe = y030xx067a_probe,\n\t.remove = y030xx067a_remove,\n};\nmodule_spi_driver(y030xx067a_driver);\n\nMODULE_AUTHOR(\"Paul Cercueil <paul@crapouillou.net>\");\nMODULE_AUTHOR(\"Christophe Branchereau <cbranchereau@gmail.com>\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}