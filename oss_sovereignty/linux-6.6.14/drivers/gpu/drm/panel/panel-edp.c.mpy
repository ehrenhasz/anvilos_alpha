{
  "module_name": "panel-edp.c",
  "hash_id": "b88fd329d68175da2f6cf51ed855c5ad120dd75e6a3749b998fe5fcf19f9fd44",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/panel/panel-edp.c",
  "human_readable_source": " \n\n#include <linux/debugfs.h>\n#include <linux/delay.h>\n#include <linux/gpio/consumer.h>\n#include <linux/iopoll.h>\n#include <linux/module.h>\n#include <linux/of_platform.h>\n#include <linux/platform_device.h>\n#include <linux/pm_runtime.h>\n#include <linux/regulator/consumer.h>\n\n#include <video/display_timing.h>\n#include <video/of_display_timing.h>\n#include <video/videomode.h>\n\n#include <drm/display/drm_dp_aux_bus.h>\n#include <drm/display/drm_dp_helper.h>\n#include <drm/drm_crtc.h>\n#include <drm/drm_device.h>\n#include <drm/drm_edid.h>\n#include <drm/drm_panel.h>\n\n \nstruct panel_delay {\n\t \n\tunsigned int hpd_reliable;\n\n\t \n\tunsigned int hpd_absent;\n\n\t \n\tunsigned int prepare_to_enable;\n\n\t \n\tunsigned int enable;\n\n\t \n\tunsigned int disable;\n\n\t \n\tunsigned int unprepare;\n};\n\n \nstruct panel_desc {\n\t \n\tconst struct drm_display_mode *modes;\n\n\t \n\tunsigned int num_modes;\n\n\t \n\tconst struct display_timing *timings;\n\n\t \n\tunsigned int num_timings;\n\n\t \n\tunsigned int bpc;\n\n\t \n\tstruct {\n\t\t \n\t\tunsigned int width;\n\n\t\t \n\t\tunsigned int height;\n\t} size;\n\n\t \n\tstruct panel_delay delay;\n};\n\n \nstruct edp_panel_entry {\n\t \n\tu32 panel_id;\n\n\t \n\tconst struct panel_delay *delay;\n\n\t \n\tconst char *name;\n};\n\nstruct panel_edp {\n\tstruct drm_panel base;\n\tbool enabled;\n\tbool no_hpd;\n\n\tbool prepared;\n\n\tktime_t prepared_time;\n\tktime_t unprepared_time;\n\n\tconst struct panel_desc *desc;\n\n\tstruct regulator *supply;\n\tstruct i2c_adapter *ddc;\n\tstruct drm_dp_aux *aux;\n\n\tstruct gpio_desc *enable_gpio;\n\tstruct gpio_desc *hpd_gpio;\n\n\tconst struct edp_panel_entry *detected_panel;\n\n\tstruct edid *edid;\n\n\tstruct drm_display_mode override_mode;\n\n\tenum drm_panel_orientation orientation;\n};\n\nstatic inline struct panel_edp *to_panel_edp(struct drm_panel *panel)\n{\n\treturn container_of(panel, struct panel_edp, base);\n}\n\nstatic unsigned int panel_edp_get_timings_modes(struct panel_edp *panel,\n\t\t\t\t\t\tstruct drm_connector *connector)\n{\n\tstruct drm_display_mode *mode;\n\tunsigned int i, num = 0;\n\n\tfor (i = 0; i < panel->desc->num_timings; i++) {\n\t\tconst struct display_timing *dt = &panel->desc->timings[i];\n\t\tstruct videomode vm;\n\n\t\tvideomode_from_timing(dt, &vm);\n\t\tmode = drm_mode_create(connector->dev);\n\t\tif (!mode) {\n\t\t\tdev_err(panel->base.dev, \"failed to add mode %ux%u\\n\",\n\t\t\t\tdt->hactive.typ, dt->vactive.typ);\n\t\t\tcontinue;\n\t\t}\n\n\t\tdrm_display_mode_from_videomode(&vm, mode);\n\n\t\tmode->type |= DRM_MODE_TYPE_DRIVER;\n\n\t\tif (panel->desc->num_timings == 1)\n\t\t\tmode->type |= DRM_MODE_TYPE_PREFERRED;\n\n\t\tdrm_mode_probed_add(connector, mode);\n\t\tnum++;\n\t}\n\n\treturn num;\n}\n\nstatic unsigned int panel_edp_get_display_modes(struct panel_edp *panel,\n\t\t\t\t\t\tstruct drm_connector *connector)\n{\n\tstruct drm_display_mode *mode;\n\tunsigned int i, num = 0;\n\n\tfor (i = 0; i < panel->desc->num_modes; i++) {\n\t\tconst struct drm_display_mode *m = &panel->desc->modes[i];\n\n\t\tmode = drm_mode_duplicate(connector->dev, m);\n\t\tif (!mode) {\n\t\t\tdev_err(panel->base.dev, \"failed to add mode %ux%u@%u\\n\",\n\t\t\t\tm->hdisplay, m->vdisplay,\n\t\t\t\tdrm_mode_vrefresh(m));\n\t\t\tcontinue;\n\t\t}\n\n\t\tmode->type |= DRM_MODE_TYPE_DRIVER;\n\n\t\tif (panel->desc->num_modes == 1)\n\t\t\tmode->type |= DRM_MODE_TYPE_PREFERRED;\n\n\t\tdrm_mode_set_name(mode);\n\n\t\tdrm_mode_probed_add(connector, mode);\n\t\tnum++;\n\t}\n\n\treturn num;\n}\n\nstatic int panel_edp_get_non_edid_modes(struct panel_edp *panel,\n\t\t\t\t\tstruct drm_connector *connector)\n{\n\tstruct drm_display_mode *mode;\n\tbool has_override = panel->override_mode.type;\n\tunsigned int num = 0;\n\n\tif (!panel->desc)\n\t\treturn 0;\n\n\tif (has_override) {\n\t\tmode = drm_mode_duplicate(connector->dev,\n\t\t\t\t\t  &panel->override_mode);\n\t\tif (mode) {\n\t\t\tdrm_mode_probed_add(connector, mode);\n\t\t\tnum = 1;\n\t\t} else {\n\t\t\tdev_err(panel->base.dev, \"failed to add override mode\\n\");\n\t\t}\n\t}\n\n\t \n\tif (num == 0 && panel->desc->num_timings)\n\t\tnum = panel_edp_get_timings_modes(panel, connector);\n\n\t \n\tWARN_ON(panel->desc->num_timings && panel->desc->num_modes);\n\tif (num == 0)\n\t\tnum = panel_edp_get_display_modes(panel, connector);\n\n\tconnector->display_info.bpc = panel->desc->bpc;\n\tconnector->display_info.width_mm = panel->desc->size.width;\n\tconnector->display_info.height_mm = panel->desc->size.height;\n\n\treturn num;\n}\n\nstatic void panel_edp_wait(ktime_t start_ktime, unsigned int min_ms)\n{\n\tktime_t now_ktime, min_ktime;\n\n\tif (!min_ms)\n\t\treturn;\n\n\tmin_ktime = ktime_add(start_ktime, ms_to_ktime(min_ms));\n\tnow_ktime = ktime_get_boottime();\n\n\tif (ktime_before(now_ktime, min_ktime))\n\t\tmsleep(ktime_to_ms(ktime_sub(min_ktime, now_ktime)) + 1);\n}\n\nstatic int panel_edp_disable(struct drm_panel *panel)\n{\n\tstruct panel_edp *p = to_panel_edp(panel);\n\n\tif (!p->enabled)\n\t\treturn 0;\n\n\tif (p->desc->delay.disable)\n\t\tmsleep(p->desc->delay.disable);\n\n\tp->enabled = false;\n\n\treturn 0;\n}\n\nstatic int panel_edp_suspend(struct device *dev)\n{\n\tstruct panel_edp *p = dev_get_drvdata(dev);\n\n\tgpiod_set_value_cansleep(p->enable_gpio, 0);\n\tregulator_disable(p->supply);\n\tp->unprepared_time = ktime_get_boottime();\n\n\treturn 0;\n}\n\nstatic int panel_edp_unprepare(struct drm_panel *panel)\n{\n\tstruct panel_edp *p = to_panel_edp(panel);\n\tint ret;\n\n\t \n\tif (!p->prepared)\n\t\treturn 0;\n\n\tpm_runtime_mark_last_busy(panel->dev);\n\tret = pm_runtime_put_autosuspend(panel->dev);\n\tif (ret < 0)\n\t\treturn ret;\n\tp->prepared = false;\n\n\treturn 0;\n}\n\nstatic int panel_edp_get_hpd_gpio(struct device *dev, struct panel_edp *p)\n{\n\tp->hpd_gpio = devm_gpiod_get_optional(dev, \"hpd\", GPIOD_IN);\n\tif (IS_ERR(p->hpd_gpio))\n\t\treturn dev_err_probe(dev, PTR_ERR(p->hpd_gpio),\n\t\t\t\t     \"failed to get 'hpd' GPIO\\n\");\n\n\treturn 0;\n}\n\nstatic bool panel_edp_can_read_hpd(struct panel_edp *p)\n{\n\treturn !p->no_hpd && (p->hpd_gpio || (p->aux && p->aux->wait_hpd_asserted));\n}\n\nstatic int panel_edp_prepare_once(struct panel_edp *p)\n{\n\tstruct device *dev = p->base.dev;\n\tunsigned int delay;\n\tint err;\n\tint hpd_asserted;\n\tunsigned long hpd_wait_us;\n\n\tpanel_edp_wait(p->unprepared_time, p->desc->delay.unprepare);\n\n\terr = regulator_enable(p->supply);\n\tif (err < 0) {\n\t\tdev_err(dev, \"failed to enable supply: %d\\n\", err);\n\t\treturn err;\n\t}\n\n\tgpiod_set_value_cansleep(p->enable_gpio, 1);\n\n\tdelay = p->desc->delay.hpd_reliable;\n\tif (p->no_hpd)\n\t\tdelay = max(delay, p->desc->delay.hpd_absent);\n\tif (delay)\n\t\tmsleep(delay);\n\n\tif (panel_edp_can_read_hpd(p)) {\n\t\tif (p->desc->delay.hpd_absent)\n\t\t\thpd_wait_us = p->desc->delay.hpd_absent * 1000UL;\n\t\telse\n\t\t\thpd_wait_us = 2000000;\n\n\t\tif (p->hpd_gpio) {\n\t\t\terr = readx_poll_timeout(gpiod_get_value_cansleep,\n\t\t\t\t\t\t p->hpd_gpio, hpd_asserted,\n\t\t\t\t\t\t hpd_asserted, 1000, hpd_wait_us);\n\t\t\tif (hpd_asserted < 0)\n\t\t\t\terr = hpd_asserted;\n\t\t} else {\n\t\t\terr = p->aux->wait_hpd_asserted(p->aux, hpd_wait_us);\n\t\t}\n\n\t\tif (err) {\n\t\t\tif (err != -ETIMEDOUT)\n\t\t\t\tdev_err(dev,\n\t\t\t\t\t\"error waiting for hpd GPIO: %d\\n\", err);\n\t\t\tgoto error;\n\t\t}\n\t}\n\n\tp->prepared_time = ktime_get_boottime();\n\n\treturn 0;\n\nerror:\n\tgpiod_set_value_cansleep(p->enable_gpio, 0);\n\tregulator_disable(p->supply);\n\tp->unprepared_time = ktime_get_boottime();\n\n\treturn err;\n}\n\n \n#define MAX_PANEL_PREPARE_TRIES\t\t5\n\nstatic int panel_edp_resume(struct device *dev)\n{\n\tstruct panel_edp *p = dev_get_drvdata(dev);\n\tint ret;\n\tint try;\n\n\tfor (try = 0; try < MAX_PANEL_PREPARE_TRIES; try++) {\n\t\tret = panel_edp_prepare_once(p);\n\t\tif (ret != -ETIMEDOUT)\n\t\t\tbreak;\n\t}\n\n\tif (ret == -ETIMEDOUT)\n\t\tdev_err(dev, \"Prepare timeout after %d tries\\n\", try);\n\telse if (try)\n\t\tdev_warn(dev, \"Prepare needed %d retries\\n\", try);\n\n\treturn ret;\n}\n\nstatic int panel_edp_prepare(struct drm_panel *panel)\n{\n\tstruct panel_edp *p = to_panel_edp(panel);\n\tint ret;\n\n\t \n\tif (p->prepared)\n\t\treturn 0;\n\n\tret = pm_runtime_get_sync(panel->dev);\n\tif (ret < 0) {\n\t\tpm_runtime_put_autosuspend(panel->dev);\n\t\treturn ret;\n\t}\n\n\tp->prepared = true;\n\n\treturn 0;\n}\n\nstatic int panel_edp_enable(struct drm_panel *panel)\n{\n\tstruct panel_edp *p = to_panel_edp(panel);\n\tunsigned int delay;\n\n\tif (p->enabled)\n\t\treturn 0;\n\n\tdelay = p->desc->delay.enable;\n\n\t \n\tif (p->desc->delay.prepare_to_enable &&\n\t    !panel_edp_can_read_hpd(p) && !p->no_hpd)\n\t\tdelay = max(delay, p->desc->delay.prepare_to_enable);\n\n\tif (delay)\n\t\tmsleep(delay);\n\n\tpanel_edp_wait(p->prepared_time, p->desc->delay.prepare_to_enable);\n\n\tp->enabled = true;\n\n\treturn 0;\n}\n\nstatic int panel_edp_get_modes(struct drm_panel *panel,\n\t\t\t       struct drm_connector *connector)\n{\n\tstruct panel_edp *p = to_panel_edp(panel);\n\tint num = 0;\n\n\t \n\tif (p->ddc) {\n\t\tpm_runtime_get_sync(panel->dev);\n\n\t\tif (!p->edid)\n\t\t\tp->edid = drm_get_edid(connector, p->ddc);\n\n\t\tif (p->edid)\n\t\t\tnum += drm_add_edid_modes(connector, p->edid);\n\n\t\tpm_runtime_mark_last_busy(panel->dev);\n\t\tpm_runtime_put_autosuspend(panel->dev);\n\t}\n\n\t \n\tif (p->desc->num_timings || p->desc->num_modes)\n\t\tnum += panel_edp_get_non_edid_modes(p, connector);\n\telse if (!num)\n\t\tdev_warn(p->base.dev, \"No display modes\\n\");\n\n\t \n\tdrm_connector_set_panel_orientation(connector, p->orientation);\n\n\treturn num;\n}\n\nstatic int panel_edp_get_timings(struct drm_panel *panel,\n\t\t\t\t unsigned int num_timings,\n\t\t\t\t struct display_timing *timings)\n{\n\tstruct panel_edp *p = to_panel_edp(panel);\n\tunsigned int i;\n\n\tif (p->desc->num_timings < num_timings)\n\t\tnum_timings = p->desc->num_timings;\n\n\tif (timings)\n\t\tfor (i = 0; i < num_timings; i++)\n\t\t\ttimings[i] = p->desc->timings[i];\n\n\treturn p->desc->num_timings;\n}\n\nstatic enum drm_panel_orientation panel_edp_get_orientation(struct drm_panel *panel)\n{\n\tstruct panel_edp *p = to_panel_edp(panel);\n\n\treturn p->orientation;\n}\n\nstatic int detected_panel_show(struct seq_file *s, void *data)\n{\n\tstruct drm_panel *panel = s->private;\n\tstruct panel_edp *p = to_panel_edp(panel);\n\n\tif (IS_ERR(p->detected_panel))\n\t\tseq_puts(s, \"UNKNOWN\\n\");\n\telse if (!p->detected_panel)\n\t\tseq_puts(s, \"HARDCODED\\n\");\n\telse\n\t\tseq_printf(s, \"%s\\n\", p->detected_panel->name);\n\n\treturn 0;\n}\n\nDEFINE_SHOW_ATTRIBUTE(detected_panel);\n\nstatic void panel_edp_debugfs_init(struct drm_panel *panel, struct dentry *root)\n{\n\tdebugfs_create_file(\"detected_panel\", 0600, root, panel, &detected_panel_fops);\n}\n\nstatic const struct drm_panel_funcs panel_edp_funcs = {\n\t.disable = panel_edp_disable,\n\t.unprepare = panel_edp_unprepare,\n\t.prepare = panel_edp_prepare,\n\t.enable = panel_edp_enable,\n\t.get_modes = panel_edp_get_modes,\n\t.get_orientation = panel_edp_get_orientation,\n\t.get_timings = panel_edp_get_timings,\n\t.debugfs_init = panel_edp_debugfs_init,\n};\n\n#define PANEL_EDP_BOUNDS_CHECK(to_check, bounds, field) \\\n\t(to_check->field.typ >= bounds->field.min && \\\n\t to_check->field.typ <= bounds->field.max)\nstatic void panel_edp_parse_panel_timing_node(struct device *dev,\n\t\t\t\t\t      struct panel_edp *panel,\n\t\t\t\t\t      const struct display_timing *ot)\n{\n\tconst struct panel_desc *desc = panel->desc;\n\tstruct videomode vm;\n\tunsigned int i;\n\n\tif (WARN_ON(desc->num_modes)) {\n\t\tdev_err(dev, \"Reject override mode: panel has a fixed mode\\n\");\n\t\treturn;\n\t}\n\tif (WARN_ON(!desc->num_timings)) {\n\t\tdev_err(dev, \"Reject override mode: no timings specified\\n\");\n\t\treturn;\n\t}\n\n\tfor (i = 0; i < panel->desc->num_timings; i++) {\n\t\tconst struct display_timing *dt = &panel->desc->timings[i];\n\n\t\tif (!PANEL_EDP_BOUNDS_CHECK(ot, dt, hactive) ||\n\t\t    !PANEL_EDP_BOUNDS_CHECK(ot, dt, hfront_porch) ||\n\t\t    !PANEL_EDP_BOUNDS_CHECK(ot, dt, hback_porch) ||\n\t\t    !PANEL_EDP_BOUNDS_CHECK(ot, dt, hsync_len) ||\n\t\t    !PANEL_EDP_BOUNDS_CHECK(ot, dt, vactive) ||\n\t\t    !PANEL_EDP_BOUNDS_CHECK(ot, dt, vfront_porch) ||\n\t\t    !PANEL_EDP_BOUNDS_CHECK(ot, dt, vback_porch) ||\n\t\t    !PANEL_EDP_BOUNDS_CHECK(ot, dt, vsync_len))\n\t\t\tcontinue;\n\n\t\tif (ot->flags != dt->flags)\n\t\t\tcontinue;\n\n\t\tvideomode_from_timing(ot, &vm);\n\t\tdrm_display_mode_from_videomode(&vm, &panel->override_mode);\n\t\tpanel->override_mode.type |= DRM_MODE_TYPE_DRIVER |\n\t\t\t\t\t     DRM_MODE_TYPE_PREFERRED;\n\t\tbreak;\n\t}\n\n\tif (WARN_ON(!panel->override_mode.type))\n\t\tdev_err(dev, \"Reject override mode: No display_timing found\\n\");\n}\n\nstatic const struct edp_panel_entry *find_edp_panel(u32 panel_id);\n\nstatic int generic_edp_panel_probe(struct device *dev, struct panel_edp *panel)\n{\n\tstruct panel_desc *desc;\n\tu32 panel_id;\n\tchar vend[4];\n\tu16 product_id;\n\tu32 reliable_ms = 0;\n\tu32 absent_ms = 0;\n\tint ret;\n\n\tdesc = devm_kzalloc(dev, sizeof(*desc), GFP_KERNEL);\n\tif (!desc)\n\t\treturn -ENOMEM;\n\tpanel->desc = desc;\n\n\t \n\tof_property_read_u32(dev->of_node, \"hpd-reliable-delay-ms\", &reliable_ms);\n\tdesc->delay.hpd_reliable = reliable_ms;\n\tof_property_read_u32(dev->of_node, \"hpd-absent-delay-ms\", &absent_ms);\n\tdesc->delay.hpd_absent = absent_ms;\n\n\t \n\tret = pm_runtime_get_sync(dev);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"Couldn't power on panel to read EDID: %d\\n\", ret);\n\t\tgoto exit;\n\t}\n\n\tpanel_id = drm_edid_get_panel_id(panel->ddc);\n\tif (!panel_id) {\n\t\tdev_err(dev, \"Couldn't identify panel via EDID\\n\");\n\t\tret = -EIO;\n\t\tgoto exit;\n\t}\n\tdrm_edid_decode_panel_id(panel_id, vend, &product_id);\n\n\tpanel->detected_panel = find_edp_panel(panel_id);\n\n\t \n\tif (WARN_ON(!panel->detected_panel)) {\n\t\tdev_warn(dev,\n\t\t\t \"Unknown panel %s %#06x, using conservative timings\\n\",\n\t\t\t vend, product_id);\n\n\t\t \n\t\tdesc->delay.unprepare = 2000;\n\t\tdesc->delay.enable = 200;\n\n\t\tpanel->detected_panel = ERR_PTR(-EINVAL);\n\t} else {\n\t\tdev_info(dev, \"Detected %s %s (%#06x)\\n\",\n\t\t\t vend, panel->detected_panel->name, product_id);\n\n\t\t \n\t\tdesc->delay = *panel->detected_panel->delay;\n\t}\n\n\tret = 0;\nexit:\n\tpm_runtime_mark_last_busy(dev);\n\tpm_runtime_put_autosuspend(dev);\n\n\treturn ret;\n}\n\nstatic int panel_edp_probe(struct device *dev, const struct panel_desc *desc,\n\t\t\t   struct drm_dp_aux *aux)\n{\n\tstruct panel_edp *panel;\n\tstruct display_timing dt;\n\tstruct device_node *ddc;\n\tint err;\n\n\tpanel = devm_kzalloc(dev, sizeof(*panel), GFP_KERNEL);\n\tif (!panel)\n\t\treturn -ENOMEM;\n\n\tpanel->enabled = false;\n\tpanel->prepared_time = 0;\n\tpanel->desc = desc;\n\tpanel->aux = aux;\n\n\tpanel->no_hpd = of_property_read_bool(dev->of_node, \"no-hpd\");\n\tif (!panel->no_hpd) {\n\t\terr = panel_edp_get_hpd_gpio(dev, panel);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tpanel->supply = devm_regulator_get(dev, \"power\");\n\tif (IS_ERR(panel->supply))\n\t\treturn PTR_ERR(panel->supply);\n\n\tpanel->enable_gpio = devm_gpiod_get_optional(dev, \"enable\",\n\t\t\t\t\t\t     GPIOD_OUT_LOW);\n\tif (IS_ERR(panel->enable_gpio))\n\t\treturn dev_err_probe(dev, PTR_ERR(panel->enable_gpio),\n\t\t\t\t     \"failed to request GPIO\\n\");\n\n\terr = of_drm_get_panel_orientation(dev->of_node, &panel->orientation);\n\tif (err) {\n\t\tdev_err(dev, \"%pOF: failed to get orientation %d\\n\", dev->of_node, err);\n\t\treturn err;\n\t}\n\n\tddc = of_parse_phandle(dev->of_node, \"ddc-i2c-bus\", 0);\n\tif (ddc) {\n\t\tpanel->ddc = of_find_i2c_adapter_by_node(ddc);\n\t\tof_node_put(ddc);\n\n\t\tif (!panel->ddc)\n\t\t\treturn -EPROBE_DEFER;\n\t} else if (aux) {\n\t\tpanel->ddc = &aux->ddc;\n\t}\n\n\tif (!of_get_display_timing(dev->of_node, \"panel-timing\", &dt))\n\t\tpanel_edp_parse_panel_timing_node(dev, panel, &dt);\n\n\tdev_set_drvdata(dev, panel);\n\n\tdrm_panel_init(&panel->base, dev, &panel_edp_funcs, DRM_MODE_CONNECTOR_eDP);\n\n\terr = drm_panel_of_backlight(&panel->base);\n\tif (err)\n\t\tgoto err_finished_ddc_init;\n\n\t \n\tpm_runtime_enable(dev);\n\tpm_runtime_set_autosuspend_delay(dev, 1000);\n\tpm_runtime_use_autosuspend(dev);\n\n\tif (of_device_is_compatible(dev->of_node, \"edp-panel\")) {\n\t\terr = generic_edp_panel_probe(dev, panel);\n\t\tif (err) {\n\t\t\tdev_err_probe(dev, err,\n\t\t\t\t      \"Couldn't detect panel nor find a fallback\\n\");\n\t\t\tgoto err_finished_pm_runtime;\n\t\t}\n\t\t \n\t\tdesc = panel->desc;\n\t} else if (desc->bpc != 6 && desc->bpc != 8 && desc->bpc != 10) {\n\t\tdev_warn(dev, \"Expected bpc in {6,8,10} but got: %u\\n\", desc->bpc);\n\t}\n\n\tif (!panel->base.backlight && panel->aux) {\n\t\tpm_runtime_get_sync(dev);\n\t\terr = drm_panel_dp_aux_backlight(&panel->base, panel->aux);\n\t\tpm_runtime_mark_last_busy(dev);\n\t\tpm_runtime_put_autosuspend(dev);\n\t\tif (err)\n\t\t\tgoto err_finished_pm_runtime;\n\t}\n\n\tdrm_panel_add(&panel->base);\n\n\treturn 0;\n\nerr_finished_pm_runtime:\n\tpm_runtime_dont_use_autosuspend(dev);\n\tpm_runtime_disable(dev);\nerr_finished_ddc_init:\n\tif (panel->ddc && (!panel->aux || panel->ddc != &panel->aux->ddc))\n\t\tput_device(&panel->ddc->dev);\n\n\treturn err;\n}\n\nstatic void panel_edp_remove(struct device *dev)\n{\n\tstruct panel_edp *panel = dev_get_drvdata(dev);\n\n\tdrm_panel_remove(&panel->base);\n\tdrm_panel_disable(&panel->base);\n\tdrm_panel_unprepare(&panel->base);\n\n\tpm_runtime_dont_use_autosuspend(dev);\n\tpm_runtime_disable(dev);\n\tif (panel->ddc && (!panel->aux || panel->ddc != &panel->aux->ddc))\n\t\tput_device(&panel->ddc->dev);\n\n\tkfree(panel->edid);\n\tpanel->edid = NULL;\n}\n\nstatic void panel_edp_shutdown(struct device *dev)\n{\n\tstruct panel_edp *panel = dev_get_drvdata(dev);\n\n\tdrm_panel_disable(&panel->base);\n\tdrm_panel_unprepare(&panel->base);\n}\n\nstatic const struct display_timing auo_b101ean01_timing = {\n\t.pixelclock = { 65300000, 72500000, 75000000 },\n\t.hactive = { 1280, 1280, 1280 },\n\t.hfront_porch = { 18, 119, 119 },\n\t.hback_porch = { 21, 21, 21 },\n\t.hsync_len = { 32, 32, 32 },\n\t.vactive = { 800, 800, 800 },\n\t.vfront_porch = { 4, 4, 4 },\n\t.vback_porch = { 8, 8, 8 },\n\t.vsync_len = { 18, 20, 20 },\n};\n\nstatic const struct panel_desc auo_b101ean01 = {\n\t.timings = &auo_b101ean01_timing,\n\t.num_timings = 1,\n\t.bpc = 6,\n\t.size = {\n\t\t.width = 217,\n\t\t.height = 136,\n\t},\n};\n\nstatic const struct drm_display_mode auo_b116xak01_mode = {\n\t.clock = 69300,\n\t.hdisplay = 1366,\n\t.hsync_start = 1366 + 48,\n\t.hsync_end = 1366 + 48 + 32,\n\t.htotal = 1366 + 48 + 32 + 10,\n\t.vdisplay = 768,\n\t.vsync_start = 768 + 4,\n\t.vsync_end = 768 + 4 + 6,\n\t.vtotal = 768 + 4 + 6 + 15,\n\t.flags = DRM_MODE_FLAG_NVSYNC | DRM_MODE_FLAG_NHSYNC,\n};\n\nstatic const struct panel_desc auo_b116xak01 = {\n\t.modes = &auo_b116xak01_mode,\n\t.num_modes = 1,\n\t.bpc = 6,\n\t.size = {\n\t\t.width = 256,\n\t\t.height = 144,\n\t},\n\t.delay = {\n\t\t.hpd_absent = 200,\n\t},\n};\n\nstatic const struct drm_display_mode auo_b133han05_mode = {\n\t.clock = 142600,\n\t.hdisplay = 1920,\n\t.hsync_start = 1920 + 58,\n\t.hsync_end = 1920 + 58 + 42,\n\t.htotal = 1920 + 58 + 42 + 60,\n\t.vdisplay = 1080,\n\t.vsync_start = 1080 + 3,\n\t.vsync_end = 1080 + 3 + 5,\n\t.vtotal = 1080 + 3 + 5 + 54,\n};\n\nstatic const struct panel_desc auo_b133han05 = {\n\t.modes = &auo_b133han05_mode,\n\t.num_modes = 1,\n\t.bpc = 8,\n\t.size = {\n\t\t.width = 293,\n\t\t.height = 165,\n\t},\n\t.delay = {\n\t\t.hpd_reliable = 100,\n\t\t.enable = 20,\n\t\t.unprepare = 50,\n\t},\n};\n\nstatic const struct drm_display_mode auo_b133htn01_mode = {\n\t.clock = 150660,\n\t.hdisplay = 1920,\n\t.hsync_start = 1920 + 172,\n\t.hsync_end = 1920 + 172 + 80,\n\t.htotal = 1920 + 172 + 80 + 60,\n\t.vdisplay = 1080,\n\t.vsync_start = 1080 + 25,\n\t.vsync_end = 1080 + 25 + 10,\n\t.vtotal = 1080 + 25 + 10 + 10,\n};\n\nstatic const struct panel_desc auo_b133htn01 = {\n\t.modes = &auo_b133htn01_mode,\n\t.num_modes = 1,\n\t.bpc = 6,\n\t.size = {\n\t\t.width = 293,\n\t\t.height = 165,\n\t},\n\t.delay = {\n\t\t.hpd_reliable = 105,\n\t\t.enable = 20,\n\t\t.unprepare = 50,\n\t},\n};\n\nstatic const struct drm_display_mode auo_b133xtn01_mode = {\n\t.clock = 69500,\n\t.hdisplay = 1366,\n\t.hsync_start = 1366 + 48,\n\t.hsync_end = 1366 + 48 + 32,\n\t.htotal = 1366 + 48 + 32 + 20,\n\t.vdisplay = 768,\n\t.vsync_start = 768 + 3,\n\t.vsync_end = 768 + 3 + 6,\n\t.vtotal = 768 + 3 + 6 + 13,\n};\n\nstatic const struct panel_desc auo_b133xtn01 = {\n\t.modes = &auo_b133xtn01_mode,\n\t.num_modes = 1,\n\t.bpc = 6,\n\t.size = {\n\t\t.width = 293,\n\t\t.height = 165,\n\t},\n};\n\nstatic const struct drm_display_mode auo_b140han06_mode = {\n\t.clock = 141000,\n\t.hdisplay = 1920,\n\t.hsync_start = 1920 + 16,\n\t.hsync_end = 1920 + 16 + 16,\n\t.htotal = 1920 + 16 + 16 + 152,\n\t.vdisplay = 1080,\n\t.vsync_start = 1080 + 3,\n\t.vsync_end = 1080 + 3 + 14,\n\t.vtotal = 1080 + 3 + 14 + 19,\n};\n\nstatic const struct panel_desc auo_b140han06 = {\n\t.modes = &auo_b140han06_mode,\n\t.num_modes = 1,\n\t.bpc = 8,\n\t.size = {\n\t\t.width = 309,\n\t\t.height = 174,\n\t},\n\t.delay = {\n\t\t.hpd_reliable = 100,\n\t\t.enable = 20,\n\t\t.unprepare = 50,\n\t},\n};\n\nstatic const struct drm_display_mode boe_nv101wxmn51_modes[] = {\n\t{\n\t\t.clock = 71900,\n\t\t.hdisplay = 1280,\n\t\t.hsync_start = 1280 + 48,\n\t\t.hsync_end = 1280 + 48 + 32,\n\t\t.htotal = 1280 + 48 + 32 + 80,\n\t\t.vdisplay = 800,\n\t\t.vsync_start = 800 + 3,\n\t\t.vsync_end = 800 + 3 + 5,\n\t\t.vtotal = 800 + 3 + 5 + 24,\n\t},\n\t{\n\t\t.clock = 57500,\n\t\t.hdisplay = 1280,\n\t\t.hsync_start = 1280 + 48,\n\t\t.hsync_end = 1280 + 48 + 32,\n\t\t.htotal = 1280 + 48 + 32 + 80,\n\t\t.vdisplay = 800,\n\t\t.vsync_start = 800 + 3,\n\t\t.vsync_end = 800 + 3 + 5,\n\t\t.vtotal = 800 + 3 + 5 + 24,\n\t},\n};\n\nstatic const struct panel_desc boe_nv101wxmn51 = {\n\t.modes = boe_nv101wxmn51_modes,\n\t.num_modes = ARRAY_SIZE(boe_nv101wxmn51_modes),\n\t.bpc = 8,\n\t.size = {\n\t\t.width = 217,\n\t\t.height = 136,\n\t},\n\t.delay = {\n\t\t \n\t\t.hpd_reliable = 210,\n\t\t.enable = 50,\n\t\t.unprepare = 160,\n\t},\n};\n\nstatic const struct drm_display_mode boe_nv110wtm_n61_modes[] = {\n\t{\n\t\t.clock = 207800,\n\t\t.hdisplay = 2160,\n\t\t.hsync_start = 2160 + 48,\n\t\t.hsync_end = 2160 + 48 + 32,\n\t\t.htotal = 2160 + 48 + 32 + 100,\n\t\t.vdisplay = 1440,\n\t\t.vsync_start = 1440 + 3,\n\t\t.vsync_end = 1440 + 3 + 6,\n\t\t.vtotal = 1440 + 3 + 6 + 31,\n\t\t.flags = DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_NVSYNC,\n\t},\n\t{\n\t\t.clock = 138500,\n\t\t.hdisplay = 2160,\n\t\t.hsync_start = 2160 + 48,\n\t\t.hsync_end = 2160 + 48 + 32,\n\t\t.htotal = 2160 + 48 + 32 + 100,\n\t\t.vdisplay = 1440,\n\t\t.vsync_start = 1440 + 3,\n\t\t.vsync_end = 1440 + 3 + 6,\n\t\t.vtotal = 1440 + 3 + 6 + 31,\n\t\t.flags = DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_NVSYNC,\n\t},\n};\n\nstatic const struct panel_desc boe_nv110wtm_n61 = {\n\t.modes = boe_nv110wtm_n61_modes,\n\t.num_modes = ARRAY_SIZE(boe_nv110wtm_n61_modes),\n\t.bpc = 8,\n\t.size = {\n\t\t.width = 233,\n\t\t.height = 155,\n\t},\n\t.delay = {\n\t\t.hpd_absent = 200,\n\t\t.prepare_to_enable = 80,\n\t\t.enable = 50,\n\t\t.unprepare = 500,\n\t},\n};\n\n \nstatic const struct drm_display_mode boe_nv133fhm_n61_modes = {\n\t.clock = 147840,\n\t.hdisplay = 1920,\n\t.hsync_start = 1920 + 48,\n\t.hsync_end = 1920 + 48 + 32,\n\t.htotal = 1920 + 48 + 32 + 200,\n\t.vdisplay = 1080,\n\t.vsync_start = 1080 + 3,\n\t.vsync_end = 1080 + 3 + 6,\n\t.vtotal = 1080 + 3 + 6 + 31,\n\t.flags = DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_NVSYNC,\n};\n\n \nstatic const struct panel_desc boe_nv133fhm_n61 = {\n\t.modes = &boe_nv133fhm_n61_modes,\n\t.num_modes = 1,\n\t.bpc = 6,\n\t.size = {\n\t\t.width = 294,\n\t\t.height = 165,\n\t},\n\t.delay = {\n\t\t \n\t\t.hpd_reliable = 15,\n\t\t.hpd_absent = 200,\n\n\t\t.unprepare = 500,\n\t},\n};\n\nstatic const struct drm_display_mode boe_nv140fhmn49_modes[] = {\n\t{\n\t\t.clock = 148500,\n\t\t.hdisplay = 1920,\n\t\t.hsync_start = 1920 + 48,\n\t\t.hsync_end = 1920 + 48 + 32,\n\t\t.htotal = 2200,\n\t\t.vdisplay = 1080,\n\t\t.vsync_start = 1080 + 3,\n\t\t.vsync_end = 1080 + 3 + 5,\n\t\t.vtotal = 1125,\n\t},\n};\n\nstatic const struct panel_desc boe_nv140fhmn49 = {\n\t.modes = boe_nv140fhmn49_modes,\n\t.num_modes = ARRAY_SIZE(boe_nv140fhmn49_modes),\n\t.bpc = 6,\n\t.size = {\n\t\t.width = 309,\n\t\t.height = 174,\n\t},\n\t.delay = {\n\t\t \n\t\t.hpd_reliable = 210,\n\t\t.enable = 50,\n\t\t.unprepare = 160,\n\t},\n};\n\nstatic const struct drm_display_mode innolux_n116bca_ea1_mode = {\n\t.clock = 76420,\n\t.hdisplay = 1366,\n\t.hsync_start = 1366 + 136,\n\t.hsync_end = 1366 + 136 + 30,\n\t.htotal = 1366 + 136 + 30 + 60,\n\t.vdisplay = 768,\n\t.vsync_start = 768 + 8,\n\t.vsync_end = 768 + 8 + 12,\n\t.vtotal = 768 + 8 + 12 + 12,\n\t.flags = DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_NVSYNC,\n};\n\nstatic const struct panel_desc innolux_n116bca_ea1 = {\n\t.modes = &innolux_n116bca_ea1_mode,\n\t.num_modes = 1,\n\t.bpc = 6,\n\t.size = {\n\t\t.width = 256,\n\t\t.height = 144,\n\t},\n\t.delay = {\n\t\t.hpd_absent = 200,\n\t\t.enable = 80,\n\t\t.disable = 50,\n\t\t.unprepare = 500,\n\t},\n};\n\n \nstatic const struct display_timing innolux_n116bge_timing = {\n\t.pixelclock = { 72600000, 76420000, 80240000 },\n\t.hactive = { 1366, 1366, 1366 },\n\t.hfront_porch = { 136, 136, 136 },\n\t.hback_porch = { 60, 60, 60 },\n\t.hsync_len = { 30, 30, 30 },\n\t.vactive = { 768, 768, 768 },\n\t.vfront_porch = { 8, 8, 8 },\n\t.vback_porch = { 12, 12, 12 },\n\t.vsync_len = { 12, 12, 12 },\n\t.flags = DISPLAY_FLAGS_VSYNC_LOW | DISPLAY_FLAGS_HSYNC_LOW,\n};\n\nstatic const struct panel_desc innolux_n116bge = {\n\t.timings = &innolux_n116bge_timing,\n\t.num_timings = 1,\n\t.bpc = 6,\n\t.size = {\n\t\t.width = 256,\n\t\t.height = 144,\n\t},\n};\n\nstatic const struct drm_display_mode innolux_n125hce_gn1_mode = {\n\t.clock = 162000,\n\t.hdisplay = 1920,\n\t.hsync_start = 1920 + 40,\n\t.hsync_end = 1920 + 40 + 40,\n\t.htotal = 1920 + 40 + 40 + 80,\n\t.vdisplay = 1080,\n\t.vsync_start = 1080 + 4,\n\t.vsync_end = 1080 + 4 + 4,\n\t.vtotal = 1080 + 4 + 4 + 24,\n};\n\nstatic const struct panel_desc innolux_n125hce_gn1 = {\n\t.modes = &innolux_n125hce_gn1_mode,\n\t.num_modes = 1,\n\t.bpc = 8,\n\t.size = {\n\t\t.width = 276,\n\t\t.height = 155,\n\t},\n};\n\nstatic const struct drm_display_mode innolux_p120zdg_bf1_mode = {\n\t.clock = 206016,\n\t.hdisplay = 2160,\n\t.hsync_start = 2160 + 48,\n\t.hsync_end = 2160 + 48 + 32,\n\t.htotal = 2160 + 48 + 32 + 80,\n\t.vdisplay = 1440,\n\t.vsync_start = 1440 + 3,\n\t.vsync_end = 1440 + 3 + 10,\n\t.vtotal = 1440 + 3 + 10 + 27,\n\t.flags = DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC,\n};\n\nstatic const struct panel_desc innolux_p120zdg_bf1 = {\n\t.modes = &innolux_p120zdg_bf1_mode,\n\t.num_modes = 1,\n\t.bpc = 8,\n\t.size = {\n\t\t.width = 254,\n\t\t.height = 169,\n\t},\n\t.delay = {\n\t\t.hpd_absent = 200,\n\t\t.unprepare = 500,\n\t},\n};\n\nstatic const struct drm_display_mode ivo_m133nwf4_r0_mode = {\n\t.clock = 138778,\n\t.hdisplay = 1920,\n\t.hsync_start = 1920 + 24,\n\t.hsync_end = 1920 + 24 + 48,\n\t.htotal = 1920 + 24 + 48 + 88,\n\t.vdisplay = 1080,\n\t.vsync_start = 1080 + 3,\n\t.vsync_end = 1080 + 3 + 12,\n\t.vtotal = 1080 + 3 + 12 + 17,\n\t.flags = DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC,\n};\n\nstatic const struct panel_desc ivo_m133nwf4_r0 = {\n\t.modes = &ivo_m133nwf4_r0_mode,\n\t.num_modes = 1,\n\t.bpc = 8,\n\t.size = {\n\t\t.width = 294,\n\t\t.height = 165,\n\t},\n\t.delay = {\n\t\t.hpd_absent = 200,\n\t\t.unprepare = 500,\n\t},\n};\n\nstatic const struct drm_display_mode kingdisplay_kd116n21_30nv_a010_mode = {\n\t.clock = 81000,\n\t.hdisplay = 1366,\n\t.hsync_start = 1366 + 40,\n\t.hsync_end = 1366 + 40 + 32,\n\t.htotal = 1366 + 40 + 32 + 62,\n\t.vdisplay = 768,\n\t.vsync_start = 768 + 5,\n\t.vsync_end = 768 + 5 + 5,\n\t.vtotal = 768 + 5 + 5 + 122,\n\t.flags = DRM_MODE_FLAG_NVSYNC | DRM_MODE_FLAG_NHSYNC,\n};\n\nstatic const struct panel_desc kingdisplay_kd116n21_30nv_a010 = {\n\t.modes = &kingdisplay_kd116n21_30nv_a010_mode,\n\t.num_modes = 1,\n\t.bpc = 6,\n\t.size = {\n\t\t.width = 256,\n\t\t.height = 144,\n\t},\n\t.delay = {\n\t\t.hpd_absent = 200,\n\t},\n};\n\nstatic const struct drm_display_mode lg_lp079qx1_sp0v_mode = {\n\t.clock = 200000,\n\t.hdisplay = 1536,\n\t.hsync_start = 1536 + 12,\n\t.hsync_end = 1536 + 12 + 16,\n\t.htotal = 1536 + 12 + 16 + 48,\n\t.vdisplay = 2048,\n\t.vsync_start = 2048 + 8,\n\t.vsync_end = 2048 + 8 + 4,\n\t.vtotal = 2048 + 8 + 4 + 8,\n\t.flags = DRM_MODE_FLAG_NVSYNC | DRM_MODE_FLAG_NHSYNC,\n};\n\nstatic const struct panel_desc lg_lp079qx1_sp0v = {\n\t.modes = &lg_lp079qx1_sp0v_mode,\n\t.num_modes = 1,\n\t.size = {\n\t\t.width = 129,\n\t\t.height = 171,\n\t},\n};\n\nstatic const struct drm_display_mode lg_lp097qx1_spa1_mode = {\n\t.clock = 205210,\n\t.hdisplay = 2048,\n\t.hsync_start = 2048 + 150,\n\t.hsync_end = 2048 + 150 + 5,\n\t.htotal = 2048 + 150 + 5 + 5,\n\t.vdisplay = 1536,\n\t.vsync_start = 1536 + 3,\n\t.vsync_end = 1536 + 3 + 1,\n\t.vtotal = 1536 + 3 + 1 + 9,\n};\n\nstatic const struct panel_desc lg_lp097qx1_spa1 = {\n\t.modes = &lg_lp097qx1_spa1_mode,\n\t.num_modes = 1,\n\t.size = {\n\t\t.width = 208,\n\t\t.height = 147,\n\t},\n};\n\nstatic const struct drm_display_mode lg_lp120up1_mode = {\n\t.clock = 162300,\n\t.hdisplay = 1920,\n\t.hsync_start = 1920 + 40,\n\t.hsync_end = 1920 + 40 + 40,\n\t.htotal = 1920 + 40 + 40 + 80,\n\t.vdisplay = 1280,\n\t.vsync_start = 1280 + 4,\n\t.vsync_end = 1280 + 4 + 4,\n\t.vtotal = 1280 + 4 + 4 + 12,\n};\n\nstatic const struct panel_desc lg_lp120up1 = {\n\t.modes = &lg_lp120up1_mode,\n\t.num_modes = 1,\n\t.bpc = 8,\n\t.size = {\n\t\t.width = 267,\n\t\t.height = 183,\n\t},\n};\n\nstatic const struct drm_display_mode lg_lp129qe_mode = {\n\t.clock = 285250,\n\t.hdisplay = 2560,\n\t.hsync_start = 2560 + 48,\n\t.hsync_end = 2560 + 48 + 32,\n\t.htotal = 2560 + 48 + 32 + 80,\n\t.vdisplay = 1700,\n\t.vsync_start = 1700 + 3,\n\t.vsync_end = 1700 + 3 + 10,\n\t.vtotal = 1700 + 3 + 10 + 36,\n};\n\nstatic const struct panel_desc lg_lp129qe = {\n\t.modes = &lg_lp129qe_mode,\n\t.num_modes = 1,\n\t.bpc = 8,\n\t.size = {\n\t\t.width = 272,\n\t\t.height = 181,\n\t},\n};\n\nstatic const struct drm_display_mode neweast_wjfh116008a_modes[] = {\n\t{\n\t\t.clock = 138500,\n\t\t.hdisplay = 1920,\n\t\t.hsync_start = 1920 + 48,\n\t\t.hsync_end = 1920 + 48 + 32,\n\t\t.htotal = 1920 + 48 + 32 + 80,\n\t\t.vdisplay = 1080,\n\t\t.vsync_start = 1080 + 3,\n\t\t.vsync_end = 1080 + 3 + 5,\n\t\t.vtotal = 1080 + 3 + 5 + 23,\n\t\t.flags = DRM_MODE_FLAG_NVSYNC | DRM_MODE_FLAG_NHSYNC,\n\t}, {\n\t\t.clock = 110920,\n\t\t.hdisplay = 1920,\n\t\t.hsync_start = 1920 + 48,\n\t\t.hsync_end = 1920 + 48 + 32,\n\t\t.htotal = 1920 + 48 + 32 + 80,\n\t\t.vdisplay = 1080,\n\t\t.vsync_start = 1080 + 3,\n\t\t.vsync_end = 1080 + 3 + 5,\n\t\t.vtotal = 1080 + 3 + 5 + 23,\n\t\t.flags = DRM_MODE_FLAG_NVSYNC | DRM_MODE_FLAG_NHSYNC,\n\t}\n};\n\nstatic const struct panel_desc neweast_wjfh116008a = {\n\t.modes = neweast_wjfh116008a_modes,\n\t.num_modes = 2,\n\t.bpc = 6,\n\t.size = {\n\t\t.width = 260,\n\t\t.height = 150,\n\t},\n\t.delay = {\n\t\t.hpd_reliable = 110,\n\t\t.enable = 20,\n\t\t.unprepare = 500,\n\t},\n};\n\nstatic const struct drm_display_mode samsung_lsn122dl01_c01_mode = {\n\t.clock = 271560,\n\t.hdisplay = 2560,\n\t.hsync_start = 2560 + 48,\n\t.hsync_end = 2560 + 48 + 32,\n\t.htotal = 2560 + 48 + 32 + 80,\n\t.vdisplay = 1600,\n\t.vsync_start = 1600 + 2,\n\t.vsync_end = 1600 + 2 + 5,\n\t.vtotal = 1600 + 2 + 5 + 57,\n};\n\nstatic const struct panel_desc samsung_lsn122dl01_c01 = {\n\t.modes = &samsung_lsn122dl01_c01_mode,\n\t.num_modes = 1,\n\t.size = {\n\t\t.width = 263,\n\t\t.height = 164,\n\t},\n};\n\nstatic const struct drm_display_mode samsung_ltn140at29_301_mode = {\n\t.clock = 76300,\n\t.hdisplay = 1366,\n\t.hsync_start = 1366 + 64,\n\t.hsync_end = 1366 + 64 + 48,\n\t.htotal = 1366 + 64 + 48 + 128,\n\t.vdisplay = 768,\n\t.vsync_start = 768 + 2,\n\t.vsync_end = 768 + 2 + 5,\n\t.vtotal = 768 + 2 + 5 + 17,\n};\n\nstatic const struct panel_desc samsung_ltn140at29_301 = {\n\t.modes = &samsung_ltn140at29_301_mode,\n\t.num_modes = 1,\n\t.bpc = 6,\n\t.size = {\n\t\t.width = 320,\n\t\t.height = 187,\n\t},\n};\n\nstatic const struct drm_display_mode sharp_ld_d5116z01b_mode = {\n\t.clock = 168480,\n\t.hdisplay = 1920,\n\t.hsync_start = 1920 + 48,\n\t.hsync_end = 1920 + 48 + 32,\n\t.htotal = 1920 + 48 + 32 + 80,\n\t.vdisplay = 1280,\n\t.vsync_start = 1280 + 3,\n\t.vsync_end = 1280 + 3 + 10,\n\t.vtotal = 1280 + 3 + 10 + 57,\n\t.flags = DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC,\n};\n\nstatic const struct panel_desc sharp_ld_d5116z01b = {\n\t.modes = &sharp_ld_d5116z01b_mode,\n\t.num_modes = 1,\n\t.bpc = 8,\n\t.size = {\n\t\t.width = 260,\n\t\t.height = 120,\n\t},\n};\n\nstatic const struct display_timing sharp_lq123p1jx31_timing = {\n\t.pixelclock = { 252750000, 252750000, 266604720 },\n\t.hactive = { 2400, 2400, 2400 },\n\t.hfront_porch = { 48, 48, 48 },\n\t.hback_porch = { 80, 80, 84 },\n\t.hsync_len = { 32, 32, 32 },\n\t.vactive = { 1600, 1600, 1600 },\n\t.vfront_porch = { 3, 3, 3 },\n\t.vback_porch = { 33, 33, 120 },\n\t.vsync_len = { 10, 10, 10 },\n\t.flags = DISPLAY_FLAGS_VSYNC_LOW | DISPLAY_FLAGS_HSYNC_LOW,\n};\n\nstatic const struct panel_desc sharp_lq123p1jx31 = {\n\t.timings = &sharp_lq123p1jx31_timing,\n\t.num_timings = 1,\n\t.bpc = 8,\n\t.size = {\n\t\t.width = 259,\n\t\t.height = 173,\n\t},\n\t.delay = {\n\t\t.hpd_reliable = 110,\n\t\t.enable = 50,\n\t\t.unprepare = 550,\n\t},\n};\n\nstatic const struct drm_display_mode sharp_lq140m1jw46_mode[] = {\n\t{\n\t\t.clock = 346500,\n\t\t.hdisplay = 1920,\n\t\t.hsync_start = 1920 + 48,\n\t\t.hsync_end = 1920 + 48 + 32,\n\t\t.htotal = 1920 + 48 + 32 + 80,\n\t\t.vdisplay = 1080,\n\t\t.vsync_start = 1080 + 3,\n\t\t.vsync_end = 1080 + 3 + 5,\n\t\t.vtotal = 1080 + 3 + 5 + 69,\n\t\t.flags = DRM_MODE_FLAG_NVSYNC | DRM_MODE_FLAG_NHSYNC,\n\t}, {\n\t\t.clock = 144370,\n\t\t.hdisplay = 1920,\n\t\t.hsync_start = 1920 + 48,\n\t\t.hsync_end = 1920 + 48 + 32,\n\t\t.htotal = 1920 + 48 + 32 + 80,\n\t\t.vdisplay = 1080,\n\t\t.vsync_start = 1080 + 3,\n\t\t.vsync_end = 1080 + 3 + 5,\n\t\t.vtotal = 1080 + 3 + 5 + 69,\n\t\t.flags = DRM_MODE_FLAG_NVSYNC | DRM_MODE_FLAG_NHSYNC,\n\t},\n};\n\nstatic const struct panel_desc sharp_lq140m1jw46 = {\n\t.modes = sharp_lq140m1jw46_mode,\n\t.num_modes = ARRAY_SIZE(sharp_lq140m1jw46_mode),\n\t.bpc = 8,\n\t.size = {\n\t\t.width = 309,\n\t\t.height = 174,\n\t},\n\t.delay = {\n\t\t.hpd_absent = 80,\n\t\t.enable = 50,\n\t\t.unprepare = 500,\n\t},\n};\n\nstatic const struct drm_display_mode starry_kr122ea0sra_mode = {\n\t.clock = 147000,\n\t.hdisplay = 1920,\n\t.hsync_start = 1920 + 16,\n\t.hsync_end = 1920 + 16 + 16,\n\t.htotal = 1920 + 16 + 16 + 32,\n\t.vdisplay = 1200,\n\t.vsync_start = 1200 + 15,\n\t.vsync_end = 1200 + 15 + 2,\n\t.vtotal = 1200 + 15 + 2 + 18,\n\t.flags = DRM_MODE_FLAG_NVSYNC | DRM_MODE_FLAG_NHSYNC,\n};\n\nstatic const struct panel_desc starry_kr122ea0sra = {\n\t.modes = &starry_kr122ea0sra_mode,\n\t.num_modes = 1,\n\t.size = {\n\t\t.width = 263,\n\t\t.height = 164,\n\t},\n\t.delay = {\n\t\t \n\t\t.hpd_reliable = 10 + 200,\n\t\t.enable = 50,\n\t\t.unprepare = 10 + 500,\n\t},\n};\n\nstatic const struct of_device_id platform_of_match[] = {\n\t{\n\t\t \n\t\t.compatible = \"edp-panel\",\n\t}, {\n\t\t.compatible = \"auo,b101ean01\",\n\t\t.data = &auo_b101ean01,\n\t}, {\n\t\t.compatible = \"auo,b116xa01\",\n\t\t.data = &auo_b116xak01,\n\t}, {\n\t\t.compatible = \"auo,b133han05\",\n\t\t.data = &auo_b133han05,\n\t}, {\n\t\t.compatible = \"auo,b133htn01\",\n\t\t.data = &auo_b133htn01,\n\t}, {\n\t\t.compatible = \"auo,b133xtn01\",\n\t\t.data = &auo_b133xtn01,\n\t}, {\n\t\t.compatible = \"auo,b140han06\",\n\t\t.data = &auo_b140han06,\n\t}, {\n\t\t.compatible = \"boe,nv101wxmn51\",\n\t\t.data = &boe_nv101wxmn51,\n\t}, {\n\t\t.compatible = \"boe,nv110wtm-n61\",\n\t\t.data = &boe_nv110wtm_n61,\n\t}, {\n\t\t.compatible = \"boe,nv133fhm-n61\",\n\t\t.data = &boe_nv133fhm_n61,\n\t}, {\n\t\t.compatible = \"boe,nv133fhm-n62\",\n\t\t.data = &boe_nv133fhm_n61,\n\t}, {\n\t\t.compatible = \"boe,nv140fhmn49\",\n\t\t.data = &boe_nv140fhmn49,\n\t}, {\n\t\t.compatible = \"innolux,n116bca-ea1\",\n\t\t.data = &innolux_n116bca_ea1,\n\t}, {\n\t\t.compatible = \"innolux,n116bge\",\n\t\t.data = &innolux_n116bge,\n\t}, {\n\t\t.compatible = \"innolux,n125hce-gn1\",\n\t\t.data = &innolux_n125hce_gn1,\n\t}, {\n\t\t.compatible = \"innolux,p120zdg-bf1\",\n\t\t.data = &innolux_p120zdg_bf1,\n\t}, {\n\t\t.compatible = \"ivo,m133nwf4-r0\",\n\t\t.data = &ivo_m133nwf4_r0,\n\t}, {\n\t\t.compatible = \"kingdisplay,kd116n21-30nv-a010\",\n\t\t.data = &kingdisplay_kd116n21_30nv_a010,\n\t}, {\n\t\t.compatible = \"lg,lp079qx1-sp0v\",\n\t\t.data = &lg_lp079qx1_sp0v,\n\t}, {\n\t\t.compatible = \"lg,lp097qx1-spa1\",\n\t\t.data = &lg_lp097qx1_spa1,\n\t}, {\n\t\t.compatible = \"lg,lp120up1\",\n\t\t.data = &lg_lp120up1,\n\t}, {\n\t\t.compatible = \"lg,lp129qe\",\n\t\t.data = &lg_lp129qe,\n\t}, {\n\t\t.compatible = \"neweast,wjfh116008a\",\n\t\t.data = &neweast_wjfh116008a,\n\t}, {\n\t\t.compatible = \"samsung,lsn122dl01-c01\",\n\t\t.data = &samsung_lsn122dl01_c01,\n\t}, {\n\t\t.compatible = \"samsung,ltn140at29-301\",\n\t\t.data = &samsung_ltn140at29_301,\n\t}, {\n\t\t.compatible = \"sharp,ld-d5116z01b\",\n\t\t.data = &sharp_ld_d5116z01b,\n\t}, {\n\t\t.compatible = \"sharp,lq123p1jx31\",\n\t\t.data = &sharp_lq123p1jx31,\n\t}, {\n\t\t.compatible = \"sharp,lq140m1jw46\",\n\t\t.data = &sharp_lq140m1jw46,\n\t}, {\n\t\t.compatible = \"starry,kr122ea0sra\",\n\t\t.data = &starry_kr122ea0sra,\n\t}, {\n\t\t \n\t}\n};\nMODULE_DEVICE_TABLE(of, platform_of_match);\n\nstatic const struct panel_delay delay_200_500_p2e80 = {\n\t.hpd_absent = 200,\n\t.unprepare = 500,\n\t.prepare_to_enable = 80,\n};\n\nstatic const struct panel_delay delay_200_500_p2e100 = {\n\t.hpd_absent = 200,\n\t.unprepare = 500,\n\t.prepare_to_enable = 100,\n};\n\nstatic const struct panel_delay delay_200_500_e50 = {\n\t.hpd_absent = 200,\n\t.unprepare = 500,\n\t.enable = 50,\n};\n\nstatic const struct panel_delay delay_200_500_e80_d50 = {\n\t.hpd_absent = 200,\n\t.unprepare = 500,\n\t.enable = 80,\n\t.disable = 50,\n};\n\nstatic const struct panel_delay delay_100_500_e200 = {\n\t.hpd_absent = 100,\n\t.unprepare = 500,\n\t.enable = 200,\n};\n\nstatic const struct panel_delay delay_200_500_e200 = {\n\t.hpd_absent = 200,\n\t.unprepare = 500,\n\t.enable = 200,\n};\n\n#define EDP_PANEL_ENTRY(vend_chr_0, vend_chr_1, vend_chr_2, product_id, _delay, _name) \\\n{ \\\n\t.name = _name, \\\n\t.panel_id = drm_edid_encode_panel_id(vend_chr_0, vend_chr_1, vend_chr_2, \\\n\t\t\t\t\t     product_id), \\\n\t.delay = _delay \\\n}\n\n \nstatic const struct edp_panel_entry edp_panels[] = {\n\tEDP_PANEL_ENTRY('A', 'U', 'O', 0x1062, &delay_200_500_e50, \"B120XAN01.0\"),\n\tEDP_PANEL_ENTRY('A', 'U', 'O', 0x145c, &delay_200_500_e50, \"B116XAB01.4\"),\n\tEDP_PANEL_ENTRY('A', 'U', 'O', 0x1e9b, &delay_200_500_e50, \"B133UAN02.1\"),\n\tEDP_PANEL_ENTRY('A', 'U', 'O', 0x1ea5, &delay_200_500_e50, \"B116XAK01.6\"),\n\tEDP_PANEL_ENTRY('A', 'U', 'O', 0x405c, &auo_b116xak01.delay, \"B116XAK01\"),\n\tEDP_PANEL_ENTRY('A', 'U', 'O', 0x582d, &delay_200_500_e50, \"B133UAN01.0\"),\n\tEDP_PANEL_ENTRY('A', 'U', 'O', 0x615c, &delay_200_500_e50, \"B116XAN06.1\"),\n\tEDP_PANEL_ENTRY('A', 'U', 'O', 0x8594, &delay_200_500_e50, \"B133UAN01.0\"),\n\n\tEDP_PANEL_ENTRY('B', 'O', 'E', 0x0786, &delay_200_500_p2e80, \"NV116WHM-T01\"),\n\tEDP_PANEL_ENTRY('B', 'O', 'E', 0x07d1, &boe_nv133fhm_n61.delay, \"NV133FHM-N61\"),\n\tEDP_PANEL_ENTRY('B', 'O', 'E', 0x082d, &boe_nv133fhm_n61.delay, \"NV133FHM-N62\"),\n\tEDP_PANEL_ENTRY('B', 'O', 'E', 0x094b, &delay_200_500_e50, \"NT116WHM-N21\"),\n\tEDP_PANEL_ENTRY('B', 'O', 'E', 0x095f, &delay_200_500_e50, \"NE135FBM-N41 v8.1\"),\n\tEDP_PANEL_ENTRY('B', 'O', 'E', 0x098d, &boe_nv110wtm_n61.delay, \"NV110WTM-N61\"),\n\tEDP_PANEL_ENTRY('B', 'O', 'E', 0x09dd, &delay_200_500_e50, \"NT116WHM-N21\"),\n\tEDP_PANEL_ENTRY('B', 'O', 'E', 0x0a5d, &delay_200_500_e50, \"NV116WHM-N45\"),\n\tEDP_PANEL_ENTRY('B', 'O', 'E', 0x0ac5, &delay_200_500_e50, \"NV116WHM-N4C\"),\n\n\tEDP_PANEL_ENTRY('C', 'M', 'N', 0x1139, &delay_200_500_e80_d50, \"N116BGE-EA2\"),\n\tEDP_PANEL_ENTRY('C', 'M', 'N', 0x114c, &innolux_n116bca_ea1.delay, \"N116BCA-EA1\"),\n\tEDP_PANEL_ENTRY('C', 'M', 'N', 0x1152, &delay_200_500_e80_d50, \"N116BCN-EA1\"),\n\tEDP_PANEL_ENTRY('C', 'M', 'N', 0x1153, &delay_200_500_e80_d50, \"N116BGE-EA2\"),\n\tEDP_PANEL_ENTRY('C', 'M', 'N', 0x1154, &delay_200_500_e80_d50, \"N116BCA-EA2\"),\n\tEDP_PANEL_ENTRY('C', 'M', 'N', 0x1247, &delay_200_500_e80_d50, \"N120ACA-EA1\"),\n\tEDP_PANEL_ENTRY('C', 'M', 'N', 0x14d4, &delay_200_500_e80_d50, \"N140HCA-EAC\"),\n\n\tEDP_PANEL_ENTRY('I', 'V', 'O', 0x057d, &delay_200_500_e200, \"R140NWF5 RH\"),\n\tEDP_PANEL_ENTRY('I', 'V', 'O', 0x854a, &delay_200_500_p2e100, \"M133NW4J\"),\n\tEDP_PANEL_ENTRY('I', 'V', 'O', 0x854b, &delay_200_500_p2e100, \"R133NW4K-R0\"),\n\n\tEDP_PANEL_ENTRY('K', 'D', 'B', 0x0624, &kingdisplay_kd116n21_30nv_a010.delay, \"116N21-30NV-A010\"),\n\tEDP_PANEL_ENTRY('K', 'D', 'B', 0x1120, &delay_200_500_e80_d50, \"116N29-30NK-C007\"),\n\n\tEDP_PANEL_ENTRY('S', 'H', 'P', 0x1511, &delay_200_500_e50, \"LQ140M1JW48\"),\n\tEDP_PANEL_ENTRY('S', 'H', 'P', 0x1523, &sharp_lq140m1jw46.delay, \"LQ140M1JW46\"),\n\tEDP_PANEL_ENTRY('S', 'H', 'P', 0x154c, &delay_200_500_p2e100, \"LQ116M1JW10\"),\n\n\tEDP_PANEL_ENTRY('S', 'T', 'A', 0x0100, &delay_100_500_e200, \"2081116HHD028001-51D\"),\n\n\t{   }\n};\n\nstatic const struct edp_panel_entry *find_edp_panel(u32 panel_id)\n{\n\tconst struct edp_panel_entry *panel;\n\n\tif (!panel_id)\n\t\treturn NULL;\n\n\tfor (panel = edp_panels; panel->panel_id; panel++)\n\t\tif (panel->panel_id == panel_id)\n\t\t\treturn panel;\n\n\treturn NULL;\n}\n\nstatic int panel_edp_platform_probe(struct platform_device *pdev)\n{\n\tconst struct of_device_id *id;\n\n\t \n\tid = of_match_node(platform_of_match + 1, pdev->dev.of_node);\n\tif (!id)\n\t\treturn -ENODEV;\n\n\treturn panel_edp_probe(&pdev->dev, id->data, NULL);\n}\n\nstatic void panel_edp_platform_remove(struct platform_device *pdev)\n{\n\tpanel_edp_remove(&pdev->dev);\n}\n\nstatic void panel_edp_platform_shutdown(struct platform_device *pdev)\n{\n\tpanel_edp_shutdown(&pdev->dev);\n}\n\nstatic const struct dev_pm_ops panel_edp_pm_ops = {\n\tSET_RUNTIME_PM_OPS(panel_edp_suspend, panel_edp_resume, NULL)\n\tSET_SYSTEM_SLEEP_PM_OPS(pm_runtime_force_suspend,\n\t\t\t\tpm_runtime_force_resume)\n};\n\nstatic struct platform_driver panel_edp_platform_driver = {\n\t.driver = {\n\t\t.name = \"panel-edp\",\n\t\t.of_match_table = platform_of_match,\n\t\t.pm = &panel_edp_pm_ops,\n\t},\n\t.probe = panel_edp_platform_probe,\n\t.remove_new = panel_edp_platform_remove,\n\t.shutdown = panel_edp_platform_shutdown,\n};\n\nstatic int panel_edp_dp_aux_ep_probe(struct dp_aux_ep_device *aux_ep)\n{\n\tconst struct of_device_id *id;\n\n\tid = of_match_node(platform_of_match, aux_ep->dev.of_node);\n\tif (!id)\n\t\treturn -ENODEV;\n\n\treturn panel_edp_probe(&aux_ep->dev, id->data, aux_ep->aux);\n}\n\nstatic void panel_edp_dp_aux_ep_remove(struct dp_aux_ep_device *aux_ep)\n{\n\tpanel_edp_remove(&aux_ep->dev);\n}\n\nstatic void panel_edp_dp_aux_ep_shutdown(struct dp_aux_ep_device *aux_ep)\n{\n\tpanel_edp_shutdown(&aux_ep->dev);\n}\n\nstatic struct dp_aux_ep_driver panel_edp_dp_aux_ep_driver = {\n\t.driver = {\n\t\t.name = \"panel-simple-dp-aux\",\n\t\t.of_match_table = platform_of_match,\t \n\t\t.pm = &panel_edp_pm_ops,\n\t},\n\t.probe = panel_edp_dp_aux_ep_probe,\n\t.remove = panel_edp_dp_aux_ep_remove,\n\t.shutdown = panel_edp_dp_aux_ep_shutdown,\n};\n\nstatic int __init panel_edp_init(void)\n{\n\tint err;\n\n\terr = platform_driver_register(&panel_edp_platform_driver);\n\tif (err < 0)\n\t\treturn err;\n\n\terr = dp_aux_dp_driver_register(&panel_edp_dp_aux_ep_driver);\n\tif (err < 0)\n\t\tgoto err_did_platform_register;\n\n\treturn 0;\n\nerr_did_platform_register:\n\tplatform_driver_unregister(&panel_edp_platform_driver);\n\n\treturn err;\n}\nmodule_init(panel_edp_init);\n\nstatic void __exit panel_edp_exit(void)\n{\n\tdp_aux_dp_driver_unregister(&panel_edp_dp_aux_ep_driver);\n\tplatform_driver_unregister(&panel_edp_platform_driver);\n}\nmodule_exit(panel_edp_exit);\n\nMODULE_AUTHOR(\"Thierry Reding <treding@nvidia.com>\");\nMODULE_DESCRIPTION(\"DRM Driver for Simple eDP Panels\");\nMODULE_LICENSE(\"GPL and additional rights\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}