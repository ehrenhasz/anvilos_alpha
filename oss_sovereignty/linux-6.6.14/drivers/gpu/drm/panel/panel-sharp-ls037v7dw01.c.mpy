{
  "module_name": "panel-sharp-ls037v7dw01.c",
  "hash_id": "76aabd0d32feab850f8a031d6bf0d7656f485433b20f13be7ad1d50ab190bec8",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/panel/panel-sharp-ls037v7dw01.c",
  "human_readable_source": "\n \n\n#include <linux/delay.h>\n#include <linux/gpio/consumer.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/regulator/consumer.h>\n\n#include <drm/drm_connector.h>\n#include <drm/drm_modes.h>\n#include <drm/drm_panel.h>\n\nstruct ls037v7dw01_panel {\n\tstruct drm_panel panel;\n\tstruct platform_device *pdev;\n\n\tstruct regulator *vdd;\n\tstruct gpio_desc *resb_gpio;\t \n\tstruct gpio_desc *ini_gpio;\t \n\tstruct gpio_desc *mo_gpio;\t \n\tstruct gpio_desc *lr_gpio;\t \n\tstruct gpio_desc *ud_gpio;\t \n};\n\n#define to_ls037v7dw01_device(p) \\\n\tcontainer_of(p, struct ls037v7dw01_panel, panel)\n\nstatic int ls037v7dw01_disable(struct drm_panel *panel)\n{\n\tstruct ls037v7dw01_panel *lcd = to_ls037v7dw01_device(panel);\n\n\tgpiod_set_value_cansleep(lcd->ini_gpio, 0);\n\tgpiod_set_value_cansleep(lcd->resb_gpio, 0);\n\n\t \n\tmsleep(100);\n\n\treturn 0;\n}\n\nstatic int ls037v7dw01_unprepare(struct drm_panel *panel)\n{\n\tstruct ls037v7dw01_panel *lcd = to_ls037v7dw01_device(panel);\n\n\tregulator_disable(lcd->vdd);\n\treturn 0;\n}\n\nstatic int ls037v7dw01_prepare(struct drm_panel *panel)\n{\n\tstruct ls037v7dw01_panel *lcd = to_ls037v7dw01_device(panel);\n\tint ret;\n\n\tret = regulator_enable(lcd->vdd);\n\tif (ret < 0)\n\t\tdev_err(&lcd->pdev->dev, \"%s: failed to enable regulator\\n\",\n\t\t\t__func__);\n\n\treturn ret;\n}\n\nstatic int ls037v7dw01_enable(struct drm_panel *panel)\n{\n\tstruct ls037v7dw01_panel *lcd = to_ls037v7dw01_device(panel);\n\n\t \n\tmsleep(50);\n\n\tgpiod_set_value_cansleep(lcd->resb_gpio, 1);\n\tgpiod_set_value_cansleep(lcd->ini_gpio, 1);\n\n\treturn 0;\n}\n\nstatic const struct drm_display_mode ls037v7dw01_mode = {\n\t.clock = 19200,\n\t.hdisplay = 480,\n\t.hsync_start = 480 + 1,\n\t.hsync_end = 480 + 1 + 2,\n\t.htotal = 480 + 1 + 2 + 28,\n\t.vdisplay = 640,\n\t.vsync_start = 640 + 1,\n\t.vsync_end = 640 + 1 + 1,\n\t.vtotal = 640 + 1 + 1 + 1,\n\t.type = DRM_MODE_TYPE_DRIVER | DRM_MODE_TYPE_PREFERRED,\n\t.flags = DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_NVSYNC,\n\t.width_mm = 56,\n\t.height_mm = 75,\n};\n\nstatic int ls037v7dw01_get_modes(struct drm_panel *panel,\n\t\t\t\t struct drm_connector *connector)\n{\n\tstruct drm_display_mode *mode;\n\n\tmode = drm_mode_duplicate(connector->dev, &ls037v7dw01_mode);\n\tif (!mode)\n\t\treturn -ENOMEM;\n\n\tdrm_mode_set_name(mode);\n\tdrm_mode_probed_add(connector, mode);\n\n\tconnector->display_info.width_mm = ls037v7dw01_mode.width_mm;\n\tconnector->display_info.height_mm = ls037v7dw01_mode.height_mm;\n\t \n\tconnector->display_info.bus_flags = DRM_BUS_FLAG_DE_HIGH\n\t\t\t\t\t  | DRM_BUS_FLAG_SYNC_SAMPLE_POSEDGE\n\t\t\t\t\t  | DRM_BUS_FLAG_PIXDATA_SAMPLE_NEGEDGE;\n\n\treturn 1;\n}\n\nstatic const struct drm_panel_funcs ls037v7dw01_funcs = {\n\t.disable = ls037v7dw01_disable,\n\t.unprepare = ls037v7dw01_unprepare,\n\t.prepare = ls037v7dw01_prepare,\n\t.enable = ls037v7dw01_enable,\n\t.get_modes = ls037v7dw01_get_modes,\n};\n\nstatic int ls037v7dw01_probe(struct platform_device *pdev)\n{\n\tstruct ls037v7dw01_panel *lcd;\n\n\tlcd = devm_kzalloc(&pdev->dev, sizeof(*lcd), GFP_KERNEL);\n\tif (!lcd)\n\t\treturn -ENOMEM;\n\n\tplatform_set_drvdata(pdev, lcd);\n\tlcd->pdev = pdev;\n\n\tlcd->vdd = devm_regulator_get(&pdev->dev, \"envdd\");\n\tif (IS_ERR(lcd->vdd))\n\t\treturn dev_err_probe(&pdev->dev, PTR_ERR(lcd->vdd),\n\t\t\t\t     \"failed to get regulator\\n\");\n\n\tlcd->ini_gpio = devm_gpiod_get(&pdev->dev, \"enable\", GPIOD_OUT_LOW);\n\tif (IS_ERR(lcd->ini_gpio))\n\t\treturn dev_err_probe(&pdev->dev, PTR_ERR(lcd->ini_gpio),\n\t\t\t\t     \"failed to get enable gpio\\n\");\n\n\tlcd->resb_gpio = devm_gpiod_get(&pdev->dev, \"reset\", GPIOD_OUT_LOW);\n\tif (IS_ERR(lcd->resb_gpio))\n\t\treturn dev_err_probe(&pdev->dev, PTR_ERR(lcd->resb_gpio),\n\t\t\t\t     \"failed to get reset gpio\\n\");\n\n\tlcd->mo_gpio = devm_gpiod_get_index(&pdev->dev, \"mode\", 0,\n\t\t\t\t\t    GPIOD_OUT_LOW);\n\tif (IS_ERR(lcd->mo_gpio)) {\n\t\tdev_err(&pdev->dev, \"failed to get mode[0] gpio\\n\");\n\t\treturn PTR_ERR(lcd->mo_gpio);\n\t}\n\n\tlcd->lr_gpio = devm_gpiod_get_index(&pdev->dev, \"mode\", 1,\n\t\t\t\t\t    GPIOD_OUT_LOW);\n\tif (IS_ERR(lcd->lr_gpio)) {\n\t\tdev_err(&pdev->dev, \"failed to get mode[1] gpio\\n\");\n\t\treturn PTR_ERR(lcd->lr_gpio);\n\t}\n\n\tlcd->ud_gpio = devm_gpiod_get_index(&pdev->dev, \"mode\", 2,\n\t\t\t\t\t    GPIOD_OUT_LOW);\n\tif (IS_ERR(lcd->ud_gpio)) {\n\t\tdev_err(&pdev->dev, \"failed to get mode[2] gpio\\n\");\n\t\treturn PTR_ERR(lcd->ud_gpio);\n\t}\n\n\tdrm_panel_init(&lcd->panel, &pdev->dev, &ls037v7dw01_funcs,\n\t\t       DRM_MODE_CONNECTOR_DPI);\n\n\tdrm_panel_add(&lcd->panel);\n\n\treturn 0;\n}\n\nstatic void ls037v7dw01_remove(struct platform_device *pdev)\n{\n\tstruct ls037v7dw01_panel *lcd = platform_get_drvdata(pdev);\n\n\tdrm_panel_remove(&lcd->panel);\n\tdrm_panel_disable(&lcd->panel);\n\tdrm_panel_unprepare(&lcd->panel);\n}\n\nstatic const struct of_device_id ls037v7dw01_of_match[] = {\n\t{ .compatible = \"sharp,ls037v7dw01\", },\n\t{   },\n};\n\nMODULE_DEVICE_TABLE(of, ls037v7dw01_of_match);\n\nstatic struct platform_driver ls037v7dw01_driver = {\n\t.probe\t\t= ls037v7dw01_probe,\n\t.remove_new\t= ls037v7dw01_remove,\n\t.driver\t\t= {\n\t\t.name = \"panel-sharp-ls037v7dw01\",\n\t\t.of_match_table = ls037v7dw01_of_match,\n\t},\n};\n\nmodule_platform_driver(ls037v7dw01_driver);\n\nMODULE_AUTHOR(\"Tomi Valkeinen <tomi.valkeinen@ti.com>\");\nMODULE_DESCRIPTION(\"Sharp LS037V7DW01 Panel Driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}