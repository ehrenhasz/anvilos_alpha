{
  "module_name": "panel-tpo-tpg110.c",
  "hash_id": "87e79b6ce4dda109578f1a4788cdf844fdbd6747aab2b85e8f02cf68a79cc937",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/panel/panel-tpo-tpg110.c",
  "human_readable_source": "\n \n#include <drm/drm_modes.h>\n#include <drm/drm_panel.h>\n\n#include <linux/bitops.h>\n#include <linux/delay.h>\n#include <linux/gpio/consumer.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/spi/spi.h>\n\n#define TPG110_TEST\t\t\t0x00\n#define TPG110_CHIPID\t\t\t0x01\n#define TPG110_CTRL1\t\t\t0x02\n#define TPG110_RES_MASK\t\t\tGENMASK(2, 0)\n#define TPG110_RES_800X480\t\t0x07\n#define TPG110_RES_640X480\t\t0x06\n#define TPG110_RES_480X272\t\t0x05\n#define TPG110_RES_480X640\t\t0x04\n#define TPG110_RES_480X272_D\t\t0x01  \n#define TPG110_RES_400X240_D\t\t0x00  \n#define TPG110_CTRL2\t\t\t0x03\n#define TPG110_CTRL2_PM\t\t\tBIT(0)\n#define TPG110_CTRL2_RES_PM_CTRL\tBIT(7)\n\n \nstruct tpg110_panel_mode {\n\t \n\tconst char *name;\n\t \n\tu32 magic;\n\t \n\tstruct drm_display_mode mode;\n\t \n\tu32 bus_flags;\n};\n\n \nstruct tpg110 {\n\t \n\tstruct device *dev;\n\t \n\tstruct spi_device *spi;\n\t \n\tstruct drm_panel panel;\n\t \n\tconst struct tpg110_panel_mode *panel_mode;\n\t \n\tu32 width;\n\t \n\tu32 height;\n\t \n\tstruct gpio_desc *grestb;\n};\n\n \nstatic const struct tpg110_panel_mode tpg110_modes[] = {\n\t{\n\t\t.name = \"800x480 RGB\",\n\t\t.magic = TPG110_RES_800X480,\n\t\t.mode = {\n\t\t\t.clock = 33200,\n\t\t\t.hdisplay = 800,\n\t\t\t.hsync_start = 800 + 40,\n\t\t\t.hsync_end = 800 + 40 + 1,\n\t\t\t.htotal = 800 + 40 + 1 + 216,\n\t\t\t.vdisplay = 480,\n\t\t\t.vsync_start = 480 + 10,\n\t\t\t.vsync_end = 480 + 10 + 1,\n\t\t\t.vtotal = 480 + 10 + 1 + 35,\n\t\t},\n\t\t.bus_flags = DRM_BUS_FLAG_PIXDATA_DRIVE_POSEDGE,\n\t},\n\t{\n\t\t.name = \"640x480 RGB\",\n\t\t.magic = TPG110_RES_640X480,\n\t\t.mode = {\n\t\t\t.clock = 25200,\n\t\t\t.hdisplay = 640,\n\t\t\t.hsync_start = 640 + 24,\n\t\t\t.hsync_end = 640 + 24 + 1,\n\t\t\t.htotal = 640 + 24 + 1 + 136,\n\t\t\t.vdisplay = 480,\n\t\t\t.vsync_start = 480 + 18,\n\t\t\t.vsync_end = 480 + 18 + 1,\n\t\t\t.vtotal = 480 + 18 + 1 + 27,\n\t\t},\n\t\t.bus_flags = DRM_BUS_FLAG_PIXDATA_DRIVE_POSEDGE,\n\t},\n\t{\n\t\t.name = \"480x272 RGB\",\n\t\t.magic = TPG110_RES_480X272,\n\t\t.mode = {\n\t\t\t.clock = 9000,\n\t\t\t.hdisplay = 480,\n\t\t\t.hsync_start = 480 + 2,\n\t\t\t.hsync_end = 480 + 2 + 1,\n\t\t\t.htotal = 480 + 2 + 1 + 43,\n\t\t\t.vdisplay = 272,\n\t\t\t.vsync_start = 272 + 2,\n\t\t\t.vsync_end = 272 + 2 + 1,\n\t\t\t.vtotal = 272 + 2 + 1 + 12,\n\t\t},\n\t\t.bus_flags = DRM_BUS_FLAG_PIXDATA_DRIVE_POSEDGE,\n\t},\n\t{\n\t\t.name = \"480x640 RGB\",\n\t\t.magic = TPG110_RES_480X640,\n\t\t.mode = {\n\t\t\t.clock = 20500,\n\t\t\t.hdisplay = 480,\n\t\t\t.hsync_start = 480 + 2,\n\t\t\t.hsync_end = 480 + 2 + 1,\n\t\t\t.htotal = 480 + 2 + 1 + 43,\n\t\t\t.vdisplay = 640,\n\t\t\t.vsync_start = 640 + 4,\n\t\t\t.vsync_end = 640 + 4 + 1,\n\t\t\t.vtotal = 640 + 4 + 1 + 8,\n\t\t},\n\t\t.bus_flags = DRM_BUS_FLAG_PIXDATA_DRIVE_POSEDGE,\n\t},\n\t{\n\t\t.name = \"400x240 RGB\",\n\t\t.magic = TPG110_RES_400X240_D,\n\t\t.mode = {\n\t\t\t.clock = 8300,\n\t\t\t.hdisplay = 400,\n\t\t\t.hsync_start = 400 + 20,\n\t\t\t.hsync_end = 400 + 20 + 1,\n\t\t\t.htotal = 400 + 20 + 1 + 108,\n\t\t\t.vdisplay = 240,\n\t\t\t.vsync_start = 240 + 2,\n\t\t\t.vsync_end = 240 + 2 + 1,\n\t\t\t.vtotal = 240 + 2 + 1 + 20,\n\t\t},\n\t\t.bus_flags = DRM_BUS_FLAG_PIXDATA_DRIVE_POSEDGE,\n\t},\n};\n\nstatic inline struct tpg110 *\nto_tpg110(struct drm_panel *panel)\n{\n\treturn container_of(panel, struct tpg110, panel);\n}\n\nstatic u8 tpg110_readwrite_reg(struct tpg110 *tpg, bool write,\n\t\t\t       u8 address, u8 outval)\n{\n\tstruct spi_message m;\n\tstruct spi_transfer t[2];\n\tu8 buf[2];\n\tint ret;\n\n\tspi_message_init(&m);\n\tmemset(t, 0, sizeof(t));\n\n\tif (write) {\n\t\t \n\t\tbuf[0] = address << 2;\n\t\tbuf[0] &= ~0x03;\n\t\tbuf[1] = outval;\n\n\t\tt[0].bits_per_word = 8;\n\t\tt[0].tx_buf = &buf[0];\n\t\tt[0].len = 1;\n\n\t\tt[1].tx_buf = &buf[1];\n\t\tt[1].len = 1;\n\t\tt[1].bits_per_word = 8;\n\t} else {\n\t\t \n\t\tbuf[0] = address << 1;\n\t\tbuf[0] |= 0x01;\n\n\t\t \n\t\tt[0].bits_per_word = 7;\n\t\tt[0].tx_buf = &buf[0];\n\t\tt[0].len = 1;\n\n\t\tt[1].rx_buf = &buf[1];\n\t\tt[1].len = 1;\n\t\tt[1].bits_per_word = 8;\n\t}\n\n\tspi_message_add_tail(&t[0], &m);\n\tspi_message_add_tail(&t[1], &m);\n\tret = spi_sync(tpg->spi, &m);\n\tif (ret) {\n\t\tdev_err(tpg->dev, \"SPI message error %d\\n\", ret);\n\t\treturn ret;\n\t}\n\tif (write)\n\t\treturn 0;\n\t \n\treturn buf[1];\n}\n\nstatic u8 tpg110_read_reg(struct tpg110 *tpg, u8 address)\n{\n\treturn tpg110_readwrite_reg(tpg, false, address, 0);\n}\n\nstatic void tpg110_write_reg(struct tpg110 *tpg, u8 address, u8 outval)\n{\n\ttpg110_readwrite_reg(tpg, true, address, outval);\n}\n\nstatic int tpg110_startup(struct tpg110 *tpg)\n{\n\tu8 val;\n\tint i;\n\n\t \n\tgpiod_set_value_cansleep(tpg->grestb, 0);\n\tusleep_range(1000, 2000);\n\tdev_dbg(tpg->dev, \"de-asserted GRESTB\\n\");\n\n\t \n\ttpg110_write_reg(tpg, TPG110_TEST, 0x55);\n\tval = tpg110_read_reg(tpg, TPG110_TEST);\n\tif (val != 0x55) {\n\t\tdev_err(tpg->dev, \"failed communication test\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tval = tpg110_read_reg(tpg, TPG110_CHIPID);\n\tdev_info(tpg->dev, \"TPG110 chip ID: %d version: %d\\n\",\n\t\t val >> 4, val & 0x0f);\n\n\t \n\tval = tpg110_read_reg(tpg, TPG110_CTRL1);\n\tval &= TPG110_RES_MASK;\n\tswitch (val) {\n\tcase TPG110_RES_400X240_D:\n\t\tdev_info(tpg->dev, \"IN 400x240 RGB -> OUT 800x480 RGB (dual scan)\\n\");\n\t\tbreak;\n\tcase TPG110_RES_480X272_D:\n\t\tdev_info(tpg->dev, \"IN 480x272 RGB -> OUT 800x480 RGB (dual scan)\\n\");\n\t\tbreak;\n\tcase TPG110_RES_480X640:\n\t\tdev_info(tpg->dev, \"480x640 RGB\\n\");\n\t\tbreak;\n\tcase TPG110_RES_480X272:\n\t\tdev_info(tpg->dev, \"480x272 RGB\\n\");\n\t\tbreak;\n\tcase TPG110_RES_640X480:\n\t\tdev_info(tpg->dev, \"640x480 RGB\\n\");\n\t\tbreak;\n\tcase TPG110_RES_800X480:\n\t\tdev_info(tpg->dev, \"800x480 RGB\\n\");\n\t\tbreak;\n\tdefault:\n\t\tdev_err(tpg->dev, \"ILLEGAL RESOLUTION 0x%02x\\n\", val);\n\t\tbreak;\n\t}\n\n\t \n\tif (val == TPG110_RES_480X272_D)\n\t\tval = TPG110_RES_480X272;\n\n\tfor (i = 0; i < ARRAY_SIZE(tpg110_modes); i++) {\n\t\tconst struct tpg110_panel_mode *pm;\n\n\t\tpm = &tpg110_modes[i];\n\t\tif (pm->magic == val) {\n\t\t\ttpg->panel_mode = pm;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (i == ARRAY_SIZE(tpg110_modes)) {\n\t\tdev_err(tpg->dev, \"unsupported mode (%02x) detected\\n\", val);\n\t\treturn -ENODEV;\n\t}\n\n\tval = tpg110_read_reg(tpg, TPG110_CTRL2);\n\tdev_info(tpg->dev, \"resolution and standby is controlled by %s\\n\",\n\t\t (val & TPG110_CTRL2_RES_PM_CTRL) ? \"software\" : \"hardware\");\n\t \n\tval |= TPG110_CTRL2_RES_PM_CTRL;\n\ttpg110_write_reg(tpg, TPG110_CTRL2, val);\n\n\treturn 0;\n}\n\nstatic int tpg110_disable(struct drm_panel *panel)\n{\n\tstruct tpg110 *tpg = to_tpg110(panel);\n\tu8 val;\n\n\t \n\tval = tpg110_read_reg(tpg, TPG110_CTRL2_PM);\n\tval &= ~TPG110_CTRL2_PM;\n\ttpg110_write_reg(tpg, TPG110_CTRL2_PM, val);\n\n\treturn 0;\n}\n\nstatic int tpg110_enable(struct drm_panel *panel)\n{\n\tstruct tpg110 *tpg = to_tpg110(panel);\n\tu8 val;\n\n\t \n\tval = tpg110_read_reg(tpg, TPG110_CTRL2_PM);\n\tval |= TPG110_CTRL2_PM;\n\ttpg110_write_reg(tpg, TPG110_CTRL2_PM, val);\n\n\treturn 0;\n}\n\n \nstatic int tpg110_get_modes(struct drm_panel *panel,\n\t\t\t    struct drm_connector *connector)\n{\n\tstruct tpg110 *tpg = to_tpg110(panel);\n\tstruct drm_display_mode *mode;\n\n\tconnector->display_info.width_mm = tpg->width;\n\tconnector->display_info.height_mm = tpg->height;\n\tconnector->display_info.bus_flags = tpg->panel_mode->bus_flags;\n\n\tmode = drm_mode_duplicate(connector->dev, &tpg->panel_mode->mode);\n\tif (!mode)\n\t\treturn -ENOMEM;\n\tdrm_mode_set_name(mode);\n\tmode->type = DRM_MODE_TYPE_DRIVER | DRM_MODE_TYPE_PREFERRED;\n\n\tmode->width_mm = tpg->width;\n\tmode->height_mm = tpg->height;\n\n\tdrm_mode_probed_add(connector, mode);\n\n\treturn 1;\n}\n\nstatic const struct drm_panel_funcs tpg110_drm_funcs = {\n\t.disable = tpg110_disable,\n\t.enable = tpg110_enable,\n\t.get_modes = tpg110_get_modes,\n};\n\nstatic int tpg110_probe(struct spi_device *spi)\n{\n\tstruct device *dev = &spi->dev;\n\tstruct device_node *np = dev->of_node;\n\tstruct tpg110 *tpg;\n\tint ret;\n\n\ttpg = devm_kzalloc(dev, sizeof(*tpg), GFP_KERNEL);\n\tif (!tpg)\n\t\treturn -ENOMEM;\n\ttpg->dev = dev;\n\n\t \n\tret = of_property_read_u32(np, \"width-mm\", &tpg->width);\n\tif (ret)\n\t\tdev_err(dev, \"no panel width specified\\n\");\n\tret = of_property_read_u32(np, \"height-mm\", &tpg->height);\n\tif (ret)\n\t\tdev_err(dev, \"no panel height specified\\n\");\n\n\t \n\ttpg->grestb = devm_gpiod_get(dev, \"grestb\", GPIOD_OUT_HIGH);\n\tif (IS_ERR(tpg->grestb)) {\n\t\tdev_err(dev, \"no GRESTB GPIO\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tspi->bits_per_word = 8;\n\tspi->mode |= SPI_3WIRE_HIZ;\n\tret = spi_setup(spi);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"spi setup failed.\\n\");\n\t\treturn ret;\n\t}\n\ttpg->spi = spi;\n\n\tret = tpg110_startup(tpg);\n\tif (ret)\n\t\treturn ret;\n\n\tdrm_panel_init(&tpg->panel, dev, &tpg110_drm_funcs,\n\t\t       DRM_MODE_CONNECTOR_DPI);\n\n\tret = drm_panel_of_backlight(&tpg->panel);\n\tif (ret)\n\t\treturn ret;\n\n\tspi_set_drvdata(spi, tpg);\n\n\tdrm_panel_add(&tpg->panel);\n\n\treturn 0;\n}\n\nstatic void tpg110_remove(struct spi_device *spi)\n{\n\tstruct tpg110 *tpg = spi_get_drvdata(spi);\n\n\tdrm_panel_remove(&tpg->panel);\n}\n\nstatic const struct of_device_id tpg110_match[] = {\n\t{ .compatible = \"tpo,tpg110\", },\n\t{},\n};\nMODULE_DEVICE_TABLE(of, tpg110_match);\n\nstatic const struct spi_device_id tpg110_ids[] = {\n\t{ \"tpg110\" },\n\t{ },\n};\nMODULE_DEVICE_TABLE(spi, tpg110_ids);\n\nstatic struct spi_driver tpg110_driver = {\n\t.probe\t\t= tpg110_probe,\n\t.remove\t\t= tpg110_remove,\n\t.id_table\t= tpg110_ids,\n\t.driver\t\t= {\n\t\t.name\t= \"tpo-tpg110-panel\",\n\t\t.of_match_table = tpg110_match,\n\t},\n};\nmodule_spi_driver(tpg110_driver);\n\nMODULE_AUTHOR(\"Linus Walleij <linus.walleij@linaro.org>\");\nMODULE_DESCRIPTION(\"TPO TPG110 panel driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}