{
  "module_name": "panel-samsung-atna33xc20.c",
  "hash_id": "598fdbe56a2c119e19b280d29c4cf64f4acd8e7aa7bbdfd4a30b3f6f0227f010",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/panel/panel-samsung-atna33xc20.c",
  "human_readable_source": "\n \n\n#include <linux/backlight.h>\n#include <linux/delay.h>\n#include <linux/gpio/consumer.h>\n#include <linux/iopoll.h>\n#include <linux/module.h>\n#include <linux/pm_runtime.h>\n#include <linux/regulator/consumer.h>\n\n#include <drm/display/drm_dp_aux_bus.h>\n#include <drm/display/drm_dp_helper.h>\n#include <drm/drm_edid.h>\n#include <drm/drm_panel.h>\n\n \n#define HPD_MAX_MS\t200\n#define HPD_MAX_US\t(HPD_MAX_MS * 1000)\n\nstruct atana33xc20_panel {\n\tstruct drm_panel base;\n\tbool prepared;\n\tbool enabled;\n\tbool el3_was_on;\n\n\tbool no_hpd;\n\tstruct gpio_desc *hpd_gpio;\n\n\tstruct regulator *supply;\n\tstruct gpio_desc *el_on3_gpio;\n\tstruct drm_dp_aux *aux;\n\n\tstruct edid *edid;\n\n\tktime_t powered_off_time;\n\tktime_t powered_on_time;\n\tktime_t el_on3_off_time;\n};\n\nstatic inline struct atana33xc20_panel *to_atana33xc20(struct drm_panel *panel)\n{\n\treturn container_of(panel, struct atana33xc20_panel, base);\n}\n\nstatic void atana33xc20_wait(ktime_t start_ktime, unsigned int min_ms)\n{\n\tktime_t now_ktime, min_ktime;\n\n\tmin_ktime = ktime_add(start_ktime, ms_to_ktime(min_ms));\n\tnow_ktime = ktime_get_boottime();\n\n\tif (ktime_before(now_ktime, min_ktime))\n\t\tmsleep(ktime_to_ms(ktime_sub(min_ktime, now_ktime)) + 1);\n}\n\nstatic int atana33xc20_suspend(struct device *dev)\n{\n\tstruct atana33xc20_panel *p = dev_get_drvdata(dev);\n\tint ret;\n\n\t \n\tif (p->el3_was_on)\n\t\tatana33xc20_wait(p->el_on3_off_time, 150);\n\n\tret = regulator_disable(p->supply);\n\tif (ret)\n\t\treturn ret;\n\tp->powered_off_time = ktime_get_boottime();\n\tp->el3_was_on = false;\n\n\treturn 0;\n}\n\nstatic int atana33xc20_resume(struct device *dev)\n{\n\tstruct atana33xc20_panel *p = dev_get_drvdata(dev);\n\tint hpd_asserted;\n\tint ret;\n\n\t \n\tatana33xc20_wait(p->powered_off_time, 500);\n\n\tret = regulator_enable(p->supply);\n\tif (ret)\n\t\treturn ret;\n\tp->powered_on_time = ktime_get_boottime();\n\n\tif (p->no_hpd) {\n\t\tmsleep(HPD_MAX_MS);\n\t\treturn 0;\n\t}\n\n\tif (p->hpd_gpio) {\n\t\tret = readx_poll_timeout(gpiod_get_value_cansleep, p->hpd_gpio,\n\t\t\t\t\t hpd_asserted, hpd_asserted,\n\t\t\t\t\t 1000, HPD_MAX_US);\n\t\tif (hpd_asserted < 0)\n\t\t\tret = hpd_asserted;\n\n\t\tif (ret)\n\t\t\tdev_warn(dev, \"Error waiting for HPD GPIO: %d\\n\", ret);\n\n\t\treturn ret;\n\t}\n\n\tif (p->aux->wait_hpd_asserted) {\n\t\tret = p->aux->wait_hpd_asserted(p->aux, HPD_MAX_US);\n\n\t\tif (ret)\n\t\t\tdev_warn(dev, \"Controller error waiting for HPD: %d\\n\", ret);\n\n\t\treturn ret;\n\t}\n\n\t \n\treturn 0;\n}\n\nstatic int atana33xc20_disable(struct drm_panel *panel)\n{\n\tstruct atana33xc20_panel *p = to_atana33xc20(panel);\n\n\t \n\tif (!p->enabled)\n\t\treturn 0;\n\n\tgpiod_set_value_cansleep(p->el_on3_gpio, 0);\n\tp->el_on3_off_time = ktime_get_boottime();\n\tp->enabled = false;\n\n\t \n\tp->el3_was_on = true;\n\n\t \n\tmsleep(20);\n\n\treturn 0;\n}\n\nstatic int atana33xc20_enable(struct drm_panel *panel)\n{\n\tstruct atana33xc20_panel *p = to_atana33xc20(panel);\n\n\t \n\tif (p->enabled)\n\t\treturn 0;\n\n\t \n\tif (WARN_ON(p->el3_was_on))\n\t\treturn -EIO;\n\n\t \n\tatana33xc20_wait(p->powered_on_time, 400);\n\n\tgpiod_set_value_cansleep(p->el_on3_gpio, 1);\n\tp->enabled = true;\n\n\treturn 0;\n}\n\nstatic int atana33xc20_unprepare(struct drm_panel *panel)\n{\n\tstruct atana33xc20_panel *p = to_atana33xc20(panel);\n\tint ret;\n\n\t \n\tif (!p->prepared)\n\t\treturn 0;\n\n\t \n\tret = pm_runtime_put_sync_suspend(panel->dev);\n\tif (ret < 0)\n\t\treturn ret;\n\tp->prepared = false;\n\n\treturn 0;\n}\n\nstatic int atana33xc20_prepare(struct drm_panel *panel)\n{\n\tstruct atana33xc20_panel *p = to_atana33xc20(panel);\n\tint ret;\n\n\t \n\tif (p->prepared)\n\t\treturn 0;\n\n\tret = pm_runtime_get_sync(panel->dev);\n\tif (ret < 0) {\n\t\tpm_runtime_put_autosuspend(panel->dev);\n\t\treturn ret;\n\t}\n\tp->prepared = true;\n\n\treturn 0;\n}\n\nstatic int atana33xc20_get_modes(struct drm_panel *panel,\n\t\t\t\t struct drm_connector *connector)\n{\n\tstruct atana33xc20_panel *p = to_atana33xc20(panel);\n\tstruct dp_aux_ep_device *aux_ep = to_dp_aux_ep_dev(panel->dev);\n\tint num = 0;\n\n\tpm_runtime_get_sync(panel->dev);\n\n\tif (!p->edid)\n\t\tp->edid = drm_get_edid(connector, &aux_ep->aux->ddc);\n\tnum = drm_add_edid_modes(connector, p->edid);\n\n\tpm_runtime_mark_last_busy(panel->dev);\n\tpm_runtime_put_autosuspend(panel->dev);\n\n\treturn num;\n}\n\nstatic const struct drm_panel_funcs atana33xc20_funcs = {\n\t.disable = atana33xc20_disable,\n\t.enable = atana33xc20_enable,\n\t.unprepare = atana33xc20_unprepare,\n\t.prepare = atana33xc20_prepare,\n\t.get_modes = atana33xc20_get_modes,\n};\n\nstatic void atana33xc20_runtime_disable(void *data)\n{\n\tpm_runtime_disable(data);\n}\n\nstatic void atana33xc20_dont_use_autosuspend(void *data)\n{\n\tpm_runtime_dont_use_autosuspend(data);\n}\n\nstatic int atana33xc20_probe(struct dp_aux_ep_device *aux_ep)\n{\n\tstruct atana33xc20_panel *panel;\n\tstruct device *dev = &aux_ep->dev;\n\tint ret;\n\n\tpanel = devm_kzalloc(dev, sizeof(*panel), GFP_KERNEL);\n\tif (!panel)\n\t\treturn -ENOMEM;\n\tdev_set_drvdata(dev, panel);\n\n\tpanel->aux = aux_ep->aux;\n\n\tpanel->supply = devm_regulator_get(dev, \"power\");\n\tif (IS_ERR(panel->supply))\n\t\treturn dev_err_probe(dev, PTR_ERR(panel->supply),\n\t\t\t\t     \"Failed to get power supply\\n\");\n\n\tpanel->el_on3_gpio = devm_gpiod_get(dev, \"enable\", GPIOD_OUT_LOW);\n\tif (IS_ERR(panel->el_on3_gpio))\n\t\treturn dev_err_probe(dev, PTR_ERR(panel->el_on3_gpio),\n\t\t\t\t     \"Failed to get enable GPIO\\n\");\n\n\tpanel->no_hpd = of_property_read_bool(dev->of_node, \"no-hpd\");\n\tif (!panel->no_hpd) {\n\t\tpanel->hpd_gpio = devm_gpiod_get_optional(dev, \"hpd\", GPIOD_IN);\n\t\tif (IS_ERR(panel->hpd_gpio))\n\t\t\treturn dev_err_probe(dev, PTR_ERR(panel->hpd_gpio),\n\t\t\t\t\t     \"Failed to get HPD GPIO\\n\");\n\t}\n\n\tpm_runtime_enable(dev);\n\tret = devm_add_action_or_reset(dev,  atana33xc20_runtime_disable, dev);\n\tif (ret)\n\t\treturn ret;\n\tpm_runtime_set_autosuspend_delay(dev, 2000);\n\tpm_runtime_use_autosuspend(dev);\n\tret = devm_add_action_or_reset(dev,  atana33xc20_dont_use_autosuspend, dev);\n\tif (ret)\n\t\treturn ret;\n\n\tdrm_panel_init(&panel->base, dev, &atana33xc20_funcs, DRM_MODE_CONNECTOR_eDP);\n\n\tpm_runtime_get_sync(dev);\n\tret = drm_panel_dp_aux_backlight(&panel->base, aux_ep->aux);\n\tpm_runtime_mark_last_busy(dev);\n\tpm_runtime_put_autosuspend(dev);\n\tif (ret)\n\t\treturn dev_err_probe(dev, ret,\n\t\t\t\t     \"failed to register dp aux backlight\\n\");\n\n\tdrm_panel_add(&panel->base);\n\n\treturn 0;\n}\n\nstatic void atana33xc20_remove(struct dp_aux_ep_device *aux_ep)\n{\n\tstruct device *dev = &aux_ep->dev;\n\tstruct atana33xc20_panel *panel = dev_get_drvdata(dev);\n\n\tdrm_panel_remove(&panel->base);\n\tdrm_panel_disable(&panel->base);\n\tdrm_panel_unprepare(&panel->base);\n\n\tkfree(panel->edid);\n}\n\nstatic void atana33xc20_shutdown(struct dp_aux_ep_device *aux_ep)\n{\n\tstruct device *dev = &aux_ep->dev;\n\tstruct atana33xc20_panel *panel = dev_get_drvdata(dev);\n\n\tdrm_panel_disable(&panel->base);\n\tdrm_panel_unprepare(&panel->base);\n}\n\nstatic const struct of_device_id atana33xc20_dt_match[] = {\n\t{ .compatible = \"samsung,atna33xc20\", },\n\t{   }\n};\nMODULE_DEVICE_TABLE(of, atana33xc20_dt_match);\n\nstatic const struct dev_pm_ops atana33xc20_pm_ops = {\n\tSET_RUNTIME_PM_OPS(atana33xc20_suspend, atana33xc20_resume, NULL)\n\tSET_SYSTEM_SLEEP_PM_OPS(pm_runtime_force_suspend,\n\t\t\t\tpm_runtime_force_resume)\n};\n\nstatic struct dp_aux_ep_driver atana33xc20_driver = {\n\t.driver = {\n\t\t.name\t\t= \"samsung_atana33xc20\",\n\t\t.of_match_table = atana33xc20_dt_match,\n\t\t.pm\t\t= &atana33xc20_pm_ops,\n\t},\n\t.probe = atana33xc20_probe,\n\t.remove = atana33xc20_remove,\n\t.shutdown = atana33xc20_shutdown,\n};\n\nstatic int __init atana33xc20_init(void)\n{\n\treturn dp_aux_dp_driver_register(&atana33xc20_driver);\n}\nmodule_init(atana33xc20_init);\n\nstatic void __exit atana33xc20_exit(void)\n{\n\tdp_aux_dp_driver_unregister(&atana33xc20_driver);\n}\nmodule_exit(atana33xc20_exit);\n\nMODULE_DESCRIPTION(\"Samsung ATANA33XC20 Panel Driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}