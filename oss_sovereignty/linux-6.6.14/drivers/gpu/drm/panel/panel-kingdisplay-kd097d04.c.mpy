{
  "module_name": "panel-kingdisplay-kd097d04.c",
  "hash_id": "8feaa923731d64de083273d841e13b1558cd0ac7dd0a44fa7ec1697ef7b634b2",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/panel/panel-kingdisplay-kd097d04.c",
  "human_readable_source": "\n \n\n#include <linux/delay.h>\n#include <linux/gpio/consumer.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/regulator/consumer.h>\n\n#include <video/mipi_display.h>\n\n#include <drm/drm_crtc.h>\n#include <drm/drm_device.h>\n#include <drm/drm_mipi_dsi.h>\n#include <drm/drm_modes.h>\n#include <drm/drm_panel.h>\n\nstruct kingdisplay_panel {\n\tstruct drm_panel base;\n\tstruct mipi_dsi_device *link;\n\n\tstruct regulator *supply;\n\tstruct gpio_desc *enable_gpio;\n\n\tbool prepared;\n\tbool enabled;\n};\n\nstruct kingdisplay_panel_cmd {\n\tchar cmd;\n\tchar data;\n};\n\n \nstatic const struct kingdisplay_panel_cmd init_code[] = {\n\t \n\t{ 0xB0, 0x00 },\n\t{ 0xB2, 0x02 },\n\t{ 0xB3, 0x11 },\n\t{ 0xB4, 0x00 },\n\t{ 0xB6, 0x80 },\n\t \n\t{ 0xB7, 0x02 },\n\t{ 0xB8, 0x80 },\n\t{ 0xBA, 0x43 },\n\t \n\t{ 0xBB, 0x53 },\n\t \n\t{ 0xBC, 0x0A },\n\t \n\t{ 0xBD, 0x4A },\n\t \n\t{ 0xBE, 0x2F },\n\t \n\t{ 0xBF, 0x1A },\n\t{ 0xF0, 0x39 },\n\t{ 0xF1, 0x22 },\n\t \n\t{ 0xB0, 0x02 },\n\t{ 0xC0, 0x00 },\n\t{ 0xC1, 0x01 },\n\t{ 0xC2, 0x0B },\n\t{ 0xC3, 0x15 },\n\t{ 0xC4, 0x22 },\n\t{ 0xC5, 0x11 },\n\t{ 0xC6, 0x15 },\n\t{ 0xC7, 0x19 },\n\t{ 0xC8, 0x1A },\n\t{ 0xC9, 0x16 },\n\t{ 0xCA, 0x18 },\n\t{ 0xCB, 0x13 },\n\t{ 0xCC, 0x18 },\n\t{ 0xCD, 0x13 },\n\t{ 0xCE, 0x1C },\n\t{ 0xCF, 0x19 },\n\t{ 0xD0, 0x21 },\n\t{ 0xD1, 0x2C },\n\t{ 0xD2, 0x2F },\n\t{ 0xD3, 0x30 },\n\t{ 0xD4, 0x19 },\n\t{ 0xD5, 0x1F },\n\t{ 0xD6, 0x00 },\n\t{ 0xD7, 0x01 },\n\t{ 0xD8, 0x0B },\n\t{ 0xD9, 0x15 },\n\t{ 0xDA, 0x22 },\n\t{ 0xDB, 0x11 },\n\t{ 0xDC, 0x15 },\n\t{ 0xDD, 0x19 },\n\t{ 0xDE, 0x1A },\n\t{ 0xDF, 0x16 },\n\t{ 0xE0, 0x18 },\n\t{ 0xE1, 0x13 },\n\t{ 0xE2, 0x18 },\n\t{ 0xE3, 0x13 },\n\t{ 0xE4, 0x1C },\n\t{ 0xE5, 0x19 },\n\t{ 0xE6, 0x21 },\n\t{ 0xE7, 0x2C },\n\t{ 0xE8, 0x2F },\n\t{ 0xE9, 0x30 },\n\t{ 0xEA, 0x19 },\n\t{ 0xEB, 0x1F },\n\t \n\t{ 0xB0, 0x01 },\n\t{ 0xC0, 0x10 },\n\t{ 0xC1, 0x0F },\n\t{ 0xC2, 0x0E },\n\t{ 0xC3, 0x0D },\n\t{ 0xC4, 0x0C },\n\t{ 0xC5, 0x0B },\n\t{ 0xC6, 0x0A },\n\t{ 0xC7, 0x09 },\n\t{ 0xC8, 0x08 },\n\t{ 0xC9, 0x07 },\n\t{ 0xCA, 0x06 },\n\t{ 0xCB, 0x05 },\n\t{ 0xCC, 0x00 },\n\t{ 0xCD, 0x01 },\n\t{ 0xCE, 0x02 },\n\t{ 0xCF, 0x03 },\n\t{ 0xD0, 0x04 },\n\t{ 0xD6, 0x10 },\n\t{ 0xD7, 0x0F },\n\t{ 0xD8, 0x0E },\n\t{ 0xD9, 0x0D },\n\t{ 0xDA, 0x0C },\n\t{ 0xDB, 0x0B },\n\t{ 0xDC, 0x0A },\n\t{ 0xDD, 0x09 },\n\t{ 0xDE, 0x08 },\n\t{ 0xDF, 0x07 },\n\t{ 0xE0, 0x06 },\n\t{ 0xE1, 0x05 },\n\t{ 0xE2, 0x00 },\n\t{ 0xE3, 0x01 },\n\t{ 0xE4, 0x02 },\n\t{ 0xE5, 0x03 },\n\t{ 0xE6, 0x04 },\n\t{ 0xE7, 0x00 },\n\t{ 0xEC, 0xC0 },\n\t \n\t{ 0xB0, 0x03 },\n\t{ 0xC0, 0x01 },\n\t{ 0xC2, 0x6F },\n\t{ 0xC3, 0x6F },\n\t{ 0xC5, 0x36 },\n\t{ 0xC8, 0x08 },\n\t{ 0xC9, 0x04 },\n\t{ 0xCA, 0x41 },\n\t{ 0xCC, 0x43 },\n\t{ 0xCF, 0x60 },\n\t{ 0xD2, 0x04 },\n\t{ 0xD3, 0x04 },\n\t{ 0xD4, 0x03 },\n\t{ 0xD5, 0x02 },\n\t{ 0xD6, 0x01 },\n\t{ 0xD7, 0x00 },\n\t{ 0xDB, 0x01 },\n\t{ 0xDE, 0x36 },\n\t{ 0xE6, 0x6F },\n\t{ 0xE7, 0x6F },\n\t \n\t{ 0xB0, 0x06 },\n\t{ 0xB8, 0xA5 },\n\t{ 0xC0, 0xA5 },\n\t{ 0xD5, 0x3F },\n};\n\nstatic inline\nstruct kingdisplay_panel *to_kingdisplay_panel(struct drm_panel *panel)\n{\n\treturn container_of(panel, struct kingdisplay_panel, base);\n}\n\nstatic int kingdisplay_panel_disable(struct drm_panel *panel)\n{\n\tstruct kingdisplay_panel *kingdisplay = to_kingdisplay_panel(panel);\n\tint err;\n\n\tif (!kingdisplay->enabled)\n\t\treturn 0;\n\n\terr = mipi_dsi_dcs_set_display_off(kingdisplay->link);\n\tif (err < 0)\n\t\tdev_err(panel->dev, \"failed to set display off: %d\\n\", err);\n\n\tkingdisplay->enabled = false;\n\n\treturn 0;\n}\n\nstatic int kingdisplay_panel_unprepare(struct drm_panel *panel)\n{\n\tstruct kingdisplay_panel *kingdisplay = to_kingdisplay_panel(panel);\n\tint err;\n\n\tif (!kingdisplay->prepared)\n\t\treturn 0;\n\n\terr = mipi_dsi_dcs_enter_sleep_mode(kingdisplay->link);\n\tif (err < 0) {\n\t\tdev_err(panel->dev, \"failed to enter sleep mode: %d\\n\", err);\n\t\treturn err;\n\t}\n\n\t \n\tmsleep(120);\n\n\tgpiod_set_value_cansleep(kingdisplay->enable_gpio, 0);\n\n\terr = regulator_disable(kingdisplay->supply);\n\tif (err < 0)\n\t\treturn err;\n\n\tkingdisplay->prepared = false;\n\n\treturn 0;\n}\n\nstatic int kingdisplay_panel_prepare(struct drm_panel *panel)\n{\n\tstruct kingdisplay_panel *kingdisplay = to_kingdisplay_panel(panel);\n\tint err, regulator_err;\n\tunsigned int i;\n\n\tif (kingdisplay->prepared)\n\t\treturn 0;\n\n\tgpiod_set_value_cansleep(kingdisplay->enable_gpio, 0);\n\n\terr = regulator_enable(kingdisplay->supply);\n\tif (err < 0)\n\t\treturn err;\n\n\t \n\tusleep_range(15000, 16000);\n\n\tgpiod_set_value_cansleep(kingdisplay->enable_gpio, 1);\n\n\t \n\tusleep_range(15000, 16000);\n\n\tfor (i = 0; i < ARRAY_SIZE(init_code); i++) {\n\t\terr = mipi_dsi_generic_write(kingdisplay->link, &init_code[i],\n\t\t\t\t\tsizeof(struct kingdisplay_panel_cmd));\n\t\tif (err < 0) {\n\t\t\tdev_err(panel->dev, \"failed write init cmds: %d\\n\", err);\n\t\t\tgoto poweroff;\n\t\t}\n\t}\n\n\terr = mipi_dsi_dcs_exit_sleep_mode(kingdisplay->link);\n\tif (err < 0) {\n\t\tdev_err(panel->dev, \"failed to exit sleep mode: %d\\n\", err);\n\t\tgoto poweroff;\n\t}\n\n\t \n\tmsleep(120);\n\n\terr = mipi_dsi_dcs_set_display_on(kingdisplay->link);\n\tif (err < 0) {\n\t\tdev_err(panel->dev, \"failed to set display on: %d\\n\", err);\n\t\tgoto poweroff;\n\t}\n\n\t \n\tusleep_range(10000, 11000);\n\n\tkingdisplay->prepared = true;\n\n\treturn 0;\n\npoweroff:\n\tgpiod_set_value_cansleep(kingdisplay->enable_gpio, 0);\n\n\tregulator_err = regulator_disable(kingdisplay->supply);\n\tif (regulator_err)\n\t\tdev_err(panel->dev, \"failed to disable regulator: %d\\n\", regulator_err);\n\n\treturn err;\n}\n\nstatic int kingdisplay_panel_enable(struct drm_panel *panel)\n{\n\tstruct kingdisplay_panel *kingdisplay = to_kingdisplay_panel(panel);\n\n\tif (kingdisplay->enabled)\n\t\treturn 0;\n\n\tkingdisplay->enabled = true;\n\n\treturn 0;\n}\n\nstatic const struct drm_display_mode default_mode = {\n\t.clock = 229000,\n\t.hdisplay = 1536,\n\t.hsync_start = 1536 + 100,\n\t.hsync_end = 1536 + 100 + 24,\n\t.htotal = 1536 + 100 + 24 + 100,\n\t.vdisplay = 2048,\n\t.vsync_start = 2048 + 95,\n\t.vsync_end = 2048 + 95 + 2,\n\t.vtotal = 2048 + 95 + 2 + 23,\n};\n\nstatic int kingdisplay_panel_get_modes(struct drm_panel *panel,\n\t\t\t\t       struct drm_connector *connector)\n{\n\tstruct drm_display_mode *mode;\n\n\tmode = drm_mode_duplicate(connector->dev, &default_mode);\n\tif (!mode) {\n\t\tdev_err(panel->dev, \"failed to add mode %ux%u@%u\\n\",\n\t\t\tdefault_mode.hdisplay, default_mode.vdisplay,\n\t\t\tdrm_mode_vrefresh(&default_mode));\n\t\treturn -ENOMEM;\n\t}\n\n\tdrm_mode_set_name(mode);\n\n\tdrm_mode_probed_add(connector, mode);\n\n\tconnector->display_info.width_mm = 147;\n\tconnector->display_info.height_mm = 196;\n\tconnector->display_info.bpc = 8;\n\n\treturn 1;\n}\n\nstatic const struct drm_panel_funcs kingdisplay_panel_funcs = {\n\t.disable = kingdisplay_panel_disable,\n\t.unprepare = kingdisplay_panel_unprepare,\n\t.prepare = kingdisplay_panel_prepare,\n\t.enable = kingdisplay_panel_enable,\n\t.get_modes = kingdisplay_panel_get_modes,\n};\n\nstatic const struct of_device_id kingdisplay_of_match[] = {\n\t{ .compatible = \"kingdisplay,kd097d04\", },\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, kingdisplay_of_match);\n\nstatic int kingdisplay_panel_add(struct kingdisplay_panel *kingdisplay)\n{\n\tstruct device *dev = &kingdisplay->link->dev;\n\tint err;\n\n\tkingdisplay->supply = devm_regulator_get(dev, \"power\");\n\tif (IS_ERR(kingdisplay->supply))\n\t\treturn PTR_ERR(kingdisplay->supply);\n\n\tkingdisplay->enable_gpio = devm_gpiod_get_optional(dev, \"enable\",\n\t\t\t\t\t\t\t   GPIOD_OUT_HIGH);\n\tif (IS_ERR(kingdisplay->enable_gpio)) {\n\t\terr = PTR_ERR(kingdisplay->enable_gpio);\n\t\tdev_dbg(dev, \"failed to get enable gpio: %d\\n\", err);\n\t\tkingdisplay->enable_gpio = NULL;\n\t}\n\n\tdrm_panel_init(&kingdisplay->base, &kingdisplay->link->dev,\n\t\t       &kingdisplay_panel_funcs, DRM_MODE_CONNECTOR_DSI);\n\n\terr = drm_panel_of_backlight(&kingdisplay->base);\n\tif (err)\n\t\treturn err;\n\n\tdrm_panel_add(&kingdisplay->base);\n\n\treturn 0;\n}\n\nstatic void kingdisplay_panel_del(struct kingdisplay_panel *kingdisplay)\n{\n\tdrm_panel_remove(&kingdisplay->base);\n}\n\nstatic int kingdisplay_panel_probe(struct mipi_dsi_device *dsi)\n{\n\tstruct kingdisplay_panel *kingdisplay;\n\tint err;\n\n\tdsi->lanes = 4;\n\tdsi->format = MIPI_DSI_FMT_RGB888;\n\tdsi->mode_flags = MIPI_DSI_MODE_VIDEO | MIPI_DSI_MODE_VIDEO_BURST |\n\t\t\t  MIPI_DSI_MODE_LPM;\n\n\tkingdisplay = devm_kzalloc(&dsi->dev, sizeof(*kingdisplay), GFP_KERNEL);\n\tif (!kingdisplay)\n\t\treturn -ENOMEM;\n\n\tmipi_dsi_set_drvdata(dsi, kingdisplay);\n\tkingdisplay->link = dsi;\n\n\terr = kingdisplay_panel_add(kingdisplay);\n\tif (err < 0)\n\t\treturn err;\n\n\terr = mipi_dsi_attach(dsi);\n\tif (err < 0) {\n\t\tkingdisplay_panel_del(kingdisplay);\n\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\nstatic void kingdisplay_panel_remove(struct mipi_dsi_device *dsi)\n{\n\tstruct kingdisplay_panel *kingdisplay = mipi_dsi_get_drvdata(dsi);\n\tint err;\n\n\terr = drm_panel_unprepare(&kingdisplay->base);\n\tif (err < 0)\n\t\tdev_err(&dsi->dev, \"failed to unprepare panel: %d\\n\", err);\n\n\terr = drm_panel_disable(&kingdisplay->base);\n\tif (err < 0)\n\t\tdev_err(&dsi->dev, \"failed to disable panel: %d\\n\", err);\n\n\terr = mipi_dsi_detach(dsi);\n\tif (err < 0)\n\t\tdev_err(&dsi->dev, \"failed to detach from DSI host: %d\\n\", err);\n\n\tkingdisplay_panel_del(kingdisplay);\n}\n\nstatic void kingdisplay_panel_shutdown(struct mipi_dsi_device *dsi)\n{\n\tstruct kingdisplay_panel *kingdisplay = mipi_dsi_get_drvdata(dsi);\n\n\tdrm_panel_unprepare(&kingdisplay->base);\n\tdrm_panel_disable(&kingdisplay->base);\n}\n\nstatic struct mipi_dsi_driver kingdisplay_panel_driver = {\n\t.driver = {\n\t\t.name = \"panel-kingdisplay-kd097d04\",\n\t\t.of_match_table = kingdisplay_of_match,\n\t},\n\t.probe = kingdisplay_panel_probe,\n\t.remove = kingdisplay_panel_remove,\n\t.shutdown = kingdisplay_panel_shutdown,\n};\nmodule_mipi_dsi_driver(kingdisplay_panel_driver);\n\nMODULE_AUTHOR(\"Chris Zhong <zyw@rock-chips.com>\");\nMODULE_AUTHOR(\"Nickey Yang <nickey.yang@rock-chips.com>\");\nMODULE_DESCRIPTION(\"kingdisplay KD097D04 panel driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}