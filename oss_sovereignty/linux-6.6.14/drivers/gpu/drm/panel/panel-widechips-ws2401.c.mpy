{
  "module_name": "panel-widechips-ws2401.c",
  "hash_id": "5570e4967aebde592983226dc9e6c1cfbf2fc0c771e46871ea0b0ef3bb39bee7",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/panel/panel-widechips-ws2401.c",
  "human_readable_source": "\n \n#include <drm/drm_mipi_dbi.h>\n#include <drm/drm_modes.h>\n#include <drm/drm_panel.h>\n\n#include <linux/backlight.h>\n#include <linux/delay.h>\n#include <linux/gpio/consumer.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/media-bus-format.h>\n#include <linux/module.h>\n#include <linux/regulator/consumer.h>\n#include <linux/spi/spi.h>\n\n#include <video/mipi_display.h>\n\n#define WS2401_RESCTL\t\t\t0xb8  \n#define WS2401_PSMPS\t\t\t0xbd  \n#define WS2401_NSMPS\t\t\t0xbe  \n#define WS2401_SMPS\t\t\t0xbf\n#define WS2401_BCMODE\t\t\t0xc1  \n#define WS2401_WRBLCTL\t\t\t0xc3  \n#define WS2401_WRDISBV\t\t\t0xc4  \n#define WS2401_WRCTRLD\t\t\t0xc6  \n#define WS2401_WRMIE\t\t\t0xc7  \n#define WS2401_READ_ID1\t\t\t0xda  \n#define WS2401_READ_ID2\t\t\t0xdb  \n#define WS2401_READ_ID3\t\t\t0xdc  \n#define WS2401_GAMMA_R1\t\t\t0xe7  \n#define WS2401_GAMMA_G1\t\t\t0xe8  \n#define WS2401_GAMMA_B1\t\t\t0xe9  \n#define WS2401_GAMMA_R2\t\t\t0xea  \n#define WS2401_GAMMA_G2\t\t\t0xeb  \n#define WS2401_GAMMA_B2\t\t\t0xec  \n#define WS2401_PASSWD1\t\t\t0xf0  \n#define WS2401_DISCTL\t\t\t0xf2  \n#define WS2401_PWRCTL\t\t\t0xf3  \n#define WS2401_VCOMCTL\t\t\t0xf4  \n#define WS2401_SRCCTL\t\t\t0xf5  \n#define WS2401_PANELCTL\t\t\t0xf6  \n\nstatic const u8 ws2401_dbi_read_commands[] = {\n\tWS2401_READ_ID1,\n\tWS2401_READ_ID2,\n\tWS2401_READ_ID3,\n\t0,  \n};\n\n \nstruct ws2401 {\n\t \n\tstruct device *dev;\n\t \n\tstruct mipi_dbi dbi;\n\t \n\tstruct drm_panel panel;\n\t \n\tu32 width;\n\t \n\tu32 height;\n\t \n\tstruct gpio_desc *reset;\n\t \n\tstruct regulator_bulk_data regulators[2];\n\t \n\tbool internal_bl;\n};\n\nstatic const struct drm_display_mode lms380kf01_480_800_mode = {\n\t \n\t.clock = 24960,\n\t.hdisplay = 480,\n\t.hsync_start = 480 + 8,\n\t.hsync_end = 480 + 8 + 10,\n\t.htotal = 480 + 8 + 10 + 8,\n\t.vdisplay = 800,\n\t.vsync_start = 800 + 8,\n\t.vsync_end = 800 + 8 + 2,\n\t.vtotal = 800 + 8 + 2 + 18,\n\t.width_mm = 50,\n\t.height_mm = 84,\n\t.flags = DRM_MODE_FLAG_NVSYNC | DRM_MODE_FLAG_NHSYNC,\n};\n\nstatic inline struct ws2401 *to_ws2401(struct drm_panel *panel)\n{\n\treturn container_of(panel, struct ws2401, panel);\n}\n\nstatic void ws2401_read_mtp_id(struct ws2401 *ws)\n{\n\tstruct mipi_dbi *dbi = &ws->dbi;\n\tu8 id1, id2, id3;\n\tint ret;\n\n\tret = mipi_dbi_command_read(dbi, WS2401_READ_ID1, &id1);\n\tif (ret) {\n\t\tdev_err(ws->dev, \"unable to read MTP ID 1\\n\");\n\t\treturn;\n\t}\n\tret = mipi_dbi_command_read(dbi, WS2401_READ_ID2, &id2);\n\tif (ret) {\n\t\tdev_err(ws->dev, \"unable to read MTP ID 2\\n\");\n\t\treturn;\n\t}\n\tret = mipi_dbi_command_read(dbi, WS2401_READ_ID3, &id3);\n\tif (ret) {\n\t\tdev_err(ws->dev, \"unable to read MTP ID 3\\n\");\n\t\treturn;\n\t}\n\tdev_info(ws->dev, \"MTP ID: %02x %02x %02x\\n\", id1, id2, id3);\n}\n\nstatic int ws2401_power_on(struct ws2401 *ws)\n{\n\tstruct mipi_dbi *dbi = &ws->dbi;\n\tint ret;\n\n\t \n\tret = regulator_bulk_enable(ARRAY_SIZE(ws->regulators),\n\t\t\t\t    ws->regulators);\n\tif (ret) {\n\t\tdev_err(ws->dev, \"failed to enable regulators: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\tmsleep(10);\n\n\t \n\tgpiod_set_value_cansleep(ws->reset, 1);\n\tusleep_range(1000, 5000);\n\t \n\tgpiod_set_value_cansleep(ws->reset, 0);\n\t \n\tmsleep(10);\n\tdev_dbg(ws->dev, \"de-asserted RESET\\n\");\n\n\t \n\tmipi_dbi_command(dbi, MIPI_DCS_EXIT_SLEEP_MODE);\n\tmipi_dbi_command(dbi, MIPI_DCS_EXIT_SLEEP_MODE);\n\tmsleep(50);\n\n\t \n\tmipi_dbi_command(dbi, WS2401_PASSWD1, 0x5a, 0x5a);\n\t \n\tmipi_dbi_command(dbi, WS2401_RESCTL, 0x12);\n\t \n\tmipi_dbi_command(dbi, MIPI_DCS_SET_ADDRESS_MODE, 0x01);\n\t \n\tmipi_dbi_command(dbi, MIPI_DCS_SET_PIXEL_FORMAT, 0x70);\n\tmipi_dbi_command(dbi, WS2401_SMPS, 0x00, 0x0f);\n\tmipi_dbi_command(dbi, WS2401_PSMPS, 0x06, 0x03,  \n\t\t\t 0x7e, 0x03, 0x12, 0x37);\n\tmipi_dbi_command(dbi, WS2401_NSMPS, 0x06, 0x03,  \n\t\t\t 0x7e, 0x02, 0x15, 0x37);\n\tmipi_dbi_command(dbi, WS2401_SMPS, 0x02, 0x0f);\n\tmipi_dbi_command(dbi, WS2401_PWRCTL, 0x10, 0xA9, 0x00, 0x01, 0x44,\n\t\t\t 0xb4,\t \n\t\t\t 0x50,\t \n\t\t\t 0x50,\t \n\t\t\t 0x00,\n\t\t\t 0x44);\t \n\tmipi_dbi_command(dbi, WS2401_DISCTL, 0x01, 0x00, 0x00, 0x00, 0x14,\n\t\t\t 0x16);\n\tmipi_dbi_command(dbi, WS2401_VCOMCTL, 0x30, 0x53, 0x53);\n\tmipi_dbi_command(dbi, WS2401_SRCCTL, 0x03, 0x0C, 0x00, 0x00, 0x00,\n\t\t\t 0x01,\t \n\t\t\t 0x01, 0x06, 0x03);\n\tmipi_dbi_command(dbi, WS2401_PANELCTL, 0x14, 0x00, 0x80, 0x00);\n\tmipi_dbi_command(dbi, WS2401_WRMIE, 0x01);\n\n\t \n\tmipi_dbi_command(dbi, WS2401_GAMMA_R1, 0x00,\n\t\t\t 0x5b, 0x42, 0x41, 0x3f, 0x42, 0x3d, 0x38, 0x2e,\n\t\t\t 0x2b, 0x2a, 0x27, 0x22, 0x27, 0x0f, 0x00, 0x00);\n\tmipi_dbi_command(dbi, WS2401_GAMMA_R2, 0x00,\n\t\t\t 0x5b, 0x42, 0x41, 0x3f, 0x42, 0x3d, 0x38, 0x2e,\n\t\t\t 0x2b, 0x2a, 0x27, 0x22, 0x27, 0x0f, 0x00, 0x00);\n\tmipi_dbi_command(dbi, WS2401_GAMMA_G1, 0x00,\n\t\t\t 0x59, 0x40, 0x3f, 0x3e, 0x41, 0x3d, 0x39, 0x2f,\n\t\t\t 0x2c, 0x2b, 0x29, 0x25, 0x29, 0x19, 0x08, 0x00);\n\tmipi_dbi_command(dbi, WS2401_GAMMA_G2, 0x00,\n\t\t\t 0x59, 0x40, 0x3f, 0x3e, 0x41, 0x3d, 0x39, 0x2f,\n\t\t\t 0x2c, 0x2b, 0x29, 0x25, 0x29, 0x19, 0x08, 0x00);\n\tmipi_dbi_command(dbi, WS2401_GAMMA_B1, 0x00,\n\t\t\t 0x57, 0x3b, 0x3a, 0x3b, 0x3f, 0x3b, 0x38, 0x27,\n\t\t\t 0x38, 0x2a, 0x26, 0x22, 0x34, 0x0c, 0x09, 0x00);\n\tmipi_dbi_command(dbi, WS2401_GAMMA_B2, 0x00,\n\t\t\t 0x57, 0x3b, 0x3a, 0x3b, 0x3f, 0x3b, 0x38, 0x27,\n\t\t\t 0x38, 0x2a, 0x26, 0x22, 0x34, 0x0c, 0x09, 0x00);\n\n\tif (ws->internal_bl) {\n\t\tmipi_dbi_command(dbi, WS2401_WRCTRLD, 0x2c);\n\t} else {\n\t\tmipi_dbi_command(dbi, WS2401_WRCTRLD, 0x00);\n\t\t \n\t\tmipi_dbi_command(dbi, WS2401_PASSWD1, 0xa5, 0xa5);\n\t}\n\n\treturn 0;\n}\n\nstatic int ws2401_power_off(struct ws2401 *ws)\n{\n\t \n\tgpiod_set_value_cansleep(ws->reset, 1);\n\treturn regulator_bulk_disable(ARRAY_SIZE(ws->regulators),\n\t\t\t\t      ws->regulators);\n}\n\nstatic int ws2401_unprepare(struct drm_panel *panel)\n{\n\tstruct ws2401 *ws = to_ws2401(panel);\n\tstruct mipi_dbi *dbi = &ws->dbi;\n\n\t \n\tif (ws->internal_bl)\n\t\tmipi_dbi_command(dbi, WS2401_WRCTRLD, 0x00);\n\tmipi_dbi_command(dbi, MIPI_DCS_ENTER_SLEEP_MODE);\n\tmsleep(120);\n\treturn ws2401_power_off(to_ws2401(panel));\n}\n\nstatic int ws2401_disable(struct drm_panel *panel)\n{\n\tstruct ws2401 *ws = to_ws2401(panel);\n\tstruct mipi_dbi *dbi = &ws->dbi;\n\n\tmipi_dbi_command(dbi, MIPI_DCS_SET_DISPLAY_OFF);\n\tmsleep(25);\n\n\treturn 0;\n}\n\nstatic int ws2401_prepare(struct drm_panel *panel)\n{\n\treturn ws2401_power_on(to_ws2401(panel));\n}\n\nstatic int ws2401_enable(struct drm_panel *panel)\n{\n\tstruct ws2401 *ws = to_ws2401(panel);\n\tstruct mipi_dbi *dbi = &ws->dbi;\n\n\tmipi_dbi_command(dbi, MIPI_DCS_SET_DISPLAY_ON);\n\n\treturn 0;\n}\n\n \nstatic int ws2401_get_modes(struct drm_panel *panel,\n\t\t\t    struct drm_connector *connector)\n{\n\tstruct ws2401 *ws = to_ws2401(panel);\n\tstruct drm_display_mode *mode;\n\tstatic const u32 bus_format = MEDIA_BUS_FMT_RGB888_1X24;\n\n\t \n\tmode = drm_mode_duplicate(connector->dev, &lms380kf01_480_800_mode);\n\tif (!mode) {\n\t\tdev_err(ws->dev, \"failed to add mode\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tconnector->display_info.bpc = 8;\n\tconnector->display_info.width_mm = mode->width_mm;\n\tconnector->display_info.height_mm = mode->height_mm;\n\tconnector->display_info.bus_flags =\n\t\tDRM_BUS_FLAG_PIXDATA_DRIVE_NEGEDGE;\n\tdrm_display_info_set_bus_formats(&connector->display_info,\n\t\t\t\t\t &bus_format, 1);\n\n\tdrm_mode_set_name(mode);\n\tmode->type = DRM_MODE_TYPE_DRIVER | DRM_MODE_TYPE_PREFERRED;\n\n\tdrm_mode_probed_add(connector, mode);\n\n\treturn 1;\n}\n\nstatic const struct drm_panel_funcs ws2401_drm_funcs = {\n\t.disable = ws2401_disable,\n\t.unprepare = ws2401_unprepare,\n\t.prepare = ws2401_prepare,\n\t.enable = ws2401_enable,\n\t.get_modes = ws2401_get_modes,\n};\n\nstatic int ws2401_set_brightness(struct backlight_device *bl)\n{\n\tstruct ws2401 *ws = bl_get_data(bl);\n\tstruct mipi_dbi *dbi = &ws->dbi;\n\tu8 brightness = backlight_get_brightness(bl);\n\n\tif (backlight_is_blank(bl)) {\n\t\tmipi_dbi_command(dbi, WS2401_WRCTRLD, 0x00);\n\t} else {\n\t\tmipi_dbi_command(dbi, WS2401_WRCTRLD, 0x2c);\n\t\tmipi_dbi_command(dbi, WS2401_WRDISBV, brightness);\n\t}\n\n\treturn 0;\n}\n\nstatic const struct backlight_ops ws2401_bl_ops = {\n\t.update_status = ws2401_set_brightness,\n};\n\nstatic const struct backlight_properties ws2401_bl_props = {\n\t.type = BACKLIGHT_PLATFORM,\n\t.brightness = 120,\n\t.max_brightness = U8_MAX,\n};\n\nstatic int ws2401_probe(struct spi_device *spi)\n{\n\tstruct device *dev = &spi->dev;\n\tstruct ws2401 *ws;\n\tint ret;\n\n\tws = devm_kzalloc(dev, sizeof(*ws), GFP_KERNEL);\n\tif (!ws)\n\t\treturn -ENOMEM;\n\tws->dev = dev;\n\n\t \n\tws->regulators[0].supply = \"vci\";\n\tws->regulators[1].supply = \"vccio\";\n\tret = devm_regulator_bulk_get(dev,\n\t\t\t\t      ARRAY_SIZE(ws->regulators),\n\t\t\t\t      ws->regulators);\n\tif (ret)\n\t\treturn dev_err_probe(dev, ret, \"failed to get regulators\\n\");\n\n\tws->reset = devm_gpiod_get(dev, \"reset\", GPIOD_OUT_HIGH);\n\tif (IS_ERR(ws->reset)) {\n\t\tret = PTR_ERR(ws->reset);\n\t\treturn dev_err_probe(dev, ret, \"no RESET GPIO\\n\");\n\t}\n\n\tret = mipi_dbi_spi_init(spi, &ws->dbi, NULL);\n\tif (ret)\n\t\treturn dev_err_probe(dev, ret, \"MIPI DBI init failed\\n\");\n\tws->dbi.read_commands = ws2401_dbi_read_commands;\n\n\tws2401_power_on(ws);\n\tws2401_read_mtp_id(ws);\n\tws2401_power_off(ws);\n\n\tdrm_panel_init(&ws->panel, dev, &ws2401_drm_funcs,\n\t\t       DRM_MODE_CONNECTOR_DPI);\n\n\tret = drm_panel_of_backlight(&ws->panel);\n\tif (ret)\n\t\treturn dev_err_probe(dev, ret,\n\t\t\t\t\"failed to get external backlight device\\n\");\n\n\tif (!ws->panel.backlight) {\n\t\tdev_dbg(dev, \"no external backlight, using internal backlight\\n\");\n\t\tws->panel.backlight =\n\t\t\tdevm_backlight_device_register(dev, \"ws2401\", dev, ws,\n\t\t\t\t&ws2401_bl_ops, &ws2401_bl_props);\n\t\tif (IS_ERR(ws->panel.backlight))\n\t\t\treturn dev_err_probe(dev, PTR_ERR(ws->panel.backlight),\n\t\t\t\t\"failed to register backlight device\\n\");\n\t} else {\n\t\tdev_dbg(dev, \"using external backlight\\n\");\n\t}\n\n\tspi_set_drvdata(spi, ws);\n\n\tdrm_panel_add(&ws->panel);\n\tdev_dbg(dev, \"added panel\\n\");\n\n\treturn 0;\n}\n\nstatic void ws2401_remove(struct spi_device *spi)\n{\n\tstruct ws2401 *ws = spi_get_drvdata(spi);\n\n\tdrm_panel_remove(&ws->panel);\n}\n\n \nstatic const struct of_device_id ws2401_match[] = {\n\t{ .compatible = \"samsung,lms380kf01\", },\n\t{},\n};\nMODULE_DEVICE_TABLE(of, ws2401_match);\n\nstatic const struct spi_device_id ws2401_ids[] = {\n\t{ \"lms380kf01\" },\n\t{ },\n};\nMODULE_DEVICE_TABLE(spi, ws2401_ids);\n\nstatic struct spi_driver ws2401_driver = {\n\t.probe\t\t= ws2401_probe,\n\t.remove\t\t= ws2401_remove,\n\t.id_table\t= ws2401_ids,\n\t.driver\t\t= {\n\t\t.name\t= \"ws2401-panel\",\n\t\t.of_match_table = ws2401_match,\n\t},\n};\nmodule_spi_driver(ws2401_driver);\n\nMODULE_AUTHOR(\"Linus Walleij <linus.walleij@linaro.org>\");\nMODULE_DESCRIPTION(\"Samsung WS2401 panel driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}