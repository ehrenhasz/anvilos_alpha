{
  "module_name": "panel-ilitek-ili9322.c",
  "hash_id": "f99b1255c814a555c53c7109f73f88658522d88f69637dc349027f6266e6ea26",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/panel/panel-ilitek-ili9322.c",
  "human_readable_source": "\n \n\n#include <linux/bitops.h>\n#include <linux/gpio/consumer.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/regmap.h>\n#include <linux/regulator/consumer.h>\n#include <linux/spi/spi.h>\n\n#include <video/mipi_display.h>\n#include <video/of_videomode.h>\n#include <video/videomode.h>\n\n#include <drm/drm_modes.h>\n#include <drm/drm_panel.h>\n\n#define ILI9322_CHIP_ID\t\t\t0x00\n#define ILI9322_CHIP_ID_MAGIC\t\t0x96\n\n \n#define ILI9322_VCOM_AMP\t\t0x01\n\n \n#define ILI9322_VCOM_HIGH\t\t0x02\n\n \n#define ILI9322_VREG1_VOLTAGE\t\t0x03\n\n \n#define ILI9322_ENTRY\t\t\t0x06\n \n#define ILI9322_ENTRY_HDIR\t\tBIT(0)\n \n#define ILI9322_ENTRY_VDIR\t\tBIT(1)\n \n#define ILI9322_ENTRY_NTSC\t\t(0 << 2)\n#define ILI9322_ENTRY_PAL\t\t(1 << 2)\n#define ILI9322_ENTRY_AUTODETECT\t(3 << 2)\n \n#define ILI9322_ENTRY_SERIAL_RGB_THROUGH (0 << 4)\n#define ILI9322_ENTRY_SERIAL_RGB_ALIGNED (1 << 4)\n#define ILI9322_ENTRY_SERIAL_RGB_DUMMY_320X240 (2 << 4)\n#define ILI9322_ENTRY_SERIAL_RGB_DUMMY_360X240 (3 << 4)\n#define ILI9322_ENTRY_DISABLE_1\t\t(4 << 4)\n#define ILI9322_ENTRY_PARALLEL_RGB_THROUGH (5 << 4)\n#define ILI9322_ENTRY_PARALLEL_RGB_ALIGNED (6 << 4)\n#define ILI9322_ENTRY_YUV_640Y_320CBCR_25_54_MHZ (7 << 4)\n#define ILI9322_ENTRY_YUV_720Y_360CBCR_27_MHZ (8 << 4)\n#define ILI9322_ENTRY_DISABLE_2\t\t(9 << 4)\n#define ILI9322_ENTRY_ITU_R_BT_656_720X360 (10 << 4)\n#define ILI9322_ENTRY_ITU_R_BT_656_640X320 (11 << 4)\n\n \n#define ILI9322_POW_CTRL\t\t0x07\n#define ILI9322_POW_CTRL_STB\t\tBIT(0)  \n#define ILI9322_POW_CTRL_VGL\t\tBIT(1)  \n#define ILI9322_POW_CTRL_VGH\t\tBIT(2)  \n#define ILI9322_POW_CTRL_DDVDH\t\tBIT(3)  \n#define ILI9322_POW_CTRL_VCOM\t\tBIT(4)  \n#define ILI9322_POW_CTRL_VCL\t\tBIT(5)  \n#define ILI9322_POW_CTRL_AUTO\t\tBIT(6)  \n#define ILI9322_POW_CTRL_STANDBY\t(ILI9322_POW_CTRL_VGL | \\\n\t\t\t\t\t ILI9322_POW_CTRL_VGH | \\\n\t\t\t\t\t ILI9322_POW_CTRL_DDVDH | \\\n\t\t\t\t\t ILI9322_POW_CTRL_VCL | \\\n\t\t\t\t\t ILI9322_POW_CTRL_AUTO | \\\n\t\t\t\t\t BIT(7))\n#define ILI9322_POW_CTRL_DEFAULT\t(ILI9322_POW_CTRL_STANDBY | \\\n\t\t\t\t\t ILI9322_POW_CTRL_STB)\n\n \n#define ILI9322_VBP\t\t\t0x08\n\n \n#define ILI9322_HBP\t\t\t0x09\n\n \n#define ILI9322_POL\t\t\t0x0a\n#define ILI9322_POL_DCLK\t\tBIT(0)  \n#define ILI9322_POL_HSYNC\t\tBIT(1)  \n#define ILI9322_POL_VSYNC\t\tBIT(2)  \n#define ILI9322_POL_DE\t\t\tBIT(3)  \n \n#define ILI9322_POL_YCBCR_MODE\t\tBIT(4)\n \n#define ILI9322_POL_FORMULA\t\tBIT(5)\n \n#define ILI9322_POL_REV\t\t\tBIT(6)\n\n#define ILI9322_IF_CTRL\t\t\t0x0b\n#define ILI9322_IF_CTRL_HSYNC_VSYNC\t0x00\n#define ILI9322_IF_CTRL_HSYNC_VSYNC_DE\tBIT(2)\n#define ILI9322_IF_CTRL_DE_ONLY\t\tBIT(3)\n#define ILI9322_IF_CTRL_SYNC_DISABLED\t(BIT(2) | BIT(3))\n#define ILI9322_IF_CTRL_LINE_INVERSION\tBIT(0)  \n\n#define ILI9322_GLOBAL_RESET\t\t0x04\n#define ILI9322_GLOBAL_RESET_ASSERT\t0x00  \n\n \n#define ILI9322_GAMMA_1\t\t\t0x10\n#define ILI9322_GAMMA_2\t\t\t0x11\n#define ILI9322_GAMMA_3\t\t\t0x12\n#define ILI9322_GAMMA_4\t\t\t0x13\n#define ILI9322_GAMMA_5\t\t\t0x14\n#define ILI9322_GAMMA_6\t\t\t0x15\n#define ILI9322_GAMMA_7\t\t\t0x16\n#define ILI9322_GAMMA_8\t\t\t0x17\n\n \nenum ili9322_input {\n\tILI9322_INPUT_SRGB_THROUGH = 0x0,\n\tILI9322_INPUT_SRGB_ALIGNED = 0x1,\n\tILI9322_INPUT_SRGB_DUMMY_320X240 = 0x2,\n\tILI9322_INPUT_SRGB_DUMMY_360X240 = 0x3,\n\tILI9322_INPUT_DISABLED_1 = 0x4,\n\tILI9322_INPUT_PRGB_THROUGH = 0x5,\n\tILI9322_INPUT_PRGB_ALIGNED = 0x6,\n\tILI9322_INPUT_YUV_640X320_YCBCR = 0x7,\n\tILI9322_INPUT_YUV_720X360_YCBCR = 0x8,\n\tILI9322_INPUT_DISABLED_2 = 0x9,\n\tILI9322_INPUT_ITU_R_BT656_720X360_YCBCR = 0xa,\n\tILI9322_INPUT_ITU_R_BT656_640X320_YCBCR = 0xb,\n\tILI9322_INPUT_UNKNOWN = 0xc,\n};\n\nstatic const char * const ili9322_inputs[] = {\n\t\"8 bit serial RGB through\",\n\t\"8 bit serial RGB aligned\",\n\t\"8 bit serial RGB dummy 320x240\",\n\t\"8 bit serial RGB dummy 360x240\",\n\t\"disabled 1\",\n\t\"24 bit parallel RGB through\",\n\t\"24 bit parallel RGB aligned\",\n\t\"24 bit YUV 640Y 320CbCr\",\n\t\"24 bit YUV 720Y 360CbCr\",\n\t\"disabled 2\",\n\t\"8 bit ITU-R BT.656 720Y 360CbCr\",\n\t\"8 bit ITU-R BT.656 640Y 320CbCr\",\n};\n\n \nstruct ili9322_config {\n\tu32 width_mm;\n\tu32 height_mm;\n\tbool flip_horizontal;\n\tbool flip_vertical;\n\tenum ili9322_input input;\n\tu32 vreg1out_mv;\n\tu32 vcom_high_percent;\n\tu32 vcom_amplitude_percent;\n\tbool dclk_active_high;\n\tbool de_active_high;\n\tbool hsync_active_high;\n\tbool vsync_active_high;\n\tu8 syncmode;\n\tu8 gamma_corr_pos[8];\n\tu8 gamma_corr_neg[8];\n};\n\nstruct ili9322 {\n\tstruct device *dev;\n\tconst struct ili9322_config *conf;\n\tstruct drm_panel panel;\n\tstruct regmap *regmap;\n\tstruct regulator_bulk_data supplies[3];\n\tstruct gpio_desc *reset_gpio;\n\tenum ili9322_input input;\n\tstruct videomode vm;\n\tu8 gamma[8];\n\tu8 vreg1out;\n\tu8 vcom_high;\n\tu8 vcom_amplitude;\n};\n\nstatic inline struct ili9322 *panel_to_ili9322(struct drm_panel *panel)\n{\n\treturn container_of(panel, struct ili9322, panel);\n}\n\nstatic int ili9322_regmap_spi_write(void *context, const void *data,\n\t\t\t\t    size_t count)\n{\n\tstruct device *dev = context;\n\tstruct spi_device *spi = to_spi_device(dev);\n\tu8 buf[2];\n\n\t \n\tmemcpy(buf, data, 2);\n\tbuf[0] &= ~0x80;\n\n\tdev_dbg(dev, \"WRITE: %02x %02x\\n\", buf[0], buf[1]);\n\treturn spi_write_then_read(spi, buf, 2, NULL, 0);\n}\n\nstatic int ili9322_regmap_spi_read(void *context, const void *reg,\n\t\t\t\t   size_t reg_size, void *val, size_t val_size)\n{\n\tstruct device *dev = context;\n\tstruct spi_device *spi = to_spi_device(dev);\n\tu8 buf[1];\n\n\t \n\tmemcpy(buf, reg, 1);\n\tdev_dbg(dev, \"READ: %02x reg size = %zu, val size = %zu\\n\",\n\t\tbuf[0], reg_size, val_size);\n\tbuf[0] |= 0x80;\n\n\treturn spi_write_then_read(spi, buf, 1, val, 1);\n}\n\nstatic struct regmap_bus ili9322_regmap_bus = {\n\t.write = ili9322_regmap_spi_write,\n\t.read = ili9322_regmap_spi_read,\n\t.reg_format_endian_default = REGMAP_ENDIAN_BIG,\n\t.val_format_endian_default = REGMAP_ENDIAN_BIG,\n};\n\nstatic bool ili9322_volatile_reg(struct device *dev, unsigned int reg)\n{\n\treturn false;\n}\n\nstatic bool ili9322_writeable_reg(struct device *dev, unsigned int reg)\n{\n\t \n\tif (reg == 0x00)\n\t\treturn false;\n\treturn true;\n}\n\nstatic const struct regmap_config ili9322_regmap_config = {\n\t.reg_bits = 8,\n\t.val_bits = 8,\n\t.max_register = 0x44,\n\t.cache_type = REGCACHE_RBTREE,\n\t.volatile_reg = ili9322_volatile_reg,\n\t.writeable_reg = ili9322_writeable_reg,\n};\n\nstatic int ili9322_init(struct drm_panel *panel, struct ili9322 *ili)\n{\n\tu8 reg;\n\tint ret;\n\tint i;\n\n\t \n\tret = regmap_write(ili->regmap, ILI9322_GLOBAL_RESET,\n\t\t\t   ILI9322_GLOBAL_RESET_ASSERT);\n\tif (ret) {\n\t\tdev_err(ili->dev, \"can't issue GRESET (%d)\\n\", ret);\n\t\treturn ret;\n\t}\n\n\t \n\tif (ili->vreg1out != U8_MAX) {\n\t\tret = regmap_write(ili->regmap, ILI9322_VREG1_VOLTAGE,\n\t\t\t\t   ili->vreg1out);\n\t\tif (ret) {\n\t\t\tdev_err(ili->dev, \"can't set up VREG1OUT (%d)\\n\", ret);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tif (ili->vcom_amplitude != U8_MAX) {\n\t\tret = regmap_write(ili->regmap, ILI9322_VCOM_AMP,\n\t\t\t\t   ili->vcom_amplitude);\n\t\tif (ret) {\n\t\t\tdev_err(ili->dev,\n\t\t\t\t\"can't set up VCOM amplitude (%d)\\n\", ret);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tif (ili->vcom_high != U8_MAX) {\n\t\tret = regmap_write(ili->regmap, ILI9322_VCOM_HIGH,\n\t\t\t\t   ili->vcom_high);\n\t\tif (ret) {\n\t\t\tdev_err(ili->dev, \"can't set up VCOM high (%d)\\n\", ret);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\t \n\tfor (i = 0; i < ARRAY_SIZE(ili->gamma); i++) {\n\t\tret = regmap_write(ili->regmap, ILI9322_GAMMA_1 + i,\n\t\t\t\t   ili->gamma[i]);\n\t\tif (ret) {\n\t\t\tdev_err(ili->dev,\n\t\t\t\t\"can't write gamma V%d to 0x%02x (%d)\\n\",\n\t\t\t\ti + 1, ILI9322_GAMMA_1 + i, ret);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\t \n\treg = 0;\n\tif (ili->conf->dclk_active_high)\n\t\treg = ILI9322_POL_DCLK;\n\tif (ili->conf->de_active_high)\n\t\treg |= ILI9322_POL_DE;\n\tif (ili->conf->hsync_active_high)\n\t\treg |= ILI9322_POL_HSYNC;\n\tif (ili->conf->vsync_active_high)\n\t\treg |= ILI9322_POL_VSYNC;\n\tret = regmap_write(ili->regmap, ILI9322_POL, reg);\n\tif (ret) {\n\t\tdev_err(ili->dev, \"can't write POL register (%d)\\n\", ret);\n\t\treturn ret;\n\t}\n\n\t \n\treg = ili->conf->syncmode;\n\treg |= ILI9322_IF_CTRL_LINE_INVERSION;\n\tret = regmap_write(ili->regmap, ILI9322_IF_CTRL, reg);\n\tif (ret) {\n\t\tdev_err(ili->dev, \"can't write IF CTRL register (%d)\\n\", ret);\n\t\treturn ret;\n\t}\n\n\t \n\treg = (ili->input << 4);\n\t \n\tif (!ili->conf->flip_horizontal)\n\t\treg |= ILI9322_ENTRY_HDIR;\n\tif (!ili->conf->flip_vertical)\n\t\treg |= ILI9322_ENTRY_VDIR;\n\treg |= ILI9322_ENTRY_AUTODETECT;\n\tret = regmap_write(ili->regmap, ILI9322_ENTRY, reg);\n\tif (ret) {\n\t\tdev_err(ili->dev, \"can't write ENTRY reg (%d)\\n\", ret);\n\t\treturn ret;\n\t}\n\tdev_info(ili->dev, \"display is in %s mode, syncmode %02x\\n\",\n\t\t ili9322_inputs[ili->input],\n\t\t ili->conf->syncmode);\n\n\tdev_info(ili->dev, \"initialized display\\n\");\n\n\treturn 0;\n}\n\n \nstatic int ili9322_power_on(struct ili9322 *ili)\n{\n\tint ret;\n\n\t \n\tgpiod_set_value(ili->reset_gpio, 1);\n\n\tret = regulator_bulk_enable(ARRAY_SIZE(ili->supplies), ili->supplies);\n\tif (ret < 0) {\n\t\tdev_err(ili->dev, \"unable to enable regulators\\n\");\n\t\treturn ret;\n\t}\n\tmsleep(20);\n\n\t \n\tgpiod_set_value(ili->reset_gpio, 0);\n\n\tmsleep(10);\n\n\treturn 0;\n}\n\nstatic int ili9322_power_off(struct ili9322 *ili)\n{\n\treturn regulator_bulk_disable(ARRAY_SIZE(ili->supplies), ili->supplies);\n}\n\nstatic int ili9322_disable(struct drm_panel *panel)\n{\n\tstruct ili9322 *ili = panel_to_ili9322(panel);\n\tint ret;\n\n\tret = regmap_write(ili->regmap, ILI9322_POW_CTRL,\n\t\t\t   ILI9322_POW_CTRL_STANDBY);\n\tif (ret) {\n\t\tdev_err(ili->dev, \"unable to go to standby mode\\n\");\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int ili9322_unprepare(struct drm_panel *panel)\n{\n\tstruct ili9322 *ili = panel_to_ili9322(panel);\n\n\treturn ili9322_power_off(ili);\n}\n\nstatic int ili9322_prepare(struct drm_panel *panel)\n{\n\tstruct ili9322 *ili = panel_to_ili9322(panel);\n\tint ret;\n\n\tret = ili9322_power_on(ili);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = ili9322_init(panel, ili);\n\tif (ret < 0)\n\t\tili9322_unprepare(panel);\n\n\treturn ret;\n}\n\nstatic int ili9322_enable(struct drm_panel *panel)\n{\n\tstruct ili9322 *ili = panel_to_ili9322(panel);\n\tint ret;\n\n\tret = regmap_write(ili->regmap, ILI9322_POW_CTRL,\n\t\t\t   ILI9322_POW_CTRL_DEFAULT);\n\tif (ret) {\n\t\tdev_err(ili->dev, \"unable to enable panel\\n\");\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\n \nstatic const struct drm_display_mode srgb_320x240_mode = {\n\t.clock = 24535,\n\t.hdisplay = 320,\n\t.hsync_start = 320 + 359,\n\t.hsync_end = 320 + 359 + 1,\n\t.htotal = 320 + 359 + 1 + 241,\n\t.vdisplay = 240,\n\t.vsync_start = 240 + 4,\n\t.vsync_end = 240 + 4 + 1,\n\t.vtotal = 262,\n\t.flags = 0,\n};\n\nstatic const struct drm_display_mode srgb_360x240_mode = {\n\t.clock = 27000,\n\t.hdisplay = 360,\n\t.hsync_start = 360 + 35,\n\t.hsync_end = 360 + 35 + 1,\n\t.htotal = 360 + 35 + 1 + 241,\n\t.vdisplay = 240,\n\t.vsync_start = 240 + 21,\n\t.vsync_end = 240 + 21 + 1,\n\t.vtotal = 262,\n\t.flags = 0,\n};\n\n \nstatic const struct drm_display_mode prgb_320x240_mode = {\n\t.clock = 64000,\n\t.hdisplay = 320,\n\t.hsync_start = 320 + 38,\n\t.hsync_end = 320 + 38 + 1,\n\t.htotal = 320 + 38 + 1 + 50,\n\t.vdisplay = 240,\n\t.vsync_start = 240 + 4,\n\t.vsync_end = 240 + 4 + 1,\n\t.vtotal = 262,\n\t.flags = 0,\n};\n\n \nstatic const struct drm_display_mode yuv_640x320_mode = {\n\t.clock = 24540,\n\t.hdisplay = 640,\n\t.hsync_start = 640 + 252,\n\t.hsync_end = 640 + 252 + 1,\n\t.htotal = 640 + 252 + 1 + 28,\n\t.vdisplay = 320,\n\t.vsync_start = 320 + 4,\n\t.vsync_end = 320 + 4 + 1,\n\t.vtotal = 320 + 4 + 1 + 18,\n\t.flags = 0,\n};\n\nstatic const struct drm_display_mode yuv_720x360_mode = {\n\t.clock = 27000,\n\t.hdisplay = 720,\n\t.hsync_start = 720 + 252,\n\t.hsync_end = 720 + 252 + 1,\n\t.htotal = 720 + 252 + 1 + 24,\n\t.vdisplay = 360,\n\t.vsync_start = 360 + 4,\n\t.vsync_end = 360 + 4 + 1,\n\t.vtotal = 360 + 4 + 1 + 18,\n\t.flags = 0,\n};\n\n \nstatic const struct drm_display_mode itu_r_bt_656_640_mode = {\n\t.clock = 24540,\n\t.hdisplay = 640,\n\t.hsync_start = 640 + 3,\n\t.hsync_end = 640 + 3 + 1,\n\t.htotal = 640 + 3 + 1 + 272,\n\t.vdisplay = 480,\n\t.vsync_start = 480 + 4,\n\t.vsync_end = 480 + 4 + 1,\n\t.vtotal = 500,\n\t.flags = 0,\n};\n\n \nstatic const struct drm_display_mode itu_r_bt_656_720_mode = {\n\t.clock = 27000,\n\t.hdisplay = 720,\n\t.hsync_start = 720 + 3,\n\t.hsync_end = 720 + 3 + 1,\n\t.htotal = 720 + 3 + 1 + 272,\n\t.vdisplay = 480,\n\t.vsync_start = 480 + 4,\n\t.vsync_end = 480 + 4 + 1,\n\t.vtotal = 500,\n\t.flags = 0,\n};\n\nstatic int ili9322_get_modes(struct drm_panel *panel,\n\t\t\t     struct drm_connector *connector)\n{\n\tstruct ili9322 *ili = panel_to_ili9322(panel);\n\tstruct drm_device *drm = connector->dev;\n\tstruct drm_display_mode *mode;\n\tstruct drm_display_info *info;\n\n\tinfo = &connector->display_info;\n\tinfo->width_mm = ili->conf->width_mm;\n\tinfo->height_mm = ili->conf->height_mm;\n\tif (ili->conf->dclk_active_high)\n\t\tinfo->bus_flags |= DRM_BUS_FLAG_PIXDATA_DRIVE_POSEDGE;\n\telse\n\t\tinfo->bus_flags |= DRM_BUS_FLAG_PIXDATA_DRIVE_NEGEDGE;\n\n\tif (ili->conf->de_active_high)\n\t\tinfo->bus_flags |= DRM_BUS_FLAG_DE_HIGH;\n\telse\n\t\tinfo->bus_flags |= DRM_BUS_FLAG_DE_LOW;\n\n\tswitch (ili->input) {\n\tcase ILI9322_INPUT_SRGB_DUMMY_320X240:\n\t\tmode = drm_mode_duplicate(drm, &srgb_320x240_mode);\n\t\tbreak;\n\tcase ILI9322_INPUT_SRGB_DUMMY_360X240:\n\t\tmode = drm_mode_duplicate(drm, &srgb_360x240_mode);\n\t\tbreak;\n\tcase ILI9322_INPUT_PRGB_THROUGH:\n\tcase ILI9322_INPUT_PRGB_ALIGNED:\n\t\tmode = drm_mode_duplicate(drm, &prgb_320x240_mode);\n\t\tbreak;\n\tcase ILI9322_INPUT_YUV_640X320_YCBCR:\n\t\tmode = drm_mode_duplicate(drm, &yuv_640x320_mode);\n\t\tbreak;\n\tcase ILI9322_INPUT_YUV_720X360_YCBCR:\n\t\tmode = drm_mode_duplicate(drm, &yuv_720x360_mode);\n\t\tbreak;\n\tcase ILI9322_INPUT_ITU_R_BT656_720X360_YCBCR:\n\t\tmode = drm_mode_duplicate(drm, &itu_r_bt_656_720_mode);\n\t\tbreak;\n\tcase ILI9322_INPUT_ITU_R_BT656_640X320_YCBCR:\n\t\tmode = drm_mode_duplicate(drm, &itu_r_bt_656_640_mode);\n\t\tbreak;\n\tdefault:\n\t\tmode = NULL;\n\t\tbreak;\n\t}\n\tif (!mode) {\n\t\tdev_err(panel->dev, \"bad mode or failed to add mode\\n\");\n\t\treturn -EINVAL;\n\t}\n\tdrm_mode_set_name(mode);\n\t \n\tmode->type = DRM_MODE_TYPE_DRIVER | DRM_MODE_TYPE_PREFERRED;\n\n\t \n\tif (ili->conf->hsync_active_high)\n\t\tmode->flags |= DRM_MODE_FLAG_PHSYNC;\n\telse\n\t\tmode->flags |= DRM_MODE_FLAG_NHSYNC;\n\tif (ili->conf->vsync_active_high)\n\t\tmode->flags |= DRM_MODE_FLAG_PVSYNC;\n\telse\n\t\tmode->flags |= DRM_MODE_FLAG_NVSYNC;\n\n\tmode->width_mm = ili->conf->width_mm;\n\tmode->height_mm = ili->conf->height_mm;\n\tdrm_mode_probed_add(connector, mode);\n\n\treturn 1;  \n}\n\nstatic const struct drm_panel_funcs ili9322_drm_funcs = {\n\t.disable = ili9322_disable,\n\t.unprepare = ili9322_unprepare,\n\t.prepare = ili9322_prepare,\n\t.enable = ili9322_enable,\n\t.get_modes = ili9322_get_modes,\n};\n\nstatic int ili9322_probe(struct spi_device *spi)\n{\n\tstruct device *dev = &spi->dev;\n\tstruct ili9322 *ili;\n\tconst struct regmap_config *regmap_config;\n\tu8 gamma;\n\tu32 val;\n\tint ret;\n\tint i;\n\n\tili = devm_kzalloc(dev, sizeof(struct ili9322), GFP_KERNEL);\n\tif (!ili)\n\t\treturn -ENOMEM;\n\n\tspi_set_drvdata(spi, ili);\n\n\tili->dev = dev;\n\n\t \n\tili->conf = of_device_get_match_data(dev);\n\tif (!ili->conf) {\n\t\tdev_err(dev, \"missing device configuration\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tval = ili->conf->vreg1out_mv;\n\tif (!val) {\n\t\t \n\t\tili->vreg1out = U8_MAX;\n\t} else {\n\t\tif (val < 3600) {\n\t\t\tdev_err(dev, \"too low VREG1OUT\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (val > 6000) {\n\t\t\tdev_err(dev, \"too high VREG1OUT\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tif ((val % 100) != 0) {\n\t\t\tdev_err(dev, \"VREG1OUT is no even 100 microvolt\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tval -= 3600;\n\t\tval /= 100;\n\t\tdev_dbg(dev, \"VREG1OUT = 0x%02x\\n\", val);\n\t\tili->vreg1out = val;\n\t}\n\n\tval = ili->conf->vcom_high_percent;\n\tif (!val) {\n\t\t \n\t\tili->vcom_high = U8_MAX;\n\t} else {\n\t\tif (val < 37) {\n\t\t\tdev_err(dev, \"too low VCOM high\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (val > 100) {\n\t\t\tdev_err(dev, \"too high VCOM high\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tval -= 37;\n\t\tdev_dbg(dev, \"VCOM high = 0x%02x\\n\", val);\n\t\tili->vcom_high = val;\n\t}\n\n\tval = ili->conf->vcom_amplitude_percent;\n\tif (!val) {\n\t\t \n\t\tili->vcom_high = U8_MAX;\n\t} else {\n\t\tif (val < 70) {\n\t\t\tdev_err(dev, \"too low VCOM amplitude\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (val > 132) {\n\t\t\tdev_err(dev, \"too high VCOM amplitude\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tval -= 70;\n\t\tval >>= 1;  \n\t\tdev_dbg(dev, \"VCOM amplitude = 0x%02x\\n\", val);\n\t\tili->vcom_amplitude = val;\n\t}\n\n\tfor (i = 0; i < ARRAY_SIZE(ili->gamma); i++) {\n\t\tval = ili->conf->gamma_corr_neg[i];\n\t\tif (val > 15) {\n\t\t\tdev_err(dev, \"negative gamma %u > 15, capping\\n\", val);\n\t\t\tval = 15;\n\t\t}\n\t\tgamma = val << 4;\n\t\tval = ili->conf->gamma_corr_pos[i];\n\t\tif (val > 15) {\n\t\t\tdev_err(dev, \"positive gamma %u > 15, capping\\n\", val);\n\t\t\tval = 15;\n\t\t}\n\t\tgamma |= val;\n\t\tili->gamma[i] = gamma;\n\t\tdev_dbg(dev, \"gamma V%d: 0x%02x\\n\", i + 1, gamma);\n\t}\n\n\tili->supplies[0].supply = \"vcc\";  \n\tili->supplies[1].supply = \"iovcc\";  \n\tili->supplies[2].supply = \"vci\";  \n\tret = devm_regulator_bulk_get(dev, ARRAY_SIZE(ili->supplies),\n\t\t\t\t      ili->supplies);\n\tif (ret < 0)\n\t\treturn ret;\n\tret = regulator_set_voltage(ili->supplies[0].consumer,\n\t\t\t\t    2700000, 3600000);\n\tif (ret)\n\t\treturn ret;\n\tret = regulator_set_voltage(ili->supplies[1].consumer,\n\t\t\t\t    1650000, 3600000);\n\tif (ret)\n\t\treturn ret;\n\tret = regulator_set_voltage(ili->supplies[2].consumer,\n\t\t\t\t    2700000, 3600000);\n\tif (ret)\n\t\treturn ret;\n\n\tili->reset_gpio = devm_gpiod_get_optional(dev, \"reset\", GPIOD_OUT_HIGH);\n\tif (IS_ERR(ili->reset_gpio)) {\n\t\tdev_err(dev, \"failed to get RESET GPIO\\n\");\n\t\treturn PTR_ERR(ili->reset_gpio);\n\t}\n\n\tspi->bits_per_word = 8;\n\tret = spi_setup(spi);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"spi setup failed.\\n\");\n\t\treturn ret;\n\t}\n\tregmap_config = &ili9322_regmap_config;\n\tili->regmap = devm_regmap_init(dev, &ili9322_regmap_bus, dev,\n\t\t\t\t       regmap_config);\n\tif (IS_ERR(ili->regmap)) {\n\t\tdev_err(dev, \"failed to allocate register map\\n\");\n\t\treturn PTR_ERR(ili->regmap);\n\t}\n\n\tret = regmap_read(ili->regmap, ILI9322_CHIP_ID, &val);\n\tif (ret) {\n\t\tdev_err(dev, \"can't get chip ID (%d)\\n\", ret);\n\t\treturn ret;\n\t}\n\tif (val != ILI9322_CHIP_ID_MAGIC) {\n\t\tdev_err(dev, \"chip ID 0x%0x2, expected 0x%02x\\n\", val,\n\t\t\tILI9322_CHIP_ID_MAGIC);\n\t\treturn -ENODEV;\n\t}\n\n\t \n\tif (ili->conf->input == ILI9322_INPUT_UNKNOWN) {\n\t\tret = regmap_read(ili->regmap, ILI9322_ENTRY, &val);\n\t\tif (ret) {\n\t\t\tdev_err(dev, \"can't get entry setting (%d)\\n\", ret);\n\t\t\treturn ret;\n\t\t}\n\t\t \n\t\tili->input = (val >> 4) & 0x0f;\n\t\tif (ili->input >= ILI9322_INPUT_UNKNOWN)\n\t\t\tili->input = ILI9322_INPUT_UNKNOWN;\n\t} else {\n\t\tili->input = ili->conf->input;\n\t}\n\n\tdrm_panel_init(&ili->panel, dev, &ili9322_drm_funcs,\n\t\t       DRM_MODE_CONNECTOR_DPI);\n\n\tdrm_panel_add(&ili->panel);\n\n\treturn 0;\n}\n\nstatic void ili9322_remove(struct spi_device *spi)\n{\n\tstruct ili9322 *ili = spi_get_drvdata(spi);\n\n\tili9322_power_off(ili);\n\tdrm_panel_remove(&ili->panel);\n}\n\n \nstatic const struct ili9322_config ili9322_dir_685 = {\n\t.width_mm = 65,\n\t.height_mm = 50,\n\t.input = ILI9322_INPUT_ITU_R_BT656_640X320_YCBCR,\n\t.vreg1out_mv = 4600,\n\t.vcom_high_percent = 91,\n\t.vcom_amplitude_percent = 114,\n\t.syncmode = ILI9322_IF_CTRL_SYNC_DISABLED,\n\t.dclk_active_high = true,\n\t.gamma_corr_neg = { 0xa, 0x5, 0x7, 0x7, 0x7, 0x5, 0x1, 0x6 },\n\t.gamma_corr_pos = { 0x7, 0x7, 0x3, 0x2, 0x3, 0x5, 0x7, 0x2 },\n};\n\nstatic const struct of_device_id ili9322_of_match[] = {\n\t{\n\t\t.compatible = \"dlink,dir-685-panel\",\n\t\t.data = &ili9322_dir_685,\n\t},\n\t{\n\t\t.compatible = \"ilitek,ili9322\",\n\t\t.data = NULL,\n\t},\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, ili9322_of_match);\n\nstatic struct spi_driver ili9322_driver = {\n\t.probe = ili9322_probe,\n\t.remove = ili9322_remove,\n\t.driver = {\n\t\t.name = \"panel-ilitek-ili9322\",\n\t\t.of_match_table = ili9322_of_match,\n\t},\n};\nmodule_spi_driver(ili9322_driver);\n\nMODULE_AUTHOR(\"Linus Walleij <linus.walleij@linaro.org>\");\nMODULE_DESCRIPTION(\"ILI9322 LCD panel driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}