{
  "module_name": "panel-boe-bf060y8m-aj0.c",
  "hash_id": "a22058c60c0d15663a2d32fb49b9ff2556955b4f3d3ac7596954f28a60f76b15",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/panel/panel-boe-bf060y8m-aj0.c",
  "human_readable_source": "\n \n\n#include <linux/backlight.h>\n#include <linux/delay.h>\n#include <linux/gpio/consumer.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/regulator/consumer.h>\n#include <video/mipi_display.h>\n#include <drm/drm_mipi_dsi.h>\n#include <drm/drm_modes.h>\n#include <drm/drm_panel.h>\n\n#define DCS_ALLOW_HBM_RANGE\t\t0x0c\n#define DCS_DISALLOW_HBM_RANGE\t\t0x08\n\nenum boe_bf060y8m_aj0_supplies {\n\tBF060Y8M_VREG_VCC,\n\tBF060Y8M_VREG_VDDIO,\n\tBF060Y8M_VREG_VCI,\n\tBF060Y8M_VREG_EL_VDD,\n\tBF060Y8M_VREG_EL_VSS,\n\tBF060Y8M_VREG_MAX\n};\n\nstruct boe_bf060y8m_aj0 {\n\tstruct drm_panel panel;\n\tstruct mipi_dsi_device *dsi;\n\tstruct regulator_bulk_data vregs[BF060Y8M_VREG_MAX];\n\tstruct gpio_desc *reset_gpio;\n\tbool prepared;\n};\n\nstatic inline\nstruct boe_bf060y8m_aj0 *to_boe_bf060y8m_aj0(struct drm_panel *panel)\n{\n\treturn container_of(panel, struct boe_bf060y8m_aj0, panel);\n}\n\nstatic void boe_bf060y8m_aj0_reset(struct boe_bf060y8m_aj0 *boe)\n{\n\tgpiod_set_value_cansleep(boe->reset_gpio, 0);\n\tusleep_range(2000, 3000);\n\tgpiod_set_value_cansleep(boe->reset_gpio, 1);\n\tusleep_range(15000, 16000);\n\tgpiod_set_value_cansleep(boe->reset_gpio, 0);\n\tusleep_range(5000, 6000);\n}\n\nstatic int boe_bf060y8m_aj0_on(struct boe_bf060y8m_aj0 *boe)\n{\n\tstruct mipi_dsi_device *dsi = boe->dsi;\n\tstruct device *dev = &dsi->dev;\n\tint ret;\n\n\tmipi_dsi_dcs_write_seq(dsi, 0xb0, 0xa5, 0x00);\n\tmipi_dsi_dcs_write_seq(dsi, 0xb2, 0x00, 0x4c);\n\tmipi_dsi_dcs_write_seq(dsi, MIPI_DCS_SET_3D_CONTROL, 0x10);\n\tmipi_dsi_dcs_write_seq(dsi, MIPI_DCS_WRITE_POWER_SAVE, DCS_ALLOW_HBM_RANGE);\n\tmipi_dsi_dcs_write_seq(dsi, 0xf8,\n\t\t\t       0x00, 0x08, 0x10, 0x00, 0x22, 0x00, 0x00, 0x2d);\n\n\tret = mipi_dsi_dcs_exit_sleep_mode(dsi);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"Failed to exit sleep mode: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\tmsleep(30);\n\n\tmipi_dsi_dcs_write_seq(dsi, 0xb0, 0xa5, 0x00);\n\tmipi_dsi_dcs_write_seq(dsi, 0xc0,\n\t\t\t       0x08, 0x48, 0x65, 0x33, 0x33, 0x33,\n\t\t\t       0x2a, 0x31, 0x39, 0x20, 0x09);\n\tmipi_dsi_dcs_write_seq(dsi, 0xc1, 0x00, 0x00, 0x00, 0x1f, 0x1f,\n\t\t\t       0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 0x1f,\n\t\t\t       0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 0x1f);\n\tmipi_dsi_dcs_write_seq(dsi, 0xe2, 0x20, 0x04, 0x10, 0x12, 0x92,\n\t\t\t       0x4f, 0x8f, 0x44, 0x84, 0x83, 0x83, 0x83,\n\t\t\t       0x5c, 0x5c, 0x5c);\n\tmipi_dsi_dcs_write_seq(dsi, 0xde, 0x01, 0x2c, 0x00, 0x77, 0x3e);\n\n\tmsleep(30);\n\n\tret = mipi_dsi_dcs_set_display_on(dsi);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"Failed to set display on: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\tmsleep(50);\n\n\treturn 0;\n}\n\nstatic int boe_bf060y8m_aj0_off(struct boe_bf060y8m_aj0 *boe)\n{\n\tstruct mipi_dsi_device *dsi = boe->dsi;\n\tstruct device *dev = &dsi->dev;\n\tint ret;\n\n\t \n\tdsi->mode_flags &= ~MIPI_DSI_MODE_LPM;\n\tret = mipi_dsi_dcs_set_display_off(dsi);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"Failed to set display off: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\tmsleep(20);\n\n\tret = mipi_dsi_dcs_enter_sleep_mode(dsi);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"Failed to enter sleep mode: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\tusleep_range(1000, 2000);\n\tdsi->mode_flags |= MIPI_DSI_MODE_LPM;\n\n\treturn 0;\n}\n\nstatic int boe_bf060y8m_aj0_prepare(struct drm_panel *panel)\n{\n\tstruct boe_bf060y8m_aj0 *boe = to_boe_bf060y8m_aj0(panel);\n\tstruct device *dev = &boe->dsi->dev;\n\tint ret;\n\n\tif (boe->prepared)\n\t\treturn 0;\n\n\t \n\tret = regulator_enable(boe->vregs[BF060Y8M_VREG_EL_VDD].consumer);\n\tif (ret)\n\t\treturn ret;\n\tret = regulator_enable(boe->vregs[BF060Y8M_VREG_EL_VSS].consumer);\n\tif (ret)\n\t\tgoto err_elvss;\n\n\tret = regulator_enable(boe->vregs[BF060Y8M_VREG_VCC].consumer);\n\tif (ret)\n\t\tgoto err_vcc;\n\tusleep_range(1000, 2000);\n\tret = regulator_enable(boe->vregs[BF060Y8M_VREG_VDDIO].consumer);\n\tif (ret)\n\t\tgoto err_vddio;\n\tusleep_range(500, 1000);\n\tret = regulator_enable(boe->vregs[BF060Y8M_VREG_VCI].consumer);\n\tif (ret)\n\t\tgoto err_vci;\n\tusleep_range(2000, 3000);\n\n\tboe_bf060y8m_aj0_reset(boe);\n\n\tret = boe_bf060y8m_aj0_on(boe);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"Failed to initialize panel: %d\\n\", ret);\n\t\tgpiod_set_value_cansleep(boe->reset_gpio, 1);\n\t\treturn ret;\n\t}\n\n\tboe->prepared = true;\n\treturn 0;\n\nerr_vci:\n\tregulator_disable(boe->vregs[BF060Y8M_VREG_VDDIO].consumer);\nerr_vddio:\n\tregulator_disable(boe->vregs[BF060Y8M_VREG_VCC].consumer);\nerr_vcc:\n\tregulator_disable(boe->vregs[BF060Y8M_VREG_EL_VSS].consumer);\nerr_elvss:\n\tregulator_disable(boe->vregs[BF060Y8M_VREG_EL_VDD].consumer);\n\treturn ret;\n}\n\nstatic int boe_bf060y8m_aj0_unprepare(struct drm_panel *panel)\n{\n\tstruct boe_bf060y8m_aj0 *boe = to_boe_bf060y8m_aj0(panel);\n\tstruct device *dev = &boe->dsi->dev;\n\tint ret;\n\n\tif (!boe->prepared)\n\t\treturn 0;\n\n\tret = boe_bf060y8m_aj0_off(boe);\n\tif (ret < 0)\n\t\tdev_err(dev, \"Failed to un-initialize panel: %d\\n\", ret);\n\n\tgpiod_set_value_cansleep(boe->reset_gpio, 1);\n\tret = regulator_bulk_disable(ARRAY_SIZE(boe->vregs), boe->vregs);\n\n\tboe->prepared = false;\n\treturn 0;\n}\n\nstatic const struct drm_display_mode boe_bf060y8m_aj0_mode = {\n\t.clock = 165268,\n\t.hdisplay = 1080,\n\t.hsync_start = 1080 + 36,\n\t.hsync_end = 1080 + 36 + 24,\n\t.htotal = 1080 + 36 + 24 + 96,\n\t.vdisplay = 2160,\n\t.vsync_start = 2160 + 16,\n\t.vsync_end = 2160 + 16 + 1,\n\t.vtotal = 2160 + 16 + 1 + 15,\n\t.width_mm = 68,    \n\t.height_mm = 136,  \n};\n\nstatic int boe_bf060y8m_aj0_get_modes(struct drm_panel *panel,\n\t\t\t\t      struct drm_connector *connector)\n{\n\tstruct drm_display_mode *mode;\n\n\tmode = drm_mode_duplicate(connector->dev, &boe_bf060y8m_aj0_mode);\n\tif (!mode)\n\t\treturn -ENOMEM;\n\n\tdrm_mode_set_name(mode);\n\n\tmode->type = DRM_MODE_TYPE_DRIVER | DRM_MODE_TYPE_PREFERRED;\n\tconnector->display_info.width_mm = mode->width_mm;\n\tconnector->display_info.height_mm = mode->height_mm;\n\tdrm_mode_probed_add(connector, mode);\n\n\treturn 1;\n}\n\nstatic const struct drm_panel_funcs boe_bf060y8m_aj0_panel_funcs = {\n\t.prepare = boe_bf060y8m_aj0_prepare,\n\t.unprepare = boe_bf060y8m_aj0_unprepare,\n\t.get_modes = boe_bf060y8m_aj0_get_modes,\n};\n\nstatic int boe_bf060y8m_aj0_bl_update_status(struct backlight_device *bl)\n{\n\tstruct mipi_dsi_device *dsi = bl_get_data(bl);\n\tu16 brightness = backlight_get_brightness(bl);\n\tint ret;\n\n\tret = mipi_dsi_dcs_set_display_brightness(dsi, brightness);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn 0;\n}\n\nstatic int boe_bf060y8m_aj0_bl_get_brightness(struct backlight_device *bl)\n{\n\tstruct mipi_dsi_device *dsi = bl_get_data(bl);\n\tu16 brightness;\n\tint ret;\n\n\tret = mipi_dsi_dcs_get_display_brightness(dsi, &brightness);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn brightness & 0xff;\n}\n\nstatic const struct backlight_ops boe_bf060y8m_aj0_bl_ops = {\n\t.update_status = boe_bf060y8m_aj0_bl_update_status,\n\t.get_brightness = boe_bf060y8m_aj0_bl_get_brightness,\n};\n\nstatic struct backlight_device *\nboe_bf060y8m_aj0_create_backlight(struct mipi_dsi_device *dsi)\n{\n\tstruct device *dev = &dsi->dev;\n\tconst struct backlight_properties props = {\n\t\t.type = BACKLIGHT_RAW,\n\t\t.brightness = 127,\n\t\t.max_brightness = 255,\n\t\t.scale = BACKLIGHT_SCALE_NON_LINEAR,\n\t};\n\n\treturn devm_backlight_device_register(dev, dev_name(dev), dev, dsi,\n\t\t\t\t\t      &boe_bf060y8m_aj0_bl_ops, &props);\n}\n\nstatic int boe_bf060y8m_aj0_init_vregs(struct boe_bf060y8m_aj0 *boe,\n\t\t\t\t       struct device *dev)\n{\n\tstruct regulator *vreg;\n\tint ret;\n\n\tboe->vregs[BF060Y8M_VREG_VCC].supply = \"vcc\";\n\tboe->vregs[BF060Y8M_VREG_VDDIO].supply = \"vddio\";\n\tboe->vregs[BF060Y8M_VREG_VCI].supply = \"vci\";\n\tboe->vregs[BF060Y8M_VREG_EL_VDD].supply = \"elvdd\";\n\tboe->vregs[BF060Y8M_VREG_EL_VSS].supply = \"elvss\";\n\tret = devm_regulator_bulk_get(dev, ARRAY_SIZE(boe->vregs),\n\t\t\t\t      boe->vregs);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"Failed to get regulators: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tvreg = boe->vregs[BF060Y8M_VREG_VCC].consumer;\n\tret = regulator_is_supported_voltage(vreg, 2700000, 3600000);\n\tif (!ret)\n\t\treturn ret;\n\n\tvreg = boe->vregs[BF060Y8M_VREG_VDDIO].consumer;\n\tret = regulator_is_supported_voltage(vreg, 1620000, 1980000);\n\tif (!ret)\n\t\treturn ret;\n\n\tvreg = boe->vregs[BF060Y8M_VREG_VCI].consumer;\n\tret = regulator_is_supported_voltage(vreg, 2600000, 3600000);\n\tif (!ret)\n\t\treturn ret;\n\n\tvreg = boe->vregs[BF060Y8M_VREG_EL_VDD].consumer;\n\tret = regulator_is_supported_voltage(vreg, 4400000, 4800000);\n\tif (!ret)\n\t\treturn ret;\n\n\t \n\tvreg = boe->vregs[BF060Y8M_VREG_EL_VSS].consumer;\n\tret = regulator_is_supported_voltage(vreg, 1400000, 5000000);\n\tif (!ret)\n\t\treturn ret;\n\n\t \n\tvreg = boe->vregs[BF060Y8M_VREG_VDDIO].consumer;\n\tret = regulator_set_current_limit(vreg, 1500, 2500);\n\tif (ret)\n\t\tdev_dbg(dev, \"Current limit cannot be set on %s: %d\\n\",\n\t\t\tboe->vregs[1].supply, ret);\n\n\tvreg = boe->vregs[BF060Y8M_VREG_VCI].consumer;\n\tret = regulator_set_current_limit(vreg, 20000, 40000);\n\tif (ret)\n\t\tdev_dbg(dev, \"Current limit cannot be set on %s: %d\\n\",\n\t\t\tboe->vregs[2].supply, ret);\n\n\treturn 0;\n}\n\nstatic int boe_bf060y8m_aj0_probe(struct mipi_dsi_device *dsi)\n{\n\tstruct device *dev = &dsi->dev;\n\tstruct boe_bf060y8m_aj0 *boe;\n\tint ret;\n\n\tboe = devm_kzalloc(dev, sizeof(*boe), GFP_KERNEL);\n\tif (!boe)\n\t\treturn -ENOMEM;\n\n\tret = boe_bf060y8m_aj0_init_vregs(boe, dev);\n\tif (ret)\n\t\treturn dev_err_probe(dev, ret,\n\t\t\t\t     \"Failed to initialize supplies.\\n\");\n\n\tboe->reset_gpio = devm_gpiod_get_optional(dev, \"reset\", GPIOD_ASIS);\n\tif (IS_ERR(boe->reset_gpio))\n\t\treturn dev_err_probe(dev, PTR_ERR(boe->reset_gpio),\n\t\t\t\t     \"Failed to get reset-gpios\\n\");\n\n\tboe->dsi = dsi;\n\tmipi_dsi_set_drvdata(dsi, boe);\n\n\tdsi->lanes = 4;\n\tdsi->format = MIPI_DSI_FMT_RGB888;\n\tdsi->mode_flags = MIPI_DSI_MODE_VIDEO | MIPI_DSI_MODE_NO_EOT_PACKET |\n\t\t\t  MIPI_DSI_MODE_VIDEO_SYNC_PULSE |\n\t\t\t  MIPI_DSI_CLOCK_NON_CONTINUOUS |\n\t\t\t  MIPI_DSI_MODE_LPM;\n\n\tdrm_panel_init(&boe->panel, dev, &boe_bf060y8m_aj0_panel_funcs,\n\t\t       DRM_MODE_CONNECTOR_DSI);\n\n\tboe->panel.backlight = boe_bf060y8m_aj0_create_backlight(dsi);\n\tif (IS_ERR(boe->panel.backlight))\n\t\treturn dev_err_probe(dev, PTR_ERR(boe->panel.backlight),\n\t\t\t\t     \"Failed to create backlight\\n\");\n\n\tdrm_panel_add(&boe->panel);\n\n\tret = mipi_dsi_attach(dsi);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"Failed to attach to DSI host: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic void boe_bf060y8m_aj0_remove(struct mipi_dsi_device *dsi)\n{\n\tstruct boe_bf060y8m_aj0 *boe = mipi_dsi_get_drvdata(dsi);\n\tint ret;\n\n\tret = mipi_dsi_detach(dsi);\n\tif (ret < 0)\n\t\tdev_err(&dsi->dev, \"Failed to detach from DSI host: %d\\n\", ret);\n\n\tdrm_panel_remove(&boe->panel);\n}\n\nstatic const struct of_device_id boe_bf060y8m_aj0_of_match[] = {\n\t{ .compatible = \"boe,bf060y8m-aj0\" },\n\t{   }\n};\nMODULE_DEVICE_TABLE(of, boe_bf060y8m_aj0_of_match);\n\nstatic struct mipi_dsi_driver boe_bf060y8m_aj0_driver = {\n\t.probe = boe_bf060y8m_aj0_probe,\n\t.remove = boe_bf060y8m_aj0_remove,\n\t.driver = {\n\t\t.name = \"panel-sw43404-boe-fhd-amoled\",\n\t\t.of_match_table = boe_bf060y8m_aj0_of_match,\n\t},\n};\nmodule_mipi_dsi_driver(boe_bf060y8m_aj0_driver);\n\nMODULE_AUTHOR(\"AngeloGioacchino Del Regno <angelogioacchino.delregno@somainline.org>\");\nMODULE_DESCRIPTION(\"BOE BF060Y8M-AJ0 MIPI-DSI OLED panel\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}