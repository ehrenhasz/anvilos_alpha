{
  "module_name": "panel-ronbo-rb070d30.c",
  "hash_id": "bb365cc2f213241a0f309e195036a0c7fb3cf0c5ad510100cbd1c1b9cf5f4b78",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/panel/panel-ronbo-rb070d30.c",
  "human_readable_source": "\n \n\n#include <linux/delay.h>\n#include <linux/device.h>\n#include <linux/err.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include <linux/media-bus-format.h>\n#include <linux/module.h>\n#include <linux/of.h>\n\n#include <linux/gpio/consumer.h>\n#include <linux/regulator/consumer.h>\n\n#include <drm/drm_connector.h>\n#include <drm/drm_mipi_dsi.h>\n#include <drm/drm_modes.h>\n#include <drm/drm_panel.h>\n\nstruct rb070d30_panel {\n\tstruct drm_panel panel;\n\tstruct mipi_dsi_device *dsi;\n\tstruct regulator *supply;\n\n\tstruct {\n\t\tstruct gpio_desc *power;\n\t\tstruct gpio_desc *reset;\n\t\tstruct gpio_desc *updn;\n\t\tstruct gpio_desc *shlr;\n\t} gpios;\n};\n\nstatic inline struct rb070d30_panel *panel_to_rb070d30_panel(struct drm_panel *panel)\n{\n\treturn container_of(panel, struct rb070d30_panel, panel);\n}\n\nstatic int rb070d30_panel_prepare(struct drm_panel *panel)\n{\n\tstruct rb070d30_panel *ctx = panel_to_rb070d30_panel(panel);\n\tint ret;\n\n\tret = regulator_enable(ctx->supply);\n\tif (ret < 0) {\n\t\tdev_err(&ctx->dsi->dev, \"Failed to enable supply: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tmsleep(20);\n\tgpiod_set_value(ctx->gpios.power, 1);\n\tmsleep(20);\n\tgpiod_set_value(ctx->gpios.reset, 1);\n\tmsleep(20);\n\treturn 0;\n}\n\nstatic int rb070d30_panel_unprepare(struct drm_panel *panel)\n{\n\tstruct rb070d30_panel *ctx = panel_to_rb070d30_panel(panel);\n\n\tgpiod_set_value(ctx->gpios.reset, 0);\n\tgpiod_set_value(ctx->gpios.power, 0);\n\tregulator_disable(ctx->supply);\n\n\treturn 0;\n}\n\nstatic int rb070d30_panel_enable(struct drm_panel *panel)\n{\n\tstruct rb070d30_panel *ctx = panel_to_rb070d30_panel(panel);\n\n\treturn mipi_dsi_dcs_exit_sleep_mode(ctx->dsi);\n}\n\nstatic int rb070d30_panel_disable(struct drm_panel *panel)\n{\n\tstruct rb070d30_panel *ctx = panel_to_rb070d30_panel(panel);\n\n\treturn mipi_dsi_dcs_enter_sleep_mode(ctx->dsi);\n}\n\n \nstatic const struct drm_display_mode default_mode = {\n\t.clock\t\t= 51206,\n\t.hdisplay\t= 1024,\n\t.hsync_start\t= 1024 + 160,\n\t.hsync_end\t= 1024 + 160 + 80,\n\t.htotal\t\t= 1024 + 160 + 80 + 80,\n\t.vdisplay\t= 600,\n\t.vsync_start\t= 600 + 12,\n\t.vsync_end\t= 600 + 12 + 10,\n\t.vtotal\t\t= 600 + 12 + 10 + 13,\n\n\t.width_mm\t= 154,\n\t.height_mm\t= 85,\n};\n\nstatic int rb070d30_panel_get_modes(struct drm_panel *panel,\n\t\t\t\t    struct drm_connector *connector)\n{\n\tstruct rb070d30_panel *ctx = panel_to_rb070d30_panel(panel);\n\tstruct drm_display_mode *mode;\n\tstatic const u32 bus_format = MEDIA_BUS_FMT_RGB888_1X24;\n\n\tmode = drm_mode_duplicate(connector->dev, &default_mode);\n\tif (!mode) {\n\t\tdev_err(&ctx->dsi->dev, \"Failed to add mode \" DRM_MODE_FMT \"\\n\",\n\t\t\tDRM_MODE_ARG(&default_mode));\n\t\treturn -EINVAL;\n\t}\n\n\tdrm_mode_set_name(mode);\n\n\tmode->type = DRM_MODE_TYPE_DRIVER | DRM_MODE_TYPE_PREFERRED;\n\tdrm_mode_probed_add(connector, mode);\n\n\tconnector->display_info.bpc = 8;\n\tconnector->display_info.width_mm = mode->width_mm;\n\tconnector->display_info.height_mm = mode->height_mm;\n\tdrm_display_info_set_bus_formats(&connector->display_info,\n\t\t\t\t\t &bus_format, 1);\n\n\treturn 1;\n}\n\nstatic const struct drm_panel_funcs rb070d30_panel_funcs = {\n\t.get_modes\t= rb070d30_panel_get_modes,\n\t.prepare\t= rb070d30_panel_prepare,\n\t.enable\t\t= rb070d30_panel_enable,\n\t.disable\t= rb070d30_panel_disable,\n\t.unprepare\t= rb070d30_panel_unprepare,\n};\n\nstatic int rb070d30_panel_dsi_probe(struct mipi_dsi_device *dsi)\n{\n\tstruct rb070d30_panel *ctx;\n\tint ret;\n\n\tctx = devm_kzalloc(&dsi->dev, sizeof(*ctx), GFP_KERNEL);\n\tif (!ctx)\n\t\treturn -ENOMEM;\n\n\tctx->supply = devm_regulator_get(&dsi->dev, \"vcc-lcd\");\n\tif (IS_ERR(ctx->supply))\n\t\treturn PTR_ERR(ctx->supply);\n\n\tmipi_dsi_set_drvdata(dsi, ctx);\n\tctx->dsi = dsi;\n\n\tdrm_panel_init(&ctx->panel, &dsi->dev, &rb070d30_panel_funcs,\n\t\t       DRM_MODE_CONNECTOR_DSI);\n\n\tctx->gpios.reset = devm_gpiod_get(&dsi->dev, \"reset\", GPIOD_OUT_LOW);\n\tif (IS_ERR(ctx->gpios.reset)) {\n\t\tdev_err(&dsi->dev, \"Couldn't get our reset GPIO\\n\");\n\t\treturn PTR_ERR(ctx->gpios.reset);\n\t}\n\n\tctx->gpios.power = devm_gpiod_get(&dsi->dev, \"power\", GPIOD_OUT_LOW);\n\tif (IS_ERR(ctx->gpios.power)) {\n\t\tdev_err(&dsi->dev, \"Couldn't get our power GPIO\\n\");\n\t\treturn PTR_ERR(ctx->gpios.power);\n\t}\n\n\t \n\tctx->gpios.updn = devm_gpiod_get(&dsi->dev, \"updn\", GPIOD_OUT_LOW);\n\tif (IS_ERR(ctx->gpios.updn)) {\n\t\tdev_err(&dsi->dev, \"Couldn't get our updn GPIO\\n\");\n\t\treturn PTR_ERR(ctx->gpios.updn);\n\t}\n\n\t \n\tctx->gpios.shlr = devm_gpiod_get(&dsi->dev, \"shlr\", GPIOD_OUT_LOW);\n\tif (IS_ERR(ctx->gpios.shlr)) {\n\t\tdev_err(&dsi->dev, \"Couldn't get our shlr GPIO\\n\");\n\t\treturn PTR_ERR(ctx->gpios.shlr);\n\t}\n\n\tret = drm_panel_of_backlight(&ctx->panel);\n\tif (ret)\n\t\treturn ret;\n\n\tdrm_panel_add(&ctx->panel);\n\n\tdsi->mode_flags = MIPI_DSI_MODE_VIDEO | MIPI_DSI_MODE_VIDEO_BURST | MIPI_DSI_MODE_LPM;\n\tdsi->format = MIPI_DSI_FMT_RGB888;\n\tdsi->lanes = 4;\n\n\tret = mipi_dsi_attach(dsi);\n\tif (ret < 0) {\n\t\tdrm_panel_remove(&ctx->panel);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic void rb070d30_panel_dsi_remove(struct mipi_dsi_device *dsi)\n{\n\tstruct rb070d30_panel *ctx = mipi_dsi_get_drvdata(dsi);\n\n\tmipi_dsi_detach(dsi);\n\tdrm_panel_remove(&ctx->panel);\n}\n\nstatic const struct of_device_id rb070d30_panel_of_match[] = {\n\t{ .compatible = \"ronbo,rb070d30\" },\n\t{   },\n};\nMODULE_DEVICE_TABLE(of, rb070d30_panel_of_match);\n\nstatic struct mipi_dsi_driver rb070d30_panel_driver = {\n\t.probe = rb070d30_panel_dsi_probe,\n\t.remove = rb070d30_panel_dsi_remove,\n\t.driver = {\n\t\t.name = \"panel-ronbo-rb070d30\",\n\t\t.of_match_table\t= rb070d30_panel_of_match,\n\t},\n};\nmodule_mipi_dsi_driver(rb070d30_panel_driver);\n\nMODULE_AUTHOR(\"Boris Brezillon <boris.brezillon@bootlin.com>\");\nMODULE_AUTHOR(\"Konstantin Sudakov <k.sudakov@integrasources.com>\");\nMODULE_DESCRIPTION(\"Ronbo RB070D30 Panel Driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}