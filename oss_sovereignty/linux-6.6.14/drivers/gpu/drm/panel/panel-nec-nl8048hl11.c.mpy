{
  "module_name": "panel-nec-nl8048hl11.c",
  "hash_id": "524f5d29b0a9fab6e4879c48d587ddd6d350d8977f454823ac486db1b57c3631",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/panel/panel-nec-nl8048hl11.c",
  "human_readable_source": "\n \n\n#include <linux/delay.h>\n#include <linux/gpio/consumer.h>\n#include <linux/module.h>\n#include <linux/pm.h>\n#include <linux/spi/spi.h>\n\n#include <drm/drm_connector.h>\n#include <drm/drm_modes.h>\n#include <drm/drm_panel.h>\n\nstruct nl8048_panel {\n\tstruct drm_panel panel;\n\n\tstruct spi_device *spi;\n\tstruct gpio_desc *reset_gpio;\n};\n\n#define to_nl8048_device(p) container_of(p, struct nl8048_panel, panel)\n\nstatic int nl8048_write(struct nl8048_panel *lcd, unsigned char addr,\n\t\t\tunsigned char value)\n{\n\tu8 data[4] = { value, 0x01, addr, 0x00 };\n\tint ret;\n\n\tret = spi_write(lcd->spi, data, sizeof(data));\n\tif (ret)\n\t\tdev_err(&lcd->spi->dev, \"SPI write to %u failed: %d\\n\",\n\t\t\taddr, ret);\n\n\treturn ret;\n}\n\nstatic int nl8048_init(struct nl8048_panel *lcd)\n{\n\tstatic const struct {\n\t\tunsigned char addr;\n\t\tunsigned char data;\n\t} nl8048_init_seq[] = {\n\t\t{   3, 0x01 }, {   0, 0x00 }, {   1, 0x01 }, {   4, 0x00 },\n\t\t{   5, 0x14 }, {   6, 0x24 }, {  16, 0xd7 }, {  17, 0x00 },\n\t\t{  18, 0x00 }, {  19, 0x55 }, {  20, 0x01 }, {  21, 0x70 },\n\t\t{  22, 0x1e }, {  23, 0x25 }, {  24, 0x25 }, {  25, 0x02 },\n\t\t{  26, 0x02 }, {  27, 0xa0 }, {  32, 0x2f }, {  33, 0x0f },\n\t\t{  34, 0x0f }, {  35, 0x0f }, {  36, 0x0f }, {  37, 0x0f },\n\t\t{  38, 0x0f }, {  39, 0x00 }, {  40, 0x02 }, {  41, 0x02 },\n\t\t{  42, 0x02 }, {  43, 0x0f }, {  44, 0x0f }, {  45, 0x0f },\n\t\t{  46, 0x0f }, {  47, 0x0f }, {  48, 0x0f }, {  49, 0x0f },\n\t\t{  50, 0x00 }, {  51, 0x02 }, {  52, 0x02 }, {  53, 0x02 },\n\t\t{  80, 0x0c }, {  83, 0x42 }, {  84, 0x42 }, {  85, 0x41 },\n\t\t{  86, 0x14 }, {  89, 0x88 }, {  90, 0x01 }, {  91, 0x00 },\n\t\t{  92, 0x02 }, {  93, 0x0c }, {  94, 0x1c }, {  95, 0x27 },\n\t\t{  98, 0x49 }, {  99, 0x27 }, { 102, 0x76 }, { 103, 0x27 },\n\t\t{ 112, 0x01 }, { 113, 0x0e }, { 114, 0x02 }, { 115, 0x0c },\n\t\t{ 118, 0x0c }, { 121, 0x30 }, { 130, 0x00 }, { 131, 0x00 },\n\t\t{ 132, 0xfc }, { 134, 0x00 }, { 136, 0x00 }, { 138, 0x00 },\n\t\t{ 139, 0x00 }, { 140, 0x00 }, { 141, 0xfc }, { 143, 0x00 },\n\t\t{ 145, 0x00 }, { 147, 0x00 }, { 148, 0x00 }, { 149, 0x00 },\n\t\t{ 150, 0xfc }, { 152, 0x00 }, { 154, 0x00 }, { 156, 0x00 },\n\t\t{ 157, 0x00 },\n\t};\n\n\tunsigned int i;\n\tint ret;\n\n\tfor (i = 0; i < ARRAY_SIZE(nl8048_init_seq); ++i) {\n\t\tret = nl8048_write(lcd, nl8048_init_seq[i].addr,\n\t\t\t\t   nl8048_init_seq[i].data);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\tudelay(20);\n\n\treturn nl8048_write(lcd, 2, 0x00);\n}\n\nstatic int nl8048_disable(struct drm_panel *panel)\n{\n\tstruct nl8048_panel *lcd = to_nl8048_device(panel);\n\n\tgpiod_set_value_cansleep(lcd->reset_gpio, 0);\n\n\treturn 0;\n}\n\nstatic int nl8048_enable(struct drm_panel *panel)\n{\n\tstruct nl8048_panel *lcd = to_nl8048_device(panel);\n\n\tgpiod_set_value_cansleep(lcd->reset_gpio, 1);\n\n\treturn 0;\n}\n\nstatic const struct drm_display_mode nl8048_mode = {\n\t \n\t.clock\t= 23800,\n\t.hdisplay = 800,\n\t.hsync_start = 800 + 6,\n\t.hsync_end = 800 + 6 + 1,\n\t.htotal = 800 + 6 + 1 + 4,\n\t.vdisplay = 480,\n\t.vsync_start = 480 + 3,\n\t.vsync_end = 480 + 3 + 1,\n\t.vtotal = 480 + 3 + 1 + 4,\n\t.type = DRM_MODE_TYPE_DRIVER | DRM_MODE_TYPE_PREFERRED,\n\t.flags = DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_NVSYNC,\n\t.width_mm = 89,\n\t.height_mm = 53,\n};\n\nstatic int nl8048_get_modes(struct drm_panel *panel,\n\t\t\t    struct drm_connector *connector)\n{\n\tstruct drm_display_mode *mode;\n\n\tmode = drm_mode_duplicate(connector->dev, &nl8048_mode);\n\tif (!mode)\n\t\treturn -ENOMEM;\n\n\tdrm_mode_set_name(mode);\n\tdrm_mode_probed_add(connector, mode);\n\n\tconnector->display_info.width_mm = nl8048_mode.width_mm;\n\tconnector->display_info.height_mm = nl8048_mode.height_mm;\n\tconnector->display_info.bus_flags = DRM_BUS_FLAG_DE_HIGH\n\t\t\t\t\t  | DRM_BUS_FLAG_SYNC_SAMPLE_NEGEDGE\n\t\t\t\t\t  | DRM_BUS_FLAG_PIXDATA_SAMPLE_NEGEDGE;\n\n\treturn 1;\n}\n\nstatic const struct drm_panel_funcs nl8048_funcs = {\n\t.disable = nl8048_disable,\n\t.enable = nl8048_enable,\n\t.get_modes = nl8048_get_modes,\n};\n\nstatic int __maybe_unused nl8048_suspend(struct device *dev)\n{\n\tstruct nl8048_panel *lcd = dev_get_drvdata(dev);\n\n\tnl8048_write(lcd, 2, 0x01);\n\tmsleep(40);\n\n\treturn 0;\n}\n\nstatic int __maybe_unused nl8048_resume(struct device *dev)\n{\n\tstruct nl8048_panel *lcd = dev_get_drvdata(dev);\n\n\t \n\tspi_setup(lcd->spi);\n\tnl8048_write(lcd, 2, 0x00);\n\tnl8048_init(lcd);\n\n\treturn 0;\n}\n\nstatic SIMPLE_DEV_PM_OPS(nl8048_pm_ops, nl8048_suspend, nl8048_resume);\n\nstatic int nl8048_probe(struct spi_device *spi)\n{\n\tstruct nl8048_panel *lcd;\n\tint ret;\n\n\tlcd = devm_kzalloc(&spi->dev, sizeof(*lcd), GFP_KERNEL);\n\tif (!lcd)\n\t\treturn -ENOMEM;\n\n\tspi_set_drvdata(spi, lcd);\n\tlcd->spi = spi;\n\n\tlcd->reset_gpio = devm_gpiod_get(&spi->dev, \"reset\", GPIOD_OUT_LOW);\n\tif (IS_ERR(lcd->reset_gpio)) {\n\t\tdev_err(&spi->dev, \"failed to parse reset gpio\\n\");\n\t\treturn PTR_ERR(lcd->reset_gpio);\n\t}\n\n\tspi->mode = SPI_MODE_0;\n\tspi->bits_per_word = 32;\n\n\tret = spi_setup(spi);\n\tif (ret < 0) {\n\t\tdev_err(&spi->dev, \"failed to setup SPI: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = nl8048_init(lcd);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tdrm_panel_init(&lcd->panel, &lcd->spi->dev, &nl8048_funcs,\n\t\t       DRM_MODE_CONNECTOR_DPI);\n\n\tdrm_panel_add(&lcd->panel);\n\n\treturn 0;\n}\n\nstatic void nl8048_remove(struct spi_device *spi)\n{\n\tstruct nl8048_panel *lcd = spi_get_drvdata(spi);\n\n\tdrm_panel_remove(&lcd->panel);\n\tdrm_panel_disable(&lcd->panel);\n\tdrm_panel_unprepare(&lcd->panel);\n}\n\nstatic const struct of_device_id nl8048_of_match[] = {\n\t{ .compatible = \"nec,nl8048hl11\", },\n\t{   },\n};\n\nMODULE_DEVICE_TABLE(of, nl8048_of_match);\n\nstatic const struct spi_device_id nl8048_ids[] = {\n\t{ \"nl8048hl11\", 0 },\n\t{   }\n};\n\nMODULE_DEVICE_TABLE(spi, nl8048_ids);\n\nstatic struct spi_driver nl8048_driver = {\n\t.probe\t\t= nl8048_probe,\n\t.remove\t\t= nl8048_remove,\n\t.id_table\t= nl8048_ids,\n\t.driver\t\t= {\n\t\t.name\t= \"panel-nec-nl8048hl11\",\n\t\t.pm\t= &nl8048_pm_ops,\n\t\t.of_match_table = nl8048_of_match,\n\t},\n};\n\nmodule_spi_driver(nl8048_driver);\n\nMODULE_AUTHOR(\"Erik Gilling <konkers@android.com>\");\nMODULE_DESCRIPTION(\"NEC-NL8048HL11 Driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}