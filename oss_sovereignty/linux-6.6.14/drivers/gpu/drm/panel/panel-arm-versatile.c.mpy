{
  "module_name": "panel-arm-versatile.c",
  "hash_id": "c416df8c49e7b6baab5121624584cc585ab227d3194556f986625eff5028ed0d",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/panel/panel-arm-versatile.c",
  "human_readable_source": "\n \n\n#include <linux/bitops.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/mfd/syscon.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include <linux/platform_device.h>\n#include <linux/regmap.h>\n\n#include <video/of_videomode.h>\n#include <video/videomode.h>\n\n#include <drm/drm_modes.h>\n#include <drm/drm_panel.h>\n\n \n#define SYS_CLCD\t\t\t0x50\n\n \n#define SYS_CLCD_CLCDID_MASK\t\t(BIT(8)|BIT(9)|BIT(10)|BIT(11)|BIT(12))\n#define SYS_CLCD_ID_SANYO_3_8\t\t(0x00 << 8)\n#define SYS_CLCD_ID_SHARP_8_4\t\t(0x01 << 8)\n#define SYS_CLCD_ID_EPSON_2_2\t\t(0x02 << 8)\n#define SYS_CLCD_ID_SANYO_2_5\t\t(0x07 << 8)\n#define SYS_CLCD_ID_VGA\t\t\t(0x1f << 8)\n\n \n#define IB2_CTRL\t\t\t0x00\n#define IB2_CTRL_LCD_SD\t\t\tBIT(1)  \n#define IB2_CTRL_LCD_BL_ON\t\tBIT(0)\n#define IB2_CTRL_LCD_MASK\t\t(BIT(0)|BIT(1))\n\n \nstruct versatile_panel_type {\n\t \n\tconst char *name;\n\t \n\tu32 magic;\n\t \n\tstruct drm_display_mode mode;\n\t \n\tu32 bus_flags;\n\t \n\tu32 width_mm;\n\t \n\tu32 height_mm;\n\t \n\tbool ib2;\n};\n\n \nstruct versatile_panel {\n\t \n\tstruct device *dev;\n\t \n\tstruct drm_panel panel;\n\t \n\tconst struct versatile_panel_type *panel_type;\n\t \n\tstruct regmap *map;\n\t \n\tstruct regmap *ib2_map;\n};\n\nstatic const struct versatile_panel_type versatile_panels[] = {\n\t \n\t{\n\t\t.name = \"Sanyo TM38QV67A02A\",\n\t\t.magic = SYS_CLCD_ID_SANYO_3_8,\n\t\t.width_mm = 79,\n\t\t.height_mm = 54,\n\t\t.mode = {\n\t\t\t.clock = 10000,\n\t\t\t.hdisplay = 320,\n\t\t\t.hsync_start = 320 + 6,\n\t\t\t.hsync_end = 320 + 6 + 6,\n\t\t\t.htotal = 320 + 6 + 6 + 6,\n\t\t\t.vdisplay = 240,\n\t\t\t.vsync_start = 240 + 5,\n\t\t\t.vsync_end = 240 + 5 + 6,\n\t\t\t.vtotal = 240 + 5 + 6 + 5,\n\t\t\t.flags = DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC,\n\t\t},\n\t},\n\t \n\t{\n\t\t.name = \"Sharp LQ084V1DG21\",\n\t\t.magic = SYS_CLCD_ID_SHARP_8_4,\n\t\t.width_mm = 171,\n\t\t.height_mm = 130,\n\t\t.mode = {\n\t\t\t.clock = 25000,\n\t\t\t.hdisplay = 640,\n\t\t\t.hsync_start = 640 + 24,\n\t\t\t.hsync_end = 640 + 24 + 96,\n\t\t\t.htotal = 640 + 24 + 96 + 24,\n\t\t\t.vdisplay = 480,\n\t\t\t.vsync_start = 480 + 11,\n\t\t\t.vsync_end = 480 + 11 + 2,\n\t\t\t.vtotal = 480 + 11 + 2 + 32,\n\t\t\t.flags = DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC,\n\t\t},\n\t},\n\t \n\t{\n\t\t.name = \"Epson L2F50113T00\",\n\t\t.magic = SYS_CLCD_ID_EPSON_2_2,\n\t\t.width_mm = 34,\n\t\t.height_mm = 45,\n\t\t.mode = {\n\t\t\t.clock = 62500,\n\t\t\t.hdisplay = 176,\n\t\t\t.hsync_start = 176 + 2,\n\t\t\t.hsync_end = 176 + 2 + 3,\n\t\t\t.htotal = 176 + 2 + 3 + 3,\n\t\t\t.vdisplay = 220,\n\t\t\t.vsync_start = 220 + 0,\n\t\t\t.vsync_end = 220 + 0 + 2,\n\t\t\t.vtotal = 220 + 0 + 2 + 1,\n\t\t\t.flags = DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC,\n\t\t},\n\t\t.bus_flags = DRM_BUS_FLAG_PIXDATA_DRIVE_NEGEDGE,\n\t},\n\t \n\t{\n\t\t.name = \"Sanyo ALR252RGT\",\n\t\t.magic = SYS_CLCD_ID_SANYO_2_5,\n\t\t.width_mm = 37,\n\t\t.height_mm = 50,\n\t\t.mode = {\n\t\t\t.clock = 5400,\n\t\t\t.hdisplay = 240,\n\t\t\t.hsync_start = 240 + 10,\n\t\t\t.hsync_end = 240 + 10 + 10,\n\t\t\t.htotal = 240 + 10 + 10 + 20,\n\t\t\t.vdisplay = 320,\n\t\t\t.vsync_start = 320 + 2,\n\t\t\t.vsync_end = 320 + 2 + 2,\n\t\t\t.vtotal = 320 + 2 + 2 + 2,\n\t\t\t.flags = DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_NVSYNC,\n\t\t},\n\t\t.bus_flags = DRM_BUS_FLAG_PIXDATA_DRIVE_NEGEDGE,\n\t\t.ib2 = true,\n\t},\n};\n\nstatic inline struct versatile_panel *\nto_versatile_panel(struct drm_panel *panel)\n{\n\treturn container_of(panel, struct versatile_panel, panel);\n}\n\nstatic int versatile_panel_disable(struct drm_panel *panel)\n{\n\tstruct versatile_panel *vpanel = to_versatile_panel(panel);\n\n\t \n\tif (vpanel->ib2_map) {\n\t\tdev_dbg(vpanel->dev, \"disable IB2 display\\n\");\n\t\tregmap_update_bits(vpanel->ib2_map,\n\t\t\t\t   IB2_CTRL,\n\t\t\t\t   IB2_CTRL_LCD_MASK,\n\t\t\t\t   IB2_CTRL_LCD_SD);\n\t}\n\n\treturn 0;\n}\n\nstatic int versatile_panel_enable(struct drm_panel *panel)\n{\n\tstruct versatile_panel *vpanel = to_versatile_panel(panel);\n\n\t \n\tif (vpanel->ib2_map) {\n\t\tdev_dbg(vpanel->dev, \"enable IB2 display\\n\");\n\t\tregmap_update_bits(vpanel->ib2_map,\n\t\t\t\t   IB2_CTRL,\n\t\t\t\t   IB2_CTRL_LCD_MASK,\n\t\t\t\t   IB2_CTRL_LCD_BL_ON);\n\t}\n\n\treturn 0;\n}\n\nstatic int versatile_panel_get_modes(struct drm_panel *panel,\n\t\t\t\t     struct drm_connector *connector)\n{\n\tstruct versatile_panel *vpanel = to_versatile_panel(panel);\n\tstruct drm_display_mode *mode;\n\n\tconnector->display_info.width_mm = vpanel->panel_type->width_mm;\n\tconnector->display_info.height_mm = vpanel->panel_type->height_mm;\n\tconnector->display_info.bus_flags = vpanel->panel_type->bus_flags;\n\n\tmode = drm_mode_duplicate(connector->dev, &vpanel->panel_type->mode);\n\tif (!mode)\n\t\treturn -ENOMEM;\n\tdrm_mode_set_name(mode);\n\tmode->type = DRM_MODE_TYPE_DRIVER | DRM_MODE_TYPE_PREFERRED;\n\n\tmode->width_mm = vpanel->panel_type->width_mm;\n\tmode->height_mm = vpanel->panel_type->height_mm;\n\tdrm_mode_probed_add(connector, mode);\n\n\treturn 1;\n}\n\nstatic const struct drm_panel_funcs versatile_panel_drm_funcs = {\n\t.disable = versatile_panel_disable,\n\t.enable = versatile_panel_enable,\n\t.get_modes = versatile_panel_get_modes,\n};\n\nstatic int versatile_panel_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct versatile_panel *vpanel;\n\tstruct device *parent;\n\tstruct regmap *map;\n\tint ret;\n\tu32 val;\n\tint i;\n\n\tparent = dev->parent;\n\tif (!parent) {\n\t\tdev_err(dev, \"no parent for versatile panel\\n\");\n\t\treturn -ENODEV;\n\t}\n\tmap = syscon_node_to_regmap(parent->of_node);\n\tif (IS_ERR(map)) {\n\t\tdev_err(dev, \"no regmap for versatile panel parent\\n\");\n\t\treturn PTR_ERR(map);\n\t}\n\n\tvpanel = devm_kzalloc(dev, sizeof(*vpanel), GFP_KERNEL);\n\tif (!vpanel)\n\t\treturn -ENOMEM;\n\n\tret = regmap_read(map, SYS_CLCD, &val);\n\tif (ret) {\n\t\tdev_err(dev, \"cannot access syscon regs\\n\");\n\t\treturn ret;\n\t}\n\n\tval &= SYS_CLCD_CLCDID_MASK;\n\n\tfor (i = 0; i < ARRAY_SIZE(versatile_panels); i++) {\n\t\tconst struct versatile_panel_type *pt;\n\n\t\tpt = &versatile_panels[i];\n\t\tif (pt->magic == val) {\n\t\t\tvpanel->panel_type = pt;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t \n\tif (i == ARRAY_SIZE(versatile_panels)) {\n\t\tdev_info(dev, \"no panel detected\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tdev_info(dev, \"detected: %s\\n\", vpanel->panel_type->name);\n\tvpanel->dev = dev;\n\tvpanel->map = map;\n\n\t \n\tif (vpanel->panel_type->ib2) {\n\t\tvpanel->ib2_map = syscon_regmap_lookup_by_compatible(\n\t\t\t\"arm,versatile-ib2-syscon\");\n\t\tif (IS_ERR(vpanel->ib2_map))\n\t\t\tvpanel->ib2_map = NULL;\n\t\telse\n\t\t\tdev_info(dev, \"panel mounted on IB2 daughterboard\\n\");\n\t}\n\n\tdrm_panel_init(&vpanel->panel, dev, &versatile_panel_drm_funcs,\n\t\t       DRM_MODE_CONNECTOR_DPI);\n\n\tdrm_panel_add(&vpanel->panel);\n\n\treturn 0;\n}\n\nstatic const struct of_device_id versatile_panel_match[] = {\n\t{ .compatible = \"arm,versatile-tft-panel\", },\n\t{},\n};\nMODULE_DEVICE_TABLE(of, versatile_panel_match);\n\nstatic struct platform_driver versatile_panel_driver = {\n\t.probe\t\t= versatile_panel_probe,\n\t.driver\t\t= {\n\t\t.name\t= \"versatile-tft-panel\",\n\t\t.of_match_table = versatile_panel_match,\n\t},\n};\nmodule_platform_driver(versatile_panel_driver);\n\nMODULE_AUTHOR(\"Linus Walleij <linus.walleij@linaro.org>\");\nMODULE_DESCRIPTION(\"ARM Versatile panel driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}