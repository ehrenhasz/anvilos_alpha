{
  "module_name": "panel-samsung-ld9040.c",
  "hash_id": "e1cd6d784ddf22bbd3cb20f32076ac6788d2ac028d442a0ab130d368e8ab9053",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/panel/panel-samsung-ld9040.c",
  "human_readable_source": "\n \n\n#include <linux/backlight.h>\n#include <linux/delay.h>\n#include <linux/gpio/consumer.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/regulator/consumer.h>\n#include <linux/spi/spi.h>\n\n#include <video/mipi_display.h>\n#include <video/of_videomode.h>\n#include <video/videomode.h>\n\n#include <drm/drm_modes.h>\n#include <drm/drm_panel.h>\n\n \n#define MCS_MANPWR\t\t0xb0\n#define MCS_ELVSS_ON\t\t0xb1\n#define MCS_USER_SETTING\t0xf0\n#define MCS_DISPCTL\t\t0xf2\n#define MCS_POWER_CTRL\t\t0xf4\n#define MCS_GTCON\t\t0xf7\n#define MCS_PANEL_CONDITION\t0xf8\n#define MCS_GAMMA_SET1\t\t0xf9\n#define MCS_GAMMA_CTRL\t\t0xfb\n\n \nstatic u8 const ld9040_gammas[25][22] = {\n\t{ 0xf9, 0x00, 0x13, 0xb2, 0xba, 0xd2, 0x00, 0x30, 0x00, 0xaf, 0xc0,\n\t  0xb8, 0xcd, 0x00, 0x3d, 0x00, 0xa8, 0xb8, 0xb7, 0xcd, 0x00, 0x44 },\n\t{ 0xf9, 0x00, 0x13, 0xb9, 0xb9, 0xd0, 0x00, 0x3c, 0x00, 0xaf, 0xbf,\n\t  0xb6, 0xcb, 0x00, 0x4b, 0x00, 0xa8, 0xb9, 0xb5, 0xcc, 0x00, 0x52 },\n\t{ 0xf9, 0x00, 0x13, 0xba, 0xb9, 0xcd, 0x00, 0x41, 0x00, 0xb0, 0xbe,\n\t  0xb5, 0xc9, 0x00, 0x51, 0x00, 0xa9, 0xb9, 0xb5, 0xca, 0x00, 0x57 },\n\t{ 0xf9, 0x00, 0x13, 0xb9, 0xb8, 0xcd, 0x00, 0x46, 0x00, 0xb1, 0xbc,\n\t  0xb5, 0xc8, 0x00, 0x56, 0x00, 0xaa, 0xb8, 0xb4, 0xc9, 0x00, 0x5d },\n\t{ 0xf9, 0x00, 0x13, 0xba, 0xb8, 0xcb, 0x00, 0x4b, 0x00, 0xb3, 0xbc,\n\t  0xb4, 0xc7, 0x00, 0x5c, 0x00, 0xac, 0xb8, 0xb4, 0xc8, 0x00, 0x62 },\n\t{ 0xf9, 0x00, 0x13, 0xbb, 0xb7, 0xca, 0x00, 0x4f, 0x00, 0xb4, 0xbb,\n\t  0xb3, 0xc7, 0x00, 0x60, 0x00, 0xad, 0xb8, 0xb4, 0xc7, 0x00, 0x67 },\n\t{ 0xf9, 0x00, 0x47, 0xba, 0xb6, 0xca, 0x00, 0x53, 0x00, 0xb5, 0xbb,\n\t  0xb3, 0xc6, 0x00, 0x65, 0x00, 0xae, 0xb8, 0xb3, 0xc7, 0x00, 0x6c },\n\t{ 0xf9, 0x00, 0x71, 0xbb, 0xb5, 0xc8, 0x00, 0x57, 0x00, 0xb5, 0xbb,\n\t  0xb0, 0xc5, 0x00, 0x6a, 0x00, 0xae, 0xb9, 0xb1, 0xc6, 0x00, 0x70 },\n\t{ 0xf9, 0x00, 0x7b, 0xbb, 0xb4, 0xc8, 0x00, 0x5b, 0x00, 0xb5, 0xba,\n\t  0xb1, 0xc4, 0x00, 0x6e, 0x00, 0xae, 0xb9, 0xb0, 0xc5, 0x00, 0x75 },\n\t{ 0xf9, 0x00, 0x82, 0xba, 0xb4, 0xc7, 0x00, 0x5f, 0x00, 0xb5, 0xba,\n\t  0xb0, 0xc3, 0x00, 0x72, 0x00, 0xae, 0xb8, 0xb0, 0xc3, 0x00, 0x7a },\n\t{ 0xf9, 0x00, 0x89, 0xba, 0xb3, 0xc8, 0x00, 0x62, 0x00, 0xb6, 0xba,\n\t  0xaf, 0xc3, 0x00, 0x76, 0x00, 0xaf, 0xb7, 0xae, 0xc4, 0x00, 0x7e },\n\t{ 0xf9, 0x00, 0x8b, 0xb9, 0xb3, 0xc7, 0x00, 0x65, 0x00, 0xb7, 0xb8,\n\t  0xaf, 0xc3, 0x00, 0x7a, 0x00, 0x80, 0xb6, 0xae, 0xc4, 0x00, 0x81 },\n\t{ 0xf9, 0x00, 0x93, 0xba, 0xb3, 0xc5, 0x00, 0x69, 0x00, 0xb8, 0xb9,\n\t  0xae, 0xc1, 0x00, 0x7f, 0x00, 0xb0, 0xb6, 0xae, 0xc3, 0x00, 0x85 },\n\t{ 0xf9, 0x00, 0x97, 0xba, 0xb2, 0xc5, 0x00, 0x6c, 0x00, 0xb8, 0xb8,\n\t  0xae, 0xc1, 0x00, 0x82, 0x00, 0xb0, 0xb6, 0xae, 0xc2, 0x00, 0x89 },\n\t{ 0xf9, 0x00, 0x9a, 0xba, 0xb1, 0xc4, 0x00, 0x6f, 0x00, 0xb8, 0xb8,\n\t  0xad, 0xc0, 0x00, 0x86, 0x00, 0xb0, 0xb7, 0xad, 0xc0, 0x00, 0x8d },\n\t{ 0xf9, 0x00, 0x9c, 0xb9, 0xb0, 0xc4, 0x00, 0x72, 0x00, 0xb8, 0xb8,\n\t  0xac, 0xbf, 0x00, 0x8a, 0x00, 0xb0, 0xb6, 0xac, 0xc0, 0x00, 0x91 },\n\t{ 0xf9, 0x00, 0x9e, 0xba, 0xb0, 0xc2, 0x00, 0x75, 0x00, 0xb9, 0xb8,\n\t  0xab, 0xbe, 0x00, 0x8e, 0x00, 0xb0, 0xb6, 0xac, 0xbf, 0x00, 0x94 },\n\t{ 0xf9, 0x00, 0xa0, 0xb9, 0xaf, 0xc3, 0x00, 0x77, 0x00, 0xb9, 0xb7,\n\t  0xab, 0xbe, 0x00, 0x90, 0x00, 0xb0, 0xb6, 0xab, 0xbf, 0x00, 0x97 },\n\t{ 0xf9, 0x00, 0xa2, 0xb9, 0xaf, 0xc2, 0x00, 0x7a, 0x00, 0xb9, 0xb7,\n\t  0xaa, 0xbd, 0x00, 0x94, 0x00, 0xb0, 0xb5, 0xab, 0xbf, 0x00, 0x9a },\n\t{ 0xf9, 0x00, 0xa4, 0xb9, 0xaf, 0xc1, 0x00, 0x7d, 0x00, 0xb9, 0xb6,\n\t  0xaa, 0xbb, 0x00, 0x97, 0x00, 0xb1, 0xb5, 0xaa, 0xbf, 0x00, 0x9d },\n\t{ 0xf9, 0x00, 0xa4, 0xb8, 0xb0, 0xbf, 0x00, 0x80, 0x00, 0xb8, 0xb6,\n\t  0xaa, 0xbc, 0x00, 0x9a, 0x00, 0xb0, 0xb5, 0xab, 0xbd, 0x00, 0xa0 },\n\t{ 0xf9, 0x00, 0xa8, 0xb8, 0xae, 0xbe, 0x00, 0x84, 0x00, 0xb9, 0xb7,\n\t  0xa8, 0xbc, 0x00, 0x9d, 0x00, 0xb2, 0xb5, 0xaa, 0xbc, 0x00, 0xa4 },\n\t{ 0xf9, 0x00, 0xa9, 0xb6, 0xad, 0xbf, 0x00, 0x86, 0x00, 0xb8, 0xb5,\n\t  0xa8, 0xbc, 0x00, 0xa0, 0x00, 0xb3, 0xb3, 0xa9, 0xbc, 0x00, 0xa7 },\n\t{ 0xf9, 0x00, 0xa9, 0xb7, 0xae, 0xbd, 0x00, 0x89, 0x00, 0xb7, 0xb6,\n\t  0xa8, 0xba, 0x00, 0xa4, 0x00, 0xb1, 0xb4, 0xaa, 0xbb, 0x00, 0xaa },\n\t{ 0xf9, 0x00, 0xa7, 0xb4, 0xae, 0xbf, 0x00, 0x91, 0x00, 0xb2, 0xb4,\n\t  0xaa, 0xbb, 0x00, 0xac, 0x00, 0xb3, 0xb1, 0xaa, 0xbc, 0x00, 0xb3 },\n};\n\nstruct ld9040 {\n\tstruct device *dev;\n\tstruct drm_panel panel;\n\n\tstruct regulator_bulk_data supplies[2];\n\tstruct gpio_desc *reset_gpio;\n\tu32 power_on_delay;\n\tu32 reset_delay;\n\tstruct videomode vm;\n\tu32 width_mm;\n\tu32 height_mm;\n\n\tint brightness;\n\n\t \n\tint error;\n};\n\nstatic inline struct ld9040 *panel_to_ld9040(struct drm_panel *panel)\n{\n\treturn container_of(panel, struct ld9040, panel);\n}\n\nstatic int ld9040_clear_error(struct ld9040 *ctx)\n{\n\tint ret = ctx->error;\n\n\tctx->error = 0;\n\treturn ret;\n}\n\nstatic int ld9040_spi_write_word(struct ld9040 *ctx, u16 data)\n{\n\tstruct spi_device *spi = to_spi_device(ctx->dev);\n\tstruct spi_transfer xfer = {\n\t\t.len\t\t= 2,\n\t\t.tx_buf\t\t= &data,\n\t};\n\tstruct spi_message msg;\n\n\tspi_message_init(&msg);\n\tspi_message_add_tail(&xfer, &msg);\n\n\treturn spi_sync(spi, &msg);\n}\n\nstatic void ld9040_dcs_write(struct ld9040 *ctx, const u8 *data, size_t len)\n{\n\tint ret = 0;\n\n\tif (ctx->error < 0 || len == 0)\n\t\treturn;\n\n\tdev_dbg(ctx->dev, \"writing dcs seq: %*ph\\n\", (int)len, data);\n\tret = ld9040_spi_write_word(ctx, *data);\n\n\twhile (!ret && --len) {\n\t\t++data;\n\t\tret = ld9040_spi_write_word(ctx, *data | 0x100);\n\t}\n\n\tif (ret) {\n\t\tdev_err(ctx->dev, \"error %d writing dcs seq: %*ph\\n\", ret,\n\t\t\t(int)len, data);\n\t\tctx->error = ret;\n\t}\n\n\tusleep_range(300, 310);\n}\n\n#define ld9040_dcs_write_seq_static(ctx, seq...) \\\n({\\\n\tstatic const u8 d[] = { seq };\\\n\tld9040_dcs_write(ctx, d, ARRAY_SIZE(d));\\\n})\n\nstatic void ld9040_brightness_set(struct ld9040 *ctx)\n{\n\tld9040_dcs_write(ctx, ld9040_gammas[ctx->brightness],\n\t\t\t ARRAY_SIZE(ld9040_gammas[ctx->brightness]));\n\n\tld9040_dcs_write_seq_static(ctx, MCS_GAMMA_CTRL, 0x02, 0x5a);\n}\n\nstatic void ld9040_init(struct ld9040 *ctx)\n{\n\tld9040_dcs_write_seq_static(ctx, MCS_USER_SETTING, 0x5a, 0x5a);\n\tld9040_dcs_write_seq_static(ctx, MCS_PANEL_CONDITION,\n\t\t0x05, 0x5e, 0x96, 0x6b, 0x7d, 0x0d, 0x3f, 0x00,\n\t\t0x00, 0x32, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n\t\t0x07, 0x05, 0x1f, 0x1f, 0x1f, 0x00, 0x00);\n\tld9040_dcs_write_seq_static(ctx, MCS_DISPCTL,\n\t\t0x02, 0x06, 0x0a, 0x10, 0x10);\n\tld9040_dcs_write_seq_static(ctx, MCS_MANPWR, 0x04);\n\tld9040_dcs_write_seq_static(ctx, MCS_POWER_CTRL,\n\t\t0x0a, 0x87, 0x25, 0x6a, 0x44, 0x02, 0x88);\n\tld9040_dcs_write_seq_static(ctx, MCS_ELVSS_ON, 0x0f, 0x00, 0x16);\n\tld9040_dcs_write_seq_static(ctx, MCS_GTCON, 0x09, 0x00, 0x00);\n\tld9040_brightness_set(ctx);\n\tld9040_dcs_write_seq_static(ctx, MIPI_DCS_EXIT_SLEEP_MODE);\n\tld9040_dcs_write_seq_static(ctx, MIPI_DCS_SET_DISPLAY_ON);\n}\n\nstatic int ld9040_power_on(struct ld9040 *ctx)\n{\n\tint ret;\n\n\tret = regulator_bulk_enable(ARRAY_SIZE(ctx->supplies), ctx->supplies);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tmsleep(ctx->power_on_delay);\n\tgpiod_set_value(ctx->reset_gpio, 0);\n\tmsleep(ctx->reset_delay);\n\tgpiod_set_value(ctx->reset_gpio, 1);\n\tmsleep(ctx->reset_delay);\n\n\treturn 0;\n}\n\nstatic int ld9040_power_off(struct ld9040 *ctx)\n{\n\treturn regulator_bulk_disable(ARRAY_SIZE(ctx->supplies), ctx->supplies);\n}\n\nstatic int ld9040_disable(struct drm_panel *panel)\n{\n\treturn 0;\n}\n\nstatic int ld9040_unprepare(struct drm_panel *panel)\n{\n\tstruct ld9040 *ctx = panel_to_ld9040(panel);\n\n\tmsleep(120);\n\tld9040_dcs_write_seq_static(ctx, MIPI_DCS_SET_DISPLAY_OFF);\n\tld9040_dcs_write_seq_static(ctx, MIPI_DCS_ENTER_SLEEP_MODE);\n\tmsleep(40);\n\n\tld9040_clear_error(ctx);\n\n\treturn ld9040_power_off(ctx);\n}\n\nstatic int ld9040_prepare(struct drm_panel *panel)\n{\n\tstruct ld9040 *ctx = panel_to_ld9040(panel);\n\tint ret;\n\n\tret = ld9040_power_on(ctx);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tld9040_init(ctx);\n\n\tret = ld9040_clear_error(ctx);\n\n\tif (ret < 0)\n\t\tld9040_unprepare(panel);\n\n\treturn ret;\n}\n\nstatic int ld9040_enable(struct drm_panel *panel)\n{\n\treturn 0;\n}\n\nstatic int ld9040_get_modes(struct drm_panel *panel,\n\t\t\t    struct drm_connector *connector)\n{\n\tstruct ld9040 *ctx = panel_to_ld9040(panel);\n\tstruct drm_display_mode *mode;\n\n\tmode = drm_mode_create(connector->dev);\n\tif (!mode) {\n\t\tdev_err(panel->dev, \"failed to create a new display mode\\n\");\n\t\treturn 0;\n\t}\n\n\tdrm_display_mode_from_videomode(&ctx->vm, mode);\n\tmode->width_mm = ctx->width_mm;\n\tmode->height_mm = ctx->height_mm;\n\tconnector->display_info.width_mm = mode->width_mm;\n\tconnector->display_info.height_mm = mode->height_mm;\n\n\tmode->type = DRM_MODE_TYPE_DRIVER | DRM_MODE_TYPE_PREFERRED;\n\tdrm_mode_probed_add(connector, mode);\n\n\treturn 1;\n}\n\nstatic const struct drm_panel_funcs ld9040_drm_funcs = {\n\t.disable = ld9040_disable,\n\t.unprepare = ld9040_unprepare,\n\t.prepare = ld9040_prepare,\n\t.enable = ld9040_enable,\n\t.get_modes = ld9040_get_modes,\n};\n\nstatic int ld9040_parse_dt(struct ld9040 *ctx)\n{\n\tstruct device *dev = ctx->dev;\n\tstruct device_node *np = dev->of_node;\n\tint ret;\n\n\tret = of_get_videomode(np, &ctx->vm, 0);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tof_property_read_u32(np, \"power-on-delay\", &ctx->power_on_delay);\n\tof_property_read_u32(np, \"reset-delay\", &ctx->reset_delay);\n\tof_property_read_u32(np, \"panel-width-mm\", &ctx->width_mm);\n\tof_property_read_u32(np, \"panel-height-mm\", &ctx->height_mm);\n\n\treturn 0;\n}\n\nstatic int ld9040_bl_update_status(struct backlight_device *dev)\n{\n\tstruct ld9040 *ctx = bl_get_data(dev);\n\n\tctx->brightness = backlight_get_brightness(dev);\n\tld9040_brightness_set(ctx);\n\n\treturn 0;\n}\n\nstatic const struct backlight_ops ld9040_bl_ops = {\n\t.update_status  = ld9040_bl_update_status,\n};\n\nstatic const struct backlight_properties ld9040_bl_props = {\n\t.type = BACKLIGHT_RAW,\n\t.scale = BACKLIGHT_SCALE_NON_LINEAR,\n\t.max_brightness = ARRAY_SIZE(ld9040_gammas) - 1,\n\t.brightness = ARRAY_SIZE(ld9040_gammas) - 1,\n};\n\nstatic int ld9040_probe(struct spi_device *spi)\n{\n\tstruct backlight_device *bldev;\n\tstruct device *dev = &spi->dev;\n\tstruct ld9040 *ctx;\n\tint ret;\n\n\tctx = devm_kzalloc(dev, sizeof(struct ld9040), GFP_KERNEL);\n\tif (!ctx)\n\t\treturn -ENOMEM;\n\n\tspi_set_drvdata(spi, ctx);\n\n\tctx->dev = dev;\n\tctx->brightness = ld9040_bl_props.brightness;\n\n\tret = ld9040_parse_dt(ctx);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tctx->supplies[0].supply = \"vdd3\";\n\tctx->supplies[1].supply = \"vci\";\n\tret = devm_regulator_bulk_get(dev, ARRAY_SIZE(ctx->supplies),\n\t\t\t\t      ctx->supplies);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tctx->reset_gpio = devm_gpiod_get(dev, \"reset\", GPIOD_OUT_HIGH);\n\tif (IS_ERR(ctx->reset_gpio)) {\n\t\tdev_err(dev, \"cannot get reset-gpios %ld\\n\",\n\t\t\tPTR_ERR(ctx->reset_gpio));\n\t\treturn PTR_ERR(ctx->reset_gpio);\n\t}\n\n\tspi->bits_per_word = 9;\n\tret = spi_setup(spi);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"spi setup failed.\\n\");\n\t\treturn ret;\n\t}\n\n\tdrm_panel_init(&ctx->panel, dev, &ld9040_drm_funcs,\n\t\t       DRM_MODE_CONNECTOR_DPI);\n\n\tbldev = devm_backlight_device_register(dev, dev_name(dev), dev,\n\t\t\t\t\t       ctx, &ld9040_bl_ops,\n\t\t\t\t\t       &ld9040_bl_props);\n\tif (IS_ERR(bldev))\n\t\treturn PTR_ERR(bldev);\n\n\tdrm_panel_add(&ctx->panel);\n\n\treturn 0;\n}\n\nstatic void ld9040_remove(struct spi_device *spi)\n{\n\tstruct ld9040 *ctx = spi_get_drvdata(spi);\n\n\tld9040_power_off(ctx);\n\tdrm_panel_remove(&ctx->panel);\n}\n\nstatic const struct of_device_id ld9040_of_match[] = {\n\t{ .compatible = \"samsung,ld9040\" },\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, ld9040_of_match);\n\nstatic const struct spi_device_id ld9040_ids[] = {\n\t{ \"ld9040\", },\n\t{   }\n};\nMODULE_DEVICE_TABLE(spi, ld9040_ids);\n\nstatic struct spi_driver ld9040_driver = {\n\t.probe = ld9040_probe,\n\t.remove = ld9040_remove,\n\t.id_table = ld9040_ids,\n\t.driver = {\n\t\t.name = \"panel-samsung-ld9040\",\n\t\t.of_match_table = ld9040_of_match,\n\t},\n};\nmodule_spi_driver(ld9040_driver);\n\nMODULE_AUTHOR(\"Andrzej Hajda <a.hajda@samsung.com>\");\nMODULE_DESCRIPTION(\"ld9040 LCD Driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}