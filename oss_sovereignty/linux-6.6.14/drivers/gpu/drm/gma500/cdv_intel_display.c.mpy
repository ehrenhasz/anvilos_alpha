{
  "module_name": "cdv_intel_display.c",
  "hash_id": "f820e76e08e4630d147552e985eb8c99f94758cdb5c964bf963df0ce921892bd",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/gma500/cdv_intel_display.c",
  "human_readable_source": "\n \n\n#include <linux/delay.h>\n#include <linux/i2c.h>\n\n#include <drm/drm_crtc.h>\n#include <drm/drm_modeset_helper_vtables.h>\n\n#include \"cdv_device.h\"\n#include \"framebuffer.h\"\n#include \"gma_display.h\"\n#include \"power.h\"\n#include \"psb_drv.h\"\n#include \"psb_intel_drv.h\"\n#include \"psb_intel_reg.h\"\n\nstatic bool cdv_intel_find_dp_pll(const struct gma_limit_t *limit,\n\t\t\t\t  struct drm_crtc *crtc, int target,\n\t\t\t\t  int refclk, struct gma_clock_t *best_clock);\n\n\n#define CDV_LIMIT_SINGLE_LVDS_96\t0\n#define CDV_LIMIT_SINGLE_LVDS_100\t1\n#define CDV_LIMIT_DAC_HDMI_27\t\t2\n#define CDV_LIMIT_DAC_HDMI_96\t\t3\n#define CDV_LIMIT_DP_27\t\t\t4\n#define CDV_LIMIT_DP_100\t\t5\n\nstatic const struct gma_limit_t cdv_intel_limits[] = {\n\t{\t\t\t \n\t .dot = {.min = 20000, .max = 115500},\n\t .vco = {.min = 1800000, .max = 3600000},\n\t .n = {.min = 2, .max = 6},\n\t .m = {.min = 60, .max = 160},\n\t .m1 = {.min = 0, .max = 0},\n\t .m2 = {.min = 58, .max = 158},\n\t .p = {.min = 28, .max = 140},\n\t .p1 = {.min = 2, .max = 10},\n\t .p2 = {.dot_limit = 200000, .p2_slow = 14, .p2_fast = 14},\n\t .find_pll = gma_find_best_pll,\n\t },\n\t{\t\t\t \n\t .dot = {.min = 20000, .max = 115500},\n\t .vco = {.min = 1800000, .max = 3600000},\n\t .n = {.min = 2, .max = 6},\n\t .m = {.min = 60, .max = 160},\n\t .m1 = {.min = 0, .max = 0},\n\t .m2 = {.min = 58, .max = 158},\n\t .p = {.min = 28, .max = 140},\n\t .p1 = {.min = 2, .max = 10},\n\t  \n\t .p2 = {.dot_limit = 200000, .p2_slow = 14, .p2_fast = 14},\n\t .find_pll = gma_find_best_pll,\n\t },\n\t{\t\t\t \n\t .dot = {.min = 20000, .max = 400000},\n\t .vco = {.min = 1809000, .max = 3564000},\n\t .n = {.min = 1, .max = 1},\n\t .m = {.min = 67, .max = 132},\n\t .m1 = {.min = 0, .max = 0},\n\t .m2 = {.min = 65, .max = 130},\n\t .p = {.min = 5, .max = 90},\n\t .p1 = {.min = 1, .max = 9},\n\t .p2 = {.dot_limit = 225000, .p2_slow = 10, .p2_fast = 5},\n\t .find_pll = gma_find_best_pll,\n\t },\n\t{\t\t\t \n\t .dot = {.min = 20000, .max = 400000},\n\t .vco = {.min = 1800000, .max = 3600000},\n\t .n = {.min = 2, .max = 6},\n\t .m = {.min = 60, .max = 160},\n\t .m1 = {.min = 0, .max = 0},\n\t .m2 = {.min = 58, .max = 158},\n\t .p = {.min = 5, .max = 100},\n\t .p1 = {.min = 1, .max = 10},\n\t .p2 = {.dot_limit = 225000, .p2_slow = 10, .p2_fast = 5},\n\t .find_pll = gma_find_best_pll,\n\t },\n\t{\t\t\t \n\t .dot = {.min = 160000, .max = 272000},\n\t .vco = {.min = 1809000, .max = 3564000},\n\t .n = {.min = 1, .max = 1},\n\t .m = {.min = 67, .max = 132},\n\t .m1 = {.min = 0, .max = 0},\n\t .m2 = {.min = 65, .max = 130},\n\t .p = {.min = 5, .max = 90},\n\t .p1 = {.min = 1, .max = 9},\n\t .p2 = {.dot_limit = 225000, .p2_slow = 10, .p2_fast = 10},\n\t .find_pll = cdv_intel_find_dp_pll,\n\t },\n\t{\t\t\t \n\t .dot = {.min = 160000, .max = 272000},\n\t .vco = {.min = 1800000, .max = 3600000},\n\t .n = {.min = 2, .max = 6},\n\t .m = {.min = 60, .max = 164},\n\t .m1 = {.min = 0, .max = 0},\n\t .m2 = {.min = 58, .max = 162},\n\t .p = {.min = 5, .max = 100},\n\t .p1 = {.min = 1, .max = 10},\n\t .p2 = {.dot_limit = 225000, .p2_slow = 10, .p2_fast = 10},\n\t .find_pll = cdv_intel_find_dp_pll,\n\t}\n};\n\n#define _wait_for(COND, MS, W) ({ \\\n\tunsigned long timeout__ = jiffies + msecs_to_jiffies(MS);\t\\\n\tint ret__ = 0;\t\t\t\t\t\t\t\\\n\twhile (!(COND)) {\t\t\t\t\t\t\\\n\t\tif (time_after(jiffies, timeout__)) {\t\t\t\\\n\t\t\tret__ = -ETIMEDOUT;\t\t\t\t\\\n\t\t\tbreak;\t\t\t\t\t\t\\\n\t\t}\t\t\t\t\t\t\t\\\n\t\tif (W && !in_dbg_master())\t\t\t\t\\\n\t\t\tmsleep(W);\t\t\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\\\n\tret__;\t\t\t\t\t\t\t\t\\\n})\n\n#define wait_for(COND, MS) _wait_for(COND, MS, 1)\n\n\nint cdv_sb_read(struct drm_device *dev, u32 reg, u32 *val)\n{\n\tint ret;\n\n\tret = wait_for((REG_READ(SB_PCKT) & SB_BUSY) == 0, 1000);\n\tif (ret) {\n\t\tDRM_ERROR(\"timeout waiting for SB to idle before read\\n\");\n\t\treturn ret;\n\t}\n\n\tREG_WRITE(SB_ADDR, reg);\n\tREG_WRITE(SB_PCKT,\n\t\t   SET_FIELD(SB_OPCODE_READ, SB_OPCODE) |\n\t\t   SET_FIELD(SB_DEST_DPLL, SB_DEST) |\n\t\t   SET_FIELD(0xf, SB_BYTE_ENABLE));\n\n\tret = wait_for((REG_READ(SB_PCKT) & SB_BUSY) == 0, 1000);\n\tif (ret) {\n\t\tDRM_ERROR(\"timeout waiting for SB to idle after read\\n\");\n\t\treturn ret;\n\t}\n\n\t*val = REG_READ(SB_DATA);\n\n\treturn 0;\n}\n\nint cdv_sb_write(struct drm_device *dev, u32 reg, u32 val)\n{\n\tint ret;\n\tstatic bool dpio_debug = true;\n\tu32 temp;\n\n\tif (dpio_debug) {\n\t\tif (cdv_sb_read(dev, reg, &temp) == 0)\n\t\t\tDRM_DEBUG_KMS(\"0x%08x: 0x%08x (before)\\n\", reg, temp);\n\t\tDRM_DEBUG_KMS(\"0x%08x: 0x%08x\\n\", reg, val);\n\t}\n\n\tret = wait_for((REG_READ(SB_PCKT) & SB_BUSY) == 0, 1000);\n\tif (ret) {\n\t\tDRM_ERROR(\"timeout waiting for SB to idle before write\\n\");\n\t\treturn ret;\n\t}\n\n\tREG_WRITE(SB_ADDR, reg);\n\tREG_WRITE(SB_DATA, val);\n\tREG_WRITE(SB_PCKT,\n\t\t   SET_FIELD(SB_OPCODE_WRITE, SB_OPCODE) |\n\t\t   SET_FIELD(SB_DEST_DPLL, SB_DEST) |\n\t\t   SET_FIELD(0xf, SB_BYTE_ENABLE));\n\n\tret = wait_for((REG_READ(SB_PCKT) & SB_BUSY) == 0, 1000);\n\tif (ret) {\n\t\tDRM_ERROR(\"timeout waiting for SB to idle after write\\n\");\n\t\treturn ret;\n\t}\n\n\tif (dpio_debug) {\n\t\tif (cdv_sb_read(dev, reg, &temp) == 0)\n\t\t\tDRM_DEBUG_KMS(\"0x%08x: 0x%08x (after)\\n\", reg, temp);\n\t}\n\n\treturn 0;\n}\n\n \nvoid cdv_sb_reset(struct drm_device *dev)\n{\n\n\tREG_WRITE(DPIO_CFG, 0);\n\tREG_READ(DPIO_CFG);\n\tREG_WRITE(DPIO_CFG, DPIO_MODE_SELECT_0 | DPIO_CMN_RESET_N);\n}\n\n \nstatic int\ncdv_dpll_set_clock_cdv(struct drm_device *dev, struct drm_crtc *crtc,\n\t\t       struct gma_clock_t *clock, bool is_lvds, u32 ddi_select)\n{\n\tstruct gma_crtc *gma_crtc = to_gma_crtc(crtc);\n\tint pipe = gma_crtc->pipe;\n\tu32 m, n_vco, p;\n\tint ret = 0;\n\tint dpll_reg = (pipe == 0) ? DPLL_A : DPLL_B;\n\tint ref_sfr = (pipe == 0) ? SB_REF_DPLLA : SB_REF_DPLLB;\n\tu32 ref_value;\n\tu32 lane_reg, lane_value;\n\n\tcdv_sb_reset(dev);\n\n\tREG_WRITE(dpll_reg, DPLL_SYNCLOCK_ENABLE | DPLL_VGA_MODE_DIS);\n\n\tudelay(100);\n\n\t \n\tref_value = 0x68A701;\n\n\tcdv_sb_write(dev, SB_REF_SFR(pipe), ref_value);\n\n\t \n\t \n\tret = cdv_sb_read(dev, ref_sfr, &ref_value);\n\tif (ret)\n\t\treturn ret;\n\tref_value &= ~(REF_CLK_MASK);\n\n\t \n\tif (pipe == 1 && !is_lvds && !(ddi_select & DP_MASK)) {\n\t\tDRM_DEBUG_KMS(\"use DPLLA for pipe B\\n\");\n\t\tref_value |= REF_CLK_DPLLA;\n\t} else {\n\t\tDRM_DEBUG_KMS(\"use their DPLL for pipe A/B\\n\");\n\t\tref_value |= REF_CLK_DPLL;\n\t}\n\tret = cdv_sb_write(dev, ref_sfr, ref_value);\n\tif (ret)\n\t\treturn ret;\n\n\tret = cdv_sb_read(dev, SB_M(pipe), &m);\n\tif (ret)\n\t\treturn ret;\n\tm &= ~SB_M_DIVIDER_MASK;\n\tm |= ((clock->m2) << SB_M_DIVIDER_SHIFT);\n\tret = cdv_sb_write(dev, SB_M(pipe), m);\n\tif (ret)\n\t\treturn ret;\n\n\tret = cdv_sb_read(dev, SB_N_VCO(pipe), &n_vco);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tn_vco &= 0xFFFF;\n\tn_vco |= 0x107;\n\tn_vco &= ~(SB_N_VCO_SEL_MASK |\n\t\t   SB_N_DIVIDER_MASK |\n\t\t   SB_N_CB_TUNE_MASK);\n\n\tn_vco |= ((clock->n) << SB_N_DIVIDER_SHIFT);\n\n\tif (clock->vco < 2250000) {\n\t\tn_vco |= (2 << SB_N_CB_TUNE_SHIFT);\n\t\tn_vco |= (0 << SB_N_VCO_SEL_SHIFT);\n\t} else if (clock->vco < 2750000) {\n\t\tn_vco |= (1 << SB_N_CB_TUNE_SHIFT);\n\t\tn_vco |= (1 << SB_N_VCO_SEL_SHIFT);\n\t} else if (clock->vco < 3300000) {\n\t\tn_vco |= (0 << SB_N_CB_TUNE_SHIFT);\n\t\tn_vco |= (2 << SB_N_VCO_SEL_SHIFT);\n\t} else {\n\t\tn_vco |= (0 << SB_N_CB_TUNE_SHIFT);\n\t\tn_vco |= (3 << SB_N_VCO_SEL_SHIFT);\n\t}\n\n\tret = cdv_sb_write(dev, SB_N_VCO(pipe), n_vco);\n\tif (ret)\n\t\treturn ret;\n\n\tret = cdv_sb_read(dev, SB_P(pipe), &p);\n\tif (ret)\n\t\treturn ret;\n\tp &= ~(SB_P2_DIVIDER_MASK | SB_P1_DIVIDER_MASK);\n\tp |= SET_FIELD(clock->p1, SB_P1_DIVIDER);\n\tswitch (clock->p2) {\n\tcase 5:\n\t\tp |= SET_FIELD(SB_P2_5, SB_P2_DIVIDER);\n\t\tbreak;\n\tcase 10:\n\t\tp |= SET_FIELD(SB_P2_10, SB_P2_DIVIDER);\n\t\tbreak;\n\tcase 14:\n\t\tp |= SET_FIELD(SB_P2_14, SB_P2_DIVIDER);\n\t\tbreak;\n\tcase 7:\n\t\tp |= SET_FIELD(SB_P2_7, SB_P2_DIVIDER);\n\t\tbreak;\n\tdefault:\n\t\tDRM_ERROR(\"Bad P2 clock: %d\\n\", clock->p2);\n\t\treturn -EINVAL;\n\t}\n\tret = cdv_sb_write(dev, SB_P(pipe), p);\n\tif (ret)\n\t\treturn ret;\n\n\tif (ddi_select) {\n\t\tif ((ddi_select & DDI_MASK) == DDI0_SELECT) {\n\t\t\tlane_reg = PSB_LANE0;\n\t\t\tcdv_sb_read(dev, lane_reg, &lane_value);\n\t\t\tlane_value &= ~(LANE_PLL_MASK);\n\t\t\tlane_value |= LANE_PLL_ENABLE | LANE_PLL_PIPE(pipe);\n\t\t\tcdv_sb_write(dev, lane_reg, lane_value);\n\n\t\t\tlane_reg = PSB_LANE1;\n\t\t\tcdv_sb_read(dev, lane_reg, &lane_value);\n\t\t\tlane_value &= ~(LANE_PLL_MASK);\n\t\t\tlane_value |= LANE_PLL_ENABLE | LANE_PLL_PIPE(pipe);\n\t\t\tcdv_sb_write(dev, lane_reg, lane_value);\n\t\t} else {\n\t\t\tlane_reg = PSB_LANE2;\n\t\t\tcdv_sb_read(dev, lane_reg, &lane_value);\n\t\t\tlane_value &= ~(LANE_PLL_MASK);\n\t\t\tlane_value |= LANE_PLL_ENABLE | LANE_PLL_PIPE(pipe);\n\t\t\tcdv_sb_write(dev, lane_reg, lane_value);\n\n\t\t\tlane_reg = PSB_LANE3;\n\t\t\tcdv_sb_read(dev, lane_reg, &lane_value);\n\t\t\tlane_value &= ~(LANE_PLL_MASK);\n\t\t\tlane_value |= LANE_PLL_ENABLE | LANE_PLL_PIPE(pipe);\n\t\t\tcdv_sb_write(dev, lane_reg, lane_value);\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic const struct gma_limit_t *cdv_intel_limit(struct drm_crtc *crtc,\n\t\t\t\t\t\t int refclk)\n{\n\tconst struct gma_limit_t *limit;\n\tif (gma_pipe_has_type(crtc, INTEL_OUTPUT_LVDS)) {\n\t\t \n\t\tif (refclk == 96000)\n\t\t\tlimit = &cdv_intel_limits[CDV_LIMIT_SINGLE_LVDS_96];\n\t\telse\n\t\t\tlimit = &cdv_intel_limits[CDV_LIMIT_SINGLE_LVDS_100];\n\t} else if (gma_pipe_has_type(crtc, INTEL_OUTPUT_DISPLAYPORT) ||\n\t\t\tgma_pipe_has_type(crtc, INTEL_OUTPUT_EDP)) {\n\t\tif (refclk == 27000)\n\t\t\tlimit = &cdv_intel_limits[CDV_LIMIT_DP_27];\n\t\telse\n\t\t\tlimit = &cdv_intel_limits[CDV_LIMIT_DP_100];\n\t} else {\n\t\tif (refclk == 27000)\n\t\t\tlimit = &cdv_intel_limits[CDV_LIMIT_DAC_HDMI_27];\n\t\telse\n\t\t\tlimit = &cdv_intel_limits[CDV_LIMIT_DAC_HDMI_96];\n\t}\n\treturn limit;\n}\n\n \nstatic void cdv_intel_clock(int refclk, struct gma_clock_t *clock)\n{\n\tclock->m = clock->m2 + 2;\n\tclock->p = clock->p1 * clock->p2;\n\tclock->vco = (refclk * clock->m) / clock->n;\n\tclock->dot = clock->vco / clock->p;\n}\n\nstatic bool cdv_intel_find_dp_pll(const struct gma_limit_t *limit,\n\t\t\t\t  struct drm_crtc *crtc, int target,\n\t\t\t\t  int refclk,\n\t\t\t\t  struct gma_clock_t *best_clock)\n{\n\tstruct gma_crtc *gma_crtc = to_gma_crtc(crtc);\n\tstruct gma_clock_t clock;\n\n\tmemset(&clock, 0, sizeof(clock));\n\n\tswitch (refclk) {\n\tcase 27000:\n\t\tif (target < 200000) {\n\t\t\tclock.p1 = 2;\n\t\t\tclock.p2 = 10;\n\t\t\tclock.n = 1;\n\t\t\tclock.m1 = 0;\n\t\t\tclock.m2 = 118;\n\t\t} else {\n\t\t\tclock.p1 = 1;\n\t\t\tclock.p2 = 10;\n\t\t\tclock.n = 1;\n\t\t\tclock.m1 = 0;\n\t\t\tclock.m2 = 98;\n\t\t}\n\t\tbreak;\n\n\tcase 100000:\n\t\tif (target < 200000) {\n\t\t\tclock.p1 = 2;\n\t\t\tclock.p2 = 10;\n\t\t\tclock.n = 5;\n\t\t\tclock.m1 = 0;\n\t\t\tclock.m2 = 160;\n\t\t} else {\n\t\t\tclock.p1 = 1;\n\t\t\tclock.p2 = 10;\n\t\t\tclock.n = 5;\n\t\t\tclock.m1 = 0;\n\t\t\tclock.m2 = 133;\n\t\t}\n\t\tbreak;\n\n\tdefault:\n\t\treturn false;\n\t}\n\n\tgma_crtc->clock_funcs->clock(refclk, &clock);\n\tmemcpy(best_clock, &clock, sizeof(struct gma_clock_t));\n\treturn true;\n}\n\n#define\t\tFIFO_PIPEA\t\t(1 << 0)\n#define\t\tFIFO_PIPEB\t\t(1 << 1)\n\nstatic bool cdv_intel_pipe_enabled(struct drm_device *dev, int pipe)\n{\n\tstruct drm_crtc *crtc;\n\tstruct drm_psb_private *dev_priv = to_drm_psb_private(dev);\n\tstruct gma_crtc *gma_crtc = NULL;\n\n\tcrtc = dev_priv->pipe_to_crtc_mapping[pipe];\n\tgma_crtc = to_gma_crtc(crtc);\n\n\tif (crtc->primary->fb == NULL || !gma_crtc->active)\n\t\treturn false;\n\treturn true;\n}\n\nvoid cdv_disable_sr(struct drm_device *dev)\n{\n\tif (REG_READ(FW_BLC_SELF) & FW_BLC_SELF_EN) {\n\n\t\t \n\t\tREG_WRITE(FW_BLC_SELF, (REG_READ(FW_BLC_SELF) & ~FW_BLC_SELF_EN));\n\t\tREG_READ(FW_BLC_SELF);\n\n\t\tgma_wait_for_vblank(dev);\n\n\t\t \n\t\tREG_WRITE(OV_OVADD, 0 );\n\t\tREG_READ(OV_OVADD);\n\n\t\tgma_wait_for_vblank(dev);\n\t}\n\n}\n\nvoid cdv_update_wm(struct drm_device *dev, struct drm_crtc *crtc)\n{\n\tstruct drm_psb_private *dev_priv = to_drm_psb_private(dev);\n\tstruct gma_crtc *gma_crtc = to_gma_crtc(crtc);\n\n\t \n\tif (cdv_intel_pipe_enabled(dev, 0) ^ cdv_intel_pipe_enabled(dev, 1)) {\n\t\tu32 fw;\n\n\t\tfw = REG_READ(DSPFW1);\n\t\tfw &= ~DSP_FIFO_SR_WM_MASK;\n\t\tfw |= (0x7e << DSP_FIFO_SR_WM_SHIFT);\n\t\tfw &= ~CURSOR_B_FIFO_WM_MASK;\n\t\tfw |= (0x4 << CURSOR_B_FIFO_WM_SHIFT);\n\t\tREG_WRITE(DSPFW1, fw);\n\n\t\tfw = REG_READ(DSPFW2);\n\t\tfw &= ~CURSOR_A_FIFO_WM_MASK;\n\t\tfw |= (0x6 << CURSOR_A_FIFO_WM_SHIFT);\n\t\tfw &= ~DSP_PLANE_C_FIFO_WM_MASK;\n\t\tfw |= (0x8 << DSP_PLANE_C_FIFO_WM_SHIFT);\n\t\tREG_WRITE(DSPFW2, fw);\n\n\t\tREG_WRITE(DSPFW3, 0x36000000);\n\n\t\t \n\n\t\t \n\t\tif (gma_crtc->pipe == 1 &&\n\t\t    gma_pipe_has_type(crtc, INTEL_OUTPUT_LVDS)) {\n\t\t\tREG_WRITE(DSPFW5, 0x00040330);\n\t\t} else {\n\t\t\tfw = (3 << DSP_PLANE_B_FIFO_WM1_SHIFT) |\n\t\t\t     (4 << DSP_PLANE_A_FIFO_WM1_SHIFT) |\n\t\t\t     (3 << CURSOR_B_FIFO_WM1_SHIFT) |\n\t\t\t     (4 << CURSOR_FIFO_SR_WM1_SHIFT);\n\t\t\tREG_WRITE(DSPFW5, fw);\n\t\t}\n\n\t\tREG_WRITE(DSPFW6, 0x10);\n\n\t\tgma_wait_for_vblank(dev);\n\n\t\t \n\t\tREG_WRITE(FW_BLC_SELF, FW_BLC_SELF_EN);\n\t\tREG_READ(FW_BLC_SELF);\n\t\tgma_wait_for_vblank(dev);\n\n\t} else {\n\n\t\t \n\t\tREG_WRITE(DSPFW1, 0x3f880808);\n\t\tREG_WRITE(DSPFW2, 0x0b020202);\n\t\tREG_WRITE(DSPFW3, 0x24000000);\n\t\tREG_WRITE(DSPFW4, 0x08030202);\n\t\tREG_WRITE(DSPFW5, 0x01010101);\n\t\tREG_WRITE(DSPFW6, 0x1d0);\n\n\t\tgma_wait_for_vblank(dev);\n\n\t\tdev_priv->ops->disable_sr(dev);\n\t}\n}\n\n \nstatic int cdv_intel_panel_fitter_pipe(struct drm_device *dev)\n{\n\tu32 pfit_control;\n\n\tpfit_control = REG_READ(PFIT_CONTROL);\n\n\t \n\tif ((pfit_control & PFIT_ENABLE) == 0)\n\t\treturn -1;\n\treturn (pfit_control >> 29) & 0x3;\n}\n\nstatic int cdv_intel_crtc_mode_set(struct drm_crtc *crtc,\n\t\t\t       struct drm_display_mode *mode,\n\t\t\t       struct drm_display_mode *adjusted_mode,\n\t\t\t       int x, int y,\n\t\t\t       struct drm_framebuffer *old_fb)\n{\n\tstruct drm_device *dev = crtc->dev;\n\tstruct drm_psb_private *dev_priv = to_drm_psb_private(dev);\n\tstruct gma_crtc *gma_crtc = to_gma_crtc(crtc);\n\tint pipe = gma_crtc->pipe;\n\tconst struct psb_offset *map = &dev_priv->regmap[pipe];\n\tint refclk;\n\tstruct gma_clock_t clock;\n\tu32 dpll = 0, dspcntr, pipeconf;\n\tbool ok;\n\tbool is_lvds = false;\n\tbool is_dp = false;\n\tstruct drm_connector_list_iter conn_iter;\n\tstruct drm_connector *connector;\n\tconst struct gma_limit_t *limit;\n\tu32 ddi_select = 0;\n\tbool is_edp = false;\n\n\tdrm_connector_list_iter_begin(dev, &conn_iter);\n\tdrm_for_each_connector_iter(connector, &conn_iter) {\n\t\tstruct gma_encoder *gma_encoder =\n\t\t\t\t\tgma_attached_encoder(connector);\n\n\t\tif (!connector->encoder\n\t\t    || connector->encoder->crtc != crtc)\n\t\t\tcontinue;\n\n\t\tddi_select = gma_encoder->ddi_select;\n\t\tswitch (gma_encoder->type) {\n\t\tcase INTEL_OUTPUT_LVDS:\n\t\t\tis_lvds = true;\n\t\t\tbreak;\n\t\tcase INTEL_OUTPUT_ANALOG:\n\t\tcase INTEL_OUTPUT_HDMI:\n\t\t\tbreak;\n\t\tcase INTEL_OUTPUT_DISPLAYPORT:\n\t\t\tis_dp = true;\n\t\t\tbreak;\n\t\tcase INTEL_OUTPUT_EDP:\n\t\t\tis_edp = true;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdrm_connector_list_iter_end(&conn_iter);\n\t\t\tDRM_ERROR(\"invalid output type.\\n\");\n\t\t\treturn 0;\n\t\t}\n\n\t\tbreak;\n\t}\n\tdrm_connector_list_iter_end(&conn_iter);\n\n\tif (dev_priv->dplla_96mhz)\n\t\t \n\t\trefclk = 96000;\n\telse\n\t\t \n\t\trefclk = 27000;\n\tif (is_dp || is_edp) {\n\t\t \n\t\tif (pipe == 0)\n\t\t\trefclk = 27000;\n\t\telse\n\t\t\trefclk = 100000;\n\t}\n\n\tif (is_lvds && dev_priv->lvds_use_ssc) {\n\t\trefclk = dev_priv->lvds_ssc_freq * 1000;\n\t\tDRM_DEBUG_KMS(\"Use SSC reference clock %d Mhz\\n\", dev_priv->lvds_ssc_freq);\n\t}\n\n\tdrm_mode_debug_printmodeline(adjusted_mode);\n\n\tlimit = gma_crtc->clock_funcs->limit(crtc, refclk);\n\n\tok = limit->find_pll(limit, crtc, adjusted_mode->clock, refclk,\n\t\t\t\t &clock);\n\tif (!ok) {\n\t\tDRM_ERROR(\"Couldn't find PLL settings for mode! target: %d, actual: %d\",\n\t\t\t  adjusted_mode->clock, clock.dot);\n\t\treturn 0;\n\t}\n\n\tdpll = DPLL_VGA_MODE_DIS;\n\n\tif (is_dp || is_edp) {\n\t\tcdv_intel_dp_set_m_n(crtc, mode, adjusted_mode);\n\t} else {\n\t\tREG_WRITE(PIPE_GMCH_DATA_M(pipe), 0);\n\t\tREG_WRITE(PIPE_GMCH_DATA_N(pipe), 0);\n\t\tREG_WRITE(PIPE_DP_LINK_M(pipe), 0);\n\t\tREG_WRITE(PIPE_DP_LINK_N(pipe), 0);\n\t}\n\n\tdpll |= DPLL_SYNCLOCK_ENABLE;\n \n\t \n\n\t \n\tpipeconf = REG_READ(map->conf);\n\n\tpipeconf &= ~(PIPE_BPC_MASK);\n\tif (is_edp) {\n\t\tswitch (dev_priv->edp.bpp) {\n\t\tcase 24:\n\t\t\tpipeconf |= PIPE_8BPC;\n\t\t\tbreak;\n\t\tcase 18:\n\t\t\tpipeconf |= PIPE_6BPC;\n\t\t\tbreak;\n\t\tcase 30:\n\t\t\tpipeconf |= PIPE_10BPC;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tpipeconf |= PIPE_8BPC;\n\t\t\tbreak;\n\t\t}\n\t} else if (is_lvds) {\n\t\t \n\t\tif ((REG_READ(LVDS) & LVDS_A3_POWER_MASK) == LVDS_A3_POWER_UP)\n\t\t\tpipeconf |= PIPE_8BPC;\n\t\telse\n\t\t\tpipeconf |= PIPE_6BPC;\n\t} else\n\t\tpipeconf |= PIPE_8BPC;\n\n\t \n\tdspcntr = DISPPLANE_GAMMA_ENABLE;\n\n\tif (pipe == 0)\n\t\tdspcntr |= DISPPLANE_SEL_PIPE_A;\n\telse\n\t\tdspcntr |= DISPPLANE_SEL_PIPE_B;\n\n\tdspcntr |= DISPLAY_PLANE_ENABLE;\n\tpipeconf |= PIPEACONF_ENABLE;\n\n\tREG_WRITE(map->dpll, dpll | DPLL_VGA_MODE_DIS | DPLL_SYNCLOCK_ENABLE);\n\tREG_READ(map->dpll);\n\n\tcdv_dpll_set_clock_cdv(dev, crtc, &clock, is_lvds, ddi_select);\n\n\tudelay(150);\n\n\n\t \n\tif (is_lvds) {\n\t\tu32 lvds = REG_READ(LVDS);\n\n\t\tlvds |=\n\t\t    LVDS_PORT_EN | LVDS_A0A2_CLKA_POWER_UP |\n\t\t    LVDS_PIPEB_SELECT;\n\t\t \n\t\tif (clock.p2 == 7)\n\t\t\tlvds |= LVDS_B0B3_POWER_UP | LVDS_CLKB_POWER_UP;\n\t\telse\n\t\t\tlvds &= ~(LVDS_B0B3_POWER_UP | LVDS_CLKB_POWER_UP);\n\n\t\t \n\n\t\tREG_WRITE(LVDS, lvds);\n\t\tREG_READ(LVDS);\n\t}\n\n\tdpll |= DPLL_VCO_ENABLE;\n\n\t \n\tif (cdv_intel_panel_fitter_pipe(dev) == pipe)\n\t\tREG_WRITE(PFIT_CONTROL, 0);\n\n\tDRM_DEBUG_KMS(\"Mode for pipe %c:\\n\", pipe == 0 ? 'A' : 'B');\n\tdrm_mode_debug_printmodeline(mode);\n\n\tREG_WRITE(map->dpll,\n\t\t(REG_READ(map->dpll) & ~DPLL_LOCK) | DPLL_VCO_ENABLE);\n\tREG_READ(map->dpll);\n\t \n\tudelay(150);  \n\n\tif (!(REG_READ(map->dpll) & DPLL_LOCK)) {\n\t\tdev_err(dev->dev, \"Failed to get DPLL lock\\n\");\n\t\treturn -EBUSY;\n\t}\n\n\t{\n\t\tint sdvo_pixel_multiply = adjusted_mode->clock / mode->clock;\n\t\tREG_WRITE(map->dpll_md, (0 << DPLL_MD_UDI_DIVIDER_SHIFT) | ((sdvo_pixel_multiply - 1) << DPLL_MD_UDI_MULTIPLIER_SHIFT));\n\t}\n\n\tREG_WRITE(map->htotal, (adjusted_mode->crtc_hdisplay - 1) |\n\t\t  ((adjusted_mode->crtc_htotal - 1) << 16));\n\tREG_WRITE(map->hblank, (adjusted_mode->crtc_hblank_start - 1) |\n\t\t  ((adjusted_mode->crtc_hblank_end - 1) << 16));\n\tREG_WRITE(map->hsync, (adjusted_mode->crtc_hsync_start - 1) |\n\t\t  ((adjusted_mode->crtc_hsync_end - 1) << 16));\n\tREG_WRITE(map->vtotal, (adjusted_mode->crtc_vdisplay - 1) |\n\t\t  ((adjusted_mode->crtc_vtotal - 1) << 16));\n\tREG_WRITE(map->vblank, (adjusted_mode->crtc_vblank_start - 1) |\n\t\t  ((adjusted_mode->crtc_vblank_end - 1) << 16));\n\tREG_WRITE(map->vsync, (adjusted_mode->crtc_vsync_start - 1) |\n\t\t  ((adjusted_mode->crtc_vsync_end - 1) << 16));\n\t \n\tREG_WRITE(map->size,\n\t\t  ((mode->vdisplay - 1) << 16) | (mode->hdisplay - 1));\n\tREG_WRITE(map->pos, 0);\n\tREG_WRITE(map->src,\n\t\t  ((mode->hdisplay - 1) << 16) | (mode->vdisplay - 1));\n\tREG_WRITE(map->conf, pipeconf);\n\tREG_READ(map->conf);\n\n\tgma_wait_for_vblank(dev);\n\n\tREG_WRITE(map->cntr, dspcntr);\n\n\t \n\t{\n\t\tconst struct drm_crtc_helper_funcs *crtc_funcs =\n\t\t    crtc->helper_private;\n\t\tcrtc_funcs->mode_set_base(crtc, x, y, old_fb);\n\t}\n\n\tgma_wait_for_vblank(dev);\n\n\treturn 0;\n}\n\n \n\n \n\nstatic void i8xx_clock(int refclk, struct gma_clock_t *clock)\n{\n\tclock->m = 5 * (clock->m1 + 2) + (clock->m2 + 2);\n\tclock->p = clock->p1 * clock->p2;\n\tclock->vco = refclk * clock->m / (clock->n + 2);\n\tclock->dot = clock->vco / clock->p;\n}\n\n \nstatic int cdv_intel_crtc_clock_get(struct drm_device *dev,\n\t\t\t\tstruct drm_crtc *crtc)\n{\n\tstruct drm_psb_private *dev_priv = to_drm_psb_private(dev);\n\tstruct gma_crtc *gma_crtc = to_gma_crtc(crtc);\n\tint pipe = gma_crtc->pipe;\n\tconst struct psb_offset *map = &dev_priv->regmap[pipe];\n\tu32 dpll;\n\tu32 fp;\n\tstruct gma_clock_t clock;\n\tbool is_lvds;\n\tstruct psb_pipe *p = &dev_priv->regs.pipe[pipe];\n\n\tif (gma_power_begin(dev, false)) {\n\t\tdpll = REG_READ(map->dpll);\n\t\tif ((dpll & DISPLAY_RATE_SELECT_FPA1) == 0)\n\t\t\tfp = REG_READ(map->fp0);\n\t\telse\n\t\t\tfp = REG_READ(map->fp1);\n\t\tis_lvds = (pipe == 1) && (REG_READ(LVDS) & LVDS_PORT_EN);\n\t\tgma_power_end(dev);\n\t} else {\n\t\tdpll = p->dpll;\n\t\tif ((dpll & DISPLAY_RATE_SELECT_FPA1) == 0)\n\t\t\tfp = p->fp0;\n\t\telse\n\t\t\tfp = p->fp1;\n\n\t\tis_lvds = (pipe == 1) &&\n\t\t\t\t(dev_priv->regs.psb.saveLVDS & LVDS_PORT_EN);\n\t}\n\n\tclock.m1 = (fp & FP_M1_DIV_MASK) >> FP_M1_DIV_SHIFT;\n\tclock.m2 = (fp & FP_M2_DIV_MASK) >> FP_M2_DIV_SHIFT;\n\tclock.n = (fp & FP_N_DIV_MASK) >> FP_N_DIV_SHIFT;\n\n\tif (is_lvds) {\n\t\tclock.p1 =\n\t\t    ffs((dpll &\n\t\t\t DPLL_FPA01_P1_POST_DIV_MASK_I830_LVDS) >>\n\t\t\tDPLL_FPA01_P1_POST_DIV_SHIFT);\n\t\tif (clock.p1 == 0) {\n\t\t\tclock.p1 = 4;\n\t\t\tdev_err(dev->dev, \"PLL %d\\n\", dpll);\n\t\t}\n\t\tclock.p2 = 14;\n\n\t\tif ((dpll & PLL_REF_INPUT_MASK) ==\n\t\t    PLLB_REF_INPUT_SPREADSPECTRUMIN) {\n\t\t\t \n\t\t\ti8xx_clock(66000, &clock);\n\t\t} else\n\t\t\ti8xx_clock(48000, &clock);\n\t} else {\n\t\tif (dpll & PLL_P1_DIVIDE_BY_TWO)\n\t\t\tclock.p1 = 2;\n\t\telse {\n\t\t\tclock.p1 =\n\t\t\t    ((dpll &\n\t\t\t      DPLL_FPA01_P1_POST_DIV_MASK_I830) >>\n\t\t\t     DPLL_FPA01_P1_POST_DIV_SHIFT) + 2;\n\t\t}\n\t\tif (dpll & PLL_P2_DIVIDE_BY_4)\n\t\t\tclock.p2 = 4;\n\t\telse\n\t\t\tclock.p2 = 2;\n\n\t\ti8xx_clock(48000, &clock);\n\t}\n\n\t \n\n\treturn clock.dot;\n}\n\n \nstruct drm_display_mode *cdv_intel_crtc_mode_get(struct drm_device *dev,\n\t\t\t\t\t     struct drm_crtc *crtc)\n{\n\tstruct gma_crtc *gma_crtc = to_gma_crtc(crtc);\n\tint pipe = gma_crtc->pipe;\n\tstruct drm_psb_private *dev_priv = to_drm_psb_private(dev);\n\tstruct psb_pipe *p = &dev_priv->regs.pipe[pipe];\n\tconst struct psb_offset *map = &dev_priv->regmap[pipe];\n\tstruct drm_display_mode *mode;\n\tint htot;\n\tint hsync;\n\tint vtot;\n\tint vsync;\n\n\tif (gma_power_begin(dev, false)) {\n\t\thtot = REG_READ(map->htotal);\n\t\thsync = REG_READ(map->hsync);\n\t\tvtot = REG_READ(map->vtotal);\n\t\tvsync = REG_READ(map->vsync);\n\t\tgma_power_end(dev);\n\t} else {\n\t\thtot = p->htotal;\n\t\thsync = p->hsync;\n\t\tvtot = p->vtotal;\n\t\tvsync = p->vsync;\n\t}\n\n\tmode = kzalloc(sizeof(*mode), GFP_KERNEL);\n\tif (!mode)\n\t\treturn NULL;\n\n\tmode->clock = cdv_intel_crtc_clock_get(dev, crtc);\n\tmode->hdisplay = (htot & 0xffff) + 1;\n\tmode->htotal = ((htot & 0xffff0000) >> 16) + 1;\n\tmode->hsync_start = (hsync & 0xffff) + 1;\n\tmode->hsync_end = ((hsync & 0xffff0000) >> 16) + 1;\n\tmode->vdisplay = (vtot & 0xffff) + 1;\n\tmode->vtotal = ((vtot & 0xffff0000) >> 16) + 1;\n\tmode->vsync_start = (vsync & 0xffff) + 1;\n\tmode->vsync_end = ((vsync & 0xffff0000) >> 16) + 1;\n\n\tdrm_mode_set_name(mode);\n\tdrm_mode_set_crtcinfo(mode, 0);\n\n\treturn mode;\n}\n\nconst struct drm_crtc_helper_funcs cdv_intel_helper_funcs = {\n\t.dpms = gma_crtc_dpms,\n\t.mode_set = cdv_intel_crtc_mode_set,\n\t.mode_set_base = gma_pipe_set_base,\n\t.prepare = gma_crtc_prepare,\n\t.commit = gma_crtc_commit,\n\t.disable = gma_crtc_disable,\n};\n\nconst struct gma_clock_funcs cdv_clock_funcs = {\n\t.clock = cdv_intel_clock,\n\t.limit = cdv_intel_limit,\n\t.pll_is_valid = gma_pll_is_valid,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}