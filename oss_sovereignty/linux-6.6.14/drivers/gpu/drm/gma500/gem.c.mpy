{
  "module_name": "gem.c",
  "hash_id": "8253dcc8e5edb8dd51f5b94bdcbc9886fe7769dd8b427afbb1176f5a212a1b5a",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/gma500/gem.c",
  "human_readable_source": "\n \n\n#include <linux/pagemap.h>\n\n#include <asm/set_memory.h>\n\n#include <drm/drm.h>\n#include <drm/drm_vma_manager.h>\n\n#include \"gem.h\"\n#include \"psb_drv.h\"\n\n \n\nint psb_gem_pin(struct psb_gem_object *pobj)\n{\n\tstruct drm_gem_object *obj = &pobj->base;\n\tstruct drm_device *dev = obj->dev;\n\tstruct drm_psb_private *dev_priv = to_drm_psb_private(dev);\n\tu32 gpu_base = dev_priv->gtt.gatt_start;\n\tstruct page **pages;\n\tunsigned int npages;\n\tint ret;\n\n\tret = dma_resv_lock(obj->resv, NULL);\n\tif (drm_WARN_ONCE(dev, ret, \"dma_resv_lock() failed, ret=%d\\n\", ret))\n\t\treturn ret;\n\n\tif (pobj->in_gart || pobj->stolen)\n\t\tgoto out;  \n\n\tpages = drm_gem_get_pages(obj);\n\tif (IS_ERR(pages)) {\n\t\tret = PTR_ERR(pages);\n\t\tgoto err_dma_resv_unlock;\n\t}\n\n\tnpages = obj->size / PAGE_SIZE;\n\n\tset_pages_array_wc(pages, npages);\n\n\tpsb_gtt_insert_pages(dev_priv, &pobj->resource, pages);\n\tpsb_mmu_insert_pages(psb_mmu_get_default_pd(dev_priv->mmu), pages,\n\t\t\t     (gpu_base + pobj->offset), npages, 0, 0,\n\t\t\t     PSB_MMU_CACHED_MEMORY);\n\n\tpobj->pages = pages;\n\nout:\n\t++pobj->in_gart;\n\tdma_resv_unlock(obj->resv);\n\n\treturn 0;\n\nerr_dma_resv_unlock:\n\tdma_resv_unlock(obj->resv);\n\treturn ret;\n}\n\nvoid psb_gem_unpin(struct psb_gem_object *pobj)\n{\n\tstruct drm_gem_object *obj = &pobj->base;\n\tstruct drm_device *dev = obj->dev;\n\tstruct drm_psb_private *dev_priv = to_drm_psb_private(dev);\n\tu32 gpu_base = dev_priv->gtt.gatt_start;\n\tunsigned long npages;\n\tint ret;\n\n\tret = dma_resv_lock(obj->resv, NULL);\n\tif (drm_WARN_ONCE(dev, ret, \"dma_resv_lock() failed, ret=%d\\n\", ret))\n\t\treturn;\n\n\tWARN_ON(!pobj->in_gart);\n\n\t--pobj->in_gart;\n\n\tif (pobj->in_gart || pobj->stolen)\n\t\tgoto out;\n\n\tnpages = obj->size / PAGE_SIZE;\n\n\tpsb_mmu_remove_pages(psb_mmu_get_default_pd(dev_priv->mmu),\n\t\t\t     (gpu_base + pobj->offset), npages, 0, 0);\n\tpsb_gtt_remove_pages(dev_priv, &pobj->resource);\n\n\t \n\tset_pages_array_wb(pobj->pages, npages);\n\n\tdrm_gem_put_pages(obj, pobj->pages, true, false);\n\tpobj->pages = NULL;\n\nout:\n\tdma_resv_unlock(obj->resv);\n}\n\nstatic vm_fault_t psb_gem_fault(struct vm_fault *vmf);\n\nstatic void psb_gem_free_object(struct drm_gem_object *obj)\n{\n\tstruct psb_gem_object *pobj = to_psb_gem_object(obj);\n\n\t \n\tif (pobj->mmapping)\n\t\tpsb_gem_unpin(pobj);\n\n\tdrm_gem_object_release(obj);\n\n\tWARN_ON(pobj->in_gart && !pobj->stolen);\n\n\trelease_resource(&pobj->resource);\n\tkfree(pobj);\n}\n\nstatic const struct vm_operations_struct psb_gem_vm_ops = {\n\t.fault = psb_gem_fault,\n\t.open = drm_gem_vm_open,\n\t.close = drm_gem_vm_close,\n};\n\nstatic const struct drm_gem_object_funcs psb_gem_object_funcs = {\n\t.free = psb_gem_free_object,\n\t.vm_ops = &psb_gem_vm_ops,\n};\n\nstruct psb_gem_object *\npsb_gem_create(struct drm_device *dev, u64 size, const char *name, bool stolen, u32 align)\n{\n\tstruct drm_psb_private *dev_priv = to_drm_psb_private(dev);\n\tstruct psb_gem_object *pobj;\n\tstruct drm_gem_object *obj;\n\tint ret;\n\n\tsize = roundup(size, PAGE_SIZE);\n\n\tpobj = kzalloc(sizeof(*pobj), GFP_KERNEL);\n\tif (!pobj)\n\t\treturn ERR_PTR(-ENOMEM);\n\tobj = &pobj->base;\n\n\t \n\n\tret = psb_gtt_allocate_resource(dev_priv, &pobj->resource, name, size, align, stolen,\n\t\t\t\t\t&pobj->offset);\n\tif (ret)\n\t\tgoto err_kfree;\n\n\tif (stolen) {\n\t\tpobj->stolen = true;\n\t\tpobj->in_gart = 1;\n\t}\n\n\t \n\n\tobj->funcs = &psb_gem_object_funcs;\n\n\tif (stolen) {\n\t\tdrm_gem_private_object_init(dev, obj, size);\n\t} else {\n\t\tret = drm_gem_object_init(dev, obj, size);\n\t\tif (ret)\n\t\t\tgoto err_release_resource;\n\n\t\t \n\t\tmapping_set_gfp_mask(obj->filp->f_mapping, GFP_KERNEL | __GFP_DMA32);\n\t}\n\n\treturn pobj;\n\nerr_release_resource:\n\trelease_resource(&pobj->resource);\nerr_kfree:\n\tkfree(pobj);\n\treturn ERR_PTR(ret);\n}\n\n \nint psb_gem_dumb_create(struct drm_file *file, struct drm_device *dev,\n\t\t\tstruct drm_mode_create_dumb *args)\n{\n\tsize_t pitch, size;\n\tstruct psb_gem_object *pobj;\n\tstruct drm_gem_object *obj;\n\tu32 handle;\n\tint ret;\n\n\tpitch = args->width * DIV_ROUND_UP(args->bpp, 8);\n\tpitch = ALIGN(pitch, 64);\n\n\tsize = pitch * args->height;\n\tsize = roundup(size, PAGE_SIZE);\n\tif (!size)\n\t\treturn -EINVAL;\n\n\tpobj = psb_gem_create(dev, size, \"gem\", false, PAGE_SIZE);\n\tif (IS_ERR(pobj))\n\t\treturn PTR_ERR(pobj);\n\tobj = &pobj->base;\n\n\tret = drm_gem_handle_create(file, obj, &handle);\n\tif (ret)\n\t\tgoto err_drm_gem_object_put;\n\n\tdrm_gem_object_put(obj);\n\n\targs->pitch = pitch;\n\targs->size = size;\n\targs->handle = handle;\n\n\treturn 0;\n\nerr_drm_gem_object_put:\n\tdrm_gem_object_put(obj);\n\treturn ret;\n}\n\n \nstatic vm_fault_t psb_gem_fault(struct vm_fault *vmf)\n{\n\tstruct vm_area_struct *vma = vmf->vma;\n\tstruct drm_gem_object *obj;\n\tstruct psb_gem_object *pobj;\n\tint err;\n\tvm_fault_t ret;\n\tunsigned long pfn;\n\tpgoff_t page_offset;\n\tstruct drm_device *dev;\n\tstruct drm_psb_private *dev_priv;\n\n\tobj = vma->vm_private_data;\t \n\tdev = obj->dev;\n\tdev_priv = to_drm_psb_private(dev);\n\n\tpobj = to_psb_gem_object(obj);\n\n\t \n\tmutex_lock(&dev_priv->mmap_mutex);\n\n\t \n\tif (pobj->mmapping == 0) {\n\t\terr = psb_gem_pin(pobj);\n\t\tif (err < 0) {\n\t\t\tdev_err(dev->dev, \"gma500: pin failed: %d\\n\", err);\n\t\t\tret = vmf_error(err);\n\t\t\tgoto fail;\n\t\t}\n\t\tpobj->mmapping = 1;\n\t}\n\n\t \n\tpage_offset = (vmf->address - vma->vm_start) >> PAGE_SHIFT;\n\n\t \n\tif (pobj->stolen)\n\t\tpfn = (dev_priv->stolen_base + pobj->offset) >> PAGE_SHIFT;\n\telse\n\t\tpfn = page_to_pfn(pobj->pages[page_offset]);\n\tret = vmf_insert_pfn(vma, vmf->address, pfn);\nfail:\n\tmutex_unlock(&dev_priv->mmap_mutex);\n\n\treturn ret;\n}\n\n \n\n \nstatic void psb_gem_mm_populate_stolen(struct drm_psb_private *pdev)\n{\n\tstruct drm_device *dev = &pdev->dev;\n\tunsigned int pfn_base;\n\tunsigned int i, num_pages;\n\tuint32_t pte;\n\n\tpfn_base = pdev->stolen_base >> PAGE_SHIFT;\n\tnum_pages = pdev->vram_stolen_size >> PAGE_SHIFT;\n\n\tdrm_dbg(dev, \"Set up %u stolen pages starting at 0x%08x, GTT offset %dK\\n\",\n\t\tnum_pages, pfn_base << PAGE_SHIFT, 0);\n\n\tfor (i = 0; i < num_pages; ++i) {\n\t\tpte = psb_gtt_mask_pte(pfn_base + i, PSB_MMU_CACHED_MEMORY);\n\t\tiowrite32(pte, pdev->gtt_map + i);\n\t}\n\n\t(void)ioread32(pdev->gtt_map + i - 1);\n}\n\nint psb_gem_mm_init(struct drm_device *dev)\n{\n\tstruct drm_psb_private *dev_priv = to_drm_psb_private(dev);\n\tstruct pci_dev *pdev = to_pci_dev(dev->dev);\n\tunsigned long stolen_size, vram_stolen_size;\n\tstruct psb_gtt *pg;\n\tint ret;\n\n\tmutex_init(&dev_priv->mmap_mutex);\n\n\tpg = &dev_priv->gtt;\n\n\tpci_read_config_dword(pdev, PSB_BSM, &dev_priv->stolen_base);\n\tvram_stolen_size = pg->gtt_phys_start - dev_priv->stolen_base - PAGE_SIZE;\n\n\tstolen_size = vram_stolen_size;\n\n\tdev_dbg(dev->dev, \"Stolen memory base 0x%x, size %luK\\n\",\n\t\tdev_priv->stolen_base, vram_stolen_size / 1024);\n\n\tpg->stolen_size = stolen_size;\n\tdev_priv->vram_stolen_size = vram_stolen_size;\n\n\tdev_priv->vram_addr = ioremap_wc(dev_priv->stolen_base, stolen_size);\n\tif (!dev_priv->vram_addr) {\n\t\tdev_err(dev->dev, \"Failure to map stolen base.\\n\");\n\t\tret = -ENOMEM;\n\t\tgoto err_mutex_destroy;\n\t}\n\n\tpsb_gem_mm_populate_stolen(dev_priv);\n\n\treturn 0;\n\nerr_mutex_destroy:\n\tmutex_destroy(&dev_priv->mmap_mutex);\n\treturn ret;\n}\n\nvoid psb_gem_mm_fini(struct drm_device *dev)\n{\n\tstruct drm_psb_private *dev_priv = to_drm_psb_private(dev);\n\n\tiounmap(dev_priv->vram_addr);\n\n\tmutex_destroy(&dev_priv->mmap_mutex);\n}\n\n \nstatic void psb_gem_mm_populate_resources(struct drm_psb_private *pdev)\n{\n\tunsigned int restored = 0, total = 0, size = 0;\n\tstruct resource *r = pdev->gtt_mem->child;\n\tstruct drm_device *dev = &pdev->dev;\n\tstruct psb_gem_object *pobj;\n\n\twhile (r) {\n\t\t \n\t\tpobj = container_of(r, struct psb_gem_object, resource);\n\t\tif (pobj->pages) {\n\t\t\tpsb_gtt_insert_pages(pdev, &pobj->resource, pobj->pages);\n\t\t\tsize += resource_size(&pobj->resource);\n\t\t\t++restored;\n\t\t}\n\t\tr = r->sibling;\n\t\t++total;\n\t}\n\n\tdrm_dbg(dev, \"Restored %u of %u gtt ranges (%u KB)\", restored, total, (size / 1024));\n}\n\nint psb_gem_mm_resume(struct drm_device *dev)\n{\n\tstruct drm_psb_private *dev_priv = to_drm_psb_private(dev);\n\tstruct pci_dev *pdev = to_pci_dev(dev->dev);\n\tunsigned long stolen_size, vram_stolen_size;\n\tstruct psb_gtt *pg;\n\n\tpg = &dev_priv->gtt;\n\n\tpci_read_config_dword(pdev, PSB_BSM, &dev_priv->stolen_base);\n\tvram_stolen_size = pg->gtt_phys_start - dev_priv->stolen_base - PAGE_SIZE;\n\n\tstolen_size = vram_stolen_size;\n\n\tdev_dbg(dev->dev, \"Stolen memory base 0x%x, size %luK\\n\", dev_priv->stolen_base,\n\t\tvram_stolen_size / 1024);\n\n\tif (stolen_size != pg->stolen_size) {\n\t\tdev_err(dev->dev, \"GTT resume error.\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tpsb_gem_mm_populate_stolen(dev_priv);\n\tpsb_gem_mm_populate_resources(dev_priv);\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}