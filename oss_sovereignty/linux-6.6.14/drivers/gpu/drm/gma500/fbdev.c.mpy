{
  "module_name": "fbdev.c",
  "hash_id": "a3be102ae696ec9d5610f2a482d5a9f6f53b779e467a6dd0f8716b9c3814ab77",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/gma500/fbdev.c",
  "human_readable_source": "\n \n\n#include <linux/fb.h>\n#include <linux/pfn_t.h>\n\n#include <drm/drm_crtc_helper.h>\n#include <drm/drm_drv.h>\n#include <drm/drm_fb_helper.h>\n#include <drm/drm_framebuffer.h>\n\n#include \"gem.h\"\n#include \"psb_drv.h\"\n\n \n\nstatic vm_fault_t psb_fbdev_vm_fault(struct vm_fault *vmf)\n{\n\tstruct vm_area_struct *vma = vmf->vma;\n\tstruct fb_info *info = vma->vm_private_data;\n\tunsigned long address = vmf->address - (vmf->pgoff << PAGE_SHIFT);\n\tunsigned long pfn = info->fix.smem_start >> PAGE_SHIFT;\n\tvm_fault_t err = VM_FAULT_SIGBUS;\n\tunsigned long page_num = vma_pages(vma);\n\tunsigned long i;\n\n\tvma->vm_page_prot = pgprot_noncached(vma->vm_page_prot);\n\n\tfor (i = 0; i < page_num; ++i) {\n\t\terr = vmf_insert_mixed(vma, address, __pfn_to_pfn_t(pfn, PFN_DEV));\n\t\tif (unlikely(err & VM_FAULT_ERROR))\n\t\t\tbreak;\n\t\taddress += PAGE_SIZE;\n\t\t++pfn;\n\t}\n\n\treturn err;\n}\n\nstatic const struct vm_operations_struct psb_fbdev_vm_ops = {\n\t.fault\t= psb_fbdev_vm_fault,\n};\n\n \n\n#define CMAP_TOHW(_val, _width) ((((_val) << (_width)) + 0x7FFF - (_val)) >> 16)\n\nstatic int psb_fbdev_fb_setcolreg(unsigned int regno,\n\t\t\t\t  unsigned int red, unsigned int green,\n\t\t\t\t  unsigned int blue, unsigned int transp,\n\t\t\t\t  struct fb_info *info)\n{\n\tstruct drm_fb_helper *fb_helper = info->par;\n\tstruct drm_framebuffer *fb = fb_helper->fb;\n\tuint32_t v;\n\n\tif (!fb)\n\t\treturn -ENOMEM;\n\n\tif (regno > 255)\n\t\treturn 1;\n\n\tred = CMAP_TOHW(red, info->var.red.length);\n\tblue = CMAP_TOHW(blue, info->var.blue.length);\n\tgreen = CMAP_TOHW(green, info->var.green.length);\n\ttransp = CMAP_TOHW(transp, info->var.transp.length);\n\n\tv = (red << info->var.red.offset) |\n\t    (green << info->var.green.offset) |\n\t    (blue << info->var.blue.offset) |\n\t    (transp << info->var.transp.offset);\n\n\tif (regno < 16) {\n\t\tswitch (fb->format->cpp[0] * 8) {\n\t\tcase 16:\n\t\t\t((uint32_t *) info->pseudo_palette)[regno] = v;\n\t\t\tbreak;\n\t\tcase 24:\n\t\tcase 32:\n\t\t\t((uint32_t *) info->pseudo_palette)[regno] = v;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int psb_fbdev_fb_mmap(struct fb_info *info, struct vm_area_struct *vma)\n{\n\tif (vma->vm_pgoff != 0)\n\t\treturn -EINVAL;\n\tif (vma->vm_pgoff > (~0UL >> PAGE_SHIFT))\n\t\treturn -EINVAL;\n\n\t \n\tvma->vm_ops = &psb_fbdev_vm_ops;\n\tvma->vm_private_data = info;\n\tvm_flags_set(vma, VM_IO | VM_MIXEDMAP | VM_DONTEXPAND | VM_DONTDUMP);\n\n\treturn 0;\n}\n\nstatic void psb_fbdev_fb_destroy(struct fb_info *info)\n{\n\tstruct drm_fb_helper *fb_helper = info->par;\n\tstruct drm_framebuffer *fb = fb_helper->fb;\n\tstruct drm_gem_object *obj = fb->obj[0];\n\n\tdrm_fb_helper_fini(fb_helper);\n\n\tdrm_framebuffer_unregister_private(fb);\n\tfb->obj[0] = NULL;\n\tdrm_framebuffer_cleanup(fb);\n\tkfree(fb);\n\n\tdrm_gem_object_put(obj);\n\n\tdrm_client_release(&fb_helper->client);\n\n\tdrm_fb_helper_unprepare(fb_helper);\n\tkfree(fb_helper);\n}\n\nstatic const struct fb_ops psb_fbdev_fb_ops = {\n\t.owner = THIS_MODULE,\n\t__FB_DEFAULT_IOMEM_OPS_RDWR,\n\tDRM_FB_HELPER_DEFAULT_OPS,\n\t.fb_setcolreg = psb_fbdev_fb_setcolreg,\n\t__FB_DEFAULT_IOMEM_OPS_DRAW,\n\t.fb_mmap = psb_fbdev_fb_mmap,\n\t.fb_destroy = psb_fbdev_fb_destroy,\n};\n\n \n\nstatic int psb_fbdev_fb_probe(struct drm_fb_helper *fb_helper,\n\t\t\t      struct drm_fb_helper_surface_size *sizes)\n{\n\tstruct drm_device *dev = fb_helper->dev;\n\tstruct drm_psb_private *dev_priv = to_drm_psb_private(dev);\n\tstruct pci_dev *pdev = to_pci_dev(dev->dev);\n\tstruct fb_info *info;\n\tstruct drm_framebuffer *fb;\n\tstruct drm_mode_fb_cmd2 mode_cmd = { };\n\tint size;\n\tint ret;\n\tstruct psb_gem_object *backing;\n\tstruct drm_gem_object *obj;\n\tu32 bpp, depth;\n\n\t \n\tif (sizes->surface_bpp == 24) {\n\t\tsizes->surface_bpp = 32;\n\t\tsizes->surface_depth = 24;\n\t}\n\tbpp = sizes->surface_bpp;\n\tdepth = sizes->surface_depth;\n\n\t \n\tsize = ALIGN(sizes->surface_width * DIV_ROUND_UP(bpp, 8), 64) *\n\t\t     sizes->surface_height;\n\tsize = ALIGN(size, PAGE_SIZE);\n\n\tif (size > dev_priv->vram_stolen_size) {\n\t\tsizes->surface_bpp = 16;\n\t\tsizes->surface_depth = 16;\n\t}\n\tbpp = sizes->surface_bpp;\n\tdepth = sizes->surface_depth;\n\n\tmode_cmd.width = sizes->surface_width;\n\tmode_cmd.height = sizes->surface_height;\n\tmode_cmd.pitches[0] = ALIGN(mode_cmd.width * DIV_ROUND_UP(bpp, 8), 64);\n\tmode_cmd.pixel_format = drm_mode_legacy_fb_format(bpp, depth);\n\n\tsize = mode_cmd.pitches[0] * mode_cmd.height;\n\tsize = ALIGN(size, PAGE_SIZE);\n\n\t \n\tbacking = psb_gem_create(dev, size, \"fb\", true, PAGE_SIZE);\n\tif (IS_ERR(backing))\n\t\treturn PTR_ERR(backing);\n\tobj = &backing->base;\n\n\tfb = psb_framebuffer_create(dev, &mode_cmd, obj);\n\tif (IS_ERR(fb)) {\n\t\tret = PTR_ERR(fb);\n\t\tgoto err_drm_gem_object_put;\n\t}\n\n\tfb_helper->fb = fb;\n\n\tinfo = drm_fb_helper_alloc_info(fb_helper);\n\tif (IS_ERR(info)) {\n\t\tret = PTR_ERR(info);\n\t\tgoto err_drm_framebuffer_unregister_private;\n\t}\n\n\tinfo->fbops = &psb_fbdev_fb_ops;\n\n\t \n\tinfo->screen_base = dev_priv->vram_addr + backing->offset;\n\tinfo->screen_size = size;\n\n\tdrm_fb_helper_fill_info(info, fb_helper, sizes);\n\n\tinfo->fix.smem_start = dev_priv->stolen_base + backing->offset;\n\tinfo->fix.smem_len = size;\n\tinfo->fix.ywrapstep = 0;\n\tinfo->fix.ypanstep = 0;\n\tinfo->fix.mmio_start = pci_resource_start(pdev, 0);\n\tinfo->fix.mmio_len = pci_resource_len(pdev, 0);\n\n\tfb_memset_io(info->screen_base, 0, info->screen_size);\n\n\t \n\n\tdev_dbg(dev->dev, \"allocated %dx%d fb\\n\", fb->width, fb->height);\n\n\treturn 0;\n\nerr_drm_framebuffer_unregister_private:\n\tdrm_framebuffer_unregister_private(fb);\n\tfb->obj[0] = NULL;\n\tdrm_framebuffer_cleanup(fb);\n\tkfree(fb);\nerr_drm_gem_object_put:\n\tdrm_gem_object_put(obj);\n\treturn ret;\n}\n\nstatic const struct drm_fb_helper_funcs psb_fbdev_fb_helper_funcs = {\n\t.fb_probe = psb_fbdev_fb_probe,\n};\n\n \n\nstatic void psb_fbdev_client_unregister(struct drm_client_dev *client)\n{\n\tstruct drm_fb_helper *fb_helper = drm_fb_helper_from_client(client);\n\n\tif (fb_helper->info) {\n\t\tdrm_fb_helper_unregister_info(fb_helper);\n\t} else {\n\t\tdrm_fb_helper_unprepare(fb_helper);\n\t\tdrm_client_release(&fb_helper->client);\n\t\tkfree(fb_helper);\n\t}\n}\n\nstatic int psb_fbdev_client_restore(struct drm_client_dev *client)\n{\n\tdrm_fb_helper_lastclose(client->dev);\n\n\treturn 0;\n}\n\nstatic int psb_fbdev_client_hotplug(struct drm_client_dev *client)\n{\n\tstruct drm_fb_helper *fb_helper = drm_fb_helper_from_client(client);\n\tstruct drm_device *dev = client->dev;\n\tint ret;\n\n\tif (dev->fb_helper)\n\t\treturn drm_fb_helper_hotplug_event(dev->fb_helper);\n\n\tret = drm_fb_helper_init(dev, fb_helper);\n\tif (ret)\n\t\tgoto err_drm_err;\n\n\tif (!drm_drv_uses_atomic_modeset(dev))\n\t\tdrm_helper_disable_unused_functions(dev);\n\n\tret = drm_fb_helper_initial_config(fb_helper);\n\tif (ret)\n\t\tgoto err_drm_fb_helper_fini;\n\n\treturn 0;\n\nerr_drm_fb_helper_fini:\n\tdrm_fb_helper_fini(fb_helper);\nerr_drm_err:\n\tdrm_err(dev, \"Failed to setup gma500 fbdev emulation (ret=%d)\\n\", ret);\n\treturn ret;\n}\n\nstatic const struct drm_client_funcs psb_fbdev_client_funcs = {\n\t.owner\t\t= THIS_MODULE,\n\t.unregister\t= psb_fbdev_client_unregister,\n\t.restore\t= psb_fbdev_client_restore,\n\t.hotplug\t= psb_fbdev_client_hotplug,\n};\n\nvoid psb_fbdev_setup(struct drm_psb_private *dev_priv)\n{\n\tstruct drm_device *dev = &dev_priv->dev;\n\tstruct drm_fb_helper *fb_helper;\n\tint ret;\n\n\tfb_helper = kzalloc(sizeof(*fb_helper), GFP_KERNEL);\n\tif (!fb_helper)\n\t\treturn;\n\tdrm_fb_helper_prepare(dev, fb_helper, 32, &psb_fbdev_fb_helper_funcs);\n\n\tret = drm_client_init(dev, &fb_helper->client, \"fbdev-gma500\", &psb_fbdev_client_funcs);\n\tif (ret) {\n\t\tdrm_err(dev, \"Failed to register client: %d\\n\", ret);\n\t\tgoto err_drm_fb_helper_unprepare;\n\t}\n\n\tdrm_client_register(&fb_helper->client);\n\n\treturn;\n\nerr_drm_fb_helper_unprepare:\n\tdrm_fb_helper_unprepare(fb_helper);\n\tkfree(fb_helper);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}