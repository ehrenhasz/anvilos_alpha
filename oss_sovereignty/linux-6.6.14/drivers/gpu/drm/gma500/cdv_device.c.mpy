{
  "module_name": "cdv_device.c",
  "hash_id": "6c038413681935859c1859ae7c4cb2591247dbab2f3ebbe27b3683d7adf6230f",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/gma500/cdv_device.c",
  "human_readable_source": "\n \n\n#include <linux/delay.h>\n\n#include <drm/drm.h>\n#include <drm/drm_crtc_helper.h>\n\n#include \"cdv_device.h\"\n#include \"gma_device.h\"\n#include \"intel_bios.h\"\n#include \"psb_drv.h\"\n#include \"psb_intel_reg.h\"\n#include \"psb_reg.h\"\n\n#define VGA_SR_INDEX\t\t0x3c4\n#define VGA_SR_DATA\t\t0x3c5\n\nstatic void cdv_disable_vga(struct drm_device *dev)\n{\n\tu8 sr1;\n\tu32 vga_reg;\n\n\tvga_reg = VGACNTRL;\n\n\toutb(1, VGA_SR_INDEX);\n\tsr1 = inb(VGA_SR_DATA);\n\toutb(sr1 | 1<<5, VGA_SR_DATA);\n\tudelay(300);\n\n\tREG_WRITE(vga_reg, VGA_DISP_DISABLE);\n\tREG_READ(vga_reg);\n}\n\nstatic int cdv_output_init(struct drm_device *dev)\n{\n\tstruct drm_psb_private *dev_priv = to_drm_psb_private(dev);\n\n\tdrm_mode_create_scaling_mode_property(dev);\n\n\tcdv_disable_vga(dev);\n\n\tcdv_intel_crt_init(dev, &dev_priv->mode_dev);\n\tcdv_intel_lvds_init(dev, &dev_priv->mode_dev);\n\n\t \n\tif (REG_READ(SDVOB) & SDVO_DETECTED) {\n\t\tcdv_hdmi_init(dev, &dev_priv->mode_dev, SDVOB);\n\t\tif (REG_READ(DP_B) & DP_DETECTED)\n\t\t\tcdv_intel_dp_init(dev, &dev_priv->mode_dev, DP_B);\n\t}\n\n\tif (REG_READ(SDVOC) & SDVO_DETECTED) {\n\t\tcdv_hdmi_init(dev, &dev_priv->mode_dev, SDVOC);\n\t\tif (REG_READ(DP_C) & DP_DETECTED)\n\t\t\tcdv_intel_dp_init(dev, &dev_priv->mode_dev, DP_C);\n\t}\n\treturn 0;\n}\n\n \n\nstatic int cdv_backlight_combination_mode(struct drm_device *dev)\n{\n\treturn REG_READ(BLC_PWM_CTL2) & PWM_LEGACY_MODE;\n}\n\nstatic u32 cdv_get_max_backlight(struct drm_device *dev)\n{\n\tu32 max = REG_READ(BLC_PWM_CTL);\n\n\tif (max == 0) {\n\t\tDRM_DEBUG_KMS(\"LVDS Panel PWM value is 0!\\n\");\n\t\t \n\t\treturn 1;\n\t}\n\n\tmax >>= 16;\n\tif (cdv_backlight_combination_mode(dev))\n\t\tmax *= 0xff;\n\treturn max;\n}\n\nstatic int cdv_get_brightness(struct drm_device *dev)\n{\n\tstruct pci_dev *pdev = to_pci_dev(dev->dev);\n\tu32 val = REG_READ(BLC_PWM_CTL) & BACKLIGHT_DUTY_CYCLE_MASK;\n\n\tif (cdv_backlight_combination_mode(dev)) {\n\t\tu8 lbpc;\n\n\t\tval &= ~1;\n\t\tpci_read_config_byte(pdev, 0xF4, &lbpc);\n\t\tval *= lbpc;\n\t}\n\treturn (val * 100)/cdv_get_max_backlight(dev);\n}\n\nstatic void cdv_set_brightness(struct drm_device *dev, int level)\n{\n\tstruct pci_dev *pdev = to_pci_dev(dev->dev);\n\tu32 blc_pwm_ctl;\n\n\tlevel *= cdv_get_max_backlight(dev);\n\tlevel /= 100;\n\n\tif (cdv_backlight_combination_mode(dev)) {\n\t\tu32 max = cdv_get_max_backlight(dev);\n\t\tu8 lbpc;\n\n\t\tlbpc = level * 0xfe / max + 1;\n\t\tlevel /= lbpc;\n\n\t\tpci_write_config_byte(pdev, 0xF4, lbpc);\n\t}\n\n\tblc_pwm_ctl = REG_READ(BLC_PWM_CTL) & ~BACKLIGHT_DUTY_CYCLE_MASK;\n\tREG_WRITE(BLC_PWM_CTL, (blc_pwm_ctl |\n\t\t\t\t(level << BACKLIGHT_DUTY_CYCLE_SHIFT)));\n}\n\nstatic int cdv_backlight_init(struct drm_device *dev)\n{\n\tstruct drm_psb_private *dev_priv = to_drm_psb_private(dev);\n\n\tdev_priv->backlight_level = cdv_get_brightness(dev);\n\tcdv_set_brightness(dev, dev_priv->backlight_level);\n\n\treturn 0;\n}\n\n \n\nstatic inline u32 CDV_MSG_READ32(int domain, uint port, uint offset)\n{\n\tint mcr = (0x10<<24) | (port << 16) | (offset << 8);\n\tuint32_t ret_val = 0;\n\tstruct pci_dev *pci_root = pci_get_domain_bus_and_slot(domain, 0, 0);\n\tpci_write_config_dword(pci_root, 0xD0, mcr);\n\tpci_read_config_dword(pci_root, 0xD4, &ret_val);\n\tpci_dev_put(pci_root);\n\treturn ret_val;\n}\n\nstatic inline void CDV_MSG_WRITE32(int domain, uint port, uint offset,\n\t\t\t\t   u32 value)\n{\n\tint mcr = (0x11<<24) | (port << 16) | (offset << 8) | 0xF0;\n\tstruct pci_dev *pci_root = pci_get_domain_bus_and_slot(domain, 0, 0);\n\tpci_write_config_dword(pci_root, 0xD4, value);\n\tpci_write_config_dword(pci_root, 0xD0, mcr);\n\tpci_dev_put(pci_root);\n}\n\n#define PSB_PM_SSC\t\t\t0x20\n#define PSB_PM_SSS\t\t\t0x30\n#define PSB_PWRGT_GFX_ON\t\t0x02\n#define PSB_PWRGT_GFX_OFF\t\t0x01\n#define PSB_PWRGT_GFX_D0\t\t0x00\n#define PSB_PWRGT_GFX_D3\t\t0x03\n\nstatic void cdv_init_pm(struct drm_device *dev)\n{\n\tstruct drm_psb_private *dev_priv = to_drm_psb_private(dev);\n\tstruct pci_dev *pdev = to_pci_dev(dev->dev);\n\tu32 pwr_cnt;\n\tint domain = pci_domain_nr(pdev->bus);\n\tint i;\n\n\tdev_priv->apm_base = CDV_MSG_READ32(domain, PSB_PUNIT_PORT,\n\t\t\t\t\t\t\tPSB_APMBA) & 0xFFFF;\n\tdev_priv->ospm_base = CDV_MSG_READ32(domain, PSB_PUNIT_PORT,\n\t\t\t\t\t\t\tPSB_OSPMBA) & 0xFFFF;\n\n\t \n\tpwr_cnt = inl(dev_priv->apm_base + PSB_APM_CMD);\n\n\t \n\tpwr_cnt &= ~PSB_PWRGT_GFX_MASK;\n\tpwr_cnt |= PSB_PWRGT_GFX_ON;\n\toutl(pwr_cnt, dev_priv->apm_base + PSB_APM_CMD);\n\n\t \n\tfor (i = 0; i < 5; i++) {\n\t\tu32 pwr_sts = inl(dev_priv->apm_base + PSB_APM_STS);\n\t\tif ((pwr_sts & PSB_PWRGT_GFX_MASK) == 0)\n\t\t\treturn;\n\t\tudelay(10);\n\t}\n\tdev_err(dev->dev, \"GPU: power management timed out.\\n\");\n}\n\nstatic void cdv_errata(struct drm_device *dev)\n{\n\tstruct pci_dev *pdev = to_pci_dev(dev->dev);\n\n\t \n\t CDV_MSG_WRITE32(pci_domain_nr(pdev->bus), 3, 0x30, 0x08027108);\n}\n\n \nstatic int cdv_save_display_registers(struct drm_device *dev)\n{\n\tstruct drm_psb_private *dev_priv = to_drm_psb_private(dev);\n\tstruct pci_dev *pdev = to_pci_dev(dev->dev);\n\tstruct psb_save_area *regs = &dev_priv->regs;\n\tstruct drm_connector_list_iter conn_iter;\n\tstruct drm_connector *connector;\n\n\tdev_dbg(dev->dev, \"Saving GPU registers.\\n\");\n\n\tpci_read_config_byte(pdev, 0xF4, &regs->cdv.saveLBB);\n\n\tregs->cdv.saveDSPCLK_GATE_D = REG_READ(DSPCLK_GATE_D);\n\tregs->cdv.saveRAMCLK_GATE_D = REG_READ(RAMCLK_GATE_D);\n\n\tregs->cdv.saveDSPARB = REG_READ(DSPARB);\n\tregs->cdv.saveDSPFW[0] = REG_READ(DSPFW1);\n\tregs->cdv.saveDSPFW[1] = REG_READ(DSPFW2);\n\tregs->cdv.saveDSPFW[2] = REG_READ(DSPFW3);\n\tregs->cdv.saveDSPFW[3] = REG_READ(DSPFW4);\n\tregs->cdv.saveDSPFW[4] = REG_READ(DSPFW5);\n\tregs->cdv.saveDSPFW[5] = REG_READ(DSPFW6);\n\n\tregs->cdv.saveADPA = REG_READ(ADPA);\n\n\tregs->cdv.savePP_CONTROL = REG_READ(PP_CONTROL);\n\tregs->cdv.savePFIT_PGM_RATIOS = REG_READ(PFIT_PGM_RATIOS);\n\tregs->saveBLC_PWM_CTL = REG_READ(BLC_PWM_CTL);\n\tregs->saveBLC_PWM_CTL2 = REG_READ(BLC_PWM_CTL2);\n\tregs->cdv.saveLVDS = REG_READ(LVDS);\n\n\tregs->cdv.savePFIT_CONTROL = REG_READ(PFIT_CONTROL);\n\n\tregs->cdv.savePP_ON_DELAYS = REG_READ(PP_ON_DELAYS);\n\tregs->cdv.savePP_OFF_DELAYS = REG_READ(PP_OFF_DELAYS);\n\tregs->cdv.savePP_CYCLE = REG_READ(PP_CYCLE);\n\n\tregs->cdv.saveVGACNTRL = REG_READ(VGACNTRL);\n\n\tregs->cdv.saveIER = REG_READ(PSB_INT_ENABLE_R);\n\tregs->cdv.saveIMR = REG_READ(PSB_INT_MASK_R);\n\n\tdrm_connector_list_iter_begin(dev, &conn_iter);\n\tdrm_for_each_connector_iter(connector, &conn_iter)\n\t\tconnector->funcs->dpms(connector, DRM_MODE_DPMS_OFF);\n\tdrm_connector_list_iter_end(&conn_iter);\n\n\treturn 0;\n}\n\n \nstatic int cdv_restore_display_registers(struct drm_device *dev)\n{\n\tstruct drm_psb_private *dev_priv = to_drm_psb_private(dev);\n\tstruct pci_dev *pdev = to_pci_dev(dev->dev);\n\tstruct psb_save_area *regs = &dev_priv->regs;\n\tstruct drm_connector_list_iter conn_iter;\n\tstruct drm_connector *connector;\n\tu32 temp;\n\n\tpci_write_config_byte(pdev, 0xF4, regs->cdv.saveLBB);\n\n\tREG_WRITE(DSPCLK_GATE_D, regs->cdv.saveDSPCLK_GATE_D);\n\tREG_WRITE(RAMCLK_GATE_D, regs->cdv.saveRAMCLK_GATE_D);\n\n\t \n\tREG_WRITE(DPIO_CFG, 0);\n\tREG_WRITE(DPIO_CFG, DPIO_MODE_SELECT_0 | DPIO_CMN_RESET_N);\n\n\ttemp = REG_READ(DPLL_A);\n\tif ((temp & DPLL_SYNCLOCK_ENABLE) == 0) {\n\t\tREG_WRITE(DPLL_A, temp | DPLL_SYNCLOCK_ENABLE);\n\t\tREG_READ(DPLL_A);\n\t}\n\n\ttemp = REG_READ(DPLL_B);\n\tif ((temp & DPLL_SYNCLOCK_ENABLE) == 0) {\n\t\tREG_WRITE(DPLL_B, temp | DPLL_SYNCLOCK_ENABLE);\n\t\tREG_READ(DPLL_B);\n\t}\n\n\tudelay(500);\n\n\tREG_WRITE(DSPFW1, regs->cdv.saveDSPFW[0]);\n\tREG_WRITE(DSPFW2, regs->cdv.saveDSPFW[1]);\n\tREG_WRITE(DSPFW3, regs->cdv.saveDSPFW[2]);\n\tREG_WRITE(DSPFW4, regs->cdv.saveDSPFW[3]);\n\tREG_WRITE(DSPFW5, regs->cdv.saveDSPFW[4]);\n\tREG_WRITE(DSPFW6, regs->cdv.saveDSPFW[5]);\n\n\tREG_WRITE(DSPARB, regs->cdv.saveDSPARB);\n\tREG_WRITE(ADPA, regs->cdv.saveADPA);\n\n\tREG_WRITE(BLC_PWM_CTL2, regs->saveBLC_PWM_CTL2);\n\tREG_WRITE(LVDS, regs->cdv.saveLVDS);\n\tREG_WRITE(PFIT_CONTROL, regs->cdv.savePFIT_CONTROL);\n\tREG_WRITE(PFIT_PGM_RATIOS, regs->cdv.savePFIT_PGM_RATIOS);\n\tREG_WRITE(BLC_PWM_CTL, regs->saveBLC_PWM_CTL);\n\tREG_WRITE(PP_ON_DELAYS, regs->cdv.savePP_ON_DELAYS);\n\tREG_WRITE(PP_OFF_DELAYS, regs->cdv.savePP_OFF_DELAYS);\n\tREG_WRITE(PP_CYCLE, regs->cdv.savePP_CYCLE);\n\tREG_WRITE(PP_CONTROL, regs->cdv.savePP_CONTROL);\n\n\tREG_WRITE(VGACNTRL, regs->cdv.saveVGACNTRL);\n\n\tREG_WRITE(PSB_INT_ENABLE_R, regs->cdv.saveIER);\n\tREG_WRITE(PSB_INT_MASK_R, regs->cdv.saveIMR);\n\n\t \n\tcdv_errata(dev);\n\n\tdrm_mode_config_reset(dev);\n\n\tdrm_connector_list_iter_begin(dev, &conn_iter);\n\tdrm_for_each_connector_iter(connector, &conn_iter)\n\t\tconnector->funcs->dpms(connector, DRM_MODE_DPMS_ON);\n\tdrm_connector_list_iter_end(&conn_iter);\n\n\t \n\tdrm_helper_resume_force_mode(dev);\n\treturn 0;\n}\n\nstatic int cdv_power_down(struct drm_device *dev)\n{\n\tstruct drm_psb_private *dev_priv = to_drm_psb_private(dev);\n\tu32 pwr_cnt, pwr_mask, pwr_sts;\n\tint tries = 5;\n\n\tpwr_cnt = inl(dev_priv->apm_base + PSB_APM_CMD);\n\tpwr_cnt &= ~PSB_PWRGT_GFX_MASK;\n\tpwr_cnt |= PSB_PWRGT_GFX_OFF;\n\tpwr_mask = PSB_PWRGT_GFX_MASK;\n\n\toutl(pwr_cnt, dev_priv->apm_base + PSB_APM_CMD);\n\n\twhile (tries--) {\n\t\tpwr_sts = inl(dev_priv->apm_base + PSB_APM_STS);\n\t\tif ((pwr_sts & pwr_mask) == PSB_PWRGT_GFX_D3)\n\t\t\treturn 0;\n\t\tudelay(10);\n\t}\n\treturn 0;\n}\n\nstatic int cdv_power_up(struct drm_device *dev)\n{\n\tstruct drm_psb_private *dev_priv = to_drm_psb_private(dev);\n\tu32 pwr_cnt, pwr_mask, pwr_sts;\n\tint tries = 5;\n\n\tpwr_cnt = inl(dev_priv->apm_base + PSB_APM_CMD);\n\tpwr_cnt &= ~PSB_PWRGT_GFX_MASK;\n\tpwr_cnt |= PSB_PWRGT_GFX_ON;\n\tpwr_mask = PSB_PWRGT_GFX_MASK;\n\n\toutl(pwr_cnt, dev_priv->apm_base + PSB_APM_CMD);\n\n\twhile (tries--) {\n\t\tpwr_sts = inl(dev_priv->apm_base + PSB_APM_STS);\n\t\tif ((pwr_sts & pwr_mask) == PSB_PWRGT_GFX_D0)\n\t\t\treturn 0;\n\t\tudelay(10);\n\t}\n\treturn 0;\n}\n\nstatic void cdv_hotplug_work_func(struct work_struct *work)\n{\n        struct drm_psb_private *dev_priv = container_of(work, struct drm_psb_private,\n\t\t\t\t\t\t\thotplug_work);\n\tstruct drm_device *dev = &dev_priv->dev;\n\n         \n        drm_helper_hpd_irq_event(dev);\n}\n\n \n\nstatic int cdv_hotplug_event(struct drm_device *dev)\n{\n\tstruct drm_psb_private *dev_priv = to_drm_psb_private(dev);\n\tschedule_work(&dev_priv->hotplug_work);\n\tREG_WRITE(PORT_HOTPLUG_STAT, REG_READ(PORT_HOTPLUG_STAT));\n\treturn 1;\n}\n\nstatic void cdv_hotplug_enable(struct drm_device *dev, bool on)\n{\n\tif (on) {\n\t\tu32 hotplug = REG_READ(PORT_HOTPLUG_EN);\n\t\thotplug |= HDMIB_HOTPLUG_INT_EN | HDMIC_HOTPLUG_INT_EN |\n\t\t\t   HDMID_HOTPLUG_INT_EN | CRT_HOTPLUG_INT_EN;\n\t\tREG_WRITE(PORT_HOTPLUG_EN, hotplug);\n\t}  else {\n\t\tREG_WRITE(PORT_HOTPLUG_EN, 0);\n\t\tREG_WRITE(PORT_HOTPLUG_STAT, REG_READ(PORT_HOTPLUG_STAT));\n\t}\n}\n\nstatic const char *force_audio_names[] = {\n\t\"off\",\n\t\"auto\",\n\t\"on\",\n};\n\nvoid cdv_intel_attach_force_audio_property(struct drm_connector *connector)\n{\n\tstruct drm_device *dev = connector->dev;\n\tstruct drm_psb_private *dev_priv = to_drm_psb_private(dev);\n\tstruct drm_property *prop;\n\tint i;\n\n\tprop = dev_priv->force_audio_property;\n\tif (prop == NULL) {\n\t\tprop = drm_property_create(dev, DRM_MODE_PROP_ENUM,\n\t\t\t\t\t   \"audio\",\n\t\t\t\t\t   ARRAY_SIZE(force_audio_names));\n\t\tif (prop == NULL)\n\t\t\treturn;\n\n\t\tfor (i = 0; i < ARRAY_SIZE(force_audio_names); i++)\n\t\t\tdrm_property_add_enum(prop, i-1, force_audio_names[i]);\n\n\t\tdev_priv->force_audio_property = prop;\n\t}\n\tdrm_object_attach_property(&connector->base, prop, 0);\n}\n\n\nstatic const char *broadcast_rgb_names[] = {\n\t\"Full\",\n\t\"Limited 16:235\",\n};\n\nvoid cdv_intel_attach_broadcast_rgb_property(struct drm_connector *connector)\n{\n\tstruct drm_device *dev = connector->dev;\n\tstruct drm_psb_private *dev_priv = to_drm_psb_private(dev);\n\tstruct drm_property *prop;\n\tint i;\n\n\tprop = dev_priv->broadcast_rgb_property;\n\tif (prop == NULL) {\n\t\tprop = drm_property_create(dev, DRM_MODE_PROP_ENUM,\n\t\t\t\t\t   \"Broadcast RGB\",\n\t\t\t\t\t   ARRAY_SIZE(broadcast_rgb_names));\n\t\tif (prop == NULL)\n\t\t\treturn;\n\n\t\tfor (i = 0; i < ARRAY_SIZE(broadcast_rgb_names); i++)\n\t\t\tdrm_property_add_enum(prop, i, broadcast_rgb_names[i]);\n\n\t\tdev_priv->broadcast_rgb_property = prop;\n\t}\n\n\tdrm_object_attach_property(&connector->base, prop, 0);\n}\n\n \nstatic const struct psb_offset cdv_regmap[2] = {\n\t{\n\t\t.fp0 = FPA0,\n\t\t.fp1 = FPA1,\n\t\t.cntr = DSPACNTR,\n\t\t.conf = PIPEACONF,\n\t\t.src = PIPEASRC,\n\t\t.dpll = DPLL_A,\n\t\t.dpll_md = DPLL_A_MD,\n\t\t.htotal = HTOTAL_A,\n\t\t.hblank = HBLANK_A,\n\t\t.hsync = HSYNC_A,\n\t\t.vtotal = VTOTAL_A,\n\t\t.vblank = VBLANK_A,\n\t\t.vsync = VSYNC_A,\n\t\t.stride = DSPASTRIDE,\n\t\t.size = DSPASIZE,\n\t\t.pos = DSPAPOS,\n\t\t.base = DSPABASE,\n\t\t.surf = DSPASURF,\n\t\t.addr = DSPABASE,\n\t\t.status = PIPEASTAT,\n\t\t.linoff = DSPALINOFF,\n\t\t.tileoff = DSPATILEOFF,\n\t\t.palette = PALETTE_A,\n\t},\n\t{\n\t\t.fp0 = FPB0,\n\t\t.fp1 = FPB1,\n\t\t.cntr = DSPBCNTR,\n\t\t.conf = PIPEBCONF,\n\t\t.src = PIPEBSRC,\n\t\t.dpll = DPLL_B,\n\t\t.dpll_md = DPLL_B_MD,\n\t\t.htotal = HTOTAL_B,\n\t\t.hblank = HBLANK_B,\n\t\t.hsync = HSYNC_B,\n\t\t.vtotal = VTOTAL_B,\n\t\t.vblank = VBLANK_B,\n\t\t.vsync = VSYNC_B,\n\t\t.stride = DSPBSTRIDE,\n\t\t.size = DSPBSIZE,\n\t\t.pos = DSPBPOS,\n\t\t.base = DSPBBASE,\n\t\t.surf = DSPBSURF,\n\t\t.addr = DSPBBASE,\n\t\t.status = PIPEBSTAT,\n\t\t.linoff = DSPBLINOFF,\n\t\t.tileoff = DSPBTILEOFF,\n\t\t.palette = PALETTE_B,\n\t}\n};\n\nstatic int cdv_chip_setup(struct drm_device *dev)\n{\n\tstruct drm_psb_private *dev_priv = to_drm_psb_private(dev);\n\tINIT_WORK(&dev_priv->hotplug_work, cdv_hotplug_work_func);\n\n\tdev_priv->use_msi = true;\n\tdev_priv->regmap = cdv_regmap;\n\tgma_get_core_freq(dev);\n\tpsb_intel_opregion_init(dev);\n\tpsb_intel_init_bios(dev);\n\tcdv_hotplug_enable(dev, false);\n\treturn 0;\n}\n\n \n\nconst struct psb_ops cdv_chip_ops = {\n\t.name = \"GMA3600/3650\",\n\t.pipes = 2,\n\t.crtcs = 2,\n\t.hdmi_mask = (1 << 0) | (1 << 1),\n\t.lvds_mask = (1 << 1),\n\t.sdvo_mask = (1 << 0),\n\t.cursor_needs_phys = 0,\n\t.sgx_offset = MRST_SGX_OFFSET,\n\t.chip_setup = cdv_chip_setup,\n\t.errata = cdv_errata,\n\n\t.crtc_helper = &cdv_intel_helper_funcs,\n\t.clock_funcs = &cdv_clock_funcs,\n\n\t.output_init = cdv_output_init,\n\t.hotplug = cdv_hotplug_event,\n\t.hotplug_enable = cdv_hotplug_enable,\n\n\t.backlight_init = cdv_backlight_init,\n\t.backlight_get = cdv_get_brightness,\n\t.backlight_set = cdv_set_brightness,\n\t.backlight_name = \"psb-bl\",\n\n\t.init_pm = cdv_init_pm,\n\t.save_regs = cdv_save_display_registers,\n\t.restore_regs = cdv_restore_display_registers,\n\t.save_crtc = gma_crtc_save,\n\t.restore_crtc = gma_crtc_restore,\n\t.power_down = cdv_power_down,\n\t.power_up = cdv_power_up,\n\t.update_wm = cdv_update_wm,\n\t.disable_sr = cdv_disable_sr,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}