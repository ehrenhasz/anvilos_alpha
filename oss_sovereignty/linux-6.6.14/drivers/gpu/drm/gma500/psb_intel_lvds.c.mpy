{
  "module_name": "psb_intel_lvds.c",
  "hash_id": "220e78ad72ba875ab4491647779cbe8e06fca58c86949a8a6adc99a0e7fdb02a",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/gma500/psb_intel_lvds.c",
  "human_readable_source": "\n \n\n#include <linux/i2c.h>\n#include <linux/pm_runtime.h>\n\n#include <drm/drm_crtc_helper.h>\n#include <drm/drm_modeset_helper_vtables.h>\n#include <drm/drm_simple_kms_helper.h>\n\n#include \"intel_bios.h\"\n#include \"power.h\"\n#include \"psb_drv.h\"\n#include \"psb_intel_drv.h\"\n#include \"psb_intel_reg.h\"\n\n \n#define BRIGHTNESS_MAX_LEVEL 100\n#define BRIGHTNESS_MASK 0xFF\n#define BLC_I2C_TYPE\t0x01\n#define BLC_PWM_TYPT\t0x02\n\n#define BLC_POLARITY_NORMAL 0\n#define BLC_POLARITY_INVERSE 1\n\n#define PSB_BLC_MAX_PWM_REG_FREQ       (0xFFFE)\n#define PSB_BLC_MIN_PWM_REG_FREQ\t(0x2)\n#define PSB_BLC_PWM_PRECISION_FACTOR\t(10)\n#define PSB_BACKLIGHT_PWM_CTL_SHIFT\t(16)\n#define PSB_BACKLIGHT_PWM_POLARITY_BIT_CLEAR (0xFFFE)\n\nstruct psb_intel_lvds_priv {\n\t \n\tuint32_t savePP_ON;\n\tuint32_t savePP_OFF;\n\tuint32_t saveLVDS;\n\tuint32_t savePP_CONTROL;\n\tuint32_t savePP_CYCLE;\n\tuint32_t savePFIT_CONTROL;\n\tuint32_t savePFIT_PGM_RATIOS;\n\tuint32_t saveBLC_PWM_CTL;\n\n\tstruct gma_i2c_chan *i2c_bus;\n};\n\n\n \nstatic u32 psb_intel_lvds_get_max_backlight(struct drm_device *dev)\n{\n\tstruct drm_psb_private *dev_priv = to_drm_psb_private(dev);\n\tu32 ret;\n\n\tif (gma_power_begin(dev, false)) {\n\t\tret = REG_READ(BLC_PWM_CTL);\n\t\tgma_power_end(dev);\n\t} else  \n\t\tret = dev_priv->regs.saveBLC_PWM_CTL;\n\n\t \n\tret = (ret &  BACKLIGHT_MODULATION_FREQ_MASK) >>\n\t\t\t\t\tBACKLIGHT_MODULATION_FREQ_SHIFT;\n\n        ret *= 2;\t \n        if (ret == 0)\n                dev_err(dev->dev, \"BL bug: Reg %08x save %08X\\n\",\n                        REG_READ(BLC_PWM_CTL), dev_priv->regs.saveBLC_PWM_CTL);\n\treturn ret;\n}\n\n \nstatic int psb_lvds_i2c_set_brightness(struct drm_device *dev,\n\t\t\t\t\tunsigned int level)\n{\n\tstruct drm_psb_private *dev_priv = to_drm_psb_private(dev);\n\n\tstruct gma_i2c_chan *lvds_i2c_bus = dev_priv->lvds_i2c_bus;\n\tu8 out_buf[2];\n\tunsigned int blc_i2c_brightness;\n\n\tstruct i2c_msg msgs[] = {\n\t\t{\n\t\t\t.addr = lvds_i2c_bus->slave_addr,\n\t\t\t.flags = 0,\n\t\t\t.len = 2,\n\t\t\t.buf = out_buf,\n\t\t}\n\t};\n\n\tblc_i2c_brightness = BRIGHTNESS_MASK & ((unsigned int)level *\n\t\t\t     BRIGHTNESS_MASK /\n\t\t\t     BRIGHTNESS_MAX_LEVEL);\n\n\tif (dev_priv->lvds_bl->pol == BLC_POLARITY_INVERSE)\n\t\tblc_i2c_brightness = BRIGHTNESS_MASK - blc_i2c_brightness;\n\n\tout_buf[0] = dev_priv->lvds_bl->brightnesscmd;\n\tout_buf[1] = (u8)blc_i2c_brightness;\n\n\tif (i2c_transfer(&lvds_i2c_bus->base, msgs, 1) == 1) {\n\t\tdev_dbg(dev->dev, \"I2C set brightness.(command, value) (%d, %d)\\n\",\n\t\t\tdev_priv->lvds_bl->brightnesscmd,\n\t\t\tblc_i2c_brightness);\n\t\treturn 0;\n\t}\n\n\tdev_err(dev->dev, \"I2C transfer error\\n\");\n\treturn -1;\n}\n\n\nstatic int psb_lvds_pwm_set_brightness(struct drm_device *dev, int level)\n{\n\tstruct drm_psb_private *dev_priv = to_drm_psb_private(dev);\n\n\tu32 max_pwm_blc;\n\tu32 blc_pwm_duty_cycle;\n\n\tmax_pwm_blc = psb_intel_lvds_get_max_backlight(dev);\n\n\t \n\tBUG_ON(max_pwm_blc == 0);\n\n\tblc_pwm_duty_cycle = level * max_pwm_blc / BRIGHTNESS_MAX_LEVEL;\n\n\tif (dev_priv->lvds_bl->pol == BLC_POLARITY_INVERSE)\n\t\tblc_pwm_duty_cycle = max_pwm_blc - blc_pwm_duty_cycle;\n\n\tblc_pwm_duty_cycle &= PSB_BACKLIGHT_PWM_POLARITY_BIT_CLEAR;\n\tREG_WRITE(BLC_PWM_CTL,\n\t\t  (max_pwm_blc << PSB_BACKLIGHT_PWM_CTL_SHIFT) |\n\t\t  (blc_pwm_duty_cycle));\n\n        dev_info(dev->dev, \"Backlight lvds set brightness %08x\\n\",\n\t\t  (max_pwm_blc << PSB_BACKLIGHT_PWM_CTL_SHIFT) |\n\t\t  (blc_pwm_duty_cycle));\n\n\treturn 0;\n}\n\n \nvoid psb_intel_lvds_set_brightness(struct drm_device *dev, int level)\n{\n\tstruct drm_psb_private *dev_priv = to_drm_psb_private(dev);\n\n\tdev_dbg(dev->dev, \"backlight level is %d\\n\", level);\n\n\tif (!dev_priv->lvds_bl) {\n\t\tdev_err(dev->dev, \"NO LVDS backlight info\\n\");\n\t\treturn;\n\t}\n\n\tif (dev_priv->lvds_bl->type == BLC_I2C_TYPE)\n\t\tpsb_lvds_i2c_set_brightness(dev, level);\n\telse\n\t\tpsb_lvds_pwm_set_brightness(dev, level);\n}\n\n \nstatic void psb_intel_lvds_set_backlight(struct drm_device *dev, int level)\n{\n\tstruct drm_psb_private *dev_priv = to_drm_psb_private(dev);\n\tu32 blc_pwm_ctl;\n\n\tif (gma_power_begin(dev, false)) {\n\t\tblc_pwm_ctl = REG_READ(BLC_PWM_CTL);\n\t\tblc_pwm_ctl &= ~BACKLIGHT_DUTY_CYCLE_MASK;\n\t\tREG_WRITE(BLC_PWM_CTL,\n\t\t\t\t(blc_pwm_ctl |\n\t\t\t\t(level << BACKLIGHT_DUTY_CYCLE_SHIFT)));\n\t\tdev_priv->regs.saveBLC_PWM_CTL = (blc_pwm_ctl |\n\t\t\t\t\t(level << BACKLIGHT_DUTY_CYCLE_SHIFT));\n\t\tgma_power_end(dev);\n\t} else {\n\t\tblc_pwm_ctl = dev_priv->regs.saveBLC_PWM_CTL &\n\t\t\t\t~BACKLIGHT_DUTY_CYCLE_MASK;\n\t\tdev_priv->regs.saveBLC_PWM_CTL = (blc_pwm_ctl |\n\t\t\t\t\t(level << BACKLIGHT_DUTY_CYCLE_SHIFT));\n\t}\n}\n\n \nstatic void psb_intel_lvds_set_power(struct drm_device *dev, bool on)\n{\n\tstruct drm_psb_private *dev_priv = to_drm_psb_private(dev);\n\tstruct psb_intel_mode_device *mode_dev = &dev_priv->mode_dev;\n\tu32 pp_status;\n\n\tif (!gma_power_begin(dev, true)) {\n\t        dev_err(dev->dev, \"set power, chip off!\\n\");\n\t\treturn;\n        }\n\n\tif (on) {\n\t\tREG_WRITE(PP_CONTROL, REG_READ(PP_CONTROL) |\n\t\t\t  POWER_TARGET_ON);\n\t\tdo {\n\t\t\tpp_status = REG_READ(PP_STATUS);\n\t\t} while ((pp_status & PP_ON) == 0);\n\n\t\tpsb_intel_lvds_set_backlight(dev,\n\t\t\t\t\t     mode_dev->backlight_duty_cycle);\n\t} else {\n\t\tpsb_intel_lvds_set_backlight(dev, 0);\n\n\t\tREG_WRITE(PP_CONTROL, REG_READ(PP_CONTROL) &\n\t\t\t  ~POWER_TARGET_ON);\n\t\tdo {\n\t\t\tpp_status = REG_READ(PP_STATUS);\n\t\t} while (pp_status & PP_ON);\n\t}\n\n\tgma_power_end(dev);\n}\n\nstatic void psb_intel_lvds_encoder_dpms(struct drm_encoder *encoder, int mode)\n{\n\tstruct drm_device *dev = encoder->dev;\n\n\tif (mode == DRM_MODE_DPMS_ON)\n\t\tpsb_intel_lvds_set_power(dev, true);\n\telse\n\t\tpsb_intel_lvds_set_power(dev, false);\n\n\t \n}\n\nstatic void psb_intel_lvds_save(struct drm_connector *connector)\n{\n\tstruct drm_device *dev = connector->dev;\n\tstruct drm_psb_private *dev_priv = to_drm_psb_private(dev);\n\tstruct gma_encoder *gma_encoder = gma_attached_encoder(connector);\n\tstruct psb_intel_lvds_priv *lvds_priv =\n\t\t(struct psb_intel_lvds_priv *)gma_encoder->dev_priv;\n\n\tlvds_priv->savePP_ON = REG_READ(LVDSPP_ON);\n\tlvds_priv->savePP_OFF = REG_READ(LVDSPP_OFF);\n\tlvds_priv->saveLVDS = REG_READ(LVDS);\n\tlvds_priv->savePP_CONTROL = REG_READ(PP_CONTROL);\n\tlvds_priv->savePP_CYCLE = REG_READ(PP_CYCLE);\n\t \n\tlvds_priv->saveBLC_PWM_CTL = REG_READ(BLC_PWM_CTL);\n\tlvds_priv->savePFIT_CONTROL = REG_READ(PFIT_CONTROL);\n\tlvds_priv->savePFIT_PGM_RATIOS = REG_READ(PFIT_PGM_RATIOS);\n\n\t \n\tdev_priv->backlight_duty_cycle = (dev_priv->regs.saveBLC_PWM_CTL &\n\t\t\t\t\t\tBACKLIGHT_DUTY_CYCLE_MASK);\n\n\t \n\tif (dev_priv->backlight_duty_cycle == 0)\n\t\tdev_priv->backlight_duty_cycle =\n\t\tpsb_intel_lvds_get_max_backlight(dev);\n\n\tdev_dbg(dev->dev, \"(0x%x, 0x%x, 0x%x, 0x%x, 0x%x, 0x%x)\\n\",\n\t\t\tlvds_priv->savePP_ON,\n\t\t\tlvds_priv->savePP_OFF,\n\t\t\tlvds_priv->saveLVDS,\n\t\t\tlvds_priv->savePP_CONTROL,\n\t\t\tlvds_priv->savePP_CYCLE,\n\t\t\tlvds_priv->saveBLC_PWM_CTL);\n}\n\nstatic void psb_intel_lvds_restore(struct drm_connector *connector)\n{\n\tstruct drm_device *dev = connector->dev;\n\tu32 pp_status;\n\tstruct gma_encoder *gma_encoder = gma_attached_encoder(connector);\n\tstruct psb_intel_lvds_priv *lvds_priv =\n\t\t(struct psb_intel_lvds_priv *)gma_encoder->dev_priv;\n\n\tdev_dbg(dev->dev, \"(0x%x, 0x%x, 0x%x, 0x%x, 0x%x, 0x%x)\\n\",\n\t\t\tlvds_priv->savePP_ON,\n\t\t\tlvds_priv->savePP_OFF,\n\t\t\tlvds_priv->saveLVDS,\n\t\t\tlvds_priv->savePP_CONTROL,\n\t\t\tlvds_priv->savePP_CYCLE,\n\t\t\tlvds_priv->saveBLC_PWM_CTL);\n\n\tREG_WRITE(BLC_PWM_CTL, lvds_priv->saveBLC_PWM_CTL);\n\tREG_WRITE(PFIT_CONTROL, lvds_priv->savePFIT_CONTROL);\n\tREG_WRITE(PFIT_PGM_RATIOS, lvds_priv->savePFIT_PGM_RATIOS);\n\tREG_WRITE(LVDSPP_ON, lvds_priv->savePP_ON);\n\tREG_WRITE(LVDSPP_OFF, lvds_priv->savePP_OFF);\n\t \n\tREG_WRITE(PP_CYCLE, lvds_priv->savePP_CYCLE);\n\tREG_WRITE(PP_CONTROL, lvds_priv->savePP_CONTROL);\n\tREG_WRITE(LVDS, lvds_priv->saveLVDS);\n\n\tif (lvds_priv->savePP_CONTROL & POWER_TARGET_ON) {\n\t\tREG_WRITE(PP_CONTROL, REG_READ(PP_CONTROL) |\n\t\t\tPOWER_TARGET_ON);\n\t\tdo {\n\t\t\tpp_status = REG_READ(PP_STATUS);\n\t\t} while ((pp_status & PP_ON) == 0);\n\t} else {\n\t\tREG_WRITE(PP_CONTROL, REG_READ(PP_CONTROL) &\n\t\t\t~POWER_TARGET_ON);\n\t\tdo {\n\t\t\tpp_status = REG_READ(PP_STATUS);\n\t\t} while (pp_status & PP_ON);\n\t}\n}\n\nenum drm_mode_status psb_intel_lvds_mode_valid(struct drm_connector *connector,\n\t\t\t\t struct drm_display_mode *mode)\n{\n\tstruct drm_psb_private *dev_priv = to_drm_psb_private(connector->dev);\n\tstruct gma_encoder *gma_encoder = gma_attached_encoder(connector);\n\tstruct drm_display_mode *fixed_mode =\n\t\t\t\t\tdev_priv->mode_dev.panel_fixed_mode;\n\n\tif (gma_encoder->type == INTEL_OUTPUT_MIPI2)\n\t\tfixed_mode = dev_priv->mode_dev.panel_fixed_mode2;\n\n\t \n\tif (mode->flags & DRM_MODE_FLAG_DBLSCAN)\n\t\treturn MODE_NO_DBLESCAN;\n\n\t \n\tif (mode->flags & DRM_MODE_FLAG_INTERLACE)\n\t\treturn MODE_NO_INTERLACE;\n\n\tif (fixed_mode) {\n\t\tif (mode->hdisplay > fixed_mode->hdisplay)\n\t\t\treturn MODE_PANEL;\n\t\tif (mode->vdisplay > fixed_mode->vdisplay)\n\t\t\treturn MODE_PANEL;\n\t}\n\treturn MODE_OK;\n}\n\nbool psb_intel_lvds_mode_fixup(struct drm_encoder *encoder,\n\t\t\t\t  const struct drm_display_mode *mode,\n\t\t\t\t  struct drm_display_mode *adjusted_mode)\n{\n\tstruct drm_device *dev = encoder->dev;\n\tstruct drm_psb_private *dev_priv = to_drm_psb_private(dev);\n\tstruct psb_intel_mode_device *mode_dev = &dev_priv->mode_dev;\n\tstruct gma_crtc *gma_crtc = to_gma_crtc(encoder->crtc);\n\tstruct drm_encoder *tmp_encoder;\n\tstruct drm_display_mode *panel_fixed_mode = mode_dev->panel_fixed_mode;\n\tstruct gma_encoder *gma_encoder = to_gma_encoder(encoder);\n\n\tif (gma_encoder->type == INTEL_OUTPUT_MIPI2)\n\t\tpanel_fixed_mode = mode_dev->panel_fixed_mode2;\n\n\t \n\tif (!IS_MRST(dev) && gma_crtc->pipe == 0) {\n\t\tpr_err(\"Can't support LVDS on pipe A\\n\");\n\t\treturn false;\n\t}\n\tif (IS_MRST(dev) && gma_crtc->pipe != 0) {\n\t\tpr_err(\"Must use PIPE A\\n\");\n\t\treturn false;\n\t}\n\t \n\tlist_for_each_entry(tmp_encoder, &dev->mode_config.encoder_list,\n\t\t\t    head) {\n\t\tif (tmp_encoder != encoder\n\t\t    && tmp_encoder->crtc == encoder->crtc) {\n\t\t\tpr_err(\"Can't enable LVDS and another encoder on the same pipe\\n\");\n\t\t\treturn false;\n\t\t}\n\t}\n\n\t \n\tif (panel_fixed_mode != NULL) {\n\t\tadjusted_mode->hdisplay = panel_fixed_mode->hdisplay;\n\t\tadjusted_mode->hsync_start = panel_fixed_mode->hsync_start;\n\t\tadjusted_mode->hsync_end = panel_fixed_mode->hsync_end;\n\t\tadjusted_mode->htotal = panel_fixed_mode->htotal;\n\t\tadjusted_mode->vdisplay = panel_fixed_mode->vdisplay;\n\t\tadjusted_mode->vsync_start = panel_fixed_mode->vsync_start;\n\t\tadjusted_mode->vsync_end = panel_fixed_mode->vsync_end;\n\t\tadjusted_mode->vtotal = panel_fixed_mode->vtotal;\n\t\tadjusted_mode->clock = panel_fixed_mode->clock;\n\t\tdrm_mode_set_crtcinfo(adjusted_mode,\n\t\t\t\t      CRTC_INTERLACE_HALVE_V);\n\t}\n\n\t \n\n\treturn true;\n}\n\nstatic void psb_intel_lvds_prepare(struct drm_encoder *encoder)\n{\n\tstruct drm_device *dev = encoder->dev;\n\tstruct drm_psb_private *dev_priv = to_drm_psb_private(dev);\n\tstruct psb_intel_mode_device *mode_dev = &dev_priv->mode_dev;\n\n\tif (!gma_power_begin(dev, true))\n\t\treturn;\n\n\tmode_dev->saveBLC_PWM_CTL = REG_READ(BLC_PWM_CTL);\n\tmode_dev->backlight_duty_cycle = (mode_dev->saveBLC_PWM_CTL &\n\t\t\t\t\t  BACKLIGHT_DUTY_CYCLE_MASK);\n\n\tpsb_intel_lvds_set_power(dev, false);\n\n\tgma_power_end(dev);\n}\n\nstatic void psb_intel_lvds_commit(struct drm_encoder *encoder)\n{\n\tstruct drm_device *dev = encoder->dev;\n\tstruct drm_psb_private *dev_priv = to_drm_psb_private(dev);\n\tstruct psb_intel_mode_device *mode_dev = &dev_priv->mode_dev;\n\n\tif (mode_dev->backlight_duty_cycle == 0)\n\t\tmode_dev->backlight_duty_cycle =\n\t\t    psb_intel_lvds_get_max_backlight(dev);\n\n\tpsb_intel_lvds_set_power(dev, true);\n}\n\nstatic void psb_intel_lvds_mode_set(struct drm_encoder *encoder,\n\t\t\t\tstruct drm_display_mode *mode,\n\t\t\t\tstruct drm_display_mode *adjusted_mode)\n{\n\tstruct drm_device *dev = encoder->dev;\n\tstruct drm_psb_private *dev_priv = to_drm_psb_private(dev);\n\tu32 pfit_control;\n\n\t \n\n\t \n\tif (mode->hdisplay != adjusted_mode->hdisplay ||\n\t    mode->vdisplay != adjusted_mode->vdisplay)\n\t\tpfit_control = (PFIT_ENABLE | VERT_AUTO_SCALE |\n\t\t\t\tHORIZ_AUTO_SCALE | VERT_INTERP_BILINEAR |\n\t\t\t\tHORIZ_INTERP_BILINEAR);\n\telse\n\t\tpfit_control = 0;\n\n\tif (dev_priv->lvds_dither)\n\t\tpfit_control |= PANEL_8TO6_DITHER_ENABLE;\n\n\tREG_WRITE(PFIT_CONTROL, pfit_control);\n}\n\n \nstatic int psb_intel_lvds_get_modes(struct drm_connector *connector)\n{\n\tstruct drm_device *dev = connector->dev;\n\tstruct drm_psb_private *dev_priv = to_drm_psb_private(dev);\n\tstruct psb_intel_mode_device *mode_dev = &dev_priv->mode_dev;\n\tint ret = 0;\n\n\tif (!IS_MRST(dev))\n\t\tret = psb_intel_ddc_get_modes(connector, connector->ddc);\n\n\tif (ret)\n\t\treturn ret;\n\n\tif (mode_dev->panel_fixed_mode != NULL) {\n\t\tstruct drm_display_mode *mode =\n\t\t    drm_mode_duplicate(dev, mode_dev->panel_fixed_mode);\n\t\tdrm_mode_probed_add(connector, mode);\n\t\treturn 1;\n\t}\n\n\treturn 0;\n}\n\nvoid psb_intel_lvds_destroy(struct drm_connector *connector)\n{\n\tstruct gma_connector *gma_connector = to_gma_connector(connector);\n\tstruct gma_i2c_chan *ddc_bus = to_gma_i2c_chan(connector->ddc);\n\n\tgma_i2c_destroy(ddc_bus);\n\tdrm_connector_cleanup(connector);\n\tkfree(gma_connector);\n}\n\nint psb_intel_lvds_set_property(struct drm_connector *connector,\n\t\t\t\t       struct drm_property *property,\n\t\t\t\t       uint64_t value)\n{\n\tstruct drm_encoder *encoder = connector->encoder;\n\n\tif (!encoder)\n\t\treturn -1;\n\n\tif (!strcmp(property->name, \"scaling mode\")) {\n\t\tstruct gma_crtc *crtc = to_gma_crtc(encoder->crtc);\n\t\tuint64_t curval;\n\n\t\tif (!crtc)\n\t\t\tgoto set_prop_error;\n\n\t\tswitch (value) {\n\t\tcase DRM_MODE_SCALE_FULLSCREEN:\n\t\t\tbreak;\n\t\tcase DRM_MODE_SCALE_NO_SCALE:\n\t\t\tbreak;\n\t\tcase DRM_MODE_SCALE_ASPECT:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tgoto set_prop_error;\n\t\t}\n\n\t\tif (drm_object_property_get_value(&connector->base,\n\t\t\t\t\t\t     property,\n\t\t\t\t\t\t     &curval))\n\t\t\tgoto set_prop_error;\n\n\t\tif (curval == value)\n\t\t\tgoto set_prop_done;\n\n\t\tif (drm_object_property_set_value(&connector->base,\n\t\t\t\t\t\t\tproperty,\n\t\t\t\t\t\t\tvalue))\n\t\t\tgoto set_prop_error;\n\n\t\tif (crtc->saved_mode.hdisplay != 0 &&\n\t\t    crtc->saved_mode.vdisplay != 0) {\n\t\t\tif (!drm_crtc_helper_set_mode(encoder->crtc,\n\t\t\t\t\t\t      &crtc->saved_mode,\n\t\t\t\t\t\t      encoder->crtc->x,\n\t\t\t\t\t\t      encoder->crtc->y,\n\t\t\t\t\t\t      encoder->crtc->primary->fb))\n\t\t\t\tgoto set_prop_error;\n\t\t}\n\t} else if (!strcmp(property->name, \"backlight\")) {\n\t\tif (drm_object_property_set_value(&connector->base,\n\t\t\t\t\t\t\tproperty,\n\t\t\t\t\t\t\tvalue))\n\t\t\tgoto set_prop_error;\n\t\telse\n                        gma_backlight_set(encoder->dev, value);\n\t} else if (!strcmp(property->name, \"DPMS\")) {\n\t\tconst struct drm_encoder_helper_funcs *hfuncs\n\t\t\t\t\t\t= encoder->helper_private;\n\t\thfuncs->dpms(encoder, value);\n\t}\n\nset_prop_done:\n\treturn 0;\nset_prop_error:\n\treturn -1;\n}\n\nstatic const struct drm_encoder_helper_funcs psb_intel_lvds_helper_funcs = {\n\t.dpms = psb_intel_lvds_encoder_dpms,\n\t.mode_fixup = psb_intel_lvds_mode_fixup,\n\t.prepare = psb_intel_lvds_prepare,\n\t.mode_set = psb_intel_lvds_mode_set,\n\t.commit = psb_intel_lvds_commit,\n};\n\nconst struct drm_connector_helper_funcs\n\t\t\t\tpsb_intel_lvds_connector_helper_funcs = {\n\t.get_modes = psb_intel_lvds_get_modes,\n\t.mode_valid = psb_intel_lvds_mode_valid,\n\t.best_encoder = gma_best_encoder,\n};\n\nconst struct drm_connector_funcs psb_intel_lvds_connector_funcs = {\n\t.dpms = drm_helper_connector_dpms,\n\t.fill_modes = drm_helper_probe_single_connector_modes,\n\t.set_property = psb_intel_lvds_set_property,\n\t.destroy = psb_intel_lvds_destroy,\n};\n\n \nvoid psb_intel_lvds_init(struct drm_device *dev,\n\t\t\t struct psb_intel_mode_device *mode_dev)\n{\n\tstruct gma_encoder *gma_encoder;\n\tstruct gma_connector *gma_connector;\n\tstruct psb_intel_lvds_priv *lvds_priv;\n\tstruct drm_connector *connector;\n\tstruct drm_encoder *encoder;\n\tstruct drm_display_mode *scan;\t \n\tstruct drm_crtc *crtc;\n\tstruct drm_psb_private *dev_priv = to_drm_psb_private(dev);\n\tstruct gma_i2c_chan *ddc_bus;\n\tu32 lvds;\n\tint pipe;\n\tint ret;\n\n\tgma_encoder = kzalloc(sizeof(struct gma_encoder), GFP_KERNEL);\n\tif (!gma_encoder) {\n\t\tdev_err(dev->dev, \"gma_encoder allocation error\\n\");\n\t\treturn;\n\t}\n\tencoder = &gma_encoder->base;\n\n\tgma_connector = kzalloc(sizeof(struct gma_connector), GFP_KERNEL);\n\tif (!gma_connector) {\n\t\tdev_err(dev->dev, \"gma_connector allocation error\\n\");\n\t\tgoto err_free_encoder;\n\t}\n\n\tlvds_priv = kzalloc(sizeof(struct psb_intel_lvds_priv), GFP_KERNEL);\n\tif (!lvds_priv) {\n\t\tdev_err(dev->dev, \"LVDS private allocation error\\n\");\n\t\tgoto err_free_connector;\n\t}\n\n\tgma_encoder->dev_priv = lvds_priv;\n\n\tconnector = &gma_connector->base;\n\tgma_connector->save = psb_intel_lvds_save;\n\tgma_connector->restore = psb_intel_lvds_restore;\n\n\t \n\tddc_bus = gma_i2c_create(dev, GPIOC, \"LVDSDDC_C\");\n\tif (!ddc_bus) {\n\t\tdev_printk(KERN_ERR, dev->dev,\n\t\t\t   \"DDC bus registration \" \"failed.\\n\");\n\t\tgoto err_free_lvds_priv;\n\t}\n\n\tret = drm_connector_init_with_ddc(dev, connector,\n\t\t\t\t\t  &psb_intel_lvds_connector_funcs,\n\t\t\t\t\t  DRM_MODE_CONNECTOR_LVDS,\n\t\t\t\t\t  &ddc_bus->base);\n\tif (ret)\n\t\tgoto err_ddc_destroy;\n\n\tret = drm_simple_encoder_init(dev, encoder, DRM_MODE_ENCODER_LVDS);\n\tif (ret)\n\t\tgoto err_connector_cleanup;\n\n\tgma_connector_attach_encoder(gma_connector, gma_encoder);\n\tgma_encoder->type = INTEL_OUTPUT_LVDS;\n\n\tdrm_encoder_helper_add(encoder, &psb_intel_lvds_helper_funcs);\n\tdrm_connector_helper_add(connector,\n\t\t\t\t &psb_intel_lvds_connector_helper_funcs);\n\tconnector->display_info.subpixel_order = SubPixelHorizontalRGB;\n\tconnector->interlace_allowed = false;\n\tconnector->doublescan_allowed = false;\n\n\t \n\tdrm_object_attach_property(&connector->base,\n\t\t\t\t      dev->mode_config.scaling_mode_property,\n\t\t\t\t      DRM_MODE_SCALE_FULLSCREEN);\n\tdrm_object_attach_property(&connector->base,\n\t\t\t\t      dev_priv->backlight_property,\n\t\t\t\t      BRIGHTNESS_MAX_LEVEL);\n\n\t \n\tlvds_priv->i2c_bus = gma_i2c_create(dev, GPIOB, \"LVDSBLC_B\");\n\tif (!lvds_priv->i2c_bus) {\n\t\tdev_printk(KERN_ERR,\n\t\t\tdev->dev, \"I2C bus registration failed.\\n\");\n\t\tgoto err_encoder_cleanup;\n\t}\n\tlvds_priv->i2c_bus->slave_addr = 0x2C;\n\tdev_priv->lvds_i2c_bus =  lvds_priv->i2c_bus;\n\n\t \n\n\t \n\tmutex_lock(&dev->mode_config.mutex);\n\tpsb_intel_ddc_get_modes(connector, &ddc_bus->base);\n\n\tlist_for_each_entry(scan, &connector->probed_modes, head) {\n\t\tif (scan->type & DRM_MODE_TYPE_PREFERRED) {\n\t\t\tmode_dev->panel_fixed_mode =\n\t\t\t    drm_mode_duplicate(dev, scan);\n\t\t\tDRM_DEBUG_KMS(\"Using mode from DDC\\n\");\n\t\t\tgoto out;\t \n\t\t}\n\t}\n\n\t \n\tif (dev_priv->lfp_lvds_vbt_mode) {\n\t\tmode_dev->panel_fixed_mode =\n\t\t\tdrm_mode_duplicate(dev, dev_priv->lfp_lvds_vbt_mode);\n\n\t\tif (mode_dev->panel_fixed_mode) {\n\t\t\tmode_dev->panel_fixed_mode->type |=\n\t\t\t\tDRM_MODE_TYPE_PREFERRED;\n\t\t\tDRM_DEBUG_KMS(\"Using mode from VBT\\n\");\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\t \n\tlvds = REG_READ(LVDS);\n\tpipe = (lvds & LVDS_PIPEB_SELECT) ? 1 : 0;\n\tcrtc = psb_intel_get_crtc_from_pipe(dev, pipe);\n\n\tif (crtc && (lvds & LVDS_PORT_EN)) {\n\t\tmode_dev->panel_fixed_mode =\n\t\t    psb_intel_crtc_mode_get(dev, crtc);\n\t\tif (mode_dev->panel_fixed_mode) {\n\t\t\tmode_dev->panel_fixed_mode->type |=\n\t\t\t    DRM_MODE_TYPE_PREFERRED;\n\t\t\tDRM_DEBUG_KMS(\"Using pre-programmed mode\\n\");\n\t\t\tgoto out;\t \n\t\t}\n\t}\n\n\t \n\tif (!mode_dev->panel_fixed_mode) {\n\t\tdev_err(dev->dev, \"Found no modes on the lvds, ignoring the LVDS\\n\");\n\t\tgoto err_unlock;\n\t}\n\n\t \nout:\n\tmutex_unlock(&dev->mode_config.mutex);\n\treturn;\n\nerr_unlock:\n\tmutex_unlock(&dev->mode_config.mutex);\n\tgma_i2c_destroy(lvds_priv->i2c_bus);\nerr_encoder_cleanup:\n\tdrm_encoder_cleanup(encoder);\nerr_connector_cleanup:\n\tdrm_connector_cleanup(connector);\nerr_ddc_destroy:\n\tgma_i2c_destroy(ddc_bus);\nerr_free_lvds_priv:\n\tkfree(lvds_priv);\nerr_free_connector:\n\tkfree(gma_connector);\nerr_free_encoder:\n\tkfree(gma_encoder);\n}\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}