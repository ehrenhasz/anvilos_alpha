{
  "module_name": "psb_intel_sdvo.c",
  "hash_id": "d284797409a3bce359e37aa991c5897eec1d48a2b50f3318d70f33c3b859602b",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/gma500/psb_intel_sdvo.c",
  "human_readable_source": " \n\n#include <linux/delay.h>\n#include <linux/i2c.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n\n#include <drm/drm_crtc.h>\n#include <drm/drm_crtc_helper.h>\n#include <drm/drm_edid.h>\n#include <drm/drm_modeset_helper_vtables.h>\n\n#include \"psb_drv.h\"\n#include \"psb_intel_drv.h\"\n#include \"psb_intel_reg.h\"\n#include \"psb_intel_sdvo_regs.h\"\n\n#define SDVO_TMDS_MASK (SDVO_OUTPUT_TMDS0 | SDVO_OUTPUT_TMDS1)\n#define SDVO_RGB_MASK  (SDVO_OUTPUT_RGB0 | SDVO_OUTPUT_RGB1)\n#define SDVO_LVDS_MASK (SDVO_OUTPUT_LVDS0 | SDVO_OUTPUT_LVDS1)\n#define SDVO_TV_MASK   (SDVO_OUTPUT_CVBS0 | SDVO_OUTPUT_SVID0)\n\n#define SDVO_OUTPUT_MASK (SDVO_TMDS_MASK | SDVO_RGB_MASK | SDVO_LVDS_MASK |\\\n                         SDVO_TV_MASK)\n\n#define IS_TV(c)\t(c->output_flag & SDVO_TV_MASK)\n#define IS_TMDS(c)\t(c->output_flag & SDVO_TMDS_MASK)\n#define IS_LVDS(c)\t(c->output_flag & SDVO_LVDS_MASK)\n#define IS_TV_OR_LVDS(c) (c->output_flag & (SDVO_TV_MASK | SDVO_LVDS_MASK))\n\n\nstatic const char *tv_format_names[] = {\n\t\"NTSC_M\"   , \"NTSC_J\"  , \"NTSC_443\",\n\t\"PAL_B\"    , \"PAL_D\"   , \"PAL_G\"   ,\n\t\"PAL_H\"    , \"PAL_I\"   , \"PAL_M\"   ,\n\t\"PAL_N\"    , \"PAL_NC\"  , \"PAL_60\"  ,\n\t\"SECAM_B\"  , \"SECAM_D\" , \"SECAM_G\" ,\n\t\"SECAM_K\"  , \"SECAM_K1\", \"SECAM_L\" ,\n\t\"SECAM_60\"\n};\n\nstruct psb_intel_sdvo {\n\tstruct gma_encoder base;\n\n\tstruct i2c_adapter *i2c;\n\tu8 slave_addr;\n\n\tstruct i2c_adapter ddc;\n\n\t \n\tint sdvo_reg;\n\n\t \n\tuint16_t controlled_output;\n\n\t \n\tstruct psb_intel_sdvo_caps caps;\n\n\t \n\tint pixel_clock_min, pixel_clock_max;\n\n\t \n\tuint16_t attached_output;\n\n\t \n\tuint32_t color_range;\n\n\t \n\tbool is_tv;\n\n\t \n\tint tv_format_index;\n\n\t \n\tbool is_hdmi;\n\tbool has_hdmi_monitor;\n\tbool has_hdmi_audio;\n\n\t \n\tbool is_lvds;\n\n\t \n\tstruct drm_display_mode *sdvo_lvds_fixed_mode;\n\n\t \n\tuint8_t ddc_bus;\n\n\tu8 pixel_multiplier;\n\n\t \n\tstruct psb_intel_sdvo_dtd input_dtd;\n\n\t \n\tuint32_t saveSDVO;  \n};\n\nstruct psb_intel_sdvo_connector {\n\tstruct gma_connector base;\n\n\t \n\tuint16_t output_flag;\n\n\tint force_audio;\n\n\t \n\tu8 tv_format_supported[ARRAY_SIZE(tv_format_names)];\n\tint   format_supported_num;\n\tstruct drm_property *tv_format;\n\n\t \n\tstruct drm_property *left;\n\tstruct drm_property *right;\n\tstruct drm_property *top;\n\tstruct drm_property *bottom;\n\tstruct drm_property *hpos;\n\tstruct drm_property *vpos;\n\tstruct drm_property *contrast;\n\tstruct drm_property *saturation;\n\tstruct drm_property *hue;\n\tstruct drm_property *sharpness;\n\tstruct drm_property *flicker_filter;\n\tstruct drm_property *flicker_filter_adaptive;\n\tstruct drm_property *flicker_filter_2d;\n\tstruct drm_property *tv_chroma_filter;\n\tstruct drm_property *tv_luma_filter;\n\tstruct drm_property *dot_crawl;\n\n\t \n\tstruct drm_property *brightness;\n\n\t \n\tu32\tleft_margin, right_margin, top_margin, bottom_margin;\n\n\t \n\tu32\tmax_hscan,  max_vscan;\n\tu32\tmax_hpos, cur_hpos;\n\tu32\tmax_vpos, cur_vpos;\n\tu32\tcur_brightness, max_brightness;\n\tu32\tcur_contrast,\tmax_contrast;\n\tu32\tcur_saturation, max_saturation;\n\tu32\tcur_hue,\tmax_hue;\n\tu32\tcur_sharpness,\tmax_sharpness;\n\tu32\tcur_flicker_filter,\t\tmax_flicker_filter;\n\tu32\tcur_flicker_filter_adaptive,\tmax_flicker_filter_adaptive;\n\tu32\tcur_flicker_filter_2d,\t\tmax_flicker_filter_2d;\n\tu32\tcur_tv_chroma_filter,\tmax_tv_chroma_filter;\n\tu32\tcur_tv_luma_filter,\tmax_tv_luma_filter;\n\tu32\tcur_dot_crawl,\tmax_dot_crawl;\n};\n\nstatic struct psb_intel_sdvo *to_psb_intel_sdvo(struct drm_encoder *encoder)\n{\n\treturn container_of(encoder, struct psb_intel_sdvo, base.base);\n}\n\nstatic struct psb_intel_sdvo *intel_attached_sdvo(struct drm_connector *connector)\n{\n\treturn container_of(gma_attached_encoder(connector),\n\t\t\t    struct psb_intel_sdvo, base);\n}\n\nstatic struct psb_intel_sdvo_connector *to_psb_intel_sdvo_connector(struct drm_connector *connector)\n{\n\treturn container_of(to_gma_connector(connector), struct psb_intel_sdvo_connector, base);\n}\n\nstatic bool\npsb_intel_sdvo_output_setup(struct psb_intel_sdvo *psb_intel_sdvo, uint16_t flags);\nstatic bool\npsb_intel_sdvo_tv_create_property(struct psb_intel_sdvo *psb_intel_sdvo,\n\t\t\t      struct psb_intel_sdvo_connector *psb_intel_sdvo_connector,\n\t\t\t      int type);\nstatic bool\npsb_intel_sdvo_create_enhance_property(struct psb_intel_sdvo *psb_intel_sdvo,\n\t\t\t\t   struct psb_intel_sdvo_connector *psb_intel_sdvo_connector);\n\n \nstatic void psb_intel_sdvo_write_sdvox(struct psb_intel_sdvo *psb_intel_sdvo, u32 val)\n{\n\tstruct drm_device *dev = psb_intel_sdvo->base.base.dev;\n\tu32 bval = val, cval = val;\n\tint i, j;\n\tint need_aux = IS_MRST(dev) ? 1 : 0;\n\n\tfor (j = 0; j <= need_aux; j++) {\n\t\tif (psb_intel_sdvo->sdvo_reg == SDVOB)\n\t\t\tcval = REG_READ_WITH_AUX(SDVOC, j);\n\t\telse\n\t\t\tbval = REG_READ_WITH_AUX(SDVOB, j);\n\n\t\t \n\t\tfor (i = 0; i < 2; i++) {\n\t\t\tREG_WRITE_WITH_AUX(SDVOB, bval, j);\n\t\t\tREG_READ_WITH_AUX(SDVOB, j);\n\t\t\tREG_WRITE_WITH_AUX(SDVOC, cval, j);\n\t\t\tREG_READ_WITH_AUX(SDVOC, j);\n\t\t}\n\t}\n}\n\nstatic bool psb_intel_sdvo_read_byte(struct psb_intel_sdvo *psb_intel_sdvo, u8 addr, u8 *ch)\n{\n\tstruct i2c_msg msgs[] = {\n\t\t{\n\t\t\t.addr = psb_intel_sdvo->slave_addr,\n\t\t\t.flags = 0,\n\t\t\t.len = 1,\n\t\t\t.buf = &addr,\n\t\t},\n\t\t{\n\t\t\t.addr = psb_intel_sdvo->slave_addr,\n\t\t\t.flags = I2C_M_RD,\n\t\t\t.len = 1,\n\t\t\t.buf = ch,\n\t\t}\n\t};\n\tint ret;\n\n\tif ((ret = i2c_transfer(psb_intel_sdvo->i2c, msgs, 2)) == 2)\n\t\treturn true;\n\n\tDRM_DEBUG_KMS(\"i2c transfer returned %d\\n\", ret);\n\treturn false;\n}\n\n#define SDVO_CMD_NAME_ENTRY(cmd) {cmd, #cmd}\n \nstatic const struct _sdvo_cmd_name {\n\tu8 cmd;\n\tconst char *name;\n} sdvo_cmd_names[] = {\n    SDVO_CMD_NAME_ENTRY(SDVO_CMD_RESET),\n    SDVO_CMD_NAME_ENTRY(SDVO_CMD_GET_DEVICE_CAPS),\n    SDVO_CMD_NAME_ENTRY(SDVO_CMD_GET_FIRMWARE_REV),\n    SDVO_CMD_NAME_ENTRY(SDVO_CMD_GET_TRAINED_INPUTS),\n    SDVO_CMD_NAME_ENTRY(SDVO_CMD_GET_ACTIVE_OUTPUTS),\n    SDVO_CMD_NAME_ENTRY(SDVO_CMD_SET_ACTIVE_OUTPUTS),\n    SDVO_CMD_NAME_ENTRY(SDVO_CMD_GET_IN_OUT_MAP),\n    SDVO_CMD_NAME_ENTRY(SDVO_CMD_SET_IN_OUT_MAP),\n    SDVO_CMD_NAME_ENTRY(SDVO_CMD_GET_ATTACHED_DISPLAYS),\n    SDVO_CMD_NAME_ENTRY(SDVO_CMD_GET_HOT_PLUG_SUPPORT),\n    SDVO_CMD_NAME_ENTRY(SDVO_CMD_SET_ACTIVE_HOT_PLUG),\n    SDVO_CMD_NAME_ENTRY(SDVO_CMD_GET_ACTIVE_HOT_PLUG),\n    SDVO_CMD_NAME_ENTRY(SDVO_CMD_GET_INTERRUPT_EVENT_SOURCE),\n    SDVO_CMD_NAME_ENTRY(SDVO_CMD_SET_TARGET_INPUT),\n    SDVO_CMD_NAME_ENTRY(SDVO_CMD_SET_TARGET_OUTPUT),\n    SDVO_CMD_NAME_ENTRY(SDVO_CMD_GET_INPUT_TIMINGS_PART1),\n    SDVO_CMD_NAME_ENTRY(SDVO_CMD_GET_INPUT_TIMINGS_PART2),\n    SDVO_CMD_NAME_ENTRY(SDVO_CMD_SET_INPUT_TIMINGS_PART1),\n    SDVO_CMD_NAME_ENTRY(SDVO_CMD_SET_INPUT_TIMINGS_PART2),\n    SDVO_CMD_NAME_ENTRY(SDVO_CMD_SET_INPUT_TIMINGS_PART1),\n    SDVO_CMD_NAME_ENTRY(SDVO_CMD_SET_OUTPUT_TIMINGS_PART1),\n    SDVO_CMD_NAME_ENTRY(SDVO_CMD_SET_OUTPUT_TIMINGS_PART2),\n    SDVO_CMD_NAME_ENTRY(SDVO_CMD_GET_OUTPUT_TIMINGS_PART1),\n    SDVO_CMD_NAME_ENTRY(SDVO_CMD_GET_OUTPUT_TIMINGS_PART2),\n    SDVO_CMD_NAME_ENTRY(SDVO_CMD_CREATE_PREFERRED_INPUT_TIMING),\n    SDVO_CMD_NAME_ENTRY(SDVO_CMD_GET_PREFERRED_INPUT_TIMING_PART1),\n    SDVO_CMD_NAME_ENTRY(SDVO_CMD_GET_PREFERRED_INPUT_TIMING_PART2),\n    SDVO_CMD_NAME_ENTRY(SDVO_CMD_GET_INPUT_PIXEL_CLOCK_RANGE),\n    SDVO_CMD_NAME_ENTRY(SDVO_CMD_GET_OUTPUT_PIXEL_CLOCK_RANGE),\n    SDVO_CMD_NAME_ENTRY(SDVO_CMD_GET_SUPPORTED_CLOCK_RATE_MULTS),\n    SDVO_CMD_NAME_ENTRY(SDVO_CMD_GET_CLOCK_RATE_MULT),\n    SDVO_CMD_NAME_ENTRY(SDVO_CMD_SET_CLOCK_RATE_MULT),\n    SDVO_CMD_NAME_ENTRY(SDVO_CMD_GET_SUPPORTED_TV_FORMATS),\n    SDVO_CMD_NAME_ENTRY(SDVO_CMD_GET_TV_FORMAT),\n    SDVO_CMD_NAME_ENTRY(SDVO_CMD_SET_TV_FORMAT),\n    SDVO_CMD_NAME_ENTRY(SDVO_CMD_GET_SUPPORTED_POWER_STATES),\n    SDVO_CMD_NAME_ENTRY(SDVO_CMD_GET_POWER_STATE),\n    SDVO_CMD_NAME_ENTRY(SDVO_CMD_SET_ENCODER_POWER_STATE),\n    SDVO_CMD_NAME_ENTRY(SDVO_CMD_SET_DISPLAY_POWER_STATE),\n    SDVO_CMD_NAME_ENTRY(SDVO_CMD_SET_CONTROL_BUS_SWITCH),\n    SDVO_CMD_NAME_ENTRY(SDVO_CMD_GET_SDTV_RESOLUTION_SUPPORT),\n    SDVO_CMD_NAME_ENTRY(SDVO_CMD_GET_SCALED_HDTV_RESOLUTION_SUPPORT),\n    SDVO_CMD_NAME_ENTRY(SDVO_CMD_GET_SUPPORTED_ENHANCEMENTS),\n\n     \n    SDVO_CMD_NAME_ENTRY(SDVO_CMD_GET_MAX_HPOS),\n    SDVO_CMD_NAME_ENTRY(SDVO_CMD_GET_HPOS),\n    SDVO_CMD_NAME_ENTRY(SDVO_CMD_SET_HPOS),\n    SDVO_CMD_NAME_ENTRY(SDVO_CMD_GET_MAX_VPOS),\n    SDVO_CMD_NAME_ENTRY(SDVO_CMD_GET_VPOS),\n    SDVO_CMD_NAME_ENTRY(SDVO_CMD_SET_VPOS),\n    SDVO_CMD_NAME_ENTRY(SDVO_CMD_GET_MAX_SATURATION),\n    SDVO_CMD_NAME_ENTRY(SDVO_CMD_GET_SATURATION),\n    SDVO_CMD_NAME_ENTRY(SDVO_CMD_SET_SATURATION),\n    SDVO_CMD_NAME_ENTRY(SDVO_CMD_GET_MAX_HUE),\n    SDVO_CMD_NAME_ENTRY(SDVO_CMD_GET_HUE),\n    SDVO_CMD_NAME_ENTRY(SDVO_CMD_SET_HUE),\n    SDVO_CMD_NAME_ENTRY(SDVO_CMD_GET_MAX_CONTRAST),\n    SDVO_CMD_NAME_ENTRY(SDVO_CMD_GET_CONTRAST),\n    SDVO_CMD_NAME_ENTRY(SDVO_CMD_SET_CONTRAST),\n    SDVO_CMD_NAME_ENTRY(SDVO_CMD_GET_MAX_BRIGHTNESS),\n    SDVO_CMD_NAME_ENTRY(SDVO_CMD_GET_BRIGHTNESS),\n    SDVO_CMD_NAME_ENTRY(SDVO_CMD_SET_BRIGHTNESS),\n    SDVO_CMD_NAME_ENTRY(SDVO_CMD_GET_MAX_OVERSCAN_H),\n    SDVO_CMD_NAME_ENTRY(SDVO_CMD_GET_OVERSCAN_H),\n    SDVO_CMD_NAME_ENTRY(SDVO_CMD_SET_OVERSCAN_H),\n    SDVO_CMD_NAME_ENTRY(SDVO_CMD_GET_MAX_OVERSCAN_V),\n    SDVO_CMD_NAME_ENTRY(SDVO_CMD_GET_OVERSCAN_V),\n    SDVO_CMD_NAME_ENTRY(SDVO_CMD_SET_OVERSCAN_V),\n    SDVO_CMD_NAME_ENTRY(SDVO_CMD_GET_MAX_FLICKER_FILTER),\n    SDVO_CMD_NAME_ENTRY(SDVO_CMD_GET_FLICKER_FILTER),\n    SDVO_CMD_NAME_ENTRY(SDVO_CMD_SET_FLICKER_FILTER),\n    SDVO_CMD_NAME_ENTRY(SDVO_CMD_GET_MAX_FLICKER_FILTER_ADAPTIVE),\n    SDVO_CMD_NAME_ENTRY(SDVO_CMD_GET_FLICKER_FILTER_ADAPTIVE),\n    SDVO_CMD_NAME_ENTRY(SDVO_CMD_SET_FLICKER_FILTER_ADAPTIVE),\n    SDVO_CMD_NAME_ENTRY(SDVO_CMD_GET_MAX_FLICKER_FILTER_2D),\n    SDVO_CMD_NAME_ENTRY(SDVO_CMD_GET_FLICKER_FILTER_2D),\n    SDVO_CMD_NAME_ENTRY(SDVO_CMD_SET_FLICKER_FILTER_2D),\n    SDVO_CMD_NAME_ENTRY(SDVO_CMD_GET_MAX_SHARPNESS),\n    SDVO_CMD_NAME_ENTRY(SDVO_CMD_GET_SHARPNESS),\n    SDVO_CMD_NAME_ENTRY(SDVO_CMD_SET_SHARPNESS),\n    SDVO_CMD_NAME_ENTRY(SDVO_CMD_GET_DOT_CRAWL),\n    SDVO_CMD_NAME_ENTRY(SDVO_CMD_SET_DOT_CRAWL),\n    SDVO_CMD_NAME_ENTRY(SDVO_CMD_GET_MAX_TV_CHROMA_FILTER),\n    SDVO_CMD_NAME_ENTRY(SDVO_CMD_GET_TV_CHROMA_FILTER),\n    SDVO_CMD_NAME_ENTRY(SDVO_CMD_SET_TV_CHROMA_FILTER),\n    SDVO_CMD_NAME_ENTRY(SDVO_CMD_GET_MAX_TV_LUMA_FILTER),\n    SDVO_CMD_NAME_ENTRY(SDVO_CMD_GET_TV_LUMA_FILTER),\n    SDVO_CMD_NAME_ENTRY(SDVO_CMD_SET_TV_LUMA_FILTER),\n\n     \n    SDVO_CMD_NAME_ENTRY(SDVO_CMD_GET_SUPP_ENCODE),\n    SDVO_CMD_NAME_ENTRY(SDVO_CMD_GET_ENCODE),\n    SDVO_CMD_NAME_ENTRY(SDVO_CMD_SET_ENCODE),\n    SDVO_CMD_NAME_ENTRY(SDVO_CMD_SET_PIXEL_REPLI),\n    SDVO_CMD_NAME_ENTRY(SDVO_CMD_GET_PIXEL_REPLI),\n    SDVO_CMD_NAME_ENTRY(SDVO_CMD_GET_COLORIMETRY_CAP),\n    SDVO_CMD_NAME_ENTRY(SDVO_CMD_SET_COLORIMETRY),\n    SDVO_CMD_NAME_ENTRY(SDVO_CMD_GET_COLORIMETRY),\n    SDVO_CMD_NAME_ENTRY(SDVO_CMD_GET_AUDIO_ENCRYPT_PREFER),\n    SDVO_CMD_NAME_ENTRY(SDVO_CMD_SET_AUDIO_STAT),\n    SDVO_CMD_NAME_ENTRY(SDVO_CMD_GET_AUDIO_STAT),\n    SDVO_CMD_NAME_ENTRY(SDVO_CMD_GET_HBUF_INDEX),\n    SDVO_CMD_NAME_ENTRY(SDVO_CMD_SET_HBUF_INDEX),\n    SDVO_CMD_NAME_ENTRY(SDVO_CMD_GET_HBUF_INFO),\n    SDVO_CMD_NAME_ENTRY(SDVO_CMD_GET_HBUF_AV_SPLIT),\n    SDVO_CMD_NAME_ENTRY(SDVO_CMD_SET_HBUF_AV_SPLIT),\n    SDVO_CMD_NAME_ENTRY(SDVO_CMD_GET_HBUF_TXRATE),\n    SDVO_CMD_NAME_ENTRY(SDVO_CMD_SET_HBUF_TXRATE),\n    SDVO_CMD_NAME_ENTRY(SDVO_CMD_SET_HBUF_DATA),\n    SDVO_CMD_NAME_ENTRY(SDVO_CMD_GET_HBUF_DATA),\n};\n\n#define IS_SDVOB(reg)\t(reg == SDVOB)\n#define SDVO_NAME(svdo) (IS_SDVOB((svdo)->sdvo_reg) ? \"SDVOB\" : \"SDVOC\")\n\nstatic void psb_intel_sdvo_debug_write(struct psb_intel_sdvo *psb_intel_sdvo,\n\t\t\t\t       u8 cmd, const void *args, int args_len)\n{\n\tstruct drm_device *dev = psb_intel_sdvo->base.base.dev;\n\tint i, pos = 0;\n\tchar buffer[73];\n\n#define BUF_PRINT(args...) \\\n\tpos += snprintf(buffer + pos, max_t(int, sizeof(buffer) - pos, 0), args)\n\n\tfor (i = 0; i < args_len; i++) {\n\t\tBUF_PRINT(\"%02X \", ((u8 *)args)[i]);\n\t}\n\n\tfor (; i < 8; i++) {\n\t\tBUF_PRINT(\"   \");\n\t}\n\n\tfor (i = 0; i < ARRAY_SIZE(sdvo_cmd_names); i++) {\n\t\tif (cmd == sdvo_cmd_names[i].cmd) {\n\t\t\tBUF_PRINT(\"(%s)\", sdvo_cmd_names[i].name);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (i == ARRAY_SIZE(sdvo_cmd_names))\n\t\tBUF_PRINT(\"(%02X)\", cmd);\n\n\tdrm_WARN_ON(dev, pos >= sizeof(buffer) - 1);\n#undef BUF_PRINT\n\n\tDRM_DEBUG_KMS(\"%s: W: %02X %s\\n\", SDVO_NAME(psb_intel_sdvo), cmd, buffer);\n}\n\nstatic const char *cmd_status_names[] = {\n\t\"Power on\",\n\t\"Success\",\n\t\"Not supported\",\n\t\"Invalid arg\",\n\t\"Pending\",\n\t\"Target not specified\",\n\t\"Scaling not supported\"\n};\n\n#define MAX_ARG_LEN 32\n\nstatic bool psb_intel_sdvo_write_cmd(struct psb_intel_sdvo *psb_intel_sdvo, u8 cmd,\n\t\t\t\t const void *args, int args_len)\n{\n\tu8 buf[MAX_ARG_LEN*2 + 2], status;\n\tstruct i2c_msg msgs[MAX_ARG_LEN + 3];\n\tint i, ret;\n\n\tif (args_len > MAX_ARG_LEN) {\n\t\tDRM_ERROR(\"Need to increase arg length\\n\");\n\t\treturn false;\n\t}\n\n\tpsb_intel_sdvo_debug_write(psb_intel_sdvo, cmd, args, args_len);\n\n\tfor (i = 0; i < args_len; i++) {\n\t\tmsgs[i].addr = psb_intel_sdvo->slave_addr;\n\t\tmsgs[i].flags = 0;\n\t\tmsgs[i].len = 2;\n\t\tmsgs[i].buf = buf + 2 *i;\n\t\tbuf[2*i + 0] = SDVO_I2C_ARG_0 - i;\n\t\tbuf[2*i + 1] = ((u8*)args)[i];\n\t}\n\tmsgs[i].addr = psb_intel_sdvo->slave_addr;\n\tmsgs[i].flags = 0;\n\tmsgs[i].len = 2;\n\tmsgs[i].buf = buf + 2*i;\n\tbuf[2*i + 0] = SDVO_I2C_OPCODE;\n\tbuf[2*i + 1] = cmd;\n\n\t \n\tstatus = SDVO_I2C_CMD_STATUS;\n\tmsgs[i+1].addr = psb_intel_sdvo->slave_addr;\n\tmsgs[i+1].flags = 0;\n\tmsgs[i+1].len = 1;\n\tmsgs[i+1].buf = &status;\n\n\tmsgs[i+2].addr = psb_intel_sdvo->slave_addr;\n\tmsgs[i+2].flags = I2C_M_RD;\n\tmsgs[i+2].len = 1;\n\tmsgs[i+2].buf = &status;\n\n\tret = i2c_transfer(psb_intel_sdvo->i2c, msgs, i+3);\n\tif (ret < 0) {\n\t\tDRM_DEBUG_KMS(\"I2c transfer returned %d\\n\", ret);\n\t\treturn false;\n\t}\n\tif (ret != i+3) {\n\t\t \n\t\tDRM_DEBUG_KMS(\"I2c transfer returned %d/%d\\n\", ret, i+3);\n\t\treturn false;\n\t}\n\n\treturn true;\n}\n\nstatic bool psb_intel_sdvo_read_response(struct psb_intel_sdvo *psb_intel_sdvo,\n\t\t\t\t\t void *response, int response_len)\n{\n\tstruct drm_device *dev = psb_intel_sdvo->base.base.dev;\n\tchar buffer[73];\n\tint i, pos = 0;\n\tu8 retry = 5;\n\tu8 status;\n\n\t \n\tif (!psb_intel_sdvo_read_byte(psb_intel_sdvo,\n\t\t\t\t  SDVO_I2C_CMD_STATUS,\n\t\t\t\t  &status))\n\t\tgoto log_fail;\n\n\twhile ((status == SDVO_CMD_STATUS_PENDING ||\n\t\tstatus == SDVO_CMD_STATUS_TARGET_NOT_SPECIFIED) && retry--) {\n\t\tudelay(15);\n\t\tif (!psb_intel_sdvo_read_byte(psb_intel_sdvo,\n\t\t\t\t\t  SDVO_I2C_CMD_STATUS,\n\t\t\t\t\t  &status))\n\t\t\tgoto log_fail;\n\t}\n\n#define BUF_PRINT(args...) \\\n\tpos += snprintf(buffer + pos, max_t(int, sizeof(buffer) - pos, 0), args)\n\n\tif (status <= SDVO_CMD_STATUS_SCALING_NOT_SUPP)\n\t\tBUF_PRINT(\"(%s)\", cmd_status_names[status]);\n\telse\n\t\tBUF_PRINT(\"(??? %d)\", status);\n\n\tif (status != SDVO_CMD_STATUS_SUCCESS)\n\t\tgoto log_fail;\n\n\t \n\tfor (i = 0; i < response_len; i++) {\n\t\tif (!psb_intel_sdvo_read_byte(psb_intel_sdvo,\n\t\t\t\t\t  SDVO_I2C_RETURN_0 + i,\n\t\t\t\t\t  &((u8 *)response)[i]))\n\t\t\tgoto log_fail;\n\t\tBUF_PRINT(\" %02X\", ((u8 *)response)[i]);\n\t}\n\n\tdrm_WARN_ON(dev, pos >= sizeof(buffer) - 1);\n#undef BUF_PRINT\n\n\tDRM_DEBUG_KMS(\"%s: R: %s\\n\", SDVO_NAME(psb_intel_sdvo), buffer);\n\treturn true;\n\nlog_fail:\n\tDRM_DEBUG_KMS(\"%s: R: ... failed %s\\n\",\n\t\t      SDVO_NAME(psb_intel_sdvo), buffer);\n\treturn false;\n}\n\nstatic int psb_intel_sdvo_get_pixel_multiplier(struct drm_display_mode *mode)\n{\n\tif (mode->clock >= 100000)\n\t\treturn 1;\n\telse if (mode->clock >= 50000)\n\t\treturn 2;\n\telse\n\t\treturn 4;\n}\n\nstatic bool psb_intel_sdvo_set_control_bus_switch(struct psb_intel_sdvo *psb_intel_sdvo,\n\t\t\t\t\t      u8 ddc_bus)\n{\n\t \n\treturn psb_intel_sdvo_write_cmd(psb_intel_sdvo,\n\t\t\t\t    SDVO_CMD_SET_CONTROL_BUS_SWITCH,\n\t\t\t\t    &ddc_bus, 1);\n}\n\nstatic bool psb_intel_sdvo_set_value(struct psb_intel_sdvo *psb_intel_sdvo, u8 cmd, const void *data, int len)\n{\n\tif (!psb_intel_sdvo_write_cmd(psb_intel_sdvo, cmd, data, len))\n\t\treturn false;\n\n\treturn psb_intel_sdvo_read_response(psb_intel_sdvo, NULL, 0);\n}\n\nstatic bool\npsb_intel_sdvo_get_value(struct psb_intel_sdvo *psb_intel_sdvo, u8 cmd, void *value, int len)\n{\n\tif (!psb_intel_sdvo_write_cmd(psb_intel_sdvo, cmd, NULL, 0))\n\t\treturn false;\n\n\treturn psb_intel_sdvo_read_response(psb_intel_sdvo, value, len);\n}\n\nstatic bool psb_intel_sdvo_set_target_input(struct psb_intel_sdvo *psb_intel_sdvo)\n{\n\tstruct psb_intel_sdvo_set_target_input_args targets = {0};\n\treturn psb_intel_sdvo_set_value(psb_intel_sdvo,\n\t\t\t\t    SDVO_CMD_SET_TARGET_INPUT,\n\t\t\t\t    &targets, sizeof(targets));\n}\n\n \nstatic bool psb_intel_sdvo_get_trained_inputs(struct psb_intel_sdvo *psb_intel_sdvo, bool *input_1, bool *input_2)\n{\n\tstruct psb_intel_sdvo_get_trained_inputs_response response;\n\n\tBUILD_BUG_ON(sizeof(response) != 1);\n\tif (!psb_intel_sdvo_get_value(psb_intel_sdvo, SDVO_CMD_GET_TRAINED_INPUTS,\n\t\t\t\t  &response, sizeof(response)))\n\t\treturn false;\n\n\t*input_1 = response.input0_trained;\n\t*input_2 = response.input1_trained;\n\treturn true;\n}\n\nstatic bool psb_intel_sdvo_set_active_outputs(struct psb_intel_sdvo *psb_intel_sdvo,\n\t\t\t\t\t  u16 outputs)\n{\n\treturn psb_intel_sdvo_set_value(psb_intel_sdvo,\n\t\t\t\t    SDVO_CMD_SET_ACTIVE_OUTPUTS,\n\t\t\t\t    &outputs, sizeof(outputs));\n}\n\nstatic bool psb_intel_sdvo_set_encoder_power_state(struct psb_intel_sdvo *psb_intel_sdvo,\n\t\t\t\t\t       int mode)\n{\n\tu8 state = SDVO_ENCODER_STATE_ON;\n\n\tswitch (mode) {\n\tcase DRM_MODE_DPMS_ON:\n\t\tstate = SDVO_ENCODER_STATE_ON;\n\t\tbreak;\n\tcase DRM_MODE_DPMS_STANDBY:\n\t\tstate = SDVO_ENCODER_STATE_STANDBY;\n\t\tbreak;\n\tcase DRM_MODE_DPMS_SUSPEND:\n\t\tstate = SDVO_ENCODER_STATE_SUSPEND;\n\t\tbreak;\n\tcase DRM_MODE_DPMS_OFF:\n\t\tstate = SDVO_ENCODER_STATE_OFF;\n\t\tbreak;\n\t}\n\n\treturn psb_intel_sdvo_set_value(psb_intel_sdvo,\n\t\t\t\t    SDVO_CMD_SET_ENCODER_POWER_STATE, &state, sizeof(state));\n}\n\nstatic bool psb_intel_sdvo_get_input_pixel_clock_range(struct psb_intel_sdvo *psb_intel_sdvo,\n\t\t\t\t\t\t   int *clock_min,\n\t\t\t\t\t\t   int *clock_max)\n{\n\tstruct psb_intel_sdvo_pixel_clock_range clocks;\n\n\tBUILD_BUG_ON(sizeof(clocks) != 4);\n\tif (!psb_intel_sdvo_get_value(psb_intel_sdvo,\n\t\t\t\t  SDVO_CMD_GET_INPUT_PIXEL_CLOCK_RANGE,\n\t\t\t\t  &clocks, sizeof(clocks)))\n\t\treturn false;\n\n\t \n\t*clock_min = clocks.min * 10;\n\t*clock_max = clocks.max * 10;\n\treturn true;\n}\n\nstatic bool psb_intel_sdvo_set_target_output(struct psb_intel_sdvo *psb_intel_sdvo,\n\t\t\t\t\t u16 outputs)\n{\n\treturn psb_intel_sdvo_set_value(psb_intel_sdvo,\n\t\t\t\t    SDVO_CMD_SET_TARGET_OUTPUT,\n\t\t\t\t    &outputs, sizeof(outputs));\n}\n\nstatic bool psb_intel_sdvo_set_timing(struct psb_intel_sdvo *psb_intel_sdvo, u8 cmd,\n\t\t\t\t  struct psb_intel_sdvo_dtd *dtd)\n{\n\treturn psb_intel_sdvo_set_value(psb_intel_sdvo, cmd, &dtd->part1, sizeof(dtd->part1)) &&\n\t\tpsb_intel_sdvo_set_value(psb_intel_sdvo, cmd + 1, &dtd->part2, sizeof(dtd->part2));\n}\n\nstatic bool psb_intel_sdvo_set_input_timing(struct psb_intel_sdvo *psb_intel_sdvo,\n\t\t\t\t\t struct psb_intel_sdvo_dtd *dtd)\n{\n\treturn psb_intel_sdvo_set_timing(psb_intel_sdvo,\n\t\t\t\t     SDVO_CMD_SET_INPUT_TIMINGS_PART1, dtd);\n}\n\nstatic bool psb_intel_sdvo_set_output_timing(struct psb_intel_sdvo *psb_intel_sdvo,\n\t\t\t\t\t struct psb_intel_sdvo_dtd *dtd)\n{\n\treturn psb_intel_sdvo_set_timing(psb_intel_sdvo,\n\t\t\t\t     SDVO_CMD_SET_OUTPUT_TIMINGS_PART1, dtd);\n}\n\nstatic bool\npsb_intel_sdvo_create_preferred_input_timing(struct psb_intel_sdvo *psb_intel_sdvo,\n\t\t\t\t\t uint16_t clock,\n\t\t\t\t\t uint16_t width,\n\t\t\t\t\t uint16_t height)\n{\n\tstruct psb_intel_sdvo_preferred_input_timing_args args;\n\n\tmemset(&args, 0, sizeof(args));\n\targs.clock = clock;\n\targs.width = width;\n\targs.height = height;\n\targs.interlace = 0;\n\n\tif (psb_intel_sdvo->is_lvds &&\n\t   (psb_intel_sdvo->sdvo_lvds_fixed_mode->hdisplay != width ||\n\t    psb_intel_sdvo->sdvo_lvds_fixed_mode->vdisplay != height))\n\t\targs.scaled = 1;\n\n\treturn psb_intel_sdvo_set_value(psb_intel_sdvo,\n\t\t\t\t    SDVO_CMD_CREATE_PREFERRED_INPUT_TIMING,\n\t\t\t\t    &args, sizeof(args));\n}\n\nstatic bool psb_intel_sdvo_get_preferred_input_timing(struct psb_intel_sdvo *psb_intel_sdvo,\n\t\t\t\t\t\t  struct psb_intel_sdvo_dtd *dtd)\n{\n\tBUILD_BUG_ON(sizeof(dtd->part1) != 8);\n\tBUILD_BUG_ON(sizeof(dtd->part2) != 8);\n\treturn psb_intel_sdvo_get_value(psb_intel_sdvo, SDVO_CMD_GET_PREFERRED_INPUT_TIMING_PART1,\n\t\t\t\t    &dtd->part1, sizeof(dtd->part1)) &&\n\t\tpsb_intel_sdvo_get_value(psb_intel_sdvo, SDVO_CMD_GET_PREFERRED_INPUT_TIMING_PART2,\n\t\t\t\t     &dtd->part2, sizeof(dtd->part2));\n}\n\nstatic bool psb_intel_sdvo_set_clock_rate_mult(struct psb_intel_sdvo *psb_intel_sdvo, u8 val)\n{\n\treturn psb_intel_sdvo_set_value(psb_intel_sdvo, SDVO_CMD_SET_CLOCK_RATE_MULT, &val, 1);\n}\n\nstatic void psb_intel_sdvo_get_dtd_from_mode(struct psb_intel_sdvo_dtd *dtd,\n\t\t\t\t\t const struct drm_display_mode *mode)\n{\n\tuint16_t width, height;\n\tuint16_t h_blank_len, h_sync_len, v_blank_len, v_sync_len;\n\tuint16_t h_sync_offset, v_sync_offset;\n\n\twidth = mode->crtc_hdisplay;\n\theight = mode->crtc_vdisplay;\n\n\t \n\th_blank_len = mode->crtc_hblank_end - mode->crtc_hblank_start;\n\th_sync_len = mode->crtc_hsync_end - mode->crtc_hsync_start;\n\n\tv_blank_len = mode->crtc_vblank_end - mode->crtc_vblank_start;\n\tv_sync_len = mode->crtc_vsync_end - mode->crtc_vsync_start;\n\n\th_sync_offset = mode->crtc_hsync_start - mode->crtc_hblank_start;\n\tv_sync_offset = mode->crtc_vsync_start - mode->crtc_vblank_start;\n\n\tdtd->part1.clock = mode->clock / 10;\n\tdtd->part1.h_active = width & 0xff;\n\tdtd->part1.h_blank = h_blank_len & 0xff;\n\tdtd->part1.h_high = (((width >> 8) & 0xf) << 4) |\n\t\t((h_blank_len >> 8) & 0xf);\n\tdtd->part1.v_active = height & 0xff;\n\tdtd->part1.v_blank = v_blank_len & 0xff;\n\tdtd->part1.v_high = (((height >> 8) & 0xf) << 4) |\n\t\t((v_blank_len >> 8) & 0xf);\n\n\tdtd->part2.h_sync_off = h_sync_offset & 0xff;\n\tdtd->part2.h_sync_width = h_sync_len & 0xff;\n\tdtd->part2.v_sync_off_width = (v_sync_offset & 0xf) << 4 |\n\t\t(v_sync_len & 0xf);\n\tdtd->part2.sync_off_width_high = ((h_sync_offset & 0x300) >> 2) |\n\t\t((h_sync_len & 0x300) >> 4) | ((v_sync_offset & 0x30) >> 2) |\n\t\t((v_sync_len & 0x30) >> 4);\n\n\tdtd->part2.dtd_flags = 0x18;\n\tif (mode->flags & DRM_MODE_FLAG_PHSYNC)\n\t\tdtd->part2.dtd_flags |= 0x2;\n\tif (mode->flags & DRM_MODE_FLAG_PVSYNC)\n\t\tdtd->part2.dtd_flags |= 0x4;\n\n\tdtd->part2.sdvo_flags = 0;\n\tdtd->part2.v_sync_off_high = v_sync_offset & 0xc0;\n\tdtd->part2.reserved = 0;\n}\n\nstatic void psb_intel_sdvo_get_mode_from_dtd(struct drm_display_mode * mode,\n\t\t\t\t\t const struct psb_intel_sdvo_dtd *dtd)\n{\n\tmode->hdisplay = dtd->part1.h_active;\n\tmode->hdisplay += ((dtd->part1.h_high >> 4) & 0x0f) << 8;\n\tmode->hsync_start = mode->hdisplay + dtd->part2.h_sync_off;\n\tmode->hsync_start += (dtd->part2.sync_off_width_high & 0xc0) << 2;\n\tmode->hsync_end = mode->hsync_start + dtd->part2.h_sync_width;\n\tmode->hsync_end += (dtd->part2.sync_off_width_high & 0x30) << 4;\n\tmode->htotal = mode->hdisplay + dtd->part1.h_blank;\n\tmode->htotal += (dtd->part1.h_high & 0xf) << 8;\n\n\tmode->vdisplay = dtd->part1.v_active;\n\tmode->vdisplay += ((dtd->part1.v_high >> 4) & 0x0f) << 8;\n\tmode->vsync_start = mode->vdisplay;\n\tmode->vsync_start += (dtd->part2.v_sync_off_width >> 4) & 0xf;\n\tmode->vsync_start += (dtd->part2.sync_off_width_high & 0x0c) << 2;\n\tmode->vsync_start += dtd->part2.v_sync_off_high & 0xc0;\n\tmode->vsync_end = mode->vsync_start +\n\t\t(dtd->part2.v_sync_off_width & 0xf);\n\tmode->vsync_end += (dtd->part2.sync_off_width_high & 0x3) << 4;\n\tmode->vtotal = mode->vdisplay + dtd->part1.v_blank;\n\tmode->vtotal += (dtd->part1.v_high & 0xf) << 8;\n\n\tmode->clock = dtd->part1.clock * 10;\n\n\tmode->flags &= ~(DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC);\n\tif (dtd->part2.dtd_flags & 0x2)\n\t\tmode->flags |= DRM_MODE_FLAG_PHSYNC;\n\tif (dtd->part2.dtd_flags & 0x4)\n\t\tmode->flags |= DRM_MODE_FLAG_PVSYNC;\n}\n\nstatic bool psb_intel_sdvo_check_supp_encode(struct psb_intel_sdvo *psb_intel_sdvo)\n{\n\tstruct psb_intel_sdvo_encode encode;\n\n\tBUILD_BUG_ON(sizeof(encode) != 2);\n\treturn psb_intel_sdvo_get_value(psb_intel_sdvo,\n\t\t\t\t  SDVO_CMD_GET_SUPP_ENCODE,\n\t\t\t\t  &encode, sizeof(encode));\n}\n\nstatic bool psb_intel_sdvo_set_encode(struct psb_intel_sdvo *psb_intel_sdvo,\n\t\t\t\t  uint8_t mode)\n{\n\treturn psb_intel_sdvo_set_value(psb_intel_sdvo, SDVO_CMD_SET_ENCODE, &mode, 1);\n}\n\nstatic bool psb_intel_sdvo_set_colorimetry(struct psb_intel_sdvo *psb_intel_sdvo,\n\t\t\t\t       uint8_t mode)\n{\n\treturn psb_intel_sdvo_set_value(psb_intel_sdvo, SDVO_CMD_SET_COLORIMETRY, &mode, 1);\n}\n\n#if 0\nstatic void psb_intel_sdvo_dump_hdmi_buf(struct psb_intel_sdvo *psb_intel_sdvo)\n{\n\tint i, j;\n\tuint8_t set_buf_index[2];\n\tuint8_t av_split;\n\tuint8_t buf_size;\n\tuint8_t buf[48];\n\tuint8_t *pos;\n\n\tpsb_intel_sdvo_get_value(encoder, SDVO_CMD_GET_HBUF_AV_SPLIT, &av_split, 1);\n\n\tfor (i = 0; i <= av_split; i++) {\n\t\tset_buf_index[0] = i; set_buf_index[1] = 0;\n\t\tpsb_intel_sdvo_write_cmd(encoder, SDVO_CMD_SET_HBUF_INDEX,\n\t\t\t\t     set_buf_index, 2);\n\t\tpsb_intel_sdvo_write_cmd(encoder, SDVO_CMD_GET_HBUF_INFO, NULL, 0);\n\t\tpsb_intel_sdvo_read_response(encoder, &buf_size, 1);\n\n\t\tpos = buf;\n\t\tfor (j = 0; j <= buf_size; j += 8) {\n\t\t\tpsb_intel_sdvo_write_cmd(encoder, SDVO_CMD_GET_HBUF_DATA,\n\t\t\t\t\t     NULL, 0);\n\t\t\tpsb_intel_sdvo_read_response(encoder, pos, 8);\n\t\t\tpos += 8;\n\t\t}\n\t}\n}\n#endif\n\nstatic bool psb_intel_sdvo_set_avi_infoframe(struct psb_intel_sdvo *psb_intel_sdvo)\n{\n\tDRM_INFO(\"HDMI is not supported yet\");\n\n\treturn false;\n}\n\nstatic bool psb_intel_sdvo_set_tv_format(struct psb_intel_sdvo *psb_intel_sdvo)\n{\n\tstruct psb_intel_sdvo_tv_format format;\n\tuint32_t format_map;\n\n\tformat_map = 1 << psb_intel_sdvo->tv_format_index;\n\tmemset(&format, 0, sizeof(format));\n\tmemcpy(&format, &format_map, min(sizeof(format), sizeof(format_map)));\n\n\tBUILD_BUG_ON(sizeof(format) != 6);\n\treturn psb_intel_sdvo_set_value(psb_intel_sdvo,\n\t\t\t\t    SDVO_CMD_SET_TV_FORMAT,\n\t\t\t\t    &format, sizeof(format));\n}\n\nstatic bool\npsb_intel_sdvo_set_output_timings_from_mode(struct psb_intel_sdvo *psb_intel_sdvo,\n\t\t\t\t\tconst struct drm_display_mode *mode)\n{\n\tstruct psb_intel_sdvo_dtd output_dtd;\n\n\tif (!psb_intel_sdvo_set_target_output(psb_intel_sdvo,\n\t\t\t\t\t  psb_intel_sdvo->attached_output))\n\t\treturn false;\n\n\tpsb_intel_sdvo_get_dtd_from_mode(&output_dtd, mode);\n\tif (!psb_intel_sdvo_set_output_timing(psb_intel_sdvo, &output_dtd))\n\t\treturn false;\n\n\treturn true;\n}\n\nstatic bool\npsb_intel_sdvo_set_input_timings_for_mode(struct psb_intel_sdvo *psb_intel_sdvo,\n\t\t\t\t\tconst struct drm_display_mode *mode,\n\t\t\t\t\tstruct drm_display_mode *adjusted_mode)\n{\n\t \n\tif (!psb_intel_sdvo_set_target_input(psb_intel_sdvo))\n\t\treturn false;\n\n\tif (!psb_intel_sdvo_create_preferred_input_timing(psb_intel_sdvo,\n\t\t\t\t\t\t      mode->clock / 10,\n\t\t\t\t\t\t      mode->hdisplay,\n\t\t\t\t\t\t      mode->vdisplay))\n\t\treturn false;\n\n\tif (!psb_intel_sdvo_get_preferred_input_timing(psb_intel_sdvo,\n\t\t\t\t\t\t   &psb_intel_sdvo->input_dtd))\n\t\treturn false;\n\n\tpsb_intel_sdvo_get_mode_from_dtd(adjusted_mode, &psb_intel_sdvo->input_dtd);\n\n\tdrm_mode_set_crtcinfo(adjusted_mode, 0);\n\treturn true;\n}\n\nstatic bool psb_intel_sdvo_mode_fixup(struct drm_encoder *encoder,\n\t\t\t\t  const struct drm_display_mode *mode,\n\t\t\t\t  struct drm_display_mode *adjusted_mode)\n{\n\tstruct psb_intel_sdvo *psb_intel_sdvo = to_psb_intel_sdvo(encoder);\n\n\t \n\tif (psb_intel_sdvo->is_tv) {\n\t\tif (!psb_intel_sdvo_set_output_timings_from_mode(psb_intel_sdvo, mode))\n\t\t\treturn false;\n\n\t\t(void) psb_intel_sdvo_set_input_timings_for_mode(psb_intel_sdvo,\n\t\t\t\t\t\t\t     mode,\n\t\t\t\t\t\t\t     adjusted_mode);\n\t} else if (psb_intel_sdvo->is_lvds) {\n\t\tif (!psb_intel_sdvo_set_output_timings_from_mode(psb_intel_sdvo,\n\t\t\t\t\t\t\t     psb_intel_sdvo->sdvo_lvds_fixed_mode))\n\t\t\treturn false;\n\n\t\t(void) psb_intel_sdvo_set_input_timings_for_mode(psb_intel_sdvo,\n\t\t\t\t\t\t\t     mode,\n\t\t\t\t\t\t\t     adjusted_mode);\n\t}\n\n\t \n\tpsb_intel_sdvo->pixel_multiplier =\n\t\tpsb_intel_sdvo_get_pixel_multiplier(adjusted_mode);\n\tadjusted_mode->clock *= psb_intel_sdvo->pixel_multiplier;\n\n\treturn true;\n}\n\nstatic void psb_intel_sdvo_mode_set(struct drm_encoder *encoder,\n\t\t\t\tstruct drm_display_mode *mode,\n\t\t\t\tstruct drm_display_mode *adjusted_mode)\n{\n\tstruct drm_device *dev = encoder->dev;\n\tstruct drm_crtc *crtc = encoder->crtc;\n\tstruct gma_crtc *gma_crtc = to_gma_crtc(crtc);\n\tstruct psb_intel_sdvo *psb_intel_sdvo = to_psb_intel_sdvo(encoder);\n\tu32 sdvox;\n\tstruct psb_intel_sdvo_in_out_map in_out;\n\tstruct psb_intel_sdvo_dtd input_dtd;\n\tint rate;\n\tint need_aux = IS_MRST(dev) ? 1 : 0;\n\n\tif (!mode)\n\t\treturn;\n\n\t \n\tin_out.in0 = psb_intel_sdvo->attached_output;\n\tin_out.in1 = 0;\n\n\tpsb_intel_sdvo_set_value(psb_intel_sdvo,\n\t\t\t     SDVO_CMD_SET_IN_OUT_MAP,\n\t\t\t     &in_out, sizeof(in_out));\n\n\t \n\tif (!psb_intel_sdvo_set_target_output(psb_intel_sdvo,\n\t\t\t\t\t  psb_intel_sdvo->attached_output))\n\t\treturn;\n\n\t \n\tif (psb_intel_sdvo->is_tv || psb_intel_sdvo->is_lvds) {\n\t\tinput_dtd = psb_intel_sdvo->input_dtd;\n\t} else {\n\t\t \n\t\tif (!psb_intel_sdvo_set_target_output(psb_intel_sdvo,\n\t\t\t\t\t\t  psb_intel_sdvo->attached_output))\n\t\t\treturn;\n\n\t\tpsb_intel_sdvo_get_dtd_from_mode(&input_dtd, adjusted_mode);\n\t\t(void) psb_intel_sdvo_set_output_timing(psb_intel_sdvo, &input_dtd);\n\t}\n\n\t \n\tif (!psb_intel_sdvo_set_target_input(psb_intel_sdvo))\n\t\treturn;\n\n\tif (psb_intel_sdvo->has_hdmi_monitor) {\n\t\tpsb_intel_sdvo_set_encode(psb_intel_sdvo, SDVO_ENCODE_HDMI);\n\t\tpsb_intel_sdvo_set_colorimetry(psb_intel_sdvo,\n\t\t\t\t\t   SDVO_COLORIMETRY_RGB256);\n\t\tpsb_intel_sdvo_set_avi_infoframe(psb_intel_sdvo);\n\t} else\n\t\tpsb_intel_sdvo_set_encode(psb_intel_sdvo, SDVO_ENCODE_DVI);\n\n\tif (psb_intel_sdvo->is_tv &&\n\t    !psb_intel_sdvo_set_tv_format(psb_intel_sdvo))\n\t\treturn;\n\n\t(void) psb_intel_sdvo_set_input_timing(psb_intel_sdvo, &input_dtd);\n\n\tswitch (psb_intel_sdvo->pixel_multiplier) {\n\tdefault:\n\tcase 1: rate = SDVO_CLOCK_RATE_MULT_1X; break;\n\tcase 2: rate = SDVO_CLOCK_RATE_MULT_2X; break;\n\tcase 4: rate = SDVO_CLOCK_RATE_MULT_4X; break;\n\t}\n\tif (!psb_intel_sdvo_set_clock_rate_mult(psb_intel_sdvo, rate))\n\t\treturn;\n\n\t \n\tif (need_aux)\n\t\tsdvox = REG_READ_AUX(psb_intel_sdvo->sdvo_reg);\n\telse\n\t\tsdvox = REG_READ(psb_intel_sdvo->sdvo_reg);\n\n\tswitch (psb_intel_sdvo->sdvo_reg) {\n\tcase SDVOB:\n\t\tsdvox &= SDVOB_PRESERVE_MASK;\n\t\tbreak;\n\tcase SDVOC:\n\t\tsdvox &= SDVOC_PRESERVE_MASK;\n\t\tbreak;\n\t}\n\tsdvox |= (9 << 19) | SDVO_BORDER_ENABLE;\n\n\tif (gma_crtc->pipe == 1)\n\t\tsdvox |= SDVO_PIPE_B_SELECT;\n\tif (psb_intel_sdvo->has_hdmi_audio)\n\t\tsdvox |= SDVO_AUDIO_ENABLE;\n\n\t \n\n\tif (input_dtd.part2.sdvo_flags & SDVO_NEED_TO_STALL)\n\t\tsdvox |= SDVO_STALL_SELECT;\n\tpsb_intel_sdvo_write_sdvox(psb_intel_sdvo, sdvox);\n}\n\nstatic void psb_intel_sdvo_dpms(struct drm_encoder *encoder, int mode)\n{\n\tstruct drm_device *dev = encoder->dev;\n\tstruct psb_intel_sdvo *psb_intel_sdvo = to_psb_intel_sdvo(encoder);\n\tu32 temp;\n\tint i;\n\tint need_aux = IS_MRST(dev) ? 1 : 0;\n\n\tswitch (mode) {\n\tcase DRM_MODE_DPMS_ON:\n\t\tDRM_DEBUG(\"DPMS_ON\");\n\t\tbreak;\n\tcase DRM_MODE_DPMS_OFF:\n\t\tDRM_DEBUG(\"DPMS_OFF\");\n\t\tbreak;\n\tdefault:\n\t\tDRM_DEBUG(\"DPMS: %d\", mode);\n\t}\n\n\tif (mode != DRM_MODE_DPMS_ON) {\n\t\tpsb_intel_sdvo_set_active_outputs(psb_intel_sdvo, 0);\n\t\tif (0)\n\t\t\tpsb_intel_sdvo_set_encoder_power_state(psb_intel_sdvo, mode);\n\n\t\tif (mode == DRM_MODE_DPMS_OFF) {\n\t\t\tif (need_aux)\n\t\t\t\ttemp = REG_READ_AUX(psb_intel_sdvo->sdvo_reg);\n\t\t\telse\n\t\t\t\ttemp = REG_READ(psb_intel_sdvo->sdvo_reg);\n\n\t\t\tif ((temp & SDVO_ENABLE) != 0) {\n\t\t\t\tpsb_intel_sdvo_write_sdvox(psb_intel_sdvo, temp & ~SDVO_ENABLE);\n\t\t\t}\n\t\t}\n\t} else {\n\t\tbool input1, input2;\n\t\tu8 status;\n\n\t\tif (need_aux)\n\t\t\ttemp = REG_READ_AUX(psb_intel_sdvo->sdvo_reg);\n\t\telse\n\t\t\ttemp = REG_READ(psb_intel_sdvo->sdvo_reg);\n\n\t\tif ((temp & SDVO_ENABLE) == 0)\n\t\t\tpsb_intel_sdvo_write_sdvox(psb_intel_sdvo, temp | SDVO_ENABLE);\n\n\t\tfor (i = 0; i < 2; i++)\n\t\t\tgma_wait_for_vblank(dev);\n\n\t\tstatus = psb_intel_sdvo_get_trained_inputs(psb_intel_sdvo, &input1, &input2);\n\t\t \n\t\tif (status == SDVO_CMD_STATUS_SUCCESS && !input1) {\n\t\t\tDRM_DEBUG_KMS(\"First %s output reported failure to \"\n\t\t\t\t\t\"sync\\n\", SDVO_NAME(psb_intel_sdvo));\n\t\t}\n\n\t\tif (0)\n\t\t\tpsb_intel_sdvo_set_encoder_power_state(psb_intel_sdvo, mode);\n\t\tpsb_intel_sdvo_set_active_outputs(psb_intel_sdvo, psb_intel_sdvo->attached_output);\n\t}\n\treturn;\n}\n\nstatic enum drm_mode_status psb_intel_sdvo_mode_valid(struct drm_connector *connector,\n\t\t\t\t struct drm_display_mode *mode)\n{\n\tstruct psb_intel_sdvo *psb_intel_sdvo = intel_attached_sdvo(connector);\n\n\tif (mode->flags & DRM_MODE_FLAG_DBLSCAN)\n\t\treturn MODE_NO_DBLESCAN;\n\n\tif (psb_intel_sdvo->pixel_clock_min > mode->clock)\n\t\treturn MODE_CLOCK_LOW;\n\n\tif (psb_intel_sdvo->pixel_clock_max < mode->clock)\n\t\treturn MODE_CLOCK_HIGH;\n\n\tif (psb_intel_sdvo->is_lvds) {\n\t\tif (mode->hdisplay > psb_intel_sdvo->sdvo_lvds_fixed_mode->hdisplay)\n\t\t\treturn MODE_PANEL;\n\n\t\tif (mode->vdisplay > psb_intel_sdvo->sdvo_lvds_fixed_mode->vdisplay)\n\t\t\treturn MODE_PANEL;\n\t}\n\n\treturn MODE_OK;\n}\n\nstatic bool psb_intel_sdvo_get_capabilities(struct psb_intel_sdvo *psb_intel_sdvo, struct psb_intel_sdvo_caps *caps)\n{\n\tBUILD_BUG_ON(sizeof(*caps) != 8);\n\tif (!psb_intel_sdvo_get_value(psb_intel_sdvo,\n\t\t\t\t  SDVO_CMD_GET_DEVICE_CAPS,\n\t\t\t\t  caps, sizeof(*caps)))\n\t\treturn false;\n\n\tDRM_DEBUG_KMS(\"SDVO capabilities:\\n\"\n\t\t      \"  vendor_id: %d\\n\"\n\t\t      \"  device_id: %d\\n\"\n\t\t      \"  device_rev_id: %d\\n\"\n\t\t      \"  sdvo_version_major: %d\\n\"\n\t\t      \"  sdvo_version_minor: %d\\n\"\n\t\t      \"  sdvo_inputs_mask: %d\\n\"\n\t\t      \"  smooth_scaling: %d\\n\"\n\t\t      \"  sharp_scaling: %d\\n\"\n\t\t      \"  up_scaling: %d\\n\"\n\t\t      \"  down_scaling: %d\\n\"\n\t\t      \"  stall_support: %d\\n\"\n\t\t      \"  output_flags: %d\\n\",\n\t\t      caps->vendor_id,\n\t\t      caps->device_id,\n\t\t      caps->device_rev_id,\n\t\t      caps->sdvo_version_major,\n\t\t      caps->sdvo_version_minor,\n\t\t      caps->sdvo_inputs_mask,\n\t\t      caps->smooth_scaling,\n\t\t      caps->sharp_scaling,\n\t\t      caps->up_scaling,\n\t\t      caps->down_scaling,\n\t\t      caps->stall_support,\n\t\t      caps->output_flags);\n\n\treturn true;\n}\n\nstatic bool\npsb_intel_sdvo_multifunc_encoder(struct psb_intel_sdvo *psb_intel_sdvo)\n{\n\t \n\tint caps = psb_intel_sdvo->caps.output_flags & 0xf;\n\treturn caps & -caps;\n}\n\nstatic struct edid *\npsb_intel_sdvo_get_edid(struct drm_connector *connector)\n{\n\tstruct psb_intel_sdvo *sdvo = intel_attached_sdvo(connector);\n\treturn drm_get_edid(connector, &sdvo->ddc);\n}\n\n \nstatic struct edid *\npsb_intel_sdvo_get_analog_edid(struct drm_connector *connector)\n{\n\tstruct drm_psb_private *dev_priv = to_drm_psb_private(connector->dev);\n\n\treturn drm_get_edid(connector,\n\t\t\t    &dev_priv->gmbus[dev_priv->crt_ddc_pin].adapter);\n}\n\nstatic enum drm_connector_status\npsb_intel_sdvo_hdmi_sink_detect(struct drm_connector *connector)\n{\n\tstruct psb_intel_sdvo *psb_intel_sdvo = intel_attached_sdvo(connector);\n\tenum drm_connector_status status;\n\tstruct edid *edid;\n\n\tedid = psb_intel_sdvo_get_edid(connector);\n\n\tif (edid == NULL && psb_intel_sdvo_multifunc_encoder(psb_intel_sdvo)) {\n\t\tu8 ddc, saved_ddc = psb_intel_sdvo->ddc_bus;\n\n\t\t \n\t\tfor (ddc = psb_intel_sdvo->ddc_bus >> 1; ddc > 1; ddc >>= 1) {\n\t\t\tpsb_intel_sdvo->ddc_bus = ddc;\n\t\t\tedid = psb_intel_sdvo_get_edid(connector);\n\t\t\tif (edid)\n\t\t\t\tbreak;\n\t\t}\n\t\t \n\t\tif (edid == NULL)\n\t\t\tpsb_intel_sdvo->ddc_bus = saved_ddc;\n\t}\n\n\t \n\tif (edid == NULL)\n\t\tedid = psb_intel_sdvo_get_analog_edid(connector);\n\n\tstatus = connector_status_unknown;\n\tif (edid != NULL) {\n\t\t \n\t\tif (edid->input & DRM_EDID_INPUT_DIGITAL) {\n\t\t\tstatus = connector_status_connected;\n\t\t\tif (psb_intel_sdvo->is_hdmi) {\n\t\t\t\tpsb_intel_sdvo->has_hdmi_monitor = drm_detect_hdmi_monitor(edid);\n\t\t\t\tpsb_intel_sdvo->has_hdmi_audio = drm_detect_monitor_audio(edid);\n\t\t\t}\n\t\t} else\n\t\t\tstatus = connector_status_disconnected;\n\t\tkfree(edid);\n\t}\n\n\tif (status == connector_status_connected) {\n\t\tstruct psb_intel_sdvo_connector *psb_intel_sdvo_connector = to_psb_intel_sdvo_connector(connector);\n\t\tif (psb_intel_sdvo_connector->force_audio)\n\t\t\tpsb_intel_sdvo->has_hdmi_audio = psb_intel_sdvo_connector->force_audio > 0;\n\t}\n\n\treturn status;\n}\n\nstatic enum drm_connector_status\npsb_intel_sdvo_detect(struct drm_connector *connector, bool force)\n{\n\tuint16_t response;\n\tstruct psb_intel_sdvo *psb_intel_sdvo = intel_attached_sdvo(connector);\n\tstruct psb_intel_sdvo_connector *psb_intel_sdvo_connector = to_psb_intel_sdvo_connector(connector);\n\tenum drm_connector_status ret;\n\n\tif (!psb_intel_sdvo_write_cmd(psb_intel_sdvo,\n\t\t\t\t  SDVO_CMD_GET_ATTACHED_DISPLAYS, NULL, 0))\n\t\treturn connector_status_unknown;\n\n\t \n\tif (psb_intel_sdvo->caps.output_flags &\n\t    (SDVO_OUTPUT_SVID0 | SDVO_OUTPUT_CVBS0))\n\t\tmdelay(30);\n\n\tif (!psb_intel_sdvo_read_response(psb_intel_sdvo, &response, 2))\n\t\treturn connector_status_unknown;\n\n\tDRM_DEBUG_KMS(\"SDVO response %d %d [%x]\\n\",\n\t\t      response & 0xff, response >> 8,\n\t\t      psb_intel_sdvo_connector->output_flag);\n\n\tif (response == 0)\n\t\treturn connector_status_disconnected;\n\n\tpsb_intel_sdvo->attached_output = response;\n\n\tpsb_intel_sdvo->has_hdmi_monitor = false;\n\tpsb_intel_sdvo->has_hdmi_audio = false;\n\n\tif ((psb_intel_sdvo_connector->output_flag & response) == 0)\n\t\tret = connector_status_disconnected;\n\telse if (IS_TMDS(psb_intel_sdvo_connector))\n\t\tret = psb_intel_sdvo_hdmi_sink_detect(connector);\n\telse {\n\t\tstruct edid *edid;\n\n\t\t \n\t\tedid = psb_intel_sdvo_get_edid(connector);\n\t\tif (edid == NULL)\n\t\t\tedid = psb_intel_sdvo_get_analog_edid(connector);\n\t\tif (edid != NULL) {\n\t\t\tif (edid->input & DRM_EDID_INPUT_DIGITAL)\n\t\t\t\tret = connector_status_disconnected;\n\t\t\telse\n\t\t\t\tret = connector_status_connected;\n\t\t\tkfree(edid);\n\t\t} else\n\t\t\tret = connector_status_connected;\n\t}\n\n\t \n\tif (ret == connector_status_connected) {\n\t\tpsb_intel_sdvo->is_tv = false;\n\t\tpsb_intel_sdvo->is_lvds = false;\n\t\tpsb_intel_sdvo->base.needs_tv_clock = false;\n\n\t\tif (response & SDVO_TV_MASK) {\n\t\t\tpsb_intel_sdvo->is_tv = true;\n\t\t\tpsb_intel_sdvo->base.needs_tv_clock = true;\n\t\t}\n\t\tif (response & SDVO_LVDS_MASK)\n\t\t\tpsb_intel_sdvo->is_lvds = psb_intel_sdvo->sdvo_lvds_fixed_mode != NULL;\n\t}\n\n\treturn ret;\n}\n\nstatic void psb_intel_sdvo_get_ddc_modes(struct drm_connector *connector)\n{\n\tstruct edid *edid;\n\n\t \n\tedid = psb_intel_sdvo_get_edid(connector);\n\n\t \n\tif (edid == NULL)\n\t\tedid = psb_intel_sdvo_get_analog_edid(connector);\n\n\tif (edid != NULL) {\n\t\tstruct psb_intel_sdvo_connector *psb_intel_sdvo_connector = to_psb_intel_sdvo_connector(connector);\n\t\tbool monitor_is_digital = !!(edid->input & DRM_EDID_INPUT_DIGITAL);\n\t\tbool connector_is_digital = !!IS_TMDS(psb_intel_sdvo_connector);\n\n\t\tif (connector_is_digital == monitor_is_digital) {\n\t\t\tdrm_connector_update_edid_property(connector, edid);\n\t\t\tdrm_add_edid_modes(connector, edid);\n\t\t}\n\n\t\tkfree(edid);\n\t}\n}\n\n \nstatic const struct drm_display_mode sdvo_tv_modes[] = {\n\t{ DRM_MODE(\"320x200\", DRM_MODE_TYPE_DRIVER, 5815, 320, 321, 384,\n\t\t   416, 0, 200, 201, 232, 233, 0,\n\t\t   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC) },\n\t{ DRM_MODE(\"320x240\", DRM_MODE_TYPE_DRIVER, 6814, 320, 321, 384,\n\t\t   416, 0, 240, 241, 272, 273, 0,\n\t\t   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC) },\n\t{ DRM_MODE(\"400x300\", DRM_MODE_TYPE_DRIVER, 9910, 400, 401, 464,\n\t\t   496, 0, 300, 301, 332, 333, 0,\n\t\t   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC) },\n\t{ DRM_MODE(\"640x350\", DRM_MODE_TYPE_DRIVER, 16913, 640, 641, 704,\n\t\t   736, 0, 350, 351, 382, 383, 0,\n\t\t   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC) },\n\t{ DRM_MODE(\"640x400\", DRM_MODE_TYPE_DRIVER, 19121, 640, 641, 704,\n\t\t   736, 0, 400, 401, 432, 433, 0,\n\t\t   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC) },\n\t{ DRM_MODE(\"640x480\", DRM_MODE_TYPE_DRIVER, 22654, 640, 641, 704,\n\t\t   736, 0, 480, 481, 512, 513, 0,\n\t\t   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC) },\n\t{ DRM_MODE(\"704x480\", DRM_MODE_TYPE_DRIVER, 24624, 704, 705, 768,\n\t\t   800, 0, 480, 481, 512, 513, 0,\n\t\t   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC) },\n\t{ DRM_MODE(\"704x576\", DRM_MODE_TYPE_DRIVER, 29232, 704, 705, 768,\n\t\t   800, 0, 576, 577, 608, 609, 0,\n\t\t   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC) },\n\t{ DRM_MODE(\"720x350\", DRM_MODE_TYPE_DRIVER, 18751, 720, 721, 784,\n\t\t   816, 0, 350, 351, 382, 383, 0,\n\t\t   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC) },\n\t{ DRM_MODE(\"720x400\", DRM_MODE_TYPE_DRIVER, 21199, 720, 721, 784,\n\t\t   816, 0, 400, 401, 432, 433, 0,\n\t\t   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC) },\n\t{ DRM_MODE(\"720x480\", DRM_MODE_TYPE_DRIVER, 25116, 720, 721, 784,\n\t\t   816, 0, 480, 481, 512, 513, 0,\n\t\t   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC) },\n\t{ DRM_MODE(\"720x540\", DRM_MODE_TYPE_DRIVER, 28054, 720, 721, 784,\n\t\t   816, 0, 540, 541, 572, 573, 0,\n\t\t   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC) },\n\t{ DRM_MODE(\"720x576\", DRM_MODE_TYPE_DRIVER, 29816, 720, 721, 784,\n\t\t   816, 0, 576, 577, 608, 609, 0,\n\t\t   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC) },\n\t{ DRM_MODE(\"768x576\", DRM_MODE_TYPE_DRIVER, 31570, 768, 769, 832,\n\t\t   864, 0, 576, 577, 608, 609, 0,\n\t\t   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC) },\n\t{ DRM_MODE(\"800x600\", DRM_MODE_TYPE_DRIVER, 34030, 800, 801, 864,\n\t\t   896, 0, 600, 601, 632, 633, 0,\n\t\t   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC) },\n\t{ DRM_MODE(\"832x624\", DRM_MODE_TYPE_DRIVER, 36581, 832, 833, 896,\n\t\t   928, 0, 624, 625, 656, 657, 0,\n\t\t   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC) },\n\t{ DRM_MODE(\"920x766\", DRM_MODE_TYPE_DRIVER, 48707, 920, 921, 984,\n\t\t   1016, 0, 766, 767, 798, 799, 0,\n\t\t   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC) },\n\t{ DRM_MODE(\"1024x768\", DRM_MODE_TYPE_DRIVER, 53827, 1024, 1025, 1088,\n\t\t   1120, 0, 768, 769, 800, 801, 0,\n\t\t   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC) },\n\t{ DRM_MODE(\"1280x1024\", DRM_MODE_TYPE_DRIVER, 87265, 1280, 1281, 1344,\n\t\t   1376, 0, 1024, 1025, 1056, 1057, 0,\n\t\t   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC) },\n};\n\nstatic void psb_intel_sdvo_get_tv_modes(struct drm_connector *connector)\n{\n\tstruct psb_intel_sdvo *psb_intel_sdvo = intel_attached_sdvo(connector);\n\tstruct psb_intel_sdvo_sdtv_resolution_request tv_res;\n\tuint32_t reply = 0, format_map = 0;\n\tint i;\n\n\t \n\tformat_map = 1 << psb_intel_sdvo->tv_format_index;\n\tmemcpy(&tv_res, &format_map,\n\t       min(sizeof(format_map), sizeof(struct psb_intel_sdvo_sdtv_resolution_request)));\n\n\tif (!psb_intel_sdvo_set_target_output(psb_intel_sdvo, psb_intel_sdvo->attached_output))\n\t\treturn;\n\n\tBUILD_BUG_ON(sizeof(tv_res) != 3);\n\tif (!psb_intel_sdvo_write_cmd(psb_intel_sdvo,\n\t\t\t\t  SDVO_CMD_GET_SDTV_RESOLUTION_SUPPORT,\n\t\t\t\t  &tv_res, sizeof(tv_res)))\n\t\treturn;\n\tif (!psb_intel_sdvo_read_response(psb_intel_sdvo, &reply, 3))\n\t\treturn;\n\n\tfor (i = 0; i < ARRAY_SIZE(sdvo_tv_modes); i++)\n\t\tif (reply & (1 << i)) {\n\t\t\tstruct drm_display_mode *nmode;\n\t\t\tnmode = drm_mode_duplicate(connector->dev,\n\t\t\t\t\t\t   &sdvo_tv_modes[i]);\n\t\t\tif (nmode)\n\t\t\t\tdrm_mode_probed_add(connector, nmode);\n\t\t}\n}\n\nstatic void psb_intel_sdvo_get_lvds_modes(struct drm_connector *connector)\n{\n\tstruct psb_intel_sdvo *psb_intel_sdvo = intel_attached_sdvo(connector);\n\tstruct drm_psb_private *dev_priv = to_drm_psb_private(connector->dev);\n\tstruct drm_display_mode *newmode;\n\n\t \n\tpsb_intel_ddc_get_modes(connector, psb_intel_sdvo->i2c);\n\tif (list_empty(&connector->probed_modes) == false)\n\t\tgoto end;\n\n\t \n\tif (dev_priv->sdvo_lvds_vbt_mode != NULL) {\n\t\tnewmode = drm_mode_duplicate(connector->dev,\n\t\t\t\t\t     dev_priv->sdvo_lvds_vbt_mode);\n\t\tif (newmode != NULL) {\n\t\t\t \n\t\t\tnewmode->type = (DRM_MODE_TYPE_PREFERRED |\n\t\t\t\t\t DRM_MODE_TYPE_DRIVER);\n\t\t\tdrm_mode_probed_add(connector, newmode);\n\t\t}\n\t}\n\nend:\n\tlist_for_each_entry(newmode, &connector->probed_modes, head) {\n\t\tif (newmode->type & DRM_MODE_TYPE_PREFERRED) {\n\t\t\tpsb_intel_sdvo->sdvo_lvds_fixed_mode =\n\t\t\t\tdrm_mode_duplicate(connector->dev, newmode);\n\n\t\t\tdrm_mode_set_crtcinfo(psb_intel_sdvo->sdvo_lvds_fixed_mode,\n\t\t\t\t\t      0);\n\n\t\t\tpsb_intel_sdvo->is_lvds = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\n}\n\nstatic int psb_intel_sdvo_get_modes(struct drm_connector *connector)\n{\n\tstruct psb_intel_sdvo_connector *psb_intel_sdvo_connector = to_psb_intel_sdvo_connector(connector);\n\n\tif (IS_TV(psb_intel_sdvo_connector))\n\t\tpsb_intel_sdvo_get_tv_modes(connector);\n\telse if (IS_LVDS(psb_intel_sdvo_connector))\n\t\tpsb_intel_sdvo_get_lvds_modes(connector);\n\telse\n\t\tpsb_intel_sdvo_get_ddc_modes(connector);\n\n\treturn !list_empty(&connector->probed_modes);\n}\n\nstatic void psb_intel_sdvo_destroy(struct drm_connector *connector)\n{\n\tstruct gma_connector *gma_connector = to_gma_connector(connector);\n\n\tdrm_connector_cleanup(connector);\n\tkfree(gma_connector);\n}\n\nstatic bool psb_intel_sdvo_detect_hdmi_audio(struct drm_connector *connector)\n{\n\tstruct psb_intel_sdvo *psb_intel_sdvo = intel_attached_sdvo(connector);\n\tstruct edid *edid;\n\tbool has_audio = false;\n\n\tif (!psb_intel_sdvo->is_hdmi)\n\t\treturn false;\n\n\tedid = psb_intel_sdvo_get_edid(connector);\n\tif (edid != NULL && edid->input & DRM_EDID_INPUT_DIGITAL)\n\t\thas_audio = drm_detect_monitor_audio(edid);\n\n\treturn has_audio;\n}\n\nstatic int\npsb_intel_sdvo_set_property(struct drm_connector *connector,\n\t\t\tstruct drm_property *property,\n\t\t\tuint64_t val)\n{\n\tstruct psb_intel_sdvo *psb_intel_sdvo = intel_attached_sdvo(connector);\n\tstruct psb_intel_sdvo_connector *psb_intel_sdvo_connector = to_psb_intel_sdvo_connector(connector);\n\tstruct drm_psb_private *dev_priv = to_drm_psb_private(connector->dev);\n\tuint16_t temp_value;\n\tuint8_t cmd;\n\tint ret;\n\n\tret = drm_object_property_set_value(&connector->base, property, val);\n\tif (ret)\n\t\treturn ret;\n\n\tif (property == dev_priv->force_audio_property) {\n\t\tint i = val;\n\t\tbool has_audio;\n\n\t\tif (i == psb_intel_sdvo_connector->force_audio)\n\t\t\treturn 0;\n\n\t\tpsb_intel_sdvo_connector->force_audio = i;\n\n\t\tif (i == 0)\n\t\t\thas_audio = psb_intel_sdvo_detect_hdmi_audio(connector);\n\t\telse\n\t\t\thas_audio = i > 0;\n\n\t\tif (has_audio == psb_intel_sdvo->has_hdmi_audio)\n\t\t\treturn 0;\n\n\t\tpsb_intel_sdvo->has_hdmi_audio = has_audio;\n\t\tgoto done;\n\t}\n\n\tif (property == dev_priv->broadcast_rgb_property) {\n\t\tif (val == !!psb_intel_sdvo->color_range)\n\t\t\treturn 0;\n\n\t\tpsb_intel_sdvo->color_range = val ? SDVO_COLOR_RANGE_16_235 : 0;\n\t\tgoto done;\n\t}\n\n#define CHECK_PROPERTY(name, NAME) \\\n\tif (psb_intel_sdvo_connector->name == property) { \\\n\t\tif (psb_intel_sdvo_connector->cur_##name == temp_value) return 0; \\\n\t\tif (psb_intel_sdvo_connector->max_##name < temp_value) return -EINVAL; \\\n\t\tcmd = SDVO_CMD_SET_##NAME; \\\n\t\tpsb_intel_sdvo_connector->cur_##name = temp_value; \\\n\t\tgoto set_value; \\\n\t}\n\n\tif (property == psb_intel_sdvo_connector->tv_format) {\n\t\tif (val >= ARRAY_SIZE(tv_format_names))\n\t\t\treturn -EINVAL;\n\n\t\tif (psb_intel_sdvo->tv_format_index ==\n\t\t    psb_intel_sdvo_connector->tv_format_supported[val])\n\t\t\treturn 0;\n\n\t\tpsb_intel_sdvo->tv_format_index = psb_intel_sdvo_connector->tv_format_supported[val];\n\t\tgoto done;\n\t} else if (IS_TV_OR_LVDS(psb_intel_sdvo_connector)) {\n\t\ttemp_value = val;\n\t\tif (psb_intel_sdvo_connector->left == property) {\n\t\t\tdrm_object_property_set_value(&connector->base,\n\t\t\t\t\t\t\t psb_intel_sdvo_connector->right, val);\n\t\t\tif (psb_intel_sdvo_connector->left_margin == temp_value)\n\t\t\t\treturn 0;\n\n\t\t\tpsb_intel_sdvo_connector->left_margin = temp_value;\n\t\t\tpsb_intel_sdvo_connector->right_margin = temp_value;\n\t\t\ttemp_value = psb_intel_sdvo_connector->max_hscan -\n\t\t\t\tpsb_intel_sdvo_connector->left_margin;\n\t\t\tcmd = SDVO_CMD_SET_OVERSCAN_H;\n\t\t\tgoto set_value;\n\t\t} else if (psb_intel_sdvo_connector->right == property) {\n\t\t\tdrm_object_property_set_value(&connector->base,\n\t\t\t\t\t\t\t psb_intel_sdvo_connector->left, val);\n\t\t\tif (psb_intel_sdvo_connector->right_margin == temp_value)\n\t\t\t\treturn 0;\n\n\t\t\tpsb_intel_sdvo_connector->left_margin = temp_value;\n\t\t\tpsb_intel_sdvo_connector->right_margin = temp_value;\n\t\t\ttemp_value = psb_intel_sdvo_connector->max_hscan -\n\t\t\t\tpsb_intel_sdvo_connector->left_margin;\n\t\t\tcmd = SDVO_CMD_SET_OVERSCAN_H;\n\t\t\tgoto set_value;\n\t\t} else if (psb_intel_sdvo_connector->top == property) {\n\t\t\tdrm_object_property_set_value(&connector->base,\n\t\t\t\t\t\t\t psb_intel_sdvo_connector->bottom, val);\n\t\t\tif (psb_intel_sdvo_connector->top_margin == temp_value)\n\t\t\t\treturn 0;\n\n\t\t\tpsb_intel_sdvo_connector->top_margin = temp_value;\n\t\t\tpsb_intel_sdvo_connector->bottom_margin = temp_value;\n\t\t\ttemp_value = psb_intel_sdvo_connector->max_vscan -\n\t\t\t\tpsb_intel_sdvo_connector->top_margin;\n\t\t\tcmd = SDVO_CMD_SET_OVERSCAN_V;\n\t\t\tgoto set_value;\n\t\t} else if (psb_intel_sdvo_connector->bottom == property) {\n\t\t\tdrm_object_property_set_value(&connector->base,\n\t\t\t\t\t\t\t psb_intel_sdvo_connector->top, val);\n\t\t\tif (psb_intel_sdvo_connector->bottom_margin == temp_value)\n\t\t\t\treturn 0;\n\n\t\t\tpsb_intel_sdvo_connector->top_margin = temp_value;\n\t\t\tpsb_intel_sdvo_connector->bottom_margin = temp_value;\n\t\t\ttemp_value = psb_intel_sdvo_connector->max_vscan -\n\t\t\t\tpsb_intel_sdvo_connector->top_margin;\n\t\t\tcmd = SDVO_CMD_SET_OVERSCAN_V;\n\t\t\tgoto set_value;\n\t\t}\n\t\tCHECK_PROPERTY(hpos, HPOS)\n\t\tCHECK_PROPERTY(vpos, VPOS)\n\t\tCHECK_PROPERTY(saturation, SATURATION)\n\t\tCHECK_PROPERTY(contrast, CONTRAST)\n\t\tCHECK_PROPERTY(hue, HUE)\n\t\tCHECK_PROPERTY(brightness, BRIGHTNESS)\n\t\tCHECK_PROPERTY(sharpness, SHARPNESS)\n\t\tCHECK_PROPERTY(flicker_filter, FLICKER_FILTER)\n\t\tCHECK_PROPERTY(flicker_filter_2d, FLICKER_FILTER_2D)\n\t\tCHECK_PROPERTY(flicker_filter_adaptive, FLICKER_FILTER_ADAPTIVE)\n\t\tCHECK_PROPERTY(tv_chroma_filter, TV_CHROMA_FILTER)\n\t\tCHECK_PROPERTY(tv_luma_filter, TV_LUMA_FILTER)\n\t\tCHECK_PROPERTY(dot_crawl, DOT_CRAWL)\n\t}\n\n\treturn -EINVAL;  \n\nset_value:\n\tif (!psb_intel_sdvo_set_value(psb_intel_sdvo, cmd, &temp_value, 2))\n\t\treturn -EIO;\n\n\ndone:\n\tif (psb_intel_sdvo->base.base.crtc) {\n\t\tstruct drm_crtc *crtc = psb_intel_sdvo->base.base.crtc;\n\t\tdrm_crtc_helper_set_mode(crtc, &crtc->mode, crtc->x,\n\t\t\t\t\t crtc->y, crtc->primary->fb);\n\t}\n\n\treturn 0;\n#undef CHECK_PROPERTY\n}\n\nstatic void psb_intel_sdvo_save(struct drm_connector *connector)\n{\n\tstruct drm_device *dev = connector->dev;\n\tstruct gma_encoder *gma_encoder = gma_attached_encoder(connector);\n\tstruct psb_intel_sdvo *sdvo = to_psb_intel_sdvo(&gma_encoder->base);\n\n\tsdvo->saveSDVO = REG_READ(sdvo->sdvo_reg);\n}\n\nstatic void psb_intel_sdvo_restore(struct drm_connector *connector)\n{\n\tstruct drm_device *dev = connector->dev;\n\tstruct drm_encoder *encoder = &gma_attached_encoder(connector)->base;\n\tstruct psb_intel_sdvo *sdvo = to_psb_intel_sdvo(encoder);\n\tstruct drm_crtc *crtc = encoder->crtc;\n\n\tREG_WRITE(sdvo->sdvo_reg, sdvo->saveSDVO);\n\n\t \n\tif (connector->status == connector_status_connected)\n\t\tdrm_crtc_helper_set_mode(crtc, &crtc->mode, crtc->x, crtc->y,\n\t\t\t\t\t NULL);\n}\n\nstatic const struct drm_encoder_helper_funcs psb_intel_sdvo_helper_funcs = {\n\t.dpms = psb_intel_sdvo_dpms,\n\t.mode_fixup = psb_intel_sdvo_mode_fixup,\n\t.prepare = gma_encoder_prepare,\n\t.mode_set = psb_intel_sdvo_mode_set,\n\t.commit = gma_encoder_commit,\n};\n\nstatic const struct drm_connector_funcs psb_intel_sdvo_connector_funcs = {\n\t.dpms = drm_helper_connector_dpms,\n\t.detect = psb_intel_sdvo_detect,\n\t.fill_modes = drm_helper_probe_single_connector_modes,\n\t.set_property = psb_intel_sdvo_set_property,\n\t.destroy = psb_intel_sdvo_destroy,\n};\n\nstatic const struct drm_connector_helper_funcs psb_intel_sdvo_connector_helper_funcs = {\n\t.get_modes = psb_intel_sdvo_get_modes,\n\t.mode_valid = psb_intel_sdvo_mode_valid,\n\t.best_encoder = gma_best_encoder,\n};\n\nstatic void psb_intel_sdvo_enc_destroy(struct drm_encoder *encoder)\n{\n\tstruct psb_intel_sdvo *psb_intel_sdvo = to_psb_intel_sdvo(encoder);\n\n\tif (psb_intel_sdvo->sdvo_lvds_fixed_mode != NULL)\n\t\tdrm_mode_destroy(encoder->dev,\n\t\t\t\t psb_intel_sdvo->sdvo_lvds_fixed_mode);\n\n\ti2c_del_adapter(&psb_intel_sdvo->ddc);\n\tgma_encoder_destroy(encoder);\n}\n\nstatic const struct drm_encoder_funcs psb_intel_sdvo_enc_funcs = {\n\t.destroy = psb_intel_sdvo_enc_destroy,\n};\n\nstatic void\npsb_intel_sdvo_guess_ddc_bus(struct psb_intel_sdvo *sdvo)\n{\n\t \n\tsdvo->ddc_bus = 2;\n\n#if 0\n\tuint16_t mask = 0;\n\tunsigned int num_bits;\n\n\t \n\tswitch (sdvo->controlled_output) {\n\tcase SDVO_OUTPUT_LVDS1:\n\t\tmask |= SDVO_OUTPUT_LVDS1;\n\tcase SDVO_OUTPUT_LVDS0:\n\t\tmask |= SDVO_OUTPUT_LVDS0;\n\tcase SDVO_OUTPUT_TMDS1:\n\t\tmask |= SDVO_OUTPUT_TMDS1;\n\tcase SDVO_OUTPUT_TMDS0:\n\t\tmask |= SDVO_OUTPUT_TMDS0;\n\tcase SDVO_OUTPUT_RGB1:\n\t\tmask |= SDVO_OUTPUT_RGB1;\n\tcase SDVO_OUTPUT_RGB0:\n\t\tmask |= SDVO_OUTPUT_RGB0;\n\t\tbreak;\n\t}\n\n\t \n\tmask &= sdvo->caps.output_flags;\n\tnum_bits = hweight16(mask);\n\t \n\tif (num_bits > 3)\n\t\tnum_bits = 3;\n\n\t \n\tsdvo->ddc_bus = 1 << num_bits;\n#endif\n}\n\n \nstatic void\npsb_intel_sdvo_select_ddc_bus(struct drm_psb_private *dev_priv,\n\t\t\t  struct psb_intel_sdvo *sdvo, u32 reg)\n{\n\tstruct sdvo_device_mapping *mapping;\n\n\tif (IS_SDVOB(reg))\n\t\tmapping = &(dev_priv->sdvo_mappings[0]);\n\telse\n\t\tmapping = &(dev_priv->sdvo_mappings[1]);\n\n\tif (mapping->initialized)\n\t\tsdvo->ddc_bus = 1 << ((mapping->ddc_pin & 0xf0) >> 4);\n\telse\n\t\tpsb_intel_sdvo_guess_ddc_bus(sdvo);\n}\n\nstatic void\npsb_intel_sdvo_select_i2c_bus(struct drm_psb_private *dev_priv,\n\t\t\t  struct psb_intel_sdvo *sdvo, u32 reg)\n{\n\tstruct sdvo_device_mapping *mapping;\n\tu8 pin, speed;\n\n\tif (IS_SDVOB(reg))\n\t\tmapping = &dev_priv->sdvo_mappings[0];\n\telse\n\t\tmapping = &dev_priv->sdvo_mappings[1];\n\n\tpin = GMBUS_PORT_DPB;\n\tspeed = GMBUS_RATE_1MHZ >> 8;\n\tif (mapping->initialized) {\n\t\tpin = mapping->i2c_pin;\n\t\tspeed = mapping->i2c_speed;\n\t}\n\n\tif (pin < GMBUS_NUM_PORTS) {\n\t\tsdvo->i2c = &dev_priv->gmbus[pin].adapter;\n\t\tgma_intel_gmbus_set_speed(sdvo->i2c, speed);\n\t\tgma_intel_gmbus_force_bit(sdvo->i2c, true);\n\t} else\n\t\tsdvo->i2c = &dev_priv->gmbus[GMBUS_PORT_DPB].adapter;\n}\n\nstatic bool\npsb_intel_sdvo_is_hdmi_connector(struct psb_intel_sdvo *psb_intel_sdvo, int device)\n{\n\treturn psb_intel_sdvo_check_supp_encode(psb_intel_sdvo);\n}\n\nstatic u8\npsb_intel_sdvo_get_slave_addr(struct drm_device *dev, int sdvo_reg)\n{\n\tstruct drm_psb_private *dev_priv = to_drm_psb_private(dev);\n\tstruct sdvo_device_mapping *my_mapping, *other_mapping;\n\n\tif (IS_SDVOB(sdvo_reg)) {\n\t\tmy_mapping = &dev_priv->sdvo_mappings[0];\n\t\tother_mapping = &dev_priv->sdvo_mappings[1];\n\t} else {\n\t\tmy_mapping = &dev_priv->sdvo_mappings[1];\n\t\tother_mapping = &dev_priv->sdvo_mappings[0];\n\t}\n\n\t \n\tif (my_mapping->slave_addr)\n\t\treturn my_mapping->slave_addr;\n\n\t \n\tif (other_mapping->slave_addr) {\n\t\tif (other_mapping->slave_addr == 0x70)\n\t\t\treturn 0x72;\n\t\telse\n\t\t\treturn 0x70;\n\t}\n\n\t \n\tif (IS_SDVOB(sdvo_reg))\n\t\treturn 0x70;\n\telse\n\t\treturn 0x72;\n}\n\nstatic void\npsb_intel_sdvo_connector_init(struct psb_intel_sdvo_connector *connector,\n\t\t\t  struct psb_intel_sdvo *encoder)\n{\n\tdrm_connector_init(encoder->base.base.dev,\n\t\t\t   &connector->base.base,\n\t\t\t   &psb_intel_sdvo_connector_funcs,\n\t\t\t   connector->base.base.connector_type);\n\n\tdrm_connector_helper_add(&connector->base.base,\n\t\t\t\t &psb_intel_sdvo_connector_helper_funcs);\n\n\tconnector->base.base.interlace_allowed = 0;\n\tconnector->base.base.doublescan_allowed = 0;\n\tconnector->base.base.display_info.subpixel_order = SubPixelHorizontalRGB;\n\n\tconnector->base.save = psb_intel_sdvo_save;\n\tconnector->base.restore = psb_intel_sdvo_restore;\n\n\tgma_connector_attach_encoder(&connector->base, &encoder->base);\n}\n\nstatic void\npsb_intel_sdvo_add_hdmi_properties(struct psb_intel_sdvo_connector *connector)\n{\n\t \n}\n\nstatic bool\npsb_intel_sdvo_dvi_init(struct psb_intel_sdvo *psb_intel_sdvo, int device)\n{\n\tstruct drm_encoder *encoder = &psb_intel_sdvo->base.base;\n\tstruct drm_connector *connector;\n\tstruct gma_connector *intel_connector;\n\tstruct psb_intel_sdvo_connector *psb_intel_sdvo_connector;\n\n\tpsb_intel_sdvo_connector = kzalloc(sizeof(struct psb_intel_sdvo_connector), GFP_KERNEL);\n\tif (!psb_intel_sdvo_connector)\n\t\treturn false;\n\n\tif (device == 0) {\n\t\tpsb_intel_sdvo->controlled_output |= SDVO_OUTPUT_TMDS0;\n\t\tpsb_intel_sdvo_connector->output_flag = SDVO_OUTPUT_TMDS0;\n\t} else if (device == 1) {\n\t\tpsb_intel_sdvo->controlled_output |= SDVO_OUTPUT_TMDS1;\n\t\tpsb_intel_sdvo_connector->output_flag = SDVO_OUTPUT_TMDS1;\n\t}\n\n\tintel_connector = &psb_intel_sdvo_connector->base;\n\tconnector = &intel_connector->base;\n\t\n\tencoder->encoder_type = DRM_MODE_ENCODER_TMDS;\n\tconnector->connector_type = DRM_MODE_CONNECTOR_DVID;\n\n\tif (psb_intel_sdvo_is_hdmi_connector(psb_intel_sdvo, device)) {\n\t\tconnector->connector_type = DRM_MODE_CONNECTOR_HDMIA;\n\t\tpsb_intel_sdvo->is_hdmi = true;\n\t}\n\tpsb_intel_sdvo->base.clone_mask = ((1 << INTEL_SDVO_NON_TV_CLONE_BIT) |\n\t\t\t\t       (1 << INTEL_ANALOG_CLONE_BIT));\n\n\tpsb_intel_sdvo_connector_init(psb_intel_sdvo_connector, psb_intel_sdvo);\n\tif (psb_intel_sdvo->is_hdmi)\n\t\tpsb_intel_sdvo_add_hdmi_properties(psb_intel_sdvo_connector);\n\n\treturn true;\n}\n\nstatic bool\npsb_intel_sdvo_tv_init(struct psb_intel_sdvo *psb_intel_sdvo, int type)\n{\n\tstruct drm_encoder *encoder = &psb_intel_sdvo->base.base;\n\tstruct drm_connector *connector;\n\tstruct gma_connector *intel_connector;\n\tstruct psb_intel_sdvo_connector *psb_intel_sdvo_connector;\n\n\tpsb_intel_sdvo_connector = kzalloc(sizeof(struct psb_intel_sdvo_connector), GFP_KERNEL);\n\tif (!psb_intel_sdvo_connector)\n\t\treturn false;\n\n\tintel_connector = &psb_intel_sdvo_connector->base;\n\tconnector = &intel_connector->base;\n\tencoder->encoder_type = DRM_MODE_ENCODER_TVDAC;\n\tconnector->connector_type = DRM_MODE_CONNECTOR_SVIDEO;\n\n\tpsb_intel_sdvo->controlled_output |= type;\n\tpsb_intel_sdvo_connector->output_flag = type;\n\n\tpsb_intel_sdvo->is_tv = true;\n\tpsb_intel_sdvo->base.needs_tv_clock = true;\n\tpsb_intel_sdvo->base.clone_mask = 1 << INTEL_SDVO_TV_CLONE_BIT;\n\n\tpsb_intel_sdvo_connector_init(psb_intel_sdvo_connector, psb_intel_sdvo);\n\n\tif (!psb_intel_sdvo_tv_create_property(psb_intel_sdvo, psb_intel_sdvo_connector, type))\n\t\tgoto err;\n\n\tif (!psb_intel_sdvo_create_enhance_property(psb_intel_sdvo, psb_intel_sdvo_connector))\n\t\tgoto err;\n\n\treturn true;\n\nerr:\n\tpsb_intel_sdvo_destroy(connector);\n\treturn false;\n}\n\nstatic bool\npsb_intel_sdvo_analog_init(struct psb_intel_sdvo *psb_intel_sdvo, int device)\n{\n\tstruct drm_encoder *encoder = &psb_intel_sdvo->base.base;\n\tstruct drm_connector *connector;\n\tstruct gma_connector *intel_connector;\n\tstruct psb_intel_sdvo_connector *psb_intel_sdvo_connector;\n\n\tpsb_intel_sdvo_connector = kzalloc(sizeof(struct psb_intel_sdvo_connector), GFP_KERNEL);\n\tif (!psb_intel_sdvo_connector)\n\t\treturn false;\n\n\tintel_connector = &psb_intel_sdvo_connector->base;\n\tconnector = &intel_connector->base;\n\tconnector->polled = DRM_CONNECTOR_POLL_CONNECT;\n\tencoder->encoder_type = DRM_MODE_ENCODER_DAC;\n\tconnector->connector_type = DRM_MODE_CONNECTOR_VGA;\n\n\tif (device == 0) {\n\t\tpsb_intel_sdvo->controlled_output |= SDVO_OUTPUT_RGB0;\n\t\tpsb_intel_sdvo_connector->output_flag = SDVO_OUTPUT_RGB0;\n\t} else if (device == 1) {\n\t\tpsb_intel_sdvo->controlled_output |= SDVO_OUTPUT_RGB1;\n\t\tpsb_intel_sdvo_connector->output_flag = SDVO_OUTPUT_RGB1;\n\t}\n\n\tpsb_intel_sdvo->base.clone_mask = ((1 << INTEL_SDVO_NON_TV_CLONE_BIT) |\n\t\t\t\t       (1 << INTEL_ANALOG_CLONE_BIT));\n\n\tpsb_intel_sdvo_connector_init(psb_intel_sdvo_connector,\n\t\t\t\t  psb_intel_sdvo);\n\treturn true;\n}\n\nstatic bool\npsb_intel_sdvo_lvds_init(struct psb_intel_sdvo *psb_intel_sdvo, int device)\n{\n\tstruct drm_encoder *encoder = &psb_intel_sdvo->base.base;\n\tstruct drm_connector *connector;\n\tstruct gma_connector *intel_connector;\n\tstruct psb_intel_sdvo_connector *psb_intel_sdvo_connector;\n\n\tpsb_intel_sdvo_connector = kzalloc(sizeof(struct psb_intel_sdvo_connector), GFP_KERNEL);\n\tif (!psb_intel_sdvo_connector)\n\t\treturn false;\n\n\tintel_connector = &psb_intel_sdvo_connector->base;\n\tconnector = &intel_connector->base;\n\tencoder->encoder_type = DRM_MODE_ENCODER_LVDS;\n\tconnector->connector_type = DRM_MODE_CONNECTOR_LVDS;\n\n\tif (device == 0) {\n\t\tpsb_intel_sdvo->controlled_output |= SDVO_OUTPUT_LVDS0;\n\t\tpsb_intel_sdvo_connector->output_flag = SDVO_OUTPUT_LVDS0;\n\t} else if (device == 1) {\n\t\tpsb_intel_sdvo->controlled_output |= SDVO_OUTPUT_LVDS1;\n\t\tpsb_intel_sdvo_connector->output_flag = SDVO_OUTPUT_LVDS1;\n\t}\n\n\tpsb_intel_sdvo->base.clone_mask = ((1 << INTEL_ANALOG_CLONE_BIT) |\n\t\t\t\t       (1 << INTEL_SDVO_LVDS_CLONE_BIT));\n\n\tpsb_intel_sdvo_connector_init(psb_intel_sdvo_connector, psb_intel_sdvo);\n\tif (!psb_intel_sdvo_create_enhance_property(psb_intel_sdvo, psb_intel_sdvo_connector))\n\t\tgoto err;\n\n\treturn true;\n\nerr:\n\tpsb_intel_sdvo_destroy(connector);\n\treturn false;\n}\n\nstatic bool\npsb_intel_sdvo_output_setup(struct psb_intel_sdvo *psb_intel_sdvo, uint16_t flags)\n{\n\tpsb_intel_sdvo->is_tv = false;\n\tpsb_intel_sdvo->base.needs_tv_clock = false;\n\tpsb_intel_sdvo->is_lvds = false;\n\n\t \n\n\tif (flags & SDVO_OUTPUT_TMDS0)\n\t\tif (!psb_intel_sdvo_dvi_init(psb_intel_sdvo, 0))\n\t\t\treturn false;\n\n\tif ((flags & SDVO_TMDS_MASK) == SDVO_TMDS_MASK)\n\t\tif (!psb_intel_sdvo_dvi_init(psb_intel_sdvo, 1))\n\t\t\treturn false;\n\n\t \n\tif (flags & SDVO_OUTPUT_SVID0)\n\t\tif (!psb_intel_sdvo_tv_init(psb_intel_sdvo, SDVO_OUTPUT_SVID0))\n\t\t\treturn false;\n\n\tif (flags & SDVO_OUTPUT_CVBS0)\n\t\tif (!psb_intel_sdvo_tv_init(psb_intel_sdvo, SDVO_OUTPUT_CVBS0))\n\t\t\treturn false;\n\n\tif (flags & SDVO_OUTPUT_RGB0)\n\t\tif (!psb_intel_sdvo_analog_init(psb_intel_sdvo, 0))\n\t\t\treturn false;\n\n\tif ((flags & SDVO_RGB_MASK) == SDVO_RGB_MASK)\n\t\tif (!psb_intel_sdvo_analog_init(psb_intel_sdvo, 1))\n\t\t\treturn false;\n\n\tif (flags & SDVO_OUTPUT_LVDS0)\n\t\tif (!psb_intel_sdvo_lvds_init(psb_intel_sdvo, 0))\n\t\t\treturn false;\n\n\tif ((flags & SDVO_LVDS_MASK) == SDVO_LVDS_MASK)\n\t\tif (!psb_intel_sdvo_lvds_init(psb_intel_sdvo, 1))\n\t\t\treturn false;\n\n\tif ((flags & SDVO_OUTPUT_MASK) == 0) {\n\t\tunsigned char bytes[2];\n\n\t\tpsb_intel_sdvo->controlled_output = 0;\n\t\tmemcpy(bytes, &psb_intel_sdvo->caps.output_flags, 2);\n\t\tDRM_DEBUG_KMS(\"%s: Unknown SDVO output type (0x%02x%02x)\\n\",\n\t\t\t      SDVO_NAME(psb_intel_sdvo),\n\t\t\t      bytes[0], bytes[1]);\n\t\treturn false;\n\t}\n\tpsb_intel_sdvo->base.crtc_mask = (1 << 0) | (1 << 1);\n\n\treturn true;\n}\n\nstatic bool psb_intel_sdvo_tv_create_property(struct psb_intel_sdvo *psb_intel_sdvo,\n\t\t\t\t\t  struct psb_intel_sdvo_connector *psb_intel_sdvo_connector,\n\t\t\t\t\t  int type)\n{\n\tstruct drm_device *dev = psb_intel_sdvo->base.base.dev;\n\tstruct psb_intel_sdvo_tv_format format;\n\tuint32_t format_map, i;\n\n\tif (!psb_intel_sdvo_set_target_output(psb_intel_sdvo, type))\n\t\treturn false;\n\n\tBUILD_BUG_ON(sizeof(format) != 6);\n\tif (!psb_intel_sdvo_get_value(psb_intel_sdvo,\n\t\t\t\t  SDVO_CMD_GET_SUPPORTED_TV_FORMATS,\n\t\t\t\t  &format, sizeof(format)))\n\t\treturn false;\n\n\tmemcpy(&format_map, &format, min(sizeof(format_map), sizeof(format)));\n\n\tif (format_map == 0)\n\t\treturn false;\n\n\tpsb_intel_sdvo_connector->format_supported_num = 0;\n\tfor (i = 0 ; i < ARRAY_SIZE(tv_format_names); i++)\n\t\tif (format_map & (1 << i))\n\t\t\tpsb_intel_sdvo_connector->tv_format_supported[psb_intel_sdvo_connector->format_supported_num++] = i;\n\n\n\tpsb_intel_sdvo_connector->tv_format =\n\t\t\tdrm_property_create(dev, DRM_MODE_PROP_ENUM,\n\t\t\t\t\t    \"mode\", psb_intel_sdvo_connector->format_supported_num);\n\tif (!psb_intel_sdvo_connector->tv_format)\n\t\treturn false;\n\n\tfor (i = 0; i < psb_intel_sdvo_connector->format_supported_num; i++)\n\t\tdrm_property_add_enum(\n\t\t\t\tpsb_intel_sdvo_connector->tv_format,\n\t\t\t\ti, tv_format_names[psb_intel_sdvo_connector->tv_format_supported[i]]);\n\n\tpsb_intel_sdvo->tv_format_index = psb_intel_sdvo_connector->tv_format_supported[0];\n\tdrm_object_attach_property(&psb_intel_sdvo_connector->base.base.base,\n\t\t\t\t      psb_intel_sdvo_connector->tv_format, 0);\n\treturn true;\n\n}\n\n#define ENHANCEMENT(name, NAME) do { \\\n\tif (enhancements.name) { \\\n\t\tif (!psb_intel_sdvo_get_value(psb_intel_sdvo, SDVO_CMD_GET_MAX_##NAME, &data_value, 4) || \\\n\t\t    !psb_intel_sdvo_get_value(psb_intel_sdvo, SDVO_CMD_GET_##NAME, &response, 2)) \\\n\t\t\treturn false; \\\n\t\tpsb_intel_sdvo_connector->max_##name = data_value[0]; \\\n\t\tpsb_intel_sdvo_connector->cur_##name = response; \\\n\t\tpsb_intel_sdvo_connector->name = \\\n\t\t\tdrm_property_create_range(dev, 0, #name, 0, data_value[0]); \\\n\t\tif (!psb_intel_sdvo_connector->name) return false; \\\n\t\tdrm_object_attach_property(&connector->base, \\\n\t\t\t\t\t      psb_intel_sdvo_connector->name, \\\n\t\t\t\t\t      psb_intel_sdvo_connector->cur_##name); \\\n\t\tDRM_DEBUG_KMS(#name \": max %d, default %d, current %d\\n\", \\\n\t\t\t      data_value[0], data_value[1], response); \\\n\t} \\\n} while(0)\n\nstatic bool\npsb_intel_sdvo_create_enhance_property_tv(struct psb_intel_sdvo *psb_intel_sdvo,\n\t\t\t\t      struct psb_intel_sdvo_connector *psb_intel_sdvo_connector,\n\t\t\t\t      struct psb_intel_sdvo_enhancements_reply enhancements)\n{\n\tstruct drm_device *dev = psb_intel_sdvo->base.base.dev;\n\tstruct drm_connector *connector = &psb_intel_sdvo_connector->base.base;\n\tuint16_t response, data_value[2];\n\n\t \n\tif (enhancements.overscan_h) {\n\t\tif (!psb_intel_sdvo_get_value(psb_intel_sdvo,\n\t\t\t\t\t  SDVO_CMD_GET_MAX_OVERSCAN_H,\n\t\t\t\t\t  &data_value, 4))\n\t\t\treturn false;\n\n\t\tif (!psb_intel_sdvo_get_value(psb_intel_sdvo,\n\t\t\t\t\t  SDVO_CMD_GET_OVERSCAN_H,\n\t\t\t\t\t  &response, 2))\n\t\t\treturn false;\n\n\t\tpsb_intel_sdvo_connector->max_hscan = data_value[0];\n\t\tpsb_intel_sdvo_connector->left_margin = data_value[0] - response;\n\t\tpsb_intel_sdvo_connector->right_margin = psb_intel_sdvo_connector->left_margin;\n\t\tpsb_intel_sdvo_connector->left =\n\t\t\tdrm_property_create_range(dev, 0, \"left_margin\", 0, data_value[0]);\n\t\tif (!psb_intel_sdvo_connector->left)\n\t\t\treturn false;\n\n\t\tdrm_object_attach_property(&connector->base,\n\t\t\t\t\t      psb_intel_sdvo_connector->left,\n\t\t\t\t\t      psb_intel_sdvo_connector->left_margin);\n\n\t\tpsb_intel_sdvo_connector->right =\n\t\t\tdrm_property_create_range(dev, 0, \"right_margin\", 0, data_value[0]);\n\t\tif (!psb_intel_sdvo_connector->right)\n\t\t\treturn false;\n\n\t\tdrm_object_attach_property(&connector->base,\n\t\t\t\t\t      psb_intel_sdvo_connector->right,\n\t\t\t\t\t      psb_intel_sdvo_connector->right_margin);\n\t\tDRM_DEBUG_KMS(\"h_overscan: max %d, \"\n\t\t\t      \"default %d, current %d\\n\",\n\t\t\t      data_value[0], data_value[1], response);\n\t}\n\n\tif (enhancements.overscan_v) {\n\t\tif (!psb_intel_sdvo_get_value(psb_intel_sdvo,\n\t\t\t\t\t  SDVO_CMD_GET_MAX_OVERSCAN_V,\n\t\t\t\t\t  &data_value, 4))\n\t\t\treturn false;\n\n\t\tif (!psb_intel_sdvo_get_value(psb_intel_sdvo,\n\t\t\t\t\t  SDVO_CMD_GET_OVERSCAN_V,\n\t\t\t\t\t  &response, 2))\n\t\t\treturn false;\n\n\t\tpsb_intel_sdvo_connector->max_vscan = data_value[0];\n\t\tpsb_intel_sdvo_connector->top_margin = data_value[0] - response;\n\t\tpsb_intel_sdvo_connector->bottom_margin = psb_intel_sdvo_connector->top_margin;\n\t\tpsb_intel_sdvo_connector->top =\n\t\t\tdrm_property_create_range(dev, 0, \"top_margin\", 0, data_value[0]);\n\t\tif (!psb_intel_sdvo_connector->top)\n\t\t\treturn false;\n\n\t\tdrm_object_attach_property(&connector->base,\n\t\t\t\t\t      psb_intel_sdvo_connector->top,\n\t\t\t\t\t      psb_intel_sdvo_connector->top_margin);\n\n\t\tpsb_intel_sdvo_connector->bottom =\n\t\t\tdrm_property_create_range(dev, 0, \"bottom_margin\", 0, data_value[0]);\n\t\tif (!psb_intel_sdvo_connector->bottom)\n\t\t\treturn false;\n\n\t\tdrm_object_attach_property(&connector->base,\n\t\t\t\t\t      psb_intel_sdvo_connector->bottom,\n\t\t\t\t\t      psb_intel_sdvo_connector->bottom_margin);\n\t\tDRM_DEBUG_KMS(\"v_overscan: max %d, \"\n\t\t\t      \"default %d, current %d\\n\",\n\t\t\t      data_value[0], data_value[1], response);\n\t}\n\n\tENHANCEMENT(hpos, HPOS);\n\tENHANCEMENT(vpos, VPOS);\n\tENHANCEMENT(saturation, SATURATION);\n\tENHANCEMENT(contrast, CONTRAST);\n\tENHANCEMENT(hue, HUE);\n\tENHANCEMENT(sharpness, SHARPNESS);\n\tENHANCEMENT(brightness, BRIGHTNESS);\n\tENHANCEMENT(flicker_filter, FLICKER_FILTER);\n\tENHANCEMENT(flicker_filter_adaptive, FLICKER_FILTER_ADAPTIVE);\n\tENHANCEMENT(flicker_filter_2d, FLICKER_FILTER_2D);\n\tENHANCEMENT(tv_chroma_filter, TV_CHROMA_FILTER);\n\tENHANCEMENT(tv_luma_filter, TV_LUMA_FILTER);\n\n\tif (enhancements.dot_crawl) {\n\t\tif (!psb_intel_sdvo_get_value(psb_intel_sdvo, SDVO_CMD_GET_DOT_CRAWL, &response, 2))\n\t\t\treturn false;\n\n\t\tpsb_intel_sdvo_connector->max_dot_crawl = 1;\n\t\tpsb_intel_sdvo_connector->cur_dot_crawl = response & 0x1;\n\t\tpsb_intel_sdvo_connector->dot_crawl =\n\t\t\tdrm_property_create_range(dev, 0, \"dot_crawl\", 0, 1);\n\t\tif (!psb_intel_sdvo_connector->dot_crawl)\n\t\t\treturn false;\n\n\t\tdrm_object_attach_property(&connector->base,\n\t\t\t\t\t      psb_intel_sdvo_connector->dot_crawl,\n\t\t\t\t\t      psb_intel_sdvo_connector->cur_dot_crawl);\n\t\tDRM_DEBUG_KMS(\"dot crawl: current %d\\n\", response);\n\t}\n\n\treturn true;\n}\n\nstatic bool\npsb_intel_sdvo_create_enhance_property_lvds(struct psb_intel_sdvo *psb_intel_sdvo,\n\t\t\t\t\tstruct psb_intel_sdvo_connector *psb_intel_sdvo_connector,\n\t\t\t\t\tstruct psb_intel_sdvo_enhancements_reply enhancements)\n{\n\tstruct drm_device *dev = psb_intel_sdvo->base.base.dev;\n\tstruct drm_connector *connector = &psb_intel_sdvo_connector->base.base;\n\tuint16_t response, data_value[2];\n\n\tENHANCEMENT(brightness, BRIGHTNESS);\n\n\treturn true;\n}\n#undef ENHANCEMENT\n\nstatic bool psb_intel_sdvo_create_enhance_property(struct psb_intel_sdvo *psb_intel_sdvo,\n\t\t\t\t\t       struct psb_intel_sdvo_connector *psb_intel_sdvo_connector)\n{\n\tunion {\n\t\tstruct psb_intel_sdvo_enhancements_reply reply;\n\t\tuint16_t response;\n\t} enhancements;\n\n\tBUILD_BUG_ON(sizeof(enhancements) != 2);\n\n\tenhancements.response = 0;\n\tpsb_intel_sdvo_get_value(psb_intel_sdvo,\n\t\t\t     SDVO_CMD_GET_SUPPORTED_ENHANCEMENTS,\n\t\t\t     &enhancements, sizeof(enhancements));\n\tif (enhancements.response == 0) {\n\t\tDRM_DEBUG_KMS(\"No enhancement is supported\\n\");\n\t\treturn true;\n\t}\n\n\tif (IS_TV(psb_intel_sdvo_connector))\n\t\treturn psb_intel_sdvo_create_enhance_property_tv(psb_intel_sdvo, psb_intel_sdvo_connector, enhancements.reply);\n\telse if(IS_LVDS(psb_intel_sdvo_connector))\n\t\treturn psb_intel_sdvo_create_enhance_property_lvds(psb_intel_sdvo, psb_intel_sdvo_connector, enhancements.reply);\n\telse\n\t\treturn true;\n}\n\nstatic int psb_intel_sdvo_ddc_proxy_xfer(struct i2c_adapter *adapter,\n\t\t\t\t     struct i2c_msg *msgs,\n\t\t\t\t     int num)\n{\n\tstruct psb_intel_sdvo *sdvo = adapter->algo_data;\n\n\tif (!psb_intel_sdvo_set_control_bus_switch(sdvo, sdvo->ddc_bus))\n\t\treturn -EIO;\n\n\treturn sdvo->i2c->algo->master_xfer(sdvo->i2c, msgs, num);\n}\n\nstatic u32 psb_intel_sdvo_ddc_proxy_func(struct i2c_adapter *adapter)\n{\n\tstruct psb_intel_sdvo *sdvo = adapter->algo_data;\n\treturn sdvo->i2c->algo->functionality(sdvo->i2c);\n}\n\nstatic const struct i2c_algorithm psb_intel_sdvo_ddc_proxy = {\n\t.master_xfer\t= psb_intel_sdvo_ddc_proxy_xfer,\n\t.functionality\t= psb_intel_sdvo_ddc_proxy_func\n};\n\nstatic bool\npsb_intel_sdvo_init_ddc_proxy(struct psb_intel_sdvo *sdvo,\n\t\t\t  struct drm_device *dev)\n{\n\tsdvo->ddc.owner = THIS_MODULE;\n\tsdvo->ddc.class = I2C_CLASS_DDC;\n\tsnprintf(sdvo->ddc.name, I2C_NAME_SIZE, \"SDVO DDC proxy\");\n\tsdvo->ddc.dev.parent = dev->dev;\n\tsdvo->ddc.algo_data = sdvo;\n\tsdvo->ddc.algo = &psb_intel_sdvo_ddc_proxy;\n\n\treturn i2c_add_adapter(&sdvo->ddc) == 0;\n}\n\nbool psb_intel_sdvo_init(struct drm_device *dev, int sdvo_reg)\n{\n\tstruct drm_psb_private *dev_priv = to_drm_psb_private(dev);\n\tstruct gma_encoder *gma_encoder;\n\tstruct psb_intel_sdvo *psb_intel_sdvo;\n\tint i;\n\n\tpsb_intel_sdvo = kzalloc(sizeof(struct psb_intel_sdvo), GFP_KERNEL);\n\tif (!psb_intel_sdvo)\n\t\treturn false;\n\n\tpsb_intel_sdvo->sdvo_reg = sdvo_reg;\n\tpsb_intel_sdvo->slave_addr = psb_intel_sdvo_get_slave_addr(dev, sdvo_reg) >> 1;\n\tpsb_intel_sdvo_select_i2c_bus(dev_priv, psb_intel_sdvo, sdvo_reg);\n\tif (!psb_intel_sdvo_init_ddc_proxy(psb_intel_sdvo, dev)) {\n\t\tkfree(psb_intel_sdvo);\n\t\treturn false;\n\t}\n\n\t \n\tgma_encoder = &psb_intel_sdvo->base;\n\tgma_encoder->type = INTEL_OUTPUT_SDVO;\n\tdrm_encoder_init(dev, &gma_encoder->base, &psb_intel_sdvo_enc_funcs,\n\t\t\t 0, NULL);\n\n\t \n\tfor (i = 0; i < 0x40; i++) {\n\t\tu8 byte;\n\n\t\tif (!psb_intel_sdvo_read_byte(psb_intel_sdvo, i, &byte)) {\n\t\t\tDRM_DEBUG_KMS(\"No SDVO device found on SDVO%c\\n\",\n\t\t\t\t      IS_SDVOB(sdvo_reg) ? 'B' : 'C');\n\t\t\tgoto err;\n\t\t}\n\t}\n\n\tif (IS_SDVOB(sdvo_reg))\n\t\tdev_priv->hotplug_supported_mask |= SDVOB_HOTPLUG_INT_STATUS;\n\telse\n\t\tdev_priv->hotplug_supported_mask |= SDVOC_HOTPLUG_INT_STATUS;\n\n\tdrm_encoder_helper_add(&gma_encoder->base, &psb_intel_sdvo_helper_funcs);\n\n\t \n\tif (!psb_intel_sdvo_get_capabilities(psb_intel_sdvo, &psb_intel_sdvo->caps))\n\t\tgoto err;\n\n\tif (psb_intel_sdvo_output_setup(psb_intel_sdvo,\n\t\t\t\t    psb_intel_sdvo->caps.output_flags) != true) {\n\t\tDRM_DEBUG_KMS(\"SDVO output failed to setup on SDVO%c\\n\",\n\t\t\t      IS_SDVOB(sdvo_reg) ? 'B' : 'C');\n\t\tgoto err;\n\t}\n\n\tpsb_intel_sdvo_select_ddc_bus(dev_priv, psb_intel_sdvo, sdvo_reg);\n\n\t \n\tif (!psb_intel_sdvo_set_target_input(psb_intel_sdvo))\n\t\tgoto err;\n\n\tif (!psb_intel_sdvo_get_input_pixel_clock_range(psb_intel_sdvo,\n\t\t\t\t\t\t    &psb_intel_sdvo->pixel_clock_min,\n\t\t\t\t\t\t    &psb_intel_sdvo->pixel_clock_max))\n\t\tgoto err;\n\n\tDRM_DEBUG_KMS(\"%s device VID/DID: %02X:%02X.%02X, \"\n\t\t\t\"clock range %dMHz - %dMHz, \"\n\t\t\t\"input 1: %c, input 2: %c, \"\n\t\t\t\"output 1: %c, output 2: %c\\n\",\n\t\t\tSDVO_NAME(psb_intel_sdvo),\n\t\t\tpsb_intel_sdvo->caps.vendor_id, psb_intel_sdvo->caps.device_id,\n\t\t\tpsb_intel_sdvo->caps.device_rev_id,\n\t\t\tpsb_intel_sdvo->pixel_clock_min / 1000,\n\t\t\tpsb_intel_sdvo->pixel_clock_max / 1000,\n\t\t\t(psb_intel_sdvo->caps.sdvo_inputs_mask & 0x1) ? 'Y' : 'N',\n\t\t\t(psb_intel_sdvo->caps.sdvo_inputs_mask & 0x2) ? 'Y' : 'N',\n\t\t\t \n\t\t\tpsb_intel_sdvo->caps.output_flags &\n\t\t\t(SDVO_OUTPUT_TMDS0 | SDVO_OUTPUT_RGB0) ? 'Y' : 'N',\n\t\t\tpsb_intel_sdvo->caps.output_flags &\n\t\t\t(SDVO_OUTPUT_TMDS1 | SDVO_OUTPUT_RGB1) ? 'Y' : 'N');\n\treturn true;\n\nerr:\n\tdrm_encoder_cleanup(&gma_encoder->base);\n\ti2c_del_adapter(&psb_intel_sdvo->ddc);\n\tkfree(psb_intel_sdvo);\n\n\treturn false;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}