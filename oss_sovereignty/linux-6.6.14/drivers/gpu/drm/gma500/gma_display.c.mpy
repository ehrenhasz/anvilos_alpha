{
  "module_name": "gma_display.c",
  "hash_id": "327cb518f373fbb4ff4a0e1bd85c838edd36102c55ff69610db729f8fd6ccce2",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/gma500/gma_display.c",
  "human_readable_source": "\n \n\n#include <linux/delay.h>\n#include <linux/highmem.h>\n\n#include <drm/drm_crtc.h>\n#include <drm/drm_crtc_helper.h>\n#include <drm/drm_fourcc.h>\n#include <drm/drm_framebuffer.h>\n#include <drm/drm_modeset_helper_vtables.h>\n#include <drm/drm_vblank.h>\n\n#include \"framebuffer.h\"\n#include \"gem.h\"\n#include \"gma_display.h\"\n#include \"psb_irq.h\"\n#include \"psb_intel_drv.h\"\n#include \"psb_intel_reg.h\"\n\n \nbool gma_pipe_has_type(struct drm_crtc *crtc, int type)\n{\n\tstruct drm_device *dev = crtc->dev;\n\tstruct drm_connector_list_iter conn_iter;\n\tstruct drm_connector *connector;\n\n\tdrm_connector_list_iter_begin(dev, &conn_iter);\n\tdrm_for_each_connector_iter(connector, &conn_iter) {\n\t\tif (connector->encoder && connector->encoder->crtc == crtc) {\n\t\t\tstruct gma_encoder *gma_encoder =\n\t\t\t\t\t\tgma_attached_encoder(connector);\n\t\t\tif (gma_encoder->type == type) {\n\t\t\t\tdrm_connector_list_iter_end(&conn_iter);\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t}\n\tdrm_connector_list_iter_end(&conn_iter);\n\n\treturn false;\n}\n\nvoid gma_wait_for_vblank(struct drm_device *dev)\n{\n\t \n\tmdelay(20);\n}\n\nint gma_pipe_set_base(struct drm_crtc *crtc, int x, int y,\n\t\t      struct drm_framebuffer *old_fb)\n{\n\tstruct drm_device *dev = crtc->dev;\n\tstruct drm_psb_private *dev_priv = to_drm_psb_private(dev);\n\tstruct gma_crtc *gma_crtc = to_gma_crtc(crtc);\n\tstruct drm_framebuffer *fb = crtc->primary->fb;\n\tstruct psb_gem_object *pobj;\n\tint pipe = gma_crtc->pipe;\n\tconst struct psb_offset *map = &dev_priv->regmap[pipe];\n\tunsigned long start, offset;\n\tu32 dspcntr;\n\tint ret = 0;\n\n\tif (!gma_power_begin(dev, true))\n\t\treturn 0;\n\n\t \n\tif (!fb) {\n\t\tdev_err(dev->dev, \"No FB bound\\n\");\n\t\tgoto gma_pipe_cleaner;\n\t}\n\n\tpobj = to_psb_gem_object(fb->obj[0]);\n\n\t \n\tret = psb_gem_pin(pobj);\n\tif (ret < 0)\n\t\tgoto gma_pipe_set_base_exit;\n\tstart = pobj->offset;\n\toffset = y * fb->pitches[0] + x * fb->format->cpp[0];\n\n\tREG_WRITE(map->stride, fb->pitches[0]);\n\n\tdspcntr = REG_READ(map->cntr);\n\tdspcntr &= ~DISPPLANE_PIXFORMAT_MASK;\n\n\tswitch (fb->format->cpp[0] * 8) {\n\tcase 8:\n\t\tdspcntr |= DISPPLANE_8BPP;\n\t\tbreak;\n\tcase 16:\n\t\tif (fb->format->depth == 15)\n\t\t\tdspcntr |= DISPPLANE_15_16BPP;\n\t\telse\n\t\t\tdspcntr |= DISPPLANE_16BPP;\n\t\tbreak;\n\tcase 24:\n\tcase 32:\n\t\tdspcntr |= DISPPLANE_32BPP_NO_ALPHA;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(dev->dev, \"Unknown color depth\\n\");\n\t\tret = -EINVAL;\n\t\tgoto gma_pipe_set_base_exit;\n\t}\n\tREG_WRITE(map->cntr, dspcntr);\n\n\tdev_dbg(dev->dev,\n\t\t\"Writing base %08lX %08lX %d %d\\n\", start, offset, x, y);\n\n\t \n\tif (IS_PSB(dev)) {\n\t\tREG_WRITE(map->base, offset + start);\n\t\tREG_READ(map->base);\n\t} else {\n\t\tREG_WRITE(map->base, offset);\n\t\tREG_READ(map->base);\n\t\tREG_WRITE(map->surf, start);\n\t\tREG_READ(map->surf);\n\t}\n\ngma_pipe_cleaner:\n\t \n\tif (old_fb)\n\t\tpsb_gem_unpin(to_psb_gem_object(old_fb->obj[0]));\n\ngma_pipe_set_base_exit:\n\tgma_power_end(dev);\n\treturn ret;\n}\n\n \nvoid gma_crtc_load_lut(struct drm_crtc *crtc)\n{\n\tstruct drm_device *dev = crtc->dev;\n\tstruct drm_psb_private *dev_priv = to_drm_psb_private(dev);\n\tstruct gma_crtc *gma_crtc = to_gma_crtc(crtc);\n\tconst struct psb_offset *map = &dev_priv->regmap[gma_crtc->pipe];\n\tint palreg = map->palette;\n\tu16 *r, *g, *b;\n\tint i;\n\n\t \n\tif (!crtc->enabled)\n\t\treturn;\n\n\tr = crtc->gamma_store;\n\tg = r + crtc->gamma_size;\n\tb = g + crtc->gamma_size;\n\n\tif (gma_power_begin(dev, false)) {\n\t\tfor (i = 0; i < 256; i++) {\n\t\t\tREG_WRITE(palreg + 4 * i,\n\t\t\t\t  (((*r++ >> 8) + gma_crtc->lut_adj[i]) << 16) |\n\t\t\t\t  (((*g++ >> 8) + gma_crtc->lut_adj[i]) << 8) |\n\t\t\t\t  ((*b++ >> 8) + gma_crtc->lut_adj[i]));\n\t\t}\n\t\tgma_power_end(dev);\n\t} else {\n\t\tfor (i = 0; i < 256; i++) {\n\t\t\t \n\t\t\tdev_priv->regs.pipe[0].palette[i] =\n\t\t\t\t(((*r++ >> 8) + gma_crtc->lut_adj[i]) << 16) |\n\t\t\t\t(((*g++ >> 8) + gma_crtc->lut_adj[i]) << 8) |\n\t\t\t\t((*b++ >> 8) + gma_crtc->lut_adj[i]);\n\t\t}\n\n\t}\n}\n\nstatic int gma_crtc_gamma_set(struct drm_crtc *crtc, u16 *red, u16 *green,\n\t\t\t      u16 *blue, u32 size,\n\t\t\t      struct drm_modeset_acquire_ctx *ctx)\n{\n\tgma_crtc_load_lut(crtc);\n\n\treturn 0;\n}\n\n \nvoid gma_crtc_dpms(struct drm_crtc *crtc, int mode)\n{\n\tstruct drm_device *dev = crtc->dev;\n\tstruct drm_psb_private *dev_priv = to_drm_psb_private(dev);\n\tstruct gma_crtc *gma_crtc = to_gma_crtc(crtc);\n\tint pipe = gma_crtc->pipe;\n\tconst struct psb_offset *map = &dev_priv->regmap[pipe];\n\tu32 temp;\n\n\t \n\n\tif (IS_CDV(dev))\n\t\tdev_priv->ops->disable_sr(dev);\n\n\tswitch (mode) {\n\tcase DRM_MODE_DPMS_ON:\n\tcase DRM_MODE_DPMS_STANDBY:\n\tcase DRM_MODE_DPMS_SUSPEND:\n\t\tif (gma_crtc->active)\n\t\t\tbreak;\n\n\t\tgma_crtc->active = true;\n\n\t\t \n\t\ttemp = REG_READ(map->dpll);\n\t\tif ((temp & DPLL_VCO_ENABLE) == 0) {\n\t\t\tREG_WRITE(map->dpll, temp);\n\t\t\tREG_READ(map->dpll);\n\t\t\t \n\t\t\tudelay(150);\n\t\t\tREG_WRITE(map->dpll, temp | DPLL_VCO_ENABLE);\n\t\t\tREG_READ(map->dpll);\n\t\t\t \n\t\t\tudelay(150);\n\t\t\tREG_WRITE(map->dpll, temp | DPLL_VCO_ENABLE);\n\t\t\tREG_READ(map->dpll);\n\t\t\t \n\t\t\tudelay(150);\n\t\t}\n\n\t\t \n\t\ttemp = REG_READ(map->cntr);\n\t\tif ((temp & DISPLAY_PLANE_ENABLE) == 0) {\n\t\t\tREG_WRITE(map->cntr,\n\t\t\t\t  temp | DISPLAY_PLANE_ENABLE);\n\t\t\t \n\t\t\tREG_WRITE(map->base, REG_READ(map->base));\n\t\t}\n\n\t\tudelay(150);\n\n\t\t \n\t\ttemp = REG_READ(map->conf);\n\t\tif ((temp & PIPEACONF_ENABLE) == 0)\n\t\t\tREG_WRITE(map->conf, temp | PIPEACONF_ENABLE);\n\n\t\ttemp = REG_READ(map->status);\n\t\ttemp &= ~(0xFFFF);\n\t\ttemp |= PIPE_FIFO_UNDERRUN;\n\t\tREG_WRITE(map->status, temp);\n\t\tREG_READ(map->status);\n\n\t\tgma_crtc_load_lut(crtc);\n\n\t\t \n\t\t \n\n\t\tdrm_crtc_vblank_on(crtc);\n\t\tbreak;\n\tcase DRM_MODE_DPMS_OFF:\n\t\tif (!gma_crtc->active)\n\t\t\tbreak;\n\n\t\tgma_crtc->active = false;\n\n\t\t \n\t\t \n\n\t\t \n\t\tREG_WRITE(VGACNTRL, VGA_DISP_DISABLE);\n\n\t\t \n\t\tdrm_crtc_vblank_off(crtc);\n\n\t\t \n\t\tgma_wait_for_vblank(dev);\n\n\t\t \n\t\ttemp = REG_READ(map->cntr);\n\t\tif ((temp & DISPLAY_PLANE_ENABLE) != 0) {\n\t\t\tREG_WRITE(map->cntr,\n\t\t\t\t  temp & ~DISPLAY_PLANE_ENABLE);\n\t\t\t \n\t\t\tREG_WRITE(map->base, REG_READ(map->base));\n\t\t\tREG_READ(map->base);\n\t\t}\n\n\t\t \n\t\ttemp = REG_READ(map->conf);\n\t\tif ((temp & PIPEACONF_ENABLE) != 0) {\n\t\t\tREG_WRITE(map->conf, temp & ~PIPEACONF_ENABLE);\n\t\t\tREG_READ(map->conf);\n\t\t}\n\n\t\t \n\t\tgma_wait_for_vblank(dev);\n\n\t\tudelay(150);\n\n\t\t \n\t\ttemp = REG_READ(map->dpll);\n\t\tif ((temp & DPLL_VCO_ENABLE) != 0) {\n\t\t\tREG_WRITE(map->dpll, temp & ~DPLL_VCO_ENABLE);\n\t\t\tREG_READ(map->dpll);\n\t\t}\n\n\t\t \n\t\tudelay(150);\n\t\tbreak;\n\t}\n\n\tif (IS_CDV(dev))\n\t\tdev_priv->ops->update_wm(dev, crtc);\n\n\t \n\tREG_WRITE(DSPARB, 0x3F3E);\n}\n\nstatic int gma_crtc_cursor_set(struct drm_crtc *crtc,\n\t\t\t       struct drm_file *file_priv, uint32_t handle,\n\t\t\t       uint32_t width, uint32_t height)\n{\n\tstruct drm_device *dev = crtc->dev;\n\tstruct drm_psb_private *dev_priv = to_drm_psb_private(dev);\n\tstruct gma_crtc *gma_crtc = to_gma_crtc(crtc);\n\tint pipe = gma_crtc->pipe;\n\tuint32_t control = (pipe == 0) ? CURACNTR : CURBCNTR;\n\tuint32_t base = (pipe == 0) ? CURABASE : CURBBASE;\n\tuint32_t temp;\n\tsize_t addr = 0;\n\tstruct psb_gem_object *pobj;\n\tstruct psb_gem_object *cursor_pobj = gma_crtc->cursor_pobj;\n\tstruct drm_gem_object *obj;\n\tvoid *tmp_dst;\n\tint ret = 0, i, cursor_pages;\n\n\t \n\tif (!handle) {\n\t\ttemp = CURSOR_MODE_DISABLE;\n\t\tif (gma_power_begin(dev, false)) {\n\t\t\tREG_WRITE(control, temp);\n\t\t\tREG_WRITE(base, 0);\n\t\t\tgma_power_end(dev);\n\t\t}\n\n\t\t \n\t\tif (gma_crtc->cursor_obj) {\n\t\t\tpobj = to_psb_gem_object(gma_crtc->cursor_obj);\n\t\t\tpsb_gem_unpin(pobj);\n\t\t\tdrm_gem_object_put(gma_crtc->cursor_obj);\n\t\t\tgma_crtc->cursor_obj = NULL;\n\t\t}\n\t\treturn 0;\n\t}\n\n\t \n\tif (width != 64 || height != 64) {\n\t\tdev_dbg(dev->dev, \"We currently only support 64x64 cursors\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tobj = drm_gem_object_lookup(file_priv, handle);\n\tif (!obj) {\n\t\tret = -ENOENT;\n\t\tgoto unlock;\n\t}\n\n\tif (obj->size < width * height * 4) {\n\t\tdev_dbg(dev->dev, \"Buffer is too small\\n\");\n\t\tret = -ENOMEM;\n\t\tgoto unref_cursor;\n\t}\n\n\tpobj = to_psb_gem_object(obj);\n\n\t \n\tret = psb_gem_pin(pobj);\n\tif (ret) {\n\t\tdev_err(dev->dev, \"Can not pin down handle 0x%x\\n\", handle);\n\t\tgoto unref_cursor;\n\t}\n\n\tif (dev_priv->ops->cursor_needs_phys) {\n\t\tif (!cursor_pobj) {\n\t\t\tdev_err(dev->dev, \"No hardware cursor mem available\");\n\t\t\tret = -ENOMEM;\n\t\t\tgoto unref_cursor;\n\t\t}\n\n\t\tcursor_pages = obj->size / PAGE_SIZE;\n\t\tif (cursor_pages > 4)\n\t\t\tcursor_pages = 4;  \n\n\t\t \n\t\ttmp_dst = dev_priv->vram_addr + cursor_pobj->offset;\n\t\tfor (i = 0; i < cursor_pages; i++) {\n\t\t\tmemcpy_from_page(tmp_dst, pobj->pages[i], 0, PAGE_SIZE);\n\t\t\ttmp_dst += PAGE_SIZE;\n\t\t}\n\n\t\taddr = gma_crtc->cursor_addr;\n\t} else {\n\t\taddr = pobj->offset;\n\t\tgma_crtc->cursor_addr = addr;\n\t}\n\n\ttemp = 0;\n\t \n\ttemp |= (pipe << 28);\n\ttemp |= CURSOR_MODE_64_ARGB_AX | MCURSOR_GAMMA_ENABLE;\n\n\tif (gma_power_begin(dev, false)) {\n\t\tREG_WRITE(control, temp);\n\t\tREG_WRITE(base, addr);\n\t\tgma_power_end(dev);\n\t}\n\n\t \n\tif (gma_crtc->cursor_obj) {\n\t\tpobj = to_psb_gem_object(gma_crtc->cursor_obj);\n\t\tpsb_gem_unpin(pobj);\n\t\tdrm_gem_object_put(gma_crtc->cursor_obj);\n\t}\n\n\tgma_crtc->cursor_obj = obj;\nunlock:\n\treturn ret;\n\nunref_cursor:\n\tdrm_gem_object_put(obj);\n\treturn ret;\n}\n\nstatic int gma_crtc_cursor_move(struct drm_crtc *crtc, int x, int y)\n{\n\tstruct drm_device *dev = crtc->dev;\n\tstruct gma_crtc *gma_crtc = to_gma_crtc(crtc);\n\tint pipe = gma_crtc->pipe;\n\tuint32_t temp = 0;\n\tuint32_t addr;\n\n\tif (x < 0) {\n\t\ttemp |= (CURSOR_POS_SIGN << CURSOR_X_SHIFT);\n\t\tx = -x;\n\t}\n\tif (y < 0) {\n\t\ttemp |= (CURSOR_POS_SIGN << CURSOR_Y_SHIFT);\n\t\ty = -y;\n\t}\n\n\ttemp |= ((x & CURSOR_POS_MASK) << CURSOR_X_SHIFT);\n\ttemp |= ((y & CURSOR_POS_MASK) << CURSOR_Y_SHIFT);\n\n\taddr = gma_crtc->cursor_addr;\n\n\tif (gma_power_begin(dev, false)) {\n\t\tREG_WRITE((pipe == 0) ? CURAPOS : CURBPOS, temp);\n\t\tREG_WRITE((pipe == 0) ? CURABASE : CURBBASE, addr);\n\t\tgma_power_end(dev);\n\t}\n\treturn 0;\n}\n\nvoid gma_crtc_prepare(struct drm_crtc *crtc)\n{\n\tconst struct drm_crtc_helper_funcs *crtc_funcs = crtc->helper_private;\n\tcrtc_funcs->dpms(crtc, DRM_MODE_DPMS_OFF);\n}\n\nvoid gma_crtc_commit(struct drm_crtc *crtc)\n{\n\tconst struct drm_crtc_helper_funcs *crtc_funcs = crtc->helper_private;\n\tcrtc_funcs->dpms(crtc, DRM_MODE_DPMS_ON);\n}\n\nvoid gma_crtc_disable(struct drm_crtc *crtc)\n{\n\tstruct psb_gem_object *pobj;\n\tconst struct drm_crtc_helper_funcs *crtc_funcs = crtc->helper_private;\n\n\tcrtc_funcs->dpms(crtc, DRM_MODE_DPMS_OFF);\n\n\tif (crtc->primary->fb) {\n\t\tpobj = to_psb_gem_object(crtc->primary->fb->obj[0]);\n\t\tpsb_gem_unpin(pobj);\n\t}\n}\n\nvoid gma_crtc_destroy(struct drm_crtc *crtc)\n{\n\tstruct gma_crtc *gma_crtc = to_gma_crtc(crtc);\n\n\tif (gma_crtc->cursor_pobj)\n\t\tdrm_gem_object_put(&gma_crtc->cursor_pobj->base);\n\n\tkfree(gma_crtc->crtc_state);\n\tdrm_crtc_cleanup(crtc);\n\tkfree(gma_crtc);\n}\n\nint gma_crtc_page_flip(struct drm_crtc *crtc,\n\t\t       struct drm_framebuffer *fb,\n\t\t       struct drm_pending_vblank_event *event,\n\t\t       uint32_t page_flip_flags,\n\t\t       struct drm_modeset_acquire_ctx *ctx)\n{\n\tstruct gma_crtc *gma_crtc = to_gma_crtc(crtc);\n\tstruct drm_framebuffer *current_fb = crtc->primary->fb;\n\tstruct drm_framebuffer *old_fb = crtc->primary->old_fb;\n\tconst struct drm_crtc_helper_funcs *crtc_funcs = crtc->helper_private;\n\tstruct drm_device *dev = crtc->dev;\n\tunsigned long flags;\n\tint ret;\n\n\tif (!crtc_funcs->mode_set_base)\n\t\treturn -EINVAL;\n\n\t \n\tcrtc->primary->fb = fb;\n\n\tif (event) {\n\t\tspin_lock_irqsave(&dev->event_lock, flags);\n\n\t\tWARN_ON(drm_crtc_vblank_get(crtc) != 0);\n\n\t\tgma_crtc->page_flip_event = event;\n\t\tspin_unlock_irqrestore(&dev->event_lock, flags);\n\n\t\t \n\t\tret = crtc_funcs->mode_set_base(crtc, crtc->x, crtc->y, old_fb);\n\t\tif (ret) {\n\t\t\tspin_lock_irqsave(&dev->event_lock, flags);\n\t\t\tif (gma_crtc->page_flip_event) {\n\t\t\t\tgma_crtc->page_flip_event = NULL;\n\t\t\t\tdrm_crtc_vblank_put(crtc);\n\t\t\t}\n\t\t\tspin_unlock_irqrestore(&dev->event_lock, flags);\n\t\t}\n\t} else {\n\t\tret = crtc_funcs->mode_set_base(crtc, crtc->x, crtc->y, old_fb);\n\t}\n\n\t \n\tif (ret)\n\t\tcrtc->primary->fb = current_fb;\n\n\treturn ret;\n}\n\nconst struct drm_crtc_funcs gma_crtc_funcs = {\n\t.cursor_set = gma_crtc_cursor_set,\n\t.cursor_move = gma_crtc_cursor_move,\n\t.gamma_set = gma_crtc_gamma_set,\n\t.set_config = drm_crtc_helper_set_config,\n\t.destroy = gma_crtc_destroy,\n\t.page_flip = gma_crtc_page_flip,\n\t.enable_vblank = gma_crtc_enable_vblank,\n\t.disable_vblank = gma_crtc_disable_vblank,\n\t.get_vblank_counter = gma_crtc_get_vblank_counter,\n};\n\n \nvoid gma_crtc_save(struct drm_crtc *crtc)\n{\n\tstruct drm_device *dev = crtc->dev;\n\tstruct drm_psb_private *dev_priv = to_drm_psb_private(dev);\n\tstruct gma_crtc *gma_crtc = to_gma_crtc(crtc);\n\tstruct psb_intel_crtc_state *crtc_state = gma_crtc->crtc_state;\n\tconst struct psb_offset *map = &dev_priv->regmap[gma_crtc->pipe];\n\tuint32_t palette_reg;\n\tint i;\n\n\tif (!crtc_state) {\n\t\tdev_err(dev->dev, \"No CRTC state found\\n\");\n\t\treturn;\n\t}\n\n\tcrtc_state->saveDSPCNTR = REG_READ(map->cntr);\n\tcrtc_state->savePIPECONF = REG_READ(map->conf);\n\tcrtc_state->savePIPESRC = REG_READ(map->src);\n\tcrtc_state->saveFP0 = REG_READ(map->fp0);\n\tcrtc_state->saveFP1 = REG_READ(map->fp1);\n\tcrtc_state->saveDPLL = REG_READ(map->dpll);\n\tcrtc_state->saveHTOTAL = REG_READ(map->htotal);\n\tcrtc_state->saveHBLANK = REG_READ(map->hblank);\n\tcrtc_state->saveHSYNC = REG_READ(map->hsync);\n\tcrtc_state->saveVTOTAL = REG_READ(map->vtotal);\n\tcrtc_state->saveVBLANK = REG_READ(map->vblank);\n\tcrtc_state->saveVSYNC = REG_READ(map->vsync);\n\tcrtc_state->saveDSPSTRIDE = REG_READ(map->stride);\n\n\t \n\tcrtc_state->saveDSPSIZE = REG_READ(map->size);\n\tcrtc_state->saveDSPPOS = REG_READ(map->pos);\n\n\tcrtc_state->saveDSPBASE = REG_READ(map->base);\n\n\tpalette_reg = map->palette;\n\tfor (i = 0; i < 256; ++i)\n\t\tcrtc_state->savePalette[i] = REG_READ(palette_reg + (i << 2));\n}\n\n \nvoid gma_crtc_restore(struct drm_crtc *crtc)\n{\n\tstruct drm_device *dev = crtc->dev;\n\tstruct drm_psb_private *dev_priv = to_drm_psb_private(dev);\n\tstruct gma_crtc *gma_crtc =  to_gma_crtc(crtc);\n\tstruct psb_intel_crtc_state *crtc_state = gma_crtc->crtc_state;\n\tconst struct psb_offset *map = &dev_priv->regmap[gma_crtc->pipe];\n\tuint32_t palette_reg;\n\tint i;\n\n\tif (!crtc_state) {\n\t\tdev_err(dev->dev, \"No crtc state\\n\");\n\t\treturn;\n\t}\n\n\tif (crtc_state->saveDPLL & DPLL_VCO_ENABLE) {\n\t\tREG_WRITE(map->dpll,\n\t\t\tcrtc_state->saveDPLL & ~DPLL_VCO_ENABLE);\n\t\tREG_READ(map->dpll);\n\t\tudelay(150);\n\t}\n\n\tREG_WRITE(map->fp0, crtc_state->saveFP0);\n\tREG_READ(map->fp0);\n\n\tREG_WRITE(map->fp1, crtc_state->saveFP1);\n\tREG_READ(map->fp1);\n\n\tREG_WRITE(map->dpll, crtc_state->saveDPLL);\n\tREG_READ(map->dpll);\n\tudelay(150);\n\n\tREG_WRITE(map->htotal, crtc_state->saveHTOTAL);\n\tREG_WRITE(map->hblank, crtc_state->saveHBLANK);\n\tREG_WRITE(map->hsync, crtc_state->saveHSYNC);\n\tREG_WRITE(map->vtotal, crtc_state->saveVTOTAL);\n\tREG_WRITE(map->vblank, crtc_state->saveVBLANK);\n\tREG_WRITE(map->vsync, crtc_state->saveVSYNC);\n\tREG_WRITE(map->stride, crtc_state->saveDSPSTRIDE);\n\n\tREG_WRITE(map->size, crtc_state->saveDSPSIZE);\n\tREG_WRITE(map->pos, crtc_state->saveDSPPOS);\n\n\tREG_WRITE(map->src, crtc_state->savePIPESRC);\n\tREG_WRITE(map->base, crtc_state->saveDSPBASE);\n\tREG_WRITE(map->conf, crtc_state->savePIPECONF);\n\n\tgma_wait_for_vblank(dev);\n\n\tREG_WRITE(map->cntr, crtc_state->saveDSPCNTR);\n\tREG_WRITE(map->base, crtc_state->saveDSPBASE);\n\n\tgma_wait_for_vblank(dev);\n\n\tpalette_reg = map->palette;\n\tfor (i = 0; i < 256; ++i)\n\t\tREG_WRITE(palette_reg + (i << 2), crtc_state->savePalette[i]);\n}\n\nvoid gma_encoder_prepare(struct drm_encoder *encoder)\n{\n\tconst struct drm_encoder_helper_funcs *encoder_funcs =\n\t    encoder->helper_private;\n\t \n\tencoder_funcs->dpms(encoder, DRM_MODE_DPMS_OFF);\n}\n\nvoid gma_encoder_commit(struct drm_encoder *encoder)\n{\n\tconst struct drm_encoder_helper_funcs *encoder_funcs =\n\t    encoder->helper_private;\n\t \n\tencoder_funcs->dpms(encoder, DRM_MODE_DPMS_ON);\n}\n\nvoid gma_encoder_destroy(struct drm_encoder *encoder)\n{\n\tstruct gma_encoder *intel_encoder = to_gma_encoder(encoder);\n\n\tdrm_encoder_cleanup(encoder);\n\tkfree(intel_encoder);\n}\n\n \nstruct drm_encoder *gma_best_encoder(struct drm_connector *connector)\n{\n\tstruct gma_encoder *gma_encoder = gma_attached_encoder(connector);\n\n\treturn &gma_encoder->base;\n}\n\nvoid gma_connector_attach_encoder(struct gma_connector *connector,\n\t\t\t\t  struct gma_encoder *encoder)\n{\n\tconnector->encoder = encoder;\n\tdrm_connector_attach_encoder(&connector->base,\n\t\t\t\t\t  &encoder->base);\n}\n\n#define GMA_PLL_INVALID(s) {   return false; }\n\nbool gma_pll_is_valid(struct drm_crtc *crtc,\n\t\t      const struct gma_limit_t *limit,\n\t\t      struct gma_clock_t *clock)\n{\n\tif (clock->p1 < limit->p1.min || limit->p1.max < clock->p1)\n\t\tGMA_PLL_INVALID(\"p1 out of range\");\n\tif (clock->p < limit->p.min || limit->p.max < clock->p)\n\t\tGMA_PLL_INVALID(\"p out of range\");\n\tif (clock->m2 < limit->m2.min || limit->m2.max < clock->m2)\n\t\tGMA_PLL_INVALID(\"m2 out of range\");\n\tif (clock->m1 < limit->m1.min || limit->m1.max < clock->m1)\n\t\tGMA_PLL_INVALID(\"m1 out of range\");\n\t \n\tif (clock->m1 <= clock->m2 && clock->m1 != 0)\n\t\tGMA_PLL_INVALID(\"m1 <= m2 && m1 != 0\");\n\tif (clock->m < limit->m.min || limit->m.max < clock->m)\n\t\tGMA_PLL_INVALID(\"m out of range\");\n\tif (clock->n < limit->n.min || limit->n.max < clock->n)\n\t\tGMA_PLL_INVALID(\"n out of range\");\n\tif (clock->vco < limit->vco.min || limit->vco.max < clock->vco)\n\t\tGMA_PLL_INVALID(\"vco out of range\");\n\t \n\tif (clock->dot < limit->dot.min || limit->dot.max < clock->dot)\n\t\tGMA_PLL_INVALID(\"dot out of range\");\n\n\treturn true;\n}\n\nbool gma_find_best_pll(const struct gma_limit_t *limit,\n\t\t       struct drm_crtc *crtc, int target, int refclk,\n\t\t       struct gma_clock_t *best_clock)\n{\n\tstruct drm_device *dev = crtc->dev;\n\tconst struct gma_clock_funcs *clock_funcs =\n\t\t\t\t\t\tto_gma_crtc(crtc)->clock_funcs;\n\tstruct gma_clock_t clock;\n\tint err = target;\n\n\tif (gma_pipe_has_type(crtc, INTEL_OUTPUT_LVDS) &&\n\t    (REG_READ(LVDS) & LVDS_PORT_EN) != 0) {\n\t\t \n\t\tif ((REG_READ(LVDS) & LVDS_CLKB_POWER_MASK) ==\n\t\t    LVDS_CLKB_POWER_UP)\n\t\t\tclock.p2 = limit->p2.p2_fast;\n\t\telse\n\t\t\tclock.p2 = limit->p2.p2_slow;\n\t} else {\n\t\tif (target < limit->p2.dot_limit)\n\t\t\tclock.p2 = limit->p2.p2_slow;\n\t\telse\n\t\t\tclock.p2 = limit->p2.p2_fast;\n\t}\n\n\tmemset(best_clock, 0, sizeof(*best_clock));\n\n\t \n\tfor (clock.m1 = limit->m1.min; clock.m1 <= limit->m1.max; clock.m1++) {\n\t\tfor (clock.m2 = limit->m2.min;\n\t\t     (clock.m2 < clock.m1 || clock.m1 == 0) &&\n\t\t      clock.m2 <= limit->m2.max; clock.m2++) {\n\t\t\tfor (clock.n = limit->n.min;\n\t\t\t     clock.n <= limit->n.max; clock.n++) {\n\t\t\t\tfor (clock.p1 = limit->p1.min;\n\t\t\t\t     clock.p1 <= limit->p1.max;\n\t\t\t\t     clock.p1++) {\n\t\t\t\t\tint this_err;\n\n\t\t\t\t\tclock_funcs->clock(refclk, &clock);\n\n\t\t\t\t\tif (!clock_funcs->pll_is_valid(crtc,\n\t\t\t\t\t\t\t\tlimit, &clock))\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\tthis_err = abs(clock.dot - target);\n\t\t\t\t\tif (this_err < err) {\n\t\t\t\t\t\t*best_clock = clock;\n\t\t\t\t\t\terr = this_err;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn err != target;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}