{
  "module_name": "intel_i2c.c",
  "hash_id": "6a16345c5a1ef360d4d1385f6611febd62103eacb9d3352b6aeeed699cf0ec6c",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/gma500/intel_i2c.c",
  "human_readable_source": "\n \n\n#include <linux/delay.h>\n#include <linux/export.h>\n#include <linux/i2c-algo-bit.h>\n#include <linux/i2c.h>\n\n#include \"psb_drv.h\"\n#include \"psb_intel_reg.h\"\n\n \n\n#define I2C_RISEFALL_TIME 20\n\nstatic int get_clock(void *data)\n{\n\tstruct gma_i2c_chan *chan = data;\n\tstruct drm_device *dev = chan->drm_dev;\n\tu32 val;\n\n\tval = REG_READ(chan->reg);\n\treturn (val & GPIO_CLOCK_VAL_IN) != 0;\n}\n\nstatic int get_data(void *data)\n{\n\tstruct gma_i2c_chan *chan = data;\n\tstruct drm_device *dev = chan->drm_dev;\n\tu32 val;\n\n\tval = REG_READ(chan->reg);\n\treturn (val & GPIO_DATA_VAL_IN) != 0;\n}\n\nstatic void set_clock(void *data, int state_high)\n{\n\tstruct gma_i2c_chan *chan = data;\n\tstruct drm_device *dev = chan->drm_dev;\n\tu32 reserved = 0, clock_bits;\n\n\t \n\treserved =\n\t\t    REG_READ(chan->reg) & (GPIO_DATA_PULLUP_DISABLE |\n\t\t\t\t\t   GPIO_CLOCK_PULLUP_DISABLE);\n\n\tif (state_high)\n\t\tclock_bits = GPIO_CLOCK_DIR_IN | GPIO_CLOCK_DIR_MASK;\n\telse\n\t\tclock_bits = GPIO_CLOCK_DIR_OUT | GPIO_CLOCK_DIR_MASK |\n\t\t    GPIO_CLOCK_VAL_MASK;\n\tREG_WRITE(chan->reg, reserved | clock_bits);\n\tudelay(I2C_RISEFALL_TIME);\t \n}\n\nstatic void set_data(void *data, int state_high)\n{\n\tstruct gma_i2c_chan *chan = data;\n\tstruct drm_device *dev = chan->drm_dev;\n\tu32 reserved = 0, data_bits;\n\n\t \n\treserved =\n\t\t    REG_READ(chan->reg) & (GPIO_DATA_PULLUP_DISABLE |\n\t\t\t\t\t   GPIO_CLOCK_PULLUP_DISABLE);\n\n\tif (state_high)\n\t\tdata_bits = GPIO_DATA_DIR_IN | GPIO_DATA_DIR_MASK;\n\telse\n\t\tdata_bits =\n\t\t    GPIO_DATA_DIR_OUT | GPIO_DATA_DIR_MASK |\n\t\t    GPIO_DATA_VAL_MASK;\n\n\tREG_WRITE(chan->reg, reserved | data_bits);\n\tudelay(I2C_RISEFALL_TIME);\t \n}\n\n \nstruct gma_i2c_chan *gma_i2c_create(struct drm_device *dev, const u32 reg,\n\t\t\t\t    const char *name)\n{\n\tstruct gma_i2c_chan *chan;\n\n\tchan = kzalloc(sizeof(struct gma_i2c_chan), GFP_KERNEL);\n\tif (!chan)\n\t\tgoto out_free;\n\n\tchan->drm_dev = dev;\n\tchan->reg = reg;\n\tsnprintf(chan->base.name, I2C_NAME_SIZE, \"intel drm %s\", name);\n\tchan->base.owner = THIS_MODULE;\n\tchan->base.algo_data = &chan->algo;\n\tchan->base.dev.parent = dev->dev;\n\tchan->algo.setsda = set_data;\n\tchan->algo.setscl = set_clock;\n\tchan->algo.getsda = get_data;\n\tchan->algo.getscl = get_clock;\n\tchan->algo.udelay = 20;\n\tchan->algo.timeout = usecs_to_jiffies(2200);\n\tchan->algo.data = chan;\n\n\ti2c_set_adapdata(&chan->base, chan);\n\n\tif (i2c_bit_add_bus(&chan->base))\n\t\tgoto out_free;\n\n\t \n\tset_data(chan, 1);\n\tset_clock(chan, 1);\n\tudelay(20);\n\n\treturn chan;\n\nout_free:\n\tkfree(chan);\n\treturn NULL;\n}\n\n \nvoid gma_i2c_destroy(struct gma_i2c_chan *chan)\n{\n\tif (!chan)\n\t\treturn;\n\n\ti2c_del_adapter(&chan->base);\n\tkfree(chan);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}