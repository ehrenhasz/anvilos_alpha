{
  "module_name": "mid_bios.c",
  "hash_id": "d0c2a097980e730171ab47423d3806118ecaed841ff5f097248ffe7964047c1e",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/gma500/mid_bios.c",
  "human_readable_source": "\n \n\n \n\n#include <drm/drm.h>\n\n#include \"mid_bios.h\"\n#include \"psb_drv.h\"\n\nstatic void mid_get_fuse_settings(struct drm_device *dev)\n{\n\tstruct drm_psb_private *dev_priv = to_drm_psb_private(dev);\n\tstruct pci_dev *pdev = to_pci_dev(dev->dev);\n\tstruct pci_dev *pci_root =\n\t\tpci_get_domain_bus_and_slot(pci_domain_nr(pdev->bus),\n\t\t\t\t\t    0, 0);\n\tuint32_t fuse_value = 0;\n\tuint32_t fuse_value_tmp = 0;\n\n#define FB_REG06 0xD0810600\n#define FB_MIPI_DISABLE  (1 << 11)\n#define FB_REG09 0xD0810900\n#define FB_SKU_MASK  0x7000\n#define FB_SKU_SHIFT 12\n#define FB_SKU_100 0\n#define FB_SKU_100L 1\n#define FB_SKU_83 2\n\tif (pci_root == NULL) {\n\t\tWARN_ON(1);\n\t\treturn;\n\t}\n\n\n\tpci_write_config_dword(pci_root, 0xD0, FB_REG06);\n\tpci_read_config_dword(pci_root, 0xD4, &fuse_value);\n\n\t \n\tif (IS_MRST(dev))\n\t\tdev_priv->iLVDS_enable = fuse_value & FB_MIPI_DISABLE;\n\n\tDRM_INFO(\"internal display is %s\\n\",\n\t\t dev_priv->iLVDS_enable ? \"LVDS display\" : \"MIPI display\");\n\n\t  \n\t if (dev_priv->iLVDS_enable) {\n\t\tdev_priv->is_lvds_on = true;\n\t\tdev_priv->is_mipi_on = false;\n\t} else {\n\t\tdev_priv->is_mipi_on = true;\n\t\tdev_priv->is_lvds_on = false;\n\t}\n\n\tdev_priv->video_device_fuse = fuse_value;\n\n\tpci_write_config_dword(pci_root, 0xD0, FB_REG09);\n\tpci_read_config_dword(pci_root, 0xD4, &fuse_value);\n\n\tdev_dbg(dev->dev, \"SKU values is 0x%x.\\n\", fuse_value);\n\tfuse_value_tmp = (fuse_value & FB_SKU_MASK) >> FB_SKU_SHIFT;\n\n\tdev_priv->fuse_reg_value = fuse_value;\n\n\tswitch (fuse_value_tmp) {\n\tcase FB_SKU_100:\n\t\tdev_priv->core_freq = 200;\n\t\tbreak;\n\tcase FB_SKU_100L:\n\t\tdev_priv->core_freq = 100;\n\t\tbreak;\n\tcase FB_SKU_83:\n\t\tdev_priv->core_freq = 166;\n\t\tbreak;\n\tdefault:\n\t\tdev_warn(dev->dev, \"Invalid SKU values, SKU value = 0x%08x\\n\",\n\t\t\t\t\t\t\t\tfuse_value_tmp);\n\t\tdev_priv->core_freq = 0;\n\t}\n\tdev_dbg(dev->dev, \"LNC core clk is %dMHz.\\n\", dev_priv->core_freq);\n\tpci_dev_put(pci_root);\n}\n\n \nstatic void mid_get_pci_revID(struct drm_psb_private *dev_priv)\n{\n\tuint32_t platform_rev_id = 0;\n\tstruct pci_dev *pdev = to_pci_dev(dev_priv->dev.dev);\n\tint domain = pci_domain_nr(pdev->bus);\n\tstruct pci_dev *pci_gfx_root =\n\t\tpci_get_domain_bus_and_slot(domain, 0, PCI_DEVFN(2, 0));\n\n\tif (pci_gfx_root == NULL) {\n\t\tWARN_ON(1);\n\t\treturn;\n\t}\n\tpci_read_config_dword(pci_gfx_root, 0x08, &platform_rev_id);\n\tdev_priv->platform_rev_id = (uint8_t) platform_rev_id;\n\tpci_dev_put(pci_gfx_root);\n\tdev_dbg(dev_priv->dev.dev, \"platform_rev_id is %x\\n\", dev_priv->platform_rev_id);\n}\n\nstruct mid_vbt_header {\n\tu32 signature;\n\tu8 revision;\n} __packed;\n\n \nstruct vbt_r0 {\n\tstruct mid_vbt_header vbt_header;\n\tu8 size;\n\tu8 checksum;\n} __packed;\n\nstruct vbt_r10 {\n\tstruct mid_vbt_header vbt_header;\n\tu8 checksum;\n\tu16 size;\n\tu8 panel_count;\n\tu8 primary_panel_idx;\n\tu8 secondary_panel_idx;\n\tu8 __reserved[5];\n} __packed;\n\nstatic int read_vbt_r0(u32 addr, struct vbt_r0 *vbt)\n{\n\tvoid __iomem *vbt_virtual;\n\n\tvbt_virtual = ioremap(addr, sizeof(*vbt));\n\tif (vbt_virtual == NULL)\n\t\treturn -1;\n\n\tmemcpy_fromio(vbt, vbt_virtual, sizeof(*vbt));\n\tiounmap(vbt_virtual);\n\n\treturn 0;\n}\n\nstatic int read_vbt_r10(u32 addr, struct vbt_r10 *vbt)\n{\n\tvoid __iomem *vbt_virtual;\n\n\tvbt_virtual = ioremap(addr, sizeof(*vbt));\n\tif (!vbt_virtual)\n\t\treturn -1;\n\n\tmemcpy_fromio(vbt, vbt_virtual, sizeof(*vbt));\n\tiounmap(vbt_virtual);\n\n\treturn 0;\n}\n\nstatic int mid_get_vbt_data_r0(struct drm_psb_private *dev_priv, u32 addr)\n{\n\tstruct vbt_r0 vbt;\n\tvoid __iomem *gct_virtual;\n\tstruct gct_r0 gct;\n\tu8 bpi;\n\n\tif (read_vbt_r0(addr, &vbt))\n\t\treturn -1;\n\n\tgct_virtual = ioremap(addr + sizeof(vbt), vbt.size - sizeof(vbt));\n\tif (!gct_virtual)\n\t\treturn -1;\n\tmemcpy_fromio(&gct, gct_virtual, sizeof(gct));\n\tiounmap(gct_virtual);\n\n\tbpi = gct.PD.BootPanelIndex;\n\tdev_priv->gct_data.bpi = bpi;\n\tdev_priv->gct_data.pt = gct.PD.PanelType;\n\tdev_priv->gct_data.DTD = gct.panel[bpi].DTD;\n\tdev_priv->gct_data.Panel_Port_Control =\n\t\tgct.panel[bpi].Panel_Port_Control;\n\tdev_priv->gct_data.Panel_MIPI_Display_Descriptor =\n\t\tgct.panel[bpi].Panel_MIPI_Display_Descriptor;\n\n\treturn 0;\n}\n\nstatic int mid_get_vbt_data_r1(struct drm_psb_private *dev_priv, u32 addr)\n{\n\tstruct vbt_r0 vbt;\n\tvoid __iomem *gct_virtual;\n\tstruct gct_r1 gct;\n\tu8 bpi;\n\n\tif (read_vbt_r0(addr, &vbt))\n\t\treturn -1;\n\n\tgct_virtual = ioremap(addr + sizeof(vbt), vbt.size - sizeof(vbt));\n\tif (!gct_virtual)\n\t\treturn -1;\n\tmemcpy_fromio(&gct, gct_virtual, sizeof(gct));\n\tiounmap(gct_virtual);\n\n\tbpi = gct.PD.BootPanelIndex;\n\tdev_priv->gct_data.bpi = bpi;\n\tdev_priv->gct_data.pt = gct.PD.PanelType;\n\tdev_priv->gct_data.DTD = gct.panel[bpi].DTD;\n\tdev_priv->gct_data.Panel_Port_Control =\n\t\tgct.panel[bpi].Panel_Port_Control;\n\tdev_priv->gct_data.Panel_MIPI_Display_Descriptor =\n\t\tgct.panel[bpi].Panel_MIPI_Display_Descriptor;\n\n\treturn 0;\n}\n\nstatic int mid_get_vbt_data_r10(struct drm_psb_private *dev_priv, u32 addr)\n{\n\tstruct vbt_r10 vbt;\n\tvoid __iomem *gct_virtual;\n\tstruct gct_r10 *gct;\n\tstruct oaktrail_timing_info *dp_ti = &dev_priv->gct_data.DTD;\n\tstruct gct_r10_timing_info *ti;\n\tint ret = -1;\n\n\tif (read_vbt_r10(addr, &vbt))\n\t\treturn -1;\n\n\tgct = kmalloc_array(vbt.panel_count, sizeof(*gct), GFP_KERNEL);\n\tif (!gct)\n\t\treturn -ENOMEM;\n\n\tgct_virtual = ioremap(addr + sizeof(vbt),\n\t\t\tsizeof(*gct) * vbt.panel_count);\n\tif (!gct_virtual)\n\t\tgoto out;\n\tmemcpy_fromio(gct, gct_virtual, sizeof(*gct));\n\tiounmap(gct_virtual);\n\n\tdev_priv->gct_data.bpi = vbt.primary_panel_idx;\n\tdev_priv->gct_data.Panel_MIPI_Display_Descriptor =\n\t\tgct[vbt.primary_panel_idx].Panel_MIPI_Display_Descriptor;\n\n\tti = &gct[vbt.primary_panel_idx].DTD;\n\tdp_ti->pixel_clock = ti->pixel_clock;\n\tdp_ti->hactive_hi = ti->hactive_hi;\n\tdp_ti->hactive_lo = ti->hactive_lo;\n\tdp_ti->hblank_hi = ti->hblank_hi;\n\tdp_ti->hblank_lo = ti->hblank_lo;\n\tdp_ti->hsync_offset_hi = ti->hsync_offset_hi;\n\tdp_ti->hsync_offset_lo = ti->hsync_offset_lo;\n\tdp_ti->hsync_pulse_width_hi = ti->hsync_pulse_width_hi;\n\tdp_ti->hsync_pulse_width_lo = ti->hsync_pulse_width_lo;\n\tdp_ti->vactive_hi = ti->vactive_hi;\n\tdp_ti->vactive_lo = ti->vactive_lo;\n\tdp_ti->vblank_hi = ti->vblank_hi;\n\tdp_ti->vblank_lo = ti->vblank_lo;\n\tdp_ti->vsync_offset_hi = ti->vsync_offset_hi;\n\tdp_ti->vsync_offset_lo = ti->vsync_offset_lo;\n\tdp_ti->vsync_pulse_width_hi = ti->vsync_pulse_width_hi;\n\tdp_ti->vsync_pulse_width_lo = ti->vsync_pulse_width_lo;\n\n\tret = 0;\nout:\n\tkfree(gct);\n\treturn ret;\n}\n\nstatic void mid_get_vbt_data(struct drm_psb_private *dev_priv)\n{\n\tstruct drm_device *dev = &dev_priv->dev;\n\tstruct pci_dev *pdev = to_pci_dev(dev->dev);\n\tu32 addr;\n\tu8 __iomem *vbt_virtual;\n\tstruct mid_vbt_header vbt_header;\n\tstruct pci_dev *pci_gfx_root =\n\t\tpci_get_domain_bus_and_slot(pci_domain_nr(pdev->bus),\n\t\t\t\t\t    0, PCI_DEVFN(2, 0));\n\tint ret = -1;\n\n\t \n\tpci_read_config_dword(pci_gfx_root, 0xFC, &addr);\n\tpci_dev_put(pci_gfx_root);\n\n\tdev_dbg(dev->dev, \"drm platform config address is %x\\n\", addr);\n\n\tif (!addr)\n\t\tgoto out;\n\n\t \n\tvbt_virtual = ioremap(addr, sizeof(vbt_header));\n\tif (!vbt_virtual)\n\t\tgoto out;\n\n\tmemcpy_fromio(&vbt_header, vbt_virtual, sizeof(vbt_header));\n\tiounmap(vbt_virtual);\n\n\tif (memcmp(&vbt_header.signature, \"$GCT\", 4))\n\t\tgoto out;\n\n\tdev_dbg(dev->dev, \"GCT revision is %02x\\n\", vbt_header.revision);\n\n\tswitch (vbt_header.revision) {\n\tcase 0x00:\n\t\tret = mid_get_vbt_data_r0(dev_priv, addr);\n\t\tbreak;\n\tcase 0x01:\n\t\tret = mid_get_vbt_data_r1(dev_priv, addr);\n\t\tbreak;\n\tcase 0x10:\n\t\tret = mid_get_vbt_data_r10(dev_priv, addr);\n\t\tbreak;\n\tdefault:\n\t\tdev_err(dev->dev, \"Unknown revision of GCT!\\n\");\n\t}\n\nout:\n\tif (ret)\n\t\tdev_err(dev->dev, \"Unable to read GCT!\");\n\telse\n\t\tdev_priv->has_gct = true;\n}\n\nint mid_chip_setup(struct drm_device *dev)\n{\n\tstruct drm_psb_private *dev_priv = to_drm_psb_private(dev);\n\tmid_get_fuse_settings(dev);\n\tmid_get_vbt_data(dev_priv);\n\tmid_get_pci_revID(dev_priv);\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}