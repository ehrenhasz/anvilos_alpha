{
  "module_name": "oaktrail_hdmi.c",
  "hash_id": "2f4f9fc1b6dd76822e4f09cef5a4b99a2a34de47f42d8e67eb102124bf20bbd1",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/gma500/oaktrail_hdmi.c",
  "human_readable_source": " \n\n#include <linux/delay.h>\n\n#include <drm/drm.h>\n#include <drm/drm_crtc_helper.h>\n#include <drm/drm_edid.h>\n#include <drm/drm_modeset_helper_vtables.h>\n#include <drm/drm_simple_kms_helper.h>\n\n#include \"psb_drv.h\"\n#include \"psb_intel_drv.h\"\n#include \"psb_intel_reg.h\"\n\n#define HDMI_READ(reg)\t\treadl(hdmi_dev->regs + (reg))\n#define HDMI_WRITE(reg, val)\twritel(val, hdmi_dev->regs + (reg))\n\n#define HDMI_HCR\t0x1000\n#define HCR_ENABLE_HDCP\t\t(1 << 5)\n#define HCR_ENABLE_AUDIO\t(1 << 2)\n#define HCR_ENABLE_PIXEL\t(1 << 1)\n#define HCR_ENABLE_TMDS\t\t(1 << 0)\n\n#define HDMI_HICR\t0x1004\n#define HDMI_HSR\t0x1008\n#define HDMI_HISR\t0x100C\n#define HDMI_DETECT_HDP\t\t(1 << 0)\n\n#define HDMI_VIDEO_REG\t0x3000\n#define HDMI_UNIT_EN\t\t(1 << 7)\n#define HDMI_MODE_OUTPUT\t(1 << 0)\n#define HDMI_HBLANK_A\t0x3100\n\n#define HDMI_AUDIO_CTRL\t0x4000\n#define HDMI_ENABLE_AUDIO\t(1 << 0)\n\n#define PCH_HTOTAL_B\t0x3100\n#define PCH_HBLANK_B\t0x3104\n#define PCH_HSYNC_B\t0x3108\n#define PCH_VTOTAL_B\t0x310C\n#define PCH_VBLANK_B\t0x3110\n#define PCH_VSYNC_B\t0x3114\n#define PCH_PIPEBSRC\t0x311C\n\n#define PCH_PIPEB_DSL\t0x3800\n#define PCH_PIPEB_SLC\t0x3804\n#define PCH_PIPEBCONF\t0x3808\n#define PCH_PIPEBSTAT\t0x3824\n\n#define CDVO_DFT\t0x5000\n#define CDVO_SLEWRATE\t0x5004\n#define CDVO_STRENGTH\t0x5008\n#define CDVO_RCOMP\t0x500C\n\n#define DPLL_CTRL       0x6000\n#define DPLL_PDIV_SHIFT\t\t16\n#define DPLL_PDIV_MASK\t\t(0xf << 16)\n#define DPLL_PWRDN\t\t(1 << 4)\n#define DPLL_RESET\t\t(1 << 3)\n#define DPLL_FASTEN\t\t(1 << 2)\n#define DPLL_ENSTAT\t\t(1 << 1)\n#define DPLL_DITHEN\t\t(1 << 0)\n\n#define DPLL_DIV_CTRL   0x6004\n#define DPLL_CLKF_MASK\t\t0xffffffc0\n#define DPLL_CLKR_MASK\t\t(0x3f)\n\n#define DPLL_CLK_ENABLE 0x6008\n#define DPLL_EN_DISP\t\t(1 << 31)\n#define DPLL_SEL_HDMI\t\t(1 << 8)\n#define DPLL_EN_HDMI\t\t(1 << 1)\n#define DPLL_EN_VGA\t\t(1 << 0)\n\n#define DPLL_ADJUST     0x600C\n#define DPLL_STATUS     0x6010\n#define DPLL_UPDATE     0x6014\n#define DPLL_DFT        0x6020\n\nstruct intel_range {\n\tint\tmin, max;\n};\n\nstruct oaktrail_hdmi_limit {\n\tstruct intel_range vco, np, nr, nf;\n};\n\nstruct oaktrail_hdmi_clock {\n\tint np;\n\tint nr;\n\tint nf;\n\tint dot;\n};\n\n#define VCO_MIN\t\t320000\n#define VCO_MAX\t\t1650000\n#define\tNP_MIN\t\t1\n#define\tNP_MAX\t\t15\n#define\tNR_MIN\t\t1\n#define\tNR_MAX\t\t64\n#define NF_MIN\t\t2\n#define NF_MAX\t\t4095\n\nstatic const struct oaktrail_hdmi_limit oaktrail_hdmi_limit = {\n\t.vco = { .min = VCO_MIN,\t\t.max = VCO_MAX },\n\t.np  = { .min = NP_MIN,\t\t\t.max = NP_MAX  },\n\t.nr  = { .min = NR_MIN,\t\t\t.max = NR_MAX  },\n\t.nf  = { .min = NF_MIN,\t\t\t.max = NF_MAX  },\n};\n\nstatic void oaktrail_hdmi_audio_enable(struct drm_device *dev)\n{\n\tstruct drm_psb_private *dev_priv = to_drm_psb_private(dev);\n\tstruct oaktrail_hdmi_dev *hdmi_dev = dev_priv->hdmi_priv;\n\n\tHDMI_WRITE(HDMI_HCR, 0x67);\n\tHDMI_READ(HDMI_HCR);\n\n\tHDMI_WRITE(0x51a8, 0x10);\n\tHDMI_READ(0x51a8);\n\n\tHDMI_WRITE(HDMI_AUDIO_CTRL, 0x1);\n\tHDMI_READ(HDMI_AUDIO_CTRL);\n}\n\nstatic void oaktrail_hdmi_audio_disable(struct drm_device *dev)\n{\n\tstruct drm_psb_private *dev_priv = to_drm_psb_private(dev);\n\tstruct oaktrail_hdmi_dev *hdmi_dev = dev_priv->hdmi_priv;\n\n\tHDMI_WRITE(0x51a8, 0x0);\n\tHDMI_READ(0x51a8);\n\n\tHDMI_WRITE(HDMI_AUDIO_CTRL, 0x0);\n\tHDMI_READ(HDMI_AUDIO_CTRL);\n\n\tHDMI_WRITE(HDMI_HCR, 0x47);\n\tHDMI_READ(HDMI_HCR);\n}\n\nstatic unsigned int htotal_calculate(struct drm_display_mode *mode)\n{\n\tu32 new_crtc_htotal;\n\n\t \n\tnew_crtc_htotal = (mode->crtc_htotal - 1) * 200 * 1000 / mode->clock;\n\n\tDRM_DEBUG_KMS(\"new crtc htotal 0x%4x\\n\", new_crtc_htotal);\n\treturn (mode->crtc_hdisplay - 1) | (new_crtc_htotal << 16);\n}\n\nstatic void oaktrail_hdmi_find_dpll(struct drm_crtc *crtc, int target,\n\t\t\t\tint refclk, struct oaktrail_hdmi_clock *best_clock)\n{\n\tint np_min, np_max, nr_min, nr_max;\n\tint np, nr, nf;\n\n\tnp_min = DIV_ROUND_UP(oaktrail_hdmi_limit.vco.min, target * 10);\n\tnp_max = oaktrail_hdmi_limit.vco.max / (target * 10);\n\tif (np_min < oaktrail_hdmi_limit.np.min)\n\t\tnp_min = oaktrail_hdmi_limit.np.min;\n\tif (np_max > oaktrail_hdmi_limit.np.max)\n\t\tnp_max = oaktrail_hdmi_limit.np.max;\n\n\tnr_min = DIV_ROUND_UP((refclk * 1000), (target * 10 * np_max));\n\tnr_max = DIV_ROUND_UP((refclk * 1000), (target * 10 * np_min));\n\tif (nr_min < oaktrail_hdmi_limit.nr.min)\n\t\tnr_min = oaktrail_hdmi_limit.nr.min;\n\tif (nr_max > oaktrail_hdmi_limit.nr.max)\n\t\tnr_max = oaktrail_hdmi_limit.nr.max;\n\n\tnp = DIV_ROUND_UP((refclk * 1000), (target * 10 * nr_max));\n\tnr = DIV_ROUND_UP((refclk * 1000), (target * 10 * np));\n\tnf = DIV_ROUND_CLOSEST((target * 10 * np * nr), refclk);\n\tDRM_DEBUG_KMS(\"np, nr, nf %d %d %d\\n\", np, nr, nf);\n\n\t \n\tbest_clock->np = np;\n\tbest_clock->nr = nr - 1;\n\tbest_clock->nf = (nf << 14);\n}\n\nstatic void scu_busy_loop(void __iomem *scu_base)\n{\n\tu32 status = 0;\n\tu32 loop_count = 0;\n\n\tstatus = readl(scu_base + 0x04);\n\twhile (status & 1) {\n\t\tudelay(1);  \n\t\tstatus = readl(scu_base + 0x04);\n\t\tloop_count++;\n\t\t \n\t\tif (loop_count > 1000) {\n\t\t\tDRM_DEBUG_KMS(\"SCU IPC timed out\");\n\t\t\treturn;\n\t\t}\n\t}\n}\n\n \nstatic void oaktrail_hdmi_reset(struct drm_device *dev)\n{\n\tvoid __iomem *base;\n\tunsigned long scu_ipc_mmio = 0xff11c000UL;\n\tint scu_len = 1024;\n\n\tbase = ioremap((resource_size_t)scu_ipc_mmio, scu_len);\n\tif (base == NULL) {\n\t\tDRM_ERROR(\"failed to map scu mmio\\n\");\n\t\treturn;\n\t}\n\n\t \n\twritel(0xff11d118, base + 0x0c);\n\twritel(0x7fffffdf, base + 0x80);\n\twritel(0x42005, base + 0x0);\n\tscu_busy_loop(base);\n\n\t \n\twritel(0xff11d118, base + 0x0c);\n\twritel(0x7fffffff, base + 0x80);\n\twritel(0x42005, base + 0x0);\n\tscu_busy_loop(base);\n\n\tiounmap(base);\n}\n\nint oaktrail_crtc_hdmi_mode_set(struct drm_crtc *crtc,\n\t\t\t    struct drm_display_mode *mode,\n\t\t\t    struct drm_display_mode *adjusted_mode,\n\t\t\t    int x, int y,\n\t\t\t    struct drm_framebuffer *old_fb)\n{\n\tstruct drm_device *dev = crtc->dev;\n\tstruct drm_psb_private *dev_priv = to_drm_psb_private(dev);\n\tstruct oaktrail_hdmi_dev *hdmi_dev = dev_priv->hdmi_priv;\n\tint pipe = 1;\n\tint htot_reg = (pipe == 0) ? HTOTAL_A : HTOTAL_B;\n\tint hblank_reg = (pipe == 0) ? HBLANK_A : HBLANK_B;\n\tint hsync_reg = (pipe == 0) ? HSYNC_A : HSYNC_B;\n\tint vtot_reg = (pipe == 0) ? VTOTAL_A : VTOTAL_B;\n\tint vblank_reg = (pipe == 0) ? VBLANK_A : VBLANK_B;\n\tint vsync_reg = (pipe == 0) ? VSYNC_A : VSYNC_B;\n\tint dspsize_reg = (pipe == 0) ? DSPASIZE : DSPBSIZE;\n\tint dsppos_reg = (pipe == 0) ? DSPAPOS : DSPBPOS;\n\tint pipesrc_reg = (pipe == 0) ? PIPEASRC : PIPEBSRC;\n\tint pipeconf_reg = (pipe == 0) ? PIPEACONF : PIPEBCONF;\n\tint refclk;\n\tstruct oaktrail_hdmi_clock clock;\n\tu32 dspcntr, pipeconf, dpll, temp;\n\tint dspcntr_reg = DSPBCNTR;\n\n\tif (!gma_power_begin(dev, true))\n\t\treturn 0;\n\n\t \n\tREG_WRITE(VGACNTRL, VGA_DISP_DISABLE);\n\n\t \n\tdpll = REG_READ(DPLL_CTRL);\n\tif ((dpll & DPLL_PWRDN) == 0) {\n\t\tREG_WRITE(DPLL_CTRL, dpll | (DPLL_PWRDN | DPLL_RESET));\n\t\tREG_WRITE(DPLL_DIV_CTRL, 0x00000000);\n\t\tREG_WRITE(DPLL_STATUS, 0x1);\n\t}\n\tudelay(150);\n\n\t \n\toaktrail_hdmi_reset(dev);\n\n\t \n\trefclk = 25000;\n\toaktrail_hdmi_find_dpll(crtc, adjusted_mode->clock, refclk, &clock);\n\n\t \n\tdpll = REG_READ(DPLL_CTRL);\n\tdpll &= ~DPLL_PDIV_MASK;\n\tdpll &= ~(DPLL_PWRDN | DPLL_RESET);\n\tREG_WRITE(DPLL_CTRL, 0x00000008);\n\tREG_WRITE(DPLL_DIV_CTRL, ((clock.nf << 6) | clock.nr));\n\tREG_WRITE(DPLL_ADJUST, ((clock.nf >> 14) - 1));\n\tREG_WRITE(DPLL_CTRL, (dpll | (clock.np << DPLL_PDIV_SHIFT) | DPLL_ENSTAT | DPLL_DITHEN));\n\tREG_WRITE(DPLL_UPDATE, 0x80000000);\n\tREG_WRITE(DPLL_CLK_ENABLE, 0x80050102);\n\tudelay(150);\n\n\t \n\tHDMI_WRITE(0x1004, 0x1fd);\n\tHDMI_WRITE(0x2000, 0x1);\n\tHDMI_WRITE(0x2008, 0x0);\n\tHDMI_WRITE(0x3130, 0x8);\n\tHDMI_WRITE(0x101c, 0x1800810);\n\n\ttemp = htotal_calculate(adjusted_mode);\n\tREG_WRITE(htot_reg, temp);\n\tREG_WRITE(hblank_reg, (adjusted_mode->crtc_hblank_start - 1) | ((adjusted_mode->crtc_hblank_end - 1) << 16));\n\tREG_WRITE(hsync_reg, (adjusted_mode->crtc_hsync_start - 1) | ((adjusted_mode->crtc_hsync_end - 1) << 16));\n\tREG_WRITE(vtot_reg, (adjusted_mode->crtc_vdisplay - 1) | ((adjusted_mode->crtc_vtotal - 1) << 16));\n\tREG_WRITE(vblank_reg, (adjusted_mode->crtc_vblank_start - 1) | ((adjusted_mode->crtc_vblank_end - 1) << 16));\n\tREG_WRITE(vsync_reg, (adjusted_mode->crtc_vsync_start - 1) | ((adjusted_mode->crtc_vsync_end - 1) << 16));\n\tREG_WRITE(pipesrc_reg, ((mode->crtc_hdisplay - 1) << 16) |  (mode->crtc_vdisplay - 1));\n\n\tREG_WRITE(PCH_HTOTAL_B, (adjusted_mode->crtc_hdisplay - 1) | ((adjusted_mode->crtc_htotal - 1) << 16));\n\tREG_WRITE(PCH_HBLANK_B, (adjusted_mode->crtc_hblank_start - 1) | ((adjusted_mode->crtc_hblank_end - 1) << 16));\n\tREG_WRITE(PCH_HSYNC_B, (adjusted_mode->crtc_hsync_start - 1) | ((adjusted_mode->crtc_hsync_end - 1) << 16));\n\tREG_WRITE(PCH_VTOTAL_B, (adjusted_mode->crtc_vdisplay - 1) | ((adjusted_mode->crtc_vtotal - 1) << 16));\n\tREG_WRITE(PCH_VBLANK_B, (adjusted_mode->crtc_vblank_start - 1) | ((adjusted_mode->crtc_vblank_end - 1) << 16));\n\tREG_WRITE(PCH_VSYNC_B, (adjusted_mode->crtc_vsync_start - 1) | ((adjusted_mode->crtc_vsync_end - 1) << 16));\n\tREG_WRITE(PCH_PIPEBSRC, ((mode->crtc_hdisplay - 1) << 16) |  (mode->crtc_vdisplay - 1));\n\n\ttemp = adjusted_mode->crtc_hblank_end - adjusted_mode->crtc_hblank_start;\n\tHDMI_WRITE(HDMI_HBLANK_A, ((adjusted_mode->crtc_hdisplay - 1) << 16) |  temp);\n\n\tREG_WRITE(dspsize_reg, ((mode->vdisplay - 1) << 16) | (mode->hdisplay - 1));\n\tREG_WRITE(dsppos_reg, 0);\n\n\t \n\t{\n\t\tconst struct drm_crtc_helper_funcs *crtc_funcs = crtc->helper_private;\n\t\tcrtc_funcs->mode_set_base(crtc, x, y, old_fb);\n\t}\n\n\t \n\tdspcntr = REG_READ(dspcntr_reg);\n\tdspcntr |= DISPPLANE_GAMMA_ENABLE;\n\tdspcntr |= DISPPLANE_SEL_PIPE_B;\n\tdspcntr |= DISPLAY_PLANE_ENABLE;\n\n\t \n\tpipeconf = REG_READ(pipeconf_reg);\n\tpipeconf |= PIPEACONF_ENABLE;\n\n\tREG_WRITE(pipeconf_reg, pipeconf);\n\tREG_READ(pipeconf_reg);\n\n\tREG_WRITE(PCH_PIPEBCONF, pipeconf);\n\tREG_READ(PCH_PIPEBCONF);\n\tgma_wait_for_vblank(dev);\n\n\tREG_WRITE(dspcntr_reg, dspcntr);\n\tgma_wait_for_vblank(dev);\n\n\tgma_power_end(dev);\n\n\treturn 0;\n}\n\nvoid oaktrail_crtc_hdmi_dpms(struct drm_crtc *crtc, int mode)\n{\n\tstruct drm_device *dev = crtc->dev;\n\tu32 temp;\n\n\tDRM_DEBUG_KMS(\"%s %d\\n\", __func__, mode);\n\n\tswitch (mode) {\n\tcase DRM_MODE_DPMS_OFF:\n\t\tREG_WRITE(VGACNTRL, 0x80000000);\n\n\t\t \n\t\ttemp = REG_READ(DSPBCNTR);\n\t\tif ((temp & DISPLAY_PLANE_ENABLE) != 0) {\n\t\t\tREG_WRITE(DSPBCNTR, temp & ~DISPLAY_PLANE_ENABLE);\n\t\t\tREG_READ(DSPBCNTR);\n\t\t\t \n\t\t\tREG_WRITE(DSPBSURF, REG_READ(DSPBSURF));\n\t\t\tREG_READ(DSPBSURF);\n\t\t}\n\n\t\t \n\t\ttemp = REG_READ(PIPEBCONF);\n\t\tif ((temp & PIPEACONF_ENABLE) != 0) {\n\t\t\tREG_WRITE(PIPEBCONF, temp & ~PIPEACONF_ENABLE);\n\t\t\tREG_READ(PIPEBCONF);\n\t\t}\n\n\t\t \n\t\ttemp = REG_READ(PCH_PIPEBCONF);\n\t\tif ((temp & PIPEACONF_ENABLE) != 0) {\n\t\t\tREG_WRITE(PCH_PIPEBCONF, temp & ~PIPEACONF_ENABLE);\n\t\t\tREG_READ(PCH_PIPEBCONF);\n\t\t}\n\n\t\t \n\t\tudelay(150);\n\n\t\t \n\t\ttemp = REG_READ(DPLL_CTRL);\n\t\tif ((temp & DPLL_PWRDN) == 0) {\n\t\t\tREG_WRITE(DPLL_CTRL, temp | (DPLL_PWRDN | DPLL_RESET));\n\t\t\tREG_WRITE(DPLL_STATUS, 0x1);\n\t\t}\n\n\t\t \n\t\tudelay(150);\n\n\t\tbreak;\n\tcase DRM_MODE_DPMS_ON:\n\tcase DRM_MODE_DPMS_STANDBY:\n\tcase DRM_MODE_DPMS_SUSPEND:\n\t\t \n\t\ttemp = REG_READ(DPLL_CTRL);\n\t\tif ((temp & DPLL_PWRDN) != 0) {\n\t\t\tREG_WRITE(DPLL_CTRL, temp & ~(DPLL_PWRDN | DPLL_RESET));\n\t\t\ttemp = REG_READ(DPLL_CLK_ENABLE);\n\t\t\tREG_WRITE(DPLL_CLK_ENABLE, temp | DPLL_EN_DISP | DPLL_SEL_HDMI | DPLL_EN_HDMI);\n\t\t\tREG_READ(DPLL_CLK_ENABLE);\n\t\t}\n\t\t \n\t\tudelay(150);\n\n\t\t \n\t\ttemp = REG_READ(PIPEBCONF);\n\t\tif ((temp & PIPEACONF_ENABLE) == 0) {\n\t\t\tREG_WRITE(PIPEBCONF, temp | PIPEACONF_ENABLE);\n\t\t\tREG_READ(PIPEBCONF);\n\t\t}\n\n\t\t \n\t\ttemp = REG_READ(PCH_PIPEBCONF);\n\t\tif ((temp & PIPEACONF_ENABLE) == 0) {\n\t\t\tREG_WRITE(PCH_PIPEBCONF, temp | PIPEACONF_ENABLE);\n\t\t\tREG_READ(PCH_PIPEBCONF);\n\t\t}\n\n\t\tgma_wait_for_vblank(dev);\n\n\t\t \n\t\ttemp = REG_READ(DSPBCNTR);\n\t\tif ((temp & DISPLAY_PLANE_ENABLE) == 0) {\n\t\t\tREG_WRITE(DSPBCNTR, temp | DISPLAY_PLANE_ENABLE);\n\t\t\t \n\t\t\tREG_WRITE(DSPBSURF, REG_READ(DSPBSURF));\n\t\t\tREG_READ(DSPBSURF);\n\t\t}\n\n\t\tgma_crtc_load_lut(crtc);\n\t}\n\n\t \n\tREG_WRITE(DSPARB, 0x00003fbf);\n\n\t \n\tREG_WRITE(0x70034, 0x3f880a0a);\n\n\t \n\tREG_WRITE(0x70038, 0x0b060808);\n\n\t \n\tREG_WRITE(0x70050, 0x08030404);\n\n\t \n\tREG_WRITE(0x70054, 0x04040404);\n\n\t \n\tREG_WRITE(0x70400, 0x4000);\n\n\treturn;\n}\n\nstatic void oaktrail_hdmi_dpms(struct drm_encoder *encoder, int mode)\n{\n\tstatic int dpms_mode = -1;\n\n\tstruct drm_device *dev = encoder->dev;\n\tstruct drm_psb_private *dev_priv = to_drm_psb_private(dev);\n\tstruct oaktrail_hdmi_dev *hdmi_dev = dev_priv->hdmi_priv;\n\tu32 temp;\n\n\tif (dpms_mode == mode)\n\t\treturn;\n\n\tif (mode != DRM_MODE_DPMS_ON)\n\t\ttemp = 0x0;\n\telse\n\t\ttemp = 0x99;\n\n\tdpms_mode = mode;\n\tHDMI_WRITE(HDMI_VIDEO_REG, temp);\n}\n\nstatic enum drm_mode_status oaktrail_hdmi_mode_valid(struct drm_connector *connector,\n\t\t\t\tstruct drm_display_mode *mode)\n{\n\tif (mode->clock > 165000)\n\t\treturn MODE_CLOCK_HIGH;\n\tif (mode->clock < 20000)\n\t\treturn MODE_CLOCK_LOW;\n\n\tif (mode->flags & DRM_MODE_FLAG_DBLSCAN)\n\t\treturn MODE_NO_DBLESCAN;\n\n\treturn MODE_OK;\n}\n\nstatic enum drm_connector_status\noaktrail_hdmi_detect(struct drm_connector *connector, bool force)\n{\n\tenum drm_connector_status status;\n\tstruct drm_device *dev = connector->dev;\n\tstruct drm_psb_private *dev_priv = to_drm_psb_private(dev);\n\tstruct oaktrail_hdmi_dev *hdmi_dev = dev_priv->hdmi_priv;\n\tu32 temp;\n\n\ttemp = HDMI_READ(HDMI_HSR);\n\tDRM_DEBUG_KMS(\"HDMI_HSR %x\\n\", temp);\n\n\tif ((temp & HDMI_DETECT_HDP) != 0)\n\t\tstatus = connector_status_connected;\n\telse\n\t\tstatus = connector_status_disconnected;\n\n\treturn status;\n}\n\nstatic const unsigned char raw_edid[] = {\n\t0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x10, 0xac, 0x2f, 0xa0,\n\t0x53, 0x55, 0x33, 0x30, 0x16, 0x13, 0x01, 0x03, 0x0e, 0x3a, 0x24, 0x78,\n\t0xea, 0xe9, 0xf5, 0xac, 0x51, 0x30, 0xb4, 0x25, 0x11, 0x50, 0x54, 0xa5,\n\t0x4b, 0x00, 0x81, 0x80, 0xa9, 0x40, 0x71, 0x4f, 0xb3, 0x00, 0x01, 0x01,\n\t0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x28, 0x3c, 0x80, 0xa0, 0x70, 0xb0,\n\t0x23, 0x40, 0x30, 0x20, 0x36, 0x00, 0x46, 0x6c, 0x21, 0x00, 0x00, 0x1a,\n\t0x00, 0x00, 0x00, 0xff, 0x00, 0x47, 0x4e, 0x37, 0x32, 0x31, 0x39, 0x35,\n\t0x52, 0x30, 0x33, 0x55, 0x53, 0x0a, 0x00, 0x00, 0x00, 0xfc, 0x00, 0x44,\n\t0x45, 0x4c, 0x4c, 0x20, 0x32, 0x37, 0x30, 0x39, 0x57, 0x0a, 0x20, 0x20,\n\t0x00, 0x00, 0x00, 0xfd, 0x00, 0x38, 0x4c, 0x1e, 0x53, 0x11, 0x00, 0x0a,\n\t0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x00, 0x8d\n};\n\nstatic int oaktrail_hdmi_get_modes(struct drm_connector *connector)\n{\n\tstruct i2c_adapter *i2c_adap;\n\tstruct edid *edid;\n\tint ret = 0;\n\n\t \n\ti2c_adap = i2c_get_adapter(3);\n\tif (i2c_adap == NULL) {\n\t\tDRM_ERROR(\"No ddc adapter available!\\n\");\n\t\tedid = (struct edid *)raw_edid;\n\t} else {\n\t\tedid = (struct edid *)raw_edid;\n\t\t \n\t}\n\n\tif (edid) {\n\t\tdrm_connector_update_edid_property(connector, edid);\n\t\tret = drm_add_edid_modes(connector, edid);\n\t}\n\treturn ret;\n}\n\nstatic void oaktrail_hdmi_mode_set(struct drm_encoder *encoder,\n\t\t\t       struct drm_display_mode *mode,\n\t\t\t       struct drm_display_mode *adjusted_mode)\n{\n\tstruct drm_device *dev = encoder->dev;\n\n\toaktrail_hdmi_audio_enable(dev);\n\treturn;\n}\n\nstatic void oaktrail_hdmi_destroy(struct drm_connector *connector)\n{\n\treturn;\n}\n\nstatic const struct drm_encoder_helper_funcs oaktrail_hdmi_helper_funcs = {\n\t.dpms = oaktrail_hdmi_dpms,\n\t.prepare = gma_encoder_prepare,\n\t.mode_set = oaktrail_hdmi_mode_set,\n\t.commit = gma_encoder_commit,\n};\n\nstatic const struct drm_connector_helper_funcs\n\t\t\t\t\toaktrail_hdmi_connector_helper_funcs = {\n\t.get_modes = oaktrail_hdmi_get_modes,\n\t.mode_valid = oaktrail_hdmi_mode_valid,\n\t.best_encoder = gma_best_encoder,\n};\n\nstatic const struct drm_connector_funcs oaktrail_hdmi_connector_funcs = {\n\t.dpms = drm_helper_connector_dpms,\n\t.detect = oaktrail_hdmi_detect,\n\t.fill_modes = drm_helper_probe_single_connector_modes,\n\t.destroy = oaktrail_hdmi_destroy,\n};\n\nvoid oaktrail_hdmi_init(struct drm_device *dev,\n\t\t\t\t\tstruct psb_intel_mode_device *mode_dev)\n{\n\tstruct gma_encoder *gma_encoder;\n\tstruct gma_connector *gma_connector;\n\tstruct drm_connector *connector;\n\tstruct drm_encoder *encoder;\n\n\tgma_encoder = kzalloc(sizeof(struct gma_encoder), GFP_KERNEL);\n\tif (!gma_encoder)\n\t\treturn;\n\n\tgma_connector = kzalloc(sizeof(struct gma_connector), GFP_KERNEL);\n\tif (!gma_connector)\n\t\tgoto failed_connector;\n\n\tconnector = &gma_connector->base;\n\tencoder = &gma_encoder->base;\n\tdrm_connector_init(dev, connector,\n\t\t\t   &oaktrail_hdmi_connector_funcs,\n\t\t\t   DRM_MODE_CONNECTOR_DVID);\n\n\tdrm_simple_encoder_init(dev, encoder, DRM_MODE_ENCODER_TMDS);\n\n\tgma_connector_attach_encoder(gma_connector, gma_encoder);\n\n\tgma_encoder->type = INTEL_OUTPUT_HDMI;\n\tdrm_encoder_helper_add(encoder, &oaktrail_hdmi_helper_funcs);\n\tdrm_connector_helper_add(connector, &oaktrail_hdmi_connector_helper_funcs);\n\n\tconnector->display_info.subpixel_order = SubPixelHorizontalRGB;\n\tconnector->interlace_allowed = false;\n\tconnector->doublescan_allowed = false;\n\tdev_info(dev->dev, \"HDMI initialised.\\n\");\n\n\treturn;\n\nfailed_connector:\n\tkfree(gma_encoder);\n}\n\nvoid oaktrail_hdmi_setup(struct drm_device *dev)\n{\n\tstruct drm_psb_private *dev_priv = to_drm_psb_private(dev);\n\tstruct pci_dev *pdev;\n\tstruct oaktrail_hdmi_dev *hdmi_dev;\n\tint ret;\n\n\tpdev = pci_get_device(PCI_VENDOR_ID_INTEL, 0x080d, NULL);\n\tif (!pdev)\n\t\treturn;\n\n\thdmi_dev = kzalloc(sizeof(struct oaktrail_hdmi_dev), GFP_KERNEL);\n\tif (!hdmi_dev) {\n\t\tdev_err(dev->dev, \"failed to allocate memory\\n\");\n\t\tgoto out;\n\t}\n\n\n\tret = pci_enable_device(pdev);\n\tif (ret) {\n\t\tdev_err(dev->dev, \"failed to enable hdmi controller\\n\");\n\t\tgoto free;\n\t}\n\n\thdmi_dev->mmio = pci_resource_start(pdev, 0);\n\thdmi_dev->mmio_len = pci_resource_len(pdev, 0);\n\thdmi_dev->regs = ioremap(hdmi_dev->mmio, hdmi_dev->mmio_len);\n\tif (!hdmi_dev->regs) {\n\t\tdev_err(dev->dev, \"failed to map hdmi mmio\\n\");\n\t\tgoto free;\n\t}\n\n\thdmi_dev->dev = pdev;\n\tpci_set_drvdata(pdev, hdmi_dev);\n\n\t \n\tret = oaktrail_hdmi_i2c_init(hdmi_dev->dev);\n\tif (ret)\n\t\tdev_err(dev->dev, \"HDMI I2C initialization failed\\n\");\n\n\tdev_priv->hdmi_priv = hdmi_dev;\n\toaktrail_hdmi_audio_disable(dev);\n\n\tdev_info(dev->dev, \"HDMI hardware present.\\n\");\n\n\treturn;\n\nfree:\n\tkfree(hdmi_dev);\nout:\n\treturn;\n}\n\nvoid oaktrail_hdmi_teardown(struct drm_device *dev)\n{\n\tstruct drm_psb_private *dev_priv = to_drm_psb_private(dev);\n\tstruct oaktrail_hdmi_dev *hdmi_dev = dev_priv->hdmi_priv;\n\tstruct pci_dev *pdev;\n\n\tif (hdmi_dev) {\n\t\tpdev = hdmi_dev->dev;\n\t\tpci_set_drvdata(pdev, NULL);\n\t\toaktrail_hdmi_i2c_exit(pdev);\n\t\tiounmap(hdmi_dev->regs);\n\t\tkfree(hdmi_dev);\n\t\tpci_dev_put(pdev);\n\t}\n}\n\n \nvoid oaktrail_hdmi_save(struct drm_device *dev)\n{\n\tstruct drm_psb_private *dev_priv = to_drm_psb_private(dev);\n\tstruct oaktrail_hdmi_dev *hdmi_dev = dev_priv->hdmi_priv;\n\tstruct psb_state *regs = &dev_priv->regs.psb;\n\tstruct psb_pipe *pipeb = &dev_priv->regs.pipe[1];\n\tint i;\n\n\t \n\thdmi_dev->saveDPLL_CTRL = PSB_RVDC32(DPLL_CTRL);\n\thdmi_dev->saveDPLL_DIV_CTRL = PSB_RVDC32(DPLL_DIV_CTRL);\n\thdmi_dev->saveDPLL_ADJUST = PSB_RVDC32(DPLL_ADJUST);\n\thdmi_dev->saveDPLL_UPDATE = PSB_RVDC32(DPLL_UPDATE);\n\thdmi_dev->saveDPLL_CLK_ENABLE = PSB_RVDC32(DPLL_CLK_ENABLE);\n\n\t \n\tpipeb->conf = PSB_RVDC32(PIPEBCONF);\n\tpipeb->src = PSB_RVDC32(PIPEBSRC);\n\tpipeb->htotal = PSB_RVDC32(HTOTAL_B);\n\tpipeb->hblank = PSB_RVDC32(HBLANK_B);\n\tpipeb->hsync = PSB_RVDC32(HSYNC_B);\n\tpipeb->vtotal = PSB_RVDC32(VTOTAL_B);\n\tpipeb->vblank = PSB_RVDC32(VBLANK_B);\n\tpipeb->vsync = PSB_RVDC32(VSYNC_B);\n\n\thdmi_dev->savePCH_PIPEBCONF = PSB_RVDC32(PCH_PIPEBCONF);\n\thdmi_dev->savePCH_PIPEBSRC = PSB_RVDC32(PCH_PIPEBSRC);\n\thdmi_dev->savePCH_HTOTAL_B = PSB_RVDC32(PCH_HTOTAL_B);\n\thdmi_dev->savePCH_HBLANK_B = PSB_RVDC32(PCH_HBLANK_B);\n\thdmi_dev->savePCH_HSYNC_B  = PSB_RVDC32(PCH_HSYNC_B);\n\thdmi_dev->savePCH_VTOTAL_B = PSB_RVDC32(PCH_VTOTAL_B);\n\thdmi_dev->savePCH_VBLANK_B = PSB_RVDC32(PCH_VBLANK_B);\n\thdmi_dev->savePCH_VSYNC_B  = PSB_RVDC32(PCH_VSYNC_B);\n\n\t \n\tpipeb->cntr = PSB_RVDC32(DSPBCNTR);\n\tpipeb->stride = PSB_RVDC32(DSPBSTRIDE);\n\tpipeb->addr = PSB_RVDC32(DSPBBASE);\n\tpipeb->surf = PSB_RVDC32(DSPBSURF);\n\tpipeb->linoff = PSB_RVDC32(DSPBLINOFF);\n\tpipeb->tileoff = PSB_RVDC32(DSPBTILEOFF);\n\n\t \n\tregs->saveDSPBCURSOR_CTRL = PSB_RVDC32(CURBCNTR);\n\tregs->saveDSPBCURSOR_BASE = PSB_RVDC32(CURBBASE);\n\tregs->saveDSPBCURSOR_POS = PSB_RVDC32(CURBPOS);\n\n\t \n\tfor (i = 0; i < 256; i++)\n\t\tpipeb->palette[i] = PSB_RVDC32(PALETTE_B + (i << 2));\n}\n\n \nvoid oaktrail_hdmi_restore(struct drm_device *dev)\n{\n\tstruct drm_psb_private *dev_priv = to_drm_psb_private(dev);\n\tstruct oaktrail_hdmi_dev *hdmi_dev = dev_priv->hdmi_priv;\n\tstruct psb_state *regs = &dev_priv->regs.psb;\n\tstruct psb_pipe *pipeb = &dev_priv->regs.pipe[1];\n\tint i;\n\n\t \n\tPSB_WVDC32(hdmi_dev->saveDPLL_CTRL, DPLL_CTRL);\n\tPSB_WVDC32(hdmi_dev->saveDPLL_DIV_CTRL, DPLL_DIV_CTRL);\n\tPSB_WVDC32(hdmi_dev->saveDPLL_ADJUST, DPLL_ADJUST);\n\tPSB_WVDC32(hdmi_dev->saveDPLL_UPDATE, DPLL_UPDATE);\n\tPSB_WVDC32(hdmi_dev->saveDPLL_CLK_ENABLE, DPLL_CLK_ENABLE);\n\tudelay(150);\n\n\t \n\tPSB_WVDC32(pipeb->src, PIPEBSRC);\n\tPSB_WVDC32(pipeb->htotal, HTOTAL_B);\n\tPSB_WVDC32(pipeb->hblank, HBLANK_B);\n\tPSB_WVDC32(pipeb->hsync,  HSYNC_B);\n\tPSB_WVDC32(pipeb->vtotal, VTOTAL_B);\n\tPSB_WVDC32(pipeb->vblank, VBLANK_B);\n\tPSB_WVDC32(pipeb->vsync,  VSYNC_B);\n\n\tPSB_WVDC32(hdmi_dev->savePCH_PIPEBSRC, PCH_PIPEBSRC);\n\tPSB_WVDC32(hdmi_dev->savePCH_HTOTAL_B, PCH_HTOTAL_B);\n\tPSB_WVDC32(hdmi_dev->savePCH_HBLANK_B, PCH_HBLANK_B);\n\tPSB_WVDC32(hdmi_dev->savePCH_HSYNC_B,  PCH_HSYNC_B);\n\tPSB_WVDC32(hdmi_dev->savePCH_VTOTAL_B, PCH_VTOTAL_B);\n\tPSB_WVDC32(hdmi_dev->savePCH_VBLANK_B, PCH_VBLANK_B);\n\tPSB_WVDC32(hdmi_dev->savePCH_VSYNC_B,  PCH_VSYNC_B);\n\n\tPSB_WVDC32(pipeb->conf, PIPEBCONF);\n\tPSB_WVDC32(hdmi_dev->savePCH_PIPEBCONF, PCH_PIPEBCONF);\n\n\t \n\tPSB_WVDC32(pipeb->linoff, DSPBLINOFF);\n\tPSB_WVDC32(pipeb->stride, DSPBSTRIDE);\n\tPSB_WVDC32(pipeb->tileoff, DSPBTILEOFF);\n\tPSB_WVDC32(pipeb->cntr, DSPBCNTR);\n\tPSB_WVDC32(pipeb->surf, DSPBSURF);\n\n\t \n\tPSB_WVDC32(regs->saveDSPBCURSOR_CTRL, CURBCNTR);\n\tPSB_WVDC32(regs->saveDSPBCURSOR_POS, CURBPOS);\n\tPSB_WVDC32(regs->saveDSPBCURSOR_BASE, CURBBASE);\n\n\t \n\tfor (i = 0; i < 256; i++)\n\t\tPSB_WVDC32(pipeb->palette[i], PALETTE_B + (i << 2));\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}