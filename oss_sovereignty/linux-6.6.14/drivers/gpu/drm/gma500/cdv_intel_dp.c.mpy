{
  "module_name": "cdv_intel_dp.c",
  "hash_id": "506b740ecac56da171ce1502638bd15cf9d40805bb0dc189575eff27264952dc",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/gma500/cdv_intel_dp.c",
  "human_readable_source": " \n\n#include <linux/i2c.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n\n#include <drm/display/drm_dp_helper.h>\n#include <drm/drm_crtc.h>\n#include <drm/drm_crtc_helper.h>\n#include <drm/drm_edid.h>\n#include <drm/drm_modeset_helper_vtables.h>\n#include <drm/drm_simple_kms_helper.h>\n\n#include \"gma_display.h\"\n#include \"psb_drv.h\"\n#include \"psb_intel_drv.h\"\n#include \"psb_intel_reg.h\"\n\n \nstruct i2c_algo_dp_aux_data {\n\tbool running;\n\tu16 address;\n\tint (*aux_ch) (struct i2c_adapter *adapter,\n\t\t       int mode, uint8_t write_byte,\n\t\t       uint8_t *read_byte);\n};\n\n \nstatic int\ni2c_algo_dp_aux_transaction(struct i2c_adapter *adapter, int mode,\n\t\t\t    uint8_t write_byte, uint8_t *read_byte)\n{\n\tstruct i2c_algo_dp_aux_data *algo_data = adapter->algo_data;\n\tint ret;\n\n\tret = (*algo_data->aux_ch)(adapter, mode,\n\t\t\t\t   write_byte, read_byte);\n\treturn ret;\n}\n\n \n\n \nstatic int\ni2c_algo_dp_aux_address(struct i2c_adapter *adapter, u16 address, bool reading)\n{\n\tstruct i2c_algo_dp_aux_data *algo_data = adapter->algo_data;\n\tint mode = MODE_I2C_START;\n\n\tif (reading)\n\t\tmode |= MODE_I2C_READ;\n\telse\n\t\tmode |= MODE_I2C_WRITE;\n\talgo_data->address = address;\n\talgo_data->running = true;\n\treturn i2c_algo_dp_aux_transaction(adapter, mode, 0, NULL);\n}\n\n \nstatic void\ni2c_algo_dp_aux_stop(struct i2c_adapter *adapter, bool reading)\n{\n\tstruct i2c_algo_dp_aux_data *algo_data = adapter->algo_data;\n\tint mode = MODE_I2C_STOP;\n\n\tif (reading)\n\t\tmode |= MODE_I2C_READ;\n\telse\n\t\tmode |= MODE_I2C_WRITE;\n\tif (algo_data->running) {\n\t\t(void) i2c_algo_dp_aux_transaction(adapter, mode, 0, NULL);\n\t\talgo_data->running = false;\n\t}\n}\n\n \nstatic int\ni2c_algo_dp_aux_put_byte(struct i2c_adapter *adapter, u8 byte)\n{\n\tstruct i2c_algo_dp_aux_data *algo_data = adapter->algo_data;\n\n\tif (!algo_data->running)\n\t\treturn -EIO;\n\n\treturn i2c_algo_dp_aux_transaction(adapter, MODE_I2C_WRITE, byte, NULL);\n}\n\n \nstatic int\ni2c_algo_dp_aux_get_byte(struct i2c_adapter *adapter, u8 *byte_ret)\n{\n\tstruct i2c_algo_dp_aux_data *algo_data = adapter->algo_data;\n\n\tif (!algo_data->running)\n\t\treturn -EIO;\n\n\treturn i2c_algo_dp_aux_transaction(adapter, MODE_I2C_READ, 0, byte_ret);\n}\n\nstatic int\ni2c_algo_dp_aux_xfer(struct i2c_adapter *adapter,\n\t\t     struct i2c_msg *msgs,\n\t\t     int num)\n{\n\tint ret = 0;\n\tbool reading = false;\n\tint m;\n\tint b;\n\n\tfor (m = 0; m < num; m++) {\n\t\tu16 len = msgs[m].len;\n\t\tu8 *buf = msgs[m].buf;\n\t\treading = (msgs[m].flags & I2C_M_RD) != 0;\n\t\tret = i2c_algo_dp_aux_address(adapter, msgs[m].addr, reading);\n\t\tif (ret < 0)\n\t\t\tbreak;\n\t\tif (reading) {\n\t\t\tfor (b = 0; b < len; b++) {\n\t\t\t\tret = i2c_algo_dp_aux_get_byte(adapter, &buf[b]);\n\t\t\t\tif (ret < 0)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t} else {\n\t\t\tfor (b = 0; b < len; b++) {\n\t\t\t\tret = i2c_algo_dp_aux_put_byte(adapter, buf[b]);\n\t\t\t\tif (ret < 0)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (ret < 0)\n\t\t\tbreak;\n\t}\n\tif (ret >= 0)\n\t\tret = num;\n\ti2c_algo_dp_aux_stop(adapter, reading);\n\tDRM_DEBUG_KMS(\"dp_aux_xfer return %d\\n\", ret);\n\treturn ret;\n}\n\nstatic u32\ni2c_algo_dp_aux_functionality(struct i2c_adapter *adapter)\n{\n\treturn I2C_FUNC_I2C | I2C_FUNC_SMBUS_EMUL |\n\t       I2C_FUNC_SMBUS_READ_BLOCK_DATA |\n\t       I2C_FUNC_SMBUS_BLOCK_PROC_CALL |\n\t       I2C_FUNC_10BIT_ADDR;\n}\n\nstatic const struct i2c_algorithm i2c_dp_aux_algo = {\n\t.master_xfer\t= i2c_algo_dp_aux_xfer,\n\t.functionality\t= i2c_algo_dp_aux_functionality,\n};\n\nstatic void\ni2c_dp_aux_reset_bus(struct i2c_adapter *adapter)\n{\n\t(void) i2c_algo_dp_aux_address(adapter, 0, false);\n\t(void) i2c_algo_dp_aux_stop(adapter, false);\n}\n\nstatic int\ni2c_dp_aux_prepare_bus(struct i2c_adapter *adapter)\n{\n\tadapter->algo = &i2c_dp_aux_algo;\n\tadapter->retries = 3;\n\ti2c_dp_aux_reset_bus(adapter);\n\treturn 0;\n}\n\n \nstatic int\ni2c_dp_aux_add_bus(struct i2c_adapter *adapter)\n{\n\tint error;\n\n\terror = i2c_dp_aux_prepare_bus(adapter);\n\tif (error)\n\t\treturn error;\n\terror = i2c_add_adapter(adapter);\n\treturn error;\n}\n\n#define _wait_for(COND, MS, W) ({ \\\n        unsigned long timeout__ = jiffies + msecs_to_jiffies(MS);       \\\n        int ret__ = 0;                                                  \\\n        while (! (COND)) {                                              \\\n                if (time_after(jiffies, timeout__)) {                   \\\n                        ret__ = -ETIMEDOUT;                             \\\n                        break;                                          \\\n                }                                                       \\\n                if (W && !in_dbg_master()) msleep(W);                   \\\n        }                                                               \\\n        ret__;                                                          \\\n})\n\n#define wait_for(COND, MS) _wait_for(COND, MS, 1)\n\n#define DP_LINK_CHECK_TIMEOUT\t(10 * 1000)\n\n#define DP_LINK_CONFIGURATION_SIZE\t9\n\n#define CDV_FAST_LINK_TRAIN\t1\n\nstruct cdv_intel_dp {\n\tuint32_t output_reg;\n\tuint32_t DP;\n\tuint8_t  link_configuration[DP_LINK_CONFIGURATION_SIZE];\n\tbool has_audio;\n\tint force_audio;\n\tuint32_t color_range;\n\tuint8_t link_bw;\n\tuint8_t lane_count;\n\tuint8_t dpcd[4];\n\tstruct gma_encoder *encoder;\n\tstruct i2c_adapter adapter;\n\tstruct i2c_algo_dp_aux_data algo;\n\tuint8_t\ttrain_set[4];\n\tuint8_t link_status[DP_LINK_STATUS_SIZE];\n\tint panel_power_up_delay;\n\tint panel_power_down_delay;\n\tint panel_power_cycle_delay;\n\tint backlight_on_delay;\n\tint backlight_off_delay;\n\tstruct drm_display_mode *panel_fixed_mode;   \n\tbool panel_on;\n};\n\nstruct ddi_regoff {\n\tuint32_t\tPreEmph1;\n\tuint32_t\tPreEmph2;\n\tuint32_t\tVSwing1;\n\tuint32_t\tVSwing2;\n\tuint32_t\tVSwing3;\n\tuint32_t\tVSwing4;\n\tuint32_t\tVSwing5;\n};\n\nstatic struct ddi_regoff ddi_DP_train_table[] = {\n\t{.PreEmph1 = 0x812c, .PreEmph2 = 0x8124, .VSwing1 = 0x8154,\n\t.VSwing2 = 0x8148, .VSwing3 = 0x814C, .VSwing4 = 0x8150,\n\t.VSwing5 = 0x8158,},\n\t{.PreEmph1 = 0x822c, .PreEmph2 = 0x8224, .VSwing1 = 0x8254,\n\t.VSwing2 = 0x8248, .VSwing3 = 0x824C, .VSwing4 = 0x8250,\n\t.VSwing5 = 0x8258,},\n};\n\nstatic uint32_t dp_vswing_premph_table[] = {\n        0x55338954,\t0x4000,\n        0x554d8954,\t0x2000,\n        0x55668954,\t0,\n        0x559ac0d4,\t0x6000,\n};\n \nstatic bool is_edp(struct gma_encoder *encoder)\n{\n\treturn encoder->type == INTEL_OUTPUT_EDP;\n}\n\n\nstatic void cdv_intel_dp_start_link_train(struct gma_encoder *encoder);\nstatic void cdv_intel_dp_complete_link_train(struct gma_encoder *encoder);\nstatic void cdv_intel_dp_link_down(struct gma_encoder *encoder);\n\nstatic int\ncdv_intel_dp_max_lane_count(struct gma_encoder *encoder)\n{\n\tstruct cdv_intel_dp *intel_dp = encoder->dev_priv;\n\tint max_lane_count = 4;\n\n\tif (intel_dp->dpcd[DP_DPCD_REV] >= 0x11) {\n\t\tmax_lane_count = intel_dp->dpcd[DP_MAX_LANE_COUNT] & 0x1f;\n\t\tswitch (max_lane_count) {\n\t\tcase 1: case 2: case 4:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tmax_lane_count = 4;\n\t\t}\n\t}\n\treturn max_lane_count;\n}\n\nstatic int\ncdv_intel_dp_max_link_bw(struct gma_encoder *encoder)\n{\n\tstruct cdv_intel_dp *intel_dp = encoder->dev_priv;\n\tint max_link_bw = intel_dp->dpcd[DP_MAX_LINK_RATE];\n\n\tswitch (max_link_bw) {\n\tcase DP_LINK_BW_1_62:\n\tcase DP_LINK_BW_2_7:\n\t\tbreak;\n\tdefault:\n\t\tmax_link_bw = DP_LINK_BW_1_62;\n\t\tbreak;\n\t}\n\treturn max_link_bw;\n}\n\nstatic int\ncdv_intel_dp_link_clock(uint8_t link_bw)\n{\n\tif (link_bw == DP_LINK_BW_2_7)\n\t\treturn 270000;\n\telse\n\t\treturn 162000;\n}\n\nstatic int\ncdv_intel_dp_link_required(int pixel_clock, int bpp)\n{\n\treturn (pixel_clock * bpp + 7) / 8;\n}\n\nstatic int\ncdv_intel_dp_max_data_rate(int max_link_clock, int max_lanes)\n{\n\treturn (max_link_clock * max_lanes * 19) / 20;\n}\n\nstatic void cdv_intel_edp_panel_vdd_on(struct gma_encoder *intel_encoder)\n{\n\tstruct drm_device *dev = intel_encoder->base.dev;\n\tstruct cdv_intel_dp *intel_dp = intel_encoder->dev_priv;\n\tu32 pp;\n\n\tif (intel_dp->panel_on) {\n\t\tDRM_DEBUG_KMS(\"Skip VDD on because of panel on\\n\");\n\t\treturn;\n\t}\n\tDRM_DEBUG_KMS(\"\\n\");\n\n\tpp = REG_READ(PP_CONTROL);\n\n\tpp |= EDP_FORCE_VDD;\n\tREG_WRITE(PP_CONTROL, pp);\n\tREG_READ(PP_CONTROL);\n\tmsleep(intel_dp->panel_power_up_delay);\n}\n\nstatic void cdv_intel_edp_panel_vdd_off(struct gma_encoder *intel_encoder)\n{\n\tstruct drm_device *dev = intel_encoder->base.dev;\n\tu32 pp;\n\n\tDRM_DEBUG_KMS(\"\\n\");\n\tpp = REG_READ(PP_CONTROL);\n\n\tpp &= ~EDP_FORCE_VDD;\n\tREG_WRITE(PP_CONTROL, pp);\n\tREG_READ(PP_CONTROL);\n\n}\n\n \nstatic bool cdv_intel_edp_panel_on(struct gma_encoder *intel_encoder)\n{\n\tstruct drm_device *dev = intel_encoder->base.dev;\n\tstruct cdv_intel_dp *intel_dp = intel_encoder->dev_priv;\n\tu32 pp, idle_on_mask = PP_ON | PP_SEQUENCE_NONE;\n\n\tif (intel_dp->panel_on)\n\t\treturn true;\n\n\tDRM_DEBUG_KMS(\"\\n\");\n\tpp = REG_READ(PP_CONTROL);\n\tpp &= ~PANEL_UNLOCK_MASK;\n\n\tpp |= (PANEL_UNLOCK_REGS | POWER_TARGET_ON);\n\tREG_WRITE(PP_CONTROL, pp);\n\tREG_READ(PP_CONTROL);\n\n\tif (wait_for(((REG_READ(PP_STATUS) & idle_on_mask) == idle_on_mask), 1000)) {\n\t\tDRM_DEBUG_KMS(\"Error in Powering up eDP panel, status %x\\n\", REG_READ(PP_STATUS));\n\t\tintel_dp->panel_on = false;\n\t} else\n\t\tintel_dp->panel_on = true;\n\tmsleep(intel_dp->panel_power_up_delay);\n\n\treturn false;\n}\n\nstatic void cdv_intel_edp_panel_off (struct gma_encoder *intel_encoder)\n{\n\tstruct drm_device *dev = intel_encoder->base.dev;\n\tu32 pp, idle_off_mask = PP_ON ;\n\tstruct cdv_intel_dp *intel_dp = intel_encoder->dev_priv;\n\n\tDRM_DEBUG_KMS(\"\\n\");\n\n\tpp = REG_READ(PP_CONTROL);\n\n\tif ((pp & POWER_TARGET_ON) == 0)\n\t\treturn;\n\n\tintel_dp->panel_on = false;\n\tpp &= ~PANEL_UNLOCK_MASK;\n\t \n\n\tpp &= ~POWER_TARGET_ON;\n\tpp &= ~EDP_FORCE_VDD;\n\tpp &= ~EDP_BLC_ENABLE;\n\tREG_WRITE(PP_CONTROL, pp);\n\tREG_READ(PP_CONTROL);\n\tDRM_DEBUG_KMS(\"PP_STATUS %x\\n\", REG_READ(PP_STATUS));\n\n\tif (wait_for((REG_READ(PP_STATUS) & idle_off_mask) == 0, 1000)) {\n\t\tDRM_DEBUG_KMS(\"Error in turning off Panel\\n\");\n\t}\n\n\tmsleep(intel_dp->panel_power_cycle_delay);\n\tDRM_DEBUG_KMS(\"Over\\n\");\n}\n\nstatic void cdv_intel_edp_backlight_on (struct gma_encoder *intel_encoder)\n{\n\tstruct drm_device *dev = intel_encoder->base.dev;\n\tu32 pp;\n\n\tDRM_DEBUG_KMS(\"\\n\");\n\t \n\tmsleep(300);\n\tpp = REG_READ(PP_CONTROL);\n\n\tpp |= EDP_BLC_ENABLE;\n\tREG_WRITE(PP_CONTROL, pp);\n\tgma_backlight_enable(dev);\n}\n\nstatic void cdv_intel_edp_backlight_off (struct gma_encoder *intel_encoder)\n{\n\tstruct drm_device *dev = intel_encoder->base.dev;\n\tstruct cdv_intel_dp *intel_dp = intel_encoder->dev_priv;\n\tu32 pp;\n\n\tDRM_DEBUG_KMS(\"\\n\");\n\tgma_backlight_disable(dev);\n\tmsleep(10);\n\tpp = REG_READ(PP_CONTROL);\n\n\tpp &= ~EDP_BLC_ENABLE;\n\tREG_WRITE(PP_CONTROL, pp);\n\tmsleep(intel_dp->backlight_off_delay);\n}\n\nstatic enum drm_mode_status\ncdv_intel_dp_mode_valid(struct drm_connector *connector,\n\t\t    struct drm_display_mode *mode)\n{\n\tstruct gma_encoder *encoder = gma_attached_encoder(connector);\n\tstruct cdv_intel_dp *intel_dp = encoder->dev_priv;\n\tint max_link_clock = cdv_intel_dp_link_clock(cdv_intel_dp_max_link_bw(encoder));\n\tint max_lanes = cdv_intel_dp_max_lane_count(encoder);\n\tstruct drm_psb_private *dev_priv = to_drm_psb_private(connector->dev);\n\n\tif (is_edp(encoder) && intel_dp->panel_fixed_mode) {\n\t\tif (mode->hdisplay > intel_dp->panel_fixed_mode->hdisplay)\n\t\t\treturn MODE_PANEL;\n\t\tif (mode->vdisplay > intel_dp->panel_fixed_mode->vdisplay)\n\t\t\treturn MODE_PANEL;\n\t}\n\n\t \n\tif (!is_edp(encoder) &&\n\t    (cdv_intel_dp_link_required(mode->clock, dev_priv->edp.bpp)\n\t     > cdv_intel_dp_max_data_rate(max_link_clock, max_lanes)))\n\t\treturn MODE_CLOCK_HIGH;\n\n\tif (is_edp(encoder)) {\n\t    if (cdv_intel_dp_link_required(mode->clock, 24)\n\t     \t> cdv_intel_dp_max_data_rate(max_link_clock, max_lanes))\n\t\treturn MODE_CLOCK_HIGH;\n\n\t}\n\tif (mode->clock < 10000)\n\t\treturn MODE_CLOCK_LOW;\n\n\treturn MODE_OK;\n}\n\nstatic uint32_t\npack_aux(uint8_t *src, int src_bytes)\n{\n\tint\ti;\n\tuint32_t v = 0;\n\n\tif (src_bytes > 4)\n\t\tsrc_bytes = 4;\n\tfor (i = 0; i < src_bytes; i++)\n\t\tv |= ((uint32_t) src[i]) << ((3-i) * 8);\n\treturn v;\n}\n\nstatic void\nunpack_aux(uint32_t src, uint8_t *dst, int dst_bytes)\n{\n\tint i;\n\tif (dst_bytes > 4)\n\t\tdst_bytes = 4;\n\tfor (i = 0; i < dst_bytes; i++)\n\t\tdst[i] = src >> ((3-i) * 8);\n}\n\nstatic int\ncdv_intel_dp_aux_ch(struct gma_encoder *encoder,\n\t\tuint8_t *send, int send_bytes,\n\t\tuint8_t *recv, int recv_size)\n{\n\tstruct cdv_intel_dp *intel_dp = encoder->dev_priv;\n\tuint32_t output_reg = intel_dp->output_reg;\n\tstruct drm_device *dev = encoder->base.dev;\n\tuint32_t ch_ctl = output_reg + 0x10;\n\tuint32_t ch_data = ch_ctl + 4;\n\tint i;\n\tint recv_bytes;\n\tuint32_t status;\n\tuint32_t aux_clock_divider;\n\tint try, precharge;\n\n\t \n\taux_clock_divider = 200 / 2;\n\n\tprecharge = 4;\n\tif (is_edp(encoder))\n\t\tprecharge = 10;\n\n\tif (REG_READ(ch_ctl) & DP_AUX_CH_CTL_SEND_BUSY) {\n\t\tDRM_ERROR(\"dp_aux_ch not started status 0x%08x\\n\",\n\t\t\t  REG_READ(ch_ctl));\n\t\treturn -EBUSY;\n\t}\n\n\t \n\tfor (try = 0; try < 5; try++) {\n\t\t \n\t\tfor (i = 0; i < send_bytes; i += 4)\n\t\t\tREG_WRITE(ch_data + i,\n\t\t\t\t   pack_aux(send + i, send_bytes - i));\n\n\t\t \n\t\tREG_WRITE(ch_ctl,\n\t\t\t   DP_AUX_CH_CTL_SEND_BUSY |\n\t\t\t   DP_AUX_CH_CTL_TIME_OUT_400us |\n\t\t\t   (send_bytes << DP_AUX_CH_CTL_MESSAGE_SIZE_SHIFT) |\n\t\t\t   (precharge << DP_AUX_CH_CTL_PRECHARGE_2US_SHIFT) |\n\t\t\t   (aux_clock_divider << DP_AUX_CH_CTL_BIT_CLOCK_2X_SHIFT) |\n\t\t\t   DP_AUX_CH_CTL_DONE |\n\t\t\t   DP_AUX_CH_CTL_TIME_OUT_ERROR |\n\t\t\t   DP_AUX_CH_CTL_RECEIVE_ERROR);\n\t\tfor (;;) {\n\t\t\tstatus = REG_READ(ch_ctl);\n\t\t\tif ((status & DP_AUX_CH_CTL_SEND_BUSY) == 0)\n\t\t\t\tbreak;\n\t\t\tudelay(100);\n\t\t}\n\n\t\t \n\t\tREG_WRITE(ch_ctl,\n\t\t\t   status |\n\t\t\t   DP_AUX_CH_CTL_DONE |\n\t\t\t   DP_AUX_CH_CTL_TIME_OUT_ERROR |\n\t\t\t   DP_AUX_CH_CTL_RECEIVE_ERROR);\n\t\tif (status & DP_AUX_CH_CTL_DONE)\n\t\t\tbreak;\n\t}\n\n\tif ((status & DP_AUX_CH_CTL_DONE) == 0) {\n\t\tDRM_ERROR(\"dp_aux_ch not done status 0x%08x\\n\", status);\n\t\treturn -EBUSY;\n\t}\n\n\t \n\tif (status & DP_AUX_CH_CTL_RECEIVE_ERROR) {\n\t\tDRM_ERROR(\"dp_aux_ch receive error status 0x%08x\\n\", status);\n\t\treturn -EIO;\n\t}\n\n\t \n\tif (status & DP_AUX_CH_CTL_TIME_OUT_ERROR) {\n\t\tDRM_DEBUG_KMS(\"dp_aux_ch timeout status 0x%08x\\n\", status);\n\t\treturn -ETIMEDOUT;\n\t}\n\n\t \n\trecv_bytes = ((status & DP_AUX_CH_CTL_MESSAGE_SIZE_MASK) >>\n\t\t      DP_AUX_CH_CTL_MESSAGE_SIZE_SHIFT);\n\tif (recv_bytes > recv_size)\n\t\trecv_bytes = recv_size;\n\n\tfor (i = 0; i < recv_bytes; i += 4)\n\t\tunpack_aux(REG_READ(ch_data + i),\n\t\t\t   recv + i, recv_bytes - i);\n\n\treturn recv_bytes;\n}\n\n \nstatic int\ncdv_intel_dp_aux_native_write(struct gma_encoder *encoder,\n\t\t\t  uint16_t address, uint8_t *send, int send_bytes)\n{\n\tint ret;\n\tuint8_t\tmsg[20];\n\tint msg_bytes;\n\tuint8_t\tack;\n\n\tif (send_bytes > 16)\n\t\treturn -1;\n\tmsg[0] = DP_AUX_NATIVE_WRITE << 4;\n\tmsg[1] = address >> 8;\n\tmsg[2] = address & 0xff;\n\tmsg[3] = send_bytes - 1;\n\tmemcpy(&msg[4], send, send_bytes);\n\tmsg_bytes = send_bytes + 4;\n\tfor (;;) {\n\t\tret = cdv_intel_dp_aux_ch(encoder, msg, msg_bytes, &ack, 1);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tack >>= 4;\n\t\tif ((ack & DP_AUX_NATIVE_REPLY_MASK) == DP_AUX_NATIVE_REPLY_ACK)\n\t\t\tbreak;\n\t\telse if ((ack & DP_AUX_NATIVE_REPLY_MASK) == DP_AUX_NATIVE_REPLY_DEFER)\n\t\t\tudelay(100);\n\t\telse\n\t\t\treturn -EIO;\n\t}\n\treturn send_bytes;\n}\n\n \nstatic int\ncdv_intel_dp_aux_native_write_1(struct gma_encoder *encoder,\n\t\t\t    uint16_t address, uint8_t byte)\n{\n\treturn cdv_intel_dp_aux_native_write(encoder, address, &byte, 1);\n}\n\n \nstatic int\ncdv_intel_dp_aux_native_read(struct gma_encoder *encoder,\n\t\t\t uint16_t address, uint8_t *recv, int recv_bytes)\n{\n\tuint8_t msg[4];\n\tint msg_bytes;\n\tuint8_t reply[20];\n\tint reply_bytes;\n\tuint8_t ack;\n\tint ret;\n\n\tmsg[0] = DP_AUX_NATIVE_READ << 4;\n\tmsg[1] = address >> 8;\n\tmsg[2] = address & 0xff;\n\tmsg[3] = recv_bytes - 1;\n\n\tmsg_bytes = 4;\n\treply_bytes = recv_bytes + 1;\n\n\tfor (;;) {\n\t\tret = cdv_intel_dp_aux_ch(encoder, msg, msg_bytes,\n\t\t\t\t      reply, reply_bytes);\n\t\tif (ret == 0)\n\t\t\treturn -EPROTO;\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tack = reply[0] >> 4;\n\t\tif ((ack & DP_AUX_NATIVE_REPLY_MASK) == DP_AUX_NATIVE_REPLY_ACK) {\n\t\t\tmemcpy(recv, reply + 1, ret - 1);\n\t\t\treturn ret - 1;\n\t\t}\n\t\telse if ((ack & DP_AUX_NATIVE_REPLY_MASK) == DP_AUX_NATIVE_REPLY_DEFER)\n\t\t\tudelay(100);\n\t\telse\n\t\t\treturn -EIO;\n\t}\n}\n\nstatic int\ncdv_intel_dp_i2c_aux_ch(struct i2c_adapter *adapter, int mode,\n\t\t    uint8_t write_byte, uint8_t *read_byte)\n{\n\tstruct i2c_algo_dp_aux_data *algo_data = adapter->algo_data;\n\tstruct cdv_intel_dp *intel_dp = container_of(adapter,\n\t\t\t\t\t\tstruct cdv_intel_dp,\n\t\t\t\t\t\tadapter);\n\tstruct gma_encoder *encoder = intel_dp->encoder;\n\tuint16_t address = algo_data->address;\n\tuint8_t msg[5];\n\tuint8_t reply[2];\n\tunsigned retry;\n\tint msg_bytes;\n\tint reply_bytes;\n\tint ret;\n\n\t \n\tif (mode & MODE_I2C_READ)\n\t\tmsg[0] = DP_AUX_I2C_READ << 4;\n\telse\n\t\tmsg[0] = DP_AUX_I2C_WRITE << 4;\n\n\tif (!(mode & MODE_I2C_STOP))\n\t\tmsg[0] |= DP_AUX_I2C_MOT << 4;\n\n\tmsg[1] = address >> 8;\n\tmsg[2] = address;\n\n\tswitch (mode) {\n\tcase MODE_I2C_WRITE:\n\t\tmsg[3] = 0;\n\t\tmsg[4] = write_byte;\n\t\tmsg_bytes = 5;\n\t\treply_bytes = 1;\n\t\tbreak;\n\tcase MODE_I2C_READ:\n\t\tmsg[3] = 0;\n\t\tmsg_bytes = 4;\n\t\treply_bytes = 2;\n\t\tbreak;\n\tdefault:\n\t\tmsg_bytes = 3;\n\t\treply_bytes = 1;\n\t\tbreak;\n\t}\n\n\tfor (retry = 0; retry < 5; retry++) {\n\t\tret = cdv_intel_dp_aux_ch(encoder,\n\t\t\t\t      msg, msg_bytes,\n\t\t\t\t      reply, reply_bytes);\n\t\tif (ret < 0) {\n\t\t\tDRM_DEBUG_KMS(\"aux_ch failed %d\\n\", ret);\n\t\t\treturn ret;\n\t\t}\n\n\t\tswitch ((reply[0] >> 4) & DP_AUX_NATIVE_REPLY_MASK) {\n\t\tcase DP_AUX_NATIVE_REPLY_ACK:\n\t\t\t \n\t\t\tbreak;\n\t\tcase DP_AUX_NATIVE_REPLY_NACK:\n\t\t\tDRM_DEBUG_KMS(\"aux_ch native nack\\n\");\n\t\t\treturn -EREMOTEIO;\n\t\tcase DP_AUX_NATIVE_REPLY_DEFER:\n\t\t\tudelay(100);\n\t\t\tcontinue;\n\t\tdefault:\n\t\t\tDRM_ERROR(\"aux_ch invalid native reply 0x%02x\\n\",\n\t\t\t\t  reply[0]);\n\t\t\treturn -EREMOTEIO;\n\t\t}\n\n\t\tswitch ((reply[0] >> 4) & DP_AUX_I2C_REPLY_MASK) {\n\t\tcase DP_AUX_I2C_REPLY_ACK:\n\t\t\tif (mode == MODE_I2C_READ) {\n\t\t\t\t*read_byte = reply[1];\n\t\t\t}\n\t\t\treturn reply_bytes - 1;\n\t\tcase DP_AUX_I2C_REPLY_NACK:\n\t\t\tDRM_DEBUG_KMS(\"aux_i2c nack\\n\");\n\t\t\treturn -EREMOTEIO;\n\t\tcase DP_AUX_I2C_REPLY_DEFER:\n\t\t\tDRM_DEBUG_KMS(\"aux_i2c defer\\n\");\n\t\t\tudelay(100);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tDRM_ERROR(\"aux_i2c invalid reply 0x%02x\\n\", reply[0]);\n\t\t\treturn -EREMOTEIO;\n\t\t}\n\t}\n\n\tDRM_ERROR(\"too many retries, giving up\\n\");\n\treturn -EREMOTEIO;\n}\n\nstatic int\ncdv_intel_dp_i2c_init(struct gma_connector *connector,\n\t\t      struct gma_encoder *encoder, const char *name)\n{\n\tstruct cdv_intel_dp *intel_dp = encoder->dev_priv;\n\tint ret;\n\n\tDRM_DEBUG_KMS(\"i2c_init %s\\n\", name);\n\n\tintel_dp->algo.running = false;\n\tintel_dp->algo.address = 0;\n\tintel_dp->algo.aux_ch = cdv_intel_dp_i2c_aux_ch;\n\n\tmemset(&intel_dp->adapter, '\\0', sizeof (intel_dp->adapter));\n\tintel_dp->adapter.owner = THIS_MODULE;\n\tintel_dp->adapter.class = I2C_CLASS_DDC;\n\tstrncpy (intel_dp->adapter.name, name, sizeof(intel_dp->adapter.name) - 1);\n\tintel_dp->adapter.name[sizeof(intel_dp->adapter.name) - 1] = '\\0';\n\tintel_dp->adapter.algo_data = &intel_dp->algo;\n\tintel_dp->adapter.dev.parent = connector->base.kdev;\n\n\tif (is_edp(encoder))\n\t\tcdv_intel_edp_panel_vdd_on(encoder);\n\tret = i2c_dp_aux_add_bus(&intel_dp->adapter);\n\tif (is_edp(encoder))\n\t\tcdv_intel_edp_panel_vdd_off(encoder);\n\n\treturn ret;\n}\n\nstatic void cdv_intel_fixed_panel_mode(struct drm_display_mode *fixed_mode,\n\tstruct drm_display_mode *adjusted_mode)\n{\n\tadjusted_mode->hdisplay = fixed_mode->hdisplay;\n\tadjusted_mode->hsync_start = fixed_mode->hsync_start;\n\tadjusted_mode->hsync_end = fixed_mode->hsync_end;\n\tadjusted_mode->htotal = fixed_mode->htotal;\n\n\tadjusted_mode->vdisplay = fixed_mode->vdisplay;\n\tadjusted_mode->vsync_start = fixed_mode->vsync_start;\n\tadjusted_mode->vsync_end = fixed_mode->vsync_end;\n\tadjusted_mode->vtotal = fixed_mode->vtotal;\n\n\tadjusted_mode->clock = fixed_mode->clock;\n\n\tdrm_mode_set_crtcinfo(adjusted_mode, CRTC_INTERLACE_HALVE_V);\n}\n\nstatic bool\ncdv_intel_dp_mode_fixup(struct drm_encoder *encoder, const struct drm_display_mode *mode,\n\t\t    struct drm_display_mode *adjusted_mode)\n{\n\tstruct drm_psb_private *dev_priv = to_drm_psb_private(encoder->dev);\n\tstruct gma_encoder *intel_encoder = to_gma_encoder(encoder);\n\tstruct cdv_intel_dp *intel_dp = intel_encoder->dev_priv;\n\tint lane_count, clock;\n\tint max_lane_count = cdv_intel_dp_max_lane_count(intel_encoder);\n\tint max_clock = cdv_intel_dp_max_link_bw(intel_encoder) == DP_LINK_BW_2_7 ? 1 : 0;\n\tstatic int bws[2] = { DP_LINK_BW_1_62, DP_LINK_BW_2_7 };\n\tint refclock = mode->clock;\n\tint bpp = 24;\n\n\tif (is_edp(intel_encoder) && intel_dp->panel_fixed_mode) {\n\t\tcdv_intel_fixed_panel_mode(intel_dp->panel_fixed_mode, adjusted_mode);\n\t\trefclock = intel_dp->panel_fixed_mode->clock;\n\t\tbpp = dev_priv->edp.bpp;\n\t}\n\n\tfor (lane_count = 1; lane_count <= max_lane_count; lane_count <<= 1) {\n\t\tfor (clock = max_clock; clock >= 0; clock--) {\n\t\t\tint link_avail = cdv_intel_dp_max_data_rate(cdv_intel_dp_link_clock(bws[clock]), lane_count);\n\n\t\t\tif (cdv_intel_dp_link_required(refclock, bpp) <= link_avail) {\n\t\t\t\tintel_dp->link_bw = bws[clock];\n\t\t\t\tintel_dp->lane_count = lane_count;\n\t\t\t\tadjusted_mode->clock = cdv_intel_dp_link_clock(intel_dp->link_bw);\n\t\t\t\tDRM_DEBUG_KMS(\"Display port link bw %02x lane \"\n\t\t\t\t\t\t\"count %d clock %d\\n\",\n\t\t\t\t       intel_dp->link_bw, intel_dp->lane_count,\n\t\t\t\t       adjusted_mode->clock);\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t}\n\tif (is_edp(intel_encoder)) {\n\t\t \n\t\tintel_dp->lane_count = max_lane_count;\n\t\tintel_dp->link_bw = bws[max_clock];\n\t\tadjusted_mode->clock = cdv_intel_dp_link_clock(intel_dp->link_bw);\n\t\tDRM_DEBUG_KMS(\"Force picking display port link bw %02x lane \"\n\t\t\t      \"count %d clock %d\\n\",\n\t\t\t      intel_dp->link_bw, intel_dp->lane_count,\n\t\t\t      adjusted_mode->clock);\n\n\t\treturn true;\n\t}\n\treturn false;\n}\n\nstruct cdv_intel_dp_m_n {\n\tuint32_t\ttu;\n\tuint32_t\tgmch_m;\n\tuint32_t\tgmch_n;\n\tuint32_t\tlink_m;\n\tuint32_t\tlink_n;\n};\n\nstatic void\ncdv_intel_reduce_ratio(uint32_t *num, uint32_t *den)\n{\n\t \n\tuint64_t value, m;\n\tm = *num;\n\tvalue = m * (0x800000);\n\tm = do_div(value, *den);\n\t*num = value;\n\t*den = 0x800000;\n}\n\nstatic void\ncdv_intel_dp_compute_m_n(int bpp,\n\t\t     int nlanes,\n\t\t     int pixel_clock,\n\t\t     int link_clock,\n\t\t     struct cdv_intel_dp_m_n *m_n)\n{\n\tm_n->tu = 64;\n\tm_n->gmch_m = (pixel_clock * bpp + 7) >> 3;\n\tm_n->gmch_n = link_clock * nlanes;\n\tcdv_intel_reduce_ratio(&m_n->gmch_m, &m_n->gmch_n);\n\tm_n->link_m = pixel_clock;\n\tm_n->link_n = link_clock;\n\tcdv_intel_reduce_ratio(&m_n->link_m, &m_n->link_n);\n}\n\nvoid\ncdv_intel_dp_set_m_n(struct drm_crtc *crtc, struct drm_display_mode *mode,\n\t\t struct drm_display_mode *adjusted_mode)\n{\n\tstruct drm_device *dev = crtc->dev;\n\tstruct drm_psb_private *dev_priv = to_drm_psb_private(dev);\n\tstruct drm_mode_config *mode_config = &dev->mode_config;\n\tstruct drm_encoder *encoder;\n\tstruct gma_crtc *gma_crtc = to_gma_crtc(crtc);\n\tint lane_count = 4, bpp = 24;\n\tstruct cdv_intel_dp_m_n m_n;\n\tint pipe = gma_crtc->pipe;\n\n\t \n\tlist_for_each_entry(encoder, &mode_config->encoder_list, head) {\n\t\tstruct gma_encoder *intel_encoder;\n\t\tstruct cdv_intel_dp *intel_dp;\n\n\t\tif (encoder->crtc != crtc)\n\t\t\tcontinue;\n\n\t\tintel_encoder = to_gma_encoder(encoder);\n\t\tintel_dp = intel_encoder->dev_priv;\n\t\tif (intel_encoder->type == INTEL_OUTPUT_DISPLAYPORT) {\n\t\t\tlane_count = intel_dp->lane_count;\n\t\t\tbreak;\n\t\t} else if (is_edp(intel_encoder)) {\n\t\t\tlane_count = intel_dp->lane_count;\n\t\t\tbpp = dev_priv->edp.bpp;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t \n\tcdv_intel_dp_compute_m_n(bpp, lane_count,\n\t\t\t     mode->clock, adjusted_mode->clock, &m_n);\n\n\t{\n\t\tREG_WRITE(PIPE_GMCH_DATA_M(pipe),\n\t\t\t   ((m_n.tu - 1) << PIPE_GMCH_DATA_M_TU_SIZE_SHIFT) |\n\t\t\t   m_n.gmch_m);\n\t\tREG_WRITE(PIPE_GMCH_DATA_N(pipe), m_n.gmch_n);\n\t\tREG_WRITE(PIPE_DP_LINK_M(pipe), m_n.link_m);\n\t\tREG_WRITE(PIPE_DP_LINK_N(pipe), m_n.link_n);\n\t}\n}\n\nstatic void\ncdv_intel_dp_mode_set(struct drm_encoder *encoder, struct drm_display_mode *mode,\n\t\t  struct drm_display_mode *adjusted_mode)\n{\n\tstruct gma_encoder *intel_encoder = to_gma_encoder(encoder);\n\tstruct drm_crtc *crtc = encoder->crtc;\n\tstruct gma_crtc *gma_crtc = to_gma_crtc(crtc);\n\tstruct cdv_intel_dp *intel_dp = intel_encoder->dev_priv;\n\tstruct drm_device *dev = encoder->dev;\n\n\tintel_dp->DP = DP_VOLTAGE_0_4 | DP_PRE_EMPHASIS_0;\n\tintel_dp->DP |= intel_dp->color_range;\n\n\tif (adjusted_mode->flags & DRM_MODE_FLAG_PHSYNC)\n\t\tintel_dp->DP |= DP_SYNC_HS_HIGH;\n\tif (adjusted_mode->flags & DRM_MODE_FLAG_PVSYNC)\n\t\tintel_dp->DP |= DP_SYNC_VS_HIGH;\n\n\tintel_dp->DP |= DP_LINK_TRAIN_OFF;\n\n\tswitch (intel_dp->lane_count) {\n\tcase 1:\n\t\tintel_dp->DP |= DP_PORT_WIDTH_1;\n\t\tbreak;\n\tcase 2:\n\t\tintel_dp->DP |= DP_PORT_WIDTH_2;\n\t\tbreak;\n\tcase 4:\n\t\tintel_dp->DP |= DP_PORT_WIDTH_4;\n\t\tbreak;\n\t}\n\tif (intel_dp->has_audio)\n\t\tintel_dp->DP |= DP_AUDIO_OUTPUT_ENABLE;\n\n\tmemset(intel_dp->link_configuration, 0, DP_LINK_CONFIGURATION_SIZE);\n\tintel_dp->link_configuration[0] = intel_dp->link_bw;\n\tintel_dp->link_configuration[1] = intel_dp->lane_count;\n\n\t \n\tif (intel_dp->dpcd[DP_DPCD_REV] >= 0x11 &&\n\t    (intel_dp->dpcd[DP_MAX_LANE_COUNT] & DP_ENHANCED_FRAME_CAP)) {\n\t\tintel_dp->link_configuration[1] |= DP_LANE_COUNT_ENHANCED_FRAME_EN;\n\t\tintel_dp->DP |= DP_ENHANCED_FRAMING;\n\t}\n\n\t \n\tif (gma_crtc->pipe == 1)\n\t\tintel_dp->DP |= DP_PIPEB_SELECT;\n\n\tREG_WRITE(intel_dp->output_reg, (intel_dp->DP | DP_PORT_EN));\n\tDRM_DEBUG_KMS(\"DP expected reg is %x\\n\", intel_dp->DP);\n\tif (is_edp(intel_encoder)) {\n\t\tuint32_t pfit_control;\n\t\tcdv_intel_edp_panel_on(intel_encoder);\n\n\t\tif (mode->hdisplay != adjusted_mode->hdisplay ||\n\t\t\t    mode->vdisplay != adjusted_mode->vdisplay)\n\t\t\tpfit_control = PFIT_ENABLE;\n\t\telse\n\t\t\tpfit_control = 0;\n\n\t\tpfit_control |= gma_crtc->pipe << PFIT_PIPE_SHIFT;\n\n\t\tREG_WRITE(PFIT_CONTROL, pfit_control);\n\t}\n}\n\n\n \nstatic void cdv_intel_dp_sink_dpms(struct gma_encoder *encoder, int mode)\n{\n\tstruct cdv_intel_dp *intel_dp = encoder->dev_priv;\n\tint ret, i;\n\n\t \n\tif (intel_dp->dpcd[DP_DPCD_REV] < 0x11)\n\t\treturn;\n\n\tif (mode != DRM_MODE_DPMS_ON) {\n\t\tret = cdv_intel_dp_aux_native_write_1(encoder, DP_SET_POWER,\n\t\t\t\t\t\t  DP_SET_POWER_D3);\n\t\tif (ret != 1)\n\t\t\tDRM_DEBUG_DRIVER(\"failed to write sink power state\\n\");\n\t} else {\n\t\t \n\t\tfor (i = 0; i < 3; i++) {\n\t\t\tret = cdv_intel_dp_aux_native_write_1(encoder,\n\t\t\t\t\t\t\t  DP_SET_POWER,\n\t\t\t\t\t\t\t  DP_SET_POWER_D0);\n\t\t\tif (ret == 1)\n\t\t\t\tbreak;\n\t\t\tudelay(1000);\n\t\t}\n\t}\n}\n\nstatic void cdv_intel_dp_prepare(struct drm_encoder *encoder)\n{\n\tstruct gma_encoder *intel_encoder = to_gma_encoder(encoder);\n\tint edp = is_edp(intel_encoder);\n\n\tif (edp) {\n\t\tcdv_intel_edp_backlight_off(intel_encoder);\n\t\tcdv_intel_edp_panel_off(intel_encoder);\n\t\tcdv_intel_edp_panel_vdd_on(intel_encoder);\n        }\n\t \n\tcdv_intel_dp_sink_dpms(intel_encoder, DRM_MODE_DPMS_ON);\n\tcdv_intel_dp_link_down(intel_encoder);\n\tif (edp)\n\t\tcdv_intel_edp_panel_vdd_off(intel_encoder);\n}\n\nstatic void cdv_intel_dp_commit(struct drm_encoder *encoder)\n{\n\tstruct gma_encoder *intel_encoder = to_gma_encoder(encoder);\n\tint edp = is_edp(intel_encoder);\n\n\tif (edp)\n\t\tcdv_intel_edp_panel_on(intel_encoder);\n\tcdv_intel_dp_start_link_train(intel_encoder);\n\tcdv_intel_dp_complete_link_train(intel_encoder);\n\tif (edp)\n\t\tcdv_intel_edp_backlight_on(intel_encoder);\n}\n\nstatic void\ncdv_intel_dp_dpms(struct drm_encoder *encoder, int mode)\n{\n\tstruct gma_encoder *intel_encoder = to_gma_encoder(encoder);\n\tstruct cdv_intel_dp *intel_dp = intel_encoder->dev_priv;\n\tstruct drm_device *dev = encoder->dev;\n\tuint32_t dp_reg = REG_READ(intel_dp->output_reg);\n\tint edp = is_edp(intel_encoder);\n\n\tif (mode != DRM_MODE_DPMS_ON) {\n\t\tif (edp) {\n\t\t\tcdv_intel_edp_backlight_off(intel_encoder);\n\t\t\tcdv_intel_edp_panel_vdd_on(intel_encoder);\n\t\t}\n\t\tcdv_intel_dp_sink_dpms(intel_encoder, mode);\n\t\tcdv_intel_dp_link_down(intel_encoder);\n\t\tif (edp) {\n\t\t\tcdv_intel_edp_panel_vdd_off(intel_encoder);\n\t\t\tcdv_intel_edp_panel_off(intel_encoder);\n\t\t}\n\t} else {\n        \tif (edp)\n\t\t\tcdv_intel_edp_panel_on(intel_encoder);\n\t\tcdv_intel_dp_sink_dpms(intel_encoder, mode);\n\t\tif (!(dp_reg & DP_PORT_EN)) {\n\t\t\tcdv_intel_dp_start_link_train(intel_encoder);\n\t\t\tcdv_intel_dp_complete_link_train(intel_encoder);\n\t\t}\n\t\tif (edp)\n        \t\tcdv_intel_edp_backlight_on(intel_encoder);\n\t}\n}\n\n \nstatic bool\ncdv_intel_dp_aux_native_read_retry(struct gma_encoder *encoder, uint16_t address,\n\t\t\t       uint8_t *recv, int recv_bytes)\n{\n\tint ret, i;\n\n\t \n\tfor (i = 0; i < 3; i++) {\n\t\tret = cdv_intel_dp_aux_native_read(encoder, address, recv,\n\t\t\t\t\t       recv_bytes);\n\t\tif (ret == recv_bytes)\n\t\t\treturn true;\n\t\tudelay(1000);\n\t}\n\n\treturn false;\n}\n\n \nstatic bool\ncdv_intel_dp_get_link_status(struct gma_encoder *encoder)\n{\n\tstruct cdv_intel_dp *intel_dp = encoder->dev_priv;\n\treturn cdv_intel_dp_aux_native_read_retry(encoder,\n\t\t\t\t\t      DP_LANE0_1_STATUS,\n\t\t\t\t\t      intel_dp->link_status,\n\t\t\t\t\t      DP_LINK_STATUS_SIZE);\n}\n\nstatic uint8_t\ncdv_intel_dp_link_status(uint8_t link_status[DP_LINK_STATUS_SIZE],\n\t\t     int r)\n{\n\treturn link_status[r - DP_LANE0_1_STATUS];\n}\n\nstatic uint8_t\ncdv_intel_get_adjust_request_voltage(uint8_t link_status[DP_LINK_STATUS_SIZE],\n\t\t\t\t int lane)\n{\n\tint\t    i = DP_ADJUST_REQUEST_LANE0_1 + (lane >> 1);\n\tint\t    s = ((lane & 1) ?\n\t\t\t DP_ADJUST_VOLTAGE_SWING_LANE1_SHIFT :\n\t\t\t DP_ADJUST_VOLTAGE_SWING_LANE0_SHIFT);\n\tuint8_t l = cdv_intel_dp_link_status(link_status, i);\n\n\treturn ((l >> s) & 3) << DP_TRAIN_VOLTAGE_SWING_SHIFT;\n}\n\nstatic uint8_t\ncdv_intel_get_adjust_request_pre_emphasis(uint8_t link_status[DP_LINK_STATUS_SIZE],\n\t\t\t\t      int lane)\n{\n\tint\t    i = DP_ADJUST_REQUEST_LANE0_1 + (lane >> 1);\n\tint\t    s = ((lane & 1) ?\n\t\t\t DP_ADJUST_PRE_EMPHASIS_LANE1_SHIFT :\n\t\t\t DP_ADJUST_PRE_EMPHASIS_LANE0_SHIFT);\n\tuint8_t l = cdv_intel_dp_link_status(link_status, i);\n\n\treturn ((l >> s) & 3) << DP_TRAIN_PRE_EMPHASIS_SHIFT;\n}\n\n#define CDV_DP_VOLTAGE_MAX\t    DP_TRAIN_VOLTAGE_SWING_LEVEL_3\n\nstatic void\ncdv_intel_get_adjust_train(struct gma_encoder *encoder)\n{\n\tstruct cdv_intel_dp *intel_dp = encoder->dev_priv;\n\tuint8_t v = 0;\n\tuint8_t p = 0;\n\tint lane;\n\n\tfor (lane = 0; lane < intel_dp->lane_count; lane++) {\n\t\tuint8_t this_v = cdv_intel_get_adjust_request_voltage(intel_dp->link_status, lane);\n\t\tuint8_t this_p = cdv_intel_get_adjust_request_pre_emphasis(intel_dp->link_status, lane);\n\n\t\tif (this_v > v)\n\t\t\tv = this_v;\n\t\tif (this_p > p)\n\t\t\tp = this_p;\n\t}\n\n\tif (v >= CDV_DP_VOLTAGE_MAX)\n\t\tv = CDV_DP_VOLTAGE_MAX | DP_TRAIN_MAX_SWING_REACHED;\n\n\tif (p == DP_TRAIN_PRE_EMPHASIS_MASK)\n\t\tp |= DP_TRAIN_MAX_PRE_EMPHASIS_REACHED;\n\n\tfor (lane = 0; lane < 4; lane++)\n\t\tintel_dp->train_set[lane] = v | p;\n}\n\n\nstatic uint8_t\ncdv_intel_get_lane_status(uint8_t link_status[DP_LINK_STATUS_SIZE],\n\t\t      int lane)\n{\n\tint i = DP_LANE0_1_STATUS + (lane >> 1);\n\tint s = (lane & 1) * 4;\n\tuint8_t l = cdv_intel_dp_link_status(link_status, i);\n\n\treturn (l >> s) & 0xf;\n}\n\n \nstatic bool\ncdv_intel_clock_recovery_ok(uint8_t link_status[DP_LINK_STATUS_SIZE], int lane_count)\n{\n\tint lane;\n\tuint8_t lane_status;\n\n\tfor (lane = 0; lane < lane_count; lane++) {\n\t\tlane_status = cdv_intel_get_lane_status(link_status, lane);\n\t\tif ((lane_status & DP_LANE_CR_DONE) == 0)\n\t\t\treturn false;\n\t}\n\treturn true;\n}\n\n \n#define CHANNEL_EQ_BITS (DP_LANE_CR_DONE|\\\n\t\t\t DP_LANE_CHANNEL_EQ_DONE|\\\n\t\t\t DP_LANE_SYMBOL_LOCKED)\nstatic bool\ncdv_intel_channel_eq_ok(struct gma_encoder *encoder)\n{\n\tstruct cdv_intel_dp *intel_dp = encoder->dev_priv;\n\tuint8_t lane_align;\n\tuint8_t lane_status;\n\tint lane;\n\n\tlane_align = cdv_intel_dp_link_status(intel_dp->link_status,\n\t\t\t\t\t  DP_LANE_ALIGN_STATUS_UPDATED);\n\tif ((lane_align & DP_INTERLANE_ALIGN_DONE) == 0)\n\t\treturn false;\n\tfor (lane = 0; lane < intel_dp->lane_count; lane++) {\n\t\tlane_status = cdv_intel_get_lane_status(intel_dp->link_status, lane);\n\t\tif ((lane_status & CHANNEL_EQ_BITS) != CHANNEL_EQ_BITS)\n\t\t\treturn false;\n\t}\n\treturn true;\n}\n\nstatic bool\ncdv_intel_dp_set_link_train(struct gma_encoder *encoder,\n\t\t\tuint32_t dp_reg_value,\n\t\t\tuint8_t dp_train_pat)\n{\n\tstruct drm_device *dev = encoder->base.dev;\n\tint ret;\n\tstruct cdv_intel_dp *intel_dp = encoder->dev_priv;\n\n\tREG_WRITE(intel_dp->output_reg, dp_reg_value);\n\tREG_READ(intel_dp->output_reg);\n\n\tret = cdv_intel_dp_aux_native_write_1(encoder,\n\t\t\t\t    DP_TRAINING_PATTERN_SET,\n\t\t\t\t    dp_train_pat);\n\n\tif (ret != 1) {\n\t\tDRM_DEBUG_KMS(\"Failure in setting link pattern %x\\n\",\n\t\t\t\tdp_train_pat);\n\t\treturn false;\n\t}\n\n\treturn true;\n}\n\n\nstatic bool\ncdv_intel_dplink_set_level(struct gma_encoder *encoder,\n\t\t\tuint8_t dp_train_pat)\n{\n\tint ret;\n\tstruct cdv_intel_dp *intel_dp = encoder->dev_priv;\n\n\tret = cdv_intel_dp_aux_native_write(encoder,\n\t\t\t\t\tDP_TRAINING_LANE0_SET,\n\t\t\t\t\tintel_dp->train_set,\n\t\t\t\t\tintel_dp->lane_count);\n\n\tif (ret != intel_dp->lane_count) {\n\t\tDRM_DEBUG_KMS(\"Failure in setting level %d, lane_cnt= %d\\n\",\n\t\t\t\tintel_dp->train_set[0], intel_dp->lane_count);\n\t\treturn false;\n\t}\n\treturn true;\n}\n\nstatic void\ncdv_intel_dp_set_vswing_premph(struct gma_encoder *encoder, uint8_t signal_level)\n{\n\tstruct drm_device *dev = encoder->base.dev;\n\tstruct cdv_intel_dp *intel_dp = encoder->dev_priv;\n\tstruct ddi_regoff *ddi_reg;\n\tint vswing, premph, index;\n\n\tif (intel_dp->output_reg == DP_B)\n\t\tddi_reg = &ddi_DP_train_table[0];\n\telse\n\t\tddi_reg = &ddi_DP_train_table[1];\n\n\tvswing = (signal_level & DP_TRAIN_VOLTAGE_SWING_MASK);\n\tpremph = ((signal_level & DP_TRAIN_PRE_EMPHASIS_MASK)) >>\n\t\t\t\tDP_TRAIN_PRE_EMPHASIS_SHIFT;\n\n\tif (vswing + premph > 3)\n\t\treturn;\n#ifdef CDV_FAST_LINK_TRAIN\n\treturn;\n#endif\n\tDRM_DEBUG_KMS(\"Test2\\n\");\n\t\n\tcdv_sb_reset(dev);\n\t \n\tcdv_sb_write(dev, ddi_reg->VSwing5, 0x0505313A);\n\n\t \n\tcdv_sb_write(dev, ddi_reg->VSwing1, 0x43406055);\n\n\t \n\tindex = (vswing + premph) * 2;\n\tif (premph == 1 && vswing == 1) {\n\t\tcdv_sb_write(dev, ddi_reg->VSwing2, 0x055738954);\n\t} else\n\t\tcdv_sb_write(dev, ddi_reg->VSwing2, dp_vswing_premph_table[index]);\n\n\t \n\tif ((vswing + premph) == DP_TRAIN_VOLTAGE_SWING_LEVEL_3)\n\t\tcdv_sb_write(dev, ddi_reg->VSwing3, 0x70802040);\n\telse\n\t\tcdv_sb_write(dev, ddi_reg->VSwing3, 0x40802040);\n\n\t \n\t \n\n\t \n\tcdv_sb_write(dev, ddi_reg->VSwing1, 0xc3406055);\n\n\t \n\tcdv_sb_write(dev, ddi_reg->PreEmph1, 0x1f030040);\n\n\t \n\tindex = 2 * premph + 1;\n\tcdv_sb_write(dev, ddi_reg->PreEmph2, dp_vswing_premph_table[index]);\n\treturn;\n}\n\n\n \nstatic void\ncdv_intel_dp_start_link_train(struct gma_encoder *encoder)\n{\n\tstruct drm_device *dev = encoder->base.dev;\n\tstruct cdv_intel_dp *intel_dp = encoder->dev_priv;\n\tint i;\n\tuint8_t voltage;\n\tbool clock_recovery = false;\n\tint tries;\n\tu32 reg;\n\tuint32_t DP = intel_dp->DP;\n\n\tDP |= DP_PORT_EN;\n\tDP &= ~DP_LINK_TRAIN_MASK;\n\n\treg = DP;\n\treg |= DP_LINK_TRAIN_PAT_1;\n\t \n\tREG_WRITE(intel_dp->output_reg, reg);\n\tREG_READ(intel_dp->output_reg);\n\tgma_wait_for_vblank(dev);\n\n\tDRM_DEBUG_KMS(\"Link config\\n\");\n\t \n\tcdv_intel_dp_aux_native_write(encoder, DP_LINK_BW_SET,\n\t\t\t\t  intel_dp->link_configuration,\n\t\t\t\t  2);\n\n\tmemset(intel_dp->train_set, 0, 4);\n\tvoltage = 0;\n\ttries = 0;\n\tclock_recovery = false;\n\n\tDRM_DEBUG_KMS(\"Start train\\n\");\n\treg = DP | DP_LINK_TRAIN_PAT_1;\n\n\tfor (;;) {\n\t\t \n\t\tDRM_DEBUG_KMS(\"DP Link Train Set %x, Link_config %x, %x\\n\",\n\t\t\t\tintel_dp->train_set[0],\n\t\t\t\tintel_dp->link_configuration[0],\n\t\t\t\tintel_dp->link_configuration[1]);\n\n\t\tif (!cdv_intel_dp_set_link_train(encoder, reg, DP_TRAINING_PATTERN_1)) {\n\t\t\tDRM_DEBUG_KMS(\"Failure in aux-transfer setting pattern 1\\n\");\n\t\t}\n\t\tcdv_intel_dp_set_vswing_premph(encoder, intel_dp->train_set[0]);\n\t\t \n\n\t\tcdv_intel_dplink_set_level(encoder, DP_TRAINING_PATTERN_1);\n\n\t\tudelay(200);\n\t\tif (!cdv_intel_dp_get_link_status(encoder))\n\t\t\tbreak;\n\n\t\tDRM_DEBUG_KMS(\"DP Link status %x, %x, %x, %x, %x, %x\\n\",\n\t\t\t\tintel_dp->link_status[0], intel_dp->link_status[1], intel_dp->link_status[2],\n\t\t\t\tintel_dp->link_status[3], intel_dp->link_status[4], intel_dp->link_status[5]);\n\n\t\tif (cdv_intel_clock_recovery_ok(intel_dp->link_status, intel_dp->lane_count)) {\n\t\t\tDRM_DEBUG_KMS(\"PT1 train is done\\n\");\n\t\t\tclock_recovery = true;\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\tfor (i = 0; i < intel_dp->lane_count; i++)\n\t\t\tif ((intel_dp->train_set[i] & DP_TRAIN_MAX_SWING_REACHED) == 0)\n\t\t\t\tbreak;\n\t\tif (i == intel_dp->lane_count)\n\t\t\tbreak;\n\n\t\t \n\t\tif ((intel_dp->train_set[0] & DP_TRAIN_VOLTAGE_SWING_MASK) == voltage) {\n\t\t\t++tries;\n\t\t\tif (tries == 5)\n\t\t\t\tbreak;\n\t\t} else\n\t\t\ttries = 0;\n\t\tvoltage = intel_dp->train_set[0] & DP_TRAIN_VOLTAGE_SWING_MASK;\n\n\t\t \n\t\tcdv_intel_get_adjust_train(encoder);\n\n\t}\n\n\tif (!clock_recovery) {\n\t\tDRM_DEBUG_KMS(\"failure in DP patter 1 training, train set %x\\n\", intel_dp->train_set[0]);\n\t}\n\n\tintel_dp->DP = DP;\n}\n\nstatic void\ncdv_intel_dp_complete_link_train(struct gma_encoder *encoder)\n{\n\tstruct drm_device *dev = encoder->base.dev;\n\tstruct cdv_intel_dp *intel_dp = encoder->dev_priv;\n\tint tries, cr_tries;\n\tu32 reg;\n\tuint32_t DP = intel_dp->DP;\n\n\t \n\ttries = 0;\n\tcr_tries = 0;\n\n\tDRM_DEBUG_KMS(\"\\n\");\n\treg = DP | DP_LINK_TRAIN_PAT_2;\n\n\tfor (;;) {\n\n\t\tDRM_DEBUG_KMS(\"DP Link Train Set %x, Link_config %x, %x\\n\",\n\t\t\t\tintel_dp->train_set[0],\n\t\t\t\tintel_dp->link_configuration[0],\n\t\t\t\tintel_dp->link_configuration[1]);\n        \t \n\n\t\tif (!cdv_intel_dp_set_link_train(encoder, reg,\n\t\t\t\t\t     DP_TRAINING_PATTERN_2)) {\n\t\t\tDRM_DEBUG_KMS(\"Failure in aux-transfer setting pattern 2\\n\");\n\t\t}\n\t\t \n\n\t\tif (cr_tries > 5) {\n\t\t\tDRM_ERROR(\"failed to train DP, aborting\\n\");\n\t\t\tcdv_intel_dp_link_down(encoder);\n\t\t\tbreak;\n\t\t}\n\n\t\tcdv_intel_dp_set_vswing_premph(encoder, intel_dp->train_set[0]);\n\n\t\tcdv_intel_dplink_set_level(encoder, DP_TRAINING_PATTERN_2);\n\n\t\tudelay(1000);\n\t\tif (!cdv_intel_dp_get_link_status(encoder))\n\t\t\tbreak;\n\n\t\tDRM_DEBUG_KMS(\"DP Link status %x, %x, %x, %x, %x, %x\\n\",\n\t\t\t\tintel_dp->link_status[0], intel_dp->link_status[1], intel_dp->link_status[2],\n\t\t\t\tintel_dp->link_status[3], intel_dp->link_status[4], intel_dp->link_status[5]);\n\n\t\t \n\t\tif (!cdv_intel_clock_recovery_ok(intel_dp->link_status, intel_dp->lane_count)) {\n\t\t\tcdv_intel_dp_start_link_train(encoder);\n\t\t\tcr_tries++;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (cdv_intel_channel_eq_ok(encoder)) {\n\t\t\tDRM_DEBUG_KMS(\"PT2 train is done\\n\");\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\tif (tries > 5) {\n\t\t\tcdv_intel_dp_link_down(encoder);\n\t\t\tcdv_intel_dp_start_link_train(encoder);\n\t\t\ttries = 0;\n\t\t\tcr_tries++;\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\tcdv_intel_get_adjust_train(encoder);\n\t\t++tries;\n\n\t}\n\n\treg = DP | DP_LINK_TRAIN_OFF;\n\n\tREG_WRITE(intel_dp->output_reg, reg);\n\tREG_READ(intel_dp->output_reg);\n\tcdv_intel_dp_aux_native_write_1(encoder,\n\t\t\t\t    DP_TRAINING_PATTERN_SET, DP_TRAINING_PATTERN_DISABLE);\n}\n\nstatic void\ncdv_intel_dp_link_down(struct gma_encoder *encoder)\n{\n\tstruct drm_device *dev = encoder->base.dev;\n\tstruct cdv_intel_dp *intel_dp = encoder->dev_priv;\n\tuint32_t DP = intel_dp->DP;\n\n\tif ((REG_READ(intel_dp->output_reg) & DP_PORT_EN) == 0)\n\t\treturn;\n\n\tDRM_DEBUG_KMS(\"\\n\");\n\n\n\t{\n\t\tDP &= ~DP_LINK_TRAIN_MASK;\n\t\tREG_WRITE(intel_dp->output_reg, DP | DP_LINK_TRAIN_PAT_IDLE);\n\t}\n\tREG_READ(intel_dp->output_reg);\n\n\tmsleep(17);\n\n\tREG_WRITE(intel_dp->output_reg, DP & ~DP_PORT_EN);\n\tREG_READ(intel_dp->output_reg);\n}\n\nstatic enum drm_connector_status cdv_dp_detect(struct gma_encoder *encoder)\n{\n\tstruct cdv_intel_dp *intel_dp = encoder->dev_priv;\n\tenum drm_connector_status status;\n\n\tstatus = connector_status_disconnected;\n\tif (cdv_intel_dp_aux_native_read(encoder, 0x000, intel_dp->dpcd,\n\t\t\t\t     sizeof (intel_dp->dpcd)) == sizeof (intel_dp->dpcd))\n\t{\n\t\tif (intel_dp->dpcd[DP_DPCD_REV] != 0)\n\t\t\tstatus = connector_status_connected;\n\t}\n\tif (status == connector_status_connected)\n\t\tDRM_DEBUG_KMS(\"DPCD: Rev=%x LN_Rate=%x LN_CNT=%x LN_DOWNSP=%x\\n\",\n\t\t\tintel_dp->dpcd[0], intel_dp->dpcd[1],\n\t\t\tintel_dp->dpcd[2], intel_dp->dpcd[3]);\n\treturn status;\n}\n\n \nstatic enum drm_connector_status\ncdv_intel_dp_detect(struct drm_connector *connector, bool force)\n{\n\tstruct gma_encoder *encoder = gma_attached_encoder(connector);\n\tstruct cdv_intel_dp *intel_dp = encoder->dev_priv;\n\tenum drm_connector_status status;\n\tstruct edid *edid = NULL;\n\tint edp = is_edp(encoder);\n\n\tintel_dp->has_audio = false;\n\n\tif (edp)\n\t\tcdv_intel_edp_panel_vdd_on(encoder);\n\tstatus = cdv_dp_detect(encoder);\n\tif (status != connector_status_connected) {\n\t\tif (edp)\n\t\t\tcdv_intel_edp_panel_vdd_off(encoder);\n\t\treturn status;\n        }\n\n\tif (intel_dp->force_audio) {\n\t\tintel_dp->has_audio = intel_dp->force_audio > 0;\n\t} else {\n\t\tedid = drm_get_edid(connector, &intel_dp->adapter);\n\t\tif (edid) {\n\t\t\tintel_dp->has_audio = drm_detect_monitor_audio(edid);\n\t\t\tkfree(edid);\n\t\t}\n\t}\n\tif (edp)\n\t\tcdv_intel_edp_panel_vdd_off(encoder);\n\n\treturn connector_status_connected;\n}\n\nstatic int cdv_intel_dp_get_modes(struct drm_connector *connector)\n{\n\tstruct gma_encoder *intel_encoder = gma_attached_encoder(connector);\n\tstruct cdv_intel_dp *intel_dp = intel_encoder->dev_priv;\n\tstruct edid *edid = NULL;\n\tint ret = 0;\n\tint edp = is_edp(intel_encoder);\n\n\n\tedid = drm_get_edid(connector, &intel_dp->adapter);\n\tif (edid) {\n\t\tdrm_connector_update_edid_property(connector, edid);\n\t\tret = drm_add_edid_modes(connector, edid);\n\t\tkfree(edid);\n\t}\n\n\tif (is_edp(intel_encoder)) {\n\t\tstruct drm_device *dev = connector->dev;\n\t\tstruct drm_psb_private *dev_priv = to_drm_psb_private(dev);\n\n\t\tcdv_intel_edp_panel_vdd_off(intel_encoder);\n\t\tif (ret) {\n\t\t\tif (edp && !intel_dp->panel_fixed_mode) {\n\t\t\t\tstruct drm_display_mode *newmode;\n\t\t\t\tlist_for_each_entry(newmode, &connector->probed_modes,\n\t\t\t\t\t    head) {\n\t\t\t\t\tif (newmode->type & DRM_MODE_TYPE_PREFERRED) {\n\t\t\t\t\t\tintel_dp->panel_fixed_mode =\n\t\t\t\t\t\t\tdrm_mode_duplicate(dev, newmode);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn ret;\n\t\t}\n\t\tif (!intel_dp->panel_fixed_mode && dev_priv->lfp_lvds_vbt_mode) {\n\t\t\tintel_dp->panel_fixed_mode =\n\t\t\t\tdrm_mode_duplicate(dev, dev_priv->lfp_lvds_vbt_mode);\n\t\t\tif (intel_dp->panel_fixed_mode) {\n\t\t\t\tintel_dp->panel_fixed_mode->type |=\n\t\t\t\t\tDRM_MODE_TYPE_PREFERRED;\n\t\t\t}\n\t\t}\n\t\tif (intel_dp->panel_fixed_mode != NULL) {\n\t\t\tstruct drm_display_mode *mode;\n\t\t\tmode = drm_mode_duplicate(dev, intel_dp->panel_fixed_mode);\n\t\t\tdrm_mode_probed_add(connector, mode);\n\t\t\treturn 1;\n\t\t}\n\t}\n\n\treturn ret;\n}\n\nstatic bool\ncdv_intel_dp_detect_audio(struct drm_connector *connector)\n{\n\tstruct gma_encoder *encoder = gma_attached_encoder(connector);\n\tstruct cdv_intel_dp *intel_dp = encoder->dev_priv;\n\tstruct edid *edid;\n\tbool has_audio = false;\n\tint edp = is_edp(encoder);\n\n\tif (edp)\n\t\tcdv_intel_edp_panel_vdd_on(encoder);\n\n\tedid = drm_get_edid(connector, &intel_dp->adapter);\n\tif (edid) {\n\t\thas_audio = drm_detect_monitor_audio(edid);\n\t\tkfree(edid);\n\t}\n\tif (edp)\n\t\tcdv_intel_edp_panel_vdd_off(encoder);\n\n\treturn has_audio;\n}\n\nstatic int\ncdv_intel_dp_set_property(struct drm_connector *connector,\n\t\t      struct drm_property *property,\n\t\t      uint64_t val)\n{\n\tstruct drm_psb_private *dev_priv = to_drm_psb_private(connector->dev);\n\tstruct gma_encoder *encoder = gma_attached_encoder(connector);\n\tstruct cdv_intel_dp *intel_dp = encoder->dev_priv;\n\tint ret;\n\n\tret = drm_object_property_set_value(&connector->base, property, val);\n\tif (ret)\n\t\treturn ret;\n\n\tif (property == dev_priv->force_audio_property) {\n\t\tint i = val;\n\t\tbool has_audio;\n\n\t\tif (i == intel_dp->force_audio)\n\t\t\treturn 0;\n\n\t\tintel_dp->force_audio = i;\n\n\t\tif (i == 0)\n\t\t\thas_audio = cdv_intel_dp_detect_audio(connector);\n\t\telse\n\t\t\thas_audio = i > 0;\n\n\t\tif (has_audio == intel_dp->has_audio)\n\t\t\treturn 0;\n\n\t\tintel_dp->has_audio = has_audio;\n\t\tgoto done;\n\t}\n\n\tif (property == dev_priv->broadcast_rgb_property) {\n\t\tif (val == !!intel_dp->color_range)\n\t\t\treturn 0;\n\n\t\tintel_dp->color_range = val ? DP_COLOR_RANGE_16_235 : 0;\n\t\tgoto done;\n\t}\n\n\treturn -EINVAL;\n\ndone:\n\tif (encoder->base.crtc) {\n\t\tstruct drm_crtc *crtc = encoder->base.crtc;\n\t\tdrm_crtc_helper_set_mode(crtc, &crtc->mode,\n\t\t\t\t\t crtc->x, crtc->y,\n\t\t\t\t\t crtc->primary->fb);\n\t}\n\n\treturn 0;\n}\n\nstatic void\ncdv_intel_dp_destroy(struct drm_connector *connector)\n{\n\tstruct gma_connector *gma_connector = to_gma_connector(connector);\n\tstruct gma_encoder *gma_encoder = gma_attached_encoder(connector);\n\tstruct cdv_intel_dp *intel_dp = gma_encoder->dev_priv;\n\n\tif (is_edp(gma_encoder)) {\n\t \n\t\tkfree(intel_dp->panel_fixed_mode);\n\t\tintel_dp->panel_fixed_mode = NULL;\n\t}\n\ti2c_del_adapter(&intel_dp->adapter);\n\tdrm_connector_cleanup(connector);\n\tkfree(gma_connector);\n}\n\nstatic const struct drm_encoder_helper_funcs cdv_intel_dp_helper_funcs = {\n\t.dpms = cdv_intel_dp_dpms,\n\t.mode_fixup = cdv_intel_dp_mode_fixup,\n\t.prepare = cdv_intel_dp_prepare,\n\t.mode_set = cdv_intel_dp_mode_set,\n\t.commit = cdv_intel_dp_commit,\n};\n\nstatic const struct drm_connector_funcs cdv_intel_dp_connector_funcs = {\n\t.dpms = drm_helper_connector_dpms,\n\t.detect = cdv_intel_dp_detect,\n\t.fill_modes = drm_helper_probe_single_connector_modes,\n\t.set_property = cdv_intel_dp_set_property,\n\t.destroy = cdv_intel_dp_destroy,\n};\n\nstatic const struct drm_connector_helper_funcs cdv_intel_dp_connector_helper_funcs = {\n\t.get_modes = cdv_intel_dp_get_modes,\n\t.mode_valid = cdv_intel_dp_mode_valid,\n\t.best_encoder = gma_best_encoder,\n};\n\nstatic void cdv_intel_dp_add_properties(struct drm_connector *connector)\n{\n\tcdv_intel_attach_force_audio_property(connector);\n\tcdv_intel_attach_broadcast_rgb_property(connector);\n}\n\n \nstatic bool cdv_intel_dpc_is_edp(struct drm_device *dev)\n{\n\tstruct drm_psb_private *dev_priv = to_drm_psb_private(dev);\n\tstruct child_device_config *p_child;\n\tint i;\n\n\tif (!dev_priv->child_dev_num)\n\t\treturn false;\n\n\tfor (i = 0; i < dev_priv->child_dev_num; i++) {\n\t\tp_child = dev_priv->child_dev + i;\n\n\t\tif (p_child->dvo_port == PORT_IDPC &&\n\t\t    p_child->device_type == DEVICE_TYPE_eDP)\n\t\t\treturn true;\n\t}\n\treturn false;\n}\n\n \nstatic void cdv_disable_intel_clock_gating(struct drm_device *dev)\n{\n\tu32 reg_value;\n\treg_value = REG_READ(DSPCLK_GATE_D);\n\n\treg_value |= (DPUNIT_PIPEB_GATE_DISABLE |\n\t\t\tDPUNIT_PIPEA_GATE_DISABLE |\n\t\t\tDPCUNIT_CLOCK_GATE_DISABLE |\n\t\t\tDPLSUNIT_CLOCK_GATE_DISABLE |\n\t\t\tDPOUNIT_CLOCK_GATE_DISABLE |\n\t\t\tDPIOUNIT_CLOCK_GATE_DISABLE);\n\n\tREG_WRITE(DSPCLK_GATE_D, reg_value);\n\n\tudelay(500);\n}\n\nvoid\ncdv_intel_dp_init(struct drm_device *dev, struct psb_intel_mode_device *mode_dev, int output_reg)\n{\n\tstruct gma_encoder *gma_encoder;\n\tstruct gma_connector *gma_connector;\n\tstruct drm_connector *connector;\n\tstruct drm_encoder *encoder;\n\tstruct cdv_intel_dp *intel_dp;\n\tconst char *name = NULL;\n\tint type = DRM_MODE_CONNECTOR_DisplayPort;\n\n\tgma_encoder = kzalloc(sizeof(struct gma_encoder), GFP_KERNEL);\n\tif (!gma_encoder)\n\t\treturn;\n        gma_connector = kzalloc(sizeof(struct gma_connector), GFP_KERNEL);\n        if (!gma_connector)\n                goto err_connector;\n\tintel_dp = kzalloc(sizeof(struct cdv_intel_dp), GFP_KERNEL);\n\tif (!intel_dp)\n\t        goto err_priv;\n\n\tif ((output_reg == DP_C) && cdv_intel_dpc_is_edp(dev))\n\t\ttype = DRM_MODE_CONNECTOR_eDP;\n\n\tconnector = &gma_connector->base;\n\tencoder = &gma_encoder->base;\n\n\tdrm_connector_init(dev, connector, &cdv_intel_dp_connector_funcs, type);\n\tdrm_simple_encoder_init(dev, encoder, DRM_MODE_ENCODER_TMDS);\n\n\tgma_connector_attach_encoder(gma_connector, gma_encoder);\n\n\tif (type == DRM_MODE_CONNECTOR_DisplayPort)\n\t\tgma_encoder->type = INTEL_OUTPUT_DISPLAYPORT;\n        else\n\t\tgma_encoder->type = INTEL_OUTPUT_EDP;\n\n\n\tgma_encoder->dev_priv=intel_dp;\n\tintel_dp->encoder = gma_encoder;\n\tintel_dp->output_reg = output_reg;\n\n\tdrm_encoder_helper_add(encoder, &cdv_intel_dp_helper_funcs);\n\tdrm_connector_helper_add(connector, &cdv_intel_dp_connector_helper_funcs);\n\n\tconnector->polled = DRM_CONNECTOR_POLL_HPD;\n\tconnector->interlace_allowed = false;\n\tconnector->doublescan_allowed = false;\n\n\t \n\tswitch (output_reg) {\n\t\tcase DP_B:\n\t\t\tname = \"DPDDC-B\";\n\t\t\tgma_encoder->ddi_select = (DP_MASK | DDI0_SELECT);\n\t\t\tbreak;\n\t\tcase DP_C:\n\t\t\tname = \"DPDDC-C\";\n\t\t\tgma_encoder->ddi_select = (DP_MASK | DDI1_SELECT);\n\t\t\tbreak;\n\t}\n\n\tcdv_disable_intel_clock_gating(dev);\n\n\tcdv_intel_dp_i2c_init(gma_connector, gma_encoder, name);\n         \n\tcdv_intel_dp_add_properties(connector);\n\n\tif (is_edp(gma_encoder)) {\n\t\tint ret;\n\t\tstruct edp_power_seq cur;\n                u32 pp_on, pp_off, pp_div;\n\t\tu32 pwm_ctrl;\n\n\t\tpp_on = REG_READ(PP_CONTROL);\n\t\tpp_on &= ~PANEL_UNLOCK_MASK;\n\t        pp_on |= PANEL_UNLOCK_REGS;\n\n\t\tREG_WRITE(PP_CONTROL, pp_on);\n\n\t\tpwm_ctrl = REG_READ(BLC_PWM_CTL2);\n\t\tpwm_ctrl |= PWM_PIPE_B;\n\t\tREG_WRITE(BLC_PWM_CTL2, pwm_ctrl);\n\n                pp_on = REG_READ(PP_ON_DELAYS);\n                pp_off = REG_READ(PP_OFF_DELAYS);\n                pp_div = REG_READ(PP_DIVISOR);\n\n\t\t \n                cur.t1_t3 = (pp_on & PANEL_POWER_UP_DELAY_MASK) >>\n                        PANEL_POWER_UP_DELAY_SHIFT;\n\n                cur.t8 = (pp_on & PANEL_LIGHT_ON_DELAY_MASK) >>\n                        PANEL_LIGHT_ON_DELAY_SHIFT;\n\n                cur.t9 = (pp_off & PANEL_LIGHT_OFF_DELAY_MASK) >>\n                        PANEL_LIGHT_OFF_DELAY_SHIFT;\n\n                cur.t10 = (pp_off & PANEL_POWER_DOWN_DELAY_MASK) >>\n                        PANEL_POWER_DOWN_DELAY_SHIFT;\n\n                cur.t11_t12 = ((pp_div & PANEL_POWER_CYCLE_DELAY_MASK) >>\n                               PANEL_POWER_CYCLE_DELAY_SHIFT);\n\n                DRM_DEBUG_KMS(\"cur t1_t3 %d t8 %d t9 %d t10 %d t11_t12 %d\\n\",\n                              cur.t1_t3, cur.t8, cur.t9, cur.t10, cur.t11_t12);\n\n\n\t\tintel_dp->panel_power_up_delay = cur.t1_t3 / 10;\n                intel_dp->backlight_on_delay = cur.t8 / 10;\n                intel_dp->backlight_off_delay = cur.t9 / 10;\n                intel_dp->panel_power_down_delay = cur.t10 / 10;\n                intel_dp->panel_power_cycle_delay = (cur.t11_t12 - 1) * 100;\n\n                DRM_DEBUG_KMS(\"panel power up delay %d, power down delay %d, power cycle delay %d\\n\",\n                              intel_dp->panel_power_up_delay, intel_dp->panel_power_down_delay,\n                              intel_dp->panel_power_cycle_delay);\n\n                DRM_DEBUG_KMS(\"backlight on delay %d, off delay %d\\n\",\n                              intel_dp->backlight_on_delay, intel_dp->backlight_off_delay);\n\n\n\t\tcdv_intel_edp_panel_vdd_on(gma_encoder);\n\t\tret = cdv_intel_dp_aux_native_read(gma_encoder, DP_DPCD_REV,\n\t\t\t\t\t       intel_dp->dpcd,\n\t\t\t\t\t       sizeof(intel_dp->dpcd));\n\t\tcdv_intel_edp_panel_vdd_off(gma_encoder);\n\t\tif (ret <= 0) {\n\t\t\t \n\t\t\tDRM_INFO(\"failed to retrieve link info, disabling eDP\\n\");\n\t\t\tdrm_encoder_cleanup(encoder);\n\t\t\tcdv_intel_dp_destroy(connector);\n\t\t\tgoto err_connector;\n\t\t} else {\n        \t\tDRM_DEBUG_KMS(\"DPCD: Rev=%x LN_Rate=%x LN_CNT=%x LN_DOWNSP=%x\\n\",\n\t\t\t\tintel_dp->dpcd[0], intel_dp->dpcd[1],\n\t\t\t\tintel_dp->dpcd[2], intel_dp->dpcd[3]);\n\n\t\t}\n\t\t \n                 \n\t}\n\treturn;\n\nerr_priv:\n\tkfree(gma_connector);\nerr_connector:\n\tkfree(gma_encoder);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}