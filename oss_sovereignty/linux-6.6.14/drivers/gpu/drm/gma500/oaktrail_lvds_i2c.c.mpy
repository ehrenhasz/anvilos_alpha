{
  "module_name": "oaktrail_lvds_i2c.c",
  "hash_id": "e8addf883eea810f35c4e32147d9522b3e871890d01e94620868977d36fc7bb8",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/gma500/oaktrail_lvds_i2c.c",
  "human_readable_source": " \n\n#include <linux/delay.h>\n#include <linux/i2c-algo-bit.h>\n#include <linux/i2c.h>\n#include <linux/init.h>\n#include <linux/io.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/pci.h>\n#include <linux/types.h>\n\n#include \"psb_drv.h\"\n#include \"psb_intel_reg.h\"\n\n\n \n\n \n#define RGEN    0x20\n#define RGIO    0x24\n#define RGLVL   0x28\n#define RGTPE   0x2C\n#define RGTNE   0x30\n#define RGGPE   0x34\n#define RGSMI   0x38\n#define RGTS    0x3C\n\n \n#define GPIO_CLOCK\t0x08\n#define GPIO_DATA\t0x10\n\n#define LPC_READ_REG(chan, r) inl((chan)->reg + (r))\n#define LPC_WRITE_REG(chan, r, val) outl((val), (chan)->reg + (r))\n\nstatic int get_clock(void *data)\n{\n\tstruct gma_i2c_chan *chan = data;\n\tu32 val;\n\n\tval = LPC_READ_REG(chan, RGIO);\n\tval |= GPIO_CLOCK;\n\tLPC_WRITE_REG(chan, RGIO, val);\n\tLPC_READ_REG(chan, RGLVL);\n\tval = (LPC_READ_REG(chan, RGLVL) & GPIO_CLOCK) ? 1 : 0;\n\n\treturn val;\n}\n\nstatic int get_data(void *data)\n{\n\tstruct gma_i2c_chan *chan = data;\n\tu32 val;\n\n\tval = LPC_READ_REG(chan, RGIO);\n\tval |= GPIO_DATA;\n\tLPC_WRITE_REG(chan, RGIO, val);\n\tLPC_READ_REG(chan, RGLVL);\n\tval = (LPC_READ_REG(chan, RGLVL) & GPIO_DATA) ? 1 : 0;\n\n\treturn val;\n}\n\nstatic void set_clock(void *data, int state_high)\n{\n\tstruct gma_i2c_chan *chan = data;\n\tu32 val;\n\n\tif (state_high) {\n\t\tval = LPC_READ_REG(chan, RGIO);\n\t\tval |= GPIO_CLOCK;\n\t\tLPC_WRITE_REG(chan, RGIO, val);\n\t} else {\n\t\tval = LPC_READ_REG(chan, RGIO);\n\t\tval &= ~GPIO_CLOCK;\n\t\tLPC_WRITE_REG(chan, RGIO, val);\n\t\tval = LPC_READ_REG(chan, RGLVL);\n\t\tval &= ~GPIO_CLOCK;\n\t\tLPC_WRITE_REG(chan, RGLVL, val);\n\t}\n}\n\nstatic void set_data(void *data, int state_high)\n{\n\tstruct gma_i2c_chan *chan = data;\n\tu32 val;\n\n\tif (state_high) {\n\t\tval = LPC_READ_REG(chan, RGIO);\n\t\tval |= GPIO_DATA;\n\t\tLPC_WRITE_REG(chan, RGIO, val);\n\t} else {\n\t\tval = LPC_READ_REG(chan, RGIO);\n\t\tval &= ~GPIO_DATA;\n\t\tLPC_WRITE_REG(chan, RGIO, val);\n\t\tval = LPC_READ_REG(chan, RGLVL);\n\t\tval &= ~GPIO_DATA;\n\t\tLPC_WRITE_REG(chan, RGLVL, val);\n\t}\n}\n\nstruct gma_i2c_chan *oaktrail_lvds_i2c_init(struct drm_device *dev)\n{\n\tstruct drm_psb_private *dev_priv = to_drm_psb_private(dev);\n\tstruct gma_i2c_chan *chan;\n\tint ret;\n\n\tchan = kzalloc(sizeof(struct gma_i2c_chan), GFP_KERNEL);\n\tif (!chan)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tchan->drm_dev = dev;\n\tchan->reg = dev_priv->lpc_gpio_base;\n\tstrncpy(chan->base.name, \"gma500 LPC\",  I2C_NAME_SIZE - 1);\n\tchan->base.owner = THIS_MODULE;\n\tchan->base.algo_data = &chan->algo;\n\tchan->base.dev.parent = dev->dev;\n\tchan->algo.setsda = set_data;\n\tchan->algo.setscl = set_clock;\n\tchan->algo.getsda = get_data;\n\tchan->algo.getscl = get_clock;\n\tchan->algo.udelay = 100;\n\tchan->algo.timeout = usecs_to_jiffies(2200);\n\tchan->algo.data = chan;\n\n\ti2c_set_adapdata(&chan->base, chan);\n\n\tset_data(chan, 1);\n\tset_clock(chan, 1);\n\tudelay(50);\n\n\tret = i2c_bit_add_bus(&chan->base);\n\tif (ret < 0) {\n\t\tkfree(chan);\n\t\treturn ERR_PTR(ret);\n\t}\n\n\treturn chan;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}