{
  "module_name": "power.c",
  "hash_id": "957bb9bb0d5144e4367eae217094f8264082b3d9596aa6528d8ada46d564b347",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/gma500/power.c",
  "human_readable_source": " \n\n#include \"gem.h\"\n#include \"power.h\"\n#include \"psb_drv.h\"\n#include \"psb_reg.h\"\n#include \"psb_intel_reg.h\"\n#include \"psb_irq.h\"\n#include <linux/mutex.h>\n#include <linux/pm_runtime.h>\n\n \nvoid gma_power_init(struct drm_device *dev)\n{\n\tstruct drm_psb_private *dev_priv = to_drm_psb_private(dev);\n\n\t \n\tdev_priv->apm_base = dev_priv->apm_reg & 0xffff;\n\tdev_priv->ospm_base &= 0xffff;\n\n\tif (dev_priv->ops->init_pm)\n\t\tdev_priv->ops->init_pm(dev);\n\n\t \n\tpm_runtime_get(dev->dev);\n\n\tdev_priv->pm_initialized = true;\n}\n\n \nvoid gma_power_uninit(struct drm_device *dev)\n{\n\tstruct drm_psb_private *dev_priv = to_drm_psb_private(dev);\n\n\tif (!dev_priv->pm_initialized)\n\t\treturn;\n\n\tpm_runtime_put_noidle(dev->dev);\n}\n\n \nstatic void gma_suspend_display(struct drm_device *dev)\n{\n\tstruct drm_psb_private *dev_priv = to_drm_psb_private(dev);\n\n\tdev_priv->ops->save_regs(dev);\n\tdev_priv->ops->power_down(dev);\n}\n\n \nstatic void gma_resume_display(struct pci_dev *pdev)\n{\n\tstruct drm_device *dev = pci_get_drvdata(pdev);\n\tstruct drm_psb_private *dev_priv = to_drm_psb_private(dev);\n\n\t \n\tdev_priv->ops->power_up(dev);\n\n\tPSB_WVDC32(dev_priv->pge_ctl | _PSB_PGETBL_ENABLED, PSB_PGETBL_CTL);\n\tpci_write_config_word(pdev, PSB_GMCH_CTRL,\n\t\t\tdev_priv->gmch_ctrl | _PSB_GMCH_ENABLED);\n\n\t \n\tpsb_gtt_resume(dev);\n\tpsb_gem_mm_resume(dev);\n\tdev_priv->ops->restore_regs(dev);\n}\n\n \nstatic void gma_suspend_pci(struct pci_dev *pdev)\n{\n\tstruct drm_device *dev = pci_get_drvdata(pdev);\n\tstruct drm_psb_private *dev_priv = to_drm_psb_private(dev);\n\tint bsm, vbt;\n\n\tpci_save_state(pdev);\n\tpci_read_config_dword(pdev, 0x5C, &bsm);\n\tdev_priv->regs.saveBSM = bsm;\n\tpci_read_config_dword(pdev, 0xFC, &vbt);\n\tdev_priv->regs.saveVBT = vbt;\n\n\tpci_disable_device(pdev);\n\tpci_set_power_state(pdev, PCI_D3hot);\n}\n\n \nstatic int gma_resume_pci(struct pci_dev *pdev)\n{\n\tstruct drm_device *dev = pci_get_drvdata(pdev);\n\tstruct drm_psb_private *dev_priv = to_drm_psb_private(dev);\n\n\tpci_set_power_state(pdev, PCI_D0);\n\tpci_restore_state(pdev);\n\tpci_write_config_dword(pdev, 0x5c, dev_priv->regs.saveBSM);\n\tpci_write_config_dword(pdev, 0xFC, dev_priv->regs.saveVBT);\n\n\treturn pci_enable_device(pdev);\n}\n\n \nint gma_power_suspend(struct device *_dev)\n{\n\tstruct pci_dev *pdev = to_pci_dev(_dev);\n\tstruct drm_device *dev = pci_get_drvdata(pdev);\n\n\tgma_irq_uninstall(dev);\n\tgma_suspend_display(dev);\n\tgma_suspend_pci(pdev);\n\treturn 0;\n}\n\n \nint gma_power_resume(struct device *_dev)\n{\n\tstruct pci_dev *pdev = to_pci_dev(_dev);\n\tstruct drm_device *dev = pci_get_drvdata(pdev);\n\n\tgma_resume_pci(pdev);\n\tgma_resume_display(pdev);\n\tgma_irq_install(dev);\n\treturn 0;\n}\n\n \nbool gma_power_begin(struct drm_device *dev, bool force_on)\n{\n\tif (force_on)\n\t\treturn pm_runtime_resume_and_get(dev->dev) == 0;\n\telse\n\t\treturn pm_runtime_get_if_in_use(dev->dev) == 1;\n}\n\n \nvoid gma_power_end(struct drm_device *dev)\n{\n\tpm_runtime_put(dev->dev);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}