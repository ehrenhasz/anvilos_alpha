{
  "module_name": "oaktrail_hdmi_i2c.c",
  "hash_id": "04a5f9231b9124e8f866cc396d7f19400556ce184868a60250826969886370e2",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/gma500/oaktrail_hdmi_i2c.c",
  "human_readable_source": " \n\n#include <linux/export.h>\n#include <linux/mutex.h>\n#include <linux/pci.h>\n#include <linux/i2c.h>\n#include <linux/interrupt.h>\n#include <linux/delay.h>\n#include \"psb_drv.h\"\n\n#define HDMI_READ(reg)\t\treadl(hdmi_dev->regs + (reg))\n#define HDMI_WRITE(reg, val)\twritel(val, hdmi_dev->regs + (reg))\n\n#define HDMI_HCR\t0x1000\n#define HCR_DETECT_HDP\t\t(1 << 6)\n#define HCR_ENABLE_HDCP\t\t(1 << 5)\n#define HCR_ENABLE_AUDIO\t(1 << 2)\n#define HCR_ENABLE_PIXEL\t(1 << 1)\n#define HCR_ENABLE_TMDS\t\t(1 << 0)\n#define HDMI_HICR\t0x1004\n#define HDMI_INTR_I2C_ERROR\t(1 << 4)\n#define HDMI_INTR_I2C_FULL\t(1 << 3)\n#define HDMI_INTR_I2C_DONE\t(1 << 2)\n#define HDMI_INTR_HPD\t\t(1 << 0)\n#define HDMI_HSR\t0x1008\n#define HDMI_HISR\t0x100C\n#define HDMI_HI2CRDB0\t0x1200\n#define HDMI_HI2CHCR\t0x1240\n#define HI2C_HDCP_WRITE\t\t(0 << 2)\n#define HI2C_HDCP_RI_READ\t(1 << 2)\n#define HI2C_HDCP_READ\t\t(2 << 2)\n#define HI2C_EDID_READ\t\t(3 << 2)\n#define HI2C_READ_CONTINUE\t(1 << 1)\n#define HI2C_ENABLE_TRANSACTION\t(1 << 0)\n\n#define HDMI_ICRH\t0x1100\n#define HDMI_HI2CTDR0\t0x1244\n#define HDMI_HI2CTDR1\t0x1248\n\n#define I2C_STAT_INIT\t\t0\n#define I2C_READ_DONE\t\t1\n#define I2C_TRANSACTION_DONE\t2\n\nstruct hdmi_i2c_dev {\n\tstruct i2c_adapter *adap;\n\tstruct mutex i2c_lock;\n\tstruct completion complete;\n\tint status;\n\tstruct i2c_msg *msg;\n\tint buf_offset;\n};\n\nstatic void hdmi_i2c_irq_enable(struct oaktrail_hdmi_dev *hdmi_dev)\n{\n\tu32 temp;\n\n\ttemp = HDMI_READ(HDMI_HICR);\n\ttemp |= (HDMI_INTR_I2C_ERROR | HDMI_INTR_I2C_FULL | HDMI_INTR_I2C_DONE);\n\tHDMI_WRITE(HDMI_HICR, temp);\n\tHDMI_READ(HDMI_HICR);\n}\n\nstatic void hdmi_i2c_irq_disable(struct oaktrail_hdmi_dev *hdmi_dev)\n{\n\tHDMI_WRITE(HDMI_HICR, 0x0);\n\tHDMI_READ(HDMI_HICR);\n}\n\nstatic int xfer_read(struct i2c_adapter *adap, struct i2c_msg *pmsg)\n{\n\tstruct oaktrail_hdmi_dev *hdmi_dev = i2c_get_adapdata(adap);\n\tstruct hdmi_i2c_dev *i2c_dev = hdmi_dev->i2c_dev;\n\tu32 temp;\n\n\ti2c_dev->status = I2C_STAT_INIT;\n\ti2c_dev->msg = pmsg;\n\ti2c_dev->buf_offset = 0;\n\treinit_completion(&i2c_dev->complete);\n\n\t \n\ttemp = ((pmsg->len) << 20) | HI2C_EDID_READ | HI2C_ENABLE_TRANSACTION;\n\tHDMI_WRITE(HDMI_HI2CHCR, temp);\n\tHDMI_READ(HDMI_HI2CHCR);\n\n\twhile (i2c_dev->status != I2C_TRANSACTION_DONE)\n\t\twait_for_completion_interruptible_timeout(&i2c_dev->complete,\n\t\t\t\t\t\t\t\t10 * HZ);\n\n\treturn 0;\n}\n\nstatic int xfer_write(struct i2c_adapter *adap, struct i2c_msg *pmsg)\n{\n\t \n\treturn 0;\n}\n\nstatic int oaktrail_hdmi_i2c_access(struct i2c_adapter *adap,\n\t\t\t\tstruct i2c_msg *pmsg,\n\t\t\t\tint num)\n{\n\tstruct oaktrail_hdmi_dev *hdmi_dev = i2c_get_adapdata(adap);\n\tstruct hdmi_i2c_dev *i2c_dev = hdmi_dev->i2c_dev;\n\tint i;\n\n\tmutex_lock(&i2c_dev->i2c_lock);\n\n\t \n\tHDMI_WRITE(HDMI_ICRH, 0x00008760);\n\n\t \n\thdmi_i2c_irq_enable(hdmi_dev);\n\tfor (i = 0; i < num; i++) {\n\t\tif (pmsg->len && pmsg->buf) {\n\t\t\tif (pmsg->flags & I2C_M_RD)\n\t\t\t\txfer_read(adap, pmsg);\n\t\t\telse\n\t\t\t\txfer_write(adap, pmsg);\n\t\t}\n\t\tpmsg++;          \n\t}\n\n\t \n\thdmi_i2c_irq_disable(hdmi_dev);\n\n\tmutex_unlock(&i2c_dev->i2c_lock);\n\n\treturn i;\n}\n\nstatic u32 oaktrail_hdmi_i2c_func(struct i2c_adapter *adapter)\n{\n\treturn I2C_FUNC_I2C | I2C_FUNC_10BIT_ADDR;\n}\n\nstatic const struct i2c_algorithm oaktrail_hdmi_i2c_algorithm = {\n\t.master_xfer\t= oaktrail_hdmi_i2c_access,\n\t.functionality  = oaktrail_hdmi_i2c_func,\n};\n\nstatic struct i2c_adapter oaktrail_hdmi_i2c_adapter = {\n\t.name\t\t= \"oaktrail_hdmi_i2c\",\n\t.nr\t\t= 3,\n\t.owner\t\t= THIS_MODULE,\n\t.class\t\t= I2C_CLASS_DDC,\n\t.algo\t\t= &oaktrail_hdmi_i2c_algorithm,\n};\n\nstatic void hdmi_i2c_read(struct oaktrail_hdmi_dev *hdmi_dev)\n{\n\tstruct hdmi_i2c_dev *i2c_dev = hdmi_dev->i2c_dev;\n\tstruct i2c_msg *msg = i2c_dev->msg;\n\tu8 *buf = msg->buf;\n\tu32 temp;\n\tint i, offset;\n\n\toffset = i2c_dev->buf_offset;\n\tfor (i = 0; i < 0x10; i++) {\n\t\ttemp = HDMI_READ(HDMI_HI2CRDB0 + (i * 4));\n\t\tmemcpy(buf + (offset + i * 4), &temp, 4);\n\t}\n\ti2c_dev->buf_offset += (0x10 * 4);\n\n\t \n\ttemp = HDMI_READ(HDMI_HISR);\n\tHDMI_WRITE(HDMI_HISR, temp | HDMI_INTR_I2C_FULL);\n\tHDMI_READ(HDMI_HISR);\n\n\t \n\ttemp = HDMI_READ(HDMI_HI2CHCR);\n\tHDMI_WRITE(HDMI_HI2CHCR, temp | HI2C_READ_CONTINUE);\n\tHDMI_READ(HDMI_HI2CHCR);\n\n\ti2c_dev->status = I2C_READ_DONE;\n\treturn;\n}\n\nstatic void hdmi_i2c_transaction_done(struct oaktrail_hdmi_dev *hdmi_dev)\n{\n\tstruct hdmi_i2c_dev *i2c_dev = hdmi_dev->i2c_dev;\n\tu32 temp;\n\n\t \n\ttemp = HDMI_READ(HDMI_HISR);\n\tHDMI_WRITE(HDMI_HISR, temp | HDMI_INTR_I2C_DONE);\n\tHDMI_READ(HDMI_HISR);\n\n\n\ttemp = HDMI_READ(HDMI_HI2CHCR);\n\tHDMI_WRITE(HDMI_HI2CHCR, temp & ~HI2C_ENABLE_TRANSACTION);\n\tHDMI_READ(HDMI_HI2CHCR);\n\n\ti2c_dev->status = I2C_TRANSACTION_DONE;\n\treturn;\n}\n\nstatic irqreturn_t oaktrail_hdmi_i2c_handler(int this_irq, void *dev)\n{\n\tstruct oaktrail_hdmi_dev *hdmi_dev = dev;\n\tstruct hdmi_i2c_dev *i2c_dev = hdmi_dev->i2c_dev;\n\tu32 stat;\n\n\tstat = HDMI_READ(HDMI_HISR);\n\n\tif (stat & HDMI_INTR_HPD) {\n\t\tHDMI_WRITE(HDMI_HISR, stat | HDMI_INTR_HPD);\n\t\tHDMI_READ(HDMI_HISR);\n\t}\n\n\tif (stat & HDMI_INTR_I2C_FULL)\n\t\thdmi_i2c_read(hdmi_dev);\n\n\tif (stat & HDMI_INTR_I2C_DONE)\n\t\thdmi_i2c_transaction_done(hdmi_dev);\n\n\tcomplete(&i2c_dev->complete);\n\n\treturn IRQ_HANDLED;\n}\n\n \nstatic void oaktrail_hdmi_i2c_gpio_fix(void)\n{\n\tvoid __iomem *base;\n\tunsigned int gpio_base = 0xff12c000;\n\tint gpio_len = 0x1000;\n\tu32 temp;\n\n\tbase = ioremap((resource_size_t)gpio_base, gpio_len);\n\tif (base == NULL) {\n\t\tDRM_ERROR(\"gpio ioremap fail\\n\");\n\t\treturn;\n\t}\n\n\ttemp = readl(base + 0x44);\n\tDRM_DEBUG_DRIVER(\"old gpio val %x\\n\", temp);\n\twritel((temp | 0x00000a00), (base +  0x44));\n\ttemp = readl(base + 0x44);\n\tDRM_DEBUG_DRIVER(\"new gpio val %x\\n\", temp);\n\n\tiounmap(base);\n}\n\nint oaktrail_hdmi_i2c_init(struct pci_dev *dev)\n{\n\tstruct oaktrail_hdmi_dev *hdmi_dev;\n\tstruct hdmi_i2c_dev *i2c_dev;\n\tint ret;\n\n\thdmi_dev = pci_get_drvdata(dev);\n\n\ti2c_dev = kzalloc(sizeof(struct hdmi_i2c_dev), GFP_KERNEL);\n\tif (!i2c_dev)\n\t\treturn -ENOMEM;\n\n\ti2c_dev->adap = &oaktrail_hdmi_i2c_adapter;\n\ti2c_dev->status = I2C_STAT_INIT;\n\tinit_completion(&i2c_dev->complete);\n\tmutex_init(&i2c_dev->i2c_lock);\n\ti2c_set_adapdata(&oaktrail_hdmi_i2c_adapter, hdmi_dev);\n\thdmi_dev->i2c_dev = i2c_dev;\n\n\t \n\toaktrail_hdmi_i2c_gpio_fix();\n\n\t \n\tret = request_irq(dev->irq, oaktrail_hdmi_i2c_handler, IRQF_SHARED,\n\t\t\t  oaktrail_hdmi_i2c_adapter.name, hdmi_dev);\n\tif (ret) {\n\t\tDRM_ERROR(\"Failed to request IRQ for I2C controller\\n\");\n\t\tgoto free_dev;\n\t}\n\n\t \n\tret = i2c_add_numbered_adapter(&oaktrail_hdmi_i2c_adapter);\n\tif (ret) {\n\t\tDRM_ERROR(\"Failed to add I2C adapter\\n\");\n\t\tgoto free_irq;\n\t}\n\n\treturn 0;\n\nfree_irq:\n\tfree_irq(dev->irq, hdmi_dev);\nfree_dev:\n\tkfree(i2c_dev);\n\n\treturn ret;\n}\n\nvoid oaktrail_hdmi_i2c_exit(struct pci_dev *dev)\n{\n\tstruct oaktrail_hdmi_dev *hdmi_dev;\n\tstruct hdmi_i2c_dev *i2c_dev;\n\n\thdmi_dev = pci_get_drvdata(dev);\n\ti2c_del_adapter(&oaktrail_hdmi_i2c_adapter);\n\n\ti2c_dev = hdmi_dev->i2c_dev;\n\tkfree(i2c_dev);\n\tfree_irq(dev->irq, hdmi_dev);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}