{
  "module_name": "psb_irq.c",
  "hash_id": "b423ca8199bc542a80730f612c37bf9cca69de5fbf26790ba238d09cce23374c",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/gma500/psb_irq.c",
  "human_readable_source": "\n \n\n#include <drm/drm_drv.h>\n#include <drm/drm_vblank.h>\n\n#include \"power.h\"\n#include \"psb_drv.h\"\n#include \"psb_intel_reg.h\"\n#include \"psb_irq.h\"\n#include \"psb_reg.h\"\n\n \n\nstatic inline u32 gma_pipestat(int pipe)\n{\n\tif (pipe == 0)\n\t\treturn PIPEASTAT;\n\tif (pipe == 1)\n\t\treturn PIPEBSTAT;\n\tif (pipe == 2)\n\t\treturn PIPECSTAT;\n\tBUG();\n}\n\nstatic inline u32 gma_pipeconf(int pipe)\n{\n\tif (pipe == 0)\n\t\treturn PIPEACONF;\n\tif (pipe == 1)\n\t\treturn PIPEBCONF;\n\tif (pipe == 2)\n\t\treturn PIPECCONF;\n\tBUG();\n}\n\nvoid gma_enable_pipestat(struct drm_psb_private *dev_priv, int pipe, u32 mask)\n{\n\tif ((dev_priv->pipestat[pipe] & mask) != mask) {\n\t\tu32 reg = gma_pipestat(pipe);\n\t\tdev_priv->pipestat[pipe] |= mask;\n\t\t \n\t\tif (gma_power_begin(&dev_priv->dev, false)) {\n\t\t\tu32 writeVal = PSB_RVDC32(reg);\n\t\t\twriteVal |= (mask | (mask >> 16));\n\t\t\tPSB_WVDC32(writeVal, reg);\n\t\t\t(void) PSB_RVDC32(reg);\n\t\t\tgma_power_end(&dev_priv->dev);\n\t\t}\n\t}\n}\n\nvoid gma_disable_pipestat(struct drm_psb_private *dev_priv, int pipe, u32 mask)\n{\n\tif ((dev_priv->pipestat[pipe] & mask) != 0) {\n\t\tu32 reg = gma_pipestat(pipe);\n\t\tdev_priv->pipestat[pipe] &= ~mask;\n\t\tif (gma_power_begin(&dev_priv->dev, false)) {\n\t\t\tu32 writeVal = PSB_RVDC32(reg);\n\t\t\twriteVal &= ~mask;\n\t\t\tPSB_WVDC32(writeVal, reg);\n\t\t\t(void) PSB_RVDC32(reg);\n\t\t\tgma_power_end(&dev_priv->dev);\n\t\t}\n\t}\n}\n\n \nstatic void gma_pipe_event_handler(struct drm_device *dev, int pipe)\n{\n\tstruct drm_psb_private *dev_priv = to_drm_psb_private(dev);\n\n\tuint32_t pipe_stat_val = 0;\n\tuint32_t pipe_stat_reg = gma_pipestat(pipe);\n\tuint32_t pipe_enable = dev_priv->pipestat[pipe];\n\tuint32_t pipe_status = dev_priv->pipestat[pipe] >> 16;\n\tuint32_t pipe_clear;\n\tuint32_t i = 0;\n\n\tspin_lock(&dev_priv->irqmask_lock);\n\n\tpipe_stat_val = PSB_RVDC32(pipe_stat_reg);\n\tpipe_stat_val &= pipe_enable | pipe_status;\n\tpipe_stat_val &= pipe_stat_val >> 16;\n\n\tspin_unlock(&dev_priv->irqmask_lock);\n\n\t \n\tfor (i = 0; i < 0xffff; i++) {\n\t\tPSB_WVDC32(PSB_RVDC32(pipe_stat_reg), pipe_stat_reg);\n\t\tpipe_clear = PSB_RVDC32(pipe_stat_reg) & pipe_status;\n\n\t\tif (pipe_clear == 0)\n\t\t\tbreak;\n\t}\n\n\tif (pipe_clear)\n\t\tdev_err(dev->dev,\n\t\t\"%s, can't clear status bits for pipe %d, its value = 0x%x.\\n\",\n\t\t__func__, pipe, PSB_RVDC32(pipe_stat_reg));\n\n\tif (pipe_stat_val & PIPE_VBLANK_STATUS) {\n\t\tstruct drm_crtc *crtc = drm_crtc_from_index(dev, pipe);\n\t\tstruct gma_crtc *gma_crtc = to_gma_crtc(crtc);\n\t\tunsigned long flags;\n\n\t\tdrm_handle_vblank(dev, pipe);\n\n\t\tspin_lock_irqsave(&dev->event_lock, flags);\n\t\tif (gma_crtc->page_flip_event) {\n\t\t\tdrm_crtc_send_vblank_event(crtc,\n\t\t\t\t\t\t   gma_crtc->page_flip_event);\n\t\t\tgma_crtc->page_flip_event = NULL;\n\t\t\tdrm_crtc_vblank_put(crtc);\n\t\t}\n\t\tspin_unlock_irqrestore(&dev->event_lock, flags);\n\t}\n}\n\n \nstatic void gma_vdc_interrupt(struct drm_device *dev, uint32_t vdc_stat)\n{\n\tif (vdc_stat & _PSB_IRQ_ASLE)\n\t\tpsb_intel_opregion_asle_intr(dev);\n\n\tif (vdc_stat & _PSB_VSYNC_PIPEA_FLAG)\n\t\tgma_pipe_event_handler(dev, 0);\n\n\tif (vdc_stat & _PSB_VSYNC_PIPEB_FLAG)\n\t\tgma_pipe_event_handler(dev, 1);\n}\n\n \nstatic void gma_sgx_interrupt(struct drm_device *dev, u32 stat_1, u32 stat_2)\n{\n\tstruct drm_psb_private *dev_priv = to_drm_psb_private(dev);\n\tu32 val, addr;\n\n\tif (stat_1 & _PSB_CE_TWOD_COMPLETE)\n\t\tval = PSB_RSGX32(PSB_CR_2D_BLIT_STATUS);\n\n\tif (stat_2 & _PSB_CE2_BIF_REQUESTER_FAULT) {\n\t\tval = PSB_RSGX32(PSB_CR_BIF_INT_STAT);\n\t\taddr = PSB_RSGX32(PSB_CR_BIF_FAULT);\n\t\tif (val) {\n\t\t\tif (val & _PSB_CBI_STAT_PF_N_RW)\n\t\t\t\tDRM_ERROR(\"SGX MMU page fault:\");\n\t\t\telse\n\t\t\t\tDRM_ERROR(\"SGX MMU read / write protection fault:\");\n\n\t\t\tif (val & _PSB_CBI_STAT_FAULT_CACHE)\n\t\t\t\tDRM_ERROR(\"\\tCache requestor\");\n\t\t\tif (val & _PSB_CBI_STAT_FAULT_TA)\n\t\t\t\tDRM_ERROR(\"\\tTA requestor\");\n\t\t\tif (val & _PSB_CBI_STAT_FAULT_VDM)\n\t\t\t\tDRM_ERROR(\"\\tVDM requestor\");\n\t\t\tif (val & _PSB_CBI_STAT_FAULT_2D)\n\t\t\t\tDRM_ERROR(\"\\t2D requestor\");\n\t\t\tif (val & _PSB_CBI_STAT_FAULT_PBE)\n\t\t\t\tDRM_ERROR(\"\\tPBE requestor\");\n\t\t\tif (val & _PSB_CBI_STAT_FAULT_TSP)\n\t\t\t\tDRM_ERROR(\"\\tTSP requestor\");\n\t\t\tif (val & _PSB_CBI_STAT_FAULT_ISP)\n\t\t\t\tDRM_ERROR(\"\\tISP requestor\");\n\t\t\tif (val & _PSB_CBI_STAT_FAULT_USSEPDS)\n\t\t\t\tDRM_ERROR(\"\\tUSSEPDS requestor\");\n\t\t\tif (val & _PSB_CBI_STAT_FAULT_HOST)\n\t\t\t\tDRM_ERROR(\"\\tHost requestor\");\n\n\t\t\tDRM_ERROR(\"\\tMMU failing address is 0x%08x.\\n\",\n\t\t\t\t  (unsigned int)addr);\n\t\t}\n\t}\n\n\t \n\tPSB_WSGX32(stat_1, PSB_CR_EVENT_HOST_CLEAR);\n\tPSB_WSGX32(stat_2, PSB_CR_EVENT_HOST_CLEAR2);\n\tPSB_RSGX32(PSB_CR_EVENT_HOST_CLEAR2);\n}\n\nstatic irqreturn_t gma_irq_handler(int irq, void *arg)\n{\n\tstruct drm_device *dev = arg;\n\tstruct drm_psb_private *dev_priv = to_drm_psb_private(dev);\n\tuint32_t vdc_stat, dsp_int = 0, sgx_int = 0, hotplug_int = 0;\n\tu32 sgx_stat_1, sgx_stat_2;\n\tint handled = 0;\n\n\tspin_lock(&dev_priv->irqmask_lock);\n\n\tvdc_stat = PSB_RVDC32(PSB_INT_IDENTITY_R);\n\n\tif (vdc_stat & (_PSB_PIPE_EVENT_FLAG|_PSB_IRQ_ASLE))\n\t\tdsp_int = 1;\n\n\tif (vdc_stat & _PSB_IRQ_SGX_FLAG)\n\t\tsgx_int = 1;\n\tif (vdc_stat & _PSB_IRQ_DISP_HOTSYNC)\n\t\thotplug_int = 1;\n\n\tvdc_stat &= dev_priv->vdc_irq_mask;\n\tspin_unlock(&dev_priv->irqmask_lock);\n\n\tif (dsp_int) {\n\t\tgma_vdc_interrupt(dev, vdc_stat);\n\t\thandled = 1;\n\t}\n\n\tif (sgx_int) {\n\t\tsgx_stat_1 = PSB_RSGX32(PSB_CR_EVENT_STATUS);\n\t\tsgx_stat_2 = PSB_RSGX32(PSB_CR_EVENT_STATUS2);\n\t\tgma_sgx_interrupt(dev, sgx_stat_1, sgx_stat_2);\n\t\thandled = 1;\n\t}\n\n\t \n\tif (hotplug_int && dev_priv->ops->hotplug) {\n\t\thandled = dev_priv->ops->hotplug(dev);\n\t\tREG_WRITE(PORT_HOTPLUG_STAT, REG_READ(PORT_HOTPLUG_STAT));\n\t}\n\n\tPSB_WVDC32(vdc_stat, PSB_INT_IDENTITY_R);\n\t(void) PSB_RVDC32(PSB_INT_IDENTITY_R);\n\trmb();\n\n\tif (!handled)\n\t\treturn IRQ_NONE;\n\n\treturn IRQ_HANDLED;\n}\n\nvoid gma_irq_preinstall(struct drm_device *dev)\n{\n\tstruct drm_psb_private *dev_priv = to_drm_psb_private(dev);\n\tunsigned long irqflags;\n\n\tspin_lock_irqsave(&dev_priv->irqmask_lock, irqflags);\n\n\tPSB_WVDC32(0xFFFFFFFF, PSB_HWSTAM);\n\tPSB_WVDC32(0x00000000, PSB_INT_MASK_R);\n\tPSB_WVDC32(0x00000000, PSB_INT_ENABLE_R);\n\tPSB_WSGX32(0x00000000, PSB_CR_EVENT_HOST_ENABLE);\n\tPSB_RSGX32(PSB_CR_EVENT_HOST_ENABLE);\n\n\tif (dev->vblank[0].enabled)\n\t\tdev_priv->vdc_irq_mask |= _PSB_VSYNC_PIPEA_FLAG;\n\tif (dev->vblank[1].enabled)\n\t\tdev_priv->vdc_irq_mask |= _PSB_VSYNC_PIPEB_FLAG;\n\n\t \n\tif (dev_priv->ops->hotplug)\n\t\tdev_priv->vdc_irq_mask |= _PSB_IRQ_DISP_HOTSYNC;\n\tdev_priv->vdc_irq_mask |= _PSB_IRQ_ASLE | _PSB_IRQ_SGX_FLAG;\n\n\t \n\tPSB_WVDC32(~dev_priv->vdc_irq_mask, PSB_INT_MASK_R);\n\tspin_unlock_irqrestore(&dev_priv->irqmask_lock, irqflags);\n}\n\nvoid gma_irq_postinstall(struct drm_device *dev)\n{\n\tstruct drm_psb_private *dev_priv = to_drm_psb_private(dev);\n\tunsigned long irqflags;\n\tunsigned int i;\n\n\tspin_lock_irqsave(&dev_priv->irqmask_lock, irqflags);\n\n\t \n\tPSB_WSGX32(_PSB_CE2_BIF_REQUESTER_FAULT, PSB_CR_EVENT_HOST_ENABLE2);\n\tPSB_WSGX32(_PSB_CE_TWOD_COMPLETE, PSB_CR_EVENT_HOST_ENABLE);\n\tPSB_RSGX32(PSB_CR_EVENT_HOST_ENABLE);  \n\n\t \n\tPSB_WVDC32(dev_priv->vdc_irq_mask, PSB_INT_ENABLE_R);\n\tPSB_WVDC32(0xFFFFFFFF, PSB_HWSTAM);\n\n\tfor (i = 0; i < dev->num_crtcs; ++i) {\n\t\tif (dev->vblank[i].enabled)\n\t\t\tgma_enable_pipestat(dev_priv, i, PIPE_VBLANK_INTERRUPT_ENABLE);\n\t\telse\n\t\t\tgma_disable_pipestat(dev_priv, i, PIPE_VBLANK_INTERRUPT_ENABLE);\n\t}\n\n\tif (dev_priv->ops->hotplug_enable)\n\t\tdev_priv->ops->hotplug_enable(dev, true);\n\n\tspin_unlock_irqrestore(&dev_priv->irqmask_lock, irqflags);\n}\n\nint gma_irq_install(struct drm_device *dev)\n{\n\tstruct drm_psb_private *dev_priv = to_drm_psb_private(dev);\n\tstruct pci_dev *pdev = to_pci_dev(dev->dev);\n\tint ret;\n\n\tif (dev_priv->use_msi && pci_enable_msi(pdev)) {\n\t\tdev_warn(dev->dev, \"Enabling MSI failed!\\n\");\n\t\tdev_priv->use_msi = false;\n\t}\n\n\tif (pdev->irq == IRQ_NOTCONNECTED)\n\t\treturn -ENOTCONN;\n\n\tgma_irq_preinstall(dev);\n\n\t \n\tret = request_irq(pdev->irq, gma_irq_handler, IRQF_SHARED, dev->driver->name, dev);\n\tif (ret)\n\t\treturn ret;\n\n\tgma_irq_postinstall(dev);\n\n\tdev_priv->irq_enabled = true;\n\n\treturn 0;\n}\n\nvoid gma_irq_uninstall(struct drm_device *dev)\n{\n\tstruct drm_psb_private *dev_priv = to_drm_psb_private(dev);\n\tstruct pci_dev *pdev = to_pci_dev(dev->dev);\n\tunsigned long irqflags;\n\tunsigned int i;\n\n\tif (!dev_priv->irq_enabled)\n\t\treturn;\n\n\tspin_lock_irqsave(&dev_priv->irqmask_lock, irqflags);\n\n\tif (dev_priv->ops->hotplug_enable)\n\t\tdev_priv->ops->hotplug_enable(dev, false);\n\n\tPSB_WVDC32(0xFFFFFFFF, PSB_HWSTAM);\n\n\tfor (i = 0; i < dev->num_crtcs; ++i) {\n\t\tif (dev->vblank[i].enabled)\n\t\t\tgma_disable_pipestat(dev_priv, i, PIPE_VBLANK_INTERRUPT_ENABLE);\n\t}\n\n\tdev_priv->vdc_irq_mask &= _PSB_IRQ_SGX_FLAG |\n\t\t\t\t  _PSB_IRQ_MSVDX_FLAG |\n\t\t\t\t  _LNC_IRQ_TOPAZ_FLAG;\n\n\t \n\tPSB_WVDC32(~dev_priv->vdc_irq_mask, PSB_INT_MASK_R);\n\tPSB_WVDC32(dev_priv->vdc_irq_mask, PSB_INT_ENABLE_R);\n\n\twmb();\n\n\t \n\tPSB_WVDC32(PSB_RVDC32(PSB_INT_IDENTITY_R), PSB_INT_IDENTITY_R);\n\tspin_unlock_irqrestore(&dev_priv->irqmask_lock, irqflags);\n\n\tfree_irq(pdev->irq, dev);\n\tif (dev_priv->use_msi)\n\t\tpci_disable_msi(pdev);\n}\n\nint gma_crtc_enable_vblank(struct drm_crtc *crtc)\n{\n\tstruct drm_device *dev = crtc->dev;\n\tunsigned int pipe = crtc->index;\n\tstruct drm_psb_private *dev_priv = to_drm_psb_private(dev);\n\tunsigned long irqflags;\n\tuint32_t reg_val = 0;\n\tuint32_t pipeconf_reg = gma_pipeconf(pipe);\n\n\tif (gma_power_begin(dev, false)) {\n\t\treg_val = REG_READ(pipeconf_reg);\n\t\tgma_power_end(dev);\n\t}\n\n\tif (!(reg_val & PIPEACONF_ENABLE))\n\t\treturn -EINVAL;\n\n\tspin_lock_irqsave(&dev_priv->irqmask_lock, irqflags);\n\n\tif (pipe == 0)\n\t\tdev_priv->vdc_irq_mask |= _PSB_VSYNC_PIPEA_FLAG;\n\telse if (pipe == 1)\n\t\tdev_priv->vdc_irq_mask |= _PSB_VSYNC_PIPEB_FLAG;\n\n\tPSB_WVDC32(~dev_priv->vdc_irq_mask, PSB_INT_MASK_R);\n\tPSB_WVDC32(dev_priv->vdc_irq_mask, PSB_INT_ENABLE_R);\n\tgma_enable_pipestat(dev_priv, pipe, PIPE_VBLANK_INTERRUPT_ENABLE);\n\n\tspin_unlock_irqrestore(&dev_priv->irqmask_lock, irqflags);\n\n\treturn 0;\n}\n\nvoid gma_crtc_disable_vblank(struct drm_crtc *crtc)\n{\n\tstruct drm_device *dev = crtc->dev;\n\tunsigned int pipe = crtc->index;\n\tstruct drm_psb_private *dev_priv = to_drm_psb_private(dev);\n\tunsigned long irqflags;\n\n\tspin_lock_irqsave(&dev_priv->irqmask_lock, irqflags);\n\n\tif (pipe == 0)\n\t\tdev_priv->vdc_irq_mask &= ~_PSB_VSYNC_PIPEA_FLAG;\n\telse if (pipe == 1)\n\t\tdev_priv->vdc_irq_mask &= ~_PSB_VSYNC_PIPEB_FLAG;\n\n\tPSB_WVDC32(~dev_priv->vdc_irq_mask, PSB_INT_MASK_R);\n\tPSB_WVDC32(dev_priv->vdc_irq_mask, PSB_INT_ENABLE_R);\n\tgma_disable_pipestat(dev_priv, pipe, PIPE_VBLANK_INTERRUPT_ENABLE);\n\n\tspin_unlock_irqrestore(&dev_priv->irqmask_lock, irqflags);\n}\n\n \nu32 gma_crtc_get_vblank_counter(struct drm_crtc *crtc)\n{\n\tstruct drm_device *dev = crtc->dev;\n\tunsigned int pipe = crtc->index;\n\tuint32_t high_frame = PIPEAFRAMEHIGH;\n\tuint32_t low_frame = PIPEAFRAMEPIXEL;\n\tuint32_t pipeconf_reg = PIPEACONF;\n\tuint32_t reg_val = 0;\n\tuint32_t high1 = 0, high2 = 0, low = 0, count = 0;\n\n\tswitch (pipe) {\n\tcase 0:\n\t\tbreak;\n\tcase 1:\n\t\thigh_frame = PIPEBFRAMEHIGH;\n\t\tlow_frame = PIPEBFRAMEPIXEL;\n\t\tpipeconf_reg = PIPEBCONF;\n\t\tbreak;\n\tcase 2:\n\t\thigh_frame = PIPECFRAMEHIGH;\n\t\tlow_frame = PIPECFRAMEPIXEL;\n\t\tpipeconf_reg = PIPECCONF;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(dev->dev, \"%s, invalid pipe.\\n\", __func__);\n\t\treturn 0;\n\t}\n\n\tif (!gma_power_begin(dev, false))\n\t\treturn 0;\n\n\treg_val = REG_READ(pipeconf_reg);\n\n\tif (!(reg_val & PIPEACONF_ENABLE)) {\n\t\tdev_err(dev->dev, \"trying to get vblank count for disabled pipe %u\\n\",\n\t\t\tpipe);\n\t\tgoto err_gma_power_end;\n\t}\n\n\t \n\tdo {\n\t\thigh1 = ((REG_READ(high_frame) & PIPE_FRAME_HIGH_MASK) >>\n\t\t\t PIPE_FRAME_HIGH_SHIFT);\n\t\tlow =  ((REG_READ(low_frame) & PIPE_FRAME_LOW_MASK) >>\n\t\t\tPIPE_FRAME_LOW_SHIFT);\n\t\thigh2 = ((REG_READ(high_frame) & PIPE_FRAME_HIGH_MASK) >>\n\t\t\t PIPE_FRAME_HIGH_SHIFT);\n\t} while (high1 != high2);\n\n\tcount = (high1 << 8) | low;\n\nerr_gma_power_end:\n\tgma_power_end(dev);\n\n\treturn count;\n}\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}