{
  "module_name": "opregion.c",
  "hash_id": "2929e7f0f268e07f63aeb5f999d34eb65d6592f21477082dead33bc97de38269",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/gma500/opregion.c",
  "human_readable_source": " \n#include <linux/acpi.h>\n#include \"psb_drv.h\"\n#include \"psb_irq.h\"\n#include \"psb_intel_reg.h\"\n\n#define PCI_ASLE 0xe4\n#define PCI_ASLS 0xfc\n\n#define OPREGION_HEADER_OFFSET 0\n#define OPREGION_ACPI_OFFSET   0x100\n#define   ACPI_CLID 0x01ac  \n#define   ACPI_CDCK 0x01b0  \n#define OPREGION_SWSCI_OFFSET  0x200\n#define OPREGION_ASLE_OFFSET   0x300\n#define OPREGION_VBT_OFFSET    0x400\n\n#define OPREGION_SIGNATURE \"IntelGraphicsMem\"\n#define MBOX_ACPI      (1<<0)\n#define MBOX_SWSCI     (1<<1)\n#define MBOX_ASLE      (1<<2)\n\nstruct opregion_header {\n\tu8 signature[16];\n\tu32 size;\n\tu32 opregion_ver;\n\tu8 bios_ver[32];\n\tu8 vbios_ver[16];\n\tu8 driver_ver[16];\n\tu32 mboxes;\n\tu8 reserved[164];\n} __packed;\n\n \nstruct opregion_acpi {\n\tu32 drdy;\t \n\tu32 csts;\t \n\tu32 cevt;\t \n\tu8 rsvd1[20];\n\tu32 didl[8];\t \n\tu32 cpdl[8];\t \n\tu32 cadl[8];\t \n\tu32 nadl[8];\t \n\tu32 aslp;\t \n\tu32 tidx;\t \n\tu32 chpd;\t \n\tu32 clid;\t \n\tu32 cdck;\t \n\tu32 sxsw;\t \n\tu32 evts;\t \n\tu32 cnot;\t \n\tu32 nrdy;\t \n\tu8 rsvd2[60];\n} __packed;\n\n \nstruct opregion_swsci {\n\t \n} __packed;\n\n \nstruct opregion_asle {\n\tu32 ardy;\t \n\tu32 aslc;\t \n\tu32 tche;\t \n\tu32 alsi;\t \n\tu32 bclp;\t \n\tu32 pfit;\t \n\tu32 cblv;\t \n\tu16 bclm[20];\t \n\tu32 cpfm;\t \n\tu32 epfm;\t \n\tu8 plut[74];\t \n\tu32 pfmb;\t \n\tu8 rsvd[102];\n} __packed;\n\n \n#define ASLE_SET_ALS_ILLUM     (1 << 0)\n#define ASLE_SET_BACKLIGHT     (1 << 1)\n#define ASLE_SET_PFIT          (1 << 2)\n#define ASLE_SET_PWM_FREQ      (1 << 3)\n#define ASLE_REQ_MSK           0xf\n\n \n#define ASLE_ALS_ILLUM_FAILED   (1<<10)\n#define ASLE_BACKLIGHT_FAILED   (1<<12)\n#define ASLE_PFIT_FAILED        (1<<14)\n#define ASLE_PWM_FREQ_FAILED    (1<<16)\n\n \n#define ASLE_BCLP_VALID                (1<<31)\n#define ASLE_BCLP_MSK          (~(1<<31))\n\n \n#define ASLE_PFIT_VALID         (1<<31)\n#define ASLE_PFIT_CENTER (1<<0)\n#define ASLE_PFIT_STRETCH_TEXT (1<<1)\n#define ASLE_PFIT_STRETCH_GFX (1<<2)\n\n \n#define ASLE_ALS_ILLUM_FAILED\t(1<<10)\n#define ASLE_BACKLIGHT_FAILED\t(1<<12)\n#define ASLE_PFIT_FAILED\t(1<<14)\n#define ASLE_PWM_FREQ_FAILED\t(1<<16)\n\n \n#define ASLE_BCLP_VALID                (1<<31)\n#define ASLE_BCLP_MSK          (~(1<<31))\n\n \n#define ASLE_PFIT_VALID         (1<<31)\n#define ASLE_PFIT_CENTER (1<<0)\n#define ASLE_PFIT_STRETCH_TEXT (1<<1)\n#define ASLE_PFIT_STRETCH_GFX (1<<2)\n\n \n#define ASLE_PFMB_BRIGHTNESS_MASK (0xff)\n#define ASLE_PFMB_BRIGHTNESS_VALID (1<<8)\n#define ASLE_PFMB_PWM_MASK (0x7ffffe00)\n#define ASLE_PFMB_PWM_VALID (1<<31)\n\n#define ASLE_CBLV_VALID         (1<<31)\n\nstatic struct psb_intel_opregion *system_opregion;\n\nstatic u32 asle_set_backlight(struct drm_device *dev, u32 bclp)\n{\n\tstruct drm_psb_private *dev_priv = to_drm_psb_private(dev);\n\tstruct opregion_asle *asle = dev_priv->opregion.asle;\n\n\tDRM_DEBUG_DRIVER(\"asle set backlight %x\\n\", bclp);\n\n\tif (!(bclp & ASLE_BCLP_VALID))\n\t\treturn ASLE_BACKLIGHT_FAILED;\n\n\tbclp &= ASLE_BCLP_MSK;\n\tif (bclp > 255)\n\t\treturn ASLE_BACKLIGHT_FAILED;\n\n\tgma_backlight_set(dev, bclp * PSB_MAX_BRIGHTNESS / 255);\n\n\tasle->cblv = (bclp * 0x64) / 0xff | ASLE_CBLV_VALID;\n\n\treturn 0;\n}\n\nstatic void psb_intel_opregion_asle_work(struct work_struct *work)\n{\n\tstruct psb_intel_opregion *opregion =\n\t\tcontainer_of(work, struct psb_intel_opregion, asle_work);\n\tstruct drm_psb_private *dev_priv =\n\t\tcontainer_of(opregion, struct drm_psb_private, opregion);\n\tstruct opregion_asle *asle = opregion->asle;\n\tu32 asle_stat = 0;\n\tu32 asle_req;\n\n\tif (!asle)\n\t\treturn;\n\n\tasle_req = asle->aslc & ASLE_REQ_MSK;\n\tif (!asle_req) {\n\t\tDRM_DEBUG_DRIVER(\"non asle set request??\\n\");\n\t\treturn;\n\t}\n\n\tif (asle_req & ASLE_SET_BACKLIGHT)\n\t\tasle_stat |= asle_set_backlight(&dev_priv->dev, asle->bclp);\n\n\tasle->aslc = asle_stat;\n\n}\n\nvoid psb_intel_opregion_asle_intr(struct drm_device *dev)\n{\n\tstruct drm_psb_private *dev_priv = to_drm_psb_private(dev);\n\n\tif (dev_priv->opregion.asle)\n\t\tschedule_work(&dev_priv->opregion.asle_work);\n}\n\n#define ASLE_ALS_EN    (1<<0)\n#define ASLE_BLC_EN    (1<<1)\n#define ASLE_PFIT_EN   (1<<2)\n#define ASLE_PFMB_EN   (1<<3)\n\nvoid psb_intel_opregion_enable_asle(struct drm_device *dev)\n{\n\tstruct drm_psb_private *dev_priv = to_drm_psb_private(dev);\n\tstruct opregion_asle *asle = dev_priv->opregion.asle;\n\n\tif (asle && system_opregion ) {\n\t\t \n\t\tgma_enable_pipestat(dev_priv, 0, PIPE_LEGACY_BLC_EVENT_ENABLE);\n\t\tgma_enable_pipestat(dev_priv, 1, PIPE_LEGACY_BLC_EVENT_ENABLE);\n\n\t\tasle->tche = ASLE_ALS_EN | ASLE_BLC_EN | ASLE_PFIT_EN\n\t\t\t\t\t\t\t\t| ASLE_PFMB_EN;\n\t\tasle->ardy = 1;\n\t}\n}\n\n#define ACPI_EV_DISPLAY_SWITCH (1<<0)\n#define ACPI_EV_LID            (1<<1)\n#define ACPI_EV_DOCK           (1<<2)\n\n\nstatic int psb_intel_opregion_video_event(struct notifier_block *nb,\n\t\t\t\t\t  unsigned long val, void *data)\n{\n\t \n\n\tstruct opregion_acpi *acpi;\n\n\tif (!system_opregion)\n\t\treturn NOTIFY_DONE;\n\n\tacpi = system_opregion->acpi;\n\tacpi->csts = 0;\n\n\treturn NOTIFY_OK;\n}\n\nstatic struct notifier_block psb_intel_opregion_notifier = {\n\t.notifier_call = psb_intel_opregion_video_event,\n};\n\nvoid psb_intel_opregion_init(struct drm_device *dev)\n{\n\tstruct drm_psb_private *dev_priv = to_drm_psb_private(dev);\n\tstruct psb_intel_opregion *opregion = &dev_priv->opregion;\n\n\tif (!opregion->header)\n\t\treturn;\n\n\tif (opregion->acpi) {\n\t\t \n\t\topregion->acpi->csts = 0;\n\t\topregion->acpi->drdy = 1;\n\n\t\tsystem_opregion = opregion;\n\t\tregister_acpi_notifier(&psb_intel_opregion_notifier);\n\t}\n}\n\nvoid psb_intel_opregion_fini(struct drm_device *dev)\n{\n\tstruct drm_psb_private *dev_priv = to_drm_psb_private(dev);\n\tstruct psb_intel_opregion *opregion = &dev_priv->opregion;\n\n\tif (!opregion->header)\n\t\treturn;\n\n\tif (opregion->acpi) {\n\t\topregion->acpi->drdy = 0;\n\n\t\tsystem_opregion = NULL;\n\t\tunregister_acpi_notifier(&psb_intel_opregion_notifier);\n\t}\n\n\tcancel_work_sync(&opregion->asle_work);\n\n\t \n\tiounmap(opregion->header);\n\topregion->header = NULL;\n\topregion->acpi = NULL;\n\topregion->swsci = NULL;\n\topregion->asle = NULL;\n\topregion->vbt = NULL;\n}\n\nint psb_intel_opregion_setup(struct drm_device *dev)\n{\n\tstruct drm_psb_private *dev_priv = to_drm_psb_private(dev);\n\tstruct pci_dev *pdev = to_pci_dev(dev->dev);\n\tstruct psb_intel_opregion *opregion = &dev_priv->opregion;\n\tu32 opregion_phy, mboxes;\n\tvoid __iomem *base;\n\tint err = 0;\n\n\tpci_read_config_dword(pdev, PCI_ASLS, &opregion_phy);\n\tif (opregion_phy == 0) {\n\t\tDRM_DEBUG_DRIVER(\"ACPI Opregion not supported\\n\");\n\t\treturn -ENOTSUPP;\n\t}\n\n\tINIT_WORK(&opregion->asle_work, psb_intel_opregion_asle_work);\n\n\tDRM_DEBUG(\"OpRegion detected at 0x%8x\\n\", opregion_phy);\n\tbase = acpi_os_ioremap(opregion_phy, 8*1024);\n\tif (!base)\n\t\treturn -ENOMEM;\n\n\tif (memcmp(base, OPREGION_SIGNATURE, 16)) {\n\t\tDRM_DEBUG_DRIVER(\"opregion signature mismatch\\n\");\n\t\terr = -EINVAL;\n\t\tgoto err_out;\n\t}\n\n\topregion->header = base;\n\topregion->vbt = base + OPREGION_VBT_OFFSET;\n\n\topregion->lid_state = base + ACPI_CLID;\n\n\tmboxes = opregion->header->mboxes;\n\tif (mboxes & MBOX_ACPI) {\n\t\tDRM_DEBUG_DRIVER(\"Public ACPI methods supported\\n\");\n\t\topregion->acpi = base + OPREGION_ACPI_OFFSET;\n\t}\n\n\tif (mboxes & MBOX_ASLE) {\n\t\tDRM_DEBUG_DRIVER(\"ASLE supported\\n\");\n\t\topregion->asle = base + OPREGION_ASLE_OFFSET;\n\t}\n\n\treturn 0;\n\nerr_out:\n\tiounmap(base);\n\treturn err;\n}\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}