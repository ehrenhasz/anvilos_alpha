{
  "module_name": "oaktrail_lvds.c",
  "hash_id": "0ec16c40abe268b0bd0173b66fc79516551dc0fba0867540bfc8e8d4a53e5b80",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/gma500/oaktrail_lvds.c",
  "human_readable_source": "\n \n\n#include <linux/i2c.h>\n#include <linux/pm_runtime.h>\n\n#include <asm/intel-mid.h>\n\n#include <drm/drm_edid.h>\n#include <drm/drm_modeset_helper_vtables.h>\n#include <drm/drm_simple_kms_helper.h>\n\n#include \"intel_bios.h\"\n#include \"power.h\"\n#include \"psb_drv.h\"\n#include \"psb_intel_drv.h\"\n#include \"psb_intel_reg.h\"\n\n \n \n \n#define MRST_BLC_MAX_PWM_REG_FREQ\t    0xFFFF\n#define BRIGHTNESS_MAX_LEVEL 100\n\n \nstatic void oaktrail_lvds_set_power(struct drm_device *dev,\n\t\t\t\tstruct gma_encoder *gma_encoder,\n\t\t\t\tbool on)\n{\n\tu32 pp_status;\n\tstruct drm_psb_private *dev_priv = to_drm_psb_private(dev);\n\n\tif (!gma_power_begin(dev, true))\n\t\treturn;\n\n\tif (on) {\n\t\tREG_WRITE(PP_CONTROL, REG_READ(PP_CONTROL) |\n\t\t\t  POWER_TARGET_ON);\n\t\tdo {\n\t\t\tpp_status = REG_READ(PP_STATUS);\n\t\t} while ((pp_status & (PP_ON | PP_READY)) == PP_READY);\n\t\tdev_priv->is_lvds_on = true;\n\t\tif (dev_priv->ops->lvds_bl_power)\n\t\t\tdev_priv->ops->lvds_bl_power(dev, true);\n\t} else {\n\t\tif (dev_priv->ops->lvds_bl_power)\n\t\t\tdev_priv->ops->lvds_bl_power(dev, false);\n\t\tREG_WRITE(PP_CONTROL, REG_READ(PP_CONTROL) &\n\t\t\t  ~POWER_TARGET_ON);\n\t\tdo {\n\t\t\tpp_status = REG_READ(PP_STATUS);\n\t\t} while (pp_status & PP_ON);\n\t\tdev_priv->is_lvds_on = false;\n\t}\n\tgma_power_end(dev);\n}\n\nstatic void oaktrail_lvds_dpms(struct drm_encoder *encoder, int mode)\n{\n\tstruct drm_device *dev = encoder->dev;\n\tstruct gma_encoder *gma_encoder = to_gma_encoder(encoder);\n\n\tif (mode == DRM_MODE_DPMS_ON)\n\t\toaktrail_lvds_set_power(dev, gma_encoder, true);\n\telse\n\t\toaktrail_lvds_set_power(dev, gma_encoder, false);\n\n\t \n}\n\nstatic void oaktrail_lvds_mode_set(struct drm_encoder *encoder,\n\t\t\t       struct drm_display_mode *mode,\n\t\t\t       struct drm_display_mode *adjusted_mode)\n{\n\tstruct drm_device *dev = encoder->dev;\n\tstruct drm_psb_private *dev_priv = to_drm_psb_private(dev);\n\tstruct psb_intel_mode_device *mode_dev = &dev_priv->mode_dev;\n\tstruct drm_connector_list_iter conn_iter;\n\tstruct drm_connector *connector = NULL;\n\tstruct drm_crtc *crtc = encoder->crtc;\n\tu32 lvds_port;\n\tuint64_t v = DRM_MODE_SCALE_FULLSCREEN;\n\n\tif (!gma_power_begin(dev, true))\n\t\treturn;\n\n\t \n\tlvds_port = (REG_READ(LVDS) &\n\t\t    (~LVDS_PIPEB_SELECT)) |\n\t\t    LVDS_PORT_EN |\n\t\t    LVDS_BORDER_EN;\n\n\t \n\tif (mode_dev->panel_wants_dither || dev_priv->lvds_dither)\n\t\tlvds_port |= MRST_PANEL_8TO6_DITHER_ENABLE;\n\n\tREG_WRITE(LVDS, lvds_port);\n\n\t \n\tdrm_connector_list_iter_begin(dev, &conn_iter);\n\tdrm_for_each_connector_iter(connector, &conn_iter) {\n\t\tif (connector->encoder && connector->encoder->crtc == crtc)\n\t\t\tbreak;\n\t}\n\n\tif (!connector) {\n\t\tdrm_connector_list_iter_end(&conn_iter);\n\t\tDRM_ERROR(\"Couldn't find connector when setting mode\");\n\t\tgma_power_end(dev);\n\t\treturn;\n\t}\n\n\tdrm_object_property_get_value( &connector->base,\n\t\tdev->mode_config.scaling_mode_property, &v);\n\tdrm_connector_list_iter_end(&conn_iter);\n\n\tif (v == DRM_MODE_SCALE_NO_SCALE)\n\t\tREG_WRITE(PFIT_CONTROL, 0);\n\telse if (v == DRM_MODE_SCALE_ASPECT) {\n\t\tif ((mode->vdisplay != adjusted_mode->crtc_vdisplay) ||\n\t\t    (mode->hdisplay != adjusted_mode->crtc_hdisplay)) {\n\t\t\tif ((adjusted_mode->crtc_hdisplay * mode->vdisplay) ==\n\t\t\t    (mode->hdisplay * adjusted_mode->crtc_vdisplay))\n\t\t\t\tREG_WRITE(PFIT_CONTROL, PFIT_ENABLE);\n\t\t\telse if ((adjusted_mode->crtc_hdisplay *\n\t\t\t\tmode->vdisplay) > (mode->hdisplay *\n\t\t\t\tadjusted_mode->crtc_vdisplay))\n\t\t\t\tREG_WRITE(PFIT_CONTROL, PFIT_ENABLE |\n\t\t\t\t\t  PFIT_SCALING_MODE_PILLARBOX);\n\t\t\telse\n\t\t\t\tREG_WRITE(PFIT_CONTROL, PFIT_ENABLE |\n\t\t\t\t\t  PFIT_SCALING_MODE_LETTERBOX);\n\t\t} else\n\t\t\tREG_WRITE(PFIT_CONTROL, PFIT_ENABLE);\n\t} else  \n\t\tREG_WRITE(PFIT_CONTROL, PFIT_ENABLE);\n\n\tgma_power_end(dev);\n}\n\nstatic void oaktrail_lvds_prepare(struct drm_encoder *encoder)\n{\n\tstruct drm_device *dev = encoder->dev;\n\tstruct drm_psb_private *dev_priv = to_drm_psb_private(dev);\n\tstruct gma_encoder *gma_encoder = to_gma_encoder(encoder);\n\tstruct psb_intel_mode_device *mode_dev = &dev_priv->mode_dev;\n\n\tif (!gma_power_begin(dev, true))\n\t\treturn;\n\n\tmode_dev->saveBLC_PWM_CTL = REG_READ(BLC_PWM_CTL);\n\tmode_dev->backlight_duty_cycle = (mode_dev->saveBLC_PWM_CTL &\n\t\t\t\t\t  BACKLIGHT_DUTY_CYCLE_MASK);\n\toaktrail_lvds_set_power(dev, gma_encoder, false);\n\tgma_power_end(dev);\n}\n\nstatic u32 oaktrail_lvds_get_max_backlight(struct drm_device *dev)\n{\n\tstruct drm_psb_private *dev_priv = to_drm_psb_private(dev);\n\tu32 ret;\n\n\tif (gma_power_begin(dev, false)) {\n\t\tret = ((REG_READ(BLC_PWM_CTL) &\n\t\t\t  BACKLIGHT_MODULATION_FREQ_MASK) >>\n\t\t\t  BACKLIGHT_MODULATION_FREQ_SHIFT) * 2;\n\n\t\tgma_power_end(dev);\n\t} else\n\t\tret = ((dev_priv->regs.saveBLC_PWM_CTL &\n\t\t\t  BACKLIGHT_MODULATION_FREQ_MASK) >>\n\t\t\t  BACKLIGHT_MODULATION_FREQ_SHIFT) * 2;\n\n\treturn ret;\n}\n\nstatic void oaktrail_lvds_commit(struct drm_encoder *encoder)\n{\n\tstruct drm_device *dev = encoder->dev;\n\tstruct drm_psb_private *dev_priv = to_drm_psb_private(dev);\n\tstruct gma_encoder *gma_encoder = to_gma_encoder(encoder);\n\tstruct psb_intel_mode_device *mode_dev = &dev_priv->mode_dev;\n\n\tif (mode_dev->backlight_duty_cycle == 0)\n\t\tmode_dev->backlight_duty_cycle =\n\t\t\t\t\toaktrail_lvds_get_max_backlight(dev);\n\toaktrail_lvds_set_power(dev, gma_encoder, true);\n}\n\nstatic const struct drm_encoder_helper_funcs oaktrail_lvds_helper_funcs = {\n\t.dpms = oaktrail_lvds_dpms,\n\t.mode_fixup = psb_intel_lvds_mode_fixup,\n\t.prepare = oaktrail_lvds_prepare,\n\t.mode_set = oaktrail_lvds_mode_set,\n\t.commit = oaktrail_lvds_commit,\n};\n\n \n\nstatic void oaktrail_lvds_get_configuration_mode(struct drm_device *dev,\n\t\t\t\t\tstruct psb_intel_mode_device *mode_dev)\n{\n\tstruct drm_display_mode *mode = NULL;\n\tstruct drm_psb_private *dev_priv = to_drm_psb_private(dev);\n\tstruct oaktrail_timing_info *ti = &dev_priv->gct_data.DTD;\n\n\tmode_dev->panel_fixed_mode = NULL;\n\n\t \n\tif (dev_priv->has_gct) {\n\t\tmode = kzalloc(sizeof(*mode), GFP_KERNEL);\n\t\tif (!mode)\n\t\t\treturn;\n\n\t\tmode->hdisplay = (ti->hactive_hi << 8) | ti->hactive_lo;\n\t\tmode->vdisplay = (ti->vactive_hi << 8) | ti->vactive_lo;\n\t\tmode->hsync_start = mode->hdisplay + \\\n\t\t\t\t((ti->hsync_offset_hi << 8) | \\\n\t\t\t\tti->hsync_offset_lo);\n\t\tmode->hsync_end = mode->hsync_start + \\\n\t\t\t\t((ti->hsync_pulse_width_hi << 8) | \\\n\t\t\t\tti->hsync_pulse_width_lo);\n\t\tmode->htotal = mode->hdisplay + ((ti->hblank_hi << 8) | \\\n\t\t\t\t\t\t\tti->hblank_lo);\n\t\tmode->vsync_start = \\\n\t\t\tmode->vdisplay + ((ti->vsync_offset_hi << 4) | \\\n\t\t\t\t\t\tti->vsync_offset_lo);\n\t\tmode->vsync_end = \\\n\t\t\tmode->vsync_start + ((ti->vsync_pulse_width_hi << 4) | \\\n\t\t\t\t\t\tti->vsync_pulse_width_lo);\n\t\tmode->vtotal = mode->vdisplay + \\\n\t\t\t\t((ti->vblank_hi << 8) | ti->vblank_lo);\n\t\tmode->clock = ti->pixel_clock * 10;\n#if 0\n\t\tpr_info(\"hdisplay is %d\\n\", mode->hdisplay);\n\t\tpr_info(\"vdisplay is %d\\n\", mode->vdisplay);\n\t\tpr_info(\"HSS is %d\\n\", mode->hsync_start);\n\t\tpr_info(\"HSE is %d\\n\", mode->hsync_end);\n\t\tpr_info(\"htotal is %d\\n\", mode->htotal);\n\t\tpr_info(\"VSS is %d\\n\", mode->vsync_start);\n\t\tpr_info(\"VSE is %d\\n\", mode->vsync_end);\n\t\tpr_info(\"vtotal is %d\\n\", mode->vtotal);\n\t\tpr_info(\"clock is %d\\n\", mode->clock);\n#endif\n\t\tmode_dev->panel_fixed_mode = mode;\n\t}\n\n\t \n\tif (mode_dev->panel_fixed_mode == NULL && mode_dev->vbt_mode)\n\t\tmode_dev->panel_fixed_mode = drm_mode_duplicate(dev,\n\t\t\t\t\t\tmode_dev->vbt_mode);\n\n\t \n\tif (mode_dev->panel_fixed_mode == NULL)\n\t\tif (dev_priv->lfp_lvds_vbt_mode)\n\t\t\tmode_dev->panel_fixed_mode =\n\t\t\t\tdrm_mode_duplicate(dev,\n\t\t\t\t\tdev_priv->lfp_lvds_vbt_mode);\n\n\t \n\tif (mode_dev->panel_fixed_mode == NULL)\n\t\treturn;\n\n\tdrm_mode_set_name(mode_dev->panel_fixed_mode);\n\tdrm_mode_set_crtcinfo(mode_dev->panel_fixed_mode, 0);\n}\n\n \nvoid oaktrail_lvds_init(struct drm_device *dev,\n\t\t    struct psb_intel_mode_device *mode_dev)\n{\n\tstruct gma_encoder *gma_encoder;\n\tstruct gma_connector *gma_connector;\n\tstruct gma_i2c_chan *ddc_bus;\n\tstruct drm_connector *connector;\n\tstruct drm_encoder *encoder;\n\tstruct drm_psb_private *dev_priv = to_drm_psb_private(dev);\n\tstruct edid *edid;\n\tstruct i2c_adapter *i2c_adap;\n\tstruct drm_display_mode *scan;\t \n\tint ret;\n\n\tgma_encoder = kzalloc(sizeof(struct gma_encoder), GFP_KERNEL);\n\tif (!gma_encoder)\n\t\treturn;\n\n\tgma_connector = kzalloc(sizeof(struct gma_connector), GFP_KERNEL);\n\tif (!gma_connector)\n\t\tgoto err_free_encoder;\n\n\tconnector = &gma_connector->base;\n\tencoder = &gma_encoder->base;\n\tdev_priv->is_lvds_on = true;\n\tret = drm_connector_init(dev, connector,\n\t\t\t\t &psb_intel_lvds_connector_funcs,\n\t\t\t\t DRM_MODE_CONNECTOR_LVDS);\n\tif (ret)\n\t\tgoto err_free_connector;\n\n\tret = drm_simple_encoder_init(dev, encoder, DRM_MODE_ENCODER_LVDS);\n\tif (ret)\n\t\tgoto err_connector_cleanup;\n\n\tgma_connector_attach_encoder(gma_connector, gma_encoder);\n\tgma_encoder->type = INTEL_OUTPUT_LVDS;\n\n\tdrm_encoder_helper_add(encoder, &oaktrail_lvds_helper_funcs);\n\tdrm_connector_helper_add(connector,\n\t\t\t\t &psb_intel_lvds_connector_helper_funcs);\n\tconnector->display_info.subpixel_order = SubPixelHorizontalRGB;\n\tconnector->interlace_allowed = false;\n\tconnector->doublescan_allowed = false;\n\n\tdrm_object_attach_property(&connector->base,\n\t\t\t\t\tdev->mode_config.scaling_mode_property,\n\t\t\t\t\tDRM_MODE_SCALE_FULLSCREEN);\n\tdrm_object_attach_property(&connector->base,\n\t\t\t\t\tdev_priv->backlight_property,\n\t\t\t\t\tBRIGHTNESS_MAX_LEVEL);\n\n\tmode_dev->panel_wants_dither = false;\n\tif (dev_priv->has_gct)\n\t\tmode_dev->panel_wants_dither = (dev_priv->gct_data.\n\t\t\tPanel_Port_Control & MRST_PANEL_8TO6_DITHER_ENABLE);\n        if (dev_priv->lvds_dither)\n                mode_dev->panel_wants_dither = 1;\n\n\t \n\n\tedid = NULL;\n\tmutex_lock(&dev->mode_config.mutex);\n\n\ti2c_adap = i2c_get_adapter(dev_priv->ops->i2c_bus);\n\tif (i2c_adap)\n\t\tedid = drm_get_edid(connector, i2c_adap);\n\n\tif (edid == NULL && dev_priv->lpc_gpio_base) {\n\t\tddc_bus = oaktrail_lvds_i2c_init(dev);\n\t\tif (!IS_ERR(ddc_bus)) {\n\t\t\ti2c_adap = &ddc_bus->base;\n\t\t\tedid = drm_get_edid(connector, i2c_adap);\n\t\t}\n\t}\n\n\t \n\tconnector->ddc = i2c_adap;\n\n\t \n\tif (edid) {\n\t\tdrm_connector_update_edid_property(connector, edid);\n\t\tdrm_add_edid_modes(connector, edid);\n\t\tkfree(edid);\n\n\t\tlist_for_each_entry(scan, &connector->probed_modes, head) {\n\t\t\tif (scan->type & DRM_MODE_TYPE_PREFERRED) {\n\t\t\t\tmode_dev->panel_fixed_mode =\n\t\t\t\t    drm_mode_duplicate(dev, scan);\n\t\t\t\tgoto out;\t \n\t\t\t}\n\t\t}\n\t} else\n\t\tdev_err(dev->dev, \"No ddc adapter available!\\n\");\n\t \n\toaktrail_lvds_get_configuration_mode(dev, mode_dev);\n\n\tif (mode_dev->panel_fixed_mode) {\n\t\tmode_dev->panel_fixed_mode->type |= DRM_MODE_TYPE_PREFERRED;\n\t\tgoto out;\t \n\t}\n\n\t \n\tif (!mode_dev->panel_fixed_mode) {\n\t\tdev_err(dev->dev, \"Found no modes on the lvds, ignoring the LVDS\\n\");\n\t\tgoto err_unlock;\n\t}\n\nout:\n\tmutex_unlock(&dev->mode_config.mutex);\n\n\treturn;\n\nerr_unlock:\n\tmutex_unlock(&dev->mode_config.mutex);\n\tgma_i2c_destroy(to_gma_i2c_chan(connector->ddc));\n\tdrm_encoder_cleanup(encoder);\nerr_connector_cleanup:\n\tdrm_connector_cleanup(connector);\nerr_free_connector:\n\tkfree(gma_connector);\nerr_free_encoder:\n\tkfree(gma_encoder);\n}\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}