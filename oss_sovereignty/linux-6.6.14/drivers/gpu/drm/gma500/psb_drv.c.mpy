{
  "module_name": "psb_drv.c",
  "hash_id": "817fe22d05dc09328118f4749053507ade5afe6a30ae46e8945b2967f120ab86",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/gma500/psb_drv.c",
  "human_readable_source": "\n \n\n#include <linux/aperture.h>\n#include <linux/cpu.h>\n#include <linux/module.h>\n#include <linux/notifier.h>\n#include <linux/pm_runtime.h>\n#include <linux/spinlock.h>\n#include <linux/delay.h>\n\n#include <asm/set_memory.h>\n\n#include <acpi/video.h>\n\n#include <drm/drm.h>\n#include <drm/drm_drv.h>\n#include <drm/drm_file.h>\n#include <drm/drm_ioctl.h>\n#include <drm/drm_pciids.h>\n#include <drm/drm_vblank.h>\n\n#include \"framebuffer.h\"\n#include \"gem.h\"\n#include \"intel_bios.h\"\n#include \"mid_bios.h\"\n#include \"power.h\"\n#include \"psb_drv.h\"\n#include \"psb_intel_reg.h\"\n#include \"psb_irq.h\"\n#include \"psb_reg.h\"\n\nstatic const struct drm_driver driver;\nstatic int psb_pci_probe(struct pci_dev *pdev, const struct pci_device_id *ent);\n\n \nstatic const struct pci_device_id pciidlist[] = {\n\t \n\t{ 0x8086, 0x8108, PCI_ANY_ID, PCI_ANY_ID, 0, 0, (long) &psb_chip_ops },\n\t{ 0x8086, 0x8109, PCI_ANY_ID, PCI_ANY_ID, 0, 0, (long) &psb_chip_ops },\n\t \n\t{ 0x8086, 0x4100, PCI_ANY_ID, PCI_ANY_ID, 0, 0, (long) &oaktrail_chip_ops },\n\t{ 0x8086, 0x4101, PCI_ANY_ID, PCI_ANY_ID, 0, 0, (long) &oaktrail_chip_ops },\n\t{ 0x8086, 0x4102, PCI_ANY_ID, PCI_ANY_ID, 0, 0, (long) &oaktrail_chip_ops },\n\t{ 0x8086, 0x4103, PCI_ANY_ID, PCI_ANY_ID, 0, 0, (long) &oaktrail_chip_ops },\n\t{ 0x8086, 0x4104, PCI_ANY_ID, PCI_ANY_ID, 0, 0, (long) &oaktrail_chip_ops },\n\t{ 0x8086, 0x4105, PCI_ANY_ID, PCI_ANY_ID, 0, 0, (long) &oaktrail_chip_ops },\n\t{ 0x8086, 0x4106, PCI_ANY_ID, PCI_ANY_ID, 0, 0, (long) &oaktrail_chip_ops },\n\t{ 0x8086, 0x4107, PCI_ANY_ID, PCI_ANY_ID, 0, 0, (long) &oaktrail_chip_ops },\n\t{ 0x8086, 0x4108, PCI_ANY_ID, PCI_ANY_ID, 0, 0, (long) &oaktrail_chip_ops },\n\t \n\t{ 0x8086, 0x0be0, PCI_ANY_ID, PCI_ANY_ID, 0, 0, (long) &cdv_chip_ops },\n\t{ 0x8086, 0x0be1, PCI_ANY_ID, PCI_ANY_ID, 0, 0, (long) &cdv_chip_ops },\n\t{ 0x8086, 0x0be2, PCI_ANY_ID, PCI_ANY_ID, 0, 0, (long) &cdv_chip_ops },\n\t{ 0x8086, 0x0be3, PCI_ANY_ID, PCI_ANY_ID, 0, 0, (long) &cdv_chip_ops },\n\t{ 0x8086, 0x0be4, PCI_ANY_ID, PCI_ANY_ID, 0, 0, (long) &cdv_chip_ops },\n\t{ 0x8086, 0x0be5, PCI_ANY_ID, PCI_ANY_ID, 0, 0, (long) &cdv_chip_ops },\n\t{ 0x8086, 0x0be6, PCI_ANY_ID, PCI_ANY_ID, 0, 0, (long) &cdv_chip_ops },\n\t{ 0x8086, 0x0be7, PCI_ANY_ID, PCI_ANY_ID, 0, 0, (long) &cdv_chip_ops },\n\t{ 0x8086, 0x0be8, PCI_ANY_ID, PCI_ANY_ID, 0, 0, (long) &cdv_chip_ops },\n\t{ 0x8086, 0x0be9, PCI_ANY_ID, PCI_ANY_ID, 0, 0, (long) &cdv_chip_ops },\n\t{ 0x8086, 0x0bea, PCI_ANY_ID, PCI_ANY_ID, 0, 0, (long) &cdv_chip_ops },\n\t{ 0x8086, 0x0beb, PCI_ANY_ID, PCI_ANY_ID, 0, 0, (long) &cdv_chip_ops },\n\t{ 0x8086, 0x0bec, PCI_ANY_ID, PCI_ANY_ID, 0, 0, (long) &cdv_chip_ops },\n\t{ 0x8086, 0x0bed, PCI_ANY_ID, PCI_ANY_ID, 0, 0, (long) &cdv_chip_ops },\n\t{ 0x8086, 0x0bee, PCI_ANY_ID, PCI_ANY_ID, 0, 0, (long) &cdv_chip_ops },\n\t{ 0x8086, 0x0bef, PCI_ANY_ID, PCI_ANY_ID, 0, 0, (long) &cdv_chip_ops },\n\t{ 0, }\n};\nMODULE_DEVICE_TABLE(pci, pciidlist);\n\n \nstatic const struct drm_ioctl_desc psb_ioctls[] = {\n};\n\n \nstatic void psb_spank(struct drm_psb_private *dev_priv)\n{\n\tPSB_WSGX32(_PSB_CS_RESET_BIF_RESET | _PSB_CS_RESET_DPM_RESET |\n\t\t_PSB_CS_RESET_TA_RESET | _PSB_CS_RESET_USE_RESET |\n\t\t_PSB_CS_RESET_ISP_RESET | _PSB_CS_RESET_TSP_RESET |\n\t\t_PSB_CS_RESET_TWOD_RESET, PSB_CR_SOFT_RESET);\n\tPSB_RSGX32(PSB_CR_SOFT_RESET);\n\n\tmsleep(1);\n\n\tPSB_WSGX32(0, PSB_CR_SOFT_RESET);\n\twmb();\n\tPSB_WSGX32(PSB_RSGX32(PSB_CR_BIF_CTRL) | _PSB_CB_CTRL_CLEAR_FAULT,\n\t\t   PSB_CR_BIF_CTRL);\n\twmb();\n\t(void) PSB_RSGX32(PSB_CR_BIF_CTRL);\n\n\tmsleep(1);\n\tPSB_WSGX32(PSB_RSGX32(PSB_CR_BIF_CTRL) & ~_PSB_CB_CTRL_CLEAR_FAULT,\n\t\t   PSB_CR_BIF_CTRL);\n\t(void) PSB_RSGX32(PSB_CR_BIF_CTRL);\n\tPSB_WSGX32(dev_priv->gtt.gatt_start, PSB_CR_BIF_TWOD_REQ_BASE);\n}\n\nstatic int psb_do_init(struct drm_device *dev)\n{\n\tstruct drm_psb_private *dev_priv = to_drm_psb_private(dev);\n\tstruct psb_gtt *pg = &dev_priv->gtt;\n\n\tuint32_t stolen_gtt;\n\n\tif (pg->mmu_gatt_start & 0x0FFFFFFF) {\n\t\tdev_err(dev->dev, \"Gatt must be 256M aligned. This is a bug.\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tstolen_gtt = (pg->stolen_size >> PAGE_SHIFT) * 4;\n\tstolen_gtt = (stolen_gtt + PAGE_SIZE - 1) >> PAGE_SHIFT;\n\tstolen_gtt = (stolen_gtt < pg->gtt_pages) ? stolen_gtt : pg->gtt_pages;\n\n\tdev_priv->gatt_free_offset = pg->mmu_gatt_start +\n\t    (stolen_gtt << PAGE_SHIFT) * 1024;\n\n\tspin_lock_init(&dev_priv->irqmask_lock);\n\n\tPSB_WSGX32(0x00000000, PSB_CR_BIF_BANK0);\n\tPSB_WSGX32(0x00000000, PSB_CR_BIF_BANK1);\n\tPSB_RSGX32(PSB_CR_BIF_BANK1);\n\n\t \n\tPSB_WSGX32((PSB_RSGX32(PSB_CR_BIF_CTRL) & ~_PSB_MMU_ER_MASK),\n\t\t   PSB_CR_BIF_CTRL);\n\tPSB_RSGX32(PSB_CR_BIF_CTRL);\n\n\tpsb_spank(dev_priv);\n\n\t \n\tPSB_WSGX32(pg->gatt_start, PSB_CR_BIF_TWOD_REQ_BASE);\n\tPSB_RSGX32(PSB_CR_BIF_TWOD_REQ_BASE);  \n\n\treturn 0;\n}\n\nstatic void psb_driver_unload(struct drm_device *dev)\n{\n\tstruct drm_psb_private *dev_priv = to_drm_psb_private(dev);\n\n\t \n\n\tgma_backlight_exit(dev);\n\tpsb_modeset_cleanup(dev);\n\n\tgma_irq_uninstall(dev);\n\n\tif (dev_priv->ops->chip_teardown)\n\t\tdev_priv->ops->chip_teardown(dev);\n\n\tpsb_intel_opregion_fini(dev);\n\n\tif (dev_priv->pf_pd) {\n\t\tpsb_mmu_free_pagedir(dev_priv->pf_pd);\n\t\tdev_priv->pf_pd = NULL;\n\t}\n\tif (dev_priv->mmu) {\n\t\tstruct psb_gtt *pg = &dev_priv->gtt;\n\n\t\tpsb_mmu_remove_pfn_sequence(\n\t\t\tpsb_mmu_get_default_pd\n\t\t\t(dev_priv->mmu),\n\t\t\tpg->mmu_gatt_start,\n\t\t\tdev_priv->vram_stolen_size >> PAGE_SHIFT);\n\t\tpsb_mmu_driver_takedown(dev_priv->mmu);\n\t\tdev_priv->mmu = NULL;\n\t}\n\tpsb_gem_mm_fini(dev);\n\tpsb_gtt_fini(dev);\n\tif (dev_priv->scratch_page) {\n\t\tset_pages_wb(dev_priv->scratch_page, 1);\n\t\t__free_page(dev_priv->scratch_page);\n\t\tdev_priv->scratch_page = NULL;\n\t}\n\tif (dev_priv->vdc_reg) {\n\t\tiounmap(dev_priv->vdc_reg);\n\t\tdev_priv->vdc_reg = NULL;\n\t}\n\tif (dev_priv->sgx_reg) {\n\t\tiounmap(dev_priv->sgx_reg);\n\t\tdev_priv->sgx_reg = NULL;\n\t}\n\tif (dev_priv->aux_reg) {\n\t\tiounmap(dev_priv->aux_reg);\n\t\tdev_priv->aux_reg = NULL;\n\t}\n\tpci_dev_put(dev_priv->aux_pdev);\n\tpci_dev_put(dev_priv->lpc_pdev);\n\n\t \n\tpsb_intel_destroy_bios(dev);\n\n\tgma_power_uninit(dev);\n}\n\nstatic void psb_device_release(void *data)\n{\n\tstruct drm_device *dev = data;\n\n\tpsb_driver_unload(dev);\n}\n\nstatic int psb_driver_load(struct drm_device *dev, unsigned long flags)\n{\n\tstruct pci_dev *pdev = to_pci_dev(dev->dev);\n\tstruct drm_psb_private *dev_priv = to_drm_psb_private(dev);\n\tunsigned long resource_start, resource_len;\n\tunsigned long irqflags;\n\tstruct drm_connector_list_iter conn_iter;\n\tstruct drm_connector *connector;\n\tstruct gma_encoder *gma_encoder;\n\tstruct psb_gtt *pg;\n\tint ret = -ENOMEM;\n\n\t \n\n\tdev_priv->ops = (struct psb_ops *)flags;\n\n\tpg = &dev_priv->gtt;\n\n\tpci_set_master(pdev);\n\n\tdev_priv->num_pipe = dev_priv->ops->pipes;\n\n\tresource_start = pci_resource_start(pdev, PSB_MMIO_RESOURCE);\n\n\tdev_priv->vdc_reg =\n\t    ioremap(resource_start + PSB_VDC_OFFSET, PSB_VDC_SIZE);\n\tif (!dev_priv->vdc_reg)\n\t\tgoto out_err;\n\n\tdev_priv->sgx_reg = ioremap(resource_start + dev_priv->ops->sgx_offset,\n\t\t\t\t\t\t\tPSB_SGX_SIZE);\n\tif (!dev_priv->sgx_reg)\n\t\tgoto out_err;\n\n\tif (IS_MRST(dev)) {\n\t\tint domain = pci_domain_nr(pdev->bus);\n\n\t\tdev_priv->aux_pdev =\n\t\t\tpci_get_domain_bus_and_slot(domain, 0,\n\t\t\t\t\t\t    PCI_DEVFN(3, 0));\n\n\t\tif (dev_priv->aux_pdev) {\n\t\t\tresource_start = pci_resource_start(dev_priv->aux_pdev,\n\t\t\t\t\t\t\t    PSB_AUX_RESOURCE);\n\t\t\tresource_len = pci_resource_len(dev_priv->aux_pdev,\n\t\t\t\t\t\t\tPSB_AUX_RESOURCE);\n\t\t\tdev_priv->aux_reg = ioremap(resource_start,\n\t\t\t\t\t\t\t    resource_len);\n\t\t\tif (!dev_priv->aux_reg)\n\t\t\t\tgoto out_err;\n\n\t\t\tDRM_DEBUG_KMS(\"Found aux vdc\");\n\t\t} else {\n\t\t\t \n\t\t\tdev_priv->aux_reg = dev_priv->vdc_reg;\n\t\t\tDRM_DEBUG_KMS(\"Couldn't find aux pci device\");\n\t\t}\n\t\tdev_priv->gmbus_reg = dev_priv->aux_reg;\n\n\t\tdev_priv->lpc_pdev =\n\t\t\tpci_get_domain_bus_and_slot(domain, 0,\n\t\t\t\t\t\t    PCI_DEVFN(31, 0));\n\t\tif (dev_priv->lpc_pdev) {\n\t\t\tpci_read_config_word(dev_priv->lpc_pdev, PSB_LPC_GBA,\n\t\t\t\t&dev_priv->lpc_gpio_base);\n\t\t\tpci_write_config_dword(dev_priv->lpc_pdev, PSB_LPC_GBA,\n\t\t\t\t(u32)dev_priv->lpc_gpio_base | (1L<<31));\n\t\t\tpci_read_config_word(dev_priv->lpc_pdev, PSB_LPC_GBA,\n\t\t\t\t&dev_priv->lpc_gpio_base);\n\t\t\tdev_priv->lpc_gpio_base &= 0xffc0;\n\t\t\tif (dev_priv->lpc_gpio_base)\n\t\t\t\tDRM_DEBUG_KMS(\"Found LPC GPIO at 0x%04x\\n\",\n\t\t\t\t\t\tdev_priv->lpc_gpio_base);\n\t\t\telse {\n\t\t\t\tpci_dev_put(dev_priv->lpc_pdev);\n\t\t\t\tdev_priv->lpc_pdev = NULL;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tdev_priv->gmbus_reg = dev_priv->vdc_reg;\n\t}\n\n\tpsb_intel_opregion_setup(dev);\n\n\tret = dev_priv->ops->chip_setup(dev);\n\tif (ret)\n\t\tgoto out_err;\n\n\t \n\tgma_power_init(dev);\n\n\tret = -ENOMEM;\n\n\tdev_priv->scratch_page = alloc_page(GFP_DMA32 | __GFP_ZERO);\n\tif (!dev_priv->scratch_page)\n\t\tgoto out_err;\n\n\tset_pages_uc(dev_priv->scratch_page, 1);\n\n\tret = psb_gtt_init(dev);\n\tif (ret)\n\t\tgoto out_err;\n\tret = psb_gem_mm_init(dev);\n\tif (ret)\n\t\tgoto out_err;\n\n\tret = -ENOMEM;\n\n\tdev_priv->mmu = psb_mmu_driver_init(dev, 1, 0, NULL);\n\tif (!dev_priv->mmu)\n\t\tgoto out_err;\n\n\tdev_priv->pf_pd = psb_mmu_alloc_pd(dev_priv->mmu, 1, 0);\n\tif (!dev_priv->pf_pd)\n\t\tgoto out_err;\n\n\tret = psb_do_init(dev);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tret = psb_mmu_insert_pfn_sequence(psb_mmu_get_default_pd(dev_priv->mmu),\n\t\t\t\t\t  dev_priv->stolen_base >> PAGE_SHIFT,\n\t\t\t\t\t  pg->gatt_start,\n\t\t\t\t\t  pg->stolen_size >> PAGE_SHIFT, 0);\n\n\tpsb_mmu_set_pd_context(psb_mmu_get_default_pd(dev_priv->mmu), 0);\n\tpsb_mmu_set_pd_context(dev_priv->pf_pd, 1);\n\n\tPSB_WSGX32(0x20000000, PSB_CR_PDS_EXEC_BASE);\n\tPSB_WSGX32(0x30000000, PSB_CR_BIF_3D_REQ_BASE);\n\n\tacpi_video_register();\n\n\t \n\tret = drm_vblank_init(dev, dev_priv->num_pipe);\n\tif (ret)\n\t\tgoto out_err;\n\n\t \n\tdev_priv->vdc_irq_mask = 0;\n\tdev_priv->pipestat[0] = 0;\n\tdev_priv->pipestat[1] = 0;\n\tdev_priv->pipestat[2] = 0;\n\tspin_lock_irqsave(&dev_priv->irqmask_lock, irqflags);\n\tPSB_WVDC32(0xFFFFFFFF, PSB_HWSTAM);\n\tPSB_WVDC32(0x00000000, PSB_INT_ENABLE_R);\n\tPSB_WVDC32(0xFFFFFFFF, PSB_INT_MASK_R);\n\tspin_unlock_irqrestore(&dev_priv->irqmask_lock, irqflags);\n\n\tgma_irq_install(dev);\n\n\tdev->max_vblank_count = 0xffffff;  \n\n\tpsb_modeset_init(dev);\n\tdrm_kms_helper_poll_init(dev);\n\n\t \n\tdrm_connector_list_iter_begin(dev, &conn_iter);\n\tdrm_for_each_connector_iter(connector, &conn_iter) {\n\t\tgma_encoder = gma_attached_encoder(connector);\n\n\t\tif (gma_encoder->type == INTEL_OUTPUT_LVDS ||\n\t\t    gma_encoder->type == INTEL_OUTPUT_MIPI) {\n\t\t\tret = gma_backlight_init(dev);\n\t\t\tif (ret == 0)\n\t\t\t\tacpi_video_register_backlight();\n\t\t\tbreak;\n\t\t}\n\t}\n\tdrm_connector_list_iter_end(&conn_iter);\n\n\tif (ret)\n\t\treturn ret;\n\tpsb_intel_opregion_enable_asle(dev);\n\n\treturn devm_add_action_or_reset(dev->dev, psb_device_release, dev);\n\nout_err:\n\tpsb_driver_unload(dev);\n\treturn ret;\n}\n\n \nstatic int gma_remove_conflicting_framebuffers(struct pci_dev *pdev,\n\t\t\t\t\t       const struct drm_driver *req_driver)\n{\n\tresource_size_t base = 0;\n\tresource_size_t size = U32_MAX;  \n\tconst char *name = req_driver->name;\n\tint ret;\n\n\tret = aperture_remove_conflicting_devices(base, size, name);\n\tif (ret)\n\t\treturn ret;\n\n\treturn __aperture_remove_legacy_vga_devices(pdev);\n}\n\nstatic int psb_pci_probe(struct pci_dev *pdev, const struct pci_device_id *ent)\n{\n\tstruct drm_psb_private *dev_priv;\n\tstruct drm_device *dev;\n\tint ret;\n\n\tret = gma_remove_conflicting_framebuffers(pdev, &driver);\n\tif (ret)\n\t\treturn ret;\n\n\tret = pcim_enable_device(pdev);\n\tif (ret)\n\t\treturn ret;\n\n\tdev_priv = devm_drm_dev_alloc(&pdev->dev, &driver, struct drm_psb_private, dev);\n\tif (IS_ERR(dev_priv))\n\t\treturn PTR_ERR(dev_priv);\n\tdev = &dev_priv->dev;\n\n\tpci_set_drvdata(pdev, dev);\n\n\tret = psb_driver_load(dev, ent->driver_data);\n\tif (ret)\n\t\treturn ret;\n\n\tret = drm_dev_register(dev, ent->driver_data);\n\tif (ret)\n\t\treturn ret;\n\n\tpsb_fbdev_setup(dev_priv);\n\n\treturn 0;\n}\n\nstatic void psb_pci_remove(struct pci_dev *pdev)\n{\n\tstruct drm_device *dev = pci_get_drvdata(pdev);\n\n\tdrm_dev_unregister(dev);\n}\n\nstatic DEFINE_RUNTIME_DEV_PM_OPS(psb_pm_ops, gma_power_suspend, gma_power_resume, NULL);\n\nstatic const struct file_operations psb_gem_fops = {\n\t.owner = THIS_MODULE,\n\t.open = drm_open,\n\t.release = drm_release,\n\t.unlocked_ioctl = drm_ioctl,\n\t.compat_ioctl = drm_compat_ioctl,\n\t.mmap = drm_gem_mmap,\n\t.poll = drm_poll,\n\t.read = drm_read,\n};\n\nstatic const struct drm_driver driver = {\n\t.driver_features = DRIVER_MODESET | DRIVER_GEM,\n\n\t.num_ioctls = ARRAY_SIZE(psb_ioctls),\n\n\t.dumb_create = psb_gem_dumb_create,\n\t.ioctls = psb_ioctls,\n\t.fops = &psb_gem_fops,\n\t.name = DRIVER_NAME,\n\t.desc = DRIVER_DESC,\n\t.date = DRIVER_DATE,\n\t.major = DRIVER_MAJOR,\n\t.minor = DRIVER_MINOR,\n\t.patchlevel = DRIVER_PATCHLEVEL\n};\n\nstatic struct pci_driver psb_pci_driver = {\n\t.name = DRIVER_NAME,\n\t.id_table = pciidlist,\n\t.probe = psb_pci_probe,\n\t.remove = psb_pci_remove,\n\t.driver.pm = &psb_pm_ops,\n};\n\nstatic int __init psb_init(void)\n{\n\tif (drm_firmware_drivers_only())\n\t\treturn -ENODEV;\n\n\treturn pci_register_driver(&psb_pci_driver);\n}\n\nstatic void __exit psb_exit(void)\n{\n\tpci_unregister_driver(&psb_pci_driver);\n}\n\nlate_initcall(psb_init);\nmodule_exit(psb_exit);\n\nMODULE_AUTHOR(DRIVER_AUTHOR);\nMODULE_DESCRIPTION(DRIVER_DESC);\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}