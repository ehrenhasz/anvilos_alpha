{
  "module_name": "backlight.c",
  "hash_id": "14da7858de70b69f2281b9c8dccd564f80928c683162b09a43c383871f61b141",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/gma500/backlight.c",
  "human_readable_source": "\n \n\n#include <linux/backlight.h>\n\n#include <acpi/video.h>\n\n#include \"psb_drv.h\"\n#include \"psb_intel_reg.h\"\n#include \"psb_intel_drv.h\"\n#include \"intel_bios.h\"\n#include \"power.h\"\n\nvoid gma_backlight_enable(struct drm_device *dev)\n{\n\tstruct drm_psb_private *dev_priv = to_drm_psb_private(dev);\n\n\tdev_priv->backlight_enabled = true;\n\tdev_priv->ops->backlight_set(dev, dev_priv->backlight_level);\n}\n\nvoid gma_backlight_disable(struct drm_device *dev)\n{\n\tstruct drm_psb_private *dev_priv = to_drm_psb_private(dev);\n\n\tdev_priv->backlight_enabled = false;\n\tdev_priv->ops->backlight_set(dev, 0);\n}\n\nvoid gma_backlight_set(struct drm_device *dev, int v)\n{\n\tstruct drm_psb_private *dev_priv = to_drm_psb_private(dev);\n\n\tdev_priv->backlight_level = v;\n\tif (dev_priv->backlight_enabled)\n\t\tdev_priv->ops->backlight_set(dev, v);\n}\n\nstatic int gma_backlight_get_brightness(struct backlight_device *bd)\n{\n\tstruct drm_device *dev = bl_get_data(bd);\n\tstruct drm_psb_private *dev_priv = to_drm_psb_private(dev);\n\n\tif (dev_priv->ops->backlight_get)\n\t\treturn dev_priv->ops->backlight_get(dev);\n\n\treturn dev_priv->backlight_level;\n}\n\nstatic int gma_backlight_update_status(struct backlight_device *bd)\n{\n\tstruct drm_device *dev = bl_get_data(bd);\n\tint level = backlight_get_brightness(bd);\n\n\t \n\tif (level < 1)\n\t\tlevel = 1;\n\n\tgma_backlight_set(dev, level);\n\treturn 0;\n}\n\nstatic const struct backlight_ops gma_backlight_ops __maybe_unused = {\n\t.get_brightness = gma_backlight_get_brightness,\n\t.update_status  = gma_backlight_update_status,\n};\n\nint gma_backlight_init(struct drm_device *dev)\n{\n\tstruct drm_psb_private *dev_priv = to_drm_psb_private(dev);\n\tstruct backlight_properties props __maybe_unused = {};\n\tint ret;\n\n\tdev_priv->backlight_enabled = true;\n\tdev_priv->backlight_level = 100;\n\n\tret = dev_priv->ops->backlight_init(dev);\n\tif (ret)\n\t\treturn ret;\n\n\tif (!acpi_video_backlight_use_native()) {\n\t\tdrm_info(dev, \"Skipping %s backlight registration\\n\",\n\t\t\t dev_priv->ops->backlight_name);\n\t\treturn 0;\n\t}\n\n#ifdef CONFIG_BACKLIGHT_CLASS_DEVICE\n\tprops.brightness = dev_priv->backlight_level;\n\tprops.max_brightness = PSB_MAX_BRIGHTNESS;\n\tprops.type = BACKLIGHT_RAW;\n\n\tdev_priv->backlight_device =\n\t\tbacklight_device_register(dev_priv->ops->backlight_name,\n\t\t\t\t\t  dev->dev, dev,\n\t\t\t\t\t  &gma_backlight_ops, &props);\n\tif (IS_ERR(dev_priv->backlight_device))\n\t\treturn PTR_ERR(dev_priv->backlight_device);\n#endif\n\n\treturn 0;\n}\n\nvoid gma_backlight_exit(struct drm_device *dev)\n{\n#ifdef CONFIG_BACKLIGHT_CLASS_DEVICE\n\tstruct drm_psb_private *dev_priv = to_drm_psb_private(dev);\n\n\tif (dev_priv->backlight_device)\n\t\tbacklight_device_unregister(dev_priv->backlight_device);\n#endif\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}