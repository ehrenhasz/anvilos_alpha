{
  "module_name": "intel_gmbus.c",
  "hash_id": "532d55cc4465e92c12951813df64cccba578f02215dcbe2fa4481cb69e4a8a2b",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/gma500/intel_gmbus.c",
  "human_readable_source": " \n\n#include <linux/delay.h>\n#include <linux/i2c-algo-bit.h>\n#include <linux/i2c.h>\n#include <linux/module.h>\n\n#include \"psb_drv.h\"\n#include \"psb_intel_drv.h\"\n#include \"psb_intel_reg.h\"\n\n#define _wait_for(COND, MS, W) ({ \\\n\tunsigned long timeout__ = jiffies + msecs_to_jiffies(MS);\t\\\n\tint ret__ = 0;\t\t\t\t\t\t\t\\\n\twhile (! (COND)) {\t\t\t\t\t\t\\\n\t\tif (time_after(jiffies, timeout__)) {\t\t\t\\\n\t\t\tret__ = -ETIMEDOUT;\t\t\t\t\\\n\t\t\tbreak;\t\t\t\t\t\t\\\n\t\t}\t\t\t\t\t\t\t\\\n\t\tif (W && !(in_dbg_master()))\t\t\t\t\\\n\t\t\tmsleep(W);\t\t\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\\\n\tret__;\t\t\t\t\t\t\t\t\\\n})\n\n#define wait_for(COND, MS) _wait_for(COND, MS, 1)\n\n#define GMBUS_REG_READ(reg) ioread32(dev_priv->gmbus_reg + (reg))\n#define GMBUS_REG_WRITE(reg, val) iowrite32((val), dev_priv->gmbus_reg + (reg))\n\n \n\n#define I2C_RISEFALL_TIME 20\n\nstatic inline struct intel_gmbus *\nto_intel_gmbus(struct i2c_adapter *i2c)\n{\n\treturn container_of(i2c, struct intel_gmbus, adapter);\n}\n\nstruct intel_gpio {\n\tstruct i2c_adapter adapter;\n\tstruct i2c_algo_bit_data algo;\n\tstruct drm_psb_private *dev_priv;\n\tu32 reg;\n};\n\nvoid\ngma_intel_i2c_reset(struct drm_device *dev)\n{\n\tstruct drm_psb_private *dev_priv = to_drm_psb_private(dev);\n\tGMBUS_REG_WRITE(GMBUS0, 0);\n}\n\nstatic void intel_i2c_quirk_set(struct drm_psb_private *dev_priv, bool enable)\n{\n\t \n\t \n}\n\nstatic u32 get_reserved(struct intel_gpio *gpio)\n{\n\tstruct drm_psb_private *dev_priv = gpio->dev_priv;\n\tu32 reserved = 0;\n\n\t \n\treserved = GMBUS_REG_READ(gpio->reg) &\n\t\t\t\t     (GPIO_DATA_PULLUP_DISABLE |\n\t\t\t\t      GPIO_CLOCK_PULLUP_DISABLE);\n\n\treturn reserved;\n}\n\nstatic int get_clock(void *data)\n{\n\tstruct intel_gpio *gpio = data;\n\tstruct drm_psb_private *dev_priv = gpio->dev_priv;\n\tu32 reserved = get_reserved(gpio);\n\tGMBUS_REG_WRITE(gpio->reg, reserved | GPIO_CLOCK_DIR_MASK);\n\tGMBUS_REG_WRITE(gpio->reg, reserved);\n\treturn (GMBUS_REG_READ(gpio->reg) & GPIO_CLOCK_VAL_IN) != 0;\n}\n\nstatic int get_data(void *data)\n{\n\tstruct intel_gpio *gpio = data;\n\tstruct drm_psb_private *dev_priv = gpio->dev_priv;\n\tu32 reserved = get_reserved(gpio);\n\tGMBUS_REG_WRITE(gpio->reg, reserved | GPIO_DATA_DIR_MASK);\n\tGMBUS_REG_WRITE(gpio->reg, reserved);\n\treturn (GMBUS_REG_READ(gpio->reg) & GPIO_DATA_VAL_IN) != 0;\n}\n\nstatic void set_clock(void *data, int state_high)\n{\n\tstruct intel_gpio *gpio = data;\n\tstruct drm_psb_private *dev_priv = gpio->dev_priv;\n\tu32 reserved = get_reserved(gpio);\n\tu32 clock_bits;\n\n\tif (state_high)\n\t\tclock_bits = GPIO_CLOCK_DIR_IN | GPIO_CLOCK_DIR_MASK;\n\telse\n\t\tclock_bits = GPIO_CLOCK_DIR_OUT | GPIO_CLOCK_DIR_MASK |\n\t\t\tGPIO_CLOCK_VAL_MASK;\n\n\tGMBUS_REG_WRITE(gpio->reg, reserved | clock_bits);\n\tGMBUS_REG_READ(gpio->reg);  \n}\n\nstatic void set_data(void *data, int state_high)\n{\n\tstruct intel_gpio *gpio = data;\n\tstruct drm_psb_private *dev_priv = gpio->dev_priv;\n\tu32 reserved = get_reserved(gpio);\n\tu32 data_bits;\n\n\tif (state_high)\n\t\tdata_bits = GPIO_DATA_DIR_IN | GPIO_DATA_DIR_MASK;\n\telse\n\t\tdata_bits = GPIO_DATA_DIR_OUT | GPIO_DATA_DIR_MASK |\n\t\t\tGPIO_DATA_VAL_MASK;\n\n\tGMBUS_REG_WRITE(gpio->reg, reserved | data_bits);\n\tGMBUS_REG_READ(gpio->reg);\n}\n\nstatic struct i2c_adapter *\nintel_gpio_create(struct drm_psb_private *dev_priv, u32 pin)\n{\n\tstatic const int map_pin_to_reg[] = {\n\t\t0,\n\t\tGPIOB,\n\t\tGPIOA,\n\t\tGPIOC,\n\t\tGPIOD,\n\t\tGPIOE,\n\t\t0,\n\t\tGPIOF,\n\t};\n\tstruct intel_gpio *gpio;\n\n\tif (pin >= ARRAY_SIZE(map_pin_to_reg) || !map_pin_to_reg[pin])\n\t\treturn NULL;\n\n\tgpio = kzalloc(sizeof(struct intel_gpio), GFP_KERNEL);\n\tif (gpio == NULL)\n\t\treturn NULL;\n\n\tgpio->reg = map_pin_to_reg[pin];\n\tgpio->dev_priv = dev_priv;\n\n\tsnprintf(gpio->adapter.name, sizeof(gpio->adapter.name),\n\t\t \"gma500 GPIO%c\", \"?BACDE?F\"[pin]);\n\tgpio->adapter.owner = THIS_MODULE;\n\tgpio->adapter.algo_data\t= &gpio->algo;\n\tgpio->adapter.dev.parent = dev_priv->dev.dev;\n\tgpio->algo.setsda = set_data;\n\tgpio->algo.setscl = set_clock;\n\tgpio->algo.getsda = get_data;\n\tgpio->algo.getscl = get_clock;\n\tgpio->algo.udelay = I2C_RISEFALL_TIME;\n\tgpio->algo.timeout = usecs_to_jiffies(2200);\n\tgpio->algo.data = gpio;\n\n\tif (i2c_bit_add_bus(&gpio->adapter))\n\t\tgoto out_free;\n\n\treturn &gpio->adapter;\n\nout_free:\n\tkfree(gpio);\n\treturn NULL;\n}\n\nstatic int\nintel_i2c_quirk_xfer(struct drm_psb_private *dev_priv,\n\t\t     struct i2c_adapter *adapter,\n\t\t     struct i2c_msg *msgs,\n\t\t     int num)\n{\n\tstruct intel_gpio *gpio = container_of(adapter,\n\t\t\t\t\t       struct intel_gpio,\n\t\t\t\t\t       adapter);\n\tint ret;\n\n\tgma_intel_i2c_reset(&dev_priv->dev);\n\n\tintel_i2c_quirk_set(dev_priv, true);\n\tset_data(gpio, 1);\n\tset_clock(gpio, 1);\n\tudelay(I2C_RISEFALL_TIME);\n\n\tret = adapter->algo->master_xfer(adapter, msgs, num);\n\n\tset_data(gpio, 1);\n\tset_clock(gpio, 1);\n\tintel_i2c_quirk_set(dev_priv, false);\n\n\treturn ret;\n}\n\nstatic int\ngmbus_xfer(struct i2c_adapter *adapter,\n\t   struct i2c_msg *msgs,\n\t   int num)\n{\n\tstruct intel_gmbus *bus = container_of(adapter,\n\t\t\t\t\t       struct intel_gmbus,\n\t\t\t\t\t       adapter);\n\tstruct drm_psb_private *dev_priv = adapter->algo_data;\n\tint i, reg_offset;\n\n\tif (bus->force_bit)\n\t\treturn intel_i2c_quirk_xfer(dev_priv,\n\t\t\t\t\t    bus->force_bit, msgs, num);\n\n\treg_offset = 0;\n\n\tGMBUS_REG_WRITE(GMBUS0 + reg_offset, bus->reg0);\n\n\tfor (i = 0; i < num; i++) {\n\t\tu16 len = msgs[i].len;\n\t\tu8 *buf = msgs[i].buf;\n\n\t\tif (msgs[i].flags & I2C_M_RD) {\n\t\t\tGMBUS_REG_WRITE(GMBUS1 + reg_offset,\n\t\t\t\t\tGMBUS_CYCLE_WAIT |\n\t\t\t\t\t(i + 1 == num ? GMBUS_CYCLE_STOP : 0) |\n\t\t\t\t\t(len << GMBUS_BYTE_COUNT_SHIFT) |\n\t\t\t\t\t(msgs[i].addr << GMBUS_SLAVE_ADDR_SHIFT) |\n\t\t\t\t\tGMBUS_SLAVE_READ | GMBUS_SW_RDY);\n\t\t\tGMBUS_REG_READ(GMBUS2+reg_offset);\n\t\t\tdo {\n\t\t\t\tu32 val, loop = 0;\n\n\t\t\t\tif (wait_for(GMBUS_REG_READ(GMBUS2 + reg_offset) &\n\t\t\t\t\t     (GMBUS_SATOER | GMBUS_HW_RDY), 50))\n\t\t\t\t\tgoto timeout;\n\t\t\t\tif (GMBUS_REG_READ(GMBUS2 + reg_offset) & GMBUS_SATOER)\n\t\t\t\t\tgoto clear_err;\n\n\t\t\t\tval = GMBUS_REG_READ(GMBUS3 + reg_offset);\n\t\t\t\tdo {\n\t\t\t\t\t*buf++ = val & 0xff;\n\t\t\t\t\tval >>= 8;\n\t\t\t\t} while (--len && ++loop < 4);\n\t\t\t} while (len);\n\t\t} else {\n\t\t\tu32 val, loop;\n\n\t\t\tval = loop = 0;\n\t\t\tdo {\n\t\t\t\tval |= *buf++ << (8 * loop);\n\t\t\t} while (--len && ++loop < 4);\n\n\t\t\tGMBUS_REG_WRITE(GMBUS3 + reg_offset, val);\n\t\t\tGMBUS_REG_WRITE(GMBUS1 + reg_offset,\n\t\t\t\t   (i + 1 == num ? GMBUS_CYCLE_STOP : GMBUS_CYCLE_WAIT) |\n\t\t\t\t   (msgs[i].len << GMBUS_BYTE_COUNT_SHIFT) |\n\t\t\t\t   (msgs[i].addr << GMBUS_SLAVE_ADDR_SHIFT) |\n\t\t\t\t   GMBUS_SLAVE_WRITE | GMBUS_SW_RDY);\n\t\t\tGMBUS_REG_READ(GMBUS2+reg_offset);\n\n\t\t\twhile (len) {\n\t\t\t\tif (wait_for(GMBUS_REG_READ(GMBUS2 + reg_offset) &\n\t\t\t\t\t     (GMBUS_SATOER | GMBUS_HW_RDY), 50))\n\t\t\t\t\tgoto timeout;\n\t\t\t\tif (GMBUS_REG_READ(GMBUS2 + reg_offset) &\n\t\t\t\t    GMBUS_SATOER)\n\t\t\t\t\tgoto clear_err;\n\n\t\t\t\tval = loop = 0;\n\t\t\t\tdo {\n\t\t\t\t\tval |= *buf++ << (8 * loop);\n\t\t\t\t} while (--len && ++loop < 4);\n\n\t\t\t\tGMBUS_REG_WRITE(GMBUS3 + reg_offset, val);\n\t\t\t\tGMBUS_REG_READ(GMBUS2+reg_offset);\n\t\t\t}\n\t\t}\n\n\t\tif (i + 1 < num && wait_for(GMBUS_REG_READ(GMBUS2 + reg_offset) & (GMBUS_SATOER | GMBUS_HW_WAIT_PHASE), 50))\n\t\t\tgoto timeout;\n\t\tif (GMBUS_REG_READ(GMBUS2 + reg_offset) & GMBUS_SATOER)\n\t\t\tgoto clear_err;\n\t}\n\n\tgoto done;\n\nclear_err:\n\t \n\tGMBUS_REG_WRITE(GMBUS1 + reg_offset, GMBUS_SW_CLR_INT);\n\tGMBUS_REG_WRITE(GMBUS1 + reg_offset, 0);\n\ndone:\n\t \n\tGMBUS_REG_WRITE(GMBUS0 + reg_offset, 0);\n\treturn i;\n\ntimeout:\n\tDRM_INFO(\"GMBUS timed out, falling back to bit banging on pin %d [%s]\\n\",\n\t\t bus->reg0 & 0xff, bus->adapter.name);\n\tGMBUS_REG_WRITE(GMBUS0 + reg_offset, 0);\n\n\t \n\tbus->force_bit = intel_gpio_create(dev_priv, bus->reg0 & 0xff);\n\tif (!bus->force_bit)\n\t\treturn -ENOMEM;\n\n\treturn intel_i2c_quirk_xfer(dev_priv, bus->force_bit, msgs, num);\n}\n\nstatic u32 gmbus_func(struct i2c_adapter *adapter)\n{\n\tstruct intel_gmbus *bus = container_of(adapter,\n\t\t\t\t\t       struct intel_gmbus,\n\t\t\t\t\t       adapter);\n\n\tif (bus->force_bit)\n\t\tbus->force_bit->algo->functionality(bus->force_bit);\n\n\treturn (I2C_FUNC_I2C | I2C_FUNC_SMBUS_EMUL |\n\t\t \n\t\tI2C_FUNC_SMBUS_READ_BLOCK_DATA |\n\t\tI2C_FUNC_SMBUS_BLOCK_PROC_CALL);\n}\n\nstatic const struct i2c_algorithm gmbus_algorithm = {\n\t.master_xfer\t= gmbus_xfer,\n\t.functionality\t= gmbus_func\n};\n\n \nint gma_intel_setup_gmbus(struct drm_device *dev)\n{\n\tstatic const char *names[GMBUS_NUM_PORTS] = {\n\t\t\"disabled\",\n\t\t\"ssc\",\n\t\t\"vga\",\n\t\t\"panel\",\n\t\t\"dpc\",\n\t\t\"dpb\",\n\t\t\"reserved\",\n\t\t\"dpd\",\n\t};\n\tstruct drm_psb_private *dev_priv = to_drm_psb_private(dev);\n\tint ret, i;\n\n\tdev_priv->gmbus = kcalloc(GMBUS_NUM_PORTS, sizeof(struct intel_gmbus),\n\t\t\t\t  GFP_KERNEL);\n\tif (dev_priv->gmbus == NULL)\n\t\treturn -ENOMEM;\n\n\tif (IS_MRST(dev))\n\t\tdev_priv->gmbus_reg = dev_priv->aux_reg;\n\telse\n\t\tdev_priv->gmbus_reg = dev_priv->vdc_reg;\n\n\tfor (i = 0; i < GMBUS_NUM_PORTS; i++) {\n\t\tstruct intel_gmbus *bus = &dev_priv->gmbus[i];\n\n\t\tbus->adapter.owner = THIS_MODULE;\n\t\tbus->adapter.class = I2C_CLASS_DDC;\n\t\tsnprintf(bus->adapter.name,\n\t\t\t sizeof(bus->adapter.name),\n\t\t\t \"gma500 gmbus %s\",\n\t\t\t names[i]);\n\n\t\tbus->adapter.dev.parent = dev->dev;\n\t\tbus->adapter.algo_data\t= dev_priv;\n\n\t\tbus->adapter.algo = &gmbus_algorithm;\n\t\tret = i2c_add_adapter(&bus->adapter);\n\t\tif (ret)\n\t\t\tgoto err;\n\n\t\t \n\t\tbus->reg0 = i | GMBUS_RATE_100KHZ;\n\n\t\t \n\t\tbus->force_bit = intel_gpio_create(dev_priv, i);\n\t}\n\n\tgma_intel_i2c_reset(&dev_priv->dev);\n\n\treturn 0;\n\nerr:\n\twhile (i--) {\n\t\tstruct intel_gmbus *bus = &dev_priv->gmbus[i];\n\t\ti2c_del_adapter(&bus->adapter);\n\t}\n\tkfree(dev_priv->gmbus);\n\tdev_priv->gmbus = NULL;\n\treturn ret;\n}\n\nvoid gma_intel_gmbus_set_speed(struct i2c_adapter *adapter, int speed)\n{\n\tstruct intel_gmbus *bus = to_intel_gmbus(adapter);\n\n\t \n\tbus->reg0 = (bus->reg0 & ~(0x3 << 8)) | (speed << 8);\n}\n\nvoid gma_intel_gmbus_force_bit(struct i2c_adapter *adapter, bool force_bit)\n{\n\tstruct intel_gmbus *bus = to_intel_gmbus(adapter);\n\n\tif (force_bit) {\n\t\tif (bus->force_bit == NULL) {\n\t\t\tstruct drm_psb_private *dev_priv = adapter->algo_data;\n\t\t\tbus->force_bit = intel_gpio_create(dev_priv,\n\t\t\t\t\t\t\t   bus->reg0 & 0xff);\n\t\t}\n\t} else {\n\t\tif (bus->force_bit) {\n\t\t\ti2c_del_adapter(bus->force_bit);\n\t\t\tkfree(bus->force_bit);\n\t\t\tbus->force_bit = NULL;\n\t\t}\n\t}\n}\n\nvoid gma_intel_teardown_gmbus(struct drm_device *dev)\n{\n\tstruct drm_psb_private *dev_priv = to_drm_psb_private(dev);\n\tint i;\n\n\tif (dev_priv->gmbus == NULL)\n\t\treturn;\n\n\tfor (i = 0; i < GMBUS_NUM_PORTS; i++) {\n\t\tstruct intel_gmbus *bus = &dev_priv->gmbus[i];\n\t\tif (bus->force_bit) {\n\t\t\ti2c_del_adapter(bus->force_bit);\n\t\t\tkfree(bus->force_bit);\n\t\t}\n\t\ti2c_del_adapter(&bus->adapter);\n\t}\n\n\tdev_priv->gmbus_reg = NULL;  \n\tkfree(dev_priv->gmbus);\n\tdev_priv->gmbus = NULL;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}