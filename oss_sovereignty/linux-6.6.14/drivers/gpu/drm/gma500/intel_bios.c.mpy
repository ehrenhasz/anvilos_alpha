{
  "module_name": "intel_bios.c",
  "hash_id": "f713519f54820ad5faf5dad31f04e5f40f136322481e2563a3e0f9ead6325063",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/gma500/intel_bios.c",
  "human_readable_source": "\n \n\n#include <drm/display/drm_dp_helper.h>\n#include <drm/drm.h>\n\n#include \"intel_bios.h\"\n#include \"psb_drv.h\"\n#include \"psb_intel_drv.h\"\n#include \"psb_intel_reg.h\"\n\n#define\tSLAVE_ADDR1\t0x70\n#define\tSLAVE_ADDR2\t0x72\n\nstatic void *find_section(struct bdb_header *bdb, int section_id)\n{\n\tu8 *base = (u8 *)bdb;\n\tint index = 0;\n\tu16 total, current_size;\n\tu8 current_id;\n\n\t \n\tindex += bdb->header_size;\n\ttotal = bdb->bdb_size;\n\n\t \n\twhile (index < total) {\n\t\tcurrent_id = *(base + index);\n\t\tindex++;\n\t\tcurrent_size = *((u16 *)(base + index));\n\t\tindex += 2;\n\t\tif (current_id == section_id)\n\t\t\treturn base + index;\n\t\tindex += current_size;\n\t}\n\n\treturn NULL;\n}\n\nstatic void\nparse_edp(struct drm_psb_private *dev_priv, struct bdb_header *bdb)\n{\n\tstruct bdb_edp *edp;\n\tstruct edp_power_seq *edp_pps;\n\tstruct edp_link_params *edp_link_params;\n\tuint8_t\tpanel_type;\n\n\tedp = find_section(bdb, BDB_EDP);\n\n\tdev_priv->edp.bpp = 18;\n\tif (!edp) {\n\t\tif (dev_priv->edp.support) {\n\t\t\tDRM_DEBUG_KMS(\"No eDP BDB found but eDP panel supported, assume %dbpp panel color depth.\\n\",\n\t\t\t\t      dev_priv->edp.bpp);\n\t\t}\n\t\treturn;\n\t}\n\n\tpanel_type = dev_priv->panel_type;\n\tswitch ((edp->color_depth >> (panel_type * 2)) & 3) {\n\tcase EDP_18BPP:\n\t\tdev_priv->edp.bpp = 18;\n\t\tbreak;\n\tcase EDP_24BPP:\n\t\tdev_priv->edp.bpp = 24;\n\t\tbreak;\n\tcase EDP_30BPP:\n\t\tdev_priv->edp.bpp = 30;\n\t\tbreak;\n\t}\n\n\t \n\tedp_pps = &edp->power_seqs[panel_type];\n\tedp_link_params = &edp->link_params[panel_type];\n\n\tdev_priv->edp.pps = *edp_pps;\n\n\tDRM_DEBUG_KMS(\"EDP timing in vbt t1_t3 %d t8 %d t9 %d t10 %d t11_t12 %d\\n\",\n\t\t\t\tdev_priv->edp.pps.t1_t3, dev_priv->edp.pps.t8,\n\t\t\t\tdev_priv->edp.pps.t9, dev_priv->edp.pps.t10,\n\t\t\t\tdev_priv->edp.pps.t11_t12);\n\n\tdev_priv->edp.rate = edp_link_params->rate ? DP_LINK_BW_2_7 :\n\t\tDP_LINK_BW_1_62;\n\tswitch (edp_link_params->lanes) {\n\tcase 0:\n\t\tdev_priv->edp.lanes = 1;\n\t\tbreak;\n\tcase 1:\n\t\tdev_priv->edp.lanes = 2;\n\t\tbreak;\n\tcase 3:\n\tdefault:\n\t\tdev_priv->edp.lanes = 4;\n\t\tbreak;\n\t}\n\tDRM_DEBUG_KMS(\"VBT reports EDP: Lane_count %d, Lane_rate %d, Bpp %d\\n\",\n\t\t\tdev_priv->edp.lanes, dev_priv->edp.rate, dev_priv->edp.bpp);\n\n\tswitch (edp_link_params->preemphasis) {\n\tcase 0:\n\t\tdev_priv->edp.preemphasis = DP_TRAIN_PRE_EMPH_LEVEL_0;\n\t\tbreak;\n\tcase 1:\n\t\tdev_priv->edp.preemphasis = DP_TRAIN_PRE_EMPH_LEVEL_1;\n\t\tbreak;\n\tcase 2:\n\t\tdev_priv->edp.preemphasis = DP_TRAIN_PRE_EMPH_LEVEL_2;\n\t\tbreak;\n\tcase 3:\n\t\tdev_priv->edp.preemphasis = DP_TRAIN_PRE_EMPH_LEVEL_3;\n\t\tbreak;\n\t}\n\tswitch (edp_link_params->vswing) {\n\tcase 0:\n\t\tdev_priv->edp.vswing = DP_TRAIN_VOLTAGE_SWING_LEVEL_0;\n\t\tbreak;\n\tcase 1:\n\t\tdev_priv->edp.vswing = DP_TRAIN_VOLTAGE_SWING_LEVEL_1;\n\t\tbreak;\n\tcase 2:\n\t\tdev_priv->edp.vswing = DP_TRAIN_VOLTAGE_SWING_LEVEL_2;\n\t\tbreak;\n\tcase 3:\n\t\tdev_priv->edp.vswing = DP_TRAIN_VOLTAGE_SWING_LEVEL_3;\n\t\tbreak;\n\t}\n\tDRM_DEBUG_KMS(\"VBT reports EDP: VSwing  %d, Preemph %d\\n\",\n\t\t\tdev_priv->edp.vswing, dev_priv->edp.preemphasis);\n}\n\nstatic u16\nget_blocksize(void *p)\n{\n\tu16 *block_ptr, block_size;\n\n\tblock_ptr = (u16 *)((char *)p - 2);\n\tblock_size = *block_ptr;\n\treturn block_size;\n}\n\nstatic void fill_detail_timing_data(struct drm_display_mode *panel_fixed_mode,\n\t\t\tstruct lvds_dvo_timing *dvo_timing)\n{\n\tpanel_fixed_mode->hdisplay = (dvo_timing->hactive_hi << 8) |\n\t\tdvo_timing->hactive_lo;\n\tpanel_fixed_mode->hsync_start = panel_fixed_mode->hdisplay +\n\t\t((dvo_timing->hsync_off_hi << 8) | dvo_timing->hsync_off_lo);\n\tpanel_fixed_mode->hsync_end = panel_fixed_mode->hsync_start +\n\t\tdvo_timing->hsync_pulse_width;\n\tpanel_fixed_mode->htotal = panel_fixed_mode->hdisplay +\n\t\t((dvo_timing->hblank_hi << 8) | dvo_timing->hblank_lo);\n\n\tpanel_fixed_mode->vdisplay = (dvo_timing->vactive_hi << 8) |\n\t\tdvo_timing->vactive_lo;\n\tpanel_fixed_mode->vsync_start = panel_fixed_mode->vdisplay +\n\t\tdvo_timing->vsync_off;\n\tpanel_fixed_mode->vsync_end = panel_fixed_mode->vsync_start +\n\t\tdvo_timing->vsync_pulse_width;\n\tpanel_fixed_mode->vtotal = panel_fixed_mode->vdisplay +\n\t\t((dvo_timing->vblank_hi << 8) | dvo_timing->vblank_lo);\n\tpanel_fixed_mode->clock = dvo_timing->clock * 10;\n\tpanel_fixed_mode->type = DRM_MODE_TYPE_PREFERRED;\n\n\tif (dvo_timing->hsync_positive)\n\t\tpanel_fixed_mode->flags |= DRM_MODE_FLAG_PHSYNC;\n\telse\n\t\tpanel_fixed_mode->flags |= DRM_MODE_FLAG_NHSYNC;\n\n\tif (dvo_timing->vsync_positive)\n\t\tpanel_fixed_mode->flags |= DRM_MODE_FLAG_PVSYNC;\n\telse\n\t\tpanel_fixed_mode->flags |= DRM_MODE_FLAG_NVSYNC;\n\n\t \n\tif (panel_fixed_mode->hsync_end > panel_fixed_mode->htotal)\n\t\tpanel_fixed_mode->htotal = panel_fixed_mode->hsync_end + 1;\n\tif (panel_fixed_mode->vsync_end > panel_fixed_mode->vtotal)\n\t\tpanel_fixed_mode->vtotal = panel_fixed_mode->vsync_end + 1;\n\n\tdrm_mode_set_name(panel_fixed_mode);\n}\n\nstatic void parse_backlight_data(struct drm_psb_private *dev_priv,\n\t\t\t\tstruct bdb_header *bdb)\n{\n\tstruct bdb_lvds_backlight *vbt_lvds_bl = NULL;\n\tstruct bdb_lvds_backlight *lvds_bl;\n\tu8 p_type = 0;\n\tvoid *bl_start = NULL;\n\tstruct bdb_lvds_options *lvds_opts\n\t\t\t\t= find_section(bdb, BDB_LVDS_OPTIONS);\n\n\tdev_priv->lvds_bl = NULL;\n\n\tif (lvds_opts)\n\t\tp_type = lvds_opts->panel_type;\n\telse\n\t\treturn;\n\n\tbl_start = find_section(bdb, BDB_LVDS_BACKLIGHT);\n\tvbt_lvds_bl = (struct bdb_lvds_backlight *)(bl_start + 1) + p_type;\n\n\tlvds_bl = kmemdup(vbt_lvds_bl, sizeof(*vbt_lvds_bl), GFP_KERNEL);\n\tif (!lvds_bl) {\n\t\tdev_err(dev_priv->dev.dev, \"out of memory for backlight data\\n\");\n\t\treturn;\n\t}\n\tdev_priv->lvds_bl = lvds_bl;\n}\n\n \nstatic void parse_lfp_panel_data(struct drm_psb_private *dev_priv,\n\t\t\t    struct bdb_header *bdb)\n{\n\tstruct bdb_lvds_options *lvds_options;\n\tstruct bdb_lvds_lfp_data *lvds_lfp_data;\n\tstruct bdb_lvds_lfp_data_entry *entry;\n\tstruct lvds_dvo_timing *dvo_timing;\n\tstruct drm_display_mode *panel_fixed_mode;\n\n\t \n\tdev_priv->lvds_dither = 0;\n\tdev_priv->lvds_vbt = 0;\n\n\tlvds_options = find_section(bdb, BDB_LVDS_OPTIONS);\n\tif (!lvds_options)\n\t\treturn;\n\n\tdev_priv->lvds_dither = lvds_options->pixel_dither;\n\tdev_priv->panel_type = lvds_options->panel_type;\n\n\tif (lvds_options->panel_type == 0xff)\n\t\treturn;\n\n\tlvds_lfp_data = find_section(bdb, BDB_LVDS_LFP_DATA);\n\tif (!lvds_lfp_data)\n\t\treturn;\n\n\n\tentry = &lvds_lfp_data->data[lvds_options->panel_type];\n\tdvo_timing = &entry->dvo_timing;\n\n\tpanel_fixed_mode = kzalloc(sizeof(*panel_fixed_mode),\n\t\t\t\t      GFP_KERNEL);\n\tif (panel_fixed_mode == NULL) {\n\t\tdev_err(dev_priv->dev.dev, \"out of memory for fixed panel mode\\n\");\n\t\treturn;\n\t}\n\n\tdev_priv->lvds_vbt = 1;\n\tfill_detail_timing_data(panel_fixed_mode, dvo_timing);\n\n\tif (panel_fixed_mode->htotal > 0 && panel_fixed_mode->vtotal > 0) {\n\t\tdev_priv->lfp_lvds_vbt_mode = panel_fixed_mode;\n\t\tdrm_mode_debug_printmodeline(panel_fixed_mode);\n\t} else {\n\t\tdev_dbg(dev_priv->dev.dev, \"ignoring invalid LVDS VBT\\n\");\n\t\tdev_priv->lvds_vbt = 0;\n\t\tkfree(panel_fixed_mode);\n\t}\n\treturn;\n}\n\n \nstatic void parse_sdvo_panel_data(struct drm_psb_private *dev_priv,\n\t\t      struct bdb_header *bdb)\n{\n\tstruct bdb_sdvo_lvds_options *sdvo_lvds_options;\n\tstruct lvds_dvo_timing *dvo_timing;\n\tstruct drm_display_mode *panel_fixed_mode;\n\n\tdev_priv->sdvo_lvds_vbt_mode = NULL;\n\n\tsdvo_lvds_options = find_section(bdb, BDB_SDVO_LVDS_OPTIONS);\n\tif (!sdvo_lvds_options)\n\t\treturn;\n\n\tdvo_timing = find_section(bdb, BDB_SDVO_PANEL_DTDS);\n\tif (!dvo_timing)\n\t\treturn;\n\n\tpanel_fixed_mode = kzalloc(sizeof(*panel_fixed_mode), GFP_KERNEL);\n\n\tif (!panel_fixed_mode)\n\t\treturn;\n\n\tfill_detail_timing_data(panel_fixed_mode,\n\t\t\tdvo_timing + sdvo_lvds_options->panel_type);\n\n\tdev_priv->sdvo_lvds_vbt_mode = panel_fixed_mode;\n\n\treturn;\n}\n\nstatic void parse_general_features(struct drm_psb_private *dev_priv,\n\t\t       struct bdb_header *bdb)\n{\n\tstruct bdb_general_features *general;\n\n\t \n\tdev_priv->int_tv_support = 1;\n\tdev_priv->int_crt_support = 1;\n\n\tgeneral = find_section(bdb, BDB_GENERAL_FEATURES);\n\tif (general) {\n\t\tdev_priv->int_tv_support = general->int_tv_support;\n\t\tdev_priv->int_crt_support = general->int_crt_support;\n\t\tdev_priv->lvds_use_ssc = general->enable_ssc;\n\n\t\tif (dev_priv->lvds_use_ssc) {\n\t\t\tdev_priv->lvds_ssc_freq\n\t\t\t\t= general->ssc_freq ? 100 : 96;\n\t\t}\n\t}\n}\n\nstatic void\nparse_sdvo_device_mapping(struct drm_psb_private *dev_priv,\n\t\t\t  struct bdb_header *bdb)\n{\n\tstruct sdvo_device_mapping *p_mapping;\n\tstruct bdb_general_definitions *p_defs;\n\tstruct child_device_config *p_child;\n\tint i, child_device_num, count;\n\tu16\tblock_size;\n\n\tp_defs = find_section(bdb, BDB_GENERAL_DEFINITIONS);\n\tif (!p_defs) {\n\t\tDRM_DEBUG_KMS(\"No general definition block is found, unable to construct sdvo mapping.\\n\");\n\t\treturn;\n\t}\n\t \n\tif (p_defs->child_dev_size != sizeof(*p_child)) {\n\t\t \n\t\tDRM_DEBUG_KMS(\"different child size is found. Invalid.\\n\");\n\t\treturn;\n\t}\n\t \n\tblock_size = get_blocksize(p_defs);\n\t \n\tchild_device_num = (block_size - sizeof(*p_defs)) /\n\t\t\t\tsizeof(*p_child);\n\tcount = 0;\n\tfor (i = 0; i < child_device_num; i++) {\n\t\tp_child = &(p_defs->devices[i]);\n\t\tif (!p_child->device_type) {\n\t\t\t \n\t\t\tcontinue;\n\t\t}\n\t\tif (p_child->slave_addr != SLAVE_ADDR1 &&\n\t\t\tp_child->slave_addr != SLAVE_ADDR2) {\n\t\t\t \n\t\t\tcontinue;\n\t\t}\n\t\tif (p_child->dvo_port != DEVICE_PORT_DVOB &&\n\t\t\tp_child->dvo_port != DEVICE_PORT_DVOC) {\n\t\t\t \n\t\t\tDRM_DEBUG_KMS(\"Incorrect SDVO port. Skip it\\n\");\n\t\t\tcontinue;\n\t\t}\n\t\tDRM_DEBUG_KMS(\"the SDVO device with slave addr %2x is found on\"\n\t\t\t\t\" %s port\\n\",\n\t\t\t\tp_child->slave_addr,\n\t\t\t\t(p_child->dvo_port == DEVICE_PORT_DVOB) ?\n\t\t\t\t\t\"SDVOB\" : \"SDVOC\");\n\t\tp_mapping = &(dev_priv->sdvo_mappings[p_child->dvo_port - 1]);\n\t\tif (!p_mapping->initialized) {\n\t\t\tp_mapping->dvo_port = p_child->dvo_port;\n\t\t\tp_mapping->slave_addr = p_child->slave_addr;\n\t\t\tp_mapping->dvo_wiring = p_child->dvo_wiring;\n\t\t\tp_mapping->ddc_pin = p_child->ddc_pin;\n\t\t\tp_mapping->i2c_pin = p_child->i2c_pin;\n\t\t\tp_mapping->initialized = 1;\n\t\t\tDRM_DEBUG_KMS(\"SDVO device: dvo=%x, addr=%x, wiring=%d, ddc_pin=%d, i2c_pin=%d\\n\",\n\t\t\t\t      p_mapping->dvo_port,\n\t\t\t\t      p_mapping->slave_addr,\n\t\t\t\t      p_mapping->dvo_wiring,\n\t\t\t\t      p_mapping->ddc_pin,\n\t\t\t\t      p_mapping->i2c_pin);\n\t\t} else {\n\t\t\tDRM_DEBUG_KMS(\"Maybe one SDVO port is shared by \"\n\t\t\t\t\t \"two SDVO device.\\n\");\n\t\t}\n\t\tif (p_child->slave2_addr) {\n\t\t\t \n\t\t\t \n\t\t\tDRM_DEBUG_KMS(\"there exists the slave2_addr. Maybe this\"\n\t\t\t\t\" is a SDVO device with multiple inputs.\\n\");\n\t\t}\n\t\tcount++;\n\t}\n\n\tif (!count) {\n\t\t \n\t\tDRM_DEBUG_KMS(\"No SDVO device info is found in VBT\\n\");\n\t}\n\treturn;\n}\n\n\nstatic void\nparse_driver_features(struct drm_psb_private *dev_priv,\n\t\t      struct bdb_header *bdb)\n{\n\tstruct bdb_driver_features *driver;\n\n\tdriver = find_section(bdb, BDB_DRIVER_FEATURES);\n\tif (!driver)\n\t\treturn;\n\n\tif (driver->lvds_config == BDB_DRIVER_FEATURE_EDP)\n\t\tdev_priv->edp.support = 1;\n\n\tdev_priv->lvds_enabled_in_vbt = driver->lvds_config != 0;\n\tDRM_DEBUG_KMS(\"LVDS VBT config bits: 0x%x\\n\", driver->lvds_config);\n\n\t \n\tif (driver->primary_lfp_id)\n\t\tdev_priv->dplla_96mhz = true;\n\telse\n\t\tdev_priv->dplla_96mhz = false;\n}\n\nstatic void\nparse_device_mapping(struct drm_psb_private *dev_priv,\n\t\t       struct bdb_header *bdb)\n{\n\tstruct bdb_general_definitions *p_defs;\n\tstruct child_device_config *p_child, *child_dev_ptr;\n\tint i, child_device_num, count;\n\tu16\tblock_size;\n\n\tp_defs = find_section(bdb, BDB_GENERAL_DEFINITIONS);\n\tif (!p_defs) {\n\t\tDRM_DEBUG_KMS(\"No general definition block is found, no devices defined.\\n\");\n\t\treturn;\n\t}\n\t \n\tif (p_defs->child_dev_size != sizeof(*p_child)) {\n\t\t \n\t\tDRM_DEBUG_KMS(\"different child size is found. Invalid.\\n\");\n\t\treturn;\n\t}\n\t \n\tblock_size = get_blocksize(p_defs);\n\t \n\tchild_device_num = (block_size - sizeof(*p_defs)) /\n\t\t\t\tsizeof(*p_child);\n\tcount = 0;\n\t \n\tfor (i = 0; i < child_device_num; i++) {\n\t\tp_child = &(p_defs->devices[i]);\n\t\tif (!p_child->device_type) {\n\t\t\t \n\t\t\tcontinue;\n\t\t}\n\t\tcount++;\n\t}\n\tif (!count) {\n\t\tDRM_DEBUG_KMS(\"no child dev is parsed from VBT\\n\");\n\t\treturn;\n\t}\n\tdev_priv->child_dev = kcalloc(count, sizeof(*p_child), GFP_KERNEL);\n\tif (!dev_priv->child_dev) {\n\t\tDRM_DEBUG_KMS(\"No memory space for child devices\\n\");\n\t\treturn;\n\t}\n\n\tdev_priv->child_dev_num = count;\n\tcount = 0;\n\tfor (i = 0; i < child_device_num; i++) {\n\t\tp_child = &(p_defs->devices[i]);\n\t\tif (!p_child->device_type) {\n\t\t\t \n\t\t\tcontinue;\n\t\t}\n\t\tchild_dev_ptr = dev_priv->child_dev + count;\n\t\tcount++;\n\t\tmemcpy((void *)child_dev_ptr, (void *)p_child,\n\t\t\t\t\tsizeof(*p_child));\n\t}\n\treturn;\n}\n\n\n \nint psb_intel_init_bios(struct drm_device *dev)\n{\n\tstruct drm_psb_private *dev_priv = to_drm_psb_private(dev);\n\tstruct pci_dev *pdev = to_pci_dev(dev->dev);\n\tstruct vbt_header *vbt = NULL;\n\tstruct bdb_header *bdb = NULL;\n\tu8 __iomem *bios = NULL;\n\tsize_t size;\n\tint i;\n\n\n\tdev_priv->panel_type = 0xff;\n\n\t \n\tif (dev_priv->opregion.vbt) {\n\t\tstruct vbt_header *vbt = dev_priv->opregion.vbt;\n\t\tif (memcmp(vbt->signature, \"$VBT\", 4) == 0) {\n\t\t\tDRM_DEBUG_KMS(\"Using VBT from OpRegion: %20s\\n\",\n\t\t\t\t\t vbt->signature);\n\t\t\tbdb = (struct bdb_header *)((char *)vbt + vbt->bdb_offset);\n\t\t} else\n\t\t\tdev_priv->opregion.vbt = NULL;\n\t}\n\n\tif (bdb == NULL) {\n\t\tbios = pci_map_rom(pdev, &size);\n\t\tif (!bios)\n\t\t\treturn -1;\n\n\t\t \n\t\tfor (i = 0; i + 4 < size; i++) {\n\t\t\tif (!memcmp(bios + i, \"$VBT\", 4)) {\n\t\t\t\tvbt = (struct vbt_header *)(bios + i);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (!vbt) {\n\t\t\tdev_err(dev->dev, \"VBT signature missing\\n\");\n\t\t\tpci_unmap_rom(pdev, bios);\n\t\t\treturn -1;\n\t\t}\n\t\tbdb = (struct bdb_header *)(bios + i + vbt->bdb_offset);\n\t}\n\n\t \n\tparse_general_features(dev_priv, bdb);\n\tparse_driver_features(dev_priv, bdb);\n\tparse_lfp_panel_data(dev_priv, bdb);\n\tparse_sdvo_panel_data(dev_priv, bdb);\n\tparse_sdvo_device_mapping(dev_priv, bdb);\n\tparse_device_mapping(dev_priv, bdb);\n\tparse_backlight_data(dev_priv, bdb);\n\tparse_edp(dev_priv, bdb);\n\n\tif (bios)\n\t\tpci_unmap_rom(pdev, bios);\n\n\treturn 0;\n}\n\n \nvoid psb_intel_destroy_bios(struct drm_device *dev)\n{\n\tstruct drm_psb_private *dev_priv = to_drm_psb_private(dev);\n\n\tkfree(dev_priv->sdvo_lvds_vbt_mode);\n\tkfree(dev_priv->lfp_lvds_vbt_mode);\n\tkfree(dev_priv->lvds_bl);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}