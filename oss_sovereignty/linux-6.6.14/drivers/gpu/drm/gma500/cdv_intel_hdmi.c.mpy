{
  "module_name": "cdv_intel_hdmi.c",
  "hash_id": "1736a65c9cc996b3ceebed21dee914432d7550dec8cff32d91c48c2ab4dc04fa",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/gma500/cdv_intel_hdmi.c",
  "human_readable_source": " \n\n#include <linux/pm_runtime.h>\n\n#include <drm/drm.h>\n#include <drm/drm_crtc.h>\n#include <drm/drm_crtc_helper.h>\n#include <drm/drm_edid.h>\n#include <drm/drm_modeset_helper_vtables.h>\n#include <drm/drm_simple_kms_helper.h>\n\n#include \"cdv_device.h\"\n#include \"psb_drv.h\"\n#include \"psb_intel_drv.h\"\n#include \"psb_intel_reg.h\"\n\n \n#define HDMI_NULL_PACKETS_DURING_VSYNC\t(1 << 9)\n#define HDMI_BORDER_ENABLE\t\t(1 << 7)\n#define HDMI_AUDIO_ENABLE\t\t(1 << 6)\n#define HDMI_VSYNC_ACTIVE_HIGH\t\t(1 << 4)\n#define HDMI_HSYNC_ACTIVE_HIGH\t\t(1 << 3)\n \n#define\tHDMIB_PIPE_B_SELECT\t\t(1 << 30)\n\n\nstruct mid_intel_hdmi_priv {\n\tu32 hdmi_reg;\n\tu32 save_HDMIB;\n\tbool has_hdmi_sink;\n\tbool has_hdmi_audio;\n\t \n\tbool hdmi_device_connected;\n\tstruct drm_device *dev;\n};\n\nstatic void cdv_hdmi_mode_set(struct drm_encoder *encoder,\n\t\t\tstruct drm_display_mode *mode,\n\t\t\tstruct drm_display_mode *adjusted_mode)\n{\n\tstruct drm_device *dev = encoder->dev;\n\tstruct gma_encoder *gma_encoder = to_gma_encoder(encoder);\n\tstruct mid_intel_hdmi_priv *hdmi_priv = gma_encoder->dev_priv;\n\tu32 hdmib;\n\tstruct drm_crtc *crtc = encoder->crtc;\n\tstruct gma_crtc *gma_crtc = to_gma_crtc(crtc);\n\n\thdmib = (2 << 10);\n\n\tif (adjusted_mode->flags & DRM_MODE_FLAG_PVSYNC)\n\t\thdmib |= HDMI_VSYNC_ACTIVE_HIGH;\n\tif (adjusted_mode->flags & DRM_MODE_FLAG_PHSYNC)\n\t\thdmib |= HDMI_HSYNC_ACTIVE_HIGH;\n\n\tif (gma_crtc->pipe == 1)\n\t\thdmib |= HDMIB_PIPE_B_SELECT;\n\n\tif (hdmi_priv->has_hdmi_audio) {\n\t\thdmib |= HDMI_AUDIO_ENABLE;\n\t\thdmib |= HDMI_NULL_PACKETS_DURING_VSYNC;\n\t}\n\n\tREG_WRITE(hdmi_priv->hdmi_reg, hdmib);\n\tREG_READ(hdmi_priv->hdmi_reg);\n}\n\nstatic void cdv_hdmi_dpms(struct drm_encoder *encoder, int mode)\n{\n\tstruct drm_device *dev = encoder->dev;\n\tstruct gma_encoder *gma_encoder = to_gma_encoder(encoder);\n\tstruct mid_intel_hdmi_priv *hdmi_priv = gma_encoder->dev_priv;\n\tu32 hdmib;\n\n\thdmib = REG_READ(hdmi_priv->hdmi_reg);\n\n\tif (mode != DRM_MODE_DPMS_ON)\n\t\tREG_WRITE(hdmi_priv->hdmi_reg, hdmib & ~HDMIB_PORT_EN);\n\telse\n\t\tREG_WRITE(hdmi_priv->hdmi_reg, hdmib | HDMIB_PORT_EN);\n\tREG_READ(hdmi_priv->hdmi_reg);\n}\n\nstatic void cdv_hdmi_save(struct drm_connector *connector)\n{\n\tstruct drm_device *dev = connector->dev;\n\tstruct gma_encoder *gma_encoder = gma_attached_encoder(connector);\n\tstruct mid_intel_hdmi_priv *hdmi_priv = gma_encoder->dev_priv;\n\n\thdmi_priv->save_HDMIB = REG_READ(hdmi_priv->hdmi_reg);\n}\n\nstatic void cdv_hdmi_restore(struct drm_connector *connector)\n{\n\tstruct drm_device *dev = connector->dev;\n\tstruct gma_encoder *gma_encoder = gma_attached_encoder(connector);\n\tstruct mid_intel_hdmi_priv *hdmi_priv = gma_encoder->dev_priv;\n\n\tREG_WRITE(hdmi_priv->hdmi_reg, hdmi_priv->save_HDMIB);\n\tREG_READ(hdmi_priv->hdmi_reg);\n}\n\nstatic enum drm_connector_status cdv_hdmi_detect(\n\t\t\t\tstruct drm_connector *connector, bool force)\n{\n\tstruct gma_encoder *gma_encoder = gma_attached_encoder(connector);\n\tstruct mid_intel_hdmi_priv *hdmi_priv = gma_encoder->dev_priv;\n\tstruct edid *edid = NULL;\n\tenum drm_connector_status status = connector_status_disconnected;\n\n\tedid = drm_get_edid(connector, connector->ddc);\n\n\thdmi_priv->has_hdmi_sink = false;\n\thdmi_priv->has_hdmi_audio = false;\n\tif (edid) {\n\t\tif (edid->input & DRM_EDID_INPUT_DIGITAL) {\n\t\t\tstatus = connector_status_connected;\n\t\t\thdmi_priv->has_hdmi_sink =\n\t\t\t\t\t\tdrm_detect_hdmi_monitor(edid);\n\t\t\thdmi_priv->has_hdmi_audio =\n\t\t\t\t\t\tdrm_detect_monitor_audio(edid);\n\t\t}\n\t\tkfree(edid);\n\t}\n\treturn status;\n}\n\nstatic int cdv_hdmi_set_property(struct drm_connector *connector,\n\t\t\t\t       struct drm_property *property,\n\t\t\t\t       uint64_t value)\n{\n\tstruct drm_encoder *encoder = connector->encoder;\n\n\tif (!strcmp(property->name, \"scaling mode\") && encoder) {\n\t\tstruct gma_crtc *crtc = to_gma_crtc(encoder->crtc);\n\t\tbool centre;\n\t\tuint64_t curValue;\n\n\t\tif (!crtc)\n\t\t\treturn -1;\n\n\t\tswitch (value) {\n\t\tcase DRM_MODE_SCALE_FULLSCREEN:\n\t\t\tbreak;\n\t\tcase DRM_MODE_SCALE_NO_SCALE:\n\t\t\tbreak;\n\t\tcase DRM_MODE_SCALE_ASPECT:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -1;\n\t\t}\n\n\t\tif (drm_object_property_get_value(&connector->base,\n\t\t\t\t\t\t\tproperty, &curValue))\n\t\t\treturn -1;\n\n\t\tif (curValue == value)\n\t\t\treturn 0;\n\n\t\tif (drm_object_property_set_value(&connector->base,\n\t\t\t\t\t\t\tproperty, value))\n\t\t\treturn -1;\n\n\t\tcentre = (curValue == DRM_MODE_SCALE_NO_SCALE) ||\n\t\t\t(value == DRM_MODE_SCALE_NO_SCALE);\n\n\t\tif (crtc->saved_mode.hdisplay != 0 &&\n\t\t    crtc->saved_mode.vdisplay != 0) {\n\t\t\tif (centre) {\n\t\t\t\tif (!drm_crtc_helper_set_mode(encoder->crtc, &crtc->saved_mode,\n\t\t\t\t\t    encoder->crtc->x, encoder->crtc->y, encoder->crtc->primary->fb))\n\t\t\t\t\treturn -1;\n\t\t\t} else {\n\t\t\t\tconst struct drm_encoder_helper_funcs *helpers\n\t\t\t\t\t\t    = encoder->helper_private;\n\t\t\t\thelpers->mode_set(encoder, &crtc->saved_mode,\n\t\t\t\t\t     &crtc->saved_adjusted_mode);\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\n \nstatic int cdv_hdmi_get_modes(struct drm_connector *connector)\n{\n\tstruct edid *edid = NULL;\n\tint ret = 0;\n\n\tedid = drm_get_edid(connector, connector->ddc);\n\tif (edid) {\n\t\tdrm_connector_update_edid_property(connector, edid);\n\t\tret = drm_add_edid_modes(connector, edid);\n\t\tkfree(edid);\n\t}\n\treturn ret;\n}\n\nstatic enum drm_mode_status cdv_hdmi_mode_valid(struct drm_connector *connector,\n\t\t\t\t struct drm_display_mode *mode)\n{\n\tif (mode->clock > 165000)\n\t\treturn MODE_CLOCK_HIGH;\n\tif (mode->clock < 20000)\n\t\treturn MODE_CLOCK_HIGH;\n\n\t \n\tif (mode->flags & DRM_MODE_FLAG_DBLSCAN)\n\t\treturn MODE_NO_DBLESCAN;\n\n\t \n\tif (mode->flags & DRM_MODE_FLAG_INTERLACE)\n\t\treturn MODE_NO_INTERLACE;\n\n\treturn MODE_OK;\n}\n\nstatic void cdv_hdmi_destroy(struct drm_connector *connector)\n{\n\tstruct gma_connector *gma_connector = to_gma_connector(connector);\n\tstruct gma_i2c_chan *ddc_bus = to_gma_i2c_chan(connector->ddc);\n\n\tgma_i2c_destroy(ddc_bus);\n\tdrm_connector_cleanup(connector);\n\tkfree(gma_connector);\n}\n\nstatic const struct drm_encoder_helper_funcs cdv_hdmi_helper_funcs = {\n\t.dpms = cdv_hdmi_dpms,\n\t.prepare = gma_encoder_prepare,\n\t.mode_set = cdv_hdmi_mode_set,\n\t.commit = gma_encoder_commit,\n};\n\nstatic const struct drm_connector_helper_funcs\n\t\t\t\t\tcdv_hdmi_connector_helper_funcs = {\n\t.get_modes = cdv_hdmi_get_modes,\n\t.mode_valid = cdv_hdmi_mode_valid,\n\t.best_encoder = gma_best_encoder,\n};\n\nstatic const struct drm_connector_funcs cdv_hdmi_connector_funcs = {\n\t.dpms = drm_helper_connector_dpms,\n\t.detect = cdv_hdmi_detect,\n\t.fill_modes = drm_helper_probe_single_connector_modes,\n\t.set_property = cdv_hdmi_set_property,\n\t.destroy = cdv_hdmi_destroy,\n};\n\nvoid cdv_hdmi_init(struct drm_device *dev,\n\t\t\tstruct psb_intel_mode_device *mode_dev, int reg)\n{\n\tstruct gma_encoder *gma_encoder;\n\tstruct gma_connector *gma_connector;\n\tstruct drm_connector *connector;\n\tstruct mid_intel_hdmi_priv *hdmi_priv;\n\tstruct gma_i2c_chan *ddc_bus;\n\tint ddc_reg;\n\tint ret;\n\n\tgma_encoder = kzalloc(sizeof(struct gma_encoder), GFP_KERNEL);\n\tif (!gma_encoder)\n\t\treturn;\n\n\tgma_connector = kzalloc(sizeof(struct gma_connector), GFP_KERNEL);\n\tif (!gma_connector)\n\t\tgoto err_free_encoder;\n\n\thdmi_priv = kzalloc(sizeof(struct mid_intel_hdmi_priv), GFP_KERNEL);\n\tif (!hdmi_priv)\n\t\tgoto err_free_connector;\n\n\tconnector = &gma_connector->base;\n\tconnector->polled = DRM_CONNECTOR_POLL_HPD;\n\tgma_connector->save = cdv_hdmi_save;\n\tgma_connector->restore = cdv_hdmi_restore;\n\n\tswitch (reg) {\n\tcase SDVOB:\n\t\tddc_reg = GPIOE;\n\t\tgma_encoder->ddi_select = DDI0_SELECT;\n\t\tbreak;\n\tcase SDVOC:\n\t\tddc_reg = GPIOD;\n\t\tgma_encoder->ddi_select = DDI1_SELECT;\n\t\tbreak;\n\tdefault:\n\t\tDRM_ERROR(\"unknown reg 0x%x for HDMI\\n\", reg);\n\t\tgoto err_free_hdmi_priv;\n\t}\n\n\tddc_bus = gma_i2c_create(dev, ddc_reg,\n\t\t\t\t (reg == SDVOB) ? \"HDMIB\" : \"HDMIC\");\n\tif (!ddc_bus) {\n\t\tdev_err(dev->dev, \"No ddc adapter available!\\n\");\n\t\tgoto err_free_hdmi_priv;\n\t}\n\n\tret = drm_connector_init_with_ddc(dev, connector,\n\t\t\t\t\t  &cdv_hdmi_connector_funcs,\n\t\t\t\t\t  DRM_MODE_CONNECTOR_DVID,\n\t\t\t\t\t  &ddc_bus->base);\n\tif (ret)\n\t\tgoto err_ddc_destroy;\n\n\tret = drm_simple_encoder_init(dev, &gma_encoder->base,\n\t\t\t\t      DRM_MODE_ENCODER_TMDS);\n\tif (ret)\n\t\tgoto err_connector_cleanup;\n\n\tgma_connector_attach_encoder(gma_connector, gma_encoder);\n\tgma_encoder->type = INTEL_OUTPUT_HDMI;\n\thdmi_priv->hdmi_reg = reg;\n\thdmi_priv->has_hdmi_sink = false;\n\tgma_encoder->dev_priv = hdmi_priv;\n\n\tdrm_encoder_helper_add(&gma_encoder->base, &cdv_hdmi_helper_funcs);\n\tdrm_connector_helper_add(connector,\n\t\t\t\t &cdv_hdmi_connector_helper_funcs);\n\tconnector->display_info.subpixel_order = SubPixelHorizontalRGB;\n\tconnector->interlace_allowed = false;\n\tconnector->doublescan_allowed = false;\n\n\tdrm_object_attach_property(&connector->base,\n\t\t\t\t      dev->mode_config.scaling_mode_property,\n\t\t\t\t      DRM_MODE_SCALE_FULLSCREEN);\n\n\thdmi_priv->dev = dev;\n\treturn;\n\nerr_connector_cleanup:\n\tdrm_connector_cleanup(connector);\nerr_ddc_destroy:\n\tgma_i2c_destroy(ddc_bus);\nerr_free_hdmi_priv:\n\tkfree(hdmi_priv);\nerr_free_connector:\n\tkfree(gma_connector);\nerr_free_encoder:\n\tkfree(gma_encoder);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}