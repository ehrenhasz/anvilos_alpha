{
  "module_name": "oaktrail_device.c",
  "hash_id": "b75ebbc13a09d4511c2ddadaeb75b0b08dd70f2ee1bec13d4aefc3cb33616310",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/gma500/oaktrail_device.c",
  "human_readable_source": "\n \n\n#include <linux/delay.h>\n#include <linux/dmi.h>\n#include <linux/module.h>\n\n#include <drm/drm.h>\n\n#include \"intel_bios.h\"\n#include \"mid_bios.h\"\n#include \"psb_drv.h\"\n#include \"psb_intel_reg.h\"\n#include \"psb_reg.h\"\n\nstatic int oaktrail_output_init(struct drm_device *dev)\n{\n\tstruct drm_psb_private *dev_priv = to_drm_psb_private(dev);\n\tif (dev_priv->iLVDS_enable)\n\t\toaktrail_lvds_init(dev, &dev_priv->mode_dev);\n\telse\n\t\tdev_err(dev->dev, \"DSI is not supported\\n\");\n\tif (dev_priv->hdmi_priv)\n\t\toaktrail_hdmi_init(dev, &dev_priv->mode_dev);\n\n\tpsb_intel_sdvo_init(dev, SDVOB);\n\n\treturn 0;\n}\n\n \n\n#define MRST_BLC_MAX_PWM_REG_FREQ\t    0xFFFF\n#define BLC_PWM_PRECISION_FACTOR 100\t \n#define BLC_PWM_FREQ_CALC_CONSTANT 32\n#define MHz 1000000\n#define BLC_ADJUSTMENT_MAX 100\n\nstatic void oaktrail_set_brightness(struct drm_device *dev, int level)\n{\n\tstruct drm_psb_private *dev_priv = to_drm_psb_private(dev);\n\tu32 blc_pwm_ctl;\n\tu32 max_pwm_blc;\n\n\tif (gma_power_begin(dev, 0)) {\n\t\t \n\t\tmax_pwm_blc = REG_READ(BLC_PWM_CTL) >> 16;\n\t\tblc_pwm_ctl = level * max_pwm_blc / 100;\n\n\t\t \n\t\tblc_pwm_ctl = blc_pwm_ctl * dev_priv->blc_adj1;\n\t\tblc_pwm_ctl = blc_pwm_ctl / 100;\n\n\t\t \n\t\tblc_pwm_ctl = blc_pwm_ctl * dev_priv->blc_adj2;\n\t\tblc_pwm_ctl = blc_pwm_ctl / 100;\n\n\t\t \n\t\tREG_WRITE(BLC_PWM_CTL2, (0x80000000 | REG_READ(BLC_PWM_CTL2)));\n\t\tREG_WRITE(BLC_PWM_CTL, (max_pwm_blc << 16) | blc_pwm_ctl);\n\t\tgma_power_end(dev);\n\t}\n}\n\nstatic int oaktrail_backlight_init(struct drm_device *dev)\n{\n\tstruct drm_psb_private *dev_priv = to_drm_psb_private(dev);\n\tunsigned long core_clock;\n\tu16 bl_max_freq;\n\tuint32_t value;\n\tuint32_t blc_pwm_precision_factor;\n\n\tdev_priv->blc_adj1 = BLC_ADJUSTMENT_MAX;\n\tdev_priv->blc_adj2 = BLC_ADJUSTMENT_MAX;\n\tbl_max_freq = 256;\n\t \n\tblc_pwm_precision_factor = BLC_PWM_PRECISION_FACTOR;\n\n\tcore_clock = dev_priv->core_freq;\n\n\tvalue = (core_clock * MHz) / BLC_PWM_FREQ_CALC_CONSTANT;\n\tvalue *= blc_pwm_precision_factor;\n\tvalue /= bl_max_freq;\n\tvalue /= blc_pwm_precision_factor;\n\n\tif (value > (unsigned long long)MRST_BLC_MAX_PWM_REG_FREQ)\n\t\t\treturn -ERANGE;\n\n\tif (gma_power_begin(dev, false)) {\n\t\tREG_WRITE(BLC_PWM_CTL2, (0x80000000 | REG_READ(BLC_PWM_CTL2)));\n\t\tREG_WRITE(BLC_PWM_CTL, value | (value << 16));\n\t\tgma_power_end(dev);\n\t}\n\n\toaktrail_set_brightness(dev, PSB_MAX_BRIGHTNESS);\n\treturn 0;\n}\n\n \n\n \nstatic int oaktrail_save_display_registers(struct drm_device *dev)\n{\n\tstruct drm_psb_private *dev_priv = to_drm_psb_private(dev);\n\tstruct psb_save_area *regs = &dev_priv->regs;\n\tstruct psb_pipe *p = &regs->pipe[0];\n\tint i;\n\tu32 pp_stat;\n\n\t \n\tregs->psb.saveDSPARB = PSB_RVDC32(DSPARB);\n\tregs->psb.saveDSPFW1 = PSB_RVDC32(DSPFW1);\n\tregs->psb.saveDSPFW2 = PSB_RVDC32(DSPFW2);\n\tregs->psb.saveDSPFW3 = PSB_RVDC32(DSPFW3);\n\tregs->psb.saveDSPFW4 = PSB_RVDC32(DSPFW4);\n\tregs->psb.saveDSPFW5 = PSB_RVDC32(DSPFW5);\n\tregs->psb.saveDSPFW6 = PSB_RVDC32(DSPFW6);\n\tregs->psb.saveCHICKENBIT = PSB_RVDC32(DSPCHICKENBIT);\n\n\t \n\tp->conf = PSB_RVDC32(PIPEACONF);\n\tp->src = PSB_RVDC32(PIPEASRC);\n\tp->fp0 = PSB_RVDC32(MRST_FPA0);\n\tp->fp1 = PSB_RVDC32(MRST_FPA1);\n\tp->dpll = PSB_RVDC32(MRST_DPLL_A);\n\tp->htotal = PSB_RVDC32(HTOTAL_A);\n\tp->hblank = PSB_RVDC32(HBLANK_A);\n\tp->hsync = PSB_RVDC32(HSYNC_A);\n\tp->vtotal = PSB_RVDC32(VTOTAL_A);\n\tp->vblank = PSB_RVDC32(VBLANK_A);\n\tp->vsync = PSB_RVDC32(VSYNC_A);\n\tregs->psb.saveBCLRPAT_A = PSB_RVDC32(BCLRPAT_A);\n\tp->cntr = PSB_RVDC32(DSPACNTR);\n\tp->stride = PSB_RVDC32(DSPASTRIDE);\n\tp->addr = PSB_RVDC32(DSPABASE);\n\tp->surf = PSB_RVDC32(DSPASURF);\n\tp->linoff = PSB_RVDC32(DSPALINOFF);\n\tp->tileoff = PSB_RVDC32(DSPATILEOFF);\n\n\t \n\tregs->psb.saveDSPACURSOR_CTRL = PSB_RVDC32(CURACNTR);\n\tregs->psb.saveDSPACURSOR_BASE = PSB_RVDC32(CURABASE);\n\tregs->psb.saveDSPACURSOR_POS = PSB_RVDC32(CURAPOS);\n\n\t \n\tfor (i = 0; i < 256; i++)\n\t\tp->palette[i] = PSB_RVDC32(PALETTE_A + (i << 2));\n\n\tif (dev_priv->hdmi_priv)\n\t\toaktrail_hdmi_save(dev);\n\n\t \n\tregs->psb.savePERF_MODE = PSB_RVDC32(MRST_PERF_MODE);\n\n\t \n\tregs->psb.savePP_CONTROL = PSB_RVDC32(PP_CONTROL);\n\tregs->psb.savePFIT_PGM_RATIOS = PSB_RVDC32(PFIT_PGM_RATIOS);\n\tregs->psb.savePFIT_AUTO_RATIOS = PSB_RVDC32(PFIT_AUTO_RATIOS);\n\tregs->saveBLC_PWM_CTL = PSB_RVDC32(BLC_PWM_CTL);\n\tregs->saveBLC_PWM_CTL2 = PSB_RVDC32(BLC_PWM_CTL2);\n\tregs->psb.saveLVDS = PSB_RVDC32(LVDS);\n\tregs->psb.savePFIT_CONTROL = PSB_RVDC32(PFIT_CONTROL);\n\tregs->psb.savePP_ON_DELAYS = PSB_RVDC32(LVDSPP_ON);\n\tregs->psb.savePP_OFF_DELAYS = PSB_RVDC32(LVDSPP_OFF);\n\tregs->psb.savePP_DIVISOR = PSB_RVDC32(PP_CYCLE);\n\n\t \n\tregs->psb.saveOV_OVADD = PSB_RVDC32(OV_OVADD);\n\tregs->psb.saveOV_OGAMC0 = PSB_RVDC32(OV_OGAMC0);\n\tregs->psb.saveOV_OGAMC1 = PSB_RVDC32(OV_OGAMC1);\n\tregs->psb.saveOV_OGAMC2 = PSB_RVDC32(OV_OGAMC2);\n\tregs->psb.saveOV_OGAMC3 = PSB_RVDC32(OV_OGAMC3);\n\tregs->psb.saveOV_OGAMC4 = PSB_RVDC32(OV_OGAMC4);\n\tregs->psb.saveOV_OGAMC5 = PSB_RVDC32(OV_OGAMC5);\n\n\t \n\tregs->psb.saveHISTOGRAM_INT_CONTROL_REG =\n\t\t\t\t\tPSB_RVDC32(HISTOGRAM_INT_CONTROL);\n\tregs->psb.saveHISTOGRAM_LOGIC_CONTROL_REG =\n\t\t\t\t\tPSB_RVDC32(HISTOGRAM_LOGIC_CONTROL);\n\tregs->psb.savePWM_CONTROL_LOGIC = PSB_RVDC32(PWM_CONTROL_LOGIC);\n\n\tif (dev_priv->iLVDS_enable) {\n\t\t \n\t\tPSB_WVDC32(0, PP_CONTROL);\n\n\t\tdo {\n\t\t\tpp_stat = PSB_RVDC32(PP_STATUS);\n\t\t} while (pp_stat & 0x80000000);\n\n\t\t \n\t\tPSB_WVDC32(0x58000000, DSPACNTR);\n\t\t \n\t\tPSB_WVDC32(0, DSPASURF);\n\n\t\t \n\t\tmsleep(4);\n\n\t\t \n\t\tPSB_WVDC32(0x0, PIPEACONF);\n\t\t \n\t\tmsleep(8);\n\n\t\t \n\t\tPSB_WVDC32(0, MRST_DPLL_A);\n\t}\n\treturn 0;\n}\n\n \nstatic int oaktrail_restore_display_registers(struct drm_device *dev)\n{\n\tstruct drm_psb_private *dev_priv = to_drm_psb_private(dev);\n\tstruct psb_save_area *regs = &dev_priv->regs;\n\tstruct psb_pipe *p = &regs->pipe[0];\n\tu32 pp_stat;\n\tint i;\n\n\t \n\tPSB_WVDC32(regs->psb.saveDSPARB, DSPARB);\n\tPSB_WVDC32(regs->psb.saveDSPFW1, DSPFW1);\n\tPSB_WVDC32(regs->psb.saveDSPFW2, DSPFW2);\n\tPSB_WVDC32(regs->psb.saveDSPFW3, DSPFW3);\n\tPSB_WVDC32(regs->psb.saveDSPFW4, DSPFW4);\n\tPSB_WVDC32(regs->psb.saveDSPFW5, DSPFW5);\n\tPSB_WVDC32(regs->psb.saveDSPFW6, DSPFW6);\n\tPSB_WVDC32(regs->psb.saveCHICKENBIT, DSPCHICKENBIT);\n\n\t \n\tPSB_WVDC32(0x80000000, VGACNTRL);\n\n\t \n\tPSB_WVDC32(p->fp0, MRST_FPA0);\n\tPSB_WVDC32(p->fp1, MRST_FPA1);\n\n\t \n\tPSB_WVDC32(p->dpll, MRST_DPLL_A);\n\tudelay(150);\n\n\t \n\tPSB_WVDC32(p->htotal, HTOTAL_A);\n\tPSB_WVDC32(p->hblank, HBLANK_A);\n\tPSB_WVDC32(p->hsync, HSYNC_A);\n\tPSB_WVDC32(p->vtotal, VTOTAL_A);\n\tPSB_WVDC32(p->vblank, VBLANK_A);\n\tPSB_WVDC32(p->vsync, VSYNC_A);\n\tPSB_WVDC32(p->src, PIPEASRC);\n\tPSB_WVDC32(regs->psb.saveBCLRPAT_A, BCLRPAT_A);\n\n\t \n\tPSB_WVDC32(regs->psb.savePERF_MODE, MRST_PERF_MODE);\n\n\t \n\tif (dev_priv->iLVDS_enable)\n\t\tPSB_WVDC32(p->conf, PIPEACONF);\n\n\t \n\tPSB_WVDC32(p->linoff, DSPALINOFF);\n\tPSB_WVDC32(p->stride, DSPASTRIDE);\n\tPSB_WVDC32(p->tileoff, DSPATILEOFF);\n\n\t \n\tPSB_WVDC32(p->cntr, DSPACNTR);\n\tPSB_WVDC32(p->surf, DSPASURF);\n\n\t \n\tPSB_WVDC32(regs->psb.saveDSPACURSOR_CTRL, CURACNTR);\n\tPSB_WVDC32(regs->psb.saveDSPACURSOR_POS, CURAPOS);\n\tPSB_WVDC32(regs->psb.saveDSPACURSOR_BASE, CURABASE);\n\n\t \n\tfor (i = 0; i < 256; i++)\n\t\tPSB_WVDC32(p->palette[i], PALETTE_A + (i << 2));\n\n\tif (dev_priv->hdmi_priv)\n\t\toaktrail_hdmi_restore(dev);\n\n\tif (dev_priv->iLVDS_enable) {\n\t\tPSB_WVDC32(regs->saveBLC_PWM_CTL2, BLC_PWM_CTL2);\n\t\tPSB_WVDC32(regs->psb.saveLVDS, LVDS);  \n\t\tPSB_WVDC32(regs->psb.savePFIT_CONTROL, PFIT_CONTROL);\n\t\tPSB_WVDC32(regs->psb.savePFIT_PGM_RATIOS, PFIT_PGM_RATIOS);\n\t\tPSB_WVDC32(regs->psb.savePFIT_AUTO_RATIOS, PFIT_AUTO_RATIOS);\n\t\tPSB_WVDC32(regs->saveBLC_PWM_CTL, BLC_PWM_CTL);\n\t\tPSB_WVDC32(regs->psb.savePP_ON_DELAYS, LVDSPP_ON);\n\t\tPSB_WVDC32(regs->psb.savePP_OFF_DELAYS, LVDSPP_OFF);\n\t\tPSB_WVDC32(regs->psb.savePP_DIVISOR, PP_CYCLE);\n\t\tPSB_WVDC32(regs->psb.savePP_CONTROL, PP_CONTROL);\n\t}\n\n\t \n\tdo {\n\t\tpp_stat = PSB_RVDC32(PP_STATUS);\n\t} while (pp_stat & 0x08000000);\n\n\t \n\tdo {\n\t\tpp_stat = PSB_RVDC32(PP_STATUS);\n\t} while (pp_stat & 0x10000000);\n\n\t \n\tPSB_WVDC32(regs->psb.saveOV_OVADD, OV_OVADD);\n\tPSB_WVDC32(regs->psb.saveOV_OGAMC0, OV_OGAMC0);\n\tPSB_WVDC32(regs->psb.saveOV_OGAMC1, OV_OGAMC1);\n\tPSB_WVDC32(regs->psb.saveOV_OGAMC2, OV_OGAMC2);\n\tPSB_WVDC32(regs->psb.saveOV_OGAMC3, OV_OGAMC3);\n\tPSB_WVDC32(regs->psb.saveOV_OGAMC4, OV_OGAMC4);\n\tPSB_WVDC32(regs->psb.saveOV_OGAMC5, OV_OGAMC5);\n\n\t \n\tPSB_WVDC32(regs->psb.saveHISTOGRAM_INT_CONTROL_REG,\n\t\t\t\t\t\tHISTOGRAM_INT_CONTROL);\n\tPSB_WVDC32(regs->psb.saveHISTOGRAM_LOGIC_CONTROL_REG,\n\t\t\t\t\t\tHISTOGRAM_LOGIC_CONTROL);\n\tPSB_WVDC32(regs->psb.savePWM_CONTROL_LOGIC, PWM_CONTROL_LOGIC);\n\n\treturn 0;\n}\n\n \nstatic int oaktrail_power_down(struct drm_device *dev)\n{\n\tstruct drm_psb_private *dev_priv = to_drm_psb_private(dev);\n\tu32 pwr_mask ;\n\tu32 pwr_sts;\n\n\tpwr_mask = PSB_PWRGT_DISPLAY_MASK;\n\toutl(pwr_mask, dev_priv->ospm_base + PSB_PM_SSC);\n\n\twhile (true) {\n\t\tpwr_sts = inl(dev_priv->ospm_base + PSB_PM_SSS);\n\t\tif ((pwr_sts & pwr_mask) == pwr_mask)\n\t\t\tbreak;\n\t\telse\n\t\t\tudelay(10);\n\t}\n\treturn 0;\n}\n\n \nstatic int oaktrail_power_up(struct drm_device *dev)\n{\n\tstruct drm_psb_private *dev_priv = to_drm_psb_private(dev);\n\tu32 pwr_mask = PSB_PWRGT_DISPLAY_MASK;\n\tu32 pwr_sts, pwr_cnt;\n\n\tpwr_cnt = inl(dev_priv->ospm_base + PSB_PM_SSC);\n\tpwr_cnt &= ~pwr_mask;\n\toutl(pwr_cnt, (dev_priv->ospm_base + PSB_PM_SSC));\n\n\twhile (true) {\n\t\tpwr_sts = inl(dev_priv->ospm_base + PSB_PM_SSS);\n\t\tif ((pwr_sts & pwr_mask) == 0)\n\t\t\tbreak;\n\t\telse\n\t\t\tudelay(10);\n\t}\n\treturn 0;\n}\n\n \nstatic const struct psb_offset oaktrail_regmap[2] = {\n\t{\n\t\t.fp0 = MRST_FPA0,\n\t\t.fp1 = MRST_FPA1,\n\t\t.cntr = DSPACNTR,\n\t\t.conf = PIPEACONF,\n\t\t.src = PIPEASRC,\n\t\t.dpll = MRST_DPLL_A,\n\t\t.htotal = HTOTAL_A,\n\t\t.hblank = HBLANK_A,\n\t\t.hsync = HSYNC_A,\n\t\t.vtotal = VTOTAL_A,\n\t\t.vblank = VBLANK_A,\n\t\t.vsync = VSYNC_A,\n\t\t.stride = DSPASTRIDE,\n\t\t.size = DSPASIZE,\n\t\t.pos = DSPAPOS,\n\t\t.surf = DSPASURF,\n\t\t.addr = MRST_DSPABASE,\n\t\t.base = MRST_DSPABASE,\n\t\t.status = PIPEASTAT,\n\t\t.linoff = DSPALINOFF,\n\t\t.tileoff = DSPATILEOFF,\n\t\t.palette = PALETTE_A,\n\t},\n\t{\n\t\t.fp0 = FPB0,\n\t\t.fp1 = FPB1,\n\t\t.cntr = DSPBCNTR,\n\t\t.conf = PIPEBCONF,\n\t\t.src = PIPEBSRC,\n\t\t.dpll = DPLL_B,\n\t\t.htotal = HTOTAL_B,\n\t\t.hblank = HBLANK_B,\n\t\t.hsync = HSYNC_B,\n\t\t.vtotal = VTOTAL_B,\n\t\t.vblank = VBLANK_B,\n\t\t.vsync = VSYNC_B,\n\t\t.stride = DSPBSTRIDE,\n\t\t.size = DSPBSIZE,\n\t\t.pos = DSPBPOS,\n\t\t.surf = DSPBSURF,\n\t\t.addr = DSPBBASE,\n\t\t.base = DSPBBASE,\n\t\t.status = PIPEBSTAT,\n\t\t.linoff = DSPBLINOFF,\n\t\t.tileoff = DSPBTILEOFF,\n\t\t.palette = PALETTE_B,\n\t},\n};\n\nstatic int oaktrail_chip_setup(struct drm_device *dev)\n{\n\tstruct drm_psb_private *dev_priv = to_drm_psb_private(dev);\n\tint ret;\n\n\tdev_priv->use_msi = true;\n\tdev_priv->regmap = oaktrail_regmap;\n\n\tret = mid_chip_setup(dev);\n\tif (ret < 0)\n\t\treturn ret;\n\tif (!dev_priv->has_gct) {\n\t\t \n\t\tpsb_intel_opregion_init(dev);\n\t\tpsb_intel_init_bios(dev);\n\t}\n\tgma_intel_setup_gmbus(dev);\n\toaktrail_hdmi_setup(dev);\n\treturn 0;\n}\n\nstatic void oaktrail_teardown(struct drm_device *dev)\n{\n\tstruct drm_psb_private *dev_priv = to_drm_psb_private(dev);\n\n\tgma_intel_teardown_gmbus(dev);\n\toaktrail_hdmi_teardown(dev);\n\tif (!dev_priv->has_gct)\n\t\tpsb_intel_destroy_bios(dev);\n}\n\nconst struct psb_ops oaktrail_chip_ops = {\n\t.name = \"Oaktrail\",\n\t.pipes = 2,\n\t.crtcs = 2,\n\t.hdmi_mask = (1 << 1),\n\t.lvds_mask = (1 << 0),\n\t.sdvo_mask = (1 << 1),\n\t.cursor_needs_phys = 0,\n\t.sgx_offset = MRST_SGX_OFFSET,\n\n\t.chip_setup = oaktrail_chip_setup,\n\t.chip_teardown = oaktrail_teardown,\n\t.crtc_helper = &oaktrail_helper_funcs,\n\n\t.output_init = oaktrail_output_init,\n\n\t.backlight_init = oaktrail_backlight_init,\n\t.backlight_set = oaktrail_set_brightness,\n\t.backlight_name = \"oaktrail-bl\",\n\n\t.save_regs = oaktrail_save_display_registers,\n\t.restore_regs = oaktrail_restore_display_registers,\n\t.save_crtc = gma_crtc_save,\n\t.restore_crtc = gma_crtc_restore,\n\t.power_down = oaktrail_power_down,\n\t.power_up = oaktrail_power_up,\n\n\t.i2c_bus = 1,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}