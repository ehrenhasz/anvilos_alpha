{
  "module_name": "psb_device.c",
  "hash_id": "9a95a282c4811960ba290a7fd674c1ab1f29c4630407e5a0db63960cf4294a64",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/gma500/psb_device.c",
  "human_readable_source": "\n \n\n#include <drm/drm.h>\n#include <drm/drm_crtc_helper.h>\n\n#include \"gma_device.h\"\n#include \"intel_bios.h\"\n#include \"psb_device.h\"\n#include \"psb_drv.h\"\n#include \"psb_intel_reg.h\"\n#include \"psb_reg.h\"\n\nstatic int psb_output_init(struct drm_device *dev)\n{\n\tstruct drm_psb_private *dev_priv = to_drm_psb_private(dev);\n\tpsb_intel_lvds_init(dev, &dev_priv->mode_dev);\n\tpsb_intel_sdvo_init(dev, SDVOB);\n\treturn 0;\n}\n\n \n\n#define BLC_PWM_PRECISION_FACTOR 100\t \n#define BLC_PWM_FREQ_CALC_CONSTANT 32\n#define MHz 1000000\n\n#define PSB_BLC_PWM_PRECISION_FACTOR    10\n#define PSB_BLC_MAX_PWM_REG_FREQ        0xFFFE\n#define PSB_BLC_MIN_PWM_REG_FREQ        0x2\n\n#define PSB_BACKLIGHT_PWM_POLARITY_BIT_CLEAR (0xFFFE)\n#define PSB_BACKLIGHT_PWM_CTL_SHIFT\t(16)\n\nstatic int psb_backlight_setup(struct drm_device *dev)\n{\n\tstruct drm_psb_private *dev_priv = to_drm_psb_private(dev);\n\tunsigned long core_clock;\n\t \n\t \n\tu16 bl_max_freq;\n\tuint32_t value;\n\tuint32_t blc_pwm_precision_factor;\n\n\t \n\tif (!dev_priv->lvds_bl) {\n\t\tdev_err(dev->dev, \"Has no valid LVDS backlight info\\n\");\n\t\treturn -ENOENT;\n\t}\n\tbl_max_freq = dev_priv->lvds_bl->freq;\n\tblc_pwm_precision_factor = PSB_BLC_PWM_PRECISION_FACTOR;\n\n\tcore_clock = dev_priv->core_freq;\n\n\tvalue = (core_clock * MHz) / BLC_PWM_FREQ_CALC_CONSTANT;\n\tvalue *= blc_pwm_precision_factor;\n\tvalue /= bl_max_freq;\n\tvalue /= blc_pwm_precision_factor;\n\n\tif (value > (unsigned long long)PSB_BLC_MAX_PWM_REG_FREQ ||\n\t\t value < (unsigned long long)PSB_BLC_MIN_PWM_REG_FREQ)\n\t\t\t\treturn -ERANGE;\n\telse {\n\t\tvalue &= PSB_BACKLIGHT_PWM_POLARITY_BIT_CLEAR;\n\t\tREG_WRITE(BLC_PWM_CTL,\n\t\t\t(value << PSB_BACKLIGHT_PWM_CTL_SHIFT) | (value));\n\t}\n\n\tpsb_intel_lvds_set_brightness(dev, PSB_MAX_BRIGHTNESS);\n\t \n\tpsb_lid_timer_init(dev_priv);\n\treturn 0;\n}\n\n \n\nstatic void psb_init_pm(struct drm_device *dev)\n{\n\tstruct drm_psb_private *dev_priv = to_drm_psb_private(dev);\n\n\tu32 gating = PSB_RSGX32(PSB_CR_CLKGATECTL);\n\tgating &= ~3;\t \n\tgating |= 1;\n\tPSB_WSGX32(gating, PSB_CR_CLKGATECTL);\n\tPSB_RSGX32(PSB_CR_CLKGATECTL);\n}\n\n \nstatic int psb_save_display_registers(struct drm_device *dev)\n{\n\tstruct drm_psb_private *dev_priv = to_drm_psb_private(dev);\n\tstruct gma_connector *gma_connector;\n\tstruct drm_crtc *crtc;\n\tstruct drm_connector_list_iter conn_iter;\n\tstruct drm_connector *connector;\n\tstruct psb_state *regs = &dev_priv->regs.psb;\n\n\t \n\tregs->saveDSPARB = PSB_RVDC32(DSPARB);\n\tregs->saveDSPFW1 = PSB_RVDC32(DSPFW1);\n\tregs->saveDSPFW2 = PSB_RVDC32(DSPFW2);\n\tregs->saveDSPFW3 = PSB_RVDC32(DSPFW3);\n\tregs->saveDSPFW4 = PSB_RVDC32(DSPFW4);\n\tregs->saveDSPFW5 = PSB_RVDC32(DSPFW5);\n\tregs->saveDSPFW6 = PSB_RVDC32(DSPFW6);\n\tregs->saveCHICKENBIT = PSB_RVDC32(DSPCHICKENBIT);\n\n\t \n\tdrm_modeset_lock_all(dev);\n\tlist_for_each_entry(crtc, &dev->mode_config.crtc_list, head) {\n\t\tif (drm_helper_crtc_in_use(crtc))\n\t\t\tdev_priv->ops->save_crtc(crtc);\n\t}\n\n\tdrm_connector_list_iter_begin(dev, &conn_iter);\n\tdrm_for_each_connector_iter(connector, &conn_iter) {\n\t\tgma_connector = to_gma_connector(connector);\n\t\tif (gma_connector->save)\n\t\t\tgma_connector->save(connector);\n\t}\n\tdrm_connector_list_iter_end(&conn_iter);\n\n\tdrm_modeset_unlock_all(dev);\n\treturn 0;\n}\n\n \nstatic int psb_restore_display_registers(struct drm_device *dev)\n{\n\tstruct drm_psb_private *dev_priv = to_drm_psb_private(dev);\n\tstruct gma_connector *gma_connector;\n\tstruct drm_crtc *crtc;\n\tstruct drm_connector_list_iter conn_iter;\n\tstruct drm_connector *connector;\n\tstruct psb_state *regs = &dev_priv->regs.psb;\n\n\t \n\tPSB_WVDC32(regs->saveDSPARB, DSPARB);\n\tPSB_WVDC32(regs->saveDSPFW1, DSPFW1);\n\tPSB_WVDC32(regs->saveDSPFW2, DSPFW2);\n\tPSB_WVDC32(regs->saveDSPFW3, DSPFW3);\n\tPSB_WVDC32(regs->saveDSPFW4, DSPFW4);\n\tPSB_WVDC32(regs->saveDSPFW5, DSPFW5);\n\tPSB_WVDC32(regs->saveDSPFW6, DSPFW6);\n\tPSB_WVDC32(regs->saveCHICKENBIT, DSPCHICKENBIT);\n\n\t \n\tPSB_WVDC32(0x80000000, VGACNTRL);\n\n\tdrm_modeset_lock_all(dev);\n\tlist_for_each_entry(crtc, &dev->mode_config.crtc_list, head)\n\t\tif (drm_helper_crtc_in_use(crtc))\n\t\t\tdev_priv->ops->restore_crtc(crtc);\n\n\tdrm_connector_list_iter_begin(dev, &conn_iter);\n\tdrm_for_each_connector_iter(connector, &conn_iter) {\n\t\tgma_connector = to_gma_connector(connector);\n\t\tif (gma_connector->restore)\n\t\t\tgma_connector->restore(connector);\n\t}\n\tdrm_connector_list_iter_end(&conn_iter);\n\n\tdrm_modeset_unlock_all(dev);\n\treturn 0;\n}\n\nstatic int psb_power_down(struct drm_device *dev)\n{\n\treturn 0;\n}\n\nstatic int psb_power_up(struct drm_device *dev)\n{\n\treturn 0;\n}\n\n \nstatic const struct psb_offset psb_regmap[2] = {\n\t{\n\t\t.fp0 = FPA0,\n\t\t.fp1 = FPA1,\n\t\t.cntr = DSPACNTR,\n\t\t.conf = PIPEACONF,\n\t\t.src = PIPEASRC,\n\t\t.dpll = DPLL_A,\n\t\t.htotal = HTOTAL_A,\n\t\t.hblank = HBLANK_A,\n\t\t.hsync = HSYNC_A,\n\t\t.vtotal = VTOTAL_A,\n\t\t.vblank = VBLANK_A,\n\t\t.vsync = VSYNC_A,\n\t\t.stride = DSPASTRIDE,\n\t\t.size = DSPASIZE,\n\t\t.pos = DSPAPOS,\n\t\t.base = DSPABASE,\n\t\t.surf = DSPASURF,\n\t\t.addr = DSPABASE,\n\t\t.status = PIPEASTAT,\n\t\t.linoff = DSPALINOFF,\n\t\t.tileoff = DSPATILEOFF,\n\t\t.palette = PALETTE_A,\n\t},\n\t{\n\t\t.fp0 = FPB0,\n\t\t.fp1 = FPB1,\n\t\t.cntr = DSPBCNTR,\n\t\t.conf = PIPEBCONF,\n\t\t.src = PIPEBSRC,\n\t\t.dpll = DPLL_B,\n\t\t.htotal = HTOTAL_B,\n\t\t.hblank = HBLANK_B,\n\t\t.hsync = HSYNC_B,\n\t\t.vtotal = VTOTAL_B,\n\t\t.vblank = VBLANK_B,\n\t\t.vsync = VSYNC_B,\n\t\t.stride = DSPBSTRIDE,\n\t\t.size = DSPBSIZE,\n\t\t.pos = DSPBPOS,\n\t\t.base = DSPBBASE,\n\t\t.surf = DSPBSURF,\n\t\t.addr = DSPBBASE,\n\t\t.status = PIPEBSTAT,\n\t\t.linoff = DSPBLINOFF,\n\t\t.tileoff = DSPBTILEOFF,\n\t\t.palette = PALETTE_B,\n\t}\n};\n\nstatic int psb_chip_setup(struct drm_device *dev)\n{\n\tstruct drm_psb_private *dev_priv = to_drm_psb_private(dev);\n\tdev_priv->regmap = psb_regmap;\n\tgma_get_core_freq(dev);\n\tgma_intel_setup_gmbus(dev);\n\tpsb_intel_opregion_init(dev);\n\tpsb_intel_init_bios(dev);\n\treturn 0;\n}\n\nstatic void psb_chip_teardown(struct drm_device *dev)\n{\n\tstruct drm_psb_private *dev_priv = to_drm_psb_private(dev);\n\tpsb_lid_timer_takedown(dev_priv);\n\tgma_intel_teardown_gmbus(dev);\n}\n\nconst struct psb_ops psb_chip_ops = {\n\t.name = \"Poulsbo\",\n\t.pipes = 2,\n\t.crtcs = 2,\n\t.hdmi_mask = (1 << 0),\n\t.lvds_mask = (1 << 1),\n\t.sdvo_mask = (1 << 0),\n\t.cursor_needs_phys = 1,\n\t.sgx_offset = PSB_SGX_OFFSET,\n\t.chip_setup = psb_chip_setup,\n\t.chip_teardown = psb_chip_teardown,\n\n\t.crtc_helper = &psb_intel_helper_funcs,\n\t.clock_funcs = &psb_clock_funcs,\n\n\t.output_init = psb_output_init,\n\n\t.backlight_init = psb_backlight_setup,\n\t.backlight_set = psb_intel_lvds_set_brightness,\n\t.backlight_name = \"psb-bl\",\n\n\t.init_pm = psb_init_pm,\n\t.save_regs = psb_save_display_registers,\n\t.restore_regs = psb_restore_display_registers,\n\t.save_crtc = gma_crtc_save,\n\t.restore_crtc = gma_crtc_restore,\n\t.power_down = psb_power_down,\n\t.power_up = psb_power_up,\n};\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}