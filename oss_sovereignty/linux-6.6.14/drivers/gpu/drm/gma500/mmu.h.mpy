{
  "module_name": "mmu.h",
  "hash_id": "5edfcff5a42104dc903baecf0aa5c9afca005664afa827556b046677a1f8492f",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/gma500/mmu.h",
  "human_readable_source": " \n \n\n#ifndef __MMU_H\n#define __MMU_H\n\nstruct psb_mmu_driver {\n\t \n\tstruct rw_semaphore sem;\n\n\t \n\tspinlock_t lock;\n\n\tatomic_t needs_tlbflush;\n\tatomic_t *msvdx_mmu_invaldc;\n\tstruct psb_mmu_pd *default_pd;\n\tuint32_t bif_ctrl;\n\tint has_clflush;\n\tint clflush_add;\n\tunsigned long clflush_mask;\n\n\tstruct drm_device *dev;\n};\n\nstruct psb_mmu_pd;\n\nstruct psb_mmu_pt {\n\tstruct psb_mmu_pd *pd;\n\tuint32_t index;\n\tuint32_t count;\n\tstruct page *p;\n\tuint32_t *v;\n};\n\nstruct psb_mmu_pd {\n\tstruct psb_mmu_driver *driver;\n\tint hw_context;\n\tstruct psb_mmu_pt **tables;\n\tstruct page *p;\n\tstruct page *dummy_pt;\n\tstruct page *dummy_page;\n\tuint32_t pd_mask;\n\tuint32_t invalid_pde;\n\tuint32_t invalid_pte;\n};\n\nextern struct psb_mmu_driver *psb_mmu_driver_init(struct drm_device *dev,\n\t\t\t\t\t\t  int trap_pagefaults,\n\t\t\t\t\t\t  int invalid_type,\n\t\t\t\t\t\t  atomic_t *msvdx_mmu_invaldc);\nextern void psb_mmu_driver_takedown(struct psb_mmu_driver *driver);\nextern struct psb_mmu_pd *psb_mmu_get_default_pd(struct psb_mmu_driver\n\t\t\t\t\t\t *driver);\nextern struct psb_mmu_pd *psb_mmu_alloc_pd(struct psb_mmu_driver *driver,\n\t\t\t\t\t   int trap_pagefaults,\n\t\t\t\t\t   int invalid_type);\nextern void psb_mmu_free_pagedir(struct psb_mmu_pd *pd);\nextern void psb_mmu_flush(struct psb_mmu_driver *driver);\nextern void psb_mmu_remove_pfn_sequence(struct psb_mmu_pd *pd,\n\t\t\t\t\tunsigned long address,\n\t\t\t\t\tuint32_t num_pages);\nextern int psb_mmu_insert_pfn_sequence(struct psb_mmu_pd *pd,\n\t\t\t\t       uint32_t start_pfn,\n\t\t\t\t       unsigned long address,\n\t\t\t\t       uint32_t num_pages, int type);\nextern int psb_mmu_virtual_to_pfn(struct psb_mmu_pd *pd, uint32_t virtual,\n\t\t\t\t  unsigned long *pfn);\nextern void psb_mmu_set_pd_context(struct psb_mmu_pd *pd, int hw_context);\nextern int psb_mmu_insert_pages(struct psb_mmu_pd *pd, struct page **pages,\n\t\t\t\tunsigned long address, uint32_t num_pages,\n\t\t\t\tuint32_t desired_tile_stride,\n\t\t\t\tuint32_t hw_tile_stride, int type);\nextern void psb_mmu_remove_pages(struct psb_mmu_pd *pd,\n\t\t\t\t unsigned long address, uint32_t num_pages,\n\t\t\t\t uint32_t desired_tile_stride,\n\t\t\t\t uint32_t hw_tile_stride);\n\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}