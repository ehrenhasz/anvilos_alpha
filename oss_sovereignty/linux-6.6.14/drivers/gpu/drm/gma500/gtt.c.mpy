{
  "module_name": "gtt.c",
  "hash_id": "ab3bd8a296b7c3c604f6e641f11ec802026dd6bc2dc363f2d19a755f39309192",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/gma500/gtt.c",
  "human_readable_source": "\n \n\n#include \"gem.h\"  \n#include \"psb_drv.h\"\n\n\n \n\nint psb_gtt_allocate_resource(struct drm_psb_private *pdev, struct resource *res,\n\t\t\t      const char *name, resource_size_t size, resource_size_t align,\n\t\t\t      bool stolen, u32 *offset)\n{\n\tstruct resource *root = pdev->gtt_mem;\n\tresource_size_t start, end;\n\tint ret;\n\n\tif (stolen) {\n\t\t \n\t\tstart = root->start;\n\t\tend = root->start + pdev->gtt.stolen_size - 1;\n\t} else {\n\t\t \n\t\tstart = root->start + pdev->gtt.stolen_size;\n\t\tend = root->end;\n\t}\n\n\tres->name = name;\n\tret = allocate_resource(root, res, size, start, end, align, NULL, NULL);\n\tif (ret)\n\t\treturn ret;\n\t*offset = res->start - root->start;\n\n\treturn 0;\n}\n\n \nuint32_t psb_gtt_mask_pte(uint32_t pfn, int type)\n{\n\tuint32_t mask = PSB_PTE_VALID;\n\n\t \n\tBUG_ON(pfn & ~(0xFFFFFFFF >> PAGE_SHIFT));\n\n\tif (type & PSB_MMU_CACHED_MEMORY)\n\t\tmask |= PSB_PTE_CACHED;\n\tif (type & PSB_MMU_RO_MEMORY)\n\t\tmask |= PSB_PTE_RO;\n\tif (type & PSB_MMU_WO_MEMORY)\n\t\tmask |= PSB_PTE_WO;\n\n\treturn (pfn << PAGE_SHIFT) | mask;\n}\n\nstatic u32 __iomem *psb_gtt_entry(struct drm_psb_private *pdev, const struct resource *res)\n{\n\tunsigned long offset = res->start - pdev->gtt_mem->start;\n\n\treturn pdev->gtt_map + (offset >> PAGE_SHIFT);\n}\n\n \nvoid psb_gtt_insert_pages(struct drm_psb_private *pdev, const struct resource *res,\n\t\t\t  struct page **pages)\n{\n\tresource_size_t npages, i;\n\tu32 __iomem *gtt_slot;\n\tu32 pte;\n\n\tmutex_lock(&pdev->gtt_mutex);\n\n\t \n\n\tnpages = resource_size(res) >> PAGE_SHIFT;\n\tgtt_slot = psb_gtt_entry(pdev, res);\n\n\tfor (i = 0; i < npages; ++i, ++gtt_slot) {\n\t\tpte = psb_gtt_mask_pte(page_to_pfn(pages[i]), PSB_MMU_CACHED_MEMORY);\n\t\tiowrite32(pte, gtt_slot);\n\t}\n\n\t \n\tioread32(gtt_slot - 1);\n\n\tmutex_unlock(&pdev->gtt_mutex);\n}\n\n \nvoid psb_gtt_remove_pages(struct drm_psb_private *pdev, const struct resource *res)\n{\n\tresource_size_t npages, i;\n\tu32 __iomem *gtt_slot;\n\tu32 pte;\n\n\tmutex_lock(&pdev->gtt_mutex);\n\n\t \n\n\tpte = psb_gtt_mask_pte(page_to_pfn(pdev->scratch_page), PSB_MMU_CACHED_MEMORY);\n\n\tnpages = resource_size(res) >> PAGE_SHIFT;\n\tgtt_slot = psb_gtt_entry(pdev, res);\n\n\tfor (i = 0; i < npages; ++i, ++gtt_slot)\n\t\tiowrite32(pte, gtt_slot);\n\n\t \n\tioread32(gtt_slot - 1);\n\n\tmutex_unlock(&pdev->gtt_mutex);\n}\n\nstatic int psb_gtt_enable(struct drm_psb_private *dev_priv)\n{\n\tstruct drm_device *dev = &dev_priv->dev;\n\tstruct pci_dev *pdev = to_pci_dev(dev->dev);\n\tint ret;\n\n\tret = pci_read_config_word(pdev, PSB_GMCH_CTRL, &dev_priv->gmch_ctrl);\n\tif (ret)\n\t\treturn pcibios_err_to_errno(ret);\n\tret = pci_write_config_word(pdev, PSB_GMCH_CTRL, dev_priv->gmch_ctrl | _PSB_GMCH_ENABLED);\n\tif (ret)\n\t\treturn pcibios_err_to_errno(ret);\n\n\tdev_priv->pge_ctl = PSB_RVDC32(PSB_PGETBL_CTL);\n\tPSB_WVDC32(dev_priv->pge_ctl | _PSB_PGETBL_ENABLED, PSB_PGETBL_CTL);\n\n\t(void)PSB_RVDC32(PSB_PGETBL_CTL);\n\n\treturn 0;\n}\n\nstatic void psb_gtt_disable(struct drm_psb_private *dev_priv)\n{\n\tstruct drm_device *dev = &dev_priv->dev;\n\tstruct pci_dev *pdev = to_pci_dev(dev->dev);\n\n\tpci_write_config_word(pdev, PSB_GMCH_CTRL, dev_priv->gmch_ctrl);\n\tPSB_WVDC32(dev_priv->pge_ctl, PSB_PGETBL_CTL);\n\n\t(void)PSB_RVDC32(PSB_PGETBL_CTL);\n}\n\nvoid psb_gtt_fini(struct drm_device *dev)\n{\n\tstruct drm_psb_private *dev_priv = to_drm_psb_private(dev);\n\n\tiounmap(dev_priv->gtt_map);\n\tpsb_gtt_disable(dev_priv);\n\tmutex_destroy(&dev_priv->gtt_mutex);\n}\n\n \nstatic void psb_gtt_clear(struct drm_psb_private *pdev)\n{\n\tresource_size_t pfn_base;\n\tunsigned long i;\n\tuint32_t pte;\n\n\tpfn_base = page_to_pfn(pdev->scratch_page);\n\tpte = psb_gtt_mask_pte(pfn_base, PSB_MMU_CACHED_MEMORY);\n\n\tfor (i = 0; i < pdev->gtt.gtt_pages; ++i)\n\t\tiowrite32(pte, pdev->gtt_map + i);\n\n\t(void)ioread32(pdev->gtt_map + i - 1);\n}\n\nstatic void psb_gtt_init_ranges(struct drm_psb_private *dev_priv)\n{\n\tstruct drm_device *dev = &dev_priv->dev;\n\tstruct pci_dev *pdev = to_pci_dev(dev->dev);\n\tstruct psb_gtt *pg = &dev_priv->gtt;\n\tresource_size_t gtt_phys_start, mmu_gatt_start, gtt_start, gtt_pages,\n\t\t\tgatt_start, gatt_pages;\n\tstruct resource *gtt_mem;\n\n\t \n\tgtt_phys_start = dev_priv->pge_ctl & PAGE_MASK;\n\n\t \n\tmmu_gatt_start = 0xe0000000;\n\n\tgtt_start = pci_resource_start(pdev, PSB_GTT_RESOURCE);\n\tgtt_pages = pci_resource_len(pdev, PSB_GTT_RESOURCE) >> PAGE_SHIFT;\n\n\t \n\tif (!gtt_start || !gtt_pages) {\n\t\tdev_dbg(dev->dev, \"GTT PCI BAR not initialized.\\n\");\n\t\tgtt_pages = 64;\n\t\tgtt_start = dev_priv->pge_ctl;\n\t}\n\n\tgatt_start = pci_resource_start(pdev, PSB_GATT_RESOURCE);\n\tgatt_pages = pci_resource_len(pdev, PSB_GATT_RESOURCE) >> PAGE_SHIFT;\n\n\tif (!gatt_pages || !gatt_start) {\n\t\tstatic struct resource fudge;\t \n\n\t\t \n\t\tdev_dbg(dev->dev, \"GATT PCI BAR not initialized.\\n\");\n\t\tgatt_start = 0x40000000;\n\t\tgatt_pages = (128 * 1024 * 1024) >> PAGE_SHIFT;\n\n\t\t \n\t\tfudge.start = 0x40000000;\n\t\tfudge.end = 0x40000000 + 128 * 1024 * 1024 - 1;\n\t\tfudge.name = \"fudge\";\n\t\tfudge.flags = IORESOURCE_MEM;\n\n\t\tgtt_mem = &fudge;\n\t} else {\n\t\tgtt_mem = &pdev->resource[PSB_GATT_RESOURCE];\n\t}\n\n\tpg->gtt_phys_start = gtt_phys_start;\n\tpg->mmu_gatt_start = mmu_gatt_start;\n\tpg->gtt_start = gtt_start;\n\tpg->gtt_pages = gtt_pages;\n\tpg->gatt_start = gatt_start;\n\tpg->gatt_pages = gatt_pages;\n\tdev_priv->gtt_mem = gtt_mem;\n}\n\nint psb_gtt_init(struct drm_device *dev)\n{\n\tstruct drm_psb_private *dev_priv = to_drm_psb_private(dev);\n\tstruct psb_gtt *pg = &dev_priv->gtt;\n\tint ret;\n\n\tmutex_init(&dev_priv->gtt_mutex);\n\n\tret = psb_gtt_enable(dev_priv);\n\tif (ret)\n\t\tgoto err_mutex_destroy;\n\n\tpsb_gtt_init_ranges(dev_priv);\n\n\tdev_priv->gtt_map = ioremap(pg->gtt_phys_start, pg->gtt_pages << PAGE_SHIFT);\n\tif (!dev_priv->gtt_map) {\n\t\tdev_err(dev->dev, \"Failure to map gtt.\\n\");\n\t\tret = -ENOMEM;\n\t\tgoto err_psb_gtt_disable;\n\t}\n\n\tpsb_gtt_clear(dev_priv);\n\n\treturn 0;\n\nerr_psb_gtt_disable:\n\tpsb_gtt_disable(dev_priv);\nerr_mutex_destroy:\n\tmutex_destroy(&dev_priv->gtt_mutex);\n\treturn ret;\n}\n\nint psb_gtt_resume(struct drm_device *dev)\n{\n\tstruct drm_psb_private *dev_priv = to_drm_psb_private(dev);\n\tstruct psb_gtt *pg = &dev_priv->gtt;\n\tunsigned int old_gtt_pages = pg->gtt_pages;\n\tint ret;\n\n\t \n\tret = psb_gtt_enable(dev_priv);\n\tif (ret)\n\t\treturn ret;\n\n\tpsb_gtt_init_ranges(dev_priv);\n\n\tif (old_gtt_pages != pg->gtt_pages) {\n\t\tdev_err(dev->dev, \"GTT resume error.\\n\");\n\t\tret = -ENODEV;\n\t\tgoto err_psb_gtt_disable;\n\t}\n\n\tpsb_gtt_clear(dev_priv);\n\nerr_psb_gtt_disable:\n\tpsb_gtt_disable(dev_priv);\n\treturn ret;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}