{
  "module_name": "psb_intel_display.c",
  "hash_id": "de8d27ea6e93e03455d7d4f37c5e02811b4676817f5481b34909b8611532fb0f",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/gma500/psb_intel_display.c",
  "human_readable_source": "\n \n\n#include <linux/delay.h>\n#include <linux/i2c.h>\n\n#include <drm/drm_modeset_helper.h>\n#include <drm/drm_modeset_helper_vtables.h>\n\n#include \"framebuffer.h\"\n#include \"gem.h\"\n#include \"gma_display.h\"\n#include \"power.h\"\n#include \"psb_drv.h\"\n#include \"psb_intel_drv.h\"\n#include \"psb_intel_reg.h\"\n\n#define INTEL_LIMIT_I9XX_SDVO_DAC   0\n#define INTEL_LIMIT_I9XX_LVDS\t    1\n\nstatic const struct gma_limit_t psb_intel_limits[] = {\n\t{\t\t\t \n\t .dot = {.min = 20000, .max = 400000},\n\t .vco = {.min = 1400000, .max = 2800000},\n\t .n = {.min = 1, .max = 6},\n\t .m = {.min = 70, .max = 120},\n\t .m1 = {.min = 8, .max = 18},\n\t .m2 = {.min = 3, .max = 7},\n\t .p = {.min = 5, .max = 80},\n\t .p1 = {.min = 1, .max = 8},\n\t .p2 = {.dot_limit = 200000, .p2_slow = 10, .p2_fast = 5},\n\t .find_pll = gma_find_best_pll,\n\t },\n\t{\t\t\t \n\t .dot = {.min = 20000, .max = 400000},\n\t .vco = {.min = 1400000, .max = 2800000},\n\t .n = {.min = 1, .max = 6},\n\t .m = {.min = 70, .max = 120},\n\t .m1 = {.min = 8, .max = 18},\n\t .m2 = {.min = 3, .max = 7},\n\t .p = {.min = 7, .max = 98},\n\t .p1 = {.min = 1, .max = 8},\n\t  \n\t .p2 = {.dot_limit = 112000, .p2_slow = 14, .p2_fast = 7},\n\t .find_pll = gma_find_best_pll,\n\t },\n};\n\nstatic const struct gma_limit_t *psb_intel_limit(struct drm_crtc *crtc,\n\t\t\t\t\t\t int refclk)\n{\n\tconst struct gma_limit_t *limit;\n\n\tif (gma_pipe_has_type(crtc, INTEL_OUTPUT_LVDS))\n\t\tlimit = &psb_intel_limits[INTEL_LIMIT_I9XX_LVDS];\n\telse\n\t\tlimit = &psb_intel_limits[INTEL_LIMIT_I9XX_SDVO_DAC];\n\treturn limit;\n}\n\nstatic void psb_intel_clock(int refclk, struct gma_clock_t *clock)\n{\n\tclock->m = 5 * (clock->m1 + 2) + (clock->m2 + 2);\n\tclock->p = clock->p1 * clock->p2;\n\tclock->vco = refclk * clock->m / (clock->n + 2);\n\tclock->dot = clock->vco / clock->p;\n}\n\n \nstatic int psb_intel_panel_fitter_pipe(struct drm_device *dev)\n{\n\tu32 pfit_control;\n\n\tpfit_control = REG_READ(PFIT_CONTROL);\n\n\t \n\tif ((pfit_control & PFIT_ENABLE) == 0)\n\t\treturn -1;\n\t \n\treturn 1;\n}\n\nstatic int psb_intel_crtc_mode_set(struct drm_crtc *crtc,\n\t\t\t       struct drm_display_mode *mode,\n\t\t\t       struct drm_display_mode *adjusted_mode,\n\t\t\t       int x, int y,\n\t\t\t       struct drm_framebuffer *old_fb)\n{\n\tstruct drm_device *dev = crtc->dev;\n\tstruct drm_psb_private *dev_priv = to_drm_psb_private(dev);\n\tstruct gma_crtc *gma_crtc = to_gma_crtc(crtc);\n\tconst struct drm_crtc_helper_funcs *crtc_funcs = crtc->helper_private;\n\tint pipe = gma_crtc->pipe;\n\tconst struct psb_offset *map = &dev_priv->regmap[pipe];\n\tint refclk;\n\tstruct gma_clock_t clock;\n\tu32 dpll = 0, fp = 0, dspcntr, pipeconf;\n\tbool ok, is_sdvo = false;\n\tbool is_lvds = false, is_tv = false;\n\tstruct drm_connector_list_iter conn_iter;\n\tstruct drm_connector *connector;\n\tconst struct gma_limit_t *limit;\n\n\t \n\tif (crtc->primary->fb == NULL) {\n\t\tcrtc_funcs->mode_set_base(crtc, x, y, old_fb);\n\t\treturn 0;\n\t}\n\n\tdrm_connector_list_iter_begin(dev, &conn_iter);\n\tdrm_for_each_connector_iter(connector, &conn_iter) {\n\t\tstruct gma_encoder *gma_encoder = gma_attached_encoder(connector);\n\n\t\tif (!connector->encoder\n\t\t    || connector->encoder->crtc != crtc)\n\t\t\tcontinue;\n\n\t\tswitch (gma_encoder->type) {\n\t\tcase INTEL_OUTPUT_LVDS:\n\t\t\tis_lvds = true;\n\t\t\tbreak;\n\t\tcase INTEL_OUTPUT_SDVO:\n\t\t\tis_sdvo = true;\n\t\t\tbreak;\n\t\tcase INTEL_OUTPUT_TVOUT:\n\t\t\tis_tv = true;\n\t\t\tbreak;\n\t\t}\n\n\t\tbreak;\n\t}\n\tdrm_connector_list_iter_end(&conn_iter);\n\n\trefclk = 96000;\n\n\tlimit = gma_crtc->clock_funcs->limit(crtc, refclk);\n\n\tok = limit->find_pll(limit, crtc, adjusted_mode->clock, refclk,\n\t\t\t\t &clock);\n\tif (!ok) {\n\t\tDRM_ERROR(\"Couldn't find PLL settings for mode! target: %d, actual: %d\",\n\t\t\t  adjusted_mode->clock, clock.dot);\n\t\treturn 0;\n\t}\n\n\tfp = clock.n << 16 | clock.m1 << 8 | clock.m2;\n\n\tdpll = DPLL_VGA_MODE_DIS;\n\tif (is_lvds) {\n\t\tdpll |= DPLLB_MODE_LVDS;\n\t\tdpll |= DPLL_DVO_HIGH_SPEED;\n\t} else\n\t\tdpll |= DPLLB_MODE_DAC_SERIAL;\n\tif (is_sdvo) {\n\t\tint sdvo_pixel_multiply =\n\t\t\t    adjusted_mode->clock / mode->clock;\n\t\tdpll |= DPLL_DVO_HIGH_SPEED;\n\t\tdpll |=\n\t\t    (sdvo_pixel_multiply - 1) << SDVO_MULTIPLIER_SHIFT_HIRES;\n\t}\n\n\t \n\tdpll |= (1 << (clock.p1 - 1)) << 16;\n\tswitch (clock.p2) {\n\tcase 5:\n\t\tdpll |= DPLL_DAC_SERIAL_P2_CLOCK_DIV_5;\n\t\tbreak;\n\tcase 7:\n\t\tdpll |= DPLLB_LVDS_P2_CLOCK_DIV_7;\n\t\tbreak;\n\tcase 10:\n\t\tdpll |= DPLL_DAC_SERIAL_P2_CLOCK_DIV_10;\n\t\tbreak;\n\tcase 14:\n\t\tdpll |= DPLLB_LVDS_P2_CLOCK_DIV_14;\n\t\tbreak;\n\t}\n\n\tif (is_tv) {\n\t\t \n \n\t\tdpll |= 3;\n\t}\n\tdpll |= PLL_REF_INPUT_DREFCLK;\n\n\t \n\tpipeconf = REG_READ(map->conf);\n\n\t \n\tdspcntr = DISPPLANE_GAMMA_ENABLE;\n\n\tif (pipe == 0)\n\t\tdspcntr |= DISPPLANE_SEL_PIPE_A;\n\telse\n\t\tdspcntr |= DISPPLANE_SEL_PIPE_B;\n\n\tdspcntr |= DISPLAY_PLANE_ENABLE;\n\tpipeconf |= PIPEACONF_ENABLE;\n\tdpll |= DPLL_VCO_ENABLE;\n\n\n\t \n\tif (psb_intel_panel_fitter_pipe(dev) == pipe)\n\t\tREG_WRITE(PFIT_CONTROL, 0);\n\n\tdrm_mode_debug_printmodeline(mode);\n\n\tif (dpll & DPLL_VCO_ENABLE) {\n\t\tREG_WRITE(map->fp0, fp);\n\t\tREG_WRITE(map->dpll, dpll & ~DPLL_VCO_ENABLE);\n\t\tREG_READ(map->dpll);\n\t\tudelay(150);\n\t}\n\n\t \n\tif (is_lvds) {\n\t\tu32 lvds = REG_READ(LVDS);\n\n\t\tlvds &= ~LVDS_PIPEB_SELECT;\n\t\tif (pipe == 1)\n\t\t\tlvds |= LVDS_PIPEB_SELECT;\n\n\t\tlvds |= LVDS_PORT_EN | LVDS_A0A2_CLKA_POWER_UP;\n\t\t \n\t\tlvds &= ~(LVDS_B0B3_POWER_UP | LVDS_CLKB_POWER_UP);\n\t\tif (clock.p2 == 7)\n\t\t\tlvds |= LVDS_B0B3_POWER_UP | LVDS_CLKB_POWER_UP;\n\n\t\t \n\n\t\tREG_WRITE(LVDS, lvds);\n\t\tREG_READ(LVDS);\n\t}\n\n\tREG_WRITE(map->fp0, fp);\n\tREG_WRITE(map->dpll, dpll);\n\tREG_READ(map->dpll);\n\t \n\tudelay(150);\n\n\t \n\tREG_WRITE(map->dpll, dpll);\n\n\tREG_READ(map->dpll);\n\t \n\tudelay(150);\n\n\tREG_WRITE(map->htotal, (adjusted_mode->crtc_hdisplay - 1) |\n\t\t  ((adjusted_mode->crtc_htotal - 1) << 16));\n\tREG_WRITE(map->hblank, (adjusted_mode->crtc_hblank_start - 1) |\n\t\t  ((adjusted_mode->crtc_hblank_end - 1) << 16));\n\tREG_WRITE(map->hsync, (adjusted_mode->crtc_hsync_start - 1) |\n\t\t  ((adjusted_mode->crtc_hsync_end - 1) << 16));\n\tREG_WRITE(map->vtotal, (adjusted_mode->crtc_vdisplay - 1) |\n\t\t  ((adjusted_mode->crtc_vtotal - 1) << 16));\n\tREG_WRITE(map->vblank, (adjusted_mode->crtc_vblank_start - 1) |\n\t\t  ((adjusted_mode->crtc_vblank_end - 1) << 16));\n\tREG_WRITE(map->vsync, (adjusted_mode->crtc_vsync_start - 1) |\n\t\t  ((adjusted_mode->crtc_vsync_end - 1) << 16));\n\t \n\tREG_WRITE(map->size,\n\t\t  ((mode->vdisplay - 1) << 16) | (mode->hdisplay - 1));\n\tREG_WRITE(map->pos, 0);\n\tREG_WRITE(map->src,\n\t\t  ((mode->hdisplay - 1) << 16) | (mode->vdisplay - 1));\n\tREG_WRITE(map->conf, pipeconf);\n\tREG_READ(map->conf);\n\n\tgma_wait_for_vblank(dev);\n\n\tREG_WRITE(map->cntr, dspcntr);\n\n\t \n\tcrtc_funcs->mode_set_base(crtc, x, y, old_fb);\n\n\tgma_wait_for_vblank(dev);\n\n\treturn 0;\n}\n\n \nstatic int psb_intel_crtc_clock_get(struct drm_device *dev,\n\t\t\t\tstruct drm_crtc *crtc)\n{\n\tstruct gma_crtc *gma_crtc = to_gma_crtc(crtc);\n\tstruct drm_psb_private *dev_priv = to_drm_psb_private(dev);\n\tint pipe = gma_crtc->pipe;\n\tconst struct psb_offset *map = &dev_priv->regmap[pipe];\n\tu32 dpll;\n\tu32 fp;\n\tstruct gma_clock_t clock;\n\tbool is_lvds;\n\tstruct psb_pipe *p = &dev_priv->regs.pipe[pipe];\n\n\tif (gma_power_begin(dev, false)) {\n\t\tdpll = REG_READ(map->dpll);\n\t\tif ((dpll & DISPLAY_RATE_SELECT_FPA1) == 0)\n\t\t\tfp = REG_READ(map->fp0);\n\t\telse\n\t\t\tfp = REG_READ(map->fp1);\n\t\tis_lvds = (pipe == 1) && (REG_READ(LVDS) & LVDS_PORT_EN);\n\t\tgma_power_end(dev);\n\t} else {\n\t\tdpll = p->dpll;\n\n\t\tif ((dpll & DISPLAY_RATE_SELECT_FPA1) == 0)\n\t\t\tfp = p->fp0;\n\t\telse\n\t\t        fp = p->fp1;\n\n\t\tis_lvds = (pipe == 1) && (dev_priv->regs.psb.saveLVDS &\n\t\t\t\t\t\t\t\tLVDS_PORT_EN);\n\t}\n\n\tclock.m1 = (fp & FP_M1_DIV_MASK) >> FP_M1_DIV_SHIFT;\n\tclock.m2 = (fp & FP_M2_DIV_MASK) >> FP_M2_DIV_SHIFT;\n\tclock.n = (fp & FP_N_DIV_MASK) >> FP_N_DIV_SHIFT;\n\n\tif (is_lvds) {\n\t\tclock.p1 =\n\t\t    ffs((dpll &\n\t\t\t DPLL_FPA01_P1_POST_DIV_MASK_I830_LVDS) >>\n\t\t\tDPLL_FPA01_P1_POST_DIV_SHIFT);\n\t\tclock.p2 = 14;\n\n\t\tif ((dpll & PLL_REF_INPUT_MASK) ==\n\t\t    PLLB_REF_INPUT_SPREADSPECTRUMIN) {\n\t\t\t \n\t\t\tpsb_intel_clock(66000, &clock);\n\t\t} else\n\t\t\tpsb_intel_clock(48000, &clock);\n\t} else {\n\t\tif (dpll & PLL_P1_DIVIDE_BY_TWO)\n\t\t\tclock.p1 = 2;\n\t\telse {\n\t\t\tclock.p1 =\n\t\t\t    ((dpll &\n\t\t\t      DPLL_FPA01_P1_POST_DIV_MASK_I830) >>\n\t\t\t     DPLL_FPA01_P1_POST_DIV_SHIFT) + 2;\n\t\t}\n\t\tif (dpll & PLL_P2_DIVIDE_BY_4)\n\t\t\tclock.p2 = 4;\n\t\telse\n\t\t\tclock.p2 = 2;\n\n\t\tpsb_intel_clock(48000, &clock);\n\t}\n\n\t \n\n\treturn clock.dot;\n}\n\n \nstruct drm_display_mode *psb_intel_crtc_mode_get(struct drm_device *dev,\n\t\t\t\t\t     struct drm_crtc *crtc)\n{\n\tstruct gma_crtc *gma_crtc = to_gma_crtc(crtc);\n\tint pipe = gma_crtc->pipe;\n\tstruct drm_display_mode *mode;\n\tint htot;\n\tint hsync;\n\tint vtot;\n\tint vsync;\n\tstruct drm_psb_private *dev_priv = to_drm_psb_private(dev);\n\tstruct psb_pipe *p = &dev_priv->regs.pipe[pipe];\n\tconst struct psb_offset *map = &dev_priv->regmap[pipe];\n\n\tif (gma_power_begin(dev, false)) {\n\t\thtot = REG_READ(map->htotal);\n\t\thsync = REG_READ(map->hsync);\n\t\tvtot = REG_READ(map->vtotal);\n\t\tvsync = REG_READ(map->vsync);\n\t\tgma_power_end(dev);\n\t} else {\n\t\thtot = p->htotal;\n\t\thsync = p->hsync;\n\t\tvtot = p->vtotal;\n\t\tvsync = p->vsync;\n\t}\n\n\tmode = kzalloc(sizeof(*mode), GFP_KERNEL);\n\tif (!mode)\n\t\treturn NULL;\n\n\tmode->clock = psb_intel_crtc_clock_get(dev, crtc);\n\tmode->hdisplay = (htot & 0xffff) + 1;\n\tmode->htotal = ((htot & 0xffff0000) >> 16) + 1;\n\tmode->hsync_start = (hsync & 0xffff) + 1;\n\tmode->hsync_end = ((hsync & 0xffff0000) >> 16) + 1;\n\tmode->vdisplay = (vtot & 0xffff) + 1;\n\tmode->vtotal = ((vtot & 0xffff0000) >> 16) + 1;\n\tmode->vsync_start = (vsync & 0xffff) + 1;\n\tmode->vsync_end = ((vsync & 0xffff0000) >> 16) + 1;\n\n\tdrm_mode_set_name(mode);\n\tdrm_mode_set_crtcinfo(mode, 0);\n\n\treturn mode;\n}\n\nconst struct drm_crtc_helper_funcs psb_intel_helper_funcs = {\n\t.dpms = gma_crtc_dpms,\n\t.mode_set = psb_intel_crtc_mode_set,\n\t.mode_set_base = gma_pipe_set_base,\n\t.prepare = gma_crtc_prepare,\n\t.commit = gma_crtc_commit,\n\t.disable = gma_crtc_disable,\n};\n\nconst struct gma_clock_funcs psb_clock_funcs = {\n\t.clock = psb_intel_clock,\n\t.limit = psb_intel_limit,\n\t.pll_is_valid = gma_pll_is_valid,\n};\n\n \nstatic void psb_intel_cursor_init(struct drm_device *dev,\n\t\t\t\t  struct gma_crtc *gma_crtc)\n{\n\tstruct drm_psb_private *dev_priv = to_drm_psb_private(dev);\n\tu32 control[3] = { CURACNTR, CURBCNTR, CURCCNTR };\n\tu32 base[3] = { CURABASE, CURBBASE, CURCBASE };\n\tstruct psb_gem_object *cursor_pobj;\n\n\tif (dev_priv->ops->cursor_needs_phys) {\n\t\t \n\t\tcursor_pobj = psb_gem_create(dev, 4 * PAGE_SIZE, \"cursor\", true, PAGE_SIZE);\n\t\tif (IS_ERR(cursor_pobj)) {\n\t\t\tgma_crtc->cursor_pobj = NULL;\n\t\t\tgoto out;\n\t\t}\n\t\tgma_crtc->cursor_pobj = cursor_pobj;\n\t\tgma_crtc->cursor_addr = dev_priv->stolen_base + cursor_pobj->offset;\n\t} else {\n\t\tgma_crtc->cursor_pobj = NULL;\n\t}\n\nout:\n\tREG_WRITE(control[gma_crtc->pipe], 0);\n\tREG_WRITE(base[gma_crtc->pipe], 0);\n}\n\nvoid psb_intel_crtc_init(struct drm_device *dev, int pipe,\n\t\t     struct psb_intel_mode_device *mode_dev)\n{\n\tstruct drm_psb_private *dev_priv = to_drm_psb_private(dev);\n\tstruct gma_crtc *gma_crtc;\n\tint i;\n\n\t \n\tgma_crtc = kzalloc(sizeof(struct gma_crtc) +\n\t\t\t(INTELFB_CONN_LIMIT * sizeof(struct drm_connector *)),\n\t\t\tGFP_KERNEL);\n\tif (gma_crtc == NULL)\n\t\treturn;\n\n\tgma_crtc->crtc_state =\n\t\tkzalloc(sizeof(struct psb_intel_crtc_state), GFP_KERNEL);\n\tif (!gma_crtc->crtc_state) {\n\t\tdev_err(dev->dev, \"Crtc state error: No memory\\n\");\n\t\tkfree(gma_crtc);\n\t\treturn;\n\t}\n\n\tdrm_crtc_init(dev, &gma_crtc->base, &gma_crtc_funcs);\n\n\t \n\tgma_crtc->clock_funcs = dev_priv->ops->clock_funcs;\n\n\tdrm_mode_crtc_set_gamma_size(&gma_crtc->base, 256);\n\tgma_crtc->pipe = pipe;\n\tgma_crtc->plane = pipe;\n\n\tfor (i = 0; i < 256; i++)\n\t\tgma_crtc->lut_adj[i] = 0;\n\n\tgma_crtc->mode_dev = mode_dev;\n\tgma_crtc->cursor_addr = 0;\n\n\tdrm_crtc_helper_add(&gma_crtc->base,\n\t\t\t\t\t\tdev_priv->ops->crtc_helper);\n\n\t \n\tgma_crtc->mode_set.crtc = &gma_crtc->base;\n\tBUG_ON(pipe >= ARRAY_SIZE(dev_priv->plane_to_crtc_mapping) ||\n\t       dev_priv->plane_to_crtc_mapping[gma_crtc->plane] != NULL);\n\tdev_priv->plane_to_crtc_mapping[gma_crtc->plane] = &gma_crtc->base;\n\tdev_priv->pipe_to_crtc_mapping[gma_crtc->pipe] = &gma_crtc->base;\n\tgma_crtc->mode_set.connectors = (struct drm_connector **)(gma_crtc + 1);\n\tgma_crtc->mode_set.num_connectors = 0;\n\tpsb_intel_cursor_init(dev, gma_crtc);\n\n\t \n\tgma_crtc->active = true;\n}\n\nstruct drm_crtc *psb_intel_get_crtc_from_pipe(struct drm_device *dev, int pipe)\n{\n\tstruct drm_crtc *crtc;\n\n\tlist_for_each_entry(crtc, &dev->mode_config.crtc_list, head) {\n\t\tstruct gma_crtc *gma_crtc = to_gma_crtc(crtc);\n\n\t\tif (gma_crtc->pipe == pipe)\n\t\t\treturn crtc;\n\t}\n\treturn NULL;\n}\n\nint gma_connector_clones(struct drm_device *dev, int type_mask)\n{\n\tstruct drm_connector_list_iter conn_iter;\n\tstruct drm_connector *connector;\n\tint index_mask = 0;\n\tint entry = 0;\n\n\tdrm_connector_list_iter_begin(dev, &conn_iter);\n\tdrm_for_each_connector_iter(connector, &conn_iter) {\n\t\tstruct gma_encoder *gma_encoder = gma_attached_encoder(connector);\n\t\tif (type_mask & (1 << gma_encoder->type))\n\t\t\tindex_mask |= (1 << entry);\n\t\tentry++;\n\t}\n\tdrm_connector_list_iter_end(&conn_iter);\n\n\treturn index_mask;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}