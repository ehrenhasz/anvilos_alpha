{
  "module_name": "framebuffer.c",
  "hash_id": "809ba4f93cf5ab0d1cf28a6af3216aab1a7cb6b05300df863ce9c4bb8e44dbc5",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/gma500/framebuffer.c",
  "human_readable_source": "\n \n\n#include <drm/drm_framebuffer.h>\n#include <drm/drm_gem_framebuffer_helper.h>\n#include <drm/drm_modeset_helper.h>\n\n#include \"framebuffer.h\"\n#include \"psb_drv.h\"\n\nstatic const struct drm_framebuffer_funcs psb_fb_funcs = {\n\t.destroy = drm_gem_fb_destroy,\n\t.create_handle = drm_gem_fb_create_handle,\n};\n\n \nstatic int psb_framebuffer_init(struct drm_device *dev,\n\t\t\t\t\tstruct drm_framebuffer *fb,\n\t\t\t\t\tconst struct drm_mode_fb_cmd2 *mode_cmd,\n\t\t\t\t\tstruct drm_gem_object *obj)\n{\n\tconst struct drm_format_info *info;\n\tint ret;\n\n\t \n\tinfo = drm_get_format_info(dev, mode_cmd);\n\tif (!info || !info->depth || info->cpp[0] > 4)\n\t\treturn -EINVAL;\n\n\tif (mode_cmd->pitches[0] & 63)\n\t\treturn -EINVAL;\n\n\tdrm_helper_mode_fill_fb_struct(dev, fb, mode_cmd);\n\tfb->obj[0] = obj;\n\tret = drm_framebuffer_init(dev, fb, &psb_fb_funcs);\n\tif (ret) {\n\t\tdev_err(dev->dev, \"framebuffer init failed: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\treturn 0;\n}\n\n \nstruct drm_framebuffer *psb_framebuffer_create(struct drm_device *dev,\n\t\t\t\t\t       const struct drm_mode_fb_cmd2 *mode_cmd,\n\t\t\t\t\t       struct drm_gem_object *obj)\n{\n\tstruct drm_framebuffer *fb;\n\tint ret;\n\n\tfb = kzalloc(sizeof(*fb), GFP_KERNEL);\n\tif (!fb)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tret = psb_framebuffer_init(dev, fb, mode_cmd, obj);\n\tif (ret) {\n\t\tkfree(fb);\n\t\treturn ERR_PTR(ret);\n\t}\n\treturn fb;\n}\n\n \nstatic struct drm_framebuffer *psb_user_framebuffer_create\n\t\t\t(struct drm_device *dev, struct drm_file *filp,\n\t\t\t const struct drm_mode_fb_cmd2 *cmd)\n{\n\tstruct drm_gem_object *obj;\n\tstruct drm_framebuffer *fb;\n\n\t \n\tobj = drm_gem_object_lookup(filp, cmd->handles[0]);\n\tif (obj == NULL)\n\t\treturn ERR_PTR(-ENOENT);\n\n\t \n\tfb = psb_framebuffer_create(dev, cmd, obj);\n\tif (IS_ERR(fb))\n\t\tdrm_gem_object_put(obj);\n\n\treturn fb;\n}\n\nstatic const struct drm_mode_config_funcs psb_mode_funcs = {\n\t.fb_create = psb_user_framebuffer_create,\n};\n\nstatic void psb_setup_outputs(struct drm_device *dev)\n{\n\tstruct drm_psb_private *dev_priv = to_drm_psb_private(dev);\n\tstruct drm_connector_list_iter conn_iter;\n\tstruct drm_connector *connector;\n\n\tdrm_mode_create_scaling_mode_property(dev);\n\n\t \n\tif (!dev_priv->backlight_property)\n\t\tdev_priv->backlight_property = drm_property_create_range(dev, 0,\n\t\t\t\t\t\t\t\"backlight\", 0, 100);\n\tdev_priv->ops->output_init(dev);\n\n\tdrm_connector_list_iter_begin(dev, &conn_iter);\n\tdrm_for_each_connector_iter(connector, &conn_iter) {\n\t\tstruct gma_encoder *gma_encoder = gma_attached_encoder(connector);\n\t\tstruct drm_encoder *encoder = &gma_encoder->base;\n\t\tint crtc_mask = 0, clone_mask = 0;\n\n\t\t \n\t\tswitch (gma_encoder->type) {\n\t\tcase INTEL_OUTPUT_ANALOG:\n\t\t\tcrtc_mask = (1 << 0);\n\t\t\tclone_mask = (1 << INTEL_OUTPUT_ANALOG);\n\t\t\tbreak;\n\t\tcase INTEL_OUTPUT_SDVO:\n\t\t\tcrtc_mask = dev_priv->ops->sdvo_mask;\n\t\t\tclone_mask = 0;\n\t\t\tbreak;\n\t\tcase INTEL_OUTPUT_LVDS:\n\t\t\tcrtc_mask = dev_priv->ops->lvds_mask;\n\t\t\tclone_mask = 0;\n\t\t\tbreak;\n\t\tcase INTEL_OUTPUT_MIPI:\n\t\t\tcrtc_mask = (1 << 0);\n\t\t\tclone_mask = 0;\n\t\t\tbreak;\n\t\tcase INTEL_OUTPUT_MIPI2:\n\t\t\tcrtc_mask = (1 << 2);\n\t\t\tclone_mask = 0;\n\t\t\tbreak;\n\t\tcase INTEL_OUTPUT_HDMI:\n\t\t\tcrtc_mask = dev_priv->ops->hdmi_mask;\n\t\t\tclone_mask = (1 << INTEL_OUTPUT_HDMI);\n\t\t\tbreak;\n\t\tcase INTEL_OUTPUT_DISPLAYPORT:\n\t\t\tcrtc_mask = (1 << 0) | (1 << 1);\n\t\t\tclone_mask = 0;\n\t\t\tbreak;\n\t\tcase INTEL_OUTPUT_EDP:\n\t\t\tcrtc_mask = (1 << 1);\n\t\t\tclone_mask = 0;\n\t\t}\n\t\tencoder->possible_crtcs = crtc_mask;\n\t\tencoder->possible_clones =\n\t\t    gma_connector_clones(dev, clone_mask);\n\t}\n\tdrm_connector_list_iter_end(&conn_iter);\n}\n\nvoid psb_modeset_init(struct drm_device *dev)\n{\n\tstruct drm_psb_private *dev_priv = to_drm_psb_private(dev);\n\tstruct psb_intel_mode_device *mode_dev = &dev_priv->mode_dev;\n\tint i;\n\n\tif (drmm_mode_config_init(dev))\n\t\treturn;\n\n\tdev->mode_config.min_width = 0;\n\tdev->mode_config.min_height = 0;\n\n\tdev->mode_config.funcs = &psb_mode_funcs;\n\n\t \n\tfor (i = 0; i < dev_priv->num_pipe; i++)\n\t\tpsb_intel_crtc_init(dev, i, mode_dev);\n\n\tdev->mode_config.max_width = 4096;\n\tdev->mode_config.max_height = 4096;\n\n\tpsb_setup_outputs(dev);\n\n\tif (dev_priv->ops->errata)\n\t        dev_priv->ops->errata(dev);\n\n        dev_priv->modeset = true;\n}\n\nvoid psb_modeset_cleanup(struct drm_device *dev)\n{\n\tstruct drm_psb_private *dev_priv = to_drm_psb_private(dev);\n\tif (dev_priv->modeset) {\n\t\tdrm_kms_helper_poll_fini(dev);\n\t}\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}