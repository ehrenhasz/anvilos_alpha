{
  "module_name": "cdv_intel_crt.c",
  "hash_id": "45e1eec35428cbe0db21fef86cb3cbe4e075462b21c8ae285964c60db4c64e4f",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/gma500/cdv_intel_crt.c",
  "human_readable_source": " \n\n#include <linux/delay.h>\n#include <linux/i2c.h>\n#include <linux/pm_runtime.h>\n\n#include <drm/drm_crtc_helper.h>\n#include <drm/drm_modeset_helper_vtables.h>\n#include <drm/drm_simple_kms_helper.h>\n\n#include \"cdv_device.h\"\n#include \"intel_bios.h\"\n#include \"power.h\"\n#include \"psb_drv.h\"\n#include \"psb_intel_drv.h\"\n#include \"psb_intel_reg.h\"\n\n\nstatic void cdv_intel_crt_dpms(struct drm_encoder *encoder, int mode)\n{\n\tstruct drm_device *dev = encoder->dev;\n\tu32 temp, reg;\n\treg = ADPA;\n\n\ttemp = REG_READ(reg);\n\ttemp &= ~(ADPA_HSYNC_CNTL_DISABLE | ADPA_VSYNC_CNTL_DISABLE);\n\ttemp &= ~ADPA_DAC_ENABLE;\n\n\tswitch (mode) {\n\tcase DRM_MODE_DPMS_ON:\n\t\ttemp |= ADPA_DAC_ENABLE;\n\t\tbreak;\n\tcase DRM_MODE_DPMS_STANDBY:\n\t\ttemp |= ADPA_DAC_ENABLE | ADPA_HSYNC_CNTL_DISABLE;\n\t\tbreak;\n\tcase DRM_MODE_DPMS_SUSPEND:\n\t\ttemp |= ADPA_DAC_ENABLE | ADPA_VSYNC_CNTL_DISABLE;\n\t\tbreak;\n\tcase DRM_MODE_DPMS_OFF:\n\t\ttemp |= ADPA_HSYNC_CNTL_DISABLE | ADPA_VSYNC_CNTL_DISABLE;\n\t\tbreak;\n\t}\n\n\tREG_WRITE(reg, temp);\n}\n\nstatic enum drm_mode_status cdv_intel_crt_mode_valid(struct drm_connector *connector,\n\t\t\t\tstruct drm_display_mode *mode)\n{\n\tif (mode->flags & DRM_MODE_FLAG_DBLSCAN)\n\t\treturn MODE_NO_DBLESCAN;\n\n\t \n\tif (mode->clock < 20000)\n\t\treturn MODE_CLOCK_LOW;\n\n\t \n\tif (mode->clock > 355000)\n\t\treturn MODE_CLOCK_HIGH;\n\n\treturn MODE_OK;\n}\n\nstatic void cdv_intel_crt_mode_set(struct drm_encoder *encoder,\n\t\t\t       struct drm_display_mode *mode,\n\t\t\t       struct drm_display_mode *adjusted_mode)\n{\n\n\tstruct drm_device *dev = encoder->dev;\n\tstruct drm_crtc *crtc = encoder->crtc;\n\tstruct gma_crtc *gma_crtc = to_gma_crtc(crtc);\n\tint dpll_md_reg;\n\tu32 adpa, dpll_md;\n\tu32 adpa_reg;\n\n\tif (gma_crtc->pipe == 0)\n\t\tdpll_md_reg = DPLL_A_MD;\n\telse\n\t\tdpll_md_reg = DPLL_B_MD;\n\n\tadpa_reg = ADPA;\n\n\t \n\t{\n\t\tdpll_md = REG_READ(dpll_md_reg);\n\t\tREG_WRITE(dpll_md_reg,\n\t\t\t   dpll_md & ~DPLL_MD_UDI_MULTIPLIER_MASK);\n\t}\n\n\tadpa = 0;\n\tif (adjusted_mode->flags & DRM_MODE_FLAG_PHSYNC)\n\t\tadpa |= ADPA_HSYNC_ACTIVE_HIGH;\n\tif (adjusted_mode->flags & DRM_MODE_FLAG_PVSYNC)\n\t\tadpa |= ADPA_VSYNC_ACTIVE_HIGH;\n\n\tif (gma_crtc->pipe == 0)\n\t\tadpa |= ADPA_PIPE_A_SELECT;\n\telse\n\t\tadpa |= ADPA_PIPE_B_SELECT;\n\n\tREG_WRITE(adpa_reg, adpa);\n}\n\n\n \nstatic bool cdv_intel_crt_detect_hotplug(struct drm_connector *connector,\n\t\t\t\t\t\t\t\tbool force)\n{\n\tstruct drm_device *dev = connector->dev;\n\tu32 hotplug_en;\n\tint i, tries = 0, ret = false;\n\tu32 orig;\n\n\t \n\ttries = 2;\n\n\torig = hotplug_en = REG_READ(PORT_HOTPLUG_EN);\n\thotplug_en &= ~(CRT_HOTPLUG_DETECT_MASK);\n\thotplug_en |= CRT_HOTPLUG_FORCE_DETECT;\n\n\thotplug_en |= CRT_HOTPLUG_ACTIVATION_PERIOD_64;\n\thotplug_en |= CRT_HOTPLUG_VOLTAGE_COMPARE_50;\n\n\tfor (i = 0; i < tries ; i++) {\n\t\tunsigned long timeout;\n\t\t \n\t\tREG_WRITE(PORT_HOTPLUG_EN, hotplug_en);\n\t\ttimeout = jiffies + msecs_to_jiffies(1000);\n\t\t \n\t\tdo {\n\t\t\tif (!(REG_READ(PORT_HOTPLUG_EN) &\n\t\t\t\t\tCRT_HOTPLUG_FORCE_DETECT))\n\t\t\t\tbreak;\n\t\t\tmsleep(1);\n\t\t} while (time_after(timeout, jiffies));\n\t}\n\n\tif ((REG_READ(PORT_HOTPLUG_STAT) & CRT_HOTPLUG_MONITOR_MASK) !=\n\t    CRT_HOTPLUG_MONITOR_NONE)\n\t\tret = true;\n\n\t  \n\tREG_WRITE(PORT_HOTPLUG_STAT, CRT_HOTPLUG_INT_STATUS);\n\n\t \n\tREG_WRITE(PORT_HOTPLUG_EN, orig);\n\treturn ret;\n}\n\nstatic enum drm_connector_status cdv_intel_crt_detect(\n\t\t\t\tstruct drm_connector *connector, bool force)\n{\n\tif (cdv_intel_crt_detect_hotplug(connector, force))\n\t\treturn connector_status_connected;\n\telse\n\t\treturn connector_status_disconnected;\n}\n\nstatic void cdv_intel_crt_destroy(struct drm_connector *connector)\n{\n\tstruct gma_connector *gma_connector = to_gma_connector(connector);\n\tstruct gma_i2c_chan *ddc_bus = to_gma_i2c_chan(connector->ddc);\n\n\tgma_i2c_destroy(ddc_bus);\n\tdrm_connector_cleanup(connector);\n\tkfree(gma_connector);\n}\n\nstatic int cdv_intel_crt_get_modes(struct drm_connector *connector)\n{\n\treturn psb_intel_ddc_get_modes(connector, connector->ddc);\n}\n\nstatic int cdv_intel_crt_set_property(struct drm_connector *connector,\n\t\t\t\t  struct drm_property *property,\n\t\t\t\t  uint64_t value)\n{\n\treturn 0;\n}\n\n \n\nstatic const struct drm_encoder_helper_funcs cdv_intel_crt_helper_funcs = {\n\t.dpms = cdv_intel_crt_dpms,\n\t.prepare = gma_encoder_prepare,\n\t.commit = gma_encoder_commit,\n\t.mode_set = cdv_intel_crt_mode_set,\n};\n\nstatic const struct drm_connector_funcs cdv_intel_crt_connector_funcs = {\n\t.dpms = drm_helper_connector_dpms,\n\t.detect = cdv_intel_crt_detect,\n\t.fill_modes = drm_helper_probe_single_connector_modes,\n\t.destroy = cdv_intel_crt_destroy,\n\t.set_property = cdv_intel_crt_set_property,\n};\n\nstatic const struct drm_connector_helper_funcs\n\t\t\t\tcdv_intel_crt_connector_helper_funcs = {\n\t.mode_valid = cdv_intel_crt_mode_valid,\n\t.get_modes = cdv_intel_crt_get_modes,\n\t.best_encoder = gma_best_encoder,\n};\n\nvoid cdv_intel_crt_init(struct drm_device *dev,\n\t\t\tstruct psb_intel_mode_device *mode_dev)\n{\n\n\tstruct gma_connector *gma_connector;\n\tstruct gma_encoder *gma_encoder;\n\tstruct gma_i2c_chan *ddc_bus;\n\tstruct drm_connector *connector;\n\tstruct drm_encoder *encoder;\n\tint ret;\n\n\tgma_encoder = kzalloc(sizeof(struct gma_encoder), GFP_KERNEL);\n\tif (!gma_encoder)\n\t\treturn;\n\n\tgma_connector = kzalloc(sizeof(struct gma_connector), GFP_KERNEL);\n\tif (!gma_connector)\n\t\tgoto err_free_encoder;\n\n\t \n\tddc_bus = gma_i2c_create(dev, GPIOA, \"CRTDDC_A\");\n\tif (!ddc_bus) {\n\t\tdev_printk(KERN_ERR, dev->dev, \"DDC bus registration failed.\\n\");\n\t\tgoto err_free_connector;\n\t}\n\n\tconnector = &gma_connector->base;\n\tconnector->polled = DRM_CONNECTOR_POLL_HPD;\n\tret = drm_connector_init_with_ddc(dev, connector,\n\t\t\t\t\t  &cdv_intel_crt_connector_funcs,\n\t\t\t\t\t  DRM_MODE_CONNECTOR_VGA,\n\t\t\t\t\t  &ddc_bus->base);\n\tif (ret)\n\t\tgoto err_ddc_destroy;\n\n\tencoder = &gma_encoder->base;\n\tret = drm_simple_encoder_init(dev, encoder, DRM_MODE_ENCODER_DAC);\n\tif (ret)\n\t\tgoto err_connector_cleanup;\n\n\tgma_connector_attach_encoder(gma_connector, gma_encoder);\n\n\tgma_encoder->type = INTEL_OUTPUT_ANALOG;\n\tconnector->interlace_allowed = 0;\n\tconnector->doublescan_allowed = 0;\n\n\tdrm_encoder_helper_add(encoder, &cdv_intel_crt_helper_funcs);\n\tdrm_connector_helper_add(connector,\n\t\t\t\t\t&cdv_intel_crt_connector_helper_funcs);\n\n\treturn;\n\nerr_connector_cleanup:\n\tdrm_connector_cleanup(&gma_connector->base);\nerr_ddc_destroy:\n\tgma_i2c_destroy(ddc_bus);\nerr_free_connector:\n\tkfree(gma_connector);\nerr_free_encoder:\n\tkfree(gma_encoder);\n\treturn;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}