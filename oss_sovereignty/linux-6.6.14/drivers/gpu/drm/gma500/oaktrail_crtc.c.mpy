{
  "module_name": "oaktrail_crtc.c",
  "hash_id": "e07be0955d6977418582be7425df21790e93bad1e997dc64f85213a10f589866",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/gma500/oaktrail_crtc.c",
  "human_readable_source": "\n \n\n#include <linux/delay.h>\n#include <linux/i2c.h>\n#include <linux/pm_runtime.h>\n\n#include <drm/drm_fourcc.h>\n#include <drm/drm_framebuffer.h>\n#include <drm/drm_modeset_helper_vtables.h>\n\n#include \"framebuffer.h\"\n#include \"gem.h\"\n#include \"gma_display.h\"\n#include \"power.h\"\n#include \"psb_drv.h\"\n#include \"psb_intel_drv.h\"\n#include \"psb_intel_reg.h\"\n\n#define MRST_LIMIT_LVDS_100L\t0\n#define MRST_LIMIT_LVDS_83\t1\n#define MRST_LIMIT_LVDS_100\t2\n#define MRST_LIMIT_SDVO\t\t3\n\n#define MRST_DOT_MIN\t\t  19750\n#define MRST_DOT_MAX\t\t  120000\n#define MRST_M_MIN_100L\t\t    20\n#define MRST_M_MIN_100\t\t    10\n#define MRST_M_MIN_83\t\t    12\n#define MRST_M_MAX_100L\t\t    34\n#define MRST_M_MAX_100\t\t    17\n#define MRST_M_MAX_83\t\t    20\n#define MRST_P1_MIN\t\t    2\n#define MRST_P1_MAX_0\t\t    7\n#define MRST_P1_MAX_1\t\t    8\n\nstatic bool mrst_lvds_find_best_pll(const struct gma_limit_t *limit,\n\t\t\t\t    struct drm_crtc *crtc, int target,\n\t\t\t\t    int refclk, struct gma_clock_t *best_clock);\n\nstatic bool mrst_sdvo_find_best_pll(const struct gma_limit_t *limit,\n\t\t\t\t    struct drm_crtc *crtc, int target,\n\t\t\t\t    int refclk, struct gma_clock_t *best_clock);\n\nstatic const struct gma_limit_t mrst_limits[] = {\n\t{\t\t\t \n\t .dot = {.min = MRST_DOT_MIN, .max = MRST_DOT_MAX},\n\t .m = {.min = MRST_M_MIN_100L, .max = MRST_M_MAX_100L},\n\t .p1 = {.min = MRST_P1_MIN, .max = MRST_P1_MAX_1},\n\t .find_pll = mrst_lvds_find_best_pll,\n\t },\n\t{\t\t\t \n\t .dot = {.min = MRST_DOT_MIN, .max = MRST_DOT_MAX},\n\t .m = {.min = MRST_M_MIN_83, .max = MRST_M_MAX_83},\n\t .p1 = {.min = MRST_P1_MIN, .max = MRST_P1_MAX_0},\n\t .find_pll = mrst_lvds_find_best_pll,\n\t },\n\t{\t\t\t \n\t .dot = {.min = MRST_DOT_MIN, .max = MRST_DOT_MAX},\n\t .m = {.min = MRST_M_MIN_100, .max = MRST_M_MAX_100},\n\t .p1 = {.min = MRST_P1_MIN, .max = MRST_P1_MAX_1},\n\t .find_pll = mrst_lvds_find_best_pll,\n\t },\n\t{\t\t\t \n\t .vco = {.min = 1400000, .max = 2800000},\n\t .n = {.min = 3, .max = 7},\n\t .m = {.min = 80, .max = 137},\n\t .p1 = {.min = 1, .max = 2},\n\t .p2 = {.dot_limit = 200000, .p2_slow = 10, .p2_fast = 10},\n\t .find_pll = mrst_sdvo_find_best_pll,\n\t },\n};\n\n#define MRST_M_MIN\t    10\nstatic const u32 oaktrail_m_converts[] = {\n\t0x2B, 0x15, 0x2A, 0x35, 0x1A, 0x0D, 0x26, 0x33, 0x19, 0x2C,\n\t0x36, 0x3B, 0x1D, 0x2E, 0x37, 0x1B, 0x2D, 0x16, 0x0B, 0x25,\n\t0x12, 0x09, 0x24, 0x32, 0x39, 0x1c,\n};\n\nstatic const struct gma_limit_t *mrst_limit(struct drm_crtc *crtc,\n\t\t\t\t\t    int refclk)\n{\n\tconst struct gma_limit_t *limit = NULL;\n\tstruct drm_device *dev = crtc->dev;\n\tstruct drm_psb_private *dev_priv = to_drm_psb_private(dev);\n\n\tif (gma_pipe_has_type(crtc, INTEL_OUTPUT_LVDS)\n\t    || gma_pipe_has_type(crtc, INTEL_OUTPUT_MIPI)) {\n\t\tswitch (dev_priv->core_freq) {\n\t\tcase 100:\n\t\t\tlimit = &mrst_limits[MRST_LIMIT_LVDS_100L];\n\t\t\tbreak;\n\t\tcase 166:\n\t\t\tlimit = &mrst_limits[MRST_LIMIT_LVDS_83];\n\t\t\tbreak;\n\t\tcase 200:\n\t\t\tlimit = &mrst_limits[MRST_LIMIT_LVDS_100];\n\t\t\tbreak;\n\t\t}\n\t} else if (gma_pipe_has_type(crtc, INTEL_OUTPUT_SDVO)) {\n\t\tlimit = &mrst_limits[MRST_LIMIT_SDVO];\n\t} else {\n\t\tlimit = NULL;\n\t\tdev_err(dev->dev, \"mrst_limit Wrong display type.\\n\");\n\t}\n\n\treturn limit;\n}\n\n \nstatic void mrst_lvds_clock(int refclk, struct gma_clock_t *clock)\n{\n\tclock->dot = (refclk * clock->m) / (14 * clock->p1);\n}\n\nstatic void mrst_print_pll(struct gma_clock_t *clock)\n{\n\tDRM_DEBUG_DRIVER(\"dotclock=%d,  m=%d, m1=%d, m2=%d, n=%d, p1=%d, p2=%d\\n\",\n\t\t\t clock->dot, clock->m, clock->m1, clock->m2, clock->n,\n\t\t\t clock->p1, clock->p2);\n}\n\nstatic bool mrst_sdvo_find_best_pll(const struct gma_limit_t *limit,\n\t\t\t\t    struct drm_crtc *crtc, int target,\n\t\t\t\t    int refclk, struct gma_clock_t *best_clock)\n{\n\tstruct gma_clock_t clock;\n\tu32 target_vco, actual_freq;\n\ts32 freq_error, min_error = 100000;\n\n\tmemset(best_clock, 0, sizeof(*best_clock));\n\tmemset(&clock, 0, sizeof(clock));\n\n\tfor (clock.m = limit->m.min; clock.m <= limit->m.max; clock.m++) {\n\t\tfor (clock.n = limit->n.min; clock.n <= limit->n.max;\n\t\t     clock.n++) {\n\t\t\tfor (clock.p1 = limit->p1.min;\n\t\t\t     clock.p1 <= limit->p1.max; clock.p1++) {\n\t\t\t\t \n\t\t\t\tclock.p = clock.p1 * limit->p2.p2_slow;\n\t\t\t\ttarget_vco = target * clock.p;\n\n\t\t\t\t \n\t\t\t\tif (target_vco > limit->vco.max)\n\t\t\t\t\tbreak;\n\n\t\t\t\tif (target_vco < limit->vco.min)\n\t\t\t\t\tcontinue;\n\n\t\t\t\tactual_freq = (refclk * clock.m) /\n\t\t\t\t\t      (clock.n * clock.p);\n\t\t\t\tfreq_error = 10000 -\n\t\t\t\t\t     ((target * 10000) / actual_freq);\n\n\t\t\t\tif (freq_error < -min_error) {\n\t\t\t\t\t \n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tif (freq_error < 0)\n\t\t\t\t\tfreq_error = -freq_error;\n\n\t\t\t\tif (freq_error < min_error) {\n\t\t\t\t\tmin_error = freq_error;\n\t\t\t\t\t*best_clock = clock;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (min_error == 0)\n\t\t\tbreak;\n\t}\n\n\treturn min_error == 0;\n}\n\n \nstatic bool mrst_lvds_find_best_pll(const struct gma_limit_t *limit,\n\t\t\t\t    struct drm_crtc *crtc, int target,\n\t\t\t\t    int refclk, struct gma_clock_t *best_clock)\n{\n\tstruct gma_clock_t clock;\n\tint err = target;\n\n\tmemset(best_clock, 0, sizeof(*best_clock));\n\tmemset(&clock, 0, sizeof(clock));\n\n\tfor (clock.m = limit->m.min; clock.m <= limit->m.max; clock.m++) {\n\t\tfor (clock.p1 = limit->p1.min; clock.p1 <= limit->p1.max;\n\t\t     clock.p1++) {\n\t\t\tint this_err;\n\n\t\t\tmrst_lvds_clock(refclk, &clock);\n\n\t\t\tthis_err = abs(clock.dot - target);\n\t\t\tif (this_err < err) {\n\t\t\t\t*best_clock = clock;\n\t\t\t\terr = this_err;\n\t\t\t}\n\t\t}\n\t}\n\treturn err != target;\n}\n\n \nstatic void oaktrail_crtc_dpms(struct drm_crtc *crtc, int mode)\n{\n\tstruct drm_device *dev = crtc->dev;\n\tstruct drm_psb_private *dev_priv = to_drm_psb_private(dev);\n\tstruct gma_crtc *gma_crtc = to_gma_crtc(crtc);\n\tint pipe = gma_crtc->pipe;\n\tconst struct psb_offset *map = &dev_priv->regmap[pipe];\n\tu32 temp;\n\tint i;\n\tint need_aux = gma_pipe_has_type(crtc, INTEL_OUTPUT_SDVO) ? 1 : 0;\n\n\tif (gma_pipe_has_type(crtc, INTEL_OUTPUT_HDMI)) {\n\t\toaktrail_crtc_hdmi_dpms(crtc, mode);\n\t\treturn;\n\t}\n\n\tif (!gma_power_begin(dev, true))\n\t\treturn;\n\n\t \n\tswitch (mode) {\n\tcase DRM_MODE_DPMS_ON:\n\tcase DRM_MODE_DPMS_STANDBY:\n\tcase DRM_MODE_DPMS_SUSPEND:\n\t\tfor (i = 0; i <= need_aux; i++) {\n\t\t\t \n\t\t\ttemp = REG_READ_WITH_AUX(map->dpll, i);\n\t\t\tif ((temp & DPLL_VCO_ENABLE) == 0) {\n\t\t\t\tREG_WRITE_WITH_AUX(map->dpll, temp, i);\n\t\t\t\tREG_READ_WITH_AUX(map->dpll, i);\n\t\t\t\t \n\t\t\t\tudelay(150);\n\t\t\t\tREG_WRITE_WITH_AUX(map->dpll,\n\t\t\t\t\t\t   temp | DPLL_VCO_ENABLE, i);\n\t\t\t\tREG_READ_WITH_AUX(map->dpll, i);\n\t\t\t\t \n\t\t\t\tudelay(150);\n\t\t\t\tREG_WRITE_WITH_AUX(map->dpll,\n\t\t\t\t\t\t   temp | DPLL_VCO_ENABLE, i);\n\t\t\t\tREG_READ_WITH_AUX(map->dpll, i);\n\t\t\t\t \n\t\t\t\tudelay(150);\n\t\t\t}\n\n\t\t\t \n\t\t\ttemp = REG_READ_WITH_AUX(map->conf, i);\n\t\t\tif ((temp & PIPEACONF_ENABLE) == 0) {\n\t\t\t\tREG_WRITE_WITH_AUX(map->conf,\n\t\t\t\t\t\t   temp | PIPEACONF_ENABLE, i);\n\t\t\t}\n\n\t\t\t \n\t\t\ttemp = REG_READ_WITH_AUX(map->cntr, i);\n\t\t\tif ((temp & DISPLAY_PLANE_ENABLE) == 0) {\n\t\t\t\tREG_WRITE_WITH_AUX(map->cntr,\n\t\t\t\t\t\t   temp | DISPLAY_PLANE_ENABLE,\n\t\t\t\t\t\t   i);\n\t\t\t\t \n\t\t\t\tREG_WRITE_WITH_AUX(map->base,\n\t\t\t\t\tREG_READ_WITH_AUX(map->base, i), i);\n\t\t\t}\n\n\t\t}\n\t\tgma_crtc_load_lut(crtc);\n\n\t\t \n\t\t \n\t\tbreak;\n\tcase DRM_MODE_DPMS_OFF:\n\t\t \n\t\t \n\n\t\tfor (i = 0; i <= need_aux; i++) {\n\t\t\t \n\t\t\tREG_WRITE_WITH_AUX(VGACNTRL, VGA_DISP_DISABLE, i);\n\t\t\t \n\t\t\ttemp = REG_READ_WITH_AUX(map->cntr, i);\n\t\t\tif ((temp & DISPLAY_PLANE_ENABLE) != 0) {\n\t\t\t\tREG_WRITE_WITH_AUX(map->cntr,\n\t\t\t\t\ttemp & ~DISPLAY_PLANE_ENABLE, i);\n\t\t\t\t \n\t\t\t\tREG_WRITE_WITH_AUX(map->base,\n\t\t\t\t\t\t   REG_READ(map->base), i);\n\t\t\t\tREG_READ_WITH_AUX(map->base, i);\n\t\t\t}\n\n\t\t\t \n\t\t\ttemp = REG_READ_WITH_AUX(map->conf, i);\n\t\t\tif ((temp & PIPEACONF_ENABLE) != 0) {\n\t\t\t\tREG_WRITE_WITH_AUX(map->conf,\n\t\t\t\t\t\t   temp & ~PIPEACONF_ENABLE, i);\n\t\t\t\tREG_READ_WITH_AUX(map->conf, i);\n\t\t\t}\n\t\t\t \n\t\t\tgma_wait_for_vblank(dev);\n\n\t\t\ttemp = REG_READ_WITH_AUX(map->dpll, i);\n\t\t\tif ((temp & DPLL_VCO_ENABLE) != 0) {\n\t\t\t\tREG_WRITE_WITH_AUX(map->dpll,\n\t\t\t\t\t\t   temp & ~DPLL_VCO_ENABLE, i);\n\t\t\t\tREG_READ_WITH_AUX(map->dpll, i);\n\t\t\t}\n\n\t\t\t \n\t\t\tudelay(150);\n\t\t}\n\t\tbreak;\n\t}\n\n\t \n\tREG_WRITE(DSPARB, 0x3f80);\n\tREG_WRITE(DSPFW1, 0x3f8f0404);\n\tREG_WRITE(DSPFW2, 0x04040f04);\n\tREG_WRITE(DSPFW3, 0x0);\n\tREG_WRITE(DSPFW4, 0x04040404);\n\tREG_WRITE(DSPFW5, 0x04040404);\n\tREG_WRITE(DSPFW6, 0x78);\n\tREG_WRITE(DSPCHICKENBIT, REG_READ(DSPCHICKENBIT) | 0xc040);\n\n\tgma_power_end(dev);\n}\n\n \nstatic int oaktrail_panel_fitter_pipe(struct drm_device *dev)\n{\n\tu32 pfit_control;\n\n\tpfit_control = REG_READ(PFIT_CONTROL);\n\n\t \n\tif ((pfit_control & PFIT_ENABLE) == 0)\n\t\treturn -1;\n\treturn (pfit_control >> 29) & 3;\n}\n\nstatic int oaktrail_crtc_mode_set(struct drm_crtc *crtc,\n\t\t\t      struct drm_display_mode *mode,\n\t\t\t      struct drm_display_mode *adjusted_mode,\n\t\t\t      int x, int y,\n\t\t\t      struct drm_framebuffer *old_fb)\n{\n\tstruct drm_device *dev = crtc->dev;\n\tstruct gma_crtc *gma_crtc = to_gma_crtc(crtc);\n\tstruct drm_psb_private *dev_priv = to_drm_psb_private(dev);\n\tint pipe = gma_crtc->pipe;\n\tconst struct psb_offset *map = &dev_priv->regmap[pipe];\n\tint refclk = 0;\n\tstruct gma_clock_t clock;\n\tconst struct gma_limit_t *limit;\n\tu32 dpll = 0, fp = 0, dspcntr, pipeconf;\n\tbool ok, is_sdvo = false;\n\tbool is_lvds = false;\n\tbool is_mipi = false;\n\tstruct gma_encoder *gma_encoder = NULL;\n\tuint64_t scalingType = DRM_MODE_SCALE_FULLSCREEN;\n\tstruct drm_connector_list_iter conn_iter;\n\tstruct drm_connector *connector;\n\tint i;\n\tint need_aux = gma_pipe_has_type(crtc, INTEL_OUTPUT_SDVO) ? 1 : 0;\n\n\tif (gma_pipe_has_type(crtc, INTEL_OUTPUT_HDMI))\n\t\treturn oaktrail_crtc_hdmi_mode_set(crtc, mode, adjusted_mode, x, y, old_fb);\n\n\tif (!gma_power_begin(dev, true))\n\t\treturn 0;\n\n\tdrm_mode_copy(&gma_crtc->saved_mode, mode);\n\tdrm_mode_copy(&gma_crtc->saved_adjusted_mode, adjusted_mode);\n\n\tdrm_connector_list_iter_begin(dev, &conn_iter);\n\tdrm_for_each_connector_iter(connector, &conn_iter) {\n\t\tif (!connector->encoder || connector->encoder->crtc != crtc)\n\t\t\tcontinue;\n\n\t\tgma_encoder = gma_attached_encoder(connector);\n\n\t\tswitch (gma_encoder->type) {\n\t\tcase INTEL_OUTPUT_LVDS:\n\t\t\tis_lvds = true;\n\t\t\tbreak;\n\t\tcase INTEL_OUTPUT_SDVO:\n\t\t\tis_sdvo = true;\n\t\t\tbreak;\n\t\tcase INTEL_OUTPUT_MIPI:\n\t\t\tis_mipi = true;\n\t\t\tbreak;\n\t\t}\n\n\t\tbreak;\n\t}\n\n\tif (gma_encoder)\n\t\tdrm_object_property_get_value(&connector->base,\n\t\t\tdev->mode_config.scaling_mode_property, &scalingType);\n\n\tdrm_connector_list_iter_end(&conn_iter);\n\n\t \n\tfor (i = 0; i <= need_aux; i++)\n\t\tREG_WRITE_WITH_AUX(VGACNTRL, VGA_DISP_DISABLE, i);\n\n\t \n\tif (oaktrail_panel_fitter_pipe(dev) == pipe)\n\t\tREG_WRITE(PFIT_CONTROL, 0);\n\n\tfor (i = 0; i <= need_aux; i++) {\n\t\tREG_WRITE_WITH_AUX(map->src, ((mode->crtc_hdisplay - 1) << 16) |\n\t\t\t\t\t     (mode->crtc_vdisplay - 1), i);\n\t}\n\n\tif (scalingType == DRM_MODE_SCALE_NO_SCALE) {\n\t\t \n\t\tint offsetX = 0, offsetY = 0;\n\n\t\toffsetX = (adjusted_mode->crtc_hdisplay -\n\t\t\t   mode->crtc_hdisplay) / 2;\n\t\toffsetY = (adjusted_mode->crtc_vdisplay -\n\t\t\t   mode->crtc_vdisplay) / 2;\n\n\t\tfor (i = 0; i <= need_aux; i++) {\n\t\t\tREG_WRITE_WITH_AUX(map->htotal, (mode->crtc_hdisplay - 1) |\n\t\t\t\t((adjusted_mode->crtc_htotal - 1) << 16), i);\n\t\t\tREG_WRITE_WITH_AUX(map->vtotal, (mode->crtc_vdisplay - 1) |\n\t\t\t\t((adjusted_mode->crtc_vtotal - 1) << 16), i);\n\t\t\tREG_WRITE_WITH_AUX(map->hblank,\n\t\t\t\t(adjusted_mode->crtc_hblank_start - offsetX - 1) |\n\t\t\t\t((adjusted_mode->crtc_hblank_end - offsetX - 1) << 16), i);\n\t\t\tREG_WRITE_WITH_AUX(map->hsync,\n\t\t\t\t(adjusted_mode->crtc_hsync_start - offsetX - 1) |\n\t\t\t\t((adjusted_mode->crtc_hsync_end - offsetX - 1) << 16), i);\n\t\t\tREG_WRITE_WITH_AUX(map->vblank,\n\t\t\t\t(adjusted_mode->crtc_vblank_start - offsetY - 1) |\n\t\t\t\t((adjusted_mode->crtc_vblank_end - offsetY - 1) << 16), i);\n\t\t\tREG_WRITE_WITH_AUX(map->vsync,\n\t\t\t\t(adjusted_mode->crtc_vsync_start - offsetY - 1) |\n\t\t\t\t((adjusted_mode->crtc_vsync_end - offsetY - 1) << 16), i);\n\t\t}\n\t} else {\n\t\tfor (i = 0; i <= need_aux; i++) {\n\t\t\tREG_WRITE_WITH_AUX(map->htotal, (adjusted_mode->crtc_hdisplay - 1) |\n\t\t\t\t((adjusted_mode->crtc_htotal - 1) << 16), i);\n\t\t\tREG_WRITE_WITH_AUX(map->vtotal, (adjusted_mode->crtc_vdisplay - 1) |\n\t\t\t\t((adjusted_mode->crtc_vtotal - 1) << 16), i);\n\t\t\tREG_WRITE_WITH_AUX(map->hblank, (adjusted_mode->crtc_hblank_start - 1) |\n\t\t\t\t((adjusted_mode->crtc_hblank_end - 1) << 16), i);\n\t\t\tREG_WRITE_WITH_AUX(map->hsync, (adjusted_mode->crtc_hsync_start - 1) |\n\t\t\t\t((adjusted_mode->crtc_hsync_end - 1) << 16), i);\n\t\t\tREG_WRITE_WITH_AUX(map->vblank, (adjusted_mode->crtc_vblank_start - 1) |\n\t\t\t\t((adjusted_mode->crtc_vblank_end - 1) << 16), i);\n\t\t\tREG_WRITE_WITH_AUX(map->vsync, (adjusted_mode->crtc_vsync_start - 1) |\n\t\t\t\t((adjusted_mode->crtc_vsync_end - 1) << 16), i);\n\t\t}\n\t}\n\n\t \n\t{\n\t\tconst struct drm_crtc_helper_funcs *crtc_funcs =\n\t\t    crtc->helper_private;\n\t\tcrtc_funcs->mode_set_base(crtc, x, y, old_fb);\n\t}\n\n\t \n\tpipeconf = REG_READ(map->conf);\n\n\t \n\tdspcntr = REG_READ(map->cntr);\n\tdspcntr |= DISPPLANE_GAMMA_ENABLE;\n\n\tif (pipe == 0)\n\t\tdspcntr |= DISPPLANE_SEL_PIPE_A;\n\telse\n\t\tdspcntr |= DISPPLANE_SEL_PIPE_B;\n\n\tif (is_mipi)\n\t\tgoto oaktrail_crtc_mode_set_exit;\n\n\n\tdpll = 0;\t\t \n\n\trefclk = is_sdvo ? 96000 : dev_priv->core_freq * 1000;\n\tlimit = mrst_limit(crtc, refclk);\n\tok = limit->find_pll(limit, crtc, adjusted_mode->clock,\n\t\t\t     refclk, &clock);\n\n\tif (is_sdvo) {\n\t\t \n\t\tclock.p1 = (1L << (clock.p1 - 1));\n\t\tclock.m -= 2;\n\t\tclock.n = (1L << (clock.n - 1));\n\t}\n\n\tif (!ok)\n\t\tDRM_ERROR(\"Failed to find proper PLL settings\");\n\n\tmrst_print_pll(&clock);\n\n\tif (is_sdvo)\n\t\tfp = clock.n << 16 | clock.m;\n\telse\n\t\tfp = oaktrail_m_converts[(clock.m - MRST_M_MIN)] << 8;\n\n\tdpll |= DPLL_VGA_MODE_DIS;\n\n\n\tdpll |= DPLL_VCO_ENABLE;\n\n\tif (is_lvds)\n\t\tdpll |= DPLLA_MODE_LVDS;\n\telse\n\t\tdpll |= DPLLB_MODE_DAC_SERIAL;\n\n\tif (is_sdvo) {\n\t\tint sdvo_pixel_multiply =\n\t\t    adjusted_mode->clock / mode->clock;\n\n\t\tdpll |= DPLL_DVO_HIGH_SPEED;\n\t\tdpll |=\n\t\t    (sdvo_pixel_multiply -\n\t\t     1) << SDVO_MULTIPLIER_SHIFT_HIRES;\n\t}\n\n\n\t \n\tif (is_sdvo)\n\t\tdpll |= clock.p1 << 16; \n\telse\n\t\tdpll |= (1 << (clock.p1 - 2)) << 17;\n\n\tdpll |= DPLL_VCO_ENABLE;\n\n\tif (dpll & DPLL_VCO_ENABLE) {\n\t\tfor (i = 0; i <= need_aux; i++) {\n\t\t\tREG_WRITE_WITH_AUX(map->fp0, fp, i);\n\t\t\tREG_WRITE_WITH_AUX(map->dpll, dpll & ~DPLL_VCO_ENABLE, i);\n\t\t\tREG_READ_WITH_AUX(map->dpll, i);\n\t\t\t \n\t\t\tudelay(150);\n\t\t}\n\t}\n\n\tfor (i = 0; i <= need_aux; i++) {\n\t\tREG_WRITE_WITH_AUX(map->fp0, fp, i);\n\t\tREG_WRITE_WITH_AUX(map->dpll, dpll, i);\n\t\tREG_READ_WITH_AUX(map->dpll, i);\n\t\t \n\t\tudelay(150);\n\n\t\t \n\t\tREG_WRITE_WITH_AUX(map->dpll, dpll, i);\n\t\tREG_READ_WITH_AUX(map->dpll, i);\n\t\t \n\t\tudelay(150);\n\n\t\tREG_WRITE_WITH_AUX(map->conf, pipeconf, i);\n\t\tREG_READ_WITH_AUX(map->conf, i);\n\t\tgma_wait_for_vblank(dev);\n\n\t\tREG_WRITE_WITH_AUX(map->cntr, dspcntr, i);\n\t\tgma_wait_for_vblank(dev);\n\t}\n\noaktrail_crtc_mode_set_exit:\n\tgma_power_end(dev);\n\treturn 0;\n}\n\nstatic int oaktrail_pipe_set_base(struct drm_crtc *crtc,\n\t\t\t    int x, int y, struct drm_framebuffer *old_fb)\n{\n\tstruct drm_device *dev = crtc->dev;\n\tstruct drm_psb_private *dev_priv = to_drm_psb_private(dev);\n\tstruct gma_crtc *gma_crtc = to_gma_crtc(crtc);\n\tstruct drm_framebuffer *fb = crtc->primary->fb;\n\tint pipe = gma_crtc->pipe;\n\tconst struct psb_offset *map = &dev_priv->regmap[pipe];\n\tunsigned long start, offset;\n\n\tu32 dspcntr;\n\tint ret = 0;\n\n\t \n\tif (!fb) {\n\t\tdev_dbg(dev->dev, \"No FB bound\\n\");\n\t\treturn 0;\n\t}\n\n\tif (!gma_power_begin(dev, true))\n\t\treturn 0;\n\n\tstart = to_psb_gem_object(fb->obj[0])->offset;\n\toffset = y * fb->pitches[0] + x * fb->format->cpp[0];\n\n\tREG_WRITE(map->stride, fb->pitches[0]);\n\n\tdspcntr = REG_READ(map->cntr);\n\tdspcntr &= ~DISPPLANE_PIXFORMAT_MASK;\n\n\tswitch (fb->format->cpp[0] * 8) {\n\tcase 8:\n\t\tdspcntr |= DISPPLANE_8BPP;\n\t\tbreak;\n\tcase 16:\n\t\tif (fb->format->depth == 15)\n\t\t\tdspcntr |= DISPPLANE_15_16BPP;\n\t\telse\n\t\t\tdspcntr |= DISPPLANE_16BPP;\n\t\tbreak;\n\tcase 24:\n\tcase 32:\n\t\tdspcntr |= DISPPLANE_32BPP_NO_ALPHA;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(dev->dev, \"Unknown color depth\\n\");\n\t\tret = -EINVAL;\n\t\tgoto pipe_set_base_exit;\n\t}\n\tREG_WRITE(map->cntr, dspcntr);\n\n\tREG_WRITE(map->base, offset);\n\tREG_READ(map->base);\n\tREG_WRITE(map->surf, start);\n\tREG_READ(map->surf);\n\npipe_set_base_exit:\n\tgma_power_end(dev);\n\treturn ret;\n}\n\nconst struct drm_crtc_helper_funcs oaktrail_helper_funcs = {\n\t.dpms = oaktrail_crtc_dpms,\n\t.mode_set = oaktrail_crtc_mode_set,\n\t.mode_set_base = oaktrail_pipe_set_base,\n\t.prepare = gma_crtc_prepare,\n\t.commit = gma_crtc_commit,\n};\n\n \nconst struct gma_clock_funcs mrst_clock_funcs = {\n\t.clock = mrst_lvds_clock,\n\t.limit = mrst_limit,\n\t.pll_is_valid = gma_pll_is_valid,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}