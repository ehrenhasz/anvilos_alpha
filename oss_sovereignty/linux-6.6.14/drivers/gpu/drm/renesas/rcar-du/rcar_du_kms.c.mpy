{
  "module_name": "rcar_du_kms.c",
  "hash_id": "1935acb8862ce2bd621ab9bf4e273281edb1e6e360579e68b0a2c3e3dbd6bff6",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/renesas/rcar-du/rcar_du_kms.c",
  "human_readable_source": "\n \n\n#include <drm/drm_atomic.h>\n#include <drm/drm_atomic_helper.h>\n#include <drm/drm_crtc.h>\n#include <drm/drm_device.h>\n#include <drm/drm_framebuffer.h>\n#include <drm/drm_gem_dma_helper.h>\n#include <drm/drm_gem_framebuffer_helper.h>\n#include <drm/drm_managed.h>\n#include <drm/drm_probe_helper.h>\n#include <drm/drm_vblank.h>\n\n#include <linux/device.h>\n#include <linux/dma-buf.h>\n#include <linux/of.h>\n#include <linux/of_graph.h>\n#include <linux/of_platform.h>\n#include <linux/platform_device.h>\n#include <linux/wait.h>\n\n#include \"rcar_du_crtc.h\"\n#include \"rcar_du_drv.h\"\n#include \"rcar_du_encoder.h\"\n#include \"rcar_du_kms.h\"\n#include \"rcar_du_regs.h\"\n#include \"rcar_du_vsp.h\"\n#include \"rcar_du_writeback.h\"\n\n \n\nstatic const struct rcar_du_format_info rcar_du_format_infos[] = {\n\t{\n\t\t.fourcc = DRM_FORMAT_RGB565,\n\t\t.v4l2 = V4L2_PIX_FMT_RGB565,\n\t\t.bpp = 16,\n\t\t.planes = 1,\n\t\t.hsub = 1,\n\t\t.pnmr = PnMR_SPIM_TP | PnMR_DDDF_16BPP,\n\t\t.edf = PnDDCR4_EDF_NONE,\n\t}, {\n\t\t.fourcc = DRM_FORMAT_ARGB1555,\n\t\t.v4l2 = V4L2_PIX_FMT_ARGB555,\n\t\t.bpp = 16,\n\t\t.planes = 1,\n\t\t.hsub = 1,\n\t\t.pnmr = PnMR_SPIM_ALP | PnMR_DDDF_ARGB,\n\t\t.edf = PnDDCR4_EDF_NONE,\n\t}, {\n\t\t.fourcc = DRM_FORMAT_XRGB1555,\n\t\t.v4l2 = V4L2_PIX_FMT_XRGB555,\n\t\t.bpp = 16,\n\t\t.planes = 1,\n\t\t.pnmr = PnMR_SPIM_ALP | PnMR_DDDF_ARGB,\n\t\t.edf = PnDDCR4_EDF_NONE,\n\t}, {\n\t\t.fourcc = DRM_FORMAT_XRGB8888,\n\t\t.v4l2 = V4L2_PIX_FMT_XBGR32,\n\t\t.bpp = 32,\n\t\t.planes = 1,\n\t\t.hsub = 1,\n\t\t.pnmr = PnMR_SPIM_TP | PnMR_DDDF_16BPP,\n\t\t.edf = PnDDCR4_EDF_RGB888,\n\t}, {\n\t\t.fourcc = DRM_FORMAT_ARGB8888,\n\t\t.v4l2 = V4L2_PIX_FMT_ABGR32,\n\t\t.bpp = 32,\n\t\t.planes = 1,\n\t\t.hsub = 1,\n\t\t.pnmr = PnMR_SPIM_ALP | PnMR_DDDF_16BPP,\n\t\t.edf = PnDDCR4_EDF_ARGB8888,\n\t}, {\n\t\t.fourcc = DRM_FORMAT_UYVY,\n\t\t.v4l2 = V4L2_PIX_FMT_UYVY,\n\t\t.bpp = 16,\n\t\t.planes = 1,\n\t\t.hsub = 2,\n\t\t.pnmr = PnMR_SPIM_TP_OFF | PnMR_DDDF_YC,\n\t\t.edf = PnDDCR4_EDF_NONE,\n\t}, {\n\t\t.fourcc = DRM_FORMAT_YUYV,\n\t\t.v4l2 = V4L2_PIX_FMT_YUYV,\n\t\t.bpp = 16,\n\t\t.planes = 1,\n\t\t.hsub = 2,\n\t\t.pnmr = PnMR_SPIM_TP_OFF | PnMR_DDDF_YC,\n\t\t.edf = PnDDCR4_EDF_NONE,\n\t}, {\n\t\t.fourcc = DRM_FORMAT_NV12,\n\t\t.v4l2 = V4L2_PIX_FMT_NV12M,\n\t\t.bpp = 12,\n\t\t.planes = 2,\n\t\t.hsub = 2,\n\t\t.pnmr = PnMR_SPIM_TP_OFF | PnMR_DDDF_YC,\n\t\t.edf = PnDDCR4_EDF_NONE,\n\t}, {\n\t\t.fourcc = DRM_FORMAT_NV21,\n\t\t.v4l2 = V4L2_PIX_FMT_NV21M,\n\t\t.bpp = 12,\n\t\t.planes = 2,\n\t\t.hsub = 2,\n\t\t.pnmr = PnMR_SPIM_TP_OFF | PnMR_DDDF_YC,\n\t\t.edf = PnDDCR4_EDF_NONE,\n\t}, {\n\t\t.fourcc = DRM_FORMAT_NV16,\n\t\t.v4l2 = V4L2_PIX_FMT_NV16M,\n\t\t.bpp = 16,\n\t\t.planes = 2,\n\t\t.hsub = 2,\n\t\t.pnmr = PnMR_SPIM_TP_OFF | PnMR_DDDF_YC,\n\t\t.edf = PnDDCR4_EDF_NONE,\n\t},\n\t \n\t{\n\t\t.fourcc = DRM_FORMAT_RGB332,\n\t\t.v4l2 = V4L2_PIX_FMT_RGB332,\n\t\t.bpp = 8,\n\t\t.planes = 1,\n\t\t.hsub = 1,\n\t}, {\n\t\t.fourcc = DRM_FORMAT_ARGB4444,\n\t\t.v4l2 = V4L2_PIX_FMT_ARGB444,\n\t\t.bpp = 16,\n\t\t.planes = 1,\n\t\t.hsub = 1,\n\t}, {\n\t\t.fourcc = DRM_FORMAT_XRGB4444,\n\t\t.v4l2 = V4L2_PIX_FMT_XRGB444,\n\t\t.bpp = 16,\n\t\t.planes = 1,\n\t\t.hsub = 1,\n\t}, {\n\t\t.fourcc = DRM_FORMAT_RGBA4444,\n\t\t.v4l2 = V4L2_PIX_FMT_RGBA444,\n\t\t.bpp = 16,\n\t\t.planes = 1,\n\t\t.hsub = 1,\n\t}, {\n\t\t.fourcc = DRM_FORMAT_RGBX4444,\n\t\t.v4l2 = V4L2_PIX_FMT_RGBX444,\n\t\t.bpp = 16,\n\t\t.planes = 1,\n\t\t.hsub = 1,\n\t}, {\n\t\t.fourcc = DRM_FORMAT_ABGR4444,\n\t\t.v4l2 = V4L2_PIX_FMT_ABGR444,\n\t\t.bpp = 16,\n\t\t.planes = 1,\n\t\t.hsub = 1,\n\t}, {\n\t\t.fourcc = DRM_FORMAT_XBGR4444,\n\t\t.v4l2 = V4L2_PIX_FMT_XBGR444,\n\t\t.bpp = 16,\n\t\t.planes = 1,\n\t\t.hsub = 1,\n\t}, {\n\t\t.fourcc = DRM_FORMAT_BGRA4444,\n\t\t.v4l2 = V4L2_PIX_FMT_BGRA444,\n\t\t.bpp = 16,\n\t\t.planes = 1,\n\t\t.hsub = 1,\n\t}, {\n\t\t.fourcc = DRM_FORMAT_BGRX4444,\n\t\t.v4l2 = V4L2_PIX_FMT_BGRX444,\n\t\t.bpp = 16,\n\t\t.planes = 1,\n\t\t.hsub = 1,\n\t}, {\n\t\t.fourcc = DRM_FORMAT_RGBA5551,\n\t\t.v4l2 = V4L2_PIX_FMT_RGBA555,\n\t\t.bpp = 16,\n\t\t.planes = 1,\n\t\t.hsub = 1,\n\t}, {\n\t\t.fourcc = DRM_FORMAT_RGBX5551,\n\t\t.v4l2 = V4L2_PIX_FMT_RGBX555,\n\t\t.bpp = 16,\n\t\t.planes = 1,\n\t\t.hsub = 1,\n\t}, {\n\t\t.fourcc = DRM_FORMAT_ABGR1555,\n\t\t.v4l2 = V4L2_PIX_FMT_ABGR555,\n\t\t.bpp = 16,\n\t\t.planes = 1,\n\t\t.hsub = 1,\n\t}, {\n\t\t.fourcc = DRM_FORMAT_XBGR1555,\n\t\t.v4l2 = V4L2_PIX_FMT_XBGR555,\n\t\t.bpp = 16,\n\t\t.planes = 1,\n\t\t.hsub = 1,\n\t}, {\n\t\t.fourcc = DRM_FORMAT_BGRA5551,\n\t\t.v4l2 = V4L2_PIX_FMT_BGRA555,\n\t\t.bpp = 16,\n\t\t.planes = 1,\n\t\t.hsub = 1,\n\t}, {\n\t\t.fourcc = DRM_FORMAT_BGRX5551,\n\t\t.v4l2 = V4L2_PIX_FMT_BGRX555,\n\t\t.bpp = 16,\n\t\t.planes = 1,\n\t\t.hsub = 1,\n\t}, {\n\t\t.fourcc = DRM_FORMAT_BGR888,\n\t\t.v4l2 = V4L2_PIX_FMT_RGB24,\n\t\t.bpp = 24,\n\t\t.planes = 1,\n\t\t.hsub = 1,\n\t}, {\n\t\t.fourcc = DRM_FORMAT_RGB888,\n\t\t.v4l2 = V4L2_PIX_FMT_BGR24,\n\t\t.bpp = 24,\n\t\t.planes = 1,\n\t\t.hsub = 1,\n\t}, {\n\t\t.fourcc = DRM_FORMAT_RGBA8888,\n\t\t.v4l2 = V4L2_PIX_FMT_BGRA32,\n\t\t.bpp = 32,\n\t\t.planes = 1,\n\t\t.hsub = 1,\n\t}, {\n\t\t.fourcc = DRM_FORMAT_RGBX8888,\n\t\t.v4l2 = V4L2_PIX_FMT_BGRX32,\n\t\t.bpp = 32,\n\t\t.planes = 1,\n\t\t.hsub = 1,\n\t}, {\n\t\t.fourcc = DRM_FORMAT_ABGR8888,\n\t\t.v4l2 = V4L2_PIX_FMT_RGBA32,\n\t\t.bpp = 32,\n\t\t.planes = 1,\n\t\t.hsub = 1,\n\t}, {\n\t\t.fourcc = DRM_FORMAT_XBGR8888,\n\t\t.v4l2 = V4L2_PIX_FMT_RGBX32,\n\t\t.bpp = 32,\n\t\t.planes = 1,\n\t\t.hsub = 1,\n\t}, {\n\t\t.fourcc = DRM_FORMAT_BGRA8888,\n\t\t.v4l2 = V4L2_PIX_FMT_ARGB32,\n\t\t.bpp = 32,\n\t\t.planes = 1,\n\t\t.hsub = 1,\n\t}, {\n\t\t.fourcc = DRM_FORMAT_BGRX8888,\n\t\t.v4l2 = V4L2_PIX_FMT_XRGB32,\n\t\t.bpp = 32,\n\t\t.planes = 1,\n\t\t.hsub = 1,\n\t}, {\n\t\t.fourcc = DRM_FORMAT_RGBX1010102,\n\t\t.v4l2 = V4L2_PIX_FMT_RGBX1010102,\n\t\t.bpp = 32,\n\t\t.planes = 1,\n\t\t.hsub = 1,\n\t}, {\n\t\t.fourcc = DRM_FORMAT_RGBA1010102,\n\t\t.v4l2 = V4L2_PIX_FMT_RGBA1010102,\n\t\t.bpp = 32,\n\t\t.planes = 1,\n\t\t.hsub = 1,\n\t}, {\n\t\t.fourcc = DRM_FORMAT_ARGB2101010,\n\t\t.v4l2 = V4L2_PIX_FMT_ARGB2101010,\n\t\t.bpp = 32,\n\t\t.planes = 1,\n\t\t.hsub = 1,\n\t}, {\n\t\t.fourcc = DRM_FORMAT_YVYU,\n\t\t.v4l2 = V4L2_PIX_FMT_YVYU,\n\t\t.bpp = 16,\n\t\t.planes = 1,\n\t\t.hsub = 2,\n\t}, {\n\t\t.fourcc = DRM_FORMAT_NV61,\n\t\t.v4l2 = V4L2_PIX_FMT_NV61M,\n\t\t.bpp = 16,\n\t\t.planes = 2,\n\t\t.hsub = 2,\n\t}, {\n\t\t.fourcc = DRM_FORMAT_YUV420,\n\t\t.v4l2 = V4L2_PIX_FMT_YUV420M,\n\t\t.bpp = 12,\n\t\t.planes = 3,\n\t\t.hsub = 2,\n\t}, {\n\t\t.fourcc = DRM_FORMAT_YVU420,\n\t\t.v4l2 = V4L2_PIX_FMT_YVU420M,\n\t\t.bpp = 12,\n\t\t.planes = 3,\n\t\t.hsub = 2,\n\t}, {\n\t\t.fourcc = DRM_FORMAT_YUV422,\n\t\t.v4l2 = V4L2_PIX_FMT_YUV422M,\n\t\t.bpp = 16,\n\t\t.planes = 3,\n\t\t.hsub = 2,\n\t}, {\n\t\t.fourcc = DRM_FORMAT_YVU422,\n\t\t.v4l2 = V4L2_PIX_FMT_YVU422M,\n\t\t.bpp = 16,\n\t\t.planes = 3,\n\t\t.hsub = 2,\n\t}, {\n\t\t.fourcc = DRM_FORMAT_YUV444,\n\t\t.v4l2 = V4L2_PIX_FMT_YUV444M,\n\t\t.bpp = 24,\n\t\t.planes = 3,\n\t\t.hsub = 1,\n\t}, {\n\t\t.fourcc = DRM_FORMAT_YVU444,\n\t\t.v4l2 = V4L2_PIX_FMT_YVU444M,\n\t\t.bpp = 24,\n\t\t.planes = 3,\n\t\t.hsub = 1,\n\t}, {\n\t\t.fourcc = DRM_FORMAT_Y210,\n\t\t.v4l2 = V4L2_PIX_FMT_Y210,\n\t\t.bpp = 32,\n\t\t.planes = 1,\n\t\t.hsub = 2,\n\t}, {\n\t\t.fourcc = DRM_FORMAT_Y212,\n\t\t.v4l2 = V4L2_PIX_FMT_Y212,\n\t\t.bpp = 32,\n\t\t.planes = 1,\n\t\t.hsub = 2,\n\t},\n};\n\nconst struct rcar_du_format_info *rcar_du_format_info(u32 fourcc)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < ARRAY_SIZE(rcar_du_format_infos); ++i) {\n\t\tif (rcar_du_format_infos[i].fourcc == fourcc)\n\t\t\treturn &rcar_du_format_infos[i];\n\t}\n\n\treturn NULL;\n}\n\n \n\nstatic const struct drm_gem_object_funcs rcar_du_gem_funcs = {\n\t.free = drm_gem_dma_object_free,\n\t.print_info = drm_gem_dma_object_print_info,\n\t.get_sg_table = drm_gem_dma_object_get_sg_table,\n\t.vmap = drm_gem_dma_object_vmap,\n\t.mmap = drm_gem_dma_object_mmap,\n\t.vm_ops = &drm_gem_dma_vm_ops,\n};\n\nstruct drm_gem_object *rcar_du_gem_prime_import_sg_table(struct drm_device *dev,\n\t\t\t\tstruct dma_buf_attachment *attach,\n\t\t\t\tstruct sg_table *sgt)\n{\n\tstruct rcar_du_device *rcdu = to_rcar_du_device(dev);\n\tstruct drm_gem_dma_object *dma_obj;\n\tstruct drm_gem_object *gem_obj;\n\tint ret;\n\n\tif (!rcar_du_has(rcdu, RCAR_DU_FEATURE_VSP1_SOURCE))\n\t\treturn drm_gem_dma_prime_import_sg_table(dev, attach, sgt);\n\n\t \n\tdma_obj = kzalloc(sizeof(*dma_obj), GFP_KERNEL);\n\tif (!dma_obj)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tgem_obj = &dma_obj->base;\n\tgem_obj->funcs = &rcar_du_gem_funcs;\n\n\tdrm_gem_private_object_init(dev, gem_obj, attach->dmabuf->size);\n\tdma_obj->map_noncoherent = false;\n\n\tret = drm_gem_create_mmap_offset(gem_obj);\n\tif (ret) {\n\t\tdrm_gem_object_release(gem_obj);\n\t\tkfree(dma_obj);\n\t\treturn ERR_PTR(ret);\n\t}\n\n\tdma_obj->dma_addr = 0;\n\tdma_obj->sgt = sgt;\n\n\treturn gem_obj;\n}\n\nint rcar_du_dumb_create(struct drm_file *file, struct drm_device *dev,\n\t\t\tstruct drm_mode_create_dumb *args)\n{\n\tstruct rcar_du_device *rcdu = to_rcar_du_device(dev);\n\tunsigned int min_pitch = DIV_ROUND_UP(args->width * args->bpp, 8);\n\tunsigned int align;\n\n\t \n\tif (rcar_du_needs(rcdu, RCAR_DU_QUIRK_ALIGN_128B))\n\t\talign = 128;\n\telse\n\t\talign = 16 * args->bpp / 8;\n\n\targs->pitch = roundup(min_pitch, align);\n\n\treturn drm_gem_dma_dumb_create_internal(file, dev, args);\n}\n\nstatic struct drm_framebuffer *\nrcar_du_fb_create(struct drm_device *dev, struct drm_file *file_priv,\n\t\t  const struct drm_mode_fb_cmd2 *mode_cmd)\n{\n\tstruct rcar_du_device *rcdu = to_rcar_du_device(dev);\n\tconst struct rcar_du_format_info *format;\n\tunsigned int chroma_pitch;\n\tunsigned int max_pitch;\n\tunsigned int align;\n\tunsigned int i;\n\n\tformat = rcar_du_format_info(mode_cmd->pixel_format);\n\tif (format == NULL) {\n\t\tdev_dbg(dev->dev, \"unsupported pixel format %p4cc\\n\",\n\t\t\t&mode_cmd->pixel_format);\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\tif (rcdu->info->gen < 3) {\n\t\t \n\t\tunsigned int bpp = format->planes == 1 ? format->bpp / 8 : 1;\n\n\t\tmax_pitch = 4095 * bpp;\n\n\t\tif (rcar_du_needs(rcdu, RCAR_DU_QUIRK_ALIGN_128B))\n\t\t\talign = 128;\n\t\telse\n\t\t\talign = 16 * bpp;\n\t} else {\n\t\t \n\t\tmax_pitch = 65535;\n\t\talign = 1;\n\t}\n\n\tif (mode_cmd->pitches[0] & (align - 1) ||\n\t    mode_cmd->pitches[0] > max_pitch) {\n\t\tdev_dbg(dev->dev, \"invalid pitch value %u\\n\",\n\t\t\tmode_cmd->pitches[0]);\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\t \n\tchroma_pitch = mode_cmd->pitches[0] / format->hsub;\n\tif (format->planes == 2)\n\t\tchroma_pitch *= 2;\n\n\tfor (i = 1; i < format->planes; ++i) {\n\t\tif (mode_cmd->pitches[i] != chroma_pitch) {\n\t\t\tdev_dbg(dev->dev,\n\t\t\t\t\"luma and chroma pitches are not compatible\\n\");\n\t\t\treturn ERR_PTR(-EINVAL);\n\t\t}\n\t}\n\n\treturn drm_gem_fb_create(dev, file_priv, mode_cmd);\n}\n\n \n\nstatic int rcar_du_atomic_check(struct drm_device *dev,\n\t\t\t\tstruct drm_atomic_state *state)\n{\n\tstruct rcar_du_device *rcdu = to_rcar_du_device(dev);\n\tint ret;\n\n\tret = drm_atomic_helper_check(dev, state);\n\tif (ret)\n\t\treturn ret;\n\n\tif (rcar_du_has(rcdu, RCAR_DU_FEATURE_VSP1_SOURCE))\n\t\treturn 0;\n\n\treturn rcar_du_atomic_check_planes(dev, state);\n}\n\nstatic void rcar_du_atomic_commit_tail(struct drm_atomic_state *old_state)\n{\n\tstruct drm_device *dev = old_state->dev;\n\tstruct rcar_du_device *rcdu = to_rcar_du_device(dev);\n\tstruct drm_crtc_state *crtc_state;\n\tstruct drm_crtc *crtc;\n\tunsigned int i;\n\n\t \n\trcdu->dpad1_source = -1;\n\n\tfor_each_new_crtc_in_state(old_state, crtc, crtc_state, i) {\n\t\tstruct rcar_du_crtc_state *rcrtc_state =\n\t\t\tto_rcar_crtc_state(crtc_state);\n\t\tstruct rcar_du_crtc *rcrtc = to_rcar_crtc(crtc);\n\n\t\tif (rcrtc_state->outputs & BIT(RCAR_DU_OUTPUT_DPAD0))\n\t\t\trcdu->dpad0_source = rcrtc->index;\n\n\t\tif (rcrtc_state->outputs & BIT(RCAR_DU_OUTPUT_DPAD1))\n\t\t\trcdu->dpad1_source = rcrtc->index;\n\t}\n\n\t \n\tdrm_atomic_helper_commit_modeset_disables(dev, old_state);\n\tdrm_atomic_helper_commit_planes(dev, old_state,\n\t\t\t\t\tDRM_PLANE_COMMIT_ACTIVE_ONLY);\n\tdrm_atomic_helper_commit_modeset_enables(dev, old_state);\n\n\tdrm_atomic_helper_commit_hw_done(old_state);\n\tdrm_atomic_helper_wait_for_flip_done(dev, old_state);\n\n\tdrm_atomic_helper_cleanup_planes(dev, old_state);\n}\n\n \n\nstatic const struct drm_mode_config_helper_funcs rcar_du_mode_config_helper = {\n\t.atomic_commit_tail = rcar_du_atomic_commit_tail,\n};\n\nstatic const struct drm_mode_config_funcs rcar_du_mode_config_funcs = {\n\t.fb_create = rcar_du_fb_create,\n\t.atomic_check = rcar_du_atomic_check,\n\t.atomic_commit = drm_atomic_helper_commit,\n};\n\nstatic int rcar_du_encoders_init_one(struct rcar_du_device *rcdu,\n\t\t\t\t     enum rcar_du_output output,\n\t\t\t\t     struct of_endpoint *ep)\n{\n\tstruct device_node *entity;\n\tint ret;\n\n\t \n\tentity = of_graph_get_remote_port_parent(ep->local_node);\n\tif (!entity) {\n\t\tdev_dbg(rcdu->dev, \"unconnected endpoint %pOF, skipping\\n\",\n\t\t\tep->local_node);\n\t\treturn -ENODEV;\n\t}\n\n\tif (!of_device_is_available(entity)) {\n\t\tdev_dbg(rcdu->dev,\n\t\t\t\"connected entity %pOF is disabled, skipping\\n\",\n\t\t\tentity);\n\t\tof_node_put(entity);\n\t\treturn -ENODEV;\n\t}\n\n\tret = rcar_du_encoder_init(rcdu, output, entity);\n\tif (ret && ret != -EPROBE_DEFER && ret != -ENOLINK)\n\t\tdev_warn(rcdu->dev,\n\t\t\t \"failed to initialize encoder %pOF on output %s (%d), skipping\\n\",\n\t\t\t entity, rcar_du_output_name(output), ret);\n\n\tof_node_put(entity);\n\n\treturn ret;\n}\n\nstatic int rcar_du_encoders_init(struct rcar_du_device *rcdu)\n{\n\tstruct device_node *np = rcdu->dev->of_node;\n\tstruct device_node *ep_node;\n\tunsigned int num_encoders = 0;\n\n\t \n\tfor_each_endpoint_of_node(np, ep_node) {\n\t\tenum rcar_du_output output;\n\t\tstruct of_endpoint ep;\n\t\tunsigned int i;\n\t\tint ret;\n\n\t\tret = of_graph_parse_endpoint(ep_node, &ep);\n\t\tif (ret < 0) {\n\t\t\tof_node_put(ep_node);\n\t\t\treturn ret;\n\t\t}\n\n\t\t \n\t\tfor (i = 0; i < RCAR_DU_OUTPUT_MAX; ++i) {\n\t\t\tif (rcdu->info->routes[i].possible_crtcs &&\n\t\t\t    rcdu->info->routes[i].port == ep.port) {\n\t\t\t\toutput = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (i == RCAR_DU_OUTPUT_MAX) {\n\t\t\tdev_warn(rcdu->dev,\n\t\t\t\t \"port %u references unexisting output, skipping\\n\",\n\t\t\t\t ep.port);\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\tret = rcar_du_encoders_init_one(rcdu, output, &ep);\n\t\tif (ret < 0) {\n\t\t\tif (ret == -EPROBE_DEFER) {\n\t\t\t\tof_node_put(ep_node);\n\t\t\t\treturn ret;\n\t\t\t}\n\n\t\t\tcontinue;\n\t\t}\n\n\t\tnum_encoders++;\n\t}\n\n\treturn num_encoders;\n}\n\nstatic int rcar_du_properties_init(struct rcar_du_device *rcdu)\n{\n\t \n\trcdu->props.colorkey =\n\t\tdrm_property_create_range(&rcdu->ddev, 0, \"colorkey\",\n\t\t\t\t\t  0, 0x01ffffff);\n\tif (rcdu->props.colorkey == NULL)\n\t\treturn -ENOMEM;\n\n\treturn 0;\n}\n\nstatic int rcar_du_vsps_init(struct rcar_du_device *rcdu)\n{\n\tconst struct device_node *np = rcdu->dev->of_node;\n\tconst char *vsps_prop_name = \"renesas,vsps\";\n\tstruct of_phandle_args args;\n\tstruct {\n\t\tstruct device_node *np;\n\t\tunsigned int crtcs_mask;\n\t} vsps[RCAR_DU_MAX_VSPS] = { { NULL, }, };\n\tunsigned int vsps_count = 0;\n\tunsigned int cells;\n\tunsigned int i;\n\tint ret;\n\n\t \n\tret = of_property_count_u32_elems(np, vsps_prop_name);\n\tif (ret < 0) {\n\t\t \n\t\tvsps_prop_name = \"vsps\";\n\t\tret = of_property_count_u32_elems(np, vsps_prop_name);\n\t}\n\tcells = ret / rcdu->num_crtcs - 1;\n\tif (cells > 1)\n\t\treturn -EINVAL;\n\n\tfor (i = 0; i < rcdu->num_crtcs; ++i) {\n\t\tunsigned int j;\n\n\t\tret = of_parse_phandle_with_fixed_args(np, vsps_prop_name,\n\t\t\t\t\t\t       cells, i, &args);\n\t\tif (ret < 0)\n\t\t\tgoto error;\n\n\t\t \n\t\tfor (j = 0; j < vsps_count; ++j) {\n\t\t\tif (vsps[j].np == args.np)\n\t\t\t\tbreak;\n\t\t}\n\n\t\tif (j < vsps_count)\n\t\t\tof_node_put(args.np);\n\t\telse\n\t\t\tvsps[vsps_count++].np = args.np;\n\n\t\tvsps[j].crtcs_mask |= BIT(i);\n\n\t\t \n\t\trcdu->crtcs[i].vsp = &rcdu->vsps[j];\n\t\trcdu->crtcs[i].vsp_pipe = cells >= 1 ? args.args[0] : 0;\n\t}\n\n\t \n\tfor (i = 0; i < vsps_count; ++i) {\n\t\tstruct rcar_du_vsp *vsp = &rcdu->vsps[i];\n\n\t\tvsp->index = i;\n\t\tvsp->dev = rcdu;\n\n\t\tret = rcar_du_vsp_init(vsp, vsps[i].np, vsps[i].crtcs_mask);\n\t\tif (ret < 0)\n\t\t\tgoto error;\n\t}\n\n\treturn 0;\n\nerror:\n\tfor (i = 0; i < ARRAY_SIZE(vsps); ++i)\n\t\tof_node_put(vsps[i].np);\n\n\treturn ret;\n}\n\nstatic int rcar_du_cmm_init(struct rcar_du_device *rcdu)\n{\n\tconst struct device_node *np = rcdu->dev->of_node;\n\tunsigned int i;\n\tint cells;\n\n\tcells = of_property_count_u32_elems(np, \"renesas,cmms\");\n\tif (cells == -EINVAL)\n\t\treturn 0;\n\n\tif (cells > rcdu->num_crtcs) {\n\t\tdev_err(rcdu->dev,\n\t\t\t\"Invalid number of entries in 'renesas,cmms'\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tfor (i = 0; i < cells; ++i) {\n\t\tstruct platform_device *pdev;\n\t\tstruct device_link *link;\n\t\tstruct device_node *cmm;\n\t\tint ret;\n\n\t\tcmm = of_parse_phandle(np, \"renesas,cmms\", i);\n\t\tif (!cmm) {\n\t\t\tdev_err(rcdu->dev,\n\t\t\t\t\"Failed to parse 'renesas,cmms' property\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (!of_device_is_available(cmm)) {\n\t\t\t \n\t\t\tof_node_put(cmm);\n\t\t\tcontinue;\n\t\t}\n\n\t\tpdev = of_find_device_by_node(cmm);\n\t\tif (!pdev) {\n\t\t\tdev_err(rcdu->dev, \"No device found for CMM%u\\n\", i);\n\t\t\tof_node_put(cmm);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tof_node_put(cmm);\n\n\t\t \n\t\tret = rcar_cmm_init(pdev);\n\t\tif (ret) {\n\t\t\tplatform_device_put(pdev);\n\t\t\treturn ret == -ENODEV ? 0 : ret;\n\t\t}\n\n\t\trcdu->cmms[i] = pdev;\n\n\t\t \n\t\tlink = device_link_add(rcdu->dev, &pdev->dev, DL_FLAG_STATELESS);\n\t\tif (!link) {\n\t\t\tdev_err(rcdu->dev,\n\t\t\t\t\"Failed to create device link to CMM%u\\n\", i);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic void rcar_du_modeset_cleanup(struct drm_device *dev, void *res)\n{\n\tstruct rcar_du_device *rcdu = to_rcar_du_device(dev);\n\tunsigned int i;\n\n\tfor (i = 0; i < ARRAY_SIZE(rcdu->cmms); ++i)\n\t\tplatform_device_put(rcdu->cmms[i]);\n}\n\nint rcar_du_modeset_init(struct rcar_du_device *rcdu)\n{\n\tstatic const unsigned int mmio_offsets[] = {\n\t\tDU0_REG_OFFSET, DU2_REG_OFFSET\n\t};\n\n\tstruct drm_device *dev = &rcdu->ddev;\n\tstruct drm_encoder *encoder;\n\tunsigned int dpad0_sources;\n\tunsigned int num_encoders;\n\tunsigned int num_groups;\n\tunsigned int swindex;\n\tunsigned int hwindex;\n\tunsigned int i;\n\tint ret;\n\n\tret = drmm_mode_config_init(dev);\n\tif (ret)\n\t\treturn ret;\n\n\tret = drmm_add_action(&rcdu->ddev, rcar_du_modeset_cleanup, NULL);\n\tif (ret)\n\t\treturn ret;\n\n\tdev->mode_config.min_width = 0;\n\tdev->mode_config.min_height = 0;\n\tdev->mode_config.normalize_zpos = true;\n\tdev->mode_config.funcs = &rcar_du_mode_config_funcs;\n\tdev->mode_config.helper_private = &rcar_du_mode_config_helper;\n\n\tif (rcdu->info->gen < 3) {\n\t\tdev->mode_config.max_width = 4095;\n\t\tdev->mode_config.max_height = 2047;\n\t} else {\n\t\t \n\t\tdev->mode_config.max_width = 8190;\n\t\tdev->mode_config.max_height = 8190;\n\t}\n\n\trcdu->num_crtcs = hweight8(rcdu->info->channels_mask);\n\n\tret = rcar_du_properties_init(rcdu);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tret = drm_vblank_init(dev, rcdu->num_crtcs);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tnum_groups = DIV_ROUND_UP(rcdu->num_crtcs, 2);\n\n\tfor (i = 0; i < num_groups; ++i) {\n\t\tstruct rcar_du_group *rgrp = &rcdu->groups[i];\n\n\t\tmutex_init(&rgrp->lock);\n\n\t\trgrp->dev = rcdu;\n\t\trgrp->mmio_offset = mmio_offsets[i];\n\t\trgrp->index = i;\n\t\t \n\t\trgrp->channels_mask = (rcdu->info->channels_mask >> (2 * i))\n\t\t\t\t   & GENMASK(1, 0);\n\t\trgrp->num_crtcs = hweight8(rgrp->channels_mask);\n\n\t\t \n\t\trgrp->dptsr_planes = rgrp->num_crtcs > 1\n\t\t\t\t   ? (rcdu->info->gen >= 3 ? 0x04 : 0xf0)\n\t\t\t\t   : 0;\n\n\t\tif (!rcar_du_has(rcdu, RCAR_DU_FEATURE_VSP1_SOURCE)) {\n\t\t\tret = rcar_du_planes_init(rgrp);\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\t\t}\n\t}\n\n\t \n\tif (rcar_du_has(rcdu, RCAR_DU_FEATURE_VSP1_SOURCE)) {\n\t\tret = rcar_du_vsps_init(rcdu);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\t \n\tret = rcar_du_cmm_init(rcdu);\n\tif (ret)\n\t\treturn dev_err_probe(rcdu->dev, ret,\n\t\t\t\t     \"failed to initialize CMM\\n\");\n\n\t \n\tfor (swindex = 0, hwindex = 0; swindex < rcdu->num_crtcs; ++hwindex) {\n\t\tstruct rcar_du_group *rgrp;\n\n\t\t \n\t\tif (!(rcdu->info->channels_mask & BIT(hwindex)))\n\t\t\tcontinue;\n\n\t\trgrp = &rcdu->groups[hwindex / 2];\n\n\t\tret = rcar_du_crtc_create(rgrp, swindex++, hwindex);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\t \n\tret = rcar_du_encoders_init(rcdu);\n\tif (ret < 0)\n\t\treturn dev_err_probe(rcdu->dev, ret,\n\t\t\t\t     \"failed to initialize encoders\\n\");\n\n\tif (ret == 0) {\n\t\tdev_err(rcdu->dev, \"error: no encoder could be initialized\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tnum_encoders = ret;\n\n\t \n\tlist_for_each_entry(encoder, &dev->mode_config.encoder_list, head) {\n\t\tstruct rcar_du_encoder *renc = to_rcar_encoder(encoder);\n\t\tconst struct rcar_du_output_routing *route =\n\t\t\t&rcdu->info->routes[renc->output];\n\n\t\tencoder->possible_crtcs = route->possible_crtcs;\n\t\tencoder->possible_clones = (1 << num_encoders) - 1;\n\t}\n\n\t \n\tif (rcdu->info->gen >= 3) {\n\t\tfor (i = 0; i < rcdu->num_crtcs; ++i) {\n\t\t\tstruct rcar_du_crtc *rcrtc = &rcdu->crtcs[i];\n\n\t\t\tret = rcar_du_writeback_init(rcdu, rcrtc);\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\t\t}\n\t}\n\n\t \n\tdpad0_sources = rcdu->info->routes[RCAR_DU_OUTPUT_DPAD0].possible_crtcs;\n\trcdu->dpad0_source = ffs(dpad0_sources) - 1;\n\n\tdrm_mode_config_reset(dev);\n\n\tdrm_kms_helper_poll_init(dev);\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}