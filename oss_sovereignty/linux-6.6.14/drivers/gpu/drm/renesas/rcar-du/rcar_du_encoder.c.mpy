{
  "module_name": "rcar_du_encoder.c",
  "hash_id": "edd1973515280061ef161737e7ab3570701193679bad49375360c3838bc2df70",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/renesas/rcar-du/rcar_du_encoder.c",
  "human_readable_source": "\n \n\n#include <linux/export.h>\n#include <linux/of.h>\n\n#include <drm/drm_bridge.h>\n#include <drm/drm_bridge_connector.h>\n#include <drm/drm_panel.h>\n\n#include \"rcar_du_drv.h\"\n#include \"rcar_du_encoder.h\"\n#include \"rcar_lvds.h\"\n\n \n\nstatic unsigned int rcar_du_encoder_count_ports(struct device_node *node)\n{\n\tstruct device_node *ports;\n\tstruct device_node *port;\n\tunsigned int num_ports = 0;\n\n\tports = of_get_child_by_name(node, \"ports\");\n\tif (!ports)\n\t\tports = of_node_get(node);\n\n\tfor_each_child_of_node(ports, port) {\n\t\tif (of_node_name_eq(port, \"port\"))\n\t\t\tnum_ports++;\n\t}\n\n\tof_node_put(ports);\n\n\treturn num_ports;\n}\n\nstatic const struct drm_encoder_funcs rcar_du_encoder_funcs = {\n};\n\nint rcar_du_encoder_init(struct rcar_du_device *rcdu,\n\t\t\t enum rcar_du_output output,\n\t\t\t struct device_node *enc_node)\n{\n\tstruct rcar_du_encoder *renc;\n\tstruct drm_connector *connector;\n\tstruct drm_bridge *bridge;\n\tint ret;\n\n\t \n\tif ((output == RCAR_DU_OUTPUT_DPAD0 ||\n\t     output == RCAR_DU_OUTPUT_DPAD1) &&\n\t    rcar_du_encoder_count_ports(enc_node) == 1) {\n\t\tstruct drm_panel *panel = of_drm_find_panel(enc_node);\n\n\t\tif (IS_ERR(panel))\n\t\t\treturn PTR_ERR(panel);\n\n\t\tbridge = devm_drm_panel_bridge_add_typed(rcdu->dev, panel,\n\t\t\t\t\t\t\t DRM_MODE_CONNECTOR_DPI);\n\t\tif (IS_ERR(bridge))\n\t\t\treturn PTR_ERR(bridge);\n\t} else {\n\t\tbridge = of_drm_find_bridge(enc_node);\n\t\tif (!bridge)\n\t\t\treturn -EPROBE_DEFER;\n\n\t\tif (output == RCAR_DU_OUTPUT_LVDS0 ||\n\t\t    output == RCAR_DU_OUTPUT_LVDS1)\n\t\t\trcdu->lvds[output - RCAR_DU_OUTPUT_LVDS0] = bridge;\n\n\t\tif (output == RCAR_DU_OUTPUT_DSI0 ||\n\t\t    output == RCAR_DU_OUTPUT_DSI1)\n\t\t\trcdu->dsi[output - RCAR_DU_OUTPUT_DSI0] = bridge;\n\t}\n\n\t \n\tif (rcdu->info->gen >= 3) {\n\t\tif (output == RCAR_DU_OUTPUT_LVDS1 &&\n\t\t    rcar_lvds_dual_link(bridge))\n\t\t\treturn -ENOLINK;\n\n\t\tif ((output == RCAR_DU_OUTPUT_LVDS0 ||\n\t\t     output == RCAR_DU_OUTPUT_LVDS1) &&\n\t\t    !rcar_lvds_is_connected(bridge))\n\t\t\treturn -ENOLINK;\n\t}\n\n\tdev_dbg(rcdu->dev, \"initializing encoder %pOF for output %s\\n\",\n\t\tenc_node, rcar_du_output_name(output));\n\n\trenc = drmm_encoder_alloc(&rcdu->ddev, struct rcar_du_encoder, base,\n\t\t\t\t  &rcar_du_encoder_funcs, DRM_MODE_ENCODER_NONE,\n\t\t\t\t  NULL);\n\tif (IS_ERR(renc))\n\t\treturn PTR_ERR(renc);\n\n\trenc->output = output;\n\n\t \n\tret = drm_bridge_attach(&renc->base, bridge, NULL,\n\t\t\t\tDRM_BRIDGE_ATTACH_NO_CONNECTOR);\n\tif (ret) {\n\t\tdev_err(rcdu->dev,\n\t\t\t\"failed to attach bridge %pOF for output %s (%d)\\n\",\n\t\t\tbridge->of_node, rcar_du_output_name(output), ret);\n\t\treturn ret;\n\t}\n\n\t \n\tconnector = drm_bridge_connector_init(&rcdu->ddev, &renc->base);\n\tif (IS_ERR(connector)) {\n\t\tdev_err(rcdu->dev,\n\t\t\t\"failed to created connector for output %s (%ld)\\n\",\n\t\t\trcar_du_output_name(output), PTR_ERR(connector));\n\t\treturn PTR_ERR(connector);\n\t}\n\n\treturn drm_connector_attach_encoder(connector, &renc->base);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}