{
  "module_name": "rcar_du_group.c",
  "hash_id": "e0c30e56d92814e7845b91d653e1cc8157dad1c128e3f2c88041e3706b95e014",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/renesas/rcar-du/rcar_du_group.c",
  "human_readable_source": "\n \n\n \n\n#include <linux/clk.h>\n#include <linux/io.h>\n\n#include \"rcar_du_drv.h\"\n#include \"rcar_du_group.h\"\n#include \"rcar_du_regs.h\"\n\nu32 rcar_du_group_read(struct rcar_du_group *rgrp, u32 reg)\n{\n\treturn rcar_du_read(rgrp->dev, rgrp->mmio_offset + reg);\n}\n\nvoid rcar_du_group_write(struct rcar_du_group *rgrp, u32 reg, u32 data)\n{\n\trcar_du_write(rgrp->dev, rgrp->mmio_offset + reg, data);\n}\n\nstatic void rcar_du_group_setup_pins(struct rcar_du_group *rgrp)\n{\n\tu32 defr6 = DEFR6_CODE;\n\n\tif (rgrp->channels_mask & BIT(0))\n\t\tdefr6 |= DEFR6_ODPM02_DISP;\n\n\tif (rgrp->channels_mask & BIT(1))\n\t\tdefr6 |= DEFR6_ODPM12_DISP;\n\n\trcar_du_group_write(rgrp, DEFR6, defr6);\n}\n\nstatic void rcar_du_group_setup_defr8(struct rcar_du_group *rgrp)\n{\n\tstruct rcar_du_device *rcdu = rgrp->dev;\n\tu32 defr8 = DEFR8_CODE;\n\n\tif (rcdu->info->gen < 3) {\n\t\tdefr8 |= DEFR8_DEFE8;\n\n\t\t \n\t\tif (rgrp->index == 0) {\n\t\t\tdefr8 |= DEFR8_DRGBS_DU(rcdu->dpad0_source);\n\t\t\tif (rgrp->dev->vspd1_sink == 2)\n\t\t\t\tdefr8 |= DEFR8_VSCS;\n\t\t}\n\t} else {\n\t\t \n\t\tif (rgrp->index == rcdu->dpad0_source / 2)\n\t\t\tdefr8 |= DEFR8_DRGBS_DU(rcdu->dpad0_source);\n\t}\n\n\trcar_du_group_write(rgrp, DEFR8, defr8);\n}\n\nstatic void rcar_du_group_setup_didsr(struct rcar_du_group *rgrp)\n{\n\tstruct rcar_du_device *rcdu = rgrp->dev;\n\tstruct rcar_du_crtc *rcrtc;\n\tunsigned int num_crtcs = 0;\n\tunsigned int i;\n\tu32 didsr;\n\n\t \n\tif (rcdu->info->gen < 3 && rgrp->index == 0) {\n\t\t \n\t\trcrtc = rcdu->crtcs;\n\t\tnum_crtcs = rcdu->num_crtcs;\n\t} else if (rcdu->info->gen >= 3 && rgrp->num_crtcs > 1) {\n\t\t \n\t\trcrtc = &rcdu->crtcs[rgrp->index * 2];\n\t\tnum_crtcs = rgrp->num_crtcs;\n\t}\n\n\tif (!num_crtcs)\n\t\treturn;\n\n\tdidsr = DIDSR_CODE;\n\tfor (i = 0; i < num_crtcs; ++i, ++rcrtc) {\n\t\tif (rcdu->info->lvds_clk_mask & BIT(rcrtc->index))\n\t\t\tdidsr |= DIDSR_LDCS_LVDS0(i)\n\t\t\t      |  DIDSR_PDCS_CLK(i, 0);\n\t\telse if (rcdu->info->dsi_clk_mask & BIT(rcrtc->index))\n\t\t\tdidsr |= DIDSR_LDCS_DSI(i);\n\t\telse\n\t\t\tdidsr |= DIDSR_LDCS_DCLKIN(i)\n\t\t\t      |  DIDSR_PDCS_CLK(i, 0);\n\t}\n\n\trcar_du_group_write(rgrp, DIDSR, didsr);\n}\n\nstatic void rcar_du_group_setup(struct rcar_du_group *rgrp)\n{\n\tstruct rcar_du_device *rcdu = rgrp->dev;\n\tu32 defr7 = DEFR7_CODE;\n\tu32 dorcr;\n\n\t \n\trcar_du_group_write(rgrp, DEFR, DEFR_CODE | DEFR_DEFE);\n\tif (rcdu->info->gen < 3) {\n\t\trcar_du_group_write(rgrp, DEFR2, DEFR2_CODE | DEFR2_DEFE2G);\n\t\trcar_du_group_write(rgrp, DEFR3, DEFR3_CODE | DEFR3_DEFE3);\n\t\trcar_du_group_write(rgrp, DEFR4, DEFR4_CODE);\n\t}\n\trcar_du_group_write(rgrp, DEFR5, DEFR5_CODE | DEFR5_DEFE5);\n\n\tif (rcdu->info->gen < 4)\n\t\trcar_du_group_setup_pins(rgrp);\n\n\tif (rcdu->info->gen < 4) {\n\t\t \n\t\tdefr7 |= (rgrp->cmms_mask & BIT(1) ? DEFR7_CMME1 : 0) |\n\t\t\t (rgrp->cmms_mask & BIT(0) ? DEFR7_CMME0 : 0);\n\t\trcar_du_group_write(rgrp, DEFR7, defr7);\n\t}\n\n\tif (rcdu->info->gen >= 2) {\n\t\tif (rcdu->info->gen < 4)\n\t\t\trcar_du_group_setup_defr8(rgrp);\n\t\trcar_du_group_setup_didsr(rgrp);\n\t}\n\n\tif (rcdu->info->gen >= 3)\n\t\trcar_du_group_write(rgrp, DEFR10, DEFR10_CODE | DEFR10_DEFE10);\n\n\t \n\tdorcr = DORCR_PG0D_DS0 | DORCR_DPRS;\n\tif (rcdu->info->gen >= 3 && rgrp->num_crtcs == 1)\n\t\tdorcr |= DORCR_PG1T | DORCR_DK1S | DORCR_PG1D_DS1;\n\trcar_du_group_write(rgrp, DORCR, dorcr);\n\n\t \n\tmutex_lock(&rgrp->lock);\n\trcar_du_group_write(rgrp, DPTSR, (rgrp->dptsr_planes << 16) |\n\t\t\t    rgrp->dptsr_planes);\n\tmutex_unlock(&rgrp->lock);\n}\n\n \nint rcar_du_group_get(struct rcar_du_group *rgrp)\n{\n\tif (rgrp->use_count)\n\t\tgoto done;\n\n\trcar_du_group_setup(rgrp);\n\ndone:\n\trgrp->use_count++;\n\treturn 0;\n}\n\n \nvoid rcar_du_group_put(struct rcar_du_group *rgrp)\n{\n\t--rgrp->use_count;\n}\n\nstatic void __rcar_du_group_start_stop(struct rcar_du_group *rgrp, bool start)\n{\n\tstruct rcar_du_device *rcdu = rgrp->dev;\n\n\t \n\tif (rcdu->info->channels_mask & BIT(rgrp->index * 2)) {\n\t\tstruct rcar_du_crtc *rcrtc = &rgrp->dev->crtcs[rgrp->index * 2];\n\n\t\trcar_du_crtc_dsysr_clr_set(rcrtc, DSYSR_DRES | DSYSR_DEN,\n\t\t\t\t\t   start ? DSYSR_DEN : DSYSR_DRES);\n\t} else {\n\t\trcar_du_group_write(rgrp, DSYSR,\n\t\t\t\t    start ? DSYSR_DEN : DSYSR_DRES);\n\t}\n}\n\nvoid rcar_du_group_start_stop(struct rcar_du_group *rgrp, bool start)\n{\n\t \n\tif (start) {\n\t\tif (rgrp->used_crtcs++ != 0)\n\t\t\t__rcar_du_group_start_stop(rgrp, false);\n\t\t__rcar_du_group_start_stop(rgrp, true);\n\t} else {\n\t\tif (--rgrp->used_crtcs == 0)\n\t\t\t__rcar_du_group_start_stop(rgrp, false);\n\t}\n}\n\nvoid rcar_du_group_restart(struct rcar_du_group *rgrp)\n{\n\trgrp->need_restart = false;\n\n\t__rcar_du_group_start_stop(rgrp, false);\n\t__rcar_du_group_start_stop(rgrp, true);\n}\n\nint rcar_du_set_dpad0_vsp1_routing(struct rcar_du_device *rcdu)\n{\n\tstruct rcar_du_group *rgrp;\n\tstruct rcar_du_crtc *crtc;\n\tunsigned int index;\n\tint ret;\n\n\tif (rcdu->info->gen < 2)\n\t\treturn 0;\n\n\t \n\tindex = rcdu->info->gen < 3 ? 0 : DIV_ROUND_UP(rcdu->num_crtcs, 2) - 1;\n\trgrp = &rcdu->groups[index];\n\tcrtc = &rcdu->crtcs[index * 2];\n\n\tret = clk_prepare_enable(crtc->clock);\n\tif (ret < 0)\n\t\treturn ret;\n\n\trcar_du_group_setup_defr8(rgrp);\n\n\tclk_disable_unprepare(crtc->clock);\n\n\treturn 0;\n}\n\nstatic void rcar_du_group_set_dpad_levels(struct rcar_du_group *rgrp)\n{\n\tstatic const u32 doflr_values[2] = {\n\t\tDOFLR_HSYCFL0 | DOFLR_VSYCFL0 | DOFLR_ODDFL0 |\n\t\tDOFLR_DISPFL0 | DOFLR_CDEFL0  | DOFLR_RGBFL0,\n\t\tDOFLR_HSYCFL1 | DOFLR_VSYCFL1 | DOFLR_ODDFL1 |\n\t\tDOFLR_DISPFL1 | DOFLR_CDEFL1  | DOFLR_RGBFL1,\n\t};\n\tstatic const u32 dpad_mask = BIT(RCAR_DU_OUTPUT_DPAD1)\n\t\t\t\t   | BIT(RCAR_DU_OUTPUT_DPAD0);\n\tstruct rcar_du_device *rcdu = rgrp->dev;\n\tu32 doflr = DOFLR_CODE;\n\tunsigned int i;\n\n\tif (rcdu->info->gen < 2)\n\t\treturn;\n\n\t \n\n\tfor (i = 0; i < rgrp->num_crtcs; ++i) {\n\t\tstruct rcar_du_crtc_state *rstate;\n\t\tstruct rcar_du_crtc *rcrtc;\n\n\t\trcrtc = &rcdu->crtcs[rgrp->index * 2 + i];\n\t\trstate = to_rcar_crtc_state(rcrtc->crtc.state);\n\n\t\tif (!(rstate->outputs & dpad_mask))\n\t\t\tdoflr |= doflr_values[i];\n\t}\n\n\trcar_du_group_write(rgrp, DOFLR, doflr);\n}\n\nint rcar_du_group_set_routing(struct rcar_du_group *rgrp)\n{\n\tstruct rcar_du_device *rcdu = rgrp->dev;\n\tu32 dorcr = rcar_du_group_read(rgrp, DORCR);\n\n\tdorcr &= ~(DORCR_PG1T | DORCR_DK1S | DORCR_PG1D_MASK);\n\n\t \n\tif (rcdu->dpad1_source == rgrp->index * 2)\n\t\tdorcr |= DORCR_PG1D_DS0;\n\telse\n\t\tdorcr |= DORCR_PG1T | DORCR_DK1S | DORCR_PG1D_DS1;\n\n\trcar_du_group_write(rgrp, DORCR, dorcr);\n\n\trcar_du_group_set_dpad_levels(rgrp);\n\n\treturn rcar_du_set_dpad0_vsp1_routing(rgrp->dev);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}