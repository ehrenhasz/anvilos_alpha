{
  "module_name": "rcar_du_crtc.c",
  "hash_id": "2b48a48a9812e65638ed9e379c0f9e17aa83754dbcb307ba9c88de655cb5ae77",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/renesas/rcar-du/rcar_du_crtc.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/mutex.h>\n#include <linux/platform_device.h>\n\n#include <drm/drm_atomic.h>\n#include <drm/drm_atomic_helper.h>\n#include <drm/drm_bridge.h>\n#include <drm/drm_crtc.h>\n#include <drm/drm_device.h>\n#include <drm/drm_gem_dma_helper.h>\n#include <drm/drm_vblank.h>\n\n#include \"rcar_cmm.h\"\n#include \"rcar_du_crtc.h\"\n#include \"rcar_du_drv.h\"\n#include \"rcar_du_encoder.h\"\n#include \"rcar_du_kms.h\"\n#include \"rcar_du_plane.h\"\n#include \"rcar_du_regs.h\"\n#include \"rcar_du_vsp.h\"\n#include \"rcar_lvds.h\"\n#include \"rcar_mipi_dsi.h\"\n\nstatic u32 rcar_du_crtc_read(struct rcar_du_crtc *rcrtc, u32 reg)\n{\n\tstruct rcar_du_device *rcdu = rcrtc->dev;\n\n\treturn rcar_du_read(rcdu, rcrtc->mmio_offset + reg);\n}\n\nstatic void rcar_du_crtc_write(struct rcar_du_crtc *rcrtc, u32 reg, u32 data)\n{\n\tstruct rcar_du_device *rcdu = rcrtc->dev;\n\n\trcar_du_write(rcdu, rcrtc->mmio_offset + reg, data);\n}\n\nstatic void rcar_du_crtc_clr(struct rcar_du_crtc *rcrtc, u32 reg, u32 clr)\n{\n\tstruct rcar_du_device *rcdu = rcrtc->dev;\n\n\trcar_du_write(rcdu, rcrtc->mmio_offset + reg,\n\t\t      rcar_du_read(rcdu, rcrtc->mmio_offset + reg) & ~clr);\n}\n\nstatic void rcar_du_crtc_set(struct rcar_du_crtc *rcrtc, u32 reg, u32 set)\n{\n\tstruct rcar_du_device *rcdu = rcrtc->dev;\n\n\trcar_du_write(rcdu, rcrtc->mmio_offset + reg,\n\t\t      rcar_du_read(rcdu, rcrtc->mmio_offset + reg) | set);\n}\n\nvoid rcar_du_crtc_dsysr_clr_set(struct rcar_du_crtc *rcrtc, u32 clr, u32 set)\n{\n\tstruct rcar_du_device *rcdu = rcrtc->dev;\n\n\trcrtc->dsysr = (rcrtc->dsysr & ~clr) | set;\n\trcar_du_write(rcdu, rcrtc->mmio_offset + DSYSR, rcrtc->dsysr);\n}\n\n \n\nstruct dpll_info {\n\tunsigned int output;\n\tunsigned int fdpll;\n\tunsigned int n;\n\tunsigned int m;\n};\n\nstatic void rcar_du_dpll_divider(struct rcar_du_crtc *rcrtc,\n\t\t\t\t struct dpll_info *dpll,\n\t\t\t\t unsigned long input,\n\t\t\t\t unsigned long target)\n{\n\tunsigned long best_diff = (unsigned long)-1;\n\tunsigned long diff;\n\tunsigned int fdpll;\n\tunsigned int m;\n\tunsigned int n;\n\n\t \n\tfor (m = 0; m < 4; m++) {\n\t\tfor (n = 119; n > 38; n--) {\n\t\t\t \n\t\t\tunsigned long fout = input * (n + 1) / (m + 1);\n\n\t\t\tif (fout < 1000 || fout > 2048 * 1000 * 1000U)\n\t\t\t\tcontinue;\n\n\t\t\tfor (fdpll = 1; fdpll < 32; fdpll++) {\n\t\t\t\tunsigned long output;\n\n\t\t\t\toutput = fout / (fdpll + 1);\n\t\t\t\tif (output >= 400 * 1000 * 1000)\n\t\t\t\t\tcontinue;\n\n\t\t\t\tdiff = abs((long)output - (long)target);\n\t\t\t\tif (best_diff > diff) {\n\t\t\t\t\tbest_diff = diff;\n\t\t\t\t\tdpll->n = n;\n\t\t\t\t\tdpll->m = m;\n\t\t\t\t\tdpll->fdpll = fdpll;\n\t\t\t\t\tdpll->output = output;\n\t\t\t\t}\n\n\t\t\t\tif (diff == 0)\n\t\t\t\t\tgoto done;\n\t\t\t}\n\t\t}\n\t}\n\ndone:\n\tdev_dbg(rcrtc->dev->dev,\n\t\t\"output:%u, fdpll:%u, n:%u, m:%u, diff:%lu\\n\",\n\t\t dpll->output, dpll->fdpll, dpll->n, dpll->m, best_diff);\n}\n\nstruct du_clk_params {\n\tstruct clk *clk;\n\tunsigned long rate;\n\tunsigned long diff;\n\tu32 escr;\n};\n\nstatic void rcar_du_escr_divider(struct clk *clk, unsigned long target,\n\t\t\t\t u32 escr, struct du_clk_params *params)\n{\n\tunsigned long rate;\n\tunsigned long diff;\n\tu32 div;\n\n\t \n\tif (params->diff == 0)\n\t\treturn;\n\n\t \n\trate = clk_round_rate(clk, target);\n\tdiv = clamp(DIV_ROUND_CLOSEST(rate, target), 1UL, 64UL) - 1;\n\tdiff = abs(rate / (div + 1) - target);\n\n\t \n\tif (diff < params->diff) {\n\t\tparams->clk = clk;\n\t\tparams->rate = rate;\n\t\tparams->diff = diff;\n\t\tparams->escr = escr | div;\n\t}\n}\n\nstatic void rcar_du_crtc_set_display_timing(struct rcar_du_crtc *rcrtc)\n{\n\tconst struct drm_display_mode *mode = &rcrtc->crtc.state->adjusted_mode;\n\tstruct rcar_du_device *rcdu = rcrtc->dev;\n\tunsigned long mode_clock = mode->clock * 1000;\n\tunsigned int hdse_offset;\n\tu32 dsmr;\n\tu32 escr;\n\n\tif (rcdu->info->dpll_mask & (1 << rcrtc->index)) {\n\t\tunsigned long target = mode_clock;\n\t\tstruct dpll_info dpll = { 0 };\n\t\tunsigned long extclk;\n\t\tu32 dpllcr;\n\t\tu32 div = 0;\n\n\t\t \n\t\textclk = clk_get_rate(rcrtc->extclock);\n\t\trcar_du_dpll_divider(rcrtc, &dpll, extclk, target);\n\n\t\tdpllcr = DPLLCR_CODE | DPLLCR_CLKE\n\t\t       | DPLLCR_FDPLL(dpll.fdpll)\n\t\t       | DPLLCR_N(dpll.n) | DPLLCR_M(dpll.m)\n\t\t       | DPLLCR_STBY;\n\n\t\tif (rcrtc->index == 1)\n\t\t\tdpllcr |= DPLLCR_PLCS1\n\t\t\t       |  DPLLCR_INCS_DOTCLKIN1;\n\t\telse\n\t\t\tdpllcr |= DPLLCR_PLCS0\n\t\t\t       |  DPLLCR_INCS_DOTCLKIN0;\n\n\t\trcar_du_group_write(rcrtc->group, DPLLCR, dpllcr);\n\n\t\tescr = ESCR_DCLKSEL_DCLKIN | div;\n\t} else if (rcdu->info->lvds_clk_mask & BIT(rcrtc->index) ||\n\t\t   rcdu->info->dsi_clk_mask & BIT(rcrtc->index)) {\n\t\t \n\t\tescr = ESCR_DCLKSEL_DCLKIN;\n\t} else {\n\t\tstruct du_clk_params params = { .diff = (unsigned long)-1 };\n\n\t\trcar_du_escr_divider(rcrtc->clock, mode_clock,\n\t\t\t\t     ESCR_DCLKSEL_CLKS, &params);\n\t\tif (rcrtc->extclock)\n\t\t\trcar_du_escr_divider(rcrtc->extclock, mode_clock,\n\t\t\t\t\t     ESCR_DCLKSEL_DCLKIN, &params);\n\n\t\tdev_dbg(rcrtc->dev->dev, \"mode clock %lu %s rate %lu\\n\",\n\t\t\tmode_clock, params.clk == rcrtc->clock ? \"cpg\" : \"ext\",\n\t\t\tparams.rate);\n\n\t\tclk_set_rate(params.clk, params.rate);\n\t\tescr = params.escr;\n\t}\n\n\t \n\tif ((rcdu->info->routes[RCAR_DU_OUTPUT_DPAD0].possible_crtcs |\n\t     rcdu->info->routes[RCAR_DU_OUTPUT_DPAD1].possible_crtcs |\n\t     rcdu->info->routes[RCAR_DU_OUTPUT_LVDS0].possible_crtcs |\n\t     rcdu->info->routes[RCAR_DU_OUTPUT_LVDS1].possible_crtcs) &\n\t    BIT(rcrtc->index)) {\n\t\tdev_dbg(rcrtc->dev->dev, \"%s: ESCR 0x%08x\\n\", __func__, escr);\n\n\t\trcar_du_crtc_write(rcrtc, rcrtc->index % 2 ? ESCR13 : ESCR02, escr);\n\t}\n\n\tif ((rcdu->info->routes[RCAR_DU_OUTPUT_DPAD0].possible_crtcs |\n\t     rcdu->info->routes[RCAR_DU_OUTPUT_DPAD1].possible_crtcs) &\n\t    BIT(rcrtc->index))\n\t\trcar_du_crtc_write(rcrtc, rcrtc->index % 2 ? OTAR13 : OTAR02, 0);\n\n\t \n\tdsmr = ((mode->flags & DRM_MODE_FLAG_PVSYNC) ? DSMR_VSL : 0)\n\t     | ((mode->flags & DRM_MODE_FLAG_PHSYNC) ? DSMR_HSL : 0)\n\t     | ((mode->flags & DRM_MODE_FLAG_INTERLACE) ? DSMR_ODEV : 0)\n\t     | DSMR_DIPM_DISP | DSMR_CSPM;\n\trcar_du_crtc_write(rcrtc, DSMR, dsmr);\n\n\t \n\thdse_offset = 19;\n\tif (rcrtc->group->cmms_mask & BIT(rcrtc->index % 2))\n\t\thdse_offset += 25;\n\n\t \n\trcar_du_crtc_write(rcrtc, HDSR, mode->htotal - mode->hsync_start -\n\t\t\t\t\thdse_offset);\n\trcar_du_crtc_write(rcrtc, HDER, mode->htotal - mode->hsync_start +\n\t\t\t\t\tmode->hdisplay - hdse_offset);\n\trcar_du_crtc_write(rcrtc, HSWR, mode->hsync_end -\n\t\t\t\t\tmode->hsync_start - 1);\n\trcar_du_crtc_write(rcrtc, HCR,  mode->htotal - 1);\n\n\trcar_du_crtc_write(rcrtc, VDSR, mode->crtc_vtotal -\n\t\t\t\t\tmode->crtc_vsync_end - 2);\n\trcar_du_crtc_write(rcrtc, VDER, mode->crtc_vtotal -\n\t\t\t\t\tmode->crtc_vsync_end +\n\t\t\t\t\tmode->crtc_vdisplay - 2);\n\trcar_du_crtc_write(rcrtc, VSPR, mode->crtc_vtotal -\n\t\t\t\t\tmode->crtc_vsync_end +\n\t\t\t\t\tmode->crtc_vsync_start - 1);\n\trcar_du_crtc_write(rcrtc, VCR,  mode->crtc_vtotal - 1);\n\n\trcar_du_crtc_write(rcrtc, DESR,  mode->htotal - mode->hsync_start - 1);\n\trcar_du_crtc_write(rcrtc, DEWR,  mode->hdisplay);\n}\n\nstatic unsigned int plane_zpos(struct rcar_du_plane *plane)\n{\n\treturn plane->plane.state->normalized_zpos;\n}\n\nstatic const struct rcar_du_format_info *\nplane_format(struct rcar_du_plane *plane)\n{\n\treturn to_rcar_plane_state(plane->plane.state)->format;\n}\n\nstatic void rcar_du_crtc_update_planes(struct rcar_du_crtc *rcrtc)\n{\n\tstruct rcar_du_plane *planes[RCAR_DU_NUM_HW_PLANES];\n\tstruct rcar_du_device *rcdu = rcrtc->dev;\n\tunsigned int num_planes = 0;\n\tunsigned int dptsr_planes;\n\tunsigned int hwplanes = 0;\n\tunsigned int prio = 0;\n\tunsigned int i;\n\tu32 dspr = 0;\n\n\tfor (i = 0; i < rcrtc->group->num_planes; ++i) {\n\t\tstruct rcar_du_plane *plane = &rcrtc->group->planes[i];\n\t\tunsigned int j;\n\n\t\tif (plane->plane.state->crtc != &rcrtc->crtc ||\n\t\t    !plane->plane.state->visible)\n\t\t\tcontinue;\n\n\t\t \n\t\tfor (j = num_planes++; j > 0; --j) {\n\t\t\tif (plane_zpos(planes[j-1]) <= plane_zpos(plane))\n\t\t\t\tbreak;\n\t\t\tplanes[j] = planes[j-1];\n\t\t}\n\n\t\tplanes[j] = plane;\n\t\tprio += plane_format(plane)->planes * 4;\n\t}\n\n\tfor (i = 0; i < num_planes; ++i) {\n\t\tstruct rcar_du_plane *plane = planes[i];\n\t\tstruct drm_plane_state *state = plane->plane.state;\n\t\tunsigned int index = to_rcar_plane_state(state)->hwindex;\n\n\t\tprio -= 4;\n\t\tdspr |= (index + 1) << prio;\n\t\thwplanes |= 1 << index;\n\n\t\tif (plane_format(plane)->planes == 2) {\n\t\t\tindex = (index + 1) % 8;\n\n\t\t\tprio -= 4;\n\t\t\tdspr |= (index + 1) << prio;\n\t\t\thwplanes |= 1 << index;\n\t\t}\n\t}\n\n\t \n\tif (rcar_du_has(rcdu, RCAR_DU_FEATURE_VSP1_SOURCE)) {\n\t\tif (rcdu->info->gen < 3) {\n\t\t\tdspr = (rcrtc->index % 2) + 1;\n\t\t\thwplanes = 1 << (rcrtc->index % 2);\n\t\t} else {\n\t\t\tdspr = (rcrtc->index % 2) ? 3 : 1;\n\t\t\thwplanes = 1 << ((rcrtc->index % 2) ? 2 : 0);\n\t\t}\n\t}\n\n\t \n\tmutex_lock(&rcrtc->group->lock);\n\n\tdptsr_planes = rcrtc->index % 2 ? rcrtc->group->dptsr_planes | hwplanes\n\t\t     : rcrtc->group->dptsr_planes & ~hwplanes;\n\n\tif (dptsr_planes != rcrtc->group->dptsr_planes) {\n\t\trcar_du_group_write(rcrtc->group, DPTSR,\n\t\t\t\t    (dptsr_planes << 16) | dptsr_planes);\n\t\trcrtc->group->dptsr_planes = dptsr_planes;\n\n\t\tif (rcrtc->group->used_crtcs)\n\t\t\trcar_du_group_restart(rcrtc->group);\n\t}\n\n\t \n\tif (rcrtc->group->need_restart)\n\t\trcar_du_group_restart(rcrtc->group);\n\n\tmutex_unlock(&rcrtc->group->lock);\n\n\trcar_du_group_write(rcrtc->group, rcrtc->index % 2 ? DS2PR : DS1PR,\n\t\t\t    dspr);\n}\n\n \n\nvoid rcar_du_crtc_finish_page_flip(struct rcar_du_crtc *rcrtc)\n{\n\tstruct drm_pending_vblank_event *event;\n\tstruct drm_device *dev = rcrtc->crtc.dev;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&dev->event_lock, flags);\n\tevent = rcrtc->event;\n\trcrtc->event = NULL;\n\tspin_unlock_irqrestore(&dev->event_lock, flags);\n\n\tif (event == NULL)\n\t\treturn;\n\n\tspin_lock_irqsave(&dev->event_lock, flags);\n\tdrm_crtc_send_vblank_event(&rcrtc->crtc, event);\n\twake_up(&rcrtc->flip_wait);\n\tspin_unlock_irqrestore(&dev->event_lock, flags);\n\n\tdrm_crtc_vblank_put(&rcrtc->crtc);\n}\n\nstatic bool rcar_du_crtc_page_flip_pending(struct rcar_du_crtc *rcrtc)\n{\n\tstruct drm_device *dev = rcrtc->crtc.dev;\n\tunsigned long flags;\n\tbool pending;\n\n\tspin_lock_irqsave(&dev->event_lock, flags);\n\tpending = rcrtc->event != NULL;\n\tspin_unlock_irqrestore(&dev->event_lock, flags);\n\n\treturn pending;\n}\n\nstatic void rcar_du_crtc_wait_page_flip(struct rcar_du_crtc *rcrtc)\n{\n\tstruct rcar_du_device *rcdu = rcrtc->dev;\n\n\tif (wait_event_timeout(rcrtc->flip_wait,\n\t\t\t       !rcar_du_crtc_page_flip_pending(rcrtc),\n\t\t\t       msecs_to_jiffies(50)))\n\t\treturn;\n\n\tdev_warn(rcdu->dev, \"page flip timeout\\n\");\n\n\trcar_du_crtc_finish_page_flip(rcrtc);\n}\n\n \n\nstatic int rcar_du_cmm_check(struct drm_crtc *crtc,\n\t\t\t     struct drm_crtc_state *state)\n{\n\tstruct drm_property_blob *drm_lut = state->gamma_lut;\n\tstruct rcar_du_crtc *rcrtc = to_rcar_crtc(crtc);\n\tstruct device *dev = rcrtc->dev->dev;\n\n\tif (!drm_lut)\n\t\treturn 0;\n\n\t \n\tif (drm_color_lut_size(drm_lut) != CM2_LUT_SIZE) {\n\t\tdev_err(dev, \"invalid gamma lut size: %zu bytes\\n\",\n\t\t\tdrm_lut->length);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic void rcar_du_cmm_setup(struct drm_crtc *crtc)\n{\n\tstruct drm_property_blob *drm_lut = crtc->state->gamma_lut;\n\tstruct rcar_du_crtc *rcrtc = to_rcar_crtc(crtc);\n\tstruct rcar_cmm_config cmm_config = {};\n\n\tif (!rcrtc->cmm)\n\t\treturn;\n\n\tif (drm_lut)\n\t\tcmm_config.lut.table = (struct drm_color_lut *)drm_lut->data;\n\n\trcar_cmm_setup(rcrtc->cmm, &cmm_config);\n}\n\n \n\nstatic void rcar_du_crtc_setup(struct rcar_du_crtc *rcrtc)\n{\n\t \n\trcar_du_crtc_write(rcrtc, DOOR, DOOR_RGB(0, 0, 0));\n\trcar_du_crtc_write(rcrtc, BPOR, BPOR_RGB(0, 0, 0));\n\n\t \n\trcar_du_crtc_set_display_timing(rcrtc);\n\trcar_du_group_set_routing(rcrtc->group);\n\n\t \n\trcar_du_group_write(rcrtc->group, rcrtc->index % 2 ? DS2PR : DS1PR, 0);\n\n\t \n\tif (rcar_du_has(rcrtc->dev, RCAR_DU_FEATURE_VSP1_SOURCE))\n\t\trcar_du_vsp_enable(rcrtc);\n\n\t \n\tdrm_crtc_vblank_on(&rcrtc->crtc);\n}\n\nstatic int rcar_du_crtc_get(struct rcar_du_crtc *rcrtc)\n{\n\tint ret;\n\n\t \n\tif (rcrtc->initialized)\n\t\treturn 0;\n\n\tret = clk_prepare_enable(rcrtc->clock);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = clk_prepare_enable(rcrtc->extclock);\n\tif (ret < 0)\n\t\tgoto error_clock;\n\n\tret = rcar_du_group_get(rcrtc->group);\n\tif (ret < 0)\n\t\tgoto error_group;\n\n\trcar_du_crtc_setup(rcrtc);\n\trcrtc->initialized = true;\n\n\treturn 0;\n\nerror_group:\n\tclk_disable_unprepare(rcrtc->extclock);\nerror_clock:\n\tclk_disable_unprepare(rcrtc->clock);\n\treturn ret;\n}\n\nstatic void rcar_du_crtc_put(struct rcar_du_crtc *rcrtc)\n{\n\trcar_du_group_put(rcrtc->group);\n\n\tclk_disable_unprepare(rcrtc->extclock);\n\tclk_disable_unprepare(rcrtc->clock);\n\n\trcrtc->initialized = false;\n}\n\nstatic void rcar_du_crtc_start(struct rcar_du_crtc *rcrtc)\n{\n\tbool interlaced;\n\n\t \n\tinterlaced = rcrtc->crtc.mode.flags & DRM_MODE_FLAG_INTERLACE;\n\trcar_du_crtc_dsysr_clr_set(rcrtc, DSYSR_TVM_MASK | DSYSR_SCM_MASK,\n\t\t\t\t   (interlaced ? DSYSR_SCM_INT_VIDEO : 0) |\n\t\t\t\t   DSYSR_TVM_MASTER);\n\n\trcar_du_group_start_stop(rcrtc->group, true);\n}\n\nstatic void rcar_du_crtc_disable_planes(struct rcar_du_crtc *rcrtc)\n{\n\tstruct rcar_du_device *rcdu = rcrtc->dev;\n\tstruct drm_crtc *crtc = &rcrtc->crtc;\n\tu32 status;\n\n\t \n\tdrm_crtc_vblank_get(crtc);\n\n\t \n\tspin_lock_irq(&rcrtc->vblank_lock);\n\trcar_du_group_write(rcrtc->group, rcrtc->index % 2 ? DS2PR : DS1PR, 0);\n\tstatus = rcar_du_crtc_read(rcrtc, DSSR);\n\trcrtc->vblank_count = status & DSSR_VBK ? 2 : 1;\n\tspin_unlock_irq(&rcrtc->vblank_lock);\n\n\tif (!wait_event_timeout(rcrtc->vblank_wait, rcrtc->vblank_count == 0,\n\t\t\t\tmsecs_to_jiffies(100)))\n\t\tdev_warn(rcdu->dev, \"vertical blanking timeout\\n\");\n\n\tdrm_crtc_vblank_put(crtc);\n}\n\nstatic void rcar_du_crtc_stop(struct rcar_du_crtc *rcrtc)\n{\n\tstruct drm_crtc *crtc = &rcrtc->crtc;\n\n\t \n\trcar_du_crtc_disable_planes(rcrtc);\n\n\t \n\trcar_du_crtc_wait_page_flip(rcrtc);\n\tdrm_crtc_vblank_off(crtc);\n\n\t \n\tif (rcar_du_has(rcrtc->dev, RCAR_DU_FEATURE_VSP1_SOURCE))\n\t\trcar_du_vsp_disable(rcrtc);\n\n\tif (rcrtc->cmm)\n\t\trcar_cmm_disable(rcrtc->cmm);\n\n\t \n\tif (rcar_du_has(rcrtc->dev, RCAR_DU_FEATURE_TVM_SYNC))\n\t\trcar_du_crtc_dsysr_clr_set(rcrtc, DSYSR_TVM_MASK,\n\t\t\t\t\t   DSYSR_TVM_SWITCH);\n\n\trcar_du_group_start_stop(rcrtc->group, false);\n}\n\n \n\nstatic int rcar_du_crtc_atomic_check(struct drm_crtc *crtc,\n\t\t\t\t     struct drm_atomic_state *state)\n{\n\tstruct drm_crtc_state *crtc_state = drm_atomic_get_new_crtc_state(state,\n\t\t\t\t\t\t\t\t\t  crtc);\n\tstruct rcar_du_crtc_state *rstate = to_rcar_crtc_state(crtc_state);\n\tstruct drm_encoder *encoder;\n\tint ret;\n\n\tret = rcar_du_cmm_check(crtc, crtc_state);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\trstate->outputs = 0;\n\n\tdrm_for_each_encoder_mask(encoder, crtc->dev,\n\t\t\t\t  crtc_state->encoder_mask) {\n\t\tstruct rcar_du_encoder *renc;\n\n\t\t \n\t\tif (encoder->encoder_type == DRM_MODE_ENCODER_VIRTUAL)\n\t\t\tcontinue;\n\n\t\trenc = to_rcar_encoder(encoder);\n\t\trstate->outputs |= BIT(renc->output);\n\t}\n\n\treturn 0;\n}\n\nstatic void rcar_du_crtc_atomic_enable(struct drm_crtc *crtc,\n\t\t\t\t       struct drm_atomic_state *state)\n{\n\tstruct rcar_du_crtc *rcrtc = to_rcar_crtc(crtc);\n\tstruct rcar_du_crtc_state *rstate = to_rcar_crtc_state(crtc->state);\n\tstruct rcar_du_device *rcdu = rcrtc->dev;\n\n\tif (rcrtc->cmm)\n\t\trcar_cmm_enable(rcrtc->cmm);\n\trcar_du_crtc_get(rcrtc);\n\n\t \n\tif (rcdu->info->lvds_clk_mask & BIT(rcrtc->index)) {\n\t\tbool dot_clk_only = rstate->outputs == BIT(RCAR_DU_OUTPUT_DPAD0);\n\t\tstruct drm_bridge *bridge = rcdu->lvds[rcrtc->index];\n\t\tconst struct drm_display_mode *mode =\n\t\t\t&crtc->state->adjusted_mode;\n\n\t\trcar_lvds_pclk_enable(bridge, mode->clock * 1000, dot_clk_only);\n\t}\n\n\t \n\tif ((rcdu->info->dsi_clk_mask & BIT(rcrtc->index)) &&\n\t    (rstate->outputs &\n\t     (BIT(RCAR_DU_OUTPUT_DSI0) | BIT(RCAR_DU_OUTPUT_DSI1)))) {\n\t\tstruct drm_bridge *bridge = rcdu->dsi[rcrtc->index];\n\n\t\trcar_mipi_dsi_pclk_enable(bridge, state);\n\t}\n\n\trcar_du_crtc_start(rcrtc);\n\n\t \n\trcar_du_cmm_setup(crtc);\n}\n\nstatic void rcar_du_crtc_atomic_disable(struct drm_crtc *crtc,\n\t\t\t\t\tstruct drm_atomic_state *state)\n{\n\tstruct drm_crtc_state *old_state = drm_atomic_get_old_crtc_state(state,\n\t\t\t\t\t\t\t\t\t crtc);\n\tstruct rcar_du_crtc *rcrtc = to_rcar_crtc(crtc);\n\tstruct rcar_du_crtc_state *rstate = to_rcar_crtc_state(old_state);\n\tstruct rcar_du_device *rcdu = rcrtc->dev;\n\n\trcar_du_crtc_stop(rcrtc);\n\trcar_du_crtc_put(rcrtc);\n\n\tif (rcdu->info->lvds_clk_mask & BIT(rcrtc->index)) {\n\t\tbool dot_clk_only = rstate->outputs == BIT(RCAR_DU_OUTPUT_DPAD0);\n\t\tstruct drm_bridge *bridge = rcdu->lvds[rcrtc->index];\n\n\t\t \n\t\trcar_lvds_pclk_disable(bridge, dot_clk_only);\n\t}\n\n\tif ((rcdu->info->dsi_clk_mask & BIT(rcrtc->index)) &&\n\t    (rstate->outputs &\n\t     (BIT(RCAR_DU_OUTPUT_DSI0) | BIT(RCAR_DU_OUTPUT_DSI1)))) {\n\t\tstruct drm_bridge *bridge = rcdu->dsi[rcrtc->index];\n\n\t\t \n\t\trcar_mipi_dsi_pclk_disable(bridge);\n\t}\n\n\tspin_lock_irq(&crtc->dev->event_lock);\n\tif (crtc->state->event) {\n\t\tdrm_crtc_send_vblank_event(crtc, crtc->state->event);\n\t\tcrtc->state->event = NULL;\n\t}\n\tspin_unlock_irq(&crtc->dev->event_lock);\n}\n\nstatic void rcar_du_crtc_atomic_begin(struct drm_crtc *crtc,\n\t\t\t\t      struct drm_atomic_state *state)\n{\n\tstruct rcar_du_crtc *rcrtc = to_rcar_crtc(crtc);\n\n\tWARN_ON(!crtc->state->enable);\n\n\t \n\trcar_du_crtc_get(rcrtc);\n\n\t \n\tif (crtc->state->color_mgmt_changed && !crtc->state->active_changed)\n\t\trcar_du_cmm_setup(crtc);\n\n\tif (rcar_du_has(rcrtc->dev, RCAR_DU_FEATURE_VSP1_SOURCE))\n\t\trcar_du_vsp_atomic_begin(rcrtc);\n}\n\nstatic void rcar_du_crtc_atomic_flush(struct drm_crtc *crtc,\n\t\t\t\t      struct drm_atomic_state *state)\n{\n\tstruct rcar_du_crtc *rcrtc = to_rcar_crtc(crtc);\n\tstruct drm_device *dev = rcrtc->crtc.dev;\n\tunsigned long flags;\n\n\trcar_du_crtc_update_planes(rcrtc);\n\n\tif (crtc->state->event) {\n\t\tWARN_ON(drm_crtc_vblank_get(crtc) != 0);\n\n\t\tspin_lock_irqsave(&dev->event_lock, flags);\n\t\trcrtc->event = crtc->state->event;\n\t\tcrtc->state->event = NULL;\n\t\tspin_unlock_irqrestore(&dev->event_lock, flags);\n\t}\n\n\tif (rcar_du_has(rcrtc->dev, RCAR_DU_FEATURE_VSP1_SOURCE))\n\t\trcar_du_vsp_atomic_flush(rcrtc);\n}\n\nstatic enum drm_mode_status\nrcar_du_crtc_mode_valid(struct drm_crtc *crtc,\n\t\t\tconst struct drm_display_mode *mode)\n{\n\tstruct rcar_du_crtc *rcrtc = to_rcar_crtc(crtc);\n\tstruct rcar_du_device *rcdu = rcrtc->dev;\n\tbool interlaced = mode->flags & DRM_MODE_FLAG_INTERLACE;\n\tunsigned int min_sync_porch;\n\tunsigned int vbp;\n\n\tif (interlaced && !rcar_du_has(rcdu, RCAR_DU_FEATURE_INTERLACED))\n\t\treturn MODE_NO_INTERLACE;\n\n\t \n\tmin_sync_porch = 20;\n\tif (rcrtc->group->cmms_mask & BIT(rcrtc->index % 2))\n\t\tmin_sync_porch += 25;\n\n\tif (mode->htotal - mode->hsync_start < min_sync_porch)\n\t\treturn MODE_HBLANK_NARROW;\n\n\tvbp = (mode->vtotal - mode->vsync_end) / (interlaced ? 2 : 1);\n\tif (vbp < 3)\n\t\treturn MODE_VBLANK_NARROW;\n\n\treturn MODE_OK;\n}\n\nstatic const struct drm_crtc_helper_funcs crtc_helper_funcs = {\n\t.atomic_check = rcar_du_crtc_atomic_check,\n\t.atomic_begin = rcar_du_crtc_atomic_begin,\n\t.atomic_flush = rcar_du_crtc_atomic_flush,\n\t.atomic_enable = rcar_du_crtc_atomic_enable,\n\t.atomic_disable = rcar_du_crtc_atomic_disable,\n\t.mode_valid = rcar_du_crtc_mode_valid,\n};\n\nstatic void rcar_du_crtc_crc_init(struct rcar_du_crtc *rcrtc)\n{\n\tstruct rcar_du_device *rcdu = rcrtc->dev;\n\tconst char **sources;\n\tunsigned int count;\n\tint i = -1;\n\n\t \n\tif (rcdu->info->gen < 3)\n\t\treturn;\n\n\t \n\tcount = rcrtc->vsp->num_planes + 1;\n\n\tsources = kmalloc_array(count, sizeof(*sources), GFP_KERNEL);\n\tif (!sources)\n\t\treturn;\n\n\tsources[0] = kstrdup(\"auto\", GFP_KERNEL);\n\tif (!sources[0])\n\t\tgoto error;\n\n\tfor (i = 0; i < rcrtc->vsp->num_planes; ++i) {\n\t\tstruct drm_plane *plane = &rcrtc->vsp->planes[i].plane;\n\t\tchar name[16];\n\n\t\tsprintf(name, \"plane%u\", plane->base.id);\n\t\tsources[i + 1] = kstrdup(name, GFP_KERNEL);\n\t\tif (!sources[i + 1])\n\t\t\tgoto error;\n\t}\n\n\trcrtc->sources = sources;\n\trcrtc->sources_count = count;\n\treturn;\n\nerror:\n\twhile (i >= 0) {\n\t\tkfree(sources[i]);\n\t\ti--;\n\t}\n\tkfree(sources);\n}\n\nstatic void rcar_du_crtc_crc_cleanup(struct rcar_du_crtc *rcrtc)\n{\n\tunsigned int i;\n\n\tif (!rcrtc->sources)\n\t\treturn;\n\n\tfor (i = 0; i < rcrtc->sources_count; i++)\n\t\tkfree(rcrtc->sources[i]);\n\tkfree(rcrtc->sources);\n\n\trcrtc->sources = NULL;\n\trcrtc->sources_count = 0;\n}\n\nstatic struct drm_crtc_state *\nrcar_du_crtc_atomic_duplicate_state(struct drm_crtc *crtc)\n{\n\tstruct rcar_du_crtc_state *state;\n\tstruct rcar_du_crtc_state *copy;\n\n\tif (WARN_ON(!crtc->state))\n\t\treturn NULL;\n\n\tstate = to_rcar_crtc_state(crtc->state);\n\tcopy = kmemdup(state, sizeof(*state), GFP_KERNEL);\n\tif (copy == NULL)\n\t\treturn NULL;\n\n\t__drm_atomic_helper_crtc_duplicate_state(crtc, &copy->state);\n\n\treturn &copy->state;\n}\n\nstatic void rcar_du_crtc_atomic_destroy_state(struct drm_crtc *crtc,\n\t\t\t\t\t      struct drm_crtc_state *state)\n{\n\t__drm_atomic_helper_crtc_destroy_state(state);\n\tkfree(to_rcar_crtc_state(state));\n}\n\nstatic void rcar_du_crtc_cleanup(struct drm_crtc *crtc)\n{\n\tstruct rcar_du_crtc *rcrtc = to_rcar_crtc(crtc);\n\n\trcar_du_crtc_crc_cleanup(rcrtc);\n\n\treturn drm_crtc_cleanup(crtc);\n}\n\nstatic void rcar_du_crtc_reset(struct drm_crtc *crtc)\n{\n\tstruct rcar_du_crtc_state *state;\n\n\tif (crtc->state) {\n\t\trcar_du_crtc_atomic_destroy_state(crtc, crtc->state);\n\t\tcrtc->state = NULL;\n\t}\n\n\tstate = kzalloc(sizeof(*state), GFP_KERNEL);\n\tif (state == NULL)\n\t\treturn;\n\n\tstate->crc.source = VSP1_DU_CRC_NONE;\n\tstate->crc.index = 0;\n\n\t__drm_atomic_helper_crtc_reset(crtc, &state->state);\n}\n\nstatic int rcar_du_crtc_enable_vblank(struct drm_crtc *crtc)\n{\n\tstruct rcar_du_crtc *rcrtc = to_rcar_crtc(crtc);\n\n\trcar_du_crtc_write(rcrtc, DSRCR, DSRCR_VBCL);\n\trcar_du_crtc_set(rcrtc, DIER, DIER_VBE);\n\trcrtc->vblank_enable = true;\n\n\treturn 0;\n}\n\nstatic void rcar_du_crtc_disable_vblank(struct drm_crtc *crtc)\n{\n\tstruct rcar_du_crtc *rcrtc = to_rcar_crtc(crtc);\n\n\trcar_du_crtc_clr(rcrtc, DIER, DIER_VBE);\n\trcrtc->vblank_enable = false;\n}\n\nstatic int rcar_du_crtc_parse_crc_source(struct rcar_du_crtc *rcrtc,\n\t\t\t\t\t const char *source_name,\n\t\t\t\t\t enum vsp1_du_crc_source *source)\n{\n\tunsigned int index;\n\tint ret;\n\n\t \n\n\tif (!source_name) {\n\t\t*source = VSP1_DU_CRC_NONE;\n\t\treturn 0;\n\t} else if (!strcmp(source_name, \"auto\")) {\n\t\t*source = VSP1_DU_CRC_OUTPUT;\n\t\treturn 0;\n\t} else if (strstarts(source_name, \"plane\")) {\n\t\tunsigned int i;\n\n\t\t*source = VSP1_DU_CRC_PLANE;\n\n\t\tret = kstrtouint(source_name + strlen(\"plane\"), 10, &index);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tfor (i = 0; i < rcrtc->vsp->num_planes; ++i) {\n\t\t\tif (index == rcrtc->vsp->planes[i].plane.base.id)\n\t\t\t\treturn i;\n\t\t}\n\t}\n\n\treturn -EINVAL;\n}\n\nstatic int rcar_du_crtc_verify_crc_source(struct drm_crtc *crtc,\n\t\t\t\t\t  const char *source_name,\n\t\t\t\t\t  size_t *values_cnt)\n{\n\tstruct rcar_du_crtc *rcrtc = to_rcar_crtc(crtc);\n\tenum vsp1_du_crc_source source;\n\n\tif (rcar_du_crtc_parse_crc_source(rcrtc, source_name, &source) < 0) {\n\t\tDRM_DEBUG_DRIVER(\"unknown source %s\\n\", source_name);\n\t\treturn -EINVAL;\n\t}\n\n\t*values_cnt = 1;\n\treturn 0;\n}\n\nstatic const char *const *\nrcar_du_crtc_get_crc_sources(struct drm_crtc *crtc, size_t *count)\n{\n\tstruct rcar_du_crtc *rcrtc = to_rcar_crtc(crtc);\n\n\t*count = rcrtc->sources_count;\n\treturn rcrtc->sources;\n}\n\nstatic int rcar_du_crtc_set_crc_source(struct drm_crtc *crtc,\n\t\t\t\t       const char *source_name)\n{\n\tstruct rcar_du_crtc *rcrtc = to_rcar_crtc(crtc);\n\tstruct drm_modeset_acquire_ctx ctx;\n\tstruct drm_crtc_state *crtc_state;\n\tstruct drm_atomic_state *state;\n\tenum vsp1_du_crc_source source;\n\tunsigned int index;\n\tint ret;\n\n\tret = rcar_du_crtc_parse_crc_source(rcrtc, source_name, &source);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tindex = ret;\n\n\t \n\tdrm_modeset_acquire_init(&ctx, 0);\n\n\tstate = drm_atomic_state_alloc(crtc->dev);\n\tif (!state) {\n\t\tret = -ENOMEM;\n\t\tgoto unlock;\n\t}\n\n\tstate->acquire_ctx = &ctx;\n\nretry:\n\tcrtc_state = drm_atomic_get_crtc_state(state, crtc);\n\tif (!IS_ERR(crtc_state)) {\n\t\tstruct rcar_du_crtc_state *rcrtc_state;\n\n\t\trcrtc_state = to_rcar_crtc_state(crtc_state);\n\t\trcrtc_state->crc.source = source;\n\t\trcrtc_state->crc.index = index;\n\n\t\tret = drm_atomic_commit(state);\n\t} else {\n\t\tret = PTR_ERR(crtc_state);\n\t}\n\n\tif (ret == -EDEADLK) {\n\t\tdrm_atomic_state_clear(state);\n\t\tdrm_modeset_backoff(&ctx);\n\t\tgoto retry;\n\t}\n\n\tdrm_atomic_state_put(state);\n\nunlock:\n\tdrm_modeset_drop_locks(&ctx);\n\tdrm_modeset_acquire_fini(&ctx);\n\n\treturn ret;\n}\n\nstatic const struct drm_crtc_funcs crtc_funcs_gen2 = {\n\t.reset = rcar_du_crtc_reset,\n\t.destroy = drm_crtc_cleanup,\n\t.set_config = drm_atomic_helper_set_config,\n\t.page_flip = drm_atomic_helper_page_flip,\n\t.atomic_duplicate_state = rcar_du_crtc_atomic_duplicate_state,\n\t.atomic_destroy_state = rcar_du_crtc_atomic_destroy_state,\n\t.enable_vblank = rcar_du_crtc_enable_vblank,\n\t.disable_vblank = rcar_du_crtc_disable_vblank,\n};\n\nstatic const struct drm_crtc_funcs crtc_funcs_gen3 = {\n\t.reset = rcar_du_crtc_reset,\n\t.destroy = rcar_du_crtc_cleanup,\n\t.set_config = drm_atomic_helper_set_config,\n\t.page_flip = drm_atomic_helper_page_flip,\n\t.atomic_duplicate_state = rcar_du_crtc_atomic_duplicate_state,\n\t.atomic_destroy_state = rcar_du_crtc_atomic_destroy_state,\n\t.enable_vblank = rcar_du_crtc_enable_vblank,\n\t.disable_vblank = rcar_du_crtc_disable_vblank,\n\t.set_crc_source = rcar_du_crtc_set_crc_source,\n\t.verify_crc_source = rcar_du_crtc_verify_crc_source,\n\t.get_crc_sources = rcar_du_crtc_get_crc_sources,\n};\n\n \n\nstatic irqreturn_t rcar_du_crtc_irq(int irq, void *arg)\n{\n\tstruct rcar_du_crtc *rcrtc = arg;\n\tstruct rcar_du_device *rcdu = rcrtc->dev;\n\tirqreturn_t ret = IRQ_NONE;\n\tu32 status;\n\n\tspin_lock(&rcrtc->vblank_lock);\n\n\tstatus = rcar_du_crtc_read(rcrtc, DSSR);\n\trcar_du_crtc_write(rcrtc, DSRCR, status & DSRCR_MASK);\n\n\tif (status & DSSR_VBK) {\n\t\t \n\t\tif (rcrtc->vblank_count) {\n\t\t\tif (--rcrtc->vblank_count == 0)\n\t\t\t\twake_up(&rcrtc->vblank_wait);\n\t\t}\n\t}\n\n\tspin_unlock(&rcrtc->vblank_lock);\n\n\tif (status & DSSR_VBK) {\n\t\tif (rcdu->info->gen < 3) {\n\t\t\tdrm_crtc_handle_vblank(&rcrtc->crtc);\n\t\t\trcar_du_crtc_finish_page_flip(rcrtc);\n\t\t}\n\n\t\tret = IRQ_HANDLED;\n\t}\n\n\treturn ret;\n}\n\n \n\nint rcar_du_crtc_create(struct rcar_du_group *rgrp, unsigned int swindex,\n\t\t\tunsigned int hwindex)\n{\n\tstatic const unsigned int mmio_offsets[] = {\n\t\tDU0_REG_OFFSET, DU1_REG_OFFSET, DU2_REG_OFFSET, DU3_REG_OFFSET\n\t};\n\n\tstruct rcar_du_device *rcdu = rgrp->dev;\n\tstruct platform_device *pdev = to_platform_device(rcdu->dev);\n\tstruct rcar_du_crtc *rcrtc = &rcdu->crtcs[swindex];\n\tstruct drm_crtc *crtc = &rcrtc->crtc;\n\tstruct drm_plane *primary;\n\tunsigned int irqflags;\n\tstruct clk *clk;\n\tchar clk_name[9];\n\tchar *name;\n\tint irq;\n\tint ret;\n\n\t \n\tif (rcar_du_has(rcdu, RCAR_DU_FEATURE_CRTC_CLOCK)) {\n\t\tsprintf(clk_name, \"du.%u\", hwindex);\n\t\tname = clk_name;\n\t} else {\n\t\tname = NULL;\n\t}\n\n\trcrtc->clock = devm_clk_get(rcdu->dev, name);\n\tif (IS_ERR(rcrtc->clock)) {\n\t\tdev_err(rcdu->dev, \"no clock for DU channel %u\\n\", hwindex);\n\t\treturn PTR_ERR(rcrtc->clock);\n\t}\n\n\tsprintf(clk_name, \"dclkin.%u\", hwindex);\n\tclk = devm_clk_get(rcdu->dev, clk_name);\n\tif (!IS_ERR(clk)) {\n\t\trcrtc->extclock = clk;\n\t} else if (PTR_ERR(clk) == -EPROBE_DEFER) {\n\t\treturn -EPROBE_DEFER;\n\t} else if (rcdu->info->dpll_mask & BIT(hwindex)) {\n\t\t \n\t\tret = PTR_ERR(clk);\n\t\tdev_err(rcdu->dev, \"can't get dclkin.%u: %d\\n\", hwindex, ret);\n\t\treturn ret;\n\t}\n\n\tinit_waitqueue_head(&rcrtc->flip_wait);\n\tinit_waitqueue_head(&rcrtc->vblank_wait);\n\tspin_lock_init(&rcrtc->vblank_lock);\n\n\trcrtc->dev = rcdu;\n\trcrtc->group = rgrp;\n\trcrtc->mmio_offset = mmio_offsets[hwindex];\n\trcrtc->index = hwindex;\n\trcrtc->dsysr = rcrtc->index % 2 ? 0 : DSYSR_DRES;\n\n\tif (rcar_du_has(rcdu, RCAR_DU_FEATURE_TVM_SYNC))\n\t\trcrtc->dsysr |= DSYSR_TVM_TVSYNC;\n\n\tif (rcar_du_has(rcdu, RCAR_DU_FEATURE_VSP1_SOURCE))\n\t\tprimary = &rcrtc->vsp->planes[rcrtc->vsp_pipe].plane;\n\telse\n\t\tprimary = &rgrp->planes[swindex % 2].plane;\n\n\tret = drm_crtc_init_with_planes(&rcdu->ddev, crtc, primary, NULL,\n\t\t\t\t\trcdu->info->gen <= 2 ?\n\t\t\t\t\t&crtc_funcs_gen2 : &crtc_funcs_gen3,\n\t\t\t\t\tNULL);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tif (rcdu->cmms[swindex]) {\n\t\trcrtc->cmm = rcdu->cmms[swindex];\n\t\trgrp->cmms_mask |= BIT(hwindex % 2);\n\n\t\tdrm_mode_crtc_set_gamma_size(crtc, CM2_LUT_SIZE);\n\t\tdrm_crtc_enable_color_mgmt(crtc, 0, false, CM2_LUT_SIZE);\n\t}\n\n\tdrm_crtc_helper_add(crtc, &crtc_helper_funcs);\n\n\t \n\tif (rcar_du_has(rcdu, RCAR_DU_FEATURE_CRTC_IRQ)) {\n\t\t \n\t\tirq = platform_get_irq(pdev, swindex);\n\t\tirqflags = 0;\n\t} else {\n\t\tirq = platform_get_irq(pdev, 0);\n\t\tirqflags = IRQF_SHARED;\n\t}\n\n\tif (irq < 0) {\n\t\tdev_err(rcdu->dev, \"no IRQ for CRTC %u\\n\", swindex);\n\t\treturn irq;\n\t}\n\n\tret = devm_request_irq(rcdu->dev, irq, rcar_du_crtc_irq, irqflags,\n\t\t\t       dev_name(rcdu->dev), rcrtc);\n\tif (ret < 0) {\n\t\tdev_err(rcdu->dev,\n\t\t\t\"failed to register IRQ for CRTC %u\\n\", swindex);\n\t\treturn ret;\n\t}\n\n\trcar_du_crtc_crc_init(rcrtc);\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}