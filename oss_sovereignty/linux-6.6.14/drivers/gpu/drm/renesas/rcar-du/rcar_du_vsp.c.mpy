{
  "module_name": "rcar_du_vsp.c",
  "hash_id": "ba93f1c9694db752863c917427d374c347ea84092d809958f4573ee238e43de8",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/renesas/rcar-du/rcar_du_vsp.c",
  "human_readable_source": "\n \n\n#include <drm/drm_atomic.h>\n#include <drm/drm_atomic_helper.h>\n#include <drm/drm_blend.h>\n#include <drm/drm_crtc.h>\n#include <drm/drm_fb_dma_helper.h>\n#include <drm/drm_fourcc.h>\n#include <drm/drm_framebuffer.h>\n#include <drm/drm_gem_atomic_helper.h>\n#include <drm/drm_gem_dma_helper.h>\n#include <drm/drm_managed.h>\n#include <drm/drm_vblank.h>\n\n#include <linux/bitops.h>\n#include <linux/dma-mapping.h>\n#include <linux/of_platform.h>\n#include <linux/platform_device.h>\n#include <linux/scatterlist.h>\n#include <linux/slab.h>\n#include <linux/videodev2.h>\n\n#include <media/vsp1.h>\n\n#include \"rcar_du_drv.h\"\n#include \"rcar_du_kms.h\"\n#include \"rcar_du_vsp.h\"\n#include \"rcar_du_writeback.h\"\n\nstatic void rcar_du_vsp_complete(void *private, unsigned int status, u32 crc)\n{\n\tstruct rcar_du_crtc *crtc = private;\n\n\tif (crtc->vblank_enable)\n\t\tdrm_crtc_handle_vblank(&crtc->crtc);\n\n\tif (status & VSP1_DU_STATUS_COMPLETE)\n\t\trcar_du_crtc_finish_page_flip(crtc);\n\tif (status & VSP1_DU_STATUS_WRITEBACK)\n\t\trcar_du_writeback_complete(crtc);\n\n\tdrm_crtc_add_crc_entry(&crtc->crtc, false, 0, &crc);\n}\n\nvoid rcar_du_vsp_enable(struct rcar_du_crtc *crtc)\n{\n\tconst struct drm_display_mode *mode = &crtc->crtc.state->adjusted_mode;\n\tstruct rcar_du_device *rcdu = crtc->dev;\n\tstruct vsp1_du_lif_config cfg = {\n\t\t.width = mode->hdisplay,\n\t\t.height = mode->vdisplay,\n\t\t.interlaced = mode->flags & DRM_MODE_FLAG_INTERLACE,\n\t\t.callback = rcar_du_vsp_complete,\n\t\t.callback_data = crtc,\n\t};\n\tstruct rcar_du_plane_state state = {\n\t\t.state = {\n\t\t\t.alpha = DRM_BLEND_ALPHA_OPAQUE,\n\t\t\t.crtc = &crtc->crtc,\n\t\t\t.dst.x1 = 0,\n\t\t\t.dst.y1 = 0,\n\t\t\t.dst.x2 = mode->hdisplay,\n\t\t\t.dst.y2 = mode->vdisplay,\n\t\t\t.src.x1 = 0,\n\t\t\t.src.y1 = 0,\n\t\t\t.src.x2 = mode->hdisplay << 16,\n\t\t\t.src.y2 = mode->vdisplay << 16,\n\t\t\t.zpos = 0,\n\t\t},\n\t\t.format = rcar_du_format_info(DRM_FORMAT_XRGB8888),\n\t\t.source = RCAR_DU_PLANE_VSPD1,\n\t\t.colorkey = 0,\n\t};\n\n\tif (rcdu->info->gen >= 3)\n\t\tstate.hwindex = (crtc->index % 2) ? 2 : 0;\n\telse\n\t\tstate.hwindex = crtc->index % 2;\n\n\t__rcar_du_plane_setup(crtc->group, &state);\n\n\tvsp1_du_setup_lif(crtc->vsp->vsp, crtc->vsp_pipe, &cfg);\n}\n\nvoid rcar_du_vsp_disable(struct rcar_du_crtc *crtc)\n{\n\tvsp1_du_setup_lif(crtc->vsp->vsp, crtc->vsp_pipe, NULL);\n}\n\nvoid rcar_du_vsp_atomic_begin(struct rcar_du_crtc *crtc)\n{\n\tvsp1_du_atomic_begin(crtc->vsp->vsp, crtc->vsp_pipe);\n}\n\nvoid rcar_du_vsp_atomic_flush(struct rcar_du_crtc *crtc)\n{\n\tstruct vsp1_du_atomic_pipe_config cfg = { { 0, } };\n\tstruct rcar_du_crtc_state *state;\n\n\tstate = to_rcar_crtc_state(crtc->crtc.state);\n\tcfg.crc = state->crc;\n\n\trcar_du_writeback_setup(crtc, &cfg.writeback);\n\n\tvsp1_du_atomic_flush(crtc->vsp->vsp, crtc->vsp_pipe, &cfg);\n}\n\nstatic const u32 rcar_du_vsp_formats[] = {\n\tDRM_FORMAT_RGB332,\n\tDRM_FORMAT_ARGB4444,\n\tDRM_FORMAT_XRGB4444,\n\tDRM_FORMAT_ARGB1555,\n\tDRM_FORMAT_XRGB1555,\n\tDRM_FORMAT_RGB565,\n\tDRM_FORMAT_BGR888,\n\tDRM_FORMAT_RGB888,\n\tDRM_FORMAT_BGRA8888,\n\tDRM_FORMAT_BGRX8888,\n\tDRM_FORMAT_ABGR8888,\n\tDRM_FORMAT_XBGR8888,\n\tDRM_FORMAT_ARGB8888,\n\tDRM_FORMAT_XRGB8888,\n\tDRM_FORMAT_UYVY,\n\tDRM_FORMAT_YUYV,\n\tDRM_FORMAT_YVYU,\n\tDRM_FORMAT_NV12,\n\tDRM_FORMAT_NV21,\n\tDRM_FORMAT_NV16,\n\tDRM_FORMAT_NV61,\n\tDRM_FORMAT_YUV420,\n\tDRM_FORMAT_YVU420,\n\tDRM_FORMAT_YUV422,\n\tDRM_FORMAT_YVU422,\n\tDRM_FORMAT_YUV444,\n\tDRM_FORMAT_YVU444,\n};\n\n \nstatic const u32 rcar_du_vsp_formats_gen4[] = {\n\tDRM_FORMAT_RGB332,\n\tDRM_FORMAT_ARGB4444,\n\tDRM_FORMAT_XRGB4444,\n\tDRM_FORMAT_ARGB1555,\n\tDRM_FORMAT_XRGB1555,\n\tDRM_FORMAT_RGB565,\n\tDRM_FORMAT_BGR888,\n\tDRM_FORMAT_RGB888,\n\tDRM_FORMAT_BGRA8888,\n\tDRM_FORMAT_BGRX8888,\n\tDRM_FORMAT_ABGR8888,\n\tDRM_FORMAT_XBGR8888,\n\tDRM_FORMAT_ARGB8888,\n\tDRM_FORMAT_XRGB8888,\n\tDRM_FORMAT_RGBX1010102,\n\tDRM_FORMAT_RGBA1010102,\n\tDRM_FORMAT_ARGB2101010,\n\tDRM_FORMAT_UYVY,\n\tDRM_FORMAT_YUYV,\n\tDRM_FORMAT_YVYU,\n\tDRM_FORMAT_NV12,\n\tDRM_FORMAT_NV21,\n\tDRM_FORMAT_NV16,\n\tDRM_FORMAT_NV61,\n\tDRM_FORMAT_YUV420,\n\tDRM_FORMAT_YVU420,\n\tDRM_FORMAT_YUV422,\n\tDRM_FORMAT_YVU422,\n\tDRM_FORMAT_YUV444,\n\tDRM_FORMAT_YVU444,\n\tDRM_FORMAT_Y210,\n\tDRM_FORMAT_Y212,\n};\n\nstatic u32 rcar_du_vsp_state_get_format(struct rcar_du_vsp_plane_state *state)\n{\n\tu32 fourcc = state->format->fourcc;\n\n\tif (state->state.pixel_blend_mode == DRM_MODE_BLEND_PIXEL_NONE) {\n\t\tswitch (fourcc) {\n\t\tcase DRM_FORMAT_ARGB1555:\n\t\t\tfourcc = DRM_FORMAT_XRGB1555;\n\t\t\tbreak;\n\n\t\tcase DRM_FORMAT_ARGB4444:\n\t\t\tfourcc = DRM_FORMAT_XRGB4444;\n\t\t\tbreak;\n\n\t\tcase DRM_FORMAT_ARGB8888:\n\t\t\tfourcc = DRM_FORMAT_XRGB8888;\n\t\t\tbreak;\n\n\t\tcase DRM_FORMAT_ABGR8888:\n\t\t\tfourcc = DRM_FORMAT_XBGR8888;\n\t\t\tbreak;\n\n\t\tcase DRM_FORMAT_BGRA8888:\n\t\t\tfourcc = DRM_FORMAT_BGRX8888;\n\t\t\tbreak;\n\n\t\tcase DRM_FORMAT_RGBA1010102:\n\t\t\tfourcc = DRM_FORMAT_RGBX1010102;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn fourcc;\n}\n\nstatic void rcar_du_vsp_plane_setup(struct rcar_du_vsp_plane *plane)\n{\n\tstruct rcar_du_vsp_plane_state *state =\n\t\tto_rcar_vsp_plane_state(plane->plane.state);\n\tstruct rcar_du_crtc *crtc = to_rcar_crtc(state->state.crtc);\n\tstruct drm_framebuffer *fb = plane->plane.state->fb;\n\tconst struct rcar_du_format_info *format;\n\tstruct vsp1_du_atomic_config cfg = {\n\t\t.pixelformat = 0,\n\t\t.pitch = fb->pitches[0],\n\t\t.alpha = state->state.alpha >> 8,\n\t\t.zpos = state->state.zpos,\n\t};\n\tu32 fourcc = rcar_du_vsp_state_get_format(state);\n\tunsigned int i;\n\n\tcfg.src.left = state->state.src.x1 >> 16;\n\tcfg.src.top = state->state.src.y1 >> 16;\n\tcfg.src.width = drm_rect_width(&state->state.src) >> 16;\n\tcfg.src.height = drm_rect_height(&state->state.src) >> 16;\n\n\tcfg.dst.left = state->state.dst.x1;\n\tcfg.dst.top = state->state.dst.y1;\n\tcfg.dst.width = drm_rect_width(&state->state.dst);\n\tcfg.dst.height = drm_rect_height(&state->state.dst);\n\n\tfor (i = 0; i < state->format->planes; ++i)\n\t\tcfg.mem[i] = sg_dma_address(state->sg_tables[i].sgl)\n\t\t\t   + fb->offsets[i];\n\n\tformat = rcar_du_format_info(fourcc);\n\tcfg.pixelformat = format->v4l2;\n\n\tcfg.premult = state->state.pixel_blend_mode == DRM_MODE_BLEND_PREMULTI;\n\n\tvsp1_du_atomic_update(plane->vsp->vsp, crtc->vsp_pipe,\n\t\t\t      plane->index, &cfg);\n}\n\nint rcar_du_vsp_map_fb(struct rcar_du_vsp *vsp, struct drm_framebuffer *fb,\n\t\t       struct sg_table sg_tables[3])\n{\n\tstruct rcar_du_device *rcdu = vsp->dev;\n\tunsigned int i, j;\n\tint ret;\n\n\tfor (i = 0; i < fb->format->num_planes; ++i) {\n\t\tstruct drm_gem_dma_object *gem = drm_fb_dma_get_gem_obj(fb, i);\n\t\tstruct sg_table *sgt = &sg_tables[i];\n\n\t\tif (gem->sgt) {\n\t\t\tstruct scatterlist *src;\n\t\t\tstruct scatterlist *dst;\n\n\t\t\t \n\t\t\tret = sg_alloc_table(sgt, gem->sgt->orig_nents,\n\t\t\t\t\t     GFP_KERNEL);\n\t\t\tif (ret)\n\t\t\t\tgoto fail;\n\n\t\t\tsrc = gem->sgt->sgl;\n\t\t\tdst = sgt->sgl;\n\t\t\tfor (j = 0; j < gem->sgt->orig_nents; ++j) {\n\t\t\t\tsg_set_page(dst, sg_page(src), src->length,\n\t\t\t\t\t    src->offset);\n\t\t\t\tsrc = sg_next(src);\n\t\t\t\tdst = sg_next(dst);\n\t\t\t}\n\t\t} else {\n\t\t\tret = dma_get_sgtable(rcdu->dev, sgt, gem->vaddr,\n\t\t\t\t\t      gem->dma_addr, gem->base.size);\n\t\t\tif (ret)\n\t\t\t\tgoto fail;\n\t\t}\n\n\t\tret = vsp1_du_map_sg(vsp->vsp, sgt);\n\t\tif (ret) {\n\t\t\tsg_free_table(sgt);\n\t\t\tgoto fail;\n\t\t}\n\t}\n\n\treturn 0;\n\nfail:\n\twhile (i--) {\n\t\tstruct sg_table *sgt = &sg_tables[i];\n\n\t\tvsp1_du_unmap_sg(vsp->vsp, sgt);\n\t\tsg_free_table(sgt);\n\t}\n\n\treturn ret;\n}\n\nstatic int rcar_du_vsp_plane_prepare_fb(struct drm_plane *plane,\n\t\t\t\t\tstruct drm_plane_state *state)\n{\n\tstruct rcar_du_vsp_plane_state *rstate = to_rcar_vsp_plane_state(state);\n\tstruct rcar_du_vsp *vsp = to_rcar_vsp_plane(plane)->vsp;\n\tint ret;\n\n\t \n\tif (!state->visible)\n\t\treturn 0;\n\n\tret = rcar_du_vsp_map_fb(vsp, state->fb, rstate->sg_tables);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn drm_gem_plane_helper_prepare_fb(plane, state);\n}\n\nvoid rcar_du_vsp_unmap_fb(struct rcar_du_vsp *vsp, struct drm_framebuffer *fb,\n\t\t\t  struct sg_table sg_tables[3])\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < fb->format->num_planes; ++i) {\n\t\tstruct sg_table *sgt = &sg_tables[i];\n\n\t\tvsp1_du_unmap_sg(vsp->vsp, sgt);\n\t\tsg_free_table(sgt);\n\t}\n}\n\nstatic void rcar_du_vsp_plane_cleanup_fb(struct drm_plane *plane,\n\t\t\t\t\t struct drm_plane_state *state)\n{\n\tstruct rcar_du_vsp_plane_state *rstate = to_rcar_vsp_plane_state(state);\n\tstruct rcar_du_vsp *vsp = to_rcar_vsp_plane(plane)->vsp;\n\n\tif (!state->visible)\n\t\treturn;\n\n\trcar_du_vsp_unmap_fb(vsp, state->fb, rstate->sg_tables);\n}\n\nstatic int rcar_du_vsp_plane_atomic_check(struct drm_plane *plane,\n\t\t\t\t\t  struct drm_atomic_state *state)\n{\n\tstruct drm_plane_state *new_plane_state = drm_atomic_get_new_plane_state(state,\n\t\t\t\t\t\t\t\t\t\t plane);\n\tstruct rcar_du_vsp_plane_state *rstate = to_rcar_vsp_plane_state(new_plane_state);\n\n\treturn __rcar_du_plane_atomic_check(plane, new_plane_state,\n\t\t\t\t\t    &rstate->format);\n}\n\nstatic void rcar_du_vsp_plane_atomic_update(struct drm_plane *plane,\n\t\t\t\t\tstruct drm_atomic_state *state)\n{\n\tstruct drm_plane_state *old_state = drm_atomic_get_old_plane_state(state, plane);\n\tstruct drm_plane_state *new_state = drm_atomic_get_new_plane_state(state, plane);\n\tstruct rcar_du_vsp_plane *rplane = to_rcar_vsp_plane(plane);\n\tstruct rcar_du_crtc *crtc = to_rcar_crtc(old_state->crtc);\n\n\tif (new_state->visible)\n\t\trcar_du_vsp_plane_setup(rplane);\n\telse if (old_state->crtc)\n\t\tvsp1_du_atomic_update(rplane->vsp->vsp, crtc->vsp_pipe,\n\t\t\t\t      rplane->index, NULL);\n}\n\nstatic const struct drm_plane_helper_funcs rcar_du_vsp_plane_helper_funcs = {\n\t.prepare_fb = rcar_du_vsp_plane_prepare_fb,\n\t.cleanup_fb = rcar_du_vsp_plane_cleanup_fb,\n\t.atomic_check = rcar_du_vsp_plane_atomic_check,\n\t.atomic_update = rcar_du_vsp_plane_atomic_update,\n};\n\nstatic struct drm_plane_state *\nrcar_du_vsp_plane_atomic_duplicate_state(struct drm_plane *plane)\n{\n\tstruct rcar_du_vsp_plane_state *copy;\n\n\tif (WARN_ON(!plane->state))\n\t\treturn NULL;\n\n\tcopy = kzalloc(sizeof(*copy), GFP_KERNEL);\n\tif (copy == NULL)\n\t\treturn NULL;\n\n\t__drm_atomic_helper_plane_duplicate_state(plane, &copy->state);\n\n\treturn &copy->state;\n}\n\nstatic void rcar_du_vsp_plane_atomic_destroy_state(struct drm_plane *plane,\n\t\t\t\t\t\t   struct drm_plane_state *state)\n{\n\t__drm_atomic_helper_plane_destroy_state(state);\n\tkfree(to_rcar_vsp_plane_state(state));\n}\n\nstatic void rcar_du_vsp_plane_reset(struct drm_plane *plane)\n{\n\tstruct rcar_du_vsp_plane_state *state;\n\n\tif (plane->state) {\n\t\trcar_du_vsp_plane_atomic_destroy_state(plane, plane->state);\n\t\tplane->state = NULL;\n\t}\n\n\tstate = kzalloc(sizeof(*state), GFP_KERNEL);\n\tif (state == NULL)\n\t\treturn;\n\n\t__drm_atomic_helper_plane_reset(plane, &state->state);\n}\n\nstatic const struct drm_plane_funcs rcar_du_vsp_plane_funcs = {\n\t.update_plane = drm_atomic_helper_update_plane,\n\t.disable_plane = drm_atomic_helper_disable_plane,\n\t.reset = rcar_du_vsp_plane_reset,\n\t.destroy = drm_plane_cleanup,\n\t.atomic_duplicate_state = rcar_du_vsp_plane_atomic_duplicate_state,\n\t.atomic_destroy_state = rcar_du_vsp_plane_atomic_destroy_state,\n};\n\nstatic void rcar_du_vsp_cleanup(struct drm_device *dev, void *res)\n{\n\tstruct rcar_du_vsp *vsp = res;\n\tunsigned int i;\n\n\tfor (i = 0; i < vsp->num_planes; ++i) {\n\t\tstruct rcar_du_vsp_plane *plane = &vsp->planes[i];\n\n\t\tdrm_plane_cleanup(&plane->plane);\n\t}\n\n\tkfree(vsp->planes);\n\n\tput_device(vsp->vsp);\n}\n\nint rcar_du_vsp_init(struct rcar_du_vsp *vsp, struct device_node *np,\n\t\t     unsigned int crtcs)\n{\n\tstruct rcar_du_device *rcdu = vsp->dev;\n\tstruct platform_device *pdev;\n\tunsigned int num_crtcs = hweight32(crtcs);\n\tunsigned int num_planes;\n\tunsigned int i;\n\tint ret;\n\n\t \n\tpdev = of_find_device_by_node(np);\n\tif (!pdev)\n\t\treturn -ENXIO;\n\n\tvsp->vsp = &pdev->dev;\n\n\tret = drmm_add_action_or_reset(&rcdu->ddev, rcar_du_vsp_cleanup, vsp);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = vsp1_du_init(vsp->vsp);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tnum_planes = rcdu->info->num_rpf;\n\n\tvsp->planes = kcalloc(num_planes, sizeof(*vsp->planes), GFP_KERNEL);\n\tif (!vsp->planes)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < num_planes; ++i) {\n\t\tenum drm_plane_type type = i < num_crtcs\n\t\t\t\t\t ? DRM_PLANE_TYPE_PRIMARY\n\t\t\t\t\t : DRM_PLANE_TYPE_OVERLAY;\n\t\tstruct rcar_du_vsp_plane *plane = &vsp->planes[i];\n\t\tunsigned int num_formats;\n\t\tconst u32 *formats;\n\n\t\tif (rcdu->info->gen < 4) {\n\t\t\tnum_formats = ARRAY_SIZE(rcar_du_vsp_formats);\n\t\t\tformats = rcar_du_vsp_formats;\n\t\t} else {\n\t\t\tnum_formats = ARRAY_SIZE(rcar_du_vsp_formats_gen4);\n\t\t\tformats = rcar_du_vsp_formats_gen4;\n\t\t}\n\n\t\tplane->vsp = vsp;\n\t\tplane->index = i;\n\n\t\tret = drm_universal_plane_init(&rcdu->ddev, &plane->plane,\n\t\t\t\t\t       crtcs, &rcar_du_vsp_plane_funcs,\n\t\t\t\t\t       formats, num_formats,\n\t\t\t\t\t       NULL, type, NULL);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tdrm_plane_helper_add(&plane->plane,\n\t\t\t\t     &rcar_du_vsp_plane_helper_funcs);\n\n\t\tdrm_plane_create_alpha_property(&plane->plane);\n\t\tdrm_plane_create_zpos_property(&plane->plane, i, 0,\n\t\t\t\t\t       num_planes - 1);\n\n\t\tdrm_plane_create_blend_mode_property(&plane->plane,\n\t\t\t\t\tBIT(DRM_MODE_BLEND_PIXEL_NONE) |\n\t\t\t\t\tBIT(DRM_MODE_BLEND_PREMULTI) |\n\t\t\t\t\tBIT(DRM_MODE_BLEND_COVERAGE));\n\n\t\tvsp->num_planes++;\n\t}\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}