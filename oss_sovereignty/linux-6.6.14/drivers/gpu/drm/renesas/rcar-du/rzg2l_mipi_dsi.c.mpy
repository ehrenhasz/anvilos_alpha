{
  "module_name": "rzg2l_mipi_dsi.c",
  "hash_id": "8a535f2b9b2444b1504eea6eadfc98151e6265f21fb4f995cf90959248304b69",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/renesas/rcar-du/rzg2l_mipi_dsi.c",
  "human_readable_source": "\n \n#include <linux/clk.h>\n#include <linux/delay.h>\n#include <linux/io.h>\n#include <linux/iopoll.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/of_graph.h>\n#include <linux/platform_device.h>\n#include <linux/pm_runtime.h>\n#include <linux/reset.h>\n#include <linux/slab.h>\n\n#include <drm/drm_atomic.h>\n#include <drm/drm_atomic_helper.h>\n#include <drm/drm_bridge.h>\n#include <drm/drm_mipi_dsi.h>\n#include <drm/drm_of.h>\n#include <drm/drm_panel.h>\n#include <drm/drm_probe_helper.h>\n\n#include \"rzg2l_mipi_dsi_regs.h\"\n\nstruct rzg2l_mipi_dsi {\n\tstruct device *dev;\n\tvoid __iomem *mmio;\n\n\tstruct reset_control *rstc;\n\tstruct reset_control *arstc;\n\tstruct reset_control *prstc;\n\n\tstruct mipi_dsi_host host;\n\tstruct drm_bridge bridge;\n\tstruct drm_bridge *next_bridge;\n\n\tstruct clk *vclk;\n\n\tenum mipi_dsi_pixel_format format;\n\tunsigned int num_data_lanes;\n\tunsigned int lanes;\n\tunsigned long mode_flags;\n};\n\nstatic inline struct rzg2l_mipi_dsi *\nbridge_to_rzg2l_mipi_dsi(struct drm_bridge *bridge)\n{\n\treturn container_of(bridge, struct rzg2l_mipi_dsi, bridge);\n}\n\nstatic inline struct rzg2l_mipi_dsi *\nhost_to_rzg2l_mipi_dsi(struct mipi_dsi_host *host)\n{\n\treturn container_of(host, struct rzg2l_mipi_dsi, host);\n}\n\nstruct rzg2l_mipi_dsi_timings {\n\tunsigned long hsfreq_max;\n\tu32 t_init;\n\tu32 tclk_prepare;\n\tu32 ths_prepare;\n\tu32 tclk_zero;\n\tu32 tclk_pre;\n\tu32 tclk_post;\n\tu32 tclk_trail;\n\tu32 ths_zero;\n\tu32 ths_trail;\n\tu32 ths_exit;\n\tu32 tlpx;\n};\n\nstatic const struct rzg2l_mipi_dsi_timings rzg2l_mipi_dsi_global_timings[] = {\n\t{\n\t\t.hsfreq_max = 80000,\n\t\t.t_init = 79801,\n\t\t.tclk_prepare = 8,\n\t\t.ths_prepare = 13,\n\t\t.tclk_zero = 33,\n\t\t.tclk_pre = 24,\n\t\t.tclk_post = 94,\n\t\t.tclk_trail = 10,\n\t\t.ths_zero = 23,\n\t\t.ths_trail = 17,\n\t\t.ths_exit = 13,\n\t\t.tlpx = 6,\n\t},\n\t{\n\t\t.hsfreq_max = 125000,\n\t\t.t_init = 79801,\n\t\t.tclk_prepare = 8,\n\t\t.ths_prepare = 12,\n\t\t.tclk_zero = 33,\n\t\t.tclk_pre = 15,\n\t\t.tclk_post = 94,\n\t\t.tclk_trail = 10,\n\t\t.ths_zero = 23,\n\t\t.ths_trail = 17,\n\t\t.ths_exit = 13,\n\t\t.tlpx = 6,\n\t},\n\t{\n\t\t.hsfreq_max = 250000,\n\t\t.t_init = 79801,\n\t\t.tclk_prepare = 8,\n\t\t.ths_prepare = 12,\n\t\t.tclk_zero = 33,\n\t\t.tclk_pre = 13,\n\t\t.tclk_post = 94,\n\t\t.tclk_trail = 10,\n\t\t.ths_zero = 23,\n\t\t.ths_trail = 16,\n\t\t.ths_exit = 13,\n\t\t.tlpx = 6,\n\t},\n\t{\n\t\t.hsfreq_max = 360000,\n\t\t.t_init = 79801,\n\t\t.tclk_prepare = 8,\n\t\t.ths_prepare = 10,\n\t\t.tclk_zero = 33,\n\t\t.tclk_pre = 4,\n\t\t.tclk_post = 35,\n\t\t.tclk_trail = 7,\n\t\t.ths_zero = 16,\n\t\t.ths_trail = 9,\n\t\t.ths_exit = 13,\n\t\t.tlpx = 6,\n\t},\n\t{\n\t\t.hsfreq_max = 720000,\n\t\t.t_init = 79801,\n\t\t.tclk_prepare = 8,\n\t\t.ths_prepare = 9,\n\t\t.tclk_zero = 33,\n\t\t.tclk_pre = 4,\n\t\t.tclk_post = 35,\n\t\t.tclk_trail = 7,\n\t\t.ths_zero = 16,\n\t\t.ths_trail = 9,\n\t\t.ths_exit = 13,\n\t\t.tlpx = 6,\n\t},\n\t{\n\t\t.hsfreq_max = 1500000,\n\t\t.t_init = 79801,\n\t\t.tclk_prepare = 8,\n\t\t.ths_prepare = 9,\n\t\t.tclk_zero = 33,\n\t\t.tclk_pre = 4,\n\t\t.tclk_post = 35,\n\t\t.tclk_trail = 7,\n\t\t.ths_zero = 16,\n\t\t.ths_trail = 9,\n\t\t.ths_exit = 13,\n\t\t.tlpx = 6,\n\t},\n};\n\nstatic void rzg2l_mipi_dsi_phy_write(struct rzg2l_mipi_dsi *dsi, u32 reg, u32 data)\n{\n\tiowrite32(data, dsi->mmio + reg);\n}\n\nstatic void rzg2l_mipi_dsi_link_write(struct rzg2l_mipi_dsi *dsi, u32 reg, u32 data)\n{\n\tiowrite32(data, dsi->mmio + LINK_REG_OFFSET + reg);\n}\n\nstatic u32 rzg2l_mipi_dsi_phy_read(struct rzg2l_mipi_dsi *dsi, u32 reg)\n{\n\treturn ioread32(dsi->mmio + reg);\n}\n\nstatic u32 rzg2l_mipi_dsi_link_read(struct rzg2l_mipi_dsi *dsi, u32 reg)\n{\n\treturn ioread32(dsi->mmio + LINK_REG_OFFSET + reg);\n}\n\n \n\nstatic int rzg2l_mipi_dsi_dphy_init(struct rzg2l_mipi_dsi *dsi,\n\t\t\t\t    unsigned long hsfreq)\n{\n\tconst struct rzg2l_mipi_dsi_timings *dphy_timings;\n\tunsigned int i;\n\tu32 dphyctrl0;\n\tu32 dphytim0;\n\tu32 dphytim1;\n\tu32 dphytim2;\n\tu32 dphytim3;\n\tint ret;\n\n\t \n\tfor (i = 0; i < ARRAY_SIZE(rzg2l_mipi_dsi_global_timings); ++i) {\n\t\tdphy_timings = &rzg2l_mipi_dsi_global_timings[i];\n\t\tif (hsfreq <= dphy_timings->hsfreq_max)\n\t\t\tbreak;\n\t}\n\n\t \n\tdphyctrl0 = DSIDPHYCTRL0_CAL_EN_HSRX_OFS | DSIDPHYCTRL0_CMN_MASTER_EN |\n\t\t    DSIDPHYCTRL0_RE_VDD_DETVCCQLV18 | DSIDPHYCTRL0_EN_BGR;\n\n\trzg2l_mipi_dsi_phy_write(dsi, DSIDPHYCTRL0, dphyctrl0);\n\tusleep_range(20, 30);\n\n\tdphyctrl0 |= DSIDPHYCTRL0_EN_LDO1200;\n\trzg2l_mipi_dsi_phy_write(dsi, DSIDPHYCTRL0, dphyctrl0);\n\tusleep_range(10, 20);\n\n\tdphytim0 = DSIDPHYTIM0_TCLK_MISS(0) |\n\t\t   DSIDPHYTIM0_T_INIT(dphy_timings->t_init);\n\tdphytim1 = DSIDPHYTIM1_THS_PREPARE(dphy_timings->ths_prepare) |\n\t\t   DSIDPHYTIM1_TCLK_PREPARE(dphy_timings->tclk_prepare) |\n\t\t   DSIDPHYTIM1_THS_SETTLE(0) |\n\t\t   DSIDPHYTIM1_TCLK_SETTLE(0);\n\tdphytim2 = DSIDPHYTIM2_TCLK_TRAIL(dphy_timings->tclk_trail) |\n\t\t   DSIDPHYTIM2_TCLK_POST(dphy_timings->tclk_post) |\n\t\t   DSIDPHYTIM2_TCLK_PRE(dphy_timings->tclk_pre) |\n\t\t   DSIDPHYTIM2_TCLK_ZERO(dphy_timings->tclk_zero);\n\tdphytim3 = DSIDPHYTIM3_TLPX(dphy_timings->tlpx) |\n\t\t   DSIDPHYTIM3_THS_EXIT(dphy_timings->ths_exit) |\n\t\t   DSIDPHYTIM3_THS_TRAIL(dphy_timings->ths_trail) |\n\t\t   DSIDPHYTIM3_THS_ZERO(dphy_timings->ths_zero);\n\n\trzg2l_mipi_dsi_phy_write(dsi, DSIDPHYTIM0, dphytim0);\n\trzg2l_mipi_dsi_phy_write(dsi, DSIDPHYTIM1, dphytim1);\n\trzg2l_mipi_dsi_phy_write(dsi, DSIDPHYTIM2, dphytim2);\n\trzg2l_mipi_dsi_phy_write(dsi, DSIDPHYTIM3, dphytim3);\n\n\tret = reset_control_deassert(dsi->rstc);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tudelay(1);\n\n\treturn 0;\n}\n\nstatic void rzg2l_mipi_dsi_dphy_exit(struct rzg2l_mipi_dsi *dsi)\n{\n\tu32 dphyctrl0;\n\n\tdphyctrl0 = rzg2l_mipi_dsi_phy_read(dsi, DSIDPHYCTRL0);\n\n\tdphyctrl0 &= ~(DSIDPHYCTRL0_EN_LDO1200 | DSIDPHYCTRL0_EN_BGR);\n\trzg2l_mipi_dsi_phy_write(dsi, DSIDPHYCTRL0, dphyctrl0);\n\n\treset_control_assert(dsi->rstc);\n}\n\nstatic int rzg2l_mipi_dsi_startup(struct rzg2l_mipi_dsi *dsi,\n\t\t\t\t  const struct drm_display_mode *mode)\n{\n\tunsigned long hsfreq;\n\tunsigned int bpp;\n\tu32 txsetr;\n\tu32 clstptsetr;\n\tu32 lptrnstsetr;\n\tu32 clkkpt;\n\tu32 clkbfht;\n\tu32 clkstpt;\n\tu32 golpbkt;\n\tint ret;\n\n\t \n\tbpp = mipi_dsi_pixel_format_to_bpp(dsi->format);\n\thsfreq = (mode->clock * bpp * 8) / (8 * dsi->lanes);\n\n\tret = pm_runtime_resume_and_get(dsi->dev);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tclk_set_rate(dsi->vclk, mode->clock * 1000);\n\n\tret = rzg2l_mipi_dsi_dphy_init(dsi, hsfreq);\n\tif (ret < 0)\n\t\tgoto err_phy;\n\n\t \n\ttxsetr = TXSETR_DLEN | TXSETR_NUMLANEUSE(dsi->lanes - 1) | TXSETR_CLEN;\n\trzg2l_mipi_dsi_link_write(dsi, TXSETR, txsetr);\n\n\t \n\tif (hsfreq > 445500) {\n\t\tclkkpt = 12;\n\t\tclkbfht = 15;\n\t\tclkstpt = 48;\n\t\tgolpbkt = 75;\n\t} else if (hsfreq > 250000) {\n\t\tclkkpt = 7;\n\t\tclkbfht = 8;\n\t\tclkstpt = 27;\n\t\tgolpbkt = 40;\n\t} else {\n\t\tclkkpt = 8;\n\t\tclkbfht = 6;\n\t\tclkstpt = 24;\n\t\tgolpbkt = 29;\n\t}\n\n\tclstptsetr = CLSTPTSETR_CLKKPT(clkkpt) | CLSTPTSETR_CLKBFHT(clkbfht) |\n\t\t     CLSTPTSETR_CLKSTPT(clkstpt);\n\trzg2l_mipi_dsi_link_write(dsi, CLSTPTSETR, clstptsetr);\n\n\tlptrnstsetr = LPTRNSTSETR_GOLPBKT(golpbkt);\n\trzg2l_mipi_dsi_link_write(dsi, LPTRNSTSETR, lptrnstsetr);\n\n\treturn 0;\n\nerr_phy:\n\trzg2l_mipi_dsi_dphy_exit(dsi);\n\tpm_runtime_put(dsi->dev);\n\n\treturn ret;\n}\n\nstatic void rzg2l_mipi_dsi_stop(struct rzg2l_mipi_dsi *dsi)\n{\n\trzg2l_mipi_dsi_dphy_exit(dsi);\n\tpm_runtime_put(dsi->dev);\n}\n\nstatic void rzg2l_mipi_dsi_set_display_timing(struct rzg2l_mipi_dsi *dsi,\n\t\t\t\t\t      const struct drm_display_mode *mode)\n{\n\tu32 vich1ppsetr;\n\tu32 vich1vssetr;\n\tu32 vich1vpsetr;\n\tu32 vich1hssetr;\n\tu32 vich1hpsetr;\n\tint dsi_format;\n\tu32 delay[2];\n\tu8 index;\n\n\t \n\tdsi_format = mipi_dsi_pixel_format_to_bpp(dsi->format);\n\tswitch (dsi_format) {\n\tcase 24:\n\t\tvich1ppsetr = VICH1PPSETR_DT_RGB24;\n\t\tbreak;\n\tcase 18:\n\t\tvich1ppsetr = VICH1PPSETR_DT_RGB18;\n\t\tbreak;\n\t}\n\n\tif ((dsi->mode_flags & MIPI_DSI_MODE_VIDEO_SYNC_PULSE) &&\n\t    !(dsi->mode_flags & MIPI_DSI_MODE_VIDEO_BURST))\n\t\tvich1ppsetr |= VICH1PPSETR_TXESYNC_PULSE;\n\n\trzg2l_mipi_dsi_link_write(dsi, VICH1PPSETR, vich1ppsetr);\n\n\t \n\tvich1vssetr = VICH1VSSETR_VACTIVE(mode->vdisplay) |\n\t\t      VICH1VSSETR_VSA(mode->vsync_end - mode->vsync_start);\n\tvich1vssetr |= (mode->flags & DRM_MODE_FLAG_PVSYNC) ?\n\t\t\tVICH1VSSETR_VSPOL_HIGH : VICH1VSSETR_VSPOL_LOW;\n\n\tvich1vpsetr = VICH1VPSETR_VFP(mode->vsync_start - mode->vdisplay) |\n\t\t      VICH1VPSETR_VBP(mode->vtotal - mode->vsync_end);\n\n\tvich1hssetr = VICH1HSSETR_HACTIVE(mode->hdisplay) |\n\t\t      VICH1HSSETR_HSA(mode->hsync_end - mode->hsync_start);\n\tvich1hssetr |= (mode->flags & DRM_MODE_FLAG_PHSYNC) ?\n\t\t\tVICH1HSSETR_HSPOL_HIGH : VICH1HSSETR_HSPOL_LOW;\n\n\tvich1hpsetr = VICH1HPSETR_HFP(mode->hsync_start - mode->hdisplay) |\n\t\t      VICH1HPSETR_HBP(mode->htotal - mode->hsync_end);\n\n\trzg2l_mipi_dsi_link_write(dsi, VICH1VSSETR, vich1vssetr);\n\trzg2l_mipi_dsi_link_write(dsi, VICH1VPSETR, vich1vpsetr);\n\trzg2l_mipi_dsi_link_write(dsi, VICH1HSSETR, vich1hssetr);\n\trzg2l_mipi_dsi_link_write(dsi, VICH1HPSETR, vich1hpsetr);\n\n\t \n\tif (mode->clock > 74250) {\n\t\tdelay[0] = 231;\n\t\tdelay[1] = 216;\n\t} else {\n\t\tdelay[0] = 220;\n\t\tdelay[1] = 212;\n\t}\n\n\tif (dsi->mode_flags & MIPI_DSI_CLOCK_NON_CONTINUOUS)\n\t\tindex = 0;\n\telse\n\t\tindex = 1;\n\n\trzg2l_mipi_dsi_link_write(dsi, VICH1SET1R,\n\t\t\t\t  VICH1SET1R_DLY(delay[index]));\n}\n\nstatic int rzg2l_mipi_dsi_start_hs_clock(struct rzg2l_mipi_dsi *dsi)\n{\n\tbool is_clk_cont;\n\tu32 hsclksetr;\n\tu32 status;\n\tint ret;\n\n\tis_clk_cont = !(dsi->mode_flags & MIPI_DSI_CLOCK_NON_CONTINUOUS);\n\n\t \n\thsclksetr = HSCLKSETR_HSCLKRUN_HS | (is_clk_cont ?\n\t\t\t\t\t     HSCLKSETR_HSCLKMODE_CONT :\n\t\t\t\t\t     HSCLKSETR_HSCLKMODE_NON_CONT);\n\trzg2l_mipi_dsi_link_write(dsi, HSCLKSETR, hsclksetr);\n\n\tif (is_clk_cont) {\n\t\tret = read_poll_timeout(rzg2l_mipi_dsi_link_read, status,\n\t\t\t\t\tstatus & PLSR_CLLP2HS,\n\t\t\t\t\t2000, 20000, false, dsi, PLSR);\n\t\tif (ret < 0) {\n\t\t\tdev_err(dsi->dev, \"failed to start HS clock\\n\");\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tdev_dbg(dsi->dev, \"Start High Speed Clock with %s clock mode\",\n\t\tis_clk_cont ? \"continuous\" : \"non-continuous\");\n\n\treturn 0;\n}\n\nstatic int rzg2l_mipi_dsi_stop_hs_clock(struct rzg2l_mipi_dsi *dsi)\n{\n\tbool is_clk_cont;\n\tu32 status;\n\tint ret;\n\n\tis_clk_cont = !(dsi->mode_flags & MIPI_DSI_CLOCK_NON_CONTINUOUS);\n\n\t \n\trzg2l_mipi_dsi_link_write(dsi, HSCLKSETR,\n\t\t\t\t  is_clk_cont ? HSCLKSETR_HSCLKMODE_CONT :\n\t\t\t\t  HSCLKSETR_HSCLKMODE_NON_CONT);\n\n\tif (is_clk_cont) {\n\t\tret = read_poll_timeout(rzg2l_mipi_dsi_link_read, status,\n\t\t\t\t\tstatus & PLSR_CLHS2LP,\n\t\t\t\t\t2000, 20000, false, dsi, PLSR);\n\t\tif (ret < 0) {\n\t\t\tdev_err(dsi->dev, \"failed to stop HS clock\\n\");\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int rzg2l_mipi_dsi_start_video(struct rzg2l_mipi_dsi *dsi)\n{\n\tu32 vich1set0r;\n\tu32 status;\n\tint ret;\n\n\t \n\tvich1set0r = VICH1SET0R_HFPNOLP | VICH1SET0R_HBPNOLP |\n\t\t     VICH1SET0R_HSANOLP | VICH1SET0R_VSTART;\n\trzg2l_mipi_dsi_link_write(dsi, VICH1SET0R, vich1set0r);\n\n\tret = read_poll_timeout(rzg2l_mipi_dsi_link_read, status,\n\t\t\t\tstatus & VICH1SR_VIRDY,\n\t\t\t\t2000, 20000, false, dsi, VICH1SR);\n\tif (ret < 0)\n\t\tdev_err(dsi->dev, \"Failed to start video signal input\\n\");\n\n\treturn ret;\n}\n\nstatic int rzg2l_mipi_dsi_stop_video(struct rzg2l_mipi_dsi *dsi)\n{\n\tu32 status;\n\tint ret;\n\n\trzg2l_mipi_dsi_link_write(dsi, VICH1SET0R, VICH1SET0R_VSTPAFT);\n\tret = read_poll_timeout(rzg2l_mipi_dsi_link_read, status,\n\t\t\t\t(status & VICH1SR_STOP) && (!(status & VICH1SR_RUNNING)),\n\t\t\t\t2000, 20000, false, dsi, VICH1SR);\n\tif (ret < 0)\n\t\tgoto err;\n\n\tret = read_poll_timeout(rzg2l_mipi_dsi_link_read, status,\n\t\t\t\t!(status & LINKSR_HSBUSY),\n\t\t\t\t2000, 20000, false, dsi, LINKSR);\n\tif (ret < 0)\n\t\tgoto err;\n\n\treturn 0;\n\nerr:\n\tdev_err(dsi->dev, \"Failed to stop video signal input\\n\");\n\treturn ret;\n}\n\n \n\nstatic int rzg2l_mipi_dsi_attach(struct drm_bridge *bridge,\n\t\t\t\t enum drm_bridge_attach_flags flags)\n{\n\tstruct rzg2l_mipi_dsi *dsi = bridge_to_rzg2l_mipi_dsi(bridge);\n\n\treturn drm_bridge_attach(bridge->encoder, dsi->next_bridge, bridge,\n\t\t\t\t flags);\n}\n\nstatic void rzg2l_mipi_dsi_atomic_enable(struct drm_bridge *bridge,\n\t\t\t\t\t struct drm_bridge_state *old_bridge_state)\n{\n\tstruct drm_atomic_state *state = old_bridge_state->base.state;\n\tstruct rzg2l_mipi_dsi *dsi = bridge_to_rzg2l_mipi_dsi(bridge);\n\tconst struct drm_display_mode *mode;\n\tstruct drm_connector *connector;\n\tstruct drm_crtc *crtc;\n\tint ret;\n\n\tconnector = drm_atomic_get_new_connector_for_encoder(state, bridge->encoder);\n\tcrtc = drm_atomic_get_new_connector_state(state, connector)->crtc;\n\tmode = &drm_atomic_get_new_crtc_state(state, crtc)->adjusted_mode;\n\n\tret = rzg2l_mipi_dsi_startup(dsi, mode);\n\tif (ret < 0)\n\t\treturn;\n\n\trzg2l_mipi_dsi_set_display_timing(dsi, mode);\n\n\tret = rzg2l_mipi_dsi_start_hs_clock(dsi);\n\tif (ret < 0)\n\t\tgoto err_stop;\n\n\tret = rzg2l_mipi_dsi_start_video(dsi);\n\tif (ret < 0)\n\t\tgoto err_stop_clock;\n\n\treturn;\n\nerr_stop_clock:\n\trzg2l_mipi_dsi_stop_hs_clock(dsi);\nerr_stop:\n\trzg2l_mipi_dsi_stop(dsi);\n}\n\nstatic void rzg2l_mipi_dsi_atomic_disable(struct drm_bridge *bridge,\n\t\t\t\t\t  struct drm_bridge_state *old_bridge_state)\n{\n\tstruct rzg2l_mipi_dsi *dsi = bridge_to_rzg2l_mipi_dsi(bridge);\n\n\trzg2l_mipi_dsi_stop_video(dsi);\n\trzg2l_mipi_dsi_stop_hs_clock(dsi);\n\trzg2l_mipi_dsi_stop(dsi);\n}\n\nstatic enum drm_mode_status\nrzg2l_mipi_dsi_bridge_mode_valid(struct drm_bridge *bridge,\n\t\t\t\t const struct drm_display_info *info,\n\t\t\t\t const struct drm_display_mode *mode)\n{\n\tif (mode->clock > 148500)\n\t\treturn MODE_CLOCK_HIGH;\n\n\treturn MODE_OK;\n}\n\nstatic const struct drm_bridge_funcs rzg2l_mipi_dsi_bridge_ops = {\n\t.attach = rzg2l_mipi_dsi_attach,\n\t.atomic_duplicate_state = drm_atomic_helper_bridge_duplicate_state,\n\t.atomic_destroy_state = drm_atomic_helper_bridge_destroy_state,\n\t.atomic_reset = drm_atomic_helper_bridge_reset,\n\t.atomic_enable = rzg2l_mipi_dsi_atomic_enable,\n\t.atomic_disable = rzg2l_mipi_dsi_atomic_disable,\n\t.mode_valid = rzg2l_mipi_dsi_bridge_mode_valid,\n};\n\n \n\nstatic int rzg2l_mipi_dsi_host_attach(struct mipi_dsi_host *host,\n\t\t\t\t      struct mipi_dsi_device *device)\n{\n\tstruct rzg2l_mipi_dsi *dsi = host_to_rzg2l_mipi_dsi(host);\n\tint ret;\n\n\tif (device->lanes > dsi->num_data_lanes) {\n\t\tdev_err(dsi->dev,\n\t\t\t\"Number of lines of device (%u) exceeds host (%u)\\n\",\n\t\t\tdevice->lanes, dsi->num_data_lanes);\n\t\treturn -EINVAL;\n\t}\n\n\tswitch (mipi_dsi_pixel_format_to_bpp(device->format)) {\n\tcase 24:\n\tcase 18:\n\t\tbreak;\n\tdefault:\n\t\tdev_err(dsi->dev, \"Unsupported format 0x%04x\\n\", device->format);\n\t\treturn -EINVAL;\n\t}\n\n\tdsi->lanes = device->lanes;\n\tdsi->format = device->format;\n\tdsi->mode_flags = device->mode_flags;\n\n\tdsi->next_bridge = devm_drm_of_get_bridge(dsi->dev, dsi->dev->of_node,\n\t\t\t\t\t\t  1, 0);\n\tif (IS_ERR(dsi->next_bridge)) {\n\t\tret = PTR_ERR(dsi->next_bridge);\n\t\tdev_err(dsi->dev, \"failed to get next bridge: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tdrm_bridge_add(&dsi->bridge);\n\n\treturn 0;\n}\n\nstatic int rzg2l_mipi_dsi_host_detach(struct mipi_dsi_host *host,\n\t\t\t\t      struct mipi_dsi_device *device)\n{\n\tstruct rzg2l_mipi_dsi *dsi = host_to_rzg2l_mipi_dsi(host);\n\n\tdrm_bridge_remove(&dsi->bridge);\n\n\treturn 0;\n}\n\nstatic const struct mipi_dsi_host_ops rzg2l_mipi_dsi_host_ops = {\n\t.attach = rzg2l_mipi_dsi_host_attach,\n\t.detach = rzg2l_mipi_dsi_host_detach,\n};\n\n \n\nstatic int __maybe_unused rzg2l_mipi_pm_runtime_suspend(struct device *dev)\n{\n\tstruct rzg2l_mipi_dsi *dsi = dev_get_drvdata(dev);\n\n\treset_control_assert(dsi->prstc);\n\treset_control_assert(dsi->arstc);\n\n\treturn 0;\n}\n\nstatic int __maybe_unused rzg2l_mipi_pm_runtime_resume(struct device *dev)\n{\n\tstruct rzg2l_mipi_dsi *dsi = dev_get_drvdata(dev);\n\tint ret;\n\n\tret = reset_control_deassert(dsi->arstc);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = reset_control_deassert(dsi->prstc);\n\tif (ret < 0)\n\t\treset_control_assert(dsi->arstc);\n\n\treturn ret;\n}\n\nstatic const struct dev_pm_ops rzg2l_mipi_pm_ops = {\n\tSET_RUNTIME_PM_OPS(rzg2l_mipi_pm_runtime_suspend, rzg2l_mipi_pm_runtime_resume, NULL)\n};\n\n \n\nstatic int rzg2l_mipi_dsi_probe(struct platform_device *pdev)\n{\n\tunsigned int num_data_lanes;\n\tstruct rzg2l_mipi_dsi *dsi;\n\tu32 txsetr;\n\tint ret;\n\n\tdsi = devm_kzalloc(&pdev->dev, sizeof(*dsi), GFP_KERNEL);\n\tif (!dsi)\n\t\treturn -ENOMEM;\n\n\tplatform_set_drvdata(pdev, dsi);\n\tdsi->dev = &pdev->dev;\n\n\tret = drm_of_get_data_lanes_count_ep(dsi->dev->of_node, 1, 0, 1, 4);\n\tif (ret < 0)\n\t\treturn dev_err_probe(dsi->dev, ret,\n\t\t\t\t     \"missing or invalid data-lanes property\\n\");\n\n\tnum_data_lanes = ret;\n\n\tdsi->mmio = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(dsi->mmio))\n\t\treturn PTR_ERR(dsi->mmio);\n\n\tdsi->vclk = devm_clk_get(dsi->dev, \"vclk\");\n\tif (IS_ERR(dsi->vclk))\n\t\treturn PTR_ERR(dsi->vclk);\n\n\tdsi->rstc = devm_reset_control_get_exclusive(dsi->dev, \"rst\");\n\tif (IS_ERR(dsi->rstc))\n\t\treturn dev_err_probe(dsi->dev, PTR_ERR(dsi->rstc),\n\t\t\t\t     \"failed to get rst\\n\");\n\n\tdsi->arstc = devm_reset_control_get_exclusive(dsi->dev, \"arst\");\n\tif (IS_ERR(dsi->arstc))\n\t\treturn dev_err_probe(&pdev->dev, PTR_ERR(dsi->arstc),\n\t\t\t\t     \"failed to get arst\\n\");\n\n\tdsi->prstc = devm_reset_control_get_exclusive(dsi->dev, \"prst\");\n\tif (IS_ERR(dsi->prstc))\n\t\treturn dev_err_probe(dsi->dev, PTR_ERR(dsi->prstc),\n\t\t\t\t     \"failed to get prst\\n\");\n\n\tplatform_set_drvdata(pdev, dsi);\n\n\tpm_runtime_enable(dsi->dev);\n\n\tret = pm_runtime_resume_and_get(dsi->dev);\n\tif (ret < 0)\n\t\tgoto err_pm_disable;\n\n\t \n\tret = rzg2l_mipi_dsi_dphy_init(dsi, 80000);\n\tif (ret < 0)\n\t\tgoto err_phy;\n\n\ttxsetr = rzg2l_mipi_dsi_link_read(dsi, TXSETR);\n\tdsi->num_data_lanes = min(((txsetr >> 16) & 3) + 1, num_data_lanes);\n\trzg2l_mipi_dsi_dphy_exit(dsi);\n\tpm_runtime_put(dsi->dev);\n\n\t \n\tdsi->bridge.funcs = &rzg2l_mipi_dsi_bridge_ops;\n\tdsi->bridge.of_node = dsi->dev->of_node;\n\n\t \n\tdsi->host.dev = dsi->dev;\n\tdsi->host.ops = &rzg2l_mipi_dsi_host_ops;\n\tret = mipi_dsi_host_register(&dsi->host);\n\tif (ret < 0)\n\t\tgoto err_pm_disable;\n\n\treturn 0;\n\nerr_phy:\n\trzg2l_mipi_dsi_dphy_exit(dsi);\n\tpm_runtime_put(dsi->dev);\nerr_pm_disable:\n\tpm_runtime_disable(dsi->dev);\n\treturn ret;\n}\n\nstatic void rzg2l_mipi_dsi_remove(struct platform_device *pdev)\n{\n\tstruct rzg2l_mipi_dsi *dsi = platform_get_drvdata(pdev);\n\n\tmipi_dsi_host_unregister(&dsi->host);\n\tpm_runtime_disable(&pdev->dev);\n}\n\nstatic const struct of_device_id rzg2l_mipi_dsi_of_table[] = {\n\t{ .compatible = \"renesas,rzg2l-mipi-dsi\" },\n\t{   }\n};\n\nMODULE_DEVICE_TABLE(of, rzg2l_mipi_dsi_of_table);\n\nstatic struct platform_driver rzg2l_mipi_dsi_platform_driver = {\n\t.probe\t= rzg2l_mipi_dsi_probe,\n\t.remove_new = rzg2l_mipi_dsi_remove,\n\t.driver\t= {\n\t\t.name = \"rzg2l-mipi-dsi\",\n\t\t.pm = &rzg2l_mipi_pm_ops,\n\t\t.of_match_table = rzg2l_mipi_dsi_of_table,\n\t},\n};\n\nmodule_platform_driver(rzg2l_mipi_dsi_platform_driver);\n\nMODULE_AUTHOR(\"Biju Das <biju.das.jz@bp.renesas.com>\");\nMODULE_DESCRIPTION(\"Renesas RZ/G2L MIPI DSI Encoder Driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}