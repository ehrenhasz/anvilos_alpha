{
  "module_name": "rcar_du_plane.c",
  "hash_id": "d6863a35ec9be21a96dd118ee2507229fca94f352ede0929f0d9d41f66a5d437",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/renesas/rcar-du/rcar_du_plane.c",
  "human_readable_source": "\n \n\n#include <drm/drm_atomic.h>\n#include <drm/drm_atomic_helper.h>\n#include <drm/drm_blend.h>\n#include <drm/drm_crtc.h>\n#include <drm/drm_device.h>\n#include <drm/drm_fb_dma_helper.h>\n#include <drm/drm_fourcc.h>\n#include <drm/drm_framebuffer.h>\n#include <drm/drm_gem_dma_helper.h>\n\n#include \"rcar_du_drv.h\"\n#include \"rcar_du_group.h\"\n#include \"rcar_du_kms.h\"\n#include \"rcar_du_plane.h\"\n#include \"rcar_du_regs.h\"\n\n \n\nstatic bool rcar_du_plane_needs_realloc(\n\t\t\t\tconst struct rcar_du_plane_state *old_state,\n\t\t\t\tconst struct rcar_du_plane_state *new_state)\n{\n\t \n\tif (!old_state->format ||\n\t    old_state->format->planes != new_state->format->planes)\n\t\treturn true;\n\n\t \n\tif (old_state->source != new_state->source)\n\t\treturn true;\n\n\treturn false;\n}\n\nstatic unsigned int rcar_du_plane_hwmask(struct rcar_du_plane_state *state)\n{\n\tunsigned int mask;\n\n\tif (state->hwindex == -1)\n\t\treturn 0;\n\n\tmask = 1 << state->hwindex;\n\tif (state->format->planes == 2)\n\t\tmask |= 1 << ((state->hwindex + 1) % 8);\n\n\treturn mask;\n}\n\n \nstatic int rcar_du_plane_hwalloc(struct rcar_du_plane *plane,\n\t\t\t\t struct rcar_du_plane_state *state,\n\t\t\t\t unsigned int free)\n{\n\tunsigned int num_planes = state->format->planes;\n\tint fixed = -1;\n\tint i;\n\n\tif (state->source == RCAR_DU_PLANE_VSPD0) {\n\t\t \n\t\tif (plane->group->index != 0)\n\t\t\treturn -EINVAL;\n\n\t\tfixed = 0;\n\t} else if (state->source == RCAR_DU_PLANE_VSPD1) {\n\t\t \n\t\tfixed = plane->group->index == 0 ? 1 : 0;\n\t}\n\n\tif (fixed >= 0)\n\t\treturn free & (1 << fixed) ? fixed : -EBUSY;\n\n\tfor (i = RCAR_DU_NUM_HW_PLANES - 1; i >= 0; --i) {\n\t\tif (!(free & (1 << i)))\n\t\t\tcontinue;\n\n\t\tif (num_planes == 1 || free & (1 << ((i + 1) % 8)))\n\t\t\tbreak;\n\t}\n\n\treturn i < 0 ? -EBUSY : i;\n}\n\nint rcar_du_atomic_check_planes(struct drm_device *dev,\n\t\t\t\tstruct drm_atomic_state *state)\n{\n\tstruct rcar_du_device *rcdu = to_rcar_du_device(dev);\n\tunsigned int group_freed_planes[RCAR_DU_MAX_GROUPS] = { 0, };\n\tunsigned int group_free_planes[RCAR_DU_MAX_GROUPS] = { 0, };\n\tbool needs_realloc = false;\n\tunsigned int groups = 0;\n\tunsigned int i;\n\tstruct drm_plane *drm_plane;\n\tstruct drm_plane_state *old_drm_plane_state;\n\tstruct drm_plane_state *new_drm_plane_state;\n\n\t \n\tfor_each_oldnew_plane_in_state(state, drm_plane, old_drm_plane_state,\n\t\t\t\t       new_drm_plane_state, i) {\n\t\tstruct rcar_du_plane_state *old_plane_state;\n\t\tstruct rcar_du_plane_state *new_plane_state;\n\t\tstruct rcar_du_plane *plane;\n\t\tunsigned int index;\n\n\t\tplane = to_rcar_plane(drm_plane);\n\t\told_plane_state = to_rcar_plane_state(old_drm_plane_state);\n\t\tnew_plane_state = to_rcar_plane_state(new_drm_plane_state);\n\n\t\tdev_dbg(rcdu->dev, \"%s: checking plane (%u,%tu)\\n\", __func__,\n\t\t\tplane->group->index, plane - plane->group->planes);\n\n\t\t \n\t\tif (!new_plane_state->format) {\n\t\t\tdev_dbg(rcdu->dev, \"%s: plane is being disabled\\n\",\n\t\t\t\t__func__);\n\t\t\tindex = plane - plane->group->planes;\n\t\t\tgroup_freed_planes[plane->group->index] |= 1 << index;\n\t\t\tnew_plane_state->hwindex = -1;\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\tif (rcar_du_plane_needs_realloc(old_plane_state, new_plane_state)) {\n\t\t\tdev_dbg(rcdu->dev, \"%s: plane needs reallocation\\n\",\n\t\t\t\t__func__);\n\t\t\tgroups |= 1 << plane->group->index;\n\t\t\tneeds_realloc = true;\n\n\t\t\tindex = plane - plane->group->planes;\n\t\t\tgroup_freed_planes[plane->group->index] |= 1 << index;\n\t\t\tnew_plane_state->hwindex = -1;\n\t\t}\n\t}\n\n\tif (!needs_realloc)\n\t\treturn 0;\n\n\t \n\twhile (groups) {\n\t\tunsigned int index = ffs(groups) - 1;\n\t\tstruct rcar_du_group *group = &rcdu->groups[index];\n\t\tunsigned int used_planes = 0;\n\n\t\tdev_dbg(rcdu->dev, \"%s: finding free planes for group %u\\n\",\n\t\t\t__func__, index);\n\n\t\tfor (i = 0; i < group->num_planes; ++i) {\n\t\t\tstruct rcar_du_plane *plane = &group->planes[i];\n\t\t\tstruct rcar_du_plane_state *new_plane_state;\n\t\t\tstruct drm_plane_state *s;\n\n\t\t\ts = drm_atomic_get_plane_state(state, &plane->plane);\n\t\t\tif (IS_ERR(s))\n\t\t\t\treturn PTR_ERR(s);\n\n\t\t\t \n\t\t\tif (group_freed_planes[index] & (1 << i)) {\n\t\t\t\tdev_dbg(rcdu->dev,\n\t\t\t\t\t\"%s: plane (%u,%tu) has been freed, skipping\\n\",\n\t\t\t\t\t__func__, plane->group->index,\n\t\t\t\t\tplane - plane->group->planes);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tnew_plane_state = to_rcar_plane_state(s);\n\t\t\tused_planes |= rcar_du_plane_hwmask(new_plane_state);\n\n\t\t\tdev_dbg(rcdu->dev,\n\t\t\t\t\"%s: plane (%u,%tu) uses %u hwplanes (index %d)\\n\",\n\t\t\t\t__func__, plane->group->index,\n\t\t\t\tplane - plane->group->planes,\n\t\t\t\tnew_plane_state->format ?\n\t\t\t\tnew_plane_state->format->planes : 0,\n\t\t\t\tnew_plane_state->hwindex);\n\t\t}\n\n\t\tgroup_free_planes[index] = 0xff & ~used_planes;\n\t\tgroups &= ~(1 << index);\n\n\t\tdev_dbg(rcdu->dev, \"%s: group %u free planes mask 0x%02x\\n\",\n\t\t\t__func__, index, group_free_planes[index]);\n\t}\n\n\t \n\tfor_each_oldnew_plane_in_state(state, drm_plane, old_drm_plane_state,\n\t\t\t\t       new_drm_plane_state, i) {\n\t\tstruct rcar_du_plane_state *old_plane_state;\n\t\tstruct rcar_du_plane_state *new_plane_state;\n\t\tstruct rcar_du_plane *plane;\n\t\tunsigned int crtc_planes;\n\t\tunsigned int free;\n\t\tint idx;\n\n\t\tplane = to_rcar_plane(drm_plane);\n\t\told_plane_state = to_rcar_plane_state(old_drm_plane_state);\n\t\tnew_plane_state = to_rcar_plane_state(new_drm_plane_state);\n\n\t\tdev_dbg(rcdu->dev, \"%s: allocating plane (%u,%tu)\\n\", __func__,\n\t\t\tplane->group->index, plane - plane->group->planes);\n\n\t\t \n\t\tif (!new_plane_state->format ||\n\t\t    !rcar_du_plane_needs_realloc(old_plane_state, new_plane_state))\n\t\t\tcontinue;\n\n\t\t \n\t\tcrtc_planes = to_rcar_crtc(new_plane_state->state.crtc)->index % 2\n\t\t\t    ? plane->group->dptsr_planes\n\t\t\t    : ~plane->group->dptsr_planes;\n\t\tfree = group_free_planes[plane->group->index];\n\n\t\tidx = rcar_du_plane_hwalloc(plane, new_plane_state,\n\t\t\t\t\t    free & crtc_planes);\n\t\tif (idx < 0)\n\t\t\tidx = rcar_du_plane_hwalloc(plane, new_plane_state,\n\t\t\t\t\t\t    free);\n\t\tif (idx < 0) {\n\t\t\tdev_dbg(rcdu->dev, \"%s: no available hardware plane\\n\",\n\t\t\t\t__func__);\n\t\t\treturn idx;\n\t\t}\n\n\t\tdev_dbg(rcdu->dev, \"%s: allocated %u hwplanes (index %u)\\n\",\n\t\t\t__func__, new_plane_state->format->planes, idx);\n\n\t\tnew_plane_state->hwindex = idx;\n\n\t\tgroup_free_planes[plane->group->index] &=\n\t\t\t~rcar_du_plane_hwmask(new_plane_state);\n\n\t\tdev_dbg(rcdu->dev, \"%s: group %u free planes mask 0x%02x\\n\",\n\t\t\t__func__, plane->group->index,\n\t\t\tgroup_free_planes[plane->group->index]);\n\t}\n\n\treturn 0;\n}\n\n \n\n#define RCAR_DU_COLORKEY_NONE\t\t(0 << 24)\n#define RCAR_DU_COLORKEY_SOURCE\t\t(1 << 24)\n#define RCAR_DU_COLORKEY_MASK\t\t(1 << 24)\n\nstatic void rcar_du_plane_write(struct rcar_du_group *rgrp,\n\t\t\t\tunsigned int index, u32 reg, u32 data)\n{\n\trcar_du_write(rgrp->dev, rgrp->mmio_offset + index * PLANE_OFF + reg,\n\t\t      data);\n}\n\nstatic void rcar_du_plane_setup_scanout(struct rcar_du_group *rgrp,\n\t\t\t\t\tconst struct rcar_du_plane_state *state)\n{\n\tunsigned int src_x = state->state.src.x1 >> 16;\n\tunsigned int src_y = state->state.src.y1 >> 16;\n\tunsigned int index = state->hwindex;\n\tunsigned int pitch;\n\tbool interlaced;\n\tu32 dma[2];\n\n\tinterlaced = state->state.crtc->state->adjusted_mode.flags\n\t\t   & DRM_MODE_FLAG_INTERLACE;\n\n\tif (state->source == RCAR_DU_PLANE_MEMORY) {\n\t\tstruct drm_framebuffer *fb = state->state.fb;\n\t\tstruct drm_gem_dma_object *gem;\n\t\tunsigned int i;\n\n\t\tif (state->format->planes == 2)\n\t\t\tpitch = fb->pitches[0];\n\t\telse\n\t\t\tpitch = fb->pitches[0] * 8 / state->format->bpp;\n\n\t\tfor (i = 0; i < state->format->planes; ++i) {\n\t\t\tgem = drm_fb_dma_get_gem_obj(fb, i);\n\t\t\tdma[i] = gem->dma_addr + fb->offsets[i];\n\t\t}\n\t} else {\n\t\tpitch = drm_rect_width(&state->state.src) >> 16;\n\t\tdma[0] = 0;\n\t\tdma[1] = 0;\n\t}\n\n\t \n\trcar_du_plane_write(rgrp, index, PnMWR,\n\t\t\t    (interlaced && state->format->bpp == 32) ?\n\t\t\t    pitch * 2 : pitch);\n\n\t \n\trcar_du_plane_write(rgrp, index, PnSPXR, src_x);\n\trcar_du_plane_write(rgrp, index, PnSPYR, src_y *\n\t\t\t    (!interlaced && state->format->bpp == 32 ? 2 : 1));\n\n\trcar_du_plane_write(rgrp, index, PnDSA0R, dma[0]);\n\n\tif (state->format->planes == 2) {\n\t\tindex = (index + 1) % 8;\n\n\t\trcar_du_plane_write(rgrp, index, PnMWR, pitch);\n\n\t\trcar_du_plane_write(rgrp, index, PnSPXR, src_x);\n\t\trcar_du_plane_write(rgrp, index, PnSPYR, src_y *\n\t\t\t\t    (state->format->bpp == 16 ? 2 : 1) / 2);\n\n\t\trcar_du_plane_write(rgrp, index, PnDSA0R, dma[1]);\n\t}\n}\n\nstatic void rcar_du_plane_setup_mode(struct rcar_du_group *rgrp,\n\t\t\t\t     unsigned int index,\n\t\t\t\t     const struct rcar_du_plane_state *state)\n{\n\tu32 colorkey;\n\tu32 pnmr;\n\n\t \n\tif (state->format->fourcc != DRM_FORMAT_XRGB1555)\n\t\trcar_du_plane_write(rgrp, index, PnALPHAR, PnALPHAR_ABIT_0);\n\telse\n\t\trcar_du_plane_write(rgrp, index, PnALPHAR,\n\t\t\t\t    PnALPHAR_ABIT_X | state->state.alpha >> 8);\n\n\tpnmr = PnMR_BM_MD | state->format->pnmr;\n\n\t \n\tif ((state->colorkey & RCAR_DU_COLORKEY_MASK) == RCAR_DU_COLORKEY_NONE)\n\t\tpnmr |= PnMR_SPIM_TP_OFF;\n\n\t \n\tif (state->format->fourcc == DRM_FORMAT_YUYV)\n\t\tpnmr |= PnMR_YCDF_YUYV;\n\n\trcar_du_plane_write(rgrp, index, PnMR, pnmr);\n\n\tswitch (state->format->fourcc) {\n\tcase DRM_FORMAT_RGB565:\n\t\tcolorkey = ((state->colorkey & 0xf80000) >> 8)\n\t\t\t | ((state->colorkey & 0x00fc00) >> 5)\n\t\t\t | ((state->colorkey & 0x0000f8) >> 3);\n\t\trcar_du_plane_write(rgrp, index, PnTC2R, colorkey);\n\t\tbreak;\n\n\tcase DRM_FORMAT_ARGB1555:\n\tcase DRM_FORMAT_XRGB1555:\n\t\tcolorkey = ((state->colorkey & 0xf80000) >> 9)\n\t\t\t | ((state->colorkey & 0x00f800) >> 6)\n\t\t\t | ((state->colorkey & 0x0000f8) >> 3);\n\t\trcar_du_plane_write(rgrp, index, PnTC2R, colorkey);\n\t\tbreak;\n\n\tcase DRM_FORMAT_XRGB8888:\n\tcase DRM_FORMAT_ARGB8888:\n\t\trcar_du_plane_write(rgrp, index, PnTC3R,\n\t\t\t\t    PnTC3R_CODE | (state->colorkey & 0xffffff));\n\t\tbreak;\n\t}\n}\n\nstatic void rcar_du_plane_setup_format_gen2(struct rcar_du_group *rgrp,\n\t\t\t\t\t    unsigned int index,\n\t\t\t\t\t    const struct rcar_du_plane_state *state)\n{\n\tu32 ddcr2 = PnDDCR2_CODE;\n\tu32 ddcr4;\n\n\t \n\n\trcar_du_plane_setup_mode(rgrp, index, state);\n\n\tif (state->format->planes == 2) {\n\t\tif (state->hwindex != index) {\n\t\t\tif (state->format->fourcc == DRM_FORMAT_NV12 ||\n\t\t\t    state->format->fourcc == DRM_FORMAT_NV21)\n\t\t\t\tddcr2 |= PnDDCR2_Y420;\n\n\t\t\tif (state->format->fourcc == DRM_FORMAT_NV21)\n\t\t\t\tddcr2 |= PnDDCR2_NV21;\n\n\t\t\tddcr2 |= PnDDCR2_DIVU;\n\t\t} else {\n\t\t\tddcr2 |= PnDDCR2_DIVY;\n\t\t}\n\t}\n\n\trcar_du_plane_write(rgrp, index, PnDDCR2, ddcr2);\n\n\tddcr4 = state->format->edf | PnDDCR4_CODE;\n\tif (state->source != RCAR_DU_PLANE_MEMORY)\n\t\tddcr4 |= PnDDCR4_VSPS;\n\n\trcar_du_plane_write(rgrp, index, PnDDCR4, ddcr4);\n}\n\nstatic void rcar_du_plane_setup_format_gen3(struct rcar_du_group *rgrp,\n\t\t\t\t\t    unsigned int index,\n\t\t\t\t\t    const struct rcar_du_plane_state *state)\n{\n\tstruct rcar_du_device *rcdu = rgrp->dev;\n\tu32 pnmr = state->format->pnmr | PnMR_SPIM_TP_OFF;\n\n\tif (rcdu->info->features & RCAR_DU_FEATURE_NO_BLENDING) {\n\t\t \n\t\tpnmr &= ~(PnMR_SPIM_ALP | PnMR_SPIM_EOR);\n\t}\n\n\trcar_du_plane_write(rgrp, index, PnMR, pnmr);\n\n\trcar_du_plane_write(rgrp, index, PnDDCR4,\n\t\t\t    state->format->edf | PnDDCR4_CODE);\n\n\t \n\n\trcar_du_plane_write(rgrp, index, PnALPHAR, 0);\n}\n\nstatic void rcar_du_plane_setup_format(struct rcar_du_group *rgrp,\n\t\t\t\t       unsigned int index,\n\t\t\t\t       const struct rcar_du_plane_state *state)\n{\n\tstruct rcar_du_device *rcdu = rgrp->dev;\n\tconst struct drm_rect *dst = &state->state.dst;\n\n\tif (rcdu->info->gen < 3)\n\t\trcar_du_plane_setup_format_gen2(rgrp, index, state);\n\telse\n\t\trcar_du_plane_setup_format_gen3(rgrp, index, state);\n\n\t \n\trcar_du_plane_write(rgrp, index, PnDSXR, drm_rect_width(dst));\n\trcar_du_plane_write(rgrp, index, PnDSYR, drm_rect_height(dst));\n\trcar_du_plane_write(rgrp, index, PnDPXR, dst->x1);\n\trcar_du_plane_write(rgrp, index, PnDPYR, dst->y1);\n\n\tif (rcdu->info->gen < 3) {\n\t\t \n\t\trcar_du_plane_write(rgrp, index, PnWASPR, 0);\n\t\trcar_du_plane_write(rgrp, index, PnWAMWR, 4095);\n\t\trcar_du_plane_write(rgrp, index, PnBTR, 0);\n\t\trcar_du_plane_write(rgrp, index, PnMLR, 0);\n\t}\n}\n\nvoid __rcar_du_plane_setup(struct rcar_du_group *rgrp,\n\t\t\t   const struct rcar_du_plane_state *state)\n{\n\tstruct rcar_du_device *rcdu = rgrp->dev;\n\n\trcar_du_plane_setup_format(rgrp, state->hwindex, state);\n\tif (state->format->planes == 2)\n\t\trcar_du_plane_setup_format(rgrp, (state->hwindex + 1) % 8,\n\t\t\t\t\t   state);\n\n\tif (rcdu->info->gen >= 3)\n\t\treturn;\n\n\trcar_du_plane_setup_scanout(rgrp, state);\n\n\tif (state->source == RCAR_DU_PLANE_VSPD1) {\n\t\tunsigned int vspd1_sink = rgrp->index ? 2 : 0;\n\n\t\tif (rcdu->vspd1_sink != vspd1_sink) {\n\t\t\trcdu->vspd1_sink = vspd1_sink;\n\t\t\trcar_du_set_dpad0_vsp1_routing(rcdu);\n\n\t\t\t \n\t\t\trgrp->need_restart = true;\n\t\t}\n\t}\n}\n\nint __rcar_du_plane_atomic_check(struct drm_plane *plane,\n\t\t\t\t struct drm_plane_state *state,\n\t\t\t\t const struct rcar_du_format_info **format)\n{\n\tstruct drm_device *dev = plane->dev;\n\tstruct drm_crtc_state *crtc_state;\n\tint ret;\n\n\tif (!state->crtc) {\n\t\t \n\t\tstate->visible = false;\n\t\t*format = NULL;\n\t\treturn 0;\n\t}\n\n\tcrtc_state = drm_atomic_get_crtc_state(state->state, state->crtc);\n\tif (IS_ERR(crtc_state))\n\t\treturn PTR_ERR(crtc_state);\n\n\tret = drm_atomic_helper_check_plane_state(state, crtc_state,\n\t\t\t\t\t\t  DRM_PLANE_NO_SCALING,\n\t\t\t\t\t\t  DRM_PLANE_NO_SCALING,\n\t\t\t\t\t\t  true, true);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (!state->visible) {\n\t\t*format = NULL;\n\t\treturn 0;\n\t}\n\n\t*format = rcar_du_format_info(state->fb->format->format);\n\tif (*format == NULL) {\n\t\tdev_dbg(dev->dev, \"%s: unsupported format %p4cc\\n\", __func__,\n\t\t\t&state->fb->format->format);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int rcar_du_plane_atomic_check(struct drm_plane *plane,\n\t\t\t\t      struct drm_atomic_state *state)\n{\n\tstruct drm_plane_state *new_plane_state = drm_atomic_get_new_plane_state(state,\n\t\t\t\t\t\t\t\t\t\t plane);\n\tstruct rcar_du_plane_state *rstate = to_rcar_plane_state(new_plane_state);\n\n\treturn __rcar_du_plane_atomic_check(plane, new_plane_state,\n\t\t\t\t\t    &rstate->format);\n}\n\nstatic void rcar_du_plane_atomic_update(struct drm_plane *plane,\n\t\t\t\t\tstruct drm_atomic_state *state)\n{\n\tstruct drm_plane_state *old_state = drm_atomic_get_old_plane_state(state, plane);\n\tstruct drm_plane_state *new_state = drm_atomic_get_new_plane_state(state, plane);\n\tstruct rcar_du_plane *rplane = to_rcar_plane(plane);\n\tstruct rcar_du_plane_state *old_rstate;\n\tstruct rcar_du_plane_state *new_rstate;\n\n\tif (!new_state->visible)\n\t\treturn;\n\n\trcar_du_plane_setup(rplane);\n\n\t \n\told_rstate = to_rcar_plane_state(old_state);\n\tnew_rstate = to_rcar_plane_state(new_state);\n\n\tif ((old_rstate->source == RCAR_DU_PLANE_MEMORY) !=\n\t    (new_rstate->source == RCAR_DU_PLANE_MEMORY))\n\t\trplane->group->need_restart = true;\n}\n\nstatic const struct drm_plane_helper_funcs rcar_du_plane_helper_funcs = {\n\t.atomic_check = rcar_du_plane_atomic_check,\n\t.atomic_update = rcar_du_plane_atomic_update,\n};\n\nstatic struct drm_plane_state *\nrcar_du_plane_atomic_duplicate_state(struct drm_plane *plane)\n{\n\tstruct rcar_du_plane_state *state;\n\tstruct rcar_du_plane_state *copy;\n\n\tif (WARN_ON(!plane->state))\n\t\treturn NULL;\n\n\tstate = to_rcar_plane_state(plane->state);\n\tcopy = kmemdup(state, sizeof(*state), GFP_KERNEL);\n\tif (copy == NULL)\n\t\treturn NULL;\n\n\t__drm_atomic_helper_plane_duplicate_state(plane, &copy->state);\n\n\treturn &copy->state;\n}\n\nstatic void rcar_du_plane_atomic_destroy_state(struct drm_plane *plane,\n\t\t\t\t\t       struct drm_plane_state *state)\n{\n\t__drm_atomic_helper_plane_destroy_state(state);\n\tkfree(to_rcar_plane_state(state));\n}\n\nstatic void rcar_du_plane_reset(struct drm_plane *plane)\n{\n\tstruct rcar_du_plane_state *state;\n\n\tif (plane->state) {\n\t\trcar_du_plane_atomic_destroy_state(plane, plane->state);\n\t\tplane->state = NULL;\n\t}\n\n\tstate = kzalloc(sizeof(*state), GFP_KERNEL);\n\tif (state == NULL)\n\t\treturn;\n\n\t__drm_atomic_helper_plane_reset(plane, &state->state);\n\n\tstate->hwindex = -1;\n\tstate->source = RCAR_DU_PLANE_MEMORY;\n\tstate->colorkey = RCAR_DU_COLORKEY_NONE;\n}\n\nstatic int rcar_du_plane_atomic_set_property(struct drm_plane *plane,\n\t\t\t\t\t     struct drm_plane_state *state,\n\t\t\t\t\t     struct drm_property *property,\n\t\t\t\t\t     uint64_t val)\n{\n\tstruct rcar_du_plane_state *rstate = to_rcar_plane_state(state);\n\tstruct rcar_du_device *rcdu = to_rcar_plane(plane)->group->dev;\n\n\tif (property == rcdu->props.colorkey)\n\t\trstate->colorkey = val;\n\telse\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nstatic int rcar_du_plane_atomic_get_property(struct drm_plane *plane,\n\tconst struct drm_plane_state *state, struct drm_property *property,\n\tuint64_t *val)\n{\n\tconst struct rcar_du_plane_state *rstate =\n\t\tcontainer_of(state, const struct rcar_du_plane_state, state);\n\tstruct rcar_du_device *rcdu = to_rcar_plane(plane)->group->dev;\n\n\tif (property == rcdu->props.colorkey)\n\t\t*val = rstate->colorkey;\n\telse\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nstatic const struct drm_plane_funcs rcar_du_plane_funcs = {\n\t.update_plane = drm_atomic_helper_update_plane,\n\t.disable_plane = drm_atomic_helper_disable_plane,\n\t.reset = rcar_du_plane_reset,\n\t.destroy = drm_plane_cleanup,\n\t.atomic_duplicate_state = rcar_du_plane_atomic_duplicate_state,\n\t.atomic_destroy_state = rcar_du_plane_atomic_destroy_state,\n\t.atomic_set_property = rcar_du_plane_atomic_set_property,\n\t.atomic_get_property = rcar_du_plane_atomic_get_property,\n};\n\nstatic const uint32_t formats[] = {\n\tDRM_FORMAT_RGB565,\n\tDRM_FORMAT_ARGB1555,\n\tDRM_FORMAT_XRGB1555,\n\tDRM_FORMAT_XRGB8888,\n\tDRM_FORMAT_ARGB8888,\n\tDRM_FORMAT_UYVY,\n\tDRM_FORMAT_YUYV,\n\tDRM_FORMAT_NV12,\n\tDRM_FORMAT_NV21,\n\tDRM_FORMAT_NV16,\n};\n\nint rcar_du_planes_init(struct rcar_du_group *rgrp)\n{\n\tstruct rcar_du_device *rcdu = rgrp->dev;\n\tunsigned int crtcs;\n\tunsigned int i;\n\tint ret;\n\n\t  \n\trgrp->num_planes = rgrp->num_crtcs + 7;\n\n\tcrtcs = ((1 << rcdu->num_crtcs) - 1) & (3 << (2 * rgrp->index));\n\n\tfor (i = 0; i < rgrp->num_planes; ++i) {\n\t\tenum drm_plane_type type = i < rgrp->num_crtcs\n\t\t\t\t\t ? DRM_PLANE_TYPE_PRIMARY\n\t\t\t\t\t : DRM_PLANE_TYPE_OVERLAY;\n\t\tstruct rcar_du_plane *plane = &rgrp->planes[i];\n\n\t\tplane->group = rgrp;\n\n\t\tret = drm_universal_plane_init(&rcdu->ddev, &plane->plane,\n\t\t\t\t\t       crtcs, &rcar_du_plane_funcs,\n\t\t\t\t\t       formats, ARRAY_SIZE(formats),\n\t\t\t\t\t       NULL, type, NULL);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tdrm_plane_helper_add(&plane->plane,\n\t\t\t\t     &rcar_du_plane_helper_funcs);\n\n\t\tdrm_plane_create_alpha_property(&plane->plane);\n\n\t\tif (type == DRM_PLANE_TYPE_PRIMARY) {\n\t\t\tdrm_plane_create_zpos_immutable_property(&plane->plane,\n\t\t\t\t\t\t\t\t 0);\n\t\t} else {\n\t\t\tdrm_object_attach_property(&plane->plane.base,\n\t\t\t\t\t\t   rcdu->props.colorkey,\n\t\t\t\t\t\t   RCAR_DU_COLORKEY_NONE);\n\t\t\tdrm_plane_create_zpos_property(&plane->plane, 1, 1, 7);\n\t\t}\n\t}\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}