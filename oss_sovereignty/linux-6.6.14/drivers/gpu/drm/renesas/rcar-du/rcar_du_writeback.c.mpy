{
  "module_name": "rcar_du_writeback.c",
  "hash_id": "94a439c4cd922ba5b603e5d6969077d41d90700df4eb2b9be7e78e31edf61bce",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/renesas/rcar-du/rcar_du_writeback.c",
  "human_readable_source": "\n \n\n#include <drm/drm_atomic_helper.h>\n#include <drm/drm_device.h>\n#include <drm/drm_edid.h>\n#include <drm/drm_fourcc.h>\n#include <drm/drm_framebuffer.h>\n#include <drm/drm_probe_helper.h>\n#include <drm/drm_writeback.h>\n\n#include \"rcar_du_crtc.h\"\n#include \"rcar_du_drv.h\"\n#include \"rcar_du_kms.h\"\n#include \"rcar_du_writeback.h\"\n\n \nstruct rcar_du_wb_conn_state {\n\tstruct drm_connector_state state;\n\tconst struct rcar_du_format_info *format;\n};\n\n#define to_rcar_wb_conn_state(s) \\\n\tcontainer_of(s, struct rcar_du_wb_conn_state, state)\n\n \nstruct rcar_du_wb_job {\n\tstruct sg_table sg_tables[3];\n};\n\nstatic int rcar_du_wb_conn_get_modes(struct drm_connector *connector)\n{\n\tstruct drm_device *dev = connector->dev;\n\n\treturn drm_add_modes_noedid(connector, dev->mode_config.max_width,\n\t\t\t\t    dev->mode_config.max_height);\n}\n\nstatic int rcar_du_wb_prepare_job(struct drm_writeback_connector *connector,\n\t\t\t\t  struct drm_writeback_job *job)\n{\n\tstruct rcar_du_crtc *rcrtc = wb_to_rcar_crtc(connector);\n\tstruct rcar_du_wb_job *rjob;\n\tint ret;\n\n\tif (!job->fb)\n\t\treturn 0;\n\n\trjob = kzalloc(sizeof(*rjob), GFP_KERNEL);\n\tif (!rjob)\n\t\treturn -ENOMEM;\n\n\t \n\tret = rcar_du_vsp_map_fb(rcrtc->vsp, job->fb, rjob->sg_tables);\n\tif (ret < 0) {\n\t\tkfree(rjob);\n\t\treturn ret;\n\t}\n\n\tjob->priv = rjob;\n\treturn 0;\n}\n\nstatic void rcar_du_wb_cleanup_job(struct drm_writeback_connector *connector,\n\t\t\t\t   struct drm_writeback_job *job)\n{\n\tstruct rcar_du_crtc *rcrtc = wb_to_rcar_crtc(connector);\n\tstruct rcar_du_wb_job *rjob = job->priv;\n\n\tif (!job->fb)\n\t\treturn;\n\n\trcar_du_vsp_unmap_fb(rcrtc->vsp, job->fb, rjob->sg_tables);\n\tkfree(rjob);\n}\n\nstatic const struct drm_connector_helper_funcs rcar_du_wb_conn_helper_funcs = {\n\t.get_modes = rcar_du_wb_conn_get_modes,\n\t.prepare_writeback_job = rcar_du_wb_prepare_job,\n\t.cleanup_writeback_job = rcar_du_wb_cleanup_job,\n};\n\nstatic struct drm_connector_state *\nrcar_du_wb_conn_duplicate_state(struct drm_connector *connector)\n{\n\tstruct rcar_du_wb_conn_state *copy;\n\n\tif (WARN_ON(!connector->state))\n\t\treturn NULL;\n\n\tcopy = kzalloc(sizeof(*copy), GFP_KERNEL);\n\tif (!copy)\n\t\treturn NULL;\n\n\t__drm_atomic_helper_connector_duplicate_state(connector, &copy->state);\n\n\treturn &copy->state;\n}\n\nstatic void rcar_du_wb_conn_destroy_state(struct drm_connector *connector,\n\t\t\t\t\t  struct drm_connector_state *state)\n{\n\t__drm_atomic_helper_connector_destroy_state(state);\n\tkfree(to_rcar_wb_conn_state(state));\n}\n\nstatic void rcar_du_wb_conn_reset(struct drm_connector *connector)\n{\n\tstruct rcar_du_wb_conn_state *state;\n\n\tif (connector->state) {\n\t\trcar_du_wb_conn_destroy_state(connector, connector->state);\n\t\tconnector->state = NULL;\n\t}\n\n\tstate = kzalloc(sizeof(*state), GFP_KERNEL);\n\tif (state == NULL)\n\t\treturn;\n\n\t__drm_atomic_helper_connector_reset(connector, &state->state);\n}\n\nstatic const struct drm_connector_funcs rcar_du_wb_conn_funcs = {\n\t.reset = rcar_du_wb_conn_reset,\n\t.fill_modes = drm_helper_probe_single_connector_modes,\n\t.destroy = drm_connector_cleanup,\n\t.atomic_duplicate_state = rcar_du_wb_conn_duplicate_state,\n\t.atomic_destroy_state = rcar_du_wb_conn_destroy_state,\n};\n\nstatic int rcar_du_wb_enc_atomic_check(struct drm_encoder *encoder,\n\t\t\t\t       struct drm_crtc_state *crtc_state,\n\t\t\t\t       struct drm_connector_state *conn_state)\n{\n\tstruct rcar_du_wb_conn_state *wb_state =\n\t\tto_rcar_wb_conn_state(conn_state);\n\tconst struct drm_display_mode *mode = &crtc_state->mode;\n\tstruct drm_device *dev = encoder->dev;\n\tstruct drm_framebuffer *fb;\n\n\tif (!conn_state->writeback_job)\n\t\treturn 0;\n\n\tfb = conn_state->writeback_job->fb;\n\n\t \n\tif (fb->width != mode->hdisplay || fb->height != mode->vdisplay) {\n\t\tdev_dbg(dev->dev, \"%s: invalid framebuffer size %ux%u\\n\",\n\t\t\t__func__, fb->width, fb->height);\n\t\treturn -EINVAL;\n\t}\n\n\twb_state->format = rcar_du_format_info(fb->format->format);\n\tif (wb_state->format == NULL) {\n\t\tdev_dbg(dev->dev, \"%s: unsupported format %p4cc\\n\", __func__,\n\t\t\t&fb->format->format);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic const struct drm_encoder_helper_funcs rcar_du_wb_enc_helper_funcs = {\n\t.atomic_check = rcar_du_wb_enc_atomic_check,\n};\n\n \nstatic const u32 writeback_formats[] = {\n\tDRM_FORMAT_RGB332,\n\tDRM_FORMAT_ARGB4444,\n\tDRM_FORMAT_XRGB4444,\n\tDRM_FORMAT_ARGB1555,\n\tDRM_FORMAT_XRGB1555,\n\tDRM_FORMAT_RGB565,\n\tDRM_FORMAT_BGR888,\n\tDRM_FORMAT_RGB888,\n\tDRM_FORMAT_BGRA8888,\n\tDRM_FORMAT_BGRX8888,\n\tDRM_FORMAT_ARGB8888,\n\tDRM_FORMAT_XRGB8888,\n};\n\nint rcar_du_writeback_init(struct rcar_du_device *rcdu,\n\t\t\t   struct rcar_du_crtc *rcrtc)\n{\n\tstruct drm_writeback_connector *wb_conn = &rcrtc->writeback;\n\n\tdrm_connector_helper_add(&wb_conn->base,\n\t\t\t\t &rcar_du_wb_conn_helper_funcs);\n\n\treturn drm_writeback_connector_init(&rcdu->ddev, wb_conn,\n\t\t\t\t\t    &rcar_du_wb_conn_funcs,\n\t\t\t\t\t    &rcar_du_wb_enc_helper_funcs,\n\t\t\t\t\t    writeback_formats,\n\t\t\t\t\t    ARRAY_SIZE(writeback_formats),\n\t\t\t\t\t    1 << drm_crtc_index(&rcrtc->crtc));\n}\n\nvoid rcar_du_writeback_setup(struct rcar_du_crtc *rcrtc,\n\t\t\t     struct vsp1_du_writeback_config *cfg)\n{\n\tstruct rcar_du_wb_conn_state *wb_state;\n\tstruct drm_connector_state *state;\n\tstruct rcar_du_wb_job *rjob;\n\tstruct drm_framebuffer *fb;\n\tunsigned int i;\n\n\tstate = rcrtc->writeback.base.state;\n\tif (!state || !state->writeback_job)\n\t\treturn;\n\n\tfb = state->writeback_job->fb;\n\trjob = state->writeback_job->priv;\n\twb_state = to_rcar_wb_conn_state(state);\n\n\tcfg->pixelformat = wb_state->format->v4l2;\n\tcfg->pitch = fb->pitches[0];\n\n\tfor (i = 0; i < wb_state->format->planes; ++i)\n\t\tcfg->mem[i] = sg_dma_address(rjob->sg_tables[i].sgl)\n\t\t\t    + fb->offsets[i];\n\n\tdrm_writeback_queue_job(&rcrtc->writeback, state);\n}\n\nvoid rcar_du_writeback_complete(struct rcar_du_crtc *rcrtc)\n{\n\tdrm_writeback_signal_completion(&rcrtc->writeback, 0);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}