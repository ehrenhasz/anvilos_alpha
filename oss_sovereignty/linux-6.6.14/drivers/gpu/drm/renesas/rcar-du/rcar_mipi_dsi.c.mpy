{
  "module_name": "rcar_mipi_dsi.c",
  "hash_id": "f9207f8be22f626c0d4d8553515826de80bc375cc032b36a3038d6d9517745e2",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/renesas/rcar-du/rcar_mipi_dsi.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/delay.h>\n#include <linux/io.h>\n#include <linux/iopoll.h>\n#include <linux/math64.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/of_graph.h>\n#include <linux/platform_device.h>\n#include <linux/reset.h>\n#include <linux/slab.h>\n\n#include <drm/drm_atomic.h>\n#include <drm/drm_atomic_helper.h>\n#include <drm/drm_bridge.h>\n#include <drm/drm_mipi_dsi.h>\n#include <drm/drm_of.h>\n#include <drm/drm_panel.h>\n#include <drm/drm_probe_helper.h>\n\n#include \"rcar_mipi_dsi.h\"\n#include \"rcar_mipi_dsi_regs.h\"\n\n#define MHZ(v) ((u32)((v) * 1000000U))\n\nenum rcar_mipi_dsi_hw_model {\n\tRCAR_DSI_V3U,\n\tRCAR_DSI_V4H,\n};\n\nstruct rcar_mipi_dsi_device_info {\n\tenum rcar_mipi_dsi_hw_model model;\n\n\tconst struct dsi_clk_config *clk_cfg;\n\n\tu8 clockset2_m_offset;\n\n\tu8 n_min;\n\tu8 n_max;\n\tu8 n_mul;\n\tunsigned long fpfd_min;\n\tunsigned long fpfd_max;\n\tu16 m_min;\n\tu16 m_max;\n\tunsigned long fout_min;\n\tunsigned long fout_max;\n};\n\nstruct rcar_mipi_dsi {\n\tstruct device *dev;\n\tconst struct rcar_mipi_dsi_device_info *info;\n\tstruct reset_control *rstc;\n\n\tstruct mipi_dsi_host host;\n\tstruct drm_bridge bridge;\n\tstruct drm_bridge *next_bridge;\n\tstruct drm_connector connector;\n\n\tvoid __iomem *mmio;\n\tstruct {\n\t\tstruct clk *mod;\n\t\tstruct clk *pll;\n\t\tstruct clk *dsi;\n\t} clocks;\n\n\tenum mipi_dsi_pixel_format format;\n\tunsigned int num_data_lanes;\n\tunsigned int lanes;\n};\n\nstruct dsi_setup_info {\n\tunsigned long hsfreq;\n\tu16 hsfreqrange;\n\n\tunsigned long fout;\n\tu16 m;\n\tu16 n;\n\tu16 vclk_divider;\n\tconst struct dsi_clk_config *clkset;\n};\n\nstatic inline struct rcar_mipi_dsi *\nbridge_to_rcar_mipi_dsi(struct drm_bridge *bridge)\n{\n\treturn container_of(bridge, struct rcar_mipi_dsi, bridge);\n}\n\nstatic inline struct rcar_mipi_dsi *\nhost_to_rcar_mipi_dsi(struct mipi_dsi_host *host)\n{\n\treturn container_of(host, struct rcar_mipi_dsi, host);\n}\n\nstatic const u32 hsfreqrange_table[][2] = {\n\t{   MHZ(80), 0x00 }, {   MHZ(90), 0x10 }, {  MHZ(100), 0x20 },\n\t{  MHZ(110), 0x30 }, {  MHZ(120), 0x01 }, {  MHZ(130), 0x11 },\n\t{  MHZ(140), 0x21 }, {  MHZ(150), 0x31 }, {  MHZ(160), 0x02 },\n\t{  MHZ(170), 0x12 }, {  MHZ(180), 0x22 }, {  MHZ(190), 0x32 },\n\t{  MHZ(205), 0x03 }, {  MHZ(220), 0x13 }, {  MHZ(235), 0x23 },\n\t{  MHZ(250), 0x33 }, {  MHZ(275), 0x04 }, {  MHZ(300), 0x14 },\n\t{  MHZ(325), 0x25 }, {  MHZ(350), 0x35 }, {  MHZ(400), 0x05 },\n\t{  MHZ(450), 0x16 }, {  MHZ(500), 0x26 }, {  MHZ(550), 0x37 },\n\t{  MHZ(600), 0x07 }, {  MHZ(650), 0x18 }, {  MHZ(700), 0x28 },\n\t{  MHZ(750), 0x39 }, {  MHZ(800), 0x09 }, {  MHZ(850), 0x19 },\n\t{  MHZ(900), 0x29 }, {  MHZ(950), 0x3a }, { MHZ(1000), 0x0a },\n\t{ MHZ(1050), 0x1a }, { MHZ(1100), 0x2a }, { MHZ(1150), 0x3b },\n\t{ MHZ(1200), 0x0b }, { MHZ(1250), 0x1b }, { MHZ(1300), 0x2b },\n\t{ MHZ(1350), 0x3c }, { MHZ(1400), 0x0c }, { MHZ(1450), 0x1c },\n\t{ MHZ(1500), 0x2c }, { MHZ(1550), 0x3d }, { MHZ(1600), 0x0d },\n\t{ MHZ(1650), 0x1d }, { MHZ(1700), 0x2e }, { MHZ(1750), 0x3e },\n\t{ MHZ(1800), 0x0e }, { MHZ(1850), 0x1e }, { MHZ(1900), 0x2f },\n\t{ MHZ(1950), 0x3f }, { MHZ(2000), 0x0f }, { MHZ(2050), 0x40 },\n\t{ MHZ(2100), 0x41 }, { MHZ(2150), 0x42 }, { MHZ(2200), 0x43 },\n\t{ MHZ(2250), 0x44 }, { MHZ(2300), 0x45 }, { MHZ(2350), 0x46 },\n\t{ MHZ(2400), 0x47 }, { MHZ(2450), 0x48 }, { MHZ(2500), 0x49 },\n\t{   },\n};\n\nstruct dsi_clk_config {\n\tu32 min_freq;\n\tu32 max_freq;\n\tu8 vco_cntrl;\n\tu8 cpbias_cntrl;\n\tu8 gmp_cntrl;\n\tu8 int_cntrl;\n\tu8 prop_cntrl;\n};\n\nstatic const struct dsi_clk_config dsi_clk_cfg_v3u[] = {\n\t{   MHZ(40),    MHZ(55), 0x3f, 0x10, 0x01, 0x00, 0x0b },\n\t{   MHZ(52.5),  MHZ(80), 0x39, 0x10, 0x01, 0x00, 0x0b },\n\t{   MHZ(80),   MHZ(110), 0x2f, 0x10, 0x01, 0x00, 0x0b },\n\t{  MHZ(105),   MHZ(160), 0x29, 0x10, 0x01, 0x00, 0x0b },\n\t{  MHZ(160),   MHZ(220), 0x1f, 0x10, 0x01, 0x00, 0x0b },\n\t{  MHZ(210),   MHZ(320), 0x19, 0x10, 0x01, 0x00, 0x0b },\n\t{  MHZ(320),   MHZ(440), 0x0f, 0x10, 0x01, 0x00, 0x0b },\n\t{  MHZ(420),   MHZ(660), 0x09, 0x10, 0x01, 0x00, 0x0b },\n\t{  MHZ(630),  MHZ(1149), 0x03, 0x10, 0x01, 0x00, 0x0b },\n\t{ MHZ(1100),  MHZ(1152), 0x01, 0x10, 0x01, 0x00, 0x0b },\n\t{ MHZ(1150),  MHZ(1250), 0x01, 0x10, 0x01, 0x00, 0x0c },\n\t{   },\n};\n\nstatic const struct dsi_clk_config dsi_clk_cfg_v4h[] = {\n\t{   MHZ(40),    MHZ(45.31),  0x2b, 0x00, 0x00, 0x08, 0x0a },\n\t{   MHZ(45.31), MHZ(54.66),  0x28, 0x00, 0x00, 0x08, 0x0a },\n\t{   MHZ(54.66), MHZ(62.5),   0x28, 0x00, 0x00, 0x08, 0x0a },\n\t{   MHZ(62.5),  MHZ(75),     0x27, 0x00, 0x00, 0x08, 0x0a },\n\t{   MHZ(75),    MHZ(90.63),  0x23, 0x00, 0x00, 0x08, 0x0a },\n\t{   MHZ(90.63), MHZ(109.37), 0x20, 0x00, 0x00, 0x08, 0x0a },\n\t{  MHZ(109.37), MHZ(125),    0x20, 0x00, 0x00, 0x08, 0x0a },\n\t{  MHZ(125),    MHZ(150),    0x1f, 0x00, 0x00, 0x08, 0x0a },\n\t{  MHZ(150),    MHZ(181.25), 0x1b, 0x00, 0x00, 0x08, 0x0a },\n\t{  MHZ(181.25), MHZ(218.75), 0x18, 0x00, 0x00, 0x08, 0x0a },\n\t{  MHZ(218.75), MHZ(250),    0x18, 0x00, 0x00, 0x08, 0x0a },\n\t{  MHZ(250),    MHZ(300),    0x17, 0x00, 0x00, 0x08, 0x0a },\n\t{  MHZ(300),    MHZ(362.5),  0x13, 0x00, 0x00, 0x08, 0x0a },\n\t{  MHZ(362.5),  MHZ(455.48), 0x10, 0x00, 0x00, 0x08, 0x0a },\n\t{  MHZ(455.48), MHZ(500),    0x10, 0x00, 0x00, 0x08, 0x0a },\n\t{  MHZ(500),    MHZ(600),    0x0f, 0x00, 0x00, 0x08, 0x0a },\n\t{  MHZ(600),    MHZ(725),    0x0b, 0x00, 0x00, 0x08, 0x0a },\n\t{  MHZ(725),    MHZ(875),    0x08, 0x00, 0x00, 0x08, 0x0a },\n\t{  MHZ(875),   MHZ(1000),    0x08, 0x00, 0x00, 0x08, 0x0a },\n\t{ MHZ(1000),   MHZ(1200),    0x07, 0x00, 0x00, 0x08, 0x0a },\n\t{ MHZ(1200),   MHZ(1250),    0x03, 0x00, 0x00, 0x08, 0x0a },\n\t{   },\n};\n\nstatic void rcar_mipi_dsi_write(struct rcar_mipi_dsi *dsi, u32 reg, u32 data)\n{\n\tiowrite32(data, dsi->mmio + reg);\n}\n\nstatic u32 rcar_mipi_dsi_read(struct rcar_mipi_dsi *dsi, u32 reg)\n{\n\treturn ioread32(dsi->mmio + reg);\n}\n\nstatic void rcar_mipi_dsi_clr(struct rcar_mipi_dsi *dsi, u32 reg, u32 clr)\n{\n\trcar_mipi_dsi_write(dsi, reg, rcar_mipi_dsi_read(dsi, reg) & ~clr);\n}\n\nstatic void rcar_mipi_dsi_set(struct rcar_mipi_dsi *dsi, u32 reg, u32 set)\n{\n\trcar_mipi_dsi_write(dsi, reg, rcar_mipi_dsi_read(dsi, reg) | set);\n}\n\nstatic int rcar_mipi_dsi_write_phtw(struct rcar_mipi_dsi *dsi, u32 phtw)\n{\n\tu32 status;\n\tint ret;\n\n\trcar_mipi_dsi_write(dsi, PHTW, phtw);\n\n\tret = read_poll_timeout(rcar_mipi_dsi_read, status,\n\t\t\t\t!(status & (PHTW_DWEN | PHTW_CWEN)),\n\t\t\t\t2000, 10000, false, dsi, PHTW);\n\tif (ret < 0) {\n\t\tdev_err(dsi->dev, \"PHY test interface write timeout (0x%08x)\\n\",\n\t\t\tphtw);\n\t\treturn ret;\n\t}\n\n\treturn ret;\n}\n\nstatic int rcar_mipi_dsi_write_phtw_arr(struct rcar_mipi_dsi *dsi,\n\t\t\t\t\tconst u32 *phtw, unsigned int size)\n{\n\tfor (unsigned int i = 0; i < size; i++) {\n\t\tint ret = rcar_mipi_dsi_write_phtw(dsi, phtw[i]);\n\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\n#define WRITE_PHTW(...)                                               \\\n\t({                                                            \\\n\t\tstatic const u32 phtw[] = { __VA_ARGS__ };            \\\n\t\tint ret;                                              \\\n\t\tret = rcar_mipi_dsi_write_phtw_arr(dsi, phtw,         \\\n\t\t\t\t\t\t   ARRAY_SIZE(phtw)); \\\n\t\tret;                                                  \\\n\t})\n\nstatic int rcar_mipi_dsi_init_phtw_v3u(struct rcar_mipi_dsi *dsi)\n{\n\treturn WRITE_PHTW(0x01020114, 0x01600115, 0x01030116, 0x0102011d,\n\t\t\t  0x011101a4, 0x018601a4, 0x014201a0, 0x010001a3,\n\t\t\t  0x0101011f);\n}\n\nstatic int rcar_mipi_dsi_post_init_phtw_v3u(struct rcar_mipi_dsi *dsi)\n{\n\treturn WRITE_PHTW(0x010c0130, 0x010c0140, 0x010c0150, 0x010c0180,\n\t\t\t  0x010c0190, 0x010a0160, 0x010a0170, 0x01800164,\n\t\t\t  0x01800174);\n}\n\nstatic int rcar_mipi_dsi_init_phtw_v4h(struct rcar_mipi_dsi *dsi,\n\t\t\t\t       const struct dsi_setup_info *setup_info)\n{\n\tint ret;\n\n\tif (setup_info->hsfreq < MHZ(450)) {\n\t\tret = WRITE_PHTW(0x01010100, 0x011b01ac);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tret = WRITE_PHTW(0x01010100, 0x01030173, 0x01000174, 0x01500175,\n\t\t\t 0x01030176, 0x01040166, 0x010201ad);\n\tif (ret)\n\t\treturn ret;\n\n\tif (setup_info->hsfreq <= MHZ(1000))\n\t\tret = WRITE_PHTW(0x01020100, 0x01910170, 0x01020171,\n\t\t\t\t 0x01110172);\n\telse if (setup_info->hsfreq <= MHZ(1500))\n\t\tret = WRITE_PHTW(0x01020100, 0x01980170, 0x01030171,\n\t\t\t\t 0x01100172);\n\telse if (setup_info->hsfreq <= MHZ(2500))\n\t\tret = WRITE_PHTW(0x01020100, 0x0144016b, 0x01000172);\n\telse\n\t\treturn -EINVAL;\n\n\tif (ret)\n\t\treturn ret;\n\n\tif (dsi->lanes <= 1) {\n\t\tret = WRITE_PHTW(0x01070100, 0x010e010b);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tif (dsi->lanes <= 2) {\n\t\tret = WRITE_PHTW(0x01090100, 0x010e010b);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tif (dsi->lanes <= 3) {\n\t\tret = WRITE_PHTW(0x010b0100, 0x010e010b);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tif (setup_info->hsfreq <= MHZ(1500)) {\n\t\tret = WRITE_PHTW(0x01010100, 0x01c0016e);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int\nrcar_mipi_dsi_post_init_phtw_v4h(struct rcar_mipi_dsi *dsi,\n\t\t\t\t const struct dsi_setup_info *setup_info)\n{\n\tu32 status;\n\tint ret;\n\n\tif (setup_info->hsfreq <= MHZ(1500)) {\n\t\tWRITE_PHTW(0x01020100, 0x00000180);\n\n\t\tret = read_poll_timeout(rcar_mipi_dsi_read, status,\n\t\t\t\t\tstatus & PHTR_TEST, 2000, 10000, false,\n\t\t\t\t\tdsi, PHTR);\n\t\tif (ret < 0) {\n\t\t\tdev_err(dsi->dev, \"failed to test PHTR\\n\");\n\t\t\treturn ret;\n\t\t}\n\n\t\tWRITE_PHTW(0x01010100, 0x0100016e);\n\t}\n\n\treturn 0;\n}\n\n \n\nstatic void rcar_mipi_dsi_pll_calc(struct rcar_mipi_dsi *dsi,\n\t\t\t\t   unsigned long fin_rate,\n\t\t\t\t   unsigned long fout_target,\n\t\t\t\t   struct dsi_setup_info *setup_info)\n{\n\tunsigned int best_err = -1;\n\tconst struct rcar_mipi_dsi_device_info *info = dsi->info;\n\n\tfor (unsigned int n = info->n_min; n <= info->n_max; n++) {\n\t\tunsigned long fpfd;\n\n\t\tfpfd = fin_rate / n;\n\n\t\tif (fpfd < info->fpfd_min || fpfd > info->fpfd_max)\n\t\t\tcontinue;\n\n\t\tfor (unsigned int m = info->m_min; m <= info->m_max; m++) {\n\t\t\tunsigned int err;\n\t\t\tu64 fout;\n\n\t\t\tfout = div64_u64((u64)fpfd * m, dsi->info->n_mul);\n\n\t\t\tif (fout < info->fout_min || fout > info->fout_max)\n\t\t\t\tcontinue;\n\n\t\t\tfout = div64_u64(fout, setup_info->vclk_divider);\n\n\t\t\tif (fout < setup_info->clkset->min_freq ||\n\t\t\t    fout > setup_info->clkset->max_freq)\n\t\t\t\tcontinue;\n\n\t\t\terr = abs((long)(fout - fout_target) * 10000 /\n\t\t\t\t  (long)fout_target);\n\t\t\tif (err < best_err) {\n\t\t\t\tsetup_info->m = m;\n\t\t\t\tsetup_info->n = n;\n\t\t\t\tsetup_info->fout = (unsigned long)fout;\n\t\t\t\tbest_err = err;\n\n\t\t\t\tif (err == 0)\n\t\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n}\n\nstatic void rcar_mipi_dsi_parameters_calc(struct rcar_mipi_dsi *dsi,\n\t\t\t\t\t  struct clk *clk, unsigned long target,\n\t\t\t\t\t  struct dsi_setup_info *setup_info)\n{\n\n\tconst struct dsi_clk_config *clk_cfg;\n\tunsigned long fout_target;\n\tunsigned long fin_rate;\n\tunsigned int i;\n\tunsigned int err;\n\n\t \n\tfout_target = target * mipi_dsi_pixel_format_to_bpp(dsi->format)\n\t\t    / (2 * dsi->lanes);\n\tif (fout_target < MHZ(40) || fout_target > MHZ(1250))\n\t\treturn;\n\n\t \n\tfor (clk_cfg = dsi->info->clk_cfg; clk_cfg->min_freq != 0; clk_cfg++) {\n\t\tif (fout_target > clk_cfg->min_freq &&\n\t\t    fout_target <= clk_cfg->max_freq) {\n\t\t\tsetup_info->clkset = clk_cfg;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tfin_rate = clk_get_rate(clk);\n\n\tswitch (dsi->info->model) {\n\tcase RCAR_DSI_V3U:\n\tdefault:\n\t\tsetup_info->vclk_divider = 1 << ((clk_cfg->vco_cntrl >> 4) & 0x3);\n\t\tbreak;\n\n\tcase RCAR_DSI_V4H:\n\t\tsetup_info->vclk_divider = 1 << (((clk_cfg->vco_cntrl >> 3) & 0x7) + 1);\n\t\tbreak;\n\t}\n\n\trcar_mipi_dsi_pll_calc(dsi, fin_rate, fout_target, setup_info);\n\n\t \n\tsetup_info->hsfreq = setup_info->fout * 2;\n\tfor (i = 0; i < ARRAY_SIZE(hsfreqrange_table); i++) {\n\t\tif (hsfreqrange_table[i][0] >= setup_info->hsfreq) {\n\t\t\tsetup_info->hsfreqrange = hsfreqrange_table[i][1];\n\t\t\tbreak;\n\t\t}\n\t}\n\n\terr = abs((long)(setup_info->fout - fout_target) * 10000 / (long)fout_target);\n\n\tdev_dbg(dsi->dev,\n\t\t\"Fout = %u * %lu / (%u * %u * %u) = %lu (target %lu Hz, error %d.%02u%%)\\n\",\n\t\tsetup_info->m, fin_rate, dsi->info->n_mul, setup_info->n,\n\t\tsetup_info->vclk_divider, setup_info->fout, fout_target,\n\t\terr / 100, err % 100);\n\n\tdev_dbg(dsi->dev,\n\t\t\"vco_cntrl = 0x%x\\tprop_cntrl = 0x%x\\thsfreqrange = 0x%x\\n\",\n\t\tclk_cfg->vco_cntrl, clk_cfg->prop_cntrl,\n\t\tsetup_info->hsfreqrange);\n}\n\nstatic void rcar_mipi_dsi_set_display_timing(struct rcar_mipi_dsi *dsi,\n\t\t\t\t\t     const struct drm_display_mode *mode)\n{\n\tu32 setr;\n\tu32 vprmset0r;\n\tu32 vprmset1r;\n\tu32 vprmset2r;\n\tu32 vprmset3r;\n\tu32 vprmset4r;\n\n\t \n\tif (mipi_dsi_pixel_format_to_bpp(dsi->format) == 24)\n\t\trcar_mipi_dsi_write(dsi, TXVMPSPHSETR, TXVMPSPHSETR_DT_RGB24);\n\telse if (mipi_dsi_pixel_format_to_bpp(dsi->format) == 18)\n\t\trcar_mipi_dsi_write(dsi, TXVMPSPHSETR, TXVMPSPHSETR_DT_RGB18);\n\telse if (mipi_dsi_pixel_format_to_bpp(dsi->format) == 16)\n\t\trcar_mipi_dsi_write(dsi, TXVMPSPHSETR, TXVMPSPHSETR_DT_RGB16);\n\telse {\n\t\tdev_warn(dsi->dev, \"unsupported format\");\n\t\treturn;\n\t}\n\n\t \n\tsetr = TXVMSETR_HSABPEN_EN | TXVMSETR_HBPBPEN_EN\n\t     | TXVMSETR_HFPBPEN_EN | TXVMSETR_SYNSEQ_PULSES\n\t     | TXVMSETR_PIXWDTH | TXVMSETR_VSTPM;\n\trcar_mipi_dsi_write(dsi, TXVMSETR, setr);\n\n\t \n\tvprmset0r = (mode->flags & DRM_MODE_FLAG_PVSYNC ?\n\t\t     TXVMVPRMSET0R_VSPOL_HIG : TXVMVPRMSET0R_VSPOL_LOW)\n\t\t  | (mode->flags & DRM_MODE_FLAG_PHSYNC ?\n\t\t     TXVMVPRMSET0R_HSPOL_HIG : TXVMVPRMSET0R_HSPOL_LOW)\n\t\t  | TXVMVPRMSET0R_CSPC_RGB | TXVMVPRMSET0R_BPP_24;\n\n\tvprmset1r = TXVMVPRMSET1R_VACTIVE(mode->vdisplay)\n\t\t  | TXVMVPRMSET1R_VSA(mode->vsync_end - mode->vsync_start);\n\n\tvprmset2r = TXVMVPRMSET2R_VFP(mode->vsync_start - mode->vdisplay)\n\t\t  | TXVMVPRMSET2R_VBP(mode->vtotal - mode->vsync_end);\n\n\tvprmset3r = TXVMVPRMSET3R_HACTIVE(mode->hdisplay)\n\t\t  | TXVMVPRMSET3R_HSA(mode->hsync_end - mode->hsync_start);\n\n\tvprmset4r = TXVMVPRMSET4R_HFP(mode->hsync_start - mode->hdisplay)\n\t\t  | TXVMVPRMSET4R_HBP(mode->htotal - mode->hsync_end);\n\n\trcar_mipi_dsi_write(dsi, TXVMVPRMSET0R, vprmset0r);\n\trcar_mipi_dsi_write(dsi, TXVMVPRMSET1R, vprmset1r);\n\trcar_mipi_dsi_write(dsi, TXVMVPRMSET2R, vprmset2r);\n\trcar_mipi_dsi_write(dsi, TXVMVPRMSET3R, vprmset3r);\n\trcar_mipi_dsi_write(dsi, TXVMVPRMSET4R, vprmset4r);\n}\n\nstatic int rcar_mipi_dsi_startup(struct rcar_mipi_dsi *dsi,\n\t\t\t\t const struct drm_display_mode *mode)\n{\n\tstruct dsi_setup_info setup_info = {};\n\tunsigned int timeout;\n\tint ret;\n\tint dsi_format;\n\tu32 phy_setup;\n\tu32 clockset2, clockset3;\n\tu32 ppisetr;\n\tu32 vclkset;\n\n\t \n\tdsi_format = mipi_dsi_pixel_format_to_bpp(dsi->format);\n\tif (dsi_format < 0) {\n\t\tdev_warn(dsi->dev, \"invalid format\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\trcar_mipi_dsi_parameters_calc(dsi, dsi->clocks.pll,\n\t\t\t\t      mode->clock * 1000, &setup_info);\n\n\t \n\trcar_mipi_dsi_set(dsi, LPCLKSET, LPCLKSET_CKEN);\n\n\t \n\trcar_mipi_dsi_set(dsi, CFGCLKSET, CFGCLKSET_CKEN);\n\n\trcar_mipi_dsi_clr(dsi, PHYSETUP, PHYSETUP_RSTZ);\n\trcar_mipi_dsi_clr(dsi, PHYSETUP, PHYSETUP_SHUTDOWNZ);\n\n\trcar_mipi_dsi_set(dsi, PHTC, PHTC_TESTCLR);\n\trcar_mipi_dsi_clr(dsi, PHTC, PHTC_TESTCLR);\n\n\t \n\tphy_setup = rcar_mipi_dsi_read(dsi, PHYSETUP);\n\tphy_setup &= ~PHYSETUP_HSFREQRANGE_MASK;\n\tphy_setup |= PHYSETUP_HSFREQRANGE(setup_info.hsfreqrange);\n\trcar_mipi_dsi_write(dsi, PHYSETUP, phy_setup);\n\n\tswitch (dsi->info->model) {\n\tcase RCAR_DSI_V3U:\n\tdefault:\n\t\tret = rcar_mipi_dsi_init_phtw_v3u(dsi);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tbreak;\n\n\tcase RCAR_DSI_V4H:\n\t\tret = rcar_mipi_dsi_init_phtw_v4h(dsi, &setup_info);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tbreak;\n\t}\n\n\t \n\trcar_mipi_dsi_clr(dsi, CLOCKSET1, CLOCKSET1_SHADOW_CLEAR);\n\trcar_mipi_dsi_set(dsi, CLOCKSET1, CLOCKSET1_SHADOW_CLEAR);\n\trcar_mipi_dsi_clr(dsi, CLOCKSET1, CLOCKSET1_SHADOW_CLEAR);\n\n\tclockset2 = CLOCKSET2_M(setup_info.m - dsi->info->clockset2_m_offset)\n\t\t  | CLOCKSET2_N(setup_info.n - 1)\n\t\t  | CLOCKSET2_VCO_CNTRL(setup_info.clkset->vco_cntrl);\n\tclockset3 = CLOCKSET3_PROP_CNTRL(setup_info.clkset->prop_cntrl)\n\t\t  | CLOCKSET3_INT_CNTRL(setup_info.clkset->int_cntrl)\n\t\t  | CLOCKSET3_CPBIAS_CNTRL(setup_info.clkset->cpbias_cntrl)\n\t\t  | CLOCKSET3_GMP_CNTRL(setup_info.clkset->gmp_cntrl);\n\trcar_mipi_dsi_write(dsi, CLOCKSET2, clockset2);\n\trcar_mipi_dsi_write(dsi, CLOCKSET3, clockset3);\n\n\trcar_mipi_dsi_clr(dsi, CLOCKSET1, CLOCKSET1_UPDATEPLL);\n\trcar_mipi_dsi_set(dsi, CLOCKSET1, CLOCKSET1_UPDATEPLL);\n\tudelay(10);\n\trcar_mipi_dsi_clr(dsi, CLOCKSET1, CLOCKSET1_UPDATEPLL);\n\n\tppisetr = PPISETR_DLEN_3 | PPISETR_CLEN;\n\trcar_mipi_dsi_write(dsi, PPISETR, ppisetr);\n\n\trcar_mipi_dsi_set(dsi, PHYSETUP, PHYSETUP_SHUTDOWNZ);\n\trcar_mipi_dsi_set(dsi, PHYSETUP, PHYSETUP_RSTZ);\n\tusleep_range(400, 500);\n\n\t \n\tfor (timeout = 10; timeout > 0; --timeout) {\n\t\tif ((rcar_mipi_dsi_read(dsi, PPICLSR) & PPICLSR_STPST) &&\n\t\t    (rcar_mipi_dsi_read(dsi, PPIDLSR) & PPIDLSR_STPST) &&\n\t\t    (rcar_mipi_dsi_read(dsi, CLOCKSET1) & CLOCKSET1_LOCK))\n\t\t\tbreak;\n\n\t\tusleep_range(1000, 2000);\n\t}\n\n\tif (!timeout) {\n\t\tdev_err(dsi->dev, \"failed to enable PPI clock\\n\");\n\t\treturn -ETIMEDOUT;\n\t}\n\n\tswitch (dsi->info->model) {\n\tcase RCAR_DSI_V3U:\n\tdefault:\n\t\tret = rcar_mipi_dsi_post_init_phtw_v3u(dsi);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tbreak;\n\n\tcase RCAR_DSI_V4H:\n\t\tret = rcar_mipi_dsi_post_init_phtw_v4h(dsi, &setup_info);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tbreak;\n\t}\n\n\t \n\tvclkset = VCLKSET_CKEN;\n\trcar_mipi_dsi_write(dsi, VCLKSET, vclkset);\n\n\tif (dsi_format == 24)\n\t\tvclkset |= VCLKSET_BPP_24;\n\telse if (dsi_format == 18)\n\t\tvclkset |= VCLKSET_BPP_18;\n\telse if (dsi_format == 16)\n\t\tvclkset |= VCLKSET_BPP_16;\n\telse {\n\t\tdev_warn(dsi->dev, \"unsupported format\");\n\t\treturn -EINVAL;\n\t}\n\n\tvclkset |= VCLKSET_COLOR_RGB | VCLKSET_LANE(dsi->lanes - 1);\n\n\tswitch (dsi->info->model) {\n\tcase RCAR_DSI_V3U:\n\tdefault:\n\t\tvclkset |= VCLKSET_DIV_V3U(__ffs(setup_info.vclk_divider));\n\t\tbreak;\n\n\tcase RCAR_DSI_V4H:\n\t\tvclkset |= VCLKSET_DIV_V4H(__ffs(setup_info.vclk_divider) - 1);\n\t\tbreak;\n\t}\n\n\trcar_mipi_dsi_write(dsi, VCLKSET, vclkset);\n\n\t \n\trcar_mipi_dsi_set(dsi, VCLKEN, VCLKEN_CKEN);\n\n\tdev_dbg(dsi->dev, \"DSI device is started\\n\");\n\n\treturn 0;\n}\n\nstatic void rcar_mipi_dsi_shutdown(struct rcar_mipi_dsi *dsi)\n{\n\t \n\trcar_mipi_dsi_write(dsi, VCLKSET, 0);\n\n\t \n\trcar_mipi_dsi_write(dsi, VCLKSET, 0);\n\n\trcar_mipi_dsi_clr(dsi, PHYSETUP, PHYSETUP_RSTZ);\n\trcar_mipi_dsi_clr(dsi, PHYSETUP, PHYSETUP_SHUTDOWNZ);\n\n\t \n\trcar_mipi_dsi_clr(dsi, CFGCLKSET, CFGCLKSET_CKEN);\n\n\t \n\trcar_mipi_dsi_clr(dsi, LPCLKSET, LPCLKSET_CKEN);\n\n\tdev_dbg(dsi->dev, \"DSI device is shutdown\\n\");\n}\n\nstatic int rcar_mipi_dsi_clk_enable(struct rcar_mipi_dsi *dsi)\n{\n\tint ret;\n\n\treset_control_deassert(dsi->rstc);\n\n\tret = clk_prepare_enable(dsi->clocks.mod);\n\tif (ret < 0)\n\t\tgoto err_reset;\n\n\tret = clk_prepare_enable(dsi->clocks.dsi);\n\tif (ret < 0)\n\t\tgoto err_clock;\n\n\treturn 0;\n\nerr_clock:\n\tclk_disable_unprepare(dsi->clocks.mod);\nerr_reset:\n\treset_control_assert(dsi->rstc);\n\treturn ret;\n}\n\nstatic void rcar_mipi_dsi_clk_disable(struct rcar_mipi_dsi *dsi)\n{\n\tclk_disable_unprepare(dsi->clocks.dsi);\n\tclk_disable_unprepare(dsi->clocks.mod);\n\n\treset_control_assert(dsi->rstc);\n}\n\nstatic int rcar_mipi_dsi_start_hs_clock(struct rcar_mipi_dsi *dsi)\n{\n\t \n\tu32 status;\n\tint ret;\n\n\t \n\trcar_mipi_dsi_set(dsi, PPICLCR, PPICLCR_TXREQHS);\n\n\tret = read_poll_timeout(rcar_mipi_dsi_read, status,\n\t\t\t\tstatus & PPICLSR_TOHS,\n\t\t\t\t2000, 10000, false, dsi, PPICLSR);\n\tif (ret < 0) {\n\t\tdev_err(dsi->dev, \"failed to enable HS clock\\n\");\n\t\treturn ret;\n\t}\n\n\trcar_mipi_dsi_set(dsi, PPICLSCR, PPICLSCR_TOHS);\n\n\treturn 0;\n}\n\nstatic int rcar_mipi_dsi_start_video(struct rcar_mipi_dsi *dsi)\n{\n\tu32 status;\n\tint ret;\n\n\t \n\tret = read_poll_timeout(rcar_mipi_dsi_read, status,\n\t\t\t\t!(status & (LINKSR_LPBUSY | LINKSR_HSBUSY)),\n\t\t\t\t2000, 10000, false, dsi, LINKSR);\n\tif (ret < 0) {\n\t\tdev_err(dsi->dev, \"Link failed to become ready\\n\");\n\t\treturn ret;\n\t}\n\n\t \n\trcar_mipi_dsi_clr(dsi, TXVMCR, TXVMCR_VFCLR);\n\n\tret = read_poll_timeout(rcar_mipi_dsi_read, status,\n\t\t\t\tstatus & TXVMSR_VFRDY,\n\t\t\t\t2000, 10000, false, dsi, TXVMSR);\n\tif (ret < 0) {\n\t\tdev_err(dsi->dev, \"Failed to de-assert video FIFO clear\\n\");\n\t\treturn ret;\n\t}\n\n\t \n\trcar_mipi_dsi_set(dsi, TXVMCR, TXVMCR_EN_VIDEO);\n\n\tret = read_poll_timeout(rcar_mipi_dsi_read, status,\n\t\t\t\tstatus & TXVMSR_RDY,\n\t\t\t\t2000, 10000, false, dsi, TXVMSR);\n\tif (ret < 0) {\n\t\tdev_err(dsi->dev, \"Failed to enable video transmission\\n\");\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic void rcar_mipi_dsi_stop_video(struct rcar_mipi_dsi *dsi)\n{\n\tu32 status;\n\tint ret;\n\n\t \n\trcar_mipi_dsi_clr(dsi, TXVMCR, TXVMCR_EN_VIDEO);\n\n\tret = read_poll_timeout(rcar_mipi_dsi_read, status,\n\t\t\t\t!(status & TXVMSR_ACT),\n\t\t\t\t2000, 100000, false, dsi, TXVMSR);\n\tif (ret < 0) {\n\t\tdev_err(dsi->dev, \"Failed to disable video transmission\\n\");\n\t\treturn;\n\t}\n\n\t \n\trcar_mipi_dsi_set(dsi, TXVMCR, TXVMCR_VFCLR);\n\n\tret = read_poll_timeout(rcar_mipi_dsi_read, status,\n\t\t\t\t!(status & TXVMSR_VFRDY),\n\t\t\t\t2000, 100000, false, dsi, TXVMSR);\n\tif (ret < 0) {\n\t\tdev_err(dsi->dev, \"Failed to assert video FIFO clear\\n\");\n\t\treturn;\n\t}\n}\n\n \n\nstatic int rcar_mipi_dsi_attach(struct drm_bridge *bridge,\n\t\t\t\tenum drm_bridge_attach_flags flags)\n{\n\tstruct rcar_mipi_dsi *dsi = bridge_to_rcar_mipi_dsi(bridge);\n\n\treturn drm_bridge_attach(bridge->encoder, dsi->next_bridge, bridge,\n\t\t\t\t flags);\n}\n\nstatic void rcar_mipi_dsi_atomic_enable(struct drm_bridge *bridge,\n\t\t\t\t\tstruct drm_bridge_state *old_bridge_state)\n{\n\tstruct rcar_mipi_dsi *dsi = bridge_to_rcar_mipi_dsi(bridge);\n\n\trcar_mipi_dsi_start_video(dsi);\n}\n\nstatic void rcar_mipi_dsi_atomic_disable(struct drm_bridge *bridge,\n\t\t\t\t\t struct drm_bridge_state *old_bridge_state)\n{\n\tstruct rcar_mipi_dsi *dsi = bridge_to_rcar_mipi_dsi(bridge);\n\n\trcar_mipi_dsi_stop_video(dsi);\n}\n\nvoid rcar_mipi_dsi_pclk_enable(struct drm_bridge *bridge,\n\t\t\t       struct drm_atomic_state *state)\n{\n\tstruct rcar_mipi_dsi *dsi = bridge_to_rcar_mipi_dsi(bridge);\n\tconst struct drm_display_mode *mode;\n\tstruct drm_connector *connector;\n\tstruct drm_crtc *crtc;\n\tint ret;\n\n\tconnector = drm_atomic_get_new_connector_for_encoder(state,\n\t\t\t\t\t\t\t     bridge->encoder);\n\tcrtc = drm_atomic_get_new_connector_state(state, connector)->crtc;\n\tmode = &drm_atomic_get_new_crtc_state(state, crtc)->adjusted_mode;\n\n\tret = rcar_mipi_dsi_clk_enable(dsi);\n\tif (ret < 0) {\n\t\tdev_err(dsi->dev, \"failed to enable DSI clocks\\n\");\n\t\treturn;\n\t}\n\n\tret = rcar_mipi_dsi_startup(dsi, mode);\n\tif (ret < 0)\n\t\tgoto err_dsi_startup;\n\n\trcar_mipi_dsi_set_display_timing(dsi, mode);\n\n\tret = rcar_mipi_dsi_start_hs_clock(dsi);\n\tif (ret < 0)\n\t\tgoto err_dsi_start_hs;\n\n\treturn;\n\nerr_dsi_start_hs:\n\trcar_mipi_dsi_shutdown(dsi);\nerr_dsi_startup:\n\trcar_mipi_dsi_clk_disable(dsi);\n}\nEXPORT_SYMBOL_GPL(rcar_mipi_dsi_pclk_enable);\n\nvoid rcar_mipi_dsi_pclk_disable(struct drm_bridge *bridge)\n{\n\tstruct rcar_mipi_dsi *dsi = bridge_to_rcar_mipi_dsi(bridge);\n\n\trcar_mipi_dsi_shutdown(dsi);\n\trcar_mipi_dsi_clk_disable(dsi);\n}\nEXPORT_SYMBOL_GPL(rcar_mipi_dsi_pclk_disable);\n\nstatic enum drm_mode_status\nrcar_mipi_dsi_bridge_mode_valid(struct drm_bridge *bridge,\n\t\t\t\tconst struct drm_display_info *info,\n\t\t\t\tconst struct drm_display_mode *mode)\n{\n\tif (mode->clock > 297000)\n\t\treturn MODE_CLOCK_HIGH;\n\n\treturn MODE_OK;\n}\n\nstatic const struct drm_bridge_funcs rcar_mipi_dsi_bridge_ops = {\n\t.attach = rcar_mipi_dsi_attach,\n\t.atomic_duplicate_state = drm_atomic_helper_bridge_duplicate_state,\n\t.atomic_destroy_state = drm_atomic_helper_bridge_destroy_state,\n\t.atomic_reset = drm_atomic_helper_bridge_reset,\n\t.atomic_enable = rcar_mipi_dsi_atomic_enable,\n\t.atomic_disable = rcar_mipi_dsi_atomic_disable,\n\t.mode_valid = rcar_mipi_dsi_bridge_mode_valid,\n};\n\n \n\nstatic int rcar_mipi_dsi_host_attach(struct mipi_dsi_host *host,\n\t\t\t\t     struct mipi_dsi_device *device)\n{\n\tstruct rcar_mipi_dsi *dsi = host_to_rcar_mipi_dsi(host);\n\tint ret;\n\n\tif (device->lanes > dsi->num_data_lanes)\n\t\treturn -EINVAL;\n\n\tdsi->lanes = device->lanes;\n\tdsi->format = device->format;\n\n\tdsi->next_bridge = devm_drm_of_get_bridge(dsi->dev, dsi->dev->of_node,\n\t\t\t\t\t\t  1, 0);\n\tif (IS_ERR(dsi->next_bridge)) {\n\t\tret = PTR_ERR(dsi->next_bridge);\n\t\tdev_err(dsi->dev, \"failed to get next bridge: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\t \n\tdsi->bridge.funcs = &rcar_mipi_dsi_bridge_ops;\n\tdsi->bridge.of_node = dsi->dev->of_node;\n\tdrm_bridge_add(&dsi->bridge);\n\n\treturn 0;\n}\n\nstatic int rcar_mipi_dsi_host_detach(struct mipi_dsi_host *host,\n\t\t\t\t\tstruct mipi_dsi_device *device)\n{\n\tstruct rcar_mipi_dsi *dsi = host_to_rcar_mipi_dsi(host);\n\n\tdrm_bridge_remove(&dsi->bridge);\n\n\treturn 0;\n}\n\nstatic const struct mipi_dsi_host_ops rcar_mipi_dsi_host_ops = {\n\t.attach = rcar_mipi_dsi_host_attach,\n\t.detach = rcar_mipi_dsi_host_detach,\n};\n\n \n\nstatic int rcar_mipi_dsi_parse_dt(struct rcar_mipi_dsi *dsi)\n{\n\tint ret;\n\n\tret = drm_of_get_data_lanes_count_ep(dsi->dev->of_node, 1, 0, 1, 4);\n\tif (ret < 0) {\n\t\tdev_err(dsi->dev, \"missing or invalid data-lanes property\\n\");\n\t\treturn ret;\n\t}\n\n\tdsi->num_data_lanes = ret;\n\treturn 0;\n}\n\nstatic struct clk *rcar_mipi_dsi_get_clock(struct rcar_mipi_dsi *dsi,\n\t\t\t\t\t   const char *name,\n\t\t\t\t\t   bool optional)\n{\n\tstruct clk *clk;\n\n\tclk = devm_clk_get(dsi->dev, name);\n\tif (!IS_ERR(clk))\n\t\treturn clk;\n\n\tif (PTR_ERR(clk) == -ENOENT && optional)\n\t\treturn NULL;\n\n\tdev_err_probe(dsi->dev, PTR_ERR(clk), \"failed to get %s clock\\n\",\n\t\t      name ? name : \"module\");\n\n\treturn clk;\n}\n\nstatic int rcar_mipi_dsi_get_clocks(struct rcar_mipi_dsi *dsi)\n{\n\tdsi->clocks.mod = rcar_mipi_dsi_get_clock(dsi, NULL, false);\n\tif (IS_ERR(dsi->clocks.mod))\n\t\treturn PTR_ERR(dsi->clocks.mod);\n\n\tdsi->clocks.pll = rcar_mipi_dsi_get_clock(dsi, \"pll\", true);\n\tif (IS_ERR(dsi->clocks.pll))\n\t\treturn PTR_ERR(dsi->clocks.pll);\n\n\tdsi->clocks.dsi = rcar_mipi_dsi_get_clock(dsi, \"dsi\", true);\n\tif (IS_ERR(dsi->clocks.dsi))\n\t\treturn PTR_ERR(dsi->clocks.dsi);\n\n\tif (!dsi->clocks.pll && !dsi->clocks.dsi) {\n\t\tdev_err(dsi->dev, \"no input clock (pll, dsi)\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int rcar_mipi_dsi_probe(struct platform_device *pdev)\n{\n\tstruct rcar_mipi_dsi *dsi;\n\tint ret;\n\n\tdsi = devm_kzalloc(&pdev->dev, sizeof(*dsi), GFP_KERNEL);\n\tif (dsi == NULL)\n\t\treturn -ENOMEM;\n\n\tplatform_set_drvdata(pdev, dsi);\n\n\tdsi->dev = &pdev->dev;\n\tdsi->info = of_device_get_match_data(&pdev->dev);\n\n\tret = rcar_mipi_dsi_parse_dt(dsi);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tdsi->mmio = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(dsi->mmio))\n\t\treturn PTR_ERR(dsi->mmio);\n\n\tret = rcar_mipi_dsi_get_clocks(dsi);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tdsi->rstc = devm_reset_control_get(dsi->dev, NULL);\n\tif (IS_ERR(dsi->rstc)) {\n\t\tdev_err(dsi->dev, \"failed to get cpg reset\\n\");\n\t\treturn PTR_ERR(dsi->rstc);\n\t}\n\n\t \n\tdsi->host.dev = dsi->dev;\n\tdsi->host.ops = &rcar_mipi_dsi_host_ops;\n\tret = mipi_dsi_host_register(&dsi->host);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn 0;\n}\n\nstatic void rcar_mipi_dsi_remove(struct platform_device *pdev)\n{\n\tstruct rcar_mipi_dsi *dsi = platform_get_drvdata(pdev);\n\n\tmipi_dsi_host_unregister(&dsi->host);\n}\n\nstatic const struct rcar_mipi_dsi_device_info v3u_data = {\n\t.model = RCAR_DSI_V3U,\n\t.clk_cfg = dsi_clk_cfg_v3u,\n\t.clockset2_m_offset = 2,\n\t.n_min = 3,\n\t.n_max = 8,\n\t.n_mul = 1,\n\t.fpfd_min = MHZ(2),\n\t.fpfd_max = MHZ(8),\n\t.m_min = 64,\n\t.m_max = 625,\n\t.fout_min = MHZ(320),\n\t.fout_max = MHZ(1250),\n};\n\nstatic const struct rcar_mipi_dsi_device_info v4h_data = {\n\t.model = RCAR_DSI_V4H,\n\t.clk_cfg = dsi_clk_cfg_v4h,\n\t.clockset2_m_offset = 0,\n\t.n_min = 1,\n\t.n_max = 8,\n\t.n_mul = 2,\n\t.fpfd_min = MHZ(8),\n\t.fpfd_max = MHZ(24),\n\t.m_min = 167,\n\t.m_max = 1000,\n\t.fout_min = MHZ(2000),\n\t.fout_max = MHZ(4000),\n};\n\nstatic const struct of_device_id rcar_mipi_dsi_of_table[] = {\n\t{ .compatible = \"renesas,r8a779a0-dsi-csi2-tx\", .data = &v3u_data },\n\t{ .compatible = \"renesas,r8a779g0-dsi-csi2-tx\", .data = &v4h_data },\n\t{ }\n};\n\nMODULE_DEVICE_TABLE(of, rcar_mipi_dsi_of_table);\n\nstatic struct platform_driver rcar_mipi_dsi_platform_driver = {\n\t.probe          = rcar_mipi_dsi_probe,\n\t.remove_new     = rcar_mipi_dsi_remove,\n\t.driver         = {\n\t\t.name   = \"rcar-mipi-dsi\",\n\t\t.of_match_table = rcar_mipi_dsi_of_table,\n\t},\n};\n\nmodule_platform_driver(rcar_mipi_dsi_platform_driver);\n\nMODULE_DESCRIPTION(\"Renesas R-Car MIPI DSI Encoder Driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}