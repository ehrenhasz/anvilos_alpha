{
  "module_name": "rcar_lvds.c",
  "hash_id": "67b57a720501fd4e892e6a032883850ae6c51d267c80301c76a9cad63788543d",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/renesas/rcar-du/rcar_lvds.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/delay.h>\n#include <linux/io.h>\n#include <linux/media-bus-format.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/of_device.h>\n#include <linux/of_graph.h>\n#include <linux/platform_device.h>\n#include <linux/pm_runtime.h>\n#include <linux/reset.h>\n#include <linux/slab.h>\n#include <linux/sys_soc.h>\n\n#include <drm/drm_atomic.h>\n#include <drm/drm_atomic_helper.h>\n#include <drm/drm_bridge.h>\n#include <drm/drm_of.h>\n#include <drm/drm_panel.h>\n#include <drm/drm_print.h>\n#include <drm/drm_probe_helper.h>\n\n#include \"rcar_lvds.h\"\n#include \"rcar_lvds_regs.h\"\n\nstruct rcar_lvds;\n\n \nenum rcar_lvds_mode {\n\tRCAR_LVDS_MODE_JEIDA = 0,\n\tRCAR_LVDS_MODE_MIRROR = 1,\n\tRCAR_LVDS_MODE_VESA = 4,\n};\n\nenum rcar_lvds_link_type {\n\tRCAR_LVDS_SINGLE_LINK = 0,\n\tRCAR_LVDS_DUAL_LINK_EVEN_ODD_PIXELS = 1,\n\tRCAR_LVDS_DUAL_LINK_ODD_EVEN_PIXELS = 2,\n};\n\n#define RCAR_LVDS_QUIRK_LANES\t\tBIT(0)\t \n#define RCAR_LVDS_QUIRK_GEN3_LVEN\tBIT(1)\t \n#define RCAR_LVDS_QUIRK_PWD\t\tBIT(2)\t \n#define RCAR_LVDS_QUIRK_EXT_PLL\t\tBIT(3)\t \n#define RCAR_LVDS_QUIRK_DUAL_LINK\tBIT(4)\t \n\nstruct rcar_lvds_device_info {\n\tunsigned int gen;\n\tunsigned int quirks;\n\tvoid (*pll_setup)(struct rcar_lvds *lvds, unsigned int freq);\n};\n\nstruct rcar_lvds {\n\tstruct device *dev;\n\tconst struct rcar_lvds_device_info *info;\n\tstruct reset_control *rstc;\n\n\tstruct drm_bridge bridge;\n\n\tstruct drm_bridge *next_bridge;\n\tstruct drm_panel *panel;\n\n\tvoid __iomem *mmio;\n\tstruct {\n\t\tstruct clk *mod;\t\t \n\t\tstruct clk *extal;\t\t \n\t\tstruct clk *dotclkin[2];\t \n\t} clocks;\n\n\tstruct drm_bridge *companion;\n\tenum rcar_lvds_link_type link_type;\n};\n\n#define bridge_to_rcar_lvds(b) \\\n\tcontainer_of(b, struct rcar_lvds, bridge)\n\nstatic u32 rcar_lvds_read(struct rcar_lvds *lvds, u32 reg)\n{\n\treturn ioread32(lvds->mmio + reg);\n}\n\nstatic void rcar_lvds_write(struct rcar_lvds *lvds, u32 reg, u32 data)\n{\n\tiowrite32(data, lvds->mmio + reg);\n}\n\n \n\nstatic void rcar_lvds_pll_setup_gen2(struct rcar_lvds *lvds, unsigned int freq)\n{\n\tu32 val;\n\n\tif (freq < 39000000)\n\t\tval = LVDPLLCR_CEEN | LVDPLLCR_COSEL | LVDPLLCR_PLLDLYCNT_38M;\n\telse if (freq < 61000000)\n\t\tval = LVDPLLCR_CEEN | LVDPLLCR_COSEL | LVDPLLCR_PLLDLYCNT_60M;\n\telse if (freq < 121000000)\n\t\tval = LVDPLLCR_CEEN | LVDPLLCR_COSEL | LVDPLLCR_PLLDLYCNT_121M;\n\telse\n\t\tval = LVDPLLCR_PLLDLYCNT_150M;\n\n\trcar_lvds_write(lvds, LVDPLLCR, val);\n}\n\nstatic void rcar_lvds_pll_setup_gen3(struct rcar_lvds *lvds, unsigned int freq)\n{\n\tu32 val;\n\n\tif (freq < 42000000)\n\t\tval = LVDPLLCR_PLLDIVCNT_42M;\n\telse if (freq < 85000000)\n\t\tval = LVDPLLCR_PLLDIVCNT_85M;\n\telse if (freq < 128000000)\n\t\tval = LVDPLLCR_PLLDIVCNT_128M;\n\telse\n\t\tval = LVDPLLCR_PLLDIVCNT_148M;\n\n\trcar_lvds_write(lvds, LVDPLLCR, val);\n}\n\nstruct pll_info {\n\tunsigned long diff;\n\tunsigned int pll_m;\n\tunsigned int pll_n;\n\tunsigned int pll_e;\n\tunsigned int div;\n\tu32 clksel;\n};\n\nstatic void rcar_lvds_d3_e3_pll_calc(struct rcar_lvds *lvds, struct clk *clk,\n\t\t\t\t     unsigned long target, struct pll_info *pll,\n\t\t\t\t     u32 clksel, bool dot_clock_only)\n{\n\tunsigned int div7 = dot_clock_only ? 1 : 7;\n\tunsigned long output;\n\tunsigned long fin;\n\tunsigned int m_min;\n\tunsigned int m_max;\n\tunsigned int m;\n\tint error;\n\n\tif (!clk)\n\t\treturn;\n\n\t \n\n\tfin = clk_get_rate(clk);\n\tif (fin < 12000000 || fin > 192000000)\n\t\treturn;\n\n\t \n\tm_min = max_t(unsigned int, 1, DIV_ROUND_UP(fin, 24000000));\n\tm_max = min_t(unsigned int, 8, fin / 12000000);\n\n\tfor (m = m_min; m <= m_max; ++m) {\n\t\tunsigned long fpfd;\n\t\tunsigned int n_min;\n\t\tunsigned int n_max;\n\t\tunsigned int n;\n\n\t\t \n\t\tfpfd = fin / m;\n\t\tn_min = max_t(unsigned int, 60, DIV_ROUND_UP(900000000, fpfd));\n\t\tn_max = min_t(unsigned int, 120, 1800000000 / fpfd);\n\n\t\tfor (n = n_min; n < n_max; ++n) {\n\t\t\tunsigned long fvco;\n\t\t\tunsigned int e_min;\n\t\t\tunsigned int e;\n\n\t\t\t \n\t\t\tfvco = fpfd * n;\n\t\t\te_min = fvco > 1039500000 ? 1 : 0;\n\n\t\t\tfor (e = e_min; e < 3; ++e) {\n\t\t\t\tunsigned long fout;\n\t\t\t\tunsigned long diff;\n\t\t\t\tunsigned int div;\n\n\t\t\t\t \n\t\t\t\tfout = fvco / (1 << e) / div7;\n\t\t\t\tdiv = max(1UL, DIV_ROUND_CLOSEST(fout, target));\n\t\t\t\tdiff = abs(fout / div - target);\n\n\t\t\t\tif (diff < pll->diff) {\n\t\t\t\t\tpll->diff = diff;\n\t\t\t\t\tpll->pll_m = m;\n\t\t\t\t\tpll->pll_n = n;\n\t\t\t\t\tpll->pll_e = e;\n\t\t\t\t\tpll->div = div;\n\t\t\t\t\tpll->clksel = clksel;\n\n\t\t\t\t\tif (diff == 0)\n\t\t\t\t\t\tgoto done;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\ndone:\n\toutput = fin * pll->pll_n / pll->pll_m / (1 << pll->pll_e)\n\t       / div7 / pll->div;\n\terror = (long)(output - target) * 10000 / (long)target;\n\n\tdev_dbg(lvds->dev,\n\t\t\"%pC %lu Hz -> Fout %lu Hz (target %lu Hz, error %d.%02u%%), PLL M/N/E/DIV %u/%u/%u/%u\\n\",\n\t\tclk, fin, output, target, error / 100,\n\t\terror < 0 ? -error % 100 : error % 100,\n\t\tpll->pll_m, pll->pll_n, pll->pll_e, pll->div);\n}\n\nstatic void rcar_lvds_pll_setup_d3_e3(struct rcar_lvds *lvds,\n\t\t\t\t      unsigned int freq, bool dot_clock_only)\n{\n\tstruct pll_info pll = { .diff = (unsigned long)-1 };\n\tu32 lvdpllcr;\n\n\trcar_lvds_d3_e3_pll_calc(lvds, lvds->clocks.dotclkin[0], freq, &pll,\n\t\t\t\t LVDPLLCR_CKSEL_DU_DOTCLKIN(0), dot_clock_only);\n\trcar_lvds_d3_e3_pll_calc(lvds, lvds->clocks.dotclkin[1], freq, &pll,\n\t\t\t\t LVDPLLCR_CKSEL_DU_DOTCLKIN(1), dot_clock_only);\n\trcar_lvds_d3_e3_pll_calc(lvds, lvds->clocks.extal, freq, &pll,\n\t\t\t\t LVDPLLCR_CKSEL_EXTAL, dot_clock_only);\n\n\tlvdpllcr = LVDPLLCR_PLLON | pll.clksel | LVDPLLCR_CLKOUT\n\t\t | LVDPLLCR_PLLN(pll.pll_n - 1) | LVDPLLCR_PLLM(pll.pll_m - 1);\n\n\tif (pll.pll_e > 0)\n\t\tlvdpllcr |= LVDPLLCR_STP_CLKOUTE | LVDPLLCR_OUTCLKSEL\n\t\t\t |  LVDPLLCR_PLLE(pll.pll_e - 1);\n\n\tif (dot_clock_only)\n\t\tlvdpllcr |= LVDPLLCR_OCKSEL;\n\n\trcar_lvds_write(lvds, LVDPLLCR, lvdpllcr);\n\n\tif (pll.div > 1)\n\t\t \n\t\trcar_lvds_write(lvds, LVDDIV, LVDDIV_DIVSEL |\n\t\t\t\tLVDDIV_DIVRESET | LVDDIV_DIV(pll.div - 1));\n\telse\n\t\trcar_lvds_write(lvds, LVDDIV, 0);\n}\n\n \n\nstatic enum rcar_lvds_mode rcar_lvds_get_lvds_mode(struct rcar_lvds *lvds,\n\t\t\t\t\tconst struct drm_connector *connector)\n{\n\tconst struct drm_display_info *info;\n\tenum rcar_lvds_mode mode;\n\n\t \n\tif (!lvds->panel)\n\t\treturn RCAR_LVDS_MODE_JEIDA;\n\n\tinfo = &connector->display_info;\n\tif (!info->num_bus_formats || !info->bus_formats) {\n\t\tdev_warn(lvds->dev,\n\t\t\t \"no LVDS bus format reported, using JEIDA\\n\");\n\t\treturn RCAR_LVDS_MODE_JEIDA;\n\t}\n\n\tswitch (info->bus_formats[0]) {\n\tcase MEDIA_BUS_FMT_RGB666_1X7X3_SPWG:\n\tcase MEDIA_BUS_FMT_RGB888_1X7X4_JEIDA:\n\t\tmode = RCAR_LVDS_MODE_JEIDA;\n\t\tbreak;\n\tcase MEDIA_BUS_FMT_RGB888_1X7X4_SPWG:\n\t\tmode = RCAR_LVDS_MODE_VESA;\n\t\tbreak;\n\tdefault:\n\t\tdev_warn(lvds->dev,\n\t\t\t \"unsupported LVDS bus format 0x%04x, using JEIDA\\n\",\n\t\t\t info->bus_formats[0]);\n\t\treturn RCAR_LVDS_MODE_JEIDA;\n\t}\n\n\tif (info->bus_flags & DRM_BUS_FLAG_DATA_LSB_TO_MSB)\n\t\tmode |= RCAR_LVDS_MODE_MIRROR;\n\n\treturn mode;\n}\n\nstatic void rcar_lvds_enable(struct drm_bridge *bridge,\n\t\t\t     struct drm_atomic_state *state,\n\t\t\t     struct drm_crtc *crtc,\n\t\t\t     struct drm_connector *connector)\n{\n\tstruct rcar_lvds *lvds = bridge_to_rcar_lvds(bridge);\n\tu32 lvdhcr;\n\tu32 lvdcr0;\n\tint ret;\n\n\tret = pm_runtime_resume_and_get(lvds->dev);\n\tif (ret)\n\t\treturn;\n\n\t \n\tif (lvds->link_type != RCAR_LVDS_SINGLE_LINK && lvds->companion)\n\t\trcar_lvds_enable(lvds->companion, state, crtc, connector);\n\n\t \n\trcar_lvds_write(lvds, LVDCTRCR, LVDCTRCR_CTR3SEL_ZERO |\n\t\t\tLVDCTRCR_CTR2SEL_DISP | LVDCTRCR_CTR1SEL_VSYNC |\n\t\t\tLVDCTRCR_CTR0SEL_HSYNC);\n\n\tif (lvds->info->quirks & RCAR_LVDS_QUIRK_LANES)\n\t\tlvdhcr = LVDCHCR_CHSEL_CH(0, 0) | LVDCHCR_CHSEL_CH(1, 3)\n\t\t       | LVDCHCR_CHSEL_CH(2, 2) | LVDCHCR_CHSEL_CH(3, 1);\n\telse\n\t\tlvdhcr = LVDCHCR_CHSEL_CH(0, 0) | LVDCHCR_CHSEL_CH(1, 1)\n\t\t       | LVDCHCR_CHSEL_CH(2, 2) | LVDCHCR_CHSEL_CH(3, 3);\n\n\trcar_lvds_write(lvds, LVDCHCR, lvdhcr);\n\n\tif (lvds->info->quirks & RCAR_LVDS_QUIRK_DUAL_LINK) {\n\t\tu32 lvdstripe = 0;\n\n\t\tif (lvds->link_type != RCAR_LVDS_SINGLE_LINK) {\n\t\t\t \n\t\t\tbool swap_pixels = lvds->link_type ==\n\t\t\t\tRCAR_LVDS_DUAL_LINK_ODD_EVEN_PIXELS;\n\n\t\t\t \n\t\t\tlvdstripe = LVDSTRIPE_ST_ON\n\t\t\t\t  | (lvds->companion && swap_pixels ?\n\t\t\t\t     LVDSTRIPE_ST_SWAP : 0);\n\t\t}\n\t\trcar_lvds_write(lvds, LVDSTRIPE, lvdstripe);\n\t}\n\n\t \n\tif ((lvds->link_type == RCAR_LVDS_SINGLE_LINK || lvds->companion) &&\n\t    !(lvds->info->quirks & RCAR_LVDS_QUIRK_EXT_PLL)) {\n\t\tconst struct drm_crtc_state *crtc_state =\n\t\t\tdrm_atomic_get_new_crtc_state(state, crtc);\n\t\tconst struct drm_display_mode *mode =\n\t\t\t&crtc_state->adjusted_mode;\n\n\t\tlvds->info->pll_setup(lvds, mode->clock * 1000);\n\t}\n\n\t \n\tlvdcr0 = rcar_lvds_get_lvds_mode(lvds, connector) << LVDCR0_LVMD_SHIFT;\n\n\tif (lvds->bridge.encoder) {\n\t\tif (drm_crtc_index(crtc) == 2)\n\t\t\tlvdcr0 |= LVDCR0_DUSEL;\n\t}\n\n\trcar_lvds_write(lvds, LVDCR0, lvdcr0);\n\n\t \n\trcar_lvds_write(lvds, LVDCR1,\n\t\t\tLVDCR1_CHSTBY(3) | LVDCR1_CHSTBY(2) |\n\t\t\tLVDCR1_CHSTBY(1) | LVDCR1_CHSTBY(0) | LVDCR1_CLKSTBY);\n\n\tif (lvds->info->gen < 3) {\n\t\t \n\t\tlvdcr0 |= LVDCR0_BEN | LVDCR0_LVEN;\n\t\trcar_lvds_write(lvds, LVDCR0, lvdcr0);\n\t}\n\n\tif (!(lvds->info->quirks & RCAR_LVDS_QUIRK_EXT_PLL)) {\n\t\t \n\t\tlvdcr0 |= LVDCR0_PLLON;\n\t\trcar_lvds_write(lvds, LVDCR0, lvdcr0);\n\t}\n\n\tif (lvds->info->quirks & RCAR_LVDS_QUIRK_PWD) {\n\t\t \n\t\tlvdcr0 |= LVDCR0_PWD;\n\t\trcar_lvds_write(lvds, LVDCR0, lvdcr0);\n\t}\n\n\tif (lvds->info->quirks & RCAR_LVDS_QUIRK_GEN3_LVEN) {\n\t\t \n\t\tlvdcr0 |= LVDCR0_LVEN;\n\t\tif (!(lvds->info->quirks & RCAR_LVDS_QUIRK_PWD))\n\t\t\trcar_lvds_write(lvds, LVDCR0, lvdcr0);\n\t}\n\n\tif (!(lvds->info->quirks & RCAR_LVDS_QUIRK_EXT_PLL)) {\n\t\t \n\t\tusleep_range(100, 150);\n\t}\n\n\t \n\tlvdcr0 |= LVDCR0_LVRES;\n\trcar_lvds_write(lvds, LVDCR0, lvdcr0);\n}\n\nstatic void rcar_lvds_disable(struct drm_bridge *bridge)\n{\n\tstruct rcar_lvds *lvds = bridge_to_rcar_lvds(bridge);\n\tu32 lvdcr0;\n\n\t \n\tlvdcr0 = rcar_lvds_read(lvds, LVDCR0);\n\n\tlvdcr0 &= ~LVDCR0_LVRES;\n\trcar_lvds_write(lvds, LVDCR0, lvdcr0);\n\n\tif (lvds->info->quirks & RCAR_LVDS_QUIRK_GEN3_LVEN) {\n\t\tlvdcr0 &= ~LVDCR0_LVEN;\n\t\trcar_lvds_write(lvds, LVDCR0, lvdcr0);\n\t}\n\n\tif (lvds->info->quirks & RCAR_LVDS_QUIRK_PWD) {\n\t\tlvdcr0 &= ~LVDCR0_PWD;\n\t\trcar_lvds_write(lvds, LVDCR0, lvdcr0);\n\t}\n\n\tif (!(lvds->info->quirks & RCAR_LVDS_QUIRK_EXT_PLL)) {\n\t\tlvdcr0 &= ~LVDCR0_PLLON;\n\t\trcar_lvds_write(lvds, LVDCR0, lvdcr0);\n\t}\n\n\trcar_lvds_write(lvds, LVDCR0, 0);\n\trcar_lvds_write(lvds, LVDCR1, 0);\n\n\t \n\tif (!(lvds->info->quirks & RCAR_LVDS_QUIRK_EXT_PLL))\n\t\trcar_lvds_write(lvds, LVDPLLCR, 0);\n\n\t \n\tif (lvds->link_type != RCAR_LVDS_SINGLE_LINK && lvds->companion)\n\t\trcar_lvds_disable(lvds->companion);\n\n\tpm_runtime_put_sync(lvds->dev);\n}\n\n \n\nint rcar_lvds_pclk_enable(struct drm_bridge *bridge, unsigned long freq,\n\t\t\t  bool dot_clk_only)\n{\n\tstruct rcar_lvds *lvds = bridge_to_rcar_lvds(bridge);\n\tint ret;\n\n\tif (WARN_ON(!(lvds->info->quirks & RCAR_LVDS_QUIRK_EXT_PLL)))\n\t\treturn -ENODEV;\n\n\tdev_dbg(lvds->dev, \"enabling LVDS PLL, freq=%luHz\\n\", freq);\n\n\tret = pm_runtime_resume_and_get(lvds->dev);\n\tif (ret)\n\t\treturn ret;\n\n\trcar_lvds_pll_setup_d3_e3(lvds, freq, dot_clk_only);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(rcar_lvds_pclk_enable);\n\nvoid rcar_lvds_pclk_disable(struct drm_bridge *bridge, bool dot_clk_only)\n{\n\tstruct rcar_lvds *lvds = bridge_to_rcar_lvds(bridge);\n\n\tif (WARN_ON(!(lvds->info->quirks & RCAR_LVDS_QUIRK_EXT_PLL)))\n\t\treturn;\n\n\tdev_dbg(lvds->dev, \"disabling LVDS PLL\\n\");\n\n\tif (!dot_clk_only)\n\t\trcar_lvds_disable(bridge);\n\n\trcar_lvds_write(lvds, LVDPLLCR, 0);\n\n\tpm_runtime_put_sync(lvds->dev);\n}\nEXPORT_SYMBOL_GPL(rcar_lvds_pclk_disable);\n\n \n\nstatic void rcar_lvds_atomic_enable(struct drm_bridge *bridge,\n\t\t\t\t    struct drm_bridge_state *old_bridge_state)\n{\n\tstruct drm_atomic_state *state = old_bridge_state->base.state;\n\tstruct drm_connector *connector;\n\tstruct drm_crtc *crtc;\n\n\tconnector = drm_atomic_get_new_connector_for_encoder(state,\n\t\t\t\t\t\t\t     bridge->encoder);\n\tcrtc = drm_atomic_get_new_connector_state(state, connector)->crtc;\n\n\trcar_lvds_enable(bridge, state, crtc, connector);\n}\n\nstatic void rcar_lvds_atomic_disable(struct drm_bridge *bridge,\n\t\t\t\t     struct drm_bridge_state *old_bridge_state)\n{\n\tstruct rcar_lvds *lvds = bridge_to_rcar_lvds(bridge);\n\n\t \n\tif (lvds->info->quirks & RCAR_LVDS_QUIRK_EXT_PLL)\n\t\treturn;\n\n\trcar_lvds_disable(bridge);\n}\n\nstatic bool rcar_lvds_mode_fixup(struct drm_bridge *bridge,\n\t\t\t\t const struct drm_display_mode *mode,\n\t\t\t\t struct drm_display_mode *adjusted_mode)\n{\n\tstruct rcar_lvds *lvds = bridge_to_rcar_lvds(bridge);\n\tint min_freq;\n\n\t \n\tmin_freq = lvds->info->quirks & RCAR_LVDS_QUIRK_EXT_PLL ? 5000 : 31000;\n\tadjusted_mode->clock = clamp(adjusted_mode->clock, min_freq, 148500);\n\n\treturn true;\n}\n\nstatic int rcar_lvds_attach(struct drm_bridge *bridge,\n\t\t\t    enum drm_bridge_attach_flags flags)\n{\n\tstruct rcar_lvds *lvds = bridge_to_rcar_lvds(bridge);\n\n\tif (!lvds->next_bridge)\n\t\treturn 0;\n\n\treturn drm_bridge_attach(bridge->encoder, lvds->next_bridge, bridge,\n\t\t\t\t flags);\n}\n\nstatic const struct drm_bridge_funcs rcar_lvds_bridge_ops = {\n\t.attach = rcar_lvds_attach,\n\t.atomic_duplicate_state = drm_atomic_helper_bridge_duplicate_state,\n\t.atomic_destroy_state = drm_atomic_helper_bridge_destroy_state,\n\t.atomic_reset = drm_atomic_helper_bridge_reset,\n\t.atomic_enable = rcar_lvds_atomic_enable,\n\t.atomic_disable = rcar_lvds_atomic_disable,\n\t.mode_fixup = rcar_lvds_mode_fixup,\n};\n\nbool rcar_lvds_dual_link(struct drm_bridge *bridge)\n{\n\tstruct rcar_lvds *lvds = bridge_to_rcar_lvds(bridge);\n\n\treturn lvds->link_type != RCAR_LVDS_SINGLE_LINK;\n}\nEXPORT_SYMBOL_GPL(rcar_lvds_dual_link);\n\nbool rcar_lvds_is_connected(struct drm_bridge *bridge)\n{\n\tstruct rcar_lvds *lvds = bridge_to_rcar_lvds(bridge);\n\n\treturn lvds->next_bridge != NULL;\n}\nEXPORT_SYMBOL_GPL(rcar_lvds_is_connected);\n\n \n\nstatic int rcar_lvds_parse_dt_companion(struct rcar_lvds *lvds)\n{\n\tconst struct of_device_id *match;\n\tstruct device_node *companion;\n\tstruct device_node *port0, *port1;\n\tstruct rcar_lvds *companion_lvds;\n\tstruct device *dev = lvds->dev;\n\tint dual_link;\n\tint ret = 0;\n\n\t \n\tcompanion = of_parse_phandle(dev->of_node, \"renesas,companion\", 0);\n\tif (!companion)\n\t\treturn 0;\n\n\t \n\tmatch = of_match_device(dev->driver->of_match_table, dev);\n\tif (!of_device_is_compatible(companion, match->compatible)) {\n\t\tdev_err(dev, \"Companion LVDS encoder is invalid\\n\");\n\t\tret = -ENXIO;\n\t\tgoto done;\n\t}\n\n\t \n\tport0 = of_graph_get_port_by_id(dev->of_node, 1);\n\tport1 = of_graph_get_port_by_id(companion, 1);\n\tdual_link = drm_of_lvds_get_dual_link_pixel_order(port0, port1);\n\tof_node_put(port0);\n\tof_node_put(port1);\n\n\tswitch (dual_link) {\n\tcase DRM_LVDS_DUAL_LINK_ODD_EVEN_PIXELS:\n\t\tlvds->link_type = RCAR_LVDS_DUAL_LINK_ODD_EVEN_PIXELS;\n\t\tbreak;\n\tcase DRM_LVDS_DUAL_LINK_EVEN_ODD_PIXELS:\n\t\tlvds->link_type = RCAR_LVDS_DUAL_LINK_EVEN_ODD_PIXELS;\n\t\tbreak;\n\tdefault:\n\t\t \n\t\tif (lvds->next_bridge->timings &&\n\t\t    lvds->next_bridge->timings->dual_link)\n\t\t\tlvds->link_type = RCAR_LVDS_DUAL_LINK_EVEN_ODD_PIXELS;\n\t\telse\n\t\t\tlvds->link_type = RCAR_LVDS_SINGLE_LINK;\n\t}\n\n\tif (lvds->link_type == RCAR_LVDS_SINGLE_LINK) {\n\t\tdev_dbg(dev, \"Single-link configuration detected\\n\");\n\t\tgoto done;\n\t}\n\n\tlvds->companion = of_drm_find_bridge(companion);\n\tif (!lvds->companion) {\n\t\tret = -EPROBE_DEFER;\n\t\tgoto done;\n\t}\n\n\tdev_dbg(dev,\n\t\t\"Dual-link configuration detected (companion encoder %pOF)\\n\",\n\t\tcompanion);\n\n\tif (lvds->link_type == RCAR_LVDS_DUAL_LINK_ODD_EVEN_PIXELS)\n\t\tdev_dbg(dev, \"Data swapping required\\n\");\n\n\t \n\tcompanion_lvds = bridge_to_rcar_lvds(lvds->companion);\n\tcompanion_lvds->link_type = lvds->link_type;\n\ndone:\n\tof_node_put(companion);\n\n\treturn ret;\n}\n\nstatic int rcar_lvds_parse_dt(struct rcar_lvds *lvds)\n{\n\tint ret;\n\n\tret = drm_of_find_panel_or_bridge(lvds->dev->of_node, 1, 0,\n\t\t\t\t\t  &lvds->panel, &lvds->next_bridge);\n\tif (ret)\n\t\tgoto done;\n\n\tif (lvds->panel) {\n\t\tlvds->next_bridge = devm_drm_panel_bridge_add(lvds->dev,\n\t\t\t\t\t\t\t      lvds->panel);\n\t\tif (IS_ERR_OR_NULL(lvds->next_bridge)) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto done;\n\t\t}\n\t}\n\n\tif (lvds->info->quirks & RCAR_LVDS_QUIRK_DUAL_LINK)\n\t\tret = rcar_lvds_parse_dt_companion(lvds);\n\ndone:\n\t \n\tif (lvds->info->quirks & RCAR_LVDS_QUIRK_EXT_PLL)\n\t\treturn ret == -ENODEV ? 0 : ret;\n\n\treturn ret;\n}\n\nstatic struct clk *rcar_lvds_get_clock(struct rcar_lvds *lvds, const char *name,\n\t\t\t\t       bool optional)\n{\n\tstruct clk *clk;\n\n\tclk = devm_clk_get(lvds->dev, name);\n\tif (!IS_ERR(clk))\n\t\treturn clk;\n\n\tif (PTR_ERR(clk) == -ENOENT && optional)\n\t\treturn NULL;\n\n\tdev_err_probe(lvds->dev, PTR_ERR(clk), \"failed to get %s clock\\n\",\n\t\t      name ? name : \"module\");\n\n\treturn clk;\n}\n\nstatic int rcar_lvds_get_clocks(struct rcar_lvds *lvds)\n{\n\tlvds->clocks.mod = rcar_lvds_get_clock(lvds, NULL, false);\n\tif (IS_ERR(lvds->clocks.mod))\n\t\treturn PTR_ERR(lvds->clocks.mod);\n\n\t \n\tif (!(lvds->info->quirks & RCAR_LVDS_QUIRK_EXT_PLL))\n\t\treturn 0;\n\n\tlvds->clocks.extal = rcar_lvds_get_clock(lvds, \"extal\", true);\n\tif (IS_ERR(lvds->clocks.extal))\n\t\treturn PTR_ERR(lvds->clocks.extal);\n\n\tlvds->clocks.dotclkin[0] = rcar_lvds_get_clock(lvds, \"dclkin.0\", true);\n\tif (IS_ERR(lvds->clocks.dotclkin[0]))\n\t\treturn PTR_ERR(lvds->clocks.dotclkin[0]);\n\n\tlvds->clocks.dotclkin[1] = rcar_lvds_get_clock(lvds, \"dclkin.1\", true);\n\tif (IS_ERR(lvds->clocks.dotclkin[1]))\n\t\treturn PTR_ERR(lvds->clocks.dotclkin[1]);\n\n\t \n\tif (!lvds->clocks.extal && !lvds->clocks.dotclkin[0] &&\n\t    !lvds->clocks.dotclkin[1]) {\n\t\tdev_err(lvds->dev,\n\t\t\t\"no input clock (extal, dclkin.0 or dclkin.1)\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic const struct rcar_lvds_device_info rcar_lvds_r8a7790es1_info = {\n\t.gen = 2,\n\t.quirks = RCAR_LVDS_QUIRK_LANES,\n\t.pll_setup = rcar_lvds_pll_setup_gen2,\n};\n\nstatic const struct soc_device_attribute lvds_quirk_matches[] = {\n\t{\n\t\t.soc_id = \"r8a7790\", .revision = \"ES1.*\",\n\t\t.data = &rcar_lvds_r8a7790es1_info,\n\t},\n\t{   }\n};\n\nstatic int rcar_lvds_probe(struct platform_device *pdev)\n{\n\tconst struct soc_device_attribute *attr;\n\tstruct rcar_lvds *lvds;\n\tint ret;\n\n\tlvds = devm_kzalloc(&pdev->dev, sizeof(*lvds), GFP_KERNEL);\n\tif (lvds == NULL)\n\t\treturn -ENOMEM;\n\n\tplatform_set_drvdata(pdev, lvds);\n\n\tlvds->dev = &pdev->dev;\n\tlvds->info = of_device_get_match_data(&pdev->dev);\n\n\tattr = soc_device_match(lvds_quirk_matches);\n\tif (attr)\n\t\tlvds->info = attr->data;\n\n\tret = rcar_lvds_parse_dt(lvds);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tlvds->bridge.funcs = &rcar_lvds_bridge_ops;\n\tlvds->bridge.of_node = pdev->dev.of_node;\n\n\tlvds->mmio = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(lvds->mmio))\n\t\treturn PTR_ERR(lvds->mmio);\n\n\tret = rcar_lvds_get_clocks(lvds);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tlvds->rstc = devm_reset_control_get_exclusive(&pdev->dev, NULL);\n\tif (IS_ERR(lvds->rstc))\n\t\treturn dev_err_probe(&pdev->dev, PTR_ERR(lvds->rstc),\n\t\t\t\t     \"failed to get cpg reset\\n\");\n\n\tpm_runtime_enable(&pdev->dev);\n\n\tdrm_bridge_add(&lvds->bridge);\n\n\treturn 0;\n}\n\nstatic void rcar_lvds_remove(struct platform_device *pdev)\n{\n\tstruct rcar_lvds *lvds = platform_get_drvdata(pdev);\n\n\tdrm_bridge_remove(&lvds->bridge);\n\n\tpm_runtime_disable(&pdev->dev);\n}\n\nstatic const struct rcar_lvds_device_info rcar_lvds_gen2_info = {\n\t.gen = 2,\n\t.pll_setup = rcar_lvds_pll_setup_gen2,\n};\n\nstatic const struct rcar_lvds_device_info rcar_lvds_gen3_info = {\n\t.gen = 3,\n\t.quirks = RCAR_LVDS_QUIRK_PWD,\n\t.pll_setup = rcar_lvds_pll_setup_gen3,\n};\n\nstatic const struct rcar_lvds_device_info rcar_lvds_r8a77970_info = {\n\t.gen = 3,\n\t.quirks = RCAR_LVDS_QUIRK_PWD | RCAR_LVDS_QUIRK_GEN3_LVEN,\n\t.pll_setup = rcar_lvds_pll_setup_gen2,\n};\n\nstatic const struct rcar_lvds_device_info rcar_lvds_r8a77990_info = {\n\t.gen = 3,\n\t.quirks = RCAR_LVDS_QUIRK_GEN3_LVEN | RCAR_LVDS_QUIRK_EXT_PLL\n\t\t| RCAR_LVDS_QUIRK_DUAL_LINK,\n};\n\nstatic const struct rcar_lvds_device_info rcar_lvds_r8a77995_info = {\n\t.gen = 3,\n\t.quirks = RCAR_LVDS_QUIRK_GEN3_LVEN | RCAR_LVDS_QUIRK_PWD\n\t\t| RCAR_LVDS_QUIRK_EXT_PLL | RCAR_LVDS_QUIRK_DUAL_LINK,\n};\n\nstatic const struct of_device_id rcar_lvds_of_table[] = {\n\t{ .compatible = \"renesas,r8a7742-lvds\", .data = &rcar_lvds_gen2_info },\n\t{ .compatible = \"renesas,r8a7743-lvds\", .data = &rcar_lvds_gen2_info },\n\t{ .compatible = \"renesas,r8a7744-lvds\", .data = &rcar_lvds_gen2_info },\n\t{ .compatible = \"renesas,r8a774a1-lvds\", .data = &rcar_lvds_gen3_info },\n\t{ .compatible = \"renesas,r8a774b1-lvds\", .data = &rcar_lvds_gen3_info },\n\t{ .compatible = \"renesas,r8a774c0-lvds\", .data = &rcar_lvds_r8a77990_info },\n\t{ .compatible = \"renesas,r8a774e1-lvds\", .data = &rcar_lvds_gen3_info },\n\t{ .compatible = \"renesas,r8a7790-lvds\", .data = &rcar_lvds_gen2_info },\n\t{ .compatible = \"renesas,r8a7791-lvds\", .data = &rcar_lvds_gen2_info },\n\t{ .compatible = \"renesas,r8a7793-lvds\", .data = &rcar_lvds_gen2_info },\n\t{ .compatible = \"renesas,r8a7795-lvds\", .data = &rcar_lvds_gen3_info },\n\t{ .compatible = \"renesas,r8a7796-lvds\", .data = &rcar_lvds_gen3_info },\n\t{ .compatible = \"renesas,r8a77961-lvds\", .data = &rcar_lvds_gen3_info },\n\t{ .compatible = \"renesas,r8a77965-lvds\", .data = &rcar_lvds_gen3_info },\n\t{ .compatible = \"renesas,r8a77970-lvds\", .data = &rcar_lvds_r8a77970_info },\n\t{ .compatible = \"renesas,r8a77980-lvds\", .data = &rcar_lvds_gen3_info },\n\t{ .compatible = \"renesas,r8a77990-lvds\", .data = &rcar_lvds_r8a77990_info },\n\t{ .compatible = \"renesas,r8a77995-lvds\", .data = &rcar_lvds_r8a77995_info },\n\t{ }\n};\n\nMODULE_DEVICE_TABLE(of, rcar_lvds_of_table);\n\nstatic int rcar_lvds_runtime_suspend(struct device *dev)\n{\n\tstruct rcar_lvds *lvds = dev_get_drvdata(dev);\n\n\tclk_disable_unprepare(lvds->clocks.mod);\n\n\treset_control_assert(lvds->rstc);\n\n\treturn 0;\n}\n\nstatic int rcar_lvds_runtime_resume(struct device *dev)\n{\n\tstruct rcar_lvds *lvds = dev_get_drvdata(dev);\n\tint ret;\n\n\tret = reset_control_deassert(lvds->rstc);\n\tif (ret)\n\t\treturn ret;\n\n\tret = clk_prepare_enable(lvds->clocks.mod);\n\tif (ret < 0)\n\t\tgoto err_reset_assert;\n\n\treturn 0;\n\nerr_reset_assert:\n\treset_control_assert(lvds->rstc);\n\n\treturn ret;\n}\n\nstatic const struct dev_pm_ops rcar_lvds_pm_ops = {\n\tSET_RUNTIME_PM_OPS(rcar_lvds_runtime_suspend, rcar_lvds_runtime_resume, NULL)\n};\n\nstatic struct platform_driver rcar_lvds_platform_driver = {\n\t.probe\t\t= rcar_lvds_probe,\n\t.remove_new\t= rcar_lvds_remove,\n\t.driver\t\t= {\n\t\t.name\t= \"rcar-lvds\",\n\t\t.pm\t= &rcar_lvds_pm_ops,\n\t\t.of_match_table = rcar_lvds_of_table,\n\t},\n};\n\nmodule_platform_driver(rcar_lvds_platform_driver);\n\nMODULE_AUTHOR(\"Laurent Pinchart <laurent.pinchart@ideasonboard.com>\");\nMODULE_DESCRIPTION(\"Renesas R-Car LVDS Encoder Driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}