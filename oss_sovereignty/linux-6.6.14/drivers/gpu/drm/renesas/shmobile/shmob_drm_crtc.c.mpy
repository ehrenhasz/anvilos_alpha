{
  "module_name": "shmob_drm_crtc.c",
  "hash_id": "7dbc4544a7b813041ca7cce0e88b302b5b6d97144e3a8d26fb9866af5d45132e",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/renesas/shmobile/shmob_drm_crtc.c",
  "human_readable_source": "\n \n\n#include <linux/backlight.h>\n#include <linux/clk.h>\n\n#include <drm/drm_crtc.h>\n#include <drm/drm_crtc_helper.h>\n#include <drm/drm_fb_dma_helper.h>\n#include <drm/drm_fourcc.h>\n#include <drm/drm_framebuffer.h>\n#include <drm/drm_gem_dma_helper.h>\n#include <drm/drm_modeset_helper.h>\n#include <drm/drm_modeset_helper_vtables.h>\n#include <drm/drm_plane_helper.h>\n#include <drm/drm_probe_helper.h>\n#include <drm/drm_simple_kms_helper.h>\n#include <drm/drm_vblank.h>\n\n#include \"shmob_drm_backlight.h\"\n#include \"shmob_drm_crtc.h\"\n#include \"shmob_drm_drv.h\"\n#include \"shmob_drm_kms.h\"\n#include \"shmob_drm_plane.h\"\n#include \"shmob_drm_regs.h\"\n\n \n\n \n\nstatic int shmob_drm_clk_on(struct shmob_drm_device *sdev)\n{\n\tint ret;\n\n\tif (sdev->clock) {\n\t\tret = clk_prepare_enable(sdev->clock);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic void shmob_drm_clk_off(struct shmob_drm_device *sdev)\n{\n\tif (sdev->clock)\n\t\tclk_disable_unprepare(sdev->clock);\n}\n\n \n\nstatic void shmob_drm_crtc_setup_geometry(struct shmob_drm_crtc *scrtc)\n{\n\tstruct drm_crtc *crtc = &scrtc->crtc;\n\tstruct shmob_drm_device *sdev = crtc->dev->dev_private;\n\tconst struct shmob_drm_interface_data *idata = &sdev->pdata->iface;\n\tconst struct drm_display_mode *mode = &crtc->mode;\n\tu32 value;\n\n\tvalue = sdev->ldmt1r\n\t      | ((mode->flags & DRM_MODE_FLAG_PVSYNC) ? 0 : LDMT1R_VPOL)\n\t      | ((mode->flags & DRM_MODE_FLAG_PHSYNC) ? 0 : LDMT1R_HPOL)\n\t      | ((idata->flags & SHMOB_DRM_IFACE_FL_DWPOL) ? LDMT1R_DWPOL : 0)\n\t      | ((idata->flags & SHMOB_DRM_IFACE_FL_DIPOL) ? LDMT1R_DIPOL : 0)\n\t      | ((idata->flags & SHMOB_DRM_IFACE_FL_DAPOL) ? LDMT1R_DAPOL : 0)\n\t      | ((idata->flags & SHMOB_DRM_IFACE_FL_HSCNT) ? LDMT1R_HSCNT : 0)\n\t      | ((idata->flags & SHMOB_DRM_IFACE_FL_DWCNT) ? LDMT1R_DWCNT : 0);\n\tlcdc_write(sdev, LDMT1R, value);\n\n\tif (idata->interface >= SHMOB_DRM_IFACE_SYS8A &&\n\t    idata->interface <= SHMOB_DRM_IFACE_SYS24) {\n\t\t \n\t\tvalue = (idata->sys.cs_setup << LDMT2R_CSUP_SHIFT)\n\t\t      | (idata->sys.vsync_active_high ? LDMT2R_RSV : 0)\n\t\t      | (idata->sys.vsync_dir_input ? LDMT2R_VSEL : 0)\n\t\t      | (idata->sys.write_setup << LDMT2R_WCSC_SHIFT)\n\t\t      | (idata->sys.write_cycle << LDMT2R_WCEC_SHIFT)\n\t\t      | (idata->sys.write_strobe << LDMT2R_WCLW_SHIFT);\n\t\tlcdc_write(sdev, LDMT2R, value);\n\n\t\tvalue = (idata->sys.read_latch << LDMT3R_RDLC_SHIFT)\n\t\t      | (idata->sys.read_setup << LDMT3R_RCSC_SHIFT)\n\t\t      | (idata->sys.read_cycle << LDMT3R_RCEC_SHIFT)\n\t\t      | (idata->sys.read_strobe << LDMT3R_RCLW_SHIFT);\n\t\tlcdc_write(sdev, LDMT3R, value);\n\t}\n\n\tvalue = ((mode->hdisplay / 8) << 16)\t\t\t \n\t      | (mode->htotal / 8);\t\t\t\t \n\tlcdc_write(sdev, LDHCNR, value);\n\n\tvalue = (((mode->hsync_end - mode->hsync_start) / 8) << 16)  \n\t      | (mode->hsync_start / 8);\t\t\t \n\tlcdc_write(sdev, LDHSYNR, value);\n\n\tvalue = ((mode->hdisplay & 7) << 24) | ((mode->htotal & 7) << 16)\n\t      | (((mode->hsync_end - mode->hsync_start) & 7) << 8)\n\t      | (mode->hsync_start & 7);\n\tlcdc_write(sdev, LDHAJR, value);\n\n\tvalue = ((mode->vdisplay) << 16)\t\t\t \n\t      | mode->vtotal;\t\t\t\t\t \n\tlcdc_write(sdev, LDVLNR, value);\n\n\tvalue = ((mode->vsync_end - mode->vsync_start) << 16)\t \n\t      | mode->vsync_start;\t\t\t\t \n\tlcdc_write(sdev, LDVSYNR, value);\n}\n\nstatic void shmob_drm_crtc_start_stop(struct shmob_drm_crtc *scrtc, bool start)\n{\n\tstruct shmob_drm_device *sdev = scrtc->crtc.dev->dev_private;\n\tu32 value;\n\n\tvalue = lcdc_read(sdev, LDCNT2R);\n\tif (start)\n\t\tlcdc_write(sdev, LDCNT2R, value | LDCNT2R_DO);\n\telse\n\t\tlcdc_write(sdev, LDCNT2R, value & ~LDCNT2R_DO);\n\n\t \n\twhile (1) {\n\t\tvalue = lcdc_read(sdev, LDPMR) & LDPMR_LPS;\n\t\tif ((start && value) || (!start && !value))\n\t\t\tbreak;\n\n\t\tcpu_relax();\n\t}\n\n\tif (!start) {\n\t\t \n\t\tlcdc_write(sdev, LDDCKSTPR, LDDCKSTPR_DCKSTP);\n\t}\n}\n\n \nstatic void shmob_drm_crtc_start(struct shmob_drm_crtc *scrtc)\n{\n\tstruct drm_crtc *crtc = &scrtc->crtc;\n\tstruct shmob_drm_device *sdev = crtc->dev->dev_private;\n\tconst struct shmob_drm_interface_data *idata = &sdev->pdata->iface;\n\tconst struct shmob_drm_format_info *format;\n\tstruct drm_device *dev = sdev->ddev;\n\tstruct drm_plane *plane;\n\tu32 value;\n\tint ret;\n\n\tif (scrtc->started)\n\t\treturn;\n\n\tformat = shmob_drm_format_info(crtc->primary->fb->format->format);\n\tif (WARN_ON(format == NULL))\n\t\treturn;\n\n\t \n\tret = shmob_drm_clk_on(sdev);\n\tif (ret < 0)\n\t\treturn;\n\n\t \n\tlcdc_write(sdev, LDCNT2R, lcdc_read(sdev, LDCNT2R) | LDCNT2R_BR);\n\tlcdc_wait_bit(sdev, LDCNT2R, LDCNT2R_BR, 0);\n\tlcdc_write(sdev, LDCNT2R, LDCNT2R_ME);\n\n\t \n\tshmob_drm_crtc_start_stop(scrtc, false);\n\tlcdc_write(sdev, LDINTR, 0);\n\n\t \n\tlcdc_write(sdev, LDPMR, 0);\n\n\tvalue = sdev->lddckr;\n\tif (idata->clk_div) {\n\t\t \n\t\tlcdc_write(sdev, LDDCKPAT1R, 0);\n\t\tlcdc_write(sdev, LDDCKPAT2R, (1 << (idata->clk_div / 2)) - 1);\n\n\t\tif (idata->clk_div == 1)\n\t\t\tvalue |= LDDCKR_MOSEL;\n\t\telse\n\t\t\tvalue |= idata->clk_div;\n\t}\n\n\tlcdc_write(sdev, LDDCKR, value);\n\tlcdc_write(sdev, LDDCKSTPR, 0);\n\tlcdc_wait_bit(sdev, LDDCKSTPR, ~0, 0);\n\n\t \n\n\t \n\tshmob_drm_crtc_setup_geometry(scrtc);\n\n\t \n\tlcdc_write(sdev, LDDFR, format->lddfr | LDDFR_CF1);\n\tlcdc_write(sdev, LDMLSR, scrtc->line_size);\n\tlcdc_write(sdev, LDSA1R, scrtc->dma[0]);\n\tif (format->yuv)\n\t\tlcdc_write(sdev, LDSA2R, scrtc->dma[1]);\n\tlcdc_write(sdev, LDSM1R, 0);\n\n\t \n\tswitch (format->fourcc) {\n\tcase DRM_FORMAT_RGB565:\n\tcase DRM_FORMAT_NV21:\n\tcase DRM_FORMAT_NV61:\n\tcase DRM_FORMAT_NV42:\n\t\tvalue = LDDDSR_LS | LDDDSR_WS;\n\t\tbreak;\n\tcase DRM_FORMAT_RGB888:\n\tcase DRM_FORMAT_NV12:\n\tcase DRM_FORMAT_NV16:\n\tcase DRM_FORMAT_NV24:\n\t\tvalue = LDDDSR_LS | LDDDSR_WS | LDDDSR_BS;\n\t\tbreak;\n\tcase DRM_FORMAT_ARGB8888:\n\tcase DRM_FORMAT_XRGB8888:\n\tdefault:\n\t\tvalue = LDDDSR_LS;\n\t\tbreak;\n\t}\n\tlcdc_write(sdev, LDDDSR, value);\n\n\t \n\tdrm_for_each_legacy_plane(plane, dev) {\n\t\tif (plane->crtc == crtc)\n\t\t\tshmob_drm_plane_setup(plane);\n\t}\n\n\t \n\tlcdc_write(sdev, LDCNT1R, LDCNT1R_DE);\n\n\tshmob_drm_crtc_start_stop(scrtc, true);\n\n\tscrtc->started = true;\n}\n\nstatic void shmob_drm_crtc_stop(struct shmob_drm_crtc *scrtc)\n{\n\tstruct drm_crtc *crtc = &scrtc->crtc;\n\tstruct shmob_drm_device *sdev = crtc->dev->dev_private;\n\n\tif (!scrtc->started)\n\t\treturn;\n\n\t \n\tshmob_drm_crtc_start_stop(scrtc, false);\n\n\t \n\tlcdc_write(sdev, LDCNT1R, 0);\n\n\t \n\tshmob_drm_clk_off(sdev);\n\n\tscrtc->started = false;\n}\n\nvoid shmob_drm_crtc_suspend(struct shmob_drm_crtc *scrtc)\n{\n\tshmob_drm_crtc_stop(scrtc);\n}\n\nvoid shmob_drm_crtc_resume(struct shmob_drm_crtc *scrtc)\n{\n\tif (scrtc->dpms != DRM_MODE_DPMS_ON)\n\t\treturn;\n\n\tshmob_drm_crtc_start(scrtc);\n}\n\nstatic void shmob_drm_crtc_compute_base(struct shmob_drm_crtc *scrtc,\n\t\t\t\t\tint x, int y)\n{\n\tstruct drm_crtc *crtc = &scrtc->crtc;\n\tstruct drm_framebuffer *fb = crtc->primary->fb;\n\tstruct drm_gem_dma_object *gem;\n\tunsigned int bpp;\n\n\tbpp = scrtc->format->yuv ? 8 : scrtc->format->bpp;\n\tgem = drm_fb_dma_get_gem_obj(fb, 0);\n\tscrtc->dma[0] = gem->dma_addr + fb->offsets[0]\n\t\t      + y * fb->pitches[0] + x * bpp / 8;\n\n\tif (scrtc->format->yuv) {\n\t\tbpp = scrtc->format->bpp - 8;\n\t\tgem = drm_fb_dma_get_gem_obj(fb, 1);\n\t\tscrtc->dma[1] = gem->dma_addr + fb->offsets[1]\n\t\t\t      + y / (bpp == 4 ? 2 : 1) * fb->pitches[1]\n\t\t\t      + x * (bpp == 16 ? 2 : 1);\n\t}\n}\n\nstatic void shmob_drm_crtc_update_base(struct shmob_drm_crtc *scrtc)\n{\n\tstruct drm_crtc *crtc = &scrtc->crtc;\n\tstruct shmob_drm_device *sdev = crtc->dev->dev_private;\n\n\tshmob_drm_crtc_compute_base(scrtc, crtc->x, crtc->y);\n\n\tlcdc_write_mirror(sdev, LDSA1R, scrtc->dma[0]);\n\tif (scrtc->format->yuv)\n\t\tlcdc_write_mirror(sdev, LDSA2R, scrtc->dma[1]);\n\n\tlcdc_write(sdev, LDRCNTR, lcdc_read(sdev, LDRCNTR) ^ LDRCNTR_MRS);\n}\n\n#define to_shmob_crtc(c)\tcontainer_of(c, struct shmob_drm_crtc, crtc)\n\nstatic void shmob_drm_crtc_dpms(struct drm_crtc *crtc, int mode)\n{\n\tstruct shmob_drm_crtc *scrtc = to_shmob_crtc(crtc);\n\n\tif (scrtc->dpms == mode)\n\t\treturn;\n\n\tif (mode == DRM_MODE_DPMS_ON)\n\t\tshmob_drm_crtc_start(scrtc);\n\telse\n\t\tshmob_drm_crtc_stop(scrtc);\n\n\tscrtc->dpms = mode;\n}\n\nstatic void shmob_drm_crtc_mode_prepare(struct drm_crtc *crtc)\n{\n\tshmob_drm_crtc_dpms(crtc, DRM_MODE_DPMS_OFF);\n}\n\nstatic int shmob_drm_crtc_mode_set(struct drm_crtc *crtc,\n\t\t\t\t   struct drm_display_mode *mode,\n\t\t\t\t   struct drm_display_mode *adjusted_mode,\n\t\t\t\t   int x, int y,\n\t\t\t\t   struct drm_framebuffer *old_fb)\n{\n\tstruct shmob_drm_crtc *scrtc = to_shmob_crtc(crtc);\n\tstruct shmob_drm_device *sdev = crtc->dev->dev_private;\n\tconst struct shmob_drm_format_info *format;\n\n\tformat = shmob_drm_format_info(crtc->primary->fb->format->format);\n\tif (format == NULL) {\n\t\tdev_dbg(sdev->dev, \"mode_set: unsupported format %p4cc\\n\",\n\t\t\t&crtc->primary->fb->format->format);\n\t\treturn -EINVAL;\n\t}\n\n\tscrtc->format = format;\n\tscrtc->line_size = crtc->primary->fb->pitches[0];\n\n\tshmob_drm_crtc_compute_base(scrtc, x, y);\n\n\treturn 0;\n}\n\nstatic void shmob_drm_crtc_mode_commit(struct drm_crtc *crtc)\n{\n\tshmob_drm_crtc_dpms(crtc, DRM_MODE_DPMS_ON);\n}\n\nstatic int shmob_drm_crtc_mode_set_base(struct drm_crtc *crtc, int x, int y,\n\t\t\t\t\tstruct drm_framebuffer *old_fb)\n{\n\tshmob_drm_crtc_update_base(to_shmob_crtc(crtc));\n\n\treturn 0;\n}\n\nstatic const struct drm_crtc_helper_funcs crtc_helper_funcs = {\n\t.dpms = shmob_drm_crtc_dpms,\n\t.prepare = shmob_drm_crtc_mode_prepare,\n\t.commit = shmob_drm_crtc_mode_commit,\n\t.mode_set = shmob_drm_crtc_mode_set,\n\t.mode_set_base = shmob_drm_crtc_mode_set_base,\n};\n\nvoid shmob_drm_crtc_finish_page_flip(struct shmob_drm_crtc *scrtc)\n{\n\tstruct drm_pending_vblank_event *event;\n\tstruct drm_device *dev = scrtc->crtc.dev;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&dev->event_lock, flags);\n\tevent = scrtc->event;\n\tscrtc->event = NULL;\n\tif (event) {\n\t\tdrm_crtc_send_vblank_event(&scrtc->crtc, event);\n\t\tdrm_crtc_vblank_put(&scrtc->crtc);\n\t}\n\tspin_unlock_irqrestore(&dev->event_lock, flags);\n}\n\nstatic int shmob_drm_crtc_page_flip(struct drm_crtc *crtc,\n\t\t\t\t    struct drm_framebuffer *fb,\n\t\t\t\t    struct drm_pending_vblank_event *event,\n\t\t\t\t    uint32_t page_flip_flags,\n\t\t\t\t    struct drm_modeset_acquire_ctx *ctx)\n{\n\tstruct shmob_drm_crtc *scrtc = to_shmob_crtc(crtc);\n\tstruct drm_device *dev = scrtc->crtc.dev;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&dev->event_lock, flags);\n\tif (scrtc->event != NULL) {\n\t\tspin_unlock_irqrestore(&dev->event_lock, flags);\n\t\treturn -EBUSY;\n\t}\n\tspin_unlock_irqrestore(&dev->event_lock, flags);\n\n\tcrtc->primary->fb = fb;\n\tshmob_drm_crtc_update_base(scrtc);\n\n\tif (event) {\n\t\tevent->pipe = 0;\n\t\tdrm_crtc_vblank_get(&scrtc->crtc);\n\t\tspin_lock_irqsave(&dev->event_lock, flags);\n\t\tscrtc->event = event;\n\t\tspin_unlock_irqrestore(&dev->event_lock, flags);\n\t}\n\n\treturn 0;\n}\n\nstatic void shmob_drm_crtc_enable_vblank(struct shmob_drm_device *sdev,\n\t\t\t\t\t bool enable)\n{\n\tunsigned long flags;\n\tu32 ldintr;\n\n\t \n\tspin_lock_irqsave(&sdev->irq_lock, flags);\n\tldintr = lcdc_read(sdev, LDINTR) | LDINTR_STATUS_MASK;\n\tif (enable)\n\t\tldintr |= LDINTR_VEE;\n\telse\n\t\tldintr &= ~LDINTR_VEE;\n\tlcdc_write(sdev, LDINTR, ldintr);\n\tspin_unlock_irqrestore(&sdev->irq_lock, flags);\n}\n\nstatic int shmob_drm_enable_vblank(struct drm_crtc *crtc)\n{\n\tstruct shmob_drm_device *sdev = crtc->dev->dev_private;\n\n\tshmob_drm_crtc_enable_vblank(sdev, true);\n\n\treturn 0;\n}\n\nstatic void shmob_drm_disable_vblank(struct drm_crtc *crtc)\n{\n\tstruct shmob_drm_device *sdev = crtc->dev->dev_private;\n\n\tshmob_drm_crtc_enable_vblank(sdev, false);\n}\n\nstatic const struct drm_crtc_funcs crtc_funcs = {\n\t.destroy = drm_crtc_cleanup,\n\t.set_config = drm_crtc_helper_set_config,\n\t.page_flip = shmob_drm_crtc_page_flip,\n\t.enable_vblank = shmob_drm_enable_vblank,\n\t.disable_vblank = shmob_drm_disable_vblank,\n};\n\nstatic const uint32_t modeset_formats[] = {\n\tDRM_FORMAT_RGB565,\n\tDRM_FORMAT_RGB888,\n\tDRM_FORMAT_ARGB8888,\n\tDRM_FORMAT_XRGB8888,\n};\n\nstatic const struct drm_plane_funcs primary_plane_funcs = {\n\tDRM_PLANE_NON_ATOMIC_FUNCS,\n};\n\nint shmob_drm_crtc_create(struct shmob_drm_device *sdev)\n{\n\tstruct drm_crtc *crtc = &sdev->crtc.crtc;\n\tstruct drm_plane *primary;\n\tint ret;\n\n\tsdev->crtc.dpms = DRM_MODE_DPMS_OFF;\n\n\tprimary = __drm_universal_plane_alloc(sdev->ddev, sizeof(*primary), 0,\n\t\t\t\t\t      0, &primary_plane_funcs,\n\t\t\t\t\t      modeset_formats,\n\t\t\t\t\t      ARRAY_SIZE(modeset_formats),\n\t\t\t\t\t      NULL, DRM_PLANE_TYPE_PRIMARY,\n\t\t\t\t\t      NULL);\n\tif (IS_ERR(primary))\n\t\treturn PTR_ERR(primary);\n\n\tret = drm_crtc_init_with_planes(sdev->ddev, crtc, primary, NULL,\n\t\t\t\t\t&crtc_funcs, NULL);\n\tif (ret < 0) {\n\t\tdrm_plane_cleanup(primary);\n\t\tkfree(primary);\n\t\treturn ret;\n\t}\n\n\tdrm_crtc_helper_add(crtc, &crtc_helper_funcs);\n\n\treturn 0;\n}\n\n \n\n#define to_shmob_encoder(e) \\\n\tcontainer_of(e, struct shmob_drm_encoder, encoder)\n\nstatic void shmob_drm_encoder_dpms(struct drm_encoder *encoder, int mode)\n{\n\tstruct shmob_drm_encoder *senc = to_shmob_encoder(encoder);\n\tstruct shmob_drm_device *sdev = encoder->dev->dev_private;\n\tstruct shmob_drm_connector *scon = &sdev->connector;\n\n\tif (senc->dpms == mode)\n\t\treturn;\n\n\tshmob_drm_backlight_dpms(scon, mode);\n\n\tsenc->dpms = mode;\n}\n\nstatic bool shmob_drm_encoder_mode_fixup(struct drm_encoder *encoder,\n\t\t\t\t\t const struct drm_display_mode *mode,\n\t\t\t\t\t struct drm_display_mode *adjusted_mode)\n{\n\tstruct drm_device *dev = encoder->dev;\n\tstruct shmob_drm_device *sdev = dev->dev_private;\n\tstruct drm_connector *connector = &sdev->connector.connector;\n\tconst struct drm_display_mode *panel_mode;\n\n\tif (list_empty(&connector->modes)) {\n\t\tdev_dbg(dev->dev, \"mode_fixup: empty modes list\\n\");\n\t\treturn false;\n\t}\n\n\t \n\tpanel_mode = list_first_entry(&connector->modes,\n\t\t\t\t      struct drm_display_mode, head);\n\tdrm_mode_copy(adjusted_mode, panel_mode);\n\n\treturn true;\n}\n\nstatic void shmob_drm_encoder_mode_prepare(struct drm_encoder *encoder)\n{\n\t \n}\n\nstatic void shmob_drm_encoder_mode_set(struct drm_encoder *encoder,\n\t\t\t\t       struct drm_display_mode *mode,\n\t\t\t\t       struct drm_display_mode *adjusted_mode)\n{\n\t \n}\n\nstatic void shmob_drm_encoder_mode_commit(struct drm_encoder *encoder)\n{\n\t \n}\n\nstatic const struct drm_encoder_helper_funcs encoder_helper_funcs = {\n\t.dpms = shmob_drm_encoder_dpms,\n\t.mode_fixup = shmob_drm_encoder_mode_fixup,\n\t.prepare = shmob_drm_encoder_mode_prepare,\n\t.commit = shmob_drm_encoder_mode_commit,\n\t.mode_set = shmob_drm_encoder_mode_set,\n};\n\nint shmob_drm_encoder_create(struct shmob_drm_device *sdev)\n{\n\tstruct drm_encoder *encoder = &sdev->encoder.encoder;\n\tint ret;\n\n\tsdev->encoder.dpms = DRM_MODE_DPMS_OFF;\n\n\tencoder->possible_crtcs = 1;\n\n\tret = drm_simple_encoder_init(sdev->ddev, encoder,\n\t\t\t\t      DRM_MODE_ENCODER_LVDS);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tdrm_encoder_helper_add(encoder, &encoder_helper_funcs);\n\n\treturn 0;\n}\n\n \n\n#define to_shmob_connector(c) \\\n\tcontainer_of(c, struct shmob_drm_connector, connector)\n\nstatic int shmob_drm_connector_get_modes(struct drm_connector *connector)\n{\n\tstruct shmob_drm_device *sdev = connector->dev->dev_private;\n\tstruct drm_display_mode *mode;\n\n\tmode = drm_mode_create(connector->dev);\n\tif (mode == NULL)\n\t\treturn 0;\n\n\tmode->type = DRM_MODE_TYPE_PREFERRED | DRM_MODE_TYPE_DRIVER;\n\tmode->clock = sdev->pdata->panel.mode.clock;\n\tmode->hdisplay = sdev->pdata->panel.mode.hdisplay;\n\tmode->hsync_start = sdev->pdata->panel.mode.hsync_start;\n\tmode->hsync_end = sdev->pdata->panel.mode.hsync_end;\n\tmode->htotal = sdev->pdata->panel.mode.htotal;\n\tmode->vdisplay = sdev->pdata->panel.mode.vdisplay;\n\tmode->vsync_start = sdev->pdata->panel.mode.vsync_start;\n\tmode->vsync_end = sdev->pdata->panel.mode.vsync_end;\n\tmode->vtotal = sdev->pdata->panel.mode.vtotal;\n\tmode->flags = sdev->pdata->panel.mode.flags;\n\n\tdrm_mode_set_name(mode);\n\tdrm_mode_probed_add(connector, mode);\n\n\tconnector->display_info.width_mm = sdev->pdata->panel.width_mm;\n\tconnector->display_info.height_mm = sdev->pdata->panel.height_mm;\n\n\treturn 1;\n}\n\nstatic struct drm_encoder *\nshmob_drm_connector_best_encoder(struct drm_connector *connector)\n{\n\tstruct shmob_drm_connector *scon = to_shmob_connector(connector);\n\n\treturn scon->encoder;\n}\n\nstatic const struct drm_connector_helper_funcs connector_helper_funcs = {\n\t.get_modes = shmob_drm_connector_get_modes,\n\t.best_encoder = shmob_drm_connector_best_encoder,\n};\n\nstatic void shmob_drm_connector_destroy(struct drm_connector *connector)\n{\n\tstruct shmob_drm_connector *scon = to_shmob_connector(connector);\n\n\tshmob_drm_backlight_exit(scon);\n\tdrm_connector_unregister(connector);\n\tdrm_connector_cleanup(connector);\n}\n\nstatic const struct drm_connector_funcs connector_funcs = {\n\t.dpms = drm_helper_connector_dpms,\n\t.fill_modes = drm_helper_probe_single_connector_modes,\n\t.destroy = shmob_drm_connector_destroy,\n};\n\nint shmob_drm_connector_create(struct shmob_drm_device *sdev,\n\t\t\t       struct drm_encoder *encoder)\n{\n\tstruct drm_connector *connector = &sdev->connector.connector;\n\tint ret;\n\n\tsdev->connector.encoder = encoder;\n\n\tconnector->display_info.width_mm = sdev->pdata->panel.width_mm;\n\tconnector->display_info.height_mm = sdev->pdata->panel.height_mm;\n\n\tret = drm_connector_init(sdev->ddev, connector, &connector_funcs,\n\t\t\t\t DRM_MODE_CONNECTOR_LVDS);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tdrm_connector_helper_add(connector, &connector_helper_funcs);\n\n\tret = shmob_drm_backlight_init(&sdev->connector);\n\tif (ret < 0)\n\t\tgoto err_cleanup;\n\n\tret = drm_connector_attach_encoder(connector, encoder);\n\tif (ret < 0)\n\t\tgoto err_backlight;\n\n\tdrm_helper_connector_dpms(connector, DRM_MODE_DPMS_OFF);\n\tdrm_object_property_set_value(&connector->base,\n\t\tsdev->ddev->mode_config.dpms_property, DRM_MODE_DPMS_OFF);\n\n\treturn 0;\n\nerr_backlight:\n\tshmob_drm_backlight_exit(&sdev->connector);\nerr_cleanup:\n\tdrm_connector_cleanup(connector);\n\treturn ret;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}