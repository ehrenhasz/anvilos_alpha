{
  "module_name": "shmob_drm_drv.c",
  "hash_id": "edc7673908b83c4ab0649990f9a828f42ee24fd9ab366f5a5911517455ca982e",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/renesas/shmobile/shmob_drm_drv.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/io.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n#include <linux/platform_device.h>\n#include <linux/pm.h>\n#include <linux/slab.h>\n\n#include <drm/drm_drv.h>\n#include <drm/drm_fbdev_generic.h>\n#include <drm/drm_gem_dma_helper.h>\n#include <drm/drm_module.h>\n#include <drm/drm_probe_helper.h>\n#include <drm/drm_vblank.h>\n\n#include \"shmob_drm_drv.h\"\n#include \"shmob_drm_kms.h\"\n#include \"shmob_drm_plane.h\"\n#include \"shmob_drm_regs.h\"\n\n \n\nstatic int shmob_drm_init_interface(struct shmob_drm_device *sdev)\n{\n\tstatic const u32 ldmt1r[] = {\n\t\t[SHMOB_DRM_IFACE_RGB8] = LDMT1R_MIFTYP_RGB8,\n\t\t[SHMOB_DRM_IFACE_RGB9] = LDMT1R_MIFTYP_RGB9,\n\t\t[SHMOB_DRM_IFACE_RGB12A] = LDMT1R_MIFTYP_RGB12A,\n\t\t[SHMOB_DRM_IFACE_RGB12B] = LDMT1R_MIFTYP_RGB12B,\n\t\t[SHMOB_DRM_IFACE_RGB16] = LDMT1R_MIFTYP_RGB16,\n\t\t[SHMOB_DRM_IFACE_RGB18] = LDMT1R_MIFTYP_RGB18,\n\t\t[SHMOB_DRM_IFACE_RGB24] = LDMT1R_MIFTYP_RGB24,\n\t\t[SHMOB_DRM_IFACE_YUV422] = LDMT1R_MIFTYP_YCBCR,\n\t\t[SHMOB_DRM_IFACE_SYS8A] = LDMT1R_IFM | LDMT1R_MIFTYP_SYS8A,\n\t\t[SHMOB_DRM_IFACE_SYS8B] = LDMT1R_IFM | LDMT1R_MIFTYP_SYS8B,\n\t\t[SHMOB_DRM_IFACE_SYS8C] = LDMT1R_IFM | LDMT1R_MIFTYP_SYS8C,\n\t\t[SHMOB_DRM_IFACE_SYS8D] = LDMT1R_IFM | LDMT1R_MIFTYP_SYS8D,\n\t\t[SHMOB_DRM_IFACE_SYS9] = LDMT1R_IFM | LDMT1R_MIFTYP_SYS9,\n\t\t[SHMOB_DRM_IFACE_SYS12] = LDMT1R_IFM | LDMT1R_MIFTYP_SYS12,\n\t\t[SHMOB_DRM_IFACE_SYS16A] = LDMT1R_IFM | LDMT1R_MIFTYP_SYS16A,\n\t\t[SHMOB_DRM_IFACE_SYS16B] = LDMT1R_IFM | LDMT1R_MIFTYP_SYS16B,\n\t\t[SHMOB_DRM_IFACE_SYS16C] = LDMT1R_IFM | LDMT1R_MIFTYP_SYS16C,\n\t\t[SHMOB_DRM_IFACE_SYS18] = LDMT1R_IFM | LDMT1R_MIFTYP_SYS18,\n\t\t[SHMOB_DRM_IFACE_SYS24] = LDMT1R_IFM | LDMT1R_MIFTYP_SYS24,\n\t};\n\n\tif (sdev->pdata->iface.interface >= ARRAY_SIZE(ldmt1r)) {\n\t\tdev_err(sdev->dev, \"invalid interface type %u\\n\",\n\t\t\tsdev->pdata->iface.interface);\n\t\treturn -EINVAL;\n\t}\n\n\tsdev->ldmt1r = ldmt1r[sdev->pdata->iface.interface];\n\treturn 0;\n}\n\nstatic int shmob_drm_setup_clocks(struct shmob_drm_device *sdev,\n\t\t\t\t\t    enum shmob_drm_clk_source clksrc)\n{\n\tstruct clk *clk;\n\tchar *clkname;\n\n\tswitch (clksrc) {\n\tcase SHMOB_DRM_CLK_BUS:\n\t\tclkname = \"bus_clk\";\n\t\tsdev->lddckr = LDDCKR_ICKSEL_BUS;\n\t\tbreak;\n\tcase SHMOB_DRM_CLK_PERIPHERAL:\n\t\tclkname = \"peripheral_clk\";\n\t\tsdev->lddckr = LDDCKR_ICKSEL_MIPI;\n\t\tbreak;\n\tcase SHMOB_DRM_CLK_EXTERNAL:\n\t\tclkname = NULL;\n\t\tsdev->lddckr = LDDCKR_ICKSEL_HDMI;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tclk = devm_clk_get(sdev->dev, clkname);\n\tif (IS_ERR(clk)) {\n\t\tdev_err(sdev->dev, \"cannot get dot clock %s\\n\", clkname);\n\t\treturn PTR_ERR(clk);\n\t}\n\n\tsdev->clock = clk;\n\treturn 0;\n}\n\n \n\nstatic irqreturn_t shmob_drm_irq(int irq, void *arg)\n{\n\tstruct drm_device *dev = arg;\n\tstruct shmob_drm_device *sdev = dev->dev_private;\n\tunsigned long flags;\n\tu32 status;\n\n\t \n\tspin_lock_irqsave(&sdev->irq_lock, flags);\n\tstatus = lcdc_read(sdev, LDINTR);\n\tlcdc_write(sdev, LDINTR, status ^ LDINTR_STATUS_MASK);\n\tspin_unlock_irqrestore(&sdev->irq_lock, flags);\n\n\tif (status & LDINTR_VES) {\n\t\tdrm_handle_vblank(dev, 0);\n\t\tshmob_drm_crtc_finish_page_flip(&sdev->crtc);\n\t}\n\n\treturn IRQ_HANDLED;\n}\n\nDEFINE_DRM_GEM_DMA_FOPS(shmob_drm_fops);\n\nstatic const struct drm_driver shmob_drm_driver = {\n\t.driver_features\t= DRIVER_GEM | DRIVER_MODESET,\n\tDRM_GEM_DMA_DRIVER_OPS,\n\t.fops\t\t\t= &shmob_drm_fops,\n\t.name\t\t\t= \"shmob-drm\",\n\t.desc\t\t\t= \"Renesas SH Mobile DRM\",\n\t.date\t\t\t= \"20120424\",\n\t.major\t\t\t= 1,\n\t.minor\t\t\t= 0,\n};\n\n \n\nstatic int shmob_drm_pm_suspend(struct device *dev)\n{\n\tstruct shmob_drm_device *sdev = dev_get_drvdata(dev);\n\n\tdrm_kms_helper_poll_disable(sdev->ddev);\n\tshmob_drm_crtc_suspend(&sdev->crtc);\n\n\treturn 0;\n}\n\nstatic int shmob_drm_pm_resume(struct device *dev)\n{\n\tstruct shmob_drm_device *sdev = dev_get_drvdata(dev);\n\n\tdrm_modeset_lock_all(sdev->ddev);\n\tshmob_drm_crtc_resume(&sdev->crtc);\n\tdrm_modeset_unlock_all(sdev->ddev);\n\n\tdrm_kms_helper_poll_enable(sdev->ddev);\n\treturn 0;\n}\n\nstatic DEFINE_SIMPLE_DEV_PM_OPS(shmob_drm_pm_ops,\n\t\t\t\tshmob_drm_pm_suspend, shmob_drm_pm_resume);\n\n \n\nstatic int shmob_drm_remove(struct platform_device *pdev)\n{\n\tstruct shmob_drm_device *sdev = platform_get_drvdata(pdev);\n\tstruct drm_device *ddev = sdev->ddev;\n\n\tdrm_dev_unregister(ddev);\n\tdrm_kms_helper_poll_fini(ddev);\n\tfree_irq(sdev->irq, ddev);\n\tdrm_dev_put(ddev);\n\n\treturn 0;\n}\n\nstatic int shmob_drm_probe(struct platform_device *pdev)\n{\n\tstruct shmob_drm_platform_data *pdata = pdev->dev.platform_data;\n\tstruct shmob_drm_device *sdev;\n\tstruct drm_device *ddev;\n\tunsigned int i;\n\tint ret;\n\n\tif (pdata == NULL) {\n\t\tdev_err(&pdev->dev, \"no platform data\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tsdev = devm_kzalloc(&pdev->dev, sizeof(*sdev), GFP_KERNEL);\n\tif (sdev == NULL)\n\t\treturn -ENOMEM;\n\n\tsdev->dev = &pdev->dev;\n\tsdev->pdata = pdata;\n\tspin_lock_init(&sdev->irq_lock);\n\n\tplatform_set_drvdata(pdev, sdev);\n\n\tsdev->mmio = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(sdev->mmio))\n\t\treturn PTR_ERR(sdev->mmio);\n\n\tret = shmob_drm_setup_clocks(sdev, pdata->clk_source);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = shmob_drm_init_interface(sdev);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tddev = drm_dev_alloc(&shmob_drm_driver, &pdev->dev);\n\tif (IS_ERR(ddev))\n\t\treturn PTR_ERR(ddev);\n\n\tsdev->ddev = ddev;\n\tddev->dev_private = sdev;\n\n\tret = shmob_drm_modeset_init(sdev);\n\tif (ret < 0) {\n\t\tdev_err(&pdev->dev, \"failed to initialize mode setting\\n\");\n\t\tgoto err_free_drm_dev;\n\t}\n\n\tfor (i = 0; i < 4; ++i) {\n\t\tret = shmob_drm_plane_create(sdev, i);\n\t\tif (ret < 0) {\n\t\t\tdev_err(&pdev->dev, \"failed to create plane %u\\n\", i);\n\t\t\tgoto err_modeset_cleanup;\n\t\t}\n\t}\n\n\tret = drm_vblank_init(ddev, 1);\n\tif (ret < 0) {\n\t\tdev_err(&pdev->dev, \"failed to initialize vblank\\n\");\n\t\tgoto err_modeset_cleanup;\n\t}\n\n\tret = platform_get_irq(pdev, 0);\n\tif (ret < 0)\n\t\tgoto err_modeset_cleanup;\n\tsdev->irq = ret;\n\n\tret = request_irq(sdev->irq, shmob_drm_irq, 0, ddev->driver->name,\n\t\t\t  ddev);\n\tif (ret < 0) {\n\t\tdev_err(&pdev->dev, \"failed to install IRQ handler\\n\");\n\t\tgoto err_modeset_cleanup;\n\t}\n\n\t \n\tret = drm_dev_register(ddev, 0);\n\tif (ret < 0)\n\t\tgoto err_irq_uninstall;\n\n\tdrm_fbdev_generic_setup(ddev, 16);\n\n\treturn 0;\n\nerr_irq_uninstall:\n\tfree_irq(sdev->irq, ddev);\nerr_modeset_cleanup:\n\tdrm_kms_helper_poll_fini(ddev);\nerr_free_drm_dev:\n\tdrm_dev_put(ddev);\n\n\treturn ret;\n}\n\nstatic struct platform_driver shmob_drm_platform_driver = {\n\t.probe\t\t= shmob_drm_probe,\n\t.remove\t\t= shmob_drm_remove,\n\t.driver\t\t= {\n\t\t.name\t= \"shmob-drm\",\n\t\t.pm\t= pm_sleep_ptr(&shmob_drm_pm_ops),\n\t},\n};\n\ndrm_module_platform_driver(shmob_drm_platform_driver);\n\nMODULE_AUTHOR(\"Laurent Pinchart <laurent.pinchart@ideasonboard.com>\");\nMODULE_DESCRIPTION(\"Renesas SH Mobile DRM Driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}