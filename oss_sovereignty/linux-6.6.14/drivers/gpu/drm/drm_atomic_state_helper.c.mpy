{
  "module_name": "drm_atomic_state_helper.c",
  "hash_id": "3239e2037dd80d3e767ede144986b3de41f0aa57c3957979d3fc5004d58c38ee",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/drm_atomic_state_helper.c",
  "human_readable_source": " \n\n#include <drm/drm_atomic.h>\n#include <drm/drm_atomic_state_helper.h>\n#include <drm/drm_blend.h>\n#include <drm/drm_bridge.h>\n#include <drm/drm_connector.h>\n#include <drm/drm_crtc.h>\n#include <drm/drm_device.h>\n#include <drm/drm_framebuffer.h>\n#include <drm/drm_plane.h>\n#include <drm/drm_print.h>\n#include <drm/drm_vblank.h>\n#include <drm/drm_writeback.h>\n\n#include <linux/slab.h>\n#include <linux/dma-fence.h>\n\n \n\n \nvoid\n__drm_atomic_helper_crtc_state_reset(struct drm_crtc_state *crtc_state,\n\t\t\t\t     struct drm_crtc *crtc)\n{\n\tcrtc_state->crtc = crtc;\n}\nEXPORT_SYMBOL(__drm_atomic_helper_crtc_state_reset);\n\n \nvoid\n__drm_atomic_helper_crtc_reset(struct drm_crtc *crtc,\n\t\t\t       struct drm_crtc_state *crtc_state)\n{\n\tif (crtc_state)\n\t\t__drm_atomic_helper_crtc_state_reset(crtc_state, crtc);\n\n\tif (drm_dev_has_vblank(crtc->dev))\n\t\tdrm_crtc_vblank_reset(crtc);\n\n\tcrtc->state = crtc_state;\n}\nEXPORT_SYMBOL(__drm_atomic_helper_crtc_reset);\n\n \nvoid drm_atomic_helper_crtc_reset(struct drm_crtc *crtc)\n{\n\tstruct drm_crtc_state *crtc_state =\n\t\tkzalloc(sizeof(*crtc->state), GFP_KERNEL);\n\n\tif (crtc->state)\n\t\tcrtc->funcs->atomic_destroy_state(crtc, crtc->state);\n\n\t__drm_atomic_helper_crtc_reset(crtc, crtc_state);\n}\nEXPORT_SYMBOL(drm_atomic_helper_crtc_reset);\n\n \nvoid __drm_atomic_helper_crtc_duplicate_state(struct drm_crtc *crtc,\n\t\t\t\t\t      struct drm_crtc_state *state)\n{\n\tmemcpy(state, crtc->state, sizeof(*state));\n\n\tif (state->mode_blob)\n\t\tdrm_property_blob_get(state->mode_blob);\n\tif (state->degamma_lut)\n\t\tdrm_property_blob_get(state->degamma_lut);\n\tif (state->ctm)\n\t\tdrm_property_blob_get(state->ctm);\n\tif (state->gamma_lut)\n\t\tdrm_property_blob_get(state->gamma_lut);\n\tstate->mode_changed = false;\n\tstate->active_changed = false;\n\tstate->planes_changed = false;\n\tstate->connectors_changed = false;\n\tstate->color_mgmt_changed = false;\n\tstate->zpos_changed = false;\n\tstate->commit = NULL;\n\tstate->event = NULL;\n\tstate->async_flip = false;\n\n\t \n\tstate->active = drm_atomic_crtc_effectively_active(state);\n\tstate->self_refresh_active = false;\n}\nEXPORT_SYMBOL(__drm_atomic_helper_crtc_duplicate_state);\n\n \nstruct drm_crtc_state *\ndrm_atomic_helper_crtc_duplicate_state(struct drm_crtc *crtc)\n{\n\tstruct drm_crtc_state *state;\n\n\tif (WARN_ON(!crtc->state))\n\t\treturn NULL;\n\n\tstate = kmalloc(sizeof(*state), GFP_KERNEL);\n\tif (state)\n\t\t__drm_atomic_helper_crtc_duplicate_state(crtc, state);\n\n\treturn state;\n}\nEXPORT_SYMBOL(drm_atomic_helper_crtc_duplicate_state);\n\n \nvoid __drm_atomic_helper_crtc_destroy_state(struct drm_crtc_state *state)\n{\n\tif (state->commit) {\n\t\t \n\t\tif (state->event && state->commit->abort_completion)\n\t\t\tdrm_crtc_commit_put(state->commit);\n\n\t\tkfree(state->commit->event);\n\t\tstate->commit->event = NULL;\n\n\t\tdrm_crtc_commit_put(state->commit);\n\t}\n\n\tdrm_property_blob_put(state->mode_blob);\n\tdrm_property_blob_put(state->degamma_lut);\n\tdrm_property_blob_put(state->ctm);\n\tdrm_property_blob_put(state->gamma_lut);\n}\nEXPORT_SYMBOL(__drm_atomic_helper_crtc_destroy_state);\n\n \nvoid drm_atomic_helper_crtc_destroy_state(struct drm_crtc *crtc,\n\t\t\t\t\t  struct drm_crtc_state *state)\n{\n\t__drm_atomic_helper_crtc_destroy_state(state);\n\tkfree(state);\n}\nEXPORT_SYMBOL(drm_atomic_helper_crtc_destroy_state);\n\n \nvoid __drm_atomic_helper_plane_state_reset(struct drm_plane_state *plane_state,\n\t\t\t\t\t   struct drm_plane *plane)\n{\n\tu64 val;\n\n\tplane_state->plane = plane;\n\tplane_state->rotation = DRM_MODE_ROTATE_0;\n\n\tplane_state->alpha = DRM_BLEND_ALPHA_OPAQUE;\n\tplane_state->pixel_blend_mode = DRM_MODE_BLEND_PREMULTI;\n\n\tif (plane->color_encoding_property) {\n\t\tif (!drm_object_property_get_default_value(&plane->base,\n\t\t\t\t\t\t\t   plane->color_encoding_property,\n\t\t\t\t\t\t\t   &val))\n\t\t\tplane_state->color_encoding = val;\n\t}\n\n\tif (plane->color_range_property) {\n\t\tif (!drm_object_property_get_default_value(&plane->base,\n\t\t\t\t\t\t\t   plane->color_range_property,\n\t\t\t\t\t\t\t   &val))\n\t\t\tplane_state->color_range = val;\n\t}\n\n\tif (plane->zpos_property) {\n\t\tif (!drm_object_property_get_default_value(&plane->base,\n\t\t\t\t\t\t\t   plane->zpos_property,\n\t\t\t\t\t\t\t   &val)) {\n\t\t\tplane_state->zpos = val;\n\t\t\tplane_state->normalized_zpos = val;\n\t\t}\n\t}\n}\nEXPORT_SYMBOL(__drm_atomic_helper_plane_state_reset);\n\n \nvoid __drm_atomic_helper_plane_reset(struct drm_plane *plane,\n\t\t\t\t     struct drm_plane_state *plane_state)\n{\n\tif (plane_state)\n\t\t__drm_atomic_helper_plane_state_reset(plane_state, plane);\n\n\tplane->state = plane_state;\n}\nEXPORT_SYMBOL(__drm_atomic_helper_plane_reset);\n\n \nvoid drm_atomic_helper_plane_reset(struct drm_plane *plane)\n{\n\tif (plane->state)\n\t\t__drm_atomic_helper_plane_destroy_state(plane->state);\n\n\tkfree(plane->state);\n\tplane->state = kzalloc(sizeof(*plane->state), GFP_KERNEL);\n\tif (plane->state)\n\t\t__drm_atomic_helper_plane_reset(plane, plane->state);\n}\nEXPORT_SYMBOL(drm_atomic_helper_plane_reset);\n\n \nvoid __drm_atomic_helper_plane_duplicate_state(struct drm_plane *plane,\n\t\t\t\t\t       struct drm_plane_state *state)\n{\n\tmemcpy(state, plane->state, sizeof(*state));\n\n\tif (state->fb)\n\t\tdrm_framebuffer_get(state->fb);\n\n\tstate->fence = NULL;\n\tstate->commit = NULL;\n\tstate->fb_damage_clips = NULL;\n}\nEXPORT_SYMBOL(__drm_atomic_helper_plane_duplicate_state);\n\n \nstruct drm_plane_state *\ndrm_atomic_helper_plane_duplicate_state(struct drm_plane *plane)\n{\n\tstruct drm_plane_state *state;\n\n\tif (WARN_ON(!plane->state))\n\t\treturn NULL;\n\n\tstate = kmalloc(sizeof(*state), GFP_KERNEL);\n\tif (state)\n\t\t__drm_atomic_helper_plane_duplicate_state(plane, state);\n\n\treturn state;\n}\nEXPORT_SYMBOL(drm_atomic_helper_plane_duplicate_state);\n\n \nvoid __drm_atomic_helper_plane_destroy_state(struct drm_plane_state *state)\n{\n\tif (state->fb)\n\t\tdrm_framebuffer_put(state->fb);\n\n\tif (state->fence)\n\t\tdma_fence_put(state->fence);\n\n\tif (state->commit)\n\t\tdrm_crtc_commit_put(state->commit);\n\n\tdrm_property_blob_put(state->fb_damage_clips);\n}\nEXPORT_SYMBOL(__drm_atomic_helper_plane_destroy_state);\n\n \nvoid drm_atomic_helper_plane_destroy_state(struct drm_plane *plane,\n\t\t\t\t\t   struct drm_plane_state *state)\n{\n\t__drm_atomic_helper_plane_destroy_state(state);\n\tkfree(state);\n}\nEXPORT_SYMBOL(drm_atomic_helper_plane_destroy_state);\n\n \nvoid\n__drm_atomic_helper_connector_state_reset(struct drm_connector_state *conn_state,\n\t\t\t\t\t  struct drm_connector *connector)\n{\n\tconn_state->connector = connector;\n}\nEXPORT_SYMBOL(__drm_atomic_helper_connector_state_reset);\n\n \nvoid\n__drm_atomic_helper_connector_reset(struct drm_connector *connector,\n\t\t\t\t    struct drm_connector_state *conn_state)\n{\n\tif (conn_state)\n\t\t__drm_atomic_helper_connector_state_reset(conn_state, connector);\n\n\tconnector->state = conn_state;\n}\nEXPORT_SYMBOL(__drm_atomic_helper_connector_reset);\n\n \nvoid drm_atomic_helper_connector_reset(struct drm_connector *connector)\n{\n\tstruct drm_connector_state *conn_state =\n\t\tkzalloc(sizeof(*conn_state), GFP_KERNEL);\n\n\tif (connector->state)\n\t\t__drm_atomic_helper_connector_destroy_state(connector->state);\n\n\tkfree(connector->state);\n\t__drm_atomic_helper_connector_reset(connector, conn_state);\n}\nEXPORT_SYMBOL(drm_atomic_helper_connector_reset);\n\n \nvoid drm_atomic_helper_connector_tv_margins_reset(struct drm_connector *connector)\n{\n\tstruct drm_cmdline_mode *cmdline = &connector->cmdline_mode;\n\tstruct drm_connector_state *state = connector->state;\n\n\tstate->tv.margins.left = cmdline->tv_margins.left;\n\tstate->tv.margins.right = cmdline->tv_margins.right;\n\tstate->tv.margins.top = cmdline->tv_margins.top;\n\tstate->tv.margins.bottom = cmdline->tv_margins.bottom;\n}\nEXPORT_SYMBOL(drm_atomic_helper_connector_tv_margins_reset);\n\n \nvoid drm_atomic_helper_connector_tv_reset(struct drm_connector *connector)\n{\n\tstruct drm_device *dev = connector->dev;\n\tstruct drm_cmdline_mode *cmdline = &connector->cmdline_mode;\n\tstruct drm_connector_state *state = connector->state;\n\tstruct drm_property *prop;\n\tuint64_t val;\n\n\tprop = dev->mode_config.tv_mode_property;\n\tif (prop)\n\t\tif (!drm_object_property_get_default_value(&connector->base,\n\t\t\t\t\t\t\t   prop, &val))\n\t\t\tstate->tv.mode = val;\n\n\tif (cmdline->tv_mode_specified)\n\t\tstate->tv.mode = cmdline->tv_mode;\n\n\tprop = dev->mode_config.tv_select_subconnector_property;\n\tif (prop)\n\t\tif (!drm_object_property_get_default_value(&connector->base,\n\t\t\t\t\t\t\t   prop, &val))\n\t\t\tstate->tv.select_subconnector = val;\n\n\tprop = dev->mode_config.tv_subconnector_property;\n\tif (prop)\n\t\tif (!drm_object_property_get_default_value(&connector->base,\n\t\t\t\t\t\t\t   prop, &val))\n\t\t\tstate->tv.subconnector = val;\n\n\tprop = dev->mode_config.tv_brightness_property;\n\tif (prop)\n\t\tif (!drm_object_property_get_default_value(&connector->base,\n\t\t\t\t\t\t\t   prop, &val))\n\t\t\tstate->tv.brightness = val;\n\n\tprop = dev->mode_config.tv_contrast_property;\n\tif (prop)\n\t\tif (!drm_object_property_get_default_value(&connector->base,\n\t\t\t\t\t\t\t   prop, &val))\n\t\t\tstate->tv.contrast = val;\n\n\tprop = dev->mode_config.tv_flicker_reduction_property;\n\tif (prop)\n\t\tif (!drm_object_property_get_default_value(&connector->base,\n\t\t\t\t\t\t\t   prop, &val))\n\t\t\tstate->tv.flicker_reduction = val;\n\n\tprop = dev->mode_config.tv_overscan_property;\n\tif (prop)\n\t\tif (!drm_object_property_get_default_value(&connector->base,\n\t\t\t\t\t\t\t   prop, &val))\n\t\t\tstate->tv.overscan = val;\n\n\tprop = dev->mode_config.tv_saturation_property;\n\tif (prop)\n\t\tif (!drm_object_property_get_default_value(&connector->base,\n\t\t\t\t\t\t\t   prop, &val))\n\t\t\tstate->tv.saturation = val;\n\n\tprop = dev->mode_config.tv_hue_property;\n\tif (prop)\n\t\tif (!drm_object_property_get_default_value(&connector->base,\n\t\t\t\t\t\t\t   prop, &val))\n\t\t\tstate->tv.hue = val;\n\n\tdrm_atomic_helper_connector_tv_margins_reset(connector);\n}\nEXPORT_SYMBOL(drm_atomic_helper_connector_tv_reset);\n\n \nint drm_atomic_helper_connector_tv_check(struct drm_connector *connector,\n\t\t\t\t\t struct drm_atomic_state *state)\n{\n\tstruct drm_connector_state *old_conn_state =\n\t\tdrm_atomic_get_old_connector_state(state, connector);\n\tstruct drm_connector_state *new_conn_state =\n\t\tdrm_atomic_get_new_connector_state(state, connector);\n\tstruct drm_crtc_state *crtc_state;\n\tstruct drm_crtc *crtc;\n\n\tcrtc = new_conn_state->crtc;\n\tif (!crtc)\n\t\treturn 0;\n\n\tcrtc_state = drm_atomic_get_new_crtc_state(state, crtc);\n\tif (!crtc_state)\n\t\treturn -EINVAL;\n\n\tif (old_conn_state->tv.mode != new_conn_state->tv.mode)\n\t\tcrtc_state->mode_changed = true;\n\n\tif (old_conn_state->tv.margins.left != new_conn_state->tv.margins.left ||\n\t    old_conn_state->tv.margins.right != new_conn_state->tv.margins.right ||\n\t    old_conn_state->tv.margins.top != new_conn_state->tv.margins.top ||\n\t    old_conn_state->tv.margins.bottom != new_conn_state->tv.margins.bottom ||\n\t    old_conn_state->tv.mode != new_conn_state->tv.mode ||\n\t    old_conn_state->tv.brightness != new_conn_state->tv.brightness ||\n\t    old_conn_state->tv.contrast != new_conn_state->tv.contrast ||\n\t    old_conn_state->tv.flicker_reduction != new_conn_state->tv.flicker_reduction ||\n\t    old_conn_state->tv.overscan != new_conn_state->tv.overscan ||\n\t    old_conn_state->tv.saturation != new_conn_state->tv.saturation ||\n\t    old_conn_state->tv.hue != new_conn_state->tv.hue)\n\t\tcrtc_state->connectors_changed = true;\n\n\treturn 0;\n}\nEXPORT_SYMBOL(drm_atomic_helper_connector_tv_check);\n\n \nvoid\n__drm_atomic_helper_connector_duplicate_state(struct drm_connector *connector,\n\t\t\t\t\t    struct drm_connector_state *state)\n{\n\tmemcpy(state, connector->state, sizeof(*state));\n\tif (state->crtc)\n\t\tdrm_connector_get(connector);\n\tstate->commit = NULL;\n\n\tif (state->hdr_output_metadata)\n\t\tdrm_property_blob_get(state->hdr_output_metadata);\n\n\t \n\tstate->writeback_job = NULL;\n}\nEXPORT_SYMBOL(__drm_atomic_helper_connector_duplicate_state);\n\n \nstruct drm_connector_state *\ndrm_atomic_helper_connector_duplicate_state(struct drm_connector *connector)\n{\n\tstruct drm_connector_state *state;\n\n\tif (WARN_ON(!connector->state))\n\t\treturn NULL;\n\n\tstate = kmalloc(sizeof(*state), GFP_KERNEL);\n\tif (state)\n\t\t__drm_atomic_helper_connector_duplicate_state(connector, state);\n\n\treturn state;\n}\nEXPORT_SYMBOL(drm_atomic_helper_connector_duplicate_state);\n\n \nvoid\n__drm_atomic_helper_connector_destroy_state(struct drm_connector_state *state)\n{\n\tif (state->crtc)\n\t\tdrm_connector_put(state->connector);\n\n\tif (state->commit)\n\t\tdrm_crtc_commit_put(state->commit);\n\n\tif (state->writeback_job)\n\t\tdrm_writeback_cleanup_job(state->writeback_job);\n\n\tdrm_property_blob_put(state->hdr_output_metadata);\n}\nEXPORT_SYMBOL(__drm_atomic_helper_connector_destroy_state);\n\n \nvoid drm_atomic_helper_connector_destroy_state(struct drm_connector *connector,\n\t\t\t\t\t  struct drm_connector_state *state)\n{\n\t__drm_atomic_helper_connector_destroy_state(state);\n\tkfree(state);\n}\nEXPORT_SYMBOL(drm_atomic_helper_connector_destroy_state);\n\n \nvoid __drm_atomic_helper_private_obj_duplicate_state(struct drm_private_obj *obj,\n\t\t\t\t\t\t     struct drm_private_state *state)\n{\n\tmemcpy(state, obj->state, sizeof(*state));\n}\nEXPORT_SYMBOL(__drm_atomic_helper_private_obj_duplicate_state);\n\n \nvoid __drm_atomic_helper_bridge_duplicate_state(struct drm_bridge *bridge,\n\t\t\t\t\t\tstruct drm_bridge_state *state)\n{\n\t__drm_atomic_helper_private_obj_duplicate_state(&bridge->base,\n\t\t\t\t\t\t\t&state->base);\n\tstate->bridge = bridge;\n}\nEXPORT_SYMBOL(__drm_atomic_helper_bridge_duplicate_state);\n\n \nstruct drm_bridge_state *\ndrm_atomic_helper_bridge_duplicate_state(struct drm_bridge *bridge)\n{\n\tstruct drm_bridge_state *new;\n\n\tif (WARN_ON(!bridge->base.state))\n\t\treturn NULL;\n\n\tnew = kzalloc(sizeof(*new), GFP_KERNEL);\n\tif (new)\n\t\t__drm_atomic_helper_bridge_duplicate_state(bridge, new);\n\n\treturn new;\n}\nEXPORT_SYMBOL(drm_atomic_helper_bridge_duplicate_state);\n\n \nvoid drm_atomic_helper_bridge_destroy_state(struct drm_bridge *bridge,\n\t\t\t\t\t    struct drm_bridge_state *state)\n{\n\tkfree(state);\n}\nEXPORT_SYMBOL(drm_atomic_helper_bridge_destroy_state);\n\n \nvoid __drm_atomic_helper_bridge_reset(struct drm_bridge *bridge,\n\t\t\t\t      struct drm_bridge_state *state)\n{\n\tmemset(state, 0, sizeof(*state));\n\tstate->bridge = bridge;\n}\nEXPORT_SYMBOL(__drm_atomic_helper_bridge_reset);\n\n \nstruct drm_bridge_state *\ndrm_atomic_helper_bridge_reset(struct drm_bridge *bridge)\n{\n\tstruct drm_bridge_state *bridge_state;\n\n\tbridge_state = kzalloc(sizeof(*bridge_state), GFP_KERNEL);\n\tif (!bridge_state)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\t__drm_atomic_helper_bridge_reset(bridge, bridge_state);\n\treturn bridge_state;\n}\nEXPORT_SYMBOL(drm_atomic_helper_bridge_reset);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}