{
  "module_name": "armada_crtc.c",
  "hash_id": "ca74bef04f8f15cbc4b2cf425a8695b2ad228682b76c6d68395541a0f366b39d",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/armada/armada_crtc.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/component.h>\n#include <linux/module.h>\n#include <linux/of_device.h>\n#include <linux/platform_device.h>\n\n#include <drm/drm_atomic.h>\n#include <drm/drm_atomic_helper.h>\n#include <drm/drm_probe_helper.h>\n#include <drm/drm_vblank.h>\n\n#include \"armada_crtc.h\"\n#include \"armada_drm.h\"\n#include \"armada_fb.h\"\n#include \"armada_gem.h\"\n#include \"armada_hw.h\"\n#include \"armada_plane.h\"\n#include \"armada_trace.h\"\n\n \n\nvoid\narmada_drm_crtc_update_regs(struct armada_crtc *dcrtc, struct armada_regs *regs)\n{\n\twhile (regs->offset != ~0) {\n\t\tvoid __iomem *reg = dcrtc->base + regs->offset;\n\t\tuint32_t val;\n\n\t\tval = regs->mask;\n\t\tif (val != 0)\n\t\t\tval &= readl_relaxed(reg);\n\t\twritel_relaxed(val | regs->val, reg);\n\t\t++regs;\n\t}\n}\n\nstatic void armada_drm_crtc_update(struct armada_crtc *dcrtc, bool enable)\n{\n\tuint32_t dumb_ctrl;\n\n\tdumb_ctrl = dcrtc->cfg_dumb_ctrl;\n\n\tif (enable)\n\t\tdumb_ctrl |= CFG_DUMB_ENA;\n\n\t \n\tif (!enable && (dumb_ctrl & DUMB_MASK) == DUMB24_RGB888_0) {\n\t\tdumb_ctrl &= ~DUMB_MASK;\n\t\tdumb_ctrl |= DUMB_BLANK;\n\t}\n\n\tarmada_updatel(dumb_ctrl,\n\t\t       ~(CFG_INV_CSYNC | CFG_INV_HSYNC | CFG_INV_VSYNC),\n\t\t       dcrtc->base + LCD_SPU_DUMB_CTRL);\n}\n\nstatic void armada_drm_crtc_queue_state_event(struct drm_crtc *crtc)\n{\n\tstruct armada_crtc *dcrtc = drm_to_armada_crtc(crtc);\n\tstruct drm_pending_vblank_event *event;\n\n\t \n\tevent = xchg(&crtc->state->event, NULL);\n\tif (event) {\n\t\tWARN_ON(drm_crtc_vblank_get(crtc) != 0);\n\t\tdcrtc->event = event;\n\t}\n}\n\nstatic void armada_drm_update_gamma(struct drm_crtc *crtc)\n{\n\tstruct drm_property_blob *blob = crtc->state->gamma_lut;\n\tvoid __iomem *base = drm_to_armada_crtc(crtc)->base;\n\tint i;\n\n\tif (blob) {\n\t\tstruct drm_color_lut *lut = blob->data;\n\n\t\tarmada_updatel(CFG_CSB_256x8, CFG_CSB_256x8 | CFG_PDWN256x8,\n\t\t\t       base + LCD_SPU_SRAM_PARA1);\n\n\t\tfor (i = 0; i < 256; i++) {\n\t\t\twritel_relaxed(drm_color_lut_extract(lut[i].red, 8),\n\t\t\t\t       base + LCD_SPU_SRAM_WRDAT);\n\t\t\twritel_relaxed(i | SRAM_WRITE | SRAM_GAMMA_YR,\n\t\t\t\t       base + LCD_SPU_SRAM_CTRL);\n\t\t\treadl_relaxed(base + LCD_SPU_HWC_OVSA_HPXL_VLN);\n\t\t\twritel_relaxed(drm_color_lut_extract(lut[i].green, 8),\n\t\t\t\t       base + LCD_SPU_SRAM_WRDAT);\n\t\t\twritel_relaxed(i | SRAM_WRITE | SRAM_GAMMA_UG,\n\t\t\t\t       base + LCD_SPU_SRAM_CTRL);\n\t\t\treadl_relaxed(base + LCD_SPU_HWC_OVSA_HPXL_VLN);\n\t\t\twritel_relaxed(drm_color_lut_extract(lut[i].blue, 8),\n\t\t\t\t       base + LCD_SPU_SRAM_WRDAT);\n\t\t\twritel_relaxed(i | SRAM_WRITE | SRAM_GAMMA_VB,\n\t\t\t\t       base + LCD_SPU_SRAM_CTRL);\n\t\t\treadl_relaxed(base + LCD_SPU_HWC_OVSA_HPXL_VLN);\n\t\t}\n\t\tarmada_updatel(CFG_GAMMA_ENA, CFG_GAMMA_ENA,\n\t\t\t       base + LCD_SPU_DMA_CTRL0);\n\t} else {\n\t\tarmada_updatel(0, CFG_GAMMA_ENA, base + LCD_SPU_DMA_CTRL0);\n\t\tarmada_updatel(CFG_PDWN256x8, CFG_CSB_256x8 | CFG_PDWN256x8,\n\t\t\t       base + LCD_SPU_SRAM_PARA1);\n\t}\n}\n\nstatic enum drm_mode_status armada_drm_crtc_mode_valid(struct drm_crtc *crtc,\n\tconst struct drm_display_mode *mode)\n{\n\tstruct armada_crtc *dcrtc = drm_to_armada_crtc(crtc);\n\n\tif (mode->vscan > 1)\n\t\treturn MODE_NO_VSCAN;\n\n\tif (mode->flags & DRM_MODE_FLAG_DBLSCAN)\n\t\treturn MODE_NO_DBLESCAN;\n\n\tif (mode->flags & DRM_MODE_FLAG_HSKEW)\n\t\treturn MODE_H_ILLEGAL;\n\n\t \n\tif (!dcrtc->variant->has_spu_adv_reg &&\n\t    mode->flags & DRM_MODE_FLAG_INTERLACE)\n\t\treturn MODE_NO_INTERLACE;\n\n\tif (mode->flags & (DRM_MODE_FLAG_BCAST | DRM_MODE_FLAG_PIXMUX |\n\t\t\t   DRM_MODE_FLAG_CLKDIV2))\n\t\treturn MODE_BAD;\n\n\treturn MODE_OK;\n}\n\n \nstatic bool armada_drm_crtc_mode_fixup(struct drm_crtc *crtc,\n\tconst struct drm_display_mode *mode, struct drm_display_mode *adj)\n{\n\tstruct armada_crtc *dcrtc = drm_to_armada_crtc(crtc);\n\tint ret;\n\n\t \n\tdrm_mode_set_crtcinfo(adj, CRTC_INTERLACE_HALVE_V);\n\n\t \n\tif (armada_drm_crtc_mode_valid(crtc, adj) != MODE_OK)\n\t\treturn false;\n\n\t \n\tret = dcrtc->variant->compute_clock(dcrtc, adj, NULL);\n\tif (ret)\n\t\treturn false;\n\n\treturn true;\n}\n\n \nstatic void armada_drm_crtc_disable_irq(struct armada_crtc *dcrtc, u32 mask)\n{\n\tif (dcrtc->irq_ena & mask) {\n\t\tdcrtc->irq_ena &= ~mask;\n\t\twritel(dcrtc->irq_ena, dcrtc->base + LCD_SPU_IRQ_ENA);\n\t}\n}\n\nstatic void armada_drm_crtc_enable_irq(struct armada_crtc *dcrtc, u32 mask)\n{\n\tif ((dcrtc->irq_ena & mask) != mask) {\n\t\tdcrtc->irq_ena |= mask;\n\t\twritel(dcrtc->irq_ena, dcrtc->base + LCD_SPU_IRQ_ENA);\n\t\tif (readl_relaxed(dcrtc->base + LCD_SPU_IRQ_ISR) & mask)\n\t\t\twritel(0, dcrtc->base + LCD_SPU_IRQ_ISR);\n\t}\n}\n\nstatic void armada_drm_crtc_irq(struct armada_crtc *dcrtc, u32 stat)\n{\n\tstruct drm_pending_vblank_event *event;\n\tvoid __iomem *base = dcrtc->base;\n\n\tif (stat & DMA_FF_UNDERFLOW)\n\t\tDRM_ERROR(\"video underflow on crtc %u\\n\", dcrtc->num);\n\tif (stat & GRA_FF_UNDERFLOW)\n\t\tDRM_ERROR(\"graphics underflow on crtc %u\\n\", dcrtc->num);\n\n\tif (stat & VSYNC_IRQ)\n\t\tdrm_crtc_handle_vblank(&dcrtc->crtc);\n\n\tspin_lock(&dcrtc->irq_lock);\n\tif (stat & GRA_FRAME_IRQ && dcrtc->interlaced) {\n\t\tint i = stat & GRA_FRAME_IRQ0 ? 0 : 1;\n\t\tuint32_t val;\n\n\t\twritel_relaxed(dcrtc->v[i].spu_v_porch, base + LCD_SPU_V_PORCH);\n\t\twritel_relaxed(dcrtc->v[i].spu_v_h_total,\n\t\t\t       base + LCD_SPUT_V_H_TOTAL);\n\n\t\tval = readl_relaxed(base + LCD_SPU_ADV_REG);\n\t\tval &= ~(ADV_VSYNC_L_OFF | ADV_VSYNC_H_OFF | ADV_VSYNCOFFEN);\n\t\tval |= dcrtc->v[i].spu_adv_reg;\n\t\twritel_relaxed(val, base + LCD_SPU_ADV_REG);\n\t}\n\n\tif (stat & dcrtc->irq_ena & DUMB_FRAMEDONE) {\n\t\tif (dcrtc->update_pending) {\n\t\t\tarmada_drm_crtc_update_regs(dcrtc, dcrtc->regs);\n\t\t\tdcrtc->update_pending = false;\n\t\t}\n\t\tif (dcrtc->cursor_update) {\n\t\t\twritel_relaxed(dcrtc->cursor_hw_pos,\n\t\t\t\t       base + LCD_SPU_HWC_OVSA_HPXL_VLN);\n\t\t\twritel_relaxed(dcrtc->cursor_hw_sz,\n\t\t\t\t       base + LCD_SPU_HWC_HPXL_VLN);\n\t\t\tarmada_updatel(CFG_HWC_ENA,\n\t\t\t\t       CFG_HWC_ENA | CFG_HWC_1BITMOD |\n\t\t\t\t       CFG_HWC_1BITENA,\n\t\t\t\t       base + LCD_SPU_DMA_CTRL0);\n\t\t\tdcrtc->cursor_update = false;\n\t\t}\n\t\tarmada_drm_crtc_disable_irq(dcrtc, DUMB_FRAMEDONE_ENA);\n\t}\n\tspin_unlock(&dcrtc->irq_lock);\n\n\tif (stat & VSYNC_IRQ && !dcrtc->update_pending) {\n\t\tevent = xchg(&dcrtc->event, NULL);\n\t\tif (event) {\n\t\t\tspin_lock(&dcrtc->crtc.dev->event_lock);\n\t\t\tdrm_crtc_send_vblank_event(&dcrtc->crtc, event);\n\t\t\tspin_unlock(&dcrtc->crtc.dev->event_lock);\n\t\t\tdrm_crtc_vblank_put(&dcrtc->crtc);\n\t\t}\n\t}\n}\n\nstatic irqreturn_t armada_drm_irq(int irq, void *arg)\n{\n\tstruct armada_crtc *dcrtc = arg;\n\tu32 v, stat = readl_relaxed(dcrtc->base + LCD_SPU_IRQ_ISR);\n\n\t \n\twritel_relaxed(0, dcrtc->base + LCD_SPU_IRQ_ISR);\n\n\ttrace_armada_drm_irq(&dcrtc->crtc, stat);\n\n\t \n\tv = stat & dcrtc->irq_ena;\n\n\tif (v & (VSYNC_IRQ|GRA_FRAME_IRQ|DUMB_FRAMEDONE)) {\n\t\tarmada_drm_crtc_irq(dcrtc, stat);\n\t\treturn IRQ_HANDLED;\n\t}\n\treturn IRQ_NONE;\n}\n\n \nstatic void armada_drm_crtc_mode_set_nofb(struct drm_crtc *crtc)\n{\n\tstruct drm_display_mode *adj = &crtc->state->adjusted_mode;\n\tstruct armada_crtc *dcrtc = drm_to_armada_crtc(crtc);\n\tstruct armada_regs regs[17];\n\tuint32_t lm, rm, tm, bm, val, sclk;\n\tunsigned long flags;\n\tunsigned i;\n\tbool interlaced = !!(adj->flags & DRM_MODE_FLAG_INTERLACE);\n\n\ti = 0;\n\trm = adj->crtc_hsync_start - adj->crtc_hdisplay;\n\tlm = adj->crtc_htotal - adj->crtc_hsync_end;\n\tbm = adj->crtc_vsync_start - adj->crtc_vdisplay;\n\ttm = adj->crtc_vtotal - adj->crtc_vsync_end;\n\n\tDRM_DEBUG_KMS(\"[CRTC:%d:%s] mode \" DRM_MODE_FMT \"\\n\",\n\t\t      crtc->base.id, crtc->name, DRM_MODE_ARG(adj));\n\tDRM_DEBUG_KMS(\"lm %d rm %d tm %d bm %d\\n\", lm, rm, tm, bm);\n\n\t \n\tdcrtc->variant->compute_clock(dcrtc, adj, &sclk);\n\n\tarmada_reg_queue_set(regs, i, sclk, LCD_CFG_SCLK_DIV);\n\n\tspin_lock_irqsave(&dcrtc->irq_lock, flags);\n\n\tdcrtc->interlaced = interlaced;\n\t \n\tdcrtc->v[1].spu_v_h_total = adj->crtc_vtotal << 16 |\n\t\t\t\t    adj->crtc_htotal;\n\tdcrtc->v[1].spu_v_porch = tm << 16 | bm;\n\tval = adj->crtc_hsync_start;\n\tdcrtc->v[1].spu_adv_reg = val << 20 | val | ADV_VSYNCOFFEN;\n\n\tif (interlaced) {\n\t\t \n\t\tval -= adj->crtc_htotal / 2;\n\t\tdcrtc->v[0].spu_adv_reg = val << 20 | val | ADV_VSYNCOFFEN;\n\t\tdcrtc->v[0].spu_v_h_total = dcrtc->v[1].spu_v_h_total +\n\t\t\t\t\t\t(1 << 16);\n\t\tdcrtc->v[0].spu_v_porch = dcrtc->v[1].spu_v_porch + 1;\n\t} else {\n\t\tdcrtc->v[0] = dcrtc->v[1];\n\t}\n\n\tval = adj->crtc_vdisplay << 16 | adj->crtc_hdisplay;\n\n\tarmada_reg_queue_set(regs, i, val, LCD_SPU_V_H_ACTIVE);\n\tarmada_reg_queue_set(regs, i, (lm << 16) | rm, LCD_SPU_H_PORCH);\n\tarmada_reg_queue_set(regs, i, dcrtc->v[0].spu_v_porch, LCD_SPU_V_PORCH);\n\tarmada_reg_queue_set(regs, i, dcrtc->v[0].spu_v_h_total,\n\t\t\t   LCD_SPUT_V_H_TOTAL);\n\n\tif (dcrtc->variant->has_spu_adv_reg)\n\t\tarmada_reg_queue_mod(regs, i, dcrtc->v[0].spu_adv_reg,\n\t\t\t\t     ADV_VSYNC_L_OFF | ADV_VSYNC_H_OFF |\n\t\t\t\t     ADV_VSYNCOFFEN, LCD_SPU_ADV_REG);\n\n\tval = adj->flags & DRM_MODE_FLAG_NVSYNC ? CFG_VSYNC_INV : 0;\n\tarmada_reg_queue_mod(regs, i, val, CFG_VSYNC_INV, LCD_SPU_DMA_CTRL1);\n\n\t \n\tval = 0;\n\tif (adj->flags & DRM_MODE_FLAG_NCSYNC)\n\t\tval |= CFG_INV_CSYNC;\n\tif (adj->flags & DRM_MODE_FLAG_NHSYNC)\n\t\tval |= CFG_INV_HSYNC;\n\tif (adj->flags & DRM_MODE_FLAG_NVSYNC)\n\t\tval |= CFG_INV_VSYNC;\n\tarmada_reg_queue_mod(regs, i, val, CFG_INV_CSYNC | CFG_INV_HSYNC |\n\t\t\t     CFG_INV_VSYNC, LCD_SPU_DUMB_CTRL);\n\tarmada_reg_queue_end(regs, i);\n\n\tarmada_drm_crtc_update_regs(dcrtc, regs);\n\tspin_unlock_irqrestore(&dcrtc->irq_lock, flags);\n}\n\nstatic int armada_drm_crtc_atomic_check(struct drm_crtc *crtc,\n\t\t\t\t\tstruct drm_atomic_state *state)\n{\n\tstruct drm_crtc_state *crtc_state = drm_atomic_get_new_crtc_state(state,\n\t\t\t\t\t\t\t\t\t  crtc);\n\tDRM_DEBUG_KMS(\"[CRTC:%d:%s]\\n\", crtc->base.id, crtc->name);\n\n\tif (crtc_state->gamma_lut && drm_color_lut_size(crtc_state->gamma_lut) != 256)\n\t\treturn -EINVAL;\n\n\tif (crtc_state->color_mgmt_changed)\n\t\tcrtc_state->planes_changed = true;\n\n\treturn 0;\n}\n\nstatic void armada_drm_crtc_atomic_begin(struct drm_crtc *crtc,\n\t\t\t\t\t struct drm_atomic_state *state)\n{\n\tstruct drm_crtc_state *crtc_state = drm_atomic_get_new_crtc_state(state,\n\t\t\t\t\t\t\t\t\t  crtc);\n\tstruct armada_crtc *dcrtc = drm_to_armada_crtc(crtc);\n\n\tDRM_DEBUG_KMS(\"[CRTC:%d:%s]\\n\", crtc->base.id, crtc->name);\n\n\tif (crtc_state->color_mgmt_changed)\n\t\tarmada_drm_update_gamma(crtc);\n\n\tdcrtc->regs_idx = 0;\n\tdcrtc->regs = dcrtc->atomic_regs;\n}\n\nstatic void armada_drm_crtc_atomic_flush(struct drm_crtc *crtc,\n\t\t\t\t\t struct drm_atomic_state *state)\n{\n\tstruct drm_crtc_state *crtc_state = drm_atomic_get_new_crtc_state(state,\n\t\t\t\t\t\t\t\t\t  crtc);\n\tstruct armada_crtc *dcrtc = drm_to_armada_crtc(crtc);\n\n\tDRM_DEBUG_KMS(\"[CRTC:%d:%s]\\n\", crtc->base.id, crtc->name);\n\n\tarmada_reg_queue_end(dcrtc->regs, dcrtc->regs_idx);\n\n\t \n\tif (!drm_atomic_crtc_needs_modeset(crtc_state)) {\n\t\tdcrtc->update_pending = true;\n\t\tarmada_drm_crtc_queue_state_event(crtc);\n\t\tspin_lock_irq(&dcrtc->irq_lock);\n\t\tarmada_drm_crtc_enable_irq(dcrtc, DUMB_FRAMEDONE_ENA);\n\t\tspin_unlock_irq(&dcrtc->irq_lock);\n\t} else {\n\t\tspin_lock_irq(&dcrtc->irq_lock);\n\t\tarmada_drm_crtc_update_regs(dcrtc, dcrtc->regs);\n\t\tspin_unlock_irq(&dcrtc->irq_lock);\n\t}\n}\n\nstatic void armada_drm_crtc_atomic_disable(struct drm_crtc *crtc,\n\t\t\t\t\t   struct drm_atomic_state *state)\n{\n\tstruct drm_crtc_state *old_state = drm_atomic_get_old_crtc_state(state,\n\t\t\t\t\t\t\t\t\t crtc);\n\tstruct armada_crtc *dcrtc = drm_to_armada_crtc(crtc);\n\tstruct drm_pending_vblank_event *event;\n\n\tDRM_DEBUG_KMS(\"[CRTC:%d:%s]\\n\", crtc->base.id, crtc->name);\n\n\tif (old_state->adjusted_mode.flags & DRM_MODE_FLAG_INTERLACE)\n\t\tdrm_crtc_vblank_put(crtc);\n\n\tdrm_crtc_vblank_off(crtc);\n\tarmada_drm_crtc_update(dcrtc, false);\n\n\tif (!crtc->state->active) {\n\t\t \n\t\tif (dcrtc->variant->disable)\n\t\t\tdcrtc->variant->disable(dcrtc);\n\n\t\t \n\t\tevent = crtc->state->event;\n\t\tcrtc->state->event = NULL;\n\t\tif (event) {\n\t\t\tspin_lock_irq(&crtc->dev->event_lock);\n\t\t\tdrm_crtc_send_vblank_event(crtc, event);\n\t\t\tspin_unlock_irq(&crtc->dev->event_lock);\n\t\t}\n\t}\n}\n\nstatic void armada_drm_crtc_atomic_enable(struct drm_crtc *crtc,\n\t\t\t\t\t  struct drm_atomic_state *state)\n{\n\tstruct drm_crtc_state *old_state = drm_atomic_get_old_crtc_state(state,\n\t\t\t\t\t\t\t\t\t crtc);\n\tstruct armada_crtc *dcrtc = drm_to_armada_crtc(crtc);\n\n\tDRM_DEBUG_KMS(\"[CRTC:%d:%s]\\n\", crtc->base.id, crtc->name);\n\n\tif (!old_state->active) {\n\t\t \n\t\tif (dcrtc->variant->enable)\n\t\t\tdcrtc->variant->enable(dcrtc, &crtc->state->adjusted_mode);\n\t}\n\tarmada_drm_crtc_update(dcrtc, true);\n\tdrm_crtc_vblank_on(crtc);\n\n\tif (crtc->state->adjusted_mode.flags & DRM_MODE_FLAG_INTERLACE)\n\t\tWARN_ON(drm_crtc_vblank_get(crtc));\n\n\tarmada_drm_crtc_queue_state_event(crtc);\n}\n\nstatic const struct drm_crtc_helper_funcs armada_crtc_helper_funcs = {\n\t.mode_valid\t= armada_drm_crtc_mode_valid,\n\t.mode_fixup\t= armada_drm_crtc_mode_fixup,\n\t.mode_set_nofb\t= armada_drm_crtc_mode_set_nofb,\n\t.atomic_check\t= armada_drm_crtc_atomic_check,\n\t.atomic_begin\t= armada_drm_crtc_atomic_begin,\n\t.atomic_flush\t= armada_drm_crtc_atomic_flush,\n\t.atomic_disable\t= armada_drm_crtc_atomic_disable,\n\t.atomic_enable\t= armada_drm_crtc_atomic_enable,\n};\n\nstatic void armada_load_cursor_argb(void __iomem *base, uint32_t *pix,\n\tunsigned stride, unsigned width, unsigned height)\n{\n\tuint32_t addr;\n\tunsigned y;\n\n\taddr = SRAM_HWC32_RAM1;\n\tfor (y = 0; y < height; y++) {\n\t\tuint32_t *p = &pix[y * stride];\n\t\tunsigned x;\n\n\t\tfor (x = 0; x < width; x++, p++) {\n\t\t\tuint32_t val = *p;\n\n\t\t\t \n\t\t\tval = (val & 0xff00ff00) |\n\t\t\t      (val & 0x000000ff) << 16 |\n\t\t\t      (val & 0x00ff0000) >> 16;\n\n\t\t\twritel_relaxed(val,\n\t\t\t\t       base + LCD_SPU_SRAM_WRDAT);\n\t\t\twritel_relaxed(addr | SRAM_WRITE,\n\t\t\t\t       base + LCD_SPU_SRAM_CTRL);\n\t\t\treadl_relaxed(base + LCD_SPU_HWC_OVSA_HPXL_VLN);\n\t\t\taddr += 1;\n\t\t\tif ((addr & 0x00ff) == 0)\n\t\t\t\taddr += 0xf00;\n\t\t\tif ((addr & 0x30ff) == 0)\n\t\t\t\taddr = SRAM_HWC32_RAM2;\n\t\t}\n\t}\n}\n\nstatic void armada_drm_crtc_cursor_tran(void __iomem *base)\n{\n\tunsigned addr;\n\n\tfor (addr = 0; addr < 256; addr++) {\n\t\t \n\t\twritel_relaxed(0x55555555, base + LCD_SPU_SRAM_WRDAT);\n\t\twritel_relaxed(addr | SRAM_WRITE | SRAM_HWC32_TRAN,\n\t\t\t       base + LCD_SPU_SRAM_CTRL);\n\t}\n}\n\nstatic int armada_drm_crtc_cursor_update(struct armada_crtc *dcrtc, bool reload)\n{\n\tuint32_t xoff, xscr, w = dcrtc->cursor_w, s;\n\tuint32_t yoff, yscr, h = dcrtc->cursor_h;\n\tuint32_t para1;\n\n\t \n\tif (dcrtc->cursor_x < 0) {\n\t\txoff = -dcrtc->cursor_x;\n\t\txscr = 0;\n\t\tw -= min(xoff, w);\n\t} else if (dcrtc->cursor_x + w > dcrtc->crtc.mode.hdisplay) {\n\t\txoff = 0;\n\t\txscr = dcrtc->cursor_x;\n\t\tw = max_t(int, dcrtc->crtc.mode.hdisplay - dcrtc->cursor_x, 0);\n\t} else {\n\t\txoff = 0;\n\t\txscr = dcrtc->cursor_x;\n\t}\n\n\tif (dcrtc->cursor_y < 0) {\n\t\tyoff = -dcrtc->cursor_y;\n\t\tyscr = 0;\n\t\th -= min(yoff, h);\n\t} else if (dcrtc->cursor_y + h > dcrtc->crtc.mode.vdisplay) {\n\t\tyoff = 0;\n\t\tyscr = dcrtc->cursor_y;\n\t\th = max_t(int, dcrtc->crtc.mode.vdisplay - dcrtc->cursor_y, 0);\n\t} else {\n\t\tyoff = 0;\n\t\tyscr = dcrtc->cursor_y;\n\t}\n\n\t \n\ts = dcrtc->cursor_w;\n\tif (dcrtc->interlaced) {\n\t\ts *= 2;\n\t\tyscr /= 2;\n\t\th /= 2;\n\t}\n\n\tif (!dcrtc->cursor_obj || !h || !w) {\n\t\tspin_lock_irq(&dcrtc->irq_lock);\n\t\tdcrtc->cursor_update = false;\n\t\tarmada_updatel(0, CFG_HWC_ENA, dcrtc->base + LCD_SPU_DMA_CTRL0);\n\t\tspin_unlock_irq(&dcrtc->irq_lock);\n\t\treturn 0;\n\t}\n\n\tspin_lock_irq(&dcrtc->irq_lock);\n\tpara1 = readl_relaxed(dcrtc->base + LCD_SPU_SRAM_PARA1);\n\tarmada_updatel(CFG_CSB_256x32, CFG_CSB_256x32 | CFG_PDWN256x32,\n\t\t       dcrtc->base + LCD_SPU_SRAM_PARA1);\n\tspin_unlock_irq(&dcrtc->irq_lock);\n\n\t \n\tif (!(para1 & CFG_CSB_256x32)) {\n\t\tarmada_drm_crtc_cursor_tran(dcrtc->base);\n\t\treload = true;\n\t}\n\n\tif (dcrtc->cursor_hw_sz != (h << 16 | w)) {\n\t\tspin_lock_irq(&dcrtc->irq_lock);\n\t\tdcrtc->cursor_update = false;\n\t\tarmada_updatel(0, CFG_HWC_ENA, dcrtc->base + LCD_SPU_DMA_CTRL0);\n\t\tspin_unlock_irq(&dcrtc->irq_lock);\n\t\treload = true;\n\t}\n\tif (reload) {\n\t\tstruct armada_gem_object *obj = dcrtc->cursor_obj;\n\t\tuint32_t *pix;\n\t\t \n\t\tpix = obj->addr;\n\t\tpix += yoff * s + xoff;\n\t\tarmada_load_cursor_argb(dcrtc->base, pix, s, w, h);\n\t}\n\n\t \n\tspin_lock_irq(&dcrtc->irq_lock);\n\tdcrtc->cursor_hw_pos = yscr << 16 | xscr;\n\tdcrtc->cursor_hw_sz = h << 16 | w;\n\tdcrtc->cursor_update = true;\n\tarmada_drm_crtc_enable_irq(dcrtc, DUMB_FRAMEDONE_ENA);\n\tspin_unlock_irq(&dcrtc->irq_lock);\n\n\treturn 0;\n}\n\nstatic void cursor_update(void *data)\n{\n\tarmada_drm_crtc_cursor_update(data, true);\n}\n\nstatic int armada_drm_crtc_cursor_set(struct drm_crtc *crtc,\n\tstruct drm_file *file, uint32_t handle, uint32_t w, uint32_t h)\n{\n\tstruct armada_crtc *dcrtc = drm_to_armada_crtc(crtc);\n\tstruct armada_gem_object *obj = NULL;\n\tint ret;\n\n\t \n\tif (!dcrtc->variant->has_spu_adv_reg)\n\t\treturn -ENXIO;\n\n\tif (handle && w > 0 && h > 0) {\n\t\t \n\t\tif (w > 64 || h > 64 || (w > 32 && h > 32))\n\t\t\treturn -ENOMEM;\n\n\t\tobj = armada_gem_object_lookup(file, handle);\n\t\tif (!obj)\n\t\t\treturn -ENOENT;\n\n\t\t \n\t\tif (!obj->addr) {\n\t\t\tdrm_gem_object_put(&obj->obj);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (obj->obj.size < w * h * 4) {\n\t\t\tDRM_ERROR(\"buffer is too small\\n\");\n\t\t\tdrm_gem_object_put(&obj->obj);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t}\n\n\tif (dcrtc->cursor_obj) {\n\t\tdcrtc->cursor_obj->update = NULL;\n\t\tdcrtc->cursor_obj->update_data = NULL;\n\t\tdrm_gem_object_put(&dcrtc->cursor_obj->obj);\n\t}\n\tdcrtc->cursor_obj = obj;\n\tdcrtc->cursor_w = w;\n\tdcrtc->cursor_h = h;\n\tret = armada_drm_crtc_cursor_update(dcrtc, true);\n\tif (obj) {\n\t\tobj->update_data = dcrtc;\n\t\tobj->update = cursor_update;\n\t}\n\n\treturn ret;\n}\n\nstatic int armada_drm_crtc_cursor_move(struct drm_crtc *crtc, int x, int y)\n{\n\tstruct armada_crtc *dcrtc = drm_to_armada_crtc(crtc);\n\tint ret;\n\n\t \n\tif (!dcrtc->variant->has_spu_adv_reg)\n\t\treturn -EFAULT;\n\n\tdcrtc->cursor_x = x;\n\tdcrtc->cursor_y = y;\n\tret = armada_drm_crtc_cursor_update(dcrtc, false);\n\n\treturn ret;\n}\n\nstatic void armada_drm_crtc_destroy(struct drm_crtc *crtc)\n{\n\tstruct armada_crtc *dcrtc = drm_to_armada_crtc(crtc);\n\tstruct armada_private *priv = drm_to_armada_dev(crtc->dev);\n\n\tif (dcrtc->cursor_obj)\n\t\tdrm_gem_object_put(&dcrtc->cursor_obj->obj);\n\n\tpriv->dcrtc[dcrtc->num] = NULL;\n\tdrm_crtc_cleanup(&dcrtc->crtc);\n\n\tif (dcrtc->variant->disable)\n\t\tdcrtc->variant->disable(dcrtc);\n\n\twritel_relaxed(0, dcrtc->base + LCD_SPU_IRQ_ENA);\n\n\tof_node_put(dcrtc->crtc.port);\n\n\tkfree(dcrtc);\n}\n\nstatic int armada_drm_crtc_late_register(struct drm_crtc *crtc)\n{\n\tif (IS_ENABLED(CONFIG_DEBUG_FS))\n\t\tarmada_drm_crtc_debugfs_init(drm_to_armada_crtc(crtc));\n\n\treturn 0;\n}\n\n \nstatic int armada_drm_crtc_enable_vblank(struct drm_crtc *crtc)\n{\n\tstruct armada_crtc *dcrtc = drm_to_armada_crtc(crtc);\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&dcrtc->irq_lock, flags);\n\tarmada_drm_crtc_enable_irq(dcrtc, VSYNC_IRQ_ENA);\n\tspin_unlock_irqrestore(&dcrtc->irq_lock, flags);\n\treturn 0;\n}\n\nstatic void armada_drm_crtc_disable_vblank(struct drm_crtc *crtc)\n{\n\tstruct armada_crtc *dcrtc = drm_to_armada_crtc(crtc);\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&dcrtc->irq_lock, flags);\n\tarmada_drm_crtc_disable_irq(dcrtc, VSYNC_IRQ_ENA);\n\tspin_unlock_irqrestore(&dcrtc->irq_lock, flags);\n}\n\nstatic const struct drm_crtc_funcs armada_crtc_funcs = {\n\t.reset\t\t= drm_atomic_helper_crtc_reset,\n\t.cursor_set\t= armada_drm_crtc_cursor_set,\n\t.cursor_move\t= armada_drm_crtc_cursor_move,\n\t.destroy\t= armada_drm_crtc_destroy,\n\t.set_config\t= drm_atomic_helper_set_config,\n\t.page_flip\t= drm_atomic_helper_page_flip,\n\t.atomic_duplicate_state = drm_atomic_helper_crtc_duplicate_state,\n\t.atomic_destroy_state = drm_atomic_helper_crtc_destroy_state,\n\t.late_register\t= armada_drm_crtc_late_register,\n\t.enable_vblank\t= armada_drm_crtc_enable_vblank,\n\t.disable_vblank\t= armada_drm_crtc_disable_vblank,\n};\n\nint armada_crtc_select_clock(struct armada_crtc *dcrtc,\n\t\t\t     struct armada_clk_result *res,\n\t\t\t     const struct armada_clocking_params *params,\n\t\t\t     struct clk *clks[], size_t num_clks,\n\t\t\t     unsigned long desired_khz)\n{\n\tunsigned long desired_hz = desired_khz * 1000;\n\tunsigned long desired_clk_hz;\t\n\tunsigned long real_clk_hz;\t\n\tunsigned long real_hz;\t\t\n\tunsigned long permillage;\n\tstruct clk *clk;\n\tu32 div;\n\tint i;\n\n\tDRM_DEBUG_KMS(\"[CRTC:%u:%s] desired clock=%luHz\\n\",\n\t\t      dcrtc->crtc.base.id, dcrtc->crtc.name, desired_hz);\n\n\tfor (i = 0; i < num_clks; i++) {\n\t\tclk = clks[i];\n\t\tif (!clk)\n\t\t\tcontinue;\n\n\t\tif (params->settable & BIT(i)) {\n\t\t\treal_clk_hz = clk_round_rate(clk, desired_hz);\n\t\t\tdesired_clk_hz = desired_hz;\n\t\t} else {\n\t\t\treal_clk_hz = clk_get_rate(clk);\n\t\t\tdesired_clk_hz = real_clk_hz;\n\t\t}\n\n\t\t \n\t\tif (real_clk_hz == desired_hz) {\n\t\t\treal_hz = real_clk_hz;\n\t\t\tdiv = 1;\n\t\t\tgoto found;\n\t\t}\n\n\t\t \n\t\tdiv = DIV_ROUND_CLOSEST(real_clk_hz, desired_hz);\n\t\tif (div == 0 || div > params->div_max)\n\t\t\tcontinue;\n\n\t\t \n\t\treal_hz = DIV_ROUND_CLOSEST(real_clk_hz, div);\n\n\t\tDRM_DEBUG_KMS(\"[CRTC:%u:%s] clk=%u %luHz div=%u real=%luHz\\n\",\n\t\t\tdcrtc->crtc.base.id, dcrtc->crtc.name,\n\t\t\ti, real_clk_hz, div, real_hz);\n\n\t\t \n\t\tif (real_hz < desired_hz) {\n\t\t\tpermillage = real_hz / desired_khz;\n\t\t\tif (permillage < params->permillage_min)\n\t\t\t\tcontinue;\n\t\t} else {\n\t\t\tpermillage = DIV_ROUND_UP(real_hz, desired_khz);\n\t\t\tif (permillage > params->permillage_max)\n\t\t\t\tcontinue;\n\t\t}\n\t\tgoto found;\n\t}\n\n\treturn -ERANGE;\n\nfound:\n\tDRM_DEBUG_KMS(\"[CRTC:%u:%s] selected clk=%u %luHz div=%u real=%luHz\\n\",\n\t\tdcrtc->crtc.base.id, dcrtc->crtc.name,\n\t\ti, real_clk_hz, div, real_hz);\n\n\tres->desired_clk_hz = desired_clk_hz;\n\tres->clk = clk;\n\tres->div = div;\n\n\treturn i;\n}\n\nstatic int armada_drm_crtc_create(struct drm_device *drm, struct device *dev,\n\tstruct resource *res, int irq, const struct armada_variant *variant,\n\tstruct device_node *port)\n{\n\tstruct armada_private *priv = drm_to_armada_dev(drm);\n\tstruct armada_crtc *dcrtc;\n\tstruct drm_plane *primary;\n\tvoid __iomem *base;\n\tint ret;\n\n\tbase = devm_ioremap_resource(dev, res);\n\tif (IS_ERR(base))\n\t\treturn PTR_ERR(base);\n\n\tdcrtc = kzalloc(sizeof(*dcrtc), GFP_KERNEL);\n\tif (!dcrtc) {\n\t\tDRM_ERROR(\"failed to allocate Armada crtc\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tif (dev != drm->dev)\n\t\tdev_set_drvdata(dev, dcrtc);\n\n\tdcrtc->variant = variant;\n\tdcrtc->base = base;\n\tdcrtc->num = drm->mode_config.num_crtc;\n\tdcrtc->cfg_dumb_ctrl = DUMB24_RGB888_0;\n\tdcrtc->spu_iopad_ctrl = CFG_VSCALE_LN_EN | CFG_IOPAD_DUMB24;\n\tspin_lock_init(&dcrtc->irq_lock);\n\tdcrtc->irq_ena = CLEAN_SPU_IRQ_ISR;\n\n\t \n\twritel_relaxed(0x00000001, dcrtc->base + LCD_CFG_SCLK_DIV);\n\twritel_relaxed(0x00000000, dcrtc->base + LCD_SPU_BLANKCOLOR);\n\twritel_relaxed(dcrtc->spu_iopad_ctrl,\n\t\t       dcrtc->base + LCD_SPU_IOPAD_CONTROL);\n\twritel_relaxed(0x00000000, dcrtc->base + LCD_SPU_SRAM_PARA0);\n\twritel_relaxed(CFG_PDWN256x32 | CFG_PDWN256x24 | CFG_PDWN256x8 |\n\t\t       CFG_PDWN32x32 | CFG_PDWN16x66 | CFG_PDWN32x66 |\n\t\t       CFG_PDWN64x66, dcrtc->base + LCD_SPU_SRAM_PARA1);\n\twritel_relaxed(0x2032ff81, dcrtc->base + LCD_SPU_DMA_CTRL1);\n\twritel_relaxed(dcrtc->irq_ena, dcrtc->base + LCD_SPU_IRQ_ENA);\n\treadl_relaxed(dcrtc->base + LCD_SPU_IRQ_ISR);\n\twritel_relaxed(0, dcrtc->base + LCD_SPU_IRQ_ISR);\n\n\tret = devm_request_irq(dev, irq, armada_drm_irq, 0, \"armada_drm_crtc\",\n\t\t\t       dcrtc);\n\tif (ret < 0)\n\t\tgoto err_crtc;\n\n\tif (dcrtc->variant->init) {\n\t\tret = dcrtc->variant->init(dcrtc, dev);\n\t\tif (ret)\n\t\t\tgoto err_crtc;\n\t}\n\n\t \n\tarmada_updatel(CFG_ARBFAST_ENA, 0, dcrtc->base + LCD_SPU_DMA_CTRL0);\n\n\tpriv->dcrtc[dcrtc->num] = dcrtc;\n\n\tdcrtc->crtc.port = port;\n\n\tprimary = kzalloc(sizeof(*primary), GFP_KERNEL);\n\tif (!primary) {\n\t\tret = -ENOMEM;\n\t\tgoto err_crtc;\n\t}\n\n\tret = armada_drm_primary_plane_init(drm, primary);\n\tif (ret) {\n\t\tkfree(primary);\n\t\tgoto err_crtc;\n\t}\n\n\tret = drm_crtc_init_with_planes(drm, &dcrtc->crtc, primary, NULL,\n\t\t\t\t\t&armada_crtc_funcs, NULL);\n\tif (ret)\n\t\tgoto err_crtc_init;\n\n\tdrm_crtc_helper_add(&dcrtc->crtc, &armada_crtc_helper_funcs);\n\n\tret = drm_mode_crtc_set_gamma_size(&dcrtc->crtc, 256);\n\tif (ret)\n\t\treturn ret;\n\n\tdrm_crtc_enable_color_mgmt(&dcrtc->crtc, 0, false, 256);\n\n\treturn armada_overlay_plane_create(drm, 1 << dcrtc->num);\n\nerr_crtc_init:\n\tprimary->funcs->destroy(primary);\nerr_crtc:\n\tkfree(dcrtc);\n\n\treturn ret;\n}\n\nstatic int\narmada_lcd_bind(struct device *dev, struct device *master, void *data)\n{\n\tstruct platform_device *pdev = to_platform_device(dev);\n\tstruct drm_device *drm = data;\n\tstruct resource *res = platform_get_resource(pdev, IORESOURCE_MEM, 0);\n\tint irq = platform_get_irq(pdev, 0);\n\tconst struct armada_variant *variant;\n\tstruct device_node *port = NULL;\n\n\tif (irq < 0)\n\t\treturn irq;\n\n\tif (!dev->of_node) {\n\t\tconst struct platform_device_id *id;\n\n\t\tid = platform_get_device_id(pdev);\n\t\tif (!id)\n\t\t\treturn -ENXIO;\n\n\t\tvariant = (const struct armada_variant *)id->driver_data;\n\t} else {\n\t\tconst struct of_device_id *match;\n\t\tstruct device_node *np, *parent = dev->of_node;\n\n\t\tmatch = of_match_device(dev->driver->of_match_table, dev);\n\t\tif (!match)\n\t\t\treturn -ENXIO;\n\n\t\tnp = of_get_child_by_name(parent, \"ports\");\n\t\tif (np)\n\t\t\tparent = np;\n\t\tport = of_get_child_by_name(parent, \"port\");\n\t\tof_node_put(np);\n\t\tif (!port) {\n\t\t\tdev_err(dev, \"no port node found in %pOF\\n\", parent);\n\t\t\treturn -ENXIO;\n\t\t}\n\n\t\tvariant = match->data;\n\t}\n\n\treturn armada_drm_crtc_create(drm, dev, res, irq, variant, port);\n}\n\nstatic void\narmada_lcd_unbind(struct device *dev, struct device *master, void *data)\n{\n\tstruct armada_crtc *dcrtc = dev_get_drvdata(dev);\n\n\tarmada_drm_crtc_destroy(&dcrtc->crtc);\n}\n\nstatic const struct component_ops armada_lcd_ops = {\n\t.bind = armada_lcd_bind,\n\t.unbind = armada_lcd_unbind,\n};\n\nstatic int armada_lcd_probe(struct platform_device *pdev)\n{\n\treturn component_add(&pdev->dev, &armada_lcd_ops);\n}\n\nstatic int armada_lcd_remove(struct platform_device *pdev)\n{\n\tcomponent_del(&pdev->dev, &armada_lcd_ops);\n\treturn 0;\n}\n\nstatic const struct of_device_id armada_lcd_of_match[] = {\n\t{\n\t\t.compatible\t= \"marvell,dove-lcd\",\n\t\t.data\t\t= &armada510_ops,\n\t},\n\t{}\n};\nMODULE_DEVICE_TABLE(of, armada_lcd_of_match);\n\nstatic const struct platform_device_id armada_lcd_platform_ids[] = {\n\t{\n\t\t.name\t\t= \"armada-lcd\",\n\t\t.driver_data\t= (unsigned long)&armada510_ops,\n\t}, {\n\t\t.name\t\t= \"armada-510-lcd\",\n\t\t.driver_data\t= (unsigned long)&armada510_ops,\n\t},\n\t{ },\n};\nMODULE_DEVICE_TABLE(platform, armada_lcd_platform_ids);\n\nstruct platform_driver armada_lcd_platform_driver = {\n\t.probe\t= armada_lcd_probe,\n\t.remove\t= armada_lcd_remove,\n\t.driver = {\n\t\t.name\t= \"armada-lcd\",\n\t\t.owner\t=  THIS_MODULE,\n\t\t.of_match_table = armada_lcd_of_match,\n\t},\n\t.id_table = armada_lcd_platform_ids,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}