{
  "module_name": "armada_drv.c",
  "hash_id": "8ece73bf88bc36bf486748c8c7903ecc1119a411b8ff2d5032d8c803e7d810f9",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/armada/armada_drv.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/component.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/of_graph.h>\n#include <linux/platform_device.h>\n\n#include <drm/drm_aperture.h>\n#include <drm/drm_atomic_helper.h>\n#include <drm/drm_drv.h>\n#include <drm/drm_ioctl.h>\n#include <drm/drm_managed.h>\n#include <drm/drm_prime.h>\n#include <drm/drm_probe_helper.h>\n#include <drm/drm_of.h>\n#include <drm/drm_vblank.h>\n\n#include \"armada_crtc.h\"\n#include \"armada_drm.h\"\n#include \"armada_gem.h\"\n#include \"armada_fb.h\"\n#include \"armada_hw.h\"\n#include <drm/armada_drm.h>\n#include \"armada_ioctlP.h\"\n\nstatic const struct drm_ioctl_desc armada_ioctls[] = {\n\tDRM_IOCTL_DEF_DRV(ARMADA_GEM_CREATE, armada_gem_create_ioctl,0),\n\tDRM_IOCTL_DEF_DRV(ARMADA_GEM_MMAP, armada_gem_mmap_ioctl, 0),\n\tDRM_IOCTL_DEF_DRV(ARMADA_GEM_PWRITE, armada_gem_pwrite_ioctl, 0),\n};\n\nDEFINE_DRM_GEM_FOPS(armada_drm_fops);\n\nstatic const struct drm_driver armada_drm_driver = {\n\t.gem_prime_import\t= armada_gem_prime_import,\n\t.dumb_create\t\t= armada_gem_dumb_create,\n\t.major\t\t\t= 1,\n\t.minor\t\t\t= 0,\n\t.name\t\t\t= \"armada-drm\",\n\t.desc\t\t\t= \"Armada SoC DRM\",\n\t.date\t\t\t= \"20120730\",\n\t.driver_features\t= DRIVER_GEM | DRIVER_MODESET | DRIVER_ATOMIC,\n\t.ioctls\t\t\t= armada_ioctls,\n\t.num_ioctls = ARRAY_SIZE(armada_ioctls),\n\t.fops\t\t\t= &armada_drm_fops,\n};\n\nstatic const struct drm_mode_config_funcs armada_drm_mode_config_funcs = {\n\t.fb_create\t\t= armada_fb_create,\n\t.atomic_check\t\t= drm_atomic_helper_check,\n\t.atomic_commit\t\t= drm_atomic_helper_commit,\n};\n\nstatic int armada_drm_bind(struct device *dev)\n{\n\tstruct armada_private *priv;\n\tstruct resource *mem = NULL;\n\tint ret, n;\n\n\tfor (n = 0; ; n++) {\n\t\tstruct resource *r = platform_get_resource(to_platform_device(dev),\n\t\t\t\t\t\t\t   IORESOURCE_MEM, n);\n\t\tif (!r)\n\t\t\tbreak;\n\n\t\t \n\t\tif (resource_size(r) > SZ_64K)\n\t\t\tmem = r;\n\t\telse\n\t\t\treturn -EINVAL;\n\t}\n\n\tif (!mem)\n\t\treturn -ENXIO;\n\n\tif (!devm_request_mem_region(dev, mem->start, resource_size(mem),\n\t\t\t\t     \"armada-drm\"))\n\t\treturn -EBUSY;\n\n\tpriv = devm_drm_dev_alloc(dev, &armada_drm_driver,\n\t\t\t\t  struct armada_private, drm);\n\tif (IS_ERR(priv)) {\n\t\tdev_err(dev, \"[\" DRM_NAME \":%s] devm_drm_dev_alloc failed: %li\\n\",\n\t\t\t__func__, PTR_ERR(priv));\n\t\treturn PTR_ERR(priv);\n\t}\n\n\t \n\tret = drm_aperture_remove_framebuffers(&armada_drm_driver);\n\tif (ret) {\n\t\tdev_err(dev, \"[\" DRM_NAME \":%s] can't kick out simple-fb: %d\\n\",\n\t\t\t__func__, ret);\n\t\treturn ret;\n\t}\n\n\tdev_set_drvdata(dev, &priv->drm);\n\n\t \n\tdrm_mode_config_init(&priv->drm);\n\tpriv->drm.mode_config.min_width = 320;\n\tpriv->drm.mode_config.min_height = 200;\n\n\t \n\tpriv->drm.mode_config.max_width = 1920;\n\tpriv->drm.mode_config.max_height = 2048;\n\n\tpriv->drm.mode_config.preferred_depth = 24;\n\tpriv->drm.mode_config.funcs = &armada_drm_mode_config_funcs;\n\tdrm_mm_init(&priv->linear, mem->start, resource_size(mem));\n\tmutex_init(&priv->linear_lock);\n\n\tret = component_bind_all(dev, &priv->drm);\n\tif (ret)\n\t\tgoto err_kms;\n\n\tret = drm_vblank_init(&priv->drm, priv->drm.mode_config.num_crtc);\n\tif (ret)\n\t\tgoto err_comp;\n\n\tdrm_mode_config_reset(&priv->drm);\n\n\tdrm_kms_helper_poll_init(&priv->drm);\n\n\tret = drm_dev_register(&priv->drm, 0);\n\tif (ret)\n\t\tgoto err_poll;\n\n#ifdef CONFIG_DEBUG_FS\n\tarmada_drm_debugfs_init(priv->drm.primary);\n#endif\n\n\tarmada_fbdev_setup(&priv->drm);\n\n\treturn 0;\n\n err_poll:\n\tdrm_kms_helper_poll_fini(&priv->drm);\n err_comp:\n\tcomponent_unbind_all(dev, &priv->drm);\n err_kms:\n\tdrm_mode_config_cleanup(&priv->drm);\n\tdrm_mm_takedown(&priv->linear);\n\treturn ret;\n}\n\nstatic void armada_drm_unbind(struct device *dev)\n{\n\tstruct drm_device *drm = dev_get_drvdata(dev);\n\tstruct armada_private *priv = drm_to_armada_dev(drm);\n\n\tdrm_kms_helper_poll_fini(&priv->drm);\n\n\tdrm_dev_unregister(&priv->drm);\n\n\tdrm_atomic_helper_shutdown(&priv->drm);\n\n\tcomponent_unbind_all(dev, &priv->drm);\n\n\tdrm_mode_config_cleanup(&priv->drm);\n\tdrm_mm_takedown(&priv->linear);\n}\n\nstatic void armada_add_endpoints(struct device *dev,\n\tstruct component_match **match, struct device_node *dev_node)\n{\n\tstruct device_node *ep, *remote;\n\n\tfor_each_endpoint_of_node(dev_node, ep) {\n\t\tremote = of_graph_get_remote_port_parent(ep);\n\t\tif (remote && of_device_is_available(remote))\n\t\t\tdrm_of_component_match_add(dev, match, component_compare_of,\n\t\t\t\t\t\t   remote);\n\t\tof_node_put(remote);\n\t}\n}\n\nstatic const struct component_master_ops armada_master_ops = {\n\t.bind = armada_drm_bind,\n\t.unbind = armada_drm_unbind,\n};\n\nstatic int armada_drm_probe(struct platform_device *pdev)\n{\n\tstruct component_match *match = NULL;\n\tstruct device *dev = &pdev->dev;\n\tint ret;\n\n\tret = drm_of_component_probe(dev, component_compare_dev_name, &armada_master_ops);\n\tif (ret != -EINVAL)\n\t\treturn ret;\n\n\tif (dev->platform_data) {\n\t\tchar **devices = dev->platform_data;\n\t\tstruct device *d;\n\t\tint i;\n\n\t\tfor (i = 0; devices[i]; i++)\n\t\t\tcomponent_match_add(dev, &match, component_compare_dev_name,\n\t\t\t\t\t    devices[i]);\n\n\t\tif (i == 0) {\n\t\t\tdev_err(dev, \"missing 'ports' property\\n\");\n\t\t\treturn -ENODEV;\n\t\t}\n\n\t\tfor (i = 0; devices[i]; i++) {\n\t\t\td = bus_find_device_by_name(&platform_bus_type, NULL,\n\t\t\t\t\t\t    devices[i]);\n\t\t\tif (d && d->of_node)\n\t\t\t\tarmada_add_endpoints(dev, &match, d->of_node);\n\t\t\tput_device(d);\n\t\t}\n\t}\n\n\treturn component_master_add_with_match(&pdev->dev, &armada_master_ops,\n\t\t\t\t\t       match);\n}\n\nstatic int armada_drm_remove(struct platform_device *pdev)\n{\n\tcomponent_master_del(&pdev->dev, &armada_master_ops);\n\treturn 0;\n}\n\nstatic const struct platform_device_id armada_drm_platform_ids[] = {\n\t{\n\t\t.name\t\t= \"armada-drm\",\n\t}, {\n\t\t.name\t\t= \"armada-510-drm\",\n\t},\n\t{ },\n};\nMODULE_DEVICE_TABLE(platform, armada_drm_platform_ids);\n\nstatic struct platform_driver armada_drm_platform_driver = {\n\t.probe\t= armada_drm_probe,\n\t.remove\t= armada_drm_remove,\n\t.driver\t= {\n\t\t.name\t= \"armada-drm\",\n\t},\n\t.id_table = armada_drm_platform_ids,\n};\n\nstatic int __init armada_drm_init(void)\n{\n\tint ret;\n\n\tif (drm_firmware_drivers_only())\n\t\treturn -ENODEV;\n\n\tret = platform_driver_register(&armada_lcd_platform_driver);\n\tif (ret)\n\t\treturn ret;\n\tret = platform_driver_register(&armada_drm_platform_driver);\n\tif (ret)\n\t\tplatform_driver_unregister(&armada_lcd_platform_driver);\n\treturn ret;\n}\nmodule_init(armada_drm_init);\n\nstatic void __exit armada_drm_exit(void)\n{\n\tplatform_driver_unregister(&armada_drm_platform_driver);\n\tplatform_driver_unregister(&armada_lcd_platform_driver);\n}\nmodule_exit(armada_drm_exit);\n\nMODULE_AUTHOR(\"Russell King <rmk+kernel@armlinux.org.uk>\");\nMODULE_DESCRIPTION(\"Armada DRM Driver\");\nMODULE_LICENSE(\"GPL\");\nMODULE_ALIAS(\"platform:armada-drm\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}