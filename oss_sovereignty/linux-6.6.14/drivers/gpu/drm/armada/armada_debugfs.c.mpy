{
  "module_name": "armada_debugfs.c",
  "hash_id": "03023386ffb0dcc55a6dc0cd2c09772892164f7e72590ee94ff59715e9867b38",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/armada/armada_debugfs.c",
  "human_readable_source": "\n \n\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\n#include <drm/drm_debugfs.h>\n#include <drm/drm_file.h>\n\n#include \"armada_crtc.h\"\n#include \"armada_drm.h\"\n\nstatic int armada_debugfs_gem_linear_show(struct seq_file *m, void *data)\n{\n\tstruct drm_info_node *node = m->private;\n\tstruct drm_device *dev = node->minor->dev;\n\tstruct armada_private *priv = drm_to_armada_dev(dev);\n\tstruct drm_printer p = drm_seq_file_printer(m);\n\n\tmutex_lock(&priv->linear_lock);\n\tdrm_mm_print(&priv->linear, &p);\n\tmutex_unlock(&priv->linear_lock);\n\n\treturn 0;\n}\n\nstatic int armada_debugfs_crtc_reg_show(struct seq_file *m, void *data)\n{\n\tstruct armada_crtc *dcrtc = m->private;\n\tint i;\n\n\tfor (i = 0x84; i <= 0x1c4; i += 4) {\n\t\tu32 v = readl_relaxed(dcrtc->base + i);\n\t\tseq_printf(m, \"0x%04x: 0x%08x\\n\", i, v);\n\t}\n\n\treturn 0;\n}\n\nstatic int armada_debugfs_crtc_reg_open(struct inode *inode, struct file *file)\n{\n\treturn single_open(file, armada_debugfs_crtc_reg_show,\n\t\t\t   inode->i_private);\n}\n\nstatic int armada_debugfs_crtc_reg_write(struct file *file,\n\tconst char __user *ptr, size_t len, loff_t *off)\n{\n\tstruct armada_crtc *dcrtc;\n\tunsigned long reg, mask, val;\n\tchar buf[32];\n\tint ret;\n\tu32 v;\n\n\tif (*off != 0)\n\t\treturn 0;\n\n\tif (len > sizeof(buf) - 1)\n\t\tlen = sizeof(buf) - 1;\n\n\tret = strncpy_from_user(buf, ptr, len);\n\tif (ret < 0)\n\t\treturn ret;\n\tbuf[len] = '\\0';\n\n\tif (sscanf(buf, \"%lx %lx %lx\", &reg, &mask, &val) != 3)\n\t\treturn -EINVAL;\n\tif (reg < 0x84 || reg > 0x1c4 || reg & 3)\n\t\treturn -ERANGE;\n\n\tdcrtc = ((struct seq_file *)file->private_data)->private;\n\tv = readl(dcrtc->base + reg);\n\tv &= ~mask;\n\tv |= val & mask;\n\twritel(v, dcrtc->base + reg);\n\n\treturn len;\n}\n\nstatic const struct file_operations armada_debugfs_crtc_reg_fops = {\n\t.owner = THIS_MODULE,\n\t.open = armada_debugfs_crtc_reg_open,\n\t.read = seq_read,\n\t.write = armada_debugfs_crtc_reg_write,\n\t.llseek = seq_lseek,\n\t.release = single_release,\n};\n\nvoid armada_drm_crtc_debugfs_init(struct armada_crtc *dcrtc)\n{\n\tdebugfs_create_file(\"armada-regs\", 0600, dcrtc->crtc.debugfs_entry,\n\t\t\t    dcrtc, &armada_debugfs_crtc_reg_fops);\n}\n\nstatic struct drm_info_list armada_debugfs_list[] = {\n\t{ \"gem_linear\", armada_debugfs_gem_linear_show, 0 },\n};\n#define ARMADA_DEBUGFS_ENTRIES ARRAY_SIZE(armada_debugfs_list)\n\nint armada_drm_debugfs_init(struct drm_minor *minor)\n{\n\tdrm_debugfs_create_files(armada_debugfs_list, ARMADA_DEBUGFS_ENTRIES,\n\t\t\t\t minor->debugfs_root, minor);\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}