{
  "module_name": "armada_fbdev.c",
  "hash_id": "1b05cbf86eeb88ba90b51b5c3c472ea08a76c0257d63878e161ebddc51e4c250",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/armada/armada_fbdev.c",
  "human_readable_source": "\n \n\n#include <linux/errno.h>\n#include <linux/fb.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\n#include <drm/drm_crtc_helper.h>\n#include <drm/drm_drv.h>\n#include <drm/drm_fb_helper.h>\n#include <drm/drm_fourcc.h>\n\n#include \"armada_crtc.h\"\n#include \"armada_drm.h\"\n#include \"armada_fb.h\"\n#include \"armada_gem.h\"\n\nstatic void armada_fbdev_fb_destroy(struct fb_info *info)\n{\n\tstruct drm_fb_helper *fbh = info->par;\n\n\tdrm_fb_helper_fini(fbh);\n\n\tfbh->fb->funcs->destroy(fbh->fb);\n\n\tdrm_client_release(&fbh->client);\n\tdrm_fb_helper_unprepare(fbh);\n\tkfree(fbh);\n}\n\nstatic const struct fb_ops armada_fb_ops = {\n\t.owner\t\t= THIS_MODULE,\n\tFB_DEFAULT_IOMEM_OPS,\n\tDRM_FB_HELPER_DEFAULT_OPS,\n\t.fb_destroy\t= armada_fbdev_fb_destroy,\n};\n\nstatic int armada_fbdev_create(struct drm_fb_helper *fbh,\n\tstruct drm_fb_helper_surface_size *sizes)\n{\n\tstruct drm_device *dev = fbh->dev;\n\tstruct drm_mode_fb_cmd2 mode;\n\tstruct armada_framebuffer *dfb;\n\tstruct armada_gem_object *obj;\n\tstruct fb_info *info;\n\tint size, ret;\n\tvoid *ptr;\n\n\tmemset(&mode, 0, sizeof(mode));\n\tmode.width = sizes->surface_width;\n\tmode.height = sizes->surface_height;\n\tmode.pitches[0] = armada_pitch(mode.width, sizes->surface_bpp);\n\tmode.pixel_format = drm_mode_legacy_fb_format(sizes->surface_bpp,\n\t\t\t\t\tsizes->surface_depth);\n\n\tsize = mode.pitches[0] * mode.height;\n\tobj = armada_gem_alloc_private_object(dev, size);\n\tif (!obj) {\n\t\tDRM_ERROR(\"failed to allocate fb memory\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tret = armada_gem_linear_back(dev, obj);\n\tif (ret) {\n\t\tdrm_gem_object_put(&obj->obj);\n\t\treturn ret;\n\t}\n\n\tptr = armada_gem_map_object(dev, obj);\n\tif (!ptr) {\n\t\tdrm_gem_object_put(&obj->obj);\n\t\treturn -ENOMEM;\n\t}\n\n\tdfb = armada_framebuffer_create(dev, &mode, obj);\n\n\t \n\tdrm_gem_object_put(&obj->obj);\n\n\tif (IS_ERR(dfb))\n\t\treturn PTR_ERR(dfb);\n\n\tinfo = drm_fb_helper_alloc_info(fbh);\n\tif (IS_ERR(info)) {\n\t\tret = PTR_ERR(info);\n\t\tgoto err_fballoc;\n\t}\n\n\tinfo->fbops = &armada_fb_ops;\n\tinfo->fix.smem_start = obj->phys_addr;\n\tinfo->fix.smem_len = obj->obj.size;\n\tinfo->screen_size = obj->obj.size;\n\tinfo->screen_base = ptr;\n\tfbh->fb = &dfb->fb;\n\n\tdrm_fb_helper_fill_info(info, fbh, sizes);\n\n\tDRM_DEBUG_KMS(\"allocated %dx%d %dbpp fb: 0x%08llx\\n\",\n\t\tdfb->fb.width, dfb->fb.height, dfb->fb.format->cpp[0] * 8,\n\t\t(unsigned long long)obj->phys_addr);\n\n\treturn 0;\n\n err_fballoc:\n\tdfb->fb.funcs->destroy(&dfb->fb);\n\treturn ret;\n}\n\nstatic int armada_fb_probe(struct drm_fb_helper *fbh,\n\tstruct drm_fb_helper_surface_size *sizes)\n{\n\tint ret = 0;\n\n\tif (!fbh->fb) {\n\t\tret = armada_fbdev_create(fbh, sizes);\n\t\tif (ret == 0)\n\t\t\tret = 1;\n\t}\n\treturn ret;\n}\n\nstatic const struct drm_fb_helper_funcs armada_fb_helper_funcs = {\n\t.fb_probe\t= armada_fb_probe,\n};\n\n \n\nstatic void armada_fbdev_client_unregister(struct drm_client_dev *client)\n{\n\tstruct drm_fb_helper *fbh = drm_fb_helper_from_client(client);\n\n\tif (fbh->info) {\n\t\tdrm_fb_helper_unregister_info(fbh);\n\t} else {\n\t\tdrm_client_release(&fbh->client);\n\t\tdrm_fb_helper_unprepare(fbh);\n\t\tkfree(fbh);\n\t}\n}\n\nstatic int armada_fbdev_client_restore(struct drm_client_dev *client)\n{\n\tdrm_fb_helper_lastclose(client->dev);\n\n\treturn 0;\n}\n\nstatic int armada_fbdev_client_hotplug(struct drm_client_dev *client)\n{\n\tstruct drm_fb_helper *fbh = drm_fb_helper_from_client(client);\n\tstruct drm_device *dev = client->dev;\n\tint ret;\n\n\tif (dev->fb_helper)\n\t\treturn drm_fb_helper_hotplug_event(dev->fb_helper);\n\n\tret = drm_fb_helper_init(dev, fbh);\n\tif (ret)\n\t\tgoto err_drm_err;\n\n\tif (!drm_drv_uses_atomic_modeset(dev))\n\t\tdrm_helper_disable_unused_functions(dev);\n\n\tret = drm_fb_helper_initial_config(fbh);\n\tif (ret)\n\t\tgoto err_drm_fb_helper_fini;\n\n\treturn 0;\n\nerr_drm_fb_helper_fini:\n\tdrm_fb_helper_fini(fbh);\nerr_drm_err:\n\tdrm_err(dev, \"armada: Failed to setup fbdev emulation (ret=%d)\\n\", ret);\n\treturn ret;\n}\n\nstatic const struct drm_client_funcs armada_fbdev_client_funcs = {\n\t.owner\t\t= THIS_MODULE,\n\t.unregister\t= armada_fbdev_client_unregister,\n\t.restore\t= armada_fbdev_client_restore,\n\t.hotplug\t= armada_fbdev_client_hotplug,\n};\n\nvoid armada_fbdev_setup(struct drm_device *dev)\n{\n\tstruct drm_fb_helper *fbh;\n\tint ret;\n\n\tdrm_WARN(dev, !dev->registered, \"Device has not been registered.\\n\");\n\tdrm_WARN(dev, dev->fb_helper, \"fb_helper is already set!\\n\");\n\n\tfbh = kzalloc(sizeof(*fbh), GFP_KERNEL);\n\tif (!fbh)\n\t\treturn;\n\tdrm_fb_helper_prepare(dev, fbh, 32, &armada_fb_helper_funcs);\n\n\tret = drm_client_init(dev, &fbh->client, \"fbdev\", &armada_fbdev_client_funcs);\n\tif (ret) {\n\t\tdrm_err(dev, \"Failed to register client: %d\\n\", ret);\n\t\tgoto err_drm_client_init;\n\t}\n\n\tdrm_client_register(&fbh->client);\n\n\treturn;\n\nerr_drm_client_init:\n\tdrm_fb_helper_unprepare(fbh);\n\tkfree(fbh);\n\treturn;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}