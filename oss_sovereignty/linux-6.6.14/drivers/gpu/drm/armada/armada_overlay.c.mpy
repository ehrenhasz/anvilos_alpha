{
  "module_name": "armada_overlay.c",
  "hash_id": "2682aff1620ca6d91612dd473ad64b16028c06c6be4a1b8b74c84ba6fe770647",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/armada/armada_overlay.c",
  "human_readable_source": "\n \n\n#include <linux/bitfield.h>\n\n#include <drm/armada_drm.h>\n#include <drm/drm_atomic.h>\n#include <drm/drm_atomic_helper.h>\n#include <drm/drm_atomic_uapi.h>\n#include <drm/drm_fourcc.h>\n#include <drm/drm_plane_helper.h>\n\n#include \"armada_crtc.h\"\n#include \"armada_drm.h\"\n#include \"armada_fb.h\"\n#include \"armada_gem.h\"\n#include \"armada_hw.h\"\n#include \"armada_ioctlP.h\"\n#include \"armada_plane.h\"\n#include \"armada_trace.h\"\n\n#define DEFAULT_BRIGHTNESS\t0\n#define DEFAULT_CONTRAST\t0x4000\n#define DEFAULT_SATURATION\t0x4000\n#define DEFAULT_ENCODING\tDRM_COLOR_YCBCR_BT601\n\nstruct armada_overlay_state {\n\tstruct armada_plane_state base;\n\tu32 colorkey_yr;\n\tu32 colorkey_ug;\n\tu32 colorkey_vb;\n\tu32 colorkey_mode;\n\tu32 colorkey_enable;\n\ts16 brightness;\n\tu16 contrast;\n\tu16 saturation;\n};\n#define drm_to_overlay_state(s) \\\n\tcontainer_of(s, struct armada_overlay_state, base.base)\n\nstatic inline u32 armada_spu_contrast(struct drm_plane_state *state)\n{\n\treturn drm_to_overlay_state(state)->brightness << 16 |\n\t       drm_to_overlay_state(state)->contrast;\n}\n\nstatic inline u32 armada_spu_saturation(struct drm_plane_state *state)\n{\n\t \n\treturn drm_to_overlay_state(state)->saturation << 16;\n}\n\nstatic inline u32 armada_csc(struct drm_plane_state *state)\n{\n\t \n\treturn CFG_CSC_RGB_COMPUTER |\n\t       (state->color_encoding == DRM_COLOR_YCBCR_BT709 ?\n\t\t\tCFG_CSC_YUV_CCIR709 : CFG_CSC_YUV_CCIR601);\n}\n\n \nstatic void armada_drm_overlay_plane_atomic_update(struct drm_plane *plane,\n\tstruct drm_atomic_state *state)\n{\n\tstruct drm_plane_state *old_state = drm_atomic_get_old_plane_state(state,\n\t\t\t\t\t\t\t\t\t   plane);\n\tstruct drm_plane_state *new_state = drm_atomic_get_new_plane_state(state,\n\t\t\t\t\t\t\t\t\t   plane);\n\tstruct armada_crtc *dcrtc;\n\tstruct armada_regs *regs;\n\tunsigned int idx;\n\tu32 cfg, cfg_mask, val;\n\n\tDRM_DEBUG_KMS(\"[PLANE:%d:%s]\\n\", plane->base.id, plane->name);\n\n\tif (!new_state->fb || WARN_ON(!new_state->crtc))\n\t\treturn;\n\n\tDRM_DEBUG_KMS(\"[PLANE:%d:%s] is on [CRTC:%d:%s] with [FB:%d] visible %u->%u\\n\",\n\t\tplane->base.id, plane->name,\n\t\tnew_state->crtc->base.id, new_state->crtc->name,\n\t\tnew_state->fb->base.id,\n\t\told_state->visible, new_state->visible);\n\n\tdcrtc = drm_to_armada_crtc(new_state->crtc);\n\tregs = dcrtc->regs + dcrtc->regs_idx;\n\n\tidx = 0;\n\tif (!old_state->visible && new_state->visible)\n\t\tarmada_reg_queue_mod(regs, idx,\n\t\t\t\t     0, CFG_PDWN16x66 | CFG_PDWN32x66,\n\t\t\t\t     LCD_SPU_SRAM_PARA1);\n\tval = armada_src_hw(new_state);\n\tif (armada_src_hw(old_state) != val)\n\t\tarmada_reg_queue_set(regs, idx, val, LCD_SPU_DMA_HPXL_VLN);\n\tval = armada_dst_yx(new_state);\n\tif (armada_dst_yx(old_state) != val)\n\t\tarmada_reg_queue_set(regs, idx, val, LCD_SPU_DMA_OVSA_HPXL_VLN);\n\tval = armada_dst_hw(new_state);\n\tif (armada_dst_hw(old_state) != val)\n\t\tarmada_reg_queue_set(regs, idx, val, LCD_SPU_DZM_HPXL_VLN);\n\t \n\tif (old_state->src.x1 != new_state->src.x1 ||\n\t    old_state->src.y1 != new_state->src.y1 ||\n\t    old_state->fb != new_state->fb ||\n\t    new_state->crtc->state->mode_changed) {\n\t\tconst struct drm_format_info *format;\n\t\tu16 src_x;\n\n\t\tarmada_reg_queue_set(regs, idx, armada_addr(new_state, 0, 0),\n\t\t\t\t     LCD_SPU_DMA_START_ADDR_Y0);\n\t\tarmada_reg_queue_set(regs, idx, armada_addr(new_state, 0, 1),\n\t\t\t\t     LCD_SPU_DMA_START_ADDR_U0);\n\t\tarmada_reg_queue_set(regs, idx, armada_addr(new_state, 0, 2),\n\t\t\t\t     LCD_SPU_DMA_START_ADDR_V0);\n\t\tarmada_reg_queue_set(regs, idx, armada_addr(new_state, 1, 0),\n\t\t\t\t     LCD_SPU_DMA_START_ADDR_Y1);\n\t\tarmada_reg_queue_set(regs, idx, armada_addr(new_state, 1, 1),\n\t\t\t\t     LCD_SPU_DMA_START_ADDR_U1);\n\t\tarmada_reg_queue_set(regs, idx, armada_addr(new_state, 1, 2),\n\t\t\t\t     LCD_SPU_DMA_START_ADDR_V1);\n\n\t\tval = armada_pitch(new_state, 0) << 16 | armada_pitch(new_state,\n\t\t\t\t\t\t\t\t      0);\n\t\tarmada_reg_queue_set(regs, idx, val, LCD_SPU_DMA_PITCH_YC);\n\t\tval = armada_pitch(new_state, 1) << 16 | armada_pitch(new_state,\n\t\t\t\t\t\t\t\t      2);\n\t\tarmada_reg_queue_set(regs, idx, val, LCD_SPU_DMA_PITCH_UV);\n\n\t\tcfg = CFG_DMA_FMT(drm_fb_to_armada_fb(new_state->fb)->fmt) |\n\t\t      CFG_DMA_MOD(drm_fb_to_armada_fb(new_state->fb)->mod) |\n\t\t      CFG_CBSH_ENA;\n\t\tif (new_state->visible)\n\t\t\tcfg |= CFG_DMA_ENA;\n\n\t\t \n\t\tformat = new_state->fb->format;\n\t\tsrc_x = new_state->src.x1 >> 16;\n\t\tif (format->num_planes == 1 && src_x & (format->hsub - 1))\n\t\t\tcfg ^= CFG_DMA_MOD(CFG_SWAPUV);\n\t\tif (to_armada_plane_state(new_state)->interlace)\n\t\t\tcfg |= CFG_DMA_FTOGGLE;\n\t\tcfg_mask = CFG_CBSH_ENA | CFG_DMAFORMAT |\n\t\t\t   CFG_DMA_MOD(CFG_SWAPRB | CFG_SWAPUV |\n\t\t\t\t       CFG_SWAPYU | CFG_YUV2RGB) |\n\t\t\t   CFG_DMA_FTOGGLE | CFG_DMA_TSTMODE |\n\t\t\t   CFG_DMA_ENA;\n\t} else if (old_state->visible != new_state->visible) {\n\t\tcfg = new_state->visible ? CFG_DMA_ENA : 0;\n\t\tcfg_mask = CFG_DMA_ENA;\n\t} else {\n\t\tcfg = cfg_mask = 0;\n\t}\n\tif (drm_rect_width(&old_state->src) != drm_rect_width(&new_state->src) ||\n\t    drm_rect_width(&old_state->dst) != drm_rect_width(&new_state->dst)) {\n\t\tcfg_mask |= CFG_DMA_HSMOOTH;\n\t\tif (drm_rect_width(&new_state->src) >> 16 !=\n\t\t    drm_rect_width(&new_state->dst))\n\t\t\tcfg |= CFG_DMA_HSMOOTH;\n\t}\n\n\tif (cfg_mask)\n\t\tarmada_reg_queue_mod(regs, idx, cfg, cfg_mask,\n\t\t\t\t     LCD_SPU_DMA_CTRL0);\n\n\tval = armada_spu_contrast(new_state);\n\tif ((!old_state->visible && new_state->visible) ||\n\t    armada_spu_contrast(old_state) != val)\n\t\tarmada_reg_queue_set(regs, idx, val, LCD_SPU_CONTRAST);\n\tval = armada_spu_saturation(new_state);\n\tif ((!old_state->visible && new_state->visible) ||\n\t    armada_spu_saturation(old_state) != val)\n\t\tarmada_reg_queue_set(regs, idx, val, LCD_SPU_SATURATION);\n\tif (!old_state->visible && new_state->visible)\n\t\tarmada_reg_queue_set(regs, idx, 0x00002000, LCD_SPU_CBSH_HUE);\n\tval = armada_csc(new_state);\n\tif ((!old_state->visible && new_state->visible) ||\n\t    armada_csc(old_state) != val)\n\t\tarmada_reg_queue_mod(regs, idx, val, CFG_CSC_MASK,\n\t\t\t\t     LCD_SPU_IOPAD_CONTROL);\n\tval = drm_to_overlay_state(new_state)->colorkey_yr;\n\tif ((!old_state->visible && new_state->visible) ||\n\t    drm_to_overlay_state(old_state)->colorkey_yr != val)\n\t\tarmada_reg_queue_set(regs, idx, val, LCD_SPU_COLORKEY_Y);\n\tval = drm_to_overlay_state(new_state)->colorkey_ug;\n\tif ((!old_state->visible && new_state->visible) ||\n\t    drm_to_overlay_state(old_state)->colorkey_ug != val)\n\t\tarmada_reg_queue_set(regs, idx, val, LCD_SPU_COLORKEY_U);\n\tval = drm_to_overlay_state(new_state)->colorkey_vb;\n\tif ((!old_state->visible && new_state->visible) ||\n\t    drm_to_overlay_state(old_state)->colorkey_vb != val)\n\t\tarmada_reg_queue_set(regs, idx, val, LCD_SPU_COLORKEY_V);\n\tval = drm_to_overlay_state(new_state)->colorkey_mode;\n\tif ((!old_state->visible && new_state->visible) ||\n\t    drm_to_overlay_state(old_state)->colorkey_mode != val)\n\t\tarmada_reg_queue_mod(regs, idx, val, CFG_CKMODE_MASK |\n\t\t\t\t     CFG_ALPHAM_MASK | CFG_ALPHA_MASK,\n\t\t\t\t     LCD_SPU_DMA_CTRL1);\n\tval = drm_to_overlay_state(new_state)->colorkey_enable;\n\tif (((!old_state->visible && new_state->visible) ||\n\t     drm_to_overlay_state(old_state)->colorkey_enable != val) &&\n\t    dcrtc->variant->has_spu_adv_reg)\n\t\tarmada_reg_queue_mod(regs, idx, val, ADV_GRACOLORKEY |\n\t\t\t\t     ADV_VIDCOLORKEY, LCD_SPU_ADV_REG);\n\n\tdcrtc->regs_idx += idx;\n}\n\nstatic void armada_drm_overlay_plane_atomic_disable(struct drm_plane *plane,\n\tstruct drm_atomic_state *state)\n{\n\tstruct drm_plane_state *old_state = drm_atomic_get_old_plane_state(state,\n\t\t\t\t\t\t\t\t\t   plane);\n\tstruct armada_crtc *dcrtc;\n\tstruct armada_regs *regs;\n\tunsigned int idx = 0;\n\n\tDRM_DEBUG_KMS(\"[PLANE:%d:%s]\\n\", plane->base.id, plane->name);\n\n\tif (!old_state->crtc)\n\t\treturn;\n\n\tDRM_DEBUG_KMS(\"[PLANE:%d:%s] was on [CRTC:%d:%s] with [FB:%d]\\n\",\n\t\tplane->base.id, plane->name,\n\t\told_state->crtc->base.id, old_state->crtc->name,\n\t\told_state->fb->base.id);\n\n\tdcrtc = drm_to_armada_crtc(old_state->crtc);\n\tregs = dcrtc->regs + dcrtc->regs_idx;\n\n\t \n\tarmada_reg_queue_mod(regs, idx, 0, CFG_DMA_ENA, LCD_SPU_DMA_CTRL0);\n\tarmada_reg_queue_mod(regs, idx, CFG_PDWN16x66 | CFG_PDWN32x66, 0,\n\t\t\t     LCD_SPU_SRAM_PARA1);\n\n\tdcrtc->regs_idx += idx;\n}\n\nstatic const struct drm_plane_helper_funcs armada_overlay_plane_helper_funcs = {\n\t.atomic_check\t= armada_drm_plane_atomic_check,\n\t.atomic_update\t= armada_drm_overlay_plane_atomic_update,\n\t.atomic_disable\t= armada_drm_overlay_plane_atomic_disable,\n};\n\nstatic int\narmada_overlay_plane_update(struct drm_plane *plane, struct drm_crtc *crtc,\n\tstruct drm_framebuffer *fb,\n\tint crtc_x, int crtc_y, unsigned crtc_w, unsigned crtc_h,\n\tuint32_t src_x, uint32_t src_y, uint32_t src_w, uint32_t src_h,\n\tstruct drm_modeset_acquire_ctx *ctx)\n{\n\tstruct drm_atomic_state *state;\n\tstruct drm_plane_state *plane_state;\n\tint ret = 0;\n\n\ttrace_armada_ovl_plane_update(plane, crtc, fb,\n\t\t\t\t crtc_x, crtc_y, crtc_w, crtc_h,\n\t\t\t\t src_x, src_y, src_w, src_h);\n\n\tstate = drm_atomic_state_alloc(plane->dev);\n\tif (!state)\n\t\treturn -ENOMEM;\n\n\tstate->acquire_ctx = ctx;\n\tplane_state = drm_atomic_get_plane_state(state, plane);\n\tif (IS_ERR(plane_state)) {\n\t\tret = PTR_ERR(plane_state);\n\t\tgoto fail;\n\t}\n\n\tret = drm_atomic_set_crtc_for_plane(plane_state, crtc);\n\tif (ret != 0)\n\t\tgoto fail;\n\n\tdrm_atomic_set_fb_for_plane(plane_state, fb);\n\tplane_state->crtc_x = crtc_x;\n\tplane_state->crtc_y = crtc_y;\n\tplane_state->crtc_h = crtc_h;\n\tplane_state->crtc_w = crtc_w;\n\tplane_state->src_x = src_x;\n\tplane_state->src_y = src_y;\n\tplane_state->src_h = src_h;\n\tplane_state->src_w = src_w;\n\n\tret = drm_atomic_nonblocking_commit(state);\nfail:\n\tdrm_atomic_state_put(state);\n\treturn ret;\n}\n\nstatic void armada_overlay_reset(struct drm_plane *plane)\n{\n\tstruct armada_overlay_state *state;\n\n\tif (plane->state)\n\t\t__drm_atomic_helper_plane_destroy_state(plane->state);\n\tkfree(plane->state);\n\tplane->state = NULL;\n\n\tstate = kzalloc(sizeof(*state), GFP_KERNEL);\n\tif (state) {\n\t\tstate->colorkey_yr = 0xfefefe00;\n\t\tstate->colorkey_ug = 0x01010100;\n\t\tstate->colorkey_vb = 0x01010100;\n\t\tstate->colorkey_mode = CFG_CKMODE(CKMODE_RGB) |\n\t\t\t\t       CFG_ALPHAM_GRA | CFG_ALPHA(0);\n\t\tstate->colorkey_enable = ADV_GRACOLORKEY;\n\t\tstate->brightness = DEFAULT_BRIGHTNESS;\n\t\tstate->contrast = DEFAULT_CONTRAST;\n\t\tstate->saturation = DEFAULT_SATURATION;\n\t\t__drm_atomic_helper_plane_reset(plane, &state->base.base);\n\t\tstate->base.base.color_encoding = DEFAULT_ENCODING;\n\t\tstate->base.base.color_range = DRM_COLOR_YCBCR_LIMITED_RANGE;\n\t}\n}\n\nstatic struct drm_plane_state *\narmada_overlay_duplicate_state(struct drm_plane *plane)\n{\n\tstruct armada_overlay_state *state;\n\n\tif (WARN_ON(!plane->state))\n\t\treturn NULL;\n\n\tstate = kmemdup(plane->state, sizeof(*state), GFP_KERNEL);\n\tif (state)\n\t\t__drm_atomic_helper_plane_duplicate_state(plane,\n\t\t\t\t\t\t\t  &state->base.base);\n\treturn &state->base.base;\n}\n\nstatic int armada_overlay_set_property(struct drm_plane *plane,\n\tstruct drm_plane_state *state, struct drm_property *property,\n\tuint64_t val)\n{\n\tstruct armada_private *priv = drm_to_armada_dev(plane->dev);\n\n#define K2R(val) (((val) >> 0) & 0xff)\n#define K2G(val) (((val) >> 8) & 0xff)\n#define K2B(val) (((val) >> 16) & 0xff)\n\tif (property == priv->colorkey_prop) {\n#define CCC(v) ((v) << 24 | (v) << 16 | (v) << 8)\n\t\tdrm_to_overlay_state(state)->colorkey_yr = CCC(K2R(val));\n\t\tdrm_to_overlay_state(state)->colorkey_ug = CCC(K2G(val));\n\t\tdrm_to_overlay_state(state)->colorkey_vb = CCC(K2B(val));\n#undef CCC\n\t} else if (property == priv->colorkey_min_prop) {\n\t\tdrm_to_overlay_state(state)->colorkey_yr &= ~0x00ff0000;\n\t\tdrm_to_overlay_state(state)->colorkey_yr |= K2R(val) << 16;\n\t\tdrm_to_overlay_state(state)->colorkey_ug &= ~0x00ff0000;\n\t\tdrm_to_overlay_state(state)->colorkey_ug |= K2G(val) << 16;\n\t\tdrm_to_overlay_state(state)->colorkey_vb &= ~0x00ff0000;\n\t\tdrm_to_overlay_state(state)->colorkey_vb |= K2B(val) << 16;\n\t} else if (property == priv->colorkey_max_prop) {\n\t\tdrm_to_overlay_state(state)->colorkey_yr &= ~0xff000000;\n\t\tdrm_to_overlay_state(state)->colorkey_yr |= K2R(val) << 24;\n\t\tdrm_to_overlay_state(state)->colorkey_ug &= ~0xff000000;\n\t\tdrm_to_overlay_state(state)->colorkey_ug |= K2G(val) << 24;\n\t\tdrm_to_overlay_state(state)->colorkey_vb &= ~0xff000000;\n\t\tdrm_to_overlay_state(state)->colorkey_vb |= K2B(val) << 24;\n\t} else if (property == priv->colorkey_val_prop) {\n\t\tdrm_to_overlay_state(state)->colorkey_yr &= ~0x0000ff00;\n\t\tdrm_to_overlay_state(state)->colorkey_yr |= K2R(val) << 8;\n\t\tdrm_to_overlay_state(state)->colorkey_ug &= ~0x0000ff00;\n\t\tdrm_to_overlay_state(state)->colorkey_ug |= K2G(val) << 8;\n\t\tdrm_to_overlay_state(state)->colorkey_vb &= ~0x0000ff00;\n\t\tdrm_to_overlay_state(state)->colorkey_vb |= K2B(val) << 8;\n\t} else if (property == priv->colorkey_alpha_prop) {\n\t\tdrm_to_overlay_state(state)->colorkey_yr &= ~0x000000ff;\n\t\tdrm_to_overlay_state(state)->colorkey_yr |= K2R(val);\n\t\tdrm_to_overlay_state(state)->colorkey_ug &= ~0x000000ff;\n\t\tdrm_to_overlay_state(state)->colorkey_ug |= K2G(val);\n\t\tdrm_to_overlay_state(state)->colorkey_vb &= ~0x000000ff;\n\t\tdrm_to_overlay_state(state)->colorkey_vb |= K2B(val);\n\t} else if (property == priv->colorkey_mode_prop) {\n\t\tif (val == CKMODE_DISABLE) {\n\t\t\tdrm_to_overlay_state(state)->colorkey_mode =\n\t\t\t\tCFG_CKMODE(CKMODE_DISABLE) |\n\t\t\t\tCFG_ALPHAM_CFG | CFG_ALPHA(255);\n\t\t\tdrm_to_overlay_state(state)->colorkey_enable = 0;\n\t\t} else {\n\t\t\tdrm_to_overlay_state(state)->colorkey_mode =\n\t\t\t\tCFG_CKMODE(val) |\n\t\t\t\tCFG_ALPHAM_GRA | CFG_ALPHA(0);\n\t\t\tdrm_to_overlay_state(state)->colorkey_enable =\n\t\t\t\tADV_GRACOLORKEY;\n\t\t}\n\t} else if (property == priv->brightness_prop) {\n\t\tdrm_to_overlay_state(state)->brightness = val - 256;\n\t} else if (property == priv->contrast_prop) {\n\t\tdrm_to_overlay_state(state)->contrast = val;\n\t} else if (property == priv->saturation_prop) {\n\t\tdrm_to_overlay_state(state)->saturation = val;\n\t} else {\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}\n\nstatic int armada_overlay_get_property(struct drm_plane *plane,\n\tconst struct drm_plane_state *state, struct drm_property *property,\n\tuint64_t *val)\n{\n\tstruct armada_private *priv = drm_to_armada_dev(plane->dev);\n\n#define C2K(c,s)\t(((c) >> (s)) & 0xff)\n#define R2BGR(r,g,b,s)\t(C2K(r,s) << 0 | C2K(g,s) << 8 | C2K(b,s) << 16)\n\tif (property == priv->colorkey_prop) {\n\t\t \n\t\t*val = R2BGR(drm_to_overlay_state(state)->colorkey_yr,\n\t\t\t     drm_to_overlay_state(state)->colorkey_ug,\n\t\t\t     drm_to_overlay_state(state)->colorkey_vb, 16);\n\t\t \n\t\tif (*val != R2BGR(drm_to_overlay_state(state)->colorkey_yr,\n\t\t\t\t  drm_to_overlay_state(state)->colorkey_ug,\n\t\t\t\t  drm_to_overlay_state(state)->colorkey_vb, 24) ||\n\t\t    *val != R2BGR(drm_to_overlay_state(state)->colorkey_yr,\n\t\t\t\t  drm_to_overlay_state(state)->colorkey_ug,\n\t\t\t\t  drm_to_overlay_state(state)->colorkey_vb, 8))\n\t\t\treturn -EINVAL;\n\t} else if (property == priv->colorkey_min_prop) {\n\t\t*val = R2BGR(drm_to_overlay_state(state)->colorkey_yr,\n\t\t\t     drm_to_overlay_state(state)->colorkey_ug,\n\t\t\t     drm_to_overlay_state(state)->colorkey_vb, 16);\n\t} else if (property == priv->colorkey_max_prop) {\n\t\t*val = R2BGR(drm_to_overlay_state(state)->colorkey_yr,\n\t\t\t     drm_to_overlay_state(state)->colorkey_ug,\n\t\t\t     drm_to_overlay_state(state)->colorkey_vb, 24);\n\t} else if (property == priv->colorkey_val_prop) {\n\t\t*val = R2BGR(drm_to_overlay_state(state)->colorkey_yr,\n\t\t\t     drm_to_overlay_state(state)->colorkey_ug,\n\t\t\t     drm_to_overlay_state(state)->colorkey_vb, 8);\n\t} else if (property == priv->colorkey_alpha_prop) {\n\t\t*val = R2BGR(drm_to_overlay_state(state)->colorkey_yr,\n\t\t\t     drm_to_overlay_state(state)->colorkey_ug,\n\t\t\t     drm_to_overlay_state(state)->colorkey_vb, 0);\n\t} else if (property == priv->colorkey_mode_prop) {\n\t\t*val = FIELD_GET(CFG_CKMODE_MASK,\n\t\t\t\t drm_to_overlay_state(state)->colorkey_mode);\n\t} else if (property == priv->brightness_prop) {\n\t\t*val = drm_to_overlay_state(state)->brightness + 256;\n\t} else if (property == priv->contrast_prop) {\n\t\t*val = drm_to_overlay_state(state)->contrast;\n\t} else if (property == priv->saturation_prop) {\n\t\t*val = drm_to_overlay_state(state)->saturation;\n\t} else {\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}\n\nstatic const struct drm_plane_funcs armada_ovl_plane_funcs = {\n\t.update_plane\t= armada_overlay_plane_update,\n\t.disable_plane\t= drm_atomic_helper_disable_plane,\n\t.destroy\t= drm_plane_helper_destroy,\n\t.reset\t\t= armada_overlay_reset,\n\t.atomic_duplicate_state = armada_overlay_duplicate_state,\n\t.atomic_destroy_state = drm_atomic_helper_plane_destroy_state,\n\t.atomic_set_property = armada_overlay_set_property,\n\t.atomic_get_property = armada_overlay_get_property,\n};\n\nstatic const uint32_t armada_ovl_formats[] = {\n\tDRM_FORMAT_UYVY,\n\tDRM_FORMAT_YUYV,\n\tDRM_FORMAT_YUV420,\n\tDRM_FORMAT_YVU420,\n\tDRM_FORMAT_YUV422,\n\tDRM_FORMAT_YVU422,\n\tDRM_FORMAT_VYUY,\n\tDRM_FORMAT_YVYU,\n\tDRM_FORMAT_ARGB8888,\n\tDRM_FORMAT_ABGR8888,\n\tDRM_FORMAT_XRGB8888,\n\tDRM_FORMAT_XBGR8888,\n\tDRM_FORMAT_RGB888,\n\tDRM_FORMAT_BGR888,\n\tDRM_FORMAT_ARGB1555,\n\tDRM_FORMAT_ABGR1555,\n\tDRM_FORMAT_RGB565,\n\tDRM_FORMAT_BGR565,\n};\n\nstatic const struct drm_prop_enum_list armada_drm_colorkey_enum_list[] = {\n\t{ CKMODE_DISABLE, \"disabled\" },\n\t{ CKMODE_Y,       \"Y component\" },\n\t{ CKMODE_U,       \"U component\" },\n\t{ CKMODE_V,       \"V component\" },\n\t{ CKMODE_RGB,     \"RGB\" },\n\t{ CKMODE_R,       \"R component\" },\n\t{ CKMODE_G,       \"G component\" },\n\t{ CKMODE_B,       \"B component\" },\n};\n\nstatic int armada_overlay_create_properties(struct drm_device *dev)\n{\n\tstruct armada_private *priv = drm_to_armada_dev(dev);\n\n\tif (priv->colorkey_prop)\n\t\treturn 0;\n\n\tpriv->colorkey_prop = drm_property_create_range(dev, 0,\n\t\t\t\t\"colorkey\", 0, 0xffffff);\n\tpriv->colorkey_min_prop = drm_property_create_range(dev, 0,\n\t\t\t\t\"colorkey_min\", 0, 0xffffff);\n\tpriv->colorkey_max_prop = drm_property_create_range(dev, 0,\n\t\t\t\t\"colorkey_max\", 0, 0xffffff);\n\tpriv->colorkey_val_prop = drm_property_create_range(dev, 0,\n\t\t\t\t\"colorkey_val\", 0, 0xffffff);\n\tpriv->colorkey_alpha_prop = drm_property_create_range(dev, 0,\n\t\t\t\t\"colorkey_alpha\", 0, 0xffffff);\n\tpriv->colorkey_mode_prop = drm_property_create_enum(dev, 0,\n\t\t\t\t\"colorkey_mode\",\n\t\t\t\tarmada_drm_colorkey_enum_list,\n\t\t\t\tARRAY_SIZE(armada_drm_colorkey_enum_list));\n\tpriv->brightness_prop = drm_property_create_range(dev, 0,\n\t\t\t\t\"brightness\", 0, 256 + 255);\n\tpriv->contrast_prop = drm_property_create_range(dev, 0,\n\t\t\t\t\"contrast\", 0, 0x7fff);\n\tpriv->saturation_prop = drm_property_create_range(dev, 0,\n\t\t\t\t\"saturation\", 0, 0x7fff);\n\n\tif (!priv->colorkey_prop)\n\t\treturn -ENOMEM;\n\n\treturn 0;\n}\n\nint armada_overlay_plane_create(struct drm_device *dev, unsigned long crtcs)\n{\n\tstruct armada_private *priv = drm_to_armada_dev(dev);\n\tstruct drm_mode_object *mobj;\n\tstruct drm_plane *overlay;\n\tint ret;\n\n\tret = armada_overlay_create_properties(dev);\n\tif (ret)\n\t\treturn ret;\n\n\toverlay = kzalloc(sizeof(*overlay), GFP_KERNEL);\n\tif (!overlay)\n\t\treturn -ENOMEM;\n\n\tdrm_plane_helper_add(overlay, &armada_overlay_plane_helper_funcs);\n\n\tret = drm_universal_plane_init(dev, overlay, crtcs,\n\t\t\t\t       &armada_ovl_plane_funcs,\n\t\t\t\t       armada_ovl_formats,\n\t\t\t\t       ARRAY_SIZE(armada_ovl_formats),\n\t\t\t\t       NULL,\n\t\t\t\t       DRM_PLANE_TYPE_OVERLAY, NULL);\n\tif (ret) {\n\t\tkfree(overlay);\n\t\treturn ret;\n\t}\n\n\tmobj = &overlay->base;\n\tdrm_object_attach_property(mobj, priv->colorkey_prop,\n\t\t\t\t   0x0101fe);\n\tdrm_object_attach_property(mobj, priv->colorkey_min_prop,\n\t\t\t\t   0x0101fe);\n\tdrm_object_attach_property(mobj, priv->colorkey_max_prop,\n\t\t\t\t   0x0101fe);\n\tdrm_object_attach_property(mobj, priv->colorkey_val_prop,\n\t\t\t\t   0x0101fe);\n\tdrm_object_attach_property(mobj, priv->colorkey_alpha_prop,\n\t\t\t\t   0x000000);\n\tdrm_object_attach_property(mobj, priv->colorkey_mode_prop,\n\t\t\t\t   CKMODE_RGB);\n\tdrm_object_attach_property(mobj, priv->brightness_prop,\n\t\t\t\t   256 + DEFAULT_BRIGHTNESS);\n\tdrm_object_attach_property(mobj, priv->contrast_prop,\n\t\t\t\t   DEFAULT_CONTRAST);\n\tdrm_object_attach_property(mobj, priv->saturation_prop,\n\t\t\t\t   DEFAULT_SATURATION);\n\n\tret = drm_plane_create_color_properties(overlay,\n\t\t\t\t\t\tBIT(DRM_COLOR_YCBCR_BT601) |\n\t\t\t\t\t\tBIT(DRM_COLOR_YCBCR_BT709),\n\t\t\t\t\t\tBIT(DRM_COLOR_YCBCR_LIMITED_RANGE),\n\t\t\t\t\t\tDEFAULT_ENCODING,\n\t\t\t\t\t\tDRM_COLOR_YCBCR_LIMITED_RANGE);\n\n\treturn ret;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}