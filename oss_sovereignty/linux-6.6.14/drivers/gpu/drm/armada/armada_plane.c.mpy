{
  "module_name": "armada_plane.c",
  "hash_id": "25d708b50a43da978c89333c40241ab539cf3cb23a191cc80908d7a42b068f7a",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/armada/armada_plane.c",
  "human_readable_source": "\n \n\n#include <drm/drm_atomic.h>\n#include <drm/drm_atomic_helper.h>\n#include <drm/drm_fourcc.h>\n#include <drm/drm_plane_helper.h>\n\n#include \"armada_crtc.h\"\n#include \"armada_drm.h\"\n#include \"armada_fb.h\"\n#include \"armada_gem.h\"\n#include \"armada_hw.h\"\n#include \"armada_plane.h\"\n#include \"armada_trace.h\"\n\nstatic const uint32_t armada_primary_formats[] = {\n\tDRM_FORMAT_UYVY,\n\tDRM_FORMAT_YUYV,\n\tDRM_FORMAT_VYUY,\n\tDRM_FORMAT_YVYU,\n\tDRM_FORMAT_ARGB8888,\n\tDRM_FORMAT_ABGR8888,\n\tDRM_FORMAT_XRGB8888,\n\tDRM_FORMAT_XBGR8888,\n\tDRM_FORMAT_RGB888,\n\tDRM_FORMAT_BGR888,\n\tDRM_FORMAT_ARGB1555,\n\tDRM_FORMAT_ABGR1555,\n\tDRM_FORMAT_RGB565,\n\tDRM_FORMAT_BGR565,\n};\n\nvoid armada_drm_plane_calc(struct drm_plane_state *state, u32 addrs[2][3],\n\tu16 pitches[3], bool interlaced)\n{\n\tstruct drm_framebuffer *fb = state->fb;\n\tconst struct drm_format_info *format = fb->format;\n\tunsigned int num_planes = format->num_planes;\n\tunsigned int x = state->src.x1 >> 16;\n\tunsigned int y = state->src.y1 >> 16;\n\tu32 addr = drm_fb_obj(fb)->dev_addr;\n\tint i;\n\n\tDRM_DEBUG_KMS(\"pitch %u x %d y %d bpp %d\\n\",\n\t\t      fb->pitches[0], x, y, format->cpp[0] * 8);\n\n\tif (num_planes > 3)\n\t\tnum_planes = 3;\n\n\taddrs[0][0] = addr + fb->offsets[0] + y * fb->pitches[0] +\n\t\t      x * format->cpp[0];\n\tpitches[0] = fb->pitches[0];\n\n\ty /= format->vsub;\n\tx /= format->hsub;\n\n\tfor (i = 1; i < num_planes; i++) {\n\t\taddrs[0][i] = addr + fb->offsets[i] + y * fb->pitches[i] +\n\t\t\t      x * format->cpp[i];\n\t\tpitches[i] = fb->pitches[i];\n\t}\n\tfor (; i < 3; i++) {\n\t\taddrs[0][i] = 0;\n\t\tpitches[i] = 0;\n\t}\n\tif (interlaced) {\n\t\tfor (i = 0; i < 3; i++) {\n\t\t\taddrs[1][i] = addrs[0][i] + pitches[i];\n\t\t\tpitches[i] *= 2;\n\t\t}\n\t} else {\n\t\tfor (i = 0; i < 3; i++)\n\t\t\taddrs[1][i] = addrs[0][i];\n\t}\n}\n\nint armada_drm_plane_atomic_check(struct drm_plane *plane,\n\tstruct drm_atomic_state *state)\n{\n\tstruct drm_plane_state *new_plane_state = drm_atomic_get_new_plane_state(state,\n\t\t\t\t\t\t\t\t\t\t plane);\n\tstruct armada_plane_state *st = to_armada_plane_state(new_plane_state);\n\tstruct drm_crtc *crtc = new_plane_state->crtc;\n\tstruct drm_crtc_state *crtc_state;\n\tbool interlace;\n\tint ret;\n\n\tif (!new_plane_state->fb || WARN_ON(!new_plane_state->crtc)) {\n\t\tnew_plane_state->visible = false;\n\t\treturn 0;\n\t}\n\n\tif (state)\n\t\tcrtc_state = drm_atomic_get_existing_crtc_state(state,\n\t\t\t\t\t\t\t\tcrtc);\n\telse\n\t\tcrtc_state = crtc->state;\n\n\tret = drm_atomic_helper_check_plane_state(new_plane_state, crtc_state,\n\t\t\t\t\t\t  0,\n\t\t\t\t\t\t  INT_MAX, true, false);\n\tif (ret)\n\t\treturn ret;\n\n\tinterlace = crtc_state->adjusted_mode.flags & DRM_MODE_FLAG_INTERLACE;\n\tif (interlace) {\n\t\tif ((new_plane_state->dst.y1 | new_plane_state->dst.y2) & 1)\n\t\t\treturn -EINVAL;\n\t\tst->src_hw = drm_rect_height(&new_plane_state->src) >> 17;\n\t\tst->dst_yx = new_plane_state->dst.y1 >> 1;\n\t\tst->dst_hw = drm_rect_height(&new_plane_state->dst) >> 1;\n\t} else {\n\t\tst->src_hw = drm_rect_height(&new_plane_state->src) >> 16;\n\t\tst->dst_yx = new_plane_state->dst.y1;\n\t\tst->dst_hw = drm_rect_height(&new_plane_state->dst);\n\t}\n\n\tst->src_hw <<= 16;\n\tst->src_hw |= drm_rect_width(&new_plane_state->src) >> 16;\n\tst->dst_yx <<= 16;\n\tst->dst_yx |= new_plane_state->dst.x1 & 0x0000ffff;\n\tst->dst_hw <<= 16;\n\tst->dst_hw |= drm_rect_width(&new_plane_state->dst) & 0x0000ffff;\n\n\tarmada_drm_plane_calc(new_plane_state, st->addrs, st->pitches,\n\t\t\t      interlace);\n\tst->interlace = interlace;\n\n\treturn 0;\n}\n\nstatic void armada_drm_primary_plane_atomic_update(struct drm_plane *plane,\n\tstruct drm_atomic_state *state)\n{\n\tstruct drm_plane_state *old_state = drm_atomic_get_old_plane_state(state,\n\t\t\t\t\t\t\t\t\t   plane);\n\tstruct drm_plane_state *new_state = drm_atomic_get_new_plane_state(state,\n\t\t\t\t\t\t\t\t\t   plane);\n\tstruct armada_crtc *dcrtc;\n\tstruct armada_regs *regs;\n\tu32 cfg, cfg_mask, val;\n\tunsigned int idx;\n\n\tDRM_DEBUG_KMS(\"[PLANE:%d:%s]\\n\", plane->base.id, plane->name);\n\n\tif (!new_state->fb || WARN_ON(!new_state->crtc))\n\t\treturn;\n\n\tDRM_DEBUG_KMS(\"[PLANE:%d:%s] is on [CRTC:%d:%s] with [FB:%d] visible %u->%u\\n\",\n\t\tplane->base.id, plane->name,\n\t\tnew_state->crtc->base.id, new_state->crtc->name,\n\t\tnew_state->fb->base.id,\n\t\told_state->visible, new_state->visible);\n\n\tdcrtc = drm_to_armada_crtc(new_state->crtc);\n\tregs = dcrtc->regs + dcrtc->regs_idx;\n\n\tidx = 0;\n\tif (!old_state->visible && new_state->visible) {\n\t\tval = CFG_PDWN64x66;\n\t\tif (drm_fb_to_armada_fb(new_state->fb)->fmt > CFG_420)\n\t\t\tval |= CFG_PDWN256x24;\n\t\tarmada_reg_queue_mod(regs, idx, 0, val, LCD_SPU_SRAM_PARA1);\n\t}\n\tval = armada_src_hw(new_state);\n\tif (armada_src_hw(old_state) != val)\n\t\tarmada_reg_queue_set(regs, idx, val, LCD_SPU_GRA_HPXL_VLN);\n\tval = armada_dst_yx(new_state);\n\tif (armada_dst_yx(old_state) != val)\n\t\tarmada_reg_queue_set(regs, idx, val, LCD_SPU_GRA_OVSA_HPXL_VLN);\n\tval = armada_dst_hw(new_state);\n\tif (armada_dst_hw(old_state) != val)\n\t\tarmada_reg_queue_set(regs, idx, val, LCD_SPU_GZM_HPXL_VLN);\n\tif (old_state->src.x1 != new_state->src.x1 ||\n\t    old_state->src.y1 != new_state->src.y1 ||\n\t    old_state->fb != new_state->fb ||\n\t    new_state->crtc->state->mode_changed) {\n\t\tarmada_reg_queue_set(regs, idx, armada_addr(new_state, 0, 0),\n\t\t\t\t     LCD_CFG_GRA_START_ADDR0);\n\t\tarmada_reg_queue_set(regs, idx, armada_addr(new_state, 1, 0),\n\t\t\t\t     LCD_CFG_GRA_START_ADDR1);\n\t\tarmada_reg_queue_mod(regs, idx, armada_pitch(new_state, 0),\n\t\t\t\t     0xffff,\n\t\t\t\t     LCD_CFG_GRA_PITCH);\n\t}\n\tif (old_state->fb != new_state->fb ||\n\t    new_state->crtc->state->mode_changed) {\n\t\tcfg = CFG_GRA_FMT(drm_fb_to_armada_fb(new_state->fb)->fmt) |\n\t\t      CFG_GRA_MOD(drm_fb_to_armada_fb(new_state->fb)->mod);\n\t\tif (drm_fb_to_armada_fb(new_state->fb)->fmt > CFG_420)\n\t\t\tcfg |= CFG_PALETTE_ENA;\n\t\tif (new_state->visible)\n\t\t\tcfg |= CFG_GRA_ENA;\n\t\tif (to_armada_plane_state(new_state)->interlace)\n\t\t\tcfg |= CFG_GRA_FTOGGLE;\n\t\tcfg_mask = CFG_GRAFORMAT |\n\t\t\t   CFG_GRA_MOD(CFG_SWAPRB | CFG_SWAPUV |\n\t\t\t\t       CFG_SWAPYU | CFG_YUV2RGB) |\n\t\t\t   CFG_PALETTE_ENA | CFG_GRA_FTOGGLE |\n\t\t\t   CFG_GRA_ENA;\n\t} else if (old_state->visible != new_state->visible) {\n\t\tcfg = new_state->visible ? CFG_GRA_ENA : 0;\n\t\tcfg_mask = CFG_GRA_ENA;\n\t} else {\n\t\tcfg = cfg_mask = 0;\n\t}\n\tif (drm_rect_width(&old_state->src) != drm_rect_width(&new_state->src) ||\n\t    drm_rect_width(&old_state->dst) != drm_rect_width(&new_state->dst)) {\n\t\tcfg_mask |= CFG_GRA_HSMOOTH;\n\t\tif (drm_rect_width(&new_state->src) >> 16 !=\n\t\t    drm_rect_width(&new_state->dst))\n\t\t\tcfg |= CFG_GRA_HSMOOTH;\n\t}\n\n\tif (cfg_mask)\n\t\tarmada_reg_queue_mod(regs, idx, cfg, cfg_mask,\n\t\t\t\t     LCD_SPU_DMA_CTRL0);\n\n\tdcrtc->regs_idx += idx;\n}\n\nstatic void armada_drm_primary_plane_atomic_disable(struct drm_plane *plane,\n\tstruct drm_atomic_state *state)\n{\n\tstruct drm_plane_state *old_state = drm_atomic_get_old_plane_state(state,\n\t\t\t\t\t\t\t\t\t   plane);\n\tstruct armada_crtc *dcrtc;\n\tstruct armada_regs *regs;\n\tunsigned int idx = 0;\n\n\tDRM_DEBUG_KMS(\"[PLANE:%d:%s]\\n\", plane->base.id, plane->name);\n\n\tif (!old_state->crtc)\n\t\treturn;\n\n\tDRM_DEBUG_KMS(\"[PLANE:%d:%s] was on [CRTC:%d:%s] with [FB:%d]\\n\",\n\t\tplane->base.id, plane->name,\n\t\told_state->crtc->base.id, old_state->crtc->name,\n\t\told_state->fb->base.id);\n\n\tdcrtc = drm_to_armada_crtc(old_state->crtc);\n\tregs = dcrtc->regs + dcrtc->regs_idx;\n\n\t \n\tarmada_reg_queue_mod(regs, idx, 0, CFG_GRA_ENA, LCD_SPU_DMA_CTRL0);\n\tarmada_reg_queue_mod(regs, idx, CFG_PDWN256x32 | CFG_PDWN256x24 |\n\t\t\t     CFG_PDWN32x32 | CFG_PDWN64x66,\n\t\t\t     0, LCD_SPU_SRAM_PARA1);\n\n\tdcrtc->regs_idx += idx;\n}\n\nstatic const struct drm_plane_helper_funcs armada_primary_plane_helper_funcs = {\n\t.atomic_check\t= armada_drm_plane_atomic_check,\n\t.atomic_update\t= armada_drm_primary_plane_atomic_update,\n\t.atomic_disable\t= armada_drm_primary_plane_atomic_disable,\n};\n\nvoid armada_plane_reset(struct drm_plane *plane)\n{\n\tstruct armada_plane_state *st;\n\tif (plane->state)\n\t\t__drm_atomic_helper_plane_destroy_state(plane->state);\n\tkfree(plane->state);\n\tst = kzalloc(sizeof(*st), GFP_KERNEL);\n\tif (st)\n\t\t__drm_atomic_helper_plane_reset(plane, &st->base);\n}\n\nstruct drm_plane_state *armada_plane_duplicate_state(struct drm_plane *plane)\n{\n\tstruct armada_plane_state *st;\n\n\tif (WARN_ON(!plane->state))\n\t\treturn NULL;\n\n\tst = kmemdup(plane->state, sizeof(*st), GFP_KERNEL);\n\tif (st)\n\t\t__drm_atomic_helper_plane_duplicate_state(plane, &st->base);\n\n\treturn &st->base;\n}\n\nstatic const struct drm_plane_funcs armada_primary_plane_funcs = {\n\t.update_plane\t= drm_atomic_helper_update_plane,\n\t.disable_plane\t= drm_atomic_helper_disable_plane,\n\t.destroy\t= drm_plane_helper_destroy,\n\t.reset\t\t= armada_plane_reset,\n\t.atomic_duplicate_state = armada_plane_duplicate_state,\n\t.atomic_destroy_state = drm_atomic_helper_plane_destroy_state,\n};\n\nint armada_drm_primary_plane_init(struct drm_device *drm,\n\tstruct drm_plane *primary)\n{\n\tint ret;\n\n\tdrm_plane_helper_add(primary, &armada_primary_plane_helper_funcs);\n\n\tret = drm_universal_plane_init(drm, primary, 0,\n\t\t\t\t       &armada_primary_plane_funcs,\n\t\t\t\t       armada_primary_formats,\n\t\t\t\t       ARRAY_SIZE(armada_primary_formats),\n\t\t\t\t       NULL,\n\t\t\t\t       DRM_PLANE_TYPE_PRIMARY, NULL);\n\n\treturn ret;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}