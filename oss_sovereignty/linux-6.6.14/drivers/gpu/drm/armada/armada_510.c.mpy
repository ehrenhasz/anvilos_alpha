{
  "module_name": "armada_510.c",
  "hash_id": "6a7b1942ef678dcd444c85144d4edfe0795bcd7c0f45d1b50fba180bc4be0e33",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/armada/armada_510.c",
  "human_readable_source": "\n \n#include <linux/clk.h>\n#include <linux/io.h>\n#include <linux/of.h>\n#include <drm/drm_probe_helper.h>\n#include \"armada_crtc.h\"\n#include \"armada_drm.h\"\n#include \"armada_hw.h\"\n\nstruct armada510_variant_data {\n\tstruct clk *clks[4];\n\tstruct clk *sel_clk;\n};\n\nstatic int armada510_crtc_init(struct armada_crtc *dcrtc, struct device *dev)\n{\n\tstruct armada510_variant_data *v;\n\tstruct clk *clk;\n\tint idx;\n\n\tv = devm_kzalloc(dev, sizeof(*v), GFP_KERNEL);\n\tif (!v)\n\t\treturn -ENOMEM;\n\n\tdcrtc->variant_data = v;\n\n\tif (dev->of_node) {\n\t\tstruct property *prop;\n\t\tconst char *s;\n\n\t\tof_property_for_each_string(dev->of_node, \"clock-names\", prop,\n\t\t\t\t\t    s) {\n\t\t\tif (!strcmp(s, \"ext_ref_clk0\"))\n\t\t\t\tidx = 0;\n\t\t\telse if (!strcmp(s, \"ext_ref_clk1\"))\n\t\t\t\tidx = 1;\n\t\t\telse if (!strcmp(s, \"plldivider\"))\n\t\t\t\tidx = 2;\n\t\t\telse if (!strcmp(s, \"axibus\"))\n\t\t\t\tidx = 3;\n\t\t\telse\n\t\t\t\tcontinue;\n\n\t\t\tclk = devm_clk_get(dev, s);\n\t\t\tif (IS_ERR(clk))\n\t\t\t\treturn PTR_ERR(clk) == -ENOENT ? -EPROBE_DEFER :\n\t\t\t\t\tPTR_ERR(clk);\n\t\t\tv->clks[idx] = clk;\n\t\t}\n\t} else {\n\t\tclk = devm_clk_get(dev, \"ext_ref_clk1\");\n\t\tif (IS_ERR(clk))\n\t\t\treturn PTR_ERR(clk) == -ENOENT ? -EPROBE_DEFER :\n\t\t\t\tPTR_ERR(clk);\n\n\t\tv->clks[1] = clk;\n\t}\n\n\t \n\tarmada_updatel(CFG_DMA_WM(0x20), CFG_SRAM_WAIT | CFG_DMA_WM_MASK,\n\t\t       dcrtc->base + LCD_CFG_RDREG4F);\n\n\t \n\twritel_relaxed(ADV_HWC32ENABLE | ADV_HWC32ARGB | ADV_HWC32BLEND,\n\t\t       dcrtc->base + LCD_SPU_ADV_REG);\n\n\treturn 0;\n}\n\nstatic const u32 armada510_clk_sels[] = {\n\tSCLK_510_EXTCLK0,\n\tSCLK_510_EXTCLK1,\n\tSCLK_510_PLL,\n\tSCLK_510_AXI,\n};\n\nstatic const struct armada_clocking_params armada510_clocking = {\n\t \n\t.permillage_min = 994,\n\t.permillage_max = 1005,\n\t.settable = BIT(0) | BIT(1),\n\t.div_max = SCLK_510_INT_DIV_MASK,\n};\n\n \nstatic int armada510_crtc_compute_clock(struct armada_crtc *dcrtc,\n\tconst struct drm_display_mode *mode, uint32_t *sclk)\n{\n\tstruct armada510_variant_data *v = dcrtc->variant_data;\n\tunsigned long desired_khz = mode->crtc_clock;\n\tstruct armada_clk_result res;\n\tint ret, idx;\n\n\tidx = armada_crtc_select_clock(dcrtc, &res, &armada510_clocking,\n\t\t\t\t       v->clks, ARRAY_SIZE(v->clks),\n\t\t\t\t       desired_khz);\n\tif (idx < 0)\n\t\treturn idx;\n\n\tret = clk_prepare_enable(res.clk);\n\tif (ret)\n\t\treturn ret;\n\n\tif (sclk) {\n\t\tclk_set_rate(res.clk, res.desired_clk_hz);\n\n\t\t*sclk = res.div | armada510_clk_sels[idx];\n\n\t\t \n\t\tv->sel_clk = res.clk;\n\t\tswap(dcrtc->clk, res.clk);\n\t}\n\n\tclk_disable_unprepare(res.clk);\n\n\treturn 0;\n}\n\nstatic void armada510_crtc_disable(struct armada_crtc *dcrtc)\n{\n\tif (dcrtc->clk) {\n\t\tclk_disable_unprepare(dcrtc->clk);\n\t\tdcrtc->clk = NULL;\n\t}\n}\n\nstatic void armada510_crtc_enable(struct armada_crtc *dcrtc,\n\tconst struct drm_display_mode *mode)\n{\n\tstruct armada510_variant_data *v = dcrtc->variant_data;\n\n\tif (!dcrtc->clk && v->sel_clk) {\n\t\tif (!WARN_ON(clk_prepare_enable(v->sel_clk)))\n\t\t\tdcrtc->clk = v->sel_clk;\n\t}\n}\n\nconst struct armada_variant armada510_ops = {\n\t.has_spu_adv_reg = true,\n\t.init = armada510_crtc_init,\n\t.compute_clock = armada510_crtc_compute_clock,\n\t.disable = armada510_crtc_disable,\n\t.enable = armada510_crtc_enable,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}