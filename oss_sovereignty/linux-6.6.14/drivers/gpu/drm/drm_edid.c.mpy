{
  "module_name": "drm_edid.c",
  "hash_id": "3f3d2bf42b7e64b718999c903786ac78aa7091eb90cdc19d9eaa3fd501746626",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/drm_edid.c",
  "human_readable_source": " \n\n#include <linux/bitfield.h>\n#include <linux/hdmi.h>\n#include <linux/i2c.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/pci.h>\n#include <linux/slab.h>\n#include <linux/vga_switcheroo.h>\n\n#include <drm/drm_displayid.h>\n#include <drm/drm_drv.h>\n#include <drm/drm_edid.h>\n#include <drm/drm_encoder.h>\n#include <drm/drm_print.h>\n\n#include \"drm_crtc_internal.h\"\n\nstatic int oui(u8 first, u8 second, u8 third)\n{\n\treturn (first << 16) | (second << 8) | third;\n}\n\n#define EDID_EST_TIMINGS 16\n#define EDID_STD_TIMINGS 8\n#define EDID_DETAILED_TIMINGS 4\n\n \n\n \n#define EDID_QUIRK_PREFER_LARGE_60\t\t(1 << 0)\n \n#define EDID_QUIRK_135_CLOCK_TOO_HIGH\t\t(1 << 1)\n \n#define EDID_QUIRK_PREFER_LARGE_75\t\t(1 << 2)\n \n#define EDID_QUIRK_DETAILED_IN_CM\t\t(1 << 3)\n \n#define EDID_QUIRK_DETAILED_USE_MAXIMUM_SIZE\t(1 << 4)\n \n#define EDID_QUIRK_DETAILED_SYNC_PP\t\t(1 << 6)\n \n#define EDID_QUIRK_FORCE_REDUCED_BLANKING\t(1 << 7)\n \n#define EDID_QUIRK_FORCE_8BPC\t\t\t(1 << 8)\n \n#define EDID_QUIRK_FORCE_12BPC\t\t\t(1 << 9)\n \n#define EDID_QUIRK_FORCE_6BPC\t\t\t(1 << 10)\n \n#define EDID_QUIRK_FORCE_10BPC\t\t\t(1 << 11)\n \n#define EDID_QUIRK_NON_DESKTOP\t\t\t(1 << 12)\n \n#define EDID_QUIRK_CAP_DSC_15BPP\t\t(1 << 13)\n\n#define MICROSOFT_IEEE_OUI\t0xca125c\n\nstruct detailed_mode_closure {\n\tstruct drm_connector *connector;\n\tconst struct drm_edid *drm_edid;\n\tbool preferred;\n\tint modes;\n};\n\n#define LEVEL_DMT\t0\n#define LEVEL_GTF\t1\n#define LEVEL_GTF2\t2\n#define LEVEL_CVT\t3\n\n#define EDID_QUIRK(vend_chr_0, vend_chr_1, vend_chr_2, product_id, _quirks) \\\n{ \\\n\t.panel_id = drm_edid_encode_panel_id(vend_chr_0, vend_chr_1, vend_chr_2, \\\n\t\t\t\t\t     product_id), \\\n\t.quirks = _quirks \\\n}\n\nstatic const struct edid_quirk {\n\tu32 panel_id;\n\tu32 quirks;\n} edid_quirk_list[] = {\n\t \n\tEDID_QUIRK('A', 'C', 'R', 44358, EDID_QUIRK_PREFER_LARGE_60),\n\t \n\tEDID_QUIRK('A', 'P', 'I', 0x7602, EDID_QUIRK_PREFER_LARGE_60),\n\n\t \n\tEDID_QUIRK('A', 'E', 'O', 0, EDID_QUIRK_FORCE_6BPC),\n\n\t \n\tEDID_QUIRK('B', 'N', 'Q', 0x78d6, EDID_QUIRK_FORCE_8BPC),\n\n\t \n\tEDID_QUIRK('B', 'O', 'E', 0x78b, EDID_QUIRK_FORCE_6BPC),\n\n\t \n\tEDID_QUIRK('C', 'P', 'T', 0x17df, EDID_QUIRK_FORCE_6BPC),\n\n\t \n\tEDID_QUIRK('S', 'D', 'C', 0x3652, EDID_QUIRK_FORCE_6BPC),\n\n\t \n\tEDID_QUIRK('B', 'O', 'E', 0x0771, EDID_QUIRK_FORCE_6BPC),\n\n\t \n\tEDID_QUIRK('M', 'A', 'X', 1516, EDID_QUIRK_PREFER_LARGE_60),\n\tEDID_QUIRK('M', 'A', 'X', 0x77e, EDID_QUIRK_PREFER_LARGE_60),\n\n\t \n\tEDID_QUIRK('E', 'P', 'I', 59264, EDID_QUIRK_135_CLOCK_TOO_HIGH),\n\t \n\tEDID_QUIRK('E', 'P', 'I', 8232, EDID_QUIRK_PREFER_LARGE_60),\n\n\t \n\tEDID_QUIRK('F', 'C', 'M', 13600, EDID_QUIRK_PREFER_LARGE_75 |\n\t\t\t\t       EDID_QUIRK_DETAILED_IN_CM),\n\n\t \n\tEDID_QUIRK('G', 'S', 'M', 0x5bbf, EDID_QUIRK_CAP_DSC_15BPP),\n\n\t \n\tEDID_QUIRK('G', 'S', 'M', 0x5b9a, EDID_QUIRK_CAP_DSC_15BPP),\n\n\t \n\tEDID_QUIRK('L', 'G', 'D', 764, EDID_QUIRK_FORCE_10BPC),\n\n\t \n\tEDID_QUIRK('L', 'P', 'L', 0, EDID_QUIRK_DETAILED_USE_MAXIMUM_SIZE),\n\tEDID_QUIRK('L', 'P', 'L', 0x2a00, EDID_QUIRK_DETAILED_USE_MAXIMUM_SIZE),\n\n\t \n\tEDID_QUIRK('S', 'A', 'M', 541, EDID_QUIRK_DETAILED_SYNC_PP),\n\t \n\tEDID_QUIRK('S', 'A', 'M', 596, EDID_QUIRK_PREFER_LARGE_60),\n\tEDID_QUIRK('S', 'A', 'M', 638, EDID_QUIRK_PREFER_LARGE_60),\n\n\t \n\tEDID_QUIRK('S', 'N', 'Y', 0x2541, EDID_QUIRK_FORCE_12BPC),\n\n\t \n\tEDID_QUIRK('V', 'S', 'C', 5020, EDID_QUIRK_FORCE_REDUCED_BLANKING),\n\n\t \n\tEDID_QUIRK('M', 'E', 'D', 0x7b8, EDID_QUIRK_PREFER_LARGE_75),\n\n\t \n\tEDID_QUIRK('S', 'D', 'C', 18514, EDID_QUIRK_FORCE_6BPC),\n\n\t \n\tEDID_QUIRK('S', 'E', 'C', 0xd033, EDID_QUIRK_FORCE_8BPC),\n\n\t \n\tEDID_QUIRK('E', 'T', 'R', 13896, EDID_QUIRK_FORCE_8BPC),\n\n\t \n\tEDID_QUIRK('V', 'L', 'V', 0x91a8, EDID_QUIRK_NON_DESKTOP),\n\tEDID_QUIRK('V', 'L', 'V', 0x91b0, EDID_QUIRK_NON_DESKTOP),\n\tEDID_QUIRK('V', 'L', 'V', 0x91b1, EDID_QUIRK_NON_DESKTOP),\n\tEDID_QUIRK('V', 'L', 'V', 0x91b2, EDID_QUIRK_NON_DESKTOP),\n\tEDID_QUIRK('V', 'L', 'V', 0x91b3, EDID_QUIRK_NON_DESKTOP),\n\tEDID_QUIRK('V', 'L', 'V', 0x91b4, EDID_QUIRK_NON_DESKTOP),\n\tEDID_QUIRK('V', 'L', 'V', 0x91b5, EDID_QUIRK_NON_DESKTOP),\n\tEDID_QUIRK('V', 'L', 'V', 0x91b6, EDID_QUIRK_NON_DESKTOP),\n\tEDID_QUIRK('V', 'L', 'V', 0x91b7, EDID_QUIRK_NON_DESKTOP),\n\tEDID_QUIRK('V', 'L', 'V', 0x91b8, EDID_QUIRK_NON_DESKTOP),\n\tEDID_QUIRK('V', 'L', 'V', 0x91b9, EDID_QUIRK_NON_DESKTOP),\n\tEDID_QUIRK('V', 'L', 'V', 0x91ba, EDID_QUIRK_NON_DESKTOP),\n\tEDID_QUIRK('V', 'L', 'V', 0x91bb, EDID_QUIRK_NON_DESKTOP),\n\tEDID_QUIRK('V', 'L', 'V', 0x91bc, EDID_QUIRK_NON_DESKTOP),\n\tEDID_QUIRK('V', 'L', 'V', 0x91bd, EDID_QUIRK_NON_DESKTOP),\n\tEDID_QUIRK('V', 'L', 'V', 0x91be, EDID_QUIRK_NON_DESKTOP),\n\tEDID_QUIRK('V', 'L', 'V', 0x91bf, EDID_QUIRK_NON_DESKTOP),\n\n\t \n\tEDID_QUIRK('H', 'V', 'R', 0xaa01, EDID_QUIRK_NON_DESKTOP),\n\tEDID_QUIRK('H', 'V', 'R', 0xaa02, EDID_QUIRK_NON_DESKTOP),\n\n\t \n\tEDID_QUIRK('O', 'V', 'R', 0x0001, EDID_QUIRK_NON_DESKTOP),\n\tEDID_QUIRK('O', 'V', 'R', 0x0003, EDID_QUIRK_NON_DESKTOP),\n\tEDID_QUIRK('O', 'V', 'R', 0x0004, EDID_QUIRK_NON_DESKTOP),\n\tEDID_QUIRK('O', 'V', 'R', 0x0012, EDID_QUIRK_NON_DESKTOP),\n\n\t \n\tEDID_QUIRK('A', 'C', 'R', 0x7fce, EDID_QUIRK_NON_DESKTOP),\n\tEDID_QUIRK('L', 'E', 'N', 0x0408, EDID_QUIRK_NON_DESKTOP),\n\tEDID_QUIRK('F', 'U', 'J', 0x1970, EDID_QUIRK_NON_DESKTOP),\n\tEDID_QUIRK('D', 'E', 'L', 0x7fce, EDID_QUIRK_NON_DESKTOP),\n\tEDID_QUIRK('S', 'E', 'C', 0x144a, EDID_QUIRK_NON_DESKTOP),\n\tEDID_QUIRK('A', 'U', 'S', 0xc102, EDID_QUIRK_NON_DESKTOP),\n\n\t \n\tEDID_QUIRK('S', 'N', 'Y', 0x0704, EDID_QUIRK_NON_DESKTOP),\n\n\t \n\tEDID_QUIRK('S', 'E', 'N', 0x1019, EDID_QUIRK_NON_DESKTOP),\n\n\t \n\tEDID_QUIRK('S', 'V', 'R', 0x1019, EDID_QUIRK_NON_DESKTOP),\n\tEDID_QUIRK('A', 'U', 'O', 0x1111, EDID_QUIRK_NON_DESKTOP),\n};\n\n \nstatic const struct drm_display_mode drm_dmt_modes[] = {\n\t \n\t{ DRM_MODE(\"640x350\", DRM_MODE_TYPE_DRIVER, 31500, 640, 672,\n\t\t   736, 832, 0, 350, 382, 385, 445, 0,\n\t\t   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_NVSYNC) },\n\t \n\t{ DRM_MODE(\"640x400\", DRM_MODE_TYPE_DRIVER, 31500, 640, 672,\n\t\t   736, 832, 0, 400, 401, 404, 445, 0,\n\t\t   DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_PVSYNC) },\n\t \n\t{ DRM_MODE(\"720x400\", DRM_MODE_TYPE_DRIVER, 35500, 720, 756,\n\t\t   828, 936, 0, 400, 401, 404, 446, 0,\n\t\t   DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_PVSYNC) },\n\t \n\t{ DRM_MODE(\"640x480\", DRM_MODE_TYPE_DRIVER, 25175, 640, 656,\n\t\t   752, 800, 0, 480, 490, 492, 525, 0,\n\t\t   DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_NVSYNC) },\n\t \n\t{ DRM_MODE(\"640x480\", DRM_MODE_TYPE_DRIVER, 31500, 640, 664,\n\t\t   704, 832, 0, 480, 489, 492, 520, 0,\n\t\t   DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_NVSYNC) },\n\t \n\t{ DRM_MODE(\"640x480\", DRM_MODE_TYPE_DRIVER, 31500, 640, 656,\n\t\t   720, 840, 0, 480, 481, 484, 500, 0,\n\t\t   DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_NVSYNC) },\n\t \n\t{ DRM_MODE(\"640x480\", DRM_MODE_TYPE_DRIVER, 36000, 640, 696,\n\t\t   752, 832, 0, 480, 481, 484, 509, 0,\n\t\t   DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_NVSYNC) },\n\t \n\t{ DRM_MODE(\"800x600\", DRM_MODE_TYPE_DRIVER, 36000, 800, 824,\n\t\t   896, 1024, 0, 600, 601, 603, 625, 0,\n\t\t   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC) },\n\t \n\t{ DRM_MODE(\"800x600\", DRM_MODE_TYPE_DRIVER, 40000, 800, 840,\n\t\t   968, 1056, 0, 600, 601, 605, 628, 0,\n\t\t   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC) },\n\t \n\t{ DRM_MODE(\"800x600\", DRM_MODE_TYPE_DRIVER, 50000, 800, 856,\n\t\t   976, 1040, 0, 600, 637, 643, 666, 0,\n\t\t   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC) },\n\t \n\t{ DRM_MODE(\"800x600\", DRM_MODE_TYPE_DRIVER, 49500, 800, 816,\n\t\t   896, 1056, 0, 600, 601, 604, 625, 0,\n\t\t   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC) },\n\t \n\t{ DRM_MODE(\"800x600\", DRM_MODE_TYPE_DRIVER, 56250, 800, 832,\n\t\t   896, 1048, 0, 600, 601, 604, 631, 0,\n\t\t   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC) },\n\t \n\t{ DRM_MODE(\"800x600\", DRM_MODE_TYPE_DRIVER, 73250, 800, 848,\n\t\t   880, 960, 0, 600, 603, 607, 636, 0,\n\t\t   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_NVSYNC) },\n\t \n\t{ DRM_MODE(\"848x480\", DRM_MODE_TYPE_DRIVER, 33750, 848, 864,\n\t\t   976, 1088, 0, 480, 486, 494, 517, 0,\n\t\t   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC) },\n\t \n\t{ DRM_MODE(\"1024x768i\", DRM_MODE_TYPE_DRIVER, 44900, 1024, 1032,\n\t\t   1208, 1264, 0, 768, 768, 776, 817, 0,\n\t\t   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC |\n\t\t   DRM_MODE_FLAG_INTERLACE) },\n\t \n\t{ DRM_MODE(\"1024x768\", DRM_MODE_TYPE_DRIVER, 65000, 1024, 1048,\n\t\t   1184, 1344, 0, 768, 771, 777, 806, 0,\n\t\t   DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_NVSYNC) },\n\t \n\t{ DRM_MODE(\"1024x768\", DRM_MODE_TYPE_DRIVER, 75000, 1024, 1048,\n\t\t   1184, 1328, 0, 768, 771, 777, 806, 0,\n\t\t   DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_NVSYNC) },\n\t \n\t{ DRM_MODE(\"1024x768\", DRM_MODE_TYPE_DRIVER, 78750, 1024, 1040,\n\t\t   1136, 1312, 0, 768, 769, 772, 800, 0,\n\t\t   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC) },\n\t \n\t{ DRM_MODE(\"1024x768\", DRM_MODE_TYPE_DRIVER, 94500, 1024, 1072,\n\t\t   1168, 1376, 0, 768, 769, 772, 808, 0,\n\t\t   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC) },\n\t \n\t{ DRM_MODE(\"1024x768\", DRM_MODE_TYPE_DRIVER, 115500, 1024, 1072,\n\t\t   1104, 1184, 0, 768, 771, 775, 813, 0,\n\t\t   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_NVSYNC) },\n\t \n\t{ DRM_MODE(\"1152x864\", DRM_MODE_TYPE_DRIVER, 108000, 1152, 1216,\n\t\t   1344, 1600, 0, 864, 865, 868, 900, 0,\n\t\t   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC) },\n\t \n\t{ DRM_MODE(\"1280x720\", DRM_MODE_TYPE_DRIVER, 74250, 1280, 1390,\n\t\t   1430, 1650, 0, 720, 725, 730, 750, 0,\n\t\t   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC) },\n\t \n\t{ DRM_MODE(\"1280x768\", DRM_MODE_TYPE_DRIVER, 68250, 1280, 1328,\n\t\t   1360, 1440, 0, 768, 771, 778, 790, 0,\n\t\t   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_NVSYNC) },\n\t \n\t{ DRM_MODE(\"1280x768\", DRM_MODE_TYPE_DRIVER, 79500, 1280, 1344,\n\t\t   1472, 1664, 0, 768, 771, 778, 798, 0,\n\t\t   DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_PVSYNC) },\n\t \n\t{ DRM_MODE(\"1280x768\", DRM_MODE_TYPE_DRIVER, 102250, 1280, 1360,\n\t\t   1488, 1696, 0, 768, 771, 778, 805, 0,\n\t\t   DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_PVSYNC) },\n\t \n\t{ DRM_MODE(\"1280x768\", DRM_MODE_TYPE_DRIVER, 117500, 1280, 1360,\n\t\t   1496, 1712, 0, 768, 771, 778, 809, 0,\n\t\t   DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_PVSYNC) },\n\t \n\t{ DRM_MODE(\"1280x768\", DRM_MODE_TYPE_DRIVER, 140250, 1280, 1328,\n\t\t   1360, 1440, 0, 768, 771, 778, 813, 0,\n\t\t   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_NVSYNC) },\n\t \n\t{ DRM_MODE(\"1280x800\", DRM_MODE_TYPE_DRIVER, 71000, 1280, 1328,\n\t\t   1360, 1440, 0, 800, 803, 809, 823, 0,\n\t\t   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_NVSYNC) },\n\t \n\t{ DRM_MODE(\"1280x800\", DRM_MODE_TYPE_DRIVER, 83500, 1280, 1352,\n\t\t   1480, 1680, 0, 800, 803, 809, 831, 0,\n\t\t   DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_PVSYNC) },\n\t \n\t{ DRM_MODE(\"1280x800\", DRM_MODE_TYPE_DRIVER, 106500, 1280, 1360,\n\t\t   1488, 1696, 0, 800, 803, 809, 838, 0,\n\t\t   DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_PVSYNC) },\n\t \n\t{ DRM_MODE(\"1280x800\", DRM_MODE_TYPE_DRIVER, 122500, 1280, 1360,\n\t\t   1496, 1712, 0, 800, 803, 809, 843, 0,\n\t\t   DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_PVSYNC) },\n\t \n\t{ DRM_MODE(\"1280x800\", DRM_MODE_TYPE_DRIVER, 146250, 1280, 1328,\n\t\t   1360, 1440, 0, 800, 803, 809, 847, 0,\n\t\t   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_NVSYNC) },\n\t \n\t{ DRM_MODE(\"1280x960\", DRM_MODE_TYPE_DRIVER, 108000, 1280, 1376,\n\t\t   1488, 1800, 0, 960, 961, 964, 1000, 0,\n\t\t   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC) },\n\t \n\t{ DRM_MODE(\"1280x960\", DRM_MODE_TYPE_DRIVER, 148500, 1280, 1344,\n\t\t   1504, 1728, 0, 960, 961, 964, 1011, 0,\n\t\t   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC) },\n\t \n\t{ DRM_MODE(\"1280x960\", DRM_MODE_TYPE_DRIVER, 175500, 1280, 1328,\n\t\t   1360, 1440, 0, 960, 963, 967, 1017, 0,\n\t\t   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_NVSYNC) },\n\t \n\t{ DRM_MODE(\"1280x1024\", DRM_MODE_TYPE_DRIVER, 108000, 1280, 1328,\n\t\t   1440, 1688, 0, 1024, 1025, 1028, 1066, 0,\n\t\t   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC) },\n\t \n\t{ DRM_MODE(\"1280x1024\", DRM_MODE_TYPE_DRIVER, 135000, 1280, 1296,\n\t\t   1440, 1688, 0, 1024, 1025, 1028, 1066, 0,\n\t\t   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC) },\n\t \n\t{ DRM_MODE(\"1280x1024\", DRM_MODE_TYPE_DRIVER, 157500, 1280, 1344,\n\t\t   1504, 1728, 0, 1024, 1025, 1028, 1072, 0,\n\t\t   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC) },\n\t \n\t{ DRM_MODE(\"1280x1024\", DRM_MODE_TYPE_DRIVER, 187250, 1280, 1328,\n\t\t   1360, 1440, 0, 1024, 1027, 1034, 1084, 0,\n\t\t   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_NVSYNC) },\n\t \n\t{ DRM_MODE(\"1360x768\", DRM_MODE_TYPE_DRIVER, 85500, 1360, 1424,\n\t\t   1536, 1792, 0, 768, 771, 777, 795, 0,\n\t\t   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC) },\n\t \n\t{ DRM_MODE(\"1360x768\", DRM_MODE_TYPE_DRIVER, 148250, 1360, 1408,\n\t\t   1440, 1520, 0, 768, 771, 776, 813, 0,\n\t\t   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_NVSYNC) },\n\t \n\t{ DRM_MODE(\"1366x768\", DRM_MODE_TYPE_DRIVER, 85500, 1366, 1436,\n\t\t   1579, 1792, 0, 768, 771, 774, 798, 0,\n\t\t   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC) },\n\t \n\t{ DRM_MODE(\"1366x768\", DRM_MODE_TYPE_DRIVER, 72000, 1366, 1380,\n\t\t   1436, 1500, 0, 768, 769, 772, 800, 0,\n\t\t   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC) },\n\t \n\t{ DRM_MODE(\"1400x1050\", DRM_MODE_TYPE_DRIVER, 101000, 1400, 1448,\n\t\t   1480, 1560, 0, 1050, 1053, 1057, 1080, 0,\n\t\t   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_NVSYNC) },\n\t \n\t{ DRM_MODE(\"1400x1050\", DRM_MODE_TYPE_DRIVER, 121750, 1400, 1488,\n\t\t   1632, 1864, 0, 1050, 1053, 1057, 1089, 0,\n\t\t   DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_PVSYNC) },\n\t \n\t{ DRM_MODE(\"1400x1050\", DRM_MODE_TYPE_DRIVER, 156000, 1400, 1504,\n\t\t   1648, 1896, 0, 1050, 1053, 1057, 1099, 0,\n\t\t   DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_PVSYNC) },\n\t \n\t{ DRM_MODE(\"1400x1050\", DRM_MODE_TYPE_DRIVER, 179500, 1400, 1504,\n\t\t   1656, 1912, 0, 1050, 1053, 1057, 1105, 0,\n\t\t   DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_PVSYNC) },\n\t \n\t{ DRM_MODE(\"1400x1050\", DRM_MODE_TYPE_DRIVER, 208000, 1400, 1448,\n\t\t   1480, 1560, 0, 1050, 1053, 1057, 1112, 0,\n\t\t   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_NVSYNC) },\n\t \n\t{ DRM_MODE(\"1440x900\", DRM_MODE_TYPE_DRIVER, 88750, 1440, 1488,\n\t\t   1520, 1600, 0, 900, 903, 909, 926, 0,\n\t\t   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_NVSYNC) },\n\t \n\t{ DRM_MODE(\"1440x900\", DRM_MODE_TYPE_DRIVER, 106500, 1440, 1520,\n\t\t   1672, 1904, 0, 900, 903, 909, 934, 0,\n\t\t   DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_PVSYNC) },\n\t \n\t{ DRM_MODE(\"1440x900\", DRM_MODE_TYPE_DRIVER, 136750, 1440, 1536,\n\t\t   1688, 1936, 0, 900, 903, 909, 942, 0,\n\t\t   DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_PVSYNC) },\n\t \n\t{ DRM_MODE(\"1440x900\", DRM_MODE_TYPE_DRIVER, 157000, 1440, 1544,\n\t\t   1696, 1952, 0, 900, 903, 909, 948, 0,\n\t\t   DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_PVSYNC) },\n\t \n\t{ DRM_MODE(\"1440x900\", DRM_MODE_TYPE_DRIVER, 182750, 1440, 1488,\n\t\t   1520, 1600, 0, 900, 903, 909, 953, 0,\n\t\t   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_NVSYNC) },\n\t \n\t{ DRM_MODE(\"1600x900\", DRM_MODE_TYPE_DRIVER, 108000, 1600, 1624,\n\t\t   1704, 1800, 0, 900, 901, 904, 1000, 0,\n\t\t   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC) },\n\t \n\t{ DRM_MODE(\"1600x1200\", DRM_MODE_TYPE_DRIVER, 162000, 1600, 1664,\n\t\t   1856, 2160, 0, 1200, 1201, 1204, 1250, 0,\n\t\t   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC) },\n\t \n\t{ DRM_MODE(\"1600x1200\", DRM_MODE_TYPE_DRIVER, 175500, 1600, 1664,\n\t\t   1856, 2160, 0, 1200, 1201, 1204, 1250, 0,\n\t\t   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC) },\n\t \n\t{ DRM_MODE(\"1600x1200\", DRM_MODE_TYPE_DRIVER, 189000, 1600, 1664,\n\t\t   1856, 2160, 0, 1200, 1201, 1204, 1250, 0,\n\t\t   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC) },\n\t \n\t{ DRM_MODE(\"1600x1200\", DRM_MODE_TYPE_DRIVER, 202500, 1600, 1664,\n\t\t   1856, 2160, 0, 1200, 1201, 1204, 1250, 0,\n\t\t   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC) },\n\t \n\t{ DRM_MODE(\"1600x1200\", DRM_MODE_TYPE_DRIVER, 229500, 1600, 1664,\n\t\t   1856, 2160, 0, 1200, 1201, 1204, 1250, 0,\n\t\t   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC) },\n\t \n\t{ DRM_MODE(\"1600x1200\", DRM_MODE_TYPE_DRIVER, 268250, 1600, 1648,\n\t\t   1680, 1760, 0, 1200, 1203, 1207, 1271, 0,\n\t\t   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_NVSYNC) },\n\t \n\t{ DRM_MODE(\"1680x1050\", DRM_MODE_TYPE_DRIVER, 119000, 1680, 1728,\n\t\t   1760, 1840, 0, 1050, 1053, 1059, 1080, 0,\n\t\t   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_NVSYNC) },\n\t \n\t{ DRM_MODE(\"1680x1050\", DRM_MODE_TYPE_DRIVER, 146250, 1680, 1784,\n\t\t   1960, 2240, 0, 1050, 1053, 1059, 1089, 0,\n\t\t   DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_PVSYNC) },\n\t \n\t{ DRM_MODE(\"1680x1050\", DRM_MODE_TYPE_DRIVER, 187000, 1680, 1800,\n\t\t   1976, 2272, 0, 1050, 1053, 1059, 1099, 0,\n\t\t   DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_PVSYNC) },\n\t \n\t{ DRM_MODE(\"1680x1050\", DRM_MODE_TYPE_DRIVER, 214750, 1680, 1808,\n\t\t   1984, 2288, 0, 1050, 1053, 1059, 1105, 0,\n\t\t   DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_PVSYNC) },\n\t \n\t{ DRM_MODE(\"1680x1050\", DRM_MODE_TYPE_DRIVER, 245500, 1680, 1728,\n\t\t   1760, 1840, 0, 1050, 1053, 1059, 1112, 0,\n\t\t   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_NVSYNC) },\n\t \n\t{ DRM_MODE(\"1792x1344\", DRM_MODE_TYPE_DRIVER, 204750, 1792, 1920,\n\t\t   2120, 2448, 0, 1344, 1345, 1348, 1394, 0,\n\t\t   DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_PVSYNC) },\n\t \n\t{ DRM_MODE(\"1792x1344\", DRM_MODE_TYPE_DRIVER, 261000, 1792, 1888,\n\t\t   2104, 2456, 0, 1344, 1345, 1348, 1417, 0,\n\t\t   DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_PVSYNC) },\n\t \n\t{ DRM_MODE(\"1792x1344\", DRM_MODE_TYPE_DRIVER, 333250, 1792, 1840,\n\t\t   1872, 1952, 0, 1344, 1347, 1351, 1423, 0,\n\t\t   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_NVSYNC) },\n\t \n\t{ DRM_MODE(\"1856x1392\", DRM_MODE_TYPE_DRIVER, 218250, 1856, 1952,\n\t\t   2176, 2528, 0, 1392, 1393, 1396, 1439, 0,\n\t\t   DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_PVSYNC) },\n\t \n\t{ DRM_MODE(\"1856x1392\", DRM_MODE_TYPE_DRIVER, 288000, 1856, 1984,\n\t\t   2208, 2560, 0, 1392, 1393, 1396, 1500, 0,\n\t\t   DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_PVSYNC) },\n\t \n\t{ DRM_MODE(\"1856x1392\", DRM_MODE_TYPE_DRIVER, 356500, 1856, 1904,\n\t\t   1936, 2016, 0, 1392, 1395, 1399, 1474, 0,\n\t\t   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_NVSYNC) },\n\t \n\t{ DRM_MODE(\"1920x1080\", DRM_MODE_TYPE_DRIVER, 148500, 1920, 2008,\n\t\t   2052, 2200, 0, 1080, 1084, 1089, 1125, 0,\n\t\t   DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_NVSYNC) },\n\t \n\t{ DRM_MODE(\"1920x1200\", DRM_MODE_TYPE_DRIVER, 154000, 1920, 1968,\n\t\t   2000, 2080, 0, 1200, 1203, 1209, 1235, 0,\n\t\t   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_NVSYNC) },\n\t \n\t{ DRM_MODE(\"1920x1200\", DRM_MODE_TYPE_DRIVER, 193250, 1920, 2056,\n\t\t   2256, 2592, 0, 1200, 1203, 1209, 1245, 0,\n\t\t   DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_PVSYNC) },\n\t \n\t{ DRM_MODE(\"1920x1200\", DRM_MODE_TYPE_DRIVER, 245250, 1920, 2056,\n\t\t   2264, 2608, 0, 1200, 1203, 1209, 1255, 0,\n\t\t   DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_PVSYNC) },\n\t \n\t{ DRM_MODE(\"1920x1200\", DRM_MODE_TYPE_DRIVER, 281250, 1920, 2064,\n\t\t   2272, 2624, 0, 1200, 1203, 1209, 1262, 0,\n\t\t   DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_PVSYNC) },\n\t \n\t{ DRM_MODE(\"1920x1200\", DRM_MODE_TYPE_DRIVER, 317000, 1920, 1968,\n\t\t   2000, 2080, 0, 1200, 1203, 1209, 1271, 0,\n\t\t   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_NVSYNC) },\n\t \n\t{ DRM_MODE(\"1920x1440\", DRM_MODE_TYPE_DRIVER, 234000, 1920, 2048,\n\t\t   2256, 2600, 0, 1440, 1441, 1444, 1500, 0,\n\t\t   DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_PVSYNC) },\n\t \n\t{ DRM_MODE(\"1920x1440\", DRM_MODE_TYPE_DRIVER, 297000, 1920, 2064,\n\t\t   2288, 2640, 0, 1440, 1441, 1444, 1500, 0,\n\t\t   DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_PVSYNC) },\n\t \n\t{ DRM_MODE(\"1920x1440\", DRM_MODE_TYPE_DRIVER, 380500, 1920, 1968,\n\t\t   2000, 2080, 0, 1440, 1443, 1447, 1525, 0,\n\t\t   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_NVSYNC) },\n\t \n\t{ DRM_MODE(\"2048x1152\", DRM_MODE_TYPE_DRIVER, 162000, 2048, 2074,\n\t\t   2154, 2250, 0, 1152, 1153, 1156, 1200, 0,\n\t\t   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC) },\n\t \n\t{ DRM_MODE(\"2560x1600\", DRM_MODE_TYPE_DRIVER, 268500, 2560, 2608,\n\t\t   2640, 2720, 0, 1600, 1603, 1609, 1646, 0,\n\t\t   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_NVSYNC) },\n\t \n\t{ DRM_MODE(\"2560x1600\", DRM_MODE_TYPE_DRIVER, 348500, 2560, 2752,\n\t\t   3032, 3504, 0, 1600, 1603, 1609, 1658, 0,\n\t\t   DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_PVSYNC) },\n\t \n\t{ DRM_MODE(\"2560x1600\", DRM_MODE_TYPE_DRIVER, 443250, 2560, 2768,\n\t\t   3048, 3536, 0, 1600, 1603, 1609, 1672, 0,\n\t\t   DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_PVSYNC) },\n\t \n\t{ DRM_MODE(\"2560x1600\", DRM_MODE_TYPE_DRIVER, 505250, 2560, 2768,\n\t\t   3048, 3536, 0, 1600, 1603, 1609, 1682, 0,\n\t\t   DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_PVSYNC) },\n\t \n\t{ DRM_MODE(\"2560x1600\", DRM_MODE_TYPE_DRIVER, 552750, 2560, 2608,\n\t\t   2640, 2720, 0, 1600, 1603, 1609, 1694, 0,\n\t\t   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_NVSYNC) },\n\t \n\t{ DRM_MODE(\"4096x2160\", DRM_MODE_TYPE_DRIVER, 556744, 4096, 4104,\n\t\t   4136, 4176, 0, 2160, 2208, 2216, 2222, 0,\n\t\t   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_NVSYNC) },\n\t \n\t{ DRM_MODE(\"4096x2160\", DRM_MODE_TYPE_DRIVER, 556188, 4096, 4104,\n\t\t   4136, 4176, 0, 2160, 2208, 2216, 2222, 0,\n\t\t   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_NVSYNC) },\n};\n\n \nstatic const struct drm_display_mode edid_est_modes[] = {\n\t{ DRM_MODE(\"800x600\", DRM_MODE_TYPE_DRIVER, 40000, 800, 840,\n\t\t   968, 1056, 0, 600, 601, 605, 628, 0,\n\t\t   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC) },  \n\t{ DRM_MODE(\"800x600\", DRM_MODE_TYPE_DRIVER, 36000, 800, 824,\n\t\t   896, 1024, 0, 600, 601, 603,  625, 0,\n\t\t   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC) },  \n\t{ DRM_MODE(\"640x480\", DRM_MODE_TYPE_DRIVER, 31500, 640, 656,\n\t\t   720, 840, 0, 480, 481, 484, 500, 0,\n\t\t   DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_NVSYNC) },  \n\t{ DRM_MODE(\"640x480\", DRM_MODE_TYPE_DRIVER, 31500, 640, 664,\n\t\t   704,  832, 0, 480, 489, 492, 520, 0,\n\t\t   DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_NVSYNC) },  \n\t{ DRM_MODE(\"640x480\", DRM_MODE_TYPE_DRIVER, 30240, 640, 704,\n\t\t   768,  864, 0, 480, 483, 486, 525, 0,\n\t\t   DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_NVSYNC) },  \n\t{ DRM_MODE(\"640x480\", DRM_MODE_TYPE_DRIVER, 25175, 640, 656,\n\t\t   752, 800, 0, 480, 490, 492, 525, 0,\n\t\t   DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_NVSYNC) },  \n\t{ DRM_MODE(\"720x400\", DRM_MODE_TYPE_DRIVER, 35500, 720, 738,\n\t\t   846, 900, 0, 400, 421, 423,  449, 0,\n\t\t   DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_NVSYNC) },  \n\t{ DRM_MODE(\"720x400\", DRM_MODE_TYPE_DRIVER, 28320, 720, 738,\n\t\t   846,  900, 0, 400, 412, 414, 449, 0,\n\t\t   DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_PVSYNC) },  \n\t{ DRM_MODE(\"1280x1024\", DRM_MODE_TYPE_DRIVER, 135000, 1280, 1296,\n\t\t   1440, 1688, 0, 1024, 1025, 1028, 1066, 0,\n\t\t   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC) },  \n\t{ DRM_MODE(\"1024x768\", DRM_MODE_TYPE_DRIVER, 78750, 1024, 1040,\n\t\t   1136, 1312, 0,  768, 769, 772, 800, 0,\n\t\t   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC) },  \n\t{ DRM_MODE(\"1024x768\", DRM_MODE_TYPE_DRIVER, 75000, 1024, 1048,\n\t\t   1184, 1328, 0,  768, 771, 777, 806, 0,\n\t\t   DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_NVSYNC) },  \n\t{ DRM_MODE(\"1024x768\", DRM_MODE_TYPE_DRIVER, 65000, 1024, 1048,\n\t\t   1184, 1344, 0,  768, 771, 777, 806, 0,\n\t\t   DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_NVSYNC) },  \n\t{ DRM_MODE(\"1024x768i\", DRM_MODE_TYPE_DRIVER,44900, 1024, 1032,\n\t\t   1208, 1264, 0, 768, 768, 776, 817, 0,\n\t\t   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC | DRM_MODE_FLAG_INTERLACE) },  \n\t{ DRM_MODE(\"832x624\", DRM_MODE_TYPE_DRIVER, 57284, 832, 864,\n\t\t   928, 1152, 0, 624, 625, 628, 667, 0,\n\t\t   DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_NVSYNC) },  \n\t{ DRM_MODE(\"800x600\", DRM_MODE_TYPE_DRIVER, 49500, 800, 816,\n\t\t   896, 1056, 0, 600, 601, 604,  625, 0,\n\t\t   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC) },  \n\t{ DRM_MODE(\"800x600\", DRM_MODE_TYPE_DRIVER, 50000, 800, 856,\n\t\t   976, 1040, 0, 600, 637, 643, 666, 0,\n\t\t   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC) },  \n\t{ DRM_MODE(\"1152x864\", DRM_MODE_TYPE_DRIVER, 108000, 1152, 1216,\n\t\t   1344, 1600, 0,  864, 865, 868, 900, 0,\n\t\t   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC) },  \n};\n\nstruct minimode {\n\tshort w;\n\tshort h;\n\tshort r;\n\tshort rb;\n};\n\nstatic const struct minimode est3_modes[] = {\n\t \n\t{ 640, 350, 85, 0 },\n\t{ 640, 400, 85, 0 },\n\t{ 720, 400, 85, 0 },\n\t{ 640, 480, 85, 0 },\n\t{ 848, 480, 60, 0 },\n\t{ 800, 600, 85, 0 },\n\t{ 1024, 768, 85, 0 },\n\t{ 1152, 864, 75, 0 },\n\t \n\t{ 1280, 768, 60, 1 },\n\t{ 1280, 768, 60, 0 },\n\t{ 1280, 768, 75, 0 },\n\t{ 1280, 768, 85, 0 },\n\t{ 1280, 960, 60, 0 },\n\t{ 1280, 960, 85, 0 },\n\t{ 1280, 1024, 60, 0 },\n\t{ 1280, 1024, 85, 0 },\n\t \n\t{ 1360, 768, 60, 0 },\n\t{ 1440, 900, 60, 1 },\n\t{ 1440, 900, 60, 0 },\n\t{ 1440, 900, 75, 0 },\n\t{ 1440, 900, 85, 0 },\n\t{ 1400, 1050, 60, 1 },\n\t{ 1400, 1050, 60, 0 },\n\t{ 1400, 1050, 75, 0 },\n\t \n\t{ 1400, 1050, 85, 0 },\n\t{ 1680, 1050, 60, 1 },\n\t{ 1680, 1050, 60, 0 },\n\t{ 1680, 1050, 75, 0 },\n\t{ 1680, 1050, 85, 0 },\n\t{ 1600, 1200, 60, 0 },\n\t{ 1600, 1200, 65, 0 },\n\t{ 1600, 1200, 70, 0 },\n\t \n\t{ 1600, 1200, 75, 0 },\n\t{ 1600, 1200, 85, 0 },\n\t{ 1792, 1344, 60, 0 },\n\t{ 1792, 1344, 75, 0 },\n\t{ 1856, 1392, 60, 0 },\n\t{ 1856, 1392, 75, 0 },\n\t{ 1920, 1200, 60, 1 },\n\t{ 1920, 1200, 60, 0 },\n\t \n\t{ 1920, 1200, 75, 0 },\n\t{ 1920, 1200, 85, 0 },\n\t{ 1920, 1440, 60, 0 },\n\t{ 1920, 1440, 75, 0 },\n};\n\nstatic const struct minimode extra_modes[] = {\n\t{ 1024, 576,  60, 0 },\n\t{ 1366, 768,  60, 0 },\n\t{ 1600, 900,  60, 0 },\n\t{ 1680, 945,  60, 0 },\n\t{ 1920, 1080, 60, 0 },\n\t{ 2048, 1152, 60, 0 },\n\t{ 2048, 1536, 60, 0 },\n};\n\n \nstatic const struct drm_display_mode edid_cea_modes_1[] = {\n\t \n\t{ DRM_MODE(\"640x480\", DRM_MODE_TYPE_DRIVER, 25175, 640, 656,\n\t\t   752, 800, 0, 480, 490, 492, 525, 0,\n\t\t   DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_NVSYNC),\n\t  .picture_aspect_ratio = HDMI_PICTURE_ASPECT_4_3, },\n\t \n\t{ DRM_MODE(\"720x480\", DRM_MODE_TYPE_DRIVER, 27000, 720, 736,\n\t\t   798, 858, 0, 480, 489, 495, 525, 0,\n\t\t   DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_NVSYNC),\n\t  .picture_aspect_ratio = HDMI_PICTURE_ASPECT_4_3, },\n\t \n\t{ DRM_MODE(\"720x480\", DRM_MODE_TYPE_DRIVER, 27000, 720, 736,\n\t\t   798, 858, 0, 480, 489, 495, 525, 0,\n\t\t   DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_NVSYNC),\n\t  .picture_aspect_ratio = HDMI_PICTURE_ASPECT_16_9, },\n\t \n\t{ DRM_MODE(\"1280x720\", DRM_MODE_TYPE_DRIVER, 74250, 1280, 1390,\n\t\t   1430, 1650, 0, 720, 725, 730, 750, 0,\n\t\t   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC),\n\t  .picture_aspect_ratio = HDMI_PICTURE_ASPECT_16_9, },\n\t \n\t{ DRM_MODE(\"1920x1080i\", DRM_MODE_TYPE_DRIVER, 74250, 1920, 2008,\n\t\t   2052, 2200, 0, 1080, 1084, 1094, 1125, 0,\n\t\t   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC |\n\t\t   DRM_MODE_FLAG_INTERLACE),\n\t  .picture_aspect_ratio = HDMI_PICTURE_ASPECT_16_9, },\n\t \n\t{ DRM_MODE(\"720x480i\", DRM_MODE_TYPE_DRIVER, 13500, 720, 739,\n\t\t   801, 858, 0, 480, 488, 494, 525, 0,\n\t\t   DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_NVSYNC |\n\t\t   DRM_MODE_FLAG_INTERLACE | DRM_MODE_FLAG_DBLCLK),\n\t  .picture_aspect_ratio = HDMI_PICTURE_ASPECT_4_3, },\n\t \n\t{ DRM_MODE(\"720x480i\", DRM_MODE_TYPE_DRIVER, 13500, 720, 739,\n\t\t   801, 858, 0, 480, 488, 494, 525, 0,\n\t\t   DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_NVSYNC |\n\t\t   DRM_MODE_FLAG_INTERLACE | DRM_MODE_FLAG_DBLCLK),\n\t  .picture_aspect_ratio = HDMI_PICTURE_ASPECT_16_9, },\n\t \n\t{ DRM_MODE(\"720x240\", DRM_MODE_TYPE_DRIVER, 13500, 720, 739,\n\t\t   801, 858, 0, 240, 244, 247, 262, 0,\n\t\t   DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_NVSYNC |\n\t\t   DRM_MODE_FLAG_DBLCLK),\n\t  .picture_aspect_ratio = HDMI_PICTURE_ASPECT_4_3, },\n\t \n\t{ DRM_MODE(\"720x240\", DRM_MODE_TYPE_DRIVER, 13500, 720, 739,\n\t\t   801, 858, 0, 240, 244, 247, 262, 0,\n\t\t   DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_NVSYNC |\n\t\t   DRM_MODE_FLAG_DBLCLK),\n\t  .picture_aspect_ratio = HDMI_PICTURE_ASPECT_16_9, },\n\t \n\t{ DRM_MODE(\"2880x480i\", DRM_MODE_TYPE_DRIVER, 54000, 2880, 2956,\n\t\t   3204, 3432, 0, 480, 488, 494, 525, 0,\n\t\t   DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_NVSYNC |\n\t\t   DRM_MODE_FLAG_INTERLACE),\n\t  .picture_aspect_ratio = HDMI_PICTURE_ASPECT_4_3, },\n\t \n\t{ DRM_MODE(\"2880x480i\", DRM_MODE_TYPE_DRIVER, 54000, 2880, 2956,\n\t\t   3204, 3432, 0, 480, 488, 494, 525, 0,\n\t\t   DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_NVSYNC |\n\t\t   DRM_MODE_FLAG_INTERLACE),\n\t  .picture_aspect_ratio = HDMI_PICTURE_ASPECT_16_9, },\n\t \n\t{ DRM_MODE(\"2880x240\", DRM_MODE_TYPE_DRIVER, 54000, 2880, 2956,\n\t\t   3204, 3432, 0, 240, 244, 247, 262, 0,\n\t\t   DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_NVSYNC),\n\t  .picture_aspect_ratio = HDMI_PICTURE_ASPECT_4_3, },\n\t \n\t{ DRM_MODE(\"2880x240\", DRM_MODE_TYPE_DRIVER, 54000, 2880, 2956,\n\t\t   3204, 3432, 0, 240, 244, 247, 262, 0,\n\t\t   DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_NVSYNC),\n\t  .picture_aspect_ratio = HDMI_PICTURE_ASPECT_16_9, },\n\t \n\t{ DRM_MODE(\"1440x480\", DRM_MODE_TYPE_DRIVER, 54000, 1440, 1472,\n\t\t   1596, 1716, 0, 480, 489, 495, 525, 0,\n\t\t   DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_NVSYNC),\n\t  .picture_aspect_ratio = HDMI_PICTURE_ASPECT_4_3, },\n\t \n\t{ DRM_MODE(\"1440x480\", DRM_MODE_TYPE_DRIVER, 54000, 1440, 1472,\n\t\t   1596, 1716, 0, 480, 489, 495, 525, 0,\n\t\t   DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_NVSYNC),\n\t  .picture_aspect_ratio = HDMI_PICTURE_ASPECT_16_9, },\n\t \n\t{ DRM_MODE(\"1920x1080\", DRM_MODE_TYPE_DRIVER, 148500, 1920, 2008,\n\t\t   2052, 2200, 0, 1080, 1084, 1089, 1125, 0,\n\t\t   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC),\n\t  .picture_aspect_ratio = HDMI_PICTURE_ASPECT_16_9, },\n\t \n\t{ DRM_MODE(\"720x576\", DRM_MODE_TYPE_DRIVER, 27000, 720, 732,\n\t\t   796, 864, 0, 576, 581, 586, 625, 0,\n\t\t   DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_NVSYNC),\n\t  .picture_aspect_ratio = HDMI_PICTURE_ASPECT_4_3, },\n\t \n\t{ DRM_MODE(\"720x576\", DRM_MODE_TYPE_DRIVER, 27000, 720, 732,\n\t\t   796, 864, 0, 576, 581, 586, 625, 0,\n\t\t   DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_NVSYNC),\n\t  .picture_aspect_ratio = HDMI_PICTURE_ASPECT_16_9, },\n\t \n\t{ DRM_MODE(\"1280x720\", DRM_MODE_TYPE_DRIVER, 74250, 1280, 1720,\n\t\t   1760, 1980, 0, 720, 725, 730, 750, 0,\n\t\t   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC),\n\t  .picture_aspect_ratio = HDMI_PICTURE_ASPECT_16_9, },\n\t \n\t{ DRM_MODE(\"1920x1080i\", DRM_MODE_TYPE_DRIVER, 74250, 1920, 2448,\n\t\t   2492, 2640, 0, 1080, 1084, 1094, 1125, 0,\n\t\t   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC |\n\t\t   DRM_MODE_FLAG_INTERLACE),\n\t  .picture_aspect_ratio = HDMI_PICTURE_ASPECT_16_9, },\n\t \n\t{ DRM_MODE(\"720x576i\", DRM_MODE_TYPE_DRIVER, 13500, 720, 732,\n\t\t   795, 864, 0, 576, 580, 586, 625, 0,\n\t\t   DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_NVSYNC |\n\t\t   DRM_MODE_FLAG_INTERLACE | DRM_MODE_FLAG_DBLCLK),\n\t  .picture_aspect_ratio = HDMI_PICTURE_ASPECT_4_3, },\n\t \n\t{ DRM_MODE(\"720x576i\", DRM_MODE_TYPE_DRIVER, 13500, 720, 732,\n\t\t   795, 864, 0, 576, 580, 586, 625, 0,\n\t\t   DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_NVSYNC |\n\t\t   DRM_MODE_FLAG_INTERLACE | DRM_MODE_FLAG_DBLCLK),\n\t  .picture_aspect_ratio = HDMI_PICTURE_ASPECT_16_9, },\n\t \n\t{ DRM_MODE(\"720x288\", DRM_MODE_TYPE_DRIVER, 13500, 720, 732,\n\t\t   795, 864, 0, 288, 290, 293, 312, 0,\n\t\t   DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_NVSYNC |\n\t\t   DRM_MODE_FLAG_DBLCLK),\n\t  .picture_aspect_ratio = HDMI_PICTURE_ASPECT_4_3, },\n\t \n\t{ DRM_MODE(\"720x288\", DRM_MODE_TYPE_DRIVER, 13500, 720, 732,\n\t\t   795, 864, 0, 288, 290, 293, 312, 0,\n\t\t   DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_NVSYNC |\n\t\t   DRM_MODE_FLAG_DBLCLK),\n\t  .picture_aspect_ratio = HDMI_PICTURE_ASPECT_16_9, },\n\t \n\t{ DRM_MODE(\"2880x576i\", DRM_MODE_TYPE_DRIVER, 54000, 2880, 2928,\n\t\t   3180, 3456, 0, 576, 580, 586, 625, 0,\n\t\t   DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_NVSYNC |\n\t\t   DRM_MODE_FLAG_INTERLACE),\n\t  .picture_aspect_ratio = HDMI_PICTURE_ASPECT_4_3, },\n\t \n\t{ DRM_MODE(\"2880x576i\", DRM_MODE_TYPE_DRIVER, 54000, 2880, 2928,\n\t\t   3180, 3456, 0, 576, 580, 586, 625, 0,\n\t\t   DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_NVSYNC |\n\t\t   DRM_MODE_FLAG_INTERLACE),\n\t  .picture_aspect_ratio = HDMI_PICTURE_ASPECT_16_9, },\n\t \n\t{ DRM_MODE(\"2880x288\", DRM_MODE_TYPE_DRIVER, 54000, 2880, 2928,\n\t\t   3180, 3456, 0, 288, 290, 293, 312, 0,\n\t\t   DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_NVSYNC),\n\t  .picture_aspect_ratio = HDMI_PICTURE_ASPECT_4_3, },\n\t \n\t{ DRM_MODE(\"2880x288\", DRM_MODE_TYPE_DRIVER, 54000, 2880, 2928,\n\t\t   3180, 3456, 0, 288, 290, 293, 312, 0,\n\t\t   DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_NVSYNC),\n\t  .picture_aspect_ratio = HDMI_PICTURE_ASPECT_16_9, },\n\t \n\t{ DRM_MODE(\"1440x576\", DRM_MODE_TYPE_DRIVER, 54000, 1440, 1464,\n\t\t   1592, 1728, 0, 576, 581, 586, 625, 0,\n\t\t   DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_NVSYNC),\n\t  .picture_aspect_ratio = HDMI_PICTURE_ASPECT_4_3, },\n\t \n\t{ DRM_MODE(\"1440x576\", DRM_MODE_TYPE_DRIVER, 54000, 1440, 1464,\n\t\t   1592, 1728, 0, 576, 581, 586, 625, 0,\n\t\t   DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_NVSYNC),\n\t  .picture_aspect_ratio = HDMI_PICTURE_ASPECT_16_9, },\n\t \n\t{ DRM_MODE(\"1920x1080\", DRM_MODE_TYPE_DRIVER, 148500, 1920, 2448,\n\t\t   2492, 2640, 0, 1080, 1084, 1089, 1125, 0,\n\t\t   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC),\n\t  .picture_aspect_ratio = HDMI_PICTURE_ASPECT_16_9, },\n\t \n\t{ DRM_MODE(\"1920x1080\", DRM_MODE_TYPE_DRIVER, 74250, 1920, 2558,\n\t\t   2602, 2750, 0, 1080, 1084, 1089, 1125, 0,\n\t\t   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC),\n\t  .picture_aspect_ratio = HDMI_PICTURE_ASPECT_16_9, },\n\t \n\t{ DRM_MODE(\"1920x1080\", DRM_MODE_TYPE_DRIVER, 74250, 1920, 2448,\n\t\t   2492, 2640, 0, 1080, 1084, 1089, 1125, 0,\n\t\t   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC),\n\t  .picture_aspect_ratio = HDMI_PICTURE_ASPECT_16_9, },\n\t \n\t{ DRM_MODE(\"1920x1080\", DRM_MODE_TYPE_DRIVER, 74250, 1920, 2008,\n\t\t   2052, 2200, 0, 1080, 1084, 1089, 1125, 0,\n\t\t   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC),\n\t  .picture_aspect_ratio = HDMI_PICTURE_ASPECT_16_9, },\n\t \n\t{ DRM_MODE(\"2880x480\", DRM_MODE_TYPE_DRIVER, 108000, 2880, 2944,\n\t\t   3192, 3432, 0, 480, 489, 495, 525, 0,\n\t\t   DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_NVSYNC),\n\t  .picture_aspect_ratio = HDMI_PICTURE_ASPECT_4_3, },\n\t \n\t{ DRM_MODE(\"2880x480\", DRM_MODE_TYPE_DRIVER, 108000, 2880, 2944,\n\t\t   3192, 3432, 0, 480, 489, 495, 525, 0,\n\t\t   DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_NVSYNC),\n\t  .picture_aspect_ratio = HDMI_PICTURE_ASPECT_16_9, },\n\t \n\t{ DRM_MODE(\"2880x576\", DRM_MODE_TYPE_DRIVER, 108000, 2880, 2928,\n\t\t   3184, 3456, 0, 576, 581, 586, 625, 0,\n\t\t   DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_NVSYNC),\n\t  .picture_aspect_ratio = HDMI_PICTURE_ASPECT_4_3, },\n\t \n\t{ DRM_MODE(\"2880x576\", DRM_MODE_TYPE_DRIVER, 108000, 2880, 2928,\n\t\t   3184, 3456, 0, 576, 581, 586, 625, 0,\n\t\t   DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_NVSYNC),\n\t  .picture_aspect_ratio = HDMI_PICTURE_ASPECT_16_9, },\n\t \n\t{ DRM_MODE(\"1920x1080i\", DRM_MODE_TYPE_DRIVER, 72000, 1920, 1952,\n\t\t   2120, 2304, 0, 1080, 1126, 1136, 1250, 0,\n\t\t   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_NVSYNC |\n\t\t   DRM_MODE_FLAG_INTERLACE),\n\t  .picture_aspect_ratio = HDMI_PICTURE_ASPECT_16_9, },\n\t \n\t{ DRM_MODE(\"1920x1080i\", DRM_MODE_TYPE_DRIVER, 148500, 1920, 2448,\n\t\t   2492, 2640, 0, 1080, 1084, 1094, 1125, 0,\n\t\t   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC |\n\t\t   DRM_MODE_FLAG_INTERLACE),\n\t  .picture_aspect_ratio = HDMI_PICTURE_ASPECT_16_9, },\n\t \n\t{ DRM_MODE(\"1280x720\", DRM_MODE_TYPE_DRIVER, 148500, 1280, 1720,\n\t\t   1760, 1980, 0, 720, 725, 730, 750, 0,\n\t\t   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC),\n\t  .picture_aspect_ratio = HDMI_PICTURE_ASPECT_16_9, },\n\t \n\t{ DRM_MODE(\"720x576\", DRM_MODE_TYPE_DRIVER, 54000, 720, 732,\n\t\t   796, 864, 0, 576, 581, 586, 625, 0,\n\t\t   DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_NVSYNC),\n\t  .picture_aspect_ratio = HDMI_PICTURE_ASPECT_4_3, },\n\t \n\t{ DRM_MODE(\"720x576\", DRM_MODE_TYPE_DRIVER, 54000, 720, 732,\n\t\t   796, 864, 0, 576, 581, 586, 625, 0,\n\t\t   DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_NVSYNC),\n\t  .picture_aspect_ratio = HDMI_PICTURE_ASPECT_16_9, },\n\t \n\t{ DRM_MODE(\"720x576i\", DRM_MODE_TYPE_DRIVER, 27000, 720, 732,\n\t\t   795, 864, 0, 576, 580, 586, 625, 0,\n\t\t   DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_NVSYNC |\n\t\t   DRM_MODE_FLAG_INTERLACE | DRM_MODE_FLAG_DBLCLK),\n\t  .picture_aspect_ratio = HDMI_PICTURE_ASPECT_4_3, },\n\t \n\t{ DRM_MODE(\"720x576i\", DRM_MODE_TYPE_DRIVER, 27000, 720, 732,\n\t\t   795, 864, 0, 576, 580, 586, 625, 0,\n\t\t   DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_NVSYNC |\n\t\t   DRM_MODE_FLAG_INTERLACE | DRM_MODE_FLAG_DBLCLK),\n\t  .picture_aspect_ratio = HDMI_PICTURE_ASPECT_16_9, },\n\t \n\t{ DRM_MODE(\"1920x1080i\", DRM_MODE_TYPE_DRIVER, 148500, 1920, 2008,\n\t\t   2052, 2200, 0, 1080, 1084, 1094, 1125, 0,\n\t\t   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC |\n\t\t   DRM_MODE_FLAG_INTERLACE),\n\t  .picture_aspect_ratio = HDMI_PICTURE_ASPECT_16_9, },\n\t \n\t{ DRM_MODE(\"1280x720\", DRM_MODE_TYPE_DRIVER, 148500, 1280, 1390,\n\t\t   1430, 1650, 0, 720, 725, 730, 750, 0,\n\t\t   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC),\n\t  .picture_aspect_ratio = HDMI_PICTURE_ASPECT_16_9, },\n\t \n\t{ DRM_MODE(\"720x480\", DRM_MODE_TYPE_DRIVER, 54000, 720, 736,\n\t\t   798, 858, 0, 480, 489, 495, 525, 0,\n\t\t   DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_NVSYNC),\n\t  .picture_aspect_ratio = HDMI_PICTURE_ASPECT_4_3, },\n\t \n\t{ DRM_MODE(\"720x480\", DRM_MODE_TYPE_DRIVER, 54000, 720, 736,\n\t\t   798, 858, 0, 480, 489, 495, 525, 0,\n\t\t   DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_NVSYNC),\n\t  .picture_aspect_ratio = HDMI_PICTURE_ASPECT_16_9, },\n\t \n\t{ DRM_MODE(\"720x480i\", DRM_MODE_TYPE_DRIVER, 27000, 720, 739,\n\t\t   801, 858, 0, 480, 488, 494, 525, 0,\n\t\t   DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_NVSYNC |\n\t\t   DRM_MODE_FLAG_INTERLACE | DRM_MODE_FLAG_DBLCLK),\n\t  .picture_aspect_ratio = HDMI_PICTURE_ASPECT_4_3, },\n\t \n\t{ DRM_MODE(\"720x480i\", DRM_MODE_TYPE_DRIVER, 27000, 720, 739,\n\t\t   801, 858, 0, 480, 488, 494, 525, 0,\n\t\t   DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_NVSYNC |\n\t\t   DRM_MODE_FLAG_INTERLACE | DRM_MODE_FLAG_DBLCLK),\n\t  .picture_aspect_ratio = HDMI_PICTURE_ASPECT_16_9, },\n\t \n\t{ DRM_MODE(\"720x576\", DRM_MODE_TYPE_DRIVER, 108000, 720, 732,\n\t\t   796, 864, 0, 576, 581, 586, 625, 0,\n\t\t   DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_NVSYNC),\n\t  .picture_aspect_ratio = HDMI_PICTURE_ASPECT_4_3, },\n\t \n\t{ DRM_MODE(\"720x576\", DRM_MODE_TYPE_DRIVER, 108000, 720, 732,\n\t\t   796, 864, 0, 576, 581, 586, 625, 0,\n\t\t   DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_NVSYNC),\n\t  .picture_aspect_ratio = HDMI_PICTURE_ASPECT_16_9, },\n\t \n\t{ DRM_MODE(\"720x576i\", DRM_MODE_TYPE_DRIVER, 54000, 720, 732,\n\t\t   795, 864, 0, 576, 580, 586, 625, 0,\n\t\t   DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_NVSYNC |\n\t\t   DRM_MODE_FLAG_INTERLACE | DRM_MODE_FLAG_DBLCLK),\n\t  .picture_aspect_ratio = HDMI_PICTURE_ASPECT_4_3, },\n\t \n\t{ DRM_MODE(\"720x576i\", DRM_MODE_TYPE_DRIVER, 54000, 720, 732,\n\t\t   795, 864, 0, 576, 580, 586, 625, 0,\n\t\t   DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_NVSYNC |\n\t\t   DRM_MODE_FLAG_INTERLACE | DRM_MODE_FLAG_DBLCLK),\n\t  .picture_aspect_ratio = HDMI_PICTURE_ASPECT_16_9, },\n\t \n\t{ DRM_MODE(\"720x480\", DRM_MODE_TYPE_DRIVER, 108000, 720, 736,\n\t\t   798, 858, 0, 480, 489, 495, 525, 0,\n\t\t   DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_NVSYNC),\n\t  .picture_aspect_ratio = HDMI_PICTURE_ASPECT_4_3, },\n\t \n\t{ DRM_MODE(\"720x480\", DRM_MODE_TYPE_DRIVER, 108000, 720, 736,\n\t\t   798, 858, 0, 480, 489, 495, 525, 0,\n\t\t   DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_NVSYNC),\n\t  .picture_aspect_ratio = HDMI_PICTURE_ASPECT_16_9, },\n\t \n\t{ DRM_MODE(\"720x480i\", DRM_MODE_TYPE_DRIVER, 54000, 720, 739,\n\t\t   801, 858, 0, 480, 488, 494, 525, 0,\n\t\t   DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_NVSYNC |\n\t\t   DRM_MODE_FLAG_INTERLACE | DRM_MODE_FLAG_DBLCLK),\n\t  .picture_aspect_ratio = HDMI_PICTURE_ASPECT_4_3, },\n\t \n\t{ DRM_MODE(\"720x480i\", DRM_MODE_TYPE_DRIVER, 54000, 720, 739,\n\t\t   801, 858, 0, 480, 488, 494, 525, 0,\n\t\t   DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_NVSYNC |\n\t\t   DRM_MODE_FLAG_INTERLACE | DRM_MODE_FLAG_DBLCLK),\n\t  .picture_aspect_ratio = HDMI_PICTURE_ASPECT_16_9, },\n\t \n\t{ DRM_MODE(\"1280x720\", DRM_MODE_TYPE_DRIVER, 59400, 1280, 3040,\n\t\t   3080, 3300, 0, 720, 725, 730, 750, 0,\n\t\t   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC),\n\t  .picture_aspect_ratio = HDMI_PICTURE_ASPECT_16_9, },\n\t \n\t{ DRM_MODE(\"1280x720\", DRM_MODE_TYPE_DRIVER, 74250, 1280, 3700,\n\t\t   3740, 3960, 0, 720, 725, 730, 750, 0,\n\t\t   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC),\n\t  .picture_aspect_ratio = HDMI_PICTURE_ASPECT_16_9, },\n\t \n\t{ DRM_MODE(\"1280x720\", DRM_MODE_TYPE_DRIVER, 74250, 1280, 3040,\n\t\t   3080, 3300, 0, 720, 725, 730, 750, 0,\n\t\t   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC),\n\t  .picture_aspect_ratio = HDMI_PICTURE_ASPECT_16_9, },\n\t \n\t{ DRM_MODE(\"1920x1080\", DRM_MODE_TYPE_DRIVER, 297000, 1920, 2008,\n\t\t   2052, 2200, 0, 1080, 1084, 1089, 1125, 0,\n\t\t   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC),\n\t  .picture_aspect_ratio = HDMI_PICTURE_ASPECT_16_9, },\n\t \n\t{ DRM_MODE(\"1920x1080\", DRM_MODE_TYPE_DRIVER, 297000, 1920, 2448,\n\t\t   2492, 2640, 0, 1080, 1084, 1089, 1125, 0,\n\t\t   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC),\n\t  .picture_aspect_ratio = HDMI_PICTURE_ASPECT_16_9, },\n\t \n\t{ DRM_MODE(\"1280x720\", DRM_MODE_TYPE_DRIVER, 59400, 1280, 3040,\n\t\t   3080, 3300, 0, 720, 725, 730, 750, 0,\n\t\t   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC),\n\t  .picture_aspect_ratio = HDMI_PICTURE_ASPECT_64_27, },\n\t \n\t{ DRM_MODE(\"1280x720\", DRM_MODE_TYPE_DRIVER, 74250, 1280, 3700,\n\t\t   3740, 3960, 0, 720, 725, 730, 750, 0,\n\t\t   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC),\n\t  .picture_aspect_ratio = HDMI_PICTURE_ASPECT_64_27, },\n\t \n\t{ DRM_MODE(\"1280x720\", DRM_MODE_TYPE_DRIVER, 74250, 1280, 3040,\n\t\t   3080, 3300, 0, 720, 725, 730, 750, 0,\n\t\t   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC),\n\t  .picture_aspect_ratio = HDMI_PICTURE_ASPECT_64_27, },\n\t \n\t{ DRM_MODE(\"1280x720\", DRM_MODE_TYPE_DRIVER, 74250, 1280, 1720,\n\t\t   1760, 1980, 0, 720, 725, 730, 750, 0,\n\t\t   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC),\n\t  .picture_aspect_ratio = HDMI_PICTURE_ASPECT_64_27, },\n\t \n\t{ DRM_MODE(\"1280x720\", DRM_MODE_TYPE_DRIVER, 74250, 1280, 1390,\n\t\t   1430, 1650, 0, 720, 725, 730, 750, 0,\n\t\t   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC),\n\t  .picture_aspect_ratio = HDMI_PICTURE_ASPECT_64_27, },\n\t \n\t{ DRM_MODE(\"1280x720\", DRM_MODE_TYPE_DRIVER, 148500, 1280, 1720,\n\t\t   1760, 1980, 0, 720, 725, 730, 750, 0,\n\t\t   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC),\n\t  .picture_aspect_ratio = HDMI_PICTURE_ASPECT_64_27, },\n\t \n\t{ DRM_MODE(\"1280x720\", DRM_MODE_TYPE_DRIVER, 148500, 1280, 1390,\n\t\t   1430, 1650, 0, 720, 725, 730, 750, 0,\n\t\t   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC),\n\t  .picture_aspect_ratio = HDMI_PICTURE_ASPECT_64_27, },\n\t \n\t{ DRM_MODE(\"1920x1080\", DRM_MODE_TYPE_DRIVER, 74250, 1920, 2558,\n\t\t   2602, 2750, 0, 1080, 1084, 1089, 1125, 0,\n\t\t   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC),\n\t  .picture_aspect_ratio = HDMI_PICTURE_ASPECT_64_27, },\n\t \n\t{ DRM_MODE(\"1920x1080\", DRM_MODE_TYPE_DRIVER, 74250, 1920, 2448,\n\t\t   2492, 2640, 0, 1080, 1084, 1089, 1125, 0,\n\t\t   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC),\n\t  .picture_aspect_ratio = HDMI_PICTURE_ASPECT_64_27, },\n\t \n\t{ DRM_MODE(\"1920x1080\", DRM_MODE_TYPE_DRIVER, 74250, 1920, 2008,\n\t\t   2052, 2200, 0, 1080, 1084, 1089, 1125, 0,\n\t\t   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC),\n\t  .picture_aspect_ratio = HDMI_PICTURE_ASPECT_64_27, },\n\t \n\t{ DRM_MODE(\"1920x1080\", DRM_MODE_TYPE_DRIVER, 148500, 1920, 2448,\n\t\t   2492, 2640, 0, 1080, 1084, 1089, 1125, 0,\n\t\t   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC),\n\t  .picture_aspect_ratio = HDMI_PICTURE_ASPECT_64_27, },\n\t \n\t{ DRM_MODE(\"1920x1080\", DRM_MODE_TYPE_DRIVER, 148500, 1920, 2008,\n\t\t   2052, 2200, 0, 1080, 1084, 1089, 1125, 0,\n\t\t   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC),\n\t  .picture_aspect_ratio = HDMI_PICTURE_ASPECT_64_27, },\n\t \n\t{ DRM_MODE(\"1920x1080\", DRM_MODE_TYPE_DRIVER, 297000, 1920, 2448,\n\t\t   2492, 2640, 0, 1080, 1084, 1089, 1125, 0,\n\t\t   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC),\n\t  .picture_aspect_ratio = HDMI_PICTURE_ASPECT_64_27, },\n\t \n\t{ DRM_MODE(\"1920x1080\", DRM_MODE_TYPE_DRIVER, 297000, 1920, 2008,\n\t\t   2052, 2200, 0, 1080, 1084, 1089, 1125, 0,\n\t\t   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC),\n\t  .picture_aspect_ratio = HDMI_PICTURE_ASPECT_64_27, },\n\t \n\t{ DRM_MODE(\"1680x720\", DRM_MODE_TYPE_DRIVER, 59400, 1680, 3040,\n\t\t   3080, 3300, 0, 720, 725, 730, 750, 0,\n\t\t   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC),\n\t  .picture_aspect_ratio = HDMI_PICTURE_ASPECT_64_27, },\n\t \n\t{ DRM_MODE(\"1680x720\", DRM_MODE_TYPE_DRIVER, 59400, 1680, 2908,\n\t\t   2948, 3168, 0, 720, 725, 730, 750, 0,\n\t\t   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC),\n\t  .picture_aspect_ratio = HDMI_PICTURE_ASPECT_64_27, },\n\t \n\t{ DRM_MODE(\"1680x720\", DRM_MODE_TYPE_DRIVER, 59400, 1680, 2380,\n\t\t   2420, 2640, 0, 720, 725, 730, 750, 0,\n\t\t   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC),\n\t  .picture_aspect_ratio = HDMI_PICTURE_ASPECT_64_27, },\n\t \n\t{ DRM_MODE(\"1680x720\", DRM_MODE_TYPE_DRIVER, 82500, 1680, 1940,\n\t\t   1980, 2200, 0, 720, 725, 730, 750, 0,\n\t\t   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC),\n\t  .picture_aspect_ratio = HDMI_PICTURE_ASPECT_64_27, },\n\t \n\t{ DRM_MODE(\"1680x720\", DRM_MODE_TYPE_DRIVER, 99000, 1680, 1940,\n\t\t   1980, 2200, 0, 720, 725, 730, 750, 0,\n\t\t   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC),\n\t  .picture_aspect_ratio = HDMI_PICTURE_ASPECT_64_27, },\n\t \n\t{ DRM_MODE(\"1680x720\", DRM_MODE_TYPE_DRIVER, 165000, 1680, 1740,\n\t\t   1780, 2000, 0, 720, 725, 730, 825, 0,\n\t\t   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC),\n\t  .picture_aspect_ratio = HDMI_PICTURE_ASPECT_64_27, },\n\t \n\t{ DRM_MODE(\"1680x720\", DRM_MODE_TYPE_DRIVER, 198000, 1680, 1740,\n\t\t   1780, 2000, 0, 720, 725, 730, 825, 0,\n\t\t   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC),\n\t  .picture_aspect_ratio = HDMI_PICTURE_ASPECT_64_27, },\n\t \n\t{ DRM_MODE(\"2560x1080\", DRM_MODE_TYPE_DRIVER, 99000, 2560, 3558,\n\t\t   3602, 3750, 0, 1080, 1084, 1089, 1100, 0,\n\t\t   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC),\n\t  .picture_aspect_ratio = HDMI_PICTURE_ASPECT_64_27, },\n\t \n\t{ DRM_MODE(\"2560x1080\", DRM_MODE_TYPE_DRIVER, 90000, 2560, 3008,\n\t\t   3052, 3200, 0, 1080, 1084, 1089, 1125, 0,\n\t\t   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC),\n\t  .picture_aspect_ratio = HDMI_PICTURE_ASPECT_64_27, },\n\t \n\t{ DRM_MODE(\"2560x1080\", DRM_MODE_TYPE_DRIVER, 118800, 2560, 3328,\n\t\t   3372, 3520, 0, 1080, 1084, 1089, 1125, 0,\n\t\t   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC),\n\t  .picture_aspect_ratio = HDMI_PICTURE_ASPECT_64_27, },\n\t \n\t{ DRM_MODE(\"2560x1080\", DRM_MODE_TYPE_DRIVER, 185625, 2560, 3108,\n\t\t   3152, 3300, 0, 1080, 1084, 1089, 1125, 0,\n\t\t   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC),\n\t  .picture_aspect_ratio = HDMI_PICTURE_ASPECT_64_27, },\n\t \n\t{ DRM_MODE(\"2560x1080\", DRM_MODE_TYPE_DRIVER, 198000, 2560, 2808,\n\t\t   2852, 3000, 0, 1080, 1084, 1089, 1100, 0,\n\t\t   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC),\n\t  .picture_aspect_ratio = HDMI_PICTURE_ASPECT_64_27, },\n\t \n\t{ DRM_MODE(\"2560x1080\", DRM_MODE_TYPE_DRIVER, 371250, 2560, 2778,\n\t\t   2822, 2970, 0, 1080, 1084, 1089, 1250, 0,\n\t\t   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC),\n\t  .picture_aspect_ratio = HDMI_PICTURE_ASPECT_64_27, },\n\t \n\t{ DRM_MODE(\"2560x1080\", DRM_MODE_TYPE_DRIVER, 495000, 2560, 3108,\n\t\t   3152, 3300, 0, 1080, 1084, 1089, 1250, 0,\n\t\t   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC),\n\t  .picture_aspect_ratio = HDMI_PICTURE_ASPECT_64_27, },\n\t \n\t{ DRM_MODE(\"3840x2160\", DRM_MODE_TYPE_DRIVER, 297000, 3840, 5116,\n\t\t   5204, 5500, 0, 2160, 2168, 2178, 2250, 0,\n\t\t   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC),\n\t  .picture_aspect_ratio = HDMI_PICTURE_ASPECT_16_9, },\n\t \n\t{ DRM_MODE(\"3840x2160\", DRM_MODE_TYPE_DRIVER, 297000, 3840, 4896,\n\t\t   4984, 5280, 0, 2160, 2168, 2178, 2250, 0,\n\t\t   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC),\n\t  .picture_aspect_ratio = HDMI_PICTURE_ASPECT_16_9, },\n\t \n\t{ DRM_MODE(\"3840x2160\", DRM_MODE_TYPE_DRIVER, 297000, 3840, 4016,\n\t\t   4104, 4400, 0, 2160, 2168, 2178, 2250, 0,\n\t\t   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC),\n\t  .picture_aspect_ratio = HDMI_PICTURE_ASPECT_16_9, },\n\t \n\t{ DRM_MODE(\"3840x2160\", DRM_MODE_TYPE_DRIVER, 594000, 3840, 4896,\n\t\t   4984, 5280, 0, 2160, 2168, 2178, 2250, 0,\n\t\t   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC),\n\t  .picture_aspect_ratio = HDMI_PICTURE_ASPECT_16_9, },\n\t \n\t{ DRM_MODE(\"3840x2160\", DRM_MODE_TYPE_DRIVER, 594000, 3840, 4016,\n\t\t   4104, 4400, 0, 2160, 2168, 2178, 2250, 0,\n\t\t   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC),\n\t  .picture_aspect_ratio = HDMI_PICTURE_ASPECT_16_9, },\n\t \n\t{ DRM_MODE(\"4096x2160\", DRM_MODE_TYPE_DRIVER, 297000, 4096, 5116,\n\t\t   5204, 5500, 0, 2160, 2168, 2178, 2250, 0,\n\t\t   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC),\n\t  .picture_aspect_ratio = HDMI_PICTURE_ASPECT_256_135, },\n\t \n\t{ DRM_MODE(\"4096x2160\", DRM_MODE_TYPE_DRIVER, 297000, 4096, 5064,\n\t\t   5152, 5280, 0, 2160, 2168, 2178, 2250, 0,\n\t\t   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC),\n\t  .picture_aspect_ratio = HDMI_PICTURE_ASPECT_256_135, },\n\t \n\t{ DRM_MODE(\"4096x2160\", DRM_MODE_TYPE_DRIVER, 297000, 4096, 4184,\n\t\t   4272, 4400, 0, 2160, 2168, 2178, 2250, 0,\n\t\t   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC),\n\t  .picture_aspect_ratio = HDMI_PICTURE_ASPECT_256_135, },\n\t \n\t{ DRM_MODE(\"4096x2160\", DRM_MODE_TYPE_DRIVER, 594000, 4096, 5064,\n\t\t   5152, 5280, 0, 2160, 2168, 2178, 2250, 0,\n\t\t   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC),\n\t  .picture_aspect_ratio = HDMI_PICTURE_ASPECT_256_135, },\n\t \n\t{ DRM_MODE(\"4096x2160\", DRM_MODE_TYPE_DRIVER, 594000, 4096, 4184,\n\t\t   4272, 4400, 0, 2160, 2168, 2178, 2250, 0,\n\t\t   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC),\n\t  .picture_aspect_ratio = HDMI_PICTURE_ASPECT_256_135, },\n\t \n\t{ DRM_MODE(\"3840x2160\", DRM_MODE_TYPE_DRIVER, 297000, 3840, 5116,\n\t\t   5204, 5500, 0, 2160, 2168, 2178, 2250, 0,\n\t\t   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC),\n\t  .picture_aspect_ratio = HDMI_PICTURE_ASPECT_64_27, },\n\t \n\t{ DRM_MODE(\"3840x2160\", DRM_MODE_TYPE_DRIVER, 297000, 3840, 4896,\n\t\t   4984, 5280, 0, 2160, 2168, 2178, 2250, 0,\n\t\t   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC),\n\t  .picture_aspect_ratio = HDMI_PICTURE_ASPECT_64_27, },\n\t \n\t{ DRM_MODE(\"3840x2160\", DRM_MODE_TYPE_DRIVER, 297000, 3840, 4016,\n\t\t   4104, 4400, 0, 2160, 2168, 2178, 2250, 0,\n\t\t   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC),\n\t  .picture_aspect_ratio = HDMI_PICTURE_ASPECT_64_27, },\n\t \n\t{ DRM_MODE(\"3840x2160\", DRM_MODE_TYPE_DRIVER, 594000, 3840, 4896,\n\t\t   4984, 5280, 0, 2160, 2168, 2178, 2250, 0,\n\t\t   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC),\n\t  .picture_aspect_ratio = HDMI_PICTURE_ASPECT_64_27, },\n\t \n\t{ DRM_MODE(\"3840x2160\", DRM_MODE_TYPE_DRIVER, 594000, 3840, 4016,\n\t\t   4104, 4400, 0, 2160, 2168, 2178, 2250, 0,\n\t\t   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC),\n\t  .picture_aspect_ratio = HDMI_PICTURE_ASPECT_64_27, },\n\t \n\t{ DRM_MODE(\"1280x720\", DRM_MODE_TYPE_DRIVER, 90000, 1280, 2240,\n\t\t   2280, 2500, 0, 720, 725, 730, 750, 0,\n\t\t   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC),\n\t  .picture_aspect_ratio = HDMI_PICTURE_ASPECT_16_9, },\n\t \n\t{ DRM_MODE(\"1280x720\", DRM_MODE_TYPE_DRIVER, 90000, 1280, 2240,\n\t\t   2280, 2500, 0, 720, 725, 730, 750, 0,\n\t\t   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC),\n\t  .picture_aspect_ratio = HDMI_PICTURE_ASPECT_64_27, },\n\t \n\t{ DRM_MODE(\"1680x720\", DRM_MODE_TYPE_DRIVER, 99000, 1680, 2490,\n\t\t   2530, 2750, 0, 720, 725, 730, 750, 0,\n\t\t   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC),\n\t  .picture_aspect_ratio = HDMI_PICTURE_ASPECT_64_27, },\n\t \n\t{ DRM_MODE(\"1920x1080\", DRM_MODE_TYPE_DRIVER, 148500, 1920, 2558,\n\t\t   2602, 2750, 0, 1080, 1084, 1089, 1125, 0,\n\t\t   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC),\n\t  .picture_aspect_ratio = HDMI_PICTURE_ASPECT_16_9, },\n\t \n\t{ DRM_MODE(\"1920x1080\", DRM_MODE_TYPE_DRIVER, 148500, 1920, 2558,\n\t\t   2602, 2750, 0, 1080, 1084, 1089, 1125, 0,\n\t\t   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC),\n\t  .picture_aspect_ratio = HDMI_PICTURE_ASPECT_64_27, },\n\t \n\t{ DRM_MODE(\"2560x1080\", DRM_MODE_TYPE_DRIVER, 198000, 2560, 3558,\n\t\t   3602, 3750, 0, 1080, 1084, 1089, 1100, 0,\n\t\t   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC),\n\t  .picture_aspect_ratio = HDMI_PICTURE_ASPECT_64_27, },\n\t \n\t{ DRM_MODE(\"3840x2160\", DRM_MODE_TYPE_DRIVER, 594000, 3840, 5116,\n\t\t   5204, 5500, 0, 2160, 2168, 2178, 2250, 0,\n\t\t   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC),\n\t  .picture_aspect_ratio = HDMI_PICTURE_ASPECT_16_9, },\n\t \n\t{ DRM_MODE(\"4096x2160\", DRM_MODE_TYPE_DRIVER, 594000, 4096, 5116,\n\t\t   5204, 5500, 0, 2160, 2168, 2178, 2250, 0,\n\t\t   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC),\n\t  .picture_aspect_ratio = HDMI_PICTURE_ASPECT_256_135, },\n\t \n\t{ DRM_MODE(\"3840x2160\", DRM_MODE_TYPE_DRIVER, 594000, 3840, 5116,\n\t\t   5204, 5500, 0, 2160, 2168, 2178, 2250, 0,\n\t\t   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC),\n\t  .picture_aspect_ratio = HDMI_PICTURE_ASPECT_64_27, },\n\t \n\t{ DRM_MODE(\"3840x2160\", DRM_MODE_TYPE_DRIVER, 1188000, 3840, 4896,\n\t\t   4984, 5280, 0, 2160, 2168, 2178, 2250, 0,\n\t\t   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC),\n\t  .picture_aspect_ratio = HDMI_PICTURE_ASPECT_16_9, },\n\t \n\t{ DRM_MODE(\"3840x2160\", DRM_MODE_TYPE_DRIVER, 1188000, 3840, 4016,\n\t\t   4104, 4400, 0, 2160, 2168, 2178, 2250, 0,\n\t\t   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC),\n\t  .picture_aspect_ratio = HDMI_PICTURE_ASPECT_16_9, },\n\t \n\t{ DRM_MODE(\"3840x2160\", DRM_MODE_TYPE_DRIVER, 1188000, 3840, 4896,\n\t\t   4984, 5280, 0, 2160, 2168, 2178, 2250, 0,\n\t\t   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC),\n\t  .picture_aspect_ratio = HDMI_PICTURE_ASPECT_64_27, },\n\t \n\t{ DRM_MODE(\"3840x2160\", DRM_MODE_TYPE_DRIVER, 1188000, 3840, 4016,\n\t\t   4104, 4400, 0, 2160, 2168, 2178, 2250, 0,\n\t\t   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC),\n\t  .picture_aspect_ratio = HDMI_PICTURE_ASPECT_64_27, },\n\t \n\t{ DRM_MODE(\"5120x2160\", DRM_MODE_TYPE_DRIVER, 396000, 5120, 7116,\n\t\t   7204, 7500, 0, 2160, 2168, 2178, 2200, 0,\n\t\t   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC),\n\t  .picture_aspect_ratio = HDMI_PICTURE_ASPECT_64_27, },\n\t \n\t{ DRM_MODE(\"5120x2160\", DRM_MODE_TYPE_DRIVER, 396000, 5120, 6816,\n\t\t   6904, 7200, 0, 2160, 2168, 2178, 2200, 0,\n\t\t   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC),\n\t  .picture_aspect_ratio = HDMI_PICTURE_ASPECT_64_27, },\n\t \n\t{ DRM_MODE(\"5120x2160\", DRM_MODE_TYPE_DRIVER, 396000, 5120, 5784,\n\t\t   5872, 6000, 0, 2160, 2168, 2178, 2200, 0,\n\t\t   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC),\n\t  .picture_aspect_ratio = HDMI_PICTURE_ASPECT_64_27, },\n\t \n\t{ DRM_MODE(\"5120x2160\", DRM_MODE_TYPE_DRIVER, 742500, 5120, 5866,\n\t\t   5954, 6250, 0, 2160, 2168, 2178, 2475, 0,\n\t\t   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC),\n\t  .picture_aspect_ratio = HDMI_PICTURE_ASPECT_64_27, },\n\t \n\t{ DRM_MODE(\"5120x2160\", DRM_MODE_TYPE_DRIVER, 742500, 5120, 6216,\n\t\t   6304, 6600, 0, 2160, 2168, 2178, 2250, 0,\n\t\t   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC),\n\t  .picture_aspect_ratio = HDMI_PICTURE_ASPECT_64_27, },\n\t \n\t{ DRM_MODE(\"5120x2160\", DRM_MODE_TYPE_DRIVER, 742500, 5120, 5284,\n\t\t   5372, 5500, 0, 2160, 2168, 2178, 2250, 0,\n\t\t   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC),\n\t  .picture_aspect_ratio = HDMI_PICTURE_ASPECT_64_27, },\n\t \n\t{ DRM_MODE(\"5120x2160\", DRM_MODE_TYPE_DRIVER, 1485000, 5120, 6216,\n\t\t   6304, 6600, 0, 2160, 2168, 2178, 2250, 0,\n\t\t   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC),\n\t  .picture_aspect_ratio = HDMI_PICTURE_ASPECT_64_27, },\n};\n\n \nstatic const struct drm_display_mode edid_cea_modes_193[] = {\n\t \n\t{ DRM_MODE(\"5120x2160\", DRM_MODE_TYPE_DRIVER, 1485000, 5120, 5284,\n\t\t   5372, 5500, 0, 2160, 2168, 2178, 2250, 0,\n\t\t   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC),\n\t  .picture_aspect_ratio = HDMI_PICTURE_ASPECT_64_27, },\n\t \n\t{ DRM_MODE(\"7680x4320\", DRM_MODE_TYPE_DRIVER, 1188000, 7680, 10232,\n\t\t   10408, 11000, 0, 4320, 4336, 4356, 4500, 0,\n\t\t   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC),\n\t  .picture_aspect_ratio = HDMI_PICTURE_ASPECT_16_9, },\n\t \n\t{ DRM_MODE(\"7680x4320\", DRM_MODE_TYPE_DRIVER, 1188000, 7680, 10032,\n\t\t   10208, 10800, 0, 4320, 4336, 4356, 4400, 0,\n\t\t   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC),\n\t  .picture_aspect_ratio = HDMI_PICTURE_ASPECT_16_9, },\n\t \n\t{ DRM_MODE(\"7680x4320\", DRM_MODE_TYPE_DRIVER, 1188000, 7680, 8232,\n\t\t   8408, 9000, 0, 4320, 4336, 4356, 4400, 0,\n\t\t   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC),\n\t  .picture_aspect_ratio = HDMI_PICTURE_ASPECT_16_9, },\n\t \n\t{ DRM_MODE(\"7680x4320\", DRM_MODE_TYPE_DRIVER, 2376000, 7680, 10232,\n\t\t   10408, 11000, 0, 4320, 4336, 4356, 4500, 0,\n\t\t   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC),\n\t  .picture_aspect_ratio = HDMI_PICTURE_ASPECT_16_9, },\n\t \n\t{ DRM_MODE(\"7680x4320\", DRM_MODE_TYPE_DRIVER, 2376000, 7680, 10032,\n\t\t   10208, 10800, 0, 4320, 4336, 4356, 4400, 0,\n\t\t   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC),\n\t  .picture_aspect_ratio = HDMI_PICTURE_ASPECT_16_9, },\n\t \n\t{ DRM_MODE(\"7680x4320\", DRM_MODE_TYPE_DRIVER, 2376000, 7680, 8232,\n\t\t   8408, 9000, 0, 4320, 4336, 4356, 4400, 0,\n\t\t   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC),\n\t  .picture_aspect_ratio = HDMI_PICTURE_ASPECT_16_9, },\n\t \n\t{ DRM_MODE(\"7680x4320\", DRM_MODE_TYPE_DRIVER, 4752000, 7680, 9792,\n\t\t   9968, 10560, 0, 4320, 4336, 4356, 4500, 0,\n\t\t   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC),\n\t  .picture_aspect_ratio = HDMI_PICTURE_ASPECT_16_9, },\n\t \n\t{ DRM_MODE(\"7680x4320\", DRM_MODE_TYPE_DRIVER, 4752000, 7680, 8032,\n\t\t   8208, 8800, 0, 4320, 4336, 4356, 4500, 0,\n\t\t   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC),\n\t  .picture_aspect_ratio = HDMI_PICTURE_ASPECT_16_9, },\n\t \n\t{ DRM_MODE(\"7680x4320\", DRM_MODE_TYPE_DRIVER, 1188000, 7680, 10232,\n\t\t   10408, 11000, 0, 4320, 4336, 4356, 4500, 0,\n\t\t   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC),\n\t  .picture_aspect_ratio = HDMI_PICTURE_ASPECT_64_27, },\n\t \n\t{ DRM_MODE(\"7680x4320\", DRM_MODE_TYPE_DRIVER, 1188000, 7680, 10032,\n\t\t   10208, 10800, 0, 4320, 4336, 4356, 4400, 0,\n\t\t   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC),\n\t  .picture_aspect_ratio = HDMI_PICTURE_ASPECT_64_27, },\n\t \n\t{ DRM_MODE(\"7680x4320\", DRM_MODE_TYPE_DRIVER, 1188000, 7680, 8232,\n\t\t   8408, 9000, 0, 4320, 4336, 4356, 4400, 0,\n\t\t   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC),\n\t  .picture_aspect_ratio = HDMI_PICTURE_ASPECT_64_27, },\n\t \n\t{ DRM_MODE(\"7680x4320\", DRM_MODE_TYPE_DRIVER, 2376000, 7680, 10232,\n\t\t   10408, 11000, 0, 4320, 4336, 4356, 4500, 0,\n\t\t   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC),\n\t  .picture_aspect_ratio = HDMI_PICTURE_ASPECT_64_27, },\n\t \n\t{ DRM_MODE(\"7680x4320\", DRM_MODE_TYPE_DRIVER, 2376000, 7680, 10032,\n\t\t   10208, 10800, 0, 4320, 4336, 4356, 4400, 0,\n\t\t   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC),\n\t  .picture_aspect_ratio = HDMI_PICTURE_ASPECT_64_27, },\n\t \n\t{ DRM_MODE(\"7680x4320\", DRM_MODE_TYPE_DRIVER, 2376000, 7680, 8232,\n\t\t   8408, 9000, 0, 4320, 4336, 4356, 4400, 0,\n\t\t   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC),\n\t  .picture_aspect_ratio = HDMI_PICTURE_ASPECT_64_27, },\n\t \n\t{ DRM_MODE(\"7680x4320\", DRM_MODE_TYPE_DRIVER, 4752000, 7680, 9792,\n\t\t   9968, 10560, 0, 4320, 4336, 4356, 4500, 0,\n\t\t   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC),\n\t  .picture_aspect_ratio = HDMI_PICTURE_ASPECT_64_27, },\n\t \n\t{ DRM_MODE(\"7680x4320\", DRM_MODE_TYPE_DRIVER, 4752000, 7680, 8032,\n\t\t   8208, 8800, 0, 4320, 4336, 4356, 4500, 0,\n\t\t   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC),\n\t  .picture_aspect_ratio = HDMI_PICTURE_ASPECT_64_27, },\n\t \n\t{ DRM_MODE(\"10240x4320\", DRM_MODE_TYPE_DRIVER, 1485000, 10240, 11732,\n\t\t   11908, 12500, 0, 4320, 4336, 4356, 4950, 0,\n\t\t   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC),\n\t  .picture_aspect_ratio = HDMI_PICTURE_ASPECT_64_27, },\n\t \n\t{ DRM_MODE(\"10240x4320\", DRM_MODE_TYPE_DRIVER, 1485000, 10240, 12732,\n\t\t   12908, 13500, 0, 4320, 4336, 4356, 4400, 0,\n\t\t   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC),\n\t  .picture_aspect_ratio = HDMI_PICTURE_ASPECT_64_27, },\n\t \n\t{ DRM_MODE(\"10240x4320\", DRM_MODE_TYPE_DRIVER, 1485000, 10240, 10528,\n\t\t   10704, 11000, 0, 4320, 4336, 4356, 4500, 0,\n\t\t   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC),\n\t  .picture_aspect_ratio = HDMI_PICTURE_ASPECT_64_27, },\n\t \n\t{ DRM_MODE(\"10240x4320\", DRM_MODE_TYPE_DRIVER, 2970000, 10240, 11732,\n\t\t   11908, 12500, 0, 4320, 4336, 4356, 4950, 0,\n\t\t   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC),\n\t  .picture_aspect_ratio = HDMI_PICTURE_ASPECT_64_27, },\n\t \n\t{ DRM_MODE(\"10240x4320\", DRM_MODE_TYPE_DRIVER, 2970000, 10240, 12732,\n\t\t   12908, 13500, 0, 4320, 4336, 4356, 4400, 0,\n\t\t   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC),\n\t  .picture_aspect_ratio = HDMI_PICTURE_ASPECT_64_27, },\n\t \n\t{ DRM_MODE(\"10240x4320\", DRM_MODE_TYPE_DRIVER, 2970000, 10240, 10528,\n\t\t   10704, 11000, 0, 4320, 4336, 4356, 4500, 0,\n\t\t   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC),\n\t  .picture_aspect_ratio = HDMI_PICTURE_ASPECT_64_27, },\n\t \n\t{ DRM_MODE(\"10240x4320\", DRM_MODE_TYPE_DRIVER, 5940000, 10240, 12432,\n\t\t   12608, 13200, 0, 4320, 4336, 4356, 4500, 0,\n\t\t   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC),\n\t  .picture_aspect_ratio = HDMI_PICTURE_ASPECT_64_27, },\n\t \n\t{ DRM_MODE(\"10240x4320\", DRM_MODE_TYPE_DRIVER, 5940000, 10240, 10528,\n\t\t   10704, 11000, 0, 4320, 4336, 4356, 4500, 0,\n\t\t   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC),\n\t  .picture_aspect_ratio = HDMI_PICTURE_ASPECT_64_27, },\n\t \n\t{ DRM_MODE(\"4096x2160\", DRM_MODE_TYPE_DRIVER, 1188000, 4096, 4896,\n\t\t   4984, 5280, 0, 2160, 2168, 2178, 2250, 0,\n\t\t   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC),\n\t  .picture_aspect_ratio = HDMI_PICTURE_ASPECT_256_135, },\n\t \n\t{ DRM_MODE(\"4096x2160\", DRM_MODE_TYPE_DRIVER, 1188000, 4096, 4184,\n\t\t   4272, 4400, 0, 2160, 2168, 2178, 2250, 0,\n\t\t   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC),\n\t  .picture_aspect_ratio = HDMI_PICTURE_ASPECT_256_135, },\n};\n\n \nstatic const struct drm_display_mode edid_4k_modes[] = {\n\t \n\t{ },\n\t \n\t{ DRM_MODE(\"3840x2160\", DRM_MODE_TYPE_DRIVER, 297000,\n\t\t   3840, 4016, 4104, 4400, 0,\n\t\t   2160, 2168, 2178, 2250, 0,\n\t\t   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC),\n\t  .picture_aspect_ratio = HDMI_PICTURE_ASPECT_16_9, },\n\t \n\t{ DRM_MODE(\"3840x2160\", DRM_MODE_TYPE_DRIVER, 297000,\n\t\t   3840, 4896, 4984, 5280, 0,\n\t\t   2160, 2168, 2178, 2250, 0,\n\t\t   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC),\n\t  .picture_aspect_ratio = HDMI_PICTURE_ASPECT_16_9, },\n\t \n\t{ DRM_MODE(\"3840x2160\", DRM_MODE_TYPE_DRIVER, 297000,\n\t\t   3840, 5116, 5204, 5500, 0,\n\t\t   2160, 2168, 2178, 2250, 0,\n\t\t   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC),\n\t  .picture_aspect_ratio = HDMI_PICTURE_ASPECT_16_9, },\n\t \n\t{ DRM_MODE(\"4096x2160\", DRM_MODE_TYPE_DRIVER, 297000,\n\t\t   4096, 5116, 5204, 5500, 0,\n\t\t   2160, 2168, 2178, 2250, 0,\n\t\t   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC),\n\t  .picture_aspect_ratio = HDMI_PICTURE_ASPECT_256_135, },\n};\n\n \n\n \nstruct drm_edid {\n\t \n\tsize_t size;\n\tconst struct edid *edid;\n};\n\nstatic int edid_hfeeodb_extension_block_count(const struct edid *edid);\n\nstatic int edid_hfeeodb_block_count(const struct edid *edid)\n{\n\tint eeodb = edid_hfeeodb_extension_block_count(edid);\n\n\treturn eeodb ? eeodb + 1 : 0;\n}\n\nstatic int edid_extension_block_count(const struct edid *edid)\n{\n\treturn edid->extensions;\n}\n\nstatic int edid_block_count(const struct edid *edid)\n{\n\treturn edid_extension_block_count(edid) + 1;\n}\n\nstatic int edid_size_by_blocks(int num_blocks)\n{\n\treturn num_blocks * EDID_LENGTH;\n}\n\nstatic int edid_size(const struct edid *edid)\n{\n\treturn edid_size_by_blocks(edid_block_count(edid));\n}\n\nstatic const void *edid_block_data(const struct edid *edid, int index)\n{\n\tBUILD_BUG_ON(sizeof(*edid) != EDID_LENGTH);\n\n\treturn edid + index;\n}\n\nstatic const void *edid_extension_block_data(const struct edid *edid, int index)\n{\n\treturn edid_block_data(edid, index + 1);\n}\n\n \nstatic int __drm_edid_block_count(const struct drm_edid *drm_edid)\n{\n\tint num_blocks;\n\n\t \n\tnum_blocks = edid_block_count(drm_edid->edid);\n\n\t \n\tif (drm_edid->size >= edid_size_by_blocks(2)) {\n\t\tint eeodb;\n\n\t\t \n\t\teeodb = edid_hfeeodb_block_count(drm_edid->edid);\n\t\tif (eeodb)\n\t\t\tnum_blocks = eeodb;\n\t}\n\n\treturn num_blocks;\n}\n\n \nstatic int drm_edid_block_count(const struct drm_edid *drm_edid)\n{\n\t \n\treturn min(__drm_edid_block_count(drm_edid),\n\t\t   (int)drm_edid->size / EDID_LENGTH);\n}\n\n \nstatic int drm_edid_extension_block_count(const struct drm_edid *drm_edid)\n{\n\treturn drm_edid_block_count(drm_edid) - 1;\n}\n\nstatic const void *drm_edid_block_data(const struct drm_edid *drm_edid, int index)\n{\n\treturn edid_block_data(drm_edid->edid, index);\n}\n\nstatic const void *drm_edid_extension_block_data(const struct drm_edid *drm_edid,\n\t\t\t\t\t\t int index)\n{\n\treturn edid_extension_block_data(drm_edid->edid, index);\n}\n\n \nstatic const struct drm_edid *drm_edid_legacy_init(struct drm_edid *drm_edid,\n\t\t\t\t\t\t   const struct edid *edid)\n{\n\tif (!edid)\n\t\treturn NULL;\n\n\tmemset(drm_edid, 0, sizeof(*drm_edid));\n\n\tdrm_edid->edid = edid;\n\tdrm_edid->size = edid_size(edid);\n\n\treturn drm_edid;\n}\n\n \nstruct drm_edid_iter {\n\tconst struct drm_edid *drm_edid;\n\n\t \n\tint index;\n};\n\nstatic void drm_edid_iter_begin(const struct drm_edid *drm_edid,\n\t\t\t\tstruct drm_edid_iter *iter)\n{\n\tmemset(iter, 0, sizeof(*iter));\n\n\titer->drm_edid = drm_edid;\n}\n\nstatic const void *__drm_edid_iter_next(struct drm_edid_iter *iter)\n{\n\tconst void *block = NULL;\n\n\tif (!iter->drm_edid)\n\t\treturn NULL;\n\n\tif (iter->index < drm_edid_block_count(iter->drm_edid))\n\t\tblock = drm_edid_block_data(iter->drm_edid, iter->index++);\n\n\treturn block;\n}\n\n#define drm_edid_iter_for_each(__block, __iter)\t\t\t\\\n\twhile (((__block) = __drm_edid_iter_next(__iter)))\n\nstatic void drm_edid_iter_end(struct drm_edid_iter *iter)\n{\n\tmemset(iter, 0, sizeof(*iter));\n}\n\nstatic const u8 edid_header[] = {\n\t0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00\n};\n\nstatic void edid_header_fix(void *edid)\n{\n\tmemcpy(edid, edid_header, sizeof(edid_header));\n}\n\n \nint drm_edid_header_is_valid(const void *_edid)\n{\n\tconst struct edid *edid = _edid;\n\tint i, score = 0;\n\n\tfor (i = 0; i < sizeof(edid_header); i++) {\n\t\tif (edid->header[i] == edid_header[i])\n\t\t\tscore++;\n\t}\n\n\treturn score;\n}\nEXPORT_SYMBOL(drm_edid_header_is_valid);\n\nstatic int edid_fixup __read_mostly = 6;\nmodule_param_named(edid_fixup, edid_fixup, int, 0400);\nMODULE_PARM_DESC(edid_fixup,\n\t\t \"Minimum number of valid EDID header bytes (0-8, default 6)\");\n\nstatic int edid_block_compute_checksum(const void *_block)\n{\n\tconst u8 *block = _block;\n\tint i;\n\tu8 csum = 0, crc = 0;\n\n\tfor (i = 0; i < EDID_LENGTH - 1; i++)\n\t\tcsum += block[i];\n\n\tcrc = 0x100 - csum;\n\n\treturn crc;\n}\n\nstatic int edid_block_get_checksum(const void *_block)\n{\n\tconst struct edid *block = _block;\n\n\treturn block->checksum;\n}\n\nstatic int edid_block_tag(const void *_block)\n{\n\tconst u8 *block = _block;\n\n\treturn block[0];\n}\n\nstatic bool edid_block_is_zero(const void *edid)\n{\n\treturn !memchr_inv(edid, 0, EDID_LENGTH);\n}\n\n \nbool drm_edid_are_equal(const struct edid *edid1, const struct edid *edid2)\n{\n\tint edid1_len, edid2_len;\n\tbool edid1_present = edid1 != NULL;\n\tbool edid2_present = edid2 != NULL;\n\n\tif (edid1_present != edid2_present)\n\t\treturn false;\n\n\tif (edid1) {\n\t\tedid1_len = edid_size(edid1);\n\t\tedid2_len = edid_size(edid2);\n\n\t\tif (edid1_len != edid2_len)\n\t\t\treturn false;\n\n\t\tif (memcmp(edid1, edid2, edid1_len))\n\t\t\treturn false;\n\t}\n\n\treturn true;\n}\nEXPORT_SYMBOL(drm_edid_are_equal);\n\nenum edid_block_status {\n\tEDID_BLOCK_OK = 0,\n\tEDID_BLOCK_READ_FAIL,\n\tEDID_BLOCK_NULL,\n\tEDID_BLOCK_ZERO,\n\tEDID_BLOCK_HEADER_CORRUPT,\n\tEDID_BLOCK_HEADER_REPAIR,\n\tEDID_BLOCK_HEADER_FIXED,\n\tEDID_BLOCK_CHECKSUM,\n\tEDID_BLOCK_VERSION,\n};\n\nstatic enum edid_block_status edid_block_check(const void *_block,\n\t\t\t\t\t       bool is_base_block)\n{\n\tconst struct edid *block = _block;\n\n\tif (!block)\n\t\treturn EDID_BLOCK_NULL;\n\n\tif (is_base_block) {\n\t\tint score = drm_edid_header_is_valid(block);\n\n\t\tif (score < clamp(edid_fixup, 0, 8)) {\n\t\t\tif (edid_block_is_zero(block))\n\t\t\t\treturn EDID_BLOCK_ZERO;\n\t\t\telse\n\t\t\t\treturn EDID_BLOCK_HEADER_CORRUPT;\n\t\t}\n\n\t\tif (score < 8)\n\t\t\treturn EDID_BLOCK_HEADER_REPAIR;\n\t}\n\n\tif (edid_block_compute_checksum(block) != edid_block_get_checksum(block)) {\n\t\tif (edid_block_is_zero(block))\n\t\t\treturn EDID_BLOCK_ZERO;\n\t\telse\n\t\t\treturn EDID_BLOCK_CHECKSUM;\n\t}\n\n\tif (is_base_block) {\n\t\tif (block->version != 1)\n\t\t\treturn EDID_BLOCK_VERSION;\n\t}\n\n\treturn EDID_BLOCK_OK;\n}\n\nstatic bool edid_block_status_valid(enum edid_block_status status, int tag)\n{\n\treturn status == EDID_BLOCK_OK ||\n\t\tstatus == EDID_BLOCK_HEADER_FIXED ||\n\t\t(status == EDID_BLOCK_CHECKSUM && tag == CEA_EXT);\n}\n\nstatic bool edid_block_valid(const void *block, bool base)\n{\n\treturn edid_block_status_valid(edid_block_check(block, base),\n\t\t\t\t       edid_block_tag(block));\n}\n\nstatic void edid_block_status_print(enum edid_block_status status,\n\t\t\t\t    const struct edid *block,\n\t\t\t\t    int block_num)\n{\n\tswitch (status) {\n\tcase EDID_BLOCK_OK:\n\t\tbreak;\n\tcase EDID_BLOCK_READ_FAIL:\n\t\tpr_debug(\"EDID block %d read failed\\n\", block_num);\n\t\tbreak;\n\tcase EDID_BLOCK_NULL:\n\t\tpr_debug(\"EDID block %d pointer is NULL\\n\", block_num);\n\t\tbreak;\n\tcase EDID_BLOCK_ZERO:\n\t\tpr_notice(\"EDID block %d is all zeroes\\n\", block_num);\n\t\tbreak;\n\tcase EDID_BLOCK_HEADER_CORRUPT:\n\t\tpr_notice(\"EDID has corrupt header\\n\");\n\t\tbreak;\n\tcase EDID_BLOCK_HEADER_REPAIR:\n\t\tpr_debug(\"EDID corrupt header needs repair\\n\");\n\t\tbreak;\n\tcase EDID_BLOCK_HEADER_FIXED:\n\t\tpr_debug(\"EDID corrupt header fixed\\n\");\n\t\tbreak;\n\tcase EDID_BLOCK_CHECKSUM:\n\t\tif (edid_block_status_valid(status, edid_block_tag(block))) {\n\t\t\tpr_debug(\"EDID block %d (tag 0x%02x) checksum is invalid, remainder is %d, ignoring\\n\",\n\t\t\t\t block_num, edid_block_tag(block),\n\t\t\t\t edid_block_compute_checksum(block));\n\t\t} else {\n\t\t\tpr_notice(\"EDID block %d (tag 0x%02x) checksum is invalid, remainder is %d\\n\",\n\t\t\t\t  block_num, edid_block_tag(block),\n\t\t\t\t  edid_block_compute_checksum(block));\n\t\t}\n\t\tbreak;\n\tcase EDID_BLOCK_VERSION:\n\t\tpr_notice(\"EDID has major version %d, instead of 1\\n\",\n\t\t\t  block->version);\n\t\tbreak;\n\tdefault:\n\t\tWARN(1, \"EDID block %d unknown edid block status code %d\\n\",\n\t\t     block_num, status);\n\t\tbreak;\n\t}\n}\n\nstatic void edid_block_dump(const char *level, const void *block, int block_num)\n{\n\tenum edid_block_status status;\n\tchar prefix[20];\n\n\tstatus = edid_block_check(block, block_num == 0);\n\tif (status == EDID_BLOCK_ZERO)\n\t\tsprintf(prefix, \"\\t[%02x] ZERO \", block_num);\n\telse if (!edid_block_status_valid(status, edid_block_tag(block)))\n\t\tsprintf(prefix, \"\\t[%02x] BAD  \", block_num);\n\telse\n\t\tsprintf(prefix, \"\\t[%02x] GOOD \", block_num);\n\n\tprint_hex_dump(level, prefix, DUMP_PREFIX_NONE, 16, 1,\n\t\t       block, EDID_LENGTH, false);\n}\n\n \nbool drm_edid_block_valid(u8 *_block, int block_num, bool print_bad_edid,\n\t\t\t  bool *edid_corrupt)\n{\n\tstruct edid *block = (struct edid *)_block;\n\tenum edid_block_status status;\n\tbool is_base_block = block_num == 0;\n\tbool valid;\n\n\tif (WARN_ON(!block))\n\t\treturn false;\n\n\tstatus = edid_block_check(block, is_base_block);\n\tif (status == EDID_BLOCK_HEADER_REPAIR) {\n\t\tDRM_DEBUG_KMS(\"Fixing EDID header, your hardware may be failing\\n\");\n\t\tedid_header_fix(block);\n\n\t\t \n\t\tstatus = edid_block_check(block, is_base_block);\n\t\tif (status == EDID_BLOCK_OK)\n\t\t\tstatus = EDID_BLOCK_HEADER_FIXED;\n\t}\n\n\tif (edid_corrupt) {\n\t\t \n\t\tif (is_base_block &&\n\t\t    (status == EDID_BLOCK_OK || status == EDID_BLOCK_VERSION))\n\t\t\t*edid_corrupt = false;\n\t\telse if (status != EDID_BLOCK_OK)\n\t\t\t*edid_corrupt = true;\n\t}\n\n\tedid_block_status_print(status, block, block_num);\n\n\t \n\tvalid = edid_block_status_valid(status, edid_block_tag(block));\n\n\tif (!valid && print_bad_edid && status != EDID_BLOCK_ZERO) {\n\t\tpr_notice(\"Raw EDID:\\n\");\n\t\tedid_block_dump(KERN_NOTICE, block, block_num);\n\t}\n\n\treturn valid;\n}\nEXPORT_SYMBOL(drm_edid_block_valid);\n\n \nbool drm_edid_is_valid(struct edid *edid)\n{\n\tint i;\n\n\tif (!edid)\n\t\treturn false;\n\n\tfor (i = 0; i < edid_block_count(edid); i++) {\n\t\tvoid *block = (void *)edid_block_data(edid, i);\n\n\t\tif (!drm_edid_block_valid(block, i, true, NULL))\n\t\t\treturn false;\n\t}\n\n\treturn true;\n}\nEXPORT_SYMBOL(drm_edid_is_valid);\n\n \nbool drm_edid_valid(const struct drm_edid *drm_edid)\n{\n\tint i;\n\n\tif (!drm_edid)\n\t\treturn false;\n\n\tif (edid_size_by_blocks(__drm_edid_block_count(drm_edid)) != drm_edid->size)\n\t\treturn false;\n\n\tfor (i = 0; i < drm_edid_block_count(drm_edid); i++) {\n\t\tconst void *block = drm_edid_block_data(drm_edid, i);\n\n\t\tif (!edid_block_valid(block, i == 0))\n\t\t\treturn false;\n\t}\n\n\treturn true;\n}\nEXPORT_SYMBOL(drm_edid_valid);\n\nstatic struct edid *edid_filter_invalid_blocks(struct edid *edid,\n\t\t\t\t\t       size_t *alloc_size)\n{\n\tstruct edid *new;\n\tint i, valid_blocks = 0;\n\n\t \n\tfor (i = 0; i < edid_block_count(edid); i++) {\n\t\tconst void *src_block = edid_block_data(edid, i);\n\n\t\tif (edid_block_valid(src_block, i == 0)) {\n\t\t\tvoid *dst_block = (void *)edid_block_data(edid, valid_blocks);\n\n\t\t\tmemmove(dst_block, src_block, EDID_LENGTH);\n\t\t\tvalid_blocks++;\n\t\t}\n\t}\n\n\t \n\tif (WARN_ON(!valid_blocks)) {\n\t\tkfree(edid);\n\t\treturn NULL;\n\t}\n\n\tedid->extensions = valid_blocks - 1;\n\tedid->checksum = edid_block_compute_checksum(edid);\n\n\t*alloc_size = edid_size_by_blocks(valid_blocks);\n\n\tnew = krealloc(edid, *alloc_size, GFP_KERNEL);\n\tif (!new)\n\t\tkfree(edid);\n\n\treturn new;\n}\n\n#define DDC_SEGMENT_ADDR 0x30\n \nstatic int\ndrm_do_probe_ddc_edid(void *data, u8 *buf, unsigned int block, size_t len)\n{\n\tstruct i2c_adapter *adapter = data;\n\tunsigned char start = block * EDID_LENGTH;\n\tunsigned char segment = block >> 1;\n\tunsigned char xfers = segment ? 3 : 2;\n\tint ret, retries = 5;\n\n\t \n\tdo {\n\t\tstruct i2c_msg msgs[] = {\n\t\t\t{\n\t\t\t\t.addr\t= DDC_SEGMENT_ADDR,\n\t\t\t\t.flags\t= 0,\n\t\t\t\t.len\t= 1,\n\t\t\t\t.buf\t= &segment,\n\t\t\t}, {\n\t\t\t\t.addr\t= DDC_ADDR,\n\t\t\t\t.flags\t= 0,\n\t\t\t\t.len\t= 1,\n\t\t\t\t.buf\t= &start,\n\t\t\t}, {\n\t\t\t\t.addr\t= DDC_ADDR,\n\t\t\t\t.flags\t= I2C_M_RD,\n\t\t\t\t.len\t= len,\n\t\t\t\t.buf\t= buf,\n\t\t\t}\n\t\t};\n\n\t\t \n\t\tret = i2c_transfer(adapter, &msgs[3 - xfers], xfers);\n\n\t\tif (ret == -ENXIO) {\n\t\t\tDRM_DEBUG_KMS(\"drm: skipping non-existent adapter %s\\n\",\n\t\t\t\t\tadapter->name);\n\t\t\tbreak;\n\t\t}\n\t} while (ret != xfers && --retries);\n\n\treturn ret == xfers ? 0 : -1;\n}\n\nstatic void connector_bad_edid(struct drm_connector *connector,\n\t\t\t       const struct edid *edid, int num_blocks)\n{\n\tint i;\n\tu8 last_block;\n\n\t \n\tlast_block = edid->extensions;\n\n\t \n\tif (last_block < num_blocks)\n\t\tconnector->real_edid_checksum =\n\t\t\tedid_block_compute_checksum(edid + last_block);\n\n\tif (connector->bad_edid_counter++ && !drm_debug_enabled(DRM_UT_KMS))\n\t\treturn;\n\n\tdrm_dbg_kms(connector->dev, \"[CONNECTOR:%d:%s] EDID is invalid:\\n\",\n\t\t    connector->base.id, connector->name);\n\tfor (i = 0; i < num_blocks; i++)\n\t\tedid_block_dump(KERN_DEBUG, edid + i, i);\n}\n\n \nstatic const struct drm_edid *drm_edid_override_get(struct drm_connector *connector)\n{\n\tconst struct drm_edid *override = NULL;\n\n\tmutex_lock(&connector->edid_override_mutex);\n\n\tif (connector->edid_override)\n\t\toverride = drm_edid_dup(connector->edid_override);\n\n\tmutex_unlock(&connector->edid_override_mutex);\n\n\tif (!override)\n\t\toverride = drm_edid_load_firmware(connector);\n\n\treturn IS_ERR(override) ? NULL : override;\n}\n\n \nint drm_edid_override_show(struct drm_connector *connector, struct seq_file *m)\n{\n\tconst struct drm_edid *drm_edid;\n\n\tmutex_lock(&connector->edid_override_mutex);\n\n\tdrm_edid = connector->edid_override;\n\tif (drm_edid)\n\t\tseq_write(m, drm_edid->edid, drm_edid->size);\n\n\tmutex_unlock(&connector->edid_override_mutex);\n\n\treturn 0;\n}\n\n \nint drm_edid_override_set(struct drm_connector *connector, const void *edid,\n\t\t\t  size_t size)\n{\n\tconst struct drm_edid *drm_edid;\n\n\tdrm_edid = drm_edid_alloc(edid, size);\n\tif (!drm_edid_valid(drm_edid)) {\n\t\tdrm_dbg_kms(connector->dev, \"[CONNECTOR:%d:%s] EDID override invalid\\n\",\n\t\t\t    connector->base.id, connector->name);\n\t\tdrm_edid_free(drm_edid);\n\t\treturn -EINVAL;\n\t}\n\n\tdrm_dbg_kms(connector->dev, \"[CONNECTOR:%d:%s] EDID override set\\n\",\n\t\t    connector->base.id, connector->name);\n\n\tmutex_lock(&connector->edid_override_mutex);\n\n\tdrm_edid_free(connector->edid_override);\n\tconnector->edid_override = drm_edid;\n\n\tmutex_unlock(&connector->edid_override_mutex);\n\n\treturn 0;\n}\n\n \nint drm_edid_override_reset(struct drm_connector *connector)\n{\n\tdrm_dbg_kms(connector->dev, \"[CONNECTOR:%d:%s] EDID override reset\\n\",\n\t\t    connector->base.id, connector->name);\n\n\tmutex_lock(&connector->edid_override_mutex);\n\n\tdrm_edid_free(connector->edid_override);\n\tconnector->edid_override = NULL;\n\n\tmutex_unlock(&connector->edid_override_mutex);\n\n\treturn 0;\n}\n\n \nint drm_edid_override_connector_update(struct drm_connector *connector)\n{\n\tconst struct drm_edid *override;\n\tint num_modes = 0;\n\n\toverride = drm_edid_override_get(connector);\n\tif (override) {\n\t\tif (drm_edid_connector_update(connector, override) == 0)\n\t\t\tnum_modes = drm_edid_connector_add_modes(connector);\n\n\t\tdrm_edid_free(override);\n\n\t\tdrm_dbg_kms(connector->dev,\n\t\t\t    \"[CONNECTOR:%d:%s] adding %d modes via fallback override/firmware EDID\\n\",\n\t\t\t    connector->base.id, connector->name, num_modes);\n\t}\n\n\treturn num_modes;\n}\nEXPORT_SYMBOL(drm_edid_override_connector_update);\n\ntypedef int read_block_fn(void *context, u8 *buf, unsigned int block, size_t len);\n\nstatic enum edid_block_status edid_block_read(void *block, unsigned int block_num,\n\t\t\t\t\t      read_block_fn read_block,\n\t\t\t\t\t      void *context)\n{\n\tenum edid_block_status status;\n\tbool is_base_block = block_num == 0;\n\tint try;\n\n\tfor (try = 0; try < 4; try++) {\n\t\tif (read_block(context, block, block_num, EDID_LENGTH))\n\t\t\treturn EDID_BLOCK_READ_FAIL;\n\n\t\tstatus = edid_block_check(block, is_base_block);\n\t\tif (status == EDID_BLOCK_HEADER_REPAIR) {\n\t\t\tedid_header_fix(block);\n\n\t\t\t \n\t\t\tstatus = edid_block_check(block, is_base_block);\n\t\t\tif (status == EDID_BLOCK_OK)\n\t\t\t\tstatus = EDID_BLOCK_HEADER_FIXED;\n\t\t}\n\n\t\tif (edid_block_status_valid(status, edid_block_tag(block)))\n\t\t\tbreak;\n\n\t\t \n\t\tif (try == 0 && is_base_block && status == EDID_BLOCK_ZERO)\n\t\t\tbreak;\n\t}\n\n\treturn status;\n}\n\nstatic struct edid *_drm_do_get_edid(struct drm_connector *connector,\n\t\t\t\t     read_block_fn read_block, void *context,\n\t\t\t\t     size_t *size)\n{\n\tenum edid_block_status status;\n\tint i, num_blocks, invalid_blocks = 0;\n\tconst struct drm_edid *override;\n\tstruct edid *edid, *new;\n\tsize_t alloc_size = EDID_LENGTH;\n\n\toverride = drm_edid_override_get(connector);\n\tif (override) {\n\t\talloc_size = override->size;\n\t\tedid = kmemdup(override->edid, alloc_size, GFP_KERNEL);\n\t\tdrm_edid_free(override);\n\t\tif (!edid)\n\t\t\treturn NULL;\n\t\tgoto ok;\n\t}\n\n\tedid = kmalloc(alloc_size, GFP_KERNEL);\n\tif (!edid)\n\t\treturn NULL;\n\n\tstatus = edid_block_read(edid, 0, read_block, context);\n\n\tedid_block_status_print(status, edid, 0);\n\n\tif (status == EDID_BLOCK_READ_FAIL)\n\t\tgoto fail;\n\n\t \n\tif (status == EDID_BLOCK_OK || status == EDID_BLOCK_VERSION)\n\t\tconnector->edid_corrupt = false;\n\telse\n\t\tconnector->edid_corrupt = true;\n\n\tif (!edid_block_status_valid(status, edid_block_tag(edid))) {\n\t\tif (status == EDID_BLOCK_ZERO)\n\t\t\tconnector->null_edid_counter++;\n\n\t\tconnector_bad_edid(connector, edid, 1);\n\t\tgoto fail;\n\t}\n\n\tif (!edid_extension_block_count(edid))\n\t\tgoto ok;\n\n\talloc_size = edid_size(edid);\n\tnew = krealloc(edid, alloc_size, GFP_KERNEL);\n\tif (!new)\n\t\tgoto fail;\n\tedid = new;\n\n\tnum_blocks = edid_block_count(edid);\n\tfor (i = 1; i < num_blocks; i++) {\n\t\tvoid *block = (void *)edid_block_data(edid, i);\n\n\t\tstatus = edid_block_read(block, i, read_block, context);\n\n\t\tedid_block_status_print(status, block, i);\n\n\t\tif (!edid_block_status_valid(status, edid_block_tag(block))) {\n\t\t\tif (status == EDID_BLOCK_READ_FAIL)\n\t\t\t\tgoto fail;\n\t\t\tinvalid_blocks++;\n\t\t} else if (i == 1) {\n\t\t\t \n\t\t\tint eeodb = edid_hfeeodb_block_count(edid);\n\n\t\t\tif (eeodb > num_blocks) {\n\t\t\t\tnum_blocks = eeodb;\n\t\t\t\talloc_size = edid_size_by_blocks(num_blocks);\n\t\t\t\tnew = krealloc(edid, alloc_size, GFP_KERNEL);\n\t\t\t\tif (!new)\n\t\t\t\t\tgoto fail;\n\t\t\t\tedid = new;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (invalid_blocks) {\n\t\tconnector_bad_edid(connector, edid, num_blocks);\n\n\t\tedid = edid_filter_invalid_blocks(edid, &alloc_size);\n\t}\n\nok:\n\tif (size)\n\t\t*size = alloc_size;\n\n\treturn edid;\n\nfail:\n\tkfree(edid);\n\treturn NULL;\n}\n\n \nstruct edid *drm_do_get_edid(struct drm_connector *connector,\n\t\t\t     read_block_fn read_block,\n\t\t\t     void *context)\n{\n\treturn _drm_do_get_edid(connector, read_block, context, NULL);\n}\nEXPORT_SYMBOL_GPL(drm_do_get_edid);\n\n \nconst struct edid *drm_edid_raw(const struct drm_edid *drm_edid)\n{\n\tif (!drm_edid || !drm_edid->size)\n\t\treturn NULL;\n\n\t \n\tif (WARN_ON(edid_size(drm_edid->edid) > drm_edid->size))\n\t\treturn NULL;\n\n\treturn drm_edid->edid;\n}\nEXPORT_SYMBOL(drm_edid_raw);\n\n \nstatic const struct drm_edid *_drm_edid_alloc(const void *edid, size_t size)\n{\n\tstruct drm_edid *drm_edid;\n\n\tif (!edid || !size || size < EDID_LENGTH)\n\t\treturn NULL;\n\n\tdrm_edid = kzalloc(sizeof(*drm_edid), GFP_KERNEL);\n\tif (drm_edid) {\n\t\tdrm_edid->edid = edid;\n\t\tdrm_edid->size = size;\n\t}\n\n\treturn drm_edid;\n}\n\n \nconst struct drm_edid *drm_edid_alloc(const void *edid, size_t size)\n{\n\tconst struct drm_edid *drm_edid;\n\n\tif (!edid || !size || size < EDID_LENGTH)\n\t\treturn NULL;\n\n\tedid = kmemdup(edid, size, GFP_KERNEL);\n\tif (!edid)\n\t\treturn NULL;\n\n\tdrm_edid = _drm_edid_alloc(edid, size);\n\tif (!drm_edid)\n\t\tkfree(edid);\n\n\treturn drm_edid;\n}\nEXPORT_SYMBOL(drm_edid_alloc);\n\n \nconst struct drm_edid *drm_edid_dup(const struct drm_edid *drm_edid)\n{\n\tif (!drm_edid)\n\t\treturn NULL;\n\n\treturn drm_edid_alloc(drm_edid->edid, drm_edid->size);\n}\nEXPORT_SYMBOL(drm_edid_dup);\n\n \nvoid drm_edid_free(const struct drm_edid *drm_edid)\n{\n\tif (!drm_edid)\n\t\treturn;\n\n\tkfree(drm_edid->edid);\n\tkfree(drm_edid);\n}\nEXPORT_SYMBOL(drm_edid_free);\n\n \nbool\ndrm_probe_ddc(struct i2c_adapter *adapter)\n{\n\tunsigned char out;\n\n\treturn (drm_do_probe_ddc_edid(adapter, &out, 0, 1) == 0);\n}\nEXPORT_SYMBOL(drm_probe_ddc);\n\n \nstruct edid *drm_get_edid(struct drm_connector *connector,\n\t\t\t  struct i2c_adapter *adapter)\n{\n\tstruct edid *edid;\n\n\tif (connector->force == DRM_FORCE_OFF)\n\t\treturn NULL;\n\n\tif (connector->force == DRM_FORCE_UNSPECIFIED && !drm_probe_ddc(adapter))\n\t\treturn NULL;\n\n\tedid = _drm_do_get_edid(connector, drm_do_probe_ddc_edid, adapter, NULL);\n\tdrm_connector_update_edid_property(connector, edid);\n\treturn edid;\n}\nEXPORT_SYMBOL(drm_get_edid);\n\n \nconst struct drm_edid *drm_edid_read_custom(struct drm_connector *connector,\n\t\t\t\t\t    read_block_fn read_block,\n\t\t\t\t\t    void *context)\n{\n\tconst struct drm_edid *drm_edid;\n\tstruct edid *edid;\n\tsize_t size = 0;\n\n\tedid = _drm_do_get_edid(connector, read_block, context, &size);\n\tif (!edid)\n\t\treturn NULL;\n\n\t \n\tdrm_WARN_ON(connector->dev, !size);\n\n\tdrm_edid = _drm_edid_alloc(edid, size);\n\tif (!drm_edid)\n\t\tkfree(edid);\n\n\treturn drm_edid;\n}\nEXPORT_SYMBOL(drm_edid_read_custom);\n\n \nconst struct drm_edid *drm_edid_read_ddc(struct drm_connector *connector,\n\t\t\t\t\t struct i2c_adapter *adapter)\n{\n\tconst struct drm_edid *drm_edid;\n\n\tif (connector->force == DRM_FORCE_OFF)\n\t\treturn NULL;\n\n\tif (connector->force == DRM_FORCE_UNSPECIFIED && !drm_probe_ddc(adapter))\n\t\treturn NULL;\n\n\tdrm_edid = drm_edid_read_custom(connector, drm_do_probe_ddc_edid, adapter);\n\n\t \n\n\treturn drm_edid;\n}\nEXPORT_SYMBOL(drm_edid_read_ddc);\n\n \nconst struct drm_edid *drm_edid_read(struct drm_connector *connector)\n{\n\tif (drm_WARN_ON(connector->dev, !connector->ddc))\n\t\treturn NULL;\n\n\treturn drm_edid_read_ddc(connector, connector->ddc);\n}\nEXPORT_SYMBOL(drm_edid_read);\n\nstatic u32 edid_extract_panel_id(const struct edid *edid)\n{\n\t \n\treturn (u32)edid->mfg_id[0] << 24   |\n\t       (u32)edid->mfg_id[1] << 16   |\n\t       (u32)EDID_PRODUCT_ID(edid);\n}\n\n \n\nu32 drm_edid_get_panel_id(struct i2c_adapter *adapter)\n{\n\tenum edid_block_status status;\n\tvoid *base_block;\n\tu32 panel_id = 0;\n\n\t \n\n\tbase_block = kzalloc(EDID_LENGTH, GFP_KERNEL);\n\tif (!base_block)\n\t\treturn 0;\n\n\tstatus = edid_block_read(base_block, 0, drm_do_probe_ddc_edid, adapter);\n\n\tedid_block_status_print(status, base_block, 0);\n\n\tif (edid_block_status_valid(status, edid_block_tag(base_block)))\n\t\tpanel_id = edid_extract_panel_id(base_block);\n\telse\n\t\tedid_block_dump(KERN_NOTICE, base_block, 0);\n\n\tkfree(base_block);\n\n\treturn panel_id;\n}\nEXPORT_SYMBOL(drm_edid_get_panel_id);\n\n \nstruct edid *drm_get_edid_switcheroo(struct drm_connector *connector,\n\t\t\t\t     struct i2c_adapter *adapter)\n{\n\tstruct drm_device *dev = connector->dev;\n\tstruct pci_dev *pdev = to_pci_dev(dev->dev);\n\tstruct edid *edid;\n\n\tif (drm_WARN_ON_ONCE(dev, !dev_is_pci(dev->dev)))\n\t\treturn NULL;\n\n\tvga_switcheroo_lock_ddc(pdev);\n\tedid = drm_get_edid(connector, adapter);\n\tvga_switcheroo_unlock_ddc(pdev);\n\n\treturn edid;\n}\nEXPORT_SYMBOL(drm_get_edid_switcheroo);\n\n \nconst struct drm_edid *drm_edid_read_switcheroo(struct drm_connector *connector,\n\t\t\t\t\t\tstruct i2c_adapter *adapter)\n{\n\tstruct drm_device *dev = connector->dev;\n\tstruct pci_dev *pdev = to_pci_dev(dev->dev);\n\tconst struct drm_edid *drm_edid;\n\n\tif (drm_WARN_ON_ONCE(dev, !dev_is_pci(dev->dev)))\n\t\treturn NULL;\n\n\tvga_switcheroo_lock_ddc(pdev);\n\tdrm_edid = drm_edid_read_ddc(connector, adapter);\n\tvga_switcheroo_unlock_ddc(pdev);\n\n\treturn drm_edid;\n}\nEXPORT_SYMBOL(drm_edid_read_switcheroo);\n\n \nstruct edid *drm_edid_duplicate(const struct edid *edid)\n{\n\tif (!edid)\n\t\treturn NULL;\n\n\treturn kmemdup(edid, edid_size(edid), GFP_KERNEL);\n}\nEXPORT_SYMBOL(drm_edid_duplicate);\n\n \n\n \nstatic u32 edid_get_quirks(const struct drm_edid *drm_edid)\n{\n\tu32 panel_id = edid_extract_panel_id(drm_edid->edid);\n\tconst struct edid_quirk *quirk;\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(edid_quirk_list); i++) {\n\t\tquirk = &edid_quirk_list[i];\n\t\tif (quirk->panel_id == panel_id)\n\t\t\treturn quirk->quirks;\n\t}\n\n\treturn 0;\n}\n\n#define MODE_SIZE(m) ((m)->hdisplay * (m)->vdisplay)\n#define MODE_REFRESH_DIFF(c,t) (abs((c) - (t)))\n\n \nstatic void edid_fixup_preferred(struct drm_connector *connector)\n{\n\tconst struct drm_display_info *info = &connector->display_info;\n\tstruct drm_display_mode *t, *cur_mode, *preferred_mode;\n\tint target_refresh = 0;\n\tint cur_vrefresh, preferred_vrefresh;\n\n\tif (list_empty(&connector->probed_modes))\n\t\treturn;\n\n\tif (info->quirks & EDID_QUIRK_PREFER_LARGE_60)\n\t\ttarget_refresh = 60;\n\tif (info->quirks & EDID_QUIRK_PREFER_LARGE_75)\n\t\ttarget_refresh = 75;\n\n\tpreferred_mode = list_first_entry(&connector->probed_modes,\n\t\t\t\t\t  struct drm_display_mode, head);\n\n\tlist_for_each_entry_safe(cur_mode, t, &connector->probed_modes, head) {\n\t\tcur_mode->type &= ~DRM_MODE_TYPE_PREFERRED;\n\n\t\tif (cur_mode == preferred_mode)\n\t\t\tcontinue;\n\n\t\t \n\t\tif (MODE_SIZE(cur_mode) > MODE_SIZE(preferred_mode))\n\t\t\tpreferred_mode = cur_mode;\n\n\t\tcur_vrefresh = drm_mode_vrefresh(cur_mode);\n\t\tpreferred_vrefresh = drm_mode_vrefresh(preferred_mode);\n\t\t \n\t\tif ((MODE_SIZE(cur_mode) == MODE_SIZE(preferred_mode)) &&\n\t\t    MODE_REFRESH_DIFF(cur_vrefresh, target_refresh) <\n\t\t    MODE_REFRESH_DIFF(preferred_vrefresh, target_refresh)) {\n\t\t\tpreferred_mode = cur_mode;\n\t\t}\n\t}\n\n\tpreferred_mode->type |= DRM_MODE_TYPE_PREFERRED;\n}\n\nstatic bool\nmode_is_rb(const struct drm_display_mode *mode)\n{\n\treturn (mode->htotal - mode->hdisplay == 160) &&\n\t       (mode->hsync_end - mode->hdisplay == 80) &&\n\t       (mode->hsync_end - mode->hsync_start == 32) &&\n\t       (mode->vsync_start - mode->vdisplay == 3);\n}\n\n \nstruct drm_display_mode *drm_mode_find_dmt(struct drm_device *dev,\n\t\t\t\t\t   int hsize, int vsize, int fresh,\n\t\t\t\t\t   bool rb)\n{\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(drm_dmt_modes); i++) {\n\t\tconst struct drm_display_mode *ptr = &drm_dmt_modes[i];\n\n\t\tif (hsize != ptr->hdisplay)\n\t\t\tcontinue;\n\t\tif (vsize != ptr->vdisplay)\n\t\t\tcontinue;\n\t\tif (fresh != drm_mode_vrefresh(ptr))\n\t\t\tcontinue;\n\t\tif (rb != mode_is_rb(ptr))\n\t\t\tcontinue;\n\n\t\treturn drm_mode_duplicate(dev, ptr);\n\t}\n\n\treturn NULL;\n}\nEXPORT_SYMBOL(drm_mode_find_dmt);\n\nstatic bool is_display_descriptor(const struct detailed_timing *descriptor, u8 type)\n{\n\tBUILD_BUG_ON(offsetof(typeof(*descriptor), pixel_clock) != 0);\n\tBUILD_BUG_ON(offsetof(typeof(*descriptor), data.other_data.pad1) != 2);\n\tBUILD_BUG_ON(offsetof(typeof(*descriptor), data.other_data.type) != 3);\n\n\treturn descriptor->pixel_clock == 0 &&\n\t\tdescriptor->data.other_data.pad1 == 0 &&\n\t\tdescriptor->data.other_data.type == type;\n}\n\nstatic bool is_detailed_timing_descriptor(const struct detailed_timing *descriptor)\n{\n\tBUILD_BUG_ON(offsetof(typeof(*descriptor), pixel_clock) != 0);\n\n\treturn descriptor->pixel_clock != 0;\n}\n\ntypedef void detailed_cb(const struct detailed_timing *timing, void *closure);\n\nstatic void\ncea_for_each_detailed_block(const u8 *ext, detailed_cb *cb, void *closure)\n{\n\tint i, n;\n\tu8 d = ext[0x02];\n\tconst u8 *det_base = ext + d;\n\n\tif (d < 4 || d > 127)\n\t\treturn;\n\n\tn = (127 - d) / 18;\n\tfor (i = 0; i < n; i++)\n\t\tcb((const struct detailed_timing *)(det_base + 18 * i), closure);\n}\n\nstatic void\nvtb_for_each_detailed_block(const u8 *ext, detailed_cb *cb, void *closure)\n{\n\tunsigned int i, n = min((int)ext[0x02], 6);\n\tconst u8 *det_base = ext + 5;\n\n\tif (ext[0x01] != 1)\n\t\treturn;  \n\n\tfor (i = 0; i < n; i++)\n\t\tcb((const struct detailed_timing *)(det_base + 18 * i), closure);\n}\n\nstatic void drm_for_each_detailed_block(const struct drm_edid *drm_edid,\n\t\t\t\t\tdetailed_cb *cb, void *closure)\n{\n\tstruct drm_edid_iter edid_iter;\n\tconst u8 *ext;\n\tint i;\n\n\tif (!drm_edid)\n\t\treturn;\n\n\tfor (i = 0; i < EDID_DETAILED_TIMINGS; i++)\n\t\tcb(&drm_edid->edid->detailed_timings[i], closure);\n\n\tdrm_edid_iter_begin(drm_edid, &edid_iter);\n\tdrm_edid_iter_for_each(ext, &edid_iter) {\n\t\tswitch (*ext) {\n\t\tcase CEA_EXT:\n\t\t\tcea_for_each_detailed_block(ext, cb, closure);\n\t\t\tbreak;\n\t\tcase VTB_EXT:\n\t\t\tvtb_for_each_detailed_block(ext, cb, closure);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\tdrm_edid_iter_end(&edid_iter);\n}\n\nstatic void\nis_rb(const struct detailed_timing *descriptor, void *data)\n{\n\tbool *res = data;\n\n\tif (!is_display_descriptor(descriptor, EDID_DETAIL_MONITOR_RANGE))\n\t\treturn;\n\n\tBUILD_BUG_ON(offsetof(typeof(*descriptor), data.other_data.data.range.flags) != 10);\n\tBUILD_BUG_ON(offsetof(typeof(*descriptor), data.other_data.data.range.formula.cvt.flags) != 15);\n\n\tif (descriptor->data.other_data.data.range.flags == DRM_EDID_CVT_SUPPORT_FLAG &&\n\t    descriptor->data.other_data.data.range.formula.cvt.flags & DRM_EDID_CVT_FLAGS_REDUCED_BLANKING)\n\t\t*res = true;\n}\n\n \nstatic bool\ndrm_monitor_supports_rb(const struct drm_edid *drm_edid)\n{\n\tif (drm_edid->edid->revision >= 4) {\n\t\tbool ret = false;\n\n\t\tdrm_for_each_detailed_block(drm_edid, is_rb, &ret);\n\t\treturn ret;\n\t}\n\n\treturn ((drm_edid->edid->input & DRM_EDID_INPUT_DIGITAL) != 0);\n}\n\nstatic void\nfind_gtf2(const struct detailed_timing *descriptor, void *data)\n{\n\tconst struct detailed_timing **res = data;\n\n\tif (!is_display_descriptor(descriptor, EDID_DETAIL_MONITOR_RANGE))\n\t\treturn;\n\n\tBUILD_BUG_ON(offsetof(typeof(*descriptor), data.other_data.data.range.flags) != 10);\n\n\tif (descriptor->data.other_data.data.range.flags == DRM_EDID_SECONDARY_GTF_SUPPORT_FLAG)\n\t\t*res = descriptor;\n}\n\n \nstatic int\ndrm_gtf2_hbreak(const struct drm_edid *drm_edid)\n{\n\tconst struct detailed_timing *descriptor = NULL;\n\n\tdrm_for_each_detailed_block(drm_edid, find_gtf2, &descriptor);\n\n\tBUILD_BUG_ON(offsetof(typeof(*descriptor), data.other_data.data.range.formula.gtf2.hfreq_start_khz) != 12);\n\n\treturn descriptor ? descriptor->data.other_data.data.range.formula.gtf2.hfreq_start_khz * 2 : 0;\n}\n\nstatic int\ndrm_gtf2_2c(const struct drm_edid *drm_edid)\n{\n\tconst struct detailed_timing *descriptor = NULL;\n\n\tdrm_for_each_detailed_block(drm_edid, find_gtf2, &descriptor);\n\n\tBUILD_BUG_ON(offsetof(typeof(*descriptor), data.other_data.data.range.formula.gtf2.c) != 13);\n\n\treturn descriptor ? descriptor->data.other_data.data.range.formula.gtf2.c : 0;\n}\n\nstatic int\ndrm_gtf2_m(const struct drm_edid *drm_edid)\n{\n\tconst struct detailed_timing *descriptor = NULL;\n\n\tdrm_for_each_detailed_block(drm_edid, find_gtf2, &descriptor);\n\n\tBUILD_BUG_ON(offsetof(typeof(*descriptor), data.other_data.data.range.formula.gtf2.m) != 14);\n\n\treturn descriptor ? le16_to_cpu(descriptor->data.other_data.data.range.formula.gtf2.m) : 0;\n}\n\nstatic int\ndrm_gtf2_k(const struct drm_edid *drm_edid)\n{\n\tconst struct detailed_timing *descriptor = NULL;\n\n\tdrm_for_each_detailed_block(drm_edid, find_gtf2, &descriptor);\n\n\tBUILD_BUG_ON(offsetof(typeof(*descriptor), data.other_data.data.range.formula.gtf2.k) != 16);\n\n\treturn descriptor ? descriptor->data.other_data.data.range.formula.gtf2.k : 0;\n}\n\nstatic int\ndrm_gtf2_2j(const struct drm_edid *drm_edid)\n{\n\tconst struct detailed_timing *descriptor = NULL;\n\n\tdrm_for_each_detailed_block(drm_edid, find_gtf2, &descriptor);\n\n\tBUILD_BUG_ON(offsetof(typeof(*descriptor), data.other_data.data.range.formula.gtf2.j) != 17);\n\n\treturn descriptor ? descriptor->data.other_data.data.range.formula.gtf2.j : 0;\n}\n\nstatic void\nget_timing_level(const struct detailed_timing *descriptor, void *data)\n{\n\tint *res = data;\n\n\tif (!is_display_descriptor(descriptor, EDID_DETAIL_MONITOR_RANGE))\n\t\treturn;\n\n\tBUILD_BUG_ON(offsetof(typeof(*descriptor), data.other_data.data.range.flags) != 10);\n\n\tswitch (descriptor->data.other_data.data.range.flags) {\n\tcase DRM_EDID_DEFAULT_GTF_SUPPORT_FLAG:\n\t\t*res = LEVEL_GTF;\n\t\tbreak;\n\tcase DRM_EDID_SECONDARY_GTF_SUPPORT_FLAG:\n\t\t*res = LEVEL_GTF2;\n\t\tbreak;\n\tcase DRM_EDID_CVT_SUPPORT_FLAG:\n\t\t*res = LEVEL_CVT;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}\n\n \nstatic int standard_timing_level(const struct drm_edid *drm_edid)\n{\n\tconst struct edid *edid = drm_edid->edid;\n\n\tif (edid->revision >= 4) {\n\t\t \n\t\tint ret = LEVEL_CVT;\n\n\t\tdrm_for_each_detailed_block(drm_edid, get_timing_level, &ret);\n\n\t\treturn ret;\n\t} else if (edid->revision >= 3 && drm_gtf2_hbreak(drm_edid)) {\n\t\treturn LEVEL_GTF2;\n\t} else if (edid->revision >= 2) {\n\t\treturn LEVEL_GTF;\n\t} else {\n\t\treturn LEVEL_DMT;\n\t}\n}\n\n \nstatic int\nbad_std_timing(u8 a, u8 b)\n{\n\treturn (a == 0x00 && b == 0x00) ||\n\t       (a == 0x01 && b == 0x01) ||\n\t       (a == 0x20 && b == 0x20);\n}\n\nstatic int drm_mode_hsync(const struct drm_display_mode *mode)\n{\n\tif (mode->htotal <= 0)\n\t\treturn 0;\n\n\treturn DIV_ROUND_CLOSEST(mode->clock, mode->htotal);\n}\n\nstatic struct drm_display_mode *\ndrm_gtf2_mode(struct drm_device *dev,\n\t      const struct drm_edid *drm_edid,\n\t      int hsize, int vsize, int vrefresh_rate)\n{\n\tstruct drm_display_mode *mode;\n\n\t \n\tmode = drm_gtf_mode(dev, hsize, vsize, vrefresh_rate, 0, 0);\n\tif (!mode)\n\t\treturn NULL;\n\n\tif (drm_mode_hsync(mode) > drm_gtf2_hbreak(drm_edid)) {\n\t\tdrm_mode_destroy(dev, mode);\n\t\tmode = drm_gtf_mode_complex(dev, hsize, vsize,\n\t\t\t\t\t    vrefresh_rate, 0, 0,\n\t\t\t\t\t    drm_gtf2_m(drm_edid),\n\t\t\t\t\t    drm_gtf2_2c(drm_edid),\n\t\t\t\t\t    drm_gtf2_k(drm_edid),\n\t\t\t\t\t    drm_gtf2_2j(drm_edid));\n\t}\n\n\treturn mode;\n}\n\n \nstatic struct drm_display_mode *drm_mode_std(struct drm_connector *connector,\n\t\t\t\t\t     const struct drm_edid *drm_edid,\n\t\t\t\t\t     const struct std_timing *t)\n{\n\tstruct drm_device *dev = connector->dev;\n\tstruct drm_display_mode *m, *mode = NULL;\n\tint hsize, vsize;\n\tint vrefresh_rate;\n\tunsigned aspect_ratio = (t->vfreq_aspect & EDID_TIMING_ASPECT_MASK)\n\t\t>> EDID_TIMING_ASPECT_SHIFT;\n\tunsigned vfreq = (t->vfreq_aspect & EDID_TIMING_VFREQ_MASK)\n\t\t>> EDID_TIMING_VFREQ_SHIFT;\n\tint timing_level = standard_timing_level(drm_edid);\n\n\tif (bad_std_timing(t->hsize, t->vfreq_aspect))\n\t\treturn NULL;\n\n\t \n\thsize = t->hsize * 8 + 248;\n\t \n\tvrefresh_rate = vfreq + 60;\n\t \n\tif (aspect_ratio == 0) {\n\t\tif (drm_edid->edid->revision < 3)\n\t\t\tvsize = hsize;\n\t\telse\n\t\t\tvsize = (hsize * 10) / 16;\n\t} else if (aspect_ratio == 1)\n\t\tvsize = (hsize * 3) / 4;\n\telse if (aspect_ratio == 2)\n\t\tvsize = (hsize * 4) / 5;\n\telse\n\t\tvsize = (hsize * 9) / 16;\n\n\t \n\tif (vrefresh_rate == 60 &&\n\t    ((hsize == 1360 && vsize == 765) ||\n\t     (hsize == 1368 && vsize == 769))) {\n\t\thsize = 1366;\n\t\tvsize = 768;\n\t}\n\n\t \n\tlist_for_each_entry(m, &connector->probed_modes, head)\n\t\tif (m->hdisplay == hsize && m->vdisplay == vsize &&\n\t\t    drm_mode_vrefresh(m) == vrefresh_rate)\n\t\t\treturn NULL;\n\n\t \n\tif (hsize == 1366 && vsize == 768 && vrefresh_rate == 60) {\n\t\tmode = drm_cvt_mode(dev, 1366, 768, vrefresh_rate, 0, 0,\n\t\t\t\t    false);\n\t\tif (!mode)\n\t\t\treturn NULL;\n\t\tmode->hdisplay = 1366;\n\t\tmode->hsync_start = mode->hsync_start - 1;\n\t\tmode->hsync_end = mode->hsync_end - 1;\n\t\treturn mode;\n\t}\n\n\t \n\tif (drm_monitor_supports_rb(drm_edid)) {\n\t\tmode = drm_mode_find_dmt(dev, hsize, vsize, vrefresh_rate,\n\t\t\t\t\t true);\n\t\tif (mode)\n\t\t\treturn mode;\n\t}\n\tmode = drm_mode_find_dmt(dev, hsize, vsize, vrefresh_rate, false);\n\tif (mode)\n\t\treturn mode;\n\n\t \n\tswitch (timing_level) {\n\tcase LEVEL_DMT:\n\t\tbreak;\n\tcase LEVEL_GTF:\n\t\tmode = drm_gtf_mode(dev, hsize, vsize, vrefresh_rate, 0, 0);\n\t\tbreak;\n\tcase LEVEL_GTF2:\n\t\tmode = drm_gtf2_mode(dev, drm_edid, hsize, vsize, vrefresh_rate);\n\t\tbreak;\n\tcase LEVEL_CVT:\n\t\tmode = drm_cvt_mode(dev, hsize, vsize, vrefresh_rate, 0, 0,\n\t\t\t\t    false);\n\t\tbreak;\n\t}\n\treturn mode;\n}\n\n \nstatic void\ndrm_mode_do_interlace_quirk(struct drm_display_mode *mode,\n\t\t\t    const struct detailed_pixel_timing *pt)\n{\n\tint i;\n\tstatic const struct {\n\t\tint w, h;\n\t} cea_interlaced[] = {\n\t\t{ 1920, 1080 },\n\t\t{  720,  480 },\n\t\t{ 1440,  480 },\n\t\t{ 2880,  480 },\n\t\t{  720,  576 },\n\t\t{ 1440,  576 },\n\t\t{ 2880,  576 },\n\t};\n\n\tif (!(pt->misc & DRM_EDID_PT_INTERLACED))\n\t\treturn;\n\n\tfor (i = 0; i < ARRAY_SIZE(cea_interlaced); i++) {\n\t\tif ((mode->hdisplay == cea_interlaced[i].w) &&\n\t\t    (mode->vdisplay == cea_interlaced[i].h / 2)) {\n\t\t\tmode->vdisplay *= 2;\n\t\t\tmode->vsync_start *= 2;\n\t\t\tmode->vsync_end *= 2;\n\t\t\tmode->vtotal *= 2;\n\t\t\tmode->vtotal |= 1;\n\t\t}\n\t}\n\n\tmode->flags |= DRM_MODE_FLAG_INTERLACE;\n}\n\n \nstatic struct drm_display_mode *drm_mode_detailed(struct drm_connector *connector,\n\t\t\t\t\t\t  const struct drm_edid *drm_edid,\n\t\t\t\t\t\t  const struct detailed_timing *timing)\n{\n\tconst struct drm_display_info *info = &connector->display_info;\n\tstruct drm_device *dev = connector->dev;\n\tstruct drm_display_mode *mode;\n\tconst struct detailed_pixel_timing *pt = &timing->data.pixel_data;\n\tunsigned hactive = (pt->hactive_hblank_hi & 0xf0) << 4 | pt->hactive_lo;\n\tunsigned vactive = (pt->vactive_vblank_hi & 0xf0) << 4 | pt->vactive_lo;\n\tunsigned hblank = (pt->hactive_hblank_hi & 0xf) << 8 | pt->hblank_lo;\n\tunsigned vblank = (pt->vactive_vblank_hi & 0xf) << 8 | pt->vblank_lo;\n\tunsigned hsync_offset = (pt->hsync_vsync_offset_pulse_width_hi & 0xc0) << 2 | pt->hsync_offset_lo;\n\tunsigned hsync_pulse_width = (pt->hsync_vsync_offset_pulse_width_hi & 0x30) << 4 | pt->hsync_pulse_width_lo;\n\tunsigned vsync_offset = (pt->hsync_vsync_offset_pulse_width_hi & 0xc) << 2 | pt->vsync_offset_pulse_width_lo >> 4;\n\tunsigned vsync_pulse_width = (pt->hsync_vsync_offset_pulse_width_hi & 0x3) << 4 | (pt->vsync_offset_pulse_width_lo & 0xf);\n\n\t \n\tif (hactive < 64 || vactive < 64)\n\t\treturn NULL;\n\n\tif (pt->misc & DRM_EDID_PT_STEREO) {\n\t\tdrm_dbg_kms(dev, \"[CONNECTOR:%d:%s] Stereo mode not supported\\n\",\n\t\t\t    connector->base.id, connector->name);\n\t\treturn NULL;\n\t}\n\tif (!(pt->misc & DRM_EDID_PT_SEPARATE_SYNC)) {\n\t\tdrm_dbg_kms(dev, \"[CONNECTOR:%d:%s] Composite sync not supported\\n\",\n\t\t\t    connector->base.id, connector->name);\n\t}\n\n\t \n\tif (!hsync_pulse_width || !vsync_pulse_width) {\n\t\tdrm_dbg_kms(dev, \"[CONNECTOR:%d:%s] Incorrect Detailed timing. Wrong Hsync/Vsync pulse width\\n\",\n\t\t\t    connector->base.id, connector->name);\n\t\treturn NULL;\n\t}\n\n\tif (info->quirks & EDID_QUIRK_FORCE_REDUCED_BLANKING) {\n\t\tmode = drm_cvt_mode(dev, hactive, vactive, 60, true, false, false);\n\t\tif (!mode)\n\t\t\treturn NULL;\n\n\t\tgoto set_size;\n\t}\n\n\tmode = drm_mode_create(dev);\n\tif (!mode)\n\t\treturn NULL;\n\n\tif (info->quirks & EDID_QUIRK_135_CLOCK_TOO_HIGH)\n\t\tmode->clock = 1088 * 10;\n\telse\n\t\tmode->clock = le16_to_cpu(timing->pixel_clock) * 10;\n\n\tmode->hdisplay = hactive;\n\tmode->hsync_start = mode->hdisplay + hsync_offset;\n\tmode->hsync_end = mode->hsync_start + hsync_pulse_width;\n\tmode->htotal = mode->hdisplay + hblank;\n\n\tmode->vdisplay = vactive;\n\tmode->vsync_start = mode->vdisplay + vsync_offset;\n\tmode->vsync_end = mode->vsync_start + vsync_pulse_width;\n\tmode->vtotal = mode->vdisplay + vblank;\n\n\t \n\tif (mode->hsync_end > mode->htotal) {\n\t\tdrm_dbg_kms(dev, \"[CONNECTOR:%d:%s] reducing hsync_end %d->%d\\n\",\n\t\t\t    connector->base.id, connector->name,\n\t\t\t    mode->hsync_end, mode->htotal);\n\t\tmode->hsync_end = mode->htotal;\n\t}\n\tif (mode->vsync_end > mode->vtotal) {\n\t\tdrm_dbg_kms(dev, \"[CONNECTOR:%d:%s] reducing vsync_end %d->%d\\n\",\n\t\t\t    connector->base.id, connector->name,\n\t\t\t    mode->vsync_end, mode->vtotal);\n\t\tmode->vsync_end = mode->vtotal;\n\t}\n\n\tdrm_mode_do_interlace_quirk(mode, pt);\n\n\tif (info->quirks & EDID_QUIRK_DETAILED_SYNC_PP) {\n\t\tmode->flags |= DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC;\n\t} else {\n\t\tmode->flags |= (pt->misc & DRM_EDID_PT_HSYNC_POSITIVE) ?\n\t\t\tDRM_MODE_FLAG_PHSYNC : DRM_MODE_FLAG_NHSYNC;\n\t\tmode->flags |= (pt->misc & DRM_EDID_PT_VSYNC_POSITIVE) ?\n\t\t\tDRM_MODE_FLAG_PVSYNC : DRM_MODE_FLAG_NVSYNC;\n\t}\n\nset_size:\n\tmode->width_mm = pt->width_mm_lo | (pt->width_height_mm_hi & 0xf0) << 4;\n\tmode->height_mm = pt->height_mm_lo | (pt->width_height_mm_hi & 0xf) << 8;\n\n\tif (info->quirks & EDID_QUIRK_DETAILED_IN_CM) {\n\t\tmode->width_mm *= 10;\n\t\tmode->height_mm *= 10;\n\t}\n\n\tif (info->quirks & EDID_QUIRK_DETAILED_USE_MAXIMUM_SIZE) {\n\t\tmode->width_mm = drm_edid->edid->width_cm * 10;\n\t\tmode->height_mm = drm_edid->edid->height_cm * 10;\n\t}\n\n\tmode->type = DRM_MODE_TYPE_DRIVER;\n\tdrm_mode_set_name(mode);\n\n\treturn mode;\n}\n\nstatic bool\nmode_in_hsync_range(const struct drm_display_mode *mode,\n\t\t    const struct edid *edid, const u8 *t)\n{\n\tint hsync, hmin, hmax;\n\n\thmin = t[7];\n\tif (edid->revision >= 4)\n\t    hmin += ((t[4] & 0x04) ? 255 : 0);\n\thmax = t[8];\n\tif (edid->revision >= 4)\n\t    hmax += ((t[4] & 0x08) ? 255 : 0);\n\thsync = drm_mode_hsync(mode);\n\n\treturn (hsync <= hmax && hsync >= hmin);\n}\n\nstatic bool\nmode_in_vsync_range(const struct drm_display_mode *mode,\n\t\t    const struct edid *edid, const u8 *t)\n{\n\tint vsync, vmin, vmax;\n\n\tvmin = t[5];\n\tif (edid->revision >= 4)\n\t    vmin += ((t[4] & 0x01) ? 255 : 0);\n\tvmax = t[6];\n\tif (edid->revision >= 4)\n\t    vmax += ((t[4] & 0x02) ? 255 : 0);\n\tvsync = drm_mode_vrefresh(mode);\n\n\treturn (vsync <= vmax && vsync >= vmin);\n}\n\nstatic u32\nrange_pixel_clock(const struct edid *edid, const u8 *t)\n{\n\t \n\tif (t[9] == 0 || t[9] == 255)\n\t\treturn 0;\n\n\t \n\tif (edid->revision >= 4 && t[10] == DRM_EDID_CVT_SUPPORT_FLAG)\n\t\treturn (t[9] * 10000) - ((t[12] >> 2) * 250);\n\n\t \n\treturn t[9] * 10000 + 5001;\n}\n\nstatic bool mode_in_range(const struct drm_display_mode *mode,\n\t\t\t  const struct drm_edid *drm_edid,\n\t\t\t  const struct detailed_timing *timing)\n{\n\tconst struct edid *edid = drm_edid->edid;\n\tu32 max_clock;\n\tconst u8 *t = (const u8 *)timing;\n\n\tif (!mode_in_hsync_range(mode, edid, t))\n\t\treturn false;\n\n\tif (!mode_in_vsync_range(mode, edid, t))\n\t\treturn false;\n\n\tif ((max_clock = range_pixel_clock(edid, t)))\n\t\tif (mode->clock > max_clock)\n\t\t\treturn false;\n\n\t \n\tif (edid->revision >= 4 && t[10] == DRM_EDID_CVT_SUPPORT_FLAG)\n\t\tif (t[13] && mode->hdisplay > 8 * (t[13] + (256 * (t[12]&0x3))))\n\t\t\treturn false;\n\n\tif (mode_is_rb(mode) && !drm_monitor_supports_rb(drm_edid))\n\t\treturn false;\n\n\treturn true;\n}\n\nstatic bool valid_inferred_mode(const struct drm_connector *connector,\n\t\t\t\tconst struct drm_display_mode *mode)\n{\n\tconst struct drm_display_mode *m;\n\tbool ok = false;\n\n\tlist_for_each_entry(m, &connector->probed_modes, head) {\n\t\tif (mode->hdisplay == m->hdisplay &&\n\t\t    mode->vdisplay == m->vdisplay &&\n\t\t    drm_mode_vrefresh(mode) == drm_mode_vrefresh(m))\n\t\t\treturn false;  \n\t\tif (mode->hdisplay <= m->hdisplay &&\n\t\t    mode->vdisplay <= m->vdisplay)\n\t\t\tok = true;\n\t}\n\treturn ok;\n}\n\nstatic int drm_dmt_modes_for_range(struct drm_connector *connector,\n\t\t\t\t   const struct drm_edid *drm_edid,\n\t\t\t\t   const struct detailed_timing *timing)\n{\n\tint i, modes = 0;\n\tstruct drm_display_mode *newmode;\n\tstruct drm_device *dev = connector->dev;\n\n\tfor (i = 0; i < ARRAY_SIZE(drm_dmt_modes); i++) {\n\t\tif (mode_in_range(drm_dmt_modes + i, drm_edid, timing) &&\n\t\t    valid_inferred_mode(connector, drm_dmt_modes + i)) {\n\t\t\tnewmode = drm_mode_duplicate(dev, &drm_dmt_modes[i]);\n\t\t\tif (newmode) {\n\t\t\t\tdrm_mode_probed_add(connector, newmode);\n\t\t\t\tmodes++;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn modes;\n}\n\n \nvoid drm_mode_fixup_1366x768(struct drm_display_mode *mode)\n{\n\tif (mode->hdisplay == 1368 && mode->vdisplay == 768) {\n\t\tmode->hdisplay = 1366;\n\t\tmode->hsync_start--;\n\t\tmode->hsync_end--;\n\t\tdrm_mode_set_name(mode);\n\t}\n}\n\nstatic int drm_gtf_modes_for_range(struct drm_connector *connector,\n\t\t\t\t   const struct drm_edid *drm_edid,\n\t\t\t\t   const struct detailed_timing *timing)\n{\n\tint i, modes = 0;\n\tstruct drm_display_mode *newmode;\n\tstruct drm_device *dev = connector->dev;\n\n\tfor (i = 0; i < ARRAY_SIZE(extra_modes); i++) {\n\t\tconst struct minimode *m = &extra_modes[i];\n\n\t\tnewmode = drm_gtf_mode(dev, m->w, m->h, m->r, 0, 0);\n\t\tif (!newmode)\n\t\t\treturn modes;\n\n\t\tdrm_mode_fixup_1366x768(newmode);\n\t\tif (!mode_in_range(newmode, drm_edid, timing) ||\n\t\t    !valid_inferred_mode(connector, newmode)) {\n\t\t\tdrm_mode_destroy(dev, newmode);\n\t\t\tcontinue;\n\t\t}\n\n\t\tdrm_mode_probed_add(connector, newmode);\n\t\tmodes++;\n\t}\n\n\treturn modes;\n}\n\nstatic int drm_gtf2_modes_for_range(struct drm_connector *connector,\n\t\t\t\t    const struct drm_edid *drm_edid,\n\t\t\t\t    const struct detailed_timing *timing)\n{\n\tint i, modes = 0;\n\tstruct drm_display_mode *newmode;\n\tstruct drm_device *dev = connector->dev;\n\n\tfor (i = 0; i < ARRAY_SIZE(extra_modes); i++) {\n\t\tconst struct minimode *m = &extra_modes[i];\n\n\t\tnewmode = drm_gtf2_mode(dev, drm_edid, m->w, m->h, m->r);\n\t\tif (!newmode)\n\t\t\treturn modes;\n\n\t\tdrm_mode_fixup_1366x768(newmode);\n\t\tif (!mode_in_range(newmode, drm_edid, timing) ||\n\t\t    !valid_inferred_mode(connector, newmode)) {\n\t\t\tdrm_mode_destroy(dev, newmode);\n\t\t\tcontinue;\n\t\t}\n\n\t\tdrm_mode_probed_add(connector, newmode);\n\t\tmodes++;\n\t}\n\n\treturn modes;\n}\n\nstatic int drm_cvt_modes_for_range(struct drm_connector *connector,\n\t\t\t\t   const struct drm_edid *drm_edid,\n\t\t\t\t   const struct detailed_timing *timing)\n{\n\tint i, modes = 0;\n\tstruct drm_display_mode *newmode;\n\tstruct drm_device *dev = connector->dev;\n\tbool rb = drm_monitor_supports_rb(drm_edid);\n\n\tfor (i = 0; i < ARRAY_SIZE(extra_modes); i++) {\n\t\tconst struct minimode *m = &extra_modes[i];\n\n\t\tnewmode = drm_cvt_mode(dev, m->w, m->h, m->r, rb, 0, 0);\n\t\tif (!newmode)\n\t\t\treturn modes;\n\n\t\tdrm_mode_fixup_1366x768(newmode);\n\t\tif (!mode_in_range(newmode, drm_edid, timing) ||\n\t\t    !valid_inferred_mode(connector, newmode)) {\n\t\t\tdrm_mode_destroy(dev, newmode);\n\t\t\tcontinue;\n\t\t}\n\n\t\tdrm_mode_probed_add(connector, newmode);\n\t\tmodes++;\n\t}\n\n\treturn modes;\n}\n\nstatic void\ndo_inferred_modes(const struct detailed_timing *timing, void *c)\n{\n\tstruct detailed_mode_closure *closure = c;\n\tconst struct detailed_non_pixel *data = &timing->data.other_data;\n\tconst struct detailed_data_monitor_range *range = &data->data.range;\n\n\tif (!is_display_descriptor(timing, EDID_DETAIL_MONITOR_RANGE))\n\t\treturn;\n\n\tclosure->modes += drm_dmt_modes_for_range(closure->connector,\n\t\t\t\t\t\t  closure->drm_edid,\n\t\t\t\t\t\t  timing);\n\n\tif (closure->drm_edid->edid->revision < 2)\n\t\treturn;  \n\n\tswitch (range->flags) {\n\tcase DRM_EDID_SECONDARY_GTF_SUPPORT_FLAG:\n\t\tclosure->modes += drm_gtf2_modes_for_range(closure->connector,\n\t\t\t\t\t\t\t   closure->drm_edid,\n\t\t\t\t\t\t\t   timing);\n\t\tbreak;\n\tcase DRM_EDID_DEFAULT_GTF_SUPPORT_FLAG:\n\t\tclosure->modes += drm_gtf_modes_for_range(closure->connector,\n\t\t\t\t\t\t\t  closure->drm_edid,\n\t\t\t\t\t\t\t  timing);\n\t\tbreak;\n\tcase DRM_EDID_CVT_SUPPORT_FLAG:\n\t\tif (closure->drm_edid->edid->revision < 4)\n\t\t\tbreak;\n\n\t\tclosure->modes += drm_cvt_modes_for_range(closure->connector,\n\t\t\t\t\t\t\t  closure->drm_edid,\n\t\t\t\t\t\t\t  timing);\n\t\tbreak;\n\tcase DRM_EDID_RANGE_LIMITS_ONLY_FLAG:\n\tdefault:\n\t\tbreak;\n\t}\n}\n\nstatic int add_inferred_modes(struct drm_connector *connector,\n\t\t\t      const struct drm_edid *drm_edid)\n{\n\tstruct detailed_mode_closure closure = {\n\t\t.connector = connector,\n\t\t.drm_edid = drm_edid,\n\t};\n\n\tif (drm_edid->edid->revision >= 1)\n\t\tdrm_for_each_detailed_block(drm_edid, do_inferred_modes, &closure);\n\n\treturn closure.modes;\n}\n\nstatic int\ndrm_est3_modes(struct drm_connector *connector, const struct detailed_timing *timing)\n{\n\tint i, j, m, modes = 0;\n\tstruct drm_display_mode *mode;\n\tconst u8 *est = ((const u8 *)timing) + 6;\n\n\tfor (i = 0; i < 6; i++) {\n\t\tfor (j = 7; j >= 0; j--) {\n\t\t\tm = (i * 8) + (7 - j);\n\t\t\tif (m >= ARRAY_SIZE(est3_modes))\n\t\t\t\tbreak;\n\t\t\tif (est[i] & (1 << j)) {\n\t\t\t\tmode = drm_mode_find_dmt(connector->dev,\n\t\t\t\t\t\t\t est3_modes[m].w,\n\t\t\t\t\t\t\t est3_modes[m].h,\n\t\t\t\t\t\t\t est3_modes[m].r,\n\t\t\t\t\t\t\t est3_modes[m].rb);\n\t\t\t\tif (mode) {\n\t\t\t\t\tdrm_mode_probed_add(connector, mode);\n\t\t\t\t\tmodes++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn modes;\n}\n\nstatic void\ndo_established_modes(const struct detailed_timing *timing, void *c)\n{\n\tstruct detailed_mode_closure *closure = c;\n\n\tif (!is_display_descriptor(timing, EDID_DETAIL_EST_TIMINGS))\n\t\treturn;\n\n\tclosure->modes += drm_est3_modes(closure->connector, timing);\n}\n\n \nstatic int add_established_modes(struct drm_connector *connector,\n\t\t\t\t const struct drm_edid *drm_edid)\n{\n\tstruct drm_device *dev = connector->dev;\n\tconst struct edid *edid = drm_edid->edid;\n\tunsigned long est_bits = edid->established_timings.t1 |\n\t\t(edid->established_timings.t2 << 8) |\n\t\t((edid->established_timings.mfg_rsvd & 0x80) << 9);\n\tint i, modes = 0;\n\tstruct detailed_mode_closure closure = {\n\t\t.connector = connector,\n\t\t.drm_edid = drm_edid,\n\t};\n\n\tfor (i = 0; i <= EDID_EST_TIMINGS; i++) {\n\t\tif (est_bits & (1<<i)) {\n\t\t\tstruct drm_display_mode *newmode;\n\n\t\t\tnewmode = drm_mode_duplicate(dev, &edid_est_modes[i]);\n\t\t\tif (newmode) {\n\t\t\t\tdrm_mode_probed_add(connector, newmode);\n\t\t\t\tmodes++;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (edid->revision >= 1)\n\t\tdrm_for_each_detailed_block(drm_edid, do_established_modes,\n\t\t\t\t\t    &closure);\n\n\treturn modes + closure.modes;\n}\n\nstatic void\ndo_standard_modes(const struct detailed_timing *timing, void *c)\n{\n\tstruct detailed_mode_closure *closure = c;\n\tconst struct detailed_non_pixel *data = &timing->data.other_data;\n\tstruct drm_connector *connector = closure->connector;\n\tint i;\n\n\tif (!is_display_descriptor(timing, EDID_DETAIL_STD_MODES))\n\t\treturn;\n\n\tfor (i = 0; i < 6; i++) {\n\t\tconst struct std_timing *std = &data->data.timings[i];\n\t\tstruct drm_display_mode *newmode;\n\n\t\tnewmode = drm_mode_std(connector, closure->drm_edid, std);\n\t\tif (newmode) {\n\t\t\tdrm_mode_probed_add(connector, newmode);\n\t\t\tclosure->modes++;\n\t\t}\n\t}\n}\n\n \nstatic int add_standard_modes(struct drm_connector *connector,\n\t\t\t      const struct drm_edid *drm_edid)\n{\n\tint i, modes = 0;\n\tstruct detailed_mode_closure closure = {\n\t\t.connector = connector,\n\t\t.drm_edid = drm_edid,\n\t};\n\n\tfor (i = 0; i < EDID_STD_TIMINGS; i++) {\n\t\tstruct drm_display_mode *newmode;\n\n\t\tnewmode = drm_mode_std(connector, drm_edid,\n\t\t\t\t       &drm_edid->edid->standard_timings[i]);\n\t\tif (newmode) {\n\t\t\tdrm_mode_probed_add(connector, newmode);\n\t\t\tmodes++;\n\t\t}\n\t}\n\n\tif (drm_edid->edid->revision >= 1)\n\t\tdrm_for_each_detailed_block(drm_edid, do_standard_modes,\n\t\t\t\t\t    &closure);\n\n\t \n\n\treturn modes + closure.modes;\n}\n\nstatic int drm_cvt_modes(struct drm_connector *connector,\n\t\t\t const struct detailed_timing *timing)\n{\n\tint i, j, modes = 0;\n\tstruct drm_display_mode *newmode;\n\tstruct drm_device *dev = connector->dev;\n\tconst struct cvt_timing *cvt;\n\tstatic const int rates[] = { 60, 85, 75, 60, 50 };\n\tconst u8 empty[3] = { 0, 0, 0 };\n\n\tfor (i = 0; i < 4; i++) {\n\t\tint width, height;\n\n\t\tcvt = &(timing->data.other_data.data.cvt[i]);\n\n\t\tif (!memcmp(cvt->code, empty, 3))\n\t\t\tcontinue;\n\n\t\theight = (cvt->code[0] + ((cvt->code[1] & 0xf0) << 4) + 1) * 2;\n\t\tswitch (cvt->code[1] & 0x0c) {\n\t\t \n\t\tdefault:\n\t\tcase 0x00:\n\t\t\twidth = height * 4 / 3;\n\t\t\tbreak;\n\t\tcase 0x04:\n\t\t\twidth = height * 16 / 9;\n\t\t\tbreak;\n\t\tcase 0x08:\n\t\t\twidth = height * 16 / 10;\n\t\t\tbreak;\n\t\tcase 0x0c:\n\t\t\twidth = height * 15 / 9;\n\t\t\tbreak;\n\t\t}\n\n\t\tfor (j = 1; j < 5; j++) {\n\t\t\tif (cvt->code[2] & (1 << j)) {\n\t\t\t\tnewmode = drm_cvt_mode(dev, width, height,\n\t\t\t\t\t\t       rates[j], j == 0,\n\t\t\t\t\t\t       false, false);\n\t\t\t\tif (newmode) {\n\t\t\t\t\tdrm_mode_probed_add(connector, newmode);\n\t\t\t\t\tmodes++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn modes;\n}\n\nstatic void\ndo_cvt_mode(const struct detailed_timing *timing, void *c)\n{\n\tstruct detailed_mode_closure *closure = c;\n\n\tif (!is_display_descriptor(timing, EDID_DETAIL_CVT_3BYTE))\n\t\treturn;\n\n\tclosure->modes += drm_cvt_modes(closure->connector, timing);\n}\n\nstatic int\nadd_cvt_modes(struct drm_connector *connector, const struct drm_edid *drm_edid)\n{\n\tstruct detailed_mode_closure closure = {\n\t\t.connector = connector,\n\t\t.drm_edid = drm_edid,\n\t};\n\n\tif (drm_edid->edid->revision >= 3)\n\t\tdrm_for_each_detailed_block(drm_edid, do_cvt_mode, &closure);\n\n\t \n\n\treturn closure.modes;\n}\n\nstatic void fixup_detailed_cea_mode_clock(struct drm_connector *connector,\n\t\t\t\t\t  struct drm_display_mode *mode);\n\nstatic void\ndo_detailed_mode(const struct detailed_timing *timing, void *c)\n{\n\tstruct detailed_mode_closure *closure = c;\n\tstruct drm_display_mode *newmode;\n\n\tif (!is_detailed_timing_descriptor(timing))\n\t\treturn;\n\n\tnewmode = drm_mode_detailed(closure->connector,\n\t\t\t\t    closure->drm_edid, timing);\n\tif (!newmode)\n\t\treturn;\n\n\tif (closure->preferred)\n\t\tnewmode->type |= DRM_MODE_TYPE_PREFERRED;\n\n\t \n\tfixup_detailed_cea_mode_clock(closure->connector, newmode);\n\n\tdrm_mode_probed_add(closure->connector, newmode);\n\tclosure->modes++;\n\tclosure->preferred = false;\n}\n\n \nstatic int add_detailed_modes(struct drm_connector *connector,\n\t\t\t      const struct drm_edid *drm_edid)\n{\n\tstruct detailed_mode_closure closure = {\n\t\t.connector = connector,\n\t\t.drm_edid = drm_edid,\n\t};\n\n\tif (drm_edid->edid->revision >= 4)\n\t\tclosure.preferred = true;  \n\telse\n\t\tclosure.preferred =\n\t\t\tdrm_edid->edid->features & DRM_EDID_FEATURE_PREFERRED_TIMING;\n\n\tdrm_for_each_detailed_block(drm_edid, do_detailed_mode, &closure);\n\n\treturn closure.modes;\n}\n\n \n#define CTA_DB_AUDIO\t\t\t1\n#define CTA_DB_VIDEO\t\t\t2\n#define CTA_DB_VENDOR\t\t\t3\n#define CTA_DB_SPEAKER\t\t\t4\n#define CTA_DB_EXTENDED_TAG\t\t7\n\n \n#define CTA_EXT_DB_VIDEO_CAP\t\t0\n#define CTA_EXT_DB_VENDOR\t\t1\n#define CTA_EXT_DB_HDR_STATIC_METADATA\t6\n#define CTA_EXT_DB_420_VIDEO_DATA\t14\n#define CTA_EXT_DB_420_VIDEO_CAP_MAP\t15\n#define CTA_EXT_DB_HF_EEODB\t\t0x78\n#define CTA_EXT_DB_HF_SCDB\t\t0x79\n\n#define EDID_BASIC_AUDIO\t(1 << 6)\n#define EDID_CEA_YCRCB444\t(1 << 5)\n#define EDID_CEA_YCRCB422\t(1 << 4)\n#define EDID_CEA_VCDB_QS\t(1 << 6)\n\n \nconst u8 *drm_find_edid_extension(const struct drm_edid *drm_edid,\n\t\t\t\t  int ext_id, int *ext_index)\n{\n\tconst u8 *edid_ext = NULL;\n\tint i;\n\n\t \n\tif (!drm_edid || !drm_edid_extension_block_count(drm_edid))\n\t\treturn NULL;\n\n\t \n\tfor (i = *ext_index; i < drm_edid_extension_block_count(drm_edid); i++) {\n\t\tedid_ext = drm_edid_extension_block_data(drm_edid, i);\n\t\tif (edid_block_tag(edid_ext) == ext_id)\n\t\t\tbreak;\n\t}\n\n\tif (i >= drm_edid_extension_block_count(drm_edid))\n\t\treturn NULL;\n\n\t*ext_index = i + 1;\n\n\treturn edid_ext;\n}\n\n \nstatic bool drm_edid_has_cta_extension(const struct drm_edid *drm_edid)\n{\n\tconst struct displayid_block *block;\n\tstruct displayid_iter iter;\n\tint ext_index = 0;\n\tbool found = false;\n\n\t \n\tif (drm_find_edid_extension(drm_edid, CEA_EXT, &ext_index))\n\t\treturn true;\n\n\t \n\tdisplayid_iter_edid_begin(drm_edid, &iter);\n\tdisplayid_iter_for_each(block, &iter) {\n\t\tif (block->tag == DATA_BLOCK_CTA) {\n\t\t\tfound = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\tdisplayid_iter_end(&iter);\n\n\treturn found;\n}\n\nstatic __always_inline const struct drm_display_mode *cea_mode_for_vic(u8 vic)\n{\n\tBUILD_BUG_ON(1 + ARRAY_SIZE(edid_cea_modes_1) - 1 != 127);\n\tBUILD_BUG_ON(193 + ARRAY_SIZE(edid_cea_modes_193) - 1 != 219);\n\n\tif (vic >= 1 && vic < 1 + ARRAY_SIZE(edid_cea_modes_1))\n\t\treturn &edid_cea_modes_1[vic - 1];\n\tif (vic >= 193 && vic < 193 + ARRAY_SIZE(edid_cea_modes_193))\n\t\treturn &edid_cea_modes_193[vic - 193];\n\treturn NULL;\n}\n\nstatic u8 cea_num_vics(void)\n{\n\treturn 193 + ARRAY_SIZE(edid_cea_modes_193);\n}\n\nstatic u8 cea_next_vic(u8 vic)\n{\n\tif (++vic == 1 + ARRAY_SIZE(edid_cea_modes_1))\n\t\tvic = 193;\n\treturn vic;\n}\n\n \nstatic unsigned int\ncea_mode_alternate_clock(const struct drm_display_mode *cea_mode)\n{\n\tunsigned int clock = cea_mode->clock;\n\n\tif (drm_mode_vrefresh(cea_mode) % 6 != 0)\n\t\treturn clock;\n\n\t \n\tif (cea_mode->vdisplay == 240 || cea_mode->vdisplay == 480)\n\t\tclock = DIV_ROUND_CLOSEST(clock * 1001, 1000);\n\telse\n\t\tclock = DIV_ROUND_CLOSEST(clock * 1000, 1001);\n\n\treturn clock;\n}\n\nstatic bool\ncea_mode_alternate_timings(u8 vic, struct drm_display_mode *mode)\n{\n\t \n\tBUILD_BUG_ON(cea_mode_for_vic(8)->vtotal != 262 ||\n\t\t     cea_mode_for_vic(9)->vtotal != 262 ||\n\t\t     cea_mode_for_vic(12)->vtotal != 262 ||\n\t\t     cea_mode_for_vic(13)->vtotal != 262 ||\n\t\t     cea_mode_for_vic(23)->vtotal != 312 ||\n\t\t     cea_mode_for_vic(24)->vtotal != 312 ||\n\t\t     cea_mode_for_vic(27)->vtotal != 312 ||\n\t\t     cea_mode_for_vic(28)->vtotal != 312);\n\n\tif (((vic == 8 || vic == 9 ||\n\t      vic == 12 || vic == 13) && mode->vtotal < 263) ||\n\t    ((vic == 23 || vic == 24 ||\n\t      vic == 27 || vic == 28) && mode->vtotal < 314)) {\n\t\tmode->vsync_start++;\n\t\tmode->vsync_end++;\n\t\tmode->vtotal++;\n\n\t\treturn true;\n\t}\n\n\treturn false;\n}\n\nstatic u8 drm_match_cea_mode_clock_tolerance(const struct drm_display_mode *to_match,\n\t\t\t\t\t     unsigned int clock_tolerance)\n{\n\tunsigned int match_flags = DRM_MODE_MATCH_TIMINGS | DRM_MODE_MATCH_FLAGS;\n\tu8 vic;\n\n\tif (!to_match->clock)\n\t\treturn 0;\n\n\tif (to_match->picture_aspect_ratio)\n\t\tmatch_flags |= DRM_MODE_MATCH_ASPECT_RATIO;\n\n\tfor (vic = 1; vic < cea_num_vics(); vic = cea_next_vic(vic)) {\n\t\tstruct drm_display_mode cea_mode;\n\t\tunsigned int clock1, clock2;\n\n\t\tdrm_mode_init(&cea_mode, cea_mode_for_vic(vic));\n\n\t\t \n\t\tclock1 = cea_mode.clock;\n\t\tclock2 = cea_mode_alternate_clock(&cea_mode);\n\n\t\tif (abs(to_match->clock - clock1) > clock_tolerance &&\n\t\t    abs(to_match->clock - clock2) > clock_tolerance)\n\t\t\tcontinue;\n\n\t\tdo {\n\t\t\tif (drm_mode_match(to_match, &cea_mode, match_flags))\n\t\t\t\treturn vic;\n\t\t} while (cea_mode_alternate_timings(vic, &cea_mode));\n\t}\n\n\treturn 0;\n}\n\n \nu8 drm_match_cea_mode(const struct drm_display_mode *to_match)\n{\n\tunsigned int match_flags = DRM_MODE_MATCH_TIMINGS | DRM_MODE_MATCH_FLAGS;\n\tu8 vic;\n\n\tif (!to_match->clock)\n\t\treturn 0;\n\n\tif (to_match->picture_aspect_ratio)\n\t\tmatch_flags |= DRM_MODE_MATCH_ASPECT_RATIO;\n\n\tfor (vic = 1; vic < cea_num_vics(); vic = cea_next_vic(vic)) {\n\t\tstruct drm_display_mode cea_mode;\n\t\tunsigned int clock1, clock2;\n\n\t\tdrm_mode_init(&cea_mode, cea_mode_for_vic(vic));\n\n\t\t \n\t\tclock1 = cea_mode.clock;\n\t\tclock2 = cea_mode_alternate_clock(&cea_mode);\n\n\t\tif (KHZ2PICOS(to_match->clock) != KHZ2PICOS(clock1) &&\n\t\t    KHZ2PICOS(to_match->clock) != KHZ2PICOS(clock2))\n\t\t\tcontinue;\n\n\t\tdo {\n\t\t\tif (drm_mode_match(to_match, &cea_mode, match_flags))\n\t\t\t\treturn vic;\n\t\t} while (cea_mode_alternate_timings(vic, &cea_mode));\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL(drm_match_cea_mode);\n\nstatic bool drm_valid_cea_vic(u8 vic)\n{\n\treturn cea_mode_for_vic(vic) != NULL;\n}\n\nstatic enum hdmi_picture_aspect drm_get_cea_aspect_ratio(const u8 video_code)\n{\n\tconst struct drm_display_mode *mode = cea_mode_for_vic(video_code);\n\n\tif (mode)\n\t\treturn mode->picture_aspect_ratio;\n\n\treturn HDMI_PICTURE_ASPECT_NONE;\n}\n\nstatic enum hdmi_picture_aspect drm_get_hdmi_aspect_ratio(const u8 video_code)\n{\n\treturn edid_4k_modes[video_code].picture_aspect_ratio;\n}\n\n \nstatic unsigned int\nhdmi_mode_alternate_clock(const struct drm_display_mode *hdmi_mode)\n{\n\treturn cea_mode_alternate_clock(hdmi_mode);\n}\n\nstatic u8 drm_match_hdmi_mode_clock_tolerance(const struct drm_display_mode *to_match,\n\t\t\t\t\t      unsigned int clock_tolerance)\n{\n\tunsigned int match_flags = DRM_MODE_MATCH_TIMINGS | DRM_MODE_MATCH_FLAGS;\n\tu8 vic;\n\n\tif (!to_match->clock)\n\t\treturn 0;\n\n\tif (to_match->picture_aspect_ratio)\n\t\tmatch_flags |= DRM_MODE_MATCH_ASPECT_RATIO;\n\n\tfor (vic = 1; vic < ARRAY_SIZE(edid_4k_modes); vic++) {\n\t\tconst struct drm_display_mode *hdmi_mode = &edid_4k_modes[vic];\n\t\tunsigned int clock1, clock2;\n\n\t\t \n\t\tclock1 = hdmi_mode->clock;\n\t\tclock2 = hdmi_mode_alternate_clock(hdmi_mode);\n\n\t\tif (abs(to_match->clock - clock1) > clock_tolerance &&\n\t\t    abs(to_match->clock - clock2) > clock_tolerance)\n\t\t\tcontinue;\n\n\t\tif (drm_mode_match(to_match, hdmi_mode, match_flags))\n\t\t\treturn vic;\n\t}\n\n\treturn 0;\n}\n\n \nstatic u8 drm_match_hdmi_mode(const struct drm_display_mode *to_match)\n{\n\tunsigned int match_flags = DRM_MODE_MATCH_TIMINGS | DRM_MODE_MATCH_FLAGS;\n\tu8 vic;\n\n\tif (!to_match->clock)\n\t\treturn 0;\n\n\tif (to_match->picture_aspect_ratio)\n\t\tmatch_flags |= DRM_MODE_MATCH_ASPECT_RATIO;\n\n\tfor (vic = 1; vic < ARRAY_SIZE(edid_4k_modes); vic++) {\n\t\tconst struct drm_display_mode *hdmi_mode = &edid_4k_modes[vic];\n\t\tunsigned int clock1, clock2;\n\n\t\t \n\t\tclock1 = hdmi_mode->clock;\n\t\tclock2 = hdmi_mode_alternate_clock(hdmi_mode);\n\n\t\tif ((KHZ2PICOS(to_match->clock) == KHZ2PICOS(clock1) ||\n\t\t     KHZ2PICOS(to_match->clock) == KHZ2PICOS(clock2)) &&\n\t\t    drm_mode_match(to_match, hdmi_mode, match_flags))\n\t\t\treturn vic;\n\t}\n\treturn 0;\n}\n\nstatic bool drm_valid_hdmi_vic(u8 vic)\n{\n\treturn vic > 0 && vic < ARRAY_SIZE(edid_4k_modes);\n}\n\nstatic int add_alternate_cea_modes(struct drm_connector *connector,\n\t\t\t\t   const struct drm_edid *drm_edid)\n{\n\tstruct drm_device *dev = connector->dev;\n\tstruct drm_display_mode *mode, *tmp;\n\tLIST_HEAD(list);\n\tint modes = 0;\n\n\t \n\tif (!drm_edid_has_cta_extension(drm_edid))\n\t\treturn 0;\n\n\t \n\tlist_for_each_entry(mode, &connector->probed_modes, head) {\n\t\tconst struct drm_display_mode *cea_mode = NULL;\n\t\tstruct drm_display_mode *newmode;\n\t\tu8 vic = drm_match_cea_mode(mode);\n\t\tunsigned int clock1, clock2;\n\n\t\tif (drm_valid_cea_vic(vic)) {\n\t\t\tcea_mode = cea_mode_for_vic(vic);\n\t\t\tclock2 = cea_mode_alternate_clock(cea_mode);\n\t\t} else {\n\t\t\tvic = drm_match_hdmi_mode(mode);\n\t\t\tif (drm_valid_hdmi_vic(vic)) {\n\t\t\t\tcea_mode = &edid_4k_modes[vic];\n\t\t\t\tclock2 = hdmi_mode_alternate_clock(cea_mode);\n\t\t\t}\n\t\t}\n\n\t\tif (!cea_mode)\n\t\t\tcontinue;\n\n\t\tclock1 = cea_mode->clock;\n\n\t\tif (clock1 == clock2)\n\t\t\tcontinue;\n\n\t\tif (mode->clock != clock1 && mode->clock != clock2)\n\t\t\tcontinue;\n\n\t\tnewmode = drm_mode_duplicate(dev, cea_mode);\n\t\tif (!newmode)\n\t\t\tcontinue;\n\n\t\t \n\t\tnewmode->flags |= mode->flags & DRM_MODE_FLAG_3D_MASK;\n\n\t\t \n\t\tif (mode->clock != clock1)\n\t\t\tnewmode->clock = clock1;\n\t\telse\n\t\t\tnewmode->clock = clock2;\n\n\t\tlist_add_tail(&newmode->head, &list);\n\t}\n\n\tlist_for_each_entry_safe(mode, tmp, &list, head) {\n\t\tlist_del(&mode->head);\n\t\tdrm_mode_probed_add(connector, mode);\n\t\tmodes++;\n\t}\n\n\treturn modes;\n}\n\nstatic u8 svd_to_vic(u8 svd)\n{\n\t \n\tif ((svd >= 1 &&  svd <= 64) || (svd >= 129 && svd <= 192))\n\t\treturn svd & 127;\n\n\treturn svd;\n}\n\n \nstatic struct drm_display_mode *\ndrm_display_mode_from_vic_index(struct drm_connector *connector, int vic_index)\n{\n\tconst struct drm_display_info *info = &connector->display_info;\n\tstruct drm_device *dev = connector->dev;\n\n\tif (!info->vics || vic_index >= info->vics_len || !info->vics[vic_index])\n\t\treturn NULL;\n\n\treturn drm_display_mode_from_cea_vic(dev, info->vics[vic_index]);\n}\n\n \nstatic int do_y420vdb_modes(struct drm_connector *connector,\n\t\t\t    const u8 *svds, u8 svds_len)\n{\n\tstruct drm_device *dev = connector->dev;\n\tint modes = 0, i;\n\n\tfor (i = 0; i < svds_len; i++) {\n\t\tu8 vic = svd_to_vic(svds[i]);\n\t\tstruct drm_display_mode *newmode;\n\n\t\tif (!drm_valid_cea_vic(vic))\n\t\t\tcontinue;\n\n\t\tnewmode = drm_mode_duplicate(dev, cea_mode_for_vic(vic));\n\t\tif (!newmode)\n\t\t\tbreak;\n\t\tdrm_mode_probed_add(connector, newmode);\n\t\tmodes++;\n\t}\n\n\treturn modes;\n}\n\n \nstruct drm_display_mode *\ndrm_display_mode_from_cea_vic(struct drm_device *dev,\n\t\t\t      u8 video_code)\n{\n\tconst struct drm_display_mode *cea_mode;\n\tstruct drm_display_mode *newmode;\n\n\tcea_mode = cea_mode_for_vic(video_code);\n\tif (!cea_mode)\n\t\treturn NULL;\n\n\tnewmode = drm_mode_duplicate(dev, cea_mode);\n\tif (!newmode)\n\t\treturn NULL;\n\n\treturn newmode;\n}\nEXPORT_SYMBOL(drm_display_mode_from_cea_vic);\n\n \nstatic int add_cta_vdb_modes(struct drm_connector *connector)\n{\n\tconst struct drm_display_info *info = &connector->display_info;\n\tint i, modes = 0;\n\n\tif (!info->vics)\n\t\treturn 0;\n\n\tfor (i = 0; i < info->vics_len; i++) {\n\t\tstruct drm_display_mode *mode;\n\n\t\tmode = drm_display_mode_from_vic_index(connector, i);\n\t\tif (mode) {\n\t\t\tdrm_mode_probed_add(connector, mode);\n\t\t\tmodes++;\n\t\t}\n\t}\n\n\treturn modes;\n}\n\nstruct stereo_mandatory_mode {\n\tint width, height, vrefresh;\n\tunsigned int flags;\n};\n\nstatic const struct stereo_mandatory_mode stereo_mandatory_modes[] = {\n\t{ 1920, 1080, 24, DRM_MODE_FLAG_3D_TOP_AND_BOTTOM },\n\t{ 1920, 1080, 24, DRM_MODE_FLAG_3D_FRAME_PACKING },\n\t{ 1920, 1080, 50,\n\t  DRM_MODE_FLAG_INTERLACE | DRM_MODE_FLAG_3D_SIDE_BY_SIDE_HALF },\n\t{ 1920, 1080, 60,\n\t  DRM_MODE_FLAG_INTERLACE | DRM_MODE_FLAG_3D_SIDE_BY_SIDE_HALF },\n\t{ 1280, 720,  50, DRM_MODE_FLAG_3D_TOP_AND_BOTTOM },\n\t{ 1280, 720,  50, DRM_MODE_FLAG_3D_FRAME_PACKING },\n\t{ 1280, 720,  60, DRM_MODE_FLAG_3D_TOP_AND_BOTTOM },\n\t{ 1280, 720,  60, DRM_MODE_FLAG_3D_FRAME_PACKING }\n};\n\nstatic bool\nstereo_match_mandatory(const struct drm_display_mode *mode,\n\t\t       const struct stereo_mandatory_mode *stereo_mode)\n{\n\tunsigned int interlaced = mode->flags & DRM_MODE_FLAG_INTERLACE;\n\n\treturn mode->hdisplay == stereo_mode->width &&\n\t       mode->vdisplay == stereo_mode->height &&\n\t       interlaced == (stereo_mode->flags & DRM_MODE_FLAG_INTERLACE) &&\n\t       drm_mode_vrefresh(mode) == stereo_mode->vrefresh;\n}\n\nstatic int add_hdmi_mandatory_stereo_modes(struct drm_connector *connector)\n{\n\tstruct drm_device *dev = connector->dev;\n\tconst struct drm_display_mode *mode;\n\tstruct list_head stereo_modes;\n\tint modes = 0, i;\n\n\tINIT_LIST_HEAD(&stereo_modes);\n\n\tlist_for_each_entry(mode, &connector->probed_modes, head) {\n\t\tfor (i = 0; i < ARRAY_SIZE(stereo_mandatory_modes); i++) {\n\t\t\tconst struct stereo_mandatory_mode *mandatory;\n\t\t\tstruct drm_display_mode *new_mode;\n\n\t\t\tif (!stereo_match_mandatory(mode,\n\t\t\t\t\t\t    &stereo_mandatory_modes[i]))\n\t\t\t\tcontinue;\n\n\t\t\tmandatory = &stereo_mandatory_modes[i];\n\t\t\tnew_mode = drm_mode_duplicate(dev, mode);\n\t\t\tif (!new_mode)\n\t\t\t\tcontinue;\n\n\t\t\tnew_mode->flags |= mandatory->flags;\n\t\t\tlist_add_tail(&new_mode->head, &stereo_modes);\n\t\t\tmodes++;\n\t\t}\n\t}\n\n\tlist_splice_tail(&stereo_modes, &connector->probed_modes);\n\n\treturn modes;\n}\n\nstatic int add_hdmi_mode(struct drm_connector *connector, u8 vic)\n{\n\tstruct drm_device *dev = connector->dev;\n\tstruct drm_display_mode *newmode;\n\n\tif (!drm_valid_hdmi_vic(vic)) {\n\t\tdrm_err(connector->dev, \"[CONNECTOR:%d:%s] Unknown HDMI VIC: %d\\n\",\n\t\t\tconnector->base.id, connector->name, vic);\n\t\treturn 0;\n\t}\n\n\tnewmode = drm_mode_duplicate(dev, &edid_4k_modes[vic]);\n\tif (!newmode)\n\t\treturn 0;\n\n\tdrm_mode_probed_add(connector, newmode);\n\n\treturn 1;\n}\n\nstatic int add_3d_struct_modes(struct drm_connector *connector, u16 structure,\n\t\t\t       int vic_index)\n{\n\tstruct drm_display_mode *newmode;\n\tint modes = 0;\n\n\tif (structure & (1 << 0)) {\n\t\tnewmode = drm_display_mode_from_vic_index(connector, vic_index);\n\t\tif (newmode) {\n\t\t\tnewmode->flags |= DRM_MODE_FLAG_3D_FRAME_PACKING;\n\t\t\tdrm_mode_probed_add(connector, newmode);\n\t\t\tmodes++;\n\t\t}\n\t}\n\tif (structure & (1 << 6)) {\n\t\tnewmode = drm_display_mode_from_vic_index(connector, vic_index);\n\t\tif (newmode) {\n\t\t\tnewmode->flags |= DRM_MODE_FLAG_3D_TOP_AND_BOTTOM;\n\t\t\tdrm_mode_probed_add(connector, newmode);\n\t\t\tmodes++;\n\t\t}\n\t}\n\tif (structure & (1 << 8)) {\n\t\tnewmode = drm_display_mode_from_vic_index(connector, vic_index);\n\t\tif (newmode) {\n\t\t\tnewmode->flags |= DRM_MODE_FLAG_3D_SIDE_BY_SIDE_HALF;\n\t\t\tdrm_mode_probed_add(connector, newmode);\n\t\t\tmodes++;\n\t\t}\n\t}\n\n\treturn modes;\n}\n\nstatic bool hdmi_vsdb_latency_present(const u8 *db)\n{\n\treturn db[8] & BIT(7);\n}\n\nstatic bool hdmi_vsdb_i_latency_present(const u8 *db)\n{\n\treturn hdmi_vsdb_latency_present(db) && db[8] & BIT(6);\n}\n\nstatic int hdmi_vsdb_latency_length(const u8 *db)\n{\n\tif (hdmi_vsdb_i_latency_present(db))\n\t\treturn 4;\n\telse if (hdmi_vsdb_latency_present(db))\n\t\treturn 2;\n\telse\n\t\treturn 0;\n}\n\n \nstatic int\ndo_hdmi_vsdb_modes(struct drm_connector *connector, const u8 *db, u8 len)\n{\n\tint modes = 0, offset = 0, i, multi_present = 0, multi_len;\n\tu8 vic_len, hdmi_3d_len = 0;\n\tu16 mask;\n\tu16 structure_all;\n\n\tif (len < 8)\n\t\tgoto out;\n\n\t \n\tif (!(db[8] & (1 << 5)))\n\t\tgoto out;\n\n\toffset += hdmi_vsdb_latency_length(db);\n\n\t \n\tif (len < (8 + offset + 2))\n\t\tgoto out;\n\n\t \n\toffset++;\n\tif (db[8 + offset] & (1 << 7)) {\n\t\tmodes += add_hdmi_mandatory_stereo_modes(connector);\n\n\t\t \n\t\tmulti_present = (db[8 + offset] & 0x60) >> 5;\n\t}\n\n\toffset++;\n\tvic_len = db[8 + offset] >> 5;\n\thdmi_3d_len = db[8 + offset] & 0x1f;\n\n\tfor (i = 0; i < vic_len && len >= (9 + offset + i); i++) {\n\t\tu8 vic;\n\n\t\tvic = db[9 + offset + i];\n\t\tmodes += add_hdmi_mode(connector, vic);\n\t}\n\toffset += 1 + vic_len;\n\n\tif (multi_present == 1)\n\t\tmulti_len = 2;\n\telse if (multi_present == 2)\n\t\tmulti_len = 4;\n\telse\n\t\tmulti_len = 0;\n\n\tif (len < (8 + offset + hdmi_3d_len - 1))\n\t\tgoto out;\n\n\tif (hdmi_3d_len < multi_len)\n\t\tgoto out;\n\n\tif (multi_present == 1 || multi_present == 2) {\n\t\t \n\t\tstructure_all = (db[8 + offset] << 8) | db[9 + offset];\n\n\t\t \n\t\tif (multi_present == 2)\n\t\t\tmask = (db[10 + offset] << 8) | db[11 + offset];\n\t\telse\n\t\t\tmask = 0xffff;\n\n\t\tfor (i = 0; i < 16; i++) {\n\t\t\tif (mask & (1 << i))\n\t\t\t\tmodes += add_3d_struct_modes(connector,\n\t\t\t\t\t\t\t     structure_all, i);\n\t\t}\n\t}\n\n\toffset += multi_len;\n\n\tfor (i = 0; i < (hdmi_3d_len - multi_len); i++) {\n\t\tint vic_index;\n\t\tstruct drm_display_mode *newmode = NULL;\n\t\tunsigned int newflag = 0;\n\t\tbool detail_present;\n\n\t\tdetail_present = ((db[8 + offset + i] & 0x0f) > 7);\n\n\t\tif (detail_present && (i + 1 == hdmi_3d_len - multi_len))\n\t\t\tbreak;\n\n\t\t \n\t\tvic_index = db[8 + offset + i] >> 4;\n\n\t\t \n\t\tswitch (db[8 + offset + i] & 0x0f) {\n\t\tcase 0:\n\t\t\tnewflag = DRM_MODE_FLAG_3D_FRAME_PACKING;\n\t\t\tbreak;\n\t\tcase 6:\n\t\t\tnewflag = DRM_MODE_FLAG_3D_TOP_AND_BOTTOM;\n\t\t\tbreak;\n\t\tcase 8:\n\t\t\t \n\t\t\tif ((db[9 + offset + i] >> 4) == 1)\n\t\t\t\tnewflag = DRM_MODE_FLAG_3D_SIDE_BY_SIDE_HALF;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (newflag != 0) {\n\t\t\tnewmode = drm_display_mode_from_vic_index(connector,\n\t\t\t\t\t\t\t\t  vic_index);\n\n\t\t\tif (newmode) {\n\t\t\t\tnewmode->flags |= newflag;\n\t\t\t\tdrm_mode_probed_add(connector, newmode);\n\t\t\t\tmodes++;\n\t\t\t}\n\t\t}\n\n\t\tif (detail_present)\n\t\t\ti++;\n\t}\n\nout:\n\treturn modes;\n}\n\nstatic int\ncea_revision(const u8 *cea)\n{\n\t \n\treturn cea[1];\n}\n\n \nstruct cea_db_iter {\n\tstruct drm_edid_iter edid_iter;\n\tstruct displayid_iter displayid_iter;\n\n\t \n\tconst u8 *collection;\n\n\t \n\tint index;\n\n\t \n\tint end;\n};\n\n \nstruct cea_db {\n\tu8 tag_length;\n\tu8 data[];\n} __packed;\n\nstatic int cea_db_tag(const struct cea_db *db)\n{\n\treturn db->tag_length >> 5;\n}\n\nstatic int cea_db_payload_len(const void *_db)\n{\n\t \n\tconst struct cea_db *db = _db;\n\n\treturn db->tag_length & 0x1f;\n}\n\nstatic const void *cea_db_data(const struct cea_db *db)\n{\n\treturn db->data;\n}\n\nstatic bool cea_db_is_extended_tag(const struct cea_db *db, int tag)\n{\n\treturn cea_db_tag(db) == CTA_DB_EXTENDED_TAG &&\n\t\tcea_db_payload_len(db) >= 1 &&\n\t\tdb->data[0] == tag;\n}\n\nstatic bool cea_db_is_vendor(const struct cea_db *db, int vendor_oui)\n{\n\tconst u8 *data = cea_db_data(db);\n\n\treturn cea_db_tag(db) == CTA_DB_VENDOR &&\n\t\tcea_db_payload_len(db) >= 3 &&\n\t\toui(data[2], data[1], data[0]) == vendor_oui;\n}\n\nstatic void cea_db_iter_edid_begin(const struct drm_edid *drm_edid,\n\t\t\t\t   struct cea_db_iter *iter)\n{\n\tmemset(iter, 0, sizeof(*iter));\n\n\tdrm_edid_iter_begin(drm_edid, &iter->edid_iter);\n\tdisplayid_iter_edid_begin(drm_edid, &iter->displayid_iter);\n}\n\nstatic const struct cea_db *\n__cea_db_iter_current_block(const struct cea_db_iter *iter)\n{\n\tconst struct cea_db *db;\n\n\tif (!iter->collection)\n\t\treturn NULL;\n\n\tdb = (const struct cea_db *)&iter->collection[iter->index];\n\n\tif (iter->index + sizeof(*db) <= iter->end &&\n\t    iter->index + sizeof(*db) + cea_db_payload_len(db) <= iter->end)\n\t\treturn db;\n\n\treturn NULL;\n}\n\n \nstatic int cea_db_collection_size(const u8 *cta)\n{\n\tu8 d = cta[2];\n\n\tif (d < 4 || d > 127)\n\t\treturn 0;\n\n\treturn d - 4;\n}\n\n \nstatic const void *__cea_db_iter_edid_next(struct cea_db_iter *iter)\n{\n\tconst u8 *ext;\n\n\tdrm_edid_iter_for_each(ext, &iter->edid_iter) {\n\t\tint size;\n\n\t\t \n\t\tif (ext[0] != CEA_EXT || cea_revision(ext) < 3)\n\t\t\tcontinue;\n\n\t\tsize = cea_db_collection_size(ext);\n\t\tif (!size)\n\t\t\tcontinue;\n\n\t\titer->index = 4;\n\t\titer->end = iter->index + size;\n\n\t\treturn ext;\n\t}\n\n\treturn NULL;\n}\n\n \nstatic const void *__cea_db_iter_displayid_next(struct cea_db_iter *iter)\n{\n\tconst struct displayid_block *block;\n\n\tdisplayid_iter_for_each(block, &iter->displayid_iter) {\n\t\tif (block->tag != DATA_BLOCK_CTA)\n\t\t\tcontinue;\n\n\t\t \n\t\titer->index = sizeof(*block);\n\t\titer->end = iter->index + block->num_bytes;\n\n\t\treturn block;\n\t}\n\n\treturn NULL;\n}\n\nstatic const struct cea_db *__cea_db_iter_next(struct cea_db_iter *iter)\n{\n\tconst struct cea_db *db;\n\n\tif (iter->collection) {\n\t\t \n\t\tdb = __cea_db_iter_current_block(iter);\n\t\tif (WARN_ON(!db)) {\n\t\t\titer->collection = NULL;\n\t\t\treturn NULL;\n\t\t}\n\n\t\t \n\t\titer->index += sizeof(*db) + cea_db_payload_len(db);\n\n\t\tdb = __cea_db_iter_current_block(iter);\n\t\tif (db)\n\t\t\treturn db;\n\t}\n\n\tfor (;;) {\n\t\t \n\t\titer->collection = __cea_db_iter_edid_next(iter);\n\t\tif (!iter->collection)\n\t\t\titer->collection = __cea_db_iter_displayid_next(iter);\n\n\t\tif (!iter->collection)\n\t\t\treturn NULL;\n\n\t\tdb = __cea_db_iter_current_block(iter);\n\t\tif (db)\n\t\t\treturn db;\n\t}\n}\n\n#define cea_db_iter_for_each(__db, __iter) \\\n\twhile (((__db) = __cea_db_iter_next(__iter)))\n\nstatic void cea_db_iter_end(struct cea_db_iter *iter)\n{\n\tdisplayid_iter_end(&iter->displayid_iter);\n\tdrm_edid_iter_end(&iter->edid_iter);\n\n\tmemset(iter, 0, sizeof(*iter));\n}\n\nstatic bool cea_db_is_hdmi_vsdb(const struct cea_db *db)\n{\n\treturn cea_db_is_vendor(db, HDMI_IEEE_OUI) &&\n\t\tcea_db_payload_len(db) >= 5;\n}\n\nstatic bool cea_db_is_hdmi_forum_vsdb(const struct cea_db *db)\n{\n\treturn cea_db_is_vendor(db, HDMI_FORUM_IEEE_OUI) &&\n\t\tcea_db_payload_len(db) >= 7;\n}\n\nstatic bool cea_db_is_hdmi_forum_eeodb(const void *db)\n{\n\treturn cea_db_is_extended_tag(db, CTA_EXT_DB_HF_EEODB) &&\n\t\tcea_db_payload_len(db) >= 2;\n}\n\nstatic bool cea_db_is_microsoft_vsdb(const struct cea_db *db)\n{\n\treturn cea_db_is_vendor(db, MICROSOFT_IEEE_OUI) &&\n\t\tcea_db_payload_len(db) == 21;\n}\n\nstatic bool cea_db_is_vcdb(const struct cea_db *db)\n{\n\treturn cea_db_is_extended_tag(db, CTA_EXT_DB_VIDEO_CAP) &&\n\t\tcea_db_payload_len(db) == 2;\n}\n\nstatic bool cea_db_is_hdmi_forum_scdb(const struct cea_db *db)\n{\n\treturn cea_db_is_extended_tag(db, CTA_EXT_DB_HF_SCDB) &&\n\t\tcea_db_payload_len(db) >= 7;\n}\n\nstatic bool cea_db_is_y420cmdb(const struct cea_db *db)\n{\n\treturn cea_db_is_extended_tag(db, CTA_EXT_DB_420_VIDEO_CAP_MAP);\n}\n\nstatic bool cea_db_is_y420vdb(const struct cea_db *db)\n{\n\treturn cea_db_is_extended_tag(db, CTA_EXT_DB_420_VIDEO_DATA);\n}\n\nstatic bool cea_db_is_hdmi_hdr_metadata_block(const struct cea_db *db)\n{\n\treturn cea_db_is_extended_tag(db, CTA_EXT_DB_HDR_STATIC_METADATA) &&\n\t\tcea_db_payload_len(db) >= 3;\n}\n\n \nstatic int edid_hfeeodb_extension_block_count(const struct edid *edid)\n{\n\tconst u8 *cta;\n\n\t \n\tif (!edid_extension_block_count(edid))\n\t\treturn 0;\n\n\t \n\tcta = edid_extension_block_data(edid, 0);\n\tif (edid_block_tag(cta) != CEA_EXT || cea_revision(cta) < 3)\n\t\treturn 0;\n\n\t \n\tif (cea_db_collection_size(cta) < 3)\n\t\treturn 0;\n\n\t \n\tif (!cea_db_is_hdmi_forum_eeodb(&cta[4]))\n\t\treturn 0;\n\n\treturn cta[4 + 2];\n}\n\n \nstatic void parse_cta_y420cmdb(struct drm_connector *connector,\n\t\t\t       const struct cea_db *db, u64 *y420cmdb_map)\n{\n\tstruct drm_display_info *info = &connector->display_info;\n\tint i, map_len = cea_db_payload_len(db) - 1;\n\tconst u8 *data = cea_db_data(db) + 1;\n\tu64 map = 0;\n\n\tif (map_len == 0) {\n\t\t \n\t\tmap = U64_MAX;\n\t\tgoto out;\n\t}\n\n\t \n\tif (WARN_ON_ONCE(map_len > 8))\n\t\tmap_len = 8;\n\n\tfor (i = 0; i < map_len; i++)\n\t\tmap |= (u64)data[i] << (8 * i);\n\nout:\n\tif (map)\n\t\tinfo->color_formats |= DRM_COLOR_FORMAT_YCBCR420;\n\n\t*y420cmdb_map = map;\n}\n\nstatic int add_cea_modes(struct drm_connector *connector,\n\t\t\t const struct drm_edid *drm_edid)\n{\n\tconst struct cea_db *db;\n\tstruct cea_db_iter iter;\n\tint modes;\n\n\t \n\tmodes = add_cta_vdb_modes(connector);\n\n\tcea_db_iter_edid_begin(drm_edid, &iter);\n\tcea_db_iter_for_each(db, &iter) {\n\t\tif (cea_db_is_hdmi_vsdb(db)) {\n\t\t\tmodes += do_hdmi_vsdb_modes(connector, (const u8 *)db,\n\t\t\t\t\t\t    cea_db_payload_len(db));\n\t\t} else if (cea_db_is_y420vdb(db)) {\n\t\t\tconst u8 *vdb420 = cea_db_data(db) + 1;\n\n\t\t\t \n\t\t\tmodes += do_y420vdb_modes(connector, vdb420,\n\t\t\t\t\t\t  cea_db_payload_len(db) - 1);\n\t\t}\n\t}\n\tcea_db_iter_end(&iter);\n\n\treturn modes;\n}\n\nstatic void fixup_detailed_cea_mode_clock(struct drm_connector *connector,\n\t\t\t\t\t  struct drm_display_mode *mode)\n{\n\tconst struct drm_display_mode *cea_mode;\n\tint clock1, clock2, clock;\n\tu8 vic;\n\tconst char *type;\n\n\t \n\tvic = drm_match_cea_mode_clock_tolerance(mode, 5);\n\tif (drm_valid_cea_vic(vic)) {\n\t\ttype = \"CEA\";\n\t\tcea_mode = cea_mode_for_vic(vic);\n\t\tclock1 = cea_mode->clock;\n\t\tclock2 = cea_mode_alternate_clock(cea_mode);\n\t} else {\n\t\tvic = drm_match_hdmi_mode_clock_tolerance(mode, 5);\n\t\tif (drm_valid_hdmi_vic(vic)) {\n\t\t\ttype = \"HDMI\";\n\t\t\tcea_mode = &edid_4k_modes[vic];\n\t\t\tclock1 = cea_mode->clock;\n\t\t\tclock2 = hdmi_mode_alternate_clock(cea_mode);\n\t\t} else {\n\t\t\treturn;\n\t\t}\n\t}\n\n\t \n\tif (abs(mode->clock - clock1) < abs(mode->clock - clock2))\n\t\tclock = clock1;\n\telse\n\t\tclock = clock2;\n\n\tif (mode->clock == clock)\n\t\treturn;\n\n\tdrm_dbg_kms(connector->dev,\n\t\t    \"[CONNECTOR:%d:%s] detailed mode matches %s VIC %d, adjusting clock %d -> %d\\n\",\n\t\t    connector->base.id, connector->name,\n\t\t    type, vic, mode->clock, clock);\n\tmode->clock = clock;\n}\n\nstatic void drm_calculate_luminance_range(struct drm_connector *connector)\n{\n\tstruct hdr_static_metadata *hdr_metadata = &connector->hdr_sink_metadata.hdmi_type1;\n\tstruct drm_luminance_range_info *luminance_range =\n\t\t&connector->display_info.luminance_range;\n\tstatic const u8 pre_computed_values[] = {\n\t\t50, 51, 52, 53, 55, 56, 57, 58, 59, 61, 62, 63, 65, 66, 68, 69,\n\t\t71, 72, 74, 75, 77, 79, 81, 82, 84, 86, 88, 90, 92, 94, 96, 98\n\t};\n\tu32 max_avg, min_cll, max, min, q, r;\n\n\tif (!(hdr_metadata->metadata_type & BIT(HDMI_STATIC_METADATA_TYPE1)))\n\t\treturn;\n\n\tmax_avg = hdr_metadata->max_fall;\n\tmin_cll = hdr_metadata->min_cll;\n\n\t \n\tq = max_avg >> 5;\n\tr = max_avg % 32;\n\tmax = (1 << q) * pre_computed_values[r];\n\n\t \n\tq = DIV_ROUND_CLOSEST(min_cll, 255);\n\tmin = max * DIV_ROUND_CLOSEST((q * q), 100);\n\n\tluminance_range->min_luminance = min;\n\tluminance_range->max_luminance = max;\n}\n\nstatic uint8_t eotf_supported(const u8 *edid_ext)\n{\n\treturn edid_ext[2] &\n\t\t(BIT(HDMI_EOTF_TRADITIONAL_GAMMA_SDR) |\n\t\t BIT(HDMI_EOTF_TRADITIONAL_GAMMA_HDR) |\n\t\t BIT(HDMI_EOTF_SMPTE_ST2084) |\n\t\t BIT(HDMI_EOTF_BT_2100_HLG));\n}\n\nstatic uint8_t hdr_metadata_type(const u8 *edid_ext)\n{\n\treturn edid_ext[3] &\n\t\tBIT(HDMI_STATIC_METADATA_TYPE1);\n}\n\nstatic void\ndrm_parse_hdr_metadata_block(struct drm_connector *connector, const u8 *db)\n{\n\tu16 len;\n\n\tlen = cea_db_payload_len(db);\n\n\tconnector->hdr_sink_metadata.hdmi_type1.eotf =\n\t\t\t\t\t\teotf_supported(db);\n\tconnector->hdr_sink_metadata.hdmi_type1.metadata_type =\n\t\t\t\t\t\thdr_metadata_type(db);\n\n\tif (len >= 4)\n\t\tconnector->hdr_sink_metadata.hdmi_type1.max_cll = db[4];\n\tif (len >= 5)\n\t\tconnector->hdr_sink_metadata.hdmi_type1.max_fall = db[5];\n\tif (len >= 6) {\n\t\tconnector->hdr_sink_metadata.hdmi_type1.min_cll = db[6];\n\n\t\t \n\t\tdrm_calculate_luminance_range(connector);\n\t}\n}\n\n \nstatic void\ndrm_parse_hdmi_vsdb_audio(struct drm_connector *connector, const u8 *db)\n{\n\tu8 len = cea_db_payload_len(db);\n\n\tif (len >= 6 && (db[6] & (1 << 7)))\n\t\tconnector->eld[DRM_ELD_SAD_COUNT_CONN_TYPE] |= DRM_ELD_SUPPORTS_AI;\n\n\tif (len >= 10 && hdmi_vsdb_latency_present(db)) {\n\t\tconnector->latency_present[0] = true;\n\t\tconnector->video_latency[0] = db[9];\n\t\tconnector->audio_latency[0] = db[10];\n\t}\n\n\tif (len >= 12 && hdmi_vsdb_i_latency_present(db)) {\n\t\tconnector->latency_present[1] = true;\n\t\tconnector->video_latency[1] = db[11];\n\t\tconnector->audio_latency[1] = db[12];\n\t}\n\n\tdrm_dbg_kms(connector->dev,\n\t\t    \"[CONNECTOR:%d:%s] HDMI: latency present %d %d, video latency %d %d, audio latency %d %d\\n\",\n\t\t    connector->base.id, connector->name,\n\t\t    connector->latency_present[0], connector->latency_present[1],\n\t\t    connector->video_latency[0], connector->video_latency[1],\n\t\t    connector->audio_latency[0], connector->audio_latency[1]);\n}\n\nstatic void\nmonitor_name(const struct detailed_timing *timing, void *data)\n{\n\tconst char **res = data;\n\n\tif (!is_display_descriptor(timing, EDID_DETAIL_MONITOR_NAME))\n\t\treturn;\n\n\t*res = timing->data.other_data.data.str.str;\n}\n\nstatic int get_monitor_name(const struct drm_edid *drm_edid, char name[13])\n{\n\tconst char *edid_name = NULL;\n\tint mnl;\n\n\tif (!drm_edid || !name)\n\t\treturn 0;\n\n\tdrm_for_each_detailed_block(drm_edid, monitor_name, &edid_name);\n\tfor (mnl = 0; edid_name && mnl < 13; mnl++) {\n\t\tif (edid_name[mnl] == 0x0a)\n\t\t\tbreak;\n\n\t\tname[mnl] = edid_name[mnl];\n\t}\n\n\treturn mnl;\n}\n\n \nvoid drm_edid_get_monitor_name(const struct edid *edid, char *name, int bufsize)\n{\n\tint name_length = 0;\n\n\tif (bufsize <= 0)\n\t\treturn;\n\n\tif (edid) {\n\t\tchar buf[13];\n\t\tstruct drm_edid drm_edid = {\n\t\t\t.edid = edid,\n\t\t\t.size = edid_size(edid),\n\t\t};\n\n\t\tname_length = min(get_monitor_name(&drm_edid, buf), bufsize - 1);\n\t\tmemcpy(name, buf, name_length);\n\t}\n\n\tname[name_length] = '\\0';\n}\nEXPORT_SYMBOL(drm_edid_get_monitor_name);\n\nstatic void clear_eld(struct drm_connector *connector)\n{\n\tmemset(connector->eld, 0, sizeof(connector->eld));\n\n\tconnector->latency_present[0] = false;\n\tconnector->latency_present[1] = false;\n\tconnector->video_latency[0] = 0;\n\tconnector->audio_latency[0] = 0;\n\tconnector->video_latency[1] = 0;\n\tconnector->audio_latency[1] = 0;\n}\n\n \nstatic void drm_edid_to_eld(struct drm_connector *connector,\n\t\t\t    const struct drm_edid *drm_edid)\n{\n\tconst struct drm_display_info *info = &connector->display_info;\n\tconst struct cea_db *db;\n\tstruct cea_db_iter iter;\n\tuint8_t *eld = connector->eld;\n\tint total_sad_count = 0;\n\tint mnl;\n\n\tif (!drm_edid)\n\t\treturn;\n\n\tmnl = get_monitor_name(drm_edid, &eld[DRM_ELD_MONITOR_NAME_STRING]);\n\tdrm_dbg_kms(connector->dev, \"[CONNECTOR:%d:%s] ELD monitor %s\\n\",\n\t\t    connector->base.id, connector->name,\n\t\t    &eld[DRM_ELD_MONITOR_NAME_STRING]);\n\n\teld[DRM_ELD_CEA_EDID_VER_MNL] = info->cea_rev << DRM_ELD_CEA_EDID_VER_SHIFT;\n\teld[DRM_ELD_CEA_EDID_VER_MNL] |= mnl;\n\n\teld[DRM_ELD_VER] = DRM_ELD_VER_CEA861D;\n\n\teld[DRM_ELD_MANUFACTURER_NAME0] = drm_edid->edid->mfg_id[0];\n\teld[DRM_ELD_MANUFACTURER_NAME1] = drm_edid->edid->mfg_id[1];\n\teld[DRM_ELD_PRODUCT_CODE0] = drm_edid->edid->prod_code[0];\n\teld[DRM_ELD_PRODUCT_CODE1] = drm_edid->edid->prod_code[1];\n\n\tcea_db_iter_edid_begin(drm_edid, &iter);\n\tcea_db_iter_for_each(db, &iter) {\n\t\tconst u8 *data = cea_db_data(db);\n\t\tint len = cea_db_payload_len(db);\n\t\tint sad_count;\n\n\t\tswitch (cea_db_tag(db)) {\n\t\tcase CTA_DB_AUDIO:\n\t\t\t \n\t\t\tsad_count = min(len / 3, 15 - total_sad_count);\n\t\t\tif (sad_count >= 1)\n\t\t\t\tmemcpy(&eld[DRM_ELD_CEA_SAD(mnl, total_sad_count)],\n\t\t\t\t       data, sad_count * 3);\n\t\t\ttotal_sad_count += sad_count;\n\t\t\tbreak;\n\t\tcase CTA_DB_SPEAKER:\n\t\t\t \n\t\t\tif (len >= 1)\n\t\t\t\teld[DRM_ELD_SPEAKER] = data[0];\n\t\t\tbreak;\n\t\tcase CTA_DB_VENDOR:\n\t\t\t \n\t\t\tif (cea_db_is_hdmi_vsdb(db))\n\t\t\t\tdrm_parse_hdmi_vsdb_audio(connector, (const u8 *)db);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\tcea_db_iter_end(&iter);\n\n\teld[DRM_ELD_SAD_COUNT_CONN_TYPE] |= total_sad_count << DRM_ELD_SAD_COUNT_SHIFT;\n\n\tif (connector->connector_type == DRM_MODE_CONNECTOR_DisplayPort ||\n\t    connector->connector_type == DRM_MODE_CONNECTOR_eDP)\n\t\teld[DRM_ELD_SAD_COUNT_CONN_TYPE] |= DRM_ELD_CONN_TYPE_DP;\n\telse\n\t\teld[DRM_ELD_SAD_COUNT_CONN_TYPE] |= DRM_ELD_CONN_TYPE_HDMI;\n\n\teld[DRM_ELD_BASELINE_ELD_LEN] =\n\t\tDIV_ROUND_UP(drm_eld_calc_baseline_block_size(eld), 4);\n\n\tdrm_dbg_kms(connector->dev, \"[CONNECTOR:%d:%s] ELD size %d, SAD count %d\\n\",\n\t\t    connector->base.id, connector->name,\n\t\t    drm_eld_size(eld), total_sad_count);\n}\n\nstatic int _drm_edid_to_sad(const struct drm_edid *drm_edid,\n\t\t\t    struct cea_sad **sads)\n{\n\tconst struct cea_db *db;\n\tstruct cea_db_iter iter;\n\tint count = 0;\n\n\tcea_db_iter_edid_begin(drm_edid, &iter);\n\tcea_db_iter_for_each(db, &iter) {\n\t\tif (cea_db_tag(db) == CTA_DB_AUDIO) {\n\t\t\tint j;\n\n\t\t\tcount = cea_db_payload_len(db) / 3;  \n\t\t\t*sads = kcalloc(count, sizeof(**sads), GFP_KERNEL);\n\t\t\tif (!*sads)\n\t\t\t\treturn -ENOMEM;\n\t\t\tfor (j = 0; j < count; j++) {\n\t\t\t\tconst u8 *sad = &db->data[j * 3];\n\n\t\t\t\t(*sads)[j].format = (sad[0] & 0x78) >> 3;\n\t\t\t\t(*sads)[j].channels = sad[0] & 0x7;\n\t\t\t\t(*sads)[j].freq = sad[1] & 0x7F;\n\t\t\t\t(*sads)[j].byte2 = sad[2];\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\tcea_db_iter_end(&iter);\n\n\tDRM_DEBUG_KMS(\"Found %d Short Audio Descriptors\\n\", count);\n\n\treturn count;\n}\n\n \nint drm_edid_to_sad(const struct edid *edid, struct cea_sad **sads)\n{\n\tstruct drm_edid drm_edid;\n\n\treturn _drm_edid_to_sad(drm_edid_legacy_init(&drm_edid, edid), sads);\n}\nEXPORT_SYMBOL(drm_edid_to_sad);\n\nstatic int _drm_edid_to_speaker_allocation(const struct drm_edid *drm_edid,\n\t\t\t\t\t   u8 **sadb)\n{\n\tconst struct cea_db *db;\n\tstruct cea_db_iter iter;\n\tint count = 0;\n\n\tcea_db_iter_edid_begin(drm_edid, &iter);\n\tcea_db_iter_for_each(db, &iter) {\n\t\tif (cea_db_tag(db) == CTA_DB_SPEAKER &&\n\t\t    cea_db_payload_len(db) == 3) {\n\t\t\t*sadb = kmemdup(db->data, cea_db_payload_len(db),\n\t\t\t\t\tGFP_KERNEL);\n\t\t\tif (!*sadb)\n\t\t\t\treturn -ENOMEM;\n\t\t\tcount = cea_db_payload_len(db);\n\t\t\tbreak;\n\t\t}\n\t}\n\tcea_db_iter_end(&iter);\n\n\tDRM_DEBUG_KMS(\"Found %d Speaker Allocation Data Blocks\\n\", count);\n\n\treturn count;\n}\n\n \nint drm_edid_to_speaker_allocation(const struct edid *edid, u8 **sadb)\n{\n\tstruct drm_edid drm_edid;\n\n\treturn _drm_edid_to_speaker_allocation(drm_edid_legacy_init(&drm_edid, edid),\n\t\t\t\t\t       sadb);\n}\nEXPORT_SYMBOL(drm_edid_to_speaker_allocation);\n\n \nint drm_av_sync_delay(struct drm_connector *connector,\n\t\t      const struct drm_display_mode *mode)\n{\n\tint i = !!(mode->flags & DRM_MODE_FLAG_INTERLACE);\n\tint a, v;\n\n\tif (!connector->latency_present[0])\n\t\treturn 0;\n\tif (!connector->latency_present[1])\n\t\ti = 0;\n\n\ta = connector->audio_latency[i];\n\tv = connector->video_latency[i];\n\n\t \n\tif (a == 255 || v == 255)\n\t\treturn 0;\n\n\t \n\tif (a)\n\t\ta = min(2 * (a - 1), 500);\n\tif (v)\n\t\tv = min(2 * (v - 1), 500);\n\n\treturn max(v - a, 0);\n}\nEXPORT_SYMBOL(drm_av_sync_delay);\n\nstatic bool _drm_detect_hdmi_monitor(const struct drm_edid *drm_edid)\n{\n\tconst struct cea_db *db;\n\tstruct cea_db_iter iter;\n\tbool hdmi = false;\n\n\t \n\tcea_db_iter_edid_begin(drm_edid, &iter);\n\tcea_db_iter_for_each(db, &iter) {\n\t\tif (cea_db_is_hdmi_vsdb(db)) {\n\t\t\thdmi = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\tcea_db_iter_end(&iter);\n\n\treturn hdmi;\n}\n\n \nbool drm_detect_hdmi_monitor(const struct edid *edid)\n{\n\tstruct drm_edid drm_edid;\n\n\treturn _drm_detect_hdmi_monitor(drm_edid_legacy_init(&drm_edid, edid));\n}\nEXPORT_SYMBOL(drm_detect_hdmi_monitor);\n\nstatic bool _drm_detect_monitor_audio(const struct drm_edid *drm_edid)\n{\n\tstruct drm_edid_iter edid_iter;\n\tconst struct cea_db *db;\n\tstruct cea_db_iter iter;\n\tconst u8 *edid_ext;\n\tbool has_audio = false;\n\n\tdrm_edid_iter_begin(drm_edid, &edid_iter);\n\tdrm_edid_iter_for_each(edid_ext, &edid_iter) {\n\t\tif (edid_ext[0] == CEA_EXT) {\n\t\t\thas_audio = edid_ext[3] & EDID_BASIC_AUDIO;\n\t\t\tif (has_audio)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\tdrm_edid_iter_end(&edid_iter);\n\n\tif (has_audio) {\n\t\tDRM_DEBUG_KMS(\"Monitor has basic audio support\\n\");\n\t\tgoto end;\n\t}\n\n\tcea_db_iter_edid_begin(drm_edid, &iter);\n\tcea_db_iter_for_each(db, &iter) {\n\t\tif (cea_db_tag(db) == CTA_DB_AUDIO) {\n\t\t\tconst u8 *data = cea_db_data(db);\n\t\t\tint i;\n\n\t\t\tfor (i = 0; i < cea_db_payload_len(db); i += 3)\n\t\t\t\tDRM_DEBUG_KMS(\"CEA audio format %d\\n\",\n\t\t\t\t\t      (data[i] >> 3) & 0xf);\n\t\t\thas_audio = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\tcea_db_iter_end(&iter);\n\nend:\n\treturn has_audio;\n}\n\n \nbool drm_detect_monitor_audio(const struct edid *edid)\n{\n\tstruct drm_edid drm_edid;\n\n\treturn _drm_detect_monitor_audio(drm_edid_legacy_init(&drm_edid, edid));\n}\nEXPORT_SYMBOL(drm_detect_monitor_audio);\n\n\n \nenum hdmi_quantization_range\ndrm_default_rgb_quant_range(const struct drm_display_mode *mode)\n{\n\t \n\treturn drm_match_cea_mode(mode) > 1 ?\n\t\tHDMI_QUANTIZATION_RANGE_LIMITED :\n\t\tHDMI_QUANTIZATION_RANGE_FULL;\n}\nEXPORT_SYMBOL(drm_default_rgb_quant_range);\n\n \nstatic void parse_cta_vdb(struct drm_connector *connector, const struct cea_db *db)\n{\n\tstruct drm_display_info *info = &connector->display_info;\n\tint i, vic_index, len = cea_db_payload_len(db);\n\tconst u8 *svds = cea_db_data(db);\n\tu8 *vics;\n\n\tif (!len)\n\t\treturn;\n\n\t \n\tvics = krealloc(info->vics, info->vics_len + len, GFP_KERNEL);\n\tif (!vics)\n\t\treturn;\n\n\tvic_index = info->vics_len;\n\tinfo->vics_len += len;\n\tinfo->vics = vics;\n\n\tfor (i = 0; i < len; i++) {\n\t\tu8 vic = svd_to_vic(svds[i]);\n\n\t\tif (!drm_valid_cea_vic(vic))\n\t\t\tvic = 0;\n\n\t\tinfo->vics[vic_index++] = vic;\n\t}\n}\n\n \nstatic void update_cta_y420cmdb(struct drm_connector *connector, u64 y420cmdb_map)\n{\n\tstruct drm_display_info *info = &connector->display_info;\n\tstruct drm_hdmi_info *hdmi = &info->hdmi;\n\tint i, len = min_t(int, info->vics_len, BITS_PER_TYPE(y420cmdb_map));\n\n\tfor (i = 0; i < len; i++) {\n\t\tu8 vic = info->vics[i];\n\n\t\tif (vic && y420cmdb_map & BIT_ULL(i))\n\t\t\tbitmap_set(hdmi->y420_cmdb_modes, vic, 1);\n\t}\n}\n\nstatic bool cta_vdb_has_vic(const struct drm_connector *connector, u8 vic)\n{\n\tconst struct drm_display_info *info = &connector->display_info;\n\tint i;\n\n\tif (!vic || !info->vics)\n\t\treturn false;\n\n\tfor (i = 0; i < info->vics_len; i++) {\n\t\tif (info->vics[i] == vic)\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}\n\n \nstatic void parse_cta_y420vdb(struct drm_connector *connector,\n\t\t\t      const struct cea_db *db)\n{\n\tstruct drm_display_info *info = &connector->display_info;\n\tstruct drm_hdmi_info *hdmi = &info->hdmi;\n\tconst u8 *svds = cea_db_data(db) + 1;\n\tint i;\n\n\tfor (i = 0; i < cea_db_payload_len(db) - 1; i++) {\n\t\tu8 vic = svd_to_vic(svds[i]);\n\n\t\tif (!drm_valid_cea_vic(vic))\n\t\t\tcontinue;\n\n\t\tbitmap_set(hdmi->y420_vdb_modes, vic, 1);\n\t\tinfo->color_formats |= DRM_COLOR_FORMAT_YCBCR420;\n\t}\n}\n\nstatic void drm_parse_vcdb(struct drm_connector *connector, const u8 *db)\n{\n\tstruct drm_display_info *info = &connector->display_info;\n\n\tdrm_dbg_kms(connector->dev, \"[CONNECTOR:%d:%s] CEA VCDB 0x%02x\\n\",\n\t\t    connector->base.id, connector->name, db[2]);\n\n\tif (db[2] & EDID_CEA_VCDB_QS)\n\t\tinfo->rgb_quant_range_selectable = true;\n}\n\nstatic\nvoid drm_get_max_frl_rate(int max_frl_rate, u8 *max_lanes, u8 *max_rate_per_lane)\n{\n\tswitch (max_frl_rate) {\n\tcase 1:\n\t\t*max_lanes = 3;\n\t\t*max_rate_per_lane = 3;\n\t\tbreak;\n\tcase 2:\n\t\t*max_lanes = 3;\n\t\t*max_rate_per_lane = 6;\n\t\tbreak;\n\tcase 3:\n\t\t*max_lanes = 4;\n\t\t*max_rate_per_lane = 6;\n\t\tbreak;\n\tcase 4:\n\t\t*max_lanes = 4;\n\t\t*max_rate_per_lane = 8;\n\t\tbreak;\n\tcase 5:\n\t\t*max_lanes = 4;\n\t\t*max_rate_per_lane = 10;\n\t\tbreak;\n\tcase 6:\n\t\t*max_lanes = 4;\n\t\t*max_rate_per_lane = 12;\n\t\tbreak;\n\tcase 0:\n\tdefault:\n\t\t*max_lanes = 0;\n\t\t*max_rate_per_lane = 0;\n\t}\n}\n\nstatic void drm_parse_ycbcr420_deep_color_info(struct drm_connector *connector,\n\t\t\t\t\t       const u8 *db)\n{\n\tu8 dc_mask;\n\tstruct drm_hdmi_info *hdmi = &connector->display_info.hdmi;\n\n\tdc_mask = db[7] & DRM_EDID_YCBCR420_DC_MASK;\n\thdmi->y420_dc_modes = dc_mask;\n}\n\nstatic void drm_parse_dsc_info(struct drm_hdmi_dsc_cap *hdmi_dsc,\n\t\t\t       const u8 *hf_scds)\n{\n\thdmi_dsc->v_1p2 = hf_scds[11] & DRM_EDID_DSC_1P2;\n\n\tif (!hdmi_dsc->v_1p2)\n\t\treturn;\n\n\thdmi_dsc->native_420 = hf_scds[11] & DRM_EDID_DSC_NATIVE_420;\n\thdmi_dsc->all_bpp = hf_scds[11] & DRM_EDID_DSC_ALL_BPP;\n\n\tif (hf_scds[11] & DRM_EDID_DSC_16BPC)\n\t\thdmi_dsc->bpc_supported = 16;\n\telse if (hf_scds[11] & DRM_EDID_DSC_12BPC)\n\t\thdmi_dsc->bpc_supported = 12;\n\telse if (hf_scds[11] & DRM_EDID_DSC_10BPC)\n\t\thdmi_dsc->bpc_supported = 10;\n\telse\n\t\t \n\t\thdmi_dsc->bpc_supported = 8;\n\n\tif (cea_db_payload_len(hf_scds) >= 12 && hf_scds[12]) {\n\t\tu8 dsc_max_slices;\n\t\tu8 dsc_max_frl_rate;\n\n\t\tdsc_max_frl_rate = (hf_scds[12] & DRM_EDID_DSC_MAX_FRL_RATE_MASK) >> 4;\n\t\tdrm_get_max_frl_rate(dsc_max_frl_rate, &hdmi_dsc->max_lanes,\n\t\t\t\t     &hdmi_dsc->max_frl_rate_per_lane);\n\n\t\tdsc_max_slices = hf_scds[12] & DRM_EDID_DSC_MAX_SLICES;\n\n\t\tswitch (dsc_max_slices) {\n\t\tcase 1:\n\t\t\thdmi_dsc->max_slices = 1;\n\t\t\thdmi_dsc->clk_per_slice = 340;\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\thdmi_dsc->max_slices = 2;\n\t\t\thdmi_dsc->clk_per_slice = 340;\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\thdmi_dsc->max_slices = 4;\n\t\t\thdmi_dsc->clk_per_slice = 340;\n\t\t\tbreak;\n\t\tcase 4:\n\t\t\thdmi_dsc->max_slices = 8;\n\t\t\thdmi_dsc->clk_per_slice = 340;\n\t\t\tbreak;\n\t\tcase 5:\n\t\t\thdmi_dsc->max_slices = 8;\n\t\t\thdmi_dsc->clk_per_slice = 400;\n\t\t\tbreak;\n\t\tcase 6:\n\t\t\thdmi_dsc->max_slices = 12;\n\t\t\thdmi_dsc->clk_per_slice = 400;\n\t\t\tbreak;\n\t\tcase 7:\n\t\t\thdmi_dsc->max_slices = 16;\n\t\t\thdmi_dsc->clk_per_slice = 400;\n\t\t\tbreak;\n\t\tcase 0:\n\t\tdefault:\n\t\t\thdmi_dsc->max_slices = 0;\n\t\t\thdmi_dsc->clk_per_slice = 0;\n\t\t}\n\t}\n\n\tif (cea_db_payload_len(hf_scds) >= 13 && hf_scds[13])\n\t\thdmi_dsc->total_chunk_kbytes = hf_scds[13] & DRM_EDID_DSC_TOTAL_CHUNK_KBYTES;\n}\n\n \nstatic void drm_parse_hdmi_forum_scds(struct drm_connector *connector,\n\t\t\t\t      const u8 *hf_scds)\n{\n\tstruct drm_display_info *info = &connector->display_info;\n\tstruct drm_hdmi_info *hdmi = &info->hdmi;\n\tstruct drm_hdmi_dsc_cap *hdmi_dsc = &hdmi->dsc_cap;\n\tint max_tmds_clock = 0;\n\tu8 max_frl_rate = 0;\n\tbool dsc_support = false;\n\n\tinfo->has_hdmi_infoframe = true;\n\n\tif (hf_scds[6] & 0x80) {\n\t\thdmi->scdc.supported = true;\n\t\tif (hf_scds[6] & 0x40)\n\t\t\thdmi->scdc.read_request = true;\n\t}\n\n\t \n\n\tif (hf_scds[5]) {\n\t\tstruct drm_scdc *scdc = &hdmi->scdc;\n\n\t\t \n\t\tmax_tmds_clock = hf_scds[5] * 5000;\n\n\t\tif (max_tmds_clock > 340000) {\n\t\t\tinfo->max_tmds_clock = max_tmds_clock;\n\t\t}\n\n\t\tif (scdc->supported) {\n\t\t\tscdc->scrambling.supported = true;\n\n\t\t\t \n\t\t\tif ((hf_scds[6] & 0x8))\n\t\t\t\tscdc->scrambling.low_rates = true;\n\t\t}\n\t}\n\n\tif (hf_scds[7]) {\n\t\tmax_frl_rate = (hf_scds[7] & DRM_EDID_MAX_FRL_RATE_MASK) >> 4;\n\t\tdrm_get_max_frl_rate(max_frl_rate, &hdmi->max_lanes,\n\t\t\t\t     &hdmi->max_frl_rate_per_lane);\n\t}\n\n\tdrm_parse_ycbcr420_deep_color_info(connector, hf_scds);\n\n\tif (cea_db_payload_len(hf_scds) >= 11 && hf_scds[11]) {\n\t\tdrm_parse_dsc_info(hdmi_dsc, hf_scds);\n\t\tdsc_support = true;\n\t}\n\n\tdrm_dbg_kms(connector->dev,\n\t\t    \"[CONNECTOR:%d:%s] HF-VSDB: max TMDS clock: %d KHz, HDMI 2.1 support: %s, DSC 1.2 support: %s\\n\",\n\t\t    connector->base.id, connector->name,\n\t\t    max_tmds_clock, str_yes_no(max_frl_rate), str_yes_no(dsc_support));\n}\n\nstatic void drm_parse_hdmi_deep_color_info(struct drm_connector *connector,\n\t\t\t\t\t   const u8 *hdmi)\n{\n\tstruct drm_display_info *info = &connector->display_info;\n\tunsigned int dc_bpc = 0;\n\n\t \n\tinfo->bpc = 8;\n\n\tif (cea_db_payload_len(hdmi) < 6)\n\t\treturn;\n\n\tif (hdmi[6] & DRM_EDID_HDMI_DC_30) {\n\t\tdc_bpc = 10;\n\t\tinfo->edid_hdmi_rgb444_dc_modes |= DRM_EDID_HDMI_DC_30;\n\t\tdrm_dbg_kms(connector->dev, \"[CONNECTOR:%d:%s] HDMI sink does deep color 30.\\n\",\n\t\t\t    connector->base.id, connector->name);\n\t}\n\n\tif (hdmi[6] & DRM_EDID_HDMI_DC_36) {\n\t\tdc_bpc = 12;\n\t\tinfo->edid_hdmi_rgb444_dc_modes |= DRM_EDID_HDMI_DC_36;\n\t\tdrm_dbg_kms(connector->dev, \"[CONNECTOR:%d:%s] HDMI sink does deep color 36.\\n\",\n\t\t\t    connector->base.id, connector->name);\n\t}\n\n\tif (hdmi[6] & DRM_EDID_HDMI_DC_48) {\n\t\tdc_bpc = 16;\n\t\tinfo->edid_hdmi_rgb444_dc_modes |= DRM_EDID_HDMI_DC_48;\n\t\tdrm_dbg_kms(connector->dev, \"[CONNECTOR:%d:%s] HDMI sink does deep color 48.\\n\",\n\t\t\t    connector->base.id, connector->name);\n\t}\n\n\tif (dc_bpc == 0) {\n\t\tdrm_dbg_kms(connector->dev, \"[CONNECTOR:%d:%s] No deep color support on this HDMI sink.\\n\",\n\t\t\t    connector->base.id, connector->name);\n\t\treturn;\n\t}\n\n\tdrm_dbg_kms(connector->dev, \"[CONNECTOR:%d:%s] Assigning HDMI sink color depth as %d bpc.\\n\",\n\t\t    connector->base.id, connector->name, dc_bpc);\n\tinfo->bpc = dc_bpc;\n\n\t \n\tif (hdmi[6] & DRM_EDID_HDMI_DC_Y444) {\n\t\tinfo->edid_hdmi_ycbcr444_dc_modes = info->edid_hdmi_rgb444_dc_modes;\n\t\tdrm_dbg_kms(connector->dev, \"[CONNECTOR:%d:%s] HDMI sink does YCRCB444 in deep color.\\n\",\n\t\t\t    connector->base.id, connector->name);\n\t}\n\n\t \n\tif (!(hdmi[6] & DRM_EDID_HDMI_DC_36)) {\n\t\tdrm_dbg_kms(connector->dev, \"[CONNECTOR:%d:%s] HDMI sink should do DC_36, but does not!\\n\",\n\t\t\t    connector->base.id, connector->name);\n\t}\n}\n\n \nstatic void\ndrm_parse_hdmi_vsdb_video(struct drm_connector *connector, const u8 *db)\n{\n\tstruct drm_display_info *info = &connector->display_info;\n\tu8 len = cea_db_payload_len(db);\n\n\tinfo->is_hdmi = true;\n\n\tif (len >= 6)\n\t\tinfo->dvi_dual = db[6] & 1;\n\tif (len >= 7)\n\t\tinfo->max_tmds_clock = db[7] * 5000;\n\n\t \n\tif (len >= 8 && db[8] & BIT(5))\n\t\tinfo->has_hdmi_infoframe = true;\n\n\tdrm_dbg_kms(connector->dev, \"[CONNECTOR:%d:%s] HDMI: DVI dual %d, max TMDS clock %d kHz\\n\",\n\t\t    connector->base.id, connector->name,\n\t\t    info->dvi_dual, info->max_tmds_clock);\n\n\tdrm_parse_hdmi_deep_color_info(connector, db);\n}\n\n \nstatic void drm_parse_microsoft_vsdb(struct drm_connector *connector,\n\t\t\t\t     const u8 *db)\n{\n\tstruct drm_display_info *info = &connector->display_info;\n\tu8 version = db[4];\n\tbool desktop_usage = db[5] & BIT(6);\n\n\t \n\tif (version == 1 || version == 2 || (version == 3 && !desktop_usage))\n\t\tinfo->non_desktop = true;\n\n\tdrm_dbg_kms(connector->dev,\n\t\t    \"[CONNECTOR:%d:%s] HMD or specialized display VSDB version %u: 0x%02x\\n\",\n\t\t    connector->base.id, connector->name, version, db[5]);\n}\n\nstatic void drm_parse_cea_ext(struct drm_connector *connector,\n\t\t\t      const struct drm_edid *drm_edid)\n{\n\tstruct drm_display_info *info = &connector->display_info;\n\tstruct drm_edid_iter edid_iter;\n\tconst struct cea_db *db;\n\tstruct cea_db_iter iter;\n\tconst u8 *edid_ext;\n\tu64 y420cmdb_map = 0;\n\n\tdrm_edid_iter_begin(drm_edid, &edid_iter);\n\tdrm_edid_iter_for_each(edid_ext, &edid_iter) {\n\t\tif (edid_ext[0] != CEA_EXT)\n\t\t\tcontinue;\n\n\t\tif (!info->cea_rev)\n\t\t\tinfo->cea_rev = edid_ext[1];\n\n\t\tif (info->cea_rev != edid_ext[1])\n\t\t\tdrm_dbg_kms(connector->dev,\n\t\t\t\t    \"[CONNECTOR:%d:%s] CEA extension version mismatch %u != %u\\n\",\n\t\t\t\t    connector->base.id, connector->name,\n\t\t\t\t    info->cea_rev, edid_ext[1]);\n\n\t\t \n\t\tinfo->color_formats = DRM_COLOR_FORMAT_RGB444;\n\t\tif (edid_ext[3] & EDID_CEA_YCRCB444)\n\t\t\tinfo->color_formats |= DRM_COLOR_FORMAT_YCBCR444;\n\t\tif (edid_ext[3] & EDID_CEA_YCRCB422)\n\t\t\tinfo->color_formats |= DRM_COLOR_FORMAT_YCBCR422;\n\t\tif (edid_ext[3] & EDID_BASIC_AUDIO)\n\t\t\tinfo->has_audio = true;\n\n\t}\n\tdrm_edid_iter_end(&edid_iter);\n\n\tcea_db_iter_edid_begin(drm_edid, &iter);\n\tcea_db_iter_for_each(db, &iter) {\n\t\t \n\t\tconst u8 *data = (const u8 *)db;\n\n\t\tif (cea_db_is_hdmi_vsdb(db))\n\t\t\tdrm_parse_hdmi_vsdb_video(connector, data);\n\t\telse if (cea_db_is_hdmi_forum_vsdb(db) ||\n\t\t\t cea_db_is_hdmi_forum_scdb(db))\n\t\t\tdrm_parse_hdmi_forum_scds(connector, data);\n\t\telse if (cea_db_is_microsoft_vsdb(db))\n\t\t\tdrm_parse_microsoft_vsdb(connector, data);\n\t\telse if (cea_db_is_y420cmdb(db))\n\t\t\tparse_cta_y420cmdb(connector, db, &y420cmdb_map);\n\t\telse if (cea_db_is_y420vdb(db))\n\t\t\tparse_cta_y420vdb(connector, db);\n\t\telse if (cea_db_is_vcdb(db))\n\t\t\tdrm_parse_vcdb(connector, data);\n\t\telse if (cea_db_is_hdmi_hdr_metadata_block(db))\n\t\t\tdrm_parse_hdr_metadata_block(connector, data);\n\t\telse if (cea_db_tag(db) == CTA_DB_VIDEO)\n\t\t\tparse_cta_vdb(connector, db);\n\t\telse if (cea_db_tag(db) == CTA_DB_AUDIO)\n\t\t\tinfo->has_audio = true;\n\t}\n\tcea_db_iter_end(&iter);\n\n\tif (y420cmdb_map)\n\t\tupdate_cta_y420cmdb(connector, y420cmdb_map);\n}\n\nstatic\nvoid get_monitor_range(const struct detailed_timing *timing, void *c)\n{\n\tstruct detailed_mode_closure *closure = c;\n\tstruct drm_display_info *info = &closure->connector->display_info;\n\tstruct drm_monitor_range_info *monitor_range = &info->monitor_range;\n\tconst struct detailed_non_pixel *data = &timing->data.other_data;\n\tconst struct detailed_data_monitor_range *range = &data->data.range;\n\tconst struct edid *edid = closure->drm_edid->edid;\n\n\tif (!is_display_descriptor(timing, EDID_DETAIL_MONITOR_RANGE))\n\t\treturn;\n\n\t \n\tif (range->flags != DRM_EDID_RANGE_LIMITS_ONLY_FLAG)\n\t\treturn;\n\n\tmonitor_range->min_vfreq = range->min_vfreq;\n\tmonitor_range->max_vfreq = range->max_vfreq;\n\n\tif (edid->revision >= 4) {\n\t\tif (data->pad2 & DRM_EDID_RANGE_OFFSET_MIN_VFREQ)\n\t\t\tmonitor_range->min_vfreq += 255;\n\t\tif (data->pad2 & DRM_EDID_RANGE_OFFSET_MAX_VFREQ)\n\t\t\tmonitor_range->max_vfreq += 255;\n\t}\n}\n\nstatic void drm_get_monitor_range(struct drm_connector *connector,\n\t\t\t\t  const struct drm_edid *drm_edid)\n{\n\tconst struct drm_display_info *info = &connector->display_info;\n\tstruct detailed_mode_closure closure = {\n\t\t.connector = connector,\n\t\t.drm_edid = drm_edid,\n\t};\n\n\tif (drm_edid->edid->revision < 4)\n\t\treturn;\n\n\tif (!(drm_edid->edid->features & DRM_EDID_FEATURE_CONTINUOUS_FREQ))\n\t\treturn;\n\n\tdrm_for_each_detailed_block(drm_edid, get_monitor_range, &closure);\n\n\tdrm_dbg_kms(connector->dev,\n\t\t    \"[CONNECTOR:%d:%s] Supported Monitor Refresh rate range is %d Hz - %d Hz\\n\",\n\t\t    connector->base.id, connector->name,\n\t\t    info->monitor_range.min_vfreq, info->monitor_range.max_vfreq);\n}\n\nstatic void drm_parse_vesa_mso_data(struct drm_connector *connector,\n\t\t\t\t    const struct displayid_block *block)\n{\n\tstruct displayid_vesa_vendor_specific_block *vesa =\n\t\t(struct displayid_vesa_vendor_specific_block *)block;\n\tstruct drm_display_info *info = &connector->display_info;\n\n\tif (block->num_bytes < 3) {\n\t\tdrm_dbg_kms(connector->dev,\n\t\t\t    \"[CONNECTOR:%d:%s] Unexpected vendor block size %u\\n\",\n\t\t\t    connector->base.id, connector->name, block->num_bytes);\n\t\treturn;\n\t}\n\n\tif (oui(vesa->oui[0], vesa->oui[1], vesa->oui[2]) != VESA_IEEE_OUI)\n\t\treturn;\n\n\tif (sizeof(*vesa) != sizeof(*block) + block->num_bytes) {\n\t\tdrm_dbg_kms(connector->dev,\n\t\t\t    \"[CONNECTOR:%d:%s] Unexpected VESA vendor block size\\n\",\n\t\t\t    connector->base.id, connector->name);\n\t\treturn;\n\t}\n\n\tswitch (FIELD_GET(DISPLAYID_VESA_MSO_MODE, vesa->mso)) {\n\tdefault:\n\t\tdrm_dbg_kms(connector->dev, \"[CONNECTOR:%d:%s] Reserved MSO mode value\\n\",\n\t\t\t    connector->base.id, connector->name);\n\t\tfallthrough;\n\tcase 0:\n\t\tinfo->mso_stream_count = 0;\n\t\tbreak;\n\tcase 1:\n\t\tinfo->mso_stream_count = 2;  \n\t\tbreak;\n\tcase 2:\n\t\tinfo->mso_stream_count = 4;  \n\t\tbreak;\n\t}\n\n\tif (!info->mso_stream_count) {\n\t\tinfo->mso_pixel_overlap = 0;\n\t\treturn;\n\t}\n\n\tinfo->mso_pixel_overlap = FIELD_GET(DISPLAYID_VESA_MSO_OVERLAP, vesa->mso);\n\tif (info->mso_pixel_overlap > 8) {\n\t\tdrm_dbg_kms(connector->dev,\n\t\t\t    \"[CONNECTOR:%d:%s] Reserved MSO pixel overlap value %u\\n\",\n\t\t\t    connector->base.id, connector->name,\n\t\t\t    info->mso_pixel_overlap);\n\t\tinfo->mso_pixel_overlap = 8;\n\t}\n\n\tdrm_dbg_kms(connector->dev,\n\t\t    \"[CONNECTOR:%d:%s] MSO stream count %u, pixel overlap %u\\n\",\n\t\t    connector->base.id, connector->name,\n\t\t    info->mso_stream_count, info->mso_pixel_overlap);\n}\n\nstatic void drm_update_mso(struct drm_connector *connector,\n\t\t\t   const struct drm_edid *drm_edid)\n{\n\tconst struct displayid_block *block;\n\tstruct displayid_iter iter;\n\n\tdisplayid_iter_edid_begin(drm_edid, &iter);\n\tdisplayid_iter_for_each(block, &iter) {\n\t\tif (block->tag == DATA_BLOCK_2_VENDOR_SPECIFIC)\n\t\t\tdrm_parse_vesa_mso_data(connector, block);\n\t}\n\tdisplayid_iter_end(&iter);\n}\n\n \nstatic void drm_reset_display_info(struct drm_connector *connector)\n{\n\tstruct drm_display_info *info = &connector->display_info;\n\n\tinfo->width_mm = 0;\n\tinfo->height_mm = 0;\n\n\tinfo->bpc = 0;\n\tinfo->color_formats = 0;\n\tinfo->cea_rev = 0;\n\tinfo->max_tmds_clock = 0;\n\tinfo->dvi_dual = false;\n\tinfo->is_hdmi = false;\n\tinfo->has_audio = false;\n\tinfo->has_hdmi_infoframe = false;\n\tinfo->rgb_quant_range_selectable = false;\n\tmemset(&info->hdmi, 0, sizeof(info->hdmi));\n\n\tinfo->edid_hdmi_rgb444_dc_modes = 0;\n\tinfo->edid_hdmi_ycbcr444_dc_modes = 0;\n\n\tinfo->non_desktop = 0;\n\tmemset(&info->monitor_range, 0, sizeof(info->monitor_range));\n\tmemset(&info->luminance_range, 0, sizeof(info->luminance_range));\n\n\tinfo->mso_stream_count = 0;\n\tinfo->mso_pixel_overlap = 0;\n\tinfo->max_dsc_bpp = 0;\n\n\tkfree(info->vics);\n\tinfo->vics = NULL;\n\tinfo->vics_len = 0;\n\n\tinfo->quirks = 0;\n}\n\nstatic void update_displayid_info(struct drm_connector *connector,\n\t\t\t\t  const struct drm_edid *drm_edid)\n{\n\tstruct drm_display_info *info = &connector->display_info;\n\tconst struct displayid_block *block;\n\tstruct displayid_iter iter;\n\n\tdisplayid_iter_edid_begin(drm_edid, &iter);\n\tdisplayid_iter_for_each(block, &iter) {\n\t\tif (displayid_version(&iter) == DISPLAY_ID_STRUCTURE_VER_20 &&\n\t\t    (displayid_primary_use(&iter) == PRIMARY_USE_HEAD_MOUNTED_VR ||\n\t\t     displayid_primary_use(&iter) == PRIMARY_USE_HEAD_MOUNTED_AR))\n\t\t\tinfo->non_desktop = true;\n\n\t\t \n\t\tbreak;\n\t}\n\tdisplayid_iter_end(&iter);\n}\n\nstatic void update_display_info(struct drm_connector *connector,\n\t\t\t\tconst struct drm_edid *drm_edid)\n{\n\tstruct drm_display_info *info = &connector->display_info;\n\tconst struct edid *edid;\n\n\tdrm_reset_display_info(connector);\n\tclear_eld(connector);\n\n\tif (!drm_edid)\n\t\treturn;\n\n\tedid = drm_edid->edid;\n\n\tinfo->quirks = edid_get_quirks(drm_edid);\n\n\tinfo->width_mm = edid->width_cm * 10;\n\tinfo->height_mm = edid->height_cm * 10;\n\n\tdrm_get_monitor_range(connector, drm_edid);\n\n\tif (edid->revision < 3)\n\t\tgoto out;\n\n\tif (!(edid->input & DRM_EDID_INPUT_DIGITAL))\n\t\tgoto out;\n\n\tinfo->color_formats |= DRM_COLOR_FORMAT_RGB444;\n\tdrm_parse_cea_ext(connector, drm_edid);\n\n\tupdate_displayid_info(connector, drm_edid);\n\n\t \n\tif (info->bpc == 0 && edid->revision == 3 &&\n\t    edid->input & DRM_EDID_DIGITAL_DFP_1_X) {\n\t\tinfo->bpc = 8;\n\t\tdrm_dbg_kms(connector->dev,\n\t\t\t    \"[CONNECTOR:%d:%s] Assigning DFP sink color depth as %d bpc.\\n\",\n\t\t\t    connector->base.id, connector->name, info->bpc);\n\t}\n\n\t \n\tif (edid->revision < 4)\n\t\tgoto out;\n\n\tswitch (edid->input & DRM_EDID_DIGITAL_DEPTH_MASK) {\n\tcase DRM_EDID_DIGITAL_DEPTH_6:\n\t\tinfo->bpc = 6;\n\t\tbreak;\n\tcase DRM_EDID_DIGITAL_DEPTH_8:\n\t\tinfo->bpc = 8;\n\t\tbreak;\n\tcase DRM_EDID_DIGITAL_DEPTH_10:\n\t\tinfo->bpc = 10;\n\t\tbreak;\n\tcase DRM_EDID_DIGITAL_DEPTH_12:\n\t\tinfo->bpc = 12;\n\t\tbreak;\n\tcase DRM_EDID_DIGITAL_DEPTH_14:\n\t\tinfo->bpc = 14;\n\t\tbreak;\n\tcase DRM_EDID_DIGITAL_DEPTH_16:\n\t\tinfo->bpc = 16;\n\t\tbreak;\n\tcase DRM_EDID_DIGITAL_DEPTH_UNDEF:\n\tdefault:\n\t\tinfo->bpc = 0;\n\t\tbreak;\n\t}\n\n\tdrm_dbg_kms(connector->dev,\n\t\t    \"[CONNECTOR:%d:%s] Assigning EDID-1.4 digital sink color depth as %d bpc.\\n\",\n\t\t    connector->base.id, connector->name, info->bpc);\n\n\tif (edid->features & DRM_EDID_FEATURE_RGB_YCRCB444)\n\t\tinfo->color_formats |= DRM_COLOR_FORMAT_YCBCR444;\n\tif (edid->features & DRM_EDID_FEATURE_RGB_YCRCB422)\n\t\tinfo->color_formats |= DRM_COLOR_FORMAT_YCBCR422;\n\n\tdrm_update_mso(connector, drm_edid);\n\nout:\n\tif (info->quirks & EDID_QUIRK_NON_DESKTOP) {\n\t\tdrm_dbg_kms(connector->dev, \"[CONNECTOR:%d:%s] Non-desktop display%s\\n\",\n\t\t\t    connector->base.id, connector->name,\n\t\t\t    info->non_desktop ? \" (redundant quirk)\" : \"\");\n\t\tinfo->non_desktop = true;\n\t}\n\n\tif (info->quirks & EDID_QUIRK_CAP_DSC_15BPP)\n\t\tinfo->max_dsc_bpp = 15;\n\n\tif (info->quirks & EDID_QUIRK_FORCE_6BPC)\n\t\tinfo->bpc = 6;\n\n\tif (info->quirks & EDID_QUIRK_FORCE_8BPC)\n\t\tinfo->bpc = 8;\n\n\tif (info->quirks & EDID_QUIRK_FORCE_10BPC)\n\t\tinfo->bpc = 10;\n\n\tif (info->quirks & EDID_QUIRK_FORCE_12BPC)\n\t\tinfo->bpc = 12;\n\n\t \n\tdrm_edid_to_eld(connector, drm_edid);\n}\n\nstatic struct drm_display_mode *drm_mode_displayid_detailed(struct drm_device *dev,\n\t\t\t\t\t\t\t    struct displayid_detailed_timings_1 *timings,\n\t\t\t\t\t\t\t    bool type_7)\n{\n\tstruct drm_display_mode *mode;\n\tunsigned pixel_clock = (timings->pixel_clock[0] |\n\t\t\t\t(timings->pixel_clock[1] << 8) |\n\t\t\t\t(timings->pixel_clock[2] << 16)) + 1;\n\tunsigned hactive = (timings->hactive[0] | timings->hactive[1] << 8) + 1;\n\tunsigned hblank = (timings->hblank[0] | timings->hblank[1] << 8) + 1;\n\tunsigned hsync = (timings->hsync[0] | (timings->hsync[1] & 0x7f) << 8) + 1;\n\tunsigned hsync_width = (timings->hsw[0] | timings->hsw[1] << 8) + 1;\n\tunsigned vactive = (timings->vactive[0] | timings->vactive[1] << 8) + 1;\n\tunsigned vblank = (timings->vblank[0] | timings->vblank[1] << 8) + 1;\n\tunsigned vsync = (timings->vsync[0] | (timings->vsync[1] & 0x7f) << 8) + 1;\n\tunsigned vsync_width = (timings->vsw[0] | timings->vsw[1] << 8) + 1;\n\tbool hsync_positive = (timings->hsync[1] >> 7) & 0x1;\n\tbool vsync_positive = (timings->vsync[1] >> 7) & 0x1;\n\n\tmode = drm_mode_create(dev);\n\tif (!mode)\n\t\treturn NULL;\n\n\t \n\tmode->clock = type_7 ? pixel_clock : pixel_clock * 10;\n\tmode->hdisplay = hactive;\n\tmode->hsync_start = mode->hdisplay + hsync;\n\tmode->hsync_end = mode->hsync_start + hsync_width;\n\tmode->htotal = mode->hdisplay + hblank;\n\n\tmode->vdisplay = vactive;\n\tmode->vsync_start = mode->vdisplay + vsync;\n\tmode->vsync_end = mode->vsync_start + vsync_width;\n\tmode->vtotal = mode->vdisplay + vblank;\n\n\tmode->flags = 0;\n\tmode->flags |= hsync_positive ? DRM_MODE_FLAG_PHSYNC : DRM_MODE_FLAG_NHSYNC;\n\tmode->flags |= vsync_positive ? DRM_MODE_FLAG_PVSYNC : DRM_MODE_FLAG_NVSYNC;\n\tmode->type = DRM_MODE_TYPE_DRIVER;\n\n\tif (timings->flags & 0x80)\n\t\tmode->type |= DRM_MODE_TYPE_PREFERRED;\n\tdrm_mode_set_name(mode);\n\n\treturn mode;\n}\n\nstatic int add_displayid_detailed_1_modes(struct drm_connector *connector,\n\t\t\t\t\t  const struct displayid_block *block)\n{\n\tstruct displayid_detailed_timing_block *det = (struct displayid_detailed_timing_block *)block;\n\tint i;\n\tint num_timings;\n\tstruct drm_display_mode *newmode;\n\tint num_modes = 0;\n\tbool type_7 = block->tag == DATA_BLOCK_2_TYPE_7_DETAILED_TIMING;\n\t \n\tif (block->num_bytes % 20)\n\t\treturn 0;\n\n\tnum_timings = block->num_bytes / 20;\n\tfor (i = 0; i < num_timings; i++) {\n\t\tstruct displayid_detailed_timings_1 *timings = &det->timings[i];\n\n\t\tnewmode = drm_mode_displayid_detailed(connector->dev, timings, type_7);\n\t\tif (!newmode)\n\t\t\tcontinue;\n\n\t\tdrm_mode_probed_add(connector, newmode);\n\t\tnum_modes++;\n\t}\n\treturn num_modes;\n}\n\nstatic int add_displayid_detailed_modes(struct drm_connector *connector,\n\t\t\t\t\tconst struct drm_edid *drm_edid)\n{\n\tconst struct displayid_block *block;\n\tstruct displayid_iter iter;\n\tint num_modes = 0;\n\n\tdisplayid_iter_edid_begin(drm_edid, &iter);\n\tdisplayid_iter_for_each(block, &iter) {\n\t\tif (block->tag == DATA_BLOCK_TYPE_1_DETAILED_TIMING ||\n\t\t    block->tag == DATA_BLOCK_2_TYPE_7_DETAILED_TIMING)\n\t\t\tnum_modes += add_displayid_detailed_1_modes(connector, block);\n\t}\n\tdisplayid_iter_end(&iter);\n\n\treturn num_modes;\n}\n\nstatic int _drm_edid_connector_add_modes(struct drm_connector *connector,\n\t\t\t\t\t const struct drm_edid *drm_edid)\n{\n\tconst struct drm_display_info *info = &connector->display_info;\n\tint num_modes = 0;\n\n\tif (!drm_edid)\n\t\treturn 0;\n\n\t \n\tnum_modes += add_detailed_modes(connector, drm_edid);\n\tnum_modes += add_cvt_modes(connector, drm_edid);\n\tnum_modes += add_standard_modes(connector, drm_edid);\n\tnum_modes += add_established_modes(connector, drm_edid);\n\tnum_modes += add_cea_modes(connector, drm_edid);\n\tnum_modes += add_alternate_cea_modes(connector, drm_edid);\n\tnum_modes += add_displayid_detailed_modes(connector, drm_edid);\n\tif (drm_edid->edid->features & DRM_EDID_FEATURE_CONTINUOUS_FREQ)\n\t\tnum_modes += add_inferred_modes(connector, drm_edid);\n\n\tif (info->quirks & (EDID_QUIRK_PREFER_LARGE_60 | EDID_QUIRK_PREFER_LARGE_75))\n\t\tedid_fixup_preferred(connector);\n\n\treturn num_modes;\n}\n\nstatic void _drm_update_tile_info(struct drm_connector *connector,\n\t\t\t\t  const struct drm_edid *drm_edid);\n\nstatic int _drm_edid_connector_property_update(struct drm_connector *connector,\n\t\t\t\t\t       const struct drm_edid *drm_edid)\n{\n\tstruct drm_device *dev = connector->dev;\n\tint ret;\n\n\tif (connector->edid_blob_ptr) {\n\t\tconst struct edid *old_edid = connector->edid_blob_ptr->data;\n\n\t\tif (old_edid) {\n\t\t\tif (!drm_edid_are_equal(drm_edid ? drm_edid->edid : NULL, old_edid)) {\n\t\t\t\tconnector->epoch_counter++;\n\t\t\t\tdrm_dbg_kms(dev, \"[CONNECTOR:%d:%s] EDID changed, epoch counter %llu\\n\",\n\t\t\t\t\t    connector->base.id, connector->name,\n\t\t\t\t\t    connector->epoch_counter);\n\t\t\t}\n\t\t}\n\t}\n\n\tret = drm_property_replace_global_blob(dev,\n\t\t\t\t\t       &connector->edid_blob_ptr,\n\t\t\t\t\t       drm_edid ? drm_edid->size : 0,\n\t\t\t\t\t       drm_edid ? drm_edid->edid : NULL,\n\t\t\t\t\t       &connector->base,\n\t\t\t\t\t       dev->mode_config.edid_property);\n\tif (ret) {\n\t\tdrm_dbg_kms(dev, \"[CONNECTOR:%d:%s] EDID property update failed (%d)\\n\",\n\t\t\t    connector->base.id, connector->name, ret);\n\t\tgoto out;\n\t}\n\n\tret = drm_object_property_set_value(&connector->base,\n\t\t\t\t\t    dev->mode_config.non_desktop_property,\n\t\t\t\t\t    connector->display_info.non_desktop);\n\tif (ret) {\n\t\tdrm_dbg_kms(dev, \"[CONNECTOR:%d:%s] Non-desktop property update failed (%d)\\n\",\n\t\t\t    connector->base.id, connector->name, ret);\n\t\tgoto out;\n\t}\n\n\tret = drm_connector_set_tile_property(connector);\n\tif (ret) {\n\t\tdrm_dbg_kms(dev, \"[CONNECTOR:%d:%s] Tile property update failed (%d)\\n\",\n\t\t\t    connector->base.id, connector->name, ret);\n\t\tgoto out;\n\t}\n\nout:\n\treturn ret;\n}\n\n \nint drm_edid_connector_update(struct drm_connector *connector,\n\t\t\t      const struct drm_edid *drm_edid)\n{\n\tupdate_display_info(connector, drm_edid);\n\n\t_drm_update_tile_info(connector, drm_edid);\n\n\treturn _drm_edid_connector_property_update(connector, drm_edid);\n}\nEXPORT_SYMBOL(drm_edid_connector_update);\n\n \nint drm_edid_connector_add_modes(struct drm_connector *connector)\n{\n\tconst struct drm_edid *drm_edid = NULL;\n\tint count;\n\n\tif (connector->edid_blob_ptr)\n\t\tdrm_edid = drm_edid_alloc(connector->edid_blob_ptr->data,\n\t\t\t\t\t  connector->edid_blob_ptr->length);\n\n\tcount = _drm_edid_connector_add_modes(connector, drm_edid);\n\n\tdrm_edid_free(drm_edid);\n\n\treturn count;\n}\nEXPORT_SYMBOL(drm_edid_connector_add_modes);\n\n \nint drm_connector_update_edid_property(struct drm_connector *connector,\n\t\t\t\t       const struct edid *edid)\n{\n\tstruct drm_edid drm_edid;\n\n\treturn drm_edid_connector_update(connector, drm_edid_legacy_init(&drm_edid, edid));\n}\nEXPORT_SYMBOL(drm_connector_update_edid_property);\n\n \nint drm_add_edid_modes(struct drm_connector *connector, struct edid *edid)\n{\n\tstruct drm_edid _drm_edid;\n\tconst struct drm_edid *drm_edid;\n\n\tif (edid && !drm_edid_is_valid(edid)) {\n\t\tdrm_warn(connector->dev, \"[CONNECTOR:%d:%s] EDID invalid.\\n\",\n\t\t\t connector->base.id, connector->name);\n\t\tedid = NULL;\n\t}\n\n\tdrm_edid = drm_edid_legacy_init(&_drm_edid, edid);\n\n\tupdate_display_info(connector, drm_edid);\n\n\treturn _drm_edid_connector_add_modes(connector, drm_edid);\n}\nEXPORT_SYMBOL(drm_add_edid_modes);\n\n \nint drm_add_modes_noedid(struct drm_connector *connector,\n\t\t\tint hdisplay, int vdisplay)\n{\n\tint i, count, num_modes = 0;\n\tstruct drm_display_mode *mode;\n\tstruct drm_device *dev = connector->dev;\n\n\tcount = ARRAY_SIZE(drm_dmt_modes);\n\tif (hdisplay < 0)\n\t\thdisplay = 0;\n\tif (vdisplay < 0)\n\t\tvdisplay = 0;\n\n\tfor (i = 0; i < count; i++) {\n\t\tconst struct drm_display_mode *ptr = &drm_dmt_modes[i];\n\n\t\tif (hdisplay && vdisplay) {\n\t\t\t \n\t\t\tif (ptr->hdisplay > hdisplay ||\n\t\t\t\t\tptr->vdisplay > vdisplay)\n\t\t\t\tcontinue;\n\t\t}\n\t\tif (drm_mode_vrefresh(ptr) > 61)\n\t\t\tcontinue;\n\t\tmode = drm_mode_duplicate(dev, ptr);\n\t\tif (mode) {\n\t\t\tdrm_mode_probed_add(connector, mode);\n\t\t\tnum_modes++;\n\t\t}\n\t}\n\treturn num_modes;\n}\nEXPORT_SYMBOL(drm_add_modes_noedid);\n\n \nvoid drm_set_preferred_mode(struct drm_connector *connector,\n\t\t\t   int hpref, int vpref)\n{\n\tstruct drm_display_mode *mode;\n\n\tlist_for_each_entry(mode, &connector->probed_modes, head) {\n\t\tif (mode->hdisplay == hpref &&\n\t\t    mode->vdisplay == vpref)\n\t\t\tmode->type |= DRM_MODE_TYPE_PREFERRED;\n\t}\n}\nEXPORT_SYMBOL(drm_set_preferred_mode);\n\nstatic bool is_hdmi2_sink(const struct drm_connector *connector)\n{\n\t \n\tif (!connector)\n\t\treturn true;\n\n\treturn connector->display_info.hdmi.scdc.supported ||\n\t\tconnector->display_info.color_formats & DRM_COLOR_FORMAT_YCBCR420;\n}\n\nstatic u8 drm_mode_hdmi_vic(const struct drm_connector *connector,\n\t\t\t    const struct drm_display_mode *mode)\n{\n\tbool has_hdmi_infoframe = connector ?\n\t\tconnector->display_info.has_hdmi_infoframe : false;\n\n\tif (!has_hdmi_infoframe)\n\t\treturn 0;\n\n\t \n\tif (mode->flags & DRM_MODE_FLAG_3D_MASK)\n\t\treturn 0;\n\n\treturn drm_match_hdmi_mode(mode);\n}\n\nstatic u8 drm_mode_cea_vic(const struct drm_connector *connector,\n\t\t\t   const struct drm_display_mode *mode)\n{\n\t \n\tif (drm_mode_hdmi_vic(connector, mode))\n\t\treturn 0;\n\n\treturn drm_match_cea_mode(mode);\n}\n\n \nstatic u8 vic_for_avi_infoframe(const struct drm_connector *connector, u8 vic)\n{\n\tif (!is_hdmi2_sink(connector) && vic > 64 &&\n\t    !cta_vdb_has_vic(connector, vic))\n\t\treturn 0;\n\n\treturn vic;\n}\n\n \nint\ndrm_hdmi_avi_infoframe_from_display_mode(struct hdmi_avi_infoframe *frame,\n\t\t\t\t\t const struct drm_connector *connector,\n\t\t\t\t\t const struct drm_display_mode *mode)\n{\n\tenum hdmi_picture_aspect picture_aspect;\n\tu8 vic, hdmi_vic;\n\n\tif (!frame || !mode)\n\t\treturn -EINVAL;\n\n\thdmi_avi_infoframe_init(frame);\n\n\tif (mode->flags & DRM_MODE_FLAG_DBLCLK)\n\t\tframe->pixel_repeat = 1;\n\n\tvic = drm_mode_cea_vic(connector, mode);\n\thdmi_vic = drm_mode_hdmi_vic(connector, mode);\n\n\tframe->picture_aspect = HDMI_PICTURE_ASPECT_NONE;\n\n\t \n\tframe->content_type = HDMI_CONTENT_TYPE_GRAPHICS;\n\tframe->itc = 0;\n\n\t \n\tpicture_aspect = mode->picture_aspect_ratio;\n\tif (picture_aspect == HDMI_PICTURE_ASPECT_NONE) {\n\t\tif (vic)\n\t\t\tpicture_aspect = drm_get_cea_aspect_ratio(vic);\n\t\telse if (hdmi_vic)\n\t\t\tpicture_aspect = drm_get_hdmi_aspect_ratio(hdmi_vic);\n\t}\n\n\t \n\tif (picture_aspect > HDMI_PICTURE_ASPECT_16_9) {\n\t\tif (vic) {\n\t\t\tif (picture_aspect != drm_get_cea_aspect_ratio(vic))\n\t\t\t\treturn -EINVAL;\n\t\t} else if (hdmi_vic) {\n\t\t\tif (picture_aspect != drm_get_hdmi_aspect_ratio(hdmi_vic))\n\t\t\t\treturn -EINVAL;\n\t\t} else {\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tpicture_aspect = HDMI_PICTURE_ASPECT_NONE;\n\t}\n\n\tframe->video_code = vic_for_avi_infoframe(connector, vic);\n\tframe->picture_aspect = picture_aspect;\n\tframe->active_aspect = HDMI_ACTIVE_ASPECT_PICTURE;\n\tframe->scan_mode = HDMI_SCAN_MODE_UNDERSCAN;\n\n\treturn 0;\n}\nEXPORT_SYMBOL(drm_hdmi_avi_infoframe_from_display_mode);\n\n \nvoid\ndrm_hdmi_avi_infoframe_quant_range(struct hdmi_avi_infoframe *frame,\n\t\t\t\t   const struct drm_connector *connector,\n\t\t\t\t   const struct drm_display_mode *mode,\n\t\t\t\t   enum hdmi_quantization_range rgb_quant_range)\n{\n\tconst struct drm_display_info *info = &connector->display_info;\n\n\t \n\tif (info->rgb_quant_range_selectable ||\n\t    rgb_quant_range == drm_default_rgb_quant_range(mode))\n\t\tframe->quantization_range = rgb_quant_range;\n\telse\n\t\tframe->quantization_range = HDMI_QUANTIZATION_RANGE_DEFAULT;\n\n\t \n\tif (!is_hdmi2_sink(connector) ||\n\t    rgb_quant_range == HDMI_QUANTIZATION_RANGE_LIMITED)\n\t\tframe->ycc_quantization_range =\n\t\t\tHDMI_YCC_QUANTIZATION_RANGE_LIMITED;\n\telse\n\t\tframe->ycc_quantization_range =\n\t\t\tHDMI_YCC_QUANTIZATION_RANGE_FULL;\n}\nEXPORT_SYMBOL(drm_hdmi_avi_infoframe_quant_range);\n\nstatic enum hdmi_3d_structure\ns3d_structure_from_display_mode(const struct drm_display_mode *mode)\n{\n\tu32 layout = mode->flags & DRM_MODE_FLAG_3D_MASK;\n\n\tswitch (layout) {\n\tcase DRM_MODE_FLAG_3D_FRAME_PACKING:\n\t\treturn HDMI_3D_STRUCTURE_FRAME_PACKING;\n\tcase DRM_MODE_FLAG_3D_FIELD_ALTERNATIVE:\n\t\treturn HDMI_3D_STRUCTURE_FIELD_ALTERNATIVE;\n\tcase DRM_MODE_FLAG_3D_LINE_ALTERNATIVE:\n\t\treturn HDMI_3D_STRUCTURE_LINE_ALTERNATIVE;\n\tcase DRM_MODE_FLAG_3D_SIDE_BY_SIDE_FULL:\n\t\treturn HDMI_3D_STRUCTURE_SIDE_BY_SIDE_FULL;\n\tcase DRM_MODE_FLAG_3D_L_DEPTH:\n\t\treturn HDMI_3D_STRUCTURE_L_DEPTH;\n\tcase DRM_MODE_FLAG_3D_L_DEPTH_GFX_GFX_DEPTH:\n\t\treturn HDMI_3D_STRUCTURE_L_DEPTH_GFX_GFX_DEPTH;\n\tcase DRM_MODE_FLAG_3D_TOP_AND_BOTTOM:\n\t\treturn HDMI_3D_STRUCTURE_TOP_AND_BOTTOM;\n\tcase DRM_MODE_FLAG_3D_SIDE_BY_SIDE_HALF:\n\t\treturn HDMI_3D_STRUCTURE_SIDE_BY_SIDE_HALF;\n\tdefault:\n\t\treturn HDMI_3D_STRUCTURE_INVALID;\n\t}\n}\n\n \nint\ndrm_hdmi_vendor_infoframe_from_display_mode(struct hdmi_vendor_infoframe *frame,\n\t\t\t\t\t    const struct drm_connector *connector,\n\t\t\t\t\t    const struct drm_display_mode *mode)\n{\n\t \n\tbool has_hdmi_infoframe = connector ?\n\t\tconnector->display_info.has_hdmi_infoframe : false;\n\tint err;\n\n\tif (!frame || !mode)\n\t\treturn -EINVAL;\n\n\tif (!has_hdmi_infoframe)\n\t\treturn -EINVAL;\n\n\terr = hdmi_vendor_infoframe_init(frame);\n\tif (err < 0)\n\t\treturn err;\n\n\t \n\tframe->vic = drm_mode_hdmi_vic(connector, mode);\n\tframe->s3d_struct = s3d_structure_from_display_mode(mode);\n\n\treturn 0;\n}\nEXPORT_SYMBOL(drm_hdmi_vendor_infoframe_from_display_mode);\n\nstatic void drm_parse_tiled_block(struct drm_connector *connector,\n\t\t\t\t  const struct displayid_block *block)\n{\n\tconst struct displayid_tiled_block *tile = (struct displayid_tiled_block *)block;\n\tu16 w, h;\n\tu8 tile_v_loc, tile_h_loc;\n\tu8 num_v_tile, num_h_tile;\n\tstruct drm_tile_group *tg;\n\n\tw = tile->tile_size[0] | tile->tile_size[1] << 8;\n\th = tile->tile_size[2] | tile->tile_size[3] << 8;\n\n\tnum_v_tile = (tile->topo[0] & 0xf) | (tile->topo[2] & 0x30);\n\tnum_h_tile = (tile->topo[0] >> 4) | ((tile->topo[2] >> 2) & 0x30);\n\ttile_v_loc = (tile->topo[1] & 0xf) | ((tile->topo[2] & 0x3) << 4);\n\ttile_h_loc = (tile->topo[1] >> 4) | (((tile->topo[2] >> 2) & 0x3) << 4);\n\n\tconnector->has_tile = true;\n\tif (tile->tile_cap & 0x80)\n\t\tconnector->tile_is_single_monitor = true;\n\n\tconnector->num_h_tile = num_h_tile + 1;\n\tconnector->num_v_tile = num_v_tile + 1;\n\tconnector->tile_h_loc = tile_h_loc;\n\tconnector->tile_v_loc = tile_v_loc;\n\tconnector->tile_h_size = w + 1;\n\tconnector->tile_v_size = h + 1;\n\n\tdrm_dbg_kms(connector->dev,\n\t\t    \"[CONNECTOR:%d:%s] tile cap 0x%x, size %dx%d, num tiles %dx%d, location %dx%d, vend %c%c%c\",\n\t\t    connector->base.id, connector->name,\n\t\t    tile->tile_cap,\n\t\t    connector->tile_h_size, connector->tile_v_size,\n\t\t    connector->num_h_tile, connector->num_v_tile,\n\t\t    connector->tile_h_loc, connector->tile_v_loc,\n\t\t    tile->topology_id[0], tile->topology_id[1], tile->topology_id[2]);\n\n\ttg = drm_mode_get_tile_group(connector->dev, tile->topology_id);\n\tif (!tg)\n\t\ttg = drm_mode_create_tile_group(connector->dev, tile->topology_id);\n\tif (!tg)\n\t\treturn;\n\n\tif (connector->tile_group != tg) {\n\t\t \n\t\tif (connector->tile_group)\n\t\t\tdrm_mode_put_tile_group(connector->dev, connector->tile_group);\n\t\tconnector->tile_group = tg;\n\t} else {\n\t\t \n\t\tdrm_mode_put_tile_group(connector->dev, tg);\n\t}\n}\n\nstatic bool displayid_is_tiled_block(const struct displayid_iter *iter,\n\t\t\t\t     const struct displayid_block *block)\n{\n\treturn (displayid_version(iter) == DISPLAY_ID_STRUCTURE_VER_12 &&\n\t\tblock->tag == DATA_BLOCK_TILED_DISPLAY) ||\n\t\t(displayid_version(iter) == DISPLAY_ID_STRUCTURE_VER_20 &&\n\t\t block->tag == DATA_BLOCK_2_TILED_DISPLAY_TOPOLOGY);\n}\n\nstatic void _drm_update_tile_info(struct drm_connector *connector,\n\t\t\t\t  const struct drm_edid *drm_edid)\n{\n\tconst struct displayid_block *block;\n\tstruct displayid_iter iter;\n\n\tconnector->has_tile = false;\n\n\tdisplayid_iter_edid_begin(drm_edid, &iter);\n\tdisplayid_iter_for_each(block, &iter) {\n\t\tif (displayid_is_tiled_block(&iter, block))\n\t\t\tdrm_parse_tiled_block(connector, block);\n\t}\n\tdisplayid_iter_end(&iter);\n\n\tif (!connector->has_tile && connector->tile_group) {\n\t\tdrm_mode_put_tile_group(connector->dev, connector->tile_group);\n\t\tconnector->tile_group = NULL;\n\t}\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}