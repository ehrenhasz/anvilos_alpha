{
  "module_name": "mxsfb_drv.c",
  "hash_id": "b9d82ed1557decd8a699c91c79d56ee7e1f050ed2a91aaa6380a36982a047499",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/mxsfb/mxsfb_drv.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/dma-mapping.h>\n#include <linux/io.h>\n#include <linux/module.h>\n#include <linux/of_device.h>\n#include <linux/platform_device.h>\n#include <linux/pm_runtime.h>\n\n#include <drm/drm_atomic_helper.h>\n#include <drm/drm_bridge.h>\n#include <drm/drm_connector.h>\n#include <drm/drm_drv.h>\n#include <drm/drm_fbdev_dma.h>\n#include <drm/drm_fourcc.h>\n#include <drm/drm_gem_dma_helper.h>\n#include <drm/drm_gem_framebuffer_helper.h>\n#include <drm/drm_mode_config.h>\n#include <drm/drm_module.h>\n#include <drm/drm_of.h>\n#include <drm/drm_probe_helper.h>\n#include <drm/drm_vblank.h>\n\n#include \"mxsfb_drv.h\"\n#include \"mxsfb_regs.h\"\n\nenum mxsfb_devtype {\n\tMXSFB_V3,\n\tMXSFB_V4,\n\t \n\tMXSFB_V6,\n};\n\nstatic const struct mxsfb_devdata mxsfb_devdata[] = {\n\t[MXSFB_V3] = {\n\t\t.transfer_count\t= LCDC_V3_TRANSFER_COUNT,\n\t\t.cur_buf\t= LCDC_V3_CUR_BUF,\n\t\t.next_buf\t= LCDC_V3_NEXT_BUF,\n\t\t.hs_wdth_mask\t= 0xff,\n\t\t.hs_wdth_shift\t= 24,\n\t\t.has_overlay\t= false,\n\t\t.has_ctrl2\t= false,\n\t\t.has_crc32\t= false,\n\t},\n\t[MXSFB_V4] = {\n\t\t.transfer_count\t= LCDC_V4_TRANSFER_COUNT,\n\t\t.cur_buf\t= LCDC_V4_CUR_BUF,\n\t\t.next_buf\t= LCDC_V4_NEXT_BUF,\n\t\t.hs_wdth_mask\t= 0x3fff,\n\t\t.hs_wdth_shift\t= 18,\n\t\t.has_overlay\t= false,\n\t\t.has_ctrl2\t= true,\n\t\t.has_crc32\t= true,\n\t},\n\t[MXSFB_V6] = {\n\t\t.transfer_count\t= LCDC_V4_TRANSFER_COUNT,\n\t\t.cur_buf\t= LCDC_V4_CUR_BUF,\n\t\t.next_buf\t= LCDC_V4_NEXT_BUF,\n\t\t.hs_wdth_mask\t= 0x3fff,\n\t\t.hs_wdth_shift\t= 18,\n\t\t.has_overlay\t= true,\n\t\t.has_ctrl2\t= true,\n\t\t.has_crc32\t= true,\n\t},\n};\n\nvoid mxsfb_enable_axi_clk(struct mxsfb_drm_private *mxsfb)\n{\n\tclk_prepare_enable(mxsfb->clk_axi);\n}\n\nvoid mxsfb_disable_axi_clk(struct mxsfb_drm_private *mxsfb)\n{\n\tclk_disable_unprepare(mxsfb->clk_axi);\n}\n\nstatic struct drm_framebuffer *\nmxsfb_fb_create(struct drm_device *dev, struct drm_file *file_priv,\n\t\tconst struct drm_mode_fb_cmd2 *mode_cmd)\n{\n\tconst struct drm_format_info *info;\n\n\tinfo = drm_get_format_info(dev, mode_cmd);\n\tif (!info)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tif (mode_cmd->width * info->cpp[0] != mode_cmd->pitches[0]) {\n\t\tdev_dbg(dev->dev, \"Invalid pitch: fb width must match pitch\\n\");\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\treturn drm_gem_fb_create(dev, file_priv, mode_cmd);\n}\n\nstatic const struct drm_mode_config_funcs mxsfb_mode_config_funcs = {\n\t.fb_create\t\t= mxsfb_fb_create,\n\t.atomic_check\t\t= drm_atomic_helper_check,\n\t.atomic_commit\t\t= drm_atomic_helper_commit,\n};\n\nstatic const struct drm_mode_config_helper_funcs mxsfb_mode_config_helpers = {\n\t.atomic_commit_tail = drm_atomic_helper_commit_tail_rpm,\n};\n\nstatic int mxsfb_attach_bridge(struct mxsfb_drm_private *mxsfb)\n{\n\tstruct drm_device *drm = mxsfb->drm;\n\tstruct drm_connector_list_iter iter;\n\tstruct drm_panel *panel;\n\tstruct drm_bridge *bridge;\n\tint ret;\n\n\tret = drm_of_find_panel_or_bridge(drm->dev->of_node, 0, 0, &panel,\n\t\t\t\t\t  &bridge);\n\tif (ret)\n\t\treturn ret;\n\n\tif (panel) {\n\t\tbridge = devm_drm_panel_bridge_add_typed(drm->dev, panel,\n\t\t\t\t\t\t\t DRM_MODE_CONNECTOR_DPI);\n\t\tif (IS_ERR(bridge))\n\t\t\treturn PTR_ERR(bridge);\n\t}\n\n\tif (!bridge)\n\t\treturn -ENODEV;\n\n\tret = drm_bridge_attach(&mxsfb->encoder, bridge, NULL, 0);\n\tif (ret)\n\t\treturn dev_err_probe(drm->dev, ret, \"Failed to attach bridge\\n\");\n\n\tmxsfb->bridge = bridge;\n\n\t \n\tdrm_connector_list_iter_begin(drm, &iter);\n\tmxsfb->connector = drm_connector_list_iter_next(&iter);\n\tdrm_connector_list_iter_end(&iter);\n\n\treturn 0;\n}\n\nstatic irqreturn_t mxsfb_irq_handler(int irq, void *data)\n{\n\tstruct drm_device *drm = data;\n\tstruct mxsfb_drm_private *mxsfb = drm->dev_private;\n\tu32 reg, crc;\n\tu64 vbc;\n\n\treg = readl(mxsfb->base + LCDC_CTRL1);\n\n\tif (reg & CTRL1_CUR_FRAME_DONE_IRQ) {\n\t\tdrm_crtc_handle_vblank(&mxsfb->crtc);\n\t\tif (mxsfb->crc_active) {\n\t\t\tcrc = readl(mxsfb->base + LCDC_V4_CRC_STAT);\n\t\t\tvbc = drm_crtc_accurate_vblank_count(&mxsfb->crtc);\n\t\t\tdrm_crtc_add_crc_entry(&mxsfb->crtc, true, vbc, &crc);\n\t\t}\n\t}\n\n\twritel(CTRL1_CUR_FRAME_DONE_IRQ, mxsfb->base + LCDC_CTRL1 + REG_CLR);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic void mxsfb_irq_disable(struct drm_device *drm)\n{\n\tstruct mxsfb_drm_private *mxsfb = drm->dev_private;\n\n\tmxsfb_enable_axi_clk(mxsfb);\n\n\t \n\twritel(CTRL1_CUR_FRAME_DONE_IRQ_EN, mxsfb->base + LCDC_CTRL1 + REG_CLR);\n\twritel(CTRL1_CUR_FRAME_DONE_IRQ, mxsfb->base + LCDC_CTRL1 + REG_CLR);\n\n\tmxsfb_disable_axi_clk(mxsfb);\n}\n\nstatic int mxsfb_irq_install(struct drm_device *dev, int irq)\n{\n\tif (irq == IRQ_NOTCONNECTED)\n\t\treturn -ENOTCONN;\n\n\tmxsfb_irq_disable(dev);\n\n\treturn request_irq(irq, mxsfb_irq_handler, 0,  dev->driver->name, dev);\n}\n\nstatic void mxsfb_irq_uninstall(struct drm_device *dev)\n{\n\tstruct mxsfb_drm_private *mxsfb = dev->dev_private;\n\n\tmxsfb_irq_disable(dev);\n\tfree_irq(mxsfb->irq, dev);\n}\n\nstatic int mxsfb_load(struct drm_device *drm,\n\t\t      const struct mxsfb_devdata *devdata)\n{\n\tstruct platform_device *pdev = to_platform_device(drm->dev);\n\tstruct mxsfb_drm_private *mxsfb;\n\tstruct resource *res;\n\tint ret;\n\n\tmxsfb = devm_kzalloc(&pdev->dev, sizeof(*mxsfb), GFP_KERNEL);\n\tif (!mxsfb)\n\t\treturn -ENOMEM;\n\n\tmxsfb->drm = drm;\n\tdrm->dev_private = mxsfb;\n\tmxsfb->devdata = devdata;\n\n\tres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\n\tmxsfb->base = devm_ioremap_resource(drm->dev, res);\n\tif (IS_ERR(mxsfb->base))\n\t\treturn PTR_ERR(mxsfb->base);\n\n\tmxsfb->clk = devm_clk_get(drm->dev, NULL);\n\tif (IS_ERR(mxsfb->clk))\n\t\treturn PTR_ERR(mxsfb->clk);\n\n\tmxsfb->clk_axi = devm_clk_get_optional(drm->dev, \"axi\");\n\tif (IS_ERR(mxsfb->clk_axi))\n\t\treturn PTR_ERR(mxsfb->clk_axi);\n\n\tmxsfb->clk_disp_axi = devm_clk_get(drm->dev, \"disp_axi\");\n\tif (IS_ERR(mxsfb->clk_disp_axi))\n\t\tmxsfb->clk_disp_axi = NULL;\n\n\tret = dma_set_mask_and_coherent(drm->dev, DMA_BIT_MASK(32));\n\tif (ret)\n\t\treturn ret;\n\n\tpm_runtime_enable(drm->dev);\n\n\t \n\tdrm_mode_config_init(drm);\n\n\tret = mxsfb_kms_init(mxsfb);\n\tif (ret < 0) {\n\t\tdev_err(drm->dev, \"Failed to initialize KMS pipeline\\n\");\n\t\tgoto err_vblank;\n\t}\n\n\tret = drm_vblank_init(drm, drm->mode_config.num_crtc);\n\tif (ret < 0) {\n\t\tdev_err(drm->dev, \"Failed to initialise vblank\\n\");\n\t\tgoto err_vblank;\n\t}\n\n\t \n\tdrm_crtc_vblank_off(&mxsfb->crtc);\n\n\tret = mxsfb_attach_bridge(mxsfb);\n\tif (ret) {\n\t\tdev_err_probe(drm->dev, ret, \"Cannot connect bridge\\n\");\n\t\tgoto err_vblank;\n\t}\n\n\tdrm->mode_config.min_width\t= MXSFB_MIN_XRES;\n\tdrm->mode_config.min_height\t= MXSFB_MIN_YRES;\n\tdrm->mode_config.max_width\t= MXSFB_MAX_XRES;\n\tdrm->mode_config.max_height\t= MXSFB_MAX_YRES;\n\tdrm->mode_config.funcs\t\t= &mxsfb_mode_config_funcs;\n\tdrm->mode_config.helper_private\t= &mxsfb_mode_config_helpers;\n\n\tdrm_mode_config_reset(drm);\n\n\tret = platform_get_irq(pdev, 0);\n\tif (ret < 0)\n\t\tgoto err_vblank;\n\tmxsfb->irq = ret;\n\n\tpm_runtime_get_sync(drm->dev);\n\tret = mxsfb_irq_install(drm, mxsfb->irq);\n\tpm_runtime_put_sync(drm->dev);\n\n\tif (ret < 0) {\n\t\tdev_err(drm->dev, \"Failed to install IRQ handler\\n\");\n\t\tgoto err_vblank;\n\t}\n\n\tdrm_kms_helper_poll_init(drm);\n\n\tplatform_set_drvdata(pdev, drm);\n\n\tdrm_helper_hpd_irq_event(drm);\n\n\treturn 0;\n\nerr_vblank:\n\tpm_runtime_disable(drm->dev);\n\n\treturn ret;\n}\n\nstatic void mxsfb_unload(struct drm_device *drm)\n{\n\tdrm_kms_helper_poll_fini(drm);\n\tdrm_mode_config_cleanup(drm);\n\n\tpm_runtime_get_sync(drm->dev);\n\tmxsfb_irq_uninstall(drm);\n\tpm_runtime_put_sync(drm->dev);\n\n\tdrm->dev_private = NULL;\n\n\tpm_runtime_disable(drm->dev);\n}\n\nDEFINE_DRM_GEM_DMA_FOPS(fops);\n\nstatic const struct drm_driver mxsfb_driver = {\n\t.driver_features\t= DRIVER_GEM | DRIVER_MODESET | DRIVER_ATOMIC,\n\tDRM_GEM_DMA_DRIVER_OPS,\n\t.fops\t= &fops,\n\t.name\t= \"mxsfb-drm\",\n\t.desc\t= \"MXSFB Controller DRM\",\n\t.date\t= \"20160824\",\n\t.major\t= 1,\n\t.minor\t= 0,\n};\n\nstatic const struct of_device_id mxsfb_dt_ids[] = {\n\t{ .compatible = \"fsl,imx23-lcdif\", .data = &mxsfb_devdata[MXSFB_V3], },\n\t{ .compatible = \"fsl,imx28-lcdif\", .data = &mxsfb_devdata[MXSFB_V4], },\n\t{ .compatible = \"fsl,imx6sx-lcdif\", .data = &mxsfb_devdata[MXSFB_V6], },\n\t{   }\n};\nMODULE_DEVICE_TABLE(of, mxsfb_dt_ids);\n\nstatic int mxsfb_probe(struct platform_device *pdev)\n{\n\tstruct drm_device *drm;\n\tconst struct of_device_id *of_id =\n\t\t\tof_match_device(mxsfb_dt_ids, &pdev->dev);\n\tint ret;\n\n\tif (!pdev->dev.of_node)\n\t\treturn -ENODEV;\n\n\tdrm = drm_dev_alloc(&mxsfb_driver, &pdev->dev);\n\tif (IS_ERR(drm))\n\t\treturn PTR_ERR(drm);\n\n\tret = mxsfb_load(drm, of_id->data);\n\tif (ret)\n\t\tgoto err_free;\n\n\tret = drm_dev_register(drm, 0);\n\tif (ret)\n\t\tgoto err_unload;\n\n\tdrm_fbdev_dma_setup(drm, 32);\n\n\treturn 0;\n\nerr_unload:\n\tmxsfb_unload(drm);\nerr_free:\n\tdrm_dev_put(drm);\n\n\treturn ret;\n}\n\nstatic void mxsfb_remove(struct platform_device *pdev)\n{\n\tstruct drm_device *drm = platform_get_drvdata(pdev);\n\n\tdrm_dev_unregister(drm);\n\tdrm_atomic_helper_shutdown(drm);\n\tmxsfb_unload(drm);\n\tdrm_dev_put(drm);\n}\n\nstatic void mxsfb_shutdown(struct platform_device *pdev)\n{\n\tstruct drm_device *drm = platform_get_drvdata(pdev);\n\n\tdrm_atomic_helper_shutdown(drm);\n}\n\n#ifdef CONFIG_PM_SLEEP\nstatic int mxsfb_suspend(struct device *dev)\n{\n\tstruct drm_device *drm = dev_get_drvdata(dev);\n\n\treturn drm_mode_config_helper_suspend(drm);\n}\n\nstatic int mxsfb_resume(struct device *dev)\n{\n\tstruct drm_device *drm = dev_get_drvdata(dev);\n\n\treturn drm_mode_config_helper_resume(drm);\n}\n#endif\n\nstatic const struct dev_pm_ops mxsfb_pm_ops = {\n\tSET_SYSTEM_SLEEP_PM_OPS(mxsfb_suspend, mxsfb_resume)\n};\n\nstatic struct platform_driver mxsfb_platform_driver = {\n\t.probe\t\t= mxsfb_probe,\n\t.remove_new\t= mxsfb_remove,\n\t.shutdown\t= mxsfb_shutdown,\n\t.driver\t= {\n\t\t.name\t\t= \"mxsfb\",\n\t\t.of_match_table\t= mxsfb_dt_ids,\n\t\t.pm\t\t= &mxsfb_pm_ops,\n\t},\n};\n\ndrm_module_platform_driver(mxsfb_platform_driver);\n\nMODULE_AUTHOR(\"Marek Vasut <marex@denx.de>\");\nMODULE_DESCRIPTION(\"Freescale MXS DRM/KMS driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}