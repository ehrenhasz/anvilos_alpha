{
  "module_name": "lcdif_drv.c",
  "hash_id": "3a350fbf6d57ac9445e51e65f7dc85787545924b3f26e26a803cbca3a5895cf4",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/mxsfb/lcdif_drv.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/dma-mapping.h>\n#include <linux/io.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/of_graph.h>\n#include <linux/platform_device.h>\n#include <linux/pm_runtime.h>\n\n#include <drm/drm_atomic_helper.h>\n#include <drm/drm_bridge.h>\n#include <drm/drm_drv.h>\n#include <drm/drm_encoder.h>\n#include <drm/drm_fbdev_dma.h>\n#include <drm/drm_gem_dma_helper.h>\n#include <drm/drm_gem_framebuffer_helper.h>\n#include <drm/drm_mode_config.h>\n#include <drm/drm_module.h>\n#include <drm/drm_of.h>\n#include <drm/drm_probe_helper.h>\n#include <drm/drm_vblank.h>\n\n#include \"lcdif_drv.h\"\n#include \"lcdif_regs.h\"\n\nstatic const struct drm_mode_config_funcs lcdif_mode_config_funcs = {\n\t.fb_create\t\t= drm_gem_fb_create,\n\t.atomic_check\t\t= drm_atomic_helper_check,\n\t.atomic_commit\t\t= drm_atomic_helper_commit,\n};\n\nstatic const struct drm_mode_config_helper_funcs lcdif_mode_config_helpers = {\n\t.atomic_commit_tail = drm_atomic_helper_commit_tail_rpm,\n};\n\nstatic const struct drm_encoder_funcs lcdif_encoder_funcs = {\n\t.destroy = drm_encoder_cleanup,\n};\n\nstatic int lcdif_attach_bridge(struct lcdif_drm_private *lcdif)\n{\n\tstruct device *dev = lcdif->drm->dev;\n\tstruct device_node *ep;\n\tstruct drm_bridge *bridge;\n\tint ret;\n\n\tfor_each_endpoint_of_node(dev->of_node, ep) {\n\t\tstruct device_node *remote;\n\t\tstruct of_endpoint of_ep;\n\t\tstruct drm_encoder *encoder;\n\n\t\tremote = of_graph_get_remote_port_parent(ep);\n\t\tif (!of_device_is_available(remote)) {\n\t\t\tof_node_put(remote);\n\t\t\tcontinue;\n\t\t}\n\t\tof_node_put(remote);\n\n\t\tret = of_graph_parse_endpoint(ep, &of_ep);\n\t\tif (ret < 0) {\n\t\t\tdev_err(dev, \"Failed to parse endpoint %pOF\\n\", ep);\n\t\t\tof_node_put(ep);\n\t\t\treturn ret;\n\t\t}\n\n\t\tbridge = devm_drm_of_get_bridge(dev, dev->of_node, 0, of_ep.id);\n\t\tif (IS_ERR(bridge)) {\n\t\t\tof_node_put(ep);\n\t\t\treturn dev_err_probe(dev, PTR_ERR(bridge),\n\t\t\t\t\t     \"Failed to get bridge for endpoint%u\\n\",\n\t\t\t\t\t     of_ep.id);\n\t\t}\n\n\t\tencoder = devm_kzalloc(dev, sizeof(*encoder), GFP_KERNEL);\n\t\tif (!encoder) {\n\t\t\tdev_err(dev, \"Failed to allocate encoder for endpoint%u\\n\",\n\t\t\t\tof_ep.id);\n\t\t\tof_node_put(ep);\n\t\t\treturn -ENOMEM;\n\t\t}\n\n\t\tencoder->possible_crtcs = drm_crtc_mask(&lcdif->crtc);\n\t\tret = drm_encoder_init(lcdif->drm, encoder, &lcdif_encoder_funcs,\n\t\t\t\t       DRM_MODE_ENCODER_NONE, NULL);\n\t\tif (ret) {\n\t\t\tdev_err(dev, \"Failed to initialize encoder for endpoint%u: %d\\n\",\n\t\t\t\tof_ep.id, ret);\n\t\t\tof_node_put(ep);\n\t\t\treturn ret;\n\t\t}\n\n\t\tret = drm_bridge_attach(encoder, bridge, NULL, 0);\n\t\tif (ret) {\n\t\t\tof_node_put(ep);\n\t\t\treturn dev_err_probe(dev, ret,\n\t\t\t\t\t     \"Failed to attach bridge for endpoint%u\\n\",\n\t\t\t\t\t     of_ep.id);\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic irqreturn_t lcdif_irq_handler(int irq, void *data)\n{\n\tstruct drm_device *drm = data;\n\tstruct lcdif_drm_private *lcdif = drm->dev_private;\n\tu32 reg, stat;\n\n\tstat = readl(lcdif->base + LCDC_V8_INT_STATUS_D0);\n\tif (!stat)\n\t\treturn IRQ_NONE;\n\n\tif (stat & INT_STATUS_D0_VS_BLANK) {\n\t\treg = readl(lcdif->base + LCDC_V8_CTRLDESCL0_5);\n\t\tif (!(reg & CTRLDESCL0_5_SHADOW_LOAD_EN))\n\t\t\tdrm_crtc_handle_vblank(&lcdif->crtc);\n\t}\n\n\twritel(stat, lcdif->base + LCDC_V8_INT_STATUS_D0);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int lcdif_load(struct drm_device *drm)\n{\n\tstruct platform_device *pdev = to_platform_device(drm->dev);\n\tstruct lcdif_drm_private *lcdif;\n\tstruct resource *res;\n\tint ret;\n\n\tlcdif = devm_kzalloc(&pdev->dev, sizeof(*lcdif), GFP_KERNEL);\n\tif (!lcdif)\n\t\treturn -ENOMEM;\n\n\tlcdif->drm = drm;\n\tdrm->dev_private = lcdif;\n\n\tres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\n\tlcdif->base = devm_ioremap_resource(drm->dev, res);\n\tif (IS_ERR(lcdif->base))\n\t\treturn PTR_ERR(lcdif->base);\n\n\tlcdif->clk = devm_clk_get(drm->dev, \"pix\");\n\tif (IS_ERR(lcdif->clk))\n\t\treturn PTR_ERR(lcdif->clk);\n\n\tlcdif->clk_axi = devm_clk_get(drm->dev, \"axi\");\n\tif (IS_ERR(lcdif->clk_axi))\n\t\treturn PTR_ERR(lcdif->clk_axi);\n\n\tlcdif->clk_disp_axi = devm_clk_get(drm->dev, \"disp_axi\");\n\tif (IS_ERR(lcdif->clk_disp_axi))\n\t\treturn PTR_ERR(lcdif->clk_disp_axi);\n\n\tplatform_set_drvdata(pdev, drm);\n\n\tret = dma_set_mask_and_coherent(drm->dev, DMA_BIT_MASK(36));\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tdrm_mode_config_init(drm);\n\n\tret = lcdif_kms_init(lcdif);\n\tif (ret < 0) {\n\t\tdev_err(drm->dev, \"Failed to initialize KMS pipeline\\n\");\n\t\treturn ret;\n\t}\n\n\tret = drm_vblank_init(drm, drm->mode_config.num_crtc);\n\tif (ret < 0) {\n\t\tdev_err(drm->dev, \"Failed to initialise vblank\\n\");\n\t\treturn ret;\n\t}\n\n\t \n\tdrm_crtc_vblank_off(&lcdif->crtc);\n\n\tret = lcdif_attach_bridge(lcdif);\n\tif (ret)\n\t\treturn dev_err_probe(drm->dev, ret, \"Cannot connect bridge\\n\");\n\n\tdrm->mode_config.min_width\t= LCDIF_MIN_XRES;\n\tdrm->mode_config.min_height\t= LCDIF_MIN_YRES;\n\tdrm->mode_config.max_width\t= LCDIF_MAX_XRES;\n\tdrm->mode_config.max_height\t= LCDIF_MAX_YRES;\n\tdrm->mode_config.funcs\t\t= &lcdif_mode_config_funcs;\n\tdrm->mode_config.helper_private\t= &lcdif_mode_config_helpers;\n\n\tdrm_mode_config_reset(drm);\n\n\tret = platform_get_irq(pdev, 0);\n\tif (ret < 0)\n\t\treturn ret;\n\tlcdif->irq = ret;\n\n\tret = devm_request_irq(drm->dev, lcdif->irq, lcdif_irq_handler, 0,\n\t\t\t       drm->driver->name, drm);\n\tif (ret < 0) {\n\t\tdev_err(drm->dev, \"Failed to install IRQ handler\\n\");\n\t\treturn ret;\n\t}\n\n\tdrm_kms_helper_poll_init(drm);\n\n\tdrm_helper_hpd_irq_event(drm);\n\n\tpm_runtime_enable(drm->dev);\n\n\treturn 0;\n}\n\nstatic void lcdif_unload(struct drm_device *drm)\n{\n\tstruct lcdif_drm_private *lcdif = drm->dev_private;\n\n\tpm_runtime_get_sync(drm->dev);\n\n\tdrm_crtc_vblank_off(&lcdif->crtc);\n\n\tdrm_kms_helper_poll_fini(drm);\n\tdrm_mode_config_cleanup(drm);\n\n\tpm_runtime_put_sync(drm->dev);\n\tpm_runtime_disable(drm->dev);\n\n\tdrm->dev_private = NULL;\n}\n\nDEFINE_DRM_GEM_DMA_FOPS(fops);\n\nstatic const struct drm_driver lcdif_driver = {\n\t.driver_features\t= DRIVER_GEM | DRIVER_MODESET | DRIVER_ATOMIC,\n\tDRM_GEM_DMA_DRIVER_OPS,\n\t.fops\t= &fops,\n\t.name\t= \"imx-lcdif\",\n\t.desc\t= \"i.MX LCDIF Controller DRM\",\n\t.date\t= \"20220417\",\n\t.major\t= 1,\n\t.minor\t= 0,\n};\n\nstatic const struct of_device_id lcdif_dt_ids[] = {\n\t{ .compatible = \"fsl,imx8mp-lcdif\" },\n\t{ .compatible = \"fsl,imx93-lcdif\" },\n\t{   }\n};\nMODULE_DEVICE_TABLE(of, lcdif_dt_ids);\n\nstatic int lcdif_probe(struct platform_device *pdev)\n{\n\tstruct drm_device *drm;\n\tint ret;\n\n\tdrm = drm_dev_alloc(&lcdif_driver, &pdev->dev);\n\tif (IS_ERR(drm))\n\t\treturn PTR_ERR(drm);\n\n\tret = lcdif_load(drm);\n\tif (ret)\n\t\tgoto err_free;\n\n\tret = drm_dev_register(drm, 0);\n\tif (ret)\n\t\tgoto err_unload;\n\n\tdrm_fbdev_dma_setup(drm, 32);\n\n\treturn 0;\n\nerr_unload:\n\tlcdif_unload(drm);\nerr_free:\n\tdrm_dev_put(drm);\n\n\treturn ret;\n}\n\nstatic void lcdif_remove(struct platform_device *pdev)\n{\n\tstruct drm_device *drm = platform_get_drvdata(pdev);\n\n\tdrm_dev_unregister(drm);\n\tdrm_atomic_helper_shutdown(drm);\n\tlcdif_unload(drm);\n\tdrm_dev_put(drm);\n}\n\nstatic void lcdif_shutdown(struct platform_device *pdev)\n{\n\tstruct drm_device *drm = platform_get_drvdata(pdev);\n\n\tdrm_atomic_helper_shutdown(drm);\n}\n\nstatic int __maybe_unused lcdif_rpm_suspend(struct device *dev)\n{\n\tstruct drm_device *drm = dev_get_drvdata(dev);\n\tstruct lcdif_drm_private *lcdif = drm->dev_private;\n\n\t \n\tclk_disable_unprepare(lcdif->clk);\n\t \n\tclk_disable_unprepare(lcdif->clk_disp_axi);\n\t \n\tclk_disable_unprepare(lcdif->clk_axi);\n\n\treturn 0;\n}\n\nstatic int __maybe_unused lcdif_rpm_resume(struct device *dev)\n{\n\tstruct drm_device *drm = dev_get_drvdata(dev);\n\tstruct lcdif_drm_private *lcdif = drm->dev_private;\n\n\t \n\tclk_prepare_enable(lcdif->clk_axi);\n\t \n\tclk_prepare_enable(lcdif->clk_disp_axi);\n\t \n\tclk_prepare_enable(lcdif->clk);\n\n\treturn 0;\n}\n\nstatic int __maybe_unused lcdif_suspend(struct device *dev)\n{\n\tstruct drm_device *drm = dev_get_drvdata(dev);\n\tint ret;\n\n\tret = drm_mode_config_helper_suspend(drm);\n\tif (ret)\n\t\treturn ret;\n\n\treturn lcdif_rpm_suspend(dev);\n}\n\nstatic int __maybe_unused lcdif_resume(struct device *dev)\n{\n\tstruct drm_device *drm = dev_get_drvdata(dev);\n\n\tlcdif_rpm_resume(dev);\n\n\treturn drm_mode_config_helper_resume(drm);\n}\n\nstatic const struct dev_pm_ops lcdif_pm_ops = {\n\tSET_SYSTEM_SLEEP_PM_OPS(lcdif_suspend, lcdif_resume)\n\tSET_RUNTIME_PM_OPS(lcdif_rpm_suspend, lcdif_rpm_resume, NULL)\n};\n\nstatic struct platform_driver lcdif_platform_driver = {\n\t.probe\t\t= lcdif_probe,\n\t.remove_new\t= lcdif_remove,\n\t.shutdown\t= lcdif_shutdown,\n\t.driver\t= {\n\t\t.name\t\t= \"imx-lcdif\",\n\t\t.of_match_table\t= lcdif_dt_ids,\n\t\t.pm\t\t= &lcdif_pm_ops,\n\t},\n};\n\ndrm_module_platform_driver(lcdif_platform_driver);\n\nMODULE_AUTHOR(\"Marek Vasut <marex@denx.de>\");\nMODULE_DESCRIPTION(\"Freescale LCDIF DRM/KMS driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}