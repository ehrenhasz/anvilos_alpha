{
  "module_name": "lcdif_kms.c",
  "hash_id": "61957c01acba6555d0a8e0c1e6440c54d043dbcb5742d0a162c86ae34bf520c9",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/mxsfb/lcdif_kms.c",
  "human_readable_source": "\n \n\n#include <linux/bitfield.h>\n#include <linux/clk.h>\n#include <linux/io.h>\n#include <linux/iopoll.h>\n#include <linux/media-bus-format.h>\n#include <linux/pm_runtime.h>\n#include <linux/spinlock.h>\n\n#include <drm/drm_atomic.h>\n#include <drm/drm_atomic_helper.h>\n#include <drm/drm_bridge.h>\n#include <drm/drm_color_mgmt.h>\n#include <drm/drm_connector.h>\n#include <drm/drm_crtc.h>\n#include <drm/drm_encoder.h>\n#include <drm/drm_fb_dma_helper.h>\n#include <drm/drm_fourcc.h>\n#include <drm/drm_framebuffer.h>\n#include <drm/drm_gem_atomic_helper.h>\n#include <drm/drm_gem_dma_helper.h>\n#include <drm/drm_plane.h>\n#include <drm/drm_vblank.h>\n\n#include \"lcdif_drv.h\"\n#include \"lcdif_regs.h\"\n\nstruct lcdif_crtc_state {\n\tstruct drm_crtc_state\tbase;\t \n\tu32\t\t\tbus_format;\n\tu32\t\t\tbus_flags;\n};\n\nstatic inline struct lcdif_crtc_state *\nto_lcdif_crtc_state(struct drm_crtc_state *s)\n{\n\treturn container_of(s, struct lcdif_crtc_state, base);\n}\n\n \n\n \nstatic const u32 lcdif_yuv2rgb_coeffs[3][2][6] = {\n\t[DRM_COLOR_YCBCR_BT601] = {\n\t\t[DRM_COLOR_YCBCR_LIMITED_RANGE] = {\n\t\t\t \n\t\t\tCSC0_COEF0_A1(0x12a) | CSC0_COEF0_A2(0x000),\n\t\t\tCSC0_COEF1_A3(0x199) | CSC0_COEF1_B1(0x12a),\n\t\t\tCSC0_COEF2_B2(0x79c) | CSC0_COEF2_B3(0x730),\n\t\t\tCSC0_COEF3_C1(0x12a) | CSC0_COEF3_C2(0x204),\n\t\t\tCSC0_COEF4_C3(0x000) | CSC0_COEF4_D1(0x1f0),\n\t\t\tCSC0_COEF5_D2(0x180) | CSC0_COEF5_D3(0x180),\n\t\t},\n\t\t[DRM_COLOR_YCBCR_FULL_RANGE] = {\n\t\t\t \n\t\t\tCSC0_COEF0_A1(0x100) | CSC0_COEF0_A2(0x000),\n\t\t\tCSC0_COEF1_A3(0x167) | CSC0_COEF1_B1(0x100),\n\t\t\tCSC0_COEF2_B2(0x7a8) | CSC0_COEF2_B3(0x749),\n\t\t\tCSC0_COEF3_C1(0x100) | CSC0_COEF3_C2(0x1c6),\n\t\t\tCSC0_COEF4_C3(0x000) | CSC0_COEF4_D1(0x000),\n\t\t\tCSC0_COEF5_D2(0x180) | CSC0_COEF5_D3(0x180),\n\t\t},\n\t},\n\t[DRM_COLOR_YCBCR_BT709] = {\n\t\t[DRM_COLOR_YCBCR_LIMITED_RANGE] = {\n\t\t\t \n\t\t\tCSC0_COEF0_A1(0x12a) | CSC0_COEF0_A2(0x000),\n\t\t\tCSC0_COEF1_A3(0x1cb) | CSC0_COEF1_B1(0x12a),\n\t\t\tCSC0_COEF2_B2(0x7c9) | CSC0_COEF2_B3(0x778),\n\t\t\tCSC0_COEF3_C1(0x12a) | CSC0_COEF3_C2(0x21d),\n\t\t\tCSC0_COEF4_C3(0x000) | CSC0_COEF4_D1(0x1f0),\n\t\t\tCSC0_COEF5_D2(0x180) | CSC0_COEF5_D3(0x180),\n\t\t},\n\t\t[DRM_COLOR_YCBCR_FULL_RANGE] = {\n\t\t\t \n\t\t\tCSC0_COEF0_A1(0x100) | CSC0_COEF0_A2(0x000),\n\t\t\tCSC0_COEF1_A3(0x193) | CSC0_COEF1_B1(0x100),\n\t\t\tCSC0_COEF2_B2(0x7d0) | CSC0_COEF2_B3(0x788),\n\t\t\tCSC0_COEF3_C1(0x100) | CSC0_COEF3_C2(0x1db),\n\t\t\tCSC0_COEF4_C3(0x000) | CSC0_COEF4_D1(0x000),\n\t\t\tCSC0_COEF5_D2(0x180) | CSC0_COEF5_D3(0x180),\n\t\t},\n\t},\n\t[DRM_COLOR_YCBCR_BT2020] = {\n\t\t[DRM_COLOR_YCBCR_LIMITED_RANGE] = {\n\t\t\t \n\t\t\tCSC0_COEF0_A1(0x12a) | CSC0_COEF0_A2(0x000),\n\t\t\tCSC0_COEF1_A3(0x1ae) | CSC0_COEF1_B1(0x12a),\n\t\t\tCSC0_COEF2_B2(0x7d0) | CSC0_COEF2_B3(0x759),\n\t\t\tCSC0_COEF3_C1(0x12a) | CSC0_COEF3_C2(0x224),\n\t\t\tCSC0_COEF4_C3(0x000) | CSC0_COEF4_D1(0x1f0),\n\t\t\tCSC0_COEF5_D2(0x180) | CSC0_COEF5_D3(0x180),\n\t\t},\n\t\t[DRM_COLOR_YCBCR_FULL_RANGE] = {\n\t\t\t \n\t\t\tCSC0_COEF0_A1(0x100) | CSC0_COEF0_A2(0x000),\n\t\t\tCSC0_COEF1_A3(0x179) | CSC0_COEF1_B1(0x100),\n\t\t\tCSC0_COEF2_B2(0x7d6) | CSC0_COEF2_B3(0x76e),\n\t\t\tCSC0_COEF3_C1(0x100) | CSC0_COEF3_C2(0x1e2),\n\t\t\tCSC0_COEF4_C3(0x000) | CSC0_COEF4_D1(0x000),\n\t\t\tCSC0_COEF5_D2(0x180) | CSC0_COEF5_D3(0x180),\n\t\t},\n\t},\n};\n\nstatic void lcdif_set_formats(struct lcdif_drm_private *lcdif,\n\t\t\t      struct drm_plane_state *plane_state,\n\t\t\t      const u32 bus_format)\n{\n\tstruct drm_device *drm = lcdif->drm;\n\tconst u32 format = plane_state->fb->format->format;\n\tbool in_yuv = false;\n\tbool out_yuv = false;\n\n\tswitch (bus_format) {\n\tcase MEDIA_BUS_FMT_RGB565_1X16:\n\t\twritel(DISP_PARA_LINE_PATTERN_RGB565,\n\t\t       lcdif->base + LCDC_V8_DISP_PARA);\n\t\tbreak;\n\tcase MEDIA_BUS_FMT_RGB888_1X24:\n\t\twritel(DISP_PARA_LINE_PATTERN_RGB888,\n\t\t       lcdif->base + LCDC_V8_DISP_PARA);\n\t\tbreak;\n\tcase MEDIA_BUS_FMT_UYVY8_1X16:\n\t\twritel(DISP_PARA_LINE_PATTERN_UYVY_H,\n\t\t       lcdif->base + LCDC_V8_DISP_PARA);\n\t\tout_yuv = true;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(drm->dev, \"Unknown media bus format 0x%x\\n\", bus_format);\n\t\tbreak;\n\t}\n\n\tswitch (format) {\n\t \n\tcase DRM_FORMAT_RGB565:\n\t\twritel(CTRLDESCL0_5_BPP_16_RGB565,\n\t\t       lcdif->base + LCDC_V8_CTRLDESCL0_5);\n\t\tbreak;\n\tcase DRM_FORMAT_RGB888:\n\t\twritel(CTRLDESCL0_5_BPP_24_RGB888,\n\t\t       lcdif->base + LCDC_V8_CTRLDESCL0_5);\n\t\tbreak;\n\tcase DRM_FORMAT_XRGB1555:\n\t\twritel(CTRLDESCL0_5_BPP_16_ARGB1555,\n\t\t       lcdif->base + LCDC_V8_CTRLDESCL0_5);\n\t\tbreak;\n\tcase DRM_FORMAT_XRGB4444:\n\t\twritel(CTRLDESCL0_5_BPP_16_ARGB4444,\n\t\t       lcdif->base + LCDC_V8_CTRLDESCL0_5);\n\t\tbreak;\n\tcase DRM_FORMAT_XBGR8888:\n\t\twritel(CTRLDESCL0_5_BPP_32_ABGR8888,\n\t\t       lcdif->base + LCDC_V8_CTRLDESCL0_5);\n\t\tbreak;\n\tcase DRM_FORMAT_XRGB8888:\n\t\twritel(CTRLDESCL0_5_BPP_32_ARGB8888,\n\t\t       lcdif->base + LCDC_V8_CTRLDESCL0_5);\n\t\tbreak;\n\n\t \n\tcase DRM_FORMAT_YUYV:\n\t\twritel(CTRLDESCL0_5_BPP_YCbCr422 | CTRLDESCL0_5_YUV_FORMAT_VY2UY1,\n\t\t       lcdif->base + LCDC_V8_CTRLDESCL0_5);\n\t\tin_yuv = true;\n\t\tbreak;\n\tcase DRM_FORMAT_YVYU:\n\t\twritel(CTRLDESCL0_5_BPP_YCbCr422 | CTRLDESCL0_5_YUV_FORMAT_UY2VY1,\n\t\t       lcdif->base + LCDC_V8_CTRLDESCL0_5);\n\t\tin_yuv = true;\n\t\tbreak;\n\tcase DRM_FORMAT_UYVY:\n\t\twritel(CTRLDESCL0_5_BPP_YCbCr422 | CTRLDESCL0_5_YUV_FORMAT_Y2VY1U,\n\t\t       lcdif->base + LCDC_V8_CTRLDESCL0_5);\n\t\tin_yuv = true;\n\t\tbreak;\n\tcase DRM_FORMAT_VYUY:\n\t\twritel(CTRLDESCL0_5_BPP_YCbCr422 | CTRLDESCL0_5_YUV_FORMAT_Y2UY1V,\n\t\t       lcdif->base + LCDC_V8_CTRLDESCL0_5);\n\t\tin_yuv = true;\n\t\tbreak;\n\n\tdefault:\n\t\tdev_err(drm->dev, \"Unknown pixel format 0x%x\\n\", format);\n\t\tbreak;\n\t}\n\n\t \n\tif (!in_yuv && out_yuv) {\n\t\t \n\t\twritel(CSC0_CTRL_CSC_MODE_RGB2YCbCr,\n\t\t       lcdif->base + LCDC_V8_CSC0_CTRL);\n\n\t\t \n\t\twritel(CSC0_COEF0_A2(0x081) | CSC0_COEF0_A1(0x041),\n\t\t       lcdif->base + LCDC_V8_CSC0_COEF0);\n\t\twritel(CSC0_COEF1_B1(0x7db) | CSC0_COEF1_A3(0x019),\n\t\t       lcdif->base + LCDC_V8_CSC0_COEF1);\n\t\twritel(CSC0_COEF2_B3(0x070) | CSC0_COEF2_B2(0x7b6),\n\t\t       lcdif->base + LCDC_V8_CSC0_COEF2);\n\t\twritel(CSC0_COEF3_C2(0x7a2) | CSC0_COEF3_C1(0x070),\n\t\t       lcdif->base + LCDC_V8_CSC0_COEF3);\n\t\twritel(CSC0_COEF4_D1(0x010) | CSC0_COEF4_C3(0x7ee),\n\t\t       lcdif->base + LCDC_V8_CSC0_COEF4);\n\t\twritel(CSC0_COEF5_D3(0x080) | CSC0_COEF5_D2(0x080),\n\t\t       lcdif->base + LCDC_V8_CSC0_COEF5);\n\t} else if (in_yuv && !out_yuv) {\n\t\t \n\t\tconst u32 *coeffs =\n\t\t\tlcdif_yuv2rgb_coeffs[plane_state->color_encoding]\n\t\t\t\t\t    [plane_state->color_range];\n\n\t\twritel(CSC0_CTRL_CSC_MODE_YCbCr2RGB,\n\t\t       lcdif->base + LCDC_V8_CSC0_CTRL);\n\n\t\twritel(coeffs[0], lcdif->base + LCDC_V8_CSC0_COEF0);\n\t\twritel(coeffs[1], lcdif->base + LCDC_V8_CSC0_COEF1);\n\t\twritel(coeffs[2], lcdif->base + LCDC_V8_CSC0_COEF2);\n\t\twritel(coeffs[3], lcdif->base + LCDC_V8_CSC0_COEF3);\n\t\twritel(coeffs[4], lcdif->base + LCDC_V8_CSC0_COEF4);\n\t\twritel(coeffs[5], lcdif->base + LCDC_V8_CSC0_COEF5);\n\t} else {\n\t\t \n\t\twritel(CSC0_CTRL_BYPASS, lcdif->base + LCDC_V8_CSC0_CTRL);\n\t}\n}\n\nstatic void lcdif_set_mode(struct lcdif_drm_private *lcdif, u32 bus_flags)\n{\n\tstruct drm_display_mode *m = &lcdif->crtc.state->adjusted_mode;\n\tu32 ctrl = 0;\n\n\tif (m->flags & DRM_MODE_FLAG_NHSYNC)\n\t\tctrl |= CTRL_INV_HS;\n\tif (m->flags & DRM_MODE_FLAG_NVSYNC)\n\t\tctrl |= CTRL_INV_VS;\n\tif (bus_flags & DRM_BUS_FLAG_DE_LOW)\n\t\tctrl |= CTRL_INV_DE;\n\tif (bus_flags & DRM_BUS_FLAG_PIXDATA_DRIVE_NEGEDGE)\n\t\tctrl |= CTRL_INV_PXCK;\n\n\twritel(ctrl, lcdif->base + LCDC_V8_CTRL);\n\n\twritel(DISP_SIZE_DELTA_Y(m->vdisplay) |\n\t       DISP_SIZE_DELTA_X(m->hdisplay),\n\t       lcdif->base + LCDC_V8_DISP_SIZE);\n\n\twritel(HSYN_PARA_BP_H(m->htotal - m->hsync_end) |\n\t       HSYN_PARA_FP_H(m->hsync_start - m->hdisplay),\n\t       lcdif->base + LCDC_V8_HSYN_PARA);\n\n\twritel(VSYN_PARA_BP_V(m->vtotal - m->vsync_end) |\n\t       VSYN_PARA_FP_V(m->vsync_start - m->vdisplay),\n\t       lcdif->base + LCDC_V8_VSYN_PARA);\n\n\twritel(VSYN_HSYN_WIDTH_PW_V(m->vsync_end - m->vsync_start) |\n\t       VSYN_HSYN_WIDTH_PW_H(m->hsync_end - m->hsync_start),\n\t       lcdif->base + LCDC_V8_VSYN_HSYN_WIDTH);\n\n\twritel(CTRLDESCL0_1_HEIGHT(m->vdisplay) |\n\t       CTRLDESCL0_1_WIDTH(m->hdisplay),\n\t       lcdif->base + LCDC_V8_CTRLDESCL0_1);\n\n\t \n\tctrl = CTRLDESCL0_3_P_SIZE(2) | CTRLDESCL0_3_T_SIZE(2) |\n\t       CTRLDESCL0_3_PITCH(lcdif->crtc.primary->state->fb->pitches[0]);\n\twritel(ctrl, lcdif->base + LCDC_V8_CTRLDESCL0_3);\n}\n\nstatic void lcdif_enable_controller(struct lcdif_drm_private *lcdif)\n{\n\tu32 reg;\n\n\t \n\twritel(FIELD_PREP(PANIC0_THRES_LOW_MASK, 1 * PANIC0_THRES_MAX / 3) |\n\t       FIELD_PREP(PANIC0_THRES_HIGH_MASK, 2 * PANIC0_THRES_MAX / 3),\n\t       lcdif->base + LCDC_V8_PANIC0_THRES);\n\n\t \n\twritel(INT_ENABLE_D1_PLANE_PANIC_EN,\n\t       lcdif->base + LCDC_V8_INT_ENABLE_D1);\n\n\treg = readl(lcdif->base + LCDC_V8_DISP_PARA);\n\treg |= DISP_PARA_DISP_ON;\n\twritel(reg, lcdif->base + LCDC_V8_DISP_PARA);\n\n\treg = readl(lcdif->base + LCDC_V8_CTRLDESCL0_5);\n\treg |= CTRLDESCL0_5_EN;\n\twritel(reg, lcdif->base + LCDC_V8_CTRLDESCL0_5);\n}\n\nstatic void lcdif_disable_controller(struct lcdif_drm_private *lcdif)\n{\n\tu32 reg;\n\tint ret;\n\n\treg = readl(lcdif->base + LCDC_V8_CTRLDESCL0_5);\n\treg &= ~CTRLDESCL0_5_EN;\n\twritel(reg, lcdif->base + LCDC_V8_CTRLDESCL0_5);\n\n\tret = readl_poll_timeout(lcdif->base + LCDC_V8_CTRLDESCL0_5,\n\t\t\t\t reg, !(reg & CTRLDESCL0_5_EN),\n\t\t\t\t 0, 36000);\t \n\tif (ret)\n\t\tdrm_err(lcdif->drm, \"Failed to disable controller!\\n\");\n\n\treg = readl(lcdif->base + LCDC_V8_DISP_PARA);\n\treg &= ~DISP_PARA_DISP_ON;\n\twritel(reg, lcdif->base + LCDC_V8_DISP_PARA);\n\n\t \n\twritel(0, lcdif->base + LCDC_V8_INT_ENABLE_D1);\n}\n\nstatic void lcdif_reset_block(struct lcdif_drm_private *lcdif)\n{\n\twritel(CTRL_SW_RESET, lcdif->base + LCDC_V8_CTRL + REG_SET);\n\treadl(lcdif->base + LCDC_V8_CTRL);\n\twritel(CTRL_SW_RESET, lcdif->base + LCDC_V8_CTRL + REG_CLR);\n\treadl(lcdif->base + LCDC_V8_CTRL);\n}\n\nstatic void lcdif_crtc_mode_set_nofb(struct drm_crtc_state *crtc_state,\n\t\t\t\t     struct drm_plane_state *plane_state)\n{\n\tstruct lcdif_crtc_state *lcdif_crtc_state = to_lcdif_crtc_state(crtc_state);\n\tstruct drm_device *drm = crtc_state->crtc->dev;\n\tstruct lcdif_drm_private *lcdif = to_lcdif_drm_private(drm);\n\tstruct drm_display_mode *m = &crtc_state->adjusted_mode;\n\n\tDRM_DEV_DEBUG_DRIVER(drm->dev, \"Pixel clock: %dkHz (actual: %dkHz)\\n\",\n\t\t\t     m->crtc_clock,\n\t\t\t     (int)(clk_get_rate(lcdif->clk) / 1000));\n\tDRM_DEV_DEBUG_DRIVER(drm->dev, \"Bridge bus_flags: 0x%08X\\n\",\n\t\t\t     lcdif_crtc_state->bus_flags);\n\tDRM_DEV_DEBUG_DRIVER(drm->dev, \"Mode flags: 0x%08X\\n\", m->flags);\n\n\t \n\tlcdif_reset_block(lcdif);\n\n\tlcdif_set_formats(lcdif, plane_state, lcdif_crtc_state->bus_format);\n\n\tlcdif_set_mode(lcdif, lcdif_crtc_state->bus_flags);\n}\n\nstatic int lcdif_crtc_atomic_check(struct drm_crtc *crtc,\n\t\t\t\t   struct drm_atomic_state *state)\n{\n\tstruct drm_device *drm = crtc->dev;\n\tstruct drm_crtc_state *crtc_state = drm_atomic_get_new_crtc_state(state,\n\t\t\t\t\t\t\t\t\t  crtc);\n\tstruct lcdif_crtc_state *lcdif_crtc_state = to_lcdif_crtc_state(crtc_state);\n\tbool has_primary = crtc_state->plane_mask &\n\t\t\t   drm_plane_mask(crtc->primary);\n\tstruct drm_connector_state *connector_state;\n\tstruct drm_connector *connector;\n\tstruct drm_encoder *encoder;\n\tstruct drm_bridge_state *bridge_state;\n\tstruct drm_bridge *bridge;\n\tu32 bus_format, bus_flags;\n\tbool format_set = false, flags_set = false;\n\tint ret, i;\n\n\t \n\tif (crtc_state->active && !has_primary)\n\t\treturn -EINVAL;\n\n\tret = drm_atomic_add_affected_planes(state, crtc);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tfor_each_new_connector_in_state(state, connector, connector_state, i) {\n\t\tif (!connector_state->crtc)\n\t\t\tcontinue;\n\n\t\tencoder = connector_state->best_encoder;\n\n\t\tbridge = drm_bridge_chain_get_first_bridge(encoder);\n\t\tif (!bridge)\n\t\t\tcontinue;\n\n\t\tbridge_state = drm_atomic_get_new_bridge_state(state, bridge);\n\t\tif (!bridge_state)\n\t\t\tbus_format = MEDIA_BUS_FMT_FIXED;\n\t\telse\n\t\t\tbus_format = bridge_state->input_bus_cfg.format;\n\n\t\tif (bus_format == MEDIA_BUS_FMT_FIXED) {\n\t\t\tdev_warn(drm->dev,\n\t\t\t\t \"[ENCODER:%d:%s]'s bridge does not provide bus format, assuming MEDIA_BUS_FMT_RGB888_1X24.\\n\"\n\t\t\t\t \"Please fix bridge driver by handling atomic_get_input_bus_fmts.\\n\",\n\t\t\t\t encoder->base.id, encoder->name);\n\t\t\tbus_format = MEDIA_BUS_FMT_RGB888_1X24;\n\t\t} else if (!bus_format) {\n\t\t\t \n\t\t\tbus_format = MEDIA_BUS_FMT_RGB888_1X24;\n\t\t}\n\n\t\tif (!format_set) {\n\t\t\tlcdif_crtc_state->bus_format = bus_format;\n\t\t\tformat_set = true;\n\t\t} else if (lcdif_crtc_state->bus_format != bus_format) {\n\t\t\tDRM_DEV_DEBUG_DRIVER(drm->dev, \"inconsistent bus format\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (bridge->timings)\n\t\t\tbus_flags = bridge->timings->input_bus_flags;\n\t\telse if (bridge_state)\n\t\t\tbus_flags = bridge_state->input_bus_cfg.flags;\n\t\telse\n\t\t\tbus_flags = 0;\n\n\t\tif (!flags_set) {\n\t\t\tlcdif_crtc_state->bus_flags = bus_flags;\n\t\t\tflags_set = true;\n\t\t} else if (lcdif_crtc_state->bus_flags != bus_flags) {\n\t\t\tDRM_DEV_DEBUG_DRIVER(drm->dev, \"inconsistent bus flags\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic void lcdif_crtc_atomic_flush(struct drm_crtc *crtc,\n\t\t\t\t    struct drm_atomic_state *state)\n{\n\tstruct lcdif_drm_private *lcdif = to_lcdif_drm_private(crtc->dev);\n\tstruct drm_pending_vblank_event *event;\n\tu32 reg;\n\n\treg = readl(lcdif->base + LCDC_V8_CTRLDESCL0_5);\n\treg |= CTRLDESCL0_5_SHADOW_LOAD_EN;\n\twritel(reg, lcdif->base + LCDC_V8_CTRLDESCL0_5);\n\n\tevent = crtc->state->event;\n\tcrtc->state->event = NULL;\n\n\tif (!event)\n\t\treturn;\n\n\tspin_lock_irq(&crtc->dev->event_lock);\n\tif (drm_crtc_vblank_get(crtc) == 0)\n\t\tdrm_crtc_arm_vblank_event(crtc, event);\n\telse\n\t\tdrm_crtc_send_vblank_event(crtc, event);\n\tspin_unlock_irq(&crtc->dev->event_lock);\n}\n\nstatic void lcdif_crtc_atomic_enable(struct drm_crtc *crtc,\n\t\t\t\t     struct drm_atomic_state *state)\n{\n\tstruct lcdif_drm_private *lcdif = to_lcdif_drm_private(crtc->dev);\n\tstruct drm_crtc_state *new_cstate = drm_atomic_get_new_crtc_state(state, crtc);\n\tstruct drm_plane_state *new_pstate = drm_atomic_get_new_plane_state(state,\n\t\t\t\t\t\t\t\t\t    crtc->primary);\n\tstruct drm_display_mode *m = &lcdif->crtc.state->adjusted_mode;\n\tstruct drm_device *drm = lcdif->drm;\n\tdma_addr_t paddr;\n\n\tclk_set_rate(lcdif->clk, m->crtc_clock * 1000);\n\n\tpm_runtime_get_sync(drm->dev);\n\n\tlcdif_crtc_mode_set_nofb(new_cstate, new_pstate);\n\n\t \n\tpaddr = drm_fb_dma_get_gem_addr(new_pstate->fb, new_pstate, 0);\n\tif (paddr) {\n\t\twritel(lower_32_bits(paddr),\n\t\t       lcdif->base + LCDC_V8_CTRLDESCL_LOW0_4);\n\t\twritel(CTRLDESCL_HIGH0_4_ADDR_HIGH(upper_32_bits(paddr)),\n\t\t       lcdif->base + LCDC_V8_CTRLDESCL_HIGH0_4);\n\t}\n\tlcdif_enable_controller(lcdif);\n\n\tdrm_crtc_vblank_on(crtc);\n}\n\nstatic void lcdif_crtc_atomic_disable(struct drm_crtc *crtc,\n\t\t\t\t      struct drm_atomic_state *state)\n{\n\tstruct lcdif_drm_private *lcdif = to_lcdif_drm_private(crtc->dev);\n\tstruct drm_device *drm = lcdif->drm;\n\tstruct drm_pending_vblank_event *event;\n\n\tdrm_crtc_vblank_off(crtc);\n\n\tlcdif_disable_controller(lcdif);\n\n\tspin_lock_irq(&drm->event_lock);\n\tevent = crtc->state->event;\n\tif (event) {\n\t\tcrtc->state->event = NULL;\n\t\tdrm_crtc_send_vblank_event(crtc, event);\n\t}\n\tspin_unlock_irq(&drm->event_lock);\n\n\tpm_runtime_put_sync(drm->dev);\n}\n\nstatic void lcdif_crtc_atomic_destroy_state(struct drm_crtc *crtc,\n\t\t\t\t\t    struct drm_crtc_state *state)\n{\n\t__drm_atomic_helper_crtc_destroy_state(state);\n\tkfree(to_lcdif_crtc_state(state));\n}\n\nstatic void lcdif_crtc_reset(struct drm_crtc *crtc)\n{\n\tstruct lcdif_crtc_state *state;\n\n\tif (crtc->state)\n\t\tlcdif_crtc_atomic_destroy_state(crtc, crtc->state);\n\n\tcrtc->state = NULL;\n\n\tstate = kzalloc(sizeof(*state), GFP_KERNEL);\n\tif (state)\n\t\t__drm_atomic_helper_crtc_reset(crtc, &state->base);\n}\n\nstatic struct drm_crtc_state *\nlcdif_crtc_atomic_duplicate_state(struct drm_crtc *crtc)\n{\n\tstruct lcdif_crtc_state *old = to_lcdif_crtc_state(crtc->state);\n\tstruct lcdif_crtc_state *new;\n\n\tif (WARN_ON(!crtc->state))\n\t\treturn NULL;\n\n\tnew = kzalloc(sizeof(*new), GFP_KERNEL);\n\tif (!new)\n\t\treturn NULL;\n\n\t__drm_atomic_helper_crtc_duplicate_state(crtc, &new->base);\n\n\tnew->bus_format = old->bus_format;\n\tnew->bus_flags = old->bus_flags;\n\n\treturn &new->base;\n}\n\nstatic int lcdif_crtc_enable_vblank(struct drm_crtc *crtc)\n{\n\tstruct lcdif_drm_private *lcdif = to_lcdif_drm_private(crtc->dev);\n\n\t \n\twritel(INT_STATUS_D0_VS_BLANK, lcdif->base + LCDC_V8_INT_STATUS_D0);\n\twritel(INT_ENABLE_D0_VS_BLANK_EN, lcdif->base + LCDC_V8_INT_ENABLE_D0);\n\n\treturn 0;\n}\n\nstatic void lcdif_crtc_disable_vblank(struct drm_crtc *crtc)\n{\n\tstruct lcdif_drm_private *lcdif = to_lcdif_drm_private(crtc->dev);\n\n\t \n\twritel(0, lcdif->base + LCDC_V8_INT_ENABLE_D0);\n\twritel(INT_STATUS_D0_VS_BLANK, lcdif->base + LCDC_V8_INT_STATUS_D0);\n}\n\nstatic const struct drm_crtc_helper_funcs lcdif_crtc_helper_funcs = {\n\t.atomic_check = lcdif_crtc_atomic_check,\n\t.atomic_flush = lcdif_crtc_atomic_flush,\n\t.atomic_enable = lcdif_crtc_atomic_enable,\n\t.atomic_disable = lcdif_crtc_atomic_disable,\n};\n\nstatic const struct drm_crtc_funcs lcdif_crtc_funcs = {\n\t.reset = lcdif_crtc_reset,\n\t.destroy = drm_crtc_cleanup,\n\t.set_config = drm_atomic_helper_set_config,\n\t.page_flip = drm_atomic_helper_page_flip,\n\t.atomic_duplicate_state = lcdif_crtc_atomic_duplicate_state,\n\t.atomic_destroy_state = lcdif_crtc_atomic_destroy_state,\n\t.enable_vblank = lcdif_crtc_enable_vblank,\n\t.disable_vblank = lcdif_crtc_disable_vblank,\n};\n\n \n\nstatic int lcdif_plane_atomic_check(struct drm_plane *plane,\n\t\t\t\t    struct drm_atomic_state *state)\n{\n\tstruct drm_plane_state *plane_state = drm_atomic_get_new_plane_state(state,\n\t\t\t\t\t\t\t\t\t     plane);\n\tstruct lcdif_drm_private *lcdif = to_lcdif_drm_private(plane->dev);\n\tstruct drm_crtc_state *crtc_state;\n\n\tcrtc_state = drm_atomic_get_new_crtc_state(state,\n\t\t\t\t\t\t   &lcdif->crtc);\n\n\treturn drm_atomic_helper_check_plane_state(plane_state, crtc_state,\n\t\t\t\t\t\t   DRM_PLANE_NO_SCALING,\n\t\t\t\t\t\t   DRM_PLANE_NO_SCALING,\n\t\t\t\t\t\t   false, true);\n}\n\nstatic void lcdif_plane_primary_atomic_update(struct drm_plane *plane,\n\t\t\t\t\t      struct drm_atomic_state *state)\n{\n\tstruct lcdif_drm_private *lcdif = to_lcdif_drm_private(plane->dev);\n\tstruct drm_plane_state *new_pstate = drm_atomic_get_new_plane_state(state,\n\t\t\t\t\t\t\t\t\t    plane);\n\tdma_addr_t paddr;\n\n\tpaddr = drm_fb_dma_get_gem_addr(new_pstate->fb, new_pstate, 0);\n\tif (paddr) {\n\t\twritel(lower_32_bits(paddr),\n\t\t       lcdif->base + LCDC_V8_CTRLDESCL_LOW0_4);\n\t\twritel(CTRLDESCL_HIGH0_4_ADDR_HIGH(upper_32_bits(paddr)),\n\t\t       lcdif->base + LCDC_V8_CTRLDESCL_HIGH0_4);\n\t}\n}\n\nstatic bool lcdif_format_mod_supported(struct drm_plane *plane,\n\t\t\t\t       uint32_t format,\n\t\t\t\t       uint64_t modifier)\n{\n\treturn modifier == DRM_FORMAT_MOD_LINEAR;\n}\n\nstatic const struct drm_plane_helper_funcs lcdif_plane_primary_helper_funcs = {\n\t.atomic_check = lcdif_plane_atomic_check,\n\t.atomic_update = lcdif_plane_primary_atomic_update,\n};\n\nstatic const struct drm_plane_funcs lcdif_plane_funcs = {\n\t.format_mod_supported\t= lcdif_format_mod_supported,\n\t.update_plane\t\t= drm_atomic_helper_update_plane,\n\t.disable_plane\t\t= drm_atomic_helper_disable_plane,\n\t.destroy\t\t= drm_plane_cleanup,\n\t.reset\t\t\t= drm_atomic_helper_plane_reset,\n\t.atomic_duplicate_state\t= drm_atomic_helper_plane_duplicate_state,\n\t.atomic_destroy_state\t= drm_atomic_helper_plane_destroy_state,\n};\n\nstatic const u32 lcdif_primary_plane_formats[] = {\n\t \n\tDRM_FORMAT_RGB565,\n\tDRM_FORMAT_RGB888,\n\tDRM_FORMAT_XBGR8888,\n\tDRM_FORMAT_XRGB1555,\n\tDRM_FORMAT_XRGB4444,\n\tDRM_FORMAT_XRGB8888,\n\n\t \n\tDRM_FORMAT_YUYV,\n\tDRM_FORMAT_YVYU,\n\tDRM_FORMAT_UYVY,\n\tDRM_FORMAT_VYUY,\n};\n\nstatic const u64 lcdif_modifiers[] = {\n\tDRM_FORMAT_MOD_LINEAR,\n\tDRM_FORMAT_MOD_INVALID\n};\n\n \n\nint lcdif_kms_init(struct lcdif_drm_private *lcdif)\n{\n\tconst u32 supported_encodings = BIT(DRM_COLOR_YCBCR_BT601) |\n\t\t\t\t\tBIT(DRM_COLOR_YCBCR_BT709) |\n\t\t\t\t\tBIT(DRM_COLOR_YCBCR_BT2020);\n\tconst u32 supported_ranges = BIT(DRM_COLOR_YCBCR_LIMITED_RANGE) |\n\t\t\t\t     BIT(DRM_COLOR_YCBCR_FULL_RANGE);\n\tstruct drm_crtc *crtc = &lcdif->crtc;\n\tint ret;\n\n\tdrm_plane_helper_add(&lcdif->planes.primary,\n\t\t\t     &lcdif_plane_primary_helper_funcs);\n\tret = drm_universal_plane_init(lcdif->drm, &lcdif->planes.primary, 1,\n\t\t\t\t       &lcdif_plane_funcs,\n\t\t\t\t       lcdif_primary_plane_formats,\n\t\t\t\t       ARRAY_SIZE(lcdif_primary_plane_formats),\n\t\t\t\t       lcdif_modifiers, DRM_PLANE_TYPE_PRIMARY,\n\t\t\t\t       NULL);\n\tif (ret)\n\t\treturn ret;\n\n\tret = drm_plane_create_color_properties(&lcdif->planes.primary,\n\t\t\t\t\t\tsupported_encodings,\n\t\t\t\t\t\tsupported_ranges,\n\t\t\t\t\t\tDRM_COLOR_YCBCR_BT601,\n\t\t\t\t\t\tDRM_COLOR_YCBCR_LIMITED_RANGE);\n\tif (ret)\n\t\treturn ret;\n\n\tdrm_crtc_helper_add(crtc, &lcdif_crtc_helper_funcs);\n\treturn drm_crtc_init_with_planes(lcdif->drm, crtc,\n\t\t\t\t\t &lcdif->planes.primary, NULL,\n\t\t\t\t\t &lcdif_crtc_funcs, NULL);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}