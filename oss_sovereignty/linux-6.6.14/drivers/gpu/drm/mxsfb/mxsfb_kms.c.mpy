{
  "module_name": "mxsfb_kms.c",
  "hash_id": "4a0c2111b5f0d6f884662e601441c52ba438474985966ae8ab4f45d6d9723217",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/mxsfb/mxsfb_kms.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/io.h>\n#include <linux/iopoll.h>\n#include <linux/media-bus-format.h>\n#include <linux/pm_runtime.h>\n#include <linux/spinlock.h>\n\n#include <drm/drm_atomic.h>\n#include <drm/drm_atomic_helper.h>\n#include <drm/drm_bridge.h>\n#include <drm/drm_crtc.h>\n#include <drm/drm_encoder.h>\n#include <drm/drm_fb_dma_helper.h>\n#include <drm/drm_fourcc.h>\n#include <drm/drm_framebuffer.h>\n#include <drm/drm_gem_atomic_helper.h>\n#include <drm/drm_gem_dma_helper.h>\n#include <drm/drm_plane.h>\n#include <drm/drm_vblank.h>\n\n#include \"mxsfb_drv.h\"\n#include \"mxsfb_regs.h\"\n\n \n#define RESET_TIMEOUT\t\t1000000\n\n \n\nstatic u32 set_hsync_pulse_width(struct mxsfb_drm_private *mxsfb, u32 val)\n{\n\treturn (val & mxsfb->devdata->hs_wdth_mask) <<\n\t\tmxsfb->devdata->hs_wdth_shift;\n}\n\n \nstatic void mxsfb_set_formats(struct mxsfb_drm_private *mxsfb,\n\t\t\t      const u32 bus_format)\n{\n\tstruct drm_device *drm = mxsfb->drm;\n\tconst u32 format = mxsfb->crtc.primary->state->fb->format->format;\n\tu32 ctrl, ctrl1;\n\n\tDRM_DEV_DEBUG_DRIVER(drm->dev, \"Using bus_format: 0x%08X\\n\",\n\t\t\t     bus_format);\n\n\tctrl = CTRL_BYPASS_COUNT | CTRL_MASTER;\n\n\t \n\tctrl1 = readl(mxsfb->base + LCDC_CTRL1);\n\tctrl1 &= CTRL1_CUR_FRAME_DONE_IRQ_EN | CTRL1_CUR_FRAME_DONE_IRQ;\n\n\tswitch (format) {\n\tcase DRM_FORMAT_RGB565:\n\t\tdev_dbg(drm->dev, \"Setting up RGB565 mode\\n\");\n\t\tctrl |= CTRL_WORD_LENGTH_16;\n\t\tctrl1 |= CTRL1_SET_BYTE_PACKAGING(0xf);\n\t\tbreak;\n\tcase DRM_FORMAT_XRGB8888:\n\t\tdev_dbg(drm->dev, \"Setting up XRGB8888 mode\\n\");\n\t\tctrl |= CTRL_WORD_LENGTH_24;\n\t\t \n\t\tctrl1 |= CTRL1_SET_BYTE_PACKAGING(0x7);\n\t\tbreak;\n\t}\n\n\tswitch (bus_format) {\n\tcase MEDIA_BUS_FMT_RGB565_1X16:\n\t\tctrl |= CTRL_BUS_WIDTH_16;\n\t\tbreak;\n\tcase MEDIA_BUS_FMT_RGB666_1X18:\n\t\tctrl |= CTRL_BUS_WIDTH_18;\n\t\tbreak;\n\tcase MEDIA_BUS_FMT_RGB888_1X24:\n\t\tctrl |= CTRL_BUS_WIDTH_24;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(drm->dev, \"Unknown media bus format 0x%x\\n\", bus_format);\n\t\tbreak;\n\t}\n\n\twritel(ctrl1, mxsfb->base + LCDC_CTRL1);\n\twritel(ctrl, mxsfb->base + LCDC_CTRL);\n}\n\nstatic void mxsfb_set_mode(struct mxsfb_drm_private *mxsfb, u32 bus_flags)\n{\n\tstruct drm_display_mode *m = &mxsfb->crtc.state->adjusted_mode;\n\tu32 vdctrl0, vsync_pulse_len, hsync_pulse_len;\n\n\twritel(TRANSFER_COUNT_SET_VCOUNT(m->crtc_vdisplay) |\n\t       TRANSFER_COUNT_SET_HCOUNT(m->crtc_hdisplay),\n\t       mxsfb->base + mxsfb->devdata->transfer_count);\n\n\tvsync_pulse_len = m->crtc_vsync_end - m->crtc_vsync_start;\n\n\tvdctrl0 = VDCTRL0_ENABLE_PRESENT |\t \n\t\t  VDCTRL0_VSYNC_PERIOD_UNIT |\n\t\t  VDCTRL0_VSYNC_PULSE_WIDTH_UNIT |\n\t\t  VDCTRL0_SET_VSYNC_PULSE_WIDTH(vsync_pulse_len);\n\tif (m->flags & DRM_MODE_FLAG_PHSYNC)\n\t\tvdctrl0 |= VDCTRL0_HSYNC_ACT_HIGH;\n\tif (m->flags & DRM_MODE_FLAG_PVSYNC)\n\t\tvdctrl0 |= VDCTRL0_VSYNC_ACT_HIGH;\n\t \n\tif (!(bus_flags & DRM_BUS_FLAG_DE_LOW))\n\t\tvdctrl0 |= VDCTRL0_ENABLE_ACT_HIGH;\n\t \n\tif (bus_flags & DRM_BUS_FLAG_PIXDATA_DRIVE_POSEDGE)\n\t\tvdctrl0 |= VDCTRL0_DOTCLK_ACT_FALLING;\n\n\twritel(vdctrl0, mxsfb->base + LCDC_VDCTRL0);\n\n\t \n\twritel(m->crtc_vtotal, mxsfb->base + LCDC_VDCTRL1);\n\n\t \n\thsync_pulse_len = m->crtc_hsync_end - m->crtc_hsync_start;\n\twritel(set_hsync_pulse_width(mxsfb, hsync_pulse_len) |\n\t       VDCTRL2_SET_HSYNC_PERIOD(m->crtc_htotal),\n\t       mxsfb->base + LCDC_VDCTRL2);\n\n\twritel(SET_HOR_WAIT_CNT(m->crtc_htotal - m->crtc_hsync_start) |\n\t       SET_VERT_WAIT_CNT(m->crtc_vtotal - m->crtc_vsync_start),\n\t       mxsfb->base + LCDC_VDCTRL3);\n\n\twritel(SET_DOTCLK_H_VALID_DATA_CNT(m->hdisplay),\n\t       mxsfb->base + LCDC_VDCTRL4);\n\n}\n\nstatic void mxsfb_enable_controller(struct mxsfb_drm_private *mxsfb)\n{\n\tu32 reg;\n\n\tif (mxsfb->clk_disp_axi)\n\t\tclk_prepare_enable(mxsfb->clk_disp_axi);\n\tclk_prepare_enable(mxsfb->clk);\n\n\t \n\tif (mxsfb->devdata->has_ctrl2) {\n\t\treg = readl(mxsfb->base + LCDC_V4_CTRL2);\n\t\treg &= ~CTRL2_SET_OUTSTANDING_REQS_MASK;\n\t\treg |= CTRL2_SET_OUTSTANDING_REQS_16;\n\t\twritel(reg, mxsfb->base + LCDC_V4_CTRL2);\n\t}\n\n\t \n\twritel(CTRL_DOTCLK_MODE, mxsfb->base + LCDC_CTRL + REG_SET);\n\n\t \n\treg = readl(mxsfb->base + LCDC_VDCTRL4);\n\treg |= VDCTRL4_SYNC_SIGNALS_ON;\n\twritel(reg, mxsfb->base + LCDC_VDCTRL4);\n\n\t \n\treg = readl(mxsfb->base + LCDC_CTRL1);\n\treg |= CTRL1_RECOVER_ON_UNDERFLOW;\n\twritel(reg, mxsfb->base + LCDC_CTRL1);\n\n\twritel(CTRL_RUN, mxsfb->base + LCDC_CTRL + REG_SET);\n}\n\nstatic void mxsfb_disable_controller(struct mxsfb_drm_private *mxsfb)\n{\n\tu32 reg;\n\n\t \n\twritel(CTRL_DOTCLK_MODE, mxsfb->base + LCDC_CTRL + REG_CLR);\n\n\treadl_poll_timeout(mxsfb->base + LCDC_CTRL, reg, !(reg & CTRL_RUN),\n\t\t\t   0, 1000);\n\n\treg = readl(mxsfb->base + LCDC_VDCTRL4);\n\treg &= ~VDCTRL4_SYNC_SIGNALS_ON;\n\twritel(reg, mxsfb->base + LCDC_VDCTRL4);\n\n\tclk_disable_unprepare(mxsfb->clk);\n\tif (mxsfb->clk_disp_axi)\n\t\tclk_disable_unprepare(mxsfb->clk_disp_axi);\n}\n\n \nstatic int clear_poll_bit(void __iomem *addr, u32 mask)\n{\n\tu32 reg;\n\n\twritel(mask, addr + REG_CLR);\n\treturn readl_poll_timeout(addr, reg, !(reg & mask), 0, RESET_TIMEOUT);\n}\n\nstatic int mxsfb_reset_block(struct mxsfb_drm_private *mxsfb)\n{\n\tint ret;\n\n\t \n\n\tret = clear_poll_bit(mxsfb->base + LCDC_CTRL, CTRL_SFTRST);\n\tif (ret)\n\t\treturn ret;\n\n\twritel(CTRL_CLKGATE, mxsfb->base + LCDC_CTRL + REG_CLR);\n\n\tret = clear_poll_bit(mxsfb->base + LCDC_CTRL, CTRL_SFTRST);\n\tif (ret)\n\t\treturn ret;\n\n\tret = clear_poll_bit(mxsfb->base + LCDC_CTRL, CTRL_CLKGATE);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\twritel(CTRL1_FIFO_CLEAR, mxsfb->base + LCDC_CTRL1 + REG_SET);\n\treadl(mxsfb->base + LCDC_CTRL1);\n\twritel(CTRL1_FIFO_CLEAR, mxsfb->base + LCDC_CTRL1 + REG_CLR);\n\treadl(mxsfb->base + LCDC_CTRL1);\n\n\tif (mxsfb->devdata->has_overlay)\n\t\twritel(0, mxsfb->base + LCDC_AS_CTRL);\n\n\treturn 0;\n}\n\nstatic void mxsfb_crtc_mode_set_nofb(struct mxsfb_drm_private *mxsfb,\n\t\t\t\t     struct drm_bridge_state *bridge_state,\n\t\t\t\t     const u32 bus_format)\n{\n\tstruct drm_device *drm = mxsfb->crtc.dev;\n\tstruct drm_display_mode *m = &mxsfb->crtc.state->adjusted_mode;\n\tu32 bus_flags = mxsfb->connector->display_info.bus_flags;\n\tint err;\n\n\tif (mxsfb->bridge && mxsfb->bridge->timings)\n\t\tbus_flags = mxsfb->bridge->timings->input_bus_flags;\n\telse if (bridge_state)\n\t\tbus_flags = bridge_state->input_bus_cfg.flags;\n\n\tDRM_DEV_DEBUG_DRIVER(drm->dev, \"Pixel clock: %dkHz (actual: %dkHz)\\n\",\n\t\t\t     m->crtc_clock,\n\t\t\t     (int)(clk_get_rate(mxsfb->clk) / 1000));\n\tDRM_DEV_DEBUG_DRIVER(drm->dev, \"Connector bus_flags: 0x%08X\\n\",\n\t\t\t     bus_flags);\n\tDRM_DEV_DEBUG_DRIVER(drm->dev, \"Mode flags: 0x%08X\\n\", m->flags);\n\n\t \n\terr = mxsfb_reset_block(mxsfb);\n\tif (err)\n\t\treturn;\n\n\tmxsfb_set_formats(mxsfb, bus_format);\n\n\tclk_set_rate(mxsfb->clk, m->crtc_clock * 1000);\n\n\tmxsfb_set_mode(mxsfb, bus_flags);\n}\n\nstatic int mxsfb_crtc_atomic_check(struct drm_crtc *crtc,\n\t\t\t\t   struct drm_atomic_state *state)\n{\n\tstruct drm_crtc_state *crtc_state = drm_atomic_get_new_crtc_state(state,\n\t\t\t\t\t\t\t\t\t  crtc);\n\tbool has_primary = crtc_state->plane_mask &\n\t\t\t   drm_plane_mask(crtc->primary);\n\n\t \n\tif (crtc_state->active && !has_primary)\n\t\treturn -EINVAL;\n\n\t \n\treturn drm_atomic_add_affected_planes(state, crtc);\n}\n\nstatic void mxsfb_crtc_atomic_flush(struct drm_crtc *crtc,\n\t\t\t\t    struct drm_atomic_state *state)\n{\n\tstruct drm_pending_vblank_event *event;\n\n\tevent = crtc->state->event;\n\tcrtc->state->event = NULL;\n\n\tif (!event)\n\t\treturn;\n\n\tspin_lock_irq(&crtc->dev->event_lock);\n\tif (drm_crtc_vblank_get(crtc) == 0)\n\t\tdrm_crtc_arm_vblank_event(crtc, event);\n\telse\n\t\tdrm_crtc_send_vblank_event(crtc, event);\n\tspin_unlock_irq(&crtc->dev->event_lock);\n}\n\nstatic void mxsfb_crtc_atomic_enable(struct drm_crtc *crtc,\n\t\t\t\t     struct drm_atomic_state *state)\n{\n\tstruct mxsfb_drm_private *mxsfb = to_mxsfb_drm_private(crtc->dev);\n\tstruct drm_plane_state *new_pstate = drm_atomic_get_new_plane_state(state,\n\t\t\t\t\t\t\t\t\t    crtc->primary);\n\tstruct drm_bridge_state *bridge_state = NULL;\n\tstruct drm_device *drm = mxsfb->drm;\n\tu32 bus_format = 0;\n\tdma_addr_t dma_addr;\n\n\tpm_runtime_get_sync(drm->dev);\n\tmxsfb_enable_axi_clk(mxsfb);\n\n\tdrm_crtc_vblank_on(crtc);\n\n\t \n\tif (mxsfb->bridge) {\n\t\tbridge_state =\n\t\t\tdrm_atomic_get_new_bridge_state(state,\n\t\t\t\t\t\t\tmxsfb->bridge);\n\t\tif (!bridge_state)\n\t\t\tbus_format = MEDIA_BUS_FMT_FIXED;\n\t\telse\n\t\t\tbus_format = bridge_state->input_bus_cfg.format;\n\n\t\tif (bus_format == MEDIA_BUS_FMT_FIXED) {\n\t\t\tdev_warn_once(drm->dev,\n\t\t\t\t      \"Bridge does not provide bus format, assuming MEDIA_BUS_FMT_RGB888_1X24.\\n\"\n\t\t\t\t      \"Please fix bridge driver by handling atomic_get_input_bus_fmts.\\n\");\n\t\t\tbus_format = MEDIA_BUS_FMT_RGB888_1X24;\n\t\t}\n\t}\n\n\t \n\tif (!bus_format && mxsfb->connector->display_info.num_bus_formats)\n\t\tbus_format = mxsfb->connector->display_info.bus_formats[0];\n\n\t \n\tif (!bus_format)\n\t\tbus_format = MEDIA_BUS_FMT_RGB888_1X24;\n\n\tmxsfb_crtc_mode_set_nofb(mxsfb, bridge_state, bus_format);\n\n\t \n\tdma_addr = drm_fb_dma_get_gem_addr(new_pstate->fb, new_pstate, 0);\n\tif (dma_addr) {\n\t\twritel(dma_addr, mxsfb->base + mxsfb->devdata->cur_buf);\n\t\twritel(dma_addr, mxsfb->base + mxsfb->devdata->next_buf);\n\t}\n\n\tmxsfb_enable_controller(mxsfb);\n}\n\nstatic void mxsfb_crtc_atomic_disable(struct drm_crtc *crtc,\n\t\t\t\t      struct drm_atomic_state *state)\n{\n\tstruct mxsfb_drm_private *mxsfb = to_mxsfb_drm_private(crtc->dev);\n\tstruct drm_device *drm = mxsfb->drm;\n\tstruct drm_pending_vblank_event *event;\n\n\tmxsfb_disable_controller(mxsfb);\n\n\tspin_lock_irq(&drm->event_lock);\n\tevent = crtc->state->event;\n\tif (event) {\n\t\tcrtc->state->event = NULL;\n\t\tdrm_crtc_send_vblank_event(crtc, event);\n\t}\n\tspin_unlock_irq(&drm->event_lock);\n\n\tdrm_crtc_vblank_off(crtc);\n\n\tmxsfb_disable_axi_clk(mxsfb);\n\tpm_runtime_put_sync(drm->dev);\n}\n\nstatic int mxsfb_crtc_enable_vblank(struct drm_crtc *crtc)\n{\n\tstruct mxsfb_drm_private *mxsfb = to_mxsfb_drm_private(crtc->dev);\n\n\t \n\twritel(CTRL1_CUR_FRAME_DONE_IRQ, mxsfb->base + LCDC_CTRL1 + REG_CLR);\n\twritel(CTRL1_CUR_FRAME_DONE_IRQ_EN, mxsfb->base + LCDC_CTRL1 + REG_SET);\n\n\treturn 0;\n}\n\nstatic void mxsfb_crtc_disable_vblank(struct drm_crtc *crtc)\n{\n\tstruct mxsfb_drm_private *mxsfb = to_mxsfb_drm_private(crtc->dev);\n\n\t \n\twritel(CTRL1_CUR_FRAME_DONE_IRQ_EN, mxsfb->base + LCDC_CTRL1 + REG_CLR);\n\twritel(CTRL1_CUR_FRAME_DONE_IRQ, mxsfb->base + LCDC_CTRL1 + REG_CLR);\n}\n\nstatic int mxsfb_crtc_set_crc_source(struct drm_crtc *crtc, const char *source)\n{\n\tstruct mxsfb_drm_private *mxsfb;\n\n\tif (!crtc)\n\t\treturn -ENODEV;\n\n\tmxsfb = to_mxsfb_drm_private(crtc->dev);\n\n\tif (source && strcmp(source, \"auto\") == 0)\n\t\tmxsfb->crc_active = true;\n\telse if (!source)\n\t\tmxsfb->crc_active = false;\n\telse\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nstatic int mxsfb_crtc_verify_crc_source(struct drm_crtc *crtc,\n\t\t\t\t\tconst char *source, size_t *values_cnt)\n{\n\tif (!crtc)\n\t\treturn -ENODEV;\n\n\tif (source && strcmp(source, \"auto\") != 0) {\n\t\tDRM_DEBUG_DRIVER(\"Unknown CRC source %s for %s\\n\",\n\t\t\t\t source, crtc->name);\n\t\treturn -EINVAL;\n\t}\n\n\t*values_cnt = 1;\n\treturn 0;\n}\n\nstatic const struct drm_crtc_helper_funcs mxsfb_crtc_helper_funcs = {\n\t.atomic_check = mxsfb_crtc_atomic_check,\n\t.atomic_flush = mxsfb_crtc_atomic_flush,\n\t.atomic_enable = mxsfb_crtc_atomic_enable,\n\t.atomic_disable = mxsfb_crtc_atomic_disable,\n};\n\nstatic const struct drm_crtc_funcs mxsfb_crtc_funcs = {\n\t.reset = drm_atomic_helper_crtc_reset,\n\t.destroy = drm_crtc_cleanup,\n\t.set_config = drm_atomic_helper_set_config,\n\t.page_flip = drm_atomic_helper_page_flip,\n\t.atomic_duplicate_state = drm_atomic_helper_crtc_duplicate_state,\n\t.atomic_destroy_state = drm_atomic_helper_crtc_destroy_state,\n\t.enable_vblank = mxsfb_crtc_enable_vblank,\n\t.disable_vblank = mxsfb_crtc_disable_vblank,\n};\n\nstatic const struct drm_crtc_funcs mxsfb_crtc_with_crc_funcs = {\n\t.reset = drm_atomic_helper_crtc_reset,\n\t.destroy = drm_crtc_cleanup,\n\t.set_config = drm_atomic_helper_set_config,\n\t.page_flip = drm_atomic_helper_page_flip,\n\t.atomic_duplicate_state = drm_atomic_helper_crtc_duplicate_state,\n\t.atomic_destroy_state = drm_atomic_helper_crtc_destroy_state,\n\t.enable_vblank = mxsfb_crtc_enable_vblank,\n\t.disable_vblank = mxsfb_crtc_disable_vblank,\n\t.set_crc_source = mxsfb_crtc_set_crc_source,\n\t.verify_crc_source = mxsfb_crtc_verify_crc_source,\n};\n\n \n\nstatic const struct drm_encoder_funcs mxsfb_encoder_funcs = {\n\t.destroy = drm_encoder_cleanup,\n};\n\n \n\nstatic int mxsfb_plane_atomic_check(struct drm_plane *plane,\n\t\t\t\t    struct drm_atomic_state *state)\n{\n\tstruct drm_plane_state *plane_state = drm_atomic_get_new_plane_state(state,\n\t\t\t\t\t\t\t\t\t     plane);\n\tstruct mxsfb_drm_private *mxsfb = to_mxsfb_drm_private(plane->dev);\n\tstruct drm_crtc_state *crtc_state;\n\n\tcrtc_state = drm_atomic_get_new_crtc_state(state,\n\t\t\t\t\t\t   &mxsfb->crtc);\n\n\treturn drm_atomic_helper_check_plane_state(plane_state, crtc_state,\n\t\t\t\t\t\t   DRM_PLANE_NO_SCALING,\n\t\t\t\t\t\t   DRM_PLANE_NO_SCALING,\n\t\t\t\t\t\t   false, true);\n}\n\nstatic void mxsfb_plane_primary_atomic_update(struct drm_plane *plane,\n\t\t\t\t\t      struct drm_atomic_state *state)\n{\n\tstruct mxsfb_drm_private *mxsfb = to_mxsfb_drm_private(plane->dev);\n\tstruct drm_plane_state *new_pstate = drm_atomic_get_new_plane_state(state,\n\t\t\t\t\t\t\t\t\t    plane);\n\tdma_addr_t dma_addr;\n\n\tdma_addr = drm_fb_dma_get_gem_addr(new_pstate->fb, new_pstate, 0);\n\tif (dma_addr)\n\t\twritel(dma_addr, mxsfb->base + mxsfb->devdata->next_buf);\n}\n\nstatic void mxsfb_plane_overlay_atomic_update(struct drm_plane *plane,\n\t\t\t\t\t      struct drm_atomic_state *state)\n{\n\tstruct drm_plane_state *old_pstate = drm_atomic_get_old_plane_state(state,\n\t\t\t\t\t\t\t\t\t    plane);\n\tstruct mxsfb_drm_private *mxsfb = to_mxsfb_drm_private(plane->dev);\n\tstruct drm_plane_state *new_pstate = drm_atomic_get_new_plane_state(state,\n\t\t\t\t\t\t\t\t\t    plane);\n\tdma_addr_t dma_addr;\n\tu32 ctrl;\n\n\tdma_addr = drm_fb_dma_get_gem_addr(new_pstate->fb, new_pstate, 0);\n\tif (!dma_addr) {\n\t\twritel(0, mxsfb->base + LCDC_AS_CTRL);\n\t\treturn;\n\t}\n\n\t \n\tdma_addr += 64;\n\n\twritel(dma_addr, mxsfb->base + LCDC_AS_NEXT_BUF);\n\n\t \n\tif (!old_pstate->fb)\n\t\twritel(dma_addr, mxsfb->base + LCDC_AS_BUF);\n\n\tctrl = AS_CTRL_AS_ENABLE | AS_CTRL_ALPHA(255);\n\n\tswitch (new_pstate->fb->format->format) {\n\tcase DRM_FORMAT_XRGB4444:\n\t\tctrl |= AS_CTRL_FORMAT_RGB444 | AS_CTRL_ALPHA_CTRL_OVERRIDE;\n\t\tbreak;\n\tcase DRM_FORMAT_ARGB4444:\n\t\tctrl |= AS_CTRL_FORMAT_ARGB4444 | AS_CTRL_ALPHA_CTRL_EMBEDDED;\n\t\tbreak;\n\tcase DRM_FORMAT_XRGB1555:\n\t\tctrl |= AS_CTRL_FORMAT_RGB555 | AS_CTRL_ALPHA_CTRL_OVERRIDE;\n\t\tbreak;\n\tcase DRM_FORMAT_ARGB1555:\n\t\tctrl |= AS_CTRL_FORMAT_ARGB1555 | AS_CTRL_ALPHA_CTRL_EMBEDDED;\n\t\tbreak;\n\tcase DRM_FORMAT_RGB565:\n\t\tctrl |= AS_CTRL_FORMAT_RGB565 | AS_CTRL_ALPHA_CTRL_OVERRIDE;\n\t\tbreak;\n\tcase DRM_FORMAT_XRGB8888:\n\t\tctrl |= AS_CTRL_FORMAT_RGB888 | AS_CTRL_ALPHA_CTRL_OVERRIDE;\n\t\tbreak;\n\tcase DRM_FORMAT_ARGB8888:\n\t\tctrl |= AS_CTRL_FORMAT_ARGB8888 | AS_CTRL_ALPHA_CTRL_EMBEDDED;\n\t\tbreak;\n\t}\n\n\twritel(ctrl, mxsfb->base + LCDC_AS_CTRL);\n}\n\nstatic void mxsfb_plane_overlay_atomic_disable(struct drm_plane *plane,\n\t\t\t\t\t       struct drm_atomic_state *state)\n{\n\tstruct mxsfb_drm_private *mxsfb = to_mxsfb_drm_private(plane->dev);\n\n\twritel(0, mxsfb->base + LCDC_AS_CTRL);\n}\n\nstatic bool mxsfb_format_mod_supported(struct drm_plane *plane,\n\t\t\t\t       uint32_t format,\n\t\t\t\t       uint64_t modifier)\n{\n\treturn modifier == DRM_FORMAT_MOD_LINEAR;\n}\n\nstatic const struct drm_plane_helper_funcs mxsfb_plane_primary_helper_funcs = {\n\t.atomic_check = mxsfb_plane_atomic_check,\n\t.atomic_update = mxsfb_plane_primary_atomic_update,\n};\n\nstatic const struct drm_plane_helper_funcs mxsfb_plane_overlay_helper_funcs = {\n\t.atomic_check = mxsfb_plane_atomic_check,\n\t.atomic_update = mxsfb_plane_overlay_atomic_update,\n\t.atomic_disable = mxsfb_plane_overlay_atomic_disable,\n};\n\nstatic const struct drm_plane_funcs mxsfb_plane_funcs = {\n\t.format_mod_supported\t= mxsfb_format_mod_supported,\n\t.update_plane\t\t= drm_atomic_helper_update_plane,\n\t.disable_plane\t\t= drm_atomic_helper_disable_plane,\n\t.destroy\t\t= drm_plane_cleanup,\n\t.reset\t\t\t= drm_atomic_helper_plane_reset,\n\t.atomic_duplicate_state\t= drm_atomic_helper_plane_duplicate_state,\n\t.atomic_destroy_state\t= drm_atomic_helper_plane_destroy_state,\n};\n\nstatic const uint32_t mxsfb_primary_plane_formats[] = {\n\tDRM_FORMAT_RGB565,\n\tDRM_FORMAT_XRGB8888,\n};\n\nstatic const uint32_t mxsfb_overlay_plane_formats[] = {\n\tDRM_FORMAT_XRGB4444,\n\tDRM_FORMAT_ARGB4444,\n\tDRM_FORMAT_XRGB1555,\n\tDRM_FORMAT_ARGB1555,\n\tDRM_FORMAT_RGB565,\n\tDRM_FORMAT_XRGB8888,\n\tDRM_FORMAT_ARGB8888,\n};\n\nstatic const uint64_t mxsfb_modifiers[] = {\n\tDRM_FORMAT_MOD_LINEAR,\n\tDRM_FORMAT_MOD_INVALID\n};\n\n \n\nint mxsfb_kms_init(struct mxsfb_drm_private *mxsfb)\n{\n\tstruct drm_encoder *encoder = &mxsfb->encoder;\n\tstruct drm_crtc *crtc = &mxsfb->crtc;\n\tint ret;\n\n\tdrm_plane_helper_add(&mxsfb->planes.primary,\n\t\t\t     &mxsfb_plane_primary_helper_funcs);\n\tret = drm_universal_plane_init(mxsfb->drm, &mxsfb->planes.primary, 1,\n\t\t\t\t       &mxsfb_plane_funcs,\n\t\t\t\t       mxsfb_primary_plane_formats,\n\t\t\t\t       ARRAY_SIZE(mxsfb_primary_plane_formats),\n\t\t\t\t       mxsfb_modifiers, DRM_PLANE_TYPE_PRIMARY,\n\t\t\t\t       NULL);\n\tif (ret)\n\t\treturn ret;\n\n\tif (mxsfb->devdata->has_overlay) {\n\t\tdrm_plane_helper_add(&mxsfb->planes.overlay,\n\t\t\t\t     &mxsfb_plane_overlay_helper_funcs);\n\t\tret = drm_universal_plane_init(mxsfb->drm,\n\t\t\t\t\t       &mxsfb->planes.overlay, 1,\n\t\t\t\t\t       &mxsfb_plane_funcs,\n\t\t\t\t\t       mxsfb_overlay_plane_formats,\n\t\t\t\t\t       ARRAY_SIZE(mxsfb_overlay_plane_formats),\n\t\t\t\t\t       mxsfb_modifiers, DRM_PLANE_TYPE_OVERLAY,\n\t\t\t\t\t       NULL);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tdrm_crtc_helper_add(crtc, &mxsfb_crtc_helper_funcs);\n\tif (mxsfb->devdata->has_crc32) {\n\t\tret = drm_crtc_init_with_planes(mxsfb->drm, crtc,\n\t\t\t\t\t\t&mxsfb->planes.primary, NULL,\n\t\t\t\t\t\t&mxsfb_crtc_with_crc_funcs,\n\t\t\t\t\t\tNULL);\n\t} else {\n\t\tret = drm_crtc_init_with_planes(mxsfb->drm, crtc,\n\t\t\t\t\t\t&mxsfb->planes.primary, NULL,\n\t\t\t\t\t\t&mxsfb_crtc_funcs, NULL);\n\t}\n\tif (ret)\n\t\treturn ret;\n\n\tencoder->possible_crtcs = drm_crtc_mask(crtc);\n\treturn drm_encoder_init(mxsfb->drm, encoder, &mxsfb_encoder_funcs,\n\t\t\t\tDRM_MODE_ENCODER_NONE, NULL);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}