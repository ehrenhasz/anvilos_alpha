{
  "module_name": "ttm_execbuf_util.c",
  "hash_id": "1874136ec1095f4ae88c7237f6f5e9f6efc0bbc46ab0a84dd9cff600c713094e",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/ttm/ttm_execbuf_util.c",
  "human_readable_source": " \n \n\n#include <drm/ttm/ttm_execbuf_util.h>\n#include <drm/ttm/ttm_bo.h>\n\nstatic void ttm_eu_backoff_reservation_reverse(struct list_head *list,\n\t\t\t\t\t      struct ttm_validate_buffer *entry)\n{\n\tlist_for_each_entry_continue_reverse(entry, list, head) {\n\t\tstruct ttm_buffer_object *bo = entry->bo;\n\n\t\tdma_resv_unlock(bo->base.resv);\n\t}\n}\n\nvoid ttm_eu_backoff_reservation(struct ww_acquire_ctx *ticket,\n\t\t\t\tstruct list_head *list)\n{\n\tstruct ttm_validate_buffer *entry;\n\n\tif (list_empty(list))\n\t\treturn;\n\n\tlist_for_each_entry(entry, list, head) {\n\t\tstruct ttm_buffer_object *bo = entry->bo;\n\n\t\tttm_bo_move_to_lru_tail_unlocked(bo);\n\t\tdma_resv_unlock(bo->base.resv);\n\t}\n\n\tif (ticket)\n\t\tww_acquire_fini(ticket);\n}\nEXPORT_SYMBOL(ttm_eu_backoff_reservation);\n\n \n\nint ttm_eu_reserve_buffers(struct ww_acquire_ctx *ticket,\n\t\t\t   struct list_head *list, bool intr,\n\t\t\t   struct list_head *dups)\n{\n\tstruct ttm_validate_buffer *entry;\n\tint ret;\n\n\tif (list_empty(list))\n\t\treturn 0;\n\n\tif (ticket)\n\t\tww_acquire_init(ticket, &reservation_ww_class);\n\n\tlist_for_each_entry(entry, list, head) {\n\t\tstruct ttm_buffer_object *bo = entry->bo;\n\t\tunsigned int num_fences;\n\n\t\tret = ttm_bo_reserve(bo, intr, (ticket == NULL), ticket);\n\t\tif (ret == -EALREADY && dups) {\n\t\t\tstruct ttm_validate_buffer *safe = entry;\n\t\t\tentry = list_prev_entry(entry, head);\n\t\t\tlist_del(&safe->head);\n\t\t\tlist_add(&safe->head, dups);\n\t\t\tcontinue;\n\t\t}\n\n\t\tnum_fences = max(entry->num_shared, 1u);\n\t\tif (!ret) {\n\t\t\tret = dma_resv_reserve_fences(bo->base.resv,\n\t\t\t\t\t\t      num_fences);\n\t\t\tif (!ret)\n\t\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\tttm_eu_backoff_reservation_reverse(list, entry);\n\n\t\tif (ret == -EDEADLK) {\n\t\t\tret = ttm_bo_reserve_slowpath(bo, intr, ticket);\n\t\t}\n\n\t\tif (!ret)\n\t\t\tret = dma_resv_reserve_fences(bo->base.resv,\n\t\t\t\t\t\t      num_fences);\n\n\t\tif (unlikely(ret != 0)) {\n\t\t\tif (ticket) {\n\t\t\t\tww_acquire_done(ticket);\n\t\t\t\tww_acquire_fini(ticket);\n\t\t\t}\n\t\t\treturn ret;\n\t\t}\n\n\t\t \n\t\tlist_del(&entry->head);\n\t\tlist_add(&entry->head, list);\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL(ttm_eu_reserve_buffers);\n\nvoid ttm_eu_fence_buffer_objects(struct ww_acquire_ctx *ticket,\n\t\t\t\t struct list_head *list,\n\t\t\t\t struct dma_fence *fence)\n{\n\tstruct ttm_validate_buffer *entry;\n\n\tif (list_empty(list))\n\t\treturn;\n\n\tlist_for_each_entry(entry, list, head) {\n\t\tstruct ttm_buffer_object *bo = entry->bo;\n\n\t\tdma_resv_add_fence(bo->base.resv, fence, entry->num_shared ?\n\t\t\t\t   DMA_RESV_USAGE_READ : DMA_RESV_USAGE_WRITE);\n\t\tttm_bo_move_to_lru_tail_unlocked(bo);\n\t\tdma_resv_unlock(bo->base.resv);\n\t}\n\tif (ticket)\n\t\tww_acquire_fini(ticket);\n}\nEXPORT_SYMBOL(ttm_eu_fence_buffer_objects);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}