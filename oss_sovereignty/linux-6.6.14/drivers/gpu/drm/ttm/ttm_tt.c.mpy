{
  "module_name": "ttm_tt.c",
  "hash_id": "d564053327a863e0c272847a1175cde483155c73923ab7cf0c7ab17678bf232c",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/ttm/ttm_tt.c",
  "human_readable_source": " \n \n \n\n#define pr_fmt(fmt) \"[TTM] \" fmt\n\n#include <linux/sched.h>\n#include <linux/shmem_fs.h>\n#include <linux/file.h>\n#include <linux/module.h>\n#include <drm/drm_cache.h>\n#include <drm/ttm/ttm_bo.h>\n#include <drm/ttm/ttm_tt.h>\n\n#include \"ttm_module.h\"\n\nstatic unsigned long ttm_pages_limit;\n\nMODULE_PARM_DESC(pages_limit, \"Limit for the allocated pages\");\nmodule_param_named(pages_limit, ttm_pages_limit, ulong, 0644);\n\nstatic unsigned long ttm_dma32_pages_limit;\n\nMODULE_PARM_DESC(dma32_pages_limit, \"Limit for the allocated DMA32 pages\");\nmodule_param_named(dma32_pages_limit, ttm_dma32_pages_limit, ulong, 0644);\n\nstatic atomic_long_t ttm_pages_allocated;\nstatic atomic_long_t ttm_dma32_pages_allocated;\n\n \nint ttm_tt_create(struct ttm_buffer_object *bo, bool zero_alloc)\n{\n\tstruct ttm_device *bdev = bo->bdev;\n\tuint32_t page_flags = 0;\n\n\tdma_resv_assert_held(bo->base.resv);\n\n\tif (bo->ttm)\n\t\treturn 0;\n\n\tswitch (bo->type) {\n\tcase ttm_bo_type_device:\n\t\tif (zero_alloc)\n\t\t\tpage_flags |= TTM_TT_FLAG_ZERO_ALLOC;\n\t\tbreak;\n\tcase ttm_bo_type_kernel:\n\t\tbreak;\n\tcase ttm_bo_type_sg:\n\t\tpage_flags |= TTM_TT_FLAG_EXTERNAL;\n\t\tbreak;\n\tdefault:\n\t\tpr_err(\"Illegal buffer object type\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tbo->ttm = bdev->funcs->ttm_tt_create(bo, page_flags);\n\tif (unlikely(bo->ttm == NULL))\n\t\treturn -ENOMEM;\n\n\tWARN_ON(bo->ttm->page_flags & TTM_TT_FLAG_EXTERNAL_MAPPABLE &&\n\t\t!(bo->ttm->page_flags & TTM_TT_FLAG_EXTERNAL));\n\n\treturn 0;\n}\n\n \nstatic int ttm_tt_alloc_page_directory(struct ttm_tt *ttm)\n{\n\tttm->pages = kvcalloc(ttm->num_pages, sizeof(void*), GFP_KERNEL);\n\tif (!ttm->pages)\n\t\treturn -ENOMEM;\n\n\treturn 0;\n}\n\nstatic int ttm_dma_tt_alloc_page_directory(struct ttm_tt *ttm)\n{\n\tttm->pages = kvcalloc(ttm->num_pages, sizeof(*ttm->pages) +\n\t\t\t      sizeof(*ttm->dma_address), GFP_KERNEL);\n\tif (!ttm->pages)\n\t\treturn -ENOMEM;\n\n\tttm->dma_address = (void *)(ttm->pages + ttm->num_pages);\n\treturn 0;\n}\n\nstatic int ttm_sg_tt_alloc_page_directory(struct ttm_tt *ttm)\n{\n\tttm->dma_address = kvcalloc(ttm->num_pages, sizeof(*ttm->dma_address),\n\t\t\t\t    GFP_KERNEL);\n\tif (!ttm->dma_address)\n\t\treturn -ENOMEM;\n\n\treturn 0;\n}\n\nvoid ttm_tt_destroy(struct ttm_device *bdev, struct ttm_tt *ttm)\n{\n\tbdev->funcs->ttm_tt_destroy(bdev, ttm);\n}\n\nstatic void ttm_tt_init_fields(struct ttm_tt *ttm,\n\t\t\t       struct ttm_buffer_object *bo,\n\t\t\t       uint32_t page_flags,\n\t\t\t       enum ttm_caching caching,\n\t\t\t       unsigned long extra_pages)\n{\n\tttm->num_pages = (PAGE_ALIGN(bo->base.size) >> PAGE_SHIFT) + extra_pages;\n\tttm->page_flags = page_flags;\n\tttm->dma_address = NULL;\n\tttm->swap_storage = NULL;\n\tttm->sg = bo->sg;\n\tttm->caching = caching;\n}\n\nint ttm_tt_init(struct ttm_tt *ttm, struct ttm_buffer_object *bo,\n\t\tuint32_t page_flags, enum ttm_caching caching,\n\t\tunsigned long extra_pages)\n{\n\tttm_tt_init_fields(ttm, bo, page_flags, caching, extra_pages);\n\n\tif (ttm_tt_alloc_page_directory(ttm)) {\n\t\tpr_err(\"Failed allocating page table\\n\");\n\t\treturn -ENOMEM;\n\t}\n\treturn 0;\n}\nEXPORT_SYMBOL(ttm_tt_init);\n\nvoid ttm_tt_fini(struct ttm_tt *ttm)\n{\n\tWARN_ON(ttm->page_flags & TTM_TT_FLAG_PRIV_POPULATED);\n\n\tif (ttm->swap_storage)\n\t\tfput(ttm->swap_storage);\n\tttm->swap_storage = NULL;\n\n\tif (ttm->pages)\n\t\tkvfree(ttm->pages);\n\telse\n\t\tkvfree(ttm->dma_address);\n\tttm->pages = NULL;\n\tttm->dma_address = NULL;\n}\nEXPORT_SYMBOL(ttm_tt_fini);\n\nint ttm_sg_tt_init(struct ttm_tt *ttm, struct ttm_buffer_object *bo,\n\t\t   uint32_t page_flags, enum ttm_caching caching)\n{\n\tint ret;\n\n\tttm_tt_init_fields(ttm, bo, page_flags, caching, 0);\n\n\tif (page_flags & TTM_TT_FLAG_EXTERNAL)\n\t\tret = ttm_sg_tt_alloc_page_directory(ttm);\n\telse\n\t\tret = ttm_dma_tt_alloc_page_directory(ttm);\n\tif (ret) {\n\t\tpr_err(\"Failed allocating page table\\n\");\n\t\treturn -ENOMEM;\n\t}\n\treturn 0;\n}\nEXPORT_SYMBOL(ttm_sg_tt_init);\n\nint ttm_tt_swapin(struct ttm_tt *ttm)\n{\n\tstruct address_space *swap_space;\n\tstruct file *swap_storage;\n\tstruct page *from_page;\n\tstruct page *to_page;\n\tgfp_t gfp_mask;\n\tint i, ret;\n\n\tswap_storage = ttm->swap_storage;\n\tBUG_ON(swap_storage == NULL);\n\n\tswap_space = swap_storage->f_mapping;\n\tgfp_mask = mapping_gfp_mask(swap_space);\n\n\tfor (i = 0; i < ttm->num_pages; ++i) {\n\t\tfrom_page = shmem_read_mapping_page_gfp(swap_space, i,\n\t\t\t\t\t\t\tgfp_mask);\n\t\tif (IS_ERR(from_page)) {\n\t\t\tret = PTR_ERR(from_page);\n\t\t\tgoto out_err;\n\t\t}\n\t\tto_page = ttm->pages[i];\n\t\tif (unlikely(to_page == NULL)) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto out_err;\n\t\t}\n\n\t\tcopy_highpage(to_page, from_page);\n\t\tput_page(from_page);\n\t}\n\n\tfput(swap_storage);\n\tttm->swap_storage = NULL;\n\tttm->page_flags &= ~TTM_TT_FLAG_SWAPPED;\n\n\treturn 0;\n\nout_err:\n\treturn ret;\n}\n\n \nint ttm_tt_swapout(struct ttm_device *bdev, struct ttm_tt *ttm,\n\t\t   gfp_t gfp_flags)\n{\n\tloff_t size = (loff_t)ttm->num_pages << PAGE_SHIFT;\n\tstruct address_space *swap_space;\n\tstruct file *swap_storage;\n\tstruct page *from_page;\n\tstruct page *to_page;\n\tint i, ret;\n\n\tswap_storage = shmem_file_setup(\"ttm swap\", size, 0);\n\tif (IS_ERR(swap_storage)) {\n\t\tpr_err(\"Failed allocating swap storage\\n\");\n\t\treturn PTR_ERR(swap_storage);\n\t}\n\n\tswap_space = swap_storage->f_mapping;\n\tgfp_flags &= mapping_gfp_mask(swap_space);\n\n\tfor (i = 0; i < ttm->num_pages; ++i) {\n\t\tfrom_page = ttm->pages[i];\n\t\tif (unlikely(from_page == NULL))\n\t\t\tcontinue;\n\n\t\tto_page = shmem_read_mapping_page_gfp(swap_space, i, gfp_flags);\n\t\tif (IS_ERR(to_page)) {\n\t\t\tret = PTR_ERR(to_page);\n\t\t\tgoto out_err;\n\t\t}\n\t\tcopy_highpage(to_page, from_page);\n\t\tset_page_dirty(to_page);\n\t\tmark_page_accessed(to_page);\n\t\tput_page(to_page);\n\t}\n\n\tttm_tt_unpopulate(bdev, ttm);\n\tttm->swap_storage = swap_storage;\n\tttm->page_flags |= TTM_TT_FLAG_SWAPPED;\n\n\treturn ttm->num_pages;\n\nout_err:\n\tfput(swap_storage);\n\n\treturn ret;\n}\n\nint ttm_tt_populate(struct ttm_device *bdev,\n\t\t    struct ttm_tt *ttm, struct ttm_operation_ctx *ctx)\n{\n\tint ret;\n\n\tif (!ttm)\n\t\treturn -EINVAL;\n\n\tif (ttm_tt_is_populated(ttm))\n\t\treturn 0;\n\n\tif (!(ttm->page_flags & TTM_TT_FLAG_EXTERNAL)) {\n\t\tatomic_long_add(ttm->num_pages, &ttm_pages_allocated);\n\t\tif (bdev->pool.use_dma32)\n\t\t\tatomic_long_add(ttm->num_pages,\n\t\t\t\t\t&ttm_dma32_pages_allocated);\n\t}\n\n\twhile (atomic_long_read(&ttm_pages_allocated) > ttm_pages_limit ||\n\t       atomic_long_read(&ttm_dma32_pages_allocated) >\n\t       ttm_dma32_pages_limit) {\n\n\t\tret = ttm_global_swapout(ctx, GFP_KERNEL);\n\t\tif (ret == 0)\n\t\t\tbreak;\n\t\tif (ret < 0)\n\t\t\tgoto error;\n\t}\n\n\tif (bdev->funcs->ttm_tt_populate)\n\t\tret = bdev->funcs->ttm_tt_populate(bdev, ttm, ctx);\n\telse\n\t\tret = ttm_pool_alloc(&bdev->pool, ttm, ctx);\n\tif (ret)\n\t\tgoto error;\n\n\tttm->page_flags |= TTM_TT_FLAG_PRIV_POPULATED;\n\tif (unlikely(ttm->page_flags & TTM_TT_FLAG_SWAPPED)) {\n\t\tret = ttm_tt_swapin(ttm);\n\t\tif (unlikely(ret != 0)) {\n\t\t\tttm_tt_unpopulate(bdev, ttm);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn 0;\n\nerror:\n\tif (!(ttm->page_flags & TTM_TT_FLAG_EXTERNAL)) {\n\t\tatomic_long_sub(ttm->num_pages, &ttm_pages_allocated);\n\t\tif (bdev->pool.use_dma32)\n\t\t\tatomic_long_sub(ttm->num_pages,\n\t\t\t\t\t&ttm_dma32_pages_allocated);\n\t}\n\treturn ret;\n}\nEXPORT_SYMBOL(ttm_tt_populate);\n\nvoid ttm_tt_unpopulate(struct ttm_device *bdev, struct ttm_tt *ttm)\n{\n\tif (!ttm_tt_is_populated(ttm))\n\t\treturn;\n\n\tif (bdev->funcs->ttm_tt_unpopulate)\n\t\tbdev->funcs->ttm_tt_unpopulate(bdev, ttm);\n\telse\n\t\tttm_pool_free(&bdev->pool, ttm);\n\n\tif (!(ttm->page_flags & TTM_TT_FLAG_EXTERNAL)) {\n\t\tatomic_long_sub(ttm->num_pages, &ttm_pages_allocated);\n\t\tif (bdev->pool.use_dma32)\n\t\t\tatomic_long_sub(ttm->num_pages,\n\t\t\t\t\t&ttm_dma32_pages_allocated);\n\t}\n\n\tttm->page_flags &= ~TTM_TT_FLAG_PRIV_POPULATED;\n}\n\n#ifdef CONFIG_DEBUG_FS\n\n \nstatic int ttm_tt_debugfs_shrink_show(struct seq_file *m, void *data)\n{\n\tstruct ttm_operation_ctx ctx = { false, false };\n\n\tseq_printf(m, \"%d\\n\", ttm_global_swapout(&ctx, GFP_KERNEL));\n\treturn 0;\n}\nDEFINE_SHOW_ATTRIBUTE(ttm_tt_debugfs_shrink);\n\n#endif\n\n\n \nvoid ttm_tt_mgr_init(unsigned long num_pages, unsigned long num_dma32_pages)\n{\n#ifdef CONFIG_DEBUG_FS\n\tdebugfs_create_file(\"tt_shrink\", 0400, ttm_debugfs_root, NULL,\n\t\t\t    &ttm_tt_debugfs_shrink_fops);\n#endif\n\n\tif (!ttm_pages_limit)\n\t\tttm_pages_limit = num_pages;\n\n\tif (!ttm_dma32_pages_limit)\n\t\tttm_dma32_pages_limit = num_dma32_pages;\n}\n\nstatic void ttm_kmap_iter_tt_map_local(struct ttm_kmap_iter *iter,\n\t\t\t\t       struct iosys_map *dmap,\n\t\t\t\t       pgoff_t i)\n{\n\tstruct ttm_kmap_iter_tt *iter_tt =\n\t\tcontainer_of(iter, typeof(*iter_tt), base);\n\n\tiosys_map_set_vaddr(dmap, kmap_local_page_prot(iter_tt->tt->pages[i],\n\t\t\t\t\t\t       iter_tt->prot));\n}\n\nstatic void ttm_kmap_iter_tt_unmap_local(struct ttm_kmap_iter *iter,\n\t\t\t\t\t struct iosys_map *map)\n{\n\tkunmap_local(map->vaddr);\n}\n\nstatic const struct ttm_kmap_iter_ops ttm_kmap_iter_tt_ops = {\n\t.map_local = ttm_kmap_iter_tt_map_local,\n\t.unmap_local = ttm_kmap_iter_tt_unmap_local,\n\t.maps_tt = true,\n};\n\n \nstruct ttm_kmap_iter *\nttm_kmap_iter_tt_init(struct ttm_kmap_iter_tt *iter_tt,\n\t\t      struct ttm_tt *tt)\n{\n\titer_tt->base.ops = &ttm_kmap_iter_tt_ops;\n\titer_tt->tt = tt;\n\tif (tt)\n\t\titer_tt->prot = ttm_prot_from_caching(tt->caching, PAGE_KERNEL);\n\telse\n\t\titer_tt->prot = PAGE_KERNEL;\n\n\treturn &iter_tt->base;\n}\nEXPORT_SYMBOL(ttm_kmap_iter_tt_init);\n\nunsigned long ttm_tt_pages_limit(void)\n{\n\treturn ttm_pages_limit;\n}\nEXPORT_SYMBOL(ttm_tt_pages_limit);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}