{
  "module_name": "ttm_device.c",
  "hash_id": "e1fb2d735ab223dea2d4f852b7d26d4b92947ce792c92f20ad9eb532721100f4",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/ttm/ttm_device.c",
  "human_readable_source": " \n\n \n\n#define pr_fmt(fmt) \"[TTM DEVICE] \" fmt\n\n#include <linux/mm.h>\n\n#include <drm/ttm/ttm_bo.h>\n#include <drm/ttm/ttm_device.h>\n#include <drm/ttm/ttm_tt.h>\n#include <drm/ttm/ttm_placement.h>\n\n#include \"ttm_module.h\"\n\n \nstatic DEFINE_MUTEX(ttm_global_mutex);\nstatic unsigned ttm_glob_use_count;\nstruct ttm_global ttm_glob;\nEXPORT_SYMBOL(ttm_glob);\n\nstruct dentry *ttm_debugfs_root;\n\nstatic void ttm_global_release(void)\n{\n\tstruct ttm_global *glob = &ttm_glob;\n\n\tmutex_lock(&ttm_global_mutex);\n\tif (--ttm_glob_use_count > 0)\n\t\tgoto out;\n\n\tttm_pool_mgr_fini();\n\tdebugfs_remove(ttm_debugfs_root);\n\n\t__free_page(glob->dummy_read_page);\n\tmemset(glob, 0, sizeof(*glob));\nout:\n\tmutex_unlock(&ttm_global_mutex);\n}\n\nstatic int ttm_global_init(void)\n{\n\tstruct ttm_global *glob = &ttm_glob;\n\tunsigned long num_pages, num_dma32;\n\tstruct sysinfo si;\n\tint ret = 0;\n\n\tmutex_lock(&ttm_global_mutex);\n\tif (++ttm_glob_use_count > 1)\n\t\tgoto out;\n\n\tsi_meminfo(&si);\n\n\tttm_debugfs_root = debugfs_create_dir(\"ttm\", NULL);\n\tif (IS_ERR(ttm_debugfs_root)) {\n\t\tttm_debugfs_root = NULL;\n\t}\n\n\t \n\tnum_pages = ((u64)si.totalram * si.mem_unit) >> PAGE_SHIFT;\n\tnum_pages /= 2;\n\n\t \n\tnum_dma32 = (u64)(si.totalram - si.totalhigh) * si.mem_unit\n\t\t>> PAGE_SHIFT;\n\tnum_dma32 = min(num_dma32, 2UL << (30 - PAGE_SHIFT));\n\n\tttm_pool_mgr_init(num_pages);\n\tttm_tt_mgr_init(num_pages, num_dma32);\n\n\tglob->dummy_read_page = alloc_page(__GFP_ZERO | GFP_DMA32);\n\n\tif (unlikely(glob->dummy_read_page == NULL)) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tINIT_LIST_HEAD(&glob->device_list);\n\tatomic_set(&glob->bo_count, 0);\n\n\tdebugfs_create_atomic_t(\"buffer_objects\", 0444, ttm_debugfs_root,\n\t\t\t\t&glob->bo_count);\nout:\n\tif (ret && ttm_debugfs_root)\n\t\tdebugfs_remove(ttm_debugfs_root);\n\tif (ret)\n\t\t--ttm_glob_use_count;\n\tmutex_unlock(&ttm_global_mutex);\n\treturn ret;\n}\n\n \nint ttm_global_swapout(struct ttm_operation_ctx *ctx, gfp_t gfp_flags)\n{\n\tstruct ttm_global *glob = &ttm_glob;\n\tstruct ttm_device *bdev;\n\tint ret = 0;\n\n\tmutex_lock(&ttm_global_mutex);\n\tlist_for_each_entry(bdev, &glob->device_list, device_list) {\n\t\tret = ttm_device_swapout(bdev, ctx, gfp_flags);\n\t\tif (ret > 0) {\n\t\t\tlist_move_tail(&bdev->device_list, &glob->device_list);\n\t\t\tbreak;\n\t\t}\n\t}\n\tmutex_unlock(&ttm_global_mutex);\n\treturn ret;\n}\n\nint ttm_device_swapout(struct ttm_device *bdev, struct ttm_operation_ctx *ctx,\n\t\t       gfp_t gfp_flags)\n{\n\tstruct ttm_resource_cursor cursor;\n\tstruct ttm_resource_manager *man;\n\tstruct ttm_resource *res;\n\tunsigned i;\n\tint ret;\n\n\tspin_lock(&bdev->lru_lock);\n\tfor (i = TTM_PL_SYSTEM; i < TTM_NUM_MEM_TYPES; ++i) {\n\t\tman = ttm_manager_type(bdev, i);\n\t\tif (!man || !man->use_tt)\n\t\t\tcontinue;\n\n\t\tttm_resource_manager_for_each_res(man, &cursor, res) {\n\t\t\tstruct ttm_buffer_object *bo = res->bo;\n\t\t\tuint32_t num_pages;\n\n\t\t\tif (!bo || bo->resource != res)\n\t\t\t\tcontinue;\n\n\t\t\tnum_pages = PFN_UP(bo->base.size);\n\t\t\tret = ttm_bo_swapout(bo, ctx, gfp_flags);\n\t\t\t \n\t\t\tif (!ret)\n\t\t\t\treturn num_pages;\n\t\t\tif (ret != -EBUSY)\n\t\t\t\treturn ret;\n\t\t}\n\t}\n\tspin_unlock(&bdev->lru_lock);\n\treturn 0;\n}\nEXPORT_SYMBOL(ttm_device_swapout);\n\n \nint ttm_device_init(struct ttm_device *bdev, const struct ttm_device_funcs *funcs,\n\t\t    struct device *dev, struct address_space *mapping,\n\t\t    struct drm_vma_offset_manager *vma_manager,\n\t\t    bool use_dma_alloc, bool use_dma32)\n{\n\tstruct ttm_global *glob = &ttm_glob;\n\tint ret;\n\n\tif (WARN_ON(vma_manager == NULL))\n\t\treturn -EINVAL;\n\n\tret = ttm_global_init();\n\tif (ret)\n\t\treturn ret;\n\n\tbdev->wq = alloc_workqueue(\"ttm\", WQ_MEM_RECLAIM | WQ_HIGHPRI, 16);\n\tif (!bdev->wq) {\n\t\tttm_global_release();\n\t\treturn -ENOMEM;\n\t}\n\n\tbdev->funcs = funcs;\n\n\tttm_sys_man_init(bdev);\n\tttm_pool_init(&bdev->pool, dev, NUMA_NO_NODE, use_dma_alloc, use_dma32);\n\n\tbdev->vma_manager = vma_manager;\n\tspin_lock_init(&bdev->lru_lock);\n\tINIT_LIST_HEAD(&bdev->pinned);\n\tbdev->dev_mapping = mapping;\n\tmutex_lock(&ttm_global_mutex);\n\tlist_add_tail(&bdev->device_list, &glob->device_list);\n\tmutex_unlock(&ttm_global_mutex);\n\n\treturn 0;\n}\nEXPORT_SYMBOL(ttm_device_init);\n\nvoid ttm_device_fini(struct ttm_device *bdev)\n{\n\tstruct ttm_resource_manager *man;\n\tunsigned i;\n\n\tmutex_lock(&ttm_global_mutex);\n\tlist_del(&bdev->device_list);\n\tmutex_unlock(&ttm_global_mutex);\n\n\tdrain_workqueue(bdev->wq);\n\tdestroy_workqueue(bdev->wq);\n\n\tman = ttm_manager_type(bdev, TTM_PL_SYSTEM);\n\tttm_resource_manager_set_used(man, false);\n\tttm_set_driver_manager(bdev, TTM_PL_SYSTEM, NULL);\n\n\tspin_lock(&bdev->lru_lock);\n\tfor (i = 0; i < TTM_MAX_BO_PRIORITY; ++i)\n\t\tif (list_empty(&man->lru[0]))\n\t\t\tpr_debug(\"Swap list %d was clean\\n\", i);\n\tspin_unlock(&bdev->lru_lock);\n\n\tttm_pool_fini(&bdev->pool);\n\tttm_global_release();\n}\nEXPORT_SYMBOL(ttm_device_fini);\n\nstatic void ttm_device_clear_lru_dma_mappings(struct ttm_device *bdev,\n\t\t\t\t\t      struct list_head *list)\n{\n\tstruct ttm_resource *res;\n\n\tspin_lock(&bdev->lru_lock);\n\twhile ((res = list_first_entry_or_null(list, typeof(*res), lru))) {\n\t\tstruct ttm_buffer_object *bo = res->bo;\n\n\t\t \n\t\tif (!ttm_bo_get_unless_zero(bo))\n\t\t\tcontinue;\n\n\t\tlist_del_init(&res->lru);\n\t\tspin_unlock(&bdev->lru_lock);\n\n\t\tif (bo->ttm)\n\t\t\tttm_tt_unpopulate(bo->bdev, bo->ttm);\n\n\t\tttm_bo_put(bo);\n\t\tspin_lock(&bdev->lru_lock);\n\t}\n\tspin_unlock(&bdev->lru_lock);\n}\n\nvoid ttm_device_clear_dma_mappings(struct ttm_device *bdev)\n{\n\tstruct ttm_resource_manager *man;\n\tunsigned int i, j;\n\n\tttm_device_clear_lru_dma_mappings(bdev, &bdev->pinned);\n\n\tfor (i = TTM_PL_SYSTEM; i < TTM_NUM_MEM_TYPES; ++i) {\n\t\tman = ttm_manager_type(bdev, i);\n\t\tif (!man || !man->use_tt)\n\t\t\tcontinue;\n\n\t\tfor (j = 0; j < TTM_MAX_BO_PRIORITY; ++j)\n\t\t\tttm_device_clear_lru_dma_mappings(bdev, &man->lru[j]);\n\t}\n}\nEXPORT_SYMBOL(ttm_device_clear_dma_mappings);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}