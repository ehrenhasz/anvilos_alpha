{
  "module_name": "ttm_agp_backend.c",
  "hash_id": "caba41c21d8b5f0468ebfe1b8c3de23e4dd0328e65fcd376ac5c04433760b007",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/ttm/ttm_agp_backend.c",
  "human_readable_source": " \n \n \n\n#define pr_fmt(fmt) \"[TTM] \" fmt\n\n#include <drm/ttm/ttm_device.h>\n#include <drm/ttm/ttm_tt.h>\n#include <drm/ttm/ttm_resource.h>\n#include <linux/agp_backend.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/io.h>\n#include <asm/agp.h>\n\nstruct ttm_agp_backend {\n\tstruct ttm_tt ttm;\n\tstruct agp_memory *mem;\n\tstruct agp_bridge_data *bridge;\n};\n\nint ttm_agp_bind(struct ttm_tt *ttm, struct ttm_resource *bo_mem)\n{\n\tstruct ttm_agp_backend *agp_be = container_of(ttm, struct ttm_agp_backend, ttm);\n\tstruct page *dummy_read_page = ttm_glob.dummy_read_page;\n\tstruct agp_memory *mem;\n\tint ret, cached = ttm->caching == ttm_cached;\n\tunsigned i;\n\n\tif (agp_be->mem)\n\t\treturn 0;\n\n\tmem = agp_allocate_memory(agp_be->bridge, ttm->num_pages, AGP_USER_MEMORY);\n\tif (unlikely(mem == NULL))\n\t\treturn -ENOMEM;\n\n\tmem->page_count = 0;\n\tfor (i = 0; i < ttm->num_pages; i++) {\n\t\tstruct page *page = ttm->pages[i];\n\n\t\tif (!page)\n\t\t\tpage = dummy_read_page;\n\n\t\tmem->pages[mem->page_count++] = page;\n\t}\n\tagp_be->mem = mem;\n\n\tmem->is_flushed = 1;\n\tmem->type = (cached) ? AGP_USER_CACHED_MEMORY : AGP_USER_MEMORY;\n\n\tret = agp_bind_memory(mem, bo_mem->start);\n\tif (ret)\n\t\tpr_err(\"AGP Bind memory failed\\n\");\n\n\treturn ret;\n}\nEXPORT_SYMBOL(ttm_agp_bind);\n\nvoid ttm_agp_unbind(struct ttm_tt *ttm)\n{\n\tstruct ttm_agp_backend *agp_be = container_of(ttm, struct ttm_agp_backend, ttm);\n\n\tif (agp_be->mem) {\n\t\tif (agp_be->mem->is_bound) {\n\t\t\tagp_unbind_memory(agp_be->mem);\n\t\t\treturn;\n\t\t}\n\t\tagp_free_memory(agp_be->mem);\n\t\tagp_be->mem = NULL;\n\t}\n}\nEXPORT_SYMBOL(ttm_agp_unbind);\n\nbool ttm_agp_is_bound(struct ttm_tt *ttm)\n{\n\tstruct ttm_agp_backend *agp_be = container_of(ttm, struct ttm_agp_backend, ttm);\n\n\tif (!ttm)\n\t\treturn false;\n\n\treturn (agp_be->mem != NULL);\n}\nEXPORT_SYMBOL(ttm_agp_is_bound);\n\nvoid ttm_agp_destroy(struct ttm_tt *ttm)\n{\n\tstruct ttm_agp_backend *agp_be = container_of(ttm, struct ttm_agp_backend, ttm);\n\n\tif (agp_be->mem)\n\t\tttm_agp_unbind(ttm);\n\tttm_tt_fini(ttm);\n\tkfree(agp_be);\n}\nEXPORT_SYMBOL(ttm_agp_destroy);\n\nstruct ttm_tt *ttm_agp_tt_create(struct ttm_buffer_object *bo,\n\t\t\t\t struct agp_bridge_data *bridge,\n\t\t\t\t uint32_t page_flags)\n{\n\tstruct ttm_agp_backend *agp_be;\n\n\tagp_be = kmalloc(sizeof(*agp_be), GFP_KERNEL);\n\tif (!agp_be)\n\t\treturn NULL;\n\n\tagp_be->mem = NULL;\n\tagp_be->bridge = bridge;\n\n\tif (ttm_tt_init(&agp_be->ttm, bo, page_flags, ttm_write_combined, 0)) {\n\t\tkfree(agp_be);\n\t\treturn NULL;\n\t}\n\n\treturn &agp_be->ttm;\n}\nEXPORT_SYMBOL(ttm_agp_tt_create);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}