{
  "module_name": "ttm_range_manager.c",
  "hash_id": "80a89bbe3f9f657adf6f0db5c2606cd3e64b31221dcfc03c1d51d5defbeae55d",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/ttm/ttm_range_manager.c",
  "human_readable_source": " \n \n \n\n#include <drm/ttm/ttm_device.h>\n#include <drm/ttm/ttm_placement.h>\n#include <drm/ttm/ttm_range_manager.h>\n#include <drm/ttm/ttm_bo.h>\n#include <drm/drm_mm.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n\n \n\nstruct ttm_range_manager {\n\tstruct ttm_resource_manager manager;\n\tstruct drm_mm mm;\n\tspinlock_t lock;\n};\n\nstatic inline struct ttm_range_manager *\nto_range_manager(struct ttm_resource_manager *man)\n{\n\treturn container_of(man, struct ttm_range_manager, manager);\n}\n\nstatic int ttm_range_man_alloc(struct ttm_resource_manager *man,\n\t\t\t       struct ttm_buffer_object *bo,\n\t\t\t       const struct ttm_place *place,\n\t\t\t       struct ttm_resource **res)\n{\n\tstruct ttm_range_manager *rman = to_range_manager(man);\n\tstruct ttm_range_mgr_node *node;\n\tstruct drm_mm *mm = &rman->mm;\n\tenum drm_mm_insert_mode mode;\n\tunsigned long lpfn;\n\tint ret;\n\n\tlpfn = place->lpfn;\n\tif (!lpfn)\n\t\tlpfn = man->size;\n\n\tnode = kzalloc(struct_size(node, mm_nodes, 1), GFP_KERNEL);\n\tif (!node)\n\t\treturn -ENOMEM;\n\n\tmode = DRM_MM_INSERT_BEST;\n\tif (place->flags & TTM_PL_FLAG_TOPDOWN)\n\t\tmode = DRM_MM_INSERT_HIGH;\n\n\tttm_resource_init(bo, place, &node->base);\n\n\tspin_lock(&rman->lock);\n\tret = drm_mm_insert_node_in_range(mm, &node->mm_nodes[0],\n\t\t\t\t\t  PFN_UP(node->base.size),\n\t\t\t\t\t  bo->page_alignment, 0,\n\t\t\t\t\t  place->fpfn, lpfn, mode);\n\tspin_unlock(&rman->lock);\n\n\tif (unlikely(ret)) {\n\t\tttm_resource_fini(man, &node->base);\n\t\tkfree(node);\n\t\treturn ret;\n\t}\n\n\tnode->base.start = node->mm_nodes[0].start;\n\t*res = &node->base;\n\treturn 0;\n}\n\nstatic void ttm_range_man_free(struct ttm_resource_manager *man,\n\t\t\t       struct ttm_resource *res)\n{\n\tstruct ttm_range_mgr_node *node = to_ttm_range_mgr_node(res);\n\tstruct ttm_range_manager *rman = to_range_manager(man);\n\n\tspin_lock(&rman->lock);\n\tdrm_mm_remove_node(&node->mm_nodes[0]);\n\tspin_unlock(&rman->lock);\n\n\tttm_resource_fini(man, res);\n\tkfree(node);\n}\n\nstatic bool ttm_range_man_intersects(struct ttm_resource_manager *man,\n\t\t\t\t     struct ttm_resource *res,\n\t\t\t\t     const struct ttm_place *place,\n\t\t\t\t     size_t size)\n{\n\tstruct drm_mm_node *node = &to_ttm_range_mgr_node(res)->mm_nodes[0];\n\tu32 num_pages = PFN_UP(size);\n\n\t \n\tif (place->fpfn >= (node->start + num_pages) ||\n\t    (place->lpfn && place->lpfn <= node->start))\n\t\treturn false;\n\n\treturn true;\n}\n\nstatic bool ttm_range_man_compatible(struct ttm_resource_manager *man,\n\t\t\t\t     struct ttm_resource *res,\n\t\t\t\t     const struct ttm_place *place,\n\t\t\t\t     size_t size)\n{\n\tstruct drm_mm_node *node = &to_ttm_range_mgr_node(res)->mm_nodes[0];\n\tu32 num_pages = PFN_UP(size);\n\n\tif (node->start < place->fpfn ||\n\t    (place->lpfn && (node->start + num_pages) > place->lpfn))\n\t\treturn false;\n\n\treturn true;\n}\n\nstatic void ttm_range_man_debug(struct ttm_resource_manager *man,\n\t\t\t\tstruct drm_printer *printer)\n{\n\tstruct ttm_range_manager *rman = to_range_manager(man);\n\n\tspin_lock(&rman->lock);\n\tdrm_mm_print(&rman->mm, printer);\n\tspin_unlock(&rman->lock);\n}\n\nstatic const struct ttm_resource_manager_func ttm_range_manager_func = {\n\t.alloc = ttm_range_man_alloc,\n\t.free = ttm_range_man_free,\n\t.intersects = ttm_range_man_intersects,\n\t.compatible = ttm_range_man_compatible,\n\t.debug = ttm_range_man_debug\n};\n\n \nint ttm_range_man_init_nocheck(struct ttm_device *bdev,\n\t\t       unsigned type, bool use_tt,\n\t\t       unsigned long p_size)\n{\n\tstruct ttm_resource_manager *man;\n\tstruct ttm_range_manager *rman;\n\n\trman = kzalloc(sizeof(*rman), GFP_KERNEL);\n\tif (!rman)\n\t\treturn -ENOMEM;\n\n\tman = &rman->manager;\n\tman->use_tt = use_tt;\n\n\tman->func = &ttm_range_manager_func;\n\n\tttm_resource_manager_init(man, bdev, p_size);\n\n\tdrm_mm_init(&rman->mm, 0, p_size);\n\tspin_lock_init(&rman->lock);\n\n\tttm_set_driver_manager(bdev, type, &rman->manager);\n\tttm_resource_manager_set_used(man, true);\n\treturn 0;\n}\nEXPORT_SYMBOL(ttm_range_man_init_nocheck);\n\n \nint ttm_range_man_fini_nocheck(struct ttm_device *bdev,\n\t\t       unsigned type)\n{\n\tstruct ttm_resource_manager *man = ttm_manager_type(bdev, type);\n\tstruct ttm_range_manager *rman = to_range_manager(man);\n\tstruct drm_mm *mm = &rman->mm;\n\tint ret;\n\n\tif (!man)\n\t\treturn 0;\n\n\tttm_resource_manager_set_used(man, false);\n\n\tret = ttm_resource_manager_evict_all(bdev, man);\n\tif (ret)\n\t\treturn ret;\n\n\tspin_lock(&rman->lock);\n\tdrm_mm_takedown(mm);\n\tspin_unlock(&rman->lock);\n\n\tttm_resource_manager_cleanup(man);\n\tttm_set_driver_manager(bdev, type, NULL);\n\tkfree(rman);\n\treturn 0;\n}\nEXPORT_SYMBOL(ttm_range_man_fini_nocheck);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}