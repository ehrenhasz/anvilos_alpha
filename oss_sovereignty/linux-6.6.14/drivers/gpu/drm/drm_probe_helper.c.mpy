{
  "module_name": "drm_probe_helper.c",
  "hash_id": "30e1d39ec93719f61cd596895eca1230bc26af52e2626db57f6155293516c052",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/drm_probe_helper.c",
  "human_readable_source": " \n\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n\n#include <drm/drm_bridge.h>\n#include <drm/drm_client.h>\n#include <drm/drm_crtc.h>\n#include <drm/drm_edid.h>\n#include <drm/drm_fourcc.h>\n#include <drm/drm_modeset_helper_vtables.h>\n#include <drm/drm_print.h>\n#include <drm/drm_probe_helper.h>\n#include <drm/drm_sysfs.h>\n\n#include \"drm_crtc_helper_internal.h\"\n\n \n\nstatic bool drm_kms_helper_poll = true;\nmodule_param_named(poll, drm_kms_helper_poll, bool, 0600);\n\nstatic enum drm_mode_status\ndrm_mode_validate_flag(const struct drm_display_mode *mode,\n\t\t       int flags)\n{\n\tif ((mode->flags & DRM_MODE_FLAG_INTERLACE) &&\n\t    !(flags & DRM_MODE_FLAG_INTERLACE))\n\t\treturn MODE_NO_INTERLACE;\n\n\tif ((mode->flags & DRM_MODE_FLAG_DBLSCAN) &&\n\t    !(flags & DRM_MODE_FLAG_DBLSCAN))\n\t\treturn MODE_NO_DBLESCAN;\n\n\tif ((mode->flags & DRM_MODE_FLAG_3D_MASK) &&\n\t    !(flags & DRM_MODE_FLAG_3D_MASK))\n\t\treturn MODE_NO_STEREO;\n\n\treturn MODE_OK;\n}\n\nstatic int\ndrm_mode_validate_pipeline(struct drm_display_mode *mode,\n\t\t\t   struct drm_connector *connector,\n\t\t\t   struct drm_modeset_acquire_ctx *ctx,\n\t\t\t   enum drm_mode_status *status)\n{\n\tstruct drm_device *dev = connector->dev;\n\tstruct drm_encoder *encoder;\n\tint ret;\n\n\t \n\tret = drm_connector_mode_valid(connector, mode, ctx, status);\n\tif (ret || *status != MODE_OK)\n\t\treturn ret;\n\n\t \n\tdrm_connector_for_each_possible_encoder(connector, encoder) {\n\t\tstruct drm_bridge *bridge;\n\t\tstruct drm_crtc *crtc;\n\n\t\t*status = drm_encoder_mode_valid(encoder, mode);\n\t\tif (*status != MODE_OK) {\n\t\t\t \n\t\t\tcontinue;\n\t\t}\n\n\t\tbridge = drm_bridge_chain_get_first_bridge(encoder);\n\t\t*status = drm_bridge_chain_mode_valid(bridge,\n\t\t\t\t\t\t      &connector->display_info,\n\t\t\t\t\t\t      mode);\n\t\tif (*status != MODE_OK) {\n\t\t\t \n\t\t\tcontinue;\n\t\t}\n\n\t\tdrm_for_each_crtc(crtc, dev) {\n\t\t\tif (!drm_encoder_crtc_ok(encoder, crtc))\n\t\t\t\tcontinue;\n\n\t\t\t*status = drm_crtc_mode_valid(crtc, mode);\n\t\t\tif (*status == MODE_OK) {\n\t\t\t\t \n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int drm_helper_probe_add_cmdline_mode(struct drm_connector *connector)\n{\n\tstruct drm_cmdline_mode *cmdline_mode;\n\tstruct drm_display_mode *mode;\n\n\tcmdline_mode = &connector->cmdline_mode;\n\tif (!cmdline_mode->specified)\n\t\treturn 0;\n\n\t \n\tlist_for_each_entry(mode, &connector->probed_modes, head) {\n\t\tif (mode->hdisplay != cmdline_mode->xres ||\n\t\t    mode->vdisplay != cmdline_mode->yres)\n\t\t\tcontinue;\n\n\t\tif (cmdline_mode->refresh_specified) {\n\t\t\t \n\t\t\tif (drm_mode_vrefresh(mode) != cmdline_mode->refresh)\n\t\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\tmode->type |= DRM_MODE_TYPE_USERDEF;\n\t\treturn 0;\n\t}\n\n\tmode = drm_mode_create_from_cmdline_mode(connector->dev,\n\t\t\t\t\t\t cmdline_mode);\n\tif (mode == NULL)\n\t\treturn 0;\n\n\tdrm_mode_probed_add(connector, mode);\n\treturn 1;\n}\n\nenum drm_mode_status drm_crtc_mode_valid(struct drm_crtc *crtc,\n\t\t\t\t\t const struct drm_display_mode *mode)\n{\n\tconst struct drm_crtc_helper_funcs *crtc_funcs = crtc->helper_private;\n\n\tif (!crtc_funcs || !crtc_funcs->mode_valid)\n\t\treturn MODE_OK;\n\n\treturn crtc_funcs->mode_valid(crtc, mode);\n}\n\nenum drm_mode_status drm_encoder_mode_valid(struct drm_encoder *encoder,\n\t\t\t\t\t    const struct drm_display_mode *mode)\n{\n\tconst struct drm_encoder_helper_funcs *encoder_funcs =\n\t\tencoder->helper_private;\n\n\tif (!encoder_funcs || !encoder_funcs->mode_valid)\n\t\treturn MODE_OK;\n\n\treturn encoder_funcs->mode_valid(encoder, mode);\n}\n\nint\ndrm_connector_mode_valid(struct drm_connector *connector,\n\t\t\t struct drm_display_mode *mode,\n\t\t\t struct drm_modeset_acquire_ctx *ctx,\n\t\t\t enum drm_mode_status *status)\n{\n\tconst struct drm_connector_helper_funcs *connector_funcs =\n\t\tconnector->helper_private;\n\tint ret = 0;\n\n\tif (!connector_funcs)\n\t\t*status = MODE_OK;\n\telse if (connector_funcs->mode_valid_ctx)\n\t\tret = connector_funcs->mode_valid_ctx(connector, mode, ctx,\n\t\t\t\t\t\t      status);\n\telse if (connector_funcs->mode_valid)\n\t\t*status = connector_funcs->mode_valid(connector, mode);\n\telse\n\t\t*status = MODE_OK;\n\n\treturn ret;\n}\n\nstatic void drm_kms_helper_disable_hpd(struct drm_device *dev)\n{\n\tstruct drm_connector *connector;\n\tstruct drm_connector_list_iter conn_iter;\n\n\tdrm_connector_list_iter_begin(dev, &conn_iter);\n\tdrm_for_each_connector_iter(connector, &conn_iter) {\n\t\tconst struct drm_connector_helper_funcs *funcs =\n\t\t\tconnector->helper_private;\n\n\t\tif (funcs && funcs->disable_hpd)\n\t\t\tfuncs->disable_hpd(connector);\n\t}\n\tdrm_connector_list_iter_end(&conn_iter);\n}\n\nstatic bool drm_kms_helper_enable_hpd(struct drm_device *dev)\n{\n\tbool poll = false;\n\tstruct drm_connector *connector;\n\tstruct drm_connector_list_iter conn_iter;\n\n\tdrm_connector_list_iter_begin(dev, &conn_iter);\n\tdrm_for_each_connector_iter(connector, &conn_iter) {\n\t\tconst struct drm_connector_helper_funcs *funcs =\n\t\t\tconnector->helper_private;\n\n\t\tif (funcs && funcs->enable_hpd)\n\t\t\tfuncs->enable_hpd(connector);\n\n\t\tif (connector->polled & (DRM_CONNECTOR_POLL_CONNECT |\n\t\t\t\t\t DRM_CONNECTOR_POLL_DISCONNECT))\n\t\t\tpoll = true;\n\t}\n\tdrm_connector_list_iter_end(&conn_iter);\n\n\treturn poll;\n}\n\n#define DRM_OUTPUT_POLL_PERIOD (10*HZ)\nstatic void reschedule_output_poll_work(struct drm_device *dev)\n{\n\tunsigned long delay = DRM_OUTPUT_POLL_PERIOD;\n\n\tif (dev->mode_config.delayed_event)\n\t\t \n\t\tdelay = HZ;\n\n\tschedule_delayed_work(&dev->mode_config.output_poll_work, delay);\n}\n\n \nvoid drm_kms_helper_poll_enable(struct drm_device *dev)\n{\n\tif (!dev->mode_config.poll_enabled || !drm_kms_helper_poll ||\n\t    dev->mode_config.poll_running)\n\t\treturn;\n\n\tif (drm_kms_helper_enable_hpd(dev) ||\n\t    dev->mode_config.delayed_event)\n\t\treschedule_output_poll_work(dev);\n\n\tdev->mode_config.poll_running = true;\n}\nEXPORT_SYMBOL(drm_kms_helper_poll_enable);\n\n \nvoid drm_kms_helper_poll_reschedule(struct drm_device *dev)\n{\n\tif (dev->mode_config.poll_running)\n\t\treschedule_output_poll_work(dev);\n}\nEXPORT_SYMBOL(drm_kms_helper_poll_reschedule);\n\nstatic enum drm_connector_status\ndrm_helper_probe_detect_ctx(struct drm_connector *connector, bool force)\n{\n\tconst struct drm_connector_helper_funcs *funcs = connector->helper_private;\n\tstruct drm_modeset_acquire_ctx ctx;\n\tint ret;\n\n\tdrm_modeset_acquire_init(&ctx, 0);\n\nretry:\n\tret = drm_modeset_lock(&connector->dev->mode_config.connection_mutex, &ctx);\n\tif (!ret) {\n\t\tif (funcs->detect_ctx)\n\t\t\tret = funcs->detect_ctx(connector, &ctx, force);\n\t\telse if (connector->funcs->detect)\n\t\t\tret = connector->funcs->detect(connector, force);\n\t\telse\n\t\t\tret = connector_status_connected;\n\t}\n\n\tif (ret == -EDEADLK) {\n\t\tdrm_modeset_backoff(&ctx);\n\t\tgoto retry;\n\t}\n\n\tif (WARN_ON(ret < 0))\n\t\tret = connector_status_unknown;\n\n\tif (ret != connector->status)\n\t\tconnector->epoch_counter += 1;\n\n\tdrm_modeset_drop_locks(&ctx);\n\tdrm_modeset_acquire_fini(&ctx);\n\n\treturn ret;\n}\n\n \nint\ndrm_helper_probe_detect(struct drm_connector *connector,\n\t\t\tstruct drm_modeset_acquire_ctx *ctx,\n\t\t\tbool force)\n{\n\tconst struct drm_connector_helper_funcs *funcs = connector->helper_private;\n\tstruct drm_device *dev = connector->dev;\n\tint ret;\n\n\tif (!ctx)\n\t\treturn drm_helper_probe_detect_ctx(connector, force);\n\n\tret = drm_modeset_lock(&dev->mode_config.connection_mutex, ctx);\n\tif (ret)\n\t\treturn ret;\n\n\tif (funcs->detect_ctx)\n\t\tret = funcs->detect_ctx(connector, ctx, force);\n\telse if (connector->funcs->detect)\n\t\tret = connector->funcs->detect(connector, force);\n\telse\n\t\tret = connector_status_connected;\n\n\tif (ret != connector->status)\n\t\tconnector->epoch_counter += 1;\n\n\treturn ret;\n}\nEXPORT_SYMBOL(drm_helper_probe_detect);\n\nstatic int drm_helper_probe_get_modes(struct drm_connector *connector)\n{\n\tconst struct drm_connector_helper_funcs *connector_funcs =\n\t\tconnector->helper_private;\n\tint count;\n\n\tcount = connector_funcs->get_modes(connector);\n\n\t \n\tif (count == 0 && connector->status == connector_status_connected)\n\t\tcount = drm_edid_override_connector_update(connector);\n\n\treturn count;\n}\n\nstatic int __drm_helper_update_and_validate(struct drm_connector *connector,\n\t\t\t\t\t    uint32_t maxX, uint32_t maxY,\n\t\t\t\t\t    struct drm_modeset_acquire_ctx *ctx)\n{\n\tstruct drm_device *dev = connector->dev;\n\tstruct drm_display_mode *mode;\n\tint mode_flags = 0;\n\tint ret;\n\n\tdrm_connector_list_update(connector);\n\n\tif (connector->interlace_allowed)\n\t\tmode_flags |= DRM_MODE_FLAG_INTERLACE;\n\tif (connector->doublescan_allowed)\n\t\tmode_flags |= DRM_MODE_FLAG_DBLSCAN;\n\tif (connector->stereo_allowed)\n\t\tmode_flags |= DRM_MODE_FLAG_3D_MASK;\n\n\tlist_for_each_entry(mode, &connector->modes, head) {\n\t\tif (mode->status != MODE_OK)\n\t\t\tcontinue;\n\n\t\tmode->status = drm_mode_validate_driver(dev, mode);\n\t\tif (mode->status != MODE_OK)\n\t\t\tcontinue;\n\n\t\tmode->status = drm_mode_validate_size(mode, maxX, maxY);\n\t\tif (mode->status != MODE_OK)\n\t\t\tcontinue;\n\n\t\tmode->status = drm_mode_validate_flag(mode, mode_flags);\n\t\tif (mode->status != MODE_OK)\n\t\t\tcontinue;\n\n\t\tret = drm_mode_validate_pipeline(mode, connector, ctx,\n\t\t\t\t\t\t &mode->status);\n\t\tif (ret) {\n\t\t\tdrm_dbg_kms(dev,\n\t\t\t\t    \"drm_mode_validate_pipeline failed: %d\\n\",\n\t\t\t\t    ret);\n\n\t\t\tif (drm_WARN_ON_ONCE(dev, ret != -EDEADLK))\n\t\t\t\tmode->status = MODE_ERROR;\n\t\t\telse\n\t\t\t\treturn -EDEADLK;\n\t\t}\n\n\t\tif (mode->status != MODE_OK)\n\t\t\tcontinue;\n\t\tmode->status = drm_mode_validate_ycbcr420(mode, connector);\n\t}\n\n\treturn 0;\n}\n\n \nint drm_helper_probe_single_connector_modes(struct drm_connector *connector,\n\t\t\t\t\t    uint32_t maxX, uint32_t maxY)\n{\n\tstruct drm_device *dev = connector->dev;\n\tstruct drm_display_mode *mode;\n\tint count = 0, ret;\n\tenum drm_connector_status old_status;\n\tstruct drm_modeset_acquire_ctx ctx;\n\n\tWARN_ON(!mutex_is_locked(&dev->mode_config.mutex));\n\n\tdrm_modeset_acquire_init(&ctx, 0);\n\n\tDRM_DEBUG_KMS(\"[CONNECTOR:%d:%s]\\n\", connector->base.id,\n\t\t\tconnector->name);\n\nretry:\n\tret = drm_modeset_lock(&dev->mode_config.connection_mutex, &ctx);\n\tif (ret == -EDEADLK) {\n\t\tdrm_modeset_backoff(&ctx);\n\t\tgoto retry;\n\t} else\n\t\tWARN_ON(ret < 0);\n\n\t \n\tlist_for_each_entry(mode, &connector->modes, head)\n\t\tmode->status = MODE_STALE;\n\n\told_status = connector->status;\n\n\tif (connector->force) {\n\t\tif (connector->force == DRM_FORCE_ON ||\n\t\t    connector->force == DRM_FORCE_ON_DIGITAL)\n\t\t\tconnector->status = connector_status_connected;\n\t\telse\n\t\t\tconnector->status = connector_status_disconnected;\n\t\tif (connector->funcs->force)\n\t\t\tconnector->funcs->force(connector);\n\t} else {\n\t\tret = drm_helper_probe_detect(connector, &ctx, true);\n\n\t\tif (ret == -EDEADLK) {\n\t\t\tdrm_modeset_backoff(&ctx);\n\t\t\tgoto retry;\n\t\t} else if (WARN(ret < 0, \"Invalid return value %i for connector detection\\n\", ret))\n\t\t\tret = connector_status_unknown;\n\n\t\tconnector->status = ret;\n\t}\n\n\t \n\tif (old_status != connector->status) {\n\t\tDRM_DEBUG_KMS(\"[CONNECTOR:%d:%s] status updated from %s to %s\\n\",\n\t\t\t      connector->base.id,\n\t\t\t      connector->name,\n\t\t\t      drm_get_connector_status_name(old_status),\n\t\t\t      drm_get_connector_status_name(connector->status));\n\n\t\t \n\t\tdev->mode_config.delayed_event = true;\n\t\tif (dev->mode_config.poll_enabled)\n\t\t\tmod_delayed_work(system_wq,\n\t\t\t\t\t &dev->mode_config.output_poll_work,\n\t\t\t\t\t 0);\n\t}\n\n\t \n\tdrm_kms_helper_poll_enable(dev);\n\n\tif (connector->status == connector_status_disconnected) {\n\t\tDRM_DEBUG_KMS(\"[CONNECTOR:%d:%s] disconnected\\n\",\n\t\t\tconnector->base.id, connector->name);\n\t\tdrm_connector_update_edid_property(connector, NULL);\n\t\tdrm_mode_prune_invalid(dev, &connector->modes, false);\n\t\tgoto exit;\n\t}\n\n\tcount = drm_helper_probe_get_modes(connector);\n\n\tif (count == 0 && (connector->status == connector_status_connected ||\n\t\t\t   connector->status == connector_status_unknown)) {\n\t\tcount = drm_add_modes_noedid(connector, 1024, 768);\n\n\t\t \n\t\tif (connector->connector_type == DRM_MODE_CONNECTOR_DisplayPort)\n\t\t\tdrm_set_preferred_mode(connector, 640, 480);\n\t}\n\tcount += drm_helper_probe_add_cmdline_mode(connector);\n\tif (count != 0) {\n\t\tret = __drm_helper_update_and_validate(connector, maxX, maxY, &ctx);\n\t\tif (ret == -EDEADLK) {\n\t\t\tdrm_modeset_backoff(&ctx);\n\t\t\tgoto retry;\n\t\t}\n\t}\n\n\tdrm_mode_prune_invalid(dev, &connector->modes, true);\n\n\t \n\tif (list_empty(&connector->modes) &&\n\t    connector->connector_type == DRM_MODE_CONNECTOR_DisplayPort) {\n\t\tcount = drm_add_modes_noedid(connector, 640, 480);\n\t\tret = __drm_helper_update_and_validate(connector, maxX, maxY, &ctx);\n\t\tif (ret == -EDEADLK) {\n\t\t\tdrm_modeset_backoff(&ctx);\n\t\t\tgoto retry;\n\t\t}\n\t\tdrm_mode_prune_invalid(dev, &connector->modes, true);\n\t}\n\nexit:\n\tdrm_modeset_drop_locks(&ctx);\n\tdrm_modeset_acquire_fini(&ctx);\n\n\tif (list_empty(&connector->modes))\n\t\treturn 0;\n\n\tdrm_mode_sort(&connector->modes);\n\n\tDRM_DEBUG_KMS(\"[CONNECTOR:%d:%s] probed modes :\\n\", connector->base.id,\n\t\t\tconnector->name);\n\tlist_for_each_entry(mode, &connector->modes, head) {\n\t\tdrm_mode_set_crtcinfo(mode, CRTC_INTERLACE_HALVE_V);\n\t\tdrm_mode_debug_printmodeline(mode);\n\t}\n\n\treturn count;\n}\nEXPORT_SYMBOL(drm_helper_probe_single_connector_modes);\n\n \nvoid drm_kms_helper_hotplug_event(struct drm_device *dev)\n{\n\t \n\tdrm_sysfs_hotplug_event(dev);\n\tif (dev->mode_config.funcs->output_poll_changed)\n\t\tdev->mode_config.funcs->output_poll_changed(dev);\n\n\tdrm_client_dev_hotplug(dev);\n}\nEXPORT_SYMBOL(drm_kms_helper_hotplug_event);\n\n \nvoid drm_kms_helper_connector_hotplug_event(struct drm_connector *connector)\n{\n\tstruct drm_device *dev = connector->dev;\n\n\t \n\tdrm_sysfs_connector_hotplug_event(connector);\n\tif (dev->mode_config.funcs->output_poll_changed)\n\t\tdev->mode_config.funcs->output_poll_changed(dev);\n\n\tdrm_client_dev_hotplug(dev);\n}\nEXPORT_SYMBOL(drm_kms_helper_connector_hotplug_event);\n\nstatic void output_poll_execute(struct work_struct *work)\n{\n\tstruct delayed_work *delayed_work = to_delayed_work(work);\n\tstruct drm_device *dev = container_of(delayed_work, struct drm_device, mode_config.output_poll_work);\n\tstruct drm_connector *connector;\n\tstruct drm_connector_list_iter conn_iter;\n\tenum drm_connector_status old_status;\n\tbool repoll = false, changed;\n\tu64 old_epoch_counter;\n\n\tif (!dev->mode_config.poll_enabled)\n\t\treturn;\n\n\t \n\tchanged = dev->mode_config.delayed_event;\n\tdev->mode_config.delayed_event = false;\n\n\tif (!drm_kms_helper_poll && dev->mode_config.poll_running) {\n\t\tdrm_kms_helper_disable_hpd(dev);\n\t\tdev->mode_config.poll_running = false;\n\t\tgoto out;\n\t}\n\n\tif (!mutex_trylock(&dev->mode_config.mutex)) {\n\t\trepoll = true;\n\t\tgoto out;\n\t}\n\n\tdrm_connector_list_iter_begin(dev, &conn_iter);\n\tdrm_for_each_connector_iter(connector, &conn_iter) {\n\t\t \n\t\tif (connector->force)\n\t\t\tcontinue;\n\n\t\t \n\t\tif (!connector->polled || connector->polled == DRM_CONNECTOR_POLL_HPD)\n\t\t\tcontinue;\n\n\t\told_status = connector->status;\n\t\t \n\t\tif (old_status == connector_status_connected &&\n\t\t    !(connector->polled & DRM_CONNECTOR_POLL_DISCONNECT))\n\t\t\tcontinue;\n\n\t\trepoll = true;\n\n\t\told_epoch_counter = connector->epoch_counter;\n\t\tconnector->status = drm_helper_probe_detect(connector, NULL, false);\n\t\tif (old_epoch_counter != connector->epoch_counter) {\n\t\t\tconst char *old, *new;\n\n\t\t\t \n\t\t\tif (connector->status == connector_status_unknown) {\n\t\t\t\tconnector->status = old_status;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\told = drm_get_connector_status_name(old_status);\n\t\t\tnew = drm_get_connector_status_name(connector->status);\n\n\t\t\tDRM_DEBUG_KMS(\"[CONNECTOR:%d:%s] \"\n\t\t\t\t      \"status updated from %s to %s\\n\",\n\t\t\t\t      connector->base.id,\n\t\t\t\t      connector->name,\n\t\t\t\t      old, new);\n\t\t\tDRM_DEBUG_KMS(\"[CONNECTOR:%d:%s] epoch counter %llu -> %llu\\n\",\n\t\t\t\t      connector->base.id, connector->name,\n\t\t\t\t      old_epoch_counter, connector->epoch_counter);\n\n\t\t\tchanged = true;\n\t\t}\n\t}\n\tdrm_connector_list_iter_end(&conn_iter);\n\n\tmutex_unlock(&dev->mode_config.mutex);\n\nout:\n\tif (changed)\n\t\tdrm_kms_helper_hotplug_event(dev);\n\n\tif (repoll)\n\t\tschedule_delayed_work(delayed_work, DRM_OUTPUT_POLL_PERIOD);\n}\n\n \nbool drm_kms_helper_is_poll_worker(void)\n{\n\tstruct work_struct *work = current_work();\n\n\treturn work && work->func == output_poll_execute;\n}\nEXPORT_SYMBOL(drm_kms_helper_is_poll_worker);\n\n \nvoid drm_kms_helper_poll_disable(struct drm_device *dev)\n{\n\tif (dev->mode_config.poll_running)\n\t\tdrm_kms_helper_disable_hpd(dev);\n\n\tcancel_delayed_work_sync(&dev->mode_config.output_poll_work);\n\n\tdev->mode_config.poll_running = false;\n}\nEXPORT_SYMBOL(drm_kms_helper_poll_disable);\n\n \nvoid drm_kms_helper_poll_init(struct drm_device *dev)\n{\n\tINIT_DELAYED_WORK(&dev->mode_config.output_poll_work, output_poll_execute);\n\tdev->mode_config.poll_enabled = true;\n\n\tdrm_kms_helper_poll_enable(dev);\n}\nEXPORT_SYMBOL(drm_kms_helper_poll_init);\n\n \nvoid drm_kms_helper_poll_fini(struct drm_device *dev)\n{\n\tif (!dev->mode_config.poll_enabled)\n\t\treturn;\n\n\tdrm_kms_helper_poll_disable(dev);\n\n\tdev->mode_config.poll_enabled = false;\n}\nEXPORT_SYMBOL(drm_kms_helper_poll_fini);\n\nstatic bool check_connector_changed(struct drm_connector *connector)\n{\n\tstruct drm_device *dev = connector->dev;\n\tenum drm_connector_status old_status;\n\tu64 old_epoch_counter;\n\n\t \n\tdrm_WARN_ON(dev, !(connector->polled & DRM_CONNECTOR_POLL_HPD));\n\n\tdrm_WARN_ON(dev, !mutex_is_locked(&dev->mode_config.mutex));\n\n\told_status = connector->status;\n\told_epoch_counter = connector->epoch_counter;\n\tconnector->status = drm_helper_probe_detect(connector, NULL, false);\n\n\tif (old_epoch_counter == connector->epoch_counter) {\n\t\tdrm_dbg_kms(dev, \"[CONNECTOR:%d:%s] Same epoch counter %llu\\n\",\n\t\t\t    connector->base.id,\n\t\t\t    connector->name,\n\t\t\t    connector->epoch_counter);\n\n\t\treturn false;\n\t}\n\n\tdrm_dbg_kms(dev, \"[CONNECTOR:%d:%s] status updated from %s to %s\\n\",\n\t\t    connector->base.id,\n\t\t    connector->name,\n\t\t    drm_get_connector_status_name(old_status),\n\t\t    drm_get_connector_status_name(connector->status));\n\n\tdrm_dbg_kms(dev, \"[CONNECTOR:%d:%s] Changed epoch counter %llu => %llu\\n\",\n\t\t    connector->base.id,\n\t\t    connector->name,\n\t\t    old_epoch_counter,\n\t\t    connector->epoch_counter);\n\n\treturn true;\n}\n\n \nbool drm_connector_helper_hpd_irq_event(struct drm_connector *connector)\n{\n\tstruct drm_device *dev = connector->dev;\n\tbool changed;\n\n\tmutex_lock(&dev->mode_config.mutex);\n\tchanged = check_connector_changed(connector);\n\tmutex_unlock(&dev->mode_config.mutex);\n\n\tif (changed) {\n\t\tdrm_kms_helper_connector_hotplug_event(connector);\n\t\tdrm_dbg_kms(dev, \"[CONNECTOR:%d:%s] Sent hotplug event\\n\",\n\t\t\t    connector->base.id,\n\t\t\t    connector->name);\n\t}\n\n\treturn changed;\n}\nEXPORT_SYMBOL(drm_connector_helper_hpd_irq_event);\n\n \nbool drm_helper_hpd_irq_event(struct drm_device *dev)\n{\n\tstruct drm_connector *connector, *first_changed_connector = NULL;\n\tstruct drm_connector_list_iter conn_iter;\n\tint changed = 0;\n\n\tif (!dev->mode_config.poll_enabled)\n\t\treturn false;\n\n\tmutex_lock(&dev->mode_config.mutex);\n\tdrm_connector_list_iter_begin(dev, &conn_iter);\n\tdrm_for_each_connector_iter(connector, &conn_iter) {\n\t\t \n\t\tif (!(connector->polled & DRM_CONNECTOR_POLL_HPD))\n\t\t\tcontinue;\n\n\t\tif (check_connector_changed(connector)) {\n\t\t\tif (!first_changed_connector) {\n\t\t\t\tdrm_connector_get(connector);\n\t\t\t\tfirst_changed_connector = connector;\n\t\t\t}\n\n\t\t\tchanged++;\n\t\t}\n\t}\n\tdrm_connector_list_iter_end(&conn_iter);\n\tmutex_unlock(&dev->mode_config.mutex);\n\n\tif (changed == 1)\n\t\tdrm_kms_helper_connector_hotplug_event(first_changed_connector);\n\telse if (changed > 0)\n\t\tdrm_kms_helper_hotplug_event(dev);\n\n\tif (first_changed_connector)\n\t\tdrm_connector_put(first_changed_connector);\n\n\treturn changed;\n}\nEXPORT_SYMBOL(drm_helper_hpd_irq_event);\n\n \nenum drm_mode_status drm_crtc_helper_mode_valid_fixed(struct drm_crtc *crtc,\n\t\t\t\t\t\t      const struct drm_display_mode *mode,\n\t\t\t\t\t\t      const struct drm_display_mode *fixed_mode)\n{\n\tif (mode->hdisplay != fixed_mode->hdisplay && mode->vdisplay != fixed_mode->vdisplay)\n\t\treturn MODE_ONE_SIZE;\n\telse if (mode->hdisplay != fixed_mode->hdisplay)\n\t\treturn MODE_ONE_WIDTH;\n\telse if (mode->vdisplay != fixed_mode->vdisplay)\n\t\treturn MODE_ONE_HEIGHT;\n\n\treturn MODE_OK;\n}\nEXPORT_SYMBOL(drm_crtc_helper_mode_valid_fixed);\n\n \nint drm_connector_helper_get_modes_from_ddc(struct drm_connector *connector)\n{\n\tstruct edid *edid;\n\tint count = 0;\n\n\tif (!connector->ddc)\n\t\treturn 0;\n\n\tedid = drm_get_edid(connector, connector->ddc);\n\n\t \n\tdrm_connector_update_edid_property(connector, edid);\n\n\tif (edid) {\n\t\tcount = drm_add_edid_modes(connector, edid);\n\t\tkfree(edid);\n\t}\n\n\treturn count;\n}\nEXPORT_SYMBOL(drm_connector_helper_get_modes_from_ddc);\n\n \nint drm_connector_helper_get_modes_fixed(struct drm_connector *connector,\n\t\t\t\t\t const struct drm_display_mode *fixed_mode)\n{\n\tstruct drm_device *dev = connector->dev;\n\tstruct drm_display_mode *mode;\n\n\tmode = drm_mode_duplicate(dev, fixed_mode);\n\tif (!mode) {\n\t\tdrm_err(dev, \"Failed to duplicate mode \" DRM_MODE_FMT \"\\n\",\n\t\t\tDRM_MODE_ARG(fixed_mode));\n\t\treturn 0;\n\t}\n\n\tif (mode->name[0] == '\\0')\n\t\tdrm_mode_set_name(mode);\n\n\tmode->type |= DRM_MODE_TYPE_PREFERRED;\n\tdrm_mode_probed_add(connector, mode);\n\n\tif (mode->width_mm)\n\t\tconnector->display_info.width_mm = mode->width_mm;\n\tif (mode->height_mm)\n\t\tconnector->display_info.height_mm = mode->height_mm;\n\n\treturn 1;\n}\nEXPORT_SYMBOL(drm_connector_helper_get_modes_fixed);\n\n \nint drm_connector_helper_get_modes(struct drm_connector *connector)\n{\n\tconst struct drm_edid *drm_edid;\n\tint count;\n\n\tdrm_edid = drm_edid_read(connector);\n\n\t \n\tdrm_edid_connector_update(connector, drm_edid);\n\n\tcount = drm_edid_connector_add_modes(connector);\n\n\tdrm_edid_free(drm_edid);\n\n\treturn count;\n}\nEXPORT_SYMBOL(drm_connector_helper_get_modes);\n\n \nint drm_connector_helper_tv_get_modes(struct drm_connector *connector)\n{\n\tstruct drm_device *dev = connector->dev;\n\tstruct drm_property *tv_mode_property =\n\t\tdev->mode_config.tv_mode_property;\n\tstruct drm_cmdline_mode *cmdline = &connector->cmdline_mode;\n\tunsigned int ntsc_modes = BIT(DRM_MODE_TV_MODE_NTSC) |\n\t\tBIT(DRM_MODE_TV_MODE_NTSC_443) |\n\t\tBIT(DRM_MODE_TV_MODE_NTSC_J) |\n\t\tBIT(DRM_MODE_TV_MODE_PAL_M);\n\tunsigned int pal_modes = BIT(DRM_MODE_TV_MODE_PAL) |\n\t\tBIT(DRM_MODE_TV_MODE_PAL_N) |\n\t\tBIT(DRM_MODE_TV_MODE_SECAM);\n\tunsigned int tv_modes[2] = { UINT_MAX, UINT_MAX };\n\tunsigned int i, supported_tv_modes = 0;\n\n\tif (!tv_mode_property)\n\t\treturn 0;\n\n\tfor (i = 0; i < tv_mode_property->num_values; i++)\n\t\tsupported_tv_modes |= BIT(tv_mode_property->values[i]);\n\n\tif ((supported_tv_modes & ntsc_modes) &&\n\t    (supported_tv_modes & pal_modes)) {\n\t\tuint64_t default_mode;\n\n\t\tif (drm_object_property_get_default_value(&connector->base,\n\t\t\t\t\t\t\t  tv_mode_property,\n\t\t\t\t\t\t\t  &default_mode))\n\t\t\treturn 0;\n\n\t\tif (cmdline->tv_mode_specified)\n\t\t\tdefault_mode = cmdline->tv_mode;\n\n\t\tif (BIT(default_mode) & ntsc_modes) {\n\t\t\ttv_modes[0] = DRM_MODE_TV_MODE_NTSC;\n\t\t\ttv_modes[1] = DRM_MODE_TV_MODE_PAL;\n\t\t} else {\n\t\t\ttv_modes[0] = DRM_MODE_TV_MODE_PAL;\n\t\t\ttv_modes[1] = DRM_MODE_TV_MODE_NTSC;\n\t\t}\n\t} else if (supported_tv_modes & ntsc_modes) {\n\t\ttv_modes[0] = DRM_MODE_TV_MODE_NTSC;\n\t} else if (supported_tv_modes & pal_modes) {\n\t\ttv_modes[0] = DRM_MODE_TV_MODE_PAL;\n\t} else {\n\t\treturn 0;\n\t}\n\n\tfor (i = 0; i < ARRAY_SIZE(tv_modes); i++) {\n\t\tstruct drm_display_mode *mode;\n\n\t\tif (tv_modes[i] == DRM_MODE_TV_MODE_NTSC)\n\t\t\tmode = drm_mode_analog_ntsc_480i(dev);\n\t\telse if (tv_modes[i] == DRM_MODE_TV_MODE_PAL)\n\t\t\tmode = drm_mode_analog_pal_576i(dev);\n\t\telse\n\t\t\tbreak;\n\t\tif (!mode)\n\t\t\treturn i;\n\t\tif (!i)\n\t\t\tmode->type |= DRM_MODE_TYPE_PREFERRED;\n\t\tdrm_mode_probed_add(connector, mode);\n\t}\n\n\treturn i;\n}\nEXPORT_SYMBOL(drm_connector_helper_tv_get_modes);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}