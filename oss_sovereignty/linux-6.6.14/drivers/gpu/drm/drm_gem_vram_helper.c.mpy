{
  "module_name": "drm_gem_vram_helper.c",
  "hash_id": "f25e8b2cd206626d9131b4fbf18786b87b8791b11406c04bad54e4aac3310ffd",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/drm_gem_vram_helper.c",
  "human_readable_source": "\n\n#include <linux/iosys-map.h>\n#include <linux/module.h>\n\n#include <drm/drm_debugfs.h>\n#include <drm/drm_device.h>\n#include <drm/drm_drv.h>\n#include <drm/drm_file.h>\n#include <drm/drm_framebuffer.h>\n#include <drm/drm_gem_atomic_helper.h>\n#include <drm/drm_gem_framebuffer_helper.h>\n#include <drm/drm_gem_ttm_helper.h>\n#include <drm/drm_gem_vram_helper.h>\n#include <drm/drm_managed.h>\n#include <drm/drm_mode.h>\n#include <drm/drm_plane.h>\n#include <drm/drm_prime.h>\n#include <drm/drm_simple_kms_helper.h>\n\n#include <drm/ttm/ttm_range_manager.h>\n#include <drm/ttm/ttm_tt.h>\n\nstatic const struct drm_gem_object_funcs drm_gem_vram_object_funcs;\n\n \n\n \n\nstatic void drm_gem_vram_cleanup(struct drm_gem_vram_object *gbo)\n{\n\t \n\n\tWARN_ON(gbo->vmap_use_count);\n\tWARN_ON(iosys_map_is_set(&gbo->map));\n\n\tdrm_gem_object_release(&gbo->bo.base);\n}\n\nstatic void drm_gem_vram_destroy(struct drm_gem_vram_object *gbo)\n{\n\tdrm_gem_vram_cleanup(gbo);\n\tkfree(gbo);\n}\n\nstatic void ttm_buffer_object_destroy(struct ttm_buffer_object *bo)\n{\n\tstruct drm_gem_vram_object *gbo = drm_gem_vram_of_bo(bo);\n\n\tdrm_gem_vram_destroy(gbo);\n}\n\nstatic void drm_gem_vram_placement(struct drm_gem_vram_object *gbo,\n\t\t\t\t   unsigned long pl_flag)\n{\n\tu32 invariant_flags = 0;\n\tunsigned int i;\n\tunsigned int c = 0;\n\n\tif (pl_flag & DRM_GEM_VRAM_PL_FLAG_TOPDOWN)\n\t\tinvariant_flags = TTM_PL_FLAG_TOPDOWN;\n\n\tgbo->placement.placement = gbo->placements;\n\tgbo->placement.busy_placement = gbo->placements;\n\n\tif (pl_flag & DRM_GEM_VRAM_PL_FLAG_VRAM) {\n\t\tgbo->placements[c].mem_type = TTM_PL_VRAM;\n\t\tgbo->placements[c++].flags = invariant_flags;\n\t}\n\n\tif (pl_flag & DRM_GEM_VRAM_PL_FLAG_SYSTEM || !c) {\n\t\tgbo->placements[c].mem_type = TTM_PL_SYSTEM;\n\t\tgbo->placements[c++].flags = invariant_flags;\n\t}\n\n\tgbo->placement.num_placement = c;\n\tgbo->placement.num_busy_placement = c;\n\n\tfor (i = 0; i < c; ++i) {\n\t\tgbo->placements[i].fpfn = 0;\n\t\tgbo->placements[i].lpfn = 0;\n\t}\n}\n\n \nstruct drm_gem_vram_object *drm_gem_vram_create(struct drm_device *dev,\n\t\t\t\t\t\tsize_t size,\n\t\t\t\t\t\tunsigned long pg_align)\n{\n\tstruct drm_gem_vram_object *gbo;\n\tstruct drm_gem_object *gem;\n\tstruct drm_vram_mm *vmm = dev->vram_mm;\n\tstruct ttm_device *bdev;\n\tint ret;\n\n\tif (WARN_ONCE(!vmm, \"VRAM MM not initialized\"))\n\t\treturn ERR_PTR(-EINVAL);\n\n\tif (dev->driver->gem_create_object) {\n\t\tgem = dev->driver->gem_create_object(dev, size);\n\t\tif (IS_ERR(gem))\n\t\t\treturn ERR_CAST(gem);\n\t\tgbo = drm_gem_vram_of_gem(gem);\n\t} else {\n\t\tgbo = kzalloc(sizeof(*gbo), GFP_KERNEL);\n\t\tif (!gbo)\n\t\t\treturn ERR_PTR(-ENOMEM);\n\t\tgem = &gbo->bo.base;\n\t}\n\n\tif (!gem->funcs)\n\t\tgem->funcs = &drm_gem_vram_object_funcs;\n\n\tret = drm_gem_object_init(dev, gem, size);\n\tif (ret) {\n\t\tkfree(gbo);\n\t\treturn ERR_PTR(ret);\n\t}\n\n\tbdev = &vmm->bdev;\n\n\tgbo->bo.bdev = bdev;\n\tdrm_gem_vram_placement(gbo, DRM_GEM_VRAM_PL_FLAG_SYSTEM);\n\n\t \n\tret = ttm_bo_init_validate(bdev, &gbo->bo, ttm_bo_type_device,\n\t\t\t\t   &gbo->placement, pg_align, false, NULL, NULL,\n\t\t\t\t   ttm_buffer_object_destroy);\n\tif (ret)\n\t\treturn ERR_PTR(ret);\n\n\treturn gbo;\n}\nEXPORT_SYMBOL(drm_gem_vram_create);\n\n \nvoid drm_gem_vram_put(struct drm_gem_vram_object *gbo)\n{\n\tttm_bo_put(&gbo->bo);\n}\nEXPORT_SYMBOL(drm_gem_vram_put);\n\nstatic u64 drm_gem_vram_pg_offset(struct drm_gem_vram_object *gbo)\n{\n\t \n\tif (WARN_ON_ONCE(!gbo->bo.resource ||\n\t\t\t gbo->bo.resource->mem_type == TTM_PL_SYSTEM))\n\t\treturn 0;\n\n\treturn gbo->bo.resource->start;\n}\n\n \ns64 drm_gem_vram_offset(struct drm_gem_vram_object *gbo)\n{\n\tif (WARN_ON_ONCE(!gbo->bo.pin_count))\n\t\treturn (s64)-ENODEV;\n\treturn drm_gem_vram_pg_offset(gbo) << PAGE_SHIFT;\n}\nEXPORT_SYMBOL(drm_gem_vram_offset);\n\nstatic int drm_gem_vram_pin_locked(struct drm_gem_vram_object *gbo,\n\t\t\t\t   unsigned long pl_flag)\n{\n\tstruct ttm_operation_ctx ctx = { false, false };\n\tint ret;\n\n\tif (gbo->bo.pin_count)\n\t\tgoto out;\n\n\tif (pl_flag)\n\t\tdrm_gem_vram_placement(gbo, pl_flag);\n\n\tret = ttm_bo_validate(&gbo->bo, &gbo->placement, &ctx);\n\tif (ret < 0)\n\t\treturn ret;\n\nout:\n\tttm_bo_pin(&gbo->bo);\n\n\treturn 0;\n}\n\n \nint drm_gem_vram_pin(struct drm_gem_vram_object *gbo, unsigned long pl_flag)\n{\n\tint ret;\n\n\tret = ttm_bo_reserve(&gbo->bo, true, false, NULL);\n\tif (ret)\n\t\treturn ret;\n\tret = drm_gem_vram_pin_locked(gbo, pl_flag);\n\tttm_bo_unreserve(&gbo->bo);\n\n\treturn ret;\n}\nEXPORT_SYMBOL(drm_gem_vram_pin);\n\nstatic void drm_gem_vram_unpin_locked(struct drm_gem_vram_object *gbo)\n{\n\tttm_bo_unpin(&gbo->bo);\n}\n\n \nint drm_gem_vram_unpin(struct drm_gem_vram_object *gbo)\n{\n\tint ret;\n\n\tret = ttm_bo_reserve(&gbo->bo, true, false, NULL);\n\tif (ret)\n\t\treturn ret;\n\n\tdrm_gem_vram_unpin_locked(gbo);\n\tttm_bo_unreserve(&gbo->bo);\n\n\treturn 0;\n}\nEXPORT_SYMBOL(drm_gem_vram_unpin);\n\nstatic int drm_gem_vram_kmap_locked(struct drm_gem_vram_object *gbo,\n\t\t\t\t    struct iosys_map *map)\n{\n\tint ret;\n\n\tif (gbo->vmap_use_count > 0)\n\t\tgoto out;\n\n\t \n\tif (iosys_map_is_null(&gbo->map)) {\n\t\tret = ttm_bo_vmap(&gbo->bo, &gbo->map);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\nout:\n\t++gbo->vmap_use_count;\n\t*map = gbo->map;\n\n\treturn 0;\n}\n\nstatic void drm_gem_vram_kunmap_locked(struct drm_gem_vram_object *gbo,\n\t\t\t\t       struct iosys_map *map)\n{\n\tstruct drm_device *dev = gbo->bo.base.dev;\n\n\tif (drm_WARN_ON_ONCE(dev, !gbo->vmap_use_count))\n\t\treturn;\n\n\tif (drm_WARN_ON_ONCE(dev, !iosys_map_is_equal(&gbo->map, map)))\n\t\treturn;  \n\n\tif (--gbo->vmap_use_count > 0)\n\t\treturn;\n\n\t \n}\n\n \nint drm_gem_vram_vmap(struct drm_gem_vram_object *gbo, struct iosys_map *map)\n{\n\tint ret;\n\n\tdma_resv_assert_held(gbo->bo.base.resv);\n\n\tret = drm_gem_vram_pin_locked(gbo, 0);\n\tif (ret)\n\t\treturn ret;\n\tret = drm_gem_vram_kmap_locked(gbo, map);\n\tif (ret)\n\t\tgoto err_drm_gem_vram_unpin_locked;\n\n\treturn 0;\n\nerr_drm_gem_vram_unpin_locked:\n\tdrm_gem_vram_unpin_locked(gbo);\n\treturn ret;\n}\nEXPORT_SYMBOL(drm_gem_vram_vmap);\n\n \nvoid drm_gem_vram_vunmap(struct drm_gem_vram_object *gbo,\n\t\t\t struct iosys_map *map)\n{\n\tdma_resv_assert_held(gbo->bo.base.resv);\n\n\tdrm_gem_vram_kunmap_locked(gbo, map);\n\tdrm_gem_vram_unpin_locked(gbo);\n}\nEXPORT_SYMBOL(drm_gem_vram_vunmap);\n\n \nint drm_gem_vram_fill_create_dumb(struct drm_file *file,\n\t\t\t\t  struct drm_device *dev,\n\t\t\t\t  unsigned long pg_align,\n\t\t\t\t  unsigned long pitch_align,\n\t\t\t\t  struct drm_mode_create_dumb *args)\n{\n\tsize_t pitch, size;\n\tstruct drm_gem_vram_object *gbo;\n\tint ret;\n\tu32 handle;\n\n\tpitch = args->width * DIV_ROUND_UP(args->bpp, 8);\n\tif (pitch_align) {\n\t\tif (WARN_ON_ONCE(!is_power_of_2(pitch_align)))\n\t\t\treturn -EINVAL;\n\t\tpitch = ALIGN(pitch, pitch_align);\n\t}\n\tsize = pitch * args->height;\n\n\tsize = roundup(size, PAGE_SIZE);\n\tif (!size)\n\t\treturn -EINVAL;\n\n\tgbo = drm_gem_vram_create(dev, size, pg_align);\n\tif (IS_ERR(gbo))\n\t\treturn PTR_ERR(gbo);\n\n\tret = drm_gem_handle_create(file, &gbo->bo.base, &handle);\n\tif (ret)\n\t\tgoto err_drm_gem_object_put;\n\n\tdrm_gem_object_put(&gbo->bo.base);\n\n\targs->pitch = pitch;\n\targs->size = size;\n\targs->handle = handle;\n\n\treturn 0;\n\nerr_drm_gem_object_put:\n\tdrm_gem_object_put(&gbo->bo.base);\n\treturn ret;\n}\nEXPORT_SYMBOL(drm_gem_vram_fill_create_dumb);\n\n \n\nstatic bool drm_is_gem_vram(struct ttm_buffer_object *bo)\n{\n\treturn (bo->destroy == ttm_buffer_object_destroy);\n}\n\nstatic void drm_gem_vram_bo_driver_evict_flags(struct drm_gem_vram_object *gbo,\n\t\t\t\t\t       struct ttm_placement *pl)\n{\n\tdrm_gem_vram_placement(gbo, DRM_GEM_VRAM_PL_FLAG_SYSTEM);\n\t*pl = gbo->placement;\n}\n\nstatic void drm_gem_vram_bo_driver_move_notify(struct drm_gem_vram_object *gbo)\n{\n\tstruct ttm_buffer_object *bo = &gbo->bo;\n\tstruct drm_device *dev = bo->base.dev;\n\n\tif (drm_WARN_ON_ONCE(dev, gbo->vmap_use_count))\n\t\treturn;\n\n\tttm_bo_vunmap(bo, &gbo->map);\n\tiosys_map_clear(&gbo->map);  \n}\n\nstatic int drm_gem_vram_bo_driver_move(struct drm_gem_vram_object *gbo,\n\t\t\t\t       bool evict,\n\t\t\t\t       struct ttm_operation_ctx *ctx,\n\t\t\t\t       struct ttm_resource *new_mem)\n{\n\tdrm_gem_vram_bo_driver_move_notify(gbo);\n\treturn ttm_bo_move_memcpy(&gbo->bo, ctx, new_mem);\n}\n\n \n\n \nstatic void drm_gem_vram_object_free(struct drm_gem_object *gem)\n{\n\tstruct drm_gem_vram_object *gbo = drm_gem_vram_of_gem(gem);\n\n\tdrm_gem_vram_put(gbo);\n}\n\n \n\n \nint drm_gem_vram_driver_dumb_create(struct drm_file *file,\n\t\t\t\t    struct drm_device *dev,\n\t\t\t\t    struct drm_mode_create_dumb *args)\n{\n\tif (WARN_ONCE(!dev->vram_mm, \"VRAM MM not initialized\"))\n\t\treturn -EINVAL;\n\n\treturn drm_gem_vram_fill_create_dumb(file, dev, 0, 0, args);\n}\nEXPORT_SYMBOL(drm_gem_vram_driver_dumb_create);\n\n \n\nstatic void __drm_gem_vram_plane_helper_cleanup_fb(struct drm_plane *plane,\n\t\t\t\t\t\t   struct drm_plane_state *state,\n\t\t\t\t\t\t   unsigned int num_planes)\n{\n\tstruct drm_gem_object *obj;\n\tstruct drm_gem_vram_object *gbo;\n\tstruct drm_framebuffer *fb = state->fb;\n\n\twhile (num_planes) {\n\t\t--num_planes;\n\t\tobj = drm_gem_fb_get_obj(fb, num_planes);\n\t\tif (!obj)\n\t\t\tcontinue;\n\t\tgbo = drm_gem_vram_of_gem(obj);\n\t\tdrm_gem_vram_unpin(gbo);\n\t}\n}\n\n \nint\ndrm_gem_vram_plane_helper_prepare_fb(struct drm_plane *plane,\n\t\t\t\t     struct drm_plane_state *new_state)\n{\n\tstruct drm_framebuffer *fb = new_state->fb;\n\tstruct drm_gem_vram_object *gbo;\n\tstruct drm_gem_object *obj;\n\tunsigned int i;\n\tint ret;\n\n\tif (!fb)\n\t\treturn 0;\n\n\tfor (i = 0; i < fb->format->num_planes; ++i) {\n\t\tobj = drm_gem_fb_get_obj(fb, i);\n\t\tif (!obj) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto err_drm_gem_vram_unpin;\n\t\t}\n\t\tgbo = drm_gem_vram_of_gem(obj);\n\t\tret = drm_gem_vram_pin(gbo, DRM_GEM_VRAM_PL_FLAG_VRAM);\n\t\tif (ret)\n\t\t\tgoto err_drm_gem_vram_unpin;\n\t}\n\n\tret = drm_gem_plane_helper_prepare_fb(plane, new_state);\n\tif (ret)\n\t\tgoto err_drm_gem_vram_unpin;\n\n\treturn 0;\n\nerr_drm_gem_vram_unpin:\n\t__drm_gem_vram_plane_helper_cleanup_fb(plane, new_state, i);\n\treturn ret;\n}\nEXPORT_SYMBOL(drm_gem_vram_plane_helper_prepare_fb);\n\n \nvoid\ndrm_gem_vram_plane_helper_cleanup_fb(struct drm_plane *plane,\n\t\t\t\t     struct drm_plane_state *old_state)\n{\n\tstruct drm_framebuffer *fb = old_state->fb;\n\n\tif (!fb)\n\t\treturn;\n\n\t__drm_gem_vram_plane_helper_cleanup_fb(plane, old_state, fb->format->num_planes);\n}\nEXPORT_SYMBOL(drm_gem_vram_plane_helper_cleanup_fb);\n\n \n\n \nint drm_gem_vram_simple_display_pipe_prepare_fb(\n\tstruct drm_simple_display_pipe *pipe,\n\tstruct drm_plane_state *new_state)\n{\n\treturn drm_gem_vram_plane_helper_prepare_fb(&pipe->plane, new_state);\n}\nEXPORT_SYMBOL(drm_gem_vram_simple_display_pipe_prepare_fb);\n\n \nvoid drm_gem_vram_simple_display_pipe_cleanup_fb(\n\tstruct drm_simple_display_pipe *pipe,\n\tstruct drm_plane_state *old_state)\n{\n\tdrm_gem_vram_plane_helper_cleanup_fb(&pipe->plane, old_state);\n}\nEXPORT_SYMBOL(drm_gem_vram_simple_display_pipe_cleanup_fb);\n\n \n\n \nstatic int drm_gem_vram_object_pin(struct drm_gem_object *gem)\n{\n\tstruct drm_gem_vram_object *gbo = drm_gem_vram_of_gem(gem);\n\n\t \n\treturn drm_gem_vram_pin(gbo, 0);\n}\n\n \nstatic void drm_gem_vram_object_unpin(struct drm_gem_object *gem)\n{\n\tstruct drm_gem_vram_object *gbo = drm_gem_vram_of_gem(gem);\n\n\tdrm_gem_vram_unpin(gbo);\n}\n\n \nstatic int drm_gem_vram_object_vmap(struct drm_gem_object *gem,\n\t\t\t\t    struct iosys_map *map)\n{\n\tstruct drm_gem_vram_object *gbo = drm_gem_vram_of_gem(gem);\n\n\treturn drm_gem_vram_vmap(gbo, map);\n}\n\n \nstatic void drm_gem_vram_object_vunmap(struct drm_gem_object *gem,\n\t\t\t\t       struct iosys_map *map)\n{\n\tstruct drm_gem_vram_object *gbo = drm_gem_vram_of_gem(gem);\n\n\tdrm_gem_vram_vunmap(gbo, map);\n}\n\n \n\nstatic const struct drm_gem_object_funcs drm_gem_vram_object_funcs = {\n\t.free\t= drm_gem_vram_object_free,\n\t.pin\t= drm_gem_vram_object_pin,\n\t.unpin\t= drm_gem_vram_object_unpin,\n\t.vmap\t= drm_gem_vram_object_vmap,\n\t.vunmap\t= drm_gem_vram_object_vunmap,\n\t.mmap   = drm_gem_ttm_mmap,\n\t.print_info = drm_gem_ttm_print_info,\n};\n\n \n\n \n\nstatic void bo_driver_ttm_tt_destroy(struct ttm_device *bdev, struct ttm_tt *tt)\n{\n\tttm_tt_fini(tt);\n\tkfree(tt);\n}\n\n \n\nstatic struct ttm_tt *bo_driver_ttm_tt_create(struct ttm_buffer_object *bo,\n\t\t\t\t\t      uint32_t page_flags)\n{\n\tstruct ttm_tt *tt;\n\tint ret;\n\n\ttt = kzalloc(sizeof(*tt), GFP_KERNEL);\n\tif (!tt)\n\t\treturn NULL;\n\n\tret = ttm_tt_init(tt, bo, page_flags, ttm_cached, 0);\n\tif (ret < 0)\n\t\tgoto err_ttm_tt_init;\n\n\treturn tt;\n\nerr_ttm_tt_init:\n\tkfree(tt);\n\treturn NULL;\n}\n\nstatic void bo_driver_evict_flags(struct ttm_buffer_object *bo,\n\t\t\t\t  struct ttm_placement *placement)\n{\n\tstruct drm_gem_vram_object *gbo;\n\n\t \n\tif (!drm_is_gem_vram(bo))\n\t\treturn;\n\n\tgbo = drm_gem_vram_of_bo(bo);\n\n\tdrm_gem_vram_bo_driver_evict_flags(gbo, placement);\n}\n\nstatic void bo_driver_delete_mem_notify(struct ttm_buffer_object *bo)\n{\n\tstruct drm_gem_vram_object *gbo;\n\n\t \n\tif (!drm_is_gem_vram(bo))\n\t\treturn;\n\n\tgbo = drm_gem_vram_of_bo(bo);\n\n\tdrm_gem_vram_bo_driver_move_notify(gbo);\n}\n\nstatic int bo_driver_move(struct ttm_buffer_object *bo,\n\t\t\t  bool evict,\n\t\t\t  struct ttm_operation_ctx *ctx,\n\t\t\t  struct ttm_resource *new_mem,\n\t\t\t  struct ttm_place *hop)\n{\n\tstruct drm_gem_vram_object *gbo;\n\n\tif (!bo->resource) {\n\t\tif (new_mem->mem_type != TTM_PL_SYSTEM) {\n\t\t\thop->mem_type = TTM_PL_SYSTEM;\n\t\t\thop->flags = TTM_PL_FLAG_TEMPORARY;\n\t\t\treturn -EMULTIHOP;\n\t\t}\n\n\t\tttm_bo_move_null(bo, new_mem);\n\t\treturn 0;\n\t}\n\n\tgbo = drm_gem_vram_of_bo(bo);\n\n\treturn drm_gem_vram_bo_driver_move(gbo, evict, ctx, new_mem);\n}\n\nstatic int bo_driver_io_mem_reserve(struct ttm_device *bdev,\n\t\t\t\t    struct ttm_resource *mem)\n{\n\tstruct drm_vram_mm *vmm = drm_vram_mm_of_bdev(bdev);\n\n\tswitch (mem->mem_type) {\n\tcase TTM_PL_SYSTEM:\t \n\t\tbreak;\n\tcase TTM_PL_VRAM:\n\t\tmem->bus.offset = (mem->start << PAGE_SHIFT) + vmm->vram_base;\n\t\tmem->bus.is_iomem = true;\n\t\tmem->bus.caching = ttm_write_combined;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic struct ttm_device_funcs bo_driver = {\n\t.ttm_tt_create = bo_driver_ttm_tt_create,\n\t.ttm_tt_destroy = bo_driver_ttm_tt_destroy,\n\t.eviction_valuable = ttm_bo_eviction_valuable,\n\t.evict_flags = bo_driver_evict_flags,\n\t.move = bo_driver_move,\n\t.delete_mem_notify = bo_driver_delete_mem_notify,\n\t.io_mem_reserve = bo_driver_io_mem_reserve,\n};\n\n \n\nstatic int drm_vram_mm_debugfs(struct seq_file *m, void *data)\n{\n\tstruct drm_debugfs_entry *entry = m->private;\n\tstruct drm_vram_mm *vmm = entry->dev->vram_mm;\n\tstruct ttm_resource_manager *man = ttm_manager_type(&vmm->bdev, TTM_PL_VRAM);\n\tstruct drm_printer p = drm_seq_file_printer(m);\n\n\tttm_resource_manager_debug(man, &p);\n\treturn 0;\n}\n\nstatic const struct drm_debugfs_info drm_vram_mm_debugfs_list[] = {\n\t{ \"vram-mm\", drm_vram_mm_debugfs, 0, NULL },\n};\n\n \nvoid drm_vram_mm_debugfs_init(struct drm_minor *minor)\n{\n\tdrm_debugfs_add_files(minor->dev, drm_vram_mm_debugfs_list,\n\t\t\t      ARRAY_SIZE(drm_vram_mm_debugfs_list));\n}\nEXPORT_SYMBOL(drm_vram_mm_debugfs_init);\n\nstatic int drm_vram_mm_init(struct drm_vram_mm *vmm, struct drm_device *dev,\n\t\t\t    uint64_t vram_base, size_t vram_size)\n{\n\tint ret;\n\n\tvmm->vram_base = vram_base;\n\tvmm->vram_size = vram_size;\n\n\tret = ttm_device_init(&vmm->bdev, &bo_driver, dev->dev,\n\t\t\t\t dev->anon_inode->i_mapping,\n\t\t\t\t dev->vma_offset_manager,\n\t\t\t\t false, true);\n\tif (ret)\n\t\treturn ret;\n\n\tret = ttm_range_man_init(&vmm->bdev, TTM_PL_VRAM,\n\t\t\t\t false, vram_size >> PAGE_SHIFT);\n\tif (ret)\n\t\treturn ret;\n\n\treturn 0;\n}\n\nstatic void drm_vram_mm_cleanup(struct drm_vram_mm *vmm)\n{\n\tttm_range_man_fini(&vmm->bdev, TTM_PL_VRAM);\n\tttm_device_fini(&vmm->bdev);\n}\n\n \n\nstatic struct drm_vram_mm *drm_vram_helper_alloc_mm(struct drm_device *dev, uint64_t vram_base,\n\t\t\t\t\t\t    size_t vram_size)\n{\n\tint ret;\n\n\tif (WARN_ON(dev->vram_mm))\n\t\treturn dev->vram_mm;\n\n\tdev->vram_mm = kzalloc(sizeof(*dev->vram_mm), GFP_KERNEL);\n\tif (!dev->vram_mm)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tret = drm_vram_mm_init(dev->vram_mm, dev, vram_base, vram_size);\n\tif (ret)\n\t\tgoto err_kfree;\n\n\treturn dev->vram_mm;\n\nerr_kfree:\n\tkfree(dev->vram_mm);\n\tdev->vram_mm = NULL;\n\treturn ERR_PTR(ret);\n}\n\nstatic void drm_vram_helper_release_mm(struct drm_device *dev)\n{\n\tif (!dev->vram_mm)\n\t\treturn;\n\n\tdrm_vram_mm_cleanup(dev->vram_mm);\n\tkfree(dev->vram_mm);\n\tdev->vram_mm = NULL;\n}\n\nstatic void drm_vram_mm_release(struct drm_device *dev, void *ptr)\n{\n\tdrm_vram_helper_release_mm(dev);\n}\n\n \nint drmm_vram_helper_init(struct drm_device *dev, uint64_t vram_base,\n\t\t\t  size_t vram_size)\n{\n\tstruct drm_vram_mm *vram_mm;\n\n\tif (drm_WARN_ON_ONCE(dev, dev->vram_mm))\n\t\treturn 0;\n\n\tvram_mm = drm_vram_helper_alloc_mm(dev, vram_base, vram_size);\n\tif (IS_ERR(vram_mm))\n\t\treturn PTR_ERR(vram_mm);\n\treturn drmm_add_action_or_reset(dev, drm_vram_mm_release, NULL);\n}\nEXPORT_SYMBOL(drmm_vram_helper_init);\n\n \n\nstatic enum drm_mode_status\ndrm_vram_helper_mode_valid_internal(struct drm_device *dev,\n\t\t\t\t    const struct drm_display_mode *mode,\n\t\t\t\t    unsigned long max_bpp)\n{\n\tstruct drm_vram_mm *vmm = dev->vram_mm;\n\tunsigned long fbsize, fbpages, max_fbpages;\n\n\tif (WARN_ON(!dev->vram_mm))\n\t\treturn MODE_BAD;\n\n\tmax_fbpages = (vmm->vram_size / 2) >> PAGE_SHIFT;\n\n\tfbsize = mode->hdisplay * mode->vdisplay * max_bpp;\n\tfbpages = DIV_ROUND_UP(fbsize, PAGE_SIZE);\n\n\tif (fbpages > max_fbpages)\n\t\treturn MODE_MEM;\n\n\treturn MODE_OK;\n}\n\n \nenum drm_mode_status\ndrm_vram_helper_mode_valid(struct drm_device *dev,\n\t\t\t   const struct drm_display_mode *mode)\n{\n\tstatic const unsigned long max_bpp = 4;  \n\n\treturn drm_vram_helper_mode_valid_internal(dev, mode, max_bpp);\n}\nEXPORT_SYMBOL(drm_vram_helper_mode_valid);\n\nMODULE_DESCRIPTION(\"DRM VRAM memory-management helpers\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}