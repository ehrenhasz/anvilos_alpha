{
  "module_name": "drm_privacy_screen.c",
  "hash_id": "686c3c7929459761d808d48230f1d1499c411a4789bd7c3a478c14a9c0439d54",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/drm_privacy_screen.c",
  "human_readable_source": "\n \n\n#include <linux/device.h>\n#include <linux/kernel.h>\n#include <linux/list.h>\n#include <linux/module.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <drm/drm_privacy_screen_machine.h>\n#include <drm/drm_privacy_screen_consumer.h>\n#include <drm/drm_privacy_screen_driver.h>\n#include \"drm_internal.h\"\n\n \n\n#define to_drm_privacy_screen(dev) \\\n\tcontainer_of(dev, struct drm_privacy_screen, dev)\n\nstatic DEFINE_MUTEX(drm_privacy_screen_lookup_lock);\nstatic LIST_HEAD(drm_privacy_screen_lookup_list);\n\nstatic DEFINE_MUTEX(drm_privacy_screen_devs_lock);\nstatic LIST_HEAD(drm_privacy_screen_devs);\n\n \n\n \nvoid drm_privacy_screen_lookup_add(struct drm_privacy_screen_lookup *lookup)\n{\n\tmutex_lock(&drm_privacy_screen_lookup_lock);\n\tlist_add(&lookup->list, &drm_privacy_screen_lookup_list);\n\tmutex_unlock(&drm_privacy_screen_lookup_lock);\n}\nEXPORT_SYMBOL(drm_privacy_screen_lookup_add);\n\n \nvoid drm_privacy_screen_lookup_remove(struct drm_privacy_screen_lookup *lookup)\n{\n\tmutex_lock(&drm_privacy_screen_lookup_lock);\n\tlist_del(&lookup->list);\n\tmutex_unlock(&drm_privacy_screen_lookup_lock);\n}\nEXPORT_SYMBOL(drm_privacy_screen_lookup_remove);\n\n \n\nstatic struct drm_privacy_screen *drm_privacy_screen_get_by_name(\n\tconst char *name)\n{\n\tstruct drm_privacy_screen *priv;\n\tstruct device *dev = NULL;\n\n\tmutex_lock(&drm_privacy_screen_devs_lock);\n\n\tlist_for_each_entry(priv, &drm_privacy_screen_devs, list) {\n\t\tif (strcmp(dev_name(&priv->dev), name) == 0) {\n\t\t\tdev = get_device(&priv->dev);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tmutex_unlock(&drm_privacy_screen_devs_lock);\n\n\treturn dev ? to_drm_privacy_screen(dev) : NULL;\n}\n\n \nstruct drm_privacy_screen *drm_privacy_screen_get(struct device *dev,\n\t\t\t\t\t\t  const char *con_id)\n{\n\tconst char *dev_id = dev ? dev_name(dev) : NULL;\n\tstruct drm_privacy_screen_lookup *l;\n\tstruct drm_privacy_screen *priv;\n\tconst char *provider = NULL;\n\tint match, best = -1;\n\n\t \n\tmutex_lock(&drm_privacy_screen_lookup_lock);\n\n\tlist_for_each_entry(l, &drm_privacy_screen_lookup_list, list) {\n\t\tmatch = 0;\n\n\t\tif (l->dev_id) {\n\t\t\tif (!dev_id || strcmp(l->dev_id, dev_id))\n\t\t\t\tcontinue;\n\n\t\t\tmatch += 2;\n\t\t}\n\n\t\tif (l->con_id) {\n\t\t\tif (!con_id || strcmp(l->con_id, con_id))\n\t\t\t\tcontinue;\n\n\t\t\tmatch += 1;\n\t\t}\n\n\t\tif (match > best) {\n\t\t\tprovider = l->provider;\n\t\t\tbest = match;\n\t\t}\n\t}\n\n\tmutex_unlock(&drm_privacy_screen_lookup_lock);\n\n\tif (!provider)\n\t\treturn ERR_PTR(-ENODEV);\n\n\tpriv = drm_privacy_screen_get_by_name(provider);\n\tif (!priv)\n\t\treturn ERR_PTR(-EPROBE_DEFER);\n\n\treturn priv;\n}\nEXPORT_SYMBOL(drm_privacy_screen_get);\n\n \nvoid drm_privacy_screen_put(struct drm_privacy_screen *priv)\n{\n\tif (IS_ERR_OR_NULL(priv))\n\t\treturn;\n\n\tput_device(&priv->dev);\n}\nEXPORT_SYMBOL(drm_privacy_screen_put);\n\n \nint drm_privacy_screen_set_sw_state(struct drm_privacy_screen *priv,\n\t\t\t\t    enum drm_privacy_screen_status sw_state)\n{\n\tint ret = 0;\n\n\tmutex_lock(&priv->lock);\n\n\tif (!priv->ops) {\n\t\tret = -ENODEV;\n\t\tgoto out;\n\t}\n\n\t \n\tif (priv->hw_state >= PRIVACY_SCREEN_DISABLED_LOCKED ||\n\t    priv->hw_state == sw_state) {\n\t\tpriv->sw_state = sw_state;\n\t\tgoto out;\n\t}\n\n\tret = priv->ops->set_sw_state(priv, sw_state);\nout:\n\tmutex_unlock(&priv->lock);\n\treturn ret;\n}\nEXPORT_SYMBOL(drm_privacy_screen_set_sw_state);\n\n \nvoid drm_privacy_screen_get_state(struct drm_privacy_screen *priv,\n\t\t\t\t  enum drm_privacy_screen_status *sw_state_ret,\n\t\t\t\t  enum drm_privacy_screen_status *hw_state_ret)\n{\n\tmutex_lock(&priv->lock);\n\t*sw_state_ret = priv->sw_state;\n\t*hw_state_ret = priv->hw_state;\n\tmutex_unlock(&priv->lock);\n}\nEXPORT_SYMBOL(drm_privacy_screen_get_state);\n\n \nint drm_privacy_screen_register_notifier(struct drm_privacy_screen *priv,\n\t\t\t\t\t struct notifier_block *nb)\n{\n\treturn blocking_notifier_chain_register(&priv->notifier_head, nb);\n}\nEXPORT_SYMBOL(drm_privacy_screen_register_notifier);\n\n \nint drm_privacy_screen_unregister_notifier(struct drm_privacy_screen *priv,\n\t\t\t\t\t   struct notifier_block *nb)\n{\n\treturn blocking_notifier_chain_unregister(&priv->notifier_head, nb);\n}\nEXPORT_SYMBOL(drm_privacy_screen_unregister_notifier);\n\n \n\nstatic ssize_t sw_state_show(struct device *dev,\n\t\t\t     struct device_attribute *attr, char *buf)\n{\n\tstruct drm_privacy_screen *priv = to_drm_privacy_screen(dev);\n\tconst char * const sw_state_names[] = {\n\t\t\"Disabled\",\n\t\t\"Enabled\",\n\t};\n\tssize_t ret;\n\n\tmutex_lock(&priv->lock);\n\n\tif (!priv->ops)\n\t\tret = -ENODEV;\n\telse if (WARN_ON(priv->sw_state >= ARRAY_SIZE(sw_state_names)))\n\t\tret = -ENXIO;\n\telse\n\t\tret = sprintf(buf, \"%s\\n\", sw_state_names[priv->sw_state]);\n\n\tmutex_unlock(&priv->lock);\n\treturn ret;\n}\n \nstatic DEVICE_ATTR_RO(sw_state);\n\nstatic ssize_t hw_state_show(struct device *dev,\n\t\t\t     struct device_attribute *attr, char *buf)\n{\n\tstruct drm_privacy_screen *priv = to_drm_privacy_screen(dev);\n\tconst char * const hw_state_names[] = {\n\t\t\"Disabled\",\n\t\t\"Enabled\",\n\t\t\"Disabled, locked\",\n\t\t\"Enabled, locked\",\n\t};\n\tssize_t ret;\n\n\tmutex_lock(&priv->lock);\n\n\tif (!priv->ops)\n\t\tret = -ENODEV;\n\telse if (WARN_ON(priv->hw_state >= ARRAY_SIZE(hw_state_names)))\n\t\tret = -ENXIO;\n\telse\n\t\tret = sprintf(buf, \"%s\\n\", hw_state_names[priv->hw_state]);\n\n\tmutex_unlock(&priv->lock);\n\treturn ret;\n}\nstatic DEVICE_ATTR_RO(hw_state);\n\nstatic struct attribute *drm_privacy_screen_attrs[] = {\n\t&dev_attr_sw_state.attr,\n\t&dev_attr_hw_state.attr,\n\tNULL\n};\nATTRIBUTE_GROUPS(drm_privacy_screen);\n\nstatic struct device_type drm_privacy_screen_type = {\n\t.name = \"privacy_screen\",\n\t.groups = drm_privacy_screen_groups,\n};\n\nstatic void drm_privacy_screen_device_release(struct device *dev)\n{\n\tstruct drm_privacy_screen *priv = to_drm_privacy_screen(dev);\n\n\tkfree(priv);\n}\n\n \nstruct drm_privacy_screen *drm_privacy_screen_register(\n\tstruct device *parent, const struct drm_privacy_screen_ops *ops,\n\tvoid *data)\n{\n\tstruct drm_privacy_screen *priv;\n\tint ret;\n\n\tpriv = kzalloc(sizeof(*priv), GFP_KERNEL);\n\tif (!priv)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tmutex_init(&priv->lock);\n\tBLOCKING_INIT_NOTIFIER_HEAD(&priv->notifier_head);\n\n\tpriv->dev.class = drm_class;\n\tpriv->dev.type = &drm_privacy_screen_type;\n\tpriv->dev.parent = parent;\n\tpriv->dev.release = drm_privacy_screen_device_release;\n\tdev_set_name(&priv->dev, \"privacy_screen-%s\", dev_name(parent));\n\tpriv->drvdata = data;\n\tpriv->ops = ops;\n\n\tpriv->ops->get_hw_state(priv);\n\n\tret = device_register(&priv->dev);\n\tif (ret) {\n\t\tput_device(&priv->dev);\n\t\treturn ERR_PTR(ret);\n\t}\n\n\tmutex_lock(&drm_privacy_screen_devs_lock);\n\tlist_add(&priv->list, &drm_privacy_screen_devs);\n\tmutex_unlock(&drm_privacy_screen_devs_lock);\n\n\treturn priv;\n}\nEXPORT_SYMBOL(drm_privacy_screen_register);\n\n \nvoid drm_privacy_screen_unregister(struct drm_privacy_screen *priv)\n{\n\tif (IS_ERR_OR_NULL(priv))\n\t\treturn;\n\n\tmutex_lock(&drm_privacy_screen_devs_lock);\n\tlist_del(&priv->list);\n\tmutex_unlock(&drm_privacy_screen_devs_lock);\n\n\tmutex_lock(&priv->lock);\n\tpriv->drvdata = NULL;\n\tpriv->ops = NULL;\n\tmutex_unlock(&priv->lock);\n\n\tdevice_unregister(&priv->dev);\n}\nEXPORT_SYMBOL(drm_privacy_screen_unregister);\n\n \nvoid drm_privacy_screen_call_notifier_chain(struct drm_privacy_screen *priv)\n{\n\tblocking_notifier_call_chain(&priv->notifier_head, 0, priv);\n}\nEXPORT_SYMBOL(drm_privacy_screen_call_notifier_chain);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}