{
  "module_name": "etnaviv_cmdbuf.c",
  "hash_id": "2e6cf97ec0450bdfa150f0491ceba9f20bf43bd1cf00acf2b5994b2937ba96dc",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/etnaviv/etnaviv_cmdbuf.c",
  "human_readable_source": "\n \n\n#include <linux/dma-mapping.h>\n\n#include <drm/drm_mm.h>\n\n#include \"etnaviv_cmdbuf.h\"\n#include \"etnaviv_gem.h\"\n#include \"etnaviv_gpu.h\"\n#include \"etnaviv_mmu.h\"\n#include \"etnaviv_perfmon.h\"\n\n#define SUBALLOC_SIZE\t\tSZ_512K\n#define SUBALLOC_GRANULE\tSZ_4K\n#define SUBALLOC_GRANULES\t(SUBALLOC_SIZE / SUBALLOC_GRANULE)\n\nstruct etnaviv_cmdbuf_suballoc {\n\t \n\tstruct device *dev;\n\tvoid *vaddr;\n\tdma_addr_t paddr;\n\n\t \n\tstruct mutex lock;\n\tDECLARE_BITMAP(granule_map, SUBALLOC_GRANULES);\n\tint free_space;\n\twait_queue_head_t free_event;\n};\n\nstruct etnaviv_cmdbuf_suballoc *\netnaviv_cmdbuf_suballoc_new(struct device *dev)\n{\n\tstruct etnaviv_cmdbuf_suballoc *suballoc;\n\tint ret;\n\n\tsuballoc = kzalloc(sizeof(*suballoc), GFP_KERNEL);\n\tif (!suballoc)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tsuballoc->dev = dev;\n\tmutex_init(&suballoc->lock);\n\tinit_waitqueue_head(&suballoc->free_event);\n\n\tBUILD_BUG_ON(ETNAVIV_SOFTPIN_START_ADDRESS < SUBALLOC_SIZE);\n\tsuballoc->vaddr = dma_alloc_wc(dev, SUBALLOC_SIZE,\n\t\t\t\t       &suballoc->paddr, GFP_KERNEL);\n\tif (!suballoc->vaddr) {\n\t\tret = -ENOMEM;\n\t\tgoto free_suballoc;\n\t}\n\n\treturn suballoc;\n\nfree_suballoc:\n\tkfree(suballoc);\n\n\treturn ERR_PTR(ret);\n}\n\nint etnaviv_cmdbuf_suballoc_map(struct etnaviv_cmdbuf_suballoc *suballoc,\n\t\t\t\tstruct etnaviv_iommu_context *context,\n\t\t\t\tstruct etnaviv_vram_mapping *mapping,\n\t\t\t\tu32 memory_base)\n{\n\treturn etnaviv_iommu_get_suballoc_va(context, mapping, memory_base,\n\t\t\t\t\t     suballoc->paddr, SUBALLOC_SIZE);\n}\n\nvoid etnaviv_cmdbuf_suballoc_unmap(struct etnaviv_iommu_context *context,\n\t\t\t\t   struct etnaviv_vram_mapping *mapping)\n{\n\tetnaviv_iommu_put_suballoc_va(context, mapping);\n}\n\nvoid etnaviv_cmdbuf_suballoc_destroy(struct etnaviv_cmdbuf_suballoc *suballoc)\n{\n\tdma_free_wc(suballoc->dev, SUBALLOC_SIZE, suballoc->vaddr,\n\t\t    suballoc->paddr);\n\tkfree(suballoc);\n}\n\nint etnaviv_cmdbuf_init(struct etnaviv_cmdbuf_suballoc *suballoc,\n\t\t\tstruct etnaviv_cmdbuf *cmdbuf, u32 size)\n{\n\tint granule_offs, order, ret;\n\n\tcmdbuf->suballoc = suballoc;\n\tcmdbuf->size = size;\n\n\torder = order_base_2(ALIGN(size, SUBALLOC_GRANULE) / SUBALLOC_GRANULE);\nretry:\n\tmutex_lock(&suballoc->lock);\n\tgranule_offs = bitmap_find_free_region(suballoc->granule_map,\n\t\t\t\t\tSUBALLOC_GRANULES, order);\n\tif (granule_offs < 0) {\n\t\tsuballoc->free_space = 0;\n\t\tmutex_unlock(&suballoc->lock);\n\t\tret = wait_event_interruptible_timeout(suballoc->free_event,\n\t\t\t\t\t\t       suballoc->free_space,\n\t\t\t\t\t\t       msecs_to_jiffies(10 * 1000));\n\t\tif (!ret) {\n\t\t\tdev_err(suballoc->dev,\n\t\t\t\t\"Timeout waiting for cmdbuf space\\n\");\n\t\t\treturn -ETIMEDOUT;\n\t\t}\n\t\tgoto retry;\n\t}\n\tmutex_unlock(&suballoc->lock);\n\tcmdbuf->suballoc_offset = granule_offs * SUBALLOC_GRANULE;\n\tcmdbuf->vaddr = suballoc->vaddr + cmdbuf->suballoc_offset;\n\n\treturn 0;\n}\n\nvoid etnaviv_cmdbuf_free(struct etnaviv_cmdbuf *cmdbuf)\n{\n\tstruct etnaviv_cmdbuf_suballoc *suballoc = cmdbuf->suballoc;\n\tint order = order_base_2(ALIGN(cmdbuf->size, SUBALLOC_GRANULE) /\n\t\t\t\t SUBALLOC_GRANULE);\n\n\tif (!suballoc)\n\t\treturn;\n\n\tmutex_lock(&suballoc->lock);\n\tbitmap_release_region(suballoc->granule_map,\n\t\t\t      cmdbuf->suballoc_offset / SUBALLOC_GRANULE,\n\t\t\t      order);\n\tsuballoc->free_space = 1;\n\tmutex_unlock(&suballoc->lock);\n\twake_up_all(&suballoc->free_event);\n}\n\nu32 etnaviv_cmdbuf_get_va(struct etnaviv_cmdbuf *buf,\n\t\t\t  struct etnaviv_vram_mapping *mapping)\n{\n\treturn mapping->iova + buf->suballoc_offset;\n}\n\ndma_addr_t etnaviv_cmdbuf_get_pa(struct etnaviv_cmdbuf *buf)\n{\n\treturn buf->suballoc->paddr + buf->suballoc_offset;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}