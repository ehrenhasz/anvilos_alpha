{
  "module_name": "etnaviv_gem_submit.c",
  "hash_id": "ad416d3c3581d33d979afeb5b1d563e6637b14a9ae4535e2df57ac023da42408",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/etnaviv/etnaviv_gem_submit.c",
  "human_readable_source": "\n \n\n#include <drm/drm_file.h>\n#include <linux/dma-fence-array.h>\n#include <linux/file.h>\n#include <linux/pm_runtime.h>\n#include <linux/dma-resv.h>\n#include <linux/sync_file.h>\n#include <linux/uaccess.h>\n#include <linux/vmalloc.h>\n\n#include \"etnaviv_cmdbuf.h\"\n#include \"etnaviv_drv.h\"\n#include \"etnaviv_gpu.h\"\n#include \"etnaviv_gem.h\"\n#include \"etnaviv_perfmon.h\"\n#include \"etnaviv_sched.h\"\n\n \n\n#define BO_INVALID_FLAGS ~(ETNA_SUBMIT_BO_READ | ETNA_SUBMIT_BO_WRITE)\n \n#define BO_LOCKED   0x4000\n#define BO_PINNED   0x2000\n\nstatic struct etnaviv_gem_submit *submit_create(struct drm_device *dev,\n\t\tstruct etnaviv_gpu *gpu, size_t nr_bos, size_t nr_pmrs)\n{\n\tstruct etnaviv_gem_submit *submit;\n\tsize_t sz = size_vstruct(nr_bos, sizeof(submit->bos[0]), sizeof(*submit));\n\n\tsubmit = kzalloc(sz, GFP_KERNEL);\n\tif (!submit)\n\t\treturn NULL;\n\n\tsubmit->pmrs = kcalloc(nr_pmrs, sizeof(struct etnaviv_perfmon_request),\n\t\t\t       GFP_KERNEL);\n\tif (!submit->pmrs) {\n\t\tkfree(submit);\n\t\treturn NULL;\n\t}\n\tsubmit->nr_pmrs = nr_pmrs;\n\n\tsubmit->gpu = gpu;\n\tkref_init(&submit->refcount);\n\n\treturn submit;\n}\n\nstatic int submit_lookup_objects(struct etnaviv_gem_submit *submit,\n\tstruct drm_file *file, struct drm_etnaviv_gem_submit_bo *submit_bos,\n\tunsigned nr_bos)\n{\n\tstruct drm_etnaviv_gem_submit_bo *bo;\n\tunsigned i;\n\tint ret = 0;\n\n\tspin_lock(&file->table_lock);\n\n\tfor (i = 0, bo = submit_bos; i < nr_bos; i++, bo++) {\n\t\tstruct drm_gem_object *obj;\n\n\t\tif (bo->flags & BO_INVALID_FLAGS) {\n\t\t\tDRM_ERROR(\"invalid flags: %x\\n\", bo->flags);\n\t\t\tret = -EINVAL;\n\t\t\tgoto out_unlock;\n\t\t}\n\n\t\tsubmit->bos[i].flags = bo->flags;\n\t\tif (submit->flags & ETNA_SUBMIT_SOFTPIN) {\n\t\t\tif (bo->presumed < ETNAVIV_SOFTPIN_START_ADDRESS) {\n\t\t\t\tDRM_ERROR(\"invalid softpin address\\n\");\n\t\t\t\tret = -EINVAL;\n\t\t\t\tgoto out_unlock;\n\t\t\t}\n\t\t\tsubmit->bos[i].va = bo->presumed;\n\t\t}\n\n\t\t \n\t\tobj = idr_find(&file->object_idr, bo->handle);\n\t\tif (!obj) {\n\t\t\tDRM_ERROR(\"invalid handle %u at index %u\\n\",\n\t\t\t\t  bo->handle, i);\n\t\t\tret = -EINVAL;\n\t\t\tgoto out_unlock;\n\t\t}\n\n\t\t \n\t\tdrm_gem_object_get(obj);\n\n\t\tsubmit->bos[i].obj = to_etnaviv_bo(obj);\n\t}\n\nout_unlock:\n\tsubmit->nr_bos = i;\n\tspin_unlock(&file->table_lock);\n\n\treturn ret;\n}\n\nstatic void submit_unlock_object(struct etnaviv_gem_submit *submit, int i)\n{\n\tif (submit->bos[i].flags & BO_LOCKED) {\n\t\tstruct drm_gem_object *obj = &submit->bos[i].obj->base;\n\n\t\tdma_resv_unlock(obj->resv);\n\t\tsubmit->bos[i].flags &= ~BO_LOCKED;\n\t}\n}\n\nstatic int submit_lock_objects(struct etnaviv_gem_submit *submit,\n\t\tstruct ww_acquire_ctx *ticket)\n{\n\tint contended, slow_locked = -1, i, ret = 0;\n\nretry:\n\tfor (i = 0; i < submit->nr_bos; i++) {\n\t\tstruct drm_gem_object *obj = &submit->bos[i].obj->base;\n\n\t\tif (slow_locked == i)\n\t\t\tslow_locked = -1;\n\n\t\tcontended = i;\n\n\t\tif (!(submit->bos[i].flags & BO_LOCKED)) {\n\t\t\tret = dma_resv_lock_interruptible(obj->resv, ticket);\n\t\t\tif (ret == -EALREADY)\n\t\t\t\tDRM_ERROR(\"BO at index %u already on submit list\\n\",\n\t\t\t\t\t  i);\n\t\t\tif (ret)\n\t\t\t\tgoto fail;\n\t\t\tsubmit->bos[i].flags |= BO_LOCKED;\n\t\t}\n\t}\n\n\tww_acquire_done(ticket);\n\n\treturn 0;\n\nfail:\n\tfor (; i >= 0; i--)\n\t\tsubmit_unlock_object(submit, i);\n\n\tif (slow_locked > 0)\n\t\tsubmit_unlock_object(submit, slow_locked);\n\n\tif (ret == -EDEADLK) {\n\t\tstruct drm_gem_object *obj;\n\n\t\tobj = &submit->bos[contended].obj->base;\n\n\t\t \n\t\tret = dma_resv_lock_slow_interruptible(obj->resv, ticket);\n\t\tif (!ret) {\n\t\t\tsubmit->bos[contended].flags |= BO_LOCKED;\n\t\t\tslow_locked = contended;\n\t\t\tgoto retry;\n\t\t}\n\t}\n\n\treturn ret;\n}\n\nstatic int submit_fence_sync(struct etnaviv_gem_submit *submit)\n{\n\tint i, ret = 0;\n\n\tfor (i = 0; i < submit->nr_bos; i++) {\n\t\tstruct etnaviv_gem_submit_bo *bo = &submit->bos[i];\n\t\tstruct dma_resv *robj = bo->obj->base.resv;\n\n\t\tret = dma_resv_reserve_fences(robj, 1);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tif (submit->flags & ETNA_SUBMIT_NO_IMPLICIT)\n\t\t\tcontinue;\n\n\t\tret = drm_sched_job_add_implicit_dependencies(&submit->sched_job,\n\t\t\t\t\t\t\t      &bo->obj->base,\n\t\t\t\t\t\t\t      bo->flags & ETNA_SUBMIT_BO_WRITE);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn ret;\n}\n\nstatic void submit_attach_object_fences(struct etnaviv_gem_submit *submit)\n{\n\tint i;\n\n\tfor (i = 0; i < submit->nr_bos; i++) {\n\t\tstruct drm_gem_object *obj = &submit->bos[i].obj->base;\n\t\tbool write = submit->bos[i].flags & ETNA_SUBMIT_BO_WRITE;\n\n\t\tdma_resv_add_fence(obj->resv, submit->out_fence, write ?\n\t\t\t\t   DMA_RESV_USAGE_WRITE : DMA_RESV_USAGE_READ);\n\t\tsubmit_unlock_object(submit, i);\n\t}\n}\n\nstatic int submit_pin_objects(struct etnaviv_gem_submit *submit)\n{\n\tint i, ret = 0;\n\n\tfor (i = 0; i < submit->nr_bos; i++) {\n\t\tstruct etnaviv_gem_object *etnaviv_obj = submit->bos[i].obj;\n\t\tstruct etnaviv_vram_mapping *mapping;\n\n\t\tmapping = etnaviv_gem_mapping_get(&etnaviv_obj->base,\n\t\t\t\t\t\t  submit->mmu_context,\n\t\t\t\t\t\t  submit->bos[i].va);\n\t\tif (IS_ERR(mapping)) {\n\t\t\tret = PTR_ERR(mapping);\n\t\t\tbreak;\n\t\t}\n\n\t\tif ((submit->flags & ETNA_SUBMIT_SOFTPIN) &&\n\t\t     submit->bos[i].va != mapping->iova) {\n\t\t\tetnaviv_gem_mapping_unreference(mapping);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tatomic_inc(&etnaviv_obj->gpu_active);\n\n\t\tsubmit->bos[i].flags |= BO_PINNED;\n\t\tsubmit->bos[i].mapping = mapping;\n\t}\n\n\treturn ret;\n}\n\nstatic int submit_bo(struct etnaviv_gem_submit *submit, u32 idx,\n\tstruct etnaviv_gem_submit_bo **bo)\n{\n\tif (idx >= submit->nr_bos) {\n\t\tDRM_ERROR(\"invalid buffer index: %u (out of %u)\\n\",\n\t\t\t\tidx, submit->nr_bos);\n\t\treturn -EINVAL;\n\t}\n\n\t*bo = &submit->bos[idx];\n\n\treturn 0;\n}\n\n \nstatic int submit_reloc(struct etnaviv_gem_submit *submit, void *stream,\n\t\tu32 size, const struct drm_etnaviv_gem_submit_reloc *relocs,\n\t\tu32 nr_relocs)\n{\n\tu32 i, last_offset = 0;\n\tu32 *ptr = stream;\n\tint ret;\n\n\t \n\tif ((submit->flags & ETNA_SUBMIT_SOFTPIN) && nr_relocs != 0)\n\t\treturn -EINVAL;\n\n\tfor (i = 0; i < nr_relocs; i++) {\n\t\tconst struct drm_etnaviv_gem_submit_reloc *r = relocs + i;\n\t\tstruct etnaviv_gem_submit_bo *bo;\n\t\tu32 off;\n\n\t\tif (unlikely(r->flags)) {\n\t\t\tDRM_ERROR(\"invalid reloc flags\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (r->submit_offset % 4) {\n\t\t\tDRM_ERROR(\"non-aligned reloc offset: %u\\n\",\n\t\t\t\t  r->submit_offset);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\t \n\t\toff = r->submit_offset / 4;\n\n\t\tif ((off >= size ) ||\n\t\t\t\t(off < last_offset)) {\n\t\t\tDRM_ERROR(\"invalid offset %u at reloc %u\\n\", off, i);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tret = submit_bo(submit, r->reloc_idx, &bo);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tif (r->reloc_offset > bo->obj->base.size - sizeof(*ptr)) {\n\t\t\tDRM_ERROR(\"relocation %u outside object\\n\", i);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tptr[off] = bo->mapping->iova + r->reloc_offset;\n\n\t\tlast_offset = off;\n\t}\n\n\treturn 0;\n}\n\nstatic int submit_perfmon_validate(struct etnaviv_gem_submit *submit,\n\t\tu32 exec_state, const struct drm_etnaviv_gem_submit_pmr *pmrs)\n{\n\tu32 i;\n\n\tfor (i = 0; i < submit->nr_pmrs; i++) {\n\t\tconst struct drm_etnaviv_gem_submit_pmr *r = pmrs + i;\n\t\tstruct etnaviv_gem_submit_bo *bo;\n\t\tint ret;\n\n\t\tret = submit_bo(submit, r->read_idx, &bo);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\t \n\t\tif (r->read_offset == 0) {\n\t\t\tDRM_ERROR(\"perfmon request: offset is 0\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (r->read_offset >= bo->obj->base.size - sizeof(u32)) {\n\t\t\tDRM_ERROR(\"perfmon request: offset %u outside object\", i);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (r->flags & ~(ETNA_PM_PROCESS_PRE | ETNA_PM_PROCESS_POST)) {\n\t\t\tDRM_ERROR(\"perfmon request: flags are not valid\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (etnaviv_pm_req_validate(r, exec_state)) {\n\t\t\tDRM_ERROR(\"perfmon request: domain or signal not valid\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tsubmit->pmrs[i].flags = r->flags;\n\t\tsubmit->pmrs[i].domain = r->domain;\n\t\tsubmit->pmrs[i].signal = r->signal;\n\t\tsubmit->pmrs[i].sequence = r->sequence;\n\t\tsubmit->pmrs[i].offset = r->read_offset;\n\t\tsubmit->pmrs[i].bo_vma = etnaviv_gem_vmap(&bo->obj->base);\n\t}\n\n\treturn 0;\n}\n\nstatic void submit_cleanup(struct kref *kref)\n{\n\tstruct etnaviv_gem_submit *submit =\n\t\t\tcontainer_of(kref, struct etnaviv_gem_submit, refcount);\n\tunsigned i;\n\n\tif (submit->cmdbuf.suballoc)\n\t\tetnaviv_cmdbuf_free(&submit->cmdbuf);\n\n\tif (submit->mmu_context)\n\t\tetnaviv_iommu_context_put(submit->mmu_context);\n\n\tif (submit->prev_mmu_context)\n\t\tetnaviv_iommu_context_put(submit->prev_mmu_context);\n\n\tfor (i = 0; i < submit->nr_bos; i++) {\n\t\tstruct etnaviv_gem_object *etnaviv_obj = submit->bos[i].obj;\n\n\t\t \n\t\tif (submit->bos[i].flags & BO_PINNED) {\n\t\t\tetnaviv_gem_mapping_unreference(submit->bos[i].mapping);\n\t\t\tatomic_dec(&etnaviv_obj->gpu_active);\n\t\t\tsubmit->bos[i].mapping = NULL;\n\t\t\tsubmit->bos[i].flags &= ~BO_PINNED;\n\t\t}\n\n\t\t \n\t\tsubmit_unlock_object(submit, i);\n\t\tdrm_gem_object_put(&etnaviv_obj->base);\n\t}\n\n\twake_up_all(&submit->gpu->fence_event);\n\n\tif (submit->out_fence) {\n\t\t \n\t\txa_erase(&submit->gpu->user_fences, submit->out_fence_id);\n\t\tdma_fence_put(submit->out_fence);\n\t}\n\n\tput_pid(submit->pid);\n\n\tkfree(submit->pmrs);\n\tkfree(submit);\n}\n\nvoid etnaviv_submit_put(struct etnaviv_gem_submit *submit)\n{\n\tkref_put(&submit->refcount, submit_cleanup);\n}\n\nint etnaviv_ioctl_gem_submit(struct drm_device *dev, void *data,\n\t\tstruct drm_file *file)\n{\n\tstruct etnaviv_file_private *ctx = file->driver_priv;\n\tstruct etnaviv_drm_private *priv = dev->dev_private;\n\tstruct drm_etnaviv_gem_submit *args = data;\n\tstruct drm_etnaviv_gem_submit_reloc *relocs;\n\tstruct drm_etnaviv_gem_submit_pmr *pmrs;\n\tstruct drm_etnaviv_gem_submit_bo *bos;\n\tstruct etnaviv_gem_submit *submit;\n\tstruct etnaviv_gpu *gpu;\n\tstruct sync_file *sync_file = NULL;\n\tstruct ww_acquire_ctx ticket;\n\tint out_fence_fd = -1;\n\tstruct pid *pid = get_pid(task_pid(current));\n\tvoid *stream;\n\tint ret;\n\n\tif (args->pipe >= ETNA_MAX_PIPES)\n\t\treturn -EINVAL;\n\n\tgpu = priv->gpu[args->pipe];\n\tif (!gpu)\n\t\treturn -ENXIO;\n\n\tif (args->stream_size % 4) {\n\t\tDRM_ERROR(\"non-aligned cmdstream buffer size: %u\\n\",\n\t\t\t  args->stream_size);\n\t\treturn -EINVAL;\n\t}\n\n\tif (args->exec_state != ETNA_PIPE_3D &&\n\t    args->exec_state != ETNA_PIPE_2D &&\n\t    args->exec_state != ETNA_PIPE_VG) {\n\t\tDRM_ERROR(\"invalid exec_state: 0x%x\\n\", args->exec_state);\n\t\treturn -EINVAL;\n\t}\n\n\tif (args->flags & ~ETNA_SUBMIT_FLAGS) {\n\t\tDRM_ERROR(\"invalid flags: 0x%x\\n\", args->flags);\n\t\treturn -EINVAL;\n\t}\n\n\tif ((args->flags & ETNA_SUBMIT_SOFTPIN) &&\n\t    priv->mmu_global->version != ETNAVIV_IOMMU_V2) {\n\t\tDRM_ERROR(\"softpin requested on incompatible MMU\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (args->stream_size > SZ_128K || args->nr_relocs > SZ_128K ||\n\t    args->nr_bos > SZ_128K || args->nr_pmrs > 128) {\n\t\tDRM_ERROR(\"submit arguments out of size limits\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tbos = kvmalloc_array(args->nr_bos, sizeof(*bos), GFP_KERNEL);\n\trelocs = kvmalloc_array(args->nr_relocs, sizeof(*relocs), GFP_KERNEL);\n\tpmrs = kvmalloc_array(args->nr_pmrs, sizeof(*pmrs), GFP_KERNEL);\n\tstream = kvmalloc_array(1, args->stream_size, GFP_KERNEL);\n\tif (!bos || !relocs || !pmrs || !stream) {\n\t\tret = -ENOMEM;\n\t\tgoto err_submit_cmds;\n\t}\n\n\tret = copy_from_user(bos, u64_to_user_ptr(args->bos),\n\t\t\t     args->nr_bos * sizeof(*bos));\n\tif (ret) {\n\t\tret = -EFAULT;\n\t\tgoto err_submit_cmds;\n\t}\n\n\tret = copy_from_user(relocs, u64_to_user_ptr(args->relocs),\n\t\t\t     args->nr_relocs * sizeof(*relocs));\n\tif (ret) {\n\t\tret = -EFAULT;\n\t\tgoto err_submit_cmds;\n\t}\n\n\tret = copy_from_user(pmrs, u64_to_user_ptr(args->pmrs),\n\t\t\t     args->nr_pmrs * sizeof(*pmrs));\n\tif (ret) {\n\t\tret = -EFAULT;\n\t\tgoto err_submit_cmds;\n\t}\n\n\tret = copy_from_user(stream, u64_to_user_ptr(args->stream),\n\t\t\t     args->stream_size);\n\tif (ret) {\n\t\tret = -EFAULT;\n\t\tgoto err_submit_cmds;\n\t}\n\n\tif (args->flags & ETNA_SUBMIT_FENCE_FD_OUT) {\n\t\tout_fence_fd = get_unused_fd_flags(O_CLOEXEC);\n\t\tif (out_fence_fd < 0) {\n\t\t\tret = out_fence_fd;\n\t\t\tgoto err_submit_cmds;\n\t\t}\n\t}\n\n\tww_acquire_init(&ticket, &reservation_ww_class);\n\n\tsubmit = submit_create(dev, gpu, args->nr_bos, args->nr_pmrs);\n\tif (!submit) {\n\t\tret = -ENOMEM;\n\t\tgoto err_submit_ww_acquire;\n\t}\n\n\tsubmit->pid = pid;\n\n\tret = etnaviv_cmdbuf_init(priv->cmdbuf_suballoc, &submit->cmdbuf,\n\t\t\t\t  ALIGN(args->stream_size, 8) + 8);\n\tif (ret)\n\t\tgoto err_submit_put;\n\n\tsubmit->ctx = file->driver_priv;\n\tsubmit->mmu_context = etnaviv_iommu_context_get(submit->ctx->mmu);\n\tsubmit->exec_state = args->exec_state;\n\tsubmit->flags = args->flags;\n\n\tret = drm_sched_job_init(&submit->sched_job,\n\t\t\t\t &ctx->sched_entity[args->pipe],\n\t\t\t\t submit->ctx);\n\tif (ret)\n\t\tgoto err_submit_put;\n\n\tret = submit_lookup_objects(submit, file, bos, args->nr_bos);\n\tif (ret)\n\t\tgoto err_submit_job;\n\n\tif ((priv->mmu_global->version != ETNAVIV_IOMMU_V2) &&\n\t    !etnaviv_cmd_validate_one(gpu, stream, args->stream_size / 4,\n\t\t\t\t      relocs, args->nr_relocs)) {\n\t\tret = -EINVAL;\n\t\tgoto err_submit_job;\n\t}\n\n\tif (args->flags & ETNA_SUBMIT_FENCE_FD_IN) {\n\t\tstruct dma_fence *in_fence = sync_file_get_fence(args->fence_fd);\n\t\tif (!in_fence) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto err_submit_job;\n\t\t}\n\n\t\tret = drm_sched_job_add_dependency(&submit->sched_job,\n\t\t\t\t\t\t   in_fence);\n\t\tif (ret)\n\t\t\tgoto err_submit_job;\n\t}\n\n\tret = submit_pin_objects(submit);\n\tif (ret)\n\t\tgoto err_submit_job;\n\n\tret = submit_reloc(submit, stream, args->stream_size / 4,\n\t\t\t   relocs, args->nr_relocs);\n\tif (ret)\n\t\tgoto err_submit_job;\n\n\tret = submit_perfmon_validate(submit, args->exec_state, pmrs);\n\tif (ret)\n\t\tgoto err_submit_job;\n\n\tmemcpy(submit->cmdbuf.vaddr, stream, args->stream_size);\n\n\tret = submit_lock_objects(submit, &ticket);\n\tif (ret)\n\t\tgoto err_submit_job;\n\n\tret = submit_fence_sync(submit);\n\tif (ret)\n\t\tgoto err_submit_job;\n\n\tret = etnaviv_sched_push_job(submit);\n\tif (ret)\n\t\tgoto err_submit_job;\n\n\tsubmit_attach_object_fences(submit);\n\n\tif (args->flags & ETNA_SUBMIT_FENCE_FD_OUT) {\n\t\t \n\t\tsync_file = sync_file_create(submit->out_fence);\n\t\tif (!sync_file) {\n\t\t\tret = -ENOMEM;\n\t\t\t \n\t\t\tgoto err_submit_put;\n\t\t}\n\t\tfd_install(out_fence_fd, sync_file->file);\n\t}\n\n\targs->fence_fd = out_fence_fd;\n\targs->fence = submit->out_fence_id;\n\nerr_submit_job:\n\tif (ret)\n\t\tdrm_sched_job_cleanup(&submit->sched_job);\nerr_submit_put:\n\tetnaviv_submit_put(submit);\n\nerr_submit_ww_acquire:\n\tww_acquire_fini(&ticket);\n\nerr_submit_cmds:\n\tif (ret && (out_fence_fd >= 0))\n\t\tput_unused_fd(out_fence_fd);\n\tkvfree(stream);\n\tkvfree(bos);\n\tkvfree(relocs);\n\tkvfree(pmrs);\n\n\treturn ret;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}