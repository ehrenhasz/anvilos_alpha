{
  "module_name": "etnaviv_cmd_parser.c",
  "hash_id": "171497dd302caa19d8f3ec70a53373124ef6c8fd7c67d548677074e852ec8d01",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/etnaviv/etnaviv_cmd_parser.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n\n#include \"etnaviv_gem.h\"\n#include \"etnaviv_gpu.h\"\n\n#include \"cmdstream.xml.h\"\n\n#define EXTRACT(val, field) (((val) & field##__MASK) >> field##__SHIFT)\n\nstruct etna_validation_state {\n\tstruct etnaviv_gpu *gpu;\n\tconst struct drm_etnaviv_gem_submit_reloc *relocs;\n\tunsigned int num_relocs;\n\tu32 *start;\n};\n\nstatic const struct {\n\tu16 offset;\n\tu16 size;\n} etnaviv_sensitive_states[] __initconst = {\n#define ST(start, num) { (start) >> 2, (num) }\n\t \n\tST(0x1200, 1),\n\tST(0x1228, 1),\n\tST(0x1238, 1),\n\tST(0x1284, 1),\n\tST(0x128c, 1),\n\tST(0x1304, 1),\n\tST(0x1310, 1),\n\tST(0x1318, 1),\n\tST(0x12800, 4),\n\tST(0x128a0, 4),\n\tST(0x128c0, 4),\n\tST(0x12970, 4),\n\tST(0x12a00, 8),\n\tST(0x12b40, 8),\n\tST(0x12b80, 8),\n\tST(0x12ce0, 8),\n\t \n\tST(0x0644, 1),\n\tST(0x064c, 1),\n\tST(0x0680, 8),\n\tST(0x086c, 1),\n\tST(0x1028, 1),\n\tST(0x1410, 1),\n\tST(0x1430, 1),\n\tST(0x1458, 1),\n\tST(0x1460, 8),\n\tST(0x1480, 8),\n\tST(0x1500, 8),\n\tST(0x1520, 8),\n\tST(0x1608, 1),\n\tST(0x1610, 1),\n\tST(0x1658, 1),\n\tST(0x165c, 1),\n\tST(0x1664, 1),\n\tST(0x1668, 1),\n\tST(0x16a4, 1),\n\tST(0x16c0, 8),\n\tST(0x16e0, 8),\n\tST(0x1740, 8),\n\tST(0x17c0, 8),\n\tST(0x17e0, 8),\n\tST(0x2400, 14 * 16),\n\tST(0x3824, 1),\n\tST(0x10800, 32 * 16),\n\tST(0x14600, 16),\n\tST(0x14800, 8 * 8),\n#undef ST\n};\n\n#define ETNAVIV_STATES_SIZE (VIV_FE_LOAD_STATE_HEADER_OFFSET__MASK + 1u)\nstatic DECLARE_BITMAP(etnaviv_states, ETNAVIV_STATES_SIZE);\n\nvoid __init etnaviv_validate_init(void)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < ARRAY_SIZE(etnaviv_sensitive_states); i++)\n\t\tbitmap_set(etnaviv_states, etnaviv_sensitive_states[i].offset,\n\t\t\t   etnaviv_sensitive_states[i].size);\n}\n\nstatic void etnaviv_warn_if_non_sensitive(struct etna_validation_state *state,\n\tunsigned int buf_offset, unsigned int state_addr)\n{\n\tif (state->num_relocs && state->relocs->submit_offset < buf_offset) {\n\t\tdev_warn_once(state->gpu->dev,\n\t\t\t      \"%s: relocation for non-sensitive state 0x%x at offset %u\\n\",\n\t\t\t      __func__, state_addr,\n\t\t\t      state->relocs->submit_offset);\n\t\twhile (state->num_relocs &&\n\t\t       state->relocs->submit_offset < buf_offset) {\n\t\t\tstate->relocs++;\n\t\t\tstate->num_relocs--;\n\t\t}\n\t}\n}\n\nstatic bool etnaviv_validate_load_state(struct etna_validation_state *state,\n\tu32 *ptr, unsigned int state_offset, unsigned int num)\n{\n\tunsigned int size = min(ETNAVIV_STATES_SIZE, state_offset + num);\n\tunsigned int st_offset = state_offset, buf_offset;\n\n\tfor_each_set_bit_from(st_offset, etnaviv_states, size) {\n\t\tbuf_offset = (ptr - state->start +\n\t\t\t      st_offset - state_offset) * 4;\n\n\t\tetnaviv_warn_if_non_sensitive(state, buf_offset, st_offset * 4);\n\t\tif (state->num_relocs &&\n\t\t    state->relocs->submit_offset == buf_offset) {\n\t\t\tstate->relocs++;\n\t\t\tstate->num_relocs--;\n\t\t\tcontinue;\n\t\t}\n\n\t\tdev_warn_ratelimited(state->gpu->dev,\n\t\t\t\t     \"%s: load state touches restricted state 0x%x at offset %u\\n\",\n\t\t\t\t     __func__, st_offset * 4, buf_offset);\n\t\treturn false;\n\t}\n\n\tif (state->num_relocs) {\n\t\tbuf_offset = (ptr - state->start + num) * 4;\n\t\tetnaviv_warn_if_non_sensitive(state, buf_offset, st_offset * 4 +\n\t\t\t\t\t      state->relocs->submit_offset -\n\t\t\t\t\t      buf_offset);\n\t}\n\n\treturn true;\n}\n\nstatic uint8_t cmd_length[32] = {\n\t[FE_OPCODE_DRAW_PRIMITIVES] = 4,\n\t[FE_OPCODE_DRAW_INDEXED_PRIMITIVES] = 6,\n\t[FE_OPCODE_DRAW_INSTANCED] = 4,\n\t[FE_OPCODE_NOP] = 2,\n\t[FE_OPCODE_STALL] = 2,\n};\n\nbool etnaviv_cmd_validate_one(struct etnaviv_gpu *gpu, u32 *stream,\n\t\t\t      unsigned int size,\n\t\t\t      struct drm_etnaviv_gem_submit_reloc *relocs,\n\t\t\t      unsigned int reloc_size)\n{\n\tstruct etna_validation_state state;\n\tu32 *buf = stream;\n\tu32 *end = buf + size;\n\n\tstate.gpu = gpu;\n\tstate.relocs = relocs;\n\tstate.num_relocs = reloc_size;\n\tstate.start = stream;\n\n\twhile (buf < end) {\n\t\tu32 cmd = *buf;\n\t\tunsigned int len, n, off;\n\t\tunsigned int op = cmd >> 27;\n\n\t\tswitch (op) {\n\t\tcase FE_OPCODE_LOAD_STATE:\n\t\t\tn = EXTRACT(cmd, VIV_FE_LOAD_STATE_HEADER_COUNT);\n\t\t\tlen = ALIGN(1 + n, 2);\n\t\t\tif (buf + len > end)\n\t\t\t\tbreak;\n\n\t\t\toff = EXTRACT(cmd, VIV_FE_LOAD_STATE_HEADER_OFFSET);\n\t\t\tif (!etnaviv_validate_load_state(&state, buf + 1,\n\t\t\t\t\t\t\t off, n))\n\t\t\t\treturn false;\n\t\t\tbreak;\n\n\t\tcase FE_OPCODE_DRAW_2D:\n\t\t\tn = EXTRACT(cmd, VIV_FE_DRAW_2D_HEADER_COUNT);\n\t\t\tif (n == 0)\n\t\t\t\tn = 256;\n\t\t\tlen = 2 + n * 2;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tlen = cmd_length[op];\n\t\t\tif (len == 0) {\n\t\t\t\tdev_err(gpu->dev, \"%s: op %u not permitted at offset %tu\\n\",\n\t\t\t\t\t__func__, op, buf - state.start);\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\n\t\tbuf += len;\n\t}\n\n\tif (buf > end) {\n\t\tdev_err(gpu->dev, \"%s: commands overflow end of buffer: %tu > %u\\n\",\n\t\t\t__func__, buf - state.start, size);\n\t\treturn false;\n\t}\n\n\treturn true;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}