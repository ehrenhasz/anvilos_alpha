{
  "module_name": "etnaviv_gem.c",
  "hash_id": "2d658eb9678290814cf9ffde559b2ea5bbe97507b5f48479c2eead0608a6f44e",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/etnaviv/etnaviv_gem.c",
  "human_readable_source": "\n \n\n#include <drm/drm_prime.h>\n#include <linux/dma-mapping.h>\n#include <linux/shmem_fs.h>\n#include <linux/spinlock.h>\n#include <linux/vmalloc.h>\n\n#include \"etnaviv_drv.h\"\n#include \"etnaviv_gem.h\"\n#include \"etnaviv_gpu.h\"\n#include \"etnaviv_mmu.h\"\n\nstatic struct lock_class_key etnaviv_shm_lock_class;\nstatic struct lock_class_key etnaviv_userptr_lock_class;\n\nstatic void etnaviv_gem_scatter_map(struct etnaviv_gem_object *etnaviv_obj)\n{\n\tstruct drm_device *dev = etnaviv_obj->base.dev;\n\tstruct sg_table *sgt = etnaviv_obj->sgt;\n\n\t \n\tif (etnaviv_obj->flags & ETNA_BO_CACHE_MASK)\n\t\tdma_map_sgtable(dev->dev, sgt, DMA_BIDIRECTIONAL, 0);\n}\n\nstatic void etnaviv_gem_scatterlist_unmap(struct etnaviv_gem_object *etnaviv_obj)\n{\n\tstruct drm_device *dev = etnaviv_obj->base.dev;\n\tstruct sg_table *sgt = etnaviv_obj->sgt;\n\n\t \n\tif (etnaviv_obj->flags & ETNA_BO_CACHE_MASK)\n\t\tdma_unmap_sgtable(dev->dev, sgt, DMA_BIDIRECTIONAL, 0);\n}\n\n \nstatic int etnaviv_gem_shmem_get_pages(struct etnaviv_gem_object *etnaviv_obj)\n{\n\tstruct drm_device *dev = etnaviv_obj->base.dev;\n\tstruct page **p = drm_gem_get_pages(&etnaviv_obj->base);\n\n\tif (IS_ERR(p)) {\n\t\tdev_dbg(dev->dev, \"could not get pages: %ld\\n\", PTR_ERR(p));\n\t\treturn PTR_ERR(p);\n\t}\n\n\tetnaviv_obj->pages = p;\n\n\treturn 0;\n}\n\nstatic void put_pages(struct etnaviv_gem_object *etnaviv_obj)\n{\n\tif (etnaviv_obj->sgt) {\n\t\tetnaviv_gem_scatterlist_unmap(etnaviv_obj);\n\t\tsg_free_table(etnaviv_obj->sgt);\n\t\tkfree(etnaviv_obj->sgt);\n\t\tetnaviv_obj->sgt = NULL;\n\t}\n\tif (etnaviv_obj->pages) {\n\t\tdrm_gem_put_pages(&etnaviv_obj->base, etnaviv_obj->pages,\n\t\t\t\t  true, false);\n\n\t\tetnaviv_obj->pages = NULL;\n\t}\n}\n\nstruct page **etnaviv_gem_get_pages(struct etnaviv_gem_object *etnaviv_obj)\n{\n\tint ret;\n\n\tlockdep_assert_held(&etnaviv_obj->lock);\n\n\tif (!etnaviv_obj->pages) {\n\t\tret = etnaviv_obj->ops->get_pages(etnaviv_obj);\n\t\tif (ret < 0)\n\t\t\treturn ERR_PTR(ret);\n\t}\n\n\tif (!etnaviv_obj->sgt) {\n\t\tstruct drm_device *dev = etnaviv_obj->base.dev;\n\t\tint npages = etnaviv_obj->base.size >> PAGE_SHIFT;\n\t\tstruct sg_table *sgt;\n\n\t\tsgt = drm_prime_pages_to_sg(etnaviv_obj->base.dev,\n\t\t\t\t\t    etnaviv_obj->pages, npages);\n\t\tif (IS_ERR(sgt)) {\n\t\t\tdev_err(dev->dev, \"failed to allocate sgt: %ld\\n\",\n\t\t\t\tPTR_ERR(sgt));\n\t\t\treturn ERR_CAST(sgt);\n\t\t}\n\n\t\tetnaviv_obj->sgt = sgt;\n\n\t\tetnaviv_gem_scatter_map(etnaviv_obj);\n\t}\n\n\treturn etnaviv_obj->pages;\n}\n\nvoid etnaviv_gem_put_pages(struct etnaviv_gem_object *etnaviv_obj)\n{\n\tlockdep_assert_held(&etnaviv_obj->lock);\n\t \n}\n\nstatic int etnaviv_gem_mmap_obj(struct etnaviv_gem_object *etnaviv_obj,\n\t\tstruct vm_area_struct *vma)\n{\n\tpgprot_t vm_page_prot;\n\n\tvm_flags_set(vma, VM_PFNMAP | VM_DONTEXPAND | VM_DONTDUMP);\n\n\tvm_page_prot = vm_get_page_prot(vma->vm_flags);\n\n\tif (etnaviv_obj->flags & ETNA_BO_WC) {\n\t\tvma->vm_page_prot = pgprot_writecombine(vm_page_prot);\n\t} else if (etnaviv_obj->flags & ETNA_BO_UNCACHED) {\n\t\tvma->vm_page_prot = pgprot_noncached(vm_page_prot);\n\t} else {\n\t\t \n\t\tvma->vm_pgoff = 0;\n\t\tvma_set_file(vma, etnaviv_obj->base.filp);\n\n\t\tvma->vm_page_prot = vm_page_prot;\n\t}\n\n\treturn 0;\n}\n\nstatic int etnaviv_gem_mmap(struct drm_gem_object *obj, struct vm_area_struct *vma)\n{\n\tstruct etnaviv_gem_object *etnaviv_obj = to_etnaviv_bo(obj);\n\n\treturn etnaviv_obj->ops->mmap(etnaviv_obj, vma);\n}\n\nstatic vm_fault_t etnaviv_gem_fault(struct vm_fault *vmf)\n{\n\tstruct vm_area_struct *vma = vmf->vma;\n\tstruct drm_gem_object *obj = vma->vm_private_data;\n\tstruct etnaviv_gem_object *etnaviv_obj = to_etnaviv_bo(obj);\n\tstruct page **pages;\n\tunsigned long pfn;\n\tpgoff_t pgoff;\n\tint err;\n\n\t \n\terr = mutex_lock_interruptible(&etnaviv_obj->lock);\n\tif (err)\n\t\treturn VM_FAULT_NOPAGE;\n\t \n\tpages = etnaviv_gem_get_pages(etnaviv_obj);\n\tmutex_unlock(&etnaviv_obj->lock);\n\n\tif (IS_ERR(pages)) {\n\t\terr = PTR_ERR(pages);\n\t\treturn vmf_error(err);\n\t}\n\n\t \n\tpgoff = (vmf->address - vma->vm_start) >> PAGE_SHIFT;\n\n\tpfn = page_to_pfn(pages[pgoff]);\n\n\tVERB(\"Inserting %p pfn %lx, pa %lx\", (void *)vmf->address,\n\t     pfn, pfn << PAGE_SHIFT);\n\n\treturn vmf_insert_pfn(vma, vmf->address, pfn);\n}\n\nint etnaviv_gem_mmap_offset(struct drm_gem_object *obj, u64 *offset)\n{\n\tint ret;\n\n\t \n\tret = drm_gem_create_mmap_offset(obj);\n\tif (ret)\n\t\tdev_err(obj->dev->dev, \"could not allocate mmap offset\\n\");\n\telse\n\t\t*offset = drm_vma_node_offset_addr(&obj->vma_node);\n\n\treturn ret;\n}\n\nstatic struct etnaviv_vram_mapping *\netnaviv_gem_get_vram_mapping(struct etnaviv_gem_object *obj,\n\t\t\t     struct etnaviv_iommu_context *context)\n{\n\tstruct etnaviv_vram_mapping *mapping;\n\n\tlist_for_each_entry(mapping, &obj->vram_list, obj_node) {\n\t\tif (mapping->context == context)\n\t\t\treturn mapping;\n\t}\n\n\treturn NULL;\n}\n\nvoid etnaviv_gem_mapping_unreference(struct etnaviv_vram_mapping *mapping)\n{\n\tstruct etnaviv_gem_object *etnaviv_obj = mapping->object;\n\n\tmutex_lock(&etnaviv_obj->lock);\n\tWARN_ON(mapping->use == 0);\n\tmapping->use -= 1;\n\tmutex_unlock(&etnaviv_obj->lock);\n\n\tdrm_gem_object_put(&etnaviv_obj->base);\n}\n\nstruct etnaviv_vram_mapping *etnaviv_gem_mapping_get(\n\tstruct drm_gem_object *obj, struct etnaviv_iommu_context *mmu_context,\n\tu64 va)\n{\n\tstruct etnaviv_gem_object *etnaviv_obj = to_etnaviv_bo(obj);\n\tstruct etnaviv_vram_mapping *mapping;\n\tstruct page **pages;\n\tint ret = 0;\n\n\tmutex_lock(&etnaviv_obj->lock);\n\tmapping = etnaviv_gem_get_vram_mapping(etnaviv_obj, mmu_context);\n\tif (mapping) {\n\t\t \n\t\tif (mapping->use == 0) {\n\t\t\tmutex_lock(&mmu_context->lock);\n\t\t\tif (mapping->context == mmu_context)\n\t\t\t\tif (va && mapping->iova != va) {\n\t\t\t\t\tetnaviv_iommu_reap_mapping(mapping);\n\t\t\t\t\tmapping = NULL;\n\t\t\t\t} else {\n\t\t\t\t\tmapping->use += 1;\n\t\t\t\t}\n\t\t\telse\n\t\t\t\tmapping = NULL;\n\t\t\tmutex_unlock(&mmu_context->lock);\n\t\t\tif (mapping)\n\t\t\t\tgoto out;\n\t\t} else {\n\t\t\tmapping->use += 1;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tpages = etnaviv_gem_get_pages(etnaviv_obj);\n\tif (IS_ERR(pages)) {\n\t\tret = PTR_ERR(pages);\n\t\tgoto out;\n\t}\n\n\t \n\tmapping = etnaviv_gem_get_vram_mapping(etnaviv_obj, NULL);\n\tif (!mapping) {\n\t\tmapping = kzalloc(sizeof(*mapping), GFP_KERNEL);\n\t\tif (!mapping) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\n\t\tINIT_LIST_HEAD(&mapping->scan_node);\n\t\tmapping->object = etnaviv_obj;\n\t} else {\n\t\tlist_del(&mapping->obj_node);\n\t}\n\n\tmapping->use = 1;\n\n\tret = etnaviv_iommu_map_gem(mmu_context, etnaviv_obj,\n\t\t\t\t    mmu_context->global->memory_base,\n\t\t\t\t    mapping, va);\n\tif (ret < 0)\n\t\tkfree(mapping);\n\telse\n\t\tlist_add_tail(&mapping->obj_node, &etnaviv_obj->vram_list);\n\nout:\n\tmutex_unlock(&etnaviv_obj->lock);\n\n\tif (ret)\n\t\treturn ERR_PTR(ret);\n\n\t \n\tdrm_gem_object_get(obj);\n\treturn mapping;\n}\n\nvoid *etnaviv_gem_vmap(struct drm_gem_object *obj)\n{\n\tstruct etnaviv_gem_object *etnaviv_obj = to_etnaviv_bo(obj);\n\n\tif (etnaviv_obj->vaddr)\n\t\treturn etnaviv_obj->vaddr;\n\n\tmutex_lock(&etnaviv_obj->lock);\n\t \n\tif (!etnaviv_obj->vaddr)\n\t\tetnaviv_obj->vaddr = etnaviv_obj->ops->vmap(etnaviv_obj);\n\tmutex_unlock(&etnaviv_obj->lock);\n\n\treturn etnaviv_obj->vaddr;\n}\n\nstatic void *etnaviv_gem_vmap_impl(struct etnaviv_gem_object *obj)\n{\n\tstruct page **pages;\n\n\tlockdep_assert_held(&obj->lock);\n\n\tpages = etnaviv_gem_get_pages(obj);\n\tif (IS_ERR(pages))\n\t\treturn NULL;\n\n\treturn vmap(pages, obj->base.size >> PAGE_SHIFT,\n\t\t\tVM_MAP, pgprot_writecombine(PAGE_KERNEL));\n}\n\nstatic inline enum dma_data_direction etnaviv_op_to_dma_dir(u32 op)\n{\n\tif (op & ETNA_PREP_READ)\n\t\treturn DMA_FROM_DEVICE;\n\telse if (op & ETNA_PREP_WRITE)\n\t\treturn DMA_TO_DEVICE;\n\telse\n\t\treturn DMA_BIDIRECTIONAL;\n}\n\nint etnaviv_gem_cpu_prep(struct drm_gem_object *obj, u32 op,\n\t\tstruct drm_etnaviv_timespec *timeout)\n{\n\tstruct etnaviv_gem_object *etnaviv_obj = to_etnaviv_bo(obj);\n\tstruct drm_device *dev = obj->dev;\n\tbool write = !!(op & ETNA_PREP_WRITE);\n\tint ret;\n\n\tif (!etnaviv_obj->sgt) {\n\t\tvoid *ret;\n\n\t\tmutex_lock(&etnaviv_obj->lock);\n\t\tret = etnaviv_gem_get_pages(etnaviv_obj);\n\t\tmutex_unlock(&etnaviv_obj->lock);\n\t\tif (IS_ERR(ret))\n\t\t\treturn PTR_ERR(ret);\n\t}\n\n\tif (op & ETNA_PREP_NOSYNC) {\n\t\tif (!dma_resv_test_signaled(obj->resv,\n\t\t\t\t\t    dma_resv_usage_rw(write)))\n\t\t\treturn -EBUSY;\n\t} else {\n\t\tunsigned long remain = etnaviv_timeout_to_jiffies(timeout);\n\n\t\tret = dma_resv_wait_timeout(obj->resv, dma_resv_usage_rw(write),\n\t\t\t\t\t    true, remain);\n\t\tif (ret <= 0)\n\t\t\treturn ret == 0 ? -ETIMEDOUT : ret;\n\t}\n\n\tif (etnaviv_obj->flags & ETNA_BO_CACHED) {\n\t\tdma_sync_sgtable_for_cpu(dev->dev, etnaviv_obj->sgt,\n\t\t\t\t\t etnaviv_op_to_dma_dir(op));\n\t\tetnaviv_obj->last_cpu_prep_op = op;\n\t}\n\n\treturn 0;\n}\n\nint etnaviv_gem_cpu_fini(struct drm_gem_object *obj)\n{\n\tstruct drm_device *dev = obj->dev;\n\tstruct etnaviv_gem_object *etnaviv_obj = to_etnaviv_bo(obj);\n\n\tif (etnaviv_obj->flags & ETNA_BO_CACHED) {\n\t\t \n\t\tWARN_ON(etnaviv_obj->last_cpu_prep_op == 0);\n\t\tdma_sync_sgtable_for_device(dev->dev, etnaviv_obj->sgt,\n\t\t\tetnaviv_op_to_dma_dir(etnaviv_obj->last_cpu_prep_op));\n\t\tetnaviv_obj->last_cpu_prep_op = 0;\n\t}\n\n\treturn 0;\n}\n\nint etnaviv_gem_wait_bo(struct etnaviv_gpu *gpu, struct drm_gem_object *obj,\n\tstruct drm_etnaviv_timespec *timeout)\n{\n\tstruct etnaviv_gem_object *etnaviv_obj = to_etnaviv_bo(obj);\n\n\treturn etnaviv_gpu_wait_obj_inactive(gpu, etnaviv_obj, timeout);\n}\n\n#ifdef CONFIG_DEBUG_FS\nstatic void etnaviv_gem_describe(struct drm_gem_object *obj, struct seq_file *m)\n{\n\tstruct etnaviv_gem_object *etnaviv_obj = to_etnaviv_bo(obj);\n\tstruct dma_resv *robj = obj->resv;\n\tunsigned long off = drm_vma_node_start(&obj->vma_node);\n\tint r;\n\n\tseq_printf(m, \"%08x: %c %2d (%2d) %08lx %p %zd\\n\",\n\t\t\tetnaviv_obj->flags, is_active(etnaviv_obj) ? 'A' : 'I',\n\t\t\tobj->name, kref_read(&obj->refcount),\n\t\t\toff, etnaviv_obj->vaddr, obj->size);\n\n\tr = dma_resv_lock(robj, NULL);\n\tif (r)\n\t\treturn;\n\n\tdma_resv_describe(robj, m);\n\tdma_resv_unlock(robj);\n}\n\nvoid etnaviv_gem_describe_objects(struct etnaviv_drm_private *priv,\n\tstruct seq_file *m)\n{\n\tstruct etnaviv_gem_object *etnaviv_obj;\n\tint count = 0;\n\tsize_t size = 0;\n\n\tmutex_lock(&priv->gem_lock);\n\tlist_for_each_entry(etnaviv_obj, &priv->gem_list, gem_node) {\n\t\tstruct drm_gem_object *obj = &etnaviv_obj->base;\n\n\t\tseq_puts(m, \"   \");\n\t\tetnaviv_gem_describe(obj, m);\n\t\tcount++;\n\t\tsize += obj->size;\n\t}\n\tmutex_unlock(&priv->gem_lock);\n\n\tseq_printf(m, \"Total %d objects, %zu bytes\\n\", count, size);\n}\n#endif\n\nstatic void etnaviv_gem_shmem_release(struct etnaviv_gem_object *etnaviv_obj)\n{\n\tvunmap(etnaviv_obj->vaddr);\n\tput_pages(etnaviv_obj);\n}\n\nstatic const struct etnaviv_gem_ops etnaviv_gem_shmem_ops = {\n\t.get_pages = etnaviv_gem_shmem_get_pages,\n\t.release = etnaviv_gem_shmem_release,\n\t.vmap = etnaviv_gem_vmap_impl,\n\t.mmap = etnaviv_gem_mmap_obj,\n};\n\nvoid etnaviv_gem_free_object(struct drm_gem_object *obj)\n{\n\tstruct etnaviv_gem_object *etnaviv_obj = to_etnaviv_bo(obj);\n\tstruct etnaviv_drm_private *priv = obj->dev->dev_private;\n\tstruct etnaviv_vram_mapping *mapping, *tmp;\n\n\t \n\tWARN_ON(is_active(etnaviv_obj));\n\n\tmutex_lock(&priv->gem_lock);\n\tlist_del(&etnaviv_obj->gem_node);\n\tmutex_unlock(&priv->gem_lock);\n\n\tlist_for_each_entry_safe(mapping, tmp, &etnaviv_obj->vram_list,\n\t\t\t\t obj_node) {\n\t\tstruct etnaviv_iommu_context *context = mapping->context;\n\n\t\tWARN_ON(mapping->use);\n\n\t\tif (context)\n\t\t\tetnaviv_iommu_unmap_gem(context, mapping);\n\n\t\tlist_del(&mapping->obj_node);\n\t\tkfree(mapping);\n\t}\n\n\tetnaviv_obj->ops->release(etnaviv_obj);\n\tdrm_gem_object_release(obj);\n\n\tkfree(etnaviv_obj);\n}\n\nvoid etnaviv_gem_obj_add(struct drm_device *dev, struct drm_gem_object *obj)\n{\n\tstruct etnaviv_drm_private *priv = dev->dev_private;\n\tstruct etnaviv_gem_object *etnaviv_obj = to_etnaviv_bo(obj);\n\n\tmutex_lock(&priv->gem_lock);\n\tlist_add_tail(&etnaviv_obj->gem_node, &priv->gem_list);\n\tmutex_unlock(&priv->gem_lock);\n}\n\nstatic const struct vm_operations_struct vm_ops = {\n\t.fault = etnaviv_gem_fault,\n\t.open = drm_gem_vm_open,\n\t.close = drm_gem_vm_close,\n};\n\nstatic const struct drm_gem_object_funcs etnaviv_gem_object_funcs = {\n\t.free = etnaviv_gem_free_object,\n\t.pin = etnaviv_gem_prime_pin,\n\t.unpin = etnaviv_gem_prime_unpin,\n\t.get_sg_table = etnaviv_gem_prime_get_sg_table,\n\t.vmap = etnaviv_gem_prime_vmap,\n\t.mmap = etnaviv_gem_mmap,\n\t.vm_ops = &vm_ops,\n};\n\nstatic int etnaviv_gem_new_impl(struct drm_device *dev, u32 size, u32 flags,\n\tconst struct etnaviv_gem_ops *ops, struct drm_gem_object **obj)\n{\n\tstruct etnaviv_gem_object *etnaviv_obj;\n\tunsigned sz = sizeof(*etnaviv_obj);\n\tbool valid = true;\n\n\t \n\tswitch (flags & ETNA_BO_CACHE_MASK) {\n\tcase ETNA_BO_UNCACHED:\n\tcase ETNA_BO_CACHED:\n\tcase ETNA_BO_WC:\n\t\tbreak;\n\tdefault:\n\t\tvalid = false;\n\t}\n\n\tif (!valid) {\n\t\tdev_err(dev->dev, \"invalid cache flag: %x\\n\",\n\t\t\t(flags & ETNA_BO_CACHE_MASK));\n\t\treturn -EINVAL;\n\t}\n\n\tetnaviv_obj = kzalloc(sz, GFP_KERNEL);\n\tif (!etnaviv_obj)\n\t\treturn -ENOMEM;\n\n\tetnaviv_obj->flags = flags;\n\tetnaviv_obj->ops = ops;\n\n\tmutex_init(&etnaviv_obj->lock);\n\tINIT_LIST_HEAD(&etnaviv_obj->vram_list);\n\n\t*obj = &etnaviv_obj->base;\n\t(*obj)->funcs = &etnaviv_gem_object_funcs;\n\n\treturn 0;\n}\n\n \nint etnaviv_gem_new_handle(struct drm_device *dev, struct drm_file *file,\n\tu32 size, u32 flags, u32 *handle)\n{\n\tstruct etnaviv_drm_private *priv = dev->dev_private;\n\tstruct drm_gem_object *obj = NULL;\n\tint ret;\n\n\tsize = PAGE_ALIGN(size);\n\n\tret = etnaviv_gem_new_impl(dev, size, flags,\n\t\t\t\t   &etnaviv_gem_shmem_ops, &obj);\n\tif (ret)\n\t\tgoto fail;\n\n\tlockdep_set_class(&to_etnaviv_bo(obj)->lock, &etnaviv_shm_lock_class);\n\n\tret = drm_gem_object_init(dev, obj, size);\n\tif (ret)\n\t\tgoto fail;\n\n\t \n\tmapping_set_gfp_mask(obj->filp->f_mapping, priv->shm_gfp_mask);\n\n\tetnaviv_gem_obj_add(dev, obj);\n\n\tret = drm_gem_handle_create(file, obj, handle);\n\n\t \nfail:\n\tdrm_gem_object_put(obj);\n\n\treturn ret;\n}\n\nint etnaviv_gem_new_private(struct drm_device *dev, size_t size, u32 flags,\n\tconst struct etnaviv_gem_ops *ops, struct etnaviv_gem_object **res)\n{\n\tstruct drm_gem_object *obj;\n\tint ret;\n\n\tret = etnaviv_gem_new_impl(dev, size, flags, ops, &obj);\n\tif (ret)\n\t\treturn ret;\n\n\tdrm_gem_private_object_init(dev, obj, size);\n\n\t*res = to_etnaviv_bo(obj);\n\n\treturn 0;\n}\n\nstatic int etnaviv_gem_userptr_get_pages(struct etnaviv_gem_object *etnaviv_obj)\n{\n\tstruct page **pvec = NULL;\n\tstruct etnaviv_gem_userptr *userptr = &etnaviv_obj->userptr;\n\tint ret, pinned = 0, npages = etnaviv_obj->base.size >> PAGE_SHIFT;\n\tunsigned int gup_flags = FOLL_LONGTERM;\n\n\tmight_lock_read(&current->mm->mmap_lock);\n\n\tif (userptr->mm != current->mm)\n\t\treturn -EPERM;\n\n\tpvec = kvmalloc_array(npages, sizeof(struct page *), GFP_KERNEL);\n\tif (!pvec)\n\t\treturn -ENOMEM;\n\n\tif (!userptr->ro)\n\t\tgup_flags |= FOLL_WRITE;\n\n\tdo {\n\t\tunsigned num_pages = npages - pinned;\n\t\tuint64_t ptr = userptr->ptr + pinned * PAGE_SIZE;\n\t\tstruct page **pages = pvec + pinned;\n\n\t\tret = pin_user_pages_fast(ptr, num_pages, gup_flags, pages);\n\t\tif (ret < 0) {\n\t\t\tunpin_user_pages(pvec, pinned);\n\t\t\tkvfree(pvec);\n\t\t\treturn ret;\n\t\t}\n\n\t\tpinned += ret;\n\n\t} while (pinned < npages);\n\n\tetnaviv_obj->pages = pvec;\n\n\treturn 0;\n}\n\nstatic void etnaviv_gem_userptr_release(struct etnaviv_gem_object *etnaviv_obj)\n{\n\tif (etnaviv_obj->sgt) {\n\t\tetnaviv_gem_scatterlist_unmap(etnaviv_obj);\n\t\tsg_free_table(etnaviv_obj->sgt);\n\t\tkfree(etnaviv_obj->sgt);\n\t}\n\tif (etnaviv_obj->pages) {\n\t\tint npages = etnaviv_obj->base.size >> PAGE_SHIFT;\n\n\t\tunpin_user_pages(etnaviv_obj->pages, npages);\n\t\tkvfree(etnaviv_obj->pages);\n\t}\n}\n\nstatic int etnaviv_gem_userptr_mmap_obj(struct etnaviv_gem_object *etnaviv_obj,\n\t\tstruct vm_area_struct *vma)\n{\n\treturn -EINVAL;\n}\n\nstatic const struct etnaviv_gem_ops etnaviv_gem_userptr_ops = {\n\t.get_pages = etnaviv_gem_userptr_get_pages,\n\t.release = etnaviv_gem_userptr_release,\n\t.vmap = etnaviv_gem_vmap_impl,\n\t.mmap = etnaviv_gem_userptr_mmap_obj,\n};\n\nint etnaviv_gem_new_userptr(struct drm_device *dev, struct drm_file *file,\n\tuintptr_t ptr, u32 size, u32 flags, u32 *handle)\n{\n\tstruct etnaviv_gem_object *etnaviv_obj;\n\tint ret;\n\n\tret = etnaviv_gem_new_private(dev, size, ETNA_BO_CACHED,\n\t\t\t\t      &etnaviv_gem_userptr_ops, &etnaviv_obj);\n\tif (ret)\n\t\treturn ret;\n\n\tlockdep_set_class(&etnaviv_obj->lock, &etnaviv_userptr_lock_class);\n\n\tetnaviv_obj->userptr.ptr = ptr;\n\tetnaviv_obj->userptr.mm = current->mm;\n\tetnaviv_obj->userptr.ro = !(flags & ETNA_USERPTR_WRITE);\n\n\tetnaviv_gem_obj_add(dev, &etnaviv_obj->base);\n\n\tret = drm_gem_handle_create(file, &etnaviv_obj->base, handle);\n\n\t \n\tdrm_gem_object_put(&etnaviv_obj->base);\n\treturn ret;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}