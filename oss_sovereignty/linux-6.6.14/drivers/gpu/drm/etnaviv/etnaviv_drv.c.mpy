{
  "module_name": "etnaviv_drv.c",
  "hash_id": "923105bb936aed54a9394c8e2d41042f19fbdcc35d98c7af5f568a92141fcede",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/etnaviv/etnaviv_drv.c",
  "human_readable_source": "\n \n\n#include <linux/component.h>\n#include <linux/dma-mapping.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/of_device.h>\n#include <linux/platform_device.h>\n#include <linux/uaccess.h>\n\n#include <drm/drm_debugfs.h>\n#include <drm/drm_drv.h>\n#include <drm/drm_file.h>\n#include <drm/drm_ioctl.h>\n#include <drm/drm_of.h>\n#include <drm/drm_prime.h>\n\n#include \"etnaviv_cmdbuf.h\"\n#include \"etnaviv_drv.h\"\n#include \"etnaviv_gpu.h\"\n#include \"etnaviv_gem.h\"\n#include \"etnaviv_mmu.h\"\n#include \"etnaviv_perfmon.h\"\n\n \n\n\nstatic void load_gpu(struct drm_device *dev)\n{\n\tstruct etnaviv_drm_private *priv = dev->dev_private;\n\tunsigned int i;\n\n\tfor (i = 0; i < ETNA_MAX_PIPES; i++) {\n\t\tstruct etnaviv_gpu *g = priv->gpu[i];\n\n\t\tif (g) {\n\t\t\tint ret;\n\n\t\t\tret = etnaviv_gpu_init(g);\n\t\t\tif (ret)\n\t\t\t\tpriv->gpu[i] = NULL;\n\t\t}\n\t}\n}\n\nstatic int etnaviv_open(struct drm_device *dev, struct drm_file *file)\n{\n\tstruct etnaviv_drm_private *priv = dev->dev_private;\n\tstruct etnaviv_file_private *ctx;\n\tint ret, i;\n\n\tctx = kzalloc(sizeof(*ctx), GFP_KERNEL);\n\tif (!ctx)\n\t\treturn -ENOMEM;\n\n\tret = xa_alloc_cyclic(&priv->active_contexts, &ctx->id, ctx,\n\t\t\t      xa_limit_32b, &priv->next_context_id, GFP_KERNEL);\n\tif (ret < 0)\n\t\tgoto out_free;\n\n\tctx->mmu = etnaviv_iommu_context_init(priv->mmu_global,\n\t\t\t\t\t      priv->cmdbuf_suballoc);\n\tif (!ctx->mmu) {\n\t\tret = -ENOMEM;\n\t\tgoto out_free;\n\t}\n\n\tfor (i = 0; i < ETNA_MAX_PIPES; i++) {\n\t\tstruct etnaviv_gpu *gpu = priv->gpu[i];\n\t\tstruct drm_gpu_scheduler *sched;\n\n\t\tif (gpu) {\n\t\t\tsched = &gpu->sched;\n\t\t\tdrm_sched_entity_init(&ctx->sched_entity[i],\n\t\t\t\t\t      DRM_SCHED_PRIORITY_NORMAL, &sched,\n\t\t\t\t\t      1, NULL);\n\t\t\t}\n\t}\n\n\tfile->driver_priv = ctx;\n\n\treturn 0;\n\nout_free:\n\tkfree(ctx);\n\treturn ret;\n}\n\nstatic void etnaviv_postclose(struct drm_device *dev, struct drm_file *file)\n{\n\tstruct etnaviv_drm_private *priv = dev->dev_private;\n\tstruct etnaviv_file_private *ctx = file->driver_priv;\n\tunsigned int i;\n\n\tfor (i = 0; i < ETNA_MAX_PIPES; i++) {\n\t\tstruct etnaviv_gpu *gpu = priv->gpu[i];\n\n\t\tif (gpu)\n\t\t\tdrm_sched_entity_destroy(&ctx->sched_entity[i]);\n\t}\n\n\tetnaviv_iommu_context_put(ctx->mmu);\n\n\txa_erase(&priv->active_contexts, ctx->id);\n\n\tkfree(ctx);\n}\n\n \n\n#ifdef CONFIG_DEBUG_FS\nstatic int etnaviv_gem_show(struct drm_device *dev, struct seq_file *m)\n{\n\tstruct etnaviv_drm_private *priv = dev->dev_private;\n\n\tetnaviv_gem_describe_objects(priv, m);\n\n\treturn 0;\n}\n\nstatic int etnaviv_mm_show(struct drm_device *dev, struct seq_file *m)\n{\n\tstruct drm_printer p = drm_seq_file_printer(m);\n\n\tread_lock(&dev->vma_offset_manager->vm_lock);\n\tdrm_mm_print(&dev->vma_offset_manager->vm_addr_space_mm, &p);\n\tread_unlock(&dev->vma_offset_manager->vm_lock);\n\n\treturn 0;\n}\n\nstatic int etnaviv_mmu_show(struct etnaviv_gpu *gpu, struct seq_file *m)\n{\n\tstruct drm_printer p = drm_seq_file_printer(m);\n\tstruct etnaviv_iommu_context *mmu_context;\n\n\tseq_printf(m, \"Active Objects (%s):\\n\", dev_name(gpu->dev));\n\n\t \n\tmutex_lock(&gpu->lock);\n\tmmu_context = gpu->mmu_context;\n\tif (mmu_context)\n\t\tetnaviv_iommu_context_get(mmu_context);\n\tmutex_unlock(&gpu->lock);\n\n\tif (!mmu_context)\n\t\treturn 0;\n\n\tmutex_lock(&mmu_context->lock);\n\tdrm_mm_print(&mmu_context->mm, &p);\n\tmutex_unlock(&mmu_context->lock);\n\n\tetnaviv_iommu_context_put(mmu_context);\n\n\treturn 0;\n}\n\nstatic void etnaviv_buffer_dump(struct etnaviv_gpu *gpu, struct seq_file *m)\n{\n\tstruct etnaviv_cmdbuf *buf = &gpu->buffer;\n\tu32 size = buf->size;\n\tu32 *ptr = buf->vaddr;\n\tu32 i;\n\n\tseq_printf(m, \"virt %p - phys 0x%llx - free 0x%08x\\n\",\n\t\t\tbuf->vaddr, (u64)etnaviv_cmdbuf_get_pa(buf),\n\t\t\tsize - buf->user_size);\n\n\tfor (i = 0; i < size / 4; i++) {\n\t\tif (i && !(i % 4))\n\t\t\tseq_puts(m, \"\\n\");\n\t\tif (i % 4 == 0)\n\t\t\tseq_printf(m, \"\\t0x%p: \", ptr + i);\n\t\tseq_printf(m, \"%08x \", *(ptr + i));\n\t}\n\tseq_puts(m, \"\\n\");\n}\n\nstatic int etnaviv_ring_show(struct etnaviv_gpu *gpu, struct seq_file *m)\n{\n\tseq_printf(m, \"Ring Buffer (%s): \", dev_name(gpu->dev));\n\n\tmutex_lock(&gpu->lock);\n\tetnaviv_buffer_dump(gpu, m);\n\tmutex_unlock(&gpu->lock);\n\n\treturn 0;\n}\n\nstatic int show_unlocked(struct seq_file *m, void *arg)\n{\n\tstruct drm_info_node *node = (struct drm_info_node *) m->private;\n\tstruct drm_device *dev = node->minor->dev;\n\tint (*show)(struct drm_device *dev, struct seq_file *m) =\n\t\t\tnode->info_ent->data;\n\n\treturn show(dev, m);\n}\n\nstatic int show_each_gpu(struct seq_file *m, void *arg)\n{\n\tstruct drm_info_node *node = (struct drm_info_node *) m->private;\n\tstruct drm_device *dev = node->minor->dev;\n\tstruct etnaviv_drm_private *priv = dev->dev_private;\n\tstruct etnaviv_gpu *gpu;\n\tint (*show)(struct etnaviv_gpu *gpu, struct seq_file *m) =\n\t\t\tnode->info_ent->data;\n\tunsigned int i;\n\tint ret = 0;\n\n\tfor (i = 0; i < ETNA_MAX_PIPES; i++) {\n\t\tgpu = priv->gpu[i];\n\t\tif (!gpu)\n\t\t\tcontinue;\n\n\t\tret = show(gpu, m);\n\t\tif (ret < 0)\n\t\t\tbreak;\n\t}\n\n\treturn ret;\n}\n\nstatic struct drm_info_list etnaviv_debugfs_list[] = {\n\t\t{\"gpu\", show_each_gpu, 0, etnaviv_gpu_debugfs},\n\t\t{\"gem\", show_unlocked, 0, etnaviv_gem_show},\n\t\t{ \"mm\", show_unlocked, 0, etnaviv_mm_show },\n\t\t{\"mmu\", show_each_gpu, 0, etnaviv_mmu_show},\n\t\t{\"ring\", show_each_gpu, 0, etnaviv_ring_show},\n};\n\nstatic void etnaviv_debugfs_init(struct drm_minor *minor)\n{\n\tdrm_debugfs_create_files(etnaviv_debugfs_list,\n\t\t\t\t ARRAY_SIZE(etnaviv_debugfs_list),\n\t\t\t\t minor->debugfs_root, minor);\n}\n#endif\n\n \n\nstatic int etnaviv_ioctl_get_param(struct drm_device *dev, void *data,\n\t\tstruct drm_file *file)\n{\n\tstruct etnaviv_drm_private *priv = dev->dev_private;\n\tstruct drm_etnaviv_param *args = data;\n\tstruct etnaviv_gpu *gpu;\n\n\tif (args->pipe >= ETNA_MAX_PIPES)\n\t\treturn -EINVAL;\n\n\tgpu = priv->gpu[args->pipe];\n\tif (!gpu)\n\t\treturn -ENXIO;\n\n\treturn etnaviv_gpu_get_param(gpu, args->param, &args->value);\n}\n\nstatic int etnaviv_ioctl_gem_new(struct drm_device *dev, void *data,\n\t\tstruct drm_file *file)\n{\n\tstruct drm_etnaviv_gem_new *args = data;\n\n\tif (args->flags & ~(ETNA_BO_CACHED | ETNA_BO_WC | ETNA_BO_UNCACHED |\n\t\t\t    ETNA_BO_FORCE_MMU))\n\t\treturn -EINVAL;\n\n\treturn etnaviv_gem_new_handle(dev, file, args->size,\n\t\t\targs->flags, &args->handle);\n}\n\nstatic int etnaviv_ioctl_gem_cpu_prep(struct drm_device *dev, void *data,\n\t\tstruct drm_file *file)\n{\n\tstruct drm_etnaviv_gem_cpu_prep *args = data;\n\tstruct drm_gem_object *obj;\n\tint ret;\n\n\tif (args->op & ~(ETNA_PREP_READ | ETNA_PREP_WRITE | ETNA_PREP_NOSYNC))\n\t\treturn -EINVAL;\n\n\tobj = drm_gem_object_lookup(file, args->handle);\n\tif (!obj)\n\t\treturn -ENOENT;\n\n\tret = etnaviv_gem_cpu_prep(obj, args->op, &args->timeout);\n\n\tdrm_gem_object_put(obj);\n\n\treturn ret;\n}\n\nstatic int etnaviv_ioctl_gem_cpu_fini(struct drm_device *dev, void *data,\n\t\tstruct drm_file *file)\n{\n\tstruct drm_etnaviv_gem_cpu_fini *args = data;\n\tstruct drm_gem_object *obj;\n\tint ret;\n\n\tif (args->flags)\n\t\treturn -EINVAL;\n\n\tobj = drm_gem_object_lookup(file, args->handle);\n\tif (!obj)\n\t\treturn -ENOENT;\n\n\tret = etnaviv_gem_cpu_fini(obj);\n\n\tdrm_gem_object_put(obj);\n\n\treturn ret;\n}\n\nstatic int etnaviv_ioctl_gem_info(struct drm_device *dev, void *data,\n\t\tstruct drm_file *file)\n{\n\tstruct drm_etnaviv_gem_info *args = data;\n\tstruct drm_gem_object *obj;\n\tint ret;\n\n\tif (args->pad)\n\t\treturn -EINVAL;\n\n\tobj = drm_gem_object_lookup(file, args->handle);\n\tif (!obj)\n\t\treturn -ENOENT;\n\n\tret = etnaviv_gem_mmap_offset(obj, &args->offset);\n\tdrm_gem_object_put(obj);\n\n\treturn ret;\n}\n\nstatic int etnaviv_ioctl_wait_fence(struct drm_device *dev, void *data,\n\t\tstruct drm_file *file)\n{\n\tstruct drm_etnaviv_wait_fence *args = data;\n\tstruct etnaviv_drm_private *priv = dev->dev_private;\n\tstruct drm_etnaviv_timespec *timeout = &args->timeout;\n\tstruct etnaviv_gpu *gpu;\n\n\tif (args->flags & ~(ETNA_WAIT_NONBLOCK))\n\t\treturn -EINVAL;\n\n\tif (args->pipe >= ETNA_MAX_PIPES)\n\t\treturn -EINVAL;\n\n\tgpu = priv->gpu[args->pipe];\n\tif (!gpu)\n\t\treturn -ENXIO;\n\n\tif (args->flags & ETNA_WAIT_NONBLOCK)\n\t\ttimeout = NULL;\n\n\treturn etnaviv_gpu_wait_fence_interruptible(gpu, args->fence,\n\t\t\t\t\t\t    timeout);\n}\n\nstatic int etnaviv_ioctl_gem_userptr(struct drm_device *dev, void *data,\n\tstruct drm_file *file)\n{\n\tstruct drm_etnaviv_gem_userptr *args = data;\n\n\tif (args->flags & ~(ETNA_USERPTR_READ|ETNA_USERPTR_WRITE) ||\n\t    args->flags == 0)\n\t\treturn -EINVAL;\n\n\tif (offset_in_page(args->user_ptr | args->user_size) ||\n\t    (uintptr_t)args->user_ptr != args->user_ptr ||\n\t    (u32)args->user_size != args->user_size ||\n\t    args->user_ptr & ~PAGE_MASK)\n\t\treturn -EINVAL;\n\n\tif (!access_ok((void __user *)(unsigned long)args->user_ptr,\n\t\t       args->user_size))\n\t\treturn -EFAULT;\n\n\treturn etnaviv_gem_new_userptr(dev, file, args->user_ptr,\n\t\t\t\t       args->user_size, args->flags,\n\t\t\t\t       &args->handle);\n}\n\nstatic int etnaviv_ioctl_gem_wait(struct drm_device *dev, void *data,\n\tstruct drm_file *file)\n{\n\tstruct etnaviv_drm_private *priv = dev->dev_private;\n\tstruct drm_etnaviv_gem_wait *args = data;\n\tstruct drm_etnaviv_timespec *timeout = &args->timeout;\n\tstruct drm_gem_object *obj;\n\tstruct etnaviv_gpu *gpu;\n\tint ret;\n\n\tif (args->flags & ~(ETNA_WAIT_NONBLOCK))\n\t\treturn -EINVAL;\n\n\tif (args->pipe >= ETNA_MAX_PIPES)\n\t\treturn -EINVAL;\n\n\tgpu = priv->gpu[args->pipe];\n\tif (!gpu)\n\t\treturn -ENXIO;\n\n\tobj = drm_gem_object_lookup(file, args->handle);\n\tif (!obj)\n\t\treturn -ENOENT;\n\n\tif (args->flags & ETNA_WAIT_NONBLOCK)\n\t\ttimeout = NULL;\n\n\tret = etnaviv_gem_wait_bo(gpu, obj, timeout);\n\n\tdrm_gem_object_put(obj);\n\n\treturn ret;\n}\n\nstatic int etnaviv_ioctl_pm_query_dom(struct drm_device *dev, void *data,\n\tstruct drm_file *file)\n{\n\tstruct etnaviv_drm_private *priv = dev->dev_private;\n\tstruct drm_etnaviv_pm_domain *args = data;\n\tstruct etnaviv_gpu *gpu;\n\n\tif (args->pipe >= ETNA_MAX_PIPES)\n\t\treturn -EINVAL;\n\n\tgpu = priv->gpu[args->pipe];\n\tif (!gpu)\n\t\treturn -ENXIO;\n\n\treturn etnaviv_pm_query_dom(gpu, args);\n}\n\nstatic int etnaviv_ioctl_pm_query_sig(struct drm_device *dev, void *data,\n\tstruct drm_file *file)\n{\n\tstruct etnaviv_drm_private *priv = dev->dev_private;\n\tstruct drm_etnaviv_pm_signal *args = data;\n\tstruct etnaviv_gpu *gpu;\n\n\tif (args->pipe >= ETNA_MAX_PIPES)\n\t\treturn -EINVAL;\n\n\tgpu = priv->gpu[args->pipe];\n\tif (!gpu)\n\t\treturn -ENXIO;\n\n\treturn etnaviv_pm_query_sig(gpu, args);\n}\n\nstatic const struct drm_ioctl_desc etnaviv_ioctls[] = {\n#define ETNA_IOCTL(n, func, flags) \\\n\tDRM_IOCTL_DEF_DRV(ETNAVIV_##n, etnaviv_ioctl_##func, flags)\n\tETNA_IOCTL(GET_PARAM,    get_param,    DRM_RENDER_ALLOW),\n\tETNA_IOCTL(GEM_NEW,      gem_new,      DRM_RENDER_ALLOW),\n\tETNA_IOCTL(GEM_INFO,     gem_info,     DRM_RENDER_ALLOW),\n\tETNA_IOCTL(GEM_CPU_PREP, gem_cpu_prep, DRM_RENDER_ALLOW),\n\tETNA_IOCTL(GEM_CPU_FINI, gem_cpu_fini, DRM_RENDER_ALLOW),\n\tETNA_IOCTL(GEM_SUBMIT,   gem_submit,   DRM_RENDER_ALLOW),\n\tETNA_IOCTL(WAIT_FENCE,   wait_fence,   DRM_RENDER_ALLOW),\n\tETNA_IOCTL(GEM_USERPTR,  gem_userptr,  DRM_RENDER_ALLOW),\n\tETNA_IOCTL(GEM_WAIT,     gem_wait,     DRM_RENDER_ALLOW),\n\tETNA_IOCTL(PM_QUERY_DOM, pm_query_dom, DRM_RENDER_ALLOW),\n\tETNA_IOCTL(PM_QUERY_SIG, pm_query_sig, DRM_RENDER_ALLOW),\n};\n\nDEFINE_DRM_GEM_FOPS(fops);\n\nstatic const struct drm_driver etnaviv_drm_driver = {\n\t.driver_features    = DRIVER_GEM | DRIVER_RENDER,\n\t.open               = etnaviv_open,\n\t.postclose           = etnaviv_postclose,\n\t.gem_prime_import_sg_table = etnaviv_gem_prime_import_sg_table,\n#ifdef CONFIG_DEBUG_FS\n\t.debugfs_init       = etnaviv_debugfs_init,\n#endif\n\t.ioctls             = etnaviv_ioctls,\n\t.num_ioctls         = DRM_ETNAVIV_NUM_IOCTLS,\n\t.fops               = &fops,\n\t.name               = \"etnaviv\",\n\t.desc               = \"etnaviv DRM\",\n\t.date               = \"20151214\",\n\t.major              = 1,\n\t.minor              = 3,\n};\n\n \nstatic int etnaviv_bind(struct device *dev)\n{\n\tstruct etnaviv_drm_private *priv;\n\tstruct drm_device *drm;\n\tint ret;\n\n\tdrm = drm_dev_alloc(&etnaviv_drm_driver, dev);\n\tif (IS_ERR(drm))\n\t\treturn PTR_ERR(drm);\n\n\tpriv = kzalloc(sizeof(*priv), GFP_KERNEL);\n\tif (!priv) {\n\t\tdev_err(dev, \"failed to allocate private data\\n\");\n\t\tret = -ENOMEM;\n\t\tgoto out_put;\n\t}\n\tdrm->dev_private = priv;\n\n\tdma_set_max_seg_size(dev, SZ_2G);\n\n\txa_init_flags(&priv->active_contexts, XA_FLAGS_ALLOC);\n\n\tmutex_init(&priv->gem_lock);\n\tINIT_LIST_HEAD(&priv->gem_list);\n\tpriv->num_gpus = 0;\n\tpriv->shm_gfp_mask = GFP_HIGHUSER | __GFP_RETRY_MAYFAIL | __GFP_NOWARN;\n\n\tpriv->cmdbuf_suballoc = etnaviv_cmdbuf_suballoc_new(drm->dev);\n\tif (IS_ERR(priv->cmdbuf_suballoc)) {\n\t\tdev_err(drm->dev, \"Failed to create cmdbuf suballocator\\n\");\n\t\tret = PTR_ERR(priv->cmdbuf_suballoc);\n\t\tgoto out_free_priv;\n\t}\n\n\tdev_set_drvdata(dev, drm);\n\n\tret = component_bind_all(dev, drm);\n\tif (ret < 0)\n\t\tgoto out_destroy_suballoc;\n\n\tload_gpu(drm);\n\n\tret = drm_dev_register(drm, 0);\n\tif (ret)\n\t\tgoto out_unbind;\n\n\treturn 0;\n\nout_unbind:\n\tcomponent_unbind_all(dev, drm);\nout_destroy_suballoc:\n\tetnaviv_cmdbuf_suballoc_destroy(priv->cmdbuf_suballoc);\nout_free_priv:\n\tkfree(priv);\nout_put:\n\tdrm_dev_put(drm);\n\n\treturn ret;\n}\n\nstatic void etnaviv_unbind(struct device *dev)\n{\n\tstruct drm_device *drm = dev_get_drvdata(dev);\n\tstruct etnaviv_drm_private *priv = drm->dev_private;\n\n\tdrm_dev_unregister(drm);\n\n\tcomponent_unbind_all(dev, drm);\n\n\tetnaviv_cmdbuf_suballoc_destroy(priv->cmdbuf_suballoc);\n\n\txa_destroy(&priv->active_contexts);\n\n\tdrm->dev_private = NULL;\n\tkfree(priv);\n\n\tdrm_dev_put(drm);\n}\n\nstatic const struct component_master_ops etnaviv_master_ops = {\n\t.bind = etnaviv_bind,\n\t.unbind = etnaviv_unbind,\n};\n\nstatic int etnaviv_pdev_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct device_node *first_node = NULL;\n\tstruct component_match *match = NULL;\n\n\tif (!dev->platform_data) {\n\t\tstruct device_node *core_node;\n\n\t\tfor_each_compatible_node(core_node, NULL, \"vivante,gc\") {\n\t\t\tif (!of_device_is_available(core_node))\n\t\t\t\tcontinue;\n\n\t\t\tif (!first_node)\n\t\t\t\tfirst_node = core_node;\n\n\t\t\tdrm_of_component_match_add(&pdev->dev, &match,\n\t\t\t\t\t\t   component_compare_of, core_node);\n\t\t}\n\t} else {\n\t\tchar **names = dev->platform_data;\n\t\tunsigned i;\n\n\t\tfor (i = 0; names[i]; i++)\n\t\t\tcomponent_match_add(dev, &match, component_compare_dev_name, names[i]);\n\t}\n\n\t \n\tif (dma_set_mask(&pdev->dev, DMA_BIT_MASK(40)) ||\n\t    dma_set_coherent_mask(&pdev->dev, DMA_BIT_MASK(32))) {\n\t\tdev_dbg(&pdev->dev, \"No suitable DMA available\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\t \n\tif (first_node)\n\t\tof_dma_configure(&pdev->dev, first_node, true);\n\n\treturn component_master_add_with_match(dev, &etnaviv_master_ops, match);\n}\n\nstatic int etnaviv_pdev_remove(struct platform_device *pdev)\n{\n\tcomponent_master_del(&pdev->dev, &etnaviv_master_ops);\n\n\treturn 0;\n}\n\nstatic struct platform_driver etnaviv_platform_driver = {\n\t.probe      = etnaviv_pdev_probe,\n\t.remove     = etnaviv_pdev_remove,\n\t.driver     = {\n\t\t.name   = \"etnaviv\",\n\t},\n};\n\nstatic struct platform_device *etnaviv_drm;\n\nstatic int __init etnaviv_init(void)\n{\n\tstruct platform_device *pdev;\n\tint ret;\n\tstruct device_node *np;\n\n\tetnaviv_validate_init();\n\n\tret = platform_driver_register(&etnaviv_gpu_driver);\n\tif (ret != 0)\n\t\treturn ret;\n\n\tret = platform_driver_register(&etnaviv_platform_driver);\n\tif (ret != 0)\n\t\tgoto unregister_gpu_driver;\n\n\t \n\tfor_each_compatible_node(np, NULL, \"vivante,gc\") {\n\t\tif (!of_device_is_available(np))\n\t\t\tcontinue;\n\n\t\tpdev = platform_device_alloc(\"etnaviv\", PLATFORM_DEVID_NONE);\n\t\tif (!pdev) {\n\t\t\tret = -ENOMEM;\n\t\t\tof_node_put(np);\n\t\t\tgoto unregister_platform_driver;\n\t\t}\n\n\t\tret = platform_device_add(pdev);\n\t\tif (ret) {\n\t\t\tplatform_device_put(pdev);\n\t\t\tof_node_put(np);\n\t\t\tgoto unregister_platform_driver;\n\t\t}\n\n\t\tetnaviv_drm = pdev;\n\t\tof_node_put(np);\n\t\tbreak;\n\t}\n\n\treturn 0;\n\nunregister_platform_driver:\n\tplatform_driver_unregister(&etnaviv_platform_driver);\nunregister_gpu_driver:\n\tplatform_driver_unregister(&etnaviv_gpu_driver);\n\treturn ret;\n}\nmodule_init(etnaviv_init);\n\nstatic void __exit etnaviv_exit(void)\n{\n\tplatform_device_unregister(etnaviv_drm);\n\tplatform_driver_unregister(&etnaviv_platform_driver);\n\tplatform_driver_unregister(&etnaviv_gpu_driver);\n}\nmodule_exit(etnaviv_exit);\n\nMODULE_AUTHOR(\"Christian Gmeiner <christian.gmeiner@gmail.com>\");\nMODULE_AUTHOR(\"Russell King <rmk+kernel@armlinux.org.uk>\");\nMODULE_AUTHOR(\"Lucas Stach <l.stach@pengutronix.de>\");\nMODULE_DESCRIPTION(\"etnaviv DRM Driver\");\nMODULE_LICENSE(\"GPL v2\");\nMODULE_ALIAS(\"platform:etnaviv\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}