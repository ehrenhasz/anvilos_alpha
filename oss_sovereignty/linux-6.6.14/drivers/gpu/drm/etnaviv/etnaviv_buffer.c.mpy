{
  "module_name": "etnaviv_buffer.c",
  "hash_id": "53c959c8bc6eb1225d87b834f16a3c6441630cd1bf0e10bf7d8425b53c27ff9e",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/etnaviv/etnaviv_buffer.c",
  "human_readable_source": "\n \n\n#include <drm/drm_drv.h>\n\n#include \"etnaviv_cmdbuf.h\"\n#include \"etnaviv_gpu.h\"\n#include \"etnaviv_gem.h\"\n#include \"etnaviv_mmu.h\"\n\n#include \"common.xml.h\"\n#include \"state.xml.h\"\n#include \"state_blt.xml.h\"\n#include \"state_hi.xml.h\"\n#include \"state_3d.xml.h\"\n#include \"cmdstream.xml.h\"\n\n \n\n\nstatic inline void OUT(struct etnaviv_cmdbuf *buffer, u32 data)\n{\n\tu32 *vaddr = (u32 *)buffer->vaddr;\n\n\tBUG_ON(buffer->user_size >= buffer->size);\n\n\tvaddr[buffer->user_size / 4] = data;\n\tbuffer->user_size += 4;\n}\n\nstatic inline void CMD_LOAD_STATE(struct etnaviv_cmdbuf *buffer,\n\tu32 reg, u32 value)\n{\n\tu32 index = reg >> VIV_FE_LOAD_STATE_HEADER_OFFSET__SHR;\n\n\tbuffer->user_size = ALIGN(buffer->user_size, 8);\n\n\t \n\tOUT(buffer, VIV_FE_LOAD_STATE_HEADER_OP_LOAD_STATE |\n\t\t    VIV_FE_LOAD_STATE_HEADER_COUNT(1) |\n\t\t    VIV_FE_LOAD_STATE_HEADER_OFFSET(index));\n\tOUT(buffer, value);\n}\n\nstatic inline void CMD_END(struct etnaviv_cmdbuf *buffer)\n{\n\tbuffer->user_size = ALIGN(buffer->user_size, 8);\n\n\tOUT(buffer, VIV_FE_END_HEADER_OP_END);\n}\n\nstatic inline void CMD_WAIT(struct etnaviv_cmdbuf *buffer,\n\t\t\t    unsigned int waitcycles)\n{\n\tbuffer->user_size = ALIGN(buffer->user_size, 8);\n\n\tOUT(buffer, VIV_FE_WAIT_HEADER_OP_WAIT | waitcycles);\n}\n\nstatic inline void CMD_LINK(struct etnaviv_cmdbuf *buffer,\n\tu16 prefetch, u32 address)\n{\n\tbuffer->user_size = ALIGN(buffer->user_size, 8);\n\n\tOUT(buffer, VIV_FE_LINK_HEADER_OP_LINK |\n\t\t    VIV_FE_LINK_HEADER_PREFETCH(prefetch));\n\tOUT(buffer, address);\n}\n\nstatic inline void CMD_STALL(struct etnaviv_cmdbuf *buffer,\n\tu32 from, u32 to)\n{\n\tbuffer->user_size = ALIGN(buffer->user_size, 8);\n\n\tOUT(buffer, VIV_FE_STALL_HEADER_OP_STALL);\n\tOUT(buffer, VIV_FE_STALL_TOKEN_FROM(from) | VIV_FE_STALL_TOKEN_TO(to));\n}\n\nstatic inline void CMD_SEM(struct etnaviv_cmdbuf *buffer, u32 from, u32 to)\n{\n\tCMD_LOAD_STATE(buffer, VIVS_GL_SEMAPHORE_TOKEN,\n\t\t       VIVS_GL_SEMAPHORE_TOKEN_FROM(from) |\n\t\t       VIVS_GL_SEMAPHORE_TOKEN_TO(to));\n}\n\nstatic void etnaviv_cmd_select_pipe(struct etnaviv_gpu *gpu,\n\tstruct etnaviv_cmdbuf *buffer, u8 pipe)\n{\n\tu32 flush = 0;\n\n\tlockdep_assert_held(&gpu->lock);\n\n\t \n\tif (gpu->exec_state == ETNA_PIPE_2D)\n\t\tflush = VIVS_GL_FLUSH_CACHE_PE2D;\n\telse if (gpu->exec_state == ETNA_PIPE_3D)\n\t\tflush = VIVS_GL_FLUSH_CACHE_DEPTH | VIVS_GL_FLUSH_CACHE_COLOR;\n\n\tCMD_LOAD_STATE(buffer, VIVS_GL_FLUSH_CACHE, flush);\n\tCMD_SEM(buffer, SYNC_RECIPIENT_FE, SYNC_RECIPIENT_PE);\n\tCMD_STALL(buffer, SYNC_RECIPIENT_FE, SYNC_RECIPIENT_PE);\n\n\tCMD_LOAD_STATE(buffer, VIVS_GL_PIPE_SELECT,\n\t\t       VIVS_GL_PIPE_SELECT_PIPE(pipe));\n}\n\nstatic void etnaviv_buffer_dump(struct etnaviv_gpu *gpu,\n\tstruct etnaviv_cmdbuf *buf, u32 off, u32 len)\n{\n\tu32 size = buf->size;\n\tu32 *ptr = buf->vaddr + off;\n\n\tdev_info(gpu->dev, \"virt %p phys 0x%08x free 0x%08x\\n\",\n\t\t\tptr, etnaviv_cmdbuf_get_va(buf,\n\t\t\t&gpu->mmu_context->cmdbuf_mapping) +\n\t\t\toff, size - len * 4 - off);\n\n\tprint_hex_dump(KERN_INFO, \"cmd \", DUMP_PREFIX_OFFSET, 16, 4,\n\t\t\tptr, len * 4, 0);\n}\n\n \nstatic void etnaviv_buffer_replace_wait(struct etnaviv_cmdbuf *buffer,\n\tunsigned int wl_offset, u32 cmd, u32 arg)\n{\n\tu32 *lw = buffer->vaddr + wl_offset;\n\n\tlw[1] = arg;\n\tmb();\n\tlw[0] = cmd;\n\tmb();\n}\n\n \nstatic u32 etnaviv_buffer_reserve(struct etnaviv_gpu *gpu,\n\tstruct etnaviv_cmdbuf *buffer, unsigned int cmd_dwords)\n{\n\tif (buffer->user_size + cmd_dwords * sizeof(u64) > buffer->size)\n\t\tbuffer->user_size = 0;\n\n\treturn etnaviv_cmdbuf_get_va(buffer,\n\t\t\t\t     &gpu->mmu_context->cmdbuf_mapping) +\n\t       buffer->user_size;\n}\n\nu16 etnaviv_buffer_init(struct etnaviv_gpu *gpu)\n{\n\tstruct etnaviv_cmdbuf *buffer = &gpu->buffer;\n\n\tlockdep_assert_held(&gpu->lock);\n\n\t \n\tbuffer->user_size = 0;\n\n\tCMD_WAIT(buffer, gpu->fe_waitcycles);\n\tCMD_LINK(buffer, 2,\n\t\t etnaviv_cmdbuf_get_va(buffer, &gpu->mmu_context->cmdbuf_mapping)\n\t\t + buffer->user_size - 4);\n\n\treturn buffer->user_size / 8;\n}\n\nu16 etnaviv_buffer_config_mmuv2(struct etnaviv_gpu *gpu, u32 mtlb_addr, u32 safe_addr)\n{\n\tstruct etnaviv_cmdbuf *buffer = &gpu->buffer;\n\n\tlockdep_assert_held(&gpu->lock);\n\n\tbuffer->user_size = 0;\n\n\tif (gpu->identity.features & chipFeatures_PIPE_3D) {\n\t\tCMD_LOAD_STATE(buffer, VIVS_GL_PIPE_SELECT,\n\t\t\t       VIVS_GL_PIPE_SELECT_PIPE(ETNA_PIPE_3D));\n\t\tCMD_LOAD_STATE(buffer, VIVS_MMUv2_CONFIGURATION,\n\t\t\tmtlb_addr | VIVS_MMUv2_CONFIGURATION_MODE_MODE4_K);\n\t\tCMD_LOAD_STATE(buffer, VIVS_MMUv2_SAFE_ADDRESS, safe_addr);\n\t\tCMD_SEM(buffer, SYNC_RECIPIENT_FE, SYNC_RECIPIENT_PE);\n\t\tCMD_STALL(buffer, SYNC_RECIPIENT_FE, SYNC_RECIPIENT_PE);\n\t}\n\n\tif (gpu->identity.features & chipFeatures_PIPE_2D) {\n\t\tCMD_LOAD_STATE(buffer, VIVS_GL_PIPE_SELECT,\n\t\t\t       VIVS_GL_PIPE_SELECT_PIPE(ETNA_PIPE_2D));\n\t\tCMD_LOAD_STATE(buffer, VIVS_MMUv2_CONFIGURATION,\n\t\t\tmtlb_addr | VIVS_MMUv2_CONFIGURATION_MODE_MODE4_K);\n\t\tCMD_LOAD_STATE(buffer, VIVS_MMUv2_SAFE_ADDRESS, safe_addr);\n\t\tCMD_SEM(buffer, SYNC_RECIPIENT_FE, SYNC_RECIPIENT_PE);\n\t\tCMD_STALL(buffer, SYNC_RECIPIENT_FE, SYNC_RECIPIENT_PE);\n\t}\n\n\tCMD_END(buffer);\n\n\tbuffer->user_size = ALIGN(buffer->user_size, 8);\n\n\treturn buffer->user_size / 8;\n}\n\nu16 etnaviv_buffer_config_pta(struct etnaviv_gpu *gpu, unsigned short id)\n{\n\tstruct etnaviv_cmdbuf *buffer = &gpu->buffer;\n\n\tlockdep_assert_held(&gpu->lock);\n\n\tbuffer->user_size = 0;\n\n\tCMD_LOAD_STATE(buffer, VIVS_MMUv2_PTA_CONFIG,\n\t\t       VIVS_MMUv2_PTA_CONFIG_INDEX(id));\n\n\tCMD_END(buffer);\n\n\tbuffer->user_size = ALIGN(buffer->user_size, 8);\n\n\treturn buffer->user_size / 8;\n}\n\nvoid etnaviv_buffer_end(struct etnaviv_gpu *gpu)\n{\n\tstruct etnaviv_cmdbuf *buffer = &gpu->buffer;\n\tunsigned int waitlink_offset = buffer->user_size - 16;\n\tu32 link_target, flush = 0;\n\tbool has_blt = !!(gpu->identity.minor_features5 &\n\t\t\t  chipMinorFeatures5_BLT_ENGINE);\n\n\tlockdep_assert_held(&gpu->lock);\n\n\tif (gpu->exec_state == ETNA_PIPE_2D)\n\t\tflush = VIVS_GL_FLUSH_CACHE_PE2D;\n\telse if (gpu->exec_state == ETNA_PIPE_3D)\n\t\tflush = VIVS_GL_FLUSH_CACHE_DEPTH |\n\t\t\tVIVS_GL_FLUSH_CACHE_COLOR |\n\t\t\tVIVS_GL_FLUSH_CACHE_TEXTURE |\n\t\t\tVIVS_GL_FLUSH_CACHE_TEXTUREVS |\n\t\t\tVIVS_GL_FLUSH_CACHE_SHADER_L2;\n\n\tif (flush) {\n\t\tunsigned int dwords = 7;\n\n\t\tif (has_blt)\n\t\t\tdwords += 10;\n\n\t\tlink_target = etnaviv_buffer_reserve(gpu, buffer, dwords);\n\n\t\tCMD_SEM(buffer, SYNC_RECIPIENT_FE, SYNC_RECIPIENT_PE);\n\t\tCMD_STALL(buffer, SYNC_RECIPIENT_FE, SYNC_RECIPIENT_PE);\n\t\tif (has_blt) {\n\t\t\tCMD_LOAD_STATE(buffer, VIVS_BLT_ENABLE, 0x1);\n\t\t\tCMD_SEM(buffer, SYNC_RECIPIENT_FE, SYNC_RECIPIENT_BLT);\n\t\t\tCMD_STALL(buffer, SYNC_RECIPIENT_FE, SYNC_RECIPIENT_BLT);\n\t\t\tCMD_LOAD_STATE(buffer, VIVS_BLT_ENABLE, 0x0);\n\t\t}\n\t\tCMD_LOAD_STATE(buffer, VIVS_GL_FLUSH_CACHE, flush);\n\t\tif (gpu->exec_state == ETNA_PIPE_3D) {\n\t\t\tif (has_blt) {\n\t\t\t\tCMD_LOAD_STATE(buffer, VIVS_BLT_ENABLE, 0x1);\n\t\t\t\tCMD_LOAD_STATE(buffer, VIVS_BLT_SET_COMMAND, 0x1);\n\t\t\t\tCMD_LOAD_STATE(buffer, VIVS_BLT_ENABLE, 0x0);\n\t\t\t} else {\n\t\t\t\tCMD_LOAD_STATE(buffer, VIVS_TS_FLUSH_CACHE,\n\t\t\t\t\t       VIVS_TS_FLUSH_CACHE_FLUSH);\n\t\t\t}\n\t\t}\n\t\tCMD_SEM(buffer, SYNC_RECIPIENT_FE, SYNC_RECIPIENT_PE);\n\t\tCMD_STALL(buffer, SYNC_RECIPIENT_FE, SYNC_RECIPIENT_PE);\n\t\tif (has_blt) {\n\t\t\tCMD_LOAD_STATE(buffer, VIVS_BLT_ENABLE, 0x1);\n\t\t\tCMD_SEM(buffer, SYNC_RECIPIENT_FE, SYNC_RECIPIENT_BLT);\n\t\t\tCMD_STALL(buffer, SYNC_RECIPIENT_FE, SYNC_RECIPIENT_BLT);\n\t\t\tCMD_LOAD_STATE(buffer, VIVS_BLT_ENABLE, 0x0);\n\t\t}\n\t\tCMD_END(buffer);\n\n\t\tetnaviv_buffer_replace_wait(buffer, waitlink_offset,\n\t\t\t\t\t    VIV_FE_LINK_HEADER_OP_LINK |\n\t\t\t\t\t    VIV_FE_LINK_HEADER_PREFETCH(dwords),\n\t\t\t\t\t    link_target);\n\t} else {\n\t\t \n\t\tetnaviv_buffer_replace_wait(buffer, waitlink_offset,\n\t\t\t\t\t    VIV_FE_END_HEADER_OP_END, 0);\n\t}\n}\n\n \nvoid etnaviv_sync_point_queue(struct etnaviv_gpu *gpu, unsigned int event)\n{\n\tstruct etnaviv_cmdbuf *buffer = &gpu->buffer;\n\tunsigned int waitlink_offset = buffer->user_size - 16;\n\tu32 dwords, target;\n\n\tlockdep_assert_held(&gpu->lock);\n\n\t \n\tdwords = 4;\n\ttarget = etnaviv_buffer_reserve(gpu, buffer, dwords);\n\n\t \n\tCMD_LOAD_STATE(buffer, VIVS_GL_EVENT, VIVS_GL_EVENT_EVENT_ID(event) |\n\t\t       VIVS_GL_EVENT_FROM_PE);\n\n\t \n\tCMD_END(buffer);\n\n\t \n\tCMD_WAIT(buffer, gpu->fe_waitcycles);\n\tCMD_LINK(buffer, 2,\n\t\t etnaviv_cmdbuf_get_va(buffer, &gpu->mmu_context->cmdbuf_mapping)\n\t\t + buffer->user_size - 4);\n\n\t \n\tetnaviv_buffer_replace_wait(buffer, waitlink_offset,\n\t\t\t\t    VIV_FE_LINK_HEADER_OP_LINK |\n\t\t\t\t    VIV_FE_LINK_HEADER_PREFETCH(dwords),\n\t\t\t\t    target);\n}\n\n \nvoid etnaviv_buffer_queue(struct etnaviv_gpu *gpu, u32 exec_state,\n\tstruct etnaviv_iommu_context *mmu_context, unsigned int event,\n\tstruct etnaviv_cmdbuf *cmdbuf)\n{\n\tstruct etnaviv_cmdbuf *buffer = &gpu->buffer;\n\tunsigned int waitlink_offset = buffer->user_size - 16;\n\tu32 return_target, return_dwords;\n\tu32 link_target, link_dwords;\n\tbool switch_context = gpu->exec_state != exec_state;\n\tbool switch_mmu_context = gpu->mmu_context != mmu_context;\n\tunsigned int new_flush_seq = READ_ONCE(gpu->mmu_context->flush_seq);\n\tbool need_flush = switch_mmu_context || gpu->flush_seq != new_flush_seq;\n\tbool has_blt = !!(gpu->identity.minor_features5 &\n\t\t\t  chipMinorFeatures5_BLT_ENGINE);\n\n\tlockdep_assert_held(&gpu->lock);\n\n\tif (drm_debug_enabled(DRM_UT_DRIVER))\n\t\tetnaviv_buffer_dump(gpu, buffer, 0, 0x50);\n\n\tlink_target = etnaviv_cmdbuf_get_va(cmdbuf,\n\t\t\t\t\t    &gpu->mmu_context->cmdbuf_mapping);\n\tlink_dwords = cmdbuf->size / 8;\n\n\t \n\tif (need_flush || switch_context) {\n\t\tu32 target, extra_dwords;\n\n\t\t \n\t\textra_dwords = 1;\n\n\t\t \n\t\tif (need_flush) {\n\t\t\tif (gpu->mmu_context->global->version == ETNAVIV_IOMMU_V1)\n\t\t\t\textra_dwords += 1;\n\t\t\telse\n\t\t\t\textra_dwords += 3;\n\t\t}\n\n\t\t \n\t\tif (switch_context)\n\t\t\textra_dwords += 4;\n\n\t\t \n\t\tif (switch_mmu_context && gpu->sec_mode == ETNA_SEC_KERNEL)\n\t\t\textra_dwords += 1;\n\n\t\ttarget = etnaviv_buffer_reserve(gpu, buffer, extra_dwords);\n\t\t \n\t\tif (switch_mmu_context) {\n\t\t\tstruct etnaviv_iommu_context *old_context = gpu->mmu_context;\n\n\t\t\tgpu->mmu_context = etnaviv_iommu_context_get(mmu_context);\n\t\t\tetnaviv_iommu_context_put(old_context);\n\t\t}\n\n\t\tif (need_flush) {\n\t\t\t \n\t\t\tif (gpu->mmu_context->global->version == ETNAVIV_IOMMU_V1) {\n\t\t\t\tCMD_LOAD_STATE(buffer, VIVS_GL_FLUSH_MMU,\n\t\t\t\t\t       VIVS_GL_FLUSH_MMU_FLUSH_FEMMU |\n\t\t\t\t\t       VIVS_GL_FLUSH_MMU_FLUSH_UNK1 |\n\t\t\t\t\t       VIVS_GL_FLUSH_MMU_FLUSH_UNK2 |\n\t\t\t\t\t       VIVS_GL_FLUSH_MMU_FLUSH_PEMMU |\n\t\t\t\t\t       VIVS_GL_FLUSH_MMU_FLUSH_UNK4);\n\t\t\t} else {\n\t\t\t\tu32 flush = VIVS_MMUv2_CONFIGURATION_MODE_MASK |\n\t\t\t\t\t    VIVS_MMUv2_CONFIGURATION_FLUSH_FLUSH;\n\n\t\t\t\tif (switch_mmu_context &&\n\t\t\t\t    gpu->sec_mode == ETNA_SEC_KERNEL) {\n\t\t\t\t\tunsigned short id =\n\t\t\t\t\t\tetnaviv_iommuv2_get_pta_id(gpu->mmu_context);\n\t\t\t\t\tCMD_LOAD_STATE(buffer,\n\t\t\t\t\t\tVIVS_MMUv2_PTA_CONFIG,\n\t\t\t\t\t\tVIVS_MMUv2_PTA_CONFIG_INDEX(id));\n\t\t\t\t}\n\n\t\t\t\tif (gpu->sec_mode == ETNA_SEC_NONE)\n\t\t\t\t\tflush |= etnaviv_iommuv2_get_mtlb_addr(gpu->mmu_context);\n\n\t\t\t\tCMD_LOAD_STATE(buffer, VIVS_MMUv2_CONFIGURATION,\n\t\t\t\t\t       flush);\n\t\t\t\tCMD_SEM(buffer, SYNC_RECIPIENT_FE,\n\t\t\t\t\tSYNC_RECIPIENT_PE);\n\t\t\t\tCMD_STALL(buffer, SYNC_RECIPIENT_FE,\n\t\t\t\t\tSYNC_RECIPIENT_PE);\n\t\t\t}\n\n\t\t\tgpu->flush_seq = new_flush_seq;\n\t\t}\n\n\t\tif (switch_context) {\n\t\t\tetnaviv_cmd_select_pipe(gpu, buffer, exec_state);\n\t\t\tgpu->exec_state = exec_state;\n\t\t}\n\n\t\t \n\t\tlink_target = etnaviv_cmdbuf_get_va(cmdbuf,\n\t\t\t\t\t&gpu->mmu_context->cmdbuf_mapping);\n\t\tCMD_LINK(buffer, link_dwords, link_target);\n\n\t\t \n\t\tlink_target = target;\n\t\tlink_dwords = extra_dwords;\n\t}\n\n\t \n\treturn_dwords = 7;\n\n\t \n\tif (has_blt)\n\t\treturn_dwords += 6;\n\n\treturn_target = etnaviv_buffer_reserve(gpu, buffer, return_dwords);\n\tCMD_LINK(cmdbuf, return_dwords, return_target);\n\n\t \n\tif (gpu->exec_state == ETNA_PIPE_2D) {\n\t\tCMD_LOAD_STATE(buffer, VIVS_GL_FLUSH_CACHE,\n\t\t\t\t       VIVS_GL_FLUSH_CACHE_PE2D);\n\t} else {\n\t\tCMD_LOAD_STATE(buffer, VIVS_GL_FLUSH_CACHE,\n\t\t\t\t       VIVS_GL_FLUSH_CACHE_DEPTH |\n\t\t\t\t       VIVS_GL_FLUSH_CACHE_COLOR);\n\t\tif (has_blt) {\n\t\t\tCMD_LOAD_STATE(buffer, VIVS_BLT_ENABLE, 0x1);\n\t\t\tCMD_LOAD_STATE(buffer, VIVS_BLT_SET_COMMAND, 0x1);\n\t\t\tCMD_LOAD_STATE(buffer, VIVS_BLT_ENABLE, 0x0);\n\t\t} else {\n\t\t\tCMD_LOAD_STATE(buffer, VIVS_TS_FLUSH_CACHE,\n\t\t\t\t\t       VIVS_TS_FLUSH_CACHE_FLUSH);\n\t\t}\n\t}\n\tCMD_SEM(buffer, SYNC_RECIPIENT_FE, SYNC_RECIPIENT_PE);\n\tCMD_STALL(buffer, SYNC_RECIPIENT_FE, SYNC_RECIPIENT_PE);\n\n\tif (has_blt) {\n\t\tCMD_LOAD_STATE(buffer, VIVS_BLT_ENABLE, 0x1);\n\t\tCMD_SEM(buffer, SYNC_RECIPIENT_FE, SYNC_RECIPIENT_BLT);\n\t\tCMD_STALL(buffer, SYNC_RECIPIENT_FE, SYNC_RECIPIENT_BLT);\n\t\tCMD_LOAD_STATE(buffer, VIVS_BLT_ENABLE, 0x0);\n\t}\n\n\tCMD_LOAD_STATE(buffer, VIVS_GL_EVENT, VIVS_GL_EVENT_EVENT_ID(event) |\n\t\t       VIVS_GL_EVENT_FROM_PE);\n\tCMD_WAIT(buffer, gpu->fe_waitcycles);\n\tCMD_LINK(buffer, 2,\n\t\t etnaviv_cmdbuf_get_va(buffer, &gpu->mmu_context->cmdbuf_mapping)\n\t\t + buffer->user_size - 4);\n\n\tif (drm_debug_enabled(DRM_UT_DRIVER))\n\t\tpr_info(\"stream link to 0x%08x @ 0x%08x %p\\n\",\n\t\t\treturn_target,\n\t\t\tetnaviv_cmdbuf_get_va(cmdbuf, &gpu->mmu_context->cmdbuf_mapping),\n\t\t\tcmdbuf->vaddr);\n\n\tif (drm_debug_enabled(DRM_UT_DRIVER)) {\n\t\tprint_hex_dump(KERN_INFO, \"cmd \", DUMP_PREFIX_OFFSET, 16, 4,\n\t\t\t       cmdbuf->vaddr, cmdbuf->size, 0);\n\n\t\tpr_info(\"link op: %p\\n\", buffer->vaddr + waitlink_offset);\n\t\tpr_info(\"addr: 0x%08x\\n\", link_target);\n\t\tpr_info(\"back: 0x%08x\\n\", return_target);\n\t\tpr_info(\"event: %d\\n\", event);\n\t}\n\n\t \n\tetnaviv_buffer_replace_wait(buffer, waitlink_offset,\n\t\t\t\t    VIV_FE_LINK_HEADER_OP_LINK |\n\t\t\t\t    VIV_FE_LINK_HEADER_PREFETCH(link_dwords),\n\t\t\t\t    link_target);\n\n\tif (drm_debug_enabled(DRM_UT_DRIVER))\n\t\tetnaviv_buffer_dump(gpu, buffer, 0, 0x50);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}