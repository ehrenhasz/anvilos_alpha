{
  "module_name": "etnaviv_dump.c",
  "hash_id": "0a7ea2aa60f5a073559bffcf6fa76ee87a4bfbb54e8821a125f0c9970bea892f",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/etnaviv/etnaviv_dump.c",
  "human_readable_source": "\n \n\n#include <linux/devcoredump.h>\n#include <linux/moduleparam.h>\n\n#include \"etnaviv_cmdbuf.h\"\n#include \"etnaviv_dump.h\"\n#include \"etnaviv_gem.h\"\n#include \"etnaviv_gpu.h\"\n#include \"etnaviv_mmu.h\"\n#include \"etnaviv_sched.h\"\n#include \"state.xml.h\"\n#include \"state_hi.xml.h\"\n\nstatic bool etnaviv_dump_core = true;\nmodule_param_named(dump_core, etnaviv_dump_core, bool, 0600);\n\nstruct core_dump_iterator {\n\tvoid *start;\n\tstruct etnaviv_dump_object_header *hdr;\n\tvoid *data;\n};\n\nstatic const unsigned short etnaviv_dump_registers[] = {\n\tVIVS_HI_AXI_STATUS,\n\tVIVS_HI_CLOCK_CONTROL,\n\tVIVS_HI_IDLE_STATE,\n\tVIVS_HI_AXI_CONFIG,\n\tVIVS_HI_INTR_ENBL,\n\tVIVS_HI_CHIP_IDENTITY,\n\tVIVS_HI_CHIP_FEATURE,\n\tVIVS_HI_CHIP_MODEL,\n\tVIVS_HI_CHIP_REV,\n\tVIVS_HI_CHIP_DATE,\n\tVIVS_HI_CHIP_TIME,\n\tVIVS_HI_CHIP_MINOR_FEATURE_0,\n\tVIVS_HI_CACHE_CONTROL,\n\tVIVS_HI_AXI_CONTROL,\n\tVIVS_PM_POWER_CONTROLS,\n\tVIVS_PM_MODULE_CONTROLS,\n\tVIVS_PM_MODULE_STATUS,\n\tVIVS_PM_PULSE_EATER,\n\tVIVS_MC_MMU_FE_PAGE_TABLE,\n\tVIVS_MC_MMU_TX_PAGE_TABLE,\n\tVIVS_MC_MMU_PE_PAGE_TABLE,\n\tVIVS_MC_MMU_PEZ_PAGE_TABLE,\n\tVIVS_MC_MMU_RA_PAGE_TABLE,\n\tVIVS_MC_DEBUG_MEMORY,\n\tVIVS_MC_MEMORY_BASE_ADDR_RA,\n\tVIVS_MC_MEMORY_BASE_ADDR_FE,\n\tVIVS_MC_MEMORY_BASE_ADDR_TX,\n\tVIVS_MC_MEMORY_BASE_ADDR_PEZ,\n\tVIVS_MC_MEMORY_BASE_ADDR_PE,\n\tVIVS_MC_MEMORY_TIMING_CONTROL,\n\tVIVS_MC_BUS_CONFIG,\n\tVIVS_FE_DMA_STATUS,\n\tVIVS_FE_DMA_DEBUG_STATE,\n\tVIVS_FE_DMA_ADDRESS,\n\tVIVS_FE_DMA_LOW,\n\tVIVS_FE_DMA_HIGH,\n\tVIVS_FE_AUTO_FLUSH,\n};\n\nstatic void etnaviv_core_dump_header(struct core_dump_iterator *iter,\n\tu32 type, void *data_end)\n{\n\tstruct etnaviv_dump_object_header *hdr = iter->hdr;\n\n\thdr->magic = cpu_to_le32(ETDUMP_MAGIC);\n\thdr->type = cpu_to_le32(type);\n\thdr->file_offset = cpu_to_le32(iter->data - iter->start);\n\thdr->file_size = cpu_to_le32(data_end - iter->data);\n\n\titer->hdr++;\n\titer->data += le32_to_cpu(hdr->file_size);\n}\n\nstatic void etnaviv_core_dump_registers(struct core_dump_iterator *iter,\n\tstruct etnaviv_gpu *gpu)\n{\n\tstruct etnaviv_dump_registers *reg = iter->data;\n\tunsigned int i;\n\tu32 read_addr;\n\n\tfor (i = 0; i < ARRAY_SIZE(etnaviv_dump_registers); i++, reg++) {\n\t\tread_addr = etnaviv_dump_registers[i];\n\t\tif (read_addr >= VIVS_PM_POWER_CONTROLS &&\n\t\t    read_addr <= VIVS_PM_PULSE_EATER)\n\t\t\tread_addr = gpu_fix_power_address(gpu, read_addr);\n\t\treg->reg = cpu_to_le32(etnaviv_dump_registers[i]);\n\t\treg->value = cpu_to_le32(gpu_read(gpu, read_addr));\n\t}\n\n\tetnaviv_core_dump_header(iter, ETDUMP_BUF_REG, reg);\n}\n\nstatic void etnaviv_core_dump_mmu(struct core_dump_iterator *iter,\n\tstruct etnaviv_iommu_context *mmu, size_t mmu_size)\n{\n\tetnaviv_iommu_dump(mmu, iter->data);\n\n\tetnaviv_core_dump_header(iter, ETDUMP_BUF_MMU, iter->data + mmu_size);\n}\n\nstatic void etnaviv_core_dump_mem(struct core_dump_iterator *iter, u32 type,\n\tvoid *ptr, size_t size, u64 iova)\n{\n\tmemcpy(iter->data, ptr, size);\n\n\titer->hdr->iova = cpu_to_le64(iova);\n\n\tetnaviv_core_dump_header(iter, type, iter->data + size);\n}\n\nvoid etnaviv_core_dump(struct etnaviv_gem_submit *submit)\n{\n\tstruct etnaviv_gpu *gpu = submit->gpu;\n\tstruct core_dump_iterator iter;\n\tstruct etnaviv_gem_object *obj;\n\tunsigned int n_obj, n_bomap_pages;\n\tsize_t file_size, mmu_size;\n\t__le64 *bomap, *bomap_start;\n\tint i;\n\n\t \n\tif (!etnaviv_dump_core)\n\t\treturn;\n\tetnaviv_dump_core = false;\n\n\tmutex_lock(&submit->mmu_context->lock);\n\n\tmmu_size = etnaviv_iommu_dump_size(submit->mmu_context);\n\n\t \n\tn_obj = 5;\n\tn_bomap_pages = 0;\n\tfile_size = ARRAY_SIZE(etnaviv_dump_registers) *\n\t\t\tsizeof(struct etnaviv_dump_registers) +\n\t\t    mmu_size + gpu->buffer.size + submit->cmdbuf.size;\n\n\t \n\tfor (i = 0; i < submit->nr_bos; i++) {\n\t\tobj = submit->bos[i].obj;\n\t\tfile_size += obj->base.size;\n\t\tn_bomap_pages += obj->base.size >> PAGE_SHIFT;\n\t\tn_obj++;\n\t}\n\n\t \n\tif (n_bomap_pages) {\n\t\tfile_size += n_bomap_pages * sizeof(__le64);\n\t\tn_obj++;\n\t}\n\n\t \n\tfile_size += sizeof(*iter.hdr) * n_obj;\n\n\t \n\titer.start = __vmalloc(file_size, GFP_KERNEL | __GFP_NOWARN |\n\t\t\t__GFP_NORETRY);\n\tif (!iter.start) {\n\t\tmutex_unlock(&submit->mmu_context->lock);\n\t\tdev_warn(gpu->dev, \"failed to allocate devcoredump file\\n\");\n\t\treturn;\n\t}\n\n\t \n\titer.hdr = iter.start;\n\titer.data = &iter.hdr[n_obj];\n\n\tmemset(iter.hdr, 0, iter.data - iter.start);\n\n\tetnaviv_core_dump_registers(&iter, gpu);\n\tetnaviv_core_dump_mmu(&iter, submit->mmu_context, mmu_size);\n\tetnaviv_core_dump_mem(&iter, ETDUMP_BUF_RING, gpu->buffer.vaddr,\n\t\t\t      gpu->buffer.size,\n\t\t\t      etnaviv_cmdbuf_get_va(&gpu->buffer,\n\t\t\t\t\t&submit->mmu_context->cmdbuf_mapping));\n\n\tetnaviv_core_dump_mem(&iter, ETDUMP_BUF_CMD,\n\t\t\t      submit->cmdbuf.vaddr, submit->cmdbuf.size,\n\t\t\t      etnaviv_cmdbuf_get_va(&submit->cmdbuf,\n\t\t\t\t\t&submit->mmu_context->cmdbuf_mapping));\n\n\tmutex_unlock(&submit->mmu_context->lock);\n\n\t \n\tif (n_bomap_pages) {\n\t\tbomap_start = bomap = iter.data;\n\t\tmemset(bomap, 0, sizeof(*bomap) * n_bomap_pages);\n\t\tetnaviv_core_dump_header(&iter, ETDUMP_BUF_BOMAP,\n\t\t\t\t\t bomap + n_bomap_pages);\n\t} else {\n\t\t \n\t\tbomap_start = bomap = NULL;\n\t}\n\n\tfor (i = 0; i < submit->nr_bos; i++) {\n\t\tstruct etnaviv_vram_mapping *vram;\n\t\tstruct page **pages;\n\t\tvoid *vaddr;\n\n\t\tobj = submit->bos[i].obj;\n\t\tvram = submit->bos[i].mapping;\n\n\t\tmutex_lock(&obj->lock);\n\t\tpages = etnaviv_gem_get_pages(obj);\n\t\tmutex_unlock(&obj->lock);\n\t\tif (!IS_ERR(pages)) {\n\t\t\tint j;\n\n\t\t\titer.hdr->data[0] = cpu_to_le32((bomap - bomap_start));\n\n\t\t\tfor (j = 0; j < obj->base.size >> PAGE_SHIFT; j++)\n\t\t\t\t*bomap++ = cpu_to_le64(page_to_phys(*pages++));\n\t\t}\n\n\t\titer.hdr->iova = cpu_to_le64(vram->iova);\n\n\t\tvaddr = etnaviv_gem_vmap(&obj->base);\n\t\tif (vaddr)\n\t\t\tmemcpy(iter.data, vaddr, obj->base.size);\n\n\t\tetnaviv_core_dump_header(&iter, ETDUMP_BUF_BO, iter.data +\n\t\t\t\t\t obj->base.size);\n\t}\n\n\tetnaviv_core_dump_header(&iter, ETDUMP_BUF_END, iter.data);\n\n\tdev_coredumpv(gpu->dev, iter.start, iter.data - iter.start, GFP_KERNEL);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}