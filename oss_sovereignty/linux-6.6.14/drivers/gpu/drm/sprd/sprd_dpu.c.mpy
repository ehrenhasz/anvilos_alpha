{
  "module_name": "sprd_dpu.c",
  "hash_id": "19dee15a0263d20464114f1c7645e658266bf6d002f05accdc9fe0f0cc4729f6",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/sprd/sprd_dpu.c",
  "human_readable_source": "\n \n\n#include <linux/component.h>\n#include <linux/delay.h>\n#include <linux/dma-buf.h>\n#include <linux/io.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/of_graph.h>\n#include <linux/platform_device.h>\n#include <linux/wait.h>\n#include <linux/workqueue.h>\n\n#include <drm/drm_atomic_helper.h>\n#include <drm/drm_blend.h>\n#include <drm/drm_fb_dma_helper.h>\n#include <drm/drm_framebuffer.h>\n#include <drm/drm_gem_dma_helper.h>\n#include <drm/drm_gem_framebuffer_helper.h>\n\n#include \"sprd_drm.h\"\n#include \"sprd_dpu.h\"\n#include \"sprd_dsi.h\"\n\n \n#define REG_DPU_CTRL\t0x04\n#define REG_DPU_CFG0\t0x08\n#define REG_PANEL_SIZE\t0x20\n#define REG_BLEND_SIZE\t0x24\n#define REG_BG_COLOR\t0x2C\n\n \n#define REG_LAY_BASE_ADDR0\t0x30\n#define REG_LAY_BASE_ADDR1\t0x34\n#define REG_LAY_BASE_ADDR2\t0x38\n#define REG_LAY_CTRL\t\t0x40\n#define REG_LAY_SIZE\t\t0x44\n#define REG_LAY_PITCH\t\t0x48\n#define REG_LAY_POS\t\t0x4C\n#define REG_LAY_ALPHA\t\t0x50\n#define REG_LAY_CROP_START\t0x5C\n\n \n#define REG_DPU_INT_EN\t\t0x1E0\n#define REG_DPU_INT_CLR\t\t0x1E4\n#define REG_DPU_INT_STS\t\t0x1E8\n\n \n#define REG_DPI_CTRL\t\t0x1F0\n#define REG_DPI_H_TIMING\t0x1F4\n#define REG_DPI_V_TIMING\t0x1F8\n\n \n#define REG_MMU_EN\t\t\t0x800\n#define REG_MMU_VPN_RANGE\t\t0x80C\n#define REG_MMU_PPN1\t\t\t0x83C\n#define REG_MMU_RANGE1\t\t\t0x840\n#define REG_MMU_PPN2\t\t\t0x844\n#define REG_MMU_RANGE2\t\t\t0x848\n\n \n#define BIT_DPU_RUN\t\t\tBIT(0)\n#define BIT_DPU_STOP\t\t\tBIT(1)\n#define BIT_DPU_REG_UPDATE\t\tBIT(2)\n#define BIT_DPU_IF_EDPI\t\t\tBIT(0)\n\n \n#define BIT_DPU_LAY_EN\t\t\t\tBIT(0)\n#define BIT_DPU_LAY_LAYER_ALPHA\t\t\t(0x01 << 2)\n#define BIT_DPU_LAY_COMBO_ALPHA\t\t\t(0x02 << 2)\n#define BIT_DPU_LAY_FORMAT_YUV422_2PLANE\t\t(0x00 << 4)\n#define BIT_DPU_LAY_FORMAT_YUV420_2PLANE\t\t(0x01 << 4)\n#define BIT_DPU_LAY_FORMAT_YUV420_3PLANE\t\t(0x02 << 4)\n#define BIT_DPU_LAY_FORMAT_ARGB8888\t\t\t(0x03 << 4)\n#define BIT_DPU_LAY_FORMAT_RGB565\t\t\t(0x04 << 4)\n#define BIT_DPU_LAY_DATA_ENDIAN_B0B1B2B3\t\t(0x00 << 8)\n#define BIT_DPU_LAY_DATA_ENDIAN_B3B2B1B0\t\t(0x01 << 8)\n#define BIT_DPU_LAY_NO_SWITCH\t\t\t(0x00 << 10)\n#define BIT_DPU_LAY_RB_OR_UV_SWITCH\t\t(0x01 << 10)\n#define BIT_DPU_LAY_MODE_BLEND_NORMAL\t\t(0x00 << 16)\n#define BIT_DPU_LAY_MODE_BLEND_PREMULT\t\t(0x01 << 16)\n#define BIT_DPU_LAY_ROTATION_0\t\t(0x00 << 20)\n#define BIT_DPU_LAY_ROTATION_90\t\t(0x01 << 20)\n#define BIT_DPU_LAY_ROTATION_180\t(0x02 << 20)\n#define BIT_DPU_LAY_ROTATION_270\t(0x03 << 20)\n#define BIT_DPU_LAY_ROTATION_0_M\t(0x04 << 20)\n#define BIT_DPU_LAY_ROTATION_90_M\t(0x05 << 20)\n#define BIT_DPU_LAY_ROTATION_180_M\t(0x06 << 20)\n#define BIT_DPU_LAY_ROTATION_270_M\t(0x07 << 20)\n\n \n#define BIT_DPU_INT_DONE\t\tBIT(0)\n#define BIT_DPU_INT_TE\t\t\tBIT(1)\n#define BIT_DPU_INT_ERR\t\t\tBIT(2)\n#define BIT_DPU_INT_UPDATE_DONE\t\tBIT(4)\n#define BIT_DPU_INT_VSYNC\t\tBIT(5)\n\n \n#define BIT_DPU_EDPI_TE_EN\t\tBIT(8)\n#define BIT_DPU_EDPI_FROM_EXTERNAL_PAD\tBIT(10)\n#define BIT_DPU_DPI_HALT_EN\t\tBIT(16)\n\nstatic const u32 layer_fmts[] = {\n\tDRM_FORMAT_XRGB8888,\n\tDRM_FORMAT_XBGR8888,\n\tDRM_FORMAT_ARGB8888,\n\tDRM_FORMAT_ABGR8888,\n\tDRM_FORMAT_RGBA8888,\n\tDRM_FORMAT_BGRA8888,\n\tDRM_FORMAT_RGBX8888,\n\tDRM_FORMAT_RGB565,\n\tDRM_FORMAT_BGR565,\n\tDRM_FORMAT_NV12,\n\tDRM_FORMAT_NV21,\n\tDRM_FORMAT_NV16,\n\tDRM_FORMAT_NV61,\n\tDRM_FORMAT_YUV420,\n\tDRM_FORMAT_YVU420,\n};\n\nstruct sprd_plane {\n\tstruct drm_plane base;\n};\n\nstatic int dpu_wait_stop_done(struct sprd_dpu *dpu)\n{\n\tstruct dpu_context *ctx = &dpu->ctx;\n\tint rc;\n\n\tif (ctx->stopped)\n\t\treturn 0;\n\n\trc = wait_event_interruptible_timeout(ctx->wait_queue, ctx->evt_stop,\n\t\t\t\t\t      msecs_to_jiffies(500));\n\tctx->evt_stop = false;\n\n\tctx->stopped = true;\n\n\tif (!rc) {\n\t\tdrm_err(dpu->drm, \"dpu wait for stop done time out!\\n\");\n\t\treturn -ETIMEDOUT;\n\t}\n\n\treturn 0;\n}\n\nstatic int dpu_wait_update_done(struct sprd_dpu *dpu)\n{\n\tstruct dpu_context *ctx = &dpu->ctx;\n\tint rc;\n\n\tctx->evt_update = false;\n\n\trc = wait_event_interruptible_timeout(ctx->wait_queue, ctx->evt_update,\n\t\t\t\t\t      msecs_to_jiffies(500));\n\n\tif (!rc) {\n\t\tdrm_err(dpu->drm, \"dpu wait for reg update done time out!\\n\");\n\t\treturn -ETIMEDOUT;\n\t}\n\n\treturn 0;\n}\n\nstatic u32 drm_format_to_dpu(struct drm_framebuffer *fb)\n{\n\tu32 format = 0;\n\n\tswitch (fb->format->format) {\n\tcase DRM_FORMAT_BGRA8888:\n\t\t \n\t\tformat |= BIT_DPU_LAY_DATA_ENDIAN_B3B2B1B0;\n\t\tformat |= BIT_DPU_LAY_FORMAT_ARGB8888;\n\t\tbreak;\n\tcase DRM_FORMAT_RGBX8888:\n\tcase DRM_FORMAT_RGBA8888:\n\t\t \n\t\tformat |= BIT_DPU_LAY_DATA_ENDIAN_B3B2B1B0;\n\t\tfallthrough;\n\tcase DRM_FORMAT_ABGR8888:\n\t\t \n\t\tformat |= BIT_DPU_LAY_RB_OR_UV_SWITCH;\n\t\tfallthrough;\n\tcase DRM_FORMAT_ARGB8888:\n\t\tformat |= BIT_DPU_LAY_FORMAT_ARGB8888;\n\t\tbreak;\n\tcase DRM_FORMAT_XBGR8888:\n\t\t \n\t\tformat |= BIT_DPU_LAY_RB_OR_UV_SWITCH;\n\t\tfallthrough;\n\tcase DRM_FORMAT_XRGB8888:\n\t\tformat |= BIT_DPU_LAY_FORMAT_ARGB8888;\n\t\tbreak;\n\tcase DRM_FORMAT_BGR565:\n\t\t \n\t\tformat |= BIT_DPU_LAY_RB_OR_UV_SWITCH;\n\t\tfallthrough;\n\tcase DRM_FORMAT_RGB565:\n\t\tformat |= BIT_DPU_LAY_FORMAT_RGB565;\n\t\tbreak;\n\tcase DRM_FORMAT_NV12:\n\t\t \n\t\tformat |= BIT_DPU_LAY_FORMAT_YUV420_2PLANE;\n\t\t \n\t\tformat |= BIT_DPU_LAY_DATA_ENDIAN_B0B1B2B3;\n\t\t \n\t\tformat |= BIT_DPU_LAY_NO_SWITCH;\n\t\tbreak;\n\tcase DRM_FORMAT_NV21:\n\t\t \n\t\tformat |= BIT_DPU_LAY_FORMAT_YUV420_2PLANE;\n\t\t \n\t\tformat |= BIT_DPU_LAY_DATA_ENDIAN_B0B1B2B3;\n\t\t \n\t\tformat |= BIT_DPU_LAY_RB_OR_UV_SWITCH;\n\t\tbreak;\n\tcase DRM_FORMAT_NV16:\n\t\t \n\t\tformat |= BIT_DPU_LAY_FORMAT_YUV422_2PLANE;\n\t\t \n\t\tformat |= BIT_DPU_LAY_DATA_ENDIAN_B3B2B1B0;\n\t\t \n\t\tformat |= BIT_DPU_LAY_RB_OR_UV_SWITCH;\n\t\tbreak;\n\tcase DRM_FORMAT_NV61:\n\t\t \n\t\tformat |= BIT_DPU_LAY_FORMAT_YUV422_2PLANE;\n\t\t \n\t\tformat |= BIT_DPU_LAY_DATA_ENDIAN_B0B1B2B3;\n\t\t \n\t\tformat |= BIT_DPU_LAY_NO_SWITCH;\n\t\tbreak;\n\tcase DRM_FORMAT_YUV420:\n\t\tformat |= BIT_DPU_LAY_FORMAT_YUV420_3PLANE;\n\t\t \n\t\tformat |= BIT_DPU_LAY_DATA_ENDIAN_B0B1B2B3;\n\t\t \n\t\tformat |= BIT_DPU_LAY_NO_SWITCH;\n\t\tbreak;\n\tcase DRM_FORMAT_YVU420:\n\t\tformat |= BIT_DPU_LAY_FORMAT_YUV420_3PLANE;\n\t\t \n\t\tformat |= BIT_DPU_LAY_DATA_ENDIAN_B0B1B2B3;\n\t\t \n\t\tformat |= BIT_DPU_LAY_RB_OR_UV_SWITCH;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn format;\n}\n\nstatic u32 drm_rotation_to_dpu(struct drm_plane_state *state)\n{\n\tu32 rotation = 0;\n\n\tswitch (state->rotation) {\n\tdefault:\n\tcase DRM_MODE_ROTATE_0:\n\t\trotation = BIT_DPU_LAY_ROTATION_0;\n\t\tbreak;\n\tcase DRM_MODE_ROTATE_90:\n\t\trotation = BIT_DPU_LAY_ROTATION_90;\n\t\tbreak;\n\tcase DRM_MODE_ROTATE_180:\n\t\trotation = BIT_DPU_LAY_ROTATION_180;\n\t\tbreak;\n\tcase DRM_MODE_ROTATE_270:\n\t\trotation = BIT_DPU_LAY_ROTATION_270;\n\t\tbreak;\n\tcase DRM_MODE_REFLECT_Y:\n\t\trotation = BIT_DPU_LAY_ROTATION_180_M;\n\t\tbreak;\n\tcase (DRM_MODE_REFLECT_Y | DRM_MODE_ROTATE_90):\n\t\trotation = BIT_DPU_LAY_ROTATION_90_M;\n\t\tbreak;\n\tcase DRM_MODE_REFLECT_X:\n\t\trotation = BIT_DPU_LAY_ROTATION_0_M;\n\t\tbreak;\n\tcase (DRM_MODE_REFLECT_X | DRM_MODE_ROTATE_90):\n\t\trotation = BIT_DPU_LAY_ROTATION_270_M;\n\t\tbreak;\n\t}\n\n\treturn rotation;\n}\n\nstatic u32 drm_blend_to_dpu(struct drm_plane_state *state)\n{\n\tu32 blend = 0;\n\n\tswitch (state->pixel_blend_mode) {\n\tcase DRM_MODE_BLEND_COVERAGE:\n\t\t \n\t\tblend |= BIT_DPU_LAY_COMBO_ALPHA;\n\t\t \n\t\tblend |= BIT_DPU_LAY_MODE_BLEND_NORMAL;\n\t\tbreak;\n\tcase DRM_MODE_BLEND_PREMULTI:\n\t\t \n\t\tblend |= BIT_DPU_LAY_COMBO_ALPHA;\n\t\t \n\t\tblend |= BIT_DPU_LAY_MODE_BLEND_PREMULT;\n\t\tbreak;\n\tcase DRM_MODE_BLEND_PIXEL_NONE:\n\tdefault:\n\t\t \n\t\t \n\t\tblend |= BIT_DPU_LAY_LAYER_ALPHA;\n\t\tbreak;\n\t}\n\n\treturn blend;\n}\n\nstatic void sprd_dpu_layer(struct sprd_dpu *dpu, struct drm_plane_state *state)\n{\n\tstruct dpu_context *ctx = &dpu->ctx;\n\tstruct drm_gem_dma_object *dma_obj;\n\tstruct drm_framebuffer *fb = state->fb;\n\tu32 addr, size, offset, pitch, blend, format, rotation;\n\tu32 src_x = state->src_x >> 16;\n\tu32 src_y = state->src_y >> 16;\n\tu32 src_w = state->src_w >> 16;\n\tu32 src_h = state->src_h >> 16;\n\tu32 dst_x = state->crtc_x;\n\tu32 dst_y = state->crtc_y;\n\tu32 alpha = state->alpha;\n\tu32 index = state->zpos;\n\tint i;\n\n\toffset = (dst_x & 0xffff) | (dst_y << 16);\n\tsize = (src_w & 0xffff) | (src_h << 16);\n\n\tfor (i = 0; i < fb->format->num_planes; i++) {\n\t\tdma_obj = drm_fb_dma_get_gem_obj(fb, i);\n\t\taddr = dma_obj->dma_addr + fb->offsets[i];\n\n\t\tif (i == 0)\n\t\t\tlayer_reg_wr(ctx, REG_LAY_BASE_ADDR0, addr, index);\n\t\telse if (i == 1)\n\t\t\tlayer_reg_wr(ctx, REG_LAY_BASE_ADDR1, addr, index);\n\t\telse\n\t\t\tlayer_reg_wr(ctx, REG_LAY_BASE_ADDR2, addr, index);\n\t}\n\n\tif (fb->format->num_planes == 3) {\n\t\t \n\t\tpitch = (fb->pitches[0] / fb->format->cpp[0]) |\n\t\t\t\t(fb->pitches[0] / fb->format->cpp[0] << 15);\n\t} else {\n\t\tpitch = fb->pitches[0] / fb->format->cpp[0];\n\t}\n\n\tlayer_reg_wr(ctx, REG_LAY_POS, offset, index);\n\tlayer_reg_wr(ctx, REG_LAY_SIZE, size, index);\n\tlayer_reg_wr(ctx, REG_LAY_CROP_START,\n\t\t     src_y << 16 | src_x, index);\n\tlayer_reg_wr(ctx, REG_LAY_ALPHA, alpha, index);\n\tlayer_reg_wr(ctx, REG_LAY_PITCH, pitch, index);\n\n\tformat = drm_format_to_dpu(fb);\n\tblend = drm_blend_to_dpu(state);\n\trotation = drm_rotation_to_dpu(state);\n\n\tlayer_reg_wr(ctx, REG_LAY_CTRL, BIT_DPU_LAY_EN |\n\t\t\t\tformat |\n\t\t\t\tblend |\n\t\t\t\trotation,\n\t\t\t\tindex);\n}\n\nstatic void sprd_dpu_flip(struct sprd_dpu *dpu)\n{\n\tstruct dpu_context *ctx = &dpu->ctx;\n\n\t \n\tif (ctx->if_type == SPRD_DPU_IF_EDPI)\n\t\tdpu_wait_stop_done(dpu);\n\n\t \n\tif (ctx->if_type == SPRD_DPU_IF_DPI) {\n\t\tif (!ctx->stopped) {\n\t\t\tdpu_reg_set(ctx, REG_DPU_CTRL, BIT_DPU_REG_UPDATE);\n\t\t\tdpu_wait_update_done(dpu);\n\t\t}\n\n\t\tdpu_reg_set(ctx, REG_DPU_INT_EN, BIT_DPU_INT_ERR);\n\t} else if (ctx->if_type == SPRD_DPU_IF_EDPI) {\n\t\tdpu_reg_set(ctx, REG_DPU_CTRL, BIT_DPU_RUN);\n\n\t\tctx->stopped = false;\n\t}\n}\n\nstatic void sprd_dpu_init(struct sprd_dpu *dpu)\n{\n\tstruct dpu_context *ctx = &dpu->ctx;\n\tu32 int_mask = 0;\n\n\twritel(0x00, ctx->base + REG_BG_COLOR);\n\twritel(0x00, ctx->base + REG_MMU_EN);\n\twritel(0x00, ctx->base + REG_MMU_PPN1);\n\twritel(0xffff, ctx->base + REG_MMU_RANGE1);\n\twritel(0x00, ctx->base + REG_MMU_PPN2);\n\twritel(0xffff, ctx->base + REG_MMU_RANGE2);\n\twritel(0x1ffff, ctx->base + REG_MMU_VPN_RANGE);\n\n\tif (ctx->if_type == SPRD_DPU_IF_DPI) {\n\t\t \n\t\tdpu_reg_clr(ctx, REG_DPU_CFG0, BIT_DPU_IF_EDPI);\n\t\t \n\t\tdpu_reg_clr(ctx, REG_DPI_CTRL, BIT_DPU_DPI_HALT_EN);\n\t\t \n\t\tdpu_reg_set(ctx, REG_DPI_CTRL, BIT_DPU_EDPI_FROM_EXTERNAL_PAD);\n\n\t\t \n\t\tint_mask |= BIT_DPU_INT_UPDATE_DONE;\n\t\t \n\t\tint_mask |= BIT_DPU_INT_DONE;\n\t\t \n\t\tint_mask |= BIT_DPU_INT_VSYNC;\n\t\t \n\t\tint_mask |= BIT_DPU_INT_TE;\n\t\t \n\t\tint_mask |= BIT_DPU_INT_ERR;\n\t} else if (ctx->if_type == SPRD_DPU_IF_EDPI) {\n\t\t \n\t\tdpu_reg_set(ctx, REG_DPU_CFG0, BIT_DPU_IF_EDPI);\n\t\t \n\t\tdpu_reg_set(ctx, REG_DPI_CTRL, BIT_DPU_EDPI_FROM_EXTERNAL_PAD);\n\t\t \n\t\tdpu_reg_set(ctx, REG_DPI_CTRL, BIT_DPU_EDPI_TE_EN);\n\n\t\t \n\t\tint_mask |= BIT_DPU_INT_DONE;\n\t\t \n\t\tint_mask |= BIT_DPU_INT_TE;\n\t}\n\n\twritel(int_mask, ctx->base + REG_DPU_INT_EN);\n}\n\nstatic void sprd_dpu_fini(struct sprd_dpu *dpu)\n{\n\tstruct dpu_context *ctx = &dpu->ctx;\n\n\twritel(0x00, ctx->base + REG_DPU_INT_EN);\n\twritel(0xff, ctx->base + REG_DPU_INT_CLR);\n}\n\nstatic void sprd_dpi_init(struct sprd_dpu *dpu)\n{\n\tstruct dpu_context *ctx = &dpu->ctx;\n\tu32 reg_val;\n\tu32 size;\n\n\tsize = (ctx->vm.vactive << 16) | ctx->vm.hactive;\n\twritel(size, ctx->base + REG_PANEL_SIZE);\n\twritel(size, ctx->base + REG_BLEND_SIZE);\n\n\tif (ctx->if_type == SPRD_DPU_IF_DPI) {\n\t\t \n\t\treg_val = ctx->vm.hsync_len << 0 |\n\t\t\t  ctx->vm.hback_porch << 8 |\n\t\t\t  ctx->vm.hfront_porch << 20;\n\t\twritel(reg_val, ctx->base + REG_DPI_H_TIMING);\n\n\t\treg_val = ctx->vm.vsync_len << 0 |\n\t\t\t  ctx->vm.vback_porch << 8 |\n\t\t\t  ctx->vm.vfront_porch << 20;\n\t\twritel(reg_val, ctx->base + REG_DPI_V_TIMING);\n\t}\n}\n\nvoid sprd_dpu_run(struct sprd_dpu *dpu)\n{\n\tstruct dpu_context *ctx = &dpu->ctx;\n\n\tdpu_reg_set(ctx, REG_DPU_CTRL, BIT_DPU_RUN);\n\n\tctx->stopped = false;\n}\n\nvoid sprd_dpu_stop(struct sprd_dpu *dpu)\n{\n\tstruct dpu_context *ctx = &dpu->ctx;\n\n\tif (ctx->if_type == SPRD_DPU_IF_DPI)\n\t\tdpu_reg_set(ctx, REG_DPU_CTRL, BIT_DPU_STOP);\n\n\tdpu_wait_stop_done(dpu);\n}\n\nstatic int sprd_plane_atomic_check(struct drm_plane *plane,\n\t\t\t\t   struct drm_atomic_state *state)\n{\n\tstruct drm_plane_state *plane_state = drm_atomic_get_new_plane_state(state,\n\t\t\t\t\t\t\t\t\t     plane);\n\tstruct drm_crtc_state *crtc_state;\n\tu32 fmt;\n\n\tif (!plane_state->fb || !plane_state->crtc)\n\t\treturn 0;\n\n\tfmt = drm_format_to_dpu(plane_state->fb);\n\tif (!fmt)\n\t\treturn -EINVAL;\n\n\tcrtc_state = drm_atomic_get_crtc_state(plane_state->state, plane_state->crtc);\n\tif (IS_ERR(crtc_state))\n\t\treturn PTR_ERR(crtc_state);\n\n\treturn drm_atomic_helper_check_plane_state(plane_state, crtc_state,\n\t\t\t\t\t\t  DRM_PLANE_NO_SCALING,\n\t\t\t\t\t\t  DRM_PLANE_NO_SCALING,\n\t\t\t\t\t\t  true, true);\n}\n\nstatic void sprd_plane_atomic_update(struct drm_plane *drm_plane,\n\t\t\t\t     struct drm_atomic_state *state)\n{\n\tstruct drm_plane_state *new_state = drm_atomic_get_new_plane_state(state,\n\t\t\t\t\t\t\t\t\t   drm_plane);\n\tstruct sprd_dpu *dpu = to_sprd_crtc(new_state->crtc);\n\n\t \n\tsprd_dpu_layer(dpu, new_state);\n}\n\nstatic void sprd_plane_atomic_disable(struct drm_plane *drm_plane,\n\t\t\t\t      struct drm_atomic_state *state)\n{\n\tstruct drm_plane_state *old_state = drm_atomic_get_old_plane_state(state,\n\t\t\t\t\t\t\t\t\t   drm_plane);\n\tstruct sprd_dpu *dpu = to_sprd_crtc(old_state->crtc);\n\n\tlayer_reg_wr(&dpu->ctx, REG_LAY_CTRL, 0x00, old_state->zpos);\n}\n\nstatic void sprd_plane_create_properties(struct sprd_plane *plane, int index)\n{\n\tunsigned int supported_modes = BIT(DRM_MODE_BLEND_PIXEL_NONE) |\n\t\t\t\t       BIT(DRM_MODE_BLEND_PREMULTI) |\n\t\t\t\t       BIT(DRM_MODE_BLEND_COVERAGE);\n\n\t \n\tdrm_plane_create_rotation_property(&plane->base,\n\t\t\t\t\t   DRM_MODE_ROTATE_0,\n\t\t\t\t\t   DRM_MODE_ROTATE_MASK |\n\t\t\t\t\t   DRM_MODE_REFLECT_MASK);\n\n\t \n\tdrm_plane_create_alpha_property(&plane->base);\n\n\t \n\tdrm_plane_create_blend_mode_property(&plane->base, supported_modes);\n\n\t \n\tdrm_plane_create_zpos_immutable_property(&plane->base, index);\n}\n\nstatic const struct drm_plane_helper_funcs sprd_plane_helper_funcs = {\n\t.atomic_check = sprd_plane_atomic_check,\n\t.atomic_update = sprd_plane_atomic_update,\n\t.atomic_disable = sprd_plane_atomic_disable,\n};\n\nstatic const struct drm_plane_funcs sprd_plane_funcs = {\n\t.update_plane = drm_atomic_helper_update_plane,\n\t.disable_plane\t= drm_atomic_helper_disable_plane,\n\t.destroy = drm_plane_cleanup,\n\t.reset = drm_atomic_helper_plane_reset,\n\t.atomic_duplicate_state = drm_atomic_helper_plane_duplicate_state,\n\t.atomic_destroy_state = drm_atomic_helper_plane_destroy_state,\n};\n\nstatic struct sprd_plane *sprd_planes_init(struct drm_device *drm)\n{\n\tstruct sprd_plane *plane, *primary;\n\tenum drm_plane_type plane_type;\n\tint i;\n\n\tfor (i = 0; i < 6; i++) {\n\t\tplane_type = (i == 0) ? DRM_PLANE_TYPE_PRIMARY :\n\t\t\t\t\tDRM_PLANE_TYPE_OVERLAY;\n\n\t\tplane = drmm_universal_plane_alloc(drm, struct sprd_plane, base,\n\t\t\t\t\t\t   1, &sprd_plane_funcs,\n\t\t\t\t\t\t   layer_fmts, ARRAY_SIZE(layer_fmts),\n\t\t\t\t\t\t   NULL, plane_type, NULL);\n\t\tif (IS_ERR(plane)) {\n\t\t\tdrm_err(drm, \"failed to init drm plane: %d\\n\", i);\n\t\t\treturn plane;\n\t\t}\n\n\t\tdrm_plane_helper_add(&plane->base, &sprd_plane_helper_funcs);\n\n\t\tsprd_plane_create_properties(plane, i);\n\n\t\tif (i == 0)\n\t\t\tprimary = plane;\n\t}\n\n\treturn primary;\n}\n\nstatic void sprd_crtc_mode_set_nofb(struct drm_crtc *crtc)\n{\n\tstruct sprd_dpu *dpu = to_sprd_crtc(crtc);\n\tstruct drm_display_mode *mode = &crtc->state->adjusted_mode;\n\tstruct drm_encoder *encoder;\n\tstruct sprd_dsi *dsi;\n\n\tdrm_display_mode_to_videomode(mode, &dpu->ctx.vm);\n\n\tdrm_for_each_encoder_mask(encoder, crtc->dev,\n\t\t\t\t  crtc->state->encoder_mask) {\n\t\tdsi = encoder_to_dsi(encoder);\n\n\t\tif (dsi->slave->mode_flags & MIPI_DSI_MODE_VIDEO)\n\t\t\tdpu->ctx.if_type = SPRD_DPU_IF_DPI;\n\t\telse\n\t\t\tdpu->ctx.if_type = SPRD_DPU_IF_EDPI;\n\t}\n\n\tsprd_dpi_init(dpu);\n}\n\nstatic void sprd_crtc_atomic_enable(struct drm_crtc *crtc,\n\t\t\t\t    struct drm_atomic_state *state)\n{\n\tstruct sprd_dpu *dpu = to_sprd_crtc(crtc);\n\n\tsprd_dpu_init(dpu);\n\n\tdrm_crtc_vblank_on(&dpu->base);\n}\n\nstatic void sprd_crtc_atomic_disable(struct drm_crtc *crtc,\n\t\t\t\t     struct drm_atomic_state *state)\n{\n\tstruct sprd_dpu *dpu = to_sprd_crtc(crtc);\n\tstruct drm_device *drm = dpu->base.dev;\n\n\tdrm_crtc_vblank_off(&dpu->base);\n\n\tsprd_dpu_fini(dpu);\n\n\tspin_lock_irq(&drm->event_lock);\n\tif (crtc->state->event) {\n\t\tdrm_crtc_send_vblank_event(crtc, crtc->state->event);\n\t\tcrtc->state->event = NULL;\n\t}\n\tspin_unlock_irq(&drm->event_lock);\n}\n\nstatic void sprd_crtc_atomic_flush(struct drm_crtc *crtc,\n\t\t\t\t   struct drm_atomic_state *state)\n\n{\n\tstruct sprd_dpu *dpu = to_sprd_crtc(crtc);\n\tstruct drm_device *drm = dpu->base.dev;\n\n\tsprd_dpu_flip(dpu);\n\n\tspin_lock_irq(&drm->event_lock);\n\tif (crtc->state->event) {\n\t\tdrm_crtc_send_vblank_event(crtc, crtc->state->event);\n\t\tcrtc->state->event = NULL;\n\t}\n\tspin_unlock_irq(&drm->event_lock);\n}\n\nstatic int sprd_crtc_enable_vblank(struct drm_crtc *crtc)\n{\n\tstruct sprd_dpu *dpu = to_sprd_crtc(crtc);\n\n\tdpu_reg_set(&dpu->ctx, REG_DPU_INT_EN, BIT_DPU_INT_VSYNC);\n\n\treturn 0;\n}\n\nstatic void sprd_crtc_disable_vblank(struct drm_crtc *crtc)\n{\n\tstruct sprd_dpu *dpu = to_sprd_crtc(crtc);\n\n\tdpu_reg_clr(&dpu->ctx, REG_DPU_INT_EN, BIT_DPU_INT_VSYNC);\n}\n\nstatic const struct drm_crtc_helper_funcs sprd_crtc_helper_funcs = {\n\t.mode_set_nofb\t= sprd_crtc_mode_set_nofb,\n\t.atomic_flush\t= sprd_crtc_atomic_flush,\n\t.atomic_enable\t= sprd_crtc_atomic_enable,\n\t.atomic_disable\t= sprd_crtc_atomic_disable,\n};\n\nstatic const struct drm_crtc_funcs sprd_crtc_funcs = {\n\t.destroy\t= drm_crtc_cleanup,\n\t.set_config\t= drm_atomic_helper_set_config,\n\t.page_flip\t= drm_atomic_helper_page_flip,\n\t.reset\t\t= drm_atomic_helper_crtc_reset,\n\t.atomic_duplicate_state\t= drm_atomic_helper_crtc_duplicate_state,\n\t.atomic_destroy_state\t= drm_atomic_helper_crtc_destroy_state,\n\t.enable_vblank\t= sprd_crtc_enable_vblank,\n\t.disable_vblank\t= sprd_crtc_disable_vblank,\n};\n\nstatic struct sprd_dpu *sprd_crtc_init(struct drm_device *drm,\n\t\t\t\t       struct drm_plane *primary, struct device *dev)\n{\n\tstruct device_node *port;\n\tstruct sprd_dpu *dpu;\n\n\tdpu = drmm_crtc_alloc_with_planes(drm, struct sprd_dpu, base,\n\t\t\t\t\t  primary, NULL,\n\t\t\t\t\t&sprd_crtc_funcs, NULL);\n\tif (IS_ERR(dpu)) {\n\t\tdrm_err(drm, \"failed to init crtc\\n\");\n\t\treturn dpu;\n\t}\n\tdrm_crtc_helper_add(&dpu->base, &sprd_crtc_helper_funcs);\n\n\t \n\tport = of_graph_get_port_by_id(dev->of_node, 0);\n\tif (!port) {\n\t\tdrm_err(drm, \"failed to found crtc output port for %s\\n\",\n\t\t\tdev->of_node->full_name);\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\tdpu->base.port = port;\n\tof_node_put(port);\n\n\treturn dpu;\n}\n\nstatic irqreturn_t sprd_dpu_isr(int irq, void *data)\n{\n\tstruct sprd_dpu *dpu = data;\n\tstruct dpu_context *ctx = &dpu->ctx;\n\tu32 reg_val, int_mask = 0;\n\n\treg_val = readl(ctx->base + REG_DPU_INT_STS);\n\n\t \n\tif (reg_val & BIT_DPU_INT_ERR) {\n\t\tint_mask |= BIT_DPU_INT_ERR;\n\t\tdrm_warn(dpu->drm, \"Warning: dpu underflow!\\n\");\n\t}\n\n\t \n\tif (reg_val & BIT_DPU_INT_UPDATE_DONE) {\n\t\tctx->evt_update = true;\n\t\twake_up_interruptible_all(&ctx->wait_queue);\n\t}\n\n\t \n\tif (reg_val & BIT_DPU_INT_DONE) {\n\t\tctx->evt_stop = true;\n\t\twake_up_interruptible_all(&ctx->wait_queue);\n\t}\n\n\tif (reg_val & BIT_DPU_INT_VSYNC)\n\t\tdrm_crtc_handle_vblank(&dpu->base);\n\n\twritel(reg_val, ctx->base + REG_DPU_INT_CLR);\n\tdpu_reg_clr(ctx, REG_DPU_INT_EN, int_mask);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int sprd_dpu_context_init(struct sprd_dpu *dpu,\n\t\t\t\t struct device *dev)\n{\n\tstruct platform_device *pdev = to_platform_device(dev);\n\tstruct dpu_context *ctx = &dpu->ctx;\n\tstruct resource *res;\n\tint ret;\n\n\tres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\n\tif (!res) {\n\t\tdev_err(dev, \"failed to get I/O resource\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tctx->base = devm_ioremap(dev, res->start, resource_size(res));\n\tif (!ctx->base) {\n\t\tdev_err(dev, \"failed to map dpu registers\\n\");\n\t\treturn -EFAULT;\n\t}\n\n\tctx->irq = platform_get_irq(pdev, 0);\n\tif (ctx->irq < 0)\n\t\treturn ctx->irq;\n\n\t \n\twritel(0x00, ctx->base + REG_DPU_INT_EN);\n\twritel(0xff, ctx->base + REG_DPU_INT_CLR);\n\n\tret = devm_request_irq(dev, ctx->irq, sprd_dpu_isr,\n\t\t\t       IRQF_TRIGGER_NONE, \"DPU\", dpu);\n\tif (ret) {\n\t\tdev_err(dev, \"failed to register dpu irq handler\\n\");\n\t\treturn ret;\n\t}\n\n\tinit_waitqueue_head(&ctx->wait_queue);\n\n\treturn 0;\n}\n\nstatic int sprd_dpu_bind(struct device *dev, struct device *master, void *data)\n{\n\tstruct drm_device *drm = data;\n\tstruct sprd_dpu *dpu;\n\tstruct sprd_plane *plane;\n\tint ret;\n\n\tplane = sprd_planes_init(drm);\n\tif (IS_ERR(plane))\n\t\treturn PTR_ERR(plane);\n\n\tdpu = sprd_crtc_init(drm, &plane->base, dev);\n\tif (IS_ERR(dpu))\n\t\treturn PTR_ERR(dpu);\n\n\tdpu->drm = drm;\n\tdev_set_drvdata(dev, dpu);\n\n\tret = sprd_dpu_context_init(dpu, dev);\n\tif (ret)\n\t\treturn ret;\n\n\treturn 0;\n}\n\nstatic const struct component_ops dpu_component_ops = {\n\t.bind = sprd_dpu_bind,\n};\n\nstatic const struct of_device_id dpu_match_table[] = {\n\t{ .compatible = \"sprd,sharkl3-dpu\" },\n\t{   },\n};\nMODULE_DEVICE_TABLE(of, dpu_match_table);\n\nstatic int sprd_dpu_probe(struct platform_device *pdev)\n{\n\treturn component_add(&pdev->dev, &dpu_component_ops);\n}\n\nstatic int sprd_dpu_remove(struct platform_device *pdev)\n{\n\tcomponent_del(&pdev->dev, &dpu_component_ops);\n\n\treturn 0;\n}\n\nstruct platform_driver sprd_dpu_driver = {\n\t.probe = sprd_dpu_probe,\n\t.remove = sprd_dpu_remove,\n\t.driver = {\n\t\t.name = \"sprd-dpu-drv\",\n\t\t.of_match_table = dpu_match_table,\n\t},\n};\n\nMODULE_AUTHOR(\"Leon He <leon.he@unisoc.com>\");\nMODULE_AUTHOR(\"Kevin Tang <kevin.tang@unisoc.com>\");\nMODULE_DESCRIPTION(\"Unisoc Display Controller Driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}