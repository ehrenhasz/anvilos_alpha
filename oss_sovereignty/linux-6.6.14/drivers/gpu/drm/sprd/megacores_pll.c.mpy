{
  "module_name": "megacores_pll.c",
  "hash_id": "b62acf3a4855aa4472a85561db28eccf8e14af376fd830716c21068b87a0f9f7",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/sprd/megacores_pll.c",
  "human_readable_source": "\n \n\n#include <asm/div64.h>\n#include <linux/delay.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/regmap.h>\n#include <linux/string.h>\n\n#include \"sprd_dsi.h\"\n\n#define L\t\t\t\t\t\t0\n#define H\t\t\t\t\t\t1\n#define CLK\t\t\t\t\t\t0\n#define DATA\t\t\t\t\t1\n#define INFINITY\t\t\t\t0xffffffff\n#define MIN_OUTPUT_FREQ\t\t\t(100)\n\n#define AVERAGE(a, b) (min(a, b) + abs((b) - (a)) / 2)\n\n \n#define VCO_BAND_LOW\t750\n#define VCO_BAND_MID\t1100\n#define VCO_BAND_HIGH\t1500\n#define PHY_REF_CLK\t26000\n\nstatic int dphy_calc_pll_param(struct dphy_pll *pll)\n{\n\tconst u32 khz = 1000;\n\tconst u32 mhz = 1000000;\n\tconst unsigned long long factor = 100;\n\tunsigned long long tmp;\n\tint i;\n\n\tpll->potential_fvco = pll->freq / khz;\n\tpll->ref_clk = PHY_REF_CLK / khz;\n\n\tfor (i = 0; i < 4; ++i) {\n\t\tif (pll->potential_fvco >= VCO_BAND_LOW &&\n\t\t    pll->potential_fvco <= VCO_BAND_HIGH) {\n\t\t\tpll->fvco = pll->potential_fvco;\n\t\t\tpll->out_sel = BIT(i);\n\t\t\tbreak;\n\t\t}\n\t\tpll->potential_fvco <<= 1;\n\t}\n\tif (pll->fvco == 0)\n\t\treturn -EINVAL;\n\n\tif (pll->fvco >= VCO_BAND_LOW && pll->fvco <= VCO_BAND_MID) {\n\t\t \n\t\tpll->vco_band = 0x0;\n\t\t \n\t\tpll->lpf_sel = 1;\n\t} else if (pll->fvco > VCO_BAND_MID && pll->fvco <= VCO_BAND_HIGH) {\n\t\tpll->vco_band = 0x1;\n\t\tpll->lpf_sel = 0;\n\t} else {\n\t\treturn -EINVAL;\n\t}\n\n\tpll->nint = pll->fvco / pll->ref_clk;\n\ttmp = pll->fvco * factor * mhz;\n\tdo_div(tmp, pll->ref_clk);\n\ttmp = tmp - pll->nint * factor * mhz;\n\ttmp *= BIT(20);\n\tdo_div(tmp, 100000000);\n\tpll->kint = (u32)tmp;\n\tpll->refin = 3;  \n\tpll->sdm_en = true;  \n\tpll->fdk_s = 0x1;  \n\tpll->cp_s = 0x0;\n\tpll->det_delay = 0x1;\n\n\treturn 0;\n}\n\nstatic void dphy_set_pll_reg(struct dphy_pll *pll, struct regmap *regmap)\n{\n\tu8 reg_val[9] = {0};\n\tint i;\n\n\tu8 reg_addr[] = {\n\t\t0x03, 0x04, 0x06, 0x08, 0x09,\n\t\t0x0a, 0x0b, 0x0e, 0x0f\n\t};\n\n\treg_val[0] = 1 | (1 << 1) |  (pll->lpf_sel << 2);\n\treg_val[1] = pll->div | (1 << 3) | (pll->cp_s << 5) | (pll->fdk_s << 7);\n\treg_val[2] = pll->nint;\n\treg_val[3] = pll->vco_band | (pll->sdm_en << 1) | (pll->refin << 2);\n\treg_val[4] = pll->kint >> 12;\n\treg_val[5] = pll->kint >> 4;\n\treg_val[6] = pll->out_sel | ((pll->kint << 4) & 0xf);\n\treg_val[7] = 1 << 4;\n\treg_val[8] = pll->det_delay;\n\n\tfor (i = 0; i < sizeof(reg_addr); ++i) {\n\t\tregmap_write(regmap, reg_addr[i], reg_val[i]);\n\t\tDRM_DEBUG(\"%02x: %02x\\n\", reg_addr[i], reg_val[i]);\n\t}\n}\n\nint dphy_pll_config(struct dsi_context *ctx)\n{\n\tstruct sprd_dsi *dsi = container_of(ctx, struct sprd_dsi, ctx);\n\tstruct regmap *regmap = ctx->regmap;\n\tstruct dphy_pll *pll = &ctx->pll;\n\tint ret;\n\n\tpll->freq = dsi->slave->hs_rate;\n\n\t \n\tret = dphy_calc_pll_param(pll);\n\tif (ret) {\n\t\tdrm_err(dsi->drm, \"failed to calculate dphy pll parameters\\n\");\n\t\treturn ret;\n\t}\n\tdphy_set_pll_reg(pll, regmap);\n\n\treturn 0;\n}\n\nstatic void dphy_set_timing_reg(struct regmap *regmap, int type, u8 val[])\n{\n\tswitch (type) {\n\tcase REQUEST_TIME:\n\t\tregmap_write(regmap, 0x31, val[CLK]);\n\t\tregmap_write(regmap, 0x41, val[DATA]);\n\t\tregmap_write(regmap, 0x51, val[DATA]);\n\t\tregmap_write(regmap, 0x61, val[DATA]);\n\t\tregmap_write(regmap, 0x71, val[DATA]);\n\n\t\tregmap_write(regmap, 0x90, val[CLK]);\n\t\tregmap_write(regmap, 0xa0, val[DATA]);\n\t\tregmap_write(regmap, 0xb0, val[DATA]);\n\t\tregmap_write(regmap, 0xc0, val[DATA]);\n\t\tregmap_write(regmap, 0xd0, val[DATA]);\n\t\tbreak;\n\tcase PREPARE_TIME:\n\t\tregmap_write(regmap, 0x32, val[CLK]);\n\t\tregmap_write(regmap, 0x42, val[DATA]);\n\t\tregmap_write(regmap, 0x52, val[DATA]);\n\t\tregmap_write(regmap, 0x62, val[DATA]);\n\t\tregmap_write(regmap, 0x72, val[DATA]);\n\n\t\tregmap_write(regmap, 0x91, val[CLK]);\n\t\tregmap_write(regmap, 0xa1, val[DATA]);\n\t\tregmap_write(regmap, 0xb1, val[DATA]);\n\t\tregmap_write(regmap, 0xc1, val[DATA]);\n\t\tregmap_write(regmap, 0xd1, val[DATA]);\n\t\tbreak;\n\tcase ZERO_TIME:\n\t\tregmap_write(regmap, 0x33, val[CLK]);\n\t\tregmap_write(regmap, 0x43, val[DATA]);\n\t\tregmap_write(regmap, 0x53, val[DATA]);\n\t\tregmap_write(regmap, 0x63, val[DATA]);\n\t\tregmap_write(regmap, 0x73, val[DATA]);\n\n\t\tregmap_write(regmap, 0x92, val[CLK]);\n\t\tregmap_write(regmap, 0xa2, val[DATA]);\n\t\tregmap_write(regmap, 0xb2, val[DATA]);\n\t\tregmap_write(regmap, 0xc2, val[DATA]);\n\t\tregmap_write(regmap, 0xd2, val[DATA]);\n\t\tbreak;\n\tcase TRAIL_TIME:\n\t\tregmap_write(regmap, 0x34, val[CLK]);\n\t\tregmap_write(regmap, 0x44, val[DATA]);\n\t\tregmap_write(regmap, 0x54, val[DATA]);\n\t\tregmap_write(regmap, 0x64, val[DATA]);\n\t\tregmap_write(regmap, 0x74, val[DATA]);\n\n\t\tregmap_write(regmap, 0x93, val[CLK]);\n\t\tregmap_write(regmap, 0xa3, val[DATA]);\n\t\tregmap_write(regmap, 0xb3, val[DATA]);\n\t\tregmap_write(regmap, 0xc3, val[DATA]);\n\t\tregmap_write(regmap, 0xd3, val[DATA]);\n\t\tbreak;\n\tcase EXIT_TIME:\n\t\tregmap_write(regmap, 0x36, val[CLK]);\n\t\tregmap_write(regmap, 0x46, val[DATA]);\n\t\tregmap_write(regmap, 0x56, val[DATA]);\n\t\tregmap_write(regmap, 0x66, val[DATA]);\n\t\tregmap_write(regmap, 0x76, val[DATA]);\n\n\t\tregmap_write(regmap, 0x95, val[CLK]);\n\t\tregmap_write(regmap, 0xA5, val[DATA]);\n\t\tregmap_write(regmap, 0xB5, val[DATA]);\n\t\tregmap_write(regmap, 0xc5, val[DATA]);\n\t\tregmap_write(regmap, 0xd5, val[DATA]);\n\t\tbreak;\n\tcase CLKPOST_TIME:\n\t\tregmap_write(regmap, 0x35, val[CLK]);\n\t\tregmap_write(regmap, 0x94, val[CLK]);\n\t\tbreak;\n\n\t \n\tcase SETTLE_TIME:\n\t\tfallthrough;\n\tcase TA_GET:\n\t\tfallthrough;\n\tcase TA_GO:\n\t\tfallthrough;\n\tcase TA_SURE:\n\t\tfallthrough;\n\tdefault:\n\t\tbreak;\n\t}\n}\n\nvoid dphy_timing_config(struct dsi_context *ctx)\n{\n\tstruct regmap *regmap = ctx->regmap;\n\tstruct dphy_pll *pll = &ctx->pll;\n\tconst u32 factor = 2;\n\tconst u32 scale = 100;\n\tu32 t_ui, t_byteck, t_half_byteck;\n\tu32 range[2], constant;\n\tu8 val[2];\n\tu32 tmp = 0;\n\n\t \n\tt_ui = 1000 * scale / (pll->freq / 1000);\n\tt_byteck = t_ui << 3;\n\tt_half_byteck = t_ui << 2;\n\tconstant = t_ui << 1;\n\n\t \n\trange[L] = 50 * scale;\n\trange[H] = INFINITY;\n\tval[CLK] = DIV_ROUND_UP(range[L] * (factor << 1), t_byteck) - 2;\n\tval[DATA] = val[CLK];\n\tdphy_set_timing_reg(regmap, REQUEST_TIME, val);\n\n\t \n\trange[L] = 38 * scale;\n\trange[H] = 95 * scale;\n\ttmp = AVERAGE(range[L], range[H]);\n\tval[CLK] = DIV_ROUND_UP(AVERAGE(range[L], range[H]), t_half_byteck) - 1;\n\trange[L] = 40 * scale + 4 * t_ui;\n\trange[H] = 85 * scale + 6 * t_ui;\n\ttmp |= AVERAGE(range[L], range[H]) << 16;\n\tval[DATA] = DIV_ROUND_UP(AVERAGE(range[L], range[H]), t_half_byteck) - 1;\n\tdphy_set_timing_reg(regmap, PREPARE_TIME, val);\n\n\t \n\trange[L] = 300 * scale;\n\trange[H] = INFINITY;\n\tval[CLK] = DIV_ROUND_UP(range[L] * factor + (tmp & 0xffff)\n\t\t\t- 525 * t_byteck / 100, t_byteck) - 2;\n\trange[L] = 145 * scale + 10 * t_ui;\n\tval[DATA] = DIV_ROUND_UP(range[L] * factor\n\t\t\t+ ((tmp >> 16) & 0xffff) - 525 * t_byteck / 100,\n\t\t\tt_byteck) - 2;\n\tdphy_set_timing_reg(regmap, ZERO_TIME, val);\n\n\t \n\trange[L] = 60 * scale;\n\trange[H] = INFINITY;\n\tval[CLK] = DIV_ROUND_UP(range[L] * factor - constant, t_half_byteck);\n\trange[L] = max(8 * t_ui, 60 * scale + 4 * t_ui);\n\tval[DATA] = DIV_ROUND_UP(range[L] * 3 / 2 - constant, t_half_byteck) - 2;\n\tdphy_set_timing_reg(regmap, TRAIL_TIME, val);\n\n\t \n\trange[L] = 100 * scale;\n\trange[H] = INFINITY;\n\tval[CLK] = DIV_ROUND_UP(range[L] * factor, t_byteck) - 2;\n\tval[DATA] = val[CLK];\n\tdphy_set_timing_reg(regmap, EXIT_TIME, val);\n\n\t \n\trange[L] = 60 * scale + 52 * t_ui;\n\trange[H] = INFINITY;\n\tval[CLK] = DIV_ROUND_UP(range[L] * factor, t_byteck) - 2;\n\tval[DATA] = val[CLK];\n\tdphy_set_timing_reg(regmap, CLKPOST_TIME, val);\n\n\t \n\n\t \n\n\t \n\n\t \n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}