{
  "module_name": "sprd_dsi.c",
  "hash_id": "a780d8755758220f1bb3b9177e5163900dda0cf814a4e1a78632f67680d5d69a",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/sprd/sprd_dsi.c",
  "human_readable_source": "\n \n\n#include <linux/component.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <video/mipi_display.h>\n\n#include <drm/drm_atomic_helper.h>\n#include <drm/drm_bridge.h>\n#include <drm/drm_of.h>\n#include <drm/drm_probe_helper.h>\n\n#include \"sprd_drm.h\"\n#include \"sprd_dpu.h\"\n#include \"sprd_dsi.h\"\n\n#define SOFT_RESET 0x04\n#define MASK_PROTOCOL_INT 0x0C\n#define MASK_INTERNAL_INT 0x14\n#define DSI_MODE_CFG 0x18\n\n#define VIRTUAL_CHANNEL_ID 0x1C\n#define GEN_RX_VCID GENMASK(1, 0)\n#define VIDEO_PKT_VCID GENMASK(3, 2)\n\n#define DPI_VIDEO_FORMAT 0x20\n#define DPI_VIDEO_MODE_FORMAT GENMASK(5, 0)\n#define LOOSELY18_EN BIT(6)\n\n#define VIDEO_PKT_CONFIG 0x24\n#define VIDEO_PKT_SIZE GENMASK(15, 0)\n#define VIDEO_LINE_CHUNK_NUM GENMASK(31, 16)\n\n#define VIDEO_LINE_HBLK_TIME 0x28\n#define VIDEO_LINE_HBP_TIME GENMASK(15, 0)\n#define VIDEO_LINE_HSA_TIME GENMASK(31, 16)\n\n#define VIDEO_LINE_TIME 0x2C\n\n#define VIDEO_VBLK_LINES 0x30\n#define VFP_LINES GENMASK(9, 0)\n#define VBP_LINES GENMASK(19, 10)\n#define VSA_LINES GENMASK(29, 20)\n\n#define VIDEO_VACTIVE_LINES 0x34\n\n#define VID_MODE_CFG 0x38\n#define VID_MODE_TYPE GENMASK(1, 0)\n#define LP_VSA_EN BIT(8)\n#define LP_VBP_EN BIT(9)\n#define LP_VFP_EN BIT(10)\n#define LP_VACT_EN BIT(11)\n#define LP_HBP_EN BIT(12)\n#define LP_HFP_EN BIT(13)\n#define FRAME_BTA_ACK_EN BIT(14)\n\n#define TIMEOUT_CNT_CLK_CONFIG 0x40\n#define HTX_TO_CONFIG 0x44\n#define LRX_H_TO_CONFIG 0x48\n\n#define TX_ESC_CLK_CONFIG 0x5C\n\n#define CMD_MODE_CFG 0x68\n#define TEAR_FX_EN BIT(0)\n\n#define GEN_HDR 0x6C\n#define GEN_DT GENMASK(5, 0)\n#define GEN_VC GENMASK(7, 6)\n\n#define GEN_PLD_DATA 0x70\n\n#define PHY_CLK_LANE_LP_CTRL 0x74\n#define PHY_CLKLANE_TX_REQ_HS BIT(0)\n#define AUTO_CLKLANE_CTRL_EN BIT(1)\n\n#define PHY_INTERFACE_CTRL 0x78\n#define RF_PHY_SHUTDOWN BIT(0)\n#define RF_PHY_RESET_N BIT(1)\n#define RF_PHY_CLK_EN BIT(2)\n\n#define CMD_MODE_STATUS 0x98\n#define GEN_CMD_RDATA_FIFO_EMPTY BIT(1)\n#define GEN_CMD_WDATA_FIFO_EMPTY BIT(3)\n#define GEN_CMD_CMD_FIFO_EMPTY BIT(5)\n#define GEN_CMD_RDCMD_DONE BIT(7)\n\n#define PHY_STATUS 0x9C\n#define PHY_LOCK BIT(1)\n\n#define PHY_MIN_STOP_TIME 0xA0\n#define PHY_LANE_NUM_CONFIG 0xA4\n\n#define PHY_CLKLANE_TIME_CONFIG 0xA8\n#define PHY_CLKLANE_LP_TO_HS_TIME GENMASK(15, 0)\n#define PHY_CLKLANE_HS_TO_LP_TIME GENMASK(31, 16)\n\n#define PHY_DATALANE_TIME_CONFIG 0xAC\n#define PHY_DATALANE_LP_TO_HS_TIME GENMASK(15, 0)\n#define PHY_DATALANE_HS_TO_LP_TIME GENMASK(31, 16)\n\n#define MAX_READ_TIME 0xB0\n\n#define RX_PKT_CHECK_CONFIG 0xB4\n#define RX_PKT_ECC_EN BIT(0)\n#define RX_PKT_CRC_EN BIT(1)\n\n#define TA_EN 0xB8\n\n#define EOTP_EN 0xBC\n#define TX_EOTP_EN BIT(0)\n#define RX_EOTP_EN BIT(1)\n\n#define VIDEO_NULLPKT_SIZE 0xC0\n#define DCS_WM_PKT_SIZE 0xC4\n\n#define VIDEO_SIG_DELAY_CONFIG 0xD0\n#define VIDEO_SIG_DELAY GENMASK(23, 0)\n\n#define PHY_TST_CTRL0 0xF0\n#define PHY_TESTCLR BIT(0)\n#define PHY_TESTCLK BIT(1)\n\n#define PHY_TST_CTRL1 0xF4\n#define PHY_TESTDIN GENMASK(7, 0)\n#define PHY_TESTDOUT GENMASK(15, 8)\n#define PHY_TESTEN BIT(16)\n\n#define host_to_dsi(host) \\\n\tcontainer_of(host, struct sprd_dsi, host)\n\nstatic inline u32\ndsi_reg_rd(struct dsi_context *ctx, u32 offset, u32 mask,\n\t   u32 shift)\n{\n\treturn (readl(ctx->base + offset) & mask) >> shift;\n}\n\nstatic inline void\ndsi_reg_wr(struct dsi_context *ctx, u32 offset, u32 mask,\n\t   u32 shift, u32 val)\n{\n\tu32 ret;\n\n\tret = readl(ctx->base + offset);\n\tret &= ~mask;\n\tret |= (val << shift) & mask;\n\twritel(ret, ctx->base + offset);\n}\n\nstatic inline void\ndsi_reg_up(struct dsi_context *ctx, u32 offset, u32 mask,\n\t   u32 val)\n{\n\tu32 ret = readl(ctx->base + offset);\n\n\twritel((ret & ~mask) | (val & mask), ctx->base + offset);\n}\n\nstatic int regmap_tst_io_write(void *context, u32 reg, u32 val)\n{\n\tstruct sprd_dsi *dsi = context;\n\tstruct dsi_context *ctx = &dsi->ctx;\n\n\tif (val > 0xff || reg > 0xff)\n\t\treturn -EINVAL;\n\n\tdrm_dbg(dsi->drm, \"reg = 0x%02x, val = 0x%02x\\n\", reg, val);\n\n\tdsi_reg_up(ctx, PHY_TST_CTRL1, PHY_TESTEN, PHY_TESTEN);\n\tdsi_reg_wr(ctx, PHY_TST_CTRL1, PHY_TESTDIN, 0, reg);\n\tdsi_reg_up(ctx, PHY_TST_CTRL0, PHY_TESTCLK, PHY_TESTCLK);\n\tdsi_reg_up(ctx, PHY_TST_CTRL0, PHY_TESTCLK, 0);\n\tdsi_reg_up(ctx, PHY_TST_CTRL1, PHY_TESTEN, 0);\n\tdsi_reg_wr(ctx, PHY_TST_CTRL1, PHY_TESTDIN, 0, val);\n\tdsi_reg_up(ctx, PHY_TST_CTRL0, PHY_TESTCLK, PHY_TESTCLK);\n\tdsi_reg_up(ctx, PHY_TST_CTRL0, PHY_TESTCLK, 0);\n\n\treturn 0;\n}\n\nstatic int regmap_tst_io_read(void *context, u32 reg, u32 *val)\n{\n\tstruct sprd_dsi *dsi = context;\n\tstruct dsi_context *ctx = &dsi->ctx;\n\tint ret;\n\n\tif (reg > 0xff)\n\t\treturn -EINVAL;\n\n\tdsi_reg_up(ctx, PHY_TST_CTRL1, PHY_TESTEN, PHY_TESTEN);\n\tdsi_reg_wr(ctx, PHY_TST_CTRL1, PHY_TESTDIN, 0, reg);\n\tdsi_reg_up(ctx, PHY_TST_CTRL0, PHY_TESTCLK, PHY_TESTCLK);\n\tdsi_reg_up(ctx, PHY_TST_CTRL0, PHY_TESTCLK, 0);\n\tdsi_reg_up(ctx, PHY_TST_CTRL1, PHY_TESTEN, 0);\n\n\tudelay(1);\n\n\tret = dsi_reg_rd(ctx, PHY_TST_CTRL1, PHY_TESTDOUT, 8);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t*val = ret;\n\n\tdrm_dbg(dsi->drm, \"reg = 0x%02x, val = 0x%02x\\n\", reg, *val);\n\treturn 0;\n}\n\nstatic struct regmap_bus regmap_tst_io = {\n\t.reg_write = regmap_tst_io_write,\n\t.reg_read = regmap_tst_io_read,\n};\n\nstatic const struct regmap_config byte_config = {\n\t.reg_bits = 8,\n\t.val_bits = 8,\n};\n\nstatic int dphy_wait_pll_locked(struct dsi_context *ctx)\n{\n\tstruct sprd_dsi *dsi = container_of(ctx, struct sprd_dsi, ctx);\n\tint i;\n\n\tfor (i = 0; i < 50000; i++) {\n\t\tif (dsi_reg_rd(ctx, PHY_STATUS, PHY_LOCK, 1))\n\t\t\treturn 0;\n\t\tudelay(3);\n\t}\n\n\tdrm_err(dsi->drm, \"dphy pll can not be locked\\n\");\n\treturn -ETIMEDOUT;\n}\n\nstatic int dsi_wait_tx_payload_fifo_empty(struct dsi_context *ctx)\n{\n\tint i;\n\n\tfor (i = 0; i < 5000; i++) {\n\t\tif (dsi_reg_rd(ctx, CMD_MODE_STATUS, GEN_CMD_WDATA_FIFO_EMPTY, 3))\n\t\t\treturn 0;\n\t\tudelay(1);\n\t}\n\n\treturn -ETIMEDOUT;\n}\n\nstatic int dsi_wait_tx_cmd_fifo_empty(struct dsi_context *ctx)\n{\n\tint i;\n\n\tfor (i = 0; i < 5000; i++) {\n\t\tif (dsi_reg_rd(ctx, CMD_MODE_STATUS, GEN_CMD_CMD_FIFO_EMPTY, 5))\n\t\t\treturn 0;\n\t\tudelay(1);\n\t}\n\n\treturn -ETIMEDOUT;\n}\n\nstatic int dsi_wait_rd_resp_completed(struct dsi_context *ctx)\n{\n\tint i;\n\n\tfor (i = 0; i < 10000; i++) {\n\t\tif (dsi_reg_rd(ctx, CMD_MODE_STATUS, GEN_CMD_RDCMD_DONE, 7))\n\t\t\treturn 0;\n\t\tudelay(10);\n\t}\n\n\treturn -ETIMEDOUT;\n}\n\nstatic u16 calc_bytes_per_pixel_x100(int coding)\n{\n\tu16 bpp_x100;\n\n\tswitch (coding) {\n\tcase COLOR_CODE_16BIT_CONFIG1:\n\tcase COLOR_CODE_16BIT_CONFIG2:\n\tcase COLOR_CODE_16BIT_CONFIG3:\n\t\tbpp_x100 = 200;\n\t\tbreak;\n\tcase COLOR_CODE_18BIT_CONFIG1:\n\tcase COLOR_CODE_18BIT_CONFIG2:\n\t\tbpp_x100 = 225;\n\t\tbreak;\n\tcase COLOR_CODE_24BIT:\n\t\tbpp_x100 = 300;\n\t\tbreak;\n\tcase COLOR_CODE_COMPRESSTION:\n\t\tbpp_x100 = 100;\n\t\tbreak;\n\tcase COLOR_CODE_20BIT_YCC422_LOOSELY:\n\t\tbpp_x100 = 250;\n\t\tbreak;\n\tcase COLOR_CODE_24BIT_YCC422:\n\t\tbpp_x100 = 300;\n\t\tbreak;\n\tcase COLOR_CODE_16BIT_YCC422:\n\t\tbpp_x100 = 200;\n\t\tbreak;\n\tcase COLOR_CODE_30BIT:\n\t\tbpp_x100 = 375;\n\t\tbreak;\n\tcase COLOR_CODE_36BIT:\n\t\tbpp_x100 = 450;\n\t\tbreak;\n\tcase COLOR_CODE_12BIT_YCC420:\n\t\tbpp_x100 = 150;\n\t\tbreak;\n\tdefault:\n\t\tDRM_ERROR(\"invalid color coding\");\n\t\tbpp_x100 = 0;\n\t\tbreak;\n\t}\n\n\treturn bpp_x100;\n}\n\nstatic u8 calc_video_size_step(int coding)\n{\n\tu8 video_size_step;\n\n\tswitch (coding) {\n\tcase COLOR_CODE_16BIT_CONFIG1:\n\tcase COLOR_CODE_16BIT_CONFIG2:\n\tcase COLOR_CODE_16BIT_CONFIG3:\n\tcase COLOR_CODE_18BIT_CONFIG1:\n\tcase COLOR_CODE_18BIT_CONFIG2:\n\tcase COLOR_CODE_24BIT:\n\tcase COLOR_CODE_COMPRESSTION:\n\t\treturn video_size_step = 1;\n\tcase COLOR_CODE_20BIT_YCC422_LOOSELY:\n\tcase COLOR_CODE_24BIT_YCC422:\n\tcase COLOR_CODE_16BIT_YCC422:\n\tcase COLOR_CODE_30BIT:\n\tcase COLOR_CODE_36BIT:\n\tcase COLOR_CODE_12BIT_YCC420:\n\t\treturn video_size_step = 2;\n\tdefault:\n\t\tDRM_ERROR(\"invalid color coding\");\n\t\treturn 0;\n\t}\n}\n\nstatic u16 round_video_size(int coding, u16 video_size)\n{\n\tswitch (coding) {\n\tcase COLOR_CODE_16BIT_YCC422:\n\tcase COLOR_CODE_24BIT_YCC422:\n\tcase COLOR_CODE_20BIT_YCC422_LOOSELY:\n\tcase COLOR_CODE_12BIT_YCC420:\n\t\t \n\t\tif ((video_size % 2) != 0)\n\t\t\tvideo_size += 1;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn video_size;\n}\n\n#define SPRD_MIPI_DSI_FMT_DSC 0xff\nstatic u32 fmt_to_coding(u32 fmt)\n{\n\tswitch (fmt) {\n\tcase MIPI_DSI_FMT_RGB565:\n\t\treturn COLOR_CODE_16BIT_CONFIG1;\n\tcase MIPI_DSI_FMT_RGB666:\n\tcase MIPI_DSI_FMT_RGB666_PACKED:\n\t\treturn COLOR_CODE_18BIT_CONFIG1;\n\tcase MIPI_DSI_FMT_RGB888:\n\t\treturn COLOR_CODE_24BIT;\n\tcase SPRD_MIPI_DSI_FMT_DSC:\n\t\treturn COLOR_CODE_COMPRESSTION;\n\tdefault:\n\t\tDRM_ERROR(\"Unsupported format (%d)\\n\", fmt);\n\t\treturn COLOR_CODE_24BIT;\n\t}\n}\n\n#define ns_to_cycle(ns, byte_clk) \\\n\tDIV_ROUND_UP((ns) * (byte_clk), 1000000)\n\nstatic void sprd_dsi_init(struct dsi_context *ctx)\n{\n\tstruct sprd_dsi *dsi = container_of(ctx, struct sprd_dsi, ctx);\n\tu32 byte_clk = dsi->slave->hs_rate / 8;\n\tu16 data_hs2lp, data_lp2hs, clk_hs2lp, clk_lp2hs;\n\tu16 max_rd_time;\n\tint div;\n\n\twritel(0, ctx->base + SOFT_RESET);\n\twritel(0xffffffff, ctx->base + MASK_PROTOCOL_INT);\n\twritel(0xffffffff, ctx->base + MASK_INTERNAL_INT);\n\twritel(1, ctx->base + DSI_MODE_CFG);\n\tdsi_reg_up(ctx, EOTP_EN, RX_EOTP_EN, 0);\n\tdsi_reg_up(ctx, EOTP_EN, TX_EOTP_EN, 0);\n\tdsi_reg_up(ctx, RX_PKT_CHECK_CONFIG, RX_PKT_ECC_EN, RX_PKT_ECC_EN);\n\tdsi_reg_up(ctx, RX_PKT_CHECK_CONFIG, RX_PKT_CRC_EN, RX_PKT_CRC_EN);\n\twritel(1, ctx->base + TA_EN);\n\tdsi_reg_up(ctx, VIRTUAL_CHANNEL_ID, VIDEO_PKT_VCID, 0);\n\tdsi_reg_up(ctx, VIRTUAL_CHANNEL_ID, GEN_RX_VCID, 0);\n\n\tdiv = DIV_ROUND_UP(byte_clk, dsi->slave->lp_rate);\n\twritel(div, ctx->base + TX_ESC_CLK_CONFIG);\n\n\tmax_rd_time = ns_to_cycle(ctx->max_rd_time, byte_clk);\n\twritel(max_rd_time, ctx->base + MAX_READ_TIME);\n\n\tdata_hs2lp = ns_to_cycle(ctx->data_hs2lp, byte_clk);\n\tdata_lp2hs = ns_to_cycle(ctx->data_lp2hs, byte_clk);\n\tclk_hs2lp = ns_to_cycle(ctx->clk_hs2lp, byte_clk);\n\tclk_lp2hs = ns_to_cycle(ctx->clk_lp2hs, byte_clk);\n\tdsi_reg_wr(ctx, PHY_DATALANE_TIME_CONFIG,\n\t\t   PHY_DATALANE_HS_TO_LP_TIME, 16, data_hs2lp);\n\tdsi_reg_wr(ctx, PHY_DATALANE_TIME_CONFIG,\n\t\t   PHY_DATALANE_LP_TO_HS_TIME, 0, data_lp2hs);\n\tdsi_reg_wr(ctx, PHY_CLKLANE_TIME_CONFIG,\n\t\t   PHY_CLKLANE_HS_TO_LP_TIME, 16, clk_hs2lp);\n\tdsi_reg_wr(ctx, PHY_CLKLANE_TIME_CONFIG,\n\t\t   PHY_CLKLANE_LP_TO_HS_TIME, 0, clk_lp2hs);\n\n\twritel(1, ctx->base + SOFT_RESET);\n}\n\n \nstatic void sprd_dsi_fini(struct dsi_context *ctx)\n{\n\twritel(0xffffffff, ctx->base + MASK_PROTOCOL_INT);\n\twritel(0xffffffff, ctx->base + MASK_INTERNAL_INT);\n\twritel(0, ctx->base + SOFT_RESET);\n}\n\n \nstatic int sprd_dsi_dpi_video(struct dsi_context *ctx)\n{\n\tstruct sprd_dsi *dsi = container_of(ctx, struct sprd_dsi, ctx);\n\tstruct videomode *vm = &ctx->vm;\n\tu32 byte_clk = dsi->slave->hs_rate / 8;\n\tu16 bpp_x100;\n\tu16 video_size;\n\tu32 ratio_x1000;\n\tu16 null_pkt_size = 0;\n\tu8 video_size_step;\n\tu32 hs_to;\n\tu32 total_bytes;\n\tu32 bytes_per_chunk;\n\tu32 chunks = 0;\n\tu32 bytes_left = 0;\n\tu32 chunk_overhead;\n\tconst u8 pkt_header = 6;\n\tu8 coding;\n\tint div;\n\tu16 hline;\n\tu16 byte_cycle;\n\n\tcoding = fmt_to_coding(dsi->slave->format);\n\tvideo_size = round_video_size(coding, vm->hactive);\n\tbpp_x100 = calc_bytes_per_pixel_x100(coding);\n\tvideo_size_step = calc_video_size_step(coding);\n\tratio_x1000 = byte_clk * 1000 / (vm->pixelclock / 1000);\n\thline = vm->hactive + vm->hsync_len + vm->hfront_porch +\n\t\tvm->hback_porch;\n\n\twritel(0, ctx->base + SOFT_RESET);\n\tdsi_reg_wr(ctx, VID_MODE_CFG, FRAME_BTA_ACK_EN, 15, ctx->frame_ack_en);\n\tdsi_reg_wr(ctx, DPI_VIDEO_FORMAT, DPI_VIDEO_MODE_FORMAT, 0, coding);\n\tdsi_reg_wr(ctx, VID_MODE_CFG, VID_MODE_TYPE, 0, ctx->burst_mode);\n\tbyte_cycle = 95 * hline * ratio_x1000 / 100000;\n\tdsi_reg_wr(ctx, VIDEO_SIG_DELAY_CONFIG, VIDEO_SIG_DELAY, 0, byte_cycle);\n\tbyte_cycle = hline * ratio_x1000 / 1000;\n\twritel(byte_cycle, ctx->base + VIDEO_LINE_TIME);\n\tbyte_cycle = vm->hsync_len * ratio_x1000 / 1000;\n\tdsi_reg_wr(ctx, VIDEO_LINE_HBLK_TIME, VIDEO_LINE_HSA_TIME, 16, byte_cycle);\n\tbyte_cycle = vm->hback_porch * ratio_x1000 / 1000;\n\tdsi_reg_wr(ctx, VIDEO_LINE_HBLK_TIME, VIDEO_LINE_HBP_TIME, 0, byte_cycle);\n\twritel(vm->vactive, ctx->base + VIDEO_VACTIVE_LINES);\n\tdsi_reg_wr(ctx, VIDEO_VBLK_LINES, VFP_LINES, 0, vm->vfront_porch);\n\tdsi_reg_wr(ctx, VIDEO_VBLK_LINES, VBP_LINES, 10, vm->vback_porch);\n\tdsi_reg_wr(ctx, VIDEO_VBLK_LINES, VSA_LINES, 20, vm->vsync_len);\n\tdsi_reg_up(ctx, VID_MODE_CFG, LP_HBP_EN | LP_HFP_EN | LP_VACT_EN |\n\t\t\tLP_VFP_EN | LP_VBP_EN | LP_VSA_EN, LP_HBP_EN | LP_HFP_EN |\n\t\t\tLP_VACT_EN | LP_VFP_EN | LP_VBP_EN | LP_VSA_EN);\n\n\ths_to = (hline * vm->vactive) + (2 * bpp_x100) / 100;\n\tfor (div = 0x80; (div < hs_to) && (div > 2); div--) {\n\t\tif ((hs_to % div) == 0) {\n\t\t\twritel(div, ctx->base + TIMEOUT_CNT_CLK_CONFIG);\n\t\t\twritel(hs_to / div, ctx->base + LRX_H_TO_CONFIG);\n\t\t\twritel(hs_to / div, ctx->base + HTX_TO_CONFIG);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (ctx->burst_mode == VIDEO_BURST_WITH_SYNC_PULSES) {\n\t\tdsi_reg_wr(ctx, VIDEO_PKT_CONFIG, VIDEO_PKT_SIZE, 0, video_size);\n\t\twritel(0, ctx->base + VIDEO_NULLPKT_SIZE);\n\t\tdsi_reg_up(ctx, VIDEO_PKT_CONFIG, VIDEO_LINE_CHUNK_NUM, 0);\n\t} else {\n\t\t \n\t\tnull_pkt_size = 0;\n\n\t\t \n\t\tbytes_per_chunk = vm->hactive * bpp_x100 / 100 + pkt_header;\n\n\t\t \n\t\ttotal_bytes = (vm->hactive + vm->hfront_porch) *\n\t\t\t\tratio_x1000 / dsi->slave->lanes / 1000;\n\n\t\t \n\t\tif (total_bytes < bytes_per_chunk) {\n\t\t\tdrm_err(dsi->drm, \"current resolution can not be set\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tchunk_overhead = total_bytes - bytes_per_chunk;\n\n\t\t \n\t\tif (chunk_overhead > 1) {\n\t\t\t \n\t\t\tfor (video_size = video_size_step;\n\t\t\t     video_size < vm->hactive;\n\t\t\t     video_size += video_size_step) {\n\t\t\t\tif (vm->hactive * 1000 / video_size % 1000)\n\t\t\t\t\tcontinue;\n\n\t\t\t\tchunks = vm->hactive / video_size;\n\t\t\t\tbytes_per_chunk = bpp_x100 * video_size / 100\n\t\t\t\t\t\t  + pkt_header;\n\t\t\t\tif (total_bytes >= (bytes_per_chunk * chunks)) {\n\t\t\t\t\tbytes_left = total_bytes -\n\t\t\t\t\t\t     bytes_per_chunk * chunks;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t \n\t\t\tif (bytes_left > (pkt_header * chunks)) {\n\t\t\t\tnull_pkt_size = (bytes_left -\n\t\t\t\t\t\tpkt_header * chunks) / chunks;\n\t\t\t\t \n\t\t\t\tif (null_pkt_size > 1023)\n\t\t\t\t\tnull_pkt_size = 1023;\n\t\t\t}\n\n\t\t} else {\n\t\t\t \n\t\t\tchunks = 1;\n\n\t\t\t \n\t\t\tfor (video_size = vm->hactive;\n\t\t\t    (video_size % video_size_step) != 0;\n\t\t\t     video_size++)\n\t\t\t\t;\n\t\t}\n\n\t\tdsi_reg_wr(ctx, VIDEO_PKT_CONFIG, VIDEO_PKT_SIZE, 0, video_size);\n\t\twritel(null_pkt_size, ctx->base + VIDEO_NULLPKT_SIZE);\n\t\tdsi_reg_wr(ctx, VIDEO_PKT_CONFIG, VIDEO_LINE_CHUNK_NUM, 16, chunks);\n\t}\n\n\twritel(ctx->int0_mask, ctx->base + MASK_PROTOCOL_INT);\n\twritel(ctx->int1_mask, ctx->base + MASK_INTERNAL_INT);\n\twritel(1, ctx->base + SOFT_RESET);\n\n\treturn 0;\n}\n\nstatic void sprd_dsi_edpi_video(struct dsi_context *ctx)\n{\n\tstruct sprd_dsi *dsi = container_of(ctx, struct sprd_dsi, ctx);\n\tconst u32 fifo_depth = 1096;\n\tconst u32 word_length = 4;\n\tu32 hactive = ctx->vm.hactive;\n\tu32 bpp_x100;\n\tu32 max_fifo_len;\n\tu8 coding;\n\n\tcoding = fmt_to_coding(dsi->slave->format);\n\tbpp_x100 = calc_bytes_per_pixel_x100(coding);\n\tmax_fifo_len = word_length * fifo_depth * 100 / bpp_x100;\n\n\twritel(0, ctx->base + SOFT_RESET);\n\tdsi_reg_wr(ctx, DPI_VIDEO_FORMAT, DPI_VIDEO_MODE_FORMAT, 0, coding);\n\tdsi_reg_wr(ctx, CMD_MODE_CFG, TEAR_FX_EN, 0, ctx->te_ack_en);\n\n\tif (max_fifo_len > hactive)\n\t\twritel(hactive, ctx->base + DCS_WM_PKT_SIZE);\n\telse\n\t\twritel(max_fifo_len, ctx->base + DCS_WM_PKT_SIZE);\n\n\twritel(ctx->int0_mask, ctx->base + MASK_PROTOCOL_INT);\n\twritel(ctx->int1_mask, ctx->base + MASK_INTERNAL_INT);\n\twritel(1, ctx->base + SOFT_RESET);\n}\n\n \nstatic int sprd_dsi_wr_pkt(struct dsi_context *ctx, u8 vc, u8 type,\n\t\t\t   const u8 *param, u16 len)\n{\n\tstruct sprd_dsi *dsi = container_of(ctx, struct sprd_dsi, ctx);\n\tu8 wc_lsbyte, wc_msbyte;\n\tu32 payload;\n\tint i, j, ret;\n\n\tif (vc > 3)\n\t\treturn -EINVAL;\n\n\t \n\tret = dsi_wait_tx_payload_fifo_empty(ctx);\n\tif (ret) {\n\t\tdrm_err(dsi->drm, \"tx payload fifo is not empty\\n\");\n\t\treturn ret;\n\t}\n\n\tif (len > 2) {\n\t\tfor (i = 0, j = 0; i < len; i += j) {\n\t\t\tpayload = 0;\n\t\t\tfor (j = 0; (j < 4) && ((j + i) < (len)); j++)\n\t\t\t\tpayload |= param[i + j] << (j * 8);\n\n\t\t\twritel(payload, ctx->base + GEN_PLD_DATA);\n\t\t}\n\t\twc_lsbyte = len & 0xff;\n\t\twc_msbyte = len >> 8;\n\t} else {\n\t\twc_lsbyte = (len > 0) ? param[0] : 0;\n\t\twc_msbyte = (len > 1) ? param[1] : 0;\n\t}\n\n\t \n\tret = dsi_wait_tx_cmd_fifo_empty(ctx);\n\tif (ret) {\n\t\tdrm_err(dsi->drm, \"tx cmd fifo is not empty\\n\");\n\t\treturn ret;\n\t}\n\n\twritel(type | (vc << 6) | (wc_lsbyte << 8) | (wc_msbyte << 16),\n\t       ctx->base + GEN_HDR);\n\n\treturn 0;\n}\n\n \nstatic int sprd_dsi_rd_pkt(struct dsi_context *ctx, u8 vc, u8 type,\n\t\t\t   u8 msb_byte, u8 lsb_byte,\n\t\t\t   u8 *buffer, u8 bytes_to_read)\n{\n\tstruct sprd_dsi *dsi = container_of(ctx, struct sprd_dsi, ctx);\n\tint i, ret;\n\tint count = 0;\n\tu32 temp;\n\n\tif (vc > 3)\n\t\treturn -EINVAL;\n\n\t \n\tret = dsi_reg_rd(ctx, CMD_MODE_STATUS, GEN_CMD_CMD_FIFO_EMPTY, 5);\n\tif (!ret)\n\t\treturn -EIO;\n\n\twritel(type | (vc << 6) | (lsb_byte << 8) | (msb_byte << 16),\n\t       ctx->base + GEN_HDR);\n\n\t \n\tret = dsi_wait_rd_resp_completed(ctx);\n\tif (ret) {\n\t\tdrm_err(dsi->drm, \"wait read response time out\\n\");\n\t\treturn ret;\n\t}\n\n\t \n\tret = dsi_reg_rd(ctx, CMD_MODE_STATUS, GEN_CMD_RDATA_FIFO_EMPTY, 1);\n\tif (ret) {\n\t\tdrm_err(dsi->drm, \"rx payload fifo empty\\n\");\n\t\treturn -EIO;\n\t}\n\n\tfor (i = 0; i < 100; i++) {\n\t\ttemp = readl(ctx->base + GEN_PLD_DATA);\n\n\t\tif (count < bytes_to_read)\n\t\t\tbuffer[count++] = temp & 0xff;\n\t\tif (count < bytes_to_read)\n\t\t\tbuffer[count++] = (temp >> 8) & 0xff;\n\t\tif (count < bytes_to_read)\n\t\t\tbuffer[count++] = (temp >> 16) & 0xff;\n\t\tif (count < bytes_to_read)\n\t\t\tbuffer[count++] = (temp >> 24) & 0xff;\n\n\t\tret = dsi_reg_rd(ctx, CMD_MODE_STATUS, GEN_CMD_RDATA_FIFO_EMPTY, 1);\n\t\tif (ret)\n\t\t\treturn count;\n\t}\n\n\treturn 0;\n}\n\nstatic void sprd_dsi_set_work_mode(struct dsi_context *ctx, u8 mode)\n{\n\tif (mode == DSI_MODE_CMD)\n\t\twritel(1, ctx->base + DSI_MODE_CFG);\n\telse\n\t\twritel(0, ctx->base + DSI_MODE_CFG);\n}\n\nstatic void sprd_dsi_state_reset(struct dsi_context *ctx)\n{\n\twritel(0, ctx->base + SOFT_RESET);\n\tudelay(100);\n\twritel(1, ctx->base + SOFT_RESET);\n}\n\nstatic int sprd_dphy_init(struct dsi_context *ctx)\n{\n\tstruct sprd_dsi *dsi = container_of(ctx, struct sprd_dsi, ctx);\n\tint ret;\n\n\tdsi_reg_up(ctx, PHY_INTERFACE_CTRL, RF_PHY_RESET_N, 0);\n\tdsi_reg_up(ctx, PHY_INTERFACE_CTRL, RF_PHY_SHUTDOWN, 0);\n\tdsi_reg_up(ctx, PHY_INTERFACE_CTRL, RF_PHY_CLK_EN, 0);\n\n\tdsi_reg_up(ctx, PHY_TST_CTRL0, PHY_TESTCLR, 0);\n\tdsi_reg_up(ctx, PHY_TST_CTRL0, PHY_TESTCLR, PHY_TESTCLR);\n\tdsi_reg_up(ctx, PHY_TST_CTRL0, PHY_TESTCLR, 0);\n\n\tdphy_pll_config(ctx);\n\tdphy_timing_config(ctx);\n\n\tdsi_reg_up(ctx, PHY_INTERFACE_CTRL, RF_PHY_SHUTDOWN, RF_PHY_SHUTDOWN);\n\tdsi_reg_up(ctx, PHY_INTERFACE_CTRL, RF_PHY_RESET_N, RF_PHY_RESET_N);\n\twritel(0x1C, ctx->base + PHY_MIN_STOP_TIME);\n\tdsi_reg_up(ctx, PHY_INTERFACE_CTRL, RF_PHY_CLK_EN, RF_PHY_CLK_EN);\n\twritel(dsi->slave->lanes - 1, ctx->base + PHY_LANE_NUM_CONFIG);\n\n\tret = dphy_wait_pll_locked(ctx);\n\tif (ret) {\n\t\tdrm_err(dsi->drm, \"dphy initial failed\\n\");\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic void sprd_dphy_fini(struct dsi_context *ctx)\n{\n\tdsi_reg_up(ctx, PHY_INTERFACE_CTRL, RF_PHY_RESET_N, 0);\n\tdsi_reg_up(ctx, PHY_INTERFACE_CTRL, RF_PHY_SHUTDOWN, 0);\n\tdsi_reg_up(ctx, PHY_INTERFACE_CTRL, RF_PHY_RESET_N, RF_PHY_RESET_N);\n}\n\nstatic void sprd_dsi_encoder_mode_set(struct drm_encoder *encoder,\n\t\t\t\t      struct drm_display_mode *mode,\n\t\t\t\t struct drm_display_mode *adj_mode)\n{\n\tstruct sprd_dsi *dsi = encoder_to_dsi(encoder);\n\n\tdrm_display_mode_to_videomode(adj_mode, &dsi->ctx.vm);\n}\n\nstatic void sprd_dsi_encoder_enable(struct drm_encoder *encoder)\n{\n\tstruct sprd_dsi *dsi = encoder_to_dsi(encoder);\n\tstruct sprd_dpu *dpu = to_sprd_crtc(encoder->crtc);\n\tstruct dsi_context *ctx = &dsi->ctx;\n\n\tif (ctx->enabled) {\n\t\tdrm_warn(dsi->drm, \"dsi is initialized\\n\");\n\t\treturn;\n\t}\n\n\tsprd_dsi_init(ctx);\n\tif (ctx->work_mode == DSI_MODE_VIDEO)\n\t\tsprd_dsi_dpi_video(ctx);\n\telse\n\t\tsprd_dsi_edpi_video(ctx);\n\n\tsprd_dphy_init(ctx);\n\n\tsprd_dsi_set_work_mode(ctx, ctx->work_mode);\n\tsprd_dsi_state_reset(ctx);\n\n\tif (dsi->slave->mode_flags & MIPI_DSI_CLOCK_NON_CONTINUOUS) {\n\t\tdsi_reg_up(ctx, PHY_CLK_LANE_LP_CTRL, AUTO_CLKLANE_CTRL_EN,\n\t\t\t   AUTO_CLKLANE_CTRL_EN);\n\t} else {\n\t\tdsi_reg_up(ctx, PHY_CLK_LANE_LP_CTRL, RF_PHY_CLK_EN, RF_PHY_CLK_EN);\n\t\tdsi_reg_up(ctx, PHY_CLK_LANE_LP_CTRL, PHY_CLKLANE_TX_REQ_HS,\n\t\t\t   PHY_CLKLANE_TX_REQ_HS);\n\t\tdphy_wait_pll_locked(ctx);\n\t}\n\n\tsprd_dpu_run(dpu);\n\n\tctx->enabled = true;\n}\n\nstatic void sprd_dsi_encoder_disable(struct drm_encoder *encoder)\n{\n\tstruct sprd_dsi *dsi = encoder_to_dsi(encoder);\n\tstruct sprd_dpu *dpu = to_sprd_crtc(encoder->crtc);\n\tstruct dsi_context *ctx = &dsi->ctx;\n\n\tif (!ctx->enabled) {\n\t\tdrm_warn(dsi->drm, \"dsi isn't initialized\\n\");\n\t\treturn;\n\t}\n\n\tsprd_dpu_stop(dpu);\n\tsprd_dphy_fini(ctx);\n\tsprd_dsi_fini(ctx);\n\n\tctx->enabled = false;\n}\n\nstatic const struct drm_encoder_helper_funcs sprd_encoder_helper_funcs = {\n\t.mode_set\t= sprd_dsi_encoder_mode_set,\n\t.enable\t\t= sprd_dsi_encoder_enable,\n\t.disable\t= sprd_dsi_encoder_disable\n};\n\nstatic const struct drm_encoder_funcs sprd_encoder_funcs = {\n\t.destroy = drm_encoder_cleanup,\n};\n\nstatic int sprd_dsi_encoder_init(struct sprd_dsi *dsi,\n\t\t\t\t struct device *dev)\n{\n\tstruct drm_encoder *encoder = &dsi->encoder;\n\tu32 crtc_mask;\n\tint ret;\n\n\tcrtc_mask = drm_of_find_possible_crtcs(dsi->drm, dev->of_node);\n\tif (!crtc_mask) {\n\t\tdrm_err(dsi->drm, \"failed to find crtc mask\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tdrm_dbg(dsi->drm, \"find possible crtcs: 0x%08x\\n\", crtc_mask);\n\n\tencoder->possible_crtcs = crtc_mask;\n\tret = drm_encoder_init(dsi->drm, encoder, &sprd_encoder_funcs,\n\t\t\t       DRM_MODE_ENCODER_DSI, NULL);\n\tif (ret) {\n\t\tdrm_err(dsi->drm, \"failed to init dsi encoder\\n\");\n\t\treturn ret;\n\t}\n\n\tdrm_encoder_helper_add(encoder, &sprd_encoder_helper_funcs);\n\n\treturn 0;\n}\n\nstatic int sprd_dsi_bridge_init(struct sprd_dsi *dsi,\n\t\t\t\tstruct device *dev)\n{\n\tint ret;\n\n\tdsi->panel_bridge = devm_drm_of_get_bridge(dev, dev->of_node, 1, 0);\n\tif (IS_ERR(dsi->panel_bridge))\n\t\treturn PTR_ERR(dsi->panel_bridge);\n\n\tret = drm_bridge_attach(&dsi->encoder, dsi->panel_bridge, NULL, 0);\n\tif (ret)\n\t\treturn ret;\n\n\treturn 0;\n}\n\nstatic int sprd_dsi_context_init(struct sprd_dsi *dsi,\n\t\t\t\t struct device *dev)\n{\n\tstruct platform_device *pdev = to_platform_device(dev);\n\tstruct dsi_context *ctx = &dsi->ctx;\n\tstruct resource *res;\n\n\tres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\n\tif (!res) {\n\t\tdev_err(dev, \"failed to get I/O resource\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tctx->base = devm_ioremap(dev, res->start, resource_size(res));\n\tif (!ctx->base) {\n\t\tdrm_err(dsi->drm, \"failed to map dsi host registers\\n\");\n\t\treturn -ENXIO;\n\t}\n\n\tctx->regmap = devm_regmap_init(dev, &regmap_tst_io, dsi, &byte_config);\n\tif (IS_ERR(ctx->regmap)) {\n\t\tdrm_err(dsi->drm, \"dphy regmap init failed\\n\");\n\t\treturn PTR_ERR(ctx->regmap);\n\t}\n\n\tctx->data_hs2lp = 120;\n\tctx->data_lp2hs = 500;\n\tctx->clk_hs2lp = 4;\n\tctx->clk_lp2hs = 15;\n\tctx->max_rd_time = 6000;\n\tctx->int0_mask = 0xffffffff;\n\tctx->int1_mask = 0xffffffff;\n\tctx->enabled = true;\n\n\treturn 0;\n}\n\nstatic int sprd_dsi_bind(struct device *dev, struct device *master, void *data)\n{\n\tstruct drm_device *drm = data;\n\tstruct sprd_dsi *dsi = dev_get_drvdata(dev);\n\tint ret;\n\n\tdsi->drm = drm;\n\n\tret = sprd_dsi_encoder_init(dsi, dev);\n\tif (ret)\n\t\treturn ret;\n\n\tret = sprd_dsi_bridge_init(dsi, dev);\n\tif (ret)\n\t\treturn ret;\n\n\tret = sprd_dsi_context_init(dsi, dev);\n\tif (ret)\n\t\treturn ret;\n\n\treturn 0;\n}\n\nstatic void sprd_dsi_unbind(struct device *dev,\n\t\t\t    struct device *master, void *data)\n{\n\tstruct sprd_dsi *dsi = dev_get_drvdata(dev);\n\n\tdrm_of_panel_bridge_remove(dev->of_node, 1, 0);\n\n\tdrm_encoder_cleanup(&dsi->encoder);\n}\n\nstatic const struct component_ops dsi_component_ops = {\n\t.bind\t= sprd_dsi_bind,\n\t.unbind\t= sprd_dsi_unbind,\n};\n\nstatic int sprd_dsi_host_attach(struct mipi_dsi_host *host,\n\t\t\t\tstruct mipi_dsi_device *slave)\n{\n\tstruct sprd_dsi *dsi = host_to_dsi(host);\n\tstruct dsi_context *ctx = &dsi->ctx;\n\n\tdsi->slave = slave;\n\n\tif (slave->mode_flags & MIPI_DSI_MODE_VIDEO)\n\t\tctx->work_mode = DSI_MODE_VIDEO;\n\telse\n\t\tctx->work_mode = DSI_MODE_CMD;\n\n\tif (slave->mode_flags & MIPI_DSI_MODE_VIDEO_BURST)\n\t\tctx->burst_mode = VIDEO_BURST_WITH_SYNC_PULSES;\n\telse if (slave->mode_flags & MIPI_DSI_MODE_VIDEO_SYNC_PULSE)\n\t\tctx->burst_mode = VIDEO_NON_BURST_WITH_SYNC_PULSES;\n\telse\n\t\tctx->burst_mode = VIDEO_NON_BURST_WITH_SYNC_EVENTS;\n\n\treturn component_add(host->dev, &dsi_component_ops);\n}\n\nstatic int sprd_dsi_host_detach(struct mipi_dsi_host *host,\n\t\t\t\tstruct mipi_dsi_device *slave)\n{\n\tcomponent_del(host->dev, &dsi_component_ops);\n\n\treturn 0;\n}\n\nstatic ssize_t sprd_dsi_host_transfer(struct mipi_dsi_host *host,\n\t\t\t\t      const struct mipi_dsi_msg *msg)\n{\n\tstruct sprd_dsi *dsi = host_to_dsi(host);\n\tconst u8 *tx_buf = msg->tx_buf;\n\n\tif (msg->rx_buf && msg->rx_len) {\n\t\tu8 lsb = (msg->tx_len > 0) ? tx_buf[0] : 0;\n\t\tu8 msb = (msg->tx_len > 1) ? tx_buf[1] : 0;\n\n\t\treturn sprd_dsi_rd_pkt(&dsi->ctx, msg->channel, msg->type,\n\t\t\t\tmsb, lsb, msg->rx_buf, msg->rx_len);\n\t}\n\n\tif (msg->tx_buf && msg->tx_len)\n\t\treturn sprd_dsi_wr_pkt(&dsi->ctx, msg->channel, msg->type,\n\t\t\t\t\ttx_buf, msg->tx_len);\n\n\treturn 0;\n}\n\nstatic const struct mipi_dsi_host_ops sprd_dsi_host_ops = {\n\t.attach = sprd_dsi_host_attach,\n\t.detach = sprd_dsi_host_detach,\n\t.transfer = sprd_dsi_host_transfer,\n};\n\nstatic const struct of_device_id dsi_match_table[] = {\n\t{ .compatible = \"sprd,sharkl3-dsi-host\" },\n\t{   },\n};\n\nstatic int sprd_dsi_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct sprd_dsi *dsi;\n\n\tdsi = devm_kzalloc(dev, sizeof(*dsi), GFP_KERNEL);\n\tif (!dsi)\n\t\treturn -ENOMEM;\n\n\tdev_set_drvdata(dev, dsi);\n\n\tdsi->host.ops = &sprd_dsi_host_ops;\n\tdsi->host.dev = dev;\n\n\treturn mipi_dsi_host_register(&dsi->host);\n}\n\nstatic int sprd_dsi_remove(struct platform_device *pdev)\n{\n\tstruct sprd_dsi *dsi = dev_get_drvdata(&pdev->dev);\n\n\tmipi_dsi_host_unregister(&dsi->host);\n\n\treturn 0;\n}\n\nstruct platform_driver sprd_dsi_driver = {\n\t.probe = sprd_dsi_probe,\n\t.remove = sprd_dsi_remove,\n\t.driver = {\n\t\t.name = \"sprd-dsi-drv\",\n\t\t.of_match_table = dsi_match_table,\n\t},\n};\n\nMODULE_AUTHOR(\"Leon He <leon.he@unisoc.com>\");\nMODULE_AUTHOR(\"Kevin Tang <kevin.tang@unisoc.com>\");\nMODULE_DESCRIPTION(\"Unisoc MIPI DSI HOST Controller Driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}