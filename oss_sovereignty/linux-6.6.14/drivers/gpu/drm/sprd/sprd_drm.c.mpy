{
  "module_name": "sprd_drm.c",
  "hash_id": "2d6c407171802f1c78aac72fd91ad145c6799e672235038ee1c37500a4795bfb",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/sprd/sprd_drm.c",
  "human_readable_source": "\n \n\n#include <linux/component.h>\n#include <linux/dma-mapping.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include <linux/mutex.h>\n#include <linux/of_graph.h>\n#include <linux/platform_device.h>\n\n#include <drm/drm_atomic_helper.h>\n#include <drm/drm_drv.h>\n#include <drm/drm_gem_dma_helper.h>\n#include <drm/drm_gem_framebuffer_helper.h>\n#include <drm/drm_of.h>\n#include <drm/drm_probe_helper.h>\n#include <drm/drm_vblank.h>\n\n#include \"sprd_drm.h\"\n\n#define DRIVER_NAME\t\"sprd\"\n#define DRIVER_DESC\t\"Spreadtrum SoCs' DRM Driver\"\n#define DRIVER_DATE\t\"20200201\"\n#define DRIVER_MAJOR\t1\n#define DRIVER_MINOR\t0\n\nstatic const struct drm_mode_config_helper_funcs sprd_drm_mode_config_helper = {\n\t.atomic_commit_tail = drm_atomic_helper_commit_tail_rpm,\n};\n\nstatic const struct drm_mode_config_funcs sprd_drm_mode_config_funcs = {\n\t.fb_create = drm_gem_fb_create,\n\t.atomic_check = drm_atomic_helper_check,\n\t.atomic_commit = drm_atomic_helper_commit,\n};\n\nstatic void sprd_drm_mode_config_init(struct drm_device *drm)\n{\n\tdrm->mode_config.min_width = 0;\n\tdrm->mode_config.min_height = 0;\n\tdrm->mode_config.max_width = 8192;\n\tdrm->mode_config.max_height = 8192;\n\n\tdrm->mode_config.funcs = &sprd_drm_mode_config_funcs;\n\tdrm->mode_config.helper_private = &sprd_drm_mode_config_helper;\n}\n\nDEFINE_DRM_GEM_DMA_FOPS(sprd_drm_fops);\n\nstatic struct drm_driver sprd_drm_drv = {\n\t.driver_features\t= DRIVER_GEM | DRIVER_MODESET | DRIVER_ATOMIC,\n\t.fops\t\t\t= &sprd_drm_fops,\n\n\t \n\tDRM_GEM_DMA_DRIVER_OPS,\n\n\t.name\t\t\t= DRIVER_NAME,\n\t.desc\t\t\t= DRIVER_DESC,\n\t.date\t\t\t= DRIVER_DATE,\n\t.major\t\t\t= DRIVER_MAJOR,\n\t.minor\t\t\t= DRIVER_MINOR,\n};\n\nstatic int sprd_drm_bind(struct device *dev)\n{\n\tstruct platform_device *pdev = to_platform_device(dev);\n\tstruct drm_device *drm;\n\tstruct sprd_drm *sprd;\n\tint ret;\n\n\tsprd = devm_drm_dev_alloc(dev, &sprd_drm_drv, struct sprd_drm, drm);\n\tif (IS_ERR(sprd))\n\t\treturn PTR_ERR(sprd);\n\n\tdrm = &sprd->drm;\n\tplatform_set_drvdata(pdev, drm);\n\n\tret = drmm_mode_config_init(drm);\n\tif (ret)\n\t\treturn ret;\n\n\tsprd_drm_mode_config_init(drm);\n\n\t \n\tret = component_bind_all(drm->dev, drm);\n\tif (ret) {\n\t\tdrm_err(drm, \"failed to bind all component.\\n\");\n\t\treturn ret;\n\t}\n\n\t \n\tret = drm_vblank_init(drm, drm->mode_config.num_crtc);\n\tif (ret) {\n\t\tdrm_err(drm, \"failed to initialize vblank.\\n\");\n\t\tgoto err_unbind_all;\n\t}\n\n\t \n\tdrm_mode_config_reset(drm);\n\n\t \n\tdrm_kms_helper_poll_init(drm);\n\n\tret = drm_dev_register(drm, 0);\n\tif (ret < 0)\n\t\tgoto err_kms_helper_poll_fini;\n\n\treturn 0;\n\nerr_kms_helper_poll_fini:\n\tdrm_kms_helper_poll_fini(drm);\nerr_unbind_all:\n\tcomponent_unbind_all(drm->dev, drm);\n\treturn ret;\n}\n\nstatic void sprd_drm_unbind(struct device *dev)\n{\n\tstruct drm_device *drm = dev_get_drvdata(dev);\n\n\tdrm_dev_unregister(drm);\n\n\tdrm_kms_helper_poll_fini(drm);\n\n\tcomponent_unbind_all(drm->dev, drm);\n}\n\nstatic const struct component_master_ops drm_component_ops = {\n\t.bind = sprd_drm_bind,\n\t.unbind = sprd_drm_unbind,\n};\n\nstatic int sprd_drm_probe(struct platform_device *pdev)\n{\n\treturn drm_of_component_probe(&pdev->dev, component_compare_of, &drm_component_ops);\n}\n\nstatic int sprd_drm_remove(struct platform_device *pdev)\n{\n\tcomponent_master_del(&pdev->dev, &drm_component_ops);\n\treturn 0;\n}\n\nstatic void sprd_drm_shutdown(struct platform_device *pdev)\n{\n\tstruct drm_device *drm = platform_get_drvdata(pdev);\n\n\tif (!drm) {\n\t\tdev_warn(&pdev->dev, \"drm device is not available, no shutdown\\n\");\n\t\treturn;\n\t}\n\n\tdrm_atomic_helper_shutdown(drm);\n}\n\nstatic const struct of_device_id drm_match_table[] = {\n\t{ .compatible = \"sprd,display-subsystem\", },\n\t{   },\n};\nMODULE_DEVICE_TABLE(of, drm_match_table);\n\nstatic struct platform_driver sprd_drm_driver = {\n\t.probe = sprd_drm_probe,\n\t.remove = sprd_drm_remove,\n\t.shutdown = sprd_drm_shutdown,\n\t.driver = {\n\t\t.name = \"sprd-drm-drv\",\n\t\t.of_match_table = drm_match_table,\n\t},\n};\n\nstatic struct platform_driver *sprd_drm_drivers[]  = {\n\t&sprd_drm_driver,\n\t&sprd_dpu_driver,\n\t&sprd_dsi_driver,\n};\n\nstatic int __init sprd_drm_init(void)\n{\n\tif (drm_firmware_drivers_only())\n\t\treturn -ENODEV;\n\n\treturn platform_register_drivers(sprd_drm_drivers,\n\t\t\t\t\tARRAY_SIZE(sprd_drm_drivers));\n}\n\nstatic void __exit sprd_drm_exit(void)\n{\n\tplatform_unregister_drivers(sprd_drm_drivers,\n\t\t\t\t    ARRAY_SIZE(sprd_drm_drivers));\n}\n\nmodule_init(sprd_drm_init);\nmodule_exit(sprd_drm_exit);\n\nMODULE_AUTHOR(\"Leon He <leon.he@unisoc.com>\");\nMODULE_AUTHOR(\"Kevin Tang <kevin.tang@unisoc.com>\");\nMODULE_DESCRIPTION(\"Unisoc DRM KMS Master Driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}