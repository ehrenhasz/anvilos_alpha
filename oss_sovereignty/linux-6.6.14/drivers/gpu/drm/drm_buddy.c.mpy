{
  "module_name": "drm_buddy.c",
  "hash_id": "066895a4ecb933c799f78444ec73154f7334ffefbfa2b3bd24d1545985b6e2b2",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/drm_buddy.c",
  "human_readable_source": "\n \n\n#include <linux/kmemleak.h>\n#include <linux/module.h>\n#include <linux/sizes.h>\n\n#include <drm/drm_buddy.h>\n\nstatic struct kmem_cache *slab_blocks;\n\nstatic struct drm_buddy_block *drm_block_alloc(struct drm_buddy *mm,\n\t\t\t\t\t       struct drm_buddy_block *parent,\n\t\t\t\t\t       unsigned int order,\n\t\t\t\t\t       u64 offset)\n{\n\tstruct drm_buddy_block *block;\n\n\tBUG_ON(order > DRM_BUDDY_MAX_ORDER);\n\n\tblock = kmem_cache_zalloc(slab_blocks, GFP_KERNEL);\n\tif (!block)\n\t\treturn NULL;\n\n\tblock->header = offset;\n\tblock->header |= order;\n\tblock->parent = parent;\n\n\tBUG_ON(block->header & DRM_BUDDY_HEADER_UNUSED);\n\treturn block;\n}\n\nstatic void drm_block_free(struct drm_buddy *mm,\n\t\t\t   struct drm_buddy_block *block)\n{\n\tkmem_cache_free(slab_blocks, block);\n}\n\nstatic void list_insert_sorted(struct drm_buddy *mm,\n\t\t\t       struct drm_buddy_block *block)\n{\n\tstruct drm_buddy_block *node;\n\tstruct list_head *head;\n\n\thead = &mm->free_list[drm_buddy_block_order(block)];\n\tif (list_empty(head)) {\n\t\tlist_add(&block->link, head);\n\t\treturn;\n\t}\n\n\tlist_for_each_entry(node, head, link)\n\t\tif (drm_buddy_block_offset(block) < drm_buddy_block_offset(node))\n\t\t\tbreak;\n\n\t__list_add(&block->link, node->link.prev, &node->link);\n}\n\nstatic void mark_allocated(struct drm_buddy_block *block)\n{\n\tblock->header &= ~DRM_BUDDY_HEADER_STATE;\n\tblock->header |= DRM_BUDDY_ALLOCATED;\n\n\tlist_del(&block->link);\n}\n\nstatic void mark_free(struct drm_buddy *mm,\n\t\t      struct drm_buddy_block *block)\n{\n\tblock->header &= ~DRM_BUDDY_HEADER_STATE;\n\tblock->header |= DRM_BUDDY_FREE;\n\n\tlist_insert_sorted(mm, block);\n}\n\nstatic void mark_split(struct drm_buddy_block *block)\n{\n\tblock->header &= ~DRM_BUDDY_HEADER_STATE;\n\tblock->header |= DRM_BUDDY_SPLIT;\n\n\tlist_del(&block->link);\n}\n\n \nint drm_buddy_init(struct drm_buddy *mm, u64 size, u64 chunk_size)\n{\n\tunsigned int i;\n\tu64 offset;\n\n\tif (size < chunk_size)\n\t\treturn -EINVAL;\n\n\tif (chunk_size < PAGE_SIZE)\n\t\treturn -EINVAL;\n\n\tif (!is_power_of_2(chunk_size))\n\t\treturn -EINVAL;\n\n\tsize = round_down(size, chunk_size);\n\n\tmm->size = size;\n\tmm->avail = size;\n\tmm->chunk_size = chunk_size;\n\tmm->max_order = ilog2(size) - ilog2(chunk_size);\n\n\tBUG_ON(mm->max_order > DRM_BUDDY_MAX_ORDER);\n\n\tmm->free_list = kmalloc_array(mm->max_order + 1,\n\t\t\t\t      sizeof(struct list_head),\n\t\t\t\t      GFP_KERNEL);\n\tif (!mm->free_list)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i <= mm->max_order; ++i)\n\t\tINIT_LIST_HEAD(&mm->free_list[i]);\n\n\tmm->n_roots = hweight64(size);\n\n\tmm->roots = kmalloc_array(mm->n_roots,\n\t\t\t\t  sizeof(struct drm_buddy_block *),\n\t\t\t\t  GFP_KERNEL);\n\tif (!mm->roots)\n\t\tgoto out_free_list;\n\n\toffset = 0;\n\ti = 0;\n\n\t \n\tdo {\n\t\tstruct drm_buddy_block *root;\n\t\tunsigned int order;\n\t\tu64 root_size;\n\n\t\torder = ilog2(size) - ilog2(chunk_size);\n\t\troot_size = chunk_size << order;\n\n\t\troot = drm_block_alloc(mm, NULL, order, offset);\n\t\tif (!root)\n\t\t\tgoto out_free_roots;\n\n\t\tmark_free(mm, root);\n\n\t\tBUG_ON(i > mm->max_order);\n\t\tBUG_ON(drm_buddy_block_size(mm, root) < chunk_size);\n\n\t\tmm->roots[i] = root;\n\n\t\toffset += root_size;\n\t\tsize -= root_size;\n\t\ti++;\n\t} while (size);\n\n\treturn 0;\n\nout_free_roots:\n\twhile (i--)\n\t\tdrm_block_free(mm, mm->roots[i]);\n\tkfree(mm->roots);\nout_free_list:\n\tkfree(mm->free_list);\n\treturn -ENOMEM;\n}\nEXPORT_SYMBOL(drm_buddy_init);\n\n \nvoid drm_buddy_fini(struct drm_buddy *mm)\n{\n\tint i;\n\n\tfor (i = 0; i < mm->n_roots; ++i) {\n\t\tWARN_ON(!drm_buddy_block_is_free(mm->roots[i]));\n\t\tdrm_block_free(mm, mm->roots[i]);\n\t}\n\n\tWARN_ON(mm->avail != mm->size);\n\n\tkfree(mm->roots);\n\tkfree(mm->free_list);\n}\nEXPORT_SYMBOL(drm_buddy_fini);\n\nstatic int split_block(struct drm_buddy *mm,\n\t\t       struct drm_buddy_block *block)\n{\n\tunsigned int block_order = drm_buddy_block_order(block) - 1;\n\tu64 offset = drm_buddy_block_offset(block);\n\n\tBUG_ON(!drm_buddy_block_is_free(block));\n\tBUG_ON(!drm_buddy_block_order(block));\n\n\tblock->left = drm_block_alloc(mm, block, block_order, offset);\n\tif (!block->left)\n\t\treturn -ENOMEM;\n\n\tblock->right = drm_block_alloc(mm, block, block_order,\n\t\t\t\t       offset + (mm->chunk_size << block_order));\n\tif (!block->right) {\n\t\tdrm_block_free(mm, block->left);\n\t\treturn -ENOMEM;\n\t}\n\n\tmark_free(mm, block->left);\n\tmark_free(mm, block->right);\n\n\tmark_split(block);\n\n\treturn 0;\n}\n\nstatic struct drm_buddy_block *\n__get_buddy(struct drm_buddy_block *block)\n{\n\tstruct drm_buddy_block *parent;\n\n\tparent = block->parent;\n\tif (!parent)\n\t\treturn NULL;\n\n\tif (parent->left == block)\n\t\treturn parent->right;\n\n\treturn parent->left;\n}\n\n \nstruct drm_buddy_block *\ndrm_get_buddy(struct drm_buddy_block *block)\n{\n\treturn __get_buddy(block);\n}\nEXPORT_SYMBOL(drm_get_buddy);\n\nstatic void __drm_buddy_free(struct drm_buddy *mm,\n\t\t\t     struct drm_buddy_block *block)\n{\n\tstruct drm_buddy_block *parent;\n\n\twhile ((parent = block->parent)) {\n\t\tstruct drm_buddy_block *buddy;\n\n\t\tbuddy = __get_buddy(block);\n\n\t\tif (!drm_buddy_block_is_free(buddy))\n\t\t\tbreak;\n\n\t\tlist_del(&buddy->link);\n\n\t\tdrm_block_free(mm, block);\n\t\tdrm_block_free(mm, buddy);\n\n\t\tblock = parent;\n\t}\n\n\tmark_free(mm, block);\n}\n\n \nvoid drm_buddy_free_block(struct drm_buddy *mm,\n\t\t\t  struct drm_buddy_block *block)\n{\n\tBUG_ON(!drm_buddy_block_is_allocated(block));\n\tmm->avail += drm_buddy_block_size(mm, block);\n\t__drm_buddy_free(mm, block);\n}\nEXPORT_SYMBOL(drm_buddy_free_block);\n\n \nvoid drm_buddy_free_list(struct drm_buddy *mm, struct list_head *objects)\n{\n\tstruct drm_buddy_block *block, *on;\n\n\tlist_for_each_entry_safe(block, on, objects, link) {\n\t\tdrm_buddy_free_block(mm, block);\n\t\tcond_resched();\n\t}\n\tINIT_LIST_HEAD(objects);\n}\nEXPORT_SYMBOL(drm_buddy_free_list);\n\nstatic inline bool overlaps(u64 s1, u64 e1, u64 s2, u64 e2)\n{\n\treturn s1 <= e2 && e1 >= s2;\n}\n\nstatic inline bool contains(u64 s1, u64 e1, u64 s2, u64 e2)\n{\n\treturn s1 <= s2 && e1 >= e2;\n}\n\nstatic struct drm_buddy_block *\nalloc_range_bias(struct drm_buddy *mm,\n\t\t u64 start, u64 end,\n\t\t unsigned int order)\n{\n\tstruct drm_buddy_block *block;\n\tstruct drm_buddy_block *buddy;\n\tLIST_HEAD(dfs);\n\tint err;\n\tint i;\n\n\tend = end - 1;\n\n\tfor (i = 0; i < mm->n_roots; ++i)\n\t\tlist_add_tail(&mm->roots[i]->tmp_link, &dfs);\n\n\tdo {\n\t\tu64 block_start;\n\t\tu64 block_end;\n\n\t\tblock = list_first_entry_or_null(&dfs,\n\t\t\t\t\t\t struct drm_buddy_block,\n\t\t\t\t\t\t tmp_link);\n\t\tif (!block)\n\t\t\tbreak;\n\n\t\tlist_del(&block->tmp_link);\n\n\t\tif (drm_buddy_block_order(block) < order)\n\t\t\tcontinue;\n\n\t\tblock_start = drm_buddy_block_offset(block);\n\t\tblock_end = block_start + drm_buddy_block_size(mm, block) - 1;\n\n\t\tif (!overlaps(start, end, block_start, block_end))\n\t\t\tcontinue;\n\n\t\tif (drm_buddy_block_is_allocated(block))\n\t\t\tcontinue;\n\n\t\tif (contains(start, end, block_start, block_end) &&\n\t\t    order == drm_buddy_block_order(block)) {\n\t\t\t \n\t\t\tif (drm_buddy_block_is_free(block))\n\t\t\t\treturn block;\n\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!drm_buddy_block_is_split(block)) {\n\t\t\terr = split_block(mm, block);\n\t\t\tif (unlikely(err))\n\t\t\t\tgoto err_undo;\n\t\t}\n\n\t\tlist_add(&block->right->tmp_link, &dfs);\n\t\tlist_add(&block->left->tmp_link, &dfs);\n\t} while (1);\n\n\treturn ERR_PTR(-ENOSPC);\n\nerr_undo:\n\t \n\tbuddy = __get_buddy(block);\n\tif (buddy &&\n\t    (drm_buddy_block_is_free(block) &&\n\t     drm_buddy_block_is_free(buddy)))\n\t\t__drm_buddy_free(mm, block);\n\treturn ERR_PTR(err);\n}\n\nstatic struct drm_buddy_block *\nget_maxblock(struct drm_buddy *mm, unsigned int order)\n{\n\tstruct drm_buddy_block *max_block = NULL, *node;\n\tunsigned int i;\n\n\tfor (i = order; i <= mm->max_order; ++i) {\n\t\tif (!list_empty(&mm->free_list[i])) {\n\t\t\tnode = list_last_entry(&mm->free_list[i],\n\t\t\t\t\t       struct drm_buddy_block,\n\t\t\t\t\t       link);\n\t\t\tif (!max_block) {\n\t\t\t\tmax_block = node;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (drm_buddy_block_offset(node) >\n\t\t\t    drm_buddy_block_offset(max_block)) {\n\t\t\t\tmax_block = node;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn max_block;\n}\n\nstatic struct drm_buddy_block *\nalloc_from_freelist(struct drm_buddy *mm,\n\t\t    unsigned int order,\n\t\t    unsigned long flags)\n{\n\tstruct drm_buddy_block *block = NULL;\n\tunsigned int tmp;\n\tint err;\n\n\tif (flags & DRM_BUDDY_TOPDOWN_ALLOCATION) {\n\t\tblock = get_maxblock(mm, order);\n\t\tif (block)\n\t\t\t \n\t\t\ttmp = drm_buddy_block_order(block);\n\t} else {\n\t\tfor (tmp = order; tmp <= mm->max_order; ++tmp) {\n\t\t\tif (!list_empty(&mm->free_list[tmp])) {\n\t\t\t\tblock = list_last_entry(&mm->free_list[tmp],\n\t\t\t\t\t\t\tstruct drm_buddy_block,\n\t\t\t\t\t\t\tlink);\n\t\t\t\tif (block)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (!block)\n\t\treturn ERR_PTR(-ENOSPC);\n\n\tBUG_ON(!drm_buddy_block_is_free(block));\n\n\twhile (tmp != order) {\n\t\terr = split_block(mm, block);\n\t\tif (unlikely(err))\n\t\t\tgoto err_undo;\n\n\t\tblock = block->right;\n\t\ttmp--;\n\t}\n\treturn block;\n\nerr_undo:\n\tif (tmp != order)\n\t\t__drm_buddy_free(mm, block);\n\treturn ERR_PTR(err);\n}\n\nstatic int __alloc_range(struct drm_buddy *mm,\n\t\t\t struct list_head *dfs,\n\t\t\t u64 start, u64 size,\n\t\t\t struct list_head *blocks)\n{\n\tstruct drm_buddy_block *block;\n\tstruct drm_buddy_block *buddy;\n\tLIST_HEAD(allocated);\n\tu64 end;\n\tint err;\n\n\tend = start + size - 1;\n\n\tdo {\n\t\tu64 block_start;\n\t\tu64 block_end;\n\n\t\tblock = list_first_entry_or_null(dfs,\n\t\t\t\t\t\t struct drm_buddy_block,\n\t\t\t\t\t\t tmp_link);\n\t\tif (!block)\n\t\t\tbreak;\n\n\t\tlist_del(&block->tmp_link);\n\n\t\tblock_start = drm_buddy_block_offset(block);\n\t\tblock_end = block_start + drm_buddy_block_size(mm, block) - 1;\n\n\t\tif (!overlaps(start, end, block_start, block_end))\n\t\t\tcontinue;\n\n\t\tif (drm_buddy_block_is_allocated(block)) {\n\t\t\terr = -ENOSPC;\n\t\t\tgoto err_free;\n\t\t}\n\n\t\tif (contains(start, end, block_start, block_end)) {\n\t\t\tif (!drm_buddy_block_is_free(block)) {\n\t\t\t\terr = -ENOSPC;\n\t\t\t\tgoto err_free;\n\t\t\t}\n\n\t\t\tmark_allocated(block);\n\t\t\tmm->avail -= drm_buddy_block_size(mm, block);\n\t\t\tlist_add_tail(&block->link, &allocated);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!drm_buddy_block_is_split(block)) {\n\t\t\terr = split_block(mm, block);\n\t\t\tif (unlikely(err))\n\t\t\t\tgoto err_undo;\n\t\t}\n\n\t\tlist_add(&block->right->tmp_link, dfs);\n\t\tlist_add(&block->left->tmp_link, dfs);\n\t} while (1);\n\n\tlist_splice_tail(&allocated, blocks);\n\treturn 0;\n\nerr_undo:\n\t \n\tbuddy = __get_buddy(block);\n\tif (buddy &&\n\t    (drm_buddy_block_is_free(block) &&\n\t     drm_buddy_block_is_free(buddy)))\n\t\t__drm_buddy_free(mm, block);\n\nerr_free:\n\tdrm_buddy_free_list(mm, &allocated);\n\treturn err;\n}\n\nstatic int __drm_buddy_alloc_range(struct drm_buddy *mm,\n\t\t\t\t   u64 start,\n\t\t\t\t   u64 size,\n\t\t\t\t   struct list_head *blocks)\n{\n\tLIST_HEAD(dfs);\n\tint i;\n\n\tfor (i = 0; i < mm->n_roots; ++i)\n\t\tlist_add_tail(&mm->roots[i]->tmp_link, &dfs);\n\n\treturn __alloc_range(mm, &dfs, start, size, blocks);\n}\n\n \nint drm_buddy_block_trim(struct drm_buddy *mm,\n\t\t\t u64 new_size,\n\t\t\t struct list_head *blocks)\n{\n\tstruct drm_buddy_block *parent;\n\tstruct drm_buddy_block *block;\n\tLIST_HEAD(dfs);\n\tu64 new_start;\n\tint err;\n\n\tif (!list_is_singular(blocks))\n\t\treturn -EINVAL;\n\n\tblock = list_first_entry(blocks,\n\t\t\t\t struct drm_buddy_block,\n\t\t\t\t link);\n\n\tif (WARN_ON(!drm_buddy_block_is_allocated(block)))\n\t\treturn -EINVAL;\n\n\tif (new_size > drm_buddy_block_size(mm, block))\n\t\treturn -EINVAL;\n\n\tif (!new_size || !IS_ALIGNED(new_size, mm->chunk_size))\n\t\treturn -EINVAL;\n\n\tif (new_size == drm_buddy_block_size(mm, block))\n\t\treturn 0;\n\n\tlist_del(&block->link);\n\tmark_free(mm, block);\n\tmm->avail += drm_buddy_block_size(mm, block);\n\n\t \n\tparent = block->parent;\n\tblock->parent = NULL;\n\n\tnew_start = drm_buddy_block_offset(block);\n\tlist_add(&block->tmp_link, &dfs);\n\terr =  __alloc_range(mm, &dfs, new_start, new_size, blocks);\n\tif (err) {\n\t\tmark_allocated(block);\n\t\tmm->avail -= drm_buddy_block_size(mm, block);\n\t\tlist_add(&block->link, blocks);\n\t}\n\n\tblock->parent = parent;\n\treturn err;\n}\nEXPORT_SYMBOL(drm_buddy_block_trim);\n\n \nint drm_buddy_alloc_blocks(struct drm_buddy *mm,\n\t\t\t   u64 start, u64 end, u64 size,\n\t\t\t   u64 min_page_size,\n\t\t\t   struct list_head *blocks,\n\t\t\t   unsigned long flags)\n{\n\tstruct drm_buddy_block *block = NULL;\n\tunsigned int min_order, order;\n\tunsigned long pages;\n\tLIST_HEAD(allocated);\n\tint err;\n\n\tif (size < mm->chunk_size)\n\t\treturn -EINVAL;\n\n\tif (min_page_size < mm->chunk_size)\n\t\treturn -EINVAL;\n\n\tif (!is_power_of_2(min_page_size))\n\t\treturn -EINVAL;\n\n\tif (!IS_ALIGNED(start | end | size, mm->chunk_size))\n\t\treturn -EINVAL;\n\n\tif (end > mm->size)\n\t\treturn -EINVAL;\n\n\tif (range_overflows(start, size, mm->size))\n\t\treturn -EINVAL;\n\n\t \n\tif (start + size == end)\n\t\treturn __drm_buddy_alloc_range(mm, start, size, blocks);\n\n\tif (!IS_ALIGNED(size, min_page_size))\n\t\treturn -EINVAL;\n\n\tpages = size >> ilog2(mm->chunk_size);\n\torder = fls(pages) - 1;\n\tmin_order = ilog2(min_page_size) - ilog2(mm->chunk_size);\n\n\tdo {\n\t\torder = min(order, (unsigned int)fls(pages) - 1);\n\t\tBUG_ON(order > mm->max_order);\n\t\tBUG_ON(order < min_order);\n\n\t\tdo {\n\t\t\tif (flags & DRM_BUDDY_RANGE_ALLOCATION)\n\t\t\t\t \n\t\t\t\tblock = alloc_range_bias(mm, start, end, order);\n\t\t\telse\n\t\t\t\t \n\t\t\t\tblock = alloc_from_freelist(mm, order, flags);\n\n\t\t\tif (!IS_ERR(block))\n\t\t\t\tbreak;\n\n\t\t\tif (order-- == min_order) {\n\t\t\t\terr = -ENOSPC;\n\t\t\t\tgoto err_free;\n\t\t\t}\n\t\t} while (1);\n\n\t\tmark_allocated(block);\n\t\tmm->avail -= drm_buddy_block_size(mm, block);\n\t\tkmemleak_update_trace(block);\n\t\tlist_add_tail(&block->link, &allocated);\n\n\t\tpages -= BIT(order);\n\n\t\tif (!pages)\n\t\t\tbreak;\n\t} while (1);\n\n\tlist_splice_tail(&allocated, blocks);\n\treturn 0;\n\nerr_free:\n\tdrm_buddy_free_list(mm, &allocated);\n\treturn err;\n}\nEXPORT_SYMBOL(drm_buddy_alloc_blocks);\n\n \nvoid drm_buddy_block_print(struct drm_buddy *mm,\n\t\t\t   struct drm_buddy_block *block,\n\t\t\t   struct drm_printer *p)\n{\n\tu64 start = drm_buddy_block_offset(block);\n\tu64 size = drm_buddy_block_size(mm, block);\n\n\tdrm_printf(p, \"%#018llx-%#018llx: %llu\\n\", start, start + size, size);\n}\nEXPORT_SYMBOL(drm_buddy_block_print);\n\n \nvoid drm_buddy_print(struct drm_buddy *mm, struct drm_printer *p)\n{\n\tint order;\n\n\tdrm_printf(p, \"chunk_size: %lluKiB, total: %lluMiB, free: %lluMiB\\n\",\n\t\t   mm->chunk_size >> 10, mm->size >> 20, mm->avail >> 20);\n\n\tfor (order = mm->max_order; order >= 0; order--) {\n\t\tstruct drm_buddy_block *block;\n\t\tu64 count = 0, free;\n\n\t\tlist_for_each_entry(block, &mm->free_list[order], link) {\n\t\t\tBUG_ON(!drm_buddy_block_is_free(block));\n\t\t\tcount++;\n\t\t}\n\n\t\tdrm_printf(p, \"order-%2d \", order);\n\n\t\tfree = count * (mm->chunk_size << order);\n\t\tif (free < SZ_1M)\n\t\t\tdrm_printf(p, \"free: %8llu KiB\", free >> 10);\n\t\telse\n\t\t\tdrm_printf(p, \"free: %8llu MiB\", free >> 20);\n\n\t\tdrm_printf(p, \", blocks: %llu\\n\", count);\n\t}\n}\nEXPORT_SYMBOL(drm_buddy_print);\n\nstatic void drm_buddy_module_exit(void)\n{\n\tkmem_cache_destroy(slab_blocks);\n}\n\nstatic int __init drm_buddy_module_init(void)\n{\n\tslab_blocks = KMEM_CACHE(drm_buddy_block, 0);\n\tif (!slab_blocks)\n\t\treturn -ENOMEM;\n\n\treturn 0;\n}\n\nmodule_init(drm_buddy_module_init);\nmodule_exit(drm_buddy_module_exit);\n\nMODULE_DESCRIPTION(\"DRM Buddy Allocator\");\nMODULE_LICENSE(\"Dual MIT/GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}