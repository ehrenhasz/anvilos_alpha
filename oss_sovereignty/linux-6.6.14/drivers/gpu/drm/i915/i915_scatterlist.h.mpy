{
  "module_name": "i915_scatterlist.h",
  "hash_id": "d046a8cddba453cff4cf636058bd69a005861e93d59a5749c6cb287375f019fc",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/i915/i915_scatterlist.h",
  "human_readable_source": " \n\n#ifndef I915_SCATTERLIST_H\n#define I915_SCATTERLIST_H\n\n#include <linux/pfn.h>\n#include <linux/scatterlist.h>\n#include <linux/dma-mapping.h>\n#include <xen/xen.h>\n\n#include \"i915_gem.h\"\n\nstruct drm_mm_node;\nstruct ttm_resource;\n\n \nstatic __always_inline struct sgt_iter {\n\tstruct scatterlist *sgp;\n\tunion {\n\t\tunsigned long pfn;\n\t\tdma_addr_t dma;\n\t};\n\tunsigned int curr;\n\tunsigned int max;\n} __sgt_iter(struct scatterlist *sgl, bool dma) {\n\tstruct sgt_iter s = { .sgp = sgl };\n\n\tif (dma && s.sgp && sg_dma_len(s.sgp) == 0) {\n\t\ts.sgp = NULL;\n\t} else if (s.sgp) {\n\t\ts.max = s.curr = s.sgp->offset;\n\t\tif (dma) {\n\t\t\ts.dma = sg_dma_address(s.sgp);\n\t\t\ts.max += sg_dma_len(s.sgp);\n\t\t} else {\n\t\t\ts.pfn = page_to_pfn(sg_page(s.sgp));\n\t\t\ts.max += s.sgp->length;\n\t\t}\n\t}\n\n\treturn s;\n}\n\nstatic inline int __sg_page_count(const struct scatterlist *sg)\n{\n\treturn sg->length >> PAGE_SHIFT;\n}\n\nstatic inline int __sg_dma_page_count(const struct scatterlist *sg)\n{\n\treturn sg_dma_len(sg) >> PAGE_SHIFT;\n}\n\nstatic inline struct scatterlist *____sg_next(struct scatterlist *sg)\n{\n\t++sg;\n\tif (unlikely(sg_is_chain(sg)))\n\t\tsg = sg_chain_ptr(sg);\n\treturn sg;\n}\n\n \nstatic inline struct scatterlist *__sg_next(struct scatterlist *sg)\n{\n\treturn sg_is_last(sg) ? NULL : ____sg_next(sg);\n}\n\n \n#define __for_each_sgt_daddr(__dp, __iter, __sgt, __step)\t\t\\\n\tfor ((__iter) = __sgt_iter((__sgt)->sgl, true);\t\t\t\\\n\t     ((__dp) = (__iter).dma + (__iter).curr), (__iter).sgp;\t\\\n\t     (((__iter).curr += (__step)) >= (__iter).max) ?\t\t\\\n\t     (__iter) = __sgt_iter(__sg_next((__iter).sgp), true), 0 : 0)\n\n \n#define for_each_sgt_page(__pp, __iter, __sgt)\t\t\t\t\\\n\tfor ((__iter) = __sgt_iter((__sgt)->sgl, false);\t\t\\\n\t     ((__pp) = (__iter).pfn == 0 ? NULL :\t\t\t\\\n\t      pfn_to_page((__iter).pfn + ((__iter).curr >> PAGE_SHIFT))); \\\n\t     (((__iter).curr += PAGE_SIZE) >= (__iter).max) ?\t\t\\\n\t     (__iter) = __sgt_iter(__sg_next((__iter).sgp), false), 0 : 0)\n\n \nstatic inline unsigned int i915_sg_dma_sizes(struct scatterlist *sg)\n{\n\tunsigned int page_sizes;\n\n\tpage_sizes = 0;\n\twhile (sg && sg_dma_len(sg)) {\n\t\tGEM_BUG_ON(sg->offset);\n\t\tGEM_BUG_ON(!IS_ALIGNED(sg_dma_len(sg), PAGE_SIZE));\n\t\tpage_sizes |= sg_dma_len(sg);\n\t\tsg = __sg_next(sg);\n\t}\n\n\treturn page_sizes;\n}\n\nstatic inline unsigned int i915_sg_segment_size(struct device *dev)\n{\n\tsize_t max = min_t(size_t, UINT_MAX, dma_max_mapping_size(dev));\n\n\t \n\tif (xen_pv_domain())\n\t\tmax = PAGE_SIZE;\n\treturn round_down(max, PAGE_SIZE);\n}\n\nbool i915_sg_trim(struct sg_table *orig_st);\n\n \nstruct i915_refct_sgt_ops {\n\t \n\tvoid (*release)(struct kref *ref);\n};\n\n \nstruct i915_refct_sgt {\n\tstruct kref kref;\n\tstruct sg_table table;\n\tsize_t size;\n\tconst struct i915_refct_sgt_ops *ops;\n};\n\n \nstatic inline void i915_refct_sgt_put(struct i915_refct_sgt *rsgt)\n{\n\tif (rsgt)\n\t\tkref_put(&rsgt->kref, rsgt->ops->release);\n}\n\n \nstatic inline struct i915_refct_sgt *\ni915_refct_sgt_get(struct i915_refct_sgt *rsgt)\n{\n\tkref_get(&rsgt->kref);\n\treturn rsgt;\n}\n\n \nstatic inline void __i915_refct_sgt_init(struct i915_refct_sgt *rsgt,\n\t\t\t\t\t size_t size,\n\t\t\t\t\t const struct i915_refct_sgt_ops *ops)\n{\n\tkref_init(&rsgt->kref);\n\trsgt->table.sgl = NULL;\n\trsgt->size = size;\n\trsgt->ops = ops;\n}\n\nvoid i915_refct_sgt_init(struct i915_refct_sgt *rsgt, size_t size);\n\nstruct i915_refct_sgt *i915_rsgt_from_mm_node(const struct drm_mm_node *node,\n\t\t\t\t\t      u64 region_start,\n\t\t\t\t\t      u32 page_alignment);\n\nstruct i915_refct_sgt *i915_rsgt_from_buddy_resource(struct ttm_resource *res,\n\t\t\t\t\t\t     u64 region_start,\n\t\t\t\t\t\t     u32 page_alignment);\n\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}