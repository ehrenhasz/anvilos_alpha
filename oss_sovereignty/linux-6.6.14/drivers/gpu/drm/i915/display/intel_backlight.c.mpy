{
  "module_name": "intel_backlight.c",
  "hash_id": "3168d996777b1546d0edb25840c7320598aece13fc3c8b0dd43f866153817184",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/i915/display/intel_backlight.c",
  "human_readable_source": "\n \n\n#include <linux/backlight.h>\n#include <linux/kernel.h>\n#include <linux/pwm.h>\n#include <linux/string_helpers.h>\n\n#include <acpi/video.h>\n\n#include \"i915_reg.h\"\n#include \"intel_backlight.h\"\n#include \"intel_backlight_regs.h\"\n#include \"intel_connector.h\"\n#include \"intel_de.h\"\n#include \"intel_display_types.h\"\n#include \"intel_dp_aux_backlight.h\"\n#include \"intel_dsi_dcs_backlight.h\"\n#include \"intel_panel.h\"\n#include \"intel_pci_config.h\"\n#include \"intel_pps.h\"\n#include \"intel_quirks.h\"\n\n \nstatic u32 scale(u32 source_val,\n\t\t u32 source_min, u32 source_max,\n\t\t u32 target_min, u32 target_max)\n{\n\tu64 target_val;\n\n\tWARN_ON(source_min > source_max);\n\tWARN_ON(target_min > target_max);\n\n\t \n\tsource_val = clamp(source_val, source_min, source_max);\n\n\t \n\ttarget_val = mul_u32_u32(source_val - source_min,\n\t\t\t\t target_max - target_min);\n\ttarget_val = DIV_ROUND_CLOSEST_ULL(target_val, source_max - source_min);\n\ttarget_val += target_min;\n\n\treturn target_val;\n}\n\n \nstatic u32 clamp_user_to_hw(struct intel_connector *connector,\n\t\t\t    u32 user_level, u32 user_max)\n{\n\tstruct intel_panel *panel = &connector->panel;\n\tu32 hw_level;\n\n\thw_level = scale(user_level, 0, user_max, 0, panel->backlight.max);\n\thw_level = clamp(hw_level, panel->backlight.min, panel->backlight.max);\n\n\treturn hw_level;\n}\n\n \nstatic u32 scale_hw_to_user(struct intel_connector *connector,\n\t\t\t    u32 hw_level, u32 user_max)\n{\n\tstruct intel_panel *panel = &connector->panel;\n\n\treturn scale(hw_level, panel->backlight.min, panel->backlight.max,\n\t\t     0, user_max);\n}\n\nu32 intel_backlight_invert_pwm_level(struct intel_connector *connector, u32 val)\n{\n\tstruct drm_i915_private *i915 = to_i915(connector->base.dev);\n\tstruct intel_panel *panel = &connector->panel;\n\n\tdrm_WARN_ON(&i915->drm, panel->backlight.pwm_level_max == 0);\n\n\tif (i915->params.invert_brightness < 0)\n\t\treturn val;\n\n\tif (i915->params.invert_brightness > 0 ||\n\t    intel_has_quirk(i915, QUIRK_INVERT_BRIGHTNESS)) {\n\t\treturn panel->backlight.pwm_level_max - val + panel->backlight.pwm_level_min;\n\t}\n\n\treturn val;\n}\n\nvoid intel_backlight_set_pwm_level(const struct drm_connector_state *conn_state, u32 val)\n{\n\tstruct intel_connector *connector = to_intel_connector(conn_state->connector);\n\tstruct drm_i915_private *i915 = to_i915(connector->base.dev);\n\tstruct intel_panel *panel = &connector->panel;\n\n\tdrm_dbg_kms(&i915->drm, \"[CONNECTOR:%d:%s] set backlight PWM = %d\\n\",\n\t\t    connector->base.base.id, connector->base.name, val);\n\tpanel->backlight.pwm_funcs->set(conn_state, val);\n}\n\nu32 intel_backlight_level_to_pwm(struct intel_connector *connector, u32 val)\n{\n\tstruct drm_i915_private *i915 = to_i915(connector->base.dev);\n\tstruct intel_panel *panel = &connector->panel;\n\n\tdrm_WARN_ON_ONCE(&i915->drm,\n\t\t\t panel->backlight.max == 0 || panel->backlight.pwm_level_max == 0);\n\n\tval = scale(val, panel->backlight.min, panel->backlight.max,\n\t\t    panel->backlight.pwm_level_min, panel->backlight.pwm_level_max);\n\n\treturn intel_backlight_invert_pwm_level(connector, val);\n}\n\nu32 intel_backlight_level_from_pwm(struct intel_connector *connector, u32 val)\n{\n\tstruct drm_i915_private *i915 = to_i915(connector->base.dev);\n\tstruct intel_panel *panel = &connector->panel;\n\n\tdrm_WARN_ON_ONCE(&i915->drm,\n\t\t\t panel->backlight.max == 0 || panel->backlight.pwm_level_max == 0);\n\n\tif (i915->params.invert_brightness > 0 ||\n\t    (i915->params.invert_brightness == 0 && intel_has_quirk(i915, QUIRK_INVERT_BRIGHTNESS)))\n\t\tval = panel->backlight.pwm_level_max - (val - panel->backlight.pwm_level_min);\n\n\treturn scale(val, panel->backlight.pwm_level_min, panel->backlight.pwm_level_max,\n\t\t     panel->backlight.min, panel->backlight.max);\n}\n\nstatic u32 lpt_get_backlight(struct intel_connector *connector, enum pipe unused)\n{\n\tstruct drm_i915_private *i915 = to_i915(connector->base.dev);\n\n\treturn intel_de_read(i915, BLC_PWM_PCH_CTL2) & BACKLIGHT_DUTY_CYCLE_MASK;\n}\n\nstatic u32 pch_get_backlight(struct intel_connector *connector, enum pipe unused)\n{\n\tstruct drm_i915_private *i915 = to_i915(connector->base.dev);\n\n\treturn intel_de_read(i915, BLC_PWM_CPU_CTL) & BACKLIGHT_DUTY_CYCLE_MASK;\n}\n\nstatic u32 i9xx_get_backlight(struct intel_connector *connector, enum pipe unused)\n{\n\tstruct drm_i915_private *i915 = to_i915(connector->base.dev);\n\tstruct intel_panel *panel = &connector->panel;\n\tu32 val;\n\n\tval = intel_de_read(i915, BLC_PWM_CTL) & BACKLIGHT_DUTY_CYCLE_MASK;\n\tif (DISPLAY_VER(i915) < 4)\n\t\tval >>= 1;\n\n\tif (panel->backlight.combination_mode) {\n\t\tu8 lbpc;\n\n\t\tpci_read_config_byte(to_pci_dev(i915->drm.dev), LBPC, &lbpc);\n\t\tval *= lbpc;\n\t}\n\n\treturn val;\n}\n\nstatic u32 vlv_get_backlight(struct intel_connector *connector, enum pipe pipe)\n{\n\tstruct drm_i915_private *i915 = to_i915(connector->base.dev);\n\n\tif (drm_WARN_ON(&i915->drm, pipe != PIPE_A && pipe != PIPE_B))\n\t\treturn 0;\n\n\treturn intel_de_read(i915, VLV_BLC_PWM_CTL(pipe)) & BACKLIGHT_DUTY_CYCLE_MASK;\n}\n\nstatic u32 bxt_get_backlight(struct intel_connector *connector, enum pipe unused)\n{\n\tstruct drm_i915_private *i915 = to_i915(connector->base.dev);\n\tstruct intel_panel *panel = &connector->panel;\n\n\treturn intel_de_read(i915, BXT_BLC_PWM_DUTY(panel->backlight.controller));\n}\n\nstatic u32 ext_pwm_get_backlight(struct intel_connector *connector, enum pipe unused)\n{\n\tstruct intel_panel *panel = &connector->panel;\n\tstruct pwm_state state;\n\n\tpwm_get_state(panel->backlight.pwm, &state);\n\treturn pwm_get_relative_duty_cycle(&state, 100);\n}\n\nstatic void lpt_set_backlight(const struct drm_connector_state *conn_state, u32 level)\n{\n\tstruct intel_connector *connector = to_intel_connector(conn_state->connector);\n\tstruct drm_i915_private *i915 = to_i915(connector->base.dev);\n\tu32 val;\n\n\tval = intel_de_read(i915, BLC_PWM_PCH_CTL2) & ~BACKLIGHT_DUTY_CYCLE_MASK;\n\tintel_de_write(i915, BLC_PWM_PCH_CTL2, val | level);\n}\n\nstatic void pch_set_backlight(const struct drm_connector_state *conn_state, u32 level)\n{\n\tstruct intel_connector *connector = to_intel_connector(conn_state->connector);\n\tstruct drm_i915_private *i915 = to_i915(connector->base.dev);\n\tu32 tmp;\n\n\ttmp = intel_de_read(i915, BLC_PWM_CPU_CTL) & ~BACKLIGHT_DUTY_CYCLE_MASK;\n\tintel_de_write(i915, BLC_PWM_CPU_CTL, tmp | level);\n}\n\nstatic void i9xx_set_backlight(const struct drm_connector_state *conn_state, u32 level)\n{\n\tstruct intel_connector *connector = to_intel_connector(conn_state->connector);\n\tstruct drm_i915_private *i915 = to_i915(connector->base.dev);\n\tstruct intel_panel *panel = &connector->panel;\n\tu32 tmp, mask;\n\n\tdrm_WARN_ON(&i915->drm, panel->backlight.pwm_level_max == 0);\n\n\tif (panel->backlight.combination_mode) {\n\t\tu8 lbpc;\n\n\t\tlbpc = level * 0xfe / panel->backlight.pwm_level_max + 1;\n\t\tlevel /= lbpc;\n\t\tpci_write_config_byte(to_pci_dev(i915->drm.dev), LBPC, lbpc);\n\t}\n\n\tif (DISPLAY_VER(i915) == 4) {\n\t\tmask = BACKLIGHT_DUTY_CYCLE_MASK;\n\t} else {\n\t\tlevel <<= 1;\n\t\tmask = BACKLIGHT_DUTY_CYCLE_MASK_PNV;\n\t}\n\n\ttmp = intel_de_read(i915, BLC_PWM_CTL) & ~mask;\n\tintel_de_write(i915, BLC_PWM_CTL, tmp | level);\n}\n\nstatic void vlv_set_backlight(const struct drm_connector_state *conn_state, u32 level)\n{\n\tstruct intel_connector *connector = to_intel_connector(conn_state->connector);\n\tstruct drm_i915_private *i915 = to_i915(connector->base.dev);\n\tenum pipe pipe = to_intel_crtc(conn_state->crtc)->pipe;\n\tu32 tmp;\n\n\ttmp = intel_de_read(i915, VLV_BLC_PWM_CTL(pipe)) & ~BACKLIGHT_DUTY_CYCLE_MASK;\n\tintel_de_write(i915, VLV_BLC_PWM_CTL(pipe), tmp | level);\n}\n\nstatic void bxt_set_backlight(const struct drm_connector_state *conn_state, u32 level)\n{\n\tstruct intel_connector *connector = to_intel_connector(conn_state->connector);\n\tstruct drm_i915_private *i915 = to_i915(connector->base.dev);\n\tstruct intel_panel *panel = &connector->panel;\n\n\tintel_de_write(i915, BXT_BLC_PWM_DUTY(panel->backlight.controller), level);\n}\n\nstatic void ext_pwm_set_backlight(const struct drm_connector_state *conn_state, u32 level)\n{\n\tstruct intel_panel *panel = &to_intel_connector(conn_state->connector)->panel;\n\n\tpwm_set_relative_duty_cycle(&panel->backlight.pwm_state, level, 100);\n\tpwm_apply_state(panel->backlight.pwm, &panel->backlight.pwm_state);\n}\n\nstatic void\nintel_panel_actually_set_backlight(const struct drm_connector_state *conn_state, u32 level)\n{\n\tstruct intel_connector *connector = to_intel_connector(conn_state->connector);\n\tstruct drm_i915_private *i915 = to_i915(connector->base.dev);\n\tstruct intel_panel *panel = &connector->panel;\n\n\tdrm_dbg_kms(&i915->drm, \"[CONNECTOR:%d:%s] set backlight level = %d\\n\",\n\t\t    connector->base.base.id, connector->base.name, level);\n\n\tpanel->backlight.funcs->set(conn_state, level);\n}\n\n \nvoid intel_backlight_set_acpi(const struct drm_connector_state *conn_state,\n\t\t\t      u32 user_level, u32 user_max)\n{\n\tstruct intel_connector *connector = to_intel_connector(conn_state->connector);\n\tstruct drm_i915_private *i915 = to_i915(connector->base.dev);\n\tstruct intel_panel *panel = &connector->panel;\n\tu32 hw_level;\n\n\t \n\tif (!panel->backlight.present || !conn_state->crtc)\n\t\treturn;\n\n\tmutex_lock(&i915->display.backlight.lock);\n\n\tdrm_WARN_ON(&i915->drm, panel->backlight.max == 0);\n\n\thw_level = clamp_user_to_hw(connector, user_level, user_max);\n\tpanel->backlight.level = hw_level;\n\n\tif (panel->backlight.device)\n\t\tpanel->backlight.device->props.brightness =\n\t\t\tscale_hw_to_user(connector,\n\t\t\t\t\t panel->backlight.level,\n\t\t\t\t\t panel->backlight.device->props.max_brightness);\n\n\tif (panel->backlight.enabled)\n\t\tintel_panel_actually_set_backlight(conn_state, hw_level);\n\n\tmutex_unlock(&i915->display.backlight.lock);\n}\n\nstatic void lpt_disable_backlight(const struct drm_connector_state *old_conn_state, u32 level)\n{\n\tstruct intel_connector *connector = to_intel_connector(old_conn_state->connector);\n\tstruct drm_i915_private *i915 = to_i915(connector->base.dev);\n\tu32 tmp;\n\n\tintel_backlight_set_pwm_level(old_conn_state, level);\n\n\t \n\ttmp = intel_de_read(i915, BLC_PWM_CPU_CTL2);\n\tif (tmp & BLM_PWM_ENABLE) {\n\t\tdrm_dbg_kms(&i915->drm, \"[CONNECTOR:%d:%s] CPU backlight was enabled, disabling\\n\",\n\t\t\t    connector->base.base.id, connector->base.name);\n\t\tintel_de_write(i915, BLC_PWM_CPU_CTL2, tmp & ~BLM_PWM_ENABLE);\n\t}\n\n\tintel_de_rmw(i915, BLC_PWM_PCH_CTL1, BLM_PCH_PWM_ENABLE, 0);\n}\n\nstatic void pch_disable_backlight(const struct drm_connector_state *old_conn_state, u32 val)\n{\n\tstruct intel_connector *connector = to_intel_connector(old_conn_state->connector);\n\tstruct drm_i915_private *i915 = to_i915(connector->base.dev);\n\n\tintel_backlight_set_pwm_level(old_conn_state, val);\n\n\tintel_de_rmw(i915, BLC_PWM_CPU_CTL2, BLM_PWM_ENABLE, 0);\n\n\tintel_de_rmw(i915, BLC_PWM_PCH_CTL1, BLM_PCH_PWM_ENABLE, 0);\n}\n\nstatic void i9xx_disable_backlight(const struct drm_connector_state *old_conn_state, u32 val)\n{\n\tintel_backlight_set_pwm_level(old_conn_state, val);\n}\n\nstatic void i965_disable_backlight(const struct drm_connector_state *old_conn_state, u32 val)\n{\n\tstruct drm_i915_private *i915 = to_i915(old_conn_state->connector->dev);\n\n\tintel_backlight_set_pwm_level(old_conn_state, val);\n\n\tintel_de_rmw(i915, BLC_PWM_CTL2, BLM_PWM_ENABLE, 0);\n}\n\nstatic void vlv_disable_backlight(const struct drm_connector_state *old_conn_state, u32 val)\n{\n\tstruct intel_connector *connector = to_intel_connector(old_conn_state->connector);\n\tstruct drm_i915_private *i915 = to_i915(connector->base.dev);\n\tenum pipe pipe = to_intel_crtc(old_conn_state->crtc)->pipe;\n\n\tintel_backlight_set_pwm_level(old_conn_state, val);\n\n\tintel_de_rmw(i915, VLV_BLC_PWM_CTL2(pipe), BLM_PWM_ENABLE, 0);\n}\n\nstatic void bxt_disable_backlight(const struct drm_connector_state *old_conn_state, u32 val)\n{\n\tstruct intel_connector *connector = to_intel_connector(old_conn_state->connector);\n\tstruct drm_i915_private *i915 = to_i915(connector->base.dev);\n\tstruct intel_panel *panel = &connector->panel;\n\n\tintel_backlight_set_pwm_level(old_conn_state, val);\n\n\tintel_de_rmw(i915, BXT_BLC_PWM_CTL(panel->backlight.controller),\n\t\t     BXT_BLC_PWM_ENABLE, 0);\n\n\tif (panel->backlight.controller == 1)\n\t\tintel_de_rmw(i915, UTIL_PIN_CTL, UTIL_PIN_ENABLE, 0);\n}\n\nstatic void cnp_disable_backlight(const struct drm_connector_state *old_conn_state, u32 val)\n{\n\tstruct intel_connector *connector = to_intel_connector(old_conn_state->connector);\n\tstruct drm_i915_private *i915 = to_i915(connector->base.dev);\n\tstruct intel_panel *panel = &connector->panel;\n\n\tintel_backlight_set_pwm_level(old_conn_state, val);\n\n\tintel_de_rmw(i915, BXT_BLC_PWM_CTL(panel->backlight.controller),\n\t\t     BXT_BLC_PWM_ENABLE, 0);\n}\n\nstatic void ext_pwm_disable_backlight(const struct drm_connector_state *old_conn_state, u32 level)\n{\n\tstruct intel_connector *connector = to_intel_connector(old_conn_state->connector);\n\tstruct intel_panel *panel = &connector->panel;\n\n\tintel_backlight_set_pwm_level(old_conn_state, level);\n\n\tpanel->backlight.pwm_state.enabled = false;\n\tpwm_apply_state(panel->backlight.pwm, &panel->backlight.pwm_state);\n}\n\nvoid intel_backlight_disable(const struct drm_connector_state *old_conn_state)\n{\n\tstruct intel_connector *connector = to_intel_connector(old_conn_state->connector);\n\tstruct drm_i915_private *i915 = to_i915(connector->base.dev);\n\tstruct intel_panel *panel = &connector->panel;\n\n\tif (!panel->backlight.present)\n\t\treturn;\n\n\t \n\tif (i915->drm.switch_power_state == DRM_SWITCH_POWER_CHANGING) {\n\t\tdrm_dbg_kms(&i915->drm, \"[CONNECTOR:%d:%s] Skipping backlight disable on vga switch\\n\",\n\t\t\t    connector->base.base.id, connector->base.name);\n\t\treturn;\n\t}\n\n\tmutex_lock(&i915->display.backlight.lock);\n\n\tif (panel->backlight.device)\n\t\tpanel->backlight.device->props.power = FB_BLANK_POWERDOWN;\n\tpanel->backlight.enabled = false;\n\tpanel->backlight.funcs->disable(old_conn_state, 0);\n\n\tmutex_unlock(&i915->display.backlight.lock);\n}\n\nstatic void lpt_enable_backlight(const struct intel_crtc_state *crtc_state,\n\t\t\t\t const struct drm_connector_state *conn_state, u32 level)\n{\n\tstruct intel_connector *connector = to_intel_connector(conn_state->connector);\n\tstruct drm_i915_private *i915 = to_i915(connector->base.dev);\n\tstruct intel_panel *panel = &connector->panel;\n\tu32 pch_ctl1, pch_ctl2;\n\n\tpch_ctl1 = intel_de_read(i915, BLC_PWM_PCH_CTL1);\n\tif (pch_ctl1 & BLM_PCH_PWM_ENABLE) {\n\t\tdrm_dbg_kms(&i915->drm, \"[CONNECTOR:%d:%s] PCH backlight already enabled\\n\",\n\t\t\t    connector->base.base.id, connector->base.name);\n\t\tpch_ctl1 &= ~BLM_PCH_PWM_ENABLE;\n\t\tintel_de_write(i915, BLC_PWM_PCH_CTL1, pch_ctl1);\n\t}\n\n\tif (HAS_PCH_LPT(i915))\n\t\tintel_de_rmw(i915, SOUTH_CHICKEN2, LPT_PWM_GRANULARITY,\n\t\t\t     panel->backlight.alternate_pwm_increment ?\n\t\t\t     LPT_PWM_GRANULARITY : 0);\n\telse\n\t\tintel_de_rmw(i915, SOUTH_CHICKEN1, SPT_PWM_GRANULARITY,\n\t\t\t     panel->backlight.alternate_pwm_increment ?\n\t\t\t     SPT_PWM_GRANULARITY : 0);\n\n\tpch_ctl2 = panel->backlight.pwm_level_max << 16;\n\tintel_de_write(i915, BLC_PWM_PCH_CTL2, pch_ctl2);\n\n\tpch_ctl1 = 0;\n\tif (panel->backlight.active_low_pwm)\n\t\tpch_ctl1 |= BLM_PCH_POLARITY;\n\n\t \n\tif (HAS_PCH_LPT(i915))\n\t\tpch_ctl1 |= BLM_PCH_OVERRIDE_ENABLE;\n\n\tintel_de_write(i915, BLC_PWM_PCH_CTL1, pch_ctl1);\n\tintel_de_posting_read(i915, BLC_PWM_PCH_CTL1);\n\tintel_de_write(i915, BLC_PWM_PCH_CTL1, pch_ctl1 | BLM_PCH_PWM_ENABLE);\n\n\t \n\tintel_backlight_set_pwm_level(conn_state, level);\n}\n\nstatic void pch_enable_backlight(const struct intel_crtc_state *crtc_state,\n\t\t\t\t const struct drm_connector_state *conn_state, u32 level)\n{\n\tstruct intel_connector *connector = to_intel_connector(conn_state->connector);\n\tstruct drm_i915_private *i915 = to_i915(connector->base.dev);\n\tstruct intel_panel *panel = &connector->panel;\n\tenum transcoder cpu_transcoder = crtc_state->cpu_transcoder;\n\tu32 cpu_ctl2, pch_ctl1, pch_ctl2;\n\n\tcpu_ctl2 = intel_de_read(i915, BLC_PWM_CPU_CTL2);\n\tif (cpu_ctl2 & BLM_PWM_ENABLE) {\n\t\tdrm_dbg_kms(&i915->drm, \"[CONNECTOR:%d:%s] CPU backlight already enabled\\n\",\n\t\t\t    connector->base.base.id, connector->base.name);\n\t\tcpu_ctl2 &= ~BLM_PWM_ENABLE;\n\t\tintel_de_write(i915, BLC_PWM_CPU_CTL2, cpu_ctl2);\n\t}\n\n\tpch_ctl1 = intel_de_read(i915, BLC_PWM_PCH_CTL1);\n\tif (pch_ctl1 & BLM_PCH_PWM_ENABLE) {\n\t\tdrm_dbg_kms(&i915->drm, \"[CONNECTOR:%d:%s] PCH backlight already enabled\\n\",\n\t\t\t    connector->base.base.id, connector->base.name);\n\t\tpch_ctl1 &= ~BLM_PCH_PWM_ENABLE;\n\t\tintel_de_write(i915, BLC_PWM_PCH_CTL1, pch_ctl1);\n\t}\n\n\tif (cpu_transcoder == TRANSCODER_EDP)\n\t\tcpu_ctl2 = BLM_TRANSCODER_EDP;\n\telse\n\t\tcpu_ctl2 = BLM_PIPE(cpu_transcoder);\n\tintel_de_write(i915, BLC_PWM_CPU_CTL2, cpu_ctl2);\n\tintel_de_posting_read(i915, BLC_PWM_CPU_CTL2);\n\tintel_de_write(i915, BLC_PWM_CPU_CTL2, cpu_ctl2 | BLM_PWM_ENABLE);\n\n\t \n\tintel_backlight_set_pwm_level(conn_state, level);\n\n\tpch_ctl2 = panel->backlight.pwm_level_max << 16;\n\tintel_de_write(i915, BLC_PWM_PCH_CTL2, pch_ctl2);\n\n\tpch_ctl1 = 0;\n\tif (panel->backlight.active_low_pwm)\n\t\tpch_ctl1 |= BLM_PCH_POLARITY;\n\n\tintel_de_write(i915, BLC_PWM_PCH_CTL1, pch_ctl1);\n\tintel_de_posting_read(i915, BLC_PWM_PCH_CTL1);\n\tintel_de_write(i915, BLC_PWM_PCH_CTL1, pch_ctl1 | BLM_PCH_PWM_ENABLE);\n}\n\nstatic void i9xx_enable_backlight(const struct intel_crtc_state *crtc_state,\n\t\t\t\t  const struct drm_connector_state *conn_state, u32 level)\n{\n\tstruct intel_connector *connector = to_intel_connector(conn_state->connector);\n\tstruct drm_i915_private *i915 = to_i915(connector->base.dev);\n\tstruct intel_panel *panel = &connector->panel;\n\tu32 ctl, freq;\n\n\tctl = intel_de_read(i915, BLC_PWM_CTL);\n\tif (ctl & BACKLIGHT_DUTY_CYCLE_MASK_PNV) {\n\t\tdrm_dbg_kms(&i915->drm, \"[CONNECTOR:%d:%s] backlight already enabled\\n\",\n\t\t\t    connector->base.base.id, connector->base.name);\n\t\tintel_de_write(i915, BLC_PWM_CTL, 0);\n\t}\n\n\tfreq = panel->backlight.pwm_level_max;\n\tif (panel->backlight.combination_mode)\n\t\tfreq /= 0xff;\n\n\tctl = freq << 17;\n\tif (panel->backlight.combination_mode)\n\t\tctl |= BLM_LEGACY_MODE;\n\tif (IS_PINEVIEW(i915) && panel->backlight.active_low_pwm)\n\t\tctl |= BLM_POLARITY_PNV;\n\n\tintel_de_write(i915, BLC_PWM_CTL, ctl);\n\tintel_de_posting_read(i915, BLC_PWM_CTL);\n\n\t \n\tintel_backlight_set_pwm_level(conn_state, level);\n\n\t \n\tif (DISPLAY_VER(i915) == 2)\n\t\tintel_de_write(i915, BLC_HIST_CTL, BLM_HISTOGRAM_ENABLE);\n}\n\nstatic void i965_enable_backlight(const struct intel_crtc_state *crtc_state,\n\t\t\t\t  const struct drm_connector_state *conn_state, u32 level)\n{\n\tstruct intel_connector *connector = to_intel_connector(conn_state->connector);\n\tstruct drm_i915_private *i915 = to_i915(connector->base.dev);\n\tstruct intel_panel *panel = &connector->panel;\n\tenum pipe pipe = to_intel_crtc(conn_state->crtc)->pipe;\n\tu32 ctl, ctl2, freq;\n\n\tctl2 = intel_de_read(i915, BLC_PWM_CTL2);\n\tif (ctl2 & BLM_PWM_ENABLE) {\n\t\tdrm_dbg_kms(&i915->drm, \"[CONNECTOR:%d:%s] backlight already enabled\\n\",\n\t\t\t    connector->base.base.id, connector->base.name);\n\t\tctl2 &= ~BLM_PWM_ENABLE;\n\t\tintel_de_write(i915, BLC_PWM_CTL2, ctl2);\n\t}\n\n\tfreq = panel->backlight.pwm_level_max;\n\tif (panel->backlight.combination_mode)\n\t\tfreq /= 0xff;\n\n\tctl = freq << 16;\n\tintel_de_write(i915, BLC_PWM_CTL, ctl);\n\n\tctl2 = BLM_PIPE(pipe);\n\tif (panel->backlight.combination_mode)\n\t\tctl2 |= BLM_COMBINATION_MODE;\n\tif (panel->backlight.active_low_pwm)\n\t\tctl2 |= BLM_POLARITY_I965;\n\tintel_de_write(i915, BLC_PWM_CTL2, ctl2);\n\tintel_de_posting_read(i915, BLC_PWM_CTL2);\n\tintel_de_write(i915, BLC_PWM_CTL2, ctl2 | BLM_PWM_ENABLE);\n\n\tintel_backlight_set_pwm_level(conn_state, level);\n}\n\nstatic void vlv_enable_backlight(const struct intel_crtc_state *crtc_state,\n\t\t\t\t const struct drm_connector_state *conn_state, u32 level)\n{\n\tstruct intel_connector *connector = to_intel_connector(conn_state->connector);\n\tstruct drm_i915_private *i915 = to_i915(connector->base.dev);\n\tstruct intel_panel *panel = &connector->panel;\n\tenum pipe pipe = to_intel_crtc(crtc_state->uapi.crtc)->pipe;\n\tu32 ctl, ctl2;\n\n\tctl2 = intel_de_read(i915, VLV_BLC_PWM_CTL2(pipe));\n\tif (ctl2 & BLM_PWM_ENABLE) {\n\t\tdrm_dbg_kms(&i915->drm, \"[CONNECTOR:%d:%s] backlight already enabled\\n\",\n\t\t\t    connector->base.base.id, connector->base.name);\n\t\tctl2 &= ~BLM_PWM_ENABLE;\n\t\tintel_de_write(i915, VLV_BLC_PWM_CTL2(pipe), ctl2);\n\t}\n\n\tctl = panel->backlight.pwm_level_max << 16;\n\tintel_de_write(i915, VLV_BLC_PWM_CTL(pipe), ctl);\n\n\t \n\tintel_backlight_set_pwm_level(conn_state, level);\n\n\tctl2 = 0;\n\tif (panel->backlight.active_low_pwm)\n\t\tctl2 |= BLM_POLARITY_I965;\n\tintel_de_write(i915, VLV_BLC_PWM_CTL2(pipe), ctl2);\n\tintel_de_posting_read(i915, VLV_BLC_PWM_CTL2(pipe));\n\tintel_de_write(i915, VLV_BLC_PWM_CTL2(pipe), ctl2 | BLM_PWM_ENABLE);\n}\n\nstatic void bxt_enable_backlight(const struct intel_crtc_state *crtc_state,\n\t\t\t\t const struct drm_connector_state *conn_state, u32 level)\n{\n\tstruct intel_connector *connector = to_intel_connector(conn_state->connector);\n\tstruct drm_i915_private *i915 = to_i915(connector->base.dev);\n\tstruct intel_panel *panel = &connector->panel;\n\tenum pipe pipe = to_intel_crtc(crtc_state->uapi.crtc)->pipe;\n\tu32 pwm_ctl, val;\n\n\t \n\tif (panel->backlight.controller == 1) {\n\t\tval = intel_de_read(i915, UTIL_PIN_CTL);\n\t\tif (val & UTIL_PIN_ENABLE) {\n\t\t\tdrm_dbg_kms(&i915->drm, \"[CONNECTOR:%d:%s] utility pin already enabled\\n\",\n\t\t\t\t    connector->base.base.id, connector->base.name);\n\t\t\tval &= ~UTIL_PIN_ENABLE;\n\t\t\tintel_de_write(i915, UTIL_PIN_CTL, val);\n\t\t}\n\n\t\tval = 0;\n\t\tif (panel->backlight.util_pin_active_low)\n\t\t\tval |= UTIL_PIN_POLARITY;\n\t\tintel_de_write(i915, UTIL_PIN_CTL,\n\t\t\t       val | UTIL_PIN_PIPE(pipe) | UTIL_PIN_MODE_PWM | UTIL_PIN_ENABLE);\n\t}\n\n\tpwm_ctl = intel_de_read(i915, BXT_BLC_PWM_CTL(panel->backlight.controller));\n\tif (pwm_ctl & BXT_BLC_PWM_ENABLE) {\n\t\tdrm_dbg_kms(&i915->drm, \"[CONNECTOR:%d:%s] backlight already enabled\\n\",\n\t\t\t    connector->base.base.id, connector->base.name);\n\t\tpwm_ctl &= ~BXT_BLC_PWM_ENABLE;\n\t\tintel_de_write(i915, BXT_BLC_PWM_CTL(panel->backlight.controller),\n\t\t\t       pwm_ctl);\n\t}\n\n\tintel_de_write(i915, BXT_BLC_PWM_FREQ(panel->backlight.controller),\n\t\t       panel->backlight.pwm_level_max);\n\n\tintel_backlight_set_pwm_level(conn_state, level);\n\n\tpwm_ctl = 0;\n\tif (panel->backlight.active_low_pwm)\n\t\tpwm_ctl |= BXT_BLC_PWM_POLARITY;\n\n\tintel_de_write(i915, BXT_BLC_PWM_CTL(panel->backlight.controller), pwm_ctl);\n\tintel_de_posting_read(i915, BXT_BLC_PWM_CTL(panel->backlight.controller));\n\tintel_de_write(i915, BXT_BLC_PWM_CTL(panel->backlight.controller),\n\t\t       pwm_ctl | BXT_BLC_PWM_ENABLE);\n}\n\nstatic void cnp_enable_backlight(const struct intel_crtc_state *crtc_state,\n\t\t\t\t const struct drm_connector_state *conn_state, u32 level)\n{\n\tstruct intel_connector *connector = to_intel_connector(conn_state->connector);\n\tstruct drm_i915_private *i915 = to_i915(connector->base.dev);\n\tstruct intel_panel *panel = &connector->panel;\n\tu32 pwm_ctl;\n\n\tpwm_ctl = intel_de_read(i915, BXT_BLC_PWM_CTL(panel->backlight.controller));\n\tif (pwm_ctl & BXT_BLC_PWM_ENABLE) {\n\t\tdrm_dbg_kms(&i915->drm, \"backlight already enabled\\n\");\n\t\tpwm_ctl &= ~BXT_BLC_PWM_ENABLE;\n\t\tintel_de_write(i915, BXT_BLC_PWM_CTL(panel->backlight.controller),\n\t\t\t       pwm_ctl);\n\t}\n\n\tintel_de_write(i915, BXT_BLC_PWM_FREQ(panel->backlight.controller),\n\t\t       panel->backlight.pwm_level_max);\n\n\tintel_backlight_set_pwm_level(conn_state, level);\n\n\tpwm_ctl = 0;\n\tif (panel->backlight.active_low_pwm)\n\t\tpwm_ctl |= BXT_BLC_PWM_POLARITY;\n\n\tintel_de_write(i915, BXT_BLC_PWM_CTL(panel->backlight.controller), pwm_ctl);\n\tintel_de_posting_read(i915, BXT_BLC_PWM_CTL(panel->backlight.controller));\n\tintel_de_write(i915, BXT_BLC_PWM_CTL(panel->backlight.controller),\n\t\t       pwm_ctl | BXT_BLC_PWM_ENABLE);\n}\n\nstatic void ext_pwm_enable_backlight(const struct intel_crtc_state *crtc_state,\n\t\t\t\t     const struct drm_connector_state *conn_state, u32 level)\n{\n\tstruct intel_connector *connector = to_intel_connector(conn_state->connector);\n\tstruct intel_panel *panel = &connector->panel;\n\n\tpwm_set_relative_duty_cycle(&panel->backlight.pwm_state, level, 100);\n\tpanel->backlight.pwm_state.enabled = true;\n\tpwm_apply_state(panel->backlight.pwm, &panel->backlight.pwm_state);\n}\n\nstatic void __intel_backlight_enable(const struct intel_crtc_state *crtc_state,\n\t\t\t\t     const struct drm_connector_state *conn_state)\n{\n\tstruct intel_connector *connector = to_intel_connector(conn_state->connector);\n\tstruct intel_panel *panel = &connector->panel;\n\n\tWARN_ON(panel->backlight.max == 0);\n\n\tif (panel->backlight.level <= panel->backlight.min) {\n\t\tpanel->backlight.level = panel->backlight.max;\n\t\tif (panel->backlight.device)\n\t\t\tpanel->backlight.device->props.brightness =\n\t\t\t\tscale_hw_to_user(connector,\n\t\t\t\t\t\t panel->backlight.level,\n\t\t\t\t\t\t panel->backlight.device->props.max_brightness);\n\t}\n\n\tpanel->backlight.funcs->enable(crtc_state, conn_state, panel->backlight.level);\n\tpanel->backlight.enabled = true;\n\tif (panel->backlight.device)\n\t\tpanel->backlight.device->props.power = FB_BLANK_UNBLANK;\n}\n\nvoid intel_backlight_enable(const struct intel_crtc_state *crtc_state,\n\t\t\t    const struct drm_connector_state *conn_state)\n{\n\tstruct intel_connector *connector = to_intel_connector(conn_state->connector);\n\tstruct drm_i915_private *i915 = to_i915(connector->base.dev);\n\tstruct intel_panel *panel = &connector->panel;\n\tenum pipe pipe = to_intel_crtc(crtc_state->uapi.crtc)->pipe;\n\n\tif (!panel->backlight.present)\n\t\treturn;\n\n\tdrm_dbg_kms(&i915->drm, \"pipe %c\\n\", pipe_name(pipe));\n\n\tmutex_lock(&i915->display.backlight.lock);\n\n\t__intel_backlight_enable(crtc_state, conn_state);\n\n\tmutex_unlock(&i915->display.backlight.lock);\n}\n\n#if IS_ENABLED(CONFIG_BACKLIGHT_CLASS_DEVICE)\nstatic u32 intel_panel_get_backlight(struct intel_connector *connector)\n{\n\tstruct drm_i915_private *i915 = to_i915(connector->base.dev);\n\tstruct intel_panel *panel = &connector->panel;\n\tu32 val = 0;\n\n\tmutex_lock(&i915->display.backlight.lock);\n\n\tif (panel->backlight.enabled)\n\t\tval = panel->backlight.funcs->get(connector, intel_connector_get_pipe(connector));\n\n\tmutex_unlock(&i915->display.backlight.lock);\n\n\tdrm_dbg_kms(&i915->drm, \"get backlight PWM = %d\\n\", val);\n\treturn val;\n}\n\n \nstatic u32 scale_user_to_hw(struct intel_connector *connector,\n\t\t\t    u32 user_level, u32 user_max)\n{\n\tstruct intel_panel *panel = &connector->panel;\n\n\treturn scale(user_level, 0, user_max,\n\t\t     panel->backlight.min, panel->backlight.max);\n}\n\n \nstatic void intel_panel_set_backlight(const struct drm_connector_state *conn_state,\n\t\t\t\t      u32 user_level, u32 user_max)\n{\n\tstruct intel_connector *connector = to_intel_connector(conn_state->connector);\n\tstruct drm_i915_private *i915 = to_i915(connector->base.dev);\n\tstruct intel_panel *panel = &connector->panel;\n\tu32 hw_level;\n\n\tif (!panel->backlight.present)\n\t\treturn;\n\n\tmutex_lock(&i915->display.backlight.lock);\n\n\tdrm_WARN_ON(&i915->drm, panel->backlight.max == 0);\n\n\thw_level = scale_user_to_hw(connector, user_level, user_max);\n\tpanel->backlight.level = hw_level;\n\n\tif (panel->backlight.enabled)\n\t\tintel_panel_actually_set_backlight(conn_state, hw_level);\n\n\tmutex_unlock(&i915->display.backlight.lock);\n}\n\nstatic int intel_backlight_device_update_status(struct backlight_device *bd)\n{\n\tstruct intel_connector *connector = bl_get_data(bd);\n\tstruct drm_i915_private *i915 = to_i915(connector->base.dev);\n\tstruct intel_panel *panel = &connector->panel;\n\n\tdrm_modeset_lock(&i915->drm.mode_config.connection_mutex, NULL);\n\n\tdrm_dbg_kms(&i915->drm, \"updating intel_backlight, brightness=%d/%d\\n\",\n\t\t    bd->props.brightness, bd->props.max_brightness);\n\tintel_panel_set_backlight(connector->base.state, bd->props.brightness,\n\t\t\t\t  bd->props.max_brightness);\n\n\t \n\tif (panel->backlight.enabled) {\n\t\tif (panel->backlight.power) {\n\t\t\tbool enable = bd->props.power == FB_BLANK_UNBLANK &&\n\t\t\t\tbd->props.brightness != 0;\n\t\t\tpanel->backlight.power(connector, enable);\n\t\t}\n\t} else {\n\t\tbd->props.power = FB_BLANK_POWERDOWN;\n\t}\n\n\tdrm_modeset_unlock(&i915->drm.mode_config.connection_mutex);\n\n\treturn 0;\n}\n\nstatic int intel_backlight_device_get_brightness(struct backlight_device *bd)\n{\n\tstruct intel_connector *connector = bl_get_data(bd);\n\tstruct drm_i915_private *i915 = to_i915(connector->base.dev);\n\tintel_wakeref_t wakeref;\n\tint ret = 0;\n\n\twith_intel_runtime_pm(&i915->runtime_pm, wakeref) {\n\t\tu32 hw_level;\n\n\t\tdrm_modeset_lock(&i915->drm.mode_config.connection_mutex, NULL);\n\n\t\thw_level = intel_panel_get_backlight(connector);\n\t\tret = scale_hw_to_user(connector,\n\t\t\t\t       hw_level, bd->props.max_brightness);\n\n\t\tdrm_modeset_unlock(&i915->drm.mode_config.connection_mutex);\n\t}\n\n\treturn ret;\n}\n\nstatic const struct backlight_ops intel_backlight_device_ops = {\n\t.update_status = intel_backlight_device_update_status,\n\t.get_brightness = intel_backlight_device_get_brightness,\n};\n\nint intel_backlight_device_register(struct intel_connector *connector)\n{\n\tstruct drm_i915_private *i915 = to_i915(connector->base.dev);\n\tstruct intel_panel *panel = &connector->panel;\n\tstruct backlight_properties props;\n\tstruct backlight_device *bd;\n\tconst char *name;\n\tint ret = 0;\n\n\tif (WARN_ON(panel->backlight.device))\n\t\treturn -ENODEV;\n\n\tif (!panel->backlight.present)\n\t\treturn 0;\n\n\tWARN_ON(panel->backlight.max == 0);\n\n\tif (!acpi_video_backlight_use_native()) {\n\t\tdrm_info(&i915->drm, \"Skipping intel_backlight registration\\n\");\n\t\treturn 0;\n\t}\n\n\tmemset(&props, 0, sizeof(props));\n\tprops.type = BACKLIGHT_RAW;\n\n\t \n\tprops.max_brightness = panel->backlight.max;\n\tprops.brightness = scale_hw_to_user(connector,\n\t\t\t\t\t    panel->backlight.level,\n\t\t\t\t\t    props.max_brightness);\n\n\tif (panel->backlight.enabled)\n\t\tprops.power = FB_BLANK_UNBLANK;\n\telse\n\t\tprops.power = FB_BLANK_POWERDOWN;\n\n\tname = kstrdup(\"intel_backlight\", GFP_KERNEL);\n\tif (!name)\n\t\treturn -ENOMEM;\n\n\tbd = backlight_device_get_by_name(name);\n\tif (bd) {\n\t\tput_device(&bd->dev);\n\t\t \n\t\tkfree(name);\n\t\tname = kasprintf(GFP_KERNEL, \"card%d-%s-backlight\",\n\t\t\t\t i915->drm.primary->index, connector->base.name);\n\t\tif (!name)\n\t\t\treturn -ENOMEM;\n\t}\n\tbd = backlight_device_register(name, connector->base.kdev, connector,\n\t\t\t\t       &intel_backlight_device_ops, &props);\n\n\tif (IS_ERR(bd)) {\n\t\tdrm_err(&i915->drm,\n\t\t\t\"[CONNECTOR:%d:%s] backlight device %s register failed: %ld\\n\",\n\t\t\tconnector->base.base.id, connector->base.name, name, PTR_ERR(bd));\n\t\tret = PTR_ERR(bd);\n\t\tgoto out;\n\t}\n\n\tpanel->backlight.device = bd;\n\n\tdrm_dbg_kms(&i915->drm,\n\t\t    \"[CONNECTOR:%d:%s] backlight device %s registered\\n\",\n\t\t    connector->base.base.id, connector->base.name, name);\n\nout:\n\tkfree(name);\n\n\treturn ret;\n}\n\nvoid intel_backlight_device_unregister(struct intel_connector *connector)\n{\n\tstruct intel_panel *panel = &connector->panel;\n\n\tif (panel->backlight.device) {\n\t\tbacklight_device_unregister(panel->backlight.device);\n\t\tpanel->backlight.device = NULL;\n\t}\n}\n#endif  \n\n \nstatic u32 cnp_hz_to_pwm(struct intel_connector *connector, u32 pwm_freq_hz)\n{\n\tstruct drm_i915_private *i915 = to_i915(connector->base.dev);\n\n\treturn DIV_ROUND_CLOSEST(KHz(RUNTIME_INFO(i915)->rawclk_freq),\n\t\t\t\t pwm_freq_hz);\n}\n\n \nstatic u32 bxt_hz_to_pwm(struct intel_connector *connector, u32 pwm_freq_hz)\n{\n\treturn DIV_ROUND_CLOSEST(KHz(19200), pwm_freq_hz);\n}\n\n \nstatic u32 spt_hz_to_pwm(struct intel_connector *connector, u32 pwm_freq_hz)\n{\n\tstruct intel_panel *panel = &connector->panel;\n\tu32 mul;\n\n\tif (panel->backlight.alternate_pwm_increment)\n\t\tmul = 128;\n\telse\n\t\tmul = 16;\n\n\treturn DIV_ROUND_CLOSEST(MHz(24), pwm_freq_hz * mul);\n}\n\n \nstatic u32 lpt_hz_to_pwm(struct intel_connector *connector, u32 pwm_freq_hz)\n{\n\tstruct drm_i915_private *i915 = to_i915(connector->base.dev);\n\tstruct intel_panel *panel = &connector->panel;\n\tu32 mul, clock;\n\n\tif (panel->backlight.alternate_pwm_increment)\n\t\tmul = 16;\n\telse\n\t\tmul = 128;\n\n\tif (HAS_PCH_LPT_H(i915))\n\t\tclock = MHz(135);  \n\telse\n\t\tclock = MHz(24);  \n\n\treturn DIV_ROUND_CLOSEST(clock, pwm_freq_hz * mul);\n}\n\n \nstatic u32 pch_hz_to_pwm(struct intel_connector *connector, u32 pwm_freq_hz)\n{\n\tstruct drm_i915_private *i915 = to_i915(connector->base.dev);\n\n\treturn DIV_ROUND_CLOSEST(KHz(RUNTIME_INFO(i915)->rawclk_freq),\n\t\t\t\t pwm_freq_hz * 128);\n}\n\n \nstatic u32 i9xx_hz_to_pwm(struct intel_connector *connector, u32 pwm_freq_hz)\n{\n\tstruct drm_i915_private *i915 = to_i915(connector->base.dev);\n\tint clock;\n\n\tif (IS_PINEVIEW(i915))\n\t\tclock = KHz(RUNTIME_INFO(i915)->rawclk_freq);\n\telse\n\t\tclock = KHz(i915->display.cdclk.hw.cdclk);\n\n\treturn DIV_ROUND_CLOSEST(clock, pwm_freq_hz * 32);\n}\n\n \nstatic u32 i965_hz_to_pwm(struct intel_connector *connector, u32 pwm_freq_hz)\n{\n\tstruct drm_i915_private *i915 = to_i915(connector->base.dev);\n\tint clock;\n\n\tif (IS_G4X(i915))\n\t\tclock = KHz(RUNTIME_INFO(i915)->rawclk_freq);\n\telse\n\t\tclock = KHz(i915->display.cdclk.hw.cdclk);\n\n\treturn DIV_ROUND_CLOSEST(clock, pwm_freq_hz * 128);\n}\n\n \nstatic u32 vlv_hz_to_pwm(struct intel_connector *connector, u32 pwm_freq_hz)\n{\n\tstruct drm_i915_private *i915 = to_i915(connector->base.dev);\n\tint mul, clock;\n\n\tif ((intel_de_read(i915, CBR1_VLV) & CBR_PWM_CLOCK_MUX_SELECT) == 0) {\n\t\tif (IS_CHERRYVIEW(i915))\n\t\t\tclock = KHz(19200);\n\t\telse\n\t\t\tclock = MHz(25);\n\t\tmul = 16;\n\t} else {\n\t\tclock = KHz(RUNTIME_INFO(i915)->rawclk_freq);\n\t\tmul = 128;\n\t}\n\n\treturn DIV_ROUND_CLOSEST(clock, pwm_freq_hz * mul);\n}\n\nstatic u16 get_vbt_pwm_freq(struct intel_connector *connector)\n{\n\tstruct drm_i915_private *i915 = to_i915(connector->base.dev);\n\tu16 pwm_freq_hz = connector->panel.vbt.backlight.pwm_freq_hz;\n\n\tif (pwm_freq_hz) {\n\t\tdrm_dbg_kms(&i915->drm,\n\t\t\t    \"VBT defined backlight frequency %u Hz\\n\",\n\t\t\t    pwm_freq_hz);\n\t} else {\n\t\tpwm_freq_hz = 200;\n\t\tdrm_dbg_kms(&i915->drm,\n\t\t\t    \"default backlight frequency %u Hz\\n\",\n\t\t\t    pwm_freq_hz);\n\t}\n\n\treturn pwm_freq_hz;\n}\n\nstatic u32 get_backlight_max_vbt(struct intel_connector *connector)\n{\n\tstruct drm_i915_private *i915 = to_i915(connector->base.dev);\n\tstruct intel_panel *panel = &connector->panel;\n\tu16 pwm_freq_hz = get_vbt_pwm_freq(connector);\n\tu32 pwm;\n\n\tif (!panel->backlight.pwm_funcs->hz_to_pwm) {\n\t\tdrm_dbg_kms(&i915->drm,\n\t\t\t    \"backlight frequency conversion not supported\\n\");\n\t\treturn 0;\n\t}\n\n\tpwm = panel->backlight.pwm_funcs->hz_to_pwm(connector, pwm_freq_hz);\n\tif (!pwm) {\n\t\tdrm_dbg_kms(&i915->drm,\n\t\t\t    \"backlight frequency conversion failed\\n\");\n\t\treturn 0;\n\t}\n\n\treturn pwm;\n}\n\n \nstatic u32 get_backlight_min_vbt(struct intel_connector *connector)\n{\n\tstruct drm_i915_private *i915 = to_i915(connector->base.dev);\n\tstruct intel_panel *panel = &connector->panel;\n\tint min;\n\n\tdrm_WARN_ON(&i915->drm, panel->backlight.pwm_level_max == 0);\n\n\t \n\tmin = clamp_t(int, connector->panel.vbt.backlight.min_brightness, 0, 64);\n\tif (min != connector->panel.vbt.backlight.min_brightness) {\n\t\tdrm_dbg_kms(&i915->drm,\n\t\t\t    \"clamping VBT min backlight %d/255 to %d/255\\n\",\n\t\t\t    connector->panel.vbt.backlight.min_brightness, min);\n\t}\n\n\t \n\treturn scale(min, 0, 255, 0, panel->backlight.pwm_level_max);\n}\n\nstatic int lpt_setup_backlight(struct intel_connector *connector, enum pipe unused)\n{\n\tstruct drm_i915_private *i915 = to_i915(connector->base.dev);\n\tstruct intel_panel *panel = &connector->panel;\n\tu32 cpu_ctl2, pch_ctl1, pch_ctl2, val;\n\tbool alt, cpu_mode;\n\n\tif (HAS_PCH_LPT(i915))\n\t\talt = intel_de_read(i915, SOUTH_CHICKEN2) & LPT_PWM_GRANULARITY;\n\telse\n\t\talt = intel_de_read(i915, SOUTH_CHICKEN1) & SPT_PWM_GRANULARITY;\n\tpanel->backlight.alternate_pwm_increment = alt;\n\n\tpch_ctl1 = intel_de_read(i915, BLC_PWM_PCH_CTL1);\n\tpanel->backlight.active_low_pwm = pch_ctl1 & BLM_PCH_POLARITY;\n\n\tpch_ctl2 = intel_de_read(i915, BLC_PWM_PCH_CTL2);\n\tpanel->backlight.pwm_level_max = pch_ctl2 >> 16;\n\n\tcpu_ctl2 = intel_de_read(i915, BLC_PWM_CPU_CTL2);\n\n\tif (!panel->backlight.pwm_level_max)\n\t\tpanel->backlight.pwm_level_max = get_backlight_max_vbt(connector);\n\n\tif (!panel->backlight.pwm_level_max)\n\t\treturn -ENODEV;\n\n\tpanel->backlight.pwm_level_min = get_backlight_min_vbt(connector);\n\n\tpanel->backlight.pwm_enabled = pch_ctl1 & BLM_PCH_PWM_ENABLE;\n\n\tcpu_mode = panel->backlight.pwm_enabled && HAS_PCH_LPT(i915) &&\n\t\t   !(pch_ctl1 & BLM_PCH_OVERRIDE_ENABLE) &&\n\t\t   (cpu_ctl2 & BLM_PWM_ENABLE);\n\n\tif (cpu_mode) {\n\t\tval = pch_get_backlight(connector, unused);\n\n\t\tdrm_dbg_kms(&i915->drm,\n\t\t\t    \"CPU backlight register was enabled, switching to PCH override\\n\");\n\n\t\t \n\t\tlpt_set_backlight(connector->base.state, val);\n\t\tintel_de_write(i915, BLC_PWM_PCH_CTL1,\n\t\t\t       pch_ctl1 | BLM_PCH_OVERRIDE_ENABLE);\n\n\t\tintel_de_write(i915, BLC_PWM_CPU_CTL2,\n\t\t\t       cpu_ctl2 & ~BLM_PWM_ENABLE);\n\t}\n\n\tdrm_dbg_kms(&i915->drm,\n\t\t    \"[CONNECTOR:%d:%s] Using native PCH PWM for backlight control\\n\",\n\t\t    connector->base.base.id, connector->base.name);\n\n\treturn 0;\n}\n\nstatic int pch_setup_backlight(struct intel_connector *connector, enum pipe unused)\n{\n\tstruct drm_i915_private *i915 = to_i915(connector->base.dev);\n\tstruct intel_panel *panel = &connector->panel;\n\tu32 cpu_ctl2, pch_ctl1, pch_ctl2;\n\n\tpch_ctl1 = intel_de_read(i915, BLC_PWM_PCH_CTL1);\n\tpanel->backlight.active_low_pwm = pch_ctl1 & BLM_PCH_POLARITY;\n\n\tpch_ctl2 = intel_de_read(i915, BLC_PWM_PCH_CTL2);\n\tpanel->backlight.pwm_level_max = pch_ctl2 >> 16;\n\n\tif (!panel->backlight.pwm_level_max)\n\t\tpanel->backlight.pwm_level_max = get_backlight_max_vbt(connector);\n\n\tif (!panel->backlight.pwm_level_max)\n\t\treturn -ENODEV;\n\n\tpanel->backlight.pwm_level_min = get_backlight_min_vbt(connector);\n\n\tcpu_ctl2 = intel_de_read(i915, BLC_PWM_CPU_CTL2);\n\tpanel->backlight.pwm_enabled = (cpu_ctl2 & BLM_PWM_ENABLE) &&\n\t\t(pch_ctl1 & BLM_PCH_PWM_ENABLE);\n\n\tdrm_dbg_kms(&i915->drm,\n\t\t    \"[CONNECTOR:%d:%s] Using native PCH PWM for backlight control\\n\",\n\t\t    connector->base.base.id, connector->base.name);\n\n\treturn 0;\n}\n\nstatic int i9xx_setup_backlight(struct intel_connector *connector, enum pipe unused)\n{\n\tstruct drm_i915_private *i915 = to_i915(connector->base.dev);\n\tstruct intel_panel *panel = &connector->panel;\n\tu32 ctl, val;\n\n\tctl = intel_de_read(i915, BLC_PWM_CTL);\n\n\tif (DISPLAY_VER(i915) == 2 || IS_I915GM(i915) || IS_I945GM(i915))\n\t\tpanel->backlight.combination_mode = ctl & BLM_LEGACY_MODE;\n\n\tif (IS_PINEVIEW(i915))\n\t\tpanel->backlight.active_low_pwm = ctl & BLM_POLARITY_PNV;\n\n\tpanel->backlight.pwm_level_max = ctl >> 17;\n\n\tif (!panel->backlight.pwm_level_max) {\n\t\tpanel->backlight.pwm_level_max = get_backlight_max_vbt(connector);\n\t\tpanel->backlight.pwm_level_max >>= 1;\n\t}\n\n\tif (!panel->backlight.pwm_level_max)\n\t\treturn -ENODEV;\n\n\tif (panel->backlight.combination_mode)\n\t\tpanel->backlight.pwm_level_max *= 0xff;\n\n\tpanel->backlight.pwm_level_min = get_backlight_min_vbt(connector);\n\n\tval = i9xx_get_backlight(connector, unused);\n\tval = intel_backlight_invert_pwm_level(connector, val);\n\tval = clamp(val, panel->backlight.pwm_level_min, panel->backlight.pwm_level_max);\n\n\tpanel->backlight.pwm_enabled = val != 0;\n\n\tdrm_dbg_kms(&i915->drm,\n\t\t    \"[CONNECTOR:%d:%s] Using native PWM for backlight control\\n\",\n\t\t    connector->base.base.id, connector->base.name);\n\n\treturn 0;\n}\n\nstatic int i965_setup_backlight(struct intel_connector *connector, enum pipe unused)\n{\n\tstruct drm_i915_private *i915 = to_i915(connector->base.dev);\n\tstruct intel_panel *panel = &connector->panel;\n\tu32 ctl, ctl2;\n\n\tctl2 = intel_de_read(i915, BLC_PWM_CTL2);\n\tpanel->backlight.combination_mode = ctl2 & BLM_COMBINATION_MODE;\n\tpanel->backlight.active_low_pwm = ctl2 & BLM_POLARITY_I965;\n\n\tctl = intel_de_read(i915, BLC_PWM_CTL);\n\tpanel->backlight.pwm_level_max = ctl >> 16;\n\n\tif (!panel->backlight.pwm_level_max)\n\t\tpanel->backlight.pwm_level_max = get_backlight_max_vbt(connector);\n\n\tif (!panel->backlight.pwm_level_max)\n\t\treturn -ENODEV;\n\n\tif (panel->backlight.combination_mode)\n\t\tpanel->backlight.pwm_level_max *= 0xff;\n\n\tpanel->backlight.pwm_level_min = get_backlight_min_vbt(connector);\n\n\tpanel->backlight.pwm_enabled = ctl2 & BLM_PWM_ENABLE;\n\n\tdrm_dbg_kms(&i915->drm,\n\t\t    \"[CONNECTOR:%d:%s] Using native PWM for backlight control\\n\",\n\t\t    connector->base.base.id, connector->base.name);\n\n\treturn 0;\n}\n\nstatic int vlv_setup_backlight(struct intel_connector *connector, enum pipe pipe)\n{\n\tstruct drm_i915_private *i915 = to_i915(connector->base.dev);\n\tstruct intel_panel *panel = &connector->panel;\n\tu32 ctl, ctl2;\n\n\tif (drm_WARN_ON(&i915->drm, pipe != PIPE_A && pipe != PIPE_B))\n\t\treturn -ENODEV;\n\n\tctl2 = intel_de_read(i915, VLV_BLC_PWM_CTL2(pipe));\n\tpanel->backlight.active_low_pwm = ctl2 & BLM_POLARITY_I965;\n\n\tctl = intel_de_read(i915, VLV_BLC_PWM_CTL(pipe));\n\tpanel->backlight.pwm_level_max = ctl >> 16;\n\n\tif (!panel->backlight.pwm_level_max)\n\t\tpanel->backlight.pwm_level_max = get_backlight_max_vbt(connector);\n\n\tif (!panel->backlight.pwm_level_max)\n\t\treturn -ENODEV;\n\n\tpanel->backlight.pwm_level_min = get_backlight_min_vbt(connector);\n\n\tpanel->backlight.pwm_enabled = ctl2 & BLM_PWM_ENABLE;\n\n\tdrm_dbg_kms(&i915->drm,\n\t\t    \"[CONNECTOR:%d:%s] Using native PWM for backlight control (on pipe %c)\\n\",\n\t\t    connector->base.base.id, connector->base.name, pipe_name(pipe));\n\n\treturn 0;\n}\n\nstatic int\nbxt_setup_backlight(struct intel_connector *connector, enum pipe unused)\n{\n\tstruct drm_i915_private *i915 = to_i915(connector->base.dev);\n\tstruct intel_panel *panel = &connector->panel;\n\tu32 pwm_ctl, val;\n\n\tpanel->backlight.controller = connector->panel.vbt.backlight.controller;\n\n\tpwm_ctl = intel_de_read(i915,\n\t\t\t\tBXT_BLC_PWM_CTL(panel->backlight.controller));\n\n\t \n\tif (panel->backlight.controller == 1) {\n\t\tval = intel_de_read(i915, UTIL_PIN_CTL);\n\t\tpanel->backlight.util_pin_active_low =\n\t\t\t\t\tval & UTIL_PIN_POLARITY;\n\t}\n\n\tpanel->backlight.active_low_pwm = pwm_ctl & BXT_BLC_PWM_POLARITY;\n\tpanel->backlight.pwm_level_max =\n\t\tintel_de_read(i915, BXT_BLC_PWM_FREQ(panel->backlight.controller));\n\n\tif (!panel->backlight.pwm_level_max)\n\t\tpanel->backlight.pwm_level_max = get_backlight_max_vbt(connector);\n\n\tif (!panel->backlight.pwm_level_max)\n\t\treturn -ENODEV;\n\n\tpanel->backlight.pwm_level_min = get_backlight_min_vbt(connector);\n\n\tpanel->backlight.pwm_enabled = pwm_ctl & BXT_BLC_PWM_ENABLE;\n\n\tdrm_dbg_kms(&i915->drm,\n\t\t    \"[CONNECTOR:%d:%s] Using native PWM for backlight control (controller=%d)\\n\",\n\t\t    connector->base.base.id, connector->base.name,\n\t\t    panel->backlight.controller);\n\n\treturn 0;\n}\n\nstatic int cnp_num_backlight_controllers(struct drm_i915_private *i915)\n{\n\tif (INTEL_PCH_TYPE(i915) >= PCH_DG1)\n\t\treturn 1;\n\n\tif (INTEL_PCH_TYPE(i915) >= PCH_ICP)\n\t\treturn 2;\n\n\treturn 1;\n}\n\nstatic bool cnp_backlight_controller_is_valid(struct drm_i915_private *i915, int controller)\n{\n\tif (controller < 0 || controller >= cnp_num_backlight_controllers(i915))\n\t\treturn false;\n\n\tif (controller == 1 &&\n\t    INTEL_PCH_TYPE(i915) >= PCH_ICP &&\n\t    INTEL_PCH_TYPE(i915) < PCH_MTP)\n\t\treturn intel_de_read(i915, SOUTH_CHICKEN1) & ICP_SECOND_PPS_IO_SELECT;\n\n\treturn true;\n}\n\nstatic int\ncnp_setup_backlight(struct intel_connector *connector, enum pipe unused)\n{\n\tstruct drm_i915_private *i915 = to_i915(connector->base.dev);\n\tstruct intel_panel *panel = &connector->panel;\n\tu32 pwm_ctl;\n\n\t \n\tpanel->backlight.controller = connector->panel.vbt.backlight.controller;\n\tif (!cnp_backlight_controller_is_valid(i915, panel->backlight.controller)) {\n\t\tdrm_dbg_kms(&i915->drm, \"[CONNECTOR:%d:%s] Invalid backlight controller %d, assuming 0\\n\",\n\t\t\t    connector->base.base.id, connector->base.name,\n\t\t\t    panel->backlight.controller);\n\t\tpanel->backlight.controller = 0;\n\t}\n\n\tpwm_ctl = intel_de_read(i915,\n\t\t\t\tBXT_BLC_PWM_CTL(panel->backlight.controller));\n\n\tpanel->backlight.active_low_pwm = pwm_ctl & BXT_BLC_PWM_POLARITY;\n\tpanel->backlight.pwm_level_max =\n\t\tintel_de_read(i915, BXT_BLC_PWM_FREQ(panel->backlight.controller));\n\n\tif (!panel->backlight.pwm_level_max)\n\t\tpanel->backlight.pwm_level_max = get_backlight_max_vbt(connector);\n\n\tif (!panel->backlight.pwm_level_max)\n\t\treturn -ENODEV;\n\n\tpanel->backlight.pwm_level_min = get_backlight_min_vbt(connector);\n\n\tpanel->backlight.pwm_enabled = pwm_ctl & BXT_BLC_PWM_ENABLE;\n\n\tdrm_dbg_kms(&i915->drm,\n\t\t    \"[CONNECTOR:%d:%s] Using native PCH PWM for backlight control (controller=%d)\\n\",\n\t\t    connector->base.base.id, connector->base.name,\n\t\t    panel->backlight.controller);\n\n\treturn 0;\n}\n\nstatic int ext_pwm_setup_backlight(struct intel_connector *connector,\n\t\t\t\t   enum pipe pipe)\n{\n\tstruct drm_i915_private *i915 = to_i915(connector->base.dev);\n\tstruct intel_panel *panel = &connector->panel;\n\tconst char *desc;\n\tu32 level;\n\n\t \n\tif (connector->panel.vbt.dsi.config->pwm_blc == PPS_BLC_PMIC) {\n\t\tpanel->backlight.pwm = pwm_get(i915->drm.dev, \"pwm_pmic_backlight\");\n\t\tdesc = \"PMIC\";\n\t} else {\n\t\tpanel->backlight.pwm = pwm_get(i915->drm.dev, \"pwm_soc_backlight\");\n\t\tdesc = \"SoC\";\n\t}\n\n\tif (IS_ERR(panel->backlight.pwm)) {\n\t\tdrm_err(&i915->drm, \"[CONNECTOR:%d:%s] Failed to get the %s PWM chip\\n\",\n\t\t\tconnector->base.base.id, connector->base.name, desc);\n\t\tpanel->backlight.pwm = NULL;\n\t\treturn -ENODEV;\n\t}\n\n\tpanel->backlight.pwm_level_max = 100;  \n\tpanel->backlight.pwm_level_min = get_backlight_min_vbt(connector);\n\n\tif (pwm_is_enabled(panel->backlight.pwm)) {\n\t\t \n\t\tpwm_get_state(panel->backlight.pwm, &panel->backlight.pwm_state);\n\n\t\tlevel = pwm_get_relative_duty_cycle(&panel->backlight.pwm_state,\n\t\t\t\t\t\t    100);\n\t\tlevel = intel_backlight_invert_pwm_level(connector, level);\n\t\tpanel->backlight.pwm_enabled = true;\n\n\t\tdrm_dbg_kms(&i915->drm, \"[CONNECTOR:%d:%s] PWM already enabled at freq %ld, VBT freq %d, level %d\\n\",\n\t\t\t    connector->base.base.id, connector->base.name,\n\t\t\t    NSEC_PER_SEC / (unsigned long)panel->backlight.pwm_state.period,\n\t\t\t    get_vbt_pwm_freq(connector), level);\n\t} else {\n\t\t \n\t\tpanel->backlight.pwm_state.period =\n\t\t\tNSEC_PER_SEC / get_vbt_pwm_freq(connector);\n\t}\n\n\tdrm_dbg_kms(&i915->drm,\n\t\t    \"[CONNECTOR:%d:%s] Using %s PWM for backlight control\\n\",\n\t\t    connector->base.base.id, connector->base.name, desc);\n\n\treturn 0;\n}\n\nstatic void intel_pwm_set_backlight(const struct drm_connector_state *conn_state, u32 level)\n{\n\tstruct intel_connector *connector = to_intel_connector(conn_state->connector);\n\tstruct intel_panel *panel = &connector->panel;\n\n\tpanel->backlight.pwm_funcs->set(conn_state,\n\t\t\t\t\tintel_backlight_invert_pwm_level(connector, level));\n}\n\nstatic u32 intel_pwm_get_backlight(struct intel_connector *connector, enum pipe pipe)\n{\n\tstruct intel_panel *panel = &connector->panel;\n\n\treturn intel_backlight_invert_pwm_level(connector,\n\t\t\t\t\t    panel->backlight.pwm_funcs->get(connector, pipe));\n}\n\nstatic void intel_pwm_enable_backlight(const struct intel_crtc_state *crtc_state,\n\t\t\t\t       const struct drm_connector_state *conn_state, u32 level)\n{\n\tstruct intel_connector *connector = to_intel_connector(conn_state->connector);\n\tstruct intel_panel *panel = &connector->panel;\n\n\tpanel->backlight.pwm_funcs->enable(crtc_state, conn_state,\n\t\t\t\t\t   intel_backlight_invert_pwm_level(connector, level));\n}\n\nstatic void intel_pwm_disable_backlight(const struct drm_connector_state *conn_state, u32 level)\n{\n\tstruct intel_connector *connector = to_intel_connector(conn_state->connector);\n\tstruct intel_panel *panel = &connector->panel;\n\n\tpanel->backlight.pwm_funcs->disable(conn_state,\n\t\t\t\t\t    intel_backlight_invert_pwm_level(connector, level));\n}\n\nstatic int intel_pwm_setup_backlight(struct intel_connector *connector, enum pipe pipe)\n{\n\tstruct intel_panel *panel = &connector->panel;\n\tint ret;\n\n\tret = panel->backlight.pwm_funcs->setup(connector, pipe);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tpanel->backlight.min = panel->backlight.pwm_level_min;\n\tpanel->backlight.max = panel->backlight.pwm_level_max;\n\tpanel->backlight.level = intel_pwm_get_backlight(connector, pipe);\n\tpanel->backlight.enabled = panel->backlight.pwm_enabled;\n\n\treturn 0;\n}\n\nvoid intel_backlight_update(struct intel_atomic_state *state,\n\t\t\t    struct intel_encoder *encoder,\n\t\t\t    const struct intel_crtc_state *crtc_state,\n\t\t\t    const struct drm_connector_state *conn_state)\n{\n\tstruct intel_connector *connector = to_intel_connector(conn_state->connector);\n\tstruct drm_i915_private *i915 = to_i915(connector->base.dev);\n\tstruct intel_panel *panel = &connector->panel;\n\n\tif (!panel->backlight.present)\n\t\treturn;\n\n\tmutex_lock(&i915->display.backlight.lock);\n\tif (!panel->backlight.enabled)\n\t\t__intel_backlight_enable(crtc_state, conn_state);\n\n\tmutex_unlock(&i915->display.backlight.lock);\n}\n\nint intel_backlight_setup(struct intel_connector *connector, enum pipe pipe)\n{\n\tstruct drm_i915_private *i915 = to_i915(connector->base.dev);\n\tstruct intel_panel *panel = &connector->panel;\n\tint ret;\n\n\tif (!connector->panel.vbt.backlight.present) {\n\t\tif (intel_has_quirk(i915, QUIRK_BACKLIGHT_PRESENT)) {\n\t\t\tdrm_dbg_kms(&i915->drm,\n\t\t\t\t    \"[CONNECTOR:%d:%s] no backlight present per VBT, but present per quirk\\n\",\n\t\t\t\t    connector->base.base.id, connector->base.name);\n\t\t} else {\n\t\t\tdrm_dbg_kms(&i915->drm,\n\t\t\t\t    \"[CONNECTOR:%d:%s] no backlight present per VBT\\n\",\n\t\t\t\t    connector->base.base.id, connector->base.name);\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\t \n\tif (drm_WARN_ON(&i915->drm, !panel->backlight.funcs))\n\t\treturn -ENODEV;\n\n\t \n\tmutex_lock(&i915->display.backlight.lock);\n\tret = panel->backlight.funcs->setup(connector, pipe);\n\tmutex_unlock(&i915->display.backlight.lock);\n\n\tif (ret) {\n\t\tdrm_dbg_kms(&i915->drm,\n\t\t\t    \"[CONNECTOR:%d:%s] failed to setup backlight\\n\",\n\t\t\t    connector->base.base.id, connector->base.name);\n\t\treturn ret;\n\t}\n\n\tpanel->backlight.present = true;\n\n\tdrm_dbg_kms(&i915->drm,\n\t\t    \"[CONNECTOR:%d:%s] backlight initialized, %s, brightness %u/%u\\n\",\n\t\t    connector->base.base.id, connector->base.name,\n\t\t    str_enabled_disabled(panel->backlight.enabled),\n\t\t    panel->backlight.level, panel->backlight.max);\n\n\treturn 0;\n}\n\nvoid intel_backlight_destroy(struct intel_panel *panel)\n{\n\t \n\tif (panel->backlight.pwm)\n\t\tpwm_put(panel->backlight.pwm);\n\n\tpanel->backlight.present = false;\n}\n\nstatic const struct intel_panel_bl_funcs bxt_pwm_funcs = {\n\t.setup = bxt_setup_backlight,\n\t.enable = bxt_enable_backlight,\n\t.disable = bxt_disable_backlight,\n\t.set = bxt_set_backlight,\n\t.get = bxt_get_backlight,\n\t.hz_to_pwm = bxt_hz_to_pwm,\n};\n\nstatic const struct intel_panel_bl_funcs cnp_pwm_funcs = {\n\t.setup = cnp_setup_backlight,\n\t.enable = cnp_enable_backlight,\n\t.disable = cnp_disable_backlight,\n\t.set = bxt_set_backlight,\n\t.get = bxt_get_backlight,\n\t.hz_to_pwm = cnp_hz_to_pwm,\n};\n\nstatic const struct intel_panel_bl_funcs lpt_pwm_funcs = {\n\t.setup = lpt_setup_backlight,\n\t.enable = lpt_enable_backlight,\n\t.disable = lpt_disable_backlight,\n\t.set = lpt_set_backlight,\n\t.get = lpt_get_backlight,\n\t.hz_to_pwm = lpt_hz_to_pwm,\n};\n\nstatic const struct intel_panel_bl_funcs spt_pwm_funcs = {\n\t.setup = lpt_setup_backlight,\n\t.enable = lpt_enable_backlight,\n\t.disable = lpt_disable_backlight,\n\t.set = lpt_set_backlight,\n\t.get = lpt_get_backlight,\n\t.hz_to_pwm = spt_hz_to_pwm,\n};\n\nstatic const struct intel_panel_bl_funcs pch_pwm_funcs = {\n\t.setup = pch_setup_backlight,\n\t.enable = pch_enable_backlight,\n\t.disable = pch_disable_backlight,\n\t.set = pch_set_backlight,\n\t.get = pch_get_backlight,\n\t.hz_to_pwm = pch_hz_to_pwm,\n};\n\nstatic const struct intel_panel_bl_funcs ext_pwm_funcs = {\n\t.setup = ext_pwm_setup_backlight,\n\t.enable = ext_pwm_enable_backlight,\n\t.disable = ext_pwm_disable_backlight,\n\t.set = ext_pwm_set_backlight,\n\t.get = ext_pwm_get_backlight,\n};\n\nstatic const struct intel_panel_bl_funcs vlv_pwm_funcs = {\n\t.setup = vlv_setup_backlight,\n\t.enable = vlv_enable_backlight,\n\t.disable = vlv_disable_backlight,\n\t.set = vlv_set_backlight,\n\t.get = vlv_get_backlight,\n\t.hz_to_pwm = vlv_hz_to_pwm,\n};\n\nstatic const struct intel_panel_bl_funcs i965_pwm_funcs = {\n\t.setup = i965_setup_backlight,\n\t.enable = i965_enable_backlight,\n\t.disable = i965_disable_backlight,\n\t.set = i9xx_set_backlight,\n\t.get = i9xx_get_backlight,\n\t.hz_to_pwm = i965_hz_to_pwm,\n};\n\nstatic const struct intel_panel_bl_funcs i9xx_pwm_funcs = {\n\t.setup = i9xx_setup_backlight,\n\t.enable = i9xx_enable_backlight,\n\t.disable = i9xx_disable_backlight,\n\t.set = i9xx_set_backlight,\n\t.get = i9xx_get_backlight,\n\t.hz_to_pwm = i9xx_hz_to_pwm,\n};\n\nstatic const struct intel_panel_bl_funcs pwm_bl_funcs = {\n\t.setup = intel_pwm_setup_backlight,\n\t.enable = intel_pwm_enable_backlight,\n\t.disable = intel_pwm_disable_backlight,\n\t.set = intel_pwm_set_backlight,\n\t.get = intel_pwm_get_backlight,\n};\n\n \nvoid intel_backlight_init_funcs(struct intel_panel *panel)\n{\n\tstruct intel_connector *connector =\n\t\tcontainer_of(panel, struct intel_connector, panel);\n\tstruct drm_i915_private *i915 = to_i915(connector->base.dev);\n\n\tif (connector->base.connector_type == DRM_MODE_CONNECTOR_DSI &&\n\t    intel_dsi_dcs_init_backlight_funcs(connector) == 0)\n\t\treturn;\n\n\tif (IS_GEMINILAKE(i915) || IS_BROXTON(i915)) {\n\t\tpanel->backlight.pwm_funcs = &bxt_pwm_funcs;\n\t} else if (INTEL_PCH_TYPE(i915) >= PCH_CNP) {\n\t\tpanel->backlight.pwm_funcs = &cnp_pwm_funcs;\n\t} else if (INTEL_PCH_TYPE(i915) >= PCH_LPT) {\n\t\tif (HAS_PCH_LPT(i915))\n\t\t\tpanel->backlight.pwm_funcs = &lpt_pwm_funcs;\n\t\telse\n\t\t\tpanel->backlight.pwm_funcs = &spt_pwm_funcs;\n\t} else if (HAS_PCH_SPLIT(i915)) {\n\t\tpanel->backlight.pwm_funcs = &pch_pwm_funcs;\n\t} else if (IS_VALLEYVIEW(i915) || IS_CHERRYVIEW(i915)) {\n\t\tif (connector->base.connector_type == DRM_MODE_CONNECTOR_DSI) {\n\t\t\tpanel->backlight.pwm_funcs = &ext_pwm_funcs;\n\t\t} else {\n\t\t\tpanel->backlight.pwm_funcs = &vlv_pwm_funcs;\n\t\t}\n\t} else if (DISPLAY_VER(i915) == 4) {\n\t\tpanel->backlight.pwm_funcs = &i965_pwm_funcs;\n\t} else {\n\t\tpanel->backlight.pwm_funcs = &i9xx_pwm_funcs;\n\t}\n\n\tif (connector->base.connector_type == DRM_MODE_CONNECTOR_eDP) {\n\t\tif (intel_dp_aux_init_backlight_funcs(connector) == 0)\n\t\t\treturn;\n\n\t\tif (!intel_has_quirk(i915, QUIRK_NO_PPS_BACKLIGHT_POWER_HOOK))\n\t\t\tconnector->panel.backlight.power = intel_pps_backlight_power;\n\t}\n\n\t \n\tpanel->backlight.funcs = &pwm_bl_funcs;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}