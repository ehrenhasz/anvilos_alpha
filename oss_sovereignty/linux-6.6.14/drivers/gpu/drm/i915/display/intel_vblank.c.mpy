{
  "module_name": "intel_vblank.c",
  "hash_id": "5eb59ca403b36db0fac7260ee4ee65428da767e177921c2b5a82def6c9bc9117",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/i915/display/intel_vblank.c",
  "human_readable_source": "\n \n\n#include \"i915_drv.h\"\n#include \"i915_reg.h\"\n#include \"intel_de.h\"\n#include \"intel_display_types.h\"\n#include \"intel_vblank.h\"\n#include \"intel_vrr.h\"\n\n \n\n \nu32 i915_get_vblank_counter(struct drm_crtc *crtc)\n{\n\tstruct drm_i915_private *dev_priv = to_i915(crtc->dev);\n\tstruct drm_vblank_crtc *vblank = &dev_priv->drm.vblank[drm_crtc_index(crtc)];\n\tconst struct drm_display_mode *mode = &vblank->hwmode;\n\tenum pipe pipe = to_intel_crtc(crtc)->pipe;\n\tu32 pixel, vbl_start, hsync_start, htotal;\n\tu64 frame;\n\n\t \n\tif (!vblank->max_vblank_count)\n\t\treturn 0;\n\n\thtotal = mode->crtc_htotal;\n\thsync_start = mode->crtc_hsync_start;\n\tvbl_start = mode->crtc_vblank_start;\n\tif (mode->flags & DRM_MODE_FLAG_INTERLACE)\n\t\tvbl_start = DIV_ROUND_UP(vbl_start, 2);\n\n\t \n\tvbl_start *= htotal;\n\n\t \n\tvbl_start -= htotal - hsync_start;\n\n\t \n\tframe = intel_de_read64_2x32(dev_priv, PIPEFRAMEPIXEL(pipe), PIPEFRAME(pipe));\n\n\tpixel = frame & PIPE_PIXEL_MASK;\n\tframe = (frame >> PIPE_FRAME_LOW_SHIFT) & 0xffffff;\n\n\t \n\treturn (frame + (pixel >= vbl_start)) & 0xffffff;\n}\n\nu32 g4x_get_vblank_counter(struct drm_crtc *crtc)\n{\n\tstruct drm_i915_private *dev_priv = to_i915(crtc->dev);\n\tstruct drm_vblank_crtc *vblank = &dev_priv->drm.vblank[drm_crtc_index(crtc)];\n\tenum pipe pipe = to_intel_crtc(crtc)->pipe;\n\n\tif (!vblank->max_vblank_count)\n\t\treturn 0;\n\n\treturn intel_de_read(dev_priv, PIPE_FRMCOUNT_G4X(pipe));\n}\n\nstatic u32 intel_crtc_scanlines_since_frame_timestamp(struct intel_crtc *crtc)\n{\n\tstruct drm_i915_private *dev_priv = to_i915(crtc->base.dev);\n\tstruct drm_vblank_crtc *vblank =\n\t\t&crtc->base.dev->vblank[drm_crtc_index(&crtc->base)];\n\tconst struct drm_display_mode *mode = &vblank->hwmode;\n\tu32 htotal = mode->crtc_htotal;\n\tu32 clock = mode->crtc_clock;\n\tu32 scan_prev_time, scan_curr_time, scan_post_time;\n\n\t \n\tdo {\n\t\t \n\t\tscan_prev_time = intel_de_read_fw(dev_priv,\n\t\t\t\t\t\t  PIPE_FRMTMSTMP(crtc->pipe));\n\n\t\t \n\t\tscan_curr_time = intel_de_read_fw(dev_priv, IVB_TIMESTAMP_CTR);\n\n\t\tscan_post_time = intel_de_read_fw(dev_priv,\n\t\t\t\t\t\t  PIPE_FRMTMSTMP(crtc->pipe));\n\t} while (scan_post_time != scan_prev_time);\n\n\treturn div_u64(mul_u32_u32(scan_curr_time - scan_prev_time,\n\t\t\t\t   clock), 1000 * htotal);\n}\n\n \nstatic u32 __intel_get_crtc_scanline_from_timestamp(struct intel_crtc *crtc)\n{\n\tstruct drm_vblank_crtc *vblank =\n\t\t&crtc->base.dev->vblank[drm_crtc_index(&crtc->base)];\n\tconst struct drm_display_mode *mode = &vblank->hwmode;\n\tu32 vblank_start = mode->crtc_vblank_start;\n\tu32 vtotal = mode->crtc_vtotal;\n\tu32 scanline;\n\n\tscanline = intel_crtc_scanlines_since_frame_timestamp(crtc);\n\tscanline = min(scanline, vtotal - 1);\n\tscanline = (scanline + vblank_start) % vtotal;\n\n\treturn scanline;\n}\n\n \nstatic int __intel_get_crtc_scanline(struct intel_crtc *crtc)\n{\n\tstruct drm_device *dev = crtc->base.dev;\n\tstruct drm_i915_private *dev_priv = to_i915(dev);\n\tconst struct drm_display_mode *mode;\n\tstruct drm_vblank_crtc *vblank;\n\tenum pipe pipe = crtc->pipe;\n\tint position, vtotal;\n\n\tif (!crtc->active)\n\t\treturn 0;\n\n\tvblank = &crtc->base.dev->vblank[drm_crtc_index(&crtc->base)];\n\tmode = &vblank->hwmode;\n\n\tif (crtc->mode_flags & I915_MODE_FLAG_GET_SCANLINE_FROM_TIMESTAMP)\n\t\treturn __intel_get_crtc_scanline_from_timestamp(crtc);\n\n\tvtotal = mode->crtc_vtotal;\n\tif (mode->flags & DRM_MODE_FLAG_INTERLACE)\n\t\tvtotal /= 2;\n\n\tposition = intel_de_read_fw(dev_priv, PIPEDSL(pipe)) & PIPEDSL_LINE_MASK;\n\n\t \n\tif (HAS_DDI(dev_priv) && !position) {\n\t\tint i, temp;\n\n\t\tfor (i = 0; i < 100; i++) {\n\t\t\tudelay(1);\n\t\t\ttemp = intel_de_read_fw(dev_priv, PIPEDSL(pipe)) & PIPEDSL_LINE_MASK;\n\t\t\tif (temp != position) {\n\t\t\t\tposition = temp;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\t \n\treturn (position + crtc->scanline_offset) % vtotal;\n}\n\nstatic bool i915_get_crtc_scanoutpos(struct drm_crtc *_crtc,\n\t\t\t\t     bool in_vblank_irq,\n\t\t\t\t     int *vpos, int *hpos,\n\t\t\t\t     ktime_t *stime, ktime_t *etime,\n\t\t\t\t     const struct drm_display_mode *mode)\n{\n\tstruct drm_device *dev = _crtc->dev;\n\tstruct drm_i915_private *dev_priv = to_i915(dev);\n\tstruct intel_crtc *crtc = to_intel_crtc(_crtc);\n\tenum pipe pipe = crtc->pipe;\n\tint position;\n\tint vbl_start, vbl_end, hsync_start, htotal, vtotal;\n\tunsigned long irqflags;\n\tbool use_scanline_counter = DISPLAY_VER(dev_priv) >= 5 ||\n\t\tIS_G4X(dev_priv) || DISPLAY_VER(dev_priv) == 2 ||\n\t\tcrtc->mode_flags & I915_MODE_FLAG_USE_SCANLINE_COUNTER;\n\n\tif (drm_WARN_ON(&dev_priv->drm, !mode->crtc_clock)) {\n\t\tdrm_dbg(&dev_priv->drm,\n\t\t\t\"trying to get scanoutpos for disabled pipe %c\\n\",\n\t\t\tpipe_name(pipe));\n\t\treturn false;\n\t}\n\n\thtotal = mode->crtc_htotal;\n\thsync_start = mode->crtc_hsync_start;\n\tvtotal = mode->crtc_vtotal;\n\tvbl_start = mode->crtc_vblank_start;\n\tvbl_end = mode->crtc_vblank_end;\n\n\tif (mode->flags & DRM_MODE_FLAG_INTERLACE) {\n\t\tvbl_start = DIV_ROUND_UP(vbl_start, 2);\n\t\tvbl_end /= 2;\n\t\tvtotal /= 2;\n\t}\n\n\t \n\tspin_lock_irqsave(&dev_priv->uncore.lock, irqflags);\n\n\t \n\n\t \n\tif (stime)\n\t\t*stime = ktime_get();\n\n\tif (crtc->mode_flags & I915_MODE_FLAG_VRR) {\n\t\tint scanlines = intel_crtc_scanlines_since_frame_timestamp(crtc);\n\n\t\tposition = __intel_get_crtc_scanline(crtc);\n\n\t\t \n\t\tif (position >= vbl_start && scanlines < position)\n\t\t\tposition = min(crtc->vmax_vblank_start + scanlines, vtotal - 1);\n\t} else if (use_scanline_counter) {\n\t\t \n\t\tposition = __intel_get_crtc_scanline(crtc);\n\t} else {\n\t\t \n\t\tposition = (intel_de_read_fw(dev_priv, PIPEFRAMEPIXEL(pipe)) & PIPE_PIXEL_MASK) >> PIPE_PIXEL_SHIFT;\n\n\t\t \n\t\tvbl_start *= htotal;\n\t\tvbl_end *= htotal;\n\t\tvtotal *= htotal;\n\n\t\t \n\t\tposition = min(position, vtotal - 1);\n\n\t\t \n\t\tposition = (position + htotal - hsync_start) % vtotal;\n\t}\n\n\t \n\tif (etime)\n\t\t*etime = ktime_get();\n\n\t \n\n\tspin_unlock_irqrestore(&dev_priv->uncore.lock, irqflags);\n\n\t \n\tif (position >= vbl_start)\n\t\tposition -= vbl_end;\n\telse\n\t\tposition += vtotal - vbl_end;\n\n\tif (use_scanline_counter) {\n\t\t*vpos = position;\n\t\t*hpos = 0;\n\t} else {\n\t\t*vpos = position / htotal;\n\t\t*hpos = position - (*vpos * htotal);\n\t}\n\n\treturn true;\n}\n\nbool intel_crtc_get_vblank_timestamp(struct drm_crtc *crtc, int *max_error,\n\t\t\t\t     ktime_t *vblank_time, bool in_vblank_irq)\n{\n\treturn drm_crtc_vblank_helper_get_vblank_timestamp_internal(\n\t\tcrtc, max_error, vblank_time, in_vblank_irq,\n\t\ti915_get_crtc_scanoutpos);\n}\n\nint intel_get_crtc_scanline(struct intel_crtc *crtc)\n{\n\tstruct drm_i915_private *dev_priv = to_i915(crtc->base.dev);\n\tunsigned long irqflags;\n\tint position;\n\n\tspin_lock_irqsave(&dev_priv->uncore.lock, irqflags);\n\tposition = __intel_get_crtc_scanline(crtc);\n\tspin_unlock_irqrestore(&dev_priv->uncore.lock, irqflags);\n\n\treturn position;\n}\n\nstatic bool pipe_scanline_is_moving(struct drm_i915_private *dev_priv,\n\t\t\t\t    enum pipe pipe)\n{\n\ti915_reg_t reg = PIPEDSL(pipe);\n\tu32 line1, line2;\n\n\tline1 = intel_de_read(dev_priv, reg) & PIPEDSL_LINE_MASK;\n\tmsleep(5);\n\tline2 = intel_de_read(dev_priv, reg) & PIPEDSL_LINE_MASK;\n\n\treturn line1 != line2;\n}\n\nstatic void wait_for_pipe_scanline_moving(struct intel_crtc *crtc, bool state)\n{\n\tstruct drm_i915_private *dev_priv = to_i915(crtc->base.dev);\n\tenum pipe pipe = crtc->pipe;\n\n\t \n\tif (wait_for(pipe_scanline_is_moving(dev_priv, pipe) == state, 100))\n\t\tdrm_err(&dev_priv->drm,\n\t\t\t\"pipe %c scanline %s wait timed out\\n\",\n\t\t\tpipe_name(pipe), str_on_off(state));\n}\n\nvoid intel_wait_for_pipe_scanline_stopped(struct intel_crtc *crtc)\n{\n\twait_for_pipe_scanline_moving(crtc, false);\n}\n\nvoid intel_wait_for_pipe_scanline_moving(struct intel_crtc *crtc)\n{\n\twait_for_pipe_scanline_moving(crtc, true);\n}\n\nstatic int intel_crtc_scanline_offset(const struct intel_crtc_state *crtc_state)\n{\n\tstruct drm_i915_private *i915 = to_i915(crtc_state->uapi.crtc->dev);\n\tconst struct drm_display_mode *adjusted_mode = &crtc_state->hw.adjusted_mode;\n\n\t \n\tif (DISPLAY_VER(i915) == 2) {\n\t\tint vtotal;\n\n\t\tvtotal = adjusted_mode->crtc_vtotal;\n\t\tif (adjusted_mode->flags & DRM_MODE_FLAG_INTERLACE)\n\t\t\tvtotal /= 2;\n\n\t\treturn vtotal - 1;\n\t} else if (HAS_DDI(i915) && intel_crtc_has_type(crtc_state, INTEL_OUTPUT_HDMI)) {\n\t\treturn 2;\n\t} else {\n\t\treturn 1;\n\t}\n}\n\nvoid intel_crtc_update_active_timings(const struct intel_crtc_state *crtc_state,\n\t\t\t\t      bool vrr_enable)\n{\n\tstruct intel_crtc *crtc = to_intel_crtc(crtc_state->uapi.crtc);\n\tstruct drm_i915_private *i915 = to_i915(crtc->base.dev);\n\tu8 mode_flags = crtc_state->mode_flags;\n\tstruct drm_display_mode adjusted_mode;\n\tint vmax_vblank_start = 0;\n\tunsigned long irqflags;\n\n\tdrm_mode_init(&adjusted_mode, &crtc_state->hw.adjusted_mode);\n\n\tif (vrr_enable) {\n\t\tdrm_WARN_ON(&i915->drm, (mode_flags & I915_MODE_FLAG_VRR) == 0);\n\n\t\tadjusted_mode.crtc_vtotal = crtc_state->vrr.vmax;\n\t\tadjusted_mode.crtc_vblank_end = crtc_state->vrr.vmax;\n\t\tadjusted_mode.crtc_vblank_start = intel_vrr_vmin_vblank_start(crtc_state);\n\t\tvmax_vblank_start = intel_vrr_vmax_vblank_start(crtc_state);\n\t} else {\n\t\tmode_flags &= ~I915_MODE_FLAG_VRR;\n\t}\n\n\t \n\tspin_lock_irqsave(&i915->drm.vblank_time_lock, irqflags);\n\tspin_lock(&i915->uncore.lock);\n\n\tdrm_calc_timestamping_constants(&crtc->base, &adjusted_mode);\n\n\tcrtc->vmax_vblank_start = vmax_vblank_start;\n\n\tcrtc->mode_flags = mode_flags;\n\n\tcrtc->scanline_offset = intel_crtc_scanline_offset(crtc_state);\n\n\tspin_unlock(&i915->uncore.lock);\n\tspin_unlock_irqrestore(&i915->drm.vblank_time_lock, irqflags);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}