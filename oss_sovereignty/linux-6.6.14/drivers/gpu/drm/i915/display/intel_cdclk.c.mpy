{
  "module_name": "intel_cdclk.c",
  "hash_id": "2429aece476d94012c504c8ad554ef2821d993ecdfbeb90238769f29ad3a8e0b",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/i915/display/intel_cdclk.c",
  "human_readable_source": " \n\n#include <linux/time.h>\n\n#include \"hsw_ips.h\"\n#include \"i915_reg.h\"\n#include \"intel_atomic.h\"\n#include \"intel_atomic_plane.h\"\n#include \"intel_audio.h\"\n#include \"intel_bw.h\"\n#include \"intel_cdclk.h\"\n#include \"intel_crtc.h\"\n#include \"intel_de.h\"\n#include \"intel_display_types.h\"\n#include \"intel_mchbar_regs.h\"\n#include \"intel_pci_config.h\"\n#include \"intel_pcode.h\"\n#include \"intel_psr.h\"\n#include \"intel_vdsc.h\"\n#include \"vlv_sideband.h\"\n\n \n\nstruct intel_cdclk_funcs {\n\tvoid (*get_cdclk)(struct drm_i915_private *i915,\n\t\t\t  struct intel_cdclk_config *cdclk_config);\n\tvoid (*set_cdclk)(struct drm_i915_private *i915,\n\t\t\t  const struct intel_cdclk_config *cdclk_config,\n\t\t\t  enum pipe pipe);\n\tint (*modeset_calc_cdclk)(struct intel_cdclk_state *state);\n\tu8 (*calc_voltage_level)(int cdclk);\n};\n\nvoid intel_cdclk_get_cdclk(struct drm_i915_private *dev_priv,\n\t\t\t   struct intel_cdclk_config *cdclk_config)\n{\n\tdev_priv->display.funcs.cdclk->get_cdclk(dev_priv, cdclk_config);\n}\n\nstatic void intel_cdclk_set_cdclk(struct drm_i915_private *dev_priv,\n\t\t\t\t  const struct intel_cdclk_config *cdclk_config,\n\t\t\t\t  enum pipe pipe)\n{\n\tdev_priv->display.funcs.cdclk->set_cdclk(dev_priv, cdclk_config, pipe);\n}\n\nstatic int intel_cdclk_modeset_calc_cdclk(struct drm_i915_private *dev_priv,\n\t\t\t\t\t  struct intel_cdclk_state *cdclk_config)\n{\n\treturn dev_priv->display.funcs.cdclk->modeset_calc_cdclk(cdclk_config);\n}\n\nstatic u8 intel_cdclk_calc_voltage_level(struct drm_i915_private *dev_priv,\n\t\t\t\t\t int cdclk)\n{\n\treturn dev_priv->display.funcs.cdclk->calc_voltage_level(cdclk);\n}\n\nstatic void fixed_133mhz_get_cdclk(struct drm_i915_private *dev_priv,\n\t\t\t\t   struct intel_cdclk_config *cdclk_config)\n{\n\tcdclk_config->cdclk = 133333;\n}\n\nstatic void fixed_200mhz_get_cdclk(struct drm_i915_private *dev_priv,\n\t\t\t\t   struct intel_cdclk_config *cdclk_config)\n{\n\tcdclk_config->cdclk = 200000;\n}\n\nstatic void fixed_266mhz_get_cdclk(struct drm_i915_private *dev_priv,\n\t\t\t\t   struct intel_cdclk_config *cdclk_config)\n{\n\tcdclk_config->cdclk = 266667;\n}\n\nstatic void fixed_333mhz_get_cdclk(struct drm_i915_private *dev_priv,\n\t\t\t\t   struct intel_cdclk_config *cdclk_config)\n{\n\tcdclk_config->cdclk = 333333;\n}\n\nstatic void fixed_400mhz_get_cdclk(struct drm_i915_private *dev_priv,\n\t\t\t\t   struct intel_cdclk_config *cdclk_config)\n{\n\tcdclk_config->cdclk = 400000;\n}\n\nstatic void fixed_450mhz_get_cdclk(struct drm_i915_private *dev_priv,\n\t\t\t\t   struct intel_cdclk_config *cdclk_config)\n{\n\tcdclk_config->cdclk = 450000;\n}\n\nstatic void i85x_get_cdclk(struct drm_i915_private *dev_priv,\n\t\t\t   struct intel_cdclk_config *cdclk_config)\n{\n\tstruct pci_dev *pdev = to_pci_dev(dev_priv->drm.dev);\n\tu16 hpllcc = 0;\n\n\t \n\tif (pdev->revision == 0x1) {\n\t\tcdclk_config->cdclk = 133333;\n\t\treturn;\n\t}\n\n\tpci_bus_read_config_word(pdev->bus,\n\t\t\t\t PCI_DEVFN(0, 3), HPLLCC, &hpllcc);\n\n\t \n\tswitch (hpllcc & GC_CLOCK_CONTROL_MASK) {\n\tcase GC_CLOCK_133_200:\n\tcase GC_CLOCK_133_200_2:\n\tcase GC_CLOCK_100_200:\n\t\tcdclk_config->cdclk = 200000;\n\t\tbreak;\n\tcase GC_CLOCK_166_250:\n\t\tcdclk_config->cdclk = 250000;\n\t\tbreak;\n\tcase GC_CLOCK_100_133:\n\t\tcdclk_config->cdclk = 133333;\n\t\tbreak;\n\tcase GC_CLOCK_133_266:\n\tcase GC_CLOCK_133_266_2:\n\tcase GC_CLOCK_166_266:\n\t\tcdclk_config->cdclk = 266667;\n\t\tbreak;\n\t}\n}\n\nstatic void i915gm_get_cdclk(struct drm_i915_private *dev_priv,\n\t\t\t     struct intel_cdclk_config *cdclk_config)\n{\n\tstruct pci_dev *pdev = to_pci_dev(dev_priv->drm.dev);\n\tu16 gcfgc = 0;\n\n\tpci_read_config_word(pdev, GCFGC, &gcfgc);\n\n\tif (gcfgc & GC_LOW_FREQUENCY_ENABLE) {\n\t\tcdclk_config->cdclk = 133333;\n\t\treturn;\n\t}\n\n\tswitch (gcfgc & GC_DISPLAY_CLOCK_MASK) {\n\tcase GC_DISPLAY_CLOCK_333_320_MHZ:\n\t\tcdclk_config->cdclk = 333333;\n\t\tbreak;\n\tdefault:\n\tcase GC_DISPLAY_CLOCK_190_200_MHZ:\n\t\tcdclk_config->cdclk = 190000;\n\t\tbreak;\n\t}\n}\n\nstatic void i945gm_get_cdclk(struct drm_i915_private *dev_priv,\n\t\t\t     struct intel_cdclk_config *cdclk_config)\n{\n\tstruct pci_dev *pdev = to_pci_dev(dev_priv->drm.dev);\n\tu16 gcfgc = 0;\n\n\tpci_read_config_word(pdev, GCFGC, &gcfgc);\n\n\tif (gcfgc & GC_LOW_FREQUENCY_ENABLE) {\n\t\tcdclk_config->cdclk = 133333;\n\t\treturn;\n\t}\n\n\tswitch (gcfgc & GC_DISPLAY_CLOCK_MASK) {\n\tcase GC_DISPLAY_CLOCK_333_320_MHZ:\n\t\tcdclk_config->cdclk = 320000;\n\t\tbreak;\n\tdefault:\n\tcase GC_DISPLAY_CLOCK_190_200_MHZ:\n\t\tcdclk_config->cdclk = 200000;\n\t\tbreak;\n\t}\n}\n\nstatic unsigned int intel_hpll_vco(struct drm_i915_private *dev_priv)\n{\n\tstatic const unsigned int blb_vco[8] = {\n\t\t[0] = 3200000,\n\t\t[1] = 4000000,\n\t\t[2] = 5333333,\n\t\t[3] = 4800000,\n\t\t[4] = 6400000,\n\t};\n\tstatic const unsigned int pnv_vco[8] = {\n\t\t[0] = 3200000,\n\t\t[1] = 4000000,\n\t\t[2] = 5333333,\n\t\t[3] = 4800000,\n\t\t[4] = 2666667,\n\t};\n\tstatic const unsigned int cl_vco[8] = {\n\t\t[0] = 3200000,\n\t\t[1] = 4000000,\n\t\t[2] = 5333333,\n\t\t[3] = 6400000,\n\t\t[4] = 3333333,\n\t\t[5] = 3566667,\n\t\t[6] = 4266667,\n\t};\n\tstatic const unsigned int elk_vco[8] = {\n\t\t[0] = 3200000,\n\t\t[1] = 4000000,\n\t\t[2] = 5333333,\n\t\t[3] = 4800000,\n\t};\n\tstatic const unsigned int ctg_vco[8] = {\n\t\t[0] = 3200000,\n\t\t[1] = 4000000,\n\t\t[2] = 5333333,\n\t\t[3] = 6400000,\n\t\t[4] = 2666667,\n\t\t[5] = 4266667,\n\t};\n\tconst unsigned int *vco_table;\n\tunsigned int vco;\n\tu8 tmp = 0;\n\n\t \n\tif (IS_GM45(dev_priv))\n\t\tvco_table = ctg_vco;\n\telse if (IS_G45(dev_priv))\n\t\tvco_table = elk_vco;\n\telse if (IS_I965GM(dev_priv))\n\t\tvco_table = cl_vco;\n\telse if (IS_PINEVIEW(dev_priv))\n\t\tvco_table = pnv_vco;\n\telse if (IS_G33(dev_priv))\n\t\tvco_table = blb_vco;\n\telse\n\t\treturn 0;\n\n\ttmp = intel_de_read(dev_priv,\n\t\t\t    IS_PINEVIEW(dev_priv) || IS_MOBILE(dev_priv) ? HPLLVCO_MOBILE : HPLLVCO);\n\n\tvco = vco_table[tmp & 0x7];\n\tif (vco == 0)\n\t\tdrm_err(&dev_priv->drm, \"Bad HPLL VCO (HPLLVCO=0x%02x)\\n\",\n\t\t\ttmp);\n\telse\n\t\tdrm_dbg_kms(&dev_priv->drm, \"HPLL VCO %u kHz\\n\", vco);\n\n\treturn vco;\n}\n\nstatic void g33_get_cdclk(struct drm_i915_private *dev_priv,\n\t\t\t  struct intel_cdclk_config *cdclk_config)\n{\n\tstruct pci_dev *pdev = to_pci_dev(dev_priv->drm.dev);\n\tstatic const u8 div_3200[] = { 12, 10,  8,  7, 5, 16 };\n\tstatic const u8 div_4000[] = { 14, 12, 10,  8, 6, 20 };\n\tstatic const u8 div_4800[] = { 20, 14, 12, 10, 8, 24 };\n\tstatic const u8 div_5333[] = { 20, 16, 12, 12, 8, 28 };\n\tconst u8 *div_table;\n\tunsigned int cdclk_sel;\n\tu16 tmp = 0;\n\n\tcdclk_config->vco = intel_hpll_vco(dev_priv);\n\n\tpci_read_config_word(pdev, GCFGC, &tmp);\n\n\tcdclk_sel = (tmp >> 4) & 0x7;\n\n\tif (cdclk_sel >= ARRAY_SIZE(div_3200))\n\t\tgoto fail;\n\n\tswitch (cdclk_config->vco) {\n\tcase 3200000:\n\t\tdiv_table = div_3200;\n\t\tbreak;\n\tcase 4000000:\n\t\tdiv_table = div_4000;\n\t\tbreak;\n\tcase 4800000:\n\t\tdiv_table = div_4800;\n\t\tbreak;\n\tcase 5333333:\n\t\tdiv_table = div_5333;\n\t\tbreak;\n\tdefault:\n\t\tgoto fail;\n\t}\n\n\tcdclk_config->cdclk = DIV_ROUND_CLOSEST(cdclk_config->vco,\n\t\t\t\t\t\tdiv_table[cdclk_sel]);\n\treturn;\n\nfail:\n\tdrm_err(&dev_priv->drm,\n\t\t\"Unable to determine CDCLK. HPLL VCO=%u kHz, CFGC=0x%08x\\n\",\n\t\tcdclk_config->vco, tmp);\n\tcdclk_config->cdclk = 190476;\n}\n\nstatic void pnv_get_cdclk(struct drm_i915_private *dev_priv,\n\t\t\t  struct intel_cdclk_config *cdclk_config)\n{\n\tstruct pci_dev *pdev = to_pci_dev(dev_priv->drm.dev);\n\tu16 gcfgc = 0;\n\n\tpci_read_config_word(pdev, GCFGC, &gcfgc);\n\n\tswitch (gcfgc & GC_DISPLAY_CLOCK_MASK) {\n\tcase GC_DISPLAY_CLOCK_267_MHZ_PNV:\n\t\tcdclk_config->cdclk = 266667;\n\t\tbreak;\n\tcase GC_DISPLAY_CLOCK_333_MHZ_PNV:\n\t\tcdclk_config->cdclk = 333333;\n\t\tbreak;\n\tcase GC_DISPLAY_CLOCK_444_MHZ_PNV:\n\t\tcdclk_config->cdclk = 444444;\n\t\tbreak;\n\tcase GC_DISPLAY_CLOCK_200_MHZ_PNV:\n\t\tcdclk_config->cdclk = 200000;\n\t\tbreak;\n\tdefault:\n\t\tdrm_err(&dev_priv->drm,\n\t\t\t\"Unknown pnv display core clock 0x%04x\\n\", gcfgc);\n\t\tfallthrough;\n\tcase GC_DISPLAY_CLOCK_133_MHZ_PNV:\n\t\tcdclk_config->cdclk = 133333;\n\t\tbreak;\n\tcase GC_DISPLAY_CLOCK_167_MHZ_PNV:\n\t\tcdclk_config->cdclk = 166667;\n\t\tbreak;\n\t}\n}\n\nstatic void i965gm_get_cdclk(struct drm_i915_private *dev_priv,\n\t\t\t     struct intel_cdclk_config *cdclk_config)\n{\n\tstruct pci_dev *pdev = to_pci_dev(dev_priv->drm.dev);\n\tstatic const u8 div_3200[] = { 16, 10,  8 };\n\tstatic const u8 div_4000[] = { 20, 12, 10 };\n\tstatic const u8 div_5333[] = { 24, 16, 14 };\n\tconst u8 *div_table;\n\tunsigned int cdclk_sel;\n\tu16 tmp = 0;\n\n\tcdclk_config->vco = intel_hpll_vco(dev_priv);\n\n\tpci_read_config_word(pdev, GCFGC, &tmp);\n\n\tcdclk_sel = ((tmp >> 8) & 0x1f) - 1;\n\n\tif (cdclk_sel >= ARRAY_SIZE(div_3200))\n\t\tgoto fail;\n\n\tswitch (cdclk_config->vco) {\n\tcase 3200000:\n\t\tdiv_table = div_3200;\n\t\tbreak;\n\tcase 4000000:\n\t\tdiv_table = div_4000;\n\t\tbreak;\n\tcase 5333333:\n\t\tdiv_table = div_5333;\n\t\tbreak;\n\tdefault:\n\t\tgoto fail;\n\t}\n\n\tcdclk_config->cdclk = DIV_ROUND_CLOSEST(cdclk_config->vco,\n\t\t\t\t\t\tdiv_table[cdclk_sel]);\n\treturn;\n\nfail:\n\tdrm_err(&dev_priv->drm,\n\t\t\"Unable to determine CDCLK. HPLL VCO=%u kHz, CFGC=0x%04x\\n\",\n\t\tcdclk_config->vco, tmp);\n\tcdclk_config->cdclk = 200000;\n}\n\nstatic void gm45_get_cdclk(struct drm_i915_private *dev_priv,\n\t\t\t   struct intel_cdclk_config *cdclk_config)\n{\n\tstruct pci_dev *pdev = to_pci_dev(dev_priv->drm.dev);\n\tunsigned int cdclk_sel;\n\tu16 tmp = 0;\n\n\tcdclk_config->vco = intel_hpll_vco(dev_priv);\n\n\tpci_read_config_word(pdev, GCFGC, &tmp);\n\n\tcdclk_sel = (tmp >> 12) & 0x1;\n\n\tswitch (cdclk_config->vco) {\n\tcase 2666667:\n\tcase 4000000:\n\tcase 5333333:\n\t\tcdclk_config->cdclk = cdclk_sel ? 333333 : 222222;\n\t\tbreak;\n\tcase 3200000:\n\t\tcdclk_config->cdclk = cdclk_sel ? 320000 : 228571;\n\t\tbreak;\n\tdefault:\n\t\tdrm_err(&dev_priv->drm,\n\t\t\t\"Unable to determine CDCLK. HPLL VCO=%u, CFGC=0x%04x\\n\",\n\t\t\tcdclk_config->vco, tmp);\n\t\tcdclk_config->cdclk = 222222;\n\t\tbreak;\n\t}\n}\n\nstatic void hsw_get_cdclk(struct drm_i915_private *dev_priv,\n\t\t\t  struct intel_cdclk_config *cdclk_config)\n{\n\tu32 lcpll = intel_de_read(dev_priv, LCPLL_CTL);\n\tu32 freq = lcpll & LCPLL_CLK_FREQ_MASK;\n\n\tif (lcpll & LCPLL_CD_SOURCE_FCLK)\n\t\tcdclk_config->cdclk = 800000;\n\telse if (intel_de_read(dev_priv, FUSE_STRAP) & HSW_CDCLK_LIMIT)\n\t\tcdclk_config->cdclk = 450000;\n\telse if (freq == LCPLL_CLK_FREQ_450)\n\t\tcdclk_config->cdclk = 450000;\n\telse if (IS_HASWELL_ULT(dev_priv))\n\t\tcdclk_config->cdclk = 337500;\n\telse\n\t\tcdclk_config->cdclk = 540000;\n}\n\nstatic int vlv_calc_cdclk(struct drm_i915_private *dev_priv, int min_cdclk)\n{\n\tint freq_320 = (dev_priv->hpll_freq <<  1) % 320000 != 0 ?\n\t\t333333 : 320000;\n\n\t \n\tif (IS_VALLEYVIEW(dev_priv) && min_cdclk > freq_320)\n\t\treturn 400000;\n\telse if (min_cdclk > 266667)\n\t\treturn freq_320;\n\telse if (min_cdclk > 0)\n\t\treturn 266667;\n\telse\n\t\treturn 200000;\n}\n\nstatic u8 vlv_calc_voltage_level(struct drm_i915_private *dev_priv, int cdclk)\n{\n\tif (IS_VALLEYVIEW(dev_priv)) {\n\t\tif (cdclk >= 320000)  \n\t\t\treturn 2;\n\t\telse if (cdclk >= 266667)\n\t\t\treturn 1;\n\t\telse\n\t\t\treturn 0;\n\t} else {\n\t\t \n\t\treturn DIV_ROUND_CLOSEST(dev_priv->hpll_freq << 1, cdclk) - 1;\n\t}\n}\n\nstatic void vlv_get_cdclk(struct drm_i915_private *dev_priv,\n\t\t\t  struct intel_cdclk_config *cdclk_config)\n{\n\tu32 val;\n\n\tvlv_iosf_sb_get(dev_priv,\n\t\t\tBIT(VLV_IOSF_SB_CCK) | BIT(VLV_IOSF_SB_PUNIT));\n\n\tcdclk_config->vco = vlv_get_hpll_vco(dev_priv);\n\tcdclk_config->cdclk = vlv_get_cck_clock(dev_priv, \"cdclk\",\n\t\t\t\t\t\tCCK_DISPLAY_CLOCK_CONTROL,\n\t\t\t\t\t\tcdclk_config->vco);\n\n\tval = vlv_punit_read(dev_priv, PUNIT_REG_DSPSSPM);\n\n\tvlv_iosf_sb_put(dev_priv,\n\t\t\tBIT(VLV_IOSF_SB_CCK) | BIT(VLV_IOSF_SB_PUNIT));\n\n\tif (IS_VALLEYVIEW(dev_priv))\n\t\tcdclk_config->voltage_level = (val & DSPFREQGUAR_MASK) >>\n\t\t\tDSPFREQGUAR_SHIFT;\n\telse\n\t\tcdclk_config->voltage_level = (val & DSPFREQGUAR_MASK_CHV) >>\n\t\t\tDSPFREQGUAR_SHIFT_CHV;\n}\n\nstatic void vlv_program_pfi_credits(struct drm_i915_private *dev_priv)\n{\n\tunsigned int credits, default_credits;\n\n\tif (IS_CHERRYVIEW(dev_priv))\n\t\tdefault_credits = PFI_CREDIT(12);\n\telse\n\t\tdefault_credits = PFI_CREDIT(8);\n\n\tif (dev_priv->display.cdclk.hw.cdclk >= dev_priv->czclk_freq) {\n\t\t \n\t\tif (IS_CHERRYVIEW(dev_priv))\n\t\t\tcredits = PFI_CREDIT_63;\n\t\telse\n\t\t\tcredits = PFI_CREDIT(15);\n\t} else {\n\t\tcredits = default_credits;\n\t}\n\n\t \n\tintel_de_write(dev_priv, GCI_CONTROL,\n\t\t       VGA_FAST_MODE_DISABLE | default_credits);\n\n\tintel_de_write(dev_priv, GCI_CONTROL,\n\t\t       VGA_FAST_MODE_DISABLE | credits | PFI_CREDIT_RESEND);\n\n\t \n\tdrm_WARN_ON(&dev_priv->drm,\n\t\t    intel_de_read(dev_priv, GCI_CONTROL) & PFI_CREDIT_RESEND);\n}\n\nstatic void vlv_set_cdclk(struct drm_i915_private *dev_priv,\n\t\t\t  const struct intel_cdclk_config *cdclk_config,\n\t\t\t  enum pipe pipe)\n{\n\tint cdclk = cdclk_config->cdclk;\n\tu32 val, cmd = cdclk_config->voltage_level;\n\tintel_wakeref_t wakeref;\n\n\tswitch (cdclk) {\n\tcase 400000:\n\tcase 333333:\n\tcase 320000:\n\tcase 266667:\n\tcase 200000:\n\t\tbreak;\n\tdefault:\n\t\tMISSING_CASE(cdclk);\n\t\treturn;\n\t}\n\n\t \n\twakeref = intel_display_power_get(dev_priv, POWER_DOMAIN_DISPLAY_CORE);\n\n\tvlv_iosf_sb_get(dev_priv,\n\t\t\tBIT(VLV_IOSF_SB_CCK) |\n\t\t\tBIT(VLV_IOSF_SB_BUNIT) |\n\t\t\tBIT(VLV_IOSF_SB_PUNIT));\n\n\tval = vlv_punit_read(dev_priv, PUNIT_REG_DSPSSPM);\n\tval &= ~DSPFREQGUAR_MASK;\n\tval |= (cmd << DSPFREQGUAR_SHIFT);\n\tvlv_punit_write(dev_priv, PUNIT_REG_DSPSSPM, val);\n\tif (wait_for((vlv_punit_read(dev_priv, PUNIT_REG_DSPSSPM) &\n\t\t      DSPFREQSTAT_MASK) == (cmd << DSPFREQSTAT_SHIFT),\n\t\t     50)) {\n\t\tdrm_err(&dev_priv->drm,\n\t\t\t\"timed out waiting for CDclk change\\n\");\n\t}\n\n\tif (cdclk == 400000) {\n\t\tu32 divider;\n\n\t\tdivider = DIV_ROUND_CLOSEST(dev_priv->hpll_freq << 1,\n\t\t\t\t\t    cdclk) - 1;\n\n\t\t \n\t\tval = vlv_cck_read(dev_priv, CCK_DISPLAY_CLOCK_CONTROL);\n\t\tval &= ~CCK_FREQUENCY_VALUES;\n\t\tval |= divider;\n\t\tvlv_cck_write(dev_priv, CCK_DISPLAY_CLOCK_CONTROL, val);\n\n\t\tif (wait_for((vlv_cck_read(dev_priv, CCK_DISPLAY_CLOCK_CONTROL) &\n\t\t\t      CCK_FREQUENCY_STATUS) == (divider << CCK_FREQUENCY_STATUS_SHIFT),\n\t\t\t     50))\n\t\t\tdrm_err(&dev_priv->drm,\n\t\t\t\t\"timed out waiting for CDclk change\\n\");\n\t}\n\n\t \n\tval = vlv_bunit_read(dev_priv, BUNIT_REG_BISOC);\n\tval &= ~0x7f;\n\n\t \n\tif (cdclk == 400000)\n\t\tval |= 4500 / 250;  \n\telse\n\t\tval |= 3000 / 250;  \n\tvlv_bunit_write(dev_priv, BUNIT_REG_BISOC, val);\n\n\tvlv_iosf_sb_put(dev_priv,\n\t\t\tBIT(VLV_IOSF_SB_CCK) |\n\t\t\tBIT(VLV_IOSF_SB_BUNIT) |\n\t\t\tBIT(VLV_IOSF_SB_PUNIT));\n\n\tintel_update_cdclk(dev_priv);\n\n\tvlv_program_pfi_credits(dev_priv);\n\n\tintel_display_power_put(dev_priv, POWER_DOMAIN_DISPLAY_CORE, wakeref);\n}\n\nstatic void chv_set_cdclk(struct drm_i915_private *dev_priv,\n\t\t\t  const struct intel_cdclk_config *cdclk_config,\n\t\t\t  enum pipe pipe)\n{\n\tint cdclk = cdclk_config->cdclk;\n\tu32 val, cmd = cdclk_config->voltage_level;\n\tintel_wakeref_t wakeref;\n\n\tswitch (cdclk) {\n\tcase 333333:\n\tcase 320000:\n\tcase 266667:\n\tcase 200000:\n\t\tbreak;\n\tdefault:\n\t\tMISSING_CASE(cdclk);\n\t\treturn;\n\t}\n\n\t \n\twakeref = intel_display_power_get(dev_priv, POWER_DOMAIN_DISPLAY_CORE);\n\n\tvlv_punit_get(dev_priv);\n\tval = vlv_punit_read(dev_priv, PUNIT_REG_DSPSSPM);\n\tval &= ~DSPFREQGUAR_MASK_CHV;\n\tval |= (cmd << DSPFREQGUAR_SHIFT_CHV);\n\tvlv_punit_write(dev_priv, PUNIT_REG_DSPSSPM, val);\n\tif (wait_for((vlv_punit_read(dev_priv, PUNIT_REG_DSPSSPM) &\n\t\t      DSPFREQSTAT_MASK_CHV) == (cmd << DSPFREQSTAT_SHIFT_CHV),\n\t\t     50)) {\n\t\tdrm_err(&dev_priv->drm,\n\t\t\t\"timed out waiting for CDclk change\\n\");\n\t}\n\n\tvlv_punit_put(dev_priv);\n\n\tintel_update_cdclk(dev_priv);\n\n\tvlv_program_pfi_credits(dev_priv);\n\n\tintel_display_power_put(dev_priv, POWER_DOMAIN_DISPLAY_CORE, wakeref);\n}\n\nstatic int bdw_calc_cdclk(int min_cdclk)\n{\n\tif (min_cdclk > 540000)\n\t\treturn 675000;\n\telse if (min_cdclk > 450000)\n\t\treturn 540000;\n\telse if (min_cdclk > 337500)\n\t\treturn 450000;\n\telse\n\t\treturn 337500;\n}\n\nstatic u8 bdw_calc_voltage_level(int cdclk)\n{\n\tswitch (cdclk) {\n\tdefault:\n\tcase 337500:\n\t\treturn 2;\n\tcase 450000:\n\t\treturn 0;\n\tcase 540000:\n\t\treturn 1;\n\tcase 675000:\n\t\treturn 3;\n\t}\n}\n\nstatic void bdw_get_cdclk(struct drm_i915_private *dev_priv,\n\t\t\t  struct intel_cdclk_config *cdclk_config)\n{\n\tu32 lcpll = intel_de_read(dev_priv, LCPLL_CTL);\n\tu32 freq = lcpll & LCPLL_CLK_FREQ_MASK;\n\n\tif (lcpll & LCPLL_CD_SOURCE_FCLK)\n\t\tcdclk_config->cdclk = 800000;\n\telse if (intel_de_read(dev_priv, FUSE_STRAP) & HSW_CDCLK_LIMIT)\n\t\tcdclk_config->cdclk = 450000;\n\telse if (freq == LCPLL_CLK_FREQ_450)\n\t\tcdclk_config->cdclk = 450000;\n\telse if (freq == LCPLL_CLK_FREQ_54O_BDW)\n\t\tcdclk_config->cdclk = 540000;\n\telse if (freq == LCPLL_CLK_FREQ_337_5_BDW)\n\t\tcdclk_config->cdclk = 337500;\n\telse\n\t\tcdclk_config->cdclk = 675000;\n\n\t \n\tcdclk_config->voltage_level =\n\t\tbdw_calc_voltage_level(cdclk_config->cdclk);\n}\n\nstatic u32 bdw_cdclk_freq_sel(int cdclk)\n{\n\tswitch (cdclk) {\n\tdefault:\n\t\tMISSING_CASE(cdclk);\n\t\tfallthrough;\n\tcase 337500:\n\t\treturn LCPLL_CLK_FREQ_337_5_BDW;\n\tcase 450000:\n\t\treturn LCPLL_CLK_FREQ_450;\n\tcase 540000:\n\t\treturn LCPLL_CLK_FREQ_54O_BDW;\n\tcase 675000:\n\t\treturn LCPLL_CLK_FREQ_675_BDW;\n\t}\n}\n\nstatic void bdw_set_cdclk(struct drm_i915_private *dev_priv,\n\t\t\t  const struct intel_cdclk_config *cdclk_config,\n\t\t\t  enum pipe pipe)\n{\n\tint cdclk = cdclk_config->cdclk;\n\tint ret;\n\n\tif (drm_WARN(&dev_priv->drm,\n\t\t     (intel_de_read(dev_priv, LCPLL_CTL) &\n\t\t      (LCPLL_PLL_DISABLE | LCPLL_PLL_LOCK |\n\t\t       LCPLL_CD_CLOCK_DISABLE | LCPLL_ROOT_CD_CLOCK_DISABLE |\n\t\t       LCPLL_CD2X_CLOCK_DISABLE | LCPLL_POWER_DOWN_ALLOW |\n\t\t       LCPLL_CD_SOURCE_FCLK)) != LCPLL_PLL_LOCK,\n\t\t     \"trying to change cdclk frequency with cdclk not enabled\\n\"))\n\t\treturn;\n\n\tret = snb_pcode_write(&dev_priv->uncore, BDW_PCODE_DISPLAY_FREQ_CHANGE_REQ, 0x0);\n\tif (ret) {\n\t\tdrm_err(&dev_priv->drm,\n\t\t\t\"failed to inform pcode about cdclk change\\n\");\n\t\treturn;\n\t}\n\n\tintel_de_rmw(dev_priv, LCPLL_CTL,\n\t\t     0, LCPLL_CD_SOURCE_FCLK);\n\n\t \n\tif (wait_for_us(intel_de_read(dev_priv, LCPLL_CTL) &\n\t\t\tLCPLL_CD_SOURCE_FCLK_DONE, 100))\n\t\tdrm_err(&dev_priv->drm, \"Switching to FCLK failed\\n\");\n\n\tintel_de_rmw(dev_priv, LCPLL_CTL,\n\t\t     LCPLL_CLK_FREQ_MASK, bdw_cdclk_freq_sel(cdclk));\n\n\tintel_de_rmw(dev_priv, LCPLL_CTL,\n\t\t     LCPLL_CD_SOURCE_FCLK, 0);\n\n\tif (wait_for_us((intel_de_read(dev_priv, LCPLL_CTL) &\n\t\t\t LCPLL_CD_SOURCE_FCLK_DONE) == 0, 1))\n\t\tdrm_err(&dev_priv->drm, \"Switching back to LCPLL failed\\n\");\n\n\tsnb_pcode_write(&dev_priv->uncore, HSW_PCODE_DE_WRITE_FREQ_REQ,\n\t\t\tcdclk_config->voltage_level);\n\n\tintel_de_write(dev_priv, CDCLK_FREQ,\n\t\t       DIV_ROUND_CLOSEST(cdclk, 1000) - 1);\n\n\tintel_update_cdclk(dev_priv);\n}\n\nstatic int skl_calc_cdclk(int min_cdclk, int vco)\n{\n\tif (vco == 8640000) {\n\t\tif (min_cdclk > 540000)\n\t\t\treturn 617143;\n\t\telse if (min_cdclk > 432000)\n\t\t\treturn 540000;\n\t\telse if (min_cdclk > 308571)\n\t\t\treturn 432000;\n\t\telse\n\t\t\treturn 308571;\n\t} else {\n\t\tif (min_cdclk > 540000)\n\t\t\treturn 675000;\n\t\telse if (min_cdclk > 450000)\n\t\t\treturn 540000;\n\t\telse if (min_cdclk > 337500)\n\t\t\treturn 450000;\n\t\telse\n\t\t\treturn 337500;\n\t}\n}\n\nstatic u8 skl_calc_voltage_level(int cdclk)\n{\n\tif (cdclk > 540000)\n\t\treturn 3;\n\telse if (cdclk > 450000)\n\t\treturn 2;\n\telse if (cdclk > 337500)\n\t\treturn 1;\n\telse\n\t\treturn 0;\n}\n\nstatic void skl_dpll0_update(struct drm_i915_private *dev_priv,\n\t\t\t     struct intel_cdclk_config *cdclk_config)\n{\n\tu32 val;\n\n\tcdclk_config->ref = 24000;\n\tcdclk_config->vco = 0;\n\n\tval = intel_de_read(dev_priv, LCPLL1_CTL);\n\tif ((val & LCPLL_PLL_ENABLE) == 0)\n\t\treturn;\n\n\tif (drm_WARN_ON(&dev_priv->drm, (val & LCPLL_PLL_LOCK) == 0))\n\t\treturn;\n\n\tval = intel_de_read(dev_priv, DPLL_CTRL1);\n\n\tif (drm_WARN_ON(&dev_priv->drm,\n\t\t\t(val & (DPLL_CTRL1_HDMI_MODE(SKL_DPLL0) |\n\t\t\t\tDPLL_CTRL1_SSC(SKL_DPLL0) |\n\t\t\t\tDPLL_CTRL1_OVERRIDE(SKL_DPLL0))) !=\n\t\t\tDPLL_CTRL1_OVERRIDE(SKL_DPLL0)))\n\t\treturn;\n\n\tswitch (val & DPLL_CTRL1_LINK_RATE_MASK(SKL_DPLL0)) {\n\tcase DPLL_CTRL1_LINK_RATE(DPLL_CTRL1_LINK_RATE_810, SKL_DPLL0):\n\tcase DPLL_CTRL1_LINK_RATE(DPLL_CTRL1_LINK_RATE_1350, SKL_DPLL0):\n\tcase DPLL_CTRL1_LINK_RATE(DPLL_CTRL1_LINK_RATE_1620, SKL_DPLL0):\n\tcase DPLL_CTRL1_LINK_RATE(DPLL_CTRL1_LINK_RATE_2700, SKL_DPLL0):\n\t\tcdclk_config->vco = 8100000;\n\t\tbreak;\n\tcase DPLL_CTRL1_LINK_RATE(DPLL_CTRL1_LINK_RATE_1080, SKL_DPLL0):\n\tcase DPLL_CTRL1_LINK_RATE(DPLL_CTRL1_LINK_RATE_2160, SKL_DPLL0):\n\t\tcdclk_config->vco = 8640000;\n\t\tbreak;\n\tdefault:\n\t\tMISSING_CASE(val & DPLL_CTRL1_LINK_RATE_MASK(SKL_DPLL0));\n\t\tbreak;\n\t}\n}\n\nstatic void skl_get_cdclk(struct drm_i915_private *dev_priv,\n\t\t\t  struct intel_cdclk_config *cdclk_config)\n{\n\tu32 cdctl;\n\n\tskl_dpll0_update(dev_priv, cdclk_config);\n\n\tcdclk_config->cdclk = cdclk_config->bypass = cdclk_config->ref;\n\n\tif (cdclk_config->vco == 0)\n\t\tgoto out;\n\n\tcdctl = intel_de_read(dev_priv, CDCLK_CTL);\n\n\tif (cdclk_config->vco == 8640000) {\n\t\tswitch (cdctl & CDCLK_FREQ_SEL_MASK) {\n\t\tcase CDCLK_FREQ_450_432:\n\t\t\tcdclk_config->cdclk = 432000;\n\t\t\tbreak;\n\t\tcase CDCLK_FREQ_337_308:\n\t\t\tcdclk_config->cdclk = 308571;\n\t\t\tbreak;\n\t\tcase CDCLK_FREQ_540:\n\t\t\tcdclk_config->cdclk = 540000;\n\t\t\tbreak;\n\t\tcase CDCLK_FREQ_675_617:\n\t\t\tcdclk_config->cdclk = 617143;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tMISSING_CASE(cdctl & CDCLK_FREQ_SEL_MASK);\n\t\t\tbreak;\n\t\t}\n\t} else {\n\t\tswitch (cdctl & CDCLK_FREQ_SEL_MASK) {\n\t\tcase CDCLK_FREQ_450_432:\n\t\t\tcdclk_config->cdclk = 450000;\n\t\t\tbreak;\n\t\tcase CDCLK_FREQ_337_308:\n\t\t\tcdclk_config->cdclk = 337500;\n\t\t\tbreak;\n\t\tcase CDCLK_FREQ_540:\n\t\t\tcdclk_config->cdclk = 540000;\n\t\t\tbreak;\n\t\tcase CDCLK_FREQ_675_617:\n\t\t\tcdclk_config->cdclk = 675000;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tMISSING_CASE(cdctl & CDCLK_FREQ_SEL_MASK);\n\t\t\tbreak;\n\t\t}\n\t}\n\n out:\n\t \n\tcdclk_config->voltage_level =\n\t\tskl_calc_voltage_level(cdclk_config->cdclk);\n}\n\n \nstatic int skl_cdclk_decimal(int cdclk)\n{\n\treturn DIV_ROUND_CLOSEST(cdclk - 1000, 500);\n}\n\nstatic void skl_set_preferred_cdclk_vco(struct drm_i915_private *dev_priv,\n\t\t\t\t\tint vco)\n{\n\tbool changed = dev_priv->skl_preferred_vco_freq != vco;\n\n\tdev_priv->skl_preferred_vco_freq = vco;\n\n\tif (changed)\n\t\tintel_update_max_cdclk(dev_priv);\n}\n\nstatic u32 skl_dpll0_link_rate(struct drm_i915_private *dev_priv, int vco)\n{\n\tdrm_WARN_ON(&dev_priv->drm, vco != 8100000 && vco != 8640000);\n\n\t \n\tif (vco == 8640000)\n\t\treturn DPLL_CTRL1_LINK_RATE(DPLL_CTRL1_LINK_RATE_1080, SKL_DPLL0);\n\telse\n\t\treturn DPLL_CTRL1_LINK_RATE(DPLL_CTRL1_LINK_RATE_810, SKL_DPLL0);\n}\n\nstatic void skl_dpll0_enable(struct drm_i915_private *dev_priv, int vco)\n{\n\tintel_de_rmw(dev_priv, DPLL_CTRL1,\n\t\t     DPLL_CTRL1_HDMI_MODE(SKL_DPLL0) |\n\t\t     DPLL_CTRL1_SSC(SKL_DPLL0) |\n\t\t     DPLL_CTRL1_LINK_RATE_MASK(SKL_DPLL0),\n\t\t     DPLL_CTRL1_OVERRIDE(SKL_DPLL0) |\n\t\t     skl_dpll0_link_rate(dev_priv, vco));\n\tintel_de_posting_read(dev_priv, DPLL_CTRL1);\n\n\tintel_de_rmw(dev_priv, LCPLL1_CTL,\n\t\t     0, LCPLL_PLL_ENABLE);\n\n\tif (intel_de_wait_for_set(dev_priv, LCPLL1_CTL, LCPLL_PLL_LOCK, 5))\n\t\tdrm_err(&dev_priv->drm, \"DPLL0 not locked\\n\");\n\n\tdev_priv->display.cdclk.hw.vco = vco;\n\n\t \n\tskl_set_preferred_cdclk_vco(dev_priv, vco);\n}\n\nstatic void skl_dpll0_disable(struct drm_i915_private *dev_priv)\n{\n\tintel_de_rmw(dev_priv, LCPLL1_CTL,\n\t\t     LCPLL_PLL_ENABLE, 0);\n\n\tif (intel_de_wait_for_clear(dev_priv, LCPLL1_CTL, LCPLL_PLL_LOCK, 1))\n\t\tdrm_err(&dev_priv->drm, \"Couldn't disable DPLL0\\n\");\n\n\tdev_priv->display.cdclk.hw.vco = 0;\n}\n\nstatic u32 skl_cdclk_freq_sel(struct drm_i915_private *dev_priv,\n\t\t\t      int cdclk, int vco)\n{\n\tswitch (cdclk) {\n\tdefault:\n\t\tdrm_WARN_ON(&dev_priv->drm,\n\t\t\t    cdclk != dev_priv->display.cdclk.hw.bypass);\n\t\tdrm_WARN_ON(&dev_priv->drm, vco != 0);\n\t\tfallthrough;\n\tcase 308571:\n\tcase 337500:\n\t\treturn CDCLK_FREQ_337_308;\n\tcase 450000:\n\tcase 432000:\n\t\treturn CDCLK_FREQ_450_432;\n\tcase 540000:\n\t\treturn CDCLK_FREQ_540;\n\tcase 617143:\n\tcase 675000:\n\t\treturn CDCLK_FREQ_675_617;\n\t}\n}\n\nstatic void skl_set_cdclk(struct drm_i915_private *dev_priv,\n\t\t\t  const struct intel_cdclk_config *cdclk_config,\n\t\t\t  enum pipe pipe)\n{\n\tint cdclk = cdclk_config->cdclk;\n\tint vco = cdclk_config->vco;\n\tu32 freq_select, cdclk_ctl;\n\tint ret;\n\n\t \n\tdrm_WARN_ON_ONCE(&dev_priv->drm,\n\t\t\t IS_SKYLAKE(dev_priv) && vco == 8640000);\n\n\tret = skl_pcode_request(&dev_priv->uncore, SKL_PCODE_CDCLK_CONTROL,\n\t\t\t\tSKL_CDCLK_PREPARE_FOR_CHANGE,\n\t\t\t\tSKL_CDCLK_READY_FOR_CHANGE,\n\t\t\t\tSKL_CDCLK_READY_FOR_CHANGE, 3);\n\tif (ret) {\n\t\tdrm_err(&dev_priv->drm,\n\t\t\t\"Failed to inform PCU about cdclk change (%d)\\n\", ret);\n\t\treturn;\n\t}\n\n\tfreq_select = skl_cdclk_freq_sel(dev_priv, cdclk, vco);\n\n\tif (dev_priv->display.cdclk.hw.vco != 0 &&\n\t    dev_priv->display.cdclk.hw.vco != vco)\n\t\tskl_dpll0_disable(dev_priv);\n\n\tcdclk_ctl = intel_de_read(dev_priv, CDCLK_CTL);\n\n\tif (dev_priv->display.cdclk.hw.vco != vco) {\n\t\t \n\t\tcdclk_ctl &= ~(CDCLK_FREQ_SEL_MASK | CDCLK_FREQ_DECIMAL_MASK);\n\t\tcdclk_ctl |= freq_select | skl_cdclk_decimal(cdclk);\n\t\tintel_de_write(dev_priv, CDCLK_CTL, cdclk_ctl);\n\t}\n\n\t \n\tcdclk_ctl |= CDCLK_DIVMUX_CD_OVERRIDE;\n\tintel_de_write(dev_priv, CDCLK_CTL, cdclk_ctl);\n\tintel_de_posting_read(dev_priv, CDCLK_CTL);\n\n\tif (dev_priv->display.cdclk.hw.vco != vco)\n\t\tskl_dpll0_enable(dev_priv, vco);\n\n\t \n\tcdclk_ctl &= ~(CDCLK_FREQ_SEL_MASK | CDCLK_FREQ_DECIMAL_MASK);\n\tintel_de_write(dev_priv, CDCLK_CTL, cdclk_ctl);\n\n\tcdclk_ctl |= freq_select | skl_cdclk_decimal(cdclk);\n\tintel_de_write(dev_priv, CDCLK_CTL, cdclk_ctl);\n\n\t \n\tcdclk_ctl &= ~CDCLK_DIVMUX_CD_OVERRIDE;\n\tintel_de_write(dev_priv, CDCLK_CTL, cdclk_ctl);\n\tintel_de_posting_read(dev_priv, CDCLK_CTL);\n\n\t \n\tsnb_pcode_write(&dev_priv->uncore, SKL_PCODE_CDCLK_CONTROL,\n\t\t\tcdclk_config->voltage_level);\n\n\tintel_update_cdclk(dev_priv);\n}\n\nstatic void skl_sanitize_cdclk(struct drm_i915_private *dev_priv)\n{\n\tu32 cdctl, expected;\n\n\t \n\tif ((intel_de_read(dev_priv, SWF_ILK(0x18)) & 0x00FFFFFF) == 0)\n\t\tgoto sanitize;\n\n\tintel_update_cdclk(dev_priv);\n\tintel_cdclk_dump_config(dev_priv, &dev_priv->display.cdclk.hw, \"Current CDCLK\");\n\n\t \n\tif (dev_priv->display.cdclk.hw.vco == 0 ||\n\t    dev_priv->display.cdclk.hw.cdclk == dev_priv->display.cdclk.hw.bypass)\n\t\tgoto sanitize;\n\n\t \n\tcdctl = intel_de_read(dev_priv, CDCLK_CTL);\n\texpected = (cdctl & CDCLK_FREQ_SEL_MASK) |\n\t\tskl_cdclk_decimal(dev_priv->display.cdclk.hw.cdclk);\n\tif (cdctl == expected)\n\t\t \n\t\treturn;\n\nsanitize:\n\tdrm_dbg_kms(&dev_priv->drm, \"Sanitizing cdclk programmed by pre-os\\n\");\n\n\t \n\tdev_priv->display.cdclk.hw.cdclk = 0;\n\t \n\tdev_priv->display.cdclk.hw.vco = -1;\n}\n\nstatic void skl_cdclk_init_hw(struct drm_i915_private *dev_priv)\n{\n\tstruct intel_cdclk_config cdclk_config;\n\n\tskl_sanitize_cdclk(dev_priv);\n\n\tif (dev_priv->display.cdclk.hw.cdclk != 0 &&\n\t    dev_priv->display.cdclk.hw.vco != 0) {\n\t\t \n\t\tif (dev_priv->skl_preferred_vco_freq == 0)\n\t\t\tskl_set_preferred_cdclk_vco(dev_priv,\n\t\t\t\t\t\t    dev_priv->display.cdclk.hw.vco);\n\t\treturn;\n\t}\n\n\tcdclk_config = dev_priv->display.cdclk.hw;\n\n\tcdclk_config.vco = dev_priv->skl_preferred_vco_freq;\n\tif (cdclk_config.vco == 0)\n\t\tcdclk_config.vco = 8100000;\n\tcdclk_config.cdclk = skl_calc_cdclk(0, cdclk_config.vco);\n\tcdclk_config.voltage_level = skl_calc_voltage_level(cdclk_config.cdclk);\n\n\tskl_set_cdclk(dev_priv, &cdclk_config, INVALID_PIPE);\n}\n\nstatic void skl_cdclk_uninit_hw(struct drm_i915_private *dev_priv)\n{\n\tstruct intel_cdclk_config cdclk_config = dev_priv->display.cdclk.hw;\n\n\tcdclk_config.cdclk = cdclk_config.bypass;\n\tcdclk_config.vco = 0;\n\tcdclk_config.voltage_level = skl_calc_voltage_level(cdclk_config.cdclk);\n\n\tskl_set_cdclk(dev_priv, &cdclk_config, INVALID_PIPE);\n}\n\nstruct intel_cdclk_vals {\n\tu32 cdclk;\n\tu16 refclk;\n\tu16 waveform;\n\tu8 divider;\t \n\tu8 ratio;\n};\n\nstatic const struct intel_cdclk_vals bxt_cdclk_table[] = {\n\t{ .refclk = 19200, .cdclk = 144000, .divider = 8, .ratio = 60 },\n\t{ .refclk = 19200, .cdclk = 288000, .divider = 4, .ratio = 60 },\n\t{ .refclk = 19200, .cdclk = 384000, .divider = 3, .ratio = 60 },\n\t{ .refclk = 19200, .cdclk = 576000, .divider = 2, .ratio = 60 },\n\t{ .refclk = 19200, .cdclk = 624000, .divider = 2, .ratio = 65 },\n\t{}\n};\n\nstatic const struct intel_cdclk_vals glk_cdclk_table[] = {\n\t{ .refclk = 19200, .cdclk =  79200, .divider = 8, .ratio = 33 },\n\t{ .refclk = 19200, .cdclk = 158400, .divider = 4, .ratio = 33 },\n\t{ .refclk = 19200, .cdclk = 316800, .divider = 2, .ratio = 33 },\n\t{}\n};\n\nstatic const struct intel_cdclk_vals icl_cdclk_table[] = {\n\t{ .refclk = 19200, .cdclk = 172800, .divider = 2, .ratio = 18 },\n\t{ .refclk = 19200, .cdclk = 192000, .divider = 2, .ratio = 20 },\n\t{ .refclk = 19200, .cdclk = 307200, .divider = 2, .ratio = 32 },\n\t{ .refclk = 19200, .cdclk = 326400, .divider = 4, .ratio = 68 },\n\t{ .refclk = 19200, .cdclk = 556800, .divider = 2, .ratio = 58 },\n\t{ .refclk = 19200, .cdclk = 652800, .divider = 2, .ratio = 68 },\n\n\t{ .refclk = 24000, .cdclk = 180000, .divider = 2, .ratio = 15 },\n\t{ .refclk = 24000, .cdclk = 192000, .divider = 2, .ratio = 16 },\n\t{ .refclk = 24000, .cdclk = 312000, .divider = 2, .ratio = 26 },\n\t{ .refclk = 24000, .cdclk = 324000, .divider = 4, .ratio = 54 },\n\t{ .refclk = 24000, .cdclk = 552000, .divider = 2, .ratio = 46 },\n\t{ .refclk = 24000, .cdclk = 648000, .divider = 2, .ratio = 54 },\n\n\t{ .refclk = 38400, .cdclk = 172800, .divider = 2, .ratio =  9 },\n\t{ .refclk = 38400, .cdclk = 192000, .divider = 2, .ratio = 10 },\n\t{ .refclk = 38400, .cdclk = 307200, .divider = 2, .ratio = 16 },\n\t{ .refclk = 38400, .cdclk = 326400, .divider = 4, .ratio = 34 },\n\t{ .refclk = 38400, .cdclk = 556800, .divider = 2, .ratio = 29 },\n\t{ .refclk = 38400, .cdclk = 652800, .divider = 2, .ratio = 34 },\n\t{}\n};\n\nstatic const struct intel_cdclk_vals rkl_cdclk_table[] = {\n\t{ .refclk = 19200, .cdclk = 172800, .divider = 4, .ratio =  36 },\n\t{ .refclk = 19200, .cdclk = 192000, .divider = 4, .ratio =  40 },\n\t{ .refclk = 19200, .cdclk = 307200, .divider = 4, .ratio =  64 },\n\t{ .refclk = 19200, .cdclk = 326400, .divider = 8, .ratio = 136 },\n\t{ .refclk = 19200, .cdclk = 556800, .divider = 4, .ratio = 116 },\n\t{ .refclk = 19200, .cdclk = 652800, .divider = 4, .ratio = 136 },\n\n\t{ .refclk = 24000, .cdclk = 180000, .divider = 4, .ratio =  30 },\n\t{ .refclk = 24000, .cdclk = 192000, .divider = 4, .ratio =  32 },\n\t{ .refclk = 24000, .cdclk = 312000, .divider = 4, .ratio =  52 },\n\t{ .refclk = 24000, .cdclk = 324000, .divider = 8, .ratio = 108 },\n\t{ .refclk = 24000, .cdclk = 552000, .divider = 4, .ratio =  92 },\n\t{ .refclk = 24000, .cdclk = 648000, .divider = 4, .ratio = 108 },\n\n\t{ .refclk = 38400, .cdclk = 172800, .divider = 4, .ratio = 18 },\n\t{ .refclk = 38400, .cdclk = 192000, .divider = 4, .ratio = 20 },\n\t{ .refclk = 38400, .cdclk = 307200, .divider = 4, .ratio = 32 },\n\t{ .refclk = 38400, .cdclk = 326400, .divider = 8, .ratio = 68 },\n\t{ .refclk = 38400, .cdclk = 556800, .divider = 4, .ratio = 58 },\n\t{ .refclk = 38400, .cdclk = 652800, .divider = 4, .ratio = 68 },\n\t{}\n};\n\nstatic const struct intel_cdclk_vals adlp_a_step_cdclk_table[] = {\n\t{ .refclk = 19200, .cdclk = 307200, .divider = 2, .ratio = 32 },\n\t{ .refclk = 19200, .cdclk = 556800, .divider = 2, .ratio = 58 },\n\t{ .refclk = 19200, .cdclk = 652800, .divider = 2, .ratio = 68 },\n\n\t{ .refclk = 24000, .cdclk = 312000, .divider = 2, .ratio = 26 },\n\t{ .refclk = 24000, .cdclk = 552000, .divider = 2, .ratio = 46 },\n\t{ .refclk = 24400, .cdclk = 648000, .divider = 2, .ratio = 54 },\n\n\t{ .refclk = 38400, .cdclk = 307200, .divider = 2, .ratio = 16 },\n\t{ .refclk = 38400, .cdclk = 556800, .divider = 2, .ratio = 29 },\n\t{ .refclk = 38400, .cdclk = 652800, .divider = 2, .ratio = 34 },\n\t{}\n};\n\nstatic const struct intel_cdclk_vals adlp_cdclk_table[] = {\n\t{ .refclk = 19200, .cdclk = 172800, .divider = 3, .ratio = 27 },\n\t{ .refclk = 19200, .cdclk = 192000, .divider = 2, .ratio = 20 },\n\t{ .refclk = 19200, .cdclk = 307200, .divider = 2, .ratio = 32 },\n\t{ .refclk = 19200, .cdclk = 556800, .divider = 2, .ratio = 58 },\n\t{ .refclk = 19200, .cdclk = 652800, .divider = 2, .ratio = 68 },\n\n\t{ .refclk = 24000, .cdclk = 176000, .divider = 3, .ratio = 22 },\n\t{ .refclk = 24000, .cdclk = 192000, .divider = 2, .ratio = 16 },\n\t{ .refclk = 24000, .cdclk = 312000, .divider = 2, .ratio = 26 },\n\t{ .refclk = 24000, .cdclk = 552000, .divider = 2, .ratio = 46 },\n\t{ .refclk = 24000, .cdclk = 648000, .divider = 2, .ratio = 54 },\n\n\t{ .refclk = 38400, .cdclk = 179200, .divider = 3, .ratio = 14 },\n\t{ .refclk = 38400, .cdclk = 192000, .divider = 2, .ratio = 10 },\n\t{ .refclk = 38400, .cdclk = 307200, .divider = 2, .ratio = 16 },\n\t{ .refclk = 38400, .cdclk = 556800, .divider = 2, .ratio = 29 },\n\t{ .refclk = 38400, .cdclk = 652800, .divider = 2, .ratio = 34 },\n\t{}\n};\n\nstatic const struct intel_cdclk_vals rplu_cdclk_table[] = {\n\t{ .refclk = 19200, .cdclk = 172800, .divider = 3, .ratio = 27 },\n\t{ .refclk = 19200, .cdclk = 192000, .divider = 2, .ratio = 20 },\n\t{ .refclk = 19200, .cdclk = 307200, .divider = 2, .ratio = 32 },\n\t{ .refclk = 19200, .cdclk = 480000, .divider = 2, .ratio = 50 },\n\t{ .refclk = 19200, .cdclk = 556800, .divider = 2, .ratio = 58 },\n\t{ .refclk = 19200, .cdclk = 652800, .divider = 2, .ratio = 68 },\n\n\t{ .refclk = 24000, .cdclk = 176000, .divider = 3, .ratio = 22 },\n\t{ .refclk = 24000, .cdclk = 192000, .divider = 2, .ratio = 16 },\n\t{ .refclk = 24000, .cdclk = 312000, .divider = 2, .ratio = 26 },\n\t{ .refclk = 24000, .cdclk = 480000, .divider = 2, .ratio = 40 },\n\t{ .refclk = 24000, .cdclk = 552000, .divider = 2, .ratio = 46 },\n\t{ .refclk = 24000, .cdclk = 648000, .divider = 2, .ratio = 54 },\n\n\t{ .refclk = 38400, .cdclk = 179200, .divider = 3, .ratio = 14 },\n\t{ .refclk = 38400, .cdclk = 192000, .divider = 2, .ratio = 10 },\n\t{ .refclk = 38400, .cdclk = 307200, .divider = 2, .ratio = 16 },\n\t{ .refclk = 38400, .cdclk = 480000, .divider = 2, .ratio = 25 },\n\t{ .refclk = 38400, .cdclk = 556800, .divider = 2, .ratio = 29 },\n\t{ .refclk = 38400, .cdclk = 652800, .divider = 2, .ratio = 34 },\n\t{}\n};\n\nstatic const struct intel_cdclk_vals dg2_cdclk_table[] = {\n\t{ .refclk = 38400, .cdclk = 163200, .divider = 2, .ratio = 34, .waveform = 0x8888 },\n\t{ .refclk = 38400, .cdclk = 204000, .divider = 2, .ratio = 34, .waveform = 0x9248 },\n\t{ .refclk = 38400, .cdclk = 244800, .divider = 2, .ratio = 34, .waveform = 0xa4a4 },\n\t{ .refclk = 38400, .cdclk = 285600, .divider = 2, .ratio = 34, .waveform = 0xa54a },\n\t{ .refclk = 38400, .cdclk = 326400, .divider = 2, .ratio = 34, .waveform = 0xaaaa },\n\t{ .refclk = 38400, .cdclk = 367200, .divider = 2, .ratio = 34, .waveform = 0xad5a },\n\t{ .refclk = 38400, .cdclk = 408000, .divider = 2, .ratio = 34, .waveform = 0xb6b6 },\n\t{ .refclk = 38400, .cdclk = 448800, .divider = 2, .ratio = 34, .waveform = 0xdbb6 },\n\t{ .refclk = 38400, .cdclk = 489600, .divider = 2, .ratio = 34, .waveform = 0xeeee },\n\t{ .refclk = 38400, .cdclk = 530400, .divider = 2, .ratio = 34, .waveform = 0xf7de },\n\t{ .refclk = 38400, .cdclk = 571200, .divider = 2, .ratio = 34, .waveform = 0xfefe },\n\t{ .refclk = 38400, .cdclk = 612000, .divider = 2, .ratio = 34, .waveform = 0xfffe },\n\t{ .refclk = 38400, .cdclk = 652800, .divider = 2, .ratio = 34, .waveform = 0xffff },\n\t{}\n};\n\nstatic const struct intel_cdclk_vals mtl_cdclk_table[] = {\n\t{ .refclk = 38400, .cdclk = 172800, .divider = 2, .ratio = 16, .waveform = 0xad5a },\n\t{ .refclk = 38400, .cdclk = 192000, .divider = 2, .ratio = 16, .waveform = 0xb6b6 },\n\t{ .refclk = 38400, .cdclk = 307200, .divider = 2, .ratio = 16, .waveform = 0x0000 },\n\t{ .refclk = 38400, .cdclk = 480000, .divider = 2, .ratio = 25, .waveform = 0x0000 },\n\t{ .refclk = 38400, .cdclk = 556800, .divider = 2, .ratio = 29, .waveform = 0x0000 },\n\t{ .refclk = 38400, .cdclk = 652800, .divider = 2, .ratio = 34, .waveform = 0x0000 },\n\t{}\n};\n\nstatic int bxt_calc_cdclk(struct drm_i915_private *dev_priv, int min_cdclk)\n{\n\tconst struct intel_cdclk_vals *table = dev_priv->display.cdclk.table;\n\tint i;\n\n\tfor (i = 0; table[i].refclk; i++)\n\t\tif (table[i].refclk == dev_priv->display.cdclk.hw.ref &&\n\t\t    table[i].cdclk >= min_cdclk)\n\t\t\treturn table[i].cdclk;\n\n\tdrm_WARN(&dev_priv->drm, 1,\n\t\t \"Cannot satisfy minimum cdclk %d with refclk %u\\n\",\n\t\t min_cdclk, dev_priv->display.cdclk.hw.ref);\n\treturn 0;\n}\n\nstatic int bxt_calc_cdclk_pll_vco(struct drm_i915_private *dev_priv, int cdclk)\n{\n\tconst struct intel_cdclk_vals *table = dev_priv->display.cdclk.table;\n\tint i;\n\n\tif (cdclk == dev_priv->display.cdclk.hw.bypass)\n\t\treturn 0;\n\n\tfor (i = 0; table[i].refclk; i++)\n\t\tif (table[i].refclk == dev_priv->display.cdclk.hw.ref &&\n\t\t    table[i].cdclk == cdclk)\n\t\t\treturn dev_priv->display.cdclk.hw.ref * table[i].ratio;\n\n\tdrm_WARN(&dev_priv->drm, 1, \"cdclk %d not valid for refclk %u\\n\",\n\t\t cdclk, dev_priv->display.cdclk.hw.ref);\n\treturn 0;\n}\n\nstatic u8 bxt_calc_voltage_level(int cdclk)\n{\n\treturn DIV_ROUND_UP(cdclk, 25000);\n}\n\nstatic u8 icl_calc_voltage_level(int cdclk)\n{\n\tif (cdclk > 556800)\n\t\treturn 2;\n\telse if (cdclk > 312000)\n\t\treturn 1;\n\telse\n\t\treturn 0;\n}\n\nstatic u8 ehl_calc_voltage_level(int cdclk)\n{\n\tif (cdclk > 326400)\n\t\treturn 3;\n\telse if (cdclk > 312000)\n\t\treturn 2;\n\telse if (cdclk > 180000)\n\t\treturn 1;\n\telse\n\t\treturn 0;\n}\n\nstatic u8 tgl_calc_voltage_level(int cdclk)\n{\n\tif (cdclk > 556800)\n\t\treturn 3;\n\telse if (cdclk > 326400)\n\t\treturn 2;\n\telse if (cdclk > 312000)\n\t\treturn 1;\n\telse\n\t\treturn 0;\n}\n\nstatic u8 rplu_calc_voltage_level(int cdclk)\n{\n\tif (cdclk > 556800)\n\t\treturn 3;\n\telse if (cdclk > 480000)\n\t\treturn 2;\n\telse if (cdclk > 312000)\n\t\treturn 1;\n\telse\n\t\treturn 0;\n}\n\nstatic void icl_readout_refclk(struct drm_i915_private *dev_priv,\n\t\t\t       struct intel_cdclk_config *cdclk_config)\n{\n\tu32 dssm = intel_de_read(dev_priv, SKL_DSSM) & ICL_DSSM_CDCLK_PLL_REFCLK_MASK;\n\n\tswitch (dssm) {\n\tdefault:\n\t\tMISSING_CASE(dssm);\n\t\tfallthrough;\n\tcase ICL_DSSM_CDCLK_PLL_REFCLK_24MHz:\n\t\tcdclk_config->ref = 24000;\n\t\tbreak;\n\tcase ICL_DSSM_CDCLK_PLL_REFCLK_19_2MHz:\n\t\tcdclk_config->ref = 19200;\n\t\tbreak;\n\tcase ICL_DSSM_CDCLK_PLL_REFCLK_38_4MHz:\n\t\tcdclk_config->ref = 38400;\n\t\tbreak;\n\t}\n}\n\nstatic void bxt_de_pll_readout(struct drm_i915_private *dev_priv,\n\t\t\t       struct intel_cdclk_config *cdclk_config)\n{\n\tu32 val, ratio;\n\n\tif (IS_DG2(dev_priv))\n\t\tcdclk_config->ref = 38400;\n\telse if (DISPLAY_VER(dev_priv) >= 11)\n\t\ticl_readout_refclk(dev_priv, cdclk_config);\n\telse\n\t\tcdclk_config->ref = 19200;\n\n\tval = intel_de_read(dev_priv, BXT_DE_PLL_ENABLE);\n\tif ((val & BXT_DE_PLL_PLL_ENABLE) == 0 ||\n\t    (val & BXT_DE_PLL_LOCK) == 0) {\n\t\t \n\t\tcdclk_config->vco = 0;\n\t\treturn;\n\t}\n\n\t \n\tif (DISPLAY_VER(dev_priv) >= 11)\n\t\tratio = val & ICL_CDCLK_PLL_RATIO_MASK;\n\telse\n\t\tratio = intel_de_read(dev_priv, BXT_DE_PLL_CTL) & BXT_DE_PLL_RATIO_MASK;\n\n\tcdclk_config->vco = ratio * cdclk_config->ref;\n}\n\nstatic void bxt_get_cdclk(struct drm_i915_private *dev_priv,\n\t\t\t  struct intel_cdclk_config *cdclk_config)\n{\n\tu32 squash_ctl = 0;\n\tu32 divider;\n\tint div;\n\n\tbxt_de_pll_readout(dev_priv, cdclk_config);\n\n\tif (DISPLAY_VER(dev_priv) >= 12)\n\t\tcdclk_config->bypass = cdclk_config->ref / 2;\n\telse if (DISPLAY_VER(dev_priv) >= 11)\n\t\tcdclk_config->bypass = 50000;\n\telse\n\t\tcdclk_config->bypass = cdclk_config->ref;\n\n\tif (cdclk_config->vco == 0) {\n\t\tcdclk_config->cdclk = cdclk_config->bypass;\n\t\tgoto out;\n\t}\n\n\tdivider = intel_de_read(dev_priv, CDCLK_CTL) & BXT_CDCLK_CD2X_DIV_SEL_MASK;\n\n\tswitch (divider) {\n\tcase BXT_CDCLK_CD2X_DIV_SEL_1:\n\t\tdiv = 2;\n\t\tbreak;\n\tcase BXT_CDCLK_CD2X_DIV_SEL_1_5:\n\t\tdiv = 3;\n\t\tbreak;\n\tcase BXT_CDCLK_CD2X_DIV_SEL_2:\n\t\tdiv = 4;\n\t\tbreak;\n\tcase BXT_CDCLK_CD2X_DIV_SEL_4:\n\t\tdiv = 8;\n\t\tbreak;\n\tdefault:\n\t\tMISSING_CASE(divider);\n\t\treturn;\n\t}\n\n\tif (HAS_CDCLK_SQUASH(dev_priv))\n\t\tsquash_ctl = intel_de_read(dev_priv, CDCLK_SQUASH_CTL);\n\n\tif (squash_ctl & CDCLK_SQUASH_ENABLE) {\n\t\tu16 waveform;\n\t\tint size;\n\n\t\tsize = REG_FIELD_GET(CDCLK_SQUASH_WINDOW_SIZE_MASK, squash_ctl) + 1;\n\t\twaveform = REG_FIELD_GET(CDCLK_SQUASH_WAVEFORM_MASK, squash_ctl) >> (16 - size);\n\n\t\tcdclk_config->cdclk = DIV_ROUND_CLOSEST(hweight16(waveform) *\n\t\t\t\t\t\t\tcdclk_config->vco, size * div);\n\t} else {\n\t\tcdclk_config->cdclk = DIV_ROUND_CLOSEST(cdclk_config->vco, div);\n\t}\n\n out:\n\t \n\tcdclk_config->voltage_level =\n\t\tintel_cdclk_calc_voltage_level(dev_priv, cdclk_config->cdclk);\n}\n\nstatic void bxt_de_pll_disable(struct drm_i915_private *dev_priv)\n{\n\tintel_de_write(dev_priv, BXT_DE_PLL_ENABLE, 0);\n\n\t \n\tif (intel_de_wait_for_clear(dev_priv,\n\t\t\t\t    BXT_DE_PLL_ENABLE, BXT_DE_PLL_LOCK, 1))\n\t\tdrm_err(&dev_priv->drm, \"timeout waiting for DE PLL unlock\\n\");\n\n\tdev_priv->display.cdclk.hw.vco = 0;\n}\n\nstatic void bxt_de_pll_enable(struct drm_i915_private *dev_priv, int vco)\n{\n\tint ratio = DIV_ROUND_CLOSEST(vco, dev_priv->display.cdclk.hw.ref);\n\n\tintel_de_rmw(dev_priv, BXT_DE_PLL_CTL,\n\t\t     BXT_DE_PLL_RATIO_MASK, BXT_DE_PLL_RATIO(ratio));\n\n\tintel_de_write(dev_priv, BXT_DE_PLL_ENABLE, BXT_DE_PLL_PLL_ENABLE);\n\n\t \n\tif (intel_de_wait_for_set(dev_priv,\n\t\t\t\t  BXT_DE_PLL_ENABLE, BXT_DE_PLL_LOCK, 1))\n\t\tdrm_err(&dev_priv->drm, \"timeout waiting for DE PLL lock\\n\");\n\n\tdev_priv->display.cdclk.hw.vco = vco;\n}\n\nstatic void icl_cdclk_pll_disable(struct drm_i915_private *dev_priv)\n{\n\tintel_de_rmw(dev_priv, BXT_DE_PLL_ENABLE,\n\t\t     BXT_DE_PLL_PLL_ENABLE, 0);\n\n\t \n\tif (intel_de_wait_for_clear(dev_priv, BXT_DE_PLL_ENABLE, BXT_DE_PLL_LOCK, 1))\n\t\tdrm_err(&dev_priv->drm, \"timeout waiting for CDCLK PLL unlock\\n\");\n\n\tdev_priv->display.cdclk.hw.vco = 0;\n}\n\nstatic void icl_cdclk_pll_enable(struct drm_i915_private *dev_priv, int vco)\n{\n\tint ratio = DIV_ROUND_CLOSEST(vco, dev_priv->display.cdclk.hw.ref);\n\tu32 val;\n\n\tval = ICL_CDCLK_PLL_RATIO(ratio);\n\tintel_de_write(dev_priv, BXT_DE_PLL_ENABLE, val);\n\n\tval |= BXT_DE_PLL_PLL_ENABLE;\n\tintel_de_write(dev_priv, BXT_DE_PLL_ENABLE, val);\n\n\t \n\tif (intel_de_wait_for_set(dev_priv, BXT_DE_PLL_ENABLE, BXT_DE_PLL_LOCK, 1))\n\t\tdrm_err(&dev_priv->drm, \"timeout waiting for CDCLK PLL lock\\n\");\n\n\tdev_priv->display.cdclk.hw.vco = vco;\n}\n\nstatic void adlp_cdclk_pll_crawl(struct drm_i915_private *dev_priv, int vco)\n{\n\tint ratio = DIV_ROUND_CLOSEST(vco, dev_priv->display.cdclk.hw.ref);\n\tu32 val;\n\n\t \n\tval = ICL_CDCLK_PLL_RATIO(ratio) | BXT_DE_PLL_PLL_ENABLE;\n\tintel_de_write(dev_priv, BXT_DE_PLL_ENABLE, val);\n\n\t \n\tval |= BXT_DE_PLL_FREQ_REQ;\n\tintel_de_write(dev_priv, BXT_DE_PLL_ENABLE, val);\n\n\t \n\tif (intel_de_wait_for_set(dev_priv, BXT_DE_PLL_ENABLE,\n\t\t\t\t  BXT_DE_PLL_LOCK | BXT_DE_PLL_FREQ_REQ_ACK, 1))\n\t\tdrm_err(&dev_priv->drm, \"timeout waiting for FREQ change request ack\\n\");\n\n\tval &= ~BXT_DE_PLL_FREQ_REQ;\n\tintel_de_write(dev_priv, BXT_DE_PLL_ENABLE, val);\n\n\tdev_priv->display.cdclk.hw.vco = vco;\n}\n\nstatic u32 bxt_cdclk_cd2x_pipe(struct drm_i915_private *dev_priv, enum pipe pipe)\n{\n\tif (DISPLAY_VER(dev_priv) >= 12) {\n\t\tif (pipe == INVALID_PIPE)\n\t\t\treturn TGL_CDCLK_CD2X_PIPE_NONE;\n\t\telse\n\t\t\treturn TGL_CDCLK_CD2X_PIPE(pipe);\n\t} else if (DISPLAY_VER(dev_priv) >= 11) {\n\t\tif (pipe == INVALID_PIPE)\n\t\t\treturn ICL_CDCLK_CD2X_PIPE_NONE;\n\t\telse\n\t\t\treturn ICL_CDCLK_CD2X_PIPE(pipe);\n\t} else {\n\t\tif (pipe == INVALID_PIPE)\n\t\t\treturn BXT_CDCLK_CD2X_PIPE_NONE;\n\t\telse\n\t\t\treturn BXT_CDCLK_CD2X_PIPE(pipe);\n\t}\n}\n\nstatic u32 bxt_cdclk_cd2x_div_sel(struct drm_i915_private *dev_priv,\n\t\t\t\t  int cdclk, int vco)\n{\n\t \n\tswitch (DIV_ROUND_CLOSEST(vco, cdclk)) {\n\tdefault:\n\t\tdrm_WARN_ON(&dev_priv->drm,\n\t\t\t    cdclk != dev_priv->display.cdclk.hw.bypass);\n\t\tdrm_WARN_ON(&dev_priv->drm, vco != 0);\n\t\tfallthrough;\n\tcase 2:\n\t\treturn BXT_CDCLK_CD2X_DIV_SEL_1;\n\tcase 3:\n\t\treturn BXT_CDCLK_CD2X_DIV_SEL_1_5;\n\tcase 4:\n\t\treturn BXT_CDCLK_CD2X_DIV_SEL_2;\n\tcase 8:\n\t\treturn BXT_CDCLK_CD2X_DIV_SEL_4;\n\t}\n}\n\nstatic u32 cdclk_squash_waveform(struct drm_i915_private *dev_priv,\n\t\t\t\t int cdclk)\n{\n\tconst struct intel_cdclk_vals *table = dev_priv->display.cdclk.table;\n\tint i;\n\n\tif (cdclk == dev_priv->display.cdclk.hw.bypass)\n\t\treturn 0;\n\n\tfor (i = 0; table[i].refclk; i++)\n\t\tif (table[i].refclk == dev_priv->display.cdclk.hw.ref &&\n\t\t    table[i].cdclk == cdclk)\n\t\t\treturn table[i].waveform;\n\n\tdrm_WARN(&dev_priv->drm, 1, \"cdclk %d not valid for refclk %u\\n\",\n\t\t cdclk, dev_priv->display.cdclk.hw.ref);\n\n\treturn 0xffff;\n}\n\nstatic void icl_cdclk_pll_update(struct drm_i915_private *i915, int vco)\n{\n\tif (i915->display.cdclk.hw.vco != 0 &&\n\t    i915->display.cdclk.hw.vco != vco)\n\t\ticl_cdclk_pll_disable(i915);\n\n\tif (i915->display.cdclk.hw.vco != vco)\n\t\ticl_cdclk_pll_enable(i915, vco);\n}\n\nstatic void bxt_cdclk_pll_update(struct drm_i915_private *i915, int vco)\n{\n\tif (i915->display.cdclk.hw.vco != 0 &&\n\t    i915->display.cdclk.hw.vco != vco)\n\t\tbxt_de_pll_disable(i915);\n\n\tif (i915->display.cdclk.hw.vco != vco)\n\t\tbxt_de_pll_enable(i915, vco);\n}\n\nstatic void dg2_cdclk_squash_program(struct drm_i915_private *i915,\n\t\t\t\t     u16 waveform)\n{\n\tu32 squash_ctl = 0;\n\n\tif (waveform)\n\t\tsquash_ctl = CDCLK_SQUASH_ENABLE |\n\t\t\t     CDCLK_SQUASH_WINDOW_SIZE(0xf) | waveform;\n\n\tintel_de_write(i915, CDCLK_SQUASH_CTL, squash_ctl);\n}\n\nstatic bool cdclk_pll_is_unknown(unsigned int vco)\n{\n\t \n\treturn vco == ~0;\n}\n\nstatic int cdclk_squash_divider(u16 waveform)\n{\n\treturn hweight16(waveform ?: 0xffff);\n}\n\nstatic bool cdclk_compute_crawl_and_squash_midpoint(struct drm_i915_private *i915,\n\t\t\t\t\t\t    const struct intel_cdclk_config *old_cdclk_config,\n\t\t\t\t\t\t    const struct intel_cdclk_config *new_cdclk_config,\n\t\t\t\t\t\t    struct intel_cdclk_config *mid_cdclk_config)\n{\n\tu16 old_waveform, new_waveform, mid_waveform;\n\tint size = 16;\n\tint div = 2;\n\n\t \n\tif (cdclk_pll_is_unknown(old_cdclk_config->vco))\n\t\treturn false;\n\n\t \n\tif (!HAS_CDCLK_CRAWL(i915) || !HAS_CDCLK_SQUASH(i915))\n\t\treturn false;\n\n\told_waveform = cdclk_squash_waveform(i915, old_cdclk_config->cdclk);\n\tnew_waveform = cdclk_squash_waveform(i915, new_cdclk_config->cdclk);\n\n\t \n\tif (old_cdclk_config->vco == 0 || new_cdclk_config->vco == 0 ||\n\t    old_cdclk_config->vco == new_cdclk_config->vco ||\n\t    old_waveform == new_waveform)\n\t\treturn false;\n\n\t*mid_cdclk_config = *new_cdclk_config;\n\n\t \n\n\tif (cdclk_squash_divider(new_waveform) > cdclk_squash_divider(old_waveform)) {\n\t\tmid_cdclk_config->vco = old_cdclk_config->vco;\n\t\tmid_waveform = new_waveform;\n\t} else {\n\t\tmid_cdclk_config->vco = new_cdclk_config->vco;\n\t\tmid_waveform = old_waveform;\n\t}\n\n\tmid_cdclk_config->cdclk = DIV_ROUND_CLOSEST(cdclk_squash_divider(mid_waveform) *\n\t\t\t\t\t\t    mid_cdclk_config->vco, size * div);\n\n\t \n\n\tdrm_WARN_ON(&i915->drm, mid_cdclk_config->cdclk <\n\t\t    min(old_cdclk_config->cdclk, new_cdclk_config->cdclk));\n\tdrm_WARN_ON(&i915->drm, mid_cdclk_config->cdclk >\n\t\t    i915->display.cdclk.max_cdclk_freq);\n\tdrm_WARN_ON(&i915->drm, cdclk_squash_waveform(i915, mid_cdclk_config->cdclk) !=\n\t\t    mid_waveform);\n\n\treturn true;\n}\n\nstatic bool pll_enable_wa_needed(struct drm_i915_private *dev_priv)\n{\n\treturn ((IS_DG2(dev_priv) || IS_METEORLAKE(dev_priv)) &&\n\t\tdev_priv->display.cdclk.hw.vco > 0 &&\n\t\tHAS_CDCLK_SQUASH(dev_priv));\n}\n\nstatic void _bxt_set_cdclk(struct drm_i915_private *dev_priv,\n\t\t\t   const struct intel_cdclk_config *cdclk_config,\n\t\t\t   enum pipe pipe)\n{\n\tint cdclk = cdclk_config->cdclk;\n\tint vco = cdclk_config->vco;\n\tu32 val;\n\tu16 waveform;\n\tint clock;\n\n\tif (HAS_CDCLK_CRAWL(dev_priv) && dev_priv->display.cdclk.hw.vco > 0 && vco > 0 &&\n\t    !cdclk_pll_is_unknown(dev_priv->display.cdclk.hw.vco)) {\n\t\tif (dev_priv->display.cdclk.hw.vco != vco)\n\t\t\tadlp_cdclk_pll_crawl(dev_priv, vco);\n\t} else if (DISPLAY_VER(dev_priv) >= 11) {\n\t\t \n\t\tif (pll_enable_wa_needed(dev_priv))\n\t\t\tdg2_cdclk_squash_program(dev_priv, 0);\n\n\t\ticl_cdclk_pll_update(dev_priv, vco);\n\t} else\n\t\tbxt_cdclk_pll_update(dev_priv, vco);\n\n\twaveform = cdclk_squash_waveform(dev_priv, cdclk);\n\n\tif (waveform)\n\t\tclock = vco / 2;\n\telse\n\t\tclock = cdclk;\n\n\tif (HAS_CDCLK_SQUASH(dev_priv))\n\t\tdg2_cdclk_squash_program(dev_priv, waveform);\n\n\tval = bxt_cdclk_cd2x_div_sel(dev_priv, clock, vco) |\n\t\tbxt_cdclk_cd2x_pipe(dev_priv, pipe) |\n\t\tskl_cdclk_decimal(cdclk);\n\n\t \n\tif ((IS_GEMINILAKE(dev_priv) || IS_BROXTON(dev_priv)) &&\n\t    cdclk >= 500000)\n\t\tval |= BXT_CDCLK_SSA_PRECHARGE_ENABLE;\n\tintel_de_write(dev_priv, CDCLK_CTL, val);\n\n\tif (pipe != INVALID_PIPE)\n\t\tintel_crtc_wait_for_next_vblank(intel_crtc_for_pipe(dev_priv, pipe));\n}\n\nstatic void bxt_set_cdclk(struct drm_i915_private *dev_priv,\n\t\t\t  const struct intel_cdclk_config *cdclk_config,\n\t\t\t  enum pipe pipe)\n{\n\tstruct intel_cdclk_config mid_cdclk_config;\n\tint cdclk = cdclk_config->cdclk;\n\tint ret = 0;\n\n\t \n\tif (DISPLAY_VER(dev_priv) >= 14 || IS_DG2(dev_priv))\n\t\t ;\n\telse if (DISPLAY_VER(dev_priv) >= 11)\n\t\tret = skl_pcode_request(&dev_priv->uncore, SKL_PCODE_CDCLK_CONTROL,\n\t\t\t\t\tSKL_CDCLK_PREPARE_FOR_CHANGE,\n\t\t\t\t\tSKL_CDCLK_READY_FOR_CHANGE,\n\t\t\t\t\tSKL_CDCLK_READY_FOR_CHANGE, 3);\n\telse\n\t\t \n\t\tret = snb_pcode_write_timeout(&dev_priv->uncore,\n\t\t\t\t\t      HSW_PCODE_DE_WRITE_FREQ_REQ,\n\t\t\t\t\t      0x80000000, 150, 2);\n\n\tif (ret) {\n\t\tdrm_err(&dev_priv->drm,\n\t\t\t\"Failed to inform PCU about cdclk change (err %d, freq %d)\\n\",\n\t\t\tret, cdclk);\n\t\treturn;\n\t}\n\n\tif (cdclk_compute_crawl_and_squash_midpoint(dev_priv, &dev_priv->display.cdclk.hw,\n\t\t\t\t\t\t    cdclk_config, &mid_cdclk_config)) {\n\t\t_bxt_set_cdclk(dev_priv, &mid_cdclk_config, pipe);\n\t\t_bxt_set_cdclk(dev_priv, cdclk_config, pipe);\n\t} else {\n\t\t_bxt_set_cdclk(dev_priv, cdclk_config, pipe);\n\t}\n\n\tif (DISPLAY_VER(dev_priv) >= 14)\n\t\t ;\n\telse if (DISPLAY_VER(dev_priv) >= 11 && !IS_DG2(dev_priv))\n\t\tret = snb_pcode_write(&dev_priv->uncore, SKL_PCODE_CDCLK_CONTROL,\n\t\t\t\t      cdclk_config->voltage_level);\n\tif (DISPLAY_VER(dev_priv) < 11) {\n\t\t \n\t\tret = snb_pcode_write_timeout(&dev_priv->uncore,\n\t\t\t\t\t      HSW_PCODE_DE_WRITE_FREQ_REQ,\n\t\t\t\t\t      cdclk_config->voltage_level,\n\t\t\t\t\t      150, 2);\n\t}\n\tif (ret) {\n\t\tdrm_err(&dev_priv->drm,\n\t\t\t\"PCode CDCLK freq set failed, (err %d, freq %d)\\n\",\n\t\t\tret, cdclk);\n\t\treturn;\n\t}\n\n\tintel_update_cdclk(dev_priv);\n\n\tif (DISPLAY_VER(dev_priv) >= 11)\n\t\t \n\t\tdev_priv->display.cdclk.hw.voltage_level = cdclk_config->voltage_level;\n}\n\nstatic void bxt_sanitize_cdclk(struct drm_i915_private *dev_priv)\n{\n\tu32 cdctl, expected;\n\tint cdclk, clock, vco;\n\n\tintel_update_cdclk(dev_priv);\n\tintel_cdclk_dump_config(dev_priv, &dev_priv->display.cdclk.hw, \"Current CDCLK\");\n\n\tif (dev_priv->display.cdclk.hw.vco == 0 ||\n\t    dev_priv->display.cdclk.hw.cdclk == dev_priv->display.cdclk.hw.bypass)\n\t\tgoto sanitize;\n\n\t \n\tcdctl = intel_de_read(dev_priv, CDCLK_CTL);\n\t \n\tcdctl &= ~bxt_cdclk_cd2x_pipe(dev_priv, INVALID_PIPE);\n\n\t \n\tcdclk = bxt_calc_cdclk(dev_priv, dev_priv->display.cdclk.hw.cdclk);\n\tif (cdclk != dev_priv->display.cdclk.hw.cdclk)\n\t\tgoto sanitize;\n\n\t \n\tvco = bxt_calc_cdclk_pll_vco(dev_priv, cdclk);\n\tif (vco != dev_priv->display.cdclk.hw.vco)\n\t\tgoto sanitize;\n\n\texpected = skl_cdclk_decimal(cdclk);\n\n\t \n\tif (HAS_CDCLK_SQUASH(dev_priv))\n\t\tclock = dev_priv->display.cdclk.hw.vco / 2;\n\telse\n\t\tclock = dev_priv->display.cdclk.hw.cdclk;\n\n\texpected |= bxt_cdclk_cd2x_div_sel(dev_priv, clock,\n\t\t\t\t\t   dev_priv->display.cdclk.hw.vco);\n\n\t \n\tif ((IS_GEMINILAKE(dev_priv) || IS_BROXTON(dev_priv)) &&\n\t    dev_priv->display.cdclk.hw.cdclk >= 500000)\n\t\texpected |= BXT_CDCLK_SSA_PRECHARGE_ENABLE;\n\n\tif (cdctl == expected)\n\t\t \n\t\treturn;\n\nsanitize:\n\tdrm_dbg_kms(&dev_priv->drm, \"Sanitizing cdclk programmed by pre-os\\n\");\n\n\t \n\tdev_priv->display.cdclk.hw.cdclk = 0;\n\n\t \n\tdev_priv->display.cdclk.hw.vco = -1;\n}\n\nstatic void bxt_cdclk_init_hw(struct drm_i915_private *dev_priv)\n{\n\tstruct intel_cdclk_config cdclk_config;\n\n\tbxt_sanitize_cdclk(dev_priv);\n\n\tif (dev_priv->display.cdclk.hw.cdclk != 0 &&\n\t    dev_priv->display.cdclk.hw.vco != 0)\n\t\treturn;\n\n\tcdclk_config = dev_priv->display.cdclk.hw;\n\n\t \n\tcdclk_config.cdclk = bxt_calc_cdclk(dev_priv, 0);\n\tcdclk_config.vco = bxt_calc_cdclk_pll_vco(dev_priv, cdclk_config.cdclk);\n\tcdclk_config.voltage_level =\n\t\tintel_cdclk_calc_voltage_level(dev_priv, cdclk_config.cdclk);\n\n\tbxt_set_cdclk(dev_priv, &cdclk_config, INVALID_PIPE);\n}\n\nstatic void bxt_cdclk_uninit_hw(struct drm_i915_private *dev_priv)\n{\n\tstruct intel_cdclk_config cdclk_config = dev_priv->display.cdclk.hw;\n\n\tcdclk_config.cdclk = cdclk_config.bypass;\n\tcdclk_config.vco = 0;\n\tcdclk_config.voltage_level =\n\t\tintel_cdclk_calc_voltage_level(dev_priv, cdclk_config.cdclk);\n\n\tbxt_set_cdclk(dev_priv, &cdclk_config, INVALID_PIPE);\n}\n\n \nvoid intel_cdclk_init_hw(struct drm_i915_private *i915)\n{\n\tif (DISPLAY_VER(i915) >= 10 || IS_BROXTON(i915))\n\t\tbxt_cdclk_init_hw(i915);\n\telse if (DISPLAY_VER(i915) == 9)\n\t\tskl_cdclk_init_hw(i915);\n}\n\n \nvoid intel_cdclk_uninit_hw(struct drm_i915_private *i915)\n{\n\tif (DISPLAY_VER(i915) >= 10 || IS_BROXTON(i915))\n\t\tbxt_cdclk_uninit_hw(i915);\n\telse if (DISPLAY_VER(i915) == 9)\n\t\tskl_cdclk_uninit_hw(i915);\n}\n\nstatic bool intel_cdclk_can_crawl_and_squash(struct drm_i915_private *i915,\n\t\t\t\t\t     const struct intel_cdclk_config *a,\n\t\t\t\t\t     const struct intel_cdclk_config *b)\n{\n\tu16 old_waveform;\n\tu16 new_waveform;\n\n\tdrm_WARN_ON(&i915->drm, cdclk_pll_is_unknown(a->vco));\n\n\tif (a->vco == 0 || b->vco == 0)\n\t\treturn false;\n\n\tif (!HAS_CDCLK_CRAWL(i915) || !HAS_CDCLK_SQUASH(i915))\n\t\treturn false;\n\n\told_waveform = cdclk_squash_waveform(i915, a->cdclk);\n\tnew_waveform = cdclk_squash_waveform(i915, b->cdclk);\n\n\treturn a->vco != b->vco &&\n\t       old_waveform != new_waveform;\n}\n\nstatic bool intel_cdclk_can_crawl(struct drm_i915_private *dev_priv,\n\t\t\t\t  const struct intel_cdclk_config *a,\n\t\t\t\t  const struct intel_cdclk_config *b)\n{\n\tint a_div, b_div;\n\n\tif (!HAS_CDCLK_CRAWL(dev_priv))\n\t\treturn false;\n\n\t \n\ta_div = DIV_ROUND_CLOSEST(a->vco, a->cdclk);\n\tb_div = DIV_ROUND_CLOSEST(b->vco, b->cdclk);\n\n\treturn a->vco != 0 && b->vco != 0 &&\n\t\ta->vco != b->vco &&\n\t\ta_div == b_div &&\n\t\ta->ref == b->ref;\n}\n\nstatic bool intel_cdclk_can_squash(struct drm_i915_private *dev_priv,\n\t\t\t\t   const struct intel_cdclk_config *a,\n\t\t\t\t   const struct intel_cdclk_config *b)\n{\n\t \n\tif (!HAS_CDCLK_SQUASH(dev_priv))\n\t\treturn false;\n\n\treturn a->cdclk != b->cdclk &&\n\t\ta->vco != 0 &&\n\t\ta->vco == b->vco &&\n\t\ta->ref == b->ref;\n}\n\n \nbool intel_cdclk_needs_modeset(const struct intel_cdclk_config *a,\n\t\t\t       const struct intel_cdclk_config *b)\n{\n\treturn a->cdclk != b->cdclk ||\n\t\ta->vco != b->vco ||\n\t\ta->ref != b->ref;\n}\n\n \nstatic bool intel_cdclk_can_cd2x_update(struct drm_i915_private *dev_priv,\n\t\t\t\t\tconst struct intel_cdclk_config *a,\n\t\t\t\t\tconst struct intel_cdclk_config *b)\n{\n\t \n\tif (DISPLAY_VER(dev_priv) < 10 && !IS_BROXTON(dev_priv))\n\t\treturn false;\n\n\t \n\tif (HAS_CDCLK_SQUASH(dev_priv))\n\t\treturn false;\n\n\treturn a->cdclk != b->cdclk &&\n\t\ta->vco != 0 &&\n\t\ta->vco == b->vco &&\n\t\ta->ref == b->ref;\n}\n\n \nstatic bool intel_cdclk_changed(const struct intel_cdclk_config *a,\n\t\t\t\tconst struct intel_cdclk_config *b)\n{\n\treturn intel_cdclk_needs_modeset(a, b) ||\n\t\ta->voltage_level != b->voltage_level;\n}\n\nvoid intel_cdclk_dump_config(struct drm_i915_private *i915,\n\t\t\t     const struct intel_cdclk_config *cdclk_config,\n\t\t\t     const char *context)\n{\n\tdrm_dbg_kms(&i915->drm, \"%s %d kHz, VCO %d kHz, ref %d kHz, bypass %d kHz, voltage level %d\\n\",\n\t\t    context, cdclk_config->cdclk, cdclk_config->vco,\n\t\t    cdclk_config->ref, cdclk_config->bypass,\n\t\t    cdclk_config->voltage_level);\n}\n\nstatic void intel_pcode_notify(struct drm_i915_private *i915,\n\t\t\t       u8 voltage_level,\n\t\t\t       u8 active_pipe_count,\n\t\t\t       u16 cdclk,\n\t\t\t       bool cdclk_update_valid,\n\t\t\t       bool pipe_count_update_valid)\n{\n\tint ret;\n\tu32 update_mask = 0;\n\n\tif (!IS_DG2(i915))\n\t\treturn;\n\n\tupdate_mask = DISPLAY_TO_PCODE_UPDATE_MASK(cdclk, active_pipe_count, voltage_level);\n\n\tif (cdclk_update_valid)\n\t\tupdate_mask |= DISPLAY_TO_PCODE_CDCLK_VALID;\n\n\tif (pipe_count_update_valid)\n\t\tupdate_mask |= DISPLAY_TO_PCODE_PIPE_COUNT_VALID;\n\n\tret = skl_pcode_request(&i915->uncore, SKL_PCODE_CDCLK_CONTROL,\n\t\t\t\tSKL_CDCLK_PREPARE_FOR_CHANGE |\n\t\t\t\tupdate_mask,\n\t\t\t\tSKL_CDCLK_READY_FOR_CHANGE,\n\t\t\t\tSKL_CDCLK_READY_FOR_CHANGE, 3);\n\tif (ret)\n\t\tdrm_err(&i915->drm,\n\t\t\t\"Failed to inform PCU about display config (err %d)\\n\",\n\t\t\tret);\n}\n\n \nstatic void intel_set_cdclk(struct drm_i915_private *dev_priv,\n\t\t\t    const struct intel_cdclk_config *cdclk_config,\n\t\t\t    enum pipe pipe)\n{\n\tstruct intel_encoder *encoder;\n\n\tif (!intel_cdclk_changed(&dev_priv->display.cdclk.hw, cdclk_config))\n\t\treturn;\n\n\tif (drm_WARN_ON_ONCE(&dev_priv->drm, !dev_priv->display.funcs.cdclk->set_cdclk))\n\t\treturn;\n\n\tintel_cdclk_dump_config(dev_priv, cdclk_config, \"Changing CDCLK to\");\n\n\tfor_each_intel_encoder_with_psr(&dev_priv->drm, encoder) {\n\t\tstruct intel_dp *intel_dp = enc_to_intel_dp(encoder);\n\n\t\tintel_psr_pause(intel_dp);\n\t}\n\n\tintel_audio_cdclk_change_pre(dev_priv);\n\n\t \n\tmutex_lock(&dev_priv->display.gmbus.mutex);\n\tfor_each_intel_dp(&dev_priv->drm, encoder) {\n\t\tstruct intel_dp *intel_dp = enc_to_intel_dp(encoder);\n\n\t\tmutex_lock_nest_lock(&intel_dp->aux.hw_mutex,\n\t\t\t\t     &dev_priv->display.gmbus.mutex);\n\t}\n\n\tintel_cdclk_set_cdclk(dev_priv, cdclk_config, pipe);\n\n\tfor_each_intel_dp(&dev_priv->drm, encoder) {\n\t\tstruct intel_dp *intel_dp = enc_to_intel_dp(encoder);\n\n\t\tmutex_unlock(&intel_dp->aux.hw_mutex);\n\t}\n\tmutex_unlock(&dev_priv->display.gmbus.mutex);\n\n\tfor_each_intel_encoder_with_psr(&dev_priv->drm, encoder) {\n\t\tstruct intel_dp *intel_dp = enc_to_intel_dp(encoder);\n\n\t\tintel_psr_resume(intel_dp);\n\t}\n\n\tintel_audio_cdclk_change_post(dev_priv);\n\n\tif (drm_WARN(&dev_priv->drm,\n\t\t     intel_cdclk_changed(&dev_priv->display.cdclk.hw, cdclk_config),\n\t\t     \"cdclk state doesn't match!\\n\")) {\n\t\tintel_cdclk_dump_config(dev_priv, &dev_priv->display.cdclk.hw, \"[hw state]\");\n\t\tintel_cdclk_dump_config(dev_priv, cdclk_config, \"[sw state]\");\n\t}\n}\n\nstatic void intel_cdclk_pcode_pre_notify(struct intel_atomic_state *state)\n{\n\tstruct drm_i915_private *i915 = to_i915(state->base.dev);\n\tconst struct intel_cdclk_state *old_cdclk_state =\n\t\tintel_atomic_get_old_cdclk_state(state);\n\tconst struct intel_cdclk_state *new_cdclk_state =\n\t\tintel_atomic_get_new_cdclk_state(state);\n\tunsigned int cdclk = 0; u8 voltage_level, num_active_pipes = 0;\n\tbool change_cdclk, update_pipe_count;\n\n\tif (!intel_cdclk_changed(&old_cdclk_state->actual,\n\t\t\t\t &new_cdclk_state->actual) &&\n\t\t\t\t new_cdclk_state->active_pipes ==\n\t\t\t\t old_cdclk_state->active_pipes)\n\t\treturn;\n\n\t \n\tvoltage_level = DISPLAY_TO_PCODE_VOLTAGE_MAX;\n\n\tchange_cdclk = new_cdclk_state->actual.cdclk != old_cdclk_state->actual.cdclk;\n\tupdate_pipe_count = hweight8(new_cdclk_state->active_pipes) >\n\t\t\t    hweight8(old_cdclk_state->active_pipes);\n\n\t \n\tif (change_cdclk)\n\t\tcdclk = max(new_cdclk_state->actual.cdclk, old_cdclk_state->actual.cdclk);\n\n\t \n\tif (update_pipe_count)\n\t\tnum_active_pipes = hweight8(new_cdclk_state->active_pipes);\n\n\tintel_pcode_notify(i915, voltage_level, num_active_pipes, cdclk,\n\t\t\t   change_cdclk, update_pipe_count);\n}\n\nstatic void intel_cdclk_pcode_post_notify(struct intel_atomic_state *state)\n{\n\tstruct drm_i915_private *i915 = to_i915(state->base.dev);\n\tconst struct intel_cdclk_state *new_cdclk_state =\n\t\tintel_atomic_get_new_cdclk_state(state);\n\tconst struct intel_cdclk_state *old_cdclk_state =\n\t\tintel_atomic_get_old_cdclk_state(state);\n\tunsigned int cdclk = 0; u8 voltage_level, num_active_pipes = 0;\n\tbool update_cdclk, update_pipe_count;\n\n\t \n\tvoltage_level = new_cdclk_state->actual.voltage_level;\n\n\tupdate_cdclk = new_cdclk_state->actual.cdclk != old_cdclk_state->actual.cdclk;\n\tupdate_pipe_count = hweight8(new_cdclk_state->active_pipes) <\n\t\t\t    hweight8(old_cdclk_state->active_pipes);\n\n\t \n\tif (update_cdclk)\n\t\tcdclk = new_cdclk_state->actual.cdclk;\n\n\t \n\tif (update_pipe_count)\n\t\tnum_active_pipes = hweight8(new_cdclk_state->active_pipes);\n\n\tintel_pcode_notify(i915, voltage_level, num_active_pipes, cdclk,\n\t\t\t   update_cdclk, update_pipe_count);\n}\n\n \nvoid\nintel_set_cdclk_pre_plane_update(struct intel_atomic_state *state)\n{\n\tstruct drm_i915_private *i915 = to_i915(state->base.dev);\n\tconst struct intel_cdclk_state *old_cdclk_state =\n\t\tintel_atomic_get_old_cdclk_state(state);\n\tconst struct intel_cdclk_state *new_cdclk_state =\n\t\tintel_atomic_get_new_cdclk_state(state);\n\tenum pipe pipe = new_cdclk_state->pipe;\n\n\tif (!intel_cdclk_changed(&old_cdclk_state->actual,\n\t\t\t\t &new_cdclk_state->actual))\n\t\treturn;\n\n\tif (IS_DG2(i915))\n\t\tintel_cdclk_pcode_pre_notify(state);\n\n\tif (pipe == INVALID_PIPE ||\n\t    old_cdclk_state->actual.cdclk <= new_cdclk_state->actual.cdclk) {\n\t\tdrm_WARN_ON(&i915->drm, !new_cdclk_state->base.changed);\n\n\t\tintel_set_cdclk(i915, &new_cdclk_state->actual, pipe);\n\t}\n}\n\n \nvoid\nintel_set_cdclk_post_plane_update(struct intel_atomic_state *state)\n{\n\tstruct drm_i915_private *i915 = to_i915(state->base.dev);\n\tconst struct intel_cdclk_state *old_cdclk_state =\n\t\tintel_atomic_get_old_cdclk_state(state);\n\tconst struct intel_cdclk_state *new_cdclk_state =\n\t\tintel_atomic_get_new_cdclk_state(state);\n\tenum pipe pipe = new_cdclk_state->pipe;\n\n\tif (!intel_cdclk_changed(&old_cdclk_state->actual,\n\t\t\t\t &new_cdclk_state->actual))\n\t\treturn;\n\n\tif (IS_DG2(i915))\n\t\tintel_cdclk_pcode_post_notify(state);\n\n\tif (pipe != INVALID_PIPE &&\n\t    old_cdclk_state->actual.cdclk > new_cdclk_state->actual.cdclk) {\n\t\tdrm_WARN_ON(&i915->drm, !new_cdclk_state->base.changed);\n\n\t\tintel_set_cdclk(i915, &new_cdclk_state->actual, pipe);\n\t}\n}\n\nstatic int intel_pixel_rate_to_cdclk(const struct intel_crtc_state *crtc_state)\n{\n\tstruct drm_i915_private *dev_priv = to_i915(crtc_state->uapi.crtc->dev);\n\tint pixel_rate = crtc_state->pixel_rate;\n\n\tif (DISPLAY_VER(dev_priv) >= 10)\n\t\treturn DIV_ROUND_UP(pixel_rate, 2);\n\telse if (DISPLAY_VER(dev_priv) == 9 ||\n\t\t IS_BROADWELL(dev_priv) || IS_HASWELL(dev_priv))\n\t\treturn pixel_rate;\n\telse if (IS_CHERRYVIEW(dev_priv))\n\t\treturn DIV_ROUND_UP(pixel_rate * 100, 95);\n\telse if (crtc_state->double_wide)\n\t\treturn DIV_ROUND_UP(pixel_rate * 100, 90 * 2);\n\telse\n\t\treturn DIV_ROUND_UP(pixel_rate * 100, 90);\n}\n\nstatic int intel_planes_min_cdclk(const struct intel_crtc_state *crtc_state)\n{\n\tstruct intel_crtc *crtc = to_intel_crtc(crtc_state->uapi.crtc);\n\tstruct drm_i915_private *dev_priv = to_i915(crtc->base.dev);\n\tstruct intel_plane *plane;\n\tint min_cdclk = 0;\n\n\tfor_each_intel_plane_on_crtc(&dev_priv->drm, crtc, plane)\n\t\tmin_cdclk = max(crtc_state->min_cdclk[plane->id], min_cdclk);\n\n\treturn min_cdclk;\n}\n\nint intel_crtc_compute_min_cdclk(const struct intel_crtc_state *crtc_state)\n{\n\tstruct drm_i915_private *dev_priv =\n\t\tto_i915(crtc_state->uapi.crtc->dev);\n\tint min_cdclk;\n\n\tif (!crtc_state->hw.enable)\n\t\treturn 0;\n\n\tmin_cdclk = intel_pixel_rate_to_cdclk(crtc_state);\n\n\t \n\tif (IS_BROADWELL(dev_priv) && hsw_crtc_state_ips_capable(crtc_state))\n\t\tmin_cdclk = DIV_ROUND_UP(min_cdclk * 100, 95);\n\n\t \n\tif (intel_crtc_has_dp_encoder(crtc_state) &&\n\t    crtc_state->has_audio &&\n\t    crtc_state->port_clock >= 540000 &&\n\t    crtc_state->lane_count == 4) {\n\t\tif (DISPLAY_VER(dev_priv) == 10) {\n\t\t\t \n\t\t\tmin_cdclk = max(316800, min_cdclk);\n\t\t} else if (DISPLAY_VER(dev_priv) == 9 || IS_BROADWELL(dev_priv)) {\n\t\t\t \n\t\t\tmin_cdclk = max(432000, min_cdclk);\n\t\t}\n\t}\n\n\t \n\tif (crtc_state->has_audio && DISPLAY_VER(dev_priv) >= 9)\n\t\tmin_cdclk = max(2 * 96000, min_cdclk);\n\n\t \n\tif ((IS_VALLEYVIEW(dev_priv) || IS_CHERRYVIEW(dev_priv)) &&\n\t    intel_crtc_has_dp_encoder(crtc_state) && crtc_state->has_audio)\n\t\tmin_cdclk = max(crtc_state->port_clock, min_cdclk);\n\n\t \n\tif (intel_crtc_has_type(crtc_state, INTEL_OUTPUT_DSI) &&\n\t    IS_VALLEYVIEW(dev_priv))\n\t\tmin_cdclk = max(320000, min_cdclk);\n\n\t \n\tif (intel_crtc_has_type(crtc_state, INTEL_OUTPUT_DSI) &&\n\t    IS_GEMINILAKE(dev_priv))\n\t\tmin_cdclk = max(158400, min_cdclk);\n\n\t \n\tmin_cdclk = max(intel_planes_min_cdclk(crtc_state), min_cdclk);\n\n\t \n\tif (crtc_state->dsc.compression_enable) {\n\t\tint num_vdsc_instances = intel_dsc_get_num_vdsc_instances(crtc_state);\n\n\t\tmin_cdclk = max_t(int, min_cdclk,\n\t\t\t\t  DIV_ROUND_UP(crtc_state->pixel_rate,\n\t\t\t\t\t       num_vdsc_instances));\n\t}\n\n\t \n\tif (IS_TIGERLAKE(dev_priv) || IS_DG2(dev_priv)) {\n\t\t \n\t\tmin_cdclk = max_t(int, min_cdclk,\n\t\t\t\t  min_t(int, crtc_state->pixel_rate,\n\t\t\t\t\tdev_priv->display.cdclk.max_cdclk_freq));\n\t}\n\n\treturn min_cdclk;\n}\n\nstatic int intel_compute_min_cdclk(struct intel_cdclk_state *cdclk_state)\n{\n\tstruct intel_atomic_state *state = cdclk_state->base.state;\n\tstruct drm_i915_private *dev_priv = to_i915(state->base.dev);\n\tconst struct intel_bw_state *bw_state;\n\tstruct intel_crtc *crtc;\n\tstruct intel_crtc_state *crtc_state;\n\tint min_cdclk, i;\n\tenum pipe pipe;\n\n\tfor_each_new_intel_crtc_in_state(state, crtc, crtc_state, i) {\n\t\tint ret;\n\n\t\tmin_cdclk = intel_crtc_compute_min_cdclk(crtc_state);\n\t\tif (min_cdclk < 0)\n\t\t\treturn min_cdclk;\n\n\t\tif (cdclk_state->min_cdclk[crtc->pipe] == min_cdclk)\n\t\t\tcontinue;\n\n\t\tcdclk_state->min_cdclk[crtc->pipe] = min_cdclk;\n\n\t\tret = intel_atomic_lock_global_state(&cdclk_state->base);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tbw_state = intel_atomic_get_new_bw_state(state);\n\tif (bw_state) {\n\t\tmin_cdclk = intel_bw_min_cdclk(dev_priv, bw_state);\n\n\t\tif (cdclk_state->bw_min_cdclk != min_cdclk) {\n\t\t\tint ret;\n\n\t\t\tcdclk_state->bw_min_cdclk = min_cdclk;\n\n\t\t\tret = intel_atomic_lock_global_state(&cdclk_state->base);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t}\n\t}\n\n\tmin_cdclk = max(cdclk_state->force_min_cdclk,\n\t\t\tcdclk_state->bw_min_cdclk);\n\tfor_each_pipe(dev_priv, pipe)\n\t\tmin_cdclk = max(cdclk_state->min_cdclk[pipe], min_cdclk);\n\n\t \n\tif (IS_GEMINILAKE(dev_priv) && cdclk_state->active_pipes &&\n\t    !is_power_of_2(cdclk_state->active_pipes))\n\t\tmin_cdclk = max(2 * 96000, min_cdclk);\n\n\tif (min_cdclk > dev_priv->display.cdclk.max_cdclk_freq) {\n\t\tdrm_dbg_kms(&dev_priv->drm,\n\t\t\t    \"required cdclk (%d kHz) exceeds max (%d kHz)\\n\",\n\t\t\t    min_cdclk, dev_priv->display.cdclk.max_cdclk_freq);\n\t\treturn -EINVAL;\n\t}\n\n\treturn min_cdclk;\n}\n\n \nstatic int bxt_compute_min_voltage_level(struct intel_cdclk_state *cdclk_state)\n{\n\tstruct intel_atomic_state *state = cdclk_state->base.state;\n\tstruct drm_i915_private *dev_priv = to_i915(state->base.dev);\n\tstruct intel_crtc *crtc;\n\tstruct intel_crtc_state *crtc_state;\n\tu8 min_voltage_level;\n\tint i;\n\tenum pipe pipe;\n\n\tfor_each_new_intel_crtc_in_state(state, crtc, crtc_state, i) {\n\t\tint ret;\n\n\t\tif (crtc_state->hw.enable)\n\t\t\tmin_voltage_level = crtc_state->min_voltage_level;\n\t\telse\n\t\t\tmin_voltage_level = 0;\n\n\t\tif (cdclk_state->min_voltage_level[crtc->pipe] == min_voltage_level)\n\t\t\tcontinue;\n\n\t\tcdclk_state->min_voltage_level[crtc->pipe] = min_voltage_level;\n\n\t\tret = intel_atomic_lock_global_state(&cdclk_state->base);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tmin_voltage_level = 0;\n\tfor_each_pipe(dev_priv, pipe)\n\t\tmin_voltage_level = max(cdclk_state->min_voltage_level[pipe],\n\t\t\t\t\tmin_voltage_level);\n\n\treturn min_voltage_level;\n}\n\nstatic int vlv_modeset_calc_cdclk(struct intel_cdclk_state *cdclk_state)\n{\n\tstruct intel_atomic_state *state = cdclk_state->base.state;\n\tstruct drm_i915_private *dev_priv = to_i915(state->base.dev);\n\tint min_cdclk, cdclk;\n\n\tmin_cdclk = intel_compute_min_cdclk(cdclk_state);\n\tif (min_cdclk < 0)\n\t\treturn min_cdclk;\n\n\tcdclk = vlv_calc_cdclk(dev_priv, min_cdclk);\n\n\tcdclk_state->logical.cdclk = cdclk;\n\tcdclk_state->logical.voltage_level =\n\t\tvlv_calc_voltage_level(dev_priv, cdclk);\n\n\tif (!cdclk_state->active_pipes) {\n\t\tcdclk = vlv_calc_cdclk(dev_priv, cdclk_state->force_min_cdclk);\n\n\t\tcdclk_state->actual.cdclk = cdclk;\n\t\tcdclk_state->actual.voltage_level =\n\t\t\tvlv_calc_voltage_level(dev_priv, cdclk);\n\t} else {\n\t\tcdclk_state->actual = cdclk_state->logical;\n\t}\n\n\treturn 0;\n}\n\nstatic int bdw_modeset_calc_cdclk(struct intel_cdclk_state *cdclk_state)\n{\n\tint min_cdclk, cdclk;\n\n\tmin_cdclk = intel_compute_min_cdclk(cdclk_state);\n\tif (min_cdclk < 0)\n\t\treturn min_cdclk;\n\n\tcdclk = bdw_calc_cdclk(min_cdclk);\n\n\tcdclk_state->logical.cdclk = cdclk;\n\tcdclk_state->logical.voltage_level =\n\t\tbdw_calc_voltage_level(cdclk);\n\n\tif (!cdclk_state->active_pipes) {\n\t\tcdclk = bdw_calc_cdclk(cdclk_state->force_min_cdclk);\n\n\t\tcdclk_state->actual.cdclk = cdclk;\n\t\tcdclk_state->actual.voltage_level =\n\t\t\tbdw_calc_voltage_level(cdclk);\n\t} else {\n\t\tcdclk_state->actual = cdclk_state->logical;\n\t}\n\n\treturn 0;\n}\n\nstatic int skl_dpll0_vco(struct intel_cdclk_state *cdclk_state)\n{\n\tstruct intel_atomic_state *state = cdclk_state->base.state;\n\tstruct drm_i915_private *dev_priv = to_i915(state->base.dev);\n\tstruct intel_crtc *crtc;\n\tstruct intel_crtc_state *crtc_state;\n\tint vco, i;\n\n\tvco = cdclk_state->logical.vco;\n\tif (!vco)\n\t\tvco = dev_priv->skl_preferred_vco_freq;\n\n\tfor_each_new_intel_crtc_in_state(state, crtc, crtc_state, i) {\n\t\tif (!crtc_state->hw.enable)\n\t\t\tcontinue;\n\n\t\tif (!intel_crtc_has_type(crtc_state, INTEL_OUTPUT_EDP))\n\t\t\tcontinue;\n\n\t\t \n\t\tswitch (crtc_state->port_clock / 2) {\n\t\tcase 108000:\n\t\tcase 216000:\n\t\t\tvco = 8640000;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tvco = 8100000;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn vco;\n}\n\nstatic int skl_modeset_calc_cdclk(struct intel_cdclk_state *cdclk_state)\n{\n\tint min_cdclk, cdclk, vco;\n\n\tmin_cdclk = intel_compute_min_cdclk(cdclk_state);\n\tif (min_cdclk < 0)\n\t\treturn min_cdclk;\n\n\tvco = skl_dpll0_vco(cdclk_state);\n\n\tcdclk = skl_calc_cdclk(min_cdclk, vco);\n\n\tcdclk_state->logical.vco = vco;\n\tcdclk_state->logical.cdclk = cdclk;\n\tcdclk_state->logical.voltage_level =\n\t\tskl_calc_voltage_level(cdclk);\n\n\tif (!cdclk_state->active_pipes) {\n\t\tcdclk = skl_calc_cdclk(cdclk_state->force_min_cdclk, vco);\n\n\t\tcdclk_state->actual.vco = vco;\n\t\tcdclk_state->actual.cdclk = cdclk;\n\t\tcdclk_state->actual.voltage_level =\n\t\t\tskl_calc_voltage_level(cdclk);\n\t} else {\n\t\tcdclk_state->actual = cdclk_state->logical;\n\t}\n\n\treturn 0;\n}\n\nstatic int bxt_modeset_calc_cdclk(struct intel_cdclk_state *cdclk_state)\n{\n\tstruct intel_atomic_state *state = cdclk_state->base.state;\n\tstruct drm_i915_private *dev_priv = to_i915(state->base.dev);\n\tint min_cdclk, min_voltage_level, cdclk, vco;\n\n\tmin_cdclk = intel_compute_min_cdclk(cdclk_state);\n\tif (min_cdclk < 0)\n\t\treturn min_cdclk;\n\n\tmin_voltage_level = bxt_compute_min_voltage_level(cdclk_state);\n\tif (min_voltage_level < 0)\n\t\treturn min_voltage_level;\n\n\tcdclk = bxt_calc_cdclk(dev_priv, min_cdclk);\n\tvco = bxt_calc_cdclk_pll_vco(dev_priv, cdclk);\n\n\tcdclk_state->logical.vco = vco;\n\tcdclk_state->logical.cdclk = cdclk;\n\tcdclk_state->logical.voltage_level =\n\t\tmax_t(int, min_voltage_level,\n\t\t      intel_cdclk_calc_voltage_level(dev_priv, cdclk));\n\n\tif (!cdclk_state->active_pipes) {\n\t\tcdclk = bxt_calc_cdclk(dev_priv, cdclk_state->force_min_cdclk);\n\t\tvco = bxt_calc_cdclk_pll_vco(dev_priv, cdclk);\n\n\t\tcdclk_state->actual.vco = vco;\n\t\tcdclk_state->actual.cdclk = cdclk;\n\t\tcdclk_state->actual.voltage_level =\n\t\t\tintel_cdclk_calc_voltage_level(dev_priv, cdclk);\n\t} else {\n\t\tcdclk_state->actual = cdclk_state->logical;\n\t}\n\n\treturn 0;\n}\n\nstatic int fixed_modeset_calc_cdclk(struct intel_cdclk_state *cdclk_state)\n{\n\tint min_cdclk;\n\n\t \n\tmin_cdclk = intel_compute_min_cdclk(cdclk_state);\n\tif (min_cdclk < 0)\n\t\treturn min_cdclk;\n\n\treturn 0;\n}\n\nstatic struct intel_global_state *intel_cdclk_duplicate_state(struct intel_global_obj *obj)\n{\n\tstruct intel_cdclk_state *cdclk_state;\n\n\tcdclk_state = kmemdup(obj->state, sizeof(*cdclk_state), GFP_KERNEL);\n\tif (!cdclk_state)\n\t\treturn NULL;\n\n\tcdclk_state->pipe = INVALID_PIPE;\n\n\treturn &cdclk_state->base;\n}\n\nstatic void intel_cdclk_destroy_state(struct intel_global_obj *obj,\n\t\t\t\t      struct intel_global_state *state)\n{\n\tkfree(state);\n}\n\nstatic const struct intel_global_state_funcs intel_cdclk_funcs = {\n\t.atomic_duplicate_state = intel_cdclk_duplicate_state,\n\t.atomic_destroy_state = intel_cdclk_destroy_state,\n};\n\nstruct intel_cdclk_state *\nintel_atomic_get_cdclk_state(struct intel_atomic_state *state)\n{\n\tstruct drm_i915_private *dev_priv = to_i915(state->base.dev);\n\tstruct intel_global_state *cdclk_state;\n\n\tcdclk_state = intel_atomic_get_global_obj_state(state, &dev_priv->display.cdclk.obj);\n\tif (IS_ERR(cdclk_state))\n\t\treturn ERR_CAST(cdclk_state);\n\n\treturn to_intel_cdclk_state(cdclk_state);\n}\n\nint intel_cdclk_atomic_check(struct intel_atomic_state *state,\n\t\t\t     bool *need_cdclk_calc)\n{\n\tconst struct intel_cdclk_state *old_cdclk_state;\n\tconst struct intel_cdclk_state *new_cdclk_state;\n\tstruct intel_plane_state __maybe_unused *plane_state;\n\tstruct intel_plane *plane;\n\tint ret;\n\tint i;\n\n\t \n\tfor_each_new_intel_plane_in_state(state, plane, plane_state, i) {\n\t\tret = intel_plane_calc_min_cdclk(state, plane, need_cdclk_calc);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tret = intel_bw_calc_min_cdclk(state, need_cdclk_calc);\n\tif (ret)\n\t\treturn ret;\n\n\told_cdclk_state = intel_atomic_get_old_cdclk_state(state);\n\tnew_cdclk_state = intel_atomic_get_new_cdclk_state(state);\n\n\tif (new_cdclk_state &&\n\t    old_cdclk_state->force_min_cdclk != new_cdclk_state->force_min_cdclk)\n\t\t*need_cdclk_calc = true;\n\n\treturn 0;\n}\n\nint intel_cdclk_init(struct drm_i915_private *dev_priv)\n{\n\tstruct intel_cdclk_state *cdclk_state;\n\n\tcdclk_state = kzalloc(sizeof(*cdclk_state), GFP_KERNEL);\n\tif (!cdclk_state)\n\t\treturn -ENOMEM;\n\n\tintel_atomic_global_obj_init(dev_priv, &dev_priv->display.cdclk.obj,\n\t\t\t\t     &cdclk_state->base, &intel_cdclk_funcs);\n\n\treturn 0;\n}\n\nstatic bool intel_cdclk_need_serialize(struct drm_i915_private *i915,\n\t\t\t\t       const struct intel_cdclk_state *old_cdclk_state,\n\t\t\t\t       const struct intel_cdclk_state *new_cdclk_state)\n{\n\tbool power_well_cnt_changed = hweight8(old_cdclk_state->active_pipes) !=\n\t\t\t\t      hweight8(new_cdclk_state->active_pipes);\n\tbool cdclk_changed = intel_cdclk_changed(&old_cdclk_state->actual,\n\t\t\t\t\t\t &new_cdclk_state->actual);\n\t \n\treturn cdclk_changed || (IS_DG2(i915) && power_well_cnt_changed);\n}\n\nint intel_modeset_calc_cdclk(struct intel_atomic_state *state)\n{\n\tstruct drm_i915_private *dev_priv = to_i915(state->base.dev);\n\tconst struct intel_cdclk_state *old_cdclk_state;\n\tstruct intel_cdclk_state *new_cdclk_state;\n\tenum pipe pipe = INVALID_PIPE;\n\tint ret;\n\n\tnew_cdclk_state = intel_atomic_get_cdclk_state(state);\n\tif (IS_ERR(new_cdclk_state))\n\t\treturn PTR_ERR(new_cdclk_state);\n\n\told_cdclk_state = intel_atomic_get_old_cdclk_state(state);\n\n\tnew_cdclk_state->active_pipes =\n\t\tintel_calc_active_pipes(state, old_cdclk_state->active_pipes);\n\n\tret = intel_cdclk_modeset_calc_cdclk(dev_priv, new_cdclk_state);\n\tif (ret)\n\t\treturn ret;\n\n\tif (intel_cdclk_need_serialize(dev_priv, old_cdclk_state, new_cdclk_state)) {\n\t\t \n\t\tret = intel_atomic_serialize_global_state(&new_cdclk_state->base);\n\t\tif (ret)\n\t\t\treturn ret;\n\t} else if (old_cdclk_state->active_pipes != new_cdclk_state->active_pipes ||\n\t\t   old_cdclk_state->force_min_cdclk != new_cdclk_state->force_min_cdclk ||\n\t\t   intel_cdclk_changed(&old_cdclk_state->logical,\n\t\t\t\t       &new_cdclk_state->logical)) {\n\t\tret = intel_atomic_lock_global_state(&new_cdclk_state->base);\n\t\tif (ret)\n\t\t\treturn ret;\n\t} else {\n\t\treturn 0;\n\t}\n\n\tif (is_power_of_2(new_cdclk_state->active_pipes) &&\n\t    intel_cdclk_can_cd2x_update(dev_priv,\n\t\t\t\t\t&old_cdclk_state->actual,\n\t\t\t\t\t&new_cdclk_state->actual)) {\n\t\tstruct intel_crtc *crtc;\n\t\tstruct intel_crtc_state *crtc_state;\n\n\t\tpipe = ilog2(new_cdclk_state->active_pipes);\n\t\tcrtc = intel_crtc_for_pipe(dev_priv, pipe);\n\n\t\tcrtc_state = intel_atomic_get_crtc_state(&state->base, crtc);\n\t\tif (IS_ERR(crtc_state))\n\t\t\treturn PTR_ERR(crtc_state);\n\n\t\tif (intel_crtc_needs_modeset(crtc_state))\n\t\t\tpipe = INVALID_PIPE;\n\t}\n\n\tif (intel_cdclk_can_crawl_and_squash(dev_priv,\n\t\t\t\t\t     &old_cdclk_state->actual,\n\t\t\t\t\t     &new_cdclk_state->actual)) {\n\t\tdrm_dbg_kms(&dev_priv->drm,\n\t\t\t    \"Can change cdclk via crawling and squashing\\n\");\n\t} else if (intel_cdclk_can_squash(dev_priv,\n\t\t\t\t\t&old_cdclk_state->actual,\n\t\t\t\t\t&new_cdclk_state->actual)) {\n\t\tdrm_dbg_kms(&dev_priv->drm,\n\t\t\t    \"Can change cdclk via squashing\\n\");\n\t} else if (intel_cdclk_can_crawl(dev_priv,\n\t\t\t\t\t &old_cdclk_state->actual,\n\t\t\t\t\t &new_cdclk_state->actual)) {\n\t\tdrm_dbg_kms(&dev_priv->drm,\n\t\t\t    \"Can change cdclk via crawling\\n\");\n\t} else if (pipe != INVALID_PIPE) {\n\t\tnew_cdclk_state->pipe = pipe;\n\n\t\tdrm_dbg_kms(&dev_priv->drm,\n\t\t\t    \"Can change cdclk cd2x divider with pipe %c active\\n\",\n\t\t\t    pipe_name(pipe));\n\t} else if (intel_cdclk_needs_modeset(&old_cdclk_state->actual,\n\t\t\t\t\t     &new_cdclk_state->actual)) {\n\t\t \n\t\tret = intel_modeset_all_pipes(state, \"CDCLK change\");\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tdrm_dbg_kms(&dev_priv->drm,\n\t\t\t    \"Modeset required for cdclk change\\n\");\n\t}\n\n\tdrm_dbg_kms(&dev_priv->drm,\n\t\t    \"New cdclk calculated to be logical %u kHz, actual %u kHz\\n\",\n\t\t    new_cdclk_state->logical.cdclk,\n\t\t    new_cdclk_state->actual.cdclk);\n\tdrm_dbg_kms(&dev_priv->drm,\n\t\t    \"New voltage level calculated to be logical %u, actual %u\\n\",\n\t\t    new_cdclk_state->logical.voltage_level,\n\t\t    new_cdclk_state->actual.voltage_level);\n\n\treturn 0;\n}\n\nstatic int intel_compute_max_dotclk(struct drm_i915_private *dev_priv)\n{\n\tint max_cdclk_freq = dev_priv->display.cdclk.max_cdclk_freq;\n\n\tif (DISPLAY_VER(dev_priv) >= 10)\n\t\treturn 2 * max_cdclk_freq;\n\telse if (DISPLAY_VER(dev_priv) == 9 ||\n\t\t IS_BROADWELL(dev_priv) || IS_HASWELL(dev_priv))\n\t\treturn max_cdclk_freq;\n\telse if (IS_CHERRYVIEW(dev_priv))\n\t\treturn max_cdclk_freq*95/100;\n\telse if (DISPLAY_VER(dev_priv) < 4)\n\t\treturn 2*max_cdclk_freq*90/100;\n\telse\n\t\treturn max_cdclk_freq*90/100;\n}\n\n \nvoid intel_update_max_cdclk(struct drm_i915_private *dev_priv)\n{\n\tif (IS_JASPERLAKE(dev_priv) || IS_ELKHARTLAKE(dev_priv)) {\n\t\tif (dev_priv->display.cdclk.hw.ref == 24000)\n\t\t\tdev_priv->display.cdclk.max_cdclk_freq = 552000;\n\t\telse\n\t\t\tdev_priv->display.cdclk.max_cdclk_freq = 556800;\n\t} else if (DISPLAY_VER(dev_priv) >= 11) {\n\t\tif (dev_priv->display.cdclk.hw.ref == 24000)\n\t\t\tdev_priv->display.cdclk.max_cdclk_freq = 648000;\n\t\telse\n\t\t\tdev_priv->display.cdclk.max_cdclk_freq = 652800;\n\t} else if (IS_GEMINILAKE(dev_priv)) {\n\t\tdev_priv->display.cdclk.max_cdclk_freq = 316800;\n\t} else if (IS_BROXTON(dev_priv)) {\n\t\tdev_priv->display.cdclk.max_cdclk_freq = 624000;\n\t} else if (DISPLAY_VER(dev_priv) == 9) {\n\t\tu32 limit = intel_de_read(dev_priv, SKL_DFSM) & SKL_DFSM_CDCLK_LIMIT_MASK;\n\t\tint max_cdclk, vco;\n\n\t\tvco = dev_priv->skl_preferred_vco_freq;\n\t\tdrm_WARN_ON(&dev_priv->drm, vco != 8100000 && vco != 8640000);\n\n\t\t \n\t\tif (limit == SKL_DFSM_CDCLK_LIMIT_675)\n\t\t\tmax_cdclk = 617143;\n\t\telse if (limit == SKL_DFSM_CDCLK_LIMIT_540)\n\t\t\tmax_cdclk = 540000;\n\t\telse if (limit == SKL_DFSM_CDCLK_LIMIT_450)\n\t\t\tmax_cdclk = 432000;\n\t\telse\n\t\t\tmax_cdclk = 308571;\n\n\t\tdev_priv->display.cdclk.max_cdclk_freq = skl_calc_cdclk(max_cdclk, vco);\n\t} else if (IS_BROADWELL(dev_priv))  {\n\t\t \n\t\tif (intel_de_read(dev_priv, FUSE_STRAP) & HSW_CDCLK_LIMIT)\n\t\t\tdev_priv->display.cdclk.max_cdclk_freq = 450000;\n\t\telse if (IS_BROADWELL_ULX(dev_priv))\n\t\t\tdev_priv->display.cdclk.max_cdclk_freq = 450000;\n\t\telse if (IS_BROADWELL_ULT(dev_priv))\n\t\t\tdev_priv->display.cdclk.max_cdclk_freq = 540000;\n\t\telse\n\t\t\tdev_priv->display.cdclk.max_cdclk_freq = 675000;\n\t} else if (IS_CHERRYVIEW(dev_priv)) {\n\t\tdev_priv->display.cdclk.max_cdclk_freq = 320000;\n\t} else if (IS_VALLEYVIEW(dev_priv)) {\n\t\tdev_priv->display.cdclk.max_cdclk_freq = 400000;\n\t} else {\n\t\t \n\t\tdev_priv->display.cdclk.max_cdclk_freq = dev_priv->display.cdclk.hw.cdclk;\n\t}\n\n\tdev_priv->max_dotclk_freq = intel_compute_max_dotclk(dev_priv);\n\n\tdrm_dbg(&dev_priv->drm, \"Max CD clock rate: %d kHz\\n\",\n\t\tdev_priv->display.cdclk.max_cdclk_freq);\n\n\tdrm_dbg(&dev_priv->drm, \"Max dotclock rate: %d kHz\\n\",\n\t\tdev_priv->max_dotclk_freq);\n}\n\n \nvoid intel_update_cdclk(struct drm_i915_private *dev_priv)\n{\n\tintel_cdclk_get_cdclk(dev_priv, &dev_priv->display.cdclk.hw);\n\n\t \n\tif (IS_VALLEYVIEW(dev_priv) || IS_CHERRYVIEW(dev_priv))\n\t\tintel_de_write(dev_priv, GMBUSFREQ_VLV,\n\t\t\t       DIV_ROUND_UP(dev_priv->display.cdclk.hw.cdclk, 1000));\n}\n\nstatic int dg1_rawclk(struct drm_i915_private *dev_priv)\n{\n\t \n\tintel_de_write(dev_priv, PCH_RAWCLK_FREQ,\n\t\t       CNP_RAWCLK_DEN(4) | CNP_RAWCLK_DIV(37) | ICP_RAWCLK_NUM(2));\n\n\treturn 38400;\n}\n\nstatic int cnp_rawclk(struct drm_i915_private *dev_priv)\n{\n\tu32 rawclk;\n\tint divider, fraction;\n\n\tif (intel_de_read(dev_priv, SFUSE_STRAP) & SFUSE_STRAP_RAW_FREQUENCY) {\n\t\t \n\t\tdivider = 24000;\n\t\tfraction = 0;\n\t} else {\n\t\t \n\t\tdivider = 19000;\n\t\tfraction = 200;\n\t}\n\n\trawclk = CNP_RAWCLK_DIV(divider / 1000);\n\tif (fraction) {\n\t\tint numerator = 1;\n\n\t\trawclk |= CNP_RAWCLK_DEN(DIV_ROUND_CLOSEST(numerator * 1000,\n\t\t\t\t\t\t\t   fraction) - 1);\n\t\tif (INTEL_PCH_TYPE(dev_priv) >= PCH_ICP)\n\t\t\trawclk |= ICP_RAWCLK_NUM(numerator);\n\t}\n\n\tintel_de_write(dev_priv, PCH_RAWCLK_FREQ, rawclk);\n\treturn divider + fraction;\n}\n\nstatic int pch_rawclk(struct drm_i915_private *dev_priv)\n{\n\treturn (intel_de_read(dev_priv, PCH_RAWCLK_FREQ) & RAWCLK_FREQ_MASK) * 1000;\n}\n\nstatic int vlv_hrawclk(struct drm_i915_private *dev_priv)\n{\n\t \n\treturn vlv_get_cck_clock_hpll(dev_priv, \"hrawclk\",\n\t\t\t\t      CCK_DISPLAY_REF_CLOCK_CONTROL);\n}\n\nstatic int i9xx_hrawclk(struct drm_i915_private *dev_priv)\n{\n\tu32 clkcfg;\n\n\t \n\tclkcfg = intel_de_read(dev_priv, CLKCFG) & CLKCFG_FSB_MASK;\n\n\tif (IS_MOBILE(dev_priv)) {\n\t\tswitch (clkcfg) {\n\t\tcase CLKCFG_FSB_400:\n\t\t\treturn 100000;\n\t\tcase CLKCFG_FSB_533:\n\t\t\treturn 133333;\n\t\tcase CLKCFG_FSB_667:\n\t\t\treturn 166667;\n\t\tcase CLKCFG_FSB_800:\n\t\t\treturn 200000;\n\t\tcase CLKCFG_FSB_1067:\n\t\t\treturn 266667;\n\t\tcase CLKCFG_FSB_1333:\n\t\t\treturn 333333;\n\t\tdefault:\n\t\t\tMISSING_CASE(clkcfg);\n\t\t\treturn 133333;\n\t\t}\n\t} else {\n\t\tswitch (clkcfg) {\n\t\tcase CLKCFG_FSB_400_ALT:\n\t\t\treturn 100000;\n\t\tcase CLKCFG_FSB_533:\n\t\t\treturn 133333;\n\t\tcase CLKCFG_FSB_667:\n\t\t\treturn 166667;\n\t\tcase CLKCFG_FSB_800:\n\t\t\treturn 200000;\n\t\tcase CLKCFG_FSB_1067_ALT:\n\t\t\treturn 266667;\n\t\tcase CLKCFG_FSB_1333_ALT:\n\t\t\treturn 333333;\n\t\tcase CLKCFG_FSB_1600_ALT:\n\t\t\treturn 400000;\n\t\tdefault:\n\t\t\treturn 133333;\n\t\t}\n\t}\n}\n\n \nu32 intel_read_rawclk(struct drm_i915_private *dev_priv)\n{\n\tu32 freq;\n\n\tif (INTEL_PCH_TYPE(dev_priv) >= PCH_DG1)\n\t\tfreq = dg1_rawclk(dev_priv);\n\telse if (INTEL_PCH_TYPE(dev_priv) >= PCH_MTP)\n\t\t \n\t\tfreq = 38400;\n\telse if (INTEL_PCH_TYPE(dev_priv) >= PCH_CNP)\n\t\tfreq = cnp_rawclk(dev_priv);\n\telse if (HAS_PCH_SPLIT(dev_priv))\n\t\tfreq = pch_rawclk(dev_priv);\n\telse if (IS_VALLEYVIEW(dev_priv) || IS_CHERRYVIEW(dev_priv))\n\t\tfreq = vlv_hrawclk(dev_priv);\n\telse if (DISPLAY_VER(dev_priv) >= 3)\n\t\tfreq = i9xx_hrawclk(dev_priv);\n\telse\n\t\t \n\t\treturn 0;\n\n\treturn freq;\n}\n\nstatic int i915_cdclk_info_show(struct seq_file *m, void *unused)\n{\n\tstruct drm_i915_private *i915 = m->private;\n\n\tseq_printf(m, \"Current CD clock frequency: %d kHz\\n\", i915->display.cdclk.hw.cdclk);\n\tseq_printf(m, \"Max CD clock frequency: %d kHz\\n\", i915->display.cdclk.max_cdclk_freq);\n\tseq_printf(m, \"Max pixel clock frequency: %d kHz\\n\", i915->max_dotclk_freq);\n\n\treturn 0;\n}\n\nDEFINE_SHOW_ATTRIBUTE(i915_cdclk_info);\n\nvoid intel_cdclk_debugfs_register(struct drm_i915_private *i915)\n{\n\tstruct drm_minor *minor = i915->drm.primary;\n\n\tdebugfs_create_file(\"i915_cdclk_info\", 0444, minor->debugfs_root,\n\t\t\t    i915, &i915_cdclk_info_fops);\n}\n\nstatic const struct intel_cdclk_funcs mtl_cdclk_funcs = {\n\t.get_cdclk = bxt_get_cdclk,\n\t.set_cdclk = bxt_set_cdclk,\n\t.modeset_calc_cdclk = bxt_modeset_calc_cdclk,\n\t.calc_voltage_level = tgl_calc_voltage_level,\n};\n\nstatic const struct intel_cdclk_funcs rplu_cdclk_funcs = {\n\t.get_cdclk = bxt_get_cdclk,\n\t.set_cdclk = bxt_set_cdclk,\n\t.modeset_calc_cdclk = bxt_modeset_calc_cdclk,\n\t.calc_voltage_level = rplu_calc_voltage_level,\n};\n\nstatic const struct intel_cdclk_funcs tgl_cdclk_funcs = {\n\t.get_cdclk = bxt_get_cdclk,\n\t.set_cdclk = bxt_set_cdclk,\n\t.modeset_calc_cdclk = bxt_modeset_calc_cdclk,\n\t.calc_voltage_level = tgl_calc_voltage_level,\n};\n\nstatic const struct intel_cdclk_funcs ehl_cdclk_funcs = {\n\t.get_cdclk = bxt_get_cdclk,\n\t.set_cdclk = bxt_set_cdclk,\n\t.modeset_calc_cdclk = bxt_modeset_calc_cdclk,\n\t.calc_voltage_level = ehl_calc_voltage_level,\n};\n\nstatic const struct intel_cdclk_funcs icl_cdclk_funcs = {\n\t.get_cdclk = bxt_get_cdclk,\n\t.set_cdclk = bxt_set_cdclk,\n\t.modeset_calc_cdclk = bxt_modeset_calc_cdclk,\n\t.calc_voltage_level = icl_calc_voltage_level,\n};\n\nstatic const struct intel_cdclk_funcs bxt_cdclk_funcs = {\n\t.get_cdclk = bxt_get_cdclk,\n\t.set_cdclk = bxt_set_cdclk,\n\t.modeset_calc_cdclk = bxt_modeset_calc_cdclk,\n\t.calc_voltage_level = bxt_calc_voltage_level,\n};\n\nstatic const struct intel_cdclk_funcs skl_cdclk_funcs = {\n\t.get_cdclk = skl_get_cdclk,\n\t.set_cdclk = skl_set_cdclk,\n\t.modeset_calc_cdclk = skl_modeset_calc_cdclk,\n};\n\nstatic const struct intel_cdclk_funcs bdw_cdclk_funcs = {\n\t.get_cdclk = bdw_get_cdclk,\n\t.set_cdclk = bdw_set_cdclk,\n\t.modeset_calc_cdclk = bdw_modeset_calc_cdclk,\n};\n\nstatic const struct intel_cdclk_funcs chv_cdclk_funcs = {\n\t.get_cdclk = vlv_get_cdclk,\n\t.set_cdclk = chv_set_cdclk,\n\t.modeset_calc_cdclk = vlv_modeset_calc_cdclk,\n};\n\nstatic const struct intel_cdclk_funcs vlv_cdclk_funcs = {\n\t.get_cdclk = vlv_get_cdclk,\n\t.set_cdclk = vlv_set_cdclk,\n\t.modeset_calc_cdclk = vlv_modeset_calc_cdclk,\n};\n\nstatic const struct intel_cdclk_funcs hsw_cdclk_funcs = {\n\t.get_cdclk = hsw_get_cdclk,\n\t.modeset_calc_cdclk = fixed_modeset_calc_cdclk,\n};\n\n \nstatic const struct intel_cdclk_funcs fixed_400mhz_cdclk_funcs = {\n\t.get_cdclk = fixed_400mhz_get_cdclk,\n\t.modeset_calc_cdclk = fixed_modeset_calc_cdclk,\n};\n\nstatic const struct intel_cdclk_funcs ilk_cdclk_funcs = {\n\t.get_cdclk = fixed_450mhz_get_cdclk,\n\t.modeset_calc_cdclk = fixed_modeset_calc_cdclk,\n};\n\nstatic const struct intel_cdclk_funcs gm45_cdclk_funcs = {\n\t.get_cdclk = gm45_get_cdclk,\n\t.modeset_calc_cdclk = fixed_modeset_calc_cdclk,\n};\n\n \n\nstatic const struct intel_cdclk_funcs i965gm_cdclk_funcs = {\n\t.get_cdclk = i965gm_get_cdclk,\n\t.modeset_calc_cdclk = fixed_modeset_calc_cdclk,\n};\n\n \n\nstatic const struct intel_cdclk_funcs pnv_cdclk_funcs = {\n\t.get_cdclk = pnv_get_cdclk,\n\t.modeset_calc_cdclk = fixed_modeset_calc_cdclk,\n};\n\nstatic const struct intel_cdclk_funcs g33_cdclk_funcs = {\n\t.get_cdclk = g33_get_cdclk,\n\t.modeset_calc_cdclk = fixed_modeset_calc_cdclk,\n};\n\nstatic const struct intel_cdclk_funcs i945gm_cdclk_funcs = {\n\t.get_cdclk = i945gm_get_cdclk,\n\t.modeset_calc_cdclk = fixed_modeset_calc_cdclk,\n};\n\n \n\nstatic const struct intel_cdclk_funcs i915gm_cdclk_funcs = {\n\t.get_cdclk = i915gm_get_cdclk,\n\t.modeset_calc_cdclk = fixed_modeset_calc_cdclk,\n};\n\nstatic const struct intel_cdclk_funcs i915g_cdclk_funcs = {\n\t.get_cdclk = fixed_333mhz_get_cdclk,\n\t.modeset_calc_cdclk = fixed_modeset_calc_cdclk,\n};\n\nstatic const struct intel_cdclk_funcs i865g_cdclk_funcs = {\n\t.get_cdclk = fixed_266mhz_get_cdclk,\n\t.modeset_calc_cdclk = fixed_modeset_calc_cdclk,\n};\n\nstatic const struct intel_cdclk_funcs i85x_cdclk_funcs = {\n\t.get_cdclk = i85x_get_cdclk,\n\t.modeset_calc_cdclk = fixed_modeset_calc_cdclk,\n};\n\nstatic const struct intel_cdclk_funcs i845g_cdclk_funcs = {\n\t.get_cdclk = fixed_200mhz_get_cdclk,\n\t.modeset_calc_cdclk = fixed_modeset_calc_cdclk,\n};\n\nstatic const struct intel_cdclk_funcs i830_cdclk_funcs = {\n\t.get_cdclk = fixed_133mhz_get_cdclk,\n\t.modeset_calc_cdclk = fixed_modeset_calc_cdclk,\n};\n\n \nvoid intel_init_cdclk_hooks(struct drm_i915_private *dev_priv)\n{\n\tif (IS_METEORLAKE(dev_priv)) {\n\t\tdev_priv->display.funcs.cdclk = &mtl_cdclk_funcs;\n\t\tdev_priv->display.cdclk.table = mtl_cdclk_table;\n\t} else if (IS_DG2(dev_priv)) {\n\t\tdev_priv->display.funcs.cdclk = &tgl_cdclk_funcs;\n\t\tdev_priv->display.cdclk.table = dg2_cdclk_table;\n\t} else if (IS_ALDERLAKE_P(dev_priv)) {\n\t\t \n\t\tif (IS_ALDERLAKE_P(dev_priv) && IS_DISPLAY_STEP(dev_priv, STEP_A0, STEP_B0)) {\n\t\t\tdev_priv->display.cdclk.table = adlp_a_step_cdclk_table;\n\t\t\tdev_priv->display.funcs.cdclk = &tgl_cdclk_funcs;\n\t\t} else if (IS_RAPTORLAKE_U(dev_priv)) {\n\t\t\tdev_priv->display.cdclk.table = rplu_cdclk_table;\n\t\t\tdev_priv->display.funcs.cdclk = &rplu_cdclk_funcs;\n\t\t} else {\n\t\t\tdev_priv->display.cdclk.table = adlp_cdclk_table;\n\t\t\tdev_priv->display.funcs.cdclk = &tgl_cdclk_funcs;\n\t\t}\n\t} else if (IS_ROCKETLAKE(dev_priv)) {\n\t\tdev_priv->display.funcs.cdclk = &tgl_cdclk_funcs;\n\t\tdev_priv->display.cdclk.table = rkl_cdclk_table;\n\t} else if (DISPLAY_VER(dev_priv) >= 12) {\n\t\tdev_priv->display.funcs.cdclk = &tgl_cdclk_funcs;\n\t\tdev_priv->display.cdclk.table = icl_cdclk_table;\n\t} else if (IS_JASPERLAKE(dev_priv) || IS_ELKHARTLAKE(dev_priv)) {\n\t\tdev_priv->display.funcs.cdclk = &ehl_cdclk_funcs;\n\t\tdev_priv->display.cdclk.table = icl_cdclk_table;\n\t} else if (DISPLAY_VER(dev_priv) >= 11) {\n\t\tdev_priv->display.funcs.cdclk = &icl_cdclk_funcs;\n\t\tdev_priv->display.cdclk.table = icl_cdclk_table;\n\t} else if (IS_GEMINILAKE(dev_priv) || IS_BROXTON(dev_priv)) {\n\t\tdev_priv->display.funcs.cdclk = &bxt_cdclk_funcs;\n\t\tif (IS_GEMINILAKE(dev_priv))\n\t\t\tdev_priv->display.cdclk.table = glk_cdclk_table;\n\t\telse\n\t\t\tdev_priv->display.cdclk.table = bxt_cdclk_table;\n\t} else if (DISPLAY_VER(dev_priv) == 9) {\n\t\tdev_priv->display.funcs.cdclk = &skl_cdclk_funcs;\n\t} else if (IS_BROADWELL(dev_priv)) {\n\t\tdev_priv->display.funcs.cdclk = &bdw_cdclk_funcs;\n\t} else if (IS_HASWELL(dev_priv)) {\n\t\tdev_priv->display.funcs.cdclk = &hsw_cdclk_funcs;\n\t} else if (IS_CHERRYVIEW(dev_priv)) {\n\t\tdev_priv->display.funcs.cdclk = &chv_cdclk_funcs;\n\t} else if (IS_VALLEYVIEW(dev_priv)) {\n\t\tdev_priv->display.funcs.cdclk = &vlv_cdclk_funcs;\n\t} else if (IS_SANDYBRIDGE(dev_priv) || IS_IVYBRIDGE(dev_priv)) {\n\t\tdev_priv->display.funcs.cdclk = &fixed_400mhz_cdclk_funcs;\n\t} else if (IS_IRONLAKE(dev_priv)) {\n\t\tdev_priv->display.funcs.cdclk = &ilk_cdclk_funcs;\n\t} else if (IS_GM45(dev_priv)) {\n\t\tdev_priv->display.funcs.cdclk = &gm45_cdclk_funcs;\n\t} else if (IS_G45(dev_priv)) {\n\t\tdev_priv->display.funcs.cdclk = &g33_cdclk_funcs;\n\t} else if (IS_I965GM(dev_priv)) {\n\t\tdev_priv->display.funcs.cdclk = &i965gm_cdclk_funcs;\n\t} else if (IS_I965G(dev_priv)) {\n\t\tdev_priv->display.funcs.cdclk = &fixed_400mhz_cdclk_funcs;\n\t} else if (IS_PINEVIEW(dev_priv)) {\n\t\tdev_priv->display.funcs.cdclk = &pnv_cdclk_funcs;\n\t} else if (IS_G33(dev_priv)) {\n\t\tdev_priv->display.funcs.cdclk = &g33_cdclk_funcs;\n\t} else if (IS_I945GM(dev_priv)) {\n\t\tdev_priv->display.funcs.cdclk = &i945gm_cdclk_funcs;\n\t} else if (IS_I945G(dev_priv)) {\n\t\tdev_priv->display.funcs.cdclk = &fixed_400mhz_cdclk_funcs;\n\t} else if (IS_I915GM(dev_priv)) {\n\t\tdev_priv->display.funcs.cdclk = &i915gm_cdclk_funcs;\n\t} else if (IS_I915G(dev_priv)) {\n\t\tdev_priv->display.funcs.cdclk = &i915g_cdclk_funcs;\n\t} else if (IS_I865G(dev_priv)) {\n\t\tdev_priv->display.funcs.cdclk = &i865g_cdclk_funcs;\n\t} else if (IS_I85X(dev_priv)) {\n\t\tdev_priv->display.funcs.cdclk = &i85x_cdclk_funcs;\n\t} else if (IS_I845G(dev_priv)) {\n\t\tdev_priv->display.funcs.cdclk = &i845g_cdclk_funcs;\n\t} else if (IS_I830(dev_priv)) {\n\t\tdev_priv->display.funcs.cdclk = &i830_cdclk_funcs;\n\t}\n\n\tif (drm_WARN(&dev_priv->drm, !dev_priv->display.funcs.cdclk,\n\t\t     \"Unknown platform. Assuming i830\\n\"))\n\t\tdev_priv->display.funcs.cdclk = &i830_cdclk_funcs;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}