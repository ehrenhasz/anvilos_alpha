{
  "module_name": "intel_sdvo.c",
  "hash_id": "ab197e4a0bdbede3a93404d447969a417f8373cd3f83af450f25320cf0044f07",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/i915/display/intel_sdvo.c",
  "human_readable_source": " \n\n#include <linux/delay.h>\n#include <linux/export.h>\n#include <linux/i2c.h>\n#include <linux/slab.h>\n\n#include <drm/display/drm_hdmi_helper.h>\n#include <drm/drm_atomic_helper.h>\n#include <drm/drm_crtc.h>\n#include <drm/drm_edid.h>\n\n#include \"i915_drv.h\"\n#include \"i915_reg.h\"\n#include \"intel_atomic.h\"\n#include \"intel_audio.h\"\n#include \"intel_connector.h\"\n#include \"intel_crtc.h\"\n#include \"intel_de.h\"\n#include \"intel_display_types.h\"\n#include \"intel_fifo_underrun.h\"\n#include \"intel_gmbus.h\"\n#include \"intel_hdmi.h\"\n#include \"intel_hotplug.h\"\n#include \"intel_panel.h\"\n#include \"intel_sdvo.h\"\n#include \"intel_sdvo_regs.h\"\n\n#define SDVO_TMDS_MASK (SDVO_OUTPUT_TMDS0 | SDVO_OUTPUT_TMDS1)\n#define SDVO_RGB_MASK  (SDVO_OUTPUT_RGB0 | SDVO_OUTPUT_RGB1)\n#define SDVO_LVDS_MASK (SDVO_OUTPUT_LVDS0 | SDVO_OUTPUT_LVDS1)\n#define SDVO_TV_MASK   (SDVO_OUTPUT_CVBS0 | SDVO_OUTPUT_SVID0 | SDVO_OUTPUT_YPRPB0)\n\n#define SDVO_OUTPUT_MASK (SDVO_TMDS_MASK | SDVO_RGB_MASK | SDVO_LVDS_MASK |\\\n\t\t\tSDVO_TV_MASK)\n\n#define IS_TV(c)\t(c->output_flag & SDVO_TV_MASK)\n#define IS_TMDS(c)\t(c->output_flag & SDVO_TMDS_MASK)\n#define IS_LVDS(c)\t(c->output_flag & SDVO_LVDS_MASK)\n#define IS_TV_OR_LVDS(c) (c->output_flag & (SDVO_TV_MASK | SDVO_LVDS_MASK))\n#define IS_DIGITAL(c) (c->output_flag & (SDVO_TMDS_MASK | SDVO_LVDS_MASK))\n\n\nstatic const char * const tv_format_names[] = {\n\t\"NTSC_M\"   , \"NTSC_J\"  , \"NTSC_443\",\n\t\"PAL_B\"    , \"PAL_D\"   , \"PAL_G\"   ,\n\t\"PAL_H\"    , \"PAL_I\"   , \"PAL_M\"   ,\n\t\"PAL_N\"    , \"PAL_NC\"  , \"PAL_60\"  ,\n\t\"SECAM_B\"  , \"SECAM_D\" , \"SECAM_G\" ,\n\t\"SECAM_K\"  , \"SECAM_K1\", \"SECAM_L\" ,\n\t\"SECAM_60\"\n};\n\n#define TV_FORMAT_NUM  ARRAY_SIZE(tv_format_names)\n\nstruct intel_sdvo {\n\tstruct intel_encoder base;\n\n\tstruct i2c_adapter *i2c;\n\tu8 slave_addr;\n\n\tstruct i2c_adapter ddc;\n\n\t \n\ti915_reg_t sdvo_reg;\n\n\t \n\tu16 controlled_output;\n\n\t \n\tstruct intel_sdvo_caps caps;\n\n\tu8 colorimetry_cap;\n\n\t \n\tint pixel_clock_min, pixel_clock_max;\n\n\t \n\tu16 attached_output;\n\n\t \n\tu16 hotplug_active;\n\n\tenum port port;\n\n\t \n\tu8 ddc_bus;\n\n\t \n\tu8 dtd_sdvo_flags;\n};\n\nstruct intel_sdvo_connector {\n\tstruct intel_connector base;\n\n\t \n\tu16 output_flag;\n\n\t \n\tu8 tv_format_supported[TV_FORMAT_NUM];\n\tint   format_supported_num;\n\tstruct drm_property *tv_format;\n\n\t \n\tstruct drm_property *left;\n\tstruct drm_property *right;\n\tstruct drm_property *top;\n\tstruct drm_property *bottom;\n\tstruct drm_property *hpos;\n\tstruct drm_property *vpos;\n\tstruct drm_property *contrast;\n\tstruct drm_property *saturation;\n\tstruct drm_property *hue;\n\tstruct drm_property *sharpness;\n\tstruct drm_property *flicker_filter;\n\tstruct drm_property *flicker_filter_adaptive;\n\tstruct drm_property *flicker_filter_2d;\n\tstruct drm_property *tv_chroma_filter;\n\tstruct drm_property *tv_luma_filter;\n\tstruct drm_property *dot_crawl;\n\n\t \n\tstruct drm_property *brightness;\n\n\t \n\tu32 max_hscan, max_vscan;\n\n\t \n\tbool is_hdmi;\n};\n\nstruct intel_sdvo_connector_state {\n\t \n\tstruct intel_digital_connector_state base;\n\n\tstruct {\n\t\tunsigned overscan_h, overscan_v, hpos, vpos, sharpness;\n\t\tunsigned flicker_filter, flicker_filter_2d, flicker_filter_adaptive;\n\t\tunsigned chroma_filter, luma_filter, dot_crawl;\n\t} tv;\n};\n\nstatic struct intel_sdvo *to_sdvo(struct intel_encoder *encoder)\n{\n\treturn container_of(encoder, struct intel_sdvo, base);\n}\n\nstatic struct intel_sdvo *intel_attached_sdvo(struct intel_connector *connector)\n{\n\treturn to_sdvo(intel_attached_encoder(connector));\n}\n\nstatic struct intel_sdvo_connector *\nto_intel_sdvo_connector(struct drm_connector *connector)\n{\n\treturn container_of(connector, struct intel_sdvo_connector, base.base);\n}\n\n#define to_intel_sdvo_connector_state(conn_state) \\\n\tcontainer_of((conn_state), struct intel_sdvo_connector_state, base.base)\n\nstatic bool\nintel_sdvo_output_setup(struct intel_sdvo *intel_sdvo);\nstatic bool\nintel_sdvo_tv_create_property(struct intel_sdvo *intel_sdvo,\n\t\t\t      struct intel_sdvo_connector *intel_sdvo_connector,\n\t\t\t      int type);\nstatic bool\nintel_sdvo_create_enhance_property(struct intel_sdvo *intel_sdvo,\n\t\t\t\t   struct intel_sdvo_connector *intel_sdvo_connector);\n\n \nstatic void intel_sdvo_write_sdvox(struct intel_sdvo *intel_sdvo, u32 val)\n{\n\tstruct drm_device *dev = intel_sdvo->base.base.dev;\n\tstruct drm_i915_private *dev_priv = to_i915(dev);\n\tu32 bval = val, cval = val;\n\tint i;\n\n\tif (HAS_PCH_SPLIT(dev_priv)) {\n\t\tintel_de_write(dev_priv, intel_sdvo->sdvo_reg, val);\n\t\tintel_de_posting_read(dev_priv, intel_sdvo->sdvo_reg);\n\t\t \n\t\tif (HAS_PCH_IBX(dev_priv)) {\n\t\t\tintel_de_write(dev_priv, intel_sdvo->sdvo_reg, val);\n\t\t\tintel_de_posting_read(dev_priv, intel_sdvo->sdvo_reg);\n\t\t}\n\t\treturn;\n\t}\n\n\tif (intel_sdvo->port == PORT_B)\n\t\tcval = intel_de_read(dev_priv, GEN3_SDVOC);\n\telse\n\t\tbval = intel_de_read(dev_priv, GEN3_SDVOB);\n\n\t \n\tfor (i = 0; i < 2; i++) {\n\t\tintel_de_write(dev_priv, GEN3_SDVOB, bval);\n\t\tintel_de_posting_read(dev_priv, GEN3_SDVOB);\n\n\t\tintel_de_write(dev_priv, GEN3_SDVOC, cval);\n\t\tintel_de_posting_read(dev_priv, GEN3_SDVOC);\n\t}\n}\n\nstatic bool intel_sdvo_read_byte(struct intel_sdvo *intel_sdvo, u8 addr, u8 *ch)\n{\n\tstruct i2c_msg msgs[] = {\n\t\t{\n\t\t\t.addr = intel_sdvo->slave_addr,\n\t\t\t.flags = 0,\n\t\t\t.len = 1,\n\t\t\t.buf = &addr,\n\t\t},\n\t\t{\n\t\t\t.addr = intel_sdvo->slave_addr,\n\t\t\t.flags = I2C_M_RD,\n\t\t\t.len = 1,\n\t\t\t.buf = ch,\n\t\t}\n\t};\n\tint ret;\n\n\tif ((ret = i2c_transfer(intel_sdvo->i2c, msgs, 2)) == 2)\n\t\treturn true;\n\n\tDRM_DEBUG_KMS(\"i2c transfer returned %d\\n\", ret);\n\treturn false;\n}\n\n#define SDVO_CMD_NAME_ENTRY(cmd_) { .cmd = SDVO_CMD_ ## cmd_, .name = #cmd_ }\n\n \nstatic const struct {\n\tu8 cmd;\n\tconst char *name;\n} __packed sdvo_cmd_names[] = {\n\tSDVO_CMD_NAME_ENTRY(RESET),\n\tSDVO_CMD_NAME_ENTRY(GET_DEVICE_CAPS),\n\tSDVO_CMD_NAME_ENTRY(GET_FIRMWARE_REV),\n\tSDVO_CMD_NAME_ENTRY(GET_TRAINED_INPUTS),\n\tSDVO_CMD_NAME_ENTRY(GET_ACTIVE_OUTPUTS),\n\tSDVO_CMD_NAME_ENTRY(SET_ACTIVE_OUTPUTS),\n\tSDVO_CMD_NAME_ENTRY(GET_IN_OUT_MAP),\n\tSDVO_CMD_NAME_ENTRY(SET_IN_OUT_MAP),\n\tSDVO_CMD_NAME_ENTRY(GET_ATTACHED_DISPLAYS),\n\tSDVO_CMD_NAME_ENTRY(GET_HOT_PLUG_SUPPORT),\n\tSDVO_CMD_NAME_ENTRY(SET_ACTIVE_HOT_PLUG),\n\tSDVO_CMD_NAME_ENTRY(GET_ACTIVE_HOT_PLUG),\n\tSDVO_CMD_NAME_ENTRY(GET_INTERRUPT_EVENT_SOURCE),\n\tSDVO_CMD_NAME_ENTRY(SET_TARGET_INPUT),\n\tSDVO_CMD_NAME_ENTRY(SET_TARGET_OUTPUT),\n\tSDVO_CMD_NAME_ENTRY(GET_INPUT_TIMINGS_PART1),\n\tSDVO_CMD_NAME_ENTRY(GET_INPUT_TIMINGS_PART2),\n\tSDVO_CMD_NAME_ENTRY(SET_INPUT_TIMINGS_PART1),\n\tSDVO_CMD_NAME_ENTRY(SET_INPUT_TIMINGS_PART2),\n\tSDVO_CMD_NAME_ENTRY(SET_OUTPUT_TIMINGS_PART1),\n\tSDVO_CMD_NAME_ENTRY(SET_OUTPUT_TIMINGS_PART2),\n\tSDVO_CMD_NAME_ENTRY(GET_OUTPUT_TIMINGS_PART1),\n\tSDVO_CMD_NAME_ENTRY(GET_OUTPUT_TIMINGS_PART2),\n\tSDVO_CMD_NAME_ENTRY(CREATE_PREFERRED_INPUT_TIMING),\n\tSDVO_CMD_NAME_ENTRY(GET_PREFERRED_INPUT_TIMING_PART1),\n\tSDVO_CMD_NAME_ENTRY(GET_PREFERRED_INPUT_TIMING_PART2),\n\tSDVO_CMD_NAME_ENTRY(GET_INPUT_PIXEL_CLOCK_RANGE),\n\tSDVO_CMD_NAME_ENTRY(GET_OUTPUT_PIXEL_CLOCK_RANGE),\n\tSDVO_CMD_NAME_ENTRY(GET_SUPPORTED_CLOCK_RATE_MULTS),\n\tSDVO_CMD_NAME_ENTRY(GET_CLOCK_RATE_MULT),\n\tSDVO_CMD_NAME_ENTRY(SET_CLOCK_RATE_MULT),\n\tSDVO_CMD_NAME_ENTRY(GET_SUPPORTED_TV_FORMATS),\n\tSDVO_CMD_NAME_ENTRY(GET_TV_FORMAT),\n\tSDVO_CMD_NAME_ENTRY(SET_TV_FORMAT),\n\tSDVO_CMD_NAME_ENTRY(GET_SUPPORTED_POWER_STATES),\n\tSDVO_CMD_NAME_ENTRY(GET_POWER_STATE),\n\tSDVO_CMD_NAME_ENTRY(SET_ENCODER_POWER_STATE),\n\tSDVO_CMD_NAME_ENTRY(SET_DISPLAY_POWER_STATE),\n\tSDVO_CMD_NAME_ENTRY(SET_CONTROL_BUS_SWITCH),\n\tSDVO_CMD_NAME_ENTRY(GET_SDTV_RESOLUTION_SUPPORT),\n\tSDVO_CMD_NAME_ENTRY(GET_SCALED_HDTV_RESOLUTION_SUPPORT),\n\tSDVO_CMD_NAME_ENTRY(GET_SUPPORTED_ENHANCEMENTS),\n\n\t \n\tSDVO_CMD_NAME_ENTRY(GET_MAX_HPOS),\n\tSDVO_CMD_NAME_ENTRY(GET_HPOS),\n\tSDVO_CMD_NAME_ENTRY(SET_HPOS),\n\tSDVO_CMD_NAME_ENTRY(GET_MAX_VPOS),\n\tSDVO_CMD_NAME_ENTRY(GET_VPOS),\n\tSDVO_CMD_NAME_ENTRY(SET_VPOS),\n\tSDVO_CMD_NAME_ENTRY(GET_MAX_SATURATION),\n\tSDVO_CMD_NAME_ENTRY(GET_SATURATION),\n\tSDVO_CMD_NAME_ENTRY(SET_SATURATION),\n\tSDVO_CMD_NAME_ENTRY(GET_MAX_HUE),\n\tSDVO_CMD_NAME_ENTRY(GET_HUE),\n\tSDVO_CMD_NAME_ENTRY(SET_HUE),\n\tSDVO_CMD_NAME_ENTRY(GET_MAX_CONTRAST),\n\tSDVO_CMD_NAME_ENTRY(GET_CONTRAST),\n\tSDVO_CMD_NAME_ENTRY(SET_CONTRAST),\n\tSDVO_CMD_NAME_ENTRY(GET_MAX_BRIGHTNESS),\n\tSDVO_CMD_NAME_ENTRY(GET_BRIGHTNESS),\n\tSDVO_CMD_NAME_ENTRY(SET_BRIGHTNESS),\n\tSDVO_CMD_NAME_ENTRY(GET_MAX_OVERSCAN_H),\n\tSDVO_CMD_NAME_ENTRY(GET_OVERSCAN_H),\n\tSDVO_CMD_NAME_ENTRY(SET_OVERSCAN_H),\n\tSDVO_CMD_NAME_ENTRY(GET_MAX_OVERSCAN_V),\n\tSDVO_CMD_NAME_ENTRY(GET_OVERSCAN_V),\n\tSDVO_CMD_NAME_ENTRY(SET_OVERSCAN_V),\n\tSDVO_CMD_NAME_ENTRY(GET_MAX_FLICKER_FILTER),\n\tSDVO_CMD_NAME_ENTRY(GET_FLICKER_FILTER),\n\tSDVO_CMD_NAME_ENTRY(SET_FLICKER_FILTER),\n\tSDVO_CMD_NAME_ENTRY(GET_MAX_FLICKER_FILTER_ADAPTIVE),\n\tSDVO_CMD_NAME_ENTRY(GET_FLICKER_FILTER_ADAPTIVE),\n\tSDVO_CMD_NAME_ENTRY(SET_FLICKER_FILTER_ADAPTIVE),\n\tSDVO_CMD_NAME_ENTRY(GET_MAX_FLICKER_FILTER_2D),\n\tSDVO_CMD_NAME_ENTRY(GET_FLICKER_FILTER_2D),\n\tSDVO_CMD_NAME_ENTRY(SET_FLICKER_FILTER_2D),\n\tSDVO_CMD_NAME_ENTRY(GET_MAX_SHARPNESS),\n\tSDVO_CMD_NAME_ENTRY(GET_SHARPNESS),\n\tSDVO_CMD_NAME_ENTRY(SET_SHARPNESS),\n\tSDVO_CMD_NAME_ENTRY(GET_DOT_CRAWL),\n\tSDVO_CMD_NAME_ENTRY(SET_DOT_CRAWL),\n\tSDVO_CMD_NAME_ENTRY(GET_MAX_TV_CHROMA_FILTER),\n\tSDVO_CMD_NAME_ENTRY(GET_TV_CHROMA_FILTER),\n\tSDVO_CMD_NAME_ENTRY(SET_TV_CHROMA_FILTER),\n\tSDVO_CMD_NAME_ENTRY(GET_MAX_TV_LUMA_FILTER),\n\tSDVO_CMD_NAME_ENTRY(GET_TV_LUMA_FILTER),\n\tSDVO_CMD_NAME_ENTRY(SET_TV_LUMA_FILTER),\n\n\t \n\tSDVO_CMD_NAME_ENTRY(GET_SUPP_ENCODE),\n\tSDVO_CMD_NAME_ENTRY(GET_ENCODE),\n\tSDVO_CMD_NAME_ENTRY(SET_ENCODE),\n\tSDVO_CMD_NAME_ENTRY(SET_PIXEL_REPLI),\n\tSDVO_CMD_NAME_ENTRY(GET_PIXEL_REPLI),\n\tSDVO_CMD_NAME_ENTRY(GET_COLORIMETRY_CAP),\n\tSDVO_CMD_NAME_ENTRY(SET_COLORIMETRY),\n\tSDVO_CMD_NAME_ENTRY(GET_COLORIMETRY),\n\tSDVO_CMD_NAME_ENTRY(GET_AUDIO_ENCRYPT_PREFER),\n\tSDVO_CMD_NAME_ENTRY(SET_AUDIO_STAT),\n\tSDVO_CMD_NAME_ENTRY(GET_AUDIO_STAT),\n\tSDVO_CMD_NAME_ENTRY(GET_HBUF_INDEX),\n\tSDVO_CMD_NAME_ENTRY(SET_HBUF_INDEX),\n\tSDVO_CMD_NAME_ENTRY(GET_HBUF_INFO),\n\tSDVO_CMD_NAME_ENTRY(GET_HBUF_AV_SPLIT),\n\tSDVO_CMD_NAME_ENTRY(SET_HBUF_AV_SPLIT),\n\tSDVO_CMD_NAME_ENTRY(GET_HBUF_TXRATE),\n\tSDVO_CMD_NAME_ENTRY(SET_HBUF_TXRATE),\n\tSDVO_CMD_NAME_ENTRY(SET_HBUF_DATA),\n\tSDVO_CMD_NAME_ENTRY(GET_HBUF_DATA),\n};\n\n#undef SDVO_CMD_NAME_ENTRY\n\nstatic const char *sdvo_cmd_name(u8 cmd)\n{\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(sdvo_cmd_names); i++) {\n\t\tif (cmd == sdvo_cmd_names[i].cmd)\n\t\t\treturn sdvo_cmd_names[i].name;\n\t}\n\n\treturn NULL;\n}\n\n#define SDVO_NAME(svdo) ((svdo)->port == PORT_B ? \"SDVOB\" : \"SDVOC\")\n\nstatic void intel_sdvo_debug_write(struct intel_sdvo *intel_sdvo, u8 cmd,\n\t\t\t\t   const void *args, int args_len)\n{\n\tstruct drm_i915_private *dev_priv = to_i915(intel_sdvo->base.base.dev);\n\tconst char *cmd_name;\n\tint i, pos = 0;\n\tchar buffer[64];\n\n#define BUF_PRINT(args...) \\\n\tpos += snprintf(buffer + pos, max_t(int, sizeof(buffer) - pos, 0), args)\n\n\tfor (i = 0; i < args_len; i++) {\n\t\tBUF_PRINT(\"%02X \", ((u8 *)args)[i]);\n\t}\n\tfor (; i < 8; i++) {\n\t\tBUF_PRINT(\"   \");\n\t}\n\n\tcmd_name = sdvo_cmd_name(cmd);\n\tif (cmd_name)\n\t\tBUF_PRINT(\"(%s)\", cmd_name);\n\telse\n\t\tBUF_PRINT(\"(%02X)\", cmd);\n\n\tdrm_WARN_ON(&dev_priv->drm, pos >= sizeof(buffer) - 1);\n#undef BUF_PRINT\n\n\tDRM_DEBUG_KMS(\"%s: W: %02X %s\\n\", SDVO_NAME(intel_sdvo), cmd, buffer);\n}\n\nstatic const char * const cmd_status_names[] = {\n\t[SDVO_CMD_STATUS_POWER_ON] = \"Power on\",\n\t[SDVO_CMD_STATUS_SUCCESS] = \"Success\",\n\t[SDVO_CMD_STATUS_NOTSUPP] = \"Not supported\",\n\t[SDVO_CMD_STATUS_INVALID_ARG] = \"Invalid arg\",\n\t[SDVO_CMD_STATUS_PENDING] = \"Pending\",\n\t[SDVO_CMD_STATUS_TARGET_NOT_SPECIFIED] = \"Target not specified\",\n\t[SDVO_CMD_STATUS_SCALING_NOT_SUPP] = \"Scaling not supported\",\n};\n\nstatic const char *sdvo_cmd_status(u8 status)\n{\n\tif (status < ARRAY_SIZE(cmd_status_names))\n\t\treturn cmd_status_names[status];\n\telse\n\t\treturn NULL;\n}\n\nstatic bool __intel_sdvo_write_cmd(struct intel_sdvo *intel_sdvo, u8 cmd,\n\t\t\t\t   const void *args, int args_len,\n\t\t\t\t   bool unlocked)\n{\n\tu8 *buf, status;\n\tstruct i2c_msg *msgs;\n\tint i, ret = true;\n\n\t \n\tbuf = kzalloc(args_len * 2 + 2, GFP_KERNEL);\n\tif (!buf)\n\t\treturn false;\n\n\tmsgs = kcalloc(args_len + 3, sizeof(*msgs), GFP_KERNEL);\n\tif (!msgs) {\n\t\tkfree(buf);\n\t\treturn false;\n\t}\n\n\tintel_sdvo_debug_write(intel_sdvo, cmd, args, args_len);\n\n\tfor (i = 0; i < args_len; i++) {\n\t\tmsgs[i].addr = intel_sdvo->slave_addr;\n\t\tmsgs[i].flags = 0;\n\t\tmsgs[i].len = 2;\n\t\tmsgs[i].buf = buf + 2 *i;\n\t\tbuf[2*i + 0] = SDVO_I2C_ARG_0 - i;\n\t\tbuf[2*i + 1] = ((u8*)args)[i];\n\t}\n\tmsgs[i].addr = intel_sdvo->slave_addr;\n\tmsgs[i].flags = 0;\n\tmsgs[i].len = 2;\n\tmsgs[i].buf = buf + 2*i;\n\tbuf[2*i + 0] = SDVO_I2C_OPCODE;\n\tbuf[2*i + 1] = cmd;\n\n\t \n\tstatus = SDVO_I2C_CMD_STATUS;\n\tmsgs[i+1].addr = intel_sdvo->slave_addr;\n\tmsgs[i+1].flags = 0;\n\tmsgs[i+1].len = 1;\n\tmsgs[i+1].buf = &status;\n\n\tmsgs[i+2].addr = intel_sdvo->slave_addr;\n\tmsgs[i+2].flags = I2C_M_RD;\n\tmsgs[i+2].len = 1;\n\tmsgs[i+2].buf = &status;\n\n\tif (unlocked)\n\t\tret = i2c_transfer(intel_sdvo->i2c, msgs, i+3);\n\telse\n\t\tret = __i2c_transfer(intel_sdvo->i2c, msgs, i+3);\n\tif (ret < 0) {\n\t\tDRM_DEBUG_KMS(\"I2c transfer returned %d\\n\", ret);\n\t\tret = false;\n\t\tgoto out;\n\t}\n\tif (ret != i+3) {\n\t\t \n\t\tDRM_DEBUG_KMS(\"I2c transfer returned %d/%d\\n\", ret, i+3);\n\t\tret = false;\n\t}\n\nout:\n\tkfree(msgs);\n\tkfree(buf);\n\treturn ret;\n}\n\nstatic bool intel_sdvo_write_cmd(struct intel_sdvo *intel_sdvo, u8 cmd,\n\t\t\t\t const void *args, int args_len)\n{\n\treturn __intel_sdvo_write_cmd(intel_sdvo, cmd, args, args_len, true);\n}\n\nstatic bool intel_sdvo_read_response(struct intel_sdvo *intel_sdvo,\n\t\t\t\t     void *response, int response_len)\n{\n\tstruct drm_i915_private *dev_priv = to_i915(intel_sdvo->base.base.dev);\n\tconst char *cmd_status;\n\tu8 retry = 15;  \n\tu8 status;\n\tint i, pos = 0;\n\tchar buffer[64];\n\n\tbuffer[0] = '\\0';\n\n\t \n\tif (!intel_sdvo_read_byte(intel_sdvo,\n\t\t\t\t  SDVO_I2C_CMD_STATUS,\n\t\t\t\t  &status))\n\t\tgoto log_fail;\n\n\twhile ((status == SDVO_CMD_STATUS_PENDING ||\n\t\tstatus == SDVO_CMD_STATUS_TARGET_NOT_SPECIFIED) && --retry) {\n\t\tif (retry < 10)\n\t\t\tmsleep(15);\n\t\telse\n\t\t\tudelay(15);\n\n\t\tif (!intel_sdvo_read_byte(intel_sdvo,\n\t\t\t\t\t  SDVO_I2C_CMD_STATUS,\n\t\t\t\t\t  &status))\n\t\t\tgoto log_fail;\n\t}\n\n#define BUF_PRINT(args...) \\\n\tpos += snprintf(buffer + pos, max_t(int, sizeof(buffer) - pos, 0), args)\n\n\tcmd_status = sdvo_cmd_status(status);\n\tif (cmd_status)\n\t\tBUF_PRINT(\"(%s)\", cmd_status);\n\telse\n\t\tBUF_PRINT(\"(??? %d)\", status);\n\n\tif (status != SDVO_CMD_STATUS_SUCCESS)\n\t\tgoto log_fail;\n\n\t \n\tfor (i = 0; i < response_len; i++) {\n\t\tif (!intel_sdvo_read_byte(intel_sdvo,\n\t\t\t\t\t  SDVO_I2C_RETURN_0 + i,\n\t\t\t\t\t  &((u8 *)response)[i]))\n\t\t\tgoto log_fail;\n\t\tBUF_PRINT(\" %02X\", ((u8 *)response)[i]);\n\t}\n\n\tdrm_WARN_ON(&dev_priv->drm, pos >= sizeof(buffer) - 1);\n#undef BUF_PRINT\n\n\tDRM_DEBUG_KMS(\"%s: R: %s\\n\", SDVO_NAME(intel_sdvo), buffer);\n\treturn true;\n\nlog_fail:\n\tDRM_DEBUG_KMS(\"%s: R: ... failed %s\\n\",\n\t\t      SDVO_NAME(intel_sdvo), buffer);\n\treturn false;\n}\n\nstatic int intel_sdvo_get_pixel_multiplier(const struct drm_display_mode *adjusted_mode)\n{\n\tif (adjusted_mode->crtc_clock >= 100000)\n\t\treturn 1;\n\telse if (adjusted_mode->crtc_clock >= 50000)\n\t\treturn 2;\n\telse\n\t\treturn 4;\n}\n\nstatic bool __intel_sdvo_set_control_bus_switch(struct intel_sdvo *intel_sdvo,\n\t\t\t\t\t\tu8 ddc_bus)\n{\n\t \n\treturn __intel_sdvo_write_cmd(intel_sdvo,\n\t\t\t\t      SDVO_CMD_SET_CONTROL_BUS_SWITCH,\n\t\t\t\t      &ddc_bus, 1, false);\n}\n\nstatic bool intel_sdvo_set_value(struct intel_sdvo *intel_sdvo, u8 cmd, const void *data, int len)\n{\n\tif (!intel_sdvo_write_cmd(intel_sdvo, cmd, data, len))\n\t\treturn false;\n\n\treturn intel_sdvo_read_response(intel_sdvo, NULL, 0);\n}\n\nstatic bool\nintel_sdvo_get_value(struct intel_sdvo *intel_sdvo, u8 cmd, void *value, int len)\n{\n\tif (!intel_sdvo_write_cmd(intel_sdvo, cmd, NULL, 0))\n\t\treturn false;\n\n\treturn intel_sdvo_read_response(intel_sdvo, value, len);\n}\n\nstatic bool intel_sdvo_set_target_input(struct intel_sdvo *intel_sdvo)\n{\n\tstruct intel_sdvo_set_target_input_args targets = {0};\n\treturn intel_sdvo_set_value(intel_sdvo,\n\t\t\t\t    SDVO_CMD_SET_TARGET_INPUT,\n\t\t\t\t    &targets, sizeof(targets));\n}\n\n \nstatic bool intel_sdvo_get_trained_inputs(struct intel_sdvo *intel_sdvo, bool *input_1, bool *input_2)\n{\n\tstruct intel_sdvo_get_trained_inputs_response response;\n\n\tBUILD_BUG_ON(sizeof(response) != 1);\n\tif (!intel_sdvo_get_value(intel_sdvo, SDVO_CMD_GET_TRAINED_INPUTS,\n\t\t\t\t  &response, sizeof(response)))\n\t\treturn false;\n\n\t*input_1 = response.input0_trained;\n\t*input_2 = response.input1_trained;\n\treturn true;\n}\n\nstatic bool intel_sdvo_set_active_outputs(struct intel_sdvo *intel_sdvo,\n\t\t\t\t\t  u16 outputs)\n{\n\treturn intel_sdvo_set_value(intel_sdvo,\n\t\t\t\t    SDVO_CMD_SET_ACTIVE_OUTPUTS,\n\t\t\t\t    &outputs, sizeof(outputs));\n}\n\nstatic bool intel_sdvo_get_active_outputs(struct intel_sdvo *intel_sdvo,\n\t\t\t\t\t  u16 *outputs)\n{\n\treturn intel_sdvo_get_value(intel_sdvo,\n\t\t\t\t    SDVO_CMD_GET_ACTIVE_OUTPUTS,\n\t\t\t\t    outputs, sizeof(*outputs));\n}\n\nstatic bool intel_sdvo_set_encoder_power_state(struct intel_sdvo *intel_sdvo,\n\t\t\t\t\t       int mode)\n{\n\tu8 state = SDVO_ENCODER_STATE_ON;\n\n\tswitch (mode) {\n\tcase DRM_MODE_DPMS_ON:\n\t\tstate = SDVO_ENCODER_STATE_ON;\n\t\tbreak;\n\tcase DRM_MODE_DPMS_STANDBY:\n\t\tstate = SDVO_ENCODER_STATE_STANDBY;\n\t\tbreak;\n\tcase DRM_MODE_DPMS_SUSPEND:\n\t\tstate = SDVO_ENCODER_STATE_SUSPEND;\n\t\tbreak;\n\tcase DRM_MODE_DPMS_OFF:\n\t\tstate = SDVO_ENCODER_STATE_OFF;\n\t\tbreak;\n\t}\n\n\treturn intel_sdvo_set_value(intel_sdvo,\n\t\t\t\t    SDVO_CMD_SET_ENCODER_POWER_STATE, &state, sizeof(state));\n}\n\nstatic bool intel_sdvo_get_input_pixel_clock_range(struct intel_sdvo *intel_sdvo,\n\t\t\t\t\t\t   int *clock_min,\n\t\t\t\t\t\t   int *clock_max)\n{\n\tstruct intel_sdvo_pixel_clock_range clocks;\n\n\tBUILD_BUG_ON(sizeof(clocks) != 4);\n\tif (!intel_sdvo_get_value(intel_sdvo,\n\t\t\t\t  SDVO_CMD_GET_INPUT_PIXEL_CLOCK_RANGE,\n\t\t\t\t  &clocks, sizeof(clocks)))\n\t\treturn false;\n\n\t \n\t*clock_min = clocks.min * 10;\n\t*clock_max = clocks.max * 10;\n\treturn true;\n}\n\nstatic bool intel_sdvo_set_target_output(struct intel_sdvo *intel_sdvo,\n\t\t\t\t\t u16 outputs)\n{\n\treturn intel_sdvo_set_value(intel_sdvo,\n\t\t\t\t    SDVO_CMD_SET_TARGET_OUTPUT,\n\t\t\t\t    &outputs, sizeof(outputs));\n}\n\nstatic bool intel_sdvo_set_timing(struct intel_sdvo *intel_sdvo, u8 cmd,\n\t\t\t\t  struct intel_sdvo_dtd *dtd)\n{\n\treturn intel_sdvo_set_value(intel_sdvo, cmd, &dtd->part1, sizeof(dtd->part1)) &&\n\t\tintel_sdvo_set_value(intel_sdvo, cmd + 1, &dtd->part2, sizeof(dtd->part2));\n}\n\nstatic bool intel_sdvo_get_timing(struct intel_sdvo *intel_sdvo, u8 cmd,\n\t\t\t\t  struct intel_sdvo_dtd *dtd)\n{\n\treturn intel_sdvo_get_value(intel_sdvo, cmd, &dtd->part1, sizeof(dtd->part1)) &&\n\t\tintel_sdvo_get_value(intel_sdvo, cmd + 1, &dtd->part2, sizeof(dtd->part2));\n}\n\nstatic bool intel_sdvo_set_input_timing(struct intel_sdvo *intel_sdvo,\n\t\t\t\t\t struct intel_sdvo_dtd *dtd)\n{\n\treturn intel_sdvo_set_timing(intel_sdvo,\n\t\t\t\t     SDVO_CMD_SET_INPUT_TIMINGS_PART1, dtd);\n}\n\nstatic bool intel_sdvo_set_output_timing(struct intel_sdvo *intel_sdvo,\n\t\t\t\t\t struct intel_sdvo_dtd *dtd)\n{\n\treturn intel_sdvo_set_timing(intel_sdvo,\n\t\t\t\t     SDVO_CMD_SET_OUTPUT_TIMINGS_PART1, dtd);\n}\n\nstatic bool intel_sdvo_get_input_timing(struct intel_sdvo *intel_sdvo,\n\t\t\t\t\tstruct intel_sdvo_dtd *dtd)\n{\n\treturn intel_sdvo_get_timing(intel_sdvo,\n\t\t\t\t     SDVO_CMD_GET_INPUT_TIMINGS_PART1, dtd);\n}\n\nstatic bool\nintel_sdvo_create_preferred_input_timing(struct intel_sdvo *intel_sdvo,\n\t\t\t\t\t struct intel_sdvo_connector *intel_sdvo_connector,\n\t\t\t\t\t const struct drm_display_mode *mode)\n{\n\tstruct intel_sdvo_preferred_input_timing_args args;\n\n\tmemset(&args, 0, sizeof(args));\n\targs.clock = mode->clock / 10;\n\targs.width = mode->hdisplay;\n\targs.height = mode->vdisplay;\n\targs.interlace = 0;\n\n\tif (IS_LVDS(intel_sdvo_connector)) {\n\t\tconst struct drm_display_mode *fixed_mode =\n\t\t\tintel_panel_fixed_mode(&intel_sdvo_connector->base, mode);\n\n\t\tif (fixed_mode->hdisplay != args.width ||\n\t\t    fixed_mode->vdisplay != args.height)\n\t\t\targs.scaled = 1;\n\t}\n\n\treturn intel_sdvo_set_value(intel_sdvo,\n\t\t\t\t    SDVO_CMD_CREATE_PREFERRED_INPUT_TIMING,\n\t\t\t\t    &args, sizeof(args));\n}\n\nstatic bool intel_sdvo_get_preferred_input_timing(struct intel_sdvo *intel_sdvo,\n\t\t\t\t\t\t  struct intel_sdvo_dtd *dtd)\n{\n\tBUILD_BUG_ON(sizeof(dtd->part1) != 8);\n\tBUILD_BUG_ON(sizeof(dtd->part2) != 8);\n\treturn intel_sdvo_get_value(intel_sdvo, SDVO_CMD_GET_PREFERRED_INPUT_TIMING_PART1,\n\t\t\t\t    &dtd->part1, sizeof(dtd->part1)) &&\n\t\tintel_sdvo_get_value(intel_sdvo, SDVO_CMD_GET_PREFERRED_INPUT_TIMING_PART2,\n\t\t\t\t     &dtd->part2, sizeof(dtd->part2));\n}\n\nstatic bool intel_sdvo_set_clock_rate_mult(struct intel_sdvo *intel_sdvo, u8 val)\n{\n\treturn intel_sdvo_set_value(intel_sdvo, SDVO_CMD_SET_CLOCK_RATE_MULT, &val, 1);\n}\n\nstatic void intel_sdvo_get_dtd_from_mode(struct intel_sdvo_dtd *dtd,\n\t\t\t\t\t const struct drm_display_mode *mode)\n{\n\tu16 width, height;\n\tu16 h_blank_len, h_sync_len, v_blank_len, v_sync_len;\n\tu16 h_sync_offset, v_sync_offset;\n\tint mode_clock;\n\n\tmemset(dtd, 0, sizeof(*dtd));\n\n\twidth = mode->hdisplay;\n\theight = mode->vdisplay;\n\n\t \n\th_blank_len = mode->htotal - mode->hdisplay;\n\th_sync_len = mode->hsync_end - mode->hsync_start;\n\n\tv_blank_len = mode->vtotal - mode->vdisplay;\n\tv_sync_len = mode->vsync_end - mode->vsync_start;\n\n\th_sync_offset = mode->hsync_start - mode->hdisplay;\n\tv_sync_offset = mode->vsync_start - mode->vdisplay;\n\n\tmode_clock = mode->clock;\n\tmode_clock /= 10;\n\tdtd->part1.clock = mode_clock;\n\n\tdtd->part1.h_active = width & 0xff;\n\tdtd->part1.h_blank = h_blank_len & 0xff;\n\tdtd->part1.h_high = (((width >> 8) & 0xf) << 4) |\n\t\t((h_blank_len >> 8) & 0xf);\n\tdtd->part1.v_active = height & 0xff;\n\tdtd->part1.v_blank = v_blank_len & 0xff;\n\tdtd->part1.v_high = (((height >> 8) & 0xf) << 4) |\n\t\t((v_blank_len >> 8) & 0xf);\n\n\tdtd->part2.h_sync_off = h_sync_offset & 0xff;\n\tdtd->part2.h_sync_width = h_sync_len & 0xff;\n\tdtd->part2.v_sync_off_width = (v_sync_offset & 0xf) << 4 |\n\t\t(v_sync_len & 0xf);\n\tdtd->part2.sync_off_width_high = ((h_sync_offset & 0x300) >> 2) |\n\t\t((h_sync_len & 0x300) >> 4) | ((v_sync_offset & 0x30) >> 2) |\n\t\t((v_sync_len & 0x30) >> 4);\n\n\tdtd->part2.dtd_flags = 0x18;\n\tif (mode->flags & DRM_MODE_FLAG_INTERLACE)\n\t\tdtd->part2.dtd_flags |= DTD_FLAG_INTERLACE;\n\tif (mode->flags & DRM_MODE_FLAG_PHSYNC)\n\t\tdtd->part2.dtd_flags |= DTD_FLAG_HSYNC_POSITIVE;\n\tif (mode->flags & DRM_MODE_FLAG_PVSYNC)\n\t\tdtd->part2.dtd_flags |= DTD_FLAG_VSYNC_POSITIVE;\n\n\tdtd->part2.v_sync_off_high = v_sync_offset & 0xc0;\n}\n\nstatic void intel_sdvo_get_mode_from_dtd(struct drm_display_mode *pmode,\n\t\t\t\t\t const struct intel_sdvo_dtd *dtd)\n{\n\tstruct drm_display_mode mode = {};\n\n\tmode.hdisplay = dtd->part1.h_active;\n\tmode.hdisplay += ((dtd->part1.h_high >> 4) & 0x0f) << 8;\n\tmode.hsync_start = mode.hdisplay + dtd->part2.h_sync_off;\n\tmode.hsync_start += (dtd->part2.sync_off_width_high & 0xc0) << 2;\n\tmode.hsync_end = mode.hsync_start + dtd->part2.h_sync_width;\n\tmode.hsync_end += (dtd->part2.sync_off_width_high & 0x30) << 4;\n\tmode.htotal = mode.hdisplay + dtd->part1.h_blank;\n\tmode.htotal += (dtd->part1.h_high & 0xf) << 8;\n\n\tmode.vdisplay = dtd->part1.v_active;\n\tmode.vdisplay += ((dtd->part1.v_high >> 4) & 0x0f) << 8;\n\tmode.vsync_start = mode.vdisplay;\n\tmode.vsync_start += (dtd->part2.v_sync_off_width >> 4) & 0xf;\n\tmode.vsync_start += (dtd->part2.sync_off_width_high & 0x0c) << 2;\n\tmode.vsync_start += dtd->part2.v_sync_off_high & 0xc0;\n\tmode.vsync_end = mode.vsync_start +\n\t\t(dtd->part2.v_sync_off_width & 0xf);\n\tmode.vsync_end += (dtd->part2.sync_off_width_high & 0x3) << 4;\n\tmode.vtotal = mode.vdisplay + dtd->part1.v_blank;\n\tmode.vtotal += (dtd->part1.v_high & 0xf) << 8;\n\n\tmode.clock = dtd->part1.clock * 10;\n\n\tif (dtd->part2.dtd_flags & DTD_FLAG_INTERLACE)\n\t\tmode.flags |= DRM_MODE_FLAG_INTERLACE;\n\tif (dtd->part2.dtd_flags & DTD_FLAG_HSYNC_POSITIVE)\n\t\tmode.flags |= DRM_MODE_FLAG_PHSYNC;\n\telse\n\t\tmode.flags |= DRM_MODE_FLAG_NHSYNC;\n\tif (dtd->part2.dtd_flags & DTD_FLAG_VSYNC_POSITIVE)\n\t\tmode.flags |= DRM_MODE_FLAG_PVSYNC;\n\telse\n\t\tmode.flags |= DRM_MODE_FLAG_NVSYNC;\n\n\tdrm_mode_set_crtcinfo(&mode, 0);\n\n\tdrm_mode_copy(pmode, &mode);\n}\n\nstatic bool intel_sdvo_check_supp_encode(struct intel_sdvo *intel_sdvo)\n{\n\tstruct intel_sdvo_encode encode;\n\n\tBUILD_BUG_ON(sizeof(encode) != 2);\n\treturn intel_sdvo_get_value(intel_sdvo,\n\t\t\t\t  SDVO_CMD_GET_SUPP_ENCODE,\n\t\t\t\t  &encode, sizeof(encode));\n}\n\nstatic bool intel_sdvo_set_encode(struct intel_sdvo *intel_sdvo,\n\t\t\t\t  u8 mode)\n{\n\treturn intel_sdvo_set_value(intel_sdvo, SDVO_CMD_SET_ENCODE, &mode, 1);\n}\n\nstatic bool intel_sdvo_set_colorimetry(struct intel_sdvo *intel_sdvo,\n\t\t\t\t       u8 mode)\n{\n\treturn intel_sdvo_set_value(intel_sdvo, SDVO_CMD_SET_COLORIMETRY, &mode, 1);\n}\n\nstatic bool intel_sdvo_set_pixel_replication(struct intel_sdvo *intel_sdvo,\n\t\t\t\t\t     u8 pixel_repeat)\n{\n\treturn intel_sdvo_set_value(intel_sdvo, SDVO_CMD_SET_PIXEL_REPLI,\n\t\t\t\t    &pixel_repeat, 1);\n}\n\nstatic bool intel_sdvo_set_audio_state(struct intel_sdvo *intel_sdvo,\n\t\t\t\t       u8 audio_state)\n{\n\treturn intel_sdvo_set_value(intel_sdvo, SDVO_CMD_SET_AUDIO_STAT,\n\t\t\t\t    &audio_state, 1);\n}\n\nstatic bool intel_sdvo_get_hbuf_size(struct intel_sdvo *intel_sdvo,\n\t\t\t\t     u8 *hbuf_size)\n{\n\tif (!intel_sdvo_get_value(intel_sdvo, SDVO_CMD_GET_HBUF_INFO,\n\t\t\t\t  hbuf_size, 1))\n\t\treturn false;\n\n\t \n\tif (*hbuf_size)\n\t\t(*hbuf_size)++;\n\n\treturn true;\n}\n\n#if 0\nstatic void intel_sdvo_dump_hdmi_buf(struct intel_sdvo *intel_sdvo)\n{\n\tint i, j;\n\tu8 set_buf_index[2];\n\tu8 av_split;\n\tu8 buf_size;\n\tu8 buf[48];\n\tu8 *pos;\n\n\tintel_sdvo_get_value(encoder, SDVO_CMD_GET_HBUF_AV_SPLIT, &av_split, 1);\n\n\tfor (i = 0; i <= av_split; i++) {\n\t\tset_buf_index[0] = i; set_buf_index[1] = 0;\n\t\tintel_sdvo_write_cmd(encoder, SDVO_CMD_SET_HBUF_INDEX,\n\t\t\t\t     set_buf_index, 2);\n\t\tintel_sdvo_write_cmd(encoder, SDVO_CMD_GET_HBUF_INFO, NULL, 0);\n\t\tintel_sdvo_read_response(encoder, &buf_size, 1);\n\n\t\tpos = buf;\n\t\tfor (j = 0; j <= buf_size; j += 8) {\n\t\t\tintel_sdvo_write_cmd(encoder, SDVO_CMD_GET_HBUF_DATA,\n\t\t\t\t\t     NULL, 0);\n\t\t\tintel_sdvo_read_response(encoder, pos, 8);\n\t\t\tpos += 8;\n\t\t}\n\t}\n}\n#endif\n\nstatic bool intel_sdvo_write_infoframe(struct intel_sdvo *intel_sdvo,\n\t\t\t\t       unsigned int if_index, u8 tx_rate,\n\t\t\t\t       const u8 *data, unsigned int length)\n{\n\tu8 set_buf_index[2] = { if_index, 0 };\n\tu8 hbuf_size, tmp[8];\n\tint i;\n\n\tif (!intel_sdvo_set_value(intel_sdvo,\n\t\t\t\t  SDVO_CMD_SET_HBUF_INDEX,\n\t\t\t\t  set_buf_index, 2))\n\t\treturn false;\n\n\tif (!intel_sdvo_get_hbuf_size(intel_sdvo, &hbuf_size))\n\t\treturn false;\n\n\tDRM_DEBUG_KMS(\"writing sdvo hbuf: %i, length %u, hbuf_size: %i\\n\",\n\t\t      if_index, length, hbuf_size);\n\n\tif (hbuf_size < length)\n\t\treturn false;\n\n\tfor (i = 0; i < hbuf_size; i += 8) {\n\t\tmemset(tmp, 0, 8);\n\t\tif (i < length)\n\t\t\tmemcpy(tmp, data + i, min_t(unsigned, 8, length - i));\n\n\t\tif (!intel_sdvo_set_value(intel_sdvo,\n\t\t\t\t\t  SDVO_CMD_SET_HBUF_DATA,\n\t\t\t\t\t  tmp, 8))\n\t\t\treturn false;\n\t}\n\n\treturn intel_sdvo_set_value(intel_sdvo,\n\t\t\t\t    SDVO_CMD_SET_HBUF_TXRATE,\n\t\t\t\t    &tx_rate, 1);\n}\n\nstatic ssize_t intel_sdvo_read_infoframe(struct intel_sdvo *intel_sdvo,\n\t\t\t\t\t unsigned int if_index,\n\t\t\t\t\t u8 *data, unsigned int length)\n{\n\tu8 set_buf_index[2] = { if_index, 0 };\n\tu8 hbuf_size, tx_rate, av_split;\n\tint i;\n\n\tif (!intel_sdvo_get_value(intel_sdvo,\n\t\t\t\t  SDVO_CMD_GET_HBUF_AV_SPLIT,\n\t\t\t\t  &av_split, 1))\n\t\treturn -ENXIO;\n\n\tif (av_split < if_index)\n\t\treturn 0;\n\n\tif (!intel_sdvo_set_value(intel_sdvo,\n\t\t\t\t  SDVO_CMD_SET_HBUF_INDEX,\n\t\t\t\t  set_buf_index, 2))\n\t\treturn -ENXIO;\n\n\tif (!intel_sdvo_get_value(intel_sdvo,\n\t\t\t\t  SDVO_CMD_GET_HBUF_TXRATE,\n\t\t\t\t  &tx_rate, 1))\n\t\treturn -ENXIO;\n\n\t \n\tif (if_index != SDVO_HBUF_INDEX_ELD && tx_rate == SDVO_HBUF_TX_DISABLED)\n\t\treturn 0;\n\n\tif (!intel_sdvo_get_hbuf_size(intel_sdvo, &hbuf_size))\n\t\treturn false;\n\n\tDRM_DEBUG_KMS(\"reading sdvo hbuf: %i, length %u, hbuf_size: %i\\n\",\n\t\t      if_index, length, hbuf_size);\n\n\thbuf_size = min_t(unsigned int, length, hbuf_size);\n\n\tfor (i = 0; i < hbuf_size; i += 8) {\n\t\tif (!intel_sdvo_write_cmd(intel_sdvo, SDVO_CMD_GET_HBUF_DATA, NULL, 0))\n\t\t\treturn -ENXIO;\n\t\tif (!intel_sdvo_read_response(intel_sdvo, &data[i],\n\t\t\t\t\t      min_t(unsigned int, 8, hbuf_size - i)))\n\t\t\treturn -ENXIO;\n\t}\n\n\treturn hbuf_size;\n}\n\nstatic bool intel_sdvo_compute_avi_infoframe(struct intel_sdvo *intel_sdvo,\n\t\t\t\t\t     struct intel_crtc_state *crtc_state,\n\t\t\t\t\t     struct drm_connector_state *conn_state)\n{\n\tstruct drm_i915_private *dev_priv = to_i915(intel_sdvo->base.base.dev);\n\tstruct hdmi_avi_infoframe *frame = &crtc_state->infoframes.avi.avi;\n\tconst struct drm_display_mode *adjusted_mode =\n\t\t&crtc_state->hw.adjusted_mode;\n\tint ret;\n\n\tif (!crtc_state->has_hdmi_sink)\n\t\treturn true;\n\n\tcrtc_state->infoframes.enable |=\n\t\tintel_hdmi_infoframe_enable(HDMI_INFOFRAME_TYPE_AVI);\n\n\tret = drm_hdmi_avi_infoframe_from_display_mode(frame,\n\t\t\t\t\t\t       conn_state->connector,\n\t\t\t\t\t\t       adjusted_mode);\n\tif (ret)\n\t\treturn false;\n\n\tdrm_hdmi_avi_infoframe_quant_range(frame,\n\t\t\t\t\t   conn_state->connector,\n\t\t\t\t\t   adjusted_mode,\n\t\t\t\t\t   crtc_state->limited_color_range ?\n\t\t\t\t\t   HDMI_QUANTIZATION_RANGE_LIMITED :\n\t\t\t\t\t   HDMI_QUANTIZATION_RANGE_FULL);\n\n\tret = hdmi_avi_infoframe_check(frame);\n\tif (drm_WARN_ON(&dev_priv->drm, ret))\n\t\treturn false;\n\n\treturn true;\n}\n\nstatic bool intel_sdvo_set_avi_infoframe(struct intel_sdvo *intel_sdvo,\n\t\t\t\t\t const struct intel_crtc_state *crtc_state)\n{\n\tstruct drm_i915_private *dev_priv = to_i915(intel_sdvo->base.base.dev);\n\tu8 sdvo_data[HDMI_INFOFRAME_SIZE(AVI)];\n\tconst union hdmi_infoframe *frame = &crtc_state->infoframes.avi;\n\tssize_t len;\n\n\tif ((crtc_state->infoframes.enable &\n\t     intel_hdmi_infoframe_enable(HDMI_INFOFRAME_TYPE_AVI)) == 0)\n\t\treturn true;\n\n\tif (drm_WARN_ON(&dev_priv->drm,\n\t\t\tframe->any.type != HDMI_INFOFRAME_TYPE_AVI))\n\t\treturn false;\n\n\tlen = hdmi_infoframe_pack_only(frame, sdvo_data, sizeof(sdvo_data));\n\tif (drm_WARN_ON(&dev_priv->drm, len < 0))\n\t\treturn false;\n\n\treturn intel_sdvo_write_infoframe(intel_sdvo, SDVO_HBUF_INDEX_AVI_IF,\n\t\t\t\t\t  SDVO_HBUF_TX_VSYNC,\n\t\t\t\t\t  sdvo_data, len);\n}\n\nstatic void intel_sdvo_get_avi_infoframe(struct intel_sdvo *intel_sdvo,\n\t\t\t\t\t struct intel_crtc_state *crtc_state)\n{\n\tu8 sdvo_data[HDMI_INFOFRAME_SIZE(AVI)];\n\tunion hdmi_infoframe *frame = &crtc_state->infoframes.avi;\n\tssize_t len;\n\tint ret;\n\n\tif (!crtc_state->has_hdmi_sink)\n\t\treturn;\n\n\tlen = intel_sdvo_read_infoframe(intel_sdvo, SDVO_HBUF_INDEX_AVI_IF,\n\t\t\t\t\tsdvo_data, sizeof(sdvo_data));\n\tif (len < 0) {\n\t\tDRM_DEBUG_KMS(\"failed to read AVI infoframe\\n\");\n\t\treturn;\n\t} else if (len == 0) {\n\t\treturn;\n\t}\n\n\tcrtc_state->infoframes.enable |=\n\t\tintel_hdmi_infoframe_enable(HDMI_INFOFRAME_TYPE_AVI);\n\n\tret = hdmi_infoframe_unpack(frame, sdvo_data, len);\n\tif (ret) {\n\t\tDRM_DEBUG_KMS(\"Failed to unpack AVI infoframe\\n\");\n\t\treturn;\n\t}\n\n\tif (frame->any.type != HDMI_INFOFRAME_TYPE_AVI)\n\t\tDRM_DEBUG_KMS(\"Found the wrong infoframe type 0x%x (expected 0x%02x)\\n\",\n\t\t\t      frame->any.type, HDMI_INFOFRAME_TYPE_AVI);\n}\n\nstatic void intel_sdvo_get_eld(struct intel_sdvo *intel_sdvo,\n\t\t\t       struct intel_crtc_state *crtc_state)\n{\n\tstruct drm_i915_private *i915 = to_i915(intel_sdvo->base.base.dev);\n\tssize_t len;\n\tu8 val;\n\n\tif (!crtc_state->has_audio)\n\t\treturn;\n\n\tif (!intel_sdvo_get_value(intel_sdvo, SDVO_CMD_GET_AUDIO_STAT, &val, 1))\n\t\treturn;\n\n\tif ((val & SDVO_AUDIO_ELD_VALID) == 0)\n\t\treturn;\n\n\tlen = intel_sdvo_read_infoframe(intel_sdvo, SDVO_HBUF_INDEX_ELD,\n\t\t\t\t\tcrtc_state->eld, sizeof(crtc_state->eld));\n\tif (len < 0)\n\t\tdrm_dbg_kms(&i915->drm, \"failed to read ELD\\n\");\n}\n\nstatic bool intel_sdvo_set_tv_format(struct intel_sdvo *intel_sdvo,\n\t\t\t\t     const struct drm_connector_state *conn_state)\n{\n\tstruct intel_sdvo_tv_format format;\n\tu32 format_map;\n\n\tformat_map = 1 << conn_state->tv.mode;\n\tmemset(&format, 0, sizeof(format));\n\tmemcpy(&format, &format_map, min(sizeof(format), sizeof(format_map)));\n\n\tBUILD_BUG_ON(sizeof(format) != 6);\n\treturn intel_sdvo_set_value(intel_sdvo,\n\t\t\t\t    SDVO_CMD_SET_TV_FORMAT,\n\t\t\t\t    &format, sizeof(format));\n}\n\nstatic bool\nintel_sdvo_set_output_timings_from_mode(struct intel_sdvo *intel_sdvo,\n\t\t\t\t\tconst struct drm_display_mode *mode)\n{\n\tstruct intel_sdvo_dtd output_dtd;\n\n\tif (!intel_sdvo_set_target_output(intel_sdvo,\n\t\t\t\t\t  intel_sdvo->attached_output))\n\t\treturn false;\n\n\tintel_sdvo_get_dtd_from_mode(&output_dtd, mode);\n\tif (!intel_sdvo_set_output_timing(intel_sdvo, &output_dtd))\n\t\treturn false;\n\n\treturn true;\n}\n\n \nstatic bool\nintel_sdvo_get_preferred_input_mode(struct intel_sdvo *intel_sdvo,\n\t\t\t\t    struct intel_sdvo_connector *intel_sdvo_connector,\n\t\t\t\t    const struct drm_display_mode *mode,\n\t\t\t\t    struct drm_display_mode *adjusted_mode)\n{\n\tstruct intel_sdvo_dtd input_dtd;\n\n\t \n\tif (!intel_sdvo_set_target_input(intel_sdvo))\n\t\treturn false;\n\n\tif (!intel_sdvo_create_preferred_input_timing(intel_sdvo,\n\t\t\t\t\t\t      intel_sdvo_connector,\n\t\t\t\t\t\t      mode))\n\t\treturn false;\n\n\tif (!intel_sdvo_get_preferred_input_timing(intel_sdvo,\n\t\t\t\t\t\t   &input_dtd))\n\t\treturn false;\n\n\tintel_sdvo_get_mode_from_dtd(adjusted_mode, &input_dtd);\n\tintel_sdvo->dtd_sdvo_flags = input_dtd.part2.sdvo_flags;\n\n\treturn true;\n}\n\nstatic void i9xx_adjust_sdvo_tv_clock(struct intel_crtc_state *pipe_config)\n{\n\tstruct drm_i915_private *dev_priv = to_i915(pipe_config->uapi.crtc->dev);\n\tunsigned dotclock = pipe_config->port_clock;\n\tstruct dpll *clock = &pipe_config->dpll;\n\n\t \n\tif (dotclock >= 100000 && dotclock < 140500) {\n\t\tclock->p1 = 2;\n\t\tclock->p2 = 10;\n\t\tclock->n = 3;\n\t\tclock->m1 = 16;\n\t\tclock->m2 = 8;\n\t} else if (dotclock >= 140500 && dotclock <= 200000) {\n\t\tclock->p1 = 1;\n\t\tclock->p2 = 10;\n\t\tclock->n = 6;\n\t\tclock->m1 = 12;\n\t\tclock->m2 = 8;\n\t} else {\n\t\tdrm_WARN(&dev_priv->drm, 1,\n\t\t\t \"SDVO TV clock out of range: %i\\n\", dotclock);\n\t}\n\n\tpipe_config->clock_set = true;\n}\n\nstatic bool intel_has_hdmi_sink(struct intel_sdvo_connector *intel_sdvo_connector,\n\t\t\t\tconst struct drm_connector_state *conn_state)\n{\n\tstruct drm_connector *connector = conn_state->connector;\n\n\treturn intel_sdvo_connector->is_hdmi &&\n\t\tconnector->display_info.is_hdmi &&\n\t\tREAD_ONCE(to_intel_digital_connector_state(conn_state)->force_audio) != HDMI_AUDIO_OFF_DVI;\n}\n\nstatic bool intel_sdvo_limited_color_range(struct intel_encoder *encoder,\n\t\t\t\t\t   const struct intel_crtc_state *crtc_state,\n\t\t\t\t\t   const struct drm_connector_state *conn_state)\n{\n\tstruct intel_sdvo *intel_sdvo = to_sdvo(encoder);\n\n\tif ((intel_sdvo->colorimetry_cap & SDVO_COLORIMETRY_RGB220) == 0)\n\t\treturn false;\n\n\treturn intel_hdmi_limited_color_range(crtc_state, conn_state);\n}\n\nstatic bool intel_sdvo_has_audio(struct intel_encoder *encoder,\n\t\t\t\t const struct intel_crtc_state *crtc_state,\n\t\t\t\t const struct drm_connector_state *conn_state)\n{\n\tstruct drm_connector *connector = conn_state->connector;\n\tstruct intel_sdvo_connector *intel_sdvo_connector =\n\t\tto_intel_sdvo_connector(connector);\n\tconst struct intel_digital_connector_state *intel_conn_state =\n\t\tto_intel_digital_connector_state(conn_state);\n\n\tif (!crtc_state->has_hdmi_sink)\n\t\treturn false;\n\n\tif (intel_conn_state->force_audio == HDMI_AUDIO_AUTO)\n\t\treturn intel_sdvo_connector->is_hdmi &&\n\t\t\tconnector->display_info.has_audio;\n\telse\n\t\treturn intel_conn_state->force_audio == HDMI_AUDIO_ON;\n}\n\nstatic int intel_sdvo_compute_config(struct intel_encoder *encoder,\n\t\t\t\t     struct intel_crtc_state *pipe_config,\n\t\t\t\t     struct drm_connector_state *conn_state)\n{\n\tstruct intel_sdvo *intel_sdvo = to_sdvo(encoder);\n\tstruct intel_sdvo_connector *intel_sdvo_connector =\n\t\tto_intel_sdvo_connector(conn_state->connector);\n\tstruct drm_display_mode *adjusted_mode = &pipe_config->hw.adjusted_mode;\n\tstruct drm_display_mode *mode = &pipe_config->hw.mode;\n\n\tDRM_DEBUG_KMS(\"forcing bpc to 8 for SDVO\\n\");\n\tpipe_config->pipe_bpp = 8*3;\n\tpipe_config->sink_format = INTEL_OUTPUT_FORMAT_RGB;\n\tpipe_config->output_format = INTEL_OUTPUT_FORMAT_RGB;\n\n\tif (HAS_PCH_SPLIT(to_i915(encoder->base.dev)))\n\t\tpipe_config->has_pch_encoder = true;\n\n\t \n\tif (IS_TV(intel_sdvo_connector)) {\n\t\tif (!intel_sdvo_set_output_timings_from_mode(intel_sdvo, mode))\n\t\t\treturn -EINVAL;\n\n\t\t(void) intel_sdvo_get_preferred_input_mode(intel_sdvo,\n\t\t\t\t\t\t\t   intel_sdvo_connector,\n\t\t\t\t\t\t\t   mode,\n\t\t\t\t\t\t\t   adjusted_mode);\n\t\tpipe_config->sdvo_tv_clock = true;\n\t} else if (IS_LVDS(intel_sdvo_connector)) {\n\t\tconst struct drm_display_mode *fixed_mode =\n\t\t\tintel_panel_fixed_mode(&intel_sdvo_connector->base, mode);\n\t\tint ret;\n\n\t\tret = intel_panel_compute_config(&intel_sdvo_connector->base,\n\t\t\t\t\t\t adjusted_mode);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tif (!intel_sdvo_set_output_timings_from_mode(intel_sdvo, fixed_mode))\n\t\t\treturn -EINVAL;\n\n\t\t(void) intel_sdvo_get_preferred_input_mode(intel_sdvo,\n\t\t\t\t\t\t\t   intel_sdvo_connector,\n\t\t\t\t\t\t\t   mode,\n\t\t\t\t\t\t\t   adjusted_mode);\n\t}\n\n\tif (adjusted_mode->flags & DRM_MODE_FLAG_DBLSCAN)\n\t\treturn -EINVAL;\n\n\t \n\tpipe_config->pixel_multiplier =\n\t\tintel_sdvo_get_pixel_multiplier(adjusted_mode);\n\n\tpipe_config->has_hdmi_sink = intel_has_hdmi_sink(intel_sdvo_connector, conn_state);\n\n\tpipe_config->has_audio =\n\t\tintel_sdvo_has_audio(encoder, pipe_config, conn_state) &&\n\t\tintel_audio_compute_config(encoder, pipe_config, conn_state);\n\n\tpipe_config->limited_color_range =\n\t\tintel_sdvo_limited_color_range(encoder, pipe_config,\n\t\t\t\t\t       conn_state);\n\n\t \n\tif (IS_TV(intel_sdvo_connector))\n\t\ti9xx_adjust_sdvo_tv_clock(pipe_config);\n\n\tif (conn_state->picture_aspect_ratio)\n\t\tadjusted_mode->picture_aspect_ratio =\n\t\t\tconn_state->picture_aspect_ratio;\n\n\tif (!intel_sdvo_compute_avi_infoframe(intel_sdvo,\n\t\t\t\t\t      pipe_config, conn_state)) {\n\t\tDRM_DEBUG_KMS(\"bad AVI infoframe\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\n#define UPDATE_PROPERTY(input, NAME) \\\n\tdo { \\\n\t\tval = input; \\\n\t\tintel_sdvo_set_value(intel_sdvo, SDVO_CMD_SET_##NAME, &val, sizeof(val)); \\\n\t} while (0)\n\nstatic void intel_sdvo_update_props(struct intel_sdvo *intel_sdvo,\n\t\t\t\t    const struct intel_sdvo_connector_state *sdvo_state)\n{\n\tconst struct drm_connector_state *conn_state = &sdvo_state->base.base;\n\tstruct intel_sdvo_connector *intel_sdvo_conn =\n\t\tto_intel_sdvo_connector(conn_state->connector);\n\tu16 val;\n\n\tif (intel_sdvo_conn->left)\n\t\tUPDATE_PROPERTY(sdvo_state->tv.overscan_h, OVERSCAN_H);\n\n\tif (intel_sdvo_conn->top)\n\t\tUPDATE_PROPERTY(sdvo_state->tv.overscan_v, OVERSCAN_V);\n\n\tif (intel_sdvo_conn->hpos)\n\t\tUPDATE_PROPERTY(sdvo_state->tv.hpos, HPOS);\n\n\tif (intel_sdvo_conn->vpos)\n\t\tUPDATE_PROPERTY(sdvo_state->tv.vpos, VPOS);\n\n\tif (intel_sdvo_conn->saturation)\n\t\tUPDATE_PROPERTY(conn_state->tv.saturation, SATURATION);\n\n\tif (intel_sdvo_conn->contrast)\n\t\tUPDATE_PROPERTY(conn_state->tv.contrast, CONTRAST);\n\n\tif (intel_sdvo_conn->hue)\n\t\tUPDATE_PROPERTY(conn_state->tv.hue, HUE);\n\n\tif (intel_sdvo_conn->brightness)\n\t\tUPDATE_PROPERTY(conn_state->tv.brightness, BRIGHTNESS);\n\n\tif (intel_sdvo_conn->sharpness)\n\t\tUPDATE_PROPERTY(sdvo_state->tv.sharpness, SHARPNESS);\n\n\tif (intel_sdvo_conn->flicker_filter)\n\t\tUPDATE_PROPERTY(sdvo_state->tv.flicker_filter, FLICKER_FILTER);\n\n\tif (intel_sdvo_conn->flicker_filter_2d)\n\t\tUPDATE_PROPERTY(sdvo_state->tv.flicker_filter_2d, FLICKER_FILTER_2D);\n\n\tif (intel_sdvo_conn->flicker_filter_adaptive)\n\t\tUPDATE_PROPERTY(sdvo_state->tv.flicker_filter_adaptive, FLICKER_FILTER_ADAPTIVE);\n\n\tif (intel_sdvo_conn->tv_chroma_filter)\n\t\tUPDATE_PROPERTY(sdvo_state->tv.chroma_filter, TV_CHROMA_FILTER);\n\n\tif (intel_sdvo_conn->tv_luma_filter)\n\t\tUPDATE_PROPERTY(sdvo_state->tv.luma_filter, TV_LUMA_FILTER);\n\n\tif (intel_sdvo_conn->dot_crawl)\n\t\tUPDATE_PROPERTY(sdvo_state->tv.dot_crawl, DOT_CRAWL);\n\n#undef UPDATE_PROPERTY\n}\n\nstatic void intel_sdvo_pre_enable(struct intel_atomic_state *state,\n\t\t\t\t  struct intel_encoder *intel_encoder,\n\t\t\t\t  const struct intel_crtc_state *crtc_state,\n\t\t\t\t  const struct drm_connector_state *conn_state)\n{\n\tstruct drm_i915_private *dev_priv = to_i915(intel_encoder->base.dev);\n\tstruct intel_crtc *crtc = to_intel_crtc(crtc_state->uapi.crtc);\n\tconst struct drm_display_mode *adjusted_mode = &crtc_state->hw.adjusted_mode;\n\tconst struct intel_sdvo_connector_state *sdvo_state =\n\t\tto_intel_sdvo_connector_state(conn_state);\n\tstruct intel_sdvo_connector *intel_sdvo_connector =\n\t\tto_intel_sdvo_connector(conn_state->connector);\n\tconst struct drm_display_mode *mode = &crtc_state->hw.mode;\n\tstruct intel_sdvo *intel_sdvo = to_sdvo(intel_encoder);\n\tu32 sdvox;\n\tstruct intel_sdvo_in_out_map in_out;\n\tstruct intel_sdvo_dtd input_dtd, output_dtd;\n\tint rate;\n\n\tintel_sdvo_update_props(intel_sdvo, sdvo_state);\n\n\t \n\tin_out.in0 = intel_sdvo->attached_output;\n\tin_out.in1 = 0;\n\n\tintel_sdvo_set_value(intel_sdvo,\n\t\t\t     SDVO_CMD_SET_IN_OUT_MAP,\n\t\t\t     &in_out, sizeof(in_out));\n\n\t \n\tif (!intel_sdvo_set_target_output(intel_sdvo,\n\t\t\t\t\t  intel_sdvo->attached_output))\n\t\treturn;\n\n\t \n\tif (IS_LVDS(intel_sdvo_connector)) {\n\t\tconst struct drm_display_mode *fixed_mode =\n\t\t\tintel_panel_fixed_mode(&intel_sdvo_connector->base, mode);\n\n\t\tintel_sdvo_get_dtd_from_mode(&output_dtd, fixed_mode);\n\t} else {\n\t\tintel_sdvo_get_dtd_from_mode(&output_dtd, mode);\n\t}\n\tif (!intel_sdvo_set_output_timing(intel_sdvo, &output_dtd))\n\t\tdrm_info(&dev_priv->drm,\n\t\t\t \"Setting output timings on %s failed\\n\",\n\t\t\t SDVO_NAME(intel_sdvo));\n\n\t \n\tif (!intel_sdvo_set_target_input(intel_sdvo))\n\t\treturn;\n\n\tif (crtc_state->has_hdmi_sink) {\n\t\tintel_sdvo_set_encode(intel_sdvo, SDVO_ENCODE_HDMI);\n\t\tintel_sdvo_set_colorimetry(intel_sdvo,\n\t\t\t\t\t   crtc_state->limited_color_range ?\n\t\t\t\t\t   SDVO_COLORIMETRY_RGB220 :\n\t\t\t\t\t   SDVO_COLORIMETRY_RGB256);\n\t\tintel_sdvo_set_avi_infoframe(intel_sdvo, crtc_state);\n\t\tintel_sdvo_set_pixel_replication(intel_sdvo,\n\t\t\t\t\t\t !!(adjusted_mode->flags &\n\t\t\t\t\t\t    DRM_MODE_FLAG_DBLCLK));\n\t} else\n\t\tintel_sdvo_set_encode(intel_sdvo, SDVO_ENCODE_DVI);\n\n\tif (IS_TV(intel_sdvo_connector) &&\n\t    !intel_sdvo_set_tv_format(intel_sdvo, conn_state))\n\t\treturn;\n\n\tintel_sdvo_get_dtd_from_mode(&input_dtd, adjusted_mode);\n\n\tif (IS_TV(intel_sdvo_connector) || IS_LVDS(intel_sdvo_connector))\n\t\tinput_dtd.part2.sdvo_flags = intel_sdvo->dtd_sdvo_flags;\n\tif (!intel_sdvo_set_input_timing(intel_sdvo, &input_dtd))\n\t\tdrm_info(&dev_priv->drm,\n\t\t\t \"Setting input timings on %s failed\\n\",\n\t\t\t SDVO_NAME(intel_sdvo));\n\n\tswitch (crtc_state->pixel_multiplier) {\n\tdefault:\n\t\tdrm_WARN(&dev_priv->drm, 1,\n\t\t\t \"unknown pixel multiplier specified\\n\");\n\t\tfallthrough;\n\tcase 1: rate = SDVO_CLOCK_RATE_MULT_1X; break;\n\tcase 2: rate = SDVO_CLOCK_RATE_MULT_2X; break;\n\tcase 4: rate = SDVO_CLOCK_RATE_MULT_4X; break;\n\t}\n\tif (!intel_sdvo_set_clock_rate_mult(intel_sdvo, rate))\n\t\treturn;\n\n\t \n\tif (DISPLAY_VER(dev_priv) >= 4) {\n\t\t \n\t\tsdvox = SDVO_VSYNC_ACTIVE_HIGH | SDVO_HSYNC_ACTIVE_HIGH;\n\t\tif (DISPLAY_VER(dev_priv) < 5)\n\t\t\tsdvox |= SDVO_BORDER_ENABLE;\n\t} else {\n\t\tsdvox = intel_de_read(dev_priv, intel_sdvo->sdvo_reg);\n\t\tif (intel_sdvo->port == PORT_B)\n\t\t\tsdvox &= SDVOB_PRESERVE_MASK;\n\t\telse\n\t\t\tsdvox &= SDVOC_PRESERVE_MASK;\n\t\tsdvox |= (9 << 19) | SDVO_BORDER_ENABLE;\n\t}\n\n\tif (HAS_PCH_CPT(dev_priv))\n\t\tsdvox |= SDVO_PIPE_SEL_CPT(crtc->pipe);\n\telse\n\t\tsdvox |= SDVO_PIPE_SEL(crtc->pipe);\n\n\tif (DISPLAY_VER(dev_priv) >= 4) {\n\t\t \n\t} else if (IS_I945G(dev_priv) || IS_I945GM(dev_priv) ||\n\t\t   IS_G33(dev_priv) || IS_PINEVIEW(dev_priv)) {\n\t\t \n\t} else {\n\t\tsdvox |= (crtc_state->pixel_multiplier - 1)\n\t\t\t<< SDVO_PORT_MULTIPLY_SHIFT;\n\t}\n\n\tif (input_dtd.part2.sdvo_flags & SDVO_NEED_TO_STALL &&\n\t    DISPLAY_VER(dev_priv) < 5)\n\t\tsdvox |= SDVO_STALL_SELECT;\n\tintel_sdvo_write_sdvox(intel_sdvo, sdvox);\n}\n\nstatic bool intel_sdvo_connector_get_hw_state(struct intel_connector *connector)\n{\n\tstruct intel_sdvo_connector *intel_sdvo_connector =\n\t\tto_intel_sdvo_connector(&connector->base);\n\tstruct intel_sdvo *intel_sdvo = intel_attached_sdvo(connector);\n\tu16 active_outputs = 0;\n\n\tintel_sdvo_get_active_outputs(intel_sdvo, &active_outputs);\n\n\treturn active_outputs & intel_sdvo_connector->output_flag;\n}\n\nbool intel_sdvo_port_enabled(struct drm_i915_private *dev_priv,\n\t\t\t     i915_reg_t sdvo_reg, enum pipe *pipe)\n{\n\tu32 val;\n\n\tval = intel_de_read(dev_priv, sdvo_reg);\n\n\t \n\tif (HAS_PCH_CPT(dev_priv))\n\t\t*pipe = (val & SDVO_PIPE_SEL_MASK_CPT) >> SDVO_PIPE_SEL_SHIFT_CPT;\n\telse if (IS_CHERRYVIEW(dev_priv))\n\t\t*pipe = (val & SDVO_PIPE_SEL_MASK_CHV) >> SDVO_PIPE_SEL_SHIFT_CHV;\n\telse\n\t\t*pipe = (val & SDVO_PIPE_SEL_MASK) >> SDVO_PIPE_SEL_SHIFT;\n\n\treturn val & SDVO_ENABLE;\n}\n\nstatic bool intel_sdvo_get_hw_state(struct intel_encoder *encoder,\n\t\t\t\t    enum pipe *pipe)\n{\n\tstruct drm_i915_private *dev_priv = to_i915(encoder->base.dev);\n\tstruct intel_sdvo *intel_sdvo = to_sdvo(encoder);\n\tu16 active_outputs = 0;\n\tbool ret;\n\n\tintel_sdvo_get_active_outputs(intel_sdvo, &active_outputs);\n\n\tret = intel_sdvo_port_enabled(dev_priv, intel_sdvo->sdvo_reg, pipe);\n\n\treturn ret || active_outputs;\n}\n\nstatic void intel_sdvo_get_config(struct intel_encoder *encoder,\n\t\t\t\t  struct intel_crtc_state *pipe_config)\n{\n\tstruct drm_device *dev = encoder->base.dev;\n\tstruct drm_i915_private *dev_priv = to_i915(dev);\n\tstruct intel_sdvo *intel_sdvo = to_sdvo(encoder);\n\tstruct intel_sdvo_dtd dtd;\n\tint encoder_pixel_multiplier = 0;\n\tint dotclock;\n\tu32 flags = 0, sdvox;\n\tu8 val;\n\tbool ret;\n\n\tpipe_config->output_types |= BIT(INTEL_OUTPUT_SDVO);\n\n\tsdvox = intel_de_read(dev_priv, intel_sdvo->sdvo_reg);\n\n\tret = intel_sdvo_get_input_timing(intel_sdvo, &dtd);\n\tif (!ret) {\n\t\t \n\t\tdrm_dbg(&dev_priv->drm, \"failed to retrieve SDVO DTD\\n\");\n\t\tpipe_config->quirks |= PIPE_CONFIG_QUIRK_MODE_SYNC_FLAGS;\n\t} else {\n\t\tif (dtd.part2.dtd_flags & DTD_FLAG_HSYNC_POSITIVE)\n\t\t\tflags |= DRM_MODE_FLAG_PHSYNC;\n\t\telse\n\t\t\tflags |= DRM_MODE_FLAG_NHSYNC;\n\n\t\tif (dtd.part2.dtd_flags & DTD_FLAG_VSYNC_POSITIVE)\n\t\t\tflags |= DRM_MODE_FLAG_PVSYNC;\n\t\telse\n\t\t\tflags |= DRM_MODE_FLAG_NVSYNC;\n\t}\n\n\tpipe_config->hw.adjusted_mode.flags |= flags;\n\n\t \n\tif (IS_I915G(dev_priv) || IS_I915GM(dev_priv)) {\n\t\tpipe_config->pixel_multiplier =\n\t\t\t((sdvox & SDVO_PORT_MULTIPLY_MASK)\n\t\t\t >> SDVO_PORT_MULTIPLY_SHIFT) + 1;\n\t}\n\n\tdotclock = pipe_config->port_clock;\n\n\tif (pipe_config->pixel_multiplier)\n\t\tdotclock /= pipe_config->pixel_multiplier;\n\n\tpipe_config->hw.adjusted_mode.crtc_clock = dotclock;\n\n\t \n\tif (intel_sdvo_get_value(intel_sdvo, SDVO_CMD_GET_CLOCK_RATE_MULT,\n\t\t\t\t &val, 1)) {\n\t\tswitch (val) {\n\t\tcase SDVO_CLOCK_RATE_MULT_1X:\n\t\t\tencoder_pixel_multiplier = 1;\n\t\t\tbreak;\n\t\tcase SDVO_CLOCK_RATE_MULT_2X:\n\t\t\tencoder_pixel_multiplier = 2;\n\t\t\tbreak;\n\t\tcase SDVO_CLOCK_RATE_MULT_4X:\n\t\t\tencoder_pixel_multiplier = 4;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tdrm_WARN(dev,\n\t\t encoder_pixel_multiplier != pipe_config->pixel_multiplier,\n\t\t \"SDVO pixel multiplier mismatch, port: %i, encoder: %i\\n\",\n\t\t pipe_config->pixel_multiplier, encoder_pixel_multiplier);\n\n\tif (intel_sdvo_get_value(intel_sdvo, SDVO_CMD_GET_COLORIMETRY,\n\t\t\t\t &val, 1)) {\n\t\tif (val == SDVO_COLORIMETRY_RGB220)\n\t\t\tpipe_config->limited_color_range = true;\n\t}\n\n\tif (intel_sdvo_get_value(intel_sdvo, SDVO_CMD_GET_AUDIO_STAT,\n\t\t\t\t &val, 1)) {\n\t\tif (val & SDVO_AUDIO_PRESENCE_DETECT)\n\t\t\tpipe_config->has_audio = true;\n\t}\n\n\tif (intel_sdvo_get_value(intel_sdvo, SDVO_CMD_GET_ENCODE,\n\t\t\t\t &val, 1)) {\n\t\tif (val == SDVO_ENCODE_HDMI)\n\t\t\tpipe_config->has_hdmi_sink = true;\n\t}\n\n\tintel_sdvo_get_avi_infoframe(intel_sdvo, pipe_config);\n\n\tintel_sdvo_get_eld(intel_sdvo, pipe_config);\n}\n\nstatic void intel_sdvo_disable_audio(struct intel_sdvo *intel_sdvo)\n{\n\tintel_sdvo_set_audio_state(intel_sdvo, 0);\n}\n\nstatic void intel_sdvo_enable_audio(struct intel_sdvo *intel_sdvo,\n\t\t\t\t    const struct intel_crtc_state *crtc_state,\n\t\t\t\t    const struct drm_connector_state *conn_state)\n{\n\tconst u8 *eld = crtc_state->eld;\n\n\tintel_sdvo_set_audio_state(intel_sdvo, 0);\n\n\tintel_sdvo_write_infoframe(intel_sdvo, SDVO_HBUF_INDEX_ELD,\n\t\t\t\t   SDVO_HBUF_TX_DISABLED,\n\t\t\t\t   eld, drm_eld_size(eld));\n\n\tintel_sdvo_set_audio_state(intel_sdvo, SDVO_AUDIO_ELD_VALID |\n\t\t\t\t   SDVO_AUDIO_PRESENCE_DETECT);\n}\n\nstatic void intel_disable_sdvo(struct intel_atomic_state *state,\n\t\t\t       struct intel_encoder *encoder,\n\t\t\t       const struct intel_crtc_state *old_crtc_state,\n\t\t\t       const struct drm_connector_state *conn_state)\n{\n\tstruct drm_i915_private *dev_priv = to_i915(encoder->base.dev);\n\tstruct intel_sdvo *intel_sdvo = to_sdvo(encoder);\n\tstruct intel_crtc *crtc = to_intel_crtc(old_crtc_state->uapi.crtc);\n\tu32 temp;\n\n\tif (old_crtc_state->has_audio)\n\t\tintel_sdvo_disable_audio(intel_sdvo);\n\n\tintel_sdvo_set_active_outputs(intel_sdvo, 0);\n\tif (0)\n\t\tintel_sdvo_set_encoder_power_state(intel_sdvo,\n\t\t\t\t\t\t   DRM_MODE_DPMS_OFF);\n\n\ttemp = intel_de_read(dev_priv, intel_sdvo->sdvo_reg);\n\n\ttemp &= ~SDVO_ENABLE;\n\tintel_sdvo_write_sdvox(intel_sdvo, temp);\n\n\t \n\tif (HAS_PCH_IBX(dev_priv) && crtc->pipe == PIPE_B) {\n\t\t \n\t\tintel_set_cpu_fifo_underrun_reporting(dev_priv, PIPE_A, false);\n\t\tintel_set_pch_fifo_underrun_reporting(dev_priv, PIPE_A, false);\n\n\t\ttemp &= ~SDVO_PIPE_SEL_MASK;\n\t\ttemp |= SDVO_ENABLE | SDVO_PIPE_SEL(PIPE_A);\n\t\tintel_sdvo_write_sdvox(intel_sdvo, temp);\n\n\t\ttemp &= ~SDVO_ENABLE;\n\t\tintel_sdvo_write_sdvox(intel_sdvo, temp);\n\n\t\tintel_wait_for_vblank_if_active(dev_priv, PIPE_A);\n\t\tintel_set_cpu_fifo_underrun_reporting(dev_priv, PIPE_A, true);\n\t\tintel_set_pch_fifo_underrun_reporting(dev_priv, PIPE_A, true);\n\t}\n}\n\nstatic void pch_disable_sdvo(struct intel_atomic_state *state,\n\t\t\t     struct intel_encoder *encoder,\n\t\t\t     const struct intel_crtc_state *old_crtc_state,\n\t\t\t     const struct drm_connector_state *old_conn_state)\n{\n}\n\nstatic void pch_post_disable_sdvo(struct intel_atomic_state *state,\n\t\t\t\t  struct intel_encoder *encoder,\n\t\t\t\t  const struct intel_crtc_state *old_crtc_state,\n\t\t\t\t  const struct drm_connector_state *old_conn_state)\n{\n\tintel_disable_sdvo(state, encoder, old_crtc_state, old_conn_state);\n}\n\nstatic void intel_enable_sdvo(struct intel_atomic_state *state,\n\t\t\t      struct intel_encoder *encoder,\n\t\t\t      const struct intel_crtc_state *pipe_config,\n\t\t\t      const struct drm_connector_state *conn_state)\n{\n\tstruct drm_device *dev = encoder->base.dev;\n\tstruct drm_i915_private *dev_priv = to_i915(dev);\n\tstruct intel_sdvo *intel_sdvo = to_sdvo(encoder);\n\tstruct intel_crtc *crtc = to_intel_crtc(pipe_config->uapi.crtc);\n\tu32 temp;\n\tbool input1, input2;\n\tint i;\n\tbool success;\n\n\ttemp = intel_de_read(dev_priv, intel_sdvo->sdvo_reg);\n\ttemp |= SDVO_ENABLE;\n\tintel_sdvo_write_sdvox(intel_sdvo, temp);\n\n\tfor (i = 0; i < 2; i++)\n\t\tintel_crtc_wait_for_next_vblank(crtc);\n\n\tsuccess = intel_sdvo_get_trained_inputs(intel_sdvo, &input1, &input2);\n\t \n\tif (success && !input1) {\n\t\tdrm_dbg_kms(&dev_priv->drm,\n\t\t\t    \"First %s output reported failure to \"\n\t\t\t    \"sync\\n\", SDVO_NAME(intel_sdvo));\n\t}\n\n\tif (0)\n\t\tintel_sdvo_set_encoder_power_state(intel_sdvo,\n\t\t\t\t\t\t   DRM_MODE_DPMS_ON);\n\tintel_sdvo_set_active_outputs(intel_sdvo, intel_sdvo->attached_output);\n\n\tif (pipe_config->has_audio)\n\t\tintel_sdvo_enable_audio(intel_sdvo, pipe_config, conn_state);\n}\n\nstatic enum drm_mode_status\nintel_sdvo_mode_valid(struct drm_connector *connector,\n\t\t      struct drm_display_mode *mode)\n{\n\tstruct drm_i915_private *i915 = to_i915(connector->dev);\n\tstruct intel_sdvo *intel_sdvo = intel_attached_sdvo(to_intel_connector(connector));\n\tstruct intel_sdvo_connector *intel_sdvo_connector =\n\t\tto_intel_sdvo_connector(connector);\n\tbool has_hdmi_sink = intel_has_hdmi_sink(intel_sdvo_connector, connector->state);\n\tint max_dotclk = i915->max_dotclk_freq;\n\tenum drm_mode_status status;\n\tint clock = mode->clock;\n\n\tstatus = intel_cpu_transcoder_mode_valid(i915, mode);\n\tif (status != MODE_OK)\n\t\treturn status;\n\n\tif (mode->flags & DRM_MODE_FLAG_DBLSCAN)\n\t\treturn MODE_NO_DBLESCAN;\n\n\tif (clock > max_dotclk)\n\t\treturn MODE_CLOCK_HIGH;\n\n\tif (mode->flags & DRM_MODE_FLAG_DBLCLK) {\n\t\tif (!has_hdmi_sink)\n\t\t\treturn MODE_CLOCK_LOW;\n\t\tclock *= 2;\n\t}\n\n\tif (intel_sdvo->pixel_clock_min > clock)\n\t\treturn MODE_CLOCK_LOW;\n\n\tif (intel_sdvo->pixel_clock_max < clock)\n\t\treturn MODE_CLOCK_HIGH;\n\n\tif (IS_LVDS(intel_sdvo_connector)) {\n\t\tenum drm_mode_status status;\n\n\t\tstatus = intel_panel_mode_valid(&intel_sdvo_connector->base, mode);\n\t\tif (status != MODE_OK)\n\t\t\treturn status;\n\t}\n\n\treturn MODE_OK;\n}\n\nstatic bool intel_sdvo_get_capabilities(struct intel_sdvo *intel_sdvo, struct intel_sdvo_caps *caps)\n{\n\tBUILD_BUG_ON(sizeof(*caps) != 8);\n\tif (!intel_sdvo_get_value(intel_sdvo,\n\t\t\t\t  SDVO_CMD_GET_DEVICE_CAPS,\n\t\t\t\t  caps, sizeof(*caps)))\n\t\treturn false;\n\n\tDRM_DEBUG_KMS(\"SDVO capabilities:\\n\"\n\t\t      \"  vendor_id: %d\\n\"\n\t\t      \"  device_id: %d\\n\"\n\t\t      \"  device_rev_id: %d\\n\"\n\t\t      \"  sdvo_version_major: %d\\n\"\n\t\t      \"  sdvo_version_minor: %d\\n\"\n\t\t      \"  sdvo_inputs_mask: %d\\n\"\n\t\t      \"  smooth_scaling: %d\\n\"\n\t\t      \"  sharp_scaling: %d\\n\"\n\t\t      \"  up_scaling: %d\\n\"\n\t\t      \"  down_scaling: %d\\n\"\n\t\t      \"  stall_support: %d\\n\"\n\t\t      \"  output_flags: %d\\n\",\n\t\t      caps->vendor_id,\n\t\t      caps->device_id,\n\t\t      caps->device_rev_id,\n\t\t      caps->sdvo_version_major,\n\t\t      caps->sdvo_version_minor,\n\t\t      caps->sdvo_inputs_mask,\n\t\t      caps->smooth_scaling,\n\t\t      caps->sharp_scaling,\n\t\t      caps->up_scaling,\n\t\t      caps->down_scaling,\n\t\t      caps->stall_support,\n\t\t      caps->output_flags);\n\n\treturn true;\n}\n\nstatic u8 intel_sdvo_get_colorimetry_cap(struct intel_sdvo *intel_sdvo)\n{\n\tu8 cap;\n\n\tif (!intel_sdvo_get_value(intel_sdvo, SDVO_CMD_GET_COLORIMETRY_CAP,\n\t\t\t\t  &cap, sizeof(cap)))\n\t\treturn SDVO_COLORIMETRY_RGB256;\n\n\treturn cap;\n}\n\nstatic u16 intel_sdvo_get_hotplug_support(struct intel_sdvo *intel_sdvo)\n{\n\tstruct drm_i915_private *dev_priv = to_i915(intel_sdvo->base.base.dev);\n\tu16 hotplug;\n\n\tif (!I915_HAS_HOTPLUG(dev_priv))\n\t\treturn 0;\n\n\t \n\tif (IS_I945G(dev_priv) || IS_I945GM(dev_priv))\n\t\treturn 0;\n\n\tif (!intel_sdvo_get_value(intel_sdvo, SDVO_CMD_GET_HOT_PLUG_SUPPORT,\n\t\t\t\t\t&hotplug, sizeof(hotplug)))\n\t\treturn 0;\n\n\treturn hotplug;\n}\n\nstatic void intel_sdvo_enable_hotplug(struct intel_encoder *encoder)\n{\n\tstruct intel_sdvo *intel_sdvo = to_sdvo(encoder);\n\n\tintel_sdvo_write_cmd(intel_sdvo, SDVO_CMD_SET_ACTIVE_HOT_PLUG,\n\t\t\t     &intel_sdvo->hotplug_active, 2);\n}\n\nstatic enum intel_hotplug_state\nintel_sdvo_hotplug(struct intel_encoder *encoder,\n\t\t   struct intel_connector *connector)\n{\n\tintel_sdvo_enable_hotplug(encoder);\n\n\treturn intel_encoder_hotplug(encoder, connector);\n}\n\nstatic bool\nintel_sdvo_multifunc_encoder(struct intel_sdvo *intel_sdvo)\n{\n\t \n\treturn hweight16(intel_sdvo->caps.output_flags) > 1;\n}\n\nstatic const struct drm_edid *\nintel_sdvo_get_edid(struct drm_connector *connector)\n{\n\tstruct intel_sdvo *sdvo = intel_attached_sdvo(to_intel_connector(connector));\n\treturn drm_edid_read_ddc(connector, &sdvo->ddc);\n}\n\n \nstatic const struct drm_edid *\nintel_sdvo_get_analog_edid(struct drm_connector *connector)\n{\n\tstruct drm_i915_private *i915 = to_i915(connector->dev);\n\tstruct i2c_adapter *i2c;\n\n\ti2c = intel_gmbus_get_adapter(i915, i915->display.vbt.crt_ddc_pin);\n\n\treturn drm_edid_read_ddc(connector, i2c);\n}\n\nstatic enum drm_connector_status\nintel_sdvo_tmds_sink_detect(struct drm_connector *connector)\n{\n\tstruct intel_sdvo *intel_sdvo = intel_attached_sdvo(to_intel_connector(connector));\n\tenum drm_connector_status status;\n\tconst struct drm_edid *drm_edid;\n\n\tdrm_edid = intel_sdvo_get_edid(connector);\n\n\tif (!drm_edid && intel_sdvo_multifunc_encoder(intel_sdvo)) {\n\t\tu8 ddc, saved_ddc = intel_sdvo->ddc_bus;\n\n\t\t \n\t\tfor (ddc = intel_sdvo->ddc_bus >> 1; ddc > 1; ddc >>= 1) {\n\t\t\tintel_sdvo->ddc_bus = ddc;\n\t\t\tdrm_edid = intel_sdvo_get_edid(connector);\n\t\t\tif (drm_edid)\n\t\t\t\tbreak;\n\t\t}\n\t\t \n\t\tif (!drm_edid)\n\t\t\tintel_sdvo->ddc_bus = saved_ddc;\n\t}\n\n\t \n\tif (!drm_edid)\n\t\tdrm_edid = intel_sdvo_get_analog_edid(connector);\n\n\tstatus = connector_status_unknown;\n\tif (drm_edid) {\n\t\tconst struct edid *edid = drm_edid_raw(drm_edid);\n\n\t\t \n\t\tif (edid && edid->input & DRM_EDID_INPUT_DIGITAL)\n\t\t\tstatus = connector_status_connected;\n\t\telse\n\t\t\tstatus = connector_status_disconnected;\n\t\tdrm_edid_free(drm_edid);\n\t}\n\n\treturn status;\n}\n\nstatic bool\nintel_sdvo_connector_matches_edid(struct intel_sdvo_connector *sdvo,\n\t\t\t\t  const struct drm_edid *drm_edid)\n{\n\tconst struct edid *edid = drm_edid_raw(drm_edid);\n\tbool monitor_is_digital = !!(edid->input & DRM_EDID_INPUT_DIGITAL);\n\tbool connector_is_digital = !!IS_DIGITAL(sdvo);\n\n\tDRM_DEBUG_KMS(\"connector_is_digital? %d, monitor_is_digital? %d\\n\",\n\t\t      connector_is_digital, monitor_is_digital);\n\treturn connector_is_digital == monitor_is_digital;\n}\n\nstatic enum drm_connector_status\nintel_sdvo_detect(struct drm_connector *connector, bool force)\n{\n\tstruct drm_i915_private *i915 = to_i915(connector->dev);\n\tstruct intel_sdvo *intel_sdvo = intel_attached_sdvo(to_intel_connector(connector));\n\tstruct intel_sdvo_connector *intel_sdvo_connector = to_intel_sdvo_connector(connector);\n\tenum drm_connector_status ret;\n\tu16 response;\n\n\tDRM_DEBUG_KMS(\"[CONNECTOR:%d:%s]\\n\",\n\t\t      connector->base.id, connector->name);\n\n\tif (!INTEL_DISPLAY_ENABLED(i915))\n\t\treturn connector_status_disconnected;\n\n\tif (!intel_sdvo_get_value(intel_sdvo,\n\t\t\t\t  SDVO_CMD_GET_ATTACHED_DISPLAYS,\n\t\t\t\t  &response, 2))\n\t\treturn connector_status_unknown;\n\n\tDRM_DEBUG_KMS(\"SDVO response %d %d [%x]\\n\",\n\t\t      response & 0xff, response >> 8,\n\t\t      intel_sdvo_connector->output_flag);\n\n\tif (response == 0)\n\t\treturn connector_status_disconnected;\n\n\tintel_sdvo->attached_output = response;\n\n\tif ((intel_sdvo_connector->output_flag & response) == 0)\n\t\tret = connector_status_disconnected;\n\telse if (IS_TMDS(intel_sdvo_connector))\n\t\tret = intel_sdvo_tmds_sink_detect(connector);\n\telse {\n\t\tconst struct drm_edid *drm_edid;\n\n\t\t \n\t\tdrm_edid = intel_sdvo_get_edid(connector);\n\t\tif (!drm_edid)\n\t\t\tdrm_edid = intel_sdvo_get_analog_edid(connector);\n\t\tif (drm_edid) {\n\t\t\tif (intel_sdvo_connector_matches_edid(intel_sdvo_connector,\n\t\t\t\t\t\t\t      drm_edid))\n\t\t\t\tret = connector_status_connected;\n\t\t\telse\n\t\t\t\tret = connector_status_disconnected;\n\n\t\t\tdrm_edid_free(drm_edid);\n\t\t} else {\n\t\t\tret = connector_status_connected;\n\t\t}\n\t}\n\n\treturn ret;\n}\n\nstatic int intel_sdvo_get_ddc_modes(struct drm_connector *connector)\n{\n\tint num_modes = 0;\n\tconst struct drm_edid *drm_edid;\n\n\tDRM_DEBUG_KMS(\"[CONNECTOR:%d:%s]\\n\",\n\t\t      connector->base.id, connector->name);\n\n\t \n\tdrm_edid = intel_sdvo_get_edid(connector);\n\n\t \n\tif (!drm_edid)\n\t\tdrm_edid = intel_sdvo_get_analog_edid(connector);\n\n\tif (!drm_edid)\n\t\treturn 0;\n\n\tif (intel_sdvo_connector_matches_edid(to_intel_sdvo_connector(connector),\n\t\t\t\t\t      drm_edid))\n\t\tnum_modes += intel_connector_update_modes(connector, drm_edid);\n\n\tdrm_edid_free(drm_edid);\n\n\treturn num_modes;\n}\n\n \nstatic const struct drm_display_mode sdvo_tv_modes[] = {\n\t{ DRM_MODE(\"320x200\", DRM_MODE_TYPE_DRIVER, 5815, 320, 321, 384,\n\t\t   416, 0, 200, 201, 232, 233, 0,\n\t\t   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC) },\n\t{ DRM_MODE(\"320x240\", DRM_MODE_TYPE_DRIVER, 6814, 320, 321, 384,\n\t\t   416, 0, 240, 241, 272, 273, 0,\n\t\t   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC) },\n\t{ DRM_MODE(\"400x300\", DRM_MODE_TYPE_DRIVER, 9910, 400, 401, 464,\n\t\t   496, 0, 300, 301, 332, 333, 0,\n\t\t   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC) },\n\t{ DRM_MODE(\"640x350\", DRM_MODE_TYPE_DRIVER, 16913, 640, 641, 704,\n\t\t   736, 0, 350, 351, 382, 383, 0,\n\t\t   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC) },\n\t{ DRM_MODE(\"640x400\", DRM_MODE_TYPE_DRIVER, 19121, 640, 641, 704,\n\t\t   736, 0, 400, 401, 432, 433, 0,\n\t\t   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC) },\n\t{ DRM_MODE(\"640x480\", DRM_MODE_TYPE_DRIVER, 22654, 640, 641, 704,\n\t\t   736, 0, 480, 481, 512, 513, 0,\n\t\t   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC) },\n\t{ DRM_MODE(\"704x480\", DRM_MODE_TYPE_DRIVER, 24624, 704, 705, 768,\n\t\t   800, 0, 480, 481, 512, 513, 0,\n\t\t   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC) },\n\t{ DRM_MODE(\"704x576\", DRM_MODE_TYPE_DRIVER, 29232, 704, 705, 768,\n\t\t   800, 0, 576, 577, 608, 609, 0,\n\t\t   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC) },\n\t{ DRM_MODE(\"720x350\", DRM_MODE_TYPE_DRIVER, 18751, 720, 721, 784,\n\t\t   816, 0, 350, 351, 382, 383, 0,\n\t\t   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC) },\n\t{ DRM_MODE(\"720x400\", DRM_MODE_TYPE_DRIVER, 21199, 720, 721, 784,\n\t\t   816, 0, 400, 401, 432, 433, 0,\n\t\t   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC) },\n\t{ DRM_MODE(\"720x480\", DRM_MODE_TYPE_DRIVER, 25116, 720, 721, 784,\n\t\t   816, 0, 480, 481, 512, 513, 0,\n\t\t   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC) },\n\t{ DRM_MODE(\"720x540\", DRM_MODE_TYPE_DRIVER, 28054, 720, 721, 784,\n\t\t   816, 0, 540, 541, 572, 573, 0,\n\t\t   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC) },\n\t{ DRM_MODE(\"720x576\", DRM_MODE_TYPE_DRIVER, 29816, 720, 721, 784,\n\t\t   816, 0, 576, 577, 608, 609, 0,\n\t\t   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC) },\n\t{ DRM_MODE(\"768x576\", DRM_MODE_TYPE_DRIVER, 31570, 768, 769, 832,\n\t\t   864, 0, 576, 577, 608, 609, 0,\n\t\t   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC) },\n\t{ DRM_MODE(\"800x600\", DRM_MODE_TYPE_DRIVER, 34030, 800, 801, 864,\n\t\t   896, 0, 600, 601, 632, 633, 0,\n\t\t   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC) },\n\t{ DRM_MODE(\"832x624\", DRM_MODE_TYPE_DRIVER, 36581, 832, 833, 896,\n\t\t   928, 0, 624, 625, 656, 657, 0,\n\t\t   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC) },\n\t{ DRM_MODE(\"920x766\", DRM_MODE_TYPE_DRIVER, 48707, 920, 921, 984,\n\t\t   1016, 0, 766, 767, 798, 799, 0,\n\t\t   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC) },\n\t{ DRM_MODE(\"1024x768\", DRM_MODE_TYPE_DRIVER, 53827, 1024, 1025, 1088,\n\t\t   1120, 0, 768, 769, 800, 801, 0,\n\t\t   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC) },\n\t{ DRM_MODE(\"1280x1024\", DRM_MODE_TYPE_DRIVER, 87265, 1280, 1281, 1344,\n\t\t   1376, 0, 1024, 1025, 1056, 1057, 0,\n\t\t   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC) },\n};\n\nstatic int intel_sdvo_get_tv_modes(struct drm_connector *connector)\n{\n\tstruct intel_sdvo *intel_sdvo = intel_attached_sdvo(to_intel_connector(connector));\n\tconst struct drm_connector_state *conn_state = connector->state;\n\tstruct intel_sdvo_sdtv_resolution_request tv_res;\n\tu32 reply = 0, format_map = 0;\n\tint num_modes = 0;\n\tint i;\n\n\tDRM_DEBUG_KMS(\"[CONNECTOR:%d:%s]\\n\",\n\t\t      connector->base.id, connector->name);\n\n\t \n\tformat_map = 1 << conn_state->tv.mode;\n\tmemcpy(&tv_res, &format_map,\n\t       min(sizeof(format_map), sizeof(struct intel_sdvo_sdtv_resolution_request)));\n\n\tif (!intel_sdvo_set_target_output(intel_sdvo, intel_sdvo->attached_output))\n\t\treturn 0;\n\n\tBUILD_BUG_ON(sizeof(tv_res) != 3);\n\tif (!intel_sdvo_write_cmd(intel_sdvo,\n\t\t\t\t  SDVO_CMD_GET_SDTV_RESOLUTION_SUPPORT,\n\t\t\t\t  &tv_res, sizeof(tv_res)))\n\t\treturn 0;\n\tif (!intel_sdvo_read_response(intel_sdvo, &reply, 3))\n\t\treturn 0;\n\n\tfor (i = 0; i < ARRAY_SIZE(sdvo_tv_modes); i++) {\n\t\tif (reply & (1 << i)) {\n\t\t\tstruct drm_display_mode *nmode;\n\t\t\tnmode = drm_mode_duplicate(connector->dev,\n\t\t\t\t\t\t   &sdvo_tv_modes[i]);\n\t\t\tif (nmode) {\n\t\t\t\tdrm_mode_probed_add(connector, nmode);\n\t\t\t\tnum_modes++;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn num_modes;\n}\n\nstatic int intel_sdvo_get_lvds_modes(struct drm_connector *connector)\n{\n\tstruct drm_i915_private *dev_priv = to_i915(connector->dev);\n\n\tdrm_dbg_kms(&dev_priv->drm, \"[CONNECTOR:%d:%s]\\n\",\n\t\t    connector->base.id, connector->name);\n\n\treturn intel_panel_get_modes(to_intel_connector(connector));\n}\n\nstatic int intel_sdvo_get_modes(struct drm_connector *connector)\n{\n\tstruct intel_sdvo_connector *intel_sdvo_connector = to_intel_sdvo_connector(connector);\n\n\tif (IS_TV(intel_sdvo_connector))\n\t\treturn intel_sdvo_get_tv_modes(connector);\n\telse if (IS_LVDS(intel_sdvo_connector))\n\t\treturn intel_sdvo_get_lvds_modes(connector);\n\telse\n\t\treturn intel_sdvo_get_ddc_modes(connector);\n}\n\nstatic int\nintel_sdvo_connector_atomic_get_property(struct drm_connector *connector,\n\t\t\t\t\t const struct drm_connector_state *state,\n\t\t\t\t\t struct drm_property *property,\n\t\t\t\t\t u64 *val)\n{\n\tstruct intel_sdvo_connector *intel_sdvo_connector = to_intel_sdvo_connector(connector);\n\tconst struct intel_sdvo_connector_state *sdvo_state = to_intel_sdvo_connector_state((void *)state);\n\n\tif (property == intel_sdvo_connector->tv_format) {\n\t\tint i;\n\n\t\tfor (i = 0; i < intel_sdvo_connector->format_supported_num; i++)\n\t\t\tif (state->tv.mode == intel_sdvo_connector->tv_format_supported[i]) {\n\t\t\t\t*val = i;\n\n\t\t\t\treturn 0;\n\t\t\t}\n\n\t\tdrm_WARN_ON(connector->dev, 1);\n\t\t*val = 0;\n\t} else if (property == intel_sdvo_connector->top ||\n\t\t   property == intel_sdvo_connector->bottom)\n\t\t*val = intel_sdvo_connector->max_vscan - sdvo_state->tv.overscan_v;\n\telse if (property == intel_sdvo_connector->left ||\n\t\t property == intel_sdvo_connector->right)\n\t\t*val = intel_sdvo_connector->max_hscan - sdvo_state->tv.overscan_h;\n\telse if (property == intel_sdvo_connector->hpos)\n\t\t*val = sdvo_state->tv.hpos;\n\telse if (property == intel_sdvo_connector->vpos)\n\t\t*val = sdvo_state->tv.vpos;\n\telse if (property == intel_sdvo_connector->saturation)\n\t\t*val = state->tv.saturation;\n\telse if (property == intel_sdvo_connector->contrast)\n\t\t*val = state->tv.contrast;\n\telse if (property == intel_sdvo_connector->hue)\n\t\t*val = state->tv.hue;\n\telse if (property == intel_sdvo_connector->brightness)\n\t\t*val = state->tv.brightness;\n\telse if (property == intel_sdvo_connector->sharpness)\n\t\t*val = sdvo_state->tv.sharpness;\n\telse if (property == intel_sdvo_connector->flicker_filter)\n\t\t*val = sdvo_state->tv.flicker_filter;\n\telse if (property == intel_sdvo_connector->flicker_filter_2d)\n\t\t*val = sdvo_state->tv.flicker_filter_2d;\n\telse if (property == intel_sdvo_connector->flicker_filter_adaptive)\n\t\t*val = sdvo_state->tv.flicker_filter_adaptive;\n\telse if (property == intel_sdvo_connector->tv_chroma_filter)\n\t\t*val = sdvo_state->tv.chroma_filter;\n\telse if (property == intel_sdvo_connector->tv_luma_filter)\n\t\t*val = sdvo_state->tv.luma_filter;\n\telse if (property == intel_sdvo_connector->dot_crawl)\n\t\t*val = sdvo_state->tv.dot_crawl;\n\telse\n\t\treturn intel_digital_connector_atomic_get_property(connector, state, property, val);\n\n\treturn 0;\n}\n\nstatic int\nintel_sdvo_connector_atomic_set_property(struct drm_connector *connector,\n\t\t\t\t\t struct drm_connector_state *state,\n\t\t\t\t\t struct drm_property *property,\n\t\t\t\t\t u64 val)\n{\n\tstruct intel_sdvo_connector *intel_sdvo_connector = to_intel_sdvo_connector(connector);\n\tstruct intel_sdvo_connector_state *sdvo_state = to_intel_sdvo_connector_state(state);\n\n\tif (property == intel_sdvo_connector->tv_format) {\n\t\tstate->tv.mode = intel_sdvo_connector->tv_format_supported[val];\n\n\t\tif (state->crtc) {\n\t\t\tstruct drm_crtc_state *crtc_state =\n\t\t\t\tdrm_atomic_get_new_crtc_state(state->state, state->crtc);\n\n\t\t\tcrtc_state->connectors_changed = true;\n\t\t}\n\t} else if (property == intel_sdvo_connector->top ||\n\t\t   property == intel_sdvo_connector->bottom)\n\t\t \n\t\tsdvo_state->tv.overscan_v = intel_sdvo_connector->max_vscan - val;\n\telse if (property == intel_sdvo_connector->left ||\n\t\t property == intel_sdvo_connector->right)\n\t\t \n\t\tsdvo_state->tv.overscan_h = intel_sdvo_connector->max_hscan - val;\n\telse if (property == intel_sdvo_connector->hpos)\n\t\tsdvo_state->tv.hpos = val;\n\telse if (property == intel_sdvo_connector->vpos)\n\t\tsdvo_state->tv.vpos = val;\n\telse if (property == intel_sdvo_connector->saturation)\n\t\tstate->tv.saturation = val;\n\telse if (property == intel_sdvo_connector->contrast)\n\t\tstate->tv.contrast = val;\n\telse if (property == intel_sdvo_connector->hue)\n\t\tstate->tv.hue = val;\n\telse if (property == intel_sdvo_connector->brightness)\n\t\tstate->tv.brightness = val;\n\telse if (property == intel_sdvo_connector->sharpness)\n\t\tsdvo_state->tv.sharpness = val;\n\telse if (property == intel_sdvo_connector->flicker_filter)\n\t\tsdvo_state->tv.flicker_filter = val;\n\telse if (property == intel_sdvo_connector->flicker_filter_2d)\n\t\tsdvo_state->tv.flicker_filter_2d = val;\n\telse if (property == intel_sdvo_connector->flicker_filter_adaptive)\n\t\tsdvo_state->tv.flicker_filter_adaptive = val;\n\telse if (property == intel_sdvo_connector->tv_chroma_filter)\n\t\tsdvo_state->tv.chroma_filter = val;\n\telse if (property == intel_sdvo_connector->tv_luma_filter)\n\t\tsdvo_state->tv.luma_filter = val;\n\telse if (property == intel_sdvo_connector->dot_crawl)\n\t\tsdvo_state->tv.dot_crawl = val;\n\telse\n\t\treturn intel_digital_connector_atomic_set_property(connector, state, property, val);\n\n\treturn 0;\n}\n\nstatic int\nintel_sdvo_connector_register(struct drm_connector *connector)\n{\n\tstruct intel_sdvo *sdvo = intel_attached_sdvo(to_intel_connector(connector));\n\tint ret;\n\n\tret = intel_connector_register(connector);\n\tif (ret)\n\t\treturn ret;\n\n\treturn sysfs_create_link(&connector->kdev->kobj,\n\t\t\t\t &sdvo->ddc.dev.kobj,\n\t\t\t\t sdvo->ddc.dev.kobj.name);\n}\n\nstatic void\nintel_sdvo_connector_unregister(struct drm_connector *connector)\n{\n\tstruct intel_sdvo *sdvo = intel_attached_sdvo(to_intel_connector(connector));\n\n\tsysfs_remove_link(&connector->kdev->kobj,\n\t\t\t  sdvo->ddc.dev.kobj.name);\n\tintel_connector_unregister(connector);\n}\n\nstatic struct drm_connector_state *\nintel_sdvo_connector_duplicate_state(struct drm_connector *connector)\n{\n\tstruct intel_sdvo_connector_state *state;\n\n\tstate = kmemdup(connector->state, sizeof(*state), GFP_KERNEL);\n\tif (!state)\n\t\treturn NULL;\n\n\t__drm_atomic_helper_connector_duplicate_state(connector, &state->base.base);\n\treturn &state->base.base;\n}\n\nstatic const struct drm_connector_funcs intel_sdvo_connector_funcs = {\n\t.detect = intel_sdvo_detect,\n\t.fill_modes = drm_helper_probe_single_connector_modes,\n\t.atomic_get_property = intel_sdvo_connector_atomic_get_property,\n\t.atomic_set_property = intel_sdvo_connector_atomic_set_property,\n\t.late_register = intel_sdvo_connector_register,\n\t.early_unregister = intel_sdvo_connector_unregister,\n\t.destroy = intel_connector_destroy,\n\t.atomic_destroy_state = drm_atomic_helper_connector_destroy_state,\n\t.atomic_duplicate_state = intel_sdvo_connector_duplicate_state,\n};\n\nstatic int intel_sdvo_atomic_check(struct drm_connector *conn,\n\t\t\t\t   struct drm_atomic_state *state)\n{\n\tstruct drm_connector_state *new_conn_state =\n\t\tdrm_atomic_get_new_connector_state(state, conn);\n\tstruct drm_connector_state *old_conn_state =\n\t\tdrm_atomic_get_old_connector_state(state, conn);\n\tstruct intel_sdvo_connector_state *old_state =\n\t\tto_intel_sdvo_connector_state(old_conn_state);\n\tstruct intel_sdvo_connector_state *new_state =\n\t\tto_intel_sdvo_connector_state(new_conn_state);\n\n\tif (new_conn_state->crtc &&\n\t    (memcmp(&old_state->tv, &new_state->tv, sizeof(old_state->tv)) ||\n\t     memcmp(&old_conn_state->tv, &new_conn_state->tv, sizeof(old_conn_state->tv)))) {\n\t\tstruct drm_crtc_state *crtc_state =\n\t\t\tdrm_atomic_get_new_crtc_state(state,\n\t\t\t\t\t\t      new_conn_state->crtc);\n\n\t\tcrtc_state->connectors_changed = true;\n\t}\n\n\treturn intel_digital_connector_atomic_check(conn, state);\n}\n\nstatic const struct drm_connector_helper_funcs intel_sdvo_connector_helper_funcs = {\n\t.get_modes = intel_sdvo_get_modes,\n\t.mode_valid = intel_sdvo_mode_valid,\n\t.atomic_check = intel_sdvo_atomic_check,\n};\n\nstatic void intel_sdvo_enc_destroy(struct drm_encoder *encoder)\n{\n\tstruct intel_sdvo *intel_sdvo = to_sdvo(to_intel_encoder(encoder));\n\n\ti2c_del_adapter(&intel_sdvo->ddc);\n\tintel_encoder_destroy(encoder);\n}\n\nstatic const struct drm_encoder_funcs intel_sdvo_enc_funcs = {\n\t.destroy = intel_sdvo_enc_destroy,\n};\n\nstatic void\nintel_sdvo_guess_ddc_bus(struct intel_sdvo *sdvo)\n{\n\tu16 mask = 0;\n\tunsigned int num_bits;\n\n\t \n\tswitch (sdvo->controlled_output) {\n\tcase SDVO_OUTPUT_LVDS1:\n\t\tmask |= SDVO_OUTPUT_LVDS1;\n\t\tfallthrough;\n\tcase SDVO_OUTPUT_LVDS0:\n\t\tmask |= SDVO_OUTPUT_LVDS0;\n\t\tfallthrough;\n\tcase SDVO_OUTPUT_TMDS1:\n\t\tmask |= SDVO_OUTPUT_TMDS1;\n\t\tfallthrough;\n\tcase SDVO_OUTPUT_TMDS0:\n\t\tmask |= SDVO_OUTPUT_TMDS0;\n\t\tfallthrough;\n\tcase SDVO_OUTPUT_RGB1:\n\t\tmask |= SDVO_OUTPUT_RGB1;\n\t\tfallthrough;\n\tcase SDVO_OUTPUT_RGB0:\n\t\tmask |= SDVO_OUTPUT_RGB0;\n\t\tbreak;\n\t}\n\n\t \n\tmask &= sdvo->caps.output_flags;\n\tnum_bits = hweight16(mask);\n\t \n\tif (num_bits > 3)\n\t\tnum_bits = 3;\n\n\t \n\tsdvo->ddc_bus = 1 << num_bits;\n}\n\n \nstatic void\nintel_sdvo_select_ddc_bus(struct drm_i915_private *dev_priv,\n\t\t\t  struct intel_sdvo *sdvo)\n{\n\tstruct sdvo_device_mapping *mapping;\n\n\tif (sdvo->port == PORT_B)\n\t\tmapping = &dev_priv->display.vbt.sdvo_mappings[0];\n\telse\n\t\tmapping = &dev_priv->display.vbt.sdvo_mappings[1];\n\n\tif (mapping->initialized)\n\t\tsdvo->ddc_bus = 1 << ((mapping->ddc_pin & 0xf0) >> 4);\n\telse\n\t\tintel_sdvo_guess_ddc_bus(sdvo);\n}\n\nstatic void\nintel_sdvo_select_i2c_bus(struct drm_i915_private *dev_priv,\n\t\t\t  struct intel_sdvo *sdvo)\n{\n\tstruct sdvo_device_mapping *mapping;\n\tu8 pin;\n\n\tif (sdvo->port == PORT_B)\n\t\tmapping = &dev_priv->display.vbt.sdvo_mappings[0];\n\telse\n\t\tmapping = &dev_priv->display.vbt.sdvo_mappings[1];\n\n\tif (mapping->initialized &&\n\t    intel_gmbus_is_valid_pin(dev_priv, mapping->i2c_pin))\n\t\tpin = mapping->i2c_pin;\n\telse\n\t\tpin = GMBUS_PIN_DPB;\n\n\tsdvo->i2c = intel_gmbus_get_adapter(dev_priv, pin);\n\n\t \n\tintel_gmbus_force_bit(sdvo->i2c, true);\n}\n\n \nstatic void\nintel_sdvo_unselect_i2c_bus(struct intel_sdvo *sdvo)\n{\n\tintel_gmbus_force_bit(sdvo->i2c, false);\n}\n\nstatic bool\nintel_sdvo_is_hdmi_connector(struct intel_sdvo *intel_sdvo)\n{\n\treturn intel_sdvo_check_supp_encode(intel_sdvo);\n}\n\nstatic u8\nintel_sdvo_get_slave_addr(struct drm_i915_private *dev_priv,\n\t\t\t  struct intel_sdvo *sdvo)\n{\n\tstruct sdvo_device_mapping *my_mapping, *other_mapping;\n\n\tif (sdvo->port == PORT_B) {\n\t\tmy_mapping = &dev_priv->display.vbt.sdvo_mappings[0];\n\t\tother_mapping = &dev_priv->display.vbt.sdvo_mappings[1];\n\t} else {\n\t\tmy_mapping = &dev_priv->display.vbt.sdvo_mappings[1];\n\t\tother_mapping = &dev_priv->display.vbt.sdvo_mappings[0];\n\t}\n\n\t \n\tif (my_mapping->slave_addr)\n\t\treturn my_mapping->slave_addr;\n\n\t \n\tif (other_mapping->slave_addr) {\n\t\tif (other_mapping->slave_addr == 0x70)\n\t\t\treturn 0x72;\n\t\telse\n\t\t\treturn 0x70;\n\t}\n\n\t \n\tif (sdvo->port == PORT_B)\n\t\treturn 0x70;\n\telse\n\t\treturn 0x72;\n}\n\nstatic int\nintel_sdvo_connector_init(struct intel_sdvo_connector *connector,\n\t\t\t  struct intel_sdvo *encoder)\n{\n\tstruct drm_connector *drm_connector;\n\tint ret;\n\n\tdrm_connector = &connector->base.base;\n\tret = drm_connector_init(encoder->base.base.dev,\n\t\t\t   drm_connector,\n\t\t\t   &intel_sdvo_connector_funcs,\n\t\t\t   connector->base.base.connector_type);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tdrm_connector_helper_add(drm_connector,\n\t\t\t\t &intel_sdvo_connector_helper_funcs);\n\n\tconnector->base.base.display_info.subpixel_order = SubPixelHorizontalRGB;\n\tconnector->base.base.interlace_allowed = true;\n\tconnector->base.get_hw_state = intel_sdvo_connector_get_hw_state;\n\n\tintel_connector_attach_encoder(&connector->base, &encoder->base);\n\n\treturn 0;\n}\n\nstatic void\nintel_sdvo_add_hdmi_properties(struct intel_sdvo *intel_sdvo,\n\t\t\t       struct intel_sdvo_connector *connector)\n{\n\tintel_attach_force_audio_property(&connector->base.base);\n\tif (intel_sdvo->colorimetry_cap & SDVO_COLORIMETRY_RGB220)\n\t\tintel_attach_broadcast_rgb_property(&connector->base.base);\n\tintel_attach_aspect_ratio_property(&connector->base.base);\n}\n\nstatic struct intel_sdvo_connector *intel_sdvo_connector_alloc(void)\n{\n\tstruct intel_sdvo_connector *sdvo_connector;\n\tstruct intel_sdvo_connector_state *conn_state;\n\n\tsdvo_connector = kzalloc(sizeof(*sdvo_connector), GFP_KERNEL);\n\tif (!sdvo_connector)\n\t\treturn NULL;\n\n\tconn_state = kzalloc(sizeof(*conn_state), GFP_KERNEL);\n\tif (!conn_state) {\n\t\tkfree(sdvo_connector);\n\t\treturn NULL;\n\t}\n\n\t__drm_atomic_helper_connector_reset(&sdvo_connector->base.base,\n\t\t\t\t\t    &conn_state->base.base);\n\n\tintel_panel_init_alloc(&sdvo_connector->base);\n\n\treturn sdvo_connector;\n}\n\nstatic bool\nintel_sdvo_dvi_init(struct intel_sdvo *intel_sdvo, u16 type)\n{\n\tstruct drm_encoder *encoder = &intel_sdvo->base.base;\n\tstruct drm_connector *connector;\n\tstruct intel_encoder *intel_encoder = to_intel_encoder(encoder);\n\tstruct intel_connector *intel_connector;\n\tstruct intel_sdvo_connector *intel_sdvo_connector;\n\n\tDRM_DEBUG_KMS(\"initialising DVI type 0x%x\\n\", type);\n\n\tintel_sdvo_connector = intel_sdvo_connector_alloc();\n\tif (!intel_sdvo_connector)\n\t\treturn false;\n\n\tintel_sdvo_connector->output_flag = type;\n\n\tintel_connector = &intel_sdvo_connector->base;\n\tconnector = &intel_connector->base;\n\tif (intel_sdvo_get_hotplug_support(intel_sdvo) &\n\t\tintel_sdvo_connector->output_flag) {\n\t\tintel_sdvo->hotplug_active |= intel_sdvo_connector->output_flag;\n\t\t \n\t\tintel_connector->polled = DRM_CONNECTOR_POLL_HPD;\n\t\tintel_encoder->hotplug = intel_sdvo_hotplug;\n\t\tintel_sdvo_enable_hotplug(intel_encoder);\n\t} else {\n\t\tintel_connector->polled = DRM_CONNECTOR_POLL_CONNECT | DRM_CONNECTOR_POLL_DISCONNECT;\n\t}\n\tencoder->encoder_type = DRM_MODE_ENCODER_TMDS;\n\tconnector->connector_type = DRM_MODE_CONNECTOR_DVID;\n\n\tif (intel_sdvo_is_hdmi_connector(intel_sdvo)) {\n\t\tconnector->connector_type = DRM_MODE_CONNECTOR_HDMIA;\n\t\tintel_sdvo_connector->is_hdmi = true;\n\t}\n\n\tif (intel_sdvo_connector_init(intel_sdvo_connector, intel_sdvo) < 0) {\n\t\tkfree(intel_sdvo_connector);\n\t\treturn false;\n\t}\n\n\tif (intel_sdvo_connector->is_hdmi)\n\t\tintel_sdvo_add_hdmi_properties(intel_sdvo, intel_sdvo_connector);\n\n\treturn true;\n}\n\nstatic bool\nintel_sdvo_tv_init(struct intel_sdvo *intel_sdvo, u16 type)\n{\n\tstruct drm_encoder *encoder = &intel_sdvo->base.base;\n\tstruct drm_connector *connector;\n\tstruct intel_connector *intel_connector;\n\tstruct intel_sdvo_connector *intel_sdvo_connector;\n\n\tDRM_DEBUG_KMS(\"initialising TV type 0x%x\\n\", type);\n\n\tintel_sdvo_connector = intel_sdvo_connector_alloc();\n\tif (!intel_sdvo_connector)\n\t\treturn false;\n\n\tintel_connector = &intel_sdvo_connector->base;\n\tconnector = &intel_connector->base;\n\tencoder->encoder_type = DRM_MODE_ENCODER_TVDAC;\n\tconnector->connector_type = DRM_MODE_CONNECTOR_SVIDEO;\n\n\tintel_sdvo_connector->output_flag = type;\n\n\tif (intel_sdvo_connector_init(intel_sdvo_connector, intel_sdvo) < 0) {\n\t\tkfree(intel_sdvo_connector);\n\t\treturn false;\n\t}\n\n\tif (!intel_sdvo_tv_create_property(intel_sdvo, intel_sdvo_connector, type))\n\t\tgoto err;\n\n\tif (!intel_sdvo_create_enhance_property(intel_sdvo, intel_sdvo_connector))\n\t\tgoto err;\n\n\treturn true;\n\nerr:\n\tintel_connector_destroy(connector);\n\treturn false;\n}\n\nstatic bool\nintel_sdvo_analog_init(struct intel_sdvo *intel_sdvo, u16 type)\n{\n\tstruct drm_encoder *encoder = &intel_sdvo->base.base;\n\tstruct drm_connector *connector;\n\tstruct intel_connector *intel_connector;\n\tstruct intel_sdvo_connector *intel_sdvo_connector;\n\n\tDRM_DEBUG_KMS(\"initialising analog type 0x%x\\n\", type);\n\n\tintel_sdvo_connector = intel_sdvo_connector_alloc();\n\tif (!intel_sdvo_connector)\n\t\treturn false;\n\n\tintel_connector = &intel_sdvo_connector->base;\n\tconnector = &intel_connector->base;\n\tintel_connector->polled = DRM_CONNECTOR_POLL_CONNECT;\n\tencoder->encoder_type = DRM_MODE_ENCODER_DAC;\n\tconnector->connector_type = DRM_MODE_CONNECTOR_VGA;\n\n\tintel_sdvo_connector->output_flag = type;\n\n\tif (intel_sdvo_connector_init(intel_sdvo_connector, intel_sdvo) < 0) {\n\t\tkfree(intel_sdvo_connector);\n\t\treturn false;\n\t}\n\n\treturn true;\n}\n\nstatic bool\nintel_sdvo_lvds_init(struct intel_sdvo *intel_sdvo, u16 type)\n{\n\tstruct drm_encoder *encoder = &intel_sdvo->base.base;\n\tstruct drm_i915_private *i915 = to_i915(encoder->dev);\n\tstruct drm_connector *connector;\n\tstruct intel_connector *intel_connector;\n\tstruct intel_sdvo_connector *intel_sdvo_connector;\n\n\tDRM_DEBUG_KMS(\"initialising LVDS type 0x%x\\n\", type);\n\n\tintel_sdvo_connector = intel_sdvo_connector_alloc();\n\tif (!intel_sdvo_connector)\n\t\treturn false;\n\n\tintel_connector = &intel_sdvo_connector->base;\n\tconnector = &intel_connector->base;\n\tencoder->encoder_type = DRM_MODE_ENCODER_LVDS;\n\tconnector->connector_type = DRM_MODE_CONNECTOR_LVDS;\n\n\tintel_sdvo_connector->output_flag = type;\n\n\tif (intel_sdvo_connector_init(intel_sdvo_connector, intel_sdvo) < 0) {\n\t\tkfree(intel_sdvo_connector);\n\t\treturn false;\n\t}\n\n\tif (!intel_sdvo_create_enhance_property(intel_sdvo, intel_sdvo_connector))\n\t\tgoto err;\n\n\tintel_bios_init_panel_late(i915, &intel_connector->panel, NULL, NULL);\n\n\t \n\tintel_panel_add_vbt_sdvo_fixed_mode(intel_connector);\n\n\tif (!intel_panel_preferred_fixed_mode(intel_connector)) {\n\t\tmutex_lock(&i915->drm.mode_config.mutex);\n\n\t\tintel_ddc_get_modes(connector, &intel_sdvo->ddc);\n\t\tintel_panel_add_edid_fixed_modes(intel_connector, false);\n\n\t\tmutex_unlock(&i915->drm.mode_config.mutex);\n\t}\n\n\tintel_panel_init(intel_connector, NULL);\n\n\tif (!intel_panel_preferred_fixed_mode(intel_connector))\n\t\tgoto err;\n\n\treturn true;\n\nerr:\n\tintel_connector_destroy(connector);\n\treturn false;\n}\n\nstatic u16 intel_sdvo_filter_output_flags(u16 flags)\n{\n\tflags &= SDVO_OUTPUT_MASK;\n\n\t \n\tif (!(flags & SDVO_OUTPUT_TMDS0))\n\t\tflags &= ~SDVO_OUTPUT_TMDS1;\n\n\tif (!(flags & SDVO_OUTPUT_RGB0))\n\t\tflags &= ~SDVO_OUTPUT_RGB1;\n\n\tif (!(flags & SDVO_OUTPUT_LVDS0))\n\t\tflags &= ~SDVO_OUTPUT_LVDS1;\n\n\treturn flags;\n}\n\nstatic bool intel_sdvo_output_init(struct intel_sdvo *sdvo, u16 type)\n{\n\tif (type & SDVO_TMDS_MASK)\n\t\treturn intel_sdvo_dvi_init(sdvo, type);\n\telse if (type & SDVO_TV_MASK)\n\t\treturn intel_sdvo_tv_init(sdvo, type);\n\telse if (type & SDVO_RGB_MASK)\n\t\treturn intel_sdvo_analog_init(sdvo, type);\n\telse if (type & SDVO_LVDS_MASK)\n\t\treturn intel_sdvo_lvds_init(sdvo, type);\n\telse\n\t\treturn false;\n}\n\nstatic bool\nintel_sdvo_output_setup(struct intel_sdvo *intel_sdvo)\n{\n\tstatic const u16 probe_order[] = {\n\t\tSDVO_OUTPUT_TMDS0,\n\t\tSDVO_OUTPUT_TMDS1,\n\t\t \n\t\tSDVO_OUTPUT_SVID0,\n\t\tSDVO_OUTPUT_CVBS0,\n\t\tSDVO_OUTPUT_YPRPB0,\n\t\tSDVO_OUTPUT_RGB0,\n\t\tSDVO_OUTPUT_RGB1,\n\t\tSDVO_OUTPUT_LVDS0,\n\t\tSDVO_OUTPUT_LVDS1,\n\t};\n\tstruct drm_i915_private *i915 = to_i915(intel_sdvo->base.base.dev);\n\tu16 flags;\n\tint i;\n\n\tflags = intel_sdvo_filter_output_flags(intel_sdvo->caps.output_flags);\n\n\tif (flags == 0) {\n\t\tDRM_DEBUG_KMS(\"%s: Unknown SDVO output type (0x%04x)\\n\",\n\t\t\t      SDVO_NAME(intel_sdvo), intel_sdvo->caps.output_flags);\n\t\treturn false;\n\t}\n\n\tintel_sdvo->controlled_output = flags;\n\n\tintel_sdvo_select_ddc_bus(i915, intel_sdvo);\n\n\tfor (i = 0; i < ARRAY_SIZE(probe_order); i++) {\n\t\tu16 type = flags & probe_order[i];\n\n\t\tif (!type)\n\t\t\tcontinue;\n\n\t\tif (!intel_sdvo_output_init(intel_sdvo, type))\n\t\t\treturn false;\n\t}\n\n\tintel_sdvo->base.pipe_mask = ~0;\n\n\treturn true;\n}\n\nstatic void intel_sdvo_output_cleanup(struct intel_sdvo *intel_sdvo)\n{\n\tstruct drm_device *dev = intel_sdvo->base.base.dev;\n\tstruct drm_connector *connector, *tmp;\n\n\tlist_for_each_entry_safe(connector, tmp,\n\t\t\t\t &dev->mode_config.connector_list, head) {\n\t\tif (intel_attached_encoder(to_intel_connector(connector)) == &intel_sdvo->base) {\n\t\t\tdrm_connector_unregister(connector);\n\t\t\tintel_connector_destroy(connector);\n\t\t}\n\t}\n}\n\nstatic bool intel_sdvo_tv_create_property(struct intel_sdvo *intel_sdvo,\n\t\t\t\t\t  struct intel_sdvo_connector *intel_sdvo_connector,\n\t\t\t\t\t  int type)\n{\n\tstruct drm_device *dev = intel_sdvo->base.base.dev;\n\tstruct intel_sdvo_tv_format format;\n\tu32 format_map, i;\n\n\tif (!intel_sdvo_set_target_output(intel_sdvo, type))\n\t\treturn false;\n\n\tBUILD_BUG_ON(sizeof(format) != 6);\n\tif (!intel_sdvo_get_value(intel_sdvo,\n\t\t\t\t  SDVO_CMD_GET_SUPPORTED_TV_FORMATS,\n\t\t\t\t  &format, sizeof(format)))\n\t\treturn false;\n\n\tmemcpy(&format_map, &format, min(sizeof(format_map), sizeof(format)));\n\n\tif (format_map == 0)\n\t\treturn false;\n\n\tintel_sdvo_connector->format_supported_num = 0;\n\tfor (i = 0 ; i < TV_FORMAT_NUM; i++)\n\t\tif (format_map & (1 << i))\n\t\t\tintel_sdvo_connector->tv_format_supported[intel_sdvo_connector->format_supported_num++] = i;\n\n\n\tintel_sdvo_connector->tv_format =\n\t\t\tdrm_property_create(dev, DRM_MODE_PROP_ENUM,\n\t\t\t\t\t    \"mode\", intel_sdvo_connector->format_supported_num);\n\tif (!intel_sdvo_connector->tv_format)\n\t\treturn false;\n\n\tfor (i = 0; i < intel_sdvo_connector->format_supported_num; i++)\n\t\tdrm_property_add_enum(intel_sdvo_connector->tv_format, i,\n\t\t\t\t      tv_format_names[intel_sdvo_connector->tv_format_supported[i]]);\n\n\tintel_sdvo_connector->base.base.state->tv.mode = intel_sdvo_connector->tv_format_supported[0];\n\tdrm_object_attach_property(&intel_sdvo_connector->base.base.base,\n\t\t\t\t   intel_sdvo_connector->tv_format, 0);\n\treturn true;\n\n}\n\n#define _ENHANCEMENT(state_assignment, name, NAME) do { \\\n\tif (enhancements.name) { \\\n\t\tif (!intel_sdvo_get_value(intel_sdvo, SDVO_CMD_GET_MAX_##NAME, &data_value, 4) || \\\n\t\t    !intel_sdvo_get_value(intel_sdvo, SDVO_CMD_GET_##NAME, &response, 2)) \\\n\t\t\treturn false; \\\n\t\tintel_sdvo_connector->name = \\\n\t\t\tdrm_property_create_range(dev, 0, #name, 0, data_value[0]); \\\n\t\tif (!intel_sdvo_connector->name) return false; \\\n\t\tstate_assignment = response; \\\n\t\tdrm_object_attach_property(&connector->base, \\\n\t\t\t\t\t   intel_sdvo_connector->name, 0); \\\n\t\tDRM_DEBUG_KMS(#name \": max %d, default %d, current %d\\n\", \\\n\t\t\t      data_value[0], data_value[1], response); \\\n\t} \\\n} while (0)\n\n#define ENHANCEMENT(state, name, NAME) _ENHANCEMENT((state)->name, name, NAME)\n\nstatic bool\nintel_sdvo_create_enhance_property_tv(struct intel_sdvo *intel_sdvo,\n\t\t\t\t      struct intel_sdvo_connector *intel_sdvo_connector,\n\t\t\t\t      struct intel_sdvo_enhancements_reply enhancements)\n{\n\tstruct drm_device *dev = intel_sdvo->base.base.dev;\n\tstruct drm_connector *connector = &intel_sdvo_connector->base.base;\n\tstruct drm_connector_state *conn_state = connector->state;\n\tstruct intel_sdvo_connector_state *sdvo_state =\n\t\tto_intel_sdvo_connector_state(conn_state);\n\tu16 response, data_value[2];\n\n\t \n\tif (enhancements.overscan_h) {\n\t\tif (!intel_sdvo_get_value(intel_sdvo,\n\t\t\t\t\t  SDVO_CMD_GET_MAX_OVERSCAN_H,\n\t\t\t\t\t  &data_value, 4))\n\t\t\treturn false;\n\n\t\tif (!intel_sdvo_get_value(intel_sdvo,\n\t\t\t\t\t  SDVO_CMD_GET_OVERSCAN_H,\n\t\t\t\t\t  &response, 2))\n\t\t\treturn false;\n\n\t\tsdvo_state->tv.overscan_h = response;\n\n\t\tintel_sdvo_connector->max_hscan = data_value[0];\n\t\tintel_sdvo_connector->left =\n\t\t\tdrm_property_create_range(dev, 0, \"left_margin\", 0, data_value[0]);\n\t\tif (!intel_sdvo_connector->left)\n\t\t\treturn false;\n\n\t\tdrm_object_attach_property(&connector->base,\n\t\t\t\t\t   intel_sdvo_connector->left, 0);\n\n\t\tintel_sdvo_connector->right =\n\t\t\tdrm_property_create_range(dev, 0, \"right_margin\", 0, data_value[0]);\n\t\tif (!intel_sdvo_connector->right)\n\t\t\treturn false;\n\n\t\tdrm_object_attach_property(&connector->base,\n\t\t\t\t\t      intel_sdvo_connector->right, 0);\n\t\tDRM_DEBUG_KMS(\"h_overscan: max %d, \"\n\t\t\t      \"default %d, current %d\\n\",\n\t\t\t      data_value[0], data_value[1], response);\n\t}\n\n\tif (enhancements.overscan_v) {\n\t\tif (!intel_sdvo_get_value(intel_sdvo,\n\t\t\t\t\t  SDVO_CMD_GET_MAX_OVERSCAN_V,\n\t\t\t\t\t  &data_value, 4))\n\t\t\treturn false;\n\n\t\tif (!intel_sdvo_get_value(intel_sdvo,\n\t\t\t\t\t  SDVO_CMD_GET_OVERSCAN_V,\n\t\t\t\t\t  &response, 2))\n\t\t\treturn false;\n\n\t\tsdvo_state->tv.overscan_v = response;\n\n\t\tintel_sdvo_connector->max_vscan = data_value[0];\n\t\tintel_sdvo_connector->top =\n\t\t\tdrm_property_create_range(dev, 0,\n\t\t\t\t\t    \"top_margin\", 0, data_value[0]);\n\t\tif (!intel_sdvo_connector->top)\n\t\t\treturn false;\n\n\t\tdrm_object_attach_property(&connector->base,\n\t\t\t\t\t   intel_sdvo_connector->top, 0);\n\n\t\tintel_sdvo_connector->bottom =\n\t\t\tdrm_property_create_range(dev, 0,\n\t\t\t\t\t    \"bottom_margin\", 0, data_value[0]);\n\t\tif (!intel_sdvo_connector->bottom)\n\t\t\treturn false;\n\n\t\tdrm_object_attach_property(&connector->base,\n\t\t\t\t\t      intel_sdvo_connector->bottom, 0);\n\t\tDRM_DEBUG_KMS(\"v_overscan: max %d, \"\n\t\t\t      \"default %d, current %d\\n\",\n\t\t\t      data_value[0], data_value[1], response);\n\t}\n\n\tENHANCEMENT(&sdvo_state->tv, hpos, HPOS);\n\tENHANCEMENT(&sdvo_state->tv, vpos, VPOS);\n\tENHANCEMENT(&conn_state->tv, saturation, SATURATION);\n\tENHANCEMENT(&conn_state->tv, contrast, CONTRAST);\n\tENHANCEMENT(&conn_state->tv, hue, HUE);\n\tENHANCEMENT(&conn_state->tv, brightness, BRIGHTNESS);\n\tENHANCEMENT(&sdvo_state->tv, sharpness, SHARPNESS);\n\tENHANCEMENT(&sdvo_state->tv, flicker_filter, FLICKER_FILTER);\n\tENHANCEMENT(&sdvo_state->tv, flicker_filter_adaptive, FLICKER_FILTER_ADAPTIVE);\n\tENHANCEMENT(&sdvo_state->tv, flicker_filter_2d, FLICKER_FILTER_2D);\n\t_ENHANCEMENT(sdvo_state->tv.chroma_filter, tv_chroma_filter, TV_CHROMA_FILTER);\n\t_ENHANCEMENT(sdvo_state->tv.luma_filter, tv_luma_filter, TV_LUMA_FILTER);\n\n\tif (enhancements.dot_crawl) {\n\t\tif (!intel_sdvo_get_value(intel_sdvo, SDVO_CMD_GET_DOT_CRAWL, &response, 2))\n\t\t\treturn false;\n\n\t\tsdvo_state->tv.dot_crawl = response & 0x1;\n\t\tintel_sdvo_connector->dot_crawl =\n\t\t\tdrm_property_create_range(dev, 0, \"dot_crawl\", 0, 1);\n\t\tif (!intel_sdvo_connector->dot_crawl)\n\t\t\treturn false;\n\n\t\tdrm_object_attach_property(&connector->base,\n\t\t\t\t\t   intel_sdvo_connector->dot_crawl, 0);\n\t\tDRM_DEBUG_KMS(\"dot crawl: current %d\\n\", response);\n\t}\n\n\treturn true;\n}\n\nstatic bool\nintel_sdvo_create_enhance_property_lvds(struct intel_sdvo *intel_sdvo,\n\t\t\t\t\tstruct intel_sdvo_connector *intel_sdvo_connector,\n\t\t\t\t\tstruct intel_sdvo_enhancements_reply enhancements)\n{\n\tstruct drm_device *dev = intel_sdvo->base.base.dev;\n\tstruct drm_connector *connector = &intel_sdvo_connector->base.base;\n\tu16 response, data_value[2];\n\n\tENHANCEMENT(&connector->state->tv, brightness, BRIGHTNESS);\n\n\treturn true;\n}\n#undef ENHANCEMENT\n#undef _ENHANCEMENT\n\nstatic bool intel_sdvo_create_enhance_property(struct intel_sdvo *intel_sdvo,\n\t\t\t\t\t       struct intel_sdvo_connector *intel_sdvo_connector)\n{\n\tunion {\n\t\tstruct intel_sdvo_enhancements_reply reply;\n\t\tu16 response;\n\t} enhancements;\n\n\tBUILD_BUG_ON(sizeof(enhancements) != 2);\n\n\tif (!intel_sdvo_get_value(intel_sdvo,\n\t\t\t\t  SDVO_CMD_GET_SUPPORTED_ENHANCEMENTS,\n\t\t\t\t  &enhancements, sizeof(enhancements)) ||\n\t    enhancements.response == 0) {\n\t\tDRM_DEBUG_KMS(\"No enhancement is supported\\n\");\n\t\treturn true;\n\t}\n\n\tif (IS_TV(intel_sdvo_connector))\n\t\treturn intel_sdvo_create_enhance_property_tv(intel_sdvo, intel_sdvo_connector, enhancements.reply);\n\telse if (IS_LVDS(intel_sdvo_connector))\n\t\treturn intel_sdvo_create_enhance_property_lvds(intel_sdvo, intel_sdvo_connector, enhancements.reply);\n\telse\n\t\treturn true;\n}\n\nstatic int intel_sdvo_ddc_proxy_xfer(struct i2c_adapter *adapter,\n\t\t\t\t     struct i2c_msg *msgs,\n\t\t\t\t     int num)\n{\n\tstruct intel_sdvo *sdvo = adapter->algo_data;\n\n\tif (!__intel_sdvo_set_control_bus_switch(sdvo, sdvo->ddc_bus))\n\t\treturn -EIO;\n\n\treturn sdvo->i2c->algo->master_xfer(sdvo->i2c, msgs, num);\n}\n\nstatic u32 intel_sdvo_ddc_proxy_func(struct i2c_adapter *adapter)\n{\n\tstruct intel_sdvo *sdvo = adapter->algo_data;\n\treturn sdvo->i2c->algo->functionality(sdvo->i2c);\n}\n\nstatic const struct i2c_algorithm intel_sdvo_ddc_proxy = {\n\t.master_xfer\t= intel_sdvo_ddc_proxy_xfer,\n\t.functionality\t= intel_sdvo_ddc_proxy_func\n};\n\nstatic void proxy_lock_bus(struct i2c_adapter *adapter,\n\t\t\t   unsigned int flags)\n{\n\tstruct intel_sdvo *sdvo = adapter->algo_data;\n\tsdvo->i2c->lock_ops->lock_bus(sdvo->i2c, flags);\n}\n\nstatic int proxy_trylock_bus(struct i2c_adapter *adapter,\n\t\t\t     unsigned int flags)\n{\n\tstruct intel_sdvo *sdvo = adapter->algo_data;\n\treturn sdvo->i2c->lock_ops->trylock_bus(sdvo->i2c, flags);\n}\n\nstatic void proxy_unlock_bus(struct i2c_adapter *adapter,\n\t\t\t     unsigned int flags)\n{\n\tstruct intel_sdvo *sdvo = adapter->algo_data;\n\tsdvo->i2c->lock_ops->unlock_bus(sdvo->i2c, flags);\n}\n\nstatic const struct i2c_lock_operations proxy_lock_ops = {\n\t.lock_bus =    proxy_lock_bus,\n\t.trylock_bus = proxy_trylock_bus,\n\t.unlock_bus =  proxy_unlock_bus,\n};\n\nstatic bool\nintel_sdvo_init_ddc_proxy(struct intel_sdvo *sdvo,\n\t\t\t  struct drm_i915_private *dev_priv)\n{\n\tstruct pci_dev *pdev = to_pci_dev(dev_priv->drm.dev);\n\n\tsdvo->ddc.owner = THIS_MODULE;\n\tsdvo->ddc.class = I2C_CLASS_DDC;\n\tsnprintf(sdvo->ddc.name, I2C_NAME_SIZE, \"SDVO DDC proxy\");\n\tsdvo->ddc.dev.parent = &pdev->dev;\n\tsdvo->ddc.algo_data = sdvo;\n\tsdvo->ddc.algo = &intel_sdvo_ddc_proxy;\n\tsdvo->ddc.lock_ops = &proxy_lock_ops;\n\n\treturn i2c_add_adapter(&sdvo->ddc) == 0;\n}\n\nstatic bool is_sdvo_port_valid(struct drm_i915_private *dev_priv, enum port port)\n{\n\tif (HAS_PCH_SPLIT(dev_priv))\n\t\treturn port == PORT_B;\n\telse\n\t\treturn port == PORT_B || port == PORT_C;\n}\n\nstatic bool assert_sdvo_port_valid(struct drm_i915_private *dev_priv,\n\t\t\t\t   enum port port)\n{\n\treturn !drm_WARN(&dev_priv->drm, !is_sdvo_port_valid(dev_priv, port),\n\t\t\t \"Platform does not support SDVO %c\\n\", port_name(port));\n}\n\nbool intel_sdvo_init(struct drm_i915_private *dev_priv,\n\t\t     i915_reg_t sdvo_reg, enum port port)\n{\n\tstruct intel_encoder *intel_encoder;\n\tstruct intel_sdvo *intel_sdvo;\n\tint i;\n\n\tif (!assert_port_valid(dev_priv, port))\n\t\treturn false;\n\n\tif (!assert_sdvo_port_valid(dev_priv, port))\n\t\treturn false;\n\n\tintel_sdvo = kzalloc(sizeof(*intel_sdvo), GFP_KERNEL);\n\tif (!intel_sdvo)\n\t\treturn false;\n\n\tintel_sdvo->sdvo_reg = sdvo_reg;\n\tintel_sdvo->port = port;\n\tintel_sdvo->slave_addr =\n\t\tintel_sdvo_get_slave_addr(dev_priv, intel_sdvo) >> 1;\n\tintel_sdvo_select_i2c_bus(dev_priv, intel_sdvo);\n\tif (!intel_sdvo_init_ddc_proxy(intel_sdvo, dev_priv))\n\t\tgoto err_i2c_bus;\n\n\t \n\tintel_encoder = &intel_sdvo->base;\n\tintel_encoder->type = INTEL_OUTPUT_SDVO;\n\tintel_encoder->power_domain = POWER_DOMAIN_PORT_OTHER;\n\tintel_encoder->port = port;\n\tdrm_encoder_init(&dev_priv->drm, &intel_encoder->base,\n\t\t\t &intel_sdvo_enc_funcs, 0,\n\t\t\t \"SDVO %c\", port_name(port));\n\n\t \n\tfor (i = 0; i < 0x40; i++) {\n\t\tu8 byte;\n\n\t\tif (!intel_sdvo_read_byte(intel_sdvo, i, &byte)) {\n\t\t\tdrm_dbg_kms(&dev_priv->drm,\n\t\t\t\t    \"No SDVO device found on %s\\n\",\n\t\t\t\t    SDVO_NAME(intel_sdvo));\n\t\t\tgoto err;\n\t\t}\n\t}\n\n\tintel_encoder->compute_config = intel_sdvo_compute_config;\n\tif (HAS_PCH_SPLIT(dev_priv)) {\n\t\tintel_encoder->disable = pch_disable_sdvo;\n\t\tintel_encoder->post_disable = pch_post_disable_sdvo;\n\t} else {\n\t\tintel_encoder->disable = intel_disable_sdvo;\n\t}\n\tintel_encoder->pre_enable = intel_sdvo_pre_enable;\n\tintel_encoder->enable = intel_enable_sdvo;\n\tintel_encoder->get_hw_state = intel_sdvo_get_hw_state;\n\tintel_encoder->get_config = intel_sdvo_get_config;\n\n\t \n\tif (!intel_sdvo_get_capabilities(intel_sdvo, &intel_sdvo->caps))\n\t\tgoto err;\n\n\tintel_sdvo->colorimetry_cap =\n\t\tintel_sdvo_get_colorimetry_cap(intel_sdvo);\n\n\tif (!intel_sdvo_output_setup(intel_sdvo)) {\n\t\tdrm_dbg_kms(&dev_priv->drm,\n\t\t\t    \"SDVO output failed to setup on %s\\n\",\n\t\t\t    SDVO_NAME(intel_sdvo));\n\t\t \n\t\tgoto err_output;\n\t}\n\n\t \n\tif (intel_sdvo->hotplug_active) {\n\t\tif (intel_sdvo->port == PORT_B)\n\t\t\tintel_encoder->hpd_pin = HPD_SDVO_B;\n\t\telse\n\t\t\tintel_encoder->hpd_pin = HPD_SDVO_C;\n\t}\n\n\t \n\tintel_sdvo->base.cloneable = 0;\n\n\t \n\tif (!intel_sdvo_set_target_input(intel_sdvo))\n\t\tgoto err_output;\n\n\tif (!intel_sdvo_get_input_pixel_clock_range(intel_sdvo,\n\t\t\t\t\t\t    &intel_sdvo->pixel_clock_min,\n\t\t\t\t\t\t    &intel_sdvo->pixel_clock_max))\n\t\tgoto err_output;\n\n\tdrm_dbg_kms(&dev_priv->drm, \"%s device VID/DID: %02X:%02X.%02X, \"\n\t\t\t\"clock range %dMHz - %dMHz, \"\n\t\t\t\"input 1: %c, input 2: %c, \"\n\t\t\t\"output 1: %c, output 2: %c\\n\",\n\t\t\tSDVO_NAME(intel_sdvo),\n\t\t\tintel_sdvo->caps.vendor_id, intel_sdvo->caps.device_id,\n\t\t\tintel_sdvo->caps.device_rev_id,\n\t\t\tintel_sdvo->pixel_clock_min / 1000,\n\t\t\tintel_sdvo->pixel_clock_max / 1000,\n\t\t\t(intel_sdvo->caps.sdvo_inputs_mask & 0x1) ? 'Y' : 'N',\n\t\t\t(intel_sdvo->caps.sdvo_inputs_mask & 0x2) ? 'Y' : 'N',\n\t\t\t \n\t\t\tintel_sdvo->caps.output_flags &\n\t\t\t(SDVO_OUTPUT_TMDS0 | SDVO_OUTPUT_RGB0 |\n\t\t\t SDVO_OUTPUT_LVDS0 | SDVO_OUTPUT_SVID0 |\n\t\t\t SDVO_OUTPUT_CVBS0 | SDVO_OUTPUT_YPRPB0) ? 'Y' : 'N',\n\t\t\tintel_sdvo->caps.output_flags &\n\t\t\t(SDVO_OUTPUT_TMDS1 | SDVO_OUTPUT_RGB1 |\n\t\t\t SDVO_OUTPUT_LVDS1) ? 'Y' : 'N');\n\treturn true;\n\nerr_output:\n\tintel_sdvo_output_cleanup(intel_sdvo);\n\nerr:\n\tdrm_encoder_cleanup(&intel_encoder->base);\n\ti2c_del_adapter(&intel_sdvo->ddc);\nerr_i2c_bus:\n\tintel_sdvo_unselect_i2c_bus(intel_sdvo);\n\tkfree(intel_sdvo);\n\n\treturn false;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}