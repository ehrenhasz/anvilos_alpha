{
  "module_name": "intel_panel.c",
  "hash_id": "973a4bfe7bb5da77d95bd8417166f9682bebb4f3e4b35c328abf34c638e17f53",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/i915/display/intel_panel.c",
  "human_readable_source": " \n\n#include <linux/kernel.h>\n#include <linux/pwm.h>\n\n#include <drm/drm_edid.h>\n\n#include \"i915_reg.h\"\n#include \"intel_backlight.h\"\n#include \"intel_connector.h\"\n#include \"intel_de.h\"\n#include \"intel_display_types.h\"\n#include \"intel_drrs.h\"\n#include \"intel_lvds_regs.h\"\n#include \"intel_panel.h\"\n#include \"intel_quirks.h\"\n#include \"intel_vrr.h\"\n\nbool intel_panel_use_ssc(struct drm_i915_private *i915)\n{\n\tif (i915->params.panel_use_ssc >= 0)\n\t\treturn i915->params.panel_use_ssc != 0;\n\treturn i915->display.vbt.lvds_use_ssc &&\n\t\t!intel_has_quirk(i915, QUIRK_LVDS_SSC_DISABLE);\n}\n\nconst struct drm_display_mode *\nintel_panel_preferred_fixed_mode(struct intel_connector *connector)\n{\n\treturn list_first_entry_or_null(&connector->panel.fixed_modes,\n\t\t\t\t\tstruct drm_display_mode, head);\n}\n\nstatic bool is_in_vrr_range(struct intel_connector *connector, int vrefresh)\n{\n\tconst struct drm_display_info *info = &connector->base.display_info;\n\n\treturn intel_vrr_is_capable(connector) &&\n\t\tvrefresh >= info->monitor_range.min_vfreq &&\n\t\tvrefresh <= info->monitor_range.max_vfreq;\n}\n\nstatic bool is_best_fixed_mode(struct intel_connector *connector,\n\t\t\t       int vrefresh, int fixed_mode_vrefresh,\n\t\t\t       const struct drm_display_mode *best_mode)\n{\n\t \n\tif (!best_mode)\n\t\treturn true;\n\n\t \n\tif (is_in_vrr_range(connector, vrefresh) &&\n\t    is_in_vrr_range(connector, fixed_mode_vrefresh) &&\n\t    fixed_mode_vrefresh < vrefresh)\n\t\treturn false;\n\n\t \n\treturn abs(fixed_mode_vrefresh - vrefresh) <\n\t\tabs(drm_mode_vrefresh(best_mode) - vrefresh);\n}\n\nconst struct drm_display_mode *\nintel_panel_fixed_mode(struct intel_connector *connector,\n\t\t       const struct drm_display_mode *mode)\n{\n\tconst struct drm_display_mode *fixed_mode, *best_mode = NULL;\n\tint vrefresh = drm_mode_vrefresh(mode);\n\n\tlist_for_each_entry(fixed_mode, &connector->panel.fixed_modes, head) {\n\t\tint fixed_mode_vrefresh = drm_mode_vrefresh(fixed_mode);\n\n\t\tif (is_best_fixed_mode(connector, vrefresh,\n\t\t\t\t       fixed_mode_vrefresh, best_mode))\n\t\t\tbest_mode = fixed_mode;\n\t}\n\n\treturn best_mode;\n}\n\nstatic bool is_alt_drrs_mode(const struct drm_display_mode *mode,\n\t\t\t     const struct drm_display_mode *preferred_mode)\n{\n\treturn drm_mode_match(mode, preferred_mode,\n\t\t\t      DRM_MODE_MATCH_TIMINGS |\n\t\t\t      DRM_MODE_MATCH_FLAGS |\n\t\t\t      DRM_MODE_MATCH_3D_FLAGS) &&\n\t\tmode->clock != preferred_mode->clock;\n}\n\nstatic bool is_alt_fixed_mode(const struct drm_display_mode *mode,\n\t\t\t      const struct drm_display_mode *preferred_mode)\n{\n\tu32 sync_flags = DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_NHSYNC |\n\t\tDRM_MODE_FLAG_PVSYNC | DRM_MODE_FLAG_NVSYNC;\n\n\treturn (mode->flags & ~sync_flags) == (preferred_mode->flags & ~sync_flags) &&\n\t\tmode->hdisplay == preferred_mode->hdisplay &&\n\t\tmode->vdisplay == preferred_mode->vdisplay;\n}\n\nconst struct drm_display_mode *\nintel_panel_downclock_mode(struct intel_connector *connector,\n\t\t\t   const struct drm_display_mode *adjusted_mode)\n{\n\tconst struct drm_display_mode *fixed_mode, *best_mode = NULL;\n\tint min_vrefresh = connector->panel.vbt.seamless_drrs_min_refresh_rate;\n\tint max_vrefresh = drm_mode_vrefresh(adjusted_mode);\n\n\t \n\tlist_for_each_entry(fixed_mode, &connector->panel.fixed_modes, head) {\n\t\tint vrefresh = drm_mode_vrefresh(fixed_mode);\n\n\t\tif (is_alt_drrs_mode(fixed_mode, adjusted_mode) &&\n\t\t    vrefresh >= min_vrefresh && vrefresh < max_vrefresh) {\n\t\t\tmax_vrefresh = vrefresh;\n\t\t\tbest_mode = fixed_mode;\n\t\t}\n\t}\n\n\treturn best_mode;\n}\n\nconst struct drm_display_mode *\nintel_panel_highest_mode(struct intel_connector *connector,\n\t\t\t const struct drm_display_mode *adjusted_mode)\n{\n\tconst struct drm_display_mode *fixed_mode, *best_mode = adjusted_mode;\n\n\t \n\tlist_for_each_entry(fixed_mode, &connector->panel.fixed_modes, head) {\n\t\tif (fixed_mode->clock > best_mode->clock)\n\t\t\tbest_mode = fixed_mode;\n\t}\n\n\treturn best_mode;\n}\n\nint intel_panel_get_modes(struct intel_connector *connector)\n{\n\tconst struct drm_display_mode *fixed_mode;\n\tint num_modes = 0;\n\n\tlist_for_each_entry(fixed_mode, &connector->panel.fixed_modes, head) {\n\t\tstruct drm_display_mode *mode;\n\n\t\tmode = drm_mode_duplicate(connector->base.dev, fixed_mode);\n\t\tif (mode) {\n\t\t\tdrm_mode_probed_add(&connector->base, mode);\n\t\t\tnum_modes++;\n\t\t}\n\t}\n\n\treturn num_modes;\n}\n\nstatic bool has_drrs_modes(struct intel_connector *connector)\n{\n\tconst struct drm_display_mode *mode1;\n\n\tlist_for_each_entry(mode1, &connector->panel.fixed_modes, head) {\n\t\tconst struct drm_display_mode *mode2 = mode1;\n\n\t\tlist_for_each_entry_continue(mode2, &connector->panel.fixed_modes, head) {\n\t\t\tif (is_alt_drrs_mode(mode1, mode2))\n\t\t\t\treturn true;\n\t\t}\n\t}\n\n\treturn false;\n}\n\nenum drrs_type intel_panel_drrs_type(struct intel_connector *connector)\n{\n\treturn connector->panel.vbt.drrs_type;\n}\n\nint intel_panel_compute_config(struct intel_connector *connector,\n\t\t\t       struct drm_display_mode *adjusted_mode)\n{\n\tconst struct drm_display_mode *fixed_mode =\n\t\tintel_panel_fixed_mode(connector, adjusted_mode);\n\tint vrefresh, fixed_mode_vrefresh;\n\tbool is_vrr;\n\n\tif (!fixed_mode)\n\t\treturn 0;\n\n\tvrefresh = drm_mode_vrefresh(adjusted_mode);\n\tfixed_mode_vrefresh = drm_mode_vrefresh(fixed_mode);\n\n\t \n\tis_vrr = is_in_vrr_range(connector, vrefresh) &&\n\t\tis_in_vrr_range(connector, fixed_mode_vrefresh);\n\n\tif (!is_vrr) {\n\t\t \n\t\tif (abs(vrefresh - fixed_mode_vrefresh) > 1) {\n\t\t\tdrm_dbg_kms(connector->base.dev,\n\t\t\t\t    \"[CONNECTOR:%d:%s] Requested mode vrefresh (%d Hz) does not match fixed mode vrefresh (%d Hz)\\n\",\n\t\t\t\t    connector->base.base.id, connector->base.name,\n\t\t\t\t    vrefresh, fixed_mode_vrefresh);\n\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tdrm_mode_copy(adjusted_mode, fixed_mode);\n\n\tif (is_vrr && fixed_mode_vrefresh != vrefresh)\n\t\tadjusted_mode->vtotal =\n\t\t\tDIV_ROUND_CLOSEST(adjusted_mode->clock * 1000,\n\t\t\t\t\t  adjusted_mode->htotal * vrefresh);\n\n\tdrm_mode_set_crtcinfo(adjusted_mode, 0);\n\n\treturn 0;\n}\n\nstatic void intel_panel_add_edid_alt_fixed_modes(struct intel_connector *connector)\n{\n\tstruct drm_i915_private *dev_priv = to_i915(connector->base.dev);\n\tconst struct drm_display_mode *preferred_mode =\n\t\tintel_panel_preferred_fixed_mode(connector);\n\tstruct drm_display_mode *mode, *next;\n\n\tlist_for_each_entry_safe(mode, next, &connector->base.probed_modes, head) {\n\t\tif (!is_alt_fixed_mode(mode, preferred_mode))\n\t\t\tcontinue;\n\n\t\tdrm_dbg_kms(&dev_priv->drm,\n\t\t\t    \"[CONNECTOR:%d:%s] using alternate EDID fixed mode: \" DRM_MODE_FMT \"\\n\",\n\t\t\t    connector->base.base.id, connector->base.name,\n\t\t\t    DRM_MODE_ARG(mode));\n\n\t\tlist_move_tail(&mode->head, &connector->panel.fixed_modes);\n\t}\n}\n\nstatic void intel_panel_add_edid_preferred_mode(struct intel_connector *connector)\n{\n\tstruct drm_i915_private *dev_priv = to_i915(connector->base.dev);\n\tstruct drm_display_mode *scan, *fixed_mode = NULL;\n\n\tif (list_empty(&connector->base.probed_modes))\n\t\treturn;\n\n\t \n\tlist_for_each_entry(scan, &connector->base.probed_modes, head) {\n\t\tif (scan->type & DRM_MODE_TYPE_PREFERRED) {\n\t\t\tfixed_mode = scan;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!fixed_mode)\n\t\tfixed_mode = list_first_entry(&connector->base.probed_modes,\n\t\t\t\t\t      typeof(*fixed_mode), head);\n\n\tdrm_dbg_kms(&dev_priv->drm,\n\t\t    \"[CONNECTOR:%d:%s] using %s EDID fixed mode: \" DRM_MODE_FMT \"\\n\",\n\t\t    connector->base.base.id, connector->base.name,\n\t\t    fixed_mode->type & DRM_MODE_TYPE_PREFERRED ? \"preferred\" : \"first\",\n\t\t    DRM_MODE_ARG(fixed_mode));\n\n\tfixed_mode->type |= DRM_MODE_TYPE_PREFERRED;\n\n\tlist_move_tail(&fixed_mode->head, &connector->panel.fixed_modes);\n}\n\nstatic void intel_panel_destroy_probed_modes(struct intel_connector *connector)\n{\n\tstruct drm_i915_private *i915 = to_i915(connector->base.dev);\n\tstruct drm_display_mode *mode, *next;\n\n\tlist_for_each_entry_safe(mode, next, &connector->base.probed_modes, head) {\n\t\tdrm_dbg_kms(&i915->drm,\n\t\t\t    \"[CONNECTOR:%d:%s] not using EDID mode: \" DRM_MODE_FMT \"\\n\",\n\t\t\t    connector->base.base.id, connector->base.name,\n\t\t\t    DRM_MODE_ARG(mode));\n\t\tlist_del(&mode->head);\n\t\tdrm_mode_destroy(&i915->drm, mode);\n\t}\n}\n\nvoid intel_panel_add_edid_fixed_modes(struct intel_connector *connector,\n\t\t\t\t      bool use_alt_fixed_modes)\n{\n\tintel_panel_add_edid_preferred_mode(connector);\n\tif (intel_panel_preferred_fixed_mode(connector) && use_alt_fixed_modes)\n\t\tintel_panel_add_edid_alt_fixed_modes(connector);\n\tintel_panel_destroy_probed_modes(connector);\n}\n\nstatic void intel_panel_add_fixed_mode(struct intel_connector *connector,\n\t\t\t\t       struct drm_display_mode *fixed_mode,\n\t\t\t\t       const char *type)\n{\n\tstruct drm_i915_private *i915 = to_i915(connector->base.dev);\n\tstruct drm_display_info *info = &connector->base.display_info;\n\n\tif (!fixed_mode)\n\t\treturn;\n\n\tfixed_mode->type |= DRM_MODE_TYPE_PREFERRED | DRM_MODE_TYPE_DRIVER;\n\n\tinfo->width_mm = fixed_mode->width_mm;\n\tinfo->height_mm = fixed_mode->height_mm;\n\n\tdrm_dbg_kms(&i915->drm, \"[CONNECTOR:%d:%s] using %s fixed mode: \" DRM_MODE_FMT \"\\n\",\n\t\t    connector->base.base.id, connector->base.name, type,\n\t\t    DRM_MODE_ARG(fixed_mode));\n\n\tlist_add_tail(&fixed_mode->head, &connector->panel.fixed_modes);\n}\n\nvoid intel_panel_add_vbt_lfp_fixed_mode(struct intel_connector *connector)\n{\n\tstruct drm_i915_private *i915 = to_i915(connector->base.dev);\n\tconst struct drm_display_mode *mode;\n\n\tmode = connector->panel.vbt.lfp_lvds_vbt_mode;\n\tif (!mode)\n\t\treturn;\n\n\tintel_panel_add_fixed_mode(connector,\n\t\t\t\t   drm_mode_duplicate(&i915->drm, mode),\n\t\t\t\t   \"VBT LFP\");\n}\n\nvoid intel_panel_add_vbt_sdvo_fixed_mode(struct intel_connector *connector)\n{\n\tstruct drm_i915_private *i915 = to_i915(connector->base.dev);\n\tconst struct drm_display_mode *mode;\n\n\tmode = connector->panel.vbt.sdvo_lvds_vbt_mode;\n\tif (!mode)\n\t\treturn;\n\n\tintel_panel_add_fixed_mode(connector,\n\t\t\t\t   drm_mode_duplicate(&i915->drm, mode),\n\t\t\t\t   \"VBT SDVO\");\n}\n\nvoid intel_panel_add_encoder_fixed_mode(struct intel_connector *connector,\n\t\t\t\t\tstruct intel_encoder *encoder)\n{\n\tintel_panel_add_fixed_mode(connector,\n\t\t\t\t   intel_encoder_current_mode(encoder),\n\t\t\t\t   \"current (BIOS)\");\n}\n\n \nstatic int pch_panel_fitting(struct intel_crtc_state *crtc_state,\n\t\t\t     const struct drm_connector_state *conn_state)\n{\n\tconst struct drm_display_mode *adjusted_mode =\n\t\t&crtc_state->hw.adjusted_mode;\n\tint pipe_src_w = drm_rect_width(&crtc_state->pipe_src);\n\tint pipe_src_h = drm_rect_height(&crtc_state->pipe_src);\n\tint x, y, width, height;\n\n\t \n\tif (adjusted_mode->crtc_hdisplay == pipe_src_w &&\n\t    adjusted_mode->crtc_vdisplay == pipe_src_h &&\n\t    crtc_state->output_format != INTEL_OUTPUT_FORMAT_YCBCR420)\n\t\treturn 0;\n\n\tswitch (conn_state->scaling_mode) {\n\tcase DRM_MODE_SCALE_CENTER:\n\t\twidth = pipe_src_w;\n\t\theight = pipe_src_h;\n\t\tx = (adjusted_mode->crtc_hdisplay - width + 1)/2;\n\t\ty = (adjusted_mode->crtc_vdisplay - height + 1)/2;\n\t\tbreak;\n\n\tcase DRM_MODE_SCALE_ASPECT:\n\t\t \n\t\t{\n\t\t\tu32 scaled_width = adjusted_mode->crtc_hdisplay * pipe_src_h;\n\t\t\tu32 scaled_height = pipe_src_w * adjusted_mode->crtc_vdisplay;\n\t\t\tif (scaled_width > scaled_height) {  \n\t\t\t\twidth = scaled_height / pipe_src_h;\n\t\t\t\tif (width & 1)\n\t\t\t\t\twidth++;\n\t\t\t\tx = (adjusted_mode->crtc_hdisplay - width + 1) / 2;\n\t\t\t\ty = 0;\n\t\t\t\theight = adjusted_mode->crtc_vdisplay;\n\t\t\t} else if (scaled_width < scaled_height) {  \n\t\t\t\theight = scaled_width / pipe_src_w;\n\t\t\t\tif (height & 1)\n\t\t\t\t    height++;\n\t\t\t\ty = (adjusted_mode->crtc_vdisplay - height + 1) / 2;\n\t\t\t\tx = 0;\n\t\t\t\twidth = adjusted_mode->crtc_hdisplay;\n\t\t\t} else {\n\t\t\t\tx = y = 0;\n\t\t\t\twidth = adjusted_mode->crtc_hdisplay;\n\t\t\t\theight = adjusted_mode->crtc_vdisplay;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\tcase DRM_MODE_SCALE_NONE:\n\t\tWARN_ON(adjusted_mode->crtc_hdisplay != pipe_src_w);\n\t\tWARN_ON(adjusted_mode->crtc_vdisplay != pipe_src_h);\n\t\tfallthrough;\n\tcase DRM_MODE_SCALE_FULLSCREEN:\n\t\tx = y = 0;\n\t\twidth = adjusted_mode->crtc_hdisplay;\n\t\theight = adjusted_mode->crtc_vdisplay;\n\t\tbreak;\n\n\tdefault:\n\t\tMISSING_CASE(conn_state->scaling_mode);\n\t\treturn -EINVAL;\n\t}\n\n\tdrm_rect_init(&crtc_state->pch_pfit.dst,\n\t\t      x, y, width, height);\n\tcrtc_state->pch_pfit.enabled = true;\n\n\treturn 0;\n}\n\nstatic void\ncentre_horizontally(struct drm_display_mode *adjusted_mode,\n\t\t    int width)\n{\n\tu32 border, sync_pos, blank_width, sync_width;\n\n\t \n\tsync_width = adjusted_mode->crtc_hsync_end - adjusted_mode->crtc_hsync_start;\n\tblank_width = adjusted_mode->crtc_hblank_end - adjusted_mode->crtc_hblank_start;\n\tsync_pos = (blank_width - sync_width + 1) / 2;\n\n\tborder = (adjusted_mode->crtc_hdisplay - width + 1) / 2;\n\tborder += border & 1;  \n\n\tadjusted_mode->crtc_hdisplay = width;\n\tadjusted_mode->crtc_hblank_start = width + border;\n\tadjusted_mode->crtc_hblank_end = adjusted_mode->crtc_hblank_start + blank_width;\n\n\tadjusted_mode->crtc_hsync_start = adjusted_mode->crtc_hblank_start + sync_pos;\n\tadjusted_mode->crtc_hsync_end = adjusted_mode->crtc_hsync_start + sync_width;\n}\n\nstatic void\ncentre_vertically(struct drm_display_mode *adjusted_mode,\n\t\t  int height)\n{\n\tu32 border, sync_pos, blank_width, sync_width;\n\n\t \n\tsync_width = adjusted_mode->crtc_vsync_end - adjusted_mode->crtc_vsync_start;\n\tblank_width = adjusted_mode->crtc_vblank_end - adjusted_mode->crtc_vblank_start;\n\tsync_pos = (blank_width - sync_width + 1) / 2;\n\n\tborder = (adjusted_mode->crtc_vdisplay - height + 1) / 2;\n\n\tadjusted_mode->crtc_vdisplay = height;\n\tadjusted_mode->crtc_vblank_start = height + border;\n\tadjusted_mode->crtc_vblank_end = adjusted_mode->crtc_vblank_start + blank_width;\n\n\tadjusted_mode->crtc_vsync_start = adjusted_mode->crtc_vblank_start + sync_pos;\n\tadjusted_mode->crtc_vsync_end = adjusted_mode->crtc_vsync_start + sync_width;\n}\n\nstatic u32 panel_fitter_scaling(u32 source, u32 target)\n{\n\t \n#define ACCURACY 12\n#define FACTOR (1 << ACCURACY)\n\tu32 ratio = source * FACTOR / target;\n\treturn (FACTOR * ratio + FACTOR/2) / FACTOR;\n}\n\nstatic void i965_scale_aspect(struct intel_crtc_state *crtc_state,\n\t\t\t      u32 *pfit_control)\n{\n\tconst struct drm_display_mode *adjusted_mode =\n\t\t&crtc_state->hw.adjusted_mode;\n\tint pipe_src_w = drm_rect_width(&crtc_state->pipe_src);\n\tint pipe_src_h = drm_rect_height(&crtc_state->pipe_src);\n\tu32 scaled_width = adjusted_mode->crtc_hdisplay * pipe_src_h;\n\tu32 scaled_height = pipe_src_w * adjusted_mode->crtc_vdisplay;\n\n\t \n\tif (scaled_width > scaled_height)\n\t\t*pfit_control |= PFIT_ENABLE |\n\t\t\tPFIT_SCALING_PILLAR;\n\telse if (scaled_width < scaled_height)\n\t\t*pfit_control |= PFIT_ENABLE |\n\t\t\tPFIT_SCALING_LETTER;\n\telse if (adjusted_mode->crtc_hdisplay != pipe_src_w)\n\t\t*pfit_control |= PFIT_ENABLE | PFIT_SCALING_AUTO;\n}\n\nstatic void i9xx_scale_aspect(struct intel_crtc_state *crtc_state,\n\t\t\t      u32 *pfit_control, u32 *pfit_pgm_ratios,\n\t\t\t      u32 *border)\n{\n\tstruct drm_display_mode *adjusted_mode = &crtc_state->hw.adjusted_mode;\n\tint pipe_src_w = drm_rect_width(&crtc_state->pipe_src);\n\tint pipe_src_h = drm_rect_height(&crtc_state->pipe_src);\n\tu32 scaled_width = adjusted_mode->crtc_hdisplay * pipe_src_h;\n\tu32 scaled_height = pipe_src_w * adjusted_mode->crtc_vdisplay;\n\tu32 bits;\n\n\t \n\tif (scaled_width > scaled_height) {  \n\t\tcentre_horizontally(adjusted_mode,\n\t\t\t\t    scaled_height / pipe_src_h);\n\n\t\t*border = LVDS_BORDER_ENABLE;\n\t\tif (pipe_src_h != adjusted_mode->crtc_vdisplay) {\n\t\t\tbits = panel_fitter_scaling(pipe_src_h,\n\t\t\t\t\t\t    adjusted_mode->crtc_vdisplay);\n\n\t\t\t*pfit_pgm_ratios |= (PFIT_HORIZ_SCALE(bits) |\n\t\t\t\t\t     PFIT_VERT_SCALE(bits));\n\t\t\t*pfit_control |= (PFIT_ENABLE |\n\t\t\t\t\t  PFIT_VERT_INTERP_BILINEAR |\n\t\t\t\t\t  PFIT_HORIZ_INTERP_BILINEAR);\n\t\t}\n\t} else if (scaled_width < scaled_height) {  \n\t\tcentre_vertically(adjusted_mode,\n\t\t\t\t  scaled_width / pipe_src_w);\n\n\t\t*border = LVDS_BORDER_ENABLE;\n\t\tif (pipe_src_w != adjusted_mode->crtc_hdisplay) {\n\t\t\tbits = panel_fitter_scaling(pipe_src_w,\n\t\t\t\t\t\t    adjusted_mode->crtc_hdisplay);\n\n\t\t\t*pfit_pgm_ratios |= (PFIT_HORIZ_SCALE(bits) |\n\t\t\t\t\t     PFIT_VERT_SCALE(bits));\n\t\t\t*pfit_control |= (PFIT_ENABLE |\n\t\t\t\t\t  PFIT_VERT_INTERP_BILINEAR |\n\t\t\t\t\t  PFIT_HORIZ_INTERP_BILINEAR);\n\t\t}\n\t} else {\n\t\t \n\t\t*pfit_control |= (PFIT_ENABLE |\n\t\t\t\t  PFIT_VERT_AUTO_SCALE |\n\t\t\t\t  PFIT_HORIZ_AUTO_SCALE |\n\t\t\t\t  PFIT_VERT_INTERP_BILINEAR |\n\t\t\t\t  PFIT_HORIZ_INTERP_BILINEAR);\n\t}\n}\n\nstatic int gmch_panel_fitting(struct intel_crtc_state *crtc_state,\n\t\t\t      const struct drm_connector_state *conn_state)\n{\n\tstruct intel_crtc *crtc = to_intel_crtc(crtc_state->uapi.crtc);\n\tstruct drm_i915_private *dev_priv = to_i915(crtc->base.dev);\n\tu32 pfit_control = 0, pfit_pgm_ratios = 0, border = 0;\n\tstruct drm_display_mode *adjusted_mode = &crtc_state->hw.adjusted_mode;\n\tint pipe_src_w = drm_rect_width(&crtc_state->pipe_src);\n\tint pipe_src_h = drm_rect_height(&crtc_state->pipe_src);\n\n\t \n\tif (adjusted_mode->crtc_hdisplay == pipe_src_w &&\n\t    adjusted_mode->crtc_vdisplay == pipe_src_h)\n\t\tgoto out;\n\n\tswitch (conn_state->scaling_mode) {\n\tcase DRM_MODE_SCALE_CENTER:\n\t\t \n\t\tcentre_horizontally(adjusted_mode, pipe_src_w);\n\t\tcentre_vertically(adjusted_mode, pipe_src_h);\n\t\tborder = LVDS_BORDER_ENABLE;\n\t\tbreak;\n\tcase DRM_MODE_SCALE_ASPECT:\n\t\t \n\t\tif (DISPLAY_VER(dev_priv) >= 4)\n\t\t\ti965_scale_aspect(crtc_state, &pfit_control);\n\t\telse\n\t\t\ti9xx_scale_aspect(crtc_state, &pfit_control,\n\t\t\t\t\t  &pfit_pgm_ratios, &border);\n\t\tbreak;\n\tcase DRM_MODE_SCALE_FULLSCREEN:\n\t\t \n\t\tif (pipe_src_h != adjusted_mode->crtc_vdisplay ||\n\t\t    pipe_src_w != adjusted_mode->crtc_hdisplay) {\n\t\t\tpfit_control |= PFIT_ENABLE;\n\t\t\tif (DISPLAY_VER(dev_priv) >= 4)\n\t\t\t\tpfit_control |= PFIT_SCALING_AUTO;\n\t\t\telse\n\t\t\t\tpfit_control |= (PFIT_VERT_AUTO_SCALE |\n\t\t\t\t\t\t PFIT_VERT_INTERP_BILINEAR |\n\t\t\t\t\t\t PFIT_HORIZ_AUTO_SCALE |\n\t\t\t\t\t\t PFIT_HORIZ_INTERP_BILINEAR);\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tMISSING_CASE(conn_state->scaling_mode);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\t \n\tif (DISPLAY_VER(dev_priv) >= 4)\n\t\tpfit_control |= PFIT_PIPE(crtc->pipe) | PFIT_FILTER_FUZZY;\n\nout:\n\tif ((pfit_control & PFIT_ENABLE) == 0) {\n\t\tpfit_control = 0;\n\t\tpfit_pgm_ratios = 0;\n\t}\n\n\t \n\tif (DISPLAY_VER(dev_priv) < 4 && crtc_state->pipe_bpp == 18)\n\t\tpfit_control |= PFIT_PANEL_8TO6_DITHER_ENABLE;\n\n\tcrtc_state->gmch_pfit.control = pfit_control;\n\tcrtc_state->gmch_pfit.pgm_ratios = pfit_pgm_ratios;\n\tcrtc_state->gmch_pfit.lvds_border_bits = border;\n\n\treturn 0;\n}\n\nint intel_panel_fitting(struct intel_crtc_state *crtc_state,\n\t\t\tconst struct drm_connector_state *conn_state)\n{\n\tstruct intel_crtc *crtc = to_intel_crtc(crtc_state->uapi.crtc);\n\tstruct drm_i915_private *i915 = to_i915(crtc->base.dev);\n\n\tif (HAS_GMCH(i915))\n\t\treturn gmch_panel_fitting(crtc_state, conn_state);\n\telse\n\t\treturn pch_panel_fitting(crtc_state, conn_state);\n}\n\nenum drm_connector_status\nintel_panel_detect(struct drm_connector *connector, bool force)\n{\n\tstruct drm_i915_private *i915 = to_i915(connector->dev);\n\n\tif (!INTEL_DISPLAY_ENABLED(i915))\n\t\treturn connector_status_disconnected;\n\n\treturn connector_status_connected;\n}\n\nenum drm_mode_status\nintel_panel_mode_valid(struct intel_connector *connector,\n\t\t       const struct drm_display_mode *mode)\n{\n\tconst struct drm_display_mode *fixed_mode =\n\t\tintel_panel_fixed_mode(connector, mode);\n\n\tif (!fixed_mode)\n\t\treturn MODE_OK;\n\n\tif (mode->hdisplay != fixed_mode->hdisplay)\n\t\treturn MODE_PANEL;\n\n\tif (mode->vdisplay != fixed_mode->vdisplay)\n\t\treturn MODE_PANEL;\n\n\tif (drm_mode_vrefresh(mode) != drm_mode_vrefresh(fixed_mode))\n\t\treturn MODE_PANEL;\n\n\treturn MODE_OK;\n}\n\nvoid intel_panel_init_alloc(struct intel_connector *connector)\n{\n\tstruct intel_panel *panel = &connector->panel;\n\n\tconnector->panel.vbt.panel_type = -1;\n\tconnector->panel.vbt.backlight.controller = -1;\n\tINIT_LIST_HEAD(&panel->fixed_modes);\n}\n\nint intel_panel_init(struct intel_connector *connector,\n\t\t     const struct drm_edid *fixed_edid)\n{\n\tstruct intel_panel *panel = &connector->panel;\n\n\tpanel->fixed_edid = fixed_edid;\n\n\tintel_backlight_init_funcs(panel);\n\n\tif (!has_drrs_modes(connector))\n\t\tconnector->panel.vbt.drrs_type = DRRS_TYPE_NONE;\n\n\tdrm_dbg_kms(connector->base.dev,\n\t\t    \"[CONNECTOR:%d:%s] DRRS type: %s\\n\",\n\t\t    connector->base.base.id, connector->base.name,\n\t\t    intel_drrs_type_str(intel_panel_drrs_type(connector)));\n\n\treturn 0;\n}\n\nvoid intel_panel_fini(struct intel_connector *connector)\n{\n\tstruct intel_panel *panel = &connector->panel;\n\tstruct drm_display_mode *fixed_mode, *next;\n\n\tif (!IS_ERR_OR_NULL(panel->fixed_edid))\n\t\tdrm_edid_free(panel->fixed_edid);\n\n\tintel_backlight_destroy(panel);\n\n\tintel_bios_fini_panel(panel);\n\n\tlist_for_each_entry_safe(fixed_mode, next, &panel->fixed_modes, head) {\n\t\tlist_del(&fixed_mode->head);\n\t\tdrm_mode_destroy(connector->base.dev, fixed_mode);\n\t}\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}