{
  "module_name": "intel_connector.c",
  "hash_id": "9ccb822687b7a47c630fcdfd4f2fc7efa75fd5a45935cca10a2554bb8aa56c8c",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/i915/display/intel_connector.c",
  "human_readable_source": " \n\n#include <linux/i2c.h>\n#include <linux/slab.h>\n\n#include <drm/drm_atomic_helper.h>\n#include <drm/drm_edid.h>\n\n#include \"i915_drv.h\"\n#include \"intel_backlight.h\"\n#include \"intel_connector.h\"\n#include \"intel_display_debugfs.h\"\n#include \"intel_display_types.h\"\n#include \"intel_hdcp.h\"\n#include \"intel_panel.h\"\n\nint intel_connector_init(struct intel_connector *connector)\n{\n\tstruct intel_digital_connector_state *conn_state;\n\n\t \n\tconn_state = kzalloc(sizeof(*conn_state), GFP_KERNEL);\n\tif (!conn_state)\n\t\treturn -ENOMEM;\n\n\t__drm_atomic_helper_connector_reset(&connector->base,\n\t\t\t\t\t    &conn_state->base);\n\n\tintel_panel_init_alloc(connector);\n\n\treturn 0;\n}\n\nstruct intel_connector *intel_connector_alloc(void)\n{\n\tstruct intel_connector *connector;\n\n\tconnector = kzalloc(sizeof(*connector), GFP_KERNEL);\n\tif (!connector)\n\t\treturn NULL;\n\n\tif (intel_connector_init(connector) < 0) {\n\t\tkfree(connector);\n\t\treturn NULL;\n\t}\n\n\treturn connector;\n}\n\n \nvoid intel_connector_free(struct intel_connector *connector)\n{\n\tkfree(to_intel_digital_connector_state(connector->base.state));\n\tkfree(connector);\n}\n\n \nvoid intel_connector_destroy(struct drm_connector *connector)\n{\n\tstruct intel_connector *intel_connector = to_intel_connector(connector);\n\n\tdrm_edid_free(intel_connector->detect_edid);\n\n\tintel_hdcp_cleanup(intel_connector);\n\n\tintel_panel_fini(intel_connector);\n\n\tdrm_connector_cleanup(connector);\n\n\tif (intel_connector->port)\n\t\tdrm_dp_mst_put_port_malloc(intel_connector->port);\n\n\tkfree(connector);\n}\n\nint intel_connector_register(struct drm_connector *connector)\n{\n\tstruct intel_connector *intel_connector = to_intel_connector(connector);\n\tint ret;\n\n\tret = intel_backlight_device_register(intel_connector);\n\tif (ret)\n\t\tgoto err;\n\n\tif (i915_inject_probe_failure(to_i915(connector->dev))) {\n\t\tret = -EFAULT;\n\t\tgoto err_backlight;\n\t}\n\n\tintel_connector_debugfs_add(intel_connector);\n\n\treturn 0;\n\nerr_backlight:\n\tintel_backlight_device_unregister(intel_connector);\nerr:\n\treturn ret;\n}\n\nvoid intel_connector_unregister(struct drm_connector *connector)\n{\n\tstruct intel_connector *intel_connector = to_intel_connector(connector);\n\n\tintel_backlight_device_unregister(intel_connector);\n}\n\nvoid intel_connector_attach_encoder(struct intel_connector *connector,\n\t\t\t\t    struct intel_encoder *encoder)\n{\n\tconnector->encoder = encoder;\n\tdrm_connector_attach_encoder(&connector->base, &encoder->base);\n}\n\n \nbool intel_connector_get_hw_state(struct intel_connector *connector)\n{\n\tenum pipe pipe = 0;\n\tstruct intel_encoder *encoder = intel_attached_encoder(connector);\n\n\treturn encoder->get_hw_state(encoder, &pipe);\n}\n\nenum pipe intel_connector_get_pipe(struct intel_connector *connector)\n{\n\tstruct drm_device *dev = connector->base.dev;\n\n\tdrm_WARN_ON(dev,\n\t\t    !drm_modeset_is_locked(&dev->mode_config.connection_mutex));\n\n\tif (!connector->base.state->crtc)\n\t\treturn INVALID_PIPE;\n\n\treturn to_intel_crtc(connector->base.state->crtc)->pipe;\n}\n\n \nint intel_connector_update_modes(struct drm_connector *connector,\n\t\t\t\t const struct drm_edid *drm_edid)\n{\n\tint ret;\n\n\tdrm_edid_connector_update(connector, drm_edid);\n\tret = drm_edid_connector_add_modes(connector);\n\n\treturn ret;\n}\n\n \nint intel_ddc_get_modes(struct drm_connector *connector,\n\t\t\tstruct i2c_adapter *adapter)\n{\n\tconst struct drm_edid *drm_edid;\n\tint ret;\n\n\tdrm_edid = drm_edid_read_ddc(connector, adapter);\n\tif (!drm_edid)\n\t\treturn 0;\n\n\tret = intel_connector_update_modes(connector, drm_edid);\n\tdrm_edid_free(drm_edid);\n\n\treturn ret;\n}\n\nstatic const struct drm_prop_enum_list force_audio_names[] = {\n\t{ HDMI_AUDIO_OFF_DVI, \"force-dvi\" },\n\t{ HDMI_AUDIO_OFF, \"off\" },\n\t{ HDMI_AUDIO_AUTO, \"auto\" },\n\t{ HDMI_AUDIO_ON, \"on\" },\n};\n\nvoid\nintel_attach_force_audio_property(struct drm_connector *connector)\n{\n\tstruct drm_device *dev = connector->dev;\n\tstruct drm_i915_private *dev_priv = to_i915(dev);\n\tstruct drm_property *prop;\n\n\tprop = dev_priv->display.properties.force_audio;\n\tif (prop == NULL) {\n\t\tprop = drm_property_create_enum(dev, 0,\n\t\t\t\t\t   \"audio\",\n\t\t\t\t\t   force_audio_names,\n\t\t\t\t\t   ARRAY_SIZE(force_audio_names));\n\t\tif (prop == NULL)\n\t\t\treturn;\n\n\t\tdev_priv->display.properties.force_audio = prop;\n\t}\n\tdrm_object_attach_property(&connector->base, prop, 0);\n}\n\nstatic const struct drm_prop_enum_list broadcast_rgb_names[] = {\n\t{ INTEL_BROADCAST_RGB_AUTO, \"Automatic\" },\n\t{ INTEL_BROADCAST_RGB_FULL, \"Full\" },\n\t{ INTEL_BROADCAST_RGB_LIMITED, \"Limited 16:235\" },\n};\n\nvoid\nintel_attach_broadcast_rgb_property(struct drm_connector *connector)\n{\n\tstruct drm_device *dev = connector->dev;\n\tstruct drm_i915_private *dev_priv = to_i915(dev);\n\tstruct drm_property *prop;\n\n\tprop = dev_priv->display.properties.broadcast_rgb;\n\tif (prop == NULL) {\n\t\tprop = drm_property_create_enum(dev, DRM_MODE_PROP_ENUM,\n\t\t\t\t\t   \"Broadcast RGB\",\n\t\t\t\t\t   broadcast_rgb_names,\n\t\t\t\t\t   ARRAY_SIZE(broadcast_rgb_names));\n\t\tif (prop == NULL)\n\t\t\treturn;\n\n\t\tdev_priv->display.properties.broadcast_rgb = prop;\n\t}\n\n\tdrm_object_attach_property(&connector->base, prop, 0);\n}\n\nvoid\nintel_attach_aspect_ratio_property(struct drm_connector *connector)\n{\n\tif (!drm_mode_create_aspect_ratio_property(connector->dev))\n\t\tdrm_object_attach_property(&connector->base,\n\t\t\tconnector->dev->mode_config.aspect_ratio_property,\n\t\t\tDRM_MODE_PICTURE_ASPECT_NONE);\n}\n\nvoid\nintel_attach_hdmi_colorspace_property(struct drm_connector *connector)\n{\n\tif (!drm_mode_create_hdmi_colorspace_property(connector, 0))\n\t\tdrm_connector_attach_colorspace_property(connector);\n}\n\nvoid\nintel_attach_dp_colorspace_property(struct drm_connector *connector)\n{\n\tif (!drm_mode_create_dp_colorspace_property(connector, 0))\n\t\tdrm_connector_attach_colorspace_property(connector);\n}\n\nvoid\nintel_attach_scaling_mode_property(struct drm_connector *connector)\n{\n\tstruct drm_i915_private *i915 = to_i915(connector->dev);\n\tu32 scaling_modes;\n\n\tscaling_modes = BIT(DRM_MODE_SCALE_ASPECT) |\n\t\tBIT(DRM_MODE_SCALE_FULLSCREEN);\n\n\t \n\tif (!HAS_GMCH(i915) || connector->connector_type == DRM_MODE_CONNECTOR_LVDS)\n\t\tscaling_modes |= BIT(DRM_MODE_SCALE_CENTER);\n\n\tdrm_connector_attach_scaling_mode_property(connector, scaling_modes);\n\n\tconnector->state->scaling_mode = DRM_MODE_SCALE_ASPECT;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}