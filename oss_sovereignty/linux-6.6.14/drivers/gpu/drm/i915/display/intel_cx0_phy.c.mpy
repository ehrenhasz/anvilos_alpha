{
  "module_name": "intel_cx0_phy.c",
  "hash_id": "2d7592524a1c9cc43bed0326e0c9fb7126d52dc767a709520207641012bd1a91",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/i915/display/intel_cx0_phy.c",
  "human_readable_source": "\n \n\n#include <linux/log2.h>\n#include <linux/math64.h>\n#include \"i915_reg.h\"\n#include \"intel_cx0_phy.h\"\n#include \"intel_cx0_phy_regs.h\"\n#include \"intel_ddi.h\"\n#include \"intel_ddi_buf_trans.h\"\n#include \"intel_de.h\"\n#include \"intel_display_types.h\"\n#include \"intel_dp.h\"\n#include \"intel_hdmi.h\"\n#include \"intel_panel.h\"\n#include \"intel_psr.h\"\n#include \"intel_tc.h\"\n\n#define MB_WRITE_COMMITTED      true\n#define MB_WRITE_UNCOMMITTED    false\n\n#define for_each_cx0_lane_in_mask(__lane_mask, __lane) \\\n\tfor ((__lane) = 0; (__lane) < 2; (__lane)++) \\\n\t\tfor_each_if((__lane_mask) & BIT(__lane))\n\n#define INTEL_CX0_LANE0\t\tBIT(0)\n#define INTEL_CX0_LANE1\t\tBIT(1)\n#define INTEL_CX0_BOTH_LANES\t(INTEL_CX0_LANE1 | INTEL_CX0_LANE0)\n\nbool intel_is_c10phy(struct drm_i915_private *i915, enum phy phy)\n{\n\tif (IS_METEORLAKE(i915) && (phy < PHY_C))\n\t\treturn true;\n\n\treturn false;\n}\n\nstatic int lane_mask_to_lane(u8 lane_mask)\n{\n\tif (WARN_ON((lane_mask & ~INTEL_CX0_BOTH_LANES) ||\n\t\t    hweight8(lane_mask) != 1))\n\t\treturn 0;\n\n\treturn ilog2(lane_mask);\n}\n\nstatic void\nassert_dc_off(struct drm_i915_private *i915)\n{\n\tbool enabled;\n\n\tenabled = intel_display_power_is_enabled(i915, POWER_DOMAIN_DC_OFF);\n\tdrm_WARN_ON(&i915->drm, !enabled);\n}\n\n \nstatic intel_wakeref_t intel_cx0_phy_transaction_begin(struct intel_encoder *encoder)\n{\n\tstruct drm_i915_private *i915 = to_i915(encoder->base.dev);\n\tstruct intel_dp *intel_dp = enc_to_intel_dp(encoder);\n\n\tintel_psr_pause(intel_dp);\n\treturn intel_display_power_get(i915, POWER_DOMAIN_DC_OFF);\n}\n\nstatic void intel_cx0_phy_transaction_end(struct intel_encoder *encoder, intel_wakeref_t wakeref)\n{\n\tstruct drm_i915_private *i915 = to_i915(encoder->base.dev);\n\tstruct intel_dp *intel_dp = enc_to_intel_dp(encoder);\n\n\tintel_psr_resume(intel_dp);\n\tintel_display_power_put(i915, POWER_DOMAIN_DC_OFF, wakeref);\n}\n\nstatic void intel_clear_response_ready_flag(struct drm_i915_private *i915,\n\t\t\t\t\t    enum port port, int lane)\n{\n\tintel_de_rmw(i915, XELPDP_PORT_P2M_MSGBUS_STATUS(port, lane),\n\t\t     0, XELPDP_PORT_P2M_RESPONSE_READY | XELPDP_PORT_P2M_ERROR_SET);\n}\n\nstatic void intel_cx0_bus_reset(struct drm_i915_private *i915, enum port port, int lane)\n{\n\tenum phy phy = intel_port_to_phy(i915, port);\n\n\tintel_de_write(i915, XELPDP_PORT_M2P_MSGBUS_CTL(port, lane),\n\t\t       XELPDP_PORT_M2P_TRANSACTION_RESET);\n\n\tif (intel_de_wait_for_clear(i915, XELPDP_PORT_M2P_MSGBUS_CTL(port, lane),\n\t\t\t\t    XELPDP_PORT_M2P_TRANSACTION_RESET,\n\t\t\t\t    XELPDP_MSGBUS_TIMEOUT_SLOW)) {\n\t\tdrm_err_once(&i915->drm, \"Failed to bring PHY %c to idle.\\n\", phy_name(phy));\n\t\treturn;\n\t}\n\n\tintel_clear_response_ready_flag(i915, port, lane);\n}\n\nstatic int intel_cx0_wait_for_ack(struct drm_i915_private *i915, enum port port,\n\t\t\t\t  int command, int lane, u32 *val)\n{\n\tenum phy phy = intel_port_to_phy(i915, port);\n\n\tif (__intel_de_wait_for_register(i915,\n\t\t\t\t\t XELPDP_PORT_P2M_MSGBUS_STATUS(port, lane),\n\t\t\t\t\t XELPDP_PORT_P2M_RESPONSE_READY,\n\t\t\t\t\t XELPDP_PORT_P2M_RESPONSE_READY,\n\t\t\t\t\t XELPDP_MSGBUS_TIMEOUT_FAST_US,\n\t\t\t\t\t XELPDP_MSGBUS_TIMEOUT_SLOW, val)) {\n\t\tdrm_dbg_kms(&i915->drm, \"PHY %c Timeout waiting for message ACK. Status: 0x%x\\n\",\n\t\t\t    phy_name(phy), *val);\n\t\tintel_cx0_bus_reset(i915, port, lane);\n\t\treturn -ETIMEDOUT;\n\t}\n\n\tif (*val & XELPDP_PORT_P2M_ERROR_SET) {\n\t\tdrm_dbg_kms(&i915->drm, \"PHY %c Error occurred during %s command. Status: 0x%x\\n\", phy_name(phy),\n\t\t\t    command == XELPDP_PORT_P2M_COMMAND_READ_ACK ? \"read\" : \"write\", *val);\n\t\tintel_cx0_bus_reset(i915, port, lane);\n\t\treturn -EINVAL;\n\t}\n\n\tif (REG_FIELD_GET(XELPDP_PORT_P2M_COMMAND_TYPE_MASK, *val) != command) {\n\t\tdrm_dbg_kms(&i915->drm, \"PHY %c Not a %s response. MSGBUS Status: 0x%x.\\n\", phy_name(phy),\n\t\t\t    command == XELPDP_PORT_P2M_COMMAND_READ_ACK ? \"read\" : \"write\", *val);\n\t\tintel_cx0_bus_reset(i915, port, lane);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int __intel_cx0_read_once(struct drm_i915_private *i915, enum port port,\n\t\t\t\t int lane, u16 addr)\n{\n\tenum phy phy = intel_port_to_phy(i915, port);\n\tint ack;\n\tu32 val;\n\n\tif (intel_de_wait_for_clear(i915, XELPDP_PORT_M2P_MSGBUS_CTL(port, lane),\n\t\t\t\t    XELPDP_PORT_M2P_TRANSACTION_PENDING,\n\t\t\t\t    XELPDP_MSGBUS_TIMEOUT_SLOW)) {\n\t\tdrm_dbg_kms(&i915->drm,\n\t\t\t    \"PHY %c Timeout waiting for previous transaction to complete. Reset the bus and retry.\\n\", phy_name(phy));\n\t\tintel_cx0_bus_reset(i915, port, lane);\n\t\treturn -ETIMEDOUT;\n\t}\n\n\tintel_de_write(i915, XELPDP_PORT_M2P_MSGBUS_CTL(port, lane),\n\t\t       XELPDP_PORT_M2P_TRANSACTION_PENDING |\n\t\t       XELPDP_PORT_M2P_COMMAND_READ |\n\t\t       XELPDP_PORT_M2P_ADDRESS(addr));\n\n\tack = intel_cx0_wait_for_ack(i915, port, XELPDP_PORT_P2M_COMMAND_READ_ACK, lane, &val);\n\tif (ack < 0)\n\t\treturn ack;\n\n\tintel_clear_response_ready_flag(i915, port, lane);\n\n\treturn REG_FIELD_GET(XELPDP_PORT_P2M_DATA_MASK, val);\n}\n\nstatic u8 __intel_cx0_read(struct drm_i915_private *i915, enum port port,\n\t\t\t   int lane, u16 addr)\n{\n\tenum phy phy = intel_port_to_phy(i915, port);\n\tint i, status;\n\n\tassert_dc_off(i915);\n\n\t \n\tfor (i = 0; i < 3; i++) {\n\t\tstatus = __intel_cx0_read_once(i915, port, lane, addr);\n\n\t\tif (status >= 0)\n\t\t\treturn status;\n\t}\n\n\tdrm_err_once(&i915->drm, \"PHY %c Read %04x failed after %d retries.\\n\",\n\t\t     phy_name(phy), addr, i);\n\n\treturn 0;\n}\n\nstatic u8 intel_cx0_read(struct drm_i915_private *i915, enum port port,\n\t\t\t u8 lane_mask, u16 addr)\n{\n\tint lane = lane_mask_to_lane(lane_mask);\n\n\treturn __intel_cx0_read(i915, port, lane, addr);\n}\n\nstatic int __intel_cx0_write_once(struct drm_i915_private *i915, enum port port,\n\t\t\t\t  int lane, u16 addr, u8 data, bool committed)\n{\n\tenum phy phy = intel_port_to_phy(i915, port);\n\tint ack;\n\tu32 val;\n\n\tif (intel_de_wait_for_clear(i915, XELPDP_PORT_M2P_MSGBUS_CTL(port, lane),\n\t\t\t\t    XELPDP_PORT_M2P_TRANSACTION_PENDING,\n\t\t\t\t    XELPDP_MSGBUS_TIMEOUT_SLOW)) {\n\t\tdrm_dbg_kms(&i915->drm,\n\t\t\t    \"PHY %c Timeout waiting for previous transaction to complete. Resetting the bus.\\n\", phy_name(phy));\n\t\tintel_cx0_bus_reset(i915, port, lane);\n\t\treturn -ETIMEDOUT;\n\t}\n\n\tintel_de_write(i915, XELPDP_PORT_M2P_MSGBUS_CTL(port, lane),\n\t\t       XELPDP_PORT_M2P_TRANSACTION_PENDING |\n\t\t       (committed ? XELPDP_PORT_M2P_COMMAND_WRITE_COMMITTED :\n\t\t\t\t    XELPDP_PORT_M2P_COMMAND_WRITE_UNCOMMITTED) |\n\t\t       XELPDP_PORT_M2P_DATA(data) |\n\t\t       XELPDP_PORT_M2P_ADDRESS(addr));\n\n\tif (intel_de_wait_for_clear(i915, XELPDP_PORT_M2P_MSGBUS_CTL(port, lane),\n\t\t\t\t    XELPDP_PORT_M2P_TRANSACTION_PENDING,\n\t\t\t\t    XELPDP_MSGBUS_TIMEOUT_SLOW)) {\n\t\tdrm_dbg_kms(&i915->drm,\n\t\t\t    \"PHY %c Timeout waiting for write to complete. Resetting the bus.\\n\", phy_name(phy));\n\t\tintel_cx0_bus_reset(i915, port, lane);\n\t\treturn -ETIMEDOUT;\n\t}\n\n\tif (committed) {\n\t\tack = intel_cx0_wait_for_ack(i915, port, XELPDP_PORT_P2M_COMMAND_WRITE_ACK, lane, &val);\n\t\tif (ack < 0)\n\t\t\treturn ack;\n\t} else if ((intel_de_read(i915, XELPDP_PORT_P2M_MSGBUS_STATUS(port, lane)) &\n\t\t    XELPDP_PORT_P2M_ERROR_SET)) {\n\t\tdrm_dbg_kms(&i915->drm,\n\t\t\t    \"PHY %c Error occurred during write command.\\n\", phy_name(phy));\n\t\tintel_cx0_bus_reset(i915, port, lane);\n\t\treturn -EINVAL;\n\t}\n\n\tintel_clear_response_ready_flag(i915, port, lane);\n\n\treturn 0;\n}\n\nstatic void __intel_cx0_write(struct drm_i915_private *i915, enum port port,\n\t\t\t      int lane, u16 addr, u8 data, bool committed)\n{\n\tenum phy phy = intel_port_to_phy(i915, port);\n\tint i, status;\n\n\tassert_dc_off(i915);\n\n\t \n\tfor (i = 0; i < 3; i++) {\n\t\tstatus = __intel_cx0_write_once(i915, port, lane, addr, data, committed);\n\n\t\tif (status == 0)\n\t\t\treturn;\n\t}\n\n\tdrm_err_once(&i915->drm,\n\t\t     \"PHY %c Write %04x failed after %d retries.\\n\", phy_name(phy), addr, i);\n}\n\nstatic void intel_cx0_write(struct drm_i915_private *i915, enum port port,\n\t\t\t    u8 lane_mask, u16 addr, u8 data, bool committed)\n{\n\tint lane;\n\n\tfor_each_cx0_lane_in_mask(lane_mask, lane)\n\t\t__intel_cx0_write(i915, port, lane, addr, data, committed);\n}\n\nstatic void intel_c20_sram_write(struct drm_i915_private *i915, enum port port,\n\t\t\t\t int lane, u16 addr, u16 data)\n{\n\tassert_dc_off(i915);\n\n\tintel_cx0_write(i915, port, lane, PHY_C20_WR_ADDRESS_H, addr >> 8, 0);\n\tintel_cx0_write(i915, port, lane, PHY_C20_WR_ADDRESS_L, addr & 0xff, 0);\n\n\tintel_cx0_write(i915, port, lane, PHY_C20_WR_DATA_H, data >> 8, 0);\n\tintel_cx0_write(i915, port, lane, PHY_C20_WR_DATA_L, data & 0xff, 1);\n}\n\nstatic u16 intel_c20_sram_read(struct drm_i915_private *i915, enum port port,\n\t\t\t       int lane, u16 addr)\n{\n\tu16 val;\n\n\tassert_dc_off(i915);\n\n\tintel_cx0_write(i915, port, lane, PHY_C20_RD_ADDRESS_H, addr >> 8, 0);\n\tintel_cx0_write(i915, port, lane, PHY_C20_RD_ADDRESS_L, addr & 0xff, 1);\n\n\tval = intel_cx0_read(i915, port, lane, PHY_C20_RD_DATA_H);\n\tval <<= 8;\n\tval |= intel_cx0_read(i915, port, lane, PHY_C20_RD_DATA_L);\n\n\treturn val;\n}\n\nstatic void __intel_cx0_rmw(struct drm_i915_private *i915, enum port port,\n\t\t\t    int lane, u16 addr, u8 clear, u8 set, bool committed)\n{\n\tu8 old, val;\n\n\told = __intel_cx0_read(i915, port, lane, addr);\n\tval = (old & ~clear) | set;\n\n\tif (val != old)\n\t\t__intel_cx0_write(i915, port, lane, addr, val, committed);\n}\n\nstatic void intel_cx0_rmw(struct drm_i915_private *i915, enum port port,\n\t\t\t  u8 lane_mask, u16 addr, u8 clear, u8 set, bool committed)\n{\n\tu8 lane;\n\n\tfor_each_cx0_lane_in_mask(lane_mask, lane)\n\t\t__intel_cx0_rmw(i915, port, lane, addr, clear, set, committed);\n}\n\nstatic u8 intel_c10_get_tx_vboost_lvl(const struct intel_crtc_state *crtc_state)\n{\n\tif (intel_crtc_has_dp_encoder(crtc_state)) {\n\t\tif (!intel_crtc_has_type(crtc_state, INTEL_OUTPUT_EDP) &&\n\t\t    (crtc_state->port_clock == 540000 ||\n\t\t     crtc_state->port_clock == 810000))\n\t\t\treturn 5;\n\t\telse\n\t\t\treturn 4;\n\t} else {\n\t\treturn 5;\n\t}\n}\n\nstatic u8 intel_c10_get_tx_term_ctl(const struct intel_crtc_state *crtc_state)\n{\n\tif (intel_crtc_has_dp_encoder(crtc_state)) {\n\t\tif (!intel_crtc_has_type(crtc_state, INTEL_OUTPUT_EDP) &&\n\t\t    (crtc_state->port_clock == 540000 ||\n\t\t     crtc_state->port_clock == 810000))\n\t\t\treturn 5;\n\t\telse\n\t\t\treturn 2;\n\t} else {\n\t\treturn 6;\n\t}\n}\n\nvoid intel_cx0_phy_set_signal_levels(struct intel_encoder *encoder,\n\t\t\t\t     const struct intel_crtc_state *crtc_state)\n{\n\tstruct drm_i915_private *i915 = to_i915(encoder->base.dev);\n\tconst struct intel_ddi_buf_trans *trans;\n\tenum phy phy = intel_port_to_phy(i915, encoder->port);\n\tintel_wakeref_t wakeref;\n\tint n_entries, ln;\n\n\twakeref = intel_cx0_phy_transaction_begin(encoder);\n\n\ttrans = encoder->get_buf_trans(encoder, crtc_state, &n_entries);\n\tif (drm_WARN_ON_ONCE(&i915->drm, !trans)) {\n\t\tintel_cx0_phy_transaction_end(encoder, wakeref);\n\t\treturn;\n\t}\n\n\tif (intel_is_c10phy(i915, phy)) {\n\t\tintel_cx0_rmw(i915, encoder->port, INTEL_CX0_BOTH_LANES, PHY_C10_VDR_CONTROL(1),\n\t\t\t      0, C10_VDR_CTRL_MSGBUS_ACCESS, MB_WRITE_COMMITTED);\n\t\tintel_cx0_rmw(i915, encoder->port, INTEL_CX0_BOTH_LANES, PHY_C10_VDR_CMN(3),\n\t\t\t      C10_CMN3_TXVBOOST_MASK,\n\t\t\t      C10_CMN3_TXVBOOST(intel_c10_get_tx_vboost_lvl(crtc_state)),\n\t\t\t      MB_WRITE_UNCOMMITTED);\n\t\tintel_cx0_rmw(i915, encoder->port, INTEL_CX0_BOTH_LANES, PHY_C10_VDR_TX(1),\n\t\t\t      C10_TX1_TERMCTL_MASK,\n\t\t\t      C10_TX1_TERMCTL(intel_c10_get_tx_term_ctl(crtc_state)),\n\t\t\t      MB_WRITE_COMMITTED);\n\t}\n\n\tfor (ln = 0; ln < crtc_state->lane_count; ln++) {\n\t\tint level = intel_ddi_level(encoder, crtc_state, ln);\n\t\tint lane, tx;\n\n\t\tlane = ln / 2;\n\t\ttx = ln % 2;\n\n\t\tintel_cx0_rmw(i915, encoder->port, BIT(lane), PHY_CX0_VDROVRD_CTL(lane, tx, 0),\n\t\t\t      C10_PHY_OVRD_LEVEL_MASK,\n\t\t\t      C10_PHY_OVRD_LEVEL(trans->entries[level].snps.pre_cursor),\n\t\t\t      MB_WRITE_COMMITTED);\n\t\tintel_cx0_rmw(i915, encoder->port, BIT(lane), PHY_CX0_VDROVRD_CTL(lane, tx, 1),\n\t\t\t      C10_PHY_OVRD_LEVEL_MASK,\n\t\t\t      C10_PHY_OVRD_LEVEL(trans->entries[level].snps.vswing),\n\t\t\t      MB_WRITE_COMMITTED);\n\t\tintel_cx0_rmw(i915, encoder->port, BIT(lane), PHY_CX0_VDROVRD_CTL(lane, tx, 2),\n\t\t\t      C10_PHY_OVRD_LEVEL_MASK,\n\t\t\t      C10_PHY_OVRD_LEVEL(trans->entries[level].snps.post_cursor),\n\t\t\t      MB_WRITE_COMMITTED);\n\t}\n\n\t \n\tintel_cx0_rmw(i915, encoder->port, INTEL_CX0_BOTH_LANES, PHY_C10_VDR_OVRD,\n\t\t      0, PHY_C10_VDR_OVRD_TX1 | PHY_C10_VDR_OVRD_TX2,\n\t\t      MB_WRITE_COMMITTED);\n\n\tif (intel_is_c10phy(i915, phy))\n\t\tintel_cx0_rmw(i915, encoder->port, INTEL_CX0_BOTH_LANES, PHY_C10_VDR_CONTROL(1),\n\t\t\t      0, C10_VDR_CTRL_UPDATE_CFG, MB_WRITE_COMMITTED);\n\n\tintel_cx0_phy_transaction_end(encoder, wakeref);\n}\n\n \n\nstatic const struct intel_c10pll_state mtl_c10_dp_rbr = {\n\t.clock = 162000,\n\t.tx = 0x10,\n\t.cmn = 0x21,\n\t.pll[0] = 0xB4,\n\t.pll[1] = 0,\n\t.pll[2] = 0x30,\n\t.pll[3] = 0x1,\n\t.pll[4] = 0x26,\n\t.pll[5] = 0x0C,\n\t.pll[6] = 0x98,\n\t.pll[7] = 0x46,\n\t.pll[8] = 0x1,\n\t.pll[9] = 0x1,\n\t.pll[10] = 0,\n\t.pll[11] = 0,\n\t.pll[12] = 0xC0,\n\t.pll[13] = 0,\n\t.pll[14] = 0,\n\t.pll[15] = 0x2,\n\t.pll[16] = 0x84,\n\t.pll[17] = 0x4F,\n\t.pll[18] = 0xE5,\n\t.pll[19] = 0x23,\n};\n\nstatic const struct intel_c10pll_state mtl_c10_edp_r216 = {\n\t.clock = 216000,\n\t.tx = 0x10,\n\t.cmn = 0x21,\n\t.pll[0] = 0x4,\n\t.pll[1] = 0,\n\t.pll[2] = 0xA2,\n\t.pll[3] = 0x1,\n\t.pll[4] = 0x33,\n\t.pll[5] = 0x10,\n\t.pll[6] = 0x75,\n\t.pll[7] = 0xB3,\n\t.pll[8] = 0x1,\n\t.pll[9] = 0x1,\n\t.pll[10] = 0,\n\t.pll[11] = 0,\n\t.pll[12] = 0,\n\t.pll[13] = 0,\n\t.pll[14] = 0,\n\t.pll[15] = 0x2,\n\t.pll[16] = 0x85,\n\t.pll[17] = 0x0F,\n\t.pll[18] = 0xE6,\n\t.pll[19] = 0x23,\n};\n\nstatic const struct intel_c10pll_state mtl_c10_edp_r243 = {\n\t.clock = 243000,\n\t.tx = 0x10,\n\t.cmn = 0x21,\n\t.pll[0] = 0x34,\n\t.pll[1] = 0,\n\t.pll[2] = 0xDA,\n\t.pll[3] = 0x1,\n\t.pll[4] = 0x39,\n\t.pll[5] = 0x12,\n\t.pll[6] = 0xE3,\n\t.pll[7] = 0xE9,\n\t.pll[8] = 0x1,\n\t.pll[9] = 0x1,\n\t.pll[10] = 0,\n\t.pll[11] = 0,\n\t.pll[12] = 0x20,\n\t.pll[13] = 0,\n\t.pll[14] = 0,\n\t.pll[15] = 0x2,\n\t.pll[16] = 0x85,\n\t.pll[17] = 0x8F,\n\t.pll[18] = 0xE6,\n\t.pll[19] = 0x23,\n};\n\nstatic const struct intel_c10pll_state mtl_c10_dp_hbr1 = {\n\t.clock = 270000,\n\t.tx = 0x10,\n\t.cmn = 0x21,\n\t.pll[0] = 0xF4,\n\t.pll[1] = 0,\n\t.pll[2] = 0xF8,\n\t.pll[3] = 0x0,\n\t.pll[4] = 0x20,\n\t.pll[5] = 0x0A,\n\t.pll[6] = 0x29,\n\t.pll[7] = 0x10,\n\t.pll[8] = 0x1,    \n\t.pll[9] = 0x1,\n\t.pll[10] = 0,\n\t.pll[11] = 0,\n\t.pll[12] = 0xA0,\n\t.pll[13] = 0,\n\t.pll[14] = 0,\n\t.pll[15] = 0x1,\n\t.pll[16] = 0x84,\n\t.pll[17] = 0x4F,\n\t.pll[18] = 0xE5,\n\t.pll[19] = 0x23,\n};\n\nstatic const struct intel_c10pll_state mtl_c10_edp_r324 = {\n\t.clock = 324000,\n\t.tx = 0x10,\n\t.cmn = 0x21,\n\t.pll[0] = 0xB4,\n\t.pll[1] = 0,\n\t.pll[2] = 0x30,\n\t.pll[3] = 0x1,\n\t.pll[4] = 0x26,\n\t.pll[5] = 0x0C,\n\t.pll[6] = 0x98,\n\t.pll[7] = 0x46,\n\t.pll[8] = 0x1,\n\t.pll[9] = 0x1,\n\t.pll[10] = 0,\n\t.pll[11] = 0,\n\t.pll[12] = 0xC0,\n\t.pll[13] = 0,\n\t.pll[14] = 0,\n\t.pll[15] = 0x1,\n\t.pll[16] = 0x85,\n\t.pll[17] = 0x4F,\n\t.pll[18] = 0xE6,\n\t.pll[19] = 0x23,\n};\n\nstatic const struct intel_c10pll_state mtl_c10_edp_r432 = {\n\t.clock = 432000,\n\t.tx = 0x10,\n\t.cmn = 0x21,\n\t.pll[0] = 0x4,\n\t.pll[1] = 0,\n\t.pll[2] = 0xA2,\n\t.pll[3] = 0x1,\n\t.pll[4] = 0x33,\n\t.pll[5] = 0x10,\n\t.pll[6] = 0x75,\n\t.pll[7] = 0xB3,\n\t.pll[8] = 0x1,\n\t.pll[9] = 0x1,\n\t.pll[10] = 0,\n\t.pll[11] = 0,\n\t.pll[12] = 0,\n\t.pll[13] = 0,\n\t.pll[14] = 0,\n\t.pll[15] = 0x1,\n\t.pll[16] = 0x85,\n\t.pll[17] = 0x0F,\n\t.pll[18] = 0xE6,\n\t.pll[19] = 0x23,\n};\n\nstatic const struct intel_c10pll_state mtl_c10_dp_hbr2 = {\n\t.clock = 540000,\n\t.tx = 0x10,\n\t.cmn = 0x21,\n\t.pll[0] = 0xF4,\n\t.pll[1] = 0,\n\t.pll[2] = 0xF8,\n\t.pll[3] = 0,\n\t.pll[4] = 0x20,\n\t.pll[5] = 0x0A,\n\t.pll[6] = 0x29,\n\t.pll[7] = 0x10,\n\t.pll[8] = 0x1,\n\t.pll[9] = 0x1,\n\t.pll[10] = 0,\n\t.pll[11] = 0,\n\t.pll[12] = 0xA0,\n\t.pll[13] = 0,\n\t.pll[14] = 0,\n\t.pll[15] = 0,\n\t.pll[16] = 0x84,\n\t.pll[17] = 0x4F,\n\t.pll[18] = 0xE5,\n\t.pll[19] = 0x23,\n};\n\nstatic const struct intel_c10pll_state mtl_c10_edp_r675 = {\n\t.clock = 675000,\n\t.tx = 0x10,\n\t.cmn = 0x21,\n\t.pll[0] = 0xB4,\n\t.pll[1] = 0,\n\t.pll[2] = 0x3E,\n\t.pll[3] = 0x1,\n\t.pll[4] = 0xA8,\n\t.pll[5] = 0x0C,\n\t.pll[6] = 0x33,\n\t.pll[7] = 0x54,\n\t.pll[8] = 0x1,\n\t.pll[9] = 0x1,\n\t.pll[10] = 0,\n\t.pll[11] = 0,\n\t.pll[12] = 0xC8,\n\t.pll[13] = 0,\n\t.pll[14] = 0,\n\t.pll[15] = 0,\n\t.pll[16] = 0x85,\n\t.pll[17] = 0x8F,\n\t.pll[18] = 0xE6,\n\t.pll[19] = 0x23,\n};\n\nstatic const struct intel_c10pll_state mtl_c10_dp_hbr3 = {\n\t.clock = 810000,\n\t.tx = 0x10,\n\t.cmn = 0x21,\n\t.pll[0] = 0x34,\n\t.pll[1] = 0,\n\t.pll[2] = 0x84,\n\t.pll[3] = 0x1,\n\t.pll[4] = 0x30,\n\t.pll[5] = 0x0F,\n\t.pll[6] = 0x3D,\n\t.pll[7] = 0x98,\n\t.pll[8] = 0x1,\n\t.pll[9] = 0x1,\n\t.pll[10] = 0,\n\t.pll[11] = 0,\n\t.pll[12] = 0xF0,\n\t.pll[13] = 0,\n\t.pll[14] = 0,\n\t.pll[15] = 0,\n\t.pll[16] = 0x84,\n\t.pll[17] = 0x0F,\n\t.pll[18] = 0xE5,\n\t.pll[19] = 0x23,\n};\n\nstatic const struct intel_c10pll_state * const mtl_c10_dp_tables[] = {\n\t&mtl_c10_dp_rbr,\n\t&mtl_c10_dp_hbr1,\n\t&mtl_c10_dp_hbr2,\n\t&mtl_c10_dp_hbr3,\n\tNULL,\n};\n\nstatic const struct intel_c10pll_state * const mtl_c10_edp_tables[] = {\n\t&mtl_c10_dp_rbr,\n\t&mtl_c10_edp_r216,\n\t&mtl_c10_edp_r243,\n\t&mtl_c10_dp_hbr1,\n\t&mtl_c10_edp_r324,\n\t&mtl_c10_edp_r432,\n\t&mtl_c10_dp_hbr2,\n\t&mtl_c10_edp_r675,\n\t&mtl_c10_dp_hbr3,\n\tNULL,\n};\n\n \nstatic const struct intel_c20pll_state mtl_c20_dp_rbr = {\n\t.link_bit_rate = 162000,\n\t.clock = 162000,\n\t.tx = {\t0xbe88,  \n\t\t0x5800,  \n\t\t0x0000,  \n\t\t},\n\t.cmn = {0x0500,  \n\t\t0x0005,  \n\t\t0x0000,  \n\t\t0x0000,  \n\t\t},\n\t.mpllb = { 0x50a8,\t \n\t\t0x2120,\t\t \n\t\t0xcd9a,\t\t \n\t\t0xbfc1,\t\t \n\t\t0x5ab8,          \n\t\t0x4c34,          \n\t\t0x2000,\t\t \n\t\t0x0001,\t\t \n\t\t0x6000,\t\t \n\t\t0x0000,\t\t \n\t\t0x0000,\t\t \n\t\t},\n};\n\nstatic const struct intel_c20pll_state mtl_c20_dp_hbr1 = {\n\t.link_bit_rate = 270000,\n\t.clock = 270000,\n\t.tx = {\t0xbe88,  \n\t\t0x4800,  \n\t\t0x0000,  \n\t\t},\n\t.cmn = {0x0500,  \n\t\t0x0005,  \n\t\t0x0000,  \n\t\t0x0000,  \n\t\t},\n\t.mpllb = { 0x308c,\t \n\t\t0x2110,\t\t \n\t\t0xcc9c,\t\t \n\t\t0xbfc1,\t\t \n\t\t0x4b9a,          \n\t\t0x3f81,          \n\t\t0x2000,\t\t \n\t\t0x0001,\t\t \n\t\t0x5000,\t\t \n\t\t0x0000,\t\t \n\t\t0x0000,\t\t \n\t\t},\n};\n\nstatic const struct intel_c20pll_state mtl_c20_dp_hbr2 = {\n\t.link_bit_rate = 540000,\n\t.clock = 540000,\n\t.tx = {\t0xbe88,  \n\t\t0x4800,  \n\t\t0x0000,  \n\t\t},\n\t.cmn = {0x0500,  \n\t\t0x0005,  \n\t\t0x0000,  \n\t\t0x0000,  \n\t\t},\n\t.mpllb = { 0x108c,\t \n\t\t0x2108,\t\t \n\t\t0xcc9c,\t\t \n\t\t0xbfc1,\t\t \n\t\t0x4b9a,          \n\t\t0x3f81,          \n\t\t0x2000,\t\t \n\t\t0x0001,\t\t \n\t\t0x5000,\t\t \n\t\t0x0000,\t\t \n\t\t0x0000,\t\t \n\t\t},\n};\n\nstatic const struct intel_c20pll_state mtl_c20_dp_hbr3 = {\n\t.link_bit_rate = 810000,\n\t.clock = 810000,\n\t.tx = {\t0xbe88,  \n\t\t0x4800,  \n\t\t0x0000,  \n\t\t},\n\t.cmn = {0x0500,  \n\t\t0x0005,  \n\t\t0x0000,  \n\t\t0x0000,  \n\t\t},\n\t.mpllb = { 0x10d2,\t \n\t\t0x2108,\t\t \n\t\t0x8d98,\t\t \n\t\t0xbfc1,\t\t \n\t\t0x7166,          \n\t\t0x5f42,          \n\t\t0x2000,\t\t \n\t\t0x0001,\t\t \n\t\t0x7800,\t\t \n\t\t0x0000,\t\t \n\t\t0x0000,\t\t \n\t\t},\n};\n\n \nstatic const struct intel_c20pll_state mtl_c20_dp_uhbr10 = {\n\t.link_bit_rate = 1000000,  \n\t.clock = 312500,\n\t.tx = {\t0xbe21,  \n\t\t0x4800,  \n\t\t0x0000,  \n\t\t},\n\t.cmn = {0x0500,  \n\t\t0x0005,  \n\t\t0x0000,  \n\t\t0x0000,  \n\t\t},\n\t.mplla = { 0x3104,\t \n\t\t0xd105,\t\t \n\t\t0xc025,\t\t \n\t\t0xc025,\t\t \n\t\t0x8c00,\t\t \n\t\t0x759a,\t\t \n\t\t0x4000,\t\t \n\t\t0x0003,\t\t \n\t\t0x3555,\t\t \n\t\t0x0001,\t\t \n\t\t},\n};\n\nstatic const struct intel_c20pll_state mtl_c20_dp_uhbr13_5 = {\n\t.link_bit_rate = 1350000,  \n\t.clock = 421875,\n\t.tx = {\t0xbea0,  \n\t\t0x4800,  \n\t\t0x0000,  \n\t\t},\n\t.cmn = {0x0500,  \n\t\t0x0005,  \n\t\t0x0000,  \n\t\t0x0000,  \n\t\t},\n\t.mpllb = { 0x015f,\t \n\t\t0x2205,\t\t \n\t\t0x1b17,\t\t \n\t\t0xffc1,\t\t \n\t\t0xe100,\t\t \n\t\t0xbd00,\t\t \n\t\t0x2000,\t\t \n\t\t0x0001,\t\t \n\t\t0x4800,\t\t \n\t\t0x0000,\t\t \n\t\t0x0000,\t\t \n\t\t},\n};\n\nstatic const struct intel_c20pll_state mtl_c20_dp_uhbr20 = {\n\t.link_bit_rate = 2000000,  \n\t.clock = 625000,\n\t.tx = {\t0xbe20,  \n\t\t0x4800,  \n\t\t0x0000,  \n\t\t},\n\t.cmn = {0x0500,  \n\t\t0x0005,  \n\t\t0x0000,  \n\t\t0x0000,  \n\t\t},\n\t.mplla = { 0x3104,\t \n\t\t0xd105,\t\t \n\t\t0xc025,\t\t \n\t\t0xc025,\t\t \n\t\t0xa6ab,\t\t \n\t\t0x8c00,\t\t \n\t\t0x4000,\t\t \n\t\t0x0003,\t\t \n\t\t0x3555,\t\t \n\t\t0x0001,\t\t \n\t\t},\n};\n\nstatic const struct intel_c20pll_state * const mtl_c20_dp_tables[] = {\n\t&mtl_c20_dp_rbr,\n\t&mtl_c20_dp_hbr1,\n\t&mtl_c20_dp_hbr2,\n\t&mtl_c20_dp_hbr3,\n\t&mtl_c20_dp_uhbr10,\n\t&mtl_c20_dp_uhbr13_5,\n\t&mtl_c20_dp_uhbr20,\n\tNULL,\n};\n\n \n\nstatic const struct intel_c10pll_state mtl_c10_hdmi_25_2 = {\n\t.clock = 25200,\n\t.tx = 0x10,\n\t.cmn = 0x1,\n\t.pll[0] = 0x4,\n\t.pll[1] = 0,\n\t.pll[2] = 0xB2,\n\t.pll[3] = 0,\n\t.pll[4] = 0,\n\t.pll[5] = 0,\n\t.pll[6] = 0,\n\t.pll[7] = 0,\n\t.pll[8] = 0x20,\n\t.pll[9] = 0x1,\n\t.pll[10] = 0,\n\t.pll[11] = 0,\n\t.pll[12] = 0,\n\t.pll[13] = 0,\n\t.pll[14] = 0,\n\t.pll[15] = 0xD,\n\t.pll[16] = 0x6,\n\t.pll[17] = 0x8F,\n\t.pll[18] = 0x84,\n\t.pll[19] = 0x23,\n};\n\nstatic const struct intel_c10pll_state mtl_c10_hdmi_27_0 = {\n\t.clock = 27000,\n\t.tx = 0x10,\n\t.cmn = 0x1,\n\t.pll[0] = 0x34,\n\t.pll[1] = 0,\n\t.pll[2] = 0xC0,\n\t.pll[3] = 0,\n\t.pll[4] = 0,\n\t.pll[5] = 0,\n\t.pll[6] = 0,\n\t.pll[7] = 0,\n\t.pll[8] = 0x20,\n\t.pll[9] = 0x1,\n\t.pll[10] = 0,\n\t.pll[11] = 0,\n\t.pll[12] = 0x80,\n\t.pll[13] = 0,\n\t.pll[14] = 0,\n\t.pll[15] = 0xD,\n\t.pll[16] = 0x6,\n\t.pll[17] = 0xCF,\n\t.pll[18] = 0x84,\n\t.pll[19] = 0x23,\n};\n\nstatic const struct intel_c10pll_state mtl_c10_hdmi_74_25 = {\n\t.clock = 74250,\n\t.tx = 0x10,\n\t.cmn = 0x1,\n\t.pll[0] = 0xF4,\n\t.pll[1] = 0,\n\t.pll[2] = 0x7A,\n\t.pll[3] = 0,\n\t.pll[4] = 0,\n\t.pll[5] = 0,\n\t.pll[6] = 0,\n\t.pll[7] = 0,\n\t.pll[8] = 0x20,\n\t.pll[9] = 0x1,\n\t.pll[10] = 0,\n\t.pll[11] = 0,\n\t.pll[12] = 0x58,\n\t.pll[13] = 0,\n\t.pll[14] = 0,\n\t.pll[15] = 0xB,\n\t.pll[16] = 0x6,\n\t.pll[17] = 0xF,\n\t.pll[18] = 0x85,\n\t.pll[19] = 0x23,\n};\n\nstatic const struct intel_c10pll_state mtl_c10_hdmi_148_5 = {\n\t.clock = 148500,\n\t.tx = 0x10,\n\t.cmn = 0x1,\n\t.pll[0] = 0xF4,\n\t.pll[1] = 0,\n\t.pll[2] = 0x7A,\n\t.pll[3] = 0,\n\t.pll[4] = 0,\n\t.pll[5] = 0,\n\t.pll[6] = 0,\n\t.pll[7] = 0,\n\t.pll[8] = 0x20,\n\t.pll[9] = 0x1,\n\t.pll[10] = 0,\n\t.pll[11] = 0,\n\t.pll[12] = 0x58,\n\t.pll[13] = 0,\n\t.pll[14] = 0,\n\t.pll[15] = 0xA,\n\t.pll[16] = 0x6,\n\t.pll[17] = 0xF,\n\t.pll[18] = 0x85,\n\t.pll[19] = 0x23,\n};\n\nstatic const struct intel_c10pll_state mtl_c10_hdmi_594 = {\n\t.clock = 594000,\n\t.tx = 0x10,\n\t.cmn = 0x1,\n\t.pll[0] = 0xF4,\n\t.pll[1] = 0,\n\t.pll[2] = 0x7A,\n\t.pll[3] = 0,\n\t.pll[4] = 0,\n\t.pll[5] = 0,\n\t.pll[6] = 0,\n\t.pll[7] = 0,\n\t.pll[8] = 0x20,\n\t.pll[9] = 0x1,\n\t.pll[10] = 0,\n\t.pll[11] = 0,\n\t.pll[12] = 0x58,\n\t.pll[13] = 0,\n\t.pll[14] = 0,\n\t.pll[15] = 0x8,\n\t.pll[16] = 0x6,\n\t.pll[17] = 0xF,\n\t.pll[18] = 0x85,\n\t.pll[19] = 0x23,\n};\n\n \nstatic const struct intel_c10pll_state mtl_c10_hdmi_27027 = {\n\t.clock = 27027,\n\t.tx = 0x10,\n\t.cmn = 0x1,\n\t.pll[0] = 0x34, .pll[1] = 0x00, .pll[2] = 0xC0, .pll[3] = 0x00, .pll[4] = 0x00,\n\t.pll[5] = 0x00, .pll[6] = 0x00, .pll[7] = 0x00, .pll[8] = 0x20, .pll[9] = 0xFF,\n\t.pll[10] = 0xFF, .pll[11] = 0xCC, .pll[12] = 0x9C, .pll[13] = 0xCB, .pll[14] = 0xCC,\n\t.pll[15] = 0x0D, .pll[16] = 0x08, .pll[17] = 0x8F, .pll[18] = 0x84, .pll[19] = 0x23,\n};\n\nstatic const struct intel_c10pll_state mtl_c10_hdmi_28320 = {\n\t.clock = 28320,\n\t.tx = 0x10,\n\t.cmn = 0x1,\n\t.pll[0] = 0x04, .pll[1] = 0x00, .pll[2] = 0xCC, .pll[3] = 0x00, .pll[4] = 0x00,\n\t.pll[5] = 0x00, .pll[6] = 0x00, .pll[7] = 0x00, .pll[8] = 0x20, .pll[9] = 0xFF,\n\t.pll[10] = 0xFF, .pll[11] = 0x00, .pll[12] = 0x00, .pll[13] = 0x00, .pll[14] = 0x00,\n\t.pll[15] = 0x0D, .pll[16] = 0x08, .pll[17] = 0x8F, .pll[18] = 0x84, .pll[19] = 0x23,\n};\n\nstatic const struct intel_c10pll_state mtl_c10_hdmi_30240 = {\n\t.clock = 30240,\n\t.tx = 0x10,\n\t.cmn = 0x1,\n\t.pll[0] = 0x04, .pll[1] = 0x00, .pll[2] = 0xDC, .pll[3] = 0x00, .pll[4] = 0x00,\n\t.pll[5] = 0x00, .pll[6] = 0x00, .pll[7] = 0x00, .pll[8] = 0x20, .pll[9] = 0xFF,\n\t.pll[10] = 0xFF, .pll[11] = 0x00, .pll[12] = 0x00, .pll[13] = 0x00, .pll[14] = 0x00,\n\t.pll[15] = 0x0D, .pll[16] = 0x08, .pll[17] = 0xCF, .pll[18] = 0x84, .pll[19] = 0x23,\n};\n\nstatic const struct intel_c10pll_state mtl_c10_hdmi_31500 = {\n\t.clock = 31500,\n\t.tx = 0x10,\n\t.cmn = 0x1,\n\t.pll[0] = 0xF4, .pll[1] = 0x00, .pll[2] = 0x62, .pll[3] = 0x00, .pll[4] = 0x00,\n\t.pll[5] = 0x00, .pll[6] = 0x00, .pll[7] = 0x00, .pll[8] = 0x20, .pll[9] = 0xFF,\n\t.pll[10] = 0xFF, .pll[11] = 0x00, .pll[12] = 0xA0, .pll[13] = 0x00, .pll[14] = 0x00,\n\t.pll[15] = 0x0C, .pll[16] = 0x09, .pll[17] = 0x8F, .pll[18] = 0x84, .pll[19] = 0x23,\n};\n\nstatic const struct intel_c10pll_state mtl_c10_hdmi_36000 = {\n\t.clock = 36000,\n\t.tx = 0x10,\n\t.cmn = 0x1,\n\t.pll[0] = 0xC4, .pll[1] = 0x00, .pll[2] = 0x76, .pll[3] = 0x00, .pll[4] = 0x00,\n\t.pll[5] = 0x00, .pll[6] = 0x00, .pll[7] = 0x00, .pll[8] = 0x20, .pll[9] = 0xFF,\n\t.pll[10] = 0xFF, .pll[11] = 0x00, .pll[12] = 0x00, .pll[13] = 0x00, .pll[14] = 0x00,\n\t.pll[15] = 0x0C, .pll[16] = 0x08, .pll[17] = 0x8F, .pll[18] = 0x84, .pll[19] = 0x23,\n};\n\nstatic const struct intel_c10pll_state mtl_c10_hdmi_40000 = {\n\t.clock = 40000,\n\t.tx = 0x10,\n\t.cmn = 0x1,\n\t.pll[0] = 0xB4, .pll[1] = 0x00, .pll[2] = 0x86, .pll[3] = 0x00, .pll[4] = 0x00,\n\t.pll[5] = 0x00, .pll[6] = 0x00, .pll[7] = 0x00, .pll[8] = 0x20, .pll[9] = 0xFF,\n\t.pll[10] = 0xFF, .pll[11] = 0x55, .pll[12] = 0x55, .pll[13] = 0x55, .pll[14] = 0x55,\n\t.pll[15] = 0x0C, .pll[16] = 0x08, .pll[17] = 0x8F, .pll[18] = 0x84, .pll[19] = 0x23,\n};\n\nstatic const struct intel_c10pll_state mtl_c10_hdmi_49500 = {\n\t.clock = 49500,\n\t.tx = 0x10,\n\t.cmn = 0x1,\n\t.pll[0] = 0x74, .pll[1] = 0x00, .pll[2] = 0xAE, .pll[3] = 0x00, .pll[4] = 0x00,\n\t.pll[5] = 0x00, .pll[6] = 0x00, .pll[7] = 0x00, .pll[8] = 0x20, .pll[9] = 0xFF,\n\t.pll[10] = 0xFF, .pll[11] = 0x00, .pll[12] = 0x20, .pll[13] = 0x00, .pll[14] = 0x00,\n\t.pll[15] = 0x0C, .pll[16] = 0x08, .pll[17] = 0xCF, .pll[18] = 0x84, .pll[19] = 0x23,\n};\n\nstatic const struct intel_c10pll_state mtl_c10_hdmi_50000 = {\n\t.clock = 50000,\n\t.tx = 0x10,\n\t.cmn = 0x1,\n\t.pll[0] = 0x74, .pll[1] = 0x00, .pll[2] = 0xB0, .pll[3] = 0x00, .pll[4] = 0x00,\n\t.pll[5] = 0x00, .pll[6] = 0x00, .pll[7] = 0x00, .pll[8] = 0x20, .pll[9] = 0xFF,\n\t.pll[10] = 0xFF, .pll[11] = 0xAA, .pll[12] = 0x2A, .pll[13] = 0xA9, .pll[14] = 0xAA,\n\t.pll[15] = 0x0C, .pll[16] = 0x08, .pll[17] = 0xCF, .pll[18] = 0x84, .pll[19] = 0x23,\n};\n\nstatic const struct intel_c10pll_state mtl_c10_hdmi_57284 = {\n\t.clock = 57284,\n\t.tx = 0x10,\n\t.cmn = 0x1,\n\t.pll[0] = 0x34, .pll[1] = 0x00, .pll[2] = 0xCE, .pll[3] = 0x00, .pll[4] = 0x00,\n\t.pll[5] = 0x00, .pll[6] = 0x00, .pll[7] = 0x00, .pll[8] = 0x20, .pll[9] = 0xFF,\n\t.pll[10] = 0xFF, .pll[11] = 0x77, .pll[12] = 0x57, .pll[13] = 0x77, .pll[14] = 0x77,\n\t.pll[15] = 0x0C, .pll[16] = 0x08, .pll[17] = 0x8F, .pll[18] = 0x84, .pll[19] = 0x23,\n};\n\nstatic const struct intel_c10pll_state mtl_c10_hdmi_58000 = {\n\t.clock = 58000,\n\t.tx = 0x10,\n\t.cmn = 0x1,\n\t.pll[0] = 0x34, .pll[1] = 0x00, .pll[2] = 0xD0, .pll[3] = 0x00, .pll[4] = 0x00,\n\t.pll[5] = 0x00, .pll[6] = 0x00, .pll[7] = 0x00, .pll[8] = 0x20, .pll[9] = 0xFF,\n\t.pll[10] = 0xFF, .pll[11] = 0x55, .pll[12] = 0xD5, .pll[13] = 0x55, .pll[14] = 0x55,\n\t.pll[15] = 0x0C, .pll[16] = 0x08, .pll[17] = 0xCF, .pll[18] = 0x84, .pll[19] = 0x23,\n};\n\nstatic const struct intel_c10pll_state mtl_c10_hdmi_65000 = {\n\t.clock = 65000,\n\t.tx = 0x10,\n\t.cmn = 0x1,\n\t.pll[0] = 0xF4, .pll[1] = 0x00, .pll[2] = 0x66, .pll[3] = 0x00, .pll[4] = 0x00,\n\t.pll[5] = 0x00, .pll[6] = 0x00, .pll[7] = 0x00, .pll[8] = 0x20, .pll[9] = 0xFF,\n\t.pll[10] = 0xFF, .pll[11] = 0x55, .pll[12] = 0xB5, .pll[13] = 0x55, .pll[14] = 0x55,\n\t.pll[15] = 0x0B, .pll[16] = 0x09, .pll[17] = 0xCF, .pll[18] = 0x84, .pll[19] = 0x23,\n};\n\nstatic const struct intel_c10pll_state mtl_c10_hdmi_71000 = {\n\t.clock = 71000,\n\t.tx = 0x10,\n\t.cmn = 0x1,\n\t.pll[0] = 0xF4, .pll[1] = 0x00, .pll[2] = 0x72, .pll[3] = 0x00, .pll[4] = 0x00,\n\t.pll[5] = 0x00, .pll[6] = 0x00, .pll[7] = 0x00, .pll[8] = 0x20, .pll[9] = 0xFF,\n\t.pll[10] = 0xFF, .pll[11] = 0x55, .pll[12] = 0xF5, .pll[13] = 0x55, .pll[14] = 0x55,\n\t.pll[15] = 0x0B, .pll[16] = 0x08, .pll[17] = 0x8F, .pll[18] = 0x84, .pll[19] = 0x23,\n};\n\nstatic const struct intel_c10pll_state mtl_c10_hdmi_74176 = {\n\t.clock = 74176,\n\t.tx = 0x10,\n\t.cmn = 0x1,\n\t.pll[0] = 0xF4, .pll[1] = 0x00, .pll[2] = 0x7A, .pll[3] = 0x00, .pll[4] = 0x00,\n\t.pll[5] = 0x00, .pll[6] = 0x00, .pll[7] = 0x00, .pll[8] = 0x20, .pll[9] = 0xFF,\n\t.pll[10] = 0xFF, .pll[11] = 0x44, .pll[12] = 0x44, .pll[13] = 0x44, .pll[14] = 0x44,\n\t.pll[15] = 0x0B, .pll[16] = 0x08, .pll[17] = 0x8F, .pll[18] = 0x84, .pll[19] = 0x23,\n};\n\nstatic const struct intel_c10pll_state mtl_c10_hdmi_75000 = {\n\t.clock = 75000,\n\t.tx = 0x10,\n\t.cmn = 0x1,\n\t.pll[0] = 0xF4, .pll[1] = 0x00, .pll[2] = 0x7C, .pll[3] = 0x00, .pll[4] = 0x00,\n\t.pll[5] = 0x00, .pll[6] = 0x00, .pll[7] = 0x00, .pll[8] = 0x20, .pll[9] = 0xFF,\n\t.pll[10] = 0xFF, .pll[11] = 0x00, .pll[12] = 0x20, .pll[13] = 0x00, .pll[14] = 0x00,\n\t.pll[15] = 0x0B, .pll[16] = 0x08, .pll[17] = 0xCF, .pll[18] = 0x84, .pll[19] = 0x23,\n};\n\nstatic const struct intel_c10pll_state mtl_c10_hdmi_78750 = {\n\t.clock = 78750,\n\t.tx = 0x10,\n\t.cmn = 0x1,\n\t.pll[0] = 0xB4, .pll[1] = 0x00, .pll[2] = 0x84, .pll[3] = 0x00, .pll[4] = 0x00,\n\t.pll[5] = 0x00, .pll[6] = 0x00, .pll[7] = 0x00, .pll[8] = 0x20, .pll[9] = 0xFF,\n\t.pll[10] = 0xFF, .pll[11] = 0x00, .pll[12] = 0x08, .pll[13] = 0x00, .pll[14] = 0x00,\n\t.pll[15] = 0x0B, .pll[16] = 0x08, .pll[17] = 0x8F, .pll[18] = 0x84, .pll[19] = 0x23,\n};\n\nstatic const struct intel_c10pll_state mtl_c10_hdmi_85500 = {\n\t.clock = 85500,\n\t.tx = 0x10,\n\t.cmn = 0x1,\n\t.pll[0] = 0xB4, .pll[1] = 0x00, .pll[2] = 0x92, .pll[3] = 0x00, .pll[4] = 0x00,\n\t.pll[5] = 0x00, .pll[6] = 0x00, .pll[7] = 0x00, .pll[8] = 0x20, .pll[9] = 0xFF,\n\t.pll[10] = 0xFF, .pll[11] = 0x00, .pll[12] = 0x10, .pll[13] = 0x00, .pll[14] = 0x00,\n\t.pll[15] = 0x0B, .pll[16] = 0x08, .pll[17] = 0xCF, .pll[18] = 0x84, .pll[19] = 0x23,\n};\n\nstatic const struct intel_c10pll_state mtl_c10_hdmi_88750 = {\n\t.clock = 88750,\n\t.tx = 0x10,\n\t.cmn = 0x1,\n\t.pll[0] = 0x74, .pll[1] = 0x00, .pll[2] = 0x98, .pll[3] = 0x00, .pll[4] = 0x00,\n\t.pll[5] = 0x00, .pll[6] = 0x00, .pll[7] = 0x00, .pll[8] = 0x20, .pll[9] = 0xFF,\n\t.pll[10] = 0xFF, .pll[11] = 0xAA, .pll[12] = 0x72, .pll[13] = 0xA9, .pll[14] = 0xAA,\n\t.pll[15] = 0x0B, .pll[16] = 0x09, .pll[17] = 0xCF, .pll[18] = 0x84, .pll[19] = 0x23,\n};\n\nstatic const struct intel_c10pll_state mtl_c10_hdmi_106500 = {\n\t.clock = 106500,\n\t.tx = 0x10,\n\t.cmn = 0x1,\n\t.pll[0] = 0x34, .pll[1] = 0x00, .pll[2] = 0xBC, .pll[3] = 0x00, .pll[4] = 0x00,\n\t.pll[5] = 0x00, .pll[6] = 0x00, .pll[7] = 0x00, .pll[8] = 0x20, .pll[9] = 0xFF,\n\t.pll[10] = 0xFF, .pll[11] = 0x00, .pll[12] = 0xF0, .pll[13] = 0x00, .pll[14] = 0x00,\n\t.pll[15] = 0x0B, .pll[16] = 0x08, .pll[17] = 0x8F, .pll[18] = 0x84, .pll[19] = 0x23,\n};\n\nstatic const struct intel_c10pll_state mtl_c10_hdmi_108000 = {\n\t.clock = 108000,\n\t.tx = 0x10,\n\t.cmn = 0x1,\n\t.pll[0] = 0x34, .pll[1] = 0x00, .pll[2] = 0xC0, .pll[3] = 0x00, .pll[4] = 0x00,\n\t.pll[5] = 0x00, .pll[6] = 0x00, .pll[7] = 0x00, .pll[8] = 0x20, .pll[9] = 0xFF,\n\t.pll[10] = 0xFF, .pll[11] = 0x00, .pll[12] = 0x80, .pll[13] = 0x00, .pll[14] = 0x00,\n\t.pll[15] = 0x0B, .pll[16] = 0x08, .pll[17] = 0x8F, .pll[18] = 0x84, .pll[19] = 0x23,\n};\n\nstatic const struct intel_c10pll_state mtl_c10_hdmi_115500 = {\n\t.clock = 115500,\n\t.tx = 0x10,\n\t.cmn = 0x1,\n\t.pll[0] = 0x34, .pll[1] = 0x00, .pll[2] = 0xD0, .pll[3] = 0x00, .pll[4] = 0x00,\n\t.pll[5] = 0x00, .pll[6] = 0x00, .pll[7] = 0x00, .pll[8] = 0x20, .pll[9] = 0xFF,\n\t.pll[10] = 0xFF, .pll[11] = 0x00, .pll[12] = 0x50, .pll[13] = 0x00, .pll[14] = 0x00,\n\t.pll[15] = 0x0B, .pll[16] = 0x08, .pll[17] = 0xCF, .pll[18] = 0x84, .pll[19] = 0x23,\n};\n\nstatic const struct intel_c10pll_state mtl_c10_hdmi_119000 = {\n\t.clock = 119000,\n\t.tx = 0x10,\n\t.cmn = 0x1,\n\t.pll[0] = 0x34, .pll[1] = 0x00, .pll[2] = 0xD6, .pll[3] = 0x00, .pll[4] = 0x00,\n\t.pll[5] = 0x00, .pll[6] = 0x00, .pll[7] = 0x00, .pll[8] = 0x20, .pll[9] = 0xFF,\n\t.pll[10] = 0xFF, .pll[11] = 0x55, .pll[12] = 0xF5, .pll[13] = 0x55, .pll[14] = 0x55,\n\t.pll[15] = 0x0B, .pll[16] = 0x08, .pll[17] = 0xCF, .pll[18] = 0x84, .pll[19] = 0x23,\n};\n\nstatic const struct intel_c10pll_state mtl_c10_hdmi_135000 = {\n\t.clock = 135000,\n\t.tx = 0x10,\n\t.cmn = 0x1,\n\t.pll[0] = 0xF4, .pll[1] = 0x00, .pll[2] = 0x6C, .pll[3] = 0x00, .pll[4] = 0x00,\n\t.pll[5] = 0x00, .pll[6] = 0x00, .pll[7] = 0x00, .pll[8] = 0x20, .pll[9] = 0xFF,\n\t.pll[10] = 0xFF, .pll[11] = 0x00, .pll[12] = 0x50, .pll[13] = 0x00, .pll[14] = 0x00,\n\t.pll[15] = 0x0A, .pll[16] = 0x09, .pll[17] = 0xCF, .pll[18] = 0x84, .pll[19] = 0x23,\n};\n\nstatic const struct intel_c10pll_state mtl_c10_hdmi_138500 = {\n\t.clock = 138500,\n\t.tx = 0x10,\n\t.cmn = 0x1,\n\t.pll[0] = 0xF4, .pll[1] = 0x00, .pll[2] = 0x70, .pll[3] = 0x00, .pll[4] = 0x00,\n\t.pll[5] = 0x00, .pll[6] = 0x00, .pll[7] = 0x00, .pll[8] = 0x20, .pll[9] = 0xFF,\n\t.pll[10] = 0xFF, .pll[11] = 0xAA, .pll[12] = 0x22, .pll[13] = 0xA9, .pll[14] = 0xAA,\n\t.pll[15] = 0x0A, .pll[16] = 0x08, .pll[17] = 0x8F, .pll[18] = 0x84, .pll[19] = 0x23,\n};\n\nstatic const struct intel_c10pll_state mtl_c10_hdmi_147160 = {\n\t.clock = 147160,\n\t.tx = 0x10,\n\t.cmn = 0x1,\n\t.pll[0] = 0xF4, .pll[1] = 0x00, .pll[2] = 0x78, .pll[3] = 0x00, .pll[4] = 0x00,\n\t.pll[5] = 0x00, .pll[6] = 0x00, .pll[7] = 0x00, .pll[8] = 0x20, .pll[9] = 0xFF,\n\t.pll[10] = 0xFF, .pll[11] = 0x55, .pll[12] = 0xA5, .pll[13] = 0x55, .pll[14] = 0x55,\n\t.pll[15] = 0x0A, .pll[16] = 0x08, .pll[17] = 0x8F, .pll[18] = 0x84, .pll[19] = 0x23,\n};\n\nstatic const struct intel_c10pll_state mtl_c10_hdmi_148352 = {\n\t.clock = 148352,\n\t.tx = 0x10,\n\t.cmn = 0x1,\n\t.pll[0] = 0xF4, .pll[1] = 0x00, .pll[2] = 0x7A, .pll[3] = 0x00, .pll[4] = 0x00,\n\t.pll[5] = 0x00, .pll[6] = 0x00, .pll[7] = 0x00, .pll[8] = 0x20, .pll[9] = 0xFF,\n\t.pll[10] = 0xFF, .pll[11] = 0x44, .pll[12] = 0x44, .pll[13] = 0x44, .pll[14] = 0x44,\n\t.pll[15] = 0x0A, .pll[16] = 0x08, .pll[17] = 0x8F, .pll[18] = 0x84, .pll[19] = 0x23,\n};\n\nstatic const struct intel_c10pll_state mtl_c10_hdmi_154000 = {\n\t.clock = 154000,\n\t.tx = 0x10,\n\t.cmn = 0x1,\n\t.pll[0] = 0xB4, .pll[1] = 0x00, .pll[2] = 0x80, .pll[3] = 0x00, .pll[4] = 0x00,\n\t.pll[5] = 0x00, .pll[6] = 0x00, .pll[7] = 0x00, .pll[8] = 0x20, .pll[9] = 0xFF,\n\t.pll[10] = 0xFF, .pll[11] = 0x55, .pll[12] = 0x35, .pll[13] = 0x55, .pll[14] = 0x55,\n\t.pll[15] = 0x0A, .pll[16] = 0x08, .pll[17] = 0x8F, .pll[18] = 0x84, .pll[19] = 0x23,\n};\n\nstatic const struct intel_c10pll_state mtl_c10_hdmi_162000 = {\n\t.clock = 162000,\n\t.tx = 0x10,\n\t.cmn = 0x1,\n\t.pll[0] = 0xB4, .pll[1] = 0x00, .pll[2] = 0x88, .pll[3] = 0x00, .pll[4] = 0x00,\n\t.pll[5] = 0x00, .pll[6] = 0x00, .pll[7] = 0x00, .pll[8] = 0x20, .pll[9] = 0xFF,\n\t.pll[10] = 0xFF, .pll[11] = 0x00, .pll[12] = 0x60, .pll[13] = 0x00, .pll[14] = 0x00,\n\t.pll[15] = 0x0A, .pll[16] = 0x08, .pll[17] = 0x8F, .pll[18] = 0x84, .pll[19] = 0x23,\n};\n\nstatic const struct intel_c10pll_state mtl_c10_hdmi_167000 = {\n\t.clock = 167000,\n\t.tx = 0x10,\n\t.cmn = 0x1,\n\t.pll[0] = 0xB4, .pll[1] = 0x00, .pll[2] = 0x8C, .pll[3] = 0x00, .pll[4] = 0x00,\n\t.pll[5] = 0x00, .pll[6] = 0x00, .pll[7] = 0x00, .pll[8] = 0x20, .pll[9] = 0xFF,\n\t.pll[10] = 0xFF, .pll[11] = 0xAA, .pll[12] = 0xFA, .pll[13] = 0xA9, .pll[14] = 0xAA,\n\t.pll[15] = 0x0A, .pll[16] = 0x08, .pll[17] = 0x8F, .pll[18] = 0x84, .pll[19] = 0x23,\n};\n\nstatic const struct intel_c10pll_state mtl_c10_hdmi_197802 = {\n\t.clock = 197802,\n\t.tx = 0x10,\n\t.cmn = 0x1,\n\t.pll[0] = 0x74, .pll[1] = 0x00, .pll[2] = 0xAE, .pll[3] = 0x00, .pll[4] = 0x00,\n\t.pll[5] = 0x00, .pll[6] = 0x00, .pll[7] = 0x00, .pll[8] = 0x20, .pll[9] = 0xFF,\n\t.pll[10] = 0xFF, .pll[11] = 0x99, .pll[12] = 0x05, .pll[13] = 0x98, .pll[14] = 0x99,\n\t.pll[15] = 0x0A, .pll[16] = 0x08, .pll[17] = 0xCF, .pll[18] = 0x84, .pll[19] = 0x23,\n};\n\nstatic const struct intel_c10pll_state mtl_c10_hdmi_198000 = {\n\t.clock = 198000,\n\t.tx = 0x10,\n\t.cmn = 0x1,\n\t.pll[0] = 0x74, .pll[1] = 0x00, .pll[2] = 0xAE, .pll[3] = 0x00, .pll[4] = 0x00,\n\t.pll[5] = 0x00, .pll[6] = 0x00, .pll[7] = 0x00, .pll[8] = 0x20, .pll[9] = 0xFF,\n\t.pll[10] = 0xFF, .pll[11] = 0x00, .pll[12] = 0x20, .pll[13] = 0x00, .pll[14] = 0x00,\n\t.pll[15] = 0x0A, .pll[16] = 0x08, .pll[17] = 0xCF, .pll[18] = 0x84, .pll[19] = 0x23,\n};\n\nstatic const struct intel_c10pll_state mtl_c10_hdmi_209800 = {\n\t.clock = 209800,\n\t.tx = 0x10,\n\t.cmn = 0x1,\n\t.pll[0] = 0x34, .pll[1] = 0x00, .pll[2] = 0xBA, .pll[3] = 0x00, .pll[4] = 0x00,\n\t.pll[5] = 0x00, .pll[6] = 0x00, .pll[7] = 0x00, .pll[8] = 0x20, .pll[9] = 0xFF,\n\t.pll[10] = 0xFF, .pll[11] = 0x55, .pll[12] = 0x45, .pll[13] = 0x55, .pll[14] = 0x55,\n\t.pll[15] = 0x0A, .pll[16] = 0x08, .pll[17] = 0x8F, .pll[18] = 0x84, .pll[19] = 0x23,\n};\n\nstatic const struct intel_c10pll_state mtl_c10_hdmi_241500 = {\n\t.clock = 241500,\n\t.tx = 0x10,\n\t.cmn = 0x1,\n\t.pll[0] = 0x34, .pll[1] = 0x00, .pll[2] = 0xDA, .pll[3] = 0x00, .pll[4] = 0x00,\n\t.pll[5] = 0x00, .pll[6] = 0x00, .pll[7] = 0x00, .pll[8] = 0x20, .pll[9] = 0xFF,\n\t.pll[10] = 0xFF, .pll[11] = 0x00, .pll[12] = 0xC8, .pll[13] = 0x00, .pll[14] = 0x00,\n\t.pll[15] = 0x0A, .pll[16] = 0x08, .pll[17] = 0xCF, .pll[18] = 0x84, .pll[19] = 0x23,\n};\n\nstatic const struct intel_c10pll_state mtl_c10_hdmi_262750 = {\n\t.clock = 262750,\n\t.tx = 0x10,\n\t.cmn = 0x1,\n\t.pll[0] = 0xF4, .pll[1] = 0x00, .pll[2] = 0x68, .pll[3] = 0x00, .pll[4] = 0x00,\n\t.pll[5] = 0x00, .pll[6] = 0x00, .pll[7] = 0x00, .pll[8] = 0x20, .pll[9] = 0xFF,\n\t.pll[10] = 0xFF, .pll[11] = 0xAA, .pll[12] = 0x6C, .pll[13] = 0xA9, .pll[14] = 0xAA,\n\t.pll[15] = 0x09, .pll[16] = 0x09, .pll[17] = 0xCF, .pll[18] = 0x84, .pll[19] = 0x23,\n};\n\nstatic const struct intel_c10pll_state mtl_c10_hdmi_268500 = {\n\t.clock = 268500,\n\t.tx = 0x10,\n\t.cmn = 0x1,\n\t.pll[0] = 0xF4, .pll[1] = 0x00, .pll[2] = 0x6A, .pll[3] = 0x00, .pll[4] = 0x00,\n\t.pll[5] = 0x00, .pll[6] = 0x00, .pll[7] = 0x00, .pll[8] = 0x20, .pll[9] = 0xFF,\n\t.pll[10] = 0xFF, .pll[11] = 0x00, .pll[12] = 0xEC, .pll[13] = 0x00, .pll[14] = 0x00,\n\t.pll[15] = 0x09, .pll[16] = 0x09, .pll[17] = 0xCF, .pll[18] = 0x84, .pll[19] = 0x23,\n};\n\nstatic const struct intel_c10pll_state mtl_c10_hdmi_296703 = {\n\t.clock = 296703,\n\t.tx = 0x10,\n\t.cmn = 0x1,\n\t.pll[0] = 0xF4, .pll[1] = 0x00, .pll[2] = 0x7A, .pll[3] = 0x00, .pll[4] = 0x00,\n\t.pll[5] = 0x00, .pll[6] = 0x00, .pll[7] = 0x00, .pll[8] = 0x20, .pll[9] = 0xFF,\n\t.pll[10] = 0xFF, .pll[11] = 0x33, .pll[12] = 0x44, .pll[13] = 0x33, .pll[14] = 0x33,\n\t.pll[15] = 0x09, .pll[16] = 0x08, .pll[17] = 0x8F, .pll[18] = 0x84, .pll[19] = 0x23,\n};\n\nstatic const struct intel_c10pll_state mtl_c10_hdmi_297000 = {\n\t.clock = 297000,\n\t.tx = 0x10,\n\t.cmn = 0x1,\n\t.pll[0] = 0xF4, .pll[1] = 0x00, .pll[2] = 0x7A, .pll[3] = 0x00, .pll[4] = 0x00,\n\t.pll[5] = 0x00, .pll[6] = 0x00, .pll[7] = 0x00, .pll[8] = 0x20, .pll[9] = 0xFF,\n\t.pll[10] = 0xFF, .pll[11] = 0x00, .pll[12] = 0x58, .pll[13] = 0x00, .pll[14] = 0x00,\n\t.pll[15] = 0x09, .pll[16] = 0x08, .pll[17] = 0x8F, .pll[18] = 0x84, .pll[19] = 0x23,\n};\n\nstatic const struct intel_c10pll_state mtl_c10_hdmi_319750 = {\n\t.clock = 319750,\n\t.tx = 0x10,\n\t.cmn = 0x1,\n\t.pll[0] = 0xB4, .pll[1] = 0x00, .pll[2] = 0x86, .pll[3] = 0x00, .pll[4] = 0x00,\n\t.pll[5] = 0x00, .pll[6] = 0x00, .pll[7] = 0x00, .pll[8] = 0x20, .pll[9] = 0xFF,\n\t.pll[10] = 0xFF, .pll[11] = 0xAA, .pll[12] = 0x44, .pll[13] = 0xA9, .pll[14] = 0xAA,\n\t.pll[15] = 0x09, .pll[16] = 0x08, .pll[17] = 0x8F, .pll[18] = 0x84, .pll[19] = 0x23,\n};\n\nstatic const struct intel_c10pll_state mtl_c10_hdmi_497750 = {\n\t.clock = 497750,\n\t.tx = 0x10,\n\t.cmn = 0x1,\n\t.pll[0] = 0x34, .pll[1] = 0x00, .pll[2] = 0xE2, .pll[3] = 0x00, .pll[4] = 0x00,\n\t.pll[5] = 0x00, .pll[6] = 0x00, .pll[7] = 0x00, .pll[8] = 0x20, .pll[9] = 0xFF,\n\t.pll[10] = 0xFF, .pll[11] = 0x55, .pll[12] = 0x9F, .pll[13] = 0x55, .pll[14] = 0x55,\n\t.pll[15] = 0x09, .pll[16] = 0x08, .pll[17] = 0xCF, .pll[18] = 0x84, .pll[19] = 0x23,\n};\n\nstatic const struct intel_c10pll_state mtl_c10_hdmi_592000 = {\n\t.clock = 592000,\n\t.tx = 0x10,\n\t.cmn = 0x1,\n\t.pll[0] = 0xF4, .pll[1] = 0x00, .pll[2] = 0x7A, .pll[3] = 0x00, .pll[4] = 0x00,\n\t.pll[5] = 0x00, .pll[6] = 0x00, .pll[7] = 0x00, .pll[8] = 0x20, .pll[9] = 0xFF,\n\t.pll[10] = 0xFF, .pll[11] = 0x55, .pll[12] = 0x15, .pll[13] = 0x55, .pll[14] = 0x55,\n\t.pll[15] = 0x08, .pll[16] = 0x08, .pll[17] = 0x8F, .pll[18] = 0x84, .pll[19] = 0x23,\n};\n\nstatic const struct intel_c10pll_state mtl_c10_hdmi_593407 = {\n\t.clock = 593407,\n\t.tx = 0x10,\n\t.cmn = 0x1,\n\t.pll[0] = 0xF4, .pll[1] = 0x00, .pll[2] = 0x7A, .pll[3] = 0x00, .pll[4] = 0x00,\n\t.pll[5] = 0x00, .pll[6] = 0x00, .pll[7] = 0x00, .pll[8] = 0x20, .pll[9] = 0xFF,\n\t.pll[10] = 0xFF, .pll[11] = 0x3B, .pll[12] = 0x44, .pll[13] = 0xBA, .pll[14] = 0xBB,\n\t.pll[15] = 0x08, .pll[16] = 0x08, .pll[17] = 0x8F, .pll[18] = 0x84, .pll[19] = 0x23,\n};\n\nstatic const struct intel_c10pll_state * const mtl_c10_hdmi_tables[] = {\n\t&mtl_c10_hdmi_25_2,  \n\t&mtl_c10_hdmi_27_0,  \n\t&mtl_c10_hdmi_27027,\n\t&mtl_c10_hdmi_28320,\n\t&mtl_c10_hdmi_30240,\n\t&mtl_c10_hdmi_31500,\n\t&mtl_c10_hdmi_36000,\n\t&mtl_c10_hdmi_40000,\n\t&mtl_c10_hdmi_49500,\n\t&mtl_c10_hdmi_50000,\n\t&mtl_c10_hdmi_57284,\n\t&mtl_c10_hdmi_58000,\n\t&mtl_c10_hdmi_65000,\n\t&mtl_c10_hdmi_71000,\n\t&mtl_c10_hdmi_74176,\n\t&mtl_c10_hdmi_74_25,  \n\t&mtl_c10_hdmi_75000,\n\t&mtl_c10_hdmi_78750,\n\t&mtl_c10_hdmi_85500,\n\t&mtl_c10_hdmi_88750,\n\t&mtl_c10_hdmi_106500,\n\t&mtl_c10_hdmi_108000,\n\t&mtl_c10_hdmi_115500,\n\t&mtl_c10_hdmi_119000,\n\t&mtl_c10_hdmi_135000,\n\t&mtl_c10_hdmi_138500,\n\t&mtl_c10_hdmi_147160,\n\t&mtl_c10_hdmi_148352,\n\t&mtl_c10_hdmi_148_5,  \n\t&mtl_c10_hdmi_154000,\n\t&mtl_c10_hdmi_162000,\n\t&mtl_c10_hdmi_167000,\n\t&mtl_c10_hdmi_197802,\n\t&mtl_c10_hdmi_198000,\n\t&mtl_c10_hdmi_209800,\n\t&mtl_c10_hdmi_241500,\n\t&mtl_c10_hdmi_262750,\n\t&mtl_c10_hdmi_268500,\n\t&mtl_c10_hdmi_296703,\n\t&mtl_c10_hdmi_297000,\n\t&mtl_c10_hdmi_319750,\n\t&mtl_c10_hdmi_497750,\n\t&mtl_c10_hdmi_592000,\n\t&mtl_c10_hdmi_593407,\n\t&mtl_c10_hdmi_594,  \n\tNULL,\n};\n\nstatic const struct intel_c20pll_state mtl_c20_hdmi_25_175 = {\n\t.link_bit_rate = 25175,\n\t.clock = 25175,\n\t.tx = {  0xbe88,  \n\t\t  0x9800,  \n\t\t  0x0000,  \n\t\t},\n\t.cmn = { 0x0500,  \n\t\t  0x0005,  \n\t\t  0x0000,  \n\t\t  0x0000,  \n\t\t},\n\t.mpllb = { 0xa0d2,\t \n\t\t   0x7d80,\t \n\t\t   0x0906,\t \n\t\t   0xbe40,\t \n\t\t   0x0000,\t \n\t\t   0x0000,\t \n\t\t   0x0200,\t \n\t\t   0x0001,\t \n\t\t   0x0000,\t \n\t\t   0x0000,\t \n\t\t   0x0001,\t \n\t\t},\n};\n\nstatic const struct intel_c20pll_state mtl_c20_hdmi_27_0 = {\n\t.link_bit_rate = 27000,\n\t.clock = 27000,\n\t.tx = {  0xbe88,  \n\t\t  0x9800,  \n\t\t  0x0000,  \n\t\t},\n\t.cmn = { 0x0500,  \n\t\t  0x0005,  \n\t\t  0x0000,  \n\t\t  0x0000,  \n\t\t},\n\t.mpllb = { 0xa0e0,\t \n\t\t   0x7d80,\t \n\t\t   0x0906,\t \n\t\t   0xbe40,\t \n\t\t   0x0000,\t \n\t\t   0x0000,\t \n\t\t   0x2200,\t \n\t\t   0x0001,\t \n\t\t   0x8000,\t \n\t\t   0x0000,\t \n\t\t   0x0001,\t \n\t\t},\n};\n\nstatic const struct intel_c20pll_state mtl_c20_hdmi_74_25 = {\n\t.link_bit_rate = 74250,\n\t.clock = 74250,\n\t.tx = {  0xbe88,  \n\t\t  0x9800,  \n\t\t  0x0000,  \n\t\t},\n\t.cmn = { 0x0500,  \n\t\t  0x0005,  \n\t\t  0x0000,  \n\t\t  0x0000,  \n\t\t},\n\t.mpllb = { 0x609a,\t \n\t\t   0x7d40,\t \n\t\t   0xca06,\t \n\t\t   0xbe40,\t \n\t\t   0x0000,\t \n\t\t   0x0000,\t \n\t\t   0x2200,\t \n\t\t   0x0001,\t \n\t\t   0x5800,\t \n\t\t   0x0000,\t \n\t\t   0x0001,\t \n\t\t},\n};\n\nstatic const struct intel_c20pll_state mtl_c20_hdmi_148_5 = {\n\t.link_bit_rate = 148500,\n\t.clock = 148500,\n\t.tx = {  0xbe88,  \n\t\t  0x9800,  \n\t\t  0x0000,  \n\t\t},\n\t.cmn = { 0x0500,  \n\t\t  0x0005,  \n\t\t  0x0000,  \n\t\t  0x0000,  \n\t\t},\n\t.mpllb = { 0x409a,\t \n\t\t   0x7d20,\t \n\t\t   0xca06,\t \n\t\t   0xbe40,\t \n\t\t   0x0000,\t \n\t\t   0x0000,\t \n\t\t   0x2200,\t \n\t\t   0x0001,\t \n\t\t   0x5800,\t \n\t\t   0x0000,\t \n\t\t   0x0001,\t \n\t\t},\n};\n\nstatic const struct intel_c20pll_state mtl_c20_hdmi_594 = {\n\t.link_bit_rate = 594000,\n\t.clock = 594000,\n\t.tx = {  0xbe88,  \n\t\t  0x9800,  \n\t\t  0x0000,  \n\t\t},\n\t.cmn = { 0x0500,  \n\t\t  0x0005,  \n\t\t  0x0000,  \n\t\t  0x0000,  \n\t\t},\n\t.mpllb = { 0x009a,\t \n\t\t   0x7d08,\t \n\t\t   0xca06,\t \n\t\t   0xbe40,\t \n\t\t   0x0000,\t \n\t\t   0x0000,\t \n\t\t   0x2200,\t \n\t\t   0x0001,\t \n\t\t   0x5800,\t \n\t\t   0x0000,\t \n\t\t   0x0001,\t \n\t\t},\n};\n\nstatic const struct intel_c20pll_state mtl_c20_hdmi_300 = {\n\t.link_bit_rate = 3000000,\n\t.clock = 166670,\n\t.tx = {  0xbe98,  \n\t\t  0x9800,  \n\t\t  0x0000,  \n\t\t},\n\t.cmn = { 0x0500,  \n\t\t  0x0005,  \n\t\t  0x0000,  \n\t\t  0x0000,  \n\t\t},\n\t.mpllb = { 0x209c,\t \n\t\t   0x7d10,\t \n\t\t   0xca06,\t \n\t\t   0xbe40,\t \n\t\t   0x0000,\t \n\t\t   0x0000,\t \n\t\t   0x2200,\t \n\t\t   0x0001,\t \n\t\t   0x2000,\t \n\t\t   0x0000,\t \n\t\t   0x0004,\t \n\t\t},\n};\n\nstatic const struct intel_c20pll_state mtl_c20_hdmi_600 = {\n\t.link_bit_rate = 6000000,\n\t.clock = 333330,\n\t.tx = {  0xbe98,  \n\t\t  0x9800,  \n\t\t  0x0000,  \n\t\t},\n\t.cmn = { 0x0500,  \n\t\t  0x0005,  \n\t\t  0x0000,  \n\t\t  0x0000,  \n\t\t},\n\t.mpllb = { 0x009c,\t \n\t\t   0x7d08,\t \n\t\t   0xca06,\t \n\t\t   0xbe40,\t \n\t\t   0x0000,\t \n\t\t   0x0000,\t \n\t\t   0x2200,\t \n\t\t   0x0001,\t \n\t\t   0x2000,\t \n\t\t   0x0000,\t \n\t\t   0x0004,\t \n\t\t},\n};\n\nstatic const struct intel_c20pll_state mtl_c20_hdmi_800 = {\n\t.link_bit_rate = 8000000,\n\t.clock = 444440,\n\t.tx = {  0xbe98,  \n\t\t  0x9800,  \n\t\t  0x0000,  \n\t\t},\n\t.cmn = { 0x0500,  \n\t\t  0x0005,  \n\t\t  0x0000,  \n\t\t  0x0000,  \n\t\t},\n\t.mpllb = { 0x00d0,\t \n\t\t   0x7d08,\t \n\t\t   0x4a06,\t \n\t\t   0xbe40,\t \n\t\t   0x0000,\t \n\t\t   0x0000,\t \n\t\t   0x2200,\t \n\t\t   0x0003,\t \n\t\t   0x2aaa,\t \n\t\t   0x0002,\t \n\t\t   0x0004,\t \n\t\t},\n};\n\nstatic const struct intel_c20pll_state mtl_c20_hdmi_1000 = {\n\t.link_bit_rate = 10000000,\n\t.clock = 555560,\n\t.tx = {  0xbe98,  \n\t\t  0x9800,  \n\t\t  0x0000,  \n\t\t},\n\t.cmn = { 0x0500,  \n\t\t  0x0005,  \n\t\t  0x0000,  \n\t\t  0x0000,  \n\t\t},\n\t.mpllb = { 0x1104,\t \n\t\t   0x7d08,\t \n\t\t   0x0a06,\t \n\t\t   0xbe40,\t \n\t\t   0x0000,\t \n\t\t   0x0000,\t \n\t\t   0x2200,\t \n\t\t   0x0003,\t \n\t\t   0x3555,\t \n\t\t   0x0001,\t \n\t\t   0x0004,\t \n\t\t},\n};\n\nstatic const struct intel_c20pll_state mtl_c20_hdmi_1200 = {\n\t.link_bit_rate = 12000000,\n\t.clock = 666670,\n\t.tx = {  0xbe98,  \n\t\t  0x9800,  \n\t\t  0x0000,  \n\t\t},\n\t.cmn = { 0x0500,  \n\t\t  0x0005,  \n\t\t  0x0000,  \n\t\t  0x0000,  \n\t\t},\n\t.mpllb = { 0x0138,\t \n\t\t   0x7d08,\t \n\t\t   0x5486,\t \n\t\t   0xfe40,\t \n\t\t   0x0000,\t \n\t\t   0x0000,\t \n\t\t   0x2200,\t \n\t\t   0x0001,\t \n\t\t   0x4000,\t \n\t\t   0x0000,\t \n\t\t   0x0004,\t \n\t\t},\n};\n\nstatic const struct intel_c20pll_state * const mtl_c20_hdmi_tables[] = {\n\t&mtl_c20_hdmi_25_175,\n\t&mtl_c20_hdmi_27_0,\n\t&mtl_c20_hdmi_74_25,\n\t&mtl_c20_hdmi_148_5,\n\t&mtl_c20_hdmi_594,\n\t&mtl_c20_hdmi_300,\n\t&mtl_c20_hdmi_600,\n\t&mtl_c20_hdmi_800,\n\t&mtl_c20_hdmi_1000,\n\t&mtl_c20_hdmi_1200,\n\tNULL,\n};\n\nstatic int intel_c10_phy_check_hdmi_link_rate(int clock)\n{\n\tconst struct intel_c10pll_state * const *tables = mtl_c10_hdmi_tables;\n\tint i;\n\n\tfor (i = 0; tables[i]; i++) {\n\t\tif (clock == tables[i]->clock)\n\t\t\treturn MODE_OK;\n\t}\n\n\treturn MODE_CLOCK_RANGE;\n}\n\nstatic const struct intel_c10pll_state * const *\nintel_c10pll_tables_get(struct intel_crtc_state *crtc_state,\n\t\t\tstruct intel_encoder *encoder)\n{\n\tif (intel_crtc_has_dp_encoder(crtc_state)) {\n\t\tif (intel_crtc_has_type(crtc_state, INTEL_OUTPUT_EDP))\n\t\t\treturn mtl_c10_edp_tables;\n\t\telse\n\t\t\treturn mtl_c10_dp_tables;\n\t} else if (intel_crtc_has_type(crtc_state, INTEL_OUTPUT_HDMI)) {\n\t\treturn mtl_c10_hdmi_tables;\n\t}\n\n\tMISSING_CASE(encoder->type);\n\treturn NULL;\n}\n\nstatic void intel_c10pll_update_pll(struct intel_crtc_state *crtc_state,\n\t\t\t\t    struct intel_encoder *encoder)\n{\n\tstruct drm_i915_private *i915 = to_i915(encoder->base.dev);\n\tstruct intel_cx0pll_state *pll_state = &crtc_state->cx0pll_state;\n\tint i;\n\n\tif (intel_crtc_has_dp_encoder(crtc_state)) {\n\t\tif (intel_panel_use_ssc(i915)) {\n\t\t\tstruct intel_dp *intel_dp = enc_to_intel_dp(encoder);\n\n\t\t\tpll_state->ssc_enabled =\n\t\t\t\t(intel_dp->dpcd[DP_MAX_DOWNSPREAD] & DP_MAX_DOWNSPREAD_0_5);\n\t\t}\n\t}\n\n\tif (pll_state->ssc_enabled)\n\t\treturn;\n\n\tdrm_WARN_ON(&i915->drm, ARRAY_SIZE(pll_state->c10.pll) < 9);\n\tfor (i = 4; i < 9; i++)\n\t\tpll_state->c10.pll[i] = 0;\n}\n\nstatic int intel_c10pll_calc_state(struct intel_crtc_state *crtc_state,\n\t\t\t\t   struct intel_encoder *encoder)\n{\n\tconst struct intel_c10pll_state * const *tables;\n\tint i;\n\n\ttables = intel_c10pll_tables_get(crtc_state, encoder);\n\tif (!tables)\n\t\treturn -EINVAL;\n\n\tfor (i = 0; tables[i]; i++) {\n\t\tif (crtc_state->port_clock == tables[i]->clock) {\n\t\t\tcrtc_state->cx0pll_state.c10 = *tables[i];\n\t\t\tintel_c10pll_update_pll(crtc_state, encoder);\n\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\treturn -EINVAL;\n}\n\nvoid intel_c10pll_readout_hw_state(struct intel_encoder *encoder,\n\t\t\t\t   struct intel_c10pll_state *pll_state)\n{\n\tstruct drm_i915_private *i915 = to_i915(encoder->base.dev);\n\tu8 lane = INTEL_CX0_LANE0;\n\tintel_wakeref_t wakeref;\n\tint i;\n\n\twakeref = intel_cx0_phy_transaction_begin(encoder);\n\n\t \n\tintel_cx0_rmw(i915, encoder->port, lane, PHY_C10_VDR_CONTROL(1),\n\t\t      0, C10_VDR_CTRL_MSGBUS_ACCESS,\n\t\t      MB_WRITE_COMMITTED);\n\n\tfor (i = 0; i < ARRAY_SIZE(pll_state->pll); i++)\n\t\tpll_state->pll[i] = intel_cx0_read(i915, encoder->port, lane,\n\t\t\t\t\t\t   PHY_C10_VDR_PLL(i));\n\n\tpll_state->cmn = intel_cx0_read(i915, encoder->port, lane, PHY_C10_VDR_CMN(0));\n\tpll_state->tx = intel_cx0_read(i915, encoder->port, lane, PHY_C10_VDR_TX(0));\n\n\tintel_cx0_phy_transaction_end(encoder, wakeref);\n}\n\nstatic void intel_c10_pll_program(struct drm_i915_private *i915,\n\t\t\t\t  const struct intel_crtc_state *crtc_state,\n\t\t\t\t  struct intel_encoder *encoder)\n{\n\tconst struct intel_c10pll_state *pll_state = &crtc_state->cx0pll_state.c10;\n\tint i;\n\n\tintel_cx0_rmw(i915, encoder->port, INTEL_CX0_BOTH_LANES, PHY_C10_VDR_CONTROL(1),\n\t\t      0, C10_VDR_CTRL_MSGBUS_ACCESS,\n\t\t      MB_WRITE_COMMITTED);\n\n\t \n\tintel_cx0_rmw(i915, encoder->port, INTEL_CX0_BOTH_LANES, PHY_C10_VDR_CUSTOM_WIDTH,\n\t\t      C10_VDR_CUSTOM_WIDTH_MASK, C10_VDR_CUSTOM_WIDTH_8_10,\n\t\t      MB_WRITE_COMMITTED);\n\tintel_cx0_rmw(i915, encoder->port, INTEL_CX0_BOTH_LANES, PHY_C10_VDR_CONTROL(1),\n\t\t      0, C10_VDR_CTRL_UPDATE_CFG,\n\t\t      MB_WRITE_COMMITTED);\n\n\t \n\tfor (i = 0; i < ARRAY_SIZE(pll_state->pll); i++)\n\t\tintel_cx0_write(i915, encoder->port, INTEL_CX0_LANE0, PHY_C10_VDR_PLL(i),\n\t\t\t\tpll_state->pll[i],\n\t\t\t\t(i % 4) ? MB_WRITE_UNCOMMITTED : MB_WRITE_COMMITTED);\n\n\tintel_cx0_write(i915, encoder->port, INTEL_CX0_LANE0, PHY_C10_VDR_CMN(0), pll_state->cmn, MB_WRITE_COMMITTED);\n\tintel_cx0_write(i915, encoder->port, INTEL_CX0_LANE0, PHY_C10_VDR_TX(0), pll_state->tx, MB_WRITE_COMMITTED);\n\n\tintel_cx0_rmw(i915, encoder->port, INTEL_CX0_LANE0, PHY_C10_VDR_CONTROL(1),\n\t\t      0, C10_VDR_CTRL_MASTER_LANE | C10_VDR_CTRL_UPDATE_CFG,\n\t\t      MB_WRITE_COMMITTED);\n}\n\nvoid intel_c10pll_dump_hw_state(struct drm_i915_private *i915,\n\t\t\t\tconst struct intel_c10pll_state *hw_state)\n{\n\tbool fracen;\n\tint i;\n\tunsigned int frac_quot = 0, frac_rem = 0, frac_den = 1;\n\tunsigned int multiplier, tx_clk_div;\n\n\tfracen = hw_state->pll[0] & C10_PLL0_FRACEN;\n\tdrm_dbg_kms(&i915->drm, \"c10pll_hw_state: fracen: %s, \",\n\t\t    str_yes_no(fracen));\n\n\tif (fracen) {\n\t\tfrac_quot = hw_state->pll[12] << 8 | hw_state->pll[11];\n\t\tfrac_rem =  hw_state->pll[14] << 8 | hw_state->pll[13];\n\t\tfrac_den =  hw_state->pll[10] << 8 | hw_state->pll[9];\n\t\tdrm_dbg_kms(&i915->drm, \"quot: %u, rem: %u, den: %u,\\n\",\n\t\t\t    frac_quot, frac_rem, frac_den);\n\t}\n\n\tmultiplier = (REG_FIELD_GET8(C10_PLL3_MULTIPLIERH_MASK, hw_state->pll[3]) << 8 |\n\t\t      hw_state->pll[2]) / 2 + 16;\n\ttx_clk_div = REG_FIELD_GET8(C10_PLL15_TXCLKDIV_MASK, hw_state->pll[15]);\n\tdrm_dbg_kms(&i915->drm,\n\t\t    \"multiplier: %u, tx_clk_div: %u.\\n\", multiplier, tx_clk_div);\n\n\tdrm_dbg_kms(&i915->drm, \"c10pll_rawhw_state:\");\n\tdrm_dbg_kms(&i915->drm, \"tx: 0x%x, cmn: 0x%x\\n\", hw_state->tx, hw_state->cmn);\n\n\tBUILD_BUG_ON(ARRAY_SIZE(hw_state->pll) % 4);\n\tfor (i = 0; i < ARRAY_SIZE(hw_state->pll); i = i + 4)\n\t\tdrm_dbg_kms(&i915->drm, \"pll[%d] = 0x%x, pll[%d] = 0x%x, pll[%d] = 0x%x, pll[%d] = 0x%x\\n\",\n\t\t\t    i, hw_state->pll[i], i + 1, hw_state->pll[i + 1],\n\t\t\t    i + 2, hw_state->pll[i + 2], i + 3, hw_state->pll[i + 3]);\n}\n\nstatic int intel_c20_compute_hdmi_tmds_pll(u64 pixel_clock, struct intel_c20pll_state *pll_state)\n{\n\tu64 datarate;\n\tu64 mpll_tx_clk_div;\n\tu64 vco_freq_shift;\n\tu64 vco_freq;\n\tu64 multiplier;\n\tu64 mpll_multiplier;\n\tu64 mpll_fracn_quot;\n\tu64 mpll_fracn_rem;\n\tu8  mpllb_ana_freq_vco;\n\tu8  mpll_div_multiplier;\n\n\tif (pixel_clock < 25175 || pixel_clock > 600000)\n\t\treturn -EINVAL;\n\n\tdatarate = ((u64)pixel_clock * 1000) * 10;\n\tmpll_tx_clk_div = ilog2(div64_u64((u64)CLOCK_9999MHZ, (u64)datarate));\n\tvco_freq_shift = ilog2(div64_u64((u64)CLOCK_4999MHZ * (u64)256, (u64)datarate));\n\tvco_freq = (datarate << vco_freq_shift) >> 8;\n\tmultiplier = div64_u64((vco_freq << 28), (REFCLK_38_4_MHZ >> 4));\n\tmpll_multiplier = 2 * (multiplier >> 32);\n\n\tmpll_fracn_quot = (multiplier >> 16) & 0xFFFF;\n\tmpll_fracn_rem  = multiplier & 0xFFFF;\n\n\tmpll_div_multiplier = min_t(u8, div64_u64((vco_freq * 16 + (datarate >> 1)),\n\t\t\t\t\t\t  datarate), 255);\n\n\tif (vco_freq <= DATARATE_3000000000)\n\t\tmpllb_ana_freq_vco = MPLLB_ANA_FREQ_VCO_3;\n\telse if (vco_freq <= DATARATE_3500000000)\n\t\tmpllb_ana_freq_vco = MPLLB_ANA_FREQ_VCO_2;\n\telse if (vco_freq <= DATARATE_4000000000)\n\t\tmpllb_ana_freq_vco = MPLLB_ANA_FREQ_VCO_1;\n\telse\n\t\tmpllb_ana_freq_vco = MPLLB_ANA_FREQ_VCO_0;\n\n\tpll_state->link_bit_rate\t= pixel_clock;\n\tpll_state->clock\t= pixel_clock;\n\tpll_state->tx[0]\t= 0xbe88;\n\tpll_state->tx[1]\t= 0x9800;\n\tpll_state->tx[2]\t= 0x0000;\n\tpll_state->cmn[0]\t= 0x0500;\n\tpll_state->cmn[1]\t= 0x0005;\n\tpll_state->cmn[2]\t= 0x0000;\n\tpll_state->cmn[3]\t= 0x0000;\n\tpll_state->mpllb[0]\t= (MPLL_TX_CLK_DIV(mpll_tx_clk_div) |\n\t\t\t\t   MPLL_MULTIPLIER(mpll_multiplier));\n\tpll_state->mpllb[1]\t= (CAL_DAC_CODE(CAL_DAC_CODE_31) |\n\t\t\t\t   WORD_CLK_DIV |\n\t\t\t\t   MPLL_DIV_MULTIPLIER(mpll_div_multiplier));\n\tpll_state->mpllb[2]\t= (MPLLB_ANA_FREQ_VCO(mpllb_ana_freq_vco) |\n\t\t\t\t   CP_PROP(CP_PROP_20) |\n\t\t\t\t   CP_INT(CP_INT_6));\n\tpll_state->mpllb[3]\t= (V2I(V2I_2) |\n\t\t\t\t   CP_PROP_GS(CP_PROP_GS_30) |\n\t\t\t\t   CP_INT_GS(CP_INT_GS_28));\n\tpll_state->mpllb[4]\t= 0x0000;\n\tpll_state->mpllb[5]\t= 0x0000;\n\tpll_state->mpllb[6]\t= (C20_MPLLB_FRACEN | SSC_UP_SPREAD);\n\tpll_state->mpllb[7]\t= MPLL_FRACN_DEN;\n\tpll_state->mpllb[8]\t= mpll_fracn_quot;\n\tpll_state->mpllb[9]\t= mpll_fracn_rem;\n\tpll_state->mpllb[10]\t= HDMI_DIV(HDMI_DIV_1);\n\n\treturn 0;\n}\n\nstatic int intel_c20_phy_check_hdmi_link_rate(int clock)\n{\n\tconst struct intel_c20pll_state * const *tables = mtl_c20_hdmi_tables;\n\tint i;\n\n\tfor (i = 0; tables[i]; i++) {\n\t\tif (clock == tables[i]->link_bit_rate)\n\t\t\treturn MODE_OK;\n\t}\n\n\tif (clock >= 25175 && clock <= 594000)\n\t\treturn MODE_OK;\n\n\treturn MODE_CLOCK_RANGE;\n}\n\nint intel_cx0_phy_check_hdmi_link_rate(struct intel_hdmi *hdmi, int clock)\n{\n\tstruct intel_digital_port *dig_port = hdmi_to_dig_port(hdmi);\n\tstruct drm_i915_private *i915 = intel_hdmi_to_i915(hdmi);\n\tenum phy phy = intel_port_to_phy(i915, dig_port->base.port);\n\n\tif (intel_is_c10phy(i915, phy))\n\t\treturn intel_c10_phy_check_hdmi_link_rate(clock);\n\treturn intel_c20_phy_check_hdmi_link_rate(clock);\n}\n\nstatic const struct intel_c20pll_state * const *\nintel_c20_pll_tables_get(struct intel_crtc_state *crtc_state,\n\t\t\t struct intel_encoder *encoder)\n{\n\tif (intel_crtc_has_dp_encoder(crtc_state))\n\t\treturn mtl_c20_dp_tables;\n\telse if (intel_crtc_has_type(crtc_state, INTEL_OUTPUT_HDMI))\n\t\treturn mtl_c20_hdmi_tables;\n\n\tMISSING_CASE(encoder->type);\n\treturn NULL;\n}\n\nstatic int intel_c20pll_calc_state(struct intel_crtc_state *crtc_state,\n\t\t\t\t   struct intel_encoder *encoder)\n{\n\tconst struct intel_c20pll_state * const *tables;\n\tint i;\n\n\t \n\tif (intel_crtc_has_type(crtc_state, INTEL_OUTPUT_HDMI)) {\n\t\tif (intel_c20_compute_hdmi_tmds_pll(crtc_state->port_clock,\n\t\t\t\t\t\t    &crtc_state->cx0pll_state.c20) == 0)\n\t\t\treturn 0;\n\t}\n\n\ttables = intel_c20_pll_tables_get(crtc_state, encoder);\n\tif (!tables)\n\t\treturn -EINVAL;\n\n\tfor (i = 0; tables[i]; i++) {\n\t\tif (crtc_state->port_clock == tables[i]->link_bit_rate) {\n\t\t\tcrtc_state->cx0pll_state.c20 = *tables[i];\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\treturn -EINVAL;\n}\n\nint intel_cx0pll_calc_state(struct intel_crtc_state *crtc_state,\n\t\t\t    struct intel_encoder *encoder)\n{\n\tstruct drm_i915_private *i915 = to_i915(encoder->base.dev);\n\tenum phy phy = intel_port_to_phy(i915, encoder->port);\n\n\tif (intel_is_c10phy(i915, phy))\n\t\treturn intel_c10pll_calc_state(crtc_state, encoder);\n\treturn intel_c20pll_calc_state(crtc_state, encoder);\n}\n\nstatic bool intel_c20_use_mplla(u32 clock)\n{\n\t \n\tif (clock == 312500 || clock == 625000)\n\t\treturn true;\n\n\treturn false;\n}\n\nvoid intel_c20pll_readout_hw_state(struct intel_encoder *encoder,\n\t\t\t\t   struct intel_c20pll_state *pll_state)\n{\n\tstruct drm_i915_private *i915 = to_i915(encoder->base.dev);\n\tbool cntx;\n\tintel_wakeref_t wakeref;\n\tint i;\n\n\twakeref = intel_cx0_phy_transaction_begin(encoder);\n\n\t \n\tcntx = intel_cx0_read(i915, encoder->port, INTEL_CX0_LANE0, PHY_C20_VDR_CUSTOM_SERDES_RATE) & PHY_C20_CONTEXT_TOGGLE;\n\n\t \n\tfor (i = 0; i < ARRAY_SIZE(pll_state->tx); i++) {\n\t\tif (cntx)\n\t\t\tpll_state->tx[i] = intel_c20_sram_read(i915, encoder->port, INTEL_CX0_LANE0,\n\t\t\t\t\t\t\t       PHY_C20_B_TX_CNTX_CFG(i));\n\t\telse\n\t\t\tpll_state->tx[i] = intel_c20_sram_read(i915, encoder->port, INTEL_CX0_LANE0,\n\t\t\t\t\t\t\t       PHY_C20_A_TX_CNTX_CFG(i));\n\t}\n\n\t \n\tfor (i = 0; i < ARRAY_SIZE(pll_state->cmn); i++) {\n\t\tif (cntx)\n\t\t\tpll_state->cmn[i] = intel_c20_sram_read(i915, encoder->port, INTEL_CX0_LANE0,\n\t\t\t\t\t\t\t\tPHY_C20_B_CMN_CNTX_CFG(i));\n\t\telse\n\t\t\tpll_state->cmn[i] = intel_c20_sram_read(i915, encoder->port, INTEL_CX0_LANE0,\n\t\t\t\t\t\t\t\tPHY_C20_A_CMN_CNTX_CFG(i));\n\t}\n\n\tif (pll_state->tx[0] & C20_PHY_USE_MPLLB) {\n\t\t \n\t\tfor (i = 0; i < ARRAY_SIZE(pll_state->mpllb); i++) {\n\t\t\tif (cntx)\n\t\t\t\tpll_state->mpllb[i] = intel_c20_sram_read(i915, encoder->port, INTEL_CX0_LANE0,\n\t\t\t\t\t\t\t\t\t  PHY_C20_B_MPLLB_CNTX_CFG(i));\n\t\t\telse\n\t\t\t\tpll_state->mpllb[i] = intel_c20_sram_read(i915, encoder->port, INTEL_CX0_LANE0,\n\t\t\t\t\t\t\t\t\t  PHY_C20_A_MPLLB_CNTX_CFG(i));\n\t\t}\n\t} else {\n\t\t \n\t\tfor (i = 0; i < ARRAY_SIZE(pll_state->mplla); i++) {\n\t\t\tif (cntx)\n\t\t\t\tpll_state->mplla[i] = intel_c20_sram_read(i915, encoder->port, INTEL_CX0_LANE0,\n\t\t\t\t\t\t\t\t\t  PHY_C20_B_MPLLA_CNTX_CFG(i));\n\t\t\telse\n\t\t\t\tpll_state->mplla[i] = intel_c20_sram_read(i915, encoder->port, INTEL_CX0_LANE0,\n\t\t\t\t\t\t\t\t\t  PHY_C20_A_MPLLA_CNTX_CFG(i));\n\t\t}\n\t}\n\n\tintel_cx0_phy_transaction_end(encoder, wakeref);\n}\n\nvoid intel_c20pll_dump_hw_state(struct drm_i915_private *i915,\n\t\t\t\tconst struct intel_c20pll_state *hw_state)\n{\n\tint i;\n\n\tdrm_dbg_kms(&i915->drm, \"c20pll_hw_state:\\n\");\n\tdrm_dbg_kms(&i915->drm, \"tx[0] = 0x%.4x, tx[1] = 0x%.4x, tx[2] = 0x%.4x\\n\",\n\t\t    hw_state->tx[0], hw_state->tx[1], hw_state->tx[2]);\n\tdrm_dbg_kms(&i915->drm, \"cmn[0] = 0x%.4x, cmn[1] = 0x%.4x, cmn[2] = 0x%.4x, cmn[3] = 0x%.4x\\n\",\n\t\t    hw_state->cmn[0], hw_state->cmn[1], hw_state->cmn[2], hw_state->cmn[3]);\n\n\tif (intel_c20_use_mplla(hw_state->clock)) {\n\t\tfor (i = 0; i < ARRAY_SIZE(hw_state->mplla); i++)\n\t\t\tdrm_dbg_kms(&i915->drm, \"mplla[%d] = 0x%.4x\\n\", i, hw_state->mplla[i]);\n\t} else {\n\t\tfor (i = 0; i < ARRAY_SIZE(hw_state->mpllb); i++)\n\t\t\tdrm_dbg_kms(&i915->drm, \"mpllb[%d] = 0x%.4x\\n\", i, hw_state->mpllb[i]);\n\t}\n}\n\nstatic u8 intel_c20_get_dp_rate(u32 clock)\n{\n\tswitch (clock) {\n\tcase 162000:  \n\t\treturn 0;\n\tcase 270000:  \n\t\treturn 1;\n\tcase 540000:  \n\t\treturn 2;\n\tcase 810000:  \n\t\treturn 3;\n\tcase 216000:  \n\t\treturn 4;\n\tcase 243000:  \n\t\treturn 5;\n\tcase 324000:  \n\t\treturn 6;\n\tcase 432000:  \n\t\treturn 7;\n\tcase 312500:  \n\t\treturn 8;\n\tcase 421875:  \n\t\treturn 9;\n\tcase 625000:  \n\t\treturn 10;\n\tcase 648000:  \n\t\treturn 11;\n\tcase 675000:  \n\t\treturn 12;\n\tdefault:\n\t\tMISSING_CASE(clock);\n\t\treturn 0;\n\t}\n}\n\nstatic u8 intel_c20_get_hdmi_rate(u32 clock)\n{\n\tif (clock >= 25175 && clock <= 600000)\n\t\treturn 0;\n\n\tswitch (clock) {\n\tcase 166670:  \n\tcase 333330:  \n\tcase 666670:  \n\t\treturn 1;\n\tcase 444440:  \n\t\treturn 2;\n\tcase 555560:  \n\t\treturn 3;\n\tdefault:\n\t\tMISSING_CASE(clock);\n\t\treturn 0;\n\t}\n}\n\nstatic bool is_dp2(u32 clock)\n{\n\t \n\tif (clock == 312500 || clock == 421875 || clock  == 625000)\n\t\treturn true;\n\n\treturn false;\n}\n\nstatic bool is_hdmi_frl(u32 clock)\n{\n\tswitch (clock) {\n\tcase 166670:  \n\tcase 333330:  \n\tcase 444440:  \n\tcase 555560:  \n\tcase 666670:  \n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nstatic bool intel_c20_protocol_switch_valid(struct intel_encoder *encoder)\n{\n\tstruct intel_digital_port *intel_dig_port = enc_to_dig_port(encoder);\n\n\t \n\t \n\treturn intel_tc_port_in_legacy_mode(intel_dig_port);\n}\n\nstatic int intel_get_c20_custom_width(u32 clock, bool dp)\n{\n\tif (dp && is_dp2(clock))\n\t\treturn 2;\n\telse if (is_hdmi_frl(clock))\n\t\treturn 1;\n\telse\n\t\treturn 0;\n}\n\nstatic void intel_c20_pll_program(struct drm_i915_private *i915,\n\t\t\t\t  const struct intel_crtc_state *crtc_state,\n\t\t\t\t  struct intel_encoder *encoder)\n{\n\tconst struct intel_c20pll_state *pll_state = &crtc_state->cx0pll_state.c20;\n\tbool dp = false;\n\tint lane = crtc_state->lane_count > 2 ? INTEL_CX0_BOTH_LANES : INTEL_CX0_LANE0;\n\tbool cntx;\n\tint i;\n\n\tif (intel_crtc_has_dp_encoder(crtc_state))\n\t\tdp = true;\n\n\t \n\tcntx = intel_cx0_read(i915, encoder->port, INTEL_CX0_LANE0, PHY_C20_VDR_CUSTOM_SERDES_RATE) & BIT(0);\n\n\t \n\tif (intel_c20_protocol_switch_valid(encoder)) {\n\t\tfor (i = 0; i < 4; i++)\n\t\t\tintel_c20_sram_write(i915, encoder->port, INTEL_CX0_LANE0, RAWLANEAONX_DIG_TX_MPLLB_CAL_DONE_BANK(i), 0);\n\t\tusleep_range(4000, 4100);\n\t}\n\n\t \n\t \n\tfor (i = 0; i < ARRAY_SIZE(pll_state->tx); i++) {\n\t\tif (cntx)\n\t\t\tintel_c20_sram_write(i915, encoder->port, INTEL_CX0_LANE0, PHY_C20_A_TX_CNTX_CFG(i), pll_state->tx[i]);\n\t\telse\n\t\t\tintel_c20_sram_write(i915, encoder->port, INTEL_CX0_LANE0, PHY_C20_B_TX_CNTX_CFG(i), pll_state->tx[i]);\n\t}\n\n\t \n\tfor (i = 0; i < ARRAY_SIZE(pll_state->cmn); i++) {\n\t\tif (cntx)\n\t\t\tintel_c20_sram_write(i915, encoder->port, INTEL_CX0_LANE0, PHY_C20_A_CMN_CNTX_CFG(i), pll_state->cmn[i]);\n\t\telse\n\t\t\tintel_c20_sram_write(i915, encoder->port, INTEL_CX0_LANE0, PHY_C20_B_CMN_CNTX_CFG(i), pll_state->cmn[i]);\n\t}\n\n\t \n\tif (intel_c20_use_mplla(pll_state->clock)) {\n\t\tfor (i = 0; i < ARRAY_SIZE(pll_state->mplla); i++) {\n\t\t\tif (cntx)\n\t\t\t\tintel_c20_sram_write(i915, encoder->port, INTEL_CX0_LANE0,\n\t\t\t\t\t\t     PHY_C20_A_MPLLA_CNTX_CFG(i),\n\t\t\t\t\t\t     pll_state->mplla[i]);\n\t\t\telse\n\t\t\t\tintel_c20_sram_write(i915, encoder->port, INTEL_CX0_LANE0,\n\t\t\t\t\t\t     PHY_C20_B_MPLLA_CNTX_CFG(i),\n\t\t\t\t\t\t     pll_state->mplla[i]);\n\t\t}\n\t} else {\n\t\tfor (i = 0; i < ARRAY_SIZE(pll_state->mpllb); i++) {\n\t\t\tif (cntx)\n\t\t\t\tintel_c20_sram_write(i915, encoder->port, INTEL_CX0_LANE0,\n\t\t\t\t\t\t     PHY_C20_A_MPLLB_CNTX_CFG(i),\n\t\t\t\t\t\t     pll_state->mpllb[i]);\n\t\t\telse\n\t\t\t\tintel_c20_sram_write(i915, encoder->port, INTEL_CX0_LANE0,\n\t\t\t\t\t\t     PHY_C20_B_MPLLB_CNTX_CFG(i),\n\t\t\t\t\t\t     pll_state->mpllb[i]);\n\t\t}\n\t}\n\n\t \n\tintel_cx0_rmw(i915, encoder->port, lane, PHY_C20_VDR_CUSTOM_WIDTH,\n\t\t      PHY_C20_CUSTOM_WIDTH_MASK,\n\t\t      PHY_C20_CUSTOM_WIDTH(intel_get_c20_custom_width(pll_state->clock, dp)),\n\t\t      MB_WRITE_COMMITTED);\n\n\t \n\tif (dp) {\n\t\tintel_cx0_rmw(i915, encoder->port, lane, PHY_C20_VDR_CUSTOM_SERDES_RATE,\n\t\t\t      BIT(6) | PHY_C20_CUSTOM_SERDES_MASK,\n\t\t\t      BIT(6) | PHY_C20_CUSTOM_SERDES(intel_c20_get_dp_rate(pll_state->clock)),\n\t\t\t      MB_WRITE_COMMITTED);\n\t} else {\n\t\tintel_cx0_rmw(i915, encoder->port, lane, PHY_C20_VDR_CUSTOM_SERDES_RATE,\n\t\t\t      BIT(7) | PHY_C20_CUSTOM_SERDES_MASK,\n\t\t\t      is_hdmi_frl(pll_state->clock) ? BIT(7) : 0,\n\t\t\t      MB_WRITE_COMMITTED);\n\n\t\tintel_cx0_write(i915, encoder->port, INTEL_CX0_BOTH_LANES, PHY_C20_VDR_HDMI_RATE,\n\t\t\t\tintel_c20_get_hdmi_rate(pll_state->clock),\n\t\t\t\tMB_WRITE_COMMITTED);\n\t}\n\n\t \n\tintel_cx0_rmw(i915, encoder->port, lane, PHY_C20_VDR_CUSTOM_SERDES_RATE,\n\t\t      BIT(0), cntx ? 0 : 1, MB_WRITE_COMMITTED);\n}\n\nint intel_c10pll_calc_port_clock(struct intel_encoder *encoder,\n\t\t\t\t const struct intel_c10pll_state *pll_state)\n{\n\tunsigned int frac_quot = 0, frac_rem = 0, frac_den = 1;\n\tunsigned int multiplier, tx_clk_div, hdmi_div, refclk = 38400;\n\tint tmpclk = 0;\n\n\tif (pll_state->pll[0] & C10_PLL0_FRACEN) {\n\t\tfrac_quot = pll_state->pll[12] << 8 | pll_state->pll[11];\n\t\tfrac_rem =  pll_state->pll[14] << 8 | pll_state->pll[13];\n\t\tfrac_den =  pll_state->pll[10] << 8 | pll_state->pll[9];\n\t}\n\n\tmultiplier = (REG_FIELD_GET8(C10_PLL3_MULTIPLIERH_MASK, pll_state->pll[3]) << 8 |\n\t\t      pll_state->pll[2]) / 2 + 16;\n\n\ttx_clk_div = REG_FIELD_GET8(C10_PLL15_TXCLKDIV_MASK, pll_state->pll[15]);\n\thdmi_div = REG_FIELD_GET8(C10_PLL15_HDMIDIV_MASK, pll_state->pll[15]);\n\n\ttmpclk = DIV_ROUND_CLOSEST_ULL(mul_u32_u32(refclk, (multiplier << 16) + frac_quot) +\n\t\t\t\t     DIV_ROUND_CLOSEST(refclk * frac_rem, frac_den),\n\t\t\t\t     10 << (tx_clk_div + 16));\n\ttmpclk *= (hdmi_div ? 2 : 1);\n\n\treturn tmpclk;\n}\n\nint intel_c20pll_calc_port_clock(struct intel_encoder *encoder,\n\t\t\t\t const struct intel_c20pll_state *pll_state)\n{\n\tunsigned int frac, frac_en, frac_quot, frac_rem, frac_den;\n\tunsigned int multiplier, refclk = 38400;\n\tunsigned int tx_clk_div;\n\tunsigned int ref_clk_mpllb_div;\n\tunsigned int fb_clk_div4_en;\n\tunsigned int ref, vco;\n\tunsigned int tx_rate_mult;\n\tunsigned int tx_rate = REG_FIELD_GET(C20_PHY_TX_RATE, pll_state->tx[0]);\n\n\tif (pll_state->tx[0] & C20_PHY_USE_MPLLB) {\n\t\ttx_rate_mult = 1;\n\t\tfrac_en = REG_FIELD_GET(C20_MPLLB_FRACEN, pll_state->mpllb[6]);\n\t\tfrac_quot = pll_state->mpllb[8];\n\t\tfrac_rem =  pll_state->mpllb[9];\n\t\tfrac_den =  pll_state->mpllb[7];\n\t\tmultiplier = REG_FIELD_GET(C20_MULTIPLIER_MASK, pll_state->mpllb[0]);\n\t\ttx_clk_div = REG_FIELD_GET(C20_MPLLB_TX_CLK_DIV_MASK, pll_state->mpllb[0]);\n\t\tref_clk_mpllb_div = REG_FIELD_GET(C20_REF_CLK_MPLLB_DIV_MASK, pll_state->mpllb[6]);\n\t\tfb_clk_div4_en = 0;\n\t} else {\n\t\ttx_rate_mult = 2;\n\t\tfrac_en = REG_FIELD_GET(C20_MPLLA_FRACEN, pll_state->mplla[6]);\n\t\tfrac_quot = pll_state->mplla[8];\n\t\tfrac_rem =  pll_state->mplla[9];\n\t\tfrac_den =  pll_state->mplla[7];\n\t\tmultiplier = REG_FIELD_GET(C20_MULTIPLIER_MASK, pll_state->mplla[0]);\n\t\ttx_clk_div = REG_FIELD_GET(C20_MPLLA_TX_CLK_DIV_MASK, pll_state->mplla[1]);\n\t\tref_clk_mpllb_div = REG_FIELD_GET(C20_REF_CLK_MPLLB_DIV_MASK, pll_state->mplla[6]);\n\t\tfb_clk_div4_en = REG_FIELD_GET(C20_FB_CLK_DIV4_EN, pll_state->mplla[0]);\n\t}\n\n\tif (frac_en)\n\t\tfrac = frac_quot + DIV_ROUND_CLOSEST(frac_rem, frac_den);\n\telse\n\t\tfrac = 0;\n\n\tref = DIV_ROUND_CLOSEST(refclk * (1 << (1 + fb_clk_div4_en)), 1 << ref_clk_mpllb_div);\n\tvco = DIV_ROUND_CLOSEST_ULL(mul_u32_u32(ref, (multiplier << (17 - 2)) + frac) >> 17, 10);\n\n\treturn vco << tx_rate_mult >> tx_clk_div >> tx_rate;\n}\n\nstatic void intel_program_port_clock_ctl(struct intel_encoder *encoder,\n\t\t\t\t\t const struct intel_crtc_state *crtc_state,\n\t\t\t\t\t bool lane_reversal)\n{\n\tstruct drm_i915_private *i915 = to_i915(encoder->base.dev);\n\tu32 val = 0;\n\n\tintel_de_rmw(i915, XELPDP_PORT_BUF_CTL1(encoder->port), XELPDP_PORT_REVERSAL,\n\t\t     lane_reversal ? XELPDP_PORT_REVERSAL : 0);\n\n\tif (lane_reversal)\n\t\tval |= XELPDP_LANE1_PHY_CLOCK_SELECT;\n\n\tval |= XELPDP_FORWARD_CLOCK_UNGATE;\n\n\tif (intel_crtc_has_type(crtc_state, INTEL_OUTPUT_HDMI) &&\n\t    is_hdmi_frl(crtc_state->port_clock))\n\t\tval |= XELPDP_DDI_CLOCK_SELECT(XELPDP_DDI_CLOCK_SELECT_DIV18CLK);\n\telse\n\t\tval |= XELPDP_DDI_CLOCK_SELECT(XELPDP_DDI_CLOCK_SELECT_MAXPCLK);\n\n\t \n\t \n\tif (crtc_state->port_clock == 1000000 || crtc_state->port_clock == 2000000)\n\t\tval |= crtc_state->cx0pll_state.ssc_enabled ? XELPDP_SSC_ENABLE_PLLA : 0;\n\telse\n\t\tval |= crtc_state->cx0pll_state.ssc_enabled ? XELPDP_SSC_ENABLE_PLLB : 0;\n\n\tintel_de_rmw(i915, XELPDP_PORT_CLOCK_CTL(encoder->port),\n\t\t     XELPDP_LANE1_PHY_CLOCK_SELECT | XELPDP_FORWARD_CLOCK_UNGATE |\n\t\t     XELPDP_DDI_CLOCK_SELECT_MASK | XELPDP_SSC_ENABLE_PLLA |\n\t\t     XELPDP_SSC_ENABLE_PLLB, val);\n}\n\nstatic u32 intel_cx0_get_powerdown_update(u8 lane_mask)\n{\n\tu32 val = 0;\n\tint lane = 0;\n\n\tfor_each_cx0_lane_in_mask(lane_mask, lane)\n\t\tval |= XELPDP_LANE_POWERDOWN_UPDATE(lane);\n\n\treturn val;\n}\n\nstatic u32 intel_cx0_get_powerdown_state(u8 lane_mask, u8 state)\n{\n\tu32 val = 0;\n\tint lane = 0;\n\n\tfor_each_cx0_lane_in_mask(lane_mask, lane)\n\t\tval |= XELPDP_LANE_POWERDOWN_NEW_STATE(lane, state);\n\n\treturn val;\n}\n\nstatic void intel_cx0_powerdown_change_sequence(struct drm_i915_private *i915,\n\t\t\t\t\t\tenum port port,\n\t\t\t\t\t\tu8 lane_mask, u8 state)\n{\n\tenum phy phy = intel_port_to_phy(i915, port);\n\tint lane;\n\n\tintel_de_rmw(i915, XELPDP_PORT_BUF_CTL2(port),\n\t\t     intel_cx0_get_powerdown_state(INTEL_CX0_BOTH_LANES, XELPDP_LANE_POWERDOWN_NEW_STATE_MASK),\n\t\t     intel_cx0_get_powerdown_state(lane_mask, state));\n\n\t \n\tfor_each_cx0_lane_in_mask(lane_mask, lane)\n\t\tif (intel_de_wait_for_clear(i915, XELPDP_PORT_M2P_MSGBUS_CTL(port, lane),\n\t\t\t\t\t    XELPDP_PORT_M2P_TRANSACTION_PENDING,\n\t\t\t\t\t    XELPDP_MSGBUS_TIMEOUT_SLOW)) {\n\t\t\tdrm_dbg_kms(&i915->drm,\n\t\t\t\t    \"PHY %c Timeout waiting for previous transaction to complete. Reset the bus.\\n\",\n\t\t\t\t    phy_name(phy));\n\t\t\tintel_cx0_bus_reset(i915, port, lane);\n\t\t}\n\n\tintel_de_rmw(i915, XELPDP_PORT_BUF_CTL2(port),\n\t\t     intel_cx0_get_powerdown_update(INTEL_CX0_BOTH_LANES),\n\t\t     intel_cx0_get_powerdown_update(lane_mask));\n\n\t \n\tif (__intel_de_wait_for_register(i915, XELPDP_PORT_BUF_CTL2(port),\n\t\t\t\t\t intel_cx0_get_powerdown_update(lane_mask), 0,\n\t\t\t\t\t XELPDP_PORT_POWERDOWN_UPDATE_TIMEOUT_US, 0, NULL))\n\t\tdrm_warn(&i915->drm, \"PHY %c failed to bring out of Lane reset after %dus.\\n\",\n\t\t\t phy_name(phy), XELPDP_PORT_RESET_START_TIMEOUT_US);\n}\n\nstatic void intel_cx0_setup_powerdown(struct drm_i915_private *i915, enum port port)\n{\n\tintel_de_rmw(i915, XELPDP_PORT_BUF_CTL2(port),\n\t\t     XELPDP_POWER_STATE_READY_MASK,\n\t\t     XELPDP_POWER_STATE_READY(CX0_P2_STATE_READY));\n\tintel_de_rmw(i915, XELPDP_PORT_BUF_CTL3(port),\n\t\t     XELPDP_POWER_STATE_ACTIVE_MASK |\n\t\t     XELPDP_PLL_LANE_STAGGERING_DELAY_MASK,\n\t\t     XELPDP_POWER_STATE_ACTIVE(CX0_P0_STATE_ACTIVE) |\n\t\t     XELPDP_PLL_LANE_STAGGERING_DELAY(0));\n}\n\nstatic u32 intel_cx0_get_pclk_refclk_request(u8 lane_mask)\n{\n\tu32 val = 0;\n\tint lane = 0;\n\n\tfor_each_cx0_lane_in_mask(lane_mask, lane)\n\t\tval |= XELPDP_LANE_PCLK_REFCLK_REQUEST(lane);\n\n\treturn val;\n}\n\nstatic u32 intel_cx0_get_pclk_refclk_ack(u8 lane_mask)\n{\n\tu32 val = 0;\n\tint lane = 0;\n\n\tfor_each_cx0_lane_in_mask(lane_mask, lane)\n\t\tval |= XELPDP_LANE_PCLK_REFCLK_ACK(lane);\n\n\treturn val;\n}\n\nstatic void intel_cx0_phy_lane_reset(struct drm_i915_private *i915,\n\t\t\t\t     struct intel_encoder *encoder,\n\t\t\t\t     bool lane_reversal)\n{\n\tenum port port = encoder->port;\n\tenum phy phy = intel_port_to_phy(i915, port);\n\tbool both_lanes =  intel_tc_port_fia_max_lane_count(enc_to_dig_port(encoder)) > 2;\n\tu8 lane_mask = lane_reversal ? INTEL_CX0_LANE1 :\n\t\t\t\t  INTEL_CX0_LANE0;\n\tu32 lane_pipe_reset = both_lanes ?\n\t\t\t      XELPDP_LANE_PIPE_RESET(0) |\n\t\t\t      XELPDP_LANE_PIPE_RESET(1) :\n\t\t\t      XELPDP_LANE_PIPE_RESET(0);\n\tu32 lane_phy_current_status = both_lanes ?\n\t\t\t\t      XELPDP_LANE_PHY_CURRENT_STATUS(0) |\n\t\t\t\t      XELPDP_LANE_PHY_CURRENT_STATUS(1) :\n\t\t\t\t      XELPDP_LANE_PHY_CURRENT_STATUS(0);\n\n\tif (__intel_de_wait_for_register(i915, XELPDP_PORT_BUF_CTL1(port),\n\t\t\t\t\t XELPDP_PORT_BUF_SOC_PHY_READY,\n\t\t\t\t\t XELPDP_PORT_BUF_SOC_PHY_READY,\n\t\t\t\t\t XELPDP_PORT_BUF_SOC_READY_TIMEOUT_US, 0, NULL))\n\t\tdrm_warn(&i915->drm, \"PHY %c failed to bring out of SOC reset after %dus.\\n\",\n\t\t\t phy_name(phy), XELPDP_PORT_BUF_SOC_READY_TIMEOUT_US);\n\n\tintel_de_rmw(i915, XELPDP_PORT_BUF_CTL2(port), lane_pipe_reset,\n\t\t     lane_pipe_reset);\n\n\tif (__intel_de_wait_for_register(i915, XELPDP_PORT_BUF_CTL2(port),\n\t\t\t\t\t lane_phy_current_status, lane_phy_current_status,\n\t\t\t\t\t XELPDP_PORT_RESET_START_TIMEOUT_US, 0, NULL))\n\t\tdrm_warn(&i915->drm, \"PHY %c failed to bring out of Lane reset after %dus.\\n\",\n\t\t\t phy_name(phy), XELPDP_PORT_RESET_START_TIMEOUT_US);\n\n\tintel_de_rmw(i915, XELPDP_PORT_CLOCK_CTL(port),\n\t\t     intel_cx0_get_pclk_refclk_request(both_lanes ?\n\t\t\t\t\t\t       INTEL_CX0_BOTH_LANES :\n\t\t\t\t\t\t       INTEL_CX0_LANE0),\n\t\t     intel_cx0_get_pclk_refclk_request(lane_mask));\n\n\tif (__intel_de_wait_for_register(i915, XELPDP_PORT_CLOCK_CTL(port),\n\t\t\t\t\t intel_cx0_get_pclk_refclk_ack(both_lanes ?\n\t\t\t\t\t\t\t\t       INTEL_CX0_BOTH_LANES :\n\t\t\t\t\t\t\t\t       INTEL_CX0_LANE0),\n\t\t\t\t\t intel_cx0_get_pclk_refclk_ack(lane_mask),\n\t\t\t\t\t XELPDP_REFCLK_ENABLE_TIMEOUT_US, 0, NULL))\n\t\tdrm_warn(&i915->drm, \"PHY %c failed to request refclk after %dus.\\n\",\n\t\t\t phy_name(phy), XELPDP_REFCLK_ENABLE_TIMEOUT_US);\n\n\tintel_cx0_powerdown_change_sequence(i915, port, INTEL_CX0_BOTH_LANES,\n\t\t\t\t\t    CX0_P2_STATE_RESET);\n\tintel_cx0_setup_powerdown(i915, port);\n\n\tintel_de_rmw(i915, XELPDP_PORT_BUF_CTL2(port), lane_pipe_reset, 0);\n\n\tif (intel_de_wait_for_clear(i915, XELPDP_PORT_BUF_CTL2(port), lane_phy_current_status,\n\t\t\t\t    XELPDP_PORT_RESET_END_TIMEOUT))\n\t\tdrm_warn(&i915->drm, \"PHY %c failed to bring out of Lane reset after %dms.\\n\",\n\t\t\t phy_name(phy), XELPDP_PORT_RESET_END_TIMEOUT);\n}\n\nstatic void intel_cx0_program_phy_lane(struct drm_i915_private *i915,\n\t\t\t\t       struct intel_encoder *encoder, int lane_count,\n\t\t\t\t       bool lane_reversal)\n{\n\tu8 l0t1, l0t2, l1t1, l1t2;\n\tbool dp_alt_mode = intel_tc_port_in_dp_alt_mode(enc_to_dig_port(encoder));\n\tenum port port = encoder->port;\n\n\tif (intel_is_c10phy(i915, intel_port_to_phy(i915, port)))\n\t\tintel_cx0_rmw(i915, port, INTEL_CX0_BOTH_LANES,\n\t\t\t      PHY_C10_VDR_CONTROL(1), 0,\n\t\t\t      C10_VDR_CTRL_MSGBUS_ACCESS,\n\t\t\t      MB_WRITE_COMMITTED);\n\n\t \n\tl0t1 = intel_cx0_read(i915, port, INTEL_CX0_LANE0, PHY_CX0_TX_CONTROL(1, 2));\n\tl0t2 = intel_cx0_read(i915, port, INTEL_CX0_LANE0, PHY_CX0_TX_CONTROL(2, 2));\n\tl1t1 = intel_cx0_read(i915, port, INTEL_CX0_LANE1, PHY_CX0_TX_CONTROL(1, 2));\n\tl1t2 = intel_cx0_read(i915, port, INTEL_CX0_LANE1, PHY_CX0_TX_CONTROL(2, 2));\n\n\tl0t1 |= CONTROL2_DISABLE_SINGLE_TX;\n\tl0t2 |= CONTROL2_DISABLE_SINGLE_TX;\n\tl1t1 |= CONTROL2_DISABLE_SINGLE_TX;\n\tl1t2 |= CONTROL2_DISABLE_SINGLE_TX;\n\n\tif (lane_reversal) {\n\t\tswitch (lane_count) {\n\t\tcase 4:\n\t\t\tl0t1 &= ~CONTROL2_DISABLE_SINGLE_TX;\n\t\t\tfallthrough;\n\t\tcase 3:\n\t\t\tl0t2 &= ~CONTROL2_DISABLE_SINGLE_TX;\n\t\t\tfallthrough;\n\t\tcase 2:\n\t\t\tl1t1 &= ~CONTROL2_DISABLE_SINGLE_TX;\n\t\t\tfallthrough;\n\t\tcase 1:\n\t\t\tl1t2 &= ~CONTROL2_DISABLE_SINGLE_TX;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tMISSING_CASE(lane_count);\n\t\t}\n\t} else {\n\t\tswitch (lane_count) {\n\t\tcase 4:\n\t\t\tl1t2 &= ~CONTROL2_DISABLE_SINGLE_TX;\n\t\t\tfallthrough;\n\t\tcase 3:\n\t\t\tl1t1 &= ~CONTROL2_DISABLE_SINGLE_TX;\n\t\t\tfallthrough;\n\t\tcase 2:\n\t\t\tl0t2 &= ~CONTROL2_DISABLE_SINGLE_TX;\n\t\t\tl0t1 &= ~CONTROL2_DISABLE_SINGLE_TX;\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tif (dp_alt_mode)\n\t\t\t\tl0t2 &= ~CONTROL2_DISABLE_SINGLE_TX;\n\t\t\telse\n\t\t\t\tl0t1 &= ~CONTROL2_DISABLE_SINGLE_TX;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tMISSING_CASE(lane_count);\n\t\t}\n\t}\n\n\t \n\tintel_cx0_write(i915, port, INTEL_CX0_LANE0, PHY_CX0_TX_CONTROL(1, 2),\n\t\t\tl0t1, MB_WRITE_COMMITTED);\n\tintel_cx0_write(i915, port, INTEL_CX0_LANE0, PHY_CX0_TX_CONTROL(2, 2),\n\t\t\tl0t2, MB_WRITE_COMMITTED);\n\tintel_cx0_write(i915, port, INTEL_CX0_LANE1, PHY_CX0_TX_CONTROL(1, 2),\n\t\t\tl1t1, MB_WRITE_COMMITTED);\n\tintel_cx0_write(i915, port, INTEL_CX0_LANE1, PHY_CX0_TX_CONTROL(2, 2),\n\t\t\tl1t2, MB_WRITE_COMMITTED);\n\n\tif (intel_is_c10phy(i915, intel_port_to_phy(i915, port)))\n\t\tintel_cx0_rmw(i915, port, INTEL_CX0_BOTH_LANES,\n\t\t\t      PHY_C10_VDR_CONTROL(1), 0,\n\t\t\t      C10_VDR_CTRL_UPDATE_CFG,\n\t\t\t      MB_WRITE_COMMITTED);\n}\n\nstatic u32 intel_cx0_get_pclk_pll_request(u8 lane_mask)\n{\n\tu32 val = 0;\n\tint lane = 0;\n\n\tfor_each_cx0_lane_in_mask(lane_mask, lane)\n\t\tval |= XELPDP_LANE_PCLK_PLL_REQUEST(lane);\n\n\treturn val;\n}\n\nstatic u32 intel_cx0_get_pclk_pll_ack(u8 lane_mask)\n{\n\tu32 val = 0;\n\tint lane = 0;\n\n\tfor_each_cx0_lane_in_mask(lane_mask, lane)\n\t\tval |= XELPDP_LANE_PCLK_PLL_ACK(lane);\n\n\treturn val;\n}\n\nstatic void intel_cx0pll_enable(struct intel_encoder *encoder,\n\t\t\t\tconst struct intel_crtc_state *crtc_state)\n{\n\tstruct drm_i915_private *i915 = to_i915(encoder->base.dev);\n\tenum phy phy = intel_port_to_phy(i915, encoder->port);\n\tstruct intel_digital_port *dig_port = enc_to_dig_port(encoder);\n\tbool lane_reversal = dig_port->saved_port_bits & DDI_BUF_PORT_REVERSAL;\n\tu8 maxpclk_lane = lane_reversal ? INTEL_CX0_LANE1 :\n\t\t\t\t\t  INTEL_CX0_LANE0;\n\tintel_wakeref_t wakeref = intel_cx0_phy_transaction_begin(encoder);\n\n\t \n\tintel_program_port_clock_ctl(encoder, crtc_state, lane_reversal);\n\n\t \n\tintel_cx0_phy_lane_reset(i915, encoder, lane_reversal);\n\n\t \n\tintel_cx0_powerdown_change_sequence(i915, encoder->port, INTEL_CX0_BOTH_LANES,\n\t\t\t\t\t    CX0_P2_STATE_READY);\n\n\t \n\tif (intel_is_c10phy(i915, phy))\n\t\tintel_c10_pll_program(i915, crtc_state, encoder);\n\telse\n\t\tintel_c20_pll_program(i915, crtc_state, encoder);\n\n\t \n\tintel_cx0_program_phy_lane(i915, encoder, crtc_state->lane_count, lane_reversal);\n\n\t \n\n\t \n\tintel_de_write(i915, DDI_CLK_VALFREQ(encoder->port),\n\t\t       crtc_state->port_clock);\n\n\t \n\tintel_de_rmw(i915, XELPDP_PORT_CLOCK_CTL(encoder->port),\n\t\t     intel_cx0_get_pclk_pll_request(INTEL_CX0_BOTH_LANES),\n\t\t     intel_cx0_get_pclk_pll_request(maxpclk_lane));\n\n\t \n\tif (__intel_de_wait_for_register(i915, XELPDP_PORT_CLOCK_CTL(encoder->port),\n\t\t\t\t\t intel_cx0_get_pclk_pll_ack(INTEL_CX0_BOTH_LANES),\n\t\t\t\t\t intel_cx0_get_pclk_pll_ack(maxpclk_lane),\n\t\t\t\t\t XELPDP_PCLK_PLL_ENABLE_TIMEOUT_US, 0, NULL))\n\t\tdrm_warn(&i915->drm, \"Port %c PLL not locked after %dus.\\n\",\n\t\t\t phy_name(phy), XELPDP_PCLK_PLL_ENABLE_TIMEOUT_US);\n\n\t \n\n\t \n\tintel_cx0_phy_transaction_end(encoder, wakeref);\n}\n\nint intel_mtl_tbt_calc_port_clock(struct intel_encoder *encoder)\n{\n\tstruct drm_i915_private *i915 = to_i915(encoder->base.dev);\n\tu32 clock;\n\tu32 val = intel_de_read(i915, XELPDP_PORT_CLOCK_CTL(encoder->port));\n\n\tclock = REG_FIELD_GET(XELPDP_DDI_CLOCK_SELECT_MASK, val);\n\n\tdrm_WARN_ON(&i915->drm, !(val & XELPDP_FORWARD_CLOCK_UNGATE));\n\tdrm_WARN_ON(&i915->drm, !(val & XELPDP_TBT_CLOCK_REQUEST));\n\tdrm_WARN_ON(&i915->drm, !(val & XELPDP_TBT_CLOCK_ACK));\n\n\tswitch (clock) {\n\tcase XELPDP_DDI_CLOCK_SELECT_TBT_162:\n\t\treturn 162000;\n\tcase XELPDP_DDI_CLOCK_SELECT_TBT_270:\n\t\treturn 270000;\n\tcase XELPDP_DDI_CLOCK_SELECT_TBT_540:\n\t\treturn 540000;\n\tcase XELPDP_DDI_CLOCK_SELECT_TBT_810:\n\t\treturn 810000;\n\tdefault:\n\t\tMISSING_CASE(clock);\n\t\treturn 162000;\n\t}\n}\n\nstatic int intel_mtl_tbt_clock_select(struct drm_i915_private *i915, int clock)\n{\n\tswitch (clock) {\n\tcase 162000:\n\t\treturn XELPDP_DDI_CLOCK_SELECT_TBT_162;\n\tcase 270000:\n\t\treturn XELPDP_DDI_CLOCK_SELECT_TBT_270;\n\tcase 540000:\n\t\treturn XELPDP_DDI_CLOCK_SELECT_TBT_540;\n\tcase 810000:\n\t\treturn XELPDP_DDI_CLOCK_SELECT_TBT_810;\n\tdefault:\n\t\tMISSING_CASE(clock);\n\t\treturn XELPDP_DDI_CLOCK_SELECT_TBT_162;\n\t}\n}\n\nstatic void intel_mtl_tbt_pll_enable(struct intel_encoder *encoder,\n\t\t\t\t     const struct intel_crtc_state *crtc_state)\n{\n\tstruct drm_i915_private *i915 = to_i915(encoder->base.dev);\n\tenum phy phy = intel_port_to_phy(i915, encoder->port);\n\tu32 val = 0;\n\n\t \n\tval |= XELPDP_DDI_CLOCK_SELECT(intel_mtl_tbt_clock_select(i915, crtc_state->port_clock));\n\tval |= XELPDP_FORWARD_CLOCK_UNGATE;\n\tintel_de_rmw(i915, XELPDP_PORT_CLOCK_CTL(encoder->port),\n\t\t     XELPDP_DDI_CLOCK_SELECT_MASK | XELPDP_FORWARD_CLOCK_UNGATE, val);\n\n\t \n\tval = intel_de_read(i915, XELPDP_PORT_CLOCK_CTL(encoder->port));\n\n\t \n\n\t \n\tval |= XELPDP_TBT_CLOCK_REQUEST;\n\tintel_de_write(i915, XELPDP_PORT_CLOCK_CTL(encoder->port), val);\n\n\t \n\tif (__intel_de_wait_for_register(i915, XELPDP_PORT_CLOCK_CTL(encoder->port),\n\t\t\t\t\t XELPDP_TBT_CLOCK_ACK,\n\t\t\t\t\t XELPDP_TBT_CLOCK_ACK,\n\t\t\t\t\t 100, 0, NULL))\n\t\tdrm_warn(&i915->drm, \"[ENCODER:%d:%s][%c] PHY PLL not locked after 100us.\\n\",\n\t\t\t encoder->base.base.id, encoder->base.name, phy_name(phy));\n\n\t \n\n\t \n\tintel_de_write(i915, DDI_CLK_VALFREQ(encoder->port),\n\t\t       crtc_state->port_clock);\n}\n\nvoid intel_mtl_pll_enable(struct intel_encoder *encoder,\n\t\t\t  const struct intel_crtc_state *crtc_state)\n{\n\tstruct intel_digital_port *dig_port = enc_to_dig_port(encoder);\n\n\tif (intel_tc_port_in_tbt_alt_mode(dig_port))\n\t\tintel_mtl_tbt_pll_enable(encoder, crtc_state);\n\telse\n\t\tintel_cx0pll_enable(encoder, crtc_state);\n}\n\nstatic void intel_cx0pll_disable(struct intel_encoder *encoder)\n{\n\tstruct drm_i915_private *i915 = to_i915(encoder->base.dev);\n\tenum phy phy = intel_port_to_phy(i915, encoder->port);\n\tbool is_c10 = intel_is_c10phy(i915, phy);\n\tintel_wakeref_t wakeref = intel_cx0_phy_transaction_begin(encoder);\n\n\t \n\tintel_cx0_powerdown_change_sequence(i915, encoder->port, INTEL_CX0_BOTH_LANES,\n\t\t\t\t\t    is_c10 ? CX0_P2PG_STATE_DISABLE :\n\t\t\t\t\t    CX0_P4PG_STATE_DISABLE);\n\n\t \n\n\t \n\tintel_de_rmw(i915, XELPDP_PORT_CLOCK_CTL(encoder->port),\n\t\t     intel_cx0_get_pclk_pll_request(INTEL_CX0_BOTH_LANES) |\n\t\t     intel_cx0_get_pclk_refclk_request(INTEL_CX0_BOTH_LANES), 0);\n\n\t \n\tintel_de_write(i915, DDI_CLK_VALFREQ(encoder->port), 0);\n\n\t \n\tif (__intel_de_wait_for_register(i915, XELPDP_PORT_CLOCK_CTL(encoder->port),\n\t\t\t\t\t intel_cx0_get_pclk_pll_ack(INTEL_CX0_BOTH_LANES) |\n\t\t\t\t\t intel_cx0_get_pclk_refclk_ack(INTEL_CX0_BOTH_LANES), 0,\n\t\t\t\t\t XELPDP_PCLK_PLL_DISABLE_TIMEOUT_US, 0, NULL))\n\t\tdrm_warn(&i915->drm, \"Port %c PLL not unlocked after %dus.\\n\",\n\t\t\t phy_name(phy), XELPDP_PCLK_PLL_DISABLE_TIMEOUT_US);\n\n\t \n\n\t \n\tintel_de_rmw(i915, XELPDP_PORT_CLOCK_CTL(encoder->port),\n\t\t     XELPDP_DDI_CLOCK_SELECT_MASK, 0);\n\tintel_de_rmw(i915, XELPDP_PORT_CLOCK_CTL(encoder->port),\n\t\t     XELPDP_FORWARD_CLOCK_UNGATE, 0);\n\n\tintel_cx0_phy_transaction_end(encoder, wakeref);\n}\n\nstatic void intel_mtl_tbt_pll_disable(struct intel_encoder *encoder)\n{\n\tstruct drm_i915_private *i915 = to_i915(encoder->base.dev);\n\tenum phy phy = intel_port_to_phy(i915, encoder->port);\n\n\t \n\n\t \n\tintel_de_rmw(i915, XELPDP_PORT_CLOCK_CTL(encoder->port),\n\t\t     XELPDP_TBT_CLOCK_REQUEST, 0);\n\n\t \n\tif (__intel_de_wait_for_register(i915, XELPDP_PORT_CLOCK_CTL(encoder->port),\n\t\t\t\t\t XELPDP_TBT_CLOCK_ACK, 0, 10, 0, NULL))\n\t\tdrm_warn(&i915->drm, \"[ENCODER:%d:%s][%c] PHY PLL not unlocked after 10us.\\n\",\n\t\t\t encoder->base.base.id, encoder->base.name, phy_name(phy));\n\n\t \n\n\t \n\tintel_de_rmw(i915, XELPDP_PORT_CLOCK_CTL(encoder->port),\n\t\t     XELPDP_DDI_CLOCK_SELECT_MASK |\n\t\t     XELPDP_FORWARD_CLOCK_UNGATE, 0);\n\n\t \n\tintel_de_write(i915, DDI_CLK_VALFREQ(encoder->port), 0);\n}\n\nvoid intel_mtl_pll_disable(struct intel_encoder *encoder)\n{\n\tstruct intel_digital_port *dig_port = enc_to_dig_port(encoder);\n\n\tif (intel_tc_port_in_tbt_alt_mode(dig_port))\n\t\tintel_mtl_tbt_pll_disable(encoder);\n\telse\n\t\tintel_cx0pll_disable(encoder);\n}\n\nenum icl_port_dpll_id\nintel_mtl_port_pll_type(struct intel_encoder *encoder,\n\t\t\tconst struct intel_crtc_state *crtc_state)\n{\n\tstruct drm_i915_private *i915 = to_i915(encoder->base.dev);\n\t \n\tu32 val = intel_de_read(i915, XELPDP_PORT_CLOCK_CTL(encoder->port));\n\tu32 clock = REG_FIELD_GET(XELPDP_DDI_CLOCK_SELECT_MASK, val);\n\n\tif (clock == XELPDP_DDI_CLOCK_SELECT_MAXPCLK ||\n\t    clock == XELPDP_DDI_CLOCK_SELECT_DIV18CLK)\n\t\treturn ICL_PORT_DPLL_MG_PHY;\n\telse\n\t\treturn ICL_PORT_DPLL_DEFAULT;\n}\n\nvoid intel_c10pll_state_verify(struct intel_atomic_state *state,\n\t\t\t       struct intel_crtc_state *new_crtc_state)\n{\n\tstruct drm_i915_private *i915 = to_i915(state->base.dev);\n\tstruct intel_c10pll_state mpllb_hw_state = { 0 };\n\tstruct intel_c10pll_state *mpllb_sw_state = &new_crtc_state->cx0pll_state.c10;\n\tstruct intel_crtc *crtc = to_intel_crtc(new_crtc_state->uapi.crtc);\n\tstruct intel_encoder *encoder;\n\tenum phy phy;\n\tint i;\n\n\tif (DISPLAY_VER(i915) < 14)\n\t\treturn;\n\n\tif (!new_crtc_state->hw.active)\n\t\treturn;\n\n\t \n\tif (!intel_crtc_needs_modeset(new_crtc_state) &&\n\t    !intel_crtc_needs_fastset(new_crtc_state))\n\t\treturn;\n\n\tencoder = intel_get_crtc_new_encoder(state, new_crtc_state);\n\tphy = intel_port_to_phy(i915, encoder->port);\n\n\tif (!intel_is_c10phy(i915, phy))\n\t\treturn;\n\n\tintel_c10pll_readout_hw_state(encoder, &mpllb_hw_state);\n\n\tfor (i = 0; i < ARRAY_SIZE(mpllb_sw_state->pll); i++) {\n\t\tu8 expected = mpllb_sw_state->pll[i];\n\n\t\tI915_STATE_WARN(i915, mpllb_hw_state.pll[i] != expected,\n\t\t\t\t\"[CRTC:%d:%s] mismatch in C10MPLLB: Register[%d] (expected 0x%02x, found 0x%02x)\",\n\t\t\t\tcrtc->base.base.id, crtc->base.name, i,\n\t\t\t\texpected, mpllb_hw_state.pll[i]);\n\t}\n\n\tI915_STATE_WARN(i915, mpllb_hw_state.tx != mpllb_sw_state->tx,\n\t\t\t\"[CRTC:%d:%s] mismatch in C10MPLLB: Register TX0 (expected 0x%02x, found 0x%02x)\",\n\t\t\tcrtc->base.base.id, crtc->base.name,\n\t\t\tmpllb_sw_state->tx, mpllb_hw_state.tx);\n\n\tI915_STATE_WARN(i915, mpllb_hw_state.cmn != mpllb_sw_state->cmn,\n\t\t\t\"[CRTC:%d:%s] mismatch in C10MPLLB: Register CMN0 (expected 0x%02x, found 0x%02x)\",\n\t\t\tcrtc->base.base.id, crtc->base.name,\n\t\t\tmpllb_sw_state->cmn, mpllb_hw_state.cmn);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}