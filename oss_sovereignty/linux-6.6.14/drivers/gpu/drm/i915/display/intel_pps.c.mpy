{
  "module_name": "intel_pps.c",
  "hash_id": "916e5a49f4014304dde86f3b9296fdc3001b33c84dc1fd1bf7f90080bf3def22",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/i915/display/intel_pps.c",
  "human_readable_source": "\n \n\n#include \"g4x_dp.h\"\n#include \"i915_drv.h\"\n#include \"i915_reg.h\"\n#include \"intel_de.h\"\n#include \"intel_display_power_well.h\"\n#include \"intel_display_types.h\"\n#include \"intel_dp.h\"\n#include \"intel_dpio_phy.h\"\n#include \"intel_dpll.h\"\n#include \"intel_lvds.h\"\n#include \"intel_lvds_regs.h\"\n#include \"intel_pps.h\"\n#include \"intel_pps_regs.h\"\n#include \"intel_quirks.h\"\n\nstatic void vlv_steal_power_sequencer(struct drm_i915_private *dev_priv,\n\t\t\t\t      enum pipe pipe);\n\nstatic void pps_init_delays(struct intel_dp *intel_dp);\nstatic void pps_init_registers(struct intel_dp *intel_dp, bool force_disable_vdd);\n\nstatic const char *pps_name(struct drm_i915_private *i915,\n\t\t\t    struct intel_pps *pps)\n{\n\tif (IS_VALLEYVIEW(i915) || IS_CHERRYVIEW(i915)) {\n\t\tswitch (pps->pps_pipe) {\n\t\tcase INVALID_PIPE:\n\t\t\t \n\t\t\treturn \"PPS <none>\";\n\t\tcase PIPE_A:\n\t\t\treturn \"PPS A\";\n\t\tcase PIPE_B:\n\t\t\treturn \"PPS B\";\n\t\tdefault:\n\t\t\tMISSING_CASE(pps->pps_pipe);\n\t\t\tbreak;\n\t\t}\n\t} else {\n\t\tswitch (pps->pps_idx) {\n\t\tcase 0:\n\t\t\treturn \"PPS 0\";\n\t\tcase 1:\n\t\t\treturn \"PPS 1\";\n\t\tdefault:\n\t\t\tMISSING_CASE(pps->pps_idx);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn \"PPS <invalid>\";\n}\n\nintel_wakeref_t intel_pps_lock(struct intel_dp *intel_dp)\n{\n\tstruct drm_i915_private *dev_priv = dp_to_i915(intel_dp);\n\tintel_wakeref_t wakeref;\n\n\t \n\twakeref = intel_display_power_get(dev_priv, POWER_DOMAIN_DISPLAY_CORE);\n\tmutex_lock(&dev_priv->display.pps.mutex);\n\n\treturn wakeref;\n}\n\nintel_wakeref_t intel_pps_unlock(struct intel_dp *intel_dp,\n\t\t\t\t intel_wakeref_t wakeref)\n{\n\tstruct drm_i915_private *dev_priv = dp_to_i915(intel_dp);\n\n\tmutex_unlock(&dev_priv->display.pps.mutex);\n\tintel_display_power_put(dev_priv, POWER_DOMAIN_DISPLAY_CORE, wakeref);\n\n\treturn 0;\n}\n\nstatic void\nvlv_power_sequencer_kick(struct intel_dp *intel_dp)\n{\n\tstruct drm_i915_private *dev_priv = dp_to_i915(intel_dp);\n\tstruct intel_digital_port *dig_port = dp_to_dig_port(intel_dp);\n\tenum pipe pipe = intel_dp->pps.pps_pipe;\n\tbool pll_enabled, release_cl_override = false;\n\tenum dpio_phy phy = DPIO_PHY(pipe);\n\tenum dpio_channel ch = vlv_pipe_to_channel(pipe);\n\tu32 DP;\n\n\tif (drm_WARN(&dev_priv->drm,\n\t\t     intel_de_read(dev_priv, intel_dp->output_reg) & DP_PORT_EN,\n\t\t     \"skipping %s kick due to [ENCODER:%d:%s] being active\\n\",\n\t\t     pps_name(dev_priv, &intel_dp->pps),\n\t\t     dig_port->base.base.base.id, dig_port->base.base.name))\n\t\treturn;\n\n\tdrm_dbg_kms(&dev_priv->drm,\n\t\t    \"kicking %s for [ENCODER:%d:%s]\\n\",\n\t\t    pps_name(dev_priv, &intel_dp->pps),\n\t\t    dig_port->base.base.base.id, dig_port->base.base.name);\n\n\t \n\tDP = intel_de_read(dev_priv, intel_dp->output_reg) & DP_DETECTED;\n\tDP |= DP_VOLTAGE_0_4 | DP_PRE_EMPHASIS_0;\n\tDP |= DP_PORT_WIDTH(1);\n\tDP |= DP_LINK_TRAIN_PAT_1;\n\n\tif (IS_CHERRYVIEW(dev_priv))\n\t\tDP |= DP_PIPE_SEL_CHV(pipe);\n\telse\n\t\tDP |= DP_PIPE_SEL(pipe);\n\n\tpll_enabled = intel_de_read(dev_priv, DPLL(pipe)) & DPLL_VCO_ENABLE;\n\n\t \n\tif (!pll_enabled) {\n\t\trelease_cl_override = IS_CHERRYVIEW(dev_priv) &&\n\t\t\t!chv_phy_powergate_ch(dev_priv, phy, ch, true);\n\n\t\tif (vlv_force_pll_on(dev_priv, pipe, vlv_get_dpll(dev_priv))) {\n\t\t\tdrm_err(&dev_priv->drm,\n\t\t\t\t\"Failed to force on PLL for pipe %c!\\n\",\n\t\t\t\tpipe_name(pipe));\n\t\t\treturn;\n\t\t}\n\t}\n\n\t \n\tintel_de_write(dev_priv, intel_dp->output_reg, DP);\n\tintel_de_posting_read(dev_priv, intel_dp->output_reg);\n\n\tintel_de_write(dev_priv, intel_dp->output_reg, DP | DP_PORT_EN);\n\tintel_de_posting_read(dev_priv, intel_dp->output_reg);\n\n\tintel_de_write(dev_priv, intel_dp->output_reg, DP & ~DP_PORT_EN);\n\tintel_de_posting_read(dev_priv, intel_dp->output_reg);\n\n\tif (!pll_enabled) {\n\t\tvlv_force_pll_off(dev_priv, pipe);\n\n\t\tif (release_cl_override)\n\t\t\tchv_phy_powergate_ch(dev_priv, phy, ch, false);\n\t}\n}\n\nstatic enum pipe vlv_find_free_pps(struct drm_i915_private *dev_priv)\n{\n\tstruct intel_encoder *encoder;\n\tunsigned int pipes = (1 << PIPE_A) | (1 << PIPE_B);\n\n\t \n\tfor_each_intel_dp(&dev_priv->drm, encoder) {\n\t\tstruct intel_dp *intel_dp = enc_to_intel_dp(encoder);\n\n\t\tif (encoder->type == INTEL_OUTPUT_EDP) {\n\t\t\tdrm_WARN_ON(&dev_priv->drm,\n\t\t\t\t    intel_dp->pps.active_pipe != INVALID_PIPE &&\n\t\t\t\t    intel_dp->pps.active_pipe !=\n\t\t\t\t    intel_dp->pps.pps_pipe);\n\n\t\t\tif (intel_dp->pps.pps_pipe != INVALID_PIPE)\n\t\t\t\tpipes &= ~(1 << intel_dp->pps.pps_pipe);\n\t\t} else {\n\t\t\tdrm_WARN_ON(&dev_priv->drm,\n\t\t\t\t    intel_dp->pps.pps_pipe != INVALID_PIPE);\n\n\t\t\tif (intel_dp->pps.active_pipe != INVALID_PIPE)\n\t\t\t\tpipes &= ~(1 << intel_dp->pps.active_pipe);\n\t\t}\n\t}\n\n\tif (pipes == 0)\n\t\treturn INVALID_PIPE;\n\n\treturn ffs(pipes) - 1;\n}\n\nstatic enum pipe\nvlv_power_sequencer_pipe(struct intel_dp *intel_dp)\n{\n\tstruct drm_i915_private *dev_priv = dp_to_i915(intel_dp);\n\tstruct intel_digital_port *dig_port = dp_to_dig_port(intel_dp);\n\tenum pipe pipe;\n\n\tlockdep_assert_held(&dev_priv->display.pps.mutex);\n\n\t \n\tdrm_WARN_ON(&dev_priv->drm, !intel_dp_is_edp(intel_dp));\n\n\tdrm_WARN_ON(&dev_priv->drm, intel_dp->pps.active_pipe != INVALID_PIPE &&\n\t\t    intel_dp->pps.active_pipe != intel_dp->pps.pps_pipe);\n\n\tif (intel_dp->pps.pps_pipe != INVALID_PIPE)\n\t\treturn intel_dp->pps.pps_pipe;\n\n\tpipe = vlv_find_free_pps(dev_priv);\n\n\t \n\tif (drm_WARN_ON(&dev_priv->drm, pipe == INVALID_PIPE))\n\t\tpipe = PIPE_A;\n\n\tvlv_steal_power_sequencer(dev_priv, pipe);\n\tintel_dp->pps.pps_pipe = pipe;\n\n\tdrm_dbg_kms(&dev_priv->drm,\n\t\t    \"picked %s for [ENCODER:%d:%s]\\n\",\n\t\t    pps_name(dev_priv, &intel_dp->pps),\n\t\t    dig_port->base.base.base.id, dig_port->base.base.name);\n\n\t \n\tpps_init_delays(intel_dp);\n\tpps_init_registers(intel_dp, true);\n\n\t \n\tvlv_power_sequencer_kick(intel_dp);\n\n\treturn intel_dp->pps.pps_pipe;\n}\n\nstatic int\nbxt_power_sequencer_idx(struct intel_dp *intel_dp)\n{\n\tstruct drm_i915_private *dev_priv = dp_to_i915(intel_dp);\n\tint pps_idx = intel_dp->pps.pps_idx;\n\n\tlockdep_assert_held(&dev_priv->display.pps.mutex);\n\n\t \n\tdrm_WARN_ON(&dev_priv->drm, !intel_dp_is_edp(intel_dp));\n\n\tif (!intel_dp->pps.pps_reset)\n\t\treturn pps_idx;\n\n\tintel_dp->pps.pps_reset = false;\n\n\t \n\tpps_init_registers(intel_dp, false);\n\n\treturn pps_idx;\n}\n\ntypedef bool (*pps_check)(struct drm_i915_private *dev_priv, int pps_idx);\n\nstatic bool pps_has_pp_on(struct drm_i915_private *dev_priv, int pps_idx)\n{\n\treturn intel_de_read(dev_priv, PP_STATUS(pps_idx)) & PP_ON;\n}\n\nstatic bool pps_has_vdd_on(struct drm_i915_private *dev_priv, int pps_idx)\n{\n\treturn intel_de_read(dev_priv, PP_CONTROL(pps_idx)) & EDP_FORCE_VDD;\n}\n\nstatic bool pps_any(struct drm_i915_private *dev_priv, int pps_idx)\n{\n\treturn true;\n}\n\nstatic enum pipe\nvlv_initial_pps_pipe(struct drm_i915_private *dev_priv,\n\t\t     enum port port, pps_check check)\n{\n\tenum pipe pipe;\n\n\tfor (pipe = PIPE_A; pipe <= PIPE_B; pipe++) {\n\t\tu32 port_sel = intel_de_read(dev_priv, PP_ON_DELAYS(pipe)) &\n\t\t\tPANEL_PORT_SELECT_MASK;\n\n\t\tif (port_sel != PANEL_PORT_SELECT_VLV(port))\n\t\t\tcontinue;\n\n\t\tif (!check(dev_priv, pipe))\n\t\t\tcontinue;\n\n\t\treturn pipe;\n\t}\n\n\treturn INVALID_PIPE;\n}\n\nstatic void\nvlv_initial_power_sequencer_setup(struct intel_dp *intel_dp)\n{\n\tstruct drm_i915_private *dev_priv = dp_to_i915(intel_dp);\n\tstruct intel_digital_port *dig_port = dp_to_dig_port(intel_dp);\n\tenum port port = dig_port->base.port;\n\n\tlockdep_assert_held(&dev_priv->display.pps.mutex);\n\n\t \n\t \n\tintel_dp->pps.pps_pipe = vlv_initial_pps_pipe(dev_priv, port,\n\t\t\t\t\t\t      pps_has_pp_on);\n\t \n\tif (intel_dp->pps.pps_pipe == INVALID_PIPE)\n\t\tintel_dp->pps.pps_pipe = vlv_initial_pps_pipe(dev_priv, port,\n\t\t\t\t\t\t\t      pps_has_vdd_on);\n\t \n\tif (intel_dp->pps.pps_pipe == INVALID_PIPE)\n\t\tintel_dp->pps.pps_pipe = vlv_initial_pps_pipe(dev_priv, port,\n\t\t\t\t\t\t\t      pps_any);\n\n\t \n\tif (intel_dp->pps.pps_pipe == INVALID_PIPE) {\n\t\tdrm_dbg_kms(&dev_priv->drm,\n\t\t\t    \"[ENCODER:%d:%s] no initial power sequencer\\n\",\n\t\t\t    dig_port->base.base.base.id, dig_port->base.base.name);\n\t\treturn;\n\t}\n\n\tdrm_dbg_kms(&dev_priv->drm,\n\t\t    \"[ENCODER:%d:%s] initial power sequencer: %s\\n\",\n\t\t    dig_port->base.base.base.id, dig_port->base.base.name,\n\t\t    pps_name(dev_priv, &intel_dp->pps));\n}\n\nstatic int intel_num_pps(struct drm_i915_private *i915)\n{\n\tif (IS_VALLEYVIEW(i915) || IS_CHERRYVIEW(i915))\n\t\treturn 2;\n\n\tif (IS_GEMINILAKE(i915) || IS_BROXTON(i915))\n\t\treturn 2;\n\n\tif (INTEL_PCH_TYPE(i915) >= PCH_DG1)\n\t\treturn 1;\n\n\tif (INTEL_PCH_TYPE(i915) >= PCH_ICP)\n\t\treturn 2;\n\n\treturn 1;\n}\n\nstatic bool intel_pps_is_valid(struct intel_dp *intel_dp)\n{\n\tstruct drm_i915_private *i915 = dp_to_i915(intel_dp);\n\n\tif (intel_dp->pps.pps_idx == 1 &&\n\t    INTEL_PCH_TYPE(i915) >= PCH_ICP &&\n\t    INTEL_PCH_TYPE(i915) < PCH_MTP)\n\t\treturn intel_de_read(i915, SOUTH_CHICKEN1) & ICP_SECOND_PPS_IO_SELECT;\n\n\treturn true;\n}\n\nstatic int\nbxt_initial_pps_idx(struct drm_i915_private *i915, pps_check check)\n{\n\tint pps_idx, pps_num = intel_num_pps(i915);\n\n\tfor (pps_idx = 0; pps_idx < pps_num; pps_idx++) {\n\t\tif (check(i915, pps_idx))\n\t\t\treturn pps_idx;\n\t}\n\n\treturn -1;\n}\n\nstatic bool\npps_initial_setup(struct intel_dp *intel_dp)\n{\n\tstruct intel_encoder *encoder = &dp_to_dig_port(intel_dp)->base;\n\tstruct intel_connector *connector = intel_dp->attached_connector;\n\tstruct drm_i915_private *i915 = to_i915(encoder->base.dev);\n\n\tlockdep_assert_held(&i915->display.pps.mutex);\n\n\tif (IS_VALLEYVIEW(i915) || IS_CHERRYVIEW(i915)) {\n\t\tvlv_initial_power_sequencer_setup(intel_dp);\n\t\treturn true;\n\t}\n\n\t \n\tif (intel_num_pps(i915) > 1)\n\t\tintel_dp->pps.pps_idx = connector->panel.vbt.backlight.controller;\n\telse\n\t\tintel_dp->pps.pps_idx = 0;\n\n\tif (drm_WARN_ON(&i915->drm, intel_dp->pps.pps_idx >= intel_num_pps(i915)))\n\t\tintel_dp->pps.pps_idx = -1;\n\n\t \n\tif (intel_dp->pps.pps_idx < 0)\n\t\tintel_dp->pps.pps_idx = bxt_initial_pps_idx(i915, pps_has_pp_on);\n\t \n\tif (intel_dp->pps.pps_idx < 0)\n\t\tintel_dp->pps.pps_idx = bxt_initial_pps_idx(i915, pps_has_vdd_on);\n\t \n\tif (intel_dp->pps.pps_idx < 0) {\n\t\tintel_dp->pps.pps_idx = bxt_initial_pps_idx(i915, pps_any);\n\n\t\tdrm_dbg_kms(&i915->drm,\n\t\t\t    \"[ENCODER:%d:%s] no initial power sequencer, assuming %s\\n\",\n\t\t\t    encoder->base.base.id, encoder->base.name,\n\t\t\t    pps_name(i915, &intel_dp->pps));\n\t} else {\n\t\tdrm_dbg_kms(&i915->drm,\n\t\t\t    \"[ENCODER:%d:%s] initial power sequencer: %s\\n\",\n\t\t\t    encoder->base.base.id, encoder->base.name,\n\t\t\t    pps_name(i915, &intel_dp->pps));\n\t}\n\n\treturn intel_pps_is_valid(intel_dp);\n}\n\nvoid intel_pps_reset_all(struct drm_i915_private *dev_priv)\n{\n\tstruct intel_encoder *encoder;\n\n\tif (drm_WARN_ON(&dev_priv->drm, !IS_LP(dev_priv)))\n\t\treturn;\n\n\tif (!HAS_DISPLAY(dev_priv))\n\t\treturn;\n\n\t \n\n\tfor_each_intel_dp(&dev_priv->drm, encoder) {\n\t\tstruct intel_dp *intel_dp = enc_to_intel_dp(encoder);\n\n\t\tdrm_WARN_ON(&dev_priv->drm,\n\t\t\t    intel_dp->pps.active_pipe != INVALID_PIPE);\n\n\t\tif (encoder->type != INTEL_OUTPUT_EDP)\n\t\t\tcontinue;\n\n\t\tif (DISPLAY_VER(dev_priv) >= 9)\n\t\t\tintel_dp->pps.pps_reset = true;\n\t\telse\n\t\t\tintel_dp->pps.pps_pipe = INVALID_PIPE;\n\t}\n}\n\nstruct pps_registers {\n\ti915_reg_t pp_ctrl;\n\ti915_reg_t pp_stat;\n\ti915_reg_t pp_on;\n\ti915_reg_t pp_off;\n\ti915_reg_t pp_div;\n};\n\nstatic void intel_pps_get_registers(struct intel_dp *intel_dp,\n\t\t\t\t    struct pps_registers *regs)\n{\n\tstruct drm_i915_private *dev_priv = dp_to_i915(intel_dp);\n\tint pps_idx;\n\n\tmemset(regs, 0, sizeof(*regs));\n\n\tif (IS_VALLEYVIEW(dev_priv) || IS_CHERRYVIEW(dev_priv))\n\t\tpps_idx = vlv_power_sequencer_pipe(intel_dp);\n\telse if (IS_GEMINILAKE(dev_priv) || IS_BROXTON(dev_priv))\n\t\tpps_idx = bxt_power_sequencer_idx(intel_dp);\n\telse\n\t\tpps_idx = intel_dp->pps.pps_idx;\n\n\tregs->pp_ctrl = PP_CONTROL(pps_idx);\n\tregs->pp_stat = PP_STATUS(pps_idx);\n\tregs->pp_on = PP_ON_DELAYS(pps_idx);\n\tregs->pp_off = PP_OFF_DELAYS(pps_idx);\n\n\t \n\tif (IS_GEMINILAKE(dev_priv) || IS_BROXTON(dev_priv) ||\n\t    INTEL_PCH_TYPE(dev_priv) >= PCH_CNP)\n\t\tregs->pp_div = INVALID_MMIO_REG;\n\telse\n\t\tregs->pp_div = PP_DIVISOR(pps_idx);\n}\n\nstatic i915_reg_t\n_pp_ctrl_reg(struct intel_dp *intel_dp)\n{\n\tstruct pps_registers regs;\n\n\tintel_pps_get_registers(intel_dp, &regs);\n\n\treturn regs.pp_ctrl;\n}\n\nstatic i915_reg_t\n_pp_stat_reg(struct intel_dp *intel_dp)\n{\n\tstruct pps_registers regs;\n\n\tintel_pps_get_registers(intel_dp, &regs);\n\n\treturn regs.pp_stat;\n}\n\nstatic bool edp_have_panel_power(struct intel_dp *intel_dp)\n{\n\tstruct drm_i915_private *dev_priv = dp_to_i915(intel_dp);\n\n\tlockdep_assert_held(&dev_priv->display.pps.mutex);\n\n\tif ((IS_VALLEYVIEW(dev_priv) || IS_CHERRYVIEW(dev_priv)) &&\n\t    intel_dp->pps.pps_pipe == INVALID_PIPE)\n\t\treturn false;\n\n\treturn (intel_de_read(dev_priv, _pp_stat_reg(intel_dp)) & PP_ON) != 0;\n}\n\nstatic bool edp_have_panel_vdd(struct intel_dp *intel_dp)\n{\n\tstruct drm_i915_private *dev_priv = dp_to_i915(intel_dp);\n\n\tlockdep_assert_held(&dev_priv->display.pps.mutex);\n\n\tif ((IS_VALLEYVIEW(dev_priv) || IS_CHERRYVIEW(dev_priv)) &&\n\t    intel_dp->pps.pps_pipe == INVALID_PIPE)\n\t\treturn false;\n\n\treturn intel_de_read(dev_priv, _pp_ctrl_reg(intel_dp)) & EDP_FORCE_VDD;\n}\n\nvoid intel_pps_check_power_unlocked(struct intel_dp *intel_dp)\n{\n\tstruct drm_i915_private *dev_priv = dp_to_i915(intel_dp);\n\tstruct intel_digital_port *dig_port = dp_to_dig_port(intel_dp);\n\n\tif (!intel_dp_is_edp(intel_dp))\n\t\treturn;\n\n\tif (!edp_have_panel_power(intel_dp) && !edp_have_panel_vdd(intel_dp)) {\n\t\tdrm_WARN(&dev_priv->drm, 1,\n\t\t\t \"[ENCODER:%d:%s] %s powered off while attempting AUX CH communication.\\n\",\n\t\t\t dig_port->base.base.base.id, dig_port->base.base.name,\n\t\t\t pps_name(dev_priv, &intel_dp->pps));\n\t\tdrm_dbg_kms(&dev_priv->drm,\n\t\t\t    \"[ENCODER:%d:%s] %s PP_STATUS: 0x%08x PP_CONTROL: 0x%08x\\n\",\n\t\t\t    dig_port->base.base.base.id, dig_port->base.base.name,\n\t\t\t    pps_name(dev_priv, &intel_dp->pps),\n\t\t\t    intel_de_read(dev_priv, _pp_stat_reg(intel_dp)),\n\t\t\t    intel_de_read(dev_priv, _pp_ctrl_reg(intel_dp)));\n\t}\n}\n\n#define IDLE_ON_MASK\t\t(PP_ON | PP_SEQUENCE_MASK | 0                     | PP_SEQUENCE_STATE_MASK)\n#define IDLE_ON_VALUE\t\t(PP_ON | PP_SEQUENCE_NONE | 0                     | PP_SEQUENCE_STATE_ON_IDLE)\n\n#define IDLE_OFF_MASK\t\t(PP_ON | PP_SEQUENCE_MASK | 0                     | 0)\n#define IDLE_OFF_VALUE\t\t(0     | PP_SEQUENCE_NONE | 0                     | 0)\n\n#define IDLE_CYCLE_MASK\t\t(PP_ON | PP_SEQUENCE_MASK | PP_CYCLE_DELAY_ACTIVE | PP_SEQUENCE_STATE_MASK)\n#define IDLE_CYCLE_VALUE\t(0     | PP_SEQUENCE_NONE | 0                     | PP_SEQUENCE_STATE_OFF_IDLE)\n\nstatic void intel_pps_verify_state(struct intel_dp *intel_dp);\n\nstatic void wait_panel_status(struct intel_dp *intel_dp,\n\t\t\t      u32 mask, u32 value)\n{\n\tstruct drm_i915_private *dev_priv = dp_to_i915(intel_dp);\n\tstruct intel_digital_port *dig_port = dp_to_dig_port(intel_dp);\n\ti915_reg_t pp_stat_reg, pp_ctrl_reg;\n\n\tlockdep_assert_held(&dev_priv->display.pps.mutex);\n\n\tintel_pps_verify_state(intel_dp);\n\n\tpp_stat_reg = _pp_stat_reg(intel_dp);\n\tpp_ctrl_reg = _pp_ctrl_reg(intel_dp);\n\n\tdrm_dbg_kms(&dev_priv->drm,\n\t\t    \"[ENCODER:%d:%s] %s mask: 0x%08x value: 0x%08x PP_STATUS: 0x%08x PP_CONTROL: 0x%08x\\n\",\n\t\t    dig_port->base.base.base.id, dig_port->base.base.name,\n\t\t    pps_name(dev_priv, &intel_dp->pps),\n\t\t    mask, value,\n\t\t    intel_de_read(dev_priv, pp_stat_reg),\n\t\t    intel_de_read(dev_priv, pp_ctrl_reg));\n\n\tif (intel_de_wait_for_register(dev_priv, pp_stat_reg,\n\t\t\t\t       mask, value, 5000))\n\t\tdrm_err(&dev_priv->drm,\n\t\t\t\"[ENCODER:%d:%s] %s panel status timeout: PP_STATUS: 0x%08x PP_CONTROL: 0x%08x\\n\",\n\t\t\tdig_port->base.base.base.id, dig_port->base.base.name,\n\t\t\tpps_name(dev_priv, &intel_dp->pps),\n\t\t\tintel_de_read(dev_priv, pp_stat_reg),\n\t\t\tintel_de_read(dev_priv, pp_ctrl_reg));\n\n\tdrm_dbg_kms(&dev_priv->drm, \"Wait complete\\n\");\n}\n\nstatic void wait_panel_on(struct intel_dp *intel_dp)\n{\n\tstruct drm_i915_private *i915 = dp_to_i915(intel_dp);\n\tstruct intel_digital_port *dig_port = dp_to_dig_port(intel_dp);\n\n\tdrm_dbg_kms(&i915->drm, \"[ENCODER:%d:%s] %s wait for panel power on\\n\",\n\t\t    dig_port->base.base.base.id, dig_port->base.base.name,\n\t\t    pps_name(i915, &intel_dp->pps));\n\twait_panel_status(intel_dp, IDLE_ON_MASK, IDLE_ON_VALUE);\n}\n\nstatic void wait_panel_off(struct intel_dp *intel_dp)\n{\n\tstruct drm_i915_private *i915 = dp_to_i915(intel_dp);\n\tstruct intel_digital_port *dig_port = dp_to_dig_port(intel_dp);\n\n\tdrm_dbg_kms(&i915->drm, \"[ENCODER:%d:%s] %s wait for panel power off time\\n\",\n\t\t    dig_port->base.base.base.id, dig_port->base.base.name,\n\t\t    pps_name(i915, &intel_dp->pps));\n\twait_panel_status(intel_dp, IDLE_OFF_MASK, IDLE_OFF_VALUE);\n}\n\nstatic void wait_panel_power_cycle(struct intel_dp *intel_dp)\n{\n\tstruct drm_i915_private *i915 = dp_to_i915(intel_dp);\n\tstruct intel_digital_port *dig_port = dp_to_dig_port(intel_dp);\n\tktime_t panel_power_on_time;\n\ts64 panel_power_off_duration;\n\n\tdrm_dbg_kms(&i915->drm, \"[ENCODER:%d:%s] %s wait for panel power cycle\\n\",\n\t\t    dig_port->base.base.base.id, dig_port->base.base.name,\n\t\t    pps_name(i915, &intel_dp->pps));\n\n\t \n\tpanel_power_on_time = ktime_get_boottime();\n\tpanel_power_off_duration = ktime_ms_delta(panel_power_on_time, intel_dp->pps.panel_power_off_time);\n\n\t \n\tif (panel_power_off_duration < (s64)intel_dp->pps.panel_power_cycle_delay)\n\t\twait_remaining_ms_from_jiffies(jiffies,\n\t\t\t\t       intel_dp->pps.panel_power_cycle_delay - panel_power_off_duration);\n\n\twait_panel_status(intel_dp, IDLE_CYCLE_MASK, IDLE_CYCLE_VALUE);\n}\n\nvoid intel_pps_wait_power_cycle(struct intel_dp *intel_dp)\n{\n\tintel_wakeref_t wakeref;\n\n\tif (!intel_dp_is_edp(intel_dp))\n\t\treturn;\n\n\twith_intel_pps_lock(intel_dp, wakeref)\n\t\twait_panel_power_cycle(intel_dp);\n}\n\nstatic void wait_backlight_on(struct intel_dp *intel_dp)\n{\n\twait_remaining_ms_from_jiffies(intel_dp->pps.last_power_on,\n\t\t\t\t       intel_dp->pps.backlight_on_delay);\n}\n\nstatic void edp_wait_backlight_off(struct intel_dp *intel_dp)\n{\n\twait_remaining_ms_from_jiffies(intel_dp->pps.last_backlight_off,\n\t\t\t\t       intel_dp->pps.backlight_off_delay);\n}\n\n \n\nstatic  u32 ilk_get_pp_control(struct intel_dp *intel_dp)\n{\n\tstruct drm_i915_private *dev_priv = dp_to_i915(intel_dp);\n\tu32 control;\n\n\tlockdep_assert_held(&dev_priv->display.pps.mutex);\n\n\tcontrol = intel_de_read(dev_priv, _pp_ctrl_reg(intel_dp));\n\tif (drm_WARN_ON(&dev_priv->drm, !HAS_DDI(dev_priv) &&\n\t\t\t(control & PANEL_UNLOCK_MASK) != PANEL_UNLOCK_REGS)) {\n\t\tcontrol &= ~PANEL_UNLOCK_MASK;\n\t\tcontrol |= PANEL_UNLOCK_REGS;\n\t}\n\treturn control;\n}\n\n \nbool intel_pps_vdd_on_unlocked(struct intel_dp *intel_dp)\n{\n\tstruct drm_i915_private *dev_priv = dp_to_i915(intel_dp);\n\tstruct intel_digital_port *dig_port = dp_to_dig_port(intel_dp);\n\tu32 pp;\n\ti915_reg_t pp_stat_reg, pp_ctrl_reg;\n\tbool need_to_disable = !intel_dp->pps.want_panel_vdd;\n\n\tlockdep_assert_held(&dev_priv->display.pps.mutex);\n\n\tif (!intel_dp_is_edp(intel_dp))\n\t\treturn false;\n\n\tcancel_delayed_work(&intel_dp->pps.panel_vdd_work);\n\tintel_dp->pps.want_panel_vdd = true;\n\n\tif (edp_have_panel_vdd(intel_dp))\n\t\treturn need_to_disable;\n\n\tdrm_WARN_ON(&dev_priv->drm, intel_dp->pps.vdd_wakeref);\n\tintel_dp->pps.vdd_wakeref = intel_display_power_get(dev_priv,\n\t\t\t\t\t\t\t    intel_aux_power_domain(dig_port));\n\n\tpp_stat_reg = _pp_stat_reg(intel_dp);\n\tpp_ctrl_reg = _pp_ctrl_reg(intel_dp);\n\n\tdrm_dbg_kms(&dev_priv->drm, \"[ENCODER:%d:%s] %s turning VDD on\\n\",\n\t\t    dig_port->base.base.base.id, dig_port->base.base.name,\n\t\t    pps_name(dev_priv, &intel_dp->pps));\n\n\tif (!edp_have_panel_power(intel_dp))\n\t\twait_panel_power_cycle(intel_dp);\n\n\tpp = ilk_get_pp_control(intel_dp);\n\tpp |= EDP_FORCE_VDD;\n\n\tintel_de_write(dev_priv, pp_ctrl_reg, pp);\n\tintel_de_posting_read(dev_priv, pp_ctrl_reg);\n\tdrm_dbg_kms(&dev_priv->drm, \"[ENCODER:%d:%s] %s PP_STATUS: 0x%08x PP_CONTROL: 0x%08x\\n\",\n\t\t    dig_port->base.base.base.id, dig_port->base.base.name,\n\t\t    pps_name(dev_priv, &intel_dp->pps),\n\t\t    intel_de_read(dev_priv, pp_stat_reg),\n\t\t    intel_de_read(dev_priv, pp_ctrl_reg));\n\t \n\tif (!edp_have_panel_power(intel_dp)) {\n\t\tdrm_dbg_kms(&dev_priv->drm,\n\t\t\t    \"[ENCODER:%d:%s] %s panel power wasn't enabled\\n\",\n\t\t\t    dig_port->base.base.base.id, dig_port->base.base.name,\n\t\t\t    pps_name(dev_priv, &intel_dp->pps));\n\t\tmsleep(intel_dp->pps.panel_power_up_delay);\n\t}\n\n\treturn need_to_disable;\n}\n\n \nvoid intel_pps_vdd_on(struct intel_dp *intel_dp)\n{\n\tstruct drm_i915_private *i915 = dp_to_i915(intel_dp);\n\tintel_wakeref_t wakeref;\n\tbool vdd;\n\n\tif (!intel_dp_is_edp(intel_dp))\n\t\treturn;\n\n\tvdd = false;\n\twith_intel_pps_lock(intel_dp, wakeref)\n\t\tvdd = intel_pps_vdd_on_unlocked(intel_dp);\n\tI915_STATE_WARN(i915, !vdd, \"[ENCODER:%d:%s] %s VDD already requested on\\n\",\n\t\t\tdp_to_dig_port(intel_dp)->base.base.base.id,\n\t\t\tdp_to_dig_port(intel_dp)->base.base.name,\n\t\t\tpps_name(i915, &intel_dp->pps));\n}\n\nstatic void intel_pps_vdd_off_sync_unlocked(struct intel_dp *intel_dp)\n{\n\tstruct drm_i915_private *dev_priv = dp_to_i915(intel_dp);\n\tstruct intel_digital_port *dig_port =\n\t\tdp_to_dig_port(intel_dp);\n\tu32 pp;\n\ti915_reg_t pp_stat_reg, pp_ctrl_reg;\n\n\tlockdep_assert_held(&dev_priv->display.pps.mutex);\n\n\tdrm_WARN_ON(&dev_priv->drm, intel_dp->pps.want_panel_vdd);\n\n\tif (!edp_have_panel_vdd(intel_dp))\n\t\treturn;\n\n\tdrm_dbg_kms(&dev_priv->drm, \"[ENCODER:%d:%s] %s turning VDD off\\n\",\n\t\t    dig_port->base.base.base.id, dig_port->base.base.name,\n\t\t    pps_name(dev_priv, &intel_dp->pps));\n\n\tpp = ilk_get_pp_control(intel_dp);\n\tpp &= ~EDP_FORCE_VDD;\n\n\tpp_ctrl_reg = _pp_ctrl_reg(intel_dp);\n\tpp_stat_reg = _pp_stat_reg(intel_dp);\n\n\tintel_de_write(dev_priv, pp_ctrl_reg, pp);\n\tintel_de_posting_read(dev_priv, pp_ctrl_reg);\n\n\t \n\tdrm_dbg_kms(&dev_priv->drm, \"[ENCODER:%d:%s] %s PP_STATUS: 0x%08x PP_CONTROL: 0x%08x\\n\",\n\t\t    dig_port->base.base.base.id, dig_port->base.base.name,\n\t\t    pps_name(dev_priv, &intel_dp->pps),\n\t\t    intel_de_read(dev_priv, pp_stat_reg),\n\t\t    intel_de_read(dev_priv, pp_ctrl_reg));\n\n\tif ((pp & PANEL_POWER_ON) == 0)\n\t\tintel_dp->pps.panel_power_off_time = ktime_get_boottime();\n\n\tintel_display_power_put(dev_priv,\n\t\t\t\tintel_aux_power_domain(dig_port),\n\t\t\t\tfetch_and_zero(&intel_dp->pps.vdd_wakeref));\n}\n\nvoid intel_pps_vdd_off_sync(struct intel_dp *intel_dp)\n{\n\tintel_wakeref_t wakeref;\n\n\tif (!intel_dp_is_edp(intel_dp))\n\t\treturn;\n\n\tcancel_delayed_work_sync(&intel_dp->pps.panel_vdd_work);\n\t \n\twith_intel_pps_lock(intel_dp, wakeref)\n\t\tintel_pps_vdd_off_sync_unlocked(intel_dp);\n}\n\nstatic void edp_panel_vdd_work(struct work_struct *__work)\n{\n\tstruct intel_pps *pps = container_of(to_delayed_work(__work),\n\t\t\t\t\t     struct intel_pps, panel_vdd_work);\n\tstruct intel_dp *intel_dp = container_of(pps, struct intel_dp, pps);\n\tintel_wakeref_t wakeref;\n\n\twith_intel_pps_lock(intel_dp, wakeref) {\n\t\tif (!intel_dp->pps.want_panel_vdd)\n\t\t\tintel_pps_vdd_off_sync_unlocked(intel_dp);\n\t}\n}\n\nstatic void edp_panel_vdd_schedule_off(struct intel_dp *intel_dp)\n{\n\tstruct drm_i915_private *i915 = dp_to_i915(intel_dp);\n\tunsigned long delay;\n\n\t \n\tif (intel_dp->pps.initializing)\n\t\treturn;\n\n\t \n\tdelay = msecs_to_jiffies(intel_dp->pps.panel_power_cycle_delay * 5);\n\tqueue_delayed_work(i915->unordered_wq,\n\t\t\t   &intel_dp->pps.panel_vdd_work, delay);\n}\n\n \nvoid intel_pps_vdd_off_unlocked(struct intel_dp *intel_dp, bool sync)\n{\n\tstruct drm_i915_private *dev_priv = dp_to_i915(intel_dp);\n\n\tlockdep_assert_held(&dev_priv->display.pps.mutex);\n\n\tif (!intel_dp_is_edp(intel_dp))\n\t\treturn;\n\n\tI915_STATE_WARN(dev_priv, !intel_dp->pps.want_panel_vdd,\n\t\t\t\"[ENCODER:%d:%s] %s VDD not forced on\",\n\t\t\tdp_to_dig_port(intel_dp)->base.base.base.id,\n\t\t\tdp_to_dig_port(intel_dp)->base.base.name,\n\t\t\tpps_name(dev_priv, &intel_dp->pps));\n\n\tintel_dp->pps.want_panel_vdd = false;\n\n\tif (sync)\n\t\tintel_pps_vdd_off_sync_unlocked(intel_dp);\n\telse\n\t\tedp_panel_vdd_schedule_off(intel_dp);\n}\n\nvoid intel_pps_on_unlocked(struct intel_dp *intel_dp)\n{\n\tstruct drm_i915_private *dev_priv = dp_to_i915(intel_dp);\n\tu32 pp;\n\ti915_reg_t pp_ctrl_reg;\n\n\tlockdep_assert_held(&dev_priv->display.pps.mutex);\n\n\tif (!intel_dp_is_edp(intel_dp))\n\t\treturn;\n\n\tdrm_dbg_kms(&dev_priv->drm, \"[ENCODER:%d:%s] %s turn panel power on\\n\",\n\t\t    dp_to_dig_port(intel_dp)->base.base.base.id,\n\t\t    dp_to_dig_port(intel_dp)->base.base.name,\n\t\t    pps_name(dev_priv, &intel_dp->pps));\n\n\tif (drm_WARN(&dev_priv->drm, edp_have_panel_power(intel_dp),\n\t\t     \"[ENCODER:%d:%s] %s panel power already on\\n\",\n\t\t     dp_to_dig_port(intel_dp)->base.base.base.id,\n\t\t     dp_to_dig_port(intel_dp)->base.base.name,\n\t\t     pps_name(dev_priv, &intel_dp->pps)))\n\t\treturn;\n\n\twait_panel_power_cycle(intel_dp);\n\n\tpp_ctrl_reg = _pp_ctrl_reg(intel_dp);\n\tpp = ilk_get_pp_control(intel_dp);\n\tif (IS_IRONLAKE(dev_priv)) {\n\t\t \n\t\tpp &= ~PANEL_POWER_RESET;\n\t\tintel_de_write(dev_priv, pp_ctrl_reg, pp);\n\t\tintel_de_posting_read(dev_priv, pp_ctrl_reg);\n\t}\n\n\tpp |= PANEL_POWER_ON;\n\tif (!IS_IRONLAKE(dev_priv))\n\t\tpp |= PANEL_POWER_RESET;\n\n\tintel_de_write(dev_priv, pp_ctrl_reg, pp);\n\tintel_de_posting_read(dev_priv, pp_ctrl_reg);\n\n\twait_panel_on(intel_dp);\n\tintel_dp->pps.last_power_on = jiffies;\n\n\tif (IS_IRONLAKE(dev_priv)) {\n\t\tpp |= PANEL_POWER_RESET;  \n\t\tintel_de_write(dev_priv, pp_ctrl_reg, pp);\n\t\tintel_de_posting_read(dev_priv, pp_ctrl_reg);\n\t}\n}\n\nvoid intel_pps_on(struct intel_dp *intel_dp)\n{\n\tintel_wakeref_t wakeref;\n\n\tif (!intel_dp_is_edp(intel_dp))\n\t\treturn;\n\n\twith_intel_pps_lock(intel_dp, wakeref)\n\t\tintel_pps_on_unlocked(intel_dp);\n}\n\nvoid intel_pps_off_unlocked(struct intel_dp *intel_dp)\n{\n\tstruct drm_i915_private *dev_priv = dp_to_i915(intel_dp);\n\tstruct intel_digital_port *dig_port = dp_to_dig_port(intel_dp);\n\tu32 pp;\n\ti915_reg_t pp_ctrl_reg;\n\n\tlockdep_assert_held(&dev_priv->display.pps.mutex);\n\n\tif (!intel_dp_is_edp(intel_dp))\n\t\treturn;\n\n\tdrm_dbg_kms(&dev_priv->drm, \"[ENCODER:%d:%s] %s turn panel power off\\n\",\n\t\t    dig_port->base.base.base.id, dig_port->base.base.name,\n\t\t    pps_name(dev_priv, &intel_dp->pps));\n\n\tdrm_WARN(&dev_priv->drm, !intel_dp->pps.want_panel_vdd,\n\t\t \"[ENCODER:%d:%s] %s need VDD to turn off panel\\n\",\n\t\t dig_port->base.base.base.id, dig_port->base.base.name,\n\t\t pps_name(dev_priv, &intel_dp->pps));\n\n\tpp = ilk_get_pp_control(intel_dp);\n\t \n\tpp &= ~(PANEL_POWER_ON | PANEL_POWER_RESET | EDP_FORCE_VDD |\n\t\tEDP_BLC_ENABLE);\n\n\tpp_ctrl_reg = _pp_ctrl_reg(intel_dp);\n\n\tintel_dp->pps.want_panel_vdd = false;\n\n\tintel_de_write(dev_priv, pp_ctrl_reg, pp);\n\tintel_de_posting_read(dev_priv, pp_ctrl_reg);\n\n\twait_panel_off(intel_dp);\n\tintel_dp->pps.panel_power_off_time = ktime_get_boottime();\n\n\t \n\tintel_display_power_put(dev_priv,\n\t\t\t\tintel_aux_power_domain(dig_port),\n\t\t\t\tfetch_and_zero(&intel_dp->pps.vdd_wakeref));\n}\n\nvoid intel_pps_off(struct intel_dp *intel_dp)\n{\n\tintel_wakeref_t wakeref;\n\n\tif (!intel_dp_is_edp(intel_dp))\n\t\treturn;\n\n\twith_intel_pps_lock(intel_dp, wakeref)\n\t\tintel_pps_off_unlocked(intel_dp);\n}\n\n \nvoid intel_pps_backlight_on(struct intel_dp *intel_dp)\n{\n\tstruct drm_i915_private *dev_priv = dp_to_i915(intel_dp);\n\tintel_wakeref_t wakeref;\n\n\t \n\twait_backlight_on(intel_dp);\n\n\twith_intel_pps_lock(intel_dp, wakeref) {\n\t\ti915_reg_t pp_ctrl_reg = _pp_ctrl_reg(intel_dp);\n\t\tu32 pp;\n\n\t\tpp = ilk_get_pp_control(intel_dp);\n\t\tpp |= EDP_BLC_ENABLE;\n\n\t\tintel_de_write(dev_priv, pp_ctrl_reg, pp);\n\t\tintel_de_posting_read(dev_priv, pp_ctrl_reg);\n\t}\n}\n\n \nvoid intel_pps_backlight_off(struct intel_dp *intel_dp)\n{\n\tstruct drm_i915_private *dev_priv = dp_to_i915(intel_dp);\n\tintel_wakeref_t wakeref;\n\n\tif (!intel_dp_is_edp(intel_dp))\n\t\treturn;\n\n\twith_intel_pps_lock(intel_dp, wakeref) {\n\t\ti915_reg_t pp_ctrl_reg = _pp_ctrl_reg(intel_dp);\n\t\tu32 pp;\n\n\t\tpp = ilk_get_pp_control(intel_dp);\n\t\tpp &= ~EDP_BLC_ENABLE;\n\n\t\tintel_de_write(dev_priv, pp_ctrl_reg, pp);\n\t\tintel_de_posting_read(dev_priv, pp_ctrl_reg);\n\t}\n\n\tintel_dp->pps.last_backlight_off = jiffies;\n\tedp_wait_backlight_off(intel_dp);\n}\n\n \nvoid intel_pps_backlight_power(struct intel_connector *connector, bool enable)\n{\n\tstruct drm_i915_private *i915 = to_i915(connector->base.dev);\n\tstruct intel_dp *intel_dp = intel_attached_dp(connector);\n\tintel_wakeref_t wakeref;\n\tbool is_enabled;\n\n\tis_enabled = false;\n\twith_intel_pps_lock(intel_dp, wakeref)\n\t\tis_enabled = ilk_get_pp_control(intel_dp) & EDP_BLC_ENABLE;\n\tif (is_enabled == enable)\n\t\treturn;\n\n\tdrm_dbg_kms(&i915->drm, \"panel power control backlight %s\\n\",\n\t\t    enable ? \"enable\" : \"disable\");\n\n\tif (enable)\n\t\tintel_pps_backlight_on(intel_dp);\n\telse\n\t\tintel_pps_backlight_off(intel_dp);\n}\n\nstatic void vlv_detach_power_sequencer(struct intel_dp *intel_dp)\n{\n\tstruct intel_digital_port *dig_port = dp_to_dig_port(intel_dp);\n\tstruct drm_i915_private *dev_priv = to_i915(dig_port->base.base.dev);\n\tenum pipe pipe = intel_dp->pps.pps_pipe;\n\ti915_reg_t pp_on_reg = PP_ON_DELAYS(pipe);\n\n\tdrm_WARN_ON(&dev_priv->drm, intel_dp->pps.active_pipe != INVALID_PIPE);\n\n\tif (drm_WARN_ON(&dev_priv->drm, pipe != PIPE_A && pipe != PIPE_B))\n\t\treturn;\n\n\tintel_pps_vdd_off_sync_unlocked(intel_dp);\n\n\t \n\tdrm_dbg_kms(&dev_priv->drm,\n\t\t    \"detaching %s from [ENCODER:%d:%s]\\n\",\n\t\t    pps_name(dev_priv, &intel_dp->pps),\n\t\t    dig_port->base.base.base.id, dig_port->base.base.name);\n\tintel_de_write(dev_priv, pp_on_reg, 0);\n\tintel_de_posting_read(dev_priv, pp_on_reg);\n\n\tintel_dp->pps.pps_pipe = INVALID_PIPE;\n}\n\nstatic void vlv_steal_power_sequencer(struct drm_i915_private *dev_priv,\n\t\t\t\t      enum pipe pipe)\n{\n\tstruct intel_encoder *encoder;\n\n\tlockdep_assert_held(&dev_priv->display.pps.mutex);\n\n\tfor_each_intel_dp(&dev_priv->drm, encoder) {\n\t\tstruct intel_dp *intel_dp = enc_to_intel_dp(encoder);\n\n\t\tdrm_WARN(&dev_priv->drm, intel_dp->pps.active_pipe == pipe,\n\t\t\t \"stealing PPS %c from active [ENCODER:%d:%s]\\n\",\n\t\t\t pipe_name(pipe), encoder->base.base.id,\n\t\t\t encoder->base.name);\n\n\t\tif (intel_dp->pps.pps_pipe != pipe)\n\t\t\tcontinue;\n\n\t\tdrm_dbg_kms(&dev_priv->drm,\n\t\t\t    \"stealing PPS %c from [ENCODER:%d:%s]\\n\",\n\t\t\t    pipe_name(pipe), encoder->base.base.id,\n\t\t\t    encoder->base.name);\n\n\t\t \n\t\tvlv_detach_power_sequencer(intel_dp);\n\t}\n}\n\nvoid vlv_pps_init(struct intel_encoder *encoder,\n\t\t  const struct intel_crtc_state *crtc_state)\n{\n\tstruct drm_i915_private *dev_priv = to_i915(encoder->base.dev);\n\tstruct intel_dp *intel_dp = enc_to_intel_dp(encoder);\n\tstruct intel_crtc *crtc = to_intel_crtc(crtc_state->uapi.crtc);\n\n\tlockdep_assert_held(&dev_priv->display.pps.mutex);\n\n\tdrm_WARN_ON(&dev_priv->drm, intel_dp->pps.active_pipe != INVALID_PIPE);\n\n\tif (intel_dp->pps.pps_pipe != INVALID_PIPE &&\n\t    intel_dp->pps.pps_pipe != crtc->pipe) {\n\t\t \n\t\tvlv_detach_power_sequencer(intel_dp);\n\t}\n\n\t \n\tvlv_steal_power_sequencer(dev_priv, crtc->pipe);\n\n\tintel_dp->pps.active_pipe = crtc->pipe;\n\n\tif (!intel_dp_is_edp(intel_dp))\n\t\treturn;\n\n\t \n\tintel_dp->pps.pps_pipe = crtc->pipe;\n\n\tdrm_dbg_kms(&dev_priv->drm,\n\t\t    \"initializing %s for [ENCODER:%d:%s]\\n\",\n\t\t    pps_name(dev_priv, &intel_dp->pps),\n\t\t    encoder->base.base.id, encoder->base.name);\n\n\t \n\tpps_init_delays(intel_dp);\n\tpps_init_registers(intel_dp, true);\n}\n\nstatic void pps_vdd_init(struct intel_dp *intel_dp)\n{\n\tstruct drm_i915_private *dev_priv = dp_to_i915(intel_dp);\n\tstruct intel_digital_port *dig_port = dp_to_dig_port(intel_dp);\n\n\tlockdep_assert_held(&dev_priv->display.pps.mutex);\n\n\tif (!edp_have_panel_vdd(intel_dp))\n\t\treturn;\n\n\t \n\tdrm_dbg_kms(&dev_priv->drm,\n\t\t    \"[ENCODER:%d:%s] %s VDD left on by BIOS, adjusting state tracking\\n\",\n\t\t    dig_port->base.base.base.id, dig_port->base.base.name,\n\t\t    pps_name(dev_priv, &intel_dp->pps));\n\tdrm_WARN_ON(&dev_priv->drm, intel_dp->pps.vdd_wakeref);\n\tintel_dp->pps.vdd_wakeref = intel_display_power_get(dev_priv,\n\t\t\t\t\t\t\t    intel_aux_power_domain(dig_port));\n}\n\nbool intel_pps_have_panel_power_or_vdd(struct intel_dp *intel_dp)\n{\n\tintel_wakeref_t wakeref;\n\tbool have_power = false;\n\n\twith_intel_pps_lock(intel_dp, wakeref) {\n\t\thave_power = edp_have_panel_power(intel_dp) ||\n\t\t\t     edp_have_panel_vdd(intel_dp);\n\t}\n\n\treturn have_power;\n}\n\nstatic void pps_init_timestamps(struct intel_dp *intel_dp)\n{\n\t \n\tintel_dp->pps.panel_power_off_time = 0;\n\tintel_dp->pps.last_power_on = jiffies;\n\tintel_dp->pps.last_backlight_off = jiffies;\n}\n\nstatic void\nintel_pps_readout_hw_state(struct intel_dp *intel_dp, struct edp_power_seq *seq)\n{\n\tstruct drm_i915_private *dev_priv = dp_to_i915(intel_dp);\n\tu32 pp_on, pp_off, pp_ctl;\n\tstruct pps_registers regs;\n\n\tintel_pps_get_registers(intel_dp, &regs);\n\n\tpp_ctl = ilk_get_pp_control(intel_dp);\n\n\t \n\tif (!HAS_DDI(dev_priv))\n\t\tintel_de_write(dev_priv, regs.pp_ctrl, pp_ctl);\n\n\tpp_on = intel_de_read(dev_priv, regs.pp_on);\n\tpp_off = intel_de_read(dev_priv, regs.pp_off);\n\n\t \n\tseq->t1_t3 = REG_FIELD_GET(PANEL_POWER_UP_DELAY_MASK, pp_on);\n\tseq->t8 = REG_FIELD_GET(PANEL_LIGHT_ON_DELAY_MASK, pp_on);\n\tseq->t9 = REG_FIELD_GET(PANEL_LIGHT_OFF_DELAY_MASK, pp_off);\n\tseq->t10 = REG_FIELD_GET(PANEL_POWER_DOWN_DELAY_MASK, pp_off);\n\n\tif (i915_mmio_reg_valid(regs.pp_div)) {\n\t\tu32 pp_div;\n\n\t\tpp_div = intel_de_read(dev_priv, regs.pp_div);\n\n\t\tseq->t11_t12 = REG_FIELD_GET(PANEL_POWER_CYCLE_DELAY_MASK, pp_div) * 1000;\n\t} else {\n\t\tseq->t11_t12 = REG_FIELD_GET(BXT_POWER_CYCLE_DELAY_MASK, pp_ctl) * 1000;\n\t}\n}\n\nstatic void\nintel_pps_dump_state(struct intel_dp *intel_dp, const char *state_name,\n\t\t     const struct edp_power_seq *seq)\n{\n\tstruct drm_i915_private *i915 = dp_to_i915(intel_dp);\n\n\tdrm_dbg_kms(&i915->drm, \"%s t1_t3 %d t8 %d t9 %d t10 %d t11_t12 %d\\n\",\n\t\t    state_name,\n\t\t    seq->t1_t3, seq->t8, seq->t9, seq->t10, seq->t11_t12);\n}\n\nstatic void\nintel_pps_verify_state(struct intel_dp *intel_dp)\n{\n\tstruct drm_i915_private *i915 = dp_to_i915(intel_dp);\n\tstruct edp_power_seq hw;\n\tstruct edp_power_seq *sw = &intel_dp->pps.pps_delays;\n\n\tintel_pps_readout_hw_state(intel_dp, &hw);\n\n\tif (hw.t1_t3 != sw->t1_t3 || hw.t8 != sw->t8 || hw.t9 != sw->t9 ||\n\t    hw.t10 != sw->t10 || hw.t11_t12 != sw->t11_t12) {\n\t\tdrm_err(&i915->drm, \"PPS state mismatch\\n\");\n\t\tintel_pps_dump_state(intel_dp, \"sw\", sw);\n\t\tintel_pps_dump_state(intel_dp, \"hw\", &hw);\n\t}\n}\n\nstatic bool pps_delays_valid(struct edp_power_seq *delays)\n{\n\treturn delays->t1_t3 || delays->t8 || delays->t9 ||\n\t\tdelays->t10 || delays->t11_t12;\n}\n\nstatic void pps_init_delays_bios(struct intel_dp *intel_dp,\n\t\t\t\t struct edp_power_seq *bios)\n{\n\tstruct drm_i915_private *dev_priv = dp_to_i915(intel_dp);\n\n\tlockdep_assert_held(&dev_priv->display.pps.mutex);\n\n\tif (!pps_delays_valid(&intel_dp->pps.bios_pps_delays))\n\t\tintel_pps_readout_hw_state(intel_dp, &intel_dp->pps.bios_pps_delays);\n\n\t*bios = intel_dp->pps.bios_pps_delays;\n\n\tintel_pps_dump_state(intel_dp, \"bios\", bios);\n}\n\nstatic void pps_init_delays_vbt(struct intel_dp *intel_dp,\n\t\t\t\tstruct edp_power_seq *vbt)\n{\n\tstruct drm_i915_private *dev_priv = dp_to_i915(intel_dp);\n\tstruct intel_connector *connector = intel_dp->attached_connector;\n\n\t*vbt = connector->panel.vbt.edp.pps;\n\n\tif (!pps_delays_valid(vbt))\n\t\treturn;\n\n\t \n\tif (intel_has_quirk(dev_priv, QUIRK_INCREASE_T12_DELAY)) {\n\t\tvbt->t11_t12 = max_t(u16, vbt->t11_t12, 1300 * 10);\n\t\tdrm_dbg_kms(&dev_priv->drm,\n\t\t\t    \"Increasing T12 panel delay as per the quirk to %d\\n\",\n\t\t\t    vbt->t11_t12);\n\t}\n\n\t \n\tvbt->t11_t12 += 100 * 10;\n\n\tintel_pps_dump_state(intel_dp, \"vbt\", vbt);\n}\n\nstatic void pps_init_delays_spec(struct intel_dp *intel_dp,\n\t\t\t\t struct edp_power_seq *spec)\n{\n\tstruct drm_i915_private *dev_priv = dp_to_i915(intel_dp);\n\n\tlockdep_assert_held(&dev_priv->display.pps.mutex);\n\n\t \n\tspec->t1_t3 = 210 * 10;\n\tspec->t8 = 50 * 10;  \n\tspec->t9 = 50 * 10;  \n\tspec->t10 = 500 * 10;\n\t \n\tspec->t11_t12 = (510 + 100) * 10;\n\n\tintel_pps_dump_state(intel_dp, \"spec\", spec);\n}\n\nstatic void pps_init_delays(struct intel_dp *intel_dp)\n{\n\tstruct drm_i915_private *dev_priv = dp_to_i915(intel_dp);\n\tstruct edp_power_seq cur, vbt, spec,\n\t\t*final = &intel_dp->pps.pps_delays;\n\n\tlockdep_assert_held(&dev_priv->display.pps.mutex);\n\n\t \n\tif (pps_delays_valid(final))\n\t\treturn;\n\n\tpps_init_delays_bios(intel_dp, &cur);\n\tpps_init_delays_vbt(intel_dp, &vbt);\n\tpps_init_delays_spec(intel_dp, &spec);\n\n\t \n#define assign_final(field)\tfinal->field = (max(cur.field, vbt.field) == 0 ? \\\n\t\t\t\t       spec.field : \\\n\t\t\t\t       max(cur.field, vbt.field))\n\tassign_final(t1_t3);\n\tassign_final(t8);\n\tassign_final(t9);\n\tassign_final(t10);\n\tassign_final(t11_t12);\n#undef assign_final\n\n#define get_delay(field)\t(DIV_ROUND_UP(final->field, 10))\n\tintel_dp->pps.panel_power_up_delay = get_delay(t1_t3);\n\tintel_dp->pps.backlight_on_delay = get_delay(t8);\n\tintel_dp->pps.backlight_off_delay = get_delay(t9);\n\tintel_dp->pps.panel_power_down_delay = get_delay(t10);\n\tintel_dp->pps.panel_power_cycle_delay = get_delay(t11_t12);\n#undef get_delay\n\n\tdrm_dbg_kms(&dev_priv->drm,\n\t\t    \"panel power up delay %d, power down delay %d, power cycle delay %d\\n\",\n\t\t    intel_dp->pps.panel_power_up_delay,\n\t\t    intel_dp->pps.panel_power_down_delay,\n\t\t    intel_dp->pps.panel_power_cycle_delay);\n\n\tdrm_dbg_kms(&dev_priv->drm, \"backlight on delay %d, off delay %d\\n\",\n\t\t    intel_dp->pps.backlight_on_delay,\n\t\t    intel_dp->pps.backlight_off_delay);\n\n\t \n\tfinal->t8 = 1;\n\tfinal->t9 = 1;\n\n\t \n\tfinal->t11_t12 = roundup(final->t11_t12, 100 * 10);\n}\n\nstatic void pps_init_registers(struct intel_dp *intel_dp, bool force_disable_vdd)\n{\n\tstruct drm_i915_private *dev_priv = dp_to_i915(intel_dp);\n\tu32 pp_on, pp_off, port_sel = 0;\n\tint div = RUNTIME_INFO(dev_priv)->rawclk_freq / 1000;\n\tstruct pps_registers regs;\n\tenum port port = dp_to_dig_port(intel_dp)->base.port;\n\tconst struct edp_power_seq *seq = &intel_dp->pps.pps_delays;\n\n\tlockdep_assert_held(&dev_priv->display.pps.mutex);\n\n\tintel_pps_get_registers(intel_dp, &regs);\n\n\t \n\tif (force_disable_vdd) {\n\t\tu32 pp = ilk_get_pp_control(intel_dp);\n\n\t\tdrm_WARN(&dev_priv->drm, pp & PANEL_POWER_ON,\n\t\t\t \"Panel power already on\\n\");\n\n\t\tif (pp & EDP_FORCE_VDD)\n\t\t\tdrm_dbg_kms(&dev_priv->drm,\n\t\t\t\t    \"VDD already on, disabling first\\n\");\n\n\t\tpp &= ~EDP_FORCE_VDD;\n\n\t\tintel_de_write(dev_priv, regs.pp_ctrl, pp);\n\t}\n\n\tpp_on = REG_FIELD_PREP(PANEL_POWER_UP_DELAY_MASK, seq->t1_t3) |\n\t\tREG_FIELD_PREP(PANEL_LIGHT_ON_DELAY_MASK, seq->t8);\n\tpp_off = REG_FIELD_PREP(PANEL_LIGHT_OFF_DELAY_MASK, seq->t9) |\n\t\tREG_FIELD_PREP(PANEL_POWER_DOWN_DELAY_MASK, seq->t10);\n\n\t \n\tif (IS_VALLEYVIEW(dev_priv) || IS_CHERRYVIEW(dev_priv)) {\n\t\tport_sel = PANEL_PORT_SELECT_VLV(port);\n\t} else if (HAS_PCH_IBX(dev_priv) || HAS_PCH_CPT(dev_priv)) {\n\t\tswitch (port) {\n\t\tcase PORT_A:\n\t\t\tport_sel = PANEL_PORT_SELECT_DPA;\n\t\t\tbreak;\n\t\tcase PORT_C:\n\t\t\tport_sel = PANEL_PORT_SELECT_DPC;\n\t\t\tbreak;\n\t\tcase PORT_D:\n\t\t\tport_sel = PANEL_PORT_SELECT_DPD;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tMISSING_CASE(port);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tpp_on |= port_sel;\n\n\tintel_de_write(dev_priv, regs.pp_on, pp_on);\n\tintel_de_write(dev_priv, regs.pp_off, pp_off);\n\n\t \n\tif (i915_mmio_reg_valid(regs.pp_div))\n\t\tintel_de_write(dev_priv, regs.pp_div,\n\t\t\t       REG_FIELD_PREP(PP_REFERENCE_DIVIDER_MASK, (100 * div) / 2 - 1) | REG_FIELD_PREP(PANEL_POWER_CYCLE_DELAY_MASK, DIV_ROUND_UP(seq->t11_t12, 1000)));\n\telse\n\t\tintel_de_rmw(dev_priv, regs.pp_ctrl, BXT_POWER_CYCLE_DELAY_MASK,\n\t\t\t     REG_FIELD_PREP(BXT_POWER_CYCLE_DELAY_MASK,\n\t\t\t\t\t    DIV_ROUND_UP(seq->t11_t12, 1000)));\n\n\tdrm_dbg_kms(&dev_priv->drm,\n\t\t    \"panel power sequencer register settings: PP_ON %#x, PP_OFF %#x, PP_DIV %#x\\n\",\n\t\t    intel_de_read(dev_priv, regs.pp_on),\n\t\t    intel_de_read(dev_priv, regs.pp_off),\n\t\t    i915_mmio_reg_valid(regs.pp_div) ?\n\t\t    intel_de_read(dev_priv, regs.pp_div) :\n\t\t    (intel_de_read(dev_priv, regs.pp_ctrl) & BXT_POWER_CYCLE_DELAY_MASK));\n}\n\nvoid intel_pps_encoder_reset(struct intel_dp *intel_dp)\n{\n\tstruct drm_i915_private *i915 = dp_to_i915(intel_dp);\n\tintel_wakeref_t wakeref;\n\n\tif (!intel_dp_is_edp(intel_dp))\n\t\treturn;\n\n\twith_intel_pps_lock(intel_dp, wakeref) {\n\t\t \n\t\tif (IS_VALLEYVIEW(i915) || IS_CHERRYVIEW(i915))\n\t\t\tvlv_initial_power_sequencer_setup(intel_dp);\n\n\t\tpps_init_delays(intel_dp);\n\t\tpps_init_registers(intel_dp, false);\n\t\tpps_vdd_init(intel_dp);\n\n\t\tif (edp_have_panel_vdd(intel_dp))\n\t\t\tedp_panel_vdd_schedule_off(intel_dp);\n\t}\n}\n\nbool intel_pps_init(struct intel_dp *intel_dp)\n{\n\tintel_wakeref_t wakeref;\n\tbool ret;\n\n\tintel_dp->pps.initializing = true;\n\tINIT_DELAYED_WORK(&intel_dp->pps.panel_vdd_work, edp_panel_vdd_work);\n\n\tpps_init_timestamps(intel_dp);\n\n\twith_intel_pps_lock(intel_dp, wakeref) {\n\t\tret = pps_initial_setup(intel_dp);\n\n\t\tpps_init_delays(intel_dp);\n\t\tpps_init_registers(intel_dp, false);\n\t\tpps_vdd_init(intel_dp);\n\t}\n\n\treturn ret;\n}\n\nstatic void pps_init_late(struct intel_dp *intel_dp)\n{\n\tstruct drm_i915_private *i915 = dp_to_i915(intel_dp);\n\tstruct intel_encoder *encoder = &dp_to_dig_port(intel_dp)->base;\n\tstruct intel_connector *connector = intel_dp->attached_connector;\n\n\tif (IS_VALLEYVIEW(i915) || IS_CHERRYVIEW(i915))\n\t\treturn;\n\n\tif (intel_num_pps(i915) < 2)\n\t\treturn;\n\n\tdrm_WARN(&i915->drm, connector->panel.vbt.backlight.controller >= 0 &&\n\t\t intel_dp->pps.pps_idx != connector->panel.vbt.backlight.controller,\n\t\t \"[ENCODER:%d:%s] power sequencer mismatch: %d (initial) vs. %d (VBT)\\n\",\n\t\t encoder->base.base.id, encoder->base.name,\n\t\t intel_dp->pps.pps_idx, connector->panel.vbt.backlight.controller);\n\n\tif (connector->panel.vbt.backlight.controller >= 0)\n\t\tintel_dp->pps.pps_idx = connector->panel.vbt.backlight.controller;\n}\n\nvoid intel_pps_init_late(struct intel_dp *intel_dp)\n{\n\tintel_wakeref_t wakeref;\n\n\twith_intel_pps_lock(intel_dp, wakeref) {\n\t\t \n\t\tpps_init_late(intel_dp);\n\n\t\tmemset(&intel_dp->pps.pps_delays, 0, sizeof(intel_dp->pps.pps_delays));\n\t\tpps_init_delays(intel_dp);\n\t\tpps_init_registers(intel_dp, false);\n\n\t\tintel_dp->pps.initializing = false;\n\n\t\tif (edp_have_panel_vdd(intel_dp))\n\t\t\tedp_panel_vdd_schedule_off(intel_dp);\n\t}\n}\n\nvoid intel_pps_unlock_regs_wa(struct drm_i915_private *dev_priv)\n{\n\tint pps_num;\n\tint pps_idx;\n\n\tif (!HAS_DISPLAY(dev_priv) || HAS_DDI(dev_priv))\n\t\treturn;\n\t \n\tpps_num = intel_num_pps(dev_priv);\n\n\tfor (pps_idx = 0; pps_idx < pps_num; pps_idx++)\n\t\tintel_de_rmw(dev_priv, PP_CONTROL(pps_idx),\n\t\t\t     PANEL_UNLOCK_MASK, PANEL_UNLOCK_REGS);\n}\n\nvoid intel_pps_setup(struct drm_i915_private *i915)\n{\n\tif (HAS_PCH_SPLIT(i915) || IS_GEMINILAKE(i915) || IS_BROXTON(i915))\n\t\ti915->display.pps.mmio_base = PCH_PPS_BASE;\n\telse if (IS_VALLEYVIEW(i915) || IS_CHERRYVIEW(i915))\n\t\ti915->display.pps.mmio_base = VLV_PPS_BASE;\n\telse\n\t\ti915->display.pps.mmio_base = PPS_BASE;\n}\n\nvoid assert_pps_unlocked(struct drm_i915_private *dev_priv, enum pipe pipe)\n{\n\ti915_reg_t pp_reg;\n\tu32 val;\n\tenum pipe panel_pipe = INVALID_PIPE;\n\tbool locked = true;\n\n\tif (drm_WARN_ON(&dev_priv->drm, HAS_DDI(dev_priv)))\n\t\treturn;\n\n\tif (HAS_PCH_SPLIT(dev_priv)) {\n\t\tu32 port_sel;\n\n\t\tpp_reg = PP_CONTROL(0);\n\t\tport_sel = intel_de_read(dev_priv, PP_ON_DELAYS(0)) & PANEL_PORT_SELECT_MASK;\n\n\t\tswitch (port_sel) {\n\t\tcase PANEL_PORT_SELECT_LVDS:\n\t\t\tintel_lvds_port_enabled(dev_priv, PCH_LVDS, &panel_pipe);\n\t\t\tbreak;\n\t\tcase PANEL_PORT_SELECT_DPA:\n\t\t\tg4x_dp_port_enabled(dev_priv, DP_A, PORT_A, &panel_pipe);\n\t\t\tbreak;\n\t\tcase PANEL_PORT_SELECT_DPC:\n\t\t\tg4x_dp_port_enabled(dev_priv, PCH_DP_C, PORT_C, &panel_pipe);\n\t\t\tbreak;\n\t\tcase PANEL_PORT_SELECT_DPD:\n\t\t\tg4x_dp_port_enabled(dev_priv, PCH_DP_D, PORT_D, &panel_pipe);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tMISSING_CASE(port_sel);\n\t\t\tbreak;\n\t\t}\n\t} else if (IS_VALLEYVIEW(dev_priv) || IS_CHERRYVIEW(dev_priv)) {\n\t\t \n\t\tpp_reg = PP_CONTROL(pipe);\n\t\tpanel_pipe = pipe;\n\t} else {\n\t\tu32 port_sel;\n\n\t\tpp_reg = PP_CONTROL(0);\n\t\tport_sel = intel_de_read(dev_priv, PP_ON_DELAYS(0)) & PANEL_PORT_SELECT_MASK;\n\n\t\tdrm_WARN_ON(&dev_priv->drm,\n\t\t\t    port_sel != PANEL_PORT_SELECT_LVDS);\n\t\tintel_lvds_port_enabled(dev_priv, LVDS, &panel_pipe);\n\t}\n\n\tval = intel_de_read(dev_priv, pp_reg);\n\tif (!(val & PANEL_POWER_ON) ||\n\t    ((val & PANEL_UNLOCK_MASK) == PANEL_UNLOCK_REGS))\n\t\tlocked = false;\n\n\tI915_STATE_WARN(dev_priv, panel_pipe == pipe && locked,\n\t\t\t\"panel assertion failure, pipe %c regs locked\\n\",\n\t\t\tpipe_name(pipe));\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}