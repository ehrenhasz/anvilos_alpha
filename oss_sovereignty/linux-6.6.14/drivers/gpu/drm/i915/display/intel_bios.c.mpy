{
  "module_name": "intel_bios.c",
  "hash_id": "2c697d8dc544f80fd767d4795adab4a8f6c39e2ec5a1b6d4eee1373433dfce79",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/i915/display/intel_bios.c",
  "human_readable_source": " \n\n#include <drm/display/drm_dp_helper.h>\n#include <drm/display/drm_dsc_helper.h>\n#include <drm/drm_edid.h>\n\n#include \"i915_drv.h\"\n#include \"i915_reg.h\"\n#include \"intel_display.h\"\n#include \"intel_display_types.h\"\n#include \"intel_gmbus.h\"\n\n#define _INTEL_BIOS_PRIVATE\n#include \"intel_vbt_defs.h\"\n\n \n\n \nstruct intel_bios_encoder_data {\n\tstruct drm_i915_private *i915;\n\n\tstruct child_device_config child;\n\tstruct dsc_compression_parameters_entry *dsc;\n\tstruct list_head node;\n};\n\n#define\tSLAVE_ADDR1\t0x70\n#define\tSLAVE_ADDR2\t0x72\n\n \nstatic u32 _get_blocksize(const u8 *block_base)\n{\n\t \n\tif (*block_base == BDB_MIPI_SEQUENCE && *(block_base + 3) >= 3)\n\t\treturn *((const u32 *)(block_base + 4));\n\telse\n\t\treturn *((const u16 *)(block_base + 1));\n}\n\n \nstatic u32 get_blocksize(const void *block_data)\n{\n\treturn _get_blocksize(block_data - 3);\n}\n\nstatic const void *\nfind_raw_section(const void *_bdb, enum bdb_block_id section_id)\n{\n\tconst struct bdb_header *bdb = _bdb;\n\tconst u8 *base = _bdb;\n\tint index = 0;\n\tu32 total, current_size;\n\tenum bdb_block_id current_id;\n\n\t \n\tindex += bdb->header_size;\n\ttotal = bdb->bdb_size;\n\n\t \n\twhile (index + 3 < total) {\n\t\tcurrent_id = *(base + index);\n\t\tcurrent_size = _get_blocksize(base + index);\n\t\tindex += 3;\n\n\t\tif (index + current_size > total)\n\t\t\treturn NULL;\n\n\t\tif (current_id == section_id)\n\t\t\treturn base + index;\n\n\t\tindex += current_size;\n\t}\n\n\treturn NULL;\n}\n\n \nstatic u32 raw_block_offset(const void *bdb, enum bdb_block_id section_id)\n{\n\tconst void *block;\n\n\tblock = find_raw_section(bdb, section_id);\n\tif (!block)\n\t\treturn 0;\n\n\treturn block - bdb;\n}\n\nstruct bdb_block_entry {\n\tstruct list_head node;\n\tenum bdb_block_id section_id;\n\tu8 data[];\n};\n\nstatic const void *\nbdb_find_section(struct drm_i915_private *i915,\n\t\t enum bdb_block_id section_id)\n{\n\tstruct bdb_block_entry *entry;\n\n\tlist_for_each_entry(entry, &i915->display.vbt.bdb_blocks, node) {\n\t\tif (entry->section_id == section_id)\n\t\t\treturn entry->data + 3;\n\t}\n\n\treturn NULL;\n}\n\nstatic const struct {\n\tenum bdb_block_id section_id;\n\tsize_t min_size;\n} bdb_blocks[] = {\n\t{ .section_id = BDB_GENERAL_FEATURES,\n\t  .min_size = sizeof(struct bdb_general_features), },\n\t{ .section_id = BDB_GENERAL_DEFINITIONS,\n\t  .min_size = sizeof(struct bdb_general_definitions), },\n\t{ .section_id = BDB_PSR,\n\t  .min_size = sizeof(struct bdb_psr), },\n\t{ .section_id = BDB_DRIVER_FEATURES,\n\t  .min_size = sizeof(struct bdb_driver_features), },\n\t{ .section_id = BDB_SDVO_LVDS_OPTIONS,\n\t  .min_size = sizeof(struct bdb_sdvo_lvds_options), },\n\t{ .section_id = BDB_SDVO_PANEL_DTDS,\n\t  .min_size = sizeof(struct bdb_sdvo_panel_dtds), },\n\t{ .section_id = BDB_EDP,\n\t  .min_size = sizeof(struct bdb_edp), },\n\t{ .section_id = BDB_LVDS_OPTIONS,\n\t  .min_size = sizeof(struct bdb_lvds_options), },\n\t \n\t{ .section_id = BDB_LVDS_LFP_DATA_PTRS,\n\t  .min_size = sizeof(struct bdb_lvds_lfp_data_ptrs), },\n\t{ .section_id = BDB_LVDS_LFP_DATA,\n\t  .min_size = 0,   },\n\t{ .section_id = BDB_LVDS_BACKLIGHT,\n\t  .min_size = sizeof(struct bdb_lfp_backlight_data), },\n\t{ .section_id = BDB_LFP_POWER,\n\t  .min_size = sizeof(struct bdb_lfp_power), },\n\t{ .section_id = BDB_MIPI_CONFIG,\n\t  .min_size = sizeof(struct bdb_mipi_config), },\n\t{ .section_id = BDB_MIPI_SEQUENCE,\n\t  .min_size = sizeof(struct bdb_mipi_sequence) },\n\t{ .section_id = BDB_COMPRESSION_PARAMETERS,\n\t  .min_size = sizeof(struct bdb_compression_parameters), },\n\t{ .section_id = BDB_GENERIC_DTD,\n\t  .min_size = sizeof(struct bdb_generic_dtd), },\n};\n\nstatic size_t lfp_data_min_size(struct drm_i915_private *i915)\n{\n\tconst struct bdb_lvds_lfp_data_ptrs *ptrs;\n\tsize_t size;\n\n\tptrs = bdb_find_section(i915, BDB_LVDS_LFP_DATA_PTRS);\n\tif (!ptrs)\n\t\treturn 0;\n\n\tsize = sizeof(struct bdb_lvds_lfp_data);\n\tif (ptrs->panel_name.table_size)\n\t\tsize = max(size, ptrs->panel_name.offset +\n\t\t\t   sizeof(struct bdb_lvds_lfp_data_tail));\n\n\treturn size;\n}\n\nstatic bool validate_lfp_data_ptrs(const void *bdb,\n\t\t\t\t   const struct bdb_lvds_lfp_data_ptrs *ptrs)\n{\n\tint fp_timing_size, dvo_timing_size, panel_pnp_id_size, panel_name_size;\n\tint data_block_size, lfp_data_size;\n\tconst void *data_block;\n\tint i;\n\n\tdata_block = find_raw_section(bdb, BDB_LVDS_LFP_DATA);\n\tif (!data_block)\n\t\treturn false;\n\n\tdata_block_size = get_blocksize(data_block);\n\tif (data_block_size == 0)\n\t\treturn false;\n\n\t \n\tif (ptrs->lvds_entries != 3)\n\t\treturn false;\n\n\tfp_timing_size = ptrs->ptr[0].fp_timing.table_size;\n\tdvo_timing_size = ptrs->ptr[0].dvo_timing.table_size;\n\tpanel_pnp_id_size = ptrs->ptr[0].panel_pnp_id.table_size;\n\tpanel_name_size = ptrs->panel_name.table_size;\n\n\t \n\tif (fp_timing_size < 32 ||\n\t    dvo_timing_size != sizeof(struct lvds_dvo_timing) ||\n\t    panel_pnp_id_size != sizeof(struct lvds_pnp_id))\n\t\treturn false;\n\n\t \n\tif (panel_name_size != 0 &&\n\t    panel_name_size != sizeof(struct lvds_lfp_panel_name))\n\t\treturn false;\n\n\tlfp_data_size = ptrs->ptr[1].fp_timing.offset - ptrs->ptr[0].fp_timing.offset;\n\tif (16 * lfp_data_size > data_block_size)\n\t\treturn false;\n\n\t \n\tfor (i = 1; i < 16; i++) {\n\t\tif (ptrs->ptr[i].fp_timing.table_size != fp_timing_size ||\n\t\t    ptrs->ptr[i].dvo_timing.table_size != dvo_timing_size ||\n\t\t    ptrs->ptr[i].panel_pnp_id.table_size != panel_pnp_id_size)\n\t\t\treturn false;\n\n\t\tif (ptrs->ptr[i].fp_timing.offset - ptrs->ptr[i-1].fp_timing.offset != lfp_data_size ||\n\t\t    ptrs->ptr[i].dvo_timing.offset - ptrs->ptr[i-1].dvo_timing.offset != lfp_data_size ||\n\t\t    ptrs->ptr[i].panel_pnp_id.offset - ptrs->ptr[i-1].panel_pnp_id.offset != lfp_data_size)\n\t\t\treturn false;\n\t}\n\n\t \n\tif (fp_timing_size + 6 + dvo_timing_size + panel_pnp_id_size == lfp_data_size)\n\t\tfp_timing_size += 6;\n\n\tif (fp_timing_size + dvo_timing_size + panel_pnp_id_size != lfp_data_size)\n\t\treturn false;\n\n\tif (ptrs->ptr[0].fp_timing.offset + fp_timing_size != ptrs->ptr[0].dvo_timing.offset ||\n\t    ptrs->ptr[0].dvo_timing.offset + dvo_timing_size != ptrs->ptr[0].panel_pnp_id.offset ||\n\t    ptrs->ptr[0].panel_pnp_id.offset + panel_pnp_id_size != lfp_data_size)\n\t\treturn false;\n\n\t \n\tfor (i = 0; i < 16; i++) {\n\t\tif (ptrs->ptr[i].fp_timing.offset + fp_timing_size > data_block_size ||\n\t\t    ptrs->ptr[i].dvo_timing.offset + dvo_timing_size > data_block_size ||\n\t\t    ptrs->ptr[i].panel_pnp_id.offset + panel_pnp_id_size > data_block_size)\n\t\t\treturn false;\n\t}\n\n\tif (ptrs->panel_name.offset + 16 * panel_name_size > data_block_size)\n\t\treturn false;\n\n\t \n\tfor (i = 0; i < 16; i++) {\n\t\tconst u16 *t = data_block + ptrs->ptr[i].fp_timing.offset +\n\t\t\tfp_timing_size - 2;\n\n\t\tif (*t != 0xffff)\n\t\t\treturn false;\n\t}\n\n\treturn true;\n}\n\n \nstatic bool fixup_lfp_data_ptrs(const void *bdb, void *ptrs_block)\n{\n\tstruct bdb_lvds_lfp_data_ptrs *ptrs = ptrs_block;\n\tu32 offset;\n\tint i;\n\n\toffset = raw_block_offset(bdb, BDB_LVDS_LFP_DATA);\n\n\tfor (i = 0; i < 16; i++) {\n\t\tif (ptrs->ptr[i].fp_timing.offset < offset ||\n\t\t    ptrs->ptr[i].dvo_timing.offset < offset ||\n\t\t    ptrs->ptr[i].panel_pnp_id.offset < offset)\n\t\t\treturn false;\n\n\t\tptrs->ptr[i].fp_timing.offset -= offset;\n\t\tptrs->ptr[i].dvo_timing.offset -= offset;\n\t\tptrs->ptr[i].panel_pnp_id.offset -= offset;\n\t}\n\n\tif (ptrs->panel_name.table_size) {\n\t\tif (ptrs->panel_name.offset < offset)\n\t\t\treturn false;\n\n\t\tptrs->panel_name.offset -= offset;\n\t}\n\n\treturn validate_lfp_data_ptrs(bdb, ptrs);\n}\n\nstatic int make_lfp_data_ptr(struct lvds_lfp_data_ptr_table *table,\n\t\t\t     int table_size, int total_size)\n{\n\tif (total_size < table_size)\n\t\treturn total_size;\n\n\ttable->table_size = table_size;\n\ttable->offset = total_size - table_size;\n\n\treturn total_size - table_size;\n}\n\nstatic void next_lfp_data_ptr(struct lvds_lfp_data_ptr_table *next,\n\t\t\t      const struct lvds_lfp_data_ptr_table *prev,\n\t\t\t      int size)\n{\n\tnext->table_size = prev->table_size;\n\tnext->offset = prev->offset + size;\n}\n\nstatic void *generate_lfp_data_ptrs(struct drm_i915_private *i915,\n\t\t\t\t    const void *bdb)\n{\n\tint i, size, table_size, block_size, offset, fp_timing_size;\n\tstruct bdb_lvds_lfp_data_ptrs *ptrs;\n\tconst void *block;\n\tvoid *ptrs_block;\n\n\t \n\tif (i915->display.vbt.version < 155)\n\t\treturn NULL;\n\n\tfp_timing_size = 38;\n\n\tblock = find_raw_section(bdb, BDB_LVDS_LFP_DATA);\n\tif (!block)\n\t\treturn NULL;\n\n\tdrm_dbg_kms(&i915->drm, \"Generating LFP data table pointers\\n\");\n\n\tblock_size = get_blocksize(block);\n\n\tsize = fp_timing_size + sizeof(struct lvds_dvo_timing) +\n\t\tsizeof(struct lvds_pnp_id);\n\tif (size * 16 > block_size)\n\t\treturn NULL;\n\n\tptrs_block = kzalloc(sizeof(*ptrs) + 3, GFP_KERNEL);\n\tif (!ptrs_block)\n\t\treturn NULL;\n\n\t*(u8 *)(ptrs_block + 0) = BDB_LVDS_LFP_DATA_PTRS;\n\t*(u16 *)(ptrs_block + 1) = sizeof(*ptrs);\n\tptrs = ptrs_block + 3;\n\n\ttable_size = sizeof(struct lvds_pnp_id);\n\tsize = make_lfp_data_ptr(&ptrs->ptr[0].panel_pnp_id, table_size, size);\n\n\ttable_size = sizeof(struct lvds_dvo_timing);\n\tsize = make_lfp_data_ptr(&ptrs->ptr[0].dvo_timing, table_size, size);\n\n\ttable_size = fp_timing_size;\n\tsize = make_lfp_data_ptr(&ptrs->ptr[0].fp_timing, table_size, size);\n\n\tif (ptrs->ptr[0].fp_timing.table_size)\n\t\tptrs->lvds_entries++;\n\tif (ptrs->ptr[0].dvo_timing.table_size)\n\t\tptrs->lvds_entries++;\n\tif (ptrs->ptr[0].panel_pnp_id.table_size)\n\t\tptrs->lvds_entries++;\n\n\tif (size != 0 || ptrs->lvds_entries != 3) {\n\t\tkfree(ptrs_block);\n\t\treturn NULL;\n\t}\n\n\tsize = fp_timing_size + sizeof(struct lvds_dvo_timing) +\n\t\tsizeof(struct lvds_pnp_id);\n\tfor (i = 1; i < 16; i++) {\n\t\tnext_lfp_data_ptr(&ptrs->ptr[i].fp_timing, &ptrs->ptr[i-1].fp_timing, size);\n\t\tnext_lfp_data_ptr(&ptrs->ptr[i].dvo_timing, &ptrs->ptr[i-1].dvo_timing, size);\n\t\tnext_lfp_data_ptr(&ptrs->ptr[i].panel_pnp_id, &ptrs->ptr[i-1].panel_pnp_id, size);\n\t}\n\n\ttable_size = sizeof(struct lvds_lfp_panel_name);\n\n\tif (16 * (size + table_size) <= block_size) {\n\t\tptrs->panel_name.table_size = table_size;\n\t\tptrs->panel_name.offset = size * 16;\n\t}\n\n\toffset = block - bdb;\n\n\tfor (i = 0; i < 16; i++) {\n\t\tptrs->ptr[i].fp_timing.offset += offset;\n\t\tptrs->ptr[i].dvo_timing.offset += offset;\n\t\tptrs->ptr[i].panel_pnp_id.offset += offset;\n\t}\n\n\tif (ptrs->panel_name.table_size)\n\t\tptrs->panel_name.offset += offset;\n\n\treturn ptrs_block;\n}\n\nstatic void\ninit_bdb_block(struct drm_i915_private *i915,\n\t       const void *bdb, enum bdb_block_id section_id,\n\t       size_t min_size)\n{\n\tstruct bdb_block_entry *entry;\n\tvoid *temp_block = NULL;\n\tconst void *block;\n\tsize_t block_size;\n\n\tblock = find_raw_section(bdb, section_id);\n\n\t \n\tif (!block && section_id == BDB_LVDS_LFP_DATA_PTRS) {\n\t\ttemp_block = generate_lfp_data_ptrs(i915, bdb);\n\t\tif (temp_block)\n\t\t\tblock = temp_block + 3;\n\t}\n\tif (!block)\n\t\treturn;\n\n\tdrm_WARN(&i915->drm, min_size == 0,\n\t\t \"Block %d min_size is zero\\n\", section_id);\n\n\tblock_size = get_blocksize(block);\n\n\t \n\tif (section_id == BDB_MIPI_SEQUENCE && *(const u8 *)block >= 3)\n\t\tblock_size += 5;\n\n\tentry = kzalloc(struct_size(entry, data, max(min_size, block_size) + 3),\n\t\t\tGFP_KERNEL);\n\tif (!entry) {\n\t\tkfree(temp_block);\n\t\treturn;\n\t}\n\n\tentry->section_id = section_id;\n\tmemcpy(entry->data, block - 3, block_size + 3);\n\n\tkfree(temp_block);\n\n\tdrm_dbg_kms(&i915->drm, \"Found BDB block %d (size %zu, min size %zu)\\n\",\n\t\t    section_id, block_size, min_size);\n\n\tif (section_id == BDB_LVDS_LFP_DATA_PTRS &&\n\t    !fixup_lfp_data_ptrs(bdb, entry->data + 3)) {\n\t\tdrm_err(&i915->drm, \"VBT has malformed LFP data table pointers\\n\");\n\t\tkfree(entry);\n\t\treturn;\n\t}\n\n\tlist_add_tail(&entry->node, &i915->display.vbt.bdb_blocks);\n}\n\nstatic void init_bdb_blocks(struct drm_i915_private *i915,\n\t\t\t    const void *bdb)\n{\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(bdb_blocks); i++) {\n\t\tenum bdb_block_id section_id = bdb_blocks[i].section_id;\n\t\tsize_t min_size = bdb_blocks[i].min_size;\n\n\t\tif (section_id == BDB_LVDS_LFP_DATA)\n\t\t\tmin_size = lfp_data_min_size(i915);\n\n\t\tinit_bdb_block(i915, bdb, section_id, min_size);\n\t}\n}\n\nstatic void\nfill_detail_timing_data(struct drm_display_mode *panel_fixed_mode,\n\t\t\tconst struct lvds_dvo_timing *dvo_timing)\n{\n\tpanel_fixed_mode->hdisplay = (dvo_timing->hactive_hi << 8) |\n\t\tdvo_timing->hactive_lo;\n\tpanel_fixed_mode->hsync_start = panel_fixed_mode->hdisplay +\n\t\t((dvo_timing->hsync_off_hi << 8) | dvo_timing->hsync_off_lo);\n\tpanel_fixed_mode->hsync_end = panel_fixed_mode->hsync_start +\n\t\t((dvo_timing->hsync_pulse_width_hi << 8) |\n\t\t\tdvo_timing->hsync_pulse_width_lo);\n\tpanel_fixed_mode->htotal = panel_fixed_mode->hdisplay +\n\t\t((dvo_timing->hblank_hi << 8) | dvo_timing->hblank_lo);\n\n\tpanel_fixed_mode->vdisplay = (dvo_timing->vactive_hi << 8) |\n\t\tdvo_timing->vactive_lo;\n\tpanel_fixed_mode->vsync_start = panel_fixed_mode->vdisplay +\n\t\t((dvo_timing->vsync_off_hi << 4) | dvo_timing->vsync_off_lo);\n\tpanel_fixed_mode->vsync_end = panel_fixed_mode->vsync_start +\n\t\t((dvo_timing->vsync_pulse_width_hi << 4) |\n\t\t\tdvo_timing->vsync_pulse_width_lo);\n\tpanel_fixed_mode->vtotal = panel_fixed_mode->vdisplay +\n\t\t((dvo_timing->vblank_hi << 8) | dvo_timing->vblank_lo);\n\tpanel_fixed_mode->clock = dvo_timing->clock * 10;\n\tpanel_fixed_mode->type = DRM_MODE_TYPE_PREFERRED;\n\n\tif (dvo_timing->hsync_positive)\n\t\tpanel_fixed_mode->flags |= DRM_MODE_FLAG_PHSYNC;\n\telse\n\t\tpanel_fixed_mode->flags |= DRM_MODE_FLAG_NHSYNC;\n\n\tif (dvo_timing->vsync_positive)\n\t\tpanel_fixed_mode->flags |= DRM_MODE_FLAG_PVSYNC;\n\telse\n\t\tpanel_fixed_mode->flags |= DRM_MODE_FLAG_NVSYNC;\n\n\tpanel_fixed_mode->width_mm = (dvo_timing->himage_hi << 8) |\n\t\tdvo_timing->himage_lo;\n\tpanel_fixed_mode->height_mm = (dvo_timing->vimage_hi << 8) |\n\t\tdvo_timing->vimage_lo;\n\n\t \n\tif (panel_fixed_mode->hsync_end > panel_fixed_mode->htotal)\n\t\tpanel_fixed_mode->htotal = panel_fixed_mode->hsync_end + 1;\n\tif (panel_fixed_mode->vsync_end > panel_fixed_mode->vtotal)\n\t\tpanel_fixed_mode->vtotal = panel_fixed_mode->vsync_end + 1;\n\n\tdrm_mode_set_name(panel_fixed_mode);\n}\n\nstatic const struct lvds_dvo_timing *\nget_lvds_dvo_timing(const struct bdb_lvds_lfp_data *data,\n\t\t    const struct bdb_lvds_lfp_data_ptrs *ptrs,\n\t\t    int index)\n{\n\treturn (const void *)data + ptrs->ptr[index].dvo_timing.offset;\n}\n\nstatic const struct lvds_fp_timing *\nget_lvds_fp_timing(const struct bdb_lvds_lfp_data *data,\n\t\t   const struct bdb_lvds_lfp_data_ptrs *ptrs,\n\t\t   int index)\n{\n\treturn (const void *)data + ptrs->ptr[index].fp_timing.offset;\n}\n\nstatic const struct lvds_pnp_id *\nget_lvds_pnp_id(const struct bdb_lvds_lfp_data *data,\n\t\tconst struct bdb_lvds_lfp_data_ptrs *ptrs,\n\t\tint index)\n{\n\treturn (const void *)data + ptrs->ptr[index].panel_pnp_id.offset;\n}\n\nstatic const struct bdb_lvds_lfp_data_tail *\nget_lfp_data_tail(const struct bdb_lvds_lfp_data *data,\n\t\t  const struct bdb_lvds_lfp_data_ptrs *ptrs)\n{\n\tif (ptrs->panel_name.table_size)\n\t\treturn (const void *)data + ptrs->panel_name.offset;\n\telse\n\t\treturn NULL;\n}\n\nstatic void dump_pnp_id(struct drm_i915_private *i915,\n\t\t\tconst struct lvds_pnp_id *pnp_id,\n\t\t\tconst char *name)\n{\n\tu16 mfg_name = be16_to_cpu((__force __be16)pnp_id->mfg_name);\n\tchar vend[4];\n\n\tdrm_dbg_kms(&i915->drm, \"%s PNPID mfg: %s (0x%x), prod: %u, serial: %u, week: %d, year: %d\\n\",\n\t\t    name, drm_edid_decode_mfg_id(mfg_name, vend),\n\t\t    pnp_id->mfg_name, pnp_id->product_code, pnp_id->serial,\n\t\t    pnp_id->mfg_week, pnp_id->mfg_year + 1990);\n}\n\nstatic int opregion_get_panel_type(struct drm_i915_private *i915,\n\t\t\t\t   const struct intel_bios_encoder_data *devdata,\n\t\t\t\t   const struct drm_edid *drm_edid, bool use_fallback)\n{\n\treturn intel_opregion_get_panel_type(i915);\n}\n\nstatic int vbt_get_panel_type(struct drm_i915_private *i915,\n\t\t\t      const struct intel_bios_encoder_data *devdata,\n\t\t\t      const struct drm_edid *drm_edid, bool use_fallback)\n{\n\tconst struct bdb_lvds_options *lvds_options;\n\n\tlvds_options = bdb_find_section(i915, BDB_LVDS_OPTIONS);\n\tif (!lvds_options)\n\t\treturn -1;\n\n\tif (lvds_options->panel_type > 0xf &&\n\t    lvds_options->panel_type != 0xff) {\n\t\tdrm_dbg_kms(&i915->drm, \"Invalid VBT panel type 0x%x\\n\",\n\t\t\t    lvds_options->panel_type);\n\t\treturn -1;\n\t}\n\n\tif (devdata && devdata->child.handle == DEVICE_HANDLE_LFP2)\n\t\treturn lvds_options->panel_type2;\n\n\tdrm_WARN_ON(&i915->drm, devdata && devdata->child.handle != DEVICE_HANDLE_LFP1);\n\n\treturn lvds_options->panel_type;\n}\n\nstatic int pnpid_get_panel_type(struct drm_i915_private *i915,\n\t\t\t\tconst struct intel_bios_encoder_data *devdata,\n\t\t\t\tconst struct drm_edid *drm_edid, bool use_fallback)\n{\n\tconst struct bdb_lvds_lfp_data *data;\n\tconst struct bdb_lvds_lfp_data_ptrs *ptrs;\n\tconst struct lvds_pnp_id *edid_id;\n\tstruct lvds_pnp_id edid_id_nodate;\n\tconst struct edid *edid = drm_edid_raw(drm_edid);  \n\tint i, best = -1;\n\n\tif (!edid)\n\t\treturn -1;\n\n\tedid_id = (const void *)&edid->mfg_id[0];\n\n\tedid_id_nodate = *edid_id;\n\tedid_id_nodate.mfg_week = 0;\n\tedid_id_nodate.mfg_year = 0;\n\n\tdump_pnp_id(i915, edid_id, \"EDID\");\n\n\tptrs = bdb_find_section(i915, BDB_LVDS_LFP_DATA_PTRS);\n\tif (!ptrs)\n\t\treturn -1;\n\n\tdata = bdb_find_section(i915, BDB_LVDS_LFP_DATA);\n\tif (!data)\n\t\treturn -1;\n\n\tfor (i = 0; i < 16; i++) {\n\t\tconst struct lvds_pnp_id *vbt_id =\n\t\t\tget_lvds_pnp_id(data, ptrs, i);\n\n\t\t \n\t\tif (!memcmp(vbt_id, edid_id, sizeof(*vbt_id)))\n\t\t\treturn i;\n\n\t\t \n\t\tif (best < 0 &&\n\t\t    !memcmp(vbt_id, &edid_id_nodate, sizeof(*vbt_id)))\n\t\t\tbest = i;\n\t}\n\n\treturn best;\n}\n\nstatic int fallback_get_panel_type(struct drm_i915_private *i915,\n\t\t\t\t   const struct intel_bios_encoder_data *devdata,\n\t\t\t\t   const struct drm_edid *drm_edid, bool use_fallback)\n{\n\treturn use_fallback ? 0 : -1;\n}\n\nenum panel_type {\n\tPANEL_TYPE_OPREGION,\n\tPANEL_TYPE_VBT,\n\tPANEL_TYPE_PNPID,\n\tPANEL_TYPE_FALLBACK,\n};\n\nstatic int get_panel_type(struct drm_i915_private *i915,\n\t\t\t  const struct intel_bios_encoder_data *devdata,\n\t\t\t  const struct drm_edid *drm_edid, bool use_fallback)\n{\n\tstruct {\n\t\tconst char *name;\n\t\tint (*get_panel_type)(struct drm_i915_private *i915,\n\t\t\t\t      const struct intel_bios_encoder_data *devdata,\n\t\t\t\t      const struct drm_edid *drm_edid, bool use_fallback);\n\t\tint panel_type;\n\t} panel_types[] = {\n\t\t[PANEL_TYPE_OPREGION] = {\n\t\t\t.name = \"OpRegion\",\n\t\t\t.get_panel_type = opregion_get_panel_type,\n\t\t},\n\t\t[PANEL_TYPE_VBT] = {\n\t\t\t.name = \"VBT\",\n\t\t\t.get_panel_type = vbt_get_panel_type,\n\t\t},\n\t\t[PANEL_TYPE_PNPID] = {\n\t\t\t.name = \"PNPID\",\n\t\t\t.get_panel_type = pnpid_get_panel_type,\n\t\t},\n\t\t[PANEL_TYPE_FALLBACK] = {\n\t\t\t.name = \"fallback\",\n\t\t\t.get_panel_type = fallback_get_panel_type,\n\t\t},\n\t};\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(panel_types); i++) {\n\t\tpanel_types[i].panel_type = panel_types[i].get_panel_type(i915, devdata,\n\t\t\t\t\t\t\t\t\t  drm_edid, use_fallback);\n\n\t\tdrm_WARN_ON(&i915->drm, panel_types[i].panel_type > 0xf &&\n\t\t\t    panel_types[i].panel_type != 0xff);\n\n\t\tif (panel_types[i].panel_type >= 0)\n\t\t\tdrm_dbg_kms(&i915->drm, \"Panel type (%s): %d\\n\",\n\t\t\t\t    panel_types[i].name, panel_types[i].panel_type);\n\t}\n\n\tif (panel_types[PANEL_TYPE_OPREGION].panel_type >= 0)\n\t\ti = PANEL_TYPE_OPREGION;\n\telse if (panel_types[PANEL_TYPE_VBT].panel_type == 0xff &&\n\t\t panel_types[PANEL_TYPE_PNPID].panel_type >= 0)\n\t\ti = PANEL_TYPE_PNPID;\n\telse if (panel_types[PANEL_TYPE_VBT].panel_type != 0xff &&\n\t\t panel_types[PANEL_TYPE_VBT].panel_type >= 0)\n\t\ti = PANEL_TYPE_VBT;\n\telse\n\t\ti = PANEL_TYPE_FALLBACK;\n\n\tdrm_dbg_kms(&i915->drm, \"Selected panel type (%s): %d\\n\",\n\t\t    panel_types[i].name, panel_types[i].panel_type);\n\n\treturn panel_types[i].panel_type;\n}\n\nstatic unsigned int panel_bits(unsigned int value, int panel_type, int num_bits)\n{\n\treturn (value >> (panel_type * num_bits)) & (BIT(num_bits) - 1);\n}\n\nstatic bool panel_bool(unsigned int value, int panel_type)\n{\n\treturn panel_bits(value, panel_type, 1);\n}\n\n \nstatic void\nparse_panel_options(struct drm_i915_private *i915,\n\t\t    struct intel_panel *panel)\n{\n\tconst struct bdb_lvds_options *lvds_options;\n\tint panel_type = panel->vbt.panel_type;\n\tint drrs_mode;\n\n\tlvds_options = bdb_find_section(i915, BDB_LVDS_OPTIONS);\n\tif (!lvds_options)\n\t\treturn;\n\n\tpanel->vbt.lvds_dither = lvds_options->pixel_dither;\n\n\t \n\tif (get_blocksize(lvds_options) < 16)\n\t\treturn;\n\n\tdrrs_mode = panel_bits(lvds_options->dps_panel_type_bits,\n\t\t\t       panel_type, 2);\n\t \n\tswitch (drrs_mode) {\n\tcase 0:\n\t\tpanel->vbt.drrs_type = DRRS_TYPE_STATIC;\n\t\tdrm_dbg_kms(&i915->drm, \"DRRS supported mode is static\\n\");\n\t\tbreak;\n\tcase 2:\n\t\tpanel->vbt.drrs_type = DRRS_TYPE_SEAMLESS;\n\t\tdrm_dbg_kms(&i915->drm,\n\t\t\t    \"DRRS supported mode is seamless\\n\");\n\t\tbreak;\n\tdefault:\n\t\tpanel->vbt.drrs_type = DRRS_TYPE_NONE;\n\t\tdrm_dbg_kms(&i915->drm,\n\t\t\t    \"DRRS not supported (VBT input)\\n\");\n\t\tbreak;\n\t}\n}\n\nstatic void\nparse_lfp_panel_dtd(struct drm_i915_private *i915,\n\t\t    struct intel_panel *panel,\n\t\t    const struct bdb_lvds_lfp_data *lvds_lfp_data,\n\t\t    const struct bdb_lvds_lfp_data_ptrs *lvds_lfp_data_ptrs)\n{\n\tconst struct lvds_dvo_timing *panel_dvo_timing;\n\tconst struct lvds_fp_timing *fp_timing;\n\tstruct drm_display_mode *panel_fixed_mode;\n\tint panel_type = panel->vbt.panel_type;\n\n\tpanel_dvo_timing = get_lvds_dvo_timing(lvds_lfp_data,\n\t\t\t\t\t       lvds_lfp_data_ptrs,\n\t\t\t\t\t       panel_type);\n\n\tpanel_fixed_mode = kzalloc(sizeof(*panel_fixed_mode), GFP_KERNEL);\n\tif (!panel_fixed_mode)\n\t\treturn;\n\n\tfill_detail_timing_data(panel_fixed_mode, panel_dvo_timing);\n\n\tpanel->vbt.lfp_lvds_vbt_mode = panel_fixed_mode;\n\n\tdrm_dbg_kms(&i915->drm,\n\t\t    \"Found panel mode in BIOS VBT legacy lfp table: \" DRM_MODE_FMT \"\\n\",\n\t\t    DRM_MODE_ARG(panel_fixed_mode));\n\n\tfp_timing = get_lvds_fp_timing(lvds_lfp_data,\n\t\t\t\t       lvds_lfp_data_ptrs,\n\t\t\t\t       panel_type);\n\n\t \n\tif (fp_timing->x_res == panel_fixed_mode->hdisplay &&\n\t    fp_timing->y_res == panel_fixed_mode->vdisplay) {\n\t\tpanel->vbt.bios_lvds_val = fp_timing->lvds_reg_val;\n\t\tdrm_dbg_kms(&i915->drm,\n\t\t\t    \"VBT initial LVDS value %x\\n\",\n\t\t\t    panel->vbt.bios_lvds_val);\n\t}\n}\n\nstatic void\nparse_lfp_data(struct drm_i915_private *i915,\n\t       struct intel_panel *panel)\n{\n\tconst struct bdb_lvds_lfp_data *data;\n\tconst struct bdb_lvds_lfp_data_tail *tail;\n\tconst struct bdb_lvds_lfp_data_ptrs *ptrs;\n\tconst struct lvds_pnp_id *pnp_id;\n\tint panel_type = panel->vbt.panel_type;\n\n\tptrs = bdb_find_section(i915, BDB_LVDS_LFP_DATA_PTRS);\n\tif (!ptrs)\n\t\treturn;\n\n\tdata = bdb_find_section(i915, BDB_LVDS_LFP_DATA);\n\tif (!data)\n\t\treturn;\n\n\tif (!panel->vbt.lfp_lvds_vbt_mode)\n\t\tparse_lfp_panel_dtd(i915, panel, data, ptrs);\n\n\tpnp_id = get_lvds_pnp_id(data, ptrs, panel_type);\n\tdump_pnp_id(i915, pnp_id, \"Panel\");\n\n\ttail = get_lfp_data_tail(data, ptrs);\n\tif (!tail)\n\t\treturn;\n\n\tdrm_dbg_kms(&i915->drm, \"Panel name: %.*s\\n\",\n\t\t    (int)sizeof(tail->panel_name[0].name),\n\t\t    tail->panel_name[panel_type].name);\n\n\tif (i915->display.vbt.version >= 188) {\n\t\tpanel->vbt.seamless_drrs_min_refresh_rate =\n\t\t\ttail->seamless_drrs_min_refresh_rate[panel_type];\n\t\tdrm_dbg_kms(&i915->drm,\n\t\t\t    \"Seamless DRRS min refresh rate: %d Hz\\n\",\n\t\t\t    panel->vbt.seamless_drrs_min_refresh_rate);\n\t}\n}\n\nstatic void\nparse_generic_dtd(struct drm_i915_private *i915,\n\t\t  struct intel_panel *panel)\n{\n\tconst struct bdb_generic_dtd *generic_dtd;\n\tconst struct generic_dtd_entry *dtd;\n\tstruct drm_display_mode *panel_fixed_mode;\n\tint num_dtd;\n\n\t \n\tif (i915->display.vbt.version < 229)\n\t\treturn;\n\n\tgeneric_dtd = bdb_find_section(i915, BDB_GENERIC_DTD);\n\tif (!generic_dtd)\n\t\treturn;\n\n\tif (generic_dtd->gdtd_size < sizeof(struct generic_dtd_entry)) {\n\t\tdrm_err(&i915->drm, \"GDTD size %u is too small.\\n\",\n\t\t\tgeneric_dtd->gdtd_size);\n\t\treturn;\n\t} else if (generic_dtd->gdtd_size !=\n\t\t   sizeof(struct generic_dtd_entry)) {\n\t\tdrm_err(&i915->drm, \"Unexpected GDTD size %u\\n\",\n\t\t\tgeneric_dtd->gdtd_size);\n\t\t \n\t}\n\n\tnum_dtd = (get_blocksize(generic_dtd) -\n\t\t   sizeof(struct bdb_generic_dtd)) / generic_dtd->gdtd_size;\n\tif (panel->vbt.panel_type >= num_dtd) {\n\t\tdrm_err(&i915->drm,\n\t\t\t\"Panel type %d not found in table of %d DTD's\\n\",\n\t\t\tpanel->vbt.panel_type, num_dtd);\n\t\treturn;\n\t}\n\n\tdtd = &generic_dtd->dtd[panel->vbt.panel_type];\n\n\tpanel_fixed_mode = kzalloc(sizeof(*panel_fixed_mode), GFP_KERNEL);\n\tif (!panel_fixed_mode)\n\t\treturn;\n\n\tpanel_fixed_mode->hdisplay = dtd->hactive;\n\tpanel_fixed_mode->hsync_start =\n\t\tpanel_fixed_mode->hdisplay + dtd->hfront_porch;\n\tpanel_fixed_mode->hsync_end =\n\t\tpanel_fixed_mode->hsync_start + dtd->hsync;\n\tpanel_fixed_mode->htotal =\n\t\tpanel_fixed_mode->hdisplay + dtd->hblank;\n\n\tpanel_fixed_mode->vdisplay = dtd->vactive;\n\tpanel_fixed_mode->vsync_start =\n\t\tpanel_fixed_mode->vdisplay + dtd->vfront_porch;\n\tpanel_fixed_mode->vsync_end =\n\t\tpanel_fixed_mode->vsync_start + dtd->vsync;\n\tpanel_fixed_mode->vtotal =\n\t\tpanel_fixed_mode->vdisplay + dtd->vblank;\n\n\tpanel_fixed_mode->clock = dtd->pixel_clock;\n\tpanel_fixed_mode->width_mm = dtd->width_mm;\n\tpanel_fixed_mode->height_mm = dtd->height_mm;\n\n\tpanel_fixed_mode->type = DRM_MODE_TYPE_PREFERRED;\n\tdrm_mode_set_name(panel_fixed_mode);\n\n\tif (dtd->hsync_positive_polarity)\n\t\tpanel_fixed_mode->flags |= DRM_MODE_FLAG_PHSYNC;\n\telse\n\t\tpanel_fixed_mode->flags |= DRM_MODE_FLAG_NHSYNC;\n\n\tif (dtd->vsync_positive_polarity)\n\t\tpanel_fixed_mode->flags |= DRM_MODE_FLAG_PVSYNC;\n\telse\n\t\tpanel_fixed_mode->flags |= DRM_MODE_FLAG_NVSYNC;\n\n\tdrm_dbg_kms(&i915->drm,\n\t\t    \"Found panel mode in BIOS VBT generic dtd table: \" DRM_MODE_FMT \"\\n\",\n\t\t    DRM_MODE_ARG(panel_fixed_mode));\n\n\tpanel->vbt.lfp_lvds_vbt_mode = panel_fixed_mode;\n}\n\nstatic void\nparse_lfp_backlight(struct drm_i915_private *i915,\n\t\t    struct intel_panel *panel)\n{\n\tconst struct bdb_lfp_backlight_data *backlight_data;\n\tconst struct lfp_backlight_data_entry *entry;\n\tint panel_type = panel->vbt.panel_type;\n\tu16 level;\n\n\tbacklight_data = bdb_find_section(i915, BDB_LVDS_BACKLIGHT);\n\tif (!backlight_data)\n\t\treturn;\n\n\tif (backlight_data->entry_size != sizeof(backlight_data->data[0])) {\n\t\tdrm_dbg_kms(&i915->drm,\n\t\t\t    \"Unsupported backlight data entry size %u\\n\",\n\t\t\t    backlight_data->entry_size);\n\t\treturn;\n\t}\n\n\tentry = &backlight_data->data[panel_type];\n\n\tpanel->vbt.backlight.present = entry->type == BDB_BACKLIGHT_TYPE_PWM;\n\tif (!panel->vbt.backlight.present) {\n\t\tdrm_dbg_kms(&i915->drm,\n\t\t\t    \"PWM backlight not present in VBT (type %u)\\n\",\n\t\t\t    entry->type);\n\t\treturn;\n\t}\n\n\tpanel->vbt.backlight.type = INTEL_BACKLIGHT_DISPLAY_DDI;\n\tpanel->vbt.backlight.controller = 0;\n\tif (i915->display.vbt.version >= 191) {\n\t\tsize_t exp_size;\n\n\t\tif (i915->display.vbt.version >= 236)\n\t\t\texp_size = sizeof(struct bdb_lfp_backlight_data);\n\t\telse if (i915->display.vbt.version >= 234)\n\t\t\texp_size = EXP_BDB_LFP_BL_DATA_SIZE_REV_234;\n\t\telse\n\t\t\texp_size = EXP_BDB_LFP_BL_DATA_SIZE_REV_191;\n\n\t\tif (get_blocksize(backlight_data) >= exp_size) {\n\t\t\tconst struct lfp_backlight_control_method *method;\n\n\t\t\tmethod = &backlight_data->backlight_control[panel_type];\n\t\t\tpanel->vbt.backlight.type = method->type;\n\t\t\tpanel->vbt.backlight.controller = method->controller;\n\t\t}\n\t}\n\n\tpanel->vbt.backlight.pwm_freq_hz = entry->pwm_freq_hz;\n\tpanel->vbt.backlight.active_low_pwm = entry->active_low_pwm;\n\n\tif (i915->display.vbt.version >= 234) {\n\t\tu16 min_level;\n\t\tbool scale;\n\n\t\tlevel = backlight_data->brightness_level[panel_type].level;\n\t\tmin_level = backlight_data->brightness_min_level[panel_type].level;\n\n\t\tif (i915->display.vbt.version >= 236)\n\t\t\tscale = backlight_data->brightness_precision_bits[panel_type] == 16;\n\t\telse\n\t\t\tscale = level > 255;\n\n\t\tif (scale)\n\t\t\tmin_level = min_level / 255;\n\n\t\tif (min_level > 255) {\n\t\t\tdrm_warn(&i915->drm, \"Brightness min level > 255\\n\");\n\t\t\tlevel = 255;\n\t\t}\n\t\tpanel->vbt.backlight.min_brightness = min_level;\n\n\t\tpanel->vbt.backlight.brightness_precision_bits =\n\t\t\tbacklight_data->brightness_precision_bits[panel_type];\n\t} else {\n\t\tlevel = backlight_data->level[panel_type];\n\t\tpanel->vbt.backlight.min_brightness = entry->min_brightness;\n\t}\n\n\tif (i915->display.vbt.version >= 239)\n\t\tpanel->vbt.backlight.hdr_dpcd_refresh_timeout =\n\t\t\tDIV_ROUND_UP(backlight_data->hdr_dpcd_refresh_timeout[panel_type], 100);\n\telse\n\t\tpanel->vbt.backlight.hdr_dpcd_refresh_timeout = 30;\n\n\tdrm_dbg_kms(&i915->drm,\n\t\t    \"VBT backlight PWM modulation frequency %u Hz, \"\n\t\t    \"active %s, min brightness %u, level %u, controller %u\\n\",\n\t\t    panel->vbt.backlight.pwm_freq_hz,\n\t\t    panel->vbt.backlight.active_low_pwm ? \"low\" : \"high\",\n\t\t    panel->vbt.backlight.min_brightness,\n\t\t    level,\n\t\t    panel->vbt.backlight.controller);\n}\n\n \nstatic void\nparse_sdvo_panel_data(struct drm_i915_private *i915,\n\t\t      struct intel_panel *panel)\n{\n\tconst struct bdb_sdvo_panel_dtds *dtds;\n\tstruct drm_display_mode *panel_fixed_mode;\n\tint index;\n\n\tindex = i915->params.vbt_sdvo_panel_type;\n\tif (index == -2) {\n\t\tdrm_dbg_kms(&i915->drm,\n\t\t\t    \"Ignore SDVO panel mode from BIOS VBT tables.\\n\");\n\t\treturn;\n\t}\n\n\tif (index == -1) {\n\t\tconst struct bdb_sdvo_lvds_options *sdvo_lvds_options;\n\n\t\tsdvo_lvds_options = bdb_find_section(i915, BDB_SDVO_LVDS_OPTIONS);\n\t\tif (!sdvo_lvds_options)\n\t\t\treturn;\n\n\t\tindex = sdvo_lvds_options->panel_type;\n\t}\n\n\tdtds = bdb_find_section(i915, BDB_SDVO_PANEL_DTDS);\n\tif (!dtds)\n\t\treturn;\n\n\tpanel_fixed_mode = kzalloc(sizeof(*panel_fixed_mode), GFP_KERNEL);\n\tif (!panel_fixed_mode)\n\t\treturn;\n\n\tfill_detail_timing_data(panel_fixed_mode, &dtds->dtds[index]);\n\n\tpanel->vbt.sdvo_lvds_vbt_mode = panel_fixed_mode;\n\n\tdrm_dbg_kms(&i915->drm,\n\t\t    \"Found SDVO panel mode in BIOS VBT tables: \" DRM_MODE_FMT \"\\n\",\n\t\t    DRM_MODE_ARG(panel_fixed_mode));\n}\n\nstatic int intel_bios_ssc_frequency(struct drm_i915_private *i915,\n\t\t\t\t    bool alternate)\n{\n\tswitch (DISPLAY_VER(i915)) {\n\tcase 2:\n\t\treturn alternate ? 66667 : 48000;\n\tcase 3:\n\tcase 4:\n\t\treturn alternate ? 100000 : 96000;\n\tdefault:\n\t\treturn alternate ? 100000 : 120000;\n\t}\n}\n\nstatic void\nparse_general_features(struct drm_i915_private *i915)\n{\n\tconst struct bdb_general_features *general;\n\n\tgeneral = bdb_find_section(i915, BDB_GENERAL_FEATURES);\n\tif (!general)\n\t\treturn;\n\n\ti915->display.vbt.int_tv_support = general->int_tv_support;\n\t \n\tif (i915->display.vbt.version >= 155 &&\n\t    (HAS_DDI(i915) || IS_VALLEYVIEW(i915)))\n\t\ti915->display.vbt.int_crt_support = general->int_crt_support;\n\ti915->display.vbt.lvds_use_ssc = general->enable_ssc;\n\ti915->display.vbt.lvds_ssc_freq =\n\t\tintel_bios_ssc_frequency(i915, general->ssc_freq);\n\ti915->display.vbt.display_clock_mode = general->display_clock_mode;\n\ti915->display.vbt.fdi_rx_polarity_inverted = general->fdi_rx_polarity_inverted;\n\tif (i915->display.vbt.version >= 181) {\n\t\ti915->display.vbt.orientation = general->rotate_180 ?\n\t\t\tDRM_MODE_PANEL_ORIENTATION_BOTTOM_UP :\n\t\t\tDRM_MODE_PANEL_ORIENTATION_NORMAL;\n\t} else {\n\t\ti915->display.vbt.orientation = DRM_MODE_PANEL_ORIENTATION_UNKNOWN;\n\t}\n\n\tif (i915->display.vbt.version >= 249 && general->afc_startup_config) {\n\t\ti915->display.vbt.override_afc_startup = true;\n\t\ti915->display.vbt.override_afc_startup_val = general->afc_startup_config == 0x1 ? 0x0 : 0x7;\n\t}\n\n\tdrm_dbg_kms(&i915->drm,\n\t\t    \"BDB_GENERAL_FEATURES int_tv_support %d int_crt_support %d lvds_use_ssc %d lvds_ssc_freq %d display_clock_mode %d fdi_rx_polarity_inverted %d\\n\",\n\t\t    i915->display.vbt.int_tv_support,\n\t\t    i915->display.vbt.int_crt_support,\n\t\t    i915->display.vbt.lvds_use_ssc,\n\t\t    i915->display.vbt.lvds_ssc_freq,\n\t\t    i915->display.vbt.display_clock_mode,\n\t\t    i915->display.vbt.fdi_rx_polarity_inverted);\n}\n\nstatic const struct child_device_config *\nchild_device_ptr(const struct bdb_general_definitions *defs, int i)\n{\n\treturn (const void *) &defs->devices[i * defs->child_dev_size];\n}\n\nstatic void\nparse_sdvo_device_mapping(struct drm_i915_private *i915)\n{\n\tconst struct intel_bios_encoder_data *devdata;\n\tint count = 0;\n\n\t \n\tif (!IS_DISPLAY_VER(i915, 3, 7)) {\n\t\tdrm_dbg_kms(&i915->drm, \"Skipping SDVO device mapping\\n\");\n\t\treturn;\n\t}\n\n\tlist_for_each_entry(devdata, &i915->display.vbt.display_devices, node) {\n\t\tconst struct child_device_config *child = &devdata->child;\n\t\tstruct sdvo_device_mapping *mapping;\n\n\t\tif (child->slave_addr != SLAVE_ADDR1 &&\n\t\t    child->slave_addr != SLAVE_ADDR2) {\n\t\t\t \n\t\t\tcontinue;\n\t\t}\n\t\tif (child->dvo_port != DEVICE_PORT_DVOB &&\n\t\t    child->dvo_port != DEVICE_PORT_DVOC) {\n\t\t\t \n\t\t\tdrm_dbg_kms(&i915->drm,\n\t\t\t\t    \"Incorrect SDVO port. Skip it\\n\");\n\t\t\tcontinue;\n\t\t}\n\t\tdrm_dbg_kms(&i915->drm,\n\t\t\t    \"the SDVO device with slave addr %2x is found on\"\n\t\t\t    \" %s port\\n\",\n\t\t\t    child->slave_addr,\n\t\t\t    (child->dvo_port == DEVICE_PORT_DVOB) ?\n\t\t\t    \"SDVOB\" : \"SDVOC\");\n\t\tmapping = &i915->display.vbt.sdvo_mappings[child->dvo_port - 1];\n\t\tif (!mapping->initialized) {\n\t\t\tmapping->dvo_port = child->dvo_port;\n\t\t\tmapping->slave_addr = child->slave_addr;\n\t\t\tmapping->dvo_wiring = child->dvo_wiring;\n\t\t\tmapping->ddc_pin = child->ddc_pin;\n\t\t\tmapping->i2c_pin = child->i2c_pin;\n\t\t\tmapping->initialized = 1;\n\t\t\tdrm_dbg_kms(&i915->drm,\n\t\t\t\t    \"SDVO device: dvo=%x, addr=%x, wiring=%d, ddc_pin=%d, i2c_pin=%d\\n\",\n\t\t\t\t    mapping->dvo_port, mapping->slave_addr,\n\t\t\t\t    mapping->dvo_wiring, mapping->ddc_pin,\n\t\t\t\t    mapping->i2c_pin);\n\t\t} else {\n\t\t\tdrm_dbg_kms(&i915->drm,\n\t\t\t\t    \"Maybe one SDVO port is shared by \"\n\t\t\t\t    \"two SDVO device.\\n\");\n\t\t}\n\t\tif (child->slave2_addr) {\n\t\t\t \n\t\t\t \n\t\t\tdrm_dbg_kms(&i915->drm,\n\t\t\t\t    \"there exists the slave2_addr. Maybe this\"\n\t\t\t\t    \" is a SDVO device with multiple inputs.\\n\");\n\t\t}\n\t\tcount++;\n\t}\n\n\tif (!count) {\n\t\t \n\t\tdrm_dbg_kms(&i915->drm,\n\t\t\t    \"No SDVO device info is found in VBT\\n\");\n\t}\n}\n\nstatic void\nparse_driver_features(struct drm_i915_private *i915)\n{\n\tconst struct bdb_driver_features *driver;\n\n\tdriver = bdb_find_section(i915, BDB_DRIVER_FEATURES);\n\tif (!driver)\n\t\treturn;\n\n\tif (DISPLAY_VER(i915) >= 5) {\n\t\t \n\t\tif (driver->lvds_config != BDB_DRIVER_FEATURE_INT_LVDS)\n\t\t\ti915->display.vbt.int_lvds_support = 0;\n\t} else {\n\t\t \n\t\tif (i915->display.vbt.version >= 134 &&\n\t\t    driver->lvds_config != BDB_DRIVER_FEATURE_INT_LVDS &&\n\t\t    driver->lvds_config != BDB_DRIVER_FEATURE_INT_SDVO_LVDS)\n\t\t\ti915->display.vbt.int_lvds_support = 0;\n\t}\n}\n\nstatic void\nparse_panel_driver_features(struct drm_i915_private *i915,\n\t\t\t    struct intel_panel *panel)\n{\n\tconst struct bdb_driver_features *driver;\n\n\tdriver = bdb_find_section(i915, BDB_DRIVER_FEATURES);\n\tif (!driver)\n\t\treturn;\n\n\tif (i915->display.vbt.version < 228) {\n\t\tdrm_dbg_kms(&i915->drm, \"DRRS State Enabled:%d\\n\",\n\t\t\t    driver->drrs_enabled);\n\t\t \n\t\tif (!driver->drrs_enabled && panel->vbt.drrs_type != DRRS_TYPE_NONE) {\n\t\t\t \n\t\t\tif (driver->dmrrs_enabled)\n\t\t\t\tpanel->vbt.drrs_type = DRRS_TYPE_STATIC;\n\t\t\telse\n\t\t\t\tpanel->vbt.drrs_type = DRRS_TYPE_NONE;\n\t\t}\n\n\t\tpanel->vbt.psr.enable = driver->psr_enabled;\n\t}\n}\n\nstatic void\nparse_power_conservation_features(struct drm_i915_private *i915,\n\t\t\t\t  struct intel_panel *panel)\n{\n\tconst struct bdb_lfp_power *power;\n\tu8 panel_type = panel->vbt.panel_type;\n\n\tpanel->vbt.vrr = true;  \n\n\tif (i915->display.vbt.version < 228)\n\t\treturn;\n\n\tpower = bdb_find_section(i915, BDB_LFP_POWER);\n\tif (!power)\n\t\treturn;\n\n\tpanel->vbt.psr.enable = panel_bool(power->psr, panel_type);\n\n\t \n\tif (!panel_bool(power->drrs, panel_type) && panel->vbt.drrs_type != DRRS_TYPE_NONE) {\n\t\t \n\t\tif (panel_bool(power->dmrrs, panel_type))\n\t\t\tpanel->vbt.drrs_type = DRRS_TYPE_STATIC;\n\t\telse\n\t\t\tpanel->vbt.drrs_type = DRRS_TYPE_NONE;\n\t}\n\n\tif (i915->display.vbt.version >= 232)\n\t\tpanel->vbt.edp.hobl = panel_bool(power->hobl, panel_type);\n\n\tif (i915->display.vbt.version >= 233)\n\t\tpanel->vbt.vrr = panel_bool(power->vrr_feature_enabled,\n\t\t\t\t\t    panel_type);\n}\n\nstatic void\nparse_edp(struct drm_i915_private *i915,\n\t  struct intel_panel *panel)\n{\n\tconst struct bdb_edp *edp;\n\tconst struct edp_power_seq *edp_pps;\n\tconst struct edp_fast_link_params *edp_link_params;\n\tint panel_type = panel->vbt.panel_type;\n\n\tedp = bdb_find_section(i915, BDB_EDP);\n\tif (!edp)\n\t\treturn;\n\n\tswitch (panel_bits(edp->color_depth, panel_type, 2)) {\n\tcase EDP_18BPP:\n\t\tpanel->vbt.edp.bpp = 18;\n\t\tbreak;\n\tcase EDP_24BPP:\n\t\tpanel->vbt.edp.bpp = 24;\n\t\tbreak;\n\tcase EDP_30BPP:\n\t\tpanel->vbt.edp.bpp = 30;\n\t\tbreak;\n\t}\n\n\t \n\tedp_pps = &edp->power_seqs[panel_type];\n\tedp_link_params = &edp->fast_link_params[panel_type];\n\n\tpanel->vbt.edp.pps = *edp_pps;\n\n\tif (i915->display.vbt.version >= 224) {\n\t\tpanel->vbt.edp.rate =\n\t\t\tedp->edp_fast_link_training_rate[panel_type] * 20;\n\t} else {\n\t\tswitch (edp_link_params->rate) {\n\t\tcase EDP_RATE_1_62:\n\t\t\tpanel->vbt.edp.rate = 162000;\n\t\t\tbreak;\n\t\tcase EDP_RATE_2_7:\n\t\t\tpanel->vbt.edp.rate = 270000;\n\t\t\tbreak;\n\t\tcase EDP_RATE_5_4:\n\t\t\tpanel->vbt.edp.rate = 540000;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdrm_dbg_kms(&i915->drm,\n\t\t\t\t    \"VBT has unknown eDP link rate value %u\\n\",\n\t\t\t\t    edp_link_params->rate);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tswitch (edp_link_params->lanes) {\n\tcase EDP_LANE_1:\n\t\tpanel->vbt.edp.lanes = 1;\n\t\tbreak;\n\tcase EDP_LANE_2:\n\t\tpanel->vbt.edp.lanes = 2;\n\t\tbreak;\n\tcase EDP_LANE_4:\n\t\tpanel->vbt.edp.lanes = 4;\n\t\tbreak;\n\tdefault:\n\t\tdrm_dbg_kms(&i915->drm,\n\t\t\t    \"VBT has unknown eDP lane count value %u\\n\",\n\t\t\t    edp_link_params->lanes);\n\t\tbreak;\n\t}\n\n\tswitch (edp_link_params->preemphasis) {\n\tcase EDP_PREEMPHASIS_NONE:\n\t\tpanel->vbt.edp.preemphasis = DP_TRAIN_PRE_EMPH_LEVEL_0;\n\t\tbreak;\n\tcase EDP_PREEMPHASIS_3_5dB:\n\t\tpanel->vbt.edp.preemphasis = DP_TRAIN_PRE_EMPH_LEVEL_1;\n\t\tbreak;\n\tcase EDP_PREEMPHASIS_6dB:\n\t\tpanel->vbt.edp.preemphasis = DP_TRAIN_PRE_EMPH_LEVEL_2;\n\t\tbreak;\n\tcase EDP_PREEMPHASIS_9_5dB:\n\t\tpanel->vbt.edp.preemphasis = DP_TRAIN_PRE_EMPH_LEVEL_3;\n\t\tbreak;\n\tdefault:\n\t\tdrm_dbg_kms(&i915->drm,\n\t\t\t    \"VBT has unknown eDP pre-emphasis value %u\\n\",\n\t\t\t    edp_link_params->preemphasis);\n\t\tbreak;\n\t}\n\n\tswitch (edp_link_params->vswing) {\n\tcase EDP_VSWING_0_4V:\n\t\tpanel->vbt.edp.vswing = DP_TRAIN_VOLTAGE_SWING_LEVEL_0;\n\t\tbreak;\n\tcase EDP_VSWING_0_6V:\n\t\tpanel->vbt.edp.vswing = DP_TRAIN_VOLTAGE_SWING_LEVEL_1;\n\t\tbreak;\n\tcase EDP_VSWING_0_8V:\n\t\tpanel->vbt.edp.vswing = DP_TRAIN_VOLTAGE_SWING_LEVEL_2;\n\t\tbreak;\n\tcase EDP_VSWING_1_2V:\n\t\tpanel->vbt.edp.vswing = DP_TRAIN_VOLTAGE_SWING_LEVEL_3;\n\t\tbreak;\n\tdefault:\n\t\tdrm_dbg_kms(&i915->drm,\n\t\t\t    \"VBT has unknown eDP voltage swing value %u\\n\",\n\t\t\t    edp_link_params->vswing);\n\t\tbreak;\n\t}\n\n\tif (i915->display.vbt.version >= 173) {\n\t\tu8 vswing;\n\n\t\t \n\t\tif (i915->params.edp_vswing) {\n\t\t\tpanel->vbt.edp.low_vswing =\n\t\t\t\ti915->params.edp_vswing == 1;\n\t\t} else {\n\t\t\tvswing = (edp->edp_vswing_preemph >> (panel_type * 4)) & 0xF;\n\t\t\tpanel->vbt.edp.low_vswing = vswing == 0;\n\t\t}\n\t}\n\n\tpanel->vbt.edp.drrs_msa_timing_delay =\n\t\tpanel_bits(edp->sdrrs_msa_timing_delay, panel_type, 2);\n\n\tif (i915->display.vbt.version >= 244)\n\t\tpanel->vbt.edp.max_link_rate =\n\t\t\tedp->edp_max_port_link_rate[panel_type] * 20;\n}\n\nstatic void\nparse_psr(struct drm_i915_private *i915,\n\t  struct intel_panel *panel)\n{\n\tconst struct bdb_psr *psr;\n\tconst struct psr_table *psr_table;\n\tint panel_type = panel->vbt.panel_type;\n\n\tpsr = bdb_find_section(i915, BDB_PSR);\n\tif (!psr) {\n\t\tdrm_dbg_kms(&i915->drm, \"No PSR BDB found.\\n\");\n\t\treturn;\n\t}\n\n\tpsr_table = &psr->psr_table[panel_type];\n\n\tpanel->vbt.psr.full_link = psr_table->full_link;\n\tpanel->vbt.psr.require_aux_wakeup = psr_table->require_aux_to_wakeup;\n\n\t \n\tpanel->vbt.psr.idle_frames = psr_table->idle_frames < 0 ? 0 :\n\t\tpsr_table->idle_frames > 15 ? 15 : psr_table->idle_frames;\n\n\t \n\tif (i915->display.vbt.version >= 205 &&\n\t    (DISPLAY_VER(i915) >= 9 && !IS_BROXTON(i915))) {\n\t\tswitch (psr_table->tp1_wakeup_time) {\n\t\tcase 0:\n\t\t\tpanel->vbt.psr.tp1_wakeup_time_us = 500;\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tpanel->vbt.psr.tp1_wakeup_time_us = 100;\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tpanel->vbt.psr.tp1_wakeup_time_us = 0;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdrm_dbg_kms(&i915->drm,\n\t\t\t\t    \"VBT tp1 wakeup time value %d is outside range[0-3], defaulting to max value 2500us\\n\",\n\t\t\t\t    psr_table->tp1_wakeup_time);\n\t\t\tfallthrough;\n\t\tcase 2:\n\t\t\tpanel->vbt.psr.tp1_wakeup_time_us = 2500;\n\t\t\tbreak;\n\t\t}\n\n\t\tswitch (psr_table->tp2_tp3_wakeup_time) {\n\t\tcase 0:\n\t\t\tpanel->vbt.psr.tp2_tp3_wakeup_time_us = 500;\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tpanel->vbt.psr.tp2_tp3_wakeup_time_us = 100;\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tpanel->vbt.psr.tp2_tp3_wakeup_time_us = 0;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdrm_dbg_kms(&i915->drm,\n\t\t\t\t    \"VBT tp2_tp3 wakeup time value %d is outside range[0-3], defaulting to max value 2500us\\n\",\n\t\t\t\t    psr_table->tp2_tp3_wakeup_time);\n\t\t\tfallthrough;\n\t\tcase 2:\n\t\t\tpanel->vbt.psr.tp2_tp3_wakeup_time_us = 2500;\n\t\tbreak;\n\t\t}\n\t} else {\n\t\tpanel->vbt.psr.tp1_wakeup_time_us = psr_table->tp1_wakeup_time * 100;\n\t\tpanel->vbt.psr.tp2_tp3_wakeup_time_us = psr_table->tp2_tp3_wakeup_time * 100;\n\t}\n\n\tif (i915->display.vbt.version >= 226) {\n\t\tu32 wakeup_time = psr->psr2_tp2_tp3_wakeup_time;\n\n\t\twakeup_time = panel_bits(wakeup_time, panel_type, 2);\n\t\tswitch (wakeup_time) {\n\t\tcase 0:\n\t\t\twakeup_time = 500;\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\twakeup_time = 100;\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\twakeup_time = 50;\n\t\t\tbreak;\n\t\tdefault:\n\t\tcase 2:\n\t\t\twakeup_time = 2500;\n\t\t\tbreak;\n\t\t}\n\t\tpanel->vbt.psr.psr2_tp2_tp3_wakeup_time_us = wakeup_time;\n\t} else {\n\t\t \n\t\tpanel->vbt.psr.psr2_tp2_tp3_wakeup_time_us = panel->vbt.psr.tp2_tp3_wakeup_time_us;\n\t}\n}\n\nstatic void parse_dsi_backlight_ports(struct drm_i915_private *i915,\n\t\t\t\t      struct intel_panel *panel,\n\t\t\t\t      enum port port)\n{\n\tenum port port_bc = DISPLAY_VER(i915) >= 11 ? PORT_B : PORT_C;\n\n\tif (!panel->vbt.dsi.config->dual_link || i915->display.vbt.version < 197) {\n\t\tpanel->vbt.dsi.bl_ports = BIT(port);\n\t\tif (panel->vbt.dsi.config->cabc_supported)\n\t\t\tpanel->vbt.dsi.cabc_ports = BIT(port);\n\n\t\treturn;\n\t}\n\n\tswitch (panel->vbt.dsi.config->dl_dcs_backlight_ports) {\n\tcase DL_DCS_PORT_A:\n\t\tpanel->vbt.dsi.bl_ports = BIT(PORT_A);\n\t\tbreak;\n\tcase DL_DCS_PORT_C:\n\t\tpanel->vbt.dsi.bl_ports = BIT(port_bc);\n\t\tbreak;\n\tdefault:\n\tcase DL_DCS_PORT_A_AND_C:\n\t\tpanel->vbt.dsi.bl_ports = BIT(PORT_A) | BIT(port_bc);\n\t\tbreak;\n\t}\n\n\tif (!panel->vbt.dsi.config->cabc_supported)\n\t\treturn;\n\n\tswitch (panel->vbt.dsi.config->dl_dcs_cabc_ports) {\n\tcase DL_DCS_PORT_A:\n\t\tpanel->vbt.dsi.cabc_ports = BIT(PORT_A);\n\t\tbreak;\n\tcase DL_DCS_PORT_C:\n\t\tpanel->vbt.dsi.cabc_ports = BIT(port_bc);\n\t\tbreak;\n\tdefault:\n\tcase DL_DCS_PORT_A_AND_C:\n\t\tpanel->vbt.dsi.cabc_ports =\n\t\t\t\t\tBIT(PORT_A) | BIT(port_bc);\n\t\tbreak;\n\t}\n}\n\nstatic void\nparse_mipi_config(struct drm_i915_private *i915,\n\t\t  struct intel_panel *panel)\n{\n\tconst struct bdb_mipi_config *start;\n\tconst struct mipi_config *config;\n\tconst struct mipi_pps_data *pps;\n\tint panel_type = panel->vbt.panel_type;\n\tenum port port;\n\n\t \n\tif (!intel_bios_is_dsi_present(i915, &port))\n\t\treturn;\n\n\t \n\tpanel->vbt.dsi.panel_id = MIPI_DSI_UNDEFINED_PANEL_ID;\n\n\t \n\n\t \n\tstart = bdb_find_section(i915, BDB_MIPI_CONFIG);\n\tif (!start) {\n\t\tdrm_dbg_kms(&i915->drm, \"No MIPI config BDB found\");\n\t\treturn;\n\t}\n\n\tdrm_dbg(&i915->drm, \"Found MIPI Config block, panel index = %d\\n\",\n\t\tpanel_type);\n\n\t \n\tconfig = &start->config[panel_type];\n\tpps = &start->pps[panel_type];\n\n\t \n\tpanel->vbt.dsi.config = kmemdup(config, sizeof(struct mipi_config), GFP_KERNEL);\n\tif (!panel->vbt.dsi.config)\n\t\treturn;\n\n\tpanel->vbt.dsi.pps = kmemdup(pps, sizeof(struct mipi_pps_data), GFP_KERNEL);\n\tif (!panel->vbt.dsi.pps) {\n\t\tkfree(panel->vbt.dsi.config);\n\t\treturn;\n\t}\n\n\tparse_dsi_backlight_ports(i915, panel, port);\n\n\t \n\tswitch (config->rotation) {\n\tcase ENABLE_ROTATION_0:\n\t\t \n\t\tpanel->vbt.dsi.orientation =\n\t\t\tDRM_MODE_PANEL_ORIENTATION_UNKNOWN;\n\t\tbreak;\n\tcase ENABLE_ROTATION_90:\n\t\tpanel->vbt.dsi.orientation =\n\t\t\tDRM_MODE_PANEL_ORIENTATION_RIGHT_UP;\n\t\tbreak;\n\tcase ENABLE_ROTATION_180:\n\t\tpanel->vbt.dsi.orientation =\n\t\t\tDRM_MODE_PANEL_ORIENTATION_BOTTOM_UP;\n\t\tbreak;\n\tcase ENABLE_ROTATION_270:\n\t\tpanel->vbt.dsi.orientation =\n\t\t\tDRM_MODE_PANEL_ORIENTATION_LEFT_UP;\n\t\tbreak;\n\t}\n\n\t \n\tpanel->vbt.dsi.panel_id = MIPI_DSI_GENERIC_PANEL_ID;\n}\n\n \nstatic const u8 *\nfind_panel_sequence_block(const struct bdb_mipi_sequence *sequence,\n\t\t\t  u16 panel_id, u32 *seq_size)\n{\n\tu32 total = get_blocksize(sequence);\n\tconst u8 *data = &sequence->data[0];\n\tu8 current_id;\n\tu32 current_size;\n\tint header_size = sequence->version >= 3 ? 5 : 3;\n\tint index = 0;\n\tint i;\n\n\t \n\tif (sequence->version >= 3)\n\t\tdata += 4;\n\n\tfor (i = 0; i < MAX_MIPI_CONFIGURATIONS && index < total; i++) {\n\t\tif (index + header_size > total) {\n\t\t\tDRM_ERROR(\"Invalid sequence block (header)\\n\");\n\t\t\treturn NULL;\n\t\t}\n\n\t\tcurrent_id = *(data + index);\n\t\tif (sequence->version >= 3)\n\t\t\tcurrent_size = *((const u32 *)(data + index + 1));\n\t\telse\n\t\t\tcurrent_size = *((const u16 *)(data + index + 1));\n\n\t\tindex += header_size;\n\n\t\tif (index + current_size > total) {\n\t\t\tDRM_ERROR(\"Invalid sequence block\\n\");\n\t\t\treturn NULL;\n\t\t}\n\n\t\tif (current_id == panel_id) {\n\t\t\t*seq_size = current_size;\n\t\t\treturn data + index;\n\t\t}\n\n\t\tindex += current_size;\n\t}\n\n\tDRM_ERROR(\"Sequence block detected but no valid configuration\\n\");\n\n\treturn NULL;\n}\n\nstatic int goto_next_sequence(const u8 *data, int index, int total)\n{\n\tu16 len;\n\n\t \n\tfor (index = index + 1; index < total; index += len) {\n\t\tu8 operation_byte = *(data + index);\n\t\tindex++;\n\n\t\tswitch (operation_byte) {\n\t\tcase MIPI_SEQ_ELEM_END:\n\t\t\treturn index;\n\t\tcase MIPI_SEQ_ELEM_SEND_PKT:\n\t\t\tif (index + 4 > total)\n\t\t\t\treturn 0;\n\n\t\t\tlen = *((const u16 *)(data + index + 2)) + 4;\n\t\t\tbreak;\n\t\tcase MIPI_SEQ_ELEM_DELAY:\n\t\t\tlen = 4;\n\t\t\tbreak;\n\t\tcase MIPI_SEQ_ELEM_GPIO:\n\t\t\tlen = 2;\n\t\t\tbreak;\n\t\tcase MIPI_SEQ_ELEM_I2C:\n\t\t\tif (index + 7 > total)\n\t\t\t\treturn 0;\n\t\t\tlen = *(data + index + 6) + 7;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tDRM_ERROR(\"Unknown operation byte\\n\");\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int goto_next_sequence_v3(const u8 *data, int index, int total)\n{\n\tint seq_end;\n\tu16 len;\n\tu32 size_of_sequence;\n\n\t \n\tif (total < 5) {\n\t\tDRM_ERROR(\"Too small sequence size\\n\");\n\t\treturn 0;\n\t}\n\n\t \n\tindex++;\n\n\t \n\tsize_of_sequence = *((const u32 *)(data + index));\n\tindex += 4;\n\n\tseq_end = index + size_of_sequence;\n\tif (seq_end > total) {\n\t\tDRM_ERROR(\"Invalid sequence size\\n\");\n\t\treturn 0;\n\t}\n\n\tfor (; index < total; index += len) {\n\t\tu8 operation_byte = *(data + index);\n\t\tindex++;\n\n\t\tif (operation_byte == MIPI_SEQ_ELEM_END) {\n\t\t\tif (index != seq_end) {\n\t\t\t\tDRM_ERROR(\"Invalid element structure\\n\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\treturn index;\n\t\t}\n\n\t\tlen = *(data + index);\n\t\tindex++;\n\n\t\t \n\t\tswitch (operation_byte) {\n\t\tcase MIPI_SEQ_ELEM_SEND_PKT:\n\t\tcase MIPI_SEQ_ELEM_DELAY:\n\t\tcase MIPI_SEQ_ELEM_GPIO:\n\t\tcase MIPI_SEQ_ELEM_I2C:\n\t\tcase MIPI_SEQ_ELEM_SPI:\n\t\tcase MIPI_SEQ_ELEM_PMIC:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tDRM_ERROR(\"Unknown operation byte %u\\n\",\n\t\t\t\t  operation_byte);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n \nstatic int get_init_otp_deassert_fragment_len(struct drm_i915_private *i915,\n\t\t\t\t\t      struct intel_panel *panel)\n{\n\tconst u8 *data = panel->vbt.dsi.sequence[MIPI_SEQ_INIT_OTP];\n\tint index, len;\n\n\tif (drm_WARN_ON(&i915->drm,\n\t\t\t!data || panel->vbt.dsi.seq_version != 1))\n\t\treturn 0;\n\n\t \n\tfor (index = 1; data[index] != MIPI_SEQ_ELEM_END; index += len) {\n\t\tswitch (data[index]) {\n\t\tcase MIPI_SEQ_ELEM_SEND_PKT:\n\t\t\treturn index == 1 ? 0 : index;\n\t\tcase MIPI_SEQ_ELEM_DELAY:\n\t\t\tlen = 5;  \n\t\t\tbreak;\n\t\tcase MIPI_SEQ_ELEM_GPIO:\n\t\t\tlen = 3;  \n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n \nstatic void fixup_mipi_sequences(struct drm_i915_private *i915,\n\t\t\t\t struct intel_panel *panel)\n{\n\tu8 *init_otp;\n\tint len;\n\n\t \n\tif (!IS_VALLEYVIEW(i915))\n\t\treturn;\n\n\t \n\tif (panel->vbt.dsi.config->is_cmd_mode ||\n\t    panel->vbt.dsi.seq_version != 1)\n\t\treturn;\n\n\t \n\tif (!panel->vbt.dsi.sequence[MIPI_SEQ_INIT_OTP] ||\n\t    !panel->vbt.dsi.sequence[MIPI_SEQ_ASSERT_RESET] ||\n\t    panel->vbt.dsi.sequence[MIPI_SEQ_DEASSERT_RESET])\n\t\treturn;\n\n\t \n\tlen = get_init_otp_deassert_fragment_len(i915, panel);\n\tif (!len)\n\t\treturn;\n\n\tdrm_dbg_kms(&i915->drm,\n\t\t    \"Using init OTP fragment to deassert reset\\n\");\n\n\t \n\tinit_otp = (u8 *)panel->vbt.dsi.sequence[MIPI_SEQ_INIT_OTP];\n\tpanel->vbt.dsi.deassert_seq = kmemdup(init_otp, len + 1, GFP_KERNEL);\n\tif (!panel->vbt.dsi.deassert_seq)\n\t\treturn;\n\tpanel->vbt.dsi.deassert_seq[0] = MIPI_SEQ_DEASSERT_RESET;\n\tpanel->vbt.dsi.deassert_seq[len] = MIPI_SEQ_ELEM_END;\n\t \n\tpanel->vbt.dsi.sequence[MIPI_SEQ_DEASSERT_RESET] =\n\t\tpanel->vbt.dsi.deassert_seq;\n\t \n\tinit_otp[len - 1] = MIPI_SEQ_INIT_OTP;\n\t \n\tpanel->vbt.dsi.sequence[MIPI_SEQ_INIT_OTP] = init_otp + len - 1;\n}\n\nstatic void\nparse_mipi_sequence(struct drm_i915_private *i915,\n\t\t    struct intel_panel *panel)\n{\n\tint panel_type = panel->vbt.panel_type;\n\tconst struct bdb_mipi_sequence *sequence;\n\tconst u8 *seq_data;\n\tu32 seq_size;\n\tu8 *data;\n\tint index = 0;\n\n\t \n\tif (panel->vbt.dsi.panel_id != MIPI_DSI_GENERIC_PANEL_ID)\n\t\treturn;\n\n\tsequence = bdb_find_section(i915, BDB_MIPI_SEQUENCE);\n\tif (!sequence) {\n\t\tdrm_dbg_kms(&i915->drm,\n\t\t\t    \"No MIPI Sequence found, parsing complete\\n\");\n\t\treturn;\n\t}\n\n\t \n\tif (sequence->version >= 4) {\n\t\tdrm_err(&i915->drm,\n\t\t\t\"Unable to parse MIPI Sequence Block v%u\\n\",\n\t\t\tsequence->version);\n\t\treturn;\n\t}\n\n\tdrm_dbg(&i915->drm, \"Found MIPI sequence block v%u\\n\",\n\t\tsequence->version);\n\n\tseq_data = find_panel_sequence_block(sequence, panel_type, &seq_size);\n\tif (!seq_data)\n\t\treturn;\n\n\tdata = kmemdup(seq_data, seq_size, GFP_KERNEL);\n\tif (!data)\n\t\treturn;\n\n\t \n\tfor (;;) {\n\t\tu8 seq_id = *(data + index);\n\t\tif (seq_id == MIPI_SEQ_END)\n\t\t\tbreak;\n\n\t\tif (seq_id >= MIPI_SEQ_MAX) {\n\t\t\tdrm_err(&i915->drm, \"Unknown sequence %u\\n\",\n\t\t\t\tseq_id);\n\t\t\tgoto err;\n\t\t}\n\n\t\t \n\t\tif (seq_id == MIPI_SEQ_TEAR_ON || seq_id == MIPI_SEQ_TEAR_OFF)\n\t\t\tdrm_dbg_kms(&i915->drm,\n\t\t\t\t    \"Unsupported sequence %u\\n\", seq_id);\n\n\t\tpanel->vbt.dsi.sequence[seq_id] = data + index;\n\n\t\tif (sequence->version >= 3)\n\t\t\tindex = goto_next_sequence_v3(data, index, seq_size);\n\t\telse\n\t\t\tindex = goto_next_sequence(data, index, seq_size);\n\t\tif (!index) {\n\t\t\tdrm_err(&i915->drm, \"Invalid sequence %u\\n\",\n\t\t\t\tseq_id);\n\t\t\tgoto err;\n\t\t}\n\t}\n\n\tpanel->vbt.dsi.data = data;\n\tpanel->vbt.dsi.size = seq_size;\n\tpanel->vbt.dsi.seq_version = sequence->version;\n\n\tfixup_mipi_sequences(i915, panel);\n\n\tdrm_dbg(&i915->drm, \"MIPI related VBT parsing complete\\n\");\n\treturn;\n\nerr:\n\tkfree(data);\n\tmemset(panel->vbt.dsi.sequence, 0, sizeof(panel->vbt.dsi.sequence));\n}\n\nstatic void\nparse_compression_parameters(struct drm_i915_private *i915)\n{\n\tconst struct bdb_compression_parameters *params;\n\tstruct intel_bios_encoder_data *devdata;\n\tu16 block_size;\n\tint index;\n\n\tif (i915->display.vbt.version < 198)\n\t\treturn;\n\n\tparams = bdb_find_section(i915, BDB_COMPRESSION_PARAMETERS);\n\tif (params) {\n\t\t \n\t\tif (params->entry_size != sizeof(params->data[0])) {\n\t\t\tdrm_dbg_kms(&i915->drm,\n\t\t\t\t    \"VBT: unsupported compression param entry size\\n\");\n\t\t\treturn;\n\t\t}\n\n\t\tblock_size = get_blocksize(params);\n\t\tif (block_size < sizeof(*params)) {\n\t\t\tdrm_dbg_kms(&i915->drm,\n\t\t\t\t    \"VBT: expected 16 compression param entries\\n\");\n\t\t\treturn;\n\t\t}\n\t}\n\n\tlist_for_each_entry(devdata, &i915->display.vbt.display_devices, node) {\n\t\tconst struct child_device_config *child = &devdata->child;\n\n\t\tif (!child->compression_enable)\n\t\t\tcontinue;\n\n\t\tif (!params) {\n\t\t\tdrm_dbg_kms(&i915->drm,\n\t\t\t\t    \"VBT: compression params not available\\n\");\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (child->compression_method_cps) {\n\t\t\tdrm_dbg_kms(&i915->drm,\n\t\t\t\t    \"VBT: CPS compression not supported\\n\");\n\t\t\tcontinue;\n\t\t}\n\n\t\tindex = child->compression_structure_index;\n\n\t\tdevdata->dsc = kmemdup(&params->data[index],\n\t\t\t\t       sizeof(*devdata->dsc), GFP_KERNEL);\n\t}\n}\n\nstatic u8 translate_iboost(u8 val)\n{\n\tstatic const u8 mapping[] = { 1, 3, 7 };  \n\n\tif (val >= ARRAY_SIZE(mapping)) {\n\t\tDRM_DEBUG_KMS(\"Unsupported I_boost value found in VBT (%d), display may not work properly\\n\", val);\n\t\treturn 0;\n\t}\n\treturn mapping[val];\n}\n\nstatic const u8 cnp_ddc_pin_map[] = {\n\t[0] = 0,  \n\t[GMBUS_PIN_1_BXT] = DDC_BUS_DDI_B,\n\t[GMBUS_PIN_2_BXT] = DDC_BUS_DDI_C,\n\t[GMBUS_PIN_4_CNP] = DDC_BUS_DDI_D,  \n\t[GMBUS_PIN_3_BXT] = DDC_BUS_DDI_F,  \n};\n\nstatic const u8 icp_ddc_pin_map[] = {\n\t[GMBUS_PIN_1_BXT] = ICL_DDC_BUS_DDI_A,\n\t[GMBUS_PIN_2_BXT] = ICL_DDC_BUS_DDI_B,\n\t[GMBUS_PIN_3_BXT] = TGL_DDC_BUS_DDI_C,\n\t[GMBUS_PIN_9_TC1_ICP] = ICL_DDC_BUS_PORT_1,\n\t[GMBUS_PIN_10_TC2_ICP] = ICL_DDC_BUS_PORT_2,\n\t[GMBUS_PIN_11_TC3_ICP] = ICL_DDC_BUS_PORT_3,\n\t[GMBUS_PIN_12_TC4_ICP] = ICL_DDC_BUS_PORT_4,\n\t[GMBUS_PIN_13_TC5_TGP] = TGL_DDC_BUS_PORT_5,\n\t[GMBUS_PIN_14_TC6_TGP] = TGL_DDC_BUS_PORT_6,\n};\n\nstatic const u8 rkl_pch_tgp_ddc_pin_map[] = {\n\t[GMBUS_PIN_1_BXT] = ICL_DDC_BUS_DDI_A,\n\t[GMBUS_PIN_2_BXT] = ICL_DDC_BUS_DDI_B,\n\t[GMBUS_PIN_9_TC1_ICP] = RKL_DDC_BUS_DDI_D,\n\t[GMBUS_PIN_10_TC2_ICP] = RKL_DDC_BUS_DDI_E,\n};\n\nstatic const u8 adls_ddc_pin_map[] = {\n\t[GMBUS_PIN_1_BXT] = ICL_DDC_BUS_DDI_A,\n\t[GMBUS_PIN_9_TC1_ICP] = ADLS_DDC_BUS_PORT_TC1,\n\t[GMBUS_PIN_10_TC2_ICP] = ADLS_DDC_BUS_PORT_TC2,\n\t[GMBUS_PIN_11_TC3_ICP] = ADLS_DDC_BUS_PORT_TC3,\n\t[GMBUS_PIN_12_TC4_ICP] = ADLS_DDC_BUS_PORT_TC4,\n};\n\nstatic const u8 gen9bc_tgp_ddc_pin_map[] = {\n\t[GMBUS_PIN_2_BXT] = DDC_BUS_DDI_B,\n\t[GMBUS_PIN_9_TC1_ICP] = DDC_BUS_DDI_C,\n\t[GMBUS_PIN_10_TC2_ICP] = DDC_BUS_DDI_D,\n};\n\nstatic const u8 adlp_ddc_pin_map[] = {\n\t[GMBUS_PIN_1_BXT] = ICL_DDC_BUS_DDI_A,\n\t[GMBUS_PIN_2_BXT] = ICL_DDC_BUS_DDI_B,\n\t[GMBUS_PIN_9_TC1_ICP] = ADLP_DDC_BUS_PORT_TC1,\n\t[GMBUS_PIN_10_TC2_ICP] = ADLP_DDC_BUS_PORT_TC2,\n\t[GMBUS_PIN_11_TC3_ICP] = ADLP_DDC_BUS_PORT_TC3,\n\t[GMBUS_PIN_12_TC4_ICP] = ADLP_DDC_BUS_PORT_TC4,\n};\n\nstatic u8 map_ddc_pin(struct drm_i915_private *i915, u8 vbt_pin)\n{\n\tconst u8 *ddc_pin_map;\n\tint i, n_entries;\n\n\tif (HAS_PCH_MTP(i915) || IS_ALDERLAKE_P(i915)) {\n\t\tddc_pin_map = adlp_ddc_pin_map;\n\t\tn_entries = ARRAY_SIZE(adlp_ddc_pin_map);\n\t} else if (IS_ALDERLAKE_S(i915)) {\n\t\tddc_pin_map = adls_ddc_pin_map;\n\t\tn_entries = ARRAY_SIZE(adls_ddc_pin_map);\n\t} else if (INTEL_PCH_TYPE(i915) >= PCH_DG1) {\n\t\treturn vbt_pin;\n\t} else if (IS_ROCKETLAKE(i915) && INTEL_PCH_TYPE(i915) == PCH_TGP) {\n\t\tddc_pin_map = rkl_pch_tgp_ddc_pin_map;\n\t\tn_entries = ARRAY_SIZE(rkl_pch_tgp_ddc_pin_map);\n\t} else if (HAS_PCH_TGP(i915) && DISPLAY_VER(i915) == 9) {\n\t\tddc_pin_map = gen9bc_tgp_ddc_pin_map;\n\t\tn_entries = ARRAY_SIZE(gen9bc_tgp_ddc_pin_map);\n\t} else if (INTEL_PCH_TYPE(i915) >= PCH_ICP) {\n\t\tddc_pin_map = icp_ddc_pin_map;\n\t\tn_entries = ARRAY_SIZE(icp_ddc_pin_map);\n\t} else if (HAS_PCH_CNP(i915)) {\n\t\tddc_pin_map = cnp_ddc_pin_map;\n\t\tn_entries = ARRAY_SIZE(cnp_ddc_pin_map);\n\t} else {\n\t\t \n\t\treturn vbt_pin;\n\t}\n\n\tfor (i = 0; i < n_entries; i++) {\n\t\tif (ddc_pin_map[i] == vbt_pin)\n\t\t\treturn i;\n\t}\n\n\tdrm_dbg_kms(&i915->drm,\n\t\t    \"Ignoring alternate pin: VBT claims DDC pin %d, which is not valid for this platform\\n\",\n\t\t    vbt_pin);\n\treturn 0;\n}\n\nstatic u8 dvo_port_type(u8 dvo_port)\n{\n\tswitch (dvo_port) {\n\tcase DVO_PORT_HDMIA:\n\tcase DVO_PORT_HDMIB:\n\tcase DVO_PORT_HDMIC:\n\tcase DVO_PORT_HDMID:\n\tcase DVO_PORT_HDMIE:\n\tcase DVO_PORT_HDMIF:\n\tcase DVO_PORT_HDMIG:\n\tcase DVO_PORT_HDMIH:\n\tcase DVO_PORT_HDMII:\n\t\treturn DVO_PORT_HDMIA;\n\tcase DVO_PORT_DPA:\n\tcase DVO_PORT_DPB:\n\tcase DVO_PORT_DPC:\n\tcase DVO_PORT_DPD:\n\tcase DVO_PORT_DPE:\n\tcase DVO_PORT_DPF:\n\tcase DVO_PORT_DPG:\n\tcase DVO_PORT_DPH:\n\tcase DVO_PORT_DPI:\n\t\treturn DVO_PORT_DPA;\n\tcase DVO_PORT_MIPIA:\n\tcase DVO_PORT_MIPIB:\n\tcase DVO_PORT_MIPIC:\n\tcase DVO_PORT_MIPID:\n\t\treturn DVO_PORT_MIPIA;\n\tdefault:\n\t\treturn dvo_port;\n\t}\n}\n\nstatic enum port __dvo_port_to_port(int n_ports, int n_dvo,\n\t\t\t\t    const int port_mapping[][3], u8 dvo_port)\n{\n\tenum port port;\n\tint i;\n\n\tfor (port = PORT_A; port < n_ports; port++) {\n\t\tfor (i = 0; i < n_dvo; i++) {\n\t\t\tif (port_mapping[port][i] == -1)\n\t\t\t\tbreak;\n\n\t\t\tif (dvo_port == port_mapping[port][i])\n\t\t\t\treturn port;\n\t\t}\n\t}\n\n\treturn PORT_NONE;\n}\n\nstatic enum port dvo_port_to_port(struct drm_i915_private *i915,\n\t\t\t\t  u8 dvo_port)\n{\n\t \n\tstatic const int port_mapping[][3] = {\n\t\t[PORT_A] = { DVO_PORT_HDMIA, DVO_PORT_DPA, -1 },\n\t\t[PORT_B] = { DVO_PORT_HDMIB, DVO_PORT_DPB, -1 },\n\t\t[PORT_C] = { DVO_PORT_HDMIC, DVO_PORT_DPC, -1 },\n\t\t[PORT_D] = { DVO_PORT_HDMID, DVO_PORT_DPD, -1 },\n\t\t[PORT_E] = { DVO_PORT_HDMIE, DVO_PORT_DPE, DVO_PORT_CRT },\n\t\t[PORT_F] = { DVO_PORT_HDMIF, DVO_PORT_DPF, -1 },\n\t\t[PORT_G] = { DVO_PORT_HDMIG, DVO_PORT_DPG, -1 },\n\t\t[PORT_H] = { DVO_PORT_HDMIH, DVO_PORT_DPH, -1 },\n\t\t[PORT_I] = { DVO_PORT_HDMII, DVO_PORT_DPI, -1 },\n\t};\n\t \n\tstatic const int rkl_port_mapping[][3] = {\n\t\t[PORT_A] = { DVO_PORT_HDMIA, DVO_PORT_DPA, -1 },\n\t\t[PORT_B] = { DVO_PORT_HDMIB, DVO_PORT_DPB, -1 },\n\t\t[PORT_C] = { -1 },\n\t\t[PORT_TC1] = { DVO_PORT_HDMIC, DVO_PORT_DPC, -1 },\n\t\t[PORT_TC2] = { DVO_PORT_HDMID, DVO_PORT_DPD, -1 },\n\t};\n\t \n\tstatic const int adls_port_mapping[][3] = {\n\t\t[PORT_A] = { DVO_PORT_HDMIA, DVO_PORT_DPA, -1 },\n\t\t[PORT_B] = { -1 },\n\t\t[PORT_C] = { -1 },\n\t\t[PORT_TC1] = { DVO_PORT_HDMIB, DVO_PORT_DPB, -1 },\n\t\t[PORT_TC2] = { DVO_PORT_HDMIC, DVO_PORT_DPC, -1 },\n\t\t[PORT_TC3] = { DVO_PORT_HDMID, DVO_PORT_DPD, -1 },\n\t\t[PORT_TC4] = { DVO_PORT_HDMIE, DVO_PORT_DPE, -1 },\n\t};\n\tstatic const int xelpd_port_mapping[][3] = {\n\t\t[PORT_A] = { DVO_PORT_HDMIA, DVO_PORT_DPA, -1 },\n\t\t[PORT_B] = { DVO_PORT_HDMIB, DVO_PORT_DPB, -1 },\n\t\t[PORT_C] = { DVO_PORT_HDMIC, DVO_PORT_DPC, -1 },\n\t\t[PORT_D_XELPD] = { DVO_PORT_HDMID, DVO_PORT_DPD, -1 },\n\t\t[PORT_E_XELPD] = { DVO_PORT_HDMIE, DVO_PORT_DPE, -1 },\n\t\t[PORT_TC1] = { DVO_PORT_HDMIF, DVO_PORT_DPF, -1 },\n\t\t[PORT_TC2] = { DVO_PORT_HDMIG, DVO_PORT_DPG, -1 },\n\t\t[PORT_TC3] = { DVO_PORT_HDMIH, DVO_PORT_DPH, -1 },\n\t\t[PORT_TC4] = { DVO_PORT_HDMII, DVO_PORT_DPI, -1 },\n\t};\n\n\tif (DISPLAY_VER(i915) >= 13)\n\t\treturn __dvo_port_to_port(ARRAY_SIZE(xelpd_port_mapping),\n\t\t\t\t\t  ARRAY_SIZE(xelpd_port_mapping[0]),\n\t\t\t\t\t  xelpd_port_mapping,\n\t\t\t\t\t  dvo_port);\n\telse if (IS_ALDERLAKE_S(i915))\n\t\treturn __dvo_port_to_port(ARRAY_SIZE(adls_port_mapping),\n\t\t\t\t\t  ARRAY_SIZE(adls_port_mapping[0]),\n\t\t\t\t\t  adls_port_mapping,\n\t\t\t\t\t  dvo_port);\n\telse if (IS_DG1(i915) || IS_ROCKETLAKE(i915))\n\t\treturn __dvo_port_to_port(ARRAY_SIZE(rkl_port_mapping),\n\t\t\t\t\t  ARRAY_SIZE(rkl_port_mapping[0]),\n\t\t\t\t\t  rkl_port_mapping,\n\t\t\t\t\t  dvo_port);\n\telse\n\t\treturn __dvo_port_to_port(ARRAY_SIZE(port_mapping),\n\t\t\t\t\t  ARRAY_SIZE(port_mapping[0]),\n\t\t\t\t\t  port_mapping,\n\t\t\t\t\t  dvo_port);\n}\n\nstatic enum port\ndsi_dvo_port_to_port(struct drm_i915_private *i915, u8 dvo_port)\n{\n\tswitch (dvo_port) {\n\tcase DVO_PORT_MIPIA:\n\t\treturn PORT_A;\n\tcase DVO_PORT_MIPIC:\n\t\tif (DISPLAY_VER(i915) >= 11)\n\t\t\treturn PORT_B;\n\t\telse\n\t\t\treturn PORT_C;\n\tdefault:\n\t\treturn PORT_NONE;\n\t}\n}\n\nenum port intel_bios_encoder_port(const struct intel_bios_encoder_data *devdata)\n{\n\tstruct drm_i915_private *i915 = devdata->i915;\n\tconst struct child_device_config *child = &devdata->child;\n\tenum port port;\n\n\tport = dvo_port_to_port(i915, child->dvo_port);\n\tif (port == PORT_NONE && DISPLAY_VER(i915) >= 11)\n\t\tport = dsi_dvo_port_to_port(i915, child->dvo_port);\n\n\treturn port;\n}\n\nstatic int parse_bdb_230_dp_max_link_rate(const int vbt_max_link_rate)\n{\n\tswitch (vbt_max_link_rate) {\n\tdefault:\n\tcase BDB_230_VBT_DP_MAX_LINK_RATE_DEF:\n\t\treturn 0;\n\tcase BDB_230_VBT_DP_MAX_LINK_RATE_UHBR20:\n\t\treturn 2000000;\n\tcase BDB_230_VBT_DP_MAX_LINK_RATE_UHBR13P5:\n\t\treturn 1350000;\n\tcase BDB_230_VBT_DP_MAX_LINK_RATE_UHBR10:\n\t\treturn 1000000;\n\tcase BDB_230_VBT_DP_MAX_LINK_RATE_HBR3:\n\t\treturn 810000;\n\tcase BDB_230_VBT_DP_MAX_LINK_RATE_HBR2:\n\t\treturn 540000;\n\tcase BDB_230_VBT_DP_MAX_LINK_RATE_HBR:\n\t\treturn 270000;\n\tcase BDB_230_VBT_DP_MAX_LINK_RATE_LBR:\n\t\treturn 162000;\n\t}\n}\n\nstatic int parse_bdb_216_dp_max_link_rate(const int vbt_max_link_rate)\n{\n\tswitch (vbt_max_link_rate) {\n\tdefault:\n\tcase BDB_216_VBT_DP_MAX_LINK_RATE_HBR3:\n\t\treturn 810000;\n\tcase BDB_216_VBT_DP_MAX_LINK_RATE_HBR2:\n\t\treturn 540000;\n\tcase BDB_216_VBT_DP_MAX_LINK_RATE_HBR:\n\t\treturn 270000;\n\tcase BDB_216_VBT_DP_MAX_LINK_RATE_LBR:\n\t\treturn 162000;\n\t}\n}\n\nint intel_bios_dp_max_link_rate(const struct intel_bios_encoder_data *devdata)\n{\n\tif (!devdata || devdata->i915->display.vbt.version < 216)\n\t\treturn 0;\n\n\tif (devdata->i915->display.vbt.version >= 230)\n\t\treturn parse_bdb_230_dp_max_link_rate(devdata->child.dp_max_link_rate);\n\telse\n\t\treturn parse_bdb_216_dp_max_link_rate(devdata->child.dp_max_link_rate);\n}\n\nint intel_bios_dp_max_lane_count(const struct intel_bios_encoder_data *devdata)\n{\n\tif (!devdata || devdata->i915->display.vbt.version < 244)\n\t\treturn 0;\n\n\treturn devdata->child.dp_max_lane_count + 1;\n}\n\nstatic void sanitize_device_type(struct intel_bios_encoder_data *devdata,\n\t\t\t\t enum port port)\n{\n\tstruct drm_i915_private *i915 = devdata->i915;\n\tbool is_hdmi;\n\n\tif (port != PORT_A || DISPLAY_VER(i915) >= 12)\n\t\treturn;\n\n\tif (!intel_bios_encoder_supports_dvi(devdata))\n\t\treturn;\n\n\tis_hdmi = intel_bios_encoder_supports_hdmi(devdata);\n\n\tdrm_dbg_kms(&i915->drm, \"VBT claims port A supports DVI%s, ignoring\\n\",\n\t\t    is_hdmi ? \"/HDMI\" : \"\");\n\n\tdevdata->child.device_type &= ~DEVICE_TYPE_TMDS_DVI_SIGNALING;\n\tdevdata->child.device_type |= DEVICE_TYPE_NOT_HDMI_OUTPUT;\n}\n\nstatic bool\nintel_bios_encoder_supports_crt(const struct intel_bios_encoder_data *devdata)\n{\n\treturn devdata->child.device_type & DEVICE_TYPE_ANALOG_OUTPUT;\n}\n\nbool\nintel_bios_encoder_supports_dvi(const struct intel_bios_encoder_data *devdata)\n{\n\treturn devdata->child.device_type & DEVICE_TYPE_TMDS_DVI_SIGNALING;\n}\n\nbool\nintel_bios_encoder_supports_hdmi(const struct intel_bios_encoder_data *devdata)\n{\n\treturn intel_bios_encoder_supports_dvi(devdata) &&\n\t\t(devdata->child.device_type & DEVICE_TYPE_NOT_HDMI_OUTPUT) == 0;\n}\n\nbool\nintel_bios_encoder_supports_dp(const struct intel_bios_encoder_data *devdata)\n{\n\treturn devdata->child.device_type & DEVICE_TYPE_DISPLAYPORT_OUTPUT;\n}\n\nbool\nintel_bios_encoder_supports_edp(const struct intel_bios_encoder_data *devdata)\n{\n\treturn intel_bios_encoder_supports_dp(devdata) &&\n\t\tdevdata->child.device_type & DEVICE_TYPE_INTERNAL_CONNECTOR;\n}\n\nbool\nintel_bios_encoder_supports_dsi(const struct intel_bios_encoder_data *devdata)\n{\n\treturn devdata->child.device_type & DEVICE_TYPE_MIPI_OUTPUT;\n}\n\nbool\nintel_bios_encoder_is_lspcon(const struct intel_bios_encoder_data *devdata)\n{\n\treturn devdata && HAS_LSPCON(devdata->i915) && devdata->child.lspcon;\n}\n\n \nint intel_bios_hdmi_level_shift(const struct intel_bios_encoder_data *devdata)\n{\n\tif (!devdata || devdata->i915->display.vbt.version < 158 ||\n\t    DISPLAY_VER(devdata->i915) >= 14)\n\t\treturn -1;\n\n\treturn devdata->child.hdmi_level_shifter_value;\n}\n\nint intel_bios_hdmi_max_tmds_clock(const struct intel_bios_encoder_data *devdata)\n{\n\tif (!devdata || devdata->i915->display.vbt.version < 204)\n\t\treturn 0;\n\n\tswitch (devdata->child.hdmi_max_data_rate) {\n\tdefault:\n\t\tMISSING_CASE(devdata->child.hdmi_max_data_rate);\n\t\tfallthrough;\n\tcase HDMI_MAX_DATA_RATE_PLATFORM:\n\t\treturn 0;\n\tcase HDMI_MAX_DATA_RATE_594:\n\t\treturn 594000;\n\tcase HDMI_MAX_DATA_RATE_340:\n\t\treturn 340000;\n\tcase HDMI_MAX_DATA_RATE_300:\n\t\treturn 300000;\n\tcase HDMI_MAX_DATA_RATE_297:\n\t\treturn 297000;\n\tcase HDMI_MAX_DATA_RATE_165:\n\t\treturn 165000;\n\t}\n}\n\nstatic bool is_port_valid(struct drm_i915_private *i915, enum port port)\n{\n\t \n\tif (port == PORT_F && IS_ICELAKE(i915))\n\t\treturn IS_ICL_WITH_PORT_F(i915);\n\n\treturn true;\n}\n\nstatic void print_ddi_port(const struct intel_bios_encoder_data *devdata)\n{\n\tstruct drm_i915_private *i915 = devdata->i915;\n\tconst struct child_device_config *child = &devdata->child;\n\tbool is_dvi, is_hdmi, is_dp, is_edp, is_dsi, is_crt, supports_typec_usb, supports_tbt;\n\tint dp_boost_level, dp_max_link_rate, hdmi_boost_level, hdmi_level_shift, max_tmds_clock;\n\tenum port port;\n\n\tport = intel_bios_encoder_port(devdata);\n\tif (port == PORT_NONE)\n\t\treturn;\n\n\tis_dvi = intel_bios_encoder_supports_dvi(devdata);\n\tis_dp = intel_bios_encoder_supports_dp(devdata);\n\tis_crt = intel_bios_encoder_supports_crt(devdata);\n\tis_hdmi = intel_bios_encoder_supports_hdmi(devdata);\n\tis_edp = intel_bios_encoder_supports_edp(devdata);\n\tis_dsi = intel_bios_encoder_supports_dsi(devdata);\n\n\tsupports_typec_usb = intel_bios_encoder_supports_typec_usb(devdata);\n\tsupports_tbt = intel_bios_encoder_supports_tbt(devdata);\n\n\tdrm_dbg_kms(&i915->drm,\n\t\t    \"Port %c VBT info: CRT:%d DVI:%d HDMI:%d DP:%d eDP:%d DSI:%d DP++:%d LSPCON:%d USB-Type-C:%d TBT:%d DSC:%d\\n\",\n\t\t    port_name(port), is_crt, is_dvi, is_hdmi, is_dp, is_edp, is_dsi,\n\t\t    intel_bios_encoder_supports_dp_dual_mode(devdata),\n\t\t    intel_bios_encoder_is_lspcon(devdata),\n\t\t    supports_typec_usb, supports_tbt,\n\t\t    devdata->dsc != NULL);\n\n\thdmi_level_shift = intel_bios_hdmi_level_shift(devdata);\n\tif (hdmi_level_shift >= 0) {\n\t\tdrm_dbg_kms(&i915->drm,\n\t\t\t    \"Port %c VBT HDMI level shift: %d\\n\",\n\t\t\t    port_name(port), hdmi_level_shift);\n\t}\n\n\tmax_tmds_clock = intel_bios_hdmi_max_tmds_clock(devdata);\n\tif (max_tmds_clock)\n\t\tdrm_dbg_kms(&i915->drm,\n\t\t\t    \"Port %c VBT HDMI max TMDS clock: %d kHz\\n\",\n\t\t\t    port_name(port), max_tmds_clock);\n\n\t \n\tdp_boost_level = intel_bios_dp_boost_level(devdata);\n\tif (dp_boost_level)\n\t\tdrm_dbg_kms(&i915->drm,\n\t\t\t    \"Port %c VBT (e)DP boost level: %d\\n\",\n\t\t\t    port_name(port), dp_boost_level);\n\n\thdmi_boost_level = intel_bios_hdmi_boost_level(devdata);\n\tif (hdmi_boost_level)\n\t\tdrm_dbg_kms(&i915->drm,\n\t\t\t    \"Port %c VBT HDMI boost level: %d\\n\",\n\t\t\t    port_name(port), hdmi_boost_level);\n\n\tdp_max_link_rate = intel_bios_dp_max_link_rate(devdata);\n\tif (dp_max_link_rate)\n\t\tdrm_dbg_kms(&i915->drm,\n\t\t\t    \"Port %c VBT DP max link rate: %d\\n\",\n\t\t\t    port_name(port), dp_max_link_rate);\n\n\t \n\tdrm_WARN(&i915->drm, child->use_vbt_vswing,\n\t\t \"Port %c asks to use VBT vswing/preemph tables\\n\",\n\t\t port_name(port));\n}\n\nstatic void parse_ddi_port(struct intel_bios_encoder_data *devdata)\n{\n\tstruct drm_i915_private *i915 = devdata->i915;\n\tenum port port;\n\n\tport = intel_bios_encoder_port(devdata);\n\tif (port == PORT_NONE)\n\t\treturn;\n\n\tif (!is_port_valid(i915, port)) {\n\t\tdrm_dbg_kms(&i915->drm,\n\t\t\t    \"VBT reports port %c as supported, but that can't be true: skipping\\n\",\n\t\t\t    port_name(port));\n\t\treturn;\n\t}\n\n\tsanitize_device_type(devdata, port);\n}\n\nstatic bool has_ddi_port_info(struct drm_i915_private *i915)\n{\n\treturn DISPLAY_VER(i915) >= 5 || IS_G4X(i915);\n}\n\nstatic void parse_ddi_ports(struct drm_i915_private *i915)\n{\n\tstruct intel_bios_encoder_data *devdata;\n\n\tif (!has_ddi_port_info(i915))\n\t\treturn;\n\n\tlist_for_each_entry(devdata, &i915->display.vbt.display_devices, node)\n\t\tparse_ddi_port(devdata);\n\n\tlist_for_each_entry(devdata, &i915->display.vbt.display_devices, node)\n\t\tprint_ddi_port(devdata);\n}\n\nstatic void\nparse_general_definitions(struct drm_i915_private *i915)\n{\n\tconst struct bdb_general_definitions *defs;\n\tstruct intel_bios_encoder_data *devdata;\n\tconst struct child_device_config *child;\n\tint i, child_device_num;\n\tu8 expected_size;\n\tu16 block_size;\n\tint bus_pin;\n\n\tdefs = bdb_find_section(i915, BDB_GENERAL_DEFINITIONS);\n\tif (!defs) {\n\t\tdrm_dbg_kms(&i915->drm,\n\t\t\t    \"No general definition block is found, no devices defined.\\n\");\n\t\treturn;\n\t}\n\n\tblock_size = get_blocksize(defs);\n\tif (block_size < sizeof(*defs)) {\n\t\tdrm_dbg_kms(&i915->drm,\n\t\t\t    \"General definitions block too small (%u)\\n\",\n\t\t\t    block_size);\n\t\treturn;\n\t}\n\n\tbus_pin = defs->crt_ddc_gmbus_pin;\n\tdrm_dbg_kms(&i915->drm, \"crt_ddc_bus_pin: %d\\n\", bus_pin);\n\tif (intel_gmbus_is_valid_pin(i915, bus_pin))\n\t\ti915->display.vbt.crt_ddc_pin = bus_pin;\n\n\tif (i915->display.vbt.version < 106) {\n\t\texpected_size = 22;\n\t} else if (i915->display.vbt.version < 111) {\n\t\texpected_size = 27;\n\t} else if (i915->display.vbt.version < 195) {\n\t\texpected_size = LEGACY_CHILD_DEVICE_CONFIG_SIZE;\n\t} else if (i915->display.vbt.version == 195) {\n\t\texpected_size = 37;\n\t} else if (i915->display.vbt.version <= 215) {\n\t\texpected_size = 38;\n\t} else if (i915->display.vbt.version <= 250) {\n\t\texpected_size = 39;\n\t} else {\n\t\texpected_size = sizeof(*child);\n\t\tBUILD_BUG_ON(sizeof(*child) < 39);\n\t\tdrm_dbg(&i915->drm,\n\t\t\t\"Expected child device config size for VBT version %u not known; assuming %u\\n\",\n\t\t\ti915->display.vbt.version, expected_size);\n\t}\n\n\t \n\tif (defs->child_dev_size != expected_size)\n\t\tdrm_err(&i915->drm,\n\t\t\t\"Unexpected child device config size %u (expected %u for VBT version %u)\\n\",\n\t\t\tdefs->child_dev_size, expected_size, i915->display.vbt.version);\n\n\t \n\tif (defs->child_dev_size < LEGACY_CHILD_DEVICE_CONFIG_SIZE) {\n\t\tdrm_dbg_kms(&i915->drm,\n\t\t\t    \"Child device config size %u is too small.\\n\",\n\t\t\t    defs->child_dev_size);\n\t\treturn;\n\t}\n\n\t \n\tchild_device_num = (block_size - sizeof(*defs)) / defs->child_dev_size;\n\n\tfor (i = 0; i < child_device_num; i++) {\n\t\tchild = child_device_ptr(defs, i);\n\t\tif (!child->device_type)\n\t\t\tcontinue;\n\n\t\tdrm_dbg_kms(&i915->drm,\n\t\t\t    \"Found VBT child device with type 0x%x\\n\",\n\t\t\t    child->device_type);\n\n\t\tdevdata = kzalloc(sizeof(*devdata), GFP_KERNEL);\n\t\tif (!devdata)\n\t\t\tbreak;\n\n\t\tdevdata->i915 = i915;\n\n\t\t \n\t\tmemcpy(&devdata->child, child,\n\t\t       min_t(size_t, defs->child_dev_size, sizeof(*child)));\n\n\t\tlist_add_tail(&devdata->node, &i915->display.vbt.display_devices);\n\t}\n\n\tif (list_empty(&i915->display.vbt.display_devices))\n\t\tdrm_dbg_kms(&i915->drm,\n\t\t\t    \"no child dev is parsed from VBT\\n\");\n}\n\n \nstatic void\ninit_vbt_defaults(struct drm_i915_private *i915)\n{\n\ti915->display.vbt.crt_ddc_pin = GMBUS_PIN_VGADDC;\n\n\t \n\ti915->display.vbt.int_tv_support = 1;\n\ti915->display.vbt.int_crt_support = 1;\n\n\t \n\ti915->display.vbt.int_lvds_support = 1;\n\n\t \n\ti915->display.vbt.lvds_use_ssc = 1;\n\t \n\ti915->display.vbt.lvds_ssc_freq = intel_bios_ssc_frequency(i915,\n\t\t\t\t\t\t\t\t   !HAS_PCH_SPLIT(i915));\n\tdrm_dbg_kms(&i915->drm, \"Set default to SSC at %d kHz\\n\",\n\t\t    i915->display.vbt.lvds_ssc_freq);\n}\n\n \nstatic void\ninit_vbt_panel_defaults(struct intel_panel *panel)\n{\n\t \n\tpanel->vbt.backlight.present = true;\n\n\t \n\tpanel->vbt.lvds_dither = true;\n}\n\n \nstatic void\ninit_vbt_missing_defaults(struct drm_i915_private *i915)\n{\n\tenum port port;\n\tint ports = BIT(PORT_A) | BIT(PORT_B) | BIT(PORT_C) |\n\t\t    BIT(PORT_D) | BIT(PORT_E) | BIT(PORT_F);\n\n\tif (!HAS_DDI(i915) && !IS_CHERRYVIEW(i915))\n\t\treturn;\n\n\tfor_each_port_masked(port, ports) {\n\t\tstruct intel_bios_encoder_data *devdata;\n\t\tstruct child_device_config *child;\n\t\tenum phy phy = intel_port_to_phy(i915, port);\n\n\t\t \n\t\tif (intel_phy_is_tc(i915, phy))\n\t\t\tcontinue;\n\n\t\t \n\t\tdevdata = kzalloc(sizeof(*devdata), GFP_KERNEL);\n\t\tif (!devdata)\n\t\t\tbreak;\n\n\t\tdevdata->i915 = i915;\n\t\tchild = &devdata->child;\n\n\t\tif (port == PORT_F)\n\t\t\tchild->dvo_port = DVO_PORT_HDMIF;\n\t\telse if (port == PORT_E)\n\t\t\tchild->dvo_port = DVO_PORT_HDMIE;\n\t\telse\n\t\t\tchild->dvo_port = DVO_PORT_HDMIA + port;\n\n\t\tif (port != PORT_A && port != PORT_E)\n\t\t\tchild->device_type |= DEVICE_TYPE_TMDS_DVI_SIGNALING;\n\n\t\tif (port != PORT_E)\n\t\t\tchild->device_type |= DEVICE_TYPE_DISPLAYPORT_OUTPUT;\n\n\t\tif (port == PORT_A)\n\t\t\tchild->device_type |= DEVICE_TYPE_INTERNAL_CONNECTOR;\n\n\t\tlist_add_tail(&devdata->node, &i915->display.vbt.display_devices);\n\n\t\tdrm_dbg_kms(&i915->drm,\n\t\t\t    \"Generating default VBT child device with type 0x04%x on port %c\\n\",\n\t\t\t    child->device_type, port_name(port));\n\t}\n\n\t \n\ti915->display.vbt.version = 155;\n}\n\nstatic const struct bdb_header *get_bdb_header(const struct vbt_header *vbt)\n{\n\tconst void *_vbt = vbt;\n\n\treturn _vbt + vbt->bdb_offset;\n}\n\n \nbool intel_bios_is_valid_vbt(const void *buf, size_t size)\n{\n\tconst struct vbt_header *vbt = buf;\n\tconst struct bdb_header *bdb;\n\n\tif (!vbt)\n\t\treturn false;\n\n\tif (sizeof(struct vbt_header) > size) {\n\t\tDRM_DEBUG_DRIVER(\"VBT header incomplete\\n\");\n\t\treturn false;\n\t}\n\n\tif (memcmp(vbt->signature, \"$VBT\", 4)) {\n\t\tDRM_DEBUG_DRIVER(\"VBT invalid signature\\n\");\n\t\treturn false;\n\t}\n\n\tif (vbt->vbt_size > size) {\n\t\tDRM_DEBUG_DRIVER(\"VBT incomplete (vbt_size overflows)\\n\");\n\t\treturn false;\n\t}\n\n\tsize = vbt->vbt_size;\n\n\tif (range_overflows_t(size_t,\n\t\t\t      vbt->bdb_offset,\n\t\t\t      sizeof(struct bdb_header),\n\t\t\t      size)) {\n\t\tDRM_DEBUG_DRIVER(\"BDB header incomplete\\n\");\n\t\treturn false;\n\t}\n\n\tbdb = get_bdb_header(vbt);\n\tif (range_overflows_t(size_t, vbt->bdb_offset, bdb->bdb_size, size)) {\n\t\tDRM_DEBUG_DRIVER(\"BDB incomplete\\n\");\n\t\treturn false;\n\t}\n\n\treturn vbt;\n}\n\nstatic u32 intel_spi_read(struct intel_uncore *uncore, u32 offset)\n{\n\tintel_uncore_write(uncore, PRIMARY_SPI_ADDRESS, offset);\n\n\treturn intel_uncore_read(uncore, PRIMARY_SPI_TRIGGER);\n}\n\nstatic struct vbt_header *spi_oprom_get_vbt(struct drm_i915_private *i915)\n{\n\tu32 count, data, found, store = 0;\n\tu32 static_region, oprom_offset;\n\tu32 oprom_size = 0x200000;\n\tu16 vbt_size;\n\tu32 *vbt;\n\n\tstatic_region = intel_uncore_read(&i915->uncore, SPI_STATIC_REGIONS);\n\tstatic_region &= OPTIONROM_SPI_REGIONID_MASK;\n\tintel_uncore_write(&i915->uncore, PRIMARY_SPI_REGIONID, static_region);\n\n\toprom_offset = intel_uncore_read(&i915->uncore, OROM_OFFSET);\n\toprom_offset &= OROM_OFFSET_MASK;\n\n\tfor (count = 0; count < oprom_size; count += 4) {\n\t\tdata = intel_spi_read(&i915->uncore, oprom_offset + count);\n\t\tif (data == *((const u32 *)\"$VBT\")) {\n\t\t\tfound = oprom_offset + count;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (count >= oprom_size)\n\t\tgoto err_not_found;\n\n\t \n\tvbt_size = intel_spi_read(&i915->uncore,\n\t\t\t\t  found + offsetof(struct vbt_header, vbt_size));\n\tvbt_size &= 0xffff;\n\n\tvbt = kzalloc(round_up(vbt_size, 4), GFP_KERNEL);\n\tif (!vbt)\n\t\tgoto err_not_found;\n\n\tfor (count = 0; count < vbt_size; count += 4)\n\t\t*(vbt + store++) = intel_spi_read(&i915->uncore, found + count);\n\n\tif (!intel_bios_is_valid_vbt(vbt, vbt_size))\n\t\tgoto err_free_vbt;\n\n\tdrm_dbg_kms(&i915->drm, \"Found valid VBT in SPI flash\\n\");\n\n\treturn (struct vbt_header *)vbt;\n\nerr_free_vbt:\n\tkfree(vbt);\nerr_not_found:\n\treturn NULL;\n}\n\nstatic struct vbt_header *oprom_get_vbt(struct drm_i915_private *i915)\n{\n\tstruct pci_dev *pdev = to_pci_dev(i915->drm.dev);\n\tvoid __iomem *p = NULL, *oprom;\n\tstruct vbt_header *vbt;\n\tu16 vbt_size;\n\tsize_t i, size;\n\n\toprom = pci_map_rom(pdev, &size);\n\tif (!oprom)\n\t\treturn NULL;\n\n\t \n\tfor (i = 0; i + 4 < size; i += 4) {\n\t\tif (ioread32(oprom + i) != *((const u32 *)\"$VBT\"))\n\t\t\tcontinue;\n\n\t\tp = oprom + i;\n\t\tsize -= i;\n\t\tbreak;\n\t}\n\n\tif (!p)\n\t\tgoto err_unmap_oprom;\n\n\tif (sizeof(struct vbt_header) > size) {\n\t\tdrm_dbg(&i915->drm, \"VBT header incomplete\\n\");\n\t\tgoto err_unmap_oprom;\n\t}\n\n\tvbt_size = ioread16(p + offsetof(struct vbt_header, vbt_size));\n\tif (vbt_size > size) {\n\t\tdrm_dbg(&i915->drm,\n\t\t\t\"VBT incomplete (vbt_size overflows)\\n\");\n\t\tgoto err_unmap_oprom;\n\t}\n\n\t \n\tvbt = kmalloc(vbt_size, GFP_KERNEL);\n\tif (!vbt)\n\t\tgoto err_unmap_oprom;\n\n\tmemcpy_fromio(vbt, p, vbt_size);\n\n\tif (!intel_bios_is_valid_vbt(vbt, vbt_size))\n\t\tgoto err_free_vbt;\n\n\tpci_unmap_rom(pdev, oprom);\n\n\tdrm_dbg_kms(&i915->drm, \"Found valid VBT in PCI ROM\\n\");\n\n\treturn vbt;\n\nerr_free_vbt:\n\tkfree(vbt);\nerr_unmap_oprom:\n\tpci_unmap_rom(pdev, oprom);\n\n\treturn NULL;\n}\n\n \nvoid intel_bios_init(struct drm_i915_private *i915)\n{\n\tconst struct vbt_header *vbt = i915->display.opregion.vbt;\n\tstruct vbt_header *oprom_vbt = NULL;\n\tconst struct bdb_header *bdb;\n\n\tINIT_LIST_HEAD(&i915->display.vbt.display_devices);\n\tINIT_LIST_HEAD(&i915->display.vbt.bdb_blocks);\n\n\tif (!HAS_DISPLAY(i915)) {\n\t\tdrm_dbg_kms(&i915->drm,\n\t\t\t    \"Skipping VBT init due to disabled display.\\n\");\n\t\treturn;\n\t}\n\n\tinit_vbt_defaults(i915);\n\n\t \n\tif (!vbt && IS_DGFX(i915)) {\n\t\toprom_vbt = spi_oprom_get_vbt(i915);\n\t\tvbt = oprom_vbt;\n\t}\n\n\tif (!vbt) {\n\t\toprom_vbt = oprom_get_vbt(i915);\n\t\tvbt = oprom_vbt;\n\t}\n\n\tif (!vbt)\n\t\tgoto out;\n\n\tbdb = get_bdb_header(vbt);\n\ti915->display.vbt.version = bdb->version;\n\n\tdrm_dbg_kms(&i915->drm,\n\t\t    \"VBT signature \\\"%.*s\\\", BDB version %d\\n\",\n\t\t    (int)sizeof(vbt->signature), vbt->signature, i915->display.vbt.version);\n\n\tinit_bdb_blocks(i915, bdb);\n\n\t \n\tparse_general_features(i915);\n\tparse_general_definitions(i915);\n\tparse_driver_features(i915);\n\n\t \n\tparse_compression_parameters(i915);\n\nout:\n\tif (!vbt) {\n\t\tdrm_info(&i915->drm,\n\t\t\t \"Failed to find VBIOS tables (VBT)\\n\");\n\t\tinit_vbt_missing_defaults(i915);\n\t}\n\n\t \n\tparse_sdvo_device_mapping(i915);\n\tparse_ddi_ports(i915);\n\n\tkfree(oprom_vbt);\n}\n\nstatic void intel_bios_init_panel(struct drm_i915_private *i915,\n\t\t\t\t  struct intel_panel *panel,\n\t\t\t\t  const struct intel_bios_encoder_data *devdata,\n\t\t\t\t  const struct drm_edid *drm_edid,\n\t\t\t\t  bool use_fallback)\n{\n\t \n\tif (panel->vbt.panel_type >= 0) {\n\t\tdrm_WARN_ON(&i915->drm, !use_fallback);\n\t\treturn;\n\t}\n\n\tpanel->vbt.panel_type = get_panel_type(i915, devdata,\n\t\t\t\t\t       drm_edid, use_fallback);\n\tif (panel->vbt.panel_type < 0) {\n\t\tdrm_WARN_ON(&i915->drm, use_fallback);\n\t\treturn;\n\t}\n\n\tinit_vbt_panel_defaults(panel);\n\n\tparse_panel_options(i915, panel);\n\tparse_generic_dtd(i915, panel);\n\tparse_lfp_data(i915, panel);\n\tparse_lfp_backlight(i915, panel);\n\tparse_sdvo_panel_data(i915, panel);\n\tparse_panel_driver_features(i915, panel);\n\tparse_power_conservation_features(i915, panel);\n\tparse_edp(i915, panel);\n\tparse_psr(i915, panel);\n\tparse_mipi_config(i915, panel);\n\tparse_mipi_sequence(i915, panel);\n}\n\nvoid intel_bios_init_panel_early(struct drm_i915_private *i915,\n\t\t\t\t struct intel_panel *panel,\n\t\t\t\t const struct intel_bios_encoder_data *devdata)\n{\n\tintel_bios_init_panel(i915, panel, devdata, NULL, false);\n}\n\nvoid intel_bios_init_panel_late(struct drm_i915_private *i915,\n\t\t\t\tstruct intel_panel *panel,\n\t\t\t\tconst struct intel_bios_encoder_data *devdata,\n\t\t\t\tconst struct drm_edid *drm_edid)\n{\n\tintel_bios_init_panel(i915, panel, devdata, drm_edid, true);\n}\n\n \nvoid intel_bios_driver_remove(struct drm_i915_private *i915)\n{\n\tstruct intel_bios_encoder_data *devdata, *nd;\n\tstruct bdb_block_entry *entry, *ne;\n\n\tlist_for_each_entry_safe(devdata, nd, &i915->display.vbt.display_devices, node) {\n\t\tlist_del(&devdata->node);\n\t\tkfree(devdata->dsc);\n\t\tkfree(devdata);\n\t}\n\n\tlist_for_each_entry_safe(entry, ne, &i915->display.vbt.bdb_blocks, node) {\n\t\tlist_del(&entry->node);\n\t\tkfree(entry);\n\t}\n}\n\nvoid intel_bios_fini_panel(struct intel_panel *panel)\n{\n\tkfree(panel->vbt.sdvo_lvds_vbt_mode);\n\tpanel->vbt.sdvo_lvds_vbt_mode = NULL;\n\tkfree(panel->vbt.lfp_lvds_vbt_mode);\n\tpanel->vbt.lfp_lvds_vbt_mode = NULL;\n\tkfree(panel->vbt.dsi.data);\n\tpanel->vbt.dsi.data = NULL;\n\tkfree(panel->vbt.dsi.pps);\n\tpanel->vbt.dsi.pps = NULL;\n\tkfree(panel->vbt.dsi.config);\n\tpanel->vbt.dsi.config = NULL;\n\tkfree(panel->vbt.dsi.deassert_seq);\n\tpanel->vbt.dsi.deassert_seq = NULL;\n}\n\n \nbool intel_bios_is_tv_present(struct drm_i915_private *i915)\n{\n\tconst struct intel_bios_encoder_data *devdata;\n\n\tif (!i915->display.vbt.int_tv_support)\n\t\treturn false;\n\n\tif (list_empty(&i915->display.vbt.display_devices))\n\t\treturn true;\n\n\tlist_for_each_entry(devdata, &i915->display.vbt.display_devices, node) {\n\t\tconst struct child_device_config *child = &devdata->child;\n\n\t\t \n\t\tswitch (child->device_type) {\n\t\tcase DEVICE_TYPE_INT_TV:\n\t\tcase DEVICE_TYPE_TV:\n\t\tcase DEVICE_TYPE_TV_SVIDEO_COMPOSITE:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tcontinue;\n\t\t}\n\t\t \n\t\tif (child->addin_offset)\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}\n\n \nbool intel_bios_is_lvds_present(struct drm_i915_private *i915, u8 *i2c_pin)\n{\n\tconst struct intel_bios_encoder_data *devdata;\n\n\tif (list_empty(&i915->display.vbt.display_devices))\n\t\treturn true;\n\n\tlist_for_each_entry(devdata, &i915->display.vbt.display_devices, node) {\n\t\tconst struct child_device_config *child = &devdata->child;\n\n\t\t \n\t\tif (child->device_type != DEVICE_TYPE_INT_LFP &&\n\t\t    child->device_type != DEVICE_TYPE_LFP)\n\t\t\tcontinue;\n\n\t\tif (intel_gmbus_is_valid_pin(i915, child->i2c_pin))\n\t\t\t*i2c_pin = child->i2c_pin;\n\n\t\t \n\t\tif (child->addin_offset)\n\t\t\treturn true;\n\n\t\t \n\t\tif (i915->display.opregion.vbt)\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}\n\n \nbool intel_bios_is_port_present(struct drm_i915_private *i915, enum port port)\n{\n\tconst struct intel_bios_encoder_data *devdata;\n\n\tif (WARN_ON(!has_ddi_port_info(i915)))\n\t\treturn true;\n\n\tif (!is_port_valid(i915, port))\n\t\treturn false;\n\n\tlist_for_each_entry(devdata, &i915->display.vbt.display_devices, node) {\n\t\tconst struct child_device_config *child = &devdata->child;\n\n\t\tif (dvo_port_to_port(i915, child->dvo_port) == port)\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}\n\nbool intel_bios_encoder_supports_dp_dual_mode(const struct intel_bios_encoder_data *devdata)\n{\n\tconst struct child_device_config *child = &devdata->child;\n\n\tif (!intel_bios_encoder_supports_dp(devdata) ||\n\t    !intel_bios_encoder_supports_hdmi(devdata))\n\t\treturn false;\n\n\tif (dvo_port_type(child->dvo_port) == DVO_PORT_DPA)\n\t\treturn true;\n\n\t \n\tif (dvo_port_type(child->dvo_port) == DVO_PORT_HDMIA &&\n\t    child->aux_channel != 0)\n\t\treturn true;\n\n\treturn false;\n}\n\n \nbool intel_bios_is_dsi_present(struct drm_i915_private *i915,\n\t\t\t       enum port *port)\n{\n\tconst struct intel_bios_encoder_data *devdata;\n\n\tlist_for_each_entry(devdata, &i915->display.vbt.display_devices, node) {\n\t\tconst struct child_device_config *child = &devdata->child;\n\t\tu8 dvo_port = child->dvo_port;\n\n\t\tif (!(child->device_type & DEVICE_TYPE_MIPI_OUTPUT))\n\t\t\tcontinue;\n\n\t\tif (dsi_dvo_port_to_port(i915, dvo_port) == PORT_NONE) {\n\t\t\tdrm_dbg_kms(&i915->drm,\n\t\t\t\t    \"VBT has unsupported DSI port %c\\n\",\n\t\t\t\t    port_name(dvo_port - DVO_PORT_MIPIA));\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (port)\n\t\t\t*port = dsi_dvo_port_to_port(i915, dvo_port);\n\t\treturn true;\n\t}\n\n\treturn false;\n}\n\nstatic void fill_dsc(struct intel_crtc_state *crtc_state,\n\t\t     struct dsc_compression_parameters_entry *dsc,\n\t\t     int dsc_max_bpc)\n{\n\tstruct drm_dsc_config *vdsc_cfg = &crtc_state->dsc.config;\n\tint bpc = 8;\n\n\tvdsc_cfg->dsc_version_major = dsc->version_major;\n\tvdsc_cfg->dsc_version_minor = dsc->version_minor;\n\n\tif (dsc->support_12bpc && dsc_max_bpc >= 12)\n\t\tbpc = 12;\n\telse if (dsc->support_10bpc && dsc_max_bpc >= 10)\n\t\tbpc = 10;\n\telse if (dsc->support_8bpc && dsc_max_bpc >= 8)\n\t\tbpc = 8;\n\telse\n\t\tDRM_DEBUG_KMS(\"VBT: Unsupported BPC %d for DCS\\n\",\n\t\t\t      dsc_max_bpc);\n\n\tcrtc_state->pipe_bpp = bpc * 3;\n\n\tcrtc_state->dsc.compressed_bpp = min(crtc_state->pipe_bpp,\n\t\t\t\t\t     VBT_DSC_MAX_BPP(dsc->max_bpp));\n\n\t \n\tif (dsc->slices_per_line & BIT(2)) {\n\t\tcrtc_state->dsc.slice_count = 4;\n\t} else if (dsc->slices_per_line & BIT(1)) {\n\t\tcrtc_state->dsc.slice_count = 2;\n\t} else {\n\t\t \n\t\tif (!(dsc->slices_per_line & BIT(0)))\n\t\t\tDRM_DEBUG_KMS(\"VBT: Unsupported DSC slice count for DSI\\n\");\n\n\t\tcrtc_state->dsc.slice_count = 1;\n\t}\n\n\tif (crtc_state->hw.adjusted_mode.crtc_hdisplay %\n\t    crtc_state->dsc.slice_count != 0)\n\t\tDRM_DEBUG_KMS(\"VBT: DSC hdisplay %d not divisible by slice count %d\\n\",\n\t\t\t      crtc_state->hw.adjusted_mode.crtc_hdisplay,\n\t\t\t      crtc_state->dsc.slice_count);\n\n\t \n\tvdsc_cfg->rc_model_size = drm_dsc_dp_rc_buffer_size(dsc->rc_buffer_block_size,\n\t\t\t\t\t\t\t    dsc->rc_buffer_size);\n\n\t \n\tvdsc_cfg->line_buf_depth = VBT_DSC_LINE_BUFFER_DEPTH(dsc->line_buffer_depth);\n\n\tvdsc_cfg->block_pred_enable = dsc->block_prediction_enable;\n\n\tvdsc_cfg->slice_height = dsc->slice_height;\n}\n\n \nbool intel_bios_get_dsc_params(struct intel_encoder *encoder,\n\t\t\t       struct intel_crtc_state *crtc_state,\n\t\t\t       int dsc_max_bpc)\n{\n\tstruct drm_i915_private *i915 = to_i915(encoder->base.dev);\n\tconst struct intel_bios_encoder_data *devdata;\n\n\tlist_for_each_entry(devdata, &i915->display.vbt.display_devices, node) {\n\t\tconst struct child_device_config *child = &devdata->child;\n\n\t\tif (!(child->device_type & DEVICE_TYPE_MIPI_OUTPUT))\n\t\t\tcontinue;\n\n\t\tif (dsi_dvo_port_to_port(i915, child->dvo_port) == encoder->port) {\n\t\t\tif (!devdata->dsc)\n\t\t\t\treturn false;\n\n\t\t\tif (crtc_state)\n\t\t\t\tfill_dsc(crtc_state, devdata->dsc, dsc_max_bpc);\n\n\t\t\treturn true;\n\t\t}\n\t}\n\n\treturn false;\n}\n\nstatic const u8 adlp_aux_ch_map[] = {\n\t[AUX_CH_A] = DP_AUX_A,\n\t[AUX_CH_B] = DP_AUX_B,\n\t[AUX_CH_C] = DP_AUX_C,\n\t[AUX_CH_D_XELPD] = DP_AUX_D,\n\t[AUX_CH_E_XELPD] = DP_AUX_E,\n\t[AUX_CH_USBC1] = DP_AUX_F,\n\t[AUX_CH_USBC2] = DP_AUX_G,\n\t[AUX_CH_USBC3] = DP_AUX_H,\n\t[AUX_CH_USBC4] = DP_AUX_I,\n};\n\n \nstatic const u8 adls_aux_ch_map[] = {\n\t[AUX_CH_A] = DP_AUX_A,\n\t[AUX_CH_USBC1] = DP_AUX_B,\n\t[AUX_CH_USBC2] = DP_AUX_C,\n\t[AUX_CH_USBC3] = DP_AUX_D,\n\t[AUX_CH_USBC4] = DP_AUX_E,\n};\n\n \nstatic const u8 rkl_aux_ch_map[] = {\n\t[AUX_CH_A] = DP_AUX_A,\n\t[AUX_CH_B] = DP_AUX_B,\n\t[AUX_CH_USBC1] = DP_AUX_C,\n\t[AUX_CH_USBC2] = DP_AUX_D,\n};\n\nstatic const u8 direct_aux_ch_map[] = {\n\t[AUX_CH_A] = DP_AUX_A,\n\t[AUX_CH_B] = DP_AUX_B,\n\t[AUX_CH_C] = DP_AUX_C,\n\t[AUX_CH_D] = DP_AUX_D,  \n\t[AUX_CH_E] = DP_AUX_E,  \n\t[AUX_CH_F] = DP_AUX_F,  \n\t[AUX_CH_G] = DP_AUX_G,  \n\t[AUX_CH_H] = DP_AUX_H,  \n\t[AUX_CH_I] = DP_AUX_I,  \n};\n\nstatic enum aux_ch map_aux_ch(struct drm_i915_private *i915, u8 aux_channel)\n{\n\tconst u8 *aux_ch_map;\n\tint i, n_entries;\n\n\tif (DISPLAY_VER(i915) >= 13) {\n\t\taux_ch_map = adlp_aux_ch_map;\n\t\tn_entries = ARRAY_SIZE(adlp_aux_ch_map);\n\t} else if (IS_ALDERLAKE_S(i915)) {\n\t\taux_ch_map = adls_aux_ch_map;\n\t\tn_entries = ARRAY_SIZE(adls_aux_ch_map);\n\t} else if (IS_DG1(i915) || IS_ROCKETLAKE(i915)) {\n\t\taux_ch_map = rkl_aux_ch_map;\n\t\tn_entries = ARRAY_SIZE(rkl_aux_ch_map);\n\t} else {\n\t\taux_ch_map = direct_aux_ch_map;\n\t\tn_entries = ARRAY_SIZE(direct_aux_ch_map);\n\t}\n\n\tfor (i = 0; i < n_entries; i++) {\n\t\tif (aux_ch_map[i] == aux_channel)\n\t\t\treturn i;\n\t}\n\n\tdrm_dbg_kms(&i915->drm,\n\t\t    \"Ignoring alternate AUX CH: VBT claims AUX 0x%x, which is not valid for this platform\\n\",\n\t\t    aux_channel);\n\n\treturn AUX_CH_NONE;\n}\n\nenum aux_ch intel_bios_dp_aux_ch(const struct intel_bios_encoder_data *devdata)\n{\n\tif (!devdata || !devdata->child.aux_channel)\n\t\treturn AUX_CH_NONE;\n\n\treturn map_aux_ch(devdata->i915, devdata->child.aux_channel);\n}\n\nbool intel_bios_dp_has_shared_aux_ch(const struct intel_bios_encoder_data *devdata)\n{\n\tstruct drm_i915_private *i915;\n\tu8 aux_channel;\n\tint count = 0;\n\n\tif (!devdata || !devdata->child.aux_channel)\n\t\treturn false;\n\n\ti915 = devdata->i915;\n\taux_channel = devdata->child.aux_channel;\n\n\tlist_for_each_entry(devdata, &i915->display.vbt.display_devices, node) {\n\t\tif (intel_bios_encoder_supports_dp(devdata) &&\n\t\t    aux_channel == devdata->child.aux_channel)\n\t\t\tcount++;\n\t}\n\n\treturn count > 1;\n}\n\nint intel_bios_dp_boost_level(const struct intel_bios_encoder_data *devdata)\n{\n\tif (!devdata || devdata->i915->display.vbt.version < 196 || !devdata->child.iboost)\n\t\treturn 0;\n\n\treturn translate_iboost(devdata->child.dp_iboost_level);\n}\n\nint intel_bios_hdmi_boost_level(const struct intel_bios_encoder_data *devdata)\n{\n\tif (!devdata || devdata->i915->display.vbt.version < 196 || !devdata->child.iboost)\n\t\treturn 0;\n\n\treturn translate_iboost(devdata->child.hdmi_iboost_level);\n}\n\nint intel_bios_hdmi_ddc_pin(const struct intel_bios_encoder_data *devdata)\n{\n\tif (!devdata || !devdata->child.ddc_pin)\n\t\treturn 0;\n\n\treturn map_ddc_pin(devdata->i915, devdata->child.ddc_pin);\n}\n\nbool intel_bios_encoder_supports_typec_usb(const struct intel_bios_encoder_data *devdata)\n{\n\treturn devdata->i915->display.vbt.version >= 195 && devdata->child.dp_usb_type_c;\n}\n\nbool intel_bios_encoder_supports_tbt(const struct intel_bios_encoder_data *devdata)\n{\n\treturn devdata->i915->display.vbt.version >= 209 && devdata->child.tbt;\n}\n\nbool intel_bios_encoder_lane_reversal(const struct intel_bios_encoder_data *devdata)\n{\n\treturn devdata && devdata->child.lane_reversal;\n}\n\nbool intel_bios_encoder_hpd_invert(const struct intel_bios_encoder_data *devdata)\n{\n\treturn devdata && devdata->child.hpd_invert;\n}\n\nconst struct intel_bios_encoder_data *\nintel_bios_encoder_data_lookup(struct drm_i915_private *i915, enum port port)\n{\n\tstruct intel_bios_encoder_data *devdata;\n\n\tlist_for_each_entry(devdata, &i915->display.vbt.display_devices, node) {\n\t\tif (intel_bios_encoder_port(devdata) == port)\n\t\t\treturn devdata;\n\t}\n\n\treturn NULL;\n}\n\nvoid intel_bios_for_each_encoder(struct drm_i915_private *i915,\n\t\t\t\t void (*func)(struct drm_i915_private *i915,\n\t\t\t\t\t      const struct intel_bios_encoder_data *devdata))\n{\n\tstruct intel_bios_encoder_data *devdata;\n\n\tlist_for_each_entry(devdata, &i915->display.vbt.display_devices, node)\n\t\tfunc(i915, devdata);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}