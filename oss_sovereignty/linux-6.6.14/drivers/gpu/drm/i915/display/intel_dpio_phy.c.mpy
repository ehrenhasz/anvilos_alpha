{
  "module_name": "intel_dpio_phy.c",
  "hash_id": "ad9b15d9e679e6b451ea7ad0b9e9c22c9c78c20262736f485e5f02eb1382eb4b",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/i915/display/intel_dpio_phy.c",
  "human_readable_source": " \n\n#include \"i915_reg.h\"\n#include \"intel_ddi.h\"\n#include \"intel_ddi_buf_trans.h\"\n#include \"intel_de.h\"\n#include \"intel_display_power_well.h\"\n#include \"intel_display_types.h\"\n#include \"intel_dp.h\"\n#include \"intel_dpio_phy.h\"\n#include \"vlv_sideband.h\"\n\n \n\n \nstruct bxt_ddi_phy_info {\n\t \n\tbool dual_channel;\n\n\t \n\tenum dpio_phy rcomp_phy;\n\n\t \n\tint reset_delay;\n\n\t \n\tu32 pwron_mask;\n\n\t \n\tstruct {\n\t\t \n\t\tenum port port;\n\t} channel[2];\n};\n\nstatic const struct bxt_ddi_phy_info bxt_ddi_phy_info[] = {\n\t[DPIO_PHY0] = {\n\t\t.dual_channel = true,\n\t\t.rcomp_phy = DPIO_PHY1,\n\t\t.pwron_mask = BIT(0),\n\n\t\t.channel = {\n\t\t\t[DPIO_CH0] = { .port = PORT_B },\n\t\t\t[DPIO_CH1] = { .port = PORT_C },\n\t\t}\n\t},\n\t[DPIO_PHY1] = {\n\t\t.dual_channel = false,\n\t\t.rcomp_phy = -1,\n\t\t.pwron_mask = BIT(1),\n\n\t\t.channel = {\n\t\t\t[DPIO_CH0] = { .port = PORT_A },\n\t\t}\n\t},\n};\n\nstatic const struct bxt_ddi_phy_info glk_ddi_phy_info[] = {\n\t[DPIO_PHY0] = {\n\t\t.dual_channel = false,\n\t\t.rcomp_phy = DPIO_PHY1,\n\t\t.pwron_mask = BIT(0),\n\t\t.reset_delay = 20,\n\n\t\t.channel = {\n\t\t\t[DPIO_CH0] = { .port = PORT_B },\n\t\t}\n\t},\n\t[DPIO_PHY1] = {\n\t\t.dual_channel = false,\n\t\t.rcomp_phy = -1,\n\t\t.pwron_mask = BIT(3),\n\t\t.reset_delay = 20,\n\n\t\t.channel = {\n\t\t\t[DPIO_CH0] = { .port = PORT_A },\n\t\t}\n\t},\n\t[DPIO_PHY2] = {\n\t\t.dual_channel = false,\n\t\t.rcomp_phy = DPIO_PHY1,\n\t\t.pwron_mask = BIT(1),\n\t\t.reset_delay = 20,\n\n\t\t.channel = {\n\t\t\t[DPIO_CH0] = { .port = PORT_C },\n\t\t}\n\t},\n};\n\nstatic const struct bxt_ddi_phy_info *\nbxt_get_phy_list(struct drm_i915_private *dev_priv, int *count)\n{\n\tif (IS_GEMINILAKE(dev_priv)) {\n\t\t*count =  ARRAY_SIZE(glk_ddi_phy_info);\n\t\treturn glk_ddi_phy_info;\n\t} else {\n\t\t*count =  ARRAY_SIZE(bxt_ddi_phy_info);\n\t\treturn bxt_ddi_phy_info;\n\t}\n}\n\nstatic const struct bxt_ddi_phy_info *\nbxt_get_phy_info(struct drm_i915_private *dev_priv, enum dpio_phy phy)\n{\n\tint count;\n\tconst struct bxt_ddi_phy_info *phy_list =\n\t\tbxt_get_phy_list(dev_priv, &count);\n\n\treturn &phy_list[phy];\n}\n\nvoid bxt_port_to_phy_channel(struct drm_i915_private *dev_priv, enum port port,\n\t\t\t     enum dpio_phy *phy, enum dpio_channel *ch)\n{\n\tconst struct bxt_ddi_phy_info *phy_info, *phys;\n\tint i, count;\n\n\tphys = bxt_get_phy_list(dev_priv, &count);\n\n\tfor (i = 0; i < count; i++) {\n\t\tphy_info = &phys[i];\n\n\t\tif (port == phy_info->channel[DPIO_CH0].port) {\n\t\t\t*phy = i;\n\t\t\t*ch = DPIO_CH0;\n\t\t\treturn;\n\t\t}\n\n\t\tif (phy_info->dual_channel &&\n\t\t    port == phy_info->channel[DPIO_CH1].port) {\n\t\t\t*phy = i;\n\t\t\t*ch = DPIO_CH1;\n\t\t\treturn;\n\t\t}\n\t}\n\n\tdrm_WARN(&dev_priv->drm, 1, \"PHY not found for PORT %c\",\n\t\t port_name(port));\n\t*phy = DPIO_PHY0;\n\t*ch = DPIO_CH0;\n}\n\nvoid bxt_ddi_phy_set_signal_levels(struct intel_encoder *encoder,\n\t\t\t\t   const struct intel_crtc_state *crtc_state)\n{\n\tstruct drm_i915_private *dev_priv = to_i915(encoder->base.dev);\n\tint level = intel_ddi_level(encoder, crtc_state, 0);\n\tconst struct intel_ddi_buf_trans *trans;\n\tenum dpio_channel ch;\n\tenum dpio_phy phy;\n\tint n_entries;\n\tu32 val;\n\n\ttrans = encoder->get_buf_trans(encoder, crtc_state, &n_entries);\n\tif (drm_WARN_ON_ONCE(&dev_priv->drm, !trans))\n\t\treturn;\n\n\tbxt_port_to_phy_channel(dev_priv, encoder->port, &phy, &ch);\n\n\t \n\tval = intel_de_read(dev_priv, BXT_PORT_PCS_DW10_LN01(phy, ch));\n\tval &= ~(TX2_SWING_CALC_INIT | TX1_SWING_CALC_INIT);\n\tintel_de_write(dev_priv, BXT_PORT_PCS_DW10_GRP(phy, ch), val);\n\n\tval = intel_de_read(dev_priv, BXT_PORT_TX_DW2_LN0(phy, ch));\n\tval &= ~(MARGIN_000 | UNIQ_TRANS_SCALE);\n\tval |= trans->entries[level].bxt.margin << MARGIN_000_SHIFT |\n\t\ttrans->entries[level].bxt.scale << UNIQ_TRANS_SCALE_SHIFT;\n\tintel_de_write(dev_priv, BXT_PORT_TX_DW2_GRP(phy, ch), val);\n\n\tval = intel_de_read(dev_priv, BXT_PORT_TX_DW3_LN0(phy, ch));\n\tval &= ~SCALE_DCOMP_METHOD;\n\tif (trans->entries[level].bxt.enable)\n\t\tval |= SCALE_DCOMP_METHOD;\n\n\tif ((val & UNIQUE_TRANGE_EN_METHOD) && !(val & SCALE_DCOMP_METHOD))\n\t\tdrm_err(&dev_priv->drm,\n\t\t\t\"Disabled scaling while ouniqetrangenmethod was set\");\n\n\tintel_de_write(dev_priv, BXT_PORT_TX_DW3_GRP(phy, ch), val);\n\n\tval = intel_de_read(dev_priv, BXT_PORT_TX_DW4_LN0(phy, ch));\n\tval &= ~DE_EMPHASIS;\n\tval |= trans->entries[level].bxt.deemphasis << DEEMPH_SHIFT;\n\tintel_de_write(dev_priv, BXT_PORT_TX_DW4_GRP(phy, ch), val);\n\n\tval = intel_de_read(dev_priv, BXT_PORT_PCS_DW10_LN01(phy, ch));\n\tval |= TX2_SWING_CALC_INIT | TX1_SWING_CALC_INIT;\n\tintel_de_write(dev_priv, BXT_PORT_PCS_DW10_GRP(phy, ch), val);\n}\n\nbool bxt_ddi_phy_is_enabled(struct drm_i915_private *dev_priv,\n\t\t\t    enum dpio_phy phy)\n{\n\tconst struct bxt_ddi_phy_info *phy_info;\n\n\tphy_info = bxt_get_phy_info(dev_priv, phy);\n\n\tif (!(intel_de_read(dev_priv, BXT_P_CR_GT_DISP_PWRON) & phy_info->pwron_mask))\n\t\treturn false;\n\n\tif ((intel_de_read(dev_priv, BXT_PORT_CL1CM_DW0(phy)) &\n\t     (PHY_POWER_GOOD | PHY_RESERVED)) != PHY_POWER_GOOD) {\n\t\tdrm_dbg(&dev_priv->drm,\n\t\t\t\"DDI PHY %d powered, but power hasn't settled\\n\", phy);\n\n\t\treturn false;\n\t}\n\n\tif (!(intel_de_read(dev_priv, BXT_PHY_CTL_FAMILY(phy)) & COMMON_RESET_DIS)) {\n\t\tdrm_dbg(&dev_priv->drm,\n\t\t\t\"DDI PHY %d powered, but still in reset\\n\", phy);\n\n\t\treturn false;\n\t}\n\n\treturn true;\n}\n\nstatic u32 bxt_get_grc(struct drm_i915_private *dev_priv, enum dpio_phy phy)\n{\n\tu32 val = intel_de_read(dev_priv, BXT_PORT_REF_DW6(phy));\n\n\treturn (val & GRC_CODE_MASK) >> GRC_CODE_SHIFT;\n}\n\nstatic void bxt_phy_wait_grc_done(struct drm_i915_private *dev_priv,\n\t\t\t\t  enum dpio_phy phy)\n{\n\tif (intel_de_wait_for_set(dev_priv, BXT_PORT_REF_DW3(phy),\n\t\t\t\t  GRC_DONE, 10))\n\t\tdrm_err(&dev_priv->drm, \"timeout waiting for PHY%d GRC\\n\",\n\t\t\tphy);\n}\n\nstatic void _bxt_ddi_phy_init(struct drm_i915_private *dev_priv,\n\t\t\t      enum dpio_phy phy)\n{\n\tconst struct bxt_ddi_phy_info *phy_info;\n\tu32 val;\n\n\tphy_info = bxt_get_phy_info(dev_priv, phy);\n\n\tif (bxt_ddi_phy_is_enabled(dev_priv, phy)) {\n\t\t \n\t\tif (phy_info->rcomp_phy != -1)\n\t\t\tdev_priv->display.state.bxt_phy_grc = bxt_get_grc(dev_priv, phy);\n\n\t\tif (bxt_ddi_phy_verify_state(dev_priv, phy)) {\n\t\t\tdrm_dbg(&dev_priv->drm, \"DDI PHY %d already enabled, \"\n\t\t\t\t\"won't reprogram it\\n\", phy);\n\t\t\treturn;\n\t\t}\n\n\t\tdrm_dbg(&dev_priv->drm,\n\t\t\t\"DDI PHY %d enabled with invalid state, \"\n\t\t\t\"force reprogramming it\\n\", phy);\n\t}\n\n\tintel_de_rmw(dev_priv, BXT_P_CR_GT_DISP_PWRON, 0, phy_info->pwron_mask);\n\n\t \n\tif (intel_wait_for_register_fw(&dev_priv->uncore,\n\t\t\t\t       BXT_PORT_CL1CM_DW0(phy),\n\t\t\t\t       PHY_RESERVED | PHY_POWER_GOOD,\n\t\t\t\t       PHY_POWER_GOOD,\n\t\t\t\t       1))\n\t\tdrm_err(&dev_priv->drm, \"timeout during PHY%d power on\\n\",\n\t\t\tphy);\n\n\t \n\tintel_de_rmw(dev_priv, BXT_PORT_CL1CM_DW9(phy), IREF0RC_OFFSET_MASK,\n\t\t     0xE4 << IREF0RC_OFFSET_SHIFT);\n\n\tintel_de_rmw(dev_priv, BXT_PORT_CL1CM_DW10(phy), IREF1RC_OFFSET_MASK,\n\t\t     0xE4 << IREF1RC_OFFSET_SHIFT);\n\n\t \n\tintel_de_rmw(dev_priv, BXT_PORT_CL1CM_DW28(phy), 0,\n\t\t     OCL1_POWER_DOWN_EN | DW28_OLDO_DYN_PWR_DOWN_EN | SUS_CLK_CONFIG);\n\n\tif (phy_info->dual_channel)\n\t\tintel_de_rmw(dev_priv, BXT_PORT_CL2CM_DW6(phy), 0,\n\t\t\t     DW6_OLDO_DYN_PWR_DOWN_EN);\n\n\tif (phy_info->rcomp_phy != -1) {\n\t\tu32 grc_code;\n\n\t\tbxt_phy_wait_grc_done(dev_priv, phy_info->rcomp_phy);\n\n\t\t \n\t\tval = bxt_get_grc(dev_priv, phy_info->rcomp_phy);\n\t\tdev_priv->display.state.bxt_phy_grc = val;\n\n\t\tgrc_code = val << GRC_CODE_FAST_SHIFT |\n\t\t\t   val << GRC_CODE_SLOW_SHIFT |\n\t\t\t   val;\n\t\tintel_de_write(dev_priv, BXT_PORT_REF_DW6(phy), grc_code);\n\t\tintel_de_rmw(dev_priv, BXT_PORT_REF_DW8(phy),\n\t\t\t     0, GRC_DIS | GRC_RDY_OVRD);\n\t}\n\n\tif (phy_info->reset_delay)\n\t\tudelay(phy_info->reset_delay);\n\n\tintel_de_rmw(dev_priv, BXT_PHY_CTL_FAMILY(phy), 0, COMMON_RESET_DIS);\n}\n\nvoid bxt_ddi_phy_uninit(struct drm_i915_private *dev_priv, enum dpio_phy phy)\n{\n\tconst struct bxt_ddi_phy_info *phy_info;\n\n\tphy_info = bxt_get_phy_info(dev_priv, phy);\n\n\tintel_de_rmw(dev_priv, BXT_PHY_CTL_FAMILY(phy), COMMON_RESET_DIS, 0);\n\n\tintel_de_rmw(dev_priv, BXT_P_CR_GT_DISP_PWRON, phy_info->pwron_mask, 0);\n}\n\nvoid bxt_ddi_phy_init(struct drm_i915_private *dev_priv, enum dpio_phy phy)\n{\n\tconst struct bxt_ddi_phy_info *phy_info =\n\t\tbxt_get_phy_info(dev_priv, phy);\n\tenum dpio_phy rcomp_phy = phy_info->rcomp_phy;\n\tbool was_enabled;\n\n\tlockdep_assert_held(&dev_priv->display.power.domains.lock);\n\n\twas_enabled = true;\n\tif (rcomp_phy != -1)\n\t\twas_enabled = bxt_ddi_phy_is_enabled(dev_priv, rcomp_phy);\n\n\t \n\tif (!was_enabled)\n\t\t_bxt_ddi_phy_init(dev_priv, rcomp_phy);\n\n\t_bxt_ddi_phy_init(dev_priv, phy);\n\n\tif (!was_enabled)\n\t\tbxt_ddi_phy_uninit(dev_priv, rcomp_phy);\n}\n\nstatic bool __printf(6, 7)\n__phy_reg_verify_state(struct drm_i915_private *dev_priv, enum dpio_phy phy,\n\t\t       i915_reg_t reg, u32 mask, u32 expected,\n\t\t       const char *reg_fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\tu32 val;\n\n\tval = intel_de_read(dev_priv, reg);\n\tif ((val & mask) == expected)\n\t\treturn true;\n\n\tva_start(args, reg_fmt);\n\tvaf.fmt = reg_fmt;\n\tvaf.va = &args;\n\n\tdrm_dbg(&dev_priv->drm, \"DDI PHY %d reg %pV [%08x] state mismatch: \"\n\t\t\t \"current %08x, expected %08x (mask %08x)\\n\",\n\t\t\t phy, &vaf, reg.reg, val, (val & ~mask) | expected,\n\t\t\t mask);\n\n\tva_end(args);\n\n\treturn false;\n}\n\nbool bxt_ddi_phy_verify_state(struct drm_i915_private *dev_priv,\n\t\t\t      enum dpio_phy phy)\n{\n\tconst struct bxt_ddi_phy_info *phy_info;\n\tu32 mask;\n\tbool ok;\n\n\tphy_info = bxt_get_phy_info(dev_priv, phy);\n\n#define _CHK(reg, mask, exp, fmt, ...)\t\t\t\t\t\\\n\t__phy_reg_verify_state(dev_priv, phy, reg, mask, exp, fmt,\t\\\n\t\t\t       ## __VA_ARGS__)\n\n\tif (!bxt_ddi_phy_is_enabled(dev_priv, phy))\n\t\treturn false;\n\n\tok = true;\n\n\t \n\tok &= _CHK(BXT_PORT_CL1CM_DW9(phy),\n\t\t    IREF0RC_OFFSET_MASK, 0xe4 << IREF0RC_OFFSET_SHIFT,\n\t\t    \"BXT_PORT_CL1CM_DW9(%d)\", phy);\n\tok &= _CHK(BXT_PORT_CL1CM_DW10(phy),\n\t\t    IREF1RC_OFFSET_MASK, 0xe4 << IREF1RC_OFFSET_SHIFT,\n\t\t    \"BXT_PORT_CL1CM_DW10(%d)\", phy);\n\n\t \n\tmask = OCL1_POWER_DOWN_EN | DW28_OLDO_DYN_PWR_DOWN_EN | SUS_CLK_CONFIG;\n\tok &= _CHK(BXT_PORT_CL1CM_DW28(phy), mask, mask,\n\t\t    \"BXT_PORT_CL1CM_DW28(%d)\", phy);\n\n\tif (phy_info->dual_channel)\n\t\tok &= _CHK(BXT_PORT_CL2CM_DW6(phy),\n\t\t\t   DW6_OLDO_DYN_PWR_DOWN_EN, DW6_OLDO_DYN_PWR_DOWN_EN,\n\t\t\t   \"BXT_PORT_CL2CM_DW6(%d)\", phy);\n\n\tif (phy_info->rcomp_phy != -1) {\n\t\tu32 grc_code = dev_priv->display.state.bxt_phy_grc;\n\n\t\tgrc_code = grc_code << GRC_CODE_FAST_SHIFT |\n\t\t\t   grc_code << GRC_CODE_SLOW_SHIFT |\n\t\t\t   grc_code;\n\t\tmask = GRC_CODE_FAST_MASK | GRC_CODE_SLOW_MASK |\n\t\t       GRC_CODE_NOM_MASK;\n\t\tok &= _CHK(BXT_PORT_REF_DW6(phy), mask, grc_code,\n\t\t\t   \"BXT_PORT_REF_DW6(%d)\", phy);\n\n\t\tmask = GRC_DIS | GRC_RDY_OVRD;\n\t\tok &= _CHK(BXT_PORT_REF_DW8(phy), mask, mask,\n\t\t\t    \"BXT_PORT_REF_DW8(%d)\", phy);\n\t}\n\n\treturn ok;\n#undef _CHK\n}\n\nu8\nbxt_ddi_phy_calc_lane_lat_optim_mask(u8 lane_count)\n{\n\tswitch (lane_count) {\n\tcase 1:\n\t\treturn 0;\n\tcase 2:\n\t\treturn BIT(2) | BIT(0);\n\tcase 4:\n\t\treturn BIT(3) | BIT(2) | BIT(0);\n\tdefault:\n\t\tMISSING_CASE(lane_count);\n\n\t\treturn 0;\n\t}\n}\n\nvoid bxt_ddi_phy_set_lane_optim_mask(struct intel_encoder *encoder,\n\t\t\t\t     u8 lane_lat_optim_mask)\n{\n\tstruct drm_i915_private *dev_priv = to_i915(encoder->base.dev);\n\tenum port port = encoder->port;\n\tenum dpio_phy phy;\n\tenum dpio_channel ch;\n\tint lane;\n\n\tbxt_port_to_phy_channel(dev_priv, port, &phy, &ch);\n\n\tfor (lane = 0; lane < 4; lane++) {\n\t\tu32 val = intel_de_read(dev_priv,\n\t\t\t\t\tBXT_PORT_TX_DW14_LN(phy, ch, lane));\n\n\t\t \n\t\tval &= ~LATENCY_OPTIM;\n\t\tif (lane_lat_optim_mask & BIT(lane))\n\t\t\tval |= LATENCY_OPTIM;\n\n\t\tintel_de_write(dev_priv, BXT_PORT_TX_DW14_LN(phy, ch, lane),\n\t\t\t       val);\n\t}\n}\n\nu8\nbxt_ddi_phy_get_lane_lat_optim_mask(struct intel_encoder *encoder)\n{\n\tstruct drm_i915_private *dev_priv = to_i915(encoder->base.dev);\n\tenum port port = encoder->port;\n\tenum dpio_phy phy;\n\tenum dpio_channel ch;\n\tint lane;\n\tu8 mask;\n\n\tbxt_port_to_phy_channel(dev_priv, port, &phy, &ch);\n\n\tmask = 0;\n\tfor (lane = 0; lane < 4; lane++) {\n\t\tu32 val = intel_de_read(dev_priv,\n\t\t\t\t\tBXT_PORT_TX_DW14_LN(phy, ch, lane));\n\n\t\tif (val & LATENCY_OPTIM)\n\t\t\tmask |= BIT(lane);\n\t}\n\n\treturn mask;\n}\n\nenum dpio_channel vlv_dig_port_to_channel(struct intel_digital_port *dig_port)\n{\n\tswitch (dig_port->base.port) {\n\tdefault:\n\t\tMISSING_CASE(dig_port->base.port);\n\t\tfallthrough;\n\tcase PORT_B:\n\tcase PORT_D:\n\t\treturn DPIO_CH0;\n\tcase PORT_C:\n\t\treturn DPIO_CH1;\n\t}\n}\n\nenum dpio_phy vlv_dig_port_to_phy(struct intel_digital_port *dig_port)\n{\n\tswitch (dig_port->base.port) {\n\tdefault:\n\t\tMISSING_CASE(dig_port->base.port);\n\t\tfallthrough;\n\tcase PORT_B:\n\tcase PORT_C:\n\t\treturn DPIO_PHY0;\n\tcase PORT_D:\n\t\treturn DPIO_PHY1;\n\t}\n}\n\nenum dpio_channel vlv_pipe_to_channel(enum pipe pipe)\n{\n\tswitch (pipe) {\n\tdefault:\n\t\tMISSING_CASE(pipe);\n\t\tfallthrough;\n\tcase PIPE_A:\n\tcase PIPE_C:\n\t\treturn DPIO_CH0;\n\tcase PIPE_B:\n\t\treturn DPIO_CH1;\n\t}\n}\n\nvoid chv_set_phy_signal_level(struct intel_encoder *encoder,\n\t\t\t      const struct intel_crtc_state *crtc_state,\n\t\t\t      u32 deemph_reg_value, u32 margin_reg_value,\n\t\t\t      bool uniq_trans_scale)\n{\n\tstruct drm_i915_private *dev_priv = to_i915(encoder->base.dev);\n\tstruct intel_digital_port *dig_port = enc_to_dig_port(encoder);\n\tstruct intel_crtc *crtc = to_intel_crtc(crtc_state->uapi.crtc);\n\tenum dpio_channel ch = vlv_dig_port_to_channel(dig_port);\n\tenum pipe pipe = crtc->pipe;\n\tu32 val;\n\tint i;\n\n\tvlv_dpio_get(dev_priv);\n\n\t \n\tval = vlv_dpio_read(dev_priv, pipe, VLV_PCS01_DW10(ch));\n\tval &= ~(DPIO_PCS_SWING_CALC_TX0_TX2 | DPIO_PCS_SWING_CALC_TX1_TX3);\n\tval &= ~(DPIO_PCS_TX1DEEMP_MASK | DPIO_PCS_TX2DEEMP_MASK);\n\tval |= DPIO_PCS_TX1DEEMP_9P5 | DPIO_PCS_TX2DEEMP_9P5;\n\tvlv_dpio_write(dev_priv, pipe, VLV_PCS01_DW10(ch), val);\n\n\tif (crtc_state->lane_count > 2) {\n\t\tval = vlv_dpio_read(dev_priv, pipe, VLV_PCS23_DW10(ch));\n\t\tval &= ~(DPIO_PCS_SWING_CALC_TX0_TX2 | DPIO_PCS_SWING_CALC_TX1_TX3);\n\t\tval &= ~(DPIO_PCS_TX1DEEMP_MASK | DPIO_PCS_TX2DEEMP_MASK);\n\t\tval |= DPIO_PCS_TX1DEEMP_9P5 | DPIO_PCS_TX2DEEMP_9P5;\n\t\tvlv_dpio_write(dev_priv, pipe, VLV_PCS23_DW10(ch), val);\n\t}\n\n\tval = vlv_dpio_read(dev_priv, pipe, VLV_PCS01_DW9(ch));\n\tval &= ~(DPIO_PCS_TX1MARGIN_MASK | DPIO_PCS_TX2MARGIN_MASK);\n\tval |= DPIO_PCS_TX1MARGIN_000 | DPIO_PCS_TX2MARGIN_000;\n\tvlv_dpio_write(dev_priv, pipe, VLV_PCS01_DW9(ch), val);\n\n\tif (crtc_state->lane_count > 2) {\n\t\tval = vlv_dpio_read(dev_priv, pipe, VLV_PCS23_DW9(ch));\n\t\tval &= ~(DPIO_PCS_TX1MARGIN_MASK | DPIO_PCS_TX2MARGIN_MASK);\n\t\tval |= DPIO_PCS_TX1MARGIN_000 | DPIO_PCS_TX2MARGIN_000;\n\t\tvlv_dpio_write(dev_priv, pipe, VLV_PCS23_DW9(ch), val);\n\t}\n\n\t \n\tfor (i = 0; i < crtc_state->lane_count; i++) {\n\t\tval = vlv_dpio_read(dev_priv, pipe, CHV_TX_DW4(ch, i));\n\t\tval &= ~DPIO_SWING_DEEMPH9P5_MASK;\n\t\tval |= deemph_reg_value << DPIO_SWING_DEEMPH9P5_SHIFT;\n\t\tvlv_dpio_write(dev_priv, pipe, CHV_TX_DW4(ch, i), val);\n\t}\n\n\t \n\tfor (i = 0; i < crtc_state->lane_count; i++) {\n\t\tval = vlv_dpio_read(dev_priv, pipe, CHV_TX_DW2(ch, i));\n\n\t\tval &= ~DPIO_SWING_MARGIN000_MASK;\n\t\tval |= margin_reg_value << DPIO_SWING_MARGIN000_SHIFT;\n\n\t\t \n\t\tval &= ~(0xff << DPIO_UNIQ_TRANS_SCALE_SHIFT);\n\t\tval |= 0x9a << DPIO_UNIQ_TRANS_SCALE_SHIFT;\n\n\t\tvlv_dpio_write(dev_priv, pipe, CHV_TX_DW2(ch, i), val);\n\t}\n\n\t \n\tfor (i = 0; i < crtc_state->lane_count; i++) {\n\t\tval = vlv_dpio_read(dev_priv, pipe, CHV_TX_DW3(ch, i));\n\t\tif (uniq_trans_scale)\n\t\t\tval |= DPIO_TX_UNIQ_TRANS_SCALE_EN;\n\t\telse\n\t\t\tval &= ~DPIO_TX_UNIQ_TRANS_SCALE_EN;\n\t\tvlv_dpio_write(dev_priv, pipe, CHV_TX_DW3(ch, i), val);\n\t}\n\n\t \n\tval = vlv_dpio_read(dev_priv, pipe, VLV_PCS01_DW10(ch));\n\tval |= DPIO_PCS_SWING_CALC_TX0_TX2 | DPIO_PCS_SWING_CALC_TX1_TX3;\n\tvlv_dpio_write(dev_priv, pipe, VLV_PCS01_DW10(ch), val);\n\n\tif (crtc_state->lane_count > 2) {\n\t\tval = vlv_dpio_read(dev_priv, pipe, VLV_PCS23_DW10(ch));\n\t\tval |= DPIO_PCS_SWING_CALC_TX0_TX2 | DPIO_PCS_SWING_CALC_TX1_TX3;\n\t\tvlv_dpio_write(dev_priv, pipe, VLV_PCS23_DW10(ch), val);\n\t}\n\n\tvlv_dpio_put(dev_priv);\n}\n\nvoid chv_data_lane_soft_reset(struct intel_encoder *encoder,\n\t\t\t      const struct intel_crtc_state *crtc_state,\n\t\t\t      bool reset)\n{\n\tstruct drm_i915_private *dev_priv = to_i915(encoder->base.dev);\n\tenum dpio_channel ch = vlv_dig_port_to_channel(enc_to_dig_port(encoder));\n\tstruct intel_crtc *crtc = to_intel_crtc(crtc_state->uapi.crtc);\n\tenum pipe pipe = crtc->pipe;\n\tu32 val;\n\n\tval = vlv_dpio_read(dev_priv, pipe, VLV_PCS01_DW0(ch));\n\tif (reset)\n\t\tval &= ~(DPIO_PCS_TX_LANE2_RESET | DPIO_PCS_TX_LANE1_RESET);\n\telse\n\t\tval |= DPIO_PCS_TX_LANE2_RESET | DPIO_PCS_TX_LANE1_RESET;\n\tvlv_dpio_write(dev_priv, pipe, VLV_PCS01_DW0(ch), val);\n\n\tif (crtc_state->lane_count > 2) {\n\t\tval = vlv_dpio_read(dev_priv, pipe, VLV_PCS23_DW0(ch));\n\t\tif (reset)\n\t\t\tval &= ~(DPIO_PCS_TX_LANE2_RESET | DPIO_PCS_TX_LANE1_RESET);\n\t\telse\n\t\t\tval |= DPIO_PCS_TX_LANE2_RESET | DPIO_PCS_TX_LANE1_RESET;\n\t\tvlv_dpio_write(dev_priv, pipe, VLV_PCS23_DW0(ch), val);\n\t}\n\n\tval = vlv_dpio_read(dev_priv, pipe, VLV_PCS01_DW1(ch));\n\tval |= CHV_PCS_REQ_SOFTRESET_EN;\n\tif (reset)\n\t\tval &= ~DPIO_PCS_CLK_SOFT_RESET;\n\telse\n\t\tval |= DPIO_PCS_CLK_SOFT_RESET;\n\tvlv_dpio_write(dev_priv, pipe, VLV_PCS01_DW1(ch), val);\n\n\tif (crtc_state->lane_count > 2) {\n\t\tval = vlv_dpio_read(dev_priv, pipe, VLV_PCS23_DW1(ch));\n\t\tval |= CHV_PCS_REQ_SOFTRESET_EN;\n\t\tif (reset)\n\t\t\tval &= ~DPIO_PCS_CLK_SOFT_RESET;\n\t\telse\n\t\t\tval |= DPIO_PCS_CLK_SOFT_RESET;\n\t\tvlv_dpio_write(dev_priv, pipe, VLV_PCS23_DW1(ch), val);\n\t}\n}\n\nvoid chv_phy_pre_pll_enable(struct intel_encoder *encoder,\n\t\t\t    const struct intel_crtc_state *crtc_state)\n{\n\tstruct intel_digital_port *dig_port = enc_to_dig_port(encoder);\n\tstruct drm_i915_private *dev_priv = to_i915(encoder->base.dev);\n\tstruct intel_crtc *crtc = to_intel_crtc(crtc_state->uapi.crtc);\n\tenum dpio_channel ch = vlv_dig_port_to_channel(dig_port);\n\tenum pipe pipe = crtc->pipe;\n\tunsigned int lane_mask =\n\t\tintel_dp_unused_lane_mask(crtc_state->lane_count);\n\tu32 val;\n\n\t \n\tif (ch == DPIO_CH0 && pipe == PIPE_B)\n\t\tdig_port->release_cl2_override =\n\t\t\t!chv_phy_powergate_ch(dev_priv, DPIO_PHY0, DPIO_CH1, true);\n\n\tchv_phy_powergate_lanes(encoder, true, lane_mask);\n\n\tvlv_dpio_get(dev_priv);\n\n\t \n\tchv_data_lane_soft_reset(encoder, crtc_state, true);\n\n\t \n\tif (pipe != PIPE_B) {\n\t\tval = vlv_dpio_read(dev_priv, pipe, _CHV_CMN_DW5_CH0);\n\t\tval &= ~(CHV_BUFLEFTENA1_MASK | CHV_BUFRIGHTENA1_MASK);\n\t\tif (ch == DPIO_CH0)\n\t\t\tval |= CHV_BUFLEFTENA1_FORCE;\n\t\tif (ch == DPIO_CH1)\n\t\t\tval |= CHV_BUFRIGHTENA1_FORCE;\n\t\tvlv_dpio_write(dev_priv, pipe, _CHV_CMN_DW5_CH0, val);\n\t} else {\n\t\tval = vlv_dpio_read(dev_priv, pipe, _CHV_CMN_DW1_CH1);\n\t\tval &= ~(CHV_BUFLEFTENA2_MASK | CHV_BUFRIGHTENA2_MASK);\n\t\tif (ch == DPIO_CH0)\n\t\t\tval |= CHV_BUFLEFTENA2_FORCE;\n\t\tif (ch == DPIO_CH1)\n\t\t\tval |= CHV_BUFRIGHTENA2_FORCE;\n\t\tvlv_dpio_write(dev_priv, pipe, _CHV_CMN_DW1_CH1, val);\n\t}\n\n\t \n\tval = vlv_dpio_read(dev_priv, pipe, VLV_PCS01_DW8(ch));\n\tval |= CHV_PCS_USEDCLKCHANNEL_OVRRIDE;\n\tif (pipe != PIPE_B)\n\t\tval &= ~CHV_PCS_USEDCLKCHANNEL;\n\telse\n\t\tval |= CHV_PCS_USEDCLKCHANNEL;\n\tvlv_dpio_write(dev_priv, pipe, VLV_PCS01_DW8(ch), val);\n\n\tif (crtc_state->lane_count > 2) {\n\t\tval = vlv_dpio_read(dev_priv, pipe, VLV_PCS23_DW8(ch));\n\t\tval |= CHV_PCS_USEDCLKCHANNEL_OVRRIDE;\n\t\tif (pipe != PIPE_B)\n\t\t\tval &= ~CHV_PCS_USEDCLKCHANNEL;\n\t\telse\n\t\t\tval |= CHV_PCS_USEDCLKCHANNEL;\n\t\tvlv_dpio_write(dev_priv, pipe, VLV_PCS23_DW8(ch), val);\n\t}\n\n\t \n\tval = vlv_dpio_read(dev_priv, pipe, CHV_CMN_DW19(ch));\n\tif (pipe != PIPE_B)\n\t\tval &= ~CHV_CMN_USEDCLKCHANNEL;\n\telse\n\t\tval |= CHV_CMN_USEDCLKCHANNEL;\n\tvlv_dpio_write(dev_priv, pipe, CHV_CMN_DW19(ch), val);\n\n\tvlv_dpio_put(dev_priv);\n}\n\nvoid chv_phy_pre_encoder_enable(struct intel_encoder *encoder,\n\t\t\t\tconst struct intel_crtc_state *crtc_state)\n{\n\tstruct intel_dp *intel_dp = enc_to_intel_dp(encoder);\n\tstruct intel_digital_port *dig_port = dp_to_dig_port(intel_dp);\n\tstruct drm_i915_private *dev_priv = to_i915(encoder->base.dev);\n\tstruct intel_crtc *crtc = to_intel_crtc(crtc_state->uapi.crtc);\n\tenum dpio_channel ch = vlv_dig_port_to_channel(dig_port);\n\tenum pipe pipe = crtc->pipe;\n\tint data, i, stagger;\n\tu32 val;\n\n\tvlv_dpio_get(dev_priv);\n\n\t \n\tval = vlv_dpio_read(dev_priv, pipe, VLV_PCS01_DW11(ch));\n\tval &= ~DPIO_LANEDESKEW_STRAP_OVRD;\n\tvlv_dpio_write(dev_priv, pipe, VLV_PCS01_DW11(ch), val);\n\n\tif (crtc_state->lane_count > 2) {\n\t\tval = vlv_dpio_read(dev_priv, pipe, VLV_PCS23_DW11(ch));\n\t\tval &= ~DPIO_LANEDESKEW_STRAP_OVRD;\n\t\tvlv_dpio_write(dev_priv, pipe, VLV_PCS23_DW11(ch), val);\n\t}\n\n\t \n\tfor (i = 0; i < crtc_state->lane_count; i++) {\n\t\t \n\t\tif (crtc_state->lane_count == 1)\n\t\t\tdata = 0x0;\n\t\telse\n\t\t\tdata = (i == 1) ? 0x0 : 0x1;\n\t\tvlv_dpio_write(dev_priv, pipe, CHV_TX_DW14(ch, i),\n\t\t\t\tdata << DPIO_UPAR_SHIFT);\n\t}\n\n\t \n\tif (crtc_state->port_clock > 270000)\n\t\tstagger = 0x18;\n\telse if (crtc_state->port_clock > 135000)\n\t\tstagger = 0xd;\n\telse if (crtc_state->port_clock > 67500)\n\t\tstagger = 0x7;\n\telse if (crtc_state->port_clock > 33750)\n\t\tstagger = 0x4;\n\telse\n\t\tstagger = 0x2;\n\n\tval = vlv_dpio_read(dev_priv, pipe, VLV_PCS01_DW11(ch));\n\tval |= DPIO_TX2_STAGGER_MASK(0x1f);\n\tvlv_dpio_write(dev_priv, pipe, VLV_PCS01_DW11(ch), val);\n\n\tif (crtc_state->lane_count > 2) {\n\t\tval = vlv_dpio_read(dev_priv, pipe, VLV_PCS23_DW11(ch));\n\t\tval |= DPIO_TX2_STAGGER_MASK(0x1f);\n\t\tvlv_dpio_write(dev_priv, pipe, VLV_PCS23_DW11(ch), val);\n\t}\n\n\tvlv_dpio_write(dev_priv, pipe, VLV_PCS01_DW12(ch),\n\t\t       DPIO_LANESTAGGER_STRAP(stagger) |\n\t\t       DPIO_LANESTAGGER_STRAP_OVRD |\n\t\t       DPIO_TX1_STAGGER_MASK(0x1f) |\n\t\t       DPIO_TX1_STAGGER_MULT(6) |\n\t\t       DPIO_TX2_STAGGER_MULT(0));\n\n\tif (crtc_state->lane_count > 2) {\n\t\tvlv_dpio_write(dev_priv, pipe, VLV_PCS23_DW12(ch),\n\t\t\t       DPIO_LANESTAGGER_STRAP(stagger) |\n\t\t\t       DPIO_LANESTAGGER_STRAP_OVRD |\n\t\t\t       DPIO_TX1_STAGGER_MASK(0x1f) |\n\t\t\t       DPIO_TX1_STAGGER_MULT(7) |\n\t\t\t       DPIO_TX2_STAGGER_MULT(5));\n\t}\n\n\t \n\tchv_data_lane_soft_reset(encoder, crtc_state, false);\n\n\tvlv_dpio_put(dev_priv);\n}\n\nvoid chv_phy_release_cl2_override(struct intel_encoder *encoder)\n{\n\tstruct intel_digital_port *dig_port = enc_to_dig_port(encoder);\n\tstruct drm_i915_private *dev_priv = to_i915(encoder->base.dev);\n\n\tif (dig_port->release_cl2_override) {\n\t\tchv_phy_powergate_ch(dev_priv, DPIO_PHY0, DPIO_CH1, false);\n\t\tdig_port->release_cl2_override = false;\n\t}\n}\n\nvoid chv_phy_post_pll_disable(struct intel_encoder *encoder,\n\t\t\t      const struct intel_crtc_state *old_crtc_state)\n{\n\tstruct drm_i915_private *dev_priv = to_i915(encoder->base.dev);\n\tenum pipe pipe = to_intel_crtc(old_crtc_state->uapi.crtc)->pipe;\n\tu32 val;\n\n\tvlv_dpio_get(dev_priv);\n\n\t \n\tif (pipe != PIPE_B) {\n\t\tval = vlv_dpio_read(dev_priv, pipe, _CHV_CMN_DW5_CH0);\n\t\tval &= ~(CHV_BUFLEFTENA1_MASK | CHV_BUFRIGHTENA1_MASK);\n\t\tvlv_dpio_write(dev_priv, pipe, _CHV_CMN_DW5_CH0, val);\n\t} else {\n\t\tval = vlv_dpio_read(dev_priv, pipe, _CHV_CMN_DW1_CH1);\n\t\tval &= ~(CHV_BUFLEFTENA2_MASK | CHV_BUFRIGHTENA2_MASK);\n\t\tvlv_dpio_write(dev_priv, pipe, _CHV_CMN_DW1_CH1, val);\n\t}\n\n\tvlv_dpio_put(dev_priv);\n\n\t \n\tchv_phy_powergate_lanes(encoder, false, 0x0);\n}\n\nvoid vlv_set_phy_signal_level(struct intel_encoder *encoder,\n\t\t\t      const struct intel_crtc_state *crtc_state,\n\t\t\t      u32 demph_reg_value, u32 preemph_reg_value,\n\t\t\t      u32 uniqtranscale_reg_value, u32 tx3_demph)\n{\n\tstruct drm_i915_private *dev_priv = to_i915(encoder->base.dev);\n\tstruct intel_digital_port *dig_port = enc_to_dig_port(encoder);\n\tstruct intel_crtc *crtc = to_intel_crtc(crtc_state->uapi.crtc);\n\tenum dpio_channel port = vlv_dig_port_to_channel(dig_port);\n\tenum pipe pipe = crtc->pipe;\n\n\tvlv_dpio_get(dev_priv);\n\n\tvlv_dpio_write(dev_priv, pipe, VLV_TX_DW5(port), 0x00000000);\n\tvlv_dpio_write(dev_priv, pipe, VLV_TX_DW4(port), demph_reg_value);\n\tvlv_dpio_write(dev_priv, pipe, VLV_TX_DW2(port),\n\t\t\t uniqtranscale_reg_value);\n\tvlv_dpio_write(dev_priv, pipe, VLV_TX_DW3(port), 0x0C782040);\n\n\tif (tx3_demph)\n\t\tvlv_dpio_write(dev_priv, pipe, VLV_TX3_DW4(port), tx3_demph);\n\n\tvlv_dpio_write(dev_priv, pipe, VLV_PCS_DW11(port), 0x00030000);\n\tvlv_dpio_write(dev_priv, pipe, VLV_PCS_DW9(port), preemph_reg_value);\n\tvlv_dpio_write(dev_priv, pipe, VLV_TX_DW5(port), DPIO_TX_OCALINIT_EN);\n\n\tvlv_dpio_put(dev_priv);\n}\n\nvoid vlv_phy_pre_pll_enable(struct intel_encoder *encoder,\n\t\t\t    const struct intel_crtc_state *crtc_state)\n{\n\tstruct intel_digital_port *dig_port = enc_to_dig_port(encoder);\n\tstruct drm_i915_private *dev_priv = to_i915(encoder->base.dev);\n\tstruct intel_crtc *crtc = to_intel_crtc(crtc_state->uapi.crtc);\n\tenum dpio_channel port = vlv_dig_port_to_channel(dig_port);\n\tenum pipe pipe = crtc->pipe;\n\n\t \n\tvlv_dpio_get(dev_priv);\n\n\tvlv_dpio_write(dev_priv, pipe, VLV_PCS_DW0(port),\n\t\t\t DPIO_PCS_TX_LANE2_RESET |\n\t\t\t DPIO_PCS_TX_LANE1_RESET);\n\tvlv_dpio_write(dev_priv, pipe, VLV_PCS_DW1(port),\n\t\t\t DPIO_PCS_CLK_CRI_RXEB_EIOS_EN |\n\t\t\t DPIO_PCS_CLK_CRI_RXDIGFILTSG_EN |\n\t\t\t (1<<DPIO_PCS_CLK_DATAWIDTH_SHIFT) |\n\t\t\t\t DPIO_PCS_CLK_SOFT_RESET);\n\n\t \n\tvlv_dpio_write(dev_priv, pipe, VLV_PCS_DW12(port), 0x00750f00);\n\tvlv_dpio_write(dev_priv, pipe, VLV_TX_DW11(port), 0x00001500);\n\tvlv_dpio_write(dev_priv, pipe, VLV_TX_DW14(port), 0x40400000);\n\n\tvlv_dpio_put(dev_priv);\n}\n\nvoid vlv_phy_pre_encoder_enable(struct intel_encoder *encoder,\n\t\t\t\tconst struct intel_crtc_state *crtc_state)\n{\n\tstruct intel_dp *intel_dp = enc_to_intel_dp(encoder);\n\tstruct intel_digital_port *dig_port = dp_to_dig_port(intel_dp);\n\tstruct drm_i915_private *dev_priv = to_i915(encoder->base.dev);\n\tstruct intel_crtc *crtc = to_intel_crtc(crtc_state->uapi.crtc);\n\tenum dpio_channel port = vlv_dig_port_to_channel(dig_port);\n\tenum pipe pipe = crtc->pipe;\n\tu32 val;\n\n\tvlv_dpio_get(dev_priv);\n\n\t \n\tval = vlv_dpio_read(dev_priv, pipe, VLV_PCS01_DW8(port));\n\tval = 0;\n\tif (pipe)\n\t\tval |= (1<<21);\n\telse\n\t\tval &= ~(1<<21);\n\tval |= 0x001000c4;\n\tvlv_dpio_write(dev_priv, pipe, VLV_PCS_DW8(port), val);\n\n\t \n\tvlv_dpio_write(dev_priv, pipe, VLV_PCS_DW14(port), 0x00760018);\n\tvlv_dpio_write(dev_priv, pipe, VLV_PCS_DW23(port), 0x00400888);\n\n\tvlv_dpio_put(dev_priv);\n}\n\nvoid vlv_phy_reset_lanes(struct intel_encoder *encoder,\n\t\t\t const struct intel_crtc_state *old_crtc_state)\n{\n\tstruct intel_digital_port *dig_port = enc_to_dig_port(encoder);\n\tstruct drm_i915_private *dev_priv = to_i915(encoder->base.dev);\n\tstruct intel_crtc *crtc = to_intel_crtc(old_crtc_state->uapi.crtc);\n\tenum dpio_channel port = vlv_dig_port_to_channel(dig_port);\n\tenum pipe pipe = crtc->pipe;\n\n\tvlv_dpio_get(dev_priv);\n\tvlv_dpio_write(dev_priv, pipe, VLV_PCS_DW0(port), 0x00000000);\n\tvlv_dpio_write(dev_priv, pipe, VLV_PCS_DW1(port), 0x00e00060);\n\tvlv_dpio_put(dev_priv);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}