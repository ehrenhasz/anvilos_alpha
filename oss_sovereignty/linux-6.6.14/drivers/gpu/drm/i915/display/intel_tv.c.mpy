{
  "module_name": "intel_tv.c",
  "hash_id": "9bfb9f0c87884d03ba825986f3989edc0adb6201255a405edb3419f0b2f25036",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/i915/display/intel_tv.c",
  "human_readable_source": " \n\n \n\n#include <drm/drm_atomic_helper.h>\n#include <drm/drm_crtc.h>\n#include <drm/drm_edid.h>\n\n#include \"i915_drv.h\"\n#include \"i915_reg.h\"\n#include \"intel_connector.h\"\n#include \"intel_crtc.h\"\n#include \"intel_de.h\"\n#include \"intel_display_irq.h\"\n#include \"intel_display_types.h\"\n#include \"intel_dpll.h\"\n#include \"intel_hotplug.h\"\n#include \"intel_load_detect.h\"\n#include \"intel_tv.h\"\n#include \"intel_tv_regs.h\"\n\nenum tv_margin {\n\tTV_MARGIN_LEFT, TV_MARGIN_TOP,\n\tTV_MARGIN_RIGHT, TV_MARGIN_BOTTOM\n};\n\nstruct intel_tv {\n\tstruct intel_encoder base;\n\n\tint type;\n};\n\nstruct video_levels {\n\tu16 blank, black;\n\tu8 burst;\n};\n\nstruct color_conversion {\n\tu16 ry, gy, by, ay;\n\tu16 ru, gu, bu, au;\n\tu16 rv, gv, bv, av;\n};\n\nstatic const u32 filter_table[] = {\n\t0xB1403000, 0x2E203500, 0x35002E20, 0x3000B140,\n\t0x35A0B160, 0x2DC02E80, 0xB1403480, 0xB1603000,\n\t0x2EA03640, 0x34002D80, 0x3000B120, 0x36E0B160,\n\t0x2D202EF0, 0xB1203380, 0xB1603000, 0x2F303780,\n\t0x33002CC0, 0x3000B100, 0x3820B160, 0x2C802F50,\n\t0xB10032A0, 0xB1603000, 0x2F9038C0, 0x32202C20,\n\t0x3000B0E0, 0x3980B160, 0x2BC02FC0, 0xB0E031C0,\n\t0xB1603000, 0x2FF03A20, 0x31602B60, 0xB020B0C0,\n\t0x3AE0B160, 0x2B001810, 0xB0C03120, 0xB140B020,\n\t0x18283BA0, 0x30C02A80, 0xB020B0A0, 0x3C60B140,\n\t0x2A201838, 0xB0A03080, 0xB120B020, 0x18383D20,\n\t0x304029C0, 0xB040B080, 0x3DE0B100, 0x29601848,\n\t0xB0803000, 0xB100B040, 0x18483EC0, 0xB0402900,\n\t0xB040B060, 0x3F80B0C0, 0x28801858, 0xB060B080,\n\t0xB0A0B060, 0x18602820, 0xB0A02820, 0x0000B060,\n\t0xB1403000, 0x2E203500, 0x35002E20, 0x3000B140,\n\t0x35A0B160, 0x2DC02E80, 0xB1403480, 0xB1603000,\n\t0x2EA03640, 0x34002D80, 0x3000B120, 0x36E0B160,\n\t0x2D202EF0, 0xB1203380, 0xB1603000, 0x2F303780,\n\t0x33002CC0, 0x3000B100, 0x3820B160, 0x2C802F50,\n\t0xB10032A0, 0xB1603000, 0x2F9038C0, 0x32202C20,\n\t0x3000B0E0, 0x3980B160, 0x2BC02FC0, 0xB0E031C0,\n\t0xB1603000, 0x2FF03A20, 0x31602B60, 0xB020B0C0,\n\t0x3AE0B160, 0x2B001810, 0xB0C03120, 0xB140B020,\n\t0x18283BA0, 0x30C02A80, 0xB020B0A0, 0x3C60B140,\n\t0x2A201838, 0xB0A03080, 0xB120B020, 0x18383D20,\n\t0x304029C0, 0xB040B080, 0x3DE0B100, 0x29601848,\n\t0xB0803000, 0xB100B040, 0x18483EC0, 0xB0402900,\n\t0xB040B060, 0x3F80B0C0, 0x28801858, 0xB060B080,\n\t0xB0A0B060, 0x18602820, 0xB0A02820, 0x0000B060,\n\t0x36403000, 0x2D002CC0, 0x30003640, 0x2D0036C0,\n\t0x35C02CC0, 0x37403000, 0x2C802D40, 0x30003540,\n\t0x2D8037C0, 0x34C02C40, 0x38403000, 0x2BC02E00,\n\t0x30003440, 0x2E2038C0, 0x34002B80, 0x39803000,\n\t0x2B402E40, 0x30003380, 0x2E603A00, 0x33402B00,\n\t0x3A803040, 0x2A802EA0, 0x30403300, 0x2EC03B40,\n\t0x32802A40, 0x3C003040, 0x2A002EC0, 0x30803240,\n\t0x2EC03C80, 0x320029C0, 0x3D403080, 0x29402F00,\n\t0x308031C0, 0x2F203DC0, 0x31802900, 0x3E8030C0,\n\t0x28802F40, 0x30C03140, 0x2F203F40, 0x31402840,\n\t0x28003100, 0x28002F00, 0x00003100, 0x36403000,\n\t0x2D002CC0, 0x30003640, 0x2D0036C0,\n\t0x35C02CC0, 0x37403000, 0x2C802D40, 0x30003540,\n\t0x2D8037C0, 0x34C02C40, 0x38403000, 0x2BC02E00,\n\t0x30003440, 0x2E2038C0, 0x34002B80, 0x39803000,\n\t0x2B402E40, 0x30003380, 0x2E603A00, 0x33402B00,\n\t0x3A803040, 0x2A802EA0, 0x30403300, 0x2EC03B40,\n\t0x32802A40, 0x3C003040, 0x2A002EC0, 0x30803240,\n\t0x2EC03C80, 0x320029C0, 0x3D403080, 0x29402F00,\n\t0x308031C0, 0x2F203DC0, 0x31802900, 0x3E8030C0,\n\t0x28802F40, 0x30C03140, 0x2F203F40, 0x31402840,\n\t0x28003100, 0x28002F00, 0x00003100,\n};\n\n \n\n \n\n \nstatic const struct color_conversion ntsc_m_csc_composite = {\n\t.ry = 0x0332, .gy = 0x012d, .by = 0x07d3, .ay = 0x0104,\n\t.ru = 0x0733, .gu = 0x052d, .bu = 0x05c7, .au = 0x0200,\n\t.rv = 0x0340, .gv = 0x030c, .bv = 0x06d0, .av = 0x0200,\n};\n\nstatic const struct video_levels ntsc_m_levels_composite = {\n\t.blank = 225, .black = 267, .burst = 113,\n};\n\nstatic const struct color_conversion ntsc_m_csc_svideo = {\n\t.ry = 0x0332, .gy = 0x012d, .by = 0x07d3, .ay = 0x0133,\n\t.ru = 0x076a, .gu = 0x0564, .bu = 0x030d, .au = 0x0200,\n\t.rv = 0x037a, .gv = 0x033d, .bv = 0x06f6, .av = 0x0200,\n};\n\nstatic const struct video_levels ntsc_m_levels_svideo = {\n\t.blank = 266, .black = 316, .burst = 133,\n};\n\nstatic const struct color_conversion ntsc_j_csc_composite = {\n\t.ry = 0x0332, .gy = 0x012d, .by = 0x07d3, .ay = 0x0119,\n\t.ru = 0x074c, .gu = 0x0546, .bu = 0x05ec, .au = 0x0200,\n\t.rv = 0x035a, .gv = 0x0322, .bv = 0x06e1, .av = 0x0200,\n};\n\nstatic const struct video_levels ntsc_j_levels_composite = {\n\t.blank = 225, .black = 225, .burst = 113,\n};\n\nstatic const struct color_conversion ntsc_j_csc_svideo = {\n\t.ry = 0x0332, .gy = 0x012d, .by = 0x07d3, .ay = 0x014c,\n\t.ru = 0x0788, .gu = 0x0581, .bu = 0x0322, .au = 0x0200,\n\t.rv = 0x0399, .gv = 0x0356, .bv = 0x070a, .av = 0x0200,\n};\n\nstatic const struct video_levels ntsc_j_levels_svideo = {\n\t.blank = 266, .black = 266, .burst = 133,\n};\n\nstatic const struct color_conversion pal_csc_composite = {\n\t.ry = 0x0332, .gy = 0x012d, .by = 0x07d3, .ay = 0x0113,\n\t.ru = 0x0745, .gu = 0x053f, .bu = 0x05e1, .au = 0x0200,\n\t.rv = 0x0353, .gv = 0x031c, .bv = 0x06dc, .av = 0x0200,\n};\n\nstatic const struct video_levels pal_levels_composite = {\n\t.blank = 237, .black = 237, .burst = 118,\n};\n\nstatic const struct color_conversion pal_csc_svideo = {\n\t.ry = 0x0332, .gy = 0x012d, .by = 0x07d3, .ay = 0x0145,\n\t.ru = 0x0780, .gu = 0x0579, .bu = 0x031c, .au = 0x0200,\n\t.rv = 0x0390, .gv = 0x034f, .bv = 0x0705, .av = 0x0200,\n};\n\nstatic const struct video_levels pal_levels_svideo = {\n\t.blank = 280, .black = 280, .burst = 139,\n};\n\nstatic const struct color_conversion pal_m_csc_composite = {\n\t.ry = 0x0332, .gy = 0x012d, .by = 0x07d3, .ay = 0x0104,\n\t.ru = 0x0733, .gu = 0x052d, .bu = 0x05c7, .au = 0x0200,\n\t.rv = 0x0340, .gv = 0x030c, .bv = 0x06d0, .av = 0x0200,\n};\n\nstatic const struct video_levels pal_m_levels_composite = {\n\t.blank = 225, .black = 267, .burst = 113,\n};\n\nstatic const struct color_conversion pal_m_csc_svideo = {\n\t.ry = 0x0332, .gy = 0x012d, .by = 0x07d3, .ay = 0x0133,\n\t.ru = 0x076a, .gu = 0x0564, .bu = 0x030d, .au = 0x0200,\n\t.rv = 0x037a, .gv = 0x033d, .bv = 0x06f6, .av = 0x0200,\n};\n\nstatic const struct video_levels pal_m_levels_svideo = {\n\t.blank = 266, .black = 316, .burst = 133,\n};\n\nstatic const struct color_conversion pal_n_csc_composite = {\n\t.ry = 0x0332, .gy = 0x012d, .by = 0x07d3, .ay = 0x0104,\n\t.ru = 0x0733, .gu = 0x052d, .bu = 0x05c7, .au = 0x0200,\n\t.rv = 0x0340, .gv = 0x030c, .bv = 0x06d0, .av = 0x0200,\n};\n\nstatic const struct video_levels pal_n_levels_composite = {\n\t.blank = 225, .black = 267, .burst = 118,\n};\n\nstatic const struct color_conversion pal_n_csc_svideo = {\n\t.ry = 0x0332, .gy = 0x012d, .by = 0x07d3, .ay = 0x0133,\n\t.ru = 0x076a, .gu = 0x0564, .bu = 0x030d, .au = 0x0200,\n\t.rv = 0x037a, .gv = 0x033d, .bv = 0x06f6, .av = 0x0200,\n};\n\nstatic const struct video_levels pal_n_levels_svideo = {\n\t.blank = 266, .black = 316, .burst = 139,\n};\n\n \nstatic const struct color_conversion sdtv_csc_yprpb = {\n\t.ry = 0x0332, .gy = 0x012d, .by = 0x07d3, .ay = 0x0145,\n\t.ru = 0x0559, .gu = 0x0353, .bu = 0x0100, .au = 0x0200,\n\t.rv = 0x0100, .gv = 0x03ad, .bv = 0x074d, .av = 0x0200,\n};\n\nstatic const struct color_conversion hdtv_csc_yprpb = {\n\t.ry = 0x05b3, .gy = 0x016e, .by = 0x0728, .ay = 0x0145,\n\t.ru = 0x07d5, .gu = 0x038b, .bu = 0x0100, .au = 0x0200,\n\t.rv = 0x0100, .gv = 0x03d1, .bv = 0x06bc, .av = 0x0200,\n};\n\nstatic const struct video_levels component_levels = {\n\t.blank = 279, .black = 279, .burst = 0,\n};\n\n\nstruct tv_mode {\n\tconst char *name;\n\n\tu32 clock;\n\tu16 refresh;  \n\tu8 oversample;\n\tu8 hsync_end;\n\tu16 hblank_start, hblank_end, htotal;\n\tbool progressive : 1, trilevel_sync : 1, component_only : 1;\n\tu8 vsync_start_f1, vsync_start_f2, vsync_len;\n\tbool veq_ena : 1;\n\tu8 veq_start_f1, veq_start_f2, veq_len;\n\tu8 vi_end_f1, vi_end_f2;\n\tu16 nbr_end;\n\tbool burst_ena : 1;\n\tu8 hburst_start, hburst_len;\n\tu8 vburst_start_f1;\n\tu16 vburst_end_f1;\n\tu8 vburst_start_f2;\n\tu16 vburst_end_f2;\n\tu8 vburst_start_f3;\n\tu16 vburst_end_f3;\n\tu8 vburst_start_f4;\n\tu16 vburst_end_f4;\n\t \n\tu16 dda2_size, dda3_size;\n\tu8 dda1_inc;\n\tu16 dda2_inc, dda3_inc;\n\tu32 sc_reset;\n\tbool pal_burst : 1;\n\t \n\tconst struct video_levels *composite_levels, *svideo_levels;\n\tconst struct color_conversion *composite_color, *svideo_color;\n\tconst u32 *filter_table;\n};\n\n\n \n\n \nstatic const struct tv_mode tv_modes[] = {\n\t{\n\t\t.name\t\t= \"NTSC-M\",\n\t\t.clock\t\t= 108000,\n\t\t.refresh\t= 59940,\n\t\t.oversample\t= 8,\n\t\t.component_only = false,\n\t\t \n\n\t\t.hsync_end\t= 64,\t\t    .hblank_end\t\t= 124,\n\t\t.hblank_start\t= 836,\t\t    .htotal\t\t= 857,\n\n\t\t.progressive\t= false,\t    .trilevel_sync = false,\n\n\t\t.vsync_start_f1\t= 6,\t\t    .vsync_start_f2\t= 7,\n\t\t.vsync_len\t= 6,\n\n\t\t.veq_ena\t= true,\t\t    .veq_start_f1\t= 0,\n\t\t.veq_start_f2\t= 1,\t\t    .veq_len\t\t= 18,\n\n\t\t.vi_end_f1\t= 20,\t\t    .vi_end_f2\t\t= 21,\n\t\t.nbr_end\t= 240,\n\n\t\t.burst_ena\t= true,\n\t\t.hburst_start\t= 72,\t\t    .hburst_len\t\t= 34,\n\t\t.vburst_start_f1 = 9,\t\t    .vburst_end_f1\t= 240,\n\t\t.vburst_start_f2 = 10,\t\t    .vburst_end_f2\t= 240,\n\t\t.vburst_start_f3 = 9,\t\t    .vburst_end_f3\t= 240,\n\t\t.vburst_start_f4 = 10,\t\t    .vburst_end_f4\t= 240,\n\n\t\t \n\t\t.dda1_inc\t=    135,\n\t\t.dda2_inc\t=  20800,\t    .dda2_size\t\t=  27456,\n\t\t.dda3_inc\t=      0,\t    .dda3_size\t\t=      0,\n\t\t.sc_reset\t= TV_SC_RESET_EVERY_4,\n\t\t.pal_burst\t= false,\n\n\t\t.composite_levels = &ntsc_m_levels_composite,\n\t\t.composite_color = &ntsc_m_csc_composite,\n\t\t.svideo_levels  = &ntsc_m_levels_svideo,\n\t\t.svideo_color = &ntsc_m_csc_svideo,\n\n\t\t.filter_table = filter_table,\n\t},\n\t{\n\t\t.name\t\t= \"NTSC-443\",\n\t\t.clock\t\t= 108000,\n\t\t.refresh\t= 59940,\n\t\t.oversample\t= 8,\n\t\t.component_only = false,\n\t\t \n\t\t.hsync_end\t= 64,\t\t    .hblank_end\t\t= 124,\n\t\t.hblank_start\t= 836,\t\t    .htotal\t\t= 857,\n\n\t\t.progressive\t= false,\t    .trilevel_sync = false,\n\n\t\t.vsync_start_f1 = 6,\t\t    .vsync_start_f2\t= 7,\n\t\t.vsync_len\t= 6,\n\n\t\t.veq_ena\t= true,\t\t    .veq_start_f1\t= 0,\n\t\t.veq_start_f2\t= 1,\t\t    .veq_len\t\t= 18,\n\n\t\t.vi_end_f1\t= 20,\t\t    .vi_end_f2\t\t= 21,\n\t\t.nbr_end\t= 240,\n\n\t\t.burst_ena\t= true,\n\t\t.hburst_start\t= 72,\t\t    .hburst_len\t\t= 34,\n\t\t.vburst_start_f1 = 9,\t\t    .vburst_end_f1\t= 240,\n\t\t.vburst_start_f2 = 10,\t\t    .vburst_end_f2\t= 240,\n\t\t.vburst_start_f3 = 9,\t\t    .vburst_end_f3\t= 240,\n\t\t.vburst_start_f4 = 10,\t\t    .vburst_end_f4\t= 240,\n\n\t\t \n\t\t.dda1_inc       =    168,\n\t\t.dda2_inc       =   4093,       .dda2_size      =  27456,\n\t\t.dda3_inc       =    310,       .dda3_size      =    525,\n\t\t.sc_reset   = TV_SC_RESET_NEVER,\n\t\t.pal_burst  = false,\n\n\t\t.composite_levels = &ntsc_m_levels_composite,\n\t\t.composite_color = &ntsc_m_csc_composite,\n\t\t.svideo_levels  = &ntsc_m_levels_svideo,\n\t\t.svideo_color = &ntsc_m_csc_svideo,\n\n\t\t.filter_table = filter_table,\n\t},\n\t{\n\t\t.name\t\t= \"NTSC-J\",\n\t\t.clock\t\t= 108000,\n\t\t.refresh\t= 59940,\n\t\t.oversample\t= 8,\n\t\t.component_only = false,\n\n\t\t \n\t\t.hsync_end\t= 64,\t\t    .hblank_end\t\t= 124,\n\t\t.hblank_start = 836,\t    .htotal\t\t= 857,\n\n\t\t.progressive\t= false,    .trilevel_sync = false,\n\n\t\t.vsync_start_f1\t= 6,\t    .vsync_start_f2\t= 7,\n\t\t.vsync_len\t= 6,\n\n\t\t.veq_ena      = true,\t    .veq_start_f1\t= 0,\n\t\t.veq_start_f2 = 1,\t    .veq_len\t\t= 18,\n\n\t\t.vi_end_f1\t= 20,\t\t    .vi_end_f2\t\t= 21,\n\t\t.nbr_end\t= 240,\n\n\t\t.burst_ena\t= true,\n\t\t.hburst_start\t= 72,\t\t    .hburst_len\t\t= 34,\n\t\t.vburst_start_f1 = 9,\t\t    .vburst_end_f1\t= 240,\n\t\t.vburst_start_f2 = 10,\t\t    .vburst_end_f2\t= 240,\n\t\t.vburst_start_f3 = 9,\t\t    .vburst_end_f3\t= 240,\n\t\t.vburst_start_f4 = 10,\t\t    .vburst_end_f4\t= 240,\n\n\t\t \n\t\t.dda1_inc\t=    135,\n\t\t.dda2_inc\t=  20800,\t    .dda2_size\t\t=  27456,\n\t\t.dda3_inc\t=      0,\t    .dda3_size\t\t=      0,\n\t\t.sc_reset\t= TV_SC_RESET_EVERY_4,\n\t\t.pal_burst\t= false,\n\n\t\t.composite_levels = &ntsc_j_levels_composite,\n\t\t.composite_color = &ntsc_j_csc_composite,\n\t\t.svideo_levels  = &ntsc_j_levels_svideo,\n\t\t.svideo_color = &ntsc_j_csc_svideo,\n\n\t\t.filter_table = filter_table,\n\t},\n\t{\n\t\t.name\t\t= \"PAL-M\",\n\t\t.clock\t\t= 108000,\n\t\t.refresh\t= 59940,\n\t\t.oversample\t= 8,\n\t\t.component_only = false,\n\n\t\t \n\t\t.hsync_end\t= 64,\t\t  .hblank_end\t\t= 124,\n\t\t.hblank_start = 836,\t  .htotal\t\t= 857,\n\n\t\t.progressive\t= false,\t    .trilevel_sync = false,\n\n\t\t.vsync_start_f1\t= 6,\t\t    .vsync_start_f2\t= 7,\n\t\t.vsync_len\t= 6,\n\n\t\t.veq_ena\t= true,\t\t    .veq_start_f1\t= 0,\n\t\t.veq_start_f2\t= 1,\t\t    .veq_len\t\t= 18,\n\n\t\t.vi_end_f1\t= 20,\t\t    .vi_end_f2\t\t= 21,\n\t\t.nbr_end\t= 240,\n\n\t\t.burst_ena\t= true,\n\t\t.hburst_start\t= 72,\t\t    .hburst_len\t\t= 34,\n\t\t.vburst_start_f1 = 9,\t\t    .vburst_end_f1\t= 240,\n\t\t.vburst_start_f2 = 10,\t\t    .vburst_end_f2\t= 240,\n\t\t.vburst_start_f3 = 9,\t\t    .vburst_end_f3\t= 240,\n\t\t.vburst_start_f4 = 10,\t\t    .vburst_end_f4\t= 240,\n\n\t\t \n\t\t.dda1_inc\t=    135,\n\t\t.dda2_inc\t=  16704,\t    .dda2_size\t\t=  27456,\n\t\t.dda3_inc\t=      0,\t    .dda3_size\t\t=      0,\n\t\t.sc_reset\t= TV_SC_RESET_EVERY_8,\n\t\t.pal_burst  = true,\n\n\t\t.composite_levels = &pal_m_levels_composite,\n\t\t.composite_color = &pal_m_csc_composite,\n\t\t.svideo_levels  = &pal_m_levels_svideo,\n\t\t.svideo_color = &pal_m_csc_svideo,\n\n\t\t.filter_table = filter_table,\n\t},\n\t{\n\t\t \n\t\t.name\t    = \"PAL-N\",\n\t\t.clock\t\t= 108000,\n\t\t.refresh\t= 50000,\n\t\t.oversample\t= 8,\n\t\t.component_only = false,\n\n\t\t.hsync_end\t= 64,\t\t    .hblank_end\t\t= 128,\n\t\t.hblank_start = 844,\t    .htotal\t\t= 863,\n\n\t\t.progressive  = false,    .trilevel_sync = false,\n\n\n\t\t.vsync_start_f1\t= 6,\t   .vsync_start_f2\t= 7,\n\t\t.vsync_len\t= 6,\n\n\t\t.veq_ena\t= true,\t\t    .veq_start_f1\t= 0,\n\t\t.veq_start_f2\t= 1,\t\t    .veq_len\t\t= 18,\n\n\t\t.vi_end_f1\t= 24,\t\t    .vi_end_f2\t\t= 25,\n\t\t.nbr_end\t= 286,\n\n\t\t.burst_ena\t= true,\n\t\t.hburst_start = 73,\t    .hburst_len\t\t= 34,\n\t\t.vburst_start_f1 = 8,\t    .vburst_end_f1\t= 285,\n\t\t.vburst_start_f2 = 8,\t    .vburst_end_f2\t= 286,\n\t\t.vburst_start_f3 = 9,\t    .vburst_end_f3\t= 286,\n\t\t.vburst_start_f4 = 9,\t    .vburst_end_f4\t= 285,\n\n\n\t\t \n\t\t.dda1_inc       =    135,\n\t\t.dda2_inc       =  23578,       .dda2_size      =  27648,\n\t\t.dda3_inc       =    134,       .dda3_size      =    625,\n\t\t.sc_reset   = TV_SC_RESET_EVERY_8,\n\t\t.pal_burst  = true,\n\n\t\t.composite_levels = &pal_n_levels_composite,\n\t\t.composite_color = &pal_n_csc_composite,\n\t\t.svideo_levels  = &pal_n_levels_svideo,\n\t\t.svideo_color = &pal_n_csc_svideo,\n\n\t\t.filter_table = filter_table,\n\t},\n\t{\n\t\t \n\t\t.name\t    = \"PAL\",\n\t\t.clock\t\t= 108000,\n\t\t.refresh\t= 50000,\n\t\t.oversample\t= 8,\n\t\t.component_only = false,\n\n\t\t.hsync_end\t= 64,\t\t    .hblank_end\t\t= 142,\n\t\t.hblank_start\t= 844,\t    .htotal\t\t= 863,\n\n\t\t.progressive\t= false,    .trilevel_sync = false,\n\n\t\t.vsync_start_f1\t= 5,\t    .vsync_start_f2\t= 6,\n\t\t.vsync_len\t= 5,\n\n\t\t.veq_ena\t= true,\t    .veq_start_f1\t= 0,\n\t\t.veq_start_f2\t= 1,\t    .veq_len\t\t= 15,\n\n\t\t.vi_end_f1\t= 24,\t\t    .vi_end_f2\t\t= 25,\n\t\t.nbr_end\t= 286,\n\n\t\t.burst_ena\t= true,\n\t\t.hburst_start\t= 73,\t\t    .hburst_len\t\t= 32,\n\t\t.vburst_start_f1 = 8,\t\t    .vburst_end_f1\t= 285,\n\t\t.vburst_start_f2 = 8,\t\t    .vburst_end_f2\t= 286,\n\t\t.vburst_start_f3 = 9,\t\t    .vburst_end_f3\t= 286,\n\t\t.vburst_start_f4 = 9,\t\t    .vburst_end_f4\t= 285,\n\n\t\t \n\t\t.dda1_inc       =    168,\n\t\t.dda2_inc       =   4122,       .dda2_size      =  27648,\n\t\t.dda3_inc       =     67,       .dda3_size      =    625,\n\t\t.sc_reset   = TV_SC_RESET_EVERY_8,\n\t\t.pal_burst  = true,\n\n\t\t.composite_levels = &pal_levels_composite,\n\t\t.composite_color = &pal_csc_composite,\n\t\t.svideo_levels  = &pal_levels_svideo,\n\t\t.svideo_color = &pal_csc_svideo,\n\n\t\t.filter_table = filter_table,\n\t},\n\t{\n\t\t.name       = \"480p\",\n\t\t.clock\t\t= 108000,\n\t\t.refresh\t= 59940,\n\t\t.oversample     = 4,\n\t\t.component_only = true,\n\n\t\t.hsync_end      = 64,               .hblank_end         = 122,\n\t\t.hblank_start   = 842,              .htotal             = 857,\n\n\t\t.progressive    = true,\t\t    .trilevel_sync = false,\n\n\t\t.vsync_start_f1 = 12,               .vsync_start_f2     = 12,\n\t\t.vsync_len      = 12,\n\n\t\t.veq_ena        = false,\n\n\t\t.vi_end_f1      = 44,               .vi_end_f2          = 44,\n\t\t.nbr_end        = 479,\n\n\t\t.burst_ena      = false,\n\n\t\t.filter_table = filter_table,\n\t},\n\t{\n\t\t.name       = \"576p\",\n\t\t.clock\t\t= 108000,\n\t\t.refresh\t= 50000,\n\t\t.oversample     = 4,\n\t\t.component_only = true,\n\n\t\t.hsync_end      = 64,               .hblank_end         = 139,\n\t\t.hblank_start   = 859,              .htotal             = 863,\n\n\t\t.progressive    = true,\t\t    .trilevel_sync = false,\n\n\t\t.vsync_start_f1 = 10,               .vsync_start_f2     = 10,\n\t\t.vsync_len      = 10,\n\n\t\t.veq_ena        = false,\n\n\t\t.vi_end_f1      = 48,               .vi_end_f2          = 48,\n\t\t.nbr_end        = 575,\n\n\t\t.burst_ena      = false,\n\n\t\t.filter_table = filter_table,\n\t},\n\t{\n\t\t.name       = \"720p@60Hz\",\n\t\t.clock\t\t= 148500,\n\t\t.refresh\t= 60000,\n\t\t.oversample     = 2,\n\t\t.component_only = true,\n\n\t\t.hsync_end      = 80,               .hblank_end         = 300,\n\t\t.hblank_start   = 1580,             .htotal             = 1649,\n\n\t\t.progressive\t= true,\t\t    .trilevel_sync = true,\n\n\t\t.vsync_start_f1 = 10,               .vsync_start_f2     = 10,\n\t\t.vsync_len      = 10,\n\n\t\t.veq_ena        = false,\n\n\t\t.vi_end_f1      = 29,               .vi_end_f2          = 29,\n\t\t.nbr_end        = 719,\n\n\t\t.burst_ena      = false,\n\n\t\t.filter_table = filter_table,\n\t},\n\t{\n\t\t.name       = \"720p@50Hz\",\n\t\t.clock\t\t= 148500,\n\t\t.refresh\t= 50000,\n\t\t.oversample     = 2,\n\t\t.component_only = true,\n\n\t\t.hsync_end      = 80,               .hblank_end         = 300,\n\t\t.hblank_start   = 1580,             .htotal             = 1979,\n\n\t\t.progressive\t= true,\t\t    .trilevel_sync = true,\n\n\t\t.vsync_start_f1 = 10,               .vsync_start_f2     = 10,\n\t\t.vsync_len      = 10,\n\n\t\t.veq_ena        = false,\n\n\t\t.vi_end_f1      = 29,               .vi_end_f2          = 29,\n\t\t.nbr_end        = 719,\n\n\t\t.burst_ena      = false,\n\n\t\t.filter_table = filter_table,\n\t},\n\t{\n\t\t.name       = \"1080i@50Hz\",\n\t\t.clock\t\t= 148500,\n\t\t.refresh\t= 50000,\n\t\t.oversample     = 2,\n\t\t.component_only = true,\n\n\t\t.hsync_end      = 88,               .hblank_end         = 235,\n\t\t.hblank_start   = 2155,             .htotal             = 2639,\n\n\t\t.progressive\t= false,\t  .trilevel_sync = true,\n\n\t\t.vsync_start_f1 = 4,              .vsync_start_f2     = 5,\n\t\t.vsync_len      = 10,\n\n\t\t.veq_ena\t= true,\t    .veq_start_f1\t= 4,\n\t\t.veq_start_f2   = 4,\t    .veq_len\t\t= 10,\n\n\n\t\t.vi_end_f1      = 21,           .vi_end_f2          = 22,\n\t\t.nbr_end        = 539,\n\n\t\t.burst_ena      = false,\n\n\t\t.filter_table = filter_table,\n\t},\n\t{\n\t\t.name       = \"1080i@60Hz\",\n\t\t.clock\t\t= 148500,\n\t\t.refresh\t= 60000,\n\t\t.oversample     = 2,\n\t\t.component_only = true,\n\n\t\t.hsync_end      = 88,               .hblank_end         = 235,\n\t\t.hblank_start   = 2155,             .htotal             = 2199,\n\n\t\t.progressive\t= false,\t    .trilevel_sync = true,\n\n\t\t.vsync_start_f1 = 4,               .vsync_start_f2     = 5,\n\t\t.vsync_len      = 10,\n\n\t\t.veq_ena\t= true,\t\t    .veq_start_f1\t= 4,\n\t\t.veq_start_f2\t= 4,\t\t    .veq_len\t\t= 10,\n\n\n\t\t.vi_end_f1      = 21,               .vi_end_f2          = 22,\n\t\t.nbr_end        = 539,\n\n\t\t.burst_ena      = false,\n\n\t\t.filter_table = filter_table,\n\t},\n\n\t{\n\t\t.name       = \"1080p@30Hz\",\n\t\t.clock\t\t= 148500,\n\t\t.refresh\t= 30000,\n\t\t.oversample     = 2,\n\t\t.component_only = true,\n\n\t\t.hsync_end      = 88,               .hblank_end         = 235,\n\t\t.hblank_start   = 2155,             .htotal             = 2199,\n\n\t\t.progressive\t= true,\t\t    .trilevel_sync = true,\n\n\t\t.vsync_start_f1 = 8,               .vsync_start_f2     = 8,\n\t\t.vsync_len      = 10,\n\n\t\t.veq_ena\t= false,\t.veq_start_f1\t= 0,\n\t\t.veq_start_f2\t= 0,\t\t    .veq_len\t\t= 0,\n\n\t\t.vi_end_f1      = 44,               .vi_end_f2          = 44,\n\t\t.nbr_end        = 1079,\n\n\t\t.burst_ena      = false,\n\n\t\t.filter_table = filter_table,\n\t},\n\n\t{\n\t\t.name       = \"1080p@50Hz\",\n\t\t.clock\t\t= 148500,\n\t\t.refresh\t= 50000,\n\t\t.oversample     = 1,\n\t\t.component_only = true,\n\n\t\t.hsync_end      = 88,               .hblank_end         = 235,\n\t\t.hblank_start   = 2155,             .htotal             = 2639,\n\n\t\t.progressive\t= true,\t\t    .trilevel_sync = true,\n\n\t\t.vsync_start_f1 = 8,               .vsync_start_f2     = 8,\n\t\t.vsync_len      = 10,\n\n\t\t.veq_ena\t= false,\t.veq_start_f1\t= 0,\n\t\t.veq_start_f2\t= 0,\t\t    .veq_len\t\t= 0,\n\n\t\t.vi_end_f1      = 44,               .vi_end_f2          = 44,\n\t\t.nbr_end        = 1079,\n\n\t\t.burst_ena      = false,\n\n\t\t.filter_table = filter_table,\n\t},\n\n\t{\n\t\t.name       = \"1080p@60Hz\",\n\t\t.clock\t\t= 148500,\n\t\t.refresh\t= 60000,\n\t\t.oversample     = 1,\n\t\t.component_only = true,\n\n\t\t.hsync_end      = 88,               .hblank_end         = 235,\n\t\t.hblank_start   = 2155,             .htotal             = 2199,\n\n\t\t.progressive\t= true,\t\t    .trilevel_sync = true,\n\n\t\t.vsync_start_f1 = 8,               .vsync_start_f2     = 8,\n\t\t.vsync_len      = 10,\n\n\t\t.veq_ena\t= false,\t\t    .veq_start_f1\t= 0,\n\t\t.veq_start_f2\t= 0,\t\t    .veq_len\t\t= 0,\n\n\t\t.vi_end_f1      = 44,               .vi_end_f2          = 44,\n\t\t.nbr_end        = 1079,\n\n\t\t.burst_ena      = false,\n\n\t\t.filter_table = filter_table,\n\t},\n};\n\nstruct intel_tv_connector_state {\n\tstruct drm_connector_state base;\n\n\t \n\tstruct {\n\t\tu16 top, bottom;\n\t} margins;\n\n\tbool bypass_vfilter;\n};\n\n#define to_intel_tv_connector_state(x) container_of(x, struct intel_tv_connector_state, base)\n\nstatic struct drm_connector_state *\nintel_tv_connector_duplicate_state(struct drm_connector *connector)\n{\n\tstruct intel_tv_connector_state *state;\n\n\tstate = kmemdup(connector->state, sizeof(*state), GFP_KERNEL);\n\tif (!state)\n\t\treturn NULL;\n\n\t__drm_atomic_helper_connector_duplicate_state(connector, &state->base);\n\treturn &state->base;\n}\n\nstatic struct intel_tv *enc_to_tv(struct intel_encoder *encoder)\n{\n\treturn container_of(encoder, struct intel_tv, base);\n}\n\nstatic struct intel_tv *intel_attached_tv(struct intel_connector *connector)\n{\n\treturn enc_to_tv(intel_attached_encoder(connector));\n}\n\nstatic bool\nintel_tv_get_hw_state(struct intel_encoder *encoder, enum pipe *pipe)\n{\n\tstruct drm_i915_private *dev_priv = to_i915(encoder->base.dev);\n\tu32 tmp = intel_de_read(dev_priv, TV_CTL);\n\n\t*pipe = (tmp & TV_ENC_PIPE_SEL_MASK) >> TV_ENC_PIPE_SEL_SHIFT;\n\n\treturn tmp & TV_ENC_ENABLE;\n}\n\nstatic void\nintel_enable_tv(struct intel_atomic_state *state,\n\t\tstruct intel_encoder *encoder,\n\t\tconst struct intel_crtc_state *pipe_config,\n\t\tconst struct drm_connector_state *conn_state)\n{\n\tstruct drm_device *dev = encoder->base.dev;\n\tstruct drm_i915_private *dev_priv = to_i915(dev);\n\n\t \n\tintel_crtc_wait_for_next_vblank(to_intel_crtc(pipe_config->uapi.crtc));\n\n\tintel_de_rmw(dev_priv, TV_CTL, 0, TV_ENC_ENABLE);\n}\n\nstatic void\nintel_disable_tv(struct intel_atomic_state *state,\n\t\t struct intel_encoder *encoder,\n\t\t const struct intel_crtc_state *old_crtc_state,\n\t\t const struct drm_connector_state *old_conn_state)\n{\n\tstruct drm_device *dev = encoder->base.dev;\n\tstruct drm_i915_private *dev_priv = to_i915(dev);\n\n\tintel_de_rmw(dev_priv, TV_CTL, TV_ENC_ENABLE, 0);\n}\n\nstatic const struct tv_mode *intel_tv_mode_find(const struct drm_connector_state *conn_state)\n{\n\tint format = conn_state->tv.mode;\n\n\treturn &tv_modes[format];\n}\n\nstatic enum drm_mode_status\nintel_tv_mode_valid(struct drm_connector *connector,\n\t\t    struct drm_display_mode *mode)\n{\n\tstruct drm_i915_private *i915 = to_i915(connector->dev);\n\tconst struct tv_mode *tv_mode = intel_tv_mode_find(connector->state);\n\tint max_dotclk = i915->max_dotclk_freq;\n\tenum drm_mode_status status;\n\n\tstatus = intel_cpu_transcoder_mode_valid(i915, mode);\n\tif (status != MODE_OK)\n\t\treturn status;\n\n\tif (mode->flags & DRM_MODE_FLAG_DBLSCAN)\n\t\treturn MODE_NO_DBLESCAN;\n\n\tif (mode->clock > max_dotclk)\n\t\treturn MODE_CLOCK_HIGH;\n\n\t \n\tif (abs(tv_mode->refresh - drm_mode_vrefresh(mode) * 1000) >= 1000)\n\t\treturn MODE_CLOCK_RANGE;\n\n\treturn MODE_OK;\n}\n\nstatic int\nintel_tv_mode_vdisplay(const struct tv_mode *tv_mode)\n{\n\tif (tv_mode->progressive)\n\t\treturn tv_mode->nbr_end + 1;\n\telse\n\t\treturn 2 * (tv_mode->nbr_end + 1);\n}\n\nstatic void\nintel_tv_mode_to_mode(struct drm_display_mode *mode,\n\t\t      const struct tv_mode *tv_mode,\n\t\t      int clock)\n{\n\tmode->clock = clock / (tv_mode->oversample >> !tv_mode->progressive);\n\n\t \n\tmode->hdisplay =\n\t\ttv_mode->hblank_start - tv_mode->hblank_end;\n\tmode->hsync_start = mode->hdisplay +\n\t\ttv_mode->htotal - tv_mode->hblank_start;\n\tmode->hsync_end = mode->hsync_start +\n\t\ttv_mode->hsync_end;\n\tmode->htotal = tv_mode->htotal + 1;\n\n\t \n\tmode->vdisplay = intel_tv_mode_vdisplay(tv_mode);\n\tif (tv_mode->progressive) {\n\t\tmode->vsync_start = mode->vdisplay +\n\t\t\ttv_mode->vsync_start_f1 + 1;\n\t\tmode->vsync_end = mode->vsync_start +\n\t\t\ttv_mode->vsync_len;\n\t\tmode->vtotal = mode->vdisplay +\n\t\t\ttv_mode->vi_end_f1 + 1;\n\t} else {\n\t\tmode->vsync_start = mode->vdisplay +\n\t\t\ttv_mode->vsync_start_f1 + 1 +\n\t\t\ttv_mode->vsync_start_f2 + 1;\n\t\tmode->vsync_end = mode->vsync_start +\n\t\t\t2 * tv_mode->vsync_len;\n\t\tmode->vtotal = mode->vdisplay +\n\t\t\ttv_mode->vi_end_f1 + 1 +\n\t\t\ttv_mode->vi_end_f2 + 1;\n\t}\n\n\t \n\tmode->flags = 0;\n\n\tsnprintf(mode->name, sizeof(mode->name),\n\t\t \"%dx%d%c (%s)\",\n\t\t mode->hdisplay, mode->vdisplay,\n\t\t tv_mode->progressive ? 'p' : 'i',\n\t\t tv_mode->name);\n}\n\nstatic void intel_tv_scale_mode_horiz(struct drm_display_mode *mode,\n\t\t\t\t      int hdisplay, int left_margin,\n\t\t\t\t      int right_margin)\n{\n\tint hsync_start = mode->hsync_start - mode->hdisplay + right_margin;\n\tint hsync_end = mode->hsync_end - mode->hdisplay + right_margin;\n\tint new_htotal = mode->htotal * hdisplay /\n\t\t(mode->hdisplay - left_margin - right_margin);\n\n\tmode->clock = mode->clock * new_htotal / mode->htotal;\n\n\tmode->hdisplay = hdisplay;\n\tmode->hsync_start = hdisplay + hsync_start * new_htotal / mode->htotal;\n\tmode->hsync_end = hdisplay + hsync_end * new_htotal / mode->htotal;\n\tmode->htotal = new_htotal;\n}\n\nstatic void intel_tv_scale_mode_vert(struct drm_display_mode *mode,\n\t\t\t\t     int vdisplay, int top_margin,\n\t\t\t\t     int bottom_margin)\n{\n\tint vsync_start = mode->vsync_start - mode->vdisplay + bottom_margin;\n\tint vsync_end = mode->vsync_end - mode->vdisplay + bottom_margin;\n\tint new_vtotal = mode->vtotal * vdisplay /\n\t\t(mode->vdisplay - top_margin - bottom_margin);\n\n\tmode->clock = mode->clock * new_vtotal / mode->vtotal;\n\n\tmode->vdisplay = vdisplay;\n\tmode->vsync_start = vdisplay + vsync_start * new_vtotal / mode->vtotal;\n\tmode->vsync_end = vdisplay + vsync_end * new_vtotal / mode->vtotal;\n\tmode->vtotal = new_vtotal;\n}\n\nstatic void\nintel_tv_get_config(struct intel_encoder *encoder,\n\t\t    struct intel_crtc_state *pipe_config)\n{\n\tstruct drm_i915_private *dev_priv = to_i915(encoder->base.dev);\n\tstruct drm_display_mode *adjusted_mode =\n\t\t&pipe_config->hw.adjusted_mode;\n\tstruct drm_display_mode mode = {};\n\tu32 tv_ctl, hctl1, hctl3, vctl1, vctl2, tmp;\n\tstruct tv_mode tv_mode = {};\n\tint hdisplay = adjusted_mode->crtc_hdisplay;\n\tint vdisplay = adjusted_mode->crtc_vdisplay;\n\tint xsize, ysize, xpos, ypos;\n\n\tpipe_config->output_types |= BIT(INTEL_OUTPUT_TVOUT);\n\n\ttv_ctl = intel_de_read(dev_priv, TV_CTL);\n\thctl1 = intel_de_read(dev_priv, TV_H_CTL_1);\n\thctl3 = intel_de_read(dev_priv, TV_H_CTL_3);\n\tvctl1 = intel_de_read(dev_priv, TV_V_CTL_1);\n\tvctl2 = intel_de_read(dev_priv, TV_V_CTL_2);\n\n\ttv_mode.htotal = (hctl1 & TV_HTOTAL_MASK) >> TV_HTOTAL_SHIFT;\n\ttv_mode.hsync_end = (hctl1 & TV_HSYNC_END_MASK) >> TV_HSYNC_END_SHIFT;\n\n\ttv_mode.hblank_start = (hctl3 & TV_HBLANK_START_MASK) >> TV_HBLANK_START_SHIFT;\n\ttv_mode.hblank_end = (hctl3 & TV_HSYNC_END_MASK) >> TV_HBLANK_END_SHIFT;\n\n\ttv_mode.nbr_end = (vctl1 & TV_NBR_END_MASK) >> TV_NBR_END_SHIFT;\n\ttv_mode.vi_end_f1 = (vctl1 & TV_VI_END_F1_MASK) >> TV_VI_END_F1_SHIFT;\n\ttv_mode.vi_end_f2 = (vctl1 & TV_VI_END_F2_MASK) >> TV_VI_END_F2_SHIFT;\n\n\ttv_mode.vsync_len = (vctl2 & TV_VSYNC_LEN_MASK) >> TV_VSYNC_LEN_SHIFT;\n\ttv_mode.vsync_start_f1 = (vctl2 & TV_VSYNC_START_F1_MASK) >> TV_VSYNC_START_F1_SHIFT;\n\ttv_mode.vsync_start_f2 = (vctl2 & TV_VSYNC_START_F2_MASK) >> TV_VSYNC_START_F2_SHIFT;\n\n\ttv_mode.clock = pipe_config->port_clock;\n\n\ttv_mode.progressive = tv_ctl & TV_PROGRESSIVE;\n\n\tswitch (tv_ctl & TV_OVERSAMPLE_MASK) {\n\tcase TV_OVERSAMPLE_8X:\n\t\ttv_mode.oversample = 8;\n\t\tbreak;\n\tcase TV_OVERSAMPLE_4X:\n\t\ttv_mode.oversample = 4;\n\t\tbreak;\n\tcase TV_OVERSAMPLE_2X:\n\t\ttv_mode.oversample = 2;\n\t\tbreak;\n\tdefault:\n\t\ttv_mode.oversample = 1;\n\t\tbreak;\n\t}\n\n\ttmp = intel_de_read(dev_priv, TV_WIN_POS);\n\txpos = tmp >> 16;\n\typos = tmp & 0xffff;\n\n\ttmp = intel_de_read(dev_priv, TV_WIN_SIZE);\n\txsize = tmp >> 16;\n\tysize = tmp & 0xffff;\n\n\tintel_tv_mode_to_mode(&mode, &tv_mode, pipe_config->port_clock);\n\n\tdrm_dbg_kms(&dev_priv->drm, \"TV mode: \" DRM_MODE_FMT \"\\n\",\n\t\t    DRM_MODE_ARG(&mode));\n\n\tintel_tv_scale_mode_horiz(&mode, hdisplay,\n\t\t\t\t  xpos, mode.hdisplay - xsize - xpos);\n\tintel_tv_scale_mode_vert(&mode, vdisplay,\n\t\t\t\t ypos, mode.vdisplay - ysize - ypos);\n\n\tadjusted_mode->crtc_clock = mode.clock;\n\tif (adjusted_mode->flags & DRM_MODE_FLAG_INTERLACE)\n\t\tadjusted_mode->crtc_clock /= 2;\n\n\t \n\tif (IS_I965GM(dev_priv))\n\t\tpipe_config->mode_flags |=\n\t\t\tI915_MODE_FLAG_USE_SCANLINE_COUNTER;\n}\n\nstatic bool intel_tv_source_too_wide(struct drm_i915_private *dev_priv,\n\t\t\t\t     int hdisplay)\n{\n\treturn DISPLAY_VER(dev_priv) == 3 && hdisplay > 1024;\n}\n\nstatic bool intel_tv_vert_scaling(const struct drm_display_mode *tv_mode,\n\t\t\t\t  const struct drm_connector_state *conn_state,\n\t\t\t\t  int vdisplay)\n{\n\treturn tv_mode->crtc_vdisplay -\n\t\tconn_state->tv.margins.top -\n\t\tconn_state->tv.margins.bottom !=\n\t\tvdisplay;\n}\n\nstatic int\nintel_tv_compute_config(struct intel_encoder *encoder,\n\t\t\tstruct intel_crtc_state *pipe_config,\n\t\t\tstruct drm_connector_state *conn_state)\n{\n\tstruct intel_atomic_state *state =\n\t\tto_intel_atomic_state(pipe_config->uapi.state);\n\tstruct intel_crtc *crtc = to_intel_crtc(pipe_config->uapi.crtc);\n\tstruct drm_i915_private *dev_priv = to_i915(encoder->base.dev);\n\tstruct intel_tv_connector_state *tv_conn_state =\n\t\tto_intel_tv_connector_state(conn_state);\n\tconst struct tv_mode *tv_mode = intel_tv_mode_find(conn_state);\n\tstruct drm_display_mode *adjusted_mode =\n\t\t&pipe_config->hw.adjusted_mode;\n\tint hdisplay = adjusted_mode->crtc_hdisplay;\n\tint vdisplay = adjusted_mode->crtc_vdisplay;\n\tint ret;\n\n\tif (!tv_mode)\n\t\treturn -EINVAL;\n\n\tif (adjusted_mode->flags & DRM_MODE_FLAG_DBLSCAN)\n\t\treturn -EINVAL;\n\n\tpipe_config->sink_format = INTEL_OUTPUT_FORMAT_RGB;\n\tpipe_config->output_format = INTEL_OUTPUT_FORMAT_RGB;\n\n\tdrm_dbg_kms(&dev_priv->drm, \"forcing bpc to 8 for TV\\n\");\n\tpipe_config->pipe_bpp = 8*3;\n\n\tpipe_config->port_clock = tv_mode->clock;\n\n\tret = intel_dpll_crtc_compute_clock(state, crtc);\n\tif (ret)\n\t\treturn ret;\n\n\tpipe_config->clock_set = true;\n\n\tintel_tv_mode_to_mode(adjusted_mode, tv_mode, pipe_config->port_clock);\n\tdrm_mode_set_crtcinfo(adjusted_mode, 0);\n\n\tif (intel_tv_source_too_wide(dev_priv, hdisplay) ||\n\t    !intel_tv_vert_scaling(adjusted_mode, conn_state, vdisplay)) {\n\t\tint extra, top, bottom;\n\n\t\textra = adjusted_mode->crtc_vdisplay - vdisplay;\n\n\t\tif (extra < 0) {\n\t\t\tdrm_dbg_kms(&dev_priv->drm,\n\t\t\t\t    \"No vertical scaling for >1024 pixel wide modes\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\t \n\n\t\t \n\t\ttop = conn_state->tv.margins.top;\n\t\tbottom = conn_state->tv.margins.bottom;\n\n\t\tif (top + bottom)\n\t\t\ttop = extra * top / (top + bottom);\n\t\telse\n\t\t\ttop = extra / 2;\n\t\tbottom = extra - top;\n\n\t\ttv_conn_state->margins.top = top;\n\t\ttv_conn_state->margins.bottom = bottom;\n\n\t\ttv_conn_state->bypass_vfilter = true;\n\n\t\tif (!tv_mode->progressive) {\n\t\t\tadjusted_mode->clock /= 2;\n\t\t\tadjusted_mode->crtc_clock /= 2;\n\t\t\tadjusted_mode->flags |= DRM_MODE_FLAG_INTERLACE;\n\t\t}\n\t} else {\n\t\ttv_conn_state->margins.top = conn_state->tv.margins.top;\n\t\ttv_conn_state->margins.bottom = conn_state->tv.margins.bottom;\n\n\t\ttv_conn_state->bypass_vfilter = false;\n\t}\n\n\tdrm_dbg_kms(&dev_priv->drm, \"TV mode: \" DRM_MODE_FMT \"\\n\",\n\t\t    DRM_MODE_ARG(adjusted_mode));\n\n\t \n\tintel_tv_scale_mode_horiz(adjusted_mode, hdisplay,\n\t\t\t\t  conn_state->tv.margins.left,\n\t\t\t\t  conn_state->tv.margins.right);\n\tintel_tv_scale_mode_vert(adjusted_mode, vdisplay,\n\t\t\t\t tv_conn_state->margins.top,\n\t\t\t\t tv_conn_state->margins.bottom);\n\tdrm_mode_set_crtcinfo(adjusted_mode, 0);\n\tadjusted_mode->name[0] = '\\0';\n\n\t \n\tif (IS_I965GM(dev_priv))\n\t\tpipe_config->mode_flags |=\n\t\t\tI915_MODE_FLAG_USE_SCANLINE_COUNTER;\n\n\treturn 0;\n}\n\nstatic void\nset_tv_mode_timings(struct drm_i915_private *dev_priv,\n\t\t    const struct tv_mode *tv_mode,\n\t\t    bool burst_ena)\n{\n\tu32 hctl1, hctl2, hctl3;\n\tu32 vctl1, vctl2, vctl3, vctl4, vctl5, vctl6, vctl7;\n\n\thctl1 = (tv_mode->hsync_end << TV_HSYNC_END_SHIFT) |\n\t\t(tv_mode->htotal << TV_HTOTAL_SHIFT);\n\n\thctl2 = (tv_mode->hburst_start << 16) |\n\t\t(tv_mode->hburst_len << TV_HBURST_LEN_SHIFT);\n\n\tif (burst_ena)\n\t\thctl2 |= TV_BURST_ENA;\n\n\thctl3 = (tv_mode->hblank_start << TV_HBLANK_START_SHIFT) |\n\t\t(tv_mode->hblank_end << TV_HBLANK_END_SHIFT);\n\n\tvctl1 = (tv_mode->nbr_end << TV_NBR_END_SHIFT) |\n\t\t(tv_mode->vi_end_f1 << TV_VI_END_F1_SHIFT) |\n\t\t(tv_mode->vi_end_f2 << TV_VI_END_F2_SHIFT);\n\n\tvctl2 = (tv_mode->vsync_len << TV_VSYNC_LEN_SHIFT) |\n\t\t(tv_mode->vsync_start_f1 << TV_VSYNC_START_F1_SHIFT) |\n\t\t(tv_mode->vsync_start_f2 << TV_VSYNC_START_F2_SHIFT);\n\n\tvctl3 = (tv_mode->veq_len << TV_VEQ_LEN_SHIFT) |\n\t\t(tv_mode->veq_start_f1 << TV_VEQ_START_F1_SHIFT) |\n\t\t(tv_mode->veq_start_f2 << TV_VEQ_START_F2_SHIFT);\n\n\tif (tv_mode->veq_ena)\n\t\tvctl3 |= TV_EQUAL_ENA;\n\n\tvctl4 = (tv_mode->vburst_start_f1 << TV_VBURST_START_F1_SHIFT) |\n\t\t(tv_mode->vburst_end_f1 << TV_VBURST_END_F1_SHIFT);\n\n\tvctl5 = (tv_mode->vburst_start_f2 << TV_VBURST_START_F2_SHIFT) |\n\t\t(tv_mode->vburst_end_f2 << TV_VBURST_END_F2_SHIFT);\n\n\tvctl6 = (tv_mode->vburst_start_f3 << TV_VBURST_START_F3_SHIFT) |\n\t\t(tv_mode->vburst_end_f3 << TV_VBURST_END_F3_SHIFT);\n\n\tvctl7 = (tv_mode->vburst_start_f4 << TV_VBURST_START_F4_SHIFT) |\n\t\t(tv_mode->vburst_end_f4 << TV_VBURST_END_F4_SHIFT);\n\n\tintel_de_write(dev_priv, TV_H_CTL_1, hctl1);\n\tintel_de_write(dev_priv, TV_H_CTL_2, hctl2);\n\tintel_de_write(dev_priv, TV_H_CTL_3, hctl3);\n\tintel_de_write(dev_priv, TV_V_CTL_1, vctl1);\n\tintel_de_write(dev_priv, TV_V_CTL_2, vctl2);\n\tintel_de_write(dev_priv, TV_V_CTL_3, vctl3);\n\tintel_de_write(dev_priv, TV_V_CTL_4, vctl4);\n\tintel_de_write(dev_priv, TV_V_CTL_5, vctl5);\n\tintel_de_write(dev_priv, TV_V_CTL_6, vctl6);\n\tintel_de_write(dev_priv, TV_V_CTL_7, vctl7);\n}\n\nstatic void set_color_conversion(struct drm_i915_private *dev_priv,\n\t\t\t\t const struct color_conversion *color_conversion)\n{\n\tif (!color_conversion)\n\t\treturn;\n\n\tintel_de_write(dev_priv, TV_CSC_Y,\n\t\t       (color_conversion->ry << 16) | color_conversion->gy);\n\tintel_de_write(dev_priv, TV_CSC_Y2,\n\t\t       (color_conversion->by << 16) | color_conversion->ay);\n\tintel_de_write(dev_priv, TV_CSC_U,\n\t\t       (color_conversion->ru << 16) | color_conversion->gu);\n\tintel_de_write(dev_priv, TV_CSC_U2,\n\t\t       (color_conversion->bu << 16) | color_conversion->au);\n\tintel_de_write(dev_priv, TV_CSC_V,\n\t\t       (color_conversion->rv << 16) | color_conversion->gv);\n\tintel_de_write(dev_priv, TV_CSC_V2,\n\t\t       (color_conversion->bv << 16) | color_conversion->av);\n}\n\nstatic void intel_tv_pre_enable(struct intel_atomic_state *state,\n\t\t\t\tstruct intel_encoder *encoder,\n\t\t\t\tconst struct intel_crtc_state *pipe_config,\n\t\t\t\tconst struct drm_connector_state *conn_state)\n{\n\tstruct drm_i915_private *dev_priv = to_i915(encoder->base.dev);\n\tstruct intel_crtc *crtc = to_intel_crtc(pipe_config->uapi.crtc);\n\tstruct intel_tv *intel_tv = enc_to_tv(encoder);\n\tconst struct intel_tv_connector_state *tv_conn_state =\n\t\tto_intel_tv_connector_state(conn_state);\n\tconst struct tv_mode *tv_mode = intel_tv_mode_find(conn_state);\n\tu32 tv_ctl, tv_filter_ctl;\n\tu32 scctl1, scctl2, scctl3;\n\tint i, j;\n\tconst struct video_levels *video_levels;\n\tconst struct color_conversion *color_conversion;\n\tbool burst_ena;\n\tint xpos, ypos;\n\tunsigned int xsize, ysize;\n\n\tif (!tv_mode)\n\t\treturn;\t \n\n\ttv_ctl = intel_de_read(dev_priv, TV_CTL);\n\ttv_ctl &= TV_CTL_SAVE;\n\n\tswitch (intel_tv->type) {\n\tdefault:\n\tcase DRM_MODE_CONNECTOR_Unknown:\n\tcase DRM_MODE_CONNECTOR_Composite:\n\t\ttv_ctl |= TV_ENC_OUTPUT_COMPOSITE;\n\t\tvideo_levels = tv_mode->composite_levels;\n\t\tcolor_conversion = tv_mode->composite_color;\n\t\tburst_ena = tv_mode->burst_ena;\n\t\tbreak;\n\tcase DRM_MODE_CONNECTOR_Component:\n\t\ttv_ctl |= TV_ENC_OUTPUT_COMPONENT;\n\t\tvideo_levels = &component_levels;\n\t\tif (tv_mode->burst_ena)\n\t\t\tcolor_conversion = &sdtv_csc_yprpb;\n\t\telse\n\t\t\tcolor_conversion = &hdtv_csc_yprpb;\n\t\tburst_ena = false;\n\t\tbreak;\n\tcase DRM_MODE_CONNECTOR_SVIDEO:\n\t\ttv_ctl |= TV_ENC_OUTPUT_SVIDEO;\n\t\tvideo_levels = tv_mode->svideo_levels;\n\t\tcolor_conversion = tv_mode->svideo_color;\n\t\tburst_ena = tv_mode->burst_ena;\n\t\tbreak;\n\t}\n\n\ttv_ctl |= TV_ENC_PIPE_SEL(crtc->pipe);\n\n\tswitch (tv_mode->oversample) {\n\tcase 8:\n\t\ttv_ctl |= TV_OVERSAMPLE_8X;\n\t\tbreak;\n\tcase 4:\n\t\ttv_ctl |= TV_OVERSAMPLE_4X;\n\t\tbreak;\n\tcase 2:\n\t\ttv_ctl |= TV_OVERSAMPLE_2X;\n\t\tbreak;\n\tdefault:\n\t\ttv_ctl |= TV_OVERSAMPLE_NONE;\n\t\tbreak;\n\t}\n\n\tif (tv_mode->progressive)\n\t\ttv_ctl |= TV_PROGRESSIVE;\n\tif (tv_mode->trilevel_sync)\n\t\ttv_ctl |= TV_TRILEVEL_SYNC;\n\tif (tv_mode->pal_burst)\n\t\ttv_ctl |= TV_PAL_BURST;\n\n\tscctl1 = 0;\n\tif (tv_mode->dda1_inc)\n\t\tscctl1 |= TV_SC_DDA1_EN;\n\tif (tv_mode->dda2_inc)\n\t\tscctl1 |= TV_SC_DDA2_EN;\n\tif (tv_mode->dda3_inc)\n\t\tscctl1 |= TV_SC_DDA3_EN;\n\tscctl1 |= tv_mode->sc_reset;\n\tif (video_levels)\n\t\tscctl1 |= video_levels->burst << TV_BURST_LEVEL_SHIFT;\n\tscctl1 |= tv_mode->dda1_inc << TV_SCDDA1_INC_SHIFT;\n\n\tscctl2 = tv_mode->dda2_size << TV_SCDDA2_SIZE_SHIFT |\n\t\ttv_mode->dda2_inc << TV_SCDDA2_INC_SHIFT;\n\n\tscctl3 = tv_mode->dda3_size << TV_SCDDA3_SIZE_SHIFT |\n\t\ttv_mode->dda3_inc << TV_SCDDA3_INC_SHIFT;\n\n\t \n\tif (IS_I915GM(dev_priv))\n\t\ttv_ctl |= TV_ENC_C0_FIX | TV_ENC_SDP_FIX;\n\n\tset_tv_mode_timings(dev_priv, tv_mode, burst_ena);\n\n\tintel_de_write(dev_priv, TV_SC_CTL_1, scctl1);\n\tintel_de_write(dev_priv, TV_SC_CTL_2, scctl2);\n\tintel_de_write(dev_priv, TV_SC_CTL_3, scctl3);\n\n\tset_color_conversion(dev_priv, color_conversion);\n\n\tif (DISPLAY_VER(dev_priv) >= 4)\n\t\tintel_de_write(dev_priv, TV_CLR_KNOBS, 0x00404000);\n\telse\n\t\tintel_de_write(dev_priv, TV_CLR_KNOBS, 0x00606000);\n\n\tif (video_levels)\n\t\tintel_de_write(dev_priv, TV_CLR_LEVEL,\n\t\t\t       ((video_levels->black << TV_BLACK_LEVEL_SHIFT) | (video_levels->blank << TV_BLANK_LEVEL_SHIFT)));\n\n\tassert_transcoder_disabled(dev_priv, pipe_config->cpu_transcoder);\n\n\t \n\ttv_filter_ctl = TV_AUTO_SCALE;\n\tif (tv_conn_state->bypass_vfilter)\n\t\ttv_filter_ctl |= TV_V_FILTER_BYPASS;\n\tintel_de_write(dev_priv, TV_FILTER_CTL_1, tv_filter_ctl);\n\n\txsize = tv_mode->hblank_start - tv_mode->hblank_end;\n\tysize = intel_tv_mode_vdisplay(tv_mode);\n\n\txpos = conn_state->tv.margins.left;\n\typos = tv_conn_state->margins.top;\n\txsize -= (conn_state->tv.margins.left +\n\t\t  conn_state->tv.margins.right);\n\tysize -= (tv_conn_state->margins.top +\n\t\t  tv_conn_state->margins.bottom);\n\tintel_de_write(dev_priv, TV_WIN_POS, (xpos << 16) | ypos);\n\tintel_de_write(dev_priv, TV_WIN_SIZE, (xsize << 16) | ysize);\n\n\tj = 0;\n\tfor (i = 0; i < 60; i++)\n\t\tintel_de_write(dev_priv, TV_H_LUMA(i),\n\t\t\t       tv_mode->filter_table[j++]);\n\tfor (i = 0; i < 60; i++)\n\t\tintel_de_write(dev_priv, TV_H_CHROMA(i),\n\t\t\t       tv_mode->filter_table[j++]);\n\tfor (i = 0; i < 43; i++)\n\t\tintel_de_write(dev_priv, TV_V_LUMA(i),\n\t\t\t       tv_mode->filter_table[j++]);\n\tfor (i = 0; i < 43; i++)\n\t\tintel_de_write(dev_priv, TV_V_CHROMA(i),\n\t\t\t       tv_mode->filter_table[j++]);\n\tintel_de_write(dev_priv, TV_DAC,\n\t\t       intel_de_read(dev_priv, TV_DAC) & TV_DAC_SAVE);\n\tintel_de_write(dev_priv, TV_CTL, tv_ctl);\n}\n\nstatic int\nintel_tv_detect_type(struct intel_tv *intel_tv,\n\t\t      struct drm_connector *connector)\n{\n\tstruct intel_crtc *crtc = to_intel_crtc(connector->state->crtc);\n\tstruct drm_device *dev = connector->dev;\n\tstruct drm_i915_private *dev_priv = to_i915(dev);\n\tu32 tv_ctl, save_tv_ctl;\n\tu32 tv_dac, save_tv_dac;\n\tint type;\n\n\t \n\tif (connector->polled & DRM_CONNECTOR_POLL_HPD) {\n\t\tspin_lock_irq(&dev_priv->irq_lock);\n\t\ti915_disable_pipestat(dev_priv, 0,\n\t\t\t\t      PIPE_HOTPLUG_INTERRUPT_STATUS |\n\t\t\t\t      PIPE_HOTPLUG_TV_INTERRUPT_STATUS);\n\t\tspin_unlock_irq(&dev_priv->irq_lock);\n\t}\n\n\tsave_tv_dac = tv_dac = intel_de_read(dev_priv, TV_DAC);\n\tsave_tv_ctl = tv_ctl = intel_de_read(dev_priv, TV_CTL);\n\n\t \n\ttv_ctl &= ~(TV_ENC_ENABLE | TV_ENC_PIPE_SEL_MASK | TV_TEST_MODE_MASK);\n\ttv_ctl |= TV_TEST_MODE_MONITOR_DETECT;\n\ttv_ctl |= TV_ENC_PIPE_SEL(crtc->pipe);\n\n\ttv_dac &= ~(TVDAC_SENSE_MASK | DAC_A_MASK | DAC_B_MASK | DAC_C_MASK);\n\ttv_dac |= (TVDAC_STATE_CHG_EN |\n\t\t   TVDAC_A_SENSE_CTL |\n\t\t   TVDAC_B_SENSE_CTL |\n\t\t   TVDAC_C_SENSE_CTL |\n\t\t   DAC_CTL_OVERRIDE |\n\t\t   DAC_A_0_7_V |\n\t\t   DAC_B_0_7_V |\n\t\t   DAC_C_0_7_V);\n\n\n\t \n\tif (IS_GM45(dev_priv))\n\t\ttv_dac &= ~(TVDAC_STATE_CHG_EN | TVDAC_A_SENSE_CTL |\n\t\t\t    TVDAC_B_SENSE_CTL | TVDAC_C_SENSE_CTL);\n\n\tintel_de_write(dev_priv, TV_CTL, tv_ctl);\n\tintel_de_write(dev_priv, TV_DAC, tv_dac);\n\tintel_de_posting_read(dev_priv, TV_DAC);\n\n\tintel_crtc_wait_for_next_vblank(crtc);\n\n\ttype = -1;\n\ttv_dac = intel_de_read(dev_priv, TV_DAC);\n\tdrm_dbg_kms(&dev_priv->drm, \"TV detected: %x, %x\\n\", tv_ctl, tv_dac);\n\t \n\tif ((tv_dac & TVDAC_SENSE_MASK) == (TVDAC_B_SENSE | TVDAC_C_SENSE)) {\n\t\tdrm_dbg_kms(&dev_priv->drm,\n\t\t\t    \"Detected Composite TV connection\\n\");\n\t\ttype = DRM_MODE_CONNECTOR_Composite;\n\t} else if ((tv_dac & (TVDAC_A_SENSE|TVDAC_B_SENSE)) == TVDAC_A_SENSE) {\n\t\tdrm_dbg_kms(&dev_priv->drm,\n\t\t\t    \"Detected S-Video TV connection\\n\");\n\t\ttype = DRM_MODE_CONNECTOR_SVIDEO;\n\t} else if ((tv_dac & TVDAC_SENSE_MASK) == 0) {\n\t\tdrm_dbg_kms(&dev_priv->drm,\n\t\t\t    \"Detected Component TV connection\\n\");\n\t\ttype = DRM_MODE_CONNECTOR_Component;\n\t} else {\n\t\tdrm_dbg_kms(&dev_priv->drm, \"Unrecognised TV connection\\n\");\n\t\ttype = -1;\n\t}\n\n\tintel_de_write(dev_priv, TV_DAC, save_tv_dac & ~TVDAC_STATE_CHG_EN);\n\tintel_de_write(dev_priv, TV_CTL, save_tv_ctl);\n\tintel_de_posting_read(dev_priv, TV_CTL);\n\n\t \n\tintel_crtc_wait_for_next_vblank(crtc);\n\n\t \n\tif (connector->polled & DRM_CONNECTOR_POLL_HPD) {\n\t\tspin_lock_irq(&dev_priv->irq_lock);\n\t\ti915_enable_pipestat(dev_priv, 0,\n\t\t\t\t     PIPE_HOTPLUG_INTERRUPT_STATUS |\n\t\t\t\t     PIPE_HOTPLUG_TV_INTERRUPT_STATUS);\n\t\tspin_unlock_irq(&dev_priv->irq_lock);\n\t}\n\n\treturn type;\n}\n\n \nstatic void intel_tv_find_better_format(struct drm_connector *connector)\n{\n\tstruct intel_tv *intel_tv = intel_attached_tv(to_intel_connector(connector));\n\tconst struct tv_mode *tv_mode = intel_tv_mode_find(connector->state);\n\tint i;\n\n\t \n\tif (intel_tv->type == DRM_MODE_CONNECTOR_Component)\n\t\treturn;\n\n\t \n\tif (!tv_mode->component_only)\n\t\treturn;\n\n\tfor (i = 0; i < ARRAY_SIZE(tv_modes); i++) {\n\t\ttv_mode = &tv_modes[i];\n\n\t\tif (!tv_mode->component_only)\n\t\t\tbreak;\n\t}\n\n\tconnector->state->tv.mode = i;\n}\n\nstatic int\nintel_tv_detect(struct drm_connector *connector,\n\t\tstruct drm_modeset_acquire_ctx *ctx,\n\t\tbool force)\n{\n\tstruct drm_i915_private *i915 = to_i915(connector->dev);\n\tstruct intel_tv *intel_tv = intel_attached_tv(to_intel_connector(connector));\n\tenum drm_connector_status status;\n\tint type;\n\n\tdrm_dbg_kms(&i915->drm, \"[CONNECTOR:%d:%s] force=%d\\n\",\n\t\t    connector->base.id, connector->name, force);\n\n\tif (!INTEL_DISPLAY_ENABLED(i915))\n\t\treturn connector_status_disconnected;\n\n\tif (force) {\n\t\tstruct drm_atomic_state *state;\n\n\t\tstate = intel_load_detect_get_pipe(connector, ctx);\n\t\tif (IS_ERR(state))\n\t\t\treturn PTR_ERR(state);\n\n\t\tif (state) {\n\t\t\ttype = intel_tv_detect_type(intel_tv, connector);\n\t\t\tintel_load_detect_release_pipe(connector, state, ctx);\n\t\t\tstatus = type < 0 ?\n\t\t\t\tconnector_status_disconnected :\n\t\t\t\tconnector_status_connected;\n\t\t} else {\n\t\t\tstatus = connector_status_unknown;\n\t\t}\n\n\t\tif (status == connector_status_connected) {\n\t\t\tintel_tv->type = type;\n\t\t\tintel_tv_find_better_format(connector);\n\t\t}\n\n\t\treturn status;\n\t} else\n\t\treturn connector->status;\n}\n\nstatic const struct input_res {\n\tu16 w, h;\n} input_res_table[] = {\n\t{ 640, 480 },\n\t{ 800, 600 },\n\t{ 1024, 768 },\n\t{ 1280, 1024 },\n\t{ 848, 480 },\n\t{ 1280, 720 },\n\t{ 1920, 1080 },\n};\n\n \nstatic bool\nintel_tv_is_preferred_mode(const struct drm_display_mode *mode,\n\t\t\t   const struct tv_mode *tv_mode)\n{\n\tint vdisplay = intel_tv_mode_vdisplay(tv_mode);\n\n\t \n\tif (vdisplay <= 576)\n\t\tvdisplay = 480;\n\n\treturn vdisplay == mode->vdisplay;\n}\n\nstatic void\nintel_tv_set_mode_type(struct drm_display_mode *mode,\n\t\t       const struct tv_mode *tv_mode)\n{\n\tmode->type = DRM_MODE_TYPE_DRIVER;\n\n\tif (intel_tv_is_preferred_mode(mode, tv_mode))\n\t\tmode->type |= DRM_MODE_TYPE_PREFERRED;\n}\n\nstatic int\nintel_tv_get_modes(struct drm_connector *connector)\n{\n\tstruct drm_i915_private *dev_priv = to_i915(connector->dev);\n\tconst struct tv_mode *tv_mode = intel_tv_mode_find(connector->state);\n\tint i, count = 0;\n\n\tfor (i = 0; i < ARRAY_SIZE(input_res_table); i++) {\n\t\tconst struct input_res *input = &input_res_table[i];\n\t\tstruct drm_display_mode *mode;\n\n\t\tif (input->w > 1024 &&\n\t\t    !tv_mode->progressive &&\n\t\t    !tv_mode->component_only)\n\t\t\tcontinue;\n\n\t\t \n\t\tif (DISPLAY_VER(dev_priv) == 3 && input->w > 1024 &&\n\t\t    input->h > intel_tv_mode_vdisplay(tv_mode))\n\t\t\tcontinue;\n\n\t\tmode = drm_mode_create(connector->dev);\n\t\tif (!mode)\n\t\t\tcontinue;\n\n\t\t \n\t\tintel_tv_mode_to_mode(mode, tv_mode, tv_mode->clock);\n\t\tif (count == 0) {\n\t\t\tdrm_dbg_kms(&dev_priv->drm, \"TV mode: \" DRM_MODE_FMT \"\\n\",\n\t\t\t\t    DRM_MODE_ARG(mode));\n\t\t}\n\t\tintel_tv_scale_mode_horiz(mode, input->w, 0, 0);\n\t\tintel_tv_scale_mode_vert(mode, input->h, 0, 0);\n\t\tintel_tv_set_mode_type(mode, tv_mode);\n\n\t\tdrm_mode_set_name(mode);\n\n\t\tdrm_mode_probed_add(connector, mode);\n\t\tcount++;\n\t}\n\n\treturn count;\n}\n\nstatic const struct drm_connector_funcs intel_tv_connector_funcs = {\n\t.late_register = intel_connector_register,\n\t.early_unregister = intel_connector_unregister,\n\t.destroy = intel_connector_destroy,\n\t.fill_modes = drm_helper_probe_single_connector_modes,\n\t.atomic_destroy_state = drm_atomic_helper_connector_destroy_state,\n\t.atomic_duplicate_state = intel_tv_connector_duplicate_state,\n};\n\nstatic int intel_tv_atomic_check(struct drm_connector *connector,\n\t\t\t\t struct drm_atomic_state *state)\n{\n\tstruct drm_connector_state *new_state;\n\tstruct drm_crtc_state *new_crtc_state;\n\tstruct drm_connector_state *old_state;\n\n\tnew_state = drm_atomic_get_new_connector_state(state, connector);\n\tif (!new_state->crtc)\n\t\treturn 0;\n\n\told_state = drm_atomic_get_old_connector_state(state, connector);\n\tnew_crtc_state = drm_atomic_get_new_crtc_state(state, new_state->crtc);\n\n\tif (old_state->tv.mode != new_state->tv.mode ||\n\t    old_state->tv.margins.left != new_state->tv.margins.left ||\n\t    old_state->tv.margins.right != new_state->tv.margins.right ||\n\t    old_state->tv.margins.top != new_state->tv.margins.top ||\n\t    old_state->tv.margins.bottom != new_state->tv.margins.bottom) {\n\t\t \n\n\t\tnew_crtc_state->connectors_changed = true;\n\t}\n\n\treturn 0;\n}\n\nstatic const struct drm_connector_helper_funcs intel_tv_connector_helper_funcs = {\n\t.detect_ctx = intel_tv_detect,\n\t.mode_valid = intel_tv_mode_valid,\n\t.get_modes = intel_tv_get_modes,\n\t.atomic_check = intel_tv_atomic_check,\n};\n\nstatic const struct drm_encoder_funcs intel_tv_enc_funcs = {\n\t.destroy = intel_encoder_destroy,\n};\n\nstatic void intel_tv_add_properties(struct drm_connector *connector)\n{\n\tstruct drm_i915_private *i915 = to_i915(connector->dev);\n\tstruct drm_connector_state *conn_state = connector->state;\n\tconst char *tv_format_names[ARRAY_SIZE(tv_modes)];\n\tint i;\n\n\t \n\tconn_state->tv.margins.left = 54;\n\tconn_state->tv.margins.top = 36;\n\tconn_state->tv.margins.right = 46;\n\tconn_state->tv.margins.bottom = 37;\n\n\tconn_state->tv.mode = 0;\n\n\t \n\tfor (i = 0; i < ARRAY_SIZE(tv_modes); i++) {\n\t\t \n\t\tif (DISPLAY_VER(i915) == 3 && tv_modes[i].oversample == 1)\n\t\t\tbreak;\n\n\t\ttv_format_names[i] = tv_modes[i].name;\n\t}\n\tdrm_mode_create_tv_properties_legacy(&i915->drm, i, tv_format_names);\n\n\tdrm_object_attach_property(&connector->base,\n\t\t\t\t   i915->drm.mode_config.legacy_tv_mode_property,\n\t\t\t\t   conn_state->tv.mode);\n\tdrm_object_attach_property(&connector->base,\n\t\t\t\t   i915->drm.mode_config.tv_left_margin_property,\n\t\t\t\t   conn_state->tv.margins.left);\n\tdrm_object_attach_property(&connector->base,\n\t\t\t\t   i915->drm.mode_config.tv_top_margin_property,\n\t\t\t\t   conn_state->tv.margins.top);\n\tdrm_object_attach_property(&connector->base,\n\t\t\t\t   i915->drm.mode_config.tv_right_margin_property,\n\t\t\t\t   conn_state->tv.margins.right);\n\tdrm_object_attach_property(&connector->base,\n\t\t\t\t   i915->drm.mode_config.tv_bottom_margin_property,\n\t\t\t\t   conn_state->tv.margins.bottom);\n}\n\nvoid\nintel_tv_init(struct drm_i915_private *dev_priv)\n{\n\tstruct drm_connector *connector;\n\tstruct intel_tv *intel_tv;\n\tstruct intel_encoder *intel_encoder;\n\tstruct intel_connector *intel_connector;\n\tu32 tv_dac_on, tv_dac_off, save_tv_dac;\n\n\tif ((intel_de_read(dev_priv, TV_CTL) & TV_FUSE_STATE_MASK) == TV_FUSE_STATE_DISABLED)\n\t\treturn;\n\n\tif (!intel_bios_is_tv_present(dev_priv)) {\n\t\tdrm_dbg_kms(&dev_priv->drm, \"Integrated TV is not present.\\n\");\n\t\treturn;\n\t}\n\n\t \n\tsave_tv_dac = intel_de_read(dev_priv, TV_DAC);\n\n\tintel_de_write(dev_priv, TV_DAC, save_tv_dac | TVDAC_STATE_CHG_EN);\n\ttv_dac_on = intel_de_read(dev_priv, TV_DAC);\n\n\tintel_de_write(dev_priv, TV_DAC, save_tv_dac & ~TVDAC_STATE_CHG_EN);\n\ttv_dac_off = intel_de_read(dev_priv, TV_DAC);\n\n\tintel_de_write(dev_priv, TV_DAC, save_tv_dac);\n\n\t \n\tif ((tv_dac_on & TVDAC_STATE_CHG_EN) == 0 ||\n\t    (tv_dac_off & TVDAC_STATE_CHG_EN) != 0)\n\t\treturn;\n\n\tintel_tv = kzalloc(sizeof(*intel_tv), GFP_KERNEL);\n\tif (!intel_tv) {\n\t\treturn;\n\t}\n\n\tintel_connector = intel_connector_alloc();\n\tif (!intel_connector) {\n\t\tkfree(intel_tv);\n\t\treturn;\n\t}\n\n\tintel_encoder = &intel_tv->base;\n\tconnector = &intel_connector->base;\n\n\t \n\tintel_connector->polled = DRM_CONNECTOR_POLL_CONNECT;\n\n\tdrm_connector_init(&dev_priv->drm, connector, &intel_tv_connector_funcs,\n\t\t\t   DRM_MODE_CONNECTOR_SVIDEO);\n\n\tdrm_encoder_init(&dev_priv->drm, &intel_encoder->base, &intel_tv_enc_funcs,\n\t\t\t DRM_MODE_ENCODER_TVDAC, \"TV\");\n\n\tintel_encoder->compute_config = intel_tv_compute_config;\n\tintel_encoder->get_config = intel_tv_get_config;\n\tintel_encoder->pre_enable = intel_tv_pre_enable;\n\tintel_encoder->enable = intel_enable_tv;\n\tintel_encoder->disable = intel_disable_tv;\n\tintel_encoder->get_hw_state = intel_tv_get_hw_state;\n\tintel_connector->get_hw_state = intel_connector_get_hw_state;\n\n\tintel_connector_attach_encoder(intel_connector, intel_encoder);\n\n\tintel_encoder->type = INTEL_OUTPUT_TVOUT;\n\tintel_encoder->power_domain = POWER_DOMAIN_PORT_OTHER;\n\tintel_encoder->port = PORT_NONE;\n\tintel_encoder->pipe_mask = ~0;\n\tintel_encoder->cloneable = 0;\n\tintel_tv->type = DRM_MODE_CONNECTOR_Unknown;\n\n\tdrm_connector_helper_add(connector, &intel_tv_connector_helper_funcs);\n\n\tintel_tv_add_properties(connector);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}