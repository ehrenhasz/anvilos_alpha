{
  "module_name": "intel_display_irq.c",
  "hash_id": "53bb074b06748fe39f6f1538e6b74bd0dd46dc70803164e0cbadb4872fd3ea72",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/i915/display/intel_display_irq.c",
  "human_readable_source": "\n \n\n#include \"gt/intel_rps.h\"\n#include \"i915_drv.h\"\n#include \"i915_irq.h\"\n#include \"i915_reg.h\"\n#include \"icl_dsi_regs.h\"\n#include \"intel_crtc.h\"\n#include \"intel_de.h\"\n#include \"intel_display_irq.h\"\n#include \"intel_display_trace.h\"\n#include \"intel_display_types.h\"\n#include \"intel_dp_aux.h\"\n#include \"intel_fdi_regs.h\"\n#include \"intel_fifo_underrun.h\"\n#include \"intel_gmbus.h\"\n#include \"intel_hotplug_irq.h\"\n#include \"intel_pmdemand.h\"\n#include \"intel_psr.h\"\n#include \"intel_psr_regs.h\"\n\nstatic void\nintel_handle_vblank(struct drm_i915_private *dev_priv, enum pipe pipe)\n{\n\tstruct intel_crtc *crtc = intel_crtc_for_pipe(dev_priv, pipe);\n\n\tdrm_crtc_handle_vblank(&crtc->base);\n}\n\n \nvoid ilk_update_display_irq(struct drm_i915_private *dev_priv,\n\t\t\t    u32 interrupt_mask, u32 enabled_irq_mask)\n{\n\tu32 new_val;\n\n\tlockdep_assert_held(&dev_priv->irq_lock);\n\tdrm_WARN_ON(&dev_priv->drm, enabled_irq_mask & ~interrupt_mask);\n\n\tnew_val = dev_priv->irq_mask;\n\tnew_val &= ~interrupt_mask;\n\tnew_val |= (~enabled_irq_mask & interrupt_mask);\n\n\tif (new_val != dev_priv->irq_mask &&\n\t    !drm_WARN_ON(&dev_priv->drm, !intel_irqs_enabled(dev_priv))) {\n\t\tdev_priv->irq_mask = new_val;\n\t\tintel_uncore_write(&dev_priv->uncore, DEIMR, dev_priv->irq_mask);\n\t\tintel_uncore_posting_read(&dev_priv->uncore, DEIMR);\n\t}\n}\n\nvoid ilk_enable_display_irq(struct drm_i915_private *i915, u32 bits)\n{\n\tilk_update_display_irq(i915, bits, bits);\n}\n\nvoid ilk_disable_display_irq(struct drm_i915_private *i915, u32 bits)\n{\n\tilk_update_display_irq(i915, bits, 0);\n}\n\n \nvoid bdw_update_port_irq(struct drm_i915_private *dev_priv,\n\t\t\t u32 interrupt_mask, u32 enabled_irq_mask)\n{\n\tu32 new_val;\n\tu32 old_val;\n\n\tlockdep_assert_held(&dev_priv->irq_lock);\n\n\tdrm_WARN_ON(&dev_priv->drm, enabled_irq_mask & ~interrupt_mask);\n\n\tif (drm_WARN_ON(&dev_priv->drm, !intel_irqs_enabled(dev_priv)))\n\t\treturn;\n\n\told_val = intel_uncore_read(&dev_priv->uncore, GEN8_DE_PORT_IMR);\n\n\tnew_val = old_val;\n\tnew_val &= ~interrupt_mask;\n\tnew_val |= (~enabled_irq_mask & interrupt_mask);\n\n\tif (new_val != old_val) {\n\t\tintel_uncore_write(&dev_priv->uncore, GEN8_DE_PORT_IMR, new_val);\n\t\tintel_uncore_posting_read(&dev_priv->uncore, GEN8_DE_PORT_IMR);\n\t}\n}\n\n \nstatic void bdw_update_pipe_irq(struct drm_i915_private *dev_priv,\n\t\t\t\tenum pipe pipe, u32 interrupt_mask,\n\t\t\t\tu32 enabled_irq_mask)\n{\n\tu32 new_val;\n\n\tlockdep_assert_held(&dev_priv->irq_lock);\n\n\tdrm_WARN_ON(&dev_priv->drm, enabled_irq_mask & ~interrupt_mask);\n\n\tif (drm_WARN_ON(&dev_priv->drm, !intel_irqs_enabled(dev_priv)))\n\t\treturn;\n\n\tnew_val = dev_priv->de_irq_mask[pipe];\n\tnew_val &= ~interrupt_mask;\n\tnew_val |= (~enabled_irq_mask & interrupt_mask);\n\n\tif (new_val != dev_priv->de_irq_mask[pipe]) {\n\t\tdev_priv->de_irq_mask[pipe] = new_val;\n\t\tintel_uncore_write(&dev_priv->uncore, GEN8_DE_PIPE_IMR(pipe), dev_priv->de_irq_mask[pipe]);\n\t\tintel_uncore_posting_read(&dev_priv->uncore, GEN8_DE_PIPE_IMR(pipe));\n\t}\n}\n\nvoid bdw_enable_pipe_irq(struct drm_i915_private *i915,\n\t\t\t enum pipe pipe, u32 bits)\n{\n\tbdw_update_pipe_irq(i915, pipe, bits, bits);\n}\n\nvoid bdw_disable_pipe_irq(struct drm_i915_private *i915,\n\t\t\t  enum pipe pipe, u32 bits)\n{\n\tbdw_update_pipe_irq(i915, pipe, bits, 0);\n}\n\n \nvoid ibx_display_interrupt_update(struct drm_i915_private *dev_priv,\n\t\t\t\t  u32 interrupt_mask,\n\t\t\t\t  u32 enabled_irq_mask)\n{\n\tu32 sdeimr = intel_uncore_read(&dev_priv->uncore, SDEIMR);\n\n\tsdeimr &= ~interrupt_mask;\n\tsdeimr |= (~enabled_irq_mask & interrupt_mask);\n\n\tdrm_WARN_ON(&dev_priv->drm, enabled_irq_mask & ~interrupt_mask);\n\n\tlockdep_assert_held(&dev_priv->irq_lock);\n\n\tif (drm_WARN_ON(&dev_priv->drm, !intel_irqs_enabled(dev_priv)))\n\t\treturn;\n\n\tintel_uncore_write(&dev_priv->uncore, SDEIMR, sdeimr);\n\tintel_uncore_posting_read(&dev_priv->uncore, SDEIMR);\n}\n\nvoid ibx_enable_display_interrupt(struct drm_i915_private *i915, u32 bits)\n{\n\tibx_display_interrupt_update(i915, bits, bits);\n}\n\nvoid ibx_disable_display_interrupt(struct drm_i915_private *i915, u32 bits)\n{\n\tibx_display_interrupt_update(i915, bits, 0);\n}\n\nu32 i915_pipestat_enable_mask(struct drm_i915_private *dev_priv,\n\t\t\t      enum pipe pipe)\n{\n\tu32 status_mask = dev_priv->pipestat_irq_mask[pipe];\n\tu32 enable_mask = status_mask << 16;\n\n\tlockdep_assert_held(&dev_priv->irq_lock);\n\n\tif (DISPLAY_VER(dev_priv) < 5)\n\t\tgoto out;\n\n\t \n\tif (drm_WARN_ON_ONCE(&dev_priv->drm,\n\t\t\t     status_mask & PIPE_A_PSR_STATUS_VLV))\n\t\treturn 0;\n\t \n\tif (drm_WARN_ON_ONCE(&dev_priv->drm,\n\t\t\t     status_mask & PIPE_B_PSR_STATUS_VLV))\n\t\treturn 0;\n\n\tenable_mask &= ~(PIPE_FIFO_UNDERRUN_STATUS |\n\t\t\t SPRITE0_FLIP_DONE_INT_EN_VLV |\n\t\t\t SPRITE1_FLIP_DONE_INT_EN_VLV);\n\tif (status_mask & SPRITE0_FLIP_DONE_INT_STATUS_VLV)\n\t\tenable_mask |= SPRITE0_FLIP_DONE_INT_EN_VLV;\n\tif (status_mask & SPRITE1_FLIP_DONE_INT_STATUS_VLV)\n\t\tenable_mask |= SPRITE1_FLIP_DONE_INT_EN_VLV;\n\nout:\n\tdrm_WARN_ONCE(&dev_priv->drm,\n\t\t      enable_mask & ~PIPESTAT_INT_ENABLE_MASK ||\n\t\t      status_mask & ~PIPESTAT_INT_STATUS_MASK,\n\t\t      \"pipe %c: enable_mask=0x%x, status_mask=0x%x\\n\",\n\t\t      pipe_name(pipe), enable_mask, status_mask);\n\n\treturn enable_mask;\n}\n\nvoid i915_enable_pipestat(struct drm_i915_private *dev_priv,\n\t\t\t  enum pipe pipe, u32 status_mask)\n{\n\ti915_reg_t reg = PIPESTAT(pipe);\n\tu32 enable_mask;\n\n\tdrm_WARN_ONCE(&dev_priv->drm, status_mask & ~PIPESTAT_INT_STATUS_MASK,\n\t\t      \"pipe %c: status_mask=0x%x\\n\",\n\t\t      pipe_name(pipe), status_mask);\n\n\tlockdep_assert_held(&dev_priv->irq_lock);\n\tdrm_WARN_ON(&dev_priv->drm, !intel_irqs_enabled(dev_priv));\n\n\tif ((dev_priv->pipestat_irq_mask[pipe] & status_mask) == status_mask)\n\t\treturn;\n\n\tdev_priv->pipestat_irq_mask[pipe] |= status_mask;\n\tenable_mask = i915_pipestat_enable_mask(dev_priv, pipe);\n\n\tintel_uncore_write(&dev_priv->uncore, reg, enable_mask | status_mask);\n\tintel_uncore_posting_read(&dev_priv->uncore, reg);\n}\n\nvoid i915_disable_pipestat(struct drm_i915_private *dev_priv,\n\t\t\t   enum pipe pipe, u32 status_mask)\n{\n\ti915_reg_t reg = PIPESTAT(pipe);\n\tu32 enable_mask;\n\n\tdrm_WARN_ONCE(&dev_priv->drm, status_mask & ~PIPESTAT_INT_STATUS_MASK,\n\t\t      \"pipe %c: status_mask=0x%x\\n\",\n\t\t      pipe_name(pipe), status_mask);\n\n\tlockdep_assert_held(&dev_priv->irq_lock);\n\tdrm_WARN_ON(&dev_priv->drm, !intel_irqs_enabled(dev_priv));\n\n\tif ((dev_priv->pipestat_irq_mask[pipe] & status_mask) == 0)\n\t\treturn;\n\n\tdev_priv->pipestat_irq_mask[pipe] &= ~status_mask;\n\tenable_mask = i915_pipestat_enable_mask(dev_priv, pipe);\n\n\tintel_uncore_write(&dev_priv->uncore, reg, enable_mask | status_mask);\n\tintel_uncore_posting_read(&dev_priv->uncore, reg);\n}\n\nstatic bool i915_has_asle(struct drm_i915_private *dev_priv)\n{\n\tif (!dev_priv->display.opregion.asle)\n\t\treturn false;\n\n\treturn IS_PINEVIEW(dev_priv) || IS_MOBILE(dev_priv);\n}\n\n \nvoid i915_enable_asle_pipestat(struct drm_i915_private *dev_priv)\n{\n\tif (!i915_has_asle(dev_priv))\n\t\treturn;\n\n\tspin_lock_irq(&dev_priv->irq_lock);\n\n\ti915_enable_pipestat(dev_priv, PIPE_B, PIPE_LEGACY_BLC_EVENT_STATUS);\n\tif (DISPLAY_VER(dev_priv) >= 4)\n\t\ti915_enable_pipestat(dev_priv, PIPE_A,\n\t\t\t\t     PIPE_LEGACY_BLC_EVENT_STATUS);\n\n\tspin_unlock_irq(&dev_priv->irq_lock);\n}\n\n#if defined(CONFIG_DEBUG_FS)\nstatic void display_pipe_crc_irq_handler(struct drm_i915_private *dev_priv,\n\t\t\t\t\t enum pipe pipe,\n\t\t\t\t\t u32 crc0, u32 crc1,\n\t\t\t\t\t u32 crc2, u32 crc3,\n\t\t\t\t\t u32 crc4)\n{\n\tstruct intel_crtc *crtc = intel_crtc_for_pipe(dev_priv, pipe);\n\tstruct intel_pipe_crc *pipe_crc = &crtc->pipe_crc;\n\tu32 crcs[5] = { crc0, crc1, crc2, crc3, crc4 };\n\n\ttrace_intel_pipe_crc(crtc, crcs);\n\n\tspin_lock(&pipe_crc->lock);\n\t \n\tif (pipe_crc->skipped <= 0 ||\n\t    (DISPLAY_VER(dev_priv) >= 8 && pipe_crc->skipped == 1)) {\n\t\tpipe_crc->skipped++;\n\t\tspin_unlock(&pipe_crc->lock);\n\t\treturn;\n\t}\n\tspin_unlock(&pipe_crc->lock);\n\n\tdrm_crtc_add_crc_entry(&crtc->base, true,\n\t\t\t       drm_crtc_accurate_vblank_count(&crtc->base),\n\t\t\t       crcs);\n}\n#else\nstatic inline void\ndisplay_pipe_crc_irq_handler(struct drm_i915_private *dev_priv,\n\t\t\t     enum pipe pipe,\n\t\t\t     u32 crc0, u32 crc1,\n\t\t\t     u32 crc2, u32 crc3,\n\t\t\t     u32 crc4) {}\n#endif\n\nstatic void flip_done_handler(struct drm_i915_private *i915,\n\t\t\t      enum pipe pipe)\n{\n\tstruct intel_crtc *crtc = intel_crtc_for_pipe(i915, pipe);\n\tstruct drm_crtc_state *crtc_state = crtc->base.state;\n\tstruct drm_pending_vblank_event *e = crtc_state->event;\n\tstruct drm_device *dev = &i915->drm;\n\tunsigned long irqflags;\n\n\tspin_lock_irqsave(&dev->event_lock, irqflags);\n\n\tcrtc_state->event = NULL;\n\n\tdrm_crtc_send_vblank_event(&crtc->base, e);\n\n\tspin_unlock_irqrestore(&dev->event_lock, irqflags);\n}\n\nstatic void hsw_pipe_crc_irq_handler(struct drm_i915_private *dev_priv,\n\t\t\t\t     enum pipe pipe)\n{\n\tdisplay_pipe_crc_irq_handler(dev_priv, pipe,\n\t\t\t\t     intel_uncore_read(&dev_priv->uncore, PIPE_CRC_RES_1_IVB(pipe)),\n\t\t\t\t     0, 0, 0, 0);\n}\n\nstatic void ivb_pipe_crc_irq_handler(struct drm_i915_private *dev_priv,\n\t\t\t\t     enum pipe pipe)\n{\n\tdisplay_pipe_crc_irq_handler(dev_priv, pipe,\n\t\t\t\t     intel_uncore_read(&dev_priv->uncore, PIPE_CRC_RES_1_IVB(pipe)),\n\t\t\t\t     intel_uncore_read(&dev_priv->uncore, PIPE_CRC_RES_2_IVB(pipe)),\n\t\t\t\t     intel_uncore_read(&dev_priv->uncore, PIPE_CRC_RES_3_IVB(pipe)),\n\t\t\t\t     intel_uncore_read(&dev_priv->uncore, PIPE_CRC_RES_4_IVB(pipe)),\n\t\t\t\t     intel_uncore_read(&dev_priv->uncore, PIPE_CRC_RES_5_IVB(pipe)));\n}\n\nstatic void i9xx_pipe_crc_irq_handler(struct drm_i915_private *dev_priv,\n\t\t\t\t      enum pipe pipe)\n{\n\tu32 res1, res2;\n\n\tif (DISPLAY_VER(dev_priv) >= 3)\n\t\tres1 = intel_uncore_read(&dev_priv->uncore, PIPE_CRC_RES_RES1_I915(pipe));\n\telse\n\t\tres1 = 0;\n\n\tif (DISPLAY_VER(dev_priv) >= 5 || IS_G4X(dev_priv))\n\t\tres2 = intel_uncore_read(&dev_priv->uncore, PIPE_CRC_RES_RES2_G4X(pipe));\n\telse\n\t\tres2 = 0;\n\n\tdisplay_pipe_crc_irq_handler(dev_priv, pipe,\n\t\t\t\t     intel_uncore_read(&dev_priv->uncore, PIPE_CRC_RES_RED(pipe)),\n\t\t\t\t     intel_uncore_read(&dev_priv->uncore, PIPE_CRC_RES_GREEN(pipe)),\n\t\t\t\t     intel_uncore_read(&dev_priv->uncore, PIPE_CRC_RES_BLUE(pipe)),\n\t\t\t\t     res1, res2);\n}\n\nvoid i9xx_pipestat_irq_reset(struct drm_i915_private *dev_priv)\n{\n\tenum pipe pipe;\n\n\tfor_each_pipe(dev_priv, pipe) {\n\t\tintel_uncore_write(&dev_priv->uncore, PIPESTAT(pipe),\n\t\t\t\t   PIPESTAT_INT_STATUS_MASK |\n\t\t\t\t   PIPE_FIFO_UNDERRUN_STATUS);\n\n\t\tdev_priv->pipestat_irq_mask[pipe] = 0;\n\t}\n}\n\nvoid i9xx_pipestat_irq_ack(struct drm_i915_private *dev_priv,\n\t\t\t   u32 iir, u32 pipe_stats[I915_MAX_PIPES])\n{\n\tenum pipe pipe;\n\n\tspin_lock(&dev_priv->irq_lock);\n\n\tif (!dev_priv->display_irqs_enabled) {\n\t\tspin_unlock(&dev_priv->irq_lock);\n\t\treturn;\n\t}\n\n\tfor_each_pipe(dev_priv, pipe) {\n\t\ti915_reg_t reg;\n\t\tu32 status_mask, enable_mask, iir_bit = 0;\n\n\t\t \n\n\t\t \n\t\tstatus_mask = PIPE_FIFO_UNDERRUN_STATUS;\n\n\t\tswitch (pipe) {\n\t\tdefault:\n\t\tcase PIPE_A:\n\t\t\tiir_bit = I915_DISPLAY_PIPE_A_EVENT_INTERRUPT;\n\t\t\tbreak;\n\t\tcase PIPE_B:\n\t\t\tiir_bit = I915_DISPLAY_PIPE_B_EVENT_INTERRUPT;\n\t\t\tbreak;\n\t\tcase PIPE_C:\n\t\t\tiir_bit = I915_DISPLAY_PIPE_C_EVENT_INTERRUPT;\n\t\t\tbreak;\n\t\t}\n\t\tif (iir & iir_bit)\n\t\t\tstatus_mask |= dev_priv->pipestat_irq_mask[pipe];\n\n\t\tif (!status_mask)\n\t\t\tcontinue;\n\n\t\treg = PIPESTAT(pipe);\n\t\tpipe_stats[pipe] = intel_uncore_read(&dev_priv->uncore, reg) & status_mask;\n\t\tenable_mask = i915_pipestat_enable_mask(dev_priv, pipe);\n\n\t\t \n\t\tif (pipe_stats[pipe]) {\n\t\t\tintel_uncore_write(&dev_priv->uncore, reg, pipe_stats[pipe]);\n\t\t\tintel_uncore_write(&dev_priv->uncore, reg, enable_mask);\n\t\t}\n\t}\n\tspin_unlock(&dev_priv->irq_lock);\n}\n\nvoid i8xx_pipestat_irq_handler(struct drm_i915_private *dev_priv,\n\t\t\t       u16 iir, u32 pipe_stats[I915_MAX_PIPES])\n{\n\tenum pipe pipe;\n\n\tfor_each_pipe(dev_priv, pipe) {\n\t\tif (pipe_stats[pipe] & PIPE_VBLANK_INTERRUPT_STATUS)\n\t\t\tintel_handle_vblank(dev_priv, pipe);\n\n\t\tif (pipe_stats[pipe] & PIPE_CRC_DONE_INTERRUPT_STATUS)\n\t\t\ti9xx_pipe_crc_irq_handler(dev_priv, pipe);\n\n\t\tif (pipe_stats[pipe] & PIPE_FIFO_UNDERRUN_STATUS)\n\t\t\tintel_cpu_fifo_underrun_irq_handler(dev_priv, pipe);\n\t}\n}\n\nvoid i915_pipestat_irq_handler(struct drm_i915_private *dev_priv,\n\t\t\t       u32 iir, u32 pipe_stats[I915_MAX_PIPES])\n{\n\tbool blc_event = false;\n\tenum pipe pipe;\n\n\tfor_each_pipe(dev_priv, pipe) {\n\t\tif (pipe_stats[pipe] & PIPE_VBLANK_INTERRUPT_STATUS)\n\t\t\tintel_handle_vblank(dev_priv, pipe);\n\n\t\tif (pipe_stats[pipe] & PIPE_LEGACY_BLC_EVENT_STATUS)\n\t\t\tblc_event = true;\n\n\t\tif (pipe_stats[pipe] & PIPE_CRC_DONE_INTERRUPT_STATUS)\n\t\t\ti9xx_pipe_crc_irq_handler(dev_priv, pipe);\n\n\t\tif (pipe_stats[pipe] & PIPE_FIFO_UNDERRUN_STATUS)\n\t\t\tintel_cpu_fifo_underrun_irq_handler(dev_priv, pipe);\n\t}\n\n\tif (blc_event || (iir & I915_ASLE_INTERRUPT))\n\t\tintel_opregion_asle_intr(dev_priv);\n}\n\nvoid i965_pipestat_irq_handler(struct drm_i915_private *dev_priv,\n\t\t\t       u32 iir, u32 pipe_stats[I915_MAX_PIPES])\n{\n\tbool blc_event = false;\n\tenum pipe pipe;\n\n\tfor_each_pipe(dev_priv, pipe) {\n\t\tif (pipe_stats[pipe] & PIPE_START_VBLANK_INTERRUPT_STATUS)\n\t\t\tintel_handle_vblank(dev_priv, pipe);\n\n\t\tif (pipe_stats[pipe] & PIPE_LEGACY_BLC_EVENT_STATUS)\n\t\t\tblc_event = true;\n\n\t\tif (pipe_stats[pipe] & PIPE_CRC_DONE_INTERRUPT_STATUS)\n\t\t\ti9xx_pipe_crc_irq_handler(dev_priv, pipe);\n\n\t\tif (pipe_stats[pipe] & PIPE_FIFO_UNDERRUN_STATUS)\n\t\t\tintel_cpu_fifo_underrun_irq_handler(dev_priv, pipe);\n\t}\n\n\tif (blc_event || (iir & I915_ASLE_INTERRUPT))\n\t\tintel_opregion_asle_intr(dev_priv);\n\n\tif (pipe_stats[0] & PIPE_GMBUS_INTERRUPT_STATUS)\n\t\tintel_gmbus_irq_handler(dev_priv);\n}\n\nvoid valleyview_pipestat_irq_handler(struct drm_i915_private *dev_priv,\n\t\t\t\t     u32 pipe_stats[I915_MAX_PIPES])\n{\n\tenum pipe pipe;\n\n\tfor_each_pipe(dev_priv, pipe) {\n\t\tif (pipe_stats[pipe] & PIPE_START_VBLANK_INTERRUPT_STATUS)\n\t\t\tintel_handle_vblank(dev_priv, pipe);\n\n\t\tif (pipe_stats[pipe] & PLANE_FLIP_DONE_INT_STATUS_VLV)\n\t\t\tflip_done_handler(dev_priv, pipe);\n\n\t\tif (pipe_stats[pipe] & PIPE_CRC_DONE_INTERRUPT_STATUS)\n\t\t\ti9xx_pipe_crc_irq_handler(dev_priv, pipe);\n\n\t\tif (pipe_stats[pipe] & PIPE_FIFO_UNDERRUN_STATUS)\n\t\t\tintel_cpu_fifo_underrun_irq_handler(dev_priv, pipe);\n\t}\n\n\tif (pipe_stats[0] & PIPE_GMBUS_INTERRUPT_STATUS)\n\t\tintel_gmbus_irq_handler(dev_priv);\n}\n\nstatic void ibx_irq_handler(struct drm_i915_private *dev_priv, u32 pch_iir)\n{\n\tenum pipe pipe;\n\tu32 hotplug_trigger = pch_iir & SDE_HOTPLUG_MASK;\n\n\tibx_hpd_irq_handler(dev_priv, hotplug_trigger);\n\n\tif (pch_iir & SDE_AUDIO_POWER_MASK) {\n\t\tint port = ffs((pch_iir & SDE_AUDIO_POWER_MASK) >>\n\t\t\t       SDE_AUDIO_POWER_SHIFT);\n\t\tdrm_dbg(&dev_priv->drm, \"PCH audio power change on port %d\\n\",\n\t\t\tport_name(port));\n\t}\n\n\tif (pch_iir & SDE_AUX_MASK)\n\t\tintel_dp_aux_irq_handler(dev_priv);\n\n\tif (pch_iir & SDE_GMBUS)\n\t\tintel_gmbus_irq_handler(dev_priv);\n\n\tif (pch_iir & SDE_AUDIO_HDCP_MASK)\n\t\tdrm_dbg(&dev_priv->drm, \"PCH HDCP audio interrupt\\n\");\n\n\tif (pch_iir & SDE_AUDIO_TRANS_MASK)\n\t\tdrm_dbg(&dev_priv->drm, \"PCH transcoder audio interrupt\\n\");\n\n\tif (pch_iir & SDE_POISON)\n\t\tdrm_err(&dev_priv->drm, \"PCH poison interrupt\\n\");\n\n\tif (pch_iir & SDE_FDI_MASK) {\n\t\tfor_each_pipe(dev_priv, pipe)\n\t\t\tdrm_dbg(&dev_priv->drm, \"  pipe %c FDI IIR: 0x%08x\\n\",\n\t\t\t\tpipe_name(pipe),\n\t\t\t\tintel_uncore_read(&dev_priv->uncore, FDI_RX_IIR(pipe)));\n\t}\n\n\tif (pch_iir & (SDE_TRANSB_CRC_DONE | SDE_TRANSA_CRC_DONE))\n\t\tdrm_dbg(&dev_priv->drm, \"PCH transcoder CRC done interrupt\\n\");\n\n\tif (pch_iir & (SDE_TRANSB_CRC_ERR | SDE_TRANSA_CRC_ERR))\n\t\tdrm_dbg(&dev_priv->drm,\n\t\t\t\"PCH transcoder CRC error interrupt\\n\");\n\n\tif (pch_iir & SDE_TRANSA_FIFO_UNDER)\n\t\tintel_pch_fifo_underrun_irq_handler(dev_priv, PIPE_A);\n\n\tif (pch_iir & SDE_TRANSB_FIFO_UNDER)\n\t\tintel_pch_fifo_underrun_irq_handler(dev_priv, PIPE_B);\n}\n\nstatic void ivb_err_int_handler(struct drm_i915_private *dev_priv)\n{\n\tu32 err_int = intel_uncore_read(&dev_priv->uncore, GEN7_ERR_INT);\n\tenum pipe pipe;\n\n\tif (err_int & ERR_INT_POISON)\n\t\tdrm_err(&dev_priv->drm, \"Poison interrupt\\n\");\n\n\tfor_each_pipe(dev_priv, pipe) {\n\t\tif (err_int & ERR_INT_FIFO_UNDERRUN(pipe))\n\t\t\tintel_cpu_fifo_underrun_irq_handler(dev_priv, pipe);\n\n\t\tif (err_int & ERR_INT_PIPE_CRC_DONE(pipe)) {\n\t\t\tif (IS_IVYBRIDGE(dev_priv))\n\t\t\t\tivb_pipe_crc_irq_handler(dev_priv, pipe);\n\t\t\telse\n\t\t\t\thsw_pipe_crc_irq_handler(dev_priv, pipe);\n\t\t}\n\t}\n\n\tintel_uncore_write(&dev_priv->uncore, GEN7_ERR_INT, err_int);\n}\n\nstatic void cpt_serr_int_handler(struct drm_i915_private *dev_priv)\n{\n\tu32 serr_int = intel_uncore_read(&dev_priv->uncore, SERR_INT);\n\tenum pipe pipe;\n\n\tif (serr_int & SERR_INT_POISON)\n\t\tdrm_err(&dev_priv->drm, \"PCH poison interrupt\\n\");\n\n\tfor_each_pipe(dev_priv, pipe)\n\t\tif (serr_int & SERR_INT_TRANS_FIFO_UNDERRUN(pipe))\n\t\t\tintel_pch_fifo_underrun_irq_handler(dev_priv, pipe);\n\n\tintel_uncore_write(&dev_priv->uncore, SERR_INT, serr_int);\n}\n\nstatic void cpt_irq_handler(struct drm_i915_private *dev_priv, u32 pch_iir)\n{\n\tenum pipe pipe;\n\tu32 hotplug_trigger = pch_iir & SDE_HOTPLUG_MASK_CPT;\n\n\tibx_hpd_irq_handler(dev_priv, hotplug_trigger);\n\n\tif (pch_iir & SDE_AUDIO_POWER_MASK_CPT) {\n\t\tint port = ffs((pch_iir & SDE_AUDIO_POWER_MASK_CPT) >>\n\t\t\t       SDE_AUDIO_POWER_SHIFT_CPT);\n\t\tdrm_dbg(&dev_priv->drm, \"PCH audio power change on port %c\\n\",\n\t\t\tport_name(port));\n\t}\n\n\tif (pch_iir & SDE_AUX_MASK_CPT)\n\t\tintel_dp_aux_irq_handler(dev_priv);\n\n\tif (pch_iir & SDE_GMBUS_CPT)\n\t\tintel_gmbus_irq_handler(dev_priv);\n\n\tif (pch_iir & SDE_AUDIO_CP_REQ_CPT)\n\t\tdrm_dbg(&dev_priv->drm, \"Audio CP request interrupt\\n\");\n\n\tif (pch_iir & SDE_AUDIO_CP_CHG_CPT)\n\t\tdrm_dbg(&dev_priv->drm, \"Audio CP change interrupt\\n\");\n\n\tif (pch_iir & SDE_FDI_MASK_CPT) {\n\t\tfor_each_pipe(dev_priv, pipe)\n\t\t\tdrm_dbg(&dev_priv->drm, \"  pipe %c FDI IIR: 0x%08x\\n\",\n\t\t\t\tpipe_name(pipe),\n\t\t\t\tintel_uncore_read(&dev_priv->uncore, FDI_RX_IIR(pipe)));\n\t}\n\n\tif (pch_iir & SDE_ERROR_CPT)\n\t\tcpt_serr_int_handler(dev_priv);\n}\n\nvoid ilk_display_irq_handler(struct drm_i915_private *dev_priv, u32 de_iir)\n{\n\tenum pipe pipe;\n\tu32 hotplug_trigger = de_iir & DE_DP_A_HOTPLUG;\n\n\tif (hotplug_trigger)\n\t\tilk_hpd_irq_handler(dev_priv, hotplug_trigger);\n\n\tif (de_iir & DE_AUX_CHANNEL_A)\n\t\tintel_dp_aux_irq_handler(dev_priv);\n\n\tif (de_iir & DE_GSE)\n\t\tintel_opregion_asle_intr(dev_priv);\n\n\tif (de_iir & DE_POISON)\n\t\tdrm_err(&dev_priv->drm, \"Poison interrupt\\n\");\n\n\tfor_each_pipe(dev_priv, pipe) {\n\t\tif (de_iir & DE_PIPE_VBLANK(pipe))\n\t\t\tintel_handle_vblank(dev_priv, pipe);\n\n\t\tif (de_iir & DE_PLANE_FLIP_DONE(pipe))\n\t\t\tflip_done_handler(dev_priv, pipe);\n\n\t\tif (de_iir & DE_PIPE_FIFO_UNDERRUN(pipe))\n\t\t\tintel_cpu_fifo_underrun_irq_handler(dev_priv, pipe);\n\n\t\tif (de_iir & DE_PIPE_CRC_DONE(pipe))\n\t\t\ti9xx_pipe_crc_irq_handler(dev_priv, pipe);\n\t}\n\n\t \n\tif (de_iir & DE_PCH_EVENT) {\n\t\tu32 pch_iir = intel_uncore_read(&dev_priv->uncore, SDEIIR);\n\n\t\tif (HAS_PCH_CPT(dev_priv))\n\t\t\tcpt_irq_handler(dev_priv, pch_iir);\n\t\telse\n\t\t\tibx_irq_handler(dev_priv, pch_iir);\n\n\t\t \n\t\tintel_uncore_write(&dev_priv->uncore, SDEIIR, pch_iir);\n\t}\n\n\tif (DISPLAY_VER(dev_priv) == 5 && de_iir & DE_PCU_EVENT)\n\t\tgen5_rps_irq_handler(&to_gt(dev_priv)->rps);\n}\n\nvoid ivb_display_irq_handler(struct drm_i915_private *dev_priv, u32 de_iir)\n{\n\tenum pipe pipe;\n\tu32 hotplug_trigger = de_iir & DE_DP_A_HOTPLUG_IVB;\n\n\tif (hotplug_trigger)\n\t\tilk_hpd_irq_handler(dev_priv, hotplug_trigger);\n\n\tif (de_iir & DE_ERR_INT_IVB)\n\t\tivb_err_int_handler(dev_priv);\n\n\tif (de_iir & DE_EDP_PSR_INT_HSW) {\n\t\tstruct intel_encoder *encoder;\n\n\t\tfor_each_intel_encoder_with_psr(&dev_priv->drm, encoder) {\n\t\t\tstruct intel_dp *intel_dp = enc_to_intel_dp(encoder);\n\t\t\tu32 psr_iir;\n\n\t\t\tpsr_iir = intel_uncore_rmw(&dev_priv->uncore,\n\t\t\t\t\t\t   EDP_PSR_IIR, 0, 0);\n\t\t\tintel_psr_irq_handler(intel_dp, psr_iir);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (de_iir & DE_AUX_CHANNEL_A_IVB)\n\t\tintel_dp_aux_irq_handler(dev_priv);\n\n\tif (de_iir & DE_GSE_IVB)\n\t\tintel_opregion_asle_intr(dev_priv);\n\n\tfor_each_pipe(dev_priv, pipe) {\n\t\tif (de_iir & DE_PIPE_VBLANK_IVB(pipe))\n\t\t\tintel_handle_vblank(dev_priv, pipe);\n\n\t\tif (de_iir & DE_PLANE_FLIP_DONE_IVB(pipe))\n\t\t\tflip_done_handler(dev_priv, pipe);\n\t}\n\n\t \n\tif (!HAS_PCH_NOP(dev_priv) && (de_iir & DE_PCH_EVENT_IVB)) {\n\t\tu32 pch_iir = intel_uncore_read(&dev_priv->uncore, SDEIIR);\n\n\t\tcpt_irq_handler(dev_priv, pch_iir);\n\n\t\t \n\t\tintel_uncore_write(&dev_priv->uncore, SDEIIR, pch_iir);\n\t}\n}\n\nstatic u32 gen8_de_port_aux_mask(struct drm_i915_private *dev_priv)\n{\n\tu32 mask;\n\n\tif (DISPLAY_VER(dev_priv) >= 14)\n\t\treturn TGL_DE_PORT_AUX_DDIA |\n\t\t\tTGL_DE_PORT_AUX_DDIB;\n\telse if (DISPLAY_VER(dev_priv) >= 13)\n\t\treturn TGL_DE_PORT_AUX_DDIA |\n\t\t\tTGL_DE_PORT_AUX_DDIB |\n\t\t\tTGL_DE_PORT_AUX_DDIC |\n\t\t\tXELPD_DE_PORT_AUX_DDID |\n\t\t\tXELPD_DE_PORT_AUX_DDIE |\n\t\t\tTGL_DE_PORT_AUX_USBC1 |\n\t\t\tTGL_DE_PORT_AUX_USBC2 |\n\t\t\tTGL_DE_PORT_AUX_USBC3 |\n\t\t\tTGL_DE_PORT_AUX_USBC4;\n\telse if (DISPLAY_VER(dev_priv) >= 12)\n\t\treturn TGL_DE_PORT_AUX_DDIA |\n\t\t\tTGL_DE_PORT_AUX_DDIB |\n\t\t\tTGL_DE_PORT_AUX_DDIC |\n\t\t\tTGL_DE_PORT_AUX_USBC1 |\n\t\t\tTGL_DE_PORT_AUX_USBC2 |\n\t\t\tTGL_DE_PORT_AUX_USBC3 |\n\t\t\tTGL_DE_PORT_AUX_USBC4 |\n\t\t\tTGL_DE_PORT_AUX_USBC5 |\n\t\t\tTGL_DE_PORT_AUX_USBC6;\n\n\tmask = GEN8_AUX_CHANNEL_A;\n\tif (DISPLAY_VER(dev_priv) >= 9)\n\t\tmask |= GEN9_AUX_CHANNEL_B |\n\t\t\tGEN9_AUX_CHANNEL_C |\n\t\t\tGEN9_AUX_CHANNEL_D;\n\n\tif (DISPLAY_VER(dev_priv) == 11) {\n\t\tmask |= ICL_AUX_CHANNEL_F;\n\t\tmask |= ICL_AUX_CHANNEL_E;\n\t}\n\n\treturn mask;\n}\n\nstatic u32 gen8_de_pipe_fault_mask(struct drm_i915_private *dev_priv)\n{\n\tif (DISPLAY_VER(dev_priv) >= 13 || HAS_D12_PLANE_MINIMIZATION(dev_priv))\n\t\treturn RKL_DE_PIPE_IRQ_FAULT_ERRORS;\n\telse if (DISPLAY_VER(dev_priv) >= 11)\n\t\treturn GEN11_DE_PIPE_IRQ_FAULT_ERRORS;\n\telse if (DISPLAY_VER(dev_priv) >= 9)\n\t\treturn GEN9_DE_PIPE_IRQ_FAULT_ERRORS;\n\telse\n\t\treturn GEN8_DE_PIPE_IRQ_FAULT_ERRORS;\n}\n\nstatic void intel_pmdemand_irq_handler(struct drm_i915_private *dev_priv)\n{\n\twake_up_all(&dev_priv->display.pmdemand.waitqueue);\n}\n\nstatic void\ngen8_de_misc_irq_handler(struct drm_i915_private *dev_priv, u32 iir)\n{\n\tbool found = false;\n\n\tif (DISPLAY_VER(dev_priv) >= 14) {\n\t\tif (iir & (XELPDP_PMDEMAND_RSP |\n\t\t\t   XELPDP_PMDEMAND_RSPTOUT_ERR)) {\n\t\t\tif (iir & XELPDP_PMDEMAND_RSPTOUT_ERR)\n\t\t\t\tdrm_dbg(&dev_priv->drm,\n\t\t\t\t\t\"Error waiting for Punit PM Demand Response\\n\");\n\n\t\t\tintel_pmdemand_irq_handler(dev_priv);\n\t\t\tfound = true;\n\t\t}\n\t} else if (iir & GEN8_DE_MISC_GSE) {\n\t\tintel_opregion_asle_intr(dev_priv);\n\t\tfound = true;\n\t}\n\n\tif (iir & GEN8_DE_EDP_PSR) {\n\t\tstruct intel_encoder *encoder;\n\t\tu32 psr_iir;\n\t\ti915_reg_t iir_reg;\n\n\t\tfor_each_intel_encoder_with_psr(&dev_priv->drm, encoder) {\n\t\t\tstruct intel_dp *intel_dp = enc_to_intel_dp(encoder);\n\n\t\t\tif (DISPLAY_VER(dev_priv) >= 12)\n\t\t\t\tiir_reg = TRANS_PSR_IIR(intel_dp->psr.transcoder);\n\t\t\telse\n\t\t\t\tiir_reg = EDP_PSR_IIR;\n\n\t\t\tpsr_iir = intel_uncore_rmw(&dev_priv->uncore, iir_reg, 0, 0);\n\n\t\t\tif (psr_iir)\n\t\t\t\tfound = true;\n\n\t\t\tintel_psr_irq_handler(intel_dp, psr_iir);\n\n\t\t\t \n\t\t\tif (DISPLAY_VER(dev_priv) < 12)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!found)\n\t\tdrm_err(&dev_priv->drm, \"Unexpected DE Misc interrupt\\n\");\n}\n\nstatic void gen11_dsi_te_interrupt_handler(struct drm_i915_private *dev_priv,\n\t\t\t\t\t   u32 te_trigger)\n{\n\tenum pipe pipe = INVALID_PIPE;\n\tenum transcoder dsi_trans;\n\tenum port port;\n\tu32 val;\n\n\t \n\tval = intel_uncore_read(&dev_priv->uncore, TRANS_DDI_FUNC_CTL2(TRANSCODER_DSI_0));\n\tval &= PORT_SYNC_MODE_ENABLE;\n\n\t \n\tport = ((te_trigger & DSI1_TE && val) || (te_trigger & DSI0_TE)) ?\n\t\t\t\t\t\t  PORT_A : PORT_B;\n\tdsi_trans = (port == PORT_A) ? TRANSCODER_DSI_0 : TRANSCODER_DSI_1;\n\n\t \n\tval = intel_uncore_read(&dev_priv->uncore, DSI_TRANS_FUNC_CONF(dsi_trans));\n\tval = val & OP_MODE_MASK;\n\n\tif (val != CMD_MODE_NO_GATE && val != CMD_MODE_TE_GATE) {\n\t\tdrm_err(&dev_priv->drm, \"DSI trancoder not configured in command mode\\n\");\n\t\treturn;\n\t}\n\n\t \n\tval = intel_uncore_read(&dev_priv->uncore, TRANS_DDI_FUNC_CTL(dsi_trans));\n\tswitch (val & TRANS_DDI_EDP_INPUT_MASK) {\n\tcase TRANS_DDI_EDP_INPUT_A_ON:\n\t\tpipe = PIPE_A;\n\t\tbreak;\n\tcase TRANS_DDI_EDP_INPUT_B_ONOFF:\n\t\tpipe = PIPE_B;\n\t\tbreak;\n\tcase TRANS_DDI_EDP_INPUT_C_ONOFF:\n\t\tpipe = PIPE_C;\n\t\tbreak;\n\tdefault:\n\t\tdrm_err(&dev_priv->drm, \"Invalid PIPE\\n\");\n\t\treturn;\n\t}\n\n\tintel_handle_vblank(dev_priv, pipe);\n\n\t \n\tport = (te_trigger & DSI1_TE) ? PORT_B : PORT_A;\n\tintel_uncore_rmw(&dev_priv->uncore, DSI_INTR_IDENT_REG(port), 0, 0);\n}\n\nstatic u32 gen8_de_pipe_flip_done_mask(struct drm_i915_private *i915)\n{\n\tif (DISPLAY_VER(i915) >= 9)\n\t\treturn GEN9_PIPE_PLANE1_FLIP_DONE;\n\telse\n\t\treturn GEN8_PIPE_PRIMARY_FLIP_DONE;\n}\n\nu32 gen8_de_pipe_underrun_mask(struct drm_i915_private *dev_priv)\n{\n\tu32 mask = GEN8_PIPE_FIFO_UNDERRUN;\n\n\tif (DISPLAY_VER(dev_priv) >= 13)\n\t\tmask |= XELPD_PIPE_SOFT_UNDERRUN |\n\t\t\tXELPD_PIPE_HARD_UNDERRUN;\n\n\treturn mask;\n}\n\nstatic void gen8_read_and_ack_pch_irqs(struct drm_i915_private *i915, u32 *pch_iir, u32 *pica_iir)\n{\n\tu32 pica_ier = 0;\n\n\t*pica_iir = 0;\n\t*pch_iir = intel_de_read(i915, SDEIIR);\n\tif (!*pch_iir)\n\t\treturn;\n\n\t \n\tif (*pch_iir & SDE_PICAINTERRUPT) {\n\t\tdrm_WARN_ON(&i915->drm, INTEL_PCH_TYPE(i915) < PCH_MTP);\n\n\t\tpica_ier = intel_de_rmw(i915, PICAINTERRUPT_IER, ~0, 0);\n\t\t*pica_iir = intel_de_read(i915, PICAINTERRUPT_IIR);\n\t\tintel_de_write(i915, PICAINTERRUPT_IIR, *pica_iir);\n\t}\n\n\tintel_de_write(i915, SDEIIR, *pch_iir);\n\n\tif (pica_ier)\n\t\tintel_de_write(i915, PICAINTERRUPT_IER, pica_ier);\n}\n\nvoid gen8_de_irq_handler(struct drm_i915_private *dev_priv, u32 master_ctl)\n{\n\tu32 iir;\n\tenum pipe pipe;\n\n\tdrm_WARN_ON_ONCE(&dev_priv->drm, !HAS_DISPLAY(dev_priv));\n\n\tif (master_ctl & GEN8_DE_MISC_IRQ) {\n\t\tiir = intel_uncore_read(&dev_priv->uncore, GEN8_DE_MISC_IIR);\n\t\tif (iir) {\n\t\t\tintel_uncore_write(&dev_priv->uncore, GEN8_DE_MISC_IIR, iir);\n\t\t\tgen8_de_misc_irq_handler(dev_priv, iir);\n\t\t} else {\n\t\t\tdrm_err_ratelimited(&dev_priv->drm,\n\t\t\t\t\t    \"The master control interrupt lied (DE MISC)!\\n\");\n\t\t}\n\t}\n\n\tif (DISPLAY_VER(dev_priv) >= 11 && (master_ctl & GEN11_DE_HPD_IRQ)) {\n\t\tiir = intel_uncore_read(&dev_priv->uncore, GEN11_DE_HPD_IIR);\n\t\tif (iir) {\n\t\t\tintel_uncore_write(&dev_priv->uncore, GEN11_DE_HPD_IIR, iir);\n\t\t\tgen11_hpd_irq_handler(dev_priv, iir);\n\t\t} else {\n\t\t\tdrm_err_ratelimited(&dev_priv->drm,\n\t\t\t\t\t    \"The master control interrupt lied, (DE HPD)!\\n\");\n\t\t}\n\t}\n\n\tif (master_ctl & GEN8_DE_PORT_IRQ) {\n\t\tiir = intel_uncore_read(&dev_priv->uncore, GEN8_DE_PORT_IIR);\n\t\tif (iir) {\n\t\t\tbool found = false;\n\n\t\t\tintel_uncore_write(&dev_priv->uncore, GEN8_DE_PORT_IIR, iir);\n\n\t\t\tif (iir & gen8_de_port_aux_mask(dev_priv)) {\n\t\t\t\tintel_dp_aux_irq_handler(dev_priv);\n\t\t\t\tfound = true;\n\t\t\t}\n\n\t\t\tif (IS_GEMINILAKE(dev_priv) || IS_BROXTON(dev_priv)) {\n\t\t\t\tu32 hotplug_trigger = iir & BXT_DE_PORT_HOTPLUG_MASK;\n\n\t\t\t\tif (hotplug_trigger) {\n\t\t\t\t\tbxt_hpd_irq_handler(dev_priv, hotplug_trigger);\n\t\t\t\t\tfound = true;\n\t\t\t\t}\n\t\t\t} else if (IS_BROADWELL(dev_priv)) {\n\t\t\t\tu32 hotplug_trigger = iir & BDW_DE_PORT_HOTPLUG_MASK;\n\n\t\t\t\tif (hotplug_trigger) {\n\t\t\t\t\tilk_hpd_irq_handler(dev_priv, hotplug_trigger);\n\t\t\t\t\tfound = true;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif ((IS_GEMINILAKE(dev_priv) || IS_BROXTON(dev_priv)) &&\n\t\t\t    (iir & BXT_DE_PORT_GMBUS)) {\n\t\t\t\tintel_gmbus_irq_handler(dev_priv);\n\t\t\t\tfound = true;\n\t\t\t}\n\n\t\t\tif (DISPLAY_VER(dev_priv) >= 11) {\n\t\t\t\tu32 te_trigger = iir & (DSI0_TE | DSI1_TE);\n\n\t\t\t\tif (te_trigger) {\n\t\t\t\t\tgen11_dsi_te_interrupt_handler(dev_priv, te_trigger);\n\t\t\t\t\tfound = true;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (!found)\n\t\t\t\tdrm_err_ratelimited(&dev_priv->drm,\n\t\t\t\t\t\t    \"Unexpected DE Port interrupt\\n\");\n\t\t} else {\n\t\t\tdrm_err_ratelimited(&dev_priv->drm,\n\t\t\t\t\t    \"The master control interrupt lied (DE PORT)!\\n\");\n\t\t}\n\t}\n\n\tfor_each_pipe(dev_priv, pipe) {\n\t\tu32 fault_errors;\n\n\t\tif (!(master_ctl & GEN8_DE_PIPE_IRQ(pipe)))\n\t\t\tcontinue;\n\n\t\tiir = intel_uncore_read(&dev_priv->uncore, GEN8_DE_PIPE_IIR(pipe));\n\t\tif (!iir) {\n\t\t\tdrm_err_ratelimited(&dev_priv->drm,\n\t\t\t\t\t    \"The master control interrupt lied (DE PIPE)!\\n\");\n\t\t\tcontinue;\n\t\t}\n\n\t\tintel_uncore_write(&dev_priv->uncore, GEN8_DE_PIPE_IIR(pipe), iir);\n\n\t\tif (iir & GEN8_PIPE_VBLANK)\n\t\t\tintel_handle_vblank(dev_priv, pipe);\n\n\t\tif (iir & gen8_de_pipe_flip_done_mask(dev_priv))\n\t\t\tflip_done_handler(dev_priv, pipe);\n\n\t\tif (iir & GEN8_PIPE_CDCLK_CRC_DONE)\n\t\t\thsw_pipe_crc_irq_handler(dev_priv, pipe);\n\n\t\tif (iir & gen8_de_pipe_underrun_mask(dev_priv))\n\t\t\tintel_cpu_fifo_underrun_irq_handler(dev_priv, pipe);\n\n\t\tfault_errors = iir & gen8_de_pipe_fault_mask(dev_priv);\n\t\tif (fault_errors)\n\t\t\tdrm_err_ratelimited(&dev_priv->drm,\n\t\t\t\t\t    \"Fault errors on pipe %c: 0x%08x\\n\",\n\t\t\t\t\t    pipe_name(pipe),\n\t\t\t\t\t    fault_errors);\n\t}\n\n\tif (HAS_PCH_SPLIT(dev_priv) && !HAS_PCH_NOP(dev_priv) &&\n\t    master_ctl & GEN8_DE_PCH_IRQ) {\n\t\tu32 pica_iir;\n\n\t\t \n\t\tgen8_read_and_ack_pch_irqs(dev_priv, &iir, &pica_iir);\n\t\tif (iir) {\n\t\t\tif (pica_iir)\n\t\t\t\txelpdp_pica_irq_handler(dev_priv, pica_iir);\n\n\t\t\tif (INTEL_PCH_TYPE(dev_priv) >= PCH_ICP)\n\t\t\t\ticp_irq_handler(dev_priv, iir);\n\t\t\telse if (INTEL_PCH_TYPE(dev_priv) >= PCH_SPT)\n\t\t\t\tspt_irq_handler(dev_priv, iir);\n\t\t\telse\n\t\t\t\tcpt_irq_handler(dev_priv, iir);\n\t\t} else {\n\t\t\t \n\t\t\tdrm_dbg(&dev_priv->drm,\n\t\t\t\t\"The master control interrupt lied (SDE)!\\n\");\n\t\t}\n\t}\n}\n\nu32 gen11_gu_misc_irq_ack(struct drm_i915_private *i915, const u32 master_ctl)\n{\n\tvoid __iomem * const regs = intel_uncore_regs(&i915->uncore);\n\tu32 iir;\n\n\tif (!(master_ctl & GEN11_GU_MISC_IRQ))\n\t\treturn 0;\n\n\tiir = raw_reg_read(regs, GEN11_GU_MISC_IIR);\n\tif (likely(iir))\n\t\traw_reg_write(regs, GEN11_GU_MISC_IIR, iir);\n\n\treturn iir;\n}\n\nvoid gen11_gu_misc_irq_handler(struct drm_i915_private *i915, const u32 iir)\n{\n\tif (iir & GEN11_GU_MISC_GSE)\n\t\tintel_opregion_asle_intr(i915);\n}\n\nvoid gen11_display_irq_handler(struct drm_i915_private *i915)\n{\n\tvoid __iomem * const regs = intel_uncore_regs(&i915->uncore);\n\tconst u32 disp_ctl = raw_reg_read(regs, GEN11_DISPLAY_INT_CTL);\n\n\tdisable_rpm_wakeref_asserts(&i915->runtime_pm);\n\t \n\traw_reg_write(regs, GEN11_DISPLAY_INT_CTL, 0x0);\n\tgen8_de_irq_handler(i915, disp_ctl);\n\traw_reg_write(regs, GEN11_DISPLAY_INT_CTL,\n\t\t      GEN11_DISPLAY_IRQ_ENABLE);\n\n\tenable_rpm_wakeref_asserts(&i915->runtime_pm);\n}\n\n \nint i8xx_enable_vblank(struct drm_crtc *crtc)\n{\n\tstruct drm_i915_private *dev_priv = to_i915(crtc->dev);\n\tenum pipe pipe = to_intel_crtc(crtc)->pipe;\n\tunsigned long irqflags;\n\n\tspin_lock_irqsave(&dev_priv->irq_lock, irqflags);\n\ti915_enable_pipestat(dev_priv, pipe, PIPE_VBLANK_INTERRUPT_STATUS);\n\tspin_unlock_irqrestore(&dev_priv->irq_lock, irqflags);\n\n\treturn 0;\n}\n\nint i915gm_enable_vblank(struct drm_crtc *crtc)\n{\n\tstruct drm_i915_private *dev_priv = to_i915(crtc->dev);\n\n\t \n\tif (dev_priv->vblank_enabled++ == 0)\n\t\tintel_uncore_write(&dev_priv->uncore, SCPD0, _MASKED_BIT_ENABLE(CSTATE_RENDER_CLOCK_GATE_DISABLE));\n\n\treturn i8xx_enable_vblank(crtc);\n}\n\nint i965_enable_vblank(struct drm_crtc *crtc)\n{\n\tstruct drm_i915_private *dev_priv = to_i915(crtc->dev);\n\tenum pipe pipe = to_intel_crtc(crtc)->pipe;\n\tunsigned long irqflags;\n\n\tspin_lock_irqsave(&dev_priv->irq_lock, irqflags);\n\ti915_enable_pipestat(dev_priv, pipe,\n\t\t\t     PIPE_START_VBLANK_INTERRUPT_STATUS);\n\tspin_unlock_irqrestore(&dev_priv->irq_lock, irqflags);\n\n\treturn 0;\n}\n\nint ilk_enable_vblank(struct drm_crtc *crtc)\n{\n\tstruct drm_i915_private *dev_priv = to_i915(crtc->dev);\n\tenum pipe pipe = to_intel_crtc(crtc)->pipe;\n\tunsigned long irqflags;\n\tu32 bit = DISPLAY_VER(dev_priv) >= 7 ?\n\t\tDE_PIPE_VBLANK_IVB(pipe) : DE_PIPE_VBLANK(pipe);\n\n\tspin_lock_irqsave(&dev_priv->irq_lock, irqflags);\n\tilk_enable_display_irq(dev_priv, bit);\n\tspin_unlock_irqrestore(&dev_priv->irq_lock, irqflags);\n\n\t \n\tif (HAS_PSR(dev_priv))\n\t\tdrm_crtc_vblank_restore(crtc);\n\n\treturn 0;\n}\n\nstatic bool gen11_dsi_configure_te(struct intel_crtc *intel_crtc,\n\t\t\t\t   bool enable)\n{\n\tstruct drm_i915_private *dev_priv = to_i915(intel_crtc->base.dev);\n\tenum port port;\n\n\tif (!(intel_crtc->mode_flags &\n\t    (I915_MODE_FLAG_DSI_USE_TE1 | I915_MODE_FLAG_DSI_USE_TE0)))\n\t\treturn false;\n\n\t \n\tif (intel_crtc->mode_flags & I915_MODE_FLAG_DSI_USE_TE1)\n\t\tport = PORT_B;\n\telse\n\t\tport = PORT_A;\n\n\tintel_uncore_rmw(&dev_priv->uncore, DSI_INTR_MASK_REG(port), DSI_TE_EVENT,\n\t\t\t enable ? 0 : DSI_TE_EVENT);\n\n\tintel_uncore_rmw(&dev_priv->uncore, DSI_INTR_IDENT_REG(port), 0, 0);\n\n\treturn true;\n}\n\nint bdw_enable_vblank(struct drm_crtc *_crtc)\n{\n\tstruct intel_crtc *crtc = to_intel_crtc(_crtc);\n\tstruct drm_i915_private *dev_priv = to_i915(crtc->base.dev);\n\tenum pipe pipe = crtc->pipe;\n\tunsigned long irqflags;\n\n\tif (gen11_dsi_configure_te(crtc, true))\n\t\treturn 0;\n\n\tspin_lock_irqsave(&dev_priv->irq_lock, irqflags);\n\tbdw_enable_pipe_irq(dev_priv, pipe, GEN8_PIPE_VBLANK);\n\tspin_unlock_irqrestore(&dev_priv->irq_lock, irqflags);\n\n\t \n\tif (HAS_PSR(dev_priv))\n\t\tdrm_crtc_vblank_restore(&crtc->base);\n\n\treturn 0;\n}\n\n \nvoid i8xx_disable_vblank(struct drm_crtc *crtc)\n{\n\tstruct drm_i915_private *dev_priv = to_i915(crtc->dev);\n\tenum pipe pipe = to_intel_crtc(crtc)->pipe;\n\tunsigned long irqflags;\n\n\tspin_lock_irqsave(&dev_priv->irq_lock, irqflags);\n\ti915_disable_pipestat(dev_priv, pipe, PIPE_VBLANK_INTERRUPT_STATUS);\n\tspin_unlock_irqrestore(&dev_priv->irq_lock, irqflags);\n}\n\nvoid i915gm_disable_vblank(struct drm_crtc *crtc)\n{\n\tstruct drm_i915_private *dev_priv = to_i915(crtc->dev);\n\n\ti8xx_disable_vblank(crtc);\n\n\tif (--dev_priv->vblank_enabled == 0)\n\t\tintel_uncore_write(&dev_priv->uncore, SCPD0, _MASKED_BIT_DISABLE(CSTATE_RENDER_CLOCK_GATE_DISABLE));\n}\n\nvoid i965_disable_vblank(struct drm_crtc *crtc)\n{\n\tstruct drm_i915_private *dev_priv = to_i915(crtc->dev);\n\tenum pipe pipe = to_intel_crtc(crtc)->pipe;\n\tunsigned long irqflags;\n\n\tspin_lock_irqsave(&dev_priv->irq_lock, irqflags);\n\ti915_disable_pipestat(dev_priv, pipe,\n\t\t\t      PIPE_START_VBLANK_INTERRUPT_STATUS);\n\tspin_unlock_irqrestore(&dev_priv->irq_lock, irqflags);\n}\n\nvoid ilk_disable_vblank(struct drm_crtc *crtc)\n{\n\tstruct drm_i915_private *dev_priv = to_i915(crtc->dev);\n\tenum pipe pipe = to_intel_crtc(crtc)->pipe;\n\tunsigned long irqflags;\n\tu32 bit = DISPLAY_VER(dev_priv) >= 7 ?\n\t\tDE_PIPE_VBLANK_IVB(pipe) : DE_PIPE_VBLANK(pipe);\n\n\tspin_lock_irqsave(&dev_priv->irq_lock, irqflags);\n\tilk_disable_display_irq(dev_priv, bit);\n\tspin_unlock_irqrestore(&dev_priv->irq_lock, irqflags);\n}\n\nvoid bdw_disable_vblank(struct drm_crtc *_crtc)\n{\n\tstruct intel_crtc *crtc = to_intel_crtc(_crtc);\n\tstruct drm_i915_private *dev_priv = to_i915(crtc->base.dev);\n\tenum pipe pipe = crtc->pipe;\n\tunsigned long irqflags;\n\n\tif (gen11_dsi_configure_te(crtc, false))\n\t\treturn;\n\n\tspin_lock_irqsave(&dev_priv->irq_lock, irqflags);\n\tbdw_disable_pipe_irq(dev_priv, pipe, GEN8_PIPE_VBLANK);\n\tspin_unlock_irqrestore(&dev_priv->irq_lock, irqflags);\n}\n\nvoid vlv_display_irq_reset(struct drm_i915_private *dev_priv)\n{\n\tstruct intel_uncore *uncore = &dev_priv->uncore;\n\n\tif (IS_CHERRYVIEW(dev_priv))\n\t\tintel_uncore_write(uncore, DPINVGTT, DPINVGTT_STATUS_MASK_CHV);\n\telse\n\t\tintel_uncore_write(uncore, DPINVGTT, DPINVGTT_STATUS_MASK_VLV);\n\n\ti915_hotplug_interrupt_update_locked(dev_priv, 0xffffffff, 0);\n\tintel_uncore_rmw(uncore, PORT_HOTPLUG_STAT, 0, 0);\n\n\ti9xx_pipestat_irq_reset(dev_priv);\n\n\tGEN3_IRQ_RESET(uncore, VLV_);\n\tdev_priv->irq_mask = ~0u;\n}\n\nvoid vlv_display_irq_postinstall(struct drm_i915_private *dev_priv)\n{\n\tstruct intel_uncore *uncore = &dev_priv->uncore;\n\n\tu32 pipestat_mask;\n\tu32 enable_mask;\n\tenum pipe pipe;\n\n\tpipestat_mask = PIPE_CRC_DONE_INTERRUPT_STATUS;\n\n\ti915_enable_pipestat(dev_priv, PIPE_A, PIPE_GMBUS_INTERRUPT_STATUS);\n\tfor_each_pipe(dev_priv, pipe)\n\t\ti915_enable_pipestat(dev_priv, pipe, pipestat_mask);\n\n\tenable_mask = I915_DISPLAY_PORT_INTERRUPT |\n\t\tI915_DISPLAY_PIPE_A_EVENT_INTERRUPT |\n\t\tI915_DISPLAY_PIPE_B_EVENT_INTERRUPT |\n\t\tI915_LPE_PIPE_A_INTERRUPT |\n\t\tI915_LPE_PIPE_B_INTERRUPT;\n\n\tif (IS_CHERRYVIEW(dev_priv))\n\t\tenable_mask |= I915_DISPLAY_PIPE_C_EVENT_INTERRUPT |\n\t\t\tI915_LPE_PIPE_C_INTERRUPT;\n\n\tdrm_WARN_ON(&dev_priv->drm, dev_priv->irq_mask != ~0u);\n\n\tdev_priv->irq_mask = ~enable_mask;\n\n\tGEN3_IRQ_INIT(uncore, VLV_, dev_priv->irq_mask, enable_mask);\n}\n\nvoid gen8_display_irq_reset(struct drm_i915_private *dev_priv)\n{\n\tstruct intel_uncore *uncore = &dev_priv->uncore;\n\tenum pipe pipe;\n\n\tif (!HAS_DISPLAY(dev_priv))\n\t\treturn;\n\n\tintel_uncore_write(uncore, EDP_PSR_IMR, 0xffffffff);\n\tintel_uncore_write(uncore, EDP_PSR_IIR, 0xffffffff);\n\n\tfor_each_pipe(dev_priv, pipe)\n\t\tif (intel_display_power_is_enabled(dev_priv,\n\t\t\t\t\t\t   POWER_DOMAIN_PIPE(pipe)))\n\t\t\tGEN8_IRQ_RESET_NDX(uncore, DE_PIPE, pipe);\n\n\tGEN3_IRQ_RESET(uncore, GEN8_DE_PORT_);\n\tGEN3_IRQ_RESET(uncore, GEN8_DE_MISC_);\n}\n\nvoid gen11_display_irq_reset(struct drm_i915_private *dev_priv)\n{\n\tstruct intel_uncore *uncore = &dev_priv->uncore;\n\tenum pipe pipe;\n\tu32 trans_mask = BIT(TRANSCODER_A) | BIT(TRANSCODER_B) |\n\t\tBIT(TRANSCODER_C) | BIT(TRANSCODER_D);\n\n\tif (!HAS_DISPLAY(dev_priv))\n\t\treturn;\n\n\tintel_uncore_write(uncore, GEN11_DISPLAY_INT_CTL, 0);\n\n\tif (DISPLAY_VER(dev_priv) >= 12) {\n\t\tenum transcoder trans;\n\n\t\tfor_each_cpu_transcoder_masked(dev_priv, trans, trans_mask) {\n\t\t\tenum intel_display_power_domain domain;\n\n\t\t\tdomain = POWER_DOMAIN_TRANSCODER(trans);\n\t\t\tif (!intel_display_power_is_enabled(dev_priv, domain))\n\t\t\t\tcontinue;\n\n\t\t\tintel_uncore_write(uncore, TRANS_PSR_IMR(trans), 0xffffffff);\n\t\t\tintel_uncore_write(uncore, TRANS_PSR_IIR(trans), 0xffffffff);\n\t\t}\n\t} else {\n\t\tintel_uncore_write(uncore, EDP_PSR_IMR, 0xffffffff);\n\t\tintel_uncore_write(uncore, EDP_PSR_IIR, 0xffffffff);\n\t}\n\n\tfor_each_pipe(dev_priv, pipe)\n\t\tif (intel_display_power_is_enabled(dev_priv,\n\t\t\t\t\t\t   POWER_DOMAIN_PIPE(pipe)))\n\t\t\tGEN8_IRQ_RESET_NDX(uncore, DE_PIPE, pipe);\n\n\tGEN3_IRQ_RESET(uncore, GEN8_DE_PORT_);\n\tGEN3_IRQ_RESET(uncore, GEN8_DE_MISC_);\n\n\tif (DISPLAY_VER(dev_priv) >= 14)\n\t\tGEN3_IRQ_RESET(uncore, PICAINTERRUPT_);\n\telse\n\t\tGEN3_IRQ_RESET(uncore, GEN11_DE_HPD_);\n\n\tif (INTEL_PCH_TYPE(dev_priv) >= PCH_ICP)\n\t\tGEN3_IRQ_RESET(uncore, SDE);\n}\n\nvoid gen8_irq_power_well_post_enable(struct drm_i915_private *dev_priv,\n\t\t\t\t     u8 pipe_mask)\n{\n\tstruct intel_uncore *uncore = &dev_priv->uncore;\n\tu32 extra_ier = GEN8_PIPE_VBLANK |\n\t\tgen8_de_pipe_underrun_mask(dev_priv) |\n\t\tgen8_de_pipe_flip_done_mask(dev_priv);\n\tenum pipe pipe;\n\n\tspin_lock_irq(&dev_priv->irq_lock);\n\n\tif (!intel_irqs_enabled(dev_priv)) {\n\t\tspin_unlock_irq(&dev_priv->irq_lock);\n\t\treturn;\n\t}\n\n\tfor_each_pipe_masked(dev_priv, pipe, pipe_mask)\n\t\tGEN8_IRQ_INIT_NDX(uncore, DE_PIPE, pipe,\n\t\t\t\t  dev_priv->de_irq_mask[pipe],\n\t\t\t\t  ~dev_priv->de_irq_mask[pipe] | extra_ier);\n\n\tspin_unlock_irq(&dev_priv->irq_lock);\n}\n\nvoid gen8_irq_power_well_pre_disable(struct drm_i915_private *dev_priv,\n\t\t\t\t     u8 pipe_mask)\n{\n\tstruct intel_uncore *uncore = &dev_priv->uncore;\n\tenum pipe pipe;\n\n\tspin_lock_irq(&dev_priv->irq_lock);\n\n\tif (!intel_irqs_enabled(dev_priv)) {\n\t\tspin_unlock_irq(&dev_priv->irq_lock);\n\t\treturn;\n\t}\n\n\tfor_each_pipe_masked(dev_priv, pipe, pipe_mask)\n\t\tGEN8_IRQ_RESET_NDX(uncore, DE_PIPE, pipe);\n\n\tspin_unlock_irq(&dev_priv->irq_lock);\n\n\t \n\tintel_synchronize_irq(dev_priv);\n}\n\n \nstatic void ibx_irq_postinstall(struct drm_i915_private *dev_priv)\n{\n\tstruct intel_uncore *uncore = &dev_priv->uncore;\n\tu32 mask;\n\n\tif (HAS_PCH_NOP(dev_priv))\n\t\treturn;\n\n\tif (HAS_PCH_IBX(dev_priv))\n\t\tmask = SDE_GMBUS | SDE_AUX_MASK | SDE_POISON;\n\telse if (HAS_PCH_CPT(dev_priv) || HAS_PCH_LPT(dev_priv))\n\t\tmask = SDE_GMBUS_CPT | SDE_AUX_MASK_CPT;\n\telse\n\t\tmask = SDE_GMBUS_CPT;\n\n\tGEN3_IRQ_INIT(uncore, SDE, ~mask, 0xffffffff);\n}\n\nvoid valleyview_enable_display_irqs(struct drm_i915_private *dev_priv)\n{\n\tlockdep_assert_held(&dev_priv->irq_lock);\n\n\tif (dev_priv->display_irqs_enabled)\n\t\treturn;\n\n\tdev_priv->display_irqs_enabled = true;\n\n\tif (intel_irqs_enabled(dev_priv)) {\n\t\tvlv_display_irq_reset(dev_priv);\n\t\tvlv_display_irq_postinstall(dev_priv);\n\t}\n}\n\nvoid valleyview_disable_display_irqs(struct drm_i915_private *dev_priv)\n{\n\tlockdep_assert_held(&dev_priv->irq_lock);\n\n\tif (!dev_priv->display_irqs_enabled)\n\t\treturn;\n\n\tdev_priv->display_irqs_enabled = false;\n\n\tif (intel_irqs_enabled(dev_priv))\n\t\tvlv_display_irq_reset(dev_priv);\n}\n\nvoid ilk_de_irq_postinstall(struct drm_i915_private *i915)\n{\n\tstruct intel_uncore *uncore = &i915->uncore;\n\tu32 display_mask, extra_mask;\n\n\tif (GRAPHICS_VER(i915) >= 7) {\n\t\tdisplay_mask = (DE_MASTER_IRQ_CONTROL | DE_GSE_IVB |\n\t\t\t\tDE_PCH_EVENT_IVB | DE_AUX_CHANNEL_A_IVB);\n\t\textra_mask = (DE_PIPEC_VBLANK_IVB | DE_PIPEB_VBLANK_IVB |\n\t\t\t      DE_PIPEA_VBLANK_IVB | DE_ERR_INT_IVB |\n\t\t\t      DE_PLANE_FLIP_DONE_IVB(PLANE_C) |\n\t\t\t      DE_PLANE_FLIP_DONE_IVB(PLANE_B) |\n\t\t\t      DE_PLANE_FLIP_DONE_IVB(PLANE_A) |\n\t\t\t      DE_DP_A_HOTPLUG_IVB);\n\t} else {\n\t\tdisplay_mask = (DE_MASTER_IRQ_CONTROL | DE_GSE | DE_PCH_EVENT |\n\t\t\t\tDE_AUX_CHANNEL_A | DE_PIPEB_CRC_DONE |\n\t\t\t\tDE_PIPEA_CRC_DONE | DE_POISON);\n\t\textra_mask = (DE_PIPEA_VBLANK | DE_PIPEB_VBLANK |\n\t\t\t      DE_PIPEB_FIFO_UNDERRUN | DE_PIPEA_FIFO_UNDERRUN |\n\t\t\t      DE_PLANE_FLIP_DONE(PLANE_A) |\n\t\t\t      DE_PLANE_FLIP_DONE(PLANE_B) |\n\t\t\t      DE_DP_A_HOTPLUG);\n\t}\n\n\tif (IS_HASWELL(i915)) {\n\t\tgen3_assert_iir_is_zero(uncore, EDP_PSR_IIR);\n\t\tdisplay_mask |= DE_EDP_PSR_INT_HSW;\n\t}\n\n\tif (IS_IRONLAKE_M(i915))\n\t\textra_mask |= DE_PCU_EVENT;\n\n\ti915->irq_mask = ~display_mask;\n\n\tibx_irq_postinstall(i915);\n\n\tGEN3_IRQ_INIT(uncore, DE, i915->irq_mask,\n\t\t      display_mask | extra_mask);\n}\n\nstatic void mtp_irq_postinstall(struct drm_i915_private *i915);\nstatic void icp_irq_postinstall(struct drm_i915_private *i915);\n\nvoid gen8_de_irq_postinstall(struct drm_i915_private *dev_priv)\n{\n\tstruct intel_uncore *uncore = &dev_priv->uncore;\n\n\tu32 de_pipe_masked = gen8_de_pipe_fault_mask(dev_priv) |\n\t\tGEN8_PIPE_CDCLK_CRC_DONE;\n\tu32 de_pipe_enables;\n\tu32 de_port_masked = gen8_de_port_aux_mask(dev_priv);\n\tu32 de_port_enables;\n\tu32 de_misc_masked = GEN8_DE_EDP_PSR;\n\tu32 trans_mask = BIT(TRANSCODER_A) | BIT(TRANSCODER_B) |\n\t\tBIT(TRANSCODER_C) | BIT(TRANSCODER_D);\n\tenum pipe pipe;\n\n\tif (!HAS_DISPLAY(dev_priv))\n\t\treturn;\n\n\tif (DISPLAY_VER(dev_priv) >= 14)\n\t\tmtp_irq_postinstall(dev_priv);\n\telse if (INTEL_PCH_TYPE(dev_priv) >= PCH_ICP)\n\t\ticp_irq_postinstall(dev_priv);\n\telse if (HAS_PCH_SPLIT(dev_priv))\n\t\tibx_irq_postinstall(dev_priv);\n\n\tif (DISPLAY_VER(dev_priv) <= 10)\n\t\tde_misc_masked |= GEN8_DE_MISC_GSE;\n\n\tif (IS_GEMINILAKE(dev_priv) || IS_BROXTON(dev_priv))\n\t\tde_port_masked |= BXT_DE_PORT_GMBUS;\n\n\tif (DISPLAY_VER(dev_priv) >= 14) {\n\t\tde_misc_masked |= XELPDP_PMDEMAND_RSPTOUT_ERR |\n\t\t\t\t  XELPDP_PMDEMAND_RSP;\n\t} else if (DISPLAY_VER(dev_priv) >= 11) {\n\t\tenum port port;\n\n\t\tif (intel_bios_is_dsi_present(dev_priv, &port))\n\t\t\tde_port_masked |= DSI0_TE | DSI1_TE;\n\t}\n\n\tde_pipe_enables = de_pipe_masked |\n\t\tGEN8_PIPE_VBLANK |\n\t\tgen8_de_pipe_underrun_mask(dev_priv) |\n\t\tgen8_de_pipe_flip_done_mask(dev_priv);\n\n\tde_port_enables = de_port_masked;\n\tif (IS_GEMINILAKE(dev_priv) || IS_BROXTON(dev_priv))\n\t\tde_port_enables |= BXT_DE_PORT_HOTPLUG_MASK;\n\telse if (IS_BROADWELL(dev_priv))\n\t\tde_port_enables |= BDW_DE_PORT_HOTPLUG_MASK;\n\n\tif (DISPLAY_VER(dev_priv) >= 12) {\n\t\tenum transcoder trans;\n\n\t\tfor_each_cpu_transcoder_masked(dev_priv, trans, trans_mask) {\n\t\t\tenum intel_display_power_domain domain;\n\n\t\t\tdomain = POWER_DOMAIN_TRANSCODER(trans);\n\t\t\tif (!intel_display_power_is_enabled(dev_priv, domain))\n\t\t\t\tcontinue;\n\n\t\t\tgen3_assert_iir_is_zero(uncore, TRANS_PSR_IIR(trans));\n\t\t}\n\t} else {\n\t\tgen3_assert_iir_is_zero(uncore, EDP_PSR_IIR);\n\t}\n\n\tfor_each_pipe(dev_priv, pipe) {\n\t\tdev_priv->de_irq_mask[pipe] = ~de_pipe_masked;\n\n\t\tif (intel_display_power_is_enabled(dev_priv,\n\t\t\t\t\t\t   POWER_DOMAIN_PIPE(pipe)))\n\t\t\tGEN8_IRQ_INIT_NDX(uncore, DE_PIPE, pipe,\n\t\t\t\t\t  dev_priv->de_irq_mask[pipe],\n\t\t\t\t\t  de_pipe_enables);\n\t}\n\n\tGEN3_IRQ_INIT(uncore, GEN8_DE_PORT_, ~de_port_masked, de_port_enables);\n\tGEN3_IRQ_INIT(uncore, GEN8_DE_MISC_, ~de_misc_masked, de_misc_masked);\n\n\tif (IS_DISPLAY_VER(dev_priv, 11, 13)) {\n\t\tu32 de_hpd_masked = 0;\n\t\tu32 de_hpd_enables = GEN11_DE_TC_HOTPLUG_MASK |\n\t\t\t\t     GEN11_DE_TBT_HOTPLUG_MASK;\n\n\t\tGEN3_IRQ_INIT(uncore, GEN11_DE_HPD_, ~de_hpd_masked,\n\t\t\t      de_hpd_enables);\n\t}\n}\n\nstatic void mtp_irq_postinstall(struct drm_i915_private *i915)\n{\n\tstruct intel_uncore *uncore = &i915->uncore;\n\tu32 sde_mask = SDE_GMBUS_ICP | SDE_PICAINTERRUPT;\n\tu32 de_hpd_mask = XELPDP_AUX_TC_MASK;\n\tu32 de_hpd_enables = de_hpd_mask | XELPDP_DP_ALT_HOTPLUG_MASK |\n\t\t\t     XELPDP_TBT_HOTPLUG_MASK;\n\n\tGEN3_IRQ_INIT(uncore, PICAINTERRUPT_, ~de_hpd_mask,\n\t\t      de_hpd_enables);\n\n\tGEN3_IRQ_INIT(uncore, SDE, ~sde_mask, 0xffffffff);\n}\n\nstatic void icp_irq_postinstall(struct drm_i915_private *dev_priv)\n{\n\tstruct intel_uncore *uncore = &dev_priv->uncore;\n\tu32 mask = SDE_GMBUS_ICP;\n\n\tGEN3_IRQ_INIT(uncore, SDE, ~mask, 0xffffffff);\n}\n\nvoid gen11_de_irq_postinstall(struct drm_i915_private *dev_priv)\n{\n\tif (!HAS_DISPLAY(dev_priv))\n\t\treturn;\n\n\tgen8_de_irq_postinstall(dev_priv);\n\n\tintel_uncore_write(&dev_priv->uncore, GEN11_DISPLAY_INT_CTL,\n\t\t\t   GEN11_DISPLAY_IRQ_ENABLE);\n}\n\nvoid dg1_de_irq_postinstall(struct drm_i915_private *i915)\n{\n\tif (!HAS_DISPLAY(i915))\n\t\treturn;\n\n\tgen8_de_irq_postinstall(i915);\n\tintel_uncore_write(&i915->uncore, GEN11_DISPLAY_INT_CTL,\n\t\t\t   GEN11_DISPLAY_IRQ_ENABLE);\n}\n\nvoid intel_display_irq_init(struct drm_i915_private *i915)\n{\n\ti915->drm.vblank_disable_immediate = true;\n\n\t \n\ti915->display_irqs_enabled = true;\n\tif (IS_VALLEYVIEW(i915) || IS_CHERRYVIEW(i915))\n\t\ti915->display_irqs_enabled = false;\n\n\tintel_hotplug_irq_init(i915);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}