{
  "module_name": "intel_modeset_verify.c",
  "hash_id": "60336f468c31d6cc00b00f14a094bf8ebae2a184eed1529ffab1fb1ac3250adc",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/i915/display/intel_modeset_verify.c",
  "human_readable_source": "\n \n\n#include <drm/drm_atomic_state_helper.h>\n\n#include \"i915_drv.h\"\n#include \"intel_atomic.h\"\n#include \"intel_crtc.h\"\n#include \"intel_crtc_state_dump.h\"\n#include \"intel_cx0_phy.h\"\n#include \"intel_display.h\"\n#include \"intel_display_types.h\"\n#include \"intel_fdi.h\"\n#include \"intel_modeset_verify.h\"\n#include \"intel_snps_phy.h\"\n#include \"skl_watermark.h\"\n\n \nstatic void intel_connector_verify_state(struct intel_crtc_state *crtc_state,\n\t\t\t\t\t struct drm_connector_state *conn_state)\n{\n\tstruct intel_connector *connector = to_intel_connector(conn_state->connector);\n\tstruct drm_i915_private *i915 = to_i915(connector->base.dev);\n\n\tdrm_dbg_kms(&i915->drm, \"[CONNECTOR:%d:%s]\\n\",\n\t\t    connector->base.base.id, connector->base.name);\n\n\tif (connector->get_hw_state(connector)) {\n\t\tstruct intel_encoder *encoder = intel_attached_encoder(connector);\n\n\t\tI915_STATE_WARN(i915, !crtc_state,\n\t\t\t\t\"connector enabled without attached crtc\\n\");\n\n\t\tif (!crtc_state)\n\t\t\treturn;\n\n\t\tI915_STATE_WARN(i915, !crtc_state->hw.active,\n\t\t\t\t\"connector is active, but attached crtc isn't\\n\");\n\n\t\tif (!encoder || encoder->type == INTEL_OUTPUT_DP_MST)\n\t\t\treturn;\n\n\t\tI915_STATE_WARN(i915,\n\t\t\t\tconn_state->best_encoder != &encoder->base,\n\t\t\t\t\"atomic encoder doesn't match attached encoder\\n\");\n\n\t\tI915_STATE_WARN(i915, conn_state->crtc != encoder->base.crtc,\n\t\t\t\t\"attached encoder crtc differs from connector crtc\\n\");\n\t} else {\n\t\tI915_STATE_WARN(i915, crtc_state && crtc_state->hw.active,\n\t\t\t\t\"attached crtc is active, but connector isn't\\n\");\n\t\tI915_STATE_WARN(i915, !crtc_state && conn_state->best_encoder,\n\t\t\t\t\"best encoder set without crtc!\\n\");\n\t}\n}\n\nstatic void\nverify_connector_state(struct intel_atomic_state *state,\n\t\t       struct intel_crtc *crtc)\n{\n\tstruct drm_connector *connector;\n\tstruct drm_connector_state *new_conn_state;\n\tint i;\n\n\tfor_each_new_connector_in_state(&state->base, connector, new_conn_state, i) {\n\t\tstruct drm_encoder *encoder = connector->encoder;\n\t\tstruct intel_crtc_state *crtc_state = NULL;\n\n\t\tif (new_conn_state->crtc != &crtc->base)\n\t\t\tcontinue;\n\n\t\tif (crtc)\n\t\t\tcrtc_state = intel_atomic_get_new_crtc_state(state, crtc);\n\n\t\tintel_connector_verify_state(crtc_state, new_conn_state);\n\n\t\tI915_STATE_WARN(to_i915(connector->dev), new_conn_state->best_encoder != encoder,\n\t\t\t\t\"connector's atomic encoder doesn't match legacy encoder\\n\");\n\t}\n}\n\nstatic void intel_pipe_config_sanity_check(struct drm_i915_private *dev_priv,\n\t\t\t\t\t   const struct intel_crtc_state *pipe_config)\n{\n\tif (pipe_config->has_pch_encoder) {\n\t\tint fdi_dotclock = intel_dotclock_calculate(intel_fdi_link_freq(dev_priv, pipe_config),\n\t\t\t\t\t\t\t    &pipe_config->fdi_m_n);\n\t\tint dotclock = pipe_config->hw.adjusted_mode.crtc_clock;\n\n\t\t \n\t\tdrm_WARN(&dev_priv->drm, abs(fdi_dotclock - dotclock) > 1,\n\t\t\t \"FDI dotclock and encoder dotclock mismatch, fdi: %i, encoder: %i\\n\",\n\t\t\t fdi_dotclock, dotclock);\n\t}\n}\n\nstatic void\nverify_encoder_state(struct drm_i915_private *dev_priv, struct intel_atomic_state *state)\n{\n\tstruct intel_encoder *encoder;\n\tstruct drm_connector *connector;\n\tstruct drm_connector_state *old_conn_state, *new_conn_state;\n\tint i;\n\n\tfor_each_intel_encoder(&dev_priv->drm, encoder) {\n\t\tbool enabled = false, found = false;\n\t\tenum pipe pipe;\n\n\t\tdrm_dbg_kms(&dev_priv->drm, \"[ENCODER:%d:%s]\\n\",\n\t\t\t    encoder->base.base.id,\n\t\t\t    encoder->base.name);\n\n\t\tfor_each_oldnew_connector_in_state(&state->base, connector, old_conn_state,\n\t\t\t\t\t\t   new_conn_state, i) {\n\t\t\tif (old_conn_state->best_encoder == &encoder->base)\n\t\t\t\tfound = true;\n\n\t\t\tif (new_conn_state->best_encoder != &encoder->base)\n\t\t\t\tcontinue;\n\n\t\t\tfound = true;\n\t\t\tenabled = true;\n\n\t\t\tI915_STATE_WARN(dev_priv,\n\t\t\t\t\tnew_conn_state->crtc != encoder->base.crtc,\n\t\t\t\t\t\"connector's crtc doesn't match encoder crtc\\n\");\n\t\t}\n\n\t\tif (!found)\n\t\t\tcontinue;\n\n\t\tI915_STATE_WARN(dev_priv, !!encoder->base.crtc != enabled,\n\t\t\t\t\"encoder's enabled state mismatch (expected %i, found %i)\\n\",\n\t\t\t\t!!encoder->base.crtc, enabled);\n\n\t\tif (!encoder->base.crtc) {\n\t\t\tbool active;\n\n\t\t\tactive = encoder->get_hw_state(encoder, &pipe);\n\t\t\tI915_STATE_WARN(dev_priv, active,\n\t\t\t\t\t\"encoder detached but still enabled on pipe %c.\\n\",\n\t\t\t\t\tpipe_name(pipe));\n\t\t}\n\t}\n}\n\nstatic void\nverify_crtc_state(struct intel_crtc *crtc,\n\t\t  struct intel_crtc_state *old_crtc_state,\n\t\t  struct intel_crtc_state *new_crtc_state)\n{\n\tstruct drm_device *dev = crtc->base.dev;\n\tstruct drm_i915_private *dev_priv = to_i915(dev);\n\tstruct intel_encoder *encoder;\n\tstruct intel_crtc_state *pipe_config = old_crtc_state;\n\tstruct drm_atomic_state *state = old_crtc_state->uapi.state;\n\tstruct intel_crtc *master_crtc;\n\n\t__drm_atomic_helper_crtc_destroy_state(&old_crtc_state->uapi);\n\tintel_crtc_free_hw_state(old_crtc_state);\n\tintel_crtc_state_reset(old_crtc_state, crtc);\n\told_crtc_state->uapi.state = state;\n\n\tdrm_dbg_kms(&dev_priv->drm, \"[CRTC:%d:%s]\\n\", crtc->base.base.id,\n\t\t    crtc->base.name);\n\n\tpipe_config->hw.enable = new_crtc_state->hw.enable;\n\n\tintel_crtc_get_pipe_config(pipe_config);\n\n\t \n\tif (IS_I830(dev_priv) && pipe_config->hw.active)\n\t\tpipe_config->hw.active = new_crtc_state->hw.active;\n\n\tI915_STATE_WARN(dev_priv,\n\t\t\tnew_crtc_state->hw.active != pipe_config->hw.active,\n\t\t\t\"crtc active state doesn't match with hw state (expected %i, found %i)\\n\",\n\t\t\tnew_crtc_state->hw.active, pipe_config->hw.active);\n\n\tI915_STATE_WARN(dev_priv, crtc->active != new_crtc_state->hw.active,\n\t\t\t\"transitional active state does not match atomic hw state (expected %i, found %i)\\n\",\n\t\t\tnew_crtc_state->hw.active, crtc->active);\n\n\tmaster_crtc = intel_master_crtc(new_crtc_state);\n\n\tfor_each_encoder_on_crtc(dev, &master_crtc->base, encoder) {\n\t\tenum pipe pipe;\n\t\tbool active;\n\n\t\tactive = encoder->get_hw_state(encoder, &pipe);\n\t\tI915_STATE_WARN(dev_priv, active != new_crtc_state->hw.active,\n\t\t\t\t\"[ENCODER:%i] active %i with crtc active %i\\n\",\n\t\t\t\tencoder->base.base.id, active,\n\t\t\t\tnew_crtc_state->hw.active);\n\n\t\tI915_STATE_WARN(dev_priv, active && master_crtc->pipe != pipe,\n\t\t\t\t\"Encoder connected to wrong pipe %c\\n\",\n\t\t\t\tpipe_name(pipe));\n\n\t\tif (active)\n\t\t\tintel_encoder_get_config(encoder, pipe_config);\n\t}\n\n\tif (!new_crtc_state->hw.active)\n\t\treturn;\n\n\tintel_pipe_config_sanity_check(dev_priv, pipe_config);\n\n\tif (!intel_pipe_config_compare(new_crtc_state,\n\t\t\t\t       pipe_config, false)) {\n\t\tI915_STATE_WARN(dev_priv, 1, \"pipe state doesn't match!\\n\");\n\t\tintel_crtc_state_dump(pipe_config, NULL, \"hw state\");\n\t\tintel_crtc_state_dump(new_crtc_state, NULL, \"sw state\");\n\t}\n}\n\nvoid intel_modeset_verify_crtc(struct intel_crtc *crtc,\n\t\t\t       struct intel_atomic_state *state,\n\t\t\t       struct intel_crtc_state *old_crtc_state,\n\t\t\t       struct intel_crtc_state *new_crtc_state)\n{\n\tif (!intel_crtc_needs_modeset(new_crtc_state) &&\n\t    !intel_crtc_needs_fastset(new_crtc_state))\n\t\treturn;\n\n\tintel_wm_state_verify(crtc, new_crtc_state);\n\tverify_connector_state(state, crtc);\n\tverify_crtc_state(crtc, old_crtc_state, new_crtc_state);\n\tintel_shared_dpll_state_verify(crtc, old_crtc_state, new_crtc_state);\n\tintel_mpllb_state_verify(state, new_crtc_state);\n\tintel_c10pll_state_verify(state, new_crtc_state);\n}\n\nvoid intel_modeset_verify_disabled(struct drm_i915_private *dev_priv,\n\t\t\t\t   struct intel_atomic_state *state)\n{\n\tverify_encoder_state(dev_priv, state);\n\tverify_connector_state(state, NULL);\n\tintel_shared_dpll_verify_disabled(dev_priv);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}