{
  "module_name": "intel_modeset_setup.c",
  "hash_id": "caab638ca027538eb54fcc93c2b402f2667e609d596a20fd340a1a8f580c8410",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/i915/display/intel_modeset_setup.c",
  "human_readable_source": "\n \n\n#include <drm/drm_atomic_uapi.h>\n#include <drm/drm_atomic_state_helper.h>\n\n#include \"i915_drv.h\"\n#include \"i915_reg.h\"\n#include \"i9xx_wm.h\"\n#include \"intel_atomic.h\"\n#include \"intel_bw.h\"\n#include \"intel_color.h\"\n#include \"intel_crtc.h\"\n#include \"intel_crtc_state_dump.h\"\n#include \"intel_ddi.h\"\n#include \"intel_de.h\"\n#include \"intel_display.h\"\n#include \"intel_display_power.h\"\n#include \"intel_display_types.h\"\n#include \"intel_dmc.h\"\n#include \"intel_fifo_underrun.h\"\n#include \"intel_modeset_setup.h\"\n#include \"intel_pch_display.h\"\n#include \"intel_pmdemand.h\"\n#include \"intel_tc.h\"\n#include \"intel_vblank.h\"\n#include \"intel_wm.h\"\n#include \"skl_watermark.h\"\n\nstatic void intel_crtc_disable_noatomic_begin(struct intel_crtc *crtc,\n\t\t\t\t\t      struct drm_modeset_acquire_ctx *ctx)\n{\n\tstruct drm_i915_private *i915 = to_i915(crtc->base.dev);\n\tstruct intel_crtc_state *crtc_state =\n\t\tto_intel_crtc_state(crtc->base.state);\n\tstruct intel_plane *plane;\n\tstruct drm_atomic_state *state;\n\tstruct intel_crtc *temp_crtc;\n\tenum pipe pipe = crtc->pipe;\n\n\tif (!crtc_state->hw.active)\n\t\treturn;\n\n\tfor_each_intel_plane_on_crtc(&i915->drm, crtc, plane) {\n\t\tconst struct intel_plane_state *plane_state =\n\t\t\tto_intel_plane_state(plane->base.state);\n\n\t\tif (plane_state->uapi.visible)\n\t\t\tintel_plane_disable_noatomic(crtc, plane);\n\t}\n\n\tstate = drm_atomic_state_alloc(&i915->drm);\n\tif (!state) {\n\t\tdrm_dbg_kms(&i915->drm,\n\t\t\t    \"failed to disable [CRTC:%d:%s], out of memory\",\n\t\t\t    crtc->base.base.id, crtc->base.name);\n\t\treturn;\n\t}\n\n\tstate->acquire_ctx = ctx;\n\tto_intel_atomic_state(state)->internal = true;\n\n\t \n\tfor_each_intel_crtc_in_pipe_mask(&i915->drm, temp_crtc,\n\t\t\t\t\t BIT(pipe) |\n\t\t\t\t\t intel_crtc_bigjoiner_slave_pipes(crtc_state)) {\n\t\tstruct intel_crtc_state *temp_crtc_state =\n\t\t\tintel_atomic_get_crtc_state(state, temp_crtc);\n\t\tint ret;\n\n\t\tret = drm_atomic_add_affected_connectors(state, &temp_crtc->base);\n\n\t\tdrm_WARN_ON(&i915->drm, IS_ERR(temp_crtc_state) || ret);\n\t}\n\n\ti915->display.funcs.display->crtc_disable(to_intel_atomic_state(state), crtc);\n\n\tdrm_atomic_state_put(state);\n\n\tdrm_dbg_kms(&i915->drm,\n\t\t    \"[CRTC:%d:%s] hw state adjusted, was enabled, now disabled\\n\",\n\t\t    crtc->base.base.id, crtc->base.name);\n\n\tcrtc->active = false;\n\tcrtc->base.enabled = false;\n\n\tif (crtc_state->shared_dpll)\n\t\tintel_unreference_shared_dpll_crtc(crtc,\n\t\t\t\t\t\t   crtc_state->shared_dpll,\n\t\t\t\t\t\t   &crtc_state->shared_dpll->state);\n}\n\nstatic void set_encoder_for_connector(struct intel_connector *connector,\n\t\t\t\t      struct intel_encoder *encoder)\n{\n\tstruct drm_connector_state *conn_state = connector->base.state;\n\n\tif (conn_state->crtc)\n\t\tdrm_connector_put(&connector->base);\n\n\tif (encoder) {\n\t\tconn_state->best_encoder = &encoder->base;\n\t\tconn_state->crtc = encoder->base.crtc;\n\t\tdrm_connector_get(&connector->base);\n\t} else {\n\t\tconn_state->best_encoder = NULL;\n\t\tconn_state->crtc = NULL;\n\t}\n}\n\nstatic void reset_encoder_connector_state(struct intel_encoder *encoder)\n{\n\tstruct drm_i915_private *i915 = to_i915(encoder->base.dev);\n\tstruct intel_pmdemand_state *pmdemand_state =\n\t\tto_intel_pmdemand_state(i915->display.pmdemand.obj.state);\n\tstruct intel_connector *connector;\n\tstruct drm_connector_list_iter conn_iter;\n\n\tdrm_connector_list_iter_begin(&i915->drm, &conn_iter);\n\tfor_each_intel_connector_iter(connector, &conn_iter) {\n\t\tif (connector->base.encoder != &encoder->base)\n\t\t\tcontinue;\n\n\t\t \n\t\tintel_pmdemand_update_phys_mask(i915, encoder,\n\t\t\t\t\t\tpmdemand_state, false);\n\n\t\tset_encoder_for_connector(connector, NULL);\n\n\t\tconnector->base.dpms = DRM_MODE_DPMS_OFF;\n\t\tconnector->base.encoder = NULL;\n\t}\n\tdrm_connector_list_iter_end(&conn_iter);\n}\n\nstatic void reset_crtc_encoder_state(struct intel_crtc *crtc)\n{\n\tstruct drm_i915_private *i915 = to_i915(crtc->base.dev);\n\tstruct intel_encoder *encoder;\n\n\tfor_each_encoder_on_crtc(&i915->drm, &crtc->base, encoder) {\n\t\treset_encoder_connector_state(encoder);\n\t\tencoder->base.crtc = NULL;\n\t}\n}\n\nstatic void intel_crtc_disable_noatomic_complete(struct intel_crtc *crtc)\n{\n\tstruct drm_i915_private *i915 = to_i915(crtc->base.dev);\n\tstruct intel_bw_state *bw_state =\n\t\tto_intel_bw_state(i915->display.bw.obj.state);\n\tstruct intel_cdclk_state *cdclk_state =\n\t\tto_intel_cdclk_state(i915->display.cdclk.obj.state);\n\tstruct intel_dbuf_state *dbuf_state =\n\t\tto_intel_dbuf_state(i915->display.dbuf.obj.state);\n\tstruct intel_pmdemand_state *pmdemand_state =\n\t\tto_intel_pmdemand_state(i915->display.pmdemand.obj.state);\n\tstruct intel_crtc_state *crtc_state =\n\t\tto_intel_crtc_state(crtc->base.state);\n\tenum pipe pipe = crtc->pipe;\n\n\t__drm_atomic_helper_crtc_destroy_state(&crtc_state->uapi);\n\tintel_crtc_free_hw_state(crtc_state);\n\tintel_crtc_state_reset(crtc_state, crtc);\n\n\treset_crtc_encoder_state(crtc);\n\n\tintel_fbc_disable(crtc);\n\tintel_update_watermarks(i915);\n\n\tintel_display_power_put_all_in_set(i915, &crtc->enabled_power_domains);\n\n\tcdclk_state->min_cdclk[pipe] = 0;\n\tcdclk_state->min_voltage_level[pipe] = 0;\n\tcdclk_state->active_pipes &= ~BIT(pipe);\n\n\tdbuf_state->active_pipes &= ~BIT(pipe);\n\n\tbw_state->data_rate[pipe] = 0;\n\tbw_state->num_active_planes[pipe] = 0;\n\n\tintel_pmdemand_update_port_clock(i915, pmdemand_state, pipe, 0);\n}\n\n \nstatic u8 get_transcoder_pipes(struct drm_i915_private *i915,\n\t\t\t       u8 transcoder_mask)\n{\n\tstruct intel_crtc *temp_crtc;\n\tu8 pipes = 0;\n\n\tfor_each_intel_crtc(&i915->drm, temp_crtc) {\n\t\tstruct intel_crtc_state *temp_crtc_state =\n\t\t\tto_intel_crtc_state(temp_crtc->base.state);\n\n\t\tif (temp_crtc_state->cpu_transcoder == INVALID_TRANSCODER)\n\t\t\tcontinue;\n\n\t\tif (intel_crtc_is_bigjoiner_slave(temp_crtc_state))\n\t\t\tcontinue;\n\n\t\tif (transcoder_mask & BIT(temp_crtc_state->cpu_transcoder))\n\t\t\tpipes |= BIT(temp_crtc->pipe);\n\t}\n\n\treturn pipes;\n}\n\n \nstatic void get_portsync_pipes(struct intel_crtc *crtc,\n\t\t\t       u8 *master_pipe_mask, u8 *slave_pipes_mask)\n{\n\tstruct drm_i915_private *i915 = to_i915(crtc->base.dev);\n\tstruct intel_crtc_state *crtc_state =\n\t\tto_intel_crtc_state(crtc->base.state);\n\tstruct intel_crtc *master_crtc;\n\tstruct intel_crtc_state *master_crtc_state;\n\tenum transcoder master_transcoder;\n\n\tif (!is_trans_port_sync_mode(crtc_state)) {\n\t\t*master_pipe_mask = BIT(crtc->pipe);\n\t\t*slave_pipes_mask = 0;\n\n\t\treturn;\n\t}\n\n\tif (is_trans_port_sync_master(crtc_state))\n\t\tmaster_transcoder = crtc_state->cpu_transcoder;\n\telse\n\t\tmaster_transcoder = crtc_state->master_transcoder;\n\n\t*master_pipe_mask = get_transcoder_pipes(i915, BIT(master_transcoder));\n\tdrm_WARN_ON(&i915->drm, !is_power_of_2(*master_pipe_mask));\n\n\tmaster_crtc = intel_crtc_for_pipe(i915, ffs(*master_pipe_mask) - 1);\n\tmaster_crtc_state = to_intel_crtc_state(master_crtc->base.state);\n\t*slave_pipes_mask = get_transcoder_pipes(i915, master_crtc_state->sync_mode_slaves_mask);\n}\n\nstatic u8 get_bigjoiner_slave_pipes(struct drm_i915_private *i915, u8 master_pipes_mask)\n{\n\tstruct intel_crtc *master_crtc;\n\tu8 pipes = 0;\n\n\tfor_each_intel_crtc_in_pipe_mask(&i915->drm, master_crtc, master_pipes_mask) {\n\t\tstruct intel_crtc_state *master_crtc_state =\n\t\t\tto_intel_crtc_state(master_crtc->base.state);\n\n\t\tpipes |= intel_crtc_bigjoiner_slave_pipes(master_crtc_state);\n\t}\n\n\treturn pipes;\n}\n\nstatic void intel_crtc_disable_noatomic(struct intel_crtc *crtc,\n\t\t\t\t\tstruct drm_modeset_acquire_ctx *ctx)\n{\n\tstruct drm_i915_private *i915 = to_i915(crtc->base.dev);\n\tu8 portsync_master_mask;\n\tu8 portsync_slaves_mask;\n\tu8 bigjoiner_slaves_mask;\n\tstruct intel_crtc *temp_crtc;\n\n\t \n\tget_portsync_pipes(crtc, &portsync_master_mask, &portsync_slaves_mask);\n\tbigjoiner_slaves_mask = get_bigjoiner_slave_pipes(i915,\n\t\t\t\t\t\t\t  portsync_master_mask |\n\t\t\t\t\t\t\t  portsync_slaves_mask);\n\n\tdrm_WARN_ON(&i915->drm,\n\t\t    portsync_master_mask & portsync_slaves_mask ||\n\t\t    portsync_master_mask & bigjoiner_slaves_mask ||\n\t\t    portsync_slaves_mask & bigjoiner_slaves_mask);\n\n\tfor_each_intel_crtc_in_pipe_mask(&i915->drm, temp_crtc, bigjoiner_slaves_mask)\n\t\tintel_crtc_disable_noatomic_begin(temp_crtc, ctx);\n\n\tfor_each_intel_crtc_in_pipe_mask(&i915->drm, temp_crtc, portsync_slaves_mask)\n\t\tintel_crtc_disable_noatomic_begin(temp_crtc, ctx);\n\n\tfor_each_intel_crtc_in_pipe_mask(&i915->drm, temp_crtc, portsync_master_mask)\n\t\tintel_crtc_disable_noatomic_begin(temp_crtc, ctx);\n\n\tfor_each_intel_crtc_in_pipe_mask(&i915->drm, temp_crtc,\n\t\t\t\t\t bigjoiner_slaves_mask |\n\t\t\t\t\t portsync_slaves_mask |\n\t\t\t\t\t portsync_master_mask)\n\t\tintel_crtc_disable_noatomic_complete(temp_crtc);\n}\n\nstatic void intel_modeset_update_connector_atomic_state(struct drm_i915_private *i915)\n{\n\tstruct intel_connector *connector;\n\tstruct drm_connector_list_iter conn_iter;\n\n\tdrm_connector_list_iter_begin(&i915->drm, &conn_iter);\n\tfor_each_intel_connector_iter(connector, &conn_iter) {\n\t\tstruct drm_connector_state *conn_state = connector->base.state;\n\t\tstruct intel_encoder *encoder =\n\t\t\tto_intel_encoder(connector->base.encoder);\n\n\t\tset_encoder_for_connector(connector, encoder);\n\n\t\tif (encoder) {\n\t\t\tstruct intel_crtc *crtc =\n\t\t\t\tto_intel_crtc(encoder->base.crtc);\n\t\t\tconst struct intel_crtc_state *crtc_state =\n\t\t\t\tto_intel_crtc_state(crtc->base.state);\n\n\t\t\tconn_state->max_bpc = (crtc_state->pipe_bpp ?: 24) / 3;\n\t\t}\n\t}\n\tdrm_connector_list_iter_end(&conn_iter);\n}\n\nstatic void intel_crtc_copy_hw_to_uapi_state(struct intel_crtc_state *crtc_state)\n{\n\tif (intel_crtc_is_bigjoiner_slave(crtc_state))\n\t\treturn;\n\n\tcrtc_state->uapi.enable = crtc_state->hw.enable;\n\tcrtc_state->uapi.active = crtc_state->hw.active;\n\tdrm_WARN_ON(crtc_state->uapi.crtc->dev,\n\t\t    drm_atomic_set_mode_for_crtc(&crtc_state->uapi, &crtc_state->hw.mode) < 0);\n\n\tcrtc_state->uapi.adjusted_mode = crtc_state->hw.adjusted_mode;\n\tcrtc_state->uapi.scaling_filter = crtc_state->hw.scaling_filter;\n\n\t \n\tdrm_property_replace_blob(&crtc_state->hw.degamma_lut,\n\t\t\t\t  crtc_state->pre_csc_lut);\n\tdrm_property_replace_blob(&crtc_state->hw.gamma_lut,\n\t\t\t\t  crtc_state->post_csc_lut);\n\n\tdrm_property_replace_blob(&crtc_state->uapi.degamma_lut,\n\t\t\t\t  crtc_state->hw.degamma_lut);\n\tdrm_property_replace_blob(&crtc_state->uapi.gamma_lut,\n\t\t\t\t  crtc_state->hw.gamma_lut);\n\tdrm_property_replace_blob(&crtc_state->uapi.ctm,\n\t\t\t\t  crtc_state->hw.ctm);\n}\n\nstatic void\nintel_sanitize_plane_mapping(struct drm_i915_private *i915)\n{\n\tstruct intel_crtc *crtc;\n\n\tif (DISPLAY_VER(i915) >= 4)\n\t\treturn;\n\n\tfor_each_intel_crtc(&i915->drm, crtc) {\n\t\tstruct intel_plane *plane =\n\t\t\tto_intel_plane(crtc->base.primary);\n\t\tstruct intel_crtc *plane_crtc;\n\t\tenum pipe pipe;\n\n\t\tif (!plane->get_hw_state(plane, &pipe))\n\t\t\tcontinue;\n\n\t\tif (pipe == crtc->pipe)\n\t\t\tcontinue;\n\n\t\tdrm_dbg_kms(&i915->drm,\n\t\t\t    \"[PLANE:%d:%s] attached to the wrong pipe, disabling plane\\n\",\n\t\t\t    plane->base.base.id, plane->base.name);\n\n\t\tplane_crtc = intel_crtc_for_pipe(i915, pipe);\n\t\tintel_plane_disable_noatomic(plane_crtc, plane);\n\t}\n}\n\nstatic bool intel_crtc_has_encoders(struct intel_crtc *crtc)\n{\n\tstruct drm_device *dev = crtc->base.dev;\n\tstruct intel_encoder *encoder;\n\n\tfor_each_encoder_on_crtc(dev, &crtc->base, encoder)\n\t\treturn true;\n\n\treturn false;\n}\n\nstatic bool intel_crtc_needs_link_reset(struct intel_crtc *crtc)\n{\n\tstruct drm_device *dev = crtc->base.dev;\n\tstruct intel_encoder *encoder;\n\n\tfor_each_encoder_on_crtc(dev, &crtc->base, encoder) {\n\t\tstruct intel_digital_port *dig_port = enc_to_dig_port(encoder);\n\n\t\tif (dig_port && intel_tc_port_link_needs_reset(dig_port))\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}\n\nstatic struct intel_connector *intel_encoder_find_connector(struct intel_encoder *encoder)\n{\n\tstruct drm_i915_private *i915 = to_i915(encoder->base.dev);\n\tstruct drm_connector_list_iter conn_iter;\n\tstruct intel_connector *connector;\n\tstruct intel_connector *found_connector = NULL;\n\n\tdrm_connector_list_iter_begin(&i915->drm, &conn_iter);\n\tfor_each_intel_connector_iter(connector, &conn_iter) {\n\t\tif (&encoder->base == connector->base.encoder) {\n\t\t\tfound_connector = connector;\n\t\t\tbreak;\n\t\t}\n\t}\n\tdrm_connector_list_iter_end(&conn_iter);\n\n\treturn found_connector;\n}\n\nstatic void intel_sanitize_fifo_underrun_reporting(const struct intel_crtc_state *crtc_state)\n{\n\tstruct intel_crtc *crtc = to_intel_crtc(crtc_state->uapi.crtc);\n\tstruct drm_i915_private *i915 = to_i915(crtc->base.dev);\n\n\t \n\tintel_init_fifo_underrun_reporting(i915, crtc,\n\t\t\t\t\t   !crtc_state->hw.active &&\n\t\t\t\t\t   !HAS_GMCH(i915));\n}\n\nstatic bool intel_sanitize_crtc(struct intel_crtc *crtc,\n\t\t\t\tstruct drm_modeset_acquire_ctx *ctx)\n{\n\tstruct drm_i915_private *i915 = to_i915(crtc->base.dev);\n\tstruct intel_crtc_state *crtc_state = to_intel_crtc_state(crtc->base.state);\n\tbool needs_link_reset;\n\n\tif (crtc_state->hw.active) {\n\t\tstruct intel_plane *plane;\n\n\t\t \n\t\tfor_each_intel_plane_on_crtc(&i915->drm, crtc, plane) {\n\t\t\tconst struct intel_plane_state *plane_state =\n\t\t\t\tto_intel_plane_state(plane->base.state);\n\n\t\t\tif (plane_state->uapi.visible &&\n\t\t\t    plane->base.type != DRM_PLANE_TYPE_PRIMARY)\n\t\t\t\tintel_plane_disable_noatomic(crtc, plane);\n\t\t}\n\n\t\t \n\t\tintel_color_commit_noarm(crtc_state);\n\t\tintel_color_commit_arm(crtc_state);\n\t}\n\n\tif (!crtc_state->hw.active ||\n\t    intel_crtc_is_bigjoiner_slave(crtc_state))\n\t\treturn false;\n\n\tneeds_link_reset = intel_crtc_needs_link_reset(crtc);\n\n\t \n\tif (!needs_link_reset && intel_crtc_has_encoders(crtc))\n\t\treturn false;\n\n\tintel_crtc_disable_noatomic(crtc, ctx);\n\n\t \n\tif (needs_link_reset)\n\t\tmsleep(20);\n\n\treturn true;\n}\n\nstatic void intel_sanitize_all_crtcs(struct drm_i915_private *i915,\n\t\t\t\t     struct drm_modeset_acquire_ctx *ctx)\n{\n\tstruct intel_crtc *crtc;\n\tu32 crtcs_forced_off = 0;\n\n\t \n\tfor (;;) {\n\t\tu32 old_mask = crtcs_forced_off;\n\n\t\tfor_each_intel_crtc(&i915->drm, crtc) {\n\t\t\tu32 crtc_mask = drm_crtc_mask(&crtc->base);\n\n\t\t\tif (crtcs_forced_off & crtc_mask)\n\t\t\t\tcontinue;\n\n\t\t\tif (intel_sanitize_crtc(crtc, ctx))\n\t\t\t\tcrtcs_forced_off |= crtc_mask;\n\t\t}\n\t\tif (crtcs_forced_off == old_mask)\n\t\t\tbreak;\n\t}\n\n\tfor_each_intel_crtc(&i915->drm, crtc) {\n\t\tstruct intel_crtc_state *crtc_state =\n\t\t\tto_intel_crtc_state(crtc->base.state);\n\n\t\tintel_crtc_state_dump(crtc_state, NULL, \"setup_hw_state\");\n\t}\n}\n\nstatic bool has_bogus_dpll_config(const struct intel_crtc_state *crtc_state)\n{\n\tstruct drm_i915_private *i915 = to_i915(crtc_state->uapi.crtc->dev);\n\n\t \n\treturn IS_SANDYBRIDGE(i915) &&\n\t\tcrtc_state->hw.active &&\n\t\tcrtc_state->shared_dpll &&\n\t\tcrtc_state->port_clock == 0;\n}\n\nstatic void intel_sanitize_encoder(struct intel_encoder *encoder)\n{\n\tstruct drm_i915_private *i915 = to_i915(encoder->base.dev);\n\tstruct intel_connector *connector;\n\tstruct intel_crtc *crtc = to_intel_crtc(encoder->base.crtc);\n\tstruct intel_crtc_state *crtc_state = crtc ?\n\t\tto_intel_crtc_state(crtc->base.state) : NULL;\n\tstruct intel_pmdemand_state *pmdemand_state =\n\t\tto_intel_pmdemand_state(i915->display.pmdemand.obj.state);\n\n\t \n\tbool has_active_crtc = crtc_state &&\n\t\tcrtc_state->hw.active;\n\n\tif (crtc_state && has_bogus_dpll_config(crtc_state)) {\n\t\tdrm_dbg_kms(&i915->drm,\n\t\t\t    \"BIOS has misprogrammed the hardware. Disabling pipe %c\\n\",\n\t\t\t    pipe_name(crtc->pipe));\n\t\thas_active_crtc = false;\n\t}\n\n\tconnector = intel_encoder_find_connector(encoder);\n\tif (connector && !has_active_crtc) {\n\t\tdrm_dbg_kms(&i915->drm,\n\t\t\t    \"[ENCODER:%d:%s] has active connectors but no active pipe!\\n\",\n\t\t\t    encoder->base.base.id,\n\t\t\t    encoder->base.name);\n\n\t\t \n\t\tintel_pmdemand_update_phys_mask(i915, encoder,\n\t\t\t\t\t\tpmdemand_state, false);\n\n\t\t \n\t\tif (crtc_state) {\n\t\t\tstruct drm_encoder *best_encoder;\n\n\t\t\tdrm_dbg_kms(&i915->drm,\n\t\t\t\t    \"[ENCODER:%d:%s] manually disabled\\n\",\n\t\t\t\t    encoder->base.base.id,\n\t\t\t\t    encoder->base.name);\n\n\t\t\t \n\t\t\tbest_encoder = connector->base.state->best_encoder;\n\t\t\tconnector->base.state->best_encoder = &encoder->base;\n\n\t\t\t \n\t\t\tif (encoder->disable)\n\t\t\t\tencoder->disable(NULL, encoder, crtc_state,\n\t\t\t\t\t\t connector->base.state);\n\t\t\tif (encoder->post_disable)\n\t\t\t\tencoder->post_disable(NULL, encoder, crtc_state,\n\t\t\t\t\t\t      connector->base.state);\n\n\t\t\tconnector->base.state->best_encoder = best_encoder;\n\t\t}\n\t\tencoder->base.crtc = NULL;\n\n\t\t \n\t\tconnector->base.dpms = DRM_MODE_DPMS_OFF;\n\t\tconnector->base.encoder = NULL;\n\t}\n\n\t \n\tintel_opregion_notify_encoder(encoder, connector && has_active_crtc);\n\n\tif (HAS_DDI(i915))\n\t\tintel_ddi_sanitize_encoder_pll_mapping(encoder);\n}\n\n \nstatic void readout_plane_state(struct drm_i915_private *i915)\n{\n\tstruct intel_plane *plane;\n\tstruct intel_crtc *crtc;\n\n\tfor_each_intel_plane(&i915->drm, plane) {\n\t\tstruct intel_plane_state *plane_state =\n\t\t\tto_intel_plane_state(plane->base.state);\n\t\tstruct intel_crtc_state *crtc_state;\n\t\tenum pipe pipe = PIPE_A;\n\t\tbool visible;\n\n\t\tvisible = plane->get_hw_state(plane, &pipe);\n\n\t\tcrtc = intel_crtc_for_pipe(i915, pipe);\n\t\tcrtc_state = to_intel_crtc_state(crtc->base.state);\n\n\t\tintel_set_plane_visible(crtc_state, plane_state, visible);\n\n\t\tdrm_dbg_kms(&i915->drm,\n\t\t\t    \"[PLANE:%d:%s] hw state readout: %s, pipe %c\\n\",\n\t\t\t    plane->base.base.id, plane->base.name,\n\t\t\t    str_enabled_disabled(visible), pipe_name(pipe));\n\t}\n\n\tfor_each_intel_crtc(&i915->drm, crtc) {\n\t\tstruct intel_crtc_state *crtc_state =\n\t\t\tto_intel_crtc_state(crtc->base.state);\n\n\t\tintel_plane_fixup_bitmasks(crtc_state);\n\t}\n}\n\nstatic void intel_modeset_readout_hw_state(struct drm_i915_private *i915)\n{\n\tstruct intel_cdclk_state *cdclk_state =\n\t\tto_intel_cdclk_state(i915->display.cdclk.obj.state);\n\tstruct intel_dbuf_state *dbuf_state =\n\t\tto_intel_dbuf_state(i915->display.dbuf.obj.state);\n\tstruct intel_pmdemand_state *pmdemand_state =\n\t\tto_intel_pmdemand_state(i915->display.pmdemand.obj.state);\n\tenum pipe pipe;\n\tstruct intel_crtc *crtc;\n\tstruct intel_encoder *encoder;\n\tstruct intel_connector *connector;\n\tstruct drm_connector_list_iter conn_iter;\n\tu8 active_pipes = 0;\n\n\tfor_each_intel_crtc(&i915->drm, crtc) {\n\t\tstruct intel_crtc_state *crtc_state =\n\t\t\tto_intel_crtc_state(crtc->base.state);\n\n\t\t__drm_atomic_helper_crtc_destroy_state(&crtc_state->uapi);\n\t\tintel_crtc_free_hw_state(crtc_state);\n\t\tintel_crtc_state_reset(crtc_state, crtc);\n\n\t\tintel_crtc_get_pipe_config(crtc_state);\n\n\t\tcrtc_state->hw.enable = crtc_state->hw.active;\n\n\t\tcrtc->base.enabled = crtc_state->hw.enable;\n\t\tcrtc->active = crtc_state->hw.active;\n\n\t\tif (crtc_state->hw.active)\n\t\t\tactive_pipes |= BIT(crtc->pipe);\n\n\t\tdrm_dbg_kms(&i915->drm,\n\t\t\t    \"[CRTC:%d:%s] hw state readout: %s\\n\",\n\t\t\t    crtc->base.base.id, crtc->base.name,\n\t\t\t    str_enabled_disabled(crtc_state->hw.active));\n\t}\n\n\tcdclk_state->active_pipes = active_pipes;\n\tdbuf_state->active_pipes = active_pipes;\n\n\treadout_plane_state(i915);\n\n\tfor_each_intel_encoder(&i915->drm, encoder) {\n\t\tstruct intel_crtc_state *crtc_state = NULL;\n\n\t\tpipe = 0;\n\n\t\tif (encoder->get_hw_state(encoder, &pipe)) {\n\t\t\tcrtc = intel_crtc_for_pipe(i915, pipe);\n\t\t\tcrtc_state = to_intel_crtc_state(crtc->base.state);\n\n\t\t\tencoder->base.crtc = &crtc->base;\n\t\t\tintel_encoder_get_config(encoder, crtc_state);\n\n\t\t\t \n\t\t\tif (crtc_state->bigjoiner_pipes) {\n\t\t\t\tstruct intel_crtc *slave_crtc;\n\n\t\t\t\t \n\t\t\t\tWARN_ON(intel_crtc_is_bigjoiner_slave(crtc_state));\n\n\t\t\t\tfor_each_intel_crtc_in_pipe_mask(&i915->drm, slave_crtc,\n\t\t\t\t\t\t\t\t intel_crtc_bigjoiner_slave_pipes(crtc_state)) {\n\t\t\t\t\tstruct intel_crtc_state *slave_crtc_state;\n\n\t\t\t\t\tslave_crtc_state = to_intel_crtc_state(slave_crtc->base.state);\n\t\t\t\t\tintel_encoder_get_config(encoder, slave_crtc_state);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tintel_pmdemand_update_phys_mask(i915, encoder,\n\t\t\t\t\t\t\tpmdemand_state,\n\t\t\t\t\t\t\ttrue);\n\t\t} else {\n\t\t\tintel_pmdemand_update_phys_mask(i915, encoder,\n\t\t\t\t\t\t\tpmdemand_state,\n\t\t\t\t\t\t\tfalse);\n\n\t\t\tencoder->base.crtc = NULL;\n\t\t}\n\n\t\tif (encoder->sync_state)\n\t\t\tencoder->sync_state(encoder, crtc_state);\n\n\t\tdrm_dbg_kms(&i915->drm,\n\t\t\t    \"[ENCODER:%d:%s] hw state readout: %s, pipe %c\\n\",\n\t\t\t    encoder->base.base.id, encoder->base.name,\n\t\t\t    str_enabled_disabled(encoder->base.crtc),\n\t\t\t    pipe_name(pipe));\n\t}\n\n\tintel_dpll_readout_hw_state(i915);\n\n\tdrm_connector_list_iter_begin(&i915->drm, &conn_iter);\n\tfor_each_intel_connector_iter(connector, &conn_iter) {\n\t\tif (connector->get_hw_state(connector)) {\n\t\t\tstruct intel_crtc_state *crtc_state;\n\t\t\tstruct intel_crtc *crtc;\n\n\t\t\tconnector->base.dpms = DRM_MODE_DPMS_ON;\n\n\t\t\tencoder = intel_attached_encoder(connector);\n\t\t\tconnector->base.encoder = &encoder->base;\n\n\t\t\tcrtc = to_intel_crtc(encoder->base.crtc);\n\t\t\tcrtc_state = crtc ? to_intel_crtc_state(crtc->base.state) : NULL;\n\n\t\t\tif (crtc_state && crtc_state->hw.active) {\n\t\t\t\t \n\t\t\t\tcrtc_state->uapi.connector_mask |=\n\t\t\t\t\tdrm_connector_mask(&connector->base);\n\t\t\t\tcrtc_state->uapi.encoder_mask |=\n\t\t\t\t\tdrm_encoder_mask(&encoder->base);\n\t\t\t}\n\t\t} else {\n\t\t\tconnector->base.dpms = DRM_MODE_DPMS_OFF;\n\t\t\tconnector->base.encoder = NULL;\n\t\t}\n\t\tdrm_dbg_kms(&i915->drm,\n\t\t\t    \"[CONNECTOR:%d:%s] hw state readout: %s\\n\",\n\t\t\t    connector->base.base.id, connector->base.name,\n\t\t\t    str_enabled_disabled(connector->base.encoder));\n\t}\n\tdrm_connector_list_iter_end(&conn_iter);\n\n\tfor_each_intel_crtc(&i915->drm, crtc) {\n\t\tstruct intel_bw_state *bw_state =\n\t\t\tto_intel_bw_state(i915->display.bw.obj.state);\n\t\tstruct intel_crtc_state *crtc_state =\n\t\t\tto_intel_crtc_state(crtc->base.state);\n\t\tstruct intel_plane *plane;\n\t\tint min_cdclk = 0;\n\n\t\tif (crtc_state->hw.active) {\n\t\t\t \n\t\t\tcrtc_state->inherited = true;\n\n\t\t\tintel_crtc_update_active_timings(crtc_state,\n\t\t\t\t\t\t\t crtc_state->vrr.enable);\n\n\t\t\tintel_crtc_copy_hw_to_uapi_state(crtc_state);\n\t\t}\n\n\t\tfor_each_intel_plane_on_crtc(&i915->drm, crtc, plane) {\n\t\t\tconst struct intel_plane_state *plane_state =\n\t\t\t\tto_intel_plane_state(plane->base.state);\n\n\t\t\t \n\t\t\tif (plane_state->uapi.visible)\n\t\t\t\tcrtc_state->data_rate[plane->id] =\n\t\t\t\t\t4 * crtc_state->pixel_rate;\n\t\t\t \n\t\t\tif (plane_state->uapi.visible && plane->min_cdclk) {\n\t\t\t\tif (crtc_state->double_wide || DISPLAY_VER(i915) >= 10)\n\t\t\t\t\tcrtc_state->min_cdclk[plane->id] =\n\t\t\t\t\t\tDIV_ROUND_UP(crtc_state->pixel_rate, 2);\n\t\t\t\telse\n\t\t\t\t\tcrtc_state->min_cdclk[plane->id] =\n\t\t\t\t\t\tcrtc_state->pixel_rate;\n\t\t\t}\n\t\t\tdrm_dbg_kms(&i915->drm,\n\t\t\t\t    \"[PLANE:%d:%s] min_cdclk %d kHz\\n\",\n\t\t\t\t    plane->base.base.id, plane->base.name,\n\t\t\t\t    crtc_state->min_cdclk[plane->id]);\n\t\t}\n\n\t\tif (crtc_state->hw.active) {\n\t\t\tmin_cdclk = intel_crtc_compute_min_cdclk(crtc_state);\n\t\t\tif (drm_WARN_ON(&i915->drm, min_cdclk < 0))\n\t\t\t\tmin_cdclk = 0;\n\t\t}\n\n\t\tcdclk_state->min_cdclk[crtc->pipe] = min_cdclk;\n\t\tcdclk_state->min_voltage_level[crtc->pipe] =\n\t\t\tcrtc_state->min_voltage_level;\n\n\t\tintel_pmdemand_update_port_clock(i915, pmdemand_state, pipe,\n\t\t\t\t\t\t crtc_state->port_clock);\n\n\t\tintel_bw_crtc_update(bw_state, crtc_state);\n\t}\n\n\tintel_pmdemand_init_pmdemand_params(i915, pmdemand_state);\n}\n\nstatic void\nget_encoder_power_domains(struct drm_i915_private *i915)\n{\n\tstruct intel_encoder *encoder;\n\n\tfor_each_intel_encoder(&i915->drm, encoder) {\n\t\tstruct intel_crtc_state *crtc_state;\n\n\t\tif (!encoder->get_power_domains)\n\t\t\tcontinue;\n\n\t\t \n\t\tif (!encoder->base.crtc)\n\t\t\tcontinue;\n\n\t\tcrtc_state = to_intel_crtc_state(encoder->base.crtc->state);\n\t\tencoder->get_power_domains(encoder, crtc_state);\n\t}\n}\n\nstatic void intel_early_display_was(struct drm_i915_private *i915)\n{\n\t \n\tif (IS_DISPLAY_VER(i915, 10, 12))\n\t\tintel_de_rmw(i915, GEN9_CLKGATE_DIS_0, 0, DARBF_GATING_DIS);\n\n\t \n\tif (IS_HASWELL(i915))\n\t\tintel_de_rmw(i915, CHICKEN_PAR1_1, 0, FORCE_ARB_IDLE_PLANES);\n\n\tif (IS_KABYLAKE(i915) || IS_COFFEELAKE(i915) || IS_COMETLAKE(i915)) {\n\t\t \n\t\tintel_de_rmw(i915, CHICKEN_PAR1_1,\n\t\t\t     KBL_ARB_FILL_SPARE_22, KBL_ARB_FILL_SPARE_22);\n\t\tintel_de_rmw(i915, CHICKEN_MISC_2,\n\t\t\t     KBL_ARB_FILL_SPARE_13 | KBL_ARB_FILL_SPARE_14,\n\t\t\t     KBL_ARB_FILL_SPARE_14);\n\t}\n}\n\nvoid intel_modeset_setup_hw_state(struct drm_i915_private *i915,\n\t\t\t\t  struct drm_modeset_acquire_ctx *ctx)\n{\n\tstruct intel_encoder *encoder;\n\tstruct intel_crtc *crtc;\n\tintel_wakeref_t wakeref;\n\n\twakeref = intel_display_power_get(i915, POWER_DOMAIN_INIT);\n\n\tintel_early_display_was(i915);\n\tintel_modeset_readout_hw_state(i915);\n\n\t \n\tget_encoder_power_domains(i915);\n\n\tintel_pch_sanitize(i915);\n\n\t \n\tfor_each_intel_crtc(&i915->drm, crtc) {\n\t\tstruct intel_crtc_state *crtc_state =\n\t\t\tto_intel_crtc_state(crtc->base.state);\n\n\t\tintel_sanitize_fifo_underrun_reporting(crtc_state);\n\n\t\tdrm_crtc_vblank_reset(&crtc->base);\n\n\t\tif (crtc_state->hw.active) {\n\t\t\tintel_dmc_enable_pipe(i915, crtc->pipe);\n\t\t\tintel_crtc_vblank_on(crtc_state);\n\t\t}\n\t}\n\n\tintel_fbc_sanitize(i915);\n\n\tintel_sanitize_plane_mapping(i915);\n\n\tfor_each_intel_encoder(&i915->drm, encoder)\n\t\tintel_sanitize_encoder(encoder);\n\n\t \n\tintel_modeset_update_connector_atomic_state(i915);\n\n\tintel_sanitize_all_crtcs(i915, ctx);\n\n\tintel_dpll_sanitize_state(i915);\n\n\tintel_wm_get_hw_state(i915);\n\n\tfor_each_intel_crtc(&i915->drm, crtc) {\n\t\tstruct intel_crtc_state *crtc_state =\n\t\t\tto_intel_crtc_state(crtc->base.state);\n\t\tstruct intel_power_domain_mask put_domains;\n\n\t\tintel_modeset_get_crtc_power_domains(crtc_state, &put_domains);\n\t\tif (drm_WARN_ON(&i915->drm, !bitmap_empty(put_domains.bits, POWER_DOMAIN_NUM)))\n\t\t\tintel_modeset_put_crtc_power_domains(crtc, &put_domains);\n\t}\n\n\tintel_display_power_put(i915, POWER_DOMAIN_INIT, wakeref);\n\n\tintel_power_domains_sanitize_state(i915);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}