{
  "module_name": "vlv_dsi.c",
  "hash_id": "49a85f47e34b13319696ef940cabf2fec336cd853b76fcaf47107566956d122a",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/i915/display/vlv_dsi.c",
  "human_readable_source": " \n\n#include <linux/slab.h>\n\n#include <drm/drm_atomic_helper.h>\n#include <drm/drm_crtc.h>\n#include <drm/drm_edid.h>\n#include <drm/drm_mipi_dsi.h>\n\n#include \"i915_drv.h\"\n#include \"i915_reg.h\"\n#include \"intel_atomic.h\"\n#include \"intel_backlight.h\"\n#include \"intel_connector.h\"\n#include \"intel_crtc.h\"\n#include \"intel_de.h\"\n#include \"intel_display_types.h\"\n#include \"intel_dsi.h\"\n#include \"intel_dsi_vbt.h\"\n#include \"intel_fifo_underrun.h\"\n#include \"intel_panel.h\"\n#include \"skl_scaler.h\"\n#include \"vlv_dsi.h\"\n#include \"vlv_dsi_pll.h\"\n#include \"vlv_dsi_regs.h\"\n#include \"vlv_sideband.h\"\n\n \nstatic u16 txbyteclkhs(u16 pixels, int bpp, int lane_count,\n\t\t       u16 burst_mode_ratio)\n{\n\treturn DIV_ROUND_UP(DIV_ROUND_UP(pixels * bpp * burst_mode_ratio,\n\t\t\t\t\t 8 * 100), lane_count);\n}\n\n \nstatic u16 pixels_from_txbyteclkhs(u16 clk_hs, int bpp, int lane_count,\n\t\t\tu16 burst_mode_ratio)\n{\n\treturn DIV_ROUND_UP((clk_hs * lane_count * 8 * 100),\n\t\t\t\t\t\t(bpp * burst_mode_ratio));\n}\n\nenum mipi_dsi_pixel_format pixel_format_from_register_bits(u32 fmt)\n{\n\t \n\tswitch (fmt) {\n\tcase VID_MODE_FORMAT_RGB888:\n\t\treturn MIPI_DSI_FMT_RGB888;\n\tcase VID_MODE_FORMAT_RGB666:\n\t\treturn MIPI_DSI_FMT_RGB666;\n\tcase VID_MODE_FORMAT_RGB666_PACKED:\n\t\treturn MIPI_DSI_FMT_RGB666_PACKED;\n\tcase VID_MODE_FORMAT_RGB565:\n\t\treturn MIPI_DSI_FMT_RGB565;\n\tdefault:\n\t\tMISSING_CASE(fmt);\n\t\treturn MIPI_DSI_FMT_RGB666;\n\t}\n}\n\nvoid vlv_dsi_wait_for_fifo_empty(struct intel_dsi *intel_dsi, enum port port)\n{\n\tstruct drm_encoder *encoder = &intel_dsi->base.base;\n\tstruct drm_device *dev = encoder->dev;\n\tstruct drm_i915_private *dev_priv = to_i915(dev);\n\tu32 mask;\n\n\tmask = LP_CTRL_FIFO_EMPTY | HS_CTRL_FIFO_EMPTY |\n\t\tLP_DATA_FIFO_EMPTY | HS_DATA_FIFO_EMPTY;\n\n\tif (intel_de_wait_for_set(dev_priv, MIPI_GEN_FIFO_STAT(port),\n\t\t\t\t  mask, 100))\n\t\tdrm_err(&dev_priv->drm, \"DPI FIFOs are not empty\\n\");\n}\n\nstatic void write_data(struct drm_i915_private *dev_priv,\n\t\t       i915_reg_t reg,\n\t\t       const u8 *data, u32 len)\n{\n\tu32 i, j;\n\n\tfor (i = 0; i < len; i += 4) {\n\t\tu32 val = 0;\n\n\t\tfor (j = 0; j < min_t(u32, len - i, 4); j++)\n\t\t\tval |= *data++ << 8 * j;\n\n\t\tintel_de_write(dev_priv, reg, val);\n\t}\n}\n\nstatic void read_data(struct drm_i915_private *dev_priv,\n\t\t      i915_reg_t reg,\n\t\t      u8 *data, u32 len)\n{\n\tu32 i, j;\n\n\tfor (i = 0; i < len; i += 4) {\n\t\tu32 val = intel_de_read(dev_priv, reg);\n\n\t\tfor (j = 0; j < min_t(u32, len - i, 4); j++)\n\t\t\t*data++ = val >> 8 * j;\n\t}\n}\n\nstatic ssize_t intel_dsi_host_transfer(struct mipi_dsi_host *host,\n\t\t\t\t       const struct mipi_dsi_msg *msg)\n{\n\tstruct intel_dsi_host *intel_dsi_host = to_intel_dsi_host(host);\n\tstruct drm_device *dev = intel_dsi_host->intel_dsi->base.base.dev;\n\tstruct drm_i915_private *dev_priv = to_i915(dev);\n\tenum port port = intel_dsi_host->port;\n\tstruct mipi_dsi_packet packet;\n\tssize_t ret;\n\tconst u8 *header;\n\ti915_reg_t data_reg, ctrl_reg;\n\tu32 data_mask, ctrl_mask;\n\n\tret = mipi_dsi_create_packet(&packet, msg);\n\tif (ret < 0)\n\t\treturn ret;\n\n\theader = packet.header;\n\n\tif (msg->flags & MIPI_DSI_MSG_USE_LPM) {\n\t\tdata_reg = MIPI_LP_GEN_DATA(port);\n\t\tdata_mask = LP_DATA_FIFO_FULL;\n\t\tctrl_reg = MIPI_LP_GEN_CTRL(port);\n\t\tctrl_mask = LP_CTRL_FIFO_FULL;\n\t} else {\n\t\tdata_reg = MIPI_HS_GEN_DATA(port);\n\t\tdata_mask = HS_DATA_FIFO_FULL;\n\t\tctrl_reg = MIPI_HS_GEN_CTRL(port);\n\t\tctrl_mask = HS_CTRL_FIFO_FULL;\n\t}\n\n\t \n\tif (packet.payload_length) {\n\t\tif (intel_de_wait_for_clear(dev_priv, MIPI_GEN_FIFO_STAT(port),\n\t\t\t\t\t    data_mask, 50))\n\t\t\tdrm_err(&dev_priv->drm,\n\t\t\t\t\"Timeout waiting for HS/LP DATA FIFO !full\\n\");\n\n\t\twrite_data(dev_priv, data_reg, packet.payload,\n\t\t\t   packet.payload_length);\n\t}\n\n\tif (msg->rx_len) {\n\t\tintel_de_write(dev_priv, MIPI_INTR_STAT(port),\n\t\t\t       GEN_READ_DATA_AVAIL);\n\t}\n\n\tif (intel_de_wait_for_clear(dev_priv, MIPI_GEN_FIFO_STAT(port),\n\t\t\t\t    ctrl_mask, 50)) {\n\t\tdrm_err(&dev_priv->drm,\n\t\t\t\"Timeout waiting for HS/LP CTRL FIFO !full\\n\");\n\t}\n\n\tintel_de_write(dev_priv, ctrl_reg,\n\t\t       header[2] << 16 | header[1] << 8 | header[0]);\n\n\t \n\tif (msg->rx_len) {\n\t\tdata_mask = GEN_READ_DATA_AVAIL;\n\t\tif (intel_de_wait_for_set(dev_priv, MIPI_INTR_STAT(port),\n\t\t\t\t\t  data_mask, 50))\n\t\t\tdrm_err(&dev_priv->drm,\n\t\t\t\t\"Timeout waiting for read data.\\n\");\n\n\t\tread_data(dev_priv, data_reg, msg->rx_buf, msg->rx_len);\n\t}\n\n\t \n\treturn 4 + packet.payload_length;\n}\n\nstatic int intel_dsi_host_attach(struct mipi_dsi_host *host,\n\t\t\t\t struct mipi_dsi_device *dsi)\n{\n\treturn 0;\n}\n\nstatic int intel_dsi_host_detach(struct mipi_dsi_host *host,\n\t\t\t\t struct mipi_dsi_device *dsi)\n{\n\treturn 0;\n}\n\nstatic const struct mipi_dsi_host_ops intel_dsi_host_ops = {\n\t.attach = intel_dsi_host_attach,\n\t.detach = intel_dsi_host_detach,\n\t.transfer = intel_dsi_host_transfer,\n};\n\n \nstatic int dpi_send_cmd(struct intel_dsi *intel_dsi, u32 cmd, bool hs,\n\t\t\tenum port port)\n{\n\tstruct drm_encoder *encoder = &intel_dsi->base.base;\n\tstruct drm_device *dev = encoder->dev;\n\tstruct drm_i915_private *dev_priv = to_i915(dev);\n\tu32 mask;\n\n\t \n\tif (hs)\n\t\tcmd &= ~DPI_LP_MODE;\n\telse\n\t\tcmd |= DPI_LP_MODE;\n\n\t \n\tintel_de_write(dev_priv, MIPI_INTR_STAT(port), SPL_PKT_SENT_INTERRUPT);\n\n\t \n\tif (cmd == intel_de_read(dev_priv, MIPI_DPI_CONTROL(port)))\n\t\tdrm_dbg_kms(&dev_priv->drm,\n\t\t\t    \"Same special packet %02x twice in a row.\\n\", cmd);\n\n\tintel_de_write(dev_priv, MIPI_DPI_CONTROL(port), cmd);\n\n\tmask = SPL_PKT_SENT_INTERRUPT;\n\tif (intel_de_wait_for_set(dev_priv, MIPI_INTR_STAT(port), mask, 100))\n\t\tdrm_err(&dev_priv->drm,\n\t\t\t\"Video mode command 0x%08x send failed.\\n\", cmd);\n\n\treturn 0;\n}\n\nstatic void band_gap_reset(struct drm_i915_private *dev_priv)\n{\n\tvlv_flisdsi_get(dev_priv);\n\n\tvlv_flisdsi_write(dev_priv, 0x08, 0x0001);\n\tvlv_flisdsi_write(dev_priv, 0x0F, 0x0005);\n\tvlv_flisdsi_write(dev_priv, 0x0F, 0x0025);\n\tudelay(150);\n\tvlv_flisdsi_write(dev_priv, 0x0F, 0x0000);\n\tvlv_flisdsi_write(dev_priv, 0x08, 0x0000);\n\n\tvlv_flisdsi_put(dev_priv);\n}\n\nstatic int intel_dsi_compute_config(struct intel_encoder *encoder,\n\t\t\t\t    struct intel_crtc_state *pipe_config,\n\t\t\t\t    struct drm_connector_state *conn_state)\n{\n\tstruct drm_i915_private *dev_priv = to_i915(encoder->base.dev);\n\tstruct intel_dsi *intel_dsi = container_of(encoder, struct intel_dsi,\n\t\t\t\t\t\t   base);\n\tstruct intel_connector *intel_connector = intel_dsi->attached_connector;\n\tstruct drm_display_mode *adjusted_mode = &pipe_config->hw.adjusted_mode;\n\tint ret;\n\n\tdrm_dbg_kms(&dev_priv->drm, \"\\n\");\n\tpipe_config->sink_format = INTEL_OUTPUT_FORMAT_RGB;\n\tpipe_config->output_format = INTEL_OUTPUT_FORMAT_RGB;\n\n\tret = intel_panel_compute_config(intel_connector, adjusted_mode);\n\tif (ret)\n\t\treturn ret;\n\n\tret = intel_panel_fitting(pipe_config, conn_state);\n\tif (ret)\n\t\treturn ret;\n\n\tif (adjusted_mode->flags & DRM_MODE_FLAG_DBLSCAN)\n\t\treturn -EINVAL;\n\n\t \n\tadjusted_mode->flags = 0;\n\n\tif (intel_dsi->pixel_format == MIPI_DSI_FMT_RGB888)\n\t\tpipe_config->pipe_bpp = 24;\n\telse\n\t\tpipe_config->pipe_bpp = 18;\n\n\tif (IS_GEMINILAKE(dev_priv) || IS_BROXTON(dev_priv)) {\n\t\t \n\t\tpipe_config->mode_flags |=\n\t\t\tI915_MODE_FLAG_GET_SCANLINE_FROM_TIMESTAMP;\n\n\t\t \n\t\tif (intel_dsi->ports == BIT(PORT_C))\n\t\t\tpipe_config->cpu_transcoder = TRANSCODER_DSI_C;\n\t\telse\n\t\t\tpipe_config->cpu_transcoder = TRANSCODER_DSI_A;\n\n\t\tret = bxt_dsi_pll_compute(encoder, pipe_config);\n\t\tif (ret)\n\t\t\treturn -EINVAL;\n\t} else {\n\t\tret = vlv_dsi_pll_compute(encoder, pipe_config);\n\t\tif (ret)\n\t\t\treturn -EINVAL;\n\t}\n\n\tpipe_config->clock_set = true;\n\n\treturn 0;\n}\n\nstatic bool glk_dsi_enable_io(struct intel_encoder *encoder)\n{\n\tstruct drm_i915_private *dev_priv = to_i915(encoder->base.dev);\n\tstruct intel_dsi *intel_dsi = enc_to_intel_dsi(encoder);\n\tenum port port;\n\tbool cold_boot = false;\n\n\t \n\tfor_each_dsi_port(port, intel_dsi->ports)\n\t\tintel_de_rmw(dev_priv, MIPI_CTRL(port), 0, GLK_MIPIIO_ENABLE);\n\n\t \n\tintel_de_rmw(dev_priv, MIPI_CTRL(PORT_A), GLK_MIPIIO_RESET_RELEASED, 0);\n\n\t \n\tfor_each_dsi_port(port, intel_dsi->ports) {\n\t\tu32 tmp = intel_de_read(dev_priv, MIPI_DEVICE_READY(port));\n\t\tintel_de_rmw(dev_priv, MIPI_CTRL(port),\n\t\t\t     GLK_LP_WAKE, (tmp & DEVICE_READY) ? GLK_LP_WAKE : 0);\n\t}\n\n\t \n\tfor_each_dsi_port(port, intel_dsi->ports) {\n\t\tif (intel_de_wait_for_set(dev_priv, MIPI_CTRL(port),\n\t\t\t\t\t  GLK_MIPIIO_PORT_POWERED, 20))\n\t\t\tdrm_err(&dev_priv->drm, \"MIPIO port is powergated\\n\");\n\t}\n\n\t \n\tfor_each_dsi_port(port, intel_dsi->ports) {\n\t\tcold_boot |=\n\t\t\t!(intel_de_read(dev_priv, MIPI_DEVICE_READY(port)) & DEVICE_READY);\n\t}\n\n\treturn cold_boot;\n}\n\nstatic void glk_dsi_device_ready(struct intel_encoder *encoder)\n{\n\tstruct drm_i915_private *dev_priv = to_i915(encoder->base.dev);\n\tstruct intel_dsi *intel_dsi = enc_to_intel_dsi(encoder);\n\tenum port port;\n\n\t \n\tfor_each_dsi_port(port, intel_dsi->ports) {\n\t\tif (intel_de_wait_for_set(dev_priv, MIPI_CTRL(port),\n\t\t\t\t\t  GLK_PHY_STATUS_PORT_READY, 20))\n\t\t\tdrm_err(&dev_priv->drm, \"PHY is not ON\\n\");\n\t}\n\n\t \n\tintel_de_rmw(dev_priv, MIPI_CTRL(PORT_A), 0, GLK_MIPIIO_RESET_RELEASED);\n\n\t \n\tfor_each_dsi_port(port, intel_dsi->ports) {\n\t\tif (!(intel_de_read(dev_priv, MIPI_DEVICE_READY(port)) & DEVICE_READY)) {\n\t\t\tintel_de_rmw(dev_priv, MIPI_DEVICE_READY(port),\n\t\t\t\t     ULPS_STATE_MASK, DEVICE_READY);\n\t\t\tusleep_range(10, 15);\n\t\t} else {\n\t\t\t \n\t\t\tintel_de_rmw(dev_priv, MIPI_DEVICE_READY(port),\n\t\t\t\t     ULPS_STATE_MASK, ULPS_STATE_ENTER | DEVICE_READY);\n\n\t\t\t \n\t\t\tif (intel_de_wait_for_clear(dev_priv, MIPI_CTRL(port),\n\t\t\t\t\t\t    GLK_ULPS_NOT_ACTIVE, 20))\n\t\t\t\tdrm_err(&dev_priv->drm, \"ULPS not active\\n\");\n\n\t\t\t \n\t\t\tintel_de_rmw(dev_priv, MIPI_DEVICE_READY(port),\n\t\t\t\t     ULPS_STATE_MASK, ULPS_STATE_EXIT | DEVICE_READY);\n\n\t\t\t \n\t\t\tintel_de_rmw(dev_priv, MIPI_DEVICE_READY(port),\n\t\t\t\t     ULPS_STATE_MASK,\n\t\t\t\t     ULPS_STATE_NORMAL_OPERATION | DEVICE_READY);\n\n\t\t\tintel_de_rmw(dev_priv, MIPI_CTRL(port), GLK_LP_WAKE, 0);\n\t\t}\n\t}\n\n\t \n\tfor_each_dsi_port(port, intel_dsi->ports) {\n\t\tif (intel_de_wait_for_set(dev_priv, MIPI_CTRL(port),\n\t\t\t\t\t  GLK_DATA_LANE_STOP_STATE, 20))\n\t\t\tdrm_err(&dev_priv->drm,\n\t\t\t\t\"Date lane not in STOP state\\n\");\n\t}\n\n\t \n\tfor_each_dsi_port(port, intel_dsi->ports) {\n\t\tif (intel_de_wait_for_set(dev_priv, BXT_MIPI_PORT_CTRL(port),\n\t\t\t\t\t  AFE_LATCHOUT, 20))\n\t\t\tdrm_err(&dev_priv->drm,\n\t\t\t\t\"D-PHY not entering LP-11 state\\n\");\n\t}\n}\n\nstatic void bxt_dsi_device_ready(struct intel_encoder *encoder)\n{\n\tstruct drm_i915_private *dev_priv = to_i915(encoder->base.dev);\n\tstruct intel_dsi *intel_dsi = enc_to_intel_dsi(encoder);\n\tenum port port;\n\tu32 val;\n\n\tdrm_dbg_kms(&dev_priv->drm, \"\\n\");\n\n\t \n\tfor_each_dsi_port(port, intel_dsi->ports) {\n\t\tintel_de_rmw(dev_priv, BXT_MIPI_PORT_CTRL(port), 0, LP_OUTPUT_HOLD);\n\t\tusleep_range(2000, 2500);\n\t}\n\n\t \n\tfor_each_dsi_port(port, intel_dsi->ports) {\n\t\tval = intel_de_read(dev_priv, MIPI_DEVICE_READY(port));\n\t\tval &= ~ULPS_STATE_MASK;\n\t\tintel_de_write(dev_priv, MIPI_DEVICE_READY(port), val);\n\t\tusleep_range(2000, 2500);\n\t\tval |= DEVICE_READY;\n\t\tintel_de_write(dev_priv, MIPI_DEVICE_READY(port), val);\n\t}\n}\n\nstatic void vlv_dsi_device_ready(struct intel_encoder *encoder)\n{\n\tstruct drm_i915_private *dev_priv = to_i915(encoder->base.dev);\n\tstruct intel_dsi *intel_dsi = enc_to_intel_dsi(encoder);\n\tenum port port;\n\n\tdrm_dbg_kms(&dev_priv->drm, \"\\n\");\n\n\tvlv_flisdsi_get(dev_priv);\n\t \n\tvlv_flisdsi_write(dev_priv, 0x04, 0x0004);\n\tvlv_flisdsi_put(dev_priv);\n\n\t \n\tband_gap_reset(dev_priv);\n\n\tfor_each_dsi_port(port, intel_dsi->ports) {\n\n\t\tintel_de_write(dev_priv, MIPI_DEVICE_READY(port),\n\t\t\t       ULPS_STATE_ENTER);\n\t\tusleep_range(2500, 3000);\n\n\t\t \n\t\tintel_de_rmw(dev_priv, MIPI_PORT_CTRL(PORT_A), 0, LP_OUTPUT_HOLD);\n\t\tusleep_range(1000, 1500);\n\n\t\tintel_de_write(dev_priv, MIPI_DEVICE_READY(port),\n\t\t\t       ULPS_STATE_EXIT);\n\t\tusleep_range(2500, 3000);\n\n\t\tintel_de_write(dev_priv, MIPI_DEVICE_READY(port),\n\t\t\t       DEVICE_READY);\n\t\tusleep_range(2500, 3000);\n\t}\n}\n\nstatic void intel_dsi_device_ready(struct intel_encoder *encoder)\n{\n\tstruct drm_i915_private *dev_priv = to_i915(encoder->base.dev);\n\n\tif (IS_GEMINILAKE(dev_priv))\n\t\tglk_dsi_device_ready(encoder);\n\telse if (IS_GEMINILAKE(dev_priv) || IS_BROXTON(dev_priv))\n\t\tbxt_dsi_device_ready(encoder);\n\telse\n\t\tvlv_dsi_device_ready(encoder);\n}\n\nstatic void glk_dsi_enter_low_power_mode(struct intel_encoder *encoder)\n{\n\tstruct drm_i915_private *dev_priv = to_i915(encoder->base.dev);\n\tstruct intel_dsi *intel_dsi = enc_to_intel_dsi(encoder);\n\tenum port port;\n\n\t \n\tfor_each_dsi_port(port, intel_dsi->ports)\n\t\tintel_de_rmw(dev_priv, MIPI_DEVICE_READY(port),\n\t\t\t     ULPS_STATE_MASK, ULPS_STATE_ENTER | DEVICE_READY);\n\n\t \n\tfor_each_dsi_port(port, intel_dsi->ports) {\n\t\tif (intel_de_wait_for_clear(dev_priv, MIPI_CTRL(port),\n\t\t\t\t\t    GLK_PHY_STATUS_PORT_READY, 20))\n\t\t\tdrm_err(&dev_priv->drm, \"PHY is not turning OFF\\n\");\n\t}\n\n\t \n\tfor_each_dsi_port(port, intel_dsi->ports) {\n\t\tif (intel_de_wait_for_clear(dev_priv, MIPI_CTRL(port),\n\t\t\t\t\t    GLK_MIPIIO_PORT_POWERED, 20))\n\t\t\tdrm_err(&dev_priv->drm,\n\t\t\t\t\"MIPI IO Port is not powergated\\n\");\n\t}\n}\n\nstatic void glk_dsi_disable_mipi_io(struct intel_encoder *encoder)\n{\n\tstruct drm_i915_private *dev_priv = to_i915(encoder->base.dev);\n\tstruct intel_dsi *intel_dsi = enc_to_intel_dsi(encoder);\n\tenum port port;\n\n\t \n\tintel_de_rmw(dev_priv, MIPI_CTRL(PORT_A), GLK_MIPIIO_RESET_RELEASED, 0);\n\n\t \n\tfor_each_dsi_port(port, intel_dsi->ports) {\n\t\tif (intel_de_wait_for_clear(dev_priv, MIPI_CTRL(port),\n\t\t\t\t\t    GLK_PHY_STATUS_PORT_READY, 20))\n\t\t\tdrm_err(&dev_priv->drm, \"PHY is not turning OFF\\n\");\n\t}\n\n\t \n\tfor_each_dsi_port(port, intel_dsi->ports)\n\t\tintel_de_rmw(dev_priv, MIPI_CTRL(port), GLK_MIPIIO_ENABLE, 0);\n}\n\nstatic void glk_dsi_clear_device_ready(struct intel_encoder *encoder)\n{\n\tglk_dsi_enter_low_power_mode(encoder);\n\tglk_dsi_disable_mipi_io(encoder);\n}\n\nstatic void vlv_dsi_clear_device_ready(struct intel_encoder *encoder)\n{\n\tstruct drm_i915_private *dev_priv = to_i915(encoder->base.dev);\n\tstruct intel_dsi *intel_dsi = enc_to_intel_dsi(encoder);\n\tenum port port;\n\n\tdrm_dbg_kms(&dev_priv->drm, \"\\n\");\n\tfor_each_dsi_port(port, intel_dsi->ports) {\n\t\t \n\t\ti915_reg_t port_ctrl = IS_GEMINILAKE(dev_priv) || IS_BROXTON(dev_priv) ?\n\t\t\tBXT_MIPI_PORT_CTRL(port) : MIPI_PORT_CTRL(PORT_A);\n\n\t\tintel_de_write(dev_priv, MIPI_DEVICE_READY(port),\n\t\t\t       DEVICE_READY | ULPS_STATE_ENTER);\n\t\tusleep_range(2000, 2500);\n\n\t\tintel_de_write(dev_priv, MIPI_DEVICE_READY(port),\n\t\t\t       DEVICE_READY | ULPS_STATE_EXIT);\n\t\tusleep_range(2000, 2500);\n\n\t\tintel_de_write(dev_priv, MIPI_DEVICE_READY(port),\n\t\t\t       DEVICE_READY | ULPS_STATE_ENTER);\n\t\tusleep_range(2000, 2500);\n\n\t\t \n\t\tif ((IS_GEMINILAKE(dev_priv) || IS_BROXTON(dev_priv) || port == PORT_A) &&\n\t\t    intel_de_wait_for_clear(dev_priv, port_ctrl,\n\t\t\t\t\t    AFE_LATCHOUT, 30))\n\t\t\tdrm_err(&dev_priv->drm, \"DSI LP not going Low\\n\");\n\n\t\t \n\t\tintel_de_rmw(dev_priv, port_ctrl, LP_OUTPUT_HOLD, 0);\n\t\tusleep_range(1000, 1500);\n\n\t\tintel_de_write(dev_priv, MIPI_DEVICE_READY(port), 0x00);\n\t\tusleep_range(2000, 2500);\n\t}\n}\n\nstatic void intel_dsi_port_enable(struct intel_encoder *encoder,\n\t\t\t\t  const struct intel_crtc_state *crtc_state)\n{\n\tstruct drm_i915_private *dev_priv = to_i915(encoder->base.dev);\n\tstruct intel_crtc *crtc = to_intel_crtc(crtc_state->uapi.crtc);\n\tstruct intel_dsi *intel_dsi = enc_to_intel_dsi(encoder);\n\tenum port port;\n\n\tif (intel_dsi->dual_link == DSI_DUAL_LINK_FRONT_BACK) {\n\t\tu32 temp = intel_dsi->pixel_overlap;\n\n\t\tif (IS_GEMINILAKE(dev_priv) || IS_BROXTON(dev_priv)) {\n\t\t\tfor_each_dsi_port(port, intel_dsi->ports)\n\t\t\t\tintel_de_rmw(dev_priv, MIPI_CTRL(port),\n\t\t\t\t\t     BXT_PIXEL_OVERLAP_CNT_MASK,\n\t\t\t\t\t     temp << BXT_PIXEL_OVERLAP_CNT_SHIFT);\n\t\t} else {\n\t\t\tintel_de_rmw(dev_priv, VLV_CHICKEN_3,\n\t\t\t\t     PIXEL_OVERLAP_CNT_MASK,\n\t\t\t\t     temp << PIXEL_OVERLAP_CNT_SHIFT);\n\t\t}\n\t}\n\n\tfor_each_dsi_port(port, intel_dsi->ports) {\n\t\ti915_reg_t port_ctrl = IS_GEMINILAKE(dev_priv) || IS_BROXTON(dev_priv) ?\n\t\t\tBXT_MIPI_PORT_CTRL(port) : MIPI_PORT_CTRL(port);\n\t\tu32 temp;\n\n\t\ttemp = intel_de_read(dev_priv, port_ctrl);\n\n\t\ttemp &= ~LANE_CONFIGURATION_MASK;\n\t\ttemp &= ~DUAL_LINK_MODE_MASK;\n\n\t\tif (intel_dsi->ports == (BIT(PORT_A) | BIT(PORT_C))) {\n\t\t\ttemp |= (intel_dsi->dual_link - 1)\n\t\t\t\t\t\t<< DUAL_LINK_MODE_SHIFT;\n\t\t\tif (IS_BROXTON(dev_priv))\n\t\t\t\ttemp |= LANE_CONFIGURATION_DUAL_LINK_A;\n\t\t\telse\n\t\t\t\ttemp |= crtc->pipe ?\n\t\t\t\t\tLANE_CONFIGURATION_DUAL_LINK_B :\n\t\t\t\t\tLANE_CONFIGURATION_DUAL_LINK_A;\n\t\t}\n\n\t\tif (intel_dsi->pixel_format != MIPI_DSI_FMT_RGB888)\n\t\t\ttemp |= DITHERING_ENABLE;\n\n\t\t \n\t\tintel_de_write(dev_priv, port_ctrl, temp | DPI_ENABLE);\n\t\tintel_de_posting_read(dev_priv, port_ctrl);\n\t}\n}\n\nstatic void intel_dsi_port_disable(struct intel_encoder *encoder)\n{\n\tstruct drm_device *dev = encoder->base.dev;\n\tstruct drm_i915_private *dev_priv = to_i915(dev);\n\tstruct intel_dsi *intel_dsi = enc_to_intel_dsi(encoder);\n\tenum port port;\n\n\tfor_each_dsi_port(port, intel_dsi->ports) {\n\t\ti915_reg_t port_ctrl = IS_GEMINILAKE(dev_priv) || IS_BROXTON(dev_priv) ?\n\t\t\tBXT_MIPI_PORT_CTRL(port) : MIPI_PORT_CTRL(port);\n\n\t\t \n\t\tintel_de_rmw(dev_priv, port_ctrl, DPI_ENABLE, 0);\n\t\tintel_de_posting_read(dev_priv, port_ctrl);\n\t}\n}\nstatic void intel_dsi_prepare(struct intel_encoder *intel_encoder,\n\t\t\t      const struct intel_crtc_state *pipe_config);\nstatic void intel_dsi_unprepare(struct intel_encoder *encoder);\n\n \n\n \nstatic void intel_dsi_pre_enable(struct intel_atomic_state *state,\n\t\t\t\t struct intel_encoder *encoder,\n\t\t\t\t const struct intel_crtc_state *pipe_config,\n\t\t\t\t const struct drm_connector_state *conn_state)\n{\n\tstruct intel_dsi *intel_dsi = enc_to_intel_dsi(encoder);\n\tstruct intel_crtc *crtc = to_intel_crtc(pipe_config->uapi.crtc);\n\tstruct drm_i915_private *dev_priv = to_i915(crtc->base.dev);\n\tenum pipe pipe = crtc->pipe;\n\tenum port port;\n\tbool glk_cold_boot = false;\n\n\tdrm_dbg_kms(&dev_priv->drm, \"\\n\");\n\n\tintel_dsi_wait_panel_power_cycle(intel_dsi);\n\n\tintel_set_cpu_fifo_underrun_reporting(dev_priv, pipe, true);\n\n\t \n\tif (IS_GEMINILAKE(dev_priv) || IS_BROXTON(dev_priv)) {\n\t\tbxt_dsi_pll_disable(encoder);\n\t\tbxt_dsi_pll_enable(encoder, pipe_config);\n\t} else {\n\t\tvlv_dsi_pll_disable(encoder);\n\t\tvlv_dsi_pll_enable(encoder, pipe_config);\n\t}\n\n\tif (IS_BROXTON(dev_priv)) {\n\t\t \n\t\tintel_de_rmw(dev_priv, BXT_P_CR_GT_DISP_PWRON, 0, MIPIO_RST_CTRL);\n\n\t\t \n\t\tintel_de_write(dev_priv, BXT_P_DSI_REGULATOR_CFG, STAP_SELECT);\n\t\tintel_de_write(dev_priv, BXT_P_DSI_REGULATOR_TX_CTRL, 0);\n\t}\n\n\tif (IS_VALLEYVIEW(dev_priv) || IS_CHERRYVIEW(dev_priv)) {\n\t\t \n\t\tintel_de_rmw(dev_priv, DSPCLK_GATE_D(dev_priv),\n\t\t\t     0, DPOUNIT_CLOCK_GATE_DISABLE);\n\t}\n\n\tif (!IS_GEMINILAKE(dev_priv))\n\t\tintel_dsi_prepare(encoder, pipe_config);\n\n\t \n\tintel_dsi_vbt_exec_sequence(intel_dsi, MIPI_SEQ_POWER_ON);\n\tmsleep(intel_dsi->panel_on_delay);\n\tintel_dsi_vbt_exec_sequence(intel_dsi, MIPI_SEQ_DEASSERT_RESET);\n\n\tif (IS_GEMINILAKE(dev_priv)) {\n\t\tglk_cold_boot = glk_dsi_enable_io(encoder);\n\n\t\t \n\t\tif (glk_cold_boot)\n\t\t\tintel_dsi_prepare(encoder, pipe_config);\n\t}\n\n\t \n\tintel_dsi_device_ready(encoder);\n\n\t \n\tif (IS_GEMINILAKE(dev_priv) && !glk_cold_boot)\n\t\tintel_dsi_prepare(encoder, pipe_config);\n\n\t \n\tintel_dsi_vbt_exec_sequence(intel_dsi, MIPI_SEQ_INIT_OTP);\n\n\t \n\tif (is_cmd_mode(intel_dsi)) {\n\t\tfor_each_dsi_port(port, intel_dsi->ports)\n\t\t\tintel_de_write(dev_priv,\n\t\t\t\t       MIPI_MAX_RETURN_PKT_SIZE(port), 8 * 4);\n\t\tintel_dsi_vbt_exec_sequence(intel_dsi, MIPI_SEQ_TEAR_ON);\n\t\tintel_dsi_vbt_exec_sequence(intel_dsi, MIPI_SEQ_DISPLAY_ON);\n\t} else {\n\t\tmsleep(20);  \n\t\tfor_each_dsi_port(port, intel_dsi->ports)\n\t\t\tdpi_send_cmd(intel_dsi, TURN_ON, false, port);\n\t\tmsleep(100);\n\n\t\tintel_dsi_vbt_exec_sequence(intel_dsi, MIPI_SEQ_DISPLAY_ON);\n\n\t\tintel_dsi_port_enable(encoder, pipe_config);\n\t}\n\n\tintel_backlight_enable(pipe_config, conn_state);\n\tintel_dsi_vbt_exec_sequence(intel_dsi, MIPI_SEQ_BACKLIGHT_ON);\n}\n\nstatic void bxt_dsi_enable(struct intel_atomic_state *state,\n\t\t\t   struct intel_encoder *encoder,\n\t\t\t   const struct intel_crtc_state *crtc_state,\n\t\t\t   const struct drm_connector_state *conn_state)\n{\n\tintel_crtc_vblank_on(crtc_state);\n}\n\n \nstatic void intel_dsi_disable(struct intel_atomic_state *state,\n\t\t\t      struct intel_encoder *encoder,\n\t\t\t      const struct intel_crtc_state *old_crtc_state,\n\t\t\t      const struct drm_connector_state *old_conn_state)\n{\n\tstruct drm_i915_private *i915 = to_i915(encoder->base.dev);\n\tstruct intel_dsi *intel_dsi = enc_to_intel_dsi(encoder);\n\tenum port port;\n\n\tdrm_dbg_kms(&i915->drm, \"\\n\");\n\n\tintel_dsi_vbt_exec_sequence(intel_dsi, MIPI_SEQ_BACKLIGHT_OFF);\n\tintel_backlight_disable(old_conn_state);\n\n\t \n\tif (is_vid_mode(intel_dsi)) {\n\t\t \n\t\tfor_each_dsi_port(port, intel_dsi->ports)\n\t\t\tdpi_send_cmd(intel_dsi, SHUTDOWN, false, port);\n\t\tmsleep(10);\n\t}\n}\n\nstatic void intel_dsi_clear_device_ready(struct intel_encoder *encoder)\n{\n\tstruct drm_i915_private *dev_priv = to_i915(encoder->base.dev);\n\n\tif (IS_GEMINILAKE(dev_priv))\n\t\tglk_dsi_clear_device_ready(encoder);\n\telse\n\t\tvlv_dsi_clear_device_ready(encoder);\n}\n\nstatic void intel_dsi_post_disable(struct intel_atomic_state *state,\n\t\t\t\t   struct intel_encoder *encoder,\n\t\t\t\t   const struct intel_crtc_state *old_crtc_state,\n\t\t\t\t   const struct drm_connector_state *old_conn_state)\n{\n\tstruct drm_i915_private *dev_priv = to_i915(encoder->base.dev);\n\tstruct intel_dsi *intel_dsi = enc_to_intel_dsi(encoder);\n\tenum port port;\n\n\tdrm_dbg_kms(&dev_priv->drm, \"\\n\");\n\n\tif (IS_GEMINILAKE(dev_priv) || IS_BROXTON(dev_priv)) {\n\t\tintel_crtc_vblank_off(old_crtc_state);\n\n\t\tskl_scaler_disable(old_crtc_state);\n\t}\n\n\tif (is_vid_mode(intel_dsi)) {\n\t\tfor_each_dsi_port(port, intel_dsi->ports)\n\t\t\tvlv_dsi_wait_for_fifo_empty(intel_dsi, port);\n\n\t\tintel_dsi_port_disable(encoder);\n\t\tusleep_range(2000, 5000);\n\t}\n\n\tintel_dsi_unprepare(encoder);\n\n\t \n\tif (is_cmd_mode(intel_dsi))\n\t\tintel_dsi_vbt_exec_sequence(intel_dsi, MIPI_SEQ_TEAR_OFF);\n\tintel_dsi_vbt_exec_sequence(intel_dsi, MIPI_SEQ_DISPLAY_OFF);\n\n\t \n\tintel_dsi_clear_device_ready(encoder);\n\n\tif (IS_BROXTON(dev_priv)) {\n\t\t \n\t\tintel_de_write(dev_priv, BXT_P_DSI_REGULATOR_CFG, STAP_SELECT);\n\t\tintel_de_write(dev_priv, BXT_P_DSI_REGULATOR_TX_CTRL,\n\t\t\t       HS_IO_CTRL_SELECT);\n\n\t\t \n\t\tintel_de_rmw(dev_priv, BXT_P_CR_GT_DISP_PWRON, MIPIO_RST_CTRL, 0);\n\t}\n\n\tif (IS_GEMINILAKE(dev_priv) || IS_BROXTON(dev_priv)) {\n\t\tbxt_dsi_pll_disable(encoder);\n\t} else {\n\t\tvlv_dsi_pll_disable(encoder);\n\n\t\tintel_de_rmw(dev_priv, DSPCLK_GATE_D(dev_priv),\n\t\t\t     DPOUNIT_CLOCK_GATE_DISABLE, 0);\n\t}\n\n\t \n\tintel_dsi_vbt_exec_sequence(intel_dsi, MIPI_SEQ_ASSERT_RESET);\n\n\tmsleep(intel_dsi->panel_off_delay);\n\tintel_dsi_vbt_exec_sequence(intel_dsi, MIPI_SEQ_POWER_OFF);\n\n\tintel_dsi->panel_power_off_time = ktime_get_boottime();\n}\n\nstatic bool intel_dsi_get_hw_state(struct intel_encoder *encoder,\n\t\t\t\t   enum pipe *pipe)\n{\n\tstruct drm_i915_private *dev_priv = to_i915(encoder->base.dev);\n\tstruct intel_dsi *intel_dsi = enc_to_intel_dsi(encoder);\n\tintel_wakeref_t wakeref;\n\tenum port port;\n\tbool active = false;\n\n\tdrm_dbg_kms(&dev_priv->drm, \"\\n\");\n\n\twakeref = intel_display_power_get_if_enabled(dev_priv,\n\t\t\t\t\t\t     encoder->power_domain);\n\tif (!wakeref)\n\t\treturn false;\n\n\t \n\tif ((IS_GEMINILAKE(dev_priv) || IS_BROXTON(dev_priv)) &&\n\t    !bxt_dsi_pll_is_enabled(dev_priv))\n\t\tgoto out_put_power;\n\n\t \n\tfor_each_dsi_port(port, intel_dsi->ports) {\n\t\ti915_reg_t ctrl_reg = IS_GEMINILAKE(dev_priv) || IS_BROXTON(dev_priv) ?\n\t\t\tBXT_MIPI_PORT_CTRL(port) : MIPI_PORT_CTRL(port);\n\t\tbool enabled = intel_de_read(dev_priv, ctrl_reg) & DPI_ENABLE;\n\n\t\t \n\t\tif ((IS_VALLEYVIEW(dev_priv) || IS_CHERRYVIEW(dev_priv)) &&\n\t\t    port == PORT_C)\n\t\t\tenabled = intel_de_read(dev_priv, TRANSCONF(PIPE_B)) & TRANSCONF_ENABLE;\n\n\t\t \n\t\tif (!enabled) {\n\t\t\tu32 tmp = intel_de_read(dev_priv,\n\t\t\t\t\t\tMIPI_DSI_FUNC_PRG(port));\n\t\t\tenabled = tmp & CMD_MODE_DATA_WIDTH_MASK;\n\t\t}\n\n\t\tif (!enabled)\n\t\t\tcontinue;\n\n\t\tif (!(intel_de_read(dev_priv, MIPI_DEVICE_READY(port)) & DEVICE_READY))\n\t\t\tcontinue;\n\n\t\tif (IS_GEMINILAKE(dev_priv) || IS_BROXTON(dev_priv)) {\n\t\t\tu32 tmp = intel_de_read(dev_priv, MIPI_CTRL(port));\n\t\t\ttmp &= BXT_PIPE_SELECT_MASK;\n\t\t\ttmp >>= BXT_PIPE_SELECT_SHIFT;\n\n\t\t\tif (drm_WARN_ON(&dev_priv->drm, tmp > PIPE_C))\n\t\t\t\tcontinue;\n\n\t\t\t*pipe = tmp;\n\t\t} else {\n\t\t\t*pipe = port == PORT_A ? PIPE_A : PIPE_B;\n\t\t}\n\n\t\tactive = true;\n\t\tbreak;\n\t}\n\nout_put_power:\n\tintel_display_power_put(dev_priv, encoder->power_domain, wakeref);\n\n\treturn active;\n}\n\nstatic void bxt_dsi_get_pipe_config(struct intel_encoder *encoder,\n\t\t\t\t    struct intel_crtc_state *pipe_config)\n{\n\tstruct drm_device *dev = encoder->base.dev;\n\tstruct drm_i915_private *dev_priv = to_i915(dev);\n\tstruct drm_display_mode *adjusted_mode =\n\t\t\t\t\t&pipe_config->hw.adjusted_mode;\n\tstruct drm_display_mode *adjusted_mode_sw;\n\tstruct intel_crtc *crtc = to_intel_crtc(pipe_config->uapi.crtc);\n\tstruct intel_dsi *intel_dsi = enc_to_intel_dsi(encoder);\n\tunsigned int lane_count = intel_dsi->lane_count;\n\tunsigned int bpp, fmt;\n\tenum port port;\n\tu16 hactive, hfp, hsync, hbp, vfp, vsync;\n\tu16 hfp_sw, hsync_sw, hbp_sw;\n\tu16 crtc_htotal_sw, crtc_hsync_start_sw, crtc_hsync_end_sw,\n\t\t\t\tcrtc_hblank_start_sw, crtc_hblank_end_sw;\n\n\t \n\tadjusted_mode_sw = &crtc->config->hw.adjusted_mode;\n\n\t \n\tfor_each_dsi_port(port, intel_dsi->ports) {\n\t\tif (intel_de_read(dev_priv, BXT_MIPI_PORT_CTRL(port)) & DPI_ENABLE)\n\t\t\tbreak;\n\t}\n\n\tfmt = intel_de_read(dev_priv, MIPI_DSI_FUNC_PRG(port)) & VID_MODE_FORMAT_MASK;\n\tbpp = mipi_dsi_pixel_format_to_bpp(\n\t\t\tpixel_format_from_register_bits(fmt));\n\n\tpipe_config->pipe_bpp = bdw_get_pipe_misc_bpp(crtc);\n\n\t \n\tpipe_config->mode_flags |=\n\t\tI915_MODE_FLAG_GET_SCANLINE_FROM_TIMESTAMP;\n\n\t \n\tadjusted_mode->crtc_hdisplay =\n\t\t\t\tintel_de_read(dev_priv,\n\t\t\t\t              BXT_MIPI_TRANS_HACTIVE(port));\n\tadjusted_mode->crtc_vdisplay =\n\t\t\t\tintel_de_read(dev_priv,\n\t\t\t\t              BXT_MIPI_TRANS_VACTIVE(port));\n\tadjusted_mode->crtc_vtotal =\n\t\t\t\tintel_de_read(dev_priv,\n\t\t\t\t              BXT_MIPI_TRANS_VTOTAL(port));\n\n\thactive = adjusted_mode->crtc_hdisplay;\n\thfp = intel_de_read(dev_priv, MIPI_HFP_COUNT(port));\n\n\t \n\thsync = intel_de_read(dev_priv, MIPI_HSYNC_PADDING_COUNT(port));\n\thbp = intel_de_read(dev_priv, MIPI_HBP_COUNT(port));\n\n\t \n\thfp = pixels_from_txbyteclkhs(hfp, bpp, lane_count,\n\t\t\t\t\t\tintel_dsi->burst_mode_ratio);\n\thsync = pixels_from_txbyteclkhs(hsync, bpp, lane_count,\n\t\t\t\t\t\tintel_dsi->burst_mode_ratio);\n\thbp = pixels_from_txbyteclkhs(hbp, bpp, lane_count,\n\t\t\t\t\t\tintel_dsi->burst_mode_ratio);\n\n\tif (intel_dsi->dual_link) {\n\t\thfp *= 2;\n\t\thsync *= 2;\n\t\thbp *= 2;\n\t}\n\n\t \n\tvfp = intel_de_read(dev_priv, MIPI_VFP_COUNT(port));\n\tvsync = intel_de_read(dev_priv, MIPI_VSYNC_PADDING_COUNT(port));\n\n\tadjusted_mode->crtc_htotal = hactive + hfp + hsync + hbp;\n\tadjusted_mode->crtc_hsync_start = hfp + adjusted_mode->crtc_hdisplay;\n\tadjusted_mode->crtc_hsync_end = hsync + adjusted_mode->crtc_hsync_start;\n\tadjusted_mode->crtc_hblank_start = adjusted_mode->crtc_hdisplay;\n\tadjusted_mode->crtc_hblank_end = adjusted_mode->crtc_htotal;\n\n\tadjusted_mode->crtc_vsync_start = vfp + adjusted_mode->crtc_vdisplay;\n\tadjusted_mode->crtc_vsync_end = vsync + adjusted_mode->crtc_vsync_start;\n\tadjusted_mode->crtc_vblank_start = adjusted_mode->crtc_vdisplay;\n\tadjusted_mode->crtc_vblank_end = adjusted_mode->crtc_vtotal;\n\n\t \n\t \n\thfp_sw = adjusted_mode_sw->crtc_hsync_start -\n\t\t\t\t\tadjusted_mode_sw->crtc_hdisplay;\n\thsync_sw = adjusted_mode_sw->crtc_hsync_end -\n\t\t\t\t\tadjusted_mode_sw->crtc_hsync_start;\n\thbp_sw = adjusted_mode_sw->crtc_htotal -\n\t\t\t\t\tadjusted_mode_sw->crtc_hsync_end;\n\n\tif (intel_dsi->dual_link) {\n\t\thfp_sw /= 2;\n\t\thsync_sw /= 2;\n\t\thbp_sw /= 2;\n\t}\n\n\thfp_sw = txbyteclkhs(hfp_sw, bpp, lane_count,\n\t\t\t\t\t\tintel_dsi->burst_mode_ratio);\n\thsync_sw = txbyteclkhs(hsync_sw, bpp, lane_count,\n\t\t\t    intel_dsi->burst_mode_ratio);\n\thbp_sw = txbyteclkhs(hbp_sw, bpp, lane_count,\n\t\t\t\t\t\tintel_dsi->burst_mode_ratio);\n\n\t \n\thfp_sw = pixels_from_txbyteclkhs(hfp_sw, bpp, lane_count,\n\t\t\t\t\t\tintel_dsi->burst_mode_ratio);\n\thsync_sw = pixels_from_txbyteclkhs(hsync_sw, bpp, lane_count,\n\t\t\t\t\t\tintel_dsi->burst_mode_ratio);\n\thbp_sw = pixels_from_txbyteclkhs(hbp_sw, bpp, lane_count,\n\t\t\t\t\t\tintel_dsi->burst_mode_ratio);\n\n\tif (intel_dsi->dual_link) {\n\t\thfp_sw *= 2;\n\t\thsync_sw *= 2;\n\t\thbp_sw *= 2;\n\t}\n\n\tcrtc_htotal_sw = adjusted_mode_sw->crtc_hdisplay + hfp_sw +\n\t\t\t\t\t\t\thsync_sw + hbp_sw;\n\tcrtc_hsync_start_sw = hfp_sw + adjusted_mode_sw->crtc_hdisplay;\n\tcrtc_hsync_end_sw = hsync_sw + crtc_hsync_start_sw;\n\tcrtc_hblank_start_sw = adjusted_mode_sw->crtc_hdisplay;\n\tcrtc_hblank_end_sw = crtc_htotal_sw;\n\n\tif (adjusted_mode->crtc_htotal == crtc_htotal_sw)\n\t\tadjusted_mode->crtc_htotal = adjusted_mode_sw->crtc_htotal;\n\n\tif (adjusted_mode->crtc_hsync_start == crtc_hsync_start_sw)\n\t\tadjusted_mode->crtc_hsync_start =\n\t\t\t\t\tadjusted_mode_sw->crtc_hsync_start;\n\n\tif (adjusted_mode->crtc_hsync_end == crtc_hsync_end_sw)\n\t\tadjusted_mode->crtc_hsync_end =\n\t\t\t\t\tadjusted_mode_sw->crtc_hsync_end;\n\n\tif (adjusted_mode->crtc_hblank_start == crtc_hblank_start_sw)\n\t\tadjusted_mode->crtc_hblank_start =\n\t\t\t\t\tadjusted_mode_sw->crtc_hblank_start;\n\n\tif (adjusted_mode->crtc_hblank_end == crtc_hblank_end_sw)\n\t\tadjusted_mode->crtc_hblank_end =\n\t\t\t\t\tadjusted_mode_sw->crtc_hblank_end;\n}\n\nstatic void intel_dsi_get_config(struct intel_encoder *encoder,\n\t\t\t\t struct intel_crtc_state *pipe_config)\n{\n\tstruct drm_i915_private *dev_priv = to_i915(encoder->base.dev);\n\tstruct intel_dsi *intel_dsi = enc_to_intel_dsi(encoder);\n\tu32 pclk;\n\n\tdrm_dbg_kms(&dev_priv->drm, \"\\n\");\n\n\tpipe_config->output_types |= BIT(INTEL_OUTPUT_DSI);\n\n\tif (IS_GEMINILAKE(dev_priv) || IS_BROXTON(dev_priv)) {\n\t\tbxt_dsi_get_pipe_config(encoder, pipe_config);\n\t\tpclk = bxt_dsi_get_pclk(encoder, pipe_config);\n\t} else {\n\t\tpclk = vlv_dsi_get_pclk(encoder, pipe_config);\n\t}\n\n\tpipe_config->port_clock = pclk;\n\n\t \n\tpipe_config->hw.adjusted_mode.crtc_clock = pclk;\n\tif (intel_dsi->dual_link)\n\t\tpipe_config->hw.adjusted_mode.crtc_clock *= 2;\n}\n\n \nstatic u16 txclkesc(u32 divider, unsigned int us)\n{\n\tswitch (divider) {\n\tcase ESCAPE_CLOCK_DIVIDER_1:\n\tdefault:\n\t\treturn 20 * us;\n\tcase ESCAPE_CLOCK_DIVIDER_2:\n\t\treturn 10 * us;\n\tcase ESCAPE_CLOCK_DIVIDER_4:\n\t\treturn 5 * us;\n\t}\n}\n\nstatic void set_dsi_timings(struct drm_encoder *encoder,\n\t\t\t    const struct drm_display_mode *adjusted_mode)\n{\n\tstruct drm_device *dev = encoder->dev;\n\tstruct drm_i915_private *dev_priv = to_i915(dev);\n\tstruct intel_dsi *intel_dsi = enc_to_intel_dsi(to_intel_encoder(encoder));\n\tenum port port;\n\tunsigned int bpp = mipi_dsi_pixel_format_to_bpp(intel_dsi->pixel_format);\n\tunsigned int lane_count = intel_dsi->lane_count;\n\n\tu16 hactive, hfp, hsync, hbp, vfp, vsync, vbp;\n\n\thactive = adjusted_mode->crtc_hdisplay;\n\thfp = adjusted_mode->crtc_hsync_start - adjusted_mode->crtc_hdisplay;\n\thsync = adjusted_mode->crtc_hsync_end - adjusted_mode->crtc_hsync_start;\n\thbp = adjusted_mode->crtc_htotal - adjusted_mode->crtc_hsync_end;\n\n\tif (intel_dsi->dual_link) {\n\t\thactive /= 2;\n\t\tif (intel_dsi->dual_link == DSI_DUAL_LINK_FRONT_BACK)\n\t\t\thactive += intel_dsi->pixel_overlap;\n\t\thfp /= 2;\n\t\thsync /= 2;\n\t\thbp /= 2;\n\t}\n\n\tvfp = adjusted_mode->crtc_vsync_start - adjusted_mode->crtc_vdisplay;\n\tvsync = adjusted_mode->crtc_vsync_end - adjusted_mode->crtc_vsync_start;\n\tvbp = adjusted_mode->crtc_vtotal - adjusted_mode->crtc_vsync_end;\n\n\t \n\thactive = txbyteclkhs(hactive, bpp, lane_count,\n\t\t\t      intel_dsi->burst_mode_ratio);\n\thfp = txbyteclkhs(hfp, bpp, lane_count, intel_dsi->burst_mode_ratio);\n\thsync = txbyteclkhs(hsync, bpp, lane_count,\n\t\t\t    intel_dsi->burst_mode_ratio);\n\thbp = txbyteclkhs(hbp, bpp, lane_count, intel_dsi->burst_mode_ratio);\n\n\tfor_each_dsi_port(port, intel_dsi->ports) {\n\t\tif (IS_GEMINILAKE(dev_priv) || IS_BROXTON(dev_priv)) {\n\t\t\t \n\t\t\tintel_de_write(dev_priv, BXT_MIPI_TRANS_HACTIVE(port),\n\t\t\t\t       adjusted_mode->crtc_hdisplay);\n\t\t\tintel_de_write(dev_priv, BXT_MIPI_TRANS_VACTIVE(port),\n\t\t\t\t       adjusted_mode->crtc_vdisplay);\n\t\t\tintel_de_write(dev_priv, BXT_MIPI_TRANS_VTOTAL(port),\n\t\t\t\t       adjusted_mode->crtc_vtotal);\n\t\t}\n\n\t\tintel_de_write(dev_priv, MIPI_HACTIVE_AREA_COUNT(port),\n\t\t\t       hactive);\n\t\tintel_de_write(dev_priv, MIPI_HFP_COUNT(port), hfp);\n\n\t\t \n\t\tintel_de_write(dev_priv, MIPI_HSYNC_PADDING_COUNT(port),\n\t\t\t       hsync);\n\t\tintel_de_write(dev_priv, MIPI_HBP_COUNT(port), hbp);\n\n\t\t \n\t\tintel_de_write(dev_priv, MIPI_VFP_COUNT(port), vfp);\n\t\tintel_de_write(dev_priv, MIPI_VSYNC_PADDING_COUNT(port),\n\t\t\t       vsync);\n\t\tintel_de_write(dev_priv, MIPI_VBP_COUNT(port), vbp);\n\t}\n}\n\nstatic u32 pixel_format_to_reg(enum mipi_dsi_pixel_format fmt)\n{\n\tswitch (fmt) {\n\tcase MIPI_DSI_FMT_RGB888:\n\t\treturn VID_MODE_FORMAT_RGB888;\n\tcase MIPI_DSI_FMT_RGB666:\n\t\treturn VID_MODE_FORMAT_RGB666;\n\tcase MIPI_DSI_FMT_RGB666_PACKED:\n\t\treturn VID_MODE_FORMAT_RGB666_PACKED;\n\tcase MIPI_DSI_FMT_RGB565:\n\t\treturn VID_MODE_FORMAT_RGB565;\n\tdefault:\n\t\tMISSING_CASE(fmt);\n\t\treturn VID_MODE_FORMAT_RGB666;\n\t}\n}\n\nstatic void intel_dsi_prepare(struct intel_encoder *intel_encoder,\n\t\t\t      const struct intel_crtc_state *pipe_config)\n{\n\tstruct drm_encoder *encoder = &intel_encoder->base;\n\tstruct drm_device *dev = encoder->dev;\n\tstruct drm_i915_private *dev_priv = to_i915(dev);\n\tstruct intel_crtc *crtc = to_intel_crtc(pipe_config->uapi.crtc);\n\tstruct intel_dsi *intel_dsi = enc_to_intel_dsi(to_intel_encoder(encoder));\n\tconst struct drm_display_mode *adjusted_mode = &pipe_config->hw.adjusted_mode;\n\tenum port port;\n\tunsigned int bpp = mipi_dsi_pixel_format_to_bpp(intel_dsi->pixel_format);\n\tu32 val, tmp;\n\tu16 mode_hdisplay;\n\n\tdrm_dbg_kms(&dev_priv->drm, \"pipe %c\\n\", pipe_name(crtc->pipe));\n\n\tmode_hdisplay = adjusted_mode->crtc_hdisplay;\n\n\tif (intel_dsi->dual_link) {\n\t\tmode_hdisplay /= 2;\n\t\tif (intel_dsi->dual_link == DSI_DUAL_LINK_FRONT_BACK)\n\t\t\tmode_hdisplay += intel_dsi->pixel_overlap;\n\t}\n\n\tfor_each_dsi_port(port, intel_dsi->ports) {\n\t\tif (IS_VALLEYVIEW(dev_priv) || IS_CHERRYVIEW(dev_priv)) {\n\t\t\t \n\t\t\ttmp = intel_de_read(dev_priv, MIPI_CTRL(PORT_A));\n\t\t\ttmp &= ~ESCAPE_CLOCK_DIVIDER_MASK;\n\t\t\tintel_de_write(dev_priv, MIPI_CTRL(PORT_A),\n\t\t\t\t       tmp | ESCAPE_CLOCK_DIVIDER_1);\n\n\t\t\t \n\t\t\ttmp = intel_de_read(dev_priv, MIPI_CTRL(port));\n\t\t\ttmp &= ~READ_REQUEST_PRIORITY_MASK;\n\t\t\tintel_de_write(dev_priv, MIPI_CTRL(port),\n\t\t\t\t       tmp | READ_REQUEST_PRIORITY_HIGH);\n\t\t} else if (IS_GEMINILAKE(dev_priv) || IS_BROXTON(dev_priv)) {\n\t\t\tenum pipe pipe = crtc->pipe;\n\n\t\t\tintel_de_rmw(dev_priv, MIPI_CTRL(port),\n\t\t\t\t     BXT_PIPE_SELECT_MASK, BXT_PIPE_SELECT(pipe));\n\t\t}\n\n\t\t \n\t\tintel_de_write(dev_priv, MIPI_INTR_STAT(port), 0xffffffff);\n\t\tintel_de_write(dev_priv, MIPI_INTR_EN(port), 0xffffffff);\n\n\t\tintel_de_write(dev_priv, MIPI_DPHY_PARAM(port),\n\t\t\t       intel_dsi->dphy_reg);\n\n\t\tintel_de_write(dev_priv, MIPI_DPI_RESOLUTION(port),\n\t\t\t       adjusted_mode->crtc_vdisplay << VERTICAL_ADDRESS_SHIFT | mode_hdisplay << HORIZONTAL_ADDRESS_SHIFT);\n\t}\n\n\tset_dsi_timings(encoder, adjusted_mode);\n\n\tval = intel_dsi->lane_count << DATA_LANES_PRG_REG_SHIFT;\n\tif (is_cmd_mode(intel_dsi)) {\n\t\tval |= intel_dsi->channel << CMD_MODE_CHANNEL_NUMBER_SHIFT;\n\t\tval |= CMD_MODE_DATA_WIDTH_8_BIT;  \n\t} else {\n\t\tval |= intel_dsi->channel << VID_MODE_CHANNEL_NUMBER_SHIFT;\n\t\tval |= pixel_format_to_reg(intel_dsi->pixel_format);\n\t}\n\n\ttmp = 0;\n\tif (intel_dsi->eotp_pkt == 0)\n\t\ttmp |= EOT_DISABLE;\n\tif (intel_dsi->clock_stop)\n\t\ttmp |= CLOCKSTOP;\n\n\tif (IS_GEMINILAKE(dev_priv) || IS_BROXTON(dev_priv)) {\n\t\ttmp |= BXT_DPHY_DEFEATURE_EN;\n\t\tif (!is_cmd_mode(intel_dsi))\n\t\t\ttmp |= BXT_DEFEATURE_DPI_FIFO_CTR;\n\t}\n\n\tfor_each_dsi_port(port, intel_dsi->ports) {\n\t\tintel_de_write(dev_priv, MIPI_DSI_FUNC_PRG(port), val);\n\n\t\t \n\n\t\t \n\n\t\tif (is_vid_mode(intel_dsi) &&\n\t\t\tintel_dsi->video_mode == BURST_MODE) {\n\t\t\tintel_de_write(dev_priv, MIPI_HS_TX_TIMEOUT(port),\n\t\t\t\t       txbyteclkhs(adjusted_mode->crtc_htotal, bpp, intel_dsi->lane_count, intel_dsi->burst_mode_ratio) + 1);\n\t\t} else {\n\t\t\tintel_de_write(dev_priv, MIPI_HS_TX_TIMEOUT(port),\n\t\t\t\t       txbyteclkhs(adjusted_mode->crtc_vtotal * adjusted_mode->crtc_htotal, bpp, intel_dsi->lane_count, intel_dsi->burst_mode_ratio) + 1);\n\t\t}\n\t\tintel_de_write(dev_priv, MIPI_LP_RX_TIMEOUT(port),\n\t\t\t       intel_dsi->lp_rx_timeout);\n\t\tintel_de_write(dev_priv, MIPI_TURN_AROUND_TIMEOUT(port),\n\t\t\t       intel_dsi->turn_arnd_val);\n\t\tintel_de_write(dev_priv, MIPI_DEVICE_RESET_TIMER(port),\n\t\t\t       intel_dsi->rst_timer_val);\n\n\t\t \n\n\t\t \n\t\tintel_de_write(dev_priv, MIPI_INIT_COUNT(port),\n\t\t\t       txclkesc(intel_dsi->escape_clk_div, 100));\n\n\t\tif ((IS_GEMINILAKE(dev_priv) || IS_BROXTON(dev_priv)) &&\n\t\t    !intel_dsi->dual_link) {\n\t\t\t \n\t\t\tintel_de_write(dev_priv,\n\t\t\t\t       MIPI_INIT_COUNT(port == PORT_A ? PORT_C : PORT_A),\n\t\t\t\t       intel_dsi->init_count);\n\t\t}\n\n\t\t \n\t\tintel_de_write(dev_priv, MIPI_EOT_DISABLE(port), tmp);\n\n\t\t \n\t\tintel_de_write(dev_priv, MIPI_INIT_COUNT(port),\n\t\t\t       intel_dsi->init_count);\n\n\t\t \n\t\tintel_de_write(dev_priv, MIPI_HIGH_LOW_SWITCH_COUNT(port),\n\t\t\t       intel_dsi->hs_to_lp_count);\n\n\t\t \n\t\tintel_de_write(dev_priv, MIPI_LP_BYTECLK(port),\n\t\t\t       intel_dsi->lp_byte_clk);\n\n\t\tif (IS_GEMINILAKE(dev_priv)) {\n\t\t\tintel_de_write(dev_priv, MIPI_TLPX_TIME_COUNT(port),\n\t\t\t\t       intel_dsi->lp_byte_clk);\n\t\t\t \n\t\t\tintel_de_write(dev_priv, MIPI_CLK_LANE_TIMING(port),\n\t\t\t\t       intel_dsi->dphy_reg);\n\t\t}\n\n\t\t \n\t\tintel_de_write(dev_priv, MIPI_DBI_BW_CTRL(port),\n\t\t\t       intel_dsi->bw_timer);\n\n\t\tintel_de_write(dev_priv, MIPI_CLK_LANE_SWITCH_TIME_CNT(port),\n\t\t\t       intel_dsi->clk_lp_to_hs_count << LP_HS_SSW_CNT_SHIFT | intel_dsi->clk_hs_to_lp_count << HS_LP_PWR_SW_CNT_SHIFT);\n\n\t\tif (is_vid_mode(intel_dsi)) {\n\t\t\tu32 fmt = intel_dsi->video_frmt_cfg_bits | IP_TG_CONFIG;\n\n\t\t\t \n\t\t\tfmt |= RANDOM_DPI_DISPLAY_RESOLUTION;\n\n\t\t\tswitch (intel_dsi->video_mode) {\n\t\t\tdefault:\n\t\t\t\tMISSING_CASE(intel_dsi->video_mode);\n\t\t\t\tfallthrough;\n\t\t\tcase NON_BURST_SYNC_EVENTS:\n\t\t\t\tfmt |= VIDEO_MODE_NON_BURST_WITH_SYNC_EVENTS;\n\t\t\t\tbreak;\n\t\t\tcase NON_BURST_SYNC_PULSE:\n\t\t\t\tfmt |= VIDEO_MODE_NON_BURST_WITH_SYNC_PULSE;\n\t\t\t\tbreak;\n\t\t\tcase BURST_MODE:\n\t\t\t\tfmt |= VIDEO_MODE_BURST;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tintel_de_write(dev_priv, MIPI_VIDEO_MODE_FORMAT(port), fmt);\n\t\t}\n\t}\n}\n\nstatic void intel_dsi_unprepare(struct intel_encoder *encoder)\n{\n\tstruct drm_i915_private *dev_priv = to_i915(encoder->base.dev);\n\tstruct intel_dsi *intel_dsi = enc_to_intel_dsi(encoder);\n\tenum port port;\n\n\tif (IS_GEMINILAKE(dev_priv))\n\t\treturn;\n\n\tfor_each_dsi_port(port, intel_dsi->ports) {\n\t\t \n\t\tintel_de_write(dev_priv, MIPI_DEVICE_READY(port), 0x0);\n\n\t\tif (IS_GEMINILAKE(dev_priv) || IS_BROXTON(dev_priv))\n\t\t\tbxt_dsi_reset_clocks(encoder, port);\n\t\telse\n\t\t\tvlv_dsi_reset_clocks(encoder, port);\n\t\tintel_de_write(dev_priv, MIPI_EOT_DISABLE(port), CLOCKSTOP);\n\n\t\tintel_de_rmw(dev_priv, MIPI_DSI_FUNC_PRG(port), VID_MODE_FORMAT_MASK, 0);\n\n\t\tintel_de_write(dev_priv, MIPI_DEVICE_READY(port), 0x1);\n\t}\n}\n\nstatic void intel_dsi_encoder_destroy(struct drm_encoder *encoder)\n{\n\tstruct intel_dsi *intel_dsi = enc_to_intel_dsi(to_intel_encoder(encoder));\n\n\tintel_dsi_vbt_gpio_cleanup(intel_dsi);\n\tintel_encoder_destroy(encoder);\n}\n\nstatic const struct drm_encoder_funcs intel_dsi_funcs = {\n\t.destroy = intel_dsi_encoder_destroy,\n};\n\nstatic enum drm_mode_status vlv_dsi_mode_valid(struct drm_connector *connector,\n\t\t\t\t\t       struct drm_display_mode *mode)\n{\n\tstruct drm_i915_private *i915 = to_i915(connector->dev);\n\n\tif (IS_VALLEYVIEW(i915) || IS_CHERRYVIEW(i915)) {\n\t\tenum drm_mode_status status;\n\n\t\tstatus = intel_cpu_transcoder_mode_valid(i915, mode);\n\t\tif (status != MODE_OK)\n\t\t\treturn status;\n\t}\n\n\treturn intel_dsi_mode_valid(connector, mode);\n}\n\nstatic const struct drm_connector_helper_funcs intel_dsi_connector_helper_funcs = {\n\t.get_modes = intel_dsi_get_modes,\n\t.mode_valid = vlv_dsi_mode_valid,\n\t.atomic_check = intel_digital_connector_atomic_check,\n};\n\nstatic const struct drm_connector_funcs intel_dsi_connector_funcs = {\n\t.detect = intel_panel_detect,\n\t.late_register = intel_connector_register,\n\t.early_unregister = intel_connector_unregister,\n\t.destroy = intel_connector_destroy,\n\t.fill_modes = drm_helper_probe_single_connector_modes,\n\t.atomic_get_property = intel_digital_connector_atomic_get_property,\n\t.atomic_set_property = intel_digital_connector_atomic_set_property,\n\t.atomic_destroy_state = drm_atomic_helper_connector_destroy_state,\n\t.atomic_duplicate_state = intel_digital_connector_duplicate_state,\n};\n\nstatic void vlv_dsi_add_properties(struct intel_connector *connector)\n{\n\tconst struct drm_display_mode *fixed_mode =\n\t\tintel_panel_preferred_fixed_mode(connector);\n\n\tintel_attach_scaling_mode_property(&connector->base);\n\n\tdrm_connector_set_panel_orientation_with_quirk(&connector->base,\n\t\t\t\t\t\t       intel_dsi_get_panel_orientation(connector),\n\t\t\t\t\t\t       fixed_mode->hdisplay,\n\t\t\t\t\t\t       fixed_mode->vdisplay);\n}\n\n#define NS_KHZ_RATIO\t\t1000000\n\n#define PREPARE_CNT_MAX\t\t0x3F\n#define EXIT_ZERO_CNT_MAX\t0x3F\n#define CLK_ZERO_CNT_MAX\t0xFF\n#define TRAIL_CNT_MAX\t\t0x1F\n\nstatic void vlv_dphy_param_init(struct intel_dsi *intel_dsi)\n{\n\tstruct drm_device *dev = intel_dsi->base.base.dev;\n\tstruct drm_i915_private *dev_priv = to_i915(dev);\n\tstruct intel_connector *connector = intel_dsi->attached_connector;\n\tstruct mipi_config *mipi_config = connector->panel.vbt.dsi.config;\n\tu32 tlpx_ns, extra_byte_count, tlpx_ui;\n\tu32 ui_num, ui_den;\n\tu32 prepare_cnt, exit_zero_cnt, clk_zero_cnt, trail_cnt;\n\tu32 ths_prepare_ns, tclk_trail_ns;\n\tu32 tclk_prepare_clkzero, ths_prepare_hszero;\n\tu32 lp_to_hs_switch, hs_to_lp_switch;\n\tu32 mul;\n\n\ttlpx_ns = intel_dsi_tlpx_ns(intel_dsi);\n\n\tswitch (intel_dsi->lane_count) {\n\tcase 1:\n\tcase 2:\n\t\textra_byte_count = 2;\n\t\tbreak;\n\tcase 3:\n\t\textra_byte_count = 4;\n\t\tbreak;\n\tcase 4:\n\tdefault:\n\t\textra_byte_count = 3;\n\t\tbreak;\n\t}\n\n\t \n\tui_num = NS_KHZ_RATIO;\n\tui_den = intel_dsi_bitrate(intel_dsi);\n\n\ttclk_prepare_clkzero = mipi_config->tclk_prepare_clkzero;\n\tths_prepare_hszero = mipi_config->ths_prepare_hszero;\n\n\t \n\tintel_dsi->lp_byte_clk = DIV_ROUND_UP(tlpx_ns * ui_den, 8 * ui_num);\n\n\t \n\tmul = IS_GEMINILAKE(dev_priv) ? 8 : 2;\n\tths_prepare_ns = max(mipi_config->ths_prepare,\n\t\t\t     mipi_config->tclk_prepare);\n\n\t \n\tprepare_cnt = DIV_ROUND_UP(ths_prepare_ns * ui_den, ui_num * mul);\n\n\tif (prepare_cnt > PREPARE_CNT_MAX) {\n\t\tdrm_dbg_kms(&dev_priv->drm, \"prepare count too high %u\\n\",\n\t\t\t    prepare_cnt);\n\t\tprepare_cnt = PREPARE_CNT_MAX;\n\t}\n\n\t \n\texit_zero_cnt = DIV_ROUND_UP(\n\t\t\t\t(ths_prepare_hszero - ths_prepare_ns) * ui_den,\n\t\t\t\tui_num * mul\n\t\t\t\t);\n\n\t \n\tif (exit_zero_cnt < (55 * ui_den / ui_num) && (55 * ui_den) % ui_num)\n\t\texit_zero_cnt += 1;\n\n\tif (exit_zero_cnt > EXIT_ZERO_CNT_MAX) {\n\t\tdrm_dbg_kms(&dev_priv->drm, \"exit zero count too high %u\\n\",\n\t\t\t    exit_zero_cnt);\n\t\texit_zero_cnt = EXIT_ZERO_CNT_MAX;\n\t}\n\n\t \n\tclk_zero_cnt = DIV_ROUND_UP(\n\t\t\t\t(tclk_prepare_clkzero -\tths_prepare_ns)\n\t\t\t\t* ui_den, ui_num * mul);\n\n\tif (clk_zero_cnt > CLK_ZERO_CNT_MAX) {\n\t\tdrm_dbg_kms(&dev_priv->drm, \"clock zero count too high %u\\n\",\n\t\t\t    clk_zero_cnt);\n\t\tclk_zero_cnt = CLK_ZERO_CNT_MAX;\n\t}\n\n\t \n\ttclk_trail_ns = max(mipi_config->tclk_trail, mipi_config->ths_trail);\n\ttrail_cnt = DIV_ROUND_UP(tclk_trail_ns * ui_den, ui_num * mul);\n\n\tif (trail_cnt > TRAIL_CNT_MAX) {\n\t\tdrm_dbg_kms(&dev_priv->drm, \"trail count too high %u\\n\",\n\t\t\t    trail_cnt);\n\t\ttrail_cnt = TRAIL_CNT_MAX;\n\t}\n\n\t \n\tintel_dsi->dphy_reg = exit_zero_cnt << 24 | trail_cnt << 16 |\n\t\t\t\t\t\tclk_zero_cnt << 8 | prepare_cnt;\n\n\t \n\ttlpx_ui = DIV_ROUND_UP(tlpx_ns * ui_den, ui_num);\n\n\t \n\t \n\tlp_to_hs_switch = DIV_ROUND_UP(4 * tlpx_ui + prepare_cnt * mul +\n\t\t\t\t\t\texit_zero_cnt * mul + 10, 8);\n\n\ths_to_lp_switch = DIV_ROUND_UP(mipi_config->ths_trail + 2 * tlpx_ui, 8);\n\n\tintel_dsi->hs_to_lp_count = max(lp_to_hs_switch, hs_to_lp_switch);\n\tintel_dsi->hs_to_lp_count += extra_byte_count;\n\n\t \n\t \n\tintel_dsi->clk_lp_to_hs_count =\n\t\tDIV_ROUND_UP(\n\t\t\t4 * tlpx_ui + prepare_cnt * 2 +\n\t\t\tclk_zero_cnt * 2,\n\t\t\t8);\n\n\tintel_dsi->clk_lp_to_hs_count += extra_byte_count;\n\n\t \n\tintel_dsi->clk_hs_to_lp_count =\n\t\tDIV_ROUND_UP(2 * tlpx_ui + trail_cnt * 2 + 8,\n\t\t\t8);\n\tintel_dsi->clk_hs_to_lp_count += extra_byte_count;\n\n\tintel_dsi_log_params(intel_dsi);\n}\n\nvoid vlv_dsi_init(struct drm_i915_private *dev_priv)\n{\n\tstruct intel_dsi *intel_dsi;\n\tstruct intel_encoder *intel_encoder;\n\tstruct drm_encoder *encoder;\n\tstruct intel_connector *intel_connector;\n\tstruct drm_connector *connector;\n\tstruct drm_display_mode *current_mode;\n\tenum port port;\n\tenum pipe pipe;\n\n\tdrm_dbg_kms(&dev_priv->drm, \"\\n\");\n\n\t \n\tif (!intel_bios_is_dsi_present(dev_priv, &port))\n\t\treturn;\n\n\tif (IS_GEMINILAKE(dev_priv) || IS_BROXTON(dev_priv))\n\t\tdev_priv->display.dsi.mmio_base = BXT_MIPI_BASE;\n\telse\n\t\tdev_priv->display.dsi.mmio_base = VLV_MIPI_BASE;\n\n\tintel_dsi = kzalloc(sizeof(*intel_dsi), GFP_KERNEL);\n\tif (!intel_dsi)\n\t\treturn;\n\n\tintel_connector = intel_connector_alloc();\n\tif (!intel_connector) {\n\t\tkfree(intel_dsi);\n\t\treturn;\n\t}\n\n\tintel_encoder = &intel_dsi->base;\n\tencoder = &intel_encoder->base;\n\tintel_dsi->attached_connector = intel_connector;\n\n\tconnector = &intel_connector->base;\n\n\tdrm_encoder_init(&dev_priv->drm, encoder, &intel_dsi_funcs, DRM_MODE_ENCODER_DSI,\n\t\t\t \"DSI %c\", port_name(port));\n\n\tintel_encoder->compute_config = intel_dsi_compute_config;\n\tintel_encoder->pre_enable = intel_dsi_pre_enable;\n\tif (IS_GEMINILAKE(dev_priv) || IS_BROXTON(dev_priv))\n\t\tintel_encoder->enable = bxt_dsi_enable;\n\tintel_encoder->disable = intel_dsi_disable;\n\tintel_encoder->post_disable = intel_dsi_post_disable;\n\tintel_encoder->get_hw_state = intel_dsi_get_hw_state;\n\tintel_encoder->get_config = intel_dsi_get_config;\n\tintel_encoder->update_pipe = intel_backlight_update;\n\tintel_encoder->shutdown = intel_dsi_shutdown;\n\n\tintel_connector->get_hw_state = intel_connector_get_hw_state;\n\n\tintel_encoder->port = port;\n\tintel_encoder->type = INTEL_OUTPUT_DSI;\n\tintel_encoder->power_domain = POWER_DOMAIN_PORT_DSI;\n\tintel_encoder->cloneable = 0;\n\n\t \n\tif (IS_GEMINILAKE(dev_priv) || IS_BROXTON(dev_priv))\n\t\tintel_encoder->pipe_mask = ~0;\n\telse if (port == PORT_A)\n\t\tintel_encoder->pipe_mask = BIT(PIPE_A);\n\telse\n\t\tintel_encoder->pipe_mask = BIT(PIPE_B);\n\n\tintel_dsi->panel_power_off_time = ktime_get_boottime();\n\n\tintel_bios_init_panel_late(dev_priv, &intel_connector->panel, NULL, NULL);\n\n\tif (intel_connector->panel.vbt.dsi.config->dual_link)\n\t\tintel_dsi->ports = BIT(PORT_A) | BIT(PORT_C);\n\telse\n\t\tintel_dsi->ports = BIT(port);\n\n\tif (drm_WARN_ON(&dev_priv->drm, intel_connector->panel.vbt.dsi.bl_ports & ~intel_dsi->ports))\n\t\tintel_connector->panel.vbt.dsi.bl_ports &= intel_dsi->ports;\n\n\tif (drm_WARN_ON(&dev_priv->drm, intel_connector->panel.vbt.dsi.cabc_ports & ~intel_dsi->ports))\n\t\tintel_connector->panel.vbt.dsi.cabc_ports &= intel_dsi->ports;\n\n\t \n\tfor_each_dsi_port(port, intel_dsi->ports) {\n\t\tstruct intel_dsi_host *host;\n\n\t\thost = intel_dsi_host_init(intel_dsi, &intel_dsi_host_ops,\n\t\t\t\t\t   port);\n\t\tif (!host)\n\t\t\tgoto err;\n\n\t\tintel_dsi->dsi_hosts[port] = host;\n\t}\n\n\tif (!intel_dsi_vbt_init(intel_dsi, MIPI_DSI_GENERIC_PANEL_ID)) {\n\t\tdrm_dbg_kms(&dev_priv->drm, \"no device found\\n\");\n\t\tgoto err;\n\t}\n\n\t \n\tcurrent_mode = intel_encoder_current_mode(intel_encoder);\n\tif (current_mode) {\n\t\tdrm_dbg_kms(&dev_priv->drm, \"Calculated pclk %d GOP %d\\n\",\n\t\t\t    intel_dsi->pclk, current_mode->clock);\n\t\tif (intel_fuzzy_clock_check(intel_dsi->pclk,\n\t\t\t\t\t    current_mode->clock)) {\n\t\t\tdrm_dbg_kms(&dev_priv->drm, \"Using GOP pclk\\n\");\n\t\t\tintel_dsi->pclk = current_mode->clock;\n\t\t}\n\n\t\tkfree(current_mode);\n\t}\n\n\tvlv_dphy_param_init(intel_dsi);\n\n\tintel_dsi_vbt_gpio_init(intel_dsi,\n\t\t\t\tintel_dsi_get_hw_state(intel_encoder, &pipe));\n\n\tdrm_connector_init(&dev_priv->drm, connector, &intel_dsi_connector_funcs,\n\t\t\t   DRM_MODE_CONNECTOR_DSI);\n\n\tdrm_connector_helper_add(connector, &intel_dsi_connector_helper_funcs);\n\n\tconnector->display_info.subpixel_order = SubPixelHorizontalRGB;  \n\n\tintel_connector_attach_encoder(intel_connector, intel_encoder);\n\n\tmutex_lock(&dev_priv->drm.mode_config.mutex);\n\tintel_panel_add_vbt_lfp_fixed_mode(intel_connector);\n\tmutex_unlock(&dev_priv->drm.mode_config.mutex);\n\n\tif (!intel_panel_preferred_fixed_mode(intel_connector)) {\n\t\tdrm_dbg_kms(&dev_priv->drm, \"no fixed mode\\n\");\n\t\tgoto err_cleanup_connector;\n\t}\n\n\tintel_panel_init(intel_connector, NULL);\n\n\tintel_backlight_setup(intel_connector, INVALID_PIPE);\n\n\tvlv_dsi_add_properties(intel_connector);\n\n\treturn;\n\nerr_cleanup_connector:\n\tdrm_connector_cleanup(&intel_connector->base);\nerr:\n\tdrm_encoder_cleanup(&intel_encoder->base);\n\tkfree(intel_dsi);\n\tkfree(intel_connector);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}