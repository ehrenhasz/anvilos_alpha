{
  "module_name": "dvo_ch7xxx.c",
  "hash_id": "0a7521ff6ec722c133e611205a176c217add9ab2f21215fe996ba8e9a2e37c66",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/i915/display/dvo_ch7xxx.c",
  "human_readable_source": " \n\n#include \"intel_display_types.h\"\n#include \"intel_dvo_dev.h\"\n\n#define CH7xxx_REG_VID\t\t0x4a\n#define CH7xxx_REG_DID\t\t0x4b\n\n#define CH7011_VID\t\t0x83  \n#define CH7010B_VID\t\t0x05\n#define CH7009A_VID\t\t0x84\n#define CH7009B_VID\t\t0x85\n#define CH7301_VID\t\t0x95\n\n#define CH7xxx_VID\t\t0x84\n#define CH7xxx_DID\t\t0x17\n#define CH7010_DID\t\t0x16\n\n#define CH7xxx_NUM_REGS\t\t0x4c\n\n#define CH7xxx_CM\t\t0x1c\n#define CH7xxx_CM_XCM\t\t(1<<0)\n#define CH7xxx_CM_MCP\t\t(1<<2)\n#define CH7xxx_INPUT_CLOCK\t0x1d\n#define CH7xxx_GPIO\t\t0x1e\n#define CH7xxx_GPIO_HPIR\t(1<<3)\n\n#define CH7xxx_IDF\t\t0x1f\n#define CH7xxx_IDF_IBS\t\t(1<<7)\n#define CH7xxx_IDF_DES\t\t(1<<6)\n#define CH7xxx_IDF_HSP\t\t(1<<3)\n#define CH7xxx_IDF_VSP\t\t(1<<4)\n\n#define CH7xxx_CONNECTION_DETECT 0x20\n#define CH7xxx_CDET_DVI\t\t(1<<5)\n\n#define CH7xxx_DAC_CNTL\t\t0x21\n#define CH7xxx_SYNCO_MASK\t(3 << 3)\n#define CH7xxx_SYNCO_VGA_HSYNC\t(1 << 3)\n\n#define CH7xxx_CLOCK_OUTPUT\t0x22\n#define CH7xxx_BCOEN\t\t(1 << 4)\n#define CH7xxx_BCOP\t\t(1 << 3)\n#define CH7xxx_BCO_MASK\t\t(7 << 0)\n#define CH7xxx_BCO_VGA_VSYNC\t(6 << 0)\n\n#define CH7301_HOTPLUG\t\t0x23\n#define CH7xxx_TCTL\t\t0x31\n#define CH7xxx_TVCO\t\t0x32\n#define CH7xxx_TPCP\t\t0x33\n#define CH7xxx_TPD\t\t0x34\n#define CH7xxx_TPVT\t\t0x35\n#define CH7xxx_TLPF\t\t0x36\n#define CH7xxx_TCT\t\t0x37\n#define CH7301_TEST_PATTERN\t0x48\n\n#define CH7xxx_PM\t\t0x49\n#define CH7xxx_PM_FPD\t\t(1<<0)\n#define CH7301_PM_DACPD0\t(1<<1)\n#define CH7301_PM_DACPD1\t(1<<2)\n#define CH7301_PM_DACPD2\t(1<<3)\n#define CH7xxx_PM_DVIL\t\t(1<<6)\n#define CH7xxx_PM_DVIP\t\t(1<<7)\n\n#define CH7301_SYNC_POLARITY\t0x56\n#define CH7301_SYNC_RGB_YUV\t(1<<0)\n#define CH7301_SYNC_POL_DVI\t(1<<5)\n\n \n\nstatic struct ch7xxx_id_struct {\n\tu8 vid;\n\tchar *name;\n} ch7xxx_ids[] = {\n\t{ CH7011_VID, \"CH7011\" },\n\t{ CH7010B_VID, \"CH7010B\" },\n\t{ CH7009A_VID, \"CH7009A\" },\n\t{ CH7009B_VID, \"CH7009B\" },\n\t{ CH7301_VID, \"CH7301\" },\n};\n\nstatic struct ch7xxx_did_struct {\n\tu8 did;\n\tchar *name;\n} ch7xxx_dids[] = {\n\t{ CH7xxx_DID, \"CH7XXX\" },\n\t{ CH7010_DID, \"CH7010B\" },\n};\n\nstruct ch7xxx_priv {\n\tbool quiet;\n};\n\nstatic char *ch7xxx_get_id(u8 vid)\n{\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(ch7xxx_ids); i++) {\n\t\tif (ch7xxx_ids[i].vid == vid)\n\t\t\treturn ch7xxx_ids[i].name;\n\t}\n\n\treturn NULL;\n}\n\nstatic char *ch7xxx_get_did(u8 did)\n{\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(ch7xxx_dids); i++) {\n\t\tif (ch7xxx_dids[i].did == did)\n\t\t\treturn ch7xxx_dids[i].name;\n\t}\n\n\treturn NULL;\n}\n\n \nstatic bool ch7xxx_readb(struct intel_dvo_device *dvo, int addr, u8 *ch)\n{\n\tstruct ch7xxx_priv *ch7xxx = dvo->dev_priv;\n\tstruct i2c_adapter *adapter = dvo->i2c_bus;\n\tu8 out_buf[2];\n\tu8 in_buf[2];\n\n\tstruct i2c_msg msgs[] = {\n\t\t{\n\t\t\t.addr = dvo->slave_addr,\n\t\t\t.flags = 0,\n\t\t\t.len = 1,\n\t\t\t.buf = out_buf,\n\t\t},\n\t\t{\n\t\t\t.addr = dvo->slave_addr,\n\t\t\t.flags = I2C_M_RD,\n\t\t\t.len = 1,\n\t\t\t.buf = in_buf,\n\t\t}\n\t};\n\n\tout_buf[0] = addr;\n\tout_buf[1] = 0;\n\n\tif (i2c_transfer(adapter, msgs, 2) == 2) {\n\t\t*ch = in_buf[0];\n\t\treturn true;\n\t}\n\n\tif (!ch7xxx->quiet) {\n\t\tDRM_DEBUG_KMS(\"Unable to read register 0x%02x from %s:%02x.\\n\",\n\t\t\t  addr, adapter->name, dvo->slave_addr);\n\t}\n\treturn false;\n}\n\n \nstatic bool ch7xxx_writeb(struct intel_dvo_device *dvo, int addr, u8 ch)\n{\n\tstruct ch7xxx_priv *ch7xxx = dvo->dev_priv;\n\tstruct i2c_adapter *adapter = dvo->i2c_bus;\n\tu8 out_buf[2];\n\tstruct i2c_msg msg = {\n\t\t.addr = dvo->slave_addr,\n\t\t.flags = 0,\n\t\t.len = 2,\n\t\t.buf = out_buf,\n\t};\n\n\tout_buf[0] = addr;\n\tout_buf[1] = ch;\n\n\tif (i2c_transfer(adapter, &msg, 1) == 1)\n\t\treturn true;\n\n\tif (!ch7xxx->quiet) {\n\t\tDRM_DEBUG_KMS(\"Unable to write register 0x%02x to %s:%d.\\n\",\n\t\t\t  addr, adapter->name, dvo->slave_addr);\n\t}\n\n\treturn false;\n}\n\nstatic bool ch7xxx_init(struct intel_dvo_device *dvo,\n\t\t\tstruct i2c_adapter *adapter)\n{\n\t \n\tstruct ch7xxx_priv *ch7xxx;\n\tu8 vendor, device;\n\tchar *name, *devid;\n\n\tch7xxx = kzalloc(sizeof(struct ch7xxx_priv), GFP_KERNEL);\n\tif (ch7xxx == NULL)\n\t\treturn false;\n\n\tdvo->i2c_bus = adapter;\n\tdvo->dev_priv = ch7xxx;\n\tch7xxx->quiet = true;\n\n\tif (!ch7xxx_readb(dvo, CH7xxx_REG_VID, &vendor))\n\t\tgoto out;\n\n\tname = ch7xxx_get_id(vendor);\n\tif (!name) {\n\t\tDRM_DEBUG_KMS(\"ch7xxx not detected; got VID 0x%02x from %s slave %d.\\n\",\n\t\t\t      vendor, adapter->name, dvo->slave_addr);\n\t\tgoto out;\n\t}\n\n\n\tif (!ch7xxx_readb(dvo, CH7xxx_REG_DID, &device))\n\t\tgoto out;\n\n\tdevid = ch7xxx_get_did(device);\n\tif (!devid) {\n\t\tDRM_DEBUG_KMS(\"ch7xxx not detected; got DID 0x%02x from %s slave %d.\\n\",\n\t\t\t      device, adapter->name, dvo->slave_addr);\n\t\tgoto out;\n\t}\n\n\tch7xxx->quiet = false;\n\tDRM_DEBUG_KMS(\"Detected %s chipset, vendor/device ID 0x%02x/0x%02x\\n\",\n\t\t  name, vendor, device);\n\treturn true;\nout:\n\tkfree(ch7xxx);\n\treturn false;\n}\n\nstatic enum drm_connector_status ch7xxx_detect(struct intel_dvo_device *dvo)\n{\n\tu8 cdet, orig_pm, pm;\n\n\tch7xxx_readb(dvo, CH7xxx_PM, &orig_pm);\n\n\tpm = orig_pm;\n\tpm &= ~CH7xxx_PM_FPD;\n\tpm |= CH7xxx_PM_DVIL | CH7xxx_PM_DVIP;\n\n\tch7xxx_writeb(dvo, CH7xxx_PM, pm);\n\n\tch7xxx_readb(dvo, CH7xxx_CONNECTION_DETECT, &cdet);\n\n\tch7xxx_writeb(dvo, CH7xxx_PM, orig_pm);\n\n\tif (cdet & CH7xxx_CDET_DVI)\n\t\treturn connector_status_connected;\n\treturn connector_status_disconnected;\n}\n\nstatic enum drm_mode_status ch7xxx_mode_valid(struct intel_dvo_device *dvo,\n\t\t\t\t\t      struct drm_display_mode *mode)\n{\n\tif (mode->clock > 165000)\n\t\treturn MODE_CLOCK_HIGH;\n\n\treturn MODE_OK;\n}\n\nstatic void ch7xxx_mode_set(struct intel_dvo_device *dvo,\n\t\t\t    const struct drm_display_mode *mode,\n\t\t\t    const struct drm_display_mode *adjusted_mode)\n{\n\tu8 tvco, tpcp, tpd, tlpf, idf;\n\n\tif (mode->clock <= 65000) {\n\t\ttvco = 0x23;\n\t\ttpcp = 0x08;\n\t\ttpd = 0x16;\n\t\ttlpf = 0x60;\n\t} else {\n\t\ttvco = 0x2d;\n\t\ttpcp = 0x06;\n\t\ttpd = 0x26;\n\t\ttlpf = 0xa0;\n\t}\n\n\tch7xxx_writeb(dvo, CH7xxx_TCTL, 0x00);\n\tch7xxx_writeb(dvo, CH7xxx_TVCO, tvco);\n\tch7xxx_writeb(dvo, CH7xxx_TPCP, tpcp);\n\tch7xxx_writeb(dvo, CH7xxx_TPD, tpd);\n\tch7xxx_writeb(dvo, CH7xxx_TPVT, 0x30);\n\tch7xxx_writeb(dvo, CH7xxx_TLPF, tlpf);\n\tch7xxx_writeb(dvo, CH7xxx_TCT, 0x00);\n\n\tch7xxx_readb(dvo, CH7xxx_IDF, &idf);\n\n\tidf |= CH7xxx_IDF_IBS;\n\n\tidf &= ~(CH7xxx_IDF_HSP | CH7xxx_IDF_VSP);\n\tif (mode->flags & DRM_MODE_FLAG_PHSYNC)\n\t\tidf |= CH7xxx_IDF_HSP;\n\n\tif (mode->flags & DRM_MODE_FLAG_PVSYNC)\n\t\tidf |= CH7xxx_IDF_VSP;\n\n\tch7xxx_writeb(dvo, CH7xxx_IDF, idf);\n\n\tch7xxx_writeb(dvo, CH7xxx_DAC_CNTL,\n\t\t      CH7xxx_SYNCO_VGA_HSYNC);\n\tch7xxx_writeb(dvo, CH7xxx_CLOCK_OUTPUT,\n\t\t      CH7xxx_BCOEN | CH7xxx_BCO_VGA_VSYNC);\n}\n\n \nstatic void ch7xxx_dpms(struct intel_dvo_device *dvo, bool enable)\n{\n\tif (enable)\n\t\tch7xxx_writeb(dvo, CH7xxx_PM, CH7xxx_PM_DVIL | CH7xxx_PM_DVIP);\n\telse\n\t\tch7xxx_writeb(dvo, CH7xxx_PM, CH7xxx_PM_FPD);\n}\n\nstatic bool ch7xxx_get_hw_state(struct intel_dvo_device *dvo)\n{\n\tu8 val;\n\n\tch7xxx_readb(dvo, CH7xxx_PM, &val);\n\n\tif (val & (CH7xxx_PM_DVIL | CH7xxx_PM_DVIP))\n\t\treturn true;\n\telse\n\t\treturn false;\n}\n\nstatic void ch7xxx_dump_regs(struct intel_dvo_device *dvo)\n{\n\tint i;\n\n\tfor (i = 0; i < CH7xxx_NUM_REGS; i++) {\n\t\tu8 val;\n\t\tif ((i % 8) == 0)\n\t\t\tDRM_DEBUG_KMS(\"\\n %02X: \", i);\n\t\tch7xxx_readb(dvo, i, &val);\n\t\tDRM_DEBUG_KMS(\"%02X \", val);\n\t}\n}\n\nstatic void ch7xxx_destroy(struct intel_dvo_device *dvo)\n{\n\tstruct ch7xxx_priv *ch7xxx = dvo->dev_priv;\n\n\tif (ch7xxx) {\n\t\tkfree(ch7xxx);\n\t\tdvo->dev_priv = NULL;\n\t}\n}\n\nconst struct intel_dvo_dev_ops ch7xxx_ops = {\n\t.init = ch7xxx_init,\n\t.detect = ch7xxx_detect,\n\t.mode_valid = ch7xxx_mode_valid,\n\t.mode_set = ch7xxx_mode_set,\n\t.dpms = ch7xxx_dpms,\n\t.get_hw_state = ch7xxx_get_hw_state,\n\t.dump_regs = ch7xxx_dump_regs,\n\t.destroy = ch7xxx_destroy,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}