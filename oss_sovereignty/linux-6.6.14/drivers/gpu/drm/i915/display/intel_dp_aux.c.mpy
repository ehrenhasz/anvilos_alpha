{
  "module_name": "intel_dp_aux.c",
  "hash_id": "c27ddcaa5820ec79802d192450d6ae4b6664f806410d589b81efc5a2eac71b3e",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/i915/display/intel_dp_aux.c",
  "human_readable_source": "\n \n\n#include \"i915_drv.h\"\n#include \"i915_reg.h\"\n#include \"i915_trace.h\"\n#include \"intel_bios.h\"\n#include \"intel_de.h\"\n#include \"intel_display_types.h\"\n#include \"intel_dp_aux.h\"\n#include \"intel_dp_aux_regs.h\"\n#include \"intel_pps.h\"\n#include \"intel_tc.h\"\n\nu32 intel_dp_aux_pack(const u8 *src, int src_bytes)\n{\n\tint i;\n\tu32 v = 0;\n\n\tif (src_bytes > 4)\n\t\tsrc_bytes = 4;\n\tfor (i = 0; i < src_bytes; i++)\n\t\tv |= ((u32)src[i]) << ((3 - i) * 8);\n\treturn v;\n}\n\nstatic void intel_dp_aux_unpack(u32 src, u8 *dst, int dst_bytes)\n{\n\tint i;\n\n\tif (dst_bytes > 4)\n\t\tdst_bytes = 4;\n\tfor (i = 0; i < dst_bytes; i++)\n\t\tdst[i] = src >> ((3 - i) * 8);\n}\n\nstatic u32\nintel_dp_aux_wait_done(struct intel_dp *intel_dp)\n{\n\tstruct drm_i915_private *i915 = dp_to_i915(intel_dp);\n\ti915_reg_t ch_ctl = intel_dp->aux_ch_ctl_reg(intel_dp);\n\tconst unsigned int timeout_ms = 10;\n\tu32 status;\n\tint ret;\n\n\tret = __intel_de_wait_for_register(i915, ch_ctl,\n\t\t\t\t\t   DP_AUX_CH_CTL_SEND_BUSY, 0,\n\t\t\t\t\t   2, timeout_ms, &status);\n\n\tif (ret == -ETIMEDOUT)\n\t\tdrm_err(&i915->drm,\n\t\t\t\"%s: did not complete or timeout within %ums (status 0x%08x)\\n\",\n\t\t\tintel_dp->aux.name, timeout_ms, status);\n\n\treturn status;\n}\n\nstatic u32 g4x_get_aux_clock_divider(struct intel_dp *intel_dp, int index)\n{\n\tstruct drm_i915_private *dev_priv = dp_to_i915(intel_dp);\n\n\tif (index)\n\t\treturn 0;\n\n\t \n\treturn DIV_ROUND_CLOSEST(RUNTIME_INFO(dev_priv)->rawclk_freq, 2000);\n}\n\nstatic u32 ilk_get_aux_clock_divider(struct intel_dp *intel_dp, int index)\n{\n\tstruct drm_i915_private *dev_priv = dp_to_i915(intel_dp);\n\tstruct intel_digital_port *dig_port = dp_to_dig_port(intel_dp);\n\tu32 freq;\n\n\tif (index)\n\t\treturn 0;\n\n\t \n\tif (dig_port->aux_ch == AUX_CH_A)\n\t\tfreq = dev_priv->display.cdclk.hw.cdclk;\n\telse\n\t\tfreq = RUNTIME_INFO(dev_priv)->rawclk_freq;\n\treturn DIV_ROUND_CLOSEST(freq, 2000);\n}\n\nstatic u32 hsw_get_aux_clock_divider(struct intel_dp *intel_dp, int index)\n{\n\tstruct drm_i915_private *dev_priv = dp_to_i915(intel_dp);\n\tstruct intel_digital_port *dig_port = dp_to_dig_port(intel_dp);\n\n\tif (dig_port->aux_ch != AUX_CH_A && HAS_PCH_LPT_H(dev_priv)) {\n\t\t \n\t\tswitch (index) {\n\t\tcase 0: return 63;\n\t\tcase 1: return 72;\n\t\tdefault: return 0;\n\t\t}\n\t}\n\n\treturn ilk_get_aux_clock_divider(intel_dp, index);\n}\n\nstatic u32 skl_get_aux_clock_divider(struct intel_dp *intel_dp, int index)\n{\n\t \n\treturn index ? 0 : 1;\n}\n\nstatic int intel_dp_aux_sync_len(void)\n{\n\tint precharge = 16;  \n\tint preamble = 16;\n\n\treturn precharge + preamble;\n}\n\nstatic int intel_dp_aux_fw_sync_len(void)\n{\n\tint precharge = 10;  \n\tint preamble = 8;\n\n\treturn precharge + preamble;\n}\n\nstatic int g4x_dp_aux_precharge_len(void)\n{\n\tint precharge_min = 10;\n\tint preamble = 16;\n\n\t \n\treturn (intel_dp_aux_sync_len() -\n\t\tprecharge_min - preamble) / 2;\n}\n\nstatic u32 g4x_get_aux_send_ctl(struct intel_dp *intel_dp,\n\t\t\t\tint send_bytes,\n\t\t\t\tu32 aux_clock_divider)\n{\n\tstruct intel_digital_port *dig_port = dp_to_dig_port(intel_dp);\n\tstruct drm_i915_private *dev_priv =\n\t\t\tto_i915(dig_port->base.base.dev);\n\tu32 timeout;\n\n\t \n\tif (IS_BROADWELL(dev_priv))\n\t\ttimeout = DP_AUX_CH_CTL_TIME_OUT_600us;\n\telse\n\t\ttimeout = DP_AUX_CH_CTL_TIME_OUT_400us;\n\n\treturn DP_AUX_CH_CTL_SEND_BUSY |\n\t\tDP_AUX_CH_CTL_DONE |\n\t\tDP_AUX_CH_CTL_INTERRUPT |\n\t\tDP_AUX_CH_CTL_TIME_OUT_ERROR |\n\t\ttimeout |\n\t\tDP_AUX_CH_CTL_RECEIVE_ERROR |\n\t\tDP_AUX_CH_CTL_MESSAGE_SIZE(send_bytes) |\n\t\tDP_AUX_CH_CTL_PRECHARGE_2US(g4x_dp_aux_precharge_len()) |\n\t\tDP_AUX_CH_CTL_BIT_CLOCK_2X(aux_clock_divider);\n}\n\nstatic u32 skl_get_aux_send_ctl(struct intel_dp *intel_dp,\n\t\t\t\tint send_bytes,\n\t\t\t\tu32 unused)\n{\n\tstruct intel_digital_port *dig_port = dp_to_dig_port(intel_dp);\n\tstruct drm_i915_private *i915 =\tto_i915(dig_port->base.base.dev);\n\tu32 ret;\n\n\t \n\tret = DP_AUX_CH_CTL_SEND_BUSY |\n\t\tDP_AUX_CH_CTL_DONE |\n\t\tDP_AUX_CH_CTL_INTERRUPT |\n\t\tDP_AUX_CH_CTL_TIME_OUT_ERROR |\n\t\tDP_AUX_CH_CTL_TIME_OUT_MAX |\n\t\tDP_AUX_CH_CTL_RECEIVE_ERROR |\n\t\tDP_AUX_CH_CTL_MESSAGE_SIZE(send_bytes) |\n\t\tDP_AUX_CH_CTL_FW_SYNC_PULSE_SKL(intel_dp_aux_fw_sync_len()) |\n\t\tDP_AUX_CH_CTL_SYNC_PULSE_SKL(intel_dp_aux_sync_len());\n\n\tif (intel_tc_port_in_tbt_alt_mode(dig_port))\n\t\tret |= DP_AUX_CH_CTL_TBT_IO;\n\n\t \n\tif (DISPLAY_VER(i915) >= 14)\n\t\tret |= XELPDP_DP_AUX_CH_CTL_POWER_REQUEST;\n\n\treturn ret;\n}\n\nstatic int\nintel_dp_aux_xfer(struct intel_dp *intel_dp,\n\t\t  const u8 *send, int send_bytes,\n\t\t  u8 *recv, int recv_size,\n\t\t  u32 aux_send_ctl_flags)\n{\n\tstruct intel_digital_port *dig_port = dp_to_dig_port(intel_dp);\n\tstruct drm_i915_private *i915 =\n\t\t\tto_i915(dig_port->base.base.dev);\n\tenum phy phy = intel_port_to_phy(i915, dig_port->base.port);\n\tbool is_tc_port = intel_phy_is_tc(i915, phy);\n\ti915_reg_t ch_ctl, ch_data[5];\n\tu32 aux_clock_divider;\n\tenum intel_display_power_domain aux_domain;\n\tintel_wakeref_t aux_wakeref;\n\tintel_wakeref_t pps_wakeref;\n\tint i, ret, recv_bytes;\n\tint try, clock = 0;\n\tu32 status;\n\tbool vdd;\n\n\tch_ctl = intel_dp->aux_ch_ctl_reg(intel_dp);\n\tfor (i = 0; i < ARRAY_SIZE(ch_data); i++)\n\t\tch_data[i] = intel_dp->aux_ch_data_reg(intel_dp, i);\n\n\tif (is_tc_port) {\n\t\tintel_tc_port_lock(dig_port);\n\t\t \n\t\tif (!intel_tc_port_connected_locked(&dig_port->base)) {\n\t\t\tret = -ENXIO;\n\t\t\tgoto out_unlock;\n\t\t}\n\t}\n\n\taux_domain = intel_aux_power_domain(dig_port);\n\n\taux_wakeref = intel_display_power_get(i915, aux_domain);\n\tpps_wakeref = intel_pps_lock(intel_dp);\n\n\t \n\tvdd = intel_pps_vdd_on_unlocked(intel_dp);\n\n\t \n\tcpu_latency_qos_update_request(&intel_dp->pm_qos, 0);\n\n\tintel_pps_check_power_unlocked(intel_dp);\n\n\t \n\n\t \n\tfor (try = 0; try < 3; try++) {\n\t\tstatus = intel_de_read_notrace(i915, ch_ctl);\n\t\tif ((status & DP_AUX_CH_CTL_SEND_BUSY) == 0)\n\t\t\tbreak;\n\t\tmsleep(1);\n\t}\n\t \n\ttrace_i915_reg_rw(false, ch_ctl, status, sizeof(status), true);\n\n\tif (try == 3) {\n\t\tconst u32 status = intel_de_read(i915, ch_ctl);\n\n\t\tif (status != intel_dp->aux_busy_last_status) {\n\t\t\tdrm_WARN(&i915->drm, 1,\n\t\t\t\t \"%s: not started (status 0x%08x)\\n\",\n\t\t\t\t intel_dp->aux.name, status);\n\t\t\tintel_dp->aux_busy_last_status = status;\n\t\t}\n\n\t\tret = -EBUSY;\n\t\tgoto out;\n\t}\n\n\t \n\tif (drm_WARN_ON(&i915->drm, send_bytes > 20 || recv_size > 20)) {\n\t\tret = -E2BIG;\n\t\tgoto out;\n\t}\n\n\twhile ((aux_clock_divider = intel_dp->get_aux_clock_divider(intel_dp, clock++))) {\n\t\tu32 send_ctl = intel_dp->get_aux_send_ctl(intel_dp,\n\t\t\t\t\t\t\t  send_bytes,\n\t\t\t\t\t\t\t  aux_clock_divider);\n\n\t\tsend_ctl |= aux_send_ctl_flags;\n\n\t\t \n\t\tfor (try = 0; try < 5; try++) {\n\t\t\t \n\t\t\tfor (i = 0; i < send_bytes; i += 4)\n\t\t\t\tintel_de_write(i915, ch_data[i >> 2],\n\t\t\t\t\t       intel_dp_aux_pack(send + i,\n\t\t\t\t\t\t\t\t send_bytes - i));\n\n\t\t\t \n\t\t\tintel_de_write(i915, ch_ctl, send_ctl);\n\n\t\t\tstatus = intel_dp_aux_wait_done(intel_dp);\n\n\t\t\t \n\t\t\tintel_de_write(i915, ch_ctl,\n\t\t\t\t       status | DP_AUX_CH_CTL_DONE |\n\t\t\t\t       DP_AUX_CH_CTL_TIME_OUT_ERROR |\n\t\t\t\t       DP_AUX_CH_CTL_RECEIVE_ERROR);\n\n\t\t\t \n\t\t\tif (status & DP_AUX_CH_CTL_TIME_OUT_ERROR)\n\t\t\t\tcontinue;\n\n\t\t\tif (status & DP_AUX_CH_CTL_RECEIVE_ERROR) {\n\t\t\t\tusleep_range(400, 500);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (status & DP_AUX_CH_CTL_DONE)\n\t\t\t\tgoto done;\n\t\t}\n\t}\n\n\tif ((status & DP_AUX_CH_CTL_DONE) == 0) {\n\t\tdrm_err(&i915->drm, \"%s: not done (status 0x%08x)\\n\",\n\t\t\tintel_dp->aux.name, status);\n\t\tret = -EBUSY;\n\t\tgoto out;\n\t}\n\ndone:\n\t \n\tif (status & DP_AUX_CH_CTL_RECEIVE_ERROR) {\n\t\tdrm_err(&i915->drm, \"%s: receive error (status 0x%08x)\\n\",\n\t\t\tintel_dp->aux.name, status);\n\t\tret = -EIO;\n\t\tgoto out;\n\t}\n\n\t \n\tif (status & DP_AUX_CH_CTL_TIME_OUT_ERROR) {\n\t\tdrm_dbg_kms(&i915->drm, \"%s: timeout (status 0x%08x)\\n\",\n\t\t\t    intel_dp->aux.name, status);\n\t\tret = -ETIMEDOUT;\n\t\tgoto out;\n\t}\n\n\t \n\trecv_bytes = REG_FIELD_GET(DP_AUX_CH_CTL_MESSAGE_SIZE_MASK, status);\n\n\t \n\tif (recv_bytes == 0 || recv_bytes > 20) {\n\t\tdrm_dbg_kms(&i915->drm,\n\t\t\t    \"%s: Forbidden recv_bytes = %d on aux transaction\\n\",\n\t\t\t    intel_dp->aux.name, recv_bytes);\n\t\tret = -EBUSY;\n\t\tgoto out;\n\t}\n\n\tif (recv_bytes > recv_size)\n\t\trecv_bytes = recv_size;\n\n\tfor (i = 0; i < recv_bytes; i += 4)\n\t\tintel_dp_aux_unpack(intel_de_read(i915, ch_data[i >> 2]),\n\t\t\t\t    recv + i, recv_bytes - i);\n\n\tret = recv_bytes;\nout:\n\tcpu_latency_qos_update_request(&intel_dp->pm_qos, PM_QOS_DEFAULT_VALUE);\n\n\tif (vdd)\n\t\tintel_pps_vdd_off_unlocked(intel_dp, false);\n\n\tintel_pps_unlock(intel_dp, pps_wakeref);\n\tintel_display_power_put_async(i915, aux_domain, aux_wakeref);\nout_unlock:\n\tif (is_tc_port)\n\t\tintel_tc_port_unlock(dig_port);\n\n\treturn ret;\n}\n\n#define BARE_ADDRESS_SIZE\t3\n#define HEADER_SIZE\t\t(BARE_ADDRESS_SIZE + 1)\n\nstatic void\nintel_dp_aux_header(u8 txbuf[HEADER_SIZE],\n\t\t    const struct drm_dp_aux_msg *msg)\n{\n\ttxbuf[0] = (msg->request << 4) | ((msg->address >> 16) & 0xf);\n\ttxbuf[1] = (msg->address >> 8) & 0xff;\n\ttxbuf[2] = msg->address & 0xff;\n\ttxbuf[3] = msg->size - 1;\n}\n\nstatic u32 intel_dp_aux_xfer_flags(const struct drm_dp_aux_msg *msg)\n{\n\t \n\tif ((msg->request & ~DP_AUX_I2C_MOT) == DP_AUX_NATIVE_WRITE &&\n\t    msg->address == DP_AUX_HDCP_AKSV)\n\t\treturn DP_AUX_CH_CTL_AUX_AKSV_SELECT;\n\n\treturn 0;\n}\n\nstatic ssize_t\nintel_dp_aux_transfer(struct drm_dp_aux *aux, struct drm_dp_aux_msg *msg)\n{\n\tstruct intel_dp *intel_dp = container_of(aux, struct intel_dp, aux);\n\tstruct drm_i915_private *i915 = dp_to_i915(intel_dp);\n\tu8 txbuf[20], rxbuf[20];\n\tsize_t txsize, rxsize;\n\tu32 flags = intel_dp_aux_xfer_flags(msg);\n\tint ret;\n\n\tintel_dp_aux_header(txbuf, msg);\n\n\tswitch (msg->request & ~DP_AUX_I2C_MOT) {\n\tcase DP_AUX_NATIVE_WRITE:\n\tcase DP_AUX_I2C_WRITE:\n\tcase DP_AUX_I2C_WRITE_STATUS_UPDATE:\n\t\ttxsize = msg->size ? HEADER_SIZE + msg->size : BARE_ADDRESS_SIZE;\n\t\trxsize = 2;  \n\n\t\tif (drm_WARN_ON(&i915->drm, txsize > 20))\n\t\t\treturn -E2BIG;\n\n\t\tdrm_WARN_ON(&i915->drm, !msg->buffer != !msg->size);\n\n\t\tif (msg->buffer)\n\t\t\tmemcpy(txbuf + HEADER_SIZE, msg->buffer, msg->size);\n\n\t\tret = intel_dp_aux_xfer(intel_dp, txbuf, txsize,\n\t\t\t\t\trxbuf, rxsize, flags);\n\t\tif (ret > 0) {\n\t\t\tmsg->reply = rxbuf[0] >> 4;\n\n\t\t\tif (ret > 1) {\n\t\t\t\t \n\t\t\t\tret = clamp_t(int, rxbuf[1], 0, msg->size);\n\t\t\t} else {\n\t\t\t\t \n\t\t\t\tret = msg->size;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\tcase DP_AUX_NATIVE_READ:\n\tcase DP_AUX_I2C_READ:\n\t\ttxsize = msg->size ? HEADER_SIZE : BARE_ADDRESS_SIZE;\n\t\trxsize = msg->size + 1;\n\n\t\tif (drm_WARN_ON(&i915->drm, rxsize > 20))\n\t\t\treturn -E2BIG;\n\n\t\tret = intel_dp_aux_xfer(intel_dp, txbuf, txsize,\n\t\t\t\t\trxbuf, rxsize, flags);\n\t\tif (ret > 0) {\n\t\t\tmsg->reply = rxbuf[0] >> 4;\n\t\t\t \n\t\t\tret--;\n\t\t\tmemcpy(msg->buffer, rxbuf + 1, ret);\n\t\t}\n\t\tbreak;\n\n\tdefault:\n\t\tret = -EINVAL;\n\t\tbreak;\n\t}\n\n\treturn ret;\n}\n\nstatic i915_reg_t g4x_aux_ctl_reg(struct intel_dp *intel_dp)\n{\n\tstruct drm_i915_private *dev_priv = dp_to_i915(intel_dp);\n\tstruct intel_digital_port *dig_port = dp_to_dig_port(intel_dp);\n\tenum aux_ch aux_ch = dig_port->aux_ch;\n\n\tswitch (aux_ch) {\n\tcase AUX_CH_B:\n\tcase AUX_CH_C:\n\tcase AUX_CH_D:\n\t\treturn DP_AUX_CH_CTL(aux_ch);\n\tdefault:\n\t\tMISSING_CASE(aux_ch);\n\t\treturn DP_AUX_CH_CTL(AUX_CH_B);\n\t}\n}\n\nstatic i915_reg_t g4x_aux_data_reg(struct intel_dp *intel_dp, int index)\n{\n\tstruct drm_i915_private *dev_priv = dp_to_i915(intel_dp);\n\tstruct intel_digital_port *dig_port = dp_to_dig_port(intel_dp);\n\tenum aux_ch aux_ch = dig_port->aux_ch;\n\n\tswitch (aux_ch) {\n\tcase AUX_CH_B:\n\tcase AUX_CH_C:\n\tcase AUX_CH_D:\n\t\treturn DP_AUX_CH_DATA(aux_ch, index);\n\tdefault:\n\t\tMISSING_CASE(aux_ch);\n\t\treturn DP_AUX_CH_DATA(AUX_CH_B, index);\n\t}\n}\n\nstatic i915_reg_t ilk_aux_ctl_reg(struct intel_dp *intel_dp)\n{\n\tstruct drm_i915_private *dev_priv = dp_to_i915(intel_dp);\n\tstruct intel_digital_port *dig_port = dp_to_dig_port(intel_dp);\n\tenum aux_ch aux_ch = dig_port->aux_ch;\n\n\tswitch (aux_ch) {\n\tcase AUX_CH_A:\n\t\treturn DP_AUX_CH_CTL(aux_ch);\n\tcase AUX_CH_B:\n\tcase AUX_CH_C:\n\tcase AUX_CH_D:\n\t\treturn PCH_DP_AUX_CH_CTL(aux_ch);\n\tdefault:\n\t\tMISSING_CASE(aux_ch);\n\t\treturn DP_AUX_CH_CTL(AUX_CH_A);\n\t}\n}\n\nstatic i915_reg_t ilk_aux_data_reg(struct intel_dp *intel_dp, int index)\n{\n\tstruct drm_i915_private *dev_priv = dp_to_i915(intel_dp);\n\tstruct intel_digital_port *dig_port = dp_to_dig_port(intel_dp);\n\tenum aux_ch aux_ch = dig_port->aux_ch;\n\n\tswitch (aux_ch) {\n\tcase AUX_CH_A:\n\t\treturn DP_AUX_CH_DATA(aux_ch, index);\n\tcase AUX_CH_B:\n\tcase AUX_CH_C:\n\tcase AUX_CH_D:\n\t\treturn PCH_DP_AUX_CH_DATA(aux_ch, index);\n\tdefault:\n\t\tMISSING_CASE(aux_ch);\n\t\treturn DP_AUX_CH_DATA(AUX_CH_A, index);\n\t}\n}\n\nstatic i915_reg_t skl_aux_ctl_reg(struct intel_dp *intel_dp)\n{\n\tstruct drm_i915_private *dev_priv = dp_to_i915(intel_dp);\n\tstruct intel_digital_port *dig_port = dp_to_dig_port(intel_dp);\n\tenum aux_ch aux_ch = dig_port->aux_ch;\n\n\tswitch (aux_ch) {\n\tcase AUX_CH_A:\n\tcase AUX_CH_B:\n\tcase AUX_CH_C:\n\tcase AUX_CH_D:\n\tcase AUX_CH_E:\n\tcase AUX_CH_F:\n\t\treturn DP_AUX_CH_CTL(aux_ch);\n\tdefault:\n\t\tMISSING_CASE(aux_ch);\n\t\treturn DP_AUX_CH_CTL(AUX_CH_A);\n\t}\n}\n\nstatic i915_reg_t skl_aux_data_reg(struct intel_dp *intel_dp, int index)\n{\n\tstruct drm_i915_private *dev_priv = dp_to_i915(intel_dp);\n\tstruct intel_digital_port *dig_port = dp_to_dig_port(intel_dp);\n\tenum aux_ch aux_ch = dig_port->aux_ch;\n\n\tswitch (aux_ch) {\n\tcase AUX_CH_A:\n\tcase AUX_CH_B:\n\tcase AUX_CH_C:\n\tcase AUX_CH_D:\n\tcase AUX_CH_E:\n\tcase AUX_CH_F:\n\t\treturn DP_AUX_CH_DATA(aux_ch, index);\n\tdefault:\n\t\tMISSING_CASE(aux_ch);\n\t\treturn DP_AUX_CH_DATA(AUX_CH_A, index);\n\t}\n}\n\nstatic i915_reg_t tgl_aux_ctl_reg(struct intel_dp *intel_dp)\n{\n\tstruct drm_i915_private *dev_priv = dp_to_i915(intel_dp);\n\tstruct intel_digital_port *dig_port = dp_to_dig_port(intel_dp);\n\tenum aux_ch aux_ch = dig_port->aux_ch;\n\n\tswitch (aux_ch) {\n\tcase AUX_CH_A:\n\tcase AUX_CH_B:\n\tcase AUX_CH_C:\n\tcase AUX_CH_USBC1:\n\tcase AUX_CH_USBC2:\n\tcase AUX_CH_USBC3:\n\tcase AUX_CH_USBC4:\n\tcase AUX_CH_USBC5:   \n\tcase AUX_CH_USBC6:   \n\t\treturn DP_AUX_CH_CTL(aux_ch);\n\tdefault:\n\t\tMISSING_CASE(aux_ch);\n\t\treturn DP_AUX_CH_CTL(AUX_CH_A);\n\t}\n}\n\nstatic i915_reg_t tgl_aux_data_reg(struct intel_dp *intel_dp, int index)\n{\n\tstruct drm_i915_private *dev_priv = dp_to_i915(intel_dp);\n\tstruct intel_digital_port *dig_port = dp_to_dig_port(intel_dp);\n\tenum aux_ch aux_ch = dig_port->aux_ch;\n\n\tswitch (aux_ch) {\n\tcase AUX_CH_A:\n\tcase AUX_CH_B:\n\tcase AUX_CH_C:\n\tcase AUX_CH_USBC1:\n\tcase AUX_CH_USBC2:\n\tcase AUX_CH_USBC3:\n\tcase AUX_CH_USBC4:\n\tcase AUX_CH_USBC5:   \n\tcase AUX_CH_USBC6:   \n\t\treturn DP_AUX_CH_DATA(aux_ch, index);\n\tdefault:\n\t\tMISSING_CASE(aux_ch);\n\t\treturn DP_AUX_CH_DATA(AUX_CH_A, index);\n\t}\n}\n\nstatic i915_reg_t xelpdp_aux_ctl_reg(struct intel_dp *intel_dp)\n{\n\tstruct drm_i915_private *dev_priv = dp_to_i915(intel_dp);\n\tstruct intel_digital_port *dig_port = dp_to_dig_port(intel_dp);\n\tenum aux_ch aux_ch = dig_port->aux_ch;\n\n\tswitch (aux_ch) {\n\tcase AUX_CH_A:\n\tcase AUX_CH_B:\n\tcase AUX_CH_USBC1:\n\tcase AUX_CH_USBC2:\n\tcase AUX_CH_USBC3:\n\tcase AUX_CH_USBC4:\n\t\treturn XELPDP_DP_AUX_CH_CTL(aux_ch);\n\tdefault:\n\t\tMISSING_CASE(aux_ch);\n\t\treturn XELPDP_DP_AUX_CH_CTL(AUX_CH_A);\n\t}\n}\n\nstatic i915_reg_t xelpdp_aux_data_reg(struct intel_dp *intel_dp, int index)\n{\n\tstruct drm_i915_private *dev_priv = dp_to_i915(intel_dp);\n\tstruct intel_digital_port *dig_port = dp_to_dig_port(intel_dp);\n\tenum aux_ch aux_ch = dig_port->aux_ch;\n\n\tswitch (aux_ch) {\n\tcase AUX_CH_A:\n\tcase AUX_CH_B:\n\tcase AUX_CH_USBC1:\n\tcase AUX_CH_USBC2:\n\tcase AUX_CH_USBC3:\n\tcase AUX_CH_USBC4:\n\t\treturn XELPDP_DP_AUX_CH_DATA(aux_ch, index);\n\tdefault:\n\t\tMISSING_CASE(aux_ch);\n\t\treturn XELPDP_DP_AUX_CH_DATA(AUX_CH_A, index);\n\t}\n}\n\nvoid intel_dp_aux_fini(struct intel_dp *intel_dp)\n{\n\tif (cpu_latency_qos_request_active(&intel_dp->pm_qos))\n\t\tcpu_latency_qos_remove_request(&intel_dp->pm_qos);\n\n\tkfree(intel_dp->aux.name);\n}\n\nvoid intel_dp_aux_init(struct intel_dp *intel_dp)\n{\n\tstruct drm_i915_private *dev_priv = dp_to_i915(intel_dp);\n\tstruct intel_digital_port *dig_port = dp_to_dig_port(intel_dp);\n\tstruct intel_encoder *encoder = &dig_port->base;\n\tenum aux_ch aux_ch = dig_port->aux_ch;\n\n\tif (DISPLAY_VER(dev_priv) >= 14) {\n\t\tintel_dp->aux_ch_ctl_reg = xelpdp_aux_ctl_reg;\n\t\tintel_dp->aux_ch_data_reg = xelpdp_aux_data_reg;\n\t} else if (DISPLAY_VER(dev_priv) >= 12) {\n\t\tintel_dp->aux_ch_ctl_reg = tgl_aux_ctl_reg;\n\t\tintel_dp->aux_ch_data_reg = tgl_aux_data_reg;\n\t} else if (DISPLAY_VER(dev_priv) >= 9) {\n\t\tintel_dp->aux_ch_ctl_reg = skl_aux_ctl_reg;\n\t\tintel_dp->aux_ch_data_reg = skl_aux_data_reg;\n\t} else if (HAS_PCH_SPLIT(dev_priv)) {\n\t\tintel_dp->aux_ch_ctl_reg = ilk_aux_ctl_reg;\n\t\tintel_dp->aux_ch_data_reg = ilk_aux_data_reg;\n\t} else {\n\t\tintel_dp->aux_ch_ctl_reg = g4x_aux_ctl_reg;\n\t\tintel_dp->aux_ch_data_reg = g4x_aux_data_reg;\n\t}\n\n\tif (DISPLAY_VER(dev_priv) >= 9)\n\t\tintel_dp->get_aux_clock_divider = skl_get_aux_clock_divider;\n\telse if (IS_BROADWELL(dev_priv) || IS_HASWELL(dev_priv))\n\t\tintel_dp->get_aux_clock_divider = hsw_get_aux_clock_divider;\n\telse if (HAS_PCH_SPLIT(dev_priv))\n\t\tintel_dp->get_aux_clock_divider = ilk_get_aux_clock_divider;\n\telse\n\t\tintel_dp->get_aux_clock_divider = g4x_get_aux_clock_divider;\n\n\tif (DISPLAY_VER(dev_priv) >= 9)\n\t\tintel_dp->get_aux_send_ctl = skl_get_aux_send_ctl;\n\telse\n\t\tintel_dp->get_aux_send_ctl = g4x_get_aux_send_ctl;\n\n\tintel_dp->aux.drm_dev = &dev_priv->drm;\n\tdrm_dp_aux_init(&intel_dp->aux);\n\n\t \n\tif (DISPLAY_VER(dev_priv) >= 13 && aux_ch >= AUX_CH_D_XELPD)\n\t\tintel_dp->aux.name = kasprintf(GFP_KERNEL, \"AUX %c/%s\",\n\t\t\t\t\t       aux_ch_name(aux_ch - AUX_CH_D_XELPD + AUX_CH_D),\n\t\t\t\t\t       encoder->base.name);\n\telse if (DISPLAY_VER(dev_priv) >= 12 && aux_ch >= AUX_CH_USBC1)\n\t\tintel_dp->aux.name = kasprintf(GFP_KERNEL, \"AUX USBC%c/%s\",\n\t\t\t\t\t       aux_ch - AUX_CH_USBC1 + '1',\n\t\t\t\t\t       encoder->base.name);\n\telse\n\t\tintel_dp->aux.name = kasprintf(GFP_KERNEL, \"AUX %c/%s\",\n\t\t\t\t\t       aux_ch_name(aux_ch),\n\t\t\t\t\t       encoder->base.name);\n\n\tintel_dp->aux.transfer = intel_dp_aux_transfer;\n\tcpu_latency_qos_add_request(&intel_dp->pm_qos, PM_QOS_DEFAULT_VALUE);\n}\n\nstatic enum aux_ch default_aux_ch(struct intel_encoder *encoder)\n{\n\tstruct drm_i915_private *i915 = to_i915(encoder->base.dev);\n\n\t \n\tif (DISPLAY_VER(i915) == 9 && encoder->port == PORT_E)\n\t\treturn AUX_CH_A;\n\n\treturn (enum aux_ch)encoder->port;\n}\n\nstatic struct intel_encoder *\nget_encoder_by_aux_ch(struct intel_encoder *encoder,\n\t\t      enum aux_ch aux_ch)\n{\n\tstruct drm_i915_private *i915 = to_i915(encoder->base.dev);\n\tstruct intel_encoder *other;\n\n\tfor_each_intel_encoder(&i915->drm, other) {\n\t\tif (other == encoder)\n\t\t\tcontinue;\n\n\t\tif (!intel_encoder_is_dig_port(other))\n\t\t\tcontinue;\n\n\t\tif (enc_to_dig_port(other)->aux_ch == aux_ch)\n\t\t\treturn other;\n\t}\n\n\treturn NULL;\n}\n\nenum aux_ch intel_dp_aux_ch(struct intel_encoder *encoder)\n{\n\tstruct drm_i915_private *i915 = to_i915(encoder->base.dev);\n\tstruct intel_encoder *other;\n\tconst char *source;\n\tenum aux_ch aux_ch;\n\n\taux_ch = intel_bios_dp_aux_ch(encoder->devdata);\n\tsource = \"VBT\";\n\n\tif (aux_ch == AUX_CH_NONE) {\n\t\taux_ch = default_aux_ch(encoder);\n\t\tsource = \"platform default\";\n\t}\n\n\tif (aux_ch == AUX_CH_NONE)\n\t\treturn AUX_CH_NONE;\n\n\t \n\n\tother = get_encoder_by_aux_ch(encoder, aux_ch);\n\tif (other) {\n\t\tdrm_dbg_kms(&i915->drm,\n\t\t\t    \"[ENCODER:%d:%s] AUX CH %c already claimed by [ENCODER:%d:%s]\\n\",\n\t\t\t    encoder->base.base.id, encoder->base.name, aux_ch_name(aux_ch),\n\t\t\t    other->base.base.id, other->base.name);\n\t\treturn AUX_CH_NONE;\n\t}\n\n\tdrm_dbg_kms(&i915->drm,\n\t\t    \"[ENCODER:%d:%s] Using AUX CH %c (%s)\\n\",\n\t\t    encoder->base.base.id, encoder->base.name,\n\t\t    aux_ch_name(aux_ch), source);\n\n\treturn aux_ch;\n}\n\nvoid intel_dp_aux_irq_handler(struct drm_i915_private *i915)\n{\n\twake_up_all(&i915->display.gmbus.wait_queue);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}