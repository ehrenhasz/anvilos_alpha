{
  "module_name": "intel_fb.c",
  "hash_id": "b5aeadc3774020b33eb5e998a7b34f631edb65c5b5614f554af0b5a0d0dde68b",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/i915/display/intel_fb.c",
  "human_readable_source": "\n \n\n#include <drm/drm_blend.h>\n#include <drm/drm_framebuffer.h>\n#include <drm/drm_modeset_helper.h>\n\n#include \"i915_drv.h\"\n#include \"intel_display.h\"\n#include \"intel_display_types.h\"\n#include \"intel_dpt.h\"\n#include \"intel_fb.h\"\n\n#define check_array_bounds(i915, a, i) drm_WARN_ON(&(i915)->drm, (i) >= ARRAY_SIZE(a))\n\n \nstatic const struct drm_format_info skl_ccs_formats[] = {\n\t{ .format = DRM_FORMAT_XRGB8888, .depth = 24, .num_planes = 2,\n\t  .cpp = { 4, 1, }, .hsub = 8, .vsub = 16, },\n\t{ .format = DRM_FORMAT_XBGR8888, .depth = 24, .num_planes = 2,\n\t  .cpp = { 4, 1, }, .hsub = 8, .vsub = 16, },\n\t{ .format = DRM_FORMAT_ARGB8888, .depth = 32, .num_planes = 2,\n\t  .cpp = { 4, 1, }, .hsub = 8, .vsub = 16, .has_alpha = true, },\n\t{ .format = DRM_FORMAT_ABGR8888, .depth = 32, .num_planes = 2,\n\t  .cpp = { 4, 1, }, .hsub = 8, .vsub = 16, .has_alpha = true, },\n};\n\n \nstatic const struct drm_format_info gen12_ccs_formats[] = {\n\t{ .format = DRM_FORMAT_XRGB8888, .depth = 24, .num_planes = 2,\n\t  .char_per_block = { 4, 1 }, .block_w = { 1, 2 }, .block_h = { 1, 1 },\n\t  .hsub = 1, .vsub = 1, },\n\t{ .format = DRM_FORMAT_XBGR8888, .depth = 24, .num_planes = 2,\n\t  .char_per_block = { 4, 1 }, .block_w = { 1, 2 }, .block_h = { 1, 1 },\n\t  .hsub = 1, .vsub = 1, },\n\t{ .format = DRM_FORMAT_ARGB8888, .depth = 32, .num_planes = 2,\n\t  .char_per_block = { 4, 1 }, .block_w = { 1, 2 }, .block_h = { 1, 1 },\n\t  .hsub = 1, .vsub = 1, .has_alpha = true },\n\t{ .format = DRM_FORMAT_ABGR8888, .depth = 32, .num_planes = 2,\n\t  .char_per_block = { 4, 1 }, .block_w = { 1, 2 }, .block_h = { 1, 1 },\n\t  .hsub = 1, .vsub = 1, .has_alpha = true },\n\t{ .format = DRM_FORMAT_YUYV, .num_planes = 2,\n\t  .char_per_block = { 2, 1 }, .block_w = { 1, 2 }, .block_h = { 1, 1 },\n\t  .hsub = 2, .vsub = 1, .is_yuv = true },\n\t{ .format = DRM_FORMAT_YVYU, .num_planes = 2,\n\t  .char_per_block = { 2, 1 }, .block_w = { 1, 2 }, .block_h = { 1, 1 },\n\t  .hsub = 2, .vsub = 1, .is_yuv = true },\n\t{ .format = DRM_FORMAT_UYVY, .num_planes = 2,\n\t  .char_per_block = { 2, 1 }, .block_w = { 1, 2 }, .block_h = { 1, 1 },\n\t  .hsub = 2, .vsub = 1, .is_yuv = true },\n\t{ .format = DRM_FORMAT_VYUY, .num_planes = 2,\n\t  .char_per_block = { 2, 1 }, .block_w = { 1, 2 }, .block_h = { 1, 1 },\n\t  .hsub = 2, .vsub = 1, .is_yuv = true },\n\t{ .format = DRM_FORMAT_XYUV8888, .num_planes = 2,\n\t  .char_per_block = { 4, 1 }, .block_w = { 1, 2 }, .block_h = { 1, 1 },\n\t  .hsub = 1, .vsub = 1, .is_yuv = true },\n\t{ .format = DRM_FORMAT_NV12, .num_planes = 4,\n\t  .char_per_block = { 1, 2, 1, 1 }, .block_w = { 1, 1, 4, 4 }, .block_h = { 1, 1, 1, 1 },\n\t  .hsub = 2, .vsub = 2, .is_yuv = true },\n\t{ .format = DRM_FORMAT_P010, .num_planes = 4,\n\t  .char_per_block = { 2, 4, 1, 1 }, .block_w = { 1, 1, 2, 2 }, .block_h = { 1, 1, 1, 1 },\n\t  .hsub = 2, .vsub = 2, .is_yuv = true },\n\t{ .format = DRM_FORMAT_P012, .num_planes = 4,\n\t  .char_per_block = { 2, 4, 1, 1 }, .block_w = { 1, 1, 2, 2 }, .block_h = { 1, 1, 1, 1 },\n\t  .hsub = 2, .vsub = 2, .is_yuv = true },\n\t{ .format = DRM_FORMAT_P016, .num_planes = 4,\n\t  .char_per_block = { 2, 4, 1, 1 }, .block_w = { 1, 1, 2, 2 }, .block_h = { 1, 1, 1, 1 },\n\t  .hsub = 2, .vsub = 2, .is_yuv = true },\n};\n\n \nstatic const struct drm_format_info gen12_ccs_cc_formats[] = {\n\t{ .format = DRM_FORMAT_XRGB8888, .depth = 24, .num_planes = 3,\n\t  .char_per_block = { 4, 1, 0 }, .block_w = { 1, 2, 2 }, .block_h = { 1, 1, 1 },\n\t  .hsub = 1, .vsub = 1, },\n\t{ .format = DRM_FORMAT_XBGR8888, .depth = 24, .num_planes = 3,\n\t  .char_per_block = { 4, 1, 0 }, .block_w = { 1, 2, 2 }, .block_h = { 1, 1, 1 },\n\t  .hsub = 1, .vsub = 1, },\n\t{ .format = DRM_FORMAT_ARGB8888, .depth = 32, .num_planes = 3,\n\t  .char_per_block = { 4, 1, 0 }, .block_w = { 1, 2, 2 }, .block_h = { 1, 1, 1 },\n\t  .hsub = 1, .vsub = 1, .has_alpha = true },\n\t{ .format = DRM_FORMAT_ABGR8888, .depth = 32, .num_planes = 3,\n\t  .char_per_block = { 4, 1, 0 }, .block_w = { 1, 2, 2 }, .block_h = { 1, 1, 1 },\n\t  .hsub = 1, .vsub = 1, .has_alpha = true },\n};\n\nstatic const struct drm_format_info gen12_flat_ccs_cc_formats[] = {\n\t{ .format = DRM_FORMAT_XRGB8888, .depth = 24, .num_planes = 2,\n\t  .char_per_block = { 4, 0 }, .block_w = { 1, 2 }, .block_h = { 1, 1 },\n\t  .hsub = 1, .vsub = 1, },\n\t{ .format = DRM_FORMAT_XBGR8888, .depth = 24, .num_planes = 2,\n\t  .char_per_block = { 4, 0 }, .block_w = { 1, 2 }, .block_h = { 1, 1 },\n\t  .hsub = 1, .vsub = 1, },\n\t{ .format = DRM_FORMAT_ARGB8888, .depth = 32, .num_planes = 2,\n\t  .char_per_block = { 4, 0 }, .block_w = { 1, 2 }, .block_h = { 1, 1 },\n\t  .hsub = 1, .vsub = 1, .has_alpha = true },\n\t{ .format = DRM_FORMAT_ABGR8888, .depth = 32, .num_planes = 2,\n\t  .char_per_block = { 4, 0 }, .block_w = { 1, 2 }, .block_h = { 1, 1 },\n\t  .hsub = 1, .vsub = 1, .has_alpha = true },\n};\n\nstruct intel_modifier_desc {\n\tu64 modifier;\n\tstruct {\n\t\tu8 from;\n\t\tu8 until;\n\t} display_ver;\n#define DISPLAY_VER_ALL\t\t{ 0, -1 }\n\n\tconst struct drm_format_info *formats;\n\tint format_count;\n#define FORMAT_OVERRIDE(format_list) \\\n\t.formats = format_list, \\\n\t.format_count = ARRAY_SIZE(format_list)\n\n\tu8 plane_caps;\n\n\tstruct {\n\t\tu8 cc_planes:3;\n\t\tu8 packed_aux_planes:4;\n\t\tu8 planar_aux_planes:4;\n\t} ccs;\n};\n\n#define INTEL_PLANE_CAP_CCS_MASK\t(INTEL_PLANE_CAP_CCS_RC | \\\n\t\t\t\t\t INTEL_PLANE_CAP_CCS_RC_CC | \\\n\t\t\t\t\t INTEL_PLANE_CAP_CCS_MC)\n#define INTEL_PLANE_CAP_TILING_MASK\t(INTEL_PLANE_CAP_TILING_X | \\\n\t\t\t\t\t INTEL_PLANE_CAP_TILING_Y | \\\n\t\t\t\t\t INTEL_PLANE_CAP_TILING_Yf | \\\n\t\t\t\t\t INTEL_PLANE_CAP_TILING_4)\n#define INTEL_PLANE_CAP_TILING_NONE\t0\n\nstatic const struct intel_modifier_desc intel_modifiers[] = {\n\t{\n\t\t.modifier = I915_FORMAT_MOD_4_TILED_MTL_MC_CCS,\n\t\t.display_ver = { 14, 14 },\n\t\t.plane_caps = INTEL_PLANE_CAP_TILING_4 | INTEL_PLANE_CAP_CCS_MC,\n\n\t\t.ccs.packed_aux_planes = BIT(1),\n\t\t.ccs.planar_aux_planes = BIT(2) | BIT(3),\n\n\t\tFORMAT_OVERRIDE(gen12_ccs_formats),\n\t}, {\n\t\t.modifier = I915_FORMAT_MOD_4_TILED_MTL_RC_CCS,\n\t\t.display_ver = { 14, 14 },\n\t\t.plane_caps = INTEL_PLANE_CAP_TILING_4 | INTEL_PLANE_CAP_CCS_RC,\n\n\t\t.ccs.packed_aux_planes = BIT(1),\n\n\t\tFORMAT_OVERRIDE(gen12_ccs_formats),\n\t}, {\n\t\t.modifier = I915_FORMAT_MOD_4_TILED_MTL_RC_CCS_CC,\n\t\t.display_ver = { 14, 14 },\n\t\t.plane_caps = INTEL_PLANE_CAP_TILING_4 | INTEL_PLANE_CAP_CCS_RC_CC,\n\n\t\t.ccs.cc_planes = BIT(2),\n\t\t.ccs.packed_aux_planes = BIT(1),\n\n\t\tFORMAT_OVERRIDE(gen12_ccs_cc_formats),\n\t}, {\n\t\t.modifier = I915_FORMAT_MOD_4_TILED_DG2_MC_CCS,\n\t\t.display_ver = { 13, 13 },\n\t\t.plane_caps = INTEL_PLANE_CAP_TILING_4 | INTEL_PLANE_CAP_CCS_MC,\n\t}, {\n\t\t.modifier = I915_FORMAT_MOD_4_TILED_DG2_RC_CCS_CC,\n\t\t.display_ver = { 13, 13 },\n\t\t.plane_caps = INTEL_PLANE_CAP_TILING_4 | INTEL_PLANE_CAP_CCS_RC_CC,\n\n\t\t.ccs.cc_planes = BIT(1),\n\n\t\tFORMAT_OVERRIDE(gen12_flat_ccs_cc_formats),\n\t}, {\n\t\t.modifier = I915_FORMAT_MOD_4_TILED_DG2_RC_CCS,\n\t\t.display_ver = { 13, 13 },\n\t\t.plane_caps = INTEL_PLANE_CAP_TILING_4 | INTEL_PLANE_CAP_CCS_RC,\n\t}, {\n\t\t.modifier = I915_FORMAT_MOD_4_TILED,\n\t\t.display_ver = { 13, -1 },\n\t\t.plane_caps = INTEL_PLANE_CAP_TILING_4,\n\t}, {\n\t\t.modifier = I915_FORMAT_MOD_Y_TILED_GEN12_MC_CCS,\n\t\t.display_ver = { 12, 13 },\n\t\t.plane_caps = INTEL_PLANE_CAP_TILING_Y | INTEL_PLANE_CAP_CCS_MC,\n\n\t\t.ccs.packed_aux_planes = BIT(1),\n\t\t.ccs.planar_aux_planes = BIT(2) | BIT(3),\n\n\t\tFORMAT_OVERRIDE(gen12_ccs_formats),\n\t}, {\n\t\t.modifier = I915_FORMAT_MOD_Y_TILED_GEN12_RC_CCS,\n\t\t.display_ver = { 12, 13 },\n\t\t.plane_caps = INTEL_PLANE_CAP_TILING_Y | INTEL_PLANE_CAP_CCS_RC,\n\n\t\t.ccs.packed_aux_planes = BIT(1),\n\n\t\tFORMAT_OVERRIDE(gen12_ccs_formats),\n\t}, {\n\t\t.modifier = I915_FORMAT_MOD_Y_TILED_GEN12_RC_CCS_CC,\n\t\t.display_ver = { 12, 13 },\n\t\t.plane_caps = INTEL_PLANE_CAP_TILING_Y | INTEL_PLANE_CAP_CCS_RC_CC,\n\n\t\t.ccs.cc_planes = BIT(2),\n\t\t.ccs.packed_aux_planes = BIT(1),\n\n\t\tFORMAT_OVERRIDE(gen12_ccs_cc_formats),\n\t}, {\n\t\t.modifier = I915_FORMAT_MOD_Yf_TILED_CCS,\n\t\t.display_ver = { 9, 11 },\n\t\t.plane_caps = INTEL_PLANE_CAP_TILING_Yf | INTEL_PLANE_CAP_CCS_RC,\n\n\t\t.ccs.packed_aux_planes = BIT(1),\n\n\t\tFORMAT_OVERRIDE(skl_ccs_formats),\n\t}, {\n\t\t.modifier = I915_FORMAT_MOD_Y_TILED_CCS,\n\t\t.display_ver = { 9, 11 },\n\t\t.plane_caps = INTEL_PLANE_CAP_TILING_Y | INTEL_PLANE_CAP_CCS_RC,\n\n\t\t.ccs.packed_aux_planes = BIT(1),\n\n\t\tFORMAT_OVERRIDE(skl_ccs_formats),\n\t}, {\n\t\t.modifier = I915_FORMAT_MOD_Yf_TILED,\n\t\t.display_ver = { 9, 11 },\n\t\t.plane_caps = INTEL_PLANE_CAP_TILING_Yf,\n\t}, {\n\t\t.modifier = I915_FORMAT_MOD_Y_TILED,\n\t\t.display_ver = { 9, 13 },\n\t\t.plane_caps = INTEL_PLANE_CAP_TILING_Y,\n\t}, {\n\t\t.modifier = I915_FORMAT_MOD_X_TILED,\n\t\t.display_ver = DISPLAY_VER_ALL,\n\t\t.plane_caps = INTEL_PLANE_CAP_TILING_X,\n\t}, {\n\t\t.modifier = DRM_FORMAT_MOD_LINEAR,\n\t\t.display_ver = DISPLAY_VER_ALL,\n\t},\n};\n\nstatic const struct intel_modifier_desc *lookup_modifier_or_null(u64 modifier)\n{\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(intel_modifiers); i++)\n\t\tif (intel_modifiers[i].modifier == modifier)\n\t\t\treturn &intel_modifiers[i];\n\n\treturn NULL;\n}\n\nstatic const struct intel_modifier_desc *lookup_modifier(u64 modifier)\n{\n\tconst struct intel_modifier_desc *md = lookup_modifier_or_null(modifier);\n\n\tif (WARN_ON(!md))\n\t\treturn &intel_modifiers[0];\n\n\treturn md;\n}\n\nstatic const struct drm_format_info *\nlookup_format_info(const struct drm_format_info formats[],\n\t\t   int num_formats, u32 format)\n{\n\tint i;\n\n\tfor (i = 0; i < num_formats; i++) {\n\t\tif (formats[i].format == format)\n\t\t\treturn &formats[i];\n\t}\n\n\treturn NULL;\n}\n\n \nconst struct drm_format_info *\nintel_fb_get_format_info(const struct drm_mode_fb_cmd2 *cmd)\n{\n\tconst struct intel_modifier_desc *md = lookup_modifier_or_null(cmd->modifier[0]);\n\n\tif (!md || !md->formats)\n\t\treturn NULL;\n\n\treturn lookup_format_info(md->formats, md->format_count, cmd->pixel_format);\n}\n\nstatic bool plane_caps_contain_any(u8 caps, u8 mask)\n{\n\treturn caps & mask;\n}\n\nstatic bool plane_caps_contain_all(u8 caps, u8 mask)\n{\n\treturn (caps & mask) == mask;\n}\n\n \nbool intel_fb_is_tiled_modifier(u64 modifier)\n{\n\treturn plane_caps_contain_any(lookup_modifier(modifier)->plane_caps,\n\t\t\t\t      INTEL_PLANE_CAP_TILING_MASK);\n}\n\n \nbool intel_fb_is_ccs_modifier(u64 modifier)\n{\n\treturn plane_caps_contain_any(lookup_modifier(modifier)->plane_caps,\n\t\t\t\t      INTEL_PLANE_CAP_CCS_MASK);\n}\n\n \nbool intel_fb_is_rc_ccs_cc_modifier(u64 modifier)\n{\n\treturn plane_caps_contain_any(lookup_modifier(modifier)->plane_caps,\n\t\t\t\t      INTEL_PLANE_CAP_CCS_RC_CC);\n}\n\n \nbool intel_fb_is_mc_ccs_modifier(u64 modifier)\n{\n\treturn plane_caps_contain_any(lookup_modifier(modifier)->plane_caps,\n\t\t\t\t      INTEL_PLANE_CAP_CCS_MC);\n}\n\nstatic bool check_modifier_display_ver_range(const struct intel_modifier_desc *md,\n\t\t\t\t\t     u8 display_ver_from, u8 display_ver_until)\n{\n\treturn md->display_ver.from <= display_ver_until &&\n\t\tdisplay_ver_from <= md->display_ver.until;\n}\n\nstatic bool plane_has_modifier(struct drm_i915_private *i915,\n\t\t\t       u8 plane_caps,\n\t\t\t       const struct intel_modifier_desc *md)\n{\n\tif (!IS_DISPLAY_VER(i915, md->display_ver.from, md->display_ver.until))\n\t\treturn false;\n\n\tif (!plane_caps_contain_all(plane_caps, md->plane_caps))\n\t\treturn false;\n\n\t \n\tif (intel_fb_is_ccs_modifier(md->modifier) &&\n\t    HAS_FLAT_CCS(i915) != !md->ccs.packed_aux_planes)\n\t\treturn false;\n\n\treturn true;\n}\n\n \nu64 *intel_fb_plane_get_modifiers(struct drm_i915_private *i915,\n\t\t\t\t  u8 plane_caps)\n{\n\tu64 *list, *p;\n\tint count = 1;\t\t \n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(intel_modifiers); i++) {\n\t\tif (plane_has_modifier(i915, plane_caps, &intel_modifiers[i]))\n\t\t\tcount++;\n\t}\n\n\tlist = kmalloc_array(count, sizeof(*list), GFP_KERNEL);\n\tif (drm_WARN_ON(&i915->drm, !list))\n\t\treturn NULL;\n\n\tp = list;\n\tfor (i = 0; i < ARRAY_SIZE(intel_modifiers); i++) {\n\t\tif (plane_has_modifier(i915, plane_caps, &intel_modifiers[i]))\n\t\t\t*p++ = intel_modifiers[i].modifier;\n\t}\n\t*p++ = DRM_FORMAT_MOD_INVALID;\n\n\treturn list;\n}\n\n \nbool intel_fb_plane_supports_modifier(struct intel_plane *plane, u64 modifier)\n{\n\tint i;\n\n\tfor (i = 0; i < plane->base.modifier_count; i++)\n\t\tif (plane->base.modifiers[i] == modifier)\n\t\t\treturn true;\n\n\treturn false;\n}\n\nstatic bool format_is_yuv_semiplanar(const struct intel_modifier_desc *md,\n\t\t\t\t     const struct drm_format_info *info)\n{\n\tif (!info->is_yuv)\n\t\treturn false;\n\n\tif (hweight8(md->ccs.planar_aux_planes) == 2)\n\t\treturn info->num_planes == 4;\n\telse\n\t\treturn info->num_planes == 2;\n}\n\n \nbool intel_format_info_is_yuv_semiplanar(const struct drm_format_info *info,\n\t\t\t\t\t u64 modifier)\n{\n\treturn format_is_yuv_semiplanar(lookup_modifier(modifier), info);\n}\n\nstatic u8 ccs_aux_plane_mask(const struct intel_modifier_desc *md,\n\t\t\t     const struct drm_format_info *format)\n{\n\tif (format_is_yuv_semiplanar(md, format))\n\t\treturn md->ccs.planar_aux_planes;\n\telse\n\t\treturn md->ccs.packed_aux_planes;\n}\n\n \nbool intel_fb_is_ccs_aux_plane(const struct drm_framebuffer *fb, int color_plane)\n{\n\tconst struct intel_modifier_desc *md = lookup_modifier(fb->modifier);\n\n\treturn ccs_aux_plane_mask(md, fb->format) & BIT(color_plane);\n}\n\n \nstatic bool intel_fb_is_gen12_ccs_aux_plane(const struct drm_framebuffer *fb, int color_plane)\n{\n\tconst struct intel_modifier_desc *md = lookup_modifier(fb->modifier);\n\n\treturn check_modifier_display_ver_range(md, 12, 14) &&\n\t       ccs_aux_plane_mask(md, fb->format) & BIT(color_plane);\n}\n\n \nint intel_fb_rc_ccs_cc_plane(const struct drm_framebuffer *fb)\n{\n\tconst struct intel_modifier_desc *md = lookup_modifier(fb->modifier);\n\n\tif (!md->ccs.cc_planes)\n\t\treturn -1;\n\n\tdrm_WARN_ON_ONCE(fb->dev, hweight8(md->ccs.cc_planes) > 1);\n\n\treturn ilog2((int)md->ccs.cc_planes);\n}\n\nstatic bool is_gen12_ccs_cc_plane(const struct drm_framebuffer *fb, int color_plane)\n{\n\treturn intel_fb_rc_ccs_cc_plane(fb) == color_plane;\n}\n\nstatic bool is_semiplanar_uv_plane(const struct drm_framebuffer *fb, int color_plane)\n{\n\treturn intel_format_info_is_yuv_semiplanar(fb->format, fb->modifier) &&\n\t\tcolor_plane == 1;\n}\n\nbool is_surface_linear(const struct drm_framebuffer *fb, int color_plane)\n{\n\treturn fb->modifier == DRM_FORMAT_MOD_LINEAR ||\n\t       intel_fb_is_gen12_ccs_aux_plane(fb, color_plane) ||\n\t       is_gen12_ccs_cc_plane(fb, color_plane);\n}\n\nint main_to_ccs_plane(const struct drm_framebuffer *fb, int main_plane)\n{\n\tdrm_WARN_ON(fb->dev, !intel_fb_is_ccs_modifier(fb->modifier) ||\n\t\t    (main_plane && main_plane >= fb->format->num_planes / 2));\n\n\treturn fb->format->num_planes / 2 + main_plane;\n}\n\nint skl_ccs_to_main_plane(const struct drm_framebuffer *fb, int ccs_plane)\n{\n\tdrm_WARN_ON(fb->dev, !intel_fb_is_ccs_modifier(fb->modifier) ||\n\t\t    ccs_plane < fb->format->num_planes / 2);\n\n\tif (is_gen12_ccs_cc_plane(fb, ccs_plane))\n\t\treturn 0;\n\n\treturn ccs_plane - fb->format->num_planes / 2;\n}\n\nstatic unsigned int gen12_ccs_aux_stride(struct intel_framebuffer *fb, int ccs_plane)\n{\n\tint main_plane = skl_ccs_to_main_plane(&fb->base, ccs_plane);\n\tunsigned int main_stride = fb->base.pitches[main_plane];\n\tunsigned int main_tile_width = intel_tile_width_bytes(&fb->base, main_plane);\n\n\treturn DIV_ROUND_UP(main_stride, 4 * main_tile_width) * 64;\n}\n\nint skl_main_to_aux_plane(const struct drm_framebuffer *fb, int main_plane)\n{\n\tconst struct intel_modifier_desc *md = lookup_modifier(fb->modifier);\n\tstruct drm_i915_private *i915 = to_i915(fb->dev);\n\n\tif (md->ccs.packed_aux_planes | md->ccs.planar_aux_planes)\n\t\treturn main_to_ccs_plane(fb, main_plane);\n\telse if (DISPLAY_VER(i915) < 11 &&\n\t\t format_is_yuv_semiplanar(md, fb->format))\n\t\treturn 1;\n\telse\n\t\treturn 0;\n}\n\nunsigned int intel_tile_size(const struct drm_i915_private *i915)\n{\n\treturn DISPLAY_VER(i915) == 2 ? 2048 : 4096;\n}\n\nunsigned int\nintel_tile_width_bytes(const struct drm_framebuffer *fb, int color_plane)\n{\n\tstruct drm_i915_private *dev_priv = to_i915(fb->dev);\n\tunsigned int cpp = fb->format->cpp[color_plane];\n\n\tswitch (fb->modifier) {\n\tcase DRM_FORMAT_MOD_LINEAR:\n\t\treturn intel_tile_size(dev_priv);\n\tcase I915_FORMAT_MOD_X_TILED:\n\t\tif (DISPLAY_VER(dev_priv) == 2)\n\t\t\treturn 128;\n\t\telse\n\t\t\treturn 512;\n\tcase I915_FORMAT_MOD_4_TILED_DG2_RC_CCS:\n\tcase I915_FORMAT_MOD_4_TILED_DG2_RC_CCS_CC:\n\tcase I915_FORMAT_MOD_4_TILED_DG2_MC_CCS:\n\tcase I915_FORMAT_MOD_4_TILED:\n\t\t \n\t\treturn 128;\n\tcase I915_FORMAT_MOD_Y_TILED_CCS:\n\t\tif (intel_fb_is_ccs_aux_plane(fb, color_plane))\n\t\t\treturn 128;\n\t\tfallthrough;\n\tcase I915_FORMAT_MOD_4_TILED_MTL_RC_CCS:\n\tcase I915_FORMAT_MOD_4_TILED_MTL_RC_CCS_CC:\n\tcase I915_FORMAT_MOD_4_TILED_MTL_MC_CCS:\n\tcase I915_FORMAT_MOD_Y_TILED_GEN12_RC_CCS:\n\tcase I915_FORMAT_MOD_Y_TILED_GEN12_RC_CCS_CC:\n\tcase I915_FORMAT_MOD_Y_TILED_GEN12_MC_CCS:\n\t\tif (intel_fb_is_ccs_aux_plane(fb, color_plane) ||\n\t\t    is_gen12_ccs_cc_plane(fb, color_plane))\n\t\t\treturn 64;\n\t\tfallthrough;\n\tcase I915_FORMAT_MOD_Y_TILED:\n\t\tif (DISPLAY_VER(dev_priv) == 2 || HAS_128_BYTE_Y_TILING(dev_priv))\n\t\t\treturn 128;\n\t\telse\n\t\t\treturn 512;\n\tcase I915_FORMAT_MOD_Yf_TILED_CCS:\n\t\tif (intel_fb_is_ccs_aux_plane(fb, color_plane))\n\t\t\treturn 128;\n\t\tfallthrough;\n\tcase I915_FORMAT_MOD_Yf_TILED:\n\t\tswitch (cpp) {\n\t\tcase 1:\n\t\t\treturn 64;\n\t\tcase 2:\n\t\tcase 4:\n\t\t\treturn 128;\n\t\tcase 8:\n\t\tcase 16:\n\t\t\treturn 256;\n\t\tdefault:\n\t\t\tMISSING_CASE(cpp);\n\t\t\treturn cpp;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tMISSING_CASE(fb->modifier);\n\t\treturn cpp;\n\t}\n}\n\nunsigned int intel_tile_height(const struct drm_framebuffer *fb, int color_plane)\n{\n\treturn intel_tile_size(to_i915(fb->dev)) /\n\t\tintel_tile_width_bytes(fb, color_plane);\n}\n\n \nstatic void intel_tile_dims(const struct drm_framebuffer *fb, int color_plane,\n\t\t\t    unsigned int *tile_width,\n\t\t\t    unsigned int *tile_height)\n{\n\tunsigned int tile_width_bytes = intel_tile_width_bytes(fb, color_plane);\n\tunsigned int cpp = fb->format->cpp[color_plane];\n\n\t*tile_width = tile_width_bytes / cpp;\n\t*tile_height = intel_tile_height(fb, color_plane);\n}\n\n \nstatic void intel_tile_block_dims(const struct drm_framebuffer *fb, int color_plane,\n\t\t\t\t  unsigned int *tile_width,\n\t\t\t\t  unsigned int *tile_height)\n{\n\tintel_tile_dims(fb, color_plane, tile_width, tile_height);\n\n\tif (intel_fb_is_gen12_ccs_aux_plane(fb, color_plane))\n\t\t*tile_height = 1;\n}\n\nunsigned int intel_tile_row_size(const struct drm_framebuffer *fb, int color_plane)\n{\n\tunsigned int tile_width, tile_height;\n\n\tintel_tile_dims(fb, color_plane, &tile_width, &tile_height);\n\n\treturn fb->pitches[color_plane] * tile_height;\n}\n\nunsigned int\nintel_fb_align_height(const struct drm_framebuffer *fb,\n\t\t      int color_plane, unsigned int height)\n{\n\tunsigned int tile_height = intel_tile_height(fb, color_plane);\n\n\treturn ALIGN(height, tile_height);\n}\n\nstatic unsigned int intel_fb_modifier_to_tiling(u64 fb_modifier)\n{\n\tu8 tiling_caps = lookup_modifier(fb_modifier)->plane_caps &\n\t\t\t INTEL_PLANE_CAP_TILING_MASK;\n\n\tswitch (tiling_caps) {\n\tcase INTEL_PLANE_CAP_TILING_Y:\n\t\treturn I915_TILING_Y;\n\tcase INTEL_PLANE_CAP_TILING_X:\n\t\treturn I915_TILING_X;\n\tcase INTEL_PLANE_CAP_TILING_4:\n\tcase INTEL_PLANE_CAP_TILING_Yf:\n\tcase INTEL_PLANE_CAP_TILING_NONE:\n\t\treturn I915_TILING_NONE;\n\tdefault:\n\t\tMISSING_CASE(tiling_caps);\n\t\treturn I915_TILING_NONE;\n\t}\n}\n\nbool intel_fb_modifier_uses_dpt(struct drm_i915_private *i915, u64 modifier)\n{\n\treturn HAS_DPT(i915) && modifier != DRM_FORMAT_MOD_LINEAR;\n}\n\nbool intel_fb_uses_dpt(const struct drm_framebuffer *fb)\n{\n\treturn fb && to_i915(fb->dev)->params.enable_dpt &&\n\t\tintel_fb_modifier_uses_dpt(to_i915(fb->dev), fb->modifier);\n}\n\nunsigned int intel_cursor_alignment(const struct drm_i915_private *i915)\n{\n\tif (IS_I830(i915))\n\t\treturn 16 * 1024;\n\telse if (IS_I85X(i915))\n\t\treturn 256;\n\telse if (IS_I845G(i915) || IS_I865G(i915))\n\t\treturn 32;\n\telse\n\t\treturn 4 * 1024;\n}\n\nstatic unsigned int intel_linear_alignment(const struct drm_i915_private *dev_priv)\n{\n\tif (DISPLAY_VER(dev_priv) >= 9)\n\t\treturn 256 * 1024;\n\telse if (IS_I965G(dev_priv) || IS_I965GM(dev_priv) ||\n\t\t IS_VALLEYVIEW(dev_priv) || IS_CHERRYVIEW(dev_priv))\n\t\treturn 128 * 1024;\n\telse if (DISPLAY_VER(dev_priv) >= 4)\n\t\treturn 4 * 1024;\n\telse\n\t\treturn 0;\n}\n\nunsigned int intel_surf_alignment(const struct drm_framebuffer *fb,\n\t\t\t\t  int color_plane)\n{\n\tstruct drm_i915_private *dev_priv = to_i915(fb->dev);\n\n\tif (intel_fb_uses_dpt(fb))\n\t\treturn 512 * 4096;\n\n\t \n\tif (intel_fb_is_ccs_aux_plane(fb, color_plane))\n\t\treturn 4096;\n\n\tif (is_semiplanar_uv_plane(fb, color_plane)) {\n\t\t \n\t\tif (DISPLAY_VER(dev_priv) >= 12) {\n\t\t\tif (fb->modifier == DRM_FORMAT_MOD_LINEAR)\n\t\t\t\treturn intel_linear_alignment(dev_priv);\n\n\t\t\treturn intel_tile_row_size(fb, color_plane);\n\t\t}\n\n\t\treturn 4096;\n\t}\n\n\tdrm_WARN_ON(&dev_priv->drm, color_plane != 0);\n\n\tswitch (fb->modifier) {\n\tcase DRM_FORMAT_MOD_LINEAR:\n\t\treturn intel_linear_alignment(dev_priv);\n\tcase I915_FORMAT_MOD_X_TILED:\n\t\tif (HAS_ASYNC_FLIPS(dev_priv))\n\t\t\treturn 256 * 1024;\n\t\treturn 0;\n\tcase I915_FORMAT_MOD_Y_TILED_GEN12_MC_CCS:\n\tcase I915_FORMAT_MOD_Y_TILED_GEN12_RC_CCS:\n\tcase I915_FORMAT_MOD_Y_TILED_GEN12_RC_CCS_CC:\n\tcase I915_FORMAT_MOD_4_TILED_MTL_MC_CCS:\n\tcase I915_FORMAT_MOD_4_TILED_MTL_RC_CCS:\n\tcase I915_FORMAT_MOD_4_TILED_MTL_RC_CCS_CC:\n\t\treturn 16 * 1024;\n\tcase I915_FORMAT_MOD_Y_TILED_CCS:\n\tcase I915_FORMAT_MOD_Yf_TILED_CCS:\n\tcase I915_FORMAT_MOD_Y_TILED:\n\tcase I915_FORMAT_MOD_4_TILED:\n\tcase I915_FORMAT_MOD_Yf_TILED:\n\t\treturn 1 * 1024 * 1024;\n\tcase I915_FORMAT_MOD_4_TILED_DG2_RC_CCS:\n\tcase I915_FORMAT_MOD_4_TILED_DG2_RC_CCS_CC:\n\tcase I915_FORMAT_MOD_4_TILED_DG2_MC_CCS:\n\t\treturn 16 * 1024;\n\tdefault:\n\t\tMISSING_CASE(fb->modifier);\n\t\treturn 0;\n\t}\n}\n\nvoid intel_fb_plane_get_subsampling(int *hsub, int *vsub,\n\t\t\t\t    const struct drm_framebuffer *fb,\n\t\t\t\t    int color_plane)\n{\n\tint main_plane;\n\n\tif (color_plane == 0) {\n\t\t*hsub = 1;\n\t\t*vsub = 1;\n\n\t\treturn;\n\t}\n\n\t \n\tif (!intel_fb_is_gen12_ccs_aux_plane(fb, color_plane)) {\n\t\t*hsub = fb->format->hsub;\n\t\t*vsub = fb->format->vsub;\n\n\t\treturn;\n\t}\n\n\tmain_plane = skl_ccs_to_main_plane(fb, color_plane);\n\t*hsub = drm_format_info_block_width(fb->format, color_plane) /\n\t\tdrm_format_info_block_width(fb->format, main_plane);\n\n\t \n\tif (main_plane == 0)\n\t\t*hsub *= fb->format->hsub;\n\n\t*vsub = 32;\n}\n\nstatic void intel_fb_plane_dims(const struct intel_framebuffer *fb, int color_plane, int *w, int *h)\n{\n\tint main_plane = intel_fb_is_ccs_aux_plane(&fb->base, color_plane) ?\n\t\t\t skl_ccs_to_main_plane(&fb->base, color_plane) : 0;\n\tunsigned int main_width = fb->base.width;\n\tunsigned int main_height = fb->base.height;\n\tint main_hsub, main_vsub;\n\tint hsub, vsub;\n\n\tintel_fb_plane_get_subsampling(&main_hsub, &main_vsub, &fb->base, main_plane);\n\tintel_fb_plane_get_subsampling(&hsub, &vsub, &fb->base, color_plane);\n\n\t*w = DIV_ROUND_UP(main_width, main_hsub * hsub);\n\t*h = DIV_ROUND_UP(main_height, main_vsub * vsub);\n}\n\nstatic u32 intel_adjust_tile_offset(int *x, int *y,\n\t\t\t\t    unsigned int tile_width,\n\t\t\t\t    unsigned int tile_height,\n\t\t\t\t    unsigned int tile_size,\n\t\t\t\t    unsigned int pitch_tiles,\n\t\t\t\t    u32 old_offset,\n\t\t\t\t    u32 new_offset)\n{\n\tunsigned int pitch_pixels = pitch_tiles * tile_width;\n\tunsigned int tiles;\n\n\tWARN_ON(old_offset & (tile_size - 1));\n\tWARN_ON(new_offset & (tile_size - 1));\n\tWARN_ON(new_offset > old_offset);\n\n\ttiles = (old_offset - new_offset) / tile_size;\n\n\t*y += tiles / pitch_tiles * tile_height;\n\t*x += tiles % pitch_tiles * tile_width;\n\n\t \n\t*y += *x / pitch_pixels * tile_height;\n\t*x %= pitch_pixels;\n\n\treturn new_offset;\n}\n\nstatic u32 intel_adjust_linear_offset(int *x, int *y,\n\t\t\t\t      unsigned int cpp,\n\t\t\t\t      unsigned int pitch,\n\t\t\t\t      u32 old_offset,\n\t\t\t\t      u32 new_offset)\n{\n\told_offset += *y * pitch + *x * cpp;\n\n\t*y = (old_offset - new_offset) / pitch;\n\t*x = ((old_offset - new_offset) - *y * pitch) / cpp;\n\n\treturn new_offset;\n}\n\nstatic u32 intel_adjust_aligned_offset(int *x, int *y,\n\t\t\t\t       const struct drm_framebuffer *fb,\n\t\t\t\t       int color_plane,\n\t\t\t\t       unsigned int rotation,\n\t\t\t\t       unsigned int pitch,\n\t\t\t\t       u32 old_offset, u32 new_offset)\n{\n\tstruct drm_i915_private *i915 = to_i915(fb->dev);\n\tunsigned int cpp = fb->format->cpp[color_plane];\n\n\tdrm_WARN_ON(&i915->drm, new_offset > old_offset);\n\n\tif (!is_surface_linear(fb, color_plane)) {\n\t\tunsigned int tile_size, tile_width, tile_height;\n\t\tunsigned int pitch_tiles;\n\n\t\ttile_size = intel_tile_size(i915);\n\t\tintel_tile_dims(fb, color_plane, &tile_width, &tile_height);\n\n\t\tif (drm_rotation_90_or_270(rotation)) {\n\t\t\tpitch_tiles = pitch / tile_height;\n\t\t\tswap(tile_width, tile_height);\n\t\t} else {\n\t\t\tpitch_tiles = pitch / (tile_width * cpp);\n\t\t}\n\n\t\tintel_adjust_tile_offset(x, y, tile_width, tile_height,\n\t\t\t\t\t tile_size, pitch_tiles,\n\t\t\t\t\t old_offset, new_offset);\n\t} else {\n\t\tintel_adjust_linear_offset(x, y, cpp, pitch,\n\t\t\t\t\t   old_offset, new_offset);\n\t}\n\n\treturn new_offset;\n}\n\n \nu32 intel_plane_adjust_aligned_offset(int *x, int *y,\n\t\t\t\t      const struct intel_plane_state *state,\n\t\t\t\t      int color_plane,\n\t\t\t\t      u32 old_offset, u32 new_offset)\n{\n\treturn intel_adjust_aligned_offset(x, y, state->hw.fb, color_plane,\n\t\t\t\t\t   state->hw.rotation,\n\t\t\t\t\t   state->view.color_plane[color_plane].mapping_stride,\n\t\t\t\t\t   old_offset, new_offset);\n}\n\n \nstatic u32 intel_compute_aligned_offset(struct drm_i915_private *i915,\n\t\t\t\t\tint *x, int *y,\n\t\t\t\t\tconst struct drm_framebuffer *fb,\n\t\t\t\t\tint color_plane,\n\t\t\t\t\tunsigned int pitch,\n\t\t\t\t\tunsigned int rotation,\n\t\t\t\t\tu32 alignment)\n{\n\tunsigned int cpp = fb->format->cpp[color_plane];\n\tu32 offset, offset_aligned;\n\n\tif (!is_surface_linear(fb, color_plane)) {\n\t\tunsigned int tile_size, tile_width, tile_height;\n\t\tunsigned int tile_rows, tiles, pitch_tiles;\n\n\t\ttile_size = intel_tile_size(i915);\n\t\tintel_tile_dims(fb, color_plane, &tile_width, &tile_height);\n\n\t\tif (drm_rotation_90_or_270(rotation)) {\n\t\t\tpitch_tiles = pitch / tile_height;\n\t\t\tswap(tile_width, tile_height);\n\t\t} else {\n\t\t\tpitch_tiles = pitch / (tile_width * cpp);\n\t\t}\n\n\t\ttile_rows = *y / tile_height;\n\t\t*y %= tile_height;\n\n\t\ttiles = *x / tile_width;\n\t\t*x %= tile_width;\n\n\t\toffset = (tile_rows * pitch_tiles + tiles) * tile_size;\n\n\t\toffset_aligned = offset;\n\t\tif (alignment)\n\t\t\toffset_aligned = rounddown(offset_aligned, alignment);\n\n\t\tintel_adjust_tile_offset(x, y, tile_width, tile_height,\n\t\t\t\t\t tile_size, pitch_tiles,\n\t\t\t\t\t offset, offset_aligned);\n\t} else {\n\t\toffset = *y * pitch + *x * cpp;\n\t\toffset_aligned = offset;\n\t\tif (alignment) {\n\t\t\toffset_aligned = rounddown(offset_aligned, alignment);\n\t\t\t*y = (offset % alignment) / pitch;\n\t\t\t*x = ((offset % alignment) - *y * pitch) / cpp;\n\t\t} else {\n\t\t\t*y = *x = 0;\n\t\t}\n\t}\n\n\treturn offset_aligned;\n}\n\nu32 intel_plane_compute_aligned_offset(int *x, int *y,\n\t\t\t\t       const struct intel_plane_state *state,\n\t\t\t\t       int color_plane)\n{\n\tstruct intel_plane *intel_plane = to_intel_plane(state->uapi.plane);\n\tstruct drm_i915_private *i915 = to_i915(intel_plane->base.dev);\n\tconst struct drm_framebuffer *fb = state->hw.fb;\n\tunsigned int rotation = state->hw.rotation;\n\tint pitch = state->view.color_plane[color_plane].mapping_stride;\n\tu32 alignment;\n\n\tif (intel_plane->id == PLANE_CURSOR)\n\t\talignment = intel_cursor_alignment(i915);\n\telse\n\t\talignment = intel_surf_alignment(fb, color_plane);\n\n\treturn intel_compute_aligned_offset(i915, x, y, fb, color_plane,\n\t\t\t\t\t    pitch, rotation, alignment);\n}\n\n \nstatic int intel_fb_offset_to_xy(int *x, int *y,\n\t\t\t\t const struct drm_framebuffer *fb,\n\t\t\t\t int color_plane)\n{\n\tstruct drm_i915_private *i915 = to_i915(fb->dev);\n\tunsigned int height;\n\tu32 alignment;\n\n\tif (DISPLAY_VER(i915) >= 12 &&\n\t    !intel_fb_needs_pot_stride_remap(to_intel_framebuffer(fb)) &&\n\t    is_semiplanar_uv_plane(fb, color_plane))\n\t\talignment = intel_tile_row_size(fb, color_plane);\n\telse if (fb->modifier != DRM_FORMAT_MOD_LINEAR)\n\t\talignment = intel_tile_size(i915);\n\telse\n\t\talignment = 0;\n\n\tif (alignment != 0 && fb->offsets[color_plane] % alignment) {\n\t\tdrm_dbg_kms(&i915->drm,\n\t\t\t    \"Misaligned offset 0x%08x for color plane %d\\n\",\n\t\t\t    fb->offsets[color_plane], color_plane);\n\t\treturn -EINVAL;\n\t}\n\n\theight = drm_framebuffer_plane_height(fb->height, fb, color_plane);\n\theight = ALIGN(height, intel_tile_height(fb, color_plane));\n\n\t \n\tif (add_overflows_t(u32, mul_u32_u32(height, fb->pitches[color_plane]),\n\t\t\t    fb->offsets[color_plane])) {\n\t\tdrm_dbg_kms(&i915->drm,\n\t\t\t    \"Bad offset 0x%08x or pitch %d for color plane %d\\n\",\n\t\t\t    fb->offsets[color_plane], fb->pitches[color_plane],\n\t\t\t    color_plane);\n\t\treturn -ERANGE;\n\t}\n\n\t*x = 0;\n\t*y = 0;\n\n\tintel_adjust_aligned_offset(x, y,\n\t\t\t\t    fb, color_plane, DRM_MODE_ROTATE_0,\n\t\t\t\t    fb->pitches[color_plane],\n\t\t\t\t    fb->offsets[color_plane], 0);\n\n\treturn 0;\n}\n\nstatic int intel_fb_check_ccs_xy(const struct drm_framebuffer *fb, int ccs_plane, int x, int y)\n{\n\tstruct drm_i915_private *i915 = to_i915(fb->dev);\n\tconst struct intel_framebuffer *intel_fb = to_intel_framebuffer(fb);\n\tint main_plane;\n\tint hsub, vsub;\n\tint tile_width, tile_height;\n\tint ccs_x, ccs_y;\n\tint main_x, main_y;\n\n\tif (!intel_fb_is_ccs_aux_plane(fb, ccs_plane))\n\t\treturn 0;\n\n\t \n\tintel_tile_block_dims(fb, ccs_plane, &tile_width, &tile_height);\n\tintel_fb_plane_get_subsampling(&hsub, &vsub, fb, ccs_plane);\n\n\ttile_width *= hsub;\n\ttile_height *= vsub;\n\n\tccs_x = (x * hsub) % tile_width;\n\tccs_y = (y * vsub) % tile_height;\n\n\tmain_plane = skl_ccs_to_main_plane(fb, ccs_plane);\n\tmain_x = intel_fb->normal_view.color_plane[main_plane].x % tile_width;\n\tmain_y = intel_fb->normal_view.color_plane[main_plane].y % tile_height;\n\n\t \n\tif (main_x != ccs_x || main_y != ccs_y) {\n\t\tdrm_dbg_kms(&i915->drm,\n\t\t\t      \"Bad CCS x/y (main %d,%d ccs %d,%d) full (main %d,%d ccs %d,%d)\\n\",\n\t\t\t      main_x, main_y,\n\t\t\t      ccs_x, ccs_y,\n\t\t\t      intel_fb->normal_view.color_plane[main_plane].x,\n\t\t\t      intel_fb->normal_view.color_plane[main_plane].y,\n\t\t\t      x, y);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic bool intel_plane_can_remap(const struct intel_plane_state *plane_state)\n{\n\tstruct intel_plane *plane = to_intel_plane(plane_state->uapi.plane);\n\tstruct drm_i915_private *i915 = to_i915(plane->base.dev);\n\tconst struct drm_framebuffer *fb = plane_state->hw.fb;\n\tint i;\n\n\t \n\tif (plane->id == PLANE_CURSOR)\n\t\treturn false;\n\n\t \n\tif (DISPLAY_VER(i915) < 4)\n\t\treturn false;\n\n\t \n\tif (intel_fb_is_ccs_modifier(fb->modifier))\n\t\treturn false;\n\n\t \n\tif (fb->modifier == DRM_FORMAT_MOD_LINEAR) {\n\t\tunsigned int alignment = intel_tile_size(i915) - 1;\n\n\t\tfor (i = 0; i < fb->format->num_planes; i++) {\n\t\t\tif (fb->pitches[i] & alignment)\n\t\t\t\treturn false;\n\t\t}\n\t}\n\n\treturn true;\n}\n\nbool intel_fb_needs_pot_stride_remap(const struct intel_framebuffer *fb)\n{\n\tstruct drm_i915_private *i915 = to_i915(fb->base.dev);\n\n\treturn (IS_ALDERLAKE_P(i915) || DISPLAY_VER(i915) >= 14) &&\n\t\tintel_fb_uses_dpt(&fb->base);\n}\n\nstatic int intel_fb_pitch(const struct intel_framebuffer *fb, int color_plane, unsigned int rotation)\n{\n\tif (drm_rotation_90_or_270(rotation))\n\t\treturn fb->rotated_view.color_plane[color_plane].mapping_stride;\n\telse if (intel_fb_needs_pot_stride_remap(fb))\n\t\treturn fb->remapped_view.color_plane[color_plane].mapping_stride;\n\telse\n\t\treturn fb->normal_view.color_plane[color_plane].mapping_stride;\n}\n\nstatic bool intel_plane_needs_remap(const struct intel_plane_state *plane_state)\n{\n\tstruct intel_plane *plane = to_intel_plane(plane_state->uapi.plane);\n\tconst struct intel_framebuffer *fb = to_intel_framebuffer(plane_state->hw.fb);\n\tunsigned int rotation = plane_state->hw.rotation;\n\tu32 stride, max_stride;\n\n\t \n\tif (!plane_state->uapi.visible)\n\t\treturn false;\n\n\tif (!intel_plane_can_remap(plane_state))\n\t\treturn false;\n\n\t \n\tstride = intel_fb_pitch(fb, 0, rotation);\n\tmax_stride = plane->max_stride(plane, fb->base.format->format,\n\t\t\t\t       fb->base.modifier, rotation);\n\n\treturn stride > max_stride;\n}\n\nstatic int convert_plane_offset_to_xy(const struct intel_framebuffer *fb, int color_plane,\n\t\t\t\t      int plane_width, int *x, int *y)\n{\n\tstruct drm_i915_gem_object *obj = intel_fb_obj(&fb->base);\n\tint ret;\n\n\tret = intel_fb_offset_to_xy(x, y, &fb->base, color_plane);\n\tif (ret) {\n\t\tdrm_dbg_kms(fb->base.dev,\n\t\t\t    \"bad fb plane %d offset: 0x%x\\n\",\n\t\t\t    color_plane, fb->base.offsets[color_plane]);\n\t\treturn ret;\n\t}\n\n\tret = intel_fb_check_ccs_xy(&fb->base, color_plane, *x, *y);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tif (color_plane == 0 && i915_gem_object_is_tiled(obj) &&\n\t    (*x + plane_width) * fb->base.format->cpp[color_plane] > fb->base.pitches[color_plane]) {\n\t\tdrm_dbg_kms(fb->base.dev,\n\t\t\t    \"bad fb plane %d offset: 0x%x\\n\",\n\t\t\t    color_plane, fb->base.offsets[color_plane]);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic u32 calc_plane_aligned_offset(const struct intel_framebuffer *fb, int color_plane, int *x, int *y)\n{\n\tstruct drm_i915_private *i915 = to_i915(fb->base.dev);\n\tunsigned int tile_size = intel_tile_size(i915);\n\tu32 offset;\n\n\toffset = intel_compute_aligned_offset(i915, x, y, &fb->base, color_plane,\n\t\t\t\t\t      fb->base.pitches[color_plane],\n\t\t\t\t\t      DRM_MODE_ROTATE_0,\n\t\t\t\t\t      tile_size);\n\n\treturn offset / tile_size;\n}\n\nstruct fb_plane_view_dims {\n\tunsigned int width, height;\n\tunsigned int tile_width, tile_height;\n};\n\nstatic void init_plane_view_dims(const struct intel_framebuffer *fb, int color_plane,\n\t\t\t\t unsigned int width, unsigned int height,\n\t\t\t\t struct fb_plane_view_dims *dims)\n{\n\tdims->width = width;\n\tdims->height = height;\n\n\tintel_tile_dims(&fb->base, color_plane, &dims->tile_width, &dims->tile_height);\n}\n\nstatic unsigned int\nplane_view_src_stride_tiles(const struct intel_framebuffer *fb, int color_plane,\n\t\t\t    const struct fb_plane_view_dims *dims)\n{\n\treturn DIV_ROUND_UP(fb->base.pitches[color_plane],\n\t\t\t    dims->tile_width * fb->base.format->cpp[color_plane]);\n}\n\nstatic unsigned int\nplane_view_dst_stride_tiles(const struct intel_framebuffer *fb, int color_plane,\n\t\t\t    unsigned int pitch_tiles)\n{\n\tif (intel_fb_needs_pot_stride_remap(fb)) {\n\t\t \n\t\treturn roundup_pow_of_two(max(pitch_tiles, 8u));\n\t} else {\n\t\treturn pitch_tiles;\n\t}\n}\n\nstatic unsigned int\nplane_view_scanout_stride(const struct intel_framebuffer *fb, int color_plane,\n\t\t\t  unsigned int tile_width,\n\t\t\t  unsigned int src_stride_tiles, unsigned int dst_stride_tiles)\n{\n\tstruct drm_i915_private *i915 = to_i915(fb->base.dev);\n\tunsigned int stride_tiles;\n\n\tif ((IS_ALDERLAKE_P(i915) || DISPLAY_VER(i915) >= 14) &&\n\t    src_stride_tiles < dst_stride_tiles)\n\t\tstride_tiles = src_stride_tiles;\n\telse\n\t\tstride_tiles = dst_stride_tiles;\n\n\treturn stride_tiles * tile_width * fb->base.format->cpp[color_plane];\n}\n\nstatic unsigned int\nplane_view_width_tiles(const struct intel_framebuffer *fb, int color_plane,\n\t\t       const struct fb_plane_view_dims *dims,\n\t\t       int x)\n{\n\treturn DIV_ROUND_UP(x + dims->width, dims->tile_width);\n}\n\nstatic unsigned int\nplane_view_height_tiles(const struct intel_framebuffer *fb, int color_plane,\n\t\t\tconst struct fb_plane_view_dims *dims,\n\t\t\tint y)\n{\n\treturn DIV_ROUND_UP(y + dims->height, dims->tile_height);\n}\n\nstatic unsigned int\nplane_view_linear_tiles(const struct intel_framebuffer *fb, int color_plane,\n\t\t\tconst struct fb_plane_view_dims *dims,\n\t\t\tint x, int y)\n{\n\tstruct drm_i915_private *i915 = to_i915(fb->base.dev);\n\tunsigned int size;\n\n\tsize = (y + dims->height) * fb->base.pitches[color_plane] +\n\t\tx * fb->base.format->cpp[color_plane];\n\n\treturn DIV_ROUND_UP(size, intel_tile_size(i915));\n}\n\n#define assign_chk_ovf(i915, var, val) ({ \\\n\tdrm_WARN_ON(&(i915)->drm, overflows_type(val, var)); \\\n\t(var) = (val); \\\n})\n\n#define assign_bfld_chk_ovf(i915, var, val) ({ \\\n\t(var) = (val); \\\n\tdrm_WARN_ON(&(i915)->drm, (var) != (val)); \\\n\t(var); \\\n})\n\nstatic u32 calc_plane_remap_info(const struct intel_framebuffer *fb, int color_plane,\n\t\t\t\t const struct fb_plane_view_dims *dims,\n\t\t\t\t u32 obj_offset, u32 gtt_offset, int x, int y,\n\t\t\t\t struct intel_fb_view *view)\n{\n\tstruct drm_i915_private *i915 = to_i915(fb->base.dev);\n\tstruct intel_remapped_plane_info *remap_info = &view->gtt.remapped.plane[color_plane];\n\tstruct i915_color_plane_view *color_plane_info = &view->color_plane[color_plane];\n\tunsigned int tile_width = dims->tile_width;\n\tunsigned int tile_height = dims->tile_height;\n\tunsigned int tile_size = intel_tile_size(i915);\n\tstruct drm_rect r;\n\tu32 size = 0;\n\n\tassign_bfld_chk_ovf(i915, remap_info->offset, obj_offset);\n\n\tif (intel_fb_is_gen12_ccs_aux_plane(&fb->base, color_plane)) {\n\t\tremap_info->linear = 1;\n\n\t\tassign_chk_ovf(i915, remap_info->size,\n\t\t\t       plane_view_linear_tiles(fb, color_plane, dims, x, y));\n\t} else {\n\t\tremap_info->linear = 0;\n\n\t\tassign_chk_ovf(i915, remap_info->src_stride,\n\t\t\t       plane_view_src_stride_tiles(fb, color_plane, dims));\n\t\tassign_chk_ovf(i915, remap_info->width,\n\t\t\t       plane_view_width_tiles(fb, color_plane, dims, x));\n\t\tassign_chk_ovf(i915, remap_info->height,\n\t\t\t       plane_view_height_tiles(fb, color_plane, dims, y));\n\t}\n\n\tif (view->gtt.type == I915_GTT_VIEW_ROTATED) {\n\t\tdrm_WARN_ON(&i915->drm, remap_info->linear);\n\t\tcheck_array_bounds(i915, view->gtt.rotated.plane, color_plane);\n\n\t\tassign_chk_ovf(i915, remap_info->dst_stride,\n\t\t\t       plane_view_dst_stride_tiles(fb, color_plane, remap_info->height));\n\n\t\t \n\t\tdrm_rect_init(&r, x, y, dims->width, dims->height);\n\t\tdrm_rect_rotate(&r,\n\t\t\t\tremap_info->width * tile_width,\n\t\t\t\tremap_info->height * tile_height,\n\t\t\t\tDRM_MODE_ROTATE_270);\n\n\t\tcolor_plane_info->x = r.x1;\n\t\tcolor_plane_info->y = r.y1;\n\n\t\tcolor_plane_info->mapping_stride = remap_info->dst_stride * tile_height;\n\t\tcolor_plane_info->scanout_stride = color_plane_info->mapping_stride;\n\n\t\tsize += remap_info->dst_stride * remap_info->width;\n\n\t\t \n\t\tswap(tile_width, tile_height);\n\t} else {\n\t\tdrm_WARN_ON(&i915->drm, view->gtt.type != I915_GTT_VIEW_REMAPPED);\n\n\t\tcheck_array_bounds(i915, view->gtt.remapped.plane, color_plane);\n\n\t\tif (view->gtt.remapped.plane_alignment) {\n\t\t\tunsigned int aligned_offset = ALIGN(gtt_offset,\n\t\t\t\t\t\t\t    view->gtt.remapped.plane_alignment);\n\n\t\t\tsize += aligned_offset - gtt_offset;\n\t\t\tgtt_offset = aligned_offset;\n\t\t}\n\n\t\tcolor_plane_info->x = x;\n\t\tcolor_plane_info->y = y;\n\n\t\tif (remap_info->linear) {\n\t\t\tcolor_plane_info->mapping_stride = fb->base.pitches[color_plane];\n\t\t\tcolor_plane_info->scanout_stride = color_plane_info->mapping_stride;\n\n\t\t\tsize += remap_info->size;\n\t\t} else {\n\t\t\tunsigned int dst_stride;\n\n\t\t\t \n\t\t\tif (intel_fb_needs_pot_stride_remap(fb) &&\n\t\t\t    intel_fb_is_ccs_modifier(fb->base.modifier))\n\t\t\t\tdst_stride = remap_info->src_stride;\n\t\t\telse\n\t\t\t\tdst_stride = remap_info->width;\n\n\t\t\tdst_stride = plane_view_dst_stride_tiles(fb, color_plane, dst_stride);\n\n\t\t\tassign_chk_ovf(i915, remap_info->dst_stride, dst_stride);\n\t\t\tcolor_plane_info->mapping_stride = dst_stride *\n\t\t\t\t\t\t\t   tile_width *\n\t\t\t\t\t\t\t   fb->base.format->cpp[color_plane];\n\t\t\tcolor_plane_info->scanout_stride =\n\t\t\t\tplane_view_scanout_stride(fb, color_plane, tile_width,\n\t\t\t\t\t\t\t  remap_info->src_stride,\n\t\t\t\t\t\t\t  dst_stride);\n\n\t\t\tsize += dst_stride * remap_info->height;\n\t\t}\n\t}\n\n\t \n\tif (remap_info->linear)\n\t\tintel_adjust_linear_offset(&color_plane_info->x, &color_plane_info->y,\n\t\t\t\t\t   fb->base.format->cpp[color_plane],\n\t\t\t\t\t   color_plane_info->mapping_stride,\n\t\t\t\t\t   gtt_offset * tile_size, 0);\n\telse\n\t\tintel_adjust_tile_offset(&color_plane_info->x, &color_plane_info->y,\n\t\t\t\t\t tile_width, tile_height,\n\t\t\t\t\t tile_size, remap_info->dst_stride,\n\t\t\t\t\t gtt_offset * tile_size, 0);\n\n\treturn size;\n}\n\n#undef assign_chk_ovf\n\n \nstatic unsigned int\ncalc_plane_normal_size(const struct intel_framebuffer *fb, int color_plane,\n\t\t       const struct fb_plane_view_dims *dims,\n\t\t       int x, int y)\n{\n\tunsigned int tiles;\n\n\tif (is_surface_linear(&fb->base, color_plane)) {\n\t\ttiles = plane_view_linear_tiles(fb, color_plane, dims, x, y);\n\t} else {\n\t\ttiles = plane_view_src_stride_tiles(fb, color_plane, dims) *\n\t\t\tplane_view_height_tiles(fb, color_plane, dims, y);\n\t\t \n\t\tif (x != 0)\n\t\t\ttiles++;\n\t}\n\n\treturn tiles;\n}\n\nstatic void intel_fb_view_init(struct drm_i915_private *i915, struct intel_fb_view *view,\n\t\t\t       enum i915_gtt_view_type view_type)\n{\n\tmemset(view, 0, sizeof(*view));\n\tview->gtt.type = view_type;\n\n\tif (view_type == I915_GTT_VIEW_REMAPPED &&\n\t    (IS_ALDERLAKE_P(i915) || DISPLAY_VER(i915) >= 14))\n\t\tview->gtt.remapped.plane_alignment = SZ_2M / PAGE_SIZE;\n}\n\nbool intel_fb_supports_90_270_rotation(const struct intel_framebuffer *fb)\n{\n\tif (DISPLAY_VER(to_i915(fb->base.dev)) >= 13)\n\t\treturn false;\n\n\treturn fb->base.modifier == I915_FORMAT_MOD_Y_TILED ||\n\t       fb->base.modifier == I915_FORMAT_MOD_Yf_TILED;\n}\n\nint intel_fill_fb_info(struct drm_i915_private *i915, struct intel_framebuffer *fb)\n{\n\tstruct drm_i915_gem_object *obj = intel_fb_obj(&fb->base);\n\tu32 gtt_offset_rotated = 0;\n\tu32 gtt_offset_remapped = 0;\n\tunsigned int max_size = 0;\n\tint i, num_planes = fb->base.format->num_planes;\n\tunsigned int tile_size = intel_tile_size(i915);\n\n\tintel_fb_view_init(i915, &fb->normal_view, I915_GTT_VIEW_NORMAL);\n\n\tdrm_WARN_ON(&i915->drm,\n\t\t    intel_fb_supports_90_270_rotation(fb) &&\n\t\t    intel_fb_needs_pot_stride_remap(fb));\n\n\tif (intel_fb_supports_90_270_rotation(fb))\n\t\tintel_fb_view_init(i915, &fb->rotated_view, I915_GTT_VIEW_ROTATED);\n\tif (intel_fb_needs_pot_stride_remap(fb))\n\t\tintel_fb_view_init(i915, &fb->remapped_view, I915_GTT_VIEW_REMAPPED);\n\n\tfor (i = 0; i < num_planes; i++) {\n\t\tstruct fb_plane_view_dims view_dims;\n\t\tunsigned int width, height;\n\t\tunsigned int size;\n\t\tu32 offset;\n\t\tint x, y;\n\t\tint ret;\n\n\t\t \n\t\tif (is_gen12_ccs_cc_plane(&fb->base, i)) {\n\t\t\tif (IS_ALIGNED(fb->base.offsets[i], PAGE_SIZE))\n\t\t\t\tcontinue;\n\t\t\telse\n\t\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tintel_fb_plane_dims(fb, i, &width, &height);\n\n\t\tret = convert_plane_offset_to_xy(fb, i, width, &x, &y);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tinit_plane_view_dims(fb, i, width, height, &view_dims);\n\n\t\t \n\t\tfb->normal_view.color_plane[i].x = x;\n\t\tfb->normal_view.color_plane[i].y = y;\n\t\tfb->normal_view.color_plane[i].mapping_stride = fb->base.pitches[i];\n\t\tfb->normal_view.color_plane[i].scanout_stride =\n\t\t\tfb->normal_view.color_plane[i].mapping_stride;\n\n\t\toffset = calc_plane_aligned_offset(fb, i, &x, &y);\n\n\t\tif (intel_fb_supports_90_270_rotation(fb))\n\t\t\tgtt_offset_rotated += calc_plane_remap_info(fb, i, &view_dims,\n\t\t\t\t\t\t\t\t    offset, gtt_offset_rotated, x, y,\n\t\t\t\t\t\t\t\t    &fb->rotated_view);\n\n\t\tif (intel_fb_needs_pot_stride_remap(fb))\n\t\t\tgtt_offset_remapped += calc_plane_remap_info(fb, i, &view_dims,\n\t\t\t\t\t\t\t\t     offset, gtt_offset_remapped, x, y,\n\t\t\t\t\t\t\t\t     &fb->remapped_view);\n\n\t\tsize = calc_plane_normal_size(fb, i, &view_dims, x, y);\n\t\t \n\t\tmax_size = max(max_size, offset + size);\n\t}\n\n\tif (mul_u32_u32(max_size, tile_size) > obj->base.size) {\n\t\tdrm_dbg_kms(&i915->drm,\n\t\t\t    \"fb too big for bo (need %llu bytes, have %zu bytes)\\n\",\n\t\t\t    mul_u32_u32(max_size, tile_size), obj->base.size);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic void intel_plane_remap_gtt(struct intel_plane_state *plane_state)\n{\n\tstruct drm_i915_private *i915 =\n\t\tto_i915(plane_state->uapi.plane->dev);\n\tstruct drm_framebuffer *fb = plane_state->hw.fb;\n\tstruct intel_framebuffer *intel_fb = to_intel_framebuffer(fb);\n\tunsigned int rotation = plane_state->hw.rotation;\n\tint i, num_planes = fb->format->num_planes;\n\tunsigned int src_x, src_y;\n\tunsigned int src_w, src_h;\n\tu32 gtt_offset = 0;\n\n\tintel_fb_view_init(i915, &plane_state->view,\n\t\t\t   drm_rotation_90_or_270(rotation) ? I915_GTT_VIEW_ROTATED :\n\t\t\t\t\t\t\t      I915_GTT_VIEW_REMAPPED);\n\n\tsrc_x = plane_state->uapi.src.x1 >> 16;\n\tsrc_y = plane_state->uapi.src.y1 >> 16;\n\tsrc_w = drm_rect_width(&plane_state->uapi.src) >> 16;\n\tsrc_h = drm_rect_height(&plane_state->uapi.src) >> 16;\n\n\tdrm_WARN_ON(&i915->drm, intel_fb_is_ccs_modifier(fb->modifier));\n\n\t \n\tdrm_rect_translate(&plane_state->uapi.src,\n\t\t\t   -(src_x << 16), -(src_y << 16));\n\n\t \n\tif (drm_rotation_90_or_270(rotation))\n\t\tdrm_rect_rotate(&plane_state->uapi.src,\n\t\t\t\tsrc_w << 16, src_h << 16,\n\t\t\t\tDRM_MODE_ROTATE_270);\n\n\tfor (i = 0; i < num_planes; i++) {\n\t\tunsigned int hsub = i ? fb->format->hsub : 1;\n\t\tunsigned int vsub = i ? fb->format->vsub : 1;\n\t\tstruct fb_plane_view_dims view_dims;\n\t\tunsigned int width, height;\n\t\tunsigned int x, y;\n\t\tu32 offset;\n\n\t\tx = src_x / hsub;\n\t\ty = src_y / vsub;\n\t\twidth = src_w / hsub;\n\t\theight = src_h / vsub;\n\n\t\tinit_plane_view_dims(intel_fb, i, width, height, &view_dims);\n\n\t\t \n\t\tx += intel_fb->normal_view.color_plane[i].x;\n\t\ty += intel_fb->normal_view.color_plane[i].y;\n\n\t\toffset = calc_plane_aligned_offset(intel_fb, i, &x, &y);\n\n\t\tgtt_offset += calc_plane_remap_info(intel_fb, i, &view_dims,\n\t\t\t\t\t\t    offset, gtt_offset, x, y,\n\t\t\t\t\t\t    &plane_state->view);\n\t}\n}\n\nvoid intel_fb_fill_view(const struct intel_framebuffer *fb, unsigned int rotation,\n\t\t\tstruct intel_fb_view *view)\n{\n\tif (drm_rotation_90_or_270(rotation))\n\t\t*view = fb->rotated_view;\n\telse if (intel_fb_needs_pot_stride_remap(fb))\n\t\t*view = fb->remapped_view;\n\telse\n\t\t*view = fb->normal_view;\n}\n\nstatic\nu32 intel_fb_max_stride(struct drm_i915_private *dev_priv,\n\t\t\tu32 pixel_format, u64 modifier)\n{\n\t \n\tif (DISPLAY_VER(dev_priv) < 4 || intel_fb_is_ccs_modifier(modifier) ||\n\t    intel_fb_modifier_uses_dpt(dev_priv, modifier))\n\t\treturn intel_plane_fb_max_stride(dev_priv, pixel_format, modifier);\n\telse if (DISPLAY_VER(dev_priv) >= 7)\n\t\treturn 256 * 1024;\n\telse\n\t\treturn 128 * 1024;\n}\n\nstatic u32\nintel_fb_stride_alignment(const struct drm_framebuffer *fb, int color_plane)\n{\n\tstruct drm_i915_private *dev_priv = to_i915(fb->dev);\n\tu32 tile_width;\n\n\tif (is_surface_linear(fb, color_plane)) {\n\t\tu32 max_stride = intel_plane_fb_max_stride(dev_priv,\n\t\t\t\t\t\t\t   fb->format->format,\n\t\t\t\t\t\t\t   fb->modifier);\n\n\t\t \n\t\tif (fb->pitches[color_plane] > max_stride &&\n\t\t    !intel_fb_is_ccs_modifier(fb->modifier))\n\t\t\treturn intel_tile_size(dev_priv);\n\t\telse\n\t\t\treturn 64;\n\t}\n\n\ttile_width = intel_tile_width_bytes(fb, color_plane);\n\tif (intel_fb_is_ccs_modifier(fb->modifier)) {\n\t\t \n\t\tif (DISPLAY_VER(dev_priv) >= 12)\n\t\t\ttile_width *= 4;\n\t\t \n\t\telse if ((DISPLAY_VER(dev_priv) == 9 || IS_GEMINILAKE(dev_priv)) &&\n\t\t\t color_plane == 0 && fb->width > 3840)\n\t\t\ttile_width *= 4;\n\t}\n\treturn tile_width;\n}\n\nstatic int intel_plane_check_stride(const struct intel_plane_state *plane_state)\n{\n\tstruct intel_plane *plane = to_intel_plane(plane_state->uapi.plane);\n\tconst struct drm_framebuffer *fb = plane_state->hw.fb;\n\tunsigned int rotation = plane_state->hw.rotation;\n\tu32 stride, max_stride;\n\n\t \n\tif (intel_plane_can_remap(plane_state) &&\n\t    !plane_state->uapi.visible)\n\t\treturn 0;\n\n\t \n\tstride = plane_state->view.color_plane[0].mapping_stride;\n\tmax_stride = plane->max_stride(plane, fb->format->format,\n\t\t\t\t       fb->modifier, rotation);\n\n\tif (stride > max_stride) {\n\t\tDRM_DEBUG_KMS(\"[FB:%d] stride (%d) exceeds [PLANE:%d:%s] max stride (%d)\\n\",\n\t\t\t      fb->base.id, stride,\n\t\t\t      plane->base.base.id, plane->base.name, max_stride);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nint intel_plane_compute_gtt(struct intel_plane_state *plane_state)\n{\n\tconst struct intel_framebuffer *fb =\n\t\tto_intel_framebuffer(plane_state->hw.fb);\n\tunsigned int rotation = plane_state->hw.rotation;\n\n\tif (!fb)\n\t\treturn 0;\n\n\tif (intel_plane_needs_remap(plane_state)) {\n\t\tintel_plane_remap_gtt(plane_state);\n\n\t\t \n\t\treturn intel_plane_check_stride(plane_state);\n\t}\n\n\tintel_fb_fill_view(fb, rotation, &plane_state->view);\n\n\t \n\tif (drm_rotation_90_or_270(rotation))\n\t\tdrm_rect_rotate(&plane_state->uapi.src,\n\t\t\t\tfb->base.width << 16, fb->base.height << 16,\n\t\t\t\tDRM_MODE_ROTATE_270);\n\n\treturn intel_plane_check_stride(plane_state);\n}\n\nstatic void intel_user_framebuffer_destroy(struct drm_framebuffer *fb)\n{\n\tstruct intel_framebuffer *intel_fb = to_intel_framebuffer(fb);\n\n\tdrm_framebuffer_cleanup(fb);\n\n\tif (intel_fb_uses_dpt(fb))\n\t\tintel_dpt_destroy(intel_fb->dpt_vm);\n\n\tintel_frontbuffer_put(intel_fb->frontbuffer);\n\n\tkfree(intel_fb);\n}\n\nstatic int intel_user_framebuffer_create_handle(struct drm_framebuffer *fb,\n\t\t\t\t\t\tstruct drm_file *file,\n\t\t\t\t\t\tunsigned int *handle)\n{\n\tstruct drm_i915_gem_object *obj = intel_fb_obj(fb);\n\tstruct drm_i915_private *i915 = to_i915(obj->base.dev);\n\n\tif (i915_gem_object_is_userptr(obj)) {\n\t\tdrm_dbg(&i915->drm,\n\t\t\t\"attempting to use a userptr for a framebuffer, denied\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn drm_gem_handle_create(file, &obj->base, handle);\n}\n\nstatic int intel_user_framebuffer_dirty(struct drm_framebuffer *fb,\n\t\t\t\t\tstruct drm_file *file,\n\t\t\t\t\tunsigned int flags, unsigned int color,\n\t\t\t\t\tstruct drm_clip_rect *clips,\n\t\t\t\t\tunsigned int num_clips)\n{\n\tstruct drm_i915_gem_object *obj = intel_fb_obj(fb);\n\n\ti915_gem_object_flush_if_display(obj);\n\tintel_frontbuffer_flush(to_intel_frontbuffer(fb), ORIGIN_DIRTYFB);\n\n\treturn 0;\n}\n\nstatic const struct drm_framebuffer_funcs intel_fb_funcs = {\n\t.destroy = intel_user_framebuffer_destroy,\n\t.create_handle = intel_user_framebuffer_create_handle,\n\t.dirty = intel_user_framebuffer_dirty,\n};\n\nint intel_framebuffer_init(struct intel_framebuffer *intel_fb,\n\t\t\t   struct drm_i915_gem_object *obj,\n\t\t\t   struct drm_mode_fb_cmd2 *mode_cmd)\n{\n\tstruct drm_i915_private *dev_priv = to_i915(obj->base.dev);\n\tstruct drm_framebuffer *fb = &intel_fb->base;\n\tu32 max_stride;\n\tunsigned int tiling, stride;\n\tint ret = -EINVAL;\n\tint i;\n\n\tintel_fb->frontbuffer = intel_frontbuffer_get(obj);\n\tif (!intel_fb->frontbuffer)\n\t\treturn -ENOMEM;\n\n\ti915_gem_object_lock(obj, NULL);\n\ttiling = i915_gem_object_get_tiling(obj);\n\tstride = i915_gem_object_get_stride(obj);\n\ti915_gem_object_unlock(obj);\n\n\tif (mode_cmd->flags & DRM_MODE_FB_MODIFIERS) {\n\t\t \n\t\tif (tiling != I915_TILING_NONE &&\n\t\t    tiling != intel_fb_modifier_to_tiling(mode_cmd->modifier[0])) {\n\t\t\tdrm_dbg_kms(&dev_priv->drm,\n\t\t\t\t    \"tiling_mode doesn't match fb modifier\\n\");\n\t\t\tgoto err;\n\t\t}\n\t} else {\n\t\tif (tiling == I915_TILING_X) {\n\t\t\tmode_cmd->modifier[0] = I915_FORMAT_MOD_X_TILED;\n\t\t} else if (tiling == I915_TILING_Y) {\n\t\t\tdrm_dbg_kms(&dev_priv->drm,\n\t\t\t\t    \"No Y tiling for legacy addfb\\n\");\n\t\t\tgoto err;\n\t\t}\n\t}\n\n\tif (!drm_any_plane_has_format(&dev_priv->drm,\n\t\t\t\t      mode_cmd->pixel_format,\n\t\t\t\t      mode_cmd->modifier[0])) {\n\t\tdrm_dbg_kms(&dev_priv->drm,\n\t\t\t    \"unsupported pixel format %p4cc / modifier 0x%llx\\n\",\n\t\t\t    &mode_cmd->pixel_format, mode_cmd->modifier[0]);\n\t\tgoto err;\n\t}\n\n\t \n\tif (DISPLAY_VER(dev_priv) < 4 &&\n\t    tiling != intel_fb_modifier_to_tiling(mode_cmd->modifier[0])) {\n\t\tdrm_dbg_kms(&dev_priv->drm,\n\t\t\t    \"tiling_mode must match fb modifier exactly on gen2/3\\n\");\n\t\tgoto err;\n\t}\n\n\tmax_stride = intel_fb_max_stride(dev_priv, mode_cmd->pixel_format,\n\t\t\t\t\t mode_cmd->modifier[0]);\n\tif (mode_cmd->pitches[0] > max_stride) {\n\t\tdrm_dbg_kms(&dev_priv->drm,\n\t\t\t    \"%s pitch (%u) must be at most %d\\n\",\n\t\t\t    mode_cmd->modifier[0] != DRM_FORMAT_MOD_LINEAR ?\n\t\t\t    \"tiled\" : \"linear\",\n\t\t\t    mode_cmd->pitches[0], max_stride);\n\t\tgoto err;\n\t}\n\n\t \n\tif (tiling != I915_TILING_NONE && mode_cmd->pitches[0] != stride) {\n\t\tdrm_dbg_kms(&dev_priv->drm,\n\t\t\t    \"pitch (%d) must match tiling stride (%d)\\n\",\n\t\t\t    mode_cmd->pitches[0], stride);\n\t\tgoto err;\n\t}\n\n\t \n\tif (mode_cmd->offsets[0] != 0) {\n\t\tdrm_dbg_kms(&dev_priv->drm,\n\t\t\t    \"plane 0 offset (0x%08x) must be 0\\n\",\n\t\t\t    mode_cmd->offsets[0]);\n\t\tgoto err;\n\t}\n\n\tdrm_helper_mode_fill_fb_struct(&dev_priv->drm, fb, mode_cmd);\n\n\tfor (i = 0; i < fb->format->num_planes; i++) {\n\t\tu32 stride_alignment;\n\n\t\tif (mode_cmd->handles[i] != mode_cmd->handles[0]) {\n\t\t\tdrm_dbg_kms(&dev_priv->drm, \"bad plane %d handle\\n\",\n\t\t\t\t    i);\n\t\t\tgoto err;\n\t\t}\n\n\t\tstride_alignment = intel_fb_stride_alignment(fb, i);\n\t\tif (fb->pitches[i] & (stride_alignment - 1)) {\n\t\t\tdrm_dbg_kms(&dev_priv->drm,\n\t\t\t\t    \"plane %d pitch (%d) must be at least %u byte aligned\\n\",\n\t\t\t\t    i, fb->pitches[i], stride_alignment);\n\t\t\tgoto err;\n\t\t}\n\n\t\tif (intel_fb_is_gen12_ccs_aux_plane(fb, i)) {\n\t\t\tint ccs_aux_stride = gen12_ccs_aux_stride(intel_fb, i);\n\n\t\t\tif (fb->pitches[i] != ccs_aux_stride) {\n\t\t\t\tdrm_dbg_kms(&dev_priv->drm,\n\t\t\t\t\t    \"ccs aux plane %d pitch (%d) must be %d\\n\",\n\t\t\t\t\t    i,\n\t\t\t\t\t    fb->pitches[i], ccs_aux_stride);\n\t\t\t\tgoto err;\n\t\t\t}\n\t\t}\n\n\t\tfb->obj[i] = &obj->base;\n\t}\n\n\tret = intel_fill_fb_info(dev_priv, intel_fb);\n\tif (ret)\n\t\tgoto err;\n\n\tif (intel_fb_uses_dpt(fb)) {\n\t\tstruct i915_address_space *vm;\n\n\t\tvm = intel_dpt_create(intel_fb);\n\t\tif (IS_ERR(vm)) {\n\t\t\tdrm_dbg_kms(&dev_priv->drm, \"failed to create DPT\\n\");\n\t\t\tret = PTR_ERR(vm);\n\t\t\tgoto err;\n\t\t}\n\n\t\tintel_fb->dpt_vm = vm;\n\t}\n\n\tret = drm_framebuffer_init(&dev_priv->drm, fb, &intel_fb_funcs);\n\tif (ret) {\n\t\tdrm_err(&dev_priv->drm, \"framebuffer init failed %d\\n\", ret);\n\t\tgoto err_free_dpt;\n\t}\n\n\treturn 0;\n\nerr_free_dpt:\n\tif (intel_fb_uses_dpt(fb))\n\t\tintel_dpt_destroy(intel_fb->dpt_vm);\nerr:\n\tintel_frontbuffer_put(intel_fb->frontbuffer);\n\treturn ret;\n}\n\nstruct drm_framebuffer *\nintel_user_framebuffer_create(struct drm_device *dev,\n\t\t\t      struct drm_file *filp,\n\t\t\t      const struct drm_mode_fb_cmd2 *user_mode_cmd)\n{\n\tstruct drm_framebuffer *fb;\n\tstruct drm_i915_gem_object *obj;\n\tstruct drm_mode_fb_cmd2 mode_cmd = *user_mode_cmd;\n\tstruct drm_i915_private *i915;\n\n\tobj = i915_gem_object_lookup(filp, mode_cmd.handles[0]);\n\tif (!obj)\n\t\treturn ERR_PTR(-ENOENT);\n\n\t \n\ti915 = to_i915(obj->base.dev);\n\tif (HAS_LMEM(i915) && !i915_gem_object_can_migrate(obj, INTEL_REGION_LMEM_0)) {\n\t\t \n\t\ti915_gem_object_put(obj);\n\t\tdrm_dbg_kms(&i915->drm, \"framebuffer must reside in local memory\\n\");\n\t\treturn ERR_PTR(-EREMOTE);\n\t}\n\n\tfb = intel_framebuffer_create(obj, &mode_cmd);\n\ti915_gem_object_put(obj);\n\n\treturn fb;\n}\n\nstruct drm_framebuffer *\nintel_framebuffer_create(struct drm_i915_gem_object *obj,\n\t\t\t struct drm_mode_fb_cmd2 *mode_cmd)\n{\n\tstruct intel_framebuffer *intel_fb;\n\tint ret;\n\n\tintel_fb = kzalloc(sizeof(*intel_fb), GFP_KERNEL);\n\tif (!intel_fb)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tret = intel_framebuffer_init(intel_fb, obj, mode_cmd);\n\tif (ret)\n\t\tgoto err;\n\n\treturn &intel_fb->base;\n\nerr:\n\tkfree(intel_fb);\n\treturn ERR_PTR(ret);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}