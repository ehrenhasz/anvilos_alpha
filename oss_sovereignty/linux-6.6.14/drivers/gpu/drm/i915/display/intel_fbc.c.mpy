{
  "module_name": "intel_fbc.c",
  "hash_id": "e7a240c0b2fa1adb41fcadf350517af3aeef19f7def60e2f2bbce149e10025ed",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/i915/display/intel_fbc.c",
  "human_readable_source": " \n\n \n\n#include <linux/string_helpers.h>\n\n#include <drm/drm_blend.h>\n#include <drm/drm_fourcc.h>\n\n#include \"i915_drv.h\"\n#include \"i915_reg.h\"\n#include \"i915_utils.h\"\n#include \"i915_vgpu.h\"\n#include \"i915_vma.h\"\n#include \"intel_cdclk.h\"\n#include \"intel_de.h\"\n#include \"intel_display_trace.h\"\n#include \"intel_display_types.h\"\n#include \"intel_fbc.h\"\n#include \"intel_frontbuffer.h\"\n\n#define for_each_fbc_id(__dev_priv, __fbc_id) \\\n\tfor ((__fbc_id) = INTEL_FBC_A; (__fbc_id) < I915_MAX_FBCS; (__fbc_id)++) \\\n\t\tfor_each_if(DISPLAY_RUNTIME_INFO(__dev_priv)->fbc_mask & BIT(__fbc_id))\n\n#define for_each_intel_fbc(__dev_priv, __fbc, __fbc_id) \\\n\tfor_each_fbc_id((__dev_priv), (__fbc_id)) \\\n\t\tfor_each_if((__fbc) = (__dev_priv)->display.fbc[(__fbc_id)])\n\nstruct intel_fbc_funcs {\n\tvoid (*activate)(struct intel_fbc *fbc);\n\tvoid (*deactivate)(struct intel_fbc *fbc);\n\tbool (*is_active)(struct intel_fbc *fbc);\n\tbool (*is_compressing)(struct intel_fbc *fbc);\n\tvoid (*nuke)(struct intel_fbc *fbc);\n\tvoid (*program_cfb)(struct intel_fbc *fbc);\n\tvoid (*set_false_color)(struct intel_fbc *fbc, bool enable);\n};\n\nstruct intel_fbc_state {\n\tstruct intel_plane *plane;\n\tunsigned int cfb_stride;\n\tunsigned int cfb_size;\n\tunsigned int fence_y_offset;\n\tu16 override_cfb_stride;\n\tu16 interval;\n\ts8 fence_id;\n};\n\nstruct intel_fbc {\n\tstruct drm_i915_private *i915;\n\tconst struct intel_fbc_funcs *funcs;\n\n\t \n\tstruct mutex lock;\n\tunsigned int busy_bits;\n\n\tstruct i915_stolen_fb compressed_fb, compressed_llb;\n\n\tenum intel_fbc_id id;\n\n\tu8 limit;\n\n\tbool false_color;\n\n\tbool active;\n\tbool activated;\n\tbool flip_pending;\n\n\tbool underrun_detected;\n\tstruct work_struct underrun_work;\n\n\t \n\tstruct intel_fbc_state state;\n\tconst char *no_fbc_reason;\n};\n\n \nstatic unsigned int intel_fbc_plane_stride(const struct intel_plane_state *plane_state)\n{\n\tconst struct drm_framebuffer *fb = plane_state->hw.fb;\n\tunsigned int stride;\n\n\tstride = plane_state->view.color_plane[0].mapping_stride;\n\tif (!drm_rotation_90_or_270(plane_state->hw.rotation))\n\t\tstride /= fb->format->cpp[0];\n\n\treturn stride;\n}\n\n \nstatic unsigned int _intel_fbc_cfb_stride(const struct intel_plane_state *plane_state)\n{\n\tunsigned int cpp = 4;  \n\n\treturn intel_fbc_plane_stride(plane_state) * cpp;\n}\n\n \nstatic unsigned int skl_fbc_min_cfb_stride(const struct intel_plane_state *plane_state)\n{\n\tstruct drm_i915_private *i915 = to_i915(plane_state->uapi.plane->dev);\n\tunsigned int limit = 4;  \n\tunsigned int cpp = 4;  \n\tunsigned int width = drm_rect_width(&plane_state->uapi.src) >> 16;\n\tunsigned int height = 4;  \n\tunsigned int stride;\n\n\t \n\tstride = width * cpp * height / limit;\n\n\t \n\tif (DISPLAY_VER(i915) >= 11)\n\t\tstride += 64;\n\n\t \n\tstride = ALIGN(stride, 512);\n\n\t \n\treturn stride * limit / height;\n}\n\n \nstatic unsigned int intel_fbc_cfb_stride(const struct intel_plane_state *plane_state)\n{\n\tstruct drm_i915_private *i915 = to_i915(plane_state->uapi.plane->dev);\n\tunsigned int stride = _intel_fbc_cfb_stride(plane_state);\n\n\t \n\tif (DISPLAY_VER(i915) >= 9)\n\t\treturn max(ALIGN(stride, 512), skl_fbc_min_cfb_stride(plane_state));\n\telse\n\t\treturn stride;\n}\n\nstatic unsigned int intel_fbc_cfb_size(const struct intel_plane_state *plane_state)\n{\n\tstruct drm_i915_private *i915 = to_i915(plane_state->uapi.plane->dev);\n\tint lines = drm_rect_height(&plane_state->uapi.src) >> 16;\n\n\tif (DISPLAY_VER(i915) == 7)\n\t\tlines = min(lines, 2048);\n\telse if (DISPLAY_VER(i915) >= 8)\n\t\tlines = min(lines, 2560);\n\n\treturn lines * intel_fbc_cfb_stride(plane_state);\n}\n\nstatic u16 intel_fbc_override_cfb_stride(const struct intel_plane_state *plane_state)\n{\n\tstruct drm_i915_private *i915 = to_i915(plane_state->uapi.plane->dev);\n\tunsigned int stride_aligned = intel_fbc_cfb_stride(plane_state);\n\tunsigned int stride = _intel_fbc_cfb_stride(plane_state);\n\tconst struct drm_framebuffer *fb = plane_state->hw.fb;\n\n\t \n\tif (stride != stride_aligned ||\n\t    (DISPLAY_VER(i915) == 9 && fb->modifier == DRM_FORMAT_MOD_LINEAR))\n\t\treturn stride_aligned * 4 / 64;\n\n\treturn 0;\n}\n\nstatic u32 i8xx_fbc_ctl(struct intel_fbc *fbc)\n{\n\tconst struct intel_fbc_state *fbc_state = &fbc->state;\n\tstruct drm_i915_private *i915 = fbc->i915;\n\tunsigned int cfb_stride;\n\tu32 fbc_ctl;\n\n\tcfb_stride = fbc_state->cfb_stride / fbc->limit;\n\n\t \n\tif (DISPLAY_VER(i915) == 2)\n\t\tcfb_stride = (cfb_stride / 32) - 1;\n\telse\n\t\tcfb_stride = (cfb_stride / 64) - 1;\n\n\tfbc_ctl = FBC_CTL_PERIODIC |\n\t\tFBC_CTL_INTERVAL(fbc_state->interval) |\n\t\tFBC_CTL_STRIDE(cfb_stride);\n\n\tif (IS_I945GM(i915))\n\t\tfbc_ctl |= FBC_CTL_C3_IDLE;  \n\n\tif (fbc_state->fence_id >= 0)\n\t\tfbc_ctl |= FBC_CTL_FENCENO(fbc_state->fence_id);\n\n\treturn fbc_ctl;\n}\n\nstatic u32 i965_fbc_ctl2(struct intel_fbc *fbc)\n{\n\tconst struct intel_fbc_state *fbc_state = &fbc->state;\n\tu32 fbc_ctl2;\n\n\tfbc_ctl2 = FBC_CTL_FENCE_DBL | FBC_CTL_IDLE_IMM |\n\t\tFBC_CTL_PLANE(fbc_state->plane->i9xx_plane);\n\n\tif (fbc_state->fence_id >= 0)\n\t\tfbc_ctl2 |= FBC_CTL_CPU_FENCE_EN;\n\n\treturn fbc_ctl2;\n}\n\nstatic void i8xx_fbc_deactivate(struct intel_fbc *fbc)\n{\n\tstruct drm_i915_private *i915 = fbc->i915;\n\tu32 fbc_ctl;\n\n\t \n\tfbc_ctl = intel_de_read(i915, FBC_CONTROL);\n\tif ((fbc_ctl & FBC_CTL_EN) == 0)\n\t\treturn;\n\n\tfbc_ctl &= ~FBC_CTL_EN;\n\tintel_de_write(i915, FBC_CONTROL, fbc_ctl);\n\n\t \n\tif (intel_de_wait_for_clear(i915, FBC_STATUS,\n\t\t\t\t    FBC_STAT_COMPRESSING, 10)) {\n\t\tdrm_dbg_kms(&i915->drm, \"FBC idle timed out\\n\");\n\t\treturn;\n\t}\n}\n\nstatic void i8xx_fbc_activate(struct intel_fbc *fbc)\n{\n\tconst struct intel_fbc_state *fbc_state = &fbc->state;\n\tstruct drm_i915_private *i915 = fbc->i915;\n\tint i;\n\n\t \n\tfor (i = 0; i < (FBC_LL_SIZE / 32) + 1; i++)\n\t\tintel_de_write(i915, FBC_TAG(i), 0);\n\n\tif (DISPLAY_VER(i915) == 4) {\n\t\tintel_de_write(i915, FBC_CONTROL2,\n\t\t\t       i965_fbc_ctl2(fbc));\n\t\tintel_de_write(i915, FBC_FENCE_OFF,\n\t\t\t       fbc_state->fence_y_offset);\n\t}\n\n\tintel_de_write(i915, FBC_CONTROL,\n\t\t       FBC_CTL_EN | i8xx_fbc_ctl(fbc));\n}\n\nstatic bool i8xx_fbc_is_active(struct intel_fbc *fbc)\n{\n\treturn intel_de_read(fbc->i915, FBC_CONTROL) & FBC_CTL_EN;\n}\n\nstatic bool i8xx_fbc_is_compressing(struct intel_fbc *fbc)\n{\n\treturn intel_de_read(fbc->i915, FBC_STATUS) &\n\t\t(FBC_STAT_COMPRESSING | FBC_STAT_COMPRESSED);\n}\n\nstatic void i8xx_fbc_nuke(struct intel_fbc *fbc)\n{\n\tstruct intel_fbc_state *fbc_state = &fbc->state;\n\tenum i9xx_plane_id i9xx_plane = fbc_state->plane->i9xx_plane;\n\tstruct drm_i915_private *dev_priv = fbc->i915;\n\n\tintel_de_write_fw(dev_priv, DSPADDR(i9xx_plane),\n\t\t\t  intel_de_read_fw(dev_priv, DSPADDR(i9xx_plane)));\n}\n\nstatic void i8xx_fbc_program_cfb(struct intel_fbc *fbc)\n{\n\tstruct drm_i915_private *i915 = fbc->i915;\n\n\tGEM_BUG_ON(range_overflows_end_t(u64, i915_gem_stolen_area_address(i915),\n\t\t\t\t\t i915_gem_stolen_node_offset(&fbc->compressed_fb),\n\t\t\t\t\t U32_MAX));\n\tGEM_BUG_ON(range_overflows_end_t(u64, i915_gem_stolen_area_address(i915),\n\t\t\t\t\t i915_gem_stolen_node_offset(&fbc->compressed_llb),\n\t\t\t\t\t U32_MAX));\n\tintel_de_write(i915, FBC_CFB_BASE,\n\t\t       i915_gem_stolen_node_address(i915, &fbc->compressed_fb));\n\tintel_de_write(i915, FBC_LL_BASE,\n\t\t       i915_gem_stolen_node_address(i915, &fbc->compressed_llb));\n}\n\nstatic const struct intel_fbc_funcs i8xx_fbc_funcs = {\n\t.activate = i8xx_fbc_activate,\n\t.deactivate = i8xx_fbc_deactivate,\n\t.is_active = i8xx_fbc_is_active,\n\t.is_compressing = i8xx_fbc_is_compressing,\n\t.nuke = i8xx_fbc_nuke,\n\t.program_cfb = i8xx_fbc_program_cfb,\n};\n\nstatic void i965_fbc_nuke(struct intel_fbc *fbc)\n{\n\tstruct intel_fbc_state *fbc_state = &fbc->state;\n\tenum i9xx_plane_id i9xx_plane = fbc_state->plane->i9xx_plane;\n\tstruct drm_i915_private *dev_priv = fbc->i915;\n\n\tintel_de_write_fw(dev_priv, DSPSURF(i9xx_plane),\n\t\t\t  intel_de_read_fw(dev_priv, DSPSURF(i9xx_plane)));\n}\n\nstatic const struct intel_fbc_funcs i965_fbc_funcs = {\n\t.activate = i8xx_fbc_activate,\n\t.deactivate = i8xx_fbc_deactivate,\n\t.is_active = i8xx_fbc_is_active,\n\t.is_compressing = i8xx_fbc_is_compressing,\n\t.nuke = i965_fbc_nuke,\n\t.program_cfb = i8xx_fbc_program_cfb,\n};\n\nstatic u32 g4x_dpfc_ctl_limit(struct intel_fbc *fbc)\n{\n\tswitch (fbc->limit) {\n\tdefault:\n\t\tMISSING_CASE(fbc->limit);\n\t\tfallthrough;\n\tcase 1:\n\t\treturn DPFC_CTL_LIMIT_1X;\n\tcase 2:\n\t\treturn DPFC_CTL_LIMIT_2X;\n\tcase 4:\n\t\treturn DPFC_CTL_LIMIT_4X;\n\t}\n}\n\nstatic u32 g4x_dpfc_ctl(struct intel_fbc *fbc)\n{\n\tconst struct intel_fbc_state *fbc_state = &fbc->state;\n\tstruct drm_i915_private *i915 = fbc->i915;\n\tu32 dpfc_ctl;\n\n\tdpfc_ctl = g4x_dpfc_ctl_limit(fbc) |\n\t\tDPFC_CTL_PLANE_G4X(fbc_state->plane->i9xx_plane);\n\n\tif (IS_G4X(i915))\n\t\tdpfc_ctl |= DPFC_CTL_SR_EN;\n\n\tif (fbc_state->fence_id >= 0) {\n\t\tdpfc_ctl |= DPFC_CTL_FENCE_EN_G4X;\n\n\t\tif (DISPLAY_VER(i915) < 6)\n\t\t\tdpfc_ctl |= DPFC_CTL_FENCENO(fbc_state->fence_id);\n\t}\n\n\treturn dpfc_ctl;\n}\n\nstatic void g4x_fbc_activate(struct intel_fbc *fbc)\n{\n\tconst struct intel_fbc_state *fbc_state = &fbc->state;\n\tstruct drm_i915_private *i915 = fbc->i915;\n\n\tintel_de_write(i915, DPFC_FENCE_YOFF,\n\t\t       fbc_state->fence_y_offset);\n\n\tintel_de_write(i915, DPFC_CONTROL,\n\t\t       DPFC_CTL_EN | g4x_dpfc_ctl(fbc));\n}\n\nstatic void g4x_fbc_deactivate(struct intel_fbc *fbc)\n{\n\tstruct drm_i915_private *i915 = fbc->i915;\n\tu32 dpfc_ctl;\n\n\t \n\tdpfc_ctl = intel_de_read(i915, DPFC_CONTROL);\n\tif (dpfc_ctl & DPFC_CTL_EN) {\n\t\tdpfc_ctl &= ~DPFC_CTL_EN;\n\t\tintel_de_write(i915, DPFC_CONTROL, dpfc_ctl);\n\t}\n}\n\nstatic bool g4x_fbc_is_active(struct intel_fbc *fbc)\n{\n\treturn intel_de_read(fbc->i915, DPFC_CONTROL) & DPFC_CTL_EN;\n}\n\nstatic bool g4x_fbc_is_compressing(struct intel_fbc *fbc)\n{\n\treturn intel_de_read(fbc->i915, DPFC_STATUS) & DPFC_COMP_SEG_MASK;\n}\n\nstatic void g4x_fbc_program_cfb(struct intel_fbc *fbc)\n{\n\tstruct drm_i915_private *i915 = fbc->i915;\n\n\tintel_de_write(i915, DPFC_CB_BASE,\n\t\t       i915_gem_stolen_node_offset(&fbc->compressed_fb));\n}\n\nstatic const struct intel_fbc_funcs g4x_fbc_funcs = {\n\t.activate = g4x_fbc_activate,\n\t.deactivate = g4x_fbc_deactivate,\n\t.is_active = g4x_fbc_is_active,\n\t.is_compressing = g4x_fbc_is_compressing,\n\t.nuke = i965_fbc_nuke,\n\t.program_cfb = g4x_fbc_program_cfb,\n};\n\nstatic void ilk_fbc_activate(struct intel_fbc *fbc)\n{\n\tstruct intel_fbc_state *fbc_state = &fbc->state;\n\tstruct drm_i915_private *i915 = fbc->i915;\n\n\tintel_de_write(i915, ILK_DPFC_FENCE_YOFF(fbc->id),\n\t\t       fbc_state->fence_y_offset);\n\n\tintel_de_write(i915, ILK_DPFC_CONTROL(fbc->id),\n\t\t       DPFC_CTL_EN | g4x_dpfc_ctl(fbc));\n}\n\nstatic void ilk_fbc_deactivate(struct intel_fbc *fbc)\n{\n\tstruct drm_i915_private *i915 = fbc->i915;\n\tu32 dpfc_ctl;\n\n\t \n\tdpfc_ctl = intel_de_read(i915, ILK_DPFC_CONTROL(fbc->id));\n\tif (dpfc_ctl & DPFC_CTL_EN) {\n\t\tdpfc_ctl &= ~DPFC_CTL_EN;\n\t\tintel_de_write(i915, ILK_DPFC_CONTROL(fbc->id), dpfc_ctl);\n\t}\n}\n\nstatic bool ilk_fbc_is_active(struct intel_fbc *fbc)\n{\n\treturn intel_de_read(fbc->i915, ILK_DPFC_CONTROL(fbc->id)) & DPFC_CTL_EN;\n}\n\nstatic bool ilk_fbc_is_compressing(struct intel_fbc *fbc)\n{\n\treturn intel_de_read(fbc->i915, ILK_DPFC_STATUS(fbc->id)) & DPFC_COMP_SEG_MASK;\n}\n\nstatic void ilk_fbc_program_cfb(struct intel_fbc *fbc)\n{\n\tstruct drm_i915_private *i915 = fbc->i915;\n\n\tintel_de_write(i915, ILK_DPFC_CB_BASE(fbc->id),\n\t\t       i915_gem_stolen_node_offset(&fbc->compressed_fb));\n}\n\nstatic const struct intel_fbc_funcs ilk_fbc_funcs = {\n\t.activate = ilk_fbc_activate,\n\t.deactivate = ilk_fbc_deactivate,\n\t.is_active = ilk_fbc_is_active,\n\t.is_compressing = ilk_fbc_is_compressing,\n\t.nuke = i965_fbc_nuke,\n\t.program_cfb = ilk_fbc_program_cfb,\n};\n\nstatic void snb_fbc_program_fence(struct intel_fbc *fbc)\n{\n\tconst struct intel_fbc_state *fbc_state = &fbc->state;\n\tstruct drm_i915_private *i915 = fbc->i915;\n\tu32 ctl = 0;\n\n\tif (fbc_state->fence_id >= 0)\n\t\tctl = SNB_DPFC_FENCE_EN | SNB_DPFC_FENCENO(fbc_state->fence_id);\n\n\tintel_de_write(i915, SNB_DPFC_CTL_SA, ctl);\n\tintel_de_write(i915, SNB_DPFC_CPU_FENCE_OFFSET, fbc_state->fence_y_offset);\n}\n\nstatic void snb_fbc_activate(struct intel_fbc *fbc)\n{\n\tsnb_fbc_program_fence(fbc);\n\n\tilk_fbc_activate(fbc);\n}\n\nstatic void snb_fbc_nuke(struct intel_fbc *fbc)\n{\n\tstruct drm_i915_private *i915 = fbc->i915;\n\n\tintel_de_write(i915, MSG_FBC_REND_STATE(fbc->id), FBC_REND_NUKE);\n\tintel_de_posting_read(i915, MSG_FBC_REND_STATE(fbc->id));\n}\n\nstatic const struct intel_fbc_funcs snb_fbc_funcs = {\n\t.activate = snb_fbc_activate,\n\t.deactivate = ilk_fbc_deactivate,\n\t.is_active = ilk_fbc_is_active,\n\t.is_compressing = ilk_fbc_is_compressing,\n\t.nuke = snb_fbc_nuke,\n\t.program_cfb = ilk_fbc_program_cfb,\n};\n\nstatic void glk_fbc_program_cfb_stride(struct intel_fbc *fbc)\n{\n\tconst struct intel_fbc_state *fbc_state = &fbc->state;\n\tstruct drm_i915_private *i915 = fbc->i915;\n\tu32 val = 0;\n\n\tif (fbc_state->override_cfb_stride)\n\t\tval |= FBC_STRIDE_OVERRIDE |\n\t\t\tFBC_STRIDE(fbc_state->override_cfb_stride / fbc->limit);\n\n\tintel_de_write(i915, GLK_FBC_STRIDE(fbc->id), val);\n}\n\nstatic void skl_fbc_program_cfb_stride(struct intel_fbc *fbc)\n{\n\tconst struct intel_fbc_state *fbc_state = &fbc->state;\n\tstruct drm_i915_private *i915 = fbc->i915;\n\tu32 val = 0;\n\n\t \n\tif (fbc_state->override_cfb_stride)\n\t\tval |= CHICKEN_FBC_STRIDE_OVERRIDE |\n\t\t\tCHICKEN_FBC_STRIDE(fbc_state->override_cfb_stride / fbc->limit);\n\n\tintel_de_rmw(i915, CHICKEN_MISC_4,\n\t\t     CHICKEN_FBC_STRIDE_OVERRIDE |\n\t\t     CHICKEN_FBC_STRIDE_MASK, val);\n}\n\nstatic u32 ivb_dpfc_ctl(struct intel_fbc *fbc)\n{\n\tconst struct intel_fbc_state *fbc_state = &fbc->state;\n\tstruct drm_i915_private *i915 = fbc->i915;\n\tu32 dpfc_ctl;\n\n\tdpfc_ctl = g4x_dpfc_ctl_limit(fbc);\n\n\tif (IS_IVYBRIDGE(i915))\n\t\tdpfc_ctl |= DPFC_CTL_PLANE_IVB(fbc_state->plane->i9xx_plane);\n\n\tif (fbc_state->fence_id >= 0)\n\t\tdpfc_ctl |= DPFC_CTL_FENCE_EN_IVB;\n\n\tif (fbc->false_color)\n\t\tdpfc_ctl |= DPFC_CTL_FALSE_COLOR;\n\n\treturn dpfc_ctl;\n}\n\nstatic void ivb_fbc_activate(struct intel_fbc *fbc)\n{\n\tstruct drm_i915_private *i915 = fbc->i915;\n\n\tif (DISPLAY_VER(i915) >= 10)\n\t\tglk_fbc_program_cfb_stride(fbc);\n\telse if (DISPLAY_VER(i915) == 9)\n\t\tskl_fbc_program_cfb_stride(fbc);\n\n\tif (intel_gt_support_legacy_fencing(to_gt(i915)))\n\t\tsnb_fbc_program_fence(fbc);\n\n\tintel_de_write(i915, ILK_DPFC_CONTROL(fbc->id),\n\t\t       DPFC_CTL_EN | ivb_dpfc_ctl(fbc));\n}\n\nstatic bool ivb_fbc_is_compressing(struct intel_fbc *fbc)\n{\n\treturn intel_de_read(fbc->i915, ILK_DPFC_STATUS2(fbc->id)) & DPFC_COMP_SEG_MASK_IVB;\n}\n\nstatic void ivb_fbc_set_false_color(struct intel_fbc *fbc,\n\t\t\t\t    bool enable)\n{\n\tintel_de_rmw(fbc->i915, ILK_DPFC_CONTROL(fbc->id),\n\t\t     DPFC_CTL_FALSE_COLOR, enable ? DPFC_CTL_FALSE_COLOR : 0);\n}\n\nstatic const struct intel_fbc_funcs ivb_fbc_funcs = {\n\t.activate = ivb_fbc_activate,\n\t.deactivate = ilk_fbc_deactivate,\n\t.is_active = ilk_fbc_is_active,\n\t.is_compressing = ivb_fbc_is_compressing,\n\t.nuke = snb_fbc_nuke,\n\t.program_cfb = ilk_fbc_program_cfb,\n\t.set_false_color = ivb_fbc_set_false_color,\n};\n\nstatic bool intel_fbc_hw_is_active(struct intel_fbc *fbc)\n{\n\treturn fbc->funcs->is_active(fbc);\n}\n\nstatic void intel_fbc_hw_activate(struct intel_fbc *fbc)\n{\n\ttrace_intel_fbc_activate(fbc->state.plane);\n\n\tfbc->active = true;\n\tfbc->activated = true;\n\n\tfbc->funcs->activate(fbc);\n}\n\nstatic void intel_fbc_hw_deactivate(struct intel_fbc *fbc)\n{\n\ttrace_intel_fbc_deactivate(fbc->state.plane);\n\n\tfbc->active = false;\n\n\tfbc->funcs->deactivate(fbc);\n}\n\nstatic bool intel_fbc_is_compressing(struct intel_fbc *fbc)\n{\n\treturn fbc->funcs->is_compressing(fbc);\n}\n\nstatic void intel_fbc_nuke(struct intel_fbc *fbc)\n{\n\tstruct drm_i915_private *i915 = fbc->i915;\n\n\tlockdep_assert_held(&fbc->lock);\n\tdrm_WARN_ON(&i915->drm, fbc->flip_pending);\n\n\ttrace_intel_fbc_nuke(fbc->state.plane);\n\n\tfbc->funcs->nuke(fbc);\n}\n\nstatic void intel_fbc_activate(struct intel_fbc *fbc)\n{\n\tlockdep_assert_held(&fbc->lock);\n\n\tintel_fbc_hw_activate(fbc);\n\tintel_fbc_nuke(fbc);\n\n\tfbc->no_fbc_reason = NULL;\n}\n\nstatic void intel_fbc_deactivate(struct intel_fbc *fbc, const char *reason)\n{\n\tlockdep_assert_held(&fbc->lock);\n\n\tif (fbc->active)\n\t\tintel_fbc_hw_deactivate(fbc);\n\n\tfbc->no_fbc_reason = reason;\n}\n\nstatic u64 intel_fbc_cfb_base_max(struct drm_i915_private *i915)\n{\n\tif (DISPLAY_VER(i915) >= 5 || IS_G4X(i915))\n\t\treturn BIT_ULL(28);\n\telse\n\t\treturn BIT_ULL(32);\n}\n\nstatic u64 intel_fbc_stolen_end(struct drm_i915_private *i915)\n{\n\tu64 end;\n\n\t \n\tif (IS_BROADWELL(i915) ||\n\t    (DISPLAY_VER(i915) == 9 && !IS_BROXTON(i915)))\n\t\tend = i915_gem_stolen_area_size(i915) - 8 * 1024 * 1024;\n\telse\n\t\tend = U64_MAX;\n\n\treturn min(end, intel_fbc_cfb_base_max(i915));\n}\n\nstatic int intel_fbc_min_limit(const struct intel_plane_state *plane_state)\n{\n\treturn plane_state->hw.fb->format->cpp[0] == 2 ? 2 : 1;\n}\n\nstatic int intel_fbc_max_limit(struct drm_i915_private *i915)\n{\n\t \n\tif (IS_G4X(i915))\n\t\treturn 1;\n\n\t \n\treturn 4;\n}\n\nstatic int find_compression_limit(struct intel_fbc *fbc,\n\t\t\t\t  unsigned int size, int min_limit)\n{\n\tstruct drm_i915_private *i915 = fbc->i915;\n\tu64 end = intel_fbc_stolen_end(i915);\n\tint ret, limit = min_limit;\n\n\tsize /= limit;\n\n\t \n\tret = i915_gem_stolen_insert_node_in_range(i915, &fbc->compressed_fb,\n\t\t\t\t\t\t   size <<= 1, 4096, 0, end);\n\tif (ret == 0)\n\t\treturn limit;\n\n\tfor (; limit <= intel_fbc_max_limit(i915); limit <<= 1) {\n\t\tret = i915_gem_stolen_insert_node_in_range(i915, &fbc->compressed_fb,\n\t\t\t\t\t\t\t   size >>= 1, 4096, 0, end);\n\t\tif (ret == 0)\n\t\t\treturn limit;\n\t}\n\n\treturn 0;\n}\n\nstatic int intel_fbc_alloc_cfb(struct intel_fbc *fbc,\n\t\t\t       unsigned int size, int min_limit)\n{\n\tstruct drm_i915_private *i915 = fbc->i915;\n\tint ret;\n\n\tdrm_WARN_ON(&i915->drm,\n\t\t    i915_gem_stolen_node_allocated(&fbc->compressed_fb));\n\tdrm_WARN_ON(&i915->drm,\n\t\t    i915_gem_stolen_node_allocated(&fbc->compressed_llb));\n\n\tif (DISPLAY_VER(i915) < 5 && !IS_G4X(i915)) {\n\t\tret = i915_gem_stolen_insert_node(i915, &fbc->compressed_llb,\n\t\t\t\t\t\t  4096, 4096);\n\t\tif (ret)\n\t\t\tgoto err;\n\t}\n\n\tret = find_compression_limit(fbc, size, min_limit);\n\tif (!ret)\n\t\tgoto err_llb;\n\telse if (ret > min_limit)\n\t\tdrm_info_once(&i915->drm,\n\t\t\t      \"Reducing the compressed framebuffer size. This may lead to less power savings than a non-reduced-size. Try to increase stolen memory size if available in BIOS.\\n\");\n\n\tfbc->limit = ret;\n\n\tdrm_dbg_kms(&i915->drm,\n\t\t    \"reserved %llu bytes of contiguous stolen space for FBC, limit: %d\\n\",\n\t\t    i915_gem_stolen_node_size(&fbc->compressed_fb), fbc->limit);\n\treturn 0;\n\nerr_llb:\n\tif (i915_gem_stolen_node_allocated(&fbc->compressed_llb))\n\t\ti915_gem_stolen_remove_node(i915, &fbc->compressed_llb);\nerr:\n\tif (i915_gem_stolen_initialized(i915))\n\t\tdrm_info_once(&i915->drm, \"not enough stolen space for compressed buffer (need %d more bytes), disabling. Hint: you may be able to increase stolen memory size in the BIOS to avoid this.\\n\", size);\n\treturn -ENOSPC;\n}\n\nstatic void intel_fbc_program_cfb(struct intel_fbc *fbc)\n{\n\tfbc->funcs->program_cfb(fbc);\n}\n\nstatic void intel_fbc_program_workarounds(struct intel_fbc *fbc)\n{\n\t \n\tif (DISPLAY_VER(fbc->i915) >= 11 && !IS_DG2(fbc->i915))\n\t\tintel_de_rmw(fbc->i915, ILK_DPFC_CHICKEN(fbc->id), 0,\n\t\t\t     DPFC_CHICKEN_FORCE_SLB_INVALIDATION);\n}\n\nstatic void __intel_fbc_cleanup_cfb(struct intel_fbc *fbc)\n{\n\tstruct drm_i915_private *i915 = fbc->i915;\n\n\tif (WARN_ON(intel_fbc_hw_is_active(fbc)))\n\t\treturn;\n\n\tif (i915_gem_stolen_node_allocated(&fbc->compressed_llb))\n\t\ti915_gem_stolen_remove_node(i915, &fbc->compressed_llb);\n\tif (i915_gem_stolen_node_allocated(&fbc->compressed_fb))\n\t\ti915_gem_stolen_remove_node(i915, &fbc->compressed_fb);\n}\n\nvoid intel_fbc_cleanup(struct drm_i915_private *i915)\n{\n\tstruct intel_fbc *fbc;\n\tenum intel_fbc_id fbc_id;\n\n\tfor_each_intel_fbc(i915, fbc, fbc_id) {\n\t\tmutex_lock(&fbc->lock);\n\t\t__intel_fbc_cleanup_cfb(fbc);\n\t\tmutex_unlock(&fbc->lock);\n\n\t\tkfree(fbc);\n\t}\n}\n\nstatic bool stride_is_valid(const struct intel_plane_state *plane_state)\n{\n\tstruct drm_i915_private *i915 = to_i915(plane_state->uapi.plane->dev);\n\tconst struct drm_framebuffer *fb = plane_state->hw.fb;\n\tunsigned int stride = intel_fbc_plane_stride(plane_state) *\n\t\tfb->format->cpp[0];\n\n\t \n\tif (drm_WARN_ON_ONCE(&i915->drm, (stride & (64 - 1)) != 0))\n\t\treturn false;\n\n\t \n\tif (stride < 512)\n\t\treturn false;\n\n\tif (DISPLAY_VER(i915) == 2 || DISPLAY_VER(i915) == 3)\n\t\treturn stride == 4096 || stride == 8192;\n\n\tif (DISPLAY_VER(i915) == 4 && !IS_G4X(i915) && stride < 2048)\n\t\treturn false;\n\n\t \n\tif ((DISPLAY_VER(i915) == 9 || IS_GEMINILAKE(i915)) &&\n\t    fb->modifier == DRM_FORMAT_MOD_LINEAR && stride & 511)\n\t\treturn false;\n\n\tif (stride > 16384)\n\t\treturn false;\n\n\treturn true;\n}\n\nstatic bool pixel_format_is_valid(const struct intel_plane_state *plane_state)\n{\n\tstruct drm_i915_private *i915 = to_i915(plane_state->uapi.plane->dev);\n\tconst struct drm_framebuffer *fb = plane_state->hw.fb;\n\n\tswitch (fb->format->format) {\n\tcase DRM_FORMAT_XRGB8888:\n\tcase DRM_FORMAT_XBGR8888:\n\t\treturn true;\n\tcase DRM_FORMAT_XRGB1555:\n\tcase DRM_FORMAT_RGB565:\n\t\t \n\t\tif (DISPLAY_VER(i915) == 2)\n\t\t\treturn false;\n\t\t \n\t\tif (IS_G4X(i915))\n\t\t\treturn false;\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nstatic bool rotation_is_valid(const struct intel_plane_state *plane_state)\n{\n\tstruct drm_i915_private *i915 = to_i915(plane_state->uapi.plane->dev);\n\tconst struct drm_framebuffer *fb = plane_state->hw.fb;\n\tunsigned int rotation = plane_state->hw.rotation;\n\n\tif (DISPLAY_VER(i915) >= 9 && fb->format->format == DRM_FORMAT_RGB565 &&\n\t    drm_rotation_90_or_270(rotation))\n\t\treturn false;\n\telse if (DISPLAY_VER(i915) <= 4 && !IS_G4X(i915) &&\n\t\t rotation != DRM_MODE_ROTATE_0)\n\t\treturn false;\n\n\treturn true;\n}\n\n \nstatic bool intel_fbc_hw_tracking_covers_screen(const struct intel_plane_state *plane_state)\n{\n\tstruct drm_i915_private *i915 = to_i915(plane_state->uapi.plane->dev);\n\tunsigned int effective_w, effective_h, max_w, max_h;\n\n\tif (DISPLAY_VER(i915) >= 10) {\n\t\tmax_w = 5120;\n\t\tmax_h = 4096;\n\t} else if (DISPLAY_VER(i915) >= 8 || IS_HASWELL(i915)) {\n\t\tmax_w = 4096;\n\t\tmax_h = 4096;\n\t} else if (IS_G4X(i915) || DISPLAY_VER(i915) >= 5) {\n\t\tmax_w = 4096;\n\t\tmax_h = 2048;\n\t} else {\n\t\tmax_w = 2048;\n\t\tmax_h = 1536;\n\t}\n\n\teffective_w = plane_state->view.color_plane[0].x +\n\t\t(drm_rect_width(&plane_state->uapi.src) >> 16);\n\teffective_h = plane_state->view.color_plane[0].y +\n\t\t(drm_rect_height(&plane_state->uapi.src) >> 16);\n\n\treturn effective_w <= max_w && effective_h <= max_h;\n}\n\nstatic bool tiling_is_valid(const struct intel_plane_state *plane_state)\n{\n\tstruct drm_i915_private *i915 = to_i915(plane_state->uapi.plane->dev);\n\tconst struct drm_framebuffer *fb = plane_state->hw.fb;\n\n\tswitch (fb->modifier) {\n\tcase DRM_FORMAT_MOD_LINEAR:\n\tcase I915_FORMAT_MOD_Y_TILED:\n\tcase I915_FORMAT_MOD_Yf_TILED:\n\t\treturn DISPLAY_VER(i915) >= 9;\n\tcase I915_FORMAT_MOD_4_TILED:\n\tcase I915_FORMAT_MOD_X_TILED:\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nstatic void intel_fbc_update_state(struct intel_atomic_state *state,\n\t\t\t\t   struct intel_crtc *crtc,\n\t\t\t\t   struct intel_plane *plane)\n{\n\tstruct drm_i915_private *i915 = to_i915(state->base.dev);\n\tconst struct intel_crtc_state *crtc_state =\n\t\tintel_atomic_get_new_crtc_state(state, crtc);\n\tconst struct intel_plane_state *plane_state =\n\t\tintel_atomic_get_new_plane_state(state, plane);\n\tstruct intel_fbc *fbc = plane->fbc;\n\tstruct intel_fbc_state *fbc_state = &fbc->state;\n\n\tWARN_ON(plane_state->no_fbc_reason);\n\tWARN_ON(fbc_state->plane && fbc_state->plane != plane);\n\n\tfbc_state->plane = plane;\n\n\t \n\tfbc_state->interval = drm_mode_vrefresh(&crtc_state->hw.adjusted_mode);\n\n\tfbc_state->fence_y_offset = intel_plane_fence_y_offset(plane_state);\n\n\tdrm_WARN_ON(&i915->drm, plane_state->flags & PLANE_HAS_FENCE &&\n\t\t    !intel_gt_support_legacy_fencing(to_gt(i915)));\n\n\tif (plane_state->flags & PLANE_HAS_FENCE)\n\t\tfbc_state->fence_id =  i915_vma_fence_id(plane_state->ggtt_vma);\n\telse\n\t\tfbc_state->fence_id = -1;\n\n\tfbc_state->cfb_stride = intel_fbc_cfb_stride(plane_state);\n\tfbc_state->cfb_size = intel_fbc_cfb_size(plane_state);\n\tfbc_state->override_cfb_stride = intel_fbc_override_cfb_stride(plane_state);\n}\n\nstatic bool intel_fbc_is_fence_ok(const struct intel_plane_state *plane_state)\n{\n\tstruct drm_i915_private *i915 = to_i915(plane_state->uapi.plane->dev);\n\n\t \n\treturn DISPLAY_VER(i915) >= 9 ||\n\t\t(plane_state->flags & PLANE_HAS_FENCE &&\n\t\t i915_vma_fence_id(plane_state->ggtt_vma) != -1);\n}\n\nstatic bool intel_fbc_is_cfb_ok(const struct intel_plane_state *plane_state)\n{\n\tstruct intel_plane *plane = to_intel_plane(plane_state->uapi.plane);\n\tstruct intel_fbc *fbc = plane->fbc;\n\n\treturn intel_fbc_min_limit(plane_state) <= fbc->limit &&\n\t\tintel_fbc_cfb_size(plane_state) <= fbc->limit *\n\t\t\ti915_gem_stolen_node_size(&fbc->compressed_fb);\n}\n\nstatic bool intel_fbc_is_ok(const struct intel_plane_state *plane_state)\n{\n\treturn !plane_state->no_fbc_reason &&\n\t\tintel_fbc_is_fence_ok(plane_state) &&\n\t\tintel_fbc_is_cfb_ok(plane_state);\n}\n\nstatic int intel_fbc_check_plane(struct intel_atomic_state *state,\n\t\t\t\t struct intel_plane *plane)\n{\n\tstruct drm_i915_private *i915 = to_i915(state->base.dev);\n\tstruct intel_plane_state *plane_state =\n\t\tintel_atomic_get_new_plane_state(state, plane);\n\tconst struct drm_framebuffer *fb = plane_state->hw.fb;\n\tstruct intel_crtc *crtc = to_intel_crtc(plane_state->hw.crtc);\n\tconst struct intel_crtc_state *crtc_state;\n\tstruct intel_fbc *fbc = plane->fbc;\n\n\tif (!fbc)\n\t\treturn 0;\n\n\tif (!i915_gem_stolen_initialized(i915)) {\n\t\tplane_state->no_fbc_reason = \"stolen memory not initialised\";\n\t\treturn 0;\n\t}\n\n\tif (intel_vgpu_active(i915)) {\n\t\tplane_state->no_fbc_reason = \"VGPU active\";\n\t\treturn 0;\n\t}\n\n\tif (!i915->params.enable_fbc) {\n\t\tplane_state->no_fbc_reason = \"disabled per module param or by default\";\n\t\treturn 0;\n\t}\n\n\tif (!plane_state->uapi.visible) {\n\t\tplane_state->no_fbc_reason = \"plane not visible\";\n\t\treturn 0;\n\t}\n\n\tcrtc_state = intel_atomic_get_new_crtc_state(state, crtc);\n\n\tif (crtc_state->hw.adjusted_mode.flags & DRM_MODE_FLAG_INTERLACE) {\n\t\tplane_state->no_fbc_reason = \"interlaced mode not supported\";\n\t\treturn 0;\n\t}\n\n\tif (crtc_state->double_wide) {\n\t\tplane_state->no_fbc_reason = \"double wide pipe not supported\";\n\t\treturn 0;\n\t}\n\n\t \n\tif (DISPLAY_VER(i915) >= 12 && crtc_state->has_psr2) {\n\t\tplane_state->no_fbc_reason = \"PSR2 enabled\";\n\t\treturn 0;\n\t}\n\n\t \n\tif ((IS_DISPLAY_VER(i915, 12, 13) ||\n\t     IS_MTL_DISPLAY_STEP(i915, STEP_A0, STEP_C0)) &&\n\t    crtc_state->has_psr) {\n\t\tplane_state->no_fbc_reason = \"PSR1 enabled (Wa_14016291713)\";\n\t\treturn 0;\n\t}\n\n\tif (!pixel_format_is_valid(plane_state)) {\n\t\tplane_state->no_fbc_reason = \"pixel format not supported\";\n\t\treturn 0;\n\t}\n\n\tif (!tiling_is_valid(plane_state)) {\n\t\tplane_state->no_fbc_reason = \"tiling not supported\";\n\t\treturn 0;\n\t}\n\n\tif (!rotation_is_valid(plane_state)) {\n\t\tplane_state->no_fbc_reason = \"rotation not supported\";\n\t\treturn 0;\n\t}\n\n\tif (!stride_is_valid(plane_state)) {\n\t\tplane_state->no_fbc_reason = \"stride not supported\";\n\t\treturn 0;\n\t}\n\n\tif (plane_state->hw.pixel_blend_mode != DRM_MODE_BLEND_PIXEL_NONE &&\n\t    fb->format->has_alpha) {\n\t\tplane_state->no_fbc_reason = \"per-pixel alpha not supported\";\n\t\treturn 0;\n\t}\n\n\tif (!intel_fbc_hw_tracking_covers_screen(plane_state)) {\n\t\tplane_state->no_fbc_reason = \"plane size too big\";\n\t\treturn 0;\n\t}\n\n\t \n\tif (DISPLAY_VER(i915) >= 9 &&\n\t    plane_state->view.color_plane[0].y & 3) {\n\t\tplane_state->no_fbc_reason = \"plane start Y offset misaligned\";\n\t\treturn 0;\n\t}\n\n\t \n\tif (DISPLAY_VER(i915) >= 11 &&\n\t    (plane_state->view.color_plane[0].y +\n\t     (drm_rect_height(&plane_state->uapi.src) >> 16)) & 3) {\n\t\tplane_state->no_fbc_reason = \"plane end Y offset misaligned\";\n\t\treturn 0;\n\t}\n\n\t \n\tif (IS_HASWELL(i915) || IS_BROADWELL(i915)) {\n\t\tconst struct intel_cdclk_state *cdclk_state;\n\n\t\tcdclk_state = intel_atomic_get_cdclk_state(state);\n\t\tif (IS_ERR(cdclk_state))\n\t\t\treturn PTR_ERR(cdclk_state);\n\n\t\tif (crtc_state->pixel_rate >= cdclk_state->logical.cdclk * 95 / 100) {\n\t\t\tplane_state->no_fbc_reason = \"pixel rate too high\";\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tplane_state->no_fbc_reason = NULL;\n\n\treturn 0;\n}\n\n\nstatic bool intel_fbc_can_flip_nuke(struct intel_atomic_state *state,\n\t\t\t\t    struct intel_crtc *crtc,\n\t\t\t\t    struct intel_plane *plane)\n{\n\tconst struct intel_crtc_state *new_crtc_state =\n\t\tintel_atomic_get_new_crtc_state(state, crtc);\n\tconst struct intel_plane_state *old_plane_state =\n\t\tintel_atomic_get_old_plane_state(state, plane);\n\tconst struct intel_plane_state *new_plane_state =\n\t\tintel_atomic_get_new_plane_state(state, plane);\n\tconst struct drm_framebuffer *old_fb = old_plane_state->hw.fb;\n\tconst struct drm_framebuffer *new_fb = new_plane_state->hw.fb;\n\n\tif (intel_crtc_needs_modeset(new_crtc_state))\n\t\treturn false;\n\n\tif (!intel_fbc_is_ok(old_plane_state) ||\n\t    !intel_fbc_is_ok(new_plane_state))\n\t\treturn false;\n\n\tif (old_fb->format->format != new_fb->format->format)\n\t\treturn false;\n\n\tif (old_fb->modifier != new_fb->modifier)\n\t\treturn false;\n\n\tif (intel_fbc_plane_stride(old_plane_state) !=\n\t    intel_fbc_plane_stride(new_plane_state))\n\t\treturn false;\n\n\tif (intel_fbc_cfb_stride(old_plane_state) !=\n\t    intel_fbc_cfb_stride(new_plane_state))\n\t\treturn false;\n\n\tif (intel_fbc_cfb_size(old_plane_state) !=\n\t    intel_fbc_cfb_size(new_plane_state))\n\t\treturn false;\n\n\tif (intel_fbc_override_cfb_stride(old_plane_state) !=\n\t    intel_fbc_override_cfb_stride(new_plane_state))\n\t\treturn false;\n\n\treturn true;\n}\n\nstatic bool __intel_fbc_pre_update(struct intel_atomic_state *state,\n\t\t\t\t   struct intel_crtc *crtc,\n\t\t\t\t   struct intel_plane *plane)\n{\n\tstruct drm_i915_private *i915 = to_i915(state->base.dev);\n\tstruct intel_fbc *fbc = plane->fbc;\n\tbool need_vblank_wait = false;\n\n\tlockdep_assert_held(&fbc->lock);\n\n\tfbc->flip_pending = true;\n\n\tif (intel_fbc_can_flip_nuke(state, crtc, plane))\n\t\treturn need_vblank_wait;\n\n\tintel_fbc_deactivate(fbc, \"update pending\");\n\n\t \n\tif (fbc->activated && DISPLAY_VER(i915) >= 10)\n\t\tneed_vblank_wait = true;\n\tfbc->activated = false;\n\n\treturn need_vblank_wait;\n}\n\nbool intel_fbc_pre_update(struct intel_atomic_state *state,\n\t\t\t  struct intel_crtc *crtc)\n{\n\tconst struct intel_plane_state __maybe_unused *plane_state;\n\tbool need_vblank_wait = false;\n\tstruct intel_plane *plane;\n\tint i;\n\n\tfor_each_new_intel_plane_in_state(state, plane, plane_state, i) {\n\t\tstruct intel_fbc *fbc = plane->fbc;\n\n\t\tif (!fbc || plane->pipe != crtc->pipe)\n\t\t\tcontinue;\n\n\t\tmutex_lock(&fbc->lock);\n\n\t\tif (fbc->state.plane == plane)\n\t\t\tneed_vblank_wait |= __intel_fbc_pre_update(state, crtc, plane);\n\n\t\tmutex_unlock(&fbc->lock);\n\t}\n\n\treturn need_vblank_wait;\n}\n\nstatic void __intel_fbc_disable(struct intel_fbc *fbc)\n{\n\tstruct drm_i915_private *i915 = fbc->i915;\n\tstruct intel_plane *plane = fbc->state.plane;\n\n\tlockdep_assert_held(&fbc->lock);\n\tdrm_WARN_ON(&i915->drm, fbc->active);\n\n\tdrm_dbg_kms(&i915->drm, \"Disabling FBC on [PLANE:%d:%s]\\n\",\n\t\t    plane->base.base.id, plane->base.name);\n\n\t__intel_fbc_cleanup_cfb(fbc);\n\n\tfbc->state.plane = NULL;\n\tfbc->flip_pending = false;\n\tfbc->busy_bits = 0;\n}\n\nstatic void __intel_fbc_post_update(struct intel_fbc *fbc)\n{\n\tlockdep_assert_held(&fbc->lock);\n\n\tfbc->flip_pending = false;\n\n\tif (!fbc->busy_bits)\n\t\tintel_fbc_activate(fbc);\n\telse\n\t\tintel_fbc_deactivate(fbc, \"frontbuffer write\");\n}\n\nvoid intel_fbc_post_update(struct intel_atomic_state *state,\n\t\t\t   struct intel_crtc *crtc)\n{\n\tconst struct intel_plane_state __maybe_unused *plane_state;\n\tstruct intel_plane *plane;\n\tint i;\n\n\tfor_each_new_intel_plane_in_state(state, plane, plane_state, i) {\n\t\tstruct intel_fbc *fbc = plane->fbc;\n\n\t\tif (!fbc || plane->pipe != crtc->pipe)\n\t\t\tcontinue;\n\n\t\tmutex_lock(&fbc->lock);\n\n\t\tif (fbc->state.plane == plane)\n\t\t\t__intel_fbc_post_update(fbc);\n\n\t\tmutex_unlock(&fbc->lock);\n\t}\n}\n\nstatic unsigned int intel_fbc_get_frontbuffer_bit(struct intel_fbc *fbc)\n{\n\tif (fbc->state.plane)\n\t\treturn fbc->state.plane->frontbuffer_bit;\n\telse\n\t\treturn 0;\n}\n\nstatic void __intel_fbc_invalidate(struct intel_fbc *fbc,\n\t\t\t\t   unsigned int frontbuffer_bits,\n\t\t\t\t   enum fb_op_origin origin)\n{\n\tif (origin == ORIGIN_FLIP || origin == ORIGIN_CURSOR_UPDATE)\n\t\treturn;\n\n\tmutex_lock(&fbc->lock);\n\n\tfrontbuffer_bits &= intel_fbc_get_frontbuffer_bit(fbc);\n\tif (!frontbuffer_bits)\n\t\tgoto out;\n\n\tfbc->busy_bits |= frontbuffer_bits;\n\tintel_fbc_deactivate(fbc, \"frontbuffer write\");\n\nout:\n\tmutex_unlock(&fbc->lock);\n}\n\nvoid intel_fbc_invalidate(struct drm_i915_private *i915,\n\t\t\t  unsigned int frontbuffer_bits,\n\t\t\t  enum fb_op_origin origin)\n{\n\tstruct intel_fbc *fbc;\n\tenum intel_fbc_id fbc_id;\n\n\tfor_each_intel_fbc(i915, fbc, fbc_id)\n\t\t__intel_fbc_invalidate(fbc, frontbuffer_bits, origin);\n\n}\n\nstatic void __intel_fbc_flush(struct intel_fbc *fbc,\n\t\t\t      unsigned int frontbuffer_bits,\n\t\t\t      enum fb_op_origin origin)\n{\n\tmutex_lock(&fbc->lock);\n\n\tfrontbuffer_bits &= intel_fbc_get_frontbuffer_bit(fbc);\n\tif (!frontbuffer_bits)\n\t\tgoto out;\n\n\tfbc->busy_bits &= ~frontbuffer_bits;\n\n\tif (origin == ORIGIN_FLIP || origin == ORIGIN_CURSOR_UPDATE)\n\t\tgoto out;\n\n\tif (fbc->busy_bits || fbc->flip_pending)\n\t\tgoto out;\n\n\tif (fbc->active)\n\t\tintel_fbc_nuke(fbc);\n\telse\n\t\tintel_fbc_activate(fbc);\n\nout:\n\tmutex_unlock(&fbc->lock);\n}\n\nvoid intel_fbc_flush(struct drm_i915_private *i915,\n\t\t     unsigned int frontbuffer_bits,\n\t\t     enum fb_op_origin origin)\n{\n\tstruct intel_fbc *fbc;\n\tenum intel_fbc_id fbc_id;\n\n\tfor_each_intel_fbc(i915, fbc, fbc_id)\n\t\t__intel_fbc_flush(fbc, frontbuffer_bits, origin);\n}\n\nint intel_fbc_atomic_check(struct intel_atomic_state *state)\n{\n\tstruct intel_plane_state __maybe_unused *plane_state;\n\tstruct intel_plane *plane;\n\tint i;\n\n\tfor_each_new_intel_plane_in_state(state, plane, plane_state, i) {\n\t\tint ret;\n\n\t\tret = intel_fbc_check_plane(state, plane);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic void __intel_fbc_enable(struct intel_atomic_state *state,\n\t\t\t       struct intel_crtc *crtc,\n\t\t\t       struct intel_plane *plane)\n{\n\tstruct drm_i915_private *i915 = to_i915(state->base.dev);\n\tconst struct intel_plane_state *plane_state =\n\t\tintel_atomic_get_new_plane_state(state, plane);\n\tstruct intel_fbc *fbc = plane->fbc;\n\n\tlockdep_assert_held(&fbc->lock);\n\n\tif (fbc->state.plane) {\n\t\tif (fbc->state.plane != plane)\n\t\t\treturn;\n\n\t\tif (intel_fbc_is_ok(plane_state)) {\n\t\t\tintel_fbc_update_state(state, crtc, plane);\n\t\t\treturn;\n\t\t}\n\n\t\t__intel_fbc_disable(fbc);\n\t}\n\n\tdrm_WARN_ON(&i915->drm, fbc->active);\n\n\tfbc->no_fbc_reason = plane_state->no_fbc_reason;\n\tif (fbc->no_fbc_reason)\n\t\treturn;\n\n\tif (!intel_fbc_is_fence_ok(plane_state)) {\n\t\tfbc->no_fbc_reason = \"framebuffer not fenced\";\n\t\treturn;\n\t}\n\n\tif (fbc->underrun_detected) {\n\t\tfbc->no_fbc_reason = \"FIFO underrun\";\n\t\treturn;\n\t}\n\n\tif (intel_fbc_alloc_cfb(fbc, intel_fbc_cfb_size(plane_state),\n\t\t\t\tintel_fbc_min_limit(plane_state))) {\n\t\tfbc->no_fbc_reason = \"not enough stolen memory\";\n\t\treturn;\n\t}\n\n\tdrm_dbg_kms(&i915->drm, \"Enabling FBC on [PLANE:%d:%s]\\n\",\n\t\t    plane->base.base.id, plane->base.name);\n\tfbc->no_fbc_reason = \"FBC enabled but not active yet\\n\";\n\n\tintel_fbc_update_state(state, crtc, plane);\n\n\tintel_fbc_program_workarounds(fbc);\n\tintel_fbc_program_cfb(fbc);\n}\n\n \nvoid intel_fbc_disable(struct intel_crtc *crtc)\n{\n\tstruct drm_i915_private *i915 = to_i915(crtc->base.dev);\n\tstruct intel_plane *plane;\n\n\tfor_each_intel_plane(&i915->drm, plane) {\n\t\tstruct intel_fbc *fbc = plane->fbc;\n\n\t\tif (!fbc || plane->pipe != crtc->pipe)\n\t\t\tcontinue;\n\n\t\tmutex_lock(&fbc->lock);\n\t\tif (fbc->state.plane == plane)\n\t\t\t__intel_fbc_disable(fbc);\n\t\tmutex_unlock(&fbc->lock);\n\t}\n}\n\nvoid intel_fbc_update(struct intel_atomic_state *state,\n\t\t      struct intel_crtc *crtc)\n{\n\tconst struct intel_crtc_state *crtc_state =\n\t\tintel_atomic_get_new_crtc_state(state, crtc);\n\tconst struct intel_plane_state *plane_state;\n\tstruct intel_plane *plane;\n\tint i;\n\n\tfor_each_new_intel_plane_in_state(state, plane, plane_state, i) {\n\t\tstruct intel_fbc *fbc = plane->fbc;\n\n\t\tif (!fbc || plane->pipe != crtc->pipe)\n\t\t\tcontinue;\n\n\t\tmutex_lock(&fbc->lock);\n\n\t\tif (intel_crtc_needs_fastset(crtc_state) &&\n\t\t    plane_state->no_fbc_reason) {\n\t\t\tif (fbc->state.plane == plane)\n\t\t\t\t__intel_fbc_disable(fbc);\n\t\t} else {\n\t\t\t__intel_fbc_enable(state, crtc, plane);\n\t\t}\n\n\t\tmutex_unlock(&fbc->lock);\n\t}\n}\n\nstatic void intel_fbc_underrun_work_fn(struct work_struct *work)\n{\n\tstruct intel_fbc *fbc = container_of(work, typeof(*fbc), underrun_work);\n\tstruct drm_i915_private *i915 = fbc->i915;\n\n\tmutex_lock(&fbc->lock);\n\n\t \n\tif (fbc->underrun_detected || !fbc->state.plane)\n\t\tgoto out;\n\n\tdrm_dbg_kms(&i915->drm, \"Disabling FBC due to FIFO underrun.\\n\");\n\tfbc->underrun_detected = true;\n\n\tintel_fbc_deactivate(fbc, \"FIFO underrun\");\n\tif (!fbc->flip_pending)\n\t\tintel_crtc_wait_for_next_vblank(intel_crtc_for_pipe(i915, fbc->state.plane->pipe));\n\t__intel_fbc_disable(fbc);\nout:\n\tmutex_unlock(&fbc->lock);\n}\n\nstatic void __intel_fbc_reset_underrun(struct intel_fbc *fbc)\n{\n\tstruct drm_i915_private *i915 = fbc->i915;\n\n\tcancel_work_sync(&fbc->underrun_work);\n\n\tmutex_lock(&fbc->lock);\n\n\tif (fbc->underrun_detected) {\n\t\tdrm_dbg_kms(&i915->drm,\n\t\t\t    \"Re-allowing FBC after fifo underrun\\n\");\n\t\tfbc->no_fbc_reason = \"FIFO underrun cleared\";\n\t}\n\n\tfbc->underrun_detected = false;\n\tmutex_unlock(&fbc->lock);\n}\n\n \nvoid intel_fbc_reset_underrun(struct drm_i915_private *i915)\n{\n\tstruct intel_fbc *fbc;\n\tenum intel_fbc_id fbc_id;\n\n\tfor_each_intel_fbc(i915, fbc, fbc_id)\n\t\t__intel_fbc_reset_underrun(fbc);\n}\n\nstatic void __intel_fbc_handle_fifo_underrun_irq(struct intel_fbc *fbc)\n{\n\t \n\tif (READ_ONCE(fbc->underrun_detected))\n\t\treturn;\n\n\tqueue_work(fbc->i915->unordered_wq, &fbc->underrun_work);\n}\n\n \nvoid intel_fbc_handle_fifo_underrun_irq(struct drm_i915_private *i915)\n{\n\tstruct intel_fbc *fbc;\n\tenum intel_fbc_id fbc_id;\n\n\tfor_each_intel_fbc(i915, fbc, fbc_id)\n\t\t__intel_fbc_handle_fifo_underrun_irq(fbc);\n}\n\n \nstatic int intel_sanitize_fbc_option(struct drm_i915_private *i915)\n{\n\tif (i915->params.enable_fbc >= 0)\n\t\treturn !!i915->params.enable_fbc;\n\n\tif (!HAS_FBC(i915))\n\t\treturn 0;\n\n\tif (IS_BROADWELL(i915) || DISPLAY_VER(i915) >= 9)\n\t\treturn 1;\n\n\treturn 0;\n}\n\nstatic bool need_fbc_vtd_wa(struct drm_i915_private *i915)\n{\n\t \n\tif (i915_vtd_active(i915) &&\n\t    (IS_SKYLAKE(i915) || IS_BROXTON(i915))) {\n\t\tdrm_info(&i915->drm,\n\t\t\t \"Disabling framebuffer compression (FBC) to prevent screen flicker with VT-d enabled\\n\");\n\t\treturn true;\n\t}\n\n\treturn false;\n}\n\nvoid intel_fbc_add_plane(struct intel_fbc *fbc, struct intel_plane *plane)\n{\n\tplane->fbc = fbc;\n}\n\nstatic struct intel_fbc *intel_fbc_create(struct drm_i915_private *i915,\n\t\t\t\t\t  enum intel_fbc_id fbc_id)\n{\n\tstruct intel_fbc *fbc;\n\n\tfbc = kzalloc(sizeof(*fbc), GFP_KERNEL);\n\tif (!fbc)\n\t\treturn NULL;\n\n\tfbc->id = fbc_id;\n\tfbc->i915 = i915;\n\tINIT_WORK(&fbc->underrun_work, intel_fbc_underrun_work_fn);\n\tmutex_init(&fbc->lock);\n\n\tif (DISPLAY_VER(i915) >= 7)\n\t\tfbc->funcs = &ivb_fbc_funcs;\n\telse if (DISPLAY_VER(i915) == 6)\n\t\tfbc->funcs = &snb_fbc_funcs;\n\telse if (DISPLAY_VER(i915) == 5)\n\t\tfbc->funcs = &ilk_fbc_funcs;\n\telse if (IS_G4X(i915))\n\t\tfbc->funcs = &g4x_fbc_funcs;\n\telse if (DISPLAY_VER(i915) == 4)\n\t\tfbc->funcs = &i965_fbc_funcs;\n\telse\n\t\tfbc->funcs = &i8xx_fbc_funcs;\n\n\treturn fbc;\n}\n\n \nvoid intel_fbc_init(struct drm_i915_private *i915)\n{\n\tenum intel_fbc_id fbc_id;\n\n\tif (need_fbc_vtd_wa(i915))\n\t\tDISPLAY_RUNTIME_INFO(i915)->fbc_mask = 0;\n\n\ti915->params.enable_fbc = intel_sanitize_fbc_option(i915);\n\tdrm_dbg_kms(&i915->drm, \"Sanitized enable_fbc value: %d\\n\",\n\t\t    i915->params.enable_fbc);\n\n\tfor_each_fbc_id(i915, fbc_id)\n\t\ti915->display.fbc[fbc_id] = intel_fbc_create(i915, fbc_id);\n}\n\n \nvoid intel_fbc_sanitize(struct drm_i915_private *i915)\n{\n\tstruct intel_fbc *fbc;\n\tenum intel_fbc_id fbc_id;\n\n\tfor_each_intel_fbc(i915, fbc, fbc_id) {\n\t\tif (intel_fbc_hw_is_active(fbc))\n\t\t\tintel_fbc_hw_deactivate(fbc);\n\t}\n}\n\nstatic int intel_fbc_debugfs_status_show(struct seq_file *m, void *unused)\n{\n\tstruct intel_fbc *fbc = m->private;\n\tstruct drm_i915_private *i915 = fbc->i915;\n\tstruct intel_plane *plane;\n\tintel_wakeref_t wakeref;\n\n\tdrm_modeset_lock_all(&i915->drm);\n\n\twakeref = intel_runtime_pm_get(&i915->runtime_pm);\n\tmutex_lock(&fbc->lock);\n\n\tif (fbc->active) {\n\t\tseq_puts(m, \"FBC enabled\\n\");\n\t\tseq_printf(m, \"Compressing: %s\\n\",\n\t\t\t   str_yes_no(intel_fbc_is_compressing(fbc)));\n\t} else {\n\t\tseq_printf(m, \"FBC disabled: %s\\n\", fbc->no_fbc_reason);\n\t}\n\n\tfor_each_intel_plane(&i915->drm, plane) {\n\t\tconst struct intel_plane_state *plane_state =\n\t\t\tto_intel_plane_state(plane->base.state);\n\n\t\tif (plane->fbc != fbc)\n\t\t\tcontinue;\n\n\t\tseq_printf(m, \"%c [PLANE:%d:%s]: %s\\n\",\n\t\t\t   fbc->state.plane == plane ? '*' : ' ',\n\t\t\t   plane->base.base.id, plane->base.name,\n\t\t\t   plane_state->no_fbc_reason ?: \"FBC possible\");\n\t}\n\n\tmutex_unlock(&fbc->lock);\n\tintel_runtime_pm_put(&i915->runtime_pm, wakeref);\n\n\tdrm_modeset_unlock_all(&i915->drm);\n\n\treturn 0;\n}\n\nDEFINE_SHOW_ATTRIBUTE(intel_fbc_debugfs_status);\n\nstatic int intel_fbc_debugfs_false_color_get(void *data, u64 *val)\n{\n\tstruct intel_fbc *fbc = data;\n\n\t*val = fbc->false_color;\n\n\treturn 0;\n}\n\nstatic int intel_fbc_debugfs_false_color_set(void *data, u64 val)\n{\n\tstruct intel_fbc *fbc = data;\n\n\tmutex_lock(&fbc->lock);\n\n\tfbc->false_color = val;\n\n\tif (fbc->active)\n\t\tfbc->funcs->set_false_color(fbc, fbc->false_color);\n\n\tmutex_unlock(&fbc->lock);\n\n\treturn 0;\n}\n\nDEFINE_DEBUGFS_ATTRIBUTE(intel_fbc_debugfs_false_color_fops,\n\t\t\t intel_fbc_debugfs_false_color_get,\n\t\t\t intel_fbc_debugfs_false_color_set,\n\t\t\t \"%llu\\n\");\n\nstatic void intel_fbc_debugfs_add(struct intel_fbc *fbc,\n\t\t\t\t  struct dentry *parent)\n{\n\tdebugfs_create_file(\"i915_fbc_status\", 0444, parent,\n\t\t\t    fbc, &intel_fbc_debugfs_status_fops);\n\n\tif (fbc->funcs->set_false_color)\n\t\tdebugfs_create_file_unsafe(\"i915_fbc_false_color\", 0644, parent,\n\t\t\t\t\t   fbc, &intel_fbc_debugfs_false_color_fops);\n}\n\nvoid intel_fbc_crtc_debugfs_add(struct intel_crtc *crtc)\n{\n\tstruct intel_plane *plane = to_intel_plane(crtc->base.primary);\n\n\tif (plane->fbc)\n\t\tintel_fbc_debugfs_add(plane->fbc, crtc->base.debugfs_entry);\n}\n\n \nvoid intel_fbc_debugfs_register(struct drm_i915_private *i915)\n{\n\tstruct drm_minor *minor = i915->drm.primary;\n\tstruct intel_fbc *fbc;\n\n\tfbc = i915->display.fbc[INTEL_FBC_A];\n\tif (fbc)\n\t\tintel_fbc_debugfs_add(fbc, minor->debugfs_root);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}