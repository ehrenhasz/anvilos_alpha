{
  "module_name": "intel_display_device.c",
  "hash_id": "0543d2d13e5730706daa6b8bfc5b488eaced3ce8c0a8f31e1e5929cf8da1583c",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/i915/display/intel_display_device.c",
  "human_readable_source": "\n \n\n#include <drm/i915_pciids.h>\n#include <drm/drm_color_mgmt.h>\n#include <linux/pci.h>\n\n#include \"i915_drv.h\"\n#include \"i915_reg.h\"\n#include \"intel_de.h\"\n#include \"intel_display.h\"\n#include \"intel_display_device.h\"\n#include \"intel_display_power.h\"\n#include \"intel_display_reg_defs.h\"\n#include \"intel_fbc.h\"\n\nstatic const struct intel_display_device_info no_display = {};\n\n#define PIPE_A_OFFSET\t\t0x70000\n#define PIPE_B_OFFSET\t\t0x71000\n#define PIPE_C_OFFSET\t\t0x72000\n#define PIPE_D_OFFSET\t\t0x73000\n#define CHV_PIPE_C_OFFSET\t0x74000\n \n#define PIPE_EDP_OFFSET\t0x7f000\n\n \n#define PIPE_DSI0_OFFSET\t0x7b000\n#define PIPE_DSI1_OFFSET\t0x7b800\n\n#define TRANSCODER_A_OFFSET 0x60000\n#define TRANSCODER_B_OFFSET 0x61000\n#define TRANSCODER_C_OFFSET 0x62000\n#define CHV_TRANSCODER_C_OFFSET 0x63000\n#define TRANSCODER_D_OFFSET 0x63000\n#define TRANSCODER_EDP_OFFSET 0x6f000\n#define TRANSCODER_DSI0_OFFSET\t0x6b000\n#define TRANSCODER_DSI1_OFFSET\t0x6b800\n\n#define CURSOR_A_OFFSET 0x70080\n#define CURSOR_B_OFFSET 0x700c0\n#define CHV_CURSOR_C_OFFSET 0x700e0\n#define IVB_CURSOR_B_OFFSET 0x71080\n#define IVB_CURSOR_C_OFFSET 0x72080\n#define TGL_CURSOR_D_OFFSET 0x73080\n\n#define I845_PIPE_OFFSETS \\\n\t.pipe_offsets = { \\\n\t\t[TRANSCODER_A] = PIPE_A_OFFSET,\t\\\n\t}, \\\n\t.trans_offsets = { \\\n\t\t[TRANSCODER_A] = TRANSCODER_A_OFFSET, \\\n\t}\n\n#define I9XX_PIPE_OFFSETS \\\n\t.pipe_offsets = { \\\n\t\t[TRANSCODER_A] = PIPE_A_OFFSET,\t\\\n\t\t[TRANSCODER_B] = PIPE_B_OFFSET, \\\n\t}, \\\n\t.trans_offsets = { \\\n\t\t[TRANSCODER_A] = TRANSCODER_A_OFFSET, \\\n\t\t[TRANSCODER_B] = TRANSCODER_B_OFFSET, \\\n\t}\n\n#define IVB_PIPE_OFFSETS \\\n\t.pipe_offsets = { \\\n\t\t[TRANSCODER_A] = PIPE_A_OFFSET,\t\\\n\t\t[TRANSCODER_B] = PIPE_B_OFFSET, \\\n\t\t[TRANSCODER_C] = PIPE_C_OFFSET, \\\n\t}, \\\n\t.trans_offsets = { \\\n\t\t[TRANSCODER_A] = TRANSCODER_A_OFFSET, \\\n\t\t[TRANSCODER_B] = TRANSCODER_B_OFFSET, \\\n\t\t[TRANSCODER_C] = TRANSCODER_C_OFFSET, \\\n\t}\n\n#define HSW_PIPE_OFFSETS \\\n\t.pipe_offsets = { \\\n\t\t[TRANSCODER_A] = PIPE_A_OFFSET,\t\\\n\t\t[TRANSCODER_B] = PIPE_B_OFFSET, \\\n\t\t[TRANSCODER_C] = PIPE_C_OFFSET, \\\n\t\t[TRANSCODER_EDP] = PIPE_EDP_OFFSET, \\\n\t}, \\\n\t.trans_offsets = { \\\n\t\t[TRANSCODER_A] = TRANSCODER_A_OFFSET, \\\n\t\t[TRANSCODER_B] = TRANSCODER_B_OFFSET, \\\n\t\t[TRANSCODER_C] = TRANSCODER_C_OFFSET, \\\n\t\t[TRANSCODER_EDP] = TRANSCODER_EDP_OFFSET, \\\n\t}\n\n#define CHV_PIPE_OFFSETS \\\n\t.pipe_offsets = { \\\n\t\t[TRANSCODER_A] = PIPE_A_OFFSET, \\\n\t\t[TRANSCODER_B] = PIPE_B_OFFSET, \\\n\t\t[TRANSCODER_C] = CHV_PIPE_C_OFFSET, \\\n\t}, \\\n\t.trans_offsets = { \\\n\t\t[TRANSCODER_A] = TRANSCODER_A_OFFSET, \\\n\t\t[TRANSCODER_B] = TRANSCODER_B_OFFSET, \\\n\t\t[TRANSCODER_C] = CHV_TRANSCODER_C_OFFSET, \\\n\t}\n\n#define I845_CURSOR_OFFSETS \\\n\t.cursor_offsets = { \\\n\t\t[PIPE_A] = CURSOR_A_OFFSET, \\\n\t}\n\n#define I9XX_CURSOR_OFFSETS \\\n\t.cursor_offsets = { \\\n\t\t[PIPE_A] = CURSOR_A_OFFSET, \\\n\t\t[PIPE_B] = CURSOR_B_OFFSET, \\\n\t}\n\n#define CHV_CURSOR_OFFSETS \\\n\t.cursor_offsets = { \\\n\t\t[PIPE_A] = CURSOR_A_OFFSET, \\\n\t\t[PIPE_B] = CURSOR_B_OFFSET, \\\n\t\t[PIPE_C] = CHV_CURSOR_C_OFFSET, \\\n\t}\n\n#define IVB_CURSOR_OFFSETS \\\n\t.cursor_offsets = { \\\n\t\t[PIPE_A] = CURSOR_A_OFFSET, \\\n\t\t[PIPE_B] = IVB_CURSOR_B_OFFSET, \\\n\t\t[PIPE_C] = IVB_CURSOR_C_OFFSET, \\\n\t}\n\n#define TGL_CURSOR_OFFSETS \\\n\t.cursor_offsets = { \\\n\t\t[PIPE_A] = CURSOR_A_OFFSET, \\\n\t\t[PIPE_B] = IVB_CURSOR_B_OFFSET, \\\n\t\t[PIPE_C] = IVB_CURSOR_C_OFFSET, \\\n\t\t[PIPE_D] = TGL_CURSOR_D_OFFSET, \\\n\t}\n\n#define I845_COLORS \\\n\t.color = { .gamma_lut_size = 256 }\n#define I9XX_COLORS \\\n\t.color = { .gamma_lut_size = 129, \\\n\t\t   .gamma_lut_tests = DRM_COLOR_LUT_NON_DECREASING, \\\n\t}\n#define ILK_COLORS \\\n\t.color = { .gamma_lut_size = 1024 }\n#define IVB_COLORS \\\n\t.color = { .degamma_lut_size = 1024, .gamma_lut_size = 1024 }\n#define CHV_COLORS \\\n\t.color = { \\\n\t\t.degamma_lut_size = 65, .gamma_lut_size = 257, \\\n\t\t.degamma_lut_tests = DRM_COLOR_LUT_NON_DECREASING, \\\n\t\t.gamma_lut_tests = DRM_COLOR_LUT_NON_DECREASING, \\\n\t}\n#define GLK_COLORS \\\n\t.color = { \\\n\t\t.degamma_lut_size = 33, .gamma_lut_size = 1024, \\\n\t\t.degamma_lut_tests = DRM_COLOR_LUT_NON_DECREASING | \\\n\t\t\t\t     DRM_COLOR_LUT_EQUAL_CHANNELS, \\\n\t}\n#define ICL_COLORS \\\n\t.color = { \\\n\t\t.degamma_lut_size = 33, .gamma_lut_size = 262145, \\\n\t\t.degamma_lut_tests = DRM_COLOR_LUT_NON_DECREASING | \\\n\t\t\t\t     DRM_COLOR_LUT_EQUAL_CHANNELS, \\\n\t\t.gamma_lut_tests = DRM_COLOR_LUT_NON_DECREASING, \\\n\t}\n\n#define I830_DISPLAY \\\n\t.has_overlay = 1, \\\n\t.cursor_needs_physical = 1, \\\n\t.overlay_needs_physical = 1, \\\n\t.has_gmch = 1, \\\n\tI9XX_PIPE_OFFSETS, \\\n\tI9XX_CURSOR_OFFSETS, \\\n\tI9XX_COLORS, \\\n\t\\\n\t.__runtime_defaults.ip.ver = 2, \\\n\t.__runtime_defaults.pipe_mask = BIT(PIPE_A) | BIT(PIPE_B), \\\n\t.__runtime_defaults.cpu_transcoder_mask = \\\n\t\tBIT(TRANSCODER_A) | BIT(TRANSCODER_B)\n\n#define I845_DISPLAY \\\n\t.has_overlay = 1, \\\n\t.overlay_needs_physical = 1, \\\n\t.has_gmch = 1, \\\n\tI845_PIPE_OFFSETS, \\\n\tI845_CURSOR_OFFSETS, \\\n\tI845_COLORS, \\\n\t\\\n\t.__runtime_defaults.ip.ver = 2, \\\n\t.__runtime_defaults.pipe_mask = BIT(PIPE_A), \\\n\t.__runtime_defaults.cpu_transcoder_mask = BIT(TRANSCODER_A)\n\nstatic const struct intel_display_device_info i830_display = {\n\tI830_DISPLAY,\n\n\t.__runtime_defaults.port_mask = BIT(PORT_A) | BIT(PORT_B) | BIT(PORT_C),  \n};\n\nstatic const struct intel_display_device_info i845_display = {\n\tI845_DISPLAY,\n\n\t.__runtime_defaults.port_mask = BIT(PORT_B) | BIT(PORT_C),  \n};\n\nstatic const struct intel_display_device_info i85x_display = {\n\tI830_DISPLAY,\n\n\t.__runtime_defaults.port_mask = BIT(PORT_B) | BIT(PORT_C),  \n\t.__runtime_defaults.fbc_mask = BIT(INTEL_FBC_A),\n};\n\nstatic const struct intel_display_device_info i865g_display = {\n\tI845_DISPLAY,\n\n\t.__runtime_defaults.port_mask = BIT(PORT_B) | BIT(PORT_C),  \n\t.__runtime_defaults.fbc_mask = BIT(INTEL_FBC_A),\n};\n\n#define GEN3_DISPLAY \\\n\t.has_gmch = 1, \\\n\t.has_overlay = 1, \\\n\tI9XX_PIPE_OFFSETS, \\\n\tI9XX_CURSOR_OFFSETS, \\\n\t\\\n\t.__runtime_defaults.ip.ver = 3, \\\n\t.__runtime_defaults.pipe_mask = BIT(PIPE_A) | BIT(PIPE_B), \\\n\t.__runtime_defaults.cpu_transcoder_mask = \\\n\t\tBIT(TRANSCODER_A) | BIT(TRANSCODER_B), \\\n\t.__runtime_defaults.port_mask = BIT(PORT_B) | BIT(PORT_C)  \n\nstatic const struct intel_display_device_info i915g_display = {\n\tGEN3_DISPLAY,\n\tI845_COLORS,\n\t.cursor_needs_physical = 1,\n\t.overlay_needs_physical = 1,\n};\n\nstatic const struct intel_display_device_info i915gm_display = {\n\tGEN3_DISPLAY,\n\tI9XX_COLORS,\n\t.cursor_needs_physical = 1,\n\t.overlay_needs_physical = 1,\n\t.supports_tv = 1,\n\n\t.__runtime_defaults.fbc_mask = BIT(INTEL_FBC_A),\n};\n\nstatic const struct intel_display_device_info i945g_display = {\n\tGEN3_DISPLAY,\n\tI845_COLORS,\n\t.has_hotplug = 1,\n\t.cursor_needs_physical = 1,\n\t.overlay_needs_physical = 1,\n};\n\nstatic const struct intel_display_device_info i945gm_display = {\n\tGEN3_DISPLAY,\n\tI9XX_COLORS,\n\t.has_hotplug = 1,\n\t.cursor_needs_physical = 1,\n\t.overlay_needs_physical = 1,\n\t.supports_tv = 1,\n\n\t.__runtime_defaults.fbc_mask = BIT(INTEL_FBC_A),\n};\n\nstatic const struct intel_display_device_info g33_display = {\n\tGEN3_DISPLAY,\n\tI845_COLORS,\n\t.has_hotplug = 1,\n};\n\nstatic const struct intel_display_device_info pnv_display = {\n\tGEN3_DISPLAY,\n\tI9XX_COLORS,\n\t.has_hotplug = 1,\n};\n\n#define GEN4_DISPLAY \\\n\t.has_hotplug = 1, \\\n\t.has_gmch = 1, \\\n\tI9XX_PIPE_OFFSETS, \\\n\tI9XX_CURSOR_OFFSETS, \\\n\tI9XX_COLORS, \\\n\t\\\n\t.__runtime_defaults.ip.ver = 4, \\\n\t.__runtime_defaults.pipe_mask = BIT(PIPE_A) | BIT(PIPE_B), \\\n\t.__runtime_defaults.cpu_transcoder_mask = \\\n\t\tBIT(TRANSCODER_A) | BIT(TRANSCODER_B)\n\nstatic const struct intel_display_device_info i965g_display = {\n\tGEN4_DISPLAY,\n\t.has_overlay = 1,\n\n\t.__runtime_defaults.port_mask = BIT(PORT_B) | BIT(PORT_C),  \n};\n\nstatic const struct intel_display_device_info i965gm_display = {\n\tGEN4_DISPLAY,\n\t.has_overlay = 1,\n\t.supports_tv = 1,\n\n\t.__runtime_defaults.port_mask = BIT(PORT_B) | BIT(PORT_C),  \n\t.__runtime_defaults.fbc_mask = BIT(INTEL_FBC_A),\n};\n\nstatic const struct intel_display_device_info g45_display = {\n\tGEN4_DISPLAY,\n\n\t.__runtime_defaults.port_mask = BIT(PORT_B) | BIT(PORT_C) | BIT(PORT_D),  \n};\n\nstatic const struct intel_display_device_info gm45_display = {\n\tGEN4_DISPLAY,\n\t.supports_tv = 1,\n\n\t.__runtime_defaults.port_mask = BIT(PORT_B) | BIT(PORT_C) | BIT(PORT_D),  \n\t.__runtime_defaults.fbc_mask = BIT(INTEL_FBC_A),\n};\n\n#define ILK_DISPLAY \\\n\t.has_hotplug = 1, \\\n\tI9XX_PIPE_OFFSETS, \\\n\tI9XX_CURSOR_OFFSETS, \\\n\tILK_COLORS, \\\n\t\\\n\t.__runtime_defaults.ip.ver = 5, \\\n\t.__runtime_defaults.pipe_mask = BIT(PIPE_A) | BIT(PIPE_B), \\\n\t.__runtime_defaults.cpu_transcoder_mask = \\\n\t\tBIT(TRANSCODER_A) | BIT(TRANSCODER_B), \\\n\t.__runtime_defaults.port_mask = BIT(PORT_A) | BIT(PORT_B) | BIT(PORT_C) | BIT(PORT_D)  \n\nstatic const struct intel_display_device_info ilk_d_display = {\n\tILK_DISPLAY,\n};\n\nstatic const struct intel_display_device_info ilk_m_display = {\n\tILK_DISPLAY,\n\n\t.__runtime_defaults.fbc_mask = BIT(INTEL_FBC_A),\n};\n\nstatic const struct intel_display_device_info snb_display = {\n\t.has_hotplug = 1,\n\tI9XX_PIPE_OFFSETS,\n\tI9XX_CURSOR_OFFSETS,\n\tILK_COLORS,\n\n\t.__runtime_defaults.ip.ver = 6,\n\t.__runtime_defaults.pipe_mask = BIT(PIPE_A) | BIT(PIPE_B),\n\t.__runtime_defaults.cpu_transcoder_mask =\n\t\tBIT(TRANSCODER_A) | BIT(TRANSCODER_B),\n\t.__runtime_defaults.port_mask = BIT(PORT_A) | BIT(PORT_B) | BIT(PORT_C) | BIT(PORT_D),  \n\t.__runtime_defaults.fbc_mask = BIT(INTEL_FBC_A),\n};\n\nstatic const struct intel_display_device_info ivb_display = {\n\t.has_hotplug = 1,\n\tIVB_PIPE_OFFSETS,\n\tIVB_CURSOR_OFFSETS,\n\tIVB_COLORS,\n\n\t.__runtime_defaults.ip.ver = 7,\n\t.__runtime_defaults.pipe_mask = BIT(PIPE_A) | BIT(PIPE_B) | BIT(PIPE_C),\n\t.__runtime_defaults.cpu_transcoder_mask =\n\t\tBIT(TRANSCODER_A) | BIT(TRANSCODER_B) | BIT(TRANSCODER_C),\n\t.__runtime_defaults.port_mask = BIT(PORT_A) | BIT(PORT_B) | BIT(PORT_C) | BIT(PORT_D),  \n\t.__runtime_defaults.fbc_mask = BIT(INTEL_FBC_A),\n};\n\nstatic const struct intel_display_device_info vlv_display = {\n\t.has_gmch = 1,\n\t.has_hotplug = 1,\n\t.mmio_offset = VLV_DISPLAY_BASE,\n\tI9XX_PIPE_OFFSETS,\n\tI9XX_CURSOR_OFFSETS,\n\tI9XX_COLORS,\n\n\t.__runtime_defaults.ip.ver = 7,\n\t.__runtime_defaults.pipe_mask = BIT(PIPE_A) | BIT(PIPE_B),\n\t.__runtime_defaults.cpu_transcoder_mask =\n\t\tBIT(TRANSCODER_A) | BIT(TRANSCODER_B),\n\t.__runtime_defaults.port_mask = BIT(PORT_B) | BIT(PORT_C),  \n};\n\nstatic const struct intel_display_device_info hsw_display = {\n\t.has_ddi = 1,\n\t.has_dp_mst = 1,\n\t.has_fpga_dbg = 1,\n\t.has_hotplug = 1,\n\t.has_psr = 1,\n\t.has_psr_hw_tracking = 1,\n\tHSW_PIPE_OFFSETS,\n\tIVB_CURSOR_OFFSETS,\n\tIVB_COLORS,\n\n\t.__runtime_defaults.ip.ver = 7,\n\t.__runtime_defaults.pipe_mask = BIT(PIPE_A) | BIT(PIPE_B) | BIT(PIPE_C),\n\t.__runtime_defaults.cpu_transcoder_mask =\n\t\tBIT(TRANSCODER_A) | BIT(TRANSCODER_B) |\n\t\tBIT(TRANSCODER_C) | BIT(TRANSCODER_EDP),\n\t.__runtime_defaults.port_mask = BIT(PORT_A) | BIT(PORT_B) | BIT(PORT_C) | BIT(PORT_D) | BIT(PORT_E),\n\t.__runtime_defaults.fbc_mask = BIT(INTEL_FBC_A),\n};\n\nstatic const struct intel_display_device_info bdw_display = {\n\t.has_ddi = 1,\n\t.has_dp_mst = 1,\n\t.has_fpga_dbg = 1,\n\t.has_hotplug = 1,\n\t.has_psr = 1,\n\t.has_psr_hw_tracking = 1,\n\tHSW_PIPE_OFFSETS,\n\tIVB_CURSOR_OFFSETS,\n\tIVB_COLORS,\n\n\t.__runtime_defaults.ip.ver = 8,\n\t.__runtime_defaults.pipe_mask = BIT(PIPE_A) | BIT(PIPE_B) | BIT(PIPE_C),\n\t.__runtime_defaults.cpu_transcoder_mask =\n\t\tBIT(TRANSCODER_A) | BIT(TRANSCODER_B) |\n\t\tBIT(TRANSCODER_C) | BIT(TRANSCODER_EDP),\n\t.__runtime_defaults.port_mask = BIT(PORT_A) | BIT(PORT_B) | BIT(PORT_C) | BIT(PORT_D) | BIT(PORT_E),\n\t.__runtime_defaults.fbc_mask = BIT(INTEL_FBC_A),\n};\n\nstatic const struct intel_display_device_info chv_display = {\n\t.has_hotplug = 1,\n\t.has_gmch = 1,\n\t.mmio_offset = VLV_DISPLAY_BASE,\n\tCHV_PIPE_OFFSETS,\n\tCHV_CURSOR_OFFSETS,\n\tCHV_COLORS,\n\n\t.__runtime_defaults.ip.ver = 8,\n\t.__runtime_defaults.pipe_mask = BIT(PIPE_A) | BIT(PIPE_B) | BIT(PIPE_C),\n\t.__runtime_defaults.cpu_transcoder_mask =\n\t\tBIT(TRANSCODER_A) | BIT(TRANSCODER_B) | BIT(TRANSCODER_C),\n\t.__runtime_defaults.port_mask = BIT(PORT_B) | BIT(PORT_C) | BIT(PORT_D),  \n};\n\nstatic const struct intel_display_device_info skl_display = {\n\t.dbuf.size = 896 - 4,  \n\t.dbuf.slice_mask = BIT(DBUF_S1),\n\t.has_ddi = 1,\n\t.has_dp_mst = 1,\n\t.has_fpga_dbg = 1,\n\t.has_hotplug = 1,\n\t.has_ipc = 1,\n\t.has_psr = 1,\n\t.has_psr_hw_tracking = 1,\n\tHSW_PIPE_OFFSETS,\n\tIVB_CURSOR_OFFSETS,\n\tIVB_COLORS,\n\n\t.__runtime_defaults.ip.ver = 9,\n\t.__runtime_defaults.has_dmc = 1,\n\t.__runtime_defaults.has_hdcp = 1,\n\t.__runtime_defaults.pipe_mask = BIT(PIPE_A) | BIT(PIPE_B) | BIT(PIPE_C),\n\t.__runtime_defaults.cpu_transcoder_mask =\n\t\tBIT(TRANSCODER_A) | BIT(TRANSCODER_B) |\n\t\tBIT(TRANSCODER_C) | BIT(TRANSCODER_EDP),\n\t.__runtime_defaults.port_mask = BIT(PORT_A) | BIT(PORT_B) | BIT(PORT_C) | BIT(PORT_D) | BIT(PORT_E),\n\t.__runtime_defaults.fbc_mask = BIT(INTEL_FBC_A),\n};\n\n#define GEN9_LP_DISPLAY \\\n\t.dbuf.slice_mask = BIT(DBUF_S1), \\\n\t.has_dp_mst = 1, \\\n\t.has_ddi = 1, \\\n\t.has_fpga_dbg = 1, \\\n\t.has_hotplug = 1, \\\n\t.has_ipc = 1, \\\n\t.has_psr = 1, \\\n\t.has_psr_hw_tracking = 1, \\\n\tHSW_PIPE_OFFSETS, \\\n\tIVB_CURSOR_OFFSETS, \\\n\tIVB_COLORS, \\\n\t\\\n\t.__runtime_defaults.has_dmc = 1, \\\n\t.__runtime_defaults.has_hdcp = 1, \\\n\t.__runtime_defaults.fbc_mask = BIT(INTEL_FBC_A), \\\n\t.__runtime_defaults.pipe_mask = BIT(PIPE_A) | BIT(PIPE_B) | BIT(PIPE_C), \\\n\t.__runtime_defaults.cpu_transcoder_mask = \\\n\t\tBIT(TRANSCODER_A) | BIT(TRANSCODER_B) | \\\n\t\tBIT(TRANSCODER_C) | BIT(TRANSCODER_EDP) | \\\n\t\tBIT(TRANSCODER_DSI_A) | BIT(TRANSCODER_DSI_C), \\\n\t.__runtime_defaults.port_mask = BIT(PORT_A) | BIT(PORT_B) | BIT(PORT_C)\n\nstatic const struct intel_display_device_info bxt_display = {\n\tGEN9_LP_DISPLAY,\n\t.dbuf.size = 512 - 4,  \n\n\t.__runtime_defaults.ip.ver = 9,\n};\n\nstatic const struct intel_display_device_info glk_display = {\n\tGEN9_LP_DISPLAY,\n\t.dbuf.size = 1024 - 4,  \n\tGLK_COLORS,\n\n\t.__runtime_defaults.ip.ver = 10,\n};\n\n#define ICL_DISPLAY \\\n\t.abox_mask = BIT(0), \\\n\t.dbuf.size = 2048, \\\n\t.dbuf.slice_mask = BIT(DBUF_S1) | BIT(DBUF_S2), \\\n\t.has_ddi = 1, \\\n\t.has_dp_mst = 1, \\\n\t.has_fpga_dbg = 1, \\\n\t.has_hotplug = 1, \\\n\t.has_ipc = 1, \\\n\t.has_psr = 1, \\\n\t.has_psr_hw_tracking = 1, \\\n\t.pipe_offsets = { \\\n\t\t[TRANSCODER_A] = PIPE_A_OFFSET, \\\n\t\t[TRANSCODER_B] = PIPE_B_OFFSET, \\\n\t\t[TRANSCODER_C] = PIPE_C_OFFSET, \\\n\t\t[TRANSCODER_EDP] = PIPE_EDP_OFFSET, \\\n\t\t[TRANSCODER_DSI_0] = PIPE_DSI0_OFFSET, \\\n\t\t[TRANSCODER_DSI_1] = PIPE_DSI1_OFFSET, \\\n\t}, \\\n\t.trans_offsets = { \\\n\t\t[TRANSCODER_A] = TRANSCODER_A_OFFSET, \\\n\t\t[TRANSCODER_B] = TRANSCODER_B_OFFSET, \\\n\t\t[TRANSCODER_C] = TRANSCODER_C_OFFSET, \\\n\t\t[TRANSCODER_EDP] = TRANSCODER_EDP_OFFSET, \\\n\t\t[TRANSCODER_DSI_0] = TRANSCODER_DSI0_OFFSET, \\\n\t\t[TRANSCODER_DSI_1] = TRANSCODER_DSI1_OFFSET, \\\n\t}, \\\n\tIVB_CURSOR_OFFSETS, \\\n\tICL_COLORS, \\\n\t\\\n\t.__runtime_defaults.ip.ver = 11, \\\n\t.__runtime_defaults.has_dmc = 1, \\\n\t.__runtime_defaults.has_dsc = 1, \\\n\t.__runtime_defaults.has_hdcp = 1, \\\n\t.__runtime_defaults.pipe_mask = BIT(PIPE_A) | BIT(PIPE_B) | BIT(PIPE_C), \\\n\t.__runtime_defaults.cpu_transcoder_mask = \\\n\t\tBIT(TRANSCODER_A) | BIT(TRANSCODER_B) | \\\n\t\tBIT(TRANSCODER_C) | BIT(TRANSCODER_EDP) | \\\n\t\tBIT(TRANSCODER_DSI_0) | BIT(TRANSCODER_DSI_1), \\\n\t.__runtime_defaults.fbc_mask = BIT(INTEL_FBC_A)\n\nstatic const struct intel_display_device_info icl_display = {\n\tICL_DISPLAY,\n\n\t.__runtime_defaults.port_mask = BIT(PORT_A) | BIT(PORT_B) | BIT(PORT_C) | BIT(PORT_D) | BIT(PORT_E),\n};\n\nstatic const struct intel_display_device_info jsl_ehl_display = {\n\tICL_DISPLAY,\n\n\t.__runtime_defaults.port_mask = BIT(PORT_A) | BIT(PORT_B) | BIT(PORT_C) | BIT(PORT_D),\n};\n\n#define XE_D_DISPLAY \\\n\t.abox_mask = GENMASK(2, 1), \\\n\t.dbuf.size = 2048, \\\n\t.dbuf.slice_mask = BIT(DBUF_S1) | BIT(DBUF_S2), \\\n\t.has_ddi = 1, \\\n\t.has_dp_mst = 1, \\\n\t.has_dsb = 1, \\\n\t.has_fpga_dbg = 1, \\\n\t.has_hotplug = 1, \\\n\t.has_ipc = 1, \\\n\t.has_psr = 1, \\\n\t.has_psr_hw_tracking = 1, \\\n\t.pipe_offsets = { \\\n\t\t[TRANSCODER_A] = PIPE_A_OFFSET, \\\n\t\t[TRANSCODER_B] = PIPE_B_OFFSET, \\\n\t\t[TRANSCODER_C] = PIPE_C_OFFSET, \\\n\t\t[TRANSCODER_D] = PIPE_D_OFFSET, \\\n\t\t[TRANSCODER_DSI_0] = PIPE_DSI0_OFFSET, \\\n\t\t[TRANSCODER_DSI_1] = PIPE_DSI1_OFFSET, \\\n\t}, \\\n\t.trans_offsets = { \\\n\t\t[TRANSCODER_A] = TRANSCODER_A_OFFSET, \\\n\t\t[TRANSCODER_B] = TRANSCODER_B_OFFSET, \\\n\t\t[TRANSCODER_C] = TRANSCODER_C_OFFSET, \\\n\t\t[TRANSCODER_D] = TRANSCODER_D_OFFSET, \\\n\t\t[TRANSCODER_DSI_0] = TRANSCODER_DSI0_OFFSET, \\\n\t\t[TRANSCODER_DSI_1] = TRANSCODER_DSI1_OFFSET, \\\n\t}, \\\n\tTGL_CURSOR_OFFSETS, \\\n\tICL_COLORS, \\\n\t\\\n\t.__runtime_defaults.ip.ver = 12, \\\n\t.__runtime_defaults.has_dmc = 1, \\\n\t.__runtime_defaults.has_dsc = 1, \\\n\t.__runtime_defaults.has_hdcp = 1, \\\n\t.__runtime_defaults.pipe_mask = \\\n\t\tBIT(PIPE_A) | BIT(PIPE_B) | BIT(PIPE_C) | BIT(PIPE_D), \\\n\t.__runtime_defaults.cpu_transcoder_mask = \\\n\t\tBIT(TRANSCODER_A) | BIT(TRANSCODER_B) | \\\n\t\tBIT(TRANSCODER_C) | BIT(TRANSCODER_D) | \\\n\t\tBIT(TRANSCODER_DSI_0) | BIT(TRANSCODER_DSI_1), \\\n\t.__runtime_defaults.fbc_mask = BIT(INTEL_FBC_A)\n\nstatic const struct intel_display_device_info tgl_display = {\n\tXE_D_DISPLAY,\n\n\t \n\t.__runtime_defaults.port_mask = BIT(PORT_A) | BIT(PORT_B) |\n\t\tBIT(PORT_TC1) | BIT(PORT_TC2) | BIT(PORT_TC3) | BIT(PORT_TC4) | BIT(PORT_TC5) | BIT(PORT_TC6),\n};\n\nstatic const struct intel_display_device_info dg1_display = {\n\tXE_D_DISPLAY,\n\n\t.__runtime_defaults.port_mask = BIT(PORT_A) | BIT(PORT_B) |\n\t\tBIT(PORT_TC1) | BIT(PORT_TC2),\n};\n\nstatic const struct intel_display_device_info rkl_display = {\n\tXE_D_DISPLAY,\n\t.abox_mask = BIT(0),\n\t.has_hti = 1,\n\t.has_psr_hw_tracking = 0,\n\n\t.__runtime_defaults.pipe_mask = BIT(PIPE_A) | BIT(PIPE_B) | BIT(PIPE_C),\n\t.__runtime_defaults.cpu_transcoder_mask =\n\t\tBIT(TRANSCODER_A) | BIT(TRANSCODER_B) | BIT(TRANSCODER_C),\n\t.__runtime_defaults.port_mask = BIT(PORT_A) | BIT(PORT_B) |\n\t\tBIT(PORT_TC1) | BIT(PORT_TC2),\n};\n\nstatic const struct intel_display_device_info adl_s_display = {\n\tXE_D_DISPLAY,\n\t.has_hti = 1,\n\t.has_psr_hw_tracking = 0,\n\n\t.__runtime_defaults.port_mask = BIT(PORT_A) |\n\t\tBIT(PORT_TC1) | BIT(PORT_TC2) | BIT(PORT_TC3) | BIT(PORT_TC4),\n};\n\n#define XE_LPD_FEATURES \\\n\t.abox_mask = GENMASK(1, 0),\t\t\t\t\t\t\\\n\t.color = {\t\t\t\t\t\t\t\t\\\n\t\t.degamma_lut_size = 129, .gamma_lut_size = 1024,\t\t\\\n\t\t.degamma_lut_tests = DRM_COLOR_LUT_NON_DECREASING |\t\t\\\n\t\tDRM_COLOR_LUT_EQUAL_CHANNELS,\t\t\t\t\t\\\n\t},\t\t\t\t\t\t\t\t\t\\\n\t.dbuf.size = 4096,\t\t\t\t\t\t\t\\\n\t.dbuf.slice_mask = BIT(DBUF_S1) | BIT(DBUF_S2) | BIT(DBUF_S3) |\t\t\\\n\t\tBIT(DBUF_S4),\t\t\t\t\t\t\t\\\n\t.has_ddi = 1,\t\t\t\t\t\t\t\t\\\n\t.has_dp_mst = 1,\t\t\t\t\t\t\t\\\n\t.has_dsb = 1,\t\t\t\t\t\t\t\t\\\n\t.has_fpga_dbg = 1,\t\t\t\t\t\t\t\\\n\t.has_hotplug = 1,\t\t\t\t\t\t\t\\\n\t.has_ipc = 1,\t\t\t\t\t\t\t\t\\\n\t.has_psr = 1,\t\t\t\t\t\t\t\t\\\n\t.pipe_offsets = {\t\t\t\t\t\t\t\\\n\t\t[TRANSCODER_A] = PIPE_A_OFFSET,\t\t\t\t\t\\\n\t\t[TRANSCODER_B] = PIPE_B_OFFSET,\t\t\t\t\t\\\n\t\t[TRANSCODER_C] = PIPE_C_OFFSET,\t\t\t\t\t\\\n\t\t[TRANSCODER_D] = PIPE_D_OFFSET,\t\t\t\t\t\\\n\t\t[TRANSCODER_DSI_0] = PIPE_DSI0_OFFSET,\t\t\t\t\\\n\t\t[TRANSCODER_DSI_1] = PIPE_DSI1_OFFSET,\t\t\t\t\\\n\t},\t\t\t\t\t\t\t\t\t\\\n\t.trans_offsets = {\t\t\t\t\t\t\t\\\n\t\t[TRANSCODER_A] = TRANSCODER_A_OFFSET,\t\t\t\t\\\n\t\t[TRANSCODER_B] = TRANSCODER_B_OFFSET,\t\t\t\t\\\n\t\t[TRANSCODER_C] = TRANSCODER_C_OFFSET,\t\t\t\t\\\n\t\t[TRANSCODER_D] = TRANSCODER_D_OFFSET,\t\t\t\t\\\n\t\t[TRANSCODER_DSI_0] = TRANSCODER_DSI0_OFFSET,\t\t\t\\\n\t\t[TRANSCODER_DSI_1] = TRANSCODER_DSI1_OFFSET,\t\t\t\\\n\t},\t\t\t\t\t\t\t\t\t\\\n\tTGL_CURSOR_OFFSETS,\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\t\\\n\t.__runtime_defaults.ip.ver = 13,\t\t\t\t\t\\\n\t.__runtime_defaults.has_dmc = 1,\t\t\t\t\t\\\n\t.__runtime_defaults.has_dsc = 1,\t\t\t\t\t\\\n\t.__runtime_defaults.fbc_mask = BIT(INTEL_FBC_A),\t\t\t\\\n\t.__runtime_defaults.has_hdcp = 1,\t\t\t\t\t\\\n\t.__runtime_defaults.pipe_mask =\t\t\t\t\t\t\\\n\t\tBIT(PIPE_A) | BIT(PIPE_B) | BIT(PIPE_C) | BIT(PIPE_D)\n\nstatic const struct intel_display_device_info xe_lpd_display = {\n\tXE_LPD_FEATURES,\n\t.has_cdclk_crawl = 1,\n\t.has_psr_hw_tracking = 0,\n\n\t.__runtime_defaults.cpu_transcoder_mask =\n\t\tBIT(TRANSCODER_A) | BIT(TRANSCODER_B) |\n\t\tBIT(TRANSCODER_C) | BIT(TRANSCODER_D) |\n\t\tBIT(TRANSCODER_DSI_0) | BIT(TRANSCODER_DSI_1),\n\t.__runtime_defaults.port_mask = BIT(PORT_A) | BIT(PORT_B) |\n\t\tBIT(PORT_TC1) | BIT(PORT_TC2) | BIT(PORT_TC3) | BIT(PORT_TC4),\n};\n\nstatic const struct intel_display_device_info xe_hpd_display = {\n\tXE_LPD_FEATURES,\n\t.has_cdclk_squash = 1,\n\n\t.__runtime_defaults.cpu_transcoder_mask =\n\t\tBIT(TRANSCODER_A) | BIT(TRANSCODER_B) |\n\t\tBIT(TRANSCODER_C) | BIT(TRANSCODER_D),\n\t.__runtime_defaults.port_mask = BIT(PORT_A) | BIT(PORT_B) | BIT(PORT_C) | BIT(PORT_D_XELPD) |\n\t\tBIT(PORT_TC1),\n};\n\nstatic const struct intel_display_device_info xe_lpdp_display = {\n\tXE_LPD_FEATURES,\n\t.has_cdclk_crawl = 1,\n\t.has_cdclk_squash = 1,\n\n\t.__runtime_defaults.ip.ver = 14,\n\t.__runtime_defaults.fbc_mask = BIT(INTEL_FBC_A) | BIT(INTEL_FBC_B),\n\t.__runtime_defaults.cpu_transcoder_mask =\n\t\tBIT(TRANSCODER_A) | BIT(TRANSCODER_B) |\n\t\tBIT(TRANSCODER_C) | BIT(TRANSCODER_D),\n\t.__runtime_defaults.port_mask = BIT(PORT_A) | BIT(PORT_B) |\n\t\tBIT(PORT_TC1) | BIT(PORT_TC2) | BIT(PORT_TC3) | BIT(PORT_TC4),\n};\n\n \nstatic bool has_no_display(struct pci_dev *pdev)\n{\n\tstatic const struct pci_device_id ids[] = {\n\t\tINTEL_IVB_Q_IDS(0),\n\t\t{}\n\t};\n\n\treturn pci_match_id(ids, pdev);\n}\n\n#undef INTEL_VGA_DEVICE\n#define INTEL_VGA_DEVICE(id, info) { id, info }\n\nstatic const struct {\n\tu32 devid;\n\tconst struct intel_display_device_info *info;\n} intel_display_ids[] = {\n\tINTEL_I830_IDS(&i830_display),\n\tINTEL_I845G_IDS(&i845_display),\n\tINTEL_I85X_IDS(&i85x_display),\n\tINTEL_I865G_IDS(&i865g_display),\n\tINTEL_I915G_IDS(&i915g_display),\n\tINTEL_I915GM_IDS(&i915gm_display),\n\tINTEL_I945G_IDS(&i945g_display),\n\tINTEL_I945GM_IDS(&i945gm_display),\n\tINTEL_I965G_IDS(&i965g_display),\n\tINTEL_G33_IDS(&g33_display),\n\tINTEL_I965GM_IDS(&i965gm_display),\n\tINTEL_GM45_IDS(&gm45_display),\n\tINTEL_G45_IDS(&g45_display),\n\tINTEL_PINEVIEW_G_IDS(&pnv_display),\n\tINTEL_PINEVIEW_M_IDS(&pnv_display),\n\tINTEL_IRONLAKE_D_IDS(&ilk_d_display),\n\tINTEL_IRONLAKE_M_IDS(&ilk_m_display),\n\tINTEL_SNB_D_IDS(&snb_display),\n\tINTEL_SNB_M_IDS(&snb_display),\n\tINTEL_IVB_M_IDS(&ivb_display),\n\tINTEL_IVB_D_IDS(&ivb_display),\n\tINTEL_HSW_IDS(&hsw_display),\n\tINTEL_VLV_IDS(&vlv_display),\n\tINTEL_BDW_IDS(&bdw_display),\n\tINTEL_CHV_IDS(&chv_display),\n\tINTEL_SKL_IDS(&skl_display),\n\tINTEL_BXT_IDS(&bxt_display),\n\tINTEL_GLK_IDS(&glk_display),\n\tINTEL_KBL_IDS(&skl_display),\n\tINTEL_CFL_IDS(&skl_display),\n\tINTEL_ICL_11_IDS(&icl_display),\n\tINTEL_EHL_IDS(&jsl_ehl_display),\n\tINTEL_JSL_IDS(&jsl_ehl_display),\n\tINTEL_TGL_12_IDS(&tgl_display),\n\tINTEL_DG1_IDS(&dg1_display),\n\tINTEL_RKL_IDS(&rkl_display),\n\tINTEL_ADLS_IDS(&adl_s_display),\n\tINTEL_RPLS_IDS(&adl_s_display),\n\tINTEL_ADLP_IDS(&xe_lpd_display),\n\tINTEL_ADLN_IDS(&xe_lpd_display),\n\tINTEL_RPLP_IDS(&xe_lpd_display),\n\tINTEL_DG2_IDS(&xe_hpd_display),\n\n\t \n};\n\nstatic const struct {\n\tu16 ver;\n\tu16 rel;\n\tconst struct intel_display_device_info *display;\n} gmdid_display_map[] = {\n\t{ 14,  0, &xe_lpdp_display },\n};\n\nstatic const struct intel_display_device_info *\nprobe_gmdid_display(struct drm_i915_private *i915, u16 *ver, u16 *rel, u16 *step)\n{\n\tstruct pci_dev *pdev = to_pci_dev(i915->drm.dev);\n\tvoid __iomem *addr;\n\tu32 val;\n\tint i;\n\n\t \n\t*ver = 0;\n\t*rel = 0;\n\t*step = 0;\n\n\taddr = pci_iomap_range(pdev, 0, i915_mmio_reg_offset(GMD_ID_DISPLAY), sizeof(u32));\n\tif (!addr) {\n\t\tdrm_err(&i915->drm, \"Cannot map MMIO BAR to read display GMD_ID\\n\");\n\t\treturn &no_display;\n\t}\n\n\tval = ioread32(addr);\n\tpci_iounmap(pdev, addr);\n\n\tif (val == 0) {\n\t\tdrm_dbg_kms(&i915->drm, \"Device doesn't have display\\n\");\n\t\treturn &no_display;\n\t}\n\n\t*ver = REG_FIELD_GET(GMD_ID_ARCH_MASK, val);\n\t*rel = REG_FIELD_GET(GMD_ID_RELEASE_MASK, val);\n\t*step = REG_FIELD_GET(GMD_ID_STEP, val);\n\n\tfor (i = 0; i < ARRAY_SIZE(gmdid_display_map); i++)\n\t\tif (*ver == gmdid_display_map[i].ver &&\n\t\t    *rel == gmdid_display_map[i].rel)\n\t\t\treturn gmdid_display_map[i].display;\n\n\tdrm_err(&i915->drm, \"Unrecognized display IP version %d.%02d; disabling display.\\n\",\n\t\t*ver, *rel);\n\treturn &no_display;\n}\n\nconst struct intel_display_device_info *\nintel_display_device_probe(struct drm_i915_private *i915, bool has_gmdid,\n\t\t\t   u16 *gmdid_ver, u16 *gmdid_rel, u16 *gmdid_step)\n{\n\tstruct pci_dev *pdev = to_pci_dev(i915->drm.dev);\n\tint i;\n\n\tif (has_gmdid)\n\t\treturn probe_gmdid_display(i915, gmdid_ver, gmdid_rel, gmdid_step);\n\n\tif (has_no_display(pdev)) {\n\t\tdrm_dbg_kms(&i915->drm, \"Device doesn't have display\\n\");\n\t\treturn &no_display;\n\t}\n\n\tfor (i = 0; i < ARRAY_SIZE(intel_display_ids); i++) {\n\t\tif (intel_display_ids[i].devid == pdev->device)\n\t\t\treturn intel_display_ids[i].info;\n\t}\n\n\tdrm_dbg(&i915->drm, \"No display ID found for device ID %04x; disabling display.\\n\",\n\t\tpdev->device);\n\n\treturn &no_display;\n}\n\nvoid intel_display_device_info_runtime_init(struct drm_i915_private *i915)\n{\n\tstruct intel_display_runtime_info *display_runtime = DISPLAY_RUNTIME_INFO(i915);\n\tenum pipe pipe;\n\n\tBUILD_BUG_ON(BITS_PER_TYPE(display_runtime->pipe_mask) < I915_MAX_PIPES);\n\tBUILD_BUG_ON(BITS_PER_TYPE(display_runtime->cpu_transcoder_mask) < I915_MAX_TRANSCODERS);\n\tBUILD_BUG_ON(BITS_PER_TYPE(display_runtime->port_mask) < I915_MAX_PORTS);\n\n\t \n\tif (IS_ALDERLAKE_S(i915) && IS_DISPLAY_STEP(i915, STEP_A0, STEP_A2))\n\t\tfor_each_pipe(i915, pipe)\n\t\t\tdisplay_runtime->num_scalers[pipe] = 0;\n\telse if (DISPLAY_VER(i915) >= 11) {\n\t\tfor_each_pipe(i915, pipe)\n\t\t\tdisplay_runtime->num_scalers[pipe] = 2;\n\t} else if (DISPLAY_VER(i915) >= 9) {\n\t\tdisplay_runtime->num_scalers[PIPE_A] = 2;\n\t\tdisplay_runtime->num_scalers[PIPE_B] = 2;\n\t\tdisplay_runtime->num_scalers[PIPE_C] = 1;\n\t}\n\n\tif (DISPLAY_VER(i915) >= 13 || HAS_D12_PLANE_MINIMIZATION(i915))\n\t\tfor_each_pipe(i915, pipe)\n\t\t\tdisplay_runtime->num_sprites[pipe] = 4;\n\telse if (DISPLAY_VER(i915) >= 11)\n\t\tfor_each_pipe(i915, pipe)\n\t\t\tdisplay_runtime->num_sprites[pipe] = 6;\n\telse if (DISPLAY_VER(i915) == 10)\n\t\tfor_each_pipe(i915, pipe)\n\t\t\tdisplay_runtime->num_sprites[pipe] = 3;\n\telse if (IS_BROXTON(i915)) {\n\t\t \n\n\t\tdisplay_runtime->num_sprites[PIPE_A] = 2;\n\t\tdisplay_runtime->num_sprites[PIPE_B] = 2;\n\t\tdisplay_runtime->num_sprites[PIPE_C] = 1;\n\t} else if (IS_VALLEYVIEW(i915) || IS_CHERRYVIEW(i915)) {\n\t\tfor_each_pipe(i915, pipe)\n\t\t\tdisplay_runtime->num_sprites[pipe] = 2;\n\t} else if (DISPLAY_VER(i915) >= 5 || IS_G4X(i915)) {\n\t\tfor_each_pipe(i915, pipe)\n\t\t\tdisplay_runtime->num_sprites[pipe] = 1;\n\t}\n\n\tif ((IS_DGFX(i915) || DISPLAY_VER(i915) >= 14) &&\n\t    !(intel_de_read(i915, GU_CNTL_PROTECTED) & DEPRESENT)) {\n\t\tdrm_info(&i915->drm, \"Display not present, disabling\\n\");\n\t\tgoto display_fused_off;\n\t}\n\n\tif (IS_GRAPHICS_VER(i915, 7, 8) && HAS_PCH_SPLIT(i915)) {\n\t\tu32 fuse_strap = intel_de_read(i915, FUSE_STRAP);\n\t\tu32 sfuse_strap = intel_de_read(i915, SFUSE_STRAP);\n\n\t\t \n\t\tif (fuse_strap & ILK_INTERNAL_DISPLAY_DISABLE ||\n\t\t    sfuse_strap & SFUSE_STRAP_DISPLAY_DISABLED ||\n\t\t    (HAS_PCH_CPT(i915) &&\n\t\t     !(sfuse_strap & SFUSE_STRAP_FUSE_LOCK))) {\n\t\t\tdrm_info(&i915->drm,\n\t\t\t\t \"Display fused off, disabling\\n\");\n\t\t\tgoto display_fused_off;\n\t\t} else if (fuse_strap & IVB_PIPE_C_DISABLE) {\n\t\t\tdrm_info(&i915->drm, \"PipeC fused off\\n\");\n\t\t\tdisplay_runtime->pipe_mask &= ~BIT(PIPE_C);\n\t\t\tdisplay_runtime->cpu_transcoder_mask &= ~BIT(TRANSCODER_C);\n\t\t}\n\t} else if (DISPLAY_VER(i915) >= 9) {\n\t\tu32 dfsm = intel_de_read(i915, SKL_DFSM);\n\n\t\tif (dfsm & SKL_DFSM_PIPE_A_DISABLE) {\n\t\t\tdisplay_runtime->pipe_mask &= ~BIT(PIPE_A);\n\t\t\tdisplay_runtime->cpu_transcoder_mask &= ~BIT(TRANSCODER_A);\n\t\t\tdisplay_runtime->fbc_mask &= ~BIT(INTEL_FBC_A);\n\t\t}\n\t\tif (dfsm & SKL_DFSM_PIPE_B_DISABLE) {\n\t\t\tdisplay_runtime->pipe_mask &= ~BIT(PIPE_B);\n\t\t\tdisplay_runtime->cpu_transcoder_mask &= ~BIT(TRANSCODER_B);\n\t\t}\n\t\tif (dfsm & SKL_DFSM_PIPE_C_DISABLE) {\n\t\t\tdisplay_runtime->pipe_mask &= ~BIT(PIPE_C);\n\t\t\tdisplay_runtime->cpu_transcoder_mask &= ~BIT(TRANSCODER_C);\n\t\t}\n\n\t\tif (DISPLAY_VER(i915) >= 12 &&\n\t\t    (dfsm & TGL_DFSM_PIPE_D_DISABLE)) {\n\t\t\tdisplay_runtime->pipe_mask &= ~BIT(PIPE_D);\n\t\t\tdisplay_runtime->cpu_transcoder_mask &= ~BIT(TRANSCODER_D);\n\t\t}\n\n\t\tif (!display_runtime->pipe_mask)\n\t\t\tgoto display_fused_off;\n\n\t\tif (dfsm & SKL_DFSM_DISPLAY_HDCP_DISABLE)\n\t\t\tdisplay_runtime->has_hdcp = 0;\n\n\t\tif (dfsm & SKL_DFSM_DISPLAY_PM_DISABLE)\n\t\t\tdisplay_runtime->fbc_mask = 0;\n\n\t\tif (DISPLAY_VER(i915) >= 11 && (dfsm & ICL_DFSM_DMC_DISABLE))\n\t\t\tdisplay_runtime->has_dmc = 0;\n\n\t\tif (IS_DISPLAY_VER(i915, 10, 12) &&\n\t\t    (dfsm & GLK_DFSM_DISPLAY_DSC_DISABLE))\n\t\t\tdisplay_runtime->has_dsc = 0;\n\t}\n\n\treturn;\n\ndisplay_fused_off:\n\tmemset(display_runtime, 0, sizeof(*display_runtime));\n}\n\nvoid intel_display_device_info_print(const struct intel_display_device_info *info,\n\t\t\t\t     const struct intel_display_runtime_info *runtime,\n\t\t\t\t     struct drm_printer *p)\n{\n\tif (runtime->ip.rel)\n\t\tdrm_printf(p, \"display version: %u.%02u\\n\",\n\t\t\t   runtime->ip.ver,\n\t\t\t   runtime->ip.rel);\n\telse\n\t\tdrm_printf(p, \"display version: %u\\n\",\n\t\t\t   runtime->ip.ver);\n\n#define PRINT_FLAG(name) drm_printf(p, \"%s: %s\\n\", #name, str_yes_no(info->name))\n\tDEV_INFO_DISPLAY_FOR_EACH_FLAG(PRINT_FLAG);\n#undef PRINT_FLAG\n\n\tdrm_printf(p, \"has_hdcp: %s\\n\", str_yes_no(runtime->has_hdcp));\n\tdrm_printf(p, \"has_dmc: %s\\n\", str_yes_no(runtime->has_dmc));\n\tdrm_printf(p, \"has_dsc: %s\\n\", str_yes_no(runtime->has_dsc));\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}