{
  "module_name": "intel_dp_aux_backlight.c",
  "hash_id": "3036788c907bcc3fe69eff55ade75a4340fe456e134cb08fdcd3a088db5dee27",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/i915/display/intel_dp_aux_backlight.c",
  "human_readable_source": " \n\n \n\n#include \"i915_drv.h\"\n#include \"intel_backlight.h\"\n#include \"intel_display_types.h\"\n#include \"intel_dp.h\"\n#include \"intel_dp_aux_backlight.h\"\n\n \n\n \n#define INTEL_EDP_HDR_TCON_CAP0                                        0x340\n\n#define INTEL_EDP_HDR_TCON_CAP1                                        0x341\n# define INTEL_EDP_HDR_TCON_2084_DECODE_CAP                           BIT(0)\n# define INTEL_EDP_HDR_TCON_2020_GAMUT_CAP                            BIT(1)\n# define INTEL_EDP_HDR_TCON_TONE_MAPPING_CAP                          BIT(2)\n# define INTEL_EDP_HDR_TCON_SEGMENTED_BACKLIGHT_CAP                   BIT(3)\n# define INTEL_EDP_HDR_TCON_BRIGHTNESS_NITS_CAP                       BIT(4)\n# define INTEL_EDP_HDR_TCON_OPTIMIZATION_CAP                          BIT(5)\n# define INTEL_EDP_HDR_TCON_SDP_COLORIMETRY_CAP                       BIT(6)\n# define INTEL_EDP_HDR_TCON_SRGB_TO_PANEL_GAMUT_CONVERSION_CAP        BIT(7)\n\n#define INTEL_EDP_HDR_TCON_CAP2                                        0x342\n# define INTEL_EDP_SDR_TCON_BRIGHTNESS_AUX_CAP                        BIT(0)\n\n#define INTEL_EDP_HDR_TCON_CAP3                                        0x343\n\n#define INTEL_EDP_HDR_GETSET_CTRL_PARAMS                               0x344\n# define INTEL_EDP_HDR_TCON_2084_DECODE_ENABLE                        BIT(0)\n# define INTEL_EDP_HDR_TCON_2020_GAMUT_ENABLE                         BIT(1)\n# define INTEL_EDP_HDR_TCON_TONE_MAPPING_ENABLE                       BIT(2)  \n# define INTEL_EDP_HDR_TCON_SEGMENTED_BACKLIGHT_ENABLE                BIT(3)\n# define INTEL_EDP_HDR_TCON_BRIGHTNESS_AUX_ENABLE                     BIT(4)\n# define INTEL_EDP_HDR_TCON_SRGB_TO_PANEL_GAMUT_ENABLE                BIT(5)\n \n# define INTEL_EDP_HDR_TCON_SDP_COLORIMETRY_ENABLE                    BIT(7)\n\n#define INTEL_EDP_HDR_CONTENT_LUMINANCE                                0x346  \n#define INTEL_EDP_HDR_PANEL_LUMINANCE_OVERRIDE                         0x34A\n#define INTEL_EDP_SDR_LUMINANCE_LEVEL                                  0x352\n#define INTEL_EDP_BRIGHTNESS_NITS_LSB                                  0x354\n#define INTEL_EDP_BRIGHTNESS_NITS_MSB                                  0x355\n#define INTEL_EDP_BRIGHTNESS_DELAY_FRAMES                              0x356\n#define INTEL_EDP_BRIGHTNESS_PER_FRAME_STEPS                           0x357\n\n#define INTEL_EDP_BRIGHTNESS_OPTIMIZATION_0                            0x358\n# define INTEL_EDP_TCON_USAGE_MASK                             GENMASK(0, 3)\n# define INTEL_EDP_TCON_USAGE_UNKNOWN                                    0x0\n# define INTEL_EDP_TCON_USAGE_DESKTOP                                    0x1\n# define INTEL_EDP_TCON_USAGE_FULL_SCREEN_MEDIA                          0x2\n# define INTEL_EDP_TCON_USAGE_FULL_SCREEN_GAMING                         0x3\n# define INTEL_EDP_TCON_POWER_MASK                                    BIT(4)\n# define INTEL_EDP_TCON_POWER_DC                                    (0 << 4)\n# define INTEL_EDP_TCON_POWER_AC                                    (1 << 4)\n# define INTEL_EDP_TCON_OPTIMIZATION_STRENGTH_MASK             GENMASK(5, 7)\n\n#define INTEL_EDP_BRIGHTNESS_OPTIMIZATION_1                            0x359\n\nenum intel_dp_aux_backlight_modparam {\n\tINTEL_DP_AUX_BACKLIGHT_AUTO = -1,\n\tINTEL_DP_AUX_BACKLIGHT_OFF = 0,\n\tINTEL_DP_AUX_BACKLIGHT_ON = 1,\n\tINTEL_DP_AUX_BACKLIGHT_FORCE_VESA = 2,\n\tINTEL_DP_AUX_BACKLIGHT_FORCE_INTEL = 3,\n};\n\nstatic bool is_intel_tcon_cap(const u8 tcon_cap[4])\n{\n\treturn tcon_cap[0] >= 1;\n}\n\n \nstatic bool\nintel_dp_aux_supports_hdr_backlight(struct intel_connector *connector)\n{\n\tstruct drm_i915_private *i915 = to_i915(connector->base.dev);\n\tstruct intel_dp *intel_dp = enc_to_intel_dp(connector->encoder);\n\tstruct drm_dp_aux *aux = &intel_dp->aux;\n\tstruct intel_panel *panel = &connector->panel;\n\tint ret;\n\tu8 tcon_cap[4];\n\n\tintel_dp_wait_source_oui(intel_dp);\n\n\tret = drm_dp_dpcd_read(aux, INTEL_EDP_HDR_TCON_CAP0, tcon_cap, sizeof(tcon_cap));\n\tif (ret != sizeof(tcon_cap))\n\t\treturn false;\n\n\tif (!(tcon_cap[1] & INTEL_EDP_HDR_TCON_BRIGHTNESS_NITS_CAP))\n\t\treturn false;\n\n\tdrm_dbg_kms(&i915->drm, \"[CONNECTOR:%d:%s] Detected %s HDR backlight interface version %d\\n\",\n\t\t    connector->base.base.id, connector->base.name,\n\t\t    is_intel_tcon_cap(tcon_cap) ? \"Intel\" : \"unsupported\", tcon_cap[0]);\n\n\tif (!is_intel_tcon_cap(tcon_cap))\n\t\treturn false;\n\n\t \n\tif (i915->params.enable_dpcd_backlight != INTEL_DP_AUX_BACKLIGHT_FORCE_INTEL &&\n\t    !(connector->base.hdr_sink_metadata.hdmi_type1.metadata_type &\n\t      BIT(HDMI_STATIC_METADATA_TYPE1))) {\n\t\tdrm_info(&i915->drm,\n\t\t\t \"[CONNECTOR:%d:%s] Panel is missing HDR static metadata. Possible support for Intel HDR backlight interface is not used. If your backlight controls don't work try booting with i915.enable_dpcd_backlight=%d. needs this, please file a _new_ bug report on drm/i915, see \" FDO_BUG_URL \" for details.\\n\",\n\t\t\t connector->base.base.id, connector->base.name,\n\t\t\t INTEL_DP_AUX_BACKLIGHT_FORCE_INTEL);\n\t\treturn false;\n\t}\n\n\tpanel->backlight.edp.intel.sdr_uses_aux =\n\t\ttcon_cap[2] & INTEL_EDP_SDR_TCON_BRIGHTNESS_AUX_CAP;\n\n\treturn true;\n}\n\nstatic u32\nintel_dp_aux_hdr_get_backlight(struct intel_connector *connector, enum pipe pipe)\n{\n\tstruct drm_i915_private *i915 = to_i915(connector->base.dev);\n\tstruct intel_panel *panel = &connector->panel;\n\tstruct intel_dp *intel_dp = enc_to_intel_dp(connector->encoder);\n\tu8 tmp;\n\tu8 buf[2] = { 0 };\n\n\tif (drm_dp_dpcd_readb(&intel_dp->aux, INTEL_EDP_HDR_GETSET_CTRL_PARAMS, &tmp) != 1) {\n\t\tdrm_err(&i915->drm, \"[CONNECTOR:%d:%s] Failed to read current backlight mode from DPCD\\n\",\n\t\t\tconnector->base.base.id, connector->base.name);\n\t\treturn 0;\n\t}\n\n\tif (!(tmp & INTEL_EDP_HDR_TCON_BRIGHTNESS_AUX_ENABLE)) {\n\t\tif (!panel->backlight.edp.intel.sdr_uses_aux) {\n\t\t\tu32 pwm_level = panel->backlight.pwm_funcs->get(connector, pipe);\n\n\t\t\treturn intel_backlight_level_from_pwm(connector, pwm_level);\n\t\t}\n\n\t\t \n\t\treturn panel->backlight.max;\n\t}\n\n\tif (drm_dp_dpcd_read(&intel_dp->aux, INTEL_EDP_BRIGHTNESS_NITS_LSB, buf,\n\t\t\t     sizeof(buf)) != sizeof(buf)) {\n\t\tdrm_err(&i915->drm, \"[CONNECTOR:%d:%s] Failed to read brightness from DPCD\\n\",\n\t\t\tconnector->base.base.id, connector->base.name);\n\t\treturn 0;\n\t}\n\n\treturn (buf[1] << 8 | buf[0]);\n}\n\nstatic void\nintel_dp_aux_hdr_set_aux_backlight(const struct drm_connector_state *conn_state, u32 level)\n{\n\tstruct intel_connector *connector = to_intel_connector(conn_state->connector);\n\tstruct drm_device *dev = connector->base.dev;\n\tstruct intel_dp *intel_dp = enc_to_intel_dp(connector->encoder);\n\tu8 buf[4] = { 0 };\n\n\tbuf[0] = level & 0xFF;\n\tbuf[1] = (level & 0xFF00) >> 8;\n\n\tif (drm_dp_dpcd_write(&intel_dp->aux, INTEL_EDP_BRIGHTNESS_NITS_LSB, buf,\n\t\t\t      sizeof(buf)) != sizeof(buf))\n\t\tdrm_err(dev, \"[CONNECTOR:%d:%s] Failed to write brightness level to DPCD\\n\",\n\t\t\tconnector->base.base.id, connector->base.name);\n}\n\nstatic void\nintel_dp_aux_hdr_set_backlight(const struct drm_connector_state *conn_state, u32 level)\n{\n\tstruct intel_connector *connector = to_intel_connector(conn_state->connector);\n\tstruct intel_panel *panel = &connector->panel;\n\n\tif (panel->backlight.edp.intel.sdr_uses_aux) {\n\t\tintel_dp_aux_hdr_set_aux_backlight(conn_state, level);\n\t} else {\n\t\tconst u32 pwm_level = intel_backlight_level_to_pwm(connector, level);\n\n\t\tintel_backlight_set_pwm_level(conn_state, pwm_level);\n\t}\n}\n\nstatic void\nintel_dp_aux_hdr_enable_backlight(const struct intel_crtc_state *crtc_state,\n\t\t\t\t  const struct drm_connector_state *conn_state, u32 level)\n{\n\tstruct intel_connector *connector = to_intel_connector(conn_state->connector);\n\tstruct intel_panel *panel = &connector->panel;\n\tstruct drm_i915_private *i915 = to_i915(connector->base.dev);\n\tstruct intel_dp *intel_dp = enc_to_intel_dp(connector->encoder);\n\tint ret;\n\tu8 old_ctrl, ctrl;\n\n\tintel_dp_wait_source_oui(intel_dp);\n\n\tret = drm_dp_dpcd_readb(&intel_dp->aux, INTEL_EDP_HDR_GETSET_CTRL_PARAMS, &old_ctrl);\n\tif (ret != 1) {\n\t\tdrm_err(&i915->drm, \"[CONNECTOR:%d:%s] Failed to read current backlight control mode: %d\\n\",\n\t\t\tconnector->base.base.id, connector->base.name, ret);\n\t\treturn;\n\t}\n\n\tctrl = old_ctrl;\n\tif (panel->backlight.edp.intel.sdr_uses_aux) {\n\t\tctrl |= INTEL_EDP_HDR_TCON_BRIGHTNESS_AUX_ENABLE;\n\t\tintel_dp_aux_hdr_set_aux_backlight(conn_state, level);\n\t} else {\n\t\tu32 pwm_level = intel_backlight_level_to_pwm(connector, level);\n\n\t\tpanel->backlight.pwm_funcs->enable(crtc_state, conn_state, pwm_level);\n\n\t\tctrl &= ~INTEL_EDP_HDR_TCON_BRIGHTNESS_AUX_ENABLE;\n\t}\n\n\tif (ctrl != old_ctrl &&\n\t    drm_dp_dpcd_writeb(&intel_dp->aux, INTEL_EDP_HDR_GETSET_CTRL_PARAMS, ctrl) != 1)\n\t\tdrm_err(&i915->drm, \"[CONNECTOR:%d:%s] Failed to configure DPCD brightness controls\\n\",\n\t\t\tconnector->base.base.id, connector->base.name);\n}\n\nstatic void\nintel_dp_aux_hdr_disable_backlight(const struct drm_connector_state *conn_state, u32 level)\n{\n\tstruct intel_connector *connector = to_intel_connector(conn_state->connector);\n\tstruct intel_panel *panel = &connector->panel;\n\n\t \n\tif (panel->backlight.edp.intel.sdr_uses_aux)\n\t\treturn;\n\n\t \n\tpanel->backlight.pwm_funcs->disable(conn_state, intel_backlight_invert_pwm_level(connector, 0));\n}\n\nstatic const char *dpcd_vs_pwm_str(bool aux)\n{\n\treturn aux ? \"DPCD\" : \"PWM\";\n}\n\nstatic int\nintel_dp_aux_hdr_setup_backlight(struct intel_connector *connector, enum pipe pipe)\n{\n\tstruct drm_i915_private *i915 = to_i915(connector->base.dev);\n\tstruct intel_panel *panel = &connector->panel;\n\tstruct drm_luminance_range_info *luminance_range =\n\t\t&connector->base.display_info.luminance_range;\n\tint ret;\n\n\tdrm_dbg_kms(&i915->drm, \"[CONNECTOR:%d:%s] SDR backlight is controlled through %s\\n\",\n\t\t    connector->base.base.id, connector->base.name,\n\t\t    dpcd_vs_pwm_str(panel->backlight.edp.intel.sdr_uses_aux));\n\n\tif (!panel->backlight.edp.intel.sdr_uses_aux) {\n\t\tret = panel->backlight.pwm_funcs->setup(connector, pipe);\n\t\tif (ret < 0) {\n\t\t\tdrm_err(&i915->drm,\n\t\t\t\t\"[CONNECTOR:%d:%s] Failed to setup SDR backlight controls through PWM: %d\\n\",\n\t\t\t\tconnector->base.base.id, connector->base.name, ret);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tif (luminance_range->max_luminance) {\n\t\tpanel->backlight.max = luminance_range->max_luminance;\n\t\tpanel->backlight.min = luminance_range->min_luminance;\n\t} else {\n\t\tpanel->backlight.max = 512;\n\t\tpanel->backlight.min = 0;\n\t}\n\n\tdrm_dbg_kms(&i915->drm, \"[CONNECTOR:%d:%s] Using AUX HDR interface for backlight control (range %d..%d)\\n\",\n\t\t    connector->base.base.id, connector->base.name,\n\t\t    panel->backlight.min, panel->backlight.max);\n\n\n\tpanel->backlight.level = intel_dp_aux_hdr_get_backlight(connector, pipe);\n\tpanel->backlight.enabled = panel->backlight.level != 0;\n\n\treturn 0;\n}\n\n \nstatic u32 intel_dp_aux_vesa_get_backlight(struct intel_connector *connector, enum pipe unused)\n{\n\treturn connector->panel.backlight.level;\n}\n\nstatic void\nintel_dp_aux_vesa_set_backlight(const struct drm_connector_state *conn_state, u32 level)\n{\n\tstruct intel_connector *connector = to_intel_connector(conn_state->connector);\n\tstruct intel_panel *panel = &connector->panel;\n\tstruct intel_dp *intel_dp = enc_to_intel_dp(connector->encoder);\n\n\tif (!panel->backlight.edp.vesa.info.aux_set) {\n\t\tconst u32 pwm_level = intel_backlight_level_to_pwm(connector, level);\n\n\t\tintel_backlight_set_pwm_level(conn_state, pwm_level);\n\t}\n\n\tdrm_edp_backlight_set_level(&intel_dp->aux, &panel->backlight.edp.vesa.info, level);\n}\n\nstatic void\nintel_dp_aux_vesa_enable_backlight(const struct intel_crtc_state *crtc_state,\n\t\t\t\t   const struct drm_connector_state *conn_state, u32 level)\n{\n\tstruct intel_connector *connector = to_intel_connector(conn_state->connector);\n\tstruct intel_panel *panel = &connector->panel;\n\tstruct intel_dp *intel_dp = enc_to_intel_dp(connector->encoder);\n\n\tif (!panel->backlight.edp.vesa.info.aux_enable) {\n\t\tu32 pwm_level;\n\n\t\tif (!panel->backlight.edp.vesa.info.aux_set)\n\t\t\tpwm_level = intel_backlight_level_to_pwm(connector, level);\n\t\telse\n\t\t\tpwm_level = intel_backlight_invert_pwm_level(connector,\n\t\t\t\t\t\t\t\t     panel->backlight.pwm_level_max);\n\n\t\tpanel->backlight.pwm_funcs->enable(crtc_state, conn_state, pwm_level);\n\t}\n\n\tdrm_edp_backlight_enable(&intel_dp->aux, &panel->backlight.edp.vesa.info, level);\n}\n\nstatic void intel_dp_aux_vesa_disable_backlight(const struct drm_connector_state *old_conn_state,\n\t\t\t\t\t\tu32 level)\n{\n\tstruct intel_connector *connector = to_intel_connector(old_conn_state->connector);\n\tstruct intel_panel *panel = &connector->panel;\n\tstruct intel_dp *intel_dp = enc_to_intel_dp(connector->encoder);\n\n\tdrm_edp_backlight_disable(&intel_dp->aux, &panel->backlight.edp.vesa.info);\n\n\tif (!panel->backlight.edp.vesa.info.aux_enable)\n\t\tpanel->backlight.pwm_funcs->disable(old_conn_state,\n\t\t\t\t\t\t    intel_backlight_invert_pwm_level(connector, 0));\n}\n\nstatic int intel_dp_aux_vesa_setup_backlight(struct intel_connector *connector, enum pipe pipe)\n{\n\tstruct intel_dp *intel_dp = intel_attached_dp(connector);\n\tstruct intel_panel *panel = &connector->panel;\n\tstruct drm_i915_private *i915 = dp_to_i915(intel_dp);\n\tu16 current_level;\n\tu8 current_mode;\n\tint ret;\n\n\tret = drm_edp_backlight_init(&intel_dp->aux, &panel->backlight.edp.vesa.info,\n\t\t\t\t     panel->vbt.backlight.pwm_freq_hz, intel_dp->edp_dpcd,\n\t\t\t\t     &current_level, &current_mode);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tdrm_dbg_kms(&i915->drm, \"[CONNECTOR:%d:%s] AUX VESA backlight enable is controlled through %s\\n\",\n\t\t    connector->base.base.id, connector->base.name,\n\t\t    dpcd_vs_pwm_str(panel->backlight.edp.vesa.info.aux_enable));\n\tdrm_dbg_kms(&i915->drm, \"[CONNECTOR:%d:%s] AUX VESA backlight level is controlled through %s\\n\",\n\t\t    connector->base.base.id, connector->base.name,\n\t\t    dpcd_vs_pwm_str(panel->backlight.edp.vesa.info.aux_set));\n\n\tif (!panel->backlight.edp.vesa.info.aux_set || !panel->backlight.edp.vesa.info.aux_enable) {\n\t\tret = panel->backlight.pwm_funcs->setup(connector, pipe);\n\t\tif (ret < 0) {\n\t\t\tdrm_err(&i915->drm,\n\t\t\t\t\"[CONNECTOR:%d:%s] Failed to setup PWM backlight controls for eDP backlight: %d\\n\",\n\t\t\t\tconnector->base.base.id, connector->base.name, ret);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tif (panel->backlight.edp.vesa.info.aux_set) {\n\t\tpanel->backlight.max = panel->backlight.edp.vesa.info.max;\n\t\tpanel->backlight.min = 0;\n\t\tif (current_mode == DP_EDP_BACKLIGHT_CONTROL_MODE_DPCD) {\n\t\t\tpanel->backlight.level = current_level;\n\t\t\tpanel->backlight.enabled = panel->backlight.level != 0;\n\t\t} else {\n\t\t\tpanel->backlight.level = panel->backlight.max;\n\t\t\tpanel->backlight.enabled = false;\n\t\t}\n\t} else {\n\t\tpanel->backlight.max = panel->backlight.pwm_level_max;\n\t\tpanel->backlight.min = panel->backlight.pwm_level_min;\n\t\tif (current_mode == DP_EDP_BACKLIGHT_CONTROL_MODE_PWM) {\n\t\t\tpanel->backlight.level = panel->backlight.pwm_funcs->get(connector, pipe);\n\t\t\tpanel->backlight.enabled = panel->backlight.pwm_enabled;\n\t\t} else {\n\t\t\tpanel->backlight.level = panel->backlight.max;\n\t\t\tpanel->backlight.enabled = false;\n\t\t}\n\t}\n\n\tdrm_dbg_kms(&i915->drm, \"[CONNECTOR:%d:%s] Using AUX VESA interface for backlight control\\n\",\n\t\t    connector->base.base.id, connector->base.name);\n\n\treturn 0;\n}\n\nstatic bool\nintel_dp_aux_supports_vesa_backlight(struct intel_connector *connector)\n{\n\tstruct intel_dp *intel_dp = intel_attached_dp(connector);\n\tstruct drm_i915_private *i915 = dp_to_i915(intel_dp);\n\n\tif (drm_edp_backlight_supported(intel_dp->edp_dpcd)) {\n\t\tdrm_dbg_kms(&i915->drm, \"[CONNECTOR:%d:%s] AUX Backlight Control Supported!\\n\",\n\t\t\t    connector->base.base.id, connector->base.name);\n\t\treturn true;\n\t}\n\treturn false;\n}\n\nstatic const struct intel_panel_bl_funcs intel_dp_hdr_bl_funcs = {\n\t.setup = intel_dp_aux_hdr_setup_backlight,\n\t.enable = intel_dp_aux_hdr_enable_backlight,\n\t.disable = intel_dp_aux_hdr_disable_backlight,\n\t.set = intel_dp_aux_hdr_set_backlight,\n\t.get = intel_dp_aux_hdr_get_backlight,\n};\n\nstatic const struct intel_panel_bl_funcs intel_dp_vesa_bl_funcs = {\n\t.setup = intel_dp_aux_vesa_setup_backlight,\n\t.enable = intel_dp_aux_vesa_enable_backlight,\n\t.disable = intel_dp_aux_vesa_disable_backlight,\n\t.set = intel_dp_aux_vesa_set_backlight,\n\t.get = intel_dp_aux_vesa_get_backlight,\n};\n\nint intel_dp_aux_init_backlight_funcs(struct intel_connector *connector)\n{\n\tstruct drm_device *dev = connector->base.dev;\n\tstruct intel_panel *panel = &connector->panel;\n\tstruct intel_dp *intel_dp = enc_to_intel_dp(connector->encoder);\n\tstruct drm_i915_private *i915 = dp_to_i915(intel_dp);\n\tbool try_intel_interface = false, try_vesa_interface = false;\n\n\t \n\tswitch (i915->params.enable_dpcd_backlight) {\n\tcase INTEL_DP_AUX_BACKLIGHT_OFF:\n\t\treturn -ENODEV;\n\tcase INTEL_DP_AUX_BACKLIGHT_AUTO:\n\t\tswitch (panel->vbt.backlight.type) {\n\t\tcase INTEL_BACKLIGHT_VESA_EDP_AUX_INTERFACE:\n\t\t\ttry_vesa_interface = true;\n\t\t\tbreak;\n\t\tcase INTEL_BACKLIGHT_DISPLAY_DDI:\n\t\t\ttry_intel_interface = true;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -ENODEV;\n\t\t}\n\t\tbreak;\n\tcase INTEL_DP_AUX_BACKLIGHT_ON:\n\t\tif (panel->vbt.backlight.type != INTEL_BACKLIGHT_VESA_EDP_AUX_INTERFACE)\n\t\t\ttry_intel_interface = true;\n\n\t\ttry_vesa_interface = true;\n\t\tbreak;\n\tcase INTEL_DP_AUX_BACKLIGHT_FORCE_VESA:\n\t\ttry_vesa_interface = true;\n\t\tbreak;\n\tcase INTEL_DP_AUX_BACKLIGHT_FORCE_INTEL:\n\t\ttry_intel_interface = true;\n\t\tbreak;\n\t}\n\n\t \n\tif (try_intel_interface && intel_dp_aux_supports_hdr_backlight(connector)) {\n\t\tdrm_dbg_kms(dev, \"[CONNECTOR:%d:%s] Using Intel proprietary eDP backlight controls\\n\",\n\t\t\t    connector->base.base.id, connector->base.name);\n\t\tpanel->backlight.funcs = &intel_dp_hdr_bl_funcs;\n\t\treturn 0;\n\t}\n\n\tif (try_vesa_interface && intel_dp_aux_supports_vesa_backlight(connector)) {\n\t\tdrm_dbg_kms(dev, \"[CONNECTOR:%d:%s] Using VESA eDP backlight controls\\n\",\n\t\t\t    connector->base.base.id, connector->base.name);\n\t\tpanel->backlight.funcs = &intel_dp_vesa_bl_funcs;\n\t\treturn 0;\n\t}\n\n\treturn -ENODEV;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}