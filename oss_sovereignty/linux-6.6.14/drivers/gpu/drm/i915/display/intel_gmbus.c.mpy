{
  "module_name": "intel_gmbus.c",
  "hash_id": "b74bf886340e77acc05e1afbb0bb80fbf47c4848bad4d2c20b95f793bd446d7d",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/i915/display/intel_gmbus.c",
  "human_readable_source": " \n\n#include <linux/export.h>\n#include <linux/i2c-algo-bit.h>\n#include <linux/i2c.h>\n\n#include <drm/display/drm_hdcp_helper.h>\n\n#include \"i915_drv.h\"\n#include \"i915_irq.h\"\n#include \"i915_reg.h\"\n#include \"intel_de.h\"\n#include \"intel_display_types.h\"\n#include \"intel_gmbus.h\"\n#include \"intel_gmbus_regs.h\"\n\nstruct intel_gmbus {\n\tstruct i2c_adapter adapter;\n#define GMBUS_FORCE_BIT_RETRY (1U << 31)\n\tu32 force_bit;\n\tu32 reg0;\n\ti915_reg_t gpio_reg;\n\tstruct i2c_algo_bit_data bit_algo;\n\tstruct drm_i915_private *i915;\n};\n\nenum gmbus_gpio {\n\tGPIOA,\n\tGPIOB,\n\tGPIOC,\n\tGPIOD,\n\tGPIOE,\n\tGPIOF,\n\tGPIOG,\n\tGPIOH,\n\t__GPIOI_UNUSED,\n\tGPIOJ,\n\tGPIOK,\n\tGPIOL,\n\tGPIOM,\n\tGPION,\n\tGPIOO,\n};\n\nstruct gmbus_pin {\n\tconst char *name;\n\tenum gmbus_gpio gpio;\n};\n\n \nstatic const struct gmbus_pin gmbus_pins[] = {\n\t[GMBUS_PIN_SSC] = { \"ssc\", GPIOB },\n\t[GMBUS_PIN_VGADDC] = { \"vga\", GPIOA },\n\t[GMBUS_PIN_PANEL] = { \"panel\", GPIOC },\n\t[GMBUS_PIN_DPC] = { \"dpc\", GPIOD },\n\t[GMBUS_PIN_DPB] = { \"dpb\", GPIOE },\n\t[GMBUS_PIN_DPD] = { \"dpd\", GPIOF },\n};\n\nstatic const struct gmbus_pin gmbus_pins_bdw[] = {\n\t[GMBUS_PIN_VGADDC] = { \"vga\", GPIOA },\n\t[GMBUS_PIN_DPC] = { \"dpc\", GPIOD },\n\t[GMBUS_PIN_DPB] = { \"dpb\", GPIOE },\n\t[GMBUS_PIN_DPD] = { \"dpd\", GPIOF },\n};\n\nstatic const struct gmbus_pin gmbus_pins_skl[] = {\n\t[GMBUS_PIN_DPC] = { \"dpc\", GPIOD },\n\t[GMBUS_PIN_DPB] = { \"dpb\", GPIOE },\n\t[GMBUS_PIN_DPD] = { \"dpd\", GPIOF },\n};\n\nstatic const struct gmbus_pin gmbus_pins_bxt[] = {\n\t[GMBUS_PIN_1_BXT] = { \"dpb\", GPIOB },\n\t[GMBUS_PIN_2_BXT] = { \"dpc\", GPIOC },\n\t[GMBUS_PIN_3_BXT] = { \"misc\", GPIOD },\n};\n\nstatic const struct gmbus_pin gmbus_pins_cnp[] = {\n\t[GMBUS_PIN_1_BXT] = { \"dpb\", GPIOB },\n\t[GMBUS_PIN_2_BXT] = { \"dpc\", GPIOC },\n\t[GMBUS_PIN_3_BXT] = { \"misc\", GPIOD },\n\t[GMBUS_PIN_4_CNP] = { \"dpd\", GPIOE },\n};\n\nstatic const struct gmbus_pin gmbus_pins_icp[] = {\n\t[GMBUS_PIN_1_BXT] = { \"dpa\", GPIOB },\n\t[GMBUS_PIN_2_BXT] = { \"dpb\", GPIOC },\n\t[GMBUS_PIN_3_BXT] = { \"dpc\", GPIOD },\n\t[GMBUS_PIN_9_TC1_ICP] = { \"tc1\", GPIOJ },\n\t[GMBUS_PIN_10_TC2_ICP] = { \"tc2\", GPIOK },\n\t[GMBUS_PIN_11_TC3_ICP] = { \"tc3\", GPIOL },\n\t[GMBUS_PIN_12_TC4_ICP] = { \"tc4\", GPIOM },\n\t[GMBUS_PIN_13_TC5_TGP] = { \"tc5\", GPION },\n\t[GMBUS_PIN_14_TC6_TGP] = { \"tc6\", GPIOO },\n};\n\nstatic const struct gmbus_pin gmbus_pins_dg1[] = {\n\t[GMBUS_PIN_1_BXT] = { \"dpa\", GPIOB },\n\t[GMBUS_PIN_2_BXT] = { \"dpb\", GPIOC },\n\t[GMBUS_PIN_3_BXT] = { \"dpc\", GPIOD },\n\t[GMBUS_PIN_4_CNP] = { \"dpd\", GPIOE },\n};\n\nstatic const struct gmbus_pin gmbus_pins_dg2[] = {\n\t[GMBUS_PIN_1_BXT] = { \"dpa\", GPIOB },\n\t[GMBUS_PIN_2_BXT] = { \"dpb\", GPIOC },\n\t[GMBUS_PIN_3_BXT] = { \"dpc\", GPIOD },\n\t[GMBUS_PIN_4_CNP] = { \"dpd\", GPIOE },\n\t[GMBUS_PIN_9_TC1_ICP] = { \"tc1\", GPIOJ },\n};\n\nstatic const struct gmbus_pin gmbus_pins_mtp[] = {\n\t[GMBUS_PIN_1_BXT] = { \"dpa\", GPIOB },\n\t[GMBUS_PIN_2_BXT] = { \"dpb\", GPIOC },\n\t[GMBUS_PIN_3_BXT] = { \"dpc\", GPIOD },\n\t[GMBUS_PIN_4_CNP] = { \"dpd\", GPIOE },\n\t[GMBUS_PIN_5_MTP] = { \"dpe\", GPIOF },\n\t[GMBUS_PIN_9_TC1_ICP] = { \"tc1\", GPIOJ },\n\t[GMBUS_PIN_10_TC2_ICP] = { \"tc2\", GPIOK },\n\t[GMBUS_PIN_11_TC3_ICP] = { \"tc3\", GPIOL },\n\t[GMBUS_PIN_12_TC4_ICP] = { \"tc4\", GPIOM },\n};\n\nstatic const struct gmbus_pin *get_gmbus_pin(struct drm_i915_private *i915,\n\t\t\t\t\t     unsigned int pin)\n{\n\tconst struct gmbus_pin *pins;\n\tsize_t size;\n\n\tif (INTEL_PCH_TYPE(i915) >= PCH_DG2) {\n\t\tpins = gmbus_pins_dg2;\n\t\tsize = ARRAY_SIZE(gmbus_pins_dg2);\n\t} else if (INTEL_PCH_TYPE(i915) >= PCH_DG1) {\n\t\tpins = gmbus_pins_dg1;\n\t\tsize = ARRAY_SIZE(gmbus_pins_dg1);\n\t} else if (INTEL_PCH_TYPE(i915) >= PCH_MTP) {\n\t\tpins = gmbus_pins_mtp;\n\t\tsize = ARRAY_SIZE(gmbus_pins_mtp);\n\t} else if (INTEL_PCH_TYPE(i915) >= PCH_ICP) {\n\t\tpins = gmbus_pins_icp;\n\t\tsize = ARRAY_SIZE(gmbus_pins_icp);\n\t} else if (HAS_PCH_CNP(i915)) {\n\t\tpins = gmbus_pins_cnp;\n\t\tsize = ARRAY_SIZE(gmbus_pins_cnp);\n\t} else if (IS_GEMINILAKE(i915) || IS_BROXTON(i915)) {\n\t\tpins = gmbus_pins_bxt;\n\t\tsize = ARRAY_SIZE(gmbus_pins_bxt);\n\t} else if (DISPLAY_VER(i915) == 9) {\n\t\tpins = gmbus_pins_skl;\n\t\tsize = ARRAY_SIZE(gmbus_pins_skl);\n\t} else if (IS_BROADWELL(i915)) {\n\t\tpins = gmbus_pins_bdw;\n\t\tsize = ARRAY_SIZE(gmbus_pins_bdw);\n\t} else {\n\t\tpins = gmbus_pins;\n\t\tsize = ARRAY_SIZE(gmbus_pins);\n\t}\n\n\tif (pin >= size || !pins[pin].name)\n\t\treturn NULL;\n\n\treturn &pins[pin];\n}\n\nbool intel_gmbus_is_valid_pin(struct drm_i915_private *i915, unsigned int pin)\n{\n\treturn get_gmbus_pin(i915, pin);\n}\n\n \n\n#define I2C_RISEFALL_TIME 10\n\nstatic inline struct intel_gmbus *\nto_intel_gmbus(struct i2c_adapter *i2c)\n{\n\treturn container_of(i2c, struct intel_gmbus, adapter);\n}\n\nvoid\nintel_gmbus_reset(struct drm_i915_private *i915)\n{\n\tintel_de_write(i915, GMBUS0(i915), 0);\n\tintel_de_write(i915, GMBUS4(i915), 0);\n}\n\nstatic void pnv_gmbus_clock_gating(struct drm_i915_private *i915,\n\t\t\t\t   bool enable)\n{\n\t \n\tintel_de_rmw(i915, DSPCLK_GATE_D(i915), PNV_GMBUSUNIT_CLOCK_GATE_DISABLE,\n\t\t     !enable ? PNV_GMBUSUNIT_CLOCK_GATE_DISABLE : 0);\n}\n\nstatic void pch_gmbus_clock_gating(struct drm_i915_private *i915,\n\t\t\t\t   bool enable)\n{\n\tintel_de_rmw(i915, SOUTH_DSPCLK_GATE_D, PCH_GMBUSUNIT_CLOCK_GATE_DISABLE,\n\t\t     !enable ? PCH_GMBUSUNIT_CLOCK_GATE_DISABLE : 0);\n}\n\nstatic void bxt_gmbus_clock_gating(struct drm_i915_private *i915,\n\t\t\t\t   bool enable)\n{\n\tintel_de_rmw(i915, GEN9_CLKGATE_DIS_4, BXT_GMBUS_GATING_DIS,\n\t\t     !enable ? BXT_GMBUS_GATING_DIS : 0);\n}\n\nstatic u32 get_reserved(struct intel_gmbus *bus)\n{\n\tstruct drm_i915_private *i915 = bus->i915;\n\tu32 reserved = 0;\n\n\t \n\tif (!IS_I830(i915) && !IS_I845G(i915))\n\t\treserved = intel_de_read_notrace(i915, bus->gpio_reg) &\n\t\t\t(GPIO_DATA_PULLUP_DISABLE | GPIO_CLOCK_PULLUP_DISABLE);\n\n\treturn reserved;\n}\n\nstatic int get_clock(void *data)\n{\n\tstruct intel_gmbus *bus = data;\n\tstruct drm_i915_private *i915 = bus->i915;\n\tu32 reserved = get_reserved(bus);\n\n\tintel_de_write_notrace(i915, bus->gpio_reg, reserved | GPIO_CLOCK_DIR_MASK);\n\tintel_de_write_notrace(i915, bus->gpio_reg, reserved);\n\n\treturn (intel_de_read_notrace(i915, bus->gpio_reg) & GPIO_CLOCK_VAL_IN) != 0;\n}\n\nstatic int get_data(void *data)\n{\n\tstruct intel_gmbus *bus = data;\n\tstruct drm_i915_private *i915 = bus->i915;\n\tu32 reserved = get_reserved(bus);\n\n\tintel_de_write_notrace(i915, bus->gpio_reg, reserved | GPIO_DATA_DIR_MASK);\n\tintel_de_write_notrace(i915, bus->gpio_reg, reserved);\n\n\treturn (intel_de_read_notrace(i915, bus->gpio_reg) & GPIO_DATA_VAL_IN) != 0;\n}\n\nstatic void set_clock(void *data, int state_high)\n{\n\tstruct intel_gmbus *bus = data;\n\tstruct drm_i915_private *i915 = bus->i915;\n\tu32 reserved = get_reserved(bus);\n\tu32 clock_bits;\n\n\tif (state_high)\n\t\tclock_bits = GPIO_CLOCK_DIR_IN | GPIO_CLOCK_DIR_MASK;\n\telse\n\t\tclock_bits = GPIO_CLOCK_DIR_OUT | GPIO_CLOCK_DIR_MASK |\n\t\t\t     GPIO_CLOCK_VAL_MASK;\n\n\tintel_de_write_notrace(i915, bus->gpio_reg, reserved | clock_bits);\n\tintel_de_posting_read(i915, bus->gpio_reg);\n}\n\nstatic void set_data(void *data, int state_high)\n{\n\tstruct intel_gmbus *bus = data;\n\tstruct drm_i915_private *i915 = bus->i915;\n\tu32 reserved = get_reserved(bus);\n\tu32 data_bits;\n\n\tif (state_high)\n\t\tdata_bits = GPIO_DATA_DIR_IN | GPIO_DATA_DIR_MASK;\n\telse\n\t\tdata_bits = GPIO_DATA_DIR_OUT | GPIO_DATA_DIR_MASK |\n\t\t\tGPIO_DATA_VAL_MASK;\n\n\tintel_de_write_notrace(i915, bus->gpio_reg, reserved | data_bits);\n\tintel_de_posting_read(i915, bus->gpio_reg);\n}\n\nstatic int\nintel_gpio_pre_xfer(struct i2c_adapter *adapter)\n{\n\tstruct intel_gmbus *bus = to_intel_gmbus(adapter);\n\tstruct drm_i915_private *i915 = bus->i915;\n\n\tintel_gmbus_reset(i915);\n\n\tif (IS_PINEVIEW(i915))\n\t\tpnv_gmbus_clock_gating(i915, false);\n\n\tset_data(bus, 1);\n\tset_clock(bus, 1);\n\tudelay(I2C_RISEFALL_TIME);\n\treturn 0;\n}\n\nstatic void\nintel_gpio_post_xfer(struct i2c_adapter *adapter)\n{\n\tstruct intel_gmbus *bus = to_intel_gmbus(adapter);\n\tstruct drm_i915_private *i915 = bus->i915;\n\n\tset_data(bus, 1);\n\tset_clock(bus, 1);\n\n\tif (IS_PINEVIEW(i915))\n\t\tpnv_gmbus_clock_gating(i915, true);\n}\n\nstatic void\nintel_gpio_setup(struct intel_gmbus *bus, i915_reg_t gpio_reg)\n{\n\tstruct i2c_algo_bit_data *algo;\n\n\talgo = &bus->bit_algo;\n\n\tbus->gpio_reg = gpio_reg;\n\tbus->adapter.algo_data = algo;\n\talgo->setsda = set_data;\n\talgo->setscl = set_clock;\n\talgo->getsda = get_data;\n\talgo->getscl = get_clock;\n\talgo->pre_xfer = intel_gpio_pre_xfer;\n\talgo->post_xfer = intel_gpio_post_xfer;\n\talgo->udelay = I2C_RISEFALL_TIME;\n\talgo->timeout = usecs_to_jiffies(2200);\n\talgo->data = bus;\n}\n\nstatic bool has_gmbus_irq(struct drm_i915_private *i915)\n{\n\t \n\treturn HAS_GMBUS_IRQ(i915) && intel_irqs_enabled(i915);\n}\n\nstatic int gmbus_wait(struct drm_i915_private *i915, u32 status, u32 irq_en)\n{\n\tDEFINE_WAIT(wait);\n\tu32 gmbus2;\n\tint ret;\n\n\t \n\tif (!has_gmbus_irq(i915))\n\t\tirq_en = 0;\n\n\tadd_wait_queue(&i915->display.gmbus.wait_queue, &wait);\n\tintel_de_write_fw(i915, GMBUS4(i915), irq_en);\n\n\tstatus |= GMBUS_SATOER;\n\tret = wait_for_us((gmbus2 = intel_de_read_fw(i915, GMBUS2(i915))) & status,\n\t\t\t  2);\n\tif (ret)\n\t\tret = wait_for((gmbus2 = intel_de_read_fw(i915, GMBUS2(i915))) & status,\n\t\t\t       50);\n\n\tintel_de_write_fw(i915, GMBUS4(i915), 0);\n\tremove_wait_queue(&i915->display.gmbus.wait_queue, &wait);\n\n\tif (gmbus2 & GMBUS_SATOER)\n\t\treturn -ENXIO;\n\n\treturn ret;\n}\n\nstatic int\ngmbus_wait_idle(struct drm_i915_private *i915)\n{\n\tDEFINE_WAIT(wait);\n\tu32 irq_enable;\n\tint ret;\n\n\t \n\tirq_enable = 0;\n\tif (has_gmbus_irq(i915))\n\t\tirq_enable = GMBUS_IDLE_EN;\n\n\tadd_wait_queue(&i915->display.gmbus.wait_queue, &wait);\n\tintel_de_write_fw(i915, GMBUS4(i915), irq_enable);\n\n\tret = intel_de_wait_for_register_fw(i915, GMBUS2(i915), GMBUS_ACTIVE, 0, 10);\n\n\tintel_de_write_fw(i915, GMBUS4(i915), 0);\n\tremove_wait_queue(&i915->display.gmbus.wait_queue, &wait);\n\n\treturn ret;\n}\n\nstatic unsigned int gmbus_max_xfer_size(struct drm_i915_private *i915)\n{\n\treturn DISPLAY_VER(i915) >= 9 ? GEN9_GMBUS_BYTE_COUNT_MAX :\n\t       GMBUS_BYTE_COUNT_MAX;\n}\n\nstatic int\ngmbus_xfer_read_chunk(struct drm_i915_private *i915,\n\t\t      unsigned short addr, u8 *buf, unsigned int len,\n\t\t      u32 gmbus0_reg, u32 gmbus1_index)\n{\n\tunsigned int size = len;\n\tbool burst_read = len > gmbus_max_xfer_size(i915);\n\tbool extra_byte_added = false;\n\n\tif (burst_read) {\n\t\t \n\t\tif (len == 512) {\n\t\t\textra_byte_added = true;\n\t\t\tlen++;\n\t\t}\n\t\tsize = len % 256 + 256;\n\t\tintel_de_write_fw(i915, GMBUS0(i915),\n\t\t\t\t  gmbus0_reg | GMBUS_BYTE_CNT_OVERRIDE);\n\t}\n\n\tintel_de_write_fw(i915, GMBUS1(i915),\n\t\t\t  gmbus1_index | GMBUS_CYCLE_WAIT | (size << GMBUS_BYTE_COUNT_SHIFT) | (addr << GMBUS_SLAVE_ADDR_SHIFT) | GMBUS_SLAVE_READ | GMBUS_SW_RDY);\n\twhile (len) {\n\t\tint ret;\n\t\tu32 val, loop = 0;\n\n\t\tret = gmbus_wait(i915, GMBUS_HW_RDY, GMBUS_HW_RDY_EN);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tval = intel_de_read_fw(i915, GMBUS3(i915));\n\t\tdo {\n\t\t\tif (extra_byte_added && len == 1)\n\t\t\t\tbreak;\n\n\t\t\t*buf++ = val & 0xff;\n\t\t\tval >>= 8;\n\t\t} while (--len && ++loop < 4);\n\n\t\tif (burst_read && len == size - 4)\n\t\t\t \n\t\t\tintel_de_write_fw(i915, GMBUS0(i915), gmbus0_reg);\n\t}\n\n\treturn 0;\n}\n\n \n#define INTEL_GMBUS_BURST_READ_MAX_LEN\t\t767U\n\nstatic int\ngmbus_xfer_read(struct drm_i915_private *i915, struct i2c_msg *msg,\n\t\tu32 gmbus0_reg, u32 gmbus1_index)\n{\n\tu8 *buf = msg->buf;\n\tunsigned int rx_size = msg->len;\n\tunsigned int len;\n\tint ret;\n\n\tdo {\n\t\tif (HAS_GMBUS_BURST_READ(i915))\n\t\t\tlen = min(rx_size, INTEL_GMBUS_BURST_READ_MAX_LEN);\n\t\telse\n\t\t\tlen = min(rx_size, gmbus_max_xfer_size(i915));\n\n\t\tret = gmbus_xfer_read_chunk(i915, msg->addr, buf, len,\n\t\t\t\t\t    gmbus0_reg, gmbus1_index);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\trx_size -= len;\n\t\tbuf += len;\n\t} while (rx_size != 0);\n\n\treturn 0;\n}\n\nstatic int\ngmbus_xfer_write_chunk(struct drm_i915_private *i915,\n\t\t       unsigned short addr, u8 *buf, unsigned int len,\n\t\t       u32 gmbus1_index)\n{\n\tunsigned int chunk_size = len;\n\tu32 val, loop;\n\n\tval = loop = 0;\n\twhile (len && loop < 4) {\n\t\tval |= *buf++ << (8 * loop++);\n\t\tlen -= 1;\n\t}\n\n\tintel_de_write_fw(i915, GMBUS3(i915), val);\n\tintel_de_write_fw(i915, GMBUS1(i915),\n\t\t\t  gmbus1_index | GMBUS_CYCLE_WAIT | (chunk_size << GMBUS_BYTE_COUNT_SHIFT) | (addr << GMBUS_SLAVE_ADDR_SHIFT) | GMBUS_SLAVE_WRITE | GMBUS_SW_RDY);\n\twhile (len) {\n\t\tint ret;\n\n\t\tval = loop = 0;\n\t\tdo {\n\t\t\tval |= *buf++ << (8 * loop);\n\t\t} while (--len && ++loop < 4);\n\n\t\tintel_de_write_fw(i915, GMBUS3(i915), val);\n\n\t\tret = gmbus_wait(i915, GMBUS_HW_RDY, GMBUS_HW_RDY_EN);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int\ngmbus_xfer_write(struct drm_i915_private *i915, struct i2c_msg *msg,\n\t\t u32 gmbus1_index)\n{\n\tu8 *buf = msg->buf;\n\tunsigned int tx_size = msg->len;\n\tunsigned int len;\n\tint ret;\n\n\tdo {\n\t\tlen = min(tx_size, gmbus_max_xfer_size(i915));\n\n\t\tret = gmbus_xfer_write_chunk(i915, msg->addr, buf, len,\n\t\t\t\t\t     gmbus1_index);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tbuf += len;\n\t\ttx_size -= len;\n\t} while (tx_size != 0);\n\n\treturn 0;\n}\n\n \nstatic bool\ngmbus_is_index_xfer(struct i2c_msg *msgs, int i, int num)\n{\n\treturn (i + 1 < num &&\n\t\tmsgs[i].addr == msgs[i + 1].addr &&\n\t\t!(msgs[i].flags & I2C_M_RD) &&\n\t\t(msgs[i].len == 1 || msgs[i].len == 2) &&\n\t\tmsgs[i + 1].len > 0);\n}\n\nstatic int\ngmbus_index_xfer(struct drm_i915_private *i915, struct i2c_msg *msgs,\n\t\t u32 gmbus0_reg)\n{\n\tu32 gmbus1_index = 0;\n\tu32 gmbus5 = 0;\n\tint ret;\n\n\tif (msgs[0].len == 2)\n\t\tgmbus5 = GMBUS_2BYTE_INDEX_EN |\n\t\t\t msgs[0].buf[1] | (msgs[0].buf[0] << 8);\n\tif (msgs[0].len == 1)\n\t\tgmbus1_index = GMBUS_CYCLE_INDEX |\n\t\t\t       (msgs[0].buf[0] << GMBUS_SLAVE_INDEX_SHIFT);\n\n\t \n\tif (gmbus5)\n\t\tintel_de_write_fw(i915, GMBUS5(i915), gmbus5);\n\n\tif (msgs[1].flags & I2C_M_RD)\n\t\tret = gmbus_xfer_read(i915, &msgs[1], gmbus0_reg,\n\t\t\t\t      gmbus1_index);\n\telse\n\t\tret = gmbus_xfer_write(i915, &msgs[1], gmbus1_index);\n\n\t \n\tif (gmbus5)\n\t\tintel_de_write_fw(i915, GMBUS5(i915), 0);\n\n\treturn ret;\n}\n\nstatic int\ndo_gmbus_xfer(struct i2c_adapter *adapter, struct i2c_msg *msgs, int num,\n\t      u32 gmbus0_source)\n{\n\tstruct intel_gmbus *bus = to_intel_gmbus(adapter);\n\tstruct drm_i915_private *i915 = bus->i915;\n\tint i = 0, inc, try = 0;\n\tint ret = 0;\n\n\t \n\tif (IS_GEMINILAKE(i915) || IS_BROXTON(i915))\n\t\tbxt_gmbus_clock_gating(i915, false);\n\telse if (HAS_PCH_SPT(i915) || HAS_PCH_CNP(i915))\n\t\tpch_gmbus_clock_gating(i915, false);\n\nretry:\n\tintel_de_write_fw(i915, GMBUS0(i915), gmbus0_source | bus->reg0);\n\n\tfor (; i < num; i += inc) {\n\t\tinc = 1;\n\t\tif (gmbus_is_index_xfer(msgs, i, num)) {\n\t\t\tret = gmbus_index_xfer(i915, &msgs[i],\n\t\t\t\t\t       gmbus0_source | bus->reg0);\n\t\t\tinc = 2;  \n\t\t} else if (msgs[i].flags & I2C_M_RD) {\n\t\t\tret = gmbus_xfer_read(i915, &msgs[i],\n\t\t\t\t\t      gmbus0_source | bus->reg0, 0);\n\t\t} else {\n\t\t\tret = gmbus_xfer_write(i915, &msgs[i], 0);\n\t\t}\n\n\t\tif (!ret)\n\t\t\tret = gmbus_wait(i915,\n\t\t\t\t\t GMBUS_HW_WAIT_PHASE, GMBUS_HW_WAIT_EN);\n\t\tif (ret == -ETIMEDOUT)\n\t\t\tgoto timeout;\n\t\telse if (ret)\n\t\t\tgoto clear_err;\n\t}\n\n\t \n\tintel_de_write_fw(i915, GMBUS1(i915), GMBUS_CYCLE_STOP | GMBUS_SW_RDY);\n\n\t \n\tif (gmbus_wait_idle(i915)) {\n\t\tdrm_dbg_kms(&i915->drm,\n\t\t\t    \"GMBUS [%s] timed out waiting for idle\\n\",\n\t\t\t    adapter->name);\n\t\tret = -ETIMEDOUT;\n\t}\n\tintel_de_write_fw(i915, GMBUS0(i915), 0);\n\tret = ret ?: i;\n\tgoto out;\n\nclear_err:\n\t \n\tret = -ENXIO;\n\tif (gmbus_wait_idle(i915)) {\n\t\tdrm_dbg_kms(&i915->drm,\n\t\t\t    \"GMBUS [%s] timed out after NAK\\n\",\n\t\t\t    adapter->name);\n\t\tret = -ETIMEDOUT;\n\t}\n\n\t \n\tintel_de_write_fw(i915, GMBUS1(i915), GMBUS_SW_CLR_INT);\n\tintel_de_write_fw(i915, GMBUS1(i915), 0);\n\tintel_de_write_fw(i915, GMBUS0(i915), 0);\n\n\tdrm_dbg_kms(&i915->drm, \"GMBUS [%s] NAK for addr: %04x %c(%d)\\n\",\n\t\t    adapter->name, msgs[i].addr,\n\t\t    (msgs[i].flags & I2C_M_RD) ? 'r' : 'w', msgs[i].len);\n\n\t \n\tif (ret == -ENXIO && i == 0 && try++ == 0) {\n\t\tdrm_dbg_kms(&i915->drm,\n\t\t\t    \"GMBUS [%s] NAK on first message, retry\\n\",\n\t\t\t    adapter->name);\n\t\tgoto retry;\n\t}\n\n\tgoto out;\n\ntimeout:\n\tdrm_dbg_kms(&i915->drm,\n\t\t    \"GMBUS [%s] timed out, falling back to bit banging on pin %d\\n\",\n\t\t    bus->adapter.name, bus->reg0 & 0xff);\n\tintel_de_write_fw(i915, GMBUS0(i915), 0);\n\n\t \n\tret = -EAGAIN;\n\nout:\n\t \n\tif (IS_GEMINILAKE(i915) || IS_BROXTON(i915))\n\t\tbxt_gmbus_clock_gating(i915, true);\n\telse if (HAS_PCH_SPT(i915) || HAS_PCH_CNP(i915))\n\t\tpch_gmbus_clock_gating(i915, true);\n\n\treturn ret;\n}\n\nstatic int\ngmbus_xfer(struct i2c_adapter *adapter, struct i2c_msg *msgs, int num)\n{\n\tstruct intel_gmbus *bus = to_intel_gmbus(adapter);\n\tstruct drm_i915_private *i915 = bus->i915;\n\tintel_wakeref_t wakeref;\n\tint ret;\n\n\twakeref = intel_display_power_get(i915, POWER_DOMAIN_GMBUS);\n\n\tif (bus->force_bit) {\n\t\tret = i2c_bit_algo.master_xfer(adapter, msgs, num);\n\t\tif (ret < 0)\n\t\t\tbus->force_bit &= ~GMBUS_FORCE_BIT_RETRY;\n\t} else {\n\t\tret = do_gmbus_xfer(adapter, msgs, num, 0);\n\t\tif (ret == -EAGAIN)\n\t\t\tbus->force_bit |= GMBUS_FORCE_BIT_RETRY;\n\t}\n\n\tintel_display_power_put(i915, POWER_DOMAIN_GMBUS, wakeref);\n\n\treturn ret;\n}\n\nint intel_gmbus_output_aksv(struct i2c_adapter *adapter)\n{\n\tstruct intel_gmbus *bus = to_intel_gmbus(adapter);\n\tstruct drm_i915_private *i915 = bus->i915;\n\tu8 cmd = DRM_HDCP_DDC_AKSV;\n\tu8 buf[DRM_HDCP_KSV_LEN] = { 0 };\n\tstruct i2c_msg msgs[] = {\n\t\t{\n\t\t\t.addr = DRM_HDCP_DDC_ADDR,\n\t\t\t.flags = 0,\n\t\t\t.len = sizeof(cmd),\n\t\t\t.buf = &cmd,\n\t\t},\n\t\t{\n\t\t\t.addr = DRM_HDCP_DDC_ADDR,\n\t\t\t.flags = 0,\n\t\t\t.len = sizeof(buf),\n\t\t\t.buf = buf,\n\t\t}\n\t};\n\tintel_wakeref_t wakeref;\n\tint ret;\n\n\twakeref = intel_display_power_get(i915, POWER_DOMAIN_GMBUS);\n\tmutex_lock(&i915->display.gmbus.mutex);\n\n\t \n\tret = do_gmbus_xfer(adapter, msgs, ARRAY_SIZE(msgs), GMBUS_AKSV_SELECT);\n\n\tmutex_unlock(&i915->display.gmbus.mutex);\n\tintel_display_power_put(i915, POWER_DOMAIN_GMBUS, wakeref);\n\n\treturn ret;\n}\n\nstatic u32 gmbus_func(struct i2c_adapter *adapter)\n{\n\treturn i2c_bit_algo.functionality(adapter) &\n\t\t(I2C_FUNC_I2C | I2C_FUNC_SMBUS_EMUL |\n\t\t \n\t\tI2C_FUNC_SMBUS_READ_BLOCK_DATA |\n\t\tI2C_FUNC_SMBUS_BLOCK_PROC_CALL);\n}\n\nstatic const struct i2c_algorithm gmbus_algorithm = {\n\t.master_xfer\t= gmbus_xfer,\n\t.functionality\t= gmbus_func\n};\n\nstatic void gmbus_lock_bus(struct i2c_adapter *adapter,\n\t\t\t   unsigned int flags)\n{\n\tstruct intel_gmbus *bus = to_intel_gmbus(adapter);\n\tstruct drm_i915_private *i915 = bus->i915;\n\n\tmutex_lock(&i915->display.gmbus.mutex);\n}\n\nstatic int gmbus_trylock_bus(struct i2c_adapter *adapter,\n\t\t\t     unsigned int flags)\n{\n\tstruct intel_gmbus *bus = to_intel_gmbus(adapter);\n\tstruct drm_i915_private *i915 = bus->i915;\n\n\treturn mutex_trylock(&i915->display.gmbus.mutex);\n}\n\nstatic void gmbus_unlock_bus(struct i2c_adapter *adapter,\n\t\t\t     unsigned int flags)\n{\n\tstruct intel_gmbus *bus = to_intel_gmbus(adapter);\n\tstruct drm_i915_private *i915 = bus->i915;\n\n\tmutex_unlock(&i915->display.gmbus.mutex);\n}\n\nstatic const struct i2c_lock_operations gmbus_lock_ops = {\n\t.lock_bus =    gmbus_lock_bus,\n\t.trylock_bus = gmbus_trylock_bus,\n\t.unlock_bus =  gmbus_unlock_bus,\n};\n\n \nint intel_gmbus_setup(struct drm_i915_private *i915)\n{\n\tstruct pci_dev *pdev = to_pci_dev(i915->drm.dev);\n\tunsigned int pin;\n\tint ret;\n\n\tif (IS_VALLEYVIEW(i915) || IS_CHERRYVIEW(i915))\n\t\ti915->display.gmbus.mmio_base = VLV_DISPLAY_BASE;\n\telse if (!HAS_GMCH(i915))\n\t\t \n\t\ti915->display.gmbus.mmio_base = PCH_DISPLAY_BASE;\n\n\tmutex_init(&i915->display.gmbus.mutex);\n\tinit_waitqueue_head(&i915->display.gmbus.wait_queue);\n\n\tfor (pin = 0; pin < ARRAY_SIZE(i915->display.gmbus.bus); pin++) {\n\t\tconst struct gmbus_pin *gmbus_pin;\n\t\tstruct intel_gmbus *bus;\n\n\t\tgmbus_pin = get_gmbus_pin(i915, pin);\n\t\tif (!gmbus_pin)\n\t\t\tcontinue;\n\n\t\tbus = kzalloc(sizeof(*bus), GFP_KERNEL);\n\t\tif (!bus) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto err;\n\t\t}\n\n\t\tbus->adapter.owner = THIS_MODULE;\n\t\tbus->adapter.class = I2C_CLASS_DDC;\n\t\tsnprintf(bus->adapter.name,\n\t\t\t sizeof(bus->adapter.name),\n\t\t\t \"i915 gmbus %s\", gmbus_pin->name);\n\n\t\tbus->adapter.dev.parent = &pdev->dev;\n\t\tbus->i915 = i915;\n\n\t\tbus->adapter.algo = &gmbus_algorithm;\n\t\tbus->adapter.lock_ops = &gmbus_lock_ops;\n\n\t\t \n\t\tbus->adapter.retries = 1;\n\n\t\t \n\t\tbus->reg0 = pin | GMBUS_RATE_100KHZ;\n\n\t\t \n\t\tif (IS_I830(i915))\n\t\t\tbus->force_bit = 1;\n\n\t\tintel_gpio_setup(bus, GPIO(i915, gmbus_pin->gpio));\n\n\t\tret = i2c_add_adapter(&bus->adapter);\n\t\tif (ret) {\n\t\t\tkfree(bus);\n\t\t\tgoto err;\n\t\t}\n\n\t\ti915->display.gmbus.bus[pin] = bus;\n\t}\n\n\tintel_gmbus_reset(i915);\n\n\treturn 0;\n\nerr:\n\tintel_gmbus_teardown(i915);\n\n\treturn ret;\n}\n\nstruct i2c_adapter *intel_gmbus_get_adapter(struct drm_i915_private *i915,\n\t\t\t\t\t    unsigned int pin)\n{\n\tif (drm_WARN_ON(&i915->drm, pin >= ARRAY_SIZE(i915->display.gmbus.bus) ||\n\t\t\t!i915->display.gmbus.bus[pin]))\n\t\treturn NULL;\n\n\treturn &i915->display.gmbus.bus[pin]->adapter;\n}\n\nvoid intel_gmbus_force_bit(struct i2c_adapter *adapter, bool force_bit)\n{\n\tstruct intel_gmbus *bus = to_intel_gmbus(adapter);\n\tstruct drm_i915_private *i915 = bus->i915;\n\n\tmutex_lock(&i915->display.gmbus.mutex);\n\n\tbus->force_bit += force_bit ? 1 : -1;\n\tdrm_dbg_kms(&i915->drm,\n\t\t    \"%sabling bit-banging on %s. force bit now %d\\n\",\n\t\t    force_bit ? \"en\" : \"dis\", adapter->name,\n\t\t    bus->force_bit);\n\n\tmutex_unlock(&i915->display.gmbus.mutex);\n}\n\nbool intel_gmbus_is_forced_bit(struct i2c_adapter *adapter)\n{\n\tstruct intel_gmbus *bus = to_intel_gmbus(adapter);\n\n\treturn bus->force_bit;\n}\n\nvoid intel_gmbus_teardown(struct drm_i915_private *i915)\n{\n\tunsigned int pin;\n\n\tfor (pin = 0; pin < ARRAY_SIZE(i915->display.gmbus.bus); pin++) {\n\t\tstruct intel_gmbus *bus;\n\n\t\tbus = i915->display.gmbus.bus[pin];\n\t\tif (!bus)\n\t\t\tcontinue;\n\n\t\ti2c_del_adapter(&bus->adapter);\n\n\t\tkfree(bus);\n\t\ti915->display.gmbus.bus[pin] = NULL;\n\t}\n}\n\nvoid intel_gmbus_irq_handler(struct drm_i915_private *i915)\n{\n\twake_up_all(&i915->display.gmbus.wait_queue);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}