{
  "module_name": "intel_pch_refclk.c",
  "hash_id": "909fe516eb4dc04b56a154526542add451c71c5968ebc76051dbf2a413c6435d",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/i915/display/intel_pch_refclk.c",
  "human_readable_source": "\n \n\n#include \"i915_reg.h\"\n#include \"intel_de.h\"\n#include \"intel_display_types.h\"\n#include \"intel_panel.h\"\n#include \"intel_pch_refclk.h\"\n#include \"intel_sbi.h\"\n\nstatic void lpt_fdi_reset_mphy(struct drm_i915_private *dev_priv)\n{\n\tintel_de_rmw(dev_priv, SOUTH_CHICKEN2, 0, FDI_MPHY_IOSFSB_RESET_CTL);\n\n\tif (wait_for_us(intel_de_read(dev_priv, SOUTH_CHICKEN2) &\n\t\t\tFDI_MPHY_IOSFSB_RESET_STATUS, 100))\n\t\tdrm_err(&dev_priv->drm, \"FDI mPHY reset assert timeout\\n\");\n\n\tintel_de_rmw(dev_priv, SOUTH_CHICKEN2, FDI_MPHY_IOSFSB_RESET_CTL, 0);\n\n\tif (wait_for_us((intel_de_read(dev_priv, SOUTH_CHICKEN2) &\n\t\t\t FDI_MPHY_IOSFSB_RESET_STATUS) == 0, 100))\n\t\tdrm_err(&dev_priv->drm, \"FDI mPHY reset de-assert timeout\\n\");\n}\n\n \nstatic void lpt_fdi_program_mphy(struct drm_i915_private *dev_priv)\n{\n\tu32 tmp;\n\n\tlpt_fdi_reset_mphy(dev_priv);\n\n\ttmp = intel_sbi_read(dev_priv, 0x8008, SBI_MPHY);\n\ttmp &= ~(0xFF << 24);\n\ttmp |= (0x12 << 24);\n\tintel_sbi_write(dev_priv, 0x8008, tmp, SBI_MPHY);\n\n\ttmp = intel_sbi_read(dev_priv, 0x2008, SBI_MPHY);\n\ttmp |= (1 << 11);\n\tintel_sbi_write(dev_priv, 0x2008, tmp, SBI_MPHY);\n\n\ttmp = intel_sbi_read(dev_priv, 0x2108, SBI_MPHY);\n\ttmp |= (1 << 11);\n\tintel_sbi_write(dev_priv, 0x2108, tmp, SBI_MPHY);\n\n\ttmp = intel_sbi_read(dev_priv, 0x206C, SBI_MPHY);\n\ttmp |= (1 << 24) | (1 << 21) | (1 << 18);\n\tintel_sbi_write(dev_priv, 0x206C, tmp, SBI_MPHY);\n\n\ttmp = intel_sbi_read(dev_priv, 0x216C, SBI_MPHY);\n\ttmp |= (1 << 24) | (1 << 21) | (1 << 18);\n\tintel_sbi_write(dev_priv, 0x216C, tmp, SBI_MPHY);\n\n\ttmp = intel_sbi_read(dev_priv, 0x2080, SBI_MPHY);\n\ttmp &= ~(7 << 13);\n\ttmp |= (5 << 13);\n\tintel_sbi_write(dev_priv, 0x2080, tmp, SBI_MPHY);\n\n\ttmp = intel_sbi_read(dev_priv, 0x2180, SBI_MPHY);\n\ttmp &= ~(7 << 13);\n\ttmp |= (5 << 13);\n\tintel_sbi_write(dev_priv, 0x2180, tmp, SBI_MPHY);\n\n\ttmp = intel_sbi_read(dev_priv, 0x208C, SBI_MPHY);\n\ttmp &= ~0xFF;\n\ttmp |= 0x1C;\n\tintel_sbi_write(dev_priv, 0x208C, tmp, SBI_MPHY);\n\n\ttmp = intel_sbi_read(dev_priv, 0x218C, SBI_MPHY);\n\ttmp &= ~0xFF;\n\ttmp |= 0x1C;\n\tintel_sbi_write(dev_priv, 0x218C, tmp, SBI_MPHY);\n\n\ttmp = intel_sbi_read(dev_priv, 0x2098, SBI_MPHY);\n\ttmp &= ~(0xFF << 16);\n\ttmp |= (0x1C << 16);\n\tintel_sbi_write(dev_priv, 0x2098, tmp, SBI_MPHY);\n\n\ttmp = intel_sbi_read(dev_priv, 0x2198, SBI_MPHY);\n\ttmp &= ~(0xFF << 16);\n\ttmp |= (0x1C << 16);\n\tintel_sbi_write(dev_priv, 0x2198, tmp, SBI_MPHY);\n\n\ttmp = intel_sbi_read(dev_priv, 0x20C4, SBI_MPHY);\n\ttmp |= (1 << 27);\n\tintel_sbi_write(dev_priv, 0x20C4, tmp, SBI_MPHY);\n\n\ttmp = intel_sbi_read(dev_priv, 0x21C4, SBI_MPHY);\n\ttmp |= (1 << 27);\n\tintel_sbi_write(dev_priv, 0x21C4, tmp, SBI_MPHY);\n\n\ttmp = intel_sbi_read(dev_priv, 0x20EC, SBI_MPHY);\n\ttmp &= ~(0xF << 28);\n\ttmp |= (4 << 28);\n\tintel_sbi_write(dev_priv, 0x20EC, tmp, SBI_MPHY);\n\n\ttmp = intel_sbi_read(dev_priv, 0x21EC, SBI_MPHY);\n\ttmp &= ~(0xF << 28);\n\ttmp |= (4 << 28);\n\tintel_sbi_write(dev_priv, 0x21EC, tmp, SBI_MPHY);\n}\n\nvoid lpt_disable_iclkip(struct drm_i915_private *dev_priv)\n{\n\tu32 temp;\n\n\tintel_de_write(dev_priv, PIXCLK_GATE, PIXCLK_GATE_GATE);\n\n\tmutex_lock(&dev_priv->sb_lock);\n\n\ttemp = intel_sbi_read(dev_priv, SBI_SSCCTL6, SBI_ICLK);\n\ttemp |= SBI_SSCCTL_DISABLE;\n\tintel_sbi_write(dev_priv, SBI_SSCCTL6, temp, SBI_ICLK);\n\n\tmutex_unlock(&dev_priv->sb_lock);\n}\n\nstruct iclkip_params {\n\tu32 iclk_virtual_root_freq;\n\tu32 iclk_pi_range;\n\tu32 divsel, phaseinc, auxdiv, phasedir, desired_divisor;\n};\n\nstatic void iclkip_params_init(struct iclkip_params *p)\n{\n\tmemset(p, 0, sizeof(*p));\n\n\tp->iclk_virtual_root_freq = 172800 * 1000;\n\tp->iclk_pi_range = 64;\n}\n\nstatic int lpt_iclkip_freq(struct iclkip_params *p)\n{\n\treturn DIV_ROUND_CLOSEST(p->iclk_virtual_root_freq,\n\t\t\t\t p->desired_divisor << p->auxdiv);\n}\n\nstatic void lpt_compute_iclkip(struct iclkip_params *p, int clock)\n{\n\ticlkip_params_init(p);\n\n\t \n\tfor (p->auxdiv = 0; p->auxdiv < 2; p->auxdiv++) {\n\t\tp->desired_divisor = DIV_ROUND_CLOSEST(p->iclk_virtual_root_freq,\n\t\t\t\t\t\t       clock << p->auxdiv);\n\t\tp->divsel = (p->desired_divisor / p->iclk_pi_range) - 2;\n\t\tp->phaseinc = p->desired_divisor % p->iclk_pi_range;\n\n\t\t \n\t\tif (p->divsel <= 0x7f)\n\t\t\tbreak;\n\t}\n}\n\nint lpt_iclkip(const struct intel_crtc_state *crtc_state)\n{\n\tstruct iclkip_params p;\n\n\tlpt_compute_iclkip(&p, crtc_state->hw.adjusted_mode.crtc_clock);\n\n\treturn lpt_iclkip_freq(&p);\n}\n\n \nvoid lpt_program_iclkip(const struct intel_crtc_state *crtc_state)\n{\n\tstruct intel_crtc *crtc = to_intel_crtc(crtc_state->uapi.crtc);\n\tstruct drm_i915_private *dev_priv = to_i915(crtc->base.dev);\n\tint clock = crtc_state->hw.adjusted_mode.crtc_clock;\n\tstruct iclkip_params p;\n\tu32 temp;\n\n\tlpt_disable_iclkip(dev_priv);\n\n\tlpt_compute_iclkip(&p, clock);\n\tdrm_WARN_ON(&dev_priv->drm, lpt_iclkip_freq(&p) != clock);\n\n\t \n\tdrm_WARN_ON(&dev_priv->drm, SBI_SSCDIVINTPHASE_DIVSEL(p.divsel) &\n\t\t    ~SBI_SSCDIVINTPHASE_DIVSEL_MASK);\n\tdrm_WARN_ON(&dev_priv->drm, SBI_SSCDIVINTPHASE_DIR(p.phasedir) &\n\t\t    ~SBI_SSCDIVINTPHASE_INCVAL_MASK);\n\n\tdrm_dbg_kms(&dev_priv->drm,\n\t\t    \"iCLKIP clock: found settings for %dKHz refresh rate: auxdiv=%x, divsel=%x, phasedir=%x, phaseinc=%x\\n\",\n\t\t    clock, p.auxdiv, p.divsel, p.phasedir, p.phaseinc);\n\n\tmutex_lock(&dev_priv->sb_lock);\n\n\t \n\ttemp = intel_sbi_read(dev_priv, SBI_SSCDIVINTPHASE6, SBI_ICLK);\n\ttemp &= ~SBI_SSCDIVINTPHASE_DIVSEL_MASK;\n\ttemp |= SBI_SSCDIVINTPHASE_DIVSEL(p.divsel);\n\ttemp &= ~SBI_SSCDIVINTPHASE_INCVAL_MASK;\n\ttemp |= SBI_SSCDIVINTPHASE_INCVAL(p.phaseinc);\n\ttemp |= SBI_SSCDIVINTPHASE_DIR(p.phasedir);\n\ttemp |= SBI_SSCDIVINTPHASE_PROPAGATE;\n\tintel_sbi_write(dev_priv, SBI_SSCDIVINTPHASE6, temp, SBI_ICLK);\n\n\t \n\ttemp = intel_sbi_read(dev_priv, SBI_SSCAUXDIV6, SBI_ICLK);\n\ttemp &= ~SBI_SSCAUXDIV_FINALDIV2SEL(1);\n\ttemp |= SBI_SSCAUXDIV_FINALDIV2SEL(p.auxdiv);\n\tintel_sbi_write(dev_priv, SBI_SSCAUXDIV6, temp, SBI_ICLK);\n\n\t \n\ttemp = intel_sbi_read(dev_priv, SBI_SSCCTL6, SBI_ICLK);\n\ttemp &= ~SBI_SSCCTL_DISABLE;\n\tintel_sbi_write(dev_priv, SBI_SSCCTL6, temp, SBI_ICLK);\n\n\tmutex_unlock(&dev_priv->sb_lock);\n\n\t \n\tudelay(24);\n\n\tintel_de_write(dev_priv, PIXCLK_GATE, PIXCLK_GATE_UNGATE);\n}\n\nint lpt_get_iclkip(struct drm_i915_private *dev_priv)\n{\n\tstruct iclkip_params p;\n\tu32 temp;\n\n\tif ((intel_de_read(dev_priv, PIXCLK_GATE) & PIXCLK_GATE_UNGATE) == 0)\n\t\treturn 0;\n\n\ticlkip_params_init(&p);\n\n\tmutex_lock(&dev_priv->sb_lock);\n\n\ttemp = intel_sbi_read(dev_priv, SBI_SSCCTL6, SBI_ICLK);\n\tif (temp & SBI_SSCCTL_DISABLE) {\n\t\tmutex_unlock(&dev_priv->sb_lock);\n\t\treturn 0;\n\t}\n\n\ttemp = intel_sbi_read(dev_priv, SBI_SSCDIVINTPHASE6, SBI_ICLK);\n\tp.divsel = (temp & SBI_SSCDIVINTPHASE_DIVSEL_MASK) >>\n\t\tSBI_SSCDIVINTPHASE_DIVSEL_SHIFT;\n\tp.phaseinc = (temp & SBI_SSCDIVINTPHASE_INCVAL_MASK) >>\n\t\tSBI_SSCDIVINTPHASE_INCVAL_SHIFT;\n\n\ttemp = intel_sbi_read(dev_priv, SBI_SSCAUXDIV6, SBI_ICLK);\n\tp.auxdiv = (temp & SBI_SSCAUXDIV_FINALDIV2SEL_MASK) >>\n\t\tSBI_SSCAUXDIV_FINALDIV2SEL_SHIFT;\n\n\tmutex_unlock(&dev_priv->sb_lock);\n\n\tp.desired_divisor = (p.divsel + 2) * p.iclk_pi_range + p.phaseinc;\n\n\treturn lpt_iclkip_freq(&p);\n}\n\n \nstatic void lpt_enable_clkout_dp(struct drm_i915_private *dev_priv,\n\t\t\t\t bool with_spread, bool with_fdi)\n{\n\tu32 reg, tmp;\n\n\tif (drm_WARN(&dev_priv->drm, with_fdi && !with_spread,\n\t\t     \"FDI requires downspread\\n\"))\n\t\twith_spread = true;\n\tif (drm_WARN(&dev_priv->drm, HAS_PCH_LPT_LP(dev_priv) &&\n\t\t     with_fdi, \"LP PCH doesn't have FDI\\n\"))\n\t\twith_fdi = false;\n\n\tmutex_lock(&dev_priv->sb_lock);\n\n\ttmp = intel_sbi_read(dev_priv, SBI_SSCCTL, SBI_ICLK);\n\ttmp &= ~SBI_SSCCTL_DISABLE;\n\ttmp |= SBI_SSCCTL_PATHALT;\n\tintel_sbi_write(dev_priv, SBI_SSCCTL, tmp, SBI_ICLK);\n\n\tudelay(24);\n\n\tif (with_spread) {\n\t\ttmp = intel_sbi_read(dev_priv, SBI_SSCCTL, SBI_ICLK);\n\t\ttmp &= ~SBI_SSCCTL_PATHALT;\n\t\tintel_sbi_write(dev_priv, SBI_SSCCTL, tmp, SBI_ICLK);\n\n\t\tif (with_fdi)\n\t\t\tlpt_fdi_program_mphy(dev_priv);\n\t}\n\n\treg = HAS_PCH_LPT_LP(dev_priv) ? SBI_GEN0 : SBI_DBUFF0;\n\ttmp = intel_sbi_read(dev_priv, reg, SBI_ICLK);\n\ttmp |= SBI_GEN0_CFG_BUFFENABLE_DISABLE;\n\tintel_sbi_write(dev_priv, reg, tmp, SBI_ICLK);\n\n\tmutex_unlock(&dev_priv->sb_lock);\n}\n\n \nvoid lpt_disable_clkout_dp(struct drm_i915_private *dev_priv)\n{\n\tu32 reg, tmp;\n\n\tmutex_lock(&dev_priv->sb_lock);\n\n\treg = HAS_PCH_LPT_LP(dev_priv) ? SBI_GEN0 : SBI_DBUFF0;\n\ttmp = intel_sbi_read(dev_priv, reg, SBI_ICLK);\n\ttmp &= ~SBI_GEN0_CFG_BUFFENABLE_DISABLE;\n\tintel_sbi_write(dev_priv, reg, tmp, SBI_ICLK);\n\n\ttmp = intel_sbi_read(dev_priv, SBI_SSCCTL, SBI_ICLK);\n\tif (!(tmp & SBI_SSCCTL_DISABLE)) {\n\t\tif (!(tmp & SBI_SSCCTL_PATHALT)) {\n\t\t\ttmp |= SBI_SSCCTL_PATHALT;\n\t\t\tintel_sbi_write(dev_priv, SBI_SSCCTL, tmp, SBI_ICLK);\n\t\t\tudelay(32);\n\t\t}\n\t\ttmp |= SBI_SSCCTL_DISABLE;\n\t\tintel_sbi_write(dev_priv, SBI_SSCCTL, tmp, SBI_ICLK);\n\t}\n\n\tmutex_unlock(&dev_priv->sb_lock);\n}\n\n#define BEND_IDX(steps) ((50 + (steps)) / 5)\n\nstatic const u16 sscdivintphase[] = {\n\t[BEND_IDX( 50)] = 0x3B23,\n\t[BEND_IDX( 45)] = 0x3B23,\n\t[BEND_IDX( 40)] = 0x3C23,\n\t[BEND_IDX( 35)] = 0x3C23,\n\t[BEND_IDX( 30)] = 0x3D23,\n\t[BEND_IDX( 25)] = 0x3D23,\n\t[BEND_IDX( 20)] = 0x3E23,\n\t[BEND_IDX( 15)] = 0x3E23,\n\t[BEND_IDX( 10)] = 0x3F23,\n\t[BEND_IDX(  5)] = 0x3F23,\n\t[BEND_IDX(  0)] = 0x0025,\n\t[BEND_IDX( -5)] = 0x0025,\n\t[BEND_IDX(-10)] = 0x0125,\n\t[BEND_IDX(-15)] = 0x0125,\n\t[BEND_IDX(-20)] = 0x0225,\n\t[BEND_IDX(-25)] = 0x0225,\n\t[BEND_IDX(-30)] = 0x0325,\n\t[BEND_IDX(-35)] = 0x0325,\n\t[BEND_IDX(-40)] = 0x0425,\n\t[BEND_IDX(-45)] = 0x0425,\n\t[BEND_IDX(-50)] = 0x0525,\n};\n\n \nstatic void lpt_bend_clkout_dp(struct drm_i915_private *dev_priv, int steps)\n{\n\tu32 tmp;\n\tint idx = BEND_IDX(steps);\n\n\tif (drm_WARN_ON(&dev_priv->drm, steps % 5 != 0))\n\t\treturn;\n\n\tif (drm_WARN_ON(&dev_priv->drm, idx >= ARRAY_SIZE(sscdivintphase)))\n\t\treturn;\n\n\tmutex_lock(&dev_priv->sb_lock);\n\n\tif (steps % 10 != 0)\n\t\ttmp = 0xAAAAAAAB;\n\telse\n\t\ttmp = 0x00000000;\n\tintel_sbi_write(dev_priv, SBI_SSCDITHPHASE, tmp, SBI_ICLK);\n\n\ttmp = intel_sbi_read(dev_priv, SBI_SSCDIVINTPHASE, SBI_ICLK);\n\ttmp &= 0xffff0000;\n\ttmp |= sscdivintphase[idx];\n\tintel_sbi_write(dev_priv, SBI_SSCDIVINTPHASE, tmp, SBI_ICLK);\n\n\tmutex_unlock(&dev_priv->sb_lock);\n}\n\n#undef BEND_IDX\n\nstatic bool spll_uses_pch_ssc(struct drm_i915_private *dev_priv)\n{\n\tu32 fuse_strap = intel_de_read(dev_priv, FUSE_STRAP);\n\tu32 ctl = intel_de_read(dev_priv, SPLL_CTL);\n\n\tif ((ctl & SPLL_PLL_ENABLE) == 0)\n\t\treturn false;\n\n\tif ((ctl & SPLL_REF_MASK) == SPLL_REF_MUXED_SSC &&\n\t    (fuse_strap & HSW_CPU_SSC_ENABLE) == 0)\n\t\treturn true;\n\n\tif (IS_BROADWELL(dev_priv) &&\n\t    (ctl & SPLL_REF_MASK) == SPLL_REF_PCH_SSC_BDW)\n\t\treturn true;\n\n\treturn false;\n}\n\nstatic bool wrpll_uses_pch_ssc(struct drm_i915_private *dev_priv,\n\t\t\t       enum intel_dpll_id id)\n{\n\tu32 fuse_strap = intel_de_read(dev_priv, FUSE_STRAP);\n\tu32 ctl = intel_de_read(dev_priv, WRPLL_CTL(id));\n\n\tif ((ctl & WRPLL_PLL_ENABLE) == 0)\n\t\treturn false;\n\n\tif ((ctl & WRPLL_REF_MASK) == WRPLL_REF_PCH_SSC)\n\t\treturn true;\n\n\tif ((IS_BROADWELL(dev_priv) || IS_HASWELL_ULT(dev_priv)) &&\n\t    (ctl & WRPLL_REF_MASK) == WRPLL_REF_MUXED_SSC_BDW &&\n\t    (fuse_strap & HSW_CPU_SSC_ENABLE) == 0)\n\t\treturn true;\n\n\treturn false;\n}\n\nstatic void lpt_init_pch_refclk(struct drm_i915_private *dev_priv)\n{\n\tstruct intel_encoder *encoder;\n\tbool has_fdi = false;\n\n\tfor_each_intel_encoder(&dev_priv->drm, encoder) {\n\t\tswitch (encoder->type) {\n\t\tcase INTEL_OUTPUT_ANALOG:\n\t\t\thas_fdi = true;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t \n\tdev_priv->display.dpll.pch_ssc_use = 0;\n\n\tif (spll_uses_pch_ssc(dev_priv)) {\n\t\tdrm_dbg_kms(&dev_priv->drm, \"SPLL using PCH SSC\\n\");\n\t\tdev_priv->display.dpll.pch_ssc_use |= BIT(DPLL_ID_SPLL);\n\t}\n\n\tif (wrpll_uses_pch_ssc(dev_priv, DPLL_ID_WRPLL1)) {\n\t\tdrm_dbg_kms(&dev_priv->drm, \"WRPLL1 using PCH SSC\\n\");\n\t\tdev_priv->display.dpll.pch_ssc_use |= BIT(DPLL_ID_WRPLL1);\n\t}\n\n\tif (wrpll_uses_pch_ssc(dev_priv, DPLL_ID_WRPLL2)) {\n\t\tdrm_dbg_kms(&dev_priv->drm, \"WRPLL2 using PCH SSC\\n\");\n\t\tdev_priv->display.dpll.pch_ssc_use |= BIT(DPLL_ID_WRPLL2);\n\t}\n\n\tif (dev_priv->display.dpll.pch_ssc_use)\n\t\treturn;\n\n\tif (has_fdi) {\n\t\tlpt_bend_clkout_dp(dev_priv, 0);\n\t\tlpt_enable_clkout_dp(dev_priv, true, true);\n\t} else {\n\t\tlpt_disable_clkout_dp(dev_priv);\n\t}\n}\n\nstatic void ilk_init_pch_refclk(struct drm_i915_private *dev_priv)\n{\n\tstruct intel_encoder *encoder;\n\tint i;\n\tu32 val, final;\n\tbool has_lvds = false;\n\tbool has_cpu_edp = false;\n\tbool has_panel = false;\n\tbool has_ck505 = false;\n\tbool can_ssc = false;\n\tbool using_ssc_source = false;\n\n\t \n\tfor_each_intel_encoder(&dev_priv->drm, encoder) {\n\t\tswitch (encoder->type) {\n\t\tcase INTEL_OUTPUT_LVDS:\n\t\t\thas_panel = true;\n\t\t\thas_lvds = true;\n\t\t\tbreak;\n\t\tcase INTEL_OUTPUT_EDP:\n\t\t\thas_panel = true;\n\t\t\tif (encoder->port == PORT_A)\n\t\t\t\thas_cpu_edp = true;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (HAS_PCH_IBX(dev_priv)) {\n\t\thas_ck505 = dev_priv->display.vbt.display_clock_mode;\n\t\tcan_ssc = has_ck505;\n\t} else {\n\t\thas_ck505 = false;\n\t\tcan_ssc = true;\n\t}\n\n\t \n\tfor (i = 0; i < dev_priv->display.dpll.num_shared_dpll; i++) {\n\t\tu32 temp = intel_de_read(dev_priv, PCH_DPLL(i));\n\n\t\tif (!(temp & DPLL_VCO_ENABLE))\n\t\t\tcontinue;\n\n\t\tif ((temp & PLL_REF_INPUT_MASK) ==\n\t\t    PLLB_REF_INPUT_SPREADSPECTRUMIN) {\n\t\t\tusing_ssc_source = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tdrm_dbg_kms(&dev_priv->drm,\n\t\t    \"has_panel %d has_lvds %d has_ck505 %d using_ssc_source %d\\n\",\n\t\t    has_panel, has_lvds, has_ck505, using_ssc_source);\n\n\t \n\tval = intel_de_read(dev_priv, PCH_DREF_CONTROL);\n\n\t \n\tfinal = val;\n\tfinal &= ~DREF_NONSPREAD_SOURCE_MASK;\n\tif (has_ck505)\n\t\tfinal |= DREF_NONSPREAD_CK505_ENABLE;\n\telse\n\t\tfinal |= DREF_NONSPREAD_SOURCE_ENABLE;\n\n\tfinal &= ~DREF_SSC_SOURCE_MASK;\n\tfinal &= ~DREF_CPU_SOURCE_OUTPUT_MASK;\n\tfinal &= ~DREF_SSC1_ENABLE;\n\n\tif (has_panel) {\n\t\tfinal |= DREF_SSC_SOURCE_ENABLE;\n\n\t\tif (intel_panel_use_ssc(dev_priv) && can_ssc)\n\t\t\tfinal |= DREF_SSC1_ENABLE;\n\n\t\tif (has_cpu_edp) {\n\t\t\tif (intel_panel_use_ssc(dev_priv) && can_ssc)\n\t\t\t\tfinal |= DREF_CPU_SOURCE_OUTPUT_DOWNSPREAD;\n\t\t\telse\n\t\t\t\tfinal |= DREF_CPU_SOURCE_OUTPUT_NONSPREAD;\n\t\t} else {\n\t\t\tfinal |= DREF_CPU_SOURCE_OUTPUT_DISABLE;\n\t\t}\n\t} else if (using_ssc_source) {\n\t\tfinal |= DREF_SSC_SOURCE_ENABLE;\n\t\tfinal |= DREF_SSC1_ENABLE;\n\t}\n\n\tif (final == val)\n\t\treturn;\n\n\t \n\tval &= ~DREF_NONSPREAD_SOURCE_MASK;\n\n\tif (has_ck505)\n\t\tval |= DREF_NONSPREAD_CK505_ENABLE;\n\telse\n\t\tval |= DREF_NONSPREAD_SOURCE_ENABLE;\n\n\tif (has_panel) {\n\t\tval &= ~DREF_SSC_SOURCE_MASK;\n\t\tval |= DREF_SSC_SOURCE_ENABLE;\n\n\t\t \n\t\tif (intel_panel_use_ssc(dev_priv) && can_ssc) {\n\t\t\tdrm_dbg_kms(&dev_priv->drm, \"Using SSC on panel\\n\");\n\t\t\tval |= DREF_SSC1_ENABLE;\n\t\t} else {\n\t\t\tval &= ~DREF_SSC1_ENABLE;\n\t\t}\n\n\t\t \n\t\tintel_de_write(dev_priv, PCH_DREF_CONTROL, val);\n\t\tintel_de_posting_read(dev_priv, PCH_DREF_CONTROL);\n\t\tudelay(200);\n\n\t\tval &= ~DREF_CPU_SOURCE_OUTPUT_MASK;\n\n\t\t \n\t\tif (has_cpu_edp) {\n\t\t\tif (intel_panel_use_ssc(dev_priv) && can_ssc) {\n\t\t\t\tdrm_dbg_kms(&dev_priv->drm,\n\t\t\t\t\t    \"Using SSC on eDP\\n\");\n\t\t\t\tval |= DREF_CPU_SOURCE_OUTPUT_DOWNSPREAD;\n\t\t\t} else {\n\t\t\t\tval |= DREF_CPU_SOURCE_OUTPUT_NONSPREAD;\n\t\t\t}\n\t\t} else {\n\t\t\tval |= DREF_CPU_SOURCE_OUTPUT_DISABLE;\n\t\t}\n\n\t\tintel_de_write(dev_priv, PCH_DREF_CONTROL, val);\n\t\tintel_de_posting_read(dev_priv, PCH_DREF_CONTROL);\n\t\tudelay(200);\n\t} else {\n\t\tdrm_dbg_kms(&dev_priv->drm, \"Disabling CPU source output\\n\");\n\n\t\tval &= ~DREF_CPU_SOURCE_OUTPUT_MASK;\n\n\t\t \n\t\tval |= DREF_CPU_SOURCE_OUTPUT_DISABLE;\n\n\t\tintel_de_write(dev_priv, PCH_DREF_CONTROL, val);\n\t\tintel_de_posting_read(dev_priv, PCH_DREF_CONTROL);\n\t\tudelay(200);\n\n\t\tif (!using_ssc_source) {\n\t\t\tdrm_dbg_kms(&dev_priv->drm, \"Disabling SSC source\\n\");\n\n\t\t\t \n\t\t\tval &= ~DREF_SSC_SOURCE_MASK;\n\t\t\tval |= DREF_SSC_SOURCE_DISABLE;\n\n\t\t\t \n\t\t\tval &= ~DREF_SSC1_ENABLE;\n\n\t\t\tintel_de_write(dev_priv, PCH_DREF_CONTROL, val);\n\t\t\tintel_de_posting_read(dev_priv, PCH_DREF_CONTROL);\n\t\t\tudelay(200);\n\t\t}\n\t}\n\n\tdrm_WARN_ON(&dev_priv->drm, val != final);\n}\n\n \nvoid intel_init_pch_refclk(struct drm_i915_private *dev_priv)\n{\n\tif (HAS_PCH_IBX(dev_priv) || HAS_PCH_CPT(dev_priv))\n\t\tilk_init_pch_refclk(dev_priv);\n\telse if (HAS_PCH_LPT(dev_priv))\n\t\tlpt_init_pch_refclk(dev_priv);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}