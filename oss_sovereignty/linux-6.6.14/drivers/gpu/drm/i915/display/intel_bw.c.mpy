{
  "module_name": "intel_bw.c",
  "hash_id": "b852e20530fe6bfc8f8957d3622fd24c4ba0dd144302cc3f38e09b6d208f2d87",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/i915/display/intel_bw.c",
  "human_readable_source": "\n \n\n#include <drm/drm_atomic_state_helper.h>\n\n#include \"i915_drv.h\"\n#include \"i915_reg.h\"\n#include \"i915_utils.h\"\n#include \"intel_atomic.h\"\n#include \"intel_bw.h\"\n#include \"intel_cdclk.h\"\n#include \"intel_display_core.h\"\n#include \"intel_display_types.h\"\n#include \"skl_watermark.h\"\n#include \"intel_mchbar_regs.h\"\n#include \"intel_pcode.h\"\n\n \nstruct intel_qgv_point {\n\tu16 dclk, t_rp, t_rdpre, t_rc, t_ras, t_rcd;\n};\n\nstruct intel_psf_gv_point {\n\tu8 clk;  \n};\n\nstruct intel_qgv_info {\n\tstruct intel_qgv_point points[I915_NUM_QGV_POINTS];\n\tstruct intel_psf_gv_point psf_points[I915_NUM_PSF_GV_POINTS];\n\tu8 num_points;\n\tu8 num_psf_points;\n\tu8 t_bl;\n\tu8 max_numchannels;\n\tu8 channel_width;\n\tu8 deinterleave;\n};\n\nstatic int dg1_mchbar_read_qgv_point_info(struct drm_i915_private *dev_priv,\n\t\t\t\t\t  struct intel_qgv_point *sp,\n\t\t\t\t\t  int point)\n{\n\tu32 dclk_ratio, dclk_reference;\n\tu32 val;\n\n\tval = intel_uncore_read(&dev_priv->uncore, SA_PERF_STATUS_0_0_0_MCHBAR_PC);\n\tdclk_ratio = REG_FIELD_GET(DG1_QCLK_RATIO_MASK, val);\n\tif (val & DG1_QCLK_REFERENCE)\n\t\tdclk_reference = 6;  \n\telse\n\t\tdclk_reference = 8;  \n\tsp->dclk = DIV_ROUND_UP((16667 * dclk_ratio * dclk_reference) + 500, 1000);\n\n\tval = intel_uncore_read(&dev_priv->uncore, SKL_MC_BIOS_DATA_0_0_0_MCHBAR_PCU);\n\tif (val & DG1_GEAR_TYPE)\n\t\tsp->dclk *= 2;\n\n\tif (sp->dclk == 0)\n\t\treturn -EINVAL;\n\n\tval = intel_uncore_read(&dev_priv->uncore, MCHBAR_CH0_CR_TC_PRE_0_0_0_MCHBAR);\n\tsp->t_rp = REG_FIELD_GET(DG1_DRAM_T_RP_MASK, val);\n\tsp->t_rdpre = REG_FIELD_GET(DG1_DRAM_T_RDPRE_MASK, val);\n\n\tval = intel_uncore_read(&dev_priv->uncore, MCHBAR_CH0_CR_TC_PRE_0_0_0_MCHBAR_HIGH);\n\tsp->t_rcd = REG_FIELD_GET(DG1_DRAM_T_RCD_MASK, val);\n\tsp->t_ras = REG_FIELD_GET(DG1_DRAM_T_RAS_MASK, val);\n\n\tsp->t_rc = sp->t_rp + sp->t_ras;\n\n\treturn 0;\n}\n\nstatic int icl_pcode_read_qgv_point_info(struct drm_i915_private *dev_priv,\n\t\t\t\t\t struct intel_qgv_point *sp,\n\t\t\t\t\t int point)\n{\n\tu32 val = 0, val2 = 0;\n\tu16 dclk;\n\tint ret;\n\n\tret = snb_pcode_read(&dev_priv->uncore, ICL_PCODE_MEM_SUBSYSYSTEM_INFO |\n\t\t\t     ICL_PCODE_MEM_SS_READ_QGV_POINT_INFO(point),\n\t\t\t     &val, &val2);\n\tif (ret)\n\t\treturn ret;\n\n\tdclk = val & 0xffff;\n\tsp->dclk = DIV_ROUND_UP((16667 * dclk) + (DISPLAY_VER(dev_priv) > 11 ? 500 : 0), 1000);\n\tsp->t_rp = (val & 0xff0000) >> 16;\n\tsp->t_rcd = (val & 0xff000000) >> 24;\n\n\tsp->t_rdpre = val2 & 0xff;\n\tsp->t_ras = (val2 & 0xff00) >> 8;\n\n\tsp->t_rc = sp->t_rp + sp->t_ras;\n\n\treturn 0;\n}\n\nstatic int adls_pcode_read_psf_gv_point_info(struct drm_i915_private *dev_priv,\n\t\t\t\t\t    struct intel_psf_gv_point *points)\n{\n\tu32 val = 0;\n\tint ret;\n\tint i;\n\n\tret = snb_pcode_read(&dev_priv->uncore, ICL_PCODE_MEM_SUBSYSYSTEM_INFO |\n\t\t\t     ADL_PCODE_MEM_SS_READ_PSF_GV_INFO, &val, NULL);\n\tif (ret)\n\t\treturn ret;\n\n\tfor (i = 0; i < I915_NUM_PSF_GV_POINTS; i++) {\n\t\tpoints[i].clk = val & 0xff;\n\t\tval >>= 8;\n\t}\n\n\treturn 0;\n}\n\nstatic u16 icl_qgv_points_mask(struct drm_i915_private *i915)\n{\n\tunsigned int num_psf_gv_points = i915->display.bw.max[0].num_psf_gv_points;\n\tunsigned int num_qgv_points = i915->display.bw.max[0].num_qgv_points;\n\tu16 qgv_points = 0, psf_points = 0;\n\n\t \n\tif (num_qgv_points > 0)\n\t\tqgv_points = GENMASK(num_qgv_points - 1, 0);\n\n\tif (num_psf_gv_points > 0)\n\t\tpsf_points = GENMASK(num_psf_gv_points - 1, 0);\n\n\treturn ICL_PCODE_REQ_QGV_PT(qgv_points) | ADLS_PCODE_REQ_PSF_PT(psf_points);\n}\n\nstatic bool is_sagv_enabled(struct drm_i915_private *i915, u16 points_mask)\n{\n\treturn !is_power_of_2(~points_mask & icl_qgv_points_mask(i915) &\n\t\t\t      ICL_PCODE_REQ_QGV_PT_MASK);\n}\n\nint icl_pcode_restrict_qgv_points(struct drm_i915_private *dev_priv,\n\t\t\t\t  u32 points_mask)\n{\n\tint ret;\n\n\tif (DISPLAY_VER(dev_priv) >= 14)\n\t\treturn 0;\n\n\t \n\tret = skl_pcode_request(&dev_priv->uncore, ICL_PCODE_SAGV_DE_MEM_SS_CONFIG,\n\t\t\t\tpoints_mask,\n\t\t\t\tICL_PCODE_REP_QGV_MASK | ADLS_PCODE_REP_PSF_MASK,\n\t\t\t\tICL_PCODE_REP_QGV_SAFE | ADLS_PCODE_REP_PSF_SAFE,\n\t\t\t\t1);\n\n\tif (ret < 0) {\n\t\tdrm_err(&dev_priv->drm, \"Failed to disable qgv points (%d) points: 0x%x\\n\", ret, points_mask);\n\t\treturn ret;\n\t}\n\n\tdev_priv->display.sagv.status = is_sagv_enabled(dev_priv, points_mask) ?\n\t\tI915_SAGV_ENABLED : I915_SAGV_DISABLED;\n\n\treturn 0;\n}\n\nstatic int mtl_read_qgv_point_info(struct drm_i915_private *dev_priv,\n\t\t\t\t   struct intel_qgv_point *sp, int point)\n{\n\tu32 val, val2;\n\tu16 dclk;\n\n\tval = intel_uncore_read(&dev_priv->uncore,\n\t\t\t\tMTL_MEM_SS_INFO_QGV_POINT_LOW(point));\n\tval2 = intel_uncore_read(&dev_priv->uncore,\n\t\t\t\t MTL_MEM_SS_INFO_QGV_POINT_HIGH(point));\n\tdclk = REG_FIELD_GET(MTL_DCLK_MASK, val);\n\tsp->dclk = DIV_ROUND_CLOSEST(16667 * dclk, 1000);\n\tsp->t_rp = REG_FIELD_GET(MTL_TRP_MASK, val);\n\tsp->t_rcd = REG_FIELD_GET(MTL_TRCD_MASK, val);\n\n\tsp->t_rdpre = REG_FIELD_GET(MTL_TRDPRE_MASK, val2);\n\tsp->t_ras = REG_FIELD_GET(MTL_TRAS_MASK, val2);\n\n\tsp->t_rc = sp->t_rp + sp->t_ras;\n\n\treturn 0;\n}\n\nstatic int\nintel_read_qgv_point_info(struct drm_i915_private *dev_priv,\n\t\t\t  struct intel_qgv_point *sp,\n\t\t\t  int point)\n{\n\tif (DISPLAY_VER(dev_priv) >= 14)\n\t\treturn mtl_read_qgv_point_info(dev_priv, sp, point);\n\telse if (IS_DG1(dev_priv))\n\t\treturn dg1_mchbar_read_qgv_point_info(dev_priv, sp, point);\n\telse\n\t\treturn icl_pcode_read_qgv_point_info(dev_priv, sp, point);\n}\n\nstatic int icl_get_qgv_points(struct drm_i915_private *dev_priv,\n\t\t\t      struct intel_qgv_info *qi,\n\t\t\t      bool is_y_tile)\n{\n\tconst struct dram_info *dram_info = &dev_priv->dram_info;\n\tint i, ret;\n\n\tqi->num_points = dram_info->num_qgv_points;\n\tqi->num_psf_points = dram_info->num_psf_gv_points;\n\n\tif (DISPLAY_VER(dev_priv) >= 14) {\n\t\tswitch (dram_info->type) {\n\t\tcase INTEL_DRAM_DDR4:\n\t\t\tqi->t_bl = 4;\n\t\t\tqi->max_numchannels = 2;\n\t\t\tqi->channel_width = 64;\n\t\t\tqi->deinterleave = 2;\n\t\t\tbreak;\n\t\tcase INTEL_DRAM_DDR5:\n\t\t\tqi->t_bl = 8;\n\t\t\tqi->max_numchannels = 4;\n\t\t\tqi->channel_width = 32;\n\t\t\tqi->deinterleave = 2;\n\t\t\tbreak;\n\t\tcase INTEL_DRAM_LPDDR4:\n\t\tcase INTEL_DRAM_LPDDR5:\n\t\t\tqi->t_bl = 16;\n\t\t\tqi->max_numchannels = 8;\n\t\t\tqi->channel_width = 16;\n\t\t\tqi->deinterleave = 4;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tMISSING_CASE(dram_info->type);\n\t\t\treturn -EINVAL;\n\t\t}\n\t} else if (DISPLAY_VER(dev_priv) >= 12) {\n\t\tswitch (dram_info->type) {\n\t\tcase INTEL_DRAM_DDR4:\n\t\t\tqi->t_bl = is_y_tile ? 8 : 4;\n\t\t\tqi->max_numchannels = 2;\n\t\t\tqi->channel_width = 64;\n\t\t\tqi->deinterleave = is_y_tile ? 1 : 2;\n\t\t\tbreak;\n\t\tcase INTEL_DRAM_DDR5:\n\t\t\tqi->t_bl = is_y_tile ? 16 : 8;\n\t\t\tqi->max_numchannels = 4;\n\t\t\tqi->channel_width = 32;\n\t\t\tqi->deinterleave = is_y_tile ? 1 : 2;\n\t\t\tbreak;\n\t\tcase INTEL_DRAM_LPDDR4:\n\t\t\tif (IS_ROCKETLAKE(dev_priv)) {\n\t\t\t\tqi->t_bl = 8;\n\t\t\t\tqi->max_numchannels = 4;\n\t\t\t\tqi->channel_width = 32;\n\t\t\t\tqi->deinterleave = 2;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tfallthrough;\n\t\tcase INTEL_DRAM_LPDDR5:\n\t\t\tqi->t_bl = 16;\n\t\t\tqi->max_numchannels = 8;\n\t\t\tqi->channel_width = 16;\n\t\t\tqi->deinterleave = is_y_tile ? 2 : 4;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tqi->t_bl = 16;\n\t\t\tqi->max_numchannels = 1;\n\t\t\tbreak;\n\t\t}\n\t} else if (DISPLAY_VER(dev_priv) == 11) {\n\t\tqi->t_bl = dev_priv->dram_info.type == INTEL_DRAM_DDR4 ? 4 : 8;\n\t\tqi->max_numchannels = 1;\n\t}\n\n\tif (drm_WARN_ON(&dev_priv->drm,\n\t\t\tqi->num_points > ARRAY_SIZE(qi->points)))\n\t\tqi->num_points = ARRAY_SIZE(qi->points);\n\n\tfor (i = 0; i < qi->num_points; i++) {\n\t\tstruct intel_qgv_point *sp = &qi->points[i];\n\n\t\tret = intel_read_qgv_point_info(dev_priv, sp, i);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tdrm_dbg_kms(&dev_priv->drm,\n\t\t\t    \"QGV %d: DCLK=%d tRP=%d tRDPRE=%d tRAS=%d tRCD=%d tRC=%d\\n\",\n\t\t\t    i, sp->dclk, sp->t_rp, sp->t_rdpre, sp->t_ras,\n\t\t\t    sp->t_rcd, sp->t_rc);\n\t}\n\n\tif (qi->num_psf_points > 0) {\n\t\tret = adls_pcode_read_psf_gv_point_info(dev_priv, qi->psf_points);\n\t\tif (ret) {\n\t\t\tdrm_err(&dev_priv->drm, \"Failed to read PSF point data; PSF points will not be considered in bandwidth calculations.\\n\");\n\t\t\tqi->num_psf_points = 0;\n\t\t}\n\n\t\tfor (i = 0; i < qi->num_psf_points; i++)\n\t\t\tdrm_dbg_kms(&dev_priv->drm,\n\t\t\t\t    \"PSF GV %d: CLK=%d \\n\",\n\t\t\t\t    i, qi->psf_points[i].clk);\n\t}\n\n\treturn 0;\n}\n\nstatic int adl_calc_psf_bw(int clk)\n{\n\t \n\treturn DIV_ROUND_CLOSEST(64 * clk * 100, 6);\n}\n\nstatic int icl_sagv_max_dclk(const struct intel_qgv_info *qi)\n{\n\tu16 dclk = 0;\n\tint i;\n\n\tfor (i = 0; i < qi->num_points; i++)\n\t\tdclk = max(dclk, qi->points[i].dclk);\n\n\treturn dclk;\n}\n\nstruct intel_sa_info {\n\tu16 displayrtids;\n\tu8 deburst, deprogbwlimit, derating;\n};\n\nstatic const struct intel_sa_info icl_sa_info = {\n\t.deburst = 8,\n\t.deprogbwlimit = 25,  \n\t.displayrtids = 128,\n\t.derating = 10,\n};\n\nstatic const struct intel_sa_info tgl_sa_info = {\n\t.deburst = 16,\n\t.deprogbwlimit = 34,  \n\t.displayrtids = 256,\n\t.derating = 10,\n};\n\nstatic const struct intel_sa_info rkl_sa_info = {\n\t.deburst = 8,\n\t.deprogbwlimit = 20,  \n\t.displayrtids = 128,\n\t.derating = 10,\n};\n\nstatic const struct intel_sa_info adls_sa_info = {\n\t.deburst = 16,\n\t.deprogbwlimit = 38,  \n\t.displayrtids = 256,\n\t.derating = 10,\n};\n\nstatic const struct intel_sa_info adlp_sa_info = {\n\t.deburst = 16,\n\t.deprogbwlimit = 38,  \n\t.displayrtids = 256,\n\t.derating = 20,\n};\n\nstatic const struct intel_sa_info mtl_sa_info = {\n\t.deburst = 32,\n\t.deprogbwlimit = 38,  \n\t.displayrtids = 256,\n\t.derating = 10,\n};\n\nstatic int icl_get_bw_info(struct drm_i915_private *dev_priv, const struct intel_sa_info *sa)\n{\n\tstruct intel_qgv_info qi = {};\n\tbool is_y_tile = true;  \n\tint num_channels = max_t(u8, 1, dev_priv->dram_info.num_channels);\n\tint ipqdepth, ipqdepthpch = 16;\n\tint dclk_max;\n\tint maxdebw;\n\tint num_groups = ARRAY_SIZE(dev_priv->display.bw.max);\n\tint i, ret;\n\n\tret = icl_get_qgv_points(dev_priv, &qi, is_y_tile);\n\tif (ret) {\n\t\tdrm_dbg_kms(&dev_priv->drm,\n\t\t\t    \"Failed to get memory subsystem information, ignoring bandwidth limits\");\n\t\treturn ret;\n\t}\n\n\tdclk_max = icl_sagv_max_dclk(&qi);\n\tmaxdebw = min(sa->deprogbwlimit * 1000, dclk_max * 16 * 6 / 10);\n\tipqdepth = min(ipqdepthpch, sa->displayrtids / num_channels);\n\tqi.deinterleave = DIV_ROUND_UP(num_channels, is_y_tile ? 4 : 2);\n\n\tfor (i = 0; i < num_groups; i++) {\n\t\tstruct intel_bw_info *bi = &dev_priv->display.bw.max[i];\n\t\tint clpchgroup;\n\t\tint j;\n\n\t\tclpchgroup = (sa->deburst * qi.deinterleave / num_channels) << i;\n\t\tbi->num_planes = (ipqdepth - clpchgroup) / clpchgroup + 1;\n\n\t\tbi->num_qgv_points = qi.num_points;\n\t\tbi->num_psf_gv_points = qi.num_psf_points;\n\n\t\tfor (j = 0; j < qi.num_points; j++) {\n\t\t\tconst struct intel_qgv_point *sp = &qi.points[j];\n\t\t\tint ct, bw;\n\n\t\t\t \n\t\t\tct = max_t(int, sp->t_rc, sp->t_rp + sp->t_rcd +\n\t\t\t\t   (clpchgroup - 1) * qi.t_bl + sp->t_rdpre);\n\t\t\tbw = DIV_ROUND_UP(sp->dclk * clpchgroup * 32 * num_channels, ct);\n\n\t\t\tbi->deratedbw[j] = min(maxdebw,\n\t\t\t\t\t       bw * (100 - sa->derating) / 100);\n\n\t\t\tdrm_dbg_kms(&dev_priv->drm,\n\t\t\t\t    \"BW%d / QGV %d: num_planes=%d deratedbw=%u\\n\",\n\t\t\t\t    i, j, bi->num_planes, bi->deratedbw[j]);\n\t\t}\n\t}\n\t \n\tif (qi.num_points == 1)\n\t\tdev_priv->display.sagv.status = I915_SAGV_NOT_CONTROLLED;\n\telse\n\t\tdev_priv->display.sagv.status = I915_SAGV_ENABLED;\n\n\treturn 0;\n}\n\nstatic int tgl_get_bw_info(struct drm_i915_private *dev_priv, const struct intel_sa_info *sa)\n{\n\tstruct intel_qgv_info qi = {};\n\tconst struct dram_info *dram_info = &dev_priv->dram_info;\n\tbool is_y_tile = true;  \n\tint num_channels = max_t(u8, 1, dev_priv->dram_info.num_channels);\n\tint ipqdepth, ipqdepthpch = 16;\n\tint dclk_max;\n\tint maxdebw, peakbw;\n\tint clperchgroup;\n\tint num_groups = ARRAY_SIZE(dev_priv->display.bw.max);\n\tint i, ret;\n\n\tret = icl_get_qgv_points(dev_priv, &qi, is_y_tile);\n\tif (ret) {\n\t\tdrm_dbg_kms(&dev_priv->drm,\n\t\t\t    \"Failed to get memory subsystem information, ignoring bandwidth limits\");\n\t\treturn ret;\n\t}\n\n\tif (DISPLAY_VER(dev_priv) < 14 &&\n\t    (dram_info->type == INTEL_DRAM_LPDDR4 || dram_info->type == INTEL_DRAM_LPDDR5))\n\t\tnum_channels *= 2;\n\n\tqi.deinterleave = qi.deinterleave ? : DIV_ROUND_UP(num_channels, is_y_tile ? 4 : 2);\n\n\tif (num_channels < qi.max_numchannels && DISPLAY_VER(dev_priv) >= 12)\n\t\tqi.deinterleave = max(DIV_ROUND_UP(qi.deinterleave, 2), 1);\n\n\tif (DISPLAY_VER(dev_priv) > 11 && num_channels > qi.max_numchannels)\n\t\tdrm_warn(&dev_priv->drm, \"Number of channels exceeds max number of channels.\");\n\tif (qi.max_numchannels != 0)\n\t\tnum_channels = min_t(u8, num_channels, qi.max_numchannels);\n\n\tdclk_max = icl_sagv_max_dclk(&qi);\n\n\tpeakbw = num_channels * DIV_ROUND_UP(qi.channel_width, 8) * dclk_max;\n\tmaxdebw = min(sa->deprogbwlimit * 1000, peakbw * 6 / 10);  \n\n\tipqdepth = min(ipqdepthpch, sa->displayrtids / num_channels);\n\t \n\tclperchgroup = 4 * DIV_ROUND_UP(8, num_channels) * qi.deinterleave;\n\n\tfor (i = 0; i < num_groups; i++) {\n\t\tstruct intel_bw_info *bi = &dev_priv->display.bw.max[i];\n\t\tstruct intel_bw_info *bi_next;\n\t\tint clpchgroup;\n\t\tint j;\n\n\t\tclpchgroup = (sa->deburst * qi.deinterleave / num_channels) << i;\n\n\t\tif (i < num_groups - 1) {\n\t\t\tbi_next = &dev_priv->display.bw.max[i + 1];\n\n\t\t\tif (clpchgroup < clperchgroup)\n\t\t\t\tbi_next->num_planes = (ipqdepth - clpchgroup) /\n\t\t\t\t\t\t       clpchgroup + 1;\n\t\t\telse\n\t\t\t\tbi_next->num_planes = 0;\n\t\t}\n\n\t\tbi->num_qgv_points = qi.num_points;\n\t\tbi->num_psf_gv_points = qi.num_psf_points;\n\n\t\tfor (j = 0; j < qi.num_points; j++) {\n\t\t\tconst struct intel_qgv_point *sp = &qi.points[j];\n\t\t\tint ct, bw;\n\n\t\t\t \n\t\t\tct = max_t(int, sp->t_rc, sp->t_rp + sp->t_rcd +\n\t\t\t\t   (clpchgroup - 1) * qi.t_bl + sp->t_rdpre);\n\t\t\tbw = DIV_ROUND_UP(sp->dclk * clpchgroup * 32 * num_channels, ct);\n\n\t\t\tbi->deratedbw[j] = min(maxdebw,\n\t\t\t\t\t       bw * (100 - sa->derating) / 100);\n\t\t\tbi->peakbw[j] = DIV_ROUND_CLOSEST(sp->dclk *\n\t\t\t\t\t\t\t  num_channels *\n\t\t\t\t\t\t\t  qi.channel_width, 8);\n\n\t\t\tdrm_dbg_kms(&dev_priv->drm,\n\t\t\t\t    \"BW%d / QGV %d: num_planes=%d deratedbw=%u peakbw: %u\\n\",\n\t\t\t\t    i, j, bi->num_planes, bi->deratedbw[j],\n\t\t\t\t    bi->peakbw[j]);\n\t\t}\n\n\t\tfor (j = 0; j < qi.num_psf_points; j++) {\n\t\t\tconst struct intel_psf_gv_point *sp = &qi.psf_points[j];\n\n\t\t\tbi->psf_bw[j] = adl_calc_psf_bw(sp->clk);\n\n\t\t\tdrm_dbg_kms(&dev_priv->drm,\n\t\t\t\t    \"BW%d / PSF GV %d: num_planes=%d bw=%u\\n\",\n\t\t\t\t    i, j, bi->num_planes, bi->psf_bw[j]);\n\t\t}\n\t}\n\n\t \n\tif (qi.num_points == 1)\n\t\tdev_priv->display.sagv.status = I915_SAGV_NOT_CONTROLLED;\n\telse\n\t\tdev_priv->display.sagv.status = I915_SAGV_ENABLED;\n\n\treturn 0;\n}\n\nstatic void dg2_get_bw_info(struct drm_i915_private *i915)\n{\n\tunsigned int deratedbw = IS_DG2_G11(i915) ? 38000 : 50000;\n\tint num_groups = ARRAY_SIZE(i915->display.bw.max);\n\tint i;\n\n\t \n\tfor (i = 0; i < num_groups; i++) {\n\t\tstruct intel_bw_info *bi = &i915->display.bw.max[i];\n\n\t\tbi->num_planes = 1;\n\t\t \n\t\tbi->num_qgv_points = 1;\n\t\tbi->deratedbw[0] = deratedbw;\n\t}\n\n\ti915->display.sagv.status = I915_SAGV_NOT_CONTROLLED;\n}\n\nstatic unsigned int icl_max_bw_index(struct drm_i915_private *dev_priv,\n\t\t\t\t     int num_planes, int qgv_point)\n{\n\tint i;\n\n\t \n\tnum_planes = max(1, num_planes);\n\n\tfor (i = 0; i < ARRAY_SIZE(dev_priv->display.bw.max); i++) {\n\t\tconst struct intel_bw_info *bi =\n\t\t\t&dev_priv->display.bw.max[i];\n\n\t\t \n\t\tif (qgv_point >= bi->num_qgv_points)\n\t\t\treturn UINT_MAX;\n\n\t\tif (num_planes >= bi->num_planes)\n\t\t\treturn i;\n\t}\n\n\treturn UINT_MAX;\n}\n\nstatic unsigned int tgl_max_bw_index(struct drm_i915_private *dev_priv,\n\t\t\t\t     int num_planes, int qgv_point)\n{\n\tint i;\n\n\t \n\tnum_planes = max(1, num_planes);\n\n\tfor (i = ARRAY_SIZE(dev_priv->display.bw.max) - 1; i >= 0; i--) {\n\t\tconst struct intel_bw_info *bi =\n\t\t\t&dev_priv->display.bw.max[i];\n\n\t\t \n\t\tif (qgv_point >= bi->num_qgv_points)\n\t\t\treturn UINT_MAX;\n\n\t\tif (num_planes <= bi->num_planes)\n\t\t\treturn i;\n\t}\n\n\treturn 0;\n}\n\nstatic unsigned int adl_psf_bw(struct drm_i915_private *dev_priv,\n\t\t\t       int psf_gv_point)\n{\n\tconst struct intel_bw_info *bi =\n\t\t\t&dev_priv->display.bw.max[0];\n\n\treturn bi->psf_bw[psf_gv_point];\n}\n\nvoid intel_bw_init_hw(struct drm_i915_private *dev_priv)\n{\n\tif (!HAS_DISPLAY(dev_priv))\n\t\treturn;\n\n\tif (DISPLAY_VER(dev_priv) >= 14)\n\t\ttgl_get_bw_info(dev_priv, &mtl_sa_info);\n\telse if (IS_DG2(dev_priv))\n\t\tdg2_get_bw_info(dev_priv);\n\telse if (IS_ALDERLAKE_P(dev_priv))\n\t\ttgl_get_bw_info(dev_priv, &adlp_sa_info);\n\telse if (IS_ALDERLAKE_S(dev_priv))\n\t\ttgl_get_bw_info(dev_priv, &adls_sa_info);\n\telse if (IS_ROCKETLAKE(dev_priv))\n\t\ttgl_get_bw_info(dev_priv, &rkl_sa_info);\n\telse if (DISPLAY_VER(dev_priv) == 12)\n\t\ttgl_get_bw_info(dev_priv, &tgl_sa_info);\n\telse if (DISPLAY_VER(dev_priv) == 11)\n\t\ticl_get_bw_info(dev_priv, &icl_sa_info);\n}\n\nstatic unsigned int intel_bw_crtc_num_active_planes(const struct intel_crtc_state *crtc_state)\n{\n\t \n\treturn hweight8(crtc_state->active_planes & ~BIT(PLANE_CURSOR));\n}\n\nstatic unsigned int intel_bw_crtc_data_rate(const struct intel_crtc_state *crtc_state)\n{\n\tstruct intel_crtc *crtc = to_intel_crtc(crtc_state->uapi.crtc);\n\tstruct drm_i915_private *i915 = to_i915(crtc->base.dev);\n\tunsigned int data_rate = 0;\n\tenum plane_id plane_id;\n\n\tfor_each_plane_id_on_crtc(crtc, plane_id) {\n\t\t \n\t\tif (plane_id == PLANE_CURSOR)\n\t\t\tcontinue;\n\n\t\tdata_rate += crtc_state->data_rate[plane_id];\n\n\t\tif (DISPLAY_VER(i915) < 11)\n\t\t\tdata_rate += crtc_state->data_rate_y[plane_id];\n\t}\n\n\treturn data_rate;\n}\n\n \nstatic int intel_bw_crtc_min_cdclk(const struct intel_crtc_state *crtc_state)\n{\n\tstruct intel_crtc *crtc = to_intel_crtc(crtc_state->uapi.crtc);\n\tstruct drm_i915_private *i915 = to_i915(crtc->base.dev);\n\n\tif (DISPLAY_VER(i915) < 12)\n\t\treturn 0;\n\n\treturn DIV_ROUND_UP_ULL(mul_u32_u32(intel_bw_crtc_data_rate(crtc_state), 10), 512);\n}\n\nvoid intel_bw_crtc_update(struct intel_bw_state *bw_state,\n\t\t\t  const struct intel_crtc_state *crtc_state)\n{\n\tstruct intel_crtc *crtc = to_intel_crtc(crtc_state->uapi.crtc);\n\tstruct drm_i915_private *i915 = to_i915(crtc->base.dev);\n\n\tbw_state->data_rate[crtc->pipe] =\n\t\tintel_bw_crtc_data_rate(crtc_state);\n\tbw_state->num_active_planes[crtc->pipe] =\n\t\tintel_bw_crtc_num_active_planes(crtc_state);\n\n\tdrm_dbg_kms(&i915->drm, \"pipe %c data rate %u num active planes %u\\n\",\n\t\t    pipe_name(crtc->pipe),\n\t\t    bw_state->data_rate[crtc->pipe],\n\t\t    bw_state->num_active_planes[crtc->pipe]);\n}\n\nstatic unsigned int intel_bw_num_active_planes(struct drm_i915_private *dev_priv,\n\t\t\t\t\t       const struct intel_bw_state *bw_state)\n{\n\tunsigned int num_active_planes = 0;\n\tenum pipe pipe;\n\n\tfor_each_pipe(dev_priv, pipe)\n\t\tnum_active_planes += bw_state->num_active_planes[pipe];\n\n\treturn num_active_planes;\n}\n\nstatic unsigned int intel_bw_data_rate(struct drm_i915_private *dev_priv,\n\t\t\t\t       const struct intel_bw_state *bw_state)\n{\n\tunsigned int data_rate = 0;\n\tenum pipe pipe;\n\n\tfor_each_pipe(dev_priv, pipe)\n\t\tdata_rate += bw_state->data_rate[pipe];\n\n\tif (DISPLAY_VER(dev_priv) >= 13 && i915_vtd_active(dev_priv))\n\t\tdata_rate = DIV_ROUND_UP(data_rate * 105, 100);\n\n\treturn data_rate;\n}\n\nstruct intel_bw_state *\nintel_atomic_get_old_bw_state(struct intel_atomic_state *state)\n{\n\tstruct drm_i915_private *dev_priv = to_i915(state->base.dev);\n\tstruct intel_global_state *bw_state;\n\n\tbw_state = intel_atomic_get_old_global_obj_state(state, &dev_priv->display.bw.obj);\n\n\treturn to_intel_bw_state(bw_state);\n}\n\nstruct intel_bw_state *\nintel_atomic_get_new_bw_state(struct intel_atomic_state *state)\n{\n\tstruct drm_i915_private *dev_priv = to_i915(state->base.dev);\n\tstruct intel_global_state *bw_state;\n\n\tbw_state = intel_atomic_get_new_global_obj_state(state, &dev_priv->display.bw.obj);\n\n\treturn to_intel_bw_state(bw_state);\n}\n\nstruct intel_bw_state *\nintel_atomic_get_bw_state(struct intel_atomic_state *state)\n{\n\tstruct drm_i915_private *dev_priv = to_i915(state->base.dev);\n\tstruct intel_global_state *bw_state;\n\n\tbw_state = intel_atomic_get_global_obj_state(state, &dev_priv->display.bw.obj);\n\tif (IS_ERR(bw_state))\n\t\treturn ERR_CAST(bw_state);\n\n\treturn to_intel_bw_state(bw_state);\n}\n\nstatic int mtl_find_qgv_points(struct drm_i915_private *i915,\n\t\t\t       unsigned int data_rate,\n\t\t\t       unsigned int num_active_planes,\n\t\t\t       struct intel_bw_state *new_bw_state)\n{\n\tunsigned int best_rate = UINT_MAX;\n\tunsigned int num_qgv_points = i915->display.bw.max[0].num_qgv_points;\n\tunsigned int qgv_peak_bw  = 0;\n\tint i;\n\tint ret;\n\n\tret = intel_atomic_lock_global_state(&new_bw_state->base);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tif (!intel_can_enable_sagv(i915, new_bw_state)) {\n\t\tnew_bw_state->qgv_point_peakbw = U16_MAX;\n\t\tdrm_dbg_kms(&i915->drm, \"No SAGV, use UINT_MAX as peak bw.\");\n\t\treturn 0;\n\t}\n\n\t \n\tfor (i = 0; i < num_qgv_points; i++) {\n\t\tunsigned int bw_index =\n\t\t\ttgl_max_bw_index(i915, num_active_planes, i);\n\t\tunsigned int max_data_rate;\n\n\t\tif (bw_index >= ARRAY_SIZE(i915->display.bw.max))\n\t\t\tcontinue;\n\n\t\tmax_data_rate = i915->display.bw.max[bw_index].deratedbw[i];\n\n\t\tif (max_data_rate < data_rate)\n\t\t\tcontinue;\n\n\t\tif (max_data_rate - data_rate < best_rate) {\n\t\t\tbest_rate = max_data_rate - data_rate;\n\t\t\tqgv_peak_bw = i915->display.bw.max[bw_index].peakbw[i];\n\t\t}\n\n\t\tdrm_dbg_kms(&i915->drm, \"QGV point %d: max bw %d required %d qgv_peak_bw: %d\\n\",\n\t\t\t    i, max_data_rate, data_rate, qgv_peak_bw);\n\t}\n\n\tdrm_dbg_kms(&i915->drm, \"Matching peaks QGV bw: %d for required data rate: %d\\n\",\n\t\t    qgv_peak_bw, data_rate);\n\n\t \n\tif (qgv_peak_bw == 0) {\n\t\tdrm_dbg_kms(&i915->drm, \"No QGV points for bw %d for display configuration(%d active planes).\\n\",\n\t\t\t    data_rate, num_active_planes);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tnew_bw_state->qgv_point_peakbw = DIV_ROUND_CLOSEST(qgv_peak_bw, 100);\n\n\treturn 0;\n}\n\nstatic int icl_find_qgv_points(struct drm_i915_private *i915,\n\t\t\t       unsigned int data_rate,\n\t\t\t       unsigned int num_active_planes,\n\t\t\t       const struct intel_bw_state *old_bw_state,\n\t\t\t       struct intel_bw_state *new_bw_state)\n{\n\tunsigned int max_bw_point = 0;\n\tunsigned int max_bw = 0;\n\tunsigned int num_psf_gv_points = i915->display.bw.max[0].num_psf_gv_points;\n\tunsigned int num_qgv_points = i915->display.bw.max[0].num_qgv_points;\n\tu16 psf_points = 0;\n\tu16 qgv_points = 0;\n\tint i;\n\tint ret;\n\n\tret = intel_atomic_lock_global_state(&new_bw_state->base);\n\tif (ret)\n\t\treturn ret;\n\n\tfor (i = 0; i < num_qgv_points; i++) {\n\t\tunsigned int idx;\n\t\tunsigned int max_data_rate;\n\n\t\tif (DISPLAY_VER(i915) > 11)\n\t\t\tidx = tgl_max_bw_index(i915, num_active_planes, i);\n\t\telse\n\t\t\tidx = icl_max_bw_index(i915, num_active_planes, i);\n\n\t\tif (idx >= ARRAY_SIZE(i915->display.bw.max))\n\t\t\tcontinue;\n\n\t\tmax_data_rate = i915->display.bw.max[idx].deratedbw[i];\n\n\t\t \n\t\tif (max_data_rate > max_bw) {\n\t\t\tmax_bw_point = i;\n\t\t\tmax_bw = max_data_rate;\n\t\t}\n\t\tif (max_data_rate >= data_rate)\n\t\t\tqgv_points |= BIT(i);\n\n\t\tdrm_dbg_kms(&i915->drm, \"QGV point %d: max bw %d required %d\\n\",\n\t\t\t    i, max_data_rate, data_rate);\n\t}\n\n\tfor (i = 0; i < num_psf_gv_points; i++) {\n\t\tunsigned int max_data_rate = adl_psf_bw(i915, i);\n\n\t\tif (max_data_rate >= data_rate)\n\t\t\tpsf_points |= BIT(i);\n\n\t\tdrm_dbg_kms(&i915->drm, \"PSF GV point %d: max bw %d\"\n\t\t\t    \" required %d\\n\",\n\t\t\t    i, max_data_rate, data_rate);\n\t}\n\n\t \n\tif (qgv_points == 0) {\n\t\tdrm_dbg_kms(&i915->drm, \"No QGV points provide sufficient memory\"\n\t\t\t    \" bandwidth %d for display configuration(%d active planes).\\n\",\n\t\t\t    data_rate, num_active_planes);\n\t\treturn -EINVAL;\n\t}\n\n\tif (num_psf_gv_points > 0 && psf_points == 0) {\n\t\tdrm_dbg_kms(&i915->drm, \"No PSF GV points provide sufficient memory\"\n\t\t\t    \" bandwidth %d for display configuration(%d active planes).\\n\",\n\t\t\t    data_rate, num_active_planes);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (!intel_can_enable_sagv(i915, new_bw_state)) {\n\t\tqgv_points = BIT(max_bw_point);\n\t\tdrm_dbg_kms(&i915->drm, \"No SAGV, using single QGV point %d\\n\",\n\t\t\t    max_bw_point);\n\t}\n\n\t \n\tnew_bw_state->qgv_points_mask =\n\t\t~(ICL_PCODE_REQ_QGV_PT(qgv_points) |\n\t\t  ADLS_PCODE_REQ_PSF_PT(psf_points)) &\n\t\ticl_qgv_points_mask(i915);\n\n\t \n\tif (new_bw_state->qgv_points_mask != old_bw_state->qgv_points_mask) {\n\t\tret = intel_atomic_serialize_global_state(&new_bw_state->base);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int intel_bw_check_qgv_points(struct drm_i915_private *i915,\n\t\t\t\t     const struct intel_bw_state *old_bw_state,\n\t\t\t\t     struct intel_bw_state *new_bw_state)\n{\n\tunsigned int data_rate = intel_bw_data_rate(i915, new_bw_state);\n\tunsigned int num_active_planes =\n\t\t\tintel_bw_num_active_planes(i915, new_bw_state);\n\n\tdata_rate = DIV_ROUND_UP(data_rate, 1000);\n\n\tif (DISPLAY_VER(i915) >= 14)\n\t\treturn mtl_find_qgv_points(i915, data_rate, num_active_planes,\n\t\t\t\t\t   new_bw_state);\n\telse\n\t\treturn icl_find_qgv_points(i915, data_rate, num_active_planes,\n\t\t\t\t\t   old_bw_state, new_bw_state);\n}\n\nstatic bool intel_bw_state_changed(struct drm_i915_private *i915,\n\t\t\t\t   const struct intel_bw_state *old_bw_state,\n\t\t\t\t   const struct intel_bw_state *new_bw_state)\n{\n\tenum pipe pipe;\n\n\tfor_each_pipe(i915, pipe) {\n\t\tconst struct intel_dbuf_bw *old_crtc_bw =\n\t\t\t&old_bw_state->dbuf_bw[pipe];\n\t\tconst struct intel_dbuf_bw *new_crtc_bw =\n\t\t\t&new_bw_state->dbuf_bw[pipe];\n\t\tenum dbuf_slice slice;\n\n\t\tfor_each_dbuf_slice(i915, slice) {\n\t\t\tif (old_crtc_bw->max_bw[slice] != new_crtc_bw->max_bw[slice] ||\n\t\t\t    old_crtc_bw->active_planes[slice] != new_crtc_bw->active_planes[slice])\n\t\t\t\treturn true;\n\t\t}\n\n\t\tif (old_bw_state->min_cdclk[pipe] != new_bw_state->min_cdclk[pipe])\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}\n\nstatic void skl_plane_calc_dbuf_bw(struct intel_bw_state *bw_state,\n\t\t\t\t   struct intel_crtc *crtc,\n\t\t\t\t   enum plane_id plane_id,\n\t\t\t\t   const struct skl_ddb_entry *ddb,\n\t\t\t\t   unsigned int data_rate)\n{\n\tstruct drm_i915_private *i915 = to_i915(crtc->base.dev);\n\tstruct intel_dbuf_bw *crtc_bw = &bw_state->dbuf_bw[crtc->pipe];\n\tunsigned int dbuf_mask = skl_ddb_dbuf_slice_mask(i915, ddb);\n\tenum dbuf_slice slice;\n\n\t \n\tfor_each_dbuf_slice_in_mask(i915, slice, dbuf_mask) {\n\t\tcrtc_bw->max_bw[slice] = max(crtc_bw->max_bw[slice], data_rate);\n\t\tcrtc_bw->active_planes[slice] |= BIT(plane_id);\n\t}\n}\n\nstatic void skl_crtc_calc_dbuf_bw(struct intel_bw_state *bw_state,\n\t\t\t\t  const struct intel_crtc_state *crtc_state)\n{\n\tstruct intel_crtc *crtc = to_intel_crtc(crtc_state->uapi.crtc);\n\tstruct drm_i915_private *i915 = to_i915(crtc->base.dev);\n\tstruct intel_dbuf_bw *crtc_bw = &bw_state->dbuf_bw[crtc->pipe];\n\tenum plane_id plane_id;\n\n\tmemset(crtc_bw, 0, sizeof(*crtc_bw));\n\n\tif (!crtc_state->hw.active)\n\t\treturn;\n\n\tfor_each_plane_id_on_crtc(crtc, plane_id) {\n\t\t \n\t\tif (plane_id == PLANE_CURSOR)\n\t\t\tcontinue;\n\n\t\tskl_plane_calc_dbuf_bw(bw_state, crtc, plane_id,\n\t\t\t\t       &crtc_state->wm.skl.plane_ddb[plane_id],\n\t\t\t\t       crtc_state->data_rate[plane_id]);\n\n\t\tif (DISPLAY_VER(i915) < 11)\n\t\t\tskl_plane_calc_dbuf_bw(bw_state, crtc, plane_id,\n\t\t\t\t\t       &crtc_state->wm.skl.plane_ddb_y[plane_id],\n\t\t\t\t\t       crtc_state->data_rate[plane_id]);\n\t}\n}\n\n \nstatic int\nintel_bw_dbuf_min_cdclk(struct drm_i915_private *i915,\n\t\t\tconst struct intel_bw_state *bw_state)\n{\n\tunsigned int total_max_bw = 0;\n\tenum dbuf_slice slice;\n\n\tfor_each_dbuf_slice(i915, slice) {\n\t\tint num_active_planes = 0;\n\t\tunsigned int max_bw = 0;\n\t\tenum pipe pipe;\n\n\t\t \n\t\tfor_each_pipe(i915, pipe) {\n\t\t\tconst struct intel_dbuf_bw *crtc_bw = &bw_state->dbuf_bw[pipe];\n\n\t\t\tmax_bw = max(crtc_bw->max_bw[slice], max_bw);\n\t\t\tnum_active_planes += hweight8(crtc_bw->active_planes[slice]);\n\t\t}\n\t\tmax_bw *= num_active_planes;\n\n\t\ttotal_max_bw = max(total_max_bw, max_bw);\n\t}\n\n\treturn DIV_ROUND_UP(total_max_bw, 64);\n}\n\nint intel_bw_min_cdclk(struct drm_i915_private *i915,\n\t\t       const struct intel_bw_state *bw_state)\n{\n\tenum pipe pipe;\n\tint min_cdclk;\n\n\tmin_cdclk = intel_bw_dbuf_min_cdclk(i915, bw_state);\n\n\tfor_each_pipe(i915, pipe)\n\t\tmin_cdclk = max(bw_state->min_cdclk[pipe], min_cdclk);\n\n\treturn min_cdclk;\n}\n\nint intel_bw_calc_min_cdclk(struct intel_atomic_state *state,\n\t\t\t    bool *need_cdclk_calc)\n{\n\tstruct drm_i915_private *dev_priv = to_i915(state->base.dev);\n\tstruct intel_bw_state *new_bw_state = NULL;\n\tconst struct intel_bw_state *old_bw_state = NULL;\n\tconst struct intel_cdclk_state *cdclk_state;\n\tconst struct intel_crtc_state *crtc_state;\n\tint old_min_cdclk, new_min_cdclk;\n\tstruct intel_crtc *crtc;\n\tint i;\n\n\tif (DISPLAY_VER(dev_priv) < 9)\n\t\treturn 0;\n\n\tfor_each_new_intel_crtc_in_state(state, crtc, crtc_state, i) {\n\t\tnew_bw_state = intel_atomic_get_bw_state(state);\n\t\tif (IS_ERR(new_bw_state))\n\t\t\treturn PTR_ERR(new_bw_state);\n\n\t\told_bw_state = intel_atomic_get_old_bw_state(state);\n\n\t\tskl_crtc_calc_dbuf_bw(new_bw_state, crtc_state);\n\n\t\tnew_bw_state->min_cdclk[crtc->pipe] =\n\t\t\tintel_bw_crtc_min_cdclk(crtc_state);\n\t}\n\n\tif (!old_bw_state)\n\t\treturn 0;\n\n\tif (intel_bw_state_changed(dev_priv, old_bw_state, new_bw_state)) {\n\t\tint ret = intel_atomic_lock_global_state(&new_bw_state->base);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\told_min_cdclk = intel_bw_min_cdclk(dev_priv, old_bw_state);\n\tnew_min_cdclk = intel_bw_min_cdclk(dev_priv, new_bw_state);\n\n\t \n\tif (new_min_cdclk <= old_min_cdclk)\n\t\treturn 0;\n\n\tcdclk_state = intel_atomic_get_cdclk_state(state);\n\tif (IS_ERR(cdclk_state))\n\t\treturn PTR_ERR(cdclk_state);\n\n\t \n\tif (new_min_cdclk <= cdclk_state->bw_min_cdclk)\n\t\treturn 0;\n\n\tdrm_dbg_kms(&dev_priv->drm,\n\t\t    \"new bandwidth min cdclk (%d kHz) > old min cdclk (%d kHz)\\n\",\n\t\t    new_min_cdclk, cdclk_state->bw_min_cdclk);\n\t*need_cdclk_calc = true;\n\n\treturn 0;\n}\n\nstatic int intel_bw_check_data_rate(struct intel_atomic_state *state, bool *changed)\n{\n\tstruct drm_i915_private *i915 = to_i915(state->base.dev);\n\tconst struct intel_crtc_state *new_crtc_state, *old_crtc_state;\n\tstruct intel_crtc *crtc;\n\tint i;\n\n\tfor_each_oldnew_intel_crtc_in_state(state, crtc, old_crtc_state,\n\t\t\t\t\t    new_crtc_state, i) {\n\t\tunsigned int old_data_rate =\n\t\t\tintel_bw_crtc_data_rate(old_crtc_state);\n\t\tunsigned int new_data_rate =\n\t\t\tintel_bw_crtc_data_rate(new_crtc_state);\n\t\tunsigned int old_active_planes =\n\t\t\tintel_bw_crtc_num_active_planes(old_crtc_state);\n\t\tunsigned int new_active_planes =\n\t\t\tintel_bw_crtc_num_active_planes(new_crtc_state);\n\t\tstruct intel_bw_state *new_bw_state;\n\n\t\t \n\t\tif (old_data_rate == new_data_rate &&\n\t\t    old_active_planes == new_active_planes)\n\t\t\tcontinue;\n\n\t\tnew_bw_state = intel_atomic_get_bw_state(state);\n\t\tif (IS_ERR(new_bw_state))\n\t\t\treturn PTR_ERR(new_bw_state);\n\n\t\tnew_bw_state->data_rate[crtc->pipe] = new_data_rate;\n\t\tnew_bw_state->num_active_planes[crtc->pipe] = new_active_planes;\n\n\t\t*changed = true;\n\n\t\tdrm_dbg_kms(&i915->drm,\n\t\t\t    \"[CRTC:%d:%s] data rate %u num active planes %u\\n\",\n\t\t\t    crtc->base.base.id, crtc->base.name,\n\t\t\t    new_bw_state->data_rate[crtc->pipe],\n\t\t\t    new_bw_state->num_active_planes[crtc->pipe]);\n\t}\n\n\treturn 0;\n}\n\nint intel_bw_atomic_check(struct intel_atomic_state *state)\n{\n\tbool changed = false;\n\tstruct drm_i915_private *i915 = to_i915(state->base.dev);\n\tstruct intel_bw_state *new_bw_state;\n\tconst struct intel_bw_state *old_bw_state;\n\tint ret;\n\n\t \n\tif (DISPLAY_VER(i915) < 11)\n\t\treturn 0;\n\n\tret = intel_bw_check_data_rate(state, &changed);\n\tif (ret)\n\t\treturn ret;\n\n\told_bw_state = intel_atomic_get_old_bw_state(state);\n\tnew_bw_state = intel_atomic_get_new_bw_state(state);\n\n\tif (new_bw_state &&\n\t    intel_can_enable_sagv(i915, old_bw_state) !=\n\t    intel_can_enable_sagv(i915, new_bw_state))\n\t\tchanged = true;\n\n\t \n\tif (!changed)\n\t\treturn 0;\n\n\tret = intel_bw_check_qgv_points(i915, old_bw_state, new_bw_state);\n\tif (ret)\n\t\treturn ret;\n\n\treturn 0;\n}\n\nstatic struct intel_global_state *\nintel_bw_duplicate_state(struct intel_global_obj *obj)\n{\n\tstruct intel_bw_state *state;\n\n\tstate = kmemdup(obj->state, sizeof(*state), GFP_KERNEL);\n\tif (!state)\n\t\treturn NULL;\n\n\treturn &state->base;\n}\n\nstatic void intel_bw_destroy_state(struct intel_global_obj *obj,\n\t\t\t\t   struct intel_global_state *state)\n{\n\tkfree(state);\n}\n\nstatic const struct intel_global_state_funcs intel_bw_funcs = {\n\t.atomic_duplicate_state = intel_bw_duplicate_state,\n\t.atomic_destroy_state = intel_bw_destroy_state,\n};\n\nint intel_bw_init(struct drm_i915_private *dev_priv)\n{\n\tstruct intel_bw_state *state;\n\n\tstate = kzalloc(sizeof(*state), GFP_KERNEL);\n\tif (!state)\n\t\treturn -ENOMEM;\n\n\tintel_atomic_global_obj_init(dev_priv, &dev_priv->display.bw.obj,\n\t\t\t\t     &state->base, &intel_bw_funcs);\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}