{
  "module_name": "intel_lspcon.c",
  "hash_id": "910f182ef1770b605e1c9bf9f7189fdaedc27f029a4754611438315629b18f16",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/i915/display/intel_lspcon.c",
  "human_readable_source": " \n\n#include <drm/display/drm_dp_dual_mode_helper.h>\n#include <drm/display/drm_hdmi_helper.h>\n#include <drm/drm_atomic_helper.h>\n#include <drm/drm_edid.h>\n\n#include \"i915_reg.h\"\n#include \"intel_de.h\"\n#include \"intel_display_types.h\"\n#include \"intel_dp.h\"\n#include \"intel_lspcon.h\"\n#include \"intel_hdmi.h\"\n\n \n#define LSPCON_VENDOR_PARADE_OUI 0x001CF8\n#define LSPCON_VENDOR_MCA_OUI 0x0060AD\n\n#define DPCD_MCA_LSPCON_HDR_STATUS\t0x70003\n#define DPCD_PARADE_LSPCON_HDR_STATUS\t0x00511\n\n \n#define LSPCON_MCA_AVI_IF_WRITE_OFFSET 0x5C0\n#define LSPCON_MCA_AVI_IF_CTRL 0x5DF\n#define  LSPCON_MCA_AVI_IF_KICKOFF (1 << 0)\n#define  LSPCON_MCA_AVI_IF_HANDLED (1 << 1)\n\n \n#define LSPCON_PARADE_AVI_IF_WRITE_OFFSET 0x516\n#define LSPCON_PARADE_AVI_IF_CTRL 0x51E\n#define  LSPCON_PARADE_AVI_IF_KICKOFF (1 << 7)\n#define LSPCON_PARADE_AVI_IF_DATA_SIZE 32\n\nstatic struct intel_dp *lspcon_to_intel_dp(struct intel_lspcon *lspcon)\n{\n\tstruct intel_digital_port *dig_port =\n\t\tcontainer_of(lspcon, struct intel_digital_port, lspcon);\n\n\treturn &dig_port->dp;\n}\n\nstatic const char *lspcon_mode_name(enum drm_lspcon_mode mode)\n{\n\tswitch (mode) {\n\tcase DRM_LSPCON_MODE_PCON:\n\t\treturn \"PCON\";\n\tcase DRM_LSPCON_MODE_LS:\n\t\treturn \"LS\";\n\tcase DRM_LSPCON_MODE_INVALID:\n\t\treturn \"INVALID\";\n\tdefault:\n\t\tMISSING_CASE(mode);\n\t\treturn \"INVALID\";\n\t}\n}\n\nstatic bool lspcon_detect_vendor(struct intel_lspcon *lspcon)\n{\n\tstruct intel_dp *dp = lspcon_to_intel_dp(lspcon);\n\tstruct drm_i915_private *i915 = dp_to_i915(dp);\n\tstruct drm_dp_dpcd_ident *ident;\n\tu32 vendor_oui;\n\n\tif (drm_dp_read_desc(&dp->aux, &dp->desc, drm_dp_is_branch(dp->dpcd))) {\n\t\tdrm_err(&i915->drm, \"Can't read description\\n\");\n\t\treturn false;\n\t}\n\n\tident = &dp->desc.ident;\n\tvendor_oui = (ident->oui[0] << 16) | (ident->oui[1] << 8) |\n\t\t      ident->oui[2];\n\n\tswitch (vendor_oui) {\n\tcase LSPCON_VENDOR_MCA_OUI:\n\t\tlspcon->vendor = LSPCON_VENDOR_MCA;\n\t\tdrm_dbg_kms(&i915->drm, \"Vendor: Mega Chips\\n\");\n\t\tbreak;\n\n\tcase LSPCON_VENDOR_PARADE_OUI:\n\t\tlspcon->vendor = LSPCON_VENDOR_PARADE;\n\t\tdrm_dbg_kms(&i915->drm, \"Vendor: Parade Tech\\n\");\n\t\tbreak;\n\n\tdefault:\n\t\tdrm_err(&i915->drm, \"Invalid/Unknown vendor OUI\\n\");\n\t\treturn false;\n\t}\n\n\treturn true;\n}\n\nstatic u32 get_hdr_status_reg(struct intel_lspcon *lspcon)\n{\n\tif (lspcon->vendor == LSPCON_VENDOR_MCA)\n\t\treturn DPCD_MCA_LSPCON_HDR_STATUS;\n\telse\n\t\treturn DPCD_PARADE_LSPCON_HDR_STATUS;\n}\n\nvoid lspcon_detect_hdr_capability(struct intel_lspcon *lspcon)\n{\n\tstruct intel_dp *intel_dp = lspcon_to_intel_dp(lspcon);\n\tstruct drm_i915_private *i915 = dp_to_i915(intel_dp);\n\tu8 hdr_caps;\n\tint ret;\n\n\tret = drm_dp_dpcd_read(&intel_dp->aux, get_hdr_status_reg(lspcon),\n\t\t\t       &hdr_caps, 1);\n\n\tif (ret < 0) {\n\t\tdrm_dbg_kms(&i915->drm, \"HDR capability detection failed\\n\");\n\t\tlspcon->hdr_supported = false;\n\t} else if (hdr_caps & 0x1) {\n\t\tdrm_dbg_kms(&i915->drm, \"LSPCON capable of HDR\\n\");\n\t\tlspcon->hdr_supported = true;\n\t}\n}\n\nstatic enum drm_lspcon_mode lspcon_get_current_mode(struct intel_lspcon *lspcon)\n{\n\tstruct intel_dp *intel_dp = lspcon_to_intel_dp(lspcon);\n\tstruct drm_i915_private *i915 = dp_to_i915(intel_dp);\n\tenum drm_lspcon_mode current_mode;\n\tstruct i2c_adapter *adapter = &intel_dp->aux.ddc;\n\n\tif (drm_lspcon_get_mode(intel_dp->aux.drm_dev, adapter, &current_mode)) {\n\t\tdrm_dbg_kms(&i915->drm, \"Error reading LSPCON mode\\n\");\n\t\treturn DRM_LSPCON_MODE_INVALID;\n\t}\n\treturn current_mode;\n}\n\nstatic enum drm_lspcon_mode lspcon_wait_mode(struct intel_lspcon *lspcon,\n\t\t\t\t\t     enum drm_lspcon_mode mode)\n{\n\tstruct intel_dp *intel_dp = lspcon_to_intel_dp(lspcon);\n\tstruct drm_i915_private *i915 = dp_to_i915(intel_dp);\n\tenum drm_lspcon_mode current_mode;\n\n\tcurrent_mode = lspcon_get_current_mode(lspcon);\n\tif (current_mode == mode)\n\t\tgoto out;\n\n\tdrm_dbg_kms(&i915->drm, \"Waiting for LSPCON mode %s to settle\\n\",\n\t\t    lspcon_mode_name(mode));\n\n\twait_for((current_mode = lspcon_get_current_mode(lspcon)) == mode, 400);\n\tif (current_mode != mode)\n\t\tdrm_err(&i915->drm, \"LSPCON mode hasn't settled\\n\");\n\nout:\n\tdrm_dbg_kms(&i915->drm, \"Current LSPCON mode %s\\n\",\n\t\t    lspcon_mode_name(current_mode));\n\n\treturn current_mode;\n}\n\nstatic int lspcon_change_mode(struct intel_lspcon *lspcon,\n\t\t\t      enum drm_lspcon_mode mode)\n{\n\tstruct intel_dp *intel_dp = lspcon_to_intel_dp(lspcon);\n\tstruct drm_i915_private *i915 = dp_to_i915(intel_dp);\n\tint err;\n\tenum drm_lspcon_mode current_mode;\n\tstruct i2c_adapter *adapter = &intel_dp->aux.ddc;\n\n\terr = drm_lspcon_get_mode(intel_dp->aux.drm_dev, adapter, &current_mode);\n\tif (err) {\n\t\tdrm_err(&i915->drm, \"Error reading LSPCON mode\\n\");\n\t\treturn err;\n\t}\n\n\tif (current_mode == mode) {\n\t\tdrm_dbg_kms(&i915->drm, \"Current mode = desired LSPCON mode\\n\");\n\t\treturn 0;\n\t}\n\n\terr = drm_lspcon_set_mode(intel_dp->aux.drm_dev, adapter, mode);\n\tif (err < 0) {\n\t\tdrm_err(&i915->drm, \"LSPCON mode change failed\\n\");\n\t\treturn err;\n\t}\n\n\tlspcon->mode = mode;\n\tdrm_dbg_kms(&i915->drm, \"LSPCON mode changed done\\n\");\n\treturn 0;\n}\n\nstatic bool lspcon_wake_native_aux_ch(struct intel_lspcon *lspcon)\n{\n\tstruct intel_dp *intel_dp = lspcon_to_intel_dp(lspcon);\n\tstruct drm_i915_private *i915 = dp_to_i915(intel_dp);\n\tu8 rev;\n\n\tif (drm_dp_dpcd_readb(&lspcon_to_intel_dp(lspcon)->aux, DP_DPCD_REV,\n\t\t\t      &rev) != 1) {\n\t\tdrm_dbg_kms(&i915->drm, \"Native AUX CH down\\n\");\n\t\treturn false;\n\t}\n\n\tdrm_dbg_kms(&i915->drm, \"Native AUX CH up, DPCD version: %d.%d\\n\",\n\t\t    rev >> 4, rev & 0xf);\n\n\treturn true;\n}\n\nstatic bool lspcon_probe(struct intel_lspcon *lspcon)\n{\n\tint retry;\n\tenum drm_dp_dual_mode_type adaptor_type;\n\tstruct intel_dp *intel_dp = lspcon_to_intel_dp(lspcon);\n\tstruct drm_i915_private *i915 = dp_to_i915(intel_dp);\n\tstruct i2c_adapter *adapter = &intel_dp->aux.ddc;\n\tenum drm_lspcon_mode expected_mode;\n\n\texpected_mode = lspcon_wake_native_aux_ch(lspcon) ?\n\t\t\tDRM_LSPCON_MODE_PCON : DRM_LSPCON_MODE_LS;\n\n\t \n\tfor (retry = 0; retry < 6; retry++) {\n\t\tif (retry)\n\t\t\tusleep_range(500, 1000);\n\n\t\tadaptor_type = drm_dp_dual_mode_detect(intel_dp->aux.drm_dev, adapter);\n\t\tif (adaptor_type == DRM_DP_DUAL_MODE_LSPCON)\n\t\t\tbreak;\n\t}\n\n\tif (adaptor_type != DRM_DP_DUAL_MODE_LSPCON) {\n\t\tdrm_dbg_kms(&i915->drm, \"No LSPCON detected, found %s\\n\",\n\t\t\t    drm_dp_get_dual_mode_type_name(adaptor_type));\n\t\treturn false;\n\t}\n\n\t \n\tdrm_dbg_kms(&i915->drm, \"LSPCON detected\\n\");\n\tlspcon->mode = lspcon_wait_mode(lspcon, expected_mode);\n\n\t \n\tif (lspcon->mode != DRM_LSPCON_MODE_PCON) {\n\t\tif (lspcon_change_mode(lspcon, DRM_LSPCON_MODE_PCON) < 0) {\n\t\t\tdrm_err(&i915->drm, \"LSPCON mode change to PCON failed\\n\");\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\n\nstatic void lspcon_resume_in_pcon_wa(struct intel_lspcon *lspcon)\n{\n\tstruct intel_dp *intel_dp = lspcon_to_intel_dp(lspcon);\n\tstruct drm_i915_private *i915 = dp_to_i915(intel_dp);\n\tstruct intel_digital_port *dig_port = dp_to_dig_port(intel_dp);\n\tunsigned long start = jiffies;\n\n\twhile (1) {\n\t\tif (intel_digital_port_connected(&dig_port->base)) {\n\t\t\tdrm_dbg_kms(&i915->drm, \"LSPCON recovering in PCON mode after %u ms\\n\",\n\t\t\t\t    jiffies_to_msecs(jiffies - start));\n\t\t\treturn;\n\t\t}\n\n\t\tif (time_after(jiffies, start + msecs_to_jiffies(1000)))\n\t\t\tbreak;\n\n\t\tusleep_range(10000, 15000);\n\t}\n\n\tdrm_dbg_kms(&i915->drm, \"LSPCON DP descriptor mismatch after resume\\n\");\n}\n\nstatic bool lspcon_parade_fw_ready(struct drm_dp_aux *aux)\n{\n\tu8 avi_if_ctrl;\n\tu8 retry;\n\tssize_t ret;\n\n\t \n\tfor (retry = 0; retry < 5; retry++) {\n\t\tif (retry)\n\t\t\tusleep_range(200, 300);\n\n\t\tret = drm_dp_dpcd_read(aux, LSPCON_PARADE_AVI_IF_CTRL,\n\t\t\t\t       &avi_if_ctrl, 1);\n\t\tif (ret < 0) {\n\t\t\tdrm_err(aux->drm_dev, \"Failed to read AVI IF control\\n\");\n\t\t\treturn false;\n\t\t}\n\n\t\tif ((avi_if_ctrl & LSPCON_PARADE_AVI_IF_KICKOFF) == 0)\n\t\t\treturn true;\n\t}\n\n\tdrm_err(aux->drm_dev, \"Parade FW not ready to accept AVI IF\\n\");\n\treturn false;\n}\n\nstatic bool _lspcon_parade_write_infoframe_blocks(struct drm_dp_aux *aux,\n\t\t\t\t\t\t  u8 *avi_buf)\n{\n\tu8 avi_if_ctrl;\n\tu8 block_count = 0;\n\tu8 *data;\n\tu16 reg;\n\tssize_t ret;\n\n\twhile (block_count < 4) {\n\t\tif (!lspcon_parade_fw_ready(aux)) {\n\t\t\tdrm_dbg_kms(aux->drm_dev, \"LSPCON FW not ready, block %d\\n\",\n\t\t\t\t    block_count);\n\t\t\treturn false;\n\t\t}\n\n\t\treg = LSPCON_PARADE_AVI_IF_WRITE_OFFSET;\n\t\tdata = avi_buf + block_count * 8;\n\t\tret = drm_dp_dpcd_write(aux, reg, data, 8);\n\t\tif (ret < 0) {\n\t\t\tdrm_err(aux->drm_dev, \"Failed to write AVI IF block %d\\n\",\n\t\t\t\tblock_count);\n\t\t\treturn false;\n\t\t}\n\n\t\t \n\t\treg = LSPCON_PARADE_AVI_IF_CTRL;\n\t\tavi_if_ctrl = LSPCON_PARADE_AVI_IF_KICKOFF | block_count;\n\t\tret = drm_dp_dpcd_write(aux, reg, &avi_if_ctrl, 1);\n\t\tif (ret < 0) {\n\t\t\tdrm_err(aux->drm_dev, \"Failed to update (0x%x), block %d\\n\",\n\t\t\t\treg, block_count);\n\t\t\treturn false;\n\t\t}\n\n\t\tblock_count++;\n\t}\n\n\tdrm_dbg_kms(aux->drm_dev, \"Wrote AVI IF blocks successfully\\n\");\n\treturn true;\n}\n\nstatic bool _lspcon_write_avi_infoframe_parade(struct drm_dp_aux *aux,\n\t\t\t\t\t       const u8 *frame,\n\t\t\t\t\t       ssize_t len)\n{\n\tu8 avi_if[LSPCON_PARADE_AVI_IF_DATA_SIZE] = {1, };\n\n\t \n\n\tif (len > LSPCON_PARADE_AVI_IF_DATA_SIZE - 1) {\n\t\tdrm_err(aux->drm_dev, \"Invalid length of infoframes\\n\");\n\t\treturn false;\n\t}\n\n\tmemcpy(&avi_if[1], frame, len);\n\n\tif (!_lspcon_parade_write_infoframe_blocks(aux, avi_if)) {\n\t\tdrm_dbg_kms(aux->drm_dev, \"Failed to write infoframe blocks\\n\");\n\t\treturn false;\n\t}\n\n\treturn true;\n}\n\nstatic bool _lspcon_write_avi_infoframe_mca(struct drm_dp_aux *aux,\n\t\t\t\t\t    const u8 *buffer, ssize_t len)\n{\n\tint ret;\n\tu32 val = 0;\n\tu32 retry;\n\tu16 reg;\n\tconst u8 *data = buffer;\n\n\treg = LSPCON_MCA_AVI_IF_WRITE_OFFSET;\n\twhile (val < len) {\n\t\t \n\t\tfor (retry = 0; retry < 5; retry++) {\n\t\t\tret = drm_dp_dpcd_write(aux, reg, (void *)data, 1);\n\t\t\tif (ret == 1) {\n\t\t\t\tbreak;\n\t\t\t} else if (retry < 4) {\n\t\t\t\tmdelay(50);\n\t\t\t\tcontinue;\n\t\t\t} else {\n\t\t\t\tdrm_err(aux->drm_dev, \"DPCD write failed at:0x%x\\n\", reg);\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\tval++; reg++; data++;\n\t}\n\n\tval = 0;\n\treg = LSPCON_MCA_AVI_IF_CTRL;\n\tret = drm_dp_dpcd_read(aux, reg, &val, 1);\n\tif (ret < 0) {\n\t\tdrm_err(aux->drm_dev, \"DPCD read failed, address 0x%x\\n\", reg);\n\t\treturn false;\n\t}\n\n\t \n\tval &= ~LSPCON_MCA_AVI_IF_HANDLED;\n\tval |= LSPCON_MCA_AVI_IF_KICKOFF;\n\n\tret = drm_dp_dpcd_write(aux, reg, &val, 1);\n\tif (ret < 0) {\n\t\tdrm_err(aux->drm_dev, \"DPCD read failed, address 0x%x\\n\", reg);\n\t\treturn false;\n\t}\n\n\tval = 0;\n\tret = drm_dp_dpcd_read(aux, reg, &val, 1);\n\tif (ret < 0) {\n\t\tdrm_err(aux->drm_dev, \"DPCD read failed, address 0x%x\\n\", reg);\n\t\treturn false;\n\t}\n\n\tif (val == LSPCON_MCA_AVI_IF_HANDLED)\n\t\tdrm_dbg_kms(aux->drm_dev, \"AVI IF handled by FW\\n\");\n\n\treturn true;\n}\n\nvoid lspcon_write_infoframe(struct intel_encoder *encoder,\n\t\t\t    const struct intel_crtc_state *crtc_state,\n\t\t\t    unsigned int type,\n\t\t\t    const void *frame, ssize_t len)\n{\n\tbool ret = true;\n\tstruct intel_dp *intel_dp = enc_to_intel_dp(encoder);\n\tstruct drm_i915_private *i915 = dp_to_i915(intel_dp);\n\tstruct intel_lspcon *lspcon = enc_to_intel_lspcon(encoder);\n\n\tswitch (type) {\n\tcase HDMI_INFOFRAME_TYPE_AVI:\n\t\tif (lspcon->vendor == LSPCON_VENDOR_MCA)\n\t\t\tret = _lspcon_write_avi_infoframe_mca(&intel_dp->aux,\n\t\t\t\t\t\t\t      frame, len);\n\t\telse\n\t\t\tret = _lspcon_write_avi_infoframe_parade(&intel_dp->aux,\n\t\t\t\t\t\t\t\t frame, len);\n\t\tbreak;\n\tcase HDMI_PACKET_TYPE_GAMUT_METADATA:\n\t\tdrm_dbg_kms(&i915->drm, \"Update HDR metadata for lspcon\\n\");\n\t\t \n\t\thsw_write_infoframe(encoder, crtc_state, type, frame, len);\n\t\tbreak;\n\tdefault:\n\t\treturn;\n\t}\n\n\tif (!ret) {\n\t\tdrm_err(&i915->drm, \"Failed to write infoframes\\n\");\n\t\treturn;\n\t}\n}\n\nvoid lspcon_read_infoframe(struct intel_encoder *encoder,\n\t\t\t   const struct intel_crtc_state *crtc_state,\n\t\t\t   unsigned int type,\n\t\t\t   void *frame, ssize_t len)\n{\n\t \n\tif (type == HDMI_PACKET_TYPE_GAMUT_METADATA)\n\t\thsw_read_infoframe(encoder, crtc_state, type,\n\t\t\t\t   frame, len);\n}\n\nvoid lspcon_set_infoframes(struct intel_encoder *encoder,\n\t\t\t   bool enable,\n\t\t\t   const struct intel_crtc_state *crtc_state,\n\t\t\t   const struct drm_connector_state *conn_state)\n{\n\tssize_t ret;\n\tunion hdmi_infoframe frame;\n\tu8 buf[VIDEO_DIP_DATA_SIZE];\n\tstruct intel_digital_port *dig_port = enc_to_dig_port(encoder);\n\tstruct intel_lspcon *lspcon = &dig_port->lspcon;\n\tstruct drm_i915_private *i915 = to_i915(encoder->base.dev);\n\tconst struct drm_display_mode *adjusted_mode =\n\t\t&crtc_state->hw.adjusted_mode;\n\n\tif (!lspcon->active) {\n\t\tdrm_err(&i915->drm, \"Writing infoframes while LSPCON disabled ?\\n\");\n\t\treturn;\n\t}\n\n\t \n\n\tret = drm_hdmi_avi_infoframe_from_display_mode(&frame.avi,\n\t\t\t\t\t\t       conn_state->connector,\n\t\t\t\t\t\t       adjusted_mode);\n\tif (ret < 0) {\n\t\tdrm_err(&i915->drm, \"couldn't fill AVI infoframe\\n\");\n\t\treturn;\n\t}\n\n\t \n\tif (crtc_state->output_format == INTEL_OUTPUT_FORMAT_YCBCR444)\n\t\tframe.avi.colorspace = HDMI_COLORSPACE_YUV420;\n\telse\n\t\tframe.avi.colorspace = HDMI_COLORSPACE_RGB;\n\n\t \n\tdrm_hdmi_avi_infoframe_colorimetry(&frame.avi, conn_state);\n\n\t \n\tdrm_WARN_ON(encoder->base.dev, crtc_state->limited_color_range &&\n\t\t    crtc_state->output_format != INTEL_OUTPUT_FORMAT_RGB);\n\n\tif (crtc_state->output_format == INTEL_OUTPUT_FORMAT_RGB) {\n\t\tdrm_hdmi_avi_infoframe_quant_range(&frame.avi,\n\t\t\t\t\t\t   conn_state->connector,\n\t\t\t\t\t\t   adjusted_mode,\n\t\t\t\t\t\t   crtc_state->limited_color_range ?\n\t\t\t\t\t\t   HDMI_QUANTIZATION_RANGE_LIMITED :\n\t\t\t\t\t\t   HDMI_QUANTIZATION_RANGE_FULL);\n\t} else {\n\t\tframe.avi.quantization_range = HDMI_QUANTIZATION_RANGE_DEFAULT;\n\t\tframe.avi.ycc_quantization_range = HDMI_YCC_QUANTIZATION_RANGE_LIMITED;\n\t}\n\n\tdrm_hdmi_avi_infoframe_content_type(&frame.avi, conn_state);\n\n\tret = hdmi_infoframe_pack(&frame, buf, sizeof(buf));\n\tif (ret < 0) {\n\t\tdrm_err(&i915->drm, \"Failed to pack AVI IF\\n\");\n\t\treturn;\n\t}\n\n\tdig_port->write_infoframe(encoder, crtc_state, HDMI_INFOFRAME_TYPE_AVI,\n\t\t\t\t  buf, ret);\n}\n\nstatic bool _lspcon_read_avi_infoframe_enabled_mca(struct drm_dp_aux *aux)\n{\n\tint ret;\n\tu32 val = 0;\n\tu16 reg = LSPCON_MCA_AVI_IF_CTRL;\n\n\tret = drm_dp_dpcd_read(aux, reg, &val, 1);\n\tif (ret < 0) {\n\t\tdrm_err(aux->drm_dev, \"DPCD read failed, address 0x%x\\n\", reg);\n\t\treturn false;\n\t}\n\n\treturn val & LSPCON_MCA_AVI_IF_KICKOFF;\n}\n\nstatic bool _lspcon_read_avi_infoframe_enabled_parade(struct drm_dp_aux *aux)\n{\n\tint ret;\n\tu32 val = 0;\n\tu16 reg = LSPCON_PARADE_AVI_IF_CTRL;\n\n\tret = drm_dp_dpcd_read(aux, reg, &val, 1);\n\tif (ret < 0) {\n\t\tdrm_err(aux->drm_dev, \"DPCD read failed, address 0x%x\\n\", reg);\n\t\treturn false;\n\t}\n\n\treturn val & LSPCON_PARADE_AVI_IF_KICKOFF;\n}\n\nu32 lspcon_infoframes_enabled(struct intel_encoder *encoder,\n\t\t\t      const struct intel_crtc_state *pipe_config)\n{\n\tstruct intel_dp *intel_dp = enc_to_intel_dp(encoder);\n\tstruct intel_lspcon *lspcon = enc_to_intel_lspcon(encoder);\n\tstruct drm_i915_private *dev_priv = to_i915(encoder->base.dev);\n\tbool infoframes_enabled;\n\tu32 val = 0;\n\tu32 mask, tmp;\n\n\tif (lspcon->vendor == LSPCON_VENDOR_MCA)\n\t\tinfoframes_enabled = _lspcon_read_avi_infoframe_enabled_mca(&intel_dp->aux);\n\telse\n\t\tinfoframes_enabled = _lspcon_read_avi_infoframe_enabled_parade(&intel_dp->aux);\n\n\tif (infoframes_enabled)\n\t\tval |= intel_hdmi_infoframe_enable(HDMI_INFOFRAME_TYPE_AVI);\n\n\tif (lspcon->hdr_supported) {\n\t\ttmp = intel_de_read(dev_priv,\n\t\t\t\t    HSW_TVIDEO_DIP_CTL(pipe_config->cpu_transcoder));\n\t\tmask = VIDEO_DIP_ENABLE_GMP_HSW;\n\n\t\tif (tmp & mask)\n\t\t\tval |= intel_hdmi_infoframe_enable(HDMI_PACKET_TYPE_GAMUT_METADATA);\n\t}\n\n\treturn val;\n}\n\nvoid lspcon_wait_pcon_mode(struct intel_lspcon *lspcon)\n{\n\tlspcon_wait_mode(lspcon, DRM_LSPCON_MODE_PCON);\n}\n\nbool lspcon_init(struct intel_digital_port *dig_port)\n{\n\tstruct intel_dp *intel_dp = &dig_port->dp;\n\tstruct intel_lspcon *lspcon = &dig_port->lspcon;\n\tstruct drm_i915_private *i915 = dp_to_i915(intel_dp);\n\tstruct drm_connector *connector = &intel_dp->attached_connector->base;\n\n\tlspcon->active = false;\n\tlspcon->mode = DRM_LSPCON_MODE_INVALID;\n\n\tif (!lspcon_probe(lspcon)) {\n\t\tdrm_err(&i915->drm, \"Failed to probe lspcon\\n\");\n\t\treturn false;\n\t}\n\n\tif (drm_dp_read_dpcd_caps(&intel_dp->aux, intel_dp->dpcd) != 0) {\n\t\tdrm_err(&i915->drm, \"LSPCON DPCD read failed\\n\");\n\t\treturn false;\n\t}\n\n\tif (!lspcon_detect_vendor(lspcon)) {\n\t\tdrm_err(&i915->drm, \"LSPCON vendor detection failed\\n\");\n\t\treturn false;\n\t}\n\n\tconnector->ycbcr_420_allowed = true;\n\tlspcon->active = true;\n\tdrm_dbg_kms(&i915->drm, \"Success: LSPCON init\\n\");\n\treturn true;\n}\n\nu32 intel_lspcon_infoframes_enabled(struct intel_encoder *encoder,\n\t\t\t\t    const struct intel_crtc_state *pipe_config)\n{\n\tstruct intel_digital_port *dig_port = enc_to_dig_port(encoder);\n\n\treturn dig_port->infoframes_enabled(encoder, pipe_config);\n}\n\nvoid lspcon_resume(struct intel_digital_port *dig_port)\n{\n\tstruct intel_lspcon *lspcon = &dig_port->lspcon;\n\tstruct drm_device *dev = dig_port->base.base.dev;\n\tstruct drm_i915_private *i915 = to_i915(dev);\n\tenum drm_lspcon_mode expected_mode;\n\n\tif (!intel_bios_encoder_is_lspcon(dig_port->base.devdata))\n\t\treturn;\n\n\tif (!lspcon->active) {\n\t\tif (!lspcon_init(dig_port)) {\n\t\t\tdrm_err(&i915->drm, \"LSPCON init failed on port %c\\n\",\n\t\t\t\tport_name(dig_port->base.port));\n\t\t\treturn;\n\t\t}\n\t}\n\n\tif (lspcon_wake_native_aux_ch(lspcon)) {\n\t\texpected_mode = DRM_LSPCON_MODE_PCON;\n\t\tlspcon_resume_in_pcon_wa(lspcon);\n\t} else {\n\t\texpected_mode = DRM_LSPCON_MODE_LS;\n\t}\n\n\tif (lspcon_wait_mode(lspcon, expected_mode) == DRM_LSPCON_MODE_PCON)\n\t\treturn;\n\n\tif (lspcon_change_mode(lspcon, DRM_LSPCON_MODE_PCON))\n\t\tdrm_err(&i915->drm, \"LSPCON resume failed\\n\");\n\telse\n\t\tdrm_dbg_kms(&i915->drm, \"LSPCON resume success\\n\");\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}