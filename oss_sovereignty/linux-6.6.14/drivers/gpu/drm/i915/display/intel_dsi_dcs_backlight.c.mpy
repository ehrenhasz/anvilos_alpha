{
  "module_name": "intel_dsi_dcs_backlight.c",
  "hash_id": "c04398d404ae6bfc5b66551bd4006cca02d9e6dfe06956c0ed69e26a207da1ea",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/i915/display/intel_dsi_dcs_backlight.c",
  "human_readable_source": " \n\n#include <drm/drm_mipi_dsi.h>\n#include <video/mipi_display.h>\n\n#include \"i915_drv.h\"\n#include \"intel_display_types.h\"\n#include \"intel_dsi.h\"\n#include \"intel_dsi_dcs_backlight.h\"\n\n#define CONTROL_DISPLAY_BCTRL\t\t(1 << 5)\n#define CONTROL_DISPLAY_DD\t\t(1 << 3)\n#define CONTROL_DISPLAY_BL\t\t(1 << 2)\n\n#define POWER_SAVE_OFF\t\t\t(0 << 0)\n#define POWER_SAVE_LOW\t\t\t(1 << 0)\n#define POWER_SAVE_MEDIUM\t\t(2 << 0)\n#define POWER_SAVE_HIGH\t\t\t(3 << 0)\n#define POWER_SAVE_OUTDOOR_MODE\t\t(4 << 0)\n\n#define PANEL_PWM_MAX_VALUE\t\t0xFF\n\nstatic u32 dcs_get_backlight(struct intel_connector *connector, enum pipe unused)\n{\n\tstruct intel_encoder *encoder = intel_attached_encoder(connector);\n\tstruct intel_dsi *intel_dsi = enc_to_intel_dsi(encoder);\n\tstruct intel_panel *panel = &connector->panel;\n\tstruct mipi_dsi_device *dsi_device;\n\tu8 data[2] = {};\n\tenum port port;\n\tsize_t len = panel->backlight.max > U8_MAX ? 2 : 1;\n\n\tfor_each_dsi_port(port, panel->vbt.dsi.bl_ports) {\n\t\tdsi_device = intel_dsi->dsi_hosts[port]->device;\n\t\tmipi_dsi_dcs_read(dsi_device, MIPI_DCS_GET_DISPLAY_BRIGHTNESS,\n\t\t\t\t  &data, len);\n\t\tbreak;\n\t}\n\n\treturn (data[1] << 8) | data[0];\n}\n\nstatic void dcs_set_backlight(const struct drm_connector_state *conn_state, u32 level)\n{\n\tstruct intel_dsi *intel_dsi = enc_to_intel_dsi(to_intel_encoder(conn_state->best_encoder));\n\tstruct intel_panel *panel = &to_intel_connector(conn_state->connector)->panel;\n\tstruct mipi_dsi_device *dsi_device;\n\tu8 data[2] = {};\n\tenum port port;\n\tsize_t len = panel->backlight.max > U8_MAX ? 2 : 1;\n\tunsigned long mode_flags;\n\n\tif (len == 1) {\n\t\tdata[0] = level;\n\t} else {\n\t\tdata[0] = level >> 8;\n\t\tdata[1] = level;\n\t}\n\n\tfor_each_dsi_port(port, panel->vbt.dsi.bl_ports) {\n\t\tdsi_device = intel_dsi->dsi_hosts[port]->device;\n\t\tmode_flags = dsi_device->mode_flags;\n\t\tdsi_device->mode_flags &= ~MIPI_DSI_MODE_LPM;\n\t\tmipi_dsi_dcs_write(dsi_device, MIPI_DCS_SET_DISPLAY_BRIGHTNESS,\n\t\t\t\t   &data, len);\n\t\tdsi_device->mode_flags = mode_flags;\n\t}\n}\n\nstatic void dcs_disable_backlight(const struct drm_connector_state *conn_state, u32 level)\n{\n\tstruct intel_dsi *intel_dsi = enc_to_intel_dsi(to_intel_encoder(conn_state->best_encoder));\n\tstruct intel_panel *panel = &to_intel_connector(conn_state->connector)->panel;\n\tstruct mipi_dsi_device *dsi_device;\n\tenum port port;\n\n\tdcs_set_backlight(conn_state, 0);\n\n\tfor_each_dsi_port(port, panel->vbt.dsi.cabc_ports) {\n\t\tu8 cabc = POWER_SAVE_OFF;\n\n\t\tdsi_device = intel_dsi->dsi_hosts[port]->device;\n\t\tmipi_dsi_dcs_write(dsi_device, MIPI_DCS_WRITE_POWER_SAVE,\n\t\t\t\t   &cabc, sizeof(cabc));\n\t}\n\n\tfor_each_dsi_port(port, panel->vbt.dsi.bl_ports) {\n\t\tu8 ctrl = 0;\n\n\t\tdsi_device = intel_dsi->dsi_hosts[port]->device;\n\n\t\tmipi_dsi_dcs_read(dsi_device, MIPI_DCS_GET_CONTROL_DISPLAY,\n\t\t\t\t  &ctrl, sizeof(ctrl));\n\n\t\tctrl &= ~CONTROL_DISPLAY_BL;\n\t\tctrl &= ~CONTROL_DISPLAY_DD;\n\t\tctrl &= ~CONTROL_DISPLAY_BCTRL;\n\n\t\tmipi_dsi_dcs_write(dsi_device, MIPI_DCS_WRITE_CONTROL_DISPLAY,\n\t\t\t\t   &ctrl, sizeof(ctrl));\n\t}\n}\n\nstatic void dcs_enable_backlight(const struct intel_crtc_state *crtc_state,\n\t\t\t\t const struct drm_connector_state *conn_state, u32 level)\n{\n\tstruct intel_dsi *intel_dsi = enc_to_intel_dsi(to_intel_encoder(conn_state->best_encoder));\n\tstruct intel_panel *panel = &to_intel_connector(conn_state->connector)->panel;\n\tstruct mipi_dsi_device *dsi_device;\n\tenum port port;\n\n\tfor_each_dsi_port(port, panel->vbt.dsi.bl_ports) {\n\t\tu8 ctrl = 0;\n\n\t\tdsi_device = intel_dsi->dsi_hosts[port]->device;\n\n\t\tmipi_dsi_dcs_read(dsi_device, MIPI_DCS_GET_CONTROL_DISPLAY,\n\t\t\t\t  &ctrl, sizeof(ctrl));\n\n\t\tctrl |= CONTROL_DISPLAY_BL;\n\t\tctrl |= CONTROL_DISPLAY_DD;\n\t\tctrl |= CONTROL_DISPLAY_BCTRL;\n\n\t\tmipi_dsi_dcs_write(dsi_device, MIPI_DCS_WRITE_CONTROL_DISPLAY,\n\t\t\t\t   &ctrl, sizeof(ctrl));\n\t}\n\n\tfor_each_dsi_port(port, panel->vbt.dsi.cabc_ports) {\n\t\tu8 cabc = POWER_SAVE_MEDIUM;\n\n\t\tdsi_device = intel_dsi->dsi_hosts[port]->device;\n\t\tmipi_dsi_dcs_write(dsi_device, MIPI_DCS_WRITE_POWER_SAVE,\n\t\t\t\t   &cabc, sizeof(cabc));\n\t}\n\n\tdcs_set_backlight(conn_state, level);\n}\n\nstatic int dcs_setup_backlight(struct intel_connector *connector,\n\t\t\t       enum pipe unused)\n{\n\tstruct drm_i915_private *i915 = to_i915(connector->base.dev);\n\tstruct intel_panel *panel = &connector->panel;\n\n\tif (panel->vbt.backlight.brightness_precision_bits > 8)\n\t\tpanel->backlight.max = (1 << panel->vbt.backlight.brightness_precision_bits) - 1;\n\telse\n\t\tpanel->backlight.max = PANEL_PWM_MAX_VALUE;\n\n\tpanel->backlight.level = panel->backlight.max;\n\n\tdrm_dbg_kms(&i915->drm,\n\t\t    \"[CONNECTOR:%d:%s] Using DCS for backlight control\\n\",\n\t\t    connector->base.base.id, connector->base.name);\n\n\treturn 0;\n}\n\nstatic const struct intel_panel_bl_funcs dcs_bl_funcs = {\n\t.setup = dcs_setup_backlight,\n\t.enable = dcs_enable_backlight,\n\t.disable = dcs_disable_backlight,\n\t.set = dcs_set_backlight,\n\t.get = dcs_get_backlight,\n};\n\nint intel_dsi_dcs_init_backlight_funcs(struct intel_connector *intel_connector)\n{\n\tstruct drm_device *dev = intel_connector->base.dev;\n\tstruct intel_encoder *encoder = intel_attached_encoder(intel_connector);\n\tstruct intel_panel *panel = &intel_connector->panel;\n\n\tif (panel->vbt.backlight.type != INTEL_BACKLIGHT_DSI_DCS)\n\t\treturn -ENODEV;\n\n\tif (drm_WARN_ON(dev, encoder->type != INTEL_OUTPUT_DSI))\n\t\treturn -EINVAL;\n\n\tpanel->backlight.funcs = &dcs_bl_funcs;\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}