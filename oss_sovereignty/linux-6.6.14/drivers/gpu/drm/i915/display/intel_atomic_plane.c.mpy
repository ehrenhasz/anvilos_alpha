{
  "module_name": "intel_atomic_plane.c",
  "hash_id": "28949dc5232abcec4731167400a1782ce6de3e0b123e0a5298d7de3271bc4489",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/i915/display/intel_atomic_plane.c",
  "human_readable_source": " \n\n \n\n#include <drm/drm_atomic_helper.h>\n#include <drm/drm_blend.h>\n#include <drm/drm_fourcc.h>\n\n#include \"i915_config.h\"\n#include \"i915_reg.h\"\n#include \"intel_atomic_plane.h\"\n#include \"intel_cdclk.h\"\n#include \"intel_display_rps.h\"\n#include \"intel_display_trace.h\"\n#include \"intel_display_types.h\"\n#include \"intel_fb.h\"\n#include \"intel_fb_pin.h\"\n#include \"skl_scaler.h\"\n#include \"skl_watermark.h\"\n\nstatic void intel_plane_state_reset(struct intel_plane_state *plane_state,\n\t\t\t\t    struct intel_plane *plane)\n{\n\tmemset(plane_state, 0, sizeof(*plane_state));\n\n\t__drm_atomic_helper_plane_state_reset(&plane_state->uapi, &plane->base);\n\n\tplane_state->scaler_id = -1;\n}\n\nstruct intel_plane *intel_plane_alloc(void)\n{\n\tstruct intel_plane_state *plane_state;\n\tstruct intel_plane *plane;\n\n\tplane = kzalloc(sizeof(*plane), GFP_KERNEL);\n\tif (!plane)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tplane_state = kzalloc(sizeof(*plane_state), GFP_KERNEL);\n\tif (!plane_state) {\n\t\tkfree(plane);\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\n\tintel_plane_state_reset(plane_state, plane);\n\n\tplane->base.state = &plane_state->uapi;\n\n\treturn plane;\n}\n\nvoid intel_plane_free(struct intel_plane *plane)\n{\n\tintel_plane_destroy_state(&plane->base, plane->base.state);\n\tkfree(plane);\n}\n\n \nstruct drm_plane_state *\nintel_plane_duplicate_state(struct drm_plane *plane)\n{\n\tstruct intel_plane_state *intel_state;\n\n\tintel_state = to_intel_plane_state(plane->state);\n\tintel_state = kmemdup(intel_state, sizeof(*intel_state), GFP_KERNEL);\n\n\tif (!intel_state)\n\t\treturn NULL;\n\n\t__drm_atomic_helper_plane_duplicate_state(plane, &intel_state->uapi);\n\n\tintel_state->ggtt_vma = NULL;\n\tintel_state->dpt_vma = NULL;\n\tintel_state->flags = 0;\n\n\t \n\tif (intel_state->hw.fb)\n\t\tdrm_framebuffer_get(intel_state->hw.fb);\n\n\treturn &intel_state->uapi;\n}\n\n \nvoid\nintel_plane_destroy_state(struct drm_plane *plane,\n\t\t\t  struct drm_plane_state *state)\n{\n\tstruct intel_plane_state *plane_state = to_intel_plane_state(state);\n\n\tdrm_WARN_ON(plane->dev, plane_state->ggtt_vma);\n\tdrm_WARN_ON(plane->dev, plane_state->dpt_vma);\n\n\t__drm_atomic_helper_plane_destroy_state(&plane_state->uapi);\n\tif (plane_state->hw.fb)\n\t\tdrm_framebuffer_put(plane_state->hw.fb);\n\tkfree(plane_state);\n}\n\nunsigned int intel_adjusted_rate(const struct drm_rect *src,\n\t\t\t\t const struct drm_rect *dst,\n\t\t\t\t unsigned int rate)\n{\n\tunsigned int src_w, src_h, dst_w, dst_h;\n\n\tsrc_w = drm_rect_width(src) >> 16;\n\tsrc_h = drm_rect_height(src) >> 16;\n\tdst_w = drm_rect_width(dst);\n\tdst_h = drm_rect_height(dst);\n\n\t \n\tdst_w = min(src_w, dst_w);\n\tdst_h = min(src_h, dst_h);\n\n\treturn DIV_ROUND_UP_ULL(mul_u32_u32(rate, src_w * src_h),\n\t\t\t\tdst_w * dst_h);\n}\n\nunsigned int intel_plane_pixel_rate(const struct intel_crtc_state *crtc_state,\n\t\t\t\t    const struct intel_plane_state *plane_state)\n{\n\t \n\n\treturn intel_adjusted_rate(&plane_state->uapi.src,\n\t\t\t\t   &plane_state->uapi.dst,\n\t\t\t\t   crtc_state->pixel_rate);\n}\n\nunsigned int intel_plane_data_rate(const struct intel_crtc_state *crtc_state,\n\t\t\t\t   const struct intel_plane_state *plane_state,\n\t\t\t\t   int color_plane)\n{\n\tconst struct drm_framebuffer *fb = plane_state->hw.fb;\n\n\tif (!plane_state->uapi.visible)\n\t\treturn 0;\n\n\treturn intel_plane_pixel_rate(crtc_state, plane_state) *\n\t\tfb->format->cpp[color_plane];\n}\n\nstatic bool\nuse_min_ddb(const struct intel_crtc_state *crtc_state,\n\t    struct intel_plane *plane)\n{\n\tstruct drm_i915_private *i915 = to_i915(plane->base.dev);\n\n\treturn DISPLAY_VER(i915) >= 13 &&\n\t       crtc_state->uapi.async_flip &&\n\t       plane->async_flip;\n}\n\nstatic unsigned int\nintel_plane_relative_data_rate(const struct intel_crtc_state *crtc_state,\n\t\t\t       const struct intel_plane_state *plane_state,\n\t\t\t       int color_plane)\n{\n\tstruct intel_plane *plane = to_intel_plane(plane_state->uapi.plane);\n\tconst struct drm_framebuffer *fb = plane_state->hw.fb;\n\tint width, height;\n\tunsigned int rel_data_rate;\n\n\tif (plane->id == PLANE_CURSOR)\n\t\treturn 0;\n\n\tif (!plane_state->uapi.visible)\n\t\treturn 0;\n\n\t \n\tif (use_min_ddb(crtc_state, plane))\n\t\treturn 0;\n\n\t \n\twidth = drm_rect_width(&plane_state->uapi.src) >> 16;\n\theight = drm_rect_height(&plane_state->uapi.src) >> 16;\n\n\t \n\tif (color_plane == 1) {\n\t\twidth /= 2;\n\t\theight /= 2;\n\t}\n\n\trel_data_rate = width * height * fb->format->cpp[color_plane];\n\n\treturn intel_adjusted_rate(&plane_state->uapi.src,\n\t\t\t\t   &plane_state->uapi.dst,\n\t\t\t\t   rel_data_rate);\n}\n\nint intel_plane_calc_min_cdclk(struct intel_atomic_state *state,\n\t\t\t       struct intel_plane *plane,\n\t\t\t       bool *need_cdclk_calc)\n{\n\tstruct drm_i915_private *dev_priv = to_i915(plane->base.dev);\n\tconst struct intel_plane_state *plane_state =\n\t\tintel_atomic_get_new_plane_state(state, plane);\n\tstruct intel_crtc *crtc = to_intel_crtc(plane_state->hw.crtc);\n\tconst struct intel_cdclk_state *cdclk_state;\n\tconst struct intel_crtc_state *old_crtc_state;\n\tstruct intel_crtc_state *new_crtc_state;\n\n\tif (!plane_state->uapi.visible || !plane->min_cdclk)\n\t\treturn 0;\n\n\told_crtc_state = intel_atomic_get_old_crtc_state(state, crtc);\n\tnew_crtc_state = intel_atomic_get_new_crtc_state(state, crtc);\n\n\tnew_crtc_state->min_cdclk[plane->id] =\n\t\tplane->min_cdclk(new_crtc_state, plane_state);\n\n\t \n\tif (new_crtc_state->min_cdclk[plane->id] <=\n\t    old_crtc_state->min_cdclk[plane->id])\n\t\treturn 0;\n\n\tcdclk_state = intel_atomic_get_cdclk_state(state);\n\tif (IS_ERR(cdclk_state))\n\t\treturn PTR_ERR(cdclk_state);\n\n\t \n\tif (new_crtc_state->min_cdclk[plane->id] <=\n\t    cdclk_state->min_cdclk[crtc->pipe])\n\t\treturn 0;\n\n\tdrm_dbg_kms(&dev_priv->drm,\n\t\t    \"[PLANE:%d:%s] min cdclk (%d kHz) > [CRTC:%d:%s] min cdclk (%d kHz)\\n\",\n\t\t    plane->base.base.id, plane->base.name,\n\t\t    new_crtc_state->min_cdclk[plane->id],\n\t\t    crtc->base.base.id, crtc->base.name,\n\t\t    cdclk_state->min_cdclk[crtc->pipe]);\n\t*need_cdclk_calc = true;\n\n\treturn 0;\n}\n\nstatic void intel_plane_clear_hw_state(struct intel_plane_state *plane_state)\n{\n\tif (plane_state->hw.fb)\n\t\tdrm_framebuffer_put(plane_state->hw.fb);\n\n\tmemset(&plane_state->hw, 0, sizeof(plane_state->hw));\n}\n\nvoid intel_plane_copy_uapi_to_hw_state(struct intel_plane_state *plane_state,\n\t\t\t\t       const struct intel_plane_state *from_plane_state,\n\t\t\t\t       struct intel_crtc *crtc)\n{\n\tintel_plane_clear_hw_state(plane_state);\n\n\t \n\tplane_state->hw.crtc = from_plane_state->uapi.crtc ? &crtc->base : NULL;\n\n\tplane_state->hw.fb = from_plane_state->uapi.fb;\n\tif (plane_state->hw.fb)\n\t\tdrm_framebuffer_get(plane_state->hw.fb);\n\n\tplane_state->hw.alpha = from_plane_state->uapi.alpha;\n\tplane_state->hw.pixel_blend_mode =\n\t\tfrom_plane_state->uapi.pixel_blend_mode;\n\tplane_state->hw.rotation = from_plane_state->uapi.rotation;\n\tplane_state->hw.color_encoding = from_plane_state->uapi.color_encoding;\n\tplane_state->hw.color_range = from_plane_state->uapi.color_range;\n\tplane_state->hw.scaling_filter = from_plane_state->uapi.scaling_filter;\n\n\tplane_state->uapi.src = drm_plane_state_src(&from_plane_state->uapi);\n\tplane_state->uapi.dst = drm_plane_state_dest(&from_plane_state->uapi);\n}\n\nvoid intel_plane_copy_hw_state(struct intel_plane_state *plane_state,\n\t\t\t       const struct intel_plane_state *from_plane_state)\n{\n\tintel_plane_clear_hw_state(plane_state);\n\n\tmemcpy(&plane_state->hw, &from_plane_state->hw,\n\t       sizeof(plane_state->hw));\n\n\tif (plane_state->hw.fb)\n\t\tdrm_framebuffer_get(plane_state->hw.fb);\n}\n\nvoid intel_plane_set_invisible(struct intel_crtc_state *crtc_state,\n\t\t\t       struct intel_plane_state *plane_state)\n{\n\tstruct intel_plane *plane = to_intel_plane(plane_state->uapi.plane);\n\n\tcrtc_state->active_planes &= ~BIT(plane->id);\n\tcrtc_state->scaled_planes &= ~BIT(plane->id);\n\tcrtc_state->nv12_planes &= ~BIT(plane->id);\n\tcrtc_state->c8_planes &= ~BIT(plane->id);\n\tcrtc_state->async_flip_planes &= ~BIT(plane->id);\n\tcrtc_state->data_rate[plane->id] = 0;\n\tcrtc_state->data_rate_y[plane->id] = 0;\n\tcrtc_state->rel_data_rate[plane->id] = 0;\n\tcrtc_state->rel_data_rate_y[plane->id] = 0;\n\tcrtc_state->min_cdclk[plane->id] = 0;\n\n\tplane_state->uapi.visible = false;\n}\n\n \nstatic bool intel_wm_need_update(const struct intel_plane_state *cur,\n\t\t\t\t struct intel_plane_state *new)\n{\n\t \n\tif (new->uapi.visible != cur->uapi.visible)\n\t\treturn true;\n\n\tif (!cur->hw.fb || !new->hw.fb)\n\t\treturn false;\n\n\tif (cur->hw.fb->modifier != new->hw.fb->modifier ||\n\t    cur->hw.rotation != new->hw.rotation ||\n\t    drm_rect_width(&new->uapi.src) != drm_rect_width(&cur->uapi.src) ||\n\t    drm_rect_height(&new->uapi.src) != drm_rect_height(&cur->uapi.src) ||\n\t    drm_rect_width(&new->uapi.dst) != drm_rect_width(&cur->uapi.dst) ||\n\t    drm_rect_height(&new->uapi.dst) != drm_rect_height(&cur->uapi.dst))\n\t\treturn true;\n\n\treturn false;\n}\n\nstatic bool intel_plane_is_scaled(const struct intel_plane_state *plane_state)\n{\n\tint src_w = drm_rect_width(&plane_state->uapi.src) >> 16;\n\tint src_h = drm_rect_height(&plane_state->uapi.src) >> 16;\n\tint dst_w = drm_rect_width(&plane_state->uapi.dst);\n\tint dst_h = drm_rect_height(&plane_state->uapi.dst);\n\n\treturn src_w != dst_w || src_h != dst_h;\n}\n\nstatic bool intel_plane_do_async_flip(struct intel_plane *plane,\n\t\t\t\t      const struct intel_crtc_state *old_crtc_state,\n\t\t\t\t      const struct intel_crtc_state *new_crtc_state)\n{\n\tstruct drm_i915_private *i915 = to_i915(plane->base.dev);\n\n\tif (!plane->async_flip)\n\t\treturn false;\n\n\tif (!new_crtc_state->uapi.async_flip)\n\t\treturn false;\n\n\t \n\treturn DISPLAY_VER(i915) < 13 || old_crtc_state->uapi.async_flip;\n}\n\nstatic bool i9xx_must_disable_cxsr(const struct intel_crtc_state *new_crtc_state,\n\t\t\t\t   const struct intel_plane_state *old_plane_state,\n\t\t\t\t   const struct intel_plane_state *new_plane_state)\n{\n\tstruct intel_plane *plane = to_intel_plane(new_plane_state->uapi.plane);\n\tbool old_visible = old_plane_state->uapi.visible;\n\tbool new_visible = new_plane_state->uapi.visible;\n\tu32 old_ctl = old_plane_state->ctl;\n\tu32 new_ctl = new_plane_state->ctl;\n\tbool modeset, turn_on, turn_off;\n\n\tif (plane->id == PLANE_CURSOR)\n\t\treturn false;\n\n\tmodeset = intel_crtc_needs_modeset(new_crtc_state);\n\tturn_off = old_visible && (!new_visible || modeset);\n\tturn_on = new_visible && (!old_visible || modeset);\n\n\t \n\tif (turn_on || turn_off)\n\t\treturn true;\n\n\tif (!old_visible || !new_visible)\n\t\treturn false;\n\n\t \n\tif (plane->id == PLANE_PRIMARY) {\n\t\told_ctl &= ~DISP_TILED;\n\t\tnew_ctl &= ~DISP_TILED;\n\t}\n\n\treturn old_ctl != new_ctl;\n}\n\nstatic int intel_plane_atomic_calc_changes(const struct intel_crtc_state *old_crtc_state,\n\t\t\t\t\t   struct intel_crtc_state *new_crtc_state,\n\t\t\t\t\t   const struct intel_plane_state *old_plane_state,\n\t\t\t\t\t   struct intel_plane_state *new_plane_state)\n{\n\tstruct intel_crtc *crtc = to_intel_crtc(new_crtc_state->uapi.crtc);\n\tstruct intel_plane *plane = to_intel_plane(new_plane_state->uapi.plane);\n\tstruct drm_i915_private *dev_priv = to_i915(crtc->base.dev);\n\tbool mode_changed = intel_crtc_needs_modeset(new_crtc_state);\n\tbool was_crtc_enabled = old_crtc_state->hw.active;\n\tbool is_crtc_enabled = new_crtc_state->hw.active;\n\tbool turn_off, turn_on, visible, was_visible;\n\tint ret;\n\n\tif (DISPLAY_VER(dev_priv) >= 9 && plane->id != PLANE_CURSOR) {\n\t\tret = skl_update_scaler_plane(new_crtc_state, new_plane_state);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\twas_visible = old_plane_state->uapi.visible;\n\tvisible = new_plane_state->uapi.visible;\n\n\tif (!was_crtc_enabled && drm_WARN_ON(&dev_priv->drm, was_visible))\n\t\twas_visible = false;\n\n\t \n\tif (!is_crtc_enabled) {\n\t\tintel_plane_set_invisible(new_crtc_state, new_plane_state);\n\t\tvisible = false;\n\t}\n\n\tif (!was_visible && !visible)\n\t\treturn 0;\n\n\tturn_off = was_visible && (!visible || mode_changed);\n\tturn_on = visible && (!was_visible || mode_changed);\n\n\tdrm_dbg_atomic(&dev_priv->drm,\n\t\t       \"[CRTC:%d:%s] with [PLANE:%d:%s] visible %i -> %i, off %i, on %i, ms %i\\n\",\n\t\t       crtc->base.base.id, crtc->base.name,\n\t\t       plane->base.base.id, plane->base.name,\n\t\t       was_visible, visible,\n\t\t       turn_off, turn_on, mode_changed);\n\n\tif (turn_on) {\n\t\tif (DISPLAY_VER(dev_priv) < 5 && !IS_G4X(dev_priv))\n\t\t\tnew_crtc_state->update_wm_pre = true;\n\t} else if (turn_off) {\n\t\tif (DISPLAY_VER(dev_priv) < 5 && !IS_G4X(dev_priv))\n\t\t\tnew_crtc_state->update_wm_post = true;\n\t} else if (intel_wm_need_update(old_plane_state, new_plane_state)) {\n\t\tif (DISPLAY_VER(dev_priv) < 5 && !IS_G4X(dev_priv)) {\n\t\t\t \n\t\t\tnew_crtc_state->update_wm_pre = true;\n\t\t\tnew_crtc_state->update_wm_post = true;\n\t\t}\n\t}\n\n\tif (visible || was_visible)\n\t\tnew_crtc_state->fb_bits |= plane->frontbuffer_bit;\n\n\tif (HAS_GMCH(dev_priv) &&\n\t    i9xx_must_disable_cxsr(new_crtc_state, old_plane_state, new_plane_state))\n\t\tnew_crtc_state->disable_cxsr = true;\n\n\t \n\tif (plane->id != PLANE_CURSOR &&\n\t    (IS_IRONLAKE(dev_priv) || IS_SANDYBRIDGE(dev_priv) ||\n\t     IS_IVYBRIDGE(dev_priv)) &&\n\t    (turn_on || (!intel_plane_is_scaled(old_plane_state) &&\n\t\t\t intel_plane_is_scaled(new_plane_state))))\n\t\tnew_crtc_state->disable_lp_wm = true;\n\n\tif (intel_plane_do_async_flip(plane, old_crtc_state, new_crtc_state)) {\n\t\tnew_crtc_state->do_async_flip = true;\n\t\tnew_crtc_state->async_flip_planes |= BIT(plane->id);\n\t}\n\n\treturn 0;\n}\n\nint intel_plane_atomic_check_with_state(const struct intel_crtc_state *old_crtc_state,\n\t\t\t\t\tstruct intel_crtc_state *new_crtc_state,\n\t\t\t\t\tconst struct intel_plane_state *old_plane_state,\n\t\t\t\t\tstruct intel_plane_state *new_plane_state)\n{\n\tstruct intel_plane *plane = to_intel_plane(new_plane_state->uapi.plane);\n\tconst struct drm_framebuffer *fb = new_plane_state->hw.fb;\n\tint ret;\n\n\tintel_plane_set_invisible(new_crtc_state, new_plane_state);\n\tnew_crtc_state->enabled_planes &= ~BIT(plane->id);\n\n\tif (!new_plane_state->hw.crtc && !old_plane_state->hw.crtc)\n\t\treturn 0;\n\n\tret = plane->check_plane(new_crtc_state, new_plane_state);\n\tif (ret)\n\t\treturn ret;\n\n\tif (fb)\n\t\tnew_crtc_state->enabled_planes |= BIT(plane->id);\n\n\t \n\tif (new_plane_state->uapi.visible)\n\t\tnew_crtc_state->active_planes |= BIT(plane->id);\n\n\tif (new_plane_state->uapi.visible &&\n\t    intel_plane_is_scaled(new_plane_state))\n\t\tnew_crtc_state->scaled_planes |= BIT(plane->id);\n\n\tif (new_plane_state->uapi.visible &&\n\t    intel_format_info_is_yuv_semiplanar(fb->format, fb->modifier))\n\t\tnew_crtc_state->nv12_planes |= BIT(plane->id);\n\n\tif (new_plane_state->uapi.visible &&\n\t    fb->format->format == DRM_FORMAT_C8)\n\t\tnew_crtc_state->c8_planes |= BIT(plane->id);\n\n\tif (new_plane_state->uapi.visible || old_plane_state->uapi.visible)\n\t\tnew_crtc_state->update_planes |= BIT(plane->id);\n\n\tif (new_plane_state->uapi.visible &&\n\t    intel_format_info_is_yuv_semiplanar(fb->format, fb->modifier)) {\n\t\tnew_crtc_state->data_rate_y[plane->id] =\n\t\t\tintel_plane_data_rate(new_crtc_state, new_plane_state, 0);\n\t\tnew_crtc_state->data_rate[plane->id] =\n\t\t\tintel_plane_data_rate(new_crtc_state, new_plane_state, 1);\n\n\t\tnew_crtc_state->rel_data_rate_y[plane->id] =\n\t\t\tintel_plane_relative_data_rate(new_crtc_state,\n\t\t\t\t\t\t       new_plane_state, 0);\n\t\tnew_crtc_state->rel_data_rate[plane->id] =\n\t\t\tintel_plane_relative_data_rate(new_crtc_state,\n\t\t\t\t\t\t       new_plane_state, 1);\n\t} else if (new_plane_state->uapi.visible) {\n\t\tnew_crtc_state->data_rate[plane->id] =\n\t\t\tintel_plane_data_rate(new_crtc_state, new_plane_state, 0);\n\n\t\tnew_crtc_state->rel_data_rate[plane->id] =\n\t\t\tintel_plane_relative_data_rate(new_crtc_state,\n\t\t\t\t\t\t       new_plane_state, 0);\n\t}\n\n\treturn intel_plane_atomic_calc_changes(old_crtc_state, new_crtc_state,\n\t\t\t\t\t       old_plane_state, new_plane_state);\n}\n\nstatic struct intel_plane *\nintel_crtc_get_plane(struct intel_crtc *crtc, enum plane_id plane_id)\n{\n\tstruct drm_i915_private *i915 = to_i915(crtc->base.dev);\n\tstruct intel_plane *plane;\n\n\tfor_each_intel_plane_on_crtc(&i915->drm, crtc, plane) {\n\t\tif (plane->id == plane_id)\n\t\t\treturn plane;\n\t}\n\n\treturn NULL;\n}\n\nint intel_plane_atomic_check(struct intel_atomic_state *state,\n\t\t\t     struct intel_plane *plane)\n{\n\tstruct drm_i915_private *i915 = to_i915(state->base.dev);\n\tstruct intel_plane_state *new_plane_state =\n\t\tintel_atomic_get_new_plane_state(state, plane);\n\tconst struct intel_plane_state *old_plane_state =\n\t\tintel_atomic_get_old_plane_state(state, plane);\n\tconst struct intel_plane_state *new_master_plane_state;\n\tstruct intel_crtc *crtc = intel_crtc_for_pipe(i915, plane->pipe);\n\tconst struct intel_crtc_state *old_crtc_state =\n\t\tintel_atomic_get_old_crtc_state(state, crtc);\n\tstruct intel_crtc_state *new_crtc_state =\n\t\tintel_atomic_get_new_crtc_state(state, crtc);\n\n\tif (new_crtc_state && intel_crtc_is_bigjoiner_slave(new_crtc_state)) {\n\t\tstruct intel_crtc *master_crtc =\n\t\t\tintel_master_crtc(new_crtc_state);\n\t\tstruct intel_plane *master_plane =\n\t\t\tintel_crtc_get_plane(master_crtc, plane->id);\n\n\t\tnew_master_plane_state =\n\t\t\tintel_atomic_get_new_plane_state(state, master_plane);\n\t} else {\n\t\tnew_master_plane_state = new_plane_state;\n\t}\n\n\tintel_plane_copy_uapi_to_hw_state(new_plane_state,\n\t\t\t\t\t  new_master_plane_state,\n\t\t\t\t\t  crtc);\n\n\tnew_plane_state->uapi.visible = false;\n\tif (!new_crtc_state)\n\t\treturn 0;\n\n\treturn intel_plane_atomic_check_with_state(old_crtc_state,\n\t\t\t\t\t\t   new_crtc_state,\n\t\t\t\t\t\t   old_plane_state,\n\t\t\t\t\t\t   new_plane_state);\n}\n\nstatic struct intel_plane *\nskl_next_plane_to_commit(struct intel_atomic_state *state,\n\t\t\t struct intel_crtc *crtc,\n\t\t\t struct skl_ddb_entry ddb[I915_MAX_PLANES],\n\t\t\t struct skl_ddb_entry ddb_y[I915_MAX_PLANES],\n\t\t\t unsigned int *update_mask)\n{\n\tstruct intel_crtc_state *crtc_state =\n\t\tintel_atomic_get_new_crtc_state(state, crtc);\n\tstruct intel_plane_state __maybe_unused *plane_state;\n\tstruct intel_plane *plane;\n\tint i;\n\n\tif (*update_mask == 0)\n\t\treturn NULL;\n\n\tfor_each_new_intel_plane_in_state(state, plane, plane_state, i) {\n\t\tenum plane_id plane_id = plane->id;\n\n\t\tif (crtc->pipe != plane->pipe ||\n\t\t    !(*update_mask & BIT(plane_id)))\n\t\t\tcontinue;\n\n\t\tif (skl_ddb_allocation_overlaps(&crtc_state->wm.skl.plane_ddb[plane_id],\n\t\t\t\t\t\tddb, I915_MAX_PLANES, plane_id) ||\n\t\t    skl_ddb_allocation_overlaps(&crtc_state->wm.skl.plane_ddb_y[plane_id],\n\t\t\t\t\t\tddb_y, I915_MAX_PLANES, plane_id))\n\t\t\tcontinue;\n\n\t\t*update_mask &= ~BIT(plane_id);\n\t\tddb[plane_id] = crtc_state->wm.skl.plane_ddb[plane_id];\n\t\tddb_y[plane_id] = crtc_state->wm.skl.plane_ddb_y[plane_id];\n\n\t\treturn plane;\n\t}\n\n\t \n\tdrm_WARN_ON(state->base.dev, 1);\n\n\treturn NULL;\n}\n\nvoid intel_plane_update_noarm(struct intel_plane *plane,\n\t\t\t      const struct intel_crtc_state *crtc_state,\n\t\t\t      const struct intel_plane_state *plane_state)\n{\n\tstruct intel_crtc *crtc = to_intel_crtc(crtc_state->uapi.crtc);\n\n\ttrace_intel_plane_update_noarm(plane, crtc);\n\n\tif (plane->update_noarm)\n\t\tplane->update_noarm(plane, crtc_state, plane_state);\n}\n\nvoid intel_plane_update_arm(struct intel_plane *plane,\n\t\t\t    const struct intel_crtc_state *crtc_state,\n\t\t\t    const struct intel_plane_state *plane_state)\n{\n\tstruct intel_crtc *crtc = to_intel_crtc(crtc_state->uapi.crtc);\n\n\ttrace_intel_plane_update_arm(plane, crtc);\n\n\tif (crtc_state->do_async_flip && plane->async_flip)\n\t\tplane->async_flip(plane, crtc_state, plane_state, true);\n\telse\n\t\tplane->update_arm(plane, crtc_state, plane_state);\n}\n\nvoid intel_plane_disable_arm(struct intel_plane *plane,\n\t\t\t     const struct intel_crtc_state *crtc_state)\n{\n\tstruct intel_crtc *crtc = to_intel_crtc(crtc_state->uapi.crtc);\n\n\ttrace_intel_plane_disable_arm(plane, crtc);\n\tplane->disable_arm(plane, crtc_state);\n}\n\nvoid intel_crtc_planes_update_noarm(struct intel_atomic_state *state,\n\t\t\t\t    struct intel_crtc *crtc)\n{\n\tstruct intel_crtc_state *new_crtc_state =\n\t\tintel_atomic_get_new_crtc_state(state, crtc);\n\tu32 update_mask = new_crtc_state->update_planes;\n\tstruct intel_plane_state *new_plane_state;\n\tstruct intel_plane *plane;\n\tint i;\n\n\tif (new_crtc_state->do_async_flip)\n\t\treturn;\n\n\t \n\tfor_each_new_intel_plane_in_state(state, plane, new_plane_state, i) {\n\t\tif (crtc->pipe != plane->pipe ||\n\t\t    !(update_mask & BIT(plane->id)))\n\t\t\tcontinue;\n\n\t\t \n\t\tif (new_plane_state->uapi.visible ||\n\t\t    new_plane_state->planar_slave)\n\t\t\tintel_plane_update_noarm(plane, new_crtc_state, new_plane_state);\n\t}\n}\n\nstatic void skl_crtc_planes_update_arm(struct intel_atomic_state *state,\n\t\t\t\t       struct intel_crtc *crtc)\n{\n\tstruct intel_crtc_state *old_crtc_state =\n\t\tintel_atomic_get_old_crtc_state(state, crtc);\n\tstruct intel_crtc_state *new_crtc_state =\n\t\tintel_atomic_get_new_crtc_state(state, crtc);\n\tstruct skl_ddb_entry ddb[I915_MAX_PLANES];\n\tstruct skl_ddb_entry ddb_y[I915_MAX_PLANES];\n\tu32 update_mask = new_crtc_state->update_planes;\n\tstruct intel_plane *plane;\n\n\tmemcpy(ddb, old_crtc_state->wm.skl.plane_ddb,\n\t       sizeof(old_crtc_state->wm.skl.plane_ddb));\n\tmemcpy(ddb_y, old_crtc_state->wm.skl.plane_ddb_y,\n\t       sizeof(old_crtc_state->wm.skl.plane_ddb_y));\n\n\twhile ((plane = skl_next_plane_to_commit(state, crtc, ddb, ddb_y, &update_mask))) {\n\t\tstruct intel_plane_state *new_plane_state =\n\t\t\tintel_atomic_get_new_plane_state(state, plane);\n\n\t\t \n\t\tif (new_plane_state->uapi.visible ||\n\t\t    new_plane_state->planar_slave)\n\t\t\tintel_plane_update_arm(plane, new_crtc_state, new_plane_state);\n\t\telse\n\t\t\tintel_plane_disable_arm(plane, new_crtc_state);\n\t}\n}\n\nstatic void i9xx_crtc_planes_update_arm(struct intel_atomic_state *state,\n\t\t\t\t\tstruct intel_crtc *crtc)\n{\n\tstruct intel_crtc_state *new_crtc_state =\n\t\tintel_atomic_get_new_crtc_state(state, crtc);\n\tu32 update_mask = new_crtc_state->update_planes;\n\tstruct intel_plane_state *new_plane_state;\n\tstruct intel_plane *plane;\n\tint i;\n\n\tfor_each_new_intel_plane_in_state(state, plane, new_plane_state, i) {\n\t\tif (crtc->pipe != plane->pipe ||\n\t\t    !(update_mask & BIT(plane->id)))\n\t\t\tcontinue;\n\n\t\t \n\t\tif (new_plane_state->uapi.visible)\n\t\t\tintel_plane_update_arm(plane, new_crtc_state, new_plane_state);\n\t\telse\n\t\t\tintel_plane_disable_arm(plane, new_crtc_state);\n\t}\n}\n\nvoid intel_crtc_planes_update_arm(struct intel_atomic_state *state,\n\t\t\t\t  struct intel_crtc *crtc)\n{\n\tstruct drm_i915_private *i915 = to_i915(state->base.dev);\n\n\tif (DISPLAY_VER(i915) >= 9)\n\t\tskl_crtc_planes_update_arm(state, crtc);\n\telse\n\t\ti9xx_crtc_planes_update_arm(state, crtc);\n}\n\nint intel_atomic_plane_check_clipping(struct intel_plane_state *plane_state,\n\t\t\t\t      struct intel_crtc_state *crtc_state,\n\t\t\t\t      int min_scale, int max_scale,\n\t\t\t\t      bool can_position)\n{\n\tstruct drm_i915_private *i915 = to_i915(plane_state->uapi.plane->dev);\n\tstruct drm_framebuffer *fb = plane_state->hw.fb;\n\tstruct drm_rect *src = &plane_state->uapi.src;\n\tstruct drm_rect *dst = &plane_state->uapi.dst;\n\tconst struct drm_rect *clip = &crtc_state->pipe_src;\n\tunsigned int rotation = plane_state->hw.rotation;\n\tint hscale, vscale;\n\n\tif (!fb) {\n\t\tplane_state->uapi.visible = false;\n\t\treturn 0;\n\t}\n\n\tdrm_rect_rotate(src, fb->width << 16, fb->height << 16, rotation);\n\n\t \n\thscale = drm_rect_calc_hscale(src, dst, min_scale, max_scale);\n\tvscale = drm_rect_calc_vscale(src, dst, min_scale, max_scale);\n\tif (hscale < 0 || vscale < 0) {\n\t\tdrm_dbg_kms(&i915->drm, \"Invalid scaling of plane\\n\");\n\t\tdrm_rect_debug_print(\"src: \", src, true);\n\t\tdrm_rect_debug_print(\"dst: \", dst, false);\n\t\treturn -ERANGE;\n\t}\n\n\t \n\tplane_state->uapi.visible = drm_rect_clip_scaled(src, dst, clip);\n\n\tdrm_rect_rotate_inv(src, fb->width << 16, fb->height << 16, rotation);\n\n\tif (!can_position && plane_state->uapi.visible &&\n\t    !drm_rect_equals(dst, clip)) {\n\t\tdrm_dbg_kms(&i915->drm, \"Plane must cover entire CRTC\\n\");\n\t\tdrm_rect_debug_print(\"dst: \", dst, false);\n\t\tdrm_rect_debug_print(\"clip: \", clip, false);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tdrm_rect_translate(dst, -clip->x1, -clip->y1);\n\n\treturn 0;\n}\n\nint intel_plane_check_src_coordinates(struct intel_plane_state *plane_state)\n{\n\tstruct drm_i915_private *i915 = to_i915(plane_state->uapi.plane->dev);\n\tconst struct drm_framebuffer *fb = plane_state->hw.fb;\n\tstruct drm_rect *src = &plane_state->uapi.src;\n\tu32 src_x, src_y, src_w, src_h, hsub, vsub;\n\tbool rotated = drm_rotation_90_or_270(plane_state->hw.rotation);\n\n\t \n\tif (fb->modifier == I915_FORMAT_MOD_Y_TILED_CCS ||\n\t    fb->modifier == I915_FORMAT_MOD_Yf_TILED_CCS)\n\t\treturn 0;\n\n\t \n\tsrc_x = src->x1 >> 16;\n\tsrc_w = drm_rect_width(src) >> 16;\n\tsrc_y = src->y1 >> 16;\n\tsrc_h = drm_rect_height(src) >> 16;\n\n\tdrm_rect_init(src, src_x << 16, src_y << 16,\n\t\t      src_w << 16, src_h << 16);\n\n\tif (fb->format->format == DRM_FORMAT_RGB565 && rotated) {\n\t\thsub = 2;\n\t\tvsub = 2;\n\t} else {\n\t\thsub = fb->format->hsub;\n\t\tvsub = fb->format->vsub;\n\t}\n\n\tif (rotated)\n\t\thsub = vsub = max(hsub, vsub);\n\n\tif (src_x % hsub || src_w % hsub) {\n\t\tdrm_dbg_kms(&i915->drm, \"src x/w (%u, %u) must be a multiple of %u (rotated: %s)\\n\",\n\t\t\t    src_x, src_w, hsub, str_yes_no(rotated));\n\t\treturn -EINVAL;\n\t}\n\n\tif (src_y % vsub || src_h % vsub) {\n\t\tdrm_dbg_kms(&i915->drm, \"src y/h (%u, %u) must be a multiple of %u (rotated: %s)\\n\",\n\t\t\t    src_y, src_h, vsub, str_yes_no(rotated));\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int\nintel_prepare_plane_fb(struct drm_plane *_plane,\n\t\t       struct drm_plane_state *_new_plane_state)\n{\n\tstruct i915_sched_attr attr = { .priority = I915_PRIORITY_DISPLAY };\n\tstruct intel_plane *plane = to_intel_plane(_plane);\n\tstruct intel_plane_state *new_plane_state =\n\t\tto_intel_plane_state(_new_plane_state);\n\tstruct intel_atomic_state *state =\n\t\tto_intel_atomic_state(new_plane_state->uapi.state);\n\tstruct drm_i915_private *dev_priv = to_i915(plane->base.dev);\n\tconst struct intel_plane_state *old_plane_state =\n\t\tintel_atomic_get_old_plane_state(state, plane);\n\tstruct drm_i915_gem_object *obj = intel_fb_obj(new_plane_state->hw.fb);\n\tstruct drm_i915_gem_object *old_obj = intel_fb_obj(old_plane_state->hw.fb);\n\tint ret;\n\n\tif (old_obj) {\n\t\tconst struct intel_crtc_state *new_crtc_state =\n\t\t\tintel_atomic_get_new_crtc_state(state,\n\t\t\t\t\t\t\tto_intel_crtc(old_plane_state->hw.crtc));\n\n\t\t \n\t\tif (new_crtc_state && intel_crtc_needs_modeset(new_crtc_state)) {\n\t\t\tret = i915_sw_fence_await_reservation(&state->commit_ready,\n\t\t\t\t\t\t\t      old_obj->base.resv,\n\t\t\t\t\t\t\t      false, 0,\n\t\t\t\t\t\t\t      GFP_KERNEL);\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\t\t}\n\t}\n\n\tif (new_plane_state->uapi.fence) {  \n\t\ti915_gem_fence_wait_priority(new_plane_state->uapi.fence,\n\t\t\t\t\t     &attr);\n\t\tret = i915_sw_fence_await_dma_fence(&state->commit_ready,\n\t\t\t\t\t\t    new_plane_state->uapi.fence,\n\t\t\t\t\t\t    i915_fence_timeout(dev_priv),\n\t\t\t\t\t\t    GFP_KERNEL);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\tif (!obj)\n\t\treturn 0;\n\n\n\tret = intel_plane_pin_fb(new_plane_state);\n\tif (ret)\n\t\treturn ret;\n\n\ti915_gem_object_wait_priority(obj, 0, &attr);\n\n\tif (!new_plane_state->uapi.fence) {  \n\t\tstruct dma_resv_iter cursor;\n\t\tstruct dma_fence *fence;\n\n\t\tret = i915_sw_fence_await_reservation(&state->commit_ready,\n\t\t\t\t\t\t      obj->base.resv, false,\n\t\t\t\t\t\t      i915_fence_timeout(dev_priv),\n\t\t\t\t\t\t      GFP_KERNEL);\n\t\tif (ret < 0)\n\t\t\tgoto unpin_fb;\n\n\t\tdma_resv_iter_begin(&cursor, obj->base.resv,\n\t\t\t\t    DMA_RESV_USAGE_WRITE);\n\t\tdma_resv_for_each_fence_unlocked(&cursor, fence) {\n\t\t\tintel_display_rps_boost_after_vblank(new_plane_state->hw.crtc,\n\t\t\t\t\t\t\t     fence);\n\t\t}\n\t\tdma_resv_iter_end(&cursor);\n\t} else {\n\t\tintel_display_rps_boost_after_vblank(new_plane_state->hw.crtc,\n\t\t\t\t\t\t     new_plane_state->uapi.fence);\n\t}\n\n\t \n\tintel_display_rps_mark_interactive(dev_priv, state, true);\n\n\treturn 0;\n\nunpin_fb:\n\tintel_plane_unpin_fb(new_plane_state);\n\n\treturn ret;\n}\n\n \nstatic void\nintel_cleanup_plane_fb(struct drm_plane *plane,\n\t\t       struct drm_plane_state *_old_plane_state)\n{\n\tstruct intel_plane_state *old_plane_state =\n\t\tto_intel_plane_state(_old_plane_state);\n\tstruct intel_atomic_state *state =\n\t\tto_intel_atomic_state(old_plane_state->uapi.state);\n\tstruct drm_i915_private *dev_priv = to_i915(plane->dev);\n\tstruct drm_i915_gem_object *obj = intel_fb_obj(old_plane_state->hw.fb);\n\n\tif (!obj)\n\t\treturn;\n\n\tintel_display_rps_mark_interactive(dev_priv, state, false);\n\n\t \n\tintel_plane_unpin_fb(old_plane_state);\n}\n\nstatic const struct drm_plane_helper_funcs intel_plane_helper_funcs = {\n\t.prepare_fb = intel_prepare_plane_fb,\n\t.cleanup_fb = intel_cleanup_plane_fb,\n};\n\nvoid intel_plane_helper_add(struct intel_plane *plane)\n{\n\tdrm_plane_helper_add(&plane->base, &intel_plane_helper_funcs);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}