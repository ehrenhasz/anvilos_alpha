{
  "module_name": "intel_lpe_audio.c",
  "hash_id": "726c9d2b8c4543aa1a2592b8488a14d771af8ce85a92670bcfccb8eb8718a870",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/i915/display/intel_lpe_audio.c",
  "human_readable_source": " \n\n \n\n#include <linux/acpi.h>\n#include <linux/delay.h>\n#include <linux/device.h>\n#include <linux/irq.h>\n#include <linux/pci.h>\n#include <linux/platform_device.h>\n#include <linux/pm_runtime.h>\n\n#include <drm/intel_lpe_audio.h>\n\n#include \"i915_drv.h\"\n#include \"i915_irq.h\"\n#include \"i915_reg.h\"\n#include \"intel_de.h\"\n#include \"intel_lpe_audio.h\"\n#include \"intel_pci_config.h\"\n\n#define HAS_LPE_AUDIO(dev_priv) ((dev_priv)->display.audio.lpe.platdev != NULL)\n\nstatic struct platform_device *\nlpe_audio_platdev_create(struct drm_i915_private *dev_priv)\n{\n\tstruct pci_dev *pdev = to_pci_dev(dev_priv->drm.dev);\n\tstruct platform_device_info pinfo = {};\n\tstruct resource *rsc;\n\tstruct platform_device *platdev;\n\tstruct intel_hdmi_lpe_audio_pdata *pdata;\n\n\tpdata = kzalloc(sizeof(*pdata), GFP_KERNEL);\n\tif (!pdata)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\trsc = kcalloc(2, sizeof(*rsc), GFP_KERNEL);\n\tif (!rsc) {\n\t\tkfree(pdata);\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\n\trsc[0].start    = rsc[0].end = dev_priv->display.audio.lpe.irq;\n\trsc[0].flags    = IORESOURCE_IRQ;\n\trsc[0].name     = \"hdmi-lpe-audio-irq\";\n\n\trsc[1].start    = pci_resource_start(pdev, GEN4_GTTMMADR_BAR) +\n\t\tI915_HDMI_LPE_AUDIO_BASE;\n\trsc[1].end      = pci_resource_start(pdev, GEN4_GTTMMADR_BAR) +\n\t\tI915_HDMI_LPE_AUDIO_BASE + I915_HDMI_LPE_AUDIO_SIZE - 1;\n\trsc[1].flags    = IORESOURCE_MEM;\n\trsc[1].name     = \"hdmi-lpe-audio-mmio\";\n\n\tpinfo.parent = dev_priv->drm.dev;\n\tpinfo.name = \"hdmi-lpe-audio\";\n\tpinfo.id = -1;\n\tpinfo.res = rsc;\n\tpinfo.num_res = 2;\n\tpinfo.data = pdata;\n\tpinfo.size_data = sizeof(*pdata);\n\tpinfo.dma_mask = DMA_BIT_MASK(32);\n\n\tpdata->num_pipes = INTEL_NUM_PIPES(dev_priv);\n\tpdata->num_ports = IS_CHERRYVIEW(dev_priv) ? 3 : 2;  \n\tpdata->port[0].pipe = -1;\n\tpdata->port[1].pipe = -1;\n\tpdata->port[2].pipe = -1;\n\tspin_lock_init(&pdata->lpe_audio_slock);\n\n\tplatdev = platform_device_register_full(&pinfo);\n\tkfree(rsc);\n\tkfree(pdata);\n\n\tif (IS_ERR(platdev)) {\n\t\tdrm_err(&dev_priv->drm,\n\t\t\t\"Failed to allocate LPE audio platform device\\n\");\n\t\treturn platdev;\n\t}\n\n\tpm_runtime_no_callbacks(&platdev->dev);\n\n\treturn platdev;\n}\n\nstatic void lpe_audio_platdev_destroy(struct drm_i915_private *dev_priv)\n{\n\t \n\n\tplatform_device_unregister(dev_priv->display.audio.lpe.platdev);\n}\n\nstatic void lpe_audio_irq_unmask(struct irq_data *d)\n{\n}\n\nstatic void lpe_audio_irq_mask(struct irq_data *d)\n{\n}\n\nstatic struct irq_chip lpe_audio_irqchip = {\n\t.name = \"hdmi_lpe_audio_irqchip\",\n\t.irq_mask = lpe_audio_irq_mask,\n\t.irq_unmask = lpe_audio_irq_unmask,\n};\n\nstatic int lpe_audio_irq_init(struct drm_i915_private *dev_priv)\n{\n\tint irq = dev_priv->display.audio.lpe.irq;\n\n\tdrm_WARN_ON(&dev_priv->drm, !intel_irqs_enabled(dev_priv));\n\tirq_set_chip_and_handler_name(irq,\n\t\t\t\t&lpe_audio_irqchip,\n\t\t\t\thandle_simple_irq,\n\t\t\t\t\"hdmi_lpe_audio_irq_handler\");\n\n\treturn irq_set_chip_data(irq, dev_priv);\n}\n\nstatic bool lpe_audio_detect(struct drm_i915_private *dev_priv)\n{\n\tint lpe_present = false;\n\n\tif (IS_VALLEYVIEW(dev_priv) || IS_CHERRYVIEW(dev_priv)) {\n\t\tstatic const struct pci_device_id atom_hdaudio_ids[] = {\n\t\t\t \n\t\t\t{PCI_DEVICE(PCI_VENDOR_ID_INTEL, 0x0f04)},\n\t\t\t \n\t\t\t{PCI_DEVICE(PCI_VENDOR_ID_INTEL, 0x2284)},\n\t\t\t{}\n\t\t};\n\n\t\tif (!pci_dev_present(atom_hdaudio_ids)) {\n\t\t\tdrm_info(&dev_priv->drm,\n\t\t\t\t \"HDaudio controller not detected, using LPE audio instead\\n\");\n\t\t\tlpe_present = true;\n\t\t}\n\t}\n\treturn lpe_present;\n}\n\nstatic int lpe_audio_setup(struct drm_i915_private *dev_priv)\n{\n\tint ret;\n\n\tdev_priv->display.audio.lpe.irq = irq_alloc_desc(0);\n\tif (dev_priv->display.audio.lpe.irq < 0) {\n\t\tdrm_err(&dev_priv->drm, \"Failed to allocate IRQ desc: %d\\n\",\n\t\t\tdev_priv->display.audio.lpe.irq);\n\t\tret = dev_priv->display.audio.lpe.irq;\n\t\tgoto err;\n\t}\n\n\tdrm_dbg(&dev_priv->drm, \"irq = %d\\n\", dev_priv->display.audio.lpe.irq);\n\n\tret = lpe_audio_irq_init(dev_priv);\n\n\tif (ret) {\n\t\tdrm_err(&dev_priv->drm,\n\t\t\t\"Failed to initialize irqchip for lpe audio: %d\\n\",\n\t\t\tret);\n\t\tgoto err_free_irq;\n\t}\n\n\tdev_priv->display.audio.lpe.platdev = lpe_audio_platdev_create(dev_priv);\n\n\tif (IS_ERR(dev_priv->display.audio.lpe.platdev)) {\n\t\tret = PTR_ERR(dev_priv->display.audio.lpe.platdev);\n\t\tdrm_err(&dev_priv->drm,\n\t\t\t\"Failed to create lpe audio platform device: %d\\n\",\n\t\t\tret);\n\t\tgoto err_free_irq;\n\t}\n\n\t \n\tintel_de_write(dev_priv, VLV_AUD_CHICKEN_BIT_REG,\n\t\t       VLV_CHICKEN_BIT_DBG_ENABLE);\n\n\treturn 0;\nerr_free_irq:\n\tirq_free_desc(dev_priv->display.audio.lpe.irq);\nerr:\n\tdev_priv->display.audio.lpe.irq = -1;\n\tdev_priv->display.audio.lpe.platdev = NULL;\n\treturn ret;\n}\n\n \nvoid intel_lpe_audio_irq_handler(struct drm_i915_private *dev_priv)\n{\n\tint ret;\n\n\tif (!HAS_LPE_AUDIO(dev_priv))\n\t\treturn;\n\n\tret = generic_handle_irq(dev_priv->display.audio.lpe.irq);\n\tif (ret)\n\t\tdrm_err_ratelimited(&dev_priv->drm,\n\t\t\t\t    \"error handling LPE audio irq: %d\\n\", ret);\n}\n\n \nint intel_lpe_audio_init(struct drm_i915_private *dev_priv)\n{\n\tint ret = -ENODEV;\n\n\tif (lpe_audio_detect(dev_priv)) {\n\t\tret = lpe_audio_setup(dev_priv);\n\t\tif (ret < 0)\n\t\t\tdrm_err(&dev_priv->drm,\n\t\t\t\t\"failed to setup LPE Audio bridge\\n\");\n\t}\n\treturn ret;\n}\n\n \nvoid intel_lpe_audio_teardown(struct drm_i915_private *dev_priv)\n{\n\tif (!HAS_LPE_AUDIO(dev_priv))\n\t\treturn;\n\n\tlpe_audio_platdev_destroy(dev_priv);\n\n\tirq_free_desc(dev_priv->display.audio.lpe.irq);\n\n\tdev_priv->display.audio.lpe.irq = -1;\n\tdev_priv->display.audio.lpe.platdev = NULL;\n}\n\n \nvoid intel_lpe_audio_notify(struct drm_i915_private *dev_priv,\n\t\t\t    enum transcoder cpu_transcoder, enum port port,\n\t\t\t    const void *eld, int ls_clock, bool dp_output)\n{\n\tunsigned long irqflags;\n\tstruct intel_hdmi_lpe_audio_pdata *pdata;\n\tstruct intel_hdmi_lpe_audio_port_pdata *ppdata;\n\tu32 audio_enable;\n\n\tif (!HAS_LPE_AUDIO(dev_priv))\n\t\treturn;\n\n\tpdata = dev_get_platdata(&dev_priv->display.audio.lpe.platdev->dev);\n\tppdata = &pdata->port[port - PORT_B];\n\n\tspin_lock_irqsave(&pdata->lpe_audio_slock, irqflags);\n\n\taudio_enable = intel_de_read(dev_priv, VLV_AUD_PORT_EN_DBG(port));\n\n\tif (eld != NULL) {\n\t\tmemcpy(ppdata->eld, eld, HDMI_MAX_ELD_BYTES);\n\t\tppdata->pipe = cpu_transcoder;\n\t\tppdata->ls_clock = ls_clock;\n\t\tppdata->dp_output = dp_output;\n\n\t\t \n\t\tintel_de_write(dev_priv, VLV_AUD_PORT_EN_DBG(port),\n\t\t\t       audio_enable & ~VLV_AMP_MUTE);\n\t} else {\n\t\tmemset(ppdata->eld, 0, HDMI_MAX_ELD_BYTES);\n\t\tppdata->pipe = -1;\n\t\tppdata->ls_clock = 0;\n\t\tppdata->dp_output = false;\n\n\t\t \n\t\tintel_de_write(dev_priv, VLV_AUD_PORT_EN_DBG(port),\n\t\t\t       audio_enable | VLV_AMP_MUTE);\n\t}\n\n\tif (pdata->notify_audio_lpe)\n\t\tpdata->notify_audio_lpe(dev_priv->display.audio.lpe.platdev, port - PORT_B);\n\n\tspin_unlock_irqrestore(&pdata->lpe_audio_slock, irqflags);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}