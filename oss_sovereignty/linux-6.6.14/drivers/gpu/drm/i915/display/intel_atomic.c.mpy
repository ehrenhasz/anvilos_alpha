{
  "module_name": "intel_atomic.c",
  "hash_id": "1f54b614a7e3d58c41fe4a3788ac6eb2a13cf3452cdcfa2ae9ea5471a686266e",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/i915/display/intel_atomic.c",
  "human_readable_source": " \n\n \n\n#include <drm/drm_atomic.h>\n#include <drm/drm_atomic_helper.h>\n#include <drm/drm_fourcc.h>\n\n#include \"i915_drv.h\"\n#include \"i915_reg.h\"\n#include \"intel_atomic.h\"\n#include \"intel_cdclk.h\"\n#include \"intel_display_types.h\"\n#include \"intel_global_state.h\"\n#include \"intel_hdcp.h\"\n#include \"intel_psr.h\"\n#include \"intel_fb.h\"\n#include \"skl_universal_plane.h\"\n\n \nint intel_digital_connector_atomic_get_property(struct drm_connector *connector,\n\t\t\t\t\t\tconst struct drm_connector_state *state,\n\t\t\t\t\t\tstruct drm_property *property,\n\t\t\t\t\t\tu64 *val)\n{\n\tstruct drm_device *dev = connector->dev;\n\tstruct drm_i915_private *dev_priv = to_i915(dev);\n\tstruct intel_digital_connector_state *intel_conn_state =\n\t\tto_intel_digital_connector_state(state);\n\n\tif (property == dev_priv->display.properties.force_audio)\n\t\t*val = intel_conn_state->force_audio;\n\telse if (property == dev_priv->display.properties.broadcast_rgb)\n\t\t*val = intel_conn_state->broadcast_rgb;\n\telse {\n\t\tdrm_dbg_atomic(&dev_priv->drm,\n\t\t\t       \"Unknown property [PROP:%d:%s]\\n\",\n\t\t\t       property->base.id, property->name);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\n \nint intel_digital_connector_atomic_set_property(struct drm_connector *connector,\n\t\t\t\t\t\tstruct drm_connector_state *state,\n\t\t\t\t\t\tstruct drm_property *property,\n\t\t\t\t\t\tu64 val)\n{\n\tstruct drm_device *dev = connector->dev;\n\tstruct drm_i915_private *dev_priv = to_i915(dev);\n\tstruct intel_digital_connector_state *intel_conn_state =\n\t\tto_intel_digital_connector_state(state);\n\n\tif (property == dev_priv->display.properties.force_audio) {\n\t\tintel_conn_state->force_audio = val;\n\t\treturn 0;\n\t}\n\n\tif (property == dev_priv->display.properties.broadcast_rgb) {\n\t\tintel_conn_state->broadcast_rgb = val;\n\t\treturn 0;\n\t}\n\n\tdrm_dbg_atomic(&dev_priv->drm, \"Unknown property [PROP:%d:%s]\\n\",\n\t\t       property->base.id, property->name);\n\treturn -EINVAL;\n}\n\nint intel_digital_connector_atomic_check(struct drm_connector *conn,\n\t\t\t\t\t struct drm_atomic_state *state)\n{\n\tstruct drm_connector_state *new_state =\n\t\tdrm_atomic_get_new_connector_state(state, conn);\n\tstruct intel_digital_connector_state *new_conn_state =\n\t\tto_intel_digital_connector_state(new_state);\n\tstruct drm_connector_state *old_state =\n\t\tdrm_atomic_get_old_connector_state(state, conn);\n\tstruct intel_digital_connector_state *old_conn_state =\n\t\tto_intel_digital_connector_state(old_state);\n\tstruct drm_crtc_state *crtc_state;\n\n\tintel_hdcp_atomic_check(conn, old_state, new_state);\n\n\tif (!new_state->crtc)\n\t\treturn 0;\n\n\tcrtc_state = drm_atomic_get_new_crtc_state(state, new_state->crtc);\n\n\t \n\tif (new_conn_state->force_audio != old_conn_state->force_audio ||\n\t    new_conn_state->broadcast_rgb != old_conn_state->broadcast_rgb ||\n\t    new_conn_state->base.colorspace != old_conn_state->base.colorspace ||\n\t    new_conn_state->base.picture_aspect_ratio != old_conn_state->base.picture_aspect_ratio ||\n\t    new_conn_state->base.content_type != old_conn_state->base.content_type ||\n\t    new_conn_state->base.scaling_mode != old_conn_state->base.scaling_mode ||\n\t    new_conn_state->base.privacy_screen_sw_state != old_conn_state->base.privacy_screen_sw_state ||\n\t    !drm_connector_atomic_hdr_metadata_equal(old_state, new_state))\n\t\tcrtc_state->mode_changed = true;\n\n\treturn 0;\n}\n\n \nstruct drm_connector_state *\nintel_digital_connector_duplicate_state(struct drm_connector *connector)\n{\n\tstruct intel_digital_connector_state *state;\n\n\tstate = kmemdup(connector->state, sizeof(*state), GFP_KERNEL);\n\tif (!state)\n\t\treturn NULL;\n\n\t__drm_atomic_helper_connector_duplicate_state(connector, &state->base);\n\treturn &state->base;\n}\n\n \nbool\nintel_connector_needs_modeset(struct intel_atomic_state *state,\n\t\t\t      struct drm_connector *connector)\n{\n\tconst struct drm_connector_state *old_conn_state, *new_conn_state;\n\n\told_conn_state = drm_atomic_get_old_connector_state(&state->base, connector);\n\tnew_conn_state = drm_atomic_get_new_connector_state(&state->base, connector);\n\n\treturn old_conn_state->crtc != new_conn_state->crtc ||\n\t       (new_conn_state->crtc &&\n\t\tdrm_atomic_crtc_needs_modeset(drm_atomic_get_new_crtc_state(&state->base,\n\t\t\t\t\t\t\t\t\t    new_conn_state->crtc)));\n}\n\n \nbool intel_any_crtc_needs_modeset(struct intel_atomic_state *state)\n{\n\tstruct intel_crtc *crtc;\n\tstruct intel_crtc_state *crtc_state;\n\tint i;\n\n\tfor_each_new_intel_crtc_in_state(state, crtc, crtc_state, i) {\n\t\tif (intel_crtc_needs_modeset(crtc_state))\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}\n\nstruct intel_digital_connector_state *\nintel_atomic_get_digital_connector_state(struct intel_atomic_state *state,\n\t\t\t\t\t struct intel_connector *connector)\n{\n\tstruct drm_connector_state *conn_state;\n\n\tconn_state = drm_atomic_get_connector_state(&state->base,\n\t\t\t\t\t\t    &connector->base);\n\tif (IS_ERR(conn_state))\n\t\treturn ERR_CAST(conn_state);\n\n\treturn to_intel_digital_connector_state(conn_state);\n}\n\n \nstruct drm_crtc_state *\nintel_crtc_duplicate_state(struct drm_crtc *crtc)\n{\n\tconst struct intel_crtc_state *old_crtc_state = to_intel_crtc_state(crtc->state);\n\tstruct intel_crtc_state *crtc_state;\n\n\tcrtc_state = kmemdup(old_crtc_state, sizeof(*crtc_state), GFP_KERNEL);\n\tif (!crtc_state)\n\t\treturn NULL;\n\n\t__drm_atomic_helper_crtc_duplicate_state(crtc, &crtc_state->uapi);\n\n\t \n\tif (crtc_state->hw.degamma_lut)\n\t\tdrm_property_blob_get(crtc_state->hw.degamma_lut);\n\tif (crtc_state->hw.ctm)\n\t\tdrm_property_blob_get(crtc_state->hw.ctm);\n\tif (crtc_state->hw.gamma_lut)\n\t\tdrm_property_blob_get(crtc_state->hw.gamma_lut);\n\n\tif (crtc_state->pre_csc_lut)\n\t\tdrm_property_blob_get(crtc_state->pre_csc_lut);\n\tif (crtc_state->post_csc_lut)\n\t\tdrm_property_blob_get(crtc_state->post_csc_lut);\n\n\tcrtc_state->update_pipe = false;\n\tcrtc_state->disable_lp_wm = false;\n\tcrtc_state->disable_cxsr = false;\n\tcrtc_state->update_wm_pre = false;\n\tcrtc_state->update_wm_post = false;\n\tcrtc_state->fifo_changed = false;\n\tcrtc_state->preload_luts = false;\n\tcrtc_state->wm.need_postvbl_update = false;\n\tcrtc_state->do_async_flip = false;\n\tcrtc_state->fb_bits = 0;\n\tcrtc_state->update_planes = 0;\n\tcrtc_state->dsb = NULL;\n\n\treturn &crtc_state->uapi;\n}\n\nstatic void intel_crtc_put_color_blobs(struct intel_crtc_state *crtc_state)\n{\n\tdrm_property_blob_put(crtc_state->hw.degamma_lut);\n\tdrm_property_blob_put(crtc_state->hw.gamma_lut);\n\tdrm_property_blob_put(crtc_state->hw.ctm);\n\n\tdrm_property_blob_put(crtc_state->pre_csc_lut);\n\tdrm_property_blob_put(crtc_state->post_csc_lut);\n}\n\nvoid intel_crtc_free_hw_state(struct intel_crtc_state *crtc_state)\n{\n\tintel_crtc_put_color_blobs(crtc_state);\n}\n\n \nvoid\nintel_crtc_destroy_state(struct drm_crtc *crtc,\n\t\t\t struct drm_crtc_state *state)\n{\n\tstruct intel_crtc_state *crtc_state = to_intel_crtc_state(state);\n\n\tdrm_WARN_ON(crtc->dev, crtc_state->dsb);\n\n\t__drm_atomic_helper_crtc_destroy_state(&crtc_state->uapi);\n\tintel_crtc_free_hw_state(crtc_state);\n\tkfree(crtc_state);\n}\n\nstruct drm_atomic_state *\nintel_atomic_state_alloc(struct drm_device *dev)\n{\n\tstruct intel_atomic_state *state = kzalloc(sizeof(*state), GFP_KERNEL);\n\n\tif (!state || drm_atomic_state_init(dev, &state->base) < 0) {\n\t\tkfree(state);\n\t\treturn NULL;\n\t}\n\n\treturn &state->base;\n}\n\nvoid intel_atomic_state_free(struct drm_atomic_state *_state)\n{\n\tstruct intel_atomic_state *state = to_intel_atomic_state(_state);\n\n\tdrm_atomic_state_default_release(&state->base);\n\tkfree(state->global_objs);\n\n\ti915_sw_fence_fini(&state->commit_ready);\n\n\tkfree(state);\n}\n\nvoid intel_atomic_state_clear(struct drm_atomic_state *s)\n{\n\tstruct intel_atomic_state *state = to_intel_atomic_state(s);\n\n\tdrm_atomic_state_default_clear(&state->base);\n\tintel_atomic_clear_global_state(state);\n\n\t \n\n\tstate->dpll_set = state->modeset = false;\n}\n\nstruct intel_crtc_state *\nintel_atomic_get_crtc_state(struct drm_atomic_state *state,\n\t\t\t    struct intel_crtc *crtc)\n{\n\tstruct drm_crtc_state *crtc_state;\n\tcrtc_state = drm_atomic_get_crtc_state(state, &crtc->base);\n\tif (IS_ERR(crtc_state))\n\t\treturn ERR_CAST(crtc_state);\n\n\treturn to_intel_crtc_state(crtc_state);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}