{
  "module_name": "intel_cursor.c",
  "hash_id": "a81852a1452fab0422b4252d9d127b438100cf4f4d0afb399c777b7bf1ea43f1",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/i915/display/intel_cursor.c",
  "human_readable_source": "\n \n#include <linux/kernel.h>\n\n#include <drm/drm_atomic_helper.h>\n#include <drm/drm_atomic_uapi.h>\n#include <drm/drm_blend.h>\n#include <drm/drm_damage_helper.h>\n#include <drm/drm_fourcc.h>\n\n#include \"i915_reg.h\"\n#include \"intel_atomic.h\"\n#include \"intel_atomic_plane.h\"\n#include \"intel_cursor.h\"\n#include \"intel_de.h\"\n#include \"intel_display.h\"\n#include \"intel_display_types.h\"\n#include \"intel_fb.h\"\n#include \"intel_fb_pin.h\"\n#include \"intel_frontbuffer.h\"\n#include \"intel_psr.h\"\n#include \"skl_watermark.h\"\n\n \nstatic const u32 intel_cursor_formats[] = {\n\tDRM_FORMAT_ARGB8888,\n};\n\nstatic u32 intel_cursor_base(const struct intel_plane_state *plane_state)\n{\n\tstruct drm_i915_private *dev_priv =\n\t\tto_i915(plane_state->uapi.plane->dev);\n\tconst struct drm_framebuffer *fb = plane_state->hw.fb;\n\tconst struct drm_i915_gem_object *obj = intel_fb_obj(fb);\n\tu32 base;\n\n\tif (DISPLAY_INFO(dev_priv)->cursor_needs_physical)\n\t\tbase = sg_dma_address(obj->mm.pages->sgl);\n\telse\n\t\tbase = intel_plane_ggtt_offset(plane_state);\n\n\treturn base + plane_state->view.color_plane[0].offset;\n}\n\nstatic u32 intel_cursor_position(const struct intel_plane_state *plane_state)\n{\n\tint x = plane_state->uapi.dst.x1;\n\tint y = plane_state->uapi.dst.y1;\n\tu32 pos = 0;\n\n\tif (x < 0) {\n\t\tpos |= CURSOR_POS_X_SIGN;\n\t\tx = -x;\n\t}\n\tpos |= CURSOR_POS_X(x);\n\n\tif (y < 0) {\n\t\tpos |= CURSOR_POS_Y_SIGN;\n\t\ty = -y;\n\t}\n\tpos |= CURSOR_POS_Y(y);\n\n\treturn pos;\n}\n\nstatic bool intel_cursor_size_ok(const struct intel_plane_state *plane_state)\n{\n\tconst struct drm_mode_config *config =\n\t\t&plane_state->uapi.plane->dev->mode_config;\n\tint width = drm_rect_width(&plane_state->uapi.dst);\n\tint height = drm_rect_height(&plane_state->uapi.dst);\n\n\treturn width > 0 && width <= config->cursor_width &&\n\t\theight > 0 && height <= config->cursor_height;\n}\n\nstatic int intel_cursor_check_surface(struct intel_plane_state *plane_state)\n{\n\tstruct drm_i915_private *dev_priv =\n\t\tto_i915(plane_state->uapi.plane->dev);\n\tunsigned int rotation = plane_state->hw.rotation;\n\tint src_x, src_y;\n\tu32 offset;\n\tint ret;\n\n\tret = intel_plane_compute_gtt(plane_state);\n\tif (ret)\n\t\treturn ret;\n\n\tif (!plane_state->uapi.visible)\n\t\treturn 0;\n\n\tsrc_x = plane_state->uapi.src.x1 >> 16;\n\tsrc_y = plane_state->uapi.src.y1 >> 16;\n\n\tintel_add_fb_offsets(&src_x, &src_y, plane_state, 0);\n\toffset = intel_plane_compute_aligned_offset(&src_x, &src_y,\n\t\t\t\t\t\t    plane_state, 0);\n\n\tif (src_x != 0 || src_y != 0) {\n\t\tdrm_dbg_kms(&dev_priv->drm,\n\t\t\t    \"Arbitrary cursor panning not supported\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tdrm_rect_translate_to(&plane_state->uapi.src,\n\t\t\t      src_x << 16, src_y << 16);\n\n\t \n\tif (HAS_GMCH(dev_priv) && rotation & DRM_MODE_ROTATE_180) {\n\t\tconst struct drm_framebuffer *fb = plane_state->hw.fb;\n\t\tint src_w = drm_rect_width(&plane_state->uapi.src) >> 16;\n\t\tint src_h = drm_rect_height(&plane_state->uapi.src) >> 16;\n\n\t\toffset += (src_h * src_w - 1) * fb->format->cpp[0];\n\t}\n\n\tplane_state->view.color_plane[0].offset = offset;\n\tplane_state->view.color_plane[0].x = src_x;\n\tplane_state->view.color_plane[0].y = src_y;\n\n\treturn 0;\n}\n\nstatic int intel_check_cursor(struct intel_crtc_state *crtc_state,\n\t\t\t      struct intel_plane_state *plane_state)\n{\n\tconst struct drm_framebuffer *fb = plane_state->hw.fb;\n\tstruct drm_i915_private *i915 = to_i915(plane_state->uapi.plane->dev);\n\tconst struct drm_rect src = plane_state->uapi.src;\n\tconst struct drm_rect dst = plane_state->uapi.dst;\n\tint ret;\n\n\tif (fb && fb->modifier != DRM_FORMAT_MOD_LINEAR) {\n\t\tdrm_dbg_kms(&i915->drm, \"cursor cannot be tiled\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tret = intel_atomic_plane_check_clipping(plane_state, crtc_state,\n\t\t\t\t\t\tDRM_PLANE_NO_SCALING,\n\t\t\t\t\t\tDRM_PLANE_NO_SCALING,\n\t\t\t\t\t\ttrue);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tplane_state->uapi.src = src;\n\tplane_state->uapi.dst = dst;\n\n\t \n\tdrm_rect_translate(&plane_state->uapi.dst,\n\t\t\t   -crtc_state->pipe_src.x1,\n\t\t\t   -crtc_state->pipe_src.y1);\n\n\tret = intel_cursor_check_surface(plane_state);\n\tif (ret)\n\t\treturn ret;\n\n\tif (!plane_state->uapi.visible)\n\t\treturn 0;\n\n\tret = intel_plane_check_src_coordinates(plane_state);\n\tif (ret)\n\t\treturn ret;\n\n\treturn 0;\n}\n\nstatic unsigned int\ni845_cursor_max_stride(struct intel_plane *plane,\n\t\t       u32 pixel_format, u64 modifier,\n\t\t       unsigned int rotation)\n{\n\treturn 2048;\n}\n\nstatic u32 i845_cursor_ctl_crtc(const struct intel_crtc_state *crtc_state)\n{\n\tu32 cntl = 0;\n\n\tif (crtc_state->gamma_enable)\n\t\tcntl |= CURSOR_PIPE_GAMMA_ENABLE;\n\n\treturn cntl;\n}\n\nstatic u32 i845_cursor_ctl(const struct intel_crtc_state *crtc_state,\n\t\t\t   const struct intel_plane_state *plane_state)\n{\n\treturn CURSOR_ENABLE |\n\t\tCURSOR_FORMAT_ARGB |\n\t\tCURSOR_STRIDE(plane_state->view.color_plane[0].mapping_stride);\n}\n\nstatic bool i845_cursor_size_ok(const struct intel_plane_state *plane_state)\n{\n\tint width = drm_rect_width(&plane_state->uapi.dst);\n\n\t \n\treturn intel_cursor_size_ok(plane_state) && IS_ALIGNED(width, 64);\n}\n\nstatic int i845_check_cursor(struct intel_crtc_state *crtc_state,\n\t\t\t     struct intel_plane_state *plane_state)\n{\n\tconst struct drm_framebuffer *fb = plane_state->hw.fb;\n\tstruct drm_i915_private *i915 = to_i915(plane_state->uapi.plane->dev);\n\tint ret;\n\n\tret = intel_check_cursor(crtc_state, plane_state);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tif (!fb)\n\t\treturn 0;\n\n\t \n\tif (!i845_cursor_size_ok(plane_state)) {\n\t\tdrm_dbg_kms(&i915->drm,\n\t\t\t    \"Cursor dimension %dx%d not supported\\n\",\n\t\t\t    drm_rect_width(&plane_state->uapi.dst),\n\t\t\t    drm_rect_height(&plane_state->uapi.dst));\n\t\treturn -EINVAL;\n\t}\n\n\tdrm_WARN_ON(&i915->drm, plane_state->uapi.visible &&\n\t\t    plane_state->view.color_plane[0].mapping_stride != fb->pitches[0]);\n\n\tswitch (fb->pitches[0]) {\n\tcase 256:\n\tcase 512:\n\tcase 1024:\n\tcase 2048:\n\t\tbreak;\n\tdefault:\n\t\t drm_dbg_kms(&i915->drm, \"Invalid cursor stride (%u)\\n\",\n\t\t\t     fb->pitches[0]);\n\t\treturn -EINVAL;\n\t}\n\n\tplane_state->ctl = i845_cursor_ctl(crtc_state, plane_state);\n\n\treturn 0;\n}\n\n \nstatic void i845_cursor_update_arm(struct intel_plane *plane,\n\t\t\t\t   const struct intel_crtc_state *crtc_state,\n\t\t\t\t   const struct intel_plane_state *plane_state)\n{\n\tstruct drm_i915_private *dev_priv = to_i915(plane->base.dev);\n\tu32 cntl = 0, base = 0, pos = 0, size = 0;\n\n\tif (plane_state && plane_state->uapi.visible) {\n\t\tunsigned int width = drm_rect_width(&plane_state->uapi.dst);\n\t\tunsigned int height = drm_rect_height(&plane_state->uapi.dst);\n\n\t\tcntl = plane_state->ctl |\n\t\t\ti845_cursor_ctl_crtc(crtc_state);\n\n\t\tsize = CURSOR_HEIGHT(height) | CURSOR_WIDTH(width);\n\n\t\tbase = intel_cursor_base(plane_state);\n\t\tpos = intel_cursor_position(plane_state);\n\t}\n\n\t \n\tif (plane->cursor.base != base ||\n\t    plane->cursor.size != size ||\n\t    plane->cursor.cntl != cntl) {\n\t\tintel_de_write_fw(dev_priv, CURCNTR(PIPE_A), 0);\n\t\tintel_de_write_fw(dev_priv, CURBASE(PIPE_A), base);\n\t\tintel_de_write_fw(dev_priv, CURSIZE(PIPE_A), size);\n\t\tintel_de_write_fw(dev_priv, CURPOS(PIPE_A), pos);\n\t\tintel_de_write_fw(dev_priv, CURCNTR(PIPE_A), cntl);\n\n\t\tplane->cursor.base = base;\n\t\tplane->cursor.size = size;\n\t\tplane->cursor.cntl = cntl;\n\t} else {\n\t\tintel_de_write_fw(dev_priv, CURPOS(PIPE_A), pos);\n\t}\n}\n\nstatic void i845_cursor_disable_arm(struct intel_plane *plane,\n\t\t\t\t    const struct intel_crtc_state *crtc_state)\n{\n\ti845_cursor_update_arm(plane, crtc_state, NULL);\n}\n\nstatic bool i845_cursor_get_hw_state(struct intel_plane *plane,\n\t\t\t\t     enum pipe *pipe)\n{\n\tstruct drm_i915_private *dev_priv = to_i915(plane->base.dev);\n\tenum intel_display_power_domain power_domain;\n\tintel_wakeref_t wakeref;\n\tbool ret;\n\n\tpower_domain = POWER_DOMAIN_PIPE(PIPE_A);\n\twakeref = intel_display_power_get_if_enabled(dev_priv, power_domain);\n\tif (!wakeref)\n\t\treturn false;\n\n\tret = intel_de_read(dev_priv, CURCNTR(PIPE_A)) & CURSOR_ENABLE;\n\n\t*pipe = PIPE_A;\n\n\tintel_display_power_put(dev_priv, power_domain, wakeref);\n\n\treturn ret;\n}\n\nstatic unsigned int\ni9xx_cursor_max_stride(struct intel_plane *plane,\n\t\t       u32 pixel_format, u64 modifier,\n\t\t       unsigned int rotation)\n{\n\treturn plane->base.dev->mode_config.cursor_width * 4;\n}\n\nstatic u32 i9xx_cursor_ctl_crtc(const struct intel_crtc_state *crtc_state)\n{\n\tstruct intel_crtc *crtc = to_intel_crtc(crtc_state->uapi.crtc);\n\tstruct drm_i915_private *dev_priv = to_i915(crtc->base.dev);\n\tu32 cntl = 0;\n\n\tif (DISPLAY_VER(dev_priv) >= 11)\n\t\treturn cntl;\n\n\tif (crtc_state->gamma_enable)\n\t\tcntl = MCURSOR_PIPE_GAMMA_ENABLE;\n\n\tif (crtc_state->csc_enable)\n\t\tcntl |= MCURSOR_PIPE_CSC_ENABLE;\n\n\tif (DISPLAY_VER(dev_priv) < 5 && !IS_G4X(dev_priv))\n\t\tcntl |= MCURSOR_PIPE_SEL(crtc->pipe);\n\n\treturn cntl;\n}\n\nstatic u32 i9xx_cursor_ctl(const struct intel_crtc_state *crtc_state,\n\t\t\t   const struct intel_plane_state *plane_state)\n{\n\tstruct drm_i915_private *dev_priv =\n\t\tto_i915(plane_state->uapi.plane->dev);\n\tu32 cntl = 0;\n\n\tif (IS_SANDYBRIDGE(dev_priv) || IS_IVYBRIDGE(dev_priv))\n\t\tcntl |= MCURSOR_TRICKLE_FEED_DISABLE;\n\n\tswitch (drm_rect_width(&plane_state->uapi.dst)) {\n\tcase 64:\n\t\tcntl |= MCURSOR_MODE_64_ARGB_AX;\n\t\tbreak;\n\tcase 128:\n\t\tcntl |= MCURSOR_MODE_128_ARGB_AX;\n\t\tbreak;\n\tcase 256:\n\t\tcntl |= MCURSOR_MODE_256_ARGB_AX;\n\t\tbreak;\n\tdefault:\n\t\tMISSING_CASE(drm_rect_width(&plane_state->uapi.dst));\n\t\treturn 0;\n\t}\n\n\tif (plane_state->hw.rotation & DRM_MODE_ROTATE_180)\n\t\tcntl |= MCURSOR_ROTATE_180;\n\n\t \n\tif (DISPLAY_VER(dev_priv) == 13)\n\t\tcntl |= MCURSOR_ARB_SLOTS(1);\n\n\treturn cntl;\n}\n\nstatic bool i9xx_cursor_size_ok(const struct intel_plane_state *plane_state)\n{\n\tstruct drm_i915_private *dev_priv =\n\t\tto_i915(plane_state->uapi.plane->dev);\n\tint width = drm_rect_width(&plane_state->uapi.dst);\n\tint height = drm_rect_height(&plane_state->uapi.dst);\n\n\tif (!intel_cursor_size_ok(plane_state))\n\t\treturn false;\n\n\t \n\tswitch (width) {\n\tcase 256:\n\tcase 128:\n\tcase 64:\n\t\tbreak;\n\tdefault:\n\t\treturn false;\n\t}\n\n\t \n\tif (HAS_CUR_FBC(dev_priv) &&\n\t    plane_state->hw.rotation & DRM_MODE_ROTATE_0) {\n\t\tif (height < 8 || height > width)\n\t\t\treturn false;\n\t} else {\n\t\tif (height != width)\n\t\t\treturn false;\n\t}\n\n\treturn true;\n}\n\nstatic int i9xx_check_cursor(struct intel_crtc_state *crtc_state,\n\t\t\t     struct intel_plane_state *plane_state)\n{\n\tstruct intel_plane *plane = to_intel_plane(plane_state->uapi.plane);\n\tstruct drm_i915_private *dev_priv = to_i915(plane->base.dev);\n\tconst struct drm_framebuffer *fb = plane_state->hw.fb;\n\tenum pipe pipe = plane->pipe;\n\tint ret;\n\n\tret = intel_check_cursor(crtc_state, plane_state);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tif (!fb)\n\t\treturn 0;\n\n\t \n\tif (!i9xx_cursor_size_ok(plane_state)) {\n\t\tdrm_dbg(&dev_priv->drm,\n\t\t\t\"Cursor dimension %dx%d not supported\\n\",\n\t\t\tdrm_rect_width(&plane_state->uapi.dst),\n\t\t\tdrm_rect_height(&plane_state->uapi.dst));\n\t\treturn -EINVAL;\n\t}\n\n\tdrm_WARN_ON(&dev_priv->drm, plane_state->uapi.visible &&\n\t\t    plane_state->view.color_plane[0].mapping_stride != fb->pitches[0]);\n\n\tif (fb->pitches[0] !=\n\t    drm_rect_width(&plane_state->uapi.dst) * fb->format->cpp[0]) {\n\t\tdrm_dbg_kms(&dev_priv->drm,\n\t\t\t    \"Invalid cursor stride (%u) (cursor width %d)\\n\",\n\t\t\t    fb->pitches[0],\n\t\t\t    drm_rect_width(&plane_state->uapi.dst));\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (IS_CHERRYVIEW(dev_priv) && pipe == PIPE_C &&\n\t    plane_state->uapi.visible && plane_state->uapi.dst.x1 < 0) {\n\t\tdrm_dbg_kms(&dev_priv->drm,\n\t\t\t    \"CHV cursor C not allowed to straddle the left screen edge\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tplane_state->ctl = i9xx_cursor_ctl(crtc_state, plane_state);\n\n\treturn 0;\n}\n\n \nstatic void i9xx_cursor_update_arm(struct intel_plane *plane,\n\t\t\t\t   const struct intel_crtc_state *crtc_state,\n\t\t\t\t   const struct intel_plane_state *plane_state)\n{\n\tstruct drm_i915_private *dev_priv = to_i915(plane->base.dev);\n\tenum pipe pipe = plane->pipe;\n\tu32 cntl = 0, base = 0, pos = 0, fbc_ctl = 0;\n\n\tif (plane_state && plane_state->uapi.visible) {\n\t\tint width = drm_rect_width(&plane_state->uapi.dst);\n\t\tint height = drm_rect_height(&plane_state->uapi.dst);\n\n\t\tcntl = plane_state->ctl |\n\t\t\ti9xx_cursor_ctl_crtc(crtc_state);\n\n\t\tif (width != height)\n\t\t\tfbc_ctl = CUR_FBC_EN | CUR_FBC_HEIGHT(height - 1);\n\n\t\tbase = intel_cursor_base(plane_state);\n\t\tpos = intel_cursor_position(plane_state);\n\t}\n\n\t \n\n\tif (DISPLAY_VER(dev_priv) >= 9)\n\t\tskl_write_cursor_wm(plane, crtc_state);\n\n\tif (plane_state)\n\t\tintel_psr2_program_plane_sel_fetch_arm(plane, crtc_state,\n\t\t\t\t\t\t       plane_state);\n\telse\n\t\tintel_psr2_disable_plane_sel_fetch_arm(plane, crtc_state);\n\n\tif (plane->cursor.base != base ||\n\t    plane->cursor.size != fbc_ctl ||\n\t    plane->cursor.cntl != cntl) {\n\t\tif (HAS_CUR_FBC(dev_priv))\n\t\t\tintel_de_write_fw(dev_priv, CUR_FBC_CTL(pipe),\n\t\t\t\t\t  fbc_ctl);\n\t\tintel_de_write_fw(dev_priv, CURCNTR(pipe), cntl);\n\t\tintel_de_write_fw(dev_priv, CURPOS(pipe), pos);\n\t\tintel_de_write_fw(dev_priv, CURBASE(pipe), base);\n\n\t\tplane->cursor.base = base;\n\t\tplane->cursor.size = fbc_ctl;\n\t\tplane->cursor.cntl = cntl;\n\t} else {\n\t\tintel_de_write_fw(dev_priv, CURPOS(pipe), pos);\n\t\tintel_de_write_fw(dev_priv, CURBASE(pipe), base);\n\t}\n}\n\nstatic void i9xx_cursor_disable_arm(struct intel_plane *plane,\n\t\t\t\t    const struct intel_crtc_state *crtc_state)\n{\n\ti9xx_cursor_update_arm(plane, crtc_state, NULL);\n}\n\nstatic bool i9xx_cursor_get_hw_state(struct intel_plane *plane,\n\t\t\t\t     enum pipe *pipe)\n{\n\tstruct drm_i915_private *dev_priv = to_i915(plane->base.dev);\n\tenum intel_display_power_domain power_domain;\n\tintel_wakeref_t wakeref;\n\tbool ret;\n\tu32 val;\n\n\t \n\tpower_domain = POWER_DOMAIN_PIPE(plane->pipe);\n\twakeref = intel_display_power_get_if_enabled(dev_priv, power_domain);\n\tif (!wakeref)\n\t\treturn false;\n\n\tval = intel_de_read(dev_priv, CURCNTR(plane->pipe));\n\n\tret = val & MCURSOR_MODE_MASK;\n\n\tif (DISPLAY_VER(dev_priv) >= 5 || IS_G4X(dev_priv))\n\t\t*pipe = plane->pipe;\n\telse\n\t\t*pipe = REG_FIELD_GET(MCURSOR_PIPE_SEL_MASK, val);\n\n\tintel_display_power_put(dev_priv, power_domain, wakeref);\n\n\treturn ret;\n}\n\nstatic bool intel_cursor_format_mod_supported(struct drm_plane *_plane,\n\t\t\t\t\t      u32 format, u64 modifier)\n{\n\tif (!intel_fb_plane_supports_modifier(to_intel_plane(_plane), modifier))\n\t\treturn false;\n\n\treturn format == DRM_FORMAT_ARGB8888;\n}\n\nstatic int\nintel_legacy_cursor_update(struct drm_plane *_plane,\n\t\t\t   struct drm_crtc *_crtc,\n\t\t\t   struct drm_framebuffer *fb,\n\t\t\t   int crtc_x, int crtc_y,\n\t\t\t   unsigned int crtc_w, unsigned int crtc_h,\n\t\t\t   u32 src_x, u32 src_y,\n\t\t\t   u32 src_w, u32 src_h,\n\t\t\t   struct drm_modeset_acquire_ctx *ctx)\n{\n\tstruct intel_plane *plane = to_intel_plane(_plane);\n\tstruct intel_crtc *crtc = to_intel_crtc(_crtc);\n\tstruct intel_plane_state *old_plane_state =\n\t\tto_intel_plane_state(plane->base.state);\n\tstruct intel_plane_state *new_plane_state;\n\tstruct intel_crtc_state *crtc_state =\n\t\tto_intel_crtc_state(crtc->base.state);\n\tstruct intel_crtc_state *new_crtc_state;\n\tint ret;\n\n\t \n\tif (!crtc_state->hw.active ||\n\t    intel_crtc_needs_modeset(crtc_state) ||\n\t    intel_crtc_needs_fastset(crtc_state) ||\n\t    crtc_state->bigjoiner_pipes)\n\t\tgoto slow;\n\n\t \n\tif (old_plane_state->uapi.commit &&\n\t    !try_wait_for_completion(&old_plane_state->uapi.commit->hw_done))\n\t\tgoto slow;\n\n\t \n\tif (old_plane_state->uapi.crtc != &crtc->base ||\n\t    old_plane_state->uapi.src_w != src_w ||\n\t    old_plane_state->uapi.src_h != src_h ||\n\t    old_plane_state->uapi.crtc_w != crtc_w ||\n\t    old_plane_state->uapi.crtc_h != crtc_h ||\n\t    !old_plane_state->uapi.fb != !fb)\n\t\tgoto slow;\n\n\tnew_plane_state = to_intel_plane_state(intel_plane_duplicate_state(&plane->base));\n\tif (!new_plane_state)\n\t\treturn -ENOMEM;\n\n\tnew_crtc_state = to_intel_crtc_state(intel_crtc_duplicate_state(&crtc->base));\n\tif (!new_crtc_state) {\n\t\tret = -ENOMEM;\n\t\tgoto out_free;\n\t}\n\n\tdrm_atomic_set_fb_for_plane(&new_plane_state->uapi, fb);\n\n\tnew_plane_state->uapi.src_x = src_x;\n\tnew_plane_state->uapi.src_y = src_y;\n\tnew_plane_state->uapi.src_w = src_w;\n\tnew_plane_state->uapi.src_h = src_h;\n\tnew_plane_state->uapi.crtc_x = crtc_x;\n\tnew_plane_state->uapi.crtc_y = crtc_y;\n\tnew_plane_state->uapi.crtc_w = crtc_w;\n\tnew_plane_state->uapi.crtc_h = crtc_h;\n\n\tintel_plane_copy_uapi_to_hw_state(new_plane_state, new_plane_state, crtc);\n\n\tret = intel_plane_atomic_check_with_state(crtc_state, new_crtc_state,\n\t\t\t\t\t\t  old_plane_state, new_plane_state);\n\tif (ret)\n\t\tgoto out_free;\n\n\tret = intel_plane_pin_fb(new_plane_state);\n\tif (ret)\n\t\tgoto out_free;\n\n\tintel_frontbuffer_flush(to_intel_frontbuffer(new_plane_state->hw.fb),\n\t\t\t\tORIGIN_CURSOR_UPDATE);\n\tintel_frontbuffer_track(to_intel_frontbuffer(old_plane_state->hw.fb),\n\t\t\t\tto_intel_frontbuffer(new_plane_state->hw.fb),\n\t\t\t\tplane->frontbuffer_bit);\n\n\t \n\tplane->base.state = &new_plane_state->uapi;\n\n\t \n\tcrtc_state->active_planes = new_crtc_state->active_planes;\n\n\t \n\tlocal_irq_disable();\n\n\tif (new_plane_state->uapi.visible) {\n\t\tintel_plane_update_noarm(plane, crtc_state, new_plane_state);\n\t\tintel_plane_update_arm(plane, crtc_state, new_plane_state);\n\t} else {\n\t\tintel_plane_disable_arm(plane, crtc_state);\n\t}\n\n\tlocal_irq_enable();\n\n\tintel_plane_unpin_fb(old_plane_state);\n\nout_free:\n\tif (new_crtc_state)\n\t\tintel_crtc_destroy_state(&crtc->base, &new_crtc_state->uapi);\n\tif (ret)\n\t\tintel_plane_destroy_state(&plane->base, &new_plane_state->uapi);\n\telse\n\t\tintel_plane_destroy_state(&plane->base, &old_plane_state->uapi);\n\treturn ret;\n\nslow:\n\treturn drm_atomic_helper_update_plane(&plane->base, &crtc->base, fb,\n\t\t\t\t\t      crtc_x, crtc_y, crtc_w, crtc_h,\n\t\t\t\t\t      src_x, src_y, src_w, src_h, ctx);\n}\n\nstatic const struct drm_plane_funcs intel_cursor_plane_funcs = {\n\t.update_plane = intel_legacy_cursor_update,\n\t.disable_plane = drm_atomic_helper_disable_plane,\n\t.destroy = intel_plane_destroy,\n\t.atomic_duplicate_state = intel_plane_duplicate_state,\n\t.atomic_destroy_state = intel_plane_destroy_state,\n\t.format_mod_supported = intel_cursor_format_mod_supported,\n};\n\nstruct intel_plane *\nintel_cursor_plane_create(struct drm_i915_private *dev_priv,\n\t\t\t  enum pipe pipe)\n{\n\tstruct intel_plane *cursor;\n\tint ret, zpos;\n\tu64 *modifiers;\n\n\tcursor = intel_plane_alloc();\n\tif (IS_ERR(cursor))\n\t\treturn cursor;\n\n\tcursor->pipe = pipe;\n\tcursor->i9xx_plane = (enum i9xx_plane_id) pipe;\n\tcursor->id = PLANE_CURSOR;\n\tcursor->frontbuffer_bit = INTEL_FRONTBUFFER(pipe, cursor->id);\n\n\tif (IS_I845G(dev_priv) || IS_I865G(dev_priv)) {\n\t\tcursor->max_stride = i845_cursor_max_stride;\n\t\tcursor->update_arm = i845_cursor_update_arm;\n\t\tcursor->disable_arm = i845_cursor_disable_arm;\n\t\tcursor->get_hw_state = i845_cursor_get_hw_state;\n\t\tcursor->check_plane = i845_check_cursor;\n\t} else {\n\t\tcursor->max_stride = i9xx_cursor_max_stride;\n\t\tcursor->update_arm = i9xx_cursor_update_arm;\n\t\tcursor->disable_arm = i9xx_cursor_disable_arm;\n\t\tcursor->get_hw_state = i9xx_cursor_get_hw_state;\n\t\tcursor->check_plane = i9xx_check_cursor;\n\t}\n\n\tcursor->cursor.base = ~0;\n\tcursor->cursor.cntl = ~0;\n\n\tif (IS_I845G(dev_priv) || IS_I865G(dev_priv) || HAS_CUR_FBC(dev_priv))\n\t\tcursor->cursor.size = ~0;\n\n\tmodifiers = intel_fb_plane_get_modifiers(dev_priv, INTEL_PLANE_CAP_NONE);\n\n\tret = drm_universal_plane_init(&dev_priv->drm, &cursor->base,\n\t\t\t\t       0, &intel_cursor_plane_funcs,\n\t\t\t\t       intel_cursor_formats,\n\t\t\t\t       ARRAY_SIZE(intel_cursor_formats),\n\t\t\t\t       modifiers,\n\t\t\t\t       DRM_PLANE_TYPE_CURSOR,\n\t\t\t\t       \"cursor %c\", pipe_name(pipe));\n\n\tkfree(modifiers);\n\n\tif (ret)\n\t\tgoto fail;\n\n\tif (DISPLAY_VER(dev_priv) >= 4)\n\t\tdrm_plane_create_rotation_property(&cursor->base,\n\t\t\t\t\t\t   DRM_MODE_ROTATE_0,\n\t\t\t\t\t\t   DRM_MODE_ROTATE_0 |\n\t\t\t\t\t\t   DRM_MODE_ROTATE_180);\n\n\tzpos = DISPLAY_RUNTIME_INFO(dev_priv)->num_sprites[pipe] + 1;\n\tdrm_plane_create_zpos_immutable_property(&cursor->base, zpos);\n\n\tif (DISPLAY_VER(dev_priv) >= 12)\n\t\tdrm_plane_enable_fb_damage_clips(&cursor->base);\n\n\tintel_plane_helper_add(cursor);\n\n\treturn cursor;\n\nfail:\n\tintel_plane_free(cursor);\n\n\treturn ERR_PTR(ret);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}