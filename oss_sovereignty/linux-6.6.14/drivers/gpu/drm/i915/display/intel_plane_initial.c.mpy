{
  "module_name": "intel_plane_initial.c",
  "hash_id": "37298220a28f5adfb5dcffc9a662ff98a4939daa6ab5de44b422897475296f31",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/i915/display/intel_plane_initial.c",
  "human_readable_source": "\n \n\n#include \"gem/i915_gem_region.h\"\n#include \"i915_drv.h\"\n#include \"intel_atomic_plane.h\"\n#include \"intel_display.h\"\n#include \"intel_display_types.h\"\n#include \"intel_fb.h\"\n#include \"intel_plane_initial.h\"\n\nstatic bool\nintel_reuse_initial_plane_obj(struct drm_i915_private *i915,\n\t\t\t      const struct intel_initial_plane_config *plane_config,\n\t\t\t      struct drm_framebuffer **fb,\n\t\t\t      struct i915_vma **vma)\n{\n\tstruct intel_crtc *crtc;\n\n\tfor_each_intel_crtc(&i915->drm, crtc) {\n\t\tstruct intel_crtc_state *crtc_state =\n\t\t\tto_intel_crtc_state(crtc->base.state);\n\t\tstruct intel_plane *plane =\n\t\t\tto_intel_plane(crtc->base.primary);\n\t\tstruct intel_plane_state *plane_state =\n\t\t\tto_intel_plane_state(plane->base.state);\n\n\t\tif (!crtc_state->uapi.active)\n\t\t\tcontinue;\n\n\t\tif (!plane_state->ggtt_vma)\n\t\t\tcontinue;\n\n\t\tif (intel_plane_ggtt_offset(plane_state) == plane_config->base) {\n\t\t\t*fb = plane_state->hw.fb;\n\t\t\t*vma = plane_state->ggtt_vma;\n\t\t\treturn true;\n\t\t}\n\t}\n\n\treturn false;\n}\n\nstatic struct i915_vma *\ninitial_plane_vma(struct drm_i915_private *i915,\n\t\t  struct intel_initial_plane_config *plane_config)\n{\n\tstruct intel_memory_region *mem;\n\tstruct drm_i915_gem_object *obj;\n\tstruct i915_vma *vma;\n\tresource_size_t phys_base;\n\tu32 base, size;\n\tu64 pinctl;\n\n\tif (plane_config->size == 0)\n\t\treturn NULL;\n\n\tbase = round_down(plane_config->base, I915_GTT_MIN_ALIGNMENT);\n\tif (IS_DGFX(i915)) {\n\t\tgen8_pte_t __iomem *gte = to_gt(i915)->ggtt->gsm;\n\t\tgen8_pte_t pte;\n\n\t\tgte += base / I915_GTT_PAGE_SIZE;\n\n\t\tpte = ioread64(gte);\n\t\tif (!(pte & GEN12_GGTT_PTE_LM)) {\n\t\t\tdrm_err(&i915->drm,\n\t\t\t\t\"Initial plane programming missing PTE_LM bit\\n\");\n\t\t\treturn NULL;\n\t\t}\n\n\t\tphys_base = pte & I915_GTT_PAGE_MASK;\n\t\tmem = i915->mm.regions[INTEL_REGION_LMEM_0];\n\n\t\t \n\t\tif (phys_base >= resource_size(&mem->region)) {\n\t\t\tdrm_err(&i915->drm,\n\t\t\t\t\"Initial plane programming using invalid range, phys_base=%pa\\n\",\n\t\t\t\t&phys_base);\n\t\t\treturn NULL;\n\t\t}\n\n\t\tdrm_dbg(&i915->drm,\n\t\t\t\"Using phys_base=%pa, based on initial plane programming\\n\",\n\t\t\t&phys_base);\n\t} else {\n\t\tphys_base = base;\n\t\tmem = i915->mm.stolen_region;\n\t}\n\n\tif (!mem)\n\t\treturn NULL;\n\n\tsize = round_up(plane_config->base + plane_config->size,\n\t\t\tmem->min_page_size);\n\tsize -= base;\n\n\t \n\tif (IS_ENABLED(CONFIG_FRAMEBUFFER_CONSOLE) &&\n\t    mem == i915->mm.stolen_region &&\n\t    size * 2 > i915->dsm.usable_size)\n\t\treturn NULL;\n\n\tobj = i915_gem_object_create_region_at(mem, phys_base, size,\n\t\t\t\t\t       I915_BO_ALLOC_USER |\n\t\t\t\t\t       I915_BO_PREALLOC);\n\tif (IS_ERR(obj))\n\t\treturn NULL;\n\n\t \n\ti915_gem_object_set_cache_coherency(obj, HAS_WT(i915) ?\n\t\t\t\t\t    I915_CACHE_WT : I915_CACHE_NONE);\n\n\tswitch (plane_config->tiling) {\n\tcase I915_TILING_NONE:\n\t\tbreak;\n\tcase I915_TILING_X:\n\tcase I915_TILING_Y:\n\t\tobj->tiling_and_stride =\n\t\t\tplane_config->fb->base.pitches[0] |\n\t\t\tplane_config->tiling;\n\t\tbreak;\n\tdefault:\n\t\tMISSING_CASE(plane_config->tiling);\n\t\tgoto err_obj;\n\t}\n\n\tvma = i915_vma_instance(obj, &to_gt(i915)->ggtt->vm, NULL);\n\tif (IS_ERR(vma))\n\t\tgoto err_obj;\n\n\tpinctl = PIN_GLOBAL | PIN_OFFSET_FIXED | base;\n\tif (HAS_GMCH(i915))\n\t\tpinctl |= PIN_MAPPABLE;\n\tif (i915_vma_pin(vma, 0, 0, pinctl))\n\t\tgoto err_obj;\n\n\tif (i915_gem_object_is_tiled(obj) &&\n\t    !i915_vma_is_map_and_fenceable(vma))\n\t\tgoto err_obj;\n\n\treturn vma;\n\nerr_obj:\n\ti915_gem_object_put(obj);\n\treturn NULL;\n}\n\nstatic bool\nintel_alloc_initial_plane_obj(struct intel_crtc *crtc,\n\t\t\t      struct intel_initial_plane_config *plane_config)\n{\n\tstruct drm_device *dev = crtc->base.dev;\n\tstruct drm_i915_private *dev_priv = to_i915(dev);\n\tstruct drm_mode_fb_cmd2 mode_cmd = { 0 };\n\tstruct drm_framebuffer *fb = &plane_config->fb->base;\n\tstruct i915_vma *vma;\n\n\tswitch (fb->modifier) {\n\tcase DRM_FORMAT_MOD_LINEAR:\n\tcase I915_FORMAT_MOD_X_TILED:\n\tcase I915_FORMAT_MOD_Y_TILED:\n\tcase I915_FORMAT_MOD_4_TILED:\n\t\tbreak;\n\tdefault:\n\t\tdrm_dbg(&dev_priv->drm,\n\t\t\t\"Unsupported modifier for initial FB: 0x%llx\\n\",\n\t\t\tfb->modifier);\n\t\treturn false;\n\t}\n\n\tvma = initial_plane_vma(dev_priv, plane_config);\n\tif (!vma)\n\t\treturn false;\n\n\tmode_cmd.pixel_format = fb->format->format;\n\tmode_cmd.width = fb->width;\n\tmode_cmd.height = fb->height;\n\tmode_cmd.pitches[0] = fb->pitches[0];\n\tmode_cmd.modifier[0] = fb->modifier;\n\tmode_cmd.flags = DRM_MODE_FB_MODIFIERS;\n\n\tif (intel_framebuffer_init(to_intel_framebuffer(fb),\n\t\t\t\t   vma->obj, &mode_cmd)) {\n\t\tdrm_dbg_kms(&dev_priv->drm, \"intel fb init failed\\n\");\n\t\tgoto err_vma;\n\t}\n\n\tplane_config->vma = vma;\n\treturn true;\n\nerr_vma:\n\ti915_vma_put(vma);\n\treturn false;\n}\n\nstatic void\nintel_find_initial_plane_obj(struct intel_crtc *crtc,\n\t\t\t     struct intel_initial_plane_config *plane_config)\n{\n\tstruct drm_device *dev = crtc->base.dev;\n\tstruct drm_i915_private *dev_priv = to_i915(dev);\n\tstruct intel_plane *plane =\n\t\tto_intel_plane(crtc->base.primary);\n\tstruct intel_plane_state *plane_state =\n\t\tto_intel_plane_state(plane->base.state);\n\tstruct drm_framebuffer *fb;\n\tstruct i915_vma *vma;\n\n\t \n\tif (!plane_config->fb)\n\t\treturn;\n\n\tif (intel_alloc_initial_plane_obj(crtc, plane_config)) {\n\t\tfb = &plane_config->fb->base;\n\t\tvma = plane_config->vma;\n\t\tgoto valid_fb;\n\t}\n\n\t \n\tif (intel_reuse_initial_plane_obj(dev_priv, plane_config, &fb, &vma))\n\t\tgoto valid_fb;\n\n\t \n\tintel_plane_disable_noatomic(crtc, plane);\n\n\treturn;\n\nvalid_fb:\n\tplane_state->uapi.rotation = plane_config->rotation;\n\tintel_fb_fill_view(to_intel_framebuffer(fb),\n\t\t\t   plane_state->uapi.rotation, &plane_state->view);\n\n\t__i915_vma_pin(vma);\n\tplane_state->ggtt_vma = i915_vma_get(vma);\n\tif (intel_plane_uses_fence(plane_state) &&\n\t    i915_vma_pin_fence(vma) == 0 && vma->fence)\n\t\tplane_state->flags |= PLANE_HAS_FENCE;\n\n\tplane_state->uapi.src_x = 0;\n\tplane_state->uapi.src_y = 0;\n\tplane_state->uapi.src_w = fb->width << 16;\n\tplane_state->uapi.src_h = fb->height << 16;\n\n\tplane_state->uapi.crtc_x = 0;\n\tplane_state->uapi.crtc_y = 0;\n\tplane_state->uapi.crtc_w = fb->width;\n\tplane_state->uapi.crtc_h = fb->height;\n\n\tif (plane_config->tiling)\n\t\tdev_priv->preserve_bios_swizzle = true;\n\n\tplane_state->uapi.fb = fb;\n\tdrm_framebuffer_get(fb);\n\n\tplane_state->uapi.crtc = &crtc->base;\n\tintel_plane_copy_uapi_to_hw_state(plane_state, plane_state, crtc);\n\n\tatomic_or(plane->frontbuffer_bit, &to_intel_frontbuffer(fb)->bits);\n}\n\nstatic void plane_config_fini(struct intel_initial_plane_config *plane_config)\n{\n\tif (plane_config->fb) {\n\t\tstruct drm_framebuffer *fb = &plane_config->fb->base;\n\n\t\t \n\t\tif (drm_framebuffer_read_refcount(fb))\n\t\t\tdrm_framebuffer_put(fb);\n\t\telse\n\t\t\tkfree(fb);\n\t}\n\n\tif (plane_config->vma)\n\t\ti915_vma_put(plane_config->vma);\n}\n\nvoid intel_crtc_initial_plane_config(struct intel_crtc *crtc)\n{\n\tstruct drm_i915_private *dev_priv = to_i915(crtc->base.dev);\n\tstruct intel_initial_plane_config plane_config = {};\n\n\t \n\tdev_priv->display.funcs.display->get_initial_plane_config(crtc, &plane_config);\n\n\t \n\tintel_find_initial_plane_obj(crtc, &plane_config);\n\n\tplane_config_fini(&plane_config);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}