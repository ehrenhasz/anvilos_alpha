{
  "module_name": "g4x_hdmi.c",
  "hash_id": "4fb28d7c5c13814a2aaab4418fde52e11531fd919dd568d067f870c7817cb35f",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/i915/display/g4x_hdmi.c",
  "human_readable_source": "\n \n\n#include \"g4x_hdmi.h\"\n#include \"i915_reg.h\"\n#include \"intel_atomic.h\"\n#include \"intel_audio.h\"\n#include \"intel_connector.h\"\n#include \"intel_crtc.h\"\n#include \"intel_de.h\"\n#include \"intel_display_power.h\"\n#include \"intel_display_types.h\"\n#include \"intel_dp_aux.h\"\n#include \"intel_dpio_phy.h\"\n#include \"intel_fifo_underrun.h\"\n#include \"intel_hdmi.h\"\n#include \"intel_hotplug.h\"\n#include \"intel_sdvo.h\"\n#include \"vlv_sideband.h\"\n\nstatic void intel_hdmi_prepare(struct intel_encoder *encoder,\n\t\t\t       const struct intel_crtc_state *crtc_state)\n{\n\tstruct drm_device *dev = encoder->base.dev;\n\tstruct drm_i915_private *dev_priv = to_i915(dev);\n\tstruct intel_crtc *crtc = to_intel_crtc(crtc_state->uapi.crtc);\n\tstruct intel_hdmi *intel_hdmi = enc_to_intel_hdmi(encoder);\n\tconst struct drm_display_mode *adjusted_mode = &crtc_state->hw.adjusted_mode;\n\tu32 hdmi_val;\n\n\tintel_dp_dual_mode_set_tmds_output(intel_hdmi, true);\n\n\thdmi_val = SDVO_ENCODING_HDMI;\n\tif (!HAS_PCH_SPLIT(dev_priv) && crtc_state->limited_color_range)\n\t\thdmi_val |= HDMI_COLOR_RANGE_16_235;\n\tif (adjusted_mode->flags & DRM_MODE_FLAG_PVSYNC)\n\t\thdmi_val |= SDVO_VSYNC_ACTIVE_HIGH;\n\tif (adjusted_mode->flags & DRM_MODE_FLAG_PHSYNC)\n\t\thdmi_val |= SDVO_HSYNC_ACTIVE_HIGH;\n\n\tif (crtc_state->pipe_bpp > 24)\n\t\thdmi_val |= HDMI_COLOR_FORMAT_12bpc;\n\telse\n\t\thdmi_val |= SDVO_COLOR_FORMAT_8bpc;\n\n\tif (crtc_state->has_hdmi_sink)\n\t\thdmi_val |= HDMI_MODE_SELECT_HDMI;\n\n\tif (HAS_PCH_CPT(dev_priv))\n\t\thdmi_val |= SDVO_PIPE_SEL_CPT(crtc->pipe);\n\telse if (IS_CHERRYVIEW(dev_priv))\n\t\thdmi_val |= SDVO_PIPE_SEL_CHV(crtc->pipe);\n\telse\n\t\thdmi_val |= SDVO_PIPE_SEL(crtc->pipe);\n\n\tintel_de_write(dev_priv, intel_hdmi->hdmi_reg, hdmi_val);\n\tintel_de_posting_read(dev_priv, intel_hdmi->hdmi_reg);\n}\n\nstatic bool intel_hdmi_get_hw_state(struct intel_encoder *encoder,\n\t\t\t\t    enum pipe *pipe)\n{\n\tstruct drm_i915_private *dev_priv = to_i915(encoder->base.dev);\n\tstruct intel_hdmi *intel_hdmi = enc_to_intel_hdmi(encoder);\n\tintel_wakeref_t wakeref;\n\tbool ret;\n\n\twakeref = intel_display_power_get_if_enabled(dev_priv,\n\t\t\t\t\t\t     encoder->power_domain);\n\tif (!wakeref)\n\t\treturn false;\n\n\tret = intel_sdvo_port_enabled(dev_priv, intel_hdmi->hdmi_reg, pipe);\n\n\tintel_display_power_put(dev_priv, encoder->power_domain, wakeref);\n\n\treturn ret;\n}\n\nstatic bool connector_is_hdmi(struct drm_connector *connector)\n{\n\tstruct intel_encoder *encoder =\n\t\tintel_attached_encoder(to_intel_connector(connector));\n\n\treturn encoder && encoder->type == INTEL_OUTPUT_HDMI;\n}\n\nstatic bool g4x_compute_has_hdmi_sink(struct intel_atomic_state *state,\n\t\t\t\t      struct intel_crtc *this_crtc)\n{\n\tconst struct drm_connector_state *conn_state;\n\tstruct drm_connector *connector;\n\tint i;\n\n\t \n\tfor_each_new_connector_in_state(&state->base, connector, conn_state, i) {\n\t\tstruct intel_encoder *encoder = to_intel_encoder(conn_state->best_encoder);\n\t\tconst struct intel_crtc_state *crtc_state;\n\t\tstruct intel_crtc *crtc;\n\n\t\tif (!connector_is_hdmi(connector))\n\t\t\tcontinue;\n\n\t\tcrtc = to_intel_crtc(conn_state->crtc);\n\t\tif (!crtc)\n\t\t\tcontinue;\n\n\t\tcrtc_state = intel_atomic_get_new_crtc_state(state, crtc);\n\n\t\tif (!intel_hdmi_compute_has_hdmi_sink(encoder, crtc_state, conn_state))\n\t\t\tcontinue;\n\n\t\treturn crtc == this_crtc;\n\t}\n\n\treturn false;\n}\n\nstatic int g4x_hdmi_compute_config(struct intel_encoder *encoder,\n\t\t\t\t   struct intel_crtc_state *crtc_state,\n\t\t\t\t   struct drm_connector_state *conn_state)\n{\n\tstruct intel_atomic_state *state = to_intel_atomic_state(crtc_state->uapi.state);\n\tstruct intel_crtc *crtc = to_intel_crtc(crtc_state->uapi.crtc);\n\tstruct drm_i915_private *i915 = to_i915(encoder->base.dev);\n\n\tif (HAS_PCH_SPLIT(i915))\n\t\tcrtc_state->has_pch_encoder = true;\n\n\tif (IS_G4X(i915))\n\t\tcrtc_state->has_hdmi_sink = g4x_compute_has_hdmi_sink(state, crtc);\n\telse\n\t\tcrtc_state->has_hdmi_sink =\n\t\t\tintel_hdmi_compute_has_hdmi_sink(encoder, crtc_state, conn_state);\n\n\treturn intel_hdmi_compute_config(encoder, crtc_state, conn_state);\n}\n\nstatic void intel_hdmi_get_config(struct intel_encoder *encoder,\n\t\t\t\t  struct intel_crtc_state *pipe_config)\n{\n\tstruct intel_hdmi *intel_hdmi = enc_to_intel_hdmi(encoder);\n\tstruct drm_device *dev = encoder->base.dev;\n\tstruct drm_i915_private *dev_priv = to_i915(dev);\n\tu32 tmp, flags = 0;\n\tint dotclock;\n\n\tpipe_config->output_types |= BIT(INTEL_OUTPUT_HDMI);\n\n\ttmp = intel_de_read(dev_priv, intel_hdmi->hdmi_reg);\n\n\tif (tmp & SDVO_HSYNC_ACTIVE_HIGH)\n\t\tflags |= DRM_MODE_FLAG_PHSYNC;\n\telse\n\t\tflags |= DRM_MODE_FLAG_NHSYNC;\n\n\tif (tmp & SDVO_VSYNC_ACTIVE_HIGH)\n\t\tflags |= DRM_MODE_FLAG_PVSYNC;\n\telse\n\t\tflags |= DRM_MODE_FLAG_NVSYNC;\n\n\tif (tmp & HDMI_MODE_SELECT_HDMI)\n\t\tpipe_config->has_hdmi_sink = true;\n\n\tpipe_config->infoframes.enable |=\n\t\tintel_hdmi_infoframes_enabled(encoder, pipe_config);\n\n\tif (pipe_config->infoframes.enable)\n\t\tpipe_config->has_infoframe = true;\n\n\tif (tmp & HDMI_AUDIO_ENABLE)\n\t\tpipe_config->has_audio = true;\n\n\tif (!HAS_PCH_SPLIT(dev_priv) &&\n\t    tmp & HDMI_COLOR_RANGE_16_235)\n\t\tpipe_config->limited_color_range = true;\n\n\tpipe_config->hw.adjusted_mode.flags |= flags;\n\n\tif ((tmp & SDVO_COLOR_FORMAT_MASK) == HDMI_COLOR_FORMAT_12bpc)\n\t\tdotclock = DIV_ROUND_CLOSEST(pipe_config->port_clock * 2, 3);\n\telse\n\t\tdotclock = pipe_config->port_clock;\n\n\tif (pipe_config->pixel_multiplier)\n\t\tdotclock /= pipe_config->pixel_multiplier;\n\n\tpipe_config->hw.adjusted_mode.crtc_clock = dotclock;\n\n\tpipe_config->lane_count = 4;\n\n\tintel_hdmi_read_gcp_infoframe(encoder, pipe_config);\n\n\tintel_read_infoframe(encoder, pipe_config,\n\t\t\t     HDMI_INFOFRAME_TYPE_AVI,\n\t\t\t     &pipe_config->infoframes.avi);\n\tintel_read_infoframe(encoder, pipe_config,\n\t\t\t     HDMI_INFOFRAME_TYPE_SPD,\n\t\t\t     &pipe_config->infoframes.spd);\n\tintel_read_infoframe(encoder, pipe_config,\n\t\t\t     HDMI_INFOFRAME_TYPE_VENDOR,\n\t\t\t     &pipe_config->infoframes.hdmi);\n\n\tintel_audio_codec_get_config(encoder, pipe_config);\n}\n\nstatic void g4x_hdmi_enable_port(struct intel_encoder *encoder,\n\t\t\t\t const struct intel_crtc_state *pipe_config)\n{\n\tstruct drm_device *dev = encoder->base.dev;\n\tstruct drm_i915_private *dev_priv = to_i915(dev);\n\tstruct intel_hdmi *intel_hdmi = enc_to_intel_hdmi(encoder);\n\tu32 temp;\n\n\ttemp = intel_de_read(dev_priv, intel_hdmi->hdmi_reg);\n\n\ttemp |= SDVO_ENABLE;\n\tif (pipe_config->has_audio)\n\t\ttemp |= HDMI_AUDIO_ENABLE;\n\n\tintel_de_write(dev_priv, intel_hdmi->hdmi_reg, temp);\n\tintel_de_posting_read(dev_priv, intel_hdmi->hdmi_reg);\n}\n\nstatic void g4x_enable_hdmi(struct intel_atomic_state *state,\n\t\t\t    struct intel_encoder *encoder,\n\t\t\t    const struct intel_crtc_state *pipe_config,\n\t\t\t    const struct drm_connector_state *conn_state)\n{\n\tstruct drm_i915_private *dev_priv = to_i915(encoder->base.dev);\n\n\tg4x_hdmi_enable_port(encoder, pipe_config);\n\n\tdrm_WARN_ON(&dev_priv->drm, pipe_config->has_audio &&\n\t\t    !pipe_config->has_hdmi_sink);\n\tintel_audio_codec_enable(encoder, pipe_config, conn_state);\n}\n\nstatic void ibx_enable_hdmi(struct intel_atomic_state *state,\n\t\t\t    struct intel_encoder *encoder,\n\t\t\t    const struct intel_crtc_state *pipe_config,\n\t\t\t    const struct drm_connector_state *conn_state)\n{\n\tstruct drm_device *dev = encoder->base.dev;\n\tstruct drm_i915_private *dev_priv = to_i915(dev);\n\tstruct intel_hdmi *intel_hdmi = enc_to_intel_hdmi(encoder);\n\tu32 temp;\n\n\ttemp = intel_de_read(dev_priv, intel_hdmi->hdmi_reg);\n\n\ttemp |= SDVO_ENABLE;\n\tif (pipe_config->has_audio)\n\t\ttemp |= HDMI_AUDIO_ENABLE;\n\n\t \n\tintel_de_write(dev_priv, intel_hdmi->hdmi_reg, temp);\n\tintel_de_posting_read(dev_priv, intel_hdmi->hdmi_reg);\n\tintel_de_write(dev_priv, intel_hdmi->hdmi_reg, temp);\n\tintel_de_posting_read(dev_priv, intel_hdmi->hdmi_reg);\n\n\t \n\tif (pipe_config->pipe_bpp > 24 &&\n\t    pipe_config->pixel_multiplier > 1) {\n\t\tintel_de_write(dev_priv, intel_hdmi->hdmi_reg,\n\t\t\t       temp & ~SDVO_ENABLE);\n\t\tintel_de_posting_read(dev_priv, intel_hdmi->hdmi_reg);\n\n\t\t \n\t\tintel_de_write(dev_priv, intel_hdmi->hdmi_reg, temp);\n\t\tintel_de_posting_read(dev_priv, intel_hdmi->hdmi_reg);\n\t\tintel_de_write(dev_priv, intel_hdmi->hdmi_reg, temp);\n\t\tintel_de_posting_read(dev_priv, intel_hdmi->hdmi_reg);\n\t}\n\n\tdrm_WARN_ON(&dev_priv->drm, pipe_config->has_audio &&\n\t\t    !pipe_config->has_hdmi_sink);\n\tintel_audio_codec_enable(encoder, pipe_config, conn_state);\n}\n\nstatic void cpt_enable_hdmi(struct intel_atomic_state *state,\n\t\t\t    struct intel_encoder *encoder,\n\t\t\t    const struct intel_crtc_state *pipe_config,\n\t\t\t    const struct drm_connector_state *conn_state)\n{\n\tstruct drm_device *dev = encoder->base.dev;\n\tstruct drm_i915_private *dev_priv = to_i915(dev);\n\tstruct intel_crtc *crtc = to_intel_crtc(pipe_config->uapi.crtc);\n\tstruct intel_hdmi *intel_hdmi = enc_to_intel_hdmi(encoder);\n\tenum pipe pipe = crtc->pipe;\n\tu32 temp;\n\n\ttemp = intel_de_read(dev_priv, intel_hdmi->hdmi_reg);\n\n\ttemp |= SDVO_ENABLE;\n\tif (pipe_config->has_audio)\n\t\ttemp |= HDMI_AUDIO_ENABLE;\n\n\t \n\n\tif (pipe_config->pipe_bpp > 24) {\n\t\tintel_de_rmw(dev_priv, TRANS_CHICKEN1(pipe),\n\t\t\t     0, TRANS_CHICKEN1_HDMIUNIT_GC_DISABLE);\n\n\t\ttemp &= ~SDVO_COLOR_FORMAT_MASK;\n\t\ttemp |= SDVO_COLOR_FORMAT_8bpc;\n\t}\n\n\tintel_de_write(dev_priv, intel_hdmi->hdmi_reg, temp);\n\tintel_de_posting_read(dev_priv, intel_hdmi->hdmi_reg);\n\n\tif (pipe_config->pipe_bpp > 24) {\n\t\ttemp &= ~SDVO_COLOR_FORMAT_MASK;\n\t\ttemp |= HDMI_COLOR_FORMAT_12bpc;\n\n\t\tintel_de_write(dev_priv, intel_hdmi->hdmi_reg, temp);\n\t\tintel_de_posting_read(dev_priv, intel_hdmi->hdmi_reg);\n\n\t\tintel_de_rmw(dev_priv, TRANS_CHICKEN1(pipe),\n\t\t\t     TRANS_CHICKEN1_HDMIUNIT_GC_DISABLE, 0);\n\t}\n\n\tdrm_WARN_ON(&dev_priv->drm, pipe_config->has_audio &&\n\t\t    !pipe_config->has_hdmi_sink);\n\tintel_audio_codec_enable(encoder, pipe_config, conn_state);\n}\n\nstatic void vlv_enable_hdmi(struct intel_atomic_state *state,\n\t\t\t    struct intel_encoder *encoder,\n\t\t\t    const struct intel_crtc_state *pipe_config,\n\t\t\t    const struct drm_connector_state *conn_state)\n{\n\tstruct drm_i915_private *dev_priv = to_i915(encoder->base.dev);\n\n\tdrm_WARN_ON(&dev_priv->drm, pipe_config->has_audio &&\n\t\t    !pipe_config->has_hdmi_sink);\n\tintel_audio_codec_enable(encoder, pipe_config, conn_state);\n}\n\nstatic void intel_disable_hdmi(struct intel_atomic_state *state,\n\t\t\t       struct intel_encoder *encoder,\n\t\t\t       const struct intel_crtc_state *old_crtc_state,\n\t\t\t       const struct drm_connector_state *old_conn_state)\n{\n\tstruct drm_device *dev = encoder->base.dev;\n\tstruct drm_i915_private *dev_priv = to_i915(dev);\n\tstruct intel_hdmi *intel_hdmi = enc_to_intel_hdmi(encoder);\n\tstruct intel_digital_port *dig_port =\n\t\thdmi_to_dig_port(intel_hdmi);\n\tstruct intel_crtc *crtc = to_intel_crtc(old_crtc_state->uapi.crtc);\n\tu32 temp;\n\n\ttemp = intel_de_read(dev_priv, intel_hdmi->hdmi_reg);\n\n\ttemp &= ~(SDVO_ENABLE | HDMI_AUDIO_ENABLE);\n\tintel_de_write(dev_priv, intel_hdmi->hdmi_reg, temp);\n\tintel_de_posting_read(dev_priv, intel_hdmi->hdmi_reg);\n\n\t \n\tif (HAS_PCH_IBX(dev_priv) && crtc->pipe == PIPE_B) {\n\t\t \n\t\tintel_set_cpu_fifo_underrun_reporting(dev_priv, PIPE_A, false);\n\t\tintel_set_pch_fifo_underrun_reporting(dev_priv, PIPE_A, false);\n\n\t\ttemp &= ~SDVO_PIPE_SEL_MASK;\n\t\ttemp |= SDVO_ENABLE | SDVO_PIPE_SEL(PIPE_A);\n\t\t \n\t\tintel_de_write(dev_priv, intel_hdmi->hdmi_reg, temp);\n\t\tintel_de_posting_read(dev_priv, intel_hdmi->hdmi_reg);\n\t\tintel_de_write(dev_priv, intel_hdmi->hdmi_reg, temp);\n\t\tintel_de_posting_read(dev_priv, intel_hdmi->hdmi_reg);\n\n\t\ttemp &= ~SDVO_ENABLE;\n\t\tintel_de_write(dev_priv, intel_hdmi->hdmi_reg, temp);\n\t\tintel_de_posting_read(dev_priv, intel_hdmi->hdmi_reg);\n\n\t\tintel_wait_for_vblank_if_active(dev_priv, PIPE_A);\n\t\tintel_set_cpu_fifo_underrun_reporting(dev_priv, PIPE_A, true);\n\t\tintel_set_pch_fifo_underrun_reporting(dev_priv, PIPE_A, true);\n\t}\n\n\tdig_port->set_infoframes(encoder,\n\t\t\t\t       false,\n\t\t\t\t       old_crtc_state, old_conn_state);\n\n\tintel_dp_dual_mode_set_tmds_output(intel_hdmi, false);\n}\n\nstatic void g4x_disable_hdmi(struct intel_atomic_state *state,\n\t\t\t     struct intel_encoder *encoder,\n\t\t\t     const struct intel_crtc_state *old_crtc_state,\n\t\t\t     const struct drm_connector_state *old_conn_state)\n{\n\tintel_audio_codec_disable(encoder, old_crtc_state, old_conn_state);\n\n\tintel_disable_hdmi(state, encoder, old_crtc_state, old_conn_state);\n}\n\nstatic void pch_disable_hdmi(struct intel_atomic_state *state,\n\t\t\t     struct intel_encoder *encoder,\n\t\t\t     const struct intel_crtc_state *old_crtc_state,\n\t\t\t     const struct drm_connector_state *old_conn_state)\n{\n\tintel_audio_codec_disable(encoder, old_crtc_state, old_conn_state);\n}\n\nstatic void pch_post_disable_hdmi(struct intel_atomic_state *state,\n\t\t\t\t  struct intel_encoder *encoder,\n\t\t\t\t  const struct intel_crtc_state *old_crtc_state,\n\t\t\t\t  const struct drm_connector_state *old_conn_state)\n{\n\tintel_disable_hdmi(state, encoder, old_crtc_state, old_conn_state);\n}\n\nstatic void intel_hdmi_pre_enable(struct intel_atomic_state *state,\n\t\t\t\t  struct intel_encoder *encoder,\n\t\t\t\t  const struct intel_crtc_state *pipe_config,\n\t\t\t\t  const struct drm_connector_state *conn_state)\n{\n\tstruct intel_digital_port *dig_port =\n\t\tenc_to_dig_port(encoder);\n\n\tintel_hdmi_prepare(encoder, pipe_config);\n\n\tdig_port->set_infoframes(encoder,\n\t\t\t\t       pipe_config->has_infoframe,\n\t\t\t\t       pipe_config, conn_state);\n}\n\nstatic void vlv_hdmi_pre_enable(struct intel_atomic_state *state,\n\t\t\t\tstruct intel_encoder *encoder,\n\t\t\t\tconst struct intel_crtc_state *pipe_config,\n\t\t\t\tconst struct drm_connector_state *conn_state)\n{\n\tstruct intel_digital_port *dig_port = enc_to_dig_port(encoder);\n\tstruct drm_i915_private *dev_priv = to_i915(encoder->base.dev);\n\n\tvlv_phy_pre_encoder_enable(encoder, pipe_config);\n\n\t \n\tvlv_set_phy_signal_level(encoder, pipe_config,\n\t\t\t\t 0x2b245f5f, 0x00002000,\n\t\t\t\t 0x5578b83a, 0x2b247878);\n\n\tdig_port->set_infoframes(encoder,\n\t\t\t      pipe_config->has_infoframe,\n\t\t\t      pipe_config, conn_state);\n\n\tg4x_hdmi_enable_port(encoder, pipe_config);\n\n\tvlv_wait_port_ready(dev_priv, dig_port, 0x0);\n}\n\nstatic void vlv_hdmi_pre_pll_enable(struct intel_atomic_state *state,\n\t\t\t\t    struct intel_encoder *encoder,\n\t\t\t\t    const struct intel_crtc_state *pipe_config,\n\t\t\t\t    const struct drm_connector_state *conn_state)\n{\n\tintel_hdmi_prepare(encoder, pipe_config);\n\n\tvlv_phy_pre_pll_enable(encoder, pipe_config);\n}\n\nstatic void chv_hdmi_pre_pll_enable(struct intel_atomic_state *state,\n\t\t\t\t    struct intel_encoder *encoder,\n\t\t\t\t    const struct intel_crtc_state *pipe_config,\n\t\t\t\t    const struct drm_connector_state *conn_state)\n{\n\tintel_hdmi_prepare(encoder, pipe_config);\n\n\tchv_phy_pre_pll_enable(encoder, pipe_config);\n}\n\nstatic void chv_hdmi_post_pll_disable(struct intel_atomic_state *state,\n\t\t\t\t      struct intel_encoder *encoder,\n\t\t\t\t      const struct intel_crtc_state *old_crtc_state,\n\t\t\t\t      const struct drm_connector_state *old_conn_state)\n{\n\tchv_phy_post_pll_disable(encoder, old_crtc_state);\n}\n\nstatic void vlv_hdmi_post_disable(struct intel_atomic_state *state,\n\t\t\t\t  struct intel_encoder *encoder,\n\t\t\t\t  const struct intel_crtc_state *old_crtc_state,\n\t\t\t\t  const struct drm_connector_state *old_conn_state)\n{\n\t \n\tvlv_phy_reset_lanes(encoder, old_crtc_state);\n}\n\nstatic void chv_hdmi_post_disable(struct intel_atomic_state *state,\n\t\t\t\t  struct intel_encoder *encoder,\n\t\t\t\t  const struct intel_crtc_state *old_crtc_state,\n\t\t\t\t  const struct drm_connector_state *old_conn_state)\n{\n\tstruct drm_device *dev = encoder->base.dev;\n\tstruct drm_i915_private *dev_priv = to_i915(dev);\n\n\tvlv_dpio_get(dev_priv);\n\n\t \n\tchv_data_lane_soft_reset(encoder, old_crtc_state, true);\n\n\tvlv_dpio_put(dev_priv);\n}\n\nstatic void chv_hdmi_pre_enable(struct intel_atomic_state *state,\n\t\t\t\tstruct intel_encoder *encoder,\n\t\t\t\tconst struct intel_crtc_state *pipe_config,\n\t\t\t\tconst struct drm_connector_state *conn_state)\n{\n\tstruct intel_digital_port *dig_port = enc_to_dig_port(encoder);\n\tstruct drm_device *dev = encoder->base.dev;\n\tstruct drm_i915_private *dev_priv = to_i915(dev);\n\n\tchv_phy_pre_encoder_enable(encoder, pipe_config);\n\n\t \n\t \n\tchv_set_phy_signal_level(encoder, pipe_config, 128, 102, false);\n\n\tdig_port->set_infoframes(encoder,\n\t\t\t      pipe_config->has_infoframe,\n\t\t\t      pipe_config, conn_state);\n\n\tg4x_hdmi_enable_port(encoder, pipe_config);\n\n\tvlv_wait_port_ready(dev_priv, dig_port, 0x0);\n\n\t \n\tchv_phy_release_cl2_override(encoder);\n}\n\nstatic const struct drm_encoder_funcs intel_hdmi_enc_funcs = {\n\t.destroy = intel_encoder_destroy,\n};\n\nstatic enum intel_hotplug_state\nintel_hdmi_hotplug(struct intel_encoder *encoder,\n\t\t   struct intel_connector *connector)\n{\n\tenum intel_hotplug_state state;\n\n\tstate = intel_encoder_hotplug(encoder, connector);\n\n\t \n\tif (state == INTEL_HOTPLUG_UNCHANGED && !connector->hotplug_retries)\n\t\tstate = INTEL_HOTPLUG_RETRY;\n\n\treturn state;\n}\n\nint g4x_hdmi_connector_atomic_check(struct drm_connector *connector,\n\t\t\t\t    struct drm_atomic_state *state)\n{\n\tstruct drm_i915_private *i915 = to_i915(state->dev);\n\tstruct drm_connector_list_iter conn_iter;\n\tstruct drm_connector *conn;\n\tint ret;\n\n\tret = intel_digital_connector_atomic_check(connector, state);\n\tif (ret)\n\t\treturn ret;\n\n\tif (!IS_G4X(i915))\n\t\treturn 0;\n\n\tif (!intel_connector_needs_modeset(to_intel_atomic_state(state), connector))\n\t\treturn 0;\n\n\t \n\tdrm_connector_list_iter_begin(&i915->drm, &conn_iter);\n\tdrm_for_each_connector_iter(conn, &conn_iter) {\n\t\tstruct drm_connector_state *conn_state;\n\t\tstruct drm_crtc_state *crtc_state;\n\t\tstruct drm_crtc *crtc;\n\n\t\tif (!connector_is_hdmi(conn))\n\t\t\tcontinue;\n\n\t\tdrm_dbg_kms(&i915->drm, \"Adding [CONNECTOR:%d:%s]\\n\",\n\t\t\t    conn->base.id, conn->name);\n\n\t\tconn_state = drm_atomic_get_connector_state(state, conn);\n\t\tif (IS_ERR(conn_state)) {\n\t\t\tret = PTR_ERR(conn_state);\n\t\t\tbreak;\n\t\t}\n\n\t\tcrtc = conn_state->crtc;\n\t\tif (!crtc)\n\t\t\tcontinue;\n\n\t\tcrtc_state = drm_atomic_get_new_crtc_state(state, crtc);\n\t\tcrtc_state->mode_changed = true;\n\n\t\tret = drm_atomic_add_affected_planes(state, crtc);\n\t\tif (ret)\n\t\t\tbreak;\n\t}\n\tdrm_connector_list_iter_end(&conn_iter);\n\n\treturn ret;\n}\n\nstatic bool is_hdmi_port_valid(struct drm_i915_private *i915, enum port port)\n{\n\tif (IS_G4X(i915) || IS_VALLEYVIEW(i915))\n\t\treturn port == PORT_B || port == PORT_C;\n\telse\n\t\treturn port == PORT_B || port == PORT_C || port == PORT_D;\n}\n\nstatic bool assert_hdmi_port_valid(struct drm_i915_private *i915, enum port port)\n{\n\treturn !drm_WARN(&i915->drm, !is_hdmi_port_valid(i915, port),\n\t\t\t \"Platform does not support HDMI %c\\n\", port_name(port));\n}\n\nvoid g4x_hdmi_init(struct drm_i915_private *dev_priv,\n\t\t   i915_reg_t hdmi_reg, enum port port)\n{\n\tconst struct intel_bios_encoder_data *devdata;\n\tstruct intel_digital_port *dig_port;\n\tstruct intel_encoder *intel_encoder;\n\tstruct intel_connector *intel_connector;\n\n\tif (!assert_port_valid(dev_priv, port))\n\t\treturn;\n\n\tif (!assert_hdmi_port_valid(dev_priv, port))\n\t\treturn;\n\n\tdevdata = intel_bios_encoder_data_lookup(dev_priv, port);\n\n\t \n\tif (!devdata)\n\t\tdrm_dbg_kms(&dev_priv->drm, \"No VBT child device for HDMI-%c\\n\",\n\t\t\t    port_name(port));\n\n\tdig_port = kzalloc(sizeof(*dig_port), GFP_KERNEL);\n\tif (!dig_port)\n\t\treturn;\n\n\tdig_port->aux_ch = AUX_CH_NONE;\n\n\tintel_connector = intel_connector_alloc();\n\tif (!intel_connector) {\n\t\tkfree(dig_port);\n\t\treturn;\n\t}\n\n\tintel_encoder = &dig_port->base;\n\n\tintel_encoder->devdata = devdata;\n\n\tmutex_init(&dig_port->hdcp_mutex);\n\n\tdrm_encoder_init(&dev_priv->drm, &intel_encoder->base,\n\t\t\t &intel_hdmi_enc_funcs, DRM_MODE_ENCODER_TMDS,\n\t\t\t \"HDMI %c\", port_name(port));\n\n\tintel_encoder->hotplug = intel_hdmi_hotplug;\n\tintel_encoder->compute_config = g4x_hdmi_compute_config;\n\tif (HAS_PCH_SPLIT(dev_priv)) {\n\t\tintel_encoder->disable = pch_disable_hdmi;\n\t\tintel_encoder->post_disable = pch_post_disable_hdmi;\n\t} else {\n\t\tintel_encoder->disable = g4x_disable_hdmi;\n\t}\n\tintel_encoder->get_hw_state = intel_hdmi_get_hw_state;\n\tintel_encoder->get_config = intel_hdmi_get_config;\n\tif (IS_CHERRYVIEW(dev_priv)) {\n\t\tintel_encoder->pre_pll_enable = chv_hdmi_pre_pll_enable;\n\t\tintel_encoder->pre_enable = chv_hdmi_pre_enable;\n\t\tintel_encoder->enable = vlv_enable_hdmi;\n\t\tintel_encoder->post_disable = chv_hdmi_post_disable;\n\t\tintel_encoder->post_pll_disable = chv_hdmi_post_pll_disable;\n\t} else if (IS_VALLEYVIEW(dev_priv)) {\n\t\tintel_encoder->pre_pll_enable = vlv_hdmi_pre_pll_enable;\n\t\tintel_encoder->pre_enable = vlv_hdmi_pre_enable;\n\t\tintel_encoder->enable = vlv_enable_hdmi;\n\t\tintel_encoder->post_disable = vlv_hdmi_post_disable;\n\t} else {\n\t\tintel_encoder->pre_enable = intel_hdmi_pre_enable;\n\t\tif (HAS_PCH_CPT(dev_priv))\n\t\t\tintel_encoder->enable = cpt_enable_hdmi;\n\t\telse if (HAS_PCH_IBX(dev_priv))\n\t\t\tintel_encoder->enable = ibx_enable_hdmi;\n\t\telse\n\t\t\tintel_encoder->enable = g4x_enable_hdmi;\n\t}\n\tintel_encoder->shutdown = intel_hdmi_encoder_shutdown;\n\n\tintel_encoder->type = INTEL_OUTPUT_HDMI;\n\tintel_encoder->power_domain = intel_display_power_ddi_lanes_domain(dev_priv, port);\n\tintel_encoder->port = port;\n\tif (IS_CHERRYVIEW(dev_priv)) {\n\t\tif (port == PORT_D)\n\t\t\tintel_encoder->pipe_mask = BIT(PIPE_C);\n\t\telse\n\t\t\tintel_encoder->pipe_mask = BIT(PIPE_A) | BIT(PIPE_B);\n\t} else {\n\t\tintel_encoder->pipe_mask = ~0;\n\t}\n\tintel_encoder->cloneable = BIT(INTEL_OUTPUT_ANALOG);\n\tintel_encoder->hpd_pin = intel_hpd_pin_default(dev_priv, port);\n\t \n\tif (IS_G4X(dev_priv))\n\t\tintel_encoder->cloneable |= BIT(INTEL_OUTPUT_HDMI);\n\n\tdig_port->hdmi.hdmi_reg = hdmi_reg;\n\tdig_port->dp.output_reg = INVALID_MMIO_REG;\n\tdig_port->max_lanes = 4;\n\n\tintel_infoframe_init(dig_port);\n\n\tintel_hdmi_init_connector(dig_port, intel_connector);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}