{
  "module_name": "intel_drrs.c",
  "hash_id": "e27a7ccad16b1df7172a1d85770537f8afd10635eb64f69bb4c779301935039c",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/i915/display/intel_drrs.c",
  "human_readable_source": "\n \n\n#include \"i915_drv.h\"\n#include \"i915_reg.h\"\n#include \"intel_atomic.h\"\n#include \"intel_de.h\"\n#include \"intel_display_types.h\"\n#include \"intel_drrs.h\"\n#include \"intel_panel.h\"\n\n \n\nconst char *intel_drrs_type_str(enum drrs_type drrs_type)\n{\n\tstatic const char * const str[] = {\n\t\t[DRRS_TYPE_NONE] = \"none\",\n\t\t[DRRS_TYPE_STATIC] = \"static\",\n\t\t[DRRS_TYPE_SEAMLESS] = \"seamless\",\n\t};\n\n\tif (drrs_type >= ARRAY_SIZE(str))\n\t\treturn \"<invalid>\";\n\n\treturn str[drrs_type];\n}\n\nstatic void\nintel_drrs_set_refresh_rate_pipeconf(struct intel_crtc *crtc,\n\t\t\t\t     enum drrs_refresh_rate refresh_rate)\n{\n\tstruct drm_i915_private *dev_priv = to_i915(crtc->base.dev);\n\tenum transcoder cpu_transcoder = crtc->drrs.cpu_transcoder;\n\tu32 bit;\n\n\tif (IS_VALLEYVIEW(dev_priv) || IS_CHERRYVIEW(dev_priv))\n\t\tbit = TRANSCONF_REFRESH_RATE_ALT_VLV;\n\telse\n\t\tbit = TRANSCONF_REFRESH_RATE_ALT_ILK;\n\n\tintel_de_rmw(dev_priv, TRANSCONF(cpu_transcoder),\n\t\t     bit, refresh_rate == DRRS_REFRESH_RATE_LOW ? bit : 0);\n}\n\nstatic void\nintel_drrs_set_refresh_rate_m_n(struct intel_crtc *crtc,\n\t\t\t\tenum drrs_refresh_rate refresh_rate)\n{\n\tintel_cpu_transcoder_set_m1_n1(crtc, crtc->drrs.cpu_transcoder,\n\t\t\t\t       refresh_rate == DRRS_REFRESH_RATE_LOW ?\n\t\t\t\t       &crtc->drrs.m2_n2 : &crtc->drrs.m_n);\n}\n\nbool intel_drrs_is_active(struct intel_crtc *crtc)\n{\n\treturn crtc->drrs.cpu_transcoder != INVALID_TRANSCODER;\n}\n\nstatic void intel_drrs_set_state(struct intel_crtc *crtc,\n\t\t\t\t enum drrs_refresh_rate refresh_rate)\n{\n\tstruct drm_i915_private *dev_priv = to_i915(crtc->base.dev);\n\n\tif (refresh_rate == crtc->drrs.refresh_rate)\n\t\treturn;\n\n\tif (intel_cpu_transcoder_has_m2_n2(dev_priv, crtc->drrs.cpu_transcoder))\n\t\tintel_drrs_set_refresh_rate_pipeconf(crtc, refresh_rate);\n\telse\n\t\tintel_drrs_set_refresh_rate_m_n(crtc, refresh_rate);\n\n\tcrtc->drrs.refresh_rate = refresh_rate;\n}\n\nstatic void intel_drrs_schedule_work(struct intel_crtc *crtc)\n{\n\tstruct drm_i915_private *i915 = to_i915(crtc->base.dev);\n\n\tmod_delayed_work(i915->unordered_wq, &crtc->drrs.work, msecs_to_jiffies(1000));\n}\n\nstatic unsigned int intel_drrs_frontbuffer_bits(const struct intel_crtc_state *crtc_state)\n{\n\tstruct intel_crtc *crtc = to_intel_crtc(crtc_state->uapi.crtc);\n\tstruct drm_i915_private *i915 = to_i915(crtc->base.dev);\n\tunsigned int frontbuffer_bits;\n\n\tfrontbuffer_bits = INTEL_FRONTBUFFER_ALL_MASK(crtc->pipe);\n\n\tfor_each_intel_crtc_in_pipe_mask(&i915->drm, crtc,\n\t\t\t\t\t crtc_state->bigjoiner_pipes)\n\t\tfrontbuffer_bits |= INTEL_FRONTBUFFER_ALL_MASK(crtc->pipe);\n\n\treturn frontbuffer_bits;\n}\n\n \nvoid intel_drrs_activate(const struct intel_crtc_state *crtc_state)\n{\n\tstruct intel_crtc *crtc = to_intel_crtc(crtc_state->uapi.crtc);\n\n\tif (!crtc_state->has_drrs)\n\t\treturn;\n\n\tif (!crtc_state->hw.active)\n\t\treturn;\n\n\tif (intel_crtc_is_bigjoiner_slave(crtc_state))\n\t\treturn;\n\n\tmutex_lock(&crtc->drrs.mutex);\n\n\tcrtc->drrs.cpu_transcoder = crtc_state->cpu_transcoder;\n\tcrtc->drrs.m_n = crtc_state->dp_m_n;\n\tcrtc->drrs.m2_n2 = crtc_state->dp_m2_n2;\n\tcrtc->drrs.frontbuffer_bits = intel_drrs_frontbuffer_bits(crtc_state);\n\tcrtc->drrs.busy_frontbuffer_bits = 0;\n\n\tintel_drrs_schedule_work(crtc);\n\n\tmutex_unlock(&crtc->drrs.mutex);\n}\n\n \nvoid intel_drrs_deactivate(const struct intel_crtc_state *old_crtc_state)\n{\n\tstruct intel_crtc *crtc = to_intel_crtc(old_crtc_state->uapi.crtc);\n\n\tif (!old_crtc_state->has_drrs)\n\t\treturn;\n\n\tif (!old_crtc_state->hw.active)\n\t\treturn;\n\n\tif (intel_crtc_is_bigjoiner_slave(old_crtc_state))\n\t\treturn;\n\n\tmutex_lock(&crtc->drrs.mutex);\n\n\tif (intel_drrs_is_active(crtc))\n\t\tintel_drrs_set_state(crtc, DRRS_REFRESH_RATE_HIGH);\n\n\tcrtc->drrs.cpu_transcoder = INVALID_TRANSCODER;\n\tcrtc->drrs.frontbuffer_bits = 0;\n\tcrtc->drrs.busy_frontbuffer_bits = 0;\n\n\tmutex_unlock(&crtc->drrs.mutex);\n\n\tcancel_delayed_work_sync(&crtc->drrs.work);\n}\n\nstatic void intel_drrs_downclock_work(struct work_struct *work)\n{\n\tstruct intel_crtc *crtc = container_of(work, typeof(*crtc), drrs.work.work);\n\n\tmutex_lock(&crtc->drrs.mutex);\n\n\tif (intel_drrs_is_active(crtc) && !crtc->drrs.busy_frontbuffer_bits)\n\t\tintel_drrs_set_state(crtc, DRRS_REFRESH_RATE_LOW);\n\n\tmutex_unlock(&crtc->drrs.mutex);\n}\n\nstatic void intel_drrs_frontbuffer_update(struct drm_i915_private *dev_priv,\n\t\t\t\t\t  unsigned int all_frontbuffer_bits,\n\t\t\t\t\t  bool invalidate)\n{\n\tstruct intel_crtc *crtc;\n\n\tfor_each_intel_crtc(&dev_priv->drm, crtc) {\n\t\tunsigned int frontbuffer_bits;\n\n\t\tmutex_lock(&crtc->drrs.mutex);\n\n\t\tfrontbuffer_bits = all_frontbuffer_bits & crtc->drrs.frontbuffer_bits;\n\t\tif (!frontbuffer_bits) {\n\t\t\tmutex_unlock(&crtc->drrs.mutex);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (invalidate)\n\t\t\tcrtc->drrs.busy_frontbuffer_bits |= frontbuffer_bits;\n\t\telse\n\t\t\tcrtc->drrs.busy_frontbuffer_bits &= ~frontbuffer_bits;\n\n\t\t \n\t\tintel_drrs_set_state(crtc, DRRS_REFRESH_RATE_HIGH);\n\n\t\t \n\t\tif (!crtc->drrs.busy_frontbuffer_bits)\n\t\t\tintel_drrs_schedule_work(crtc);\n\t\telse\n\t\t\tcancel_delayed_work(&crtc->drrs.work);\n\n\t\tmutex_unlock(&crtc->drrs.mutex);\n\t}\n}\n\n \nvoid intel_drrs_invalidate(struct drm_i915_private *dev_priv,\n\t\t\t   unsigned int frontbuffer_bits)\n{\n\tintel_drrs_frontbuffer_update(dev_priv, frontbuffer_bits, true);\n}\n\n \nvoid intel_drrs_flush(struct drm_i915_private *dev_priv,\n\t\t      unsigned int frontbuffer_bits)\n{\n\tintel_drrs_frontbuffer_update(dev_priv, frontbuffer_bits, false);\n}\n\n \nvoid intel_drrs_crtc_init(struct intel_crtc *crtc)\n{\n\tINIT_DELAYED_WORK(&crtc->drrs.work, intel_drrs_downclock_work);\n\tmutex_init(&crtc->drrs.mutex);\n\tcrtc->drrs.cpu_transcoder = INVALID_TRANSCODER;\n}\n\nstatic int intel_drrs_debugfs_status_show(struct seq_file *m, void *unused)\n{\n\tstruct intel_crtc *crtc = m->private;\n\tconst struct intel_crtc_state *crtc_state;\n\tint ret;\n\n\tret = drm_modeset_lock_single_interruptible(&crtc->base.mutex);\n\tif (ret)\n\t\treturn ret;\n\n\tcrtc_state = to_intel_crtc_state(crtc->base.state);\n\n\tmutex_lock(&crtc->drrs.mutex);\n\n\tseq_printf(m, \"DRRS enabled: %s\\n\",\n\t\t   str_yes_no(crtc_state->has_drrs));\n\n\tseq_printf(m, \"DRRS active: %s\\n\",\n\t\t   str_yes_no(intel_drrs_is_active(crtc)));\n\n\tseq_printf(m, \"DRRS refresh rate: %s\\n\",\n\t\t   crtc->drrs.refresh_rate == DRRS_REFRESH_RATE_LOW ?\n\t\t   \"low\" : \"high\");\n\n\tseq_printf(m, \"DRRS busy frontbuffer bits: 0x%x\\n\",\n\t\t   crtc->drrs.busy_frontbuffer_bits);\n\n\tmutex_unlock(&crtc->drrs.mutex);\n\n\tdrm_modeset_unlock(&crtc->base.mutex);\n\n\treturn 0;\n}\n\nDEFINE_SHOW_ATTRIBUTE(intel_drrs_debugfs_status);\n\nstatic int intel_drrs_debugfs_ctl_set(void *data, u64 val)\n{\n\tstruct intel_crtc *crtc = data;\n\tstruct drm_i915_private *i915 = to_i915(crtc->base.dev);\n\tstruct intel_crtc_state *crtc_state;\n\tstruct drm_crtc_commit *commit;\n\tint ret;\n\n\tret = drm_modeset_lock_single_interruptible(&crtc->base.mutex);\n\tif (ret)\n\t\treturn ret;\n\n\tcrtc_state = to_intel_crtc_state(crtc->base.state);\n\n\tif (!crtc_state->hw.active ||\n\t    !crtc_state->has_drrs)\n\t\tgoto out;\n\n\tcommit = crtc_state->uapi.commit;\n\tif (commit) {\n\t\tret = wait_for_completion_interruptible(&commit->hw_done);\n\t\tif (ret)\n\t\t\tgoto out;\n\t}\n\n\tdrm_dbg(&i915->drm,\n\t\t\"Manually %sactivating DRRS\\n\", val ? \"\" : \"de\");\n\n\tif (val)\n\t\tintel_drrs_activate(crtc_state);\n\telse\n\t\tintel_drrs_deactivate(crtc_state);\n\nout:\n\tdrm_modeset_unlock(&crtc->base.mutex);\n\n\treturn ret;\n}\n\nDEFINE_DEBUGFS_ATTRIBUTE(intel_drrs_debugfs_ctl_fops,\n\t\t\t NULL, intel_drrs_debugfs_ctl_set, \"%llu\\n\");\n\nvoid intel_drrs_crtc_debugfs_add(struct intel_crtc *crtc)\n{\n\tdebugfs_create_file(\"i915_drrs_status\", 0444, crtc->base.debugfs_entry,\n\t\t\t    crtc, &intel_drrs_debugfs_status_fops);\n\n\tdebugfs_create_file_unsafe(\"i915_drrs_ctl\", 0644, crtc->base.debugfs_entry,\n\t\t\t\t   crtc, &intel_drrs_debugfs_ctl_fops);\n}\n\nstatic int intel_drrs_debugfs_type_show(struct seq_file *m, void *unused)\n{\n\tstruct intel_connector *connector = m->private;\n\n\tseq_printf(m, \"DRRS type: %s\\n\",\n\t\t   intel_drrs_type_str(intel_panel_drrs_type(connector)));\n\n\treturn 0;\n}\n\nDEFINE_SHOW_ATTRIBUTE(intel_drrs_debugfs_type);\n\nvoid intel_drrs_connector_debugfs_add(struct intel_connector *connector)\n{\n\tif (intel_panel_drrs_type(connector) == DRRS_TYPE_NONE)\n\t\treturn;\n\n\tdebugfs_create_file(\"i915_drrs_type\", 0444, connector->base.debugfs_entry,\n\t\t\t    connector, &intel_drrs_debugfs_type_fops);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}