{
  "module_name": "intel_crtc.c",
  "hash_id": "cee36e6c92465a8603eefc99d99a7dc66d692fd8425ba6df8c5df70da69a2b00",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/i915/display/intel_crtc.c",
  "human_readable_source": "\n \n#include <linux/kernel.h>\n#include <linux/pm_qos.h>\n#include <linux/slab.h>\n\n#include <drm/drm_atomic_helper.h>\n#include <drm/drm_fourcc.h>\n#include <drm/drm_plane.h>\n#include <drm/drm_vblank_work.h>\n\n#include \"i915_vgpu.h\"\n#include \"i9xx_plane.h\"\n#include \"icl_dsi.h\"\n#include \"intel_atomic.h\"\n#include \"intel_atomic_plane.h\"\n#include \"intel_color.h\"\n#include \"intel_crtc.h\"\n#include \"intel_cursor.h\"\n#include \"intel_display_debugfs.h\"\n#include \"intel_display_irq.h\"\n#include \"intel_display_trace.h\"\n#include \"intel_display_types.h\"\n#include \"intel_drrs.h\"\n#include \"intel_dsi.h\"\n#include \"intel_fifo_underrun.h\"\n#include \"intel_pipe_crc.h\"\n#include \"intel_psr.h\"\n#include \"intel_sprite.h\"\n#include \"intel_vblank.h\"\n#include \"intel_vrr.h\"\n#include \"skl_universal_plane.h\"\n\nstatic void assert_vblank_disabled(struct drm_crtc *crtc)\n{\n\tstruct drm_i915_private *i915 = to_i915(crtc->dev);\n\n\tif (I915_STATE_WARN(i915, drm_crtc_vblank_get(crtc) == 0,\n\t\t\t    \"[CRTC:%d:%s] vblank assertion failure (expected off, current on)\\n\",\n\t\t\t    crtc->base.id, crtc->name))\n\t\tdrm_crtc_vblank_put(crtc);\n}\n\nstruct intel_crtc *intel_first_crtc(struct drm_i915_private *i915)\n{\n\treturn to_intel_crtc(drm_crtc_from_index(&i915->drm, 0));\n}\n\nstruct intel_crtc *intel_crtc_for_pipe(struct drm_i915_private *i915,\n\t\t\t\t       enum pipe pipe)\n{\n\tstruct intel_crtc *crtc;\n\n\tfor_each_intel_crtc(&i915->drm, crtc) {\n\t\tif (crtc->pipe == pipe)\n\t\t\treturn crtc;\n\t}\n\n\treturn NULL;\n}\n\nvoid intel_crtc_wait_for_next_vblank(struct intel_crtc *crtc)\n{\n\tdrm_crtc_wait_one_vblank(&crtc->base);\n}\n\nvoid intel_wait_for_vblank_if_active(struct drm_i915_private *i915,\n\t\t\t\t     enum pipe pipe)\n{\n\tstruct intel_crtc *crtc = intel_crtc_for_pipe(i915, pipe);\n\n\tif (crtc->active)\n\t\tintel_crtc_wait_for_next_vblank(crtc);\n}\n\nu32 intel_crtc_get_vblank_counter(struct intel_crtc *crtc)\n{\n\tstruct drm_device *dev = crtc->base.dev;\n\tstruct drm_vblank_crtc *vblank = &dev->vblank[drm_crtc_index(&crtc->base)];\n\n\tif (!crtc->active)\n\t\treturn 0;\n\n\tif (!vblank->max_vblank_count)\n\t\treturn (u32)drm_crtc_accurate_vblank_count(&crtc->base);\n\n\treturn crtc->base.funcs->get_vblank_counter(&crtc->base);\n}\n\nu32 intel_crtc_max_vblank_count(const struct intel_crtc_state *crtc_state)\n{\n\tstruct drm_i915_private *dev_priv = to_i915(crtc_state->uapi.crtc->dev);\n\n\t \n\tif (crtc_state->mode_flags & (I915_MODE_FLAG_DSI_USE_TE0 |\n\t\t\t\t      I915_MODE_FLAG_DSI_USE_TE1))\n\t\treturn 0;\n\n\t \n\tif (IS_I965GM(dev_priv) &&\n\t    (crtc_state->output_types & BIT(INTEL_OUTPUT_TVOUT)))\n\t\treturn 0;\n\n\tif (DISPLAY_VER(dev_priv) >= 5 || IS_G4X(dev_priv))\n\t\treturn 0xffffffff;  \n\telse if (DISPLAY_VER(dev_priv) >= 3)\n\t\treturn 0xffffff;  \n\telse\n\t\treturn 0;  \n}\n\nvoid intel_crtc_vblank_on(const struct intel_crtc_state *crtc_state)\n{\n\tstruct intel_crtc *crtc = to_intel_crtc(crtc_state->uapi.crtc);\n\n\tassert_vblank_disabled(&crtc->base);\n\tdrm_crtc_set_max_vblank_count(&crtc->base,\n\t\t\t\t      intel_crtc_max_vblank_count(crtc_state));\n\tdrm_crtc_vblank_on(&crtc->base);\n\n\t \n\ttrace_intel_pipe_enable(crtc);\n}\n\nvoid intel_crtc_vblank_off(const struct intel_crtc_state *crtc_state)\n{\n\tstruct intel_crtc *crtc = to_intel_crtc(crtc_state->uapi.crtc);\n\n\t \n\ttrace_intel_pipe_disable(crtc);\n\n\tdrm_crtc_vblank_off(&crtc->base);\n\tassert_vblank_disabled(&crtc->base);\n}\n\nstruct intel_crtc_state *intel_crtc_state_alloc(struct intel_crtc *crtc)\n{\n\tstruct intel_crtc_state *crtc_state;\n\n\tcrtc_state = kmalloc(sizeof(*crtc_state), GFP_KERNEL);\n\n\tif (crtc_state)\n\t\tintel_crtc_state_reset(crtc_state, crtc);\n\n\treturn crtc_state;\n}\n\nvoid intel_crtc_state_reset(struct intel_crtc_state *crtc_state,\n\t\t\t    struct intel_crtc *crtc)\n{\n\tmemset(crtc_state, 0, sizeof(*crtc_state));\n\n\t__drm_atomic_helper_crtc_state_reset(&crtc_state->uapi, &crtc->base);\n\n\tcrtc_state->cpu_transcoder = INVALID_TRANSCODER;\n\tcrtc_state->master_transcoder = INVALID_TRANSCODER;\n\tcrtc_state->hsw_workaround_pipe = INVALID_PIPE;\n\tcrtc_state->scaler_state.scaler_id = -1;\n\tcrtc_state->mst_master_transcoder = INVALID_TRANSCODER;\n}\n\nstatic struct intel_crtc *intel_crtc_alloc(void)\n{\n\tstruct intel_crtc_state *crtc_state;\n\tstruct intel_crtc *crtc;\n\n\tcrtc = kzalloc(sizeof(*crtc), GFP_KERNEL);\n\tif (!crtc)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tcrtc_state = intel_crtc_state_alloc(crtc);\n\tif (!crtc_state) {\n\t\tkfree(crtc);\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\n\tcrtc->base.state = &crtc_state->uapi;\n\tcrtc->config = crtc_state;\n\n\treturn crtc;\n}\n\nstatic void intel_crtc_free(struct intel_crtc *crtc)\n{\n\tintel_crtc_destroy_state(&crtc->base, crtc->base.state);\n\tkfree(crtc);\n}\n\nstatic void intel_crtc_destroy(struct drm_crtc *_crtc)\n{\n\tstruct intel_crtc *crtc = to_intel_crtc(_crtc);\n\n\tcpu_latency_qos_remove_request(&crtc->vblank_pm_qos);\n\n\tdrm_crtc_cleanup(&crtc->base);\n\tkfree(crtc);\n}\n\nstatic int intel_crtc_late_register(struct drm_crtc *crtc)\n{\n\tintel_crtc_debugfs_add(to_intel_crtc(crtc));\n\treturn 0;\n}\n\n#define INTEL_CRTC_FUNCS \\\n\t.set_config = drm_atomic_helper_set_config, \\\n\t.destroy = intel_crtc_destroy, \\\n\t.page_flip = drm_atomic_helper_page_flip, \\\n\t.atomic_duplicate_state = intel_crtc_duplicate_state, \\\n\t.atomic_destroy_state = intel_crtc_destroy_state, \\\n\t.set_crc_source = intel_crtc_set_crc_source, \\\n\t.verify_crc_source = intel_crtc_verify_crc_source, \\\n\t.get_crc_sources = intel_crtc_get_crc_sources, \\\n\t.late_register = intel_crtc_late_register\n\nstatic const struct drm_crtc_funcs bdw_crtc_funcs = {\n\tINTEL_CRTC_FUNCS,\n\n\t.get_vblank_counter = g4x_get_vblank_counter,\n\t.enable_vblank = bdw_enable_vblank,\n\t.disable_vblank = bdw_disable_vblank,\n\t.get_vblank_timestamp = intel_crtc_get_vblank_timestamp,\n};\n\nstatic const struct drm_crtc_funcs ilk_crtc_funcs = {\n\tINTEL_CRTC_FUNCS,\n\n\t.get_vblank_counter = g4x_get_vblank_counter,\n\t.enable_vblank = ilk_enable_vblank,\n\t.disable_vblank = ilk_disable_vblank,\n\t.get_vblank_timestamp = intel_crtc_get_vblank_timestamp,\n};\n\nstatic const struct drm_crtc_funcs g4x_crtc_funcs = {\n\tINTEL_CRTC_FUNCS,\n\n\t.get_vblank_counter = g4x_get_vblank_counter,\n\t.enable_vblank = i965_enable_vblank,\n\t.disable_vblank = i965_disable_vblank,\n\t.get_vblank_timestamp = intel_crtc_get_vblank_timestamp,\n};\n\nstatic const struct drm_crtc_funcs i965_crtc_funcs = {\n\tINTEL_CRTC_FUNCS,\n\n\t.get_vblank_counter = i915_get_vblank_counter,\n\t.enable_vblank = i965_enable_vblank,\n\t.disable_vblank = i965_disable_vblank,\n\t.get_vblank_timestamp = intel_crtc_get_vblank_timestamp,\n};\n\nstatic const struct drm_crtc_funcs i915gm_crtc_funcs = {\n\tINTEL_CRTC_FUNCS,\n\n\t.get_vblank_counter = i915_get_vblank_counter,\n\t.enable_vblank = i915gm_enable_vblank,\n\t.disable_vblank = i915gm_disable_vblank,\n\t.get_vblank_timestamp = intel_crtc_get_vblank_timestamp,\n};\n\nstatic const struct drm_crtc_funcs i915_crtc_funcs = {\n\tINTEL_CRTC_FUNCS,\n\n\t.get_vblank_counter = i915_get_vblank_counter,\n\t.enable_vblank = i8xx_enable_vblank,\n\t.disable_vblank = i8xx_disable_vblank,\n\t.get_vblank_timestamp = intel_crtc_get_vblank_timestamp,\n};\n\nstatic const struct drm_crtc_funcs i8xx_crtc_funcs = {\n\tINTEL_CRTC_FUNCS,\n\n\t \n\t.enable_vblank = i8xx_enable_vblank,\n\t.disable_vblank = i8xx_disable_vblank,\n\t.get_vblank_timestamp = intel_crtc_get_vblank_timestamp,\n};\n\nint intel_crtc_init(struct drm_i915_private *dev_priv, enum pipe pipe)\n{\n\tstruct intel_plane *primary, *cursor;\n\tconst struct drm_crtc_funcs *funcs;\n\tstruct intel_crtc *crtc;\n\tint sprite, ret;\n\n\tcrtc = intel_crtc_alloc();\n\tif (IS_ERR(crtc))\n\t\treturn PTR_ERR(crtc);\n\n\tcrtc->pipe = pipe;\n\tcrtc->num_scalers = DISPLAY_RUNTIME_INFO(dev_priv)->num_scalers[pipe];\n\n\tif (DISPLAY_VER(dev_priv) >= 9)\n\t\tprimary = skl_universal_plane_create(dev_priv, pipe,\n\t\t\t\t\t\t     PLANE_PRIMARY);\n\telse\n\t\tprimary = intel_primary_plane_create(dev_priv, pipe);\n\tif (IS_ERR(primary)) {\n\t\tret = PTR_ERR(primary);\n\t\tgoto fail;\n\t}\n\tcrtc->plane_ids_mask |= BIT(primary->id);\n\n\tintel_init_fifo_underrun_reporting(dev_priv, crtc, false);\n\n\tfor_each_sprite(dev_priv, pipe, sprite) {\n\t\tstruct intel_plane *plane;\n\n\t\tif (DISPLAY_VER(dev_priv) >= 9)\n\t\t\tplane = skl_universal_plane_create(dev_priv, pipe,\n\t\t\t\t\t\t\t   PLANE_SPRITE0 + sprite);\n\t\telse\n\t\t\tplane = intel_sprite_plane_create(dev_priv, pipe, sprite);\n\t\tif (IS_ERR(plane)) {\n\t\t\tret = PTR_ERR(plane);\n\t\t\tgoto fail;\n\t\t}\n\t\tcrtc->plane_ids_mask |= BIT(plane->id);\n\t}\n\n\tcursor = intel_cursor_plane_create(dev_priv, pipe);\n\tif (IS_ERR(cursor)) {\n\t\tret = PTR_ERR(cursor);\n\t\tgoto fail;\n\t}\n\tcrtc->plane_ids_mask |= BIT(cursor->id);\n\n\tif (HAS_GMCH(dev_priv)) {\n\t\tif (IS_CHERRYVIEW(dev_priv) ||\n\t\t    IS_VALLEYVIEW(dev_priv) || IS_G4X(dev_priv))\n\t\t\tfuncs = &g4x_crtc_funcs;\n\t\telse if (DISPLAY_VER(dev_priv) == 4)\n\t\t\tfuncs = &i965_crtc_funcs;\n\t\telse if (IS_I945GM(dev_priv) || IS_I915GM(dev_priv))\n\t\t\tfuncs = &i915gm_crtc_funcs;\n\t\telse if (DISPLAY_VER(dev_priv) == 3)\n\t\t\tfuncs = &i915_crtc_funcs;\n\t\telse\n\t\t\tfuncs = &i8xx_crtc_funcs;\n\t} else {\n\t\tif (DISPLAY_VER(dev_priv) >= 8)\n\t\t\tfuncs = &bdw_crtc_funcs;\n\t\telse\n\t\t\tfuncs = &ilk_crtc_funcs;\n\t}\n\n\tret = drm_crtc_init_with_planes(&dev_priv->drm, &crtc->base,\n\t\t\t\t\t&primary->base, &cursor->base,\n\t\t\t\t\tfuncs, \"pipe %c\", pipe_name(pipe));\n\tif (ret)\n\t\tgoto fail;\n\n\tif (DISPLAY_VER(dev_priv) >= 11)\n\t\tdrm_crtc_create_scaling_filter_property(&crtc->base,\n\t\t\t\t\t\tBIT(DRM_SCALING_FILTER_DEFAULT) |\n\t\t\t\t\t\tBIT(DRM_SCALING_FILTER_NEAREST_NEIGHBOR));\n\n\tintel_color_crtc_init(crtc);\n\tintel_drrs_crtc_init(crtc);\n\tintel_crtc_crc_init(crtc);\n\n\tcpu_latency_qos_add_request(&crtc->vblank_pm_qos, PM_QOS_DEFAULT_VALUE);\n\n\tdrm_WARN_ON(&dev_priv->drm, drm_crtc_index(&crtc->base) != crtc->pipe);\n\n\treturn 0;\n\nfail:\n\tintel_crtc_free(crtc);\n\n\treturn ret;\n}\n\nstatic bool intel_crtc_needs_vblank_work(const struct intel_crtc_state *crtc_state)\n{\n\treturn crtc_state->hw.active &&\n\t\t!intel_crtc_needs_modeset(crtc_state) &&\n\t\t!crtc_state->preload_luts &&\n\t\tintel_crtc_needs_color_update(crtc_state);\n}\n\nstatic void intel_crtc_vblank_work(struct kthread_work *base)\n{\n\tstruct drm_vblank_work *work = to_drm_vblank_work(base);\n\tstruct intel_crtc_state *crtc_state =\n\t\tcontainer_of(work, typeof(*crtc_state), vblank_work);\n\tstruct intel_crtc *crtc = to_intel_crtc(crtc_state->uapi.crtc);\n\n\ttrace_intel_crtc_vblank_work_start(crtc);\n\n\tintel_color_load_luts(crtc_state);\n\n\tif (crtc_state->uapi.event) {\n\t\tspin_lock_irq(&crtc->base.dev->event_lock);\n\t\tdrm_crtc_send_vblank_event(&crtc->base, crtc_state->uapi.event);\n\t\tcrtc_state->uapi.event = NULL;\n\t\tspin_unlock_irq(&crtc->base.dev->event_lock);\n\t}\n\n\ttrace_intel_crtc_vblank_work_end(crtc);\n}\n\nstatic void intel_crtc_vblank_work_init(struct intel_crtc_state *crtc_state)\n{\n\tstruct intel_crtc *crtc = to_intel_crtc(crtc_state->uapi.crtc);\n\n\tdrm_vblank_work_init(&crtc_state->vblank_work, &crtc->base,\n\t\t\t     intel_crtc_vblank_work);\n\t \n\tcpu_latency_qos_update_request(&crtc->vblank_pm_qos, 0);\n}\n\nvoid intel_wait_for_vblank_workers(struct intel_atomic_state *state)\n{\n\tstruct intel_crtc_state *crtc_state;\n\tstruct intel_crtc *crtc;\n\tint i;\n\n\tfor_each_new_intel_crtc_in_state(state, crtc, crtc_state, i) {\n\t\tif (!intel_crtc_needs_vblank_work(crtc_state))\n\t\t\tcontinue;\n\n\t\tdrm_vblank_work_flush(&crtc_state->vblank_work);\n\t\tcpu_latency_qos_update_request(&crtc->vblank_pm_qos,\n\t\t\t\t\t       PM_QOS_DEFAULT_VALUE);\n\t}\n}\n\nint intel_usecs_to_scanlines(const struct drm_display_mode *adjusted_mode,\n\t\t\t     int usecs)\n{\n\t \n\tif (!adjusted_mode->crtc_htotal)\n\t\treturn 1;\n\n\treturn DIV_ROUND_UP(usecs * adjusted_mode->crtc_clock,\n\t\t\t    1000 * adjusted_mode->crtc_htotal);\n}\n\nstatic int intel_mode_vblank_start(const struct drm_display_mode *mode)\n{\n\tint vblank_start = mode->crtc_vblank_start;\n\n\tif (mode->flags & DRM_MODE_FLAG_INTERLACE)\n\t\tvblank_start = DIV_ROUND_UP(vblank_start, 2);\n\n\treturn vblank_start;\n}\n\n \nvoid intel_pipe_update_start(struct intel_crtc_state *new_crtc_state)\n{\n\tstruct intel_crtc *crtc = to_intel_crtc(new_crtc_state->uapi.crtc);\n\tstruct drm_i915_private *dev_priv = to_i915(crtc->base.dev);\n\tconst struct drm_display_mode *adjusted_mode = &new_crtc_state->hw.adjusted_mode;\n\tlong timeout = msecs_to_jiffies_timeout(1);\n\tint scanline, min, max, vblank_start;\n\twait_queue_head_t *wq = drm_crtc_vblank_waitqueue(&crtc->base);\n\tbool need_vlv_dsi_wa = (IS_VALLEYVIEW(dev_priv) || IS_CHERRYVIEW(dev_priv)) &&\n\t\tintel_crtc_has_type(new_crtc_state, INTEL_OUTPUT_DSI);\n\tDEFINE_WAIT(wait);\n\n\tintel_psr_lock(new_crtc_state);\n\n\tif (new_crtc_state->do_async_flip)\n\t\treturn;\n\n\tif (intel_crtc_needs_vblank_work(new_crtc_state))\n\t\tintel_crtc_vblank_work_init(new_crtc_state);\n\n\tif (new_crtc_state->vrr.enable) {\n\t\tif (intel_vrr_is_push_sent(new_crtc_state))\n\t\t\tvblank_start = intel_vrr_vmin_vblank_start(new_crtc_state);\n\t\telse\n\t\t\tvblank_start = intel_vrr_vmax_vblank_start(new_crtc_state);\n\t} else {\n\t\tvblank_start = intel_mode_vblank_start(adjusted_mode);\n\t}\n\n\t \n\tmin = vblank_start - intel_usecs_to_scanlines(adjusted_mode,\n\t\t\t\t\t\t      VBLANK_EVASION_TIME_US);\n\tmax = vblank_start - 1;\n\n\t \n\tif (new_crtc_state->seamless_m_n && intel_crtc_needs_fastset(new_crtc_state))\n\t\tmin -= adjusted_mode->crtc_vblank_start - adjusted_mode->crtc_vdisplay;\n\n\tif (min <= 0 || max <= 0)\n\t\tgoto irq_disable;\n\n\tif (drm_WARN_ON(&dev_priv->drm, drm_crtc_vblank_get(&crtc->base)))\n\t\tgoto irq_disable;\n\n\t \n\tintel_psr_wait_for_idle_locked(new_crtc_state);\n\n\tlocal_irq_disable();\n\n\tcrtc->debug.min_vbl = min;\n\tcrtc->debug.max_vbl = max;\n\ttrace_intel_pipe_update_start(crtc);\n\n\tfor (;;) {\n\t\t \n\t\tprepare_to_wait(wq, &wait, TASK_UNINTERRUPTIBLE);\n\n\t\tscanline = intel_get_crtc_scanline(crtc);\n\t\tif (scanline < min || scanline > max)\n\t\t\tbreak;\n\n\t\tif (!timeout) {\n\t\t\tdrm_err(&dev_priv->drm,\n\t\t\t\t\"Potential atomic update failure on pipe %c\\n\",\n\t\t\t\tpipe_name(crtc->pipe));\n\t\t\tbreak;\n\t\t}\n\n\t\tlocal_irq_enable();\n\n\t\ttimeout = schedule_timeout(timeout);\n\n\t\tlocal_irq_disable();\n\t}\n\n\tfinish_wait(wq, &wait);\n\n\tdrm_crtc_vblank_put(&crtc->base);\n\n\t \n\twhile (need_vlv_dsi_wa && scanline == vblank_start)\n\t\tscanline = intel_get_crtc_scanline(crtc);\n\n\tcrtc->debug.scanline_start = scanline;\n\tcrtc->debug.start_vbl_time = ktime_get();\n\tcrtc->debug.start_vbl_count = intel_crtc_get_vblank_counter(crtc);\n\n\ttrace_intel_pipe_update_vblank_evaded(crtc);\n\treturn;\n\nirq_disable:\n\tlocal_irq_disable();\n}\n\n#if IS_ENABLED(CONFIG_DRM_I915_DEBUG_VBLANK_EVADE)\nstatic void dbg_vblank_evade(struct intel_crtc *crtc, ktime_t end)\n{\n\tu64 delta = ktime_to_ns(ktime_sub(end, crtc->debug.start_vbl_time));\n\tunsigned int h;\n\n\th = ilog2(delta >> 9);\n\tif (h >= ARRAY_SIZE(crtc->debug.vbl.times))\n\t\th = ARRAY_SIZE(crtc->debug.vbl.times) - 1;\n\tcrtc->debug.vbl.times[h]++;\n\n\tcrtc->debug.vbl.sum += delta;\n\tif (!crtc->debug.vbl.min || delta < crtc->debug.vbl.min)\n\t\tcrtc->debug.vbl.min = delta;\n\tif (delta > crtc->debug.vbl.max)\n\t\tcrtc->debug.vbl.max = delta;\n\n\tif (delta > 1000 * VBLANK_EVASION_TIME_US) {\n\t\tdrm_dbg_kms(crtc->base.dev,\n\t\t\t    \"Atomic update on pipe (%c) took %lld us, max time under evasion is %u us\\n\",\n\t\t\t    pipe_name(crtc->pipe),\n\t\t\t    div_u64(delta, 1000),\n\t\t\t    VBLANK_EVASION_TIME_US);\n\t\tcrtc->debug.vbl.over++;\n\t}\n}\n#else\nstatic void dbg_vblank_evade(struct intel_crtc *crtc, ktime_t end) {}\n#endif\n\n \nvoid intel_pipe_update_end(struct intel_crtc_state *new_crtc_state)\n{\n\tstruct intel_crtc *crtc = to_intel_crtc(new_crtc_state->uapi.crtc);\n\tenum pipe pipe = crtc->pipe;\n\tint scanline_end = intel_get_crtc_scanline(crtc);\n\tu32 end_vbl_count = intel_crtc_get_vblank_counter(crtc);\n\tktime_t end_vbl_time = ktime_get();\n\tstruct drm_i915_private *dev_priv = to_i915(crtc->base.dev);\n\n\tintel_psr_unlock(new_crtc_state);\n\n\tif (new_crtc_state->do_async_flip)\n\t\treturn;\n\n\ttrace_intel_pipe_update_end(crtc, end_vbl_count, scanline_end);\n\n\t \n\tif (DISPLAY_VER(dev_priv) >= 11 &&\n\t    intel_crtc_has_type(new_crtc_state, INTEL_OUTPUT_DSI))\n\t\ticl_dsi_frame_update(new_crtc_state);\n\n\t \n\tif (intel_crtc_needs_vblank_work(new_crtc_state)) {\n\t\tdrm_vblank_work_schedule(&new_crtc_state->vblank_work,\n\t\t\t\t\t drm_crtc_accurate_vblank_count(&crtc->base) + 1,\n\t\t\t\t\t false);\n\t} else if (new_crtc_state->uapi.event) {\n\t\tdrm_WARN_ON(&dev_priv->drm,\n\t\t\t    drm_crtc_vblank_get(&crtc->base) != 0);\n\n\t\tspin_lock(&crtc->base.dev->event_lock);\n\t\tdrm_crtc_arm_vblank_event(&crtc->base,\n\t\t\t\t\t  new_crtc_state->uapi.event);\n\t\tspin_unlock(&crtc->base.dev->event_lock);\n\n\t\tnew_crtc_state->uapi.event = NULL;\n\t}\n\n\t \n\tintel_vrr_send_push(new_crtc_state);\n\n\t \n\tif (new_crtc_state->seamless_m_n && intel_crtc_needs_fastset(new_crtc_state))\n\t\tintel_crtc_update_active_timings(new_crtc_state,\n\t\t\t\t\t\t new_crtc_state->vrr.enable);\n\n\tlocal_irq_enable();\n\n\tif (intel_vgpu_active(dev_priv))\n\t\treturn;\n\n\tif (crtc->debug.start_vbl_count &&\n\t    crtc->debug.start_vbl_count != end_vbl_count) {\n\t\tdrm_err(&dev_priv->drm,\n\t\t\t\"Atomic update failure on pipe %c (start=%u end=%u) time %lld us, min %d, max %d, scanline start %d, end %d\\n\",\n\t\t\tpipe_name(pipe), crtc->debug.start_vbl_count,\n\t\t\tend_vbl_count,\n\t\t\tktime_us_delta(end_vbl_time,\n\t\t\t\t       crtc->debug.start_vbl_time),\n\t\t\tcrtc->debug.min_vbl, crtc->debug.max_vbl,\n\t\t\tcrtc->debug.scanline_start, scanline_end);\n\t}\n\n\tdbg_vblank_evade(crtc, end_vbl_time);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}