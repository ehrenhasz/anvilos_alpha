{
  "module_name": "intel_display_driver.c",
  "hash_id": "c041a4ad039b65e518e8454c2f6f50c6c94c23579c0fbbe5a6d8762f7b281551",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/i915/display/intel_display_driver.c",
  "human_readable_source": "\n \n\n#include <linux/vga_switcheroo.h>\n#include <acpi/video.h>\n#include <drm/display/drm_dp_mst_helper.h>\n#include <drm/drm_atomic_helper.h>\n#include <drm/drm_mode_config.h>\n#include <drm/drm_privacy_screen_consumer.h>\n#include <drm/drm_probe_helper.h>\n#include <drm/drm_vblank.h>\n\n#include \"i915_drv.h\"\n#include \"i9xx_wm.h\"\n#include \"intel_acpi.h\"\n#include \"intel_atomic.h\"\n#include \"intel_audio.h\"\n#include \"intel_bios.h\"\n#include \"intel_bw.h\"\n#include \"intel_cdclk.h\"\n#include \"intel_color.h\"\n#include \"intel_crtc.h\"\n#include \"intel_display_debugfs.h\"\n#include \"intel_display_driver.h\"\n#include \"intel_display_irq.h\"\n#include \"intel_display_power.h\"\n#include \"intel_display_types.h\"\n#include \"intel_dkl_phy.h\"\n#include \"intel_dmc.h\"\n#include \"intel_dp.h\"\n#include \"intel_dpll.h\"\n#include \"intel_dpll_mgr.h\"\n#include \"intel_fb.h\"\n#include \"intel_fbc.h\"\n#include \"intel_fbdev.h\"\n#include \"intel_fdi.h\"\n#include \"intel_gmbus.h\"\n#include \"intel_hdcp.h\"\n#include \"intel_hotplug.h\"\n#include \"intel_hti.h\"\n#include \"intel_modeset_setup.h\"\n#include \"intel_opregion.h\"\n#include \"intel_overlay.h\"\n#include \"intel_plane_initial.h\"\n#include \"intel_pmdemand.h\"\n#include \"intel_pps.h\"\n#include \"intel_quirks.h\"\n#include \"intel_vga.h\"\n#include \"intel_wm.h\"\n#include \"skl_watermark.h\"\n\nbool intel_display_driver_probe_defer(struct pci_dev *pdev)\n{\n\tstruct drm_privacy_screen *privacy_screen;\n\n\t \n\tif (vga_switcheroo_client_probe_defer(pdev))\n\t\treturn true;\n\n\t \n\tprivacy_screen = drm_privacy_screen_get(&pdev->dev, NULL);\n\tif (IS_ERR(privacy_screen) && PTR_ERR(privacy_screen) == -EPROBE_DEFER)\n\t\treturn true;\n\n\tdrm_privacy_screen_put(privacy_screen);\n\n\treturn false;\n}\n\nvoid intel_display_driver_init_hw(struct drm_i915_private *i915)\n{\n\tstruct intel_cdclk_state *cdclk_state;\n\n\tif (!HAS_DISPLAY(i915))\n\t\treturn;\n\n\tcdclk_state = to_intel_cdclk_state(i915->display.cdclk.obj.state);\n\n\tintel_update_cdclk(i915);\n\tintel_cdclk_dump_config(i915, &i915->display.cdclk.hw, \"Current CDCLK\");\n\tcdclk_state->logical = cdclk_state->actual = i915->display.cdclk.hw;\n}\n\nstatic const struct drm_mode_config_funcs intel_mode_funcs = {\n\t.fb_create = intel_user_framebuffer_create,\n\t.get_format_info = intel_fb_get_format_info,\n\t.output_poll_changed = intel_fbdev_output_poll_changed,\n\t.mode_valid = intel_mode_valid,\n\t.atomic_check = intel_atomic_check,\n\t.atomic_commit = intel_atomic_commit,\n\t.atomic_state_alloc = intel_atomic_state_alloc,\n\t.atomic_state_clear = intel_atomic_state_clear,\n\t.atomic_state_free = intel_atomic_state_free,\n};\n\nstatic const struct drm_mode_config_helper_funcs intel_mode_config_funcs = {\n\t.atomic_commit_setup = drm_dp_mst_atomic_setup_commit,\n};\n\nstatic void intel_mode_config_init(struct drm_i915_private *i915)\n{\n\tstruct drm_mode_config *mode_config = &i915->drm.mode_config;\n\n\tdrm_mode_config_init(&i915->drm);\n\tINIT_LIST_HEAD(&i915->display.global.obj_list);\n\n\tmode_config->min_width = 0;\n\tmode_config->min_height = 0;\n\n\tmode_config->preferred_depth = 24;\n\tmode_config->prefer_shadow = 1;\n\n\tmode_config->funcs = &intel_mode_funcs;\n\tmode_config->helper_private = &intel_mode_config_funcs;\n\n\tmode_config->async_page_flip = HAS_ASYNC_FLIPS(i915);\n\n\t \n\tif (DISPLAY_VER(i915) >= 7) {\n\t\tmode_config->max_width = 16384;\n\t\tmode_config->max_height = 16384;\n\t} else if (DISPLAY_VER(i915) >= 4) {\n\t\tmode_config->max_width = 8192;\n\t\tmode_config->max_height = 8192;\n\t} else if (DISPLAY_VER(i915) == 3) {\n\t\tmode_config->max_width = 4096;\n\t\tmode_config->max_height = 4096;\n\t} else {\n\t\tmode_config->max_width = 2048;\n\t\tmode_config->max_height = 2048;\n\t}\n\n\tif (IS_I845G(i915) || IS_I865G(i915)) {\n\t\tmode_config->cursor_width = IS_I845G(i915) ? 64 : 512;\n\t\tmode_config->cursor_height = 1023;\n\t} else if (IS_I830(i915) || IS_I85X(i915) ||\n\t\t   IS_I915G(i915) || IS_I915GM(i915)) {\n\t\tmode_config->cursor_width = 64;\n\t\tmode_config->cursor_height = 64;\n\t} else {\n\t\tmode_config->cursor_width = 256;\n\t\tmode_config->cursor_height = 256;\n\t}\n}\n\nstatic void intel_mode_config_cleanup(struct drm_i915_private *i915)\n{\n\tintel_atomic_global_obj_cleanup(i915);\n\tdrm_mode_config_cleanup(&i915->drm);\n}\n\nstatic void intel_plane_possible_crtcs_init(struct drm_i915_private *dev_priv)\n{\n\tstruct intel_plane *plane;\n\n\tfor_each_intel_plane(&dev_priv->drm, plane) {\n\t\tstruct intel_crtc *crtc = intel_crtc_for_pipe(dev_priv,\n\t\t\t\t\t\t\t      plane->pipe);\n\n\t\tplane->base.possible_crtcs = drm_crtc_mask(&crtc->base);\n\t}\n}\n\nvoid intel_display_driver_early_probe(struct drm_i915_private *i915)\n{\n\tif (!HAS_DISPLAY(i915))\n\t\treturn;\n\n\tintel_display_irq_init(i915);\n\tintel_dkl_phy_init(i915);\n\tintel_color_init_hooks(i915);\n\tintel_init_cdclk_hooks(i915);\n\tintel_audio_hooks_init(i915);\n\tintel_dpll_init_clock_hook(i915);\n\tintel_init_display_hooks(i915);\n\tintel_fdi_init_hook(i915);\n}\n\n \nint intel_display_driver_probe_noirq(struct drm_i915_private *i915)\n{\n\tint ret;\n\n\tif (i915_inject_probe_failure(i915))\n\t\treturn -ENODEV;\n\n\tif (HAS_DISPLAY(i915)) {\n\t\tret = drm_vblank_init(&i915->drm,\n\t\t\t\t      INTEL_NUM_PIPES(i915));\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tintel_bios_init(i915);\n\n\tret = intel_vga_register(i915);\n\tif (ret)\n\t\tgoto cleanup_bios;\n\n\t \n\tret = intel_power_domains_init(i915);\n\tif (ret < 0)\n\t\tgoto cleanup_vga;\n\n\tintel_pmdemand_init_early(i915);\n\n\tintel_power_domains_init_hw(i915, false);\n\n\tif (!HAS_DISPLAY(i915))\n\t\treturn 0;\n\n\tintel_dmc_init(i915);\n\n\ti915->display.wq.modeset = alloc_ordered_workqueue(\"i915_modeset\", 0);\n\ti915->display.wq.flip = alloc_workqueue(\"i915_flip\", WQ_HIGHPRI |\n\t\t\t\t\t\tWQ_UNBOUND, WQ_UNBOUND_MAX_ACTIVE);\n\n\tintel_mode_config_init(i915);\n\n\tret = intel_cdclk_init(i915);\n\tif (ret)\n\t\tgoto cleanup_vga_client_pw_domain_dmc;\n\n\tret = intel_color_init(i915);\n\tif (ret)\n\t\tgoto cleanup_vga_client_pw_domain_dmc;\n\n\tret = intel_dbuf_init(i915);\n\tif (ret)\n\t\tgoto cleanup_vga_client_pw_domain_dmc;\n\n\tret = intel_bw_init(i915);\n\tif (ret)\n\t\tgoto cleanup_vga_client_pw_domain_dmc;\n\n\tret = intel_pmdemand_init(i915);\n\tif (ret)\n\t\tgoto cleanup_vga_client_pw_domain_dmc;\n\n\tinit_llist_head(&i915->display.atomic_helper.free_list);\n\tINIT_WORK(&i915->display.atomic_helper.free_work,\n\t\t  intel_atomic_helper_free_state_worker);\n\n\tintel_init_quirks(i915);\n\n\tintel_fbc_init(i915);\n\n\treturn 0;\n\ncleanup_vga_client_pw_domain_dmc:\n\tintel_dmc_fini(i915);\n\tintel_power_domains_driver_remove(i915);\ncleanup_vga:\n\tintel_vga_unregister(i915);\ncleanup_bios:\n\tintel_bios_driver_remove(i915);\n\n\treturn ret;\n}\n\n \nint intel_display_driver_probe_nogem(struct drm_i915_private *i915)\n{\n\tstruct drm_device *dev = &i915->drm;\n\tenum pipe pipe;\n\tstruct intel_crtc *crtc;\n\tint ret;\n\n\tif (!HAS_DISPLAY(i915))\n\t\treturn 0;\n\n\tintel_wm_init(i915);\n\n\tintel_panel_sanitize_ssc(i915);\n\n\tintel_pps_setup(i915);\n\n\tintel_gmbus_setup(i915);\n\n\tdrm_dbg_kms(&i915->drm, \"%d display pipe%s available.\\n\",\n\t\t    INTEL_NUM_PIPES(i915),\n\t\t    INTEL_NUM_PIPES(i915) > 1 ? \"s\" : \"\");\n\n\tfor_each_pipe(i915, pipe) {\n\t\tret = intel_crtc_init(i915, pipe);\n\t\tif (ret) {\n\t\t\tintel_mode_config_cleanup(i915);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tintel_plane_possible_crtcs_init(i915);\n\tintel_shared_dpll_init(i915);\n\tintel_fdi_pll_freq_update(i915);\n\n\tintel_update_czclk(i915);\n\tintel_display_driver_init_hw(i915);\n\tintel_dpll_update_ref_clks(i915);\n\n\tintel_hdcp_component_init(i915);\n\n\tif (i915->display.cdclk.max_cdclk_freq == 0)\n\t\tintel_update_max_cdclk(i915);\n\n\tintel_hti_init(i915);\n\n\t \n\tintel_vga_disable(i915);\n\tintel_setup_outputs(i915);\n\n\tdrm_modeset_lock_all(dev);\n\tintel_modeset_setup_hw_state(i915, dev->mode_config.acquire_ctx);\n\tintel_acpi_assign_connector_fwnodes(i915);\n\tdrm_modeset_unlock_all(dev);\n\n\tfor_each_intel_crtc(dev, crtc) {\n\t\tif (!to_intel_crtc_state(crtc->base.state)->uapi.active)\n\t\t\tcontinue;\n\t\tintel_crtc_initial_plane_config(crtc);\n\t}\n\n\t \n\tif (!HAS_GMCH(i915))\n\t\tilk_wm_sanitize(i915);\n\n\treturn 0;\n}\n\n \nint intel_display_driver_probe(struct drm_i915_private *i915)\n{\n\tint ret;\n\n\tif (!HAS_DISPLAY(i915))\n\t\treturn 0;\n\n\t \n\tret = intel_initial_commit(&i915->drm);\n\tif (ret)\n\t\tdrm_dbg_kms(&i915->drm, \"Initial modeset failed, %d\\n\", ret);\n\n\tintel_overlay_setup(i915);\n\n\tret = intel_fbdev_init(&i915->drm);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tintel_hpd_init(i915);\n\tintel_hpd_poll_disable(i915);\n\n\tskl_watermark_ipc_init(i915);\n\n\treturn 0;\n}\n\nvoid intel_display_driver_register(struct drm_i915_private *i915)\n{\n\tif (!HAS_DISPLAY(i915))\n\t\treturn;\n\n\t \n\tintel_opregion_register(i915);\n\tintel_acpi_video_register(i915);\n\n\tintel_audio_init(i915);\n\n\tintel_display_debugfs_register(i915);\n\n\t \n\tintel_fbdev_initial_config_async(i915);\n\n\t \n\tdrm_kms_helper_poll_init(&i915->drm);\n}\n\n \nvoid intel_display_driver_remove(struct drm_i915_private *i915)\n{\n\tif (!HAS_DISPLAY(i915))\n\t\treturn;\n\n\tflush_workqueue(i915->display.wq.flip);\n\tflush_workqueue(i915->display.wq.modeset);\n\n\tflush_work(&i915->display.atomic_helper.free_work);\n\tdrm_WARN_ON(&i915->drm, !llist_empty(&i915->display.atomic_helper.free_list));\n\n\t \n\tintel_dp_mst_suspend(i915);\n}\n\n \nvoid intel_display_driver_remove_noirq(struct drm_i915_private *i915)\n{\n\tif (!HAS_DISPLAY(i915))\n\t\treturn;\n\n\t \n\tintel_hpd_poll_fini(i915);\n\n\t \n\tintel_fbdev_fini(i915);\n\n\tintel_unregister_dsm_handler();\n\n\t \n\tflush_workqueue(i915->unordered_wq);\n\n\tintel_hdcp_component_fini(i915);\n\n\tintel_mode_config_cleanup(i915);\n\n\tintel_overlay_cleanup(i915);\n\n\tintel_gmbus_teardown(i915);\n\n\tdestroy_workqueue(i915->display.wq.flip);\n\tdestroy_workqueue(i915->display.wq.modeset);\n\n\tintel_fbc_cleanup(i915);\n}\n\n \nvoid intel_display_driver_remove_nogem(struct drm_i915_private *i915)\n{\n\tintel_dmc_fini(i915);\n\n\tintel_power_domains_driver_remove(i915);\n\n\tintel_vga_unregister(i915);\n\n\tintel_bios_driver_remove(i915);\n}\n\nvoid intel_display_driver_unregister(struct drm_i915_private *i915)\n{\n\tif (!HAS_DISPLAY(i915))\n\t\treturn;\n\n\tintel_fbdev_unregister(i915);\n\tintel_audio_deinit(i915);\n\n\t \n\tdrm_kms_helper_poll_fini(&i915->drm);\n\tdrm_atomic_helper_shutdown(&i915->drm);\n\n\tacpi_video_unregister();\n\tintel_opregion_unregister(i915);\n}\n\n \nint intel_display_driver_suspend(struct drm_i915_private *i915)\n{\n\tstruct drm_atomic_state *state;\n\tint ret;\n\n\tif (!HAS_DISPLAY(i915))\n\t\treturn 0;\n\n\tstate = drm_atomic_helper_suspend(&i915->drm);\n\tret = PTR_ERR_OR_ZERO(state);\n\tif (ret)\n\t\tdrm_err(&i915->drm, \"Suspending crtc's failed with %i\\n\",\n\t\t\tret);\n\telse\n\t\ti915->display.restore.modeset_state = state;\n\treturn ret;\n}\n\nint\n__intel_display_driver_resume(struct drm_i915_private *i915,\n\t\t\t      struct drm_atomic_state *state,\n\t\t\t      struct drm_modeset_acquire_ctx *ctx)\n{\n\tstruct drm_crtc_state *crtc_state;\n\tstruct drm_crtc *crtc;\n\tint ret, i;\n\n\tintel_modeset_setup_hw_state(i915, ctx);\n\tintel_vga_redisable(i915);\n\n\tif (!state)\n\t\treturn 0;\n\n\t \n\tfor_each_new_crtc_in_state(state, crtc, crtc_state, i) {\n\t\t \n\t\tcrtc_state->mode_changed = true;\n\t}\n\n\t \n\tif (!HAS_GMCH(i915))\n\t\tto_intel_atomic_state(state)->skip_intermediate_wm = true;\n\n\tret = drm_atomic_helper_commit_duplicated_state(state, ctx);\n\n\tdrm_WARN_ON(&i915->drm, ret == -EDEADLK);\n\n\treturn ret;\n}\n\nvoid intel_display_driver_resume(struct drm_i915_private *i915)\n{\n\tstruct drm_atomic_state *state = i915->display.restore.modeset_state;\n\tstruct drm_modeset_acquire_ctx ctx;\n\tint ret;\n\n\tif (!HAS_DISPLAY(i915))\n\t\treturn;\n\n\ti915->display.restore.modeset_state = NULL;\n\tif (state)\n\t\tstate->acquire_ctx = &ctx;\n\n\tdrm_modeset_acquire_init(&ctx, 0);\n\n\twhile (1) {\n\t\tret = drm_modeset_lock_all_ctx(&i915->drm, &ctx);\n\t\tif (ret != -EDEADLK)\n\t\t\tbreak;\n\n\t\tdrm_modeset_backoff(&ctx);\n\t}\n\n\tif (!ret)\n\t\tret = __intel_display_driver_resume(i915, state, &ctx);\n\n\tskl_watermark_ipc_update(i915);\n\tdrm_modeset_drop_locks(&ctx);\n\tdrm_modeset_acquire_fini(&ctx);\n\n\tif (ret)\n\t\tdrm_err(&i915->drm,\n\t\t\t\"Restoring old state failed with %i\\n\", ret);\n\tif (state)\n\t\tdrm_atomic_state_put(state);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}