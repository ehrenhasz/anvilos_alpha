{
  "module_name": "intel_dpll_mgr.c",
  "hash_id": "3baee41f3e265b2fa17119db31101bd91b28cb29746b90f9de8b21bc93f5020f",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/i915/display/intel_dpll_mgr.c",
  "human_readable_source": " \n\n#include <linux/math.h>\n#include <linux/string_helpers.h>\n\n#include \"i915_reg.h\"\n#include \"intel_de.h\"\n#include \"intel_display_types.h\"\n#include \"intel_dkl_phy.h\"\n#include \"intel_dkl_phy_regs.h\"\n#include \"intel_dpio_phy.h\"\n#include \"intel_dpll.h\"\n#include \"intel_dpll_mgr.h\"\n#include \"intel_hti.h\"\n#include \"intel_mg_phy_regs.h\"\n#include \"intel_pch_refclk.h\"\n#include \"intel_tc.h\"\n\n \n\n \nstruct intel_shared_dpll_funcs {\n\t \n\tvoid (*enable)(struct drm_i915_private *i915,\n\t\t       struct intel_shared_dpll *pll);\n\n\t \n\tvoid (*disable)(struct drm_i915_private *i915,\n\t\t\tstruct intel_shared_dpll *pll);\n\n\t \n\tbool (*get_hw_state)(struct drm_i915_private *i915,\n\t\t\t     struct intel_shared_dpll *pll,\n\t\t\t     struct intel_dpll_hw_state *hw_state);\n\n\t \n\tint (*get_freq)(struct drm_i915_private *i915,\n\t\t\tconst struct intel_shared_dpll *pll,\n\t\t\tconst struct intel_dpll_hw_state *pll_state);\n};\n\nstruct intel_dpll_mgr {\n\tconst struct dpll_info *dpll_info;\n\n\tint (*compute_dplls)(struct intel_atomic_state *state,\n\t\t\t     struct intel_crtc *crtc,\n\t\t\t     struct intel_encoder *encoder);\n\tint (*get_dplls)(struct intel_atomic_state *state,\n\t\t\t struct intel_crtc *crtc,\n\t\t\t struct intel_encoder *encoder);\n\tvoid (*put_dplls)(struct intel_atomic_state *state,\n\t\t\t  struct intel_crtc *crtc);\n\tvoid (*update_active_dpll)(struct intel_atomic_state *state,\n\t\t\t\t   struct intel_crtc *crtc,\n\t\t\t\t   struct intel_encoder *encoder);\n\tvoid (*update_ref_clks)(struct drm_i915_private *i915);\n\tvoid (*dump_hw_state)(struct drm_i915_private *dev_priv,\n\t\t\t      const struct intel_dpll_hw_state *hw_state);\n};\n\nstatic void\nintel_atomic_duplicate_dpll_state(struct drm_i915_private *dev_priv,\n\t\t\t\t  struct intel_shared_dpll_state *shared_dpll)\n{\n\tenum intel_dpll_id i;\n\n\t \n\tfor (i = 0; i < dev_priv->display.dpll.num_shared_dpll; i++) {\n\t\tstruct intel_shared_dpll *pll = &dev_priv->display.dpll.shared_dplls[i];\n\n\t\tshared_dpll[i] = pll->state;\n\t}\n}\n\nstatic struct intel_shared_dpll_state *\nintel_atomic_get_shared_dpll_state(struct drm_atomic_state *s)\n{\n\tstruct intel_atomic_state *state = to_intel_atomic_state(s);\n\n\tdrm_WARN_ON(s->dev, !drm_modeset_is_locked(&s->dev->mode_config.connection_mutex));\n\n\tif (!state->dpll_set) {\n\t\tstate->dpll_set = true;\n\n\t\tintel_atomic_duplicate_dpll_state(to_i915(s->dev),\n\t\t\t\t\t\t  state->shared_dpll);\n\t}\n\n\treturn state->shared_dpll;\n}\n\n \nstruct intel_shared_dpll *\nintel_get_shared_dpll_by_id(struct drm_i915_private *dev_priv,\n\t\t\t    enum intel_dpll_id id)\n{\n\treturn &dev_priv->display.dpll.shared_dplls[id];\n}\n\n \nvoid assert_shared_dpll(struct drm_i915_private *dev_priv,\n\t\t\tstruct intel_shared_dpll *pll,\n\t\t\tbool state)\n{\n\tbool cur_state;\n\tstruct intel_dpll_hw_state hw_state;\n\n\tif (drm_WARN(&dev_priv->drm, !pll,\n\t\t     \"asserting DPLL %s with no DPLL\\n\", str_on_off(state)))\n\t\treturn;\n\n\tcur_state = intel_dpll_get_hw_state(dev_priv, pll, &hw_state);\n\tI915_STATE_WARN(dev_priv, cur_state != state,\n\t\t\t\"%s assertion failure (expected %s, current %s)\\n\",\n\t\t\tpll->info->name, str_on_off(state),\n\t\t\tstr_on_off(cur_state));\n}\n\nstatic enum tc_port icl_pll_id_to_tc_port(enum intel_dpll_id id)\n{\n\treturn TC_PORT_1 + id - DPLL_ID_ICL_MGPLL1;\n}\n\nenum intel_dpll_id icl_tc_port_to_pll_id(enum tc_port tc_port)\n{\n\treturn tc_port - TC_PORT_1 + DPLL_ID_ICL_MGPLL1;\n}\n\nstatic i915_reg_t\nintel_combo_pll_enable_reg(struct drm_i915_private *i915,\n\t\t\t   struct intel_shared_dpll *pll)\n{\n\tif (IS_DG1(i915))\n\t\treturn DG1_DPLL_ENABLE(pll->info->id);\n\telse if ((IS_JASPERLAKE(i915) || IS_ELKHARTLAKE(i915)) &&\n\t\t (pll->info->id == DPLL_ID_EHL_DPLL4))\n\t\treturn MG_PLL_ENABLE(0);\n\n\treturn ICL_DPLL_ENABLE(pll->info->id);\n}\n\nstatic i915_reg_t\nintel_tc_pll_enable_reg(struct drm_i915_private *i915,\n\t\t\tstruct intel_shared_dpll *pll)\n{\n\tconst enum intel_dpll_id id = pll->info->id;\n\tenum tc_port tc_port = icl_pll_id_to_tc_port(id);\n\n\tif (IS_ALDERLAKE_P(i915))\n\t\treturn ADLP_PORTTC_PLL_ENABLE(tc_port);\n\n\treturn MG_PLL_ENABLE(tc_port);\n}\n\n \nvoid intel_enable_shared_dpll(const struct intel_crtc_state *crtc_state)\n{\n\tstruct intel_crtc *crtc = to_intel_crtc(crtc_state->uapi.crtc);\n\tstruct drm_i915_private *dev_priv = to_i915(crtc->base.dev);\n\tstruct intel_shared_dpll *pll = crtc_state->shared_dpll;\n\tunsigned int pipe_mask = BIT(crtc->pipe);\n\tunsigned int old_mask;\n\n\tif (drm_WARN_ON(&dev_priv->drm, pll == NULL))\n\t\treturn;\n\n\tmutex_lock(&dev_priv->display.dpll.lock);\n\told_mask = pll->active_mask;\n\n\tif (drm_WARN_ON(&dev_priv->drm, !(pll->state.pipe_mask & pipe_mask)) ||\n\t    drm_WARN_ON(&dev_priv->drm, pll->active_mask & pipe_mask))\n\t\tgoto out;\n\n\tpll->active_mask |= pipe_mask;\n\n\tdrm_dbg_kms(&dev_priv->drm,\n\t\t    \"enable %s (active 0x%x, on? %d) for [CRTC:%d:%s]\\n\",\n\t\t    pll->info->name, pll->active_mask, pll->on,\n\t\t    crtc->base.base.id, crtc->base.name);\n\n\tif (old_mask) {\n\t\tdrm_WARN_ON(&dev_priv->drm, !pll->on);\n\t\tassert_shared_dpll_enabled(dev_priv, pll);\n\t\tgoto out;\n\t}\n\tdrm_WARN_ON(&dev_priv->drm, pll->on);\n\n\tdrm_dbg_kms(&dev_priv->drm, \"enabling %s\\n\", pll->info->name);\n\tpll->info->funcs->enable(dev_priv, pll);\n\tpll->on = true;\n\nout:\n\tmutex_unlock(&dev_priv->display.dpll.lock);\n}\n\n \nvoid intel_disable_shared_dpll(const struct intel_crtc_state *crtc_state)\n{\n\tstruct intel_crtc *crtc = to_intel_crtc(crtc_state->uapi.crtc);\n\tstruct drm_i915_private *dev_priv = to_i915(crtc->base.dev);\n\tstruct intel_shared_dpll *pll = crtc_state->shared_dpll;\n\tunsigned int pipe_mask = BIT(crtc->pipe);\n\n\t \n\tif (DISPLAY_VER(dev_priv) < 5)\n\t\treturn;\n\n\tif (pll == NULL)\n\t\treturn;\n\n\tmutex_lock(&dev_priv->display.dpll.lock);\n\tif (drm_WARN(&dev_priv->drm, !(pll->active_mask & pipe_mask),\n\t\t     \"%s not used by [CRTC:%d:%s]\\n\", pll->info->name,\n\t\t     crtc->base.base.id, crtc->base.name))\n\t\tgoto out;\n\n\tdrm_dbg_kms(&dev_priv->drm,\n\t\t    \"disable %s (active 0x%x, on? %d) for [CRTC:%d:%s]\\n\",\n\t\t    pll->info->name, pll->active_mask, pll->on,\n\t\t    crtc->base.base.id, crtc->base.name);\n\n\tassert_shared_dpll_enabled(dev_priv, pll);\n\tdrm_WARN_ON(&dev_priv->drm, !pll->on);\n\n\tpll->active_mask &= ~pipe_mask;\n\tif (pll->active_mask)\n\t\tgoto out;\n\n\tdrm_dbg_kms(&dev_priv->drm, \"disabling %s\\n\", pll->info->name);\n\tpll->info->funcs->disable(dev_priv, pll);\n\tpll->on = false;\n\nout:\n\tmutex_unlock(&dev_priv->display.dpll.lock);\n}\n\nstatic struct intel_shared_dpll *\nintel_find_shared_dpll(struct intel_atomic_state *state,\n\t\t       const struct intel_crtc *crtc,\n\t\t       const struct intel_dpll_hw_state *pll_state,\n\t\t       unsigned long dpll_mask)\n{\n\tstruct drm_i915_private *dev_priv = to_i915(crtc->base.dev);\n\tstruct intel_shared_dpll *pll, *unused_pll = NULL;\n\tstruct intel_shared_dpll_state *shared_dpll;\n\tenum intel_dpll_id i;\n\n\tshared_dpll = intel_atomic_get_shared_dpll_state(&state->base);\n\n\tdrm_WARN_ON(&dev_priv->drm, dpll_mask & ~(BIT(I915_NUM_PLLS) - 1));\n\n\tfor_each_set_bit(i, &dpll_mask, I915_NUM_PLLS) {\n\t\tpll = &dev_priv->display.dpll.shared_dplls[i];\n\n\t\t \n\t\tif (shared_dpll[i].pipe_mask == 0) {\n\t\t\tif (!unused_pll)\n\t\t\t\tunused_pll = pll;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (memcmp(pll_state,\n\t\t\t   &shared_dpll[i].hw_state,\n\t\t\t   sizeof(*pll_state)) == 0) {\n\t\t\tdrm_dbg_kms(&dev_priv->drm,\n\t\t\t\t    \"[CRTC:%d:%s] sharing existing %s (pipe mask 0x%x, active 0x%x)\\n\",\n\t\t\t\t    crtc->base.base.id, crtc->base.name,\n\t\t\t\t    pll->info->name,\n\t\t\t\t    shared_dpll[i].pipe_mask,\n\t\t\t\t    pll->active_mask);\n\t\t\treturn pll;\n\t\t}\n\t}\n\n\t \n\tif (unused_pll) {\n\t\tdrm_dbg_kms(&dev_priv->drm, \"[CRTC:%d:%s] allocated %s\\n\",\n\t\t\t    crtc->base.base.id, crtc->base.name,\n\t\t\t    unused_pll->info->name);\n\t\treturn unused_pll;\n\t}\n\n\treturn NULL;\n}\n\n \nstatic void\nintel_reference_shared_dpll_crtc(const struct intel_crtc *crtc,\n\t\t\t\t const struct intel_shared_dpll *pll,\n\t\t\t\t struct intel_shared_dpll_state *shared_dpll_state)\n{\n\tstruct drm_i915_private *i915 = to_i915(crtc->base.dev);\n\n\tdrm_WARN_ON(&i915->drm, (shared_dpll_state->pipe_mask & BIT(crtc->pipe)) != 0);\n\n\tshared_dpll_state->pipe_mask |= BIT(crtc->pipe);\n\n\tdrm_dbg_kms(&i915->drm, \"[CRTC:%d:%s] reserving %s\\n\",\n\t\t    crtc->base.base.id, crtc->base.name, pll->info->name);\n}\n\nstatic void\nintel_reference_shared_dpll(struct intel_atomic_state *state,\n\t\t\t    const struct intel_crtc *crtc,\n\t\t\t    const struct intel_shared_dpll *pll,\n\t\t\t    const struct intel_dpll_hw_state *pll_state)\n{\n\tstruct intel_shared_dpll_state *shared_dpll;\n\tconst enum intel_dpll_id id = pll->info->id;\n\n\tshared_dpll = intel_atomic_get_shared_dpll_state(&state->base);\n\n\tif (shared_dpll[id].pipe_mask == 0)\n\t\tshared_dpll[id].hw_state = *pll_state;\n\n\tintel_reference_shared_dpll_crtc(crtc, pll, &shared_dpll[id]);\n}\n\n \nvoid\nintel_unreference_shared_dpll_crtc(const struct intel_crtc *crtc,\n\t\t\t\t   const struct intel_shared_dpll *pll,\n\t\t\t\t   struct intel_shared_dpll_state *shared_dpll_state)\n{\n\tstruct drm_i915_private *i915 = to_i915(crtc->base.dev);\n\n\tdrm_WARN_ON(&i915->drm, (shared_dpll_state->pipe_mask & BIT(crtc->pipe)) == 0);\n\n\tshared_dpll_state->pipe_mask &= ~BIT(crtc->pipe);\n\n\tdrm_dbg_kms(&i915->drm, \"[CRTC:%d:%s] releasing %s\\n\",\n\t\t    crtc->base.base.id, crtc->base.name, pll->info->name);\n}\n\nstatic void intel_unreference_shared_dpll(struct intel_atomic_state *state,\n\t\t\t\t\t  const struct intel_crtc *crtc,\n\t\t\t\t\t  const struct intel_shared_dpll *pll)\n{\n\tstruct intel_shared_dpll_state *shared_dpll;\n\tconst enum intel_dpll_id id = pll->info->id;\n\n\tshared_dpll = intel_atomic_get_shared_dpll_state(&state->base);\n\n\tintel_unreference_shared_dpll_crtc(crtc, pll, &shared_dpll[id]);\n}\n\nstatic void intel_put_dpll(struct intel_atomic_state *state,\n\t\t\t   struct intel_crtc *crtc)\n{\n\tconst struct intel_crtc_state *old_crtc_state =\n\t\tintel_atomic_get_old_crtc_state(state, crtc);\n\tstruct intel_crtc_state *new_crtc_state =\n\t\tintel_atomic_get_new_crtc_state(state, crtc);\n\n\tnew_crtc_state->shared_dpll = NULL;\n\n\tif (!old_crtc_state->shared_dpll)\n\t\treturn;\n\n\tintel_unreference_shared_dpll(state, crtc, old_crtc_state->shared_dpll);\n}\n\n \nvoid intel_shared_dpll_swap_state(struct intel_atomic_state *state)\n{\n\tstruct drm_i915_private *dev_priv = to_i915(state->base.dev);\n\tstruct intel_shared_dpll_state *shared_dpll = state->shared_dpll;\n\tenum intel_dpll_id i;\n\n\tif (!state->dpll_set)\n\t\treturn;\n\n\tfor (i = 0; i < dev_priv->display.dpll.num_shared_dpll; i++) {\n\t\tstruct intel_shared_dpll *pll =\n\t\t\t&dev_priv->display.dpll.shared_dplls[i];\n\n\t\tswap(pll->state, shared_dpll[i]);\n\t}\n}\n\nstatic bool ibx_pch_dpll_get_hw_state(struct drm_i915_private *dev_priv,\n\t\t\t\t      struct intel_shared_dpll *pll,\n\t\t\t\t      struct intel_dpll_hw_state *hw_state)\n{\n\tconst enum intel_dpll_id id = pll->info->id;\n\tintel_wakeref_t wakeref;\n\tu32 val;\n\n\twakeref = intel_display_power_get_if_enabled(dev_priv,\n\t\t\t\t\t\t     POWER_DOMAIN_DISPLAY_CORE);\n\tif (!wakeref)\n\t\treturn false;\n\n\tval = intel_de_read(dev_priv, PCH_DPLL(id));\n\thw_state->dpll = val;\n\thw_state->fp0 = intel_de_read(dev_priv, PCH_FP0(id));\n\thw_state->fp1 = intel_de_read(dev_priv, PCH_FP1(id));\n\n\tintel_display_power_put(dev_priv, POWER_DOMAIN_DISPLAY_CORE, wakeref);\n\n\treturn val & DPLL_VCO_ENABLE;\n}\n\nstatic void ibx_assert_pch_refclk_enabled(struct drm_i915_private *dev_priv)\n{\n\tu32 val;\n\tbool enabled;\n\n\tval = intel_de_read(dev_priv, PCH_DREF_CONTROL);\n\tenabled = !!(val & (DREF_SSC_SOURCE_MASK | DREF_NONSPREAD_SOURCE_MASK |\n\t\t\t    DREF_SUPERSPREAD_SOURCE_MASK));\n\tI915_STATE_WARN(dev_priv, !enabled,\n\t\t\t\"PCH refclk assertion failure, should be active but is disabled\\n\");\n}\n\nstatic void ibx_pch_dpll_enable(struct drm_i915_private *dev_priv,\n\t\t\t\tstruct intel_shared_dpll *pll)\n{\n\tconst enum intel_dpll_id id = pll->info->id;\n\n\t \n\tibx_assert_pch_refclk_enabled(dev_priv);\n\n\tintel_de_write(dev_priv, PCH_FP0(id), pll->state.hw_state.fp0);\n\tintel_de_write(dev_priv, PCH_FP1(id), pll->state.hw_state.fp1);\n\n\tintel_de_write(dev_priv, PCH_DPLL(id), pll->state.hw_state.dpll);\n\n\t \n\tintel_de_posting_read(dev_priv, PCH_DPLL(id));\n\tudelay(150);\n\n\t \n\tintel_de_write(dev_priv, PCH_DPLL(id), pll->state.hw_state.dpll);\n\tintel_de_posting_read(dev_priv, PCH_DPLL(id));\n\tudelay(200);\n}\n\nstatic void ibx_pch_dpll_disable(struct drm_i915_private *dev_priv,\n\t\t\t\t struct intel_shared_dpll *pll)\n{\n\tconst enum intel_dpll_id id = pll->info->id;\n\n\tintel_de_write(dev_priv, PCH_DPLL(id), 0);\n\tintel_de_posting_read(dev_priv, PCH_DPLL(id));\n\tudelay(200);\n}\n\nstatic int ibx_compute_dpll(struct intel_atomic_state *state,\n\t\t\t    struct intel_crtc *crtc,\n\t\t\t    struct intel_encoder *encoder)\n{\n\treturn 0;\n}\n\nstatic int ibx_get_dpll(struct intel_atomic_state *state,\n\t\t\tstruct intel_crtc *crtc,\n\t\t\tstruct intel_encoder *encoder)\n{\n\tstruct intel_crtc_state *crtc_state =\n\t\tintel_atomic_get_new_crtc_state(state, crtc);\n\tstruct drm_i915_private *dev_priv = to_i915(crtc->base.dev);\n\tstruct intel_shared_dpll *pll;\n\tenum intel_dpll_id i;\n\n\tif (HAS_PCH_IBX(dev_priv)) {\n\t\t \n\t\ti = (enum intel_dpll_id) crtc->pipe;\n\t\tpll = &dev_priv->display.dpll.shared_dplls[i];\n\n\t\tdrm_dbg_kms(&dev_priv->drm,\n\t\t\t    \"[CRTC:%d:%s] using pre-allocated %s\\n\",\n\t\t\t    crtc->base.base.id, crtc->base.name,\n\t\t\t    pll->info->name);\n\t} else {\n\t\tpll = intel_find_shared_dpll(state, crtc,\n\t\t\t\t\t     &crtc_state->dpll_hw_state,\n\t\t\t\t\t     BIT(DPLL_ID_PCH_PLL_B) |\n\t\t\t\t\t     BIT(DPLL_ID_PCH_PLL_A));\n\t}\n\n\tif (!pll)\n\t\treturn -EINVAL;\n\n\t \n\tintel_reference_shared_dpll(state, crtc,\n\t\t\t\t    pll, &crtc_state->dpll_hw_state);\n\n\tcrtc_state->shared_dpll = pll;\n\n\treturn 0;\n}\n\nstatic void ibx_dump_hw_state(struct drm_i915_private *dev_priv,\n\t\t\t      const struct intel_dpll_hw_state *hw_state)\n{\n\tdrm_dbg_kms(&dev_priv->drm,\n\t\t    \"dpll_hw_state: dpll: 0x%x, dpll_md: 0x%x, \"\n\t\t    \"fp0: 0x%x, fp1: 0x%x\\n\",\n\t\t    hw_state->dpll,\n\t\t    hw_state->dpll_md,\n\t\t    hw_state->fp0,\n\t\t    hw_state->fp1);\n}\n\nstatic const struct intel_shared_dpll_funcs ibx_pch_dpll_funcs = {\n\t.enable = ibx_pch_dpll_enable,\n\t.disable = ibx_pch_dpll_disable,\n\t.get_hw_state = ibx_pch_dpll_get_hw_state,\n};\n\nstatic const struct dpll_info pch_plls[] = {\n\t{ \"PCH DPLL A\", &ibx_pch_dpll_funcs, DPLL_ID_PCH_PLL_A, 0 },\n\t{ \"PCH DPLL B\", &ibx_pch_dpll_funcs, DPLL_ID_PCH_PLL_B, 0 },\n\t{ },\n};\n\nstatic const struct intel_dpll_mgr pch_pll_mgr = {\n\t.dpll_info = pch_plls,\n\t.compute_dplls = ibx_compute_dpll,\n\t.get_dplls = ibx_get_dpll,\n\t.put_dplls = intel_put_dpll,\n\t.dump_hw_state = ibx_dump_hw_state,\n};\n\nstatic void hsw_ddi_wrpll_enable(struct drm_i915_private *dev_priv,\n\t\t\t\t struct intel_shared_dpll *pll)\n{\n\tconst enum intel_dpll_id id = pll->info->id;\n\n\tintel_de_write(dev_priv, WRPLL_CTL(id), pll->state.hw_state.wrpll);\n\tintel_de_posting_read(dev_priv, WRPLL_CTL(id));\n\tudelay(20);\n}\n\nstatic void hsw_ddi_spll_enable(struct drm_i915_private *dev_priv,\n\t\t\t\tstruct intel_shared_dpll *pll)\n{\n\tintel_de_write(dev_priv, SPLL_CTL, pll->state.hw_state.spll);\n\tintel_de_posting_read(dev_priv, SPLL_CTL);\n\tudelay(20);\n}\n\nstatic void hsw_ddi_wrpll_disable(struct drm_i915_private *dev_priv,\n\t\t\t\t  struct intel_shared_dpll *pll)\n{\n\tconst enum intel_dpll_id id = pll->info->id;\n\n\tintel_de_rmw(dev_priv, WRPLL_CTL(id), WRPLL_PLL_ENABLE, 0);\n\tintel_de_posting_read(dev_priv, WRPLL_CTL(id));\n\n\t \n\tif (dev_priv->display.dpll.pch_ssc_use & BIT(id))\n\t\tintel_init_pch_refclk(dev_priv);\n}\n\nstatic void hsw_ddi_spll_disable(struct drm_i915_private *dev_priv,\n\t\t\t\t struct intel_shared_dpll *pll)\n{\n\tenum intel_dpll_id id = pll->info->id;\n\n\tintel_de_rmw(dev_priv, SPLL_CTL, SPLL_PLL_ENABLE, 0);\n\tintel_de_posting_read(dev_priv, SPLL_CTL);\n\n\t \n\tif (dev_priv->display.dpll.pch_ssc_use & BIT(id))\n\t\tintel_init_pch_refclk(dev_priv);\n}\n\nstatic bool hsw_ddi_wrpll_get_hw_state(struct drm_i915_private *dev_priv,\n\t\t\t\t       struct intel_shared_dpll *pll,\n\t\t\t\t       struct intel_dpll_hw_state *hw_state)\n{\n\tconst enum intel_dpll_id id = pll->info->id;\n\tintel_wakeref_t wakeref;\n\tu32 val;\n\n\twakeref = intel_display_power_get_if_enabled(dev_priv,\n\t\t\t\t\t\t     POWER_DOMAIN_DISPLAY_CORE);\n\tif (!wakeref)\n\t\treturn false;\n\n\tval = intel_de_read(dev_priv, WRPLL_CTL(id));\n\thw_state->wrpll = val;\n\n\tintel_display_power_put(dev_priv, POWER_DOMAIN_DISPLAY_CORE, wakeref);\n\n\treturn val & WRPLL_PLL_ENABLE;\n}\n\nstatic bool hsw_ddi_spll_get_hw_state(struct drm_i915_private *dev_priv,\n\t\t\t\t      struct intel_shared_dpll *pll,\n\t\t\t\t      struct intel_dpll_hw_state *hw_state)\n{\n\tintel_wakeref_t wakeref;\n\tu32 val;\n\n\twakeref = intel_display_power_get_if_enabled(dev_priv,\n\t\t\t\t\t\t     POWER_DOMAIN_DISPLAY_CORE);\n\tif (!wakeref)\n\t\treturn false;\n\n\tval = intel_de_read(dev_priv, SPLL_CTL);\n\thw_state->spll = val;\n\n\tintel_display_power_put(dev_priv, POWER_DOMAIN_DISPLAY_CORE, wakeref);\n\n\treturn val & SPLL_PLL_ENABLE;\n}\n\n#define LC_FREQ 2700\n#define LC_FREQ_2K U64_C(LC_FREQ * 2000)\n\n#define P_MIN 2\n#define P_MAX 64\n#define P_INC 2\n\n \n#define REF_MIN 48\n#define REF_MAX 400\n#define VCO_MIN 2400\n#define VCO_MAX 4800\n\nstruct hsw_wrpll_rnp {\n\tunsigned p, n2, r2;\n};\n\nstatic unsigned hsw_wrpll_get_budget_for_freq(int clock)\n{\n\tswitch (clock) {\n\tcase 25175000:\n\tcase 25200000:\n\tcase 27000000:\n\tcase 27027000:\n\tcase 37762500:\n\tcase 37800000:\n\tcase 40500000:\n\tcase 40541000:\n\tcase 54000000:\n\tcase 54054000:\n\tcase 59341000:\n\tcase 59400000:\n\tcase 72000000:\n\tcase 74176000:\n\tcase 74250000:\n\tcase 81000000:\n\tcase 81081000:\n\tcase 89012000:\n\tcase 89100000:\n\tcase 108000000:\n\tcase 108108000:\n\tcase 111264000:\n\tcase 111375000:\n\tcase 148352000:\n\tcase 148500000:\n\tcase 162000000:\n\tcase 162162000:\n\tcase 222525000:\n\tcase 222750000:\n\tcase 296703000:\n\tcase 297000000:\n\t\treturn 0;\n\tcase 233500000:\n\tcase 245250000:\n\tcase 247750000:\n\tcase 253250000:\n\tcase 298000000:\n\t\treturn 1500;\n\tcase 169128000:\n\tcase 169500000:\n\tcase 179500000:\n\tcase 202000000:\n\t\treturn 2000;\n\tcase 256250000:\n\tcase 262500000:\n\tcase 270000000:\n\tcase 272500000:\n\tcase 273750000:\n\tcase 280750000:\n\tcase 281250000:\n\tcase 286000000:\n\tcase 291750000:\n\t\treturn 4000;\n\tcase 267250000:\n\tcase 268500000:\n\t\treturn 5000;\n\tdefault:\n\t\treturn 1000;\n\t}\n}\n\nstatic void hsw_wrpll_update_rnp(u64 freq2k, unsigned int budget,\n\t\t\t\t unsigned int r2, unsigned int n2,\n\t\t\t\t unsigned int p,\n\t\t\t\t struct hsw_wrpll_rnp *best)\n{\n\tu64 a, b, c, d, diff, diff_best;\n\n\t \n\tif (best->p == 0) {\n\t\tbest->p = p;\n\t\tbest->n2 = n2;\n\t\tbest->r2 = r2;\n\t\treturn;\n\t}\n\n\t \n\ta = freq2k * budget * p * r2;\n\tb = freq2k * budget * best->p * best->r2;\n\tdiff = abs_diff(freq2k * p * r2, LC_FREQ_2K * n2);\n\tdiff_best = abs_diff(freq2k * best->p * best->r2,\n\t\t\t     LC_FREQ_2K * best->n2);\n\tc = 1000000 * diff;\n\td = 1000000 * diff_best;\n\n\tif (a < c && b < d) {\n\t\t \n\t\tif (best->p * best->r2 * diff < p * r2 * diff_best) {\n\t\t\tbest->p = p;\n\t\t\tbest->n2 = n2;\n\t\t\tbest->r2 = r2;\n\t\t}\n\t} else if (a >= c && b < d) {\n\t\t \n\t\tbest->p = p;\n\t\tbest->n2 = n2;\n\t\tbest->r2 = r2;\n\t} else if (a >= c && b >= d) {\n\t\t \n\t\tif (n2 * best->r2 * best->r2 > best->n2 * r2 * r2) {\n\t\t\tbest->p = p;\n\t\t\tbest->n2 = n2;\n\t\t\tbest->r2 = r2;\n\t\t}\n\t}\n\t \n}\n\nstatic void\nhsw_ddi_calculate_wrpll(int clock  ,\n\t\t\tunsigned *r2_out, unsigned *n2_out, unsigned *p_out)\n{\n\tu64 freq2k;\n\tunsigned p, n2, r2;\n\tstruct hsw_wrpll_rnp best = {};\n\tunsigned budget;\n\n\tfreq2k = clock / 100;\n\n\tbudget = hsw_wrpll_get_budget_for_freq(clock);\n\n\t \n\tif (freq2k == 5400000) {\n\t\t*n2_out = 2;\n\t\t*p_out = 1;\n\t\t*r2_out = 2;\n\t\treturn;\n\t}\n\n\t \n\tfor (r2 = LC_FREQ * 2 / REF_MAX + 1;\n\t     r2 <= LC_FREQ * 2 / REF_MIN;\n\t     r2++) {\n\n\t\t \n\t\tfor (n2 = VCO_MIN * r2 / LC_FREQ + 1;\n\t\t     n2 <= VCO_MAX * r2 / LC_FREQ;\n\t\t     n2++) {\n\n\t\t\tfor (p = P_MIN; p <= P_MAX; p += P_INC)\n\t\t\t\thsw_wrpll_update_rnp(freq2k, budget,\n\t\t\t\t\t\t     r2, n2, p, &best);\n\t\t}\n\t}\n\n\t*n2_out = best.n2;\n\t*p_out = best.p;\n\t*r2_out = best.r2;\n}\n\nstatic int hsw_ddi_wrpll_get_freq(struct drm_i915_private *dev_priv,\n\t\t\t\t  const struct intel_shared_dpll *pll,\n\t\t\t\t  const struct intel_dpll_hw_state *pll_state)\n{\n\tint refclk;\n\tint n, p, r;\n\tu32 wrpll = pll_state->wrpll;\n\n\tswitch (wrpll & WRPLL_REF_MASK) {\n\tcase WRPLL_REF_SPECIAL_HSW:\n\t\t \n\t\tif (IS_HASWELL(dev_priv) && !IS_HASWELL_ULT(dev_priv)) {\n\t\t\trefclk = dev_priv->display.dpll.ref_clks.nssc;\n\t\t\tbreak;\n\t\t}\n\t\tfallthrough;\n\tcase WRPLL_REF_PCH_SSC:\n\t\t \n\t\trefclk = dev_priv->display.dpll.ref_clks.ssc;\n\t\tbreak;\n\tcase WRPLL_REF_LCPLL:\n\t\trefclk = 2700000;\n\t\tbreak;\n\tdefault:\n\t\tMISSING_CASE(wrpll);\n\t\treturn 0;\n\t}\n\n\tr = wrpll & WRPLL_DIVIDER_REF_MASK;\n\tp = (wrpll & WRPLL_DIVIDER_POST_MASK) >> WRPLL_DIVIDER_POST_SHIFT;\n\tn = (wrpll & WRPLL_DIVIDER_FB_MASK) >> WRPLL_DIVIDER_FB_SHIFT;\n\n\t \n\treturn (refclk * n / 10) / (p * r) * 2;\n}\n\nstatic int\nhsw_ddi_wrpll_compute_dpll(struct intel_atomic_state *state,\n\t\t\t   struct intel_crtc *crtc)\n{\n\tstruct drm_i915_private *i915 = to_i915(state->base.dev);\n\tstruct intel_crtc_state *crtc_state =\n\t\tintel_atomic_get_new_crtc_state(state, crtc);\n\tunsigned int p, n2, r2;\n\n\thsw_ddi_calculate_wrpll(crtc_state->port_clock * 1000, &r2, &n2, &p);\n\n\tcrtc_state->dpll_hw_state.wrpll =\n\t\tWRPLL_PLL_ENABLE | WRPLL_REF_LCPLL |\n\t\tWRPLL_DIVIDER_REFERENCE(r2) | WRPLL_DIVIDER_FEEDBACK(n2) |\n\t\tWRPLL_DIVIDER_POST(p);\n\n\tcrtc_state->port_clock = hsw_ddi_wrpll_get_freq(i915, NULL,\n\t\t\t\t\t\t\t&crtc_state->dpll_hw_state);\n\n\treturn 0;\n}\n\nstatic struct intel_shared_dpll *\nhsw_ddi_wrpll_get_dpll(struct intel_atomic_state *state,\n\t\t       struct intel_crtc *crtc)\n{\n\tstruct intel_crtc_state *crtc_state =\n\t\tintel_atomic_get_new_crtc_state(state, crtc);\n\n\treturn intel_find_shared_dpll(state, crtc,\n\t\t\t\t      &crtc_state->dpll_hw_state,\n\t\t\t\t      BIT(DPLL_ID_WRPLL2) |\n\t\t\t\t      BIT(DPLL_ID_WRPLL1));\n}\n\nstatic int\nhsw_ddi_lcpll_compute_dpll(struct intel_crtc_state *crtc_state)\n{\n\tstruct drm_i915_private *dev_priv = to_i915(crtc_state->uapi.crtc->dev);\n\tint clock = crtc_state->port_clock;\n\n\tswitch (clock / 2) {\n\tcase 81000:\n\tcase 135000:\n\tcase 270000:\n\t\treturn 0;\n\tdefault:\n\t\tdrm_dbg_kms(&dev_priv->drm, \"Invalid clock for DP: %d\\n\",\n\t\t\t    clock);\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic struct intel_shared_dpll *\nhsw_ddi_lcpll_get_dpll(struct intel_crtc_state *crtc_state)\n{\n\tstruct drm_i915_private *dev_priv = to_i915(crtc_state->uapi.crtc->dev);\n\tstruct intel_shared_dpll *pll;\n\tenum intel_dpll_id pll_id;\n\tint clock = crtc_state->port_clock;\n\n\tswitch (clock / 2) {\n\tcase 81000:\n\t\tpll_id = DPLL_ID_LCPLL_810;\n\t\tbreak;\n\tcase 135000:\n\t\tpll_id = DPLL_ID_LCPLL_1350;\n\t\tbreak;\n\tcase 270000:\n\t\tpll_id = DPLL_ID_LCPLL_2700;\n\t\tbreak;\n\tdefault:\n\t\tMISSING_CASE(clock / 2);\n\t\treturn NULL;\n\t}\n\n\tpll = intel_get_shared_dpll_by_id(dev_priv, pll_id);\n\n\tif (!pll)\n\t\treturn NULL;\n\n\treturn pll;\n}\n\nstatic int hsw_ddi_lcpll_get_freq(struct drm_i915_private *i915,\n\t\t\t\t  const struct intel_shared_dpll *pll,\n\t\t\t\t  const struct intel_dpll_hw_state *pll_state)\n{\n\tint link_clock = 0;\n\n\tswitch (pll->info->id) {\n\tcase DPLL_ID_LCPLL_810:\n\t\tlink_clock = 81000;\n\t\tbreak;\n\tcase DPLL_ID_LCPLL_1350:\n\t\tlink_clock = 135000;\n\t\tbreak;\n\tcase DPLL_ID_LCPLL_2700:\n\t\tlink_clock = 270000;\n\t\tbreak;\n\tdefault:\n\t\tdrm_WARN(&i915->drm, 1, \"bad port clock sel\\n\");\n\t\tbreak;\n\t}\n\n\treturn link_clock * 2;\n}\n\nstatic int\nhsw_ddi_spll_compute_dpll(struct intel_atomic_state *state,\n\t\t\t  struct intel_crtc *crtc)\n{\n\tstruct intel_crtc_state *crtc_state =\n\t\tintel_atomic_get_new_crtc_state(state, crtc);\n\n\tif (drm_WARN_ON(crtc->base.dev, crtc_state->port_clock / 2 != 135000))\n\t\treturn -EINVAL;\n\n\tcrtc_state->dpll_hw_state.spll =\n\t\tSPLL_PLL_ENABLE | SPLL_FREQ_1350MHz | SPLL_REF_MUXED_SSC;\n\n\treturn 0;\n}\n\nstatic struct intel_shared_dpll *\nhsw_ddi_spll_get_dpll(struct intel_atomic_state *state,\n\t\t      struct intel_crtc *crtc)\n{\n\tstruct intel_crtc_state *crtc_state =\n\t\tintel_atomic_get_new_crtc_state(state, crtc);\n\n\treturn intel_find_shared_dpll(state, crtc, &crtc_state->dpll_hw_state,\n\t\t\t\t      BIT(DPLL_ID_SPLL));\n}\n\nstatic int hsw_ddi_spll_get_freq(struct drm_i915_private *i915,\n\t\t\t\t const struct intel_shared_dpll *pll,\n\t\t\t\t const struct intel_dpll_hw_state *pll_state)\n{\n\tint link_clock = 0;\n\n\tswitch (pll_state->spll & SPLL_FREQ_MASK) {\n\tcase SPLL_FREQ_810MHz:\n\t\tlink_clock = 81000;\n\t\tbreak;\n\tcase SPLL_FREQ_1350MHz:\n\t\tlink_clock = 135000;\n\t\tbreak;\n\tcase SPLL_FREQ_2700MHz:\n\t\tlink_clock = 270000;\n\t\tbreak;\n\tdefault:\n\t\tdrm_WARN(&i915->drm, 1, \"bad spll freq\\n\");\n\t\tbreak;\n\t}\n\n\treturn link_clock * 2;\n}\n\nstatic int hsw_compute_dpll(struct intel_atomic_state *state,\n\t\t\t    struct intel_crtc *crtc,\n\t\t\t    struct intel_encoder *encoder)\n{\n\tstruct intel_crtc_state *crtc_state =\n\t\tintel_atomic_get_new_crtc_state(state, crtc);\n\n\tif (intel_crtc_has_type(crtc_state, INTEL_OUTPUT_HDMI))\n\t\treturn hsw_ddi_wrpll_compute_dpll(state, crtc);\n\telse if (intel_crtc_has_dp_encoder(crtc_state))\n\t\treturn hsw_ddi_lcpll_compute_dpll(crtc_state);\n\telse if (intel_crtc_has_type(crtc_state, INTEL_OUTPUT_ANALOG))\n\t\treturn hsw_ddi_spll_compute_dpll(state, crtc);\n\telse\n\t\treturn -EINVAL;\n}\n\nstatic int hsw_get_dpll(struct intel_atomic_state *state,\n\t\t\tstruct intel_crtc *crtc,\n\t\t\tstruct intel_encoder *encoder)\n{\n\tstruct intel_crtc_state *crtc_state =\n\t\tintel_atomic_get_new_crtc_state(state, crtc);\n\tstruct intel_shared_dpll *pll = NULL;\n\n\tif (intel_crtc_has_type(crtc_state, INTEL_OUTPUT_HDMI))\n\t\tpll = hsw_ddi_wrpll_get_dpll(state, crtc);\n\telse if (intel_crtc_has_dp_encoder(crtc_state))\n\t\tpll = hsw_ddi_lcpll_get_dpll(crtc_state);\n\telse if (intel_crtc_has_type(crtc_state, INTEL_OUTPUT_ANALOG))\n\t\tpll = hsw_ddi_spll_get_dpll(state, crtc);\n\n\tif (!pll)\n\t\treturn -EINVAL;\n\n\tintel_reference_shared_dpll(state, crtc,\n\t\t\t\t    pll, &crtc_state->dpll_hw_state);\n\n\tcrtc_state->shared_dpll = pll;\n\n\treturn 0;\n}\n\nstatic void hsw_update_dpll_ref_clks(struct drm_i915_private *i915)\n{\n\ti915->display.dpll.ref_clks.ssc = 135000;\n\t \n\tif (intel_de_read(i915, FUSE_STRAP3) & HSW_REF_CLK_SELECT)\n\t\ti915->display.dpll.ref_clks.nssc = 24000;\n\telse\n\t\ti915->display.dpll.ref_clks.nssc = 135000;\n}\n\nstatic void hsw_dump_hw_state(struct drm_i915_private *dev_priv,\n\t\t\t      const struct intel_dpll_hw_state *hw_state)\n{\n\tdrm_dbg_kms(&dev_priv->drm, \"dpll_hw_state: wrpll: 0x%x spll: 0x%x\\n\",\n\t\t    hw_state->wrpll, hw_state->spll);\n}\n\nstatic const struct intel_shared_dpll_funcs hsw_ddi_wrpll_funcs = {\n\t.enable = hsw_ddi_wrpll_enable,\n\t.disable = hsw_ddi_wrpll_disable,\n\t.get_hw_state = hsw_ddi_wrpll_get_hw_state,\n\t.get_freq = hsw_ddi_wrpll_get_freq,\n};\n\nstatic const struct intel_shared_dpll_funcs hsw_ddi_spll_funcs = {\n\t.enable = hsw_ddi_spll_enable,\n\t.disable = hsw_ddi_spll_disable,\n\t.get_hw_state = hsw_ddi_spll_get_hw_state,\n\t.get_freq = hsw_ddi_spll_get_freq,\n};\n\nstatic void hsw_ddi_lcpll_enable(struct drm_i915_private *dev_priv,\n\t\t\t\t struct intel_shared_dpll *pll)\n{\n}\n\nstatic void hsw_ddi_lcpll_disable(struct drm_i915_private *dev_priv,\n\t\t\t\t  struct intel_shared_dpll *pll)\n{\n}\n\nstatic bool hsw_ddi_lcpll_get_hw_state(struct drm_i915_private *dev_priv,\n\t\t\t\t       struct intel_shared_dpll *pll,\n\t\t\t\t       struct intel_dpll_hw_state *hw_state)\n{\n\treturn true;\n}\n\nstatic const struct intel_shared_dpll_funcs hsw_ddi_lcpll_funcs = {\n\t.enable = hsw_ddi_lcpll_enable,\n\t.disable = hsw_ddi_lcpll_disable,\n\t.get_hw_state = hsw_ddi_lcpll_get_hw_state,\n\t.get_freq = hsw_ddi_lcpll_get_freq,\n};\n\nstatic const struct dpll_info hsw_plls[] = {\n\t{ \"WRPLL 1\",    &hsw_ddi_wrpll_funcs, DPLL_ID_WRPLL1,     0 },\n\t{ \"WRPLL 2\",    &hsw_ddi_wrpll_funcs, DPLL_ID_WRPLL2,     0 },\n\t{ \"SPLL\",       &hsw_ddi_spll_funcs,  DPLL_ID_SPLL,       0 },\n\t{ \"LCPLL 810\",  &hsw_ddi_lcpll_funcs, DPLL_ID_LCPLL_810,  INTEL_DPLL_ALWAYS_ON },\n\t{ \"LCPLL 1350\", &hsw_ddi_lcpll_funcs, DPLL_ID_LCPLL_1350, INTEL_DPLL_ALWAYS_ON },\n\t{ \"LCPLL 2700\", &hsw_ddi_lcpll_funcs, DPLL_ID_LCPLL_2700, INTEL_DPLL_ALWAYS_ON },\n\t{ },\n};\n\nstatic const struct intel_dpll_mgr hsw_pll_mgr = {\n\t.dpll_info = hsw_plls,\n\t.compute_dplls = hsw_compute_dpll,\n\t.get_dplls = hsw_get_dpll,\n\t.put_dplls = intel_put_dpll,\n\t.update_ref_clks = hsw_update_dpll_ref_clks,\n\t.dump_hw_state = hsw_dump_hw_state,\n};\n\nstruct skl_dpll_regs {\n\ti915_reg_t ctl, cfgcr1, cfgcr2;\n};\n\n \nstatic const struct skl_dpll_regs skl_dpll_regs[4] = {\n\t{\n\t\t \n\t\t.ctl = LCPLL1_CTL,\n\t\t \n\t},\n\t{\n\t\t \n\t\t.ctl = LCPLL2_CTL,\n\t\t.cfgcr1 = DPLL_CFGCR1(SKL_DPLL1),\n\t\t.cfgcr2 = DPLL_CFGCR2(SKL_DPLL1),\n\t},\n\t{\n\t\t \n\t\t.ctl = WRPLL_CTL(0),\n\t\t.cfgcr1 = DPLL_CFGCR1(SKL_DPLL2),\n\t\t.cfgcr2 = DPLL_CFGCR2(SKL_DPLL2),\n\t},\n\t{\n\t\t \n\t\t.ctl = WRPLL_CTL(1),\n\t\t.cfgcr1 = DPLL_CFGCR1(SKL_DPLL3),\n\t\t.cfgcr2 = DPLL_CFGCR2(SKL_DPLL3),\n\t},\n};\n\nstatic void skl_ddi_pll_write_ctrl1(struct drm_i915_private *dev_priv,\n\t\t\t\t    struct intel_shared_dpll *pll)\n{\n\tconst enum intel_dpll_id id = pll->info->id;\n\n\tintel_de_rmw(dev_priv, DPLL_CTRL1,\n\t\t     DPLL_CTRL1_HDMI_MODE(id) | DPLL_CTRL1_SSC(id) | DPLL_CTRL1_LINK_RATE_MASK(id),\n\t\t     pll->state.hw_state.ctrl1 << (id * 6));\n\tintel_de_posting_read(dev_priv, DPLL_CTRL1);\n}\n\nstatic void skl_ddi_pll_enable(struct drm_i915_private *dev_priv,\n\t\t\t       struct intel_shared_dpll *pll)\n{\n\tconst struct skl_dpll_regs *regs = skl_dpll_regs;\n\tconst enum intel_dpll_id id = pll->info->id;\n\n\tskl_ddi_pll_write_ctrl1(dev_priv, pll);\n\n\tintel_de_write(dev_priv, regs[id].cfgcr1, pll->state.hw_state.cfgcr1);\n\tintel_de_write(dev_priv, regs[id].cfgcr2, pll->state.hw_state.cfgcr2);\n\tintel_de_posting_read(dev_priv, regs[id].cfgcr1);\n\tintel_de_posting_read(dev_priv, regs[id].cfgcr2);\n\n\t \n\tintel_de_rmw(dev_priv, regs[id].ctl, 0, LCPLL_PLL_ENABLE);\n\n\tif (intel_de_wait_for_set(dev_priv, DPLL_STATUS, DPLL_LOCK(id), 5))\n\t\tdrm_err(&dev_priv->drm, \"DPLL %d not locked\\n\", id);\n}\n\nstatic void skl_ddi_dpll0_enable(struct drm_i915_private *dev_priv,\n\t\t\t\t struct intel_shared_dpll *pll)\n{\n\tskl_ddi_pll_write_ctrl1(dev_priv, pll);\n}\n\nstatic void skl_ddi_pll_disable(struct drm_i915_private *dev_priv,\n\t\t\t\tstruct intel_shared_dpll *pll)\n{\n\tconst struct skl_dpll_regs *regs = skl_dpll_regs;\n\tconst enum intel_dpll_id id = pll->info->id;\n\n\t \n\tintel_de_rmw(dev_priv, regs[id].ctl, LCPLL_PLL_ENABLE, 0);\n\tintel_de_posting_read(dev_priv, regs[id].ctl);\n}\n\nstatic void skl_ddi_dpll0_disable(struct drm_i915_private *dev_priv,\n\t\t\t\t  struct intel_shared_dpll *pll)\n{\n}\n\nstatic bool skl_ddi_pll_get_hw_state(struct drm_i915_private *dev_priv,\n\t\t\t\t     struct intel_shared_dpll *pll,\n\t\t\t\t     struct intel_dpll_hw_state *hw_state)\n{\n\tu32 val;\n\tconst struct skl_dpll_regs *regs = skl_dpll_regs;\n\tconst enum intel_dpll_id id = pll->info->id;\n\tintel_wakeref_t wakeref;\n\tbool ret;\n\n\twakeref = intel_display_power_get_if_enabled(dev_priv,\n\t\t\t\t\t\t     POWER_DOMAIN_DISPLAY_CORE);\n\tif (!wakeref)\n\t\treturn false;\n\n\tret = false;\n\n\tval = intel_de_read(dev_priv, regs[id].ctl);\n\tif (!(val & LCPLL_PLL_ENABLE))\n\t\tgoto out;\n\n\tval = intel_de_read(dev_priv, DPLL_CTRL1);\n\thw_state->ctrl1 = (val >> (id * 6)) & 0x3f;\n\n\t \n\tif (val & DPLL_CTRL1_HDMI_MODE(id)) {\n\t\thw_state->cfgcr1 = intel_de_read(dev_priv, regs[id].cfgcr1);\n\t\thw_state->cfgcr2 = intel_de_read(dev_priv, regs[id].cfgcr2);\n\t}\n\tret = true;\n\nout:\n\tintel_display_power_put(dev_priv, POWER_DOMAIN_DISPLAY_CORE, wakeref);\n\n\treturn ret;\n}\n\nstatic bool skl_ddi_dpll0_get_hw_state(struct drm_i915_private *dev_priv,\n\t\t\t\t       struct intel_shared_dpll *pll,\n\t\t\t\t       struct intel_dpll_hw_state *hw_state)\n{\n\tconst struct skl_dpll_regs *regs = skl_dpll_regs;\n\tconst enum intel_dpll_id id = pll->info->id;\n\tintel_wakeref_t wakeref;\n\tu32 val;\n\tbool ret;\n\n\twakeref = intel_display_power_get_if_enabled(dev_priv,\n\t\t\t\t\t\t     POWER_DOMAIN_DISPLAY_CORE);\n\tif (!wakeref)\n\t\treturn false;\n\n\tret = false;\n\n\t \n\tval = intel_de_read(dev_priv, regs[id].ctl);\n\tif (drm_WARN_ON(&dev_priv->drm, !(val & LCPLL_PLL_ENABLE)))\n\t\tgoto out;\n\n\tval = intel_de_read(dev_priv, DPLL_CTRL1);\n\thw_state->ctrl1 = (val >> (id * 6)) & 0x3f;\n\n\tret = true;\n\nout:\n\tintel_display_power_put(dev_priv, POWER_DOMAIN_DISPLAY_CORE, wakeref);\n\n\treturn ret;\n}\n\nstruct skl_wrpll_context {\n\tu64 min_deviation;\t\t \n\tu64 central_freq;\t\t \n\tu64 dco_freq;\t\t\t \n\tunsigned int p;\t\t\t \n};\n\n \n#define SKL_DCO_MAX_PDEVIATION\t100\n#define SKL_DCO_MAX_NDEVIATION\t600\n\nstatic void skl_wrpll_try_divider(struct skl_wrpll_context *ctx,\n\t\t\t\t  u64 central_freq,\n\t\t\t\t  u64 dco_freq,\n\t\t\t\t  unsigned int divider)\n{\n\tu64 deviation;\n\n\tdeviation = div64_u64(10000 * abs_diff(dco_freq, central_freq),\n\t\t\t      central_freq);\n\n\t \n\tif (dco_freq >= central_freq) {\n\t\tif (deviation < SKL_DCO_MAX_PDEVIATION &&\n\t\t    deviation < ctx->min_deviation) {\n\t\t\tctx->min_deviation = deviation;\n\t\t\tctx->central_freq = central_freq;\n\t\t\tctx->dco_freq = dco_freq;\n\t\t\tctx->p = divider;\n\t\t}\n\t \n\t} else if (deviation < SKL_DCO_MAX_NDEVIATION &&\n\t\t   deviation < ctx->min_deviation) {\n\t\tctx->min_deviation = deviation;\n\t\tctx->central_freq = central_freq;\n\t\tctx->dco_freq = dco_freq;\n\t\tctx->p = divider;\n\t}\n}\n\nstatic void skl_wrpll_get_multipliers(unsigned int p,\n\t\t\t\t      unsigned int *p0  ,\n\t\t\t\t      unsigned int *p1  ,\n\t\t\t\t      unsigned int *p2  )\n{\n\t \n\tif (p % 2 == 0) {\n\t\tunsigned int half = p / 2;\n\n\t\tif (half == 1 || half == 2 || half == 3 || half == 5) {\n\t\t\t*p0 = 2;\n\t\t\t*p1 = 1;\n\t\t\t*p2 = half;\n\t\t} else if (half % 2 == 0) {\n\t\t\t*p0 = 2;\n\t\t\t*p1 = half / 2;\n\t\t\t*p2 = 2;\n\t\t} else if (half % 3 == 0) {\n\t\t\t*p0 = 3;\n\t\t\t*p1 = half / 3;\n\t\t\t*p2 = 2;\n\t\t} else if (half % 7 == 0) {\n\t\t\t*p0 = 7;\n\t\t\t*p1 = half / 7;\n\t\t\t*p2 = 2;\n\t\t}\n\t} else if (p == 3 || p == 9) {   \n\t\t*p0 = 3;\n\t\t*p1 = 1;\n\t\t*p2 = p / 3;\n\t} else if (p == 5 || p == 7) {\n\t\t*p0 = p;\n\t\t*p1 = 1;\n\t\t*p2 = 1;\n\t} else if (p == 15) {\n\t\t*p0 = 3;\n\t\t*p1 = 1;\n\t\t*p2 = 5;\n\t} else if (p == 21) {\n\t\t*p0 = 7;\n\t\t*p1 = 1;\n\t\t*p2 = 3;\n\t} else if (p == 35) {\n\t\t*p0 = 7;\n\t\t*p1 = 1;\n\t\t*p2 = 5;\n\t}\n}\n\nstruct skl_wrpll_params {\n\tu32 dco_fraction;\n\tu32 dco_integer;\n\tu32 qdiv_ratio;\n\tu32 qdiv_mode;\n\tu32 kdiv;\n\tu32 pdiv;\n\tu32 central_freq;\n};\n\nstatic void skl_wrpll_params_populate(struct skl_wrpll_params *params,\n\t\t\t\t      u64 afe_clock,\n\t\t\t\t      int ref_clock,\n\t\t\t\t      u64 central_freq,\n\t\t\t\t      u32 p0, u32 p1, u32 p2)\n{\n\tu64 dco_freq;\n\n\tswitch (central_freq) {\n\tcase 9600000000ULL:\n\t\tparams->central_freq = 0;\n\t\tbreak;\n\tcase 9000000000ULL:\n\t\tparams->central_freq = 1;\n\t\tbreak;\n\tcase 8400000000ULL:\n\t\tparams->central_freq = 3;\n\t}\n\n\tswitch (p0) {\n\tcase 1:\n\t\tparams->pdiv = 0;\n\t\tbreak;\n\tcase 2:\n\t\tparams->pdiv = 1;\n\t\tbreak;\n\tcase 3:\n\t\tparams->pdiv = 2;\n\t\tbreak;\n\tcase 7:\n\t\tparams->pdiv = 4;\n\t\tbreak;\n\tdefault:\n\t\tWARN(1, \"Incorrect PDiv\\n\");\n\t}\n\n\tswitch (p2) {\n\tcase 5:\n\t\tparams->kdiv = 0;\n\t\tbreak;\n\tcase 2:\n\t\tparams->kdiv = 1;\n\t\tbreak;\n\tcase 3:\n\t\tparams->kdiv = 2;\n\t\tbreak;\n\tcase 1:\n\t\tparams->kdiv = 3;\n\t\tbreak;\n\tdefault:\n\t\tWARN(1, \"Incorrect KDiv\\n\");\n\t}\n\n\tparams->qdiv_ratio = p1;\n\tparams->qdiv_mode = (params->qdiv_ratio == 1) ? 0 : 1;\n\n\tdco_freq = p0 * p1 * p2 * afe_clock;\n\n\t \n\tparams->dco_integer = div_u64(dco_freq, ref_clock * KHz(1));\n\tparams->dco_fraction =\n\t\tdiv_u64((div_u64(dco_freq, ref_clock / KHz(1)) -\n\t\t\t params->dco_integer * MHz(1)) * 0x8000, MHz(1));\n}\n\nstatic int\nskl_ddi_calculate_wrpll(int clock  ,\n\t\t\tint ref_clock,\n\t\t\tstruct skl_wrpll_params *wrpll_params)\n{\n\tstatic const u64 dco_central_freq[3] = { 8400000000ULL,\n\t\t\t\t\t\t 9000000000ULL,\n\t\t\t\t\t\t 9600000000ULL };\n\tstatic const u8 even_dividers[] = {  4,  6,  8, 10, 12, 14, 16, 18, 20,\n\t\t\t\t\t    24, 28, 30, 32, 36, 40, 42, 44,\n\t\t\t\t\t    48, 52, 54, 56, 60, 64, 66, 68,\n\t\t\t\t\t    70, 72, 76, 78, 80, 84, 88, 90,\n\t\t\t\t\t    92, 96, 98 };\n\tstatic const u8 odd_dividers[] = { 3, 5, 7, 9, 15, 21, 35 };\n\tstatic const struct {\n\t\tconst u8 *list;\n\t\tint n_dividers;\n\t} dividers[] = {\n\t\t{ even_dividers, ARRAY_SIZE(even_dividers) },\n\t\t{ odd_dividers, ARRAY_SIZE(odd_dividers) },\n\t};\n\tstruct skl_wrpll_context ctx = {\n\t\t.min_deviation = U64_MAX,\n\t};\n\tunsigned int dco, d, i;\n\tunsigned int p0, p1, p2;\n\tu64 afe_clock = clock * 5;  \n\n\tfor (d = 0; d < ARRAY_SIZE(dividers); d++) {\n\t\tfor (dco = 0; dco < ARRAY_SIZE(dco_central_freq); dco++) {\n\t\t\tfor (i = 0; i < dividers[d].n_dividers; i++) {\n\t\t\t\tunsigned int p = dividers[d].list[i];\n\t\t\t\tu64 dco_freq = p * afe_clock;\n\n\t\t\t\tskl_wrpll_try_divider(&ctx,\n\t\t\t\t\t\t      dco_central_freq[dco],\n\t\t\t\t\t\t      dco_freq,\n\t\t\t\t\t\t      p);\n\t\t\t\t \n\t\t\t\tif (ctx.min_deviation == 0)\n\t\t\t\t\tgoto skip_remaining_dividers;\n\t\t\t}\n\t\t}\n\nskip_remaining_dividers:\n\t\t \n\t\tif (d == 0 && ctx.p)\n\t\t\tbreak;\n\t}\n\n\tif (!ctx.p)\n\t\treturn -EINVAL;\n\n\t \n\tp0 = p1 = p2 = 0;\n\tskl_wrpll_get_multipliers(ctx.p, &p0, &p1, &p2);\n\tskl_wrpll_params_populate(wrpll_params, afe_clock, ref_clock,\n\t\t\t\t  ctx.central_freq, p0, p1, p2);\n\n\treturn 0;\n}\n\nstatic int skl_ddi_wrpll_get_freq(struct drm_i915_private *i915,\n\t\t\t\t  const struct intel_shared_dpll *pll,\n\t\t\t\t  const struct intel_dpll_hw_state *pll_state)\n{\n\tint ref_clock = i915->display.dpll.ref_clks.nssc;\n\tu32 p0, p1, p2, dco_freq;\n\n\tp0 = pll_state->cfgcr2 & DPLL_CFGCR2_PDIV_MASK;\n\tp2 = pll_state->cfgcr2 & DPLL_CFGCR2_KDIV_MASK;\n\n\tif (pll_state->cfgcr2 &  DPLL_CFGCR2_QDIV_MODE(1))\n\t\tp1 = (pll_state->cfgcr2 & DPLL_CFGCR2_QDIV_RATIO_MASK) >> 8;\n\telse\n\t\tp1 = 1;\n\n\n\tswitch (p0) {\n\tcase DPLL_CFGCR2_PDIV_1:\n\t\tp0 = 1;\n\t\tbreak;\n\tcase DPLL_CFGCR2_PDIV_2:\n\t\tp0 = 2;\n\t\tbreak;\n\tcase DPLL_CFGCR2_PDIV_3:\n\t\tp0 = 3;\n\t\tbreak;\n\tcase DPLL_CFGCR2_PDIV_7_INVALID:\n\t\t \n\t\tdrm_dbg_kms(&i915->drm, \"Invalid WRPLL PDIV divider value, fixing it.\\n\");\n\t\tfallthrough;\n\tcase DPLL_CFGCR2_PDIV_7:\n\t\tp0 = 7;\n\t\tbreak;\n\tdefault:\n\t\tMISSING_CASE(p0);\n\t\treturn 0;\n\t}\n\n\tswitch (p2) {\n\tcase DPLL_CFGCR2_KDIV_5:\n\t\tp2 = 5;\n\t\tbreak;\n\tcase DPLL_CFGCR2_KDIV_2:\n\t\tp2 = 2;\n\t\tbreak;\n\tcase DPLL_CFGCR2_KDIV_3:\n\t\tp2 = 3;\n\t\tbreak;\n\tcase DPLL_CFGCR2_KDIV_1:\n\t\tp2 = 1;\n\t\tbreak;\n\tdefault:\n\t\tMISSING_CASE(p2);\n\t\treturn 0;\n\t}\n\n\tdco_freq = (pll_state->cfgcr1 & DPLL_CFGCR1_DCO_INTEGER_MASK) *\n\t\t   ref_clock;\n\n\tdco_freq += ((pll_state->cfgcr1 & DPLL_CFGCR1_DCO_FRACTION_MASK) >> 9) *\n\t\t    ref_clock / 0x8000;\n\n\tif (drm_WARN_ON(&i915->drm, p0 == 0 || p1 == 0 || p2 == 0))\n\t\treturn 0;\n\n\treturn dco_freq / (p0 * p1 * p2 * 5);\n}\n\nstatic int skl_ddi_hdmi_pll_dividers(struct intel_crtc_state *crtc_state)\n{\n\tstruct drm_i915_private *i915 = to_i915(crtc_state->uapi.crtc->dev);\n\tstruct skl_wrpll_params wrpll_params = {};\n\tu32 ctrl1, cfgcr1, cfgcr2;\n\tint ret;\n\n\t \n\tctrl1 = DPLL_CTRL1_OVERRIDE(0);\n\n\tctrl1 |= DPLL_CTRL1_HDMI_MODE(0);\n\n\tret = skl_ddi_calculate_wrpll(crtc_state->port_clock * 1000,\n\t\t\t\t      i915->display.dpll.ref_clks.nssc, &wrpll_params);\n\tif (ret)\n\t\treturn ret;\n\n\tcfgcr1 = DPLL_CFGCR1_FREQ_ENABLE |\n\t\tDPLL_CFGCR1_DCO_FRACTION(wrpll_params.dco_fraction) |\n\t\twrpll_params.dco_integer;\n\n\tcfgcr2 = DPLL_CFGCR2_QDIV_RATIO(wrpll_params.qdiv_ratio) |\n\t\tDPLL_CFGCR2_QDIV_MODE(wrpll_params.qdiv_mode) |\n\t\tDPLL_CFGCR2_KDIV(wrpll_params.kdiv) |\n\t\tDPLL_CFGCR2_PDIV(wrpll_params.pdiv) |\n\t\twrpll_params.central_freq;\n\n\tcrtc_state->dpll_hw_state.ctrl1 = ctrl1;\n\tcrtc_state->dpll_hw_state.cfgcr1 = cfgcr1;\n\tcrtc_state->dpll_hw_state.cfgcr2 = cfgcr2;\n\n\tcrtc_state->port_clock = skl_ddi_wrpll_get_freq(i915, NULL,\n\t\t\t\t\t\t\t&crtc_state->dpll_hw_state);\n\n\treturn 0;\n}\n\nstatic int\nskl_ddi_dp_set_dpll_hw_state(struct intel_crtc_state *crtc_state)\n{\n\tu32 ctrl1;\n\n\t \n\tctrl1 = DPLL_CTRL1_OVERRIDE(0);\n\tswitch (crtc_state->port_clock / 2) {\n\tcase 81000:\n\t\tctrl1 |= DPLL_CTRL1_LINK_RATE(DPLL_CTRL1_LINK_RATE_810, 0);\n\t\tbreak;\n\tcase 135000:\n\t\tctrl1 |= DPLL_CTRL1_LINK_RATE(DPLL_CTRL1_LINK_RATE_1350, 0);\n\t\tbreak;\n\tcase 270000:\n\t\tctrl1 |= DPLL_CTRL1_LINK_RATE(DPLL_CTRL1_LINK_RATE_2700, 0);\n\t\tbreak;\n\t\t \n\tcase 162000:\n\t\tctrl1 |= DPLL_CTRL1_LINK_RATE(DPLL_CTRL1_LINK_RATE_1620, 0);\n\t\tbreak;\n\tcase 108000:\n\t\tctrl1 |= DPLL_CTRL1_LINK_RATE(DPLL_CTRL1_LINK_RATE_1080, 0);\n\t\tbreak;\n\tcase 216000:\n\t\tctrl1 |= DPLL_CTRL1_LINK_RATE(DPLL_CTRL1_LINK_RATE_2160, 0);\n\t\tbreak;\n\t}\n\n\tcrtc_state->dpll_hw_state.ctrl1 = ctrl1;\n\n\treturn 0;\n}\n\nstatic int skl_ddi_lcpll_get_freq(struct drm_i915_private *i915,\n\t\t\t\t  const struct intel_shared_dpll *pll,\n\t\t\t\t  const struct intel_dpll_hw_state *pll_state)\n{\n\tint link_clock = 0;\n\n\tswitch ((pll_state->ctrl1 & DPLL_CTRL1_LINK_RATE_MASK(0)) >>\n\t\tDPLL_CTRL1_LINK_RATE_SHIFT(0)) {\n\tcase DPLL_CTRL1_LINK_RATE_810:\n\t\tlink_clock = 81000;\n\t\tbreak;\n\tcase DPLL_CTRL1_LINK_RATE_1080:\n\t\tlink_clock = 108000;\n\t\tbreak;\n\tcase DPLL_CTRL1_LINK_RATE_1350:\n\t\tlink_clock = 135000;\n\t\tbreak;\n\tcase DPLL_CTRL1_LINK_RATE_1620:\n\t\tlink_clock = 162000;\n\t\tbreak;\n\tcase DPLL_CTRL1_LINK_RATE_2160:\n\t\tlink_clock = 216000;\n\t\tbreak;\n\tcase DPLL_CTRL1_LINK_RATE_2700:\n\t\tlink_clock = 270000;\n\t\tbreak;\n\tdefault:\n\t\tdrm_WARN(&i915->drm, 1, \"Unsupported link rate\\n\");\n\t\tbreak;\n\t}\n\n\treturn link_clock * 2;\n}\n\nstatic int skl_compute_dpll(struct intel_atomic_state *state,\n\t\t\t    struct intel_crtc *crtc,\n\t\t\t    struct intel_encoder *encoder)\n{\n\tstruct intel_crtc_state *crtc_state =\n\t\tintel_atomic_get_new_crtc_state(state, crtc);\n\n\tif (intel_crtc_has_type(crtc_state, INTEL_OUTPUT_HDMI))\n\t\treturn skl_ddi_hdmi_pll_dividers(crtc_state);\n\telse if (intel_crtc_has_dp_encoder(crtc_state))\n\t\treturn skl_ddi_dp_set_dpll_hw_state(crtc_state);\n\telse\n\t\treturn -EINVAL;\n}\n\nstatic int skl_get_dpll(struct intel_atomic_state *state,\n\t\t\tstruct intel_crtc *crtc,\n\t\t\tstruct intel_encoder *encoder)\n{\n\tstruct intel_crtc_state *crtc_state =\n\t\tintel_atomic_get_new_crtc_state(state, crtc);\n\tstruct intel_shared_dpll *pll;\n\n\tif (intel_crtc_has_type(crtc_state, INTEL_OUTPUT_EDP))\n\t\tpll = intel_find_shared_dpll(state, crtc,\n\t\t\t\t\t     &crtc_state->dpll_hw_state,\n\t\t\t\t\t     BIT(DPLL_ID_SKL_DPLL0));\n\telse\n\t\tpll = intel_find_shared_dpll(state, crtc,\n\t\t\t\t\t     &crtc_state->dpll_hw_state,\n\t\t\t\t\t     BIT(DPLL_ID_SKL_DPLL3) |\n\t\t\t\t\t     BIT(DPLL_ID_SKL_DPLL2) |\n\t\t\t\t\t     BIT(DPLL_ID_SKL_DPLL1));\n\tif (!pll)\n\t\treturn -EINVAL;\n\n\tintel_reference_shared_dpll(state, crtc,\n\t\t\t\t    pll, &crtc_state->dpll_hw_state);\n\n\tcrtc_state->shared_dpll = pll;\n\n\treturn 0;\n}\n\nstatic int skl_ddi_pll_get_freq(struct drm_i915_private *i915,\n\t\t\t\tconst struct intel_shared_dpll *pll,\n\t\t\t\tconst struct intel_dpll_hw_state *pll_state)\n{\n\t \n\tif (pll_state->ctrl1 & DPLL_CTRL1_HDMI_MODE(0))\n\t\treturn skl_ddi_wrpll_get_freq(i915, pll, pll_state);\n\telse\n\t\treturn skl_ddi_lcpll_get_freq(i915, pll, pll_state);\n}\n\nstatic void skl_update_dpll_ref_clks(struct drm_i915_private *i915)\n{\n\t \n\ti915->display.dpll.ref_clks.nssc = i915->display.cdclk.hw.ref;\n}\n\nstatic void skl_dump_hw_state(struct drm_i915_private *dev_priv,\n\t\t\t      const struct intel_dpll_hw_state *hw_state)\n{\n\tdrm_dbg_kms(&dev_priv->drm, \"dpll_hw_state: \"\n\t\t      \"ctrl1: 0x%x, cfgcr1: 0x%x, cfgcr2: 0x%x\\n\",\n\t\t      hw_state->ctrl1,\n\t\t      hw_state->cfgcr1,\n\t\t      hw_state->cfgcr2);\n}\n\nstatic const struct intel_shared_dpll_funcs skl_ddi_pll_funcs = {\n\t.enable = skl_ddi_pll_enable,\n\t.disable = skl_ddi_pll_disable,\n\t.get_hw_state = skl_ddi_pll_get_hw_state,\n\t.get_freq = skl_ddi_pll_get_freq,\n};\n\nstatic const struct intel_shared_dpll_funcs skl_ddi_dpll0_funcs = {\n\t.enable = skl_ddi_dpll0_enable,\n\t.disable = skl_ddi_dpll0_disable,\n\t.get_hw_state = skl_ddi_dpll0_get_hw_state,\n\t.get_freq = skl_ddi_pll_get_freq,\n};\n\nstatic const struct dpll_info skl_plls[] = {\n\t{ \"DPLL 0\", &skl_ddi_dpll0_funcs, DPLL_ID_SKL_DPLL0, INTEL_DPLL_ALWAYS_ON },\n\t{ \"DPLL 1\", &skl_ddi_pll_funcs,   DPLL_ID_SKL_DPLL1, 0 },\n\t{ \"DPLL 2\", &skl_ddi_pll_funcs,   DPLL_ID_SKL_DPLL2, 0 },\n\t{ \"DPLL 3\", &skl_ddi_pll_funcs,   DPLL_ID_SKL_DPLL3, 0 },\n\t{ },\n};\n\nstatic const struct intel_dpll_mgr skl_pll_mgr = {\n\t.dpll_info = skl_plls,\n\t.compute_dplls = skl_compute_dpll,\n\t.get_dplls = skl_get_dpll,\n\t.put_dplls = intel_put_dpll,\n\t.update_ref_clks = skl_update_dpll_ref_clks,\n\t.dump_hw_state = skl_dump_hw_state,\n};\n\nstatic void bxt_ddi_pll_enable(struct drm_i915_private *dev_priv,\n\t\t\t\tstruct intel_shared_dpll *pll)\n{\n\tu32 temp;\n\tenum port port = (enum port)pll->info->id;  \n\tenum dpio_phy phy;\n\tenum dpio_channel ch;\n\n\tbxt_port_to_phy_channel(dev_priv, port, &phy, &ch);\n\n\t \n\tintel_de_rmw(dev_priv, BXT_PORT_PLL_ENABLE(port), 0, PORT_PLL_REF_SEL);\n\n\tif (IS_GEMINILAKE(dev_priv)) {\n\t\tintel_de_rmw(dev_priv, BXT_PORT_PLL_ENABLE(port),\n\t\t\t     0, PORT_PLL_POWER_ENABLE);\n\n\t\tif (wait_for_us((intel_de_read(dev_priv, BXT_PORT_PLL_ENABLE(port)) &\n\t\t\t\t PORT_PLL_POWER_STATE), 200))\n\t\t\tdrm_err(&dev_priv->drm,\n\t\t\t\t\"Power state not set for PLL:%d\\n\", port);\n\t}\n\n\t \n\tintel_de_rmw(dev_priv, BXT_PORT_PLL_EBB_4(phy, ch),\n\t\t     PORT_PLL_10BIT_CLK_ENABLE, 0);\n\n\t \n\tintel_de_rmw(dev_priv, BXT_PORT_PLL_EBB_0(phy, ch),\n\t\t     PORT_PLL_P1_MASK | PORT_PLL_P2_MASK, pll->state.hw_state.ebb0);\n\n\t \n\tintel_de_rmw(dev_priv, BXT_PORT_PLL(phy, ch, 0),\n\t\t     PORT_PLL_M2_INT_MASK, pll->state.hw_state.pll0);\n\n\t \n\tintel_de_rmw(dev_priv, BXT_PORT_PLL(phy, ch, 1),\n\t\t     PORT_PLL_N_MASK, pll->state.hw_state.pll1);\n\n\t \n\tintel_de_rmw(dev_priv, BXT_PORT_PLL(phy, ch, 2),\n\t\t     PORT_PLL_M2_FRAC_MASK, pll->state.hw_state.pll2);\n\n\t \n\tintel_de_rmw(dev_priv, BXT_PORT_PLL(phy, ch, 3),\n\t\t     PORT_PLL_M2_FRAC_ENABLE, pll->state.hw_state.pll3);\n\n\t \n\ttemp = intel_de_read(dev_priv, BXT_PORT_PLL(phy, ch, 6));\n\ttemp &= ~PORT_PLL_PROP_COEFF_MASK;\n\ttemp &= ~PORT_PLL_INT_COEFF_MASK;\n\ttemp &= ~PORT_PLL_GAIN_CTL_MASK;\n\ttemp |= pll->state.hw_state.pll6;\n\tintel_de_write(dev_priv, BXT_PORT_PLL(phy, ch, 6), temp);\n\n\t \n\tintel_de_rmw(dev_priv, BXT_PORT_PLL(phy, ch, 8),\n\t\t     PORT_PLL_TARGET_CNT_MASK, pll->state.hw_state.pll8);\n\n\tintel_de_rmw(dev_priv, BXT_PORT_PLL(phy, ch, 9),\n\t\t     PORT_PLL_LOCK_THRESHOLD_MASK, pll->state.hw_state.pll9);\n\n\ttemp = intel_de_read(dev_priv, BXT_PORT_PLL(phy, ch, 10));\n\ttemp &= ~PORT_PLL_DCO_AMP_OVR_EN_H;\n\ttemp &= ~PORT_PLL_DCO_AMP_MASK;\n\ttemp |= pll->state.hw_state.pll10;\n\tintel_de_write(dev_priv, BXT_PORT_PLL(phy, ch, 10), temp);\n\n\t \n\ttemp = intel_de_read(dev_priv, BXT_PORT_PLL_EBB_4(phy, ch));\n\ttemp |= PORT_PLL_RECALIBRATE;\n\tintel_de_write(dev_priv, BXT_PORT_PLL_EBB_4(phy, ch), temp);\n\ttemp &= ~PORT_PLL_10BIT_CLK_ENABLE;\n\ttemp |= pll->state.hw_state.ebb4;\n\tintel_de_write(dev_priv, BXT_PORT_PLL_EBB_4(phy, ch), temp);\n\n\t \n\tintel_de_rmw(dev_priv, BXT_PORT_PLL_ENABLE(port), 0, PORT_PLL_ENABLE);\n\tintel_de_posting_read(dev_priv, BXT_PORT_PLL_ENABLE(port));\n\n\tif (wait_for_us((intel_de_read(dev_priv, BXT_PORT_PLL_ENABLE(port)) & PORT_PLL_LOCK),\n\t\t\t200))\n\t\tdrm_err(&dev_priv->drm, \"PLL %d not locked\\n\", port);\n\n\tif (IS_GEMINILAKE(dev_priv)) {\n\t\ttemp = intel_de_read(dev_priv, BXT_PORT_TX_DW5_LN0(phy, ch));\n\t\ttemp |= DCC_DELAY_RANGE_2;\n\t\tintel_de_write(dev_priv, BXT_PORT_TX_DW5_GRP(phy, ch), temp);\n\t}\n\n\t \n\ttemp = intel_de_read(dev_priv, BXT_PORT_PCS_DW12_LN01(phy, ch));\n\ttemp &= ~LANE_STAGGER_MASK;\n\ttemp &= ~LANESTAGGER_STRAP_OVRD;\n\ttemp |= pll->state.hw_state.pcsdw12;\n\tintel_de_write(dev_priv, BXT_PORT_PCS_DW12_GRP(phy, ch), temp);\n}\n\nstatic void bxt_ddi_pll_disable(struct drm_i915_private *dev_priv,\n\t\t\t\t\tstruct intel_shared_dpll *pll)\n{\n\tenum port port = (enum port)pll->info->id;  \n\n\tintel_de_rmw(dev_priv, BXT_PORT_PLL_ENABLE(port), PORT_PLL_ENABLE, 0);\n\tintel_de_posting_read(dev_priv, BXT_PORT_PLL_ENABLE(port));\n\n\tif (IS_GEMINILAKE(dev_priv)) {\n\t\tintel_de_rmw(dev_priv, BXT_PORT_PLL_ENABLE(port),\n\t\t\t     PORT_PLL_POWER_ENABLE, 0);\n\n\t\tif (wait_for_us(!(intel_de_read(dev_priv, BXT_PORT_PLL_ENABLE(port)) &\n\t\t\t\t  PORT_PLL_POWER_STATE), 200))\n\t\t\tdrm_err(&dev_priv->drm,\n\t\t\t\t\"Power state not reset for PLL:%d\\n\", port);\n\t}\n}\n\nstatic bool bxt_ddi_pll_get_hw_state(struct drm_i915_private *dev_priv,\n\t\t\t\t\tstruct intel_shared_dpll *pll,\n\t\t\t\t\tstruct intel_dpll_hw_state *hw_state)\n{\n\tenum port port = (enum port)pll->info->id;  \n\tintel_wakeref_t wakeref;\n\tenum dpio_phy phy;\n\tenum dpio_channel ch;\n\tu32 val;\n\tbool ret;\n\n\tbxt_port_to_phy_channel(dev_priv, port, &phy, &ch);\n\n\twakeref = intel_display_power_get_if_enabled(dev_priv,\n\t\t\t\t\t\t     POWER_DOMAIN_DISPLAY_CORE);\n\tif (!wakeref)\n\t\treturn false;\n\n\tret = false;\n\n\tval = intel_de_read(dev_priv, BXT_PORT_PLL_ENABLE(port));\n\tif (!(val & PORT_PLL_ENABLE))\n\t\tgoto out;\n\n\thw_state->ebb0 = intel_de_read(dev_priv, BXT_PORT_PLL_EBB_0(phy, ch));\n\thw_state->ebb0 &= PORT_PLL_P1_MASK | PORT_PLL_P2_MASK;\n\n\thw_state->ebb4 = intel_de_read(dev_priv, BXT_PORT_PLL_EBB_4(phy, ch));\n\thw_state->ebb4 &= PORT_PLL_10BIT_CLK_ENABLE;\n\n\thw_state->pll0 = intel_de_read(dev_priv, BXT_PORT_PLL(phy, ch, 0));\n\thw_state->pll0 &= PORT_PLL_M2_INT_MASK;\n\n\thw_state->pll1 = intel_de_read(dev_priv, BXT_PORT_PLL(phy, ch, 1));\n\thw_state->pll1 &= PORT_PLL_N_MASK;\n\n\thw_state->pll2 = intel_de_read(dev_priv, BXT_PORT_PLL(phy, ch, 2));\n\thw_state->pll2 &= PORT_PLL_M2_FRAC_MASK;\n\n\thw_state->pll3 = intel_de_read(dev_priv, BXT_PORT_PLL(phy, ch, 3));\n\thw_state->pll3 &= PORT_PLL_M2_FRAC_ENABLE;\n\n\thw_state->pll6 = intel_de_read(dev_priv, BXT_PORT_PLL(phy, ch, 6));\n\thw_state->pll6 &= PORT_PLL_PROP_COEFF_MASK |\n\t\t\t  PORT_PLL_INT_COEFF_MASK |\n\t\t\t  PORT_PLL_GAIN_CTL_MASK;\n\n\thw_state->pll8 = intel_de_read(dev_priv, BXT_PORT_PLL(phy, ch, 8));\n\thw_state->pll8 &= PORT_PLL_TARGET_CNT_MASK;\n\n\thw_state->pll9 = intel_de_read(dev_priv, BXT_PORT_PLL(phy, ch, 9));\n\thw_state->pll9 &= PORT_PLL_LOCK_THRESHOLD_MASK;\n\n\thw_state->pll10 = intel_de_read(dev_priv, BXT_PORT_PLL(phy, ch, 10));\n\thw_state->pll10 &= PORT_PLL_DCO_AMP_OVR_EN_H |\n\t\t\t   PORT_PLL_DCO_AMP_MASK;\n\n\t \n\thw_state->pcsdw12 = intel_de_read(dev_priv,\n\t\t\t\t\t  BXT_PORT_PCS_DW12_LN01(phy, ch));\n\tif (intel_de_read(dev_priv, BXT_PORT_PCS_DW12_LN23(phy, ch)) != hw_state->pcsdw12)\n\t\tdrm_dbg(&dev_priv->drm,\n\t\t\t\"lane stagger config different for lane 01 (%08x) and 23 (%08x)\\n\",\n\t\t\thw_state->pcsdw12,\n\t\t\tintel_de_read(dev_priv,\n\t\t\t\t      BXT_PORT_PCS_DW12_LN23(phy, ch)));\n\thw_state->pcsdw12 &= LANE_STAGGER_MASK | LANESTAGGER_STRAP_OVRD;\n\n\tret = true;\n\nout:\n\tintel_display_power_put(dev_priv, POWER_DOMAIN_DISPLAY_CORE, wakeref);\n\n\treturn ret;\n}\n\n \nstatic const struct dpll bxt_dp_clk_val[] = {\n\t \n\t{ .dot = 162000, .p1 = 4, .p2 = 2, .n = 1, .m1 = 2, .m2 = 0x819999a   },\n\t{ .dot = 270000, .p1 = 4, .p2 = 1, .n = 1, .m1 = 2, .m2 = 0x6c00000   },\n\t{ .dot = 540000, .p1 = 2, .p2 = 1, .n = 1, .m1 = 2, .m2 = 0x6c00000   },\n\t{ .dot = 216000, .p1 = 3, .p2 = 2, .n = 1, .m1 = 2, .m2 = 0x819999a   },\n\t{ .dot = 243000, .p1 = 4, .p2 = 1, .n = 1, .m1 = 2, .m2 = 0x6133333   },\n\t{ .dot = 324000, .p1 = 4, .p2 = 1, .n = 1, .m1 = 2, .m2 = 0x819999a   },\n\t{ .dot = 432000, .p1 = 3, .p2 = 1, .n = 1, .m1 = 2, .m2 = 0x819999a   },\n};\n\nstatic int\nbxt_ddi_hdmi_pll_dividers(struct intel_crtc_state *crtc_state,\n\t\t\t  struct dpll *clk_div)\n{\n\tstruct drm_i915_private *i915 = to_i915(crtc_state->uapi.crtc->dev);\n\n\t \n\t \n\tif (!bxt_find_best_dpll(crtc_state, clk_div))\n\t\treturn -EINVAL;\n\n\tdrm_WARN_ON(&i915->drm, clk_div->m1 != 2);\n\n\treturn 0;\n}\n\nstatic void bxt_ddi_dp_pll_dividers(struct intel_crtc_state *crtc_state,\n\t\t\t\t    struct dpll *clk_div)\n{\n\tstruct drm_i915_private *i915 = to_i915(crtc_state->uapi.crtc->dev);\n\tint i;\n\n\t*clk_div = bxt_dp_clk_val[0];\n\tfor (i = 0; i < ARRAY_SIZE(bxt_dp_clk_val); ++i) {\n\t\tif (crtc_state->port_clock == bxt_dp_clk_val[i].dot) {\n\t\t\t*clk_div = bxt_dp_clk_val[i];\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tchv_calc_dpll_params(i915->display.dpll.ref_clks.nssc, clk_div);\n\n\tdrm_WARN_ON(&i915->drm, clk_div->vco == 0 ||\n\t\t    clk_div->dot != crtc_state->port_clock);\n}\n\nstatic int bxt_ddi_set_dpll_hw_state(struct intel_crtc_state *crtc_state,\n\t\t\t\t     const struct dpll *clk_div)\n{\n\tstruct drm_i915_private *i915 = to_i915(crtc_state->uapi.crtc->dev);\n\tstruct intel_dpll_hw_state *dpll_hw_state = &crtc_state->dpll_hw_state;\n\tint clock = crtc_state->port_clock;\n\tint vco = clk_div->vco;\n\tu32 prop_coef, int_coef, gain_ctl, targ_cnt;\n\tu32 lanestagger;\n\n\tif (vco >= 6200000 && vco <= 6700000) {\n\t\tprop_coef = 4;\n\t\tint_coef = 9;\n\t\tgain_ctl = 3;\n\t\ttarg_cnt = 8;\n\t} else if ((vco > 5400000 && vco < 6200000) ||\n\t\t\t(vco >= 4800000 && vco < 5400000)) {\n\t\tprop_coef = 5;\n\t\tint_coef = 11;\n\t\tgain_ctl = 3;\n\t\ttarg_cnt = 9;\n\t} else if (vco == 5400000) {\n\t\tprop_coef = 3;\n\t\tint_coef = 8;\n\t\tgain_ctl = 1;\n\t\ttarg_cnt = 9;\n\t} else {\n\t\tdrm_err(&i915->drm, \"Invalid VCO\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (clock > 270000)\n\t\tlanestagger = 0x18;\n\telse if (clock > 135000)\n\t\tlanestagger = 0x0d;\n\telse if (clock > 67000)\n\t\tlanestagger = 0x07;\n\telse if (clock > 33000)\n\t\tlanestagger = 0x04;\n\telse\n\t\tlanestagger = 0x02;\n\n\tdpll_hw_state->ebb0 = PORT_PLL_P1(clk_div->p1) | PORT_PLL_P2(clk_div->p2);\n\tdpll_hw_state->pll0 = PORT_PLL_M2_INT(clk_div->m2 >> 22);\n\tdpll_hw_state->pll1 = PORT_PLL_N(clk_div->n);\n\tdpll_hw_state->pll2 = PORT_PLL_M2_FRAC(clk_div->m2 & 0x3fffff);\n\n\tif (clk_div->m2 & 0x3fffff)\n\t\tdpll_hw_state->pll3 = PORT_PLL_M2_FRAC_ENABLE;\n\n\tdpll_hw_state->pll6 = PORT_PLL_PROP_COEFF(prop_coef) |\n\t\tPORT_PLL_INT_COEFF(int_coef) |\n\t\tPORT_PLL_GAIN_CTL(gain_ctl);\n\n\tdpll_hw_state->pll8 = PORT_PLL_TARGET_CNT(targ_cnt);\n\n\tdpll_hw_state->pll9 = PORT_PLL_LOCK_THRESHOLD(5);\n\n\tdpll_hw_state->pll10 = PORT_PLL_DCO_AMP(15) |\n\t\tPORT_PLL_DCO_AMP_OVR_EN_H;\n\n\tdpll_hw_state->ebb4 = PORT_PLL_10BIT_CLK_ENABLE;\n\n\tdpll_hw_state->pcsdw12 = LANESTAGGER_STRAP_OVRD | lanestagger;\n\n\treturn 0;\n}\n\nstatic int bxt_ddi_pll_get_freq(struct drm_i915_private *i915,\n\t\t\t\tconst struct intel_shared_dpll *pll,\n\t\t\t\tconst struct intel_dpll_hw_state *pll_state)\n{\n\tstruct dpll clock;\n\n\tclock.m1 = 2;\n\tclock.m2 = REG_FIELD_GET(PORT_PLL_M2_INT_MASK, pll_state->pll0) << 22;\n\tif (pll_state->pll3 & PORT_PLL_M2_FRAC_ENABLE)\n\t\tclock.m2 |= REG_FIELD_GET(PORT_PLL_M2_FRAC_MASK, pll_state->pll2);\n\tclock.n = REG_FIELD_GET(PORT_PLL_N_MASK, pll_state->pll1);\n\tclock.p1 = REG_FIELD_GET(PORT_PLL_P1_MASK, pll_state->ebb0);\n\tclock.p2 = REG_FIELD_GET(PORT_PLL_P2_MASK, pll_state->ebb0);\n\n\treturn chv_calc_dpll_params(i915->display.dpll.ref_clks.nssc, &clock);\n}\n\nstatic int\nbxt_ddi_dp_set_dpll_hw_state(struct intel_crtc_state *crtc_state)\n{\n\tstruct dpll clk_div = {};\n\n\tbxt_ddi_dp_pll_dividers(crtc_state, &clk_div);\n\n\treturn bxt_ddi_set_dpll_hw_state(crtc_state, &clk_div);\n}\n\nstatic int\nbxt_ddi_hdmi_set_dpll_hw_state(struct intel_crtc_state *crtc_state)\n{\n\tstruct drm_i915_private *i915 = to_i915(crtc_state->uapi.crtc->dev);\n\tstruct dpll clk_div = {};\n\tint ret;\n\n\tbxt_ddi_hdmi_pll_dividers(crtc_state, &clk_div);\n\n\tret = bxt_ddi_set_dpll_hw_state(crtc_state, &clk_div);\n\tif (ret)\n\t\treturn ret;\n\n\tcrtc_state->port_clock = bxt_ddi_pll_get_freq(i915, NULL,\n\t\t\t\t\t\t      &crtc_state->dpll_hw_state);\n\n\treturn 0;\n}\n\nstatic int bxt_compute_dpll(struct intel_atomic_state *state,\n\t\t\t    struct intel_crtc *crtc,\n\t\t\t    struct intel_encoder *encoder)\n{\n\tstruct intel_crtc_state *crtc_state =\n\t\tintel_atomic_get_new_crtc_state(state, crtc);\n\n\tif (intel_crtc_has_type(crtc_state, INTEL_OUTPUT_HDMI))\n\t\treturn bxt_ddi_hdmi_set_dpll_hw_state(crtc_state);\n\telse if (intel_crtc_has_dp_encoder(crtc_state))\n\t\treturn bxt_ddi_dp_set_dpll_hw_state(crtc_state);\n\telse\n\t\treturn -EINVAL;\n}\n\nstatic int bxt_get_dpll(struct intel_atomic_state *state,\n\t\t\tstruct intel_crtc *crtc,\n\t\t\tstruct intel_encoder *encoder)\n{\n\tstruct intel_crtc_state *crtc_state =\n\t\tintel_atomic_get_new_crtc_state(state, crtc);\n\tstruct drm_i915_private *dev_priv = to_i915(crtc->base.dev);\n\tstruct intel_shared_dpll *pll;\n\tenum intel_dpll_id id;\n\n\t \n\tid = (enum intel_dpll_id) encoder->port;\n\tpll = intel_get_shared_dpll_by_id(dev_priv, id);\n\n\tdrm_dbg_kms(&dev_priv->drm, \"[CRTC:%d:%s] using pre-allocated %s\\n\",\n\t\t    crtc->base.base.id, crtc->base.name, pll->info->name);\n\n\tintel_reference_shared_dpll(state, crtc,\n\t\t\t\t    pll, &crtc_state->dpll_hw_state);\n\n\tcrtc_state->shared_dpll = pll;\n\n\treturn 0;\n}\n\nstatic void bxt_update_dpll_ref_clks(struct drm_i915_private *i915)\n{\n\ti915->display.dpll.ref_clks.ssc = 100000;\n\ti915->display.dpll.ref_clks.nssc = 100000;\n\t \n}\n\nstatic void bxt_dump_hw_state(struct drm_i915_private *dev_priv,\n\t\t\t      const struct intel_dpll_hw_state *hw_state)\n{\n\tdrm_dbg_kms(&dev_priv->drm, \"dpll_hw_state: ebb0: 0x%x, ebb4: 0x%x,\"\n\t\t    \"pll0: 0x%x, pll1: 0x%x, pll2: 0x%x, pll3: 0x%x, \"\n\t\t    \"pll6: 0x%x, pll8: 0x%x, pll9: 0x%x, pll10: 0x%x, pcsdw12: 0x%x\\n\",\n\t\t    hw_state->ebb0,\n\t\t    hw_state->ebb4,\n\t\t    hw_state->pll0,\n\t\t    hw_state->pll1,\n\t\t    hw_state->pll2,\n\t\t    hw_state->pll3,\n\t\t    hw_state->pll6,\n\t\t    hw_state->pll8,\n\t\t    hw_state->pll9,\n\t\t    hw_state->pll10,\n\t\t    hw_state->pcsdw12);\n}\n\nstatic const struct intel_shared_dpll_funcs bxt_ddi_pll_funcs = {\n\t.enable = bxt_ddi_pll_enable,\n\t.disable = bxt_ddi_pll_disable,\n\t.get_hw_state = bxt_ddi_pll_get_hw_state,\n\t.get_freq = bxt_ddi_pll_get_freq,\n};\n\nstatic const struct dpll_info bxt_plls[] = {\n\t{ \"PORT PLL A\", &bxt_ddi_pll_funcs, DPLL_ID_SKL_DPLL0, 0 },\n\t{ \"PORT PLL B\", &bxt_ddi_pll_funcs, DPLL_ID_SKL_DPLL1, 0 },\n\t{ \"PORT PLL C\", &bxt_ddi_pll_funcs, DPLL_ID_SKL_DPLL2, 0 },\n\t{ },\n};\n\nstatic const struct intel_dpll_mgr bxt_pll_mgr = {\n\t.dpll_info = bxt_plls,\n\t.compute_dplls = bxt_compute_dpll,\n\t.get_dplls = bxt_get_dpll,\n\t.put_dplls = intel_put_dpll,\n\t.update_ref_clks = bxt_update_dpll_ref_clks,\n\t.dump_hw_state = bxt_dump_hw_state,\n};\n\nstatic void icl_wrpll_get_multipliers(int bestdiv, int *pdiv,\n\t\t\t\t      int *qdiv, int *kdiv)\n{\n\t \n\tif (bestdiv % 2 == 0) {\n\t\tif (bestdiv == 2) {\n\t\t\t*pdiv = 2;\n\t\t\t*qdiv = 1;\n\t\t\t*kdiv = 1;\n\t\t} else if (bestdiv % 4 == 0) {\n\t\t\t*pdiv = 2;\n\t\t\t*qdiv = bestdiv / 4;\n\t\t\t*kdiv = 2;\n\t\t} else if (bestdiv % 6 == 0) {\n\t\t\t*pdiv = 3;\n\t\t\t*qdiv = bestdiv / 6;\n\t\t\t*kdiv = 2;\n\t\t} else if (bestdiv % 5 == 0) {\n\t\t\t*pdiv = 5;\n\t\t\t*qdiv = bestdiv / 10;\n\t\t\t*kdiv = 2;\n\t\t} else if (bestdiv % 14 == 0) {\n\t\t\t*pdiv = 7;\n\t\t\t*qdiv = bestdiv / 14;\n\t\t\t*kdiv = 2;\n\t\t}\n\t} else {\n\t\tif (bestdiv == 3 || bestdiv == 5 || bestdiv == 7) {\n\t\t\t*pdiv = bestdiv;\n\t\t\t*qdiv = 1;\n\t\t\t*kdiv = 1;\n\t\t} else {  \n\t\t\t*pdiv = bestdiv / 3;\n\t\t\t*qdiv = 1;\n\t\t\t*kdiv = 3;\n\t\t}\n\t}\n}\n\nstatic void icl_wrpll_params_populate(struct skl_wrpll_params *params,\n\t\t\t\t      u32 dco_freq, u32 ref_freq,\n\t\t\t\t      int pdiv, int qdiv, int kdiv)\n{\n\tu32 dco;\n\n\tswitch (kdiv) {\n\tcase 1:\n\t\tparams->kdiv = 1;\n\t\tbreak;\n\tcase 2:\n\t\tparams->kdiv = 2;\n\t\tbreak;\n\tcase 3:\n\t\tparams->kdiv = 4;\n\t\tbreak;\n\tdefault:\n\t\tWARN(1, \"Incorrect KDiv\\n\");\n\t}\n\n\tswitch (pdiv) {\n\tcase 2:\n\t\tparams->pdiv = 1;\n\t\tbreak;\n\tcase 3:\n\t\tparams->pdiv = 2;\n\t\tbreak;\n\tcase 5:\n\t\tparams->pdiv = 4;\n\t\tbreak;\n\tcase 7:\n\t\tparams->pdiv = 8;\n\t\tbreak;\n\tdefault:\n\t\tWARN(1, \"Incorrect PDiv\\n\");\n\t}\n\n\tWARN_ON(kdiv != 2 && qdiv != 1);\n\n\tparams->qdiv_ratio = qdiv;\n\tparams->qdiv_mode = (qdiv == 1) ? 0 : 1;\n\n\tdco = div_u64((u64)dco_freq << 15, ref_freq);\n\n\tparams->dco_integer = dco >> 15;\n\tparams->dco_fraction = dco & 0x7fff;\n}\n\n \nstatic bool\nehl_combo_pll_div_frac_wa_needed(struct drm_i915_private *i915)\n{\n\treturn (((IS_ELKHARTLAKE(i915) || IS_JASPERLAKE(i915)) &&\n\t\t IS_DISPLAY_STEP(i915, STEP_B0, STEP_FOREVER)) ||\n\t\t IS_TIGERLAKE(i915) || IS_ALDERLAKE_S(i915) || IS_ALDERLAKE_P(i915)) &&\n\t\t i915->display.dpll.ref_clks.nssc == 38400;\n}\n\nstruct icl_combo_pll_params {\n\tint clock;\n\tstruct skl_wrpll_params wrpll;\n};\n\n \nstatic const struct icl_combo_pll_params icl_dp_combo_pll_24MHz_values[] = {\n\t{ 540000,\n\t  { .dco_integer = 0x151, .dco_fraction = 0x4000,\t\t \n\t    .pdiv = 0x2  , .kdiv = 1, .qdiv_mode = 0, .qdiv_ratio = 0, }, },\n\t{ 270000,\n\t  { .dco_integer = 0x151, .dco_fraction = 0x4000,\t\t \n\t    .pdiv = 0x2  , .kdiv = 2, .qdiv_mode = 0, .qdiv_ratio = 0, }, },\n\t{ 162000,\n\t  { .dco_integer = 0x151, .dco_fraction = 0x4000,\t\t \n\t    .pdiv = 0x4  , .kdiv = 2, .qdiv_mode = 0, .qdiv_ratio = 0, }, },\n\t{ 324000,\n\t  { .dco_integer = 0x151, .dco_fraction = 0x4000,\t\t \n\t    .pdiv = 0x4  , .kdiv = 1, .qdiv_mode = 0, .qdiv_ratio = 0, }, },\n\t{ 216000,\n\t  { .dco_integer = 0x168, .dco_fraction = 0x0000,\t\t \n\t    .pdiv = 0x1  , .kdiv = 2, .qdiv_mode = 1, .qdiv_ratio = 2, }, },\n\t{ 432000,\n\t  { .dco_integer = 0x168, .dco_fraction = 0x0000,\t\t \n\t    .pdiv = 0x1  , .kdiv = 2, .qdiv_mode = 0, .qdiv_ratio = 0, }, },\n\t{ 648000,\n\t  { .dco_integer = 0x195, .dco_fraction = 0x0000,\t\t \n\t    .pdiv = 0x2  , .kdiv = 1, .qdiv_mode = 0, .qdiv_ratio = 0, }, },\n\t{ 810000,\n\t  { .dco_integer = 0x151, .dco_fraction = 0x4000,\t\t \n\t    .pdiv = 0x1  , .kdiv = 1, .qdiv_mode = 0, .qdiv_ratio = 0, }, },\n};\n\n\n \nstatic const struct icl_combo_pll_params icl_dp_combo_pll_19_2MHz_values[] = {\n\t{ 540000,\n\t  { .dco_integer = 0x1A5, .dco_fraction = 0x7000,\t\t \n\t    .pdiv = 0x2  , .kdiv = 1, .qdiv_mode = 0, .qdiv_ratio = 0, }, },\n\t{ 270000,\n\t  { .dco_integer = 0x1A5, .dco_fraction = 0x7000,\t\t \n\t    .pdiv = 0x2  , .kdiv = 2, .qdiv_mode = 0, .qdiv_ratio = 0, }, },\n\t{ 162000,\n\t  { .dco_integer = 0x1A5, .dco_fraction = 0x7000,\t\t \n\t    .pdiv = 0x4  , .kdiv = 2, .qdiv_mode = 0, .qdiv_ratio = 0, }, },\n\t{ 324000,\n\t  { .dco_integer = 0x1A5, .dco_fraction = 0x7000,\t\t \n\t    .pdiv = 0x4  , .kdiv = 1, .qdiv_mode = 0, .qdiv_ratio = 0, }, },\n\t{ 216000,\n\t  { .dco_integer = 0x1C2, .dco_fraction = 0x0000,\t\t \n\t    .pdiv = 0x1  , .kdiv = 2, .qdiv_mode = 1, .qdiv_ratio = 2, }, },\n\t{ 432000,\n\t  { .dco_integer = 0x1C2, .dco_fraction = 0x0000,\t\t \n\t    .pdiv = 0x1  , .kdiv = 2, .qdiv_mode = 0, .qdiv_ratio = 0, }, },\n\t{ 648000,\n\t  { .dco_integer = 0x1FA, .dco_fraction = 0x2000,\t\t \n\t    .pdiv = 0x2  , .kdiv = 1, .qdiv_mode = 0, .qdiv_ratio = 0, }, },\n\t{ 810000,\n\t  { .dco_integer = 0x1A5, .dco_fraction = 0x7000,\t\t \n\t    .pdiv = 0x1  , .kdiv = 1, .qdiv_mode = 0, .qdiv_ratio = 0, }, },\n};\n\nstatic const struct skl_wrpll_params icl_tbt_pll_24MHz_values = {\n\t.dco_integer = 0x151, .dco_fraction = 0x4000,\n\t.pdiv = 0x4  , .kdiv = 1, .qdiv_mode = 0, .qdiv_ratio = 0,\n};\n\nstatic const struct skl_wrpll_params icl_tbt_pll_19_2MHz_values = {\n\t.dco_integer = 0x1A5, .dco_fraction = 0x7000,\n\t.pdiv = 0x4  , .kdiv = 1, .qdiv_mode = 0, .qdiv_ratio = 0,\n};\n\nstatic const struct skl_wrpll_params tgl_tbt_pll_19_2MHz_values = {\n\t.dco_integer = 0x54, .dco_fraction = 0x3000,\n\t \n\t.pdiv = 0, .kdiv = 0, .qdiv_mode = 0, .qdiv_ratio = 0,\n};\n\nstatic const struct skl_wrpll_params tgl_tbt_pll_24MHz_values = {\n\t.dco_integer = 0x43, .dco_fraction = 0x4000,\n\t \n};\n\nstatic int icl_calc_dp_combo_pll(struct intel_crtc_state *crtc_state,\n\t\t\t\t struct skl_wrpll_params *pll_params)\n{\n\tstruct drm_i915_private *dev_priv = to_i915(crtc_state->uapi.crtc->dev);\n\tconst struct icl_combo_pll_params *params =\n\t\tdev_priv->display.dpll.ref_clks.nssc == 24000 ?\n\t\ticl_dp_combo_pll_24MHz_values :\n\t\ticl_dp_combo_pll_19_2MHz_values;\n\tint clock = crtc_state->port_clock;\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(icl_dp_combo_pll_24MHz_values); i++) {\n\t\tif (clock == params[i].clock) {\n\t\t\t*pll_params = params[i].wrpll;\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tMISSING_CASE(clock);\n\treturn -EINVAL;\n}\n\nstatic int icl_calc_tbt_pll(struct intel_crtc_state *crtc_state,\n\t\t\t    struct skl_wrpll_params *pll_params)\n{\n\tstruct drm_i915_private *dev_priv = to_i915(crtc_state->uapi.crtc->dev);\n\n\tif (DISPLAY_VER(dev_priv) >= 12) {\n\t\tswitch (dev_priv->display.dpll.ref_clks.nssc) {\n\t\tdefault:\n\t\t\tMISSING_CASE(dev_priv->display.dpll.ref_clks.nssc);\n\t\t\tfallthrough;\n\t\tcase 19200:\n\t\tcase 38400:\n\t\t\t*pll_params = tgl_tbt_pll_19_2MHz_values;\n\t\t\tbreak;\n\t\tcase 24000:\n\t\t\t*pll_params = tgl_tbt_pll_24MHz_values;\n\t\t\tbreak;\n\t\t}\n\t} else {\n\t\tswitch (dev_priv->display.dpll.ref_clks.nssc) {\n\t\tdefault:\n\t\t\tMISSING_CASE(dev_priv->display.dpll.ref_clks.nssc);\n\t\t\tfallthrough;\n\t\tcase 19200:\n\t\tcase 38400:\n\t\t\t*pll_params = icl_tbt_pll_19_2MHz_values;\n\t\t\tbreak;\n\t\tcase 24000:\n\t\t\t*pll_params = icl_tbt_pll_24MHz_values;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int icl_ddi_tbt_pll_get_freq(struct drm_i915_private *i915,\n\t\t\t\t    const struct intel_shared_dpll *pll,\n\t\t\t\t    const struct intel_dpll_hw_state *pll_state)\n{\n\t \n\tdrm_WARN_ON(&i915->drm, 1);\n\n\treturn 0;\n}\n\nstatic int icl_wrpll_ref_clock(struct drm_i915_private *i915)\n{\n\tint ref_clock = i915->display.dpll.ref_clks.nssc;\n\n\t \n\tif (ref_clock == 38400)\n\t\tref_clock = 19200;\n\n\treturn ref_clock;\n}\n\nstatic int\nicl_calc_wrpll(struct intel_crtc_state *crtc_state,\n\t       struct skl_wrpll_params *wrpll_params)\n{\n\tstruct drm_i915_private *i915 = to_i915(crtc_state->uapi.crtc->dev);\n\tint ref_clock = icl_wrpll_ref_clock(i915);\n\tu32 afe_clock = crtc_state->port_clock * 5;\n\tu32 dco_min = 7998000;\n\tu32 dco_max = 10000000;\n\tu32 dco_mid = (dco_min + dco_max) / 2;\n\tstatic const int dividers[] = {  2,  4,  6,  8, 10, 12,  14,  16,\n\t\t\t\t\t 18, 20, 24, 28, 30, 32,  36,  40,\n\t\t\t\t\t 42, 44, 48, 50, 52, 54,  56,  60,\n\t\t\t\t\t 64, 66, 68, 70, 72, 76,  78,  80,\n\t\t\t\t\t 84, 88, 90, 92, 96, 98, 100, 102,\n\t\t\t\t\t  3,  5,  7,  9, 15, 21 };\n\tu32 dco, best_dco = 0, dco_centrality = 0;\n\tu32 best_dco_centrality = U32_MAX;  \n\tint d, best_div = 0, pdiv = 0, qdiv = 0, kdiv = 0;\n\n\tfor (d = 0; d < ARRAY_SIZE(dividers); d++) {\n\t\tdco = afe_clock * dividers[d];\n\n\t\tif (dco <= dco_max && dco >= dco_min) {\n\t\t\tdco_centrality = abs(dco - dco_mid);\n\n\t\t\tif (dco_centrality < best_dco_centrality) {\n\t\t\t\tbest_dco_centrality = dco_centrality;\n\t\t\t\tbest_div = dividers[d];\n\t\t\t\tbest_dco = dco;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (best_div == 0)\n\t\treturn -EINVAL;\n\n\ticl_wrpll_get_multipliers(best_div, &pdiv, &qdiv, &kdiv);\n\ticl_wrpll_params_populate(wrpll_params, best_dco, ref_clock,\n\t\t\t\t  pdiv, qdiv, kdiv);\n\n\treturn 0;\n}\n\nstatic int icl_ddi_combo_pll_get_freq(struct drm_i915_private *i915,\n\t\t\t\t      const struct intel_shared_dpll *pll,\n\t\t\t\t      const struct intel_dpll_hw_state *pll_state)\n{\n\tint ref_clock = icl_wrpll_ref_clock(i915);\n\tu32 dco_fraction;\n\tu32 p0, p1, p2, dco_freq;\n\n\tp0 = pll_state->cfgcr1 & DPLL_CFGCR1_PDIV_MASK;\n\tp2 = pll_state->cfgcr1 & DPLL_CFGCR1_KDIV_MASK;\n\n\tif (pll_state->cfgcr1 & DPLL_CFGCR1_QDIV_MODE(1))\n\t\tp1 = (pll_state->cfgcr1 & DPLL_CFGCR1_QDIV_RATIO_MASK) >>\n\t\t\tDPLL_CFGCR1_QDIV_RATIO_SHIFT;\n\telse\n\t\tp1 = 1;\n\n\tswitch (p0) {\n\tcase DPLL_CFGCR1_PDIV_2:\n\t\tp0 = 2;\n\t\tbreak;\n\tcase DPLL_CFGCR1_PDIV_3:\n\t\tp0 = 3;\n\t\tbreak;\n\tcase DPLL_CFGCR1_PDIV_5:\n\t\tp0 = 5;\n\t\tbreak;\n\tcase DPLL_CFGCR1_PDIV_7:\n\t\tp0 = 7;\n\t\tbreak;\n\t}\n\n\tswitch (p2) {\n\tcase DPLL_CFGCR1_KDIV_1:\n\t\tp2 = 1;\n\t\tbreak;\n\tcase DPLL_CFGCR1_KDIV_2:\n\t\tp2 = 2;\n\t\tbreak;\n\tcase DPLL_CFGCR1_KDIV_3:\n\t\tp2 = 3;\n\t\tbreak;\n\t}\n\n\tdco_freq = (pll_state->cfgcr0 & DPLL_CFGCR0_DCO_INTEGER_MASK) *\n\t\t   ref_clock;\n\n\tdco_fraction = (pll_state->cfgcr0 & DPLL_CFGCR0_DCO_FRACTION_MASK) >>\n\t\t       DPLL_CFGCR0_DCO_FRACTION_SHIFT;\n\n\tif (ehl_combo_pll_div_frac_wa_needed(i915))\n\t\tdco_fraction *= 2;\n\n\tdco_freq += (dco_fraction * ref_clock) / 0x8000;\n\n\tif (drm_WARN_ON(&i915->drm, p0 == 0 || p1 == 0 || p2 == 0))\n\t\treturn 0;\n\n\treturn dco_freq / (p0 * p1 * p2 * 5);\n}\n\nstatic void icl_calc_dpll_state(struct drm_i915_private *i915,\n\t\t\t\tconst struct skl_wrpll_params *pll_params,\n\t\t\t\tstruct intel_dpll_hw_state *pll_state)\n{\n\tu32 dco_fraction = pll_params->dco_fraction;\n\n\tif (ehl_combo_pll_div_frac_wa_needed(i915))\n\t\tdco_fraction = DIV_ROUND_CLOSEST(dco_fraction, 2);\n\n\tpll_state->cfgcr0 = DPLL_CFGCR0_DCO_FRACTION(dco_fraction) |\n\t\t\t    pll_params->dco_integer;\n\n\tpll_state->cfgcr1 = DPLL_CFGCR1_QDIV_RATIO(pll_params->qdiv_ratio) |\n\t\t\t    DPLL_CFGCR1_QDIV_MODE(pll_params->qdiv_mode) |\n\t\t\t    DPLL_CFGCR1_KDIV(pll_params->kdiv) |\n\t\t\t    DPLL_CFGCR1_PDIV(pll_params->pdiv);\n\n\tif (DISPLAY_VER(i915) >= 12)\n\t\tpll_state->cfgcr1 |= TGL_DPLL_CFGCR1_CFSELOVRD_NORMAL_XTAL;\n\telse\n\t\tpll_state->cfgcr1 |= DPLL_CFGCR1_CENTRAL_FREQ_8400;\n\n\tif (i915->display.vbt.override_afc_startup)\n\t\tpll_state->div0 = TGL_DPLL0_DIV0_AFC_STARTUP(i915->display.vbt.override_afc_startup_val);\n}\n\nstatic int icl_mg_pll_find_divisors(int clock_khz, bool is_dp, bool use_ssc,\n\t\t\t\t    u32 *target_dco_khz,\n\t\t\t\t    struct intel_dpll_hw_state *state,\n\t\t\t\t    bool is_dkl)\n{\n\tstatic const u8 div1_vals[] = { 7, 5, 3, 2 };\n\tu32 dco_min_freq, dco_max_freq;\n\tunsigned int i;\n\tint div2;\n\n\tdco_min_freq = is_dp ? 8100000 : use_ssc ? 8000000 : 7992000;\n\tdco_max_freq = is_dp ? 8100000 : 10000000;\n\n\tfor (i = 0; i < ARRAY_SIZE(div1_vals); i++) {\n\t\tint div1 = div1_vals[i];\n\n\t\tfor (div2 = 10; div2 > 0; div2--) {\n\t\t\tint dco = div1 * div2 * clock_khz * 5;\n\t\t\tint a_divratio, tlinedrv, inputsel;\n\t\t\tu32 hsdiv;\n\n\t\t\tif (dco < dco_min_freq || dco > dco_max_freq)\n\t\t\t\tcontinue;\n\n\t\t\tif (div2 >= 2) {\n\t\t\t\t \n\t\t\t\ta_divratio = is_dp ? 10 : 5;\n\t\t\t\ttlinedrv = is_dkl ? 1 : 2;\n\t\t\t} else {\n\t\t\t\ta_divratio = 5;\n\t\t\t\ttlinedrv = 0;\n\t\t\t}\n\t\t\tinputsel = is_dp ? 0 : 1;\n\n\t\t\tswitch (div1) {\n\t\t\tdefault:\n\t\t\t\tMISSING_CASE(div1);\n\t\t\t\tfallthrough;\n\t\t\tcase 2:\n\t\t\t\thsdiv = MG_CLKTOP2_HSCLKCTL_HSDIV_RATIO_2;\n\t\t\t\tbreak;\n\t\t\tcase 3:\n\t\t\t\thsdiv = MG_CLKTOP2_HSCLKCTL_HSDIV_RATIO_3;\n\t\t\t\tbreak;\n\t\t\tcase 5:\n\t\t\t\thsdiv = MG_CLKTOP2_HSCLKCTL_HSDIV_RATIO_5;\n\t\t\t\tbreak;\n\t\t\tcase 7:\n\t\t\t\thsdiv = MG_CLKTOP2_HSCLKCTL_HSDIV_RATIO_7;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t*target_dco_khz = dco;\n\n\t\t\tstate->mg_refclkin_ctl = MG_REFCLKIN_CTL_OD_2_MUX(1);\n\n\t\t\tstate->mg_clktop2_coreclkctl1 =\n\t\t\t\tMG_CLKTOP2_CORECLKCTL1_A_DIVRATIO(a_divratio);\n\n\t\t\tstate->mg_clktop2_hsclkctl =\n\t\t\t\tMG_CLKTOP2_HSCLKCTL_TLINEDRV_CLKSEL(tlinedrv) |\n\t\t\t\tMG_CLKTOP2_HSCLKCTL_CORE_INPUTSEL(inputsel) |\n\t\t\t\thsdiv |\n\t\t\t\tMG_CLKTOP2_HSCLKCTL_DSDIV_RATIO(div2);\n\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\treturn -EINVAL;\n}\n\n \nstatic int icl_calc_mg_pll_state(struct intel_crtc_state *crtc_state,\n\t\t\t\t struct intel_dpll_hw_state *pll_state)\n{\n\tstruct drm_i915_private *dev_priv = to_i915(crtc_state->uapi.crtc->dev);\n\tint refclk_khz = dev_priv->display.dpll.ref_clks.nssc;\n\tint clock = crtc_state->port_clock;\n\tu32 dco_khz, m1div, m2div_int, m2div_rem, m2div_frac;\n\tu32 iref_ndiv, iref_trim, iref_pulse_w;\n\tu32 prop_coeff, int_coeff;\n\tu32 tdc_targetcnt, feedfwgain;\n\tu64 ssc_stepsize, ssc_steplen, ssc_steplog;\n\tu64 tmp;\n\tbool use_ssc = false;\n\tbool is_dp = !intel_crtc_has_type(crtc_state, INTEL_OUTPUT_HDMI);\n\tbool is_dkl = DISPLAY_VER(dev_priv) >= 12;\n\tint ret;\n\n\tret = icl_mg_pll_find_divisors(clock, is_dp, use_ssc, &dco_khz,\n\t\t\t\t       pll_state, is_dkl);\n\tif (ret)\n\t\treturn ret;\n\n\tm1div = 2;\n\tm2div_int = dco_khz / (refclk_khz * m1div);\n\tif (m2div_int > 255) {\n\t\tif (!is_dkl) {\n\t\t\tm1div = 4;\n\t\t\tm2div_int = dco_khz / (refclk_khz * m1div);\n\t\t}\n\n\t\tif (m2div_int > 255)\n\t\t\treturn -EINVAL;\n\t}\n\tm2div_rem = dco_khz % (refclk_khz * m1div);\n\n\ttmp = (u64)m2div_rem * (1 << 22);\n\tdo_div(tmp, refclk_khz * m1div);\n\tm2div_frac = tmp;\n\n\tswitch (refclk_khz) {\n\tcase 19200:\n\t\tiref_ndiv = 1;\n\t\tiref_trim = 28;\n\t\tiref_pulse_w = 1;\n\t\tbreak;\n\tcase 24000:\n\t\tiref_ndiv = 1;\n\t\tiref_trim = 25;\n\t\tiref_pulse_w = 2;\n\t\tbreak;\n\tcase 38400:\n\t\tiref_ndiv = 2;\n\t\tiref_trim = 28;\n\t\tiref_pulse_w = 1;\n\t\tbreak;\n\tdefault:\n\t\tMISSING_CASE(refclk_khz);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\ttdc_targetcnt = (2 * 1000 * 100000 * 10 / (132 * refclk_khz) + 5) / 10;\n\n\t \n\tfeedfwgain = (use_ssc || m2div_rem > 0) ?\n\t\tm1div * 1000000 * 100 / (dco_khz * 3 / 10) : 0;\n\n\tif (dco_khz >= 9000000) {\n\t\tprop_coeff = 5;\n\t\tint_coeff = 10;\n\t} else {\n\t\tprop_coeff = 4;\n\t\tint_coeff = 8;\n\t}\n\n\tif (use_ssc) {\n\t\ttmp = mul_u32_u32(dco_khz, 47 * 32);\n\t\tdo_div(tmp, refclk_khz * m1div * 10000);\n\t\tssc_stepsize = tmp;\n\n\t\ttmp = mul_u32_u32(dco_khz, 1000);\n\t\tssc_steplen = DIV_ROUND_UP_ULL(tmp, 32 * 2 * 32);\n\t} else {\n\t\tssc_stepsize = 0;\n\t\tssc_steplen = 0;\n\t}\n\tssc_steplog = 4;\n\n\t \n\tif (is_dkl) {\n\t\tpll_state->mg_pll_div0 = DKL_PLL_DIV0_INTEG_COEFF(int_coeff) |\n\t\t\t\t\t DKL_PLL_DIV0_PROP_COEFF(prop_coeff) |\n\t\t\t\t\t DKL_PLL_DIV0_FBPREDIV(m1div) |\n\t\t\t\t\t DKL_PLL_DIV0_FBDIV_INT(m2div_int);\n\t\tif (dev_priv->display.vbt.override_afc_startup) {\n\t\t\tu8 val = dev_priv->display.vbt.override_afc_startup_val;\n\n\t\t\tpll_state->mg_pll_div0 |= DKL_PLL_DIV0_AFC_STARTUP(val);\n\t\t}\n\n\t\tpll_state->mg_pll_div1 = DKL_PLL_DIV1_IREF_TRIM(iref_trim) |\n\t\t\t\t\t DKL_PLL_DIV1_TDC_TARGET_CNT(tdc_targetcnt);\n\n\t\tpll_state->mg_pll_ssc = DKL_PLL_SSC_IREF_NDIV_RATIO(iref_ndiv) |\n\t\t\t\t\tDKL_PLL_SSC_STEP_LEN(ssc_steplen) |\n\t\t\t\t\tDKL_PLL_SSC_STEP_NUM(ssc_steplog) |\n\t\t\t\t\t(use_ssc ? DKL_PLL_SSC_EN : 0);\n\n\t\tpll_state->mg_pll_bias = (m2div_frac ? DKL_PLL_BIAS_FRAC_EN_H : 0) |\n\t\t\t\t\t  DKL_PLL_BIAS_FBDIV_FRAC(m2div_frac);\n\n\t\tpll_state->mg_pll_tdc_coldst_bias =\n\t\t\t\tDKL_PLL_TDC_SSC_STEP_SIZE(ssc_stepsize) |\n\t\t\t\tDKL_PLL_TDC_FEED_FWD_GAIN(feedfwgain);\n\n\t} else {\n\t\tpll_state->mg_pll_div0 =\n\t\t\t(m2div_rem > 0 ? MG_PLL_DIV0_FRACNEN_H : 0) |\n\t\t\tMG_PLL_DIV0_FBDIV_FRAC(m2div_frac) |\n\t\t\tMG_PLL_DIV0_FBDIV_INT(m2div_int);\n\n\t\tpll_state->mg_pll_div1 =\n\t\t\tMG_PLL_DIV1_IREF_NDIVRATIO(iref_ndiv) |\n\t\t\tMG_PLL_DIV1_DITHER_DIV_2 |\n\t\t\tMG_PLL_DIV1_NDIVRATIO(1) |\n\t\t\tMG_PLL_DIV1_FBPREDIV(m1div);\n\n\t\tpll_state->mg_pll_lf =\n\t\t\tMG_PLL_LF_TDCTARGETCNT(tdc_targetcnt) |\n\t\t\tMG_PLL_LF_AFCCNTSEL_512 |\n\t\t\tMG_PLL_LF_GAINCTRL(1) |\n\t\t\tMG_PLL_LF_INT_COEFF(int_coeff) |\n\t\t\tMG_PLL_LF_PROP_COEFF(prop_coeff);\n\n\t\tpll_state->mg_pll_frac_lock =\n\t\t\tMG_PLL_FRAC_LOCK_TRUELOCK_CRIT_32 |\n\t\t\tMG_PLL_FRAC_LOCK_EARLYLOCK_CRIT_32 |\n\t\t\tMG_PLL_FRAC_LOCK_LOCKTHRESH(10) |\n\t\t\tMG_PLL_FRAC_LOCK_DCODITHEREN |\n\t\t\tMG_PLL_FRAC_LOCK_FEEDFWRDGAIN(feedfwgain);\n\t\tif (use_ssc || m2div_rem > 0)\n\t\t\tpll_state->mg_pll_frac_lock |=\n\t\t\t\tMG_PLL_FRAC_LOCK_FEEDFWRDCAL_EN;\n\n\t\tpll_state->mg_pll_ssc =\n\t\t\t(use_ssc ? MG_PLL_SSC_EN : 0) |\n\t\t\tMG_PLL_SSC_TYPE(2) |\n\t\t\tMG_PLL_SSC_STEPLENGTH(ssc_steplen) |\n\t\t\tMG_PLL_SSC_STEPNUM(ssc_steplog) |\n\t\t\tMG_PLL_SSC_FLLEN |\n\t\t\tMG_PLL_SSC_STEPSIZE(ssc_stepsize);\n\n\t\tpll_state->mg_pll_tdc_coldst_bias =\n\t\t\tMG_PLL_TDC_COLDST_COLDSTART |\n\t\t\tMG_PLL_TDC_COLDST_IREFINT_EN |\n\t\t\tMG_PLL_TDC_COLDST_REFBIAS_START_PULSE_W(iref_pulse_w) |\n\t\t\tMG_PLL_TDC_TDCOVCCORR_EN |\n\t\t\tMG_PLL_TDC_TDCSEL(3);\n\n\t\tpll_state->mg_pll_bias =\n\t\t\tMG_PLL_BIAS_BIAS_GB_SEL(3) |\n\t\t\tMG_PLL_BIAS_INIT_DCOAMP(0x3F) |\n\t\t\tMG_PLL_BIAS_BIAS_BONUS(10) |\n\t\t\tMG_PLL_BIAS_BIASCAL_EN |\n\t\t\tMG_PLL_BIAS_CTRIM(12) |\n\t\t\tMG_PLL_BIAS_VREF_RDAC(4) |\n\t\t\tMG_PLL_BIAS_IREFTRIM(iref_trim);\n\n\t\tif (refclk_khz == 38400) {\n\t\t\tpll_state->mg_pll_tdc_coldst_bias_mask =\n\t\t\t\tMG_PLL_TDC_COLDST_COLDSTART;\n\t\t\tpll_state->mg_pll_bias_mask = 0;\n\t\t} else {\n\t\t\tpll_state->mg_pll_tdc_coldst_bias_mask = -1U;\n\t\t\tpll_state->mg_pll_bias_mask = -1U;\n\t\t}\n\n\t\tpll_state->mg_pll_tdc_coldst_bias &=\n\t\t\tpll_state->mg_pll_tdc_coldst_bias_mask;\n\t\tpll_state->mg_pll_bias &= pll_state->mg_pll_bias_mask;\n\t}\n\n\treturn 0;\n}\n\nstatic int icl_ddi_mg_pll_get_freq(struct drm_i915_private *dev_priv,\n\t\t\t\t   const struct intel_shared_dpll *pll,\n\t\t\t\t   const struct intel_dpll_hw_state *pll_state)\n{\n\tu32 m1, m2_int, m2_frac, div1, div2, ref_clock;\n\tu64 tmp;\n\n\tref_clock = dev_priv->display.dpll.ref_clks.nssc;\n\n\tif (DISPLAY_VER(dev_priv) >= 12) {\n\t\tm1 = pll_state->mg_pll_div0 & DKL_PLL_DIV0_FBPREDIV_MASK;\n\t\tm1 = m1 >> DKL_PLL_DIV0_FBPREDIV_SHIFT;\n\t\tm2_int = pll_state->mg_pll_div0 & DKL_PLL_DIV0_FBDIV_INT_MASK;\n\n\t\tif (pll_state->mg_pll_bias & DKL_PLL_BIAS_FRAC_EN_H) {\n\t\t\tm2_frac = pll_state->mg_pll_bias &\n\t\t\t\t  DKL_PLL_BIAS_FBDIV_FRAC_MASK;\n\t\t\tm2_frac = m2_frac >> DKL_PLL_BIAS_FBDIV_SHIFT;\n\t\t} else {\n\t\t\tm2_frac = 0;\n\t\t}\n\t} else {\n\t\tm1 = pll_state->mg_pll_div1 & MG_PLL_DIV1_FBPREDIV_MASK;\n\t\tm2_int = pll_state->mg_pll_div0 & MG_PLL_DIV0_FBDIV_INT_MASK;\n\n\t\tif (pll_state->mg_pll_div0 & MG_PLL_DIV0_FRACNEN_H) {\n\t\t\tm2_frac = pll_state->mg_pll_div0 &\n\t\t\t\t  MG_PLL_DIV0_FBDIV_FRAC_MASK;\n\t\t\tm2_frac = m2_frac >> MG_PLL_DIV0_FBDIV_FRAC_SHIFT;\n\t\t} else {\n\t\t\tm2_frac = 0;\n\t\t}\n\t}\n\n\tswitch (pll_state->mg_clktop2_hsclkctl &\n\t\tMG_CLKTOP2_HSCLKCTL_HSDIV_RATIO_MASK) {\n\tcase MG_CLKTOP2_HSCLKCTL_HSDIV_RATIO_2:\n\t\tdiv1 = 2;\n\t\tbreak;\n\tcase MG_CLKTOP2_HSCLKCTL_HSDIV_RATIO_3:\n\t\tdiv1 = 3;\n\t\tbreak;\n\tcase MG_CLKTOP2_HSCLKCTL_HSDIV_RATIO_5:\n\t\tdiv1 = 5;\n\t\tbreak;\n\tcase MG_CLKTOP2_HSCLKCTL_HSDIV_RATIO_7:\n\t\tdiv1 = 7;\n\t\tbreak;\n\tdefault:\n\t\tMISSING_CASE(pll_state->mg_clktop2_hsclkctl);\n\t\treturn 0;\n\t}\n\n\tdiv2 = (pll_state->mg_clktop2_hsclkctl &\n\t\tMG_CLKTOP2_HSCLKCTL_DSDIV_RATIO_MASK) >>\n\t\tMG_CLKTOP2_HSCLKCTL_DSDIV_RATIO_SHIFT;\n\n\t \n\tif (div2 == 0)\n\t\tdiv2 = 1;\n\n\t \n\ttmp = (u64)m1 * m2_int * ref_clock +\n\t      (((u64)m1 * m2_frac * ref_clock) >> 22);\n\ttmp = div_u64(tmp, 5 * div1 * div2);\n\n\treturn tmp;\n}\n\n \nvoid icl_set_active_port_dpll(struct intel_crtc_state *crtc_state,\n\t\t\t      enum icl_port_dpll_id port_dpll_id)\n{\n\tstruct icl_port_dpll *port_dpll =\n\t\t&crtc_state->icl_port_dplls[port_dpll_id];\n\n\tcrtc_state->shared_dpll = port_dpll->pll;\n\tcrtc_state->dpll_hw_state = port_dpll->hw_state;\n}\n\nstatic void icl_update_active_dpll(struct intel_atomic_state *state,\n\t\t\t\t   struct intel_crtc *crtc,\n\t\t\t\t   struct intel_encoder *encoder)\n{\n\tstruct intel_crtc_state *crtc_state =\n\t\tintel_atomic_get_new_crtc_state(state, crtc);\n\tstruct intel_digital_port *primary_port;\n\tenum icl_port_dpll_id port_dpll_id = ICL_PORT_DPLL_DEFAULT;\n\n\tprimary_port = encoder->type == INTEL_OUTPUT_DP_MST ?\n\t\tenc_to_mst(encoder)->primary :\n\t\tenc_to_dig_port(encoder);\n\n\tif (primary_port &&\n\t    (intel_tc_port_in_dp_alt_mode(primary_port) ||\n\t     intel_tc_port_in_legacy_mode(primary_port)))\n\t\tport_dpll_id = ICL_PORT_DPLL_MG_PHY;\n\n\ticl_set_active_port_dpll(crtc_state, port_dpll_id);\n}\n\nstatic int icl_compute_combo_phy_dpll(struct intel_atomic_state *state,\n\t\t\t\t      struct intel_crtc *crtc)\n{\n\tstruct drm_i915_private *dev_priv = to_i915(crtc->base.dev);\n\tstruct intel_crtc_state *crtc_state =\n\t\tintel_atomic_get_new_crtc_state(state, crtc);\n\tstruct icl_port_dpll *port_dpll =\n\t\t&crtc_state->icl_port_dplls[ICL_PORT_DPLL_DEFAULT];\n\tstruct skl_wrpll_params pll_params = {};\n\tint ret;\n\n\tif (intel_crtc_has_type(crtc_state, INTEL_OUTPUT_HDMI) ||\n\t    intel_crtc_has_type(crtc_state, INTEL_OUTPUT_DSI))\n\t\tret = icl_calc_wrpll(crtc_state, &pll_params);\n\telse\n\t\tret = icl_calc_dp_combo_pll(crtc_state, &pll_params);\n\n\tif (ret)\n\t\treturn ret;\n\n\ticl_calc_dpll_state(dev_priv, &pll_params, &port_dpll->hw_state);\n\n\t \n\ticl_set_active_port_dpll(crtc_state, ICL_PORT_DPLL_DEFAULT);\n\n\tcrtc_state->port_clock = icl_ddi_combo_pll_get_freq(dev_priv, NULL,\n\t\t\t\t\t\t\t    &port_dpll->hw_state);\n\n\treturn 0;\n}\n\nstatic int icl_get_combo_phy_dpll(struct intel_atomic_state *state,\n\t\t\t\t  struct intel_crtc *crtc,\n\t\t\t\t  struct intel_encoder *encoder)\n{\n\tstruct drm_i915_private *dev_priv = to_i915(crtc->base.dev);\n\tstruct intel_crtc_state *crtc_state =\n\t\tintel_atomic_get_new_crtc_state(state, crtc);\n\tstruct icl_port_dpll *port_dpll =\n\t\t&crtc_state->icl_port_dplls[ICL_PORT_DPLL_DEFAULT];\n\tenum port port = encoder->port;\n\tunsigned long dpll_mask;\n\n\tif (IS_ALDERLAKE_S(dev_priv)) {\n\t\tdpll_mask =\n\t\t\tBIT(DPLL_ID_DG1_DPLL3) |\n\t\t\tBIT(DPLL_ID_DG1_DPLL2) |\n\t\t\tBIT(DPLL_ID_ICL_DPLL1) |\n\t\t\tBIT(DPLL_ID_ICL_DPLL0);\n\t} else if (IS_DG1(dev_priv)) {\n\t\tif (port == PORT_D || port == PORT_E) {\n\t\t\tdpll_mask =\n\t\t\t\tBIT(DPLL_ID_DG1_DPLL2) |\n\t\t\t\tBIT(DPLL_ID_DG1_DPLL3);\n\t\t} else {\n\t\t\tdpll_mask =\n\t\t\t\tBIT(DPLL_ID_DG1_DPLL0) |\n\t\t\t\tBIT(DPLL_ID_DG1_DPLL1);\n\t\t}\n\t} else if (IS_ROCKETLAKE(dev_priv)) {\n\t\tdpll_mask =\n\t\t\tBIT(DPLL_ID_EHL_DPLL4) |\n\t\t\tBIT(DPLL_ID_ICL_DPLL1) |\n\t\t\tBIT(DPLL_ID_ICL_DPLL0);\n\t} else if ((IS_JASPERLAKE(dev_priv) || IS_ELKHARTLAKE(dev_priv)) &&\n\t\t\t\tport != PORT_A) {\n\t\tdpll_mask =\n\t\t\tBIT(DPLL_ID_EHL_DPLL4) |\n\t\t\tBIT(DPLL_ID_ICL_DPLL1) |\n\t\t\tBIT(DPLL_ID_ICL_DPLL0);\n\t} else {\n\t\tdpll_mask = BIT(DPLL_ID_ICL_DPLL1) | BIT(DPLL_ID_ICL_DPLL0);\n\t}\n\n\t \n\tdpll_mask &= ~intel_hti_dpll_mask(dev_priv);\n\n\tport_dpll->pll = intel_find_shared_dpll(state, crtc,\n\t\t\t\t\t\t&port_dpll->hw_state,\n\t\t\t\t\t\tdpll_mask);\n\tif (!port_dpll->pll)\n\t\treturn -EINVAL;\n\n\tintel_reference_shared_dpll(state, crtc,\n\t\t\t\t    port_dpll->pll, &port_dpll->hw_state);\n\n\ticl_update_active_dpll(state, crtc, encoder);\n\n\treturn 0;\n}\n\nstatic int icl_compute_tc_phy_dplls(struct intel_atomic_state *state,\n\t\t\t\t    struct intel_crtc *crtc)\n{\n\tstruct drm_i915_private *dev_priv = to_i915(state->base.dev);\n\tstruct intel_crtc_state *crtc_state =\n\t\tintel_atomic_get_new_crtc_state(state, crtc);\n\tstruct icl_port_dpll *port_dpll =\n\t\t&crtc_state->icl_port_dplls[ICL_PORT_DPLL_DEFAULT];\n\tstruct skl_wrpll_params pll_params = {};\n\tint ret;\n\n\tport_dpll = &crtc_state->icl_port_dplls[ICL_PORT_DPLL_DEFAULT];\n\tret = icl_calc_tbt_pll(crtc_state, &pll_params);\n\tif (ret)\n\t\treturn ret;\n\n\ticl_calc_dpll_state(dev_priv, &pll_params, &port_dpll->hw_state);\n\n\tport_dpll = &crtc_state->icl_port_dplls[ICL_PORT_DPLL_MG_PHY];\n\tret = icl_calc_mg_pll_state(crtc_state, &port_dpll->hw_state);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\ticl_set_active_port_dpll(crtc_state, ICL_PORT_DPLL_MG_PHY);\n\n\tcrtc_state->port_clock = icl_ddi_mg_pll_get_freq(dev_priv, NULL,\n\t\t\t\t\t\t\t &port_dpll->hw_state);\n\n\treturn 0;\n}\n\nstatic int icl_get_tc_phy_dplls(struct intel_atomic_state *state,\n\t\t\t\tstruct intel_crtc *crtc,\n\t\t\t\tstruct intel_encoder *encoder)\n{\n\tstruct drm_i915_private *dev_priv = to_i915(state->base.dev);\n\tstruct intel_crtc_state *crtc_state =\n\t\tintel_atomic_get_new_crtc_state(state, crtc);\n\tstruct icl_port_dpll *port_dpll =\n\t\t&crtc_state->icl_port_dplls[ICL_PORT_DPLL_DEFAULT];\n\tenum intel_dpll_id dpll_id;\n\tint ret;\n\n\tport_dpll = &crtc_state->icl_port_dplls[ICL_PORT_DPLL_DEFAULT];\n\tport_dpll->pll = intel_find_shared_dpll(state, crtc,\n\t\t\t\t\t\t&port_dpll->hw_state,\n\t\t\t\t\t\tBIT(DPLL_ID_ICL_TBTPLL));\n\tif (!port_dpll->pll)\n\t\treturn -EINVAL;\n\tintel_reference_shared_dpll(state, crtc,\n\t\t\t\t    port_dpll->pll, &port_dpll->hw_state);\n\n\n\tport_dpll = &crtc_state->icl_port_dplls[ICL_PORT_DPLL_MG_PHY];\n\tdpll_id = icl_tc_port_to_pll_id(intel_port_to_tc(dev_priv,\n\t\t\t\t\t\t\t encoder->port));\n\tport_dpll->pll = intel_find_shared_dpll(state, crtc,\n\t\t\t\t\t\t&port_dpll->hw_state,\n\t\t\t\t\t\tBIT(dpll_id));\n\tif (!port_dpll->pll) {\n\t\tret = -EINVAL;\n\t\tgoto err_unreference_tbt_pll;\n\t}\n\tintel_reference_shared_dpll(state, crtc,\n\t\t\t\t    port_dpll->pll, &port_dpll->hw_state);\n\n\ticl_update_active_dpll(state, crtc, encoder);\n\n\treturn 0;\n\nerr_unreference_tbt_pll:\n\tport_dpll = &crtc_state->icl_port_dplls[ICL_PORT_DPLL_DEFAULT];\n\tintel_unreference_shared_dpll(state, crtc, port_dpll->pll);\n\n\treturn ret;\n}\n\nstatic int icl_compute_dplls(struct intel_atomic_state *state,\n\t\t\t     struct intel_crtc *crtc,\n\t\t\t     struct intel_encoder *encoder)\n{\n\tstruct drm_i915_private *dev_priv = to_i915(state->base.dev);\n\tenum phy phy = intel_port_to_phy(dev_priv, encoder->port);\n\n\tif (intel_phy_is_combo(dev_priv, phy))\n\t\treturn icl_compute_combo_phy_dpll(state, crtc);\n\telse if (intel_phy_is_tc(dev_priv, phy))\n\t\treturn icl_compute_tc_phy_dplls(state, crtc);\n\n\tMISSING_CASE(phy);\n\n\treturn 0;\n}\n\nstatic int icl_get_dplls(struct intel_atomic_state *state,\n\t\t\t struct intel_crtc *crtc,\n\t\t\t struct intel_encoder *encoder)\n{\n\tstruct drm_i915_private *dev_priv = to_i915(state->base.dev);\n\tenum phy phy = intel_port_to_phy(dev_priv, encoder->port);\n\n\tif (intel_phy_is_combo(dev_priv, phy))\n\t\treturn icl_get_combo_phy_dpll(state, crtc, encoder);\n\telse if (intel_phy_is_tc(dev_priv, phy))\n\t\treturn icl_get_tc_phy_dplls(state, crtc, encoder);\n\n\tMISSING_CASE(phy);\n\n\treturn -EINVAL;\n}\n\nstatic void icl_put_dplls(struct intel_atomic_state *state,\n\t\t\t  struct intel_crtc *crtc)\n{\n\tconst struct intel_crtc_state *old_crtc_state =\n\t\tintel_atomic_get_old_crtc_state(state, crtc);\n\tstruct intel_crtc_state *new_crtc_state =\n\t\tintel_atomic_get_new_crtc_state(state, crtc);\n\tenum icl_port_dpll_id id;\n\n\tnew_crtc_state->shared_dpll = NULL;\n\n\tfor (id = ICL_PORT_DPLL_DEFAULT; id < ICL_PORT_DPLL_COUNT; id++) {\n\t\tconst struct icl_port_dpll *old_port_dpll =\n\t\t\t&old_crtc_state->icl_port_dplls[id];\n\t\tstruct icl_port_dpll *new_port_dpll =\n\t\t\t&new_crtc_state->icl_port_dplls[id];\n\n\t\tnew_port_dpll->pll = NULL;\n\n\t\tif (!old_port_dpll->pll)\n\t\t\tcontinue;\n\n\t\tintel_unreference_shared_dpll(state, crtc, old_port_dpll->pll);\n\t}\n}\n\nstatic bool mg_pll_get_hw_state(struct drm_i915_private *dev_priv,\n\t\t\t\tstruct intel_shared_dpll *pll,\n\t\t\t\tstruct intel_dpll_hw_state *hw_state)\n{\n\tconst enum intel_dpll_id id = pll->info->id;\n\tenum tc_port tc_port = icl_pll_id_to_tc_port(id);\n\tintel_wakeref_t wakeref;\n\tbool ret = false;\n\tu32 val;\n\n\ti915_reg_t enable_reg = intel_tc_pll_enable_reg(dev_priv, pll);\n\n\twakeref = intel_display_power_get_if_enabled(dev_priv,\n\t\t\t\t\t\t     POWER_DOMAIN_DISPLAY_CORE);\n\tif (!wakeref)\n\t\treturn false;\n\n\tval = intel_de_read(dev_priv, enable_reg);\n\tif (!(val & PLL_ENABLE))\n\t\tgoto out;\n\n\thw_state->mg_refclkin_ctl = intel_de_read(dev_priv,\n\t\t\t\t\t\t  MG_REFCLKIN_CTL(tc_port));\n\thw_state->mg_refclkin_ctl &= MG_REFCLKIN_CTL_OD_2_MUX_MASK;\n\n\thw_state->mg_clktop2_coreclkctl1 =\n\t\tintel_de_read(dev_priv, MG_CLKTOP2_CORECLKCTL1(tc_port));\n\thw_state->mg_clktop2_coreclkctl1 &=\n\t\tMG_CLKTOP2_CORECLKCTL1_A_DIVRATIO_MASK;\n\n\thw_state->mg_clktop2_hsclkctl =\n\t\tintel_de_read(dev_priv, MG_CLKTOP2_HSCLKCTL(tc_port));\n\thw_state->mg_clktop2_hsclkctl &=\n\t\tMG_CLKTOP2_HSCLKCTL_TLINEDRV_CLKSEL_MASK |\n\t\tMG_CLKTOP2_HSCLKCTL_CORE_INPUTSEL_MASK |\n\t\tMG_CLKTOP2_HSCLKCTL_HSDIV_RATIO_MASK |\n\t\tMG_CLKTOP2_HSCLKCTL_DSDIV_RATIO_MASK;\n\n\thw_state->mg_pll_div0 = intel_de_read(dev_priv, MG_PLL_DIV0(tc_port));\n\thw_state->mg_pll_div1 = intel_de_read(dev_priv, MG_PLL_DIV1(tc_port));\n\thw_state->mg_pll_lf = intel_de_read(dev_priv, MG_PLL_LF(tc_port));\n\thw_state->mg_pll_frac_lock = intel_de_read(dev_priv,\n\t\t\t\t\t\t   MG_PLL_FRAC_LOCK(tc_port));\n\thw_state->mg_pll_ssc = intel_de_read(dev_priv, MG_PLL_SSC(tc_port));\n\n\thw_state->mg_pll_bias = intel_de_read(dev_priv, MG_PLL_BIAS(tc_port));\n\thw_state->mg_pll_tdc_coldst_bias =\n\t\tintel_de_read(dev_priv, MG_PLL_TDC_COLDST_BIAS(tc_port));\n\n\tif (dev_priv->display.dpll.ref_clks.nssc == 38400) {\n\t\thw_state->mg_pll_tdc_coldst_bias_mask = MG_PLL_TDC_COLDST_COLDSTART;\n\t\thw_state->mg_pll_bias_mask = 0;\n\t} else {\n\t\thw_state->mg_pll_tdc_coldst_bias_mask = -1U;\n\t\thw_state->mg_pll_bias_mask = -1U;\n\t}\n\n\thw_state->mg_pll_tdc_coldst_bias &= hw_state->mg_pll_tdc_coldst_bias_mask;\n\thw_state->mg_pll_bias &= hw_state->mg_pll_bias_mask;\n\n\tret = true;\nout:\n\tintel_display_power_put(dev_priv, POWER_DOMAIN_DISPLAY_CORE, wakeref);\n\treturn ret;\n}\n\nstatic bool dkl_pll_get_hw_state(struct drm_i915_private *dev_priv,\n\t\t\t\t struct intel_shared_dpll *pll,\n\t\t\t\t struct intel_dpll_hw_state *hw_state)\n{\n\tconst enum intel_dpll_id id = pll->info->id;\n\tenum tc_port tc_port = icl_pll_id_to_tc_port(id);\n\tintel_wakeref_t wakeref;\n\tbool ret = false;\n\tu32 val;\n\n\twakeref = intel_display_power_get_if_enabled(dev_priv,\n\t\t\t\t\t\t     POWER_DOMAIN_DISPLAY_CORE);\n\tif (!wakeref)\n\t\treturn false;\n\n\tval = intel_de_read(dev_priv, intel_tc_pll_enable_reg(dev_priv, pll));\n\tif (!(val & PLL_ENABLE))\n\t\tgoto out;\n\n\t \n\thw_state->mg_refclkin_ctl = intel_dkl_phy_read(dev_priv,\n\t\t\t\t\t\t       DKL_REFCLKIN_CTL(tc_port));\n\thw_state->mg_refclkin_ctl &= MG_REFCLKIN_CTL_OD_2_MUX_MASK;\n\n\thw_state->mg_clktop2_hsclkctl =\n\t\tintel_dkl_phy_read(dev_priv, DKL_CLKTOP2_HSCLKCTL(tc_port));\n\thw_state->mg_clktop2_hsclkctl &=\n\t\tMG_CLKTOP2_HSCLKCTL_TLINEDRV_CLKSEL_MASK |\n\t\tMG_CLKTOP2_HSCLKCTL_CORE_INPUTSEL_MASK |\n\t\tMG_CLKTOP2_HSCLKCTL_HSDIV_RATIO_MASK |\n\t\tMG_CLKTOP2_HSCLKCTL_DSDIV_RATIO_MASK;\n\n\thw_state->mg_clktop2_coreclkctl1 =\n\t\tintel_dkl_phy_read(dev_priv, DKL_CLKTOP2_CORECLKCTL1(tc_port));\n\thw_state->mg_clktop2_coreclkctl1 &=\n\t\tMG_CLKTOP2_CORECLKCTL1_A_DIVRATIO_MASK;\n\n\thw_state->mg_pll_div0 = intel_dkl_phy_read(dev_priv, DKL_PLL_DIV0(tc_port));\n\tval = DKL_PLL_DIV0_MASK;\n\tif (dev_priv->display.vbt.override_afc_startup)\n\t\tval |= DKL_PLL_DIV0_AFC_STARTUP_MASK;\n\thw_state->mg_pll_div0 &= val;\n\n\thw_state->mg_pll_div1 = intel_dkl_phy_read(dev_priv, DKL_PLL_DIV1(tc_port));\n\thw_state->mg_pll_div1 &= (DKL_PLL_DIV1_IREF_TRIM_MASK |\n\t\t\t\t  DKL_PLL_DIV1_TDC_TARGET_CNT_MASK);\n\n\thw_state->mg_pll_ssc = intel_dkl_phy_read(dev_priv, DKL_PLL_SSC(tc_port));\n\thw_state->mg_pll_ssc &= (DKL_PLL_SSC_IREF_NDIV_RATIO_MASK |\n\t\t\t\t DKL_PLL_SSC_STEP_LEN_MASK |\n\t\t\t\t DKL_PLL_SSC_STEP_NUM_MASK |\n\t\t\t\t DKL_PLL_SSC_EN);\n\n\thw_state->mg_pll_bias = intel_dkl_phy_read(dev_priv, DKL_PLL_BIAS(tc_port));\n\thw_state->mg_pll_bias &= (DKL_PLL_BIAS_FRAC_EN_H |\n\t\t\t\t  DKL_PLL_BIAS_FBDIV_FRAC_MASK);\n\n\thw_state->mg_pll_tdc_coldst_bias =\n\t\tintel_dkl_phy_read(dev_priv, DKL_PLL_TDC_COLDST_BIAS(tc_port));\n\thw_state->mg_pll_tdc_coldst_bias &= (DKL_PLL_TDC_SSC_STEP_SIZE_MASK |\n\t\t\t\t\t     DKL_PLL_TDC_FEED_FWD_GAIN_MASK);\n\n\tret = true;\nout:\n\tintel_display_power_put(dev_priv, POWER_DOMAIN_DISPLAY_CORE, wakeref);\n\treturn ret;\n}\n\nstatic bool icl_pll_get_hw_state(struct drm_i915_private *dev_priv,\n\t\t\t\t struct intel_shared_dpll *pll,\n\t\t\t\t struct intel_dpll_hw_state *hw_state,\n\t\t\t\t i915_reg_t enable_reg)\n{\n\tconst enum intel_dpll_id id = pll->info->id;\n\tintel_wakeref_t wakeref;\n\tbool ret = false;\n\tu32 val;\n\n\twakeref = intel_display_power_get_if_enabled(dev_priv,\n\t\t\t\t\t\t     POWER_DOMAIN_DISPLAY_CORE);\n\tif (!wakeref)\n\t\treturn false;\n\n\tval = intel_de_read(dev_priv, enable_reg);\n\tif (!(val & PLL_ENABLE))\n\t\tgoto out;\n\n\tif (IS_ALDERLAKE_S(dev_priv)) {\n\t\thw_state->cfgcr0 = intel_de_read(dev_priv, ADLS_DPLL_CFGCR0(id));\n\t\thw_state->cfgcr1 = intel_de_read(dev_priv, ADLS_DPLL_CFGCR1(id));\n\t} else if (IS_DG1(dev_priv)) {\n\t\thw_state->cfgcr0 = intel_de_read(dev_priv, DG1_DPLL_CFGCR0(id));\n\t\thw_state->cfgcr1 = intel_de_read(dev_priv, DG1_DPLL_CFGCR1(id));\n\t} else if (IS_ROCKETLAKE(dev_priv)) {\n\t\thw_state->cfgcr0 = intel_de_read(dev_priv,\n\t\t\t\t\t\t RKL_DPLL_CFGCR0(id));\n\t\thw_state->cfgcr1 = intel_de_read(dev_priv,\n\t\t\t\t\t\t RKL_DPLL_CFGCR1(id));\n\t} else if (DISPLAY_VER(dev_priv) >= 12) {\n\t\thw_state->cfgcr0 = intel_de_read(dev_priv,\n\t\t\t\t\t\t TGL_DPLL_CFGCR0(id));\n\t\thw_state->cfgcr1 = intel_de_read(dev_priv,\n\t\t\t\t\t\t TGL_DPLL_CFGCR1(id));\n\t\tif (dev_priv->display.vbt.override_afc_startup) {\n\t\t\thw_state->div0 = intel_de_read(dev_priv, TGL_DPLL0_DIV0(id));\n\t\t\thw_state->div0 &= TGL_DPLL0_DIV0_AFC_STARTUP_MASK;\n\t\t}\n\t} else {\n\t\tif ((IS_JASPERLAKE(dev_priv) || IS_ELKHARTLAKE(dev_priv)) &&\n\t\t    id == DPLL_ID_EHL_DPLL4) {\n\t\t\thw_state->cfgcr0 = intel_de_read(dev_priv,\n\t\t\t\t\t\t\t ICL_DPLL_CFGCR0(4));\n\t\t\thw_state->cfgcr1 = intel_de_read(dev_priv,\n\t\t\t\t\t\t\t ICL_DPLL_CFGCR1(4));\n\t\t} else {\n\t\t\thw_state->cfgcr0 = intel_de_read(dev_priv,\n\t\t\t\t\t\t\t ICL_DPLL_CFGCR0(id));\n\t\t\thw_state->cfgcr1 = intel_de_read(dev_priv,\n\t\t\t\t\t\t\t ICL_DPLL_CFGCR1(id));\n\t\t}\n\t}\n\n\tret = true;\nout:\n\tintel_display_power_put(dev_priv, POWER_DOMAIN_DISPLAY_CORE, wakeref);\n\treturn ret;\n}\n\nstatic bool combo_pll_get_hw_state(struct drm_i915_private *dev_priv,\n\t\t\t\t   struct intel_shared_dpll *pll,\n\t\t\t\t   struct intel_dpll_hw_state *hw_state)\n{\n\ti915_reg_t enable_reg = intel_combo_pll_enable_reg(dev_priv, pll);\n\n\treturn icl_pll_get_hw_state(dev_priv, pll, hw_state, enable_reg);\n}\n\nstatic bool tbt_pll_get_hw_state(struct drm_i915_private *dev_priv,\n\t\t\t\t struct intel_shared_dpll *pll,\n\t\t\t\t struct intel_dpll_hw_state *hw_state)\n{\n\treturn icl_pll_get_hw_state(dev_priv, pll, hw_state, TBT_PLL_ENABLE);\n}\n\nstatic void icl_dpll_write(struct drm_i915_private *dev_priv,\n\t\t\t   struct intel_shared_dpll *pll)\n{\n\tstruct intel_dpll_hw_state *hw_state = &pll->state.hw_state;\n\tconst enum intel_dpll_id id = pll->info->id;\n\ti915_reg_t cfgcr0_reg, cfgcr1_reg, div0_reg = INVALID_MMIO_REG;\n\n\tif (IS_ALDERLAKE_S(dev_priv)) {\n\t\tcfgcr0_reg = ADLS_DPLL_CFGCR0(id);\n\t\tcfgcr1_reg = ADLS_DPLL_CFGCR1(id);\n\t} else if (IS_DG1(dev_priv)) {\n\t\tcfgcr0_reg = DG1_DPLL_CFGCR0(id);\n\t\tcfgcr1_reg = DG1_DPLL_CFGCR1(id);\n\t} else if (IS_ROCKETLAKE(dev_priv)) {\n\t\tcfgcr0_reg = RKL_DPLL_CFGCR0(id);\n\t\tcfgcr1_reg = RKL_DPLL_CFGCR1(id);\n\t} else if (DISPLAY_VER(dev_priv) >= 12) {\n\t\tcfgcr0_reg = TGL_DPLL_CFGCR0(id);\n\t\tcfgcr1_reg = TGL_DPLL_CFGCR1(id);\n\t\tdiv0_reg = TGL_DPLL0_DIV0(id);\n\t} else {\n\t\tif ((IS_JASPERLAKE(dev_priv) || IS_ELKHARTLAKE(dev_priv)) &&\n\t\t    id == DPLL_ID_EHL_DPLL4) {\n\t\t\tcfgcr0_reg = ICL_DPLL_CFGCR0(4);\n\t\t\tcfgcr1_reg = ICL_DPLL_CFGCR1(4);\n\t\t} else {\n\t\t\tcfgcr0_reg = ICL_DPLL_CFGCR0(id);\n\t\t\tcfgcr1_reg = ICL_DPLL_CFGCR1(id);\n\t\t}\n\t}\n\n\tintel_de_write(dev_priv, cfgcr0_reg, hw_state->cfgcr0);\n\tintel_de_write(dev_priv, cfgcr1_reg, hw_state->cfgcr1);\n\tdrm_WARN_ON_ONCE(&dev_priv->drm, dev_priv->display.vbt.override_afc_startup &&\n\t\t\t !i915_mmio_reg_valid(div0_reg));\n\tif (dev_priv->display.vbt.override_afc_startup &&\n\t    i915_mmio_reg_valid(div0_reg))\n\t\tintel_de_rmw(dev_priv, div0_reg,\n\t\t\t     TGL_DPLL0_DIV0_AFC_STARTUP_MASK, hw_state->div0);\n\tintel_de_posting_read(dev_priv, cfgcr1_reg);\n}\n\nstatic void icl_mg_pll_write(struct drm_i915_private *dev_priv,\n\t\t\t     struct intel_shared_dpll *pll)\n{\n\tstruct intel_dpll_hw_state *hw_state = &pll->state.hw_state;\n\tenum tc_port tc_port = icl_pll_id_to_tc_port(pll->info->id);\n\n\t \n\tintel_de_rmw(dev_priv, MG_REFCLKIN_CTL(tc_port),\n\t\t     MG_REFCLKIN_CTL_OD_2_MUX_MASK, hw_state->mg_refclkin_ctl);\n\n\tintel_de_rmw(dev_priv, MG_CLKTOP2_CORECLKCTL1(tc_port),\n\t\t     MG_CLKTOP2_CORECLKCTL1_A_DIVRATIO_MASK,\n\t\t     hw_state->mg_clktop2_coreclkctl1);\n\n\tintel_de_rmw(dev_priv, MG_CLKTOP2_HSCLKCTL(tc_port),\n\t\t     MG_CLKTOP2_HSCLKCTL_TLINEDRV_CLKSEL_MASK |\n\t\t     MG_CLKTOP2_HSCLKCTL_CORE_INPUTSEL_MASK |\n\t\t     MG_CLKTOP2_HSCLKCTL_HSDIV_RATIO_MASK |\n\t\t     MG_CLKTOP2_HSCLKCTL_DSDIV_RATIO_MASK,\n\t\t     hw_state->mg_clktop2_hsclkctl);\n\n\tintel_de_write(dev_priv, MG_PLL_DIV0(tc_port), hw_state->mg_pll_div0);\n\tintel_de_write(dev_priv, MG_PLL_DIV1(tc_port), hw_state->mg_pll_div1);\n\tintel_de_write(dev_priv, MG_PLL_LF(tc_port), hw_state->mg_pll_lf);\n\tintel_de_write(dev_priv, MG_PLL_FRAC_LOCK(tc_port),\n\t\t       hw_state->mg_pll_frac_lock);\n\tintel_de_write(dev_priv, MG_PLL_SSC(tc_port), hw_state->mg_pll_ssc);\n\n\tintel_de_rmw(dev_priv, MG_PLL_BIAS(tc_port),\n\t\t     hw_state->mg_pll_bias_mask, hw_state->mg_pll_bias);\n\n\tintel_de_rmw(dev_priv, MG_PLL_TDC_COLDST_BIAS(tc_port),\n\t\t     hw_state->mg_pll_tdc_coldst_bias_mask,\n\t\t     hw_state->mg_pll_tdc_coldst_bias);\n\n\tintel_de_posting_read(dev_priv, MG_PLL_TDC_COLDST_BIAS(tc_port));\n}\n\nstatic void dkl_pll_write(struct drm_i915_private *dev_priv,\n\t\t\t  struct intel_shared_dpll *pll)\n{\n\tstruct intel_dpll_hw_state *hw_state = &pll->state.hw_state;\n\tenum tc_port tc_port = icl_pll_id_to_tc_port(pll->info->id);\n\tu32 val;\n\n\t \n\t \n\tval = intel_dkl_phy_read(dev_priv, DKL_REFCLKIN_CTL(tc_port));\n\tval &= ~MG_REFCLKIN_CTL_OD_2_MUX_MASK;\n\tval |= hw_state->mg_refclkin_ctl;\n\tintel_dkl_phy_write(dev_priv, DKL_REFCLKIN_CTL(tc_port), val);\n\n\tval = intel_dkl_phy_read(dev_priv, DKL_CLKTOP2_CORECLKCTL1(tc_port));\n\tval &= ~MG_CLKTOP2_CORECLKCTL1_A_DIVRATIO_MASK;\n\tval |= hw_state->mg_clktop2_coreclkctl1;\n\tintel_dkl_phy_write(dev_priv, DKL_CLKTOP2_CORECLKCTL1(tc_port), val);\n\n\tval = intel_dkl_phy_read(dev_priv, DKL_CLKTOP2_HSCLKCTL(tc_port));\n\tval &= ~(MG_CLKTOP2_HSCLKCTL_TLINEDRV_CLKSEL_MASK |\n\t\t MG_CLKTOP2_HSCLKCTL_CORE_INPUTSEL_MASK |\n\t\t MG_CLKTOP2_HSCLKCTL_HSDIV_RATIO_MASK |\n\t\t MG_CLKTOP2_HSCLKCTL_DSDIV_RATIO_MASK);\n\tval |= hw_state->mg_clktop2_hsclkctl;\n\tintel_dkl_phy_write(dev_priv, DKL_CLKTOP2_HSCLKCTL(tc_port), val);\n\n\tval = DKL_PLL_DIV0_MASK;\n\tif (dev_priv->display.vbt.override_afc_startup)\n\t\tval |= DKL_PLL_DIV0_AFC_STARTUP_MASK;\n\tintel_dkl_phy_rmw(dev_priv, DKL_PLL_DIV0(tc_port), val,\n\t\t\t  hw_state->mg_pll_div0);\n\n\tval = intel_dkl_phy_read(dev_priv, DKL_PLL_DIV1(tc_port));\n\tval &= ~(DKL_PLL_DIV1_IREF_TRIM_MASK |\n\t\t DKL_PLL_DIV1_TDC_TARGET_CNT_MASK);\n\tval |= hw_state->mg_pll_div1;\n\tintel_dkl_phy_write(dev_priv, DKL_PLL_DIV1(tc_port), val);\n\n\tval = intel_dkl_phy_read(dev_priv, DKL_PLL_SSC(tc_port));\n\tval &= ~(DKL_PLL_SSC_IREF_NDIV_RATIO_MASK |\n\t\t DKL_PLL_SSC_STEP_LEN_MASK |\n\t\t DKL_PLL_SSC_STEP_NUM_MASK |\n\t\t DKL_PLL_SSC_EN);\n\tval |= hw_state->mg_pll_ssc;\n\tintel_dkl_phy_write(dev_priv, DKL_PLL_SSC(tc_port), val);\n\n\tval = intel_dkl_phy_read(dev_priv, DKL_PLL_BIAS(tc_port));\n\tval &= ~(DKL_PLL_BIAS_FRAC_EN_H |\n\t\t DKL_PLL_BIAS_FBDIV_FRAC_MASK);\n\tval |= hw_state->mg_pll_bias;\n\tintel_dkl_phy_write(dev_priv, DKL_PLL_BIAS(tc_port), val);\n\n\tval = intel_dkl_phy_read(dev_priv, DKL_PLL_TDC_COLDST_BIAS(tc_port));\n\tval &= ~(DKL_PLL_TDC_SSC_STEP_SIZE_MASK |\n\t\t DKL_PLL_TDC_FEED_FWD_GAIN_MASK);\n\tval |= hw_state->mg_pll_tdc_coldst_bias;\n\tintel_dkl_phy_write(dev_priv, DKL_PLL_TDC_COLDST_BIAS(tc_port), val);\n\n\tintel_dkl_phy_posting_read(dev_priv, DKL_PLL_TDC_COLDST_BIAS(tc_port));\n}\n\nstatic void icl_pll_power_enable(struct drm_i915_private *dev_priv,\n\t\t\t\t struct intel_shared_dpll *pll,\n\t\t\t\t i915_reg_t enable_reg)\n{\n\tintel_de_rmw(dev_priv, enable_reg, 0, PLL_POWER_ENABLE);\n\n\t \n\tif (intel_de_wait_for_set(dev_priv, enable_reg, PLL_POWER_STATE, 1))\n\t\tdrm_err(&dev_priv->drm, \"PLL %d Power not enabled\\n\",\n\t\t\tpll->info->id);\n}\n\nstatic void icl_pll_enable(struct drm_i915_private *dev_priv,\n\t\t\t   struct intel_shared_dpll *pll,\n\t\t\t   i915_reg_t enable_reg)\n{\n\tintel_de_rmw(dev_priv, enable_reg, 0, PLL_ENABLE);\n\n\t \n\tif (intel_de_wait_for_set(dev_priv, enable_reg, PLL_LOCK, 1))\n\t\tdrm_err(&dev_priv->drm, \"PLL %d not locked\\n\", pll->info->id);\n}\n\nstatic void adlp_cmtg_clock_gating_wa(struct drm_i915_private *i915, struct intel_shared_dpll *pll)\n{\n\tu32 val;\n\n\tif (!(IS_ALDERLAKE_P(i915) && IS_DISPLAY_STEP(i915, STEP_A0, STEP_B0)) ||\n\t    pll->info->id != DPLL_ID_ICL_DPLL0)\n\t\treturn;\n\t \n\tval = intel_de_read(i915, TRANS_CMTG_CHICKEN);\n\tval = intel_de_rmw(i915, TRANS_CMTG_CHICKEN, ~0, DISABLE_DPT_CLK_GATING);\n\tif (drm_WARN_ON(&i915->drm, val & ~DISABLE_DPT_CLK_GATING))\n\t\tdrm_dbg_kms(&i915->drm, \"Unexpected flags in TRANS_CMTG_CHICKEN: %08x\\n\", val);\n}\n\nstatic void combo_pll_enable(struct drm_i915_private *dev_priv,\n\t\t\t     struct intel_shared_dpll *pll)\n{\n\ti915_reg_t enable_reg = intel_combo_pll_enable_reg(dev_priv, pll);\n\n\tif ((IS_JASPERLAKE(dev_priv) || IS_ELKHARTLAKE(dev_priv)) &&\n\t    pll->info->id == DPLL_ID_EHL_DPLL4) {\n\n\t\t \n\t\tpll->wakeref = intel_display_power_get(dev_priv,\n\t\t\t\t\t\t       POWER_DOMAIN_DC_OFF);\n\t}\n\n\ticl_pll_power_enable(dev_priv, pll, enable_reg);\n\n\ticl_dpll_write(dev_priv, pll);\n\n\t \n\n\ticl_pll_enable(dev_priv, pll, enable_reg);\n\n\tadlp_cmtg_clock_gating_wa(dev_priv, pll);\n\n\t \n}\n\nstatic void tbt_pll_enable(struct drm_i915_private *dev_priv,\n\t\t\t   struct intel_shared_dpll *pll)\n{\n\ticl_pll_power_enable(dev_priv, pll, TBT_PLL_ENABLE);\n\n\ticl_dpll_write(dev_priv, pll);\n\n\t \n\n\ticl_pll_enable(dev_priv, pll, TBT_PLL_ENABLE);\n\n\t \n}\n\nstatic void mg_pll_enable(struct drm_i915_private *dev_priv,\n\t\t\t  struct intel_shared_dpll *pll)\n{\n\ti915_reg_t enable_reg = intel_tc_pll_enable_reg(dev_priv, pll);\n\n\ticl_pll_power_enable(dev_priv, pll, enable_reg);\n\n\tif (DISPLAY_VER(dev_priv) >= 12)\n\t\tdkl_pll_write(dev_priv, pll);\n\telse\n\t\ticl_mg_pll_write(dev_priv, pll);\n\n\t \n\n\ticl_pll_enable(dev_priv, pll, enable_reg);\n\n\t \n}\n\nstatic void icl_pll_disable(struct drm_i915_private *dev_priv,\n\t\t\t    struct intel_shared_dpll *pll,\n\t\t\t    i915_reg_t enable_reg)\n{\n\t \n\n\t \n\n\tintel_de_rmw(dev_priv, enable_reg, PLL_ENABLE, 0);\n\n\t \n\tif (intel_de_wait_for_clear(dev_priv, enable_reg, PLL_LOCK, 1))\n\t\tdrm_err(&dev_priv->drm, \"PLL %d locked\\n\", pll->info->id);\n\n\t \n\n\tintel_de_rmw(dev_priv, enable_reg, PLL_POWER_ENABLE, 0);\n\n\t \n\tif (intel_de_wait_for_clear(dev_priv, enable_reg, PLL_POWER_STATE, 1))\n\t\tdrm_err(&dev_priv->drm, \"PLL %d Power not disabled\\n\",\n\t\t\tpll->info->id);\n}\n\nstatic void combo_pll_disable(struct drm_i915_private *dev_priv,\n\t\t\t      struct intel_shared_dpll *pll)\n{\n\ti915_reg_t enable_reg = intel_combo_pll_enable_reg(dev_priv, pll);\n\n\ticl_pll_disable(dev_priv, pll, enable_reg);\n\n\tif ((IS_JASPERLAKE(dev_priv) || IS_ELKHARTLAKE(dev_priv)) &&\n\t    pll->info->id == DPLL_ID_EHL_DPLL4)\n\t\tintel_display_power_put(dev_priv, POWER_DOMAIN_DC_OFF,\n\t\t\t\t\tpll->wakeref);\n}\n\nstatic void tbt_pll_disable(struct drm_i915_private *dev_priv,\n\t\t\t    struct intel_shared_dpll *pll)\n{\n\ticl_pll_disable(dev_priv, pll, TBT_PLL_ENABLE);\n}\n\nstatic void mg_pll_disable(struct drm_i915_private *dev_priv,\n\t\t\t   struct intel_shared_dpll *pll)\n{\n\ti915_reg_t enable_reg = intel_tc_pll_enable_reg(dev_priv, pll);\n\n\ticl_pll_disable(dev_priv, pll, enable_reg);\n}\n\nstatic void icl_update_dpll_ref_clks(struct drm_i915_private *i915)\n{\n\t \n\ti915->display.dpll.ref_clks.nssc = i915->display.cdclk.hw.ref;\n}\n\nstatic void icl_dump_hw_state(struct drm_i915_private *dev_priv,\n\t\t\t      const struct intel_dpll_hw_state *hw_state)\n{\n\tdrm_dbg_kms(&dev_priv->drm,\n\t\t    \"dpll_hw_state: cfgcr0: 0x%x, cfgcr1: 0x%x, div0: 0x%x, \"\n\t\t    \"mg_refclkin_ctl: 0x%x, hg_clktop2_coreclkctl1: 0x%x, \"\n\t\t    \"mg_clktop2_hsclkctl: 0x%x, mg_pll_div0: 0x%x, \"\n\t\t    \"mg_pll_div2: 0x%x, mg_pll_lf: 0x%x, \"\n\t\t    \"mg_pll_frac_lock: 0x%x, mg_pll_ssc: 0x%x, \"\n\t\t    \"mg_pll_bias: 0x%x, mg_pll_tdc_coldst_bias: 0x%x\\n\",\n\t\t    hw_state->cfgcr0, hw_state->cfgcr1,\n\t\t    hw_state->div0,\n\t\t    hw_state->mg_refclkin_ctl,\n\t\t    hw_state->mg_clktop2_coreclkctl1,\n\t\t    hw_state->mg_clktop2_hsclkctl,\n\t\t    hw_state->mg_pll_div0,\n\t\t    hw_state->mg_pll_div1,\n\t\t    hw_state->mg_pll_lf,\n\t\t    hw_state->mg_pll_frac_lock,\n\t\t    hw_state->mg_pll_ssc,\n\t\t    hw_state->mg_pll_bias,\n\t\t    hw_state->mg_pll_tdc_coldst_bias);\n}\n\nstatic const struct intel_shared_dpll_funcs combo_pll_funcs = {\n\t.enable = combo_pll_enable,\n\t.disable = combo_pll_disable,\n\t.get_hw_state = combo_pll_get_hw_state,\n\t.get_freq = icl_ddi_combo_pll_get_freq,\n};\n\nstatic const struct intel_shared_dpll_funcs tbt_pll_funcs = {\n\t.enable = tbt_pll_enable,\n\t.disable = tbt_pll_disable,\n\t.get_hw_state = tbt_pll_get_hw_state,\n\t.get_freq = icl_ddi_tbt_pll_get_freq,\n};\n\nstatic const struct intel_shared_dpll_funcs mg_pll_funcs = {\n\t.enable = mg_pll_enable,\n\t.disable = mg_pll_disable,\n\t.get_hw_state = mg_pll_get_hw_state,\n\t.get_freq = icl_ddi_mg_pll_get_freq,\n};\n\nstatic const struct dpll_info icl_plls[] = {\n\t{ \"DPLL 0\",   &combo_pll_funcs, DPLL_ID_ICL_DPLL0,  0 },\n\t{ \"DPLL 1\",   &combo_pll_funcs, DPLL_ID_ICL_DPLL1,  0 },\n\t{ \"TBT PLL\",  &tbt_pll_funcs, DPLL_ID_ICL_TBTPLL, 0 },\n\t{ \"MG PLL 1\", &mg_pll_funcs, DPLL_ID_ICL_MGPLL1, 0 },\n\t{ \"MG PLL 2\", &mg_pll_funcs, DPLL_ID_ICL_MGPLL2, 0 },\n\t{ \"MG PLL 3\", &mg_pll_funcs, DPLL_ID_ICL_MGPLL3, 0 },\n\t{ \"MG PLL 4\", &mg_pll_funcs, DPLL_ID_ICL_MGPLL4, 0 },\n\t{ },\n};\n\nstatic const struct intel_dpll_mgr icl_pll_mgr = {\n\t.dpll_info = icl_plls,\n\t.compute_dplls = icl_compute_dplls,\n\t.get_dplls = icl_get_dplls,\n\t.put_dplls = icl_put_dplls,\n\t.update_active_dpll = icl_update_active_dpll,\n\t.update_ref_clks = icl_update_dpll_ref_clks,\n\t.dump_hw_state = icl_dump_hw_state,\n};\n\nstatic const struct dpll_info ehl_plls[] = {\n\t{ \"DPLL 0\", &combo_pll_funcs, DPLL_ID_ICL_DPLL0, 0 },\n\t{ \"DPLL 1\", &combo_pll_funcs, DPLL_ID_ICL_DPLL1, 0 },\n\t{ \"DPLL 4\", &combo_pll_funcs, DPLL_ID_EHL_DPLL4, 0 },\n\t{ },\n};\n\nstatic const struct intel_dpll_mgr ehl_pll_mgr = {\n\t.dpll_info = ehl_plls,\n\t.compute_dplls = icl_compute_dplls,\n\t.get_dplls = icl_get_dplls,\n\t.put_dplls = icl_put_dplls,\n\t.update_ref_clks = icl_update_dpll_ref_clks,\n\t.dump_hw_state = icl_dump_hw_state,\n};\n\nstatic const struct intel_shared_dpll_funcs dkl_pll_funcs = {\n\t.enable = mg_pll_enable,\n\t.disable = mg_pll_disable,\n\t.get_hw_state = dkl_pll_get_hw_state,\n\t.get_freq = icl_ddi_mg_pll_get_freq,\n};\n\nstatic const struct dpll_info tgl_plls[] = {\n\t{ \"DPLL 0\", &combo_pll_funcs, DPLL_ID_ICL_DPLL0,  0 },\n\t{ \"DPLL 1\", &combo_pll_funcs, DPLL_ID_ICL_DPLL1,  0 },\n\t{ \"TBT PLL\",  &tbt_pll_funcs, DPLL_ID_ICL_TBTPLL, 0 },\n\t{ \"TC PLL 1\", &dkl_pll_funcs, DPLL_ID_ICL_MGPLL1, 0 },\n\t{ \"TC PLL 2\", &dkl_pll_funcs, DPLL_ID_ICL_MGPLL2, 0 },\n\t{ \"TC PLL 3\", &dkl_pll_funcs, DPLL_ID_ICL_MGPLL3, 0 },\n\t{ \"TC PLL 4\", &dkl_pll_funcs, DPLL_ID_ICL_MGPLL4, 0 },\n\t{ \"TC PLL 5\", &dkl_pll_funcs, DPLL_ID_TGL_MGPLL5, 0 },\n\t{ \"TC PLL 6\", &dkl_pll_funcs, DPLL_ID_TGL_MGPLL6, 0 },\n\t{ },\n};\n\nstatic const struct intel_dpll_mgr tgl_pll_mgr = {\n\t.dpll_info = tgl_plls,\n\t.compute_dplls = icl_compute_dplls,\n\t.get_dplls = icl_get_dplls,\n\t.put_dplls = icl_put_dplls,\n\t.update_active_dpll = icl_update_active_dpll,\n\t.update_ref_clks = icl_update_dpll_ref_clks,\n\t.dump_hw_state = icl_dump_hw_state,\n};\n\nstatic const struct dpll_info rkl_plls[] = {\n\t{ \"DPLL 0\", &combo_pll_funcs, DPLL_ID_ICL_DPLL0, 0 },\n\t{ \"DPLL 1\", &combo_pll_funcs, DPLL_ID_ICL_DPLL1, 0 },\n\t{ \"DPLL 4\", &combo_pll_funcs, DPLL_ID_EHL_DPLL4, 0 },\n\t{ },\n};\n\nstatic const struct intel_dpll_mgr rkl_pll_mgr = {\n\t.dpll_info = rkl_plls,\n\t.compute_dplls = icl_compute_dplls,\n\t.get_dplls = icl_get_dplls,\n\t.put_dplls = icl_put_dplls,\n\t.update_ref_clks = icl_update_dpll_ref_clks,\n\t.dump_hw_state = icl_dump_hw_state,\n};\n\nstatic const struct dpll_info dg1_plls[] = {\n\t{ \"DPLL 0\", &combo_pll_funcs, DPLL_ID_DG1_DPLL0, 0 },\n\t{ \"DPLL 1\", &combo_pll_funcs, DPLL_ID_DG1_DPLL1, 0 },\n\t{ \"DPLL 2\", &combo_pll_funcs, DPLL_ID_DG1_DPLL2, 0 },\n\t{ \"DPLL 3\", &combo_pll_funcs, DPLL_ID_DG1_DPLL3, 0 },\n\t{ },\n};\n\nstatic const struct intel_dpll_mgr dg1_pll_mgr = {\n\t.dpll_info = dg1_plls,\n\t.compute_dplls = icl_compute_dplls,\n\t.get_dplls = icl_get_dplls,\n\t.put_dplls = icl_put_dplls,\n\t.update_ref_clks = icl_update_dpll_ref_clks,\n\t.dump_hw_state = icl_dump_hw_state,\n};\n\nstatic const struct dpll_info adls_plls[] = {\n\t{ \"DPLL 0\", &combo_pll_funcs, DPLL_ID_ICL_DPLL0, 0 },\n\t{ \"DPLL 1\", &combo_pll_funcs, DPLL_ID_ICL_DPLL1, 0 },\n\t{ \"DPLL 2\", &combo_pll_funcs, DPLL_ID_DG1_DPLL2, 0 },\n\t{ \"DPLL 3\", &combo_pll_funcs, DPLL_ID_DG1_DPLL3, 0 },\n\t{ },\n};\n\nstatic const struct intel_dpll_mgr adls_pll_mgr = {\n\t.dpll_info = adls_plls,\n\t.compute_dplls = icl_compute_dplls,\n\t.get_dplls = icl_get_dplls,\n\t.put_dplls = icl_put_dplls,\n\t.update_ref_clks = icl_update_dpll_ref_clks,\n\t.dump_hw_state = icl_dump_hw_state,\n};\n\nstatic const struct dpll_info adlp_plls[] = {\n\t{ \"DPLL 0\", &combo_pll_funcs, DPLL_ID_ICL_DPLL0,  0 },\n\t{ \"DPLL 1\", &combo_pll_funcs, DPLL_ID_ICL_DPLL1,  0 },\n\t{ \"TBT PLL\",  &tbt_pll_funcs, DPLL_ID_ICL_TBTPLL, 0 },\n\t{ \"TC PLL 1\", &dkl_pll_funcs, DPLL_ID_ICL_MGPLL1, 0 },\n\t{ \"TC PLL 2\", &dkl_pll_funcs, DPLL_ID_ICL_MGPLL2, 0 },\n\t{ \"TC PLL 3\", &dkl_pll_funcs, DPLL_ID_ICL_MGPLL3, 0 },\n\t{ \"TC PLL 4\", &dkl_pll_funcs, DPLL_ID_ICL_MGPLL4, 0 },\n\t{ },\n};\n\nstatic const struct intel_dpll_mgr adlp_pll_mgr = {\n\t.dpll_info = adlp_plls,\n\t.compute_dplls = icl_compute_dplls,\n\t.get_dplls = icl_get_dplls,\n\t.put_dplls = icl_put_dplls,\n\t.update_active_dpll = icl_update_active_dpll,\n\t.update_ref_clks = icl_update_dpll_ref_clks,\n\t.dump_hw_state = icl_dump_hw_state,\n};\n\n \nvoid intel_shared_dpll_init(struct drm_i915_private *dev_priv)\n{\n\tconst struct intel_dpll_mgr *dpll_mgr = NULL;\n\tconst struct dpll_info *dpll_info;\n\tint i;\n\n\tmutex_init(&dev_priv->display.dpll.lock);\n\n\tif (DISPLAY_VER(dev_priv) >= 14 || IS_DG2(dev_priv))\n\t\t \n\t\tdpll_mgr = NULL;\n\telse if (IS_ALDERLAKE_P(dev_priv))\n\t\tdpll_mgr = &adlp_pll_mgr;\n\telse if (IS_ALDERLAKE_S(dev_priv))\n\t\tdpll_mgr = &adls_pll_mgr;\n\telse if (IS_DG1(dev_priv))\n\t\tdpll_mgr = &dg1_pll_mgr;\n\telse if (IS_ROCKETLAKE(dev_priv))\n\t\tdpll_mgr = &rkl_pll_mgr;\n\telse if (DISPLAY_VER(dev_priv) >= 12)\n\t\tdpll_mgr = &tgl_pll_mgr;\n\telse if (IS_JASPERLAKE(dev_priv) || IS_ELKHARTLAKE(dev_priv))\n\t\tdpll_mgr = &ehl_pll_mgr;\n\telse if (DISPLAY_VER(dev_priv) >= 11)\n\t\tdpll_mgr = &icl_pll_mgr;\n\telse if (IS_GEMINILAKE(dev_priv) || IS_BROXTON(dev_priv))\n\t\tdpll_mgr = &bxt_pll_mgr;\n\telse if (DISPLAY_VER(dev_priv) == 9)\n\t\tdpll_mgr = &skl_pll_mgr;\n\telse if (HAS_DDI(dev_priv))\n\t\tdpll_mgr = &hsw_pll_mgr;\n\telse if (HAS_PCH_IBX(dev_priv) || HAS_PCH_CPT(dev_priv))\n\t\tdpll_mgr = &pch_pll_mgr;\n\n\tif (!dpll_mgr) {\n\t\tdev_priv->display.dpll.num_shared_dpll = 0;\n\t\treturn;\n\t}\n\n\tdpll_info = dpll_mgr->dpll_info;\n\n\tfor (i = 0; dpll_info[i].name; i++) {\n\t\tif (drm_WARN_ON(&dev_priv->drm,\n\t\t\t\ti >= ARRAY_SIZE(dev_priv->display.dpll.shared_dplls)))\n\t\t\tbreak;\n\n\t\tdrm_WARN_ON(&dev_priv->drm, i != dpll_info[i].id);\n\t\tdev_priv->display.dpll.shared_dplls[i].info = &dpll_info[i];\n\t}\n\n\tdev_priv->display.dpll.mgr = dpll_mgr;\n\tdev_priv->display.dpll.num_shared_dpll = i;\n}\n\n \nint intel_compute_shared_dplls(struct intel_atomic_state *state,\n\t\t\t       struct intel_crtc *crtc,\n\t\t\t       struct intel_encoder *encoder)\n{\n\tstruct drm_i915_private *dev_priv = to_i915(state->base.dev);\n\tconst struct intel_dpll_mgr *dpll_mgr = dev_priv->display.dpll.mgr;\n\n\tif (drm_WARN_ON(&dev_priv->drm, !dpll_mgr))\n\t\treturn -EINVAL;\n\n\treturn dpll_mgr->compute_dplls(state, crtc, encoder);\n}\n\n \nint intel_reserve_shared_dplls(struct intel_atomic_state *state,\n\t\t\t       struct intel_crtc *crtc,\n\t\t\t       struct intel_encoder *encoder)\n{\n\tstruct drm_i915_private *dev_priv = to_i915(state->base.dev);\n\tconst struct intel_dpll_mgr *dpll_mgr = dev_priv->display.dpll.mgr;\n\n\tif (drm_WARN_ON(&dev_priv->drm, !dpll_mgr))\n\t\treturn -EINVAL;\n\n\treturn dpll_mgr->get_dplls(state, crtc, encoder);\n}\n\n \nvoid intel_release_shared_dplls(struct intel_atomic_state *state,\n\t\t\t\tstruct intel_crtc *crtc)\n{\n\tstruct drm_i915_private *dev_priv = to_i915(state->base.dev);\n\tconst struct intel_dpll_mgr *dpll_mgr = dev_priv->display.dpll.mgr;\n\n\t \n\tif (!dpll_mgr)\n\t\treturn;\n\n\tdpll_mgr->put_dplls(state, crtc);\n}\n\n \nvoid intel_update_active_dpll(struct intel_atomic_state *state,\n\t\t\t      struct intel_crtc *crtc,\n\t\t\t      struct intel_encoder *encoder)\n{\n\tstruct drm_i915_private *dev_priv = to_i915(encoder->base.dev);\n\tconst struct intel_dpll_mgr *dpll_mgr = dev_priv->display.dpll.mgr;\n\n\tif (drm_WARN_ON(&dev_priv->drm, !dpll_mgr))\n\t\treturn;\n\n\tdpll_mgr->update_active_dpll(state, crtc, encoder);\n}\n\n \nint intel_dpll_get_freq(struct drm_i915_private *i915,\n\t\t\tconst struct intel_shared_dpll *pll,\n\t\t\tconst struct intel_dpll_hw_state *pll_state)\n{\n\tif (drm_WARN_ON(&i915->drm, !pll->info->funcs->get_freq))\n\t\treturn 0;\n\n\treturn pll->info->funcs->get_freq(i915, pll, pll_state);\n}\n\n \nbool intel_dpll_get_hw_state(struct drm_i915_private *i915,\n\t\t\t     struct intel_shared_dpll *pll,\n\t\t\t     struct intel_dpll_hw_state *hw_state)\n{\n\treturn pll->info->funcs->get_hw_state(i915, pll, hw_state);\n}\n\nstatic void readout_dpll_hw_state(struct drm_i915_private *i915,\n\t\t\t\t  struct intel_shared_dpll *pll)\n{\n\tstruct intel_crtc *crtc;\n\n\tpll->on = intel_dpll_get_hw_state(i915, pll, &pll->state.hw_state);\n\n\tif ((IS_JASPERLAKE(i915) || IS_ELKHARTLAKE(i915)) &&\n\t    pll->on &&\n\t    pll->info->id == DPLL_ID_EHL_DPLL4) {\n\t\tpll->wakeref = intel_display_power_get(i915,\n\t\t\t\t\t\t       POWER_DOMAIN_DC_OFF);\n\t}\n\n\tpll->state.pipe_mask = 0;\n\tfor_each_intel_crtc(&i915->drm, crtc) {\n\t\tstruct intel_crtc_state *crtc_state =\n\t\t\tto_intel_crtc_state(crtc->base.state);\n\n\t\tif (crtc_state->hw.active && crtc_state->shared_dpll == pll)\n\t\t\tintel_reference_shared_dpll_crtc(crtc, pll, &pll->state);\n\t}\n\tpll->active_mask = pll->state.pipe_mask;\n\n\tdrm_dbg_kms(&i915->drm,\n\t\t    \"%s hw state readout: pipe_mask 0x%x, on %i\\n\",\n\t\t    pll->info->name, pll->state.pipe_mask, pll->on);\n}\n\nvoid intel_dpll_update_ref_clks(struct drm_i915_private *i915)\n{\n\tif (i915->display.dpll.mgr && i915->display.dpll.mgr->update_ref_clks)\n\t\ti915->display.dpll.mgr->update_ref_clks(i915);\n}\n\nvoid intel_dpll_readout_hw_state(struct drm_i915_private *i915)\n{\n\tint i;\n\n\tfor (i = 0; i < i915->display.dpll.num_shared_dpll; i++)\n\t\treadout_dpll_hw_state(i915, &i915->display.dpll.shared_dplls[i]);\n}\n\nstatic void sanitize_dpll_state(struct drm_i915_private *i915,\n\t\t\t\tstruct intel_shared_dpll *pll)\n{\n\tif (!pll->on)\n\t\treturn;\n\n\tadlp_cmtg_clock_gating_wa(i915, pll);\n\n\tif (pll->active_mask)\n\t\treturn;\n\n\tdrm_dbg_kms(&i915->drm,\n\t\t    \"%s enabled but not in use, disabling\\n\",\n\t\t    pll->info->name);\n\n\tpll->info->funcs->disable(i915, pll);\n\tpll->on = false;\n}\n\nvoid intel_dpll_sanitize_state(struct drm_i915_private *i915)\n{\n\tint i;\n\n\tfor (i = 0; i < i915->display.dpll.num_shared_dpll; i++)\n\t\tsanitize_dpll_state(i915, &i915->display.dpll.shared_dplls[i]);\n}\n\n \nvoid intel_dpll_dump_hw_state(struct drm_i915_private *dev_priv,\n\t\t\t      const struct intel_dpll_hw_state *hw_state)\n{\n\tif (dev_priv->display.dpll.mgr) {\n\t\tdev_priv->display.dpll.mgr->dump_hw_state(dev_priv, hw_state);\n\t} else {\n\t\t \n\t\tdrm_dbg_kms(&dev_priv->drm,\n\t\t\t    \"dpll_hw_state: dpll: 0x%x, dpll_md: 0x%x, \"\n\t\t\t    \"fp0: 0x%x, fp1: 0x%x\\n\",\n\t\t\t    hw_state->dpll,\n\t\t\t    hw_state->dpll_md,\n\t\t\t    hw_state->fp0,\n\t\t\t    hw_state->fp1);\n\t}\n}\n\nstatic void\nverify_single_dpll_state(struct drm_i915_private *dev_priv,\n\t\t\t struct intel_shared_dpll *pll,\n\t\t\t struct intel_crtc *crtc,\n\t\t\t struct intel_crtc_state *new_crtc_state)\n{\n\tstruct intel_dpll_hw_state dpll_hw_state;\n\tu8 pipe_mask;\n\tbool active;\n\n\tmemset(&dpll_hw_state, 0, sizeof(dpll_hw_state));\n\n\tdrm_dbg_kms(&dev_priv->drm, \"%s\\n\", pll->info->name);\n\n\tactive = intel_dpll_get_hw_state(dev_priv, pll, &dpll_hw_state);\n\n\tif (!(pll->info->flags & INTEL_DPLL_ALWAYS_ON)) {\n\t\tI915_STATE_WARN(dev_priv, !pll->on && pll->active_mask,\n\t\t\t\t\"pll in active use but not on in sw tracking\\n\");\n\t\tI915_STATE_WARN(dev_priv, pll->on && !pll->active_mask,\n\t\t\t\t\"pll is on but not used by any active pipe\\n\");\n\t\tI915_STATE_WARN(dev_priv, pll->on != active,\n\t\t\t\t\"pll on state mismatch (expected %i, found %i)\\n\",\n\t\t\t\tpll->on, active);\n\t}\n\n\tif (!crtc) {\n\t\tI915_STATE_WARN(dev_priv,\n\t\t\t\tpll->active_mask & ~pll->state.pipe_mask,\n\t\t\t\t\"more active pll users than references: 0x%x vs 0x%x\\n\",\n\t\t\t\tpll->active_mask, pll->state.pipe_mask);\n\n\t\treturn;\n\t}\n\n\tpipe_mask = BIT(crtc->pipe);\n\n\tif (new_crtc_state->hw.active)\n\t\tI915_STATE_WARN(dev_priv, !(pll->active_mask & pipe_mask),\n\t\t\t\t\"pll active mismatch (expected pipe %c in active mask 0x%x)\\n\",\n\t\t\t\tpipe_name(crtc->pipe), pll->active_mask);\n\telse\n\t\tI915_STATE_WARN(dev_priv, pll->active_mask & pipe_mask,\n\t\t\t\t\"pll active mismatch (didn't expect pipe %c in active mask 0x%x)\\n\",\n\t\t\t\tpipe_name(crtc->pipe), pll->active_mask);\n\n\tI915_STATE_WARN(dev_priv, !(pll->state.pipe_mask & pipe_mask),\n\t\t\t\"pll enabled crtcs mismatch (expected 0x%x in 0x%x)\\n\",\n\t\t\tpipe_mask, pll->state.pipe_mask);\n\n\tI915_STATE_WARN(dev_priv,\n\t\t\tpll->on && memcmp(&pll->state.hw_state, &dpll_hw_state,\n\t\t\t\t\t  sizeof(dpll_hw_state)),\n\t\t\t\"pll hw state mismatch\\n\");\n}\n\nvoid intel_shared_dpll_state_verify(struct intel_crtc *crtc,\n\t\t\t\t    struct intel_crtc_state *old_crtc_state,\n\t\t\t\t    struct intel_crtc_state *new_crtc_state)\n{\n\tstruct drm_i915_private *dev_priv = to_i915(crtc->base.dev);\n\n\tif (new_crtc_state->shared_dpll)\n\t\tverify_single_dpll_state(dev_priv, new_crtc_state->shared_dpll,\n\t\t\t\t\t crtc, new_crtc_state);\n\n\tif (old_crtc_state->shared_dpll &&\n\t    old_crtc_state->shared_dpll != new_crtc_state->shared_dpll) {\n\t\tu8 pipe_mask = BIT(crtc->pipe);\n\t\tstruct intel_shared_dpll *pll = old_crtc_state->shared_dpll;\n\n\t\tI915_STATE_WARN(dev_priv, pll->active_mask & pipe_mask,\n\t\t\t\t\"pll active mismatch (didn't expect pipe %c in active mask (0x%x))\\n\",\n\t\t\t\tpipe_name(crtc->pipe), pll->active_mask);\n\t\tI915_STATE_WARN(dev_priv, pll->state.pipe_mask & pipe_mask,\n\t\t\t\t\"pll enabled crtcs mismatch (found %x in enabled mask (0x%x))\\n\",\n\t\t\t\tpipe_name(crtc->pipe), pll->state.pipe_mask);\n\t}\n}\n\nvoid intel_shared_dpll_verify_disabled(struct drm_i915_private *i915)\n{\n\tint i;\n\n\tfor (i = 0; i < i915->display.dpll.num_shared_dpll; i++)\n\t\tverify_single_dpll_state(i915, &i915->display.dpll.shared_dplls[i],\n\t\t\t\t\t NULL, NULL);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}