{
  "module_name": "intel_ddi.c",
  "hash_id": "152375c7db0dff9537a951d6760ab1c8e464c93bf2f626058d4b559a55be26fa",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/i915/display/intel_ddi.c",
  "human_readable_source": " \n\n#include <linux/string_helpers.h>\n\n#include <drm/display/drm_scdc_helper.h>\n#include <drm/drm_privacy_screen_consumer.h>\n\n#include \"i915_drv.h\"\n#include \"i915_reg.h\"\n#include \"icl_dsi.h\"\n#include \"intel_audio.h\"\n#include \"intel_audio_regs.h\"\n#include \"intel_backlight.h\"\n#include \"intel_combo_phy.h\"\n#include \"intel_combo_phy_regs.h\"\n#include \"intel_connector.h\"\n#include \"intel_crtc.h\"\n#include \"intel_cx0_phy.h\"\n#include \"intel_cx0_phy_regs.h\"\n#include \"intel_ddi.h\"\n#include \"intel_ddi_buf_trans.h\"\n#include \"intel_de.h\"\n#include \"intel_display_power.h\"\n#include \"intel_display_types.h\"\n#include \"intel_dkl_phy.h\"\n#include \"intel_dkl_phy_regs.h\"\n#include \"intel_dp.h\"\n#include \"intel_dp_aux.h\"\n#include \"intel_dp_link_training.h\"\n#include \"intel_dp_mst.h\"\n#include \"intel_dpio_phy.h\"\n#include \"intel_dsi.h\"\n#include \"intel_fdi.h\"\n#include \"intel_fifo_underrun.h\"\n#include \"intel_gmbus.h\"\n#include \"intel_hdcp.h\"\n#include \"intel_hdmi.h\"\n#include \"intel_hotplug.h\"\n#include \"intel_hti.h\"\n#include \"intel_lspcon.h\"\n#include \"intel_mg_phy_regs.h\"\n#include \"intel_modeset_lock.h\"\n#include \"intel_pps.h\"\n#include \"intel_psr.h\"\n#include \"intel_quirks.h\"\n#include \"intel_snps_phy.h\"\n#include \"intel_tc.h\"\n#include \"intel_vdsc.h\"\n#include \"intel_vdsc_regs.h\"\n#include \"skl_scaler.h\"\n#include \"skl_universal_plane.h\"\n\nstatic const u8 index_to_dp_signal_levels[] = {\n\t[0] = DP_TRAIN_VOLTAGE_SWING_LEVEL_0 | DP_TRAIN_PRE_EMPH_LEVEL_0,\n\t[1] = DP_TRAIN_VOLTAGE_SWING_LEVEL_0 | DP_TRAIN_PRE_EMPH_LEVEL_1,\n\t[2] = DP_TRAIN_VOLTAGE_SWING_LEVEL_0 | DP_TRAIN_PRE_EMPH_LEVEL_2,\n\t[3] = DP_TRAIN_VOLTAGE_SWING_LEVEL_0 | DP_TRAIN_PRE_EMPH_LEVEL_3,\n\t[4] = DP_TRAIN_VOLTAGE_SWING_LEVEL_1 | DP_TRAIN_PRE_EMPH_LEVEL_0,\n\t[5] = DP_TRAIN_VOLTAGE_SWING_LEVEL_1 | DP_TRAIN_PRE_EMPH_LEVEL_1,\n\t[6] = DP_TRAIN_VOLTAGE_SWING_LEVEL_1 | DP_TRAIN_PRE_EMPH_LEVEL_2,\n\t[7] = DP_TRAIN_VOLTAGE_SWING_LEVEL_2 | DP_TRAIN_PRE_EMPH_LEVEL_0,\n\t[8] = DP_TRAIN_VOLTAGE_SWING_LEVEL_2 | DP_TRAIN_PRE_EMPH_LEVEL_1,\n\t[9] = DP_TRAIN_VOLTAGE_SWING_LEVEL_3 | DP_TRAIN_PRE_EMPH_LEVEL_0,\n};\n\nstatic int intel_ddi_hdmi_level(struct intel_encoder *encoder,\n\t\t\t\tconst struct intel_ddi_buf_trans *trans)\n{\n\tint level;\n\n\tlevel = intel_bios_hdmi_level_shift(encoder->devdata);\n\tif (level < 0)\n\t\tlevel = trans->hdmi_default_entry;\n\n\treturn level;\n}\n\nstatic bool has_buf_trans_select(struct drm_i915_private *i915)\n{\n\treturn DISPLAY_VER(i915) < 10 && !IS_BROXTON(i915);\n}\n\nstatic bool has_iboost(struct drm_i915_private *i915)\n{\n\treturn DISPLAY_VER(i915) == 9 && !IS_BROXTON(i915);\n}\n\n \nvoid hsw_prepare_dp_ddi_buffers(struct intel_encoder *encoder,\n\t\t\t\tconst struct intel_crtc_state *crtc_state)\n{\n\tstruct drm_i915_private *dev_priv = to_i915(encoder->base.dev);\n\tu32 iboost_bit = 0;\n\tint i, n_entries;\n\tenum port port = encoder->port;\n\tconst struct intel_ddi_buf_trans *trans;\n\n\ttrans = encoder->get_buf_trans(encoder, crtc_state, &n_entries);\n\tif (drm_WARN_ON_ONCE(&dev_priv->drm, !trans))\n\t\treturn;\n\n\t \n\tif (has_iboost(dev_priv) &&\n\t    intel_bios_dp_boost_level(encoder->devdata))\n\t\tiboost_bit = DDI_BUF_BALANCE_LEG_ENABLE;\n\n\tfor (i = 0; i < n_entries; i++) {\n\t\tintel_de_write(dev_priv, DDI_BUF_TRANS_LO(port, i),\n\t\t\t       trans->entries[i].hsw.trans1 | iboost_bit);\n\t\tintel_de_write(dev_priv, DDI_BUF_TRANS_HI(port, i),\n\t\t\t       trans->entries[i].hsw.trans2);\n\t}\n}\n\n \nstatic void hsw_prepare_hdmi_ddi_buffers(struct intel_encoder *encoder,\n\t\t\t\t\t const struct intel_crtc_state *crtc_state)\n{\n\tstruct drm_i915_private *dev_priv = to_i915(encoder->base.dev);\n\tint level = intel_ddi_level(encoder, crtc_state, 0);\n\tu32 iboost_bit = 0;\n\tint n_entries;\n\tenum port port = encoder->port;\n\tconst struct intel_ddi_buf_trans *trans;\n\n\ttrans = encoder->get_buf_trans(encoder, crtc_state, &n_entries);\n\tif (drm_WARN_ON_ONCE(&dev_priv->drm, !trans))\n\t\treturn;\n\n\t \n\tif (has_iboost(dev_priv) &&\n\t    intel_bios_hdmi_boost_level(encoder->devdata))\n\t\tiboost_bit = DDI_BUF_BALANCE_LEG_ENABLE;\n\n\t \n\tintel_de_write(dev_priv, DDI_BUF_TRANS_LO(port, 9),\n\t\t       trans->entries[level].hsw.trans1 | iboost_bit);\n\tintel_de_write(dev_priv, DDI_BUF_TRANS_HI(port, 9),\n\t\t       trans->entries[level].hsw.trans2);\n}\n\nstatic void mtl_wait_ddi_buf_idle(struct drm_i915_private *i915, enum port port)\n{\n\tint ret;\n\n\t \n\tret = wait_for_us((intel_de_read(i915, XELPDP_PORT_BUF_CTL1(port)) &\n\t\t\t   XELPDP_PORT_BUF_PHY_IDLE), 10000);\n\tif (ret)\n\t\tdrm_err(&i915->drm, \"Timeout waiting for DDI BUF %c to get idle\\n\",\n\t\t\tport_name(port));\n}\n\nvoid intel_wait_ddi_buf_idle(struct drm_i915_private *dev_priv,\n\t\t\t     enum port port)\n{\n\tif (IS_BROXTON(dev_priv)) {\n\t\tudelay(16);\n\t\treturn;\n\t}\n\n\tif (wait_for_us((intel_de_read(dev_priv, DDI_BUF_CTL(port)) &\n\t\t\t DDI_BUF_IS_IDLE), 8))\n\t\tdrm_err(&dev_priv->drm, \"Timeout waiting for DDI BUF %c to get idle\\n\",\n\t\t\tport_name(port));\n}\n\nstatic void intel_wait_ddi_buf_active(struct drm_i915_private *dev_priv,\n\t\t\t\t      enum port port)\n{\n\tenum phy phy = intel_port_to_phy(dev_priv, port);\n\tint timeout_us;\n\tint ret;\n\n\t \n\tif (DISPLAY_VER(dev_priv) < 10) {\n\t\tusleep_range(518, 1000);\n\t\treturn;\n\t}\n\n\tif (DISPLAY_VER(dev_priv) >= 14) {\n\t\ttimeout_us = 10000;\n\t} else if (IS_DG2(dev_priv)) {\n\t\ttimeout_us = 1200;\n\t} else if (DISPLAY_VER(dev_priv) >= 12) {\n\t\tif (intel_phy_is_tc(dev_priv, phy))\n\t\t\ttimeout_us = 3000;\n\t\telse\n\t\t\ttimeout_us = 1000;\n\t} else {\n\t\ttimeout_us = 500;\n\t}\n\n\tif (DISPLAY_VER(dev_priv) >= 14)\n\t\tret = _wait_for(!(intel_de_read(dev_priv, XELPDP_PORT_BUF_CTL1(port)) & XELPDP_PORT_BUF_PHY_IDLE),\n\t\t\t\ttimeout_us, 10, 10);\n\telse\n\t\tret = _wait_for(!(intel_de_read(dev_priv, DDI_BUF_CTL(port)) & DDI_BUF_IS_IDLE),\n\t\t\t\ttimeout_us, 10, 10);\n\n\tif (ret)\n\t\tdrm_err(&dev_priv->drm, \"Timeout waiting for DDI BUF %c to get active\\n\",\n\t\t\tport_name(port));\n}\n\nstatic u32 hsw_pll_to_ddi_pll_sel(const struct intel_shared_dpll *pll)\n{\n\tswitch (pll->info->id) {\n\tcase DPLL_ID_WRPLL1:\n\t\treturn PORT_CLK_SEL_WRPLL1;\n\tcase DPLL_ID_WRPLL2:\n\t\treturn PORT_CLK_SEL_WRPLL2;\n\tcase DPLL_ID_SPLL:\n\t\treturn PORT_CLK_SEL_SPLL;\n\tcase DPLL_ID_LCPLL_810:\n\t\treturn PORT_CLK_SEL_LCPLL_810;\n\tcase DPLL_ID_LCPLL_1350:\n\t\treturn PORT_CLK_SEL_LCPLL_1350;\n\tcase DPLL_ID_LCPLL_2700:\n\t\treturn PORT_CLK_SEL_LCPLL_2700;\n\tdefault:\n\t\tMISSING_CASE(pll->info->id);\n\t\treturn PORT_CLK_SEL_NONE;\n\t}\n}\n\nstatic u32 icl_pll_to_ddi_clk_sel(struct intel_encoder *encoder,\n\t\t\t\t  const struct intel_crtc_state *crtc_state)\n{\n\tconst struct intel_shared_dpll *pll = crtc_state->shared_dpll;\n\tint clock = crtc_state->port_clock;\n\tconst enum intel_dpll_id id = pll->info->id;\n\n\tswitch (id) {\n\tdefault:\n\t\t \n\t\tMISSING_CASE(id);\n\t\treturn DDI_CLK_SEL_NONE;\n\tcase DPLL_ID_ICL_TBTPLL:\n\t\tswitch (clock) {\n\t\tcase 162000:\n\t\t\treturn DDI_CLK_SEL_TBT_162;\n\t\tcase 270000:\n\t\t\treturn DDI_CLK_SEL_TBT_270;\n\t\tcase 540000:\n\t\t\treturn DDI_CLK_SEL_TBT_540;\n\t\tcase 810000:\n\t\t\treturn DDI_CLK_SEL_TBT_810;\n\t\tdefault:\n\t\t\tMISSING_CASE(clock);\n\t\t\treturn DDI_CLK_SEL_NONE;\n\t\t}\n\tcase DPLL_ID_ICL_MGPLL1:\n\tcase DPLL_ID_ICL_MGPLL2:\n\tcase DPLL_ID_ICL_MGPLL3:\n\tcase DPLL_ID_ICL_MGPLL4:\n\tcase DPLL_ID_TGL_MGPLL5:\n\tcase DPLL_ID_TGL_MGPLL6:\n\t\treturn DDI_CLK_SEL_MG;\n\t}\n}\n\nstatic u32 ddi_buf_phy_link_rate(int port_clock)\n{\n\tswitch (port_clock) {\n\tcase 162000:\n\t\treturn DDI_BUF_PHY_LINK_RATE(0);\n\tcase 216000:\n\t\treturn DDI_BUF_PHY_LINK_RATE(4);\n\tcase 243000:\n\t\treturn DDI_BUF_PHY_LINK_RATE(5);\n\tcase 270000:\n\t\treturn DDI_BUF_PHY_LINK_RATE(1);\n\tcase 324000:\n\t\treturn DDI_BUF_PHY_LINK_RATE(6);\n\tcase 432000:\n\t\treturn DDI_BUF_PHY_LINK_RATE(7);\n\tcase 540000:\n\t\treturn DDI_BUF_PHY_LINK_RATE(2);\n\tcase 810000:\n\t\treturn DDI_BUF_PHY_LINK_RATE(3);\n\tdefault:\n\t\tMISSING_CASE(port_clock);\n\t\treturn DDI_BUF_PHY_LINK_RATE(0);\n\t}\n}\n\nstatic void intel_ddi_init_dp_buf_reg(struct intel_encoder *encoder,\n\t\t\t\t      const struct intel_crtc_state *crtc_state)\n{\n\tstruct drm_i915_private *i915 = to_i915(encoder->base.dev);\n\tstruct intel_dp *intel_dp = enc_to_intel_dp(encoder);\n\tstruct intel_digital_port *dig_port = enc_to_dig_port(encoder);\n\tenum phy phy = intel_port_to_phy(i915, encoder->port);\n\n\t \n\tintel_dp->DP = dig_port->saved_port_bits |\n\t\tDDI_PORT_WIDTH(crtc_state->lane_count) |\n\t\tDDI_BUF_TRANS_SELECT(0);\n\n\tif (DISPLAY_VER(i915) >= 14) {\n\t\tif (intel_dp_is_uhbr(crtc_state))\n\t\t\tintel_dp->DP |= DDI_BUF_PORT_DATA_40BIT;\n\t\telse\n\t\t\tintel_dp->DP |= DDI_BUF_PORT_DATA_10BIT;\n\t}\n\n\tif (IS_ALDERLAKE_P(i915) && intel_phy_is_tc(i915, phy)) {\n\t\tintel_dp->DP |= ddi_buf_phy_link_rate(crtc_state->port_clock);\n\t\tif (!intel_tc_port_in_tbt_alt_mode(dig_port))\n\t\t\tintel_dp->DP |= DDI_BUF_CTL_TC_PHY_OWNERSHIP;\n\t}\n}\n\nstatic int icl_calc_tbt_pll_link(struct drm_i915_private *dev_priv,\n\t\t\t\t enum port port)\n{\n\tu32 val = intel_de_read(dev_priv, DDI_CLK_SEL(port)) & DDI_CLK_SEL_MASK;\n\n\tswitch (val) {\n\tcase DDI_CLK_SEL_NONE:\n\t\treturn 0;\n\tcase DDI_CLK_SEL_TBT_162:\n\t\treturn 162000;\n\tcase DDI_CLK_SEL_TBT_270:\n\t\treturn 270000;\n\tcase DDI_CLK_SEL_TBT_540:\n\t\treturn 540000;\n\tcase DDI_CLK_SEL_TBT_810:\n\t\treturn 810000;\n\tdefault:\n\t\tMISSING_CASE(val);\n\t\treturn 0;\n\t}\n}\n\nstatic void ddi_dotclock_get(struct intel_crtc_state *pipe_config)\n{\n\t \n\tif (pipe_config->has_pch_encoder)\n\t\treturn;\n\n\tpipe_config->hw.adjusted_mode.crtc_clock =\n\t\tintel_crtc_dotclock(pipe_config);\n}\n\nvoid intel_ddi_set_dp_msa(const struct intel_crtc_state *crtc_state,\n\t\t\t  const struct drm_connector_state *conn_state)\n{\n\tstruct intel_crtc *crtc = to_intel_crtc(crtc_state->uapi.crtc);\n\tstruct drm_i915_private *dev_priv = to_i915(crtc->base.dev);\n\tenum transcoder cpu_transcoder = crtc_state->cpu_transcoder;\n\tu32 temp;\n\n\tif (!intel_crtc_has_dp_encoder(crtc_state))\n\t\treturn;\n\n\tdrm_WARN_ON(&dev_priv->drm, transcoder_is_dsi(cpu_transcoder));\n\n\ttemp = DP_MSA_MISC_SYNC_CLOCK;\n\n\tswitch (crtc_state->pipe_bpp) {\n\tcase 18:\n\t\ttemp |= DP_MSA_MISC_6_BPC;\n\t\tbreak;\n\tcase 24:\n\t\ttemp |= DP_MSA_MISC_8_BPC;\n\t\tbreak;\n\tcase 30:\n\t\ttemp |= DP_MSA_MISC_10_BPC;\n\t\tbreak;\n\tcase 36:\n\t\ttemp |= DP_MSA_MISC_12_BPC;\n\t\tbreak;\n\tdefault:\n\t\tMISSING_CASE(crtc_state->pipe_bpp);\n\t\tbreak;\n\t}\n\n\t \n\tdrm_WARN_ON(&dev_priv->drm, crtc_state->limited_color_range &&\n\t\t    crtc_state->output_format != INTEL_OUTPUT_FORMAT_RGB);\n\n\tif (crtc_state->limited_color_range)\n\t\ttemp |= DP_MSA_MISC_COLOR_CEA_RGB;\n\n\t \n\tif (crtc_state->output_format == INTEL_OUTPUT_FORMAT_YCBCR444)\n\t\ttemp |= DP_MSA_MISC_COLOR_YCBCR_444_BT709;\n\n\t \n\tif (intel_dp_needs_vsc_sdp(crtc_state, conn_state))\n\t\ttemp |= DP_MSA_MISC_COLOR_VSC_SDP;\n\n\tintel_de_write(dev_priv, TRANS_MSA_MISC(cpu_transcoder), temp);\n}\n\nstatic u32 bdw_trans_port_sync_master_select(enum transcoder master_transcoder)\n{\n\tif (master_transcoder == TRANSCODER_EDP)\n\t\treturn 0;\n\telse\n\t\treturn master_transcoder + 1;\n}\n\nstatic void\nintel_ddi_config_transcoder_dp2(struct intel_encoder *encoder,\n\t\t\t\tconst struct intel_crtc_state *crtc_state)\n{\n\tstruct drm_i915_private *i915 = to_i915(encoder->base.dev);\n\tenum transcoder cpu_transcoder = crtc_state->cpu_transcoder;\n\tu32 val = 0;\n\n\tif (intel_dp_is_uhbr(crtc_state))\n\t\tval = TRANS_DP2_128B132B_CHANNEL_CODING;\n\n\tintel_de_write(i915, TRANS_DP2_CTL(cpu_transcoder), val);\n}\n\n \nstatic u32\nintel_ddi_transcoder_func_reg_val_get(struct intel_encoder *encoder,\n\t\t\t\t      const struct intel_crtc_state *crtc_state)\n{\n\tstruct intel_crtc *crtc = to_intel_crtc(crtc_state->uapi.crtc);\n\tstruct drm_i915_private *dev_priv = to_i915(crtc->base.dev);\n\tenum pipe pipe = crtc->pipe;\n\tenum transcoder cpu_transcoder = crtc_state->cpu_transcoder;\n\tenum port port = encoder->port;\n\tu32 temp;\n\n\t \n\ttemp = TRANS_DDI_FUNC_ENABLE;\n\tif (DISPLAY_VER(dev_priv) >= 12)\n\t\ttemp |= TGL_TRANS_DDI_SELECT_PORT(port);\n\telse\n\t\ttemp |= TRANS_DDI_SELECT_PORT(port);\n\n\tswitch (crtc_state->pipe_bpp) {\n\tdefault:\n\t\tMISSING_CASE(crtc_state->pipe_bpp);\n\t\tfallthrough;\n\tcase 18:\n\t\ttemp |= TRANS_DDI_BPC_6;\n\t\tbreak;\n\tcase 24:\n\t\ttemp |= TRANS_DDI_BPC_8;\n\t\tbreak;\n\tcase 30:\n\t\ttemp |= TRANS_DDI_BPC_10;\n\t\tbreak;\n\tcase 36:\n\t\ttemp |= TRANS_DDI_BPC_12;\n\t\tbreak;\n\t}\n\n\tif (crtc_state->hw.adjusted_mode.flags & DRM_MODE_FLAG_PVSYNC)\n\t\ttemp |= TRANS_DDI_PVSYNC;\n\tif (crtc_state->hw.adjusted_mode.flags & DRM_MODE_FLAG_PHSYNC)\n\t\ttemp |= TRANS_DDI_PHSYNC;\n\n\tif (cpu_transcoder == TRANSCODER_EDP) {\n\t\tswitch (pipe) {\n\t\tdefault:\n\t\t\tMISSING_CASE(pipe);\n\t\t\tfallthrough;\n\t\tcase PIPE_A:\n\t\t\t \n\t\t\tif (crtc_state->pch_pfit.force_thru)\n\t\t\t\ttemp |= TRANS_DDI_EDP_INPUT_A_ONOFF;\n\t\t\telse\n\t\t\t\ttemp |= TRANS_DDI_EDP_INPUT_A_ON;\n\t\t\tbreak;\n\t\tcase PIPE_B:\n\t\t\ttemp |= TRANS_DDI_EDP_INPUT_B_ONOFF;\n\t\t\tbreak;\n\t\tcase PIPE_C:\n\t\t\ttemp |= TRANS_DDI_EDP_INPUT_C_ONOFF;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (intel_crtc_has_type(crtc_state, INTEL_OUTPUT_HDMI)) {\n\t\tif (crtc_state->has_hdmi_sink)\n\t\t\ttemp |= TRANS_DDI_MODE_SELECT_HDMI;\n\t\telse\n\t\t\ttemp |= TRANS_DDI_MODE_SELECT_DVI;\n\n\t\tif (crtc_state->hdmi_scrambling)\n\t\t\ttemp |= TRANS_DDI_HDMI_SCRAMBLING;\n\t\tif (crtc_state->hdmi_high_tmds_clock_ratio)\n\t\t\ttemp |= TRANS_DDI_HIGH_TMDS_CHAR_RATE;\n\t\tif (DISPLAY_VER(dev_priv) >= 14)\n\t\t\ttemp |= TRANS_DDI_PORT_WIDTH(crtc_state->lane_count);\n\t} else if (intel_crtc_has_type(crtc_state, INTEL_OUTPUT_ANALOG)) {\n\t\ttemp |= TRANS_DDI_MODE_SELECT_FDI_OR_128B132B;\n\t\ttemp |= (crtc_state->fdi_lanes - 1) << 1;\n\t} else if (intel_crtc_has_type(crtc_state, INTEL_OUTPUT_DP_MST)) {\n\t\tif (intel_dp_is_uhbr(crtc_state))\n\t\t\ttemp |= TRANS_DDI_MODE_SELECT_FDI_OR_128B132B;\n\t\telse\n\t\t\ttemp |= TRANS_DDI_MODE_SELECT_DP_MST;\n\t\ttemp |= DDI_PORT_WIDTH(crtc_state->lane_count);\n\n\t\tif (DISPLAY_VER(dev_priv) >= 12) {\n\t\t\tenum transcoder master;\n\n\t\t\tmaster = crtc_state->mst_master_transcoder;\n\t\t\tdrm_WARN_ON(&dev_priv->drm,\n\t\t\t\t    master == INVALID_TRANSCODER);\n\t\t\ttemp |= TRANS_DDI_MST_TRANSPORT_SELECT(master);\n\t\t}\n\t} else {\n\t\ttemp |= TRANS_DDI_MODE_SELECT_DP_SST;\n\t\ttemp |= DDI_PORT_WIDTH(crtc_state->lane_count);\n\t}\n\n\tif (IS_DISPLAY_VER(dev_priv, 8, 10) &&\n\t    crtc_state->master_transcoder != INVALID_TRANSCODER) {\n\t\tu8 master_select =\n\t\t\tbdw_trans_port_sync_master_select(crtc_state->master_transcoder);\n\n\t\ttemp |= TRANS_DDI_PORT_SYNC_ENABLE |\n\t\t\tTRANS_DDI_PORT_SYNC_MASTER_SELECT(master_select);\n\t}\n\n\treturn temp;\n}\n\nvoid intel_ddi_enable_transcoder_func(struct intel_encoder *encoder,\n\t\t\t\t      const struct intel_crtc_state *crtc_state)\n{\n\tstruct intel_crtc *crtc = to_intel_crtc(crtc_state->uapi.crtc);\n\tstruct drm_i915_private *dev_priv = to_i915(crtc->base.dev);\n\tenum transcoder cpu_transcoder = crtc_state->cpu_transcoder;\n\n\tif (DISPLAY_VER(dev_priv) >= 11) {\n\t\tenum transcoder master_transcoder = crtc_state->master_transcoder;\n\t\tu32 ctl2 = 0;\n\n\t\tif (master_transcoder != INVALID_TRANSCODER) {\n\t\t\tu8 master_select =\n\t\t\t\tbdw_trans_port_sync_master_select(master_transcoder);\n\n\t\t\tctl2 |= PORT_SYNC_MODE_ENABLE |\n\t\t\t\tPORT_SYNC_MODE_MASTER_SELECT(master_select);\n\t\t}\n\n\t\tintel_de_write(dev_priv,\n\t\t\t       TRANS_DDI_FUNC_CTL2(cpu_transcoder), ctl2);\n\t}\n\n\tintel_de_write(dev_priv, TRANS_DDI_FUNC_CTL(cpu_transcoder),\n\t\t       intel_ddi_transcoder_func_reg_val_get(encoder,\n\t\t\t\t\t\t\t     crtc_state));\n}\n\n \nstatic void\nintel_ddi_config_transcoder_func(struct intel_encoder *encoder,\n\t\t\t\t const struct intel_crtc_state *crtc_state)\n{\n\tstruct intel_crtc *crtc = to_intel_crtc(crtc_state->uapi.crtc);\n\tstruct drm_i915_private *dev_priv = to_i915(crtc->base.dev);\n\tenum transcoder cpu_transcoder = crtc_state->cpu_transcoder;\n\tu32 ctl;\n\n\tctl = intel_ddi_transcoder_func_reg_val_get(encoder, crtc_state);\n\tctl &= ~TRANS_DDI_FUNC_ENABLE;\n\tintel_de_write(dev_priv, TRANS_DDI_FUNC_CTL(cpu_transcoder), ctl);\n}\n\nvoid intel_ddi_disable_transcoder_func(const struct intel_crtc_state *crtc_state)\n{\n\tstruct intel_crtc *crtc = to_intel_crtc(crtc_state->uapi.crtc);\n\tstruct drm_i915_private *dev_priv = to_i915(crtc->base.dev);\n\tenum transcoder cpu_transcoder = crtc_state->cpu_transcoder;\n\tu32 ctl;\n\n\tif (DISPLAY_VER(dev_priv) >= 11)\n\t\tintel_de_write(dev_priv,\n\t\t\t       TRANS_DDI_FUNC_CTL2(cpu_transcoder), 0);\n\n\tctl = intel_de_read(dev_priv, TRANS_DDI_FUNC_CTL(cpu_transcoder));\n\n\tdrm_WARN_ON(crtc->base.dev, ctl & TRANS_DDI_HDCP_SIGNALLING);\n\n\tctl &= ~TRANS_DDI_FUNC_ENABLE;\n\n\tif (IS_DISPLAY_VER(dev_priv, 8, 10))\n\t\tctl &= ~(TRANS_DDI_PORT_SYNC_ENABLE |\n\t\t\t TRANS_DDI_PORT_SYNC_MASTER_SELECT_MASK);\n\n\tif (DISPLAY_VER(dev_priv) >= 12) {\n\t\tif (!intel_dp_mst_is_master_trans(crtc_state)) {\n\t\t\tctl &= ~(TGL_TRANS_DDI_PORT_MASK |\n\t\t\t\t TRANS_DDI_MODE_SELECT_MASK);\n\t\t}\n\t} else {\n\t\tctl &= ~(TRANS_DDI_PORT_MASK | TRANS_DDI_MODE_SELECT_MASK);\n\t}\n\n\tintel_de_write(dev_priv, TRANS_DDI_FUNC_CTL(cpu_transcoder), ctl);\n\n\tif (intel_has_quirk(dev_priv, QUIRK_INCREASE_DDI_DISABLED_TIME) &&\n\t    intel_crtc_has_type(crtc_state, INTEL_OUTPUT_HDMI)) {\n\t\tdrm_dbg_kms(&dev_priv->drm,\n\t\t\t    \"Quirk Increase DDI disabled time\\n\");\n\t\t \n\t\tmsleep(100);\n\t}\n}\n\nint intel_ddi_toggle_hdcp_bits(struct intel_encoder *intel_encoder,\n\t\t\t       enum transcoder cpu_transcoder,\n\t\t\t       bool enable, u32 hdcp_mask)\n{\n\tstruct drm_device *dev = intel_encoder->base.dev;\n\tstruct drm_i915_private *dev_priv = to_i915(dev);\n\tintel_wakeref_t wakeref;\n\tint ret = 0;\n\n\twakeref = intel_display_power_get_if_enabled(dev_priv,\n\t\t\t\t\t\t     intel_encoder->power_domain);\n\tif (drm_WARN_ON(dev, !wakeref))\n\t\treturn -ENXIO;\n\n\tintel_de_rmw(dev_priv, TRANS_DDI_FUNC_CTL(cpu_transcoder),\n\t\t     hdcp_mask, enable ? hdcp_mask : 0);\n\tintel_display_power_put(dev_priv, intel_encoder->power_domain, wakeref);\n\treturn ret;\n}\n\nbool intel_ddi_connector_get_hw_state(struct intel_connector *intel_connector)\n{\n\tstruct drm_device *dev = intel_connector->base.dev;\n\tstruct drm_i915_private *dev_priv = to_i915(dev);\n\tstruct intel_encoder *encoder = intel_attached_encoder(intel_connector);\n\tint type = intel_connector->base.connector_type;\n\tenum port port = encoder->port;\n\tenum transcoder cpu_transcoder;\n\tintel_wakeref_t wakeref;\n\tenum pipe pipe = 0;\n\tu32 tmp;\n\tbool ret;\n\n\twakeref = intel_display_power_get_if_enabled(dev_priv,\n\t\t\t\t\t\t     encoder->power_domain);\n\tif (!wakeref)\n\t\treturn false;\n\n\tif (!encoder->get_hw_state(encoder, &pipe)) {\n\t\tret = false;\n\t\tgoto out;\n\t}\n\n\tif (HAS_TRANSCODER(dev_priv, TRANSCODER_EDP) && port == PORT_A)\n\t\tcpu_transcoder = TRANSCODER_EDP;\n\telse\n\t\tcpu_transcoder = (enum transcoder) pipe;\n\n\ttmp = intel_de_read(dev_priv, TRANS_DDI_FUNC_CTL(cpu_transcoder));\n\n\tswitch (tmp & TRANS_DDI_MODE_SELECT_MASK) {\n\tcase TRANS_DDI_MODE_SELECT_HDMI:\n\tcase TRANS_DDI_MODE_SELECT_DVI:\n\t\tret = type == DRM_MODE_CONNECTOR_HDMIA;\n\t\tbreak;\n\n\tcase TRANS_DDI_MODE_SELECT_DP_SST:\n\t\tret = type == DRM_MODE_CONNECTOR_eDP ||\n\t\t      type == DRM_MODE_CONNECTOR_DisplayPort;\n\t\tbreak;\n\n\tcase TRANS_DDI_MODE_SELECT_DP_MST:\n\t\t \n\t\tret = false;\n\t\tbreak;\n\n\tcase TRANS_DDI_MODE_SELECT_FDI_OR_128B132B:\n\t\tif (HAS_DP20(dev_priv))\n\t\t\t \n\t\t\tret = false;\n\t\telse\n\t\t\t \n\t\t\tret = type == DRM_MODE_CONNECTOR_VGA;\n\t\tbreak;\n\n\tdefault:\n\t\tret = false;\n\t\tbreak;\n\t}\n\nout:\n\tintel_display_power_put(dev_priv, encoder->power_domain, wakeref);\n\n\treturn ret;\n}\n\nstatic void intel_ddi_get_encoder_pipes(struct intel_encoder *encoder,\n\t\t\t\t\tu8 *pipe_mask, bool *is_dp_mst)\n{\n\tstruct drm_device *dev = encoder->base.dev;\n\tstruct drm_i915_private *dev_priv = to_i915(dev);\n\tenum port port = encoder->port;\n\tintel_wakeref_t wakeref;\n\tenum pipe p;\n\tu32 tmp;\n\tu8 mst_pipe_mask;\n\n\t*pipe_mask = 0;\n\t*is_dp_mst = false;\n\n\twakeref = intel_display_power_get_if_enabled(dev_priv,\n\t\t\t\t\t\t     encoder->power_domain);\n\tif (!wakeref)\n\t\treturn;\n\n\ttmp = intel_de_read(dev_priv, DDI_BUF_CTL(port));\n\tif (!(tmp & DDI_BUF_CTL_ENABLE))\n\t\tgoto out;\n\n\tif (HAS_TRANSCODER(dev_priv, TRANSCODER_EDP) && port == PORT_A) {\n\t\ttmp = intel_de_read(dev_priv,\n\t\t\t\t    TRANS_DDI_FUNC_CTL(TRANSCODER_EDP));\n\n\t\tswitch (tmp & TRANS_DDI_EDP_INPUT_MASK) {\n\t\tdefault:\n\t\t\tMISSING_CASE(tmp & TRANS_DDI_EDP_INPUT_MASK);\n\t\t\tfallthrough;\n\t\tcase TRANS_DDI_EDP_INPUT_A_ON:\n\t\tcase TRANS_DDI_EDP_INPUT_A_ONOFF:\n\t\t\t*pipe_mask = BIT(PIPE_A);\n\t\t\tbreak;\n\t\tcase TRANS_DDI_EDP_INPUT_B_ONOFF:\n\t\t\t*pipe_mask = BIT(PIPE_B);\n\t\t\tbreak;\n\t\tcase TRANS_DDI_EDP_INPUT_C_ONOFF:\n\t\t\t*pipe_mask = BIT(PIPE_C);\n\t\t\tbreak;\n\t\t}\n\n\t\tgoto out;\n\t}\n\n\tmst_pipe_mask = 0;\n\tfor_each_pipe(dev_priv, p) {\n\t\tenum transcoder cpu_transcoder = (enum transcoder)p;\n\t\tunsigned int port_mask, ddi_select;\n\t\tintel_wakeref_t trans_wakeref;\n\n\t\ttrans_wakeref = intel_display_power_get_if_enabled(dev_priv,\n\t\t\t\t\t\t\t\t   POWER_DOMAIN_TRANSCODER(cpu_transcoder));\n\t\tif (!trans_wakeref)\n\t\t\tcontinue;\n\n\t\tif (DISPLAY_VER(dev_priv) >= 12) {\n\t\t\tport_mask = TGL_TRANS_DDI_PORT_MASK;\n\t\t\tddi_select = TGL_TRANS_DDI_SELECT_PORT(port);\n\t\t} else {\n\t\t\tport_mask = TRANS_DDI_PORT_MASK;\n\t\t\tddi_select = TRANS_DDI_SELECT_PORT(port);\n\t\t}\n\n\t\ttmp = intel_de_read(dev_priv,\n\t\t\t\t    TRANS_DDI_FUNC_CTL(cpu_transcoder));\n\t\tintel_display_power_put(dev_priv, POWER_DOMAIN_TRANSCODER(cpu_transcoder),\n\t\t\t\t\ttrans_wakeref);\n\n\t\tif ((tmp & port_mask) != ddi_select)\n\t\t\tcontinue;\n\n\t\tif ((tmp & TRANS_DDI_MODE_SELECT_MASK) == TRANS_DDI_MODE_SELECT_DP_MST ||\n\t\t    (HAS_DP20(dev_priv) &&\n\t\t     (tmp & TRANS_DDI_MODE_SELECT_MASK) == TRANS_DDI_MODE_SELECT_FDI_OR_128B132B))\n\t\t\tmst_pipe_mask |= BIT(p);\n\n\t\t*pipe_mask |= BIT(p);\n\t}\n\n\tif (!*pipe_mask)\n\t\tdrm_dbg_kms(&dev_priv->drm,\n\t\t\t    \"No pipe for [ENCODER:%d:%s] found\\n\",\n\t\t\t    encoder->base.base.id, encoder->base.name);\n\n\tif (!mst_pipe_mask && hweight8(*pipe_mask) > 1) {\n\t\tdrm_dbg_kms(&dev_priv->drm,\n\t\t\t    \"Multiple pipes for [ENCODER:%d:%s] (pipe_mask %02x)\\n\",\n\t\t\t    encoder->base.base.id, encoder->base.name,\n\t\t\t    *pipe_mask);\n\t\t*pipe_mask = BIT(ffs(*pipe_mask) - 1);\n\t}\n\n\tif (mst_pipe_mask && mst_pipe_mask != *pipe_mask)\n\t\tdrm_dbg_kms(&dev_priv->drm,\n\t\t\t    \"Conflicting MST and non-MST state for [ENCODER:%d:%s] (pipe_mask %02x mst_pipe_mask %02x)\\n\",\n\t\t\t    encoder->base.base.id, encoder->base.name,\n\t\t\t    *pipe_mask, mst_pipe_mask);\n\telse\n\t\t*is_dp_mst = mst_pipe_mask;\n\nout:\n\tif (*pipe_mask && (IS_GEMINILAKE(dev_priv) || IS_BROXTON(dev_priv))) {\n\t\ttmp = intel_de_read(dev_priv, BXT_PHY_CTL(port));\n\t\tif ((tmp & (BXT_PHY_CMNLANE_POWERDOWN_ACK |\n\t\t\t    BXT_PHY_LANE_POWERDOWN_ACK |\n\t\t\t    BXT_PHY_LANE_ENABLED)) != BXT_PHY_LANE_ENABLED)\n\t\t\tdrm_err(&dev_priv->drm,\n\t\t\t\t\"[ENCODER:%d:%s] enabled but PHY powered down? (PHY_CTL %08x)\\n\",\n\t\t\t\tencoder->base.base.id, encoder->base.name, tmp);\n\t}\n\n\tintel_display_power_put(dev_priv, encoder->power_domain, wakeref);\n}\n\nbool intel_ddi_get_hw_state(struct intel_encoder *encoder,\n\t\t\t    enum pipe *pipe)\n{\n\tu8 pipe_mask;\n\tbool is_mst;\n\n\tintel_ddi_get_encoder_pipes(encoder, &pipe_mask, &is_mst);\n\n\tif (is_mst || !pipe_mask)\n\t\treturn false;\n\n\t*pipe = ffs(pipe_mask) - 1;\n\n\treturn true;\n}\n\nstatic enum intel_display_power_domain\nintel_ddi_main_link_aux_domain(struct intel_digital_port *dig_port,\n\t\t\t       const struct intel_crtc_state *crtc_state)\n{\n\tstruct drm_i915_private *i915 = to_i915(dig_port->base.base.dev);\n\tenum phy phy = intel_port_to_phy(i915, dig_port->base.port);\n\n\t \n\tif (intel_encoder_can_psr(&dig_port->base))\n\t\treturn intel_display_power_aux_io_domain(i915, dig_port->aux_ch);\n\telse if (DISPLAY_VER(i915) < 14 &&\n\t\t (intel_crtc_has_dp_encoder(crtc_state) ||\n\t\t  intel_phy_is_tc(i915, phy)))\n\t\treturn intel_aux_power_domain(dig_port);\n\telse\n\t\treturn POWER_DOMAIN_INVALID;\n}\n\nstatic void\nmain_link_aux_power_domain_get(struct intel_digital_port *dig_port,\n\t\t\t       const struct intel_crtc_state *crtc_state)\n{\n\tstruct drm_i915_private *i915 = to_i915(dig_port->base.base.dev);\n\tenum intel_display_power_domain domain =\n\t\tintel_ddi_main_link_aux_domain(dig_port, crtc_state);\n\n\tdrm_WARN_ON(&i915->drm, dig_port->aux_wakeref);\n\n\tif (domain == POWER_DOMAIN_INVALID)\n\t\treturn;\n\n\tdig_port->aux_wakeref = intel_display_power_get(i915, domain);\n}\n\nstatic void\nmain_link_aux_power_domain_put(struct intel_digital_port *dig_port,\n\t\t\t       const struct intel_crtc_state *crtc_state)\n{\n\tstruct drm_i915_private *i915 = to_i915(dig_port->base.base.dev);\n\tenum intel_display_power_domain domain =\n\t\tintel_ddi_main_link_aux_domain(dig_port, crtc_state);\n\tintel_wakeref_t wf;\n\n\twf = fetch_and_zero(&dig_port->aux_wakeref);\n\tif (!wf)\n\t\treturn;\n\n\tintel_display_power_put(i915, domain, wf);\n}\n\nstatic void intel_ddi_get_power_domains(struct intel_encoder *encoder,\n\t\t\t\t\tstruct intel_crtc_state *crtc_state)\n{\n\tstruct drm_i915_private *dev_priv = to_i915(encoder->base.dev);\n\tstruct intel_digital_port *dig_port;\n\n\t \n\tif (drm_WARN_ON(&dev_priv->drm,\n\t\t\tintel_crtc_has_type(crtc_state, INTEL_OUTPUT_DP_MST)))\n\t\treturn;\n\n\tdig_port = enc_to_dig_port(encoder);\n\n\tif (!intel_tc_port_in_tbt_alt_mode(dig_port)) {\n\t\tdrm_WARN_ON(&dev_priv->drm, dig_port->ddi_io_wakeref);\n\t\tdig_port->ddi_io_wakeref = intel_display_power_get(dev_priv,\n\t\t\t\t\t\t\t\t   dig_port->ddi_io_power_domain);\n\t}\n\n\tmain_link_aux_power_domain_get(dig_port, crtc_state);\n}\n\nvoid intel_ddi_enable_transcoder_clock(struct intel_encoder *encoder,\n\t\t\t\t       const struct intel_crtc_state *crtc_state)\n{\n\tstruct intel_crtc *crtc = to_intel_crtc(crtc_state->uapi.crtc);\n\tstruct drm_i915_private *dev_priv = to_i915(crtc->base.dev);\n\tenum transcoder cpu_transcoder = crtc_state->cpu_transcoder;\n\tenum phy phy = intel_port_to_phy(dev_priv, encoder->port);\n\tu32 val;\n\n\tif (cpu_transcoder == TRANSCODER_EDP)\n\t\treturn;\n\n\tif (DISPLAY_VER(dev_priv) >= 13)\n\t\tval = TGL_TRANS_CLK_SEL_PORT(phy);\n\telse if (DISPLAY_VER(dev_priv) >= 12)\n\t\tval = TGL_TRANS_CLK_SEL_PORT(encoder->port);\n\telse\n\t\tval = TRANS_CLK_SEL_PORT(encoder->port);\n\n\tintel_de_write(dev_priv, TRANS_CLK_SEL(cpu_transcoder), val);\n}\n\nvoid intel_ddi_disable_transcoder_clock(const struct intel_crtc_state *crtc_state)\n{\n\tstruct drm_i915_private *dev_priv = to_i915(crtc_state->uapi.crtc->dev);\n\tenum transcoder cpu_transcoder = crtc_state->cpu_transcoder;\n\tu32 val;\n\n\tif (cpu_transcoder == TRANSCODER_EDP)\n\t\treturn;\n\n\tif (DISPLAY_VER(dev_priv) >= 12)\n\t\tval = TGL_TRANS_CLK_SEL_DISABLED;\n\telse\n\t\tval = TRANS_CLK_SEL_DISABLED;\n\n\tintel_de_write(dev_priv, TRANS_CLK_SEL(cpu_transcoder), val);\n}\n\nstatic void _skl_ddi_set_iboost(struct drm_i915_private *dev_priv,\n\t\t\t\tenum port port, u8 iboost)\n{\n\tu32 tmp;\n\n\ttmp = intel_de_read(dev_priv, DISPIO_CR_TX_BMU_CR0);\n\ttmp &= ~(BALANCE_LEG_MASK(port) | BALANCE_LEG_DISABLE(port));\n\tif (iboost)\n\t\ttmp |= iboost << BALANCE_LEG_SHIFT(port);\n\telse\n\t\ttmp |= BALANCE_LEG_DISABLE(port);\n\tintel_de_write(dev_priv, DISPIO_CR_TX_BMU_CR0, tmp);\n}\n\nstatic void skl_ddi_set_iboost(struct intel_encoder *encoder,\n\t\t\t       const struct intel_crtc_state *crtc_state,\n\t\t\t       int level)\n{\n\tstruct intel_digital_port *dig_port = enc_to_dig_port(encoder);\n\tstruct drm_i915_private *dev_priv = to_i915(encoder->base.dev);\n\tu8 iboost;\n\n\tif (intel_crtc_has_type(crtc_state, INTEL_OUTPUT_HDMI))\n\t\tiboost = intel_bios_hdmi_boost_level(encoder->devdata);\n\telse\n\t\tiboost = intel_bios_dp_boost_level(encoder->devdata);\n\n\tif (iboost == 0) {\n\t\tconst struct intel_ddi_buf_trans *trans;\n\t\tint n_entries;\n\n\t\ttrans = encoder->get_buf_trans(encoder, crtc_state, &n_entries);\n\t\tif (drm_WARN_ON_ONCE(&dev_priv->drm, !trans))\n\t\t\treturn;\n\n\t\tiboost = trans->entries[level].hsw.i_boost;\n\t}\n\n\t \n\tif (iboost && iboost != 0x1 && iboost != 0x3 && iboost != 0x7) {\n\t\tdrm_err(&dev_priv->drm, \"Invalid I_boost value %u\\n\", iboost);\n\t\treturn;\n\t}\n\n\t_skl_ddi_set_iboost(dev_priv, encoder->port, iboost);\n\n\tif (encoder->port == PORT_A && dig_port->max_lanes == 4)\n\t\t_skl_ddi_set_iboost(dev_priv, PORT_E, iboost);\n}\n\nstatic u8 intel_ddi_dp_voltage_max(struct intel_dp *intel_dp,\n\t\t\t\t   const struct intel_crtc_state *crtc_state)\n{\n\tstruct intel_encoder *encoder = &dp_to_dig_port(intel_dp)->base;\n\tstruct drm_i915_private *dev_priv = to_i915(encoder->base.dev);\n\tint n_entries;\n\n\tencoder->get_buf_trans(encoder, crtc_state, &n_entries);\n\n\tif (drm_WARN_ON(&dev_priv->drm, n_entries < 1))\n\t\tn_entries = 1;\n\tif (drm_WARN_ON(&dev_priv->drm,\n\t\t\tn_entries > ARRAY_SIZE(index_to_dp_signal_levels)))\n\t\tn_entries = ARRAY_SIZE(index_to_dp_signal_levels);\n\n\treturn index_to_dp_signal_levels[n_entries - 1] &\n\t\tDP_TRAIN_VOLTAGE_SWING_MASK;\n}\n\n \nstatic u8 intel_ddi_dp_preemph_max(struct intel_dp *intel_dp)\n{\n\treturn DP_TRAIN_PRE_EMPH_LEVEL_3;\n}\n\nstatic u32 icl_combo_phy_loadgen_select(const struct intel_crtc_state *crtc_state,\n\t\t\t\t\tint lane)\n{\n\tif (crtc_state->port_clock > 600000)\n\t\treturn 0;\n\n\tif (crtc_state->lane_count == 4)\n\t\treturn lane >= 1 ? LOADGEN_SELECT : 0;\n\telse\n\t\treturn lane == 1 || lane == 2 ? LOADGEN_SELECT : 0;\n}\n\nstatic void icl_ddi_combo_vswing_program(struct intel_encoder *encoder,\n\t\t\t\t\t const struct intel_crtc_state *crtc_state)\n{\n\tstruct drm_i915_private *dev_priv = to_i915(encoder->base.dev);\n\tconst struct intel_ddi_buf_trans *trans;\n\tenum phy phy = intel_port_to_phy(dev_priv, encoder->port);\n\tint n_entries, ln;\n\tu32 val;\n\n\ttrans = encoder->get_buf_trans(encoder, crtc_state, &n_entries);\n\tif (drm_WARN_ON_ONCE(&dev_priv->drm, !trans))\n\t\treturn;\n\n\tif (intel_crtc_has_type(crtc_state, INTEL_OUTPUT_EDP)) {\n\t\tstruct intel_dp *intel_dp = enc_to_intel_dp(encoder);\n\n\t\tval = EDP4K2K_MODE_OVRD_EN | EDP4K2K_MODE_OVRD_OPTIMIZED;\n\t\tintel_dp->hobl_active = is_hobl_buf_trans(trans);\n\t\tintel_de_rmw(dev_priv, ICL_PORT_CL_DW10(phy), val,\n\t\t\t     intel_dp->hobl_active ? val : 0);\n\t}\n\n\t \n\tval = intel_de_read(dev_priv, ICL_PORT_TX_DW5_LN(0, phy));\n\tval &= ~(SCALING_MODE_SEL_MASK | RTERM_SELECT_MASK |\n\t\t  TAP2_DISABLE | TAP3_DISABLE);\n\tval |= SCALING_MODE_SEL(0x2);\n\tval |= RTERM_SELECT(0x6);\n\tval |= TAP3_DISABLE;\n\tintel_de_write(dev_priv, ICL_PORT_TX_DW5_GRP(phy), val);\n\n\t \n\tfor (ln = 0; ln < 4; ln++) {\n\t\tint level = intel_ddi_level(encoder, crtc_state, ln);\n\n\t\tintel_de_rmw(dev_priv, ICL_PORT_TX_DW2_LN(ln, phy),\n\t\t\t     SWING_SEL_UPPER_MASK | SWING_SEL_LOWER_MASK | RCOMP_SCALAR_MASK,\n\t\t\t     SWING_SEL_UPPER(trans->entries[level].icl.dw2_swing_sel) |\n\t\t\t     SWING_SEL_LOWER(trans->entries[level].icl.dw2_swing_sel) |\n\t\t\t     RCOMP_SCALAR(0x98));\n\t}\n\n\t \n\t \n\tfor (ln = 0; ln < 4; ln++) {\n\t\tint level = intel_ddi_level(encoder, crtc_state, ln);\n\n\t\tintel_de_rmw(dev_priv, ICL_PORT_TX_DW4_LN(ln, phy),\n\t\t\t     POST_CURSOR_1_MASK | POST_CURSOR_2_MASK | CURSOR_COEFF_MASK,\n\t\t\t     POST_CURSOR_1(trans->entries[level].icl.dw4_post_cursor_1) |\n\t\t\t     POST_CURSOR_2(trans->entries[level].icl.dw4_post_cursor_2) |\n\t\t\t     CURSOR_COEFF(trans->entries[level].icl.dw4_cursor_coeff));\n\t}\n\n\t \n\tfor (ln = 0; ln < 4; ln++) {\n\t\tint level = intel_ddi_level(encoder, crtc_state, ln);\n\n\t\tintel_de_rmw(dev_priv, ICL_PORT_TX_DW7_LN(ln, phy),\n\t\t\t     N_SCALAR_MASK,\n\t\t\t     N_SCALAR(trans->entries[level].icl.dw7_n_scalar));\n\t}\n}\n\nstatic void icl_combo_phy_set_signal_levels(struct intel_encoder *encoder,\n\t\t\t\t\t    const struct intel_crtc_state *crtc_state)\n{\n\tstruct drm_i915_private *dev_priv = to_i915(encoder->base.dev);\n\tenum phy phy = intel_port_to_phy(dev_priv, encoder->port);\n\tu32 val;\n\tint ln;\n\n\t \n\tval = intel_de_read(dev_priv, ICL_PORT_PCS_DW1_LN(0, phy));\n\tif (intel_crtc_has_type(crtc_state, INTEL_OUTPUT_HDMI))\n\t\tval &= ~COMMON_KEEPER_EN;\n\telse\n\t\tval |= COMMON_KEEPER_EN;\n\tintel_de_write(dev_priv, ICL_PORT_PCS_DW1_GRP(phy), val);\n\n\t \n\t \n\tfor (ln = 0; ln < 4; ln++) {\n\t\tintel_de_rmw(dev_priv, ICL_PORT_TX_DW4_LN(ln, phy),\n\t\t\t     LOADGEN_SELECT,\n\t\t\t     icl_combo_phy_loadgen_select(crtc_state, ln));\n\t}\n\n\t \n\tintel_de_rmw(dev_priv, ICL_PORT_CL_DW5(phy),\n\t\t     0, SUS_CLOCK_CONFIG);\n\n\t \n\tval = intel_de_read(dev_priv, ICL_PORT_TX_DW5_LN(0, phy));\n\tval &= ~TX_TRAINING_EN;\n\tintel_de_write(dev_priv, ICL_PORT_TX_DW5_GRP(phy), val);\n\n\t \n\ticl_ddi_combo_vswing_program(encoder, crtc_state);\n\n\t \n\tval = intel_de_read(dev_priv, ICL_PORT_TX_DW5_LN(0, phy));\n\tval |= TX_TRAINING_EN;\n\tintel_de_write(dev_priv, ICL_PORT_TX_DW5_GRP(phy), val);\n}\n\nstatic void icl_mg_phy_set_signal_levels(struct intel_encoder *encoder,\n\t\t\t\t\t const struct intel_crtc_state *crtc_state)\n{\n\tstruct drm_i915_private *dev_priv = to_i915(encoder->base.dev);\n\tenum tc_port tc_port = intel_port_to_tc(dev_priv, encoder->port);\n\tconst struct intel_ddi_buf_trans *trans;\n\tint n_entries, ln;\n\n\tif (intel_tc_port_in_tbt_alt_mode(enc_to_dig_port(encoder)))\n\t\treturn;\n\n\ttrans = encoder->get_buf_trans(encoder, crtc_state, &n_entries);\n\tif (drm_WARN_ON_ONCE(&dev_priv->drm, !trans))\n\t\treturn;\n\n\tfor (ln = 0; ln < 2; ln++) {\n\t\tintel_de_rmw(dev_priv, MG_TX1_LINK_PARAMS(ln, tc_port),\n\t\t\t     CRI_USE_FS32, 0);\n\t\tintel_de_rmw(dev_priv, MG_TX2_LINK_PARAMS(ln, tc_port),\n\t\t\t     CRI_USE_FS32, 0);\n\t}\n\n\t \n\tfor (ln = 0; ln < 2; ln++) {\n\t\tint level;\n\n\t\tlevel = intel_ddi_level(encoder, crtc_state, 2*ln+0);\n\n\t\tintel_de_rmw(dev_priv, MG_TX1_SWINGCTRL(ln, tc_port),\n\t\t\t     CRI_TXDEEMPH_OVERRIDE_17_12_MASK,\n\t\t\t     CRI_TXDEEMPH_OVERRIDE_17_12(trans->entries[level].mg.cri_txdeemph_override_17_12));\n\n\t\tlevel = intel_ddi_level(encoder, crtc_state, 2*ln+1);\n\n\t\tintel_de_rmw(dev_priv, MG_TX2_SWINGCTRL(ln, tc_port),\n\t\t\t     CRI_TXDEEMPH_OVERRIDE_17_12_MASK,\n\t\t\t     CRI_TXDEEMPH_OVERRIDE_17_12(trans->entries[level].mg.cri_txdeemph_override_17_12));\n\t}\n\n\t \n\tfor (ln = 0; ln < 2; ln++) {\n\t\tint level;\n\n\t\tlevel = intel_ddi_level(encoder, crtc_state, 2*ln+0);\n\n\t\tintel_de_rmw(dev_priv, MG_TX1_DRVCTRL(ln, tc_port),\n\t\t\t     CRI_TXDEEMPH_OVERRIDE_11_6_MASK |\n\t\t\t     CRI_TXDEEMPH_OVERRIDE_5_0_MASK,\n\t\t\t     CRI_TXDEEMPH_OVERRIDE_11_6(trans->entries[level].mg.cri_txdeemph_override_11_6) |\n\t\t\t     CRI_TXDEEMPH_OVERRIDE_5_0(trans->entries[level].mg.cri_txdeemph_override_5_0) |\n\t\t\t     CRI_TXDEEMPH_OVERRIDE_EN);\n\n\t\tlevel = intel_ddi_level(encoder, crtc_state, 2*ln+1);\n\n\t\tintel_de_rmw(dev_priv, MG_TX2_DRVCTRL(ln, tc_port),\n\t\t\t     CRI_TXDEEMPH_OVERRIDE_11_6_MASK |\n\t\t\t     CRI_TXDEEMPH_OVERRIDE_5_0_MASK,\n\t\t\t     CRI_TXDEEMPH_OVERRIDE_11_6(trans->entries[level].mg.cri_txdeemph_override_11_6) |\n\t\t\t     CRI_TXDEEMPH_OVERRIDE_5_0(trans->entries[level].mg.cri_txdeemph_override_5_0) |\n\t\t\t     CRI_TXDEEMPH_OVERRIDE_EN);\n\n\t\t \n\t}\n\n\t \n\tfor (ln = 0; ln < 2; ln++) {\n\t\tintel_de_rmw(dev_priv, MG_CLKHUB(ln, tc_port),\n\t\t\t     CFG_LOW_RATE_LKREN_EN,\n\t\t\t     crtc_state->port_clock < 300000 ? CFG_LOW_RATE_LKREN_EN : 0);\n\t}\n\n\t \n\tfor (ln = 0; ln < 2; ln++) {\n\t\tintel_de_rmw(dev_priv, MG_TX1_DCC(ln, tc_port),\n\t\t\t     CFG_AMI_CK_DIV_OVERRIDE_VAL_MASK |\n\t\t\t     CFG_AMI_CK_DIV_OVERRIDE_EN,\n\t\t\t     crtc_state->port_clock > 500000 ?\n\t\t\t     CFG_AMI_CK_DIV_OVERRIDE_VAL(1) |\n\t\t\t     CFG_AMI_CK_DIV_OVERRIDE_EN : 0);\n\n\t\tintel_de_rmw(dev_priv, MG_TX2_DCC(ln, tc_port),\n\t\t\t     CFG_AMI_CK_DIV_OVERRIDE_VAL_MASK |\n\t\t\t     CFG_AMI_CK_DIV_OVERRIDE_EN,\n\t\t\t     crtc_state->port_clock > 500000 ?\n\t\t\t     CFG_AMI_CK_DIV_OVERRIDE_VAL(1) |\n\t\t\t     CFG_AMI_CK_DIV_OVERRIDE_EN : 0);\n\t}\n\n\t \n\tfor (ln = 0; ln < 2; ln++) {\n\t\tintel_de_rmw(dev_priv, MG_TX1_PISO_READLOAD(ln, tc_port),\n\t\t\t     0, CRI_CALCINIT);\n\t\tintel_de_rmw(dev_priv, MG_TX2_PISO_READLOAD(ln, tc_port),\n\t\t\t     0, CRI_CALCINIT);\n\t}\n}\n\nstatic void tgl_dkl_phy_set_signal_levels(struct intel_encoder *encoder,\n\t\t\t\t\t  const struct intel_crtc_state *crtc_state)\n{\n\tstruct drm_i915_private *dev_priv = to_i915(encoder->base.dev);\n\tenum tc_port tc_port = intel_port_to_tc(dev_priv, encoder->port);\n\tconst struct intel_ddi_buf_trans *trans;\n\tint n_entries, ln;\n\n\tif (intel_tc_port_in_tbt_alt_mode(enc_to_dig_port(encoder)))\n\t\treturn;\n\n\ttrans = encoder->get_buf_trans(encoder, crtc_state, &n_entries);\n\tif (drm_WARN_ON_ONCE(&dev_priv->drm, !trans))\n\t\treturn;\n\n\tfor (ln = 0; ln < 2; ln++) {\n\t\tint level;\n\n\t\tintel_dkl_phy_write(dev_priv, DKL_TX_PMD_LANE_SUS(tc_port, ln), 0);\n\n\t\tlevel = intel_ddi_level(encoder, crtc_state, 2*ln+0);\n\n\t\tintel_dkl_phy_rmw(dev_priv, DKL_TX_DPCNTL0(tc_port, ln),\n\t\t\t\t  DKL_TX_PRESHOOT_COEFF_MASK |\n\t\t\t\t  DKL_TX_DE_EMPAHSIS_COEFF_MASK |\n\t\t\t\t  DKL_TX_VSWING_CONTROL_MASK,\n\t\t\t\t  DKL_TX_PRESHOOT_COEFF(trans->entries[level].dkl.preshoot) |\n\t\t\t\t  DKL_TX_DE_EMPHASIS_COEFF(trans->entries[level].dkl.de_emphasis) |\n\t\t\t\t  DKL_TX_VSWING_CONTROL(trans->entries[level].dkl.vswing));\n\n\t\tlevel = intel_ddi_level(encoder, crtc_state, 2*ln+1);\n\n\t\tintel_dkl_phy_rmw(dev_priv, DKL_TX_DPCNTL1(tc_port, ln),\n\t\t\t\t  DKL_TX_PRESHOOT_COEFF_MASK |\n\t\t\t\t  DKL_TX_DE_EMPAHSIS_COEFF_MASK |\n\t\t\t\t  DKL_TX_VSWING_CONTROL_MASK,\n\t\t\t\t  DKL_TX_PRESHOOT_COEFF(trans->entries[level].dkl.preshoot) |\n\t\t\t\t  DKL_TX_DE_EMPHASIS_COEFF(trans->entries[level].dkl.de_emphasis) |\n\t\t\t\t  DKL_TX_VSWING_CONTROL(trans->entries[level].dkl.vswing));\n\n\t\tintel_dkl_phy_rmw(dev_priv, DKL_TX_DPCNTL2(tc_port, ln),\n\t\t\t\t  DKL_TX_DP20BITMODE, 0);\n\n\t\tif (IS_ALDERLAKE_P(dev_priv)) {\n\t\t\tu32 val;\n\n\t\t\tif (intel_crtc_has_type(crtc_state, INTEL_OUTPUT_HDMI)) {\n\t\t\t\tif (ln == 0) {\n\t\t\t\t\tval = DKL_TX_DPCNTL2_CFG_LOADGENSELECT_TX1(0);\n\t\t\t\t\tval |= DKL_TX_DPCNTL2_CFG_LOADGENSELECT_TX2(2);\n\t\t\t\t} else {\n\t\t\t\t\tval = DKL_TX_DPCNTL2_CFG_LOADGENSELECT_TX1(3);\n\t\t\t\t\tval |= DKL_TX_DPCNTL2_CFG_LOADGENSELECT_TX2(3);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tval = DKL_TX_DPCNTL2_CFG_LOADGENSELECT_TX1(0);\n\t\t\t\tval |= DKL_TX_DPCNTL2_CFG_LOADGENSELECT_TX2(0);\n\t\t\t}\n\n\t\t\tintel_dkl_phy_rmw(dev_priv, DKL_TX_DPCNTL2(tc_port, ln),\n\t\t\t\t\t  DKL_TX_DPCNTL2_CFG_LOADGENSELECT_TX1_MASK |\n\t\t\t\t\t  DKL_TX_DPCNTL2_CFG_LOADGENSELECT_TX2_MASK,\n\t\t\t\t\t  val);\n\t\t}\n\t}\n}\n\nstatic int translate_signal_level(struct intel_dp *intel_dp,\n\t\t\t\t  u8 signal_levels)\n{\n\tstruct drm_i915_private *i915 = dp_to_i915(intel_dp);\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(index_to_dp_signal_levels); i++) {\n\t\tif (index_to_dp_signal_levels[i] == signal_levels)\n\t\t\treturn i;\n\t}\n\n\tdrm_WARN(&i915->drm, 1,\n\t\t \"Unsupported voltage swing/pre-emphasis level: 0x%x\\n\",\n\t\t signal_levels);\n\n\treturn 0;\n}\n\nstatic int intel_ddi_dp_level(struct intel_dp *intel_dp,\n\t\t\t      const struct intel_crtc_state *crtc_state,\n\t\t\t      int lane)\n{\n\tu8 train_set = intel_dp->train_set[lane];\n\n\tif (intel_dp_is_uhbr(crtc_state)) {\n\t\treturn train_set & DP_TX_FFE_PRESET_VALUE_MASK;\n\t} else {\n\t\tu8 signal_levels = train_set & (DP_TRAIN_VOLTAGE_SWING_MASK |\n\t\t\t\t\t\tDP_TRAIN_PRE_EMPHASIS_MASK);\n\n\t\treturn translate_signal_level(intel_dp, signal_levels);\n\t}\n}\n\nint intel_ddi_level(struct intel_encoder *encoder,\n\t\t    const struct intel_crtc_state *crtc_state,\n\t\t    int lane)\n{\n\tstruct drm_i915_private *i915 = to_i915(encoder->base.dev);\n\tconst struct intel_ddi_buf_trans *trans;\n\tint level, n_entries;\n\n\ttrans = encoder->get_buf_trans(encoder, crtc_state, &n_entries);\n\tif (drm_WARN_ON_ONCE(&i915->drm, !trans))\n\t\treturn 0;\n\n\tif (intel_crtc_has_type(crtc_state, INTEL_OUTPUT_HDMI))\n\t\tlevel = intel_ddi_hdmi_level(encoder, trans);\n\telse\n\t\tlevel = intel_ddi_dp_level(enc_to_intel_dp(encoder), crtc_state,\n\t\t\t\t\t   lane);\n\n\tif (drm_WARN_ON_ONCE(&i915->drm, level >= n_entries))\n\t\tlevel = n_entries - 1;\n\n\treturn level;\n}\n\nstatic void\nhsw_set_signal_levels(struct intel_encoder *encoder,\n\t\t      const struct intel_crtc_state *crtc_state)\n{\n\tstruct drm_i915_private *dev_priv = to_i915(encoder->base.dev);\n\tstruct intel_dp *intel_dp = enc_to_intel_dp(encoder);\n\tint level = intel_ddi_level(encoder, crtc_state, 0);\n\tenum port port = encoder->port;\n\tu32 signal_levels;\n\n\tif (has_iboost(dev_priv))\n\t\tskl_ddi_set_iboost(encoder, crtc_state, level);\n\n\t \n\tif (intel_crtc_has_type(crtc_state, INTEL_OUTPUT_HDMI))\n\t\treturn;\n\n\tsignal_levels = DDI_BUF_TRANS_SELECT(level);\n\n\tdrm_dbg_kms(&dev_priv->drm, \"Using signal levels %08x\\n\",\n\t\t    signal_levels);\n\n\tintel_dp->DP &= ~DDI_BUF_EMP_MASK;\n\tintel_dp->DP |= signal_levels;\n\n\tintel_de_write(dev_priv, DDI_BUF_CTL(port), intel_dp->DP);\n\tintel_de_posting_read(dev_priv, DDI_BUF_CTL(port));\n}\n\nstatic void _icl_ddi_enable_clock(struct drm_i915_private *i915, i915_reg_t reg,\n\t\t\t\t  u32 clk_sel_mask, u32 clk_sel, u32 clk_off)\n{\n\tmutex_lock(&i915->display.dpll.lock);\n\n\tintel_de_rmw(i915, reg, clk_sel_mask, clk_sel);\n\n\t \n\tintel_de_rmw(i915, reg, clk_off, 0);\n\n\tmutex_unlock(&i915->display.dpll.lock);\n}\n\nstatic void _icl_ddi_disable_clock(struct drm_i915_private *i915, i915_reg_t reg,\n\t\t\t\t   u32 clk_off)\n{\n\tmutex_lock(&i915->display.dpll.lock);\n\n\tintel_de_rmw(i915, reg, 0, clk_off);\n\n\tmutex_unlock(&i915->display.dpll.lock);\n}\n\nstatic bool _icl_ddi_is_clock_enabled(struct drm_i915_private *i915, i915_reg_t reg,\n\t\t\t\t      u32 clk_off)\n{\n\treturn !(intel_de_read(i915, reg) & clk_off);\n}\n\nstatic struct intel_shared_dpll *\n_icl_ddi_get_pll(struct drm_i915_private *i915, i915_reg_t reg,\n\t\t u32 clk_sel_mask, u32 clk_sel_shift)\n{\n\tenum intel_dpll_id id;\n\n\tid = (intel_de_read(i915, reg) & clk_sel_mask) >> clk_sel_shift;\n\n\treturn intel_get_shared_dpll_by_id(i915, id);\n}\n\nstatic void adls_ddi_enable_clock(struct intel_encoder *encoder,\n\t\t\t\t  const struct intel_crtc_state *crtc_state)\n{\n\tstruct drm_i915_private *i915 = to_i915(encoder->base.dev);\n\tconst struct intel_shared_dpll *pll = crtc_state->shared_dpll;\n\tenum phy phy = intel_port_to_phy(i915, encoder->port);\n\n\tif (drm_WARN_ON(&i915->drm, !pll))\n\t\treturn;\n\n\t_icl_ddi_enable_clock(i915, ADLS_DPCLKA_CFGCR(phy),\n\t\t\t      ADLS_DPCLKA_CFGCR_DDI_CLK_SEL_MASK(phy),\n\t\t\t      pll->info->id << ADLS_DPCLKA_CFGCR_DDI_SHIFT(phy),\n\t\t\t      ICL_DPCLKA_CFGCR0_DDI_CLK_OFF(phy));\n}\n\nstatic void adls_ddi_disable_clock(struct intel_encoder *encoder)\n{\n\tstruct drm_i915_private *i915 = to_i915(encoder->base.dev);\n\tenum phy phy = intel_port_to_phy(i915, encoder->port);\n\n\t_icl_ddi_disable_clock(i915, ADLS_DPCLKA_CFGCR(phy),\n\t\t\t       ICL_DPCLKA_CFGCR0_DDI_CLK_OFF(phy));\n}\n\nstatic bool adls_ddi_is_clock_enabled(struct intel_encoder *encoder)\n{\n\tstruct drm_i915_private *i915 = to_i915(encoder->base.dev);\n\tenum phy phy = intel_port_to_phy(i915, encoder->port);\n\n\treturn _icl_ddi_is_clock_enabled(i915, ADLS_DPCLKA_CFGCR(phy),\n\t\t\t\t\t ICL_DPCLKA_CFGCR0_DDI_CLK_OFF(phy));\n}\n\nstatic struct intel_shared_dpll *adls_ddi_get_pll(struct intel_encoder *encoder)\n{\n\tstruct drm_i915_private *i915 = to_i915(encoder->base.dev);\n\tenum phy phy = intel_port_to_phy(i915, encoder->port);\n\n\treturn _icl_ddi_get_pll(i915, ADLS_DPCLKA_CFGCR(phy),\n\t\t\t\tADLS_DPCLKA_CFGCR_DDI_CLK_SEL_MASK(phy),\n\t\t\t\tADLS_DPCLKA_CFGCR_DDI_SHIFT(phy));\n}\n\nstatic void rkl_ddi_enable_clock(struct intel_encoder *encoder,\n\t\t\t\t const struct intel_crtc_state *crtc_state)\n{\n\tstruct drm_i915_private *i915 = to_i915(encoder->base.dev);\n\tconst struct intel_shared_dpll *pll = crtc_state->shared_dpll;\n\tenum phy phy = intel_port_to_phy(i915, encoder->port);\n\n\tif (drm_WARN_ON(&i915->drm, !pll))\n\t\treturn;\n\n\t_icl_ddi_enable_clock(i915, ICL_DPCLKA_CFGCR0,\n\t\t\t      RKL_DPCLKA_CFGCR0_DDI_CLK_SEL_MASK(phy),\n\t\t\t      RKL_DPCLKA_CFGCR0_DDI_CLK_SEL(pll->info->id, phy),\n\t\t\t      RKL_DPCLKA_CFGCR0_DDI_CLK_OFF(phy));\n}\n\nstatic void rkl_ddi_disable_clock(struct intel_encoder *encoder)\n{\n\tstruct drm_i915_private *i915 = to_i915(encoder->base.dev);\n\tenum phy phy = intel_port_to_phy(i915, encoder->port);\n\n\t_icl_ddi_disable_clock(i915, ICL_DPCLKA_CFGCR0,\n\t\t\t       RKL_DPCLKA_CFGCR0_DDI_CLK_OFF(phy));\n}\n\nstatic bool rkl_ddi_is_clock_enabled(struct intel_encoder *encoder)\n{\n\tstruct drm_i915_private *i915 = to_i915(encoder->base.dev);\n\tenum phy phy = intel_port_to_phy(i915, encoder->port);\n\n\treturn _icl_ddi_is_clock_enabled(i915, ICL_DPCLKA_CFGCR0,\n\t\t\t\t\t RKL_DPCLKA_CFGCR0_DDI_CLK_OFF(phy));\n}\n\nstatic struct intel_shared_dpll *rkl_ddi_get_pll(struct intel_encoder *encoder)\n{\n\tstruct drm_i915_private *i915 = to_i915(encoder->base.dev);\n\tenum phy phy = intel_port_to_phy(i915, encoder->port);\n\n\treturn _icl_ddi_get_pll(i915, ICL_DPCLKA_CFGCR0,\n\t\t\t\tRKL_DPCLKA_CFGCR0_DDI_CLK_SEL_MASK(phy),\n\t\t\t\tRKL_DPCLKA_CFGCR0_DDI_CLK_SEL_SHIFT(phy));\n}\n\nstatic void dg1_ddi_enable_clock(struct intel_encoder *encoder,\n\t\t\t\t const struct intel_crtc_state *crtc_state)\n{\n\tstruct drm_i915_private *i915 = to_i915(encoder->base.dev);\n\tconst struct intel_shared_dpll *pll = crtc_state->shared_dpll;\n\tenum phy phy = intel_port_to_phy(i915, encoder->port);\n\n\tif (drm_WARN_ON(&i915->drm, !pll))\n\t\treturn;\n\n\t \n\tif (drm_WARN_ON(&i915->drm,\n\t\t\t(pll->info->id < DPLL_ID_DG1_DPLL2 && phy >= PHY_C) ||\n\t\t\t(pll->info->id >= DPLL_ID_DG1_DPLL2 && phy < PHY_C)))\n\t\treturn;\n\n\t_icl_ddi_enable_clock(i915, DG1_DPCLKA_CFGCR0(phy),\n\t\t\t      DG1_DPCLKA_CFGCR0_DDI_CLK_SEL_MASK(phy),\n\t\t\t      DG1_DPCLKA_CFGCR0_DDI_CLK_SEL(pll->info->id, phy),\n\t\t\t      DG1_DPCLKA_CFGCR0_DDI_CLK_OFF(phy));\n}\n\nstatic void dg1_ddi_disable_clock(struct intel_encoder *encoder)\n{\n\tstruct drm_i915_private *i915 = to_i915(encoder->base.dev);\n\tenum phy phy = intel_port_to_phy(i915, encoder->port);\n\n\t_icl_ddi_disable_clock(i915, DG1_DPCLKA_CFGCR0(phy),\n\t\t\t       DG1_DPCLKA_CFGCR0_DDI_CLK_OFF(phy));\n}\n\nstatic bool dg1_ddi_is_clock_enabled(struct intel_encoder *encoder)\n{\n\tstruct drm_i915_private *i915 = to_i915(encoder->base.dev);\n\tenum phy phy = intel_port_to_phy(i915, encoder->port);\n\n\treturn _icl_ddi_is_clock_enabled(i915, DG1_DPCLKA_CFGCR0(phy),\n\t\t\t\t\t DG1_DPCLKA_CFGCR0_DDI_CLK_OFF(phy));\n}\n\nstatic struct intel_shared_dpll *dg1_ddi_get_pll(struct intel_encoder *encoder)\n{\n\tstruct drm_i915_private *i915 = to_i915(encoder->base.dev);\n\tenum phy phy = intel_port_to_phy(i915, encoder->port);\n\tenum intel_dpll_id id;\n\tu32 val;\n\n\tval = intel_de_read(i915, DG1_DPCLKA_CFGCR0(phy));\n\tval &= DG1_DPCLKA_CFGCR0_DDI_CLK_SEL_MASK(phy);\n\tval >>= DG1_DPCLKA_CFGCR0_DDI_CLK_SEL_SHIFT(phy);\n\tid = val;\n\n\t \n\tif (phy >= PHY_C)\n\t\tid += DPLL_ID_DG1_DPLL2;\n\n\treturn intel_get_shared_dpll_by_id(i915, id);\n}\n\nstatic void icl_ddi_combo_enable_clock(struct intel_encoder *encoder,\n\t\t\t\t       const struct intel_crtc_state *crtc_state)\n{\n\tstruct drm_i915_private *i915 = to_i915(encoder->base.dev);\n\tconst struct intel_shared_dpll *pll = crtc_state->shared_dpll;\n\tenum phy phy = intel_port_to_phy(i915, encoder->port);\n\n\tif (drm_WARN_ON(&i915->drm, !pll))\n\t\treturn;\n\n\t_icl_ddi_enable_clock(i915, ICL_DPCLKA_CFGCR0,\n\t\t\t      ICL_DPCLKA_CFGCR0_DDI_CLK_SEL_MASK(phy),\n\t\t\t      ICL_DPCLKA_CFGCR0_DDI_CLK_SEL(pll->info->id, phy),\n\t\t\t      ICL_DPCLKA_CFGCR0_DDI_CLK_OFF(phy));\n}\n\nstatic void icl_ddi_combo_disable_clock(struct intel_encoder *encoder)\n{\n\tstruct drm_i915_private *i915 = to_i915(encoder->base.dev);\n\tenum phy phy = intel_port_to_phy(i915, encoder->port);\n\n\t_icl_ddi_disable_clock(i915, ICL_DPCLKA_CFGCR0,\n\t\t\t       ICL_DPCLKA_CFGCR0_DDI_CLK_OFF(phy));\n}\n\nstatic bool icl_ddi_combo_is_clock_enabled(struct intel_encoder *encoder)\n{\n\tstruct drm_i915_private *i915 = to_i915(encoder->base.dev);\n\tenum phy phy = intel_port_to_phy(i915, encoder->port);\n\n\treturn _icl_ddi_is_clock_enabled(i915, ICL_DPCLKA_CFGCR0,\n\t\t\t\t\t ICL_DPCLKA_CFGCR0_DDI_CLK_OFF(phy));\n}\n\nstruct intel_shared_dpll *icl_ddi_combo_get_pll(struct intel_encoder *encoder)\n{\n\tstruct drm_i915_private *i915 = to_i915(encoder->base.dev);\n\tenum phy phy = intel_port_to_phy(i915, encoder->port);\n\n\treturn _icl_ddi_get_pll(i915, ICL_DPCLKA_CFGCR0,\n\t\t\t\tICL_DPCLKA_CFGCR0_DDI_CLK_SEL_MASK(phy),\n\t\t\t\tICL_DPCLKA_CFGCR0_DDI_CLK_SEL_SHIFT(phy));\n}\n\nstatic void jsl_ddi_tc_enable_clock(struct intel_encoder *encoder,\n\t\t\t\t    const struct intel_crtc_state *crtc_state)\n{\n\tstruct drm_i915_private *i915 = to_i915(encoder->base.dev);\n\tconst struct intel_shared_dpll *pll = crtc_state->shared_dpll;\n\tenum port port = encoder->port;\n\n\tif (drm_WARN_ON(&i915->drm, !pll))\n\t\treturn;\n\n\t \n\tintel_de_write(i915, DDI_CLK_SEL(port), DDI_CLK_SEL_MG);\n\n\ticl_ddi_combo_enable_clock(encoder, crtc_state);\n}\n\nstatic void jsl_ddi_tc_disable_clock(struct intel_encoder *encoder)\n{\n\tstruct drm_i915_private *i915 = to_i915(encoder->base.dev);\n\tenum port port = encoder->port;\n\n\ticl_ddi_combo_disable_clock(encoder);\n\n\tintel_de_write(i915, DDI_CLK_SEL(port), DDI_CLK_SEL_NONE);\n}\n\nstatic bool jsl_ddi_tc_is_clock_enabled(struct intel_encoder *encoder)\n{\n\tstruct drm_i915_private *i915 = to_i915(encoder->base.dev);\n\tenum port port = encoder->port;\n\tu32 tmp;\n\n\ttmp = intel_de_read(i915, DDI_CLK_SEL(port));\n\n\tif ((tmp & DDI_CLK_SEL_MASK) == DDI_CLK_SEL_NONE)\n\t\treturn false;\n\n\treturn icl_ddi_combo_is_clock_enabled(encoder);\n}\n\nstatic void icl_ddi_tc_enable_clock(struct intel_encoder *encoder,\n\t\t\t\t    const struct intel_crtc_state *crtc_state)\n{\n\tstruct drm_i915_private *i915 = to_i915(encoder->base.dev);\n\tconst struct intel_shared_dpll *pll = crtc_state->shared_dpll;\n\tenum tc_port tc_port = intel_port_to_tc(i915, encoder->port);\n\tenum port port = encoder->port;\n\n\tif (drm_WARN_ON(&i915->drm, !pll))\n\t\treturn;\n\n\tintel_de_write(i915, DDI_CLK_SEL(port),\n\t\t       icl_pll_to_ddi_clk_sel(encoder, crtc_state));\n\n\tmutex_lock(&i915->display.dpll.lock);\n\n\tintel_de_rmw(i915, ICL_DPCLKA_CFGCR0,\n\t\t     ICL_DPCLKA_CFGCR0_TC_CLK_OFF(tc_port), 0);\n\n\tmutex_unlock(&i915->display.dpll.lock);\n}\n\nstatic void icl_ddi_tc_disable_clock(struct intel_encoder *encoder)\n{\n\tstruct drm_i915_private *i915 = to_i915(encoder->base.dev);\n\tenum tc_port tc_port = intel_port_to_tc(i915, encoder->port);\n\tenum port port = encoder->port;\n\n\tmutex_lock(&i915->display.dpll.lock);\n\n\tintel_de_rmw(i915, ICL_DPCLKA_CFGCR0,\n\t\t     0, ICL_DPCLKA_CFGCR0_TC_CLK_OFF(tc_port));\n\n\tmutex_unlock(&i915->display.dpll.lock);\n\n\tintel_de_write(i915, DDI_CLK_SEL(port), DDI_CLK_SEL_NONE);\n}\n\nstatic bool icl_ddi_tc_is_clock_enabled(struct intel_encoder *encoder)\n{\n\tstruct drm_i915_private *i915 = to_i915(encoder->base.dev);\n\tenum tc_port tc_port = intel_port_to_tc(i915, encoder->port);\n\tenum port port = encoder->port;\n\tu32 tmp;\n\n\ttmp = intel_de_read(i915, DDI_CLK_SEL(port));\n\n\tif ((tmp & DDI_CLK_SEL_MASK) == DDI_CLK_SEL_NONE)\n\t\treturn false;\n\n\ttmp = intel_de_read(i915, ICL_DPCLKA_CFGCR0);\n\n\treturn !(tmp & ICL_DPCLKA_CFGCR0_TC_CLK_OFF(tc_port));\n}\n\nstatic struct intel_shared_dpll *icl_ddi_tc_get_pll(struct intel_encoder *encoder)\n{\n\tstruct drm_i915_private *i915 = to_i915(encoder->base.dev);\n\tenum tc_port tc_port = intel_port_to_tc(i915, encoder->port);\n\tenum port port = encoder->port;\n\tenum intel_dpll_id id;\n\tu32 tmp;\n\n\ttmp = intel_de_read(i915, DDI_CLK_SEL(port));\n\n\tswitch (tmp & DDI_CLK_SEL_MASK) {\n\tcase DDI_CLK_SEL_TBT_162:\n\tcase DDI_CLK_SEL_TBT_270:\n\tcase DDI_CLK_SEL_TBT_540:\n\tcase DDI_CLK_SEL_TBT_810:\n\t\tid = DPLL_ID_ICL_TBTPLL;\n\t\tbreak;\n\tcase DDI_CLK_SEL_MG:\n\t\tid = icl_tc_port_to_pll_id(tc_port);\n\t\tbreak;\n\tdefault:\n\t\tMISSING_CASE(tmp);\n\t\tfallthrough;\n\tcase DDI_CLK_SEL_NONE:\n\t\treturn NULL;\n\t}\n\n\treturn intel_get_shared_dpll_by_id(i915, id);\n}\n\nstatic struct intel_shared_dpll *bxt_ddi_get_pll(struct intel_encoder *encoder)\n{\n\tstruct drm_i915_private *i915 = to_i915(encoder->base.dev);\n\tenum intel_dpll_id id;\n\n\tswitch (encoder->port) {\n\tcase PORT_A:\n\t\tid = DPLL_ID_SKL_DPLL0;\n\t\tbreak;\n\tcase PORT_B:\n\t\tid = DPLL_ID_SKL_DPLL1;\n\t\tbreak;\n\tcase PORT_C:\n\t\tid = DPLL_ID_SKL_DPLL2;\n\t\tbreak;\n\tdefault:\n\t\tMISSING_CASE(encoder->port);\n\t\treturn NULL;\n\t}\n\n\treturn intel_get_shared_dpll_by_id(i915, id);\n}\n\nstatic void skl_ddi_enable_clock(struct intel_encoder *encoder,\n\t\t\t\t const struct intel_crtc_state *crtc_state)\n{\n\tstruct drm_i915_private *i915 = to_i915(encoder->base.dev);\n\tconst struct intel_shared_dpll *pll = crtc_state->shared_dpll;\n\tenum port port = encoder->port;\n\n\tif (drm_WARN_ON(&i915->drm, !pll))\n\t\treturn;\n\n\tmutex_lock(&i915->display.dpll.lock);\n\n\tintel_de_rmw(i915, DPLL_CTRL2,\n\t\t     DPLL_CTRL2_DDI_CLK_OFF(port) |\n\t\t     DPLL_CTRL2_DDI_CLK_SEL_MASK(port),\n\t\t     DPLL_CTRL2_DDI_CLK_SEL(pll->info->id, port) |\n\t\t     DPLL_CTRL2_DDI_SEL_OVERRIDE(port));\n\n\tmutex_unlock(&i915->display.dpll.lock);\n}\n\nstatic void skl_ddi_disable_clock(struct intel_encoder *encoder)\n{\n\tstruct drm_i915_private *i915 = to_i915(encoder->base.dev);\n\tenum port port = encoder->port;\n\n\tmutex_lock(&i915->display.dpll.lock);\n\n\tintel_de_rmw(i915, DPLL_CTRL2,\n\t\t     0, DPLL_CTRL2_DDI_CLK_OFF(port));\n\n\tmutex_unlock(&i915->display.dpll.lock);\n}\n\nstatic bool skl_ddi_is_clock_enabled(struct intel_encoder *encoder)\n{\n\tstruct drm_i915_private *i915 = to_i915(encoder->base.dev);\n\tenum port port = encoder->port;\n\n\t \n\treturn !(intel_de_read(i915, DPLL_CTRL2) & DPLL_CTRL2_DDI_CLK_OFF(port));\n}\n\nstatic struct intel_shared_dpll *skl_ddi_get_pll(struct intel_encoder *encoder)\n{\n\tstruct drm_i915_private *i915 = to_i915(encoder->base.dev);\n\tenum port port = encoder->port;\n\tenum intel_dpll_id id;\n\tu32 tmp;\n\n\ttmp = intel_de_read(i915, DPLL_CTRL2);\n\n\t \n\tif ((tmp & DPLL_CTRL2_DDI_SEL_OVERRIDE(port)) == 0)\n\t\treturn NULL;\n\n\tid = (tmp & DPLL_CTRL2_DDI_CLK_SEL_MASK(port)) >>\n\t\tDPLL_CTRL2_DDI_CLK_SEL_SHIFT(port);\n\n\treturn intel_get_shared_dpll_by_id(i915, id);\n}\n\nvoid hsw_ddi_enable_clock(struct intel_encoder *encoder,\n\t\t\t  const struct intel_crtc_state *crtc_state)\n{\n\tstruct drm_i915_private *i915 = to_i915(encoder->base.dev);\n\tconst struct intel_shared_dpll *pll = crtc_state->shared_dpll;\n\tenum port port = encoder->port;\n\n\tif (drm_WARN_ON(&i915->drm, !pll))\n\t\treturn;\n\n\tintel_de_write(i915, PORT_CLK_SEL(port), hsw_pll_to_ddi_pll_sel(pll));\n}\n\nvoid hsw_ddi_disable_clock(struct intel_encoder *encoder)\n{\n\tstruct drm_i915_private *i915 = to_i915(encoder->base.dev);\n\tenum port port = encoder->port;\n\n\tintel_de_write(i915, PORT_CLK_SEL(port), PORT_CLK_SEL_NONE);\n}\n\nbool hsw_ddi_is_clock_enabled(struct intel_encoder *encoder)\n{\n\tstruct drm_i915_private *i915 = to_i915(encoder->base.dev);\n\tenum port port = encoder->port;\n\n\treturn intel_de_read(i915, PORT_CLK_SEL(port)) != PORT_CLK_SEL_NONE;\n}\n\nstatic struct intel_shared_dpll *hsw_ddi_get_pll(struct intel_encoder *encoder)\n{\n\tstruct drm_i915_private *i915 = to_i915(encoder->base.dev);\n\tenum port port = encoder->port;\n\tenum intel_dpll_id id;\n\tu32 tmp;\n\n\ttmp = intel_de_read(i915, PORT_CLK_SEL(port));\n\n\tswitch (tmp & PORT_CLK_SEL_MASK) {\n\tcase PORT_CLK_SEL_WRPLL1:\n\t\tid = DPLL_ID_WRPLL1;\n\t\tbreak;\n\tcase PORT_CLK_SEL_WRPLL2:\n\t\tid = DPLL_ID_WRPLL2;\n\t\tbreak;\n\tcase PORT_CLK_SEL_SPLL:\n\t\tid = DPLL_ID_SPLL;\n\t\tbreak;\n\tcase PORT_CLK_SEL_LCPLL_810:\n\t\tid = DPLL_ID_LCPLL_810;\n\t\tbreak;\n\tcase PORT_CLK_SEL_LCPLL_1350:\n\t\tid = DPLL_ID_LCPLL_1350;\n\t\tbreak;\n\tcase PORT_CLK_SEL_LCPLL_2700:\n\t\tid = DPLL_ID_LCPLL_2700;\n\t\tbreak;\n\tdefault:\n\t\tMISSING_CASE(tmp);\n\t\tfallthrough;\n\tcase PORT_CLK_SEL_NONE:\n\t\treturn NULL;\n\t}\n\n\treturn intel_get_shared_dpll_by_id(i915, id);\n}\n\nvoid intel_ddi_enable_clock(struct intel_encoder *encoder,\n\t\t\t    const struct intel_crtc_state *crtc_state)\n{\n\tif (encoder->enable_clock)\n\t\tencoder->enable_clock(encoder, crtc_state);\n}\n\nvoid intel_ddi_disable_clock(struct intel_encoder *encoder)\n{\n\tif (encoder->disable_clock)\n\t\tencoder->disable_clock(encoder);\n}\n\nvoid intel_ddi_sanitize_encoder_pll_mapping(struct intel_encoder *encoder)\n{\n\tstruct drm_i915_private *i915 = to_i915(encoder->base.dev);\n\tu32 port_mask;\n\tbool ddi_clk_needed;\n\n\t \n\tif (encoder->type == INTEL_OUTPUT_DP_MST)\n\t\treturn;\n\n\tif (!encoder->base.crtc && intel_encoder_is_dp(encoder)) {\n\t\tu8 pipe_mask;\n\t\tbool is_mst;\n\n\t\tintel_ddi_get_encoder_pipes(encoder, &pipe_mask, &is_mst);\n\t\t \n\t\tif (drm_WARN_ON(&i915->drm, is_mst))\n\t\t\treturn;\n\t}\n\n\tport_mask = BIT(encoder->port);\n\tddi_clk_needed = encoder->base.crtc;\n\n\tif (encoder->type == INTEL_OUTPUT_DSI) {\n\t\tstruct intel_encoder *other_encoder;\n\n\t\tport_mask = intel_dsi_encoder_ports(encoder);\n\t\t \n\t\tfor_each_intel_encoder(&i915->drm, other_encoder) {\n\t\t\tif (other_encoder == encoder)\n\t\t\t\tcontinue;\n\n\t\t\tif (drm_WARN_ON(&i915->drm,\n\t\t\t\t\tport_mask & BIT(other_encoder->port)))\n\t\t\t\treturn;\n\t\t}\n\t\t \n\t\tddi_clk_needed = false;\n\t}\n\n\tif (ddi_clk_needed || !encoder->is_clock_enabled ||\n\t    !encoder->is_clock_enabled(encoder))\n\t\treturn;\n\n\tdrm_notice(&i915->drm,\n\t\t   \"[ENCODER:%d:%s] is disabled/in DSI mode with an ungated DDI clock, gate it\\n\",\n\t\t   encoder->base.base.id, encoder->base.name);\n\n\tencoder->disable_clock(encoder);\n}\n\nstatic void\nicl_program_mg_dp_mode(struct intel_digital_port *dig_port,\n\t\t       const struct intel_crtc_state *crtc_state)\n{\n\tstruct drm_i915_private *dev_priv = to_i915(dig_port->base.base.dev);\n\tenum tc_port tc_port = intel_port_to_tc(dev_priv, dig_port->base.port);\n\tenum phy phy = intel_port_to_phy(dev_priv, dig_port->base.port);\n\tu32 ln0, ln1, pin_assignment;\n\tu8 width;\n\n\tif (!intel_phy_is_tc(dev_priv, phy) ||\n\t    intel_tc_port_in_tbt_alt_mode(dig_port))\n\t\treturn;\n\n\tif (DISPLAY_VER(dev_priv) >= 12) {\n\t\tln0 = intel_dkl_phy_read(dev_priv, DKL_DP_MODE(tc_port, 0));\n\t\tln1 = intel_dkl_phy_read(dev_priv, DKL_DP_MODE(tc_port, 1));\n\t} else {\n\t\tln0 = intel_de_read(dev_priv, MG_DP_MODE(0, tc_port));\n\t\tln1 = intel_de_read(dev_priv, MG_DP_MODE(1, tc_port));\n\t}\n\n\tln0 &= ~(MG_DP_MODE_CFG_DP_X1_MODE | MG_DP_MODE_CFG_DP_X2_MODE);\n\tln1 &= ~(MG_DP_MODE_CFG_DP_X1_MODE | MG_DP_MODE_CFG_DP_X2_MODE);\n\n\t \n\tpin_assignment = intel_tc_port_get_pin_assignment_mask(dig_port);\n\twidth = crtc_state->lane_count;\n\n\tswitch (pin_assignment) {\n\tcase 0x0:\n\t\tdrm_WARN_ON(&dev_priv->drm,\n\t\t\t    !intel_tc_port_in_legacy_mode(dig_port));\n\t\tif (width == 1) {\n\t\t\tln1 |= MG_DP_MODE_CFG_DP_X1_MODE;\n\t\t} else {\n\t\t\tln0 |= MG_DP_MODE_CFG_DP_X2_MODE;\n\t\t\tln1 |= MG_DP_MODE_CFG_DP_X2_MODE;\n\t\t}\n\t\tbreak;\n\tcase 0x1:\n\t\tif (width == 4) {\n\t\t\tln0 |= MG_DP_MODE_CFG_DP_X2_MODE;\n\t\t\tln1 |= MG_DP_MODE_CFG_DP_X2_MODE;\n\t\t}\n\t\tbreak;\n\tcase 0x2:\n\t\tif (width == 2) {\n\t\t\tln0 |= MG_DP_MODE_CFG_DP_X2_MODE;\n\t\t\tln1 |= MG_DP_MODE_CFG_DP_X2_MODE;\n\t\t}\n\t\tbreak;\n\tcase 0x3:\n\tcase 0x5:\n\t\tif (width == 1) {\n\t\t\tln0 |= MG_DP_MODE_CFG_DP_X1_MODE;\n\t\t\tln1 |= MG_DP_MODE_CFG_DP_X1_MODE;\n\t\t} else {\n\t\t\tln0 |= MG_DP_MODE_CFG_DP_X2_MODE;\n\t\t\tln1 |= MG_DP_MODE_CFG_DP_X2_MODE;\n\t\t}\n\t\tbreak;\n\tcase 0x4:\n\tcase 0x6:\n\t\tif (width == 1) {\n\t\t\tln0 |= MG_DP_MODE_CFG_DP_X1_MODE;\n\t\t\tln1 |= MG_DP_MODE_CFG_DP_X1_MODE;\n\t\t} else {\n\t\t\tln0 |= MG_DP_MODE_CFG_DP_X2_MODE;\n\t\t\tln1 |= MG_DP_MODE_CFG_DP_X2_MODE;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tMISSING_CASE(pin_assignment);\n\t}\n\n\tif (DISPLAY_VER(dev_priv) >= 12) {\n\t\tintel_dkl_phy_write(dev_priv, DKL_DP_MODE(tc_port, 0), ln0);\n\t\tintel_dkl_phy_write(dev_priv, DKL_DP_MODE(tc_port, 1), ln1);\n\t} else {\n\t\tintel_de_write(dev_priv, MG_DP_MODE(0, tc_port), ln0);\n\t\tintel_de_write(dev_priv, MG_DP_MODE(1, tc_port), ln1);\n\t}\n}\n\nstatic enum transcoder\ntgl_dp_tp_transcoder(const struct intel_crtc_state *crtc_state)\n{\n\tif (intel_crtc_has_type(crtc_state, INTEL_OUTPUT_DP_MST))\n\t\treturn crtc_state->mst_master_transcoder;\n\telse\n\t\treturn crtc_state->cpu_transcoder;\n}\n\ni915_reg_t dp_tp_ctl_reg(struct intel_encoder *encoder,\n\t\t\t const struct intel_crtc_state *crtc_state)\n{\n\tstruct drm_i915_private *dev_priv = to_i915(encoder->base.dev);\n\n\tif (DISPLAY_VER(dev_priv) >= 12)\n\t\treturn TGL_DP_TP_CTL(tgl_dp_tp_transcoder(crtc_state));\n\telse\n\t\treturn DP_TP_CTL(encoder->port);\n}\n\ni915_reg_t dp_tp_status_reg(struct intel_encoder *encoder,\n\t\t\t    const struct intel_crtc_state *crtc_state)\n{\n\tstruct drm_i915_private *dev_priv = to_i915(encoder->base.dev);\n\n\tif (DISPLAY_VER(dev_priv) >= 12)\n\t\treturn TGL_DP_TP_STATUS(tgl_dp_tp_transcoder(crtc_state));\n\telse\n\t\treturn DP_TP_STATUS(encoder->port);\n}\n\nstatic void intel_dp_sink_set_msa_timing_par_ignore_state(struct intel_dp *intel_dp,\n\t\t\t\t\t\t\t  const struct intel_crtc_state *crtc_state,\n\t\t\t\t\t\t\t  bool enable)\n{\n\tstruct drm_i915_private *i915 = dp_to_i915(intel_dp);\n\n\tif (!crtc_state->vrr.enable)\n\t\treturn;\n\n\tif (drm_dp_dpcd_writeb(&intel_dp->aux, DP_DOWNSPREAD_CTRL,\n\t\t\t       enable ? DP_MSA_TIMING_PAR_IGNORE_EN : 0) <= 0)\n\t\tdrm_dbg_kms(&i915->drm,\n\t\t\t    \"Failed to %s MSA_TIMING_PAR_IGNORE in the sink\\n\",\n\t\t\t    str_enable_disable(enable));\n}\n\nstatic void intel_dp_sink_set_fec_ready(struct intel_dp *intel_dp,\n\t\t\t\t\tconst struct intel_crtc_state *crtc_state)\n{\n\tstruct drm_i915_private *i915 = dp_to_i915(intel_dp);\n\n\tif (!crtc_state->fec_enable)\n\t\treturn;\n\n\tif (drm_dp_dpcd_writeb(&intel_dp->aux, DP_FEC_CONFIGURATION, DP_FEC_READY) <= 0)\n\t\tdrm_dbg_kms(&i915->drm,\n\t\t\t    \"Failed to set FEC_READY in the sink\\n\");\n}\n\nstatic void intel_ddi_enable_fec(struct intel_encoder *encoder,\n\t\t\t\t const struct intel_crtc_state *crtc_state)\n{\n\tstruct drm_i915_private *dev_priv = to_i915(encoder->base.dev);\n\n\tif (!crtc_state->fec_enable)\n\t\treturn;\n\n\tintel_de_rmw(dev_priv, dp_tp_ctl_reg(encoder, crtc_state),\n\t\t     0, DP_TP_CTL_FEC_ENABLE);\n}\n\nstatic void intel_ddi_disable_fec_state(struct intel_encoder *encoder,\n\t\t\t\t\tconst struct intel_crtc_state *crtc_state)\n{\n\tstruct drm_i915_private *dev_priv = to_i915(encoder->base.dev);\n\n\tif (!crtc_state->fec_enable)\n\t\treturn;\n\n\tintel_de_rmw(dev_priv, dp_tp_ctl_reg(encoder, crtc_state),\n\t\t     DP_TP_CTL_FEC_ENABLE, 0);\n\tintel_de_posting_read(dev_priv, dp_tp_ctl_reg(encoder, crtc_state));\n}\n\nstatic void intel_ddi_power_up_lanes(struct intel_encoder *encoder,\n\t\t\t\t     const struct intel_crtc_state *crtc_state)\n{\n\tstruct drm_i915_private *i915 = to_i915(encoder->base.dev);\n\tstruct intel_digital_port *dig_port = enc_to_dig_port(encoder);\n\tenum phy phy = intel_port_to_phy(i915, encoder->port);\n\n\tif (intel_phy_is_combo(i915, phy)) {\n\t\tbool lane_reversal =\n\t\t\tdig_port->saved_port_bits & DDI_BUF_PORT_REVERSAL;\n\n\t\tintel_combo_phy_power_up_lanes(i915, phy, false,\n\t\t\t\t\t       crtc_state->lane_count,\n\t\t\t\t\t       lane_reversal);\n\t}\n}\n\n \nstatic u8 intel_ddi_splitter_pipe_mask(struct drm_i915_private *i915)\n{\n\tif (IS_ALDERLAKE_P(i915))\n\t\treturn BIT(PIPE_A) | BIT(PIPE_B);\n\telse\n\t\treturn BIT(PIPE_A);\n}\n\nstatic void intel_ddi_mso_get_config(struct intel_encoder *encoder,\n\t\t\t\t     struct intel_crtc_state *pipe_config)\n{\n\tstruct intel_crtc *crtc = to_intel_crtc(pipe_config->uapi.crtc);\n\tstruct drm_i915_private *i915 = to_i915(crtc->base.dev);\n\tenum pipe pipe = crtc->pipe;\n\tu32 dss1;\n\n\tif (!HAS_MSO(i915))\n\t\treturn;\n\n\tdss1 = intel_de_read(i915, ICL_PIPE_DSS_CTL1(pipe));\n\n\tpipe_config->splitter.enable = dss1 & SPLITTER_ENABLE;\n\tif (!pipe_config->splitter.enable)\n\t\treturn;\n\n\tif (drm_WARN_ON(&i915->drm, !(intel_ddi_splitter_pipe_mask(i915) & BIT(pipe)))) {\n\t\tpipe_config->splitter.enable = false;\n\t\treturn;\n\t}\n\n\tswitch (dss1 & SPLITTER_CONFIGURATION_MASK) {\n\tdefault:\n\t\tdrm_WARN(&i915->drm, true,\n\t\t\t \"Invalid splitter configuration, dss1=0x%08x\\n\", dss1);\n\t\tfallthrough;\n\tcase SPLITTER_CONFIGURATION_2_SEGMENT:\n\t\tpipe_config->splitter.link_count = 2;\n\t\tbreak;\n\tcase SPLITTER_CONFIGURATION_4_SEGMENT:\n\t\tpipe_config->splitter.link_count = 4;\n\t\tbreak;\n\t}\n\n\tpipe_config->splitter.pixel_overlap = REG_FIELD_GET(OVERLAP_PIXELS_MASK, dss1);\n}\n\nstatic void intel_ddi_mso_configure(const struct intel_crtc_state *crtc_state)\n{\n\tstruct intel_crtc *crtc = to_intel_crtc(crtc_state->uapi.crtc);\n\tstruct drm_i915_private *i915 = to_i915(crtc->base.dev);\n\tenum pipe pipe = crtc->pipe;\n\tu32 dss1 = 0;\n\n\tif (!HAS_MSO(i915))\n\t\treturn;\n\n\tif (crtc_state->splitter.enable) {\n\t\tdss1 |= SPLITTER_ENABLE;\n\t\tdss1 |= OVERLAP_PIXELS(crtc_state->splitter.pixel_overlap);\n\t\tif (crtc_state->splitter.link_count == 2)\n\t\t\tdss1 |= SPLITTER_CONFIGURATION_2_SEGMENT;\n\t\telse\n\t\t\tdss1 |= SPLITTER_CONFIGURATION_4_SEGMENT;\n\t}\n\n\tintel_de_rmw(i915, ICL_PIPE_DSS_CTL1(pipe),\n\t\t     SPLITTER_ENABLE | SPLITTER_CONFIGURATION_MASK |\n\t\t     OVERLAP_PIXELS_MASK, dss1);\n}\n\nstatic u8 mtl_get_port_width(u8 lane_count)\n{\n\tswitch (lane_count) {\n\tcase 1:\n\t\treturn 0;\n\tcase 2:\n\t\treturn 1;\n\tcase 3:\n\t\treturn 4;\n\tcase 4:\n\t\treturn 3;\n\tdefault:\n\t\tMISSING_CASE(lane_count);\n\t\treturn 4;\n\t}\n}\n\nstatic void\nmtl_ddi_enable_d2d(struct intel_encoder *encoder)\n{\n\tstruct drm_i915_private *dev_priv = to_i915(encoder->base.dev);\n\tenum port port = encoder->port;\n\n\tintel_de_rmw(dev_priv, XELPDP_PORT_BUF_CTL1(port), 0,\n\t\t     XELPDP_PORT_BUF_D2D_LINK_ENABLE);\n\n\tif (wait_for_us((intel_de_read(dev_priv, XELPDP_PORT_BUF_CTL1(port)) &\n\t\t\t XELPDP_PORT_BUF_D2D_LINK_STATE), 100)) {\n\t\tdrm_err(&dev_priv->drm, \"Timeout waiting for D2D Link enable for PORT_BUF_CTL %c\\n\",\n\t\t\tport_name(port));\n\t}\n}\n\nstatic void mtl_port_buf_ctl_program(struct intel_encoder *encoder,\n\t\t\t\t     const struct intel_crtc_state *crtc_state)\n{\n\tstruct drm_i915_private *i915 = to_i915(encoder->base.dev);\n\tstruct intel_digital_port *dig_port = enc_to_dig_port(encoder);\n\tenum port port = encoder->port;\n\tu32 val;\n\n\tval = intel_de_read(i915, XELPDP_PORT_BUF_CTL1(port));\n\tval &= ~XELPDP_PORT_WIDTH_MASK;\n\tval |= XELPDP_PORT_WIDTH(mtl_get_port_width(crtc_state->lane_count));\n\n\tval &= ~XELPDP_PORT_BUF_PORT_DATA_WIDTH_MASK;\n\tif (intel_dp_is_uhbr(crtc_state))\n\t\tval |= XELPDP_PORT_BUF_PORT_DATA_40BIT;\n\telse\n\t\tval |= XELPDP_PORT_BUF_PORT_DATA_10BIT;\n\n\tif (dig_port->saved_port_bits & DDI_BUF_PORT_REVERSAL)\n\t\tval |= XELPDP_PORT_REVERSAL;\n\n\tintel_de_write(i915, XELPDP_PORT_BUF_CTL1(port), val);\n}\n\nstatic void mtl_port_buf_ctl_io_selection(struct intel_encoder *encoder)\n{\n\tstruct drm_i915_private *i915 = to_i915(encoder->base.dev);\n\tstruct intel_digital_port *dig_port = enc_to_dig_port(encoder);\n\tu32 val;\n\n\tval = intel_tc_port_in_tbt_alt_mode(dig_port) ?\n\t      XELPDP_PORT_BUF_IO_SELECT_TBT : 0;\n\tintel_de_rmw(i915, XELPDP_PORT_BUF_CTL1(encoder->port),\n\t\t     XELPDP_PORT_BUF_IO_SELECT_TBT, val);\n}\n\nstatic void mtl_ddi_pre_enable_dp(struct intel_atomic_state *state,\n\t\t\t\t  struct intel_encoder *encoder,\n\t\t\t\t  const struct intel_crtc_state *crtc_state,\n\t\t\t\t  const struct drm_connector_state *conn_state)\n{\n\tstruct intel_dp *intel_dp = enc_to_intel_dp(encoder);\n\tbool is_mst = intel_crtc_has_type(crtc_state, INTEL_OUTPUT_DP_MST);\n\n\tintel_dp_set_link_params(intel_dp,\n\t\t\t\t crtc_state->port_clock,\n\t\t\t\t crtc_state->lane_count);\n\n\t \n\tintel_ddi_init_dp_buf_reg(encoder, crtc_state);\n\n\t \n\n\t \n\n\t \n\tmtl_port_buf_ctl_io_selection(encoder);\n\n\t \n\tintel_pps_on(intel_dp);\n\n\t \n\tintel_ddi_enable_clock(encoder, crtc_state);\n\n\t \n\tintel_ddi_enable_transcoder_clock(encoder, crtc_state);\n\n\t \n\tintel_ddi_config_transcoder_dp2(encoder, crtc_state);\n\n\t \n\tintel_ddi_config_transcoder_func(encoder, crtc_state);\n\n\t \n\tintel_ddi_mso_configure(crtc_state);\n\n\tif (!is_mst)\n\t\tintel_dp_set_power(intel_dp, DP_SET_POWER_D0);\n\n\tintel_dp_configure_protocol_converter(intel_dp, crtc_state);\n\tintel_dp_sink_set_decompression_state(intel_dp, crtc_state, true);\n\t \n\tintel_dp_sink_set_fec_ready(intel_dp, crtc_state);\n\n\tintel_dp_check_frl_training(intel_dp);\n\tintel_dp_pcon_dsc_configure(intel_dp, crtc_state);\n\n\t \n\tintel_dp_start_link_train(intel_dp, crtc_state);\n\n\t \n\tif (!is_trans_port_sync_mode(crtc_state))\n\t\tintel_dp_stop_link_train(intel_dp, crtc_state);\n\n\t \n\tintel_ddi_enable_fec(encoder, crtc_state);\n\n\tintel_dsc_dp_pps_write(encoder, crtc_state);\n}\n\nstatic void tgl_ddi_pre_enable_dp(struct intel_atomic_state *state,\n\t\t\t\t  struct intel_encoder *encoder,\n\t\t\t\t  const struct intel_crtc_state *crtc_state,\n\t\t\t\t  const struct drm_connector_state *conn_state)\n{\n\tstruct intel_dp *intel_dp = enc_to_intel_dp(encoder);\n\tstruct drm_i915_private *dev_priv = to_i915(encoder->base.dev);\n\tstruct intel_digital_port *dig_port = enc_to_dig_port(encoder);\n\tbool is_mst = intel_crtc_has_type(crtc_state, INTEL_OUTPUT_DP_MST);\n\n\tintel_dp_set_link_params(intel_dp,\n\t\t\t\t crtc_state->port_clock,\n\t\t\t\t crtc_state->lane_count);\n\n\t \n\tintel_ddi_init_dp_buf_reg(encoder, crtc_state);\n\n\t \n\n\t \n\tintel_pps_on(intel_dp);\n\n\t \n\n\t \n\tintel_ddi_enable_clock(encoder, crtc_state);\n\n\t \n\tif (!intel_tc_port_in_tbt_alt_mode(dig_port)) {\n\t\tdrm_WARN_ON(&dev_priv->drm, dig_port->ddi_io_wakeref);\n\t\tdig_port->ddi_io_wakeref = intel_display_power_get(dev_priv,\n\t\t\t\t\t\t\t\t   dig_port->ddi_io_power_domain);\n\t}\n\n\t \n\ticl_program_mg_dp_mode(dig_port, crtc_state);\n\n\t \n\n\t \n\tintel_ddi_enable_transcoder_clock(encoder, crtc_state);\n\n\tif (HAS_DP20(dev_priv))\n\t\tintel_ddi_config_transcoder_dp2(encoder, crtc_state);\n\n\t \n\tintel_ddi_config_transcoder_func(encoder, crtc_state);\n\n\t \n\n\t \n\tencoder->set_signal_levels(encoder, crtc_state);\n\n\t \n\tintel_ddi_power_up_lanes(encoder, crtc_state);\n\n\t \n\tintel_ddi_mso_configure(crtc_state);\n\n\tif (!is_mst)\n\t\tintel_dp_set_power(intel_dp, DP_SET_POWER_D0);\n\n\tintel_dp_configure_protocol_converter(intel_dp, crtc_state);\n\tintel_dp_sink_set_decompression_state(intel_dp, crtc_state, true);\n\t \n\tintel_dp_sink_set_fec_ready(intel_dp, crtc_state);\n\n\tintel_dp_check_frl_training(intel_dp);\n\tintel_dp_pcon_dsc_configure(intel_dp, crtc_state);\n\n\t \n\tintel_dp_start_link_train(intel_dp, crtc_state);\n\n\t \n\tif (!is_trans_port_sync_mode(crtc_state))\n\t\tintel_dp_stop_link_train(intel_dp, crtc_state);\n\n\t \n\tintel_ddi_enable_fec(encoder, crtc_state);\n\n\tintel_dsc_dp_pps_write(encoder, crtc_state);\n}\n\nstatic void hsw_ddi_pre_enable_dp(struct intel_atomic_state *state,\n\t\t\t\t  struct intel_encoder *encoder,\n\t\t\t\t  const struct intel_crtc_state *crtc_state,\n\t\t\t\t  const struct drm_connector_state *conn_state)\n{\n\tstruct intel_dp *intel_dp = enc_to_intel_dp(encoder);\n\tstruct drm_i915_private *dev_priv = to_i915(encoder->base.dev);\n\tenum port port = encoder->port;\n\tstruct intel_digital_port *dig_port = enc_to_dig_port(encoder);\n\tbool is_mst = intel_crtc_has_type(crtc_state, INTEL_OUTPUT_DP_MST);\n\n\tif (DISPLAY_VER(dev_priv) < 11)\n\t\tdrm_WARN_ON(&dev_priv->drm,\n\t\t\t    is_mst && (port == PORT_A || port == PORT_E));\n\telse\n\t\tdrm_WARN_ON(&dev_priv->drm, is_mst && port == PORT_A);\n\n\tintel_dp_set_link_params(intel_dp,\n\t\t\t\t crtc_state->port_clock,\n\t\t\t\t crtc_state->lane_count);\n\n\t \n\tintel_ddi_init_dp_buf_reg(encoder, crtc_state);\n\n\tintel_pps_on(intel_dp);\n\n\tintel_ddi_enable_clock(encoder, crtc_state);\n\n\tif (!intel_tc_port_in_tbt_alt_mode(dig_port)) {\n\t\tdrm_WARN_ON(&dev_priv->drm, dig_port->ddi_io_wakeref);\n\t\tdig_port->ddi_io_wakeref = intel_display_power_get(dev_priv,\n\t\t\t\t\t\t\t\t   dig_port->ddi_io_power_domain);\n\t}\n\n\ticl_program_mg_dp_mode(dig_port, crtc_state);\n\n\tif (has_buf_trans_select(dev_priv))\n\t\thsw_prepare_dp_ddi_buffers(encoder, crtc_state);\n\n\tencoder->set_signal_levels(encoder, crtc_state);\n\n\tintel_ddi_power_up_lanes(encoder, crtc_state);\n\n\tif (!is_mst)\n\t\tintel_dp_set_power(intel_dp, DP_SET_POWER_D0);\n\tintel_dp_configure_protocol_converter(intel_dp, crtc_state);\n\tintel_dp_sink_set_decompression_state(intel_dp, crtc_state,\n\t\t\t\t\t      true);\n\tintel_dp_sink_set_fec_ready(intel_dp, crtc_state);\n\tintel_dp_start_link_train(intel_dp, crtc_state);\n\tif ((port != PORT_A || DISPLAY_VER(dev_priv) >= 9) &&\n\t    !is_trans_port_sync_mode(crtc_state))\n\t\tintel_dp_stop_link_train(intel_dp, crtc_state);\n\n\tintel_ddi_enable_fec(encoder, crtc_state);\n\n\tif (!is_mst)\n\t\tintel_ddi_enable_transcoder_clock(encoder, crtc_state);\n\n\tintel_dsc_dp_pps_write(encoder, crtc_state);\n}\n\nstatic void intel_ddi_pre_enable_dp(struct intel_atomic_state *state,\n\t\t\t\t    struct intel_encoder *encoder,\n\t\t\t\t    const struct intel_crtc_state *crtc_state,\n\t\t\t\t    const struct drm_connector_state *conn_state)\n{\n\tstruct drm_i915_private *dev_priv = to_i915(encoder->base.dev);\n\n\tif (HAS_DP20(dev_priv))\n\t\tintel_dp_128b132b_sdp_crc16(enc_to_intel_dp(encoder),\n\t\t\t\t\t    crtc_state);\n\n\tif (DISPLAY_VER(dev_priv) >= 14)\n\t\tmtl_ddi_pre_enable_dp(state, encoder, crtc_state, conn_state);\n\telse if (DISPLAY_VER(dev_priv) >= 12)\n\t\ttgl_ddi_pre_enable_dp(state, encoder, crtc_state, conn_state);\n\telse\n\t\thsw_ddi_pre_enable_dp(state, encoder, crtc_state, conn_state);\n\n\t \n\tif (!intel_crtc_has_type(crtc_state, INTEL_OUTPUT_DP_MST))\n\t\tintel_ddi_set_dp_msa(crtc_state, conn_state);\n}\n\nstatic void intel_ddi_pre_enable_hdmi(struct intel_atomic_state *state,\n\t\t\t\t      struct intel_encoder *encoder,\n\t\t\t\t      const struct intel_crtc_state *crtc_state,\n\t\t\t\t      const struct drm_connector_state *conn_state)\n{\n\tstruct intel_digital_port *dig_port = enc_to_dig_port(encoder);\n\tstruct intel_hdmi *intel_hdmi = &dig_port->hdmi;\n\tstruct drm_i915_private *dev_priv = to_i915(encoder->base.dev);\n\n\tintel_dp_dual_mode_set_tmds_output(intel_hdmi, true);\n\tintel_ddi_enable_clock(encoder, crtc_state);\n\n\tdrm_WARN_ON(&dev_priv->drm, dig_port->ddi_io_wakeref);\n\tdig_port->ddi_io_wakeref = intel_display_power_get(dev_priv,\n\t\t\t\t\t\t\t   dig_port->ddi_io_power_domain);\n\n\ticl_program_mg_dp_mode(dig_port, crtc_state);\n\n\tintel_ddi_enable_transcoder_clock(encoder, crtc_state);\n\n\tdig_port->set_infoframes(encoder,\n\t\t\t\t crtc_state->has_infoframe,\n\t\t\t\t crtc_state, conn_state);\n}\n\nstatic void intel_ddi_pre_enable(struct intel_atomic_state *state,\n\t\t\t\t struct intel_encoder *encoder,\n\t\t\t\t const struct intel_crtc_state *crtc_state,\n\t\t\t\t const struct drm_connector_state *conn_state)\n{\n\tstruct intel_crtc *crtc = to_intel_crtc(crtc_state->uapi.crtc);\n\tstruct drm_i915_private *dev_priv = to_i915(crtc->base.dev);\n\tenum pipe pipe = crtc->pipe;\n\n\t \n\n\tdrm_WARN_ON(&dev_priv->drm, crtc_state->has_pch_encoder);\n\n\tintel_set_cpu_fifo_underrun_reporting(dev_priv, pipe, true);\n\n\tif (intel_crtc_has_type(crtc_state, INTEL_OUTPUT_HDMI)) {\n\t\tintel_ddi_pre_enable_hdmi(state, encoder, crtc_state,\n\t\t\t\t\t  conn_state);\n\t} else {\n\t\tstruct intel_digital_port *dig_port = enc_to_dig_port(encoder);\n\n\t\tintel_ddi_pre_enable_dp(state, encoder, crtc_state,\n\t\t\t\t\tconn_state);\n\n\t\t \n\t\t \n\t\tif (dig_port->lspcon.active && intel_dp_has_hdmi_sink(&dig_port->dp))\n\t\t\tdig_port->set_infoframes(encoder,\n\t\t\t\t\t\t crtc_state->has_infoframe,\n\t\t\t\t\t\t crtc_state, conn_state);\n\t}\n}\n\nstatic void\nmtl_ddi_disable_d2d_link(struct intel_encoder *encoder)\n{\n\tstruct drm_i915_private *dev_priv = to_i915(encoder->base.dev);\n\tenum port port = encoder->port;\n\n\tintel_de_rmw(dev_priv, XELPDP_PORT_BUF_CTL1(port),\n\t\t     XELPDP_PORT_BUF_D2D_LINK_ENABLE, 0);\n\n\tif (wait_for_us(!(intel_de_read(dev_priv, XELPDP_PORT_BUF_CTL1(port)) &\n\t\t\t  XELPDP_PORT_BUF_D2D_LINK_STATE), 100))\n\t\tdrm_err(&dev_priv->drm, \"Timeout waiting for D2D Link disable for PORT_BUF_CTL %c\\n\",\n\t\t\tport_name(port));\n}\n\nstatic void mtl_disable_ddi_buf(struct intel_encoder *encoder,\n\t\t\t\tconst struct intel_crtc_state *crtc_state)\n{\n\tstruct drm_i915_private *dev_priv = to_i915(encoder->base.dev);\n\tenum port port = encoder->port;\n\tu32 val;\n\n\t \n\tval = intel_de_read(dev_priv, DDI_BUF_CTL(port));\n\tif (val & DDI_BUF_CTL_ENABLE) {\n\t\tval &= ~DDI_BUF_CTL_ENABLE;\n\t\tintel_de_write(dev_priv, DDI_BUF_CTL(port), val);\n\n\t\t \n\t\tmtl_wait_ddi_buf_idle(dev_priv, port);\n\t}\n\n\t \n\tmtl_ddi_disable_d2d_link(encoder);\n\n\t \n\tif (intel_crtc_has_dp_encoder(crtc_state)) {\n\t\tintel_de_rmw(dev_priv, dp_tp_ctl_reg(encoder, crtc_state),\n\t\t\t     DP_TP_CTL_ENABLE, 0);\n\t}\n}\n\nstatic void disable_ddi_buf(struct intel_encoder *encoder,\n\t\t\t    const struct intel_crtc_state *crtc_state)\n{\n\tstruct drm_i915_private *dev_priv = to_i915(encoder->base.dev);\n\tenum port port = encoder->port;\n\tbool wait = false;\n\tu32 val;\n\n\tval = intel_de_read(dev_priv, DDI_BUF_CTL(port));\n\tif (val & DDI_BUF_CTL_ENABLE) {\n\t\tval &= ~DDI_BUF_CTL_ENABLE;\n\t\tintel_de_write(dev_priv, DDI_BUF_CTL(port), val);\n\t\twait = true;\n\t}\n\n\tif (intel_crtc_has_dp_encoder(crtc_state))\n\t\tintel_de_rmw(dev_priv, dp_tp_ctl_reg(encoder, crtc_state),\n\t\t\t     DP_TP_CTL_ENABLE, 0);\n\n\t \n\tintel_ddi_disable_fec_state(encoder, crtc_state);\n\n\tif (wait)\n\t\tintel_wait_ddi_buf_idle(dev_priv, port);\n}\n\nstatic void intel_disable_ddi_buf(struct intel_encoder *encoder,\n\t\t\t\t  const struct intel_crtc_state *crtc_state)\n{\n\tstruct drm_i915_private *dev_priv = to_i915(encoder->base.dev);\n\n\tif (DISPLAY_VER(dev_priv) >= 14) {\n\t\tmtl_disable_ddi_buf(encoder, crtc_state);\n\n\t\t \n\t\tintel_ddi_disable_fec_state(encoder, crtc_state);\n\t} else {\n\t\tdisable_ddi_buf(encoder, crtc_state);\n\t}\n}\n\nstatic void intel_ddi_post_disable_dp(struct intel_atomic_state *state,\n\t\t\t\t      struct intel_encoder *encoder,\n\t\t\t\t      const struct intel_crtc_state *old_crtc_state,\n\t\t\t\t      const struct drm_connector_state *old_conn_state)\n{\n\tstruct drm_i915_private *dev_priv = to_i915(encoder->base.dev);\n\tstruct intel_digital_port *dig_port = enc_to_dig_port(encoder);\n\tstruct intel_dp *intel_dp = &dig_port->dp;\n\tintel_wakeref_t wakeref;\n\tbool is_mst = intel_crtc_has_type(old_crtc_state,\n\t\t\t\t\t  INTEL_OUTPUT_DP_MST);\n\n\tif (!is_mst)\n\t\tintel_dp_set_infoframes(encoder, false,\n\t\t\t\t\told_crtc_state, old_conn_state);\n\n\t \n\tintel_dp_set_power(intel_dp, DP_SET_POWER_D3);\n\n\tif (DISPLAY_VER(dev_priv) >= 12) {\n\t\tif (is_mst) {\n\t\t\tenum transcoder cpu_transcoder = old_crtc_state->cpu_transcoder;\n\n\t\t\tintel_de_rmw(dev_priv, TRANS_DDI_FUNC_CTL(cpu_transcoder),\n\t\t\t\t     TGL_TRANS_DDI_PORT_MASK | TRANS_DDI_MODE_SELECT_MASK,\n\t\t\t\t     0);\n\t\t}\n\t} else {\n\t\tif (!is_mst)\n\t\t\tintel_ddi_disable_transcoder_clock(old_crtc_state);\n\t}\n\n\tintel_disable_ddi_buf(encoder, old_crtc_state);\n\n\t \n\tif (DISPLAY_VER(dev_priv) >= 12)\n\t\tintel_ddi_disable_transcoder_clock(old_crtc_state);\n\n\tintel_pps_vdd_on(intel_dp);\n\tintel_pps_off(intel_dp);\n\n\twakeref = fetch_and_zero(&dig_port->ddi_io_wakeref);\n\n\tif (wakeref)\n\t\tintel_display_power_put(dev_priv,\n\t\t\t\t\tdig_port->ddi_io_power_domain,\n\t\t\t\t\twakeref);\n\n\tintel_ddi_disable_clock(encoder);\n\n\t \n\tif (DISPLAY_VER(dev_priv) >= 14)\n\t\tintel_de_rmw(dev_priv, XELPDP_PORT_BUF_CTL1(encoder->port),\n\t\t\t     XELPDP_PORT_BUF_IO_SELECT_TBT, 0);\n}\n\nstatic void intel_ddi_post_disable_hdmi(struct intel_atomic_state *state,\n\t\t\t\t\tstruct intel_encoder *encoder,\n\t\t\t\t\tconst struct intel_crtc_state *old_crtc_state,\n\t\t\t\t\tconst struct drm_connector_state *old_conn_state)\n{\n\tstruct drm_i915_private *dev_priv = to_i915(encoder->base.dev);\n\tstruct intel_digital_port *dig_port = enc_to_dig_port(encoder);\n\tstruct intel_hdmi *intel_hdmi = &dig_port->hdmi;\n\tintel_wakeref_t wakeref;\n\n\tdig_port->set_infoframes(encoder, false,\n\t\t\t\t old_crtc_state, old_conn_state);\n\n\tif (DISPLAY_VER(dev_priv) < 12)\n\t\tintel_ddi_disable_transcoder_clock(old_crtc_state);\n\n\tintel_disable_ddi_buf(encoder, old_crtc_state);\n\n\tif (DISPLAY_VER(dev_priv) >= 12)\n\t\tintel_ddi_disable_transcoder_clock(old_crtc_state);\n\n\twakeref = fetch_and_zero(&dig_port->ddi_io_wakeref);\n\tif (wakeref)\n\t\tintel_display_power_put(dev_priv,\n\t\t\t\t\tdig_port->ddi_io_power_domain,\n\t\t\t\t\twakeref);\n\n\tintel_ddi_disable_clock(encoder);\n\n\tintel_dp_dual_mode_set_tmds_output(intel_hdmi, false);\n}\n\nstatic void intel_ddi_post_disable(struct intel_atomic_state *state,\n\t\t\t\t   struct intel_encoder *encoder,\n\t\t\t\t   const struct intel_crtc_state *old_crtc_state,\n\t\t\t\t   const struct drm_connector_state *old_conn_state)\n{\n\tstruct drm_i915_private *dev_priv = to_i915(encoder->base.dev);\n\tstruct intel_crtc *slave_crtc;\n\n\tif (!intel_crtc_has_type(old_crtc_state, INTEL_OUTPUT_DP_MST)) {\n\t\tintel_crtc_vblank_off(old_crtc_state);\n\n\t\tintel_disable_transcoder(old_crtc_state);\n\n\t\tintel_ddi_disable_transcoder_func(old_crtc_state);\n\n\t\tintel_dsc_disable(old_crtc_state);\n\n\t\tif (DISPLAY_VER(dev_priv) >= 9)\n\t\t\tskl_scaler_disable(old_crtc_state);\n\t\telse\n\t\t\tilk_pfit_disable(old_crtc_state);\n\t}\n\n\tfor_each_intel_crtc_in_pipe_mask(&dev_priv->drm, slave_crtc,\n\t\t\t\t\t intel_crtc_bigjoiner_slave_pipes(old_crtc_state)) {\n\t\tconst struct intel_crtc_state *old_slave_crtc_state =\n\t\t\tintel_atomic_get_old_crtc_state(state, slave_crtc);\n\n\t\tintel_crtc_vblank_off(old_slave_crtc_state);\n\n\t\tintel_dsc_disable(old_slave_crtc_state);\n\t\tskl_scaler_disable(old_slave_crtc_state);\n\t}\n\n\t \n\n\tif (intel_crtc_has_type(old_crtc_state, INTEL_OUTPUT_HDMI))\n\t\tintel_ddi_post_disable_hdmi(state, encoder, old_crtc_state,\n\t\t\t\t\t    old_conn_state);\n\telse\n\t\tintel_ddi_post_disable_dp(state, encoder, old_crtc_state,\n\t\t\t\t\t  old_conn_state);\n}\n\nstatic void intel_ddi_post_pll_disable(struct intel_atomic_state *state,\n\t\t\t\t       struct intel_encoder *encoder,\n\t\t\t\t       const struct intel_crtc_state *old_crtc_state,\n\t\t\t\t       const struct drm_connector_state *old_conn_state)\n{\n\tstruct drm_i915_private *i915 = to_i915(encoder->base.dev);\n\tstruct intel_digital_port *dig_port = enc_to_dig_port(encoder);\n\tenum phy phy = intel_port_to_phy(i915, encoder->port);\n\tbool is_tc_port = intel_phy_is_tc(i915, phy);\n\n\tmain_link_aux_power_domain_put(dig_port, old_crtc_state);\n\n\tif (is_tc_port)\n\t\tintel_tc_port_put_link(dig_port);\n}\n\nstatic void trans_port_sync_stop_link_train(struct intel_atomic_state *state,\n\t\t\t\t\t    struct intel_encoder *encoder,\n\t\t\t\t\t    const struct intel_crtc_state *crtc_state)\n{\n\tconst struct drm_connector_state *conn_state;\n\tstruct drm_connector *conn;\n\tint i;\n\n\tif (!crtc_state->sync_mode_slaves_mask)\n\t\treturn;\n\n\tfor_each_new_connector_in_state(&state->base, conn, conn_state, i) {\n\t\tstruct intel_encoder *slave_encoder =\n\t\t\tto_intel_encoder(conn_state->best_encoder);\n\t\tstruct intel_crtc *slave_crtc = to_intel_crtc(conn_state->crtc);\n\t\tconst struct intel_crtc_state *slave_crtc_state;\n\n\t\tif (!slave_crtc)\n\t\t\tcontinue;\n\n\t\tslave_crtc_state =\n\t\t\tintel_atomic_get_new_crtc_state(state, slave_crtc);\n\n\t\tif (slave_crtc_state->master_transcoder !=\n\t\t    crtc_state->cpu_transcoder)\n\t\t\tcontinue;\n\n\t\tintel_dp_stop_link_train(enc_to_intel_dp(slave_encoder),\n\t\t\t\t\t slave_crtc_state);\n\t}\n\n\tusleep_range(200, 400);\n\n\tintel_dp_stop_link_train(enc_to_intel_dp(encoder),\n\t\t\t\t crtc_state);\n}\n\nstatic void intel_enable_ddi_dp(struct intel_atomic_state *state,\n\t\t\t\tstruct intel_encoder *encoder,\n\t\t\t\tconst struct intel_crtc_state *crtc_state,\n\t\t\t\tconst struct drm_connector_state *conn_state)\n{\n\tstruct drm_i915_private *dev_priv = to_i915(encoder->base.dev);\n\tstruct intel_dp *intel_dp = enc_to_intel_dp(encoder);\n\tstruct intel_digital_port *dig_port = enc_to_dig_port(encoder);\n\tenum port port = encoder->port;\n\n\tif (port == PORT_A && DISPLAY_VER(dev_priv) < 9)\n\t\tintel_dp_stop_link_train(intel_dp, crtc_state);\n\n\tdrm_connector_update_privacy_screen(conn_state);\n\tintel_edp_backlight_on(crtc_state, conn_state);\n\n\tif (!dig_port->lspcon.active || intel_dp_has_hdmi_sink(&dig_port->dp))\n\t\tintel_dp_set_infoframes(encoder, true, crtc_state, conn_state);\n\n\tintel_audio_codec_enable(encoder, crtc_state, conn_state);\n\n\ttrans_port_sync_stop_link_train(state, encoder, crtc_state);\n}\n\nstatic i915_reg_t\ngen9_chicken_trans_reg_by_port(struct drm_i915_private *dev_priv,\n\t\t\t       enum port port)\n{\n\tstatic const enum transcoder trans[] = {\n\t\t[PORT_A] = TRANSCODER_EDP,\n\t\t[PORT_B] = TRANSCODER_A,\n\t\t[PORT_C] = TRANSCODER_B,\n\t\t[PORT_D] = TRANSCODER_C,\n\t\t[PORT_E] = TRANSCODER_A,\n\t};\n\n\tdrm_WARN_ON(&dev_priv->drm, DISPLAY_VER(dev_priv) < 9);\n\n\tif (drm_WARN_ON(&dev_priv->drm, port < PORT_A || port > PORT_E))\n\t\tport = PORT_A;\n\n\treturn CHICKEN_TRANS(trans[port]);\n}\n\nstatic void intel_enable_ddi_hdmi(struct intel_atomic_state *state,\n\t\t\t\t  struct intel_encoder *encoder,\n\t\t\t\t  const struct intel_crtc_state *crtc_state,\n\t\t\t\t  const struct drm_connector_state *conn_state)\n{\n\tstruct drm_i915_private *dev_priv = to_i915(encoder->base.dev);\n\tstruct intel_digital_port *dig_port = enc_to_dig_port(encoder);\n\tstruct drm_connector *connector = conn_state->connector;\n\tenum port port = encoder->port;\n\tenum phy phy = intel_port_to_phy(dev_priv, port);\n\tu32 buf_ctl;\n\n\tif (!intel_hdmi_handle_sink_scrambling(encoder, connector,\n\t\t\t\t\t       crtc_state->hdmi_high_tmds_clock_ratio,\n\t\t\t\t\t       crtc_state->hdmi_scrambling))\n\t\tdrm_dbg_kms(&dev_priv->drm,\n\t\t\t    \"[CONNECTOR:%d:%s] Failed to configure sink scrambling/TMDS bit clock ratio\\n\",\n\t\t\t    connector->base.id, connector->name);\n\n\tif (has_buf_trans_select(dev_priv))\n\t\thsw_prepare_hdmi_ddi_buffers(encoder, crtc_state);\n\n\t \n\tif (DISPLAY_VER(dev_priv) >= 14)\n\t\tmtl_ddi_enable_d2d(encoder);\n\n\tencoder->set_signal_levels(encoder, crtc_state);\n\n\t \n\tif (DISPLAY_VER(dev_priv) == 9 && !IS_BROXTON(dev_priv)) {\n\t\t \n\t\ti915_reg_t reg = gen9_chicken_trans_reg_by_port(dev_priv, port);\n\t\tu32 val;\n\n\t\tval = intel_de_read(dev_priv, reg);\n\n\t\tif (port == PORT_E)\n\t\t\tval |= DDIE_TRAINING_OVERRIDE_ENABLE |\n\t\t\t\tDDIE_TRAINING_OVERRIDE_VALUE;\n\t\telse\n\t\t\tval |= DDI_TRAINING_OVERRIDE_ENABLE |\n\t\t\t\tDDI_TRAINING_OVERRIDE_VALUE;\n\n\t\tintel_de_write(dev_priv, reg, val);\n\t\tintel_de_posting_read(dev_priv, reg);\n\n\t\tudelay(1);\n\n\t\tif (port == PORT_E)\n\t\t\tval &= ~(DDIE_TRAINING_OVERRIDE_ENABLE |\n\t\t\t\t DDIE_TRAINING_OVERRIDE_VALUE);\n\t\telse\n\t\t\tval &= ~(DDI_TRAINING_OVERRIDE_ENABLE |\n\t\t\t\t DDI_TRAINING_OVERRIDE_VALUE);\n\n\t\tintel_de_write(dev_priv, reg, val);\n\t}\n\n\tintel_ddi_power_up_lanes(encoder, crtc_state);\n\n\t \n\tbuf_ctl = dig_port->saved_port_bits | DDI_BUF_CTL_ENABLE;\n\tif (DISPLAY_VER(dev_priv) >= 14) {\n\t\tu8  lane_count = mtl_get_port_width(crtc_state->lane_count);\n\t\tu32 port_buf = 0;\n\n\t\tport_buf |= XELPDP_PORT_WIDTH(lane_count);\n\n\t\tif (dig_port->saved_port_bits & DDI_BUF_PORT_REVERSAL)\n\t\t\tport_buf |= XELPDP_PORT_REVERSAL;\n\n\t\tintel_de_rmw(dev_priv, XELPDP_PORT_BUF_CTL1(port),\n\t\t\t     XELPDP_PORT_WIDTH_MASK | XELPDP_PORT_REVERSAL, port_buf);\n\n\t\tbuf_ctl |= DDI_PORT_WIDTH(lane_count);\n\t} else if (IS_ALDERLAKE_P(dev_priv) && intel_phy_is_tc(dev_priv, phy)) {\n\t\tdrm_WARN_ON(&dev_priv->drm, !intel_tc_port_in_legacy_mode(dig_port));\n\t\tbuf_ctl |= DDI_BUF_CTL_TC_PHY_OWNERSHIP;\n\t}\n\n\tintel_de_write(dev_priv, DDI_BUF_CTL(port), buf_ctl);\n\n\tintel_wait_ddi_buf_active(dev_priv, port);\n\n\tintel_audio_codec_enable(encoder, crtc_state, conn_state);\n}\n\nstatic void intel_enable_ddi(struct intel_atomic_state *state,\n\t\t\t     struct intel_encoder *encoder,\n\t\t\t     const struct intel_crtc_state *crtc_state,\n\t\t\t     const struct drm_connector_state *conn_state)\n{\n\tdrm_WARN_ON(state->base.dev, crtc_state->has_pch_encoder);\n\n\tif (!intel_crtc_is_bigjoiner_slave(crtc_state))\n\t\tintel_ddi_enable_transcoder_func(encoder, crtc_state);\n\n\t \n\tintel_audio_sdp_split_update(encoder, crtc_state);\n\n\tintel_enable_transcoder(crtc_state);\n\n\tintel_crtc_vblank_on(crtc_state);\n\n\tif (intel_crtc_has_type(crtc_state, INTEL_OUTPUT_HDMI))\n\t\tintel_enable_ddi_hdmi(state, encoder, crtc_state, conn_state);\n\telse\n\t\tintel_enable_ddi_dp(state, encoder, crtc_state, conn_state);\n\n\t \n\tif (conn_state->content_protection ==\n\t    DRM_MODE_CONTENT_PROTECTION_DESIRED)\n\t\tintel_hdcp_enable(state, encoder, crtc_state, conn_state);\n}\n\nstatic void intel_disable_ddi_dp(struct intel_atomic_state *state,\n\t\t\t\t struct intel_encoder *encoder,\n\t\t\t\t const struct intel_crtc_state *old_crtc_state,\n\t\t\t\t const struct drm_connector_state *old_conn_state)\n{\n\tstruct intel_dp *intel_dp = enc_to_intel_dp(encoder);\n\n\tintel_dp->link_trained = false;\n\n\tintel_audio_codec_disable(encoder, old_crtc_state, old_conn_state);\n\n\tintel_psr_disable(intel_dp, old_crtc_state);\n\tintel_edp_backlight_off(old_conn_state);\n\t \n\tintel_dp_sink_set_decompression_state(intel_dp, old_crtc_state,\n\t\t\t\t\t      false);\n\t \n\tintel_dp_sink_set_msa_timing_par_ignore_state(intel_dp, old_crtc_state,\n\t\t\t\t\t\t      false);\n}\n\nstatic void intel_disable_ddi_hdmi(struct intel_atomic_state *state,\n\t\t\t\t   struct intel_encoder *encoder,\n\t\t\t\t   const struct intel_crtc_state *old_crtc_state,\n\t\t\t\t   const struct drm_connector_state *old_conn_state)\n{\n\tstruct drm_i915_private *i915 = to_i915(encoder->base.dev);\n\tstruct drm_connector *connector = old_conn_state->connector;\n\n\tintel_audio_codec_disable(encoder, old_crtc_state, old_conn_state);\n\n\tif (!intel_hdmi_handle_sink_scrambling(encoder, connector,\n\t\t\t\t\t       false, false))\n\t\tdrm_dbg_kms(&i915->drm,\n\t\t\t    \"[CONNECTOR:%d:%s] Failed to reset sink scrambling/TMDS bit clock ratio\\n\",\n\t\t\t    connector->base.id, connector->name);\n}\n\nstatic void intel_disable_ddi(struct intel_atomic_state *state,\n\t\t\t      struct intel_encoder *encoder,\n\t\t\t      const struct intel_crtc_state *old_crtc_state,\n\t\t\t      const struct drm_connector_state *old_conn_state)\n{\n\tintel_tc_port_link_cancel_reset_work(enc_to_dig_port(encoder));\n\n\tintel_hdcp_disable(to_intel_connector(old_conn_state->connector));\n\n\tif (intel_crtc_has_type(old_crtc_state, INTEL_OUTPUT_HDMI))\n\t\tintel_disable_ddi_hdmi(state, encoder, old_crtc_state,\n\t\t\t\t       old_conn_state);\n\telse\n\t\tintel_disable_ddi_dp(state, encoder, old_crtc_state,\n\t\t\t\t     old_conn_state);\n}\n\nstatic void intel_ddi_update_pipe_dp(struct intel_atomic_state *state,\n\t\t\t\t     struct intel_encoder *encoder,\n\t\t\t\t     const struct intel_crtc_state *crtc_state,\n\t\t\t\t     const struct drm_connector_state *conn_state)\n{\n\tintel_ddi_set_dp_msa(crtc_state, conn_state);\n\n\tintel_dp_set_infoframes(encoder, true, crtc_state, conn_state);\n\n\tintel_backlight_update(state, encoder, crtc_state, conn_state);\n\tdrm_connector_update_privacy_screen(conn_state);\n}\n\nvoid intel_ddi_update_pipe(struct intel_atomic_state *state,\n\t\t\t   struct intel_encoder *encoder,\n\t\t\t   const struct intel_crtc_state *crtc_state,\n\t\t\t   const struct drm_connector_state *conn_state)\n{\n\n\tif (!intel_crtc_has_type(crtc_state, INTEL_OUTPUT_HDMI) &&\n\t    !intel_encoder_is_mst(encoder))\n\t\tintel_ddi_update_pipe_dp(state, encoder, crtc_state,\n\t\t\t\t\t conn_state);\n\n\tintel_hdcp_update_pipe(state, encoder, crtc_state, conn_state);\n}\n\nvoid intel_ddi_update_active_dpll(struct intel_atomic_state *state,\n\t\t\t\t  struct intel_encoder *encoder,\n\t\t\t\t  struct intel_crtc *crtc)\n{\n\tstruct drm_i915_private *i915 = to_i915(encoder->base.dev);\n\tstruct intel_crtc_state *crtc_state =\n\t\tintel_atomic_get_new_crtc_state(state, crtc);\n\tstruct intel_crtc *slave_crtc;\n\tenum phy phy = intel_port_to_phy(i915, encoder->port);\n\n\t \n\tif (DISPLAY_VER(i915) >= 14 || !intel_phy_is_tc(i915, phy))\n\t\treturn;\n\n\tintel_update_active_dpll(state, crtc, encoder);\n\tfor_each_intel_crtc_in_pipe_mask(&i915->drm, slave_crtc,\n\t\t\t\t\t intel_crtc_bigjoiner_slave_pipes(crtc_state))\n\t\tintel_update_active_dpll(state, slave_crtc, encoder);\n}\n\nstatic void\nintel_ddi_pre_pll_enable(struct intel_atomic_state *state,\n\t\t\t struct intel_encoder *encoder,\n\t\t\t const struct intel_crtc_state *crtc_state,\n\t\t\t const struct drm_connector_state *conn_state)\n{\n\tstruct drm_i915_private *dev_priv = to_i915(encoder->base.dev);\n\tstruct intel_digital_port *dig_port = enc_to_dig_port(encoder);\n\tenum phy phy = intel_port_to_phy(dev_priv, encoder->port);\n\tbool is_tc_port = intel_phy_is_tc(dev_priv, phy);\n\n\tif (is_tc_port) {\n\t\tstruct intel_crtc *master_crtc =\n\t\t\tto_intel_crtc(crtc_state->uapi.crtc);\n\n\t\tintel_tc_port_get_link(dig_port, crtc_state->lane_count);\n\t\tintel_ddi_update_active_dpll(state, encoder, master_crtc);\n\t}\n\n\tmain_link_aux_power_domain_get(dig_port, crtc_state);\n\n\tif (is_tc_port && !intel_tc_port_in_tbt_alt_mode(dig_port))\n\t\t \n\t\tintel_tc_port_set_fia_lane_count(dig_port, crtc_state->lane_count);\n\telse if (IS_GEMINILAKE(dev_priv) || IS_BROXTON(dev_priv))\n\t\tbxt_ddi_phy_set_lane_optim_mask(encoder,\n\t\t\t\t\t\tcrtc_state->lane_lat_optim_mask);\n}\n\nstatic void adlp_tbt_to_dp_alt_switch_wa(struct intel_encoder *encoder)\n{\n\tstruct drm_i915_private *i915 = to_i915(encoder->base.dev);\n\tenum tc_port tc_port = intel_port_to_tc(i915, encoder->port);\n\tint ln;\n\n\tfor (ln = 0; ln < 2; ln++)\n\t\tintel_dkl_phy_rmw(i915, DKL_PCS_DW5(tc_port, ln), DKL_PCS_DW5_CORE_SOFTRESET, 0);\n}\n\nstatic void mtl_ddi_prepare_link_retrain(struct intel_dp *intel_dp,\n\t\t\t\t\t const struct intel_crtc_state *crtc_state)\n{\n\tstruct intel_digital_port *dig_port = dp_to_dig_port(intel_dp);\n\tstruct intel_encoder *encoder = &dig_port->base;\n\tstruct drm_i915_private *dev_priv = to_i915(encoder->base.dev);\n\tenum port port = encoder->port;\n\tu32 dp_tp_ctl;\n\n\t \n\tdp_tp_ctl = intel_de_read(dev_priv, dp_tp_ctl_reg(encoder, crtc_state));\n\tif (dp_tp_ctl & DP_TP_CTL_ENABLE)\n\t\tmtl_disable_ddi_buf(encoder, crtc_state);\n\n\t \n\tdp_tp_ctl = DP_TP_CTL_ENABLE | DP_TP_CTL_LINK_TRAIN_PAT1;\n\tif (intel_crtc_has_type(crtc_state, INTEL_OUTPUT_DP_MST)) {\n\t\tdp_tp_ctl |= DP_TP_CTL_MODE_MST;\n\t} else {\n\t\tdp_tp_ctl |= DP_TP_CTL_MODE_SST;\n\t\tif (crtc_state->enhanced_framing)\n\t\t\tdp_tp_ctl |= DP_TP_CTL_ENHANCED_FRAME_ENABLE;\n\t}\n\tintel_de_write(dev_priv, dp_tp_ctl_reg(encoder, crtc_state), dp_tp_ctl);\n\tintel_de_posting_read(dev_priv, dp_tp_ctl_reg(encoder, crtc_state));\n\n\t \n\tmtl_ddi_enable_d2d(encoder);\n\n\t \n\tencoder->set_signal_levels(encoder, crtc_state);\n\n\t \n\tmtl_port_buf_ctl_program(encoder, crtc_state);\n\n\t \n\tintel_dp->DP |= DDI_BUF_CTL_ENABLE;\n\tintel_de_write(dev_priv, DDI_BUF_CTL(port), intel_dp->DP);\n\tintel_de_posting_read(dev_priv, DDI_BUF_CTL(port));\n\n\t \n\tintel_wait_ddi_buf_active(dev_priv, port);\n}\n\nstatic void intel_ddi_prepare_link_retrain(struct intel_dp *intel_dp,\n\t\t\t\t\t   const struct intel_crtc_state *crtc_state)\n{\n\tstruct intel_digital_port *dig_port = dp_to_dig_port(intel_dp);\n\tstruct intel_encoder *encoder = &dig_port->base;\n\tstruct drm_i915_private *dev_priv = to_i915(encoder->base.dev);\n\tenum port port = encoder->port;\n\tu32 dp_tp_ctl, ddi_buf_ctl;\n\tbool wait = false;\n\n\tdp_tp_ctl = intel_de_read(dev_priv, dp_tp_ctl_reg(encoder, crtc_state));\n\n\tif (dp_tp_ctl & DP_TP_CTL_ENABLE) {\n\t\tddi_buf_ctl = intel_de_read(dev_priv, DDI_BUF_CTL(port));\n\t\tif (ddi_buf_ctl & DDI_BUF_CTL_ENABLE) {\n\t\t\tintel_de_write(dev_priv, DDI_BUF_CTL(port),\n\t\t\t\t       ddi_buf_ctl & ~DDI_BUF_CTL_ENABLE);\n\t\t\twait = true;\n\t\t}\n\n\t\tdp_tp_ctl &= ~DP_TP_CTL_ENABLE;\n\t\tintel_de_write(dev_priv, dp_tp_ctl_reg(encoder, crtc_state), dp_tp_ctl);\n\t\tintel_de_posting_read(dev_priv, dp_tp_ctl_reg(encoder, crtc_state));\n\n\t\tif (wait)\n\t\t\tintel_wait_ddi_buf_idle(dev_priv, port);\n\t}\n\n\tdp_tp_ctl = DP_TP_CTL_ENABLE | DP_TP_CTL_LINK_TRAIN_PAT1;\n\tif (intel_crtc_has_type(crtc_state, INTEL_OUTPUT_DP_MST)) {\n\t\tdp_tp_ctl |= DP_TP_CTL_MODE_MST;\n\t} else {\n\t\tdp_tp_ctl |= DP_TP_CTL_MODE_SST;\n\t\tif (crtc_state->enhanced_framing)\n\t\t\tdp_tp_ctl |= DP_TP_CTL_ENHANCED_FRAME_ENABLE;\n\t}\n\tintel_de_write(dev_priv, dp_tp_ctl_reg(encoder, crtc_state), dp_tp_ctl);\n\tintel_de_posting_read(dev_priv, dp_tp_ctl_reg(encoder, crtc_state));\n\n\tif (IS_ALDERLAKE_P(dev_priv) &&\n\t    (intel_tc_port_in_dp_alt_mode(dig_port) || intel_tc_port_in_legacy_mode(dig_port)))\n\t\tadlp_tbt_to_dp_alt_switch_wa(encoder);\n\n\tintel_dp->DP |= DDI_BUF_CTL_ENABLE;\n\tintel_de_write(dev_priv, DDI_BUF_CTL(port), intel_dp->DP);\n\tintel_de_posting_read(dev_priv, DDI_BUF_CTL(port));\n\n\tintel_wait_ddi_buf_active(dev_priv, port);\n}\n\nstatic void intel_ddi_set_link_train(struct intel_dp *intel_dp,\n\t\t\t\t     const struct intel_crtc_state *crtc_state,\n\t\t\t\t     u8 dp_train_pat)\n{\n\tstruct intel_encoder *encoder = &dp_to_dig_port(intel_dp)->base;\n\tstruct drm_i915_private *dev_priv = to_i915(encoder->base.dev);\n\tu32 temp;\n\n\ttemp = intel_de_read(dev_priv, dp_tp_ctl_reg(encoder, crtc_state));\n\n\ttemp &= ~DP_TP_CTL_LINK_TRAIN_MASK;\n\tswitch (intel_dp_training_pattern_symbol(dp_train_pat)) {\n\tcase DP_TRAINING_PATTERN_DISABLE:\n\t\ttemp |= DP_TP_CTL_LINK_TRAIN_NORMAL;\n\t\tbreak;\n\tcase DP_TRAINING_PATTERN_1:\n\t\ttemp |= DP_TP_CTL_LINK_TRAIN_PAT1;\n\t\tbreak;\n\tcase DP_TRAINING_PATTERN_2:\n\t\ttemp |= DP_TP_CTL_LINK_TRAIN_PAT2;\n\t\tbreak;\n\tcase DP_TRAINING_PATTERN_3:\n\t\ttemp |= DP_TP_CTL_LINK_TRAIN_PAT3;\n\t\tbreak;\n\tcase DP_TRAINING_PATTERN_4:\n\t\ttemp |= DP_TP_CTL_LINK_TRAIN_PAT4;\n\t\tbreak;\n\t}\n\n\tintel_de_write(dev_priv, dp_tp_ctl_reg(encoder, crtc_state), temp);\n}\n\nstatic void intel_ddi_set_idle_link_train(struct intel_dp *intel_dp,\n\t\t\t\t\t  const struct intel_crtc_state *crtc_state)\n{\n\tstruct intel_encoder *encoder = &dp_to_dig_port(intel_dp)->base;\n\tstruct drm_i915_private *dev_priv = to_i915(encoder->base.dev);\n\tenum port port = encoder->port;\n\n\tintel_de_rmw(dev_priv, dp_tp_ctl_reg(encoder, crtc_state),\n\t\t     DP_TP_CTL_LINK_TRAIN_MASK, DP_TP_CTL_LINK_TRAIN_IDLE);\n\n\t \n\tif (port == PORT_A && DISPLAY_VER(dev_priv) < 12)\n\t\treturn;\n\n\tif (intel_de_wait_for_set(dev_priv,\n\t\t\t\t  dp_tp_status_reg(encoder, crtc_state),\n\t\t\t\t  DP_TP_STATUS_IDLE_DONE, 1))\n\t\tdrm_err(&dev_priv->drm,\n\t\t\t\"Timed out waiting for DP idle patterns\\n\");\n}\n\nstatic bool intel_ddi_is_audio_enabled(struct drm_i915_private *dev_priv,\n\t\t\t\t       enum transcoder cpu_transcoder)\n{\n\tif (cpu_transcoder == TRANSCODER_EDP)\n\t\treturn false;\n\n\tif (!intel_display_power_is_enabled(dev_priv, POWER_DOMAIN_AUDIO_MMIO))\n\t\treturn false;\n\n\treturn intel_de_read(dev_priv, HSW_AUD_PIN_ELD_CP_VLD) &\n\t\tAUDIO_OUTPUT_ENABLE(cpu_transcoder);\n}\n\nvoid intel_ddi_compute_min_voltage_level(struct drm_i915_private *dev_priv,\n\t\t\t\t\t struct intel_crtc_state *crtc_state)\n{\n\tif (DISPLAY_VER(dev_priv) >= 12 && crtc_state->port_clock > 594000)\n\t\tcrtc_state->min_voltage_level = 2;\n\telse if ((IS_JASPERLAKE(dev_priv) || IS_ELKHARTLAKE(dev_priv)) &&\n\t\t crtc_state->port_clock > 594000)\n\t\tcrtc_state->min_voltage_level = 3;\n\telse if (DISPLAY_VER(dev_priv) >= 11 && crtc_state->port_clock > 594000)\n\t\tcrtc_state->min_voltage_level = 1;\n}\n\nstatic enum transcoder bdw_transcoder_master_readout(struct drm_i915_private *dev_priv,\n\t\t\t\t\t\t     enum transcoder cpu_transcoder)\n{\n\tu32 master_select;\n\n\tif (DISPLAY_VER(dev_priv) >= 11) {\n\t\tu32 ctl2 = intel_de_read(dev_priv, TRANS_DDI_FUNC_CTL2(cpu_transcoder));\n\n\t\tif ((ctl2 & PORT_SYNC_MODE_ENABLE) == 0)\n\t\t\treturn INVALID_TRANSCODER;\n\n\t\tmaster_select = REG_FIELD_GET(PORT_SYNC_MODE_MASTER_SELECT_MASK, ctl2);\n\t} else {\n\t\tu32 ctl = intel_de_read(dev_priv, TRANS_DDI_FUNC_CTL(cpu_transcoder));\n\n\t\tif ((ctl & TRANS_DDI_PORT_SYNC_ENABLE) == 0)\n\t\t\treturn INVALID_TRANSCODER;\n\n\t\tmaster_select = REG_FIELD_GET(TRANS_DDI_PORT_SYNC_MASTER_SELECT_MASK, ctl);\n\t}\n\n\tif (master_select == 0)\n\t\treturn TRANSCODER_EDP;\n\telse\n\t\treturn master_select - 1;\n}\n\nstatic void bdw_get_trans_port_sync_config(struct intel_crtc_state *crtc_state)\n{\n\tstruct drm_i915_private *dev_priv = to_i915(crtc_state->uapi.crtc->dev);\n\tu32 transcoders = BIT(TRANSCODER_A) | BIT(TRANSCODER_B) |\n\t\tBIT(TRANSCODER_C) | BIT(TRANSCODER_D);\n\tenum transcoder cpu_transcoder;\n\n\tcrtc_state->master_transcoder =\n\t\tbdw_transcoder_master_readout(dev_priv, crtc_state->cpu_transcoder);\n\n\tfor_each_cpu_transcoder_masked(dev_priv, cpu_transcoder, transcoders) {\n\t\tenum intel_display_power_domain power_domain;\n\t\tintel_wakeref_t trans_wakeref;\n\n\t\tpower_domain = POWER_DOMAIN_TRANSCODER(cpu_transcoder);\n\t\ttrans_wakeref = intel_display_power_get_if_enabled(dev_priv,\n\t\t\t\t\t\t\t\t   power_domain);\n\n\t\tif (!trans_wakeref)\n\t\t\tcontinue;\n\n\t\tif (bdw_transcoder_master_readout(dev_priv, cpu_transcoder) ==\n\t\t    crtc_state->cpu_transcoder)\n\t\t\tcrtc_state->sync_mode_slaves_mask |= BIT(cpu_transcoder);\n\n\t\tintel_display_power_put(dev_priv, power_domain, trans_wakeref);\n\t}\n\n\tdrm_WARN_ON(&dev_priv->drm,\n\t\t    crtc_state->master_transcoder != INVALID_TRANSCODER &&\n\t\t    crtc_state->sync_mode_slaves_mask);\n}\n\nstatic void intel_ddi_read_func_ctl(struct intel_encoder *encoder,\n\t\t\t\t    struct intel_crtc_state *pipe_config)\n{\n\tstruct drm_i915_private *dev_priv = to_i915(encoder->base.dev);\n\tstruct intel_crtc *crtc = to_intel_crtc(pipe_config->uapi.crtc);\n\tenum transcoder cpu_transcoder = pipe_config->cpu_transcoder;\n\tstruct intel_digital_port *dig_port = enc_to_dig_port(encoder);\n\tu32 temp, flags = 0;\n\n\ttemp = intel_de_read(dev_priv, TRANS_DDI_FUNC_CTL(cpu_transcoder));\n\tif (temp & TRANS_DDI_PHSYNC)\n\t\tflags |= DRM_MODE_FLAG_PHSYNC;\n\telse\n\t\tflags |= DRM_MODE_FLAG_NHSYNC;\n\tif (temp & TRANS_DDI_PVSYNC)\n\t\tflags |= DRM_MODE_FLAG_PVSYNC;\n\telse\n\t\tflags |= DRM_MODE_FLAG_NVSYNC;\n\n\tpipe_config->hw.adjusted_mode.flags |= flags;\n\n\tswitch (temp & TRANS_DDI_BPC_MASK) {\n\tcase TRANS_DDI_BPC_6:\n\t\tpipe_config->pipe_bpp = 18;\n\t\tbreak;\n\tcase TRANS_DDI_BPC_8:\n\t\tpipe_config->pipe_bpp = 24;\n\t\tbreak;\n\tcase TRANS_DDI_BPC_10:\n\t\tpipe_config->pipe_bpp = 30;\n\t\tbreak;\n\tcase TRANS_DDI_BPC_12:\n\t\tpipe_config->pipe_bpp = 36;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tswitch (temp & TRANS_DDI_MODE_SELECT_MASK) {\n\tcase TRANS_DDI_MODE_SELECT_HDMI:\n\t\tpipe_config->has_hdmi_sink = true;\n\n\t\tpipe_config->infoframes.enable |=\n\t\t\tintel_hdmi_infoframes_enabled(encoder, pipe_config);\n\n\t\tif (pipe_config->infoframes.enable)\n\t\t\tpipe_config->has_infoframe = true;\n\n\t\tif (temp & TRANS_DDI_HDMI_SCRAMBLING)\n\t\t\tpipe_config->hdmi_scrambling = true;\n\t\tif (temp & TRANS_DDI_HIGH_TMDS_CHAR_RATE)\n\t\t\tpipe_config->hdmi_high_tmds_clock_ratio = true;\n\t\tfallthrough;\n\tcase TRANS_DDI_MODE_SELECT_DVI:\n\t\tpipe_config->output_types |= BIT(INTEL_OUTPUT_HDMI);\n\t\tif (DISPLAY_VER(dev_priv) >= 14)\n\t\t\tpipe_config->lane_count =\n\t\t\t\t((temp & DDI_PORT_WIDTH_MASK) >> DDI_PORT_WIDTH_SHIFT) + 1;\n\t\telse\n\t\t\tpipe_config->lane_count = 4;\n\t\tbreak;\n\tcase TRANS_DDI_MODE_SELECT_DP_SST:\n\t\tif (encoder->type == INTEL_OUTPUT_EDP)\n\t\t\tpipe_config->output_types |= BIT(INTEL_OUTPUT_EDP);\n\t\telse\n\t\t\tpipe_config->output_types |= BIT(INTEL_OUTPUT_DP);\n\t\tpipe_config->lane_count =\n\t\t\t((temp & DDI_PORT_WIDTH_MASK) >> DDI_PORT_WIDTH_SHIFT) + 1;\n\n\t\tintel_cpu_transcoder_get_m1_n1(crtc, cpu_transcoder,\n\t\t\t\t\t       &pipe_config->dp_m_n);\n\t\tintel_cpu_transcoder_get_m2_n2(crtc, cpu_transcoder,\n\t\t\t\t\t       &pipe_config->dp_m2_n2);\n\n\t\tpipe_config->enhanced_framing =\n\t\t\tintel_de_read(dev_priv, dp_tp_ctl_reg(encoder, pipe_config)) &\n\t\t\tDP_TP_CTL_ENHANCED_FRAME_ENABLE;\n\n\t\tif (DISPLAY_VER(dev_priv) >= 11)\n\t\t\tpipe_config->fec_enable =\n\t\t\t\tintel_de_read(dev_priv,\n\t\t\t\t\t      dp_tp_ctl_reg(encoder, pipe_config)) & DP_TP_CTL_FEC_ENABLE;\n\n\t\tif (dig_port->lspcon.active && intel_dp_has_hdmi_sink(&dig_port->dp))\n\t\t\tpipe_config->infoframes.enable |=\n\t\t\t\tintel_lspcon_infoframes_enabled(encoder, pipe_config);\n\t\telse\n\t\t\tpipe_config->infoframes.enable |=\n\t\t\t\tintel_hdmi_infoframes_enabled(encoder, pipe_config);\n\t\tbreak;\n\tcase TRANS_DDI_MODE_SELECT_FDI_OR_128B132B:\n\t\tif (!HAS_DP20(dev_priv)) {\n\t\t\t \n\t\t\tpipe_config->output_types |= BIT(INTEL_OUTPUT_ANALOG);\n\t\t\tpipe_config->enhanced_framing =\n\t\t\t\tintel_de_read(dev_priv, dp_tp_ctl_reg(encoder, pipe_config)) &\n\t\t\t\tDP_TP_CTL_ENHANCED_FRAME_ENABLE;\n\t\t\tbreak;\n\t\t}\n\t\tfallthrough;  \n\tcase TRANS_DDI_MODE_SELECT_DP_MST:\n\t\tpipe_config->output_types |= BIT(INTEL_OUTPUT_DP_MST);\n\t\tpipe_config->lane_count =\n\t\t\t((temp & DDI_PORT_WIDTH_MASK) >> DDI_PORT_WIDTH_SHIFT) + 1;\n\n\t\tif (DISPLAY_VER(dev_priv) >= 12)\n\t\t\tpipe_config->mst_master_transcoder =\n\t\t\t\t\tREG_FIELD_GET(TRANS_DDI_MST_TRANSPORT_SELECT_MASK, temp);\n\n\t\tintel_cpu_transcoder_get_m1_n1(crtc, cpu_transcoder,\n\t\t\t\t\t       &pipe_config->dp_m_n);\n\n\t\tpipe_config->infoframes.enable |=\n\t\t\tintel_hdmi_infoframes_enabled(encoder, pipe_config);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}\n\nstatic void intel_ddi_get_config(struct intel_encoder *encoder,\n\t\t\t\t struct intel_crtc_state *pipe_config)\n{\n\tstruct drm_i915_private *dev_priv = to_i915(encoder->base.dev);\n\tenum transcoder cpu_transcoder = pipe_config->cpu_transcoder;\n\n\t \n\tif (drm_WARN_ON(&dev_priv->drm, transcoder_is_dsi(cpu_transcoder)))\n\t\treturn;\n\n\tintel_ddi_read_func_ctl(encoder, pipe_config);\n\n\tintel_ddi_mso_get_config(encoder, pipe_config);\n\n\tpipe_config->has_audio =\n\t\tintel_ddi_is_audio_enabled(dev_priv, cpu_transcoder);\n\n\tif (encoder->type == INTEL_OUTPUT_EDP)\n\t\tintel_edp_fixup_vbt_bpp(encoder, pipe_config->pipe_bpp);\n\n\tddi_dotclock_get(pipe_config);\n\n\tif (IS_GEMINILAKE(dev_priv) || IS_BROXTON(dev_priv))\n\t\tpipe_config->lane_lat_optim_mask =\n\t\t\tbxt_ddi_phy_get_lane_lat_optim_mask(encoder);\n\n\tintel_ddi_compute_min_voltage_level(dev_priv, pipe_config);\n\n\tintel_hdmi_read_gcp_infoframe(encoder, pipe_config);\n\n\tintel_read_infoframe(encoder, pipe_config,\n\t\t\t     HDMI_INFOFRAME_TYPE_AVI,\n\t\t\t     &pipe_config->infoframes.avi);\n\tintel_read_infoframe(encoder, pipe_config,\n\t\t\t     HDMI_INFOFRAME_TYPE_SPD,\n\t\t\t     &pipe_config->infoframes.spd);\n\tintel_read_infoframe(encoder, pipe_config,\n\t\t\t     HDMI_INFOFRAME_TYPE_VENDOR,\n\t\t\t     &pipe_config->infoframes.hdmi);\n\tintel_read_infoframe(encoder, pipe_config,\n\t\t\t     HDMI_INFOFRAME_TYPE_DRM,\n\t\t\t     &pipe_config->infoframes.drm);\n\n\tif (DISPLAY_VER(dev_priv) >= 8)\n\t\tbdw_get_trans_port_sync_config(pipe_config);\n\n\tintel_read_dp_sdp(encoder, pipe_config, HDMI_PACKET_TYPE_GAMUT_METADATA);\n\tintel_read_dp_sdp(encoder, pipe_config, DP_SDP_VSC);\n\n\tintel_psr_get_config(encoder, pipe_config);\n\n\tintel_audio_codec_get_config(encoder, pipe_config);\n}\n\nvoid intel_ddi_get_clock(struct intel_encoder *encoder,\n\t\t\t struct intel_crtc_state *crtc_state,\n\t\t\t struct intel_shared_dpll *pll)\n{\n\tstruct drm_i915_private *i915 = to_i915(encoder->base.dev);\n\tenum icl_port_dpll_id port_dpll_id = ICL_PORT_DPLL_DEFAULT;\n\tstruct icl_port_dpll *port_dpll = &crtc_state->icl_port_dplls[port_dpll_id];\n\tbool pll_active;\n\n\tif (drm_WARN_ON(&i915->drm, !pll))\n\t\treturn;\n\n\tport_dpll->pll = pll;\n\tpll_active = intel_dpll_get_hw_state(i915, pll, &port_dpll->hw_state);\n\tdrm_WARN_ON(&i915->drm, !pll_active);\n\n\ticl_set_active_port_dpll(crtc_state, port_dpll_id);\n\n\tcrtc_state->port_clock = intel_dpll_get_freq(i915, crtc_state->shared_dpll,\n\t\t\t\t\t\t     &crtc_state->dpll_hw_state);\n}\n\nstatic void mtl_ddi_get_config(struct intel_encoder *encoder,\n\t\t\t       struct intel_crtc_state *crtc_state)\n{\n\tstruct drm_i915_private *i915 = to_i915(encoder->base.dev);\n\tenum phy phy = intel_port_to_phy(i915, encoder->port);\n\tstruct intel_digital_port *dig_port = enc_to_dig_port(encoder);\n\n\tif (intel_tc_port_in_tbt_alt_mode(dig_port)) {\n\t\tcrtc_state->port_clock = intel_mtl_tbt_calc_port_clock(encoder);\n\t} else if (intel_is_c10phy(i915, phy)) {\n\t\tintel_c10pll_readout_hw_state(encoder, &crtc_state->cx0pll_state.c10);\n\t\tintel_c10pll_dump_hw_state(i915, &crtc_state->cx0pll_state.c10);\n\t\tcrtc_state->port_clock = intel_c10pll_calc_port_clock(encoder, &crtc_state->cx0pll_state.c10);\n\t} else {\n\t\tintel_c20pll_readout_hw_state(encoder, &crtc_state->cx0pll_state.c20);\n\t\tintel_c20pll_dump_hw_state(i915, &crtc_state->cx0pll_state.c20);\n\t\tcrtc_state->port_clock = intel_c20pll_calc_port_clock(encoder, &crtc_state->cx0pll_state.c20);\n\t}\n\n\tintel_ddi_get_config(encoder, crtc_state);\n}\n\nstatic void dg2_ddi_get_config(struct intel_encoder *encoder,\n\t\t\t\tstruct intel_crtc_state *crtc_state)\n{\n\tintel_mpllb_readout_hw_state(encoder, &crtc_state->mpllb_state);\n\tcrtc_state->port_clock = intel_mpllb_calc_port_clock(encoder, &crtc_state->mpllb_state);\n\n\tintel_ddi_get_config(encoder, crtc_state);\n}\n\nstatic void adls_ddi_get_config(struct intel_encoder *encoder,\n\t\t\t\tstruct intel_crtc_state *crtc_state)\n{\n\tintel_ddi_get_clock(encoder, crtc_state, adls_ddi_get_pll(encoder));\n\tintel_ddi_get_config(encoder, crtc_state);\n}\n\nstatic void rkl_ddi_get_config(struct intel_encoder *encoder,\n\t\t\t       struct intel_crtc_state *crtc_state)\n{\n\tintel_ddi_get_clock(encoder, crtc_state, rkl_ddi_get_pll(encoder));\n\tintel_ddi_get_config(encoder, crtc_state);\n}\n\nstatic void dg1_ddi_get_config(struct intel_encoder *encoder,\n\t\t\t       struct intel_crtc_state *crtc_state)\n{\n\tintel_ddi_get_clock(encoder, crtc_state, dg1_ddi_get_pll(encoder));\n\tintel_ddi_get_config(encoder, crtc_state);\n}\n\nstatic void icl_ddi_combo_get_config(struct intel_encoder *encoder,\n\t\t\t\t     struct intel_crtc_state *crtc_state)\n{\n\tintel_ddi_get_clock(encoder, crtc_state, icl_ddi_combo_get_pll(encoder));\n\tintel_ddi_get_config(encoder, crtc_state);\n}\n\nstatic bool icl_ddi_tc_pll_is_tbt(const struct intel_shared_dpll *pll)\n{\n\treturn pll->info->id == DPLL_ID_ICL_TBTPLL;\n}\n\nstatic enum icl_port_dpll_id\nicl_ddi_tc_port_pll_type(struct intel_encoder *encoder,\n\t\t\t const struct intel_crtc_state *crtc_state)\n{\n\tstruct drm_i915_private *i915 = to_i915(encoder->base.dev);\n\tconst struct intel_shared_dpll *pll = crtc_state->shared_dpll;\n\n\tif (drm_WARN_ON(&i915->drm, !pll))\n\t\treturn ICL_PORT_DPLL_DEFAULT;\n\n\tif (icl_ddi_tc_pll_is_tbt(pll))\n\t\treturn ICL_PORT_DPLL_DEFAULT;\n\telse\n\t\treturn ICL_PORT_DPLL_MG_PHY;\n}\n\nenum icl_port_dpll_id\nintel_ddi_port_pll_type(struct intel_encoder *encoder,\n\t\t\tconst struct intel_crtc_state *crtc_state)\n{\n\tif (!encoder->port_pll_type)\n\t\treturn ICL_PORT_DPLL_DEFAULT;\n\n\treturn encoder->port_pll_type(encoder, crtc_state);\n}\n\nstatic void icl_ddi_tc_get_clock(struct intel_encoder *encoder,\n\t\t\t\t struct intel_crtc_state *crtc_state,\n\t\t\t\t struct intel_shared_dpll *pll)\n{\n\tstruct drm_i915_private *i915 = to_i915(encoder->base.dev);\n\tenum icl_port_dpll_id port_dpll_id;\n\tstruct icl_port_dpll *port_dpll;\n\tbool pll_active;\n\n\tif (drm_WARN_ON(&i915->drm, !pll))\n\t\treturn;\n\n\tif (icl_ddi_tc_pll_is_tbt(pll))\n\t\tport_dpll_id = ICL_PORT_DPLL_DEFAULT;\n\telse\n\t\tport_dpll_id = ICL_PORT_DPLL_MG_PHY;\n\n\tport_dpll = &crtc_state->icl_port_dplls[port_dpll_id];\n\n\tport_dpll->pll = pll;\n\tpll_active = intel_dpll_get_hw_state(i915, pll, &port_dpll->hw_state);\n\tdrm_WARN_ON(&i915->drm, !pll_active);\n\n\ticl_set_active_port_dpll(crtc_state, port_dpll_id);\n\n\tif (icl_ddi_tc_pll_is_tbt(crtc_state->shared_dpll))\n\t\tcrtc_state->port_clock = icl_calc_tbt_pll_link(i915, encoder->port);\n\telse\n\t\tcrtc_state->port_clock = intel_dpll_get_freq(i915, crtc_state->shared_dpll,\n\t\t\t\t\t\t\t     &crtc_state->dpll_hw_state);\n}\n\nstatic void icl_ddi_tc_get_config(struct intel_encoder *encoder,\n\t\t\t\t  struct intel_crtc_state *crtc_state)\n{\n\ticl_ddi_tc_get_clock(encoder, crtc_state, icl_ddi_tc_get_pll(encoder));\n\tintel_ddi_get_config(encoder, crtc_state);\n}\n\nstatic void bxt_ddi_get_config(struct intel_encoder *encoder,\n\t\t\t       struct intel_crtc_state *crtc_state)\n{\n\tintel_ddi_get_clock(encoder, crtc_state, bxt_ddi_get_pll(encoder));\n\tintel_ddi_get_config(encoder, crtc_state);\n}\n\nstatic void skl_ddi_get_config(struct intel_encoder *encoder,\n\t\t\t       struct intel_crtc_state *crtc_state)\n{\n\tintel_ddi_get_clock(encoder, crtc_state, skl_ddi_get_pll(encoder));\n\tintel_ddi_get_config(encoder, crtc_state);\n}\n\nvoid hsw_ddi_get_config(struct intel_encoder *encoder,\n\t\t\tstruct intel_crtc_state *crtc_state)\n{\n\tintel_ddi_get_clock(encoder, crtc_state, hsw_ddi_get_pll(encoder));\n\tintel_ddi_get_config(encoder, crtc_state);\n}\n\nstatic void intel_ddi_sync_state(struct intel_encoder *encoder,\n\t\t\t\t const struct intel_crtc_state *crtc_state)\n{\n\tstruct drm_i915_private *i915 = to_i915(encoder->base.dev);\n\tenum phy phy = intel_port_to_phy(i915, encoder->port);\n\n\tif (intel_phy_is_tc(i915, phy))\n\t\tintel_tc_port_sanitize_mode(enc_to_dig_port(encoder),\n\t\t\t\t\t    crtc_state);\n\n\tif (crtc_state && intel_crtc_has_dp_encoder(crtc_state))\n\t\tintel_dp_sync_state(encoder, crtc_state);\n}\n\nstatic bool intel_ddi_initial_fastset_check(struct intel_encoder *encoder,\n\t\t\t\t\t    struct intel_crtc_state *crtc_state)\n{\n\tstruct drm_i915_private *i915 = to_i915(encoder->base.dev);\n\tenum phy phy = intel_port_to_phy(i915, encoder->port);\n\tbool fastset = true;\n\n\tif (intel_phy_is_tc(i915, phy)) {\n\t\tdrm_dbg_kms(&i915->drm, \"[ENCODER:%d:%s] Forcing full modeset to compute TC port DPLLs\\n\",\n\t\t\t    encoder->base.base.id, encoder->base.name);\n\t\tcrtc_state->uapi.mode_changed = true;\n\t\tfastset = false;\n\t}\n\n\tif (intel_crtc_has_dp_encoder(crtc_state) &&\n\t    !intel_dp_initial_fastset_check(encoder, crtc_state))\n\t\tfastset = false;\n\n\treturn fastset;\n}\n\nstatic enum intel_output_type\nintel_ddi_compute_output_type(struct intel_encoder *encoder,\n\t\t\t      struct intel_crtc_state *crtc_state,\n\t\t\t      struct drm_connector_state *conn_state)\n{\n\tswitch (conn_state->connector->connector_type) {\n\tcase DRM_MODE_CONNECTOR_HDMIA:\n\t\treturn INTEL_OUTPUT_HDMI;\n\tcase DRM_MODE_CONNECTOR_eDP:\n\t\treturn INTEL_OUTPUT_EDP;\n\tcase DRM_MODE_CONNECTOR_DisplayPort:\n\t\treturn INTEL_OUTPUT_DP;\n\tdefault:\n\t\tMISSING_CASE(conn_state->connector->connector_type);\n\t\treturn INTEL_OUTPUT_UNUSED;\n\t}\n}\n\nstatic int intel_ddi_compute_config(struct intel_encoder *encoder,\n\t\t\t\t    struct intel_crtc_state *pipe_config,\n\t\t\t\t    struct drm_connector_state *conn_state)\n{\n\tstruct intel_crtc *crtc = to_intel_crtc(pipe_config->uapi.crtc);\n\tstruct drm_i915_private *dev_priv = to_i915(encoder->base.dev);\n\tenum port port = encoder->port;\n\tint ret;\n\n\tif (HAS_TRANSCODER(dev_priv, TRANSCODER_EDP) && port == PORT_A)\n\t\tpipe_config->cpu_transcoder = TRANSCODER_EDP;\n\n\tif (intel_crtc_has_type(pipe_config, INTEL_OUTPUT_HDMI)) {\n\t\tpipe_config->has_hdmi_sink =\n\t\t\tintel_hdmi_compute_has_hdmi_sink(encoder, pipe_config, conn_state);\n\n\t\tret = intel_hdmi_compute_config(encoder, pipe_config, conn_state);\n\t} else {\n\t\tret = intel_dp_compute_config(encoder, pipe_config, conn_state);\n\t}\n\n\tif (ret)\n\t\treturn ret;\n\n\tif (IS_HASWELL(dev_priv) && crtc->pipe == PIPE_A &&\n\t    pipe_config->cpu_transcoder == TRANSCODER_EDP)\n\t\tpipe_config->pch_pfit.force_thru =\n\t\t\tpipe_config->pch_pfit.enabled ||\n\t\t\tpipe_config->crc_enabled;\n\n\tif (IS_GEMINILAKE(dev_priv) || IS_BROXTON(dev_priv))\n\t\tpipe_config->lane_lat_optim_mask =\n\t\t\tbxt_ddi_phy_calc_lane_lat_optim_mask(pipe_config->lane_count);\n\n\tintel_ddi_compute_min_voltage_level(dev_priv, pipe_config);\n\n\treturn 0;\n}\n\nstatic bool mode_equal(const struct drm_display_mode *mode1,\n\t\t       const struct drm_display_mode *mode2)\n{\n\treturn drm_mode_match(mode1, mode2,\n\t\t\t      DRM_MODE_MATCH_TIMINGS |\n\t\t\t      DRM_MODE_MATCH_FLAGS |\n\t\t\t      DRM_MODE_MATCH_3D_FLAGS) &&\n\t\tmode1->clock == mode2->clock;  \n}\n\nstatic bool m_n_equal(const struct intel_link_m_n *m_n_1,\n\t\t      const struct intel_link_m_n *m_n_2)\n{\n\treturn m_n_1->tu == m_n_2->tu &&\n\t\tm_n_1->data_m == m_n_2->data_m &&\n\t\tm_n_1->data_n == m_n_2->data_n &&\n\t\tm_n_1->link_m == m_n_2->link_m &&\n\t\tm_n_1->link_n == m_n_2->link_n;\n}\n\nstatic bool crtcs_port_sync_compatible(const struct intel_crtc_state *crtc_state1,\n\t\t\t\t       const struct intel_crtc_state *crtc_state2)\n{\n\treturn crtc_state1->hw.active && crtc_state2->hw.active &&\n\t\tcrtc_state1->output_types == crtc_state2->output_types &&\n\t\tcrtc_state1->output_format == crtc_state2->output_format &&\n\t\tcrtc_state1->lane_count == crtc_state2->lane_count &&\n\t\tcrtc_state1->port_clock == crtc_state2->port_clock &&\n\t\tmode_equal(&crtc_state1->hw.adjusted_mode,\n\t\t\t   &crtc_state2->hw.adjusted_mode) &&\n\t\tm_n_equal(&crtc_state1->dp_m_n, &crtc_state2->dp_m_n);\n}\n\nstatic u8\nintel_ddi_port_sync_transcoders(const struct intel_crtc_state *ref_crtc_state,\n\t\t\t\tint tile_group_id)\n{\n\tstruct drm_connector *connector;\n\tconst struct drm_connector_state *conn_state;\n\tstruct drm_i915_private *dev_priv = to_i915(ref_crtc_state->uapi.crtc->dev);\n\tstruct intel_atomic_state *state =\n\t\tto_intel_atomic_state(ref_crtc_state->uapi.state);\n\tu8 transcoders = 0;\n\tint i;\n\n\t \n\tif (DISPLAY_VER(dev_priv) < 9)\n\t\treturn 0;\n\n\tif (!intel_crtc_has_type(ref_crtc_state, INTEL_OUTPUT_DP))\n\t\treturn 0;\n\n\tfor_each_new_connector_in_state(&state->base, connector, conn_state, i) {\n\t\tstruct intel_crtc *crtc = to_intel_crtc(conn_state->crtc);\n\t\tconst struct intel_crtc_state *crtc_state;\n\n\t\tif (!crtc)\n\t\t\tcontinue;\n\n\t\tif (!connector->has_tile ||\n\t\t    connector->tile_group->id !=\n\t\t    tile_group_id)\n\t\t\tcontinue;\n\t\tcrtc_state = intel_atomic_get_new_crtc_state(state,\n\t\t\t\t\t\t\t     crtc);\n\t\tif (!crtcs_port_sync_compatible(ref_crtc_state,\n\t\t\t\t\t\tcrtc_state))\n\t\t\tcontinue;\n\t\ttranscoders |= BIT(crtc_state->cpu_transcoder);\n\t}\n\n\treturn transcoders;\n}\n\nstatic int intel_ddi_compute_config_late(struct intel_encoder *encoder,\n\t\t\t\t\t struct intel_crtc_state *crtc_state,\n\t\t\t\t\t struct drm_connector_state *conn_state)\n{\n\tstruct drm_i915_private *i915 = to_i915(encoder->base.dev);\n\tstruct drm_connector *connector = conn_state->connector;\n\tu8 port_sync_transcoders = 0;\n\n\tdrm_dbg_kms(&i915->drm, \"[ENCODER:%d:%s] [CRTC:%d:%s]\",\n\t\t    encoder->base.base.id, encoder->base.name,\n\t\t    crtc_state->uapi.crtc->base.id, crtc_state->uapi.crtc->name);\n\n\tif (connector->has_tile)\n\t\tport_sync_transcoders = intel_ddi_port_sync_transcoders(crtc_state,\n\t\t\t\t\t\t\t\t\tconnector->tile_group->id);\n\n\t \n\tif (port_sync_transcoders & BIT(TRANSCODER_EDP))\n\t\tcrtc_state->master_transcoder = TRANSCODER_EDP;\n\telse\n\t\tcrtc_state->master_transcoder = ffs(port_sync_transcoders) - 1;\n\n\tif (crtc_state->master_transcoder == crtc_state->cpu_transcoder) {\n\t\tcrtc_state->master_transcoder = INVALID_TRANSCODER;\n\t\tcrtc_state->sync_mode_slaves_mask =\n\t\t\tport_sync_transcoders & ~BIT(crtc_state->cpu_transcoder);\n\t}\n\n\treturn 0;\n}\n\nstatic void intel_ddi_encoder_destroy(struct drm_encoder *encoder)\n{\n\tstruct drm_i915_private *i915 = to_i915(encoder->dev);\n\tstruct intel_digital_port *dig_port = enc_to_dig_port(to_intel_encoder(encoder));\n\tenum phy phy = intel_port_to_phy(i915, dig_port->base.port);\n\n\tintel_dp_encoder_flush_work(encoder);\n\tif (intel_phy_is_tc(i915, phy))\n\t\tintel_tc_port_cleanup(dig_port);\n\tintel_display_power_flush_work(i915);\n\n\tdrm_encoder_cleanup(encoder);\n\tkfree(dig_port->hdcp_port_data.streams);\n\tkfree(dig_port);\n}\n\nstatic void intel_ddi_encoder_reset(struct drm_encoder *encoder)\n{\n\tstruct drm_i915_private *i915 = to_i915(encoder->dev);\n\tstruct intel_dp *intel_dp = enc_to_intel_dp(to_intel_encoder(encoder));\n\tstruct intel_digital_port *dig_port = enc_to_dig_port(to_intel_encoder(encoder));\n\tenum phy phy = intel_port_to_phy(i915, dig_port->base.port);\n\n\tintel_dp->reset_link_params = true;\n\n\tintel_pps_encoder_reset(intel_dp);\n\n\tif (intel_phy_is_tc(i915, phy))\n\t\tintel_tc_port_init_mode(dig_port);\n}\n\nstatic int intel_ddi_encoder_late_register(struct drm_encoder *_encoder)\n{\n\tstruct intel_encoder *encoder = to_intel_encoder(_encoder);\n\n\tintel_tc_port_link_reset(enc_to_dig_port(encoder));\n\n\treturn 0;\n}\n\nstatic const struct drm_encoder_funcs intel_ddi_funcs = {\n\t.reset = intel_ddi_encoder_reset,\n\t.destroy = intel_ddi_encoder_destroy,\n\t.late_register = intel_ddi_encoder_late_register,\n};\n\nstatic struct intel_connector *\nintel_ddi_init_dp_connector(struct intel_digital_port *dig_port)\n{\n\tstruct drm_i915_private *i915 = to_i915(dig_port->base.base.dev);\n\tstruct intel_connector *connector;\n\tenum port port = dig_port->base.port;\n\n\tconnector = intel_connector_alloc();\n\tif (!connector)\n\t\treturn NULL;\n\n\tdig_port->dp.output_reg = DDI_BUF_CTL(port);\n\tif (DISPLAY_VER(i915) >= 14)\n\t\tdig_port->dp.prepare_link_retrain = mtl_ddi_prepare_link_retrain;\n\telse\n\t\tdig_port->dp.prepare_link_retrain = intel_ddi_prepare_link_retrain;\n\tdig_port->dp.set_link_train = intel_ddi_set_link_train;\n\tdig_port->dp.set_idle_link_train = intel_ddi_set_idle_link_train;\n\n\tdig_port->dp.voltage_max = intel_ddi_dp_voltage_max;\n\tdig_port->dp.preemph_max = intel_ddi_dp_preemph_max;\n\n\tif (!intel_dp_init_connector(dig_port, connector)) {\n\t\tkfree(connector);\n\t\treturn NULL;\n\t}\n\n\tif (dig_port->base.type == INTEL_OUTPUT_EDP) {\n\t\tstruct drm_device *dev = dig_port->base.base.dev;\n\t\tstruct drm_privacy_screen *privacy_screen;\n\n\t\tprivacy_screen = drm_privacy_screen_get(dev->dev, NULL);\n\t\tif (!IS_ERR(privacy_screen)) {\n\t\t\tdrm_connector_attach_privacy_screen_provider(&connector->base,\n\t\t\t\t\t\t\t\t     privacy_screen);\n\t\t} else if (PTR_ERR(privacy_screen) != -ENODEV) {\n\t\t\tdrm_warn(dev, \"Error getting privacy-screen\\n\");\n\t\t}\n\t}\n\n\treturn connector;\n}\n\nstatic int modeset_pipe(struct drm_crtc *crtc,\n\t\t\tstruct drm_modeset_acquire_ctx *ctx)\n{\n\tstruct drm_atomic_state *state;\n\tstruct drm_crtc_state *crtc_state;\n\tint ret;\n\n\tstate = drm_atomic_state_alloc(crtc->dev);\n\tif (!state)\n\t\treturn -ENOMEM;\n\n\tstate->acquire_ctx = ctx;\n\tto_intel_atomic_state(state)->internal = true;\n\n\tcrtc_state = drm_atomic_get_crtc_state(state, crtc);\n\tif (IS_ERR(crtc_state)) {\n\t\tret = PTR_ERR(crtc_state);\n\t\tgoto out;\n\t}\n\n\tcrtc_state->connectors_changed = true;\n\n\tret = drm_atomic_commit(state);\nout:\n\tdrm_atomic_state_put(state);\n\n\treturn ret;\n}\n\nstatic int intel_hdmi_reset_link(struct intel_encoder *encoder,\n\t\t\t\t struct drm_modeset_acquire_ctx *ctx)\n{\n\tstruct drm_i915_private *dev_priv = to_i915(encoder->base.dev);\n\tstruct intel_hdmi *hdmi = enc_to_intel_hdmi(encoder);\n\tstruct intel_connector *connector = hdmi->attached_connector;\n\tstruct i2c_adapter *adapter =\n\t\tintel_gmbus_get_adapter(dev_priv, hdmi->ddc_bus);\n\tstruct drm_connector_state *conn_state;\n\tstruct intel_crtc_state *crtc_state;\n\tstruct intel_crtc *crtc;\n\tu8 config;\n\tint ret;\n\n\tif (!connector || connector->base.status != connector_status_connected)\n\t\treturn 0;\n\n\tret = drm_modeset_lock(&dev_priv->drm.mode_config.connection_mutex,\n\t\t\t       ctx);\n\tif (ret)\n\t\treturn ret;\n\n\tconn_state = connector->base.state;\n\n\tcrtc = to_intel_crtc(conn_state->crtc);\n\tif (!crtc)\n\t\treturn 0;\n\n\tret = drm_modeset_lock(&crtc->base.mutex, ctx);\n\tif (ret)\n\t\treturn ret;\n\n\tcrtc_state = to_intel_crtc_state(crtc->base.state);\n\n\tdrm_WARN_ON(&dev_priv->drm,\n\t\t    !intel_crtc_has_type(crtc_state, INTEL_OUTPUT_HDMI));\n\n\tif (!crtc_state->hw.active)\n\t\treturn 0;\n\n\tif (!crtc_state->hdmi_high_tmds_clock_ratio &&\n\t    !crtc_state->hdmi_scrambling)\n\t\treturn 0;\n\n\tif (conn_state->commit &&\n\t    !try_wait_for_completion(&conn_state->commit->hw_done))\n\t\treturn 0;\n\n\tret = drm_scdc_readb(adapter, SCDC_TMDS_CONFIG, &config);\n\tif (ret < 0) {\n\t\tdrm_err(&dev_priv->drm, \"[CONNECTOR:%d:%s] Failed to read TMDS config: %d\\n\",\n\t\t\tconnector->base.base.id, connector->base.name, ret);\n\t\treturn 0;\n\t}\n\n\tif (!!(config & SCDC_TMDS_BIT_CLOCK_RATIO_BY_40) ==\n\t    crtc_state->hdmi_high_tmds_clock_ratio &&\n\t    !!(config & SCDC_SCRAMBLING_ENABLE) ==\n\t    crtc_state->hdmi_scrambling)\n\t\treturn 0;\n\n\t \n\treturn modeset_pipe(&crtc->base, ctx);\n}\n\nstatic enum intel_hotplug_state\nintel_ddi_hotplug(struct intel_encoder *encoder,\n\t\t  struct intel_connector *connector)\n{\n\tstruct drm_i915_private *i915 = to_i915(encoder->base.dev);\n\tstruct intel_digital_port *dig_port = enc_to_dig_port(encoder);\n\tstruct intel_dp *intel_dp = &dig_port->dp;\n\tenum phy phy = intel_port_to_phy(i915, encoder->port);\n\tbool is_tc = intel_phy_is_tc(i915, phy);\n\tstruct drm_modeset_acquire_ctx ctx;\n\tenum intel_hotplug_state state;\n\tint ret;\n\n\tif (intel_dp->compliance.test_active &&\n\t    intel_dp->compliance.test_type == DP_TEST_LINK_PHY_TEST_PATTERN) {\n\t\tintel_dp_phy_test(encoder);\n\t\t \n\t\treturn INTEL_HOTPLUG_UNCHANGED;\n\t}\n\n\tstate = intel_encoder_hotplug(encoder, connector);\n\n\tif (!intel_tc_port_link_reset(dig_port)) {\n\t\tintel_modeset_lock_ctx_retry(&ctx, NULL, 0, ret) {\n\t\t\tif (connector->base.connector_type == DRM_MODE_CONNECTOR_HDMIA)\n\t\t\t\tret = intel_hdmi_reset_link(encoder, &ctx);\n\t\t\telse\n\t\t\t\tret = intel_dp_retrain_link(encoder, &ctx);\n\t\t}\n\n\t\tdrm_WARN_ON(encoder->base.dev, ret);\n\t}\n\n\t \n\tif (state == INTEL_HOTPLUG_UNCHANGED &&\n\t    connector->hotplug_retries < (is_tc ? 5 : 1) &&\n\t    !dig_port->dp.is_mst)\n\t\tstate = INTEL_HOTPLUG_RETRY;\n\n\treturn state;\n}\n\nstatic bool lpt_digital_port_connected(struct intel_encoder *encoder)\n{\n\tstruct drm_i915_private *dev_priv = to_i915(encoder->base.dev);\n\tu32 bit = dev_priv->display.hotplug.pch_hpd[encoder->hpd_pin];\n\n\treturn intel_de_read(dev_priv, SDEISR) & bit;\n}\n\nstatic bool hsw_digital_port_connected(struct intel_encoder *encoder)\n{\n\tstruct drm_i915_private *dev_priv = to_i915(encoder->base.dev);\n\tu32 bit = dev_priv->display.hotplug.hpd[encoder->hpd_pin];\n\n\treturn intel_de_read(dev_priv, DEISR) & bit;\n}\n\nstatic bool bdw_digital_port_connected(struct intel_encoder *encoder)\n{\n\tstruct drm_i915_private *dev_priv = to_i915(encoder->base.dev);\n\tu32 bit = dev_priv->display.hotplug.hpd[encoder->hpd_pin];\n\n\treturn intel_de_read(dev_priv, GEN8_DE_PORT_ISR) & bit;\n}\n\nstatic struct intel_connector *\nintel_ddi_init_hdmi_connector(struct intel_digital_port *dig_port)\n{\n\tstruct intel_connector *connector;\n\tenum port port = dig_port->base.port;\n\n\tconnector = intel_connector_alloc();\n\tif (!connector)\n\t\treturn NULL;\n\n\tdig_port->hdmi.hdmi_reg = DDI_BUF_CTL(port);\n\tintel_hdmi_init_connector(dig_port, connector);\n\n\treturn connector;\n}\n\nstatic bool intel_ddi_a_force_4_lanes(struct intel_digital_port *dig_port)\n{\n\tstruct drm_i915_private *dev_priv = to_i915(dig_port->base.base.dev);\n\n\tif (dig_port->base.port != PORT_A)\n\t\treturn false;\n\n\tif (dig_port->saved_port_bits & DDI_A_4_LANES)\n\t\treturn false;\n\n\t \n\tif (IS_GEMINILAKE(dev_priv) || IS_BROXTON(dev_priv))\n\t\treturn true;\n\n\treturn false;\n}\n\nstatic int\nintel_ddi_max_lanes(struct intel_digital_port *dig_port)\n{\n\tstruct drm_i915_private *dev_priv = to_i915(dig_port->base.base.dev);\n\tenum port port = dig_port->base.port;\n\tint max_lanes = 4;\n\n\tif (DISPLAY_VER(dev_priv) >= 11)\n\t\treturn max_lanes;\n\n\tif (port == PORT_A || port == PORT_E) {\n\t\tif (intel_de_read(dev_priv, DDI_BUF_CTL(PORT_A)) & DDI_A_4_LANES)\n\t\t\tmax_lanes = port == PORT_A ? 4 : 0;\n\t\telse\n\t\t\t \n\t\t\tmax_lanes = 2;\n\t}\n\n\t \n\tif (intel_ddi_a_force_4_lanes(dig_port)) {\n\t\tdrm_dbg_kms(&dev_priv->drm,\n\t\t\t    \"Forcing DDI_A_4_LANES for port A\\n\");\n\t\tdig_port->saved_port_bits |= DDI_A_4_LANES;\n\t\tmax_lanes = 4;\n\t}\n\n\treturn max_lanes;\n}\n\nstatic enum hpd_pin xelpd_hpd_pin(struct drm_i915_private *dev_priv,\n\t\t\t\t  enum port port)\n{\n\tif (port >= PORT_D_XELPD)\n\t\treturn HPD_PORT_D + port - PORT_D_XELPD;\n\telse if (port >= PORT_TC1)\n\t\treturn HPD_PORT_TC1 + port - PORT_TC1;\n\telse\n\t\treturn HPD_PORT_A + port - PORT_A;\n}\n\nstatic enum hpd_pin dg1_hpd_pin(struct drm_i915_private *dev_priv,\n\t\t\t\tenum port port)\n{\n\tif (port >= PORT_TC1)\n\t\treturn HPD_PORT_C + port - PORT_TC1;\n\telse\n\t\treturn HPD_PORT_A + port - PORT_A;\n}\n\nstatic enum hpd_pin tgl_hpd_pin(struct drm_i915_private *dev_priv,\n\t\t\t\tenum port port)\n{\n\tif (port >= PORT_TC1)\n\t\treturn HPD_PORT_TC1 + port - PORT_TC1;\n\telse\n\t\treturn HPD_PORT_A + port - PORT_A;\n}\n\nstatic enum hpd_pin rkl_hpd_pin(struct drm_i915_private *dev_priv,\n\t\t\t\tenum port port)\n{\n\tif (HAS_PCH_TGP(dev_priv))\n\t\treturn tgl_hpd_pin(dev_priv, port);\n\n\tif (port >= PORT_TC1)\n\t\treturn HPD_PORT_C + port - PORT_TC1;\n\telse\n\t\treturn HPD_PORT_A + port - PORT_A;\n}\n\nstatic enum hpd_pin icl_hpd_pin(struct drm_i915_private *dev_priv,\n\t\t\t\tenum port port)\n{\n\tif (port >= PORT_C)\n\t\treturn HPD_PORT_TC1 + port - PORT_C;\n\telse\n\t\treturn HPD_PORT_A + port - PORT_A;\n}\n\nstatic enum hpd_pin ehl_hpd_pin(struct drm_i915_private *dev_priv,\n\t\t\t\tenum port port)\n{\n\tif (port == PORT_D)\n\t\treturn HPD_PORT_A;\n\n\tif (HAS_PCH_TGP(dev_priv))\n\t\treturn icl_hpd_pin(dev_priv, port);\n\n\treturn HPD_PORT_A + port - PORT_A;\n}\n\nstatic enum hpd_pin skl_hpd_pin(struct drm_i915_private *dev_priv, enum port port)\n{\n\tif (HAS_PCH_TGP(dev_priv))\n\t\treturn icl_hpd_pin(dev_priv, port);\n\n\treturn HPD_PORT_A + port - PORT_A;\n}\n\nstatic bool intel_ddi_is_tc(struct drm_i915_private *i915, enum port port)\n{\n\tif (DISPLAY_VER(i915) >= 12)\n\t\treturn port >= PORT_TC1;\n\telse if (DISPLAY_VER(i915) >= 11)\n\t\treturn port >= PORT_C;\n\telse\n\t\treturn false;\n}\n\nstatic void intel_ddi_encoder_suspend(struct intel_encoder *encoder)\n{\n\tintel_dp_encoder_suspend(encoder);\n}\n\nstatic void intel_ddi_tc_encoder_suspend_complete(struct intel_encoder *encoder)\n{\n\tstruct intel_dp *intel_dp = enc_to_intel_dp(encoder);\n\tstruct intel_digital_port *dig_port = dp_to_dig_port(intel_dp);\n\n\tintel_tc_port_suspend(dig_port);\n}\n\nstatic void intel_ddi_encoder_shutdown(struct intel_encoder *encoder)\n{\n\tintel_dp_encoder_shutdown(encoder);\n\tintel_hdmi_encoder_shutdown(encoder);\n}\n\nstatic void intel_ddi_tc_encoder_shutdown_complete(struct intel_encoder *encoder)\n{\n\tstruct intel_dp *intel_dp = enc_to_intel_dp(encoder);\n\tstruct intel_digital_port *dig_port = dp_to_dig_port(intel_dp);\n\n\tintel_tc_port_cleanup(dig_port);\n}\n\n#define port_tc_name(port) ((port) - PORT_TC1 + '1')\n#define tc_port_name(tc_port) ((tc_port) - TC_PORT_1 + '1')\n\nstatic bool port_strap_detected(struct drm_i915_private *i915, enum port port)\n{\n\t \n\tif (DISPLAY_VER(i915) >= 9)\n\t\treturn true;\n\n\tswitch (port) {\n\tcase PORT_A:\n\t\treturn intel_de_read(i915, DDI_BUF_CTL(PORT_A)) & DDI_INIT_DISPLAY_DETECTED;\n\tcase PORT_B:\n\t\treturn intel_de_read(i915, SFUSE_STRAP) & SFUSE_STRAP_DDIB_DETECTED;\n\tcase PORT_C:\n\t\treturn intel_de_read(i915, SFUSE_STRAP) & SFUSE_STRAP_DDIC_DETECTED;\n\tcase PORT_D:\n\t\treturn intel_de_read(i915, SFUSE_STRAP) & SFUSE_STRAP_DDID_DETECTED;\n\tcase PORT_E:\n\t\treturn true;  \n\tdefault:\n\t\tMISSING_CASE(port);\n\t\treturn false;\n\t}\n}\n\nstatic bool need_aux_ch(struct intel_encoder *encoder, bool init_dp)\n{\n\tstruct drm_i915_private *i915 = to_i915(encoder->base.dev);\n\tenum phy phy = intel_port_to_phy(i915, encoder->port);\n\n\treturn init_dp || intel_phy_is_tc(i915, phy);\n}\n\nstatic bool assert_has_icl_dsi(struct drm_i915_private *i915)\n{\n\treturn !drm_WARN(&i915->drm, !IS_ALDERLAKE_P(i915) &&\n\t\t\t !IS_TIGERLAKE(i915) && DISPLAY_VER(i915) != 11,\n\t\t\t \"Platform does not support DSI\\n\");\n}\n\nstatic bool port_in_use(struct drm_i915_private *i915, enum port port)\n{\n\tstruct intel_encoder *encoder;\n\n\tfor_each_intel_encoder(&i915->drm, encoder) {\n\t\t \n\t\tif (encoder->port == port)\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}\n\nvoid intel_ddi_init(struct drm_i915_private *dev_priv,\n\t\t    const struct intel_bios_encoder_data *devdata)\n{\n\tstruct intel_digital_port *dig_port;\n\tstruct intel_encoder *encoder;\n\tbool init_hdmi, init_dp;\n\tenum port port;\n\tenum phy phy;\n\n\tport = intel_bios_encoder_port(devdata);\n\tif (port == PORT_NONE)\n\t\treturn;\n\n\tif (!port_strap_detected(dev_priv, port)) {\n\t\tdrm_dbg_kms(&dev_priv->drm,\n\t\t\t    \"Port %c strap not detected\\n\", port_name(port));\n\t\treturn;\n\t}\n\n\tif (!assert_port_valid(dev_priv, port))\n\t\treturn;\n\n\tif (port_in_use(dev_priv, port)) {\n\t\tdrm_dbg_kms(&dev_priv->drm,\n\t\t\t    \"Port %c already claimed\\n\", port_name(port));\n\t\treturn;\n\t}\n\n\tif (intel_bios_encoder_supports_dsi(devdata)) {\n\t\t \n\t\tif (!assert_has_icl_dsi(dev_priv))\n\t\t\treturn;\n\n\t\ticl_dsi_init(dev_priv, devdata);\n\t\treturn;\n\t}\n\n\tphy = intel_port_to_phy(dev_priv, port);\n\n\t \n\tif (intel_hti_uses_phy(dev_priv, phy)) {\n\t\tdrm_dbg_kms(&dev_priv->drm, \"PORT %c / PHY %c reserved by HTI\\n\",\n\t\t\t    port_name(port), phy_name(phy));\n\t\treturn;\n\t}\n\n\tinit_hdmi = intel_bios_encoder_supports_dvi(devdata) ||\n\t\tintel_bios_encoder_supports_hdmi(devdata);\n\tinit_dp = intel_bios_encoder_supports_dp(devdata);\n\n\tif (intel_bios_encoder_is_lspcon(devdata)) {\n\t\t \n\t\tinit_dp = true;\n\t\tinit_hdmi = false;\n\t\tdrm_dbg_kms(&dev_priv->drm, \"VBT says port %c has lspcon\\n\",\n\t\t\t    port_name(port));\n\t}\n\n\tif (!init_dp && !init_hdmi) {\n\t\tdrm_dbg_kms(&dev_priv->drm,\n\t\t\t    \"VBT says port %c is not DVI/HDMI/DP compatible, respect it\\n\",\n\t\t\t    port_name(port));\n\t\treturn;\n\t}\n\n\tif (intel_phy_is_snps(dev_priv, phy) &&\n\t    dev_priv->display.snps.phy_failed_calibration & BIT(phy)) {\n\t\tdrm_dbg_kms(&dev_priv->drm,\n\t\t\t    \"SNPS PHY %c failed to calibrate, proceeding anyway\\n\",\n\t\t\t    phy_name(phy));\n\t}\n\n\tdig_port = kzalloc(sizeof(*dig_port), GFP_KERNEL);\n\tif (!dig_port)\n\t\treturn;\n\n\tdig_port->aux_ch = AUX_CH_NONE;\n\n\tencoder = &dig_port->base;\n\tencoder->devdata = devdata;\n\n\tif (DISPLAY_VER(dev_priv) >= 13 && port >= PORT_D_XELPD) {\n\t\tdrm_encoder_init(&dev_priv->drm, &encoder->base, &intel_ddi_funcs,\n\t\t\t\t DRM_MODE_ENCODER_TMDS,\n\t\t\t\t \"DDI %c/PHY %c\",\n\t\t\t\t port_name(port - PORT_D_XELPD + PORT_D),\n\t\t\t\t phy_name(phy));\n\t} else if (DISPLAY_VER(dev_priv) >= 12) {\n\t\tenum tc_port tc_port = intel_port_to_tc(dev_priv, port);\n\n\t\tdrm_encoder_init(&dev_priv->drm, &encoder->base, &intel_ddi_funcs,\n\t\t\t\t DRM_MODE_ENCODER_TMDS,\n\t\t\t\t \"DDI %s%c/PHY %s%c\",\n\t\t\t\t port >= PORT_TC1 ? \"TC\" : \"\",\n\t\t\t\t port >= PORT_TC1 ? port_tc_name(port) : port_name(port),\n\t\t\t\t tc_port != TC_PORT_NONE ? \"TC\" : \"\",\n\t\t\t\t tc_port != TC_PORT_NONE ? tc_port_name(tc_port) : phy_name(phy));\n\t} else if (DISPLAY_VER(dev_priv) >= 11) {\n\t\tenum tc_port tc_port = intel_port_to_tc(dev_priv, port);\n\n\t\tdrm_encoder_init(&dev_priv->drm, &encoder->base, &intel_ddi_funcs,\n\t\t\t\t DRM_MODE_ENCODER_TMDS,\n\t\t\t\t \"DDI %c%s/PHY %s%c\",\n\t\t\t\t port_name(port),\n\t\t\t\t port >= PORT_C ? \" (TC)\" : \"\",\n\t\t\t\t tc_port != TC_PORT_NONE ? \"TC\" : \"\",\n\t\t\t\t tc_port != TC_PORT_NONE ? tc_port_name(tc_port) : phy_name(phy));\n\t} else {\n\t\tdrm_encoder_init(&dev_priv->drm, &encoder->base, &intel_ddi_funcs,\n\t\t\t\t DRM_MODE_ENCODER_TMDS,\n\t\t\t\t \"DDI %c/PHY %c\", port_name(port),  phy_name(phy));\n\t}\n\n\tmutex_init(&dig_port->hdcp_mutex);\n\tdig_port->num_hdcp_streams = 0;\n\n\tencoder->hotplug = intel_ddi_hotplug;\n\tencoder->compute_output_type = intel_ddi_compute_output_type;\n\tencoder->compute_config = intel_ddi_compute_config;\n\tencoder->compute_config_late = intel_ddi_compute_config_late;\n\tencoder->enable = intel_enable_ddi;\n\tencoder->pre_pll_enable = intel_ddi_pre_pll_enable;\n\tencoder->pre_enable = intel_ddi_pre_enable;\n\tencoder->disable = intel_disable_ddi;\n\tencoder->post_pll_disable = intel_ddi_post_pll_disable;\n\tencoder->post_disable = intel_ddi_post_disable;\n\tencoder->update_pipe = intel_ddi_update_pipe;\n\tencoder->get_hw_state = intel_ddi_get_hw_state;\n\tencoder->sync_state = intel_ddi_sync_state;\n\tencoder->initial_fastset_check = intel_ddi_initial_fastset_check;\n\tencoder->suspend = intel_ddi_encoder_suspend;\n\tencoder->shutdown = intel_ddi_encoder_shutdown;\n\tencoder->get_power_domains = intel_ddi_get_power_domains;\n\n\tencoder->type = INTEL_OUTPUT_DDI;\n\tencoder->power_domain = intel_display_power_ddi_lanes_domain(dev_priv, port);\n\tencoder->port = port;\n\tencoder->cloneable = 0;\n\tencoder->pipe_mask = ~0;\n\n\tif (DISPLAY_VER(dev_priv) >= 14) {\n\t\tencoder->enable_clock = intel_mtl_pll_enable;\n\t\tencoder->disable_clock = intel_mtl_pll_disable;\n\t\tencoder->port_pll_type = intel_mtl_port_pll_type;\n\t\tencoder->get_config = mtl_ddi_get_config;\n\t} else if (IS_DG2(dev_priv)) {\n\t\tencoder->enable_clock = intel_mpllb_enable;\n\t\tencoder->disable_clock = intel_mpllb_disable;\n\t\tencoder->get_config = dg2_ddi_get_config;\n\t} else if (IS_ALDERLAKE_S(dev_priv)) {\n\t\tencoder->enable_clock = adls_ddi_enable_clock;\n\t\tencoder->disable_clock = adls_ddi_disable_clock;\n\t\tencoder->is_clock_enabled = adls_ddi_is_clock_enabled;\n\t\tencoder->get_config = adls_ddi_get_config;\n\t} else if (IS_ROCKETLAKE(dev_priv)) {\n\t\tencoder->enable_clock = rkl_ddi_enable_clock;\n\t\tencoder->disable_clock = rkl_ddi_disable_clock;\n\t\tencoder->is_clock_enabled = rkl_ddi_is_clock_enabled;\n\t\tencoder->get_config = rkl_ddi_get_config;\n\t} else if (IS_DG1(dev_priv)) {\n\t\tencoder->enable_clock = dg1_ddi_enable_clock;\n\t\tencoder->disable_clock = dg1_ddi_disable_clock;\n\t\tencoder->is_clock_enabled = dg1_ddi_is_clock_enabled;\n\t\tencoder->get_config = dg1_ddi_get_config;\n\t} else if (IS_JASPERLAKE(dev_priv) || IS_ELKHARTLAKE(dev_priv)) {\n\t\tif (intel_ddi_is_tc(dev_priv, port)) {\n\t\t\tencoder->enable_clock = jsl_ddi_tc_enable_clock;\n\t\t\tencoder->disable_clock = jsl_ddi_tc_disable_clock;\n\t\t\tencoder->is_clock_enabled = jsl_ddi_tc_is_clock_enabled;\n\t\t\tencoder->port_pll_type = icl_ddi_tc_port_pll_type;\n\t\t\tencoder->get_config = icl_ddi_combo_get_config;\n\t\t} else {\n\t\t\tencoder->enable_clock = icl_ddi_combo_enable_clock;\n\t\t\tencoder->disable_clock = icl_ddi_combo_disable_clock;\n\t\t\tencoder->is_clock_enabled = icl_ddi_combo_is_clock_enabled;\n\t\t\tencoder->get_config = icl_ddi_combo_get_config;\n\t\t}\n\t} else if (DISPLAY_VER(dev_priv) >= 11) {\n\t\tif (intel_ddi_is_tc(dev_priv, port)) {\n\t\t\tencoder->enable_clock = icl_ddi_tc_enable_clock;\n\t\t\tencoder->disable_clock = icl_ddi_tc_disable_clock;\n\t\t\tencoder->is_clock_enabled = icl_ddi_tc_is_clock_enabled;\n\t\t\tencoder->port_pll_type = icl_ddi_tc_port_pll_type;\n\t\t\tencoder->get_config = icl_ddi_tc_get_config;\n\t\t} else {\n\t\t\tencoder->enable_clock = icl_ddi_combo_enable_clock;\n\t\t\tencoder->disable_clock = icl_ddi_combo_disable_clock;\n\t\t\tencoder->is_clock_enabled = icl_ddi_combo_is_clock_enabled;\n\t\t\tencoder->get_config = icl_ddi_combo_get_config;\n\t\t}\n\t} else if (IS_GEMINILAKE(dev_priv) || IS_BROXTON(dev_priv)) {\n\t\t \n\t\tencoder->get_config = bxt_ddi_get_config;\n\t} else if (DISPLAY_VER(dev_priv) == 9) {\n\t\tencoder->enable_clock = skl_ddi_enable_clock;\n\t\tencoder->disable_clock = skl_ddi_disable_clock;\n\t\tencoder->is_clock_enabled = skl_ddi_is_clock_enabled;\n\t\tencoder->get_config = skl_ddi_get_config;\n\t} else if (IS_BROADWELL(dev_priv) || IS_HASWELL(dev_priv)) {\n\t\tencoder->enable_clock = hsw_ddi_enable_clock;\n\t\tencoder->disable_clock = hsw_ddi_disable_clock;\n\t\tencoder->is_clock_enabled = hsw_ddi_is_clock_enabled;\n\t\tencoder->get_config = hsw_ddi_get_config;\n\t}\n\n\tif (DISPLAY_VER(dev_priv) >= 14) {\n\t\tencoder->set_signal_levels = intel_cx0_phy_set_signal_levels;\n\t} else if (IS_DG2(dev_priv)) {\n\t\tencoder->set_signal_levels = intel_snps_phy_set_signal_levels;\n\t} else if (DISPLAY_VER(dev_priv) >= 12) {\n\t\tif (intel_phy_is_combo(dev_priv, phy))\n\t\t\tencoder->set_signal_levels = icl_combo_phy_set_signal_levels;\n\t\telse\n\t\t\tencoder->set_signal_levels = tgl_dkl_phy_set_signal_levels;\n\t} else if (DISPLAY_VER(dev_priv) >= 11) {\n\t\tif (intel_phy_is_combo(dev_priv, phy))\n\t\t\tencoder->set_signal_levels = icl_combo_phy_set_signal_levels;\n\t\telse\n\t\t\tencoder->set_signal_levels = icl_mg_phy_set_signal_levels;\n\t} else if (IS_GEMINILAKE(dev_priv) || IS_BROXTON(dev_priv)) {\n\t\tencoder->set_signal_levels = bxt_ddi_phy_set_signal_levels;\n\t} else {\n\t\tencoder->set_signal_levels = hsw_set_signal_levels;\n\t}\n\n\tintel_ddi_buf_trans_init(encoder);\n\n\tif (DISPLAY_VER(dev_priv) >= 13)\n\t\tencoder->hpd_pin = xelpd_hpd_pin(dev_priv, port);\n\telse if (IS_DG1(dev_priv))\n\t\tencoder->hpd_pin = dg1_hpd_pin(dev_priv, port);\n\telse if (IS_ROCKETLAKE(dev_priv))\n\t\tencoder->hpd_pin = rkl_hpd_pin(dev_priv, port);\n\telse if (DISPLAY_VER(dev_priv) >= 12)\n\t\tencoder->hpd_pin = tgl_hpd_pin(dev_priv, port);\n\telse if (IS_JASPERLAKE(dev_priv) || IS_ELKHARTLAKE(dev_priv))\n\t\tencoder->hpd_pin = ehl_hpd_pin(dev_priv, port);\n\telse if (DISPLAY_VER(dev_priv) == 11)\n\t\tencoder->hpd_pin = icl_hpd_pin(dev_priv, port);\n\telse if (DISPLAY_VER(dev_priv) == 9 && !IS_BROXTON(dev_priv))\n\t\tencoder->hpd_pin = skl_hpd_pin(dev_priv, port);\n\telse\n\t\tencoder->hpd_pin = intel_hpd_pin_default(dev_priv, port);\n\n\tif (DISPLAY_VER(dev_priv) >= 11)\n\t\tdig_port->saved_port_bits =\n\t\t\tintel_de_read(dev_priv, DDI_BUF_CTL(port))\n\t\t\t& DDI_BUF_PORT_REVERSAL;\n\telse\n\t\tdig_port->saved_port_bits =\n\t\t\tintel_de_read(dev_priv, DDI_BUF_CTL(port))\n\t\t\t& (DDI_BUF_PORT_REVERSAL | DDI_A_4_LANES);\n\n\tif (intel_bios_encoder_lane_reversal(devdata))\n\t\tdig_port->saved_port_bits |= DDI_BUF_PORT_REVERSAL;\n\n\tdig_port->dp.output_reg = INVALID_MMIO_REG;\n\tdig_port->max_lanes = intel_ddi_max_lanes(dig_port);\n\n\tif (need_aux_ch(encoder, init_dp)) {\n\t\tdig_port->aux_ch = intel_dp_aux_ch(encoder);\n\t\tif (dig_port->aux_ch == AUX_CH_NONE)\n\t\t\tgoto err;\n\t}\n\n\tif (intel_phy_is_tc(dev_priv, phy)) {\n\t\tbool is_legacy =\n\t\t\t!intel_bios_encoder_supports_typec_usb(devdata) &&\n\t\t\t!intel_bios_encoder_supports_tbt(devdata);\n\n\t\tif (!is_legacy && init_hdmi) {\n\t\t\tis_legacy = !init_dp;\n\n\t\t\tdrm_dbg_kms(&dev_priv->drm,\n\t\t\t\t    \"VBT says port %c is non-legacy TC and has HDMI (with DP: %s), assume it's %s\\n\",\n\t\t\t\t    port_name(port),\n\t\t\t\t    str_yes_no(init_dp),\n\t\t\t\t    is_legacy ? \"legacy\" : \"non-legacy\");\n\t\t}\n\n\t\tencoder->suspend_complete = intel_ddi_tc_encoder_suspend_complete;\n\t\tencoder->shutdown_complete = intel_ddi_tc_encoder_shutdown_complete;\n\n\t\tif (intel_tc_port_init(dig_port, is_legacy) < 0)\n\t\t\tgoto err;\n\t}\n\n\tdrm_WARN_ON(&dev_priv->drm, port > PORT_I);\n\tdig_port->ddi_io_power_domain = intel_display_power_ddi_io_domain(dev_priv, port);\n\n\tif (DISPLAY_VER(dev_priv) >= 11) {\n\t\tif (intel_phy_is_tc(dev_priv, phy))\n\t\t\tdig_port->connected = intel_tc_port_connected;\n\t\telse\n\t\t\tdig_port->connected = lpt_digital_port_connected;\n\t} else if (IS_GEMINILAKE(dev_priv) || IS_BROXTON(dev_priv)) {\n\t\tdig_port->connected = bdw_digital_port_connected;\n\t} else if (DISPLAY_VER(dev_priv) == 9) {\n\t\tdig_port->connected = lpt_digital_port_connected;\n\t} else if (IS_BROADWELL(dev_priv)) {\n\t\tif (port == PORT_A)\n\t\t\tdig_port->connected = bdw_digital_port_connected;\n\t\telse\n\t\t\tdig_port->connected = lpt_digital_port_connected;\n\t} else if (IS_HASWELL(dev_priv)) {\n\t\tif (port == PORT_A)\n\t\t\tdig_port->connected = hsw_digital_port_connected;\n\t\telse\n\t\t\tdig_port->connected = lpt_digital_port_connected;\n\t}\n\n\tintel_infoframe_init(dig_port);\n\n\tif (init_dp) {\n\t\tif (!intel_ddi_init_dp_connector(dig_port))\n\t\t\tgoto err;\n\n\t\tdig_port->hpd_pulse = intel_dp_hpd_pulse;\n\n\t\tif (dig_port->dp.mso_link_count)\n\t\t\tencoder->pipe_mask = intel_ddi_splitter_pipe_mask(dev_priv);\n\t}\n\n\t \n\tif (encoder->type != INTEL_OUTPUT_EDP && init_hdmi) {\n\t\tif (!intel_ddi_init_hdmi_connector(dig_port))\n\t\t\tgoto err;\n\t}\n\n\treturn;\n\nerr:\n\tdrm_encoder_cleanup(&encoder->base);\n\tkfree(dig_port);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}