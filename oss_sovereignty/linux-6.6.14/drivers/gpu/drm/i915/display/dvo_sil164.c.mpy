{
  "module_name": "dvo_sil164.c",
  "hash_id": "a9a7e4a07437dcae654539abfb695aece1943366f27338d0531cca7bded28980",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/i915/display/dvo_sil164.c",
  "human_readable_source": " \n\n#include \"intel_display_types.h\"\n#include \"intel_dvo_dev.h\"\n\n#define SIL164_VID 0x0001\n#define SIL164_DID 0x0006\n\n#define SIL164_VID_LO 0x00\n#define SIL164_VID_HI 0x01\n#define SIL164_DID_LO 0x02\n#define SIL164_DID_HI 0x03\n#define SIL164_REV    0x04\n#define SIL164_RSVD   0x05\n#define SIL164_FREQ_LO 0x06\n#define SIL164_FREQ_HI 0x07\n\n#define SIL164_REG8 0x08\n#define SIL164_8_VEN (1<<5)\n#define SIL164_8_HEN (1<<4)\n#define SIL164_8_DSEL (1<<3)\n#define SIL164_8_BSEL (1<<2)\n#define SIL164_8_EDGE (1<<1)\n#define SIL164_8_PD   (1<<0)\n\n#define SIL164_REG9 0x09\n#define SIL164_9_VLOW (1<<7)\n#define SIL164_9_MSEL_MASK (0x7<<4)\n#define SIL164_9_TSEL (1<<3)\n#define SIL164_9_RSEN (1<<2)\n#define SIL164_9_HTPLG (1<<1)\n#define SIL164_9_MDI (1<<0)\n\n#define SIL164_REGC 0x0c\n#define SIL164_C_SCNT (1<<7)\n#define SIL164_C_PLLF_MASK (0xf<<1)\n#define SIL164_C_PLLF_REC (4<<1)\n#define SIL164_C_PFEN (1<<0)\n\nstruct sil164_priv {\n\t\n\tbool quiet;\n};\n\n#define SILPTR(d) ((SIL164Ptr)(d->DriverPrivate.ptr))\n\nstatic bool sil164_readb(struct intel_dvo_device *dvo, int addr, u8 *ch)\n{\n\tstruct sil164_priv *sil = dvo->dev_priv;\n\tstruct i2c_adapter *adapter = dvo->i2c_bus;\n\tu8 out_buf[2];\n\tu8 in_buf[2];\n\n\tstruct i2c_msg msgs[] = {\n\t\t{\n\t\t\t.addr = dvo->slave_addr,\n\t\t\t.flags = 0,\n\t\t\t.len = 1,\n\t\t\t.buf = out_buf,\n\t\t},\n\t\t{\n\t\t\t.addr = dvo->slave_addr,\n\t\t\t.flags = I2C_M_RD,\n\t\t\t.len = 1,\n\t\t\t.buf = in_buf,\n\t\t}\n\t};\n\n\tout_buf[0] = addr;\n\tout_buf[1] = 0;\n\n\tif (i2c_transfer(adapter, msgs, 2) == 2) {\n\t\t*ch = in_buf[0];\n\t\treturn true;\n\t}\n\n\tif (!sil->quiet) {\n\t\tDRM_DEBUG_KMS(\"Unable to read register 0x%02x from %s:%02x.\\n\",\n\t\t\t  addr, adapter->name, dvo->slave_addr);\n\t}\n\treturn false;\n}\n\nstatic bool sil164_writeb(struct intel_dvo_device *dvo, int addr, u8 ch)\n{\n\tstruct sil164_priv *sil = dvo->dev_priv;\n\tstruct i2c_adapter *adapter = dvo->i2c_bus;\n\tu8 out_buf[2];\n\tstruct i2c_msg msg = {\n\t\t.addr = dvo->slave_addr,\n\t\t.flags = 0,\n\t\t.len = 2,\n\t\t.buf = out_buf,\n\t};\n\n\tout_buf[0] = addr;\n\tout_buf[1] = ch;\n\n\tif (i2c_transfer(adapter, &msg, 1) == 1)\n\t\treturn true;\n\n\tif (!sil->quiet) {\n\t\tDRM_DEBUG_KMS(\"Unable to write register 0x%02x to %s:%d.\\n\",\n\t\t\t  addr, adapter->name, dvo->slave_addr);\n\t}\n\n\treturn false;\n}\n\n \nstatic bool sil164_init(struct intel_dvo_device *dvo,\n\t\t\tstruct i2c_adapter *adapter)\n{\n\t \n\tstruct sil164_priv *sil;\n\tunsigned char ch;\n\n\tsil = kzalloc(sizeof(struct sil164_priv), GFP_KERNEL);\n\tif (sil == NULL)\n\t\treturn false;\n\n\tdvo->i2c_bus = adapter;\n\tdvo->dev_priv = sil;\n\tsil->quiet = true;\n\n\tif (!sil164_readb(dvo, SIL164_VID_LO, &ch))\n\t\tgoto out;\n\n\tif (ch != (SIL164_VID & 0xff)) {\n\t\tDRM_DEBUG_KMS(\"sil164 not detected got %d: from %s Slave %d.\\n\",\n\t\t\t  ch, adapter->name, dvo->slave_addr);\n\t\tgoto out;\n\t}\n\n\tif (!sil164_readb(dvo, SIL164_DID_LO, &ch))\n\t\tgoto out;\n\n\tif (ch != (SIL164_DID & 0xff)) {\n\t\tDRM_DEBUG_KMS(\"sil164 not detected got %d: from %s Slave %d.\\n\",\n\t\t\t  ch, adapter->name, dvo->slave_addr);\n\t\tgoto out;\n\t}\n\tsil->quiet = false;\n\n\tDRM_DEBUG_KMS(\"init sil164 dvo controller successfully!\\n\");\n\treturn true;\n\nout:\n\tkfree(sil);\n\treturn false;\n}\n\nstatic enum drm_connector_status sil164_detect(struct intel_dvo_device *dvo)\n{\n\tu8 reg9;\n\n\tsil164_readb(dvo, SIL164_REG9, &reg9);\n\n\tif (reg9 & SIL164_9_HTPLG)\n\t\treturn connector_status_connected;\n\telse\n\t\treturn connector_status_disconnected;\n}\n\nstatic enum drm_mode_status sil164_mode_valid(struct intel_dvo_device *dvo,\n\t\t\t\t\t      struct drm_display_mode *mode)\n{\n\treturn MODE_OK;\n}\n\nstatic void sil164_mode_set(struct intel_dvo_device *dvo,\n\t\t\t    const struct drm_display_mode *mode,\n\t\t\t    const struct drm_display_mode *adjusted_mode)\n{\n\t \n\t \n\t \n\t \n\n\tsil164_writeb(dvo, SIL164_REG8,\n\t\t      SIL164_8_VEN | SIL164_8_HEN);\n\tsil164_writeb(dvo, SIL164_REG9,\n\t\t      SIL164_9_TSEL);\n\tsil164_writeb(dvo, SIL164_REGC,\n\t\t      SIL164_C_PLLF_REC | SIL164_C_PFEN);\n}\n\n \nstatic void sil164_dpms(struct intel_dvo_device *dvo, bool enable)\n{\n\tint ret;\n\tunsigned char ch;\n\n\tret = sil164_readb(dvo, SIL164_REG8, &ch);\n\tif (ret == false)\n\t\treturn;\n\n\tif (enable)\n\t\tch |= SIL164_8_PD;\n\telse\n\t\tch &= ~SIL164_8_PD;\n\n\tsil164_writeb(dvo, SIL164_REG8, ch);\n}\n\nstatic bool sil164_get_hw_state(struct intel_dvo_device *dvo)\n{\n\tint ret;\n\tunsigned char ch;\n\n\tret = sil164_readb(dvo, SIL164_REG8, &ch);\n\tif (ret == false)\n\t\treturn false;\n\n\tif (ch & SIL164_8_PD)\n\t\treturn true;\n\telse\n\t\treturn false;\n}\n\nstatic void sil164_dump_regs(struct intel_dvo_device *dvo)\n{\n\tu8 val;\n\n\tsil164_readb(dvo, SIL164_FREQ_LO, &val);\n\tDRM_DEBUG_KMS(\"SIL164_FREQ_LO: 0x%02x\\n\", val);\n\tsil164_readb(dvo, SIL164_FREQ_HI, &val);\n\tDRM_DEBUG_KMS(\"SIL164_FREQ_HI: 0x%02x\\n\", val);\n\tsil164_readb(dvo, SIL164_REG8, &val);\n\tDRM_DEBUG_KMS(\"SIL164_REG8: 0x%02x\\n\", val);\n\tsil164_readb(dvo, SIL164_REG9, &val);\n\tDRM_DEBUG_KMS(\"SIL164_REG9: 0x%02x\\n\", val);\n\tsil164_readb(dvo, SIL164_REGC, &val);\n\tDRM_DEBUG_KMS(\"SIL164_REGC: 0x%02x\\n\", val);\n}\n\nstatic void sil164_destroy(struct intel_dvo_device *dvo)\n{\n\tstruct sil164_priv *sil = dvo->dev_priv;\n\n\tif (sil) {\n\t\tkfree(sil);\n\t\tdvo->dev_priv = NULL;\n\t}\n}\n\nconst struct intel_dvo_dev_ops sil164_ops = {\n\t.init = sil164_init,\n\t.detect = sil164_detect,\n\t.mode_valid = sil164_mode_valid,\n\t.mode_set = sil164_mode_set,\n\t.dpms = sil164_dpms,\n\t.get_hw_state = sil164_get_hw_state,\n\t.dump_regs = sil164_dump_regs,\n\t.destroy = sil164_destroy,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}