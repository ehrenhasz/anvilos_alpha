{
  "module_name": "intel_display_types.h",
  "hash_id": "95c56cf0132d3657a331f528f6ba7f1d2b88e6380b424acf817da491854dff48",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/i915/display/intel_display_types.h",
  "human_readable_source": " \n\n#ifndef __INTEL_DISPLAY_TYPES_H__\n#define __INTEL_DISPLAY_TYPES_H__\n\n#include <linux/i2c.h>\n#include <linux/pm_qos.h>\n#include <linux/pwm.h>\n#include <linux/sched/clock.h>\n\n#include <drm/display/drm_dp_dual_mode_helper.h>\n#include <drm/display/drm_dp_mst_helper.h>\n#include <drm/display/drm_dsc.h>\n#include <drm/drm_atomic.h>\n#include <drm/drm_crtc.h>\n#include <drm/drm_encoder.h>\n#include <drm/drm_fourcc.h>\n#include <drm/drm_framebuffer.h>\n#include <drm/drm_probe_helper.h>\n#include <drm/drm_rect.h>\n#include <drm/drm_vblank.h>\n#include <drm/drm_vblank_work.h>\n#include <drm/i915_hdcp_interface.h>\n#include <media/cec-notifier.h>\n\n#include \"i915_vma.h\"\n#include \"i915_vma_types.h\"\n#include \"intel_bios.h\"\n#include \"intel_display.h\"\n#include \"intel_display_limits.h\"\n#include \"intel_display_power.h\"\n#include \"intel_dpll_mgr.h\"\n#include \"intel_wm_types.h\"\n\nstruct drm_printer;\nstruct __intel_global_objs_state;\nstruct intel_ddi_buf_trans;\nstruct intel_fbc;\nstruct intel_connector;\nstruct intel_tc_port;\n\n \n\n \nenum intel_output_type {\n\tINTEL_OUTPUT_UNUSED = 0,\n\tINTEL_OUTPUT_ANALOG = 1,\n\tINTEL_OUTPUT_DVO = 2,\n\tINTEL_OUTPUT_SDVO = 3,\n\tINTEL_OUTPUT_LVDS = 4,\n\tINTEL_OUTPUT_TVOUT = 5,\n\tINTEL_OUTPUT_HDMI = 6,\n\tINTEL_OUTPUT_DP = 7,\n\tINTEL_OUTPUT_EDP = 8,\n\tINTEL_OUTPUT_DSI = 9,\n\tINTEL_OUTPUT_DDI = 10,\n\tINTEL_OUTPUT_DP_MST = 11,\n};\n\nenum hdmi_force_audio {\n\tHDMI_AUDIO_OFF_DVI = -2,\t \n\tHDMI_AUDIO_OFF,\t\t\t \n\tHDMI_AUDIO_AUTO,\t\t \n\tHDMI_AUDIO_ON,\t\t\t \n};\n\n \nenum intel_broadcast_rgb {\n\tINTEL_BROADCAST_RGB_AUTO,\n\tINTEL_BROADCAST_RGB_FULL,\n\tINTEL_BROADCAST_RGB_LIMITED,\n};\n\nstruct intel_fb_view {\n\t \n\tstruct i915_gtt_view gtt;\n\n\t \n\tstruct i915_color_plane_view {\n\t\tu32 offset;\n\t\tunsigned int x, y;\n\t\t \n\t\tunsigned int mapping_stride;\n\t\tunsigned int scanout_stride;\n\t} color_plane[4];\n};\n\nstruct intel_framebuffer {\n\tstruct drm_framebuffer base;\n\tstruct intel_frontbuffer *frontbuffer;\n\n\t \n\tstruct intel_fb_view normal_view;\n\tunion {\n\t\tstruct intel_fb_view rotated_view;\n\t\tstruct intel_fb_view remapped_view;\n\t};\n\n\tstruct i915_address_space *dpt_vm;\n};\n\nenum intel_hotplug_state {\n\tINTEL_HOTPLUG_UNCHANGED,\n\tINTEL_HOTPLUG_CHANGED,\n\tINTEL_HOTPLUG_RETRY,\n};\n\nstruct intel_encoder {\n\tstruct drm_encoder base;\n\n\tenum intel_output_type type;\n\tenum port port;\n\tu16 cloneable;\n\tu8 pipe_mask;\n\tenum intel_hotplug_state (*hotplug)(struct intel_encoder *encoder,\n\t\t\t\t\t    struct intel_connector *connector);\n\tenum intel_output_type (*compute_output_type)(struct intel_encoder *,\n\t\t\t\t\t\t      struct intel_crtc_state *,\n\t\t\t\t\t\t      struct drm_connector_state *);\n\tint (*compute_config)(struct intel_encoder *,\n\t\t\t      struct intel_crtc_state *,\n\t\t\t      struct drm_connector_state *);\n\tint (*compute_config_late)(struct intel_encoder *,\n\t\t\t\t   struct intel_crtc_state *,\n\t\t\t\t   struct drm_connector_state *);\n\tvoid (*pre_pll_enable)(struct intel_atomic_state *,\n\t\t\t       struct intel_encoder *,\n\t\t\t       const struct intel_crtc_state *,\n\t\t\t       const struct drm_connector_state *);\n\tvoid (*pre_enable)(struct intel_atomic_state *,\n\t\t\t   struct intel_encoder *,\n\t\t\t   const struct intel_crtc_state *,\n\t\t\t   const struct drm_connector_state *);\n\tvoid (*enable)(struct intel_atomic_state *,\n\t\t       struct intel_encoder *,\n\t\t       const struct intel_crtc_state *,\n\t\t       const struct drm_connector_state *);\n\tvoid (*disable)(struct intel_atomic_state *,\n\t\t\tstruct intel_encoder *,\n\t\t\tconst struct intel_crtc_state *,\n\t\t\tconst struct drm_connector_state *);\n\tvoid (*post_disable)(struct intel_atomic_state *,\n\t\t\t     struct intel_encoder *,\n\t\t\t     const struct intel_crtc_state *,\n\t\t\t     const struct drm_connector_state *);\n\tvoid (*post_pll_disable)(struct intel_atomic_state *,\n\t\t\t\t struct intel_encoder *,\n\t\t\t\t const struct intel_crtc_state *,\n\t\t\t\t const struct drm_connector_state *);\n\tvoid (*update_pipe)(struct intel_atomic_state *,\n\t\t\t    struct intel_encoder *,\n\t\t\t    const struct intel_crtc_state *,\n\t\t\t    const struct drm_connector_state *);\n\t \n\tbool (*get_hw_state)(struct intel_encoder *, enum pipe *pipe);\n\t \n\tvoid (*get_config)(struct intel_encoder *,\n\t\t\t   struct intel_crtc_state *pipe_config);\n\n\t \n\tvoid (*sync_state)(struct intel_encoder *encoder,\n\t\t\t   const struct intel_crtc_state *crtc_state);\n\n\t \n\tbool (*initial_fastset_check)(struct intel_encoder *encoder,\n\t\t\t\t      struct intel_crtc_state *crtc_state);\n\n\t \n\tvoid (*get_power_domains)(struct intel_encoder *encoder,\n\t\t\t\t  struct intel_crtc_state *crtc_state);\n\t \n\tvoid (*suspend)(struct intel_encoder *);\n\t \n\tvoid (*suspend_complete)(struct intel_encoder *encoder);\n\t \n\tvoid (*shutdown)(struct intel_encoder *encoder);\n\t \n\tvoid (*shutdown_complete)(struct intel_encoder *encoder);\n\t \n\tvoid (*enable_clock)(struct intel_encoder *encoder,\n\t\t\t     const struct intel_crtc_state *crtc_state);\n\tvoid (*disable_clock)(struct intel_encoder *encoder);\n\t \n\tbool (*is_clock_enabled)(struct intel_encoder *encoder);\n\t \n\tenum icl_port_dpll_id (*port_pll_type)(struct intel_encoder *encoder,\n\t\t\t\t\t       const struct intel_crtc_state *crtc_state);\n\tconst struct intel_ddi_buf_trans *(*get_buf_trans)(struct intel_encoder *encoder,\n\t\t\t\t\t\t\t   const struct intel_crtc_state *crtc_state,\n\t\t\t\t\t\t\t   int *n_entries);\n\tvoid (*set_signal_levels)(struct intel_encoder *encoder,\n\t\t\t\t  const struct intel_crtc_state *crtc_state);\n\n\tenum hpd_pin hpd_pin;\n\tenum intel_display_power_domain power_domain;\n\n\t \n\tconst struct intel_bios_encoder_data *devdata;\n};\n\nstruct intel_panel_bl_funcs {\n\t \n\tint (*setup)(struct intel_connector *connector, enum pipe pipe);\n\tu32 (*get)(struct intel_connector *connector, enum pipe pipe);\n\tvoid (*set)(const struct drm_connector_state *conn_state, u32 level);\n\tvoid (*disable)(const struct drm_connector_state *conn_state, u32 level);\n\tvoid (*enable)(const struct intel_crtc_state *crtc_state,\n\t\t       const struct drm_connector_state *conn_state, u32 level);\n\tu32 (*hz_to_pwm)(struct intel_connector *connector, u32 hz);\n};\n\nenum drrs_type {\n\tDRRS_TYPE_NONE,\n\tDRRS_TYPE_STATIC,\n\tDRRS_TYPE_SEAMLESS,\n};\n\nstruct intel_vbt_panel_data {\n\tstruct drm_display_mode *lfp_lvds_vbt_mode;  \n\tstruct drm_display_mode *sdvo_lvds_vbt_mode;  \n\n\t \n\tint panel_type;\n\tunsigned int lvds_dither:1;\n\tunsigned int bios_lvds_val;  \n\n\tbool vrr;\n\n\tu8 seamless_drrs_min_refresh_rate;\n\tenum drrs_type drrs_type;\n\n\tstruct {\n\t\tint max_link_rate;\n\t\tint rate;\n\t\tint lanes;\n\t\tint preemphasis;\n\t\tint vswing;\n\t\tint bpp;\n\t\tstruct edp_power_seq pps;\n\t\tu8 drrs_msa_timing_delay;\n\t\tbool low_vswing;\n\t\tbool initialized;\n\t\tbool hobl;\n\t} edp;\n\n\tstruct {\n\t\tbool enable;\n\t\tbool full_link;\n\t\tbool require_aux_wakeup;\n\t\tint idle_frames;\n\t\tint tp1_wakeup_time_us;\n\t\tint tp2_tp3_wakeup_time_us;\n\t\tint psr2_tp2_tp3_wakeup_time_us;\n\t} psr;\n\n\tstruct {\n\t\tu16 pwm_freq_hz;\n\t\tu16 brightness_precision_bits;\n\t\tu16 hdr_dpcd_refresh_timeout;\n\t\tbool present;\n\t\tbool active_low_pwm;\n\t\tu8 min_brightness;\t \n\t\ts8 controller;\t\t \n\t\tenum intel_backlight_type type;\n\t} backlight;\n\n\t \n\tstruct {\n\t\tu16 panel_id;\n\t\tstruct mipi_config *config;\n\t\tstruct mipi_pps_data *pps;\n\t\tu16 bl_ports;\n\t\tu16 cabc_ports;\n\t\tu8 seq_version;\n\t\tu32 size;\n\t\tu8 *data;\n\t\tconst u8 *sequence[MIPI_SEQ_MAX];\n\t\tu8 *deassert_seq;  \n\t\tenum drm_panel_orientation orientation;\n\t} dsi;\n};\n\nstruct intel_panel {\n\t \n\tconst struct drm_edid *fixed_edid;\n\n\tstruct list_head fixed_modes;\n\n\t \n\tstruct {\n\t\tbool present;\n\t\tu32 level;\n\t\tu32 min;\n\t\tu32 max;\n\t\tbool enabled;\n\t\tbool combination_mode;\t \n\t\tbool active_low_pwm;\n\t\tbool alternate_pwm_increment;\t \n\n\t\t \n\t\tu32 pwm_level_min;\n\t\tu32 pwm_level_max;\n\t\tbool pwm_enabled;\n\t\tbool util_pin_active_low;\t \n\t\tu8 controller;\t\t \n\t\tstruct pwm_device *pwm;\n\t\tstruct pwm_state pwm_state;\n\n\t\t \n\t\tunion {\n\t\t\tstruct {\n\t\t\t\tstruct drm_edp_backlight_info info;\n\t\t\t} vesa;\n\t\t\tstruct {\n\t\t\t\tbool sdr_uses_aux;\n\t\t\t} intel;\n\t\t} edp;\n\n\t\tstruct backlight_device *device;\n\n\t\tconst struct intel_panel_bl_funcs *funcs;\n\t\tconst struct intel_panel_bl_funcs *pwm_funcs;\n\t\tvoid (*power)(struct intel_connector *, bool enable);\n\t} backlight;\n\n\tstruct intel_vbt_panel_data vbt;\n};\n\nstruct intel_digital_port;\n\nenum check_link_response {\n\tHDCP_LINK_PROTECTED\t= 0,\n\tHDCP_TOPOLOGY_CHANGE,\n\tHDCP_LINK_INTEGRITY_FAILURE,\n\tHDCP_REAUTH_REQUEST\n};\n\n \nstruct intel_hdcp_shim {\n\t \n\tint (*write_an_aksv)(struct intel_digital_port *dig_port, u8 *an);\n\n\t \n\tint (*read_bksv)(struct intel_digital_port *dig_port, u8 *bksv);\n\n\t \n\tint (*read_bstatus)(struct intel_digital_port *dig_port,\n\t\t\t    u8 *bstatus);\n\n\t \n\tint (*repeater_present)(struct intel_digital_port *dig_port,\n\t\t\t\tbool *repeater_present);\n\n\t \n\tint (*read_ri_prime)(struct intel_digital_port *dig_port, u8 *ri);\n\n\t \n\tint (*read_ksv_ready)(struct intel_digital_port *dig_port,\n\t\t\t      bool *ksv_ready);\n\n\t \n\tint (*read_ksv_fifo)(struct intel_digital_port *dig_port,\n\t\t\t     int num_downstream, u8 *ksv_fifo);\n\n\t \n\tint (*read_v_prime_part)(struct intel_digital_port *dig_port,\n\t\t\t\t int i, u32 *part);\n\n\t \n\tint (*toggle_signalling)(struct intel_digital_port *dig_port,\n\t\t\t\t enum transcoder cpu_transcoder,\n\t\t\t\t bool enable);\n\n\t \n\tint (*stream_encryption)(struct intel_connector *connector,\n\t\t\t\t bool enable);\n\n\t \n\tbool (*check_link)(struct intel_digital_port *dig_port,\n\t\t\t   struct intel_connector *connector);\n\n\t \n\tint (*hdcp_capable)(struct intel_digital_port *dig_port,\n\t\t\t    bool *hdcp_capable);\n\n\t \n\tenum hdcp_wired_protocol protocol;\n\n\t \n\tint (*hdcp_2_2_capable)(struct intel_digital_port *dig_port,\n\t\t\t\tbool *capable);\n\n\t \n\tint (*write_2_2_msg)(struct intel_digital_port *dig_port,\n\t\t\t     void *buf, size_t size);\n\n\t \n\tint (*read_2_2_msg)(struct intel_digital_port *dig_port,\n\t\t\t    u8 msg_id, void *buf, size_t size);\n\n\t \n\tint (*config_stream_type)(struct intel_digital_port *dig_port,\n\t\t\t\t  bool is_repeater, u8 type);\n\n\t \n\tint (*stream_2_2_encryption)(struct intel_connector *connector,\n\t\t\t\t     bool enable);\n\n\t \n\tint (*check_2_2_link)(struct intel_digital_port *dig_port,\n\t\t\t      struct intel_connector *connector);\n};\n\nstruct intel_hdcp {\n\tconst struct intel_hdcp_shim *shim;\n\t \n\tstruct mutex mutex;\n\tu64 value;\n\tstruct delayed_work check_work;\n\tstruct work_struct prop_work;\n\n\t \n\tbool hdcp_encrypted;\n\n\t \n\t \n\tbool hdcp2_supported;\n\n\t \n\tbool hdcp2_encrypted;\n\n\t \n\tu8 content_type;\n\n\tbool is_paired;\n\tbool is_repeater;\n\n\t \n\tu32 seq_num_v;\n\n\t \n\tu32 seq_num_m;\n\n\t \n\twait_queue_head_t cp_irq_queue;\n\tatomic_t cp_irq_count;\n\tint cp_irq_count_cached;\n\n\t \n\tenum transcoder cpu_transcoder;\n\t \n\tenum transcoder stream_transcoder;\n};\n\nstruct intel_connector {\n\tstruct drm_connector base;\n\t \n\tstruct intel_encoder *encoder;\n\n\t \n\tu32 acpi_device_id;\n\n\t \n\tbool (*get_hw_state)(struct intel_connector *);\n\n\t \n\tstruct intel_panel panel;\n\n\t \n\tconst struct drm_edid *detect_edid;\n\n\t \n\tint hotplug_retries;\n\n\t \n\tu8 polled;\n\n\tstruct drm_dp_mst_port *port;\n\n\tstruct intel_dp *mst_port;\n\n\t \n\tstruct work_struct modeset_retry_work;\n\n\tstruct intel_hdcp hdcp;\n};\n\nstruct intel_digital_connector_state {\n\tstruct drm_connector_state base;\n\n\tenum hdmi_force_audio force_audio;\n\tint broadcast_rgb;\n};\n\n#define to_intel_digital_connector_state(x) container_of(x, struct intel_digital_connector_state, base)\n\nstruct dpll {\n\t \n\tint n;\n\tint m1, m2;\n\tint p1, p2;\n\t \n\tint\tdot;\n\tint\tvco;\n\tint\tm;\n\tint\tp;\n};\n\nstruct intel_atomic_state {\n\tstruct drm_atomic_state base;\n\n\tintel_wakeref_t wakeref;\n\n\tstruct __intel_global_objs_state *global_objs;\n\tint num_global_objs;\n\n\t \n\tbool internal;\n\n\tbool dpll_set, modeset;\n\n\tstruct intel_shared_dpll_state shared_dpll[I915_NUM_PLLS];\n\n\t \n\tbool skip_intermediate_wm;\n\n\tbool rps_interactive;\n\n\tstruct i915_sw_fence commit_ready;\n\n\tstruct llist_node freed;\n};\n\nstruct intel_plane_state {\n\tstruct drm_plane_state uapi;\n\n\t \n\tstruct {\n\t\tstruct drm_crtc *crtc;\n\t\tstruct drm_framebuffer *fb;\n\n\t\tu16 alpha;\n\t\tu16 pixel_blend_mode;\n\t\tunsigned int rotation;\n\t\tenum drm_color_encoding color_encoding;\n\t\tenum drm_color_range color_range;\n\t\tenum drm_scaling_filter scaling_filter;\n\t} hw;\n\n\tstruct i915_vma *ggtt_vma;\n\tstruct i915_vma *dpt_vma;\n\tunsigned long flags;\n#define PLANE_HAS_FENCE BIT(0)\n\n\tstruct intel_fb_view view;\n\n\t \n\tbool decrypt;\n\n\t \n\tbool force_black;\n\n\t \n\tu32 ctl;\n\n\t \n\tu32 color_ctl;\n\n\t \n\tu32 cus_ctl;\n\n\t \n\tint scaler_id;\n\n\t \n\tstruct intel_plane *planar_linked_plane;\n\n\t \n\tu32 planar_slave;\n\n\tstruct drm_intel_sprite_colorkey ckey;\n\n\tstruct drm_rect psr2_sel_fetch_area;\n\n\t \n\tu64 ccval;\n\n\tconst char *no_fbc_reason;\n};\n\nstruct intel_initial_plane_config {\n\tstruct intel_framebuffer *fb;\n\tstruct i915_vma *vma;\n\tunsigned int tiling;\n\tint size;\n\tu32 base;\n\tu8 rotation;\n};\n\nstruct intel_scaler {\n\tint in_use;\n\tu32 mode;\n};\n\nstruct intel_crtc_scaler_state {\n#define SKL_NUM_SCALERS 2\n\tstruct intel_scaler scalers[SKL_NUM_SCALERS];\n\n\t \n#define SKL_CRTC_INDEX 31\n\tunsigned scaler_users;\n\n\t \n\tint scaler_id;\n};\n\n \n \n#define I915_MODE_FLAG_GET_SCANLINE_FROM_TIMESTAMP (1<<1)\n \n#define I915_MODE_FLAG_USE_SCANLINE_COUNTER (1<<2)\n \n#define I915_MODE_FLAG_DSI_USE_TE0 (1<<3)\n \n#define I915_MODE_FLAG_DSI_USE_TE1 (1<<4)\n \n#define I915_MODE_FLAG_DSI_PERIODIC_CMD_MODE (1<<5)\n \n#define I915_MODE_FLAG_VRR (1<<6)\n\nstruct intel_wm_level {\n\tbool enable;\n\tu32 pri_val;\n\tu32 spr_val;\n\tu32 cur_val;\n\tu32 fbc_val;\n};\n\nstruct intel_pipe_wm {\n\tstruct intel_wm_level wm[5];\n\tbool fbc_wm_enabled;\n\tbool pipe_enabled;\n\tbool sprites_enabled;\n\tbool sprites_scaled;\n};\n\nstruct skl_wm_level {\n\tu16 min_ddb_alloc;\n\tu16 blocks;\n\tu8 lines;\n\tbool enable;\n\tbool ignore_lines;\n\tbool can_sagv;\n};\n\nstruct skl_plane_wm {\n\tstruct skl_wm_level wm[8];\n\tstruct skl_wm_level uv_wm[8];\n\tstruct skl_wm_level trans_wm;\n\tstruct {\n\t\tstruct skl_wm_level wm0;\n\t\tstruct skl_wm_level trans_wm;\n\t} sagv;\n\tbool is_planar;\n};\n\nstruct skl_pipe_wm {\n\tstruct skl_plane_wm planes[I915_MAX_PLANES];\n\tbool use_sagv_wm;\n};\n\nenum vlv_wm_level {\n\tVLV_WM_LEVEL_PM2,\n\tVLV_WM_LEVEL_PM5,\n\tVLV_WM_LEVEL_DDR_DVFS,\n\tNUM_VLV_WM_LEVELS,\n};\n\nstruct vlv_wm_state {\n\tstruct g4x_pipe_wm wm[NUM_VLV_WM_LEVELS];\n\tstruct g4x_sr_wm sr[NUM_VLV_WM_LEVELS];\n\tu8 num_levels;\n\tbool cxsr;\n};\n\nstruct vlv_fifo_state {\n\tu16 plane[I915_MAX_PLANES];\n};\n\nenum g4x_wm_level {\n\tG4X_WM_LEVEL_NORMAL,\n\tG4X_WM_LEVEL_SR,\n\tG4X_WM_LEVEL_HPLL,\n\tNUM_G4X_WM_LEVELS,\n};\n\nstruct g4x_wm_state {\n\tstruct g4x_pipe_wm wm;\n\tstruct g4x_sr_wm sr;\n\tstruct g4x_sr_wm hpll;\n\tbool cxsr;\n\tbool hpll_en;\n\tbool fbc_en;\n};\n\nstruct intel_crtc_wm_state {\n\tunion {\n\t\t \n\t\tstruct {\n\t\t\tstruct intel_pipe_wm intermediate;\n\t\t\tstruct intel_pipe_wm optimal;\n\t\t} ilk;\n\n\t\tstruct {\n\t\t\tstruct skl_pipe_wm raw;\n\t\t\t \n\t\t\tstruct skl_pipe_wm optimal;\n\t\t\tstruct skl_ddb_entry ddb;\n\t\t\t \n\t\t\tstruct skl_ddb_entry plane_ddb[I915_MAX_PLANES];\n\t\t\t \n\t\t\tstruct skl_ddb_entry plane_ddb_y[I915_MAX_PLANES];\n\t\t} skl;\n\n\t\tstruct {\n\t\t\tstruct g4x_pipe_wm raw[NUM_VLV_WM_LEVELS];  \n\t\t\tstruct vlv_wm_state intermediate;  \n\t\t\tstruct vlv_wm_state optimal;  \n\t\t\tstruct vlv_fifo_state fifo_state;\n\t\t} vlv;\n\n\t\tstruct {\n\t\t\tstruct g4x_pipe_wm raw[NUM_G4X_WM_LEVELS];\n\t\t\tstruct g4x_wm_state intermediate;\n\t\t\tstruct g4x_wm_state optimal;\n\t\t} g4x;\n\t};\n\n\t \n\tbool need_postvbl_update;\n};\n\nenum intel_output_format {\n\tINTEL_OUTPUT_FORMAT_RGB,\n\tINTEL_OUTPUT_FORMAT_YCBCR420,\n\tINTEL_OUTPUT_FORMAT_YCBCR444,\n};\n\nstruct intel_mpllb_state {\n\tu32 clock;  \n\tu32 ref_control;\n\tu32 mpllb_cp;\n\tu32 mpllb_div;\n\tu32 mpllb_div2;\n\tu32 mpllb_fracn1;\n\tu32 mpllb_fracn2;\n\tu32 mpllb_sscen;\n\tu32 mpllb_sscstep;\n};\n\n \nstruct intel_link_m_n {\n\tu32 tu;\n\tu32 data_m;\n\tu32 data_n;\n\tu32 link_m;\n\tu32 link_n;\n};\n\nstruct intel_csc_matrix {\n\tu16 coeff[9];\n\tu16 preoff[3];\n\tu16 postoff[3];\n};\n\nstruct intel_c10pll_state {\n\tu32 clock;  \n\tu8 tx;\n\tu8 cmn;\n\tu8 pll[20];\n};\n\nstruct intel_c20pll_state {\n\tu32 link_bit_rate;\n\tu32 clock;  \n\tu16 tx[3];\n\tu16 cmn[4];\n\tunion {\n\t\tu16 mplla[10];\n\t\tu16 mpllb[11];\n\t};\n};\n\nstruct intel_cx0pll_state {\n\tunion {\n\t\tstruct intel_c10pll_state c10;\n\t\tstruct intel_c20pll_state c20;\n\t};\n\tbool ssc_enabled;\n};\n\nstruct intel_crtc_state {\n\t \n\tstruct drm_crtc_state uapi;\n\n\t \n\tstruct {\n\t\tbool active, enable;\n\t\t \n\t\tstruct drm_property_blob *degamma_lut, *gamma_lut, *ctm;\n\t\tstruct drm_display_mode mode, pipe_mode, adjusted_mode;\n\t\tenum drm_scaling_filter scaling_filter;\n\t} hw;\n\n\t \n\tstruct drm_property_blob *pre_csc_lut, *post_csc_lut;\n\n\tstruct intel_csc_matrix csc, output_csc;\n\n\t \n#define PIPE_CONFIG_QUIRK_MODE_SYNC_FLAGS\t(1<<0)  \n\tunsigned long quirks;\n\n\tunsigned fb_bits;  \n\tbool update_pipe;  \n\tbool disable_cxsr;\n\tbool update_wm_pre, update_wm_post;  \n\tbool fifo_changed;  \n\tbool preload_luts;\n\tbool inherited;  \n\n\t \n\tbool do_async_flip;\n\n\t \n\tstruct drm_rect pipe_src;\n\n\t \n\tunsigned int pixel_rate;\n\n\t \n\tbool has_pch_encoder;\n\n\t \n\tbool has_infoframe;\n\n\t \n\tenum transcoder cpu_transcoder;\n\n\t \n\tbool limited_color_range;\n\n\t \n\tunsigned int output_types;\n\n\t \n\tbool has_hdmi_sink;\n\n\t \n\tbool has_audio;\n\n\t \n\tbool dither;\n\n\t \n\tbool dither_force_disable;\n\n\t \n\tbool clock_set;\n\n\t \n\tbool sdvo_tv_clock;\n\n\t \n\tbool bw_constrained;\n\n\t \n\tstruct dpll dpll;\n\n\t \n\tstruct intel_shared_dpll *shared_dpll;\n\n\t \n\tunion {\n\t\tstruct intel_dpll_hw_state dpll_hw_state;\n\t\tstruct intel_mpllb_state mpllb_state;\n\t\tstruct intel_cx0pll_state cx0pll_state;\n\t};\n\n\t \n\tstruct icl_port_dpll {\n\t\tstruct intel_shared_dpll *pll;\n\t\tstruct intel_dpll_hw_state hw_state;\n\t} icl_port_dplls[ICL_PORT_DPLL_COUNT];\n\n\t \n\tstruct {\n\t\tu32 ctrl, div;\n\t} dsi_pll;\n\n\tint pipe_bpp;\n\tstruct intel_link_m_n dp_m_n;\n\n\t \n\tstruct intel_link_m_n dp_m2_n2;\n\tbool has_drrs;\n\tbool seamless_m_n;\n\n\t \n\tbool has_psr;\n\tbool has_psr2;\n\tbool enable_psr2_sel_fetch;\n\tbool req_psr2_sdp_prior_scanline;\n\tbool wm_level_disabled;\n\tu32 dc3co_exitline;\n\tu16 su_y_granularity;\n\tstruct drm_dp_vsc_sdp psr_vsc;\n\n\t \n\tint port_clock;\n\n\t \n\tunsigned pixel_multiplier;\n\n\t \n\tu8 mode_flags;\n\n\tu8 lane_count;\n\n\t \n\tu8 lane_lat_optim_mask;\n\n\t \n\tu8 min_voltage_level;\n\n\t \n\tstruct {\n\t\tu32 control;\n\t\tu32 pgm_ratios;\n\t\tu32 lvds_border_bits;\n\t} gmch_pfit;\n\n\t \n\tstruct {\n\t\tstruct drm_rect dst;\n\t\tbool enabled;\n\t\tbool force_thru;\n\t} pch_pfit;\n\n\t \n\tint fdi_lanes;\n\tstruct intel_link_m_n fdi_m_n;\n\n\tbool ips_enabled;\n\n\tbool crc_enabled;\n\n\tbool double_wide;\n\n\tint pbn;\n\n\tstruct intel_crtc_scaler_state scaler_state;\n\n\t \n\tenum pipe hsw_workaround_pipe;\n\n\t \n\tbool disable_lp_wm;\n\n\tstruct intel_crtc_wm_state wm;\n\n\tint min_cdclk[I915_MAX_PLANES];\n\n\t \n\tu32 data_rate[I915_MAX_PLANES];\n\t \n\tu32 data_rate_y[I915_MAX_PLANES];\n\n\t \n\tu64 rel_data_rate[I915_MAX_PLANES];\n\tu64 rel_data_rate_y[I915_MAX_PLANES];\n\n\t \n\tu32 gamma_mode;\n\n\tunion {\n\t\t \n\t\tu32 csc_mode;\n\n\t\t \n\t\tu32 cgm_mode;\n\t};\n\n\t \n\tu8 enabled_planes;\n\n\t \n\tu8 active_planes;\n\tu8 scaled_planes;\n\tu8 nv12_planes;\n\tu8 c8_planes;\n\n\t \n\tu8 update_planes;\n\n\t \n\tu8 async_flip_planes;\n\n\tu8 framestart_delay;  \n\tu8 msa_timing_delay;  \n\n\tstruct {\n\t\tu32 enable;\n\t\tu32 gcp;\n\t\tunion hdmi_infoframe avi;\n\t\tunion hdmi_infoframe spd;\n\t\tunion hdmi_infoframe hdmi;\n\t\tunion hdmi_infoframe drm;\n\t\tstruct drm_dp_vsc_sdp vsc;\n\t} infoframes;\n\n\tu8 eld[MAX_ELD_BYTES];\n\n\t \n\tbool hdmi_scrambling;\n\n\t \n\tbool hdmi_high_tmds_clock_ratio;\n\n\t \n\tenum intel_output_format output_format;\n\n\t \n\tenum intel_output_format sink_format;\n\n\t \n\tbool gamma_enable;\n\n\t \n\tbool csc_enable;\n\n\t \n\tbool wgc_enable;\n\n\t \n\tu8 bigjoiner_pipes;\n\n\t \n\tstruct {\n\t\tbool compression_enable;\n\t\tbool dsc_split;\n\t\tu16 compressed_bpp;\n\t\tu8 slice_count;\n\t\tstruct drm_dsc_config config;\n\t} dsc;\n\n\t \n\tu16 linetime;\n\tu16 ips_linetime;\n\n\tbool enhanced_framing;\n\n\t \n\tbool fec_enable;\n\n\tbool sdp_split_enable;\n\n\t \n\tenum transcoder master_transcoder;\n\n\t \n\tu8 sync_mode_slaves_mask;\n\n\t \n\tenum transcoder mst_master_transcoder;\n\n\t \n\tstruct intel_dsb *dsb;\n\n\tu32 psr2_man_track_ctl;\n\n\t \n\tstruct {\n\t\tbool enable;\n\t\tu8 pipeline_full;\n\t\tu16 flipline, vmin, vmax, guardband;\n\t} vrr;\n\n\t \n\tstruct {\n\t\tbool enable;\n\t\tu8 link_count;\n\t\tu8 pixel_overlap;\n\t} splitter;\n\n\t \n\tstruct drm_vblank_work vblank_work;\n};\n\nenum intel_pipe_crc_source {\n\tINTEL_PIPE_CRC_SOURCE_NONE,\n\tINTEL_PIPE_CRC_SOURCE_PLANE1,\n\tINTEL_PIPE_CRC_SOURCE_PLANE2,\n\tINTEL_PIPE_CRC_SOURCE_PLANE3,\n\tINTEL_PIPE_CRC_SOURCE_PLANE4,\n\tINTEL_PIPE_CRC_SOURCE_PLANE5,\n\tINTEL_PIPE_CRC_SOURCE_PLANE6,\n\tINTEL_PIPE_CRC_SOURCE_PLANE7,\n\tINTEL_PIPE_CRC_SOURCE_PIPE,\n\t \n\tINTEL_PIPE_CRC_SOURCE_TV,\n\tINTEL_PIPE_CRC_SOURCE_DP_B,\n\tINTEL_PIPE_CRC_SOURCE_DP_C,\n\tINTEL_PIPE_CRC_SOURCE_DP_D,\n\tINTEL_PIPE_CRC_SOURCE_AUTO,\n\tINTEL_PIPE_CRC_SOURCE_MAX,\n};\n\nenum drrs_refresh_rate {\n\tDRRS_REFRESH_RATE_HIGH,\n\tDRRS_REFRESH_RATE_LOW,\n};\n\n#define INTEL_PIPE_CRC_ENTRIES_NR\t128\nstruct intel_pipe_crc {\n\tspinlock_t lock;\n\tint skipped;\n\tenum intel_pipe_crc_source source;\n};\n\nstruct intel_crtc {\n\tstruct drm_crtc base;\n\tenum pipe pipe;\n\t \n\tbool active;\n\tu8 plane_ids_mask;\n\n\t \n\tu8 mode_flags;\n\n\tu16 vmax_vblank_start;\n\n\tstruct intel_display_power_domain_set enabled_power_domains;\n\tstruct intel_display_power_domain_set hw_readout_power_domains;\n\tstruct intel_overlay *overlay;\n\n\tstruct intel_crtc_state *config;\n\n\t \n\tbool cpu_fifo_underrun_disabled;\n\tbool pch_fifo_underrun_disabled;\n\n\t \n\tstruct {\n\t\t \n\t\tunion {\n\t\t\tstruct intel_pipe_wm ilk;\n\t\t\tstruct vlv_wm_state vlv;\n\t\t\tstruct g4x_wm_state g4x;\n\t\t} active;\n\t} wm;\n\n\tstruct {\n\t\tstruct mutex mutex;\n\t\tstruct delayed_work work;\n\t\tenum drrs_refresh_rate refresh_rate;\n\t\tunsigned int frontbuffer_bits;\n\t\tunsigned int busy_frontbuffer_bits;\n\t\tenum transcoder cpu_transcoder;\n\t\tstruct intel_link_m_n m_n, m2_n2;\n\t} drrs;\n\n\tint scanline_offset;\n\n\tstruct {\n\t\tunsigned start_vbl_count;\n\t\tktime_t start_vbl_time;\n\t\tint min_vbl, max_vbl;\n\t\tint scanline_start;\n#ifdef CONFIG_DRM_I915_DEBUG_VBLANK_EVADE\n\t\tstruct {\n\t\t\tu64 min;\n\t\t\tu64 max;\n\t\t\tu64 sum;\n\t\t\tunsigned int over;\n\t\t\tunsigned int times[17];  \n\t\t} vbl;\n#endif\n\t} debug;\n\n\t \n\tint num_scalers;\n\n\t \n\tstruct pm_qos_request vblank_pm_qos;\n\n#ifdef CONFIG_DEBUG_FS\n\tstruct intel_pipe_crc pipe_crc;\n#endif\n};\n\nstruct intel_plane {\n\tstruct drm_plane base;\n\tenum i9xx_plane_id i9xx_plane;\n\tenum plane_id id;\n\tenum pipe pipe;\n\tbool need_async_flip_disable_wa;\n\tu32 frontbuffer_bit;\n\n\tstruct {\n\t\tu32 base, cntl, size;\n\t} cursor;\n\n\tstruct intel_fbc *fbc;\n\n\t \n\n\tint (*min_width)(const struct drm_framebuffer *fb,\n\t\t\t int color_plane,\n\t\t\t unsigned int rotation);\n\tint (*max_width)(const struct drm_framebuffer *fb,\n\t\t\t int color_plane,\n\t\t\t unsigned int rotation);\n\tint (*max_height)(const struct drm_framebuffer *fb,\n\t\t\t  int color_plane,\n\t\t\t  unsigned int rotation);\n\tunsigned int (*max_stride)(struct intel_plane *plane,\n\t\t\t\t   u32 pixel_format, u64 modifier,\n\t\t\t\t   unsigned int rotation);\n\t \n\tvoid (*update_noarm)(struct intel_plane *plane,\n\t\t\t     const struct intel_crtc_state *crtc_state,\n\t\t\t     const struct intel_plane_state *plane_state);\n\t \n\tvoid (*update_arm)(struct intel_plane *plane,\n\t\t\t   const struct intel_crtc_state *crtc_state,\n\t\t\t   const struct intel_plane_state *plane_state);\n\t \n\tvoid (*disable_arm)(struct intel_plane *plane,\n\t\t\t    const struct intel_crtc_state *crtc_state);\n\tbool (*get_hw_state)(struct intel_plane *plane, enum pipe *pipe);\n\tint (*check_plane)(struct intel_crtc_state *crtc_state,\n\t\t\t   struct intel_plane_state *plane_state);\n\tint (*min_cdclk)(const struct intel_crtc_state *crtc_state,\n\t\t\t const struct intel_plane_state *plane_state);\n\tvoid (*async_flip)(struct intel_plane *plane,\n\t\t\t   const struct intel_crtc_state *crtc_state,\n\t\t\t   const struct intel_plane_state *plane_state,\n\t\t\t   bool async_flip);\n\tvoid (*enable_flip_done)(struct intel_plane *plane);\n\tvoid (*disable_flip_done)(struct intel_plane *plane);\n};\n\nstruct intel_watermark_params {\n\tu16 fifo_size;\n\tu16 max_wm;\n\tu8 default_wm;\n\tu8 guard_size;\n\tu8 cacheline_size;\n};\n\n#define to_intel_atomic_state(x) container_of(x, struct intel_atomic_state, base)\n#define to_intel_crtc(x) container_of(x, struct intel_crtc, base)\n#define to_intel_crtc_state(x) container_of(x, struct intel_crtc_state, uapi)\n#define to_intel_connector(x) container_of(x, struct intel_connector, base)\n#define to_intel_encoder(x) container_of(x, struct intel_encoder, base)\n#define to_intel_framebuffer(x) container_of(x, struct intel_framebuffer, base)\n#define to_intel_plane(x) container_of(x, struct intel_plane, base)\n#define to_intel_plane_state(x) container_of(x, struct intel_plane_state, uapi)\n#define intel_fb_obj(x) ((x) ? to_intel_bo((x)->obj[0]) : NULL)\n\nstruct intel_hdmi {\n\ti915_reg_t hdmi_reg;\n\tint ddc_bus;\n\tstruct {\n\t\tenum drm_dp_dual_mode_type type;\n\t\tint max_tmds_clock;\n\t} dp_dual_mode;\n\tstruct intel_connector *attached_connector;\n\tstruct cec_notifier *cec_notifier;\n};\n\nstruct intel_dp_mst_encoder;\n\nstruct intel_dp_compliance_data {\n\tunsigned long edid;\n\tu8 video_pattern;\n\tu16 hdisplay, vdisplay;\n\tu8 bpc;\n\tstruct drm_dp_phy_test_params phytest;\n};\n\nstruct intel_dp_compliance {\n\tunsigned long test_type;\n\tstruct intel_dp_compliance_data test_data;\n\tbool test_active;\n\tint test_link_rate;\n\tu8 test_lane_count;\n};\n\nstruct intel_dp_pcon_frl {\n\tbool is_trained;\n\tint trained_rate_gbps;\n};\n\nstruct intel_pps {\n\tint panel_power_up_delay;\n\tint panel_power_down_delay;\n\tint panel_power_cycle_delay;\n\tint backlight_on_delay;\n\tint backlight_off_delay;\n\tstruct delayed_work panel_vdd_work;\n\tbool want_panel_vdd;\n\tbool initializing;\n\tunsigned long last_power_on;\n\tunsigned long last_backlight_off;\n\tktime_t panel_power_off_time;\n\tintel_wakeref_t vdd_wakeref;\n\n\tunion {\n\t\t \n\t\tenum pipe pps_pipe;\n\n\t\t \n\t\tint pps_idx;\n\t};\n\n\t \n\tenum pipe active_pipe;\n\t \n\tbool pps_reset;\n\tstruct edp_power_seq pps_delays;\n\tstruct edp_power_seq bios_pps_delays;\n};\n\nstruct intel_psr {\n\t \n\tstruct mutex lock;\n\n#define I915_PSR_DEBUG_MODE_MASK\t0x0f\n#define I915_PSR_DEBUG_DEFAULT\t\t0x00\n#define I915_PSR_DEBUG_DISABLE\t\t0x01\n#define I915_PSR_DEBUG_ENABLE\t\t0x02\n#define I915_PSR_DEBUG_FORCE_PSR1\t0x03\n#define I915_PSR_DEBUG_ENABLE_SEL_FETCH\t0x4\n#define I915_PSR_DEBUG_IRQ\t\t0x10\n\n\tu32 debug;\n\tbool sink_support;\n\tbool source_support;\n\tbool enabled;\n\tbool paused;\n\tenum pipe pipe;\n\tenum transcoder transcoder;\n\tbool active;\n\tstruct work_struct work;\n\tunsigned int busy_frontbuffer_bits;\n\tbool sink_psr2_support;\n\tbool link_standby;\n\tbool colorimetry_support;\n\tbool psr2_enabled;\n\tbool psr2_sel_fetch_enabled;\n\tbool psr2_sel_fetch_cff_enabled;\n\tbool req_psr2_sdp_prior_scanline;\n\tu8 sink_sync_latency;\n\tu8 io_wake_lines;\n\tu8 fast_wake_lines;\n\tktime_t last_entry_attempt;\n\tktime_t last_exit;\n\tbool sink_not_reliable;\n\tbool irq_aux_error;\n\tu16 su_w_granularity;\n\tu16 su_y_granularity;\n\tu32 dc3co_exitline;\n\tu32 dc3co_exit_delay;\n\tstruct delayed_work dc3co_work;\n};\n\nstruct intel_dp {\n\ti915_reg_t output_reg;\n\tu32 DP;\n\tint link_rate;\n\tu8 lane_count;\n\tu8 sink_count;\n\tbool link_trained;\n\tbool reset_link_params;\n\tbool use_max_params;\n\tu8 dpcd[DP_RECEIVER_CAP_SIZE];\n\tu8 psr_dpcd[EDP_PSR_RECEIVER_CAP_SIZE];\n\tu8 downstream_ports[DP_MAX_DOWNSTREAM_PORTS];\n\tu8 edp_dpcd[EDP_DISPLAY_CTL_CAP_SIZE];\n\tu8 dsc_dpcd[DP_DSC_RECEIVER_CAP_SIZE];\n\tu8 lttpr_common_caps[DP_LTTPR_COMMON_CAP_SIZE];\n\tu8 lttpr_phy_caps[DP_MAX_LTTPR_COUNT][DP_LTTPR_PHY_CAP_SIZE];\n\tu8 fec_capable;\n\tu8 pcon_dsc_dpcd[DP_PCON_DSC_ENCODER_CAP_SIZE];\n\t \n\tint num_source_rates;\n\tconst int *source_rates;\n\t \n\tint num_sink_rates;\n\tint sink_rates[DP_MAX_SUPPORTED_RATES];\n\tbool use_rate_select;\n\t \n\tint max_sink_lane_count;\n\t \n\tint num_common_rates;\n\tint common_rates[DP_MAX_SUPPORTED_RATES];\n\t \n\tint max_link_lane_count;\n\t \n\tint max_link_rate;\n\tint mso_link_count;\n\tint mso_pixel_overlap;\n\t \n\tstruct drm_dp_desc desc;\n\tstruct drm_dp_aux aux;\n\tu32 aux_busy_last_status;\n\tu8 train_set[4];\n\n\tstruct intel_pps pps;\n\n\tbool is_mst;\n\tint active_mst_links;\n\n\t \n\tstruct intel_connector *attached_connector;\n\n\t \n\tstruct intel_dp_mst_encoder *mst_encoders[I915_MAX_PIPES];\n\tstruct drm_dp_mst_topology_mgr mst_mgr;\n\n\tu32 (*get_aux_clock_divider)(struct intel_dp *dp, int index);\n\t \n\tu32 (*get_aux_send_ctl)(struct intel_dp *dp, int send_bytes,\n\t\t\t\tu32 aux_clock_divider);\n\n\ti915_reg_t (*aux_ch_ctl_reg)(struct intel_dp *dp);\n\ti915_reg_t (*aux_ch_data_reg)(struct intel_dp *dp, int index);\n\n\t \n\tvoid (*prepare_link_retrain)(struct intel_dp *intel_dp,\n\t\t\t\t     const struct intel_crtc_state *crtc_state);\n\tvoid (*set_link_train)(struct intel_dp *intel_dp,\n\t\t\t       const struct intel_crtc_state *crtc_state,\n\t\t\t       u8 dp_train_pat);\n\tvoid (*set_idle_link_train)(struct intel_dp *intel_dp,\n\t\t\t\t    const struct intel_crtc_state *crtc_state);\n\n\tu8 (*preemph_max)(struct intel_dp *intel_dp);\n\tu8 (*voltage_max)(struct intel_dp *intel_dp,\n\t\t\t  const struct intel_crtc_state *crtc_state);\n\n\t \n\tstruct intel_dp_compliance compliance;\n\n\t \n\tstruct {\n\t\tint min_tmds_clock, max_tmds_clock;\n\t\tint max_dotclock;\n\t\tint pcon_max_frl_bw;\n\t\tu8 max_bpc;\n\t\tbool ycbcr_444_to_420;\n\t\tbool ycbcr420_passthrough;\n\t\tbool rgb_to_ycbcr;\n\t} dfp;\n\n\t \n\tstruct pm_qos_request pm_qos;\n\n\t \n\tbool force_dsc_en;\n\tint force_dsc_output_format;\n\tint force_dsc_bpc;\n\n\tbool hobl_failed;\n\tbool hobl_active;\n\n\tstruct intel_dp_pcon_frl frl;\n\n\tstruct intel_psr psr;\n\n\t \n\tunsigned long last_oui_write;\n};\n\nenum lspcon_vendor {\n\tLSPCON_VENDOR_MCA,\n\tLSPCON_VENDOR_PARADE\n};\n\nstruct intel_lspcon {\n\tbool active;\n\tbool hdr_supported;\n\tenum drm_lspcon_mode mode;\n\tenum lspcon_vendor vendor;\n};\n\nstruct intel_digital_port {\n\tstruct intel_encoder base;\n\tu32 saved_port_bits;\n\tstruct intel_dp dp;\n\tstruct intel_hdmi hdmi;\n\tstruct intel_lspcon lspcon;\n\tenum irqreturn (*hpd_pulse)(struct intel_digital_port *, bool);\n\tbool release_cl2_override;\n\tu8 max_lanes;\n\t \n\tenum aux_ch aux_ch;\n\tenum intel_display_power_domain ddi_io_power_domain;\n\tintel_wakeref_t ddi_io_wakeref;\n\tintel_wakeref_t aux_wakeref;\n\n\tstruct intel_tc_port *tc;\n\n\t \n\tstruct mutex hdcp_mutex;\n\t \n\tunsigned int num_hdcp_streams;\n\t \n\tbool hdcp_auth_status;\n\t \n\tstruct hdcp_port_data hdcp_port_data;\n\t \n\tbool hdcp_mst_type1_capable;\n\n\tvoid (*write_infoframe)(struct intel_encoder *encoder,\n\t\t\t\tconst struct intel_crtc_state *crtc_state,\n\t\t\t\tunsigned int type,\n\t\t\t\tconst void *frame, ssize_t len);\n\tvoid (*read_infoframe)(struct intel_encoder *encoder,\n\t\t\t       const struct intel_crtc_state *crtc_state,\n\t\t\t       unsigned int type,\n\t\t\t       void *frame, ssize_t len);\n\tvoid (*set_infoframes)(struct intel_encoder *encoder,\n\t\t\t       bool enable,\n\t\t\t       const struct intel_crtc_state *crtc_state,\n\t\t\t       const struct drm_connector_state *conn_state);\n\tu32 (*infoframes_enabled)(struct intel_encoder *encoder,\n\t\t\t\t  const struct intel_crtc_state *pipe_config);\n\tbool (*connected)(struct intel_encoder *encoder);\n};\n\nstruct intel_dp_mst_encoder {\n\tstruct intel_encoder base;\n\tenum pipe pipe;\n\tstruct intel_digital_port *primary;\n\tstruct intel_connector *connector;\n};\n\nstatic inline struct intel_encoder *\nintel_attached_encoder(struct intel_connector *connector)\n{\n\treturn connector->encoder;\n}\n\nstatic inline bool intel_encoder_is_dig_port(struct intel_encoder *encoder)\n{\n\tswitch (encoder->type) {\n\tcase INTEL_OUTPUT_DDI:\n\tcase INTEL_OUTPUT_DP:\n\tcase INTEL_OUTPUT_EDP:\n\tcase INTEL_OUTPUT_HDMI:\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nstatic inline bool intel_encoder_is_mst(struct intel_encoder *encoder)\n{\n\treturn encoder->type == INTEL_OUTPUT_DP_MST;\n}\n\nstatic inline struct intel_dp_mst_encoder *\nenc_to_mst(struct intel_encoder *encoder)\n{\n\treturn container_of(&encoder->base, struct intel_dp_mst_encoder,\n\t\t\t    base.base);\n}\n\nstatic inline struct intel_digital_port *\nenc_to_dig_port(struct intel_encoder *encoder)\n{\n\tstruct intel_encoder *intel_encoder = encoder;\n\n\tif (intel_encoder_is_dig_port(intel_encoder))\n\t\treturn container_of(&encoder->base, struct intel_digital_port,\n\t\t\t\t    base.base);\n\telse if (intel_encoder_is_mst(intel_encoder))\n\t\treturn enc_to_mst(encoder)->primary;\n\telse\n\t\treturn NULL;\n}\n\nstatic inline struct intel_digital_port *\nintel_attached_dig_port(struct intel_connector *connector)\n{\n\treturn enc_to_dig_port(intel_attached_encoder(connector));\n}\n\nstatic inline struct intel_hdmi *\nenc_to_intel_hdmi(struct intel_encoder *encoder)\n{\n\treturn &enc_to_dig_port(encoder)->hdmi;\n}\n\nstatic inline struct intel_hdmi *\nintel_attached_hdmi(struct intel_connector *connector)\n{\n\treturn enc_to_intel_hdmi(intel_attached_encoder(connector));\n}\n\nstatic inline struct intel_dp *enc_to_intel_dp(struct intel_encoder *encoder)\n{\n\treturn &enc_to_dig_port(encoder)->dp;\n}\n\nstatic inline struct intel_dp *intel_attached_dp(struct intel_connector *connector)\n{\n\treturn enc_to_intel_dp(intel_attached_encoder(connector));\n}\n\nstatic inline bool intel_encoder_is_dp(struct intel_encoder *encoder)\n{\n\tswitch (encoder->type) {\n\tcase INTEL_OUTPUT_DP:\n\tcase INTEL_OUTPUT_EDP:\n\t\treturn true;\n\tcase INTEL_OUTPUT_DDI:\n\t\t \n\t\treturn i915_mmio_reg_valid(enc_to_intel_dp(encoder)->output_reg);\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nstatic inline struct intel_lspcon *\nenc_to_intel_lspcon(struct intel_encoder *encoder)\n{\n\treturn &enc_to_dig_port(encoder)->lspcon;\n}\n\nstatic inline struct intel_digital_port *\ndp_to_dig_port(struct intel_dp *intel_dp)\n{\n\treturn container_of(intel_dp, struct intel_digital_port, dp);\n}\n\nstatic inline struct intel_lspcon *\ndp_to_lspcon(struct intel_dp *intel_dp)\n{\n\treturn &dp_to_dig_port(intel_dp)->lspcon;\n}\n\n#define dp_to_i915(__intel_dp) to_i915(dp_to_dig_port(__intel_dp)->base.base.dev)\n\n#define CAN_PSR(intel_dp) ((intel_dp)->psr.sink_support && \\\n\t\t\t   (intel_dp)->psr.source_support)\n\nstatic inline bool intel_encoder_can_psr(struct intel_encoder *encoder)\n{\n\tif (!intel_encoder_is_dp(encoder))\n\t\treturn false;\n\n\treturn CAN_PSR(enc_to_intel_dp(encoder));\n}\n\nstatic inline struct intel_digital_port *\nhdmi_to_dig_port(struct intel_hdmi *intel_hdmi)\n{\n\treturn container_of(intel_hdmi, struct intel_digital_port, hdmi);\n}\n\nstatic inline struct intel_plane_state *\nintel_atomic_get_plane_state(struct intel_atomic_state *state,\n\t\t\t\t struct intel_plane *plane)\n{\n\tstruct drm_plane_state *ret =\n\t\tdrm_atomic_get_plane_state(&state->base, &plane->base);\n\n\tif (IS_ERR(ret))\n\t\treturn ERR_CAST(ret);\n\n\treturn to_intel_plane_state(ret);\n}\n\nstatic inline struct intel_plane_state *\nintel_atomic_get_old_plane_state(struct intel_atomic_state *state,\n\t\t\t\t struct intel_plane *plane)\n{\n\treturn to_intel_plane_state(drm_atomic_get_old_plane_state(&state->base,\n\t\t\t\t\t\t\t\t   &plane->base));\n}\n\nstatic inline struct intel_plane_state *\nintel_atomic_get_new_plane_state(struct intel_atomic_state *state,\n\t\t\t\t struct intel_plane *plane)\n{\n\treturn to_intel_plane_state(drm_atomic_get_new_plane_state(&state->base,\n\t\t\t\t\t\t\t\t   &plane->base));\n}\n\nstatic inline struct intel_crtc_state *\nintel_atomic_get_old_crtc_state(struct intel_atomic_state *state,\n\t\t\t\tstruct intel_crtc *crtc)\n{\n\treturn to_intel_crtc_state(drm_atomic_get_old_crtc_state(&state->base,\n\t\t\t\t\t\t\t\t &crtc->base));\n}\n\nstatic inline struct intel_crtc_state *\nintel_atomic_get_new_crtc_state(struct intel_atomic_state *state,\n\t\t\t\tstruct intel_crtc *crtc)\n{\n\treturn to_intel_crtc_state(drm_atomic_get_new_crtc_state(&state->base,\n\t\t\t\t\t\t\t\t &crtc->base));\n}\n\nstatic inline struct intel_digital_connector_state *\nintel_atomic_get_new_connector_state(struct intel_atomic_state *state,\n\t\t\t\t     struct intel_connector *connector)\n{\n\treturn to_intel_digital_connector_state(\n\t\t\tdrm_atomic_get_new_connector_state(&state->base,\n\t\t\t&connector->base));\n}\n\nstatic inline struct intel_digital_connector_state *\nintel_atomic_get_old_connector_state(struct intel_atomic_state *state,\n\t\t\t\t     struct intel_connector *connector)\n{\n\treturn to_intel_digital_connector_state(\n\t\t\tdrm_atomic_get_old_connector_state(&state->base,\n\t\t\t&connector->base));\n}\n\n \nstatic inline bool\nintel_crtc_has_type(const struct intel_crtc_state *crtc_state,\n\t\t    enum intel_output_type type)\n{\n\treturn crtc_state->output_types & BIT(type);\n}\n\nstatic inline bool\nintel_crtc_has_dp_encoder(const struct intel_crtc_state *crtc_state)\n{\n\treturn crtc_state->output_types &\n\t\t(BIT(INTEL_OUTPUT_DP) |\n\t\t BIT(INTEL_OUTPUT_DP_MST) |\n\t\t BIT(INTEL_OUTPUT_EDP));\n}\n\nstatic inline bool\nintel_crtc_needs_modeset(const struct intel_crtc_state *crtc_state)\n{\n\treturn drm_atomic_crtc_needs_modeset(&crtc_state->uapi);\n}\n\nstatic inline bool\nintel_crtc_needs_fastset(const struct intel_crtc_state *crtc_state)\n{\n\treturn crtc_state->update_pipe;\n}\n\nstatic inline bool\nintel_crtc_needs_color_update(const struct intel_crtc_state *crtc_state)\n{\n\treturn crtc_state->uapi.color_mgmt_changed ||\n\t\tintel_crtc_needs_fastset(crtc_state) ||\n\t\tintel_crtc_needs_modeset(crtc_state);\n}\n\nstatic inline u32 intel_plane_ggtt_offset(const struct intel_plane_state *plane_state)\n{\n\treturn i915_ggtt_offset(plane_state->ggtt_vma);\n}\n\nstatic inline struct intel_frontbuffer *\nto_intel_frontbuffer(struct drm_framebuffer *fb)\n{\n\treturn fb ? to_intel_framebuffer(fb)->frontbuffer : NULL;\n}\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}