{
  "module_name": "intel_color.c",
  "hash_id": "51d9095fd94088860a3f486e637b363112fa7c3aa73b5679c729162a9f910ba5",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/i915/display/intel_color.c",
  "human_readable_source": " \n\n#include \"i915_reg.h\"\n#include \"intel_color.h\"\n#include \"intel_de.h\"\n#include \"intel_display_types.h\"\n#include \"intel_dsb.h\"\n\nstruct intel_color_funcs {\n\tint (*color_check)(struct intel_crtc_state *crtc_state);\n\t \n\tvoid (*color_commit_noarm)(const struct intel_crtc_state *crtc_state);\n\t \n\tvoid (*color_commit_arm)(const struct intel_crtc_state *crtc_state);\n\t \n\tvoid (*color_post_update)(const struct intel_crtc_state *crtc_state);\n\t \n\tvoid (*load_luts)(const struct intel_crtc_state *crtc_state);\n\t \n\tvoid (*read_luts)(struct intel_crtc_state *crtc_state);\n\t \n\tbool (*lut_equal)(const struct intel_crtc_state *crtc_state,\n\t\t\t  const struct drm_property_blob *blob1,\n\t\t\t  const struct drm_property_blob *blob2,\n\t\t\t  bool is_pre_csc_lut);\n\t \n\tvoid (*read_csc)(struct intel_crtc_state *crtc_state);\n};\n\n#define CTM_COEFF_SIGN\t(1ULL << 63)\n\n#define CTM_COEFF_1_0\t(1ULL << 32)\n#define CTM_COEFF_2_0\t(CTM_COEFF_1_0 << 1)\n#define CTM_COEFF_4_0\t(CTM_COEFF_2_0 << 1)\n#define CTM_COEFF_8_0\t(CTM_COEFF_4_0 << 1)\n#define CTM_COEFF_0_5\t(CTM_COEFF_1_0 >> 1)\n#define CTM_COEFF_0_25\t(CTM_COEFF_0_5 >> 1)\n#define CTM_COEFF_0_125\t(CTM_COEFF_0_25 >> 1)\n\n#define CTM_COEFF_LIMITED_RANGE ((235ULL - 16ULL) * CTM_COEFF_1_0 / 255)\n\n#define CTM_COEFF_NEGATIVE(coeff)\t(((coeff) & CTM_COEFF_SIGN) != 0)\n#define CTM_COEFF_ABS(coeff)\t\t((coeff) & (CTM_COEFF_SIGN - 1))\n\n#define LEGACY_LUT_LENGTH\t\t256\n\n \n\n \n#define ILK_CSC_COEFF_FP(coeff, fbits)\t\\\n\t(clamp_val(((coeff) >> (32 - (fbits) - 3)) + 4, 0, 0xfff) & 0xff8)\n\n#define ILK_CSC_COEFF_1_0 0x7800\n#define ILK_CSC_COEFF_LIMITED_RANGE ((235 - 16) << (12 - 8))  \n#define ILK_CSC_POSTOFF_LIMITED_RANGE (16 << (12 - 8))\n\nstatic const struct intel_csc_matrix ilk_csc_matrix_identity = {\n\t.preoff = {},\n\t.coeff = {\n\t\tILK_CSC_COEFF_1_0, 0, 0,\n\t\t0, ILK_CSC_COEFF_1_0, 0,\n\t\t0, 0, ILK_CSC_COEFF_1_0,\n\t},\n\t.postoff = {},\n};\n\n \nstatic const struct intel_csc_matrix ilk_csc_matrix_limited_range = {\n\t.preoff = {},\n\t.coeff = {\n\t\tILK_CSC_COEFF_LIMITED_RANGE, 0, 0,\n\t\t0, ILK_CSC_COEFF_LIMITED_RANGE, 0,\n\t\t0, 0, ILK_CSC_COEFF_LIMITED_RANGE,\n\t},\n\t.postoff = {\n\t\tILK_CSC_POSTOFF_LIMITED_RANGE,\n\t\tILK_CSC_POSTOFF_LIMITED_RANGE,\n\t\tILK_CSC_POSTOFF_LIMITED_RANGE,\n\t},\n};\n\n \nstatic const struct intel_csc_matrix ilk_csc_matrix_rgb_to_ycbcr = {\n\t.preoff = {},\n\t.coeff = {\n\t\t0x1e08, 0x9cc0, 0xb528,\n\t\t0x2ba8, 0x09d8, 0x37e8,\n\t\t0xbce8, 0x9ad8, 0x1e08,\n\t},\n\t.postoff = {\n\t\t0x0800, 0x0100, 0x0800,\n\t},\n};\n\nstatic void intel_csc_clear(struct intel_csc_matrix *csc)\n{\n\tmemset(csc, 0, sizeof(*csc));\n}\n\nstatic bool lut_is_legacy(const struct drm_property_blob *lut)\n{\n\treturn lut && drm_color_lut_size(lut) == LEGACY_LUT_LENGTH;\n}\n\n \nstatic u64 *ctm_mult_by_limited(u64 *result, const u64 *input)\n{\n\tint i;\n\n\tfor (i = 0; i < 9; i++) {\n\t\tu64 user_coeff = input[i];\n\t\tu32 limited_coeff = CTM_COEFF_LIMITED_RANGE;\n\t\tu32 abs_coeff = clamp_val(CTM_COEFF_ABS(user_coeff), 0,\n\t\t\t\t\t  CTM_COEFF_4_0 - 1) >> 2;\n\n\t\t \n\t\tresult[i] = mul_u32_u32(limited_coeff, abs_coeff) >> 30;\n\t\tresult[i] |= user_coeff & CTM_COEFF_SIGN;\n\t}\n\n\treturn result;\n}\n\nstatic void ilk_update_pipe_csc(struct intel_crtc *crtc,\n\t\t\t\tconst struct intel_csc_matrix *csc)\n{\n\tstruct drm_i915_private *i915 = to_i915(crtc->base.dev);\n\tenum pipe pipe = crtc->pipe;\n\n\tintel_de_write_fw(i915, PIPE_CSC_PREOFF_HI(pipe), csc->preoff[0]);\n\tintel_de_write_fw(i915, PIPE_CSC_PREOFF_ME(pipe), csc->preoff[1]);\n\tintel_de_write_fw(i915, PIPE_CSC_PREOFF_LO(pipe), csc->preoff[2]);\n\n\tintel_de_write_fw(i915, PIPE_CSC_COEFF_RY_GY(pipe),\n\t\t\t  csc->coeff[0] << 16 | csc->coeff[1]);\n\tintel_de_write_fw(i915, PIPE_CSC_COEFF_BY(pipe),\n\t\t\t  csc->coeff[2] << 16);\n\n\tintel_de_write_fw(i915, PIPE_CSC_COEFF_RU_GU(pipe),\n\t\t\t  csc->coeff[3] << 16 | csc->coeff[4]);\n\tintel_de_write_fw(i915, PIPE_CSC_COEFF_BU(pipe),\n\t\t\t  csc->coeff[5] << 16);\n\n\tintel_de_write_fw(i915, PIPE_CSC_COEFF_RV_GV(pipe),\n\t\t\t  csc->coeff[6] << 16 | csc->coeff[7]);\n\tintel_de_write_fw(i915, PIPE_CSC_COEFF_BV(pipe),\n\t\t\t  csc->coeff[8] << 16);\n\n\tif (DISPLAY_VER(i915) < 7)\n\t\treturn;\n\n\tintel_de_write_fw(i915, PIPE_CSC_POSTOFF_HI(pipe), csc->postoff[0]);\n\tintel_de_write_fw(i915, PIPE_CSC_POSTOFF_ME(pipe), csc->postoff[1]);\n\tintel_de_write_fw(i915, PIPE_CSC_POSTOFF_LO(pipe), csc->postoff[2]);\n}\n\nstatic void ilk_read_pipe_csc(struct intel_crtc *crtc,\n\t\t\t      struct intel_csc_matrix *csc)\n{\n\tstruct drm_i915_private *i915 = to_i915(crtc->base.dev);\n\tenum pipe pipe = crtc->pipe;\n\tu32 tmp;\n\n\tcsc->preoff[0] = intel_de_read_fw(i915, PIPE_CSC_PREOFF_HI(pipe));\n\tcsc->preoff[1] = intel_de_read_fw(i915, PIPE_CSC_PREOFF_ME(pipe));\n\tcsc->preoff[2] = intel_de_read_fw(i915, PIPE_CSC_PREOFF_LO(pipe));\n\n\ttmp = intel_de_read_fw(i915, PIPE_CSC_COEFF_RY_GY(pipe));\n\tcsc->coeff[0] = tmp >> 16;\n\tcsc->coeff[1] = tmp & 0xffff;\n\ttmp = intel_de_read_fw(i915, PIPE_CSC_COEFF_BY(pipe));\n\tcsc->coeff[2] = tmp >> 16;\n\n\ttmp = intel_de_read_fw(i915, PIPE_CSC_COEFF_RU_GU(pipe));\n\tcsc->coeff[3] = tmp >> 16;\n\tcsc->coeff[4] = tmp & 0xffff;\n\ttmp = intel_de_read_fw(i915, PIPE_CSC_COEFF_BU(pipe));\n\tcsc->coeff[5] = tmp >> 16;\n\n\ttmp = intel_de_read_fw(i915, PIPE_CSC_COEFF_RV_GV(pipe));\n\tcsc->coeff[6] = tmp >> 16;\n\tcsc->coeff[7] = tmp & 0xffff;\n\ttmp = intel_de_read_fw(i915, PIPE_CSC_COEFF_BV(pipe));\n\tcsc->coeff[8] = tmp >> 16;\n\n\tif (DISPLAY_VER(i915) < 7)\n\t\treturn;\n\n\tcsc->postoff[0] = intel_de_read_fw(i915, PIPE_CSC_POSTOFF_HI(pipe));\n\tcsc->postoff[1] = intel_de_read_fw(i915, PIPE_CSC_POSTOFF_ME(pipe));\n\tcsc->postoff[2] = intel_de_read_fw(i915, PIPE_CSC_POSTOFF_LO(pipe));\n}\n\nstatic void ilk_read_csc(struct intel_crtc_state *crtc_state)\n{\n\tstruct intel_crtc *crtc = to_intel_crtc(crtc_state->uapi.crtc);\n\n\tif (crtc_state->csc_enable)\n\t\tilk_read_pipe_csc(crtc, &crtc_state->csc);\n}\n\nstatic void skl_read_csc(struct intel_crtc_state *crtc_state)\n{\n\tstruct intel_crtc *crtc = to_intel_crtc(crtc_state->uapi.crtc);\n\n\t \n\tif (crtc_state->csc_enable)\n\t\tilk_read_pipe_csc(crtc, &crtc_state->csc);\n}\n\nstatic void icl_update_output_csc(struct intel_crtc *crtc,\n\t\t\t\t  const struct intel_csc_matrix *csc)\n{\n\tstruct drm_i915_private *i915 = to_i915(crtc->base.dev);\n\tenum pipe pipe = crtc->pipe;\n\n\tintel_de_write_fw(i915, PIPE_CSC_OUTPUT_PREOFF_HI(pipe), csc->preoff[0]);\n\tintel_de_write_fw(i915, PIPE_CSC_OUTPUT_PREOFF_ME(pipe), csc->preoff[1]);\n\tintel_de_write_fw(i915, PIPE_CSC_OUTPUT_PREOFF_LO(pipe), csc->preoff[2]);\n\n\tintel_de_write_fw(i915, PIPE_CSC_OUTPUT_COEFF_RY_GY(pipe),\n\t\t\t  csc->coeff[0] << 16 | csc->coeff[1]);\n\tintel_de_write_fw(i915, PIPE_CSC_OUTPUT_COEFF_BY(pipe),\n\t\t\t  csc->coeff[2] << 16);\n\n\tintel_de_write_fw(i915, PIPE_CSC_OUTPUT_COEFF_RU_GU(pipe),\n\t\t\t  csc->coeff[3] << 16 | csc->coeff[4]);\n\tintel_de_write_fw(i915, PIPE_CSC_OUTPUT_COEFF_BU(pipe),\n\t\t\t  csc->coeff[5] << 16);\n\n\tintel_de_write_fw(i915, PIPE_CSC_OUTPUT_COEFF_RV_GV(pipe),\n\t\t\t  csc->coeff[6] << 16 | csc->coeff[7]);\n\tintel_de_write_fw(i915, PIPE_CSC_OUTPUT_COEFF_BV(pipe),\n\t\t\t  csc->coeff[8] << 16);\n\n\tintel_de_write_fw(i915, PIPE_CSC_OUTPUT_POSTOFF_HI(pipe), csc->postoff[0]);\n\tintel_de_write_fw(i915, PIPE_CSC_OUTPUT_POSTOFF_ME(pipe), csc->postoff[1]);\n\tintel_de_write_fw(i915, PIPE_CSC_OUTPUT_POSTOFF_LO(pipe), csc->postoff[2]);\n}\n\nstatic void icl_read_output_csc(struct intel_crtc *crtc,\n\t\t\t\tstruct intel_csc_matrix *csc)\n{\n\tstruct drm_i915_private *i915 = to_i915(crtc->base.dev);\n\tenum pipe pipe = crtc->pipe;\n\tu32 tmp;\n\n\tcsc->preoff[0] = intel_de_read_fw(i915, PIPE_CSC_OUTPUT_PREOFF_HI(pipe));\n\tcsc->preoff[1] = intel_de_read_fw(i915, PIPE_CSC_OUTPUT_PREOFF_ME(pipe));\n\tcsc->preoff[2] = intel_de_read_fw(i915, PIPE_CSC_OUTPUT_PREOFF_LO(pipe));\n\n\ttmp = intel_de_read_fw(i915, PIPE_CSC_OUTPUT_COEFF_RY_GY(pipe));\n\tcsc->coeff[0] = tmp >> 16;\n\tcsc->coeff[1] = tmp & 0xffff;\n\ttmp = intel_de_read_fw(i915, PIPE_CSC_OUTPUT_COEFF_BY(pipe));\n\tcsc->coeff[2] = tmp >> 16;\n\n\ttmp = intel_de_read_fw(i915, PIPE_CSC_OUTPUT_COEFF_RU_GU(pipe));\n\tcsc->coeff[3] = tmp >> 16;\n\tcsc->coeff[4] = tmp & 0xffff;\n\ttmp = intel_de_read_fw(i915, PIPE_CSC_OUTPUT_COEFF_BU(pipe));\n\tcsc->coeff[5] = tmp >> 16;\n\n\ttmp = intel_de_read_fw(i915, PIPE_CSC_OUTPUT_COEFF_RV_GV(pipe));\n\tcsc->coeff[6] = tmp >> 16;\n\tcsc->coeff[7] = tmp & 0xffff;\n\ttmp = intel_de_read_fw(i915, PIPE_CSC_OUTPUT_COEFF_BV(pipe));\n\tcsc->coeff[8] = tmp >> 16;\n\n\tcsc->postoff[0] = intel_de_read_fw(i915, PIPE_CSC_OUTPUT_POSTOFF_HI(pipe));\n\tcsc->postoff[1] = intel_de_read_fw(i915, PIPE_CSC_OUTPUT_POSTOFF_ME(pipe));\n\tcsc->postoff[2] = intel_de_read_fw(i915, PIPE_CSC_OUTPUT_POSTOFF_LO(pipe));\n}\n\nstatic void icl_read_csc(struct intel_crtc_state *crtc_state)\n{\n\tstruct intel_crtc *crtc = to_intel_crtc(crtc_state->uapi.crtc);\n\n\t \n\tif (crtc_state->csc_mode & ICL_CSC_ENABLE)\n\t\tilk_read_pipe_csc(crtc, &crtc_state->csc);\n\n\tif (crtc_state->csc_mode & ICL_OUTPUT_CSC_ENABLE)\n\t\ticl_read_output_csc(crtc, &crtc_state->output_csc);\n}\n\nstatic bool ilk_limited_range(const struct intel_crtc_state *crtc_state)\n{\n\tstruct drm_i915_private *i915 = to_i915(crtc_state->uapi.crtc->dev);\n\n\t \n\tif (DISPLAY_VER(i915) >= 11)\n\t\treturn false;\n\n\t \n\tif (DISPLAY_VER(i915) < 7 || IS_IVYBRIDGE(i915))\n\t\treturn false;\n\n\treturn crtc_state->limited_color_range;\n}\n\nstatic bool ilk_lut_limited_range(const struct intel_crtc_state *crtc_state)\n{\n\tstruct drm_i915_private *i915 = to_i915(crtc_state->uapi.crtc->dev);\n\n\tif (!ilk_limited_range(crtc_state))\n\t\treturn false;\n\n\tif (crtc_state->c8_planes)\n\t\treturn false;\n\n\tif (DISPLAY_VER(i915) == 10)\n\t\treturn crtc_state->hw.gamma_lut;\n\telse\n\t\treturn crtc_state->hw.gamma_lut &&\n\t\t\t(crtc_state->hw.degamma_lut || crtc_state->hw.ctm);\n}\n\nstatic bool ilk_csc_limited_range(const struct intel_crtc_state *crtc_state)\n{\n\tif (!ilk_limited_range(crtc_state))\n\t\treturn false;\n\n\treturn !ilk_lut_limited_range(crtc_state);\n}\n\nstatic void ilk_csc_copy(struct drm_i915_private *i915,\n\t\t\t struct intel_csc_matrix *dst,\n\t\t\t const struct intel_csc_matrix *src)\n{\n\t*dst = *src;\n\n\tif (DISPLAY_VER(i915) < 7)\n\t\tmemset(dst->postoff, 0, sizeof(dst->postoff));\n}\n\nstatic void ilk_csc_convert_ctm(const struct intel_crtc_state *crtc_state,\n\t\t\t\tstruct intel_csc_matrix *csc,\n\t\t\t\tbool limited_color_range)\n{\n\tstruct drm_i915_private *i915 = to_i915(crtc_state->uapi.crtc->dev);\n\tconst struct drm_color_ctm *ctm = crtc_state->hw.ctm->data;\n\tconst u64 *input;\n\tu64 temp[9];\n\tint i;\n\n\t \n\tif (limited_color_range)\n\t\tilk_csc_copy(i915, csc, &ilk_csc_matrix_limited_range);\n\telse\n\t\tilk_csc_copy(i915, csc, &ilk_csc_matrix_identity);\n\n\tif (limited_color_range)\n\t\tinput = ctm_mult_by_limited(temp, ctm->matrix);\n\telse\n\t\tinput = ctm->matrix;\n\n\t \n\tfor (i = 0; i < 9; i++) {\n\t\tu64 abs_coeff = ((1ULL << 63) - 1) & input[i];\n\n\t\t \n\t\tabs_coeff = clamp_val(abs_coeff, 0, CTM_COEFF_4_0 - 1);\n\n\t\tcsc->coeff[i] = 0;\n\n\t\t \n\t\tif (CTM_COEFF_NEGATIVE(input[i]))\n\t\t\tcsc->coeff[i] |= 1 << 15;\n\n\t\tif (abs_coeff < CTM_COEFF_0_125)\n\t\t\tcsc->coeff[i] |= (3 << 12) |\n\t\t\t\tILK_CSC_COEFF_FP(abs_coeff, 12);\n\t\telse if (abs_coeff < CTM_COEFF_0_25)\n\t\t\tcsc->coeff[i] |= (2 << 12) |\n\t\t\t\tILK_CSC_COEFF_FP(abs_coeff, 11);\n\t\telse if (abs_coeff < CTM_COEFF_0_5)\n\t\t\tcsc->coeff[i] |= (1 << 12) |\n\t\t\t\tILK_CSC_COEFF_FP(abs_coeff, 10);\n\t\telse if (abs_coeff < CTM_COEFF_1_0)\n\t\t\tcsc->coeff[i] |= ILK_CSC_COEFF_FP(abs_coeff, 9);\n\t\telse if (abs_coeff < CTM_COEFF_2_0)\n\t\t\tcsc->coeff[i] |= (7 << 12) |\n\t\t\t\tILK_CSC_COEFF_FP(abs_coeff, 8);\n\t\telse\n\t\t\tcsc->coeff[i] |= (6 << 12) |\n\t\t\t\tILK_CSC_COEFF_FP(abs_coeff, 7);\n\t}\n}\n\nstatic void ilk_assign_csc(struct intel_crtc_state *crtc_state)\n{\n\tstruct drm_i915_private *i915 = to_i915(crtc_state->uapi.crtc->dev);\n\tbool limited_color_range = ilk_csc_limited_range(crtc_state);\n\n\tif (crtc_state->hw.ctm) {\n\t\tdrm_WARN_ON(&i915->drm, !crtc_state->csc_enable);\n\n\t\tilk_csc_convert_ctm(crtc_state, &crtc_state->csc, limited_color_range);\n\t} else if (crtc_state->output_format != INTEL_OUTPUT_FORMAT_RGB) {\n\t\tdrm_WARN_ON(&i915->drm, !crtc_state->csc_enable);\n\n\t\tilk_csc_copy(i915, &crtc_state->csc, &ilk_csc_matrix_rgb_to_ycbcr);\n\t} else if (limited_color_range) {\n\t\tdrm_WARN_ON(&i915->drm, !crtc_state->csc_enable);\n\n\t\tilk_csc_copy(i915, &crtc_state->csc, &ilk_csc_matrix_limited_range);\n\t} else if (crtc_state->csc_enable) {\n\t\t \n\t\tdrm_WARN_ON(&i915->drm, !IS_GEMINILAKE(i915));\n\n\t\tilk_csc_copy(i915, &crtc_state->csc, &ilk_csc_matrix_identity);\n\t} else {\n\t\tintel_csc_clear(&crtc_state->csc);\n\t}\n}\n\nstatic void ilk_load_csc_matrix(const struct intel_crtc_state *crtc_state)\n{\n\tstruct intel_crtc *crtc = to_intel_crtc(crtc_state->uapi.crtc);\n\n\tif (crtc_state->csc_enable)\n\t\tilk_update_pipe_csc(crtc, &crtc_state->csc);\n}\n\nstatic void icl_assign_csc(struct intel_crtc_state *crtc_state)\n{\n\tstruct drm_i915_private *i915 = to_i915(crtc_state->uapi.crtc->dev);\n\n\tif (crtc_state->hw.ctm) {\n\t\tdrm_WARN_ON(&i915->drm, (crtc_state->csc_mode & ICL_CSC_ENABLE) == 0);\n\n\t\tilk_csc_convert_ctm(crtc_state, &crtc_state->csc, false);\n\t} else {\n\t\tdrm_WARN_ON(&i915->drm, (crtc_state->csc_mode & ICL_CSC_ENABLE) != 0);\n\n\t\tintel_csc_clear(&crtc_state->csc);\n\t}\n\n\tif (crtc_state->output_format != INTEL_OUTPUT_FORMAT_RGB) {\n\t\tdrm_WARN_ON(&i915->drm, (crtc_state->csc_mode & ICL_OUTPUT_CSC_ENABLE) == 0);\n\n\t\tilk_csc_copy(i915, &crtc_state->output_csc, &ilk_csc_matrix_rgb_to_ycbcr);\n\t} else if (crtc_state->limited_color_range) {\n\t\tdrm_WARN_ON(&i915->drm, (crtc_state->csc_mode & ICL_OUTPUT_CSC_ENABLE) == 0);\n\n\t\tilk_csc_copy(i915, &crtc_state->output_csc, &ilk_csc_matrix_limited_range);\n\t} else {\n\t\tdrm_WARN_ON(&i915->drm, (crtc_state->csc_mode & ICL_OUTPUT_CSC_ENABLE) != 0);\n\n\t\tintel_csc_clear(&crtc_state->output_csc);\n\t}\n}\n\nstatic void icl_load_csc_matrix(const struct intel_crtc_state *crtc_state)\n{\n\tstruct intel_crtc *crtc = to_intel_crtc(crtc_state->uapi.crtc);\n\n\tif (crtc_state->csc_mode & ICL_CSC_ENABLE)\n\t\tilk_update_pipe_csc(crtc, &crtc_state->csc);\n\n\tif (crtc_state->csc_mode & ICL_OUTPUT_CSC_ENABLE)\n\t\ticl_update_output_csc(crtc, &crtc_state->output_csc);\n}\n\nstatic u16 ctm_to_twos_complement(u64 coeff, int int_bits, int frac_bits)\n{\n\ts64 c = CTM_COEFF_ABS(coeff);\n\n\t \n\tc >>= 32 - frac_bits - 1;\n\n\t \n\tc = (c + 1) >> 1;\n\n\tif (CTM_COEFF_NEGATIVE(coeff))\n\t\tc = -c;\n\n\tc = clamp(c, -(s64)BIT(int_bits + frac_bits - 1),\n\t\t  (s64)(BIT(int_bits + frac_bits - 1) - 1));\n\n\treturn c & (BIT(int_bits + frac_bits) - 1);\n}\n\n \nstatic void vlv_wgc_csc_convert_ctm(const struct intel_crtc_state *crtc_state,\n\t\t\t\t    struct intel_csc_matrix *csc)\n{\n\tconst struct drm_color_ctm *ctm = crtc_state->hw.ctm->data;\n\tint i;\n\n\tfor (i = 0; i < 9; i++)\n\t\tcsc->coeff[i] = ctm_to_twos_complement(ctm->matrix[i], 2, 10);\n}\n\nstatic void vlv_load_wgc_csc(struct intel_crtc *crtc,\n\t\t\t     const struct intel_csc_matrix *csc)\n{\n\tstruct drm_i915_private *dev_priv = to_i915(crtc->base.dev);\n\tenum pipe pipe = crtc->pipe;\n\n\tintel_de_write_fw(dev_priv, PIPE_WGC_C01_C00(pipe),\n\t\t\t  csc->coeff[1] << 16 | csc->coeff[0]);\n\tintel_de_write_fw(dev_priv, PIPE_WGC_C02(pipe),\n\t\t\t  csc->coeff[2]);\n\n\tintel_de_write_fw(dev_priv, PIPE_WGC_C11_C10(pipe),\n\t\t\t  csc->coeff[4] << 16 | csc->coeff[3]);\n\tintel_de_write_fw(dev_priv, PIPE_WGC_C12(pipe),\n\t\t\t  csc->coeff[5]);\n\n\tintel_de_write_fw(dev_priv, PIPE_WGC_C21_C20(pipe),\n\t\t\t  csc->coeff[7] << 16 | csc->coeff[6]);\n\tintel_de_write_fw(dev_priv, PIPE_WGC_C22(pipe),\n\t\t\t  csc->coeff[8]);\n}\n\nstatic void vlv_read_wgc_csc(struct intel_crtc *crtc,\n\t\t\t     struct intel_csc_matrix *csc)\n{\n\tstruct drm_i915_private *dev_priv = to_i915(crtc->base.dev);\n\tenum pipe pipe = crtc->pipe;\n\tu32 tmp;\n\n\ttmp = intel_de_read_fw(dev_priv, PIPE_WGC_C01_C00(pipe));\n\tcsc->coeff[0] = tmp & 0xffff;\n\tcsc->coeff[1] = tmp >> 16;\n\n\ttmp = intel_de_read_fw(dev_priv, PIPE_WGC_C02(pipe));\n\tcsc->coeff[2] = tmp & 0xffff;\n\n\ttmp = intel_de_read_fw(dev_priv, PIPE_WGC_C11_C10(pipe));\n\tcsc->coeff[3] = tmp & 0xffff;\n\tcsc->coeff[4] = tmp >> 16;\n\n\ttmp = intel_de_read_fw(dev_priv, PIPE_WGC_C12(pipe));\n\tcsc->coeff[5] = tmp & 0xffff;\n\n\ttmp = intel_de_read_fw(dev_priv, PIPE_WGC_C21_C20(pipe));\n\tcsc->coeff[6] = tmp & 0xffff;\n\tcsc->coeff[7] = tmp >> 16;\n\n\ttmp = intel_de_read_fw(dev_priv, PIPE_WGC_C22(pipe));\n\tcsc->coeff[8] = tmp & 0xffff;\n}\n\nstatic void vlv_read_csc(struct intel_crtc_state *crtc_state)\n{\n\tstruct intel_crtc *crtc = to_intel_crtc(crtc_state->uapi.crtc);\n\n\tif (crtc_state->wgc_enable)\n\t\tvlv_read_wgc_csc(crtc, &crtc_state->csc);\n}\n\nstatic void vlv_assign_csc(struct intel_crtc_state *crtc_state)\n{\n\tstruct drm_i915_private *i915 = to_i915(crtc_state->uapi.crtc->dev);\n\n\tif (crtc_state->hw.ctm) {\n\t\tdrm_WARN_ON(&i915->drm, !crtc_state->wgc_enable);\n\n\t\tvlv_wgc_csc_convert_ctm(crtc_state, &crtc_state->csc);\n\t} else {\n\t\tdrm_WARN_ON(&i915->drm, crtc_state->wgc_enable);\n\n\t\tintel_csc_clear(&crtc_state->csc);\n\t}\n}\n\n \nstatic void chv_cgm_csc_convert_ctm(const struct intel_crtc_state *crtc_state,\n\t\t\t\t    struct intel_csc_matrix *csc)\n{\n\tconst struct drm_color_ctm *ctm = crtc_state->hw.ctm->data;\n\tint i;\n\n\tfor (i = 0; i < 9; i++)\n\t\tcsc->coeff[i] = ctm_to_twos_complement(ctm->matrix[i], 4, 12);\n}\n\n#define CHV_CGM_CSC_COEFF_1_0 (1 << 12)\n\nstatic const struct intel_csc_matrix chv_cgm_csc_matrix_identity = {\n\t.coeff = {\n\t\tCHV_CGM_CSC_COEFF_1_0, 0, 0,\n\t\t0, CHV_CGM_CSC_COEFF_1_0, 0,\n\t\t0, 0, CHV_CGM_CSC_COEFF_1_0,\n\t},\n};\n\nstatic void chv_load_cgm_csc(struct intel_crtc *crtc,\n\t\t\t     const struct intel_csc_matrix *csc)\n{\n\tstruct drm_i915_private *i915 = to_i915(crtc->base.dev);\n\tenum pipe pipe = crtc->pipe;\n\n\tintel_de_write_fw(i915, CGM_PIPE_CSC_COEFF01(pipe),\n\t\t\t  csc->coeff[1] << 16 | csc->coeff[0]);\n\tintel_de_write_fw(i915, CGM_PIPE_CSC_COEFF23(pipe),\n\t\t\t  csc->coeff[3] << 16 | csc->coeff[2]);\n\tintel_de_write_fw(i915, CGM_PIPE_CSC_COEFF45(pipe),\n\t\t\t  csc->coeff[5] << 16 | csc->coeff[4]);\n\tintel_de_write_fw(i915, CGM_PIPE_CSC_COEFF67(pipe),\n\t\t\t  csc->coeff[7] << 16 | csc->coeff[6]);\n\tintel_de_write_fw(i915, CGM_PIPE_CSC_COEFF8(pipe),\n\t\t\t  csc->coeff[8]);\n}\n\nstatic void chv_read_cgm_csc(struct intel_crtc *crtc,\n\t\t\t     struct intel_csc_matrix *csc)\n{\n\tstruct drm_i915_private *i915 = to_i915(crtc->base.dev);\n\tenum pipe pipe = crtc->pipe;\n\tu32 tmp;\n\n\ttmp = intel_de_read_fw(i915, CGM_PIPE_CSC_COEFF01(pipe));\n\tcsc->coeff[0] = tmp & 0xffff;\n\tcsc->coeff[1] = tmp >> 16;\n\n\ttmp = intel_de_read_fw(i915, CGM_PIPE_CSC_COEFF23(pipe));\n\tcsc->coeff[2] = tmp & 0xffff;\n\tcsc->coeff[3] = tmp >> 16;\n\n\ttmp = intel_de_read_fw(i915, CGM_PIPE_CSC_COEFF45(pipe));\n\tcsc->coeff[4] = tmp & 0xffff;\n\tcsc->coeff[5] = tmp >> 16;\n\n\ttmp = intel_de_read_fw(i915, CGM_PIPE_CSC_COEFF67(pipe));\n\tcsc->coeff[6] = tmp & 0xffff;\n\tcsc->coeff[7] = tmp >> 16;\n\n\ttmp = intel_de_read_fw(i915, CGM_PIPE_CSC_COEFF8(pipe));\n\tcsc->coeff[8] = tmp & 0xffff;\n}\n\nstatic void chv_read_csc(struct intel_crtc_state *crtc_state)\n{\n\tstruct intel_crtc *crtc = to_intel_crtc(crtc_state->uapi.crtc);\n\n\tif (crtc_state->cgm_mode & CGM_PIPE_MODE_CSC)\n\t\tchv_read_cgm_csc(crtc, &crtc_state->csc);\n}\n\nstatic void chv_assign_csc(struct intel_crtc_state *crtc_state)\n{\n\tstruct drm_i915_private *i915 = to_i915(crtc_state->uapi.crtc->dev);\n\n\tdrm_WARN_ON(&i915->drm, crtc_state->wgc_enable);\n\n\tif (crtc_state->hw.ctm) {\n\t\tdrm_WARN_ON(&i915->drm, (crtc_state->cgm_mode & CGM_PIPE_MODE_CSC) == 0);\n\n\t\tchv_cgm_csc_convert_ctm(crtc_state, &crtc_state->csc);\n\t} else {\n\t\tdrm_WARN_ON(&i915->drm, (crtc_state->cgm_mode & CGM_PIPE_MODE_CSC) == 0);\n\n\t\tcrtc_state->csc = chv_cgm_csc_matrix_identity;\n\t}\n}\n\n \nstatic u32 intel_color_lut_pack(u32 val, int bit_precision)\n{\n\tu32 max = 0xffff >> (16 - bit_precision);\n\n\tval = clamp_val(val, 0, max);\n\n\tif (bit_precision < 16)\n\t\tval <<= 16 - bit_precision;\n\n\treturn val;\n}\n\nstatic u32 i9xx_lut_8(const struct drm_color_lut *color)\n{\n\treturn REG_FIELD_PREP(PALETTE_RED_MASK, drm_color_lut_extract(color->red, 8)) |\n\t\tREG_FIELD_PREP(PALETTE_GREEN_MASK, drm_color_lut_extract(color->green, 8)) |\n\t\tREG_FIELD_PREP(PALETTE_BLUE_MASK, drm_color_lut_extract(color->blue, 8));\n}\n\nstatic void i9xx_lut_8_pack(struct drm_color_lut *entry, u32 val)\n{\n\tentry->red = intel_color_lut_pack(REG_FIELD_GET(PALETTE_RED_MASK, val), 8);\n\tentry->green = intel_color_lut_pack(REG_FIELD_GET(PALETTE_GREEN_MASK, val), 8);\n\tentry->blue = intel_color_lut_pack(REG_FIELD_GET(PALETTE_BLUE_MASK, val), 8);\n}\n\n \nstatic u32 _i9xx_lut_10_ldw(u16 a)\n{\n\treturn drm_color_lut_extract(a, 10) & 0xff;\n}\n\nstatic u32 i9xx_lut_10_ldw(const struct drm_color_lut *color)\n{\n\treturn REG_FIELD_PREP(PALETTE_RED_MASK, _i9xx_lut_10_ldw(color[0].red)) |\n\t\tREG_FIELD_PREP(PALETTE_GREEN_MASK, _i9xx_lut_10_ldw(color[0].green)) |\n\t\tREG_FIELD_PREP(PALETTE_BLUE_MASK, _i9xx_lut_10_ldw(color[0].blue));\n}\n\n \nstatic u32 _i9xx_lut_10_udw(u16 a, u16 b)\n{\n\tunsigned int mantissa, exponent;\n\n\ta = drm_color_lut_extract(a, 10);\n\tb = drm_color_lut_extract(b, 10);\n\n\t \n\tmantissa = clamp(b - a, 0, 0x7f);\n\texponent = 3;\n\twhile (mantissa > 0xf) {\n\t\tmantissa >>= 1;\n\t\texponent--;\n\t}\n\n\treturn (exponent << 6) |\n\t\t(mantissa << 2) |\n\t\t(a >> 8);\n}\n\nstatic u32 i9xx_lut_10_udw(const struct drm_color_lut *color)\n{\n\treturn REG_FIELD_PREP(PALETTE_RED_MASK, _i9xx_lut_10_udw(color[0].red, color[1].red)) |\n\t\tREG_FIELD_PREP(PALETTE_GREEN_MASK, _i9xx_lut_10_udw(color[0].green, color[1].green)) |\n\t\tREG_FIELD_PREP(PALETTE_BLUE_MASK, _i9xx_lut_10_udw(color[0].blue, color[1].blue));\n}\n\nstatic void i9xx_lut_10_pack(struct drm_color_lut *color,\n\t\t\t     u32 ldw, u32 udw)\n{\n\tu16 red = REG_FIELD_GET(PALETTE_10BIT_RED_LDW_MASK, ldw) |\n\t\tREG_FIELD_GET(PALETTE_10BIT_RED_UDW_MASK, udw) << 8;\n\tu16 green = REG_FIELD_GET(PALETTE_10BIT_GREEN_LDW_MASK, ldw) |\n\t\tREG_FIELD_GET(PALETTE_10BIT_GREEN_UDW_MASK, udw) << 8;\n\tu16 blue = REG_FIELD_GET(PALETTE_10BIT_BLUE_LDW_MASK, ldw) |\n\t\tREG_FIELD_GET(PALETTE_10BIT_BLUE_UDW_MASK, udw) << 8;\n\n\tcolor->red = intel_color_lut_pack(red, 10);\n\tcolor->green = intel_color_lut_pack(green, 10);\n\tcolor->blue = intel_color_lut_pack(blue, 10);\n}\n\nstatic void i9xx_lut_10_pack_slope(struct drm_color_lut *color,\n\t\t\t\t   u32 ldw, u32 udw)\n{\n\tint r_exp = REG_FIELD_GET(PALETTE_10BIT_RED_EXP_MASK, udw);\n\tint r_mant = REG_FIELD_GET(PALETTE_10BIT_RED_MANT_MASK, udw);\n\tint g_exp = REG_FIELD_GET(PALETTE_10BIT_GREEN_EXP_MASK, udw);\n\tint g_mant = REG_FIELD_GET(PALETTE_10BIT_GREEN_MANT_MASK, udw);\n\tint b_exp = REG_FIELD_GET(PALETTE_10BIT_BLUE_EXP_MASK, udw);\n\tint b_mant = REG_FIELD_GET(PALETTE_10BIT_BLUE_MANT_MASK, udw);\n\n\ti9xx_lut_10_pack(color, ldw, udw);\n\n\tcolor->red += r_mant << (3 - r_exp);\n\tcolor->green += g_mant << (3 - g_exp);\n\tcolor->blue += b_mant << (3 - b_exp);\n}\n\n \nstatic u32 i965_lut_10p6_ldw(const struct drm_color_lut *color)\n{\n\treturn REG_FIELD_PREP(PALETTE_RED_MASK, color->red & 0xff) |\n\t\tREG_FIELD_PREP(PALETTE_GREEN_MASK, color->green & 0xff) |\n\t\tREG_FIELD_PREP(PALETTE_BLUE_MASK, color->blue & 0xff);\n}\n\n \nstatic u32 i965_lut_10p6_udw(const struct drm_color_lut *color)\n{\n\treturn REG_FIELD_PREP(PALETTE_RED_MASK, color->red >> 8) |\n\t\tREG_FIELD_PREP(PALETTE_GREEN_MASK, color->green >> 8) |\n\t\tREG_FIELD_PREP(PALETTE_BLUE_MASK, color->blue >> 8);\n}\n\nstatic void i965_lut_10p6_pack(struct drm_color_lut *entry, u32 ldw, u32 udw)\n{\n\tentry->red = REG_FIELD_GET(PALETTE_RED_MASK, udw) << 8 |\n\t\tREG_FIELD_GET(PALETTE_RED_MASK, ldw);\n\tentry->green = REG_FIELD_GET(PALETTE_GREEN_MASK, udw) << 8 |\n\t\tREG_FIELD_GET(PALETTE_GREEN_MASK, ldw);\n\tentry->blue = REG_FIELD_GET(PALETTE_BLUE_MASK, udw) << 8 |\n\t\tREG_FIELD_GET(PALETTE_BLUE_MASK, ldw);\n}\n\nstatic u16 i965_lut_11p6_max_pack(u32 val)\n{\n\t \n\treturn clamp_val(val, 0, 0xffff);\n}\n\nstatic u32 ilk_lut_10(const struct drm_color_lut *color)\n{\n\treturn REG_FIELD_PREP(PREC_PALETTE_10_RED_MASK, drm_color_lut_extract(color->red, 10)) |\n\t\tREG_FIELD_PREP(PREC_PALETTE_10_GREEN_MASK, drm_color_lut_extract(color->green, 10)) |\n\t\tREG_FIELD_PREP(PREC_PALETTE_10_BLUE_MASK, drm_color_lut_extract(color->blue, 10));\n}\n\nstatic void ilk_lut_10_pack(struct drm_color_lut *entry, u32 val)\n{\n\tentry->red = intel_color_lut_pack(REG_FIELD_GET(PREC_PALETTE_10_RED_MASK, val), 10);\n\tentry->green = intel_color_lut_pack(REG_FIELD_GET(PREC_PALETTE_10_GREEN_MASK, val), 10);\n\tentry->blue = intel_color_lut_pack(REG_FIELD_GET(PREC_PALETTE_10_BLUE_MASK, val), 10);\n}\n\n \nstatic u32 ilk_lut_12p4_ldw(const struct drm_color_lut *color)\n{\n\treturn REG_FIELD_PREP(PREC_PALETTE_12P4_RED_LDW_MASK, color->red & 0x3f) |\n\t\tREG_FIELD_PREP(PREC_PALETTE_12P4_GREEN_LDW_MASK, color->green & 0x3f) |\n\t\tREG_FIELD_PREP(PREC_PALETTE_12P4_BLUE_LDW_MASK, color->blue & 0x3f);\n}\n\n \nstatic u32 ilk_lut_12p4_udw(const struct drm_color_lut *color)\n{\n\treturn REG_FIELD_PREP(PREC_PALETTE_12P4_RED_UDW_MASK, color->red >> 6) |\n\t\tREG_FIELD_PREP(PREC_PALETTE_12P4_GREEN_UDW_MASK, color->green >> 6) |\n\t\tREG_FIELD_PREP(PREC_PALETTE_12P4_BLUE_UDW_MASK, color->blue >> 6);\n}\n\nstatic void ilk_lut_12p4_pack(struct drm_color_lut *entry, u32 ldw, u32 udw)\n{\n\tentry->red = REG_FIELD_GET(PREC_PALETTE_12P4_RED_UDW_MASK, udw) << 6 |\n\t\tREG_FIELD_GET(PREC_PALETTE_12P4_RED_LDW_MASK, ldw);\n\tentry->green = REG_FIELD_GET(PREC_PALETTE_12P4_GREEN_UDW_MASK, udw) << 6 |\n\t\tREG_FIELD_GET(PREC_PALETTE_12P4_GREEN_LDW_MASK, ldw);\n\tentry->blue = REG_FIELD_GET(PREC_PALETTE_12P4_BLUE_UDW_MASK, udw) << 6 |\n\t\tREG_FIELD_GET(PREC_PALETTE_12P4_BLUE_LDW_MASK, ldw);\n}\n\nstatic void icl_color_commit_noarm(const struct intel_crtc_state *crtc_state)\n{\n\t \n\ticl_load_csc_matrix(crtc_state);\n}\n\nstatic void skl_color_commit_noarm(const struct intel_crtc_state *crtc_state)\n{\n\t \n\tif (!crtc_state->has_psr)\n\t\tilk_load_csc_matrix(crtc_state);\n}\n\nstatic void ilk_color_commit_noarm(const struct intel_crtc_state *crtc_state)\n{\n\tilk_load_csc_matrix(crtc_state);\n}\n\nstatic void i9xx_color_commit_arm(const struct intel_crtc_state *crtc_state)\n{\n\t \n\ti9xx_set_pipeconf(crtc_state);\n}\n\nstatic void ilk_color_commit_arm(const struct intel_crtc_state *crtc_state)\n{\n\tstruct intel_crtc *crtc = to_intel_crtc(crtc_state->uapi.crtc);\n\tstruct drm_i915_private *i915 = to_i915(crtc->base.dev);\n\n\t \n\tilk_set_pipeconf(crtc_state);\n\n\tintel_de_write_fw(i915, PIPE_CSC_MODE(crtc->pipe),\n\t\t\t  crtc_state->csc_mode);\n}\n\nstatic void hsw_color_commit_arm(const struct intel_crtc_state *crtc_state)\n{\n\tstruct intel_crtc *crtc = to_intel_crtc(crtc_state->uapi.crtc);\n\tstruct drm_i915_private *i915 = to_i915(crtc->base.dev);\n\n\tintel_de_write(i915, GAMMA_MODE(crtc->pipe),\n\t\t       crtc_state->gamma_mode);\n\n\tintel_de_write_fw(i915, PIPE_CSC_MODE(crtc->pipe),\n\t\t\t  crtc_state->csc_mode);\n}\n\nstatic void skl_color_commit_arm(const struct intel_crtc_state *crtc_state)\n{\n\tstruct intel_crtc *crtc = to_intel_crtc(crtc_state->uapi.crtc);\n\tstruct drm_i915_private *i915 = to_i915(crtc->base.dev);\n\tenum pipe pipe = crtc->pipe;\n\tu32 val = 0;\n\n\tif (crtc_state->has_psr)\n\t\tilk_load_csc_matrix(crtc_state);\n\n\t \n\tif (crtc_state->gamma_enable)\n\t\tval |= SKL_BOTTOM_COLOR_GAMMA_ENABLE;\n\tif (crtc_state->csc_enable)\n\t\tval |= SKL_BOTTOM_COLOR_CSC_ENABLE;\n\tintel_de_write(i915, SKL_BOTTOM_COLOR(pipe), val);\n\n\tintel_de_write(i915, GAMMA_MODE(crtc->pipe),\n\t\t       crtc_state->gamma_mode);\n\n\tintel_de_write_fw(i915, PIPE_CSC_MODE(crtc->pipe),\n\t\t\t  crtc_state->csc_mode);\n}\n\nstatic void icl_color_commit_arm(const struct intel_crtc_state *crtc_state)\n{\n\tstruct intel_crtc *crtc = to_intel_crtc(crtc_state->uapi.crtc);\n\tstruct drm_i915_private *i915 = to_i915(crtc->base.dev);\n\tenum pipe pipe = crtc->pipe;\n\n\t \n\tintel_de_write(i915, SKL_BOTTOM_COLOR(pipe), 0);\n\n\tintel_de_write(i915, GAMMA_MODE(crtc->pipe),\n\t\t       crtc_state->gamma_mode);\n\n\tintel_de_write_fw(i915, PIPE_CSC_MODE(crtc->pipe),\n\t\t\t  crtc_state->csc_mode);\n}\n\nstatic void icl_color_post_update(const struct intel_crtc_state *crtc_state)\n{\n\tstruct intel_crtc *crtc = to_intel_crtc(crtc_state->uapi.crtc);\n\tstruct drm_i915_private *i915 = to_i915(crtc->base.dev);\n\n\t \n\tintel_de_read_fw(i915, PIPE_CSC_PREOFF_HI(crtc->pipe));\n}\n\nstatic struct drm_property_blob *\ncreate_linear_lut(struct drm_i915_private *i915, int lut_size)\n{\n\tstruct drm_property_blob *blob;\n\tstruct drm_color_lut *lut;\n\tint i;\n\n\tblob = drm_property_create_blob(&i915->drm,\n\t\t\t\t\tsizeof(lut[0]) * lut_size,\n\t\t\t\t\tNULL);\n\tif (IS_ERR(blob))\n\t\treturn blob;\n\n\tlut = blob->data;\n\n\tfor (i = 0; i < lut_size; i++) {\n\t\tu16 val = 0xffff * i / (lut_size - 1);\n\n\t\tlut[i].red = val;\n\t\tlut[i].green = val;\n\t\tlut[i].blue = val;\n\t}\n\n\treturn blob;\n}\n\nstatic u16 lut_limited_range(unsigned int value)\n{\n\tunsigned int min = 16 << 8;\n\tunsigned int max = 235 << 8;\n\n\treturn value * (max - min) / 0xffff + min;\n}\n\nstatic struct drm_property_blob *\ncreate_resized_lut(struct drm_i915_private *i915,\n\t\t   const struct drm_property_blob *blob_in, int lut_out_size,\n\t\t   bool limited_color_range)\n{\n\tint i, lut_in_size = drm_color_lut_size(blob_in);\n\tstruct drm_property_blob *blob_out;\n\tconst struct drm_color_lut *lut_in;\n\tstruct drm_color_lut *lut_out;\n\n\tblob_out = drm_property_create_blob(&i915->drm,\n\t\t\t\t\t    sizeof(lut_out[0]) * lut_out_size,\n\t\t\t\t\t    NULL);\n\tif (IS_ERR(blob_out))\n\t\treturn blob_out;\n\n\tlut_in = blob_in->data;\n\tlut_out = blob_out->data;\n\n\tfor (i = 0; i < lut_out_size; i++) {\n\t\tconst struct drm_color_lut *entry =\n\t\t\t&lut_in[i * (lut_in_size - 1) / (lut_out_size - 1)];\n\n\t\tif (limited_color_range) {\n\t\t\tlut_out[i].red = lut_limited_range(entry->red);\n\t\t\tlut_out[i].green = lut_limited_range(entry->green);\n\t\t\tlut_out[i].blue = lut_limited_range(entry->blue);\n\t\t} else {\n\t\t\tlut_out[i] = *entry;\n\t\t}\n\t}\n\n\treturn blob_out;\n}\n\nstatic void i9xx_load_lut_8(struct intel_crtc *crtc,\n\t\t\t    const struct drm_property_blob *blob)\n{\n\tstruct drm_i915_private *dev_priv = to_i915(crtc->base.dev);\n\tconst struct drm_color_lut *lut;\n\tenum pipe pipe = crtc->pipe;\n\tint i;\n\n\tif (!blob)\n\t\treturn;\n\n\tlut = blob->data;\n\n\tfor (i = 0; i < 256; i++)\n\t\tintel_de_write_fw(dev_priv, PALETTE(pipe, i),\n\t\t\t\t  i9xx_lut_8(&lut[i]));\n}\n\nstatic void i9xx_load_lut_10(struct intel_crtc *crtc,\n\t\t\t     const struct drm_property_blob *blob)\n{\n\tstruct drm_i915_private *dev_priv = to_i915(crtc->base.dev);\n\tconst struct drm_color_lut *lut = blob->data;\n\tint i, lut_size = drm_color_lut_size(blob);\n\tenum pipe pipe = crtc->pipe;\n\n\tfor (i = 0; i < lut_size - 1; i++) {\n\t\tintel_de_write_fw(dev_priv, PALETTE(pipe, 2 * i + 0),\n\t\t\t\t  i9xx_lut_10_ldw(&lut[i]));\n\t\tintel_de_write_fw(dev_priv, PALETTE(pipe, 2 * i + 1),\n\t\t\t\t  i9xx_lut_10_udw(&lut[i]));\n\t}\n}\n\nstatic void i9xx_load_luts(const struct intel_crtc_state *crtc_state)\n{\n\tstruct intel_crtc *crtc = to_intel_crtc(crtc_state->uapi.crtc);\n\tconst struct drm_property_blob *post_csc_lut = crtc_state->post_csc_lut;\n\n\tswitch (crtc_state->gamma_mode) {\n\tcase GAMMA_MODE_MODE_8BIT:\n\t\ti9xx_load_lut_8(crtc, post_csc_lut);\n\t\tbreak;\n\tcase GAMMA_MODE_MODE_10BIT:\n\t\ti9xx_load_lut_10(crtc, post_csc_lut);\n\t\tbreak;\n\tdefault:\n\t\tMISSING_CASE(crtc_state->gamma_mode);\n\t\tbreak;\n\t}\n}\n\nstatic void i965_load_lut_10p6(struct intel_crtc *crtc,\n\t\t\t       const struct drm_property_blob *blob)\n{\n\tstruct drm_i915_private *dev_priv = to_i915(crtc->base.dev);\n\tconst struct drm_color_lut *lut = blob->data;\n\tint i, lut_size = drm_color_lut_size(blob);\n\tenum pipe pipe = crtc->pipe;\n\n\tfor (i = 0; i < lut_size - 1; i++) {\n\t\tintel_de_write_fw(dev_priv, PALETTE(pipe, 2 * i + 0),\n\t\t\t\t  i965_lut_10p6_ldw(&lut[i]));\n\t\tintel_de_write_fw(dev_priv, PALETTE(pipe, 2 * i + 1),\n\t\t\t\t  i965_lut_10p6_udw(&lut[i]));\n\t}\n\n\tintel_de_write_fw(dev_priv, PIPEGCMAX(pipe, 0), lut[i].red);\n\tintel_de_write_fw(dev_priv, PIPEGCMAX(pipe, 1), lut[i].green);\n\tintel_de_write_fw(dev_priv, PIPEGCMAX(pipe, 2), lut[i].blue);\n}\n\nstatic void i965_load_luts(const struct intel_crtc_state *crtc_state)\n{\n\tstruct intel_crtc *crtc = to_intel_crtc(crtc_state->uapi.crtc);\n\tconst struct drm_property_blob *post_csc_lut = crtc_state->post_csc_lut;\n\n\tswitch (crtc_state->gamma_mode) {\n\tcase GAMMA_MODE_MODE_8BIT:\n\t\ti9xx_load_lut_8(crtc, post_csc_lut);\n\t\tbreak;\n\tcase GAMMA_MODE_MODE_10BIT:\n\t\ti965_load_lut_10p6(crtc, post_csc_lut);\n\t\tbreak;\n\tdefault:\n\t\tMISSING_CASE(crtc_state->gamma_mode);\n\t\tbreak;\n\t}\n}\n\nstatic void ilk_lut_write(const struct intel_crtc_state *crtc_state,\n\t\t\t  i915_reg_t reg, u32 val)\n{\n\tstruct drm_i915_private *i915 = to_i915(crtc_state->uapi.crtc->dev);\n\n\tif (crtc_state->dsb)\n\t\tintel_dsb_reg_write(crtc_state->dsb, reg, val);\n\telse\n\t\tintel_de_write_fw(i915, reg, val);\n}\n\nstatic void ilk_load_lut_8(const struct intel_crtc_state *crtc_state,\n\t\t\t   const struct drm_property_blob *blob)\n{\n\tstruct intel_crtc *crtc = to_intel_crtc(crtc_state->uapi.crtc);\n\tconst struct drm_color_lut *lut;\n\tenum pipe pipe = crtc->pipe;\n\tint i;\n\n\tif (!blob)\n\t\treturn;\n\n\tlut = blob->data;\n\n\tfor (i = 0; i < 256; i++)\n\t\tilk_lut_write(crtc_state, LGC_PALETTE(pipe, i),\n\t\t\t      i9xx_lut_8(&lut[i]));\n}\n\nstatic void ilk_load_lut_10(const struct intel_crtc_state *crtc_state,\n\t\t\t    const struct drm_property_blob *blob)\n{\n\tstruct intel_crtc *crtc = to_intel_crtc(crtc_state->uapi.crtc);\n\tconst struct drm_color_lut *lut = blob->data;\n\tint i, lut_size = drm_color_lut_size(blob);\n\tenum pipe pipe = crtc->pipe;\n\n\tfor (i = 0; i < lut_size; i++)\n\t\tilk_lut_write(crtc_state, PREC_PALETTE(pipe, i),\n\t\t\t      ilk_lut_10(&lut[i]));\n}\n\nstatic void ilk_load_luts(const struct intel_crtc_state *crtc_state)\n{\n\tconst struct drm_property_blob *post_csc_lut = crtc_state->post_csc_lut;\n\tconst struct drm_property_blob *pre_csc_lut = crtc_state->pre_csc_lut;\n\tconst struct drm_property_blob *blob = post_csc_lut ?: pre_csc_lut;\n\n\tswitch (crtc_state->gamma_mode) {\n\tcase GAMMA_MODE_MODE_8BIT:\n\t\tilk_load_lut_8(crtc_state, blob);\n\t\tbreak;\n\tcase GAMMA_MODE_MODE_10BIT:\n\t\tilk_load_lut_10(crtc_state, blob);\n\t\tbreak;\n\tdefault:\n\t\tMISSING_CASE(crtc_state->gamma_mode);\n\t\tbreak;\n\t}\n}\n\nstatic int ivb_lut_10_size(u32 prec_index)\n{\n\tif (prec_index & PAL_PREC_SPLIT_MODE)\n\t\treturn 512;\n\telse\n\t\treturn 1024;\n}\n\n \nstatic void ivb_load_lut_10(const struct intel_crtc_state *crtc_state,\n\t\t\t    const struct drm_property_blob *blob,\n\t\t\t    u32 prec_index)\n{\n\tconst struct intel_crtc *crtc = to_intel_crtc(crtc_state->uapi.crtc);\n\tconst struct drm_color_lut *lut = blob->data;\n\tint i, lut_size = drm_color_lut_size(blob);\n\tenum pipe pipe = crtc->pipe;\n\n\tfor (i = 0; i < lut_size; i++) {\n\t\tilk_lut_write(crtc_state, PREC_PAL_INDEX(pipe),\n\t\t\t      prec_index + i);\n\t\tilk_lut_write(crtc_state, PREC_PAL_DATA(pipe),\n\t\t\t      ilk_lut_10(&lut[i]));\n\t}\n\n\t \n\tilk_lut_write(crtc_state, PREC_PAL_INDEX(pipe),\n\t\t      PAL_PREC_INDEX_VALUE(0));\n}\n\n \nstatic void bdw_load_lut_10(const struct intel_crtc_state *crtc_state,\n\t\t\t    const struct drm_property_blob *blob,\n\t\t\t    u32 prec_index)\n{\n\tstruct intel_crtc *crtc = to_intel_crtc(crtc_state->uapi.crtc);\n\tconst struct drm_color_lut *lut = blob->data;\n\tint i, lut_size = drm_color_lut_size(blob);\n\tenum pipe pipe = crtc->pipe;\n\n\tilk_lut_write(crtc_state, PREC_PAL_INDEX(pipe),\n\t\t      prec_index);\n\tilk_lut_write(crtc_state, PREC_PAL_INDEX(pipe),\n\t\t      PAL_PREC_AUTO_INCREMENT |\n\t\t      prec_index);\n\n\tfor (i = 0; i < lut_size; i++)\n\t\tilk_lut_write(crtc_state, PREC_PAL_DATA(pipe),\n\t\t\t      ilk_lut_10(&lut[i]));\n\n\t \n\tilk_lut_write(crtc_state, PREC_PAL_INDEX(pipe),\n\t\t      PAL_PREC_INDEX_VALUE(0));\n}\n\nstatic void ivb_load_lut_ext_max(const struct intel_crtc_state *crtc_state)\n{\n\tstruct intel_crtc *crtc = to_intel_crtc(crtc_state->uapi.crtc);\n\tenum pipe pipe = crtc->pipe;\n\n\t \n\tilk_lut_write(crtc_state, PREC_PAL_EXT_GC_MAX(pipe, 0), 1 << 16);\n\tilk_lut_write(crtc_state, PREC_PAL_EXT_GC_MAX(pipe, 1), 1 << 16);\n\tilk_lut_write(crtc_state, PREC_PAL_EXT_GC_MAX(pipe, 2), 1 << 16);\n}\n\nstatic void glk_load_lut_ext2_max(const struct intel_crtc_state *crtc_state)\n{\n\tstruct intel_crtc *crtc = to_intel_crtc(crtc_state->uapi.crtc);\n\tenum pipe pipe = crtc->pipe;\n\n\t \n\tilk_lut_write(crtc_state, PREC_PAL_EXT2_GC_MAX(pipe, 0), 1 << 16);\n\tilk_lut_write(crtc_state, PREC_PAL_EXT2_GC_MAX(pipe, 1), 1 << 16);\n\tilk_lut_write(crtc_state, PREC_PAL_EXT2_GC_MAX(pipe, 2), 1 << 16);\n}\n\nstatic void ivb_load_luts(const struct intel_crtc_state *crtc_state)\n{\n\tconst struct drm_property_blob *post_csc_lut = crtc_state->post_csc_lut;\n\tconst struct drm_property_blob *pre_csc_lut = crtc_state->pre_csc_lut;\n\tconst struct drm_property_blob *blob = post_csc_lut ?: pre_csc_lut;\n\n\tswitch (crtc_state->gamma_mode) {\n\tcase GAMMA_MODE_MODE_8BIT:\n\t\tilk_load_lut_8(crtc_state, blob);\n\t\tbreak;\n\tcase GAMMA_MODE_MODE_SPLIT:\n\t\tivb_load_lut_10(crtc_state, pre_csc_lut, PAL_PREC_SPLIT_MODE |\n\t\t\t\tPAL_PREC_INDEX_VALUE(0));\n\t\tivb_load_lut_ext_max(crtc_state);\n\t\tivb_load_lut_10(crtc_state, post_csc_lut, PAL_PREC_SPLIT_MODE |\n\t\t\t\tPAL_PREC_INDEX_VALUE(512));\n\t\tbreak;\n\tcase GAMMA_MODE_MODE_10BIT:\n\t\tivb_load_lut_10(crtc_state, blob,\n\t\t\t\tPAL_PREC_INDEX_VALUE(0));\n\t\tivb_load_lut_ext_max(crtc_state);\n\t\tbreak;\n\tdefault:\n\t\tMISSING_CASE(crtc_state->gamma_mode);\n\t\tbreak;\n\t}\n}\n\nstatic void bdw_load_luts(const struct intel_crtc_state *crtc_state)\n{\n\tconst struct drm_property_blob *post_csc_lut = crtc_state->post_csc_lut;\n\tconst struct drm_property_blob *pre_csc_lut = crtc_state->pre_csc_lut;\n\tconst struct drm_property_blob *blob = post_csc_lut ?: pre_csc_lut;\n\n\tswitch (crtc_state->gamma_mode) {\n\tcase GAMMA_MODE_MODE_8BIT:\n\t\tilk_load_lut_8(crtc_state, blob);\n\t\tbreak;\n\tcase GAMMA_MODE_MODE_SPLIT:\n\t\tbdw_load_lut_10(crtc_state, pre_csc_lut, PAL_PREC_SPLIT_MODE |\n\t\t\t\tPAL_PREC_INDEX_VALUE(0));\n\t\tivb_load_lut_ext_max(crtc_state);\n\t\tbdw_load_lut_10(crtc_state, post_csc_lut, PAL_PREC_SPLIT_MODE |\n\t\t\t\tPAL_PREC_INDEX_VALUE(512));\n\t\tbreak;\n\tcase GAMMA_MODE_MODE_10BIT:\n\t\tbdw_load_lut_10(crtc_state, blob,\n\t\t\t\tPAL_PREC_INDEX_VALUE(0));\n\t\tivb_load_lut_ext_max(crtc_state);\n\t\tbreak;\n\tdefault:\n\t\tMISSING_CASE(crtc_state->gamma_mode);\n\t\tbreak;\n\t}\n}\n\nstatic int glk_degamma_lut_size(struct drm_i915_private *i915)\n{\n\tif (DISPLAY_VER(i915) >= 13)\n\t\treturn 131;\n\telse\n\t\treturn 35;\n}\n\n \nstatic u32 change_lut_val_precision(u32 lut_val, int to, int from)\n{\n\treturn mul_u32_u32(lut_val, (1 << to)) / (1 << from);\n}\n\nstatic void glk_load_degamma_lut(const struct intel_crtc_state *crtc_state,\n\t\t\t\t const struct drm_property_blob *blob)\n{\n\tstruct intel_crtc *crtc = to_intel_crtc(crtc_state->uapi.crtc);\n\tstruct drm_i915_private *i915 = to_i915(crtc->base.dev);\n\tconst struct drm_color_lut *lut = blob->data;\n\tint i, lut_size = drm_color_lut_size(blob);\n\tenum pipe pipe = crtc->pipe;\n\n\t \n\tilk_lut_write(crtc_state, PRE_CSC_GAMC_INDEX(pipe),\n\t\t      PRE_CSC_GAMC_INDEX_VALUE(0));\n\tilk_lut_write(crtc_state, PRE_CSC_GAMC_INDEX(pipe),\n\t\t      PRE_CSC_GAMC_AUTO_INCREMENT |\n\t\t      PRE_CSC_GAMC_INDEX_VALUE(0));\n\n\tfor (i = 0; i < lut_size; i++) {\n\t\t \n\t\tu32 lut_val;\n\n\t\tif (DISPLAY_VER(i915) >= 14)\n\t\t\tlut_val = change_lut_val_precision(lut[i].green, 24, 16);\n\t\telse\n\t\t\tlut_val = lut[i].green;\n\n\t\tilk_lut_write(crtc_state, PRE_CSC_GAMC_DATA(pipe),\n\t\t\t      lut_val);\n\t}\n\n\t \n\twhile (i++ < glk_degamma_lut_size(i915))\n\t\tilk_lut_write(crtc_state, PRE_CSC_GAMC_DATA(pipe), 1 << 16);\n\n\tilk_lut_write(crtc_state, PRE_CSC_GAMC_INDEX(pipe), 0);\n}\n\nstatic void glk_load_luts(const struct intel_crtc_state *crtc_state)\n{\n\tconst struct drm_property_blob *pre_csc_lut = crtc_state->pre_csc_lut;\n\tconst struct drm_property_blob *post_csc_lut = crtc_state->post_csc_lut;\n\n\tif (pre_csc_lut)\n\t\tglk_load_degamma_lut(crtc_state, pre_csc_lut);\n\n\tswitch (crtc_state->gamma_mode) {\n\tcase GAMMA_MODE_MODE_8BIT:\n\t\tilk_load_lut_8(crtc_state, post_csc_lut);\n\t\tbreak;\n\tcase GAMMA_MODE_MODE_10BIT:\n\t\tbdw_load_lut_10(crtc_state, post_csc_lut, PAL_PREC_INDEX_VALUE(0));\n\t\tivb_load_lut_ext_max(crtc_state);\n\t\tglk_load_lut_ext2_max(crtc_state);\n\t\tbreak;\n\tdefault:\n\t\tMISSING_CASE(crtc_state->gamma_mode);\n\t\tbreak;\n\t}\n}\n\nstatic void\nivb_load_lut_max(const struct intel_crtc_state *crtc_state,\n\t\t const struct drm_color_lut *color)\n{\n\tstruct intel_crtc *crtc = to_intel_crtc(crtc_state->uapi.crtc);\n\tenum pipe pipe = crtc->pipe;\n\n\t \n\tilk_lut_write(crtc_state, PREC_PAL_GC_MAX(pipe, 0), color->red);\n\tilk_lut_write(crtc_state, PREC_PAL_GC_MAX(pipe, 1), color->green);\n\tilk_lut_write(crtc_state, PREC_PAL_GC_MAX(pipe, 2), color->blue);\n}\n\nstatic void\nicl_program_gamma_superfine_segment(const struct intel_crtc_state *crtc_state)\n{\n\tstruct intel_crtc *crtc = to_intel_crtc(crtc_state->uapi.crtc);\n\tconst struct drm_property_blob *blob = crtc_state->post_csc_lut;\n\tconst struct drm_color_lut *lut = blob->data;\n\tenum pipe pipe = crtc->pipe;\n\tint i;\n\n\t \n\tilk_lut_write(crtc_state, PREC_PAL_MULTI_SEG_INDEX(pipe),\n\t\t      PAL_PREC_MULTI_SEG_INDEX_VALUE(0));\n\tilk_lut_write(crtc_state, PREC_PAL_MULTI_SEG_INDEX(pipe),\n\t\t      PAL_PREC_AUTO_INCREMENT |\n\t\t      PAL_PREC_MULTI_SEG_INDEX_VALUE(0));\n\n\tfor (i = 0; i < 9; i++) {\n\t\tconst struct drm_color_lut *entry = &lut[i];\n\n\t\tilk_lut_write(crtc_state, PREC_PAL_MULTI_SEG_DATA(pipe),\n\t\t\t      ilk_lut_12p4_ldw(entry));\n\t\tilk_lut_write(crtc_state, PREC_PAL_MULTI_SEG_DATA(pipe),\n\t\t\t      ilk_lut_12p4_udw(entry));\n\t}\n\n\tilk_lut_write(crtc_state, PREC_PAL_MULTI_SEG_INDEX(pipe),\n\t\t      PAL_PREC_MULTI_SEG_INDEX_VALUE(0));\n}\n\nstatic void\nicl_program_gamma_multi_segment(const struct intel_crtc_state *crtc_state)\n{\n\tstruct intel_crtc *crtc = to_intel_crtc(crtc_state->uapi.crtc);\n\tconst struct drm_property_blob *blob = crtc_state->post_csc_lut;\n\tconst struct drm_color_lut *lut = blob->data;\n\tconst struct drm_color_lut *entry;\n\tenum pipe pipe = crtc->pipe;\n\tint i;\n\n\t \n\tilk_lut_write(crtc_state, PREC_PAL_INDEX(pipe),\n\t\t      PAL_PREC_INDEX_VALUE(0));\n\tilk_lut_write(crtc_state, PREC_PAL_INDEX(pipe),\n\t\t      PAL_PREC_AUTO_INCREMENT |\n\t\t      PAL_PREC_INDEX_VALUE(0));\n\n\tfor (i = 1; i < 257; i++) {\n\t\tentry = &lut[i * 8];\n\n\t\tilk_lut_write(crtc_state, PREC_PAL_DATA(pipe),\n\t\t\t      ilk_lut_12p4_ldw(entry));\n\t\tilk_lut_write(crtc_state, PREC_PAL_DATA(pipe),\n\t\t\t      ilk_lut_12p4_udw(entry));\n\t}\n\n\t \n\tfor (i = 0; i < 256; i++) {\n\t\tentry = &lut[i * 8 * 128];\n\n\t\tilk_lut_write(crtc_state, PREC_PAL_DATA(pipe),\n\t\t\t      ilk_lut_12p4_ldw(entry));\n\t\tilk_lut_write(crtc_state, PREC_PAL_DATA(pipe),\n\t\t\t      ilk_lut_12p4_udw(entry));\n\t}\n\n\tilk_lut_write(crtc_state, PREC_PAL_INDEX(pipe),\n\t\t      PAL_PREC_INDEX_VALUE(0));\n\n\t \n\tentry = &lut[256 * 8 * 128];\n\tivb_load_lut_max(crtc_state, entry);\n}\n\nstatic void icl_load_luts(const struct intel_crtc_state *crtc_state)\n{\n\tconst struct drm_property_blob *pre_csc_lut = crtc_state->pre_csc_lut;\n\tconst struct drm_property_blob *post_csc_lut = crtc_state->post_csc_lut;\n\n\tif (pre_csc_lut)\n\t\tglk_load_degamma_lut(crtc_state, pre_csc_lut);\n\n\tswitch (crtc_state->gamma_mode & GAMMA_MODE_MODE_MASK) {\n\tcase GAMMA_MODE_MODE_8BIT:\n\t\tilk_load_lut_8(crtc_state, post_csc_lut);\n\t\tbreak;\n\tcase GAMMA_MODE_MODE_12BIT_MULTI_SEG:\n\t\ticl_program_gamma_superfine_segment(crtc_state);\n\t\ticl_program_gamma_multi_segment(crtc_state);\n\t\tivb_load_lut_ext_max(crtc_state);\n\t\tglk_load_lut_ext2_max(crtc_state);\n\t\tbreak;\n\tcase GAMMA_MODE_MODE_10BIT:\n\t\tbdw_load_lut_10(crtc_state, post_csc_lut, PAL_PREC_INDEX_VALUE(0));\n\t\tivb_load_lut_ext_max(crtc_state);\n\t\tglk_load_lut_ext2_max(crtc_state);\n\t\tbreak;\n\tdefault:\n\t\tMISSING_CASE(crtc_state->gamma_mode);\n\t\tbreak;\n\t}\n\n\tif (crtc_state->dsb) {\n\t\tintel_dsb_finish(crtc_state->dsb);\n\t\tintel_dsb_commit(crtc_state->dsb, false);\n\t\tintel_dsb_wait(crtc_state->dsb);\n\t}\n}\n\nstatic void vlv_load_luts(const struct intel_crtc_state *crtc_state)\n{\n\tstruct intel_crtc *crtc = to_intel_crtc(crtc_state->uapi.crtc);\n\n\tif (crtc_state->wgc_enable)\n\t\tvlv_load_wgc_csc(crtc, &crtc_state->csc);\n\n\ti965_load_luts(crtc_state);\n}\n\nstatic u32 chv_cgm_degamma_ldw(const struct drm_color_lut *color)\n{\n\treturn REG_FIELD_PREP(CGM_PIPE_DEGAMMA_GREEN_LDW_MASK, drm_color_lut_extract(color->green, 14)) |\n\t\tREG_FIELD_PREP(CGM_PIPE_DEGAMMA_BLUE_LDW_MASK, drm_color_lut_extract(color->blue, 14));\n}\n\nstatic u32 chv_cgm_degamma_udw(const struct drm_color_lut *color)\n{\n\treturn REG_FIELD_PREP(CGM_PIPE_DEGAMMA_RED_UDW_MASK, drm_color_lut_extract(color->red, 14));\n}\n\nstatic void chv_cgm_degamma_pack(struct drm_color_lut *entry, u32 ldw, u32 udw)\n{\n\tentry->green = intel_color_lut_pack(REG_FIELD_GET(CGM_PIPE_DEGAMMA_GREEN_LDW_MASK, ldw), 14);\n\tentry->blue = intel_color_lut_pack(REG_FIELD_GET(CGM_PIPE_DEGAMMA_BLUE_LDW_MASK, ldw), 14);\n\tentry->red = intel_color_lut_pack(REG_FIELD_GET(CGM_PIPE_DEGAMMA_RED_UDW_MASK, udw), 14);\n}\n\nstatic void chv_load_cgm_degamma(struct intel_crtc *crtc,\n\t\t\t\t const struct drm_property_blob *blob)\n{\n\tstruct drm_i915_private *i915 = to_i915(crtc->base.dev);\n\tconst struct drm_color_lut *lut = blob->data;\n\tint i, lut_size = drm_color_lut_size(blob);\n\tenum pipe pipe = crtc->pipe;\n\n\tfor (i = 0; i < lut_size; i++) {\n\t\tintel_de_write_fw(i915, CGM_PIPE_DEGAMMA(pipe, i, 0),\n\t\t\t\t  chv_cgm_degamma_ldw(&lut[i]));\n\t\tintel_de_write_fw(i915, CGM_PIPE_DEGAMMA(pipe, i, 1),\n\t\t\t\t  chv_cgm_degamma_udw(&lut[i]));\n\t}\n}\n\nstatic u32 chv_cgm_gamma_ldw(const struct drm_color_lut *color)\n{\n\treturn REG_FIELD_PREP(CGM_PIPE_GAMMA_GREEN_LDW_MASK, drm_color_lut_extract(color->green, 10)) |\n\t\tREG_FIELD_PREP(CGM_PIPE_GAMMA_BLUE_LDW_MASK, drm_color_lut_extract(color->blue, 10));\n}\n\nstatic u32 chv_cgm_gamma_udw(const struct drm_color_lut *color)\n{\n\treturn REG_FIELD_PREP(CGM_PIPE_GAMMA_RED_UDW_MASK, drm_color_lut_extract(color->red, 10));\n}\n\nstatic void chv_cgm_gamma_pack(struct drm_color_lut *entry, u32 ldw, u32 udw)\n{\n\tentry->green = intel_color_lut_pack(REG_FIELD_GET(CGM_PIPE_GAMMA_GREEN_LDW_MASK, ldw), 10);\n\tentry->blue = intel_color_lut_pack(REG_FIELD_GET(CGM_PIPE_GAMMA_BLUE_LDW_MASK, ldw), 10);\n\tentry->red = intel_color_lut_pack(REG_FIELD_GET(CGM_PIPE_GAMMA_RED_UDW_MASK, udw), 10);\n}\n\nstatic void chv_load_cgm_gamma(struct intel_crtc *crtc,\n\t\t\t       const struct drm_property_blob *blob)\n{\n\tstruct drm_i915_private *i915 = to_i915(crtc->base.dev);\n\tconst struct drm_color_lut *lut = blob->data;\n\tint i, lut_size = drm_color_lut_size(blob);\n\tenum pipe pipe = crtc->pipe;\n\n\tfor (i = 0; i < lut_size; i++) {\n\t\tintel_de_write_fw(i915, CGM_PIPE_GAMMA(pipe, i, 0),\n\t\t\t\t  chv_cgm_gamma_ldw(&lut[i]));\n\t\tintel_de_write_fw(i915, CGM_PIPE_GAMMA(pipe, i, 1),\n\t\t\t\t  chv_cgm_gamma_udw(&lut[i]));\n\t}\n}\n\nstatic void chv_load_luts(const struct intel_crtc_state *crtc_state)\n{\n\tstruct intel_crtc *crtc = to_intel_crtc(crtc_state->uapi.crtc);\n\tstruct drm_i915_private *i915 = to_i915(crtc->base.dev);\n\tconst struct drm_property_blob *pre_csc_lut = crtc_state->pre_csc_lut;\n\tconst struct drm_property_blob *post_csc_lut = crtc_state->post_csc_lut;\n\n\tif (crtc_state->cgm_mode & CGM_PIPE_MODE_CSC)\n\t\tchv_load_cgm_csc(crtc, &crtc_state->csc);\n\n\tif (crtc_state->cgm_mode & CGM_PIPE_MODE_DEGAMMA)\n\t\tchv_load_cgm_degamma(crtc, pre_csc_lut);\n\n\tif (crtc_state->cgm_mode & CGM_PIPE_MODE_GAMMA)\n\t\tchv_load_cgm_gamma(crtc, post_csc_lut);\n\telse\n\t\ti965_load_luts(crtc_state);\n\n\tintel_de_write_fw(i915, CGM_PIPE_MODE(crtc->pipe),\n\t\t\t  crtc_state->cgm_mode);\n}\n\nvoid intel_color_load_luts(const struct intel_crtc_state *crtc_state)\n{\n\tstruct drm_i915_private *i915 = to_i915(crtc_state->uapi.crtc->dev);\n\n\ti915->display.funcs.color->load_luts(crtc_state);\n}\n\nvoid intel_color_commit_noarm(const struct intel_crtc_state *crtc_state)\n{\n\tstruct drm_i915_private *i915 = to_i915(crtc_state->uapi.crtc->dev);\n\n\tif (i915->display.funcs.color->color_commit_noarm)\n\t\ti915->display.funcs.color->color_commit_noarm(crtc_state);\n}\n\nvoid intel_color_commit_arm(const struct intel_crtc_state *crtc_state)\n{\n\tstruct drm_i915_private *i915 = to_i915(crtc_state->uapi.crtc->dev);\n\n\ti915->display.funcs.color->color_commit_arm(crtc_state);\n}\n\nvoid intel_color_post_update(const struct intel_crtc_state *crtc_state)\n{\n\tstruct drm_i915_private *i915 = to_i915(crtc_state->uapi.crtc->dev);\n\n\tif (i915->display.funcs.color->color_post_update)\n\t\ti915->display.funcs.color->color_post_update(crtc_state);\n}\n\nvoid intel_color_prepare_commit(struct intel_crtc_state *crtc_state)\n{\n\tstruct intel_crtc *crtc = to_intel_crtc(crtc_state->uapi.crtc);\n\n\t \n\treturn;\n\n\tif (!crtc_state->pre_csc_lut && !crtc_state->post_csc_lut)\n\t\treturn;\n\n\tcrtc_state->dsb = intel_dsb_prepare(crtc, 1024);\n}\n\nvoid intel_color_cleanup_commit(struct intel_crtc_state *crtc_state)\n{\n\tif (!crtc_state->dsb)\n\t\treturn;\n\n\tintel_dsb_cleanup(crtc_state->dsb);\n\tcrtc_state->dsb = NULL;\n}\n\nstatic bool intel_can_preload_luts(const struct intel_crtc_state *new_crtc_state)\n{\n\tstruct intel_crtc *crtc = to_intel_crtc(new_crtc_state->uapi.crtc);\n\tstruct intel_atomic_state *state =\n\t\tto_intel_atomic_state(new_crtc_state->uapi.state);\n\tconst struct intel_crtc_state *old_crtc_state =\n\t\tintel_atomic_get_old_crtc_state(state, crtc);\n\n\treturn !old_crtc_state->post_csc_lut &&\n\t\t!old_crtc_state->pre_csc_lut;\n}\n\nstatic bool vlv_can_preload_luts(const struct intel_crtc_state *new_crtc_state)\n{\n\tstruct intel_crtc *crtc = to_intel_crtc(new_crtc_state->uapi.crtc);\n\tstruct intel_atomic_state *state =\n\t\tto_intel_atomic_state(new_crtc_state->uapi.state);\n\tconst struct intel_crtc_state *old_crtc_state =\n\t\tintel_atomic_get_old_crtc_state(state, crtc);\n\n\treturn !old_crtc_state->wgc_enable &&\n\t\t!old_crtc_state->post_csc_lut;\n}\n\nstatic bool chv_can_preload_luts(const struct intel_crtc_state *new_crtc_state)\n{\n\tstruct intel_crtc *crtc = to_intel_crtc(new_crtc_state->uapi.crtc);\n\tstruct intel_atomic_state *state =\n\t\tto_intel_atomic_state(new_crtc_state->uapi.state);\n\tconst struct intel_crtc_state *old_crtc_state =\n\t\tintel_atomic_get_old_crtc_state(state, crtc);\n\n\t \n\tif (old_crtc_state->cgm_mode || new_crtc_state->cgm_mode)\n\t\treturn false;\n\n\treturn vlv_can_preload_luts(new_crtc_state);\n}\n\nint intel_color_check(struct intel_crtc_state *crtc_state)\n{\n\tstruct drm_i915_private *i915 = to_i915(crtc_state->uapi.crtc->dev);\n\n\treturn i915->display.funcs.color->color_check(crtc_state);\n}\n\nvoid intel_color_get_config(struct intel_crtc_state *crtc_state)\n{\n\tstruct drm_i915_private *i915 = to_i915(crtc_state->uapi.crtc->dev);\n\n\ti915->display.funcs.color->read_luts(crtc_state);\n\n\tif (i915->display.funcs.color->read_csc)\n\t\ti915->display.funcs.color->read_csc(crtc_state);\n}\n\nbool intel_color_lut_equal(const struct intel_crtc_state *crtc_state,\n\t\t\t   const struct drm_property_blob *blob1,\n\t\t\t   const struct drm_property_blob *blob2,\n\t\t\t   bool is_pre_csc_lut)\n{\n\tstruct drm_i915_private *i915 = to_i915(crtc_state->uapi.crtc->dev);\n\n\t \n\tif (!is_pre_csc_lut && crtc_state->c8_planes)\n\t\treturn true;\n\n\treturn i915->display.funcs.color->lut_equal(crtc_state, blob1, blob2,\n\t\t\t\t\t\t    is_pre_csc_lut);\n}\n\nstatic bool need_plane_update(struct intel_plane *plane,\n\t\t\t      const struct intel_crtc_state *crtc_state)\n{\n\tstruct drm_i915_private *i915 = to_i915(plane->base.dev);\n\n\t \n\treturn crtc_state->active_planes & BIT(plane->id) ||\n\t\t(DISPLAY_VER(i915) < 9 &&\n\t\t plane->id == PLANE_PRIMARY);\n}\n\nstatic int\nintel_color_add_affected_planes(struct intel_crtc_state *new_crtc_state)\n{\n\tstruct intel_crtc *crtc = to_intel_crtc(new_crtc_state->uapi.crtc);\n\tstruct drm_i915_private *i915 = to_i915(crtc->base.dev);\n\tstruct intel_atomic_state *state =\n\t\tto_intel_atomic_state(new_crtc_state->uapi.state);\n\tconst struct intel_crtc_state *old_crtc_state =\n\t\tintel_atomic_get_old_crtc_state(state, crtc);\n\tstruct intel_plane *plane;\n\n\tif (!new_crtc_state->hw.active ||\n\t    intel_crtc_needs_modeset(new_crtc_state))\n\t\treturn 0;\n\n\tif (new_crtc_state->gamma_enable == old_crtc_state->gamma_enable &&\n\t    new_crtc_state->csc_enable == old_crtc_state->csc_enable)\n\t\treturn 0;\n\n\tfor_each_intel_plane_on_crtc(&i915->drm, crtc, plane) {\n\t\tstruct intel_plane_state *plane_state;\n\n\t\tif (!need_plane_update(plane, new_crtc_state))\n\t\t\tcontinue;\n\n\t\tplane_state = intel_atomic_get_plane_state(state, plane);\n\t\tif (IS_ERR(plane_state))\n\t\t\treturn PTR_ERR(plane_state);\n\n\t\tnew_crtc_state->update_planes |= BIT(plane->id);\n\t\tnew_crtc_state->async_flip_planes = 0;\n\t\tnew_crtc_state->do_async_flip = false;\n\n\t\t \n\t\tif (HAS_GMCH(i915))\n\t\t\tnew_crtc_state->disable_cxsr = true;\n\t}\n\n\treturn 0;\n}\n\nstatic u32 intel_gamma_lut_tests(const struct intel_crtc_state *crtc_state)\n{\n\tstruct drm_i915_private *i915 = to_i915(crtc_state->uapi.crtc->dev);\n\tconst struct drm_property_blob *gamma_lut = crtc_state->hw.gamma_lut;\n\n\tif (lut_is_legacy(gamma_lut))\n\t\treturn 0;\n\n\treturn DISPLAY_INFO(i915)->color.gamma_lut_tests;\n}\n\nstatic u32 intel_degamma_lut_tests(const struct intel_crtc_state *crtc_state)\n{\n\tstruct drm_i915_private *i915 = to_i915(crtc_state->uapi.crtc->dev);\n\n\treturn DISPLAY_INFO(i915)->color.degamma_lut_tests;\n}\n\nstatic int intel_gamma_lut_size(const struct intel_crtc_state *crtc_state)\n{\n\tstruct drm_i915_private *i915 = to_i915(crtc_state->uapi.crtc->dev);\n\tconst struct drm_property_blob *gamma_lut = crtc_state->hw.gamma_lut;\n\n\tif (lut_is_legacy(gamma_lut))\n\t\treturn LEGACY_LUT_LENGTH;\n\n\treturn DISPLAY_INFO(i915)->color.gamma_lut_size;\n}\n\nstatic u32 intel_degamma_lut_size(const struct intel_crtc_state *crtc_state)\n{\n\tstruct drm_i915_private *i915 = to_i915(crtc_state->uapi.crtc->dev);\n\n\treturn DISPLAY_INFO(i915)->color.degamma_lut_size;\n}\n\nstatic int check_lut_size(const struct drm_property_blob *lut, int expected)\n{\n\tint len;\n\n\tif (!lut)\n\t\treturn 0;\n\n\tlen = drm_color_lut_size(lut);\n\tif (len != expected) {\n\t\tDRM_DEBUG_KMS(\"Invalid LUT size; got %d, expected %d\\n\",\n\t\t\t      len, expected);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int _check_luts(const struct intel_crtc_state *crtc_state,\n\t\t       u32 degamma_tests, u32 gamma_tests)\n{\n\tstruct drm_i915_private *i915 = to_i915(crtc_state->uapi.crtc->dev);\n\tconst struct drm_property_blob *gamma_lut = crtc_state->hw.gamma_lut;\n\tconst struct drm_property_blob *degamma_lut = crtc_state->hw.degamma_lut;\n\tint gamma_length, degamma_length;\n\n\t \n\tif (crtc_state->c8_planes && !lut_is_legacy(crtc_state->hw.gamma_lut)) {\n\t\tdrm_dbg_kms(&i915->drm,\n\t\t\t    \"C8 pixelformat requires the legacy LUT\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tdegamma_length = intel_degamma_lut_size(crtc_state);\n\tgamma_length = intel_gamma_lut_size(crtc_state);\n\n\tif (check_lut_size(degamma_lut, degamma_length) ||\n\t    check_lut_size(gamma_lut, gamma_length))\n\t\treturn -EINVAL;\n\n\tif (drm_color_lut_check(degamma_lut, degamma_tests) ||\n\t    drm_color_lut_check(gamma_lut, gamma_tests))\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nstatic int check_luts(const struct intel_crtc_state *crtc_state)\n{\n\treturn _check_luts(crtc_state,\n\t\t\t   intel_degamma_lut_tests(crtc_state),\n\t\t\t   intel_gamma_lut_tests(crtc_state));\n}\n\nstatic u32 i9xx_gamma_mode(struct intel_crtc_state *crtc_state)\n{\n\tif (!crtc_state->gamma_enable ||\n\t    lut_is_legacy(crtc_state->hw.gamma_lut))\n\t\treturn GAMMA_MODE_MODE_8BIT;\n\telse\n\t\treturn GAMMA_MODE_MODE_10BIT;\n}\n\nstatic int i9xx_lut_10_diff(u16 a, u16 b)\n{\n\treturn drm_color_lut_extract(a, 10) -\n\t\tdrm_color_lut_extract(b, 10);\n}\n\nstatic int i9xx_check_lut_10(struct drm_i915_private *dev_priv,\n\t\t\t     const struct drm_property_blob *blob)\n{\n\tconst struct drm_color_lut *lut = blob->data;\n\tint lut_size = drm_color_lut_size(blob);\n\tconst struct drm_color_lut *a = &lut[lut_size - 2];\n\tconst struct drm_color_lut *b = &lut[lut_size - 1];\n\n\tif (i9xx_lut_10_diff(b->red, a->red) > 0x7f ||\n\t    i9xx_lut_10_diff(b->green, a->green) > 0x7f ||\n\t    i9xx_lut_10_diff(b->blue, a->blue) > 0x7f) {\n\t\tdrm_dbg_kms(&dev_priv->drm, \"Last gamma LUT entry exceeds max slope\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nvoid intel_color_assert_luts(const struct intel_crtc_state *crtc_state)\n{\n\tstruct drm_i915_private *i915 = to_i915(crtc_state->uapi.crtc->dev);\n\n\t \n\tif (DISPLAY_VER(i915) >= 11 || HAS_GMCH(i915)) {\n\t\tdrm_WARN_ON(&i915->drm,\n\t\t\t    crtc_state->pre_csc_lut != crtc_state->hw.degamma_lut);\n\t\tdrm_WARN_ON(&i915->drm,\n\t\t\t    crtc_state->post_csc_lut != crtc_state->hw.gamma_lut);\n\t} else if (DISPLAY_VER(i915) == 10) {\n\t\tdrm_WARN_ON(&i915->drm,\n\t\t\t    crtc_state->post_csc_lut == crtc_state->hw.gamma_lut &&\n\t\t\t    crtc_state->pre_csc_lut != crtc_state->hw.degamma_lut &&\n\t\t\t    crtc_state->pre_csc_lut != i915->display.color.glk_linear_degamma_lut);\n\t\tdrm_WARN_ON(&i915->drm,\n\t\t\t    !ilk_lut_limited_range(crtc_state) &&\n\t\t\t    crtc_state->post_csc_lut != NULL &&\n\t\t\t    crtc_state->post_csc_lut != crtc_state->hw.gamma_lut);\n\t} else if (crtc_state->gamma_mode != GAMMA_MODE_MODE_SPLIT) {\n\t\tdrm_WARN_ON(&i915->drm,\n\t\t\t    crtc_state->pre_csc_lut != crtc_state->hw.degamma_lut &&\n\t\t\t    crtc_state->pre_csc_lut != crtc_state->hw.gamma_lut);\n\t\tdrm_WARN_ON(&i915->drm,\n\t\t\t    !ilk_lut_limited_range(crtc_state) &&\n\t\t\t    crtc_state->post_csc_lut != crtc_state->hw.degamma_lut &&\n\t\t\t    crtc_state->post_csc_lut != crtc_state->hw.gamma_lut);\n\t}\n}\n\nstatic void intel_assign_luts(struct intel_crtc_state *crtc_state)\n{\n\tdrm_property_replace_blob(&crtc_state->pre_csc_lut,\n\t\t\t\t  crtc_state->hw.degamma_lut);\n\tdrm_property_replace_blob(&crtc_state->post_csc_lut,\n\t\t\t\t  crtc_state->hw.gamma_lut);\n}\n\nstatic int i9xx_color_check(struct intel_crtc_state *crtc_state)\n{\n\tstruct drm_i915_private *i915 = to_i915(crtc_state->uapi.crtc->dev);\n\tint ret;\n\n\tret = check_luts(crtc_state);\n\tif (ret)\n\t\treturn ret;\n\n\tcrtc_state->gamma_enable =\n\t\tcrtc_state->hw.gamma_lut &&\n\t\t!crtc_state->c8_planes;\n\n\tcrtc_state->gamma_mode = i9xx_gamma_mode(crtc_state);\n\n\tif (DISPLAY_VER(i915) < 4 &&\n\t    crtc_state->gamma_mode == GAMMA_MODE_MODE_10BIT) {\n\t\tret = i9xx_check_lut_10(i915, crtc_state->hw.gamma_lut);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tret = intel_color_add_affected_planes(crtc_state);\n\tif (ret)\n\t\treturn ret;\n\n\tintel_assign_luts(crtc_state);\n\n\tcrtc_state->preload_luts = intel_can_preload_luts(crtc_state);\n\n\treturn 0;\n}\n\n \nstatic int vlv_color_check(struct intel_crtc_state *crtc_state)\n{\n\tint ret;\n\n\tret = check_luts(crtc_state);\n\tif (ret)\n\t\treturn ret;\n\n\tcrtc_state->gamma_enable =\n\t\tcrtc_state->hw.gamma_lut &&\n\t\t!crtc_state->c8_planes;\n\n\tcrtc_state->gamma_mode = i9xx_gamma_mode(crtc_state);\n\n\tcrtc_state->wgc_enable = crtc_state->hw.ctm;\n\n\tret = intel_color_add_affected_planes(crtc_state);\n\tif (ret)\n\t\treturn ret;\n\n\tintel_assign_luts(crtc_state);\n\n\tvlv_assign_csc(crtc_state);\n\n\tcrtc_state->preload_luts = vlv_can_preload_luts(crtc_state);\n\n\treturn 0;\n}\n\nstatic u32 chv_cgm_mode(const struct intel_crtc_state *crtc_state)\n{\n\tu32 cgm_mode = 0;\n\n\tif (crtc_state->hw.degamma_lut)\n\t\tcgm_mode |= CGM_PIPE_MODE_DEGAMMA;\n\tif (crtc_state->hw.ctm)\n\t\tcgm_mode |= CGM_PIPE_MODE_CSC;\n\tif (crtc_state->hw.gamma_lut &&\n\t    !lut_is_legacy(crtc_state->hw.gamma_lut))\n\t\tcgm_mode |= CGM_PIPE_MODE_GAMMA;\n\n\t \n\tcgm_mode |= CGM_PIPE_MODE_CSC;\n\n\treturn cgm_mode;\n}\n\n \nstatic int chv_color_check(struct intel_crtc_state *crtc_state)\n{\n\tint ret;\n\n\tret = check_luts(crtc_state);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tcrtc_state->gamma_enable =\n\t\tlut_is_legacy(crtc_state->hw.gamma_lut) &&\n\t\t!crtc_state->c8_planes;\n\n\tcrtc_state->gamma_mode = GAMMA_MODE_MODE_8BIT;\n\n\tcrtc_state->cgm_mode = chv_cgm_mode(crtc_state);\n\n\t \n\tcrtc_state->wgc_enable = false;\n\n\tret = intel_color_add_affected_planes(crtc_state);\n\tif (ret)\n\t\treturn ret;\n\n\tintel_assign_luts(crtc_state);\n\n\tchv_assign_csc(crtc_state);\n\n\tcrtc_state->preload_luts = chv_can_preload_luts(crtc_state);\n\n\treturn 0;\n}\n\nstatic bool ilk_gamma_enable(const struct intel_crtc_state *crtc_state)\n{\n\treturn (crtc_state->hw.gamma_lut ||\n\t\tcrtc_state->hw.degamma_lut) &&\n\t\t!crtc_state->c8_planes;\n}\n\nstatic bool ilk_csc_enable(const struct intel_crtc_state *crtc_state)\n{\n\treturn crtc_state->output_format != INTEL_OUTPUT_FORMAT_RGB ||\n\t\tilk_csc_limited_range(crtc_state) ||\n\t\tcrtc_state->hw.ctm;\n}\n\nstatic u32 ilk_gamma_mode(const struct intel_crtc_state *crtc_state)\n{\n\tif (!crtc_state->gamma_enable ||\n\t    lut_is_legacy(crtc_state->hw.gamma_lut))\n\t\treturn GAMMA_MODE_MODE_8BIT;\n\telse\n\t\treturn GAMMA_MODE_MODE_10BIT;\n}\n\nstatic u32 ilk_csc_mode(const struct intel_crtc_state *crtc_state)\n{\n\t \n\tif (crtc_state->output_format != INTEL_OUTPUT_FORMAT_RGB)\n\t\treturn CSC_BLACK_SCREEN_OFFSET;\n\n\tif (crtc_state->hw.degamma_lut)\n\t\treturn CSC_MODE_YUV_TO_RGB;\n\n\treturn CSC_MODE_YUV_TO_RGB |\n\t\tCSC_POSITION_BEFORE_GAMMA;\n}\n\nstatic int ilk_assign_luts(struct intel_crtc_state *crtc_state)\n{\n\tstruct drm_i915_private *i915 = to_i915(crtc_state->uapi.crtc->dev);\n\n\tif (ilk_lut_limited_range(crtc_state)) {\n\t\tstruct drm_property_blob *gamma_lut;\n\n\t\tgamma_lut = create_resized_lut(i915, crtc_state->hw.gamma_lut,\n\t\t\t\t\t       drm_color_lut_size(crtc_state->hw.gamma_lut),\n\t\t\t\t\t       true);\n\t\tif (IS_ERR(gamma_lut))\n\t\t\treturn PTR_ERR(gamma_lut);\n\n\t\tdrm_property_replace_blob(&crtc_state->post_csc_lut, gamma_lut);\n\n\t\tdrm_property_blob_put(gamma_lut);\n\n\t\tdrm_property_replace_blob(&crtc_state->pre_csc_lut, crtc_state->hw.degamma_lut);\n\n\t\treturn 0;\n\t}\n\n\tif (crtc_state->hw.degamma_lut ||\n\t    crtc_state->csc_mode & CSC_POSITION_BEFORE_GAMMA) {\n\t\tdrm_property_replace_blob(&crtc_state->pre_csc_lut,\n\t\t\t\t\t  crtc_state->hw.degamma_lut);\n\t\tdrm_property_replace_blob(&crtc_state->post_csc_lut,\n\t\t\t\t\t  crtc_state->hw.gamma_lut);\n\t} else {\n\t\tdrm_property_replace_blob(&crtc_state->pre_csc_lut,\n\t\t\t\t\t  crtc_state->hw.gamma_lut);\n\t\tdrm_property_replace_blob(&crtc_state->post_csc_lut,\n\t\t\t\t\t  NULL);\n\t}\n\n\treturn 0;\n}\n\nstatic int ilk_color_check(struct intel_crtc_state *crtc_state)\n{\n\tstruct drm_i915_private *i915 = to_i915(crtc_state->uapi.crtc->dev);\n\tint ret;\n\n\tret = check_luts(crtc_state);\n\tif (ret)\n\t\treturn ret;\n\n\tif (crtc_state->hw.degamma_lut && crtc_state->hw.gamma_lut) {\n\t\tdrm_dbg_kms(&i915->drm,\n\t\t\t    \"Degamma and gamma together are not possible\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (crtc_state->output_format != INTEL_OUTPUT_FORMAT_RGB &&\n\t    crtc_state->hw.ctm) {\n\t\tdrm_dbg_kms(&i915->drm,\n\t\t\t    \"YCbCr and CTM together are not possible\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tcrtc_state->gamma_enable = ilk_gamma_enable(crtc_state);\n\n\tcrtc_state->csc_enable = ilk_csc_enable(crtc_state);\n\n\tcrtc_state->gamma_mode = ilk_gamma_mode(crtc_state);\n\n\tcrtc_state->csc_mode = ilk_csc_mode(crtc_state);\n\n\tret = intel_color_add_affected_planes(crtc_state);\n\tif (ret)\n\t\treturn ret;\n\n\tret = ilk_assign_luts(crtc_state);\n\tif (ret)\n\t\treturn ret;\n\n\tilk_assign_csc(crtc_state);\n\n\tcrtc_state->preload_luts = intel_can_preload_luts(crtc_state);\n\n\treturn 0;\n}\n\nstatic u32 ivb_gamma_mode(const struct intel_crtc_state *crtc_state)\n{\n\tif (crtc_state->hw.degamma_lut && crtc_state->hw.gamma_lut)\n\t\treturn GAMMA_MODE_MODE_SPLIT;\n\n\treturn ilk_gamma_mode(crtc_state);\n}\n\nstatic u32 ivb_csc_mode(const struct intel_crtc_state *crtc_state)\n{\n\tbool limited_color_range = ilk_csc_limited_range(crtc_state);\n\n\t \n\tif (crtc_state->hw.degamma_lut ||\n\t    crtc_state->output_format != INTEL_OUTPUT_FORMAT_RGB ||\n\t    limited_color_range)\n\t\treturn 0;\n\n\treturn CSC_POSITION_BEFORE_GAMMA;\n}\n\nstatic int ivb_assign_luts(struct intel_crtc_state *crtc_state)\n{\n\tstruct drm_i915_private *i915 = to_i915(crtc_state->uapi.crtc->dev);\n\tstruct drm_property_blob *degamma_lut, *gamma_lut;\n\n\tif (crtc_state->gamma_mode != GAMMA_MODE_MODE_SPLIT)\n\t\treturn ilk_assign_luts(crtc_state);\n\n\tdrm_WARN_ON(&i915->drm, drm_color_lut_size(crtc_state->hw.degamma_lut) != 1024);\n\tdrm_WARN_ON(&i915->drm, drm_color_lut_size(crtc_state->hw.gamma_lut) != 1024);\n\n\tdegamma_lut = create_resized_lut(i915, crtc_state->hw.degamma_lut, 512,\n\t\t\t\t\t false);\n\tif (IS_ERR(degamma_lut))\n\t\treturn PTR_ERR(degamma_lut);\n\n\tgamma_lut = create_resized_lut(i915, crtc_state->hw.gamma_lut, 512,\n\t\t\t\t       ilk_lut_limited_range(crtc_state));\n\tif (IS_ERR(gamma_lut)) {\n\t\tdrm_property_blob_put(degamma_lut);\n\t\treturn PTR_ERR(gamma_lut);\n\t}\n\n\tdrm_property_replace_blob(&crtc_state->pre_csc_lut, degamma_lut);\n\tdrm_property_replace_blob(&crtc_state->post_csc_lut, gamma_lut);\n\n\tdrm_property_blob_put(degamma_lut);\n\tdrm_property_blob_put(gamma_lut);\n\n\treturn 0;\n}\n\nstatic int ivb_color_check(struct intel_crtc_state *crtc_state)\n{\n\tstruct drm_i915_private *i915 = to_i915(crtc_state->uapi.crtc->dev);\n\tint ret;\n\n\tret = check_luts(crtc_state);\n\tif (ret)\n\t\treturn ret;\n\n\tif (crtc_state->c8_planes && crtc_state->hw.degamma_lut) {\n\t\tdrm_dbg_kms(&i915->drm,\n\t\t\t    \"C8 pixelformat and degamma together are not possible\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (crtc_state->output_format != INTEL_OUTPUT_FORMAT_RGB &&\n\t    crtc_state->hw.ctm) {\n\t\tdrm_dbg_kms(&i915->drm,\n\t\t\t    \"YCbCr and CTM together are not possible\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (crtc_state->output_format != INTEL_OUTPUT_FORMAT_RGB &&\n\t    crtc_state->hw.degamma_lut && crtc_state->hw.gamma_lut) {\n\t\tdrm_dbg_kms(&i915->drm,\n\t\t\t    \"YCbCr and degamma+gamma together are not possible\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tcrtc_state->gamma_enable = ilk_gamma_enable(crtc_state);\n\n\tcrtc_state->csc_enable = ilk_csc_enable(crtc_state);\n\n\tcrtc_state->gamma_mode = ivb_gamma_mode(crtc_state);\n\n\tcrtc_state->csc_mode = ivb_csc_mode(crtc_state);\n\n\tret = intel_color_add_affected_planes(crtc_state);\n\tif (ret)\n\t\treturn ret;\n\n\tret = ivb_assign_luts(crtc_state);\n\tif (ret)\n\t\treturn ret;\n\n\tilk_assign_csc(crtc_state);\n\n\tcrtc_state->preload_luts = intel_can_preload_luts(crtc_state);\n\n\treturn 0;\n}\n\nstatic u32 glk_gamma_mode(const struct intel_crtc_state *crtc_state)\n{\n\tif (!crtc_state->gamma_enable ||\n\t    lut_is_legacy(crtc_state->hw.gamma_lut))\n\t\treturn GAMMA_MODE_MODE_8BIT;\n\telse\n\t\treturn GAMMA_MODE_MODE_10BIT;\n}\n\nstatic bool glk_use_pre_csc_lut_for_gamma(const struct intel_crtc_state *crtc_state)\n{\n\treturn crtc_state->hw.gamma_lut &&\n\t\t!crtc_state->c8_planes &&\n\t\tcrtc_state->output_format != INTEL_OUTPUT_FORMAT_RGB;\n}\n\nstatic int glk_assign_luts(struct intel_crtc_state *crtc_state)\n{\n\tstruct drm_i915_private *i915 = to_i915(crtc_state->uapi.crtc->dev);\n\n\tif (glk_use_pre_csc_lut_for_gamma(crtc_state)) {\n\t\tstruct drm_property_blob *gamma_lut;\n\n\t\tgamma_lut = create_resized_lut(i915, crtc_state->hw.gamma_lut,\n\t\t\t\t\t       DISPLAY_INFO(i915)->color.degamma_lut_size,\n\t\t\t\t\t       false);\n\t\tif (IS_ERR(gamma_lut))\n\t\t\treturn PTR_ERR(gamma_lut);\n\n\t\tdrm_property_replace_blob(&crtc_state->pre_csc_lut, gamma_lut);\n\t\tdrm_property_replace_blob(&crtc_state->post_csc_lut, NULL);\n\n\t\tdrm_property_blob_put(gamma_lut);\n\n\t\treturn 0;\n\t}\n\n\tif (ilk_lut_limited_range(crtc_state)) {\n\t\tstruct drm_property_blob *gamma_lut;\n\n\t\tgamma_lut = create_resized_lut(i915, crtc_state->hw.gamma_lut,\n\t\t\t\t\t       drm_color_lut_size(crtc_state->hw.gamma_lut),\n\t\t\t\t\t       true);\n\t\tif (IS_ERR(gamma_lut))\n\t\t\treturn PTR_ERR(gamma_lut);\n\n\t\tdrm_property_replace_blob(&crtc_state->post_csc_lut, gamma_lut);\n\n\t\tdrm_property_blob_put(gamma_lut);\n\t} else {\n\t\tdrm_property_replace_blob(&crtc_state->post_csc_lut, crtc_state->hw.gamma_lut);\n\t}\n\n\tdrm_property_replace_blob(&crtc_state->pre_csc_lut, crtc_state->hw.degamma_lut);\n\n\t \n\tif (crtc_state->csc_enable && !crtc_state->pre_csc_lut)\n\t\tdrm_property_replace_blob(&crtc_state->pre_csc_lut,\n\t\t\t\t\t  i915->display.color.glk_linear_degamma_lut);\n\n\treturn 0;\n}\n\nstatic int glk_check_luts(const struct intel_crtc_state *crtc_state)\n{\n\tu32 degamma_tests = intel_degamma_lut_tests(crtc_state);\n\tu32 gamma_tests = intel_gamma_lut_tests(crtc_state);\n\n\tif (glk_use_pre_csc_lut_for_gamma(crtc_state))\n\t\tgamma_tests |= degamma_tests;\n\n\treturn _check_luts(crtc_state, degamma_tests, gamma_tests);\n}\n\nstatic int glk_color_check(struct intel_crtc_state *crtc_state)\n{\n\tstruct drm_i915_private *i915 = to_i915(crtc_state->uapi.crtc->dev);\n\tint ret;\n\n\tret = glk_check_luts(crtc_state);\n\tif (ret)\n\t\treturn ret;\n\n\tif (crtc_state->output_format != INTEL_OUTPUT_FORMAT_RGB &&\n\t    crtc_state->hw.ctm) {\n\t\tdrm_dbg_kms(&i915->drm,\n\t\t\t    \"YCbCr and CTM together are not possible\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (crtc_state->output_format != INTEL_OUTPUT_FORMAT_RGB &&\n\t    crtc_state->hw.degamma_lut && crtc_state->hw.gamma_lut) {\n\t\tdrm_dbg_kms(&i915->drm,\n\t\t\t    \"YCbCr and degamma+gamma together are not possible\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tcrtc_state->gamma_enable =\n\t\t!glk_use_pre_csc_lut_for_gamma(crtc_state) &&\n\t\tcrtc_state->hw.gamma_lut &&\n\t\t!crtc_state->c8_planes;\n\n\t \n\tcrtc_state->csc_enable =\n\t\tglk_use_pre_csc_lut_for_gamma(crtc_state) ||\n\t\tcrtc_state->hw.degamma_lut ||\n\t\tcrtc_state->output_format != INTEL_OUTPUT_FORMAT_RGB ||\n\t\tcrtc_state->hw.ctm || ilk_csc_limited_range(crtc_state);\n\n\tcrtc_state->gamma_mode = glk_gamma_mode(crtc_state);\n\n\tcrtc_state->csc_mode = 0;\n\n\tret = intel_color_add_affected_planes(crtc_state);\n\tif (ret)\n\t\treturn ret;\n\n\tret = glk_assign_luts(crtc_state);\n\tif (ret)\n\t\treturn ret;\n\n\tilk_assign_csc(crtc_state);\n\n\tcrtc_state->preload_luts = intel_can_preload_luts(crtc_state);\n\n\treturn 0;\n}\n\nstatic u32 icl_gamma_mode(const struct intel_crtc_state *crtc_state)\n{\n\tstruct intel_crtc *crtc = to_intel_crtc(crtc_state->uapi.crtc);\n\tstruct drm_i915_private *i915 = to_i915(crtc->base.dev);\n\tu32 gamma_mode = 0;\n\n\tif (crtc_state->hw.degamma_lut)\n\t\tgamma_mode |= PRE_CSC_GAMMA_ENABLE;\n\n\tif (crtc_state->hw.gamma_lut &&\n\t    !crtc_state->c8_planes)\n\t\tgamma_mode |= POST_CSC_GAMMA_ENABLE;\n\n\tif (!crtc_state->hw.gamma_lut ||\n\t    lut_is_legacy(crtc_state->hw.gamma_lut))\n\t\tgamma_mode |= GAMMA_MODE_MODE_8BIT;\n\t \n\telse if (DISPLAY_VER(i915) >= 13)\n\t\tgamma_mode |= GAMMA_MODE_MODE_10BIT;\n\telse\n\t\tgamma_mode |= GAMMA_MODE_MODE_12BIT_MULTI_SEG;\n\n\treturn gamma_mode;\n}\n\nstatic u32 icl_csc_mode(const struct intel_crtc_state *crtc_state)\n{\n\tu32 csc_mode = 0;\n\n\tif (crtc_state->hw.ctm)\n\t\tcsc_mode |= ICL_CSC_ENABLE;\n\n\tif (crtc_state->output_format != INTEL_OUTPUT_FORMAT_RGB ||\n\t    crtc_state->limited_color_range)\n\t\tcsc_mode |= ICL_OUTPUT_CSC_ENABLE;\n\n\treturn csc_mode;\n}\n\nstatic int icl_color_check(struct intel_crtc_state *crtc_state)\n{\n\tint ret;\n\n\tret = check_luts(crtc_state);\n\tif (ret)\n\t\treturn ret;\n\n\tcrtc_state->gamma_mode = icl_gamma_mode(crtc_state);\n\n\tcrtc_state->csc_mode = icl_csc_mode(crtc_state);\n\n\tintel_assign_luts(crtc_state);\n\n\ticl_assign_csc(crtc_state);\n\n\tcrtc_state->preload_luts = intel_can_preload_luts(crtc_state);\n\n\treturn 0;\n}\n\nstatic int i9xx_post_csc_lut_precision(const struct intel_crtc_state *crtc_state)\n{\n\tif (!crtc_state->gamma_enable && !crtc_state->c8_planes)\n\t\treturn 0;\n\n\tswitch (crtc_state->gamma_mode) {\n\tcase GAMMA_MODE_MODE_8BIT:\n\t\treturn 8;\n\tcase GAMMA_MODE_MODE_10BIT:\n\t\treturn 10;\n\tdefault:\n\t\tMISSING_CASE(crtc_state->gamma_mode);\n\t\treturn 0;\n\t}\n}\n\nstatic int i9xx_pre_csc_lut_precision(const struct intel_crtc_state *crtc_state)\n{\n\treturn 0;\n}\n\nstatic int i965_post_csc_lut_precision(const struct intel_crtc_state *crtc_state)\n{\n\tif (!crtc_state->gamma_enable && !crtc_state->c8_planes)\n\t\treturn 0;\n\n\tswitch (crtc_state->gamma_mode) {\n\tcase GAMMA_MODE_MODE_8BIT:\n\t\treturn 8;\n\tcase GAMMA_MODE_MODE_10BIT:\n\t\treturn 16;\n\tdefault:\n\t\tMISSING_CASE(crtc_state->gamma_mode);\n\t\treturn 0;\n\t}\n}\n\nstatic int ilk_gamma_mode_precision(u32 gamma_mode)\n{\n\tswitch (gamma_mode) {\n\tcase GAMMA_MODE_MODE_8BIT:\n\t\treturn 8;\n\tcase GAMMA_MODE_MODE_10BIT:\n\t\treturn 10;\n\tdefault:\n\t\tMISSING_CASE(gamma_mode);\n\t\treturn 0;\n\t}\n}\n\nstatic bool ilk_has_post_csc_lut(const struct intel_crtc_state *crtc_state)\n{\n\tif (crtc_state->c8_planes)\n\t\treturn true;\n\n\treturn crtc_state->gamma_enable &&\n\t\t(crtc_state->csc_mode & CSC_POSITION_BEFORE_GAMMA) != 0;\n}\n\nstatic bool ilk_has_pre_csc_lut(const struct intel_crtc_state *crtc_state)\n{\n\treturn crtc_state->gamma_enable &&\n\t\t(crtc_state->csc_mode & CSC_POSITION_BEFORE_GAMMA) == 0;\n}\n\nstatic int ilk_post_csc_lut_precision(const struct intel_crtc_state *crtc_state)\n{\n\tif (!ilk_has_post_csc_lut(crtc_state))\n\t\treturn 0;\n\n\treturn ilk_gamma_mode_precision(crtc_state->gamma_mode);\n}\n\nstatic int ilk_pre_csc_lut_precision(const struct intel_crtc_state *crtc_state)\n{\n\tif (!ilk_has_pre_csc_lut(crtc_state))\n\t\treturn 0;\n\n\treturn ilk_gamma_mode_precision(crtc_state->gamma_mode);\n}\n\nstatic int ivb_post_csc_lut_precision(const struct intel_crtc_state *crtc_state)\n{\n\tif (crtc_state->gamma_enable &&\n\t    crtc_state->gamma_mode == GAMMA_MODE_MODE_SPLIT)\n\t\treturn 10;\n\n\treturn ilk_post_csc_lut_precision(crtc_state);\n}\n\nstatic int ivb_pre_csc_lut_precision(const struct intel_crtc_state *crtc_state)\n{\n\tif (crtc_state->gamma_enable &&\n\t    crtc_state->gamma_mode == GAMMA_MODE_MODE_SPLIT)\n\t\treturn 10;\n\n\treturn ilk_pre_csc_lut_precision(crtc_state);\n}\n\nstatic int chv_post_csc_lut_precision(const struct intel_crtc_state *crtc_state)\n{\n\tif (crtc_state->cgm_mode & CGM_PIPE_MODE_GAMMA)\n\t\treturn 10;\n\n\treturn i965_post_csc_lut_precision(crtc_state);\n}\n\nstatic int chv_pre_csc_lut_precision(const struct intel_crtc_state *crtc_state)\n{\n\tif (crtc_state->cgm_mode & CGM_PIPE_MODE_DEGAMMA)\n\t\treturn 14;\n\n\treturn 0;\n}\n\nstatic int glk_post_csc_lut_precision(const struct intel_crtc_state *crtc_state)\n{\n\tif (!crtc_state->gamma_enable && !crtc_state->c8_planes)\n\t\treturn 0;\n\n\treturn ilk_gamma_mode_precision(crtc_state->gamma_mode);\n}\n\nstatic int glk_pre_csc_lut_precision(const struct intel_crtc_state *crtc_state)\n{\n\tif (!crtc_state->csc_enable)\n\t\treturn 0;\n\n\treturn 16;\n}\n\nstatic bool icl_has_post_csc_lut(const struct intel_crtc_state *crtc_state)\n{\n\tif (crtc_state->c8_planes)\n\t\treturn true;\n\n\treturn crtc_state->gamma_mode & POST_CSC_GAMMA_ENABLE;\n}\n\nstatic bool icl_has_pre_csc_lut(const struct intel_crtc_state *crtc_state)\n{\n\treturn crtc_state->gamma_mode & PRE_CSC_GAMMA_ENABLE;\n}\n\nstatic int icl_post_csc_lut_precision(const struct intel_crtc_state *crtc_state)\n{\n\tif (!icl_has_post_csc_lut(crtc_state))\n\t\treturn 0;\n\n\tswitch (crtc_state->gamma_mode & GAMMA_MODE_MODE_MASK) {\n\tcase GAMMA_MODE_MODE_8BIT:\n\t\treturn 8;\n\tcase GAMMA_MODE_MODE_10BIT:\n\t\treturn 10;\n\tcase GAMMA_MODE_MODE_12BIT_MULTI_SEG:\n\t\treturn 16;\n\tdefault:\n\t\tMISSING_CASE(crtc_state->gamma_mode);\n\t\treturn 0;\n\t}\n}\n\nstatic int icl_pre_csc_lut_precision(const struct intel_crtc_state *crtc_state)\n{\n\tif (!icl_has_pre_csc_lut(crtc_state))\n\t\treturn 0;\n\n\treturn 16;\n}\n\nstatic bool err_check(struct drm_color_lut *lut1,\n\t\t      struct drm_color_lut *lut2, u32 err)\n{\n\treturn ((abs((long)lut2->red - lut1->red)) <= err) &&\n\t\t((abs((long)lut2->blue - lut1->blue)) <= err) &&\n\t\t((abs((long)lut2->green - lut1->green)) <= err);\n}\n\nstatic bool intel_lut_entries_equal(struct drm_color_lut *lut1,\n\t\t\t\t    struct drm_color_lut *lut2,\n\t\t\t\t    int lut_size, u32 err)\n{\n\tint i;\n\n\tfor (i = 0; i < lut_size; i++) {\n\t\tif (!err_check(&lut1[i], &lut2[i], err))\n\t\t\treturn false;\n\t}\n\n\treturn true;\n}\n\nstatic bool intel_lut_equal(const struct drm_property_blob *blob1,\n\t\t\t    const struct drm_property_blob *blob2,\n\t\t\t    int check_size, int precision)\n{\n\tstruct drm_color_lut *lut1, *lut2;\n\tint lut_size1, lut_size2;\n\tu32 err;\n\n\tif (!blob1 != !blob2)\n\t\treturn false;\n\n\tif (!blob1 != !precision)\n\t\treturn false;\n\n\tif (!blob1)\n\t\treturn true;\n\n\tlut_size1 = drm_color_lut_size(blob1);\n\tlut_size2 = drm_color_lut_size(blob2);\n\n\tif (lut_size1 != lut_size2)\n\t\treturn false;\n\n\tif (check_size > lut_size1)\n\t\treturn false;\n\n\tlut1 = blob1->data;\n\tlut2 = blob2->data;\n\n\terr = 0xffff >> precision;\n\n\tif (!check_size)\n\t\tcheck_size = lut_size1;\n\n\treturn intel_lut_entries_equal(lut1, lut2, check_size, err);\n}\n\nstatic bool i9xx_lut_equal(const struct intel_crtc_state *crtc_state,\n\t\t\t   const struct drm_property_blob *blob1,\n\t\t\t   const struct drm_property_blob *blob2,\n\t\t\t   bool is_pre_csc_lut)\n{\n\tint check_size = 0;\n\n\tif (is_pre_csc_lut)\n\t\treturn intel_lut_equal(blob1, blob2, 0,\n\t\t\t\t       i9xx_pre_csc_lut_precision(crtc_state));\n\n\t \n\tif (crtc_state->gamma_mode == GAMMA_MODE_MODE_10BIT)\n\t\tcheck_size = 128;\n\n\treturn intel_lut_equal(blob1, blob2, check_size,\n\t\t\t       i9xx_post_csc_lut_precision(crtc_state));\n}\n\nstatic bool i965_lut_equal(const struct intel_crtc_state *crtc_state,\n\t\t\t   const struct drm_property_blob *blob1,\n\t\t\t   const struct drm_property_blob *blob2,\n\t\t\t   bool is_pre_csc_lut)\n{\n\tif (is_pre_csc_lut)\n\t\treturn intel_lut_equal(blob1, blob2, 0,\n\t\t\t\t       i9xx_pre_csc_lut_precision(crtc_state));\n\telse\n\t\treturn intel_lut_equal(blob1, blob2, 0,\n\t\t\t\t       i965_post_csc_lut_precision(crtc_state));\n}\n\nstatic bool chv_lut_equal(const struct intel_crtc_state *crtc_state,\n\t\t\t  const struct drm_property_blob *blob1,\n\t\t\t  const struct drm_property_blob *blob2,\n\t\t\t  bool is_pre_csc_lut)\n{\n\tif (is_pre_csc_lut)\n\t\treturn intel_lut_equal(blob1, blob2, 0,\n\t\t\t\t       chv_pre_csc_lut_precision(crtc_state));\n\telse\n\t\treturn intel_lut_equal(blob1, blob2, 0,\n\t\t\t\t       chv_post_csc_lut_precision(crtc_state));\n}\n\nstatic bool ilk_lut_equal(const struct intel_crtc_state *crtc_state,\n\t\t\t  const struct drm_property_blob *blob1,\n\t\t\t  const struct drm_property_blob *blob2,\n\t\t\t  bool is_pre_csc_lut)\n{\n\tif (is_pre_csc_lut)\n\t\treturn intel_lut_equal(blob1, blob2, 0,\n\t\t\t\t       ilk_pre_csc_lut_precision(crtc_state));\n\telse\n\t\treturn intel_lut_equal(blob1, blob2, 0,\n\t\t\t\t       ilk_post_csc_lut_precision(crtc_state));\n}\n\nstatic bool ivb_lut_equal(const struct intel_crtc_state *crtc_state,\n\t\t\t  const struct drm_property_blob *blob1,\n\t\t\t  const struct drm_property_blob *blob2,\n\t\t\t  bool is_pre_csc_lut)\n{\n\tif (is_pre_csc_lut)\n\t\treturn intel_lut_equal(blob1, blob2, 0,\n\t\t\t\t       ivb_pre_csc_lut_precision(crtc_state));\n\telse\n\t\treturn intel_lut_equal(blob1, blob2, 0,\n\t\t\t\t       ivb_post_csc_lut_precision(crtc_state));\n}\n\nstatic bool glk_lut_equal(const struct intel_crtc_state *crtc_state,\n\t\t\t  const struct drm_property_blob *blob1,\n\t\t\t  const struct drm_property_blob *blob2,\n\t\t\t  bool is_pre_csc_lut)\n{\n\tif (is_pre_csc_lut)\n\t\treturn intel_lut_equal(blob1, blob2, 0,\n\t\t\t\t       glk_pre_csc_lut_precision(crtc_state));\n\telse\n\t\treturn intel_lut_equal(blob1, blob2, 0,\n\t\t\t\t       glk_post_csc_lut_precision(crtc_state));\n}\n\nstatic bool icl_lut_equal(const struct intel_crtc_state *crtc_state,\n\t\t\t  const struct drm_property_blob *blob1,\n\t\t\t  const struct drm_property_blob *blob2,\n\t\t\t  bool is_pre_csc_lut)\n{\n\tint check_size = 0;\n\n\tif (is_pre_csc_lut)\n\t\treturn intel_lut_equal(blob1, blob2, 0,\n\t\t\t\t       icl_pre_csc_lut_precision(crtc_state));\n\n\t \n\tif ((crtc_state->gamma_mode & GAMMA_MODE_MODE_MASK) ==\n\t    GAMMA_MODE_MODE_12BIT_MULTI_SEG)\n\t\tcheck_size = 9;\n\n\treturn intel_lut_equal(blob1, blob2, check_size,\n\t\t\t       icl_post_csc_lut_precision(crtc_state));\n}\n\nstatic struct drm_property_blob *i9xx_read_lut_8(struct intel_crtc *crtc)\n{\n\tstruct drm_i915_private *dev_priv = to_i915(crtc->base.dev);\n\tenum pipe pipe = crtc->pipe;\n\tstruct drm_property_blob *blob;\n\tstruct drm_color_lut *lut;\n\tint i;\n\n\tblob = drm_property_create_blob(&dev_priv->drm,\n\t\t\t\t\tsizeof(lut[0]) * LEGACY_LUT_LENGTH,\n\t\t\t\t\tNULL);\n\tif (IS_ERR(blob))\n\t\treturn NULL;\n\n\tlut = blob->data;\n\n\tfor (i = 0; i < LEGACY_LUT_LENGTH; i++) {\n\t\tu32 val = intel_de_read_fw(dev_priv, PALETTE(pipe, i));\n\n\t\ti9xx_lut_8_pack(&lut[i], val);\n\t}\n\n\treturn blob;\n}\n\nstatic struct drm_property_blob *i9xx_read_lut_10(struct intel_crtc *crtc)\n{\n\tstruct drm_i915_private *dev_priv = to_i915(crtc->base.dev);\n\tu32 lut_size = DISPLAY_INFO(dev_priv)->color.gamma_lut_size;\n\tenum pipe pipe = crtc->pipe;\n\tstruct drm_property_blob *blob;\n\tstruct drm_color_lut *lut;\n\tu32 ldw, udw;\n\tint i;\n\n\tblob = drm_property_create_blob(&dev_priv->drm,\n\t\t\t\t\tlut_size * sizeof(lut[0]), NULL);\n\tif (IS_ERR(blob))\n\t\treturn NULL;\n\n\tlut = blob->data;\n\n\tfor (i = 0; i < lut_size - 1; i++) {\n\t\tldw = intel_de_read_fw(dev_priv, PALETTE(pipe, 2 * i + 0));\n\t\tudw = intel_de_read_fw(dev_priv, PALETTE(pipe, 2 * i + 1));\n\n\t\ti9xx_lut_10_pack(&lut[i], ldw, udw);\n\t}\n\n\ti9xx_lut_10_pack_slope(&lut[i], ldw, udw);\n\n\treturn blob;\n}\n\nstatic void i9xx_read_luts(struct intel_crtc_state *crtc_state)\n{\n\tstruct intel_crtc *crtc = to_intel_crtc(crtc_state->uapi.crtc);\n\n\tif (!crtc_state->gamma_enable && !crtc_state->c8_planes)\n\t\treturn;\n\n\tswitch (crtc_state->gamma_mode) {\n\tcase GAMMA_MODE_MODE_8BIT:\n\t\tcrtc_state->post_csc_lut = i9xx_read_lut_8(crtc);\n\t\tbreak;\n\tcase GAMMA_MODE_MODE_10BIT:\n\t\tcrtc_state->post_csc_lut = i9xx_read_lut_10(crtc);\n\t\tbreak;\n\tdefault:\n\t\tMISSING_CASE(crtc_state->gamma_mode);\n\t\tbreak;\n\t}\n}\n\nstatic struct drm_property_blob *i965_read_lut_10p6(struct intel_crtc *crtc)\n{\n\tstruct drm_i915_private *dev_priv = to_i915(crtc->base.dev);\n\tint i, lut_size = DISPLAY_INFO(dev_priv)->color.gamma_lut_size;\n\tenum pipe pipe = crtc->pipe;\n\tstruct drm_property_blob *blob;\n\tstruct drm_color_lut *lut;\n\n\tblob = drm_property_create_blob(&dev_priv->drm,\n\t\t\t\t\tsizeof(lut[0]) * lut_size,\n\t\t\t\t\tNULL);\n\tif (IS_ERR(blob))\n\t\treturn NULL;\n\n\tlut = blob->data;\n\n\tfor (i = 0; i < lut_size - 1; i++) {\n\t\tu32 ldw = intel_de_read_fw(dev_priv, PALETTE(pipe, 2 * i + 0));\n\t\tu32 udw = intel_de_read_fw(dev_priv, PALETTE(pipe, 2 * i + 1));\n\n\t\ti965_lut_10p6_pack(&lut[i], ldw, udw);\n\t}\n\n\tlut[i].red = i965_lut_11p6_max_pack(intel_de_read_fw(dev_priv, PIPEGCMAX(pipe, 0)));\n\tlut[i].green = i965_lut_11p6_max_pack(intel_de_read_fw(dev_priv, PIPEGCMAX(pipe, 1)));\n\tlut[i].blue = i965_lut_11p6_max_pack(intel_de_read_fw(dev_priv, PIPEGCMAX(pipe, 2)));\n\n\treturn blob;\n}\n\nstatic void i965_read_luts(struct intel_crtc_state *crtc_state)\n{\n\tstruct intel_crtc *crtc = to_intel_crtc(crtc_state->uapi.crtc);\n\n\tif (!crtc_state->gamma_enable && !crtc_state->c8_planes)\n\t\treturn;\n\n\tswitch (crtc_state->gamma_mode) {\n\tcase GAMMA_MODE_MODE_8BIT:\n\t\tcrtc_state->post_csc_lut = i9xx_read_lut_8(crtc);\n\t\tbreak;\n\tcase GAMMA_MODE_MODE_10BIT:\n\t\tcrtc_state->post_csc_lut = i965_read_lut_10p6(crtc);\n\t\tbreak;\n\tdefault:\n\t\tMISSING_CASE(crtc_state->gamma_mode);\n\t\tbreak;\n\t}\n}\n\nstatic struct drm_property_blob *chv_read_cgm_degamma(struct intel_crtc *crtc)\n{\n\tstruct drm_i915_private *dev_priv = to_i915(crtc->base.dev);\n\tint i, lut_size = DISPLAY_INFO(dev_priv)->color.degamma_lut_size;\n\tenum pipe pipe = crtc->pipe;\n\tstruct drm_property_blob *blob;\n\tstruct drm_color_lut *lut;\n\n\tblob = drm_property_create_blob(&dev_priv->drm,\n\t\t\t\t\tsizeof(lut[0]) * lut_size,\n\t\t\t\t\tNULL);\n\tif (IS_ERR(blob))\n\t\treturn NULL;\n\n\tlut = blob->data;\n\n\tfor (i = 0; i < lut_size; i++) {\n\t\tu32 ldw = intel_de_read_fw(dev_priv, CGM_PIPE_DEGAMMA(pipe, i, 0));\n\t\tu32 udw = intel_de_read_fw(dev_priv, CGM_PIPE_DEGAMMA(pipe, i, 1));\n\n\t\tchv_cgm_degamma_pack(&lut[i], ldw, udw);\n\t}\n\n\treturn blob;\n}\n\nstatic struct drm_property_blob *chv_read_cgm_gamma(struct intel_crtc *crtc)\n{\n\tstruct drm_i915_private *i915 = to_i915(crtc->base.dev);\n\tint i, lut_size = DISPLAY_INFO(i915)->color.gamma_lut_size;\n\tenum pipe pipe = crtc->pipe;\n\tstruct drm_property_blob *blob;\n\tstruct drm_color_lut *lut;\n\n\tblob = drm_property_create_blob(&i915->drm,\n\t\t\t\t\tsizeof(lut[0]) * lut_size,\n\t\t\t\t\tNULL);\n\tif (IS_ERR(blob))\n\t\treturn NULL;\n\n\tlut = blob->data;\n\n\tfor (i = 0; i < lut_size; i++) {\n\t\tu32 ldw = intel_de_read_fw(i915, CGM_PIPE_GAMMA(pipe, i, 0));\n\t\tu32 udw = intel_de_read_fw(i915, CGM_PIPE_GAMMA(pipe, i, 1));\n\n\t\tchv_cgm_gamma_pack(&lut[i], ldw, udw);\n\t}\n\n\treturn blob;\n}\n\nstatic void chv_read_luts(struct intel_crtc_state *crtc_state)\n{\n\tstruct intel_crtc *crtc = to_intel_crtc(crtc_state->uapi.crtc);\n\n\tif (crtc_state->cgm_mode & CGM_PIPE_MODE_DEGAMMA)\n\t\tcrtc_state->pre_csc_lut = chv_read_cgm_degamma(crtc);\n\n\tif (crtc_state->cgm_mode & CGM_PIPE_MODE_GAMMA)\n\t\tcrtc_state->post_csc_lut = chv_read_cgm_gamma(crtc);\n\telse\n\t\ti965_read_luts(crtc_state);\n}\n\nstatic struct drm_property_blob *ilk_read_lut_8(struct intel_crtc *crtc)\n{\n\tstruct drm_i915_private *i915 = to_i915(crtc->base.dev);\n\tenum pipe pipe = crtc->pipe;\n\tstruct drm_property_blob *blob;\n\tstruct drm_color_lut *lut;\n\tint i;\n\n\tblob = drm_property_create_blob(&i915->drm,\n\t\t\t\t\tsizeof(lut[0]) * LEGACY_LUT_LENGTH,\n\t\t\t\t\tNULL);\n\tif (IS_ERR(blob))\n\t\treturn NULL;\n\n\tlut = blob->data;\n\n\tfor (i = 0; i < LEGACY_LUT_LENGTH; i++) {\n\t\tu32 val = intel_de_read_fw(i915, LGC_PALETTE(pipe, i));\n\n\t\ti9xx_lut_8_pack(&lut[i], val);\n\t}\n\n\treturn blob;\n}\n\nstatic struct drm_property_blob *ilk_read_lut_10(struct intel_crtc *crtc)\n{\n\tstruct drm_i915_private *i915 = to_i915(crtc->base.dev);\n\tint i, lut_size = DISPLAY_INFO(i915)->color.gamma_lut_size;\n\tenum pipe pipe = crtc->pipe;\n\tstruct drm_property_blob *blob;\n\tstruct drm_color_lut *lut;\n\n\tblob = drm_property_create_blob(&i915->drm,\n\t\t\t\t\tsizeof(lut[0]) * lut_size,\n\t\t\t\t\tNULL);\n\tif (IS_ERR(blob))\n\t\treturn NULL;\n\n\tlut = blob->data;\n\n\tfor (i = 0; i < lut_size; i++) {\n\t\tu32 val = intel_de_read_fw(i915, PREC_PALETTE(pipe, i));\n\n\t\tilk_lut_10_pack(&lut[i], val);\n\t}\n\n\treturn blob;\n}\n\nstatic void ilk_read_luts(struct intel_crtc_state *crtc_state)\n{\n\tstruct intel_crtc *crtc = to_intel_crtc(crtc_state->uapi.crtc);\n\tstruct drm_property_blob **blob =\n\t\tilk_has_post_csc_lut(crtc_state) ?\n\t\t&crtc_state->post_csc_lut : &crtc_state->pre_csc_lut;\n\n\tif (!crtc_state->gamma_enable && !crtc_state->c8_planes)\n\t\treturn;\n\n\tswitch (crtc_state->gamma_mode) {\n\tcase GAMMA_MODE_MODE_8BIT:\n\t\t*blob = ilk_read_lut_8(crtc);\n\t\tbreak;\n\tcase GAMMA_MODE_MODE_10BIT:\n\t\t*blob = ilk_read_lut_10(crtc);\n\t\tbreak;\n\tdefault:\n\t\tMISSING_CASE(crtc_state->gamma_mode);\n\t\tbreak;\n\t}\n}\n\n \nstatic struct drm_property_blob *ivb_read_lut_10(struct intel_crtc *crtc,\n\t\t\t\t\t\t u32 prec_index)\n{\n\tstruct drm_i915_private *dev_priv = to_i915(crtc->base.dev);\n\tint i, lut_size = ivb_lut_10_size(prec_index);\n\tenum pipe pipe = crtc->pipe;\n\tstruct drm_property_blob *blob;\n\tstruct drm_color_lut *lut;\n\n\tblob = drm_property_create_blob(&dev_priv->drm,\n\t\t\t\t\tsizeof(lut[0]) * lut_size,\n\t\t\t\t\tNULL);\n\tif (IS_ERR(blob))\n\t\treturn NULL;\n\n\tlut = blob->data;\n\n\tfor (i = 0; i < lut_size; i++) {\n\t\tu32 val;\n\n\t\tintel_de_write_fw(dev_priv, PREC_PAL_INDEX(pipe),\n\t\t\t\t  prec_index + i);\n\t\tval = intel_de_read_fw(dev_priv, PREC_PAL_DATA(pipe));\n\n\t\tilk_lut_10_pack(&lut[i], val);\n\t}\n\n\tintel_de_write_fw(dev_priv, PREC_PAL_INDEX(pipe),\n\t\t\t  PAL_PREC_INDEX_VALUE(0));\n\n\treturn blob;\n}\n\nstatic void ivb_read_luts(struct intel_crtc_state *crtc_state)\n{\n\tstruct intel_crtc *crtc = to_intel_crtc(crtc_state->uapi.crtc);\n\tstruct drm_property_blob **blob =\n\t\tilk_has_post_csc_lut(crtc_state) ?\n\t\t&crtc_state->post_csc_lut : &crtc_state->pre_csc_lut;\n\n\tif (!crtc_state->gamma_enable && !crtc_state->c8_planes)\n\t\treturn;\n\n\tswitch (crtc_state->gamma_mode) {\n\tcase GAMMA_MODE_MODE_8BIT:\n\t\t*blob = ilk_read_lut_8(crtc);\n\t\tbreak;\n\tcase GAMMA_MODE_MODE_SPLIT:\n\t\tcrtc_state->pre_csc_lut =\n\t\t\tivb_read_lut_10(crtc, PAL_PREC_SPLIT_MODE |\n\t\t\t\t\tPAL_PREC_INDEX_VALUE(0));\n\t\tcrtc_state->post_csc_lut =\n\t\t\tivb_read_lut_10(crtc, PAL_PREC_SPLIT_MODE |\n\t\t\t\t\tPAL_PREC_INDEX_VALUE(512));\n\t\tbreak;\n\tcase GAMMA_MODE_MODE_10BIT:\n\t\t*blob = ivb_read_lut_10(crtc, PAL_PREC_INDEX_VALUE(0));\n\t\tbreak;\n\tdefault:\n\t\tMISSING_CASE(crtc_state->gamma_mode);\n\t\tbreak;\n\t}\n}\n\n \nstatic struct drm_property_blob *bdw_read_lut_10(struct intel_crtc *crtc,\n\t\t\t\t\t\t u32 prec_index)\n{\n\tstruct drm_i915_private *i915 = to_i915(crtc->base.dev);\n\tint i, lut_size = ivb_lut_10_size(prec_index);\n\tenum pipe pipe = crtc->pipe;\n\tstruct drm_property_blob *blob;\n\tstruct drm_color_lut *lut;\n\n\tblob = drm_property_create_blob(&i915->drm,\n\t\t\t\t\tsizeof(lut[0]) * lut_size,\n\t\t\t\t\tNULL);\n\tif (IS_ERR(blob))\n\t\treturn NULL;\n\n\tlut = blob->data;\n\n\tintel_de_write_fw(i915, PREC_PAL_INDEX(pipe),\n\t\t\t  prec_index);\n\tintel_de_write_fw(i915, PREC_PAL_INDEX(pipe),\n\t\t\t  PAL_PREC_AUTO_INCREMENT |\n\t\t\t  prec_index);\n\n\tfor (i = 0; i < lut_size; i++) {\n\t\tu32 val = intel_de_read_fw(i915, PREC_PAL_DATA(pipe));\n\n\t\tilk_lut_10_pack(&lut[i], val);\n\t}\n\n\tintel_de_write_fw(i915, PREC_PAL_INDEX(pipe),\n\t\t\t  PAL_PREC_INDEX_VALUE(0));\n\n\treturn blob;\n}\n\nstatic void bdw_read_luts(struct intel_crtc_state *crtc_state)\n{\n\tstruct intel_crtc *crtc = to_intel_crtc(crtc_state->uapi.crtc);\n\tstruct drm_property_blob **blob =\n\t\tilk_has_post_csc_lut(crtc_state) ?\n\t\t&crtc_state->post_csc_lut : &crtc_state->pre_csc_lut;\n\n\tif (!crtc_state->gamma_enable && !crtc_state->c8_planes)\n\t\treturn;\n\n\tswitch (crtc_state->gamma_mode) {\n\tcase GAMMA_MODE_MODE_8BIT:\n\t\t*blob = ilk_read_lut_8(crtc);\n\t\tbreak;\n\tcase GAMMA_MODE_MODE_SPLIT:\n\t\tcrtc_state->pre_csc_lut =\n\t\t\tbdw_read_lut_10(crtc, PAL_PREC_SPLIT_MODE |\n\t\t\t\t\tPAL_PREC_INDEX_VALUE(0));\n\t\tcrtc_state->post_csc_lut =\n\t\t\tbdw_read_lut_10(crtc, PAL_PREC_SPLIT_MODE |\n\t\t\t\t\tPAL_PREC_INDEX_VALUE(512));\n\t\tbreak;\n\tcase GAMMA_MODE_MODE_10BIT:\n\t\t*blob = bdw_read_lut_10(crtc, PAL_PREC_INDEX_VALUE(0));\n\t\tbreak;\n\tdefault:\n\t\tMISSING_CASE(crtc_state->gamma_mode);\n\t\tbreak;\n\t}\n}\n\nstatic struct drm_property_blob *glk_read_degamma_lut(struct intel_crtc *crtc)\n{\n\tstruct drm_i915_private *dev_priv = to_i915(crtc->base.dev);\n\tint i, lut_size = DISPLAY_INFO(dev_priv)->color.degamma_lut_size;\n\tenum pipe pipe = crtc->pipe;\n\tstruct drm_property_blob *blob;\n\tstruct drm_color_lut *lut;\n\n\tblob = drm_property_create_blob(&dev_priv->drm,\n\t\t\t\t\tsizeof(lut[0]) * lut_size,\n\t\t\t\t\tNULL);\n\tif (IS_ERR(blob))\n\t\treturn NULL;\n\n\tlut = blob->data;\n\n\t \n\tintel_de_write_fw(dev_priv, PRE_CSC_GAMC_INDEX(pipe),\n\t\t\t  PRE_CSC_GAMC_INDEX_VALUE(0));\n\tintel_de_write_fw(dev_priv, PRE_CSC_GAMC_INDEX(pipe),\n\t\t\t  PRE_CSC_GAMC_AUTO_INCREMENT |\n\t\t\t  PRE_CSC_GAMC_INDEX_VALUE(0));\n\n\tfor (i = 0; i < lut_size; i++) {\n\t\tu32 val = intel_de_read_fw(dev_priv, PRE_CSC_GAMC_DATA(pipe));\n\n\t\t \n\t\tif (DISPLAY_VER(dev_priv) >= 14)\n\t\t\tval = change_lut_val_precision(val, 16, 24);\n\n\t\tlut[i].red = val;\n\t\tlut[i].green = val;\n\t\tlut[i].blue = val;\n\t}\n\n\tintel_de_write_fw(dev_priv, PRE_CSC_GAMC_INDEX(pipe),\n\t\t\t  PRE_CSC_GAMC_INDEX_VALUE(0));\n\n\treturn blob;\n}\n\nstatic void glk_read_luts(struct intel_crtc_state *crtc_state)\n{\n\tstruct intel_crtc *crtc = to_intel_crtc(crtc_state->uapi.crtc);\n\n\tif (crtc_state->csc_enable)\n\t\tcrtc_state->pre_csc_lut = glk_read_degamma_lut(crtc);\n\n\tif (!crtc_state->gamma_enable && !crtc_state->c8_planes)\n\t\treturn;\n\n\tswitch (crtc_state->gamma_mode) {\n\tcase GAMMA_MODE_MODE_8BIT:\n\t\tcrtc_state->post_csc_lut = ilk_read_lut_8(crtc);\n\t\tbreak;\n\tcase GAMMA_MODE_MODE_10BIT:\n\t\tcrtc_state->post_csc_lut = bdw_read_lut_10(crtc, PAL_PREC_INDEX_VALUE(0));\n\t\tbreak;\n\tdefault:\n\t\tMISSING_CASE(crtc_state->gamma_mode);\n\t\tbreak;\n\t}\n}\n\nstatic struct drm_property_blob *\nicl_read_lut_multi_segment(struct intel_crtc *crtc)\n{\n\tstruct drm_i915_private *i915 = to_i915(crtc->base.dev);\n\tint i, lut_size = DISPLAY_INFO(i915)->color.gamma_lut_size;\n\tenum pipe pipe = crtc->pipe;\n\tstruct drm_property_blob *blob;\n\tstruct drm_color_lut *lut;\n\n\tblob = drm_property_create_blob(&i915->drm,\n\t\t\t\t\tsizeof(lut[0]) * lut_size,\n\t\t\t\t\tNULL);\n\tif (IS_ERR(blob))\n\t\treturn NULL;\n\n\tlut = blob->data;\n\n\tintel_de_write_fw(i915, PREC_PAL_MULTI_SEG_INDEX(pipe),\n\t\t\t  PAL_PREC_MULTI_SEG_INDEX_VALUE(0));\n\tintel_de_write_fw(i915, PREC_PAL_MULTI_SEG_INDEX(pipe),\n\t\t\t  PAL_PREC_MULTI_SEG_AUTO_INCREMENT |\n\t\t\t  PAL_PREC_MULTI_SEG_INDEX_VALUE(0));\n\n\tfor (i = 0; i < 9; i++) {\n\t\tu32 ldw = intel_de_read_fw(i915, PREC_PAL_MULTI_SEG_DATA(pipe));\n\t\tu32 udw = intel_de_read_fw(i915, PREC_PAL_MULTI_SEG_DATA(pipe));\n\n\t\tilk_lut_12p4_pack(&lut[i], ldw, udw);\n\t}\n\n\tintel_de_write_fw(i915, PREC_PAL_MULTI_SEG_INDEX(pipe),\n\t\t\t  PAL_PREC_MULTI_SEG_INDEX_VALUE(0));\n\n\t \n\n\treturn blob;\n}\n\nstatic void icl_read_luts(struct intel_crtc_state *crtc_state)\n{\n\tstruct intel_crtc *crtc = to_intel_crtc(crtc_state->uapi.crtc);\n\n\tif (icl_has_pre_csc_lut(crtc_state))\n\t\tcrtc_state->pre_csc_lut = glk_read_degamma_lut(crtc);\n\n\tif (!icl_has_post_csc_lut(crtc_state))\n\t\treturn;\n\n\tswitch (crtc_state->gamma_mode & GAMMA_MODE_MODE_MASK) {\n\tcase GAMMA_MODE_MODE_8BIT:\n\t\tcrtc_state->post_csc_lut = ilk_read_lut_8(crtc);\n\t\tbreak;\n\tcase GAMMA_MODE_MODE_10BIT:\n\t\tcrtc_state->post_csc_lut = bdw_read_lut_10(crtc, PAL_PREC_INDEX_VALUE(0));\n\t\tbreak;\n\tcase GAMMA_MODE_MODE_12BIT_MULTI_SEG:\n\t\tcrtc_state->post_csc_lut = icl_read_lut_multi_segment(crtc);\n\t\tbreak;\n\tdefault:\n\t\tMISSING_CASE(crtc_state->gamma_mode);\n\t\tbreak;\n\t}\n}\n\nstatic const struct intel_color_funcs chv_color_funcs = {\n\t.color_check = chv_color_check,\n\t.color_commit_arm = i9xx_color_commit_arm,\n\t.load_luts = chv_load_luts,\n\t.read_luts = chv_read_luts,\n\t.lut_equal = chv_lut_equal,\n\t.read_csc = chv_read_csc,\n};\n\nstatic const struct intel_color_funcs vlv_color_funcs = {\n\t.color_check = vlv_color_check,\n\t.color_commit_arm = i9xx_color_commit_arm,\n\t.load_luts = vlv_load_luts,\n\t.read_luts = i965_read_luts,\n\t.lut_equal = i965_lut_equal,\n\t.read_csc = vlv_read_csc,\n};\n\nstatic const struct intel_color_funcs i965_color_funcs = {\n\t.color_check = i9xx_color_check,\n\t.color_commit_arm = i9xx_color_commit_arm,\n\t.load_luts = i965_load_luts,\n\t.read_luts = i965_read_luts,\n\t.lut_equal = i965_lut_equal,\n};\n\nstatic const struct intel_color_funcs i9xx_color_funcs = {\n\t.color_check = i9xx_color_check,\n\t.color_commit_arm = i9xx_color_commit_arm,\n\t.load_luts = i9xx_load_luts,\n\t.read_luts = i9xx_read_luts,\n\t.lut_equal = i9xx_lut_equal,\n};\n\nstatic const struct intel_color_funcs tgl_color_funcs = {\n\t.color_check = icl_color_check,\n\t.color_commit_noarm = icl_color_commit_noarm,\n\t.color_commit_arm = icl_color_commit_arm,\n\t.load_luts = icl_load_luts,\n\t.read_luts = icl_read_luts,\n\t.lut_equal = icl_lut_equal,\n\t.read_csc = icl_read_csc,\n};\n\nstatic const struct intel_color_funcs icl_color_funcs = {\n\t.color_check = icl_color_check,\n\t.color_commit_noarm = icl_color_commit_noarm,\n\t.color_commit_arm = icl_color_commit_arm,\n\t.color_post_update = icl_color_post_update,\n\t.load_luts = icl_load_luts,\n\t.read_luts = icl_read_luts,\n\t.lut_equal = icl_lut_equal,\n\t.read_csc = icl_read_csc,\n};\n\nstatic const struct intel_color_funcs glk_color_funcs = {\n\t.color_check = glk_color_check,\n\t.color_commit_noarm = skl_color_commit_noarm,\n\t.color_commit_arm = skl_color_commit_arm,\n\t.load_luts = glk_load_luts,\n\t.read_luts = glk_read_luts,\n\t.lut_equal = glk_lut_equal,\n\t.read_csc = skl_read_csc,\n};\n\nstatic const struct intel_color_funcs skl_color_funcs = {\n\t.color_check = ivb_color_check,\n\t.color_commit_noarm = skl_color_commit_noarm,\n\t.color_commit_arm = skl_color_commit_arm,\n\t.load_luts = bdw_load_luts,\n\t.read_luts = bdw_read_luts,\n\t.lut_equal = ivb_lut_equal,\n\t.read_csc = skl_read_csc,\n};\n\nstatic const struct intel_color_funcs bdw_color_funcs = {\n\t.color_check = ivb_color_check,\n\t.color_commit_noarm = ilk_color_commit_noarm,\n\t.color_commit_arm = hsw_color_commit_arm,\n\t.load_luts = bdw_load_luts,\n\t.read_luts = bdw_read_luts,\n\t.lut_equal = ivb_lut_equal,\n\t.read_csc = ilk_read_csc,\n};\n\nstatic const struct intel_color_funcs hsw_color_funcs = {\n\t.color_check = ivb_color_check,\n\t.color_commit_noarm = ilk_color_commit_noarm,\n\t.color_commit_arm = hsw_color_commit_arm,\n\t.load_luts = ivb_load_luts,\n\t.read_luts = ivb_read_luts,\n\t.lut_equal = ivb_lut_equal,\n\t.read_csc = ilk_read_csc,\n};\n\nstatic const struct intel_color_funcs ivb_color_funcs = {\n\t.color_check = ivb_color_check,\n\t.color_commit_noarm = ilk_color_commit_noarm,\n\t.color_commit_arm = ilk_color_commit_arm,\n\t.load_luts = ivb_load_luts,\n\t.read_luts = ivb_read_luts,\n\t.lut_equal = ivb_lut_equal,\n\t.read_csc = ilk_read_csc,\n};\n\nstatic const struct intel_color_funcs ilk_color_funcs = {\n\t.color_check = ilk_color_check,\n\t.color_commit_noarm = ilk_color_commit_noarm,\n\t.color_commit_arm = ilk_color_commit_arm,\n\t.load_luts = ilk_load_luts,\n\t.read_luts = ilk_read_luts,\n\t.lut_equal = ilk_lut_equal,\n\t.read_csc = ilk_read_csc,\n};\n\nvoid intel_color_crtc_init(struct intel_crtc *crtc)\n{\n\tstruct drm_i915_private *i915 = to_i915(crtc->base.dev);\n\tint degamma_lut_size, gamma_lut_size;\n\tbool has_ctm;\n\n\tdrm_mode_crtc_set_gamma_size(&crtc->base, 256);\n\n\tgamma_lut_size = DISPLAY_INFO(i915)->color.gamma_lut_size;\n\tdegamma_lut_size = DISPLAY_INFO(i915)->color.degamma_lut_size;\n\thas_ctm = DISPLAY_VER(i915) >= 5;\n\n\t \n\tif (DISPLAY_VER(i915) == 3 && crtc->pipe == PIPE_A)\n\t\tgamma_lut_size = 256;\n\n\tdrm_crtc_enable_color_mgmt(&crtc->base, degamma_lut_size,\n\t\t\t\t   has_ctm, gamma_lut_size);\n}\n\nint intel_color_init(struct drm_i915_private *i915)\n{\n\tstruct drm_property_blob *blob;\n\n\tif (DISPLAY_VER(i915) != 10)\n\t\treturn 0;\n\n\tblob = create_linear_lut(i915,\n\t\t\t\t DISPLAY_INFO(i915)->color.degamma_lut_size);\n\tif (IS_ERR(blob))\n\t\treturn PTR_ERR(blob);\n\n\ti915->display.color.glk_linear_degamma_lut = blob;\n\n\treturn 0;\n}\n\nvoid intel_color_init_hooks(struct drm_i915_private *i915)\n{\n\tif (HAS_GMCH(i915)) {\n\t\tif (IS_CHERRYVIEW(i915))\n\t\t\ti915->display.funcs.color = &chv_color_funcs;\n\t\telse if (IS_VALLEYVIEW(i915))\n\t\t\ti915->display.funcs.color = &vlv_color_funcs;\n\t\telse if (DISPLAY_VER(i915) >= 4)\n\t\t\ti915->display.funcs.color = &i965_color_funcs;\n\t\telse\n\t\t\ti915->display.funcs.color = &i9xx_color_funcs;\n\t} else {\n\t\tif (DISPLAY_VER(i915) >= 12)\n\t\t\ti915->display.funcs.color = &tgl_color_funcs;\n\t\telse if (DISPLAY_VER(i915) == 11)\n\t\t\ti915->display.funcs.color = &icl_color_funcs;\n\t\telse if (DISPLAY_VER(i915) == 10)\n\t\t\ti915->display.funcs.color = &glk_color_funcs;\n\t\telse if (DISPLAY_VER(i915) == 9)\n\t\t\ti915->display.funcs.color = &skl_color_funcs;\n\t\telse if (DISPLAY_VER(i915) == 8)\n\t\t\ti915->display.funcs.color = &bdw_color_funcs;\n\t\telse if (IS_HASWELL(i915))\n\t\t\ti915->display.funcs.color = &hsw_color_funcs;\n\t\telse if (DISPLAY_VER(i915) == 7)\n\t\t\ti915->display.funcs.color = &ivb_color_funcs;\n\t\telse\n\t\t\ti915->display.funcs.color = &ilk_color_funcs;\n\t}\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}