{
  "module_name": "intel_combo_phy.c",
  "hash_id": "c3d9858e1fb7124f74dc657d988e37696fc12d66129a5aef816bebc54c6cf7f9",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/i915/display/intel_combo_phy.c",
  "human_readable_source": "\n \n\n#include \"i915_reg.h\"\n#include \"intel_combo_phy.h\"\n#include \"intel_combo_phy_regs.h\"\n#include \"intel_de.h\"\n#include \"intel_display_types.h\"\n\n#define for_each_combo_phy(__dev_priv, __phy) \\\n\tfor ((__phy) = PHY_A; (__phy) < I915_MAX_PHYS; (__phy)++)\t\\\n\t\tfor_each_if(intel_phy_is_combo(__dev_priv, __phy))\n\n#define for_each_combo_phy_reverse(__dev_priv, __phy) \\\n\tfor ((__phy) = I915_MAX_PHYS; (__phy)-- > PHY_A;) \\\n\t\tfor_each_if(intel_phy_is_combo(__dev_priv, __phy))\n\nenum {\n\tPROCMON_0_85V_DOT_0,\n\tPROCMON_0_95V_DOT_0,\n\tPROCMON_0_95V_DOT_1,\n\tPROCMON_1_05V_DOT_0,\n\tPROCMON_1_05V_DOT_1,\n};\n\nstatic const struct icl_procmon {\n\tconst char *name;\n\tu32 dw1, dw9, dw10;\n} icl_procmon_values[] = {\n\t[PROCMON_0_85V_DOT_0] = {\n\t\t.name = \"0.85V dot0 (low-voltage)\",\n\t\t.dw1 = 0x00000000, .dw9 = 0x62AB67BB, .dw10 = 0x51914F96,\n\t},\n\t[PROCMON_0_95V_DOT_0] = {\n\t\t.name = \"0.95V dot0\",\n\t\t.dw1 = 0x00000000, .dw9 = 0x86E172C7, .dw10 = 0x77CA5EAB,\n\t},\n\t[PROCMON_0_95V_DOT_1] = {\n\t\t.name = \"0.95V dot1\",\n\t\t.dw1 = 0x00000000, .dw9 = 0x93F87FE1, .dw10 = 0x8AE871C5,\n\t},\n\t[PROCMON_1_05V_DOT_0] = {\n\t\t.name = \"1.05V dot0\",\n\t\t.dw1 = 0x00000000, .dw9 = 0x98FA82DD, .dw10 = 0x89E46DC1,\n\t},\n\t[PROCMON_1_05V_DOT_1] = {\n\t\t.name = \"1.05V dot1\",\n\t\t.dw1 = 0x00440000, .dw9 = 0x9A00AB25, .dw10 = 0x8AE38FF1,\n\t},\n};\n\nstatic const struct icl_procmon *\nicl_get_procmon_ref_values(struct drm_i915_private *dev_priv, enum phy phy)\n{\n\tu32 val;\n\n\tval = intel_de_read(dev_priv, ICL_PORT_COMP_DW3(phy));\n\tswitch (val & (PROCESS_INFO_MASK | VOLTAGE_INFO_MASK)) {\n\tdefault:\n\t\tMISSING_CASE(val);\n\t\tfallthrough;\n\tcase VOLTAGE_INFO_0_85V | PROCESS_INFO_DOT_0:\n\t\treturn &icl_procmon_values[PROCMON_0_85V_DOT_0];\n\tcase VOLTAGE_INFO_0_95V | PROCESS_INFO_DOT_0:\n\t\treturn &icl_procmon_values[PROCMON_0_95V_DOT_0];\n\tcase VOLTAGE_INFO_0_95V | PROCESS_INFO_DOT_1:\n\t\treturn &icl_procmon_values[PROCMON_0_95V_DOT_1];\n\tcase VOLTAGE_INFO_1_05V | PROCESS_INFO_DOT_0:\n\t\treturn &icl_procmon_values[PROCMON_1_05V_DOT_0];\n\tcase VOLTAGE_INFO_1_05V | PROCESS_INFO_DOT_1:\n\t\treturn &icl_procmon_values[PROCMON_1_05V_DOT_1];\n\t}\n}\n\nstatic void icl_set_procmon_ref_values(struct drm_i915_private *dev_priv,\n\t\t\t\t       enum phy phy)\n{\n\tconst struct icl_procmon *procmon;\n\n\tprocmon = icl_get_procmon_ref_values(dev_priv, phy);\n\n\tintel_de_rmw(dev_priv, ICL_PORT_COMP_DW1(phy),\n\t\t     (0xff << 16) | 0xff, procmon->dw1);\n\n\tintel_de_write(dev_priv, ICL_PORT_COMP_DW9(phy), procmon->dw9);\n\tintel_de_write(dev_priv, ICL_PORT_COMP_DW10(phy), procmon->dw10);\n}\n\nstatic bool check_phy_reg(struct drm_i915_private *dev_priv,\n\t\t\t  enum phy phy, i915_reg_t reg, u32 mask,\n\t\t\t  u32 expected_val)\n{\n\tu32 val = intel_de_read(dev_priv, reg);\n\n\tif ((val & mask) != expected_val) {\n\t\tdrm_dbg(&dev_priv->drm,\n\t\t\t\"Combo PHY %c reg %08x state mismatch: \"\n\t\t\t\"current %08x mask %08x expected %08x\\n\",\n\t\t\tphy_name(phy),\n\t\t\treg.reg, val, mask, expected_val);\n\t\treturn false;\n\t}\n\n\treturn true;\n}\n\nstatic bool icl_verify_procmon_ref_values(struct drm_i915_private *dev_priv,\n\t\t\t\t\t  enum phy phy)\n{\n\tconst struct icl_procmon *procmon;\n\tbool ret;\n\n\tprocmon = icl_get_procmon_ref_values(dev_priv, phy);\n\n\tdrm_dbg_kms(&dev_priv->drm,\n\t\t    \"Combo PHY %c Voltage/Process Info : %s\\n\",\n\t\t    phy_name(phy), procmon->name);\n\n\tret = check_phy_reg(dev_priv, phy, ICL_PORT_COMP_DW1(phy),\n\t\t\t    (0xff << 16) | 0xff, procmon->dw1);\n\tret &= check_phy_reg(dev_priv, phy, ICL_PORT_COMP_DW9(phy),\n\t\t\t     -1U, procmon->dw9);\n\tret &= check_phy_reg(dev_priv, phy, ICL_PORT_COMP_DW10(phy),\n\t\t\t     -1U, procmon->dw10);\n\n\treturn ret;\n}\n\nstatic bool has_phy_misc(struct drm_i915_private *i915, enum phy phy)\n{\n\t \n\n\tif (IS_ALDERLAKE_S(i915))\n\t\treturn phy == PHY_A;\n\telse if ((IS_JASPERLAKE(i915) || IS_ELKHARTLAKE(i915)) ||\n\t\t IS_ROCKETLAKE(i915) ||\n\t\t IS_DG1(i915))\n\t\treturn phy < PHY_C;\n\n\treturn true;\n}\n\nstatic bool icl_combo_phy_enabled(struct drm_i915_private *dev_priv,\n\t\t\t\t  enum phy phy)\n{\n\t \n\tif (!has_phy_misc(dev_priv, phy))\n\t\treturn intel_de_read(dev_priv, ICL_PORT_COMP_DW0(phy)) & COMP_INIT;\n\telse\n\t\treturn !(intel_de_read(dev_priv, ICL_PHY_MISC(phy)) &\n\t\t\t ICL_PHY_MISC_DE_IO_COMP_PWR_DOWN) &&\n\t\t\t(intel_de_read(dev_priv, ICL_PORT_COMP_DW0(phy)) & COMP_INIT);\n}\n\nstatic bool ehl_vbt_ddi_d_present(struct drm_i915_private *i915)\n{\n\tbool ddi_a_present = intel_bios_is_port_present(i915, PORT_A);\n\tbool ddi_d_present = intel_bios_is_port_present(i915, PORT_D);\n\tbool dsi_present = intel_bios_is_dsi_present(i915, NULL);\n\n\t \n\tif (ddi_d_present && !ddi_a_present && !dsi_present)\n\t\treturn true;\n\n\t \n\tif (ddi_d_present)\n\t\tdrm_err(&i915->drm,\n\t\t\t\"VBT claims to have both internal and external displays on PHY A.  Configuring for internal.\\n\");\n\n\treturn false;\n}\n\nstatic bool phy_is_master(struct drm_i915_private *dev_priv, enum phy phy)\n{\n\t \n\tif (phy == PHY_A)\n\t\treturn true;\n\telse if (IS_ALDERLAKE_S(dev_priv))\n\t\treturn phy == PHY_D;\n\telse if (IS_DG1(dev_priv) || IS_ROCKETLAKE(dev_priv))\n\t\treturn phy == PHY_C;\n\n\treturn false;\n}\n\nstatic bool icl_combo_phy_verify_state(struct drm_i915_private *dev_priv,\n\t\t\t\t       enum phy phy)\n{\n\tbool ret = true;\n\tu32 expected_val = 0;\n\n\tif (!icl_combo_phy_enabled(dev_priv, phy))\n\t\treturn false;\n\n\tif (DISPLAY_VER(dev_priv) >= 12) {\n\t\tret &= check_phy_reg(dev_priv, phy, ICL_PORT_TX_DW8_LN(0, phy),\n\t\t\t\t     ICL_PORT_TX_DW8_ODCC_CLK_SEL |\n\t\t\t\t     ICL_PORT_TX_DW8_ODCC_CLK_DIV_SEL_MASK,\n\t\t\t\t     ICL_PORT_TX_DW8_ODCC_CLK_SEL |\n\t\t\t\t     ICL_PORT_TX_DW8_ODCC_CLK_DIV_SEL_DIV2);\n\n\t\tret &= check_phy_reg(dev_priv, phy, ICL_PORT_PCS_DW1_LN(0, phy),\n\t\t\t\t     DCC_MODE_SELECT_MASK, RUN_DCC_ONCE);\n\t}\n\n\tret &= icl_verify_procmon_ref_values(dev_priv, phy);\n\n\tif (phy_is_master(dev_priv, phy)) {\n\t\tret &= check_phy_reg(dev_priv, phy, ICL_PORT_COMP_DW8(phy),\n\t\t\t\t     IREFGEN, IREFGEN);\n\n\t\tif (IS_JASPERLAKE(dev_priv) || IS_ELKHARTLAKE(dev_priv)) {\n\t\t\tif (ehl_vbt_ddi_d_present(dev_priv))\n\t\t\t\texpected_val = ICL_PHY_MISC_MUX_DDID;\n\n\t\t\tret &= check_phy_reg(dev_priv, phy, ICL_PHY_MISC(phy),\n\t\t\t\t\t     ICL_PHY_MISC_MUX_DDID,\n\t\t\t\t\t     expected_val);\n\t\t}\n\t}\n\n\tret &= check_phy_reg(dev_priv, phy, ICL_PORT_CL_DW5(phy),\n\t\t\t     CL_POWER_DOWN_ENABLE, CL_POWER_DOWN_ENABLE);\n\n\treturn ret;\n}\n\nvoid intel_combo_phy_power_up_lanes(struct drm_i915_private *dev_priv,\n\t\t\t\t    enum phy phy, bool is_dsi,\n\t\t\t\t    int lane_count, bool lane_reversal)\n{\n\tu8 lane_mask;\n\n\tif (is_dsi) {\n\t\tdrm_WARN_ON(&dev_priv->drm, lane_reversal);\n\n\t\tswitch (lane_count) {\n\t\tcase 1:\n\t\t\tlane_mask = PWR_DOWN_LN_3_1_0;\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tlane_mask = PWR_DOWN_LN_3_1;\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tlane_mask = PWR_DOWN_LN_3;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tMISSING_CASE(lane_count);\n\t\t\tfallthrough;\n\t\tcase 4:\n\t\t\tlane_mask = PWR_UP_ALL_LANES;\n\t\t\tbreak;\n\t\t}\n\t} else {\n\t\tswitch (lane_count) {\n\t\tcase 1:\n\t\t\tlane_mask = lane_reversal ? PWR_DOWN_LN_2_1_0 :\n\t\t\t\t\t\t    PWR_DOWN_LN_3_2_1;\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tlane_mask = lane_reversal ? PWR_DOWN_LN_1_0 :\n\t\t\t\t\t\t    PWR_DOWN_LN_3_2;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tMISSING_CASE(lane_count);\n\t\t\tfallthrough;\n\t\tcase 4:\n\t\t\tlane_mask = PWR_UP_ALL_LANES;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tintel_de_rmw(dev_priv, ICL_PORT_CL_DW10(phy),\n\t\t     PWR_DOWN_LN_MASK, lane_mask);\n}\n\nstatic void icl_combo_phys_init(struct drm_i915_private *dev_priv)\n{\n\tenum phy phy;\n\n\tfor_each_combo_phy(dev_priv, phy) {\n\t\tu32 val;\n\n\t\tif (icl_combo_phy_verify_state(dev_priv, phy)) {\n\t\t\tdrm_dbg(&dev_priv->drm,\n\t\t\t\t\"Combo PHY %c already enabled, won't reprogram it.\\n\",\n\t\t\t\tphy_name(phy));\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!has_phy_misc(dev_priv, phy))\n\t\t\tgoto skip_phy_misc;\n\n\t\t \n\t\tval = intel_de_read(dev_priv, ICL_PHY_MISC(phy));\n\t\tif ((IS_JASPERLAKE(dev_priv) || IS_ELKHARTLAKE(dev_priv)) &&\n\t\t    phy == PHY_A) {\n\t\t\tval &= ~ICL_PHY_MISC_MUX_DDID;\n\n\t\t\tif (ehl_vbt_ddi_d_present(dev_priv))\n\t\t\t\tval |= ICL_PHY_MISC_MUX_DDID;\n\t\t}\n\n\t\tval &= ~ICL_PHY_MISC_DE_IO_COMP_PWR_DOWN;\n\t\tintel_de_write(dev_priv, ICL_PHY_MISC(phy), val);\n\nskip_phy_misc:\n\t\tif (DISPLAY_VER(dev_priv) >= 12) {\n\t\t\tval = intel_de_read(dev_priv, ICL_PORT_TX_DW8_LN(0, phy));\n\t\t\tval &= ~ICL_PORT_TX_DW8_ODCC_CLK_DIV_SEL_MASK;\n\t\t\tval |= ICL_PORT_TX_DW8_ODCC_CLK_SEL;\n\t\t\tval |= ICL_PORT_TX_DW8_ODCC_CLK_DIV_SEL_DIV2;\n\t\t\tintel_de_write(dev_priv, ICL_PORT_TX_DW8_GRP(phy), val);\n\n\t\t\tval = intel_de_read(dev_priv, ICL_PORT_PCS_DW1_LN(0, phy));\n\t\t\tval &= ~DCC_MODE_SELECT_MASK;\n\t\t\tval |= RUN_DCC_ONCE;\n\t\t\tintel_de_write(dev_priv, ICL_PORT_PCS_DW1_GRP(phy), val);\n\t\t}\n\n\t\ticl_set_procmon_ref_values(dev_priv, phy);\n\n\t\tif (phy_is_master(dev_priv, phy))\n\t\t\tintel_de_rmw(dev_priv, ICL_PORT_COMP_DW8(phy),\n\t\t\t\t     0, IREFGEN);\n\n\t\tintel_de_rmw(dev_priv, ICL_PORT_COMP_DW0(phy), 0, COMP_INIT);\n\t\tintel_de_rmw(dev_priv, ICL_PORT_CL_DW5(phy),\n\t\t\t     0, CL_POWER_DOWN_ENABLE);\n\t}\n}\n\nstatic void icl_combo_phys_uninit(struct drm_i915_private *dev_priv)\n{\n\tenum phy phy;\n\n\tfor_each_combo_phy_reverse(dev_priv, phy) {\n\t\tif (phy == PHY_A &&\n\t\t    !icl_combo_phy_verify_state(dev_priv, phy)) {\n\t\t\tif (IS_TIGERLAKE(dev_priv) || IS_DG1(dev_priv)) {\n\t\t\t\t \n\t\t\t\tdrm_dbg_kms(&dev_priv->drm,\n\t\t\t\t\t    \"Combo PHY %c HW state changed unexpectedly\\n\",\n\t\t\t\t\t    phy_name(phy));\n\t\t\t} else {\n\t\t\t\tdrm_warn(&dev_priv->drm,\n\t\t\t\t\t \"Combo PHY %c HW state changed unexpectedly\\n\",\n\t\t\t\t\t phy_name(phy));\n\t\t\t}\n\t\t}\n\n\t\tif (!has_phy_misc(dev_priv, phy))\n\t\t\tgoto skip_phy_misc;\n\n\t\tintel_de_rmw(dev_priv, ICL_PHY_MISC(phy), 0,\n\t\t\t     ICL_PHY_MISC_DE_IO_COMP_PWR_DOWN);\n\nskip_phy_misc:\n\t\tintel_de_rmw(dev_priv, ICL_PORT_COMP_DW0(phy), COMP_INIT, 0);\n\t}\n}\n\nvoid intel_combo_phy_init(struct drm_i915_private *i915)\n{\n\ticl_combo_phys_init(i915);\n}\n\nvoid intel_combo_phy_uninit(struct drm_i915_private *i915)\n{\n\ticl_combo_phys_uninit(i915);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}