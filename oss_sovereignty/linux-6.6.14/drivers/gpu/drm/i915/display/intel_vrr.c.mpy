{
  "module_name": "intel_vrr.c",
  "hash_id": "3a6acf03f62f72551bf33e38b6c89a8e7a0a6a915dc39f00f9120b36cf5b3630",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/i915/display/intel_vrr.c",
  "human_readable_source": "\n \n\n#include \"i915_drv.h\"\n#include \"i915_reg.h\"\n#include \"intel_de.h\"\n#include \"intel_display_types.h\"\n#include \"intel_vrr.h\"\n\nbool intel_vrr_is_capable(struct intel_connector *connector)\n{\n\tconst struct drm_display_info *info = &connector->base.display_info;\n\tstruct drm_i915_private *i915 = to_i915(connector->base.dev);\n\tstruct intel_dp *intel_dp;\n\n\t \n\tswitch (connector->base.connector_type) {\n\tcase DRM_MODE_CONNECTOR_eDP:\n\t\tif (!connector->panel.vbt.vrr)\n\t\t\treturn false;\n\t\tfallthrough;\n\tcase DRM_MODE_CONNECTOR_DisplayPort:\n\t\tintel_dp = intel_attached_dp(connector);\n\n\t\tif (!drm_dp_sink_can_do_video_without_timing_msa(intel_dp->dpcd))\n\t\t\treturn false;\n\n\t\tbreak;\n\tdefault:\n\t\treturn false;\n\t}\n\n\treturn HAS_VRR(i915) &&\n\t\tinfo->monitor_range.max_vfreq - info->monitor_range.min_vfreq > 10;\n}\n\nvoid\nintel_vrr_check_modeset(struct intel_atomic_state *state)\n{\n\tint i;\n\tstruct intel_crtc_state *old_crtc_state, *new_crtc_state;\n\tstruct intel_crtc *crtc;\n\n\tfor_each_oldnew_intel_crtc_in_state(state, crtc, old_crtc_state,\n\t\t\t\t\t    new_crtc_state, i) {\n\t\tif (new_crtc_state->uapi.vrr_enabled !=\n\t\t    old_crtc_state->uapi.vrr_enabled)\n\t\t\tnew_crtc_state->uapi.mode_changed = true;\n\t}\n}\n\n \nstatic int intel_vrr_vblank_exit_length(const struct intel_crtc_state *crtc_state)\n{\n\tstruct intel_crtc *crtc = to_intel_crtc(crtc_state->uapi.crtc);\n\tstruct drm_i915_private *i915 = to_i915(crtc->base.dev);\n\n\tif (DISPLAY_VER(i915) >= 13)\n\t\treturn crtc_state->vrr.guardband;\n\telse\n\t\t \n\t\treturn crtc_state->vrr.pipeline_full + crtc_state->framestart_delay + 1;\n}\n\nint intel_vrr_vmin_vblank_start(const struct intel_crtc_state *crtc_state)\n{\n\t \n\treturn crtc_state->vrr.vmin + 1 - intel_vrr_vblank_exit_length(crtc_state);\n}\n\nint intel_vrr_vmax_vblank_start(const struct intel_crtc_state *crtc_state)\n{\n\treturn crtc_state->vrr.vmax - intel_vrr_vblank_exit_length(crtc_state);\n}\n\nvoid\nintel_vrr_compute_config(struct intel_crtc_state *crtc_state,\n\t\t\t struct drm_connector_state *conn_state)\n{\n\tstruct intel_crtc *crtc = to_intel_crtc(crtc_state->uapi.crtc);\n\tstruct drm_i915_private *i915 = to_i915(crtc->base.dev);\n\tstruct intel_connector *connector =\n\t\tto_intel_connector(conn_state->connector);\n\tstruct drm_display_mode *adjusted_mode = &crtc_state->hw.adjusted_mode;\n\tconst struct drm_display_info *info = &connector->base.display_info;\n\tint vmin, vmax;\n\n\tif (!intel_vrr_is_capable(connector))\n\t\treturn;\n\n\tif (adjusted_mode->flags & DRM_MODE_FLAG_INTERLACE)\n\t\treturn;\n\n\tvmin = DIV_ROUND_UP(adjusted_mode->crtc_clock * 1000,\n\t\t\t    adjusted_mode->crtc_htotal * info->monitor_range.max_vfreq);\n\tvmax = adjusted_mode->crtc_clock * 1000 /\n\t\t(adjusted_mode->crtc_htotal * info->monitor_range.min_vfreq);\n\n\tvmin = max_t(int, vmin, adjusted_mode->crtc_vtotal);\n\tvmax = max_t(int, vmax, adjusted_mode->crtc_vtotal);\n\n\tif (vmin >= vmax)\n\t\treturn;\n\n\t \n\tcrtc_state->vrr.vmin = vmin - 1;\n\tcrtc_state->vrr.vmax = vmax;\n\n\tcrtc_state->vrr.flipline = crtc_state->vrr.vmin + 1;\n\n\t \n\tif (DISPLAY_VER(i915) >= 13) {\n\t\tcrtc_state->vrr.guardband =\n\t\t\tcrtc_state->vrr.vmin + 1 - adjusted_mode->crtc_vblank_start;\n\t} else {\n\t\tcrtc_state->vrr.pipeline_full =\n\t\t\tmin(255, crtc_state->vrr.vmin - adjusted_mode->crtc_vblank_start -\n\t\t\t    crtc_state->framestart_delay - 1);\n\t}\n\n\tif (crtc_state->uapi.vrr_enabled) {\n\t\tcrtc_state->vrr.enable = true;\n\t\tcrtc_state->mode_flags |= I915_MODE_FLAG_VRR;\n\t}\n}\n\nstatic u32 trans_vrr_ctl(const struct intel_crtc_state *crtc_state)\n{\n\tstruct drm_i915_private *i915 = to_i915(crtc_state->uapi.crtc->dev);\n\n\tif (DISPLAY_VER(i915) >= 13)\n\t\treturn VRR_CTL_IGN_MAX_SHIFT | VRR_CTL_FLIP_LINE_EN |\n\t\t\tXELPD_VRR_CTL_VRR_GUARDBAND(crtc_state->vrr.guardband);\n\telse\n\t\treturn VRR_CTL_IGN_MAX_SHIFT | VRR_CTL_FLIP_LINE_EN |\n\t\t\tVRR_CTL_PIPELINE_FULL(crtc_state->vrr.pipeline_full) |\n\t\t\tVRR_CTL_PIPELINE_FULL_OVERRIDE;\n}\n\nvoid intel_vrr_set_transcoder_timings(const struct intel_crtc_state *crtc_state)\n{\n\tstruct drm_i915_private *dev_priv = to_i915(crtc_state->uapi.crtc->dev);\n\tenum transcoder cpu_transcoder = crtc_state->cpu_transcoder;\n\n\t \n\tif (DISPLAY_VER(dev_priv) == 13)\n\t\tintel_de_rmw(dev_priv, CHICKEN_TRANS(cpu_transcoder),\n\t\t\t     0, PIPE_VBLANK_WITH_DELAY);\n\n\tif (!crtc_state->vrr.flipline) {\n\t\tintel_de_write(dev_priv, TRANS_VRR_CTL(cpu_transcoder), 0);\n\t\treturn;\n\t}\n\n\tintel_de_write(dev_priv, TRANS_VRR_VMIN(cpu_transcoder), crtc_state->vrr.vmin - 1);\n\tintel_de_write(dev_priv, TRANS_VRR_VMAX(cpu_transcoder), crtc_state->vrr.vmax - 1);\n\tintel_de_write(dev_priv, TRANS_VRR_CTL(cpu_transcoder), trans_vrr_ctl(crtc_state));\n\tintel_de_write(dev_priv, TRANS_VRR_FLIPLINE(cpu_transcoder), crtc_state->vrr.flipline - 1);\n}\n\nvoid intel_vrr_send_push(const struct intel_crtc_state *crtc_state)\n{\n\tstruct intel_crtc *crtc = to_intel_crtc(crtc_state->uapi.crtc);\n\tstruct drm_i915_private *dev_priv = to_i915(crtc->base.dev);\n\tenum transcoder cpu_transcoder = crtc_state->cpu_transcoder;\n\n\tif (!crtc_state->vrr.enable)\n\t\treturn;\n\n\tintel_de_write(dev_priv, TRANS_PUSH(cpu_transcoder),\n\t\t       TRANS_PUSH_EN | TRANS_PUSH_SEND);\n}\n\nbool intel_vrr_is_push_sent(const struct intel_crtc_state *crtc_state)\n{\n\tstruct intel_crtc *crtc = to_intel_crtc(crtc_state->uapi.crtc);\n\tstruct drm_i915_private *dev_priv = to_i915(crtc->base.dev);\n\tenum transcoder cpu_transcoder = crtc_state->cpu_transcoder;\n\n\tif (!crtc_state->vrr.enable)\n\t\treturn false;\n\n\treturn intel_de_read(dev_priv, TRANS_PUSH(cpu_transcoder)) & TRANS_PUSH_SEND;\n}\n\nvoid intel_vrr_enable(const struct intel_crtc_state *crtc_state)\n{\n\tstruct drm_i915_private *dev_priv = to_i915(crtc_state->uapi.crtc->dev);\n\tenum transcoder cpu_transcoder = crtc_state->cpu_transcoder;\n\n\tif (!crtc_state->vrr.enable)\n\t\treturn;\n\n\tintel_de_write(dev_priv, TRANS_PUSH(cpu_transcoder), TRANS_PUSH_EN);\n\tintel_de_write(dev_priv, TRANS_VRR_CTL(cpu_transcoder),\n\t\t       VRR_CTL_VRR_ENABLE | trans_vrr_ctl(crtc_state));\n}\n\nvoid intel_vrr_disable(const struct intel_crtc_state *old_crtc_state)\n{\n\tstruct intel_crtc *crtc = to_intel_crtc(old_crtc_state->uapi.crtc);\n\tstruct drm_i915_private *dev_priv = to_i915(crtc->base.dev);\n\tenum transcoder cpu_transcoder = old_crtc_state->cpu_transcoder;\n\n\tif (!old_crtc_state->vrr.enable)\n\t\treturn;\n\n\tintel_de_write(dev_priv, TRANS_VRR_CTL(cpu_transcoder),\n\t\t       trans_vrr_ctl(old_crtc_state));\n\tintel_de_wait_for_clear(dev_priv, TRANS_VRR_STATUS(cpu_transcoder),\n\t\t\t\tVRR_STATUS_VRR_EN_LIVE, 1000);\n\tintel_de_write(dev_priv, TRANS_PUSH(cpu_transcoder), 0);\n}\n\nvoid intel_vrr_get_config(struct intel_crtc_state *crtc_state)\n{\n\tstruct drm_i915_private *dev_priv = to_i915(crtc_state->uapi.crtc->dev);\n\tenum transcoder cpu_transcoder = crtc_state->cpu_transcoder;\n\tu32 trans_vrr_ctl;\n\n\ttrans_vrr_ctl = intel_de_read(dev_priv, TRANS_VRR_CTL(cpu_transcoder));\n\n\tcrtc_state->vrr.enable = trans_vrr_ctl & VRR_CTL_VRR_ENABLE;\n\n\tif (DISPLAY_VER(dev_priv) >= 13)\n\t\tcrtc_state->vrr.guardband =\n\t\t\tREG_FIELD_GET(XELPD_VRR_CTL_VRR_GUARDBAND_MASK, trans_vrr_ctl);\n\telse\n\t\tif (trans_vrr_ctl & VRR_CTL_PIPELINE_FULL_OVERRIDE)\n\t\t\tcrtc_state->vrr.pipeline_full =\n\t\t\t\tREG_FIELD_GET(VRR_CTL_PIPELINE_FULL_MASK, trans_vrr_ctl);\n\n\tif (trans_vrr_ctl & VRR_CTL_FLIP_LINE_EN) {\n\t\tcrtc_state->vrr.flipline = intel_de_read(dev_priv, TRANS_VRR_FLIPLINE(cpu_transcoder)) + 1;\n\t\tcrtc_state->vrr.vmax = intel_de_read(dev_priv, TRANS_VRR_VMAX(cpu_transcoder)) + 1;\n\t\tcrtc_state->vrr.vmin = intel_de_read(dev_priv, TRANS_VRR_VMIN(cpu_transcoder)) + 1;\n\t}\n\n\tif (crtc_state->vrr.enable)\n\t\tcrtc_state->mode_flags |= I915_MODE_FLAG_VRR;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}