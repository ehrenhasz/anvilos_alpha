{
  "module_name": "intel_load_detect.c",
  "hash_id": "11b9cf177d5be8b71dccea0dfc4c1df244336da214564854e5e13abb9ac5e5d7",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/i915/display/intel_load_detect.c",
  "human_readable_source": "\n \n\n#include <drm/drm_atomic.h>\n#include <drm/drm_atomic_helper.h>\n#include <drm/drm_atomic_uapi.h>\n\n#include \"i915_drv.h\"\n#include \"intel_atomic.h\"\n#include \"intel_crtc.h\"\n#include \"intel_display_types.h\"\n#include \"intel_load_detect.h\"\n\n \nstatic const struct drm_display_mode load_detect_mode = {\n\tDRM_MODE(\"640x480\", DRM_MODE_TYPE_DEFAULT, 31500, 640, 664,\n\t\t 704, 832, 0, 480, 489, 491, 520, 0, DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_NVSYNC),\n};\n\nstatic int intel_modeset_disable_planes(struct drm_atomic_state *state,\n\t\t\t\t\tstruct drm_crtc *crtc)\n{\n\tstruct drm_plane *plane;\n\tstruct drm_plane_state *plane_state;\n\tint ret, i;\n\n\tret = drm_atomic_add_affected_planes(state, crtc);\n\tif (ret)\n\t\treturn ret;\n\n\tfor_each_new_plane_in_state(state, plane, plane_state, i) {\n\t\tif (plane_state->crtc != crtc)\n\t\t\tcontinue;\n\n\t\tret = drm_atomic_set_crtc_for_plane(plane_state, NULL);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tdrm_atomic_set_fb_for_plane(plane_state, NULL);\n\t}\n\n\treturn 0;\n}\n\nstruct drm_atomic_state *\nintel_load_detect_get_pipe(struct drm_connector *connector,\n\t\t\t   struct drm_modeset_acquire_ctx *ctx)\n{\n\tstruct intel_encoder *encoder =\n\t\tintel_attached_encoder(to_intel_connector(connector));\n\tstruct intel_crtc *possible_crtc;\n\tstruct intel_crtc *crtc = NULL;\n\tstruct drm_device *dev = encoder->base.dev;\n\tstruct drm_i915_private *dev_priv = to_i915(dev);\n\tstruct drm_mode_config *config = &dev->mode_config;\n\tstruct drm_atomic_state *state = NULL, *restore_state = NULL;\n\tstruct drm_connector_state *connector_state;\n\tstruct intel_crtc_state *crtc_state;\n\tint ret;\n\n\tdrm_dbg_kms(&dev_priv->drm, \"[CONNECTOR:%d:%s], [ENCODER:%d:%s]\\n\",\n\t\t    connector->base.id, connector->name,\n\t\t    encoder->base.base.id, encoder->base.name);\n\n\tdrm_WARN_ON(dev, !drm_modeset_is_locked(&config->connection_mutex));\n\n\t \n\n\t \n\tif (connector->state->crtc) {\n\t\tcrtc = to_intel_crtc(connector->state->crtc);\n\n\t\tret = drm_modeset_lock(&crtc->base.mutex, ctx);\n\t\tif (ret)\n\t\t\tgoto fail;\n\n\t\t \n\t\tgoto found;\n\t}\n\n\t \n\tfor_each_intel_crtc(dev, possible_crtc) {\n\t\tif (!(encoder->base.possible_crtcs &\n\t\t      drm_crtc_mask(&possible_crtc->base)))\n\t\t\tcontinue;\n\n\t\tret = drm_modeset_lock(&possible_crtc->base.mutex, ctx);\n\t\tif (ret)\n\t\t\tgoto fail;\n\n\t\tif (possible_crtc->base.state->enable) {\n\t\t\tdrm_modeset_unlock(&possible_crtc->base.mutex);\n\t\t\tcontinue;\n\t\t}\n\n\t\tcrtc = possible_crtc;\n\t\tbreak;\n\t}\n\n\t \n\tif (!crtc) {\n\t\tdrm_dbg_kms(&dev_priv->drm,\n\t\t\t    \"no pipe available for load-detect\\n\");\n\t\tret = -ENODEV;\n\t\tgoto fail;\n\t}\n\nfound:\n\tstate = drm_atomic_state_alloc(dev);\n\trestore_state = drm_atomic_state_alloc(dev);\n\tif (!state || !restore_state) {\n\t\tret = -ENOMEM;\n\t\tgoto fail;\n\t}\n\n\tstate->acquire_ctx = ctx;\n\tto_intel_atomic_state(state)->internal = true;\n\n\trestore_state->acquire_ctx = ctx;\n\tto_intel_atomic_state(restore_state)->internal = true;\n\n\tconnector_state = drm_atomic_get_connector_state(state, connector);\n\tif (IS_ERR(connector_state)) {\n\t\tret = PTR_ERR(connector_state);\n\t\tgoto fail;\n\t}\n\n\tret = drm_atomic_set_crtc_for_connector(connector_state, &crtc->base);\n\tif (ret)\n\t\tgoto fail;\n\n\tcrtc_state = intel_atomic_get_crtc_state(state, crtc);\n\tif (IS_ERR(crtc_state)) {\n\t\tret = PTR_ERR(crtc_state);\n\t\tgoto fail;\n\t}\n\n\tcrtc_state->uapi.active = true;\n\n\tret = drm_atomic_set_mode_for_crtc(&crtc_state->uapi,\n\t\t\t\t\t   &load_detect_mode);\n\tif (ret)\n\t\tgoto fail;\n\n\tret = intel_modeset_disable_planes(state, &crtc->base);\n\tif (ret)\n\t\tgoto fail;\n\n\tret = PTR_ERR_OR_ZERO(drm_atomic_get_connector_state(restore_state, connector));\n\tif (!ret)\n\t\tret = PTR_ERR_OR_ZERO(drm_atomic_get_crtc_state(restore_state, &crtc->base));\n\tif (!ret)\n\t\tret = drm_atomic_add_affected_planes(restore_state, &crtc->base);\n\tif (ret) {\n\t\tdrm_dbg_kms(&dev_priv->drm,\n\t\t\t    \"Failed to create a copy of old state to restore: %i\\n\",\n\t\t\t    ret);\n\t\tgoto fail;\n\t}\n\n\tret = drm_atomic_commit(state);\n\tif (ret) {\n\t\tdrm_dbg_kms(&dev_priv->drm,\n\t\t\t    \"failed to set mode on load-detect pipe\\n\");\n\t\tgoto fail;\n\t}\n\n\tdrm_atomic_state_put(state);\n\n\t \n\tintel_crtc_wait_for_next_vblank(crtc);\n\n\treturn restore_state;\n\nfail:\n\tif (state) {\n\t\tdrm_atomic_state_put(state);\n\t\tstate = NULL;\n\t}\n\tif (restore_state) {\n\t\tdrm_atomic_state_put(restore_state);\n\t\trestore_state = NULL;\n\t}\n\n\tif (ret == -EDEADLK)\n\t\treturn ERR_PTR(ret);\n\n\treturn NULL;\n}\n\nvoid intel_load_detect_release_pipe(struct drm_connector *connector,\n\t\t\t\t    struct drm_atomic_state *state,\n\t\t\t\t    struct drm_modeset_acquire_ctx *ctx)\n{\n\tstruct intel_encoder *intel_encoder =\n\t\tintel_attached_encoder(to_intel_connector(connector));\n\tstruct drm_i915_private *i915 = to_i915(intel_encoder->base.dev);\n\tstruct drm_encoder *encoder = &intel_encoder->base;\n\tint ret;\n\n\tdrm_dbg_kms(&i915->drm, \"[CONNECTOR:%d:%s], [ENCODER:%d:%s]\\n\",\n\t\t    connector->base.id, connector->name,\n\t\t    encoder->base.id, encoder->name);\n\n\tif (IS_ERR_OR_NULL(state))\n\t\treturn;\n\n\tret = drm_atomic_helper_commit_duplicated_state(state, ctx);\n\tif (ret)\n\t\tdrm_dbg_kms(&i915->drm,\n\t\t\t    \"Couldn't release load detect pipe: %i\\n\", ret);\n\tdrm_atomic_state_put(state);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}