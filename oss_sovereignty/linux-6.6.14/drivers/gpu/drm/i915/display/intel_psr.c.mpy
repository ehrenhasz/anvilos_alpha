{
  "module_name": "intel_psr.c",
  "hash_id": "c35a908b1fadde510935f6799b95c48978e167876b21dcba3f6c3f26e5b5c4f1",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/i915/display/intel_psr.c",
  "human_readable_source": " \n\n#include <drm/drm_atomic_helper.h>\n#include <drm/drm_damage_helper.h>\n\n#include \"i915_drv.h\"\n#include \"i915_reg.h\"\n#include \"intel_atomic.h\"\n#include \"intel_crtc.h\"\n#include \"intel_de.h\"\n#include \"intel_display_types.h\"\n#include \"intel_dp.h\"\n#include \"intel_dp_aux.h\"\n#include \"intel_hdmi.h\"\n#include \"intel_psr.h\"\n#include \"intel_psr_regs.h\"\n#include \"intel_snps_phy.h\"\n#include \"skl_universal_plane.h\"\n\n \n\n \n\nstatic bool psr_global_enabled(struct intel_dp *intel_dp)\n{\n\tstruct intel_connector *connector = intel_dp->attached_connector;\n\tstruct drm_i915_private *i915 = dp_to_i915(intel_dp);\n\n\tswitch (intel_dp->psr.debug & I915_PSR_DEBUG_MODE_MASK) {\n\tcase I915_PSR_DEBUG_DEFAULT:\n\t\tif (i915->params.enable_psr == -1)\n\t\t\treturn connector->panel.vbt.psr.enable;\n\t\treturn i915->params.enable_psr;\n\tcase I915_PSR_DEBUG_DISABLE:\n\t\treturn false;\n\tdefault:\n\t\treturn true;\n\t}\n}\n\nstatic bool psr2_global_enabled(struct intel_dp *intel_dp)\n{\n\tstruct drm_i915_private *i915 = dp_to_i915(intel_dp);\n\n\tswitch (intel_dp->psr.debug & I915_PSR_DEBUG_MODE_MASK) {\n\tcase I915_PSR_DEBUG_DISABLE:\n\tcase I915_PSR_DEBUG_FORCE_PSR1:\n\t\treturn false;\n\tdefault:\n\t\tif (i915->params.enable_psr == 1)\n\t\t\treturn false;\n\t\treturn true;\n\t}\n}\n\nstatic u32 psr_irq_psr_error_bit_get(struct intel_dp *intel_dp)\n{\n\tstruct drm_i915_private *dev_priv = dp_to_i915(intel_dp);\n\n\treturn DISPLAY_VER(dev_priv) >= 12 ? TGL_PSR_ERROR :\n\t\tEDP_PSR_ERROR(intel_dp->psr.transcoder);\n}\n\nstatic u32 psr_irq_post_exit_bit_get(struct intel_dp *intel_dp)\n{\n\tstruct drm_i915_private *dev_priv = dp_to_i915(intel_dp);\n\n\treturn DISPLAY_VER(dev_priv) >= 12 ? TGL_PSR_POST_EXIT :\n\t\tEDP_PSR_POST_EXIT(intel_dp->psr.transcoder);\n}\n\nstatic u32 psr_irq_pre_entry_bit_get(struct intel_dp *intel_dp)\n{\n\tstruct drm_i915_private *dev_priv = dp_to_i915(intel_dp);\n\n\treturn DISPLAY_VER(dev_priv) >= 12 ? TGL_PSR_PRE_ENTRY :\n\t\tEDP_PSR_PRE_ENTRY(intel_dp->psr.transcoder);\n}\n\nstatic u32 psr_irq_mask_get(struct intel_dp *intel_dp)\n{\n\tstruct drm_i915_private *dev_priv = dp_to_i915(intel_dp);\n\n\treturn DISPLAY_VER(dev_priv) >= 12 ? TGL_PSR_MASK :\n\t\tEDP_PSR_MASK(intel_dp->psr.transcoder);\n}\n\nstatic i915_reg_t psr_ctl_reg(struct drm_i915_private *dev_priv,\n\t\t\t      enum transcoder cpu_transcoder)\n{\n\tif (DISPLAY_VER(dev_priv) >= 8)\n\t\treturn EDP_PSR_CTL(cpu_transcoder);\n\telse\n\t\treturn HSW_SRD_CTL;\n}\n\nstatic i915_reg_t psr_debug_reg(struct drm_i915_private *dev_priv,\n\t\t\t\tenum transcoder cpu_transcoder)\n{\n\tif (DISPLAY_VER(dev_priv) >= 8)\n\t\treturn EDP_PSR_DEBUG(cpu_transcoder);\n\telse\n\t\treturn HSW_SRD_DEBUG;\n}\n\nstatic i915_reg_t psr_perf_cnt_reg(struct drm_i915_private *dev_priv,\n\t\t\t\t   enum transcoder cpu_transcoder)\n{\n\tif (DISPLAY_VER(dev_priv) >= 8)\n\t\treturn EDP_PSR_PERF_CNT(cpu_transcoder);\n\telse\n\t\treturn HSW_SRD_PERF_CNT;\n}\n\nstatic i915_reg_t psr_status_reg(struct drm_i915_private *dev_priv,\n\t\t\t\t enum transcoder cpu_transcoder)\n{\n\tif (DISPLAY_VER(dev_priv) >= 8)\n\t\treturn EDP_PSR_STATUS(cpu_transcoder);\n\telse\n\t\treturn HSW_SRD_STATUS;\n}\n\nstatic i915_reg_t psr_imr_reg(struct drm_i915_private *dev_priv,\n\t\t\t      enum transcoder cpu_transcoder)\n{\n\tif (DISPLAY_VER(dev_priv) >= 12)\n\t\treturn TRANS_PSR_IMR(cpu_transcoder);\n\telse\n\t\treturn EDP_PSR_IMR;\n}\n\nstatic i915_reg_t psr_iir_reg(struct drm_i915_private *dev_priv,\n\t\t\t      enum transcoder cpu_transcoder)\n{\n\tif (DISPLAY_VER(dev_priv) >= 12)\n\t\treturn TRANS_PSR_IIR(cpu_transcoder);\n\telse\n\t\treturn EDP_PSR_IIR;\n}\n\nstatic i915_reg_t psr_aux_ctl_reg(struct drm_i915_private *dev_priv,\n\t\t\t\t  enum transcoder cpu_transcoder)\n{\n\tif (DISPLAY_VER(dev_priv) >= 8)\n\t\treturn EDP_PSR_AUX_CTL(cpu_transcoder);\n\telse\n\t\treturn HSW_SRD_AUX_CTL;\n}\n\nstatic i915_reg_t psr_aux_data_reg(struct drm_i915_private *dev_priv,\n\t\t\t\t   enum transcoder cpu_transcoder, int i)\n{\n\tif (DISPLAY_VER(dev_priv) >= 8)\n\t\treturn EDP_PSR_AUX_DATA(cpu_transcoder, i);\n\telse\n\t\treturn HSW_SRD_AUX_DATA(i);\n}\n\nstatic void psr_irq_control(struct intel_dp *intel_dp)\n{\n\tstruct drm_i915_private *dev_priv = dp_to_i915(intel_dp);\n\tenum transcoder cpu_transcoder = intel_dp->psr.transcoder;\n\tu32 mask;\n\n\tmask = psr_irq_psr_error_bit_get(intel_dp);\n\tif (intel_dp->psr.debug & I915_PSR_DEBUG_IRQ)\n\t\tmask |= psr_irq_post_exit_bit_get(intel_dp) |\n\t\t\tpsr_irq_pre_entry_bit_get(intel_dp);\n\n\tintel_de_rmw(dev_priv, psr_imr_reg(dev_priv, cpu_transcoder),\n\t\t     psr_irq_mask_get(intel_dp), ~mask);\n}\n\nstatic void psr_event_print(struct drm_i915_private *i915,\n\t\t\t    u32 val, bool psr2_enabled)\n{\n\tdrm_dbg_kms(&i915->drm, \"PSR exit events: 0x%x\\n\", val);\n\tif (val & PSR_EVENT_PSR2_WD_TIMER_EXPIRE)\n\t\tdrm_dbg_kms(&i915->drm, \"\\tPSR2 watchdog timer expired\\n\");\n\tif ((val & PSR_EVENT_PSR2_DISABLED) && psr2_enabled)\n\t\tdrm_dbg_kms(&i915->drm, \"\\tPSR2 disabled\\n\");\n\tif (val & PSR_EVENT_SU_DIRTY_FIFO_UNDERRUN)\n\t\tdrm_dbg_kms(&i915->drm, \"\\tSU dirty FIFO underrun\\n\");\n\tif (val & PSR_EVENT_SU_CRC_FIFO_UNDERRUN)\n\t\tdrm_dbg_kms(&i915->drm, \"\\tSU CRC FIFO underrun\\n\");\n\tif (val & PSR_EVENT_GRAPHICS_RESET)\n\t\tdrm_dbg_kms(&i915->drm, \"\\tGraphics reset\\n\");\n\tif (val & PSR_EVENT_PCH_INTERRUPT)\n\t\tdrm_dbg_kms(&i915->drm, \"\\tPCH interrupt\\n\");\n\tif (val & PSR_EVENT_MEMORY_UP)\n\t\tdrm_dbg_kms(&i915->drm, \"\\tMemory up\\n\");\n\tif (val & PSR_EVENT_FRONT_BUFFER_MODIFY)\n\t\tdrm_dbg_kms(&i915->drm, \"\\tFront buffer modification\\n\");\n\tif (val & PSR_EVENT_WD_TIMER_EXPIRE)\n\t\tdrm_dbg_kms(&i915->drm, \"\\tPSR watchdog timer expired\\n\");\n\tif (val & PSR_EVENT_PIPE_REGISTERS_UPDATE)\n\t\tdrm_dbg_kms(&i915->drm, \"\\tPIPE registers updated\\n\");\n\tif (val & PSR_EVENT_REGISTER_UPDATE)\n\t\tdrm_dbg_kms(&i915->drm, \"\\tRegister updated\\n\");\n\tif (val & PSR_EVENT_HDCP_ENABLE)\n\t\tdrm_dbg_kms(&i915->drm, \"\\tHDCP enabled\\n\");\n\tif (val & PSR_EVENT_KVMR_SESSION_ENABLE)\n\t\tdrm_dbg_kms(&i915->drm, \"\\tKVMR session enabled\\n\");\n\tif (val & PSR_EVENT_VBI_ENABLE)\n\t\tdrm_dbg_kms(&i915->drm, \"\\tVBI enabled\\n\");\n\tif (val & PSR_EVENT_LPSP_MODE_EXIT)\n\t\tdrm_dbg_kms(&i915->drm, \"\\tLPSP mode exited\\n\");\n\tif ((val & PSR_EVENT_PSR_DISABLE) && !psr2_enabled)\n\t\tdrm_dbg_kms(&i915->drm, \"\\tPSR disabled\\n\");\n}\n\nvoid intel_psr_irq_handler(struct intel_dp *intel_dp, u32 psr_iir)\n{\n\tstruct drm_i915_private *dev_priv = dp_to_i915(intel_dp);\n\tenum transcoder cpu_transcoder = intel_dp->psr.transcoder;\n\tktime_t time_ns =  ktime_get();\n\n\tif (psr_iir & psr_irq_pre_entry_bit_get(intel_dp)) {\n\t\tintel_dp->psr.last_entry_attempt = time_ns;\n\t\tdrm_dbg_kms(&dev_priv->drm,\n\t\t\t    \"[transcoder %s] PSR entry attempt in 2 vblanks\\n\",\n\t\t\t    transcoder_name(cpu_transcoder));\n\t}\n\n\tif (psr_iir & psr_irq_post_exit_bit_get(intel_dp)) {\n\t\tintel_dp->psr.last_exit = time_ns;\n\t\tdrm_dbg_kms(&dev_priv->drm,\n\t\t\t    \"[transcoder %s] PSR exit completed\\n\",\n\t\t\t    transcoder_name(cpu_transcoder));\n\n\t\tif (DISPLAY_VER(dev_priv) >= 9) {\n\t\t\tu32 val;\n\n\t\t\tval = intel_de_rmw(dev_priv, PSR_EVENT(cpu_transcoder), 0, 0);\n\n\t\t\tpsr_event_print(dev_priv, val, intel_dp->psr.psr2_enabled);\n\t\t}\n\t}\n\n\tif (psr_iir & psr_irq_psr_error_bit_get(intel_dp)) {\n\t\tdrm_warn(&dev_priv->drm, \"[transcoder %s] PSR aux error\\n\",\n\t\t\t transcoder_name(cpu_transcoder));\n\n\t\tintel_dp->psr.irq_aux_error = true;\n\n\t\t \n\t\tintel_de_rmw(dev_priv, psr_imr_reg(dev_priv, cpu_transcoder),\n\t\t\t     0, psr_irq_psr_error_bit_get(intel_dp));\n\n\t\tqueue_work(dev_priv->unordered_wq, &intel_dp->psr.work);\n\t}\n}\n\nstatic bool intel_dp_get_alpm_status(struct intel_dp *intel_dp)\n{\n\tu8 alpm_caps = 0;\n\n\tif (drm_dp_dpcd_readb(&intel_dp->aux, DP_RECEIVER_ALPM_CAP,\n\t\t\t      &alpm_caps) != 1)\n\t\treturn false;\n\treturn alpm_caps & DP_ALPM_CAP;\n}\n\nstatic u8 intel_dp_get_sink_sync_latency(struct intel_dp *intel_dp)\n{\n\tstruct drm_i915_private *i915 = dp_to_i915(intel_dp);\n\tu8 val = 8;  \n\n\tif (drm_dp_dpcd_readb(&intel_dp->aux,\n\t\t\t      DP_SYNCHRONIZATION_LATENCY_IN_SINK, &val) == 1)\n\t\tval &= DP_MAX_RESYNC_FRAME_COUNT_MASK;\n\telse\n\t\tdrm_dbg_kms(&i915->drm,\n\t\t\t    \"Unable to get sink synchronization latency, assuming 8 frames\\n\");\n\treturn val;\n}\n\nstatic void intel_dp_get_su_granularity(struct intel_dp *intel_dp)\n{\n\tstruct drm_i915_private *i915 = dp_to_i915(intel_dp);\n\tssize_t r;\n\tu16 w;\n\tu8 y;\n\n\t \n\tif (!(intel_dp->psr_dpcd[1] & DP_PSR2_SU_GRANULARITY_REQUIRED)) {\n\t\t \n\t\tw = 4;\n\t\ty = 4;\n\t\tgoto exit;\n\t}\n\n\tr = drm_dp_dpcd_read(&intel_dp->aux, DP_PSR2_SU_X_GRANULARITY, &w, 2);\n\tif (r != 2)\n\t\tdrm_dbg_kms(&i915->drm,\n\t\t\t    \"Unable to read DP_PSR2_SU_X_GRANULARITY\\n\");\n\t \n\tif (r != 2 || w == 0)\n\t\tw = 4;\n\n\tr = drm_dp_dpcd_read(&intel_dp->aux, DP_PSR2_SU_Y_GRANULARITY, &y, 1);\n\tif (r != 1) {\n\t\tdrm_dbg_kms(&i915->drm,\n\t\t\t    \"Unable to read DP_PSR2_SU_Y_GRANULARITY\\n\");\n\t\ty = 4;\n\t}\n\tif (y == 0)\n\t\ty = 1;\n\nexit:\n\tintel_dp->psr.su_w_granularity = w;\n\tintel_dp->psr.su_y_granularity = y;\n}\n\nvoid intel_psr_init_dpcd(struct intel_dp *intel_dp)\n{\n\tstruct drm_i915_private *dev_priv =\n\t\tto_i915(dp_to_dig_port(intel_dp)->base.base.dev);\n\n\tdrm_dp_dpcd_read(&intel_dp->aux, DP_PSR_SUPPORT, intel_dp->psr_dpcd,\n\t\t\t sizeof(intel_dp->psr_dpcd));\n\n\tif (!intel_dp->psr_dpcd[0])\n\t\treturn;\n\tdrm_dbg_kms(&dev_priv->drm, \"eDP panel supports PSR version %x\\n\",\n\t\t    intel_dp->psr_dpcd[0]);\n\n\tif (drm_dp_has_quirk(&intel_dp->desc, DP_DPCD_QUIRK_NO_PSR)) {\n\t\tdrm_dbg_kms(&dev_priv->drm,\n\t\t\t    \"PSR support not currently available for this panel\\n\");\n\t\treturn;\n\t}\n\n\tif (!(intel_dp->edp_dpcd[1] & DP_EDP_SET_POWER_CAP)) {\n\t\tdrm_dbg_kms(&dev_priv->drm,\n\t\t\t    \"Panel lacks power state control, PSR cannot be enabled\\n\");\n\t\treturn;\n\t}\n\n\tintel_dp->psr.sink_support = true;\n\tintel_dp->psr.sink_sync_latency =\n\t\tintel_dp_get_sink_sync_latency(intel_dp);\n\n\tif (DISPLAY_VER(dev_priv) >= 9 &&\n\t    (intel_dp->psr_dpcd[0] == DP_PSR2_WITH_Y_COORD_IS_SUPPORTED)) {\n\t\tbool y_req = intel_dp->psr_dpcd[1] &\n\t\t\t     DP_PSR2_SU_Y_COORDINATE_REQUIRED;\n\t\tbool alpm = intel_dp_get_alpm_status(intel_dp);\n\n\t\t \n\t\tintel_dp->psr.sink_psr2_support = y_req && alpm;\n\t\tdrm_dbg_kms(&dev_priv->drm, \"PSR2 %ssupported\\n\",\n\t\t\t    intel_dp->psr.sink_psr2_support ? \"\" : \"not \");\n\n\t\tif (intel_dp->psr.sink_psr2_support) {\n\t\t\tintel_dp->psr.colorimetry_support =\n\t\t\t\tintel_dp_get_colorimetry_status(intel_dp);\n\t\t\tintel_dp_get_su_granularity(intel_dp);\n\t\t}\n\t}\n}\n\nstatic void hsw_psr_setup_aux(struct intel_dp *intel_dp)\n{\n\tstruct drm_i915_private *dev_priv = dp_to_i915(intel_dp);\n\tenum transcoder cpu_transcoder = intel_dp->psr.transcoder;\n\tu32 aux_clock_divider, aux_ctl;\n\t \n\tstatic const u8 aux_msg[] = {\n\t\t[0] = (DP_AUX_NATIVE_WRITE << 4) | ((DP_SET_POWER >> 16) & 0xf),\n\t\t[1] = (DP_SET_POWER >> 8) & 0xff,\n\t\t[2] = DP_SET_POWER & 0xff,\n\t\t[3] = 1 - 1,\n\t\t[4] = DP_SET_POWER_D0,\n\t};\n\tint i;\n\n\tBUILD_BUG_ON(sizeof(aux_msg) > 20);\n\tfor (i = 0; i < sizeof(aux_msg); i += 4)\n\t\tintel_de_write(dev_priv,\n\t\t\t       psr_aux_data_reg(dev_priv, cpu_transcoder, i >> 2),\n\t\t\t       intel_dp_aux_pack(&aux_msg[i], sizeof(aux_msg) - i));\n\n\taux_clock_divider = intel_dp->get_aux_clock_divider(intel_dp, 0);\n\n\t \n\taux_ctl = intel_dp->get_aux_send_ctl(intel_dp, sizeof(aux_msg),\n\t\t\t\t\t     aux_clock_divider);\n\n\t \n\taux_ctl &= EDP_PSR_AUX_CTL_TIME_OUT_MASK |\n\t\tEDP_PSR_AUX_CTL_MESSAGE_SIZE_MASK |\n\t\tEDP_PSR_AUX_CTL_PRECHARGE_2US_MASK |\n\t\tEDP_PSR_AUX_CTL_BIT_CLOCK_2X_MASK;\n\n\tintel_de_write(dev_priv, psr_aux_ctl_reg(dev_priv, cpu_transcoder),\n\t\t       aux_ctl);\n}\n\nstatic void intel_psr_enable_sink(struct intel_dp *intel_dp)\n{\n\tstruct drm_i915_private *dev_priv = dp_to_i915(intel_dp);\n\tu8 dpcd_val = DP_PSR_ENABLE;\n\n\t \n\tif (intel_dp->psr.psr2_enabled) {\n\t\tdrm_dp_dpcd_writeb(&intel_dp->aux, DP_RECEIVER_ALPM_CONFIG,\n\t\t\t\t   DP_ALPM_ENABLE |\n\t\t\t\t   DP_ALPM_LOCK_ERROR_IRQ_HPD_ENABLE);\n\n\t\tdpcd_val |= DP_PSR_ENABLE_PSR2 | DP_PSR_IRQ_HPD_WITH_CRC_ERRORS;\n\t} else {\n\t\tif (intel_dp->psr.link_standby)\n\t\t\tdpcd_val |= DP_PSR_MAIN_LINK_ACTIVE;\n\n\t\tif (DISPLAY_VER(dev_priv) >= 8)\n\t\t\tdpcd_val |= DP_PSR_CRC_VERIFICATION;\n\t}\n\n\tif (intel_dp->psr.req_psr2_sdp_prior_scanline)\n\t\tdpcd_val |= DP_PSR_SU_REGION_SCANLINE_CAPTURE;\n\n\tdrm_dp_dpcd_writeb(&intel_dp->aux, DP_PSR_EN_CFG, dpcd_val);\n\n\tdrm_dp_dpcd_writeb(&intel_dp->aux, DP_SET_POWER, DP_SET_POWER_D0);\n}\n\nstatic u32 intel_psr1_get_tp_time(struct intel_dp *intel_dp)\n{\n\tstruct intel_connector *connector = intel_dp->attached_connector;\n\tstruct drm_i915_private *dev_priv = dp_to_i915(intel_dp);\n\tu32 val = 0;\n\n\tif (DISPLAY_VER(dev_priv) >= 11)\n\t\tval |= EDP_PSR_TP4_TIME_0us;\n\n\tif (dev_priv->params.psr_safest_params) {\n\t\tval |= EDP_PSR_TP1_TIME_2500us;\n\t\tval |= EDP_PSR_TP2_TP3_TIME_2500us;\n\t\tgoto check_tp3_sel;\n\t}\n\n\tif (connector->panel.vbt.psr.tp1_wakeup_time_us == 0)\n\t\tval |= EDP_PSR_TP1_TIME_0us;\n\telse if (connector->panel.vbt.psr.tp1_wakeup_time_us <= 100)\n\t\tval |= EDP_PSR_TP1_TIME_100us;\n\telse if (connector->panel.vbt.psr.tp1_wakeup_time_us <= 500)\n\t\tval |= EDP_PSR_TP1_TIME_500us;\n\telse\n\t\tval |= EDP_PSR_TP1_TIME_2500us;\n\n\tif (connector->panel.vbt.psr.tp2_tp3_wakeup_time_us == 0)\n\t\tval |= EDP_PSR_TP2_TP3_TIME_0us;\n\telse if (connector->panel.vbt.psr.tp2_tp3_wakeup_time_us <= 100)\n\t\tval |= EDP_PSR_TP2_TP3_TIME_100us;\n\telse if (connector->panel.vbt.psr.tp2_tp3_wakeup_time_us <= 500)\n\t\tval |= EDP_PSR_TP2_TP3_TIME_500us;\n\telse\n\t\tval |= EDP_PSR_TP2_TP3_TIME_2500us;\n\n\t \n\tif (DISPLAY_VER(dev_priv) < 9 &&\n\t    connector->panel.vbt.psr.tp1_wakeup_time_us == 0 &&\n\t    connector->panel.vbt.psr.tp2_tp3_wakeup_time_us == 0)\n\t\tval |= EDP_PSR_TP2_TP3_TIME_100us;\n\ncheck_tp3_sel:\n\tif (intel_dp_source_supports_tps3(dev_priv) &&\n\t    drm_dp_tps3_supported(intel_dp->dpcd))\n\t\tval |= EDP_PSR_TP_TP1_TP3;\n\telse\n\t\tval |= EDP_PSR_TP_TP1_TP2;\n\n\treturn val;\n}\n\nstatic u8 psr_compute_idle_frames(struct intel_dp *intel_dp)\n{\n\tstruct intel_connector *connector = intel_dp->attached_connector;\n\tstruct drm_i915_private *dev_priv = dp_to_i915(intel_dp);\n\tint idle_frames;\n\n\t \n\tidle_frames = max(6, connector->panel.vbt.psr.idle_frames);\n\tidle_frames = max(idle_frames, intel_dp->psr.sink_sync_latency + 1);\n\n\tif (drm_WARN_ON(&dev_priv->drm, idle_frames > 0xf))\n\t\tidle_frames = 0xf;\n\n\treturn idle_frames;\n}\n\nstatic void hsw_activate_psr1(struct intel_dp *intel_dp)\n{\n\tstruct drm_i915_private *dev_priv = dp_to_i915(intel_dp);\n\tenum transcoder cpu_transcoder = intel_dp->psr.transcoder;\n\tu32 max_sleep_time = 0x1f;\n\tu32 val = EDP_PSR_ENABLE;\n\n\tval |= EDP_PSR_IDLE_FRAMES(psr_compute_idle_frames(intel_dp));\n\n\tval |= EDP_PSR_MAX_SLEEP_TIME(max_sleep_time);\n\tif (IS_HASWELL(dev_priv))\n\t\tval |= EDP_PSR_MIN_LINK_ENTRY_TIME_8_LINES;\n\n\tif (intel_dp->psr.link_standby)\n\t\tval |= EDP_PSR_LINK_STANDBY;\n\n\tval |= intel_psr1_get_tp_time(intel_dp);\n\n\tif (DISPLAY_VER(dev_priv) >= 8)\n\t\tval |= EDP_PSR_CRC_ENABLE;\n\n\tintel_de_rmw(dev_priv, psr_ctl_reg(dev_priv, cpu_transcoder),\n\t\t     ~EDP_PSR_RESTORE_PSR_ACTIVE_CTX_MASK, val);\n}\n\nstatic u32 intel_psr2_get_tp_time(struct intel_dp *intel_dp)\n{\n\tstruct intel_connector *connector = intel_dp->attached_connector;\n\tstruct drm_i915_private *dev_priv = dp_to_i915(intel_dp);\n\tu32 val = 0;\n\n\tif (dev_priv->params.psr_safest_params)\n\t\treturn EDP_PSR2_TP2_TIME_2500us;\n\n\tif (connector->panel.vbt.psr.psr2_tp2_tp3_wakeup_time_us >= 0 &&\n\t    connector->panel.vbt.psr.psr2_tp2_tp3_wakeup_time_us <= 50)\n\t\tval |= EDP_PSR2_TP2_TIME_50us;\n\telse if (connector->panel.vbt.psr.psr2_tp2_tp3_wakeup_time_us <= 100)\n\t\tval |= EDP_PSR2_TP2_TIME_100us;\n\telse if (connector->panel.vbt.psr.psr2_tp2_tp3_wakeup_time_us <= 500)\n\t\tval |= EDP_PSR2_TP2_TIME_500us;\n\telse\n\t\tval |= EDP_PSR2_TP2_TIME_2500us;\n\n\treturn val;\n}\n\nstatic int psr2_block_count_lines(struct intel_dp *intel_dp)\n{\n\treturn intel_dp->psr.io_wake_lines < 9 &&\n\t\tintel_dp->psr.fast_wake_lines < 9 ? 8 : 12;\n}\n\nstatic int psr2_block_count(struct intel_dp *intel_dp)\n{\n\treturn psr2_block_count_lines(intel_dp) / 4;\n}\n\nstatic void hsw_activate_psr2(struct intel_dp *intel_dp)\n{\n\tstruct drm_i915_private *dev_priv = dp_to_i915(intel_dp);\n\tenum transcoder cpu_transcoder = intel_dp->psr.transcoder;\n\tu32 val = EDP_PSR2_ENABLE;\n\n\tval |= EDP_PSR2_IDLE_FRAMES(psr_compute_idle_frames(intel_dp));\n\n\tif (DISPLAY_VER(dev_priv) <= 13 && !IS_ALDERLAKE_P(dev_priv))\n\t\tval |= EDP_SU_TRACK_ENABLE;\n\n\tif (DISPLAY_VER(dev_priv) >= 10 && DISPLAY_VER(dev_priv) <= 12)\n\t\tval |= EDP_Y_COORDINATE_ENABLE;\n\n\tval |= EDP_PSR2_FRAME_BEFORE_SU(max_t(u8, intel_dp->psr.sink_sync_latency + 1, 2));\n\tval |= intel_psr2_get_tp_time(intel_dp);\n\n\tif (DISPLAY_VER(dev_priv) >= 12) {\n\t\tif (psr2_block_count(intel_dp) > 2)\n\t\t\tval |= TGL_EDP_PSR2_BLOCK_COUNT_NUM_3;\n\t\telse\n\t\t\tval |= TGL_EDP_PSR2_BLOCK_COUNT_NUM_2;\n\t}\n\n\t \n\tif (IS_ALDERLAKE_P(dev_priv) && IS_DISPLAY_STEP(dev_priv, STEP_A0, STEP_E0)) {\n\t\tstatic const u8 map[] = {\n\t\t\t2,  \n\t\t\t1,  \n\t\t\t0,  \n\t\t\t3,  \n\t\t\t6,  \n\t\t\t5,  \n\t\t\t4,  \n\t\t\t7,  \n\t\t};\n\t\t \n\t\tint tmp;\n\n\t\ttmp = map[intel_dp->psr.io_wake_lines - TGL_EDP_PSR2_IO_BUFFER_WAKE_MIN_LINES];\n\t\tval |= TGL_EDP_PSR2_IO_BUFFER_WAKE(tmp + TGL_EDP_PSR2_IO_BUFFER_WAKE_MIN_LINES);\n\n\t\ttmp = map[intel_dp->psr.fast_wake_lines - TGL_EDP_PSR2_FAST_WAKE_MIN_LINES];\n\t\tval |= TGL_EDP_PSR2_FAST_WAKE(tmp + TGL_EDP_PSR2_FAST_WAKE_MIN_LINES);\n\t} else if (DISPLAY_VER(dev_priv) >= 12) {\n\t\tval |= TGL_EDP_PSR2_IO_BUFFER_WAKE(intel_dp->psr.io_wake_lines);\n\t\tval |= TGL_EDP_PSR2_FAST_WAKE(intel_dp->psr.fast_wake_lines);\n\t} else if (DISPLAY_VER(dev_priv) >= 9) {\n\t\tval |= EDP_PSR2_IO_BUFFER_WAKE(intel_dp->psr.io_wake_lines);\n\t\tval |= EDP_PSR2_FAST_WAKE(intel_dp->psr.fast_wake_lines);\n\t}\n\n\tif (intel_dp->psr.req_psr2_sdp_prior_scanline)\n\t\tval |= EDP_PSR2_SU_SDP_SCANLINE;\n\n\tif (intel_dp->psr.psr2_sel_fetch_enabled) {\n\t\tu32 tmp;\n\n\t\ttmp = intel_de_read(dev_priv, PSR2_MAN_TRK_CTL(cpu_transcoder));\n\t\tdrm_WARN_ON(&dev_priv->drm, !(tmp & PSR2_MAN_TRK_CTL_ENABLE));\n\t} else if (HAS_PSR2_SEL_FETCH(dev_priv)) {\n\t\tintel_de_write(dev_priv, PSR2_MAN_TRK_CTL(cpu_transcoder), 0);\n\t}\n\n\t \n\tintel_de_write(dev_priv, psr_ctl_reg(dev_priv, cpu_transcoder), 0);\n\n\tintel_de_write(dev_priv, EDP_PSR2_CTL(cpu_transcoder), val);\n}\n\nstatic bool\ntranscoder_has_psr2(struct drm_i915_private *dev_priv, enum transcoder cpu_transcoder)\n{\n\tif (IS_ALDERLAKE_P(dev_priv) || DISPLAY_VER(dev_priv) >= 14)\n\t\treturn cpu_transcoder == TRANSCODER_A || cpu_transcoder == TRANSCODER_B;\n\telse if (DISPLAY_VER(dev_priv) >= 12)\n\t\treturn cpu_transcoder == TRANSCODER_A;\n\telse if (DISPLAY_VER(dev_priv) >= 9)\n\t\treturn cpu_transcoder == TRANSCODER_EDP;\n\telse\n\t\treturn false;\n}\n\nstatic u32 intel_get_frame_time_us(const struct intel_crtc_state *cstate)\n{\n\tif (!cstate || !cstate->hw.active)\n\t\treturn 0;\n\n\treturn DIV_ROUND_UP(1000 * 1000,\n\t\t\t    drm_mode_vrefresh(&cstate->hw.adjusted_mode));\n}\n\nstatic void psr2_program_idle_frames(struct intel_dp *intel_dp,\n\t\t\t\t     u32 idle_frames)\n{\n\tstruct drm_i915_private *dev_priv = dp_to_i915(intel_dp);\n\tenum transcoder cpu_transcoder = intel_dp->psr.transcoder;\n\n\tintel_de_rmw(dev_priv, EDP_PSR2_CTL(cpu_transcoder),\n\t\t     EDP_PSR2_IDLE_FRAMES_MASK,\n\t\t     EDP_PSR2_IDLE_FRAMES(idle_frames));\n}\n\nstatic void tgl_psr2_enable_dc3co(struct intel_dp *intel_dp)\n{\n\tstruct drm_i915_private *dev_priv = dp_to_i915(intel_dp);\n\n\tpsr2_program_idle_frames(intel_dp, 0);\n\tintel_display_power_set_target_dc_state(dev_priv, DC_STATE_EN_DC3CO);\n}\n\nstatic void tgl_psr2_disable_dc3co(struct intel_dp *intel_dp)\n{\n\tstruct drm_i915_private *dev_priv = dp_to_i915(intel_dp);\n\n\tintel_display_power_set_target_dc_state(dev_priv, DC_STATE_EN_UPTO_DC6);\n\tpsr2_program_idle_frames(intel_dp, psr_compute_idle_frames(intel_dp));\n}\n\nstatic void tgl_dc3co_disable_work(struct work_struct *work)\n{\n\tstruct intel_dp *intel_dp =\n\t\tcontainer_of(work, typeof(*intel_dp), psr.dc3co_work.work);\n\n\tmutex_lock(&intel_dp->psr.lock);\n\t \n\tif (delayed_work_pending(&intel_dp->psr.dc3co_work))\n\t\tgoto unlock;\n\n\ttgl_psr2_disable_dc3co(intel_dp);\nunlock:\n\tmutex_unlock(&intel_dp->psr.lock);\n}\n\nstatic void tgl_disallow_dc3co_on_psr2_exit(struct intel_dp *intel_dp)\n{\n\tif (!intel_dp->psr.dc3co_exitline)\n\t\treturn;\n\n\tcancel_delayed_work(&intel_dp->psr.dc3co_work);\n\t \n\ttgl_psr2_disable_dc3co(intel_dp);\n}\n\nstatic bool\ndc3co_is_pipe_port_compatible(struct intel_dp *intel_dp,\n\t\t\t      struct intel_crtc_state *crtc_state)\n{\n\tstruct intel_digital_port *dig_port = dp_to_dig_port(intel_dp);\n\tenum pipe pipe = to_intel_crtc(crtc_state->uapi.crtc)->pipe;\n\tstruct drm_i915_private *dev_priv = dp_to_i915(intel_dp);\n\tenum port port = dig_port->base.port;\n\n\tif (IS_ALDERLAKE_P(dev_priv) || DISPLAY_VER(dev_priv) >= 14)\n\t\treturn pipe <= PIPE_B && port <= PORT_B;\n\telse\n\t\treturn pipe == PIPE_A && port == PORT_A;\n}\n\nstatic void\ntgl_dc3co_exitline_compute_config(struct intel_dp *intel_dp,\n\t\t\t\t  struct intel_crtc_state *crtc_state)\n{\n\tconst u32 crtc_vdisplay = crtc_state->uapi.adjusted_mode.crtc_vdisplay;\n\tstruct drm_i915_private *dev_priv = dp_to_i915(intel_dp);\n\tstruct i915_power_domains *power_domains = &dev_priv->display.power.domains;\n\tu32 exit_scanlines;\n\n\t \n\treturn;\n\n\t \n\tif (crtc_state->enable_psr2_sel_fetch)\n\t\treturn;\n\n\tif (!(power_domains->allowed_dc_mask & DC_STATE_EN_DC3CO))\n\t\treturn;\n\n\tif (!dc3co_is_pipe_port_compatible(intel_dp, crtc_state))\n\t\treturn;\n\n\t \n\tif (IS_ALDERLAKE_P(dev_priv) && IS_DISPLAY_STEP(dev_priv, STEP_A0, STEP_B0))\n\t\treturn;\n\n\t \n\texit_scanlines =\n\t\tintel_usecs_to_scanlines(&crtc_state->uapi.adjusted_mode, 200) + 1;\n\n\tif (drm_WARN_ON(&dev_priv->drm, exit_scanlines > crtc_vdisplay))\n\t\treturn;\n\n\tcrtc_state->dc3co_exitline = crtc_vdisplay - exit_scanlines;\n}\n\nstatic bool intel_psr2_sel_fetch_config_valid(struct intel_dp *intel_dp,\n\t\t\t\t\t      struct intel_crtc_state *crtc_state)\n{\n\tstruct drm_i915_private *dev_priv = dp_to_i915(intel_dp);\n\n\tif (!dev_priv->params.enable_psr2_sel_fetch &&\n\t    intel_dp->psr.debug != I915_PSR_DEBUG_ENABLE_SEL_FETCH) {\n\t\tdrm_dbg_kms(&dev_priv->drm,\n\t\t\t    \"PSR2 sel fetch not enabled, disabled by parameter\\n\");\n\t\treturn false;\n\t}\n\n\tif (crtc_state->uapi.async_flip) {\n\t\tdrm_dbg_kms(&dev_priv->drm,\n\t\t\t    \"PSR2 sel fetch not enabled, async flip enabled\\n\");\n\t\treturn false;\n\t}\n\n\treturn crtc_state->enable_psr2_sel_fetch = true;\n}\n\nstatic bool psr2_granularity_check(struct intel_dp *intel_dp,\n\t\t\t\t   struct intel_crtc_state *crtc_state)\n{\n\tstruct drm_i915_private *dev_priv = dp_to_i915(intel_dp);\n\tconst struct drm_dsc_config *vdsc_cfg = &crtc_state->dsc.config;\n\tconst int crtc_hdisplay = crtc_state->hw.adjusted_mode.crtc_hdisplay;\n\tconst int crtc_vdisplay = crtc_state->hw.adjusted_mode.crtc_vdisplay;\n\tu16 y_granularity = 0;\n\n\t \n\tif (crtc_hdisplay % intel_dp->psr.su_w_granularity)\n\t\treturn false;\n\n\tif (crtc_vdisplay % intel_dp->psr.su_y_granularity)\n\t\treturn false;\n\n\t \n\tif (!crtc_state->enable_psr2_sel_fetch)\n\t\treturn intel_dp->psr.su_y_granularity == 4;\n\n\t \n\tif (IS_ALDERLAKE_P(dev_priv) || DISPLAY_VER(dev_priv) >= 14)\n\t\ty_granularity = intel_dp->psr.su_y_granularity;\n\telse if (intel_dp->psr.su_y_granularity <= 2)\n\t\ty_granularity = 4;\n\telse if ((intel_dp->psr.su_y_granularity % 4) == 0)\n\t\ty_granularity = intel_dp->psr.su_y_granularity;\n\n\tif (y_granularity == 0 || crtc_vdisplay % y_granularity)\n\t\treturn false;\n\n\tif (crtc_state->dsc.compression_enable &&\n\t    vdsc_cfg->slice_height % y_granularity)\n\t\treturn false;\n\n\tcrtc_state->su_y_granularity = y_granularity;\n\treturn true;\n}\n\nstatic bool _compute_psr2_sdp_prior_scanline_indication(struct intel_dp *intel_dp,\n\t\t\t\t\t\t\tstruct intel_crtc_state *crtc_state)\n{\n\tconst struct drm_display_mode *adjusted_mode = &crtc_state->uapi.adjusted_mode;\n\tstruct drm_i915_private *dev_priv = dp_to_i915(intel_dp);\n\tu32 hblank_total, hblank_ns, req_ns;\n\n\thblank_total = adjusted_mode->crtc_hblank_end - adjusted_mode->crtc_hblank_start;\n\thblank_ns = div_u64(1000000ULL * hblank_total, adjusted_mode->crtc_clock);\n\n\t \n\treq_ns = ((60 / crtc_state->lane_count) + 11) * 1000 / (crtc_state->port_clock / 1000);\n\n\tif ((hblank_ns - req_ns) > 100)\n\t\treturn true;\n\n\t \n\tif (DISPLAY_VER(dev_priv) <= 13 || intel_dp->edp_dpcd[0] < DP_EDP_14b)\n\t\treturn false;\n\n\tcrtc_state->req_psr2_sdp_prior_scanline = true;\n\treturn true;\n}\n\nstatic bool _compute_psr2_wake_times(struct intel_dp *intel_dp,\n\t\t\t\t     struct intel_crtc_state *crtc_state)\n{\n\tstruct drm_i915_private *i915 = dp_to_i915(intel_dp);\n\tint io_wake_lines, io_wake_time, fast_wake_lines, fast_wake_time;\n\tu8 max_wake_lines;\n\n\tif (DISPLAY_VER(i915) >= 12) {\n\t\tio_wake_time = 42;\n\t\t \n\t\tfast_wake_time = 45;\n\t\tmax_wake_lines = 12;\n\t} else {\n\t\tio_wake_time = 50;\n\t\tfast_wake_time = 32;\n\t\tmax_wake_lines = 8;\n\t}\n\n\tio_wake_lines = intel_usecs_to_scanlines(\n\t\t&crtc_state->hw.adjusted_mode, io_wake_time);\n\tfast_wake_lines = intel_usecs_to_scanlines(\n\t\t&crtc_state->hw.adjusted_mode, fast_wake_time);\n\n\tif (io_wake_lines > max_wake_lines ||\n\t    fast_wake_lines > max_wake_lines)\n\t\treturn false;\n\n\tif (i915->params.psr_safest_params)\n\t\tio_wake_lines = fast_wake_lines = max_wake_lines;\n\n\t \n\tintel_dp->psr.io_wake_lines = max(io_wake_lines, 7);\n\tintel_dp->psr.fast_wake_lines = max(fast_wake_lines, 7);\n\n\treturn true;\n}\n\nstatic bool intel_psr2_config_valid(struct intel_dp *intel_dp,\n\t\t\t\t    struct intel_crtc_state *crtc_state)\n{\n\tstruct drm_i915_private *dev_priv = dp_to_i915(intel_dp);\n\tint crtc_hdisplay = crtc_state->hw.adjusted_mode.crtc_hdisplay;\n\tint crtc_vdisplay = crtc_state->hw.adjusted_mode.crtc_vdisplay;\n\tint psr_max_h = 0, psr_max_v = 0, max_bpp = 0;\n\n\tif (!intel_dp->psr.sink_psr2_support)\n\t\treturn false;\n\n\t \n\tif (IS_JASPERLAKE(dev_priv) || IS_ELKHARTLAKE(dev_priv)) {\n\t\tdrm_dbg_kms(&dev_priv->drm, \"PSR2 not supported by phy\\n\");\n\t\treturn false;\n\t}\n\n\t \n\tif (IS_ROCKETLAKE(dev_priv) || IS_ALDERLAKE_S(dev_priv) ||\n\t    IS_DG2(dev_priv)) {\n\t\tdrm_dbg_kms(&dev_priv->drm, \"PSR2 is defeatured for this platform\\n\");\n\t\treturn false;\n\t}\n\n\tif (IS_ALDERLAKE_P(dev_priv) && IS_DISPLAY_STEP(dev_priv, STEP_A0, STEP_B0)) {\n\t\tdrm_dbg_kms(&dev_priv->drm, \"PSR2 not completely functional in this stepping\\n\");\n\t\treturn false;\n\t}\n\n\tif (!transcoder_has_psr2(dev_priv, crtc_state->cpu_transcoder)) {\n\t\tdrm_dbg_kms(&dev_priv->drm,\n\t\t\t    \"PSR2 not supported in transcoder %s\\n\",\n\t\t\t    transcoder_name(crtc_state->cpu_transcoder));\n\t\treturn false;\n\t}\n\n\tif (!psr2_global_enabled(intel_dp)) {\n\t\tdrm_dbg_kms(&dev_priv->drm, \"PSR2 disabled by flag\\n\");\n\t\treturn false;\n\t}\n\n\t \n\tif (crtc_state->dsc.compression_enable &&\n\t    (DISPLAY_VER(dev_priv) <= 13 && !IS_ALDERLAKE_P(dev_priv))) {\n\t\tdrm_dbg_kms(&dev_priv->drm,\n\t\t\t    \"PSR2 cannot be enabled since DSC is enabled\\n\");\n\t\treturn false;\n\t}\n\n\tif (crtc_state->crc_enabled) {\n\t\tdrm_dbg_kms(&dev_priv->drm,\n\t\t\t    \"PSR2 not enabled because it would inhibit pipe CRC calculation\\n\");\n\t\treturn false;\n\t}\n\n\tif (DISPLAY_VER(dev_priv) >= 12) {\n\t\tpsr_max_h = 5120;\n\t\tpsr_max_v = 3200;\n\t\tmax_bpp = 30;\n\t} else if (DISPLAY_VER(dev_priv) >= 10) {\n\t\tpsr_max_h = 4096;\n\t\tpsr_max_v = 2304;\n\t\tmax_bpp = 24;\n\t} else if (DISPLAY_VER(dev_priv) == 9) {\n\t\tpsr_max_h = 3640;\n\t\tpsr_max_v = 2304;\n\t\tmax_bpp = 24;\n\t}\n\n\tif (crtc_state->pipe_bpp > max_bpp) {\n\t\tdrm_dbg_kms(&dev_priv->drm,\n\t\t\t    \"PSR2 not enabled, pipe bpp %d > max supported %d\\n\",\n\t\t\t    crtc_state->pipe_bpp, max_bpp);\n\t\treturn false;\n\t}\n\n\t \n\tif (crtc_state->vrr.enable &&\n\t    IS_ALDERLAKE_P(dev_priv) && IS_DISPLAY_STEP(dev_priv, STEP_A0, STEP_B0)) {\n\t\tdrm_dbg_kms(&dev_priv->drm,\n\t\t\t    \"PSR2 not enabled, not compatible with HW stepping + VRR\\n\");\n\t\treturn false;\n\t}\n\n\tif (!_compute_psr2_sdp_prior_scanline_indication(intel_dp, crtc_state)) {\n\t\tdrm_dbg_kms(&dev_priv->drm,\n\t\t\t    \"PSR2 not enabled, PSR2 SDP indication do not fit in hblank\\n\");\n\t\treturn false;\n\t}\n\n\tif (!_compute_psr2_wake_times(intel_dp, crtc_state)) {\n\t\tdrm_dbg_kms(&dev_priv->drm,\n\t\t\t    \"PSR2 not enabled, Unable to use long enough wake times\\n\");\n\t\treturn false;\n\t}\n\n\t \n\tif (crtc_state->hw.adjusted_mode.crtc_vblank_end -\n\t    crtc_state->hw.adjusted_mode.crtc_vblank_start <\n\t    psr2_block_count_lines(intel_dp)) {\n\t\tdrm_dbg_kms(&dev_priv->drm,\n\t\t\t    \"PSR2 not enabled, too short vblank time\\n\");\n\t\treturn false;\n\t}\n\n\tif (HAS_PSR2_SEL_FETCH(dev_priv)) {\n\t\tif (!intel_psr2_sel_fetch_config_valid(intel_dp, crtc_state) &&\n\t\t    !HAS_PSR_HW_TRACKING(dev_priv)) {\n\t\t\tdrm_dbg_kms(&dev_priv->drm,\n\t\t\t\t    \"PSR2 not enabled, selective fetch not valid and no HW tracking available\\n\");\n\t\t\treturn false;\n\t\t}\n\t}\n\n\tif (!psr2_granularity_check(intel_dp, crtc_state)) {\n\t\tdrm_dbg_kms(&dev_priv->drm, \"PSR2 not enabled, SU granularity not compatible\\n\");\n\t\tgoto unsupported;\n\t}\n\n\tif (!crtc_state->enable_psr2_sel_fetch &&\n\t    (crtc_hdisplay > psr_max_h || crtc_vdisplay > psr_max_v)) {\n\t\tdrm_dbg_kms(&dev_priv->drm,\n\t\t\t    \"PSR2 not enabled, resolution %dx%d > max supported %dx%d\\n\",\n\t\t\t    crtc_hdisplay, crtc_vdisplay,\n\t\t\t    psr_max_h, psr_max_v);\n\t\tgoto unsupported;\n\t}\n\n\ttgl_dc3co_exitline_compute_config(intel_dp, crtc_state);\n\treturn true;\n\nunsupported:\n\tcrtc_state->enable_psr2_sel_fetch = false;\n\treturn false;\n}\n\nvoid intel_psr_compute_config(struct intel_dp *intel_dp,\n\t\t\t      struct intel_crtc_state *crtc_state,\n\t\t\t      struct drm_connector_state *conn_state)\n{\n\tstruct drm_i915_private *dev_priv = dp_to_i915(intel_dp);\n\tconst struct drm_display_mode *adjusted_mode =\n\t\t&crtc_state->hw.adjusted_mode;\n\tint psr_setup_time;\n\n\t \n\tif (crtc_state->vrr.enable)\n\t\treturn;\n\n\tif (!CAN_PSR(intel_dp))\n\t\treturn;\n\n\tif (!psr_global_enabled(intel_dp)) {\n\t\tdrm_dbg_kms(&dev_priv->drm, \"PSR disabled by flag\\n\");\n\t\treturn;\n\t}\n\n\tif (intel_dp->psr.sink_not_reliable) {\n\t\tdrm_dbg_kms(&dev_priv->drm,\n\t\t\t    \"PSR sink implementation is not reliable\\n\");\n\t\treturn;\n\t}\n\n\tif (adjusted_mode->flags & DRM_MODE_FLAG_INTERLACE) {\n\t\tdrm_dbg_kms(&dev_priv->drm,\n\t\t\t    \"PSR condition failed: Interlaced mode enabled\\n\");\n\t\treturn;\n\t}\n\n\tpsr_setup_time = drm_dp_psr_setup_time(intel_dp->psr_dpcd);\n\tif (psr_setup_time < 0) {\n\t\tdrm_dbg_kms(&dev_priv->drm,\n\t\t\t    \"PSR condition failed: Invalid PSR setup time (0x%02x)\\n\",\n\t\t\t    intel_dp->psr_dpcd[1]);\n\t\treturn;\n\t}\n\n\tif (intel_usecs_to_scanlines(adjusted_mode, psr_setup_time) >\n\t    adjusted_mode->crtc_vtotal - adjusted_mode->crtc_vdisplay - 1) {\n\t\tdrm_dbg_kms(&dev_priv->drm,\n\t\t\t    \"PSR condition failed: PSR setup time (%d us) too long\\n\",\n\t\t\t    psr_setup_time);\n\t\treturn;\n\t}\n\n\tcrtc_state->has_psr = true;\n\tcrtc_state->has_psr2 = intel_psr2_config_valid(intel_dp, crtc_state);\n\n\tcrtc_state->infoframes.enable |= intel_hdmi_infoframe_enable(DP_SDP_VSC);\n\tintel_dp_compute_psr_vsc_sdp(intel_dp, crtc_state, conn_state,\n\t\t\t\t     &crtc_state->psr_vsc);\n}\n\nvoid intel_psr_get_config(struct intel_encoder *encoder,\n\t\t\t  struct intel_crtc_state *pipe_config)\n{\n\tstruct drm_i915_private *dev_priv = to_i915(encoder->base.dev);\n\tstruct intel_digital_port *dig_port = enc_to_dig_port(encoder);\n\tenum transcoder cpu_transcoder = pipe_config->cpu_transcoder;\n\tstruct intel_dp *intel_dp;\n\tu32 val;\n\n\tif (!dig_port)\n\t\treturn;\n\n\tintel_dp = &dig_port->dp;\n\tif (!CAN_PSR(intel_dp))\n\t\treturn;\n\n\tmutex_lock(&intel_dp->psr.lock);\n\tif (!intel_dp->psr.enabled)\n\t\tgoto unlock;\n\n\t \n\tpipe_config->has_psr = true;\n\tpipe_config->has_psr2 = intel_dp->psr.psr2_enabled;\n\tpipe_config->infoframes.enable |= intel_hdmi_infoframe_enable(DP_SDP_VSC);\n\n\tif (!intel_dp->psr.psr2_enabled)\n\t\tgoto unlock;\n\n\tif (HAS_PSR2_SEL_FETCH(dev_priv)) {\n\t\tval = intel_de_read(dev_priv, PSR2_MAN_TRK_CTL(cpu_transcoder));\n\t\tif (val & PSR2_MAN_TRK_CTL_ENABLE)\n\t\t\tpipe_config->enable_psr2_sel_fetch = true;\n\t}\n\n\tif (DISPLAY_VER(dev_priv) >= 12) {\n\t\tval = intel_de_read(dev_priv, TRANS_EXITLINE(cpu_transcoder));\n\t\tpipe_config->dc3co_exitline = REG_FIELD_GET(EXITLINE_MASK, val);\n\t}\nunlock:\n\tmutex_unlock(&intel_dp->psr.lock);\n}\n\nstatic void intel_psr_activate(struct intel_dp *intel_dp)\n{\n\tstruct drm_i915_private *dev_priv = dp_to_i915(intel_dp);\n\tenum transcoder cpu_transcoder = intel_dp->psr.transcoder;\n\n\tdrm_WARN_ON(&dev_priv->drm,\n\t\t    transcoder_has_psr2(dev_priv, cpu_transcoder) &&\n\t\t    intel_de_read(dev_priv, EDP_PSR2_CTL(cpu_transcoder)) & EDP_PSR2_ENABLE);\n\n\tdrm_WARN_ON(&dev_priv->drm,\n\t\t    intel_de_read(dev_priv, psr_ctl_reg(dev_priv, cpu_transcoder)) & EDP_PSR_ENABLE);\n\n\tdrm_WARN_ON(&dev_priv->drm, intel_dp->psr.active);\n\n\tlockdep_assert_held(&intel_dp->psr.lock);\n\n\t \n\tif (intel_dp->psr.psr2_enabled)\n\t\thsw_activate_psr2(intel_dp);\n\telse\n\t\thsw_activate_psr1(intel_dp);\n\n\tintel_dp->psr.active = true;\n}\n\nstatic u32 wa_16013835468_bit_get(struct intel_dp *intel_dp)\n{\n\tswitch (intel_dp->psr.pipe) {\n\tcase PIPE_A:\n\t\treturn LATENCY_REPORTING_REMOVED_PIPE_A;\n\tcase PIPE_B:\n\t\treturn LATENCY_REPORTING_REMOVED_PIPE_B;\n\tcase PIPE_C:\n\t\treturn LATENCY_REPORTING_REMOVED_PIPE_C;\n\tcase PIPE_D:\n\t\treturn LATENCY_REPORTING_REMOVED_PIPE_D;\n\tdefault:\n\t\tMISSING_CASE(intel_dp->psr.pipe);\n\t\treturn 0;\n\t}\n}\n\n \nstatic void wm_optimization_wa(struct intel_dp *intel_dp,\n\t\t\t       const struct intel_crtc_state *crtc_state)\n{\n\tstruct drm_i915_private *dev_priv = dp_to_i915(intel_dp);\n\tbool set_wa_bit = false;\n\n\t \n\tif (IS_MTL_DISPLAY_STEP(dev_priv, STEP_A0, STEP_B0) ||\n\t    IS_DISPLAY_VER(dev_priv, 11, 13))\n\t\tset_wa_bit |= crtc_state->wm_level_disabled;\n\n\t \n\tif (DISPLAY_VER(dev_priv) == 12)\n\t\tset_wa_bit |= crtc_state->hw.adjusted_mode.crtc_vblank_start !=\n\t\t\tcrtc_state->hw.adjusted_mode.crtc_vdisplay;\n\n\tif (set_wa_bit)\n\t\tintel_de_rmw(dev_priv, GEN8_CHICKEN_DCPR_1,\n\t\t\t     0, wa_16013835468_bit_get(intel_dp));\n\telse\n\t\tintel_de_rmw(dev_priv, GEN8_CHICKEN_DCPR_1,\n\t\t\t     wa_16013835468_bit_get(intel_dp), 0);\n}\n\nstatic void intel_psr_enable_source(struct intel_dp *intel_dp,\n\t\t\t\t    const struct intel_crtc_state *crtc_state)\n{\n\tstruct drm_i915_private *dev_priv = dp_to_i915(intel_dp);\n\tenum transcoder cpu_transcoder = intel_dp->psr.transcoder;\n\tu32 mask;\n\n\t \n\tif (DISPLAY_VER(dev_priv) < 9)\n\t\thsw_psr_setup_aux(intel_dp);\n\n\t \n\tmask = EDP_PSR_DEBUG_MASK_MEMUP |\n\t       EDP_PSR_DEBUG_MASK_HPD |\n\t       EDP_PSR_DEBUG_MASK_LPSP |\n\t       EDP_PSR_DEBUG_MASK_MAX_SLEEP;\n\n\t \n\tif (IS_DISPLAY_VER(dev_priv, 9, 10))\n\t\tmask |= EDP_PSR_DEBUG_MASK_DISP_REG_WRITE;\n\n\t \n\tif (IS_HASWELL(dev_priv))\n\t\tmask |= EDP_PSR_DEBUG_MASK_SPRITE_ENABLE;\n\n\tintel_de_write(dev_priv, psr_debug_reg(dev_priv, cpu_transcoder), mask);\n\n\tpsr_irq_control(intel_dp);\n\n\t \n\tif (intel_dp->psr.dc3co_exitline)\n\t\tintel_de_rmw(dev_priv, TRANS_EXITLINE(cpu_transcoder), EXITLINE_MASK,\n\t\t\t     intel_dp->psr.dc3co_exitline << EXITLINE_SHIFT | EXITLINE_ENABLE);\n\n\tif (HAS_PSR_HW_TRACKING(dev_priv) && HAS_PSR2_SEL_FETCH(dev_priv))\n\t\tintel_de_rmw(dev_priv, CHICKEN_PAR1_1, IGNORE_PSR2_HW_TRACKING,\n\t\t\t     intel_dp->psr.psr2_sel_fetch_enabled ?\n\t\t\t     IGNORE_PSR2_HW_TRACKING : 0);\n\n\t \n\twm_optimization_wa(intel_dp, crtc_state);\n\n\tif (intel_dp->psr.psr2_enabled) {\n\t\tif (DISPLAY_VER(dev_priv) == 9)\n\t\t\tintel_de_rmw(dev_priv, CHICKEN_TRANS(cpu_transcoder), 0,\n\t\t\t\t     PSR2_VSC_ENABLE_PROG_HEADER |\n\t\t\t\t     PSR2_ADD_VERTICAL_LINE_COUNT);\n\n\t\t \n\t\tif (IS_MTL_DISPLAY_STEP(dev_priv, STEP_A0, STEP_B0))\n\t\t\tintel_de_rmw(dev_priv, MTL_CHICKEN_TRANS(cpu_transcoder), 0,\n\t\t\t\t     ADLP_1_BASED_X_GRANULARITY);\n\t\telse if (IS_ALDERLAKE_P(dev_priv))\n\t\t\tintel_de_rmw(dev_priv, CHICKEN_TRANS(cpu_transcoder), 0,\n\t\t\t\t     ADLP_1_BASED_X_GRANULARITY);\n\n\t\t \n\t\tif (IS_MTL_DISPLAY_STEP(dev_priv, STEP_A0, STEP_B0))\n\t\t\tintel_de_rmw(dev_priv,\n\t\t\t\t     MTL_CLKGATE_DIS_TRANS(cpu_transcoder), 0,\n\t\t\t\t     MTL_CLKGATE_DIS_TRANS_DMASC_GATING_DIS);\n\t\telse if (IS_ALDERLAKE_P(dev_priv))\n\t\t\tintel_de_rmw(dev_priv, CLKGATE_DIS_MISC, 0,\n\t\t\t\t     CLKGATE_DIS_MISC_DMASC_GATING_DIS);\n\t}\n}\n\nstatic bool psr_interrupt_error_check(struct intel_dp *intel_dp)\n{\n\tstruct drm_i915_private *dev_priv = dp_to_i915(intel_dp);\n\tenum transcoder cpu_transcoder = intel_dp->psr.transcoder;\n\tu32 val;\n\n\t \n\tval = intel_de_read(dev_priv, psr_iir_reg(dev_priv, cpu_transcoder));\n\tval &= psr_irq_psr_error_bit_get(intel_dp);\n\tif (val) {\n\t\tintel_dp->psr.sink_not_reliable = true;\n\t\tdrm_dbg_kms(&dev_priv->drm,\n\t\t\t    \"PSR interruption error set, not enabling PSR\\n\");\n\t\treturn false;\n\t}\n\n\treturn true;\n}\n\nstatic void intel_psr_enable_locked(struct intel_dp *intel_dp,\n\t\t\t\t    const struct intel_crtc_state *crtc_state)\n{\n\tstruct intel_digital_port *dig_port = dp_to_dig_port(intel_dp);\n\tstruct drm_i915_private *dev_priv = dp_to_i915(intel_dp);\n\tenum phy phy = intel_port_to_phy(dev_priv, dig_port->base.port);\n\tstruct intel_encoder *encoder = &dig_port->base;\n\tu32 val;\n\n\tdrm_WARN_ON(&dev_priv->drm, intel_dp->psr.enabled);\n\n\tintel_dp->psr.psr2_enabled = crtc_state->has_psr2;\n\tintel_dp->psr.busy_frontbuffer_bits = 0;\n\tintel_dp->psr.pipe = to_intel_crtc(crtc_state->uapi.crtc)->pipe;\n\tintel_dp->psr.transcoder = crtc_state->cpu_transcoder;\n\t \n\tval = usecs_to_jiffies(intel_get_frame_time_us(crtc_state) * 6);\n\tintel_dp->psr.dc3co_exit_delay = val;\n\tintel_dp->psr.dc3co_exitline = crtc_state->dc3co_exitline;\n\tintel_dp->psr.psr2_sel_fetch_enabled = crtc_state->enable_psr2_sel_fetch;\n\tintel_dp->psr.psr2_sel_fetch_cff_enabled = false;\n\tintel_dp->psr.req_psr2_sdp_prior_scanline =\n\t\tcrtc_state->req_psr2_sdp_prior_scanline;\n\n\tif (!psr_interrupt_error_check(intel_dp))\n\t\treturn;\n\n\tdrm_dbg_kms(&dev_priv->drm, \"Enabling PSR%s\\n\",\n\t\t    intel_dp->psr.psr2_enabled ? \"2\" : \"1\");\n\tintel_write_dp_vsc_sdp(encoder, crtc_state, &crtc_state->psr_vsc);\n\tintel_snps_phy_update_psr_power_state(dev_priv, phy, true);\n\tintel_psr_enable_sink(intel_dp);\n\tintel_psr_enable_source(intel_dp, crtc_state);\n\tintel_dp->psr.enabled = true;\n\tintel_dp->psr.paused = false;\n\n\tintel_psr_activate(intel_dp);\n}\n\nstatic void intel_psr_exit(struct intel_dp *intel_dp)\n{\n\tstruct drm_i915_private *dev_priv = dp_to_i915(intel_dp);\n\tenum transcoder cpu_transcoder = intel_dp->psr.transcoder;\n\tu32 val;\n\n\tif (!intel_dp->psr.active) {\n\t\tif (transcoder_has_psr2(dev_priv, cpu_transcoder)) {\n\t\t\tval = intel_de_read(dev_priv, EDP_PSR2_CTL(cpu_transcoder));\n\t\t\tdrm_WARN_ON(&dev_priv->drm, val & EDP_PSR2_ENABLE);\n\t\t}\n\n\t\tval = intel_de_read(dev_priv, psr_ctl_reg(dev_priv, cpu_transcoder));\n\t\tdrm_WARN_ON(&dev_priv->drm, val & EDP_PSR_ENABLE);\n\n\t\treturn;\n\t}\n\n\tif (intel_dp->psr.psr2_enabled) {\n\t\ttgl_disallow_dc3co_on_psr2_exit(intel_dp);\n\n\t\tval = intel_de_rmw(dev_priv, EDP_PSR2_CTL(cpu_transcoder),\n\t\t\t\t   EDP_PSR2_ENABLE, 0);\n\n\t\tdrm_WARN_ON(&dev_priv->drm, !(val & EDP_PSR2_ENABLE));\n\t} else {\n\t\tval = intel_de_rmw(dev_priv, psr_ctl_reg(dev_priv, cpu_transcoder),\n\t\t\t\t   EDP_PSR_ENABLE, 0);\n\n\t\tdrm_WARN_ON(&dev_priv->drm, !(val & EDP_PSR_ENABLE));\n\t}\n\tintel_dp->psr.active = false;\n}\n\nstatic void intel_psr_wait_exit_locked(struct intel_dp *intel_dp)\n{\n\tstruct drm_i915_private *dev_priv = dp_to_i915(intel_dp);\n\tenum transcoder cpu_transcoder = intel_dp->psr.transcoder;\n\ti915_reg_t psr_status;\n\tu32 psr_status_mask;\n\n\tif (intel_dp->psr.psr2_enabled) {\n\t\tpsr_status = EDP_PSR2_STATUS(cpu_transcoder);\n\t\tpsr_status_mask = EDP_PSR2_STATUS_STATE_MASK;\n\t} else {\n\t\tpsr_status = psr_status_reg(dev_priv, cpu_transcoder);\n\t\tpsr_status_mask = EDP_PSR_STATUS_STATE_MASK;\n\t}\n\n\t \n\tif (intel_de_wait_for_clear(dev_priv, psr_status,\n\t\t\t\t    psr_status_mask, 2000))\n\t\tdrm_err(&dev_priv->drm, \"Timed out waiting PSR idle state\\n\");\n}\n\nstatic void intel_psr_disable_locked(struct intel_dp *intel_dp)\n{\n\tstruct drm_i915_private *dev_priv = dp_to_i915(intel_dp);\n\tenum transcoder cpu_transcoder = intel_dp->psr.transcoder;\n\tenum phy phy = intel_port_to_phy(dev_priv,\n\t\t\t\t\t dp_to_dig_port(intel_dp)->base.port);\n\n\tlockdep_assert_held(&intel_dp->psr.lock);\n\n\tif (!intel_dp->psr.enabled)\n\t\treturn;\n\n\tdrm_dbg_kms(&dev_priv->drm, \"Disabling PSR%s\\n\",\n\t\t    intel_dp->psr.psr2_enabled ? \"2\" : \"1\");\n\n\tintel_psr_exit(intel_dp);\n\tintel_psr_wait_exit_locked(intel_dp);\n\n\t \n\tif (DISPLAY_VER(dev_priv) >= 11)\n\t\tintel_de_rmw(dev_priv, GEN8_CHICKEN_DCPR_1,\n\t\t\t     wa_16013835468_bit_get(intel_dp), 0);\n\n\tif (intel_dp->psr.psr2_enabled) {\n\t\t \n\t\tif (IS_MTL_DISPLAY_STEP(dev_priv, STEP_A0, STEP_B0))\n\t\t\tintel_de_rmw(dev_priv,\n\t\t\t\t     MTL_CLKGATE_DIS_TRANS(cpu_transcoder),\n\t\t\t\t     MTL_CLKGATE_DIS_TRANS_DMASC_GATING_DIS, 0);\n\t\telse if (IS_ALDERLAKE_P(dev_priv))\n\t\t\tintel_de_rmw(dev_priv, CLKGATE_DIS_MISC,\n\t\t\t\t     CLKGATE_DIS_MISC_DMASC_GATING_DIS, 0);\n\t}\n\n\tintel_snps_phy_update_psr_power_state(dev_priv, phy, false);\n\n\t \n\tdrm_dp_dpcd_writeb(&intel_dp->aux, DP_PSR_EN_CFG, 0);\n\n\tif (intel_dp->psr.psr2_enabled)\n\t\tdrm_dp_dpcd_writeb(&intel_dp->aux, DP_RECEIVER_ALPM_CONFIG, 0);\n\n\tintel_dp->psr.enabled = false;\n\tintel_dp->psr.psr2_enabled = false;\n\tintel_dp->psr.psr2_sel_fetch_enabled = false;\n\tintel_dp->psr.psr2_sel_fetch_cff_enabled = false;\n}\n\n \nvoid intel_psr_disable(struct intel_dp *intel_dp,\n\t\t       const struct intel_crtc_state *old_crtc_state)\n{\n\tstruct drm_i915_private *dev_priv = dp_to_i915(intel_dp);\n\n\tif (!old_crtc_state->has_psr)\n\t\treturn;\n\n\tif (drm_WARN_ON(&dev_priv->drm, !CAN_PSR(intel_dp)))\n\t\treturn;\n\n\tmutex_lock(&intel_dp->psr.lock);\n\n\tintel_psr_disable_locked(intel_dp);\n\n\tmutex_unlock(&intel_dp->psr.lock);\n\tcancel_work_sync(&intel_dp->psr.work);\n\tcancel_delayed_work_sync(&intel_dp->psr.dc3co_work);\n}\n\n \nvoid intel_psr_pause(struct intel_dp *intel_dp)\n{\n\tstruct drm_i915_private *dev_priv = dp_to_i915(intel_dp);\n\tstruct intel_psr *psr = &intel_dp->psr;\n\n\tif (!CAN_PSR(intel_dp))\n\t\treturn;\n\n\tmutex_lock(&psr->lock);\n\n\tif (!psr->enabled) {\n\t\tmutex_unlock(&psr->lock);\n\t\treturn;\n\t}\n\n\t \n\tdrm_WARN_ON(&dev_priv->drm, psr->paused);\n\n\tintel_psr_exit(intel_dp);\n\tintel_psr_wait_exit_locked(intel_dp);\n\tpsr->paused = true;\n\n\tmutex_unlock(&psr->lock);\n\n\tcancel_work_sync(&psr->work);\n\tcancel_delayed_work_sync(&psr->dc3co_work);\n}\n\n \nvoid intel_psr_resume(struct intel_dp *intel_dp)\n{\n\tstruct intel_psr *psr = &intel_dp->psr;\n\n\tif (!CAN_PSR(intel_dp))\n\t\treturn;\n\n\tmutex_lock(&psr->lock);\n\n\tif (!psr->paused)\n\t\tgoto unlock;\n\n\tpsr->paused = false;\n\tintel_psr_activate(intel_dp);\n\nunlock:\n\tmutex_unlock(&psr->lock);\n}\n\nstatic u32 man_trk_ctl_enable_bit_get(struct drm_i915_private *dev_priv)\n{\n\treturn IS_ALDERLAKE_P(dev_priv) || DISPLAY_VER(dev_priv) >= 14 ? 0 :\n\t\tPSR2_MAN_TRK_CTL_ENABLE;\n}\n\nstatic u32 man_trk_ctl_single_full_frame_bit_get(struct drm_i915_private *dev_priv)\n{\n\treturn IS_ALDERLAKE_P(dev_priv) || DISPLAY_VER(dev_priv) >= 14 ?\n\t       ADLP_PSR2_MAN_TRK_CTL_SF_SINGLE_FULL_FRAME :\n\t       PSR2_MAN_TRK_CTL_SF_SINGLE_FULL_FRAME;\n}\n\nstatic u32 man_trk_ctl_partial_frame_bit_get(struct drm_i915_private *dev_priv)\n{\n\treturn IS_ALDERLAKE_P(dev_priv) || DISPLAY_VER(dev_priv) >= 14 ?\n\t       ADLP_PSR2_MAN_TRK_CTL_SF_PARTIAL_FRAME_UPDATE :\n\t       PSR2_MAN_TRK_CTL_SF_PARTIAL_FRAME_UPDATE;\n}\n\nstatic u32 man_trk_ctl_continuos_full_frame(struct drm_i915_private *dev_priv)\n{\n\treturn IS_ALDERLAKE_P(dev_priv) || DISPLAY_VER(dev_priv) >= 14 ?\n\t       ADLP_PSR2_MAN_TRK_CTL_SF_CONTINUOS_FULL_FRAME :\n\t       PSR2_MAN_TRK_CTL_SF_CONTINUOS_FULL_FRAME;\n}\n\nstatic void psr_force_hw_tracking_exit(struct intel_dp *intel_dp)\n{\n\tstruct drm_i915_private *dev_priv = dp_to_i915(intel_dp);\n\tenum transcoder cpu_transcoder = intel_dp->psr.transcoder;\n\n\tif (intel_dp->psr.psr2_sel_fetch_enabled)\n\t\tintel_de_write(dev_priv,\n\t\t\t       PSR2_MAN_TRK_CTL(cpu_transcoder),\n\t\t\t       man_trk_ctl_enable_bit_get(dev_priv) |\n\t\t\t       man_trk_ctl_partial_frame_bit_get(dev_priv) |\n\t\t\t       man_trk_ctl_single_full_frame_bit_get(dev_priv) |\n\t\t\t       man_trk_ctl_continuos_full_frame(dev_priv));\n\n\t \n\tintel_de_write(dev_priv, CURSURFLIVE(intel_dp->psr.pipe), 0);\n}\n\nvoid intel_psr2_disable_plane_sel_fetch_arm(struct intel_plane *plane,\n\t\t\t\t\t    const struct intel_crtc_state *crtc_state)\n{\n\tstruct drm_i915_private *dev_priv = to_i915(plane->base.dev);\n\tenum pipe pipe = plane->pipe;\n\n\tif (!crtc_state->enable_psr2_sel_fetch)\n\t\treturn;\n\n\tintel_de_write_fw(dev_priv, PLANE_SEL_FETCH_CTL(pipe, plane->id), 0);\n}\n\nvoid intel_psr2_program_plane_sel_fetch_arm(struct intel_plane *plane,\n\t\t\t\t\t    const struct intel_crtc_state *crtc_state,\n\t\t\t\t\t    const struct intel_plane_state *plane_state)\n{\n\tstruct drm_i915_private *i915 = to_i915(plane->base.dev);\n\tenum pipe pipe = plane->pipe;\n\n\tif (!crtc_state->enable_psr2_sel_fetch)\n\t\treturn;\n\n\tif (plane->id == PLANE_CURSOR)\n\t\tintel_de_write_fw(i915, PLANE_SEL_FETCH_CTL(pipe, plane->id),\n\t\t\t\t  plane_state->ctl);\n\telse\n\t\tintel_de_write_fw(i915, PLANE_SEL_FETCH_CTL(pipe, plane->id),\n\t\t\t\t  PLANE_SEL_FETCH_CTL_ENABLE);\n}\n\nvoid intel_psr2_program_plane_sel_fetch_noarm(struct intel_plane *plane,\n\t\t\t\t\t      const struct intel_crtc_state *crtc_state,\n\t\t\t\t\t      const struct intel_plane_state *plane_state,\n\t\t\t\t\t      int color_plane)\n{\n\tstruct drm_i915_private *dev_priv = to_i915(plane->base.dev);\n\tenum pipe pipe = plane->pipe;\n\tconst struct drm_rect *clip;\n\tu32 val;\n\tint x, y;\n\n\tif (!crtc_state->enable_psr2_sel_fetch)\n\t\treturn;\n\n\tif (plane->id == PLANE_CURSOR)\n\t\treturn;\n\n\tclip = &plane_state->psr2_sel_fetch_area;\n\n\tval = (clip->y1 + plane_state->uapi.dst.y1) << 16;\n\tval |= plane_state->uapi.dst.x1;\n\tintel_de_write_fw(dev_priv, PLANE_SEL_FETCH_POS(pipe, plane->id), val);\n\n\tx = plane_state->view.color_plane[color_plane].x;\n\n\t \n\tif (!color_plane)\n\t\ty = plane_state->view.color_plane[color_plane].y + clip->y1;\n\telse\n\t\ty = plane_state->view.color_plane[color_plane].y + clip->y1 / 2;\n\n\tval = y << 16 | x;\n\n\tintel_de_write_fw(dev_priv, PLANE_SEL_FETCH_OFFSET(pipe, plane->id),\n\t\t\t  val);\n\n\t \n\tval = (drm_rect_height(clip) - 1) << 16;\n\tval |= (drm_rect_width(&plane_state->uapi.src) >> 16) - 1;\n\tintel_de_write_fw(dev_priv, PLANE_SEL_FETCH_SIZE(pipe, plane->id), val);\n}\n\nvoid intel_psr2_program_trans_man_trk_ctl(const struct intel_crtc_state *crtc_state)\n{\n\tstruct drm_i915_private *dev_priv = to_i915(crtc_state->uapi.crtc->dev);\n\tenum transcoder cpu_transcoder = crtc_state->cpu_transcoder;\n\tstruct intel_encoder *encoder;\n\n\tif (!crtc_state->enable_psr2_sel_fetch)\n\t\treturn;\n\n\tfor_each_intel_encoder_mask_with_psr(&dev_priv->drm, encoder,\n\t\t\t\t\t     crtc_state->uapi.encoder_mask) {\n\t\tstruct intel_dp *intel_dp = enc_to_intel_dp(encoder);\n\n\t\tlockdep_assert_held(&intel_dp->psr.lock);\n\t\tif (intel_dp->psr.psr2_sel_fetch_cff_enabled)\n\t\t\treturn;\n\t\tbreak;\n\t}\n\n\tintel_de_write(dev_priv, PSR2_MAN_TRK_CTL(cpu_transcoder),\n\t\t       crtc_state->psr2_man_track_ctl);\n}\n\nstatic void psr2_man_trk_ctl_calc(struct intel_crtc_state *crtc_state,\n\t\t\t\t  struct drm_rect *clip, bool full_update)\n{\n\tstruct intel_crtc *crtc = to_intel_crtc(crtc_state->uapi.crtc);\n\tstruct drm_i915_private *dev_priv = to_i915(crtc->base.dev);\n\tu32 val = man_trk_ctl_enable_bit_get(dev_priv);\n\n\t \n\tval |= man_trk_ctl_partial_frame_bit_get(dev_priv);\n\n\tif (full_update) {\n\t\tval |= man_trk_ctl_single_full_frame_bit_get(dev_priv);\n\t\tval |= man_trk_ctl_continuos_full_frame(dev_priv);\n\t\tgoto exit;\n\t}\n\n\tif (clip->y1 == -1)\n\t\tgoto exit;\n\n\tif (IS_ALDERLAKE_P(dev_priv) || DISPLAY_VER(dev_priv) >= 14) {\n\t\tval |= ADLP_PSR2_MAN_TRK_CTL_SU_REGION_START_ADDR(clip->y1);\n\t\tval |= ADLP_PSR2_MAN_TRK_CTL_SU_REGION_END_ADDR(clip->y2 - 1);\n\t} else {\n\t\tdrm_WARN_ON(crtc_state->uapi.crtc->dev, clip->y1 % 4 || clip->y2 % 4);\n\n\t\tval |= PSR2_MAN_TRK_CTL_SU_REGION_START_ADDR(clip->y1 / 4 + 1);\n\t\tval |= PSR2_MAN_TRK_CTL_SU_REGION_END_ADDR(clip->y2 / 4 + 1);\n\t}\nexit:\n\tcrtc_state->psr2_man_track_ctl = val;\n}\n\nstatic void clip_area_update(struct drm_rect *overlap_damage_area,\n\t\t\t     struct drm_rect *damage_area,\n\t\t\t     struct drm_rect *pipe_src)\n{\n\tif (!drm_rect_intersect(damage_area, pipe_src))\n\t\treturn;\n\n\tif (overlap_damage_area->y1 == -1) {\n\t\toverlap_damage_area->y1 = damage_area->y1;\n\t\toverlap_damage_area->y2 = damage_area->y2;\n\t\treturn;\n\t}\n\n\tif (damage_area->y1 < overlap_damage_area->y1)\n\t\toverlap_damage_area->y1 = damage_area->y1;\n\n\tif (damage_area->y2 > overlap_damage_area->y2)\n\t\toverlap_damage_area->y2 = damage_area->y2;\n}\n\nstatic void intel_psr2_sel_fetch_pipe_alignment(const struct intel_crtc_state *crtc_state,\n\t\t\t\t\t\tstruct drm_rect *pipe_clip)\n{\n\tstruct drm_i915_private *dev_priv = to_i915(crtc_state->uapi.crtc->dev);\n\tconst struct drm_dsc_config *vdsc_cfg = &crtc_state->dsc.config;\n\tu16 y_alignment;\n\n\t \n\tif (crtc_state->dsc.compression_enable &&\n\t    (IS_ALDERLAKE_P(dev_priv) || DISPLAY_VER(dev_priv) >= 14))\n\t\ty_alignment = vdsc_cfg->slice_height;\n\telse\n\t\ty_alignment = crtc_state->su_y_granularity;\n\n\tpipe_clip->y1 -= pipe_clip->y1 % y_alignment;\n\tif (pipe_clip->y2 % y_alignment)\n\t\tpipe_clip->y2 = ((pipe_clip->y2 / y_alignment) + 1) * y_alignment;\n}\n\n \nstatic bool psr2_sel_fetch_plane_state_supported(const struct intel_plane_state *plane_state)\n{\n\tif (plane_state->uapi.dst.y1 < 0 ||\n\t    plane_state->uapi.dst.x1 < 0 ||\n\t    plane_state->scaler_id >= 0 ||\n\t    plane_state->uapi.rotation != DRM_MODE_ROTATE_0)\n\t\treturn false;\n\n\treturn true;\n}\n\n \nstatic bool psr2_sel_fetch_pipe_state_supported(const struct intel_crtc_state *crtc_state)\n{\n\tif (crtc_state->scaler_state.scaler_id >= 0)\n\t\treturn false;\n\n\treturn true;\n}\n\nint intel_psr2_sel_fetch_update(struct intel_atomic_state *state,\n\t\t\t\tstruct intel_crtc *crtc)\n{\n\tstruct drm_i915_private *dev_priv = to_i915(state->base.dev);\n\tstruct intel_crtc_state *crtc_state = intel_atomic_get_new_crtc_state(state, crtc);\n\tstruct drm_rect pipe_clip = { .x1 = 0, .y1 = -1, .x2 = INT_MAX, .y2 = -1 };\n\tstruct intel_plane_state *new_plane_state, *old_plane_state;\n\tstruct intel_plane *plane;\n\tbool full_update = false;\n\tint i, ret;\n\n\tif (!crtc_state->enable_psr2_sel_fetch)\n\t\treturn 0;\n\n\tif (!psr2_sel_fetch_pipe_state_supported(crtc_state)) {\n\t\tfull_update = true;\n\t\tgoto skip_sel_fetch_set_loop;\n\t}\n\n\t \n\tfor_each_oldnew_intel_plane_in_state(state, plane, old_plane_state,\n\t\t\t\t\t     new_plane_state, i) {\n\t\tstruct drm_rect src, damaged_area = { .x1 = 0, .y1 = -1,\n\t\t\t\t\t\t      .x2 = INT_MAX };\n\n\t\tif (new_plane_state->uapi.crtc != crtc_state->uapi.crtc)\n\t\t\tcontinue;\n\n\t\tif (!new_plane_state->uapi.visible &&\n\t\t    !old_plane_state->uapi.visible)\n\t\t\tcontinue;\n\n\t\tif (!psr2_sel_fetch_plane_state_supported(new_plane_state)) {\n\t\t\tfull_update = true;\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\tif (new_plane_state->uapi.visible != old_plane_state->uapi.visible ||\n\t\t    !drm_rect_equals(&new_plane_state->uapi.dst,\n\t\t\t\t     &old_plane_state->uapi.dst)) {\n\t\t\tif (old_plane_state->uapi.visible) {\n\t\t\t\tdamaged_area.y1 = old_plane_state->uapi.dst.y1;\n\t\t\t\tdamaged_area.y2 = old_plane_state->uapi.dst.y2;\n\t\t\t\tclip_area_update(&pipe_clip, &damaged_area,\n\t\t\t\t\t\t &crtc_state->pipe_src);\n\t\t\t}\n\n\t\t\tif (new_plane_state->uapi.visible) {\n\t\t\t\tdamaged_area.y1 = new_plane_state->uapi.dst.y1;\n\t\t\t\tdamaged_area.y2 = new_plane_state->uapi.dst.y2;\n\t\t\t\tclip_area_update(&pipe_clip, &damaged_area,\n\t\t\t\t\t\t &crtc_state->pipe_src);\n\t\t\t}\n\t\t\tcontinue;\n\t\t} else if (new_plane_state->uapi.alpha != old_plane_state->uapi.alpha) {\n\t\t\t \n\t\t\tdamaged_area.y1 = new_plane_state->uapi.dst.y1;\n\t\t\tdamaged_area.y2 = new_plane_state->uapi.dst.y2;\n\t\t\tclip_area_update(&pipe_clip, &damaged_area,\n\t\t\t\t\t &crtc_state->pipe_src);\n\t\t\tcontinue;\n\t\t}\n\n\t\tsrc = drm_plane_state_src(&new_plane_state->uapi);\n\t\tdrm_rect_fp_to_int(&src, &src);\n\n\t\tif (!drm_atomic_helper_damage_merged(&old_plane_state->uapi,\n\t\t\t\t\t\t     &new_plane_state->uapi, &damaged_area))\n\t\t\tcontinue;\n\n\t\tdamaged_area.y1 += new_plane_state->uapi.dst.y1 - src.y1;\n\t\tdamaged_area.y2 += new_plane_state->uapi.dst.y1 - src.y1;\n\t\tdamaged_area.x1 += new_plane_state->uapi.dst.x1 - src.x1;\n\t\tdamaged_area.x2 += new_plane_state->uapi.dst.x1 - src.x1;\n\n\t\tclip_area_update(&pipe_clip, &damaged_area, &crtc_state->pipe_src);\n\t}\n\n\t \n\tif (pipe_clip.y1 == -1) {\n\t\tdrm_info_once(&dev_priv->drm,\n\t\t\t      \"Selective fetch area calculation failed in pipe %c\\n\",\n\t\t\t      pipe_name(crtc->pipe));\n\t\tfull_update = true;\n\t}\n\n\tif (full_update)\n\t\tgoto skip_sel_fetch_set_loop;\n\n\t \n\tif ((IS_MTL_DISPLAY_STEP(dev_priv, STEP_A0, STEP_B0) ||\n\t     IS_ALDERLAKE_P(dev_priv) || IS_TIGERLAKE(dev_priv)) &&\n\t    crtc_state->splitter.enable)\n\t\tpipe_clip.y1 = 0;\n\n\tret = drm_atomic_add_affected_planes(&state->base, &crtc->base);\n\tif (ret)\n\t\treturn ret;\n\n\tintel_psr2_sel_fetch_pipe_alignment(crtc_state, &pipe_clip);\n\n\t \n\tfor_each_oldnew_intel_plane_in_state(state, plane, old_plane_state,\n\t\t\t\t\t     new_plane_state, i) {\n\t\tstruct drm_rect *sel_fetch_area, inter;\n\t\tstruct intel_plane *linked = new_plane_state->planar_linked_plane;\n\n\t\tif (new_plane_state->uapi.crtc != crtc_state->uapi.crtc ||\n\t\t    !new_plane_state->uapi.visible)\n\t\t\tcontinue;\n\n\t\tinter = pipe_clip;\n\t\tif (!drm_rect_intersect(&inter, &new_plane_state->uapi.dst))\n\t\t\tcontinue;\n\n\t\tif (!psr2_sel_fetch_plane_state_supported(new_plane_state)) {\n\t\t\tfull_update = true;\n\t\t\tbreak;\n\t\t}\n\n\t\tsel_fetch_area = &new_plane_state->psr2_sel_fetch_area;\n\t\tsel_fetch_area->y1 = inter.y1 - new_plane_state->uapi.dst.y1;\n\t\tsel_fetch_area->y2 = inter.y2 - new_plane_state->uapi.dst.y1;\n\t\tcrtc_state->update_planes |= BIT(plane->id);\n\n\t\t \n\t\tif (linked) {\n\t\t\tstruct intel_plane_state *linked_new_plane_state;\n\t\t\tstruct drm_rect *linked_sel_fetch_area;\n\n\t\t\tlinked_new_plane_state = intel_atomic_get_plane_state(state, linked);\n\t\t\tif (IS_ERR(linked_new_plane_state))\n\t\t\t\treturn PTR_ERR(linked_new_plane_state);\n\n\t\t\tlinked_sel_fetch_area = &linked_new_plane_state->psr2_sel_fetch_area;\n\t\t\tlinked_sel_fetch_area->y1 = sel_fetch_area->y1;\n\t\t\tlinked_sel_fetch_area->y2 = sel_fetch_area->y2;\n\t\t\tcrtc_state->update_planes |= BIT(linked->id);\n\t\t}\n\t}\n\nskip_sel_fetch_set_loop:\n\tpsr2_man_trk_ctl_calc(crtc_state, &pipe_clip, full_update);\n\treturn 0;\n}\n\nvoid intel_psr_pre_plane_update(struct intel_atomic_state *state,\n\t\t\t\tstruct intel_crtc *crtc)\n{\n\tstruct drm_i915_private *i915 = to_i915(state->base.dev);\n\tconst struct intel_crtc_state *old_crtc_state =\n\t\tintel_atomic_get_old_crtc_state(state, crtc);\n\tconst struct intel_crtc_state *new_crtc_state =\n\t\tintel_atomic_get_new_crtc_state(state, crtc);\n\tstruct intel_encoder *encoder;\n\n\tif (!HAS_PSR(i915))\n\t\treturn;\n\n\tfor_each_intel_encoder_mask_with_psr(state->base.dev, encoder,\n\t\t\t\t\t     old_crtc_state->uapi.encoder_mask) {\n\t\tstruct intel_dp *intel_dp = enc_to_intel_dp(encoder);\n\t\tstruct intel_psr *psr = &intel_dp->psr;\n\t\tbool needs_to_disable = false;\n\n\t\tmutex_lock(&psr->lock);\n\n\t\t \n\t\tneeds_to_disable |= intel_crtc_needs_modeset(new_crtc_state);\n\t\tneeds_to_disable |= !new_crtc_state->has_psr;\n\t\tneeds_to_disable |= !new_crtc_state->active_planes;\n\t\tneeds_to_disable |= new_crtc_state->has_psr2 != psr->psr2_enabled;\n\t\tneeds_to_disable |= DISPLAY_VER(i915) < 11 &&\n\t\t\tnew_crtc_state->wm_level_disabled;\n\n\t\tif (psr->enabled && needs_to_disable)\n\t\t\tintel_psr_disable_locked(intel_dp);\n\t\telse if (psr->enabled && new_crtc_state->wm_level_disabled)\n\t\t\t \n\t\t\twm_optimization_wa(intel_dp, new_crtc_state);\n\n\t\tmutex_unlock(&psr->lock);\n\t}\n}\n\nstatic void _intel_psr_post_plane_update(const struct intel_atomic_state *state,\n\t\t\t\t\t const struct intel_crtc_state *crtc_state)\n{\n\tstruct drm_i915_private *dev_priv = to_i915(state->base.dev);\n\tstruct intel_encoder *encoder;\n\n\tif (!crtc_state->has_psr)\n\t\treturn;\n\n\tfor_each_intel_encoder_mask_with_psr(state->base.dev, encoder,\n\t\t\t\t\t     crtc_state->uapi.encoder_mask) {\n\t\tstruct intel_dp *intel_dp = enc_to_intel_dp(encoder);\n\t\tstruct intel_psr *psr = &intel_dp->psr;\n\t\tbool keep_disabled = false;\n\n\t\tmutex_lock(&psr->lock);\n\n\t\tdrm_WARN_ON(&dev_priv->drm, psr->enabled && !crtc_state->active_planes);\n\n\t\tkeep_disabled |= psr->sink_not_reliable;\n\t\tkeep_disabled |= !crtc_state->active_planes;\n\n\t\t \n\t\tkeep_disabled |= DISPLAY_VER(dev_priv) < 11 &&\n\t\t\tcrtc_state->wm_level_disabled;\n\n\t\tif (!psr->enabled && !keep_disabled)\n\t\t\tintel_psr_enable_locked(intel_dp, crtc_state);\n\t\telse if (psr->enabled && !crtc_state->wm_level_disabled)\n\t\t\t \n\t\t\twm_optimization_wa(intel_dp, crtc_state);\n\n\t\t \n\t\tif (crtc_state->crc_enabled && psr->enabled)\n\t\t\tpsr_force_hw_tracking_exit(intel_dp);\n\n\t\tmutex_unlock(&psr->lock);\n\t}\n}\n\nvoid intel_psr_post_plane_update(const struct intel_atomic_state *state)\n{\n\tstruct drm_i915_private *dev_priv = to_i915(state->base.dev);\n\tstruct intel_crtc_state *crtc_state;\n\tstruct intel_crtc *crtc;\n\tint i;\n\n\tif (!HAS_PSR(dev_priv))\n\t\treturn;\n\n\tfor_each_new_intel_crtc_in_state(state, crtc, crtc_state, i)\n\t\t_intel_psr_post_plane_update(state, crtc_state);\n}\n\nstatic int _psr2_ready_for_pipe_update_locked(struct intel_dp *intel_dp)\n{\n\tstruct drm_i915_private *dev_priv = dp_to_i915(intel_dp);\n\tenum transcoder cpu_transcoder = intel_dp->psr.transcoder;\n\n\t \n\treturn intel_de_wait_for_clear(dev_priv,\n\t\t\t\t       EDP_PSR2_STATUS(cpu_transcoder),\n\t\t\t\t       EDP_PSR2_STATUS_STATE_DEEP_SLEEP, 50);\n}\n\nstatic int _psr1_ready_for_pipe_update_locked(struct intel_dp *intel_dp)\n{\n\tstruct drm_i915_private *dev_priv = dp_to_i915(intel_dp);\n\tenum transcoder cpu_transcoder = intel_dp->psr.transcoder;\n\n\t \n\treturn intel_de_wait_for_clear(dev_priv,\n\t\t\t\t       psr_status_reg(dev_priv, cpu_transcoder),\n\t\t\t\t       EDP_PSR_STATUS_STATE_MASK, 50);\n}\n\n \nvoid intel_psr_wait_for_idle_locked(const struct intel_crtc_state *new_crtc_state)\n{\n\tstruct drm_i915_private *dev_priv = to_i915(new_crtc_state->uapi.crtc->dev);\n\tstruct intel_encoder *encoder;\n\n\tif (!new_crtc_state->has_psr)\n\t\treturn;\n\n\tfor_each_intel_encoder_mask_with_psr(&dev_priv->drm, encoder,\n\t\t\t\t\t     new_crtc_state->uapi.encoder_mask) {\n\t\tstruct intel_dp *intel_dp = enc_to_intel_dp(encoder);\n\t\tint ret;\n\n\t\tlockdep_assert_held(&intel_dp->psr.lock);\n\n\t\tif (!intel_dp->psr.enabled)\n\t\t\tcontinue;\n\n\t\tif (intel_dp->psr.psr2_enabled)\n\t\t\tret = _psr2_ready_for_pipe_update_locked(intel_dp);\n\t\telse\n\t\t\tret = _psr1_ready_for_pipe_update_locked(intel_dp);\n\n\t\tif (ret)\n\t\t\tdrm_err(&dev_priv->drm, \"PSR wait timed out, atomic update may fail\\n\");\n\t}\n}\n\nstatic bool __psr_wait_for_idle_locked(struct intel_dp *intel_dp)\n{\n\tstruct drm_i915_private *dev_priv = dp_to_i915(intel_dp);\n\tenum transcoder cpu_transcoder = intel_dp->psr.transcoder;\n\ti915_reg_t reg;\n\tu32 mask;\n\tint err;\n\n\tif (!intel_dp->psr.enabled)\n\t\treturn false;\n\n\tif (intel_dp->psr.psr2_enabled) {\n\t\treg = EDP_PSR2_STATUS(cpu_transcoder);\n\t\tmask = EDP_PSR2_STATUS_STATE_MASK;\n\t} else {\n\t\treg = psr_status_reg(dev_priv, cpu_transcoder);\n\t\tmask = EDP_PSR_STATUS_STATE_MASK;\n\t}\n\n\tmutex_unlock(&intel_dp->psr.lock);\n\n\terr = intel_de_wait_for_clear(dev_priv, reg, mask, 50);\n\tif (err)\n\t\tdrm_err(&dev_priv->drm,\n\t\t\t\"Timed out waiting for PSR Idle for re-enable\\n\");\n\n\t \n\tmutex_lock(&intel_dp->psr.lock);\n\treturn err == 0 && intel_dp->psr.enabled;\n}\n\nstatic int intel_psr_fastset_force(struct drm_i915_private *dev_priv)\n{\n\tstruct drm_connector_list_iter conn_iter;\n\tstruct drm_modeset_acquire_ctx ctx;\n\tstruct drm_atomic_state *state;\n\tstruct drm_connector *conn;\n\tint err = 0;\n\n\tstate = drm_atomic_state_alloc(&dev_priv->drm);\n\tif (!state)\n\t\treturn -ENOMEM;\n\n\tdrm_modeset_acquire_init(&ctx, DRM_MODESET_ACQUIRE_INTERRUPTIBLE);\n\n\tstate->acquire_ctx = &ctx;\n\tto_intel_atomic_state(state)->internal = true;\n\nretry:\n\tdrm_connector_list_iter_begin(&dev_priv->drm, &conn_iter);\n\tdrm_for_each_connector_iter(conn, &conn_iter) {\n\t\tstruct drm_connector_state *conn_state;\n\t\tstruct drm_crtc_state *crtc_state;\n\n\t\tif (conn->connector_type != DRM_MODE_CONNECTOR_eDP)\n\t\t\tcontinue;\n\n\t\tconn_state = drm_atomic_get_connector_state(state, conn);\n\t\tif (IS_ERR(conn_state)) {\n\t\t\terr = PTR_ERR(conn_state);\n\t\t\tbreak;\n\t\t}\n\n\t\tif (!conn_state->crtc)\n\t\t\tcontinue;\n\n\t\tcrtc_state = drm_atomic_get_crtc_state(state, conn_state->crtc);\n\t\tif (IS_ERR(crtc_state)) {\n\t\t\terr = PTR_ERR(crtc_state);\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\tcrtc_state->mode_changed = true;\n\t}\n\tdrm_connector_list_iter_end(&conn_iter);\n\n\tif (err == 0)\n\t\terr = drm_atomic_commit(state);\n\n\tif (err == -EDEADLK) {\n\t\tdrm_atomic_state_clear(state);\n\t\terr = drm_modeset_backoff(&ctx);\n\t\tif (!err)\n\t\t\tgoto retry;\n\t}\n\n\tdrm_modeset_drop_locks(&ctx);\n\tdrm_modeset_acquire_fini(&ctx);\n\tdrm_atomic_state_put(state);\n\n\treturn err;\n}\n\nint intel_psr_debug_set(struct intel_dp *intel_dp, u64 val)\n{\n\tstruct drm_i915_private *dev_priv = dp_to_i915(intel_dp);\n\tconst u32 mode = val & I915_PSR_DEBUG_MODE_MASK;\n\tu32 old_mode;\n\tint ret;\n\n\tif (val & ~(I915_PSR_DEBUG_IRQ | I915_PSR_DEBUG_MODE_MASK) ||\n\t    mode > I915_PSR_DEBUG_ENABLE_SEL_FETCH) {\n\t\tdrm_dbg_kms(&dev_priv->drm, \"Invalid debug mask %llx\\n\", val);\n\t\treturn -EINVAL;\n\t}\n\n\tret = mutex_lock_interruptible(&intel_dp->psr.lock);\n\tif (ret)\n\t\treturn ret;\n\n\told_mode = intel_dp->psr.debug & I915_PSR_DEBUG_MODE_MASK;\n\tintel_dp->psr.debug = val;\n\n\t \n\tif (intel_dp->psr.enabled)\n\t\tpsr_irq_control(intel_dp);\n\n\tmutex_unlock(&intel_dp->psr.lock);\n\n\tif (old_mode != mode)\n\t\tret = intel_psr_fastset_force(dev_priv);\n\n\treturn ret;\n}\n\nstatic void intel_psr_handle_irq(struct intel_dp *intel_dp)\n{\n\tstruct intel_psr *psr = &intel_dp->psr;\n\n\tintel_psr_disable_locked(intel_dp);\n\tpsr->sink_not_reliable = true;\n\t \n\tdrm_dp_dpcd_writeb(&intel_dp->aux, DP_SET_POWER, DP_SET_POWER_D0);\n}\n\nstatic void intel_psr_work(struct work_struct *work)\n{\n\tstruct intel_dp *intel_dp =\n\t\tcontainer_of(work, typeof(*intel_dp), psr.work);\n\n\tmutex_lock(&intel_dp->psr.lock);\n\n\tif (!intel_dp->psr.enabled)\n\t\tgoto unlock;\n\n\tif (READ_ONCE(intel_dp->psr.irq_aux_error))\n\t\tintel_psr_handle_irq(intel_dp);\n\n\t \n\tif (!__psr_wait_for_idle_locked(intel_dp))\n\t\tgoto unlock;\n\n\t \n\tif (intel_dp->psr.busy_frontbuffer_bits || intel_dp->psr.active)\n\t\tgoto unlock;\n\n\tintel_psr_activate(intel_dp);\nunlock:\n\tmutex_unlock(&intel_dp->psr.lock);\n}\n\nstatic void _psr_invalidate_handle(struct intel_dp *intel_dp)\n{\n\tstruct drm_i915_private *dev_priv = dp_to_i915(intel_dp);\n\tenum transcoder cpu_transcoder = intel_dp->psr.transcoder;\n\n\tif (intel_dp->psr.psr2_sel_fetch_enabled) {\n\t\tu32 val;\n\n\t\tif (intel_dp->psr.psr2_sel_fetch_cff_enabled) {\n\t\t\t \n\t\t\tintel_de_write(dev_priv, CURSURFLIVE(intel_dp->psr.pipe), 0);\n\t\t\treturn;\n\t\t}\n\n\t\tval = man_trk_ctl_enable_bit_get(dev_priv) |\n\t\t      man_trk_ctl_partial_frame_bit_get(dev_priv) |\n\t\t      man_trk_ctl_continuos_full_frame(dev_priv);\n\t\tintel_de_write(dev_priv, PSR2_MAN_TRK_CTL(cpu_transcoder), val);\n\t\tintel_de_write(dev_priv, CURSURFLIVE(intel_dp->psr.pipe), 0);\n\t\tintel_dp->psr.psr2_sel_fetch_cff_enabled = true;\n\t} else {\n\t\tintel_psr_exit(intel_dp);\n\t}\n}\n\n \nvoid intel_psr_invalidate(struct drm_i915_private *dev_priv,\n\t\t\t  unsigned frontbuffer_bits, enum fb_op_origin origin)\n{\n\tstruct intel_encoder *encoder;\n\n\tif (origin == ORIGIN_FLIP)\n\t\treturn;\n\n\tfor_each_intel_encoder_with_psr(&dev_priv->drm, encoder) {\n\t\tunsigned int pipe_frontbuffer_bits = frontbuffer_bits;\n\t\tstruct intel_dp *intel_dp = enc_to_intel_dp(encoder);\n\n\t\tmutex_lock(&intel_dp->psr.lock);\n\t\tif (!intel_dp->psr.enabled) {\n\t\t\tmutex_unlock(&intel_dp->psr.lock);\n\t\t\tcontinue;\n\t\t}\n\n\t\tpipe_frontbuffer_bits &=\n\t\t\tINTEL_FRONTBUFFER_ALL_MASK(intel_dp->psr.pipe);\n\t\tintel_dp->psr.busy_frontbuffer_bits |= pipe_frontbuffer_bits;\n\n\t\tif (pipe_frontbuffer_bits)\n\t\t\t_psr_invalidate_handle(intel_dp);\n\n\t\tmutex_unlock(&intel_dp->psr.lock);\n\t}\n}\n \nstatic void\ntgl_dc3co_flush_locked(struct intel_dp *intel_dp, unsigned int frontbuffer_bits,\n\t\t       enum fb_op_origin origin)\n{\n\tstruct drm_i915_private *i915 = dp_to_i915(intel_dp);\n\n\tif (!intel_dp->psr.dc3co_exitline || !intel_dp->psr.psr2_enabled ||\n\t    !intel_dp->psr.active)\n\t\treturn;\n\n\t \n\tif (!(frontbuffer_bits &\n\t    INTEL_FRONTBUFFER_ALL_MASK(intel_dp->psr.pipe)))\n\t\treturn;\n\n\ttgl_psr2_enable_dc3co(intel_dp);\n\tmod_delayed_work(i915->unordered_wq, &intel_dp->psr.dc3co_work,\n\t\t\t intel_dp->psr.dc3co_exit_delay);\n}\n\nstatic void _psr_flush_handle(struct intel_dp *intel_dp)\n{\n\tstruct drm_i915_private *dev_priv = dp_to_i915(intel_dp);\n\tenum transcoder cpu_transcoder = intel_dp->psr.transcoder;\n\n\tif (intel_dp->psr.psr2_sel_fetch_enabled) {\n\t\tif (intel_dp->psr.psr2_sel_fetch_cff_enabled) {\n\t\t\t \n\t\t\tif (intel_dp->psr.busy_frontbuffer_bits == 0) {\n\t\t\t\tu32 val = man_trk_ctl_enable_bit_get(dev_priv) |\n\t\t\t\t\tman_trk_ctl_partial_frame_bit_get(dev_priv) |\n\t\t\t\t\tman_trk_ctl_single_full_frame_bit_get(dev_priv) |\n\t\t\t\t\tman_trk_ctl_continuos_full_frame(dev_priv);\n\n\t\t\t\t \n\t\t\t\tintel_de_write(dev_priv, PSR2_MAN_TRK_CTL(cpu_transcoder),\n\t\t\t\t\t       val);\n\t\t\t\tintel_de_write(dev_priv, CURSURFLIVE(intel_dp->psr.pipe), 0);\n\t\t\t\tintel_dp->psr.psr2_sel_fetch_cff_enabled = false;\n\t\t\t}\n\t\t} else {\n\t\t\t \n\t\t\tpsr_force_hw_tracking_exit(intel_dp);\n\t\t}\n\t} else {\n\t\tpsr_force_hw_tracking_exit(intel_dp);\n\n\t\tif (!intel_dp->psr.active && !intel_dp->psr.busy_frontbuffer_bits)\n\t\t\tqueue_work(dev_priv->unordered_wq, &intel_dp->psr.work);\n\t}\n}\n\n \nvoid intel_psr_flush(struct drm_i915_private *dev_priv,\n\t\t     unsigned frontbuffer_bits, enum fb_op_origin origin)\n{\n\tstruct intel_encoder *encoder;\n\n\tfor_each_intel_encoder_with_psr(&dev_priv->drm, encoder) {\n\t\tunsigned int pipe_frontbuffer_bits = frontbuffer_bits;\n\t\tstruct intel_dp *intel_dp = enc_to_intel_dp(encoder);\n\n\t\tmutex_lock(&intel_dp->psr.lock);\n\t\tif (!intel_dp->psr.enabled) {\n\t\t\tmutex_unlock(&intel_dp->psr.lock);\n\t\t\tcontinue;\n\t\t}\n\n\t\tpipe_frontbuffer_bits &=\n\t\t\tINTEL_FRONTBUFFER_ALL_MASK(intel_dp->psr.pipe);\n\t\tintel_dp->psr.busy_frontbuffer_bits &= ~pipe_frontbuffer_bits;\n\n\t\t \n\t\tif (intel_dp->psr.paused)\n\t\t\tgoto unlock;\n\n\t\tif (origin == ORIGIN_FLIP ||\n\t\t    (origin == ORIGIN_CURSOR_UPDATE &&\n\t\t     !intel_dp->psr.psr2_sel_fetch_enabled)) {\n\t\t\ttgl_dc3co_flush_locked(intel_dp, frontbuffer_bits, origin);\n\t\t\tgoto unlock;\n\t\t}\n\n\t\tif (pipe_frontbuffer_bits == 0)\n\t\t\tgoto unlock;\n\n\t\t \n\t\t_psr_flush_handle(intel_dp);\nunlock:\n\t\tmutex_unlock(&intel_dp->psr.lock);\n\t}\n}\n\n \nvoid intel_psr_init(struct intel_dp *intel_dp)\n{\n\tstruct intel_connector *connector = intel_dp->attached_connector;\n\tstruct intel_digital_port *dig_port = dp_to_dig_port(intel_dp);\n\tstruct drm_i915_private *dev_priv = dp_to_i915(intel_dp);\n\n\tif (!HAS_PSR(dev_priv))\n\t\treturn;\n\n\t \n\tif (DISPLAY_VER(dev_priv) < 12 && dig_port->base.port != PORT_A) {\n\t\tdrm_dbg_kms(&dev_priv->drm,\n\t\t\t    \"PSR condition failed: Port not supported\\n\");\n\t\treturn;\n\t}\n\n\tintel_dp->psr.source_support = true;\n\n\t \n\tif (DISPLAY_VER(dev_priv) < 12)\n\t\t \n\t\tintel_dp->psr.link_standby = connector->panel.vbt.psr.full_link;\n\n\tINIT_WORK(&intel_dp->psr.work, intel_psr_work);\n\tINIT_DELAYED_WORK(&intel_dp->psr.dc3co_work, tgl_dc3co_disable_work);\n\tmutex_init(&intel_dp->psr.lock);\n}\n\nstatic int psr_get_status_and_error_status(struct intel_dp *intel_dp,\n\t\t\t\t\t   u8 *status, u8 *error_status)\n{\n\tstruct drm_dp_aux *aux = &intel_dp->aux;\n\tint ret;\n\n\tret = drm_dp_dpcd_readb(aux, DP_PSR_STATUS, status);\n\tif (ret != 1)\n\t\treturn ret;\n\n\tret = drm_dp_dpcd_readb(aux, DP_PSR_ERROR_STATUS, error_status);\n\tif (ret != 1)\n\t\treturn ret;\n\n\t*status = *status & DP_PSR_SINK_STATE_MASK;\n\n\treturn 0;\n}\n\nstatic void psr_alpm_check(struct intel_dp *intel_dp)\n{\n\tstruct drm_i915_private *dev_priv = dp_to_i915(intel_dp);\n\tstruct drm_dp_aux *aux = &intel_dp->aux;\n\tstruct intel_psr *psr = &intel_dp->psr;\n\tu8 val;\n\tint r;\n\n\tif (!psr->psr2_enabled)\n\t\treturn;\n\n\tr = drm_dp_dpcd_readb(aux, DP_RECEIVER_ALPM_STATUS, &val);\n\tif (r != 1) {\n\t\tdrm_err(&dev_priv->drm, \"Error reading ALPM status\\n\");\n\t\treturn;\n\t}\n\n\tif (val & DP_ALPM_LOCK_TIMEOUT_ERROR) {\n\t\tintel_psr_disable_locked(intel_dp);\n\t\tpsr->sink_not_reliable = true;\n\t\tdrm_dbg_kms(&dev_priv->drm,\n\t\t\t    \"ALPM lock timeout error, disabling PSR\\n\");\n\n\t\t \n\t\tdrm_dp_dpcd_writeb(aux, DP_RECEIVER_ALPM_STATUS, val);\n\t}\n}\n\nstatic void psr_capability_changed_check(struct intel_dp *intel_dp)\n{\n\tstruct drm_i915_private *dev_priv = dp_to_i915(intel_dp);\n\tstruct intel_psr *psr = &intel_dp->psr;\n\tu8 val;\n\tint r;\n\n\tr = drm_dp_dpcd_readb(&intel_dp->aux, DP_PSR_ESI, &val);\n\tif (r != 1) {\n\t\tdrm_err(&dev_priv->drm, \"Error reading DP_PSR_ESI\\n\");\n\t\treturn;\n\t}\n\n\tif (val & DP_PSR_CAPS_CHANGE) {\n\t\tintel_psr_disable_locked(intel_dp);\n\t\tpsr->sink_not_reliable = true;\n\t\tdrm_dbg_kms(&dev_priv->drm,\n\t\t\t    \"Sink PSR capability changed, disabling PSR\\n\");\n\n\t\t \n\t\tdrm_dp_dpcd_writeb(&intel_dp->aux, DP_PSR_ESI, val);\n\t}\n}\n\nvoid intel_psr_short_pulse(struct intel_dp *intel_dp)\n{\n\tstruct drm_i915_private *dev_priv = dp_to_i915(intel_dp);\n\tstruct intel_psr *psr = &intel_dp->psr;\n\tu8 status, error_status;\n\tconst u8 errors = DP_PSR_RFB_STORAGE_ERROR |\n\t\t\t  DP_PSR_VSC_SDP_UNCORRECTABLE_ERROR |\n\t\t\t  DP_PSR_LINK_CRC_ERROR;\n\n\tif (!CAN_PSR(intel_dp))\n\t\treturn;\n\n\tmutex_lock(&psr->lock);\n\n\tif (!psr->enabled)\n\t\tgoto exit;\n\n\tif (psr_get_status_and_error_status(intel_dp, &status, &error_status)) {\n\t\tdrm_err(&dev_priv->drm,\n\t\t\t\"Error reading PSR status or error status\\n\");\n\t\tgoto exit;\n\t}\n\n\tif (status == DP_PSR_SINK_INTERNAL_ERROR || (error_status & errors)) {\n\t\tintel_psr_disable_locked(intel_dp);\n\t\tpsr->sink_not_reliable = true;\n\t}\n\n\tif (status == DP_PSR_SINK_INTERNAL_ERROR && !error_status)\n\t\tdrm_dbg_kms(&dev_priv->drm,\n\t\t\t    \"PSR sink internal error, disabling PSR\\n\");\n\tif (error_status & DP_PSR_RFB_STORAGE_ERROR)\n\t\tdrm_dbg_kms(&dev_priv->drm,\n\t\t\t    \"PSR RFB storage error, disabling PSR\\n\");\n\tif (error_status & DP_PSR_VSC_SDP_UNCORRECTABLE_ERROR)\n\t\tdrm_dbg_kms(&dev_priv->drm,\n\t\t\t    \"PSR VSC SDP uncorrectable error, disabling PSR\\n\");\n\tif (error_status & DP_PSR_LINK_CRC_ERROR)\n\t\tdrm_dbg_kms(&dev_priv->drm,\n\t\t\t    \"PSR Link CRC error, disabling PSR\\n\");\n\n\tif (error_status & ~errors)\n\t\tdrm_err(&dev_priv->drm,\n\t\t\t\"PSR_ERROR_STATUS unhandled errors %x\\n\",\n\t\t\terror_status & ~errors);\n\t \n\tdrm_dp_dpcd_writeb(&intel_dp->aux, DP_PSR_ERROR_STATUS, error_status);\n\n\tpsr_alpm_check(intel_dp);\n\tpsr_capability_changed_check(intel_dp);\n\nexit:\n\tmutex_unlock(&psr->lock);\n}\n\nbool intel_psr_enabled(struct intel_dp *intel_dp)\n{\n\tbool ret;\n\n\tif (!CAN_PSR(intel_dp))\n\t\treturn false;\n\n\tmutex_lock(&intel_dp->psr.lock);\n\tret = intel_dp->psr.enabled;\n\tmutex_unlock(&intel_dp->psr.lock);\n\n\treturn ret;\n}\n\n \nvoid intel_psr_lock(const struct intel_crtc_state *crtc_state)\n{\n\tstruct drm_i915_private *i915 = to_i915(crtc_state->uapi.crtc->dev);\n\tstruct intel_encoder *encoder;\n\n\tif (!crtc_state->has_psr)\n\t\treturn;\n\n\tfor_each_intel_encoder_mask_with_psr(&i915->drm, encoder,\n\t\t\t\t\t     crtc_state->uapi.encoder_mask) {\n\t\tstruct intel_dp *intel_dp = enc_to_intel_dp(encoder);\n\n\t\tmutex_lock(&intel_dp->psr.lock);\n\t\tbreak;\n\t}\n}\n\n \nvoid intel_psr_unlock(const struct intel_crtc_state *crtc_state)\n{\n\tstruct drm_i915_private *i915 = to_i915(crtc_state->uapi.crtc->dev);\n\tstruct intel_encoder *encoder;\n\n\tif (!crtc_state->has_psr)\n\t\treturn;\n\n\tfor_each_intel_encoder_mask_with_psr(&i915->drm, encoder,\n\t\t\t\t\t     crtc_state->uapi.encoder_mask) {\n\t\tstruct intel_dp *intel_dp = enc_to_intel_dp(encoder);\n\n\t\tmutex_unlock(&intel_dp->psr.lock);\n\t\tbreak;\n\t}\n}\n\nstatic void\npsr_source_status(struct intel_dp *intel_dp, struct seq_file *m)\n{\n\tstruct drm_i915_private *dev_priv = dp_to_i915(intel_dp);\n\tenum transcoder cpu_transcoder = intel_dp->psr.transcoder;\n\tconst char *status = \"unknown\";\n\tu32 val, status_val;\n\n\tif (intel_dp->psr.psr2_enabled) {\n\t\tstatic const char * const live_status[] = {\n\t\t\t\"IDLE\",\n\t\t\t\"CAPTURE\",\n\t\t\t\"CAPTURE_FS\",\n\t\t\t\"SLEEP\",\n\t\t\t\"BUFON_FW\",\n\t\t\t\"ML_UP\",\n\t\t\t\"SU_STANDBY\",\n\t\t\t\"FAST_SLEEP\",\n\t\t\t\"DEEP_SLEEP\",\n\t\t\t\"BUF_ON\",\n\t\t\t\"TG_ON\"\n\t\t};\n\t\tval = intel_de_read(dev_priv, EDP_PSR2_STATUS(cpu_transcoder));\n\t\tstatus_val = REG_FIELD_GET(EDP_PSR2_STATUS_STATE_MASK, val);\n\t\tif (status_val < ARRAY_SIZE(live_status))\n\t\t\tstatus = live_status[status_val];\n\t} else {\n\t\tstatic const char * const live_status[] = {\n\t\t\t\"IDLE\",\n\t\t\t\"SRDONACK\",\n\t\t\t\"SRDENT\",\n\t\t\t\"BUFOFF\",\n\t\t\t\"BUFON\",\n\t\t\t\"AUXACK\",\n\t\t\t\"SRDOFFACK\",\n\t\t\t\"SRDENT_ON\",\n\t\t};\n\t\tval = intel_de_read(dev_priv, psr_status_reg(dev_priv, cpu_transcoder));\n\t\tstatus_val = REG_FIELD_GET(EDP_PSR_STATUS_STATE_MASK, val);\n\t\tif (status_val < ARRAY_SIZE(live_status))\n\t\t\tstatus = live_status[status_val];\n\t}\n\n\tseq_printf(m, \"Source PSR status: %s [0x%08x]\\n\", status, val);\n}\n\nstatic int intel_psr_status(struct seq_file *m, struct intel_dp *intel_dp)\n{\n\tstruct drm_i915_private *dev_priv = dp_to_i915(intel_dp);\n\tenum transcoder cpu_transcoder = intel_dp->psr.transcoder;\n\tstruct intel_psr *psr = &intel_dp->psr;\n\tintel_wakeref_t wakeref;\n\tconst char *status;\n\tbool enabled;\n\tu32 val;\n\n\tseq_printf(m, \"Sink support: %s\", str_yes_no(psr->sink_support));\n\tif (psr->sink_support)\n\t\tseq_printf(m, \" [0x%02x]\", intel_dp->psr_dpcd[0]);\n\tseq_puts(m, \"\\n\");\n\n\tif (!psr->sink_support)\n\t\treturn 0;\n\n\twakeref = intel_runtime_pm_get(&dev_priv->runtime_pm);\n\tmutex_lock(&psr->lock);\n\n\tif (psr->enabled)\n\t\tstatus = psr->psr2_enabled ? \"PSR2 enabled\" : \"PSR1 enabled\";\n\telse\n\t\tstatus = \"disabled\";\n\tseq_printf(m, \"PSR mode: %s\\n\", status);\n\n\tif (!psr->enabled) {\n\t\tseq_printf(m, \"PSR sink not reliable: %s\\n\",\n\t\t\t   str_yes_no(psr->sink_not_reliable));\n\n\t\tgoto unlock;\n\t}\n\n\tif (psr->psr2_enabled) {\n\t\tval = intel_de_read(dev_priv, EDP_PSR2_CTL(cpu_transcoder));\n\t\tenabled = val & EDP_PSR2_ENABLE;\n\t} else {\n\t\tval = intel_de_read(dev_priv, psr_ctl_reg(dev_priv, cpu_transcoder));\n\t\tenabled = val & EDP_PSR_ENABLE;\n\t}\n\tseq_printf(m, \"Source PSR ctl: %s [0x%08x]\\n\",\n\t\t   str_enabled_disabled(enabled), val);\n\tpsr_source_status(intel_dp, m);\n\tseq_printf(m, \"Busy frontbuffer bits: 0x%08x\\n\",\n\t\t   psr->busy_frontbuffer_bits);\n\n\t \n\tval = intel_de_read(dev_priv, psr_perf_cnt_reg(dev_priv, cpu_transcoder));\n\tseq_printf(m, \"Performance counter: %u\\n\",\n\t\t   REG_FIELD_GET(EDP_PSR_PERF_CNT_MASK, val));\n\n\tif (psr->debug & I915_PSR_DEBUG_IRQ) {\n\t\tseq_printf(m, \"Last attempted entry at: %lld\\n\",\n\t\t\t   psr->last_entry_attempt);\n\t\tseq_printf(m, \"Last exit at: %lld\\n\", psr->last_exit);\n\t}\n\n\tif (psr->psr2_enabled) {\n\t\tu32 su_frames_val[3];\n\t\tint frame;\n\n\t\t \n\t\tfor (frame = 0; frame < PSR2_SU_STATUS_FRAMES; frame += 3) {\n\t\t\tval = intel_de_read(dev_priv, PSR2_SU_STATUS(cpu_transcoder, frame));\n\t\t\tsu_frames_val[frame / 3] = val;\n\t\t}\n\n\t\tseq_puts(m, \"Frame:\\tPSR2 SU blocks:\\n\");\n\n\t\tfor (frame = 0; frame < PSR2_SU_STATUS_FRAMES; frame++) {\n\t\t\tu32 su_blocks;\n\n\t\t\tsu_blocks = su_frames_val[frame / 3] &\n\t\t\t\t    PSR2_SU_STATUS_MASK(frame);\n\t\t\tsu_blocks = su_blocks >> PSR2_SU_STATUS_SHIFT(frame);\n\t\t\tseq_printf(m, \"%d\\t%d\\n\", frame, su_blocks);\n\t\t}\n\n\t\tseq_printf(m, \"PSR2 selective fetch: %s\\n\",\n\t\t\t   str_enabled_disabled(psr->psr2_sel_fetch_enabled));\n\t}\n\nunlock:\n\tmutex_unlock(&psr->lock);\n\tintel_runtime_pm_put(&dev_priv->runtime_pm, wakeref);\n\n\treturn 0;\n}\n\nstatic int i915_edp_psr_status_show(struct seq_file *m, void *data)\n{\n\tstruct drm_i915_private *dev_priv = m->private;\n\tstruct intel_dp *intel_dp = NULL;\n\tstruct intel_encoder *encoder;\n\n\tif (!HAS_PSR(dev_priv))\n\t\treturn -ENODEV;\n\n\t \n\tfor_each_intel_encoder_with_psr(&dev_priv->drm, encoder) {\n\t\tintel_dp = enc_to_intel_dp(encoder);\n\t\tbreak;\n\t}\n\n\tif (!intel_dp)\n\t\treturn -ENODEV;\n\n\treturn intel_psr_status(m, intel_dp);\n}\nDEFINE_SHOW_ATTRIBUTE(i915_edp_psr_status);\n\nstatic int\ni915_edp_psr_debug_set(void *data, u64 val)\n{\n\tstruct drm_i915_private *dev_priv = data;\n\tstruct intel_encoder *encoder;\n\tintel_wakeref_t wakeref;\n\tint ret = -ENODEV;\n\n\tif (!HAS_PSR(dev_priv))\n\t\treturn ret;\n\n\tfor_each_intel_encoder_with_psr(&dev_priv->drm, encoder) {\n\t\tstruct intel_dp *intel_dp = enc_to_intel_dp(encoder);\n\n\t\tdrm_dbg_kms(&dev_priv->drm, \"Setting PSR debug to %llx\\n\", val);\n\n\t\twakeref = intel_runtime_pm_get(&dev_priv->runtime_pm);\n\n\t\t \n\t\tret = intel_psr_debug_set(intel_dp, val);\n\n\t\tintel_runtime_pm_put(&dev_priv->runtime_pm, wakeref);\n\t}\n\n\treturn ret;\n}\n\nstatic int\ni915_edp_psr_debug_get(void *data, u64 *val)\n{\n\tstruct drm_i915_private *dev_priv = data;\n\tstruct intel_encoder *encoder;\n\n\tif (!HAS_PSR(dev_priv))\n\t\treturn -ENODEV;\n\n\tfor_each_intel_encoder_with_psr(&dev_priv->drm, encoder) {\n\t\tstruct intel_dp *intel_dp = enc_to_intel_dp(encoder);\n\n\t\t\n\t\t*val = READ_ONCE(intel_dp->psr.debug);\n\t\treturn 0;\n\t}\n\n\treturn -ENODEV;\n}\n\nDEFINE_SIMPLE_ATTRIBUTE(i915_edp_psr_debug_fops,\n\t\t\ti915_edp_psr_debug_get, i915_edp_psr_debug_set,\n\t\t\t\"%llu\\n\");\n\nvoid intel_psr_debugfs_register(struct drm_i915_private *i915)\n{\n\tstruct drm_minor *minor = i915->drm.primary;\n\n\tdebugfs_create_file(\"i915_edp_psr_debug\", 0644, minor->debugfs_root,\n\t\t\t    i915, &i915_edp_psr_debug_fops);\n\n\tdebugfs_create_file(\"i915_edp_psr_status\", 0444, minor->debugfs_root,\n\t\t\t    i915, &i915_edp_psr_status_fops);\n}\n\nstatic int i915_psr_sink_status_show(struct seq_file *m, void *data)\n{\n\tstruct intel_connector *connector = m->private;\n\tstruct intel_dp *intel_dp = intel_attached_dp(connector);\n\tstatic const char * const sink_status[] = {\n\t\t\"inactive\",\n\t\t\"transition to active, capture and display\",\n\t\t\"active, display from RFB\",\n\t\t\"active, capture and display on sink device timings\",\n\t\t\"transition to inactive, capture and display, timing re-sync\",\n\t\t\"reserved\",\n\t\t\"reserved\",\n\t\t\"sink internal error\",\n\t};\n\tconst char *str;\n\tint ret;\n\tu8 val;\n\n\tif (!CAN_PSR(intel_dp)) {\n\t\tseq_puts(m, \"PSR Unsupported\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tif (connector->base.status != connector_status_connected)\n\t\treturn -ENODEV;\n\n\tret = drm_dp_dpcd_readb(&intel_dp->aux, DP_PSR_STATUS, &val);\n\tif (ret != 1)\n\t\treturn ret < 0 ? ret : -EIO;\n\n\tval &= DP_PSR_SINK_STATE_MASK;\n\tif (val < ARRAY_SIZE(sink_status))\n\t\tstr = sink_status[val];\n\telse\n\t\tstr = \"unknown\";\n\n\tseq_printf(m, \"Sink PSR status: 0x%x [%s]\\n\", val, str);\n\n\treturn 0;\n}\nDEFINE_SHOW_ATTRIBUTE(i915_psr_sink_status);\n\nstatic int i915_psr_status_show(struct seq_file *m, void *data)\n{\n\tstruct intel_connector *connector = m->private;\n\tstruct intel_dp *intel_dp = intel_attached_dp(connector);\n\n\treturn intel_psr_status(m, intel_dp);\n}\nDEFINE_SHOW_ATTRIBUTE(i915_psr_status);\n\nvoid intel_psr_connector_debugfs_add(struct intel_connector *connector)\n{\n\tstruct drm_i915_private *i915 = to_i915(connector->base.dev);\n\tstruct dentry *root = connector->base.debugfs_entry;\n\n\tif (connector->base.connector_type != DRM_MODE_CONNECTOR_eDP)\n\t\treturn;\n\n\tdebugfs_create_file(\"i915_psr_sink_status\", 0444, root,\n\t\t\t    connector, &i915_psr_sink_status_fops);\n\n\tif (HAS_PSR(i915))\n\t\tdebugfs_create_file(\"i915_psr_status\", 0444, root,\n\t\t\t\t    connector, &i915_psr_status_fops);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}