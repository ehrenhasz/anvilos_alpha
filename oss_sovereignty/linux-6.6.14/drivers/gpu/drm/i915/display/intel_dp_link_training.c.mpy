{
  "module_name": "intel_dp_link_training.c",
  "hash_id": "ea6c8ec850af12f179ce0c80d8e227e395f068fb1bc85c6696fac91faa910410",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/i915/display/intel_dp_link_training.c",
  "human_readable_source": " \n\n#include \"i915_drv.h\"\n#include \"intel_display_types.h\"\n#include \"intel_dp.h\"\n#include \"intel_dp_link_training.h\"\n\n#define LT_MSG_PREFIX\t\t\t\"[CONNECTOR:%d:%s][ENCODER:%d:%s][%s] \"\n#define LT_MSG_ARGS(_intel_dp, _dp_phy)\t(_intel_dp)->attached_connector->base.base.id, \\\n\t\t\t\t\t(_intel_dp)->attached_connector->base.name, \\\n\t\t\t\t\tdp_to_dig_port(_intel_dp)->base.base.base.id, \\\n\t\t\t\t\tdp_to_dig_port(_intel_dp)->base.base.name, \\\n\t\t\t\t\tdrm_dp_phy_name(_dp_phy)\n\n#define lt_dbg(_intel_dp, _dp_phy, _format, ...) \\\n\tdrm_dbg_kms(&dp_to_i915(_intel_dp)->drm, \\\n\t\t    LT_MSG_PREFIX _format, \\\n\t\t    LT_MSG_ARGS(_intel_dp, _dp_phy), ## __VA_ARGS__)\n\n#define lt_err(_intel_dp, _dp_phy, _format, ...) do { \\\n\tif (intel_digital_port_connected(&dp_to_dig_port(_intel_dp)->base)) \\\n\t\tdrm_err(&dp_to_i915(_intel_dp)->drm, \\\n\t\t\tLT_MSG_PREFIX _format, \\\n\t\t\tLT_MSG_ARGS(_intel_dp, _dp_phy), ## __VA_ARGS__); \\\n\telse \\\n\t\tlt_dbg(_intel_dp, _dp_phy, \"Sink disconnected: \" _format, ## __VA_ARGS__); \\\n} while (0)\n\nstatic void intel_dp_reset_lttpr_common_caps(struct intel_dp *intel_dp)\n{\n\tmemset(intel_dp->lttpr_common_caps, 0, sizeof(intel_dp->lttpr_common_caps));\n}\n\nstatic void intel_dp_reset_lttpr_count(struct intel_dp *intel_dp)\n{\n\tintel_dp->lttpr_common_caps[DP_PHY_REPEATER_CNT -\n\t\t\t\t    DP_LT_TUNABLE_PHY_REPEATER_FIELD_DATA_STRUCTURE_REV] = 0;\n}\n\nstatic u8 *intel_dp_lttpr_phy_caps(struct intel_dp *intel_dp,\n\t\t\t\t   enum drm_dp_phy dp_phy)\n{\n\treturn intel_dp->lttpr_phy_caps[dp_phy - DP_PHY_LTTPR1];\n}\n\nstatic void intel_dp_read_lttpr_phy_caps(struct intel_dp *intel_dp,\n\t\t\t\t\t const u8 dpcd[DP_RECEIVER_CAP_SIZE],\n\t\t\t\t\t enum drm_dp_phy dp_phy)\n{\n\tu8 *phy_caps = intel_dp_lttpr_phy_caps(intel_dp, dp_phy);\n\n\tif (drm_dp_read_lttpr_phy_caps(&intel_dp->aux, dpcd, dp_phy, phy_caps) < 0) {\n\t\tlt_dbg(intel_dp, dp_phy, \"failed to read the PHY caps\\n\");\n\t\treturn;\n\t}\n\n\tlt_dbg(intel_dp, dp_phy, \"PHY capabilities: %*ph\\n\",\n\t       (int)sizeof(intel_dp->lttpr_phy_caps[0]),\n\t       phy_caps);\n}\n\nstatic bool intel_dp_read_lttpr_common_caps(struct intel_dp *intel_dp,\n\t\t\t\t\t    const u8 dpcd[DP_RECEIVER_CAP_SIZE])\n{\n\tint ret;\n\n\tret = drm_dp_read_lttpr_common_caps(&intel_dp->aux, dpcd,\n\t\t\t\t\t    intel_dp->lttpr_common_caps);\n\tif (ret < 0)\n\t\tgoto reset_caps;\n\n\tlt_dbg(intel_dp, DP_PHY_DPRX, \"LTTPR common capabilities: %*ph\\n\",\n\t       (int)sizeof(intel_dp->lttpr_common_caps),\n\t       intel_dp->lttpr_common_caps);\n\n\t \n\tif (intel_dp->lttpr_common_caps[0] < 0x14)\n\t\tgoto reset_caps;\n\n\treturn true;\n\nreset_caps:\n\tintel_dp_reset_lttpr_common_caps(intel_dp);\n\treturn false;\n}\n\nstatic bool\nintel_dp_set_lttpr_transparent_mode(struct intel_dp *intel_dp, bool enable)\n{\n\tu8 val = enable ? DP_PHY_REPEATER_MODE_TRANSPARENT :\n\t\t\t  DP_PHY_REPEATER_MODE_NON_TRANSPARENT;\n\n\treturn drm_dp_dpcd_write(&intel_dp->aux, DP_PHY_REPEATER_MODE, &val, 1) == 1;\n}\n\nstatic int intel_dp_init_lttpr(struct intel_dp *intel_dp, const u8 dpcd[DP_RECEIVER_CAP_SIZE])\n{\n\tint lttpr_count;\n\tint i;\n\n\tif (!intel_dp_read_lttpr_common_caps(intel_dp, dpcd))\n\t\treturn 0;\n\n\tlttpr_count = drm_dp_lttpr_count(intel_dp->lttpr_common_caps);\n\t \n\tif (lttpr_count == 0)\n\t\treturn 0;\n\n\t \n\tintel_dp_set_lttpr_transparent_mode(intel_dp, true);\n\n\t \n\tif (lttpr_count < 0)\n\t\treturn 0;\n\n\tif (!intel_dp_set_lttpr_transparent_mode(intel_dp, false)) {\n\t\tlt_dbg(intel_dp, DP_PHY_DPRX,\n\t\t       \"Switching to LTTPR non-transparent LT mode failed, fall-back to transparent mode\\n\");\n\n\t\tintel_dp_set_lttpr_transparent_mode(intel_dp, true);\n\t\tintel_dp_reset_lttpr_count(intel_dp);\n\n\t\treturn 0;\n\t}\n\n\tfor (i = 0; i < lttpr_count; i++)\n\t\tintel_dp_read_lttpr_phy_caps(intel_dp, dpcd, DP_PHY_LTTPR(i));\n\n\treturn lttpr_count;\n}\n\n \nint intel_dp_init_lttpr_and_dprx_caps(struct intel_dp *intel_dp)\n{\n\tstruct drm_i915_private *i915 = dp_to_i915(intel_dp);\n\tint lttpr_count = 0;\n\n\t \n\tif (!intel_dp_is_edp(intel_dp) &&\n\t    (DISPLAY_VER(i915) >= 10 && !IS_GEMINILAKE(i915))) {\n\t\tu8 dpcd[DP_RECEIVER_CAP_SIZE];\n\n\t\tif (drm_dp_dpcd_probe(&intel_dp->aux, DP_LT_TUNABLE_PHY_REPEATER_FIELD_DATA_STRUCTURE_REV))\n\t\t\treturn -EIO;\n\n\t\tif (drm_dp_read_dpcd_caps(&intel_dp->aux, dpcd))\n\t\t\treturn -EIO;\n\n\t\tlttpr_count = intel_dp_init_lttpr(intel_dp, dpcd);\n\t}\n\n\t \n\tif (drm_dp_read_dpcd_caps(&intel_dp->aux, intel_dp->dpcd)) {\n\t\tintel_dp_reset_lttpr_common_caps(intel_dp);\n\t\treturn -EIO;\n\t}\n\n\treturn lttpr_count;\n}\n\nstatic u8 dp_voltage_max(u8 preemph)\n{\n\tswitch (preemph & DP_TRAIN_PRE_EMPHASIS_MASK) {\n\tcase DP_TRAIN_PRE_EMPH_LEVEL_0:\n\t\treturn DP_TRAIN_VOLTAGE_SWING_LEVEL_3;\n\tcase DP_TRAIN_PRE_EMPH_LEVEL_1:\n\t\treturn DP_TRAIN_VOLTAGE_SWING_LEVEL_2;\n\tcase DP_TRAIN_PRE_EMPH_LEVEL_2:\n\t\treturn DP_TRAIN_VOLTAGE_SWING_LEVEL_1;\n\tcase DP_TRAIN_PRE_EMPH_LEVEL_3:\n\tdefault:\n\t\treturn DP_TRAIN_VOLTAGE_SWING_LEVEL_0;\n\t}\n}\n\nstatic u8 intel_dp_lttpr_voltage_max(struct intel_dp *intel_dp,\n\t\t\t\t     enum drm_dp_phy dp_phy)\n{\n\tconst u8 *phy_caps = intel_dp_lttpr_phy_caps(intel_dp, dp_phy);\n\n\tif (drm_dp_lttpr_voltage_swing_level_3_supported(phy_caps))\n\t\treturn DP_TRAIN_VOLTAGE_SWING_LEVEL_3;\n\telse\n\t\treturn DP_TRAIN_VOLTAGE_SWING_LEVEL_2;\n}\n\nstatic u8 intel_dp_lttpr_preemph_max(struct intel_dp *intel_dp,\n\t\t\t\t     enum drm_dp_phy dp_phy)\n{\n\tconst u8 *phy_caps = intel_dp_lttpr_phy_caps(intel_dp, dp_phy);\n\n\tif (drm_dp_lttpr_pre_emphasis_level_3_supported(phy_caps))\n\t\treturn DP_TRAIN_PRE_EMPH_LEVEL_3;\n\telse\n\t\treturn DP_TRAIN_PRE_EMPH_LEVEL_2;\n}\n\nstatic bool\nintel_dp_phy_is_downstream_of_source(struct intel_dp *intel_dp,\n\t\t\t\t     enum drm_dp_phy dp_phy)\n{\n\tstruct drm_i915_private *i915 = dp_to_i915(intel_dp);\n\tint lttpr_count = drm_dp_lttpr_count(intel_dp->lttpr_common_caps);\n\n\tdrm_WARN_ON_ONCE(&i915->drm, lttpr_count <= 0 && dp_phy != DP_PHY_DPRX);\n\n\treturn lttpr_count <= 0 || dp_phy == DP_PHY_LTTPR(lttpr_count - 1);\n}\n\nstatic u8 intel_dp_phy_voltage_max(struct intel_dp *intel_dp,\n\t\t\t\t   const struct intel_crtc_state *crtc_state,\n\t\t\t\t   enum drm_dp_phy dp_phy)\n{\n\tstruct drm_i915_private *i915 = dp_to_i915(intel_dp);\n\tu8 voltage_max;\n\n\t \n\tif (intel_dp_phy_is_downstream_of_source(intel_dp, dp_phy))\n\t\tvoltage_max = intel_dp->voltage_max(intel_dp, crtc_state);\n\telse\n\t\tvoltage_max = intel_dp_lttpr_voltage_max(intel_dp, dp_phy + 1);\n\n\tdrm_WARN_ON_ONCE(&i915->drm,\n\t\t\t voltage_max != DP_TRAIN_VOLTAGE_SWING_LEVEL_2 &&\n\t\t\t voltage_max != DP_TRAIN_VOLTAGE_SWING_LEVEL_3);\n\n\treturn voltage_max;\n}\n\nstatic u8 intel_dp_phy_preemph_max(struct intel_dp *intel_dp,\n\t\t\t\t   enum drm_dp_phy dp_phy)\n{\n\tstruct drm_i915_private *i915 = dp_to_i915(intel_dp);\n\tu8 preemph_max;\n\n\t \n\tif (intel_dp_phy_is_downstream_of_source(intel_dp, dp_phy))\n\t\tpreemph_max = intel_dp->preemph_max(intel_dp);\n\telse\n\t\tpreemph_max = intel_dp_lttpr_preemph_max(intel_dp, dp_phy + 1);\n\n\tdrm_WARN_ON_ONCE(&i915->drm,\n\t\t\t preemph_max != DP_TRAIN_PRE_EMPH_LEVEL_2 &&\n\t\t\t preemph_max != DP_TRAIN_PRE_EMPH_LEVEL_3);\n\n\treturn preemph_max;\n}\n\nstatic bool has_per_lane_signal_levels(struct intel_dp *intel_dp,\n\t\t\t\t       enum drm_dp_phy dp_phy)\n{\n\tstruct drm_i915_private *i915 = dp_to_i915(intel_dp);\n\n\treturn !intel_dp_phy_is_downstream_of_source(intel_dp, dp_phy) ||\n\t\tDISPLAY_VER(i915) >= 11;\n}\n\n \nstatic u8 intel_dp_get_lane_adjust_tx_ffe_preset(struct intel_dp *intel_dp,\n\t\t\t\t\t\t const struct intel_crtc_state *crtc_state,\n\t\t\t\t\t\t enum drm_dp_phy dp_phy,\n\t\t\t\t\t\t const u8 link_status[DP_LINK_STATUS_SIZE],\n\t\t\t\t\t\t int lane)\n{\n\tu8 tx_ffe = 0;\n\n\tif (has_per_lane_signal_levels(intel_dp, dp_phy)) {\n\t\tlane = min(lane, crtc_state->lane_count - 1);\n\t\ttx_ffe = drm_dp_get_adjust_tx_ffe_preset(link_status, lane);\n\t} else {\n\t\tfor (lane = 0; lane < crtc_state->lane_count; lane++)\n\t\t\ttx_ffe = max(tx_ffe, drm_dp_get_adjust_tx_ffe_preset(link_status, lane));\n\t}\n\n\treturn tx_ffe;\n}\n\n \nstatic u8 intel_dp_get_lane_adjust_vswing_preemph(struct intel_dp *intel_dp,\n\t\t\t\t\t\t  const struct intel_crtc_state *crtc_state,\n\t\t\t\t\t\t  enum drm_dp_phy dp_phy,\n\t\t\t\t\t\t  const u8 link_status[DP_LINK_STATUS_SIZE],\n\t\t\t\t\t\t  int lane)\n{\n\tu8 v = 0;\n\tu8 p = 0;\n\tu8 voltage_max;\n\tu8 preemph_max;\n\n\tif (has_per_lane_signal_levels(intel_dp, dp_phy)) {\n\t\tlane = min(lane, crtc_state->lane_count - 1);\n\n\t\tv = drm_dp_get_adjust_request_voltage(link_status, lane);\n\t\tp = drm_dp_get_adjust_request_pre_emphasis(link_status, lane);\n\t} else {\n\t\tfor (lane = 0; lane < crtc_state->lane_count; lane++) {\n\t\t\tv = max(v, drm_dp_get_adjust_request_voltage(link_status, lane));\n\t\t\tp = max(p, drm_dp_get_adjust_request_pre_emphasis(link_status, lane));\n\t\t}\n\t}\n\n\tpreemph_max = intel_dp_phy_preemph_max(intel_dp, dp_phy);\n\tif (p >= preemph_max)\n\t\tp = preemph_max | DP_TRAIN_MAX_PRE_EMPHASIS_REACHED;\n\n\tv = min(v, dp_voltage_max(p));\n\n\tvoltage_max = intel_dp_phy_voltage_max(intel_dp, crtc_state, dp_phy);\n\tif (v >= voltage_max)\n\t\tv = voltage_max | DP_TRAIN_MAX_SWING_REACHED;\n\n\treturn v | p;\n}\n\nstatic u8 intel_dp_get_lane_adjust_train(struct intel_dp *intel_dp,\n\t\t\t\t\t const struct intel_crtc_state *crtc_state,\n\t\t\t\t\t enum drm_dp_phy dp_phy,\n\t\t\t\t\t const u8 link_status[DP_LINK_STATUS_SIZE],\n\t\t\t\t\t int lane)\n{\n\tif (intel_dp_is_uhbr(crtc_state))\n\t\treturn intel_dp_get_lane_adjust_tx_ffe_preset(intel_dp, crtc_state,\n\t\t\t\t\t\t\t      dp_phy, link_status, lane);\n\telse\n\t\treturn intel_dp_get_lane_adjust_vswing_preemph(intel_dp, crtc_state,\n\t\t\t\t\t\t\t       dp_phy, link_status, lane);\n}\n\n#define TRAIN_REQ_FMT \"%d/%d/%d/%d\"\n#define _TRAIN_REQ_VSWING_ARGS(link_status, lane) \\\n\t(drm_dp_get_adjust_request_voltage((link_status), (lane)) >> DP_TRAIN_VOLTAGE_SWING_SHIFT)\n#define TRAIN_REQ_VSWING_ARGS(link_status) \\\n\t_TRAIN_REQ_VSWING_ARGS(link_status, 0), \\\n\t_TRAIN_REQ_VSWING_ARGS(link_status, 1), \\\n\t_TRAIN_REQ_VSWING_ARGS(link_status, 2), \\\n\t_TRAIN_REQ_VSWING_ARGS(link_status, 3)\n#define _TRAIN_REQ_PREEMPH_ARGS(link_status, lane) \\\n\t(drm_dp_get_adjust_request_pre_emphasis((link_status), (lane)) >> DP_TRAIN_PRE_EMPHASIS_SHIFT)\n#define TRAIN_REQ_PREEMPH_ARGS(link_status) \\\n\t_TRAIN_REQ_PREEMPH_ARGS(link_status, 0), \\\n\t_TRAIN_REQ_PREEMPH_ARGS(link_status, 1), \\\n\t_TRAIN_REQ_PREEMPH_ARGS(link_status, 2), \\\n\t_TRAIN_REQ_PREEMPH_ARGS(link_status, 3)\n#define _TRAIN_REQ_TX_FFE_ARGS(link_status, lane) \\\n\tdrm_dp_get_adjust_tx_ffe_preset((link_status), (lane))\n#define TRAIN_REQ_TX_FFE_ARGS(link_status) \\\n\t_TRAIN_REQ_TX_FFE_ARGS(link_status, 0), \\\n\t_TRAIN_REQ_TX_FFE_ARGS(link_status, 1), \\\n\t_TRAIN_REQ_TX_FFE_ARGS(link_status, 2), \\\n\t_TRAIN_REQ_TX_FFE_ARGS(link_status, 3)\n\nvoid\nintel_dp_get_adjust_train(struct intel_dp *intel_dp,\n\t\t\t  const struct intel_crtc_state *crtc_state,\n\t\t\t  enum drm_dp_phy dp_phy,\n\t\t\t  const u8 link_status[DP_LINK_STATUS_SIZE])\n{\n\tint lane;\n\n\tif (intel_dp_is_uhbr(crtc_state)) {\n\t\tlt_dbg(intel_dp, dp_phy,\n\t\t       \"128b/132b, lanes: %d, \"\n\t\t       \"TX FFE request: \" TRAIN_REQ_FMT \"\\n\",\n\t\t       crtc_state->lane_count,\n\t\t       TRAIN_REQ_TX_FFE_ARGS(link_status));\n\t} else {\n\t\tlt_dbg(intel_dp, dp_phy,\n\t\t       \"8b/10b, lanes: %d, \"\n\t\t       \"vswing request: \" TRAIN_REQ_FMT \", \"\n\t\t       \"pre-emphasis request: \" TRAIN_REQ_FMT \"\\n\",\n\t\t       crtc_state->lane_count,\n\t\t       TRAIN_REQ_VSWING_ARGS(link_status),\n\t\t       TRAIN_REQ_PREEMPH_ARGS(link_status));\n\t}\n\n\tfor (lane = 0; lane < 4; lane++)\n\t\tintel_dp->train_set[lane] =\n\t\t\tintel_dp_get_lane_adjust_train(intel_dp, crtc_state,\n\t\t\t\t\t\t       dp_phy, link_status, lane);\n}\n\nstatic int intel_dp_training_pattern_set_reg(struct intel_dp *intel_dp,\n\t\t\t\t\t     enum drm_dp_phy dp_phy)\n{\n\treturn dp_phy == DP_PHY_DPRX ?\n\t\tDP_TRAINING_PATTERN_SET :\n\t\tDP_TRAINING_PATTERN_SET_PHY_REPEATER(dp_phy);\n}\n\nstatic bool\nintel_dp_set_link_train(struct intel_dp *intel_dp,\n\t\t\tconst struct intel_crtc_state *crtc_state,\n\t\t\tenum drm_dp_phy dp_phy,\n\t\t\tu8 dp_train_pat)\n{\n\tint reg = intel_dp_training_pattern_set_reg(intel_dp, dp_phy);\n\tu8 buf[sizeof(intel_dp->train_set) + 1];\n\tint len;\n\n\tintel_dp_program_link_training_pattern(intel_dp, crtc_state,\n\t\t\t\t\t       dp_phy, dp_train_pat);\n\n\tbuf[0] = dp_train_pat;\n\t \n\tmemcpy(buf + 1, intel_dp->train_set, crtc_state->lane_count);\n\tlen = crtc_state->lane_count + 1;\n\n\treturn drm_dp_dpcd_write(&intel_dp->aux, reg, buf, len) == len;\n}\n\nstatic char dp_training_pattern_name(u8 train_pat)\n{\n\tswitch (train_pat) {\n\tcase DP_TRAINING_PATTERN_1:\n\tcase DP_TRAINING_PATTERN_2:\n\tcase DP_TRAINING_PATTERN_3:\n\t\treturn '0' + train_pat;\n\tcase DP_TRAINING_PATTERN_4:\n\t\treturn '4';\n\tdefault:\n\t\tMISSING_CASE(train_pat);\n\t\treturn '?';\n\t}\n}\n\nvoid\nintel_dp_program_link_training_pattern(struct intel_dp *intel_dp,\n\t\t\t\t       const struct intel_crtc_state *crtc_state,\n\t\t\t\t       enum drm_dp_phy dp_phy,\n\t\t\t\t       u8 dp_train_pat)\n{\n\tu8 train_pat = intel_dp_training_pattern_symbol(dp_train_pat);\n\n\tif (train_pat != DP_TRAINING_PATTERN_DISABLE)\n\t\tlt_dbg(intel_dp, dp_phy, \"Using DP training pattern TPS%c\\n\",\n\t\t       dp_training_pattern_name(train_pat));\n\n\tintel_dp->set_link_train(intel_dp, crtc_state, dp_train_pat);\n}\n\n#define TRAIN_SET_FMT \"%d%s/%d%s/%d%s/%d%s\"\n#define _TRAIN_SET_VSWING_ARGS(train_set) \\\n\t((train_set) & DP_TRAIN_VOLTAGE_SWING_MASK) >> DP_TRAIN_VOLTAGE_SWING_SHIFT, \\\n\t(train_set) & DP_TRAIN_MAX_SWING_REACHED ? \"(max)\" : \"\"\n#define TRAIN_SET_VSWING_ARGS(train_set) \\\n\t_TRAIN_SET_VSWING_ARGS((train_set)[0]), \\\n\t_TRAIN_SET_VSWING_ARGS((train_set)[1]), \\\n\t_TRAIN_SET_VSWING_ARGS((train_set)[2]), \\\n\t_TRAIN_SET_VSWING_ARGS((train_set)[3])\n#define _TRAIN_SET_PREEMPH_ARGS(train_set) \\\n\t((train_set) & DP_TRAIN_PRE_EMPHASIS_MASK) >> DP_TRAIN_PRE_EMPHASIS_SHIFT, \\\n\t(train_set) & DP_TRAIN_MAX_PRE_EMPHASIS_REACHED ? \"(max)\" : \"\"\n#define TRAIN_SET_PREEMPH_ARGS(train_set) \\\n\t_TRAIN_SET_PREEMPH_ARGS((train_set)[0]), \\\n\t_TRAIN_SET_PREEMPH_ARGS((train_set)[1]), \\\n\t_TRAIN_SET_PREEMPH_ARGS((train_set)[2]), \\\n\t_TRAIN_SET_PREEMPH_ARGS((train_set)[3])\n#define _TRAIN_SET_TX_FFE_ARGS(train_set) \\\n\t((train_set) & DP_TX_FFE_PRESET_VALUE_MASK), \"\"\n#define TRAIN_SET_TX_FFE_ARGS(train_set) \\\n\t_TRAIN_SET_TX_FFE_ARGS((train_set)[0]), \\\n\t_TRAIN_SET_TX_FFE_ARGS((train_set)[1]), \\\n\t_TRAIN_SET_TX_FFE_ARGS((train_set)[2]), \\\n\t_TRAIN_SET_TX_FFE_ARGS((train_set)[3])\n\nvoid intel_dp_set_signal_levels(struct intel_dp *intel_dp,\n\t\t\t\tconst struct intel_crtc_state *crtc_state,\n\t\t\t\tenum drm_dp_phy dp_phy)\n{\n\tstruct intel_encoder *encoder = &dp_to_dig_port(intel_dp)->base;\n\n\tif (intel_dp_is_uhbr(crtc_state)) {\n\t\tlt_dbg(intel_dp, dp_phy,\n\t\t       \"128b/132b, lanes: %d, \"\n\t\t       \"TX FFE presets: \" TRAIN_SET_FMT \"\\n\",\n\t\t       crtc_state->lane_count,\n\t\t       TRAIN_SET_TX_FFE_ARGS(intel_dp->train_set));\n\t} else {\n\t\tlt_dbg(intel_dp, dp_phy,\n\t\t       \"8b/10b, lanes: %d, \"\n\t\t       \"vswing levels: \" TRAIN_SET_FMT \", \"\n\t\t       \"pre-emphasis levels: \" TRAIN_SET_FMT \"\\n\",\n\t\t       crtc_state->lane_count,\n\t\t       TRAIN_SET_VSWING_ARGS(intel_dp->train_set),\n\t\t       TRAIN_SET_PREEMPH_ARGS(intel_dp->train_set));\n\t}\n\n\tif (intel_dp_phy_is_downstream_of_source(intel_dp, dp_phy))\n\t\tencoder->set_signal_levels(encoder, crtc_state);\n}\n\nstatic bool\nintel_dp_reset_link_train(struct intel_dp *intel_dp,\n\t\t\t  const struct intel_crtc_state *crtc_state,\n\t\t\t  enum drm_dp_phy dp_phy,\n\t\t\t  u8 dp_train_pat)\n{\n\tmemset(intel_dp->train_set, 0, sizeof(intel_dp->train_set));\n\tintel_dp_set_signal_levels(intel_dp, crtc_state, dp_phy);\n\treturn intel_dp_set_link_train(intel_dp, crtc_state, dp_phy, dp_train_pat);\n}\n\nstatic bool\nintel_dp_update_link_train(struct intel_dp *intel_dp,\n\t\t\t   const struct intel_crtc_state *crtc_state,\n\t\t\t   enum drm_dp_phy dp_phy)\n{\n\tint reg = dp_phy == DP_PHY_DPRX ?\n\t\t\t    DP_TRAINING_LANE0_SET :\n\t\t\t    DP_TRAINING_LANE0_SET_PHY_REPEATER(dp_phy);\n\tint ret;\n\n\tintel_dp_set_signal_levels(intel_dp, crtc_state, dp_phy);\n\n\tret = drm_dp_dpcd_write(&intel_dp->aux, reg,\n\t\t\t\tintel_dp->train_set, crtc_state->lane_count);\n\n\treturn ret == crtc_state->lane_count;\n}\n\n \nstatic bool intel_dp_lane_max_tx_ffe_reached(u8 train_set_lane)\n{\n\treturn (train_set_lane & DP_TX_FFE_PRESET_VALUE_MASK) ==\n\t\tDP_TX_FFE_PRESET_VALUE_MASK;\n}\n\n \nstatic bool intel_dp_lane_max_vswing_reached(u8 train_set_lane)\n{\n\tu8 v = (train_set_lane & DP_TRAIN_VOLTAGE_SWING_MASK) >>\n\t\tDP_TRAIN_VOLTAGE_SWING_SHIFT;\n\tu8 p = (train_set_lane & DP_TRAIN_PRE_EMPHASIS_MASK) >>\n\t\tDP_TRAIN_PRE_EMPHASIS_SHIFT;\n\n\tif ((train_set_lane & DP_TRAIN_MAX_SWING_REACHED) == 0)\n\t\treturn false;\n\n\tif (v + p != 3)\n\t\treturn false;\n\n\treturn true;\n}\n\nstatic bool intel_dp_link_max_vswing_reached(struct intel_dp *intel_dp,\n\t\t\t\t\t     const struct intel_crtc_state *crtc_state)\n{\n\tint lane;\n\n\tfor (lane = 0; lane < crtc_state->lane_count; lane++) {\n\t\tu8 train_set_lane = intel_dp->train_set[lane];\n\n\t\tif (intel_dp_is_uhbr(crtc_state)) {\n\t\t\tif (!intel_dp_lane_max_tx_ffe_reached(train_set_lane))\n\t\t\t\treturn false;\n\t\t} else {\n\t\t\tif (!intel_dp_lane_max_vswing_reached(train_set_lane))\n\t\t\t\treturn false;\n\t\t}\n\t}\n\n\treturn true;\n}\n\nstatic void\nintel_dp_update_downspread_ctrl(struct intel_dp *intel_dp,\n\t\t\t\tconst struct intel_crtc_state *crtc_state)\n{\n\tu8 link_config[2];\n\n\tlink_config[0] = crtc_state->vrr.flipline ? DP_MSA_TIMING_PAR_IGNORE_EN : 0;\n\tlink_config[1] = intel_dp_is_uhbr(crtc_state) ?\n\t\t\t DP_SET_ANSI_128B132B : DP_SET_ANSI_8B10B;\n\tdrm_dp_dpcd_write(&intel_dp->aux, DP_DOWNSPREAD_CTRL, link_config, 2);\n}\n\nstatic void\nintel_dp_update_link_bw_set(struct intel_dp *intel_dp,\n\t\t\t    const struct intel_crtc_state *crtc_state,\n\t\t\t    u8 link_bw, u8 rate_select)\n{\n\tu8 lane_count = crtc_state->lane_count;\n\n\tif (crtc_state->enhanced_framing)\n\t\tlane_count |= DP_LANE_COUNT_ENHANCED_FRAME_EN;\n\n\tif (link_bw) {\n\t\t \n\t\tu8 link_config[] = { link_bw, lane_count };\n\n\t\tdrm_dp_dpcd_write(&intel_dp->aux, DP_LINK_BW_SET, link_config,\n\t\t\t\t  ARRAY_SIZE(link_config));\n\t} else {\n\t\t \n\t\tdrm_dp_dpcd_writeb(&intel_dp->aux, DP_LANE_COUNT_SET, lane_count);\n\t\tdrm_dp_dpcd_writeb(&intel_dp->aux, DP_LINK_RATE_SET, rate_select);\n\t}\n}\n\n \nstatic bool\nintel_dp_prepare_link_train(struct intel_dp *intel_dp,\n\t\t\t    const struct intel_crtc_state *crtc_state)\n{\n\tu8 link_bw, rate_select;\n\n\tif (intel_dp->prepare_link_retrain)\n\t\tintel_dp->prepare_link_retrain(intel_dp, crtc_state);\n\n\tintel_dp_compute_rate(intel_dp, crtc_state->port_clock,\n\t\t\t      &link_bw, &rate_select);\n\n\t \n\tif (!link_bw) {\n\t\t__le16 sink_rates[DP_MAX_SUPPORTED_RATES];\n\n\t\tlt_dbg(intel_dp, DP_PHY_DPRX, \"Reloading eDP link rates\\n\");\n\n\t\tdrm_dp_dpcd_read(&intel_dp->aux, DP_SUPPORTED_LINK_RATES,\n\t\t\t\t sink_rates, sizeof(sink_rates));\n\t}\n\n\tif (link_bw)\n\t\tlt_dbg(intel_dp, DP_PHY_DPRX, \"Using LINK_BW_SET value %02x\\n\",\n\t\t       link_bw);\n\telse\n\t\tlt_dbg(intel_dp, DP_PHY_DPRX,\n\t\t       \"Using LINK_RATE_SET value %02x\\n\",\n\t\t       rate_select);\n\t \n\tintel_dp_update_downspread_ctrl(intel_dp, crtc_state);\n\tintel_dp_update_link_bw_set(intel_dp, crtc_state, link_bw,\n\t\t\t\t    rate_select);\n\n\treturn true;\n}\n\nstatic bool intel_dp_adjust_request_changed(const struct intel_crtc_state *crtc_state,\n\t\t\t\t\t    const u8 old_link_status[DP_LINK_STATUS_SIZE],\n\t\t\t\t\t    const u8 new_link_status[DP_LINK_STATUS_SIZE])\n{\n\tint lane;\n\n\tfor (lane = 0; lane < crtc_state->lane_count; lane++) {\n\t\tu8 old, new;\n\n\t\tif (intel_dp_is_uhbr(crtc_state)) {\n\t\t\told = drm_dp_get_adjust_tx_ffe_preset(old_link_status, lane);\n\t\t\tnew = drm_dp_get_adjust_tx_ffe_preset(new_link_status, lane);\n\t\t} else {\n\t\t\told = drm_dp_get_adjust_request_voltage(old_link_status, lane) |\n\t\t\t\tdrm_dp_get_adjust_request_pre_emphasis(old_link_status, lane);\n\t\t\tnew = drm_dp_get_adjust_request_voltage(new_link_status, lane) |\n\t\t\t\tdrm_dp_get_adjust_request_pre_emphasis(new_link_status, lane);\n\t\t}\n\n\t\tif (old != new)\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}\n\nvoid\nintel_dp_dump_link_status(struct intel_dp *intel_dp, enum drm_dp_phy dp_phy,\n\t\t\t  const u8 link_status[DP_LINK_STATUS_SIZE])\n{\n\tlt_dbg(intel_dp, dp_phy,\n\t       \"ln0_1:0x%x ln2_3:0x%x align:0x%x sink:0x%x adj_req0_1:0x%x adj_req2_3:0x%x\\n\",\n\t       link_status[0], link_status[1], link_status[2],\n\t       link_status[3], link_status[4], link_status[5]);\n}\n\n \nstatic bool\nintel_dp_link_training_clock_recovery(struct intel_dp *intel_dp,\n\t\t\t\t      const struct intel_crtc_state *crtc_state,\n\t\t\t\t      enum drm_dp_phy dp_phy)\n{\n\tu8 old_link_status[DP_LINK_STATUS_SIZE] = {};\n\tint voltage_tries, cr_tries, max_cr_tries;\n\tu8 link_status[DP_LINK_STATUS_SIZE];\n\tbool max_vswing_reached = false;\n\tint delay_us;\n\n\tdelay_us = drm_dp_read_clock_recovery_delay(&intel_dp->aux,\n\t\t\t\t\t\t    intel_dp->dpcd, dp_phy,\n\t\t\t\t\t\t    intel_dp_is_uhbr(crtc_state));\n\n\t \n\tif (!intel_dp_reset_link_train(intel_dp, crtc_state, dp_phy,\n\t\t\t\t       DP_TRAINING_PATTERN_1 |\n\t\t\t\t       DP_LINK_SCRAMBLING_DISABLE)) {\n\t\tlt_err(intel_dp, dp_phy, \"Failed to enable link training\\n\");\n\t\treturn false;\n\t}\n\n\t \n\tif (intel_dp->dpcd[DP_DPCD_REV] >= DP_DPCD_REV_14)\n\t\tmax_cr_tries = 10;\n\telse\n\t\tmax_cr_tries = 80;\n\n\tvoltage_tries = 1;\n\tfor (cr_tries = 0; cr_tries < max_cr_tries; ++cr_tries) {\n\t\tusleep_range(delay_us, 2 * delay_us);\n\n\t\tif (drm_dp_dpcd_read_phy_link_status(&intel_dp->aux, dp_phy,\n\t\t\t\t\t\t     link_status) < 0) {\n\t\t\tlt_err(intel_dp, dp_phy, \"Failed to get link status\\n\");\n\t\t\treturn false;\n\t\t}\n\n\t\tif (drm_dp_clock_recovery_ok(link_status, crtc_state->lane_count)) {\n\t\t\tlt_dbg(intel_dp, dp_phy, \"Clock recovery OK\\n\");\n\t\t\treturn true;\n\t\t}\n\n\t\tif (voltage_tries == 5) {\n\t\t\tintel_dp_dump_link_status(intel_dp, dp_phy, link_status);\n\t\t\tlt_dbg(intel_dp, dp_phy, \"Same voltage tried 5 times\\n\");\n\t\t\treturn false;\n\t\t}\n\n\t\tif (max_vswing_reached) {\n\t\t\tintel_dp_dump_link_status(intel_dp, dp_phy, link_status);\n\t\t\tlt_dbg(intel_dp, dp_phy, \"Max Voltage Swing reached\\n\");\n\t\t\treturn false;\n\t\t}\n\n\t\t \n\t\tintel_dp_get_adjust_train(intel_dp, crtc_state, dp_phy,\n\t\t\t\t\t  link_status);\n\t\tif (!intel_dp_update_link_train(intel_dp, crtc_state, dp_phy)) {\n\t\t\tlt_err(intel_dp, dp_phy, \"Failed to update link training\\n\");\n\t\t\treturn false;\n\t\t}\n\n\t\tif (!intel_dp_adjust_request_changed(crtc_state, old_link_status, link_status))\n\t\t\t++voltage_tries;\n\t\telse\n\t\t\tvoltage_tries = 1;\n\n\t\tmemcpy(old_link_status, link_status, sizeof(link_status));\n\n\t\tif (intel_dp_link_max_vswing_reached(intel_dp, crtc_state))\n\t\t\tmax_vswing_reached = true;\n\t}\n\n\tintel_dp_dump_link_status(intel_dp, dp_phy, link_status);\n\tlt_err(intel_dp, dp_phy, \"Failed clock recovery %d times, giving up!\\n\",\n\t       max_cr_tries);\n\n\treturn false;\n}\n\n \nstatic u32 intel_dp_training_pattern(struct intel_dp *intel_dp,\n\t\t\t\t     const struct intel_crtc_state *crtc_state,\n\t\t\t\t     enum drm_dp_phy dp_phy)\n{\n\tstruct drm_i915_private *i915 = dp_to_i915(intel_dp);\n\tbool source_tps3, sink_tps3, source_tps4, sink_tps4;\n\n\t \n\tif (intel_dp_is_uhbr(crtc_state))\n\t\treturn DP_TRAINING_PATTERN_2;\n\n\t \n\tsource_tps4 = intel_dp_source_supports_tps4(i915);\n\tsink_tps4 = dp_phy != DP_PHY_DPRX ||\n\t\t    drm_dp_tps4_supported(intel_dp->dpcd);\n\tif (source_tps4 && sink_tps4) {\n\t\treturn DP_TRAINING_PATTERN_4;\n\t} else if (crtc_state->port_clock == 810000) {\n\t\tif (!source_tps4)\n\t\t\tlt_dbg(intel_dp, dp_phy,\n\t\t\t       \"8.1 Gbps link rate without source TPS4 support\\n\");\n\t\tif (!sink_tps4)\n\t\t\tlt_dbg(intel_dp, dp_phy,\n\t\t\t       \"8.1 Gbps link rate without sink TPS4 support\\n\");\n\t}\n\n\t \n\tsource_tps3 = intel_dp_source_supports_tps3(i915);\n\tsink_tps3 = dp_phy != DP_PHY_DPRX ||\n\t\t    drm_dp_tps3_supported(intel_dp->dpcd);\n\tif (source_tps3 && sink_tps3) {\n\t\treturn  DP_TRAINING_PATTERN_3;\n\t} else if (crtc_state->port_clock >= 540000) {\n\t\tif (!source_tps3)\n\t\t\tlt_dbg(intel_dp, dp_phy,\n\t\t\t       \">=5.4/6.48 Gbps link rate without source TPS3 support\\n\");\n\t\tif (!sink_tps3)\n\t\t\tlt_dbg(intel_dp, dp_phy,\n\t\t\t       \">=5.4/6.48 Gbps link rate without sink TPS3 support\\n\");\n\t}\n\n\treturn DP_TRAINING_PATTERN_2;\n}\n\n \nstatic bool\nintel_dp_link_training_channel_equalization(struct intel_dp *intel_dp,\n\t\t\t\t\t    const struct intel_crtc_state *crtc_state,\n\t\t\t\t\t    enum drm_dp_phy dp_phy)\n{\n\tint tries;\n\tu32 training_pattern;\n\tu8 link_status[DP_LINK_STATUS_SIZE];\n\tbool channel_eq = false;\n\tint delay_us;\n\n\tdelay_us = drm_dp_read_channel_eq_delay(&intel_dp->aux,\n\t\t\t\t\t\tintel_dp->dpcd, dp_phy,\n\t\t\t\t\t\tintel_dp_is_uhbr(crtc_state));\n\n\ttraining_pattern = intel_dp_training_pattern(intel_dp, crtc_state, dp_phy);\n\t \n\tif (training_pattern != DP_TRAINING_PATTERN_4)\n\t\ttraining_pattern |= DP_LINK_SCRAMBLING_DISABLE;\n\n\t \n\tif (!intel_dp_set_link_train(intel_dp, crtc_state, dp_phy,\n\t\t\t\t     training_pattern)) {\n\t\tlt_err(intel_dp, dp_phy, \"Failed to start channel equalization\\n\");\n\t\treturn false;\n\t}\n\n\tfor (tries = 0; tries < 5; tries++) {\n\t\tusleep_range(delay_us, 2 * delay_us);\n\n\t\tif (drm_dp_dpcd_read_phy_link_status(&intel_dp->aux, dp_phy,\n\t\t\t\t\t\t     link_status) < 0) {\n\t\t\tlt_err(intel_dp, dp_phy, \"Failed to get link status\\n\");\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\tif (!drm_dp_clock_recovery_ok(link_status,\n\t\t\t\t\t      crtc_state->lane_count)) {\n\t\t\tintel_dp_dump_link_status(intel_dp, dp_phy, link_status);\n\t\t\tlt_dbg(intel_dp, dp_phy,\n\t\t\t       \"Clock recovery check failed, cannot continue channel equalization\\n\");\n\t\t\tbreak;\n\t\t}\n\n\t\tif (drm_dp_channel_eq_ok(link_status,\n\t\t\t\t\t crtc_state->lane_count)) {\n\t\t\tchannel_eq = true;\n\t\t\tlt_dbg(intel_dp, dp_phy, \"Channel EQ done. DP Training successful\\n\");\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\tintel_dp_get_adjust_train(intel_dp, crtc_state, dp_phy,\n\t\t\t\t\t  link_status);\n\t\tif (!intel_dp_update_link_train(intel_dp, crtc_state, dp_phy)) {\n\t\t\tlt_err(intel_dp, dp_phy, \"Failed to update link training\\n\");\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t \n\tif (tries == 5) {\n\t\tintel_dp_dump_link_status(intel_dp, dp_phy, link_status);\n\t\tlt_dbg(intel_dp, dp_phy, \"Channel equalization failed 5 times\\n\");\n\t}\n\n\treturn channel_eq;\n}\n\nstatic bool intel_dp_disable_dpcd_training_pattern(struct intel_dp *intel_dp,\n\t\t\t\t\t\t   enum drm_dp_phy dp_phy)\n{\n\tint reg = intel_dp_training_pattern_set_reg(intel_dp, dp_phy);\n\tu8 val = DP_TRAINING_PATTERN_DISABLE;\n\n\treturn drm_dp_dpcd_write(&intel_dp->aux, reg, &val, 1) == 1;\n}\n\nstatic int\nintel_dp_128b132b_intra_hop(struct intel_dp *intel_dp,\n\t\t\t    const struct intel_crtc_state *crtc_state)\n{\n\tu8 sink_status;\n\tint ret;\n\n\tret = drm_dp_dpcd_readb(&intel_dp->aux, DP_SINK_STATUS, &sink_status);\n\tif (ret != 1) {\n\t\tlt_dbg(intel_dp, DP_PHY_DPRX, \"Failed to read sink status\\n\");\n\t\treturn ret < 0 ? ret : -EIO;\n\t}\n\n\treturn sink_status & DP_INTRA_HOP_AUX_REPLY_INDICATION ? 1 : 0;\n}\n\n \nvoid intel_dp_stop_link_train(struct intel_dp *intel_dp,\n\t\t\t      const struct intel_crtc_state *crtc_state)\n{\n\tintel_dp->link_trained = true;\n\n\tintel_dp_disable_dpcd_training_pattern(intel_dp, DP_PHY_DPRX);\n\tintel_dp_program_link_training_pattern(intel_dp, crtc_state, DP_PHY_DPRX,\n\t\t\t\t\t       DP_TRAINING_PATTERN_DISABLE);\n\n\tif (intel_dp_is_uhbr(crtc_state) &&\n\t    wait_for(intel_dp_128b132b_intra_hop(intel_dp, crtc_state) == 0, 500)) {\n\t\tlt_dbg(intel_dp, DP_PHY_DPRX, \"128b/132b intra-hop not clearing\\n\");\n\t}\n}\n\nstatic bool\nintel_dp_link_train_phy(struct intel_dp *intel_dp,\n\t\t\tconst struct intel_crtc_state *crtc_state,\n\t\t\tenum drm_dp_phy dp_phy)\n{\n\tbool ret = false;\n\n\tif (!intel_dp_link_training_clock_recovery(intel_dp, crtc_state, dp_phy))\n\t\tgoto out;\n\n\tif (!intel_dp_link_training_channel_equalization(intel_dp, crtc_state, dp_phy))\n\t\tgoto out;\n\n\tret = true;\n\nout:\n\tlt_dbg(intel_dp, dp_phy,\n\t       \"Link Training %s at link rate = %d, lane count = %d\\n\",\n\t       ret ? \"passed\" : \"failed\",\n\t       crtc_state->port_clock, crtc_state->lane_count);\n\n\treturn ret;\n}\n\nstatic void intel_dp_schedule_fallback_link_training(struct intel_dp *intel_dp,\n\t\t\t\t\t\t     const struct intel_crtc_state *crtc_state)\n{\n\tstruct intel_connector *intel_connector = intel_dp->attached_connector;\n\tstruct drm_i915_private *i915 = dp_to_i915(intel_dp);\n\n\tif (!intel_digital_port_connected(&dp_to_dig_port(intel_dp)->base)) {\n\t\tlt_dbg(intel_dp, DP_PHY_DPRX, \"Link Training failed on disconnected sink.\\n\");\n\t\treturn;\n\t}\n\n\tif (intel_dp->hobl_active) {\n\t\tlt_dbg(intel_dp, DP_PHY_DPRX,\n\t\t       \"Link Training failed with HOBL active, not enabling it from now on\\n\");\n\t\tintel_dp->hobl_failed = true;\n\t} else if (intel_dp_get_link_train_fallback_values(intel_dp,\n\t\t\t\t\t\t\t   crtc_state->port_clock,\n\t\t\t\t\t\t\t   crtc_state->lane_count)) {\n\t\treturn;\n\t}\n\n\t \n\tqueue_work(i915->unordered_wq, &intel_connector->modeset_retry_work);\n}\n\n \nstatic bool\nintel_dp_link_train_all_phys(struct intel_dp *intel_dp,\n\t\t\t     const struct intel_crtc_state *crtc_state,\n\t\t\t     int lttpr_count)\n{\n\tbool ret = true;\n\tint i;\n\n\tfor (i = lttpr_count - 1; i >= 0; i--) {\n\t\tenum drm_dp_phy dp_phy = DP_PHY_LTTPR(i);\n\n\t\tret = intel_dp_link_train_phy(intel_dp, crtc_state, dp_phy);\n\t\tintel_dp_disable_dpcd_training_pattern(intel_dp, dp_phy);\n\n\t\tif (!ret)\n\t\t\tbreak;\n\t}\n\n\tif (ret)\n\t\tret = intel_dp_link_train_phy(intel_dp, crtc_state, DP_PHY_DPRX);\n\n\tif (intel_dp->set_idle_link_train)\n\t\tintel_dp->set_idle_link_train(intel_dp, crtc_state);\n\n\treturn ret;\n}\n\n \nstatic bool\nintel_dp_128b132b_lane_eq(struct intel_dp *intel_dp,\n\t\t\t  const struct intel_crtc_state *crtc_state)\n{\n\tu8 link_status[DP_LINK_STATUS_SIZE];\n\tint delay_us;\n\tint try, max_tries = 20;\n\tunsigned long deadline;\n\tbool timeout = false;\n\n\t \n\tif (!intel_dp_reset_link_train(intel_dp, crtc_state, DP_PHY_DPRX,\n\t\t\t\t       DP_TRAINING_PATTERN_1)) {\n\t\tlt_err(intel_dp, DP_PHY_DPRX, \"Failed to start 128b/132b TPS1\\n\");\n\t\treturn false;\n\t}\n\n\tdelay_us = drm_dp_128b132b_read_aux_rd_interval(&intel_dp->aux);\n\n\t \n\tif (drm_dp_dpcd_read_link_status(&intel_dp->aux, link_status) < 0) {\n\t\tlt_err(intel_dp, DP_PHY_DPRX, \"Failed to read TX FFE presets\\n\");\n\t\treturn false;\n\t}\n\n\t \n\tintel_dp_get_adjust_train(intel_dp, crtc_state, DP_PHY_DPRX, link_status);\n\tif (!intel_dp_update_link_train(intel_dp, crtc_state, DP_PHY_DPRX)) {\n\t\tlt_err(intel_dp, DP_PHY_DPRX, \"Failed to set initial TX FFE settings\\n\");\n\t\treturn false;\n\t}\n\n\t \n\tif (!intel_dp_set_link_train(intel_dp, crtc_state, DP_PHY_DPRX,\n\t\t\t\t     DP_TRAINING_PATTERN_2)) {\n\t\tlt_err(intel_dp, DP_PHY_DPRX, \"Failed to start 128b/132b TPS2\\n\");\n\t\treturn false;\n\t}\n\n\t \n\tdeadline = jiffies + msecs_to_jiffies_timeout(400);\n\n\tfor (try = 0; try < max_tries; try++) {\n\t\tusleep_range(delay_us, 2 * delay_us);\n\n\t\t \n\t\tdelay_us = drm_dp_128b132b_read_aux_rd_interval(&intel_dp->aux);\n\n\t\tif (drm_dp_dpcd_read_link_status(&intel_dp->aux, link_status) < 0) {\n\t\t\tlt_err(intel_dp, DP_PHY_DPRX, \"Failed to read link status\\n\");\n\t\t\treturn false;\n\t\t}\n\n\t\tif (drm_dp_128b132b_link_training_failed(link_status)) {\n\t\t\tintel_dp_dump_link_status(intel_dp, DP_PHY_DPRX, link_status);\n\t\t\tlt_err(intel_dp, DP_PHY_DPRX,\n\t\t\t       \"Downstream link training failure\\n\");\n\t\t\treturn false;\n\t\t}\n\n\t\tif (drm_dp_128b132b_lane_channel_eq_done(link_status, crtc_state->lane_count)) {\n\t\t\tlt_dbg(intel_dp, DP_PHY_DPRX, \"Lane channel eq done\\n\");\n\t\t\tbreak;\n\t\t}\n\n\t\tif (timeout) {\n\t\t\tintel_dp_dump_link_status(intel_dp, DP_PHY_DPRX, link_status);\n\t\t\tlt_err(intel_dp, DP_PHY_DPRX, \"Lane channel eq timeout\\n\");\n\t\t\treturn false;\n\t\t}\n\n\t\tif (time_after(jiffies, deadline))\n\t\t\ttimeout = true;  \n\n\t\t \n\t\tintel_dp_get_adjust_train(intel_dp, crtc_state, DP_PHY_DPRX, link_status);\n\t\tif (!intel_dp_update_link_train(intel_dp, crtc_state, DP_PHY_DPRX)) {\n\t\t\tlt_err(intel_dp, DP_PHY_DPRX, \"Failed to update TX FFE settings\\n\");\n\t\t\treturn false;\n\t\t}\n\t}\n\n\tif (try == max_tries) {\n\t\tintel_dp_dump_link_status(intel_dp, DP_PHY_DPRX, link_status);\n\t\tlt_err(intel_dp, DP_PHY_DPRX, \"Max loop count reached\\n\");\n\t\treturn false;\n\t}\n\n\tfor (;;) {\n\t\tif (time_after(jiffies, deadline))\n\t\t\ttimeout = true;  \n\n\t\tif (drm_dp_dpcd_read_link_status(&intel_dp->aux, link_status) < 0) {\n\t\t\tlt_err(intel_dp, DP_PHY_DPRX, \"Failed to read link status\\n\");\n\t\t\treturn false;\n\t\t}\n\n\t\tif (drm_dp_128b132b_link_training_failed(link_status)) {\n\t\t\tintel_dp_dump_link_status(intel_dp, DP_PHY_DPRX, link_status);\n\t\t\tlt_err(intel_dp, DP_PHY_DPRX, \"Downstream link training failure\\n\");\n\t\t\treturn false;\n\t\t}\n\n\t\tif (drm_dp_128b132b_eq_interlane_align_done(link_status)) {\n\t\t\tlt_dbg(intel_dp, DP_PHY_DPRX, \"Interlane align done\\n\");\n\t\t\tbreak;\n\t\t}\n\n\t\tif (timeout) {\n\t\t\tintel_dp_dump_link_status(intel_dp, DP_PHY_DPRX, link_status);\n\t\t\tlt_err(intel_dp, DP_PHY_DPRX, \"Interlane align timeout\\n\");\n\t\t\treturn false;\n\t\t}\n\n\t\tusleep_range(2000, 3000);\n\t}\n\n\treturn true;\n}\n\n \nstatic bool\nintel_dp_128b132b_lane_cds(struct intel_dp *intel_dp,\n\t\t\t   const struct intel_crtc_state *crtc_state,\n\t\t\t   int lttpr_count)\n{\n\tu8 link_status[DP_LINK_STATUS_SIZE];\n\tunsigned long deadline;\n\n\tif (drm_dp_dpcd_writeb(&intel_dp->aux, DP_TRAINING_PATTERN_SET,\n\t\t\t       DP_TRAINING_PATTERN_2_CDS) != 1) {\n\t\tlt_err(intel_dp, DP_PHY_DPRX, \"Failed to start 128b/132b TPS2 CDS\\n\");\n\t\treturn false;\n\t}\n\n\t \n\tdeadline = jiffies + msecs_to_jiffies_timeout((lttpr_count + 1) * 20);\n\n\tfor (;;) {\n\t\tbool timeout = false;\n\n\t\tif (time_after(jiffies, deadline))\n\t\t\ttimeout = true;  \n\n\t\tusleep_range(2000, 3000);\n\n\t\tif (drm_dp_dpcd_read_link_status(&intel_dp->aux, link_status) < 0) {\n\t\t\tlt_err(intel_dp, DP_PHY_DPRX, \"Failed to read link status\\n\");\n\t\t\treturn false;\n\t\t}\n\n\t\tif (drm_dp_128b132b_eq_interlane_align_done(link_status) &&\n\t\t    drm_dp_128b132b_cds_interlane_align_done(link_status) &&\n\t\t    drm_dp_128b132b_lane_symbol_locked(link_status, crtc_state->lane_count)) {\n\t\t\tlt_dbg(intel_dp, DP_PHY_DPRX, \"CDS interlane align done\\n\");\n\t\t\tbreak;\n\t\t}\n\n\t\tif (drm_dp_128b132b_link_training_failed(link_status)) {\n\t\t\tintel_dp_dump_link_status(intel_dp, DP_PHY_DPRX, link_status);\n\t\t\tlt_err(intel_dp, DP_PHY_DPRX, \"Downstream link training failure\\n\");\n\t\t\treturn false;\n\t\t}\n\n\t\tif (timeout) {\n\t\t\tintel_dp_dump_link_status(intel_dp, DP_PHY_DPRX, link_status);\n\t\t\tlt_err(intel_dp, DP_PHY_DPRX, \"CDS timeout\\n\");\n\t\t\treturn false;\n\t\t}\n\t}\n\n\treturn true;\n}\n\n \nstatic bool\nintel_dp_128b132b_link_train(struct intel_dp *intel_dp,\n\t\t\t     const struct intel_crtc_state *crtc_state,\n\t\t\t     int lttpr_count)\n{\n\tbool passed = false;\n\n\tif (wait_for(intel_dp_128b132b_intra_hop(intel_dp, crtc_state) == 0, 500)) {\n\t\tlt_err(intel_dp, DP_PHY_DPRX, \"128b/132b intra-hop not clear\\n\");\n\t\treturn false;\n\t}\n\n\tif (intel_dp_128b132b_lane_eq(intel_dp, crtc_state) &&\n\t    intel_dp_128b132b_lane_cds(intel_dp, crtc_state, lttpr_count))\n\t\tpassed = true;\n\n\tlt_dbg(intel_dp, DP_PHY_DPRX,\n\t       \"128b/132b Link Training %s at link rate = %d, lane count = %d\\n\",\n\t       passed ? \"passed\" : \"failed\",\n\t       crtc_state->port_clock, crtc_state->lane_count);\n\n\treturn passed;\n}\n\n \nvoid intel_dp_start_link_train(struct intel_dp *intel_dp,\n\t\t\t       const struct intel_crtc_state *crtc_state)\n{\n\tstruct drm_i915_private *i915 = dp_to_i915(intel_dp);\n\tbool passed;\n\n\t \n\tint lttpr_count = intel_dp_init_lttpr_and_dprx_caps(intel_dp);\n\n\tif (lttpr_count < 0)\n\t\t \n\t\tlttpr_count = 0;\n\n\tintel_dp_prepare_link_train(intel_dp, crtc_state);\n\n\tif (intel_dp_is_uhbr(crtc_state))\n\t\tpassed = intel_dp_128b132b_link_train(intel_dp, crtc_state, lttpr_count);\n\telse\n\t\tpassed = intel_dp_link_train_all_phys(intel_dp, crtc_state, lttpr_count);\n\n\t \n\tif (!passed && i915->display.hotplug.ignore_long_hpd) {\n\t\tlt_dbg(intel_dp, DP_PHY_DPRX, \"Ignore the link failure\\n\");\n\t\treturn;\n\t}\n\n\tif (!passed)\n\t\tintel_dp_schedule_fallback_link_training(intel_dp, crtc_state);\n}\n\nvoid intel_dp_128b132b_sdp_crc16(struct intel_dp *intel_dp,\n\t\t\t\t const struct intel_crtc_state *crtc_state)\n{\n\t \n\tif (intel_dp_is_uhbr(crtc_state))\n\t\t \n\t\tdrm_dp_dpcd_writeb(&intel_dp->aux,\n\t\t\t\t   DP_SDP_ERROR_DETECTION_CONFIGURATION,\n\t\t\t\t   DP_SDP_CRC16_128B132B_EN);\n\n\tlt_dbg(intel_dp, DP_PHY_DPRX, \"DP2.0 SDP CRC16 for 128b/132b enabled\\n\");\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}