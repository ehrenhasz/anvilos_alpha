{
  "module_name": "dvo_ns2501.c",
  "hash_id": "8cd3ce5dddde52d0f3225972c05d20f3970bbc7b2de9a19c14dd1291f63dfd17",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/i915/display/dvo_ns2501.c",
  "human_readable_source": " \n\n#include \"i915_drv.h\"\n#include \"i915_reg.h\"\n#include \"intel_display_types.h\"\n#include \"intel_dvo_dev.h\"\n\n#define NS2501_VID 0x1305\n#define NS2501_DID 0x6726\n\n#define NS2501_VID_LO 0x00\n#define NS2501_VID_HI 0x01\n#define NS2501_DID_LO 0x02\n#define NS2501_DID_HI 0x03\n#define NS2501_REV 0x04\n#define NS2501_RSVD 0x05\n#define NS2501_FREQ_LO 0x06\n#define NS2501_FREQ_HI 0x07\n\n#define NS2501_REG8 0x08\n#define NS2501_8_VEN (1<<5)\n#define NS2501_8_HEN (1<<4)\n#define NS2501_8_DSEL (1<<3)\n#define NS2501_8_BPAS (1<<2)\n#define NS2501_8_RSVD (1<<1)\n#define NS2501_8_PD (1<<0)\n\n#define NS2501_REG9 0x09\n#define NS2501_9_VLOW (1<<7)\n#define NS2501_9_MSEL_MASK (0x7<<4)\n#define NS2501_9_TSEL (1<<3)\n#define NS2501_9_RSEN (1<<2)\n#define NS2501_9_RSVD (1<<1)\n#define NS2501_9_MDI (1<<0)\n\n#define NS2501_REGC 0x0c\n\n \n\n \n#define NS2501_REGC0 0xc0\n#define NS2501_C0_ENABLE (1<<0)\t \n#define NS2501_C0_HSYNC (1<<1)\t \n#define NS2501_C0_VSYNC (1<<2)\t \n#define NS2501_C0_RESET (1<<7)\t \n\n \n#define NS2501_REG41 0x41\n\n \n#define NS2501_F9_REG 0xf9\n#define NS2501_F9_ENABLE (1<<0)\t\t \n#define NS2501_F9_DITHER_MASK (0x7f<<1)\t \n#define NS2501_F9_DITHER_SHIFT 1\t \n\n \n#define NS2501_REG1B 0x1b  \n#define NS2501_REG1C 0x1c  \n#define NS2501_REG1D 0x1d  \n\n \n#define NS2501_REG10 0x10  \n#define NS2501_REG11 0x11  \n#define NS2501_REGB8 0xb8  \n#define NS2501_REGB9 0xb9  \n\n \n#define NS2501_REGC1 0xc1  \n#define NS2501_REGC2 0xc2  \n#define NS2501_REGC3 0xc3  \n#define NS2501_REGC4 0xc4  \n#define NS2501_REGC5 0xc5  \n#define NS2501_REGC6 0xc6  \n#define NS2501_REGC7 0xc7  \n#define NS2501_REGC8 0xc8  \n\n \n#define NS2501_REG80 0x80  \n#define NS2501_REG81 0x81  \n\n \n#define NS2501_REG82 0x82  \n#define NS2501_REG83 0x83  \n\n \n#define NS2501_REG98 0x98  \n#define NS2501_REG99 0x99  \n#define NS2501_REG8E 0x8e  \n#define NS2501_REG8F 0x8f  \n\n \n#define NS2501_REG34 0x34  \n#define NS2501_REG35 0x35  \n#define NS2501_34_ENABLE_OUTPUT (1<<0)  \n#define NS2501_34_ENABLE_BACKLIGHT (1<<1)  \n\n \n#define NS2501_REG9C 0x9c\n#define NS2501_REG9D 0x9d\n\n \n#define NS2501_REGF9 0xf9\n#define NS2501_F9_ENABLE_DITHER (1<<0)  \n#define NS2501_F9_DITHER_MASK (0x7f<<1)  \n#define NS2501_F9_DITHER_SHIFT 1\t \n\nenum {\n\tMODE_640x480,\n\tMODE_800x600,\n\tMODE_1024x768,\n};\n\nstruct ns2501_reg {\n\tu8 offset;\n\tu8 value;\n};\n\n \nstruct ns2501_configuration {\n\tu8 sync;\t\t \n\tu8 conf;\t\t \n\tu8 syncb;\t\t \n\tu8 dither;\t\t \n\tu8 pll_a;\t\t \n\tu16 pll_b;\t\t \n\tu16 hstart;\t\t \n\tu16 hstop;\t\t \n\tu16 vstart;\t\t \n\tu16 vstop;\t\t \n\tu16 vsync;\t\t \n\tu16 vtotal;\t\t \n\tu16 hpos;\t\t \n\tu16 vpos;\t\t \n\tu16 voffs;\t\t \n\tu16 hscale;\t\t \n\tu16 vscale;\t\t \n};\n\n \nstatic const struct ns2501_configuration ns2501_modes[] = {\n\t[MODE_640x480] = {\n\t\t.sync\t= NS2501_C0_ENABLE | NS2501_C0_VSYNC,\n\t\t.conf\t= NS2501_8_VEN | NS2501_8_HEN | NS2501_8_PD,\n\t\t.syncb\t= 0x32,\n\t\t.dither\t= 0x0f,\n\t\t.pll_a\t= 17,\n\t\t.pll_b\t= 852,\n\t\t.hstart\t= 144,\n\t\t.hstop\t= 783,\n\t\t.vstart\t= 22,\n\t\t.vstop\t= 514,\n\t\t.vsync\t= 2047,  \n\t\t.vtotal\t= 1341,\n\t\t.hpos\t= 0,\n\t\t.vpos\t= 16,\n\t\t.voffs\t= 36,\n\t\t.hscale\t= 40960,\n\t\t.vscale\t= 40960\n\t},\n\t[MODE_800x600] = {\n\t\t.sync\t= NS2501_C0_ENABLE |\n\t\t\t  NS2501_C0_HSYNC | NS2501_C0_VSYNC,\n\t\t.conf   = NS2501_8_VEN | NS2501_8_HEN | NS2501_8_PD,\n\t\t.syncb\t= 0x00,\n\t\t.dither\t= 0x0f,\n\t\t.pll_a\t= 25,\n\t\t.pll_b\t= 612,\n\t\t.hstart\t= 215,\n\t\t.hstop\t= 1016,\n\t\t.vstart\t= 26,\n\t\t.vstop\t= 627,\n\t\t.vsync\t= 807,\n\t\t.vtotal\t= 1341,\n\t\t.hpos\t= 0,\n\t\t.vpos\t= 4,\n\t\t.voffs\t= 35,\n\t\t.hscale\t= 51248,\n\t\t.vscale\t= 51232\n\t},\n\t[MODE_1024x768] = {\n\t\t.sync\t= NS2501_C0_ENABLE | NS2501_C0_VSYNC,\n\t\t.conf   = NS2501_8_VEN | NS2501_8_HEN | NS2501_8_PD,\n\t\t.syncb\t= 0x32,\n\t\t.dither\t= 0x0f,\n\t\t.pll_a\t= 11,\n\t\t.pll_b\t= 1350,\n\t\t.hstart\t= 276,\n\t\t.hstop\t= 1299,\n\t\t.vstart\t= 15,\n\t\t.vstop\t= 1056,\n\t\t.vsync\t= 2047,\n\t\t.vtotal\t= 1341,\n\t\t.hpos\t= 0,\n\t\t.vpos\t= 7,\n\t\t.voffs\t= 27,\n\t\t.hscale\t= 65535,\n\t\t.vscale\t= 65535\n\t}\n};\n\n \n\nstatic const struct ns2501_reg mode_agnostic_values[] = {\n\t \n\t[0] = { .offset = 0x0a, .value = 0x81, },\n\t \n\t[1] = { .offset = 0x12, .value = 0x02, },\n\t[2] = { .offset = 0x18, .value = 0x07, },\n\t[3] = { .offset = 0x19, .value = 0x00, },\n\t[4] = { .offset = 0x1a, .value = 0x00, },  \n\t \n\t[5] = { .offset = 0x1e, .value = 0x02, },\n\t[6] = { .offset = 0x1f, .value = 0x40, },\n\t[7] = { .offset = 0x20, .value = 0x00, },\n\t[8] = { .offset = 0x21, .value = 0x00, },\n\t[9] = { .offset = 0x22, .value = 0x00, },\n\t[10] = { .offset = 0x23, .value = 0x00, },\n\t[11] = { .offset = 0x24, .value = 0x00, },\n\t[12] = { .offset = 0x25, .value = 0x00, },\n\t[13] = { .offset = 0x26, .value = 0x00, },\n\t[14] = { .offset = 0x27, .value = 0x00, },\n\t[15] = { .offset = 0x7e, .value = 0x18, },\n\t \n\t[16] = { .offset = 0x84, .value = 0x00, },\n\t[17] = { .offset = 0x85, .value = 0x00, },\n\t[18] = { .offset = 0x86, .value = 0x00, },\n\t[19] = { .offset = 0x87, .value = 0x00, },\n\t[20] = { .offset = 0x88, .value = 0x00, },\n\t[21] = { .offset = 0x89, .value = 0x00, },\n\t[22] = { .offset = 0x8a, .value = 0x00, },\n\t[23] = { .offset = 0x8b, .value = 0x00, },\n\t[24] = { .offset = 0x8c, .value = 0x10, },\n\t[25] = { .offset = 0x8d, .value = 0x02, },\n\t \n\t[26] = { .offset = 0x90, .value = 0xff, },\n\t[27] = { .offset = 0x91, .value = 0x07, },\n\t[28] = { .offset = 0x92, .value = 0xa0, },\n\t[29] = { .offset = 0x93, .value = 0x02, },\n\t[30] = { .offset = 0x94, .value = 0x00, },\n\t[31] = { .offset = 0x95, .value = 0x00, },\n\t[32] = { .offset = 0x96, .value = 0x05, },\n\t[33] = { .offset = 0x97, .value = 0x00, },\n\t \n\t[34] = { .offset = 0x9a, .value = 0x88, },\n\t[35] = { .offset = 0x9b, .value = 0x00, },\n\t \n\t[36] = { .offset = 0x9e, .value = 0x25, },\n\t[37] = { .offset = 0x9f, .value = 0x03, },\n\t[38] = { .offset = 0xa0, .value = 0x28, },\n\t[39] = { .offset = 0xa1, .value = 0x01, },\n\t[40] = { .offset = 0xa2, .value = 0x28, },\n\t[41] = { .offset = 0xa3, .value = 0x05, },\n\t \n\t[42] = { .offset = 0xa4, .value = 0x84, },\n\t[43] = { .offset = 0xa5, .value = 0x00, },\n\t[44] = { .offset = 0xa6, .value = 0x00, },\n\t[45] = { .offset = 0xa7, .value = 0x00, },\n\t[46] = { .offset = 0xa8, .value = 0x00, },\n\t \n\t[47] = { .offset = 0xa9, .value = 0x04, },\n\t[48] = { .offset = 0xaa, .value = 0x70, },\n\t[49] = { .offset = 0xab, .value = 0x4f, },\n\t[50] = { .offset = 0xac, .value = 0x00, },\n\t[51] = { .offset = 0xad, .value = 0x00, },\n\t[52] = { .offset = 0xb6, .value = 0x09, },\n\t[53] = { .offset = 0xb7, .value = 0x03, },\n\t \n\t[54] = { .offset = 0xba, .value = 0x00, },\n\t[55] = { .offset = 0xbb, .value = 0x20, },\n\t[56] = { .offset = 0xf3, .value = 0x90, },\n\t[57] = { .offset = 0xf4, .value = 0x00, },\n\t[58] = { .offset = 0xf7, .value = 0x88, },\n\t \n\t[59] = { .offset = 0xf8, .value = 0x0a, },\n\t[60] = { .offset = 0xf9, .value = 0x00, }\n};\n\nstatic const struct ns2501_reg regs_init[] = {\n\t[0] = { .offset = 0x35, .value = 0xff, },\n\t[1] = { .offset = 0x34, .value = 0x00, },\n\t[2] = { .offset = 0x08, .value = 0x30, },\n};\n\nstruct ns2501_priv {\n\tbool quiet;\n\tconst struct ns2501_configuration *conf;\n};\n\n#define NSPTR(d) ((NS2501Ptr)(d->DriverPrivate.ptr))\n\n \nstatic bool ns2501_readb(struct intel_dvo_device *dvo, int addr, u8 *ch)\n{\n\tstruct ns2501_priv *ns = dvo->dev_priv;\n\tstruct i2c_adapter *adapter = dvo->i2c_bus;\n\tu8 out_buf[2];\n\tu8 in_buf[2];\n\n\tstruct i2c_msg msgs[] = {\n\t\t{\n\t\t .addr = dvo->slave_addr,\n\t\t .flags = 0,\n\t\t .len = 1,\n\t\t .buf = out_buf,\n\t\t },\n\t\t{\n\t\t .addr = dvo->slave_addr,\n\t\t .flags = I2C_M_RD,\n\t\t .len = 1,\n\t\t .buf = in_buf,\n\t\t }\n\t};\n\n\tout_buf[0] = addr;\n\tout_buf[1] = 0;\n\n\tif (i2c_transfer(adapter, msgs, 2) == 2) {\n\t\t*ch = in_buf[0];\n\t\treturn true;\n\t}\n\n\tif (!ns->quiet) {\n\t\tDRM_DEBUG_KMS\n\t\t    (\"Unable to read register 0x%02x from %s:0x%02x.\\n\", addr,\n\t\t     adapter->name, dvo->slave_addr);\n\t}\n\n\treturn false;\n}\n\n \nstatic bool ns2501_writeb(struct intel_dvo_device *dvo, int addr, u8 ch)\n{\n\tstruct ns2501_priv *ns = dvo->dev_priv;\n\tstruct i2c_adapter *adapter = dvo->i2c_bus;\n\tu8 out_buf[2];\n\n\tstruct i2c_msg msg = {\n\t\t.addr = dvo->slave_addr,\n\t\t.flags = 0,\n\t\t.len = 2,\n\t\t.buf = out_buf,\n\t};\n\n\tout_buf[0] = addr;\n\tout_buf[1] = ch;\n\n\tif (i2c_transfer(adapter, &msg, 1) == 1) {\n\t\treturn true;\n\t}\n\n\tif (!ns->quiet) {\n\t\tDRM_DEBUG_KMS(\"Unable to write register 0x%02x to %s:%d\\n\",\n\t\t\t      addr, adapter->name, dvo->slave_addr);\n\t}\n\n\treturn false;\n}\n\n \nstatic bool ns2501_init(struct intel_dvo_device *dvo,\n\t\t\tstruct i2c_adapter *adapter)\n{\n\t \n\tstruct ns2501_priv *ns;\n\tunsigned char ch;\n\n\tns = kzalloc(sizeof(struct ns2501_priv), GFP_KERNEL);\n\tif (ns == NULL)\n\t\treturn false;\n\n\tdvo->i2c_bus = adapter;\n\tdvo->dev_priv = ns;\n\tns->quiet = true;\n\n\tif (!ns2501_readb(dvo, NS2501_VID_LO, &ch))\n\t\tgoto out;\n\n\tif (ch != (NS2501_VID & 0xff)) {\n\t\tDRM_DEBUG_KMS(\"ns2501 not detected got %d: from %s Slave %d.\\n\",\n\t\t\t      ch, adapter->name, dvo->slave_addr);\n\t\tgoto out;\n\t}\n\n\tif (!ns2501_readb(dvo, NS2501_DID_LO, &ch))\n\t\tgoto out;\n\n\tif (ch != (NS2501_DID & 0xff)) {\n\t\tDRM_DEBUG_KMS(\"ns2501 not detected got %d: from %s Slave %d.\\n\",\n\t\t\t      ch, adapter->name, dvo->slave_addr);\n\t\tgoto out;\n\t}\n\tns->quiet = false;\n\n\tDRM_DEBUG_KMS(\"init ns2501 dvo controller successfully!\\n\");\n\n\treturn true;\n\nout:\n\tkfree(ns);\n\treturn false;\n}\n\nstatic enum drm_connector_status ns2501_detect(struct intel_dvo_device *dvo)\n{\n\t \n\treturn connector_status_connected;\n}\n\nstatic enum drm_mode_status ns2501_mode_valid(struct intel_dvo_device *dvo,\n\t\t\t\t\t      struct drm_display_mode *mode)\n{\n\tDRM_DEBUG_KMS\n\t    (\"is mode valid (hdisplay=%d,htotal=%d,vdisplay=%d,vtotal=%d)\\n\",\n\t     mode->hdisplay, mode->htotal, mode->vdisplay, mode->vtotal);\n\n\t \n\tif ((mode->hdisplay == 640 && mode->vdisplay == 480 && mode->clock == 25175) ||\n\t    (mode->hdisplay == 800 && mode->vdisplay == 600 && mode->clock == 40000) ||\n\t    (mode->hdisplay == 1024 && mode->vdisplay == 768 && mode->clock == 65000)) {\n\t\treturn MODE_OK;\n\t} else {\n\t\treturn MODE_ONE_SIZE;\t \n\t}\n}\n\nstatic void ns2501_mode_set(struct intel_dvo_device *dvo,\n\t\t\t    const struct drm_display_mode *mode,\n\t\t\t    const struct drm_display_mode *adjusted_mode)\n{\n\tconst struct ns2501_configuration *conf;\n\tstruct ns2501_priv *ns = (struct ns2501_priv *)(dvo->dev_priv);\n\tint mode_idx, i;\n\n\tDRM_DEBUG_KMS\n\t    (\"set mode (hdisplay=%d,htotal=%d,vdisplay=%d,vtotal=%d).\\n\",\n\t     mode->hdisplay, mode->htotal, mode->vdisplay, mode->vtotal);\n\n\tDRM_DEBUG_KMS(\"Detailed requested mode settings are:\\n\"\n\t\t\t\"clock\t\t: %d kHz\\n\"\n\t\t\t\"hdisplay\t: %d\\n\"\n\t\t\t\"hblank start\t: %d\\n\"\n\t\t\t\"hblank end\t: %d\\n\"\n\t\t\t\"hsync start\t: %d\\n\"\n\t\t\t\"hsync end\t: %d\\n\"\n\t\t\t\"htotal\t\t: %d\\n\"\n\t\t\t\"hskew\t\t: %d\\n\"\n\t\t\t\"vdisplay\t: %d\\n\"\n\t\t\t\"vblank start\t: %d\\n\"\n\t\t\t\"hblank end\t: %d\\n\"\n\t\t\t\"vsync start\t: %d\\n\"\n\t\t\t\"vsync end\t: %d\\n\"\n\t\t\t\"vtotal\t\t: %d\\n\",\n\t\t\tadjusted_mode->crtc_clock,\n\t\t\tadjusted_mode->crtc_hdisplay,\n\t\t\tadjusted_mode->crtc_hblank_start,\n\t\t\tadjusted_mode->crtc_hblank_end,\n\t\t\tadjusted_mode->crtc_hsync_start,\n\t\t\tadjusted_mode->crtc_hsync_end,\n\t\t\tadjusted_mode->crtc_htotal,\n\t\t\tadjusted_mode->crtc_hskew,\n\t\t\tadjusted_mode->crtc_vdisplay,\n\t\t\tadjusted_mode->crtc_vblank_start,\n\t\t\tadjusted_mode->crtc_vblank_end,\n\t\t\tadjusted_mode->crtc_vsync_start,\n\t\t\tadjusted_mode->crtc_vsync_end,\n\t\t\tadjusted_mode->crtc_vtotal);\n\n\tif (mode->hdisplay == 640 && mode->vdisplay == 480)\n\t\tmode_idx = MODE_640x480;\n\telse if (mode->hdisplay == 800 && mode->vdisplay == 600)\n\t\tmode_idx = MODE_800x600;\n\telse if (mode->hdisplay == 1024 && mode->vdisplay == 768)\n\t\tmode_idx = MODE_1024x768;\n\telse\n\t\treturn;\n\n\t \n\tfor (i = 0; i < ARRAY_SIZE(regs_init); i++)\n\t\tns2501_writeb(dvo, regs_init[i].offset, regs_init[i].value);\n\n\t \n\tfor (i = 0; i < ARRAY_SIZE(mode_agnostic_values); i++)\n\t\tns2501_writeb(dvo, mode_agnostic_values[i].offset,\n\t\t\t\tmode_agnostic_values[i].value);\n\n\t \n\tconf = ns2501_modes + mode_idx;\n\tns->conf = conf;\n\n\tns2501_writeb(dvo, NS2501_REG8, conf->conf);\n\tns2501_writeb(dvo, NS2501_REG1B, conf->pll_a);\n\tns2501_writeb(dvo, NS2501_REG1C, conf->pll_b & 0xff);\n\tns2501_writeb(dvo, NS2501_REG1D, conf->pll_b >> 8);\n\tns2501_writeb(dvo, NS2501_REGC1, conf->hstart & 0xff);\n\tns2501_writeb(dvo, NS2501_REGC2, conf->hstart >> 8);\n\tns2501_writeb(dvo, NS2501_REGC3, conf->hstop & 0xff);\n\tns2501_writeb(dvo, NS2501_REGC4, conf->hstop >> 8);\n\tns2501_writeb(dvo, NS2501_REGC5, conf->vstart & 0xff);\n\tns2501_writeb(dvo, NS2501_REGC6, conf->vstart >> 8);\n\tns2501_writeb(dvo, NS2501_REGC7, conf->vstop & 0xff);\n\tns2501_writeb(dvo, NS2501_REGC8, conf->vstop >> 8);\n\tns2501_writeb(dvo, NS2501_REG80, conf->vsync & 0xff);\n\tns2501_writeb(dvo, NS2501_REG81, conf->vsync >> 8);\n\tns2501_writeb(dvo, NS2501_REG82, conf->vtotal & 0xff);\n\tns2501_writeb(dvo, NS2501_REG83, conf->vtotal >> 8);\n\tns2501_writeb(dvo, NS2501_REG98, conf->hpos & 0xff);\n\tns2501_writeb(dvo, NS2501_REG99, conf->hpos >> 8);\n\tns2501_writeb(dvo, NS2501_REG8E, conf->vpos & 0xff);\n\tns2501_writeb(dvo, NS2501_REG8F, conf->vpos >> 8);\n\tns2501_writeb(dvo, NS2501_REG9C, conf->voffs & 0xff);\n\tns2501_writeb(dvo, NS2501_REG9D, conf->voffs >> 8);\n\tns2501_writeb(dvo, NS2501_REGB8, conf->hscale & 0xff);\n\tns2501_writeb(dvo, NS2501_REGB9, conf->hscale >> 8);\n\tns2501_writeb(dvo, NS2501_REG10, conf->vscale & 0xff);\n\tns2501_writeb(dvo, NS2501_REG11, conf->vscale >> 8);\n\tns2501_writeb(dvo, NS2501_REGF9, conf->dither);\n\tns2501_writeb(dvo, NS2501_REG41, conf->syncb);\n\tns2501_writeb(dvo, NS2501_REGC0, conf->sync);\n}\n\n \nstatic bool ns2501_get_hw_state(struct intel_dvo_device *dvo)\n{\n\tunsigned char ch;\n\n\tif (!ns2501_readb(dvo, NS2501_REG8, &ch))\n\t\treturn false;\n\n\treturn ch & NS2501_8_PD;\n}\n\n \nstatic void ns2501_dpms(struct intel_dvo_device *dvo, bool enable)\n{\n\tstruct ns2501_priv *ns = (struct ns2501_priv *)(dvo->dev_priv);\n\n\tDRM_DEBUG_KMS(\"Trying set the dpms of the DVO to %i\\n\", enable);\n\n\tif (enable) {\n\t\tns2501_writeb(dvo, NS2501_REGC0, ns->conf->sync | 0x08);\n\n\t\tns2501_writeb(dvo, NS2501_REG41, ns->conf->syncb);\n\n\t\tns2501_writeb(dvo, NS2501_REG34, NS2501_34_ENABLE_OUTPUT);\n\t\tmsleep(15);\n\n\t\tns2501_writeb(dvo, NS2501_REG8,\n\t\t\t\tns->conf->conf | NS2501_8_BPAS);\n\t\tif (!(ns->conf->conf & NS2501_8_BPAS))\n\t\t\tns2501_writeb(dvo, NS2501_REG8, ns->conf->conf);\n\t\tmsleep(200);\n\n\t\tns2501_writeb(dvo, NS2501_REG34,\n\t\t\tNS2501_34_ENABLE_OUTPUT | NS2501_34_ENABLE_BACKLIGHT);\n\n\t\tns2501_writeb(dvo, NS2501_REGC0, ns->conf->sync);\n\t} else {\n\t\tns2501_writeb(dvo, NS2501_REG34, NS2501_34_ENABLE_OUTPUT);\n\t\tmsleep(200);\n\n\t\tns2501_writeb(dvo, NS2501_REG8, NS2501_8_VEN | NS2501_8_HEN |\n\t\t\t\tNS2501_8_BPAS);\n\t\tmsleep(15);\n\n\t\tns2501_writeb(dvo, NS2501_REG34, 0x00);\n\t}\n}\n\nstatic void ns2501_destroy(struct intel_dvo_device *dvo)\n{\n\tstruct ns2501_priv *ns = dvo->dev_priv;\n\n\tif (ns) {\n\t\tkfree(ns);\n\t\tdvo->dev_priv = NULL;\n\t}\n}\n\nconst struct intel_dvo_dev_ops ns2501_ops = {\n\t.init = ns2501_init,\n\t.detect = ns2501_detect,\n\t.mode_valid = ns2501_mode_valid,\n\t.mode_set = ns2501_mode_set,\n\t.dpms = ns2501_dpms,\n\t.get_hw_state = ns2501_get_hw_state,\n\t.destroy = ns2501_destroy,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}