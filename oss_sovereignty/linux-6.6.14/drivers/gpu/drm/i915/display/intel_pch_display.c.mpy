{
  "module_name": "intel_pch_display.c",
  "hash_id": "84772a7e8349d7d7c3e13c4fdb7ec03133e1bead77528b23a899efb104058200",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/i915/display/intel_pch_display.c",
  "human_readable_source": "\n \n\n#include \"g4x_dp.h\"\n#include \"i915_reg.h\"\n#include \"intel_crt.h\"\n#include \"intel_de.h\"\n#include \"intel_display_types.h\"\n#include \"intel_fdi.h\"\n#include \"intel_fdi_regs.h\"\n#include \"intel_lvds.h\"\n#include \"intel_lvds_regs.h\"\n#include \"intel_pch_display.h\"\n#include \"intel_pch_refclk.h\"\n#include \"intel_pps.h\"\n#include \"intel_sdvo.h\"\n\nbool intel_has_pch_trancoder(struct drm_i915_private *i915,\n\t\t\t     enum pipe pch_transcoder)\n{\n\treturn HAS_PCH_IBX(i915) || HAS_PCH_CPT(i915) ||\n\t\t(HAS_PCH_LPT_H(i915) && pch_transcoder == PIPE_A);\n}\n\nenum pipe intel_crtc_pch_transcoder(struct intel_crtc *crtc)\n{\n\tstruct drm_i915_private *i915 = to_i915(crtc->base.dev);\n\n\tif (HAS_PCH_LPT(i915))\n\t\treturn PIPE_A;\n\telse\n\t\treturn crtc->pipe;\n}\n\nstatic void assert_pch_dp_disabled(struct drm_i915_private *dev_priv,\n\t\t\t\t   enum pipe pipe, enum port port,\n\t\t\t\t   i915_reg_t dp_reg)\n{\n\tenum pipe port_pipe;\n\tbool state;\n\n\tstate = g4x_dp_port_enabled(dev_priv, dp_reg, port, &port_pipe);\n\n\tI915_STATE_WARN(dev_priv, state && port_pipe == pipe,\n\t\t\t\"PCH DP %c enabled on transcoder %c, should be disabled\\n\",\n\t\t\tport_name(port), pipe_name(pipe));\n\n\tI915_STATE_WARN(dev_priv,\n\t\t\tHAS_PCH_IBX(dev_priv) && !state && port_pipe == PIPE_B,\n\t\t\t\"IBX PCH DP %c still using transcoder B\\n\",\n\t\t\tport_name(port));\n}\n\nstatic void assert_pch_hdmi_disabled(struct drm_i915_private *dev_priv,\n\t\t\t\t     enum pipe pipe, enum port port,\n\t\t\t\t     i915_reg_t hdmi_reg)\n{\n\tenum pipe port_pipe;\n\tbool state;\n\n\tstate = intel_sdvo_port_enabled(dev_priv, hdmi_reg, &port_pipe);\n\n\tI915_STATE_WARN(dev_priv, state && port_pipe == pipe,\n\t\t\t\"PCH HDMI %c enabled on transcoder %c, should be disabled\\n\",\n\t\t\tport_name(port), pipe_name(pipe));\n\n\tI915_STATE_WARN(dev_priv,\n\t\t\tHAS_PCH_IBX(dev_priv) && !state && port_pipe == PIPE_B,\n\t\t\t\"IBX PCH HDMI %c still using transcoder B\\n\",\n\t\t\tport_name(port));\n}\n\nstatic void assert_pch_ports_disabled(struct drm_i915_private *dev_priv,\n\t\t\t\t      enum pipe pipe)\n{\n\tenum pipe port_pipe;\n\n\tassert_pch_dp_disabled(dev_priv, pipe, PORT_B, PCH_DP_B);\n\tassert_pch_dp_disabled(dev_priv, pipe, PORT_C, PCH_DP_C);\n\tassert_pch_dp_disabled(dev_priv, pipe, PORT_D, PCH_DP_D);\n\n\tI915_STATE_WARN(dev_priv,\n\t\t\tintel_crt_port_enabled(dev_priv, PCH_ADPA, &port_pipe) && port_pipe == pipe,\n\t\t\t\"PCH VGA enabled on transcoder %c, should be disabled\\n\",\n\t\t\tpipe_name(pipe));\n\n\tI915_STATE_WARN(dev_priv,\n\t\t\tintel_lvds_port_enabled(dev_priv, PCH_LVDS, &port_pipe) && port_pipe == pipe,\n\t\t\t\"PCH LVDS enabled on transcoder %c, should be disabled\\n\",\n\t\t\tpipe_name(pipe));\n\n\t \n\tassert_pch_hdmi_disabled(dev_priv, pipe, PORT_B, PCH_HDMIB);\n\tassert_pch_hdmi_disabled(dev_priv, pipe, PORT_C, PCH_HDMIC);\n\tassert_pch_hdmi_disabled(dev_priv, pipe, PORT_D, PCH_HDMID);\n}\n\nstatic void assert_pch_transcoder_disabled(struct drm_i915_private *dev_priv,\n\t\t\t\t\t   enum pipe pipe)\n{\n\tu32 val;\n\tbool enabled;\n\n\tval = intel_de_read(dev_priv, PCH_TRANSCONF(pipe));\n\tenabled = !!(val & TRANS_ENABLE);\n\tI915_STATE_WARN(dev_priv, enabled,\n\t\t\t\"transcoder assertion failed, should be off on pipe %c but is still active\\n\",\n\t\t\tpipe_name(pipe));\n}\n\nstatic void ibx_sanitize_pch_hdmi_port(struct drm_i915_private *dev_priv,\n\t\t\t\t       enum port port, i915_reg_t hdmi_reg)\n{\n\tu32 val = intel_de_read(dev_priv, hdmi_reg);\n\n\tif (val & SDVO_ENABLE ||\n\t    (val & SDVO_PIPE_SEL_MASK) == SDVO_PIPE_SEL(PIPE_A))\n\t\treturn;\n\n\tdrm_dbg_kms(&dev_priv->drm,\n\t\t    \"Sanitizing transcoder select for HDMI %c\\n\",\n\t\t    port_name(port));\n\n\tval &= ~SDVO_PIPE_SEL_MASK;\n\tval |= SDVO_PIPE_SEL(PIPE_A);\n\n\tintel_de_write(dev_priv, hdmi_reg, val);\n}\n\nstatic void ibx_sanitize_pch_dp_port(struct drm_i915_private *dev_priv,\n\t\t\t\t     enum port port, i915_reg_t dp_reg)\n{\n\tu32 val = intel_de_read(dev_priv, dp_reg);\n\n\tif (val & DP_PORT_EN ||\n\t    (val & DP_PIPE_SEL_MASK) == DP_PIPE_SEL(PIPE_A))\n\t\treturn;\n\n\tdrm_dbg_kms(&dev_priv->drm,\n\t\t    \"Sanitizing transcoder select for DP %c\\n\",\n\t\t    port_name(port));\n\n\tval &= ~DP_PIPE_SEL_MASK;\n\tval |= DP_PIPE_SEL(PIPE_A);\n\n\tintel_de_write(dev_priv, dp_reg, val);\n}\n\nstatic void ibx_sanitize_pch_ports(struct drm_i915_private *dev_priv)\n{\n\t \n\tibx_sanitize_pch_dp_port(dev_priv, PORT_B, PCH_DP_B);\n\tibx_sanitize_pch_dp_port(dev_priv, PORT_C, PCH_DP_C);\n\tibx_sanitize_pch_dp_port(dev_priv, PORT_D, PCH_DP_D);\n\n\t \n\tibx_sanitize_pch_hdmi_port(dev_priv, PORT_B, PCH_HDMIB);\n\tibx_sanitize_pch_hdmi_port(dev_priv, PORT_C, PCH_HDMIC);\n\tibx_sanitize_pch_hdmi_port(dev_priv, PORT_D, PCH_HDMID);\n}\n\nstatic void intel_pch_transcoder_set_m1_n1(struct intel_crtc *crtc,\n\t\t\t\t\t   const struct intel_link_m_n *m_n)\n{\n\tstruct drm_i915_private *dev_priv = to_i915(crtc->base.dev);\n\tenum pipe pipe = crtc->pipe;\n\n\tintel_set_m_n(dev_priv, m_n,\n\t\t      PCH_TRANS_DATA_M1(pipe), PCH_TRANS_DATA_N1(pipe),\n\t\t      PCH_TRANS_LINK_M1(pipe), PCH_TRANS_LINK_N1(pipe));\n}\n\nstatic void intel_pch_transcoder_set_m2_n2(struct intel_crtc *crtc,\n\t\t\t\t\t   const struct intel_link_m_n *m_n)\n{\n\tstruct drm_i915_private *dev_priv = to_i915(crtc->base.dev);\n\tenum pipe pipe = crtc->pipe;\n\n\tintel_set_m_n(dev_priv, m_n,\n\t\t      PCH_TRANS_DATA_M2(pipe), PCH_TRANS_DATA_N2(pipe),\n\t\t      PCH_TRANS_LINK_M2(pipe), PCH_TRANS_LINK_N2(pipe));\n}\n\nvoid intel_pch_transcoder_get_m1_n1(struct intel_crtc *crtc,\n\t\t\t\t    struct intel_link_m_n *m_n)\n{\n\tstruct drm_i915_private *dev_priv = to_i915(crtc->base.dev);\n\tenum pipe pipe = crtc->pipe;\n\n\tintel_get_m_n(dev_priv, m_n,\n\t\t      PCH_TRANS_DATA_M1(pipe), PCH_TRANS_DATA_N1(pipe),\n\t\t      PCH_TRANS_LINK_M1(pipe), PCH_TRANS_LINK_N1(pipe));\n}\n\nvoid intel_pch_transcoder_get_m2_n2(struct intel_crtc *crtc,\n\t\t\t\t    struct intel_link_m_n *m_n)\n{\n\tstruct drm_i915_private *dev_priv = to_i915(crtc->base.dev);\n\tenum pipe pipe = crtc->pipe;\n\n\tintel_get_m_n(dev_priv, m_n,\n\t\t      PCH_TRANS_DATA_M2(pipe), PCH_TRANS_DATA_N2(pipe),\n\t\t      PCH_TRANS_LINK_M2(pipe), PCH_TRANS_LINK_N2(pipe));\n}\n\nstatic void ilk_pch_transcoder_set_timings(const struct intel_crtc_state *crtc_state,\n\t\t\t\t\t   enum pipe pch_transcoder)\n{\n\tstruct intel_crtc *crtc = to_intel_crtc(crtc_state->uapi.crtc);\n\tstruct drm_i915_private *dev_priv = to_i915(crtc->base.dev);\n\tenum transcoder cpu_transcoder = crtc_state->cpu_transcoder;\n\n\tintel_de_write(dev_priv, PCH_TRANS_HTOTAL(pch_transcoder),\n\t\t       intel_de_read(dev_priv, TRANS_HTOTAL(cpu_transcoder)));\n\tintel_de_write(dev_priv, PCH_TRANS_HBLANK(pch_transcoder),\n\t\t       intel_de_read(dev_priv, TRANS_HBLANK(cpu_transcoder)));\n\tintel_de_write(dev_priv, PCH_TRANS_HSYNC(pch_transcoder),\n\t\t       intel_de_read(dev_priv, TRANS_HSYNC(cpu_transcoder)));\n\n\tintel_de_write(dev_priv, PCH_TRANS_VTOTAL(pch_transcoder),\n\t\t       intel_de_read(dev_priv, TRANS_VTOTAL(cpu_transcoder)));\n\tintel_de_write(dev_priv, PCH_TRANS_VBLANK(pch_transcoder),\n\t\t       intel_de_read(dev_priv, TRANS_VBLANK(cpu_transcoder)));\n\tintel_de_write(dev_priv, PCH_TRANS_VSYNC(pch_transcoder),\n\t\t       intel_de_read(dev_priv, TRANS_VSYNC(cpu_transcoder)));\n\tintel_de_write(dev_priv, PCH_TRANS_VSYNCSHIFT(pch_transcoder),\n\t\t       intel_de_read(dev_priv, TRANS_VSYNCSHIFT(cpu_transcoder)));\n}\n\nstatic void ilk_enable_pch_transcoder(const struct intel_crtc_state *crtc_state)\n{\n\tstruct intel_crtc *crtc = to_intel_crtc(crtc_state->uapi.crtc);\n\tstruct drm_i915_private *dev_priv = to_i915(crtc->base.dev);\n\tenum pipe pipe = crtc->pipe;\n\ti915_reg_t reg;\n\tu32 val, pipeconf_val;\n\n\t \n\tassert_shared_dpll_enabled(dev_priv, crtc_state->shared_dpll);\n\n\t \n\tassert_fdi_tx_enabled(dev_priv, pipe);\n\tassert_fdi_rx_enabled(dev_priv, pipe);\n\n\tif (HAS_PCH_CPT(dev_priv)) {\n\t\treg = TRANS_CHICKEN2(pipe);\n\t\tval = intel_de_read(dev_priv, reg);\n\t\t \n\t\tval |= TRANS_CHICKEN2_TIMING_OVERRIDE;\n\t\t \n\t\tval &= ~TRANS_CHICKEN2_FRAME_START_DELAY_MASK;\n\t\tval |= TRANS_CHICKEN2_FRAME_START_DELAY(crtc_state->framestart_delay - 1);\n\t\tintel_de_write(dev_priv, reg, val);\n\t}\n\n\treg = PCH_TRANSCONF(pipe);\n\tval = intel_de_read(dev_priv, reg);\n\tpipeconf_val = intel_de_read(dev_priv, TRANSCONF(pipe));\n\n\tif (HAS_PCH_IBX(dev_priv)) {\n\t\t \n\t\tval &= ~TRANS_FRAME_START_DELAY_MASK;\n\t\tval |= TRANS_FRAME_START_DELAY(crtc_state->framestart_delay - 1);\n\n\t\t \n\t\tval &= ~TRANSCONF_BPC_MASK;\n\t\tif (intel_crtc_has_type(crtc_state, INTEL_OUTPUT_HDMI))\n\t\t\tval |= TRANSCONF_BPC_8;\n\t\telse\n\t\t\tval |= pipeconf_val & TRANSCONF_BPC_MASK;\n\t}\n\n\tval &= ~TRANS_INTERLACE_MASK;\n\tif ((pipeconf_val & TRANSCONF_INTERLACE_MASK_ILK) == TRANSCONF_INTERLACE_IF_ID_ILK) {\n\t\tif (HAS_PCH_IBX(dev_priv) &&\n\t\t    intel_crtc_has_type(crtc_state, INTEL_OUTPUT_SDVO))\n\t\t\tval |= TRANS_INTERLACE_LEGACY_VSYNC_IBX;\n\t\telse\n\t\t\tval |= TRANS_INTERLACE_INTERLACED;\n\t} else {\n\t\tval |= TRANS_INTERLACE_PROGRESSIVE;\n\t}\n\n\tintel_de_write(dev_priv, reg, val | TRANS_ENABLE);\n\tif (intel_de_wait_for_set(dev_priv, reg, TRANS_STATE_ENABLE, 100))\n\t\tdrm_err(&dev_priv->drm, \"failed to enable transcoder %c\\n\",\n\t\t\tpipe_name(pipe));\n}\n\nstatic void ilk_disable_pch_transcoder(struct intel_crtc *crtc)\n{\n\tstruct drm_i915_private *dev_priv = to_i915(crtc->base.dev);\n\tenum pipe pipe = crtc->pipe;\n\ti915_reg_t reg;\n\n\t \n\tassert_fdi_tx_disabled(dev_priv, pipe);\n\tassert_fdi_rx_disabled(dev_priv, pipe);\n\n\t \n\tassert_pch_ports_disabled(dev_priv, pipe);\n\n\treg = PCH_TRANSCONF(pipe);\n\tintel_de_rmw(dev_priv, reg, TRANS_ENABLE, 0);\n\t \n\tif (intel_de_wait_for_clear(dev_priv, reg, TRANS_STATE_ENABLE, 50))\n\t\tdrm_err(&dev_priv->drm, \"failed to disable transcoder %c\\n\",\n\t\t\tpipe_name(pipe));\n\n\tif (HAS_PCH_CPT(dev_priv))\n\t\t \n\t\tintel_de_rmw(dev_priv, TRANS_CHICKEN2(pipe),\n\t\t\t     TRANS_CHICKEN2_TIMING_OVERRIDE, 0);\n}\n\nvoid ilk_pch_pre_enable(struct intel_atomic_state *state,\n\t\t\tstruct intel_crtc *crtc)\n{\n\tconst struct intel_crtc_state *crtc_state =\n\t\tintel_atomic_get_new_crtc_state(state, crtc);\n\n\t \n\tilk_fdi_pll_enable(crtc_state);\n}\n\n \nvoid ilk_pch_enable(struct intel_atomic_state *state,\n\t\t    struct intel_crtc *crtc)\n{\n\tstruct drm_i915_private *dev_priv = to_i915(crtc->base.dev);\n\tconst struct intel_crtc_state *crtc_state =\n\t\tintel_atomic_get_new_crtc_state(state, crtc);\n\tenum pipe pipe = crtc->pipe;\n\tu32 temp;\n\n\tassert_pch_transcoder_disabled(dev_priv, pipe);\n\n\t \n\tintel_fdi_link_train(crtc, crtc_state);\n\n\t \n\tif (HAS_PCH_CPT(dev_priv)) {\n\t\tu32 sel;\n\n\t\ttemp = intel_de_read(dev_priv, PCH_DPLL_SEL);\n\t\ttemp |= TRANS_DPLL_ENABLE(pipe);\n\t\tsel = TRANS_DPLLB_SEL(pipe);\n\t\tif (crtc_state->shared_dpll ==\n\t\t    intel_get_shared_dpll_by_id(dev_priv, DPLL_ID_PCH_PLL_B))\n\t\t\ttemp |= sel;\n\t\telse\n\t\t\ttemp &= ~sel;\n\t\tintel_de_write(dev_priv, PCH_DPLL_SEL, temp);\n\t}\n\n\t \n\tintel_enable_shared_dpll(crtc_state);\n\n\t \n\tassert_pps_unlocked(dev_priv, pipe);\n\tif (intel_crtc_has_dp_encoder(crtc_state)) {\n\t\tintel_pch_transcoder_set_m1_n1(crtc, &crtc_state->dp_m_n);\n\t\tintel_pch_transcoder_set_m2_n2(crtc, &crtc_state->dp_m2_n2);\n\t}\n\tilk_pch_transcoder_set_timings(crtc_state, pipe);\n\n\tintel_fdi_normal_train(crtc);\n\n\t \n\tif (HAS_PCH_CPT(dev_priv) &&\n\t    intel_crtc_has_dp_encoder(crtc_state)) {\n\t\tconst struct drm_display_mode *adjusted_mode =\n\t\t\t&crtc_state->hw.adjusted_mode;\n\t\tu32 bpc = (intel_de_read(dev_priv, TRANSCONF(pipe)) & TRANSCONF_BPC_MASK) >> 5;\n\t\ti915_reg_t reg = TRANS_DP_CTL(pipe);\n\t\tenum port port;\n\n\t\ttemp = intel_de_read(dev_priv, reg);\n\t\ttemp &= ~(TRANS_DP_PORT_SEL_MASK |\n\t\t\t  TRANS_DP_VSYNC_ACTIVE_HIGH |\n\t\t\t  TRANS_DP_HSYNC_ACTIVE_HIGH |\n\t\t\t  TRANS_DP_BPC_MASK);\n\t\ttemp |= TRANS_DP_OUTPUT_ENABLE;\n\t\ttemp |= bpc << 9;  \n\n\t\tif (adjusted_mode->flags & DRM_MODE_FLAG_PHSYNC)\n\t\t\ttemp |= TRANS_DP_HSYNC_ACTIVE_HIGH;\n\t\tif (adjusted_mode->flags & DRM_MODE_FLAG_PVSYNC)\n\t\t\ttemp |= TRANS_DP_VSYNC_ACTIVE_HIGH;\n\n\t\tport = intel_get_crtc_new_encoder(state, crtc_state)->port;\n\t\tdrm_WARN_ON(&dev_priv->drm, port < PORT_B || port > PORT_D);\n\t\ttemp |= TRANS_DP_PORT_SEL(port);\n\n\t\tintel_de_write(dev_priv, reg, temp);\n\t}\n\n\tilk_enable_pch_transcoder(crtc_state);\n}\n\nvoid ilk_pch_disable(struct intel_atomic_state *state,\n\t\t     struct intel_crtc *crtc)\n{\n\tilk_fdi_disable(crtc);\n}\n\nvoid ilk_pch_post_disable(struct intel_atomic_state *state,\n\t\t\t  struct intel_crtc *crtc)\n{\n\tstruct drm_i915_private *dev_priv = to_i915(crtc->base.dev);\n\tenum pipe pipe = crtc->pipe;\n\n\tilk_disable_pch_transcoder(crtc);\n\n\tif (HAS_PCH_CPT(dev_priv)) {\n\t\t \n\t\tintel_de_rmw(dev_priv, TRANS_DP_CTL(pipe),\n\t\t\t     TRANS_DP_OUTPUT_ENABLE | TRANS_DP_PORT_SEL_MASK,\n\t\t\t     TRANS_DP_PORT_SEL_NONE);\n\n\t\t \n\t\tintel_de_rmw(dev_priv, PCH_DPLL_SEL,\n\t\t\t     TRANS_DPLL_ENABLE(pipe) | TRANS_DPLLB_SEL(pipe), 0);\n\t}\n\n\tilk_fdi_pll_disable(crtc);\n}\n\nstatic void ilk_pch_clock_get(struct intel_crtc_state *crtc_state)\n{\n\tstruct intel_crtc *crtc = to_intel_crtc(crtc_state->uapi.crtc);\n\tstruct drm_i915_private *dev_priv = to_i915(crtc->base.dev);\n\n\t \n\ti9xx_crtc_clock_get(crtc, crtc_state);\n\n\t \n\tcrtc_state->hw.adjusted_mode.crtc_clock =\n\t\tintel_dotclock_calculate(intel_fdi_link_freq(dev_priv, crtc_state),\n\t\t\t\t\t &crtc_state->fdi_m_n);\n}\n\nvoid ilk_pch_get_config(struct intel_crtc_state *crtc_state)\n{\n\tstruct intel_crtc *crtc = to_intel_crtc(crtc_state->uapi.crtc);\n\tstruct drm_i915_private *dev_priv = to_i915(crtc->base.dev);\n\tstruct intel_shared_dpll *pll;\n\tenum pipe pipe = crtc->pipe;\n\tenum intel_dpll_id pll_id;\n\tbool pll_active;\n\tu32 tmp;\n\n\tif ((intel_de_read(dev_priv, PCH_TRANSCONF(pipe)) & TRANS_ENABLE) == 0)\n\t\treturn;\n\n\tcrtc_state->has_pch_encoder = true;\n\n\ttmp = intel_de_read(dev_priv, FDI_RX_CTL(pipe));\n\tcrtc_state->fdi_lanes = ((FDI_DP_PORT_WIDTH_MASK & tmp) >>\n\t\t\t\t FDI_DP_PORT_WIDTH_SHIFT) + 1;\n\n\tintel_cpu_transcoder_get_m1_n1(crtc, crtc_state->cpu_transcoder,\n\t\t\t\t       &crtc_state->fdi_m_n);\n\n\tif (HAS_PCH_IBX(dev_priv)) {\n\t\t \n\t\tpll_id = (enum intel_dpll_id) pipe;\n\t} else {\n\t\ttmp = intel_de_read(dev_priv, PCH_DPLL_SEL);\n\t\tif (tmp & TRANS_DPLLB_SEL(pipe))\n\t\t\tpll_id = DPLL_ID_PCH_PLL_B;\n\t\telse\n\t\t\tpll_id = DPLL_ID_PCH_PLL_A;\n\t}\n\n\tcrtc_state->shared_dpll = intel_get_shared_dpll_by_id(dev_priv, pll_id);\n\tpll = crtc_state->shared_dpll;\n\n\tpll_active = intel_dpll_get_hw_state(dev_priv, pll,\n\t\t\t\t\t     &crtc_state->dpll_hw_state);\n\tdrm_WARN_ON(&dev_priv->drm, !pll_active);\n\n\ttmp = crtc_state->dpll_hw_state.dpll;\n\tcrtc_state->pixel_multiplier =\n\t\t((tmp & PLL_REF_SDVO_HDMI_MULTIPLIER_MASK)\n\t\t >> PLL_REF_SDVO_HDMI_MULTIPLIER_SHIFT) + 1;\n\n\tilk_pch_clock_get(crtc_state);\n}\n\nstatic void lpt_enable_pch_transcoder(const struct intel_crtc_state *crtc_state)\n{\n\tstruct intel_crtc *crtc = to_intel_crtc(crtc_state->uapi.crtc);\n\tstruct drm_i915_private *dev_priv = to_i915(crtc->base.dev);\n\tenum transcoder cpu_transcoder = crtc_state->cpu_transcoder;\n\tu32 val, pipeconf_val;\n\n\t \n\tassert_fdi_tx_enabled(dev_priv, (enum pipe) cpu_transcoder);\n\tassert_fdi_rx_enabled(dev_priv, PIPE_A);\n\n\tval = intel_de_read(dev_priv, TRANS_CHICKEN2(PIPE_A));\n\t \n\tval |= TRANS_CHICKEN2_TIMING_OVERRIDE;\n\t \n\tval &= ~TRANS_CHICKEN2_FRAME_START_DELAY_MASK;\n\tval |= TRANS_CHICKEN2_FRAME_START_DELAY(crtc_state->framestart_delay - 1);\n\tintel_de_write(dev_priv, TRANS_CHICKEN2(PIPE_A), val);\n\n\tval = TRANS_ENABLE;\n\tpipeconf_val = intel_de_read(dev_priv, TRANSCONF(cpu_transcoder));\n\n\tif ((pipeconf_val & TRANSCONF_INTERLACE_MASK_HSW) == TRANSCONF_INTERLACE_IF_ID_ILK)\n\t\tval |= TRANS_INTERLACE_INTERLACED;\n\telse\n\t\tval |= TRANS_INTERLACE_PROGRESSIVE;\n\n\tintel_de_write(dev_priv, LPT_TRANSCONF, val);\n\tif (intel_de_wait_for_set(dev_priv, LPT_TRANSCONF,\n\t\t\t\t  TRANS_STATE_ENABLE, 100))\n\t\tdrm_err(&dev_priv->drm, \"Failed to enable PCH transcoder\\n\");\n}\n\nstatic void lpt_disable_pch_transcoder(struct drm_i915_private *dev_priv)\n{\n\tintel_de_rmw(dev_priv, LPT_TRANSCONF, TRANS_ENABLE, 0);\n\t \n\tif (intel_de_wait_for_clear(dev_priv, LPT_TRANSCONF,\n\t\t\t\t    TRANS_STATE_ENABLE, 50))\n\t\tdrm_err(&dev_priv->drm, \"Failed to disable PCH transcoder\\n\");\n\n\t \n\tintel_de_rmw(dev_priv, TRANS_CHICKEN2(PIPE_A), TRANS_CHICKEN2_TIMING_OVERRIDE, 0);\n}\n\nvoid lpt_pch_enable(struct intel_atomic_state *state,\n\t\t    struct intel_crtc *crtc)\n{\n\tstruct drm_i915_private *dev_priv = to_i915(crtc->base.dev);\n\tconst struct intel_crtc_state *crtc_state =\n\t\tintel_atomic_get_new_crtc_state(state, crtc);\n\n\tassert_pch_transcoder_disabled(dev_priv, PIPE_A);\n\n\tlpt_program_iclkip(crtc_state);\n\n\t \n\tilk_pch_transcoder_set_timings(crtc_state, PIPE_A);\n\n\tlpt_enable_pch_transcoder(crtc_state);\n}\n\nvoid lpt_pch_disable(struct intel_atomic_state *state,\n\t\t     struct intel_crtc *crtc)\n{\n\tstruct drm_i915_private *dev_priv = to_i915(crtc->base.dev);\n\n\tlpt_disable_pch_transcoder(dev_priv);\n\n\tlpt_disable_iclkip(dev_priv);\n}\n\nvoid lpt_pch_get_config(struct intel_crtc_state *crtc_state)\n{\n\tstruct intel_crtc *crtc = to_intel_crtc(crtc_state->uapi.crtc);\n\tstruct drm_i915_private *dev_priv = to_i915(crtc->base.dev);\n\tu32 tmp;\n\n\tif ((intel_de_read(dev_priv, LPT_TRANSCONF) & TRANS_ENABLE) == 0)\n\t\treturn;\n\n\tcrtc_state->has_pch_encoder = true;\n\n\ttmp = intel_de_read(dev_priv, FDI_RX_CTL(PIPE_A));\n\tcrtc_state->fdi_lanes = ((FDI_DP_PORT_WIDTH_MASK & tmp) >>\n\t\t\t\t FDI_DP_PORT_WIDTH_SHIFT) + 1;\n\n\tintel_cpu_transcoder_get_m1_n1(crtc, crtc_state->cpu_transcoder,\n\t\t\t\t       &crtc_state->fdi_m_n);\n\n\tcrtc_state->hw.adjusted_mode.crtc_clock = lpt_get_iclkip(dev_priv);\n}\n\nvoid intel_pch_sanitize(struct drm_i915_private *i915)\n{\n\tif (HAS_PCH_IBX(i915))\n\t\tibx_sanitize_pch_ports(i915);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}