{
  "module_name": "intel_hotplug.c",
  "hash_id": "5255ec06a831515c3c489d20ba6649c9b965e5ed9f3c6c0264de9e6d061a5bff",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/i915/display/intel_hotplug.c",
  "human_readable_source": " \n\n#include <linux/kernel.h>\n\n#include \"i915_drv.h\"\n#include \"i915_irq.h\"\n#include \"intel_display_types.h\"\n#include \"intel_hotplug.h\"\n#include \"intel_hotplug_irq.h\"\n\n \n\n \nenum hpd_pin intel_hpd_pin_default(struct drm_i915_private *dev_priv,\n\t\t\t\t   enum port port)\n{\n\treturn HPD_PORT_A + port - PORT_A;\n}\n\n \n#define HPD_STORM_DEFAULT_THRESHOLD\t50\n\n#define HPD_STORM_DETECT_PERIOD\t\t1000\n#define HPD_STORM_REENABLE_DELAY\t(2 * 60 * 1000)\n#define HPD_RETRY_DELAY\t\t\t1000\n\nstatic enum hpd_pin\nintel_connector_hpd_pin(struct intel_connector *connector)\n{\n\tstruct intel_encoder *encoder = intel_attached_encoder(connector);\n\n\t \n\treturn encoder ? encoder->hpd_pin : HPD_NONE;\n}\n\n \nstatic bool intel_hpd_irq_storm_detect(struct drm_i915_private *dev_priv,\n\t\t\t\t       enum hpd_pin pin, bool long_hpd)\n{\n\tstruct intel_hotplug *hpd = &dev_priv->display.hotplug;\n\tunsigned long start = hpd->stats[pin].last_jiffies;\n\tunsigned long end = start + msecs_to_jiffies(HPD_STORM_DETECT_PERIOD);\n\tconst int increment = long_hpd ? 10 : 1;\n\tconst int threshold = hpd->hpd_storm_threshold;\n\tbool storm = false;\n\n\tif (!threshold ||\n\t    (!long_hpd && !dev_priv->display.hotplug.hpd_short_storm_enabled))\n\t\treturn false;\n\n\tif (!time_in_range(jiffies, start, end)) {\n\t\thpd->stats[pin].last_jiffies = jiffies;\n\t\thpd->stats[pin].count = 0;\n\t}\n\n\thpd->stats[pin].count += increment;\n\tif (hpd->stats[pin].count > threshold) {\n\t\thpd->stats[pin].state = HPD_MARK_DISABLED;\n\t\tdrm_dbg_kms(&dev_priv->drm,\n\t\t\t    \"HPD interrupt storm detected on PIN %d\\n\", pin);\n\t\tstorm = true;\n\t} else {\n\t\tdrm_dbg_kms(&dev_priv->drm,\n\t\t\t    \"Received HPD interrupt on PIN %d - cnt: %d\\n\",\n\t\t\t      pin,\n\t\t\t      hpd->stats[pin].count);\n\t}\n\n\treturn storm;\n}\n\nstatic void\nintel_hpd_irq_storm_switch_to_polling(struct drm_i915_private *dev_priv)\n{\n\tstruct drm_connector_list_iter conn_iter;\n\tstruct intel_connector *connector;\n\tbool hpd_disabled = false;\n\n\tlockdep_assert_held(&dev_priv->irq_lock);\n\n\tdrm_connector_list_iter_begin(&dev_priv->drm, &conn_iter);\n\tfor_each_intel_connector_iter(connector, &conn_iter) {\n\t\tenum hpd_pin pin;\n\n\t\tif (connector->base.polled != DRM_CONNECTOR_POLL_HPD)\n\t\t\tcontinue;\n\n\t\tpin = intel_connector_hpd_pin(connector);\n\t\tif (pin == HPD_NONE ||\n\t\t    dev_priv->display.hotplug.stats[pin].state != HPD_MARK_DISABLED)\n\t\t\tcontinue;\n\n\t\tdrm_info(&dev_priv->drm,\n\t\t\t \"HPD interrupt storm detected on connector %s: \"\n\t\t\t \"switching from hotplug detection to polling\\n\",\n\t\t\t connector->base.name);\n\n\t\tdev_priv->display.hotplug.stats[pin].state = HPD_DISABLED;\n\t\tconnector->base.polled = DRM_CONNECTOR_POLL_CONNECT |\n\t\t\tDRM_CONNECTOR_POLL_DISCONNECT;\n\t\thpd_disabled = true;\n\t}\n\tdrm_connector_list_iter_end(&conn_iter);\n\n\t \n\tif (hpd_disabled) {\n\t\tdrm_kms_helper_poll_reschedule(&dev_priv->drm);\n\t\tmod_delayed_work(dev_priv->unordered_wq,\n\t\t\t\t &dev_priv->display.hotplug.reenable_work,\n\t\t\t\t msecs_to_jiffies(HPD_STORM_REENABLE_DELAY));\n\t}\n}\n\nstatic void intel_hpd_irq_storm_reenable_work(struct work_struct *work)\n{\n\tstruct drm_i915_private *dev_priv =\n\t\tcontainer_of(work, typeof(*dev_priv),\n\t\t\t     display.hotplug.reenable_work.work);\n\tstruct drm_connector_list_iter conn_iter;\n\tstruct intel_connector *connector;\n\tintel_wakeref_t wakeref;\n\tenum hpd_pin pin;\n\n\twakeref = intel_runtime_pm_get(&dev_priv->runtime_pm);\n\n\tspin_lock_irq(&dev_priv->irq_lock);\n\n\tdrm_connector_list_iter_begin(&dev_priv->drm, &conn_iter);\n\tfor_each_intel_connector_iter(connector, &conn_iter) {\n\t\tpin = intel_connector_hpd_pin(connector);\n\t\tif (pin == HPD_NONE ||\n\t\t    dev_priv->display.hotplug.stats[pin].state != HPD_DISABLED)\n\t\t\tcontinue;\n\n\t\tif (connector->base.polled != connector->polled)\n\t\t\tdrm_dbg(&dev_priv->drm,\n\t\t\t\t\"Reenabling HPD on connector %s\\n\",\n\t\t\t\tconnector->base.name);\n\t\tconnector->base.polled = connector->polled;\n\t}\n\tdrm_connector_list_iter_end(&conn_iter);\n\n\tfor_each_hpd_pin(pin) {\n\t\tif (dev_priv->display.hotplug.stats[pin].state == HPD_DISABLED)\n\t\t\tdev_priv->display.hotplug.stats[pin].state = HPD_ENABLED;\n\t}\n\n\tintel_hpd_irq_setup(dev_priv);\n\n\tspin_unlock_irq(&dev_priv->irq_lock);\n\n\tintel_runtime_pm_put(&dev_priv->runtime_pm, wakeref);\n}\n\nenum intel_hotplug_state\nintel_encoder_hotplug(struct intel_encoder *encoder,\n\t\t      struct intel_connector *connector)\n{\n\tstruct drm_device *dev = connector->base.dev;\n\tenum drm_connector_status old_status;\n\tu64 old_epoch_counter;\n\tbool ret = false;\n\n\tdrm_WARN_ON(dev, !mutex_is_locked(&dev->mode_config.mutex));\n\told_status = connector->base.status;\n\told_epoch_counter = connector->base.epoch_counter;\n\n\tconnector->base.status =\n\t\tdrm_helper_probe_detect(&connector->base, NULL, false);\n\n\tif (old_epoch_counter != connector->base.epoch_counter)\n\t\tret = true;\n\n\tif (ret) {\n\t\tdrm_dbg_kms(dev, \"[CONNECTOR:%d:%s] status updated from %s to %s (epoch counter %llu->%llu)\\n\",\n\t\t\t    connector->base.base.id,\n\t\t\t    connector->base.name,\n\t\t\t    drm_get_connector_status_name(old_status),\n\t\t\t    drm_get_connector_status_name(connector->base.status),\n\t\t\t    old_epoch_counter,\n\t\t\t    connector->base.epoch_counter);\n\t\treturn INTEL_HOTPLUG_CHANGED;\n\t}\n\treturn INTEL_HOTPLUG_UNCHANGED;\n}\n\nstatic bool intel_encoder_has_hpd_pulse(struct intel_encoder *encoder)\n{\n\treturn intel_encoder_is_dig_port(encoder) &&\n\t\tenc_to_dig_port(encoder)->hpd_pulse != NULL;\n}\n\nstatic void i915_digport_work_func(struct work_struct *work)\n{\n\tstruct drm_i915_private *dev_priv =\n\t\tcontainer_of(work, struct drm_i915_private, display.hotplug.dig_port_work);\n\tu32 long_port_mask, short_port_mask;\n\tstruct intel_encoder *encoder;\n\tu32 old_bits = 0;\n\n\tspin_lock_irq(&dev_priv->irq_lock);\n\tlong_port_mask = dev_priv->display.hotplug.long_port_mask;\n\tdev_priv->display.hotplug.long_port_mask = 0;\n\tshort_port_mask = dev_priv->display.hotplug.short_port_mask;\n\tdev_priv->display.hotplug.short_port_mask = 0;\n\tspin_unlock_irq(&dev_priv->irq_lock);\n\n\tfor_each_intel_encoder(&dev_priv->drm, encoder) {\n\t\tstruct intel_digital_port *dig_port;\n\t\tenum port port = encoder->port;\n\t\tbool long_hpd, short_hpd;\n\t\tenum irqreturn ret;\n\n\t\tif (!intel_encoder_has_hpd_pulse(encoder))\n\t\t\tcontinue;\n\n\t\tlong_hpd = long_port_mask & BIT(port);\n\t\tshort_hpd = short_port_mask & BIT(port);\n\n\t\tif (!long_hpd && !short_hpd)\n\t\t\tcontinue;\n\n\t\tdig_port = enc_to_dig_port(encoder);\n\n\t\tret = dig_port->hpd_pulse(dig_port, long_hpd);\n\t\tif (ret == IRQ_NONE) {\n\t\t\t \n\t\t\told_bits |= BIT(encoder->hpd_pin);\n\t\t}\n\t}\n\n\tif (old_bits) {\n\t\tspin_lock_irq(&dev_priv->irq_lock);\n\t\tdev_priv->display.hotplug.event_bits |= old_bits;\n\t\tspin_unlock_irq(&dev_priv->irq_lock);\n\t\tqueue_delayed_work(dev_priv->unordered_wq,\n\t\t\t\t   &dev_priv->display.hotplug.hotplug_work, 0);\n\t}\n}\n\n \nvoid intel_hpd_trigger_irq(struct intel_digital_port *dig_port)\n{\n\tstruct drm_i915_private *i915 = to_i915(dig_port->base.base.dev);\n\n\tspin_lock_irq(&i915->irq_lock);\n\ti915->display.hotplug.short_port_mask |= BIT(dig_port->base.port);\n\tspin_unlock_irq(&i915->irq_lock);\n\n\tqueue_work(i915->display.hotplug.dp_wq, &i915->display.hotplug.dig_port_work);\n}\n\n \nstatic void i915_hotplug_work_func(struct work_struct *work)\n{\n\tstruct drm_i915_private *dev_priv =\n\t\tcontainer_of(work, struct drm_i915_private,\n\t\t\t     display.hotplug.hotplug_work.work);\n\tstruct drm_connector_list_iter conn_iter;\n\tstruct intel_connector *connector;\n\tu32 changed = 0, retry = 0;\n\tu32 hpd_event_bits;\n\tu32 hpd_retry_bits;\n\tstruct drm_connector *first_changed_connector = NULL;\n\tint changed_connectors = 0;\n\n\tmutex_lock(&dev_priv->drm.mode_config.mutex);\n\tdrm_dbg_kms(&dev_priv->drm, \"running encoder hotplug functions\\n\");\n\n\tspin_lock_irq(&dev_priv->irq_lock);\n\n\thpd_event_bits = dev_priv->display.hotplug.event_bits;\n\tdev_priv->display.hotplug.event_bits = 0;\n\thpd_retry_bits = dev_priv->display.hotplug.retry_bits;\n\tdev_priv->display.hotplug.retry_bits = 0;\n\n\t \n\tintel_hpd_irq_storm_switch_to_polling(dev_priv);\n\n\tspin_unlock_irq(&dev_priv->irq_lock);\n\n\t \n\tif (dev_priv->display.hotplug.ignore_long_hpd) {\n\t\tdrm_dbg_kms(&dev_priv->drm, \"Ignore HPD flag on - skip encoder hotplug handlers\\n\");\n\t\tmutex_unlock(&dev_priv->drm.mode_config.mutex);\n\t\treturn;\n\t}\n\n\tdrm_connector_list_iter_begin(&dev_priv->drm, &conn_iter);\n\tfor_each_intel_connector_iter(connector, &conn_iter) {\n\t\tenum hpd_pin pin;\n\t\tu32 hpd_bit;\n\n\t\tpin = intel_connector_hpd_pin(connector);\n\t\tif (pin == HPD_NONE)\n\t\t\tcontinue;\n\n\t\thpd_bit = BIT(pin);\n\t\tif ((hpd_event_bits | hpd_retry_bits) & hpd_bit) {\n\t\t\tstruct intel_encoder *encoder =\n\t\t\t\tintel_attached_encoder(connector);\n\n\t\t\tif (hpd_event_bits & hpd_bit)\n\t\t\t\tconnector->hotplug_retries = 0;\n\t\t\telse\n\t\t\t\tconnector->hotplug_retries++;\n\n\t\t\tdrm_dbg_kms(&dev_priv->drm,\n\t\t\t\t    \"Connector %s (pin %i) received hotplug event. (retry %d)\\n\",\n\t\t\t\t    connector->base.name, pin,\n\t\t\t\t    connector->hotplug_retries);\n\n\t\t\tswitch (encoder->hotplug(encoder, connector)) {\n\t\t\tcase INTEL_HOTPLUG_UNCHANGED:\n\t\t\t\tbreak;\n\t\t\tcase INTEL_HOTPLUG_CHANGED:\n\t\t\t\tchanged |= hpd_bit;\n\t\t\t\tchanged_connectors++;\n\t\t\t\tif (!first_changed_connector) {\n\t\t\t\t\tdrm_connector_get(&connector->base);\n\t\t\t\t\tfirst_changed_connector = &connector->base;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase INTEL_HOTPLUG_RETRY:\n\t\t\t\tretry |= hpd_bit;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tdrm_connector_list_iter_end(&conn_iter);\n\tmutex_unlock(&dev_priv->drm.mode_config.mutex);\n\n\tif (changed_connectors == 1)\n\t\tdrm_kms_helper_connector_hotplug_event(first_changed_connector);\n\telse if (changed_connectors > 0)\n\t\tdrm_kms_helper_hotplug_event(&dev_priv->drm);\n\n\tif (first_changed_connector)\n\t\tdrm_connector_put(first_changed_connector);\n\n\t \n\tretry &= ~changed;\n\tif (retry) {\n\t\tspin_lock_irq(&dev_priv->irq_lock);\n\t\tdev_priv->display.hotplug.retry_bits |= retry;\n\t\tspin_unlock_irq(&dev_priv->irq_lock);\n\n\t\tmod_delayed_work(dev_priv->unordered_wq,\n\t\t\t\t &dev_priv->display.hotplug.hotplug_work,\n\t\t\t\t msecs_to_jiffies(HPD_RETRY_DELAY));\n\t}\n}\n\n\n \nvoid intel_hpd_irq_handler(struct drm_i915_private *dev_priv,\n\t\t\t   u32 pin_mask, u32 long_mask)\n{\n\tstruct intel_encoder *encoder;\n\tbool storm_detected = false;\n\tbool queue_dig = false, queue_hp = false;\n\tu32 long_hpd_pulse_mask = 0;\n\tu32 short_hpd_pulse_mask = 0;\n\tenum hpd_pin pin;\n\n\tif (!pin_mask)\n\t\treturn;\n\n\tspin_lock(&dev_priv->irq_lock);\n\n\t \n\tfor_each_intel_encoder(&dev_priv->drm, encoder) {\n\t\tenum port port = encoder->port;\n\t\tbool long_hpd;\n\n\t\tpin = encoder->hpd_pin;\n\t\tif (!(BIT(pin) & pin_mask))\n\t\t\tcontinue;\n\n\t\tif (!intel_encoder_has_hpd_pulse(encoder))\n\t\t\tcontinue;\n\n\t\tlong_hpd = long_mask & BIT(pin);\n\n\t\tdrm_dbg(&dev_priv->drm,\n\t\t\t\"digital hpd on [ENCODER:%d:%s] - %s\\n\",\n\t\t\tencoder->base.base.id, encoder->base.name,\n\t\t\tlong_hpd ? \"long\" : \"short\");\n\t\tqueue_dig = true;\n\n\t\tif (long_hpd) {\n\t\t\tlong_hpd_pulse_mask |= BIT(pin);\n\t\t\tdev_priv->display.hotplug.long_port_mask |= BIT(port);\n\t\t} else {\n\t\t\tshort_hpd_pulse_mask |= BIT(pin);\n\t\t\tdev_priv->display.hotplug.short_port_mask |= BIT(port);\n\t\t}\n\t}\n\n\t \n\tfor_each_hpd_pin(pin) {\n\t\tbool long_hpd;\n\n\t\tif (!(BIT(pin) & pin_mask))\n\t\t\tcontinue;\n\n\t\tif (dev_priv->display.hotplug.stats[pin].state == HPD_DISABLED) {\n\t\t\t \n\t\t\tdrm_WARN_ONCE(&dev_priv->drm, !HAS_GMCH(dev_priv),\n\t\t\t\t      \"Received HPD interrupt on pin %d although disabled\\n\",\n\t\t\t\t      pin);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (dev_priv->display.hotplug.stats[pin].state != HPD_ENABLED)\n\t\t\tcontinue;\n\n\t\t \n\t\tif (((short_hpd_pulse_mask | long_hpd_pulse_mask) & BIT(pin))) {\n\t\t\tlong_hpd = long_hpd_pulse_mask & BIT(pin);\n\t\t} else {\n\t\t\tdev_priv->display.hotplug.event_bits |= BIT(pin);\n\t\t\tlong_hpd = true;\n\t\t\tqueue_hp = true;\n\t\t}\n\n\t\tif (intel_hpd_irq_storm_detect(dev_priv, pin, long_hpd)) {\n\t\t\tdev_priv->display.hotplug.event_bits &= ~BIT(pin);\n\t\t\tstorm_detected = true;\n\t\t\tqueue_hp = true;\n\t\t}\n\t}\n\n\t \n\tif (storm_detected)\n\t\tintel_hpd_irq_setup(dev_priv);\n\tspin_unlock(&dev_priv->irq_lock);\n\n\t \n\tif (queue_dig)\n\t\tqueue_work(dev_priv->display.hotplug.dp_wq, &dev_priv->display.hotplug.dig_port_work);\n\tif (queue_hp)\n\t\tqueue_delayed_work(dev_priv->unordered_wq,\n\t\t\t\t   &dev_priv->display.hotplug.hotplug_work, 0);\n}\n\n \nvoid intel_hpd_init(struct drm_i915_private *dev_priv)\n{\n\tint i;\n\n\tif (!HAS_DISPLAY(dev_priv))\n\t\treturn;\n\n\tfor_each_hpd_pin(i) {\n\t\tdev_priv->display.hotplug.stats[i].count = 0;\n\t\tdev_priv->display.hotplug.stats[i].state = HPD_ENABLED;\n\t}\n\n\t \n\tspin_lock_irq(&dev_priv->irq_lock);\n\tintel_hpd_irq_setup(dev_priv);\n\tspin_unlock_irq(&dev_priv->irq_lock);\n}\n\nstatic void i915_hpd_poll_init_work(struct work_struct *work)\n{\n\tstruct drm_i915_private *dev_priv =\n\t\tcontainer_of(work, struct drm_i915_private,\n\t\t\t     display.hotplug.poll_init_work);\n\tstruct drm_connector_list_iter conn_iter;\n\tstruct intel_connector *connector;\n\tbool enabled;\n\n\tmutex_lock(&dev_priv->drm.mode_config.mutex);\n\n\tenabled = READ_ONCE(dev_priv->display.hotplug.poll_enabled);\n\n\tdrm_connector_list_iter_begin(&dev_priv->drm, &conn_iter);\n\tfor_each_intel_connector_iter(connector, &conn_iter) {\n\t\tenum hpd_pin pin;\n\n\t\tpin = intel_connector_hpd_pin(connector);\n\t\tif (pin == HPD_NONE)\n\t\t\tcontinue;\n\n\t\tconnector->base.polled = connector->polled;\n\n\t\tif (enabled && connector->base.polled == DRM_CONNECTOR_POLL_HPD)\n\t\t\tconnector->base.polled = DRM_CONNECTOR_POLL_CONNECT |\n\t\t\t\tDRM_CONNECTOR_POLL_DISCONNECT;\n\t}\n\tdrm_connector_list_iter_end(&conn_iter);\n\n\tif (enabled)\n\t\tdrm_kms_helper_poll_reschedule(&dev_priv->drm);\n\n\tmutex_unlock(&dev_priv->drm.mode_config.mutex);\n\n\t \n\tif (!enabled)\n\t\tdrm_helper_hpd_irq_event(&dev_priv->drm);\n}\n\n \nvoid intel_hpd_poll_enable(struct drm_i915_private *dev_priv)\n{\n\tif (!HAS_DISPLAY(dev_priv) ||\n\t    !INTEL_DISPLAY_ENABLED(dev_priv))\n\t\treturn;\n\n\tWRITE_ONCE(dev_priv->display.hotplug.poll_enabled, true);\n\n\t \n\tqueue_work(dev_priv->unordered_wq,\n\t\t   &dev_priv->display.hotplug.poll_init_work);\n}\n\n \nvoid intel_hpd_poll_disable(struct drm_i915_private *dev_priv)\n{\n\tif (!HAS_DISPLAY(dev_priv))\n\t\treturn;\n\n\tWRITE_ONCE(dev_priv->display.hotplug.poll_enabled, false);\n\tqueue_work(dev_priv->unordered_wq,\n\t\t   &dev_priv->display.hotplug.poll_init_work);\n}\n\nvoid intel_hpd_init_early(struct drm_i915_private *i915)\n{\n\tINIT_DELAYED_WORK(&i915->display.hotplug.hotplug_work,\n\t\t\t  i915_hotplug_work_func);\n\tINIT_WORK(&i915->display.hotplug.dig_port_work, i915_digport_work_func);\n\tINIT_WORK(&i915->display.hotplug.poll_init_work, i915_hpd_poll_init_work);\n\tINIT_DELAYED_WORK(&i915->display.hotplug.reenable_work,\n\t\t\t  intel_hpd_irq_storm_reenable_work);\n\n\ti915->display.hotplug.hpd_storm_threshold = HPD_STORM_DEFAULT_THRESHOLD;\n\t \n\ti915->display.hotplug.hpd_short_storm_enabled = !HAS_DP_MST(i915);\n}\n\nvoid intel_hpd_cancel_work(struct drm_i915_private *dev_priv)\n{\n\tif (!HAS_DISPLAY(dev_priv))\n\t\treturn;\n\n\tspin_lock_irq(&dev_priv->irq_lock);\n\n\tdev_priv->display.hotplug.long_port_mask = 0;\n\tdev_priv->display.hotplug.short_port_mask = 0;\n\tdev_priv->display.hotplug.event_bits = 0;\n\tdev_priv->display.hotplug.retry_bits = 0;\n\n\tspin_unlock_irq(&dev_priv->irq_lock);\n\n\tcancel_work_sync(&dev_priv->display.hotplug.dig_port_work);\n\tcancel_delayed_work_sync(&dev_priv->display.hotplug.hotplug_work);\n\tcancel_work_sync(&dev_priv->display.hotplug.poll_init_work);\n\tcancel_delayed_work_sync(&dev_priv->display.hotplug.reenable_work);\n}\n\nbool intel_hpd_disable(struct drm_i915_private *dev_priv, enum hpd_pin pin)\n{\n\tbool ret = false;\n\n\tif (pin == HPD_NONE)\n\t\treturn false;\n\n\tspin_lock_irq(&dev_priv->irq_lock);\n\tif (dev_priv->display.hotplug.stats[pin].state == HPD_ENABLED) {\n\t\tdev_priv->display.hotplug.stats[pin].state = HPD_DISABLED;\n\t\tret = true;\n\t}\n\tspin_unlock_irq(&dev_priv->irq_lock);\n\n\treturn ret;\n}\n\nvoid intel_hpd_enable(struct drm_i915_private *dev_priv, enum hpd_pin pin)\n{\n\tif (pin == HPD_NONE)\n\t\treturn;\n\n\tspin_lock_irq(&dev_priv->irq_lock);\n\tdev_priv->display.hotplug.stats[pin].state = HPD_ENABLED;\n\tspin_unlock_irq(&dev_priv->irq_lock);\n}\n\nstatic int i915_hpd_storm_ctl_show(struct seq_file *m, void *data)\n{\n\tstruct drm_i915_private *dev_priv = m->private;\n\tstruct intel_hotplug *hotplug = &dev_priv->display.hotplug;\n\n\t \n\tintel_synchronize_irq(dev_priv);\n\tflush_work(&dev_priv->display.hotplug.dig_port_work);\n\tflush_delayed_work(&dev_priv->display.hotplug.hotplug_work);\n\n\tseq_printf(m, \"Threshold: %d\\n\", hotplug->hpd_storm_threshold);\n\tseq_printf(m, \"Detected: %s\\n\",\n\t\t   str_yes_no(delayed_work_pending(&hotplug->reenable_work)));\n\n\treturn 0;\n}\n\nstatic ssize_t i915_hpd_storm_ctl_write(struct file *file,\n\t\t\t\t\tconst char __user *ubuf, size_t len,\n\t\t\t\t\tloff_t *offp)\n{\n\tstruct seq_file *m = file->private_data;\n\tstruct drm_i915_private *dev_priv = m->private;\n\tstruct intel_hotplug *hotplug = &dev_priv->display.hotplug;\n\tunsigned int new_threshold;\n\tint i;\n\tchar *newline;\n\tchar tmp[16];\n\n\tif (len >= sizeof(tmp))\n\t\treturn -EINVAL;\n\n\tif (copy_from_user(tmp, ubuf, len))\n\t\treturn -EFAULT;\n\n\ttmp[len] = '\\0';\n\n\t \n\tnewline = strchr(tmp, '\\n');\n\tif (newline)\n\t\t*newline = '\\0';\n\n\tif (strcmp(tmp, \"reset\") == 0)\n\t\tnew_threshold = HPD_STORM_DEFAULT_THRESHOLD;\n\telse if (kstrtouint(tmp, 10, &new_threshold) != 0)\n\t\treturn -EINVAL;\n\n\tif (new_threshold > 0)\n\t\tdrm_dbg_kms(&dev_priv->drm,\n\t\t\t    \"Setting HPD storm detection threshold to %d\\n\",\n\t\t\t    new_threshold);\n\telse\n\t\tdrm_dbg_kms(&dev_priv->drm, \"Disabling HPD storm detection\\n\");\n\n\tspin_lock_irq(&dev_priv->irq_lock);\n\thotplug->hpd_storm_threshold = new_threshold;\n\t \n\tfor_each_hpd_pin(i)\n\t\thotplug->stats[i].count = 0;\n\tspin_unlock_irq(&dev_priv->irq_lock);\n\n\t \n\tflush_delayed_work(&dev_priv->display.hotplug.reenable_work);\n\n\treturn len;\n}\n\nstatic int i915_hpd_storm_ctl_open(struct inode *inode, struct file *file)\n{\n\treturn single_open(file, i915_hpd_storm_ctl_show, inode->i_private);\n}\n\nstatic const struct file_operations i915_hpd_storm_ctl_fops = {\n\t.owner = THIS_MODULE,\n\t.open = i915_hpd_storm_ctl_open,\n\t.read = seq_read,\n\t.llseek = seq_lseek,\n\t.release = single_release,\n\t.write = i915_hpd_storm_ctl_write\n};\n\nstatic int i915_hpd_short_storm_ctl_show(struct seq_file *m, void *data)\n{\n\tstruct drm_i915_private *dev_priv = m->private;\n\n\tseq_printf(m, \"Enabled: %s\\n\",\n\t\t   str_yes_no(dev_priv->display.hotplug.hpd_short_storm_enabled));\n\n\treturn 0;\n}\n\nstatic int\ni915_hpd_short_storm_ctl_open(struct inode *inode, struct file *file)\n{\n\treturn single_open(file, i915_hpd_short_storm_ctl_show,\n\t\t\t   inode->i_private);\n}\n\nstatic ssize_t i915_hpd_short_storm_ctl_write(struct file *file,\n\t\t\t\t\t      const char __user *ubuf,\n\t\t\t\t\t      size_t len, loff_t *offp)\n{\n\tstruct seq_file *m = file->private_data;\n\tstruct drm_i915_private *dev_priv = m->private;\n\tstruct intel_hotplug *hotplug = &dev_priv->display.hotplug;\n\tchar *newline;\n\tchar tmp[16];\n\tint i;\n\tbool new_state;\n\n\tif (len >= sizeof(tmp))\n\t\treturn -EINVAL;\n\n\tif (copy_from_user(tmp, ubuf, len))\n\t\treturn -EFAULT;\n\n\ttmp[len] = '\\0';\n\n\t \n\tnewline = strchr(tmp, '\\n');\n\tif (newline)\n\t\t*newline = '\\0';\n\n\t \n\tif (strcmp(tmp, \"reset\") == 0)\n\t\tnew_state = !HAS_DP_MST(dev_priv);\n\telse if (kstrtobool(tmp, &new_state) != 0)\n\t\treturn -EINVAL;\n\n\tdrm_dbg_kms(&dev_priv->drm, \"%sabling HPD short storm detection\\n\",\n\t\t    new_state ? \"En\" : \"Dis\");\n\n\tspin_lock_irq(&dev_priv->irq_lock);\n\thotplug->hpd_short_storm_enabled = new_state;\n\t \n\tfor_each_hpd_pin(i)\n\t\thotplug->stats[i].count = 0;\n\tspin_unlock_irq(&dev_priv->irq_lock);\n\n\t \n\tflush_delayed_work(&dev_priv->display.hotplug.reenable_work);\n\n\treturn len;\n}\n\nstatic const struct file_operations i915_hpd_short_storm_ctl_fops = {\n\t.owner = THIS_MODULE,\n\t.open = i915_hpd_short_storm_ctl_open,\n\t.read = seq_read,\n\t.llseek = seq_lseek,\n\t.release = single_release,\n\t.write = i915_hpd_short_storm_ctl_write,\n};\n\nvoid intel_hpd_debugfs_register(struct drm_i915_private *i915)\n{\n\tstruct drm_minor *minor = i915->drm.primary;\n\n\tdebugfs_create_file(\"i915_hpd_storm_ctl\", 0644, minor->debugfs_root,\n\t\t\t    i915, &i915_hpd_storm_ctl_fops);\n\tdebugfs_create_file(\"i915_hpd_short_storm_ctl\", 0644, minor->debugfs_root,\n\t\t\t    i915, &i915_hpd_short_storm_ctl_fops);\n\tdebugfs_create_bool(\"i915_ignore_long_hpd\", 0644, minor->debugfs_root,\n\t\t\t    &i915->display.hotplug.ignore_long_hpd);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}