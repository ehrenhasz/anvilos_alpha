{
  "module_name": "intel_overlay.c",
  "hash_id": "5ab65b72a85625e0925edca357b1ada17ea1dd317f876959f7735412a32bf544",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/i915/display/intel_overlay.c",
  "human_readable_source": " \n\n#include <drm/drm_fourcc.h>\n\n#include \"gem/i915_gem_internal.h\"\n#include \"gem/i915_gem_pm.h\"\n#include \"gt/intel_gpu_commands.h\"\n#include \"gt/intel_ring.h\"\n\n#include \"i915_drv.h\"\n#include \"i915_reg.h\"\n#include \"intel_de.h\"\n#include \"intel_display_types.h\"\n#include \"intel_frontbuffer.h\"\n#include \"intel_overlay.h\"\n#include \"intel_pci_config.h\"\n\n \n#define IMAGE_MAX_WIDTH\t\t2048\n#define IMAGE_MAX_HEIGHT\t2046  \n \n#define IMAGE_MAX_WIDTH_LEGACY\t1024\n#define IMAGE_MAX_HEIGHT_LEGACY\t1088\n\n \n \n#define OCMD_TILED_SURFACE\t(0x1<<19)\n#define OCMD_MIRROR_MASK\t(0x3<<17)\n#define OCMD_MIRROR_MODE\t(0x3<<17)\n#define OCMD_MIRROR_HORIZONTAL\t(0x1<<17)\n#define OCMD_MIRROR_VERTICAL\t(0x2<<17)\n#define OCMD_MIRROR_BOTH\t(0x3<<17)\n#define OCMD_BYTEORDER_MASK\t(0x3<<14)  \n#define OCMD_UV_SWAP\t\t(0x1<<14)  \n#define OCMD_Y_SWAP\t\t(0x2<<14)  \n#define OCMD_Y_AND_UV_SWAP\t(0x3<<14)  \n#define OCMD_SOURCE_FORMAT_MASK (0xf<<10)\n#define OCMD_RGB_888\t\t(0x1<<10)  \n#define OCMD_RGB_555\t\t(0x2<<10)  \n#define OCMD_RGB_565\t\t(0x3<<10)  \n#define OCMD_YUV_422_PACKED\t(0x8<<10)\n#define OCMD_YUV_411_PACKED\t(0x9<<10)  \n#define OCMD_YUV_420_PLANAR\t(0xc<<10)\n#define OCMD_YUV_422_PLANAR\t(0xd<<10)\n#define OCMD_YUV_410_PLANAR\t(0xe<<10)  \n#define OCMD_TVSYNCFLIP_PARITY\t(0x1<<9)\n#define OCMD_TVSYNCFLIP_ENABLE\t(0x1<<7)\n#define OCMD_BUF_TYPE_MASK\t(0x1<<5)\n#define OCMD_BUF_TYPE_FRAME\t(0x0<<5)\n#define OCMD_BUF_TYPE_FIELD\t(0x1<<5)\n#define OCMD_TEST_MODE\t\t(0x1<<4)\n#define OCMD_BUFFER_SELECT\t(0x3<<2)\n#define OCMD_BUFFER0\t\t(0x0<<2)\n#define OCMD_BUFFER1\t\t(0x1<<2)\n#define OCMD_FIELD_SELECT\t(0x1<<2)\n#define OCMD_FIELD0\t\t(0x0<<1)\n#define OCMD_FIELD1\t\t(0x1<<1)\n#define OCMD_ENABLE\t\t(0x1<<0)\n\n \n#define OCONF_PIPE_MASK\t\t(0x1<<18)\n#define OCONF_PIPE_A\t\t(0x0<<18)\n#define OCONF_PIPE_B\t\t(0x1<<18)\n#define OCONF_GAMMA2_ENABLE\t(0x1<<16)\n#define OCONF_CSC_MODE_BT601\t(0x0<<5)\n#define OCONF_CSC_MODE_BT709\t(0x1<<5)\n#define OCONF_CSC_BYPASS\t(0x1<<4)\n#define OCONF_CC_OUT_8BIT\t(0x1<<3)\n#define OCONF_TEST_MODE\t\t(0x1<<2)\n#define OCONF_THREE_LINE_BUFFER\t(0x1<<0)\n#define OCONF_TWO_LINE_BUFFER\t(0x0<<0)\n\n \n#define DST_KEY_ENABLE\t\t(0x1<<31)\n#define CLK_RGB24_MASK\t\t0x0\n#define CLK_RGB16_MASK\t\t0x070307\n#define CLK_RGB15_MASK\t\t0x070707\n\n#define RGB30_TO_COLORKEY(c) \\\n\t((((c) & 0x3fc00000) >> 6) | (((c) & 0x000ff000) >> 4) | (((c) & 0x000003fc) >> 2))\n#define RGB16_TO_COLORKEY(c) \\\n\t((((c) & 0xf800) << 8) | (((c) & 0x07e0) << 5) | (((c) & 0x001f) << 3))\n#define RGB15_TO_COLORKEY(c) \\\n\t((((c) & 0x7c00) << 9) | (((c) & 0x03e0) << 6) | (((c) & 0x001f) << 3))\n#define RGB8I_TO_COLORKEY(c) \\\n\t((((c) & 0xff) << 16) | (((c) & 0xff) << 8) | (((c) & 0xff) << 0))\n\n \n#define OFC_UPDATE\t\t0x1\n\n \n#define N_HORIZ_Y_TAPS          5\n#define N_VERT_Y_TAPS           3\n#define N_HORIZ_UV_TAPS         3\n#define N_VERT_UV_TAPS          3\n#define N_PHASES                17\n#define MAX_TAPS                5\n\n \nstruct overlay_registers {\n\tu32 OBUF_0Y;\n\tu32 OBUF_1Y;\n\tu32 OBUF_0U;\n\tu32 OBUF_0V;\n\tu32 OBUF_1U;\n\tu32 OBUF_1V;\n\tu32 OSTRIDE;\n\tu32 YRGB_VPH;\n\tu32 UV_VPH;\n\tu32 HORZ_PH;\n\tu32 INIT_PHS;\n\tu32 DWINPOS;\n\tu32 DWINSZ;\n\tu32 SWIDTH;\n\tu32 SWIDTHSW;\n\tu32 SHEIGHT;\n\tu32 YRGBSCALE;\n\tu32 UVSCALE;\n\tu32 OCLRC0;\n\tu32 OCLRC1;\n\tu32 DCLRKV;\n\tu32 DCLRKM;\n\tu32 SCLRKVH;\n\tu32 SCLRKVL;\n\tu32 SCLRKEN;\n\tu32 OCONFIG;\n\tu32 OCMD;\n\tu32 RESERVED1;  \n\tu32 OSTART_0Y;\n\tu32 OSTART_1Y;\n\tu32 OSTART_0U;\n\tu32 OSTART_0V;\n\tu32 OSTART_1U;\n\tu32 OSTART_1V;\n\tu32 OTILEOFF_0Y;\n\tu32 OTILEOFF_1Y;\n\tu32 OTILEOFF_0U;\n\tu32 OTILEOFF_0V;\n\tu32 OTILEOFF_1U;\n\tu32 OTILEOFF_1V;\n\tu32 FASTHSCALE;  \n\tu32 UVSCALEV;  \n\tu32 RESERVEDC[(0x200 - 0xA8) / 4];  \n\tu16 Y_VCOEFS[N_VERT_Y_TAPS * N_PHASES];  \n\tu16 RESERVEDD[0x100 / 2 - N_VERT_Y_TAPS * N_PHASES];\n\tu16 Y_HCOEFS[N_HORIZ_Y_TAPS * N_PHASES];  \n\tu16 RESERVEDE[0x200 / 2 - N_HORIZ_Y_TAPS * N_PHASES];\n\tu16 UV_VCOEFS[N_VERT_UV_TAPS * N_PHASES];  \n\tu16 RESERVEDF[0x100 / 2 - N_VERT_UV_TAPS * N_PHASES];\n\tu16 UV_HCOEFS[N_HORIZ_UV_TAPS * N_PHASES];  \n\tu16 RESERVEDG[0x100 / 2 - N_HORIZ_UV_TAPS * N_PHASES];\n};\n\nstruct intel_overlay {\n\tstruct drm_i915_private *i915;\n\tstruct intel_context *context;\n\tstruct intel_crtc *crtc;\n\tstruct i915_vma *vma;\n\tstruct i915_vma *old_vma;\n\tstruct intel_frontbuffer *frontbuffer;\n\tbool active;\n\tbool pfit_active;\n\tu32 pfit_vscale_ratio;  \n\tu32 color_key:24;\n\tu32 color_key_enabled:1;\n\tu32 brightness, contrast, saturation;\n\tu32 old_xscale, old_yscale;\n\t \n\tstruct drm_i915_gem_object *reg_bo;\n\tstruct overlay_registers __iomem *regs;\n\tu32 flip_addr;\n\t \n\tstruct i915_active last_flip;\n\tvoid (*flip_complete)(struct intel_overlay *ovl);\n};\n\nstatic void i830_overlay_clock_gating(struct drm_i915_private *dev_priv,\n\t\t\t\t      bool enable)\n{\n\tstruct pci_dev *pdev = to_pci_dev(dev_priv->drm.dev);\n\tu8 val;\n\n\t \n\tif (enable)\n\t\tintel_de_write(dev_priv, DSPCLK_GATE_D(dev_priv), 0);\n\telse\n\t\tintel_de_write(dev_priv, DSPCLK_GATE_D(dev_priv),\n\t\t\t       OVRUNIT_CLOCK_GATE_DISABLE);\n\n\t \n\tpci_bus_read_config_byte(pdev->bus,\n\t\t\t\t PCI_DEVFN(0, 0), I830_CLOCK_GATE, &val);\n\tif (enable)\n\t\tval &= ~I830_L2_CACHE_CLOCK_GATE_DISABLE;\n\telse\n\t\tval |= I830_L2_CACHE_CLOCK_GATE_DISABLE;\n\tpci_bus_write_config_byte(pdev->bus,\n\t\t\t\t  PCI_DEVFN(0, 0), I830_CLOCK_GATE, val);\n}\n\nstatic struct i915_request *\nalloc_request(struct intel_overlay *overlay, void (*fn)(struct intel_overlay *))\n{\n\tstruct i915_request *rq;\n\tint err;\n\n\toverlay->flip_complete = fn;\n\n\trq = i915_request_create(overlay->context);\n\tif (IS_ERR(rq))\n\t\treturn rq;\n\n\terr = i915_active_add_request(&overlay->last_flip, rq);\n\tif (err) {\n\t\ti915_request_add(rq);\n\t\treturn ERR_PTR(err);\n\t}\n\n\treturn rq;\n}\n\n \nstatic int intel_overlay_on(struct intel_overlay *overlay)\n{\n\tstruct drm_i915_private *dev_priv = overlay->i915;\n\tstruct i915_request *rq;\n\tu32 *cs;\n\n\tdrm_WARN_ON(&dev_priv->drm, overlay->active);\n\n\trq = alloc_request(overlay, NULL);\n\tif (IS_ERR(rq))\n\t\treturn PTR_ERR(rq);\n\n\tcs = intel_ring_begin(rq, 4);\n\tif (IS_ERR(cs)) {\n\t\ti915_request_add(rq);\n\t\treturn PTR_ERR(cs);\n\t}\n\n\toverlay->active = true;\n\n\tif (IS_I830(dev_priv))\n\t\ti830_overlay_clock_gating(dev_priv, false);\n\n\t*cs++ = MI_OVERLAY_FLIP | MI_OVERLAY_ON;\n\t*cs++ = overlay->flip_addr | OFC_UPDATE;\n\t*cs++ = MI_WAIT_FOR_EVENT | MI_WAIT_FOR_OVERLAY_FLIP;\n\t*cs++ = MI_NOOP;\n\tintel_ring_advance(rq, cs);\n\n\ti915_request_add(rq);\n\n\treturn i915_active_wait(&overlay->last_flip);\n}\n\nstatic void intel_overlay_flip_prepare(struct intel_overlay *overlay,\n\t\t\t\t       struct i915_vma *vma)\n{\n\tenum pipe pipe = overlay->crtc->pipe;\n\tstruct intel_frontbuffer *frontbuffer = NULL;\n\n\tdrm_WARN_ON(&overlay->i915->drm, overlay->old_vma);\n\n\tif (vma)\n\t\tfrontbuffer = intel_frontbuffer_get(vma->obj);\n\n\tintel_frontbuffer_track(overlay->frontbuffer, frontbuffer,\n\t\t\t\tINTEL_FRONTBUFFER_OVERLAY(pipe));\n\n\tif (overlay->frontbuffer)\n\t\tintel_frontbuffer_put(overlay->frontbuffer);\n\toverlay->frontbuffer = frontbuffer;\n\n\tintel_frontbuffer_flip_prepare(overlay->i915,\n\t\t\t\t       INTEL_FRONTBUFFER_OVERLAY(pipe));\n\n\toverlay->old_vma = overlay->vma;\n\tif (vma)\n\t\toverlay->vma = i915_vma_get(vma);\n\telse\n\t\toverlay->vma = NULL;\n}\n\n \nstatic int intel_overlay_continue(struct intel_overlay *overlay,\n\t\t\t\t  struct i915_vma *vma,\n\t\t\t\t  bool load_polyphase_filter)\n{\n\tstruct drm_i915_private *dev_priv = overlay->i915;\n\tstruct i915_request *rq;\n\tu32 flip_addr = overlay->flip_addr;\n\tu32 tmp, *cs;\n\n\tdrm_WARN_ON(&dev_priv->drm, !overlay->active);\n\n\tif (load_polyphase_filter)\n\t\tflip_addr |= OFC_UPDATE;\n\n\t \n\ttmp = intel_de_read(dev_priv, DOVSTA);\n\tif (tmp & (1 << 17))\n\t\tdrm_dbg(&dev_priv->drm, \"overlay underrun, DOVSTA: %x\\n\", tmp);\n\n\trq = alloc_request(overlay, NULL);\n\tif (IS_ERR(rq))\n\t\treturn PTR_ERR(rq);\n\n\tcs = intel_ring_begin(rq, 2);\n\tif (IS_ERR(cs)) {\n\t\ti915_request_add(rq);\n\t\treturn PTR_ERR(cs);\n\t}\n\n\t*cs++ = MI_OVERLAY_FLIP | MI_OVERLAY_CONTINUE;\n\t*cs++ = flip_addr;\n\tintel_ring_advance(rq, cs);\n\n\tintel_overlay_flip_prepare(overlay, vma);\n\ti915_request_add(rq);\n\n\treturn 0;\n}\n\nstatic void intel_overlay_release_old_vma(struct intel_overlay *overlay)\n{\n\tstruct i915_vma *vma;\n\n\tvma = fetch_and_zero(&overlay->old_vma);\n\tif (drm_WARN_ON(&overlay->i915->drm, !vma))\n\t\treturn;\n\n\tintel_frontbuffer_flip_complete(overlay->i915,\n\t\t\t\t\tINTEL_FRONTBUFFER_OVERLAY(overlay->crtc->pipe));\n\n\ti915_vma_unpin(vma);\n\ti915_vma_put(vma);\n}\n\nstatic void\nintel_overlay_release_old_vid_tail(struct intel_overlay *overlay)\n{\n\tintel_overlay_release_old_vma(overlay);\n}\n\nstatic void intel_overlay_off_tail(struct intel_overlay *overlay)\n{\n\tstruct drm_i915_private *dev_priv = overlay->i915;\n\n\tintel_overlay_release_old_vma(overlay);\n\n\toverlay->crtc->overlay = NULL;\n\toverlay->crtc = NULL;\n\toverlay->active = false;\n\n\tif (IS_I830(dev_priv))\n\t\ti830_overlay_clock_gating(dev_priv, true);\n}\n\nstatic void intel_overlay_last_flip_retire(struct i915_active *active)\n{\n\tstruct intel_overlay *overlay =\n\t\tcontainer_of(active, typeof(*overlay), last_flip);\n\n\tif (overlay->flip_complete)\n\t\toverlay->flip_complete(overlay);\n}\n\n \nstatic int intel_overlay_off(struct intel_overlay *overlay)\n{\n\tstruct i915_request *rq;\n\tu32 *cs, flip_addr = overlay->flip_addr;\n\n\tdrm_WARN_ON(&overlay->i915->drm, !overlay->active);\n\n\t \n\tflip_addr |= OFC_UPDATE;\n\n\trq = alloc_request(overlay, intel_overlay_off_tail);\n\tif (IS_ERR(rq))\n\t\treturn PTR_ERR(rq);\n\n\tcs = intel_ring_begin(rq, 6);\n\tif (IS_ERR(cs)) {\n\t\ti915_request_add(rq);\n\t\treturn PTR_ERR(cs);\n\t}\n\n\t \n\t*cs++ = MI_OVERLAY_FLIP | MI_OVERLAY_CONTINUE;\n\t*cs++ = flip_addr;\n\t*cs++ = MI_WAIT_FOR_EVENT | MI_WAIT_FOR_OVERLAY_FLIP;\n\n\t \n\t*cs++ = MI_OVERLAY_FLIP | MI_OVERLAY_OFF;\n\t*cs++ = flip_addr;\n\t*cs++ = MI_WAIT_FOR_EVENT | MI_WAIT_FOR_OVERLAY_FLIP;\n\n\tintel_ring_advance(rq, cs);\n\n\tintel_overlay_flip_prepare(overlay, NULL);\n\ti915_request_add(rq);\n\n\treturn i915_active_wait(&overlay->last_flip);\n}\n\n \nstatic int intel_overlay_recover_from_interrupt(struct intel_overlay *overlay)\n{\n\treturn i915_active_wait(&overlay->last_flip);\n}\n\n \nstatic int intel_overlay_release_old_vid(struct intel_overlay *overlay)\n{\n\tstruct drm_i915_private *dev_priv = overlay->i915;\n\tstruct i915_request *rq;\n\tu32 *cs;\n\n\t \n\tif (!overlay->old_vma)\n\t\treturn 0;\n\n\tif (!(intel_de_read(dev_priv, GEN2_ISR) & I915_OVERLAY_PLANE_FLIP_PENDING_INTERRUPT)) {\n\t\tintel_overlay_release_old_vid_tail(overlay);\n\t\treturn 0;\n\t}\n\n\trq = alloc_request(overlay, intel_overlay_release_old_vid_tail);\n\tif (IS_ERR(rq))\n\t\treturn PTR_ERR(rq);\n\n\tcs = intel_ring_begin(rq, 2);\n\tif (IS_ERR(cs)) {\n\t\ti915_request_add(rq);\n\t\treturn PTR_ERR(cs);\n\t}\n\n\t*cs++ = MI_WAIT_FOR_EVENT | MI_WAIT_FOR_OVERLAY_FLIP;\n\t*cs++ = MI_NOOP;\n\tintel_ring_advance(rq, cs);\n\n\ti915_request_add(rq);\n\n\treturn i915_active_wait(&overlay->last_flip);\n}\n\nvoid intel_overlay_reset(struct drm_i915_private *dev_priv)\n{\n\tstruct intel_overlay *overlay = dev_priv->display.overlay;\n\n\tif (!overlay)\n\t\treturn;\n\n\toverlay->old_xscale = 0;\n\toverlay->old_yscale = 0;\n\toverlay->crtc = NULL;\n\toverlay->active = false;\n}\n\nstatic int packed_depth_bytes(u32 format)\n{\n\tswitch (format & I915_OVERLAY_DEPTH_MASK) {\n\tcase I915_OVERLAY_YUV422:\n\t\treturn 4;\n\tcase I915_OVERLAY_YUV411:\n\t\t \n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic int packed_width_bytes(u32 format, short width)\n{\n\tswitch (format & I915_OVERLAY_DEPTH_MASK) {\n\tcase I915_OVERLAY_YUV422:\n\t\treturn width << 1;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic int uv_hsubsampling(u32 format)\n{\n\tswitch (format & I915_OVERLAY_DEPTH_MASK) {\n\tcase I915_OVERLAY_YUV422:\n\tcase I915_OVERLAY_YUV420:\n\t\treturn 2;\n\tcase I915_OVERLAY_YUV411:\n\tcase I915_OVERLAY_YUV410:\n\t\treturn 4;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic int uv_vsubsampling(u32 format)\n{\n\tswitch (format & I915_OVERLAY_DEPTH_MASK) {\n\tcase I915_OVERLAY_YUV420:\n\tcase I915_OVERLAY_YUV410:\n\t\treturn 2;\n\tcase I915_OVERLAY_YUV422:\n\tcase I915_OVERLAY_YUV411:\n\t\treturn 1;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic u32 calc_swidthsw(struct drm_i915_private *dev_priv, u32 offset, u32 width)\n{\n\tu32 sw;\n\n\tif (DISPLAY_VER(dev_priv) == 2)\n\t\tsw = ALIGN((offset & 31) + width, 32);\n\telse\n\t\tsw = ALIGN((offset & 63) + width, 64);\n\n\tif (sw == 0)\n\t\treturn 0;\n\n\treturn (sw - 32) >> 3;\n}\n\nstatic const u16 y_static_hcoeffs[N_PHASES][N_HORIZ_Y_TAPS] = {\n\t[ 0] = { 0x3000, 0xb4a0, 0x1930, 0x1920, 0xb4a0, },\n\t[ 1] = { 0x3000, 0xb500, 0x19d0, 0x1880, 0xb440, },\n\t[ 2] = { 0x3000, 0xb540, 0x1a88, 0x2f80, 0xb3e0, },\n\t[ 3] = { 0x3000, 0xb580, 0x1b30, 0x2e20, 0xb380, },\n\t[ 4] = { 0x3000, 0xb5c0, 0x1bd8, 0x2cc0, 0xb320, },\n\t[ 5] = { 0x3020, 0xb5e0, 0x1c60, 0x2b80, 0xb2c0, },\n\t[ 6] = { 0x3020, 0xb5e0, 0x1cf8, 0x2a20, 0xb260, },\n\t[ 7] = { 0x3020, 0xb5e0, 0x1d80, 0x28e0, 0xb200, },\n\t[ 8] = { 0x3020, 0xb5c0, 0x1e08, 0x3f40, 0xb1c0, },\n\t[ 9] = { 0x3020, 0xb580, 0x1e78, 0x3ce0, 0xb160, },\n\t[10] = { 0x3040, 0xb520, 0x1ed8, 0x3aa0, 0xb120, },\n\t[11] = { 0x3040, 0xb4a0, 0x1f30, 0x3880, 0xb0e0, },\n\t[12] = { 0x3040, 0xb400, 0x1f78, 0x3680, 0xb0a0, },\n\t[13] = { 0x3020, 0xb340, 0x1fb8, 0x34a0, 0xb060, },\n\t[14] = { 0x3020, 0xb240, 0x1fe0, 0x32e0, 0xb040, },\n\t[15] = { 0x3020, 0xb140, 0x1ff8, 0x3160, 0xb020, },\n\t[16] = { 0xb000, 0x3000, 0x0800, 0x3000, 0xb000, },\n};\n\nstatic const u16 uv_static_hcoeffs[N_PHASES][N_HORIZ_UV_TAPS] = {\n\t[ 0] = { 0x3000, 0x1800, 0x1800, },\n\t[ 1] = { 0xb000, 0x18d0, 0x2e60, },\n\t[ 2] = { 0xb000, 0x1990, 0x2ce0, },\n\t[ 3] = { 0xb020, 0x1a68, 0x2b40, },\n\t[ 4] = { 0xb040, 0x1b20, 0x29e0, },\n\t[ 5] = { 0xb060, 0x1bd8, 0x2880, },\n\t[ 6] = { 0xb080, 0x1c88, 0x3e60, },\n\t[ 7] = { 0xb0a0, 0x1d28, 0x3c00, },\n\t[ 8] = { 0xb0c0, 0x1db8, 0x39e0, },\n\t[ 9] = { 0xb0e0, 0x1e40, 0x37e0, },\n\t[10] = { 0xb100, 0x1eb8, 0x3620, },\n\t[11] = { 0xb100, 0x1f18, 0x34a0, },\n\t[12] = { 0xb100, 0x1f68, 0x3360, },\n\t[13] = { 0xb0e0, 0x1fa8, 0x3240, },\n\t[14] = { 0xb0c0, 0x1fe0, 0x3140, },\n\t[15] = { 0xb060, 0x1ff0, 0x30a0, },\n\t[16] = { 0x3000, 0x0800, 0x3000, },\n};\n\nstatic void update_polyphase_filter(struct overlay_registers __iomem *regs)\n{\n\tmemcpy_toio(regs->Y_HCOEFS, y_static_hcoeffs, sizeof(y_static_hcoeffs));\n\tmemcpy_toio(regs->UV_HCOEFS, uv_static_hcoeffs,\n\t\t    sizeof(uv_static_hcoeffs));\n}\n\nstatic bool update_scaling_factors(struct intel_overlay *overlay,\n\t\t\t\t   struct overlay_registers __iomem *regs,\n\t\t\t\t   struct drm_intel_overlay_put_image *params)\n{\n\t \n\tu32 xscale, yscale, xscale_UV, yscale_UV;\n#define FP_SHIFT 12\n#define FRACT_MASK 0xfff\n\tbool scale_changed = false;\n\tint uv_hscale = uv_hsubsampling(params->flags);\n\tint uv_vscale = uv_vsubsampling(params->flags);\n\n\tif (params->dst_width > 1)\n\t\txscale = ((params->src_scan_width - 1) << FP_SHIFT) /\n\t\t\tparams->dst_width;\n\telse\n\t\txscale = 1 << FP_SHIFT;\n\n\tif (params->dst_height > 1)\n\t\tyscale = ((params->src_scan_height - 1) << FP_SHIFT) /\n\t\t\tparams->dst_height;\n\telse\n\t\tyscale = 1 << FP_SHIFT;\n\n\t \n\txscale_UV = xscale/uv_hscale;\n\tyscale_UV = yscale/uv_vscale;\n\t \n\txscale = xscale_UV * uv_hscale;\n\tyscale = yscale_UV * uv_vscale;\n\t \n\n\tif (xscale != overlay->old_xscale || yscale != overlay->old_yscale)\n\t\tscale_changed = true;\n\toverlay->old_xscale = xscale;\n\toverlay->old_yscale = yscale;\n\n\tiowrite32(((yscale & FRACT_MASK) << 20) |\n\t\t  ((xscale >> FP_SHIFT)  << 16) |\n\t\t  ((xscale & FRACT_MASK) << 3),\n\t\t &regs->YRGBSCALE);\n\n\tiowrite32(((yscale_UV & FRACT_MASK) << 20) |\n\t\t  ((xscale_UV >> FP_SHIFT)  << 16) |\n\t\t  ((xscale_UV & FRACT_MASK) << 3),\n\t\t &regs->UVSCALE);\n\n\tiowrite32((((yscale    >> FP_SHIFT) << 16) |\n\t\t   ((yscale_UV >> FP_SHIFT) << 0)),\n\t\t &regs->UVSCALEV);\n\n\tif (scale_changed)\n\t\tupdate_polyphase_filter(regs);\n\n\treturn scale_changed;\n}\n\nstatic void update_colorkey(struct intel_overlay *overlay,\n\t\t\t    struct overlay_registers __iomem *regs)\n{\n\tconst struct intel_plane_state *state =\n\t\tto_intel_plane_state(overlay->crtc->base.primary->state);\n\tu32 key = overlay->color_key;\n\tu32 format = 0;\n\tu32 flags = 0;\n\n\tif (overlay->color_key_enabled)\n\t\tflags |= DST_KEY_ENABLE;\n\n\tif (state->uapi.visible)\n\t\tformat = state->hw.fb->format->format;\n\n\tswitch (format) {\n\tcase DRM_FORMAT_C8:\n\t\tkey = RGB8I_TO_COLORKEY(key);\n\t\tflags |= CLK_RGB24_MASK;\n\t\tbreak;\n\tcase DRM_FORMAT_XRGB1555:\n\t\tkey = RGB15_TO_COLORKEY(key);\n\t\tflags |= CLK_RGB15_MASK;\n\t\tbreak;\n\tcase DRM_FORMAT_RGB565:\n\t\tkey = RGB16_TO_COLORKEY(key);\n\t\tflags |= CLK_RGB16_MASK;\n\t\tbreak;\n\tcase DRM_FORMAT_XRGB2101010:\n\tcase DRM_FORMAT_XBGR2101010:\n\t\tkey = RGB30_TO_COLORKEY(key);\n\t\tflags |= CLK_RGB24_MASK;\n\t\tbreak;\n\tdefault:\n\t\tflags |= CLK_RGB24_MASK;\n\t\tbreak;\n\t}\n\n\tiowrite32(key, &regs->DCLRKV);\n\tiowrite32(flags, &regs->DCLRKM);\n}\n\nstatic u32 overlay_cmd_reg(struct drm_intel_overlay_put_image *params)\n{\n\tu32 cmd = OCMD_ENABLE | OCMD_BUF_TYPE_FRAME | OCMD_BUFFER0;\n\n\tif (params->flags & I915_OVERLAY_YUV_PLANAR) {\n\t\tswitch (params->flags & I915_OVERLAY_DEPTH_MASK) {\n\t\tcase I915_OVERLAY_YUV422:\n\t\t\tcmd |= OCMD_YUV_422_PLANAR;\n\t\t\tbreak;\n\t\tcase I915_OVERLAY_YUV420:\n\t\t\tcmd |= OCMD_YUV_420_PLANAR;\n\t\t\tbreak;\n\t\tcase I915_OVERLAY_YUV411:\n\t\tcase I915_OVERLAY_YUV410:\n\t\t\tcmd |= OCMD_YUV_410_PLANAR;\n\t\t\tbreak;\n\t\t}\n\t} else {  \n\t\tswitch (params->flags & I915_OVERLAY_DEPTH_MASK) {\n\t\tcase I915_OVERLAY_YUV422:\n\t\t\tcmd |= OCMD_YUV_422_PACKED;\n\t\t\tbreak;\n\t\tcase I915_OVERLAY_YUV411:\n\t\t\tcmd |= OCMD_YUV_411_PACKED;\n\t\t\tbreak;\n\t\t}\n\n\t\tswitch (params->flags & I915_OVERLAY_SWAP_MASK) {\n\t\tcase I915_OVERLAY_NO_SWAP:\n\t\t\tbreak;\n\t\tcase I915_OVERLAY_UV_SWAP:\n\t\t\tcmd |= OCMD_UV_SWAP;\n\t\t\tbreak;\n\t\tcase I915_OVERLAY_Y_SWAP:\n\t\t\tcmd |= OCMD_Y_SWAP;\n\t\t\tbreak;\n\t\tcase I915_OVERLAY_Y_AND_UV_SWAP:\n\t\t\tcmd |= OCMD_Y_AND_UV_SWAP;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn cmd;\n}\n\nstatic struct i915_vma *intel_overlay_pin_fb(struct drm_i915_gem_object *new_bo)\n{\n\tstruct i915_gem_ww_ctx ww;\n\tstruct i915_vma *vma;\n\tint ret;\n\n\ti915_gem_ww_ctx_init(&ww, true);\nretry:\n\tret = i915_gem_object_lock(new_bo, &ww);\n\tif (!ret) {\n\t\tvma = i915_gem_object_pin_to_display_plane(new_bo, &ww, 0,\n\t\t\t\t\t\t\t   NULL, PIN_MAPPABLE);\n\t\tret = PTR_ERR_OR_ZERO(vma);\n\t}\n\tif (ret == -EDEADLK) {\n\t\tret = i915_gem_ww_ctx_backoff(&ww);\n\t\tif (!ret)\n\t\t\tgoto retry;\n\t}\n\ti915_gem_ww_ctx_fini(&ww);\n\tif (ret)\n\t\treturn ERR_PTR(ret);\n\n\treturn vma;\n}\n\nstatic int intel_overlay_do_put_image(struct intel_overlay *overlay,\n\t\t\t\t      struct drm_i915_gem_object *new_bo,\n\t\t\t\t      struct drm_intel_overlay_put_image *params)\n{\n\tstruct overlay_registers __iomem *regs = overlay->regs;\n\tstruct drm_i915_private *dev_priv = overlay->i915;\n\tu32 swidth, swidthsw, sheight, ostride;\n\tenum pipe pipe = overlay->crtc->pipe;\n\tbool scale_changed = false;\n\tstruct i915_vma *vma;\n\tint ret, tmp_width;\n\n\tdrm_WARN_ON(&dev_priv->drm,\n\t\t    !drm_modeset_is_locked(&dev_priv->drm.mode_config.connection_mutex));\n\n\tret = intel_overlay_release_old_vid(overlay);\n\tif (ret != 0)\n\t\treturn ret;\n\n\tatomic_inc(&dev_priv->gpu_error.pending_fb_pin);\n\n\tvma = intel_overlay_pin_fb(new_bo);\n\tif (IS_ERR(vma)) {\n\t\tret = PTR_ERR(vma);\n\t\tgoto out_pin_section;\n\t}\n\n\ti915_gem_object_flush_frontbuffer(new_bo, ORIGIN_DIRTYFB);\n\n\tif (!overlay->active) {\n\t\tconst struct intel_crtc_state *crtc_state =\n\t\t\toverlay->crtc->config;\n\t\tu32 oconfig = 0;\n\n\t\tif (crtc_state->gamma_enable &&\n\t\t    crtc_state->gamma_mode == GAMMA_MODE_MODE_8BIT)\n\t\t\toconfig |= OCONF_CC_OUT_8BIT;\n\t\tif (crtc_state->gamma_enable)\n\t\t\toconfig |= OCONF_GAMMA2_ENABLE;\n\t\tif (DISPLAY_VER(dev_priv) == 4)\n\t\t\toconfig |= OCONF_CSC_MODE_BT709;\n\t\toconfig |= pipe == 0 ?\n\t\t\tOCONF_PIPE_A : OCONF_PIPE_B;\n\t\tiowrite32(oconfig, &regs->OCONFIG);\n\n\t\tret = intel_overlay_on(overlay);\n\t\tif (ret != 0)\n\t\t\tgoto out_unpin;\n\t}\n\n\tiowrite32(params->dst_y << 16 | params->dst_x, &regs->DWINPOS);\n\tiowrite32(params->dst_height << 16 | params->dst_width, &regs->DWINSZ);\n\n\tif (params->flags & I915_OVERLAY_YUV_PACKED)\n\t\ttmp_width = packed_width_bytes(params->flags,\n\t\t\t\t\t       params->src_width);\n\telse\n\t\ttmp_width = params->src_width;\n\n\tswidth = params->src_width;\n\tswidthsw = calc_swidthsw(dev_priv, params->offset_Y, tmp_width);\n\tsheight = params->src_height;\n\tiowrite32(i915_ggtt_offset(vma) + params->offset_Y, &regs->OBUF_0Y);\n\tostride = params->stride_Y;\n\n\tif (params->flags & I915_OVERLAY_YUV_PLANAR) {\n\t\tint uv_hscale = uv_hsubsampling(params->flags);\n\t\tint uv_vscale = uv_vsubsampling(params->flags);\n\t\tu32 tmp_U, tmp_V;\n\n\t\tswidth |= (params->src_width / uv_hscale) << 16;\n\t\tsheight |= (params->src_height / uv_vscale) << 16;\n\n\t\ttmp_U = calc_swidthsw(dev_priv, params->offset_U,\n\t\t\t\t      params->src_width / uv_hscale);\n\t\ttmp_V = calc_swidthsw(dev_priv, params->offset_V,\n\t\t\t\t      params->src_width / uv_hscale);\n\t\tswidthsw |= max(tmp_U, tmp_V) << 16;\n\n\t\tiowrite32(i915_ggtt_offset(vma) + params->offset_U,\n\t\t\t  &regs->OBUF_0U);\n\t\tiowrite32(i915_ggtt_offset(vma) + params->offset_V,\n\t\t\t  &regs->OBUF_0V);\n\n\t\tostride |= params->stride_UV << 16;\n\t}\n\n\tiowrite32(swidth, &regs->SWIDTH);\n\tiowrite32(swidthsw, &regs->SWIDTHSW);\n\tiowrite32(sheight, &regs->SHEIGHT);\n\tiowrite32(ostride, &regs->OSTRIDE);\n\n\tscale_changed = update_scaling_factors(overlay, regs, params);\n\n\tupdate_colorkey(overlay, regs);\n\n\tiowrite32(overlay_cmd_reg(params), &regs->OCMD);\n\n\tret = intel_overlay_continue(overlay, vma, scale_changed);\n\tif (ret)\n\t\tgoto out_unpin;\n\n\treturn 0;\n\nout_unpin:\n\ti915_vma_unpin(vma);\nout_pin_section:\n\tatomic_dec(&dev_priv->gpu_error.pending_fb_pin);\n\n\treturn ret;\n}\n\nint intel_overlay_switch_off(struct intel_overlay *overlay)\n{\n\tstruct drm_i915_private *dev_priv = overlay->i915;\n\tint ret;\n\n\tdrm_WARN_ON(&dev_priv->drm,\n\t\t    !drm_modeset_is_locked(&dev_priv->drm.mode_config.connection_mutex));\n\n\tret = intel_overlay_recover_from_interrupt(overlay);\n\tif (ret != 0)\n\t\treturn ret;\n\n\tif (!overlay->active)\n\t\treturn 0;\n\n\tret = intel_overlay_release_old_vid(overlay);\n\tif (ret != 0)\n\t\treturn ret;\n\n\tiowrite32(0, &overlay->regs->OCMD);\n\n\treturn intel_overlay_off(overlay);\n}\n\nstatic int check_overlay_possible_on_crtc(struct intel_overlay *overlay,\n\t\t\t\t\t  struct intel_crtc *crtc)\n{\n\tif (!crtc->active)\n\t\treturn -EINVAL;\n\n\t \n\tif (crtc->config->double_wide)\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nstatic void update_pfit_vscale_ratio(struct intel_overlay *overlay)\n{\n\tstruct drm_i915_private *dev_priv = overlay->i915;\n\tu32 ratio;\n\n\t \n\tif (DISPLAY_VER(dev_priv) >= 4) {\n\t\tu32 tmp = intel_de_read(dev_priv, PFIT_PGM_RATIOS);\n\n\t\t \n\t\tratio = REG_FIELD_GET(PFIT_VERT_SCALE_MASK_965, tmp);\n\t} else {\n\t\tu32 tmp;\n\n\t\tif (intel_de_read(dev_priv, PFIT_CONTROL) & PFIT_VERT_AUTO_SCALE)\n\t\t\ttmp = intel_de_read(dev_priv, PFIT_AUTO_RATIOS);\n\t\telse\n\t\t\ttmp = intel_de_read(dev_priv, PFIT_PGM_RATIOS);\n\n\t\tratio = REG_FIELD_GET(PFIT_VERT_SCALE_MASK, tmp);\n\t}\n\n\toverlay->pfit_vscale_ratio = ratio;\n}\n\nstatic int check_overlay_dst(struct intel_overlay *overlay,\n\t\t\t     struct drm_intel_overlay_put_image *rec)\n{\n\tconst struct intel_crtc_state *crtc_state =\n\t\toverlay->crtc->config;\n\tstruct drm_rect req, clipped;\n\n\tdrm_rect_init(&req, rec->dst_x, rec->dst_y,\n\t\t      rec->dst_width, rec->dst_height);\n\n\tclipped = req;\n\tdrm_rect_intersect(&clipped, &crtc_state->pipe_src);\n\n\tif (!drm_rect_visible(&clipped) ||\n\t    !drm_rect_equals(&clipped, &req))\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nstatic int check_overlay_scaling(struct drm_intel_overlay_put_image *rec)\n{\n\tu32 tmp;\n\n\t \n\ttmp = ((rec->src_scan_height << 16) / rec->dst_height) >> 16;\n\tif (tmp > 7)\n\t\treturn -EINVAL;\n\n\ttmp = ((rec->src_scan_width << 16) / rec->dst_width) >> 16;\n\tif (tmp > 7)\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nstatic int check_overlay_src(struct drm_i915_private *dev_priv,\n\t\t\t     struct drm_intel_overlay_put_image *rec,\n\t\t\t     struct drm_i915_gem_object *new_bo)\n{\n\tint uv_hscale = uv_hsubsampling(rec->flags);\n\tint uv_vscale = uv_vsubsampling(rec->flags);\n\tu32 stride_mask;\n\tint depth;\n\tu32 tmp;\n\n\t \n\tif (IS_I845G(dev_priv) || IS_I830(dev_priv)) {\n\t\tif (rec->src_height > IMAGE_MAX_HEIGHT_LEGACY ||\n\t\t    rec->src_width  > IMAGE_MAX_WIDTH_LEGACY)\n\t\t\treturn -EINVAL;\n\t} else {\n\t\tif (rec->src_height > IMAGE_MAX_HEIGHT ||\n\t\t    rec->src_width  > IMAGE_MAX_WIDTH)\n\t\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (rec->src_height < N_VERT_Y_TAPS*4 ||\n\t    rec->src_width  < N_HORIZ_Y_TAPS*4)\n\t\treturn -EINVAL;\n\n\t \n\tswitch (rec->flags & I915_OVERLAY_TYPE_MASK) {\n\tcase I915_OVERLAY_RGB:\n\t\t \n\t\treturn -EINVAL;\n\n\tcase I915_OVERLAY_YUV_PACKED:\n\t\tif (uv_vscale != 1)\n\t\t\treturn -EINVAL;\n\n\t\tdepth = packed_depth_bytes(rec->flags);\n\t\tif (depth < 0)\n\t\t\treturn depth;\n\n\t\t \n\t\trec->stride_UV = 0;\n\t\trec->offset_U = 0;\n\t\trec->offset_V = 0;\n\t\t \n\t\tif (rec->offset_Y % depth)\n\t\t\treturn -EINVAL;\n\t\tbreak;\n\n\tcase I915_OVERLAY_YUV_PLANAR:\n\t\tif (uv_vscale < 0 || uv_hscale < 0)\n\t\t\treturn -EINVAL;\n\t\t \n\t\tbreak;\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tif (rec->src_width % uv_hscale)\n\t\treturn -EINVAL;\n\n\t \n\tif (IS_I830(dev_priv) || IS_I845G(dev_priv))\n\t\tstride_mask = 255;\n\telse\n\t\tstride_mask = 63;\n\n\tif (rec->stride_Y & stride_mask || rec->stride_UV & stride_mask)\n\t\treturn -EINVAL;\n\tif (DISPLAY_VER(dev_priv) == 4 && rec->stride_Y < 512)\n\t\treturn -EINVAL;\n\n\ttmp = (rec->flags & I915_OVERLAY_TYPE_MASK) == I915_OVERLAY_YUV_PLANAR ?\n\t\t4096 : 8192;\n\tif (rec->stride_Y > tmp || rec->stride_UV > 2*1024)\n\t\treturn -EINVAL;\n\n\t \n\tswitch (rec->flags & I915_OVERLAY_TYPE_MASK) {\n\tcase I915_OVERLAY_RGB:\n\tcase I915_OVERLAY_YUV_PACKED:\n\t\t \n\t\tif (packed_width_bytes(rec->flags, rec->src_width) > rec->stride_Y)\n\t\t\treturn -EINVAL;\n\n\t\ttmp = rec->stride_Y*rec->src_height;\n\t\tif (rec->offset_Y + tmp > new_bo->base.size)\n\t\t\treturn -EINVAL;\n\t\tbreak;\n\n\tcase I915_OVERLAY_YUV_PLANAR:\n\t\tif (rec->src_width > rec->stride_Y)\n\t\t\treturn -EINVAL;\n\t\tif (rec->src_width/uv_hscale > rec->stride_UV)\n\t\t\treturn -EINVAL;\n\n\t\ttmp = rec->stride_Y * rec->src_height;\n\t\tif (rec->offset_Y + tmp > new_bo->base.size)\n\t\t\treturn -EINVAL;\n\n\t\ttmp = rec->stride_UV * (rec->src_height / uv_vscale);\n\t\tif (rec->offset_U + tmp > new_bo->base.size ||\n\t\t    rec->offset_V + tmp > new_bo->base.size)\n\t\t\treturn -EINVAL;\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nint intel_overlay_put_image_ioctl(struct drm_device *dev, void *data,\n\t\t\t\t  struct drm_file *file_priv)\n{\n\tstruct drm_intel_overlay_put_image *params = data;\n\tstruct drm_i915_private *dev_priv = to_i915(dev);\n\tstruct intel_overlay *overlay;\n\tstruct drm_crtc *drmmode_crtc;\n\tstruct intel_crtc *crtc;\n\tstruct drm_i915_gem_object *new_bo;\n\tint ret;\n\n\toverlay = dev_priv->display.overlay;\n\tif (!overlay) {\n\t\tdrm_dbg(&dev_priv->drm, \"userspace bug: no overlay\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tif (!(params->flags & I915_OVERLAY_ENABLE)) {\n\t\tdrm_modeset_lock_all(dev);\n\t\tret = intel_overlay_switch_off(overlay);\n\t\tdrm_modeset_unlock_all(dev);\n\n\t\treturn ret;\n\t}\n\n\tdrmmode_crtc = drm_crtc_find(dev, file_priv, params->crtc_id);\n\tif (!drmmode_crtc)\n\t\treturn -ENOENT;\n\tcrtc = to_intel_crtc(drmmode_crtc);\n\n\tnew_bo = i915_gem_object_lookup(file_priv, params->bo_handle);\n\tif (!new_bo)\n\t\treturn -ENOENT;\n\n\tdrm_modeset_lock_all(dev);\n\n\tif (i915_gem_object_is_tiled(new_bo)) {\n\t\tdrm_dbg_kms(&dev_priv->drm,\n\t\t\t    \"buffer used for overlay image can not be tiled\\n\");\n\t\tret = -EINVAL;\n\t\tgoto out_unlock;\n\t}\n\n\tret = intel_overlay_recover_from_interrupt(overlay);\n\tif (ret != 0)\n\t\tgoto out_unlock;\n\n\tif (overlay->crtc != crtc) {\n\t\tret = intel_overlay_switch_off(overlay);\n\t\tif (ret != 0)\n\t\t\tgoto out_unlock;\n\n\t\tret = check_overlay_possible_on_crtc(overlay, crtc);\n\t\tif (ret != 0)\n\t\t\tgoto out_unlock;\n\n\t\toverlay->crtc = crtc;\n\t\tcrtc->overlay = overlay;\n\n\t\t \n\t\tif (drm_rect_width(&crtc->config->pipe_src) > 1024 &&\n\t\t    crtc->config->gmch_pfit.control & PFIT_ENABLE) {\n\t\t\toverlay->pfit_active = true;\n\t\t\tupdate_pfit_vscale_ratio(overlay);\n\t\t} else\n\t\t\toverlay->pfit_active = false;\n\t}\n\n\tret = check_overlay_dst(overlay, params);\n\tif (ret != 0)\n\t\tgoto out_unlock;\n\n\tif (overlay->pfit_active) {\n\t\tparams->dst_y = (((u32)params->dst_y << 12) /\n\t\t\t\t overlay->pfit_vscale_ratio);\n\t\t \n\t\tparams->dst_height = (((u32)params->dst_height << 12) /\n\t\t\t\t overlay->pfit_vscale_ratio) + 1;\n\t}\n\n\tif (params->src_scan_height > params->src_height ||\n\t    params->src_scan_width > params->src_width) {\n\t\tret = -EINVAL;\n\t\tgoto out_unlock;\n\t}\n\n\tret = check_overlay_src(dev_priv, params, new_bo);\n\tif (ret != 0)\n\t\tgoto out_unlock;\n\n\t \n\tret = check_overlay_scaling(params);\n\tif (ret != 0)\n\t\tgoto out_unlock;\n\n\tret = intel_overlay_do_put_image(overlay, new_bo, params);\n\tif (ret != 0)\n\t\tgoto out_unlock;\n\n\tdrm_modeset_unlock_all(dev);\n\ti915_gem_object_put(new_bo);\n\n\treturn 0;\n\nout_unlock:\n\tdrm_modeset_unlock_all(dev);\n\ti915_gem_object_put(new_bo);\n\n\treturn ret;\n}\n\nstatic void update_reg_attrs(struct intel_overlay *overlay,\n\t\t\t     struct overlay_registers __iomem *regs)\n{\n\tiowrite32((overlay->contrast << 18) | (overlay->brightness & 0xff),\n\t\t  &regs->OCLRC0);\n\tiowrite32(overlay->saturation, &regs->OCLRC1);\n}\n\nstatic bool check_gamma_bounds(u32 gamma1, u32 gamma2)\n{\n\tint i;\n\n\tif (gamma1 & 0xff000000 || gamma2 & 0xff000000)\n\t\treturn false;\n\n\tfor (i = 0; i < 3; i++) {\n\t\tif (((gamma1 >> i*8) & 0xff) >= ((gamma2 >> i*8) & 0xff))\n\t\t\treturn false;\n\t}\n\n\treturn true;\n}\n\nstatic bool check_gamma5_errata(u32 gamma5)\n{\n\tint i;\n\n\tfor (i = 0; i < 3; i++) {\n\t\tif (((gamma5 >> i*8) & 0xff) == 0x80)\n\t\t\treturn false;\n\t}\n\n\treturn true;\n}\n\nstatic int check_gamma(struct drm_intel_overlay_attrs *attrs)\n{\n\tif (!check_gamma_bounds(0, attrs->gamma0) ||\n\t    !check_gamma_bounds(attrs->gamma0, attrs->gamma1) ||\n\t    !check_gamma_bounds(attrs->gamma1, attrs->gamma2) ||\n\t    !check_gamma_bounds(attrs->gamma2, attrs->gamma3) ||\n\t    !check_gamma_bounds(attrs->gamma3, attrs->gamma4) ||\n\t    !check_gamma_bounds(attrs->gamma4, attrs->gamma5) ||\n\t    !check_gamma_bounds(attrs->gamma5, 0x00ffffff))\n\t\treturn -EINVAL;\n\n\tif (!check_gamma5_errata(attrs->gamma5))\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nint intel_overlay_attrs_ioctl(struct drm_device *dev, void *data,\n\t\t\t      struct drm_file *file_priv)\n{\n\tstruct drm_intel_overlay_attrs *attrs = data;\n\tstruct drm_i915_private *dev_priv = to_i915(dev);\n\tstruct intel_overlay *overlay;\n\tint ret;\n\n\toverlay = dev_priv->display.overlay;\n\tif (!overlay) {\n\t\tdrm_dbg(&dev_priv->drm, \"userspace bug: no overlay\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tdrm_modeset_lock_all(dev);\n\n\tret = -EINVAL;\n\tif (!(attrs->flags & I915_OVERLAY_UPDATE_ATTRS)) {\n\t\tattrs->color_key  = overlay->color_key;\n\t\tattrs->brightness = overlay->brightness;\n\t\tattrs->contrast   = overlay->contrast;\n\t\tattrs->saturation = overlay->saturation;\n\n\t\tif (DISPLAY_VER(dev_priv) != 2) {\n\t\t\tattrs->gamma0 = intel_de_read(dev_priv, OGAMC0);\n\t\t\tattrs->gamma1 = intel_de_read(dev_priv, OGAMC1);\n\t\t\tattrs->gamma2 = intel_de_read(dev_priv, OGAMC2);\n\t\t\tattrs->gamma3 = intel_de_read(dev_priv, OGAMC3);\n\t\t\tattrs->gamma4 = intel_de_read(dev_priv, OGAMC4);\n\t\t\tattrs->gamma5 = intel_de_read(dev_priv, OGAMC5);\n\t\t}\n\t} else {\n\t\tif (attrs->brightness < -128 || attrs->brightness > 127)\n\t\t\tgoto out_unlock;\n\t\tif (attrs->contrast > 255)\n\t\t\tgoto out_unlock;\n\t\tif (attrs->saturation > 1023)\n\t\t\tgoto out_unlock;\n\n\t\toverlay->color_key  = attrs->color_key;\n\t\toverlay->brightness = attrs->brightness;\n\t\toverlay->contrast   = attrs->contrast;\n\t\toverlay->saturation = attrs->saturation;\n\n\t\tupdate_reg_attrs(overlay, overlay->regs);\n\n\t\tif (attrs->flags & I915_OVERLAY_UPDATE_GAMMA) {\n\t\t\tif (DISPLAY_VER(dev_priv) == 2)\n\t\t\t\tgoto out_unlock;\n\n\t\t\tif (overlay->active) {\n\t\t\t\tret = -EBUSY;\n\t\t\t\tgoto out_unlock;\n\t\t\t}\n\n\t\t\tret = check_gamma(attrs);\n\t\t\tif (ret)\n\t\t\t\tgoto out_unlock;\n\n\t\t\tintel_de_write(dev_priv, OGAMC0, attrs->gamma0);\n\t\t\tintel_de_write(dev_priv, OGAMC1, attrs->gamma1);\n\t\t\tintel_de_write(dev_priv, OGAMC2, attrs->gamma2);\n\t\t\tintel_de_write(dev_priv, OGAMC3, attrs->gamma3);\n\t\t\tintel_de_write(dev_priv, OGAMC4, attrs->gamma4);\n\t\t\tintel_de_write(dev_priv, OGAMC5, attrs->gamma5);\n\t\t}\n\t}\n\toverlay->color_key_enabled = (attrs->flags & I915_OVERLAY_DISABLE_DEST_COLORKEY) == 0;\n\n\tret = 0;\nout_unlock:\n\tdrm_modeset_unlock_all(dev);\n\n\treturn ret;\n}\n\nstatic int get_registers(struct intel_overlay *overlay, bool use_phys)\n{\n\tstruct drm_i915_private *i915 = overlay->i915;\n\tstruct drm_i915_gem_object *obj = ERR_PTR(-ENODEV);\n\tstruct i915_vma *vma;\n\tint err;\n\n\tif (!IS_METEORLAKE(i915))  \n\t\tobj = i915_gem_object_create_stolen(i915, PAGE_SIZE);\n\tif (IS_ERR(obj))\n\t\tobj = i915_gem_object_create_internal(i915, PAGE_SIZE);\n\tif (IS_ERR(obj))\n\t\treturn PTR_ERR(obj);\n\n\tvma = i915_gem_object_ggtt_pin(obj, NULL, 0, 0, PIN_MAPPABLE);\n\tif (IS_ERR(vma)) {\n\t\terr = PTR_ERR(vma);\n\t\tgoto err_put_bo;\n\t}\n\n\tif (use_phys)\n\t\toverlay->flip_addr = sg_dma_address(obj->mm.pages->sgl);\n\telse\n\t\toverlay->flip_addr = i915_ggtt_offset(vma);\n\toverlay->regs = i915_vma_pin_iomap(vma);\n\ti915_vma_unpin(vma);\n\n\tif (IS_ERR(overlay->regs)) {\n\t\terr = PTR_ERR(overlay->regs);\n\t\tgoto err_put_bo;\n\t}\n\n\toverlay->reg_bo = obj;\n\treturn 0;\n\nerr_put_bo:\n\ti915_gem_object_put(obj);\n\treturn err;\n}\n\nvoid intel_overlay_setup(struct drm_i915_private *dev_priv)\n{\n\tstruct intel_overlay *overlay;\n\tstruct intel_engine_cs *engine;\n\tint ret;\n\n\tif (!HAS_OVERLAY(dev_priv))\n\t\treturn;\n\n\tengine = to_gt(dev_priv)->engine[RCS0];\n\tif (!engine || !engine->kernel_context)\n\t\treturn;\n\n\toverlay = kzalloc(sizeof(*overlay), GFP_KERNEL);\n\tif (!overlay)\n\t\treturn;\n\n\toverlay->i915 = dev_priv;\n\toverlay->context = engine->kernel_context;\n\toverlay->color_key = 0x0101fe;\n\toverlay->color_key_enabled = true;\n\toverlay->brightness = -19;\n\toverlay->contrast = 75;\n\toverlay->saturation = 146;\n\n\ti915_active_init(&overlay->last_flip,\n\t\t\t NULL, intel_overlay_last_flip_retire, 0);\n\n\tret = get_registers(overlay, OVERLAY_NEEDS_PHYSICAL(dev_priv));\n\tif (ret)\n\t\tgoto out_free;\n\n\tmemset_io(overlay->regs, 0, sizeof(struct overlay_registers));\n\tupdate_polyphase_filter(overlay->regs);\n\tupdate_reg_attrs(overlay, overlay->regs);\n\n\tdev_priv->display.overlay = overlay;\n\tdrm_info(&dev_priv->drm, \"Initialized overlay support.\\n\");\n\treturn;\n\nout_free:\n\tkfree(overlay);\n}\n\nvoid intel_overlay_cleanup(struct drm_i915_private *dev_priv)\n{\n\tstruct intel_overlay *overlay;\n\n\toverlay = fetch_and_zero(&dev_priv->display.overlay);\n\tif (!overlay)\n\t\treturn;\n\n\t \n\tdrm_WARN_ON(&dev_priv->drm, overlay->active);\n\n\ti915_gem_object_put(overlay->reg_bo);\n\ti915_active_fini(&overlay->last_flip);\n\n\tkfree(overlay);\n}\n\n#if IS_ENABLED(CONFIG_DRM_I915_CAPTURE_ERROR)\n\nstruct intel_overlay_error_state {\n\tstruct overlay_registers regs;\n\tunsigned long base;\n\tu32 dovsta;\n\tu32 isr;\n};\n\nstruct intel_overlay_error_state *\nintel_overlay_capture_error_state(struct drm_i915_private *dev_priv)\n{\n\tstruct intel_overlay *overlay = dev_priv->display.overlay;\n\tstruct intel_overlay_error_state *error;\n\n\tif (!overlay || !overlay->active)\n\t\treturn NULL;\n\n\terror = kmalloc(sizeof(*error), GFP_ATOMIC);\n\tif (error == NULL)\n\t\treturn NULL;\n\n\terror->dovsta = intel_de_read(dev_priv, DOVSTA);\n\terror->isr = intel_de_read(dev_priv, GEN2_ISR);\n\terror->base = overlay->flip_addr;\n\n\tmemcpy_fromio(&error->regs, overlay->regs, sizeof(error->regs));\n\n\treturn error;\n}\n\nvoid\nintel_overlay_print_error_state(struct drm_i915_error_state_buf *m,\n\t\t\t\tstruct intel_overlay_error_state *error)\n{\n\ti915_error_printf(m, \"Overlay, status: 0x%08x, interrupt: 0x%08x\\n\",\n\t\t\t  error->dovsta, error->isr);\n\ti915_error_printf(m, \"  Register file at 0x%08lx:\\n\",\n\t\t\t  error->base);\n\n#define P(x) i915_error_printf(m, \"    \" #x \":\t0x%08x\\n\", error->regs.x)\n\tP(OBUF_0Y);\n\tP(OBUF_1Y);\n\tP(OBUF_0U);\n\tP(OBUF_0V);\n\tP(OBUF_1U);\n\tP(OBUF_1V);\n\tP(OSTRIDE);\n\tP(YRGB_VPH);\n\tP(UV_VPH);\n\tP(HORZ_PH);\n\tP(INIT_PHS);\n\tP(DWINPOS);\n\tP(DWINSZ);\n\tP(SWIDTH);\n\tP(SWIDTHSW);\n\tP(SHEIGHT);\n\tP(YRGBSCALE);\n\tP(UVSCALE);\n\tP(OCLRC0);\n\tP(OCLRC1);\n\tP(DCLRKV);\n\tP(DCLRKM);\n\tP(SCLRKVH);\n\tP(SCLRKVL);\n\tP(SCLRKEN);\n\tP(OCONFIG);\n\tP(OCMD);\n\tP(OSTART_0Y);\n\tP(OSTART_1Y);\n\tP(OSTART_0U);\n\tP(OSTART_0V);\n\tP(OSTART_1U);\n\tP(OSTART_1V);\n\tP(OTILEOFF_0Y);\n\tP(OTILEOFF_1Y);\n\tP(OTILEOFF_0U);\n\tP(OTILEOFF_0V);\n\tP(OTILEOFF_1U);\n\tP(OTILEOFF_1V);\n\tP(FASTHSCALE);\n\tP(UVSCALEV);\n#undef P\n}\n\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}