{
  "module_name": "intel_dp_mst.c",
  "hash_id": "d1ff8abd9154f6cf93fc7e3cbf37d7c997ee45d3b56dc00278511d2c1f577734",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/i915/display/intel_dp_mst.c",
  "human_readable_source": " \n\n#include <drm/drm_atomic.h>\n#include <drm/drm_atomic_helper.h>\n#include <drm/drm_edid.h>\n#include <drm/drm_probe_helper.h>\n\n#include \"i915_drv.h\"\n#include \"i915_reg.h\"\n#include \"intel_atomic.h\"\n#include \"intel_audio.h\"\n#include \"intel_connector.h\"\n#include \"intel_crtc.h\"\n#include \"intel_ddi.h\"\n#include \"intel_de.h\"\n#include \"intel_display_types.h\"\n#include \"intel_dp.h\"\n#include \"intel_dp_hdcp.h\"\n#include \"intel_dp_mst.h\"\n#include \"intel_dpio_phy.h\"\n#include \"intel_hdcp.h\"\n#include \"intel_hotplug.h\"\n#include \"skl_scaler.h\"\n\nstatic int intel_dp_mst_check_constraints(struct drm_i915_private *i915, int bpp,\n\t\t\t\t\t  const struct drm_display_mode *adjusted_mode,\n\t\t\t\t\t  struct intel_crtc_state *crtc_state,\n\t\t\t\t\t  bool dsc)\n{\n\tif (intel_dp_is_uhbr(crtc_state) && DISPLAY_VER(i915) <= 13 && dsc) {\n\t\tint output_bpp = bpp;\n\t\t \n\t\tint symbol_clock = crtc_state->port_clock / 32;\n\n\t\tif (output_bpp * adjusted_mode->crtc_clock >=\n\t\t    symbol_clock * 72) {\n\t\t\tdrm_dbg_kms(&i915->drm, \"UHBR check failed(required bw %d available %d)\\n\",\n\t\t\t\t    output_bpp * adjusted_mode->crtc_clock, symbol_clock * 72);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int intel_dp_mst_find_vcpi_slots_for_bpp(struct intel_encoder *encoder,\n\t\t\t\t\t\tstruct intel_crtc_state *crtc_state,\n\t\t\t\t\t\tint max_bpp,\n\t\t\t\t\t\tint min_bpp,\n\t\t\t\t\t\tstruct link_config_limits *limits,\n\t\t\t\t\t\tstruct drm_connector_state *conn_state,\n\t\t\t\t\t\tint step,\n\t\t\t\t\t\tbool dsc)\n{\n\tstruct drm_atomic_state *state = crtc_state->uapi.state;\n\tstruct intel_dp_mst_encoder *intel_mst = enc_to_mst(encoder);\n\tstruct intel_dp *intel_dp = &intel_mst->primary->dp;\n\tstruct drm_dp_mst_topology_state *mst_state;\n\tstruct intel_connector *connector =\n\t\tto_intel_connector(conn_state->connector);\n\tstruct drm_i915_private *i915 = to_i915(connector->base.dev);\n\tconst struct drm_display_mode *adjusted_mode =\n\t\t&crtc_state->hw.adjusted_mode;\n\tint bpp, slots = -EINVAL;\n\tint ret = 0;\n\n\tmst_state = drm_atomic_get_mst_topology_state(state, &intel_dp->mst_mgr);\n\tif (IS_ERR(mst_state))\n\t\treturn PTR_ERR(mst_state);\n\n\tcrtc_state->lane_count = limits->max_lane_count;\n\tcrtc_state->port_clock = limits->max_rate;\n\n\t\n\tif (!mst_state->pbn_div) {\n\t\tmst_state->pbn_div = drm_dp_get_vc_payload_bw(&intel_dp->mst_mgr,\n\t\t\t\t\t\t\t      crtc_state->port_clock,\n\t\t\t\t\t\t\t      crtc_state->lane_count);\n\t}\n\n\tfor (bpp = max_bpp; bpp >= min_bpp; bpp -= step) {\n\t\tdrm_dbg_kms(&i915->drm, \"Trying bpp %d\\n\", bpp);\n\n\t\tret = intel_dp_mst_check_constraints(i915, bpp, adjusted_mode, crtc_state, dsc);\n\t\tif (ret)\n\t\t\tcontinue;\n\n\t\tcrtc_state->pbn = drm_dp_calc_pbn_mode(adjusted_mode->crtc_clock,\n\t\t\t\t\t\t       bpp << 4);\n\n\t\tslots = drm_dp_atomic_find_time_slots(state, &intel_dp->mst_mgr,\n\t\t\t\t\t\t      connector->port,\n\t\t\t\t\t\t      crtc_state->pbn);\n\t\tif (slots == -EDEADLK)\n\t\t\treturn slots;\n\n\t\tif (slots >= 0) {\n\t\t\tret = drm_dp_mst_atomic_check(state);\n\t\t\t \n\t\t\tif (!ret)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\t \n\tif (ret)\n\t\tslots = ret;\n\n\tif (slots < 0) {\n\t\tdrm_dbg_kms(&i915->drm, \"failed finding vcpi slots:%d\\n\",\n\t\t\t    slots);\n\t} else {\n\t\tif (!dsc)\n\t\t\tcrtc_state->pipe_bpp = bpp;\n\t\telse\n\t\t\tcrtc_state->dsc.compressed_bpp = bpp;\n\t\tdrm_dbg_kms(&i915->drm, \"Got %d slots for pipe bpp %d dsc %d\\n\", slots, bpp, dsc);\n\t}\n\n\treturn slots;\n}\n\nstatic int intel_dp_mst_compute_link_config(struct intel_encoder *encoder,\n\t\t\t\t\t    struct intel_crtc_state *crtc_state,\n\t\t\t\t\t    struct drm_connector_state *conn_state,\n\t\t\t\t\t    struct link_config_limits *limits)\n{\n\tconst struct drm_display_mode *adjusted_mode =\n\t\t&crtc_state->hw.adjusted_mode;\n\tint slots = -EINVAL;\n\n\tslots = intel_dp_mst_find_vcpi_slots_for_bpp(encoder, crtc_state, limits->max_bpp,\n\t\t\t\t\t\t     limits->min_bpp, limits,\n\t\t\t\t\t\t     conn_state, 2 * 3, false);\n\n\tif (slots < 0)\n\t\treturn slots;\n\n\tintel_link_compute_m_n(crtc_state->pipe_bpp,\n\t\t\t       crtc_state->lane_count,\n\t\t\t       adjusted_mode->crtc_clock,\n\t\t\t       crtc_state->port_clock,\n\t\t\t       &crtc_state->dp_m_n,\n\t\t\t       crtc_state->fec_enable);\n\tcrtc_state->dp_m_n.tu = slots;\n\n\treturn 0;\n}\n\nstatic int intel_dp_dsc_mst_compute_link_config(struct intel_encoder *encoder,\n\t\t\t\t\t\tstruct intel_crtc_state *crtc_state,\n\t\t\t\t\t\tstruct drm_connector_state *conn_state,\n\t\t\t\t\t\tstruct link_config_limits *limits)\n{\n\tstruct intel_dp_mst_encoder *intel_mst = enc_to_mst(encoder);\n\tstruct intel_dp *intel_dp = &intel_mst->primary->dp;\n\tstruct intel_connector *connector =\n\t\tto_intel_connector(conn_state->connector);\n\tstruct drm_i915_private *i915 = to_i915(connector->base.dev);\n\tconst struct drm_display_mode *adjusted_mode =\n\t\t&crtc_state->hw.adjusted_mode;\n\tint slots = -EINVAL;\n\tint i, num_bpc;\n\tu8 dsc_bpc[3] = {0};\n\tint min_bpp, max_bpp, sink_min_bpp, sink_max_bpp;\n\tu8 dsc_max_bpc;\n\tbool need_timeslot_recalc = false;\n\tu32 last_compressed_bpp;\n\n\t \n\tif (DISPLAY_VER(i915) >= 12)\n\t\tdsc_max_bpc = min_t(u8, 12, conn_state->max_requested_bpc);\n\telse\n\t\tdsc_max_bpc = min_t(u8, 10, conn_state->max_requested_bpc);\n\n\tmax_bpp = min_t(u8, dsc_max_bpc * 3, limits->max_bpp);\n\tmin_bpp = limits->min_bpp;\n\n\tnum_bpc = drm_dp_dsc_sink_supported_input_bpcs(intel_dp->dsc_dpcd,\n\t\t\t\t\t\t       dsc_bpc);\n\n\tdrm_dbg_kms(&i915->drm, \"DSC Source supported min bpp %d max bpp %d\\n\",\n\t\t    min_bpp, max_bpp);\n\n\tsink_max_bpp = dsc_bpc[0] * 3;\n\tsink_min_bpp = sink_max_bpp;\n\n\tfor (i = 1; i < num_bpc; i++) {\n\t\tif (sink_min_bpp > dsc_bpc[i] * 3)\n\t\t\tsink_min_bpp = dsc_bpc[i] * 3;\n\t\tif (sink_max_bpp < dsc_bpc[i] * 3)\n\t\t\tsink_max_bpp = dsc_bpc[i] * 3;\n\t}\n\n\tdrm_dbg_kms(&i915->drm, \"DSC Sink supported min bpp %d max bpp %d\\n\",\n\t\t    sink_min_bpp, sink_max_bpp);\n\n\tif (min_bpp < sink_min_bpp)\n\t\tmin_bpp = sink_min_bpp;\n\n\tif (max_bpp > sink_max_bpp)\n\t\tmax_bpp = sink_max_bpp;\n\n\tslots = intel_dp_mst_find_vcpi_slots_for_bpp(encoder, crtc_state, max_bpp,\n\t\t\t\t\t\t     min_bpp, limits,\n\t\t\t\t\t\t     conn_state, 2 * 3, true);\n\n\tif (slots < 0)\n\t\treturn slots;\n\n\tlast_compressed_bpp = crtc_state->dsc.compressed_bpp;\n\n\tcrtc_state->dsc.compressed_bpp = intel_dp_dsc_nearest_valid_bpp(i915,\n\t\t\t\t\t\t\t\t\tlast_compressed_bpp,\n\t\t\t\t\t\t\t\t\tcrtc_state->pipe_bpp);\n\n\tif (crtc_state->dsc.compressed_bpp != last_compressed_bpp)\n\t\tneed_timeslot_recalc = true;\n\n\t \n\tif (need_timeslot_recalc) {\n\t\tslots = intel_dp_mst_find_vcpi_slots_for_bpp(encoder, crtc_state,\n\t\t\t\t\t\t\t     crtc_state->dsc.compressed_bpp,\n\t\t\t\t\t\t\t     crtc_state->dsc.compressed_bpp,\n\t\t\t\t\t\t\t     limits, conn_state, 2 * 3, true);\n\t\tif (slots < 0)\n\t\t\treturn slots;\n\t}\n\n\tintel_link_compute_m_n(crtc_state->dsc.compressed_bpp,\n\t\t\t       crtc_state->lane_count,\n\t\t\t       adjusted_mode->crtc_clock,\n\t\t\t       crtc_state->port_clock,\n\t\t\t       &crtc_state->dp_m_n,\n\t\t\t       crtc_state->fec_enable);\n\tcrtc_state->dp_m_n.tu = slots;\n\n\treturn 0;\n}\nstatic int intel_dp_mst_update_slots(struct intel_encoder *encoder,\n\t\t\t\t     struct intel_crtc_state *crtc_state,\n\t\t\t\t     struct drm_connector_state *conn_state)\n{\n\tstruct drm_i915_private *i915 = to_i915(encoder->base.dev);\n\tstruct intel_dp_mst_encoder *intel_mst = enc_to_mst(encoder);\n\tstruct intel_dp *intel_dp = &intel_mst->primary->dp;\n\tstruct drm_dp_mst_topology_mgr *mgr = &intel_dp->mst_mgr;\n\tstruct drm_dp_mst_topology_state *topology_state;\n\tu8 link_coding_cap = intel_dp_is_uhbr(crtc_state) ?\n\t\tDP_CAP_ANSI_128B132B : DP_CAP_ANSI_8B10B;\n\n\ttopology_state = drm_atomic_get_mst_topology_state(conn_state->state, mgr);\n\tif (IS_ERR(topology_state)) {\n\t\tdrm_dbg_kms(&i915->drm, \"slot update failed\\n\");\n\t\treturn PTR_ERR(topology_state);\n\t}\n\n\tdrm_dp_mst_update_slots(topology_state, link_coding_cap);\n\n\treturn 0;\n}\n\nstatic bool intel_dp_mst_has_audio(const struct drm_connector_state *conn_state)\n{\n\tconst struct intel_digital_connector_state *intel_conn_state =\n\t\tto_intel_digital_connector_state(conn_state);\n\tstruct intel_connector *connector =\n\t\tto_intel_connector(conn_state->connector);\n\n\tif (intel_conn_state->force_audio == HDMI_AUDIO_AUTO)\n\t\treturn connector->base.display_info.has_audio;\n\telse\n\t\treturn intel_conn_state->force_audio == HDMI_AUDIO_ON;\n}\n\nstatic int intel_dp_mst_compute_config(struct intel_encoder *encoder,\n\t\t\t\t       struct intel_crtc_state *pipe_config,\n\t\t\t\t       struct drm_connector_state *conn_state)\n{\n\tstruct drm_i915_private *dev_priv = to_i915(encoder->base.dev);\n\tstruct intel_dp_mst_encoder *intel_mst = enc_to_mst(encoder);\n\tstruct intel_dp *intel_dp = &intel_mst->primary->dp;\n\tconst struct drm_display_mode *adjusted_mode =\n\t\t&pipe_config->hw.adjusted_mode;\n\tstruct link_config_limits limits;\n\tint ret;\n\n\tif (adjusted_mode->flags & DRM_MODE_FLAG_DBLSCAN)\n\t\treturn -EINVAL;\n\n\tpipe_config->sink_format = INTEL_OUTPUT_FORMAT_RGB;\n\tpipe_config->output_format = INTEL_OUTPUT_FORMAT_RGB;\n\tpipe_config->has_pch_encoder = false;\n\n\tpipe_config->has_audio =\n\t\tintel_dp_mst_has_audio(conn_state) &&\n\t\tintel_audio_compute_config(encoder, pipe_config, conn_state);\n\n\t \n\tlimits.min_rate =\n\tlimits.max_rate = intel_dp_max_link_rate(intel_dp);\n\n\tlimits.min_lane_count =\n\tlimits.max_lane_count = intel_dp_max_lane_count(intel_dp);\n\n\tlimits.min_bpp = intel_dp_min_bpp(pipe_config->output_format);\n\t \n\tlimits.max_bpp = min(pipe_config->pipe_bpp, 24);\n\n\tintel_dp_adjust_compliance_config(intel_dp, pipe_config, &limits);\n\n\tret = intel_dp_mst_compute_link_config(encoder, pipe_config,\n\t\t\t\t\t       conn_state, &limits);\n\n\tif (ret == -EDEADLK)\n\t\treturn ret;\n\n\t \n\tdrm_dbg_kms(&dev_priv->drm, \"Force DSC en = %d\\n\", intel_dp->force_dsc_en);\n\tif (ret || intel_dp->force_dsc_en) {\n\t\t \n\t\tdrm_dbg_kms(&dev_priv->drm, \"Trying to find VCPI slots in DSC mode\\n\");\n\n\t\tret = intel_dp_dsc_mst_compute_link_config(encoder, pipe_config,\n\t\t\t\t\t\t\t   conn_state, &limits);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tret = intel_dp_dsc_compute_config(intel_dp, pipe_config,\n\t\t\t\t\t\t  conn_state, &limits,\n\t\t\t\t\t\t  pipe_config->dp_m_n.tu, false);\n\t}\n\n\tif (ret)\n\t\treturn ret;\n\n\tret = intel_dp_mst_update_slots(encoder, pipe_config, conn_state);\n\tif (ret)\n\t\treturn ret;\n\n\tpipe_config->limited_color_range =\n\t\tintel_dp_limited_color_range(pipe_config, conn_state);\n\n\tif (IS_GEMINILAKE(dev_priv) || IS_BROXTON(dev_priv))\n\t\tpipe_config->lane_lat_optim_mask =\n\t\t\tbxt_ddi_phy_calc_lane_lat_optim_mask(pipe_config->lane_count);\n\n\tintel_ddi_compute_min_voltage_level(dev_priv, pipe_config);\n\n\treturn 0;\n}\n\n \nstatic unsigned int\nintel_dp_mst_transcoder_mask(struct intel_atomic_state *state,\n\t\t\t     struct intel_dp *mst_port)\n{\n\tstruct drm_i915_private *dev_priv = to_i915(state->base.dev);\n\tconst struct intel_digital_connector_state *conn_state;\n\tstruct intel_connector *connector;\n\tu8 transcoders = 0;\n\tint i;\n\n\tif (DISPLAY_VER(dev_priv) < 12)\n\t\treturn 0;\n\n\tfor_each_new_intel_connector_in_state(state, connector, conn_state, i) {\n\t\tconst struct intel_crtc_state *crtc_state;\n\t\tstruct intel_crtc *crtc;\n\n\t\tif (connector->mst_port != mst_port || !conn_state->base.crtc)\n\t\t\tcontinue;\n\n\t\tcrtc = to_intel_crtc(conn_state->base.crtc);\n\t\tcrtc_state = intel_atomic_get_new_crtc_state(state, crtc);\n\n\t\tif (!crtc_state->hw.active)\n\t\t\tcontinue;\n\n\t\ttranscoders |= BIT(crtc_state->cpu_transcoder);\n\t}\n\n\treturn transcoders;\n}\n\nstatic int intel_dp_mst_compute_config_late(struct intel_encoder *encoder,\n\t\t\t\t\t    struct intel_crtc_state *crtc_state,\n\t\t\t\t\t    struct drm_connector_state *conn_state)\n{\n\tstruct intel_atomic_state *state = to_intel_atomic_state(conn_state->state);\n\tstruct intel_dp_mst_encoder *intel_mst = enc_to_mst(encoder);\n\tstruct intel_dp *intel_dp = &intel_mst->primary->dp;\n\n\t \n\tcrtc_state->mst_master_transcoder =\n\t\tffs(intel_dp_mst_transcoder_mask(state, intel_dp)) - 1;\n\n\treturn 0;\n}\n\n \nstatic int\nintel_dp_mst_atomic_master_trans_check(struct intel_connector *connector,\n\t\t\t\t       struct intel_atomic_state *state)\n{\n\tstruct drm_i915_private *dev_priv = to_i915(state->base.dev);\n\tstruct drm_connector_list_iter connector_list_iter;\n\tstruct intel_connector *connector_iter;\n\tint ret = 0;\n\n\tif (DISPLAY_VER(dev_priv) < 12)\n\t\treturn  0;\n\n\tif (!intel_connector_needs_modeset(state, &connector->base))\n\t\treturn 0;\n\n\tdrm_connector_list_iter_begin(&dev_priv->drm, &connector_list_iter);\n\tfor_each_intel_connector_iter(connector_iter, &connector_list_iter) {\n\t\tstruct intel_digital_connector_state *conn_iter_state;\n\t\tstruct intel_crtc_state *crtc_state;\n\t\tstruct intel_crtc *crtc;\n\n\t\tif (connector_iter->mst_port != connector->mst_port ||\n\t\t    connector_iter == connector)\n\t\t\tcontinue;\n\n\t\tconn_iter_state = intel_atomic_get_digital_connector_state(state,\n\t\t\t\t\t\t\t\t\t   connector_iter);\n\t\tif (IS_ERR(conn_iter_state)) {\n\t\t\tret = PTR_ERR(conn_iter_state);\n\t\t\tbreak;\n\t\t}\n\n\t\tif (!conn_iter_state->base.crtc)\n\t\t\tcontinue;\n\n\t\tcrtc = to_intel_crtc(conn_iter_state->base.crtc);\n\t\tcrtc_state = intel_atomic_get_crtc_state(&state->base, crtc);\n\t\tif (IS_ERR(crtc_state)) {\n\t\t\tret = PTR_ERR(crtc_state);\n\t\t\tbreak;\n\t\t}\n\n\t\tret = drm_atomic_add_affected_planes(&state->base, &crtc->base);\n\t\tif (ret)\n\t\t\tbreak;\n\t\tcrtc_state->uapi.mode_changed = true;\n\t}\n\tdrm_connector_list_iter_end(&connector_list_iter);\n\n\treturn ret;\n}\n\nstatic int\nintel_dp_mst_atomic_check(struct drm_connector *connector,\n\t\t\t  struct drm_atomic_state *_state)\n{\n\tstruct intel_atomic_state *state = to_intel_atomic_state(_state);\n\tstruct intel_connector *intel_connector =\n\t\tto_intel_connector(connector);\n\tint ret;\n\n\tret = intel_digital_connector_atomic_check(connector, &state->base);\n\tif (ret)\n\t\treturn ret;\n\n\tret = intel_dp_mst_atomic_master_trans_check(intel_connector, state);\n\tif (ret)\n\t\treturn ret;\n\n\treturn drm_dp_atomic_release_time_slots(&state->base,\n\t\t\t\t\t\t&intel_connector->mst_port->mst_mgr,\n\t\t\t\t\t\tintel_connector->port);\n}\n\nstatic void clear_act_sent(struct intel_encoder *encoder,\n\t\t\t   const struct intel_crtc_state *crtc_state)\n{\n\tstruct drm_i915_private *i915 = to_i915(encoder->base.dev);\n\n\tintel_de_write(i915, dp_tp_status_reg(encoder, crtc_state),\n\t\t       DP_TP_STATUS_ACT_SENT);\n}\n\nstatic void wait_for_act_sent(struct intel_encoder *encoder,\n\t\t\t      const struct intel_crtc_state *crtc_state)\n{\n\tstruct drm_i915_private *i915 = to_i915(encoder->base.dev);\n\tstruct intel_dp_mst_encoder *intel_mst = enc_to_mst(encoder);\n\tstruct intel_dp *intel_dp = &intel_mst->primary->dp;\n\n\tif (intel_de_wait_for_set(i915, dp_tp_status_reg(encoder, crtc_state),\n\t\t\t\t  DP_TP_STATUS_ACT_SENT, 1))\n\t\tdrm_err(&i915->drm, \"Timed out waiting for ACT sent\\n\");\n\n\tdrm_dp_check_act_status(&intel_dp->mst_mgr);\n}\n\nstatic void intel_mst_disable_dp(struct intel_atomic_state *state,\n\t\t\t\t struct intel_encoder *encoder,\n\t\t\t\t const struct intel_crtc_state *old_crtc_state,\n\t\t\t\t const struct drm_connector_state *old_conn_state)\n{\n\tstruct intel_dp_mst_encoder *intel_mst = enc_to_mst(encoder);\n\tstruct intel_digital_port *dig_port = intel_mst->primary;\n\tstruct intel_dp *intel_dp = &dig_port->dp;\n\tstruct intel_connector *connector =\n\t\tto_intel_connector(old_conn_state->connector);\n\tstruct drm_dp_mst_topology_state *old_mst_state =\n\t\tdrm_atomic_get_old_mst_topology_state(&state->base, &intel_dp->mst_mgr);\n\tstruct drm_dp_mst_topology_state *new_mst_state =\n\t\tdrm_atomic_get_new_mst_topology_state(&state->base, &intel_dp->mst_mgr);\n\tconst struct drm_dp_mst_atomic_payload *old_payload =\n\t\tdrm_atomic_get_mst_payload_state(old_mst_state, connector->port);\n\tstruct drm_dp_mst_atomic_payload *new_payload =\n\t\tdrm_atomic_get_mst_payload_state(new_mst_state, connector->port);\n\tstruct drm_i915_private *i915 = to_i915(connector->base.dev);\n\n\tdrm_dbg_kms(&i915->drm, \"active links %d\\n\",\n\t\t    intel_dp->active_mst_links);\n\n\tintel_hdcp_disable(intel_mst->connector);\n\n\tdrm_dp_remove_payload(&intel_dp->mst_mgr, new_mst_state,\n\t\t\t      old_payload, new_payload);\n\n\tintel_audio_codec_disable(encoder, old_crtc_state, old_conn_state);\n}\n\nstatic void intel_mst_post_disable_dp(struct intel_atomic_state *state,\n\t\t\t\t      struct intel_encoder *encoder,\n\t\t\t\t      const struct intel_crtc_state *old_crtc_state,\n\t\t\t\t      const struct drm_connector_state *old_conn_state)\n{\n\tstruct intel_dp_mst_encoder *intel_mst = enc_to_mst(encoder);\n\tstruct intel_digital_port *dig_port = intel_mst->primary;\n\tstruct intel_dp *intel_dp = &dig_port->dp;\n\tstruct intel_connector *connector =\n\t\tto_intel_connector(old_conn_state->connector);\n\tstruct drm_i915_private *dev_priv = to_i915(connector->base.dev);\n\tbool last_mst_stream;\n\n\tintel_dp->active_mst_links--;\n\tlast_mst_stream = intel_dp->active_mst_links == 0;\n\tdrm_WARN_ON(&dev_priv->drm,\n\t\t    DISPLAY_VER(dev_priv) >= 12 && last_mst_stream &&\n\t\t    !intel_dp_mst_is_master_trans(old_crtc_state));\n\n\tintel_crtc_vblank_off(old_crtc_state);\n\n\tintel_disable_transcoder(old_crtc_state);\n\n\tclear_act_sent(encoder, old_crtc_state);\n\n\tintel_de_rmw(dev_priv, TRANS_DDI_FUNC_CTL(old_crtc_state->cpu_transcoder),\n\t\t     TRANS_DDI_DP_VC_PAYLOAD_ALLOC, 0);\n\n\twait_for_act_sent(encoder, old_crtc_state);\n\n\tintel_ddi_disable_transcoder_func(old_crtc_state);\n\n\tif (DISPLAY_VER(dev_priv) >= 9)\n\t\tskl_scaler_disable(old_crtc_state);\n\telse\n\t\tilk_pfit_disable(old_crtc_state);\n\n\t \n\tdrm_dp_send_power_updown_phy(&intel_dp->mst_mgr, connector->port,\n\t\t\t\t     false);\n\n\t \n\tif (last_mst_stream)\n\t\tintel_dp_set_infoframes(&dig_port->base, false,\n\t\t\t\t\told_crtc_state, NULL);\n\t \n\tif (DISPLAY_VER(dev_priv) < 12 || !last_mst_stream)\n\t\tintel_ddi_disable_transcoder_clock(old_crtc_state);\n\n\n\tintel_mst->connector = NULL;\n\tif (last_mst_stream)\n\t\tdig_port->base.post_disable(state, &dig_port->base,\n\t\t\t\t\t\t  old_crtc_state, NULL);\n\n\tdrm_dbg_kms(&dev_priv->drm, \"active links %d\\n\",\n\t\t    intel_dp->active_mst_links);\n}\n\nstatic void intel_mst_post_pll_disable_dp(struct intel_atomic_state *state,\n\t\t\t\t\t  struct intel_encoder *encoder,\n\t\t\t\t\t  const struct intel_crtc_state *old_crtc_state,\n\t\t\t\t\t  const struct drm_connector_state *old_conn_state)\n{\n\tstruct intel_dp_mst_encoder *intel_mst = enc_to_mst(encoder);\n\tstruct intel_digital_port *dig_port = intel_mst->primary;\n\tstruct intel_dp *intel_dp = &dig_port->dp;\n\n\tif (intel_dp->active_mst_links == 0 &&\n\t    dig_port->base.post_pll_disable)\n\t\tdig_port->base.post_pll_disable(state, encoder, old_crtc_state, old_conn_state);\n}\n\nstatic void intel_mst_pre_pll_enable_dp(struct intel_atomic_state *state,\n\t\t\t\t\tstruct intel_encoder *encoder,\n\t\t\t\t\tconst struct intel_crtc_state *pipe_config,\n\t\t\t\t\tconst struct drm_connector_state *conn_state)\n{\n\tstruct intel_dp_mst_encoder *intel_mst = enc_to_mst(encoder);\n\tstruct intel_digital_port *dig_port = intel_mst->primary;\n\tstruct intel_dp *intel_dp = &dig_port->dp;\n\n\tif (intel_dp->active_mst_links == 0)\n\t\tdig_port->base.pre_pll_enable(state, &dig_port->base,\n\t\t\t\t\t\t    pipe_config, NULL);\n\telse\n\t\t \n\t\tintel_ddi_update_active_dpll(state, &dig_port->base,\n\t\t\t\t\t     to_intel_crtc(pipe_config->uapi.crtc));\n}\n\nstatic void intel_mst_pre_enable_dp(struct intel_atomic_state *state,\n\t\t\t\t    struct intel_encoder *encoder,\n\t\t\t\t    const struct intel_crtc_state *pipe_config,\n\t\t\t\t    const struct drm_connector_state *conn_state)\n{\n\tstruct intel_dp_mst_encoder *intel_mst = enc_to_mst(encoder);\n\tstruct intel_digital_port *dig_port = intel_mst->primary;\n\tstruct intel_dp *intel_dp = &dig_port->dp;\n\tstruct drm_i915_private *dev_priv = to_i915(encoder->base.dev);\n\tstruct intel_connector *connector =\n\t\tto_intel_connector(conn_state->connector);\n\tstruct drm_dp_mst_topology_state *mst_state =\n\t\tdrm_atomic_get_new_mst_topology_state(&state->base, &intel_dp->mst_mgr);\n\tint ret;\n\tbool first_mst_stream;\n\n\t \n\tconnector->encoder = encoder;\n\tintel_mst->connector = connector;\n\tfirst_mst_stream = intel_dp->active_mst_links == 0;\n\tdrm_WARN_ON(&dev_priv->drm,\n\t\t    DISPLAY_VER(dev_priv) >= 12 && first_mst_stream &&\n\t\t    !intel_dp_mst_is_master_trans(pipe_config));\n\n\tdrm_dbg_kms(&dev_priv->drm, \"active links %d\\n\",\n\t\t    intel_dp->active_mst_links);\n\n\tif (first_mst_stream)\n\t\tintel_dp_set_power(intel_dp, DP_SET_POWER_D0);\n\n\tdrm_dp_send_power_updown_phy(&intel_dp->mst_mgr, connector->port, true);\n\n\tif (first_mst_stream)\n\t\tdig_port->base.pre_enable(state, &dig_port->base,\n\t\t\t\t\t\tpipe_config, NULL);\n\n\tintel_dp->active_mst_links++;\n\n\tret = drm_dp_add_payload_part1(&intel_dp->mst_mgr, mst_state,\n\t\t\t\t       drm_atomic_get_mst_payload_state(mst_state, connector->port));\n\tif (ret < 0)\n\t\tdrm_err(&dev_priv->drm, \"Failed to create MST payload for %s: %d\\n\",\n\t\t\tconnector->base.name, ret);\n\n\t \n\tif (DISPLAY_VER(dev_priv) < 12 || !first_mst_stream)\n\t\tintel_ddi_enable_transcoder_clock(encoder, pipe_config);\n\n\tintel_ddi_set_dp_msa(pipe_config, conn_state);\n}\n\nstatic void intel_mst_enable_dp(struct intel_atomic_state *state,\n\t\t\t\tstruct intel_encoder *encoder,\n\t\t\t\tconst struct intel_crtc_state *pipe_config,\n\t\t\t\tconst struct drm_connector_state *conn_state)\n{\n\tstruct intel_dp_mst_encoder *intel_mst = enc_to_mst(encoder);\n\tstruct intel_digital_port *dig_port = intel_mst->primary;\n\tstruct intel_dp *intel_dp = &dig_port->dp;\n\tstruct intel_connector *connector = to_intel_connector(conn_state->connector);\n\tstruct drm_i915_private *dev_priv = to_i915(encoder->base.dev);\n\tstruct drm_dp_mst_topology_state *mst_state =\n\t\tdrm_atomic_get_new_mst_topology_state(&state->base, &intel_dp->mst_mgr);\n\tenum transcoder trans = pipe_config->cpu_transcoder;\n\n\tdrm_WARN_ON(&dev_priv->drm, pipe_config->has_pch_encoder);\n\n\tclear_act_sent(encoder, pipe_config);\n\n\tif (intel_dp_is_uhbr(pipe_config)) {\n\t\tconst struct drm_display_mode *adjusted_mode =\n\t\t\t&pipe_config->hw.adjusted_mode;\n\t\tu64 crtc_clock_hz = KHz(adjusted_mode->crtc_clock);\n\n\t\tintel_de_write(dev_priv, TRANS_DP2_VFREQHIGH(pipe_config->cpu_transcoder),\n\t\t\t       TRANS_DP2_VFREQ_PIXEL_CLOCK(crtc_clock_hz >> 24));\n\t\tintel_de_write(dev_priv, TRANS_DP2_VFREQLOW(pipe_config->cpu_transcoder),\n\t\t\t       TRANS_DP2_VFREQ_PIXEL_CLOCK(crtc_clock_hz & 0xffffff));\n\t}\n\n\tintel_ddi_enable_transcoder_func(encoder, pipe_config);\n\n\tintel_de_rmw(dev_priv, TRANS_DDI_FUNC_CTL(trans), 0,\n\t\t     TRANS_DDI_DP_VC_PAYLOAD_ALLOC);\n\n\tdrm_dbg_kms(&dev_priv->drm, \"active links %d\\n\",\n\t\t    intel_dp->active_mst_links);\n\n\twait_for_act_sent(encoder, pipe_config);\n\n\tdrm_dp_add_payload_part2(&intel_dp->mst_mgr, &state->base,\n\t\t\t\t drm_atomic_get_mst_payload_state(mst_state, connector->port));\n\n\tif (DISPLAY_VER(dev_priv) >= 14 && pipe_config->fec_enable)\n\t\tintel_de_rmw(dev_priv, MTL_CHICKEN_TRANS(trans), 0,\n\t\t\t     FECSTALL_DIS_DPTSTREAM_DPTTG);\n\telse if (DISPLAY_VER(dev_priv) >= 12 && pipe_config->fec_enable)\n\t\tintel_de_rmw(dev_priv, CHICKEN_TRANS(trans), 0,\n\t\t\t     FECSTALL_DIS_DPTSTREAM_DPTTG);\n\n\tintel_enable_transcoder(pipe_config);\n\n\tintel_crtc_vblank_on(pipe_config);\n\n\tintel_audio_codec_enable(encoder, pipe_config, conn_state);\n\n\t \n\tif (conn_state->content_protection ==\n\t    DRM_MODE_CONTENT_PROTECTION_DESIRED)\n\t\tintel_hdcp_enable(state, encoder, pipe_config, conn_state);\n}\n\nstatic bool intel_dp_mst_enc_get_hw_state(struct intel_encoder *encoder,\n\t\t\t\t      enum pipe *pipe)\n{\n\tstruct intel_dp_mst_encoder *intel_mst = enc_to_mst(encoder);\n\t*pipe = intel_mst->pipe;\n\tif (intel_mst->connector)\n\t\treturn true;\n\treturn false;\n}\n\nstatic void intel_dp_mst_enc_get_config(struct intel_encoder *encoder,\n\t\t\t\t\tstruct intel_crtc_state *pipe_config)\n{\n\tstruct intel_dp_mst_encoder *intel_mst = enc_to_mst(encoder);\n\tstruct intel_digital_port *dig_port = intel_mst->primary;\n\n\tdig_port->base.get_config(&dig_port->base, pipe_config);\n}\n\nstatic bool intel_dp_mst_initial_fastset_check(struct intel_encoder *encoder,\n\t\t\t\t\t       struct intel_crtc_state *crtc_state)\n{\n\tstruct intel_dp_mst_encoder *intel_mst = enc_to_mst(encoder);\n\tstruct intel_digital_port *dig_port = intel_mst->primary;\n\n\treturn intel_dp_initial_fastset_check(&dig_port->base, crtc_state);\n}\n\nstatic int intel_dp_mst_get_ddc_modes(struct drm_connector *connector)\n{\n\tstruct intel_connector *intel_connector = to_intel_connector(connector);\n\tstruct intel_dp *intel_dp = intel_connector->mst_port;\n\tconst struct drm_edid *drm_edid;\n\tint ret;\n\n\tif (drm_connector_is_unregistered(connector))\n\t\treturn intel_connector_update_modes(connector, NULL);\n\n\tdrm_edid = drm_dp_mst_edid_read(connector, &intel_dp->mst_mgr, intel_connector->port);\n\n\tret = intel_connector_update_modes(connector, drm_edid);\n\n\tdrm_edid_free(drm_edid);\n\n\treturn ret;\n}\n\nstatic int\nintel_dp_mst_connector_late_register(struct drm_connector *connector)\n{\n\tstruct intel_connector *intel_connector = to_intel_connector(connector);\n\tint ret;\n\n\tret = drm_dp_mst_connector_late_register(connector,\n\t\t\t\t\t\t intel_connector->port);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = intel_connector_register(connector);\n\tif (ret < 0)\n\t\tdrm_dp_mst_connector_early_unregister(connector,\n\t\t\t\t\t\t      intel_connector->port);\n\n\treturn ret;\n}\n\nstatic void\nintel_dp_mst_connector_early_unregister(struct drm_connector *connector)\n{\n\tstruct intel_connector *intel_connector = to_intel_connector(connector);\n\n\tintel_connector_unregister(connector);\n\tdrm_dp_mst_connector_early_unregister(connector,\n\t\t\t\t\t      intel_connector->port);\n}\n\nstatic const struct drm_connector_funcs intel_dp_mst_connector_funcs = {\n\t.fill_modes = drm_helper_probe_single_connector_modes,\n\t.atomic_get_property = intel_digital_connector_atomic_get_property,\n\t.atomic_set_property = intel_digital_connector_atomic_set_property,\n\t.late_register = intel_dp_mst_connector_late_register,\n\t.early_unregister = intel_dp_mst_connector_early_unregister,\n\t.destroy = intel_connector_destroy,\n\t.atomic_destroy_state = drm_atomic_helper_connector_destroy_state,\n\t.atomic_duplicate_state = intel_digital_connector_duplicate_state,\n};\n\nstatic int intel_dp_mst_get_modes(struct drm_connector *connector)\n{\n\treturn intel_dp_mst_get_ddc_modes(connector);\n}\n\nstatic int\nintel_dp_mst_mode_valid_ctx(struct drm_connector *connector,\n\t\t\t    struct drm_display_mode *mode,\n\t\t\t    struct drm_modeset_acquire_ctx *ctx,\n\t\t\t    enum drm_mode_status *status)\n{\n\tstruct drm_i915_private *dev_priv = to_i915(connector->dev);\n\tstruct intel_connector *intel_connector = to_intel_connector(connector);\n\tstruct intel_dp *intel_dp = intel_connector->mst_port;\n\tstruct drm_dp_mst_topology_mgr *mgr = &intel_dp->mst_mgr;\n\tstruct drm_dp_mst_port *port = intel_connector->port;\n\tconst int min_bpp = 18;\n\tint max_dotclk = to_i915(connector->dev)->max_dotclk_freq;\n\tint max_rate, mode_rate, max_lanes, max_link_clock;\n\tint ret;\n\tbool dsc = false, bigjoiner = false;\n\tu16 dsc_max_output_bpp = 0;\n\tu8 dsc_slice_count = 0;\n\tint target_clock = mode->clock;\n\n\tif (drm_connector_is_unregistered(connector)) {\n\t\t*status = MODE_ERROR;\n\t\treturn 0;\n\t}\n\n\t*status = intel_cpu_transcoder_mode_valid(dev_priv, mode);\n\tif (*status != MODE_OK)\n\t\treturn 0;\n\n\tif (mode->flags & DRM_MODE_FLAG_DBLSCAN) {\n\t\t*status = MODE_NO_DBLESCAN;\n\t\treturn 0;\n\t}\n\n\tmax_link_clock = intel_dp_max_link_rate(intel_dp);\n\tmax_lanes = intel_dp_max_lane_count(intel_dp);\n\n\tmax_rate = intel_dp_max_data_rate(max_link_clock, max_lanes);\n\tmode_rate = intel_dp_link_required(mode->clock, min_bpp);\n\n\tret = drm_modeset_lock(&mgr->base.lock, ctx);\n\tif (ret)\n\t\treturn ret;\n\n\tif (mode_rate > max_rate || mode->clock > max_dotclk ||\n\t    drm_dp_calc_pbn_mode(mode->clock, min_bpp << 4) > port->full_pbn) {\n\t\t*status = MODE_CLOCK_HIGH;\n\t\treturn 0;\n\t}\n\n\tif (mode->clock < 10000) {\n\t\t*status = MODE_CLOCK_LOW;\n\t\treturn 0;\n\t}\n\n\tif (mode->flags & DRM_MODE_FLAG_DBLCLK) {\n\t\t*status = MODE_H_ILLEGAL;\n\t\treturn 0;\n\t}\n\n\tif (intel_dp_need_bigjoiner(intel_dp, mode->hdisplay, target_clock)) {\n\t\tbigjoiner = true;\n\t\tmax_dotclk *= 2;\n\n\t\t \n\t\t*status = MODE_CLOCK_HIGH;\n\t\treturn 0;\n\t}\n\n\tif (DISPLAY_VER(dev_priv) >= 10 &&\n\t    drm_dp_sink_supports_dsc(intel_dp->dsc_dpcd)) {\n\t\t \n\t\tint pipe_bpp = intel_dp_dsc_compute_bpp(intel_dp, U8_MAX);\n\n\t\tif (drm_dp_sink_supports_fec(intel_dp->fec_capable)) {\n\t\t\tdsc_max_output_bpp =\n\t\t\t\tintel_dp_dsc_get_output_bpp(dev_priv,\n\t\t\t\t\t\t\t    max_link_clock,\n\t\t\t\t\t\t\t    max_lanes,\n\t\t\t\t\t\t\t    target_clock,\n\t\t\t\t\t\t\t    mode->hdisplay,\n\t\t\t\t\t\t\t    bigjoiner,\n\t\t\t\t\t\t\t    pipe_bpp, 64) >> 4;\n\t\t\tdsc_slice_count =\n\t\t\t\tintel_dp_dsc_get_slice_count(intel_dp,\n\t\t\t\t\t\t\t     target_clock,\n\t\t\t\t\t\t\t     mode->hdisplay,\n\t\t\t\t\t\t\t     bigjoiner);\n\t\t}\n\n\t\tdsc = dsc_max_output_bpp && dsc_slice_count;\n\t}\n\n\t \n\tif (DISPLAY_VER(dev_priv) < 13 && bigjoiner && !dsc) {\n\t\t*status = MODE_CLOCK_HIGH;\n\t\treturn 0;\n\t}\n\n\tif (mode_rate > max_rate && !dsc) {\n\t\t*status = MODE_CLOCK_HIGH;\n\t\treturn 0;\n\t}\n\n\t*status = intel_mode_valid_max_plane_size(dev_priv, mode, false);\n\treturn 0;\n}\n\nstatic struct drm_encoder *intel_mst_atomic_best_encoder(struct drm_connector *connector,\n\t\t\t\t\t\t\t struct drm_atomic_state *state)\n{\n\tstruct drm_connector_state *connector_state = drm_atomic_get_new_connector_state(state,\n\t\t\t\t\t\t\t\t\t\t\t connector);\n\tstruct intel_connector *intel_connector = to_intel_connector(connector);\n\tstruct intel_dp *intel_dp = intel_connector->mst_port;\n\tstruct intel_crtc *crtc = to_intel_crtc(connector_state->crtc);\n\n\treturn &intel_dp->mst_encoders[crtc->pipe]->base.base;\n}\n\nstatic int\nintel_dp_mst_detect(struct drm_connector *connector,\n\t\t    struct drm_modeset_acquire_ctx *ctx, bool force)\n{\n\tstruct drm_i915_private *i915 = to_i915(connector->dev);\n\tstruct intel_connector *intel_connector = to_intel_connector(connector);\n\tstruct intel_dp *intel_dp = intel_connector->mst_port;\n\n\tif (!INTEL_DISPLAY_ENABLED(i915))\n\t\treturn connector_status_disconnected;\n\n\tif (drm_connector_is_unregistered(connector))\n\t\treturn connector_status_disconnected;\n\n\treturn drm_dp_mst_detect_port(connector, ctx, &intel_dp->mst_mgr,\n\t\t\t\t      intel_connector->port);\n}\n\nstatic const struct drm_connector_helper_funcs intel_dp_mst_connector_helper_funcs = {\n\t.get_modes = intel_dp_mst_get_modes,\n\t.mode_valid_ctx = intel_dp_mst_mode_valid_ctx,\n\t.atomic_best_encoder = intel_mst_atomic_best_encoder,\n\t.atomic_check = intel_dp_mst_atomic_check,\n\t.detect_ctx = intel_dp_mst_detect,\n};\n\nstatic void intel_dp_mst_encoder_destroy(struct drm_encoder *encoder)\n{\n\tstruct intel_dp_mst_encoder *intel_mst = enc_to_mst(to_intel_encoder(encoder));\n\n\tdrm_encoder_cleanup(encoder);\n\tkfree(intel_mst);\n}\n\nstatic const struct drm_encoder_funcs intel_dp_mst_enc_funcs = {\n\t.destroy = intel_dp_mst_encoder_destroy,\n};\n\nstatic bool intel_dp_mst_get_hw_state(struct intel_connector *connector)\n{\n\tif (intel_attached_encoder(connector) && connector->base.state->crtc) {\n\t\tenum pipe pipe;\n\t\tif (!intel_attached_encoder(connector)->get_hw_state(intel_attached_encoder(connector), &pipe))\n\t\t\treturn false;\n\t\treturn true;\n\t}\n\treturn false;\n}\n\nstatic int intel_dp_mst_add_properties(struct intel_dp *intel_dp,\n\t\t\t\t       struct drm_connector *connector,\n\t\t\t\t       const char *pathprop)\n{\n\tstruct drm_i915_private *i915 = to_i915(connector->dev);\n\n\tdrm_object_attach_property(&connector->base,\n\t\t\t\t   i915->drm.mode_config.path_property, 0);\n\tdrm_object_attach_property(&connector->base,\n\t\t\t\t   i915->drm.mode_config.tile_property, 0);\n\n\tintel_attach_force_audio_property(connector);\n\tintel_attach_broadcast_rgb_property(connector);\n\n\t \n\tconnector->max_bpc_property =\n\t\tintel_dp->attached_connector->base.max_bpc_property;\n\tif (connector->max_bpc_property)\n\t\tdrm_connector_attach_max_bpc_property(connector, 6, 12);\n\n\treturn drm_connector_set_path_property(connector, pathprop);\n}\n\nstatic struct drm_connector *intel_dp_add_mst_connector(struct drm_dp_mst_topology_mgr *mgr,\n\t\t\t\t\t\t\tstruct drm_dp_mst_port *port,\n\t\t\t\t\t\t\tconst char *pathprop)\n{\n\tstruct intel_dp *intel_dp = container_of(mgr, struct intel_dp, mst_mgr);\n\tstruct intel_digital_port *dig_port = dp_to_dig_port(intel_dp);\n\tstruct drm_device *dev = dig_port->base.base.dev;\n\tstruct drm_i915_private *dev_priv = to_i915(dev);\n\tstruct intel_connector *intel_connector;\n\tstruct drm_connector *connector;\n\tenum pipe pipe;\n\tint ret;\n\n\tintel_connector = intel_connector_alloc();\n\tif (!intel_connector)\n\t\treturn NULL;\n\n\tintel_connector->get_hw_state = intel_dp_mst_get_hw_state;\n\tintel_connector->mst_port = intel_dp;\n\tintel_connector->port = port;\n\tdrm_dp_mst_get_port_malloc(port);\n\n\tconnector = &intel_connector->base;\n\tret = drm_connector_init(dev, connector, &intel_dp_mst_connector_funcs,\n\t\t\t\t DRM_MODE_CONNECTOR_DisplayPort);\n\tif (ret) {\n\t\tdrm_dp_mst_put_port_malloc(port);\n\t\tintel_connector_free(intel_connector);\n\t\treturn NULL;\n\t}\n\n\tdrm_connector_helper_add(connector, &intel_dp_mst_connector_helper_funcs);\n\n\tfor_each_pipe(dev_priv, pipe) {\n\t\tstruct drm_encoder *enc =\n\t\t\t&intel_dp->mst_encoders[pipe]->base.base;\n\n\t\tret = drm_connector_attach_encoder(&intel_connector->base, enc);\n\t\tif (ret)\n\t\t\tgoto err;\n\t}\n\n\tret = intel_dp_mst_add_properties(intel_dp, connector, pathprop);\n\tif (ret)\n\t\tgoto err;\n\n\tret = intel_dp_hdcp_init(dig_port, intel_connector);\n\tif (ret)\n\t\tdrm_dbg_kms(&dev_priv->drm, \"[%s:%d] HDCP MST init failed, skipping.\\n\",\n\t\t\t    connector->name, connector->base.id);\n\n\treturn connector;\n\nerr:\n\tdrm_connector_cleanup(connector);\n\treturn NULL;\n}\n\nstatic void\nintel_dp_mst_poll_hpd_irq(struct drm_dp_mst_topology_mgr *mgr)\n{\n\tstruct intel_dp *intel_dp = container_of(mgr, struct intel_dp, mst_mgr);\n\n\tintel_hpd_trigger_irq(dp_to_dig_port(intel_dp));\n}\n\nstatic const struct drm_dp_mst_topology_cbs mst_cbs = {\n\t.add_connector = intel_dp_add_mst_connector,\n\t.poll_hpd_irq = intel_dp_mst_poll_hpd_irq,\n};\n\nstatic struct intel_dp_mst_encoder *\nintel_dp_create_fake_mst_encoder(struct intel_digital_port *dig_port, enum pipe pipe)\n{\n\tstruct intel_dp_mst_encoder *intel_mst;\n\tstruct intel_encoder *intel_encoder;\n\tstruct drm_device *dev = dig_port->base.base.dev;\n\n\tintel_mst = kzalloc(sizeof(*intel_mst), GFP_KERNEL);\n\n\tif (!intel_mst)\n\t\treturn NULL;\n\n\tintel_mst->pipe = pipe;\n\tintel_encoder = &intel_mst->base;\n\tintel_mst->primary = dig_port;\n\n\tdrm_encoder_init(dev, &intel_encoder->base, &intel_dp_mst_enc_funcs,\n\t\t\t DRM_MODE_ENCODER_DPMST, \"DP-MST %c\", pipe_name(pipe));\n\n\tintel_encoder->type = INTEL_OUTPUT_DP_MST;\n\tintel_encoder->power_domain = dig_port->base.power_domain;\n\tintel_encoder->port = dig_port->base.port;\n\tintel_encoder->cloneable = 0;\n\t \n\tintel_encoder->pipe_mask = ~0;\n\n\tintel_encoder->compute_config = intel_dp_mst_compute_config;\n\tintel_encoder->compute_config_late = intel_dp_mst_compute_config_late;\n\tintel_encoder->disable = intel_mst_disable_dp;\n\tintel_encoder->post_disable = intel_mst_post_disable_dp;\n\tintel_encoder->post_pll_disable = intel_mst_post_pll_disable_dp;\n\tintel_encoder->update_pipe = intel_ddi_update_pipe;\n\tintel_encoder->pre_pll_enable = intel_mst_pre_pll_enable_dp;\n\tintel_encoder->pre_enable = intel_mst_pre_enable_dp;\n\tintel_encoder->enable = intel_mst_enable_dp;\n\tintel_encoder->get_hw_state = intel_dp_mst_enc_get_hw_state;\n\tintel_encoder->get_config = intel_dp_mst_enc_get_config;\n\tintel_encoder->initial_fastset_check = intel_dp_mst_initial_fastset_check;\n\n\treturn intel_mst;\n\n}\n\nstatic bool\nintel_dp_create_fake_mst_encoders(struct intel_digital_port *dig_port)\n{\n\tstruct intel_dp *intel_dp = &dig_port->dp;\n\tstruct drm_i915_private *dev_priv = to_i915(dig_port->base.base.dev);\n\tenum pipe pipe;\n\n\tfor_each_pipe(dev_priv, pipe)\n\t\tintel_dp->mst_encoders[pipe] = intel_dp_create_fake_mst_encoder(dig_port, pipe);\n\treturn true;\n}\n\nint\nintel_dp_mst_encoder_active_links(struct intel_digital_port *dig_port)\n{\n\treturn dig_port->dp.active_mst_links;\n}\n\nint\nintel_dp_mst_encoder_init(struct intel_digital_port *dig_port, int conn_base_id)\n{\n\tstruct drm_i915_private *i915 = to_i915(dig_port->base.base.dev);\n\tstruct intel_dp *intel_dp = &dig_port->dp;\n\tenum port port = dig_port->base.port;\n\tint ret;\n\n\tif (!HAS_DP_MST(i915) || intel_dp_is_edp(intel_dp))\n\t\treturn 0;\n\n\tif (DISPLAY_VER(i915) < 12 && port == PORT_A)\n\t\treturn 0;\n\n\tif (DISPLAY_VER(i915) < 11 && port == PORT_E)\n\t\treturn 0;\n\n\tintel_dp->mst_mgr.cbs = &mst_cbs;\n\n\t \n\tintel_dp_create_fake_mst_encoders(dig_port);\n\tret = drm_dp_mst_topology_mgr_init(&intel_dp->mst_mgr, &i915->drm,\n\t\t\t\t\t   &intel_dp->aux, 16, 3, conn_base_id);\n\tif (ret) {\n\t\tintel_dp->mst_mgr.cbs = NULL;\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nbool intel_dp_mst_source_support(struct intel_dp *intel_dp)\n{\n\treturn intel_dp->mst_mgr.cbs;\n}\n\nvoid\nintel_dp_mst_encoder_cleanup(struct intel_digital_port *dig_port)\n{\n\tstruct intel_dp *intel_dp = &dig_port->dp;\n\n\tif (!intel_dp_mst_source_support(intel_dp))\n\t\treturn;\n\n\tdrm_dp_mst_topology_mgr_destroy(&intel_dp->mst_mgr);\n\t \n\n\tintel_dp->mst_mgr.cbs = NULL;\n}\n\nbool intel_dp_mst_is_master_trans(const struct intel_crtc_state *crtc_state)\n{\n\treturn crtc_state->mst_master_transcoder == crtc_state->cpu_transcoder;\n}\n\nbool intel_dp_mst_is_slave_trans(const struct intel_crtc_state *crtc_state)\n{\n\treturn crtc_state->mst_master_transcoder != INVALID_TRANSCODER &&\n\t       crtc_state->mst_master_transcoder != crtc_state->cpu_transcoder;\n}\n\n \nstatic int\nintel_dp_mst_add_topology_state_for_connector(struct intel_atomic_state *state,\n\t\t\t\t\t      struct intel_connector *connector,\n\t\t\t\t\t      struct intel_crtc *crtc)\n{\n\tstruct drm_dp_mst_topology_state *mst_state;\n\n\tif (!connector->mst_port)\n\t\treturn 0;\n\n\tmst_state = drm_atomic_get_mst_topology_state(&state->base,\n\t\t\t\t\t\t      &connector->mst_port->mst_mgr);\n\tif (IS_ERR(mst_state))\n\t\treturn PTR_ERR(mst_state);\n\n\tmst_state->pending_crtc_mask |= drm_crtc_mask(&crtc->base);\n\n\treturn 0;\n}\n\n \nint intel_dp_mst_add_topology_state_for_crtc(struct intel_atomic_state *state,\n\t\t\t\t\t     struct intel_crtc *crtc)\n{\n\tstruct drm_connector *_connector;\n\tstruct drm_connector_state *conn_state;\n\tint i;\n\n\tfor_each_new_connector_in_state(&state->base, _connector, conn_state, i) {\n\t\tstruct intel_connector *connector = to_intel_connector(_connector);\n\t\tint ret;\n\n\t\tif (conn_state->crtc != &crtc->base)\n\t\t\tcontinue;\n\n\t\tret = intel_dp_mst_add_topology_state_for_connector(state, connector, crtc);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}