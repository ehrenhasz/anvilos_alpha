{
  "module_name": "intel_display_reset.c",
  "hash_id": "bd0c289e3acf264c98716bdd29733c0c255689d6d8e4fa6b2560ef2881ba8871",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/i915/display/intel_display_reset.c",
  "human_readable_source": "\n \n\n#include <drm/drm_atomic_helper.h>\n\n#include \"i915_drv.h\"\n#include \"intel_clock_gating.h\"\n#include \"intel_display_driver.h\"\n#include \"intel_display_reset.h\"\n#include \"intel_display_types.h\"\n#include \"intel_hotplug.h\"\n#include \"intel_pps.h\"\n\nstatic bool gpu_reset_clobbers_display(struct drm_i915_private *dev_priv)\n{\n\treturn (INTEL_INFO(dev_priv)->gpu_reset_clobbers_display &&\n\t\tintel_has_gpu_reset(to_gt(dev_priv)));\n}\n\nvoid intel_display_reset_prepare(struct drm_i915_private *dev_priv)\n{\n\tstruct drm_modeset_acquire_ctx *ctx = &dev_priv->display.restore.reset_ctx;\n\tstruct drm_atomic_state *state;\n\tint ret;\n\n\tif (!HAS_DISPLAY(dev_priv))\n\t\treturn;\n\n\t \n\tif (!dev_priv->params.force_reset_modeset_test &&\n\t    !gpu_reset_clobbers_display(dev_priv))\n\t\treturn;\n\n\t \n\tset_bit(I915_RESET_MODESET, &to_gt(dev_priv)->reset.flags);\n\tsmp_mb__after_atomic();\n\twake_up_bit(&to_gt(dev_priv)->reset.flags, I915_RESET_MODESET);\n\n\tif (atomic_read(&dev_priv->gpu_error.pending_fb_pin)) {\n\t\tdrm_dbg_kms(&dev_priv->drm,\n\t\t\t    \"Modeset potentially stuck, unbreaking through wedging\\n\");\n\t\tintel_gt_set_wedged(to_gt(dev_priv));\n\t}\n\n\t \n\tmutex_lock(&dev_priv->drm.mode_config.mutex);\n\tdrm_modeset_acquire_init(ctx, 0);\n\twhile (1) {\n\t\tret = drm_modeset_lock_all_ctx(&dev_priv->drm, ctx);\n\t\tif (ret != -EDEADLK)\n\t\t\tbreak;\n\n\t\tdrm_modeset_backoff(ctx);\n\t}\n\t \n\tstate = drm_atomic_helper_duplicate_state(&dev_priv->drm, ctx);\n\tif (IS_ERR(state)) {\n\t\tret = PTR_ERR(state);\n\t\tdrm_err(&dev_priv->drm, \"Duplicating state failed with %i\\n\",\n\t\t\tret);\n\t\treturn;\n\t}\n\n\tret = drm_atomic_helper_disable_all(&dev_priv->drm, ctx);\n\tif (ret) {\n\t\tdrm_err(&dev_priv->drm, \"Suspending crtc's failed with %i\\n\",\n\t\t\tret);\n\t\tdrm_atomic_state_put(state);\n\t\treturn;\n\t}\n\n\tdev_priv->display.restore.modeset_state = state;\n\tstate->acquire_ctx = ctx;\n}\n\nvoid intel_display_reset_finish(struct drm_i915_private *i915)\n{\n\tstruct drm_modeset_acquire_ctx *ctx = &i915->display.restore.reset_ctx;\n\tstruct drm_atomic_state *state;\n\tint ret;\n\n\tif (!HAS_DISPLAY(i915))\n\t\treturn;\n\n\t \n\tif (!test_bit(I915_RESET_MODESET, &to_gt(i915)->reset.flags))\n\t\treturn;\n\n\tstate = fetch_and_zero(&i915->display.restore.modeset_state);\n\tif (!state)\n\t\tgoto unlock;\n\n\t \n\tif (!gpu_reset_clobbers_display(i915)) {\n\t\t \n\t\tret = drm_atomic_helper_commit_duplicated_state(state, ctx);\n\t\tif (ret) {\n\t\t\tdrm_WARN_ON(&i915->drm, ret == -EDEADLK);\n\t\t\tdrm_err(&i915->drm,\n\t\t\t\t\"Restoring old state failed with %i\\n\", ret);\n\t\t}\n\t} else {\n\t\t \n\t\tintel_pps_unlock_regs_wa(i915);\n\t\tintel_display_driver_init_hw(i915);\n\t\tintel_clock_gating_init(i915);\n\t\tintel_hpd_init(i915);\n\n\t\tret = __intel_display_driver_resume(i915, state, ctx);\n\t\tif (ret)\n\t\t\tdrm_err(&i915->drm,\n\t\t\t\t\"Restoring old state failed with %i\\n\", ret);\n\n\t\tintel_hpd_poll_disable(i915);\n\t}\n\n\tdrm_atomic_state_put(state);\nunlock:\n\tdrm_modeset_drop_locks(ctx);\n\tdrm_modeset_acquire_fini(ctx);\n\tmutex_unlock(&i915->drm.mode_config.mutex);\n\n\tclear_bit_unlock(I915_RESET_MODESET, &to_gt(i915)->reset.flags);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}