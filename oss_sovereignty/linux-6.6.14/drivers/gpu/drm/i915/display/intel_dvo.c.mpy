{
  "module_name": "intel_dvo.c",
  "hash_id": "a970f592de85560f11c6d3acbc4939825a0a336f6197683a0a223c4fd4d77d54",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/i915/display/intel_dvo.c",
  "human_readable_source": " \n\n#include <linux/i2c.h>\n#include <linux/slab.h>\n\n#include <drm/drm_atomic_helper.h>\n#include <drm/drm_crtc.h>\n\n#include \"i915_drv.h\"\n#include \"i915_reg.h\"\n#include \"intel_connector.h\"\n#include \"intel_de.h\"\n#include \"intel_display_types.h\"\n#include \"intel_dvo.h\"\n#include \"intel_dvo_dev.h\"\n#include \"intel_dvo_regs.h\"\n#include \"intel_gmbus.h\"\n#include \"intel_panel.h\"\n\n#define INTEL_DVO_CHIP_NONE\t0\n#define INTEL_DVO_CHIP_LVDS\t1\n#define INTEL_DVO_CHIP_TMDS\t2\n#define INTEL_DVO_CHIP_TVOUT\t4\n#define INTEL_DVO_CHIP_LVDS_NO_FIXED\t5\n\n#define SIL164_ADDR\t0x38\n#define CH7xxx_ADDR\t0x76\n#define TFP410_ADDR\t0x38\n#define NS2501_ADDR     0x38\n\nstatic const struct intel_dvo_device intel_dvo_devices[] = {\n\t{\n\t\t.type = INTEL_DVO_CHIP_TMDS,\n\t\t.name = \"sil164\",\n\t\t.port = PORT_C,\n\t\t.slave_addr = SIL164_ADDR,\n\t\t.dev_ops = &sil164_ops,\n\t},\n\t{\n\t\t.type = INTEL_DVO_CHIP_TMDS,\n\t\t.name = \"ch7xxx\",\n\t\t.port = PORT_C,\n\t\t.slave_addr = CH7xxx_ADDR,\n\t\t.dev_ops = &ch7xxx_ops,\n\t},\n\t{\n\t\t.type = INTEL_DVO_CHIP_TMDS,\n\t\t.name = \"ch7xxx\",\n\t\t.port = PORT_C,\n\t\t.slave_addr = 0x75,  \n\t\t.dev_ops = &ch7xxx_ops,\n\t},\n\t{\n\t\t.type = INTEL_DVO_CHIP_LVDS,\n\t\t.name = \"ivch\",\n\t\t.port = PORT_A,\n\t\t.slave_addr = 0x02,  \n\t\t.dev_ops = &ivch_ops,\n\t},\n\t{\n\t\t.type = INTEL_DVO_CHIP_TMDS,\n\t\t.name = \"tfp410\",\n\t\t.port = PORT_C,\n\t\t.slave_addr = TFP410_ADDR,\n\t\t.dev_ops = &tfp410_ops,\n\t},\n\t{\n\t\t.type = INTEL_DVO_CHIP_LVDS,\n\t\t.name = \"ch7017\",\n\t\t.port = PORT_C,\n\t\t.slave_addr = 0x75,\n\t\t.gpio = GMBUS_PIN_DPB,\n\t\t.dev_ops = &ch7017_ops,\n\t},\n\t{\n\t\t.type = INTEL_DVO_CHIP_LVDS_NO_FIXED,\n\t\t.name = \"ns2501\",\n\t\t.port = PORT_B,\n\t\t.slave_addr = NS2501_ADDR,\n\t\t.dev_ops = &ns2501_ops,\n\t},\n};\n\nstruct intel_dvo {\n\tstruct intel_encoder base;\n\n\tstruct intel_dvo_device dev;\n\n\tstruct intel_connector *attached_connector;\n};\n\nstatic struct intel_dvo *enc_to_dvo(struct intel_encoder *encoder)\n{\n\treturn container_of(encoder, struct intel_dvo, base);\n}\n\nstatic struct intel_dvo *intel_attached_dvo(struct intel_connector *connector)\n{\n\treturn enc_to_dvo(intel_attached_encoder(connector));\n}\n\nstatic bool intel_dvo_connector_get_hw_state(struct intel_connector *connector)\n{\n\tstruct drm_i915_private *i915 = to_i915(connector->base.dev);\n\tstruct intel_encoder *encoder = intel_attached_encoder(connector);\n\tstruct intel_dvo *intel_dvo = enc_to_dvo(encoder);\n\tenum port port = encoder->port;\n\tu32 tmp;\n\n\ttmp = intel_de_read(i915, DVO(port));\n\n\tif (!(tmp & DVO_ENABLE))\n\t\treturn false;\n\n\treturn intel_dvo->dev.dev_ops->get_hw_state(&intel_dvo->dev);\n}\n\nstatic bool intel_dvo_get_hw_state(struct intel_encoder *encoder,\n\t\t\t\t   enum pipe *pipe)\n{\n\tstruct drm_i915_private *i915 = to_i915(encoder->base.dev);\n\tenum port port = encoder->port;\n\tu32 tmp;\n\n\ttmp = intel_de_read(i915, DVO(port));\n\n\t*pipe = REG_FIELD_GET(DVO_PIPE_SEL_MASK, tmp);\n\n\treturn tmp & DVO_ENABLE;\n}\n\nstatic void intel_dvo_get_config(struct intel_encoder *encoder,\n\t\t\t\t struct intel_crtc_state *pipe_config)\n{\n\tstruct drm_i915_private *i915 = to_i915(encoder->base.dev);\n\tenum port port = encoder->port;\n\tu32 tmp, flags = 0;\n\n\tpipe_config->output_types |= BIT(INTEL_OUTPUT_DVO);\n\n\ttmp = intel_de_read(i915, DVO(port));\n\tif (tmp & DVO_HSYNC_ACTIVE_HIGH)\n\t\tflags |= DRM_MODE_FLAG_PHSYNC;\n\telse\n\t\tflags |= DRM_MODE_FLAG_NHSYNC;\n\tif (tmp & DVO_VSYNC_ACTIVE_HIGH)\n\t\tflags |= DRM_MODE_FLAG_PVSYNC;\n\telse\n\t\tflags |= DRM_MODE_FLAG_NVSYNC;\n\n\tpipe_config->hw.adjusted_mode.flags |= flags;\n\n\tpipe_config->hw.adjusted_mode.crtc_clock = pipe_config->port_clock;\n}\n\nstatic void intel_disable_dvo(struct intel_atomic_state *state,\n\t\t\t      struct intel_encoder *encoder,\n\t\t\t      const struct intel_crtc_state *old_crtc_state,\n\t\t\t      const struct drm_connector_state *old_conn_state)\n{\n\tstruct drm_i915_private *i915 = to_i915(encoder->base.dev);\n\tstruct intel_dvo *intel_dvo = enc_to_dvo(encoder);\n\tenum port port = encoder->port;\n\n\tintel_dvo->dev.dev_ops->dpms(&intel_dvo->dev, false);\n\n\tintel_de_rmw(i915, DVO(port), DVO_ENABLE, 0);\n\tintel_de_posting_read(i915, DVO(port));\n}\n\nstatic void intel_enable_dvo(struct intel_atomic_state *state,\n\t\t\t     struct intel_encoder *encoder,\n\t\t\t     const struct intel_crtc_state *pipe_config,\n\t\t\t     const struct drm_connector_state *conn_state)\n{\n\tstruct drm_i915_private *i915 = to_i915(encoder->base.dev);\n\tstruct intel_dvo *intel_dvo = enc_to_dvo(encoder);\n\tenum port port = encoder->port;\n\n\tintel_dvo->dev.dev_ops->mode_set(&intel_dvo->dev,\n\t\t\t\t\t &pipe_config->hw.mode,\n\t\t\t\t\t &pipe_config->hw.adjusted_mode);\n\n\tintel_de_rmw(i915, DVO(port), 0, DVO_ENABLE);\n\tintel_de_posting_read(i915, DVO(port));\n\n\tintel_dvo->dev.dev_ops->dpms(&intel_dvo->dev, true);\n}\n\nstatic enum drm_mode_status\nintel_dvo_mode_valid(struct drm_connector *_connector,\n\t\t     struct drm_display_mode *mode)\n{\n\tstruct intel_connector *connector = to_intel_connector(_connector);\n\tstruct drm_i915_private *i915 = to_i915(connector->base.dev);\n\tstruct intel_dvo *intel_dvo = intel_attached_dvo(connector);\n\tconst struct drm_display_mode *fixed_mode =\n\t\tintel_panel_fixed_mode(connector, mode);\n\tint max_dotclk = to_i915(connector->base.dev)->max_dotclk_freq;\n\tint target_clock = mode->clock;\n\tenum drm_mode_status status;\n\n\tstatus = intel_cpu_transcoder_mode_valid(i915, mode);\n\tif (status != MODE_OK)\n\t\treturn status;\n\n\tif (mode->flags & DRM_MODE_FLAG_DBLSCAN)\n\t\treturn MODE_NO_DBLESCAN;\n\n\t \n\n\tif (fixed_mode) {\n\t\tenum drm_mode_status status;\n\n\t\tstatus = intel_panel_mode_valid(connector, mode);\n\t\tif (status != MODE_OK)\n\t\t\treturn status;\n\n\t\ttarget_clock = fixed_mode->clock;\n\t}\n\n\tif (target_clock > max_dotclk)\n\t\treturn MODE_CLOCK_HIGH;\n\n\treturn intel_dvo->dev.dev_ops->mode_valid(&intel_dvo->dev, mode);\n}\n\nstatic int intel_dvo_compute_config(struct intel_encoder *encoder,\n\t\t\t\t    struct intel_crtc_state *pipe_config,\n\t\t\t\t    struct drm_connector_state *conn_state)\n{\n\tstruct intel_dvo *intel_dvo = enc_to_dvo(encoder);\n\tstruct intel_connector *connector = to_intel_connector(conn_state->connector);\n\tstruct drm_display_mode *adjusted_mode = &pipe_config->hw.adjusted_mode;\n\tconst struct drm_display_mode *fixed_mode =\n\t\tintel_panel_fixed_mode(intel_dvo->attached_connector, adjusted_mode);\n\n\t \n\tif (fixed_mode) {\n\t\tint ret;\n\n\t\tret = intel_panel_compute_config(connector, adjusted_mode);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tif (adjusted_mode->flags & DRM_MODE_FLAG_DBLSCAN)\n\t\treturn -EINVAL;\n\n\tpipe_config->sink_format = INTEL_OUTPUT_FORMAT_RGB;\n\tpipe_config->output_format = INTEL_OUTPUT_FORMAT_RGB;\n\n\treturn 0;\n}\n\nstatic void intel_dvo_pre_enable(struct intel_atomic_state *state,\n\t\t\t\t struct intel_encoder *encoder,\n\t\t\t\t const struct intel_crtc_state *pipe_config,\n\t\t\t\t const struct drm_connector_state *conn_state)\n{\n\tstruct drm_i915_private *i915 = to_i915(encoder->base.dev);\n\tstruct intel_crtc *crtc = to_intel_crtc(pipe_config->uapi.crtc);\n\tconst struct drm_display_mode *adjusted_mode = &pipe_config->hw.adjusted_mode;\n\tenum port port = encoder->port;\n\tenum pipe pipe = crtc->pipe;\n\tu32 dvo_val;\n\n\t \n\tdvo_val = intel_de_read(i915, DVO(port)) &\n\t\t  (DVO_DEDICATED_INT_ENABLE |\n\t\t   DVO_PRESERVE_MASK | DVO_ACT_DATA_ORDER_MASK);\n\tdvo_val |= DVO_DATA_ORDER_FP | DVO_BORDER_ENABLE |\n\t\t   DVO_BLANK_ACTIVE_HIGH;\n\n\tdvo_val |= DVO_PIPE_SEL(pipe);\n\tdvo_val |= DVO_PIPE_STALL;\n\tif (adjusted_mode->flags & DRM_MODE_FLAG_PHSYNC)\n\t\tdvo_val |= DVO_HSYNC_ACTIVE_HIGH;\n\tif (adjusted_mode->flags & DRM_MODE_FLAG_PVSYNC)\n\t\tdvo_val |= DVO_VSYNC_ACTIVE_HIGH;\n\n\tintel_de_write(i915, DVO_SRCDIM(port),\n\t\t       DVO_SRCDIM_HORIZONTAL(adjusted_mode->crtc_hdisplay) |\n\t\t       DVO_SRCDIM_VERTICAL(adjusted_mode->crtc_vdisplay));\n\tintel_de_write(i915, DVO(port), dvo_val);\n}\n\nstatic enum drm_connector_status\nintel_dvo_detect(struct drm_connector *_connector, bool force)\n{\n\tstruct intel_connector *connector = to_intel_connector(_connector);\n\tstruct drm_i915_private *i915 = to_i915(connector->base.dev);\n\tstruct intel_dvo *intel_dvo = intel_attached_dvo(connector);\n\n\tdrm_dbg_kms(&i915->drm, \"[CONNECTOR:%d:%s]\\n\",\n\t\t    connector->base.base.id, connector->base.name);\n\n\tif (!INTEL_DISPLAY_ENABLED(i915))\n\t\treturn connector_status_disconnected;\n\n\treturn intel_dvo->dev.dev_ops->detect(&intel_dvo->dev);\n}\n\nstatic int intel_dvo_get_modes(struct drm_connector *_connector)\n{\n\tstruct intel_connector *connector = to_intel_connector(_connector);\n\tstruct drm_i915_private *i915 = to_i915(connector->base.dev);\n\tint num_modes;\n\n\t \n\tnum_modes = intel_ddc_get_modes(&connector->base,\n\t\t\t\t\tintel_gmbus_get_adapter(i915, GMBUS_PIN_DPC));\n\tif (num_modes)\n\t\treturn num_modes;\n\n\treturn intel_panel_get_modes(connector);\n}\n\nstatic const struct drm_connector_funcs intel_dvo_connector_funcs = {\n\t.detect = intel_dvo_detect,\n\t.late_register = intel_connector_register,\n\t.early_unregister = intel_connector_unregister,\n\t.destroy = intel_connector_destroy,\n\t.fill_modes = drm_helper_probe_single_connector_modes,\n\t.atomic_destroy_state = drm_atomic_helper_connector_destroy_state,\n\t.atomic_duplicate_state = drm_atomic_helper_connector_duplicate_state,\n};\n\nstatic const struct drm_connector_helper_funcs intel_dvo_connector_helper_funcs = {\n\t.mode_valid = intel_dvo_mode_valid,\n\t.get_modes = intel_dvo_get_modes,\n};\n\nstatic void intel_dvo_enc_destroy(struct drm_encoder *encoder)\n{\n\tstruct intel_dvo *intel_dvo = enc_to_dvo(to_intel_encoder(encoder));\n\n\tif (intel_dvo->dev.dev_ops->destroy)\n\t\tintel_dvo->dev.dev_ops->destroy(&intel_dvo->dev);\n\n\tintel_encoder_destroy(encoder);\n}\n\nstatic const struct drm_encoder_funcs intel_dvo_enc_funcs = {\n\t.destroy = intel_dvo_enc_destroy,\n};\n\nstatic int intel_dvo_encoder_type(const struct intel_dvo_device *dvo)\n{\n\tswitch (dvo->type) {\n\tcase INTEL_DVO_CHIP_TMDS:\n\t\treturn DRM_MODE_ENCODER_TMDS;\n\tcase INTEL_DVO_CHIP_LVDS_NO_FIXED:\n\tcase INTEL_DVO_CHIP_LVDS:\n\t\treturn DRM_MODE_ENCODER_LVDS;\n\tdefault:\n\t\tMISSING_CASE(dvo->type);\n\t\treturn DRM_MODE_ENCODER_NONE;\n\t}\n}\n\nstatic int intel_dvo_connector_type(const struct intel_dvo_device *dvo)\n{\n\tswitch (dvo->type) {\n\tcase INTEL_DVO_CHIP_TMDS:\n\t\treturn DRM_MODE_CONNECTOR_DVII;\n\tcase INTEL_DVO_CHIP_LVDS_NO_FIXED:\n\tcase INTEL_DVO_CHIP_LVDS:\n\t\treturn DRM_MODE_CONNECTOR_LVDS;\n\tdefault:\n\t\tMISSING_CASE(dvo->type);\n\t\treturn DRM_MODE_CONNECTOR_Unknown;\n\t}\n}\n\nstatic bool intel_dvo_init_dev(struct drm_i915_private *dev_priv,\n\t\t\t       struct intel_dvo *intel_dvo,\n\t\t\t       const struct intel_dvo_device *dvo)\n{\n\tstruct i2c_adapter *i2c;\n\tu32 dpll[I915_MAX_PIPES];\n\tenum pipe pipe;\n\tint gpio;\n\tbool ret;\n\n\t \n\tif (intel_gmbus_is_valid_pin(dev_priv, dvo->gpio))\n\t\tgpio = dvo->gpio;\n\telse if (dvo->type == INTEL_DVO_CHIP_LVDS)\n\t\tgpio = GMBUS_PIN_SSC;\n\telse\n\t\tgpio = GMBUS_PIN_DPB;\n\n\t \n\ti2c = intel_gmbus_get_adapter(dev_priv, gpio);\n\n\tintel_dvo->dev = *dvo;\n\n\t \n\tintel_gmbus_force_bit(i2c, true);\n\n\t \n\tfor_each_pipe(dev_priv, pipe)\n\t\tdpll[pipe] = intel_de_rmw(dev_priv, DPLL(pipe), 0, DPLL_DVO_2X_MODE);\n\n\tret = dvo->dev_ops->init(&intel_dvo->dev, i2c);\n\n\t \n\tfor_each_pipe(dev_priv, pipe) {\n\t\tintel_de_write(dev_priv, DPLL(pipe), dpll[pipe]);\n\t}\n\n\tintel_gmbus_force_bit(i2c, false);\n\n\treturn ret;\n}\n\nstatic bool intel_dvo_probe(struct drm_i915_private *i915,\n\t\t\t    struct intel_dvo *intel_dvo)\n{\n\tint i;\n\n\t \n\tfor (i = 0; i < ARRAY_SIZE(intel_dvo_devices); i++) {\n\t\tif (intel_dvo_init_dev(i915, intel_dvo,\n\t\t\t\t       &intel_dvo_devices[i]))\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}\n\nvoid intel_dvo_init(struct drm_i915_private *i915)\n{\n\tstruct intel_connector *connector;\n\tstruct intel_encoder *encoder;\n\tstruct intel_dvo *intel_dvo;\n\n\tintel_dvo = kzalloc(sizeof(*intel_dvo), GFP_KERNEL);\n\tif (!intel_dvo)\n\t\treturn;\n\n\tconnector = intel_connector_alloc();\n\tif (!connector) {\n\t\tkfree(intel_dvo);\n\t\treturn;\n\t}\n\n\tintel_dvo->attached_connector = connector;\n\n\tencoder = &intel_dvo->base;\n\n\tencoder->disable = intel_disable_dvo;\n\tencoder->enable = intel_enable_dvo;\n\tencoder->get_hw_state = intel_dvo_get_hw_state;\n\tencoder->get_config = intel_dvo_get_config;\n\tencoder->compute_config = intel_dvo_compute_config;\n\tencoder->pre_enable = intel_dvo_pre_enable;\n\tconnector->get_hw_state = intel_dvo_connector_get_hw_state;\n\n\tif (!intel_dvo_probe(i915, intel_dvo)) {\n\t\tkfree(intel_dvo);\n\t\tintel_connector_free(connector);\n\t\treturn;\n\t}\n\n\tassert_port_valid(i915, intel_dvo->dev.port);\n\n\tencoder->type = INTEL_OUTPUT_DVO;\n\tencoder->power_domain = POWER_DOMAIN_PORT_OTHER;\n\tencoder->port = intel_dvo->dev.port;\n\tencoder->pipe_mask = ~0;\n\n\tif (intel_dvo->dev.type != INTEL_DVO_CHIP_LVDS)\n\t\tencoder->cloneable = BIT(INTEL_OUTPUT_ANALOG) |\n\t\t\tBIT(INTEL_OUTPUT_DVO);\n\n\tdrm_encoder_init(&i915->drm, &encoder->base,\n\t\t\t &intel_dvo_enc_funcs,\n\t\t\t intel_dvo_encoder_type(&intel_dvo->dev),\n\t\t\t \"DVO %c\", port_name(encoder->port));\n\n\tdrm_dbg_kms(&i915->drm, \"[ENCODER:%d:%s] detected %s\\n\",\n\t\t    encoder->base.base.id, encoder->base.name,\n\t\t    intel_dvo->dev.name);\n\n\tif (intel_dvo->dev.type == INTEL_DVO_CHIP_TMDS)\n\t\tconnector->polled = DRM_CONNECTOR_POLL_CONNECT |\n\t\t\tDRM_CONNECTOR_POLL_DISCONNECT;\n\n\tdrm_connector_init(&i915->drm, &connector->base,\n\t\t\t   &intel_dvo_connector_funcs,\n\t\t\t   intel_dvo_connector_type(&intel_dvo->dev));\n\n\tdrm_connector_helper_add(&connector->base,\n\t\t\t\t &intel_dvo_connector_helper_funcs);\n\tconnector->base.display_info.subpixel_order = SubPixelHorizontalRGB;\n\n\tintel_connector_attach_encoder(connector, encoder);\n\n\tif (intel_dvo->dev.type == INTEL_DVO_CHIP_LVDS) {\n\t\t \n\t\tintel_panel_add_encoder_fixed_mode(connector, encoder);\n\n\t\tintel_panel_init(connector, NULL);\n\t}\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}