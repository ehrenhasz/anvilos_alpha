{
  "module_name": "intel_fdi.c",
  "hash_id": "689cee10841893aa402ab2d1dab30129f7fb40946c1cb8c8ff481f702619f21d",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/i915/display/intel_fdi.c",
  "human_readable_source": "\n \n\n#include <linux/string_helpers.h>\n\n#include \"i915_reg.h\"\n#include \"intel_atomic.h\"\n#include \"intel_crtc.h\"\n#include \"intel_ddi.h\"\n#include \"intel_de.h\"\n#include \"intel_display_types.h\"\n#include \"intel_fdi.h\"\n#include \"intel_fdi_regs.h\"\n\nstruct intel_fdi_funcs {\n\tvoid (*fdi_link_train)(struct intel_crtc *crtc,\n\t\t\t       const struct intel_crtc_state *crtc_state);\n};\n\nstatic void assert_fdi_tx(struct drm_i915_private *dev_priv,\n\t\t\t  enum pipe pipe, bool state)\n{\n\tbool cur_state;\n\n\tif (HAS_DDI(dev_priv)) {\n\t\t \n\t\tenum transcoder cpu_transcoder = (enum transcoder)pipe;\n\t\tcur_state = intel_de_read(dev_priv, TRANS_DDI_FUNC_CTL(cpu_transcoder)) & TRANS_DDI_FUNC_ENABLE;\n\t} else {\n\t\tcur_state = intel_de_read(dev_priv, FDI_TX_CTL(pipe)) & FDI_TX_ENABLE;\n\t}\n\tI915_STATE_WARN(dev_priv, cur_state != state,\n\t\t\t\"FDI TX state assertion failure (expected %s, current %s)\\n\",\n\t\t\tstr_on_off(state), str_on_off(cur_state));\n}\n\nvoid assert_fdi_tx_enabled(struct drm_i915_private *i915, enum pipe pipe)\n{\n\tassert_fdi_tx(i915, pipe, true);\n}\n\nvoid assert_fdi_tx_disabled(struct drm_i915_private *i915, enum pipe pipe)\n{\n\tassert_fdi_tx(i915, pipe, false);\n}\n\nstatic void assert_fdi_rx(struct drm_i915_private *dev_priv,\n\t\t\t  enum pipe pipe, bool state)\n{\n\tbool cur_state;\n\n\tcur_state = intel_de_read(dev_priv, FDI_RX_CTL(pipe)) & FDI_RX_ENABLE;\n\tI915_STATE_WARN(dev_priv, cur_state != state,\n\t\t\t\"FDI RX state assertion failure (expected %s, current %s)\\n\",\n\t\t\tstr_on_off(state), str_on_off(cur_state));\n}\n\nvoid assert_fdi_rx_enabled(struct drm_i915_private *i915, enum pipe pipe)\n{\n\tassert_fdi_rx(i915, pipe, true);\n}\n\nvoid assert_fdi_rx_disabled(struct drm_i915_private *i915, enum pipe pipe)\n{\n\tassert_fdi_rx(i915, pipe, false);\n}\n\nvoid assert_fdi_tx_pll_enabled(struct drm_i915_private *i915,\n\t\t\t       enum pipe pipe)\n{\n\tbool cur_state;\n\n\t \n\tif (IS_IRONLAKE(i915))\n\t\treturn;\n\n\t \n\tif (HAS_DDI(i915))\n\t\treturn;\n\n\tcur_state = intel_de_read(i915, FDI_TX_CTL(pipe)) & FDI_TX_PLL_ENABLE;\n\tI915_STATE_WARN(i915, !cur_state,\n\t\t\t\"FDI TX PLL assertion failure, should be active but is disabled\\n\");\n}\n\nstatic void assert_fdi_rx_pll(struct drm_i915_private *i915,\n\t\t\t      enum pipe pipe, bool state)\n{\n\tbool cur_state;\n\n\tcur_state = intel_de_read(i915, FDI_RX_CTL(pipe)) & FDI_RX_PLL_ENABLE;\n\tI915_STATE_WARN(i915, cur_state != state,\n\t\t\t\"FDI RX PLL assertion failure (expected %s, current %s)\\n\",\n\t\t\tstr_on_off(state), str_on_off(cur_state));\n}\n\nvoid assert_fdi_rx_pll_enabled(struct drm_i915_private *i915, enum pipe pipe)\n{\n\tassert_fdi_rx_pll(i915, pipe, true);\n}\n\nvoid assert_fdi_rx_pll_disabled(struct drm_i915_private *i915, enum pipe pipe)\n{\n\tassert_fdi_rx_pll(i915, pipe, false);\n}\n\nvoid intel_fdi_link_train(struct intel_crtc *crtc,\n\t\t\t  const struct intel_crtc_state *crtc_state)\n{\n\tstruct drm_i915_private *dev_priv = to_i915(crtc->base.dev);\n\n\tdev_priv->display.funcs.fdi->fdi_link_train(crtc, crtc_state);\n}\n\n \nstatic int pipe_required_fdi_lanes(struct intel_crtc_state *crtc_state)\n{\n\tif (crtc_state->hw.enable && crtc_state->has_pch_encoder)\n\t\treturn crtc_state->fdi_lanes;\n\n\treturn 0;\n}\n\nstatic int ilk_check_fdi_lanes(struct drm_device *dev, enum pipe pipe,\n\t\t\t       struct intel_crtc_state *pipe_config)\n{\n\tstruct drm_i915_private *dev_priv = to_i915(dev);\n\tstruct drm_atomic_state *state = pipe_config->uapi.state;\n\tstruct intel_crtc *other_crtc;\n\tstruct intel_crtc_state *other_crtc_state;\n\n\tdrm_dbg_kms(&dev_priv->drm,\n\t\t    \"checking fdi config on pipe %c, lanes %i\\n\",\n\t\t    pipe_name(pipe), pipe_config->fdi_lanes);\n\tif (pipe_config->fdi_lanes > 4) {\n\t\tdrm_dbg_kms(&dev_priv->drm,\n\t\t\t    \"invalid fdi lane config on pipe %c: %i lanes\\n\",\n\t\t\t    pipe_name(pipe), pipe_config->fdi_lanes);\n\t\treturn -EINVAL;\n\t}\n\n\tif (IS_HASWELL(dev_priv) || IS_BROADWELL(dev_priv)) {\n\t\tif (pipe_config->fdi_lanes > 2) {\n\t\t\tdrm_dbg_kms(&dev_priv->drm,\n\t\t\t\t    \"only 2 lanes on haswell, required: %i lanes\\n\",\n\t\t\t\t    pipe_config->fdi_lanes);\n\t\t\treturn -EINVAL;\n\t\t} else {\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tif (INTEL_NUM_PIPES(dev_priv) == 2)\n\t\treturn 0;\n\n\t \n\tswitch (pipe) {\n\tcase PIPE_A:\n\t\treturn 0;\n\tcase PIPE_B:\n\t\tif (pipe_config->fdi_lanes <= 2)\n\t\t\treturn 0;\n\n\t\tother_crtc = intel_crtc_for_pipe(dev_priv, PIPE_C);\n\t\tother_crtc_state =\n\t\t\tintel_atomic_get_crtc_state(state, other_crtc);\n\t\tif (IS_ERR(other_crtc_state))\n\t\t\treturn PTR_ERR(other_crtc_state);\n\n\t\tif (pipe_required_fdi_lanes(other_crtc_state) > 0) {\n\t\t\tdrm_dbg_kms(&dev_priv->drm,\n\t\t\t\t    \"invalid shared fdi lane config on pipe %c: %i lanes\\n\",\n\t\t\t\t    pipe_name(pipe), pipe_config->fdi_lanes);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\treturn 0;\n\tcase PIPE_C:\n\t\tif (pipe_config->fdi_lanes > 2) {\n\t\t\tdrm_dbg_kms(&dev_priv->drm,\n\t\t\t\t    \"only 2 lanes on pipe %c: required %i lanes\\n\",\n\t\t\t\t    pipe_name(pipe), pipe_config->fdi_lanes);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tother_crtc = intel_crtc_for_pipe(dev_priv, PIPE_B);\n\t\tother_crtc_state =\n\t\t\tintel_atomic_get_crtc_state(state, other_crtc);\n\t\tif (IS_ERR(other_crtc_state))\n\t\t\treturn PTR_ERR(other_crtc_state);\n\n\t\tif (pipe_required_fdi_lanes(other_crtc_state) > 2) {\n\t\t\tdrm_dbg_kms(&dev_priv->drm,\n\t\t\t\t    \"fdi link B uses too many lanes to enable link C\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\treturn 0;\n\tdefault:\n\t\tMISSING_CASE(pipe);\n\t\treturn 0;\n\t}\n}\n\nvoid intel_fdi_pll_freq_update(struct drm_i915_private *i915)\n{\n\tif (IS_IRONLAKE(i915)) {\n\t\tu32 fdi_pll_clk =\n\t\t\tintel_de_read(i915, FDI_PLL_BIOS_0) & FDI_PLL_FB_CLOCK_MASK;\n\n\t\ti915->display.fdi.pll_freq = (fdi_pll_clk + 2) * 10000;\n\t} else if (IS_SANDYBRIDGE(i915) || IS_IVYBRIDGE(i915)) {\n\t\ti915->display.fdi.pll_freq = 270000;\n\t} else {\n\t\treturn;\n\t}\n\n\tdrm_dbg(&i915->drm, \"FDI PLL freq=%d\\n\", i915->display.fdi.pll_freq);\n}\n\nint intel_fdi_link_freq(struct drm_i915_private *i915,\n\t\t\tconst struct intel_crtc_state *pipe_config)\n{\n\tif (HAS_DDI(i915))\n\t\treturn pipe_config->port_clock;  \n\telse\n\t\treturn i915->display.fdi.pll_freq;\n}\n\nint ilk_fdi_compute_config(struct intel_crtc *crtc,\n\t\t\t   struct intel_crtc_state *pipe_config)\n{\n\tstruct drm_device *dev = crtc->base.dev;\n\tstruct drm_i915_private *i915 = to_i915(dev);\n\tconst struct drm_display_mode *adjusted_mode = &pipe_config->hw.adjusted_mode;\n\tint lane, link_bw, fdi_dotclock, ret;\n\tbool needs_recompute = false;\n\nretry:\n\t \n\tlink_bw = intel_fdi_link_freq(i915, pipe_config);\n\n\tfdi_dotclock = adjusted_mode->crtc_clock;\n\n\tlane = ilk_get_lanes_required(fdi_dotclock, link_bw,\n\t\t\t\t      pipe_config->pipe_bpp);\n\n\tpipe_config->fdi_lanes = lane;\n\n\tintel_link_compute_m_n(pipe_config->pipe_bpp, lane, fdi_dotclock,\n\t\t\t       link_bw, &pipe_config->fdi_m_n, false);\n\n\tret = ilk_check_fdi_lanes(dev, crtc->pipe, pipe_config);\n\tif (ret == -EDEADLK)\n\t\treturn ret;\n\n\tif (ret == -EINVAL && pipe_config->pipe_bpp > 6*3) {\n\t\tpipe_config->pipe_bpp -= 2*3;\n\t\tdrm_dbg_kms(&i915->drm,\n\t\t\t    \"fdi link bw constraint, reducing pipe bpp to %i\\n\",\n\t\t\t    pipe_config->pipe_bpp);\n\t\tneeds_recompute = true;\n\t\tpipe_config->bw_constrained = true;\n\n\t\tgoto retry;\n\t}\n\n\tif (needs_recompute)\n\t\treturn -EAGAIN;\n\n\treturn ret;\n}\n\nstatic void cpt_set_fdi_bc_bifurcation(struct drm_i915_private *dev_priv, bool enable)\n{\n\tu32 temp;\n\n\ttemp = intel_de_read(dev_priv, SOUTH_CHICKEN1);\n\tif (!!(temp & FDI_BC_BIFURCATION_SELECT) == enable)\n\t\treturn;\n\n\tdrm_WARN_ON(&dev_priv->drm,\n\t\t    intel_de_read(dev_priv, FDI_RX_CTL(PIPE_B)) &\n\t\t    FDI_RX_ENABLE);\n\tdrm_WARN_ON(&dev_priv->drm,\n\t\t    intel_de_read(dev_priv, FDI_RX_CTL(PIPE_C)) &\n\t\t    FDI_RX_ENABLE);\n\n\ttemp &= ~FDI_BC_BIFURCATION_SELECT;\n\tif (enable)\n\t\ttemp |= FDI_BC_BIFURCATION_SELECT;\n\n\tdrm_dbg_kms(&dev_priv->drm, \"%sabling fdi C rx\\n\",\n\t\t    enable ? \"en\" : \"dis\");\n\tintel_de_write(dev_priv, SOUTH_CHICKEN1, temp);\n\tintel_de_posting_read(dev_priv, SOUTH_CHICKEN1);\n}\n\nstatic void ivb_update_fdi_bc_bifurcation(const struct intel_crtc_state *crtc_state)\n{\n\tstruct intel_crtc *crtc = to_intel_crtc(crtc_state->uapi.crtc);\n\tstruct drm_i915_private *dev_priv = to_i915(crtc->base.dev);\n\n\tswitch (crtc->pipe) {\n\tcase PIPE_A:\n\t\tbreak;\n\tcase PIPE_B:\n\t\tif (crtc_state->fdi_lanes > 2)\n\t\t\tcpt_set_fdi_bc_bifurcation(dev_priv, false);\n\t\telse\n\t\t\tcpt_set_fdi_bc_bifurcation(dev_priv, true);\n\n\t\tbreak;\n\tcase PIPE_C:\n\t\tcpt_set_fdi_bc_bifurcation(dev_priv, true);\n\n\t\tbreak;\n\tdefault:\n\t\tMISSING_CASE(crtc->pipe);\n\t}\n}\n\nvoid intel_fdi_normal_train(struct intel_crtc *crtc)\n{\n\tstruct drm_device *dev = crtc->base.dev;\n\tstruct drm_i915_private *dev_priv = to_i915(dev);\n\tenum pipe pipe = crtc->pipe;\n\ti915_reg_t reg;\n\tu32 temp;\n\n\t \n\treg = FDI_TX_CTL(pipe);\n\ttemp = intel_de_read(dev_priv, reg);\n\tif (IS_IVYBRIDGE(dev_priv)) {\n\t\ttemp &= ~FDI_LINK_TRAIN_NONE_IVB;\n\t\ttemp |= FDI_LINK_TRAIN_NONE_IVB | FDI_TX_ENHANCE_FRAME_ENABLE;\n\t} else {\n\t\ttemp &= ~FDI_LINK_TRAIN_NONE;\n\t\ttemp |= FDI_LINK_TRAIN_NONE | FDI_TX_ENHANCE_FRAME_ENABLE;\n\t}\n\tintel_de_write(dev_priv, reg, temp);\n\n\treg = FDI_RX_CTL(pipe);\n\ttemp = intel_de_read(dev_priv, reg);\n\tif (HAS_PCH_CPT(dev_priv)) {\n\t\ttemp &= ~FDI_LINK_TRAIN_PATTERN_MASK_CPT;\n\t\ttemp |= FDI_LINK_TRAIN_NORMAL_CPT;\n\t} else {\n\t\ttemp &= ~FDI_LINK_TRAIN_NONE;\n\t\ttemp |= FDI_LINK_TRAIN_NONE;\n\t}\n\tintel_de_write(dev_priv, reg, temp | FDI_RX_ENHANCE_FRAME_ENABLE);\n\n\t \n\tintel_de_posting_read(dev_priv, reg);\n\tudelay(1000);\n\n\t \n\tif (IS_IVYBRIDGE(dev_priv))\n\t\tintel_de_rmw(dev_priv, reg, 0, FDI_FS_ERRC_ENABLE | FDI_FE_ERRC_ENABLE);\n}\n\n \nstatic void ilk_fdi_link_train(struct intel_crtc *crtc,\n\t\t\t       const struct intel_crtc_state *crtc_state)\n{\n\tstruct drm_device *dev = crtc->base.dev;\n\tstruct drm_i915_private *dev_priv = to_i915(dev);\n\tenum pipe pipe = crtc->pipe;\n\ti915_reg_t reg;\n\tu32 temp, tries;\n\n\t \n\tintel_de_write(dev_priv, FDI_RX_TUSIZE1(pipe),\n\t\t       intel_de_read(dev_priv, PIPE_DATA_M1(pipe)) & TU_SIZE_MASK);\n\n\t \n\tassert_transcoder_enabled(dev_priv, crtc_state->cpu_transcoder);\n\n\t \n\treg = FDI_RX_IMR(pipe);\n\ttemp = intel_de_read(dev_priv, reg);\n\ttemp &= ~FDI_RX_SYMBOL_LOCK;\n\ttemp &= ~FDI_RX_BIT_LOCK;\n\tintel_de_write(dev_priv, reg, temp);\n\tintel_de_read(dev_priv, reg);\n\tudelay(150);\n\n\t \n\treg = FDI_TX_CTL(pipe);\n\ttemp = intel_de_read(dev_priv, reg);\n\ttemp &= ~FDI_DP_PORT_WIDTH_MASK;\n\ttemp |= FDI_DP_PORT_WIDTH(crtc_state->fdi_lanes);\n\ttemp &= ~FDI_LINK_TRAIN_NONE;\n\ttemp |= FDI_LINK_TRAIN_PATTERN_1;\n\tintel_de_write(dev_priv, reg, temp | FDI_TX_ENABLE);\n\n\treg = FDI_RX_CTL(pipe);\n\ttemp = intel_de_read(dev_priv, reg);\n\ttemp &= ~FDI_LINK_TRAIN_NONE;\n\ttemp |= FDI_LINK_TRAIN_PATTERN_1;\n\tintel_de_write(dev_priv, reg, temp | FDI_RX_ENABLE);\n\n\tintel_de_posting_read(dev_priv, reg);\n\tudelay(150);\n\n\t \n\tintel_de_write(dev_priv, FDI_RX_CHICKEN(pipe),\n\t\t       FDI_RX_PHASE_SYNC_POINTER_OVR);\n\tintel_de_write(dev_priv, FDI_RX_CHICKEN(pipe),\n\t\t       FDI_RX_PHASE_SYNC_POINTER_OVR | FDI_RX_PHASE_SYNC_POINTER_EN);\n\n\treg = FDI_RX_IIR(pipe);\n\tfor (tries = 0; tries < 5; tries++) {\n\t\ttemp = intel_de_read(dev_priv, reg);\n\t\tdrm_dbg_kms(&dev_priv->drm, \"FDI_RX_IIR 0x%x\\n\", temp);\n\n\t\tif ((temp & FDI_RX_BIT_LOCK)) {\n\t\t\tdrm_dbg_kms(&dev_priv->drm, \"FDI train 1 done.\\n\");\n\t\t\tintel_de_write(dev_priv, reg, temp | FDI_RX_BIT_LOCK);\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (tries == 5)\n\t\tdrm_err(&dev_priv->drm, \"FDI train 1 fail!\\n\");\n\n\t \n\tintel_de_rmw(dev_priv, FDI_TX_CTL(pipe),\n\t\t     FDI_LINK_TRAIN_NONE, FDI_LINK_TRAIN_PATTERN_2);\n\tintel_de_rmw(dev_priv, FDI_RX_CTL(pipe),\n\t\t     FDI_LINK_TRAIN_NONE, FDI_LINK_TRAIN_PATTERN_2);\n\tintel_de_posting_read(dev_priv, FDI_RX_CTL(pipe));\n\tudelay(150);\n\n\treg = FDI_RX_IIR(pipe);\n\tfor (tries = 0; tries < 5; tries++) {\n\t\ttemp = intel_de_read(dev_priv, reg);\n\t\tdrm_dbg_kms(&dev_priv->drm, \"FDI_RX_IIR 0x%x\\n\", temp);\n\n\t\tif (temp & FDI_RX_SYMBOL_LOCK) {\n\t\t\tintel_de_write(dev_priv, reg,\n\t\t\t\t       temp | FDI_RX_SYMBOL_LOCK);\n\t\t\tdrm_dbg_kms(&dev_priv->drm, \"FDI train 2 done.\\n\");\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (tries == 5)\n\t\tdrm_err(&dev_priv->drm, \"FDI train 2 fail!\\n\");\n\n\tdrm_dbg_kms(&dev_priv->drm, \"FDI train done\\n\");\n\n}\n\nstatic const int snb_b_fdi_train_param[] = {\n\tFDI_LINK_TRAIN_400MV_0DB_SNB_B,\n\tFDI_LINK_TRAIN_400MV_6DB_SNB_B,\n\tFDI_LINK_TRAIN_600MV_3_5DB_SNB_B,\n\tFDI_LINK_TRAIN_800MV_0DB_SNB_B,\n};\n\n \nstatic void gen6_fdi_link_train(struct intel_crtc *crtc,\n\t\t\t\tconst struct intel_crtc_state *crtc_state)\n{\n\tstruct drm_device *dev = crtc->base.dev;\n\tstruct drm_i915_private *dev_priv = to_i915(dev);\n\tenum pipe pipe = crtc->pipe;\n\ti915_reg_t reg;\n\tu32 temp, i, retry;\n\n\t \n\tintel_de_write(dev_priv, FDI_RX_TUSIZE1(pipe),\n\t\t       intel_de_read(dev_priv, PIPE_DATA_M1(pipe)) & TU_SIZE_MASK);\n\n\t \n\treg = FDI_RX_IMR(pipe);\n\ttemp = intel_de_read(dev_priv, reg);\n\ttemp &= ~FDI_RX_SYMBOL_LOCK;\n\ttemp &= ~FDI_RX_BIT_LOCK;\n\tintel_de_write(dev_priv, reg, temp);\n\n\tintel_de_posting_read(dev_priv, reg);\n\tudelay(150);\n\n\t \n\treg = FDI_TX_CTL(pipe);\n\ttemp = intel_de_read(dev_priv, reg);\n\ttemp &= ~FDI_DP_PORT_WIDTH_MASK;\n\ttemp |= FDI_DP_PORT_WIDTH(crtc_state->fdi_lanes);\n\ttemp &= ~FDI_LINK_TRAIN_NONE;\n\ttemp |= FDI_LINK_TRAIN_PATTERN_1;\n\ttemp &= ~FDI_LINK_TRAIN_VOL_EMP_MASK;\n\t \n\ttemp |= FDI_LINK_TRAIN_400MV_0DB_SNB_B;\n\tintel_de_write(dev_priv, reg, temp | FDI_TX_ENABLE);\n\n\tintel_de_write(dev_priv, FDI_RX_MISC(pipe),\n\t\t       FDI_RX_TP1_TO_TP2_48 | FDI_RX_FDI_DELAY_90);\n\n\treg = FDI_RX_CTL(pipe);\n\ttemp = intel_de_read(dev_priv, reg);\n\tif (HAS_PCH_CPT(dev_priv)) {\n\t\ttemp &= ~FDI_LINK_TRAIN_PATTERN_MASK_CPT;\n\t\ttemp |= FDI_LINK_TRAIN_PATTERN_1_CPT;\n\t} else {\n\t\ttemp &= ~FDI_LINK_TRAIN_NONE;\n\t\ttemp |= FDI_LINK_TRAIN_PATTERN_1;\n\t}\n\tintel_de_write(dev_priv, reg, temp | FDI_RX_ENABLE);\n\n\tintel_de_posting_read(dev_priv, reg);\n\tudelay(150);\n\n\tfor (i = 0; i < 4; i++) {\n\t\tintel_de_rmw(dev_priv, FDI_TX_CTL(pipe),\n\t\t\t     FDI_LINK_TRAIN_VOL_EMP_MASK, snb_b_fdi_train_param[i]);\n\t\tintel_de_posting_read(dev_priv, FDI_TX_CTL(pipe));\n\t\tudelay(500);\n\n\t\tfor (retry = 0; retry < 5; retry++) {\n\t\t\treg = FDI_RX_IIR(pipe);\n\t\t\ttemp = intel_de_read(dev_priv, reg);\n\t\t\tdrm_dbg_kms(&dev_priv->drm, \"FDI_RX_IIR 0x%x\\n\", temp);\n\t\t\tif (temp & FDI_RX_BIT_LOCK) {\n\t\t\t\tintel_de_write(dev_priv, reg,\n\t\t\t\t\t       temp | FDI_RX_BIT_LOCK);\n\t\t\t\tdrm_dbg_kms(&dev_priv->drm,\n\t\t\t\t\t    \"FDI train 1 done.\\n\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tudelay(50);\n\t\t}\n\t\tif (retry < 5)\n\t\t\tbreak;\n\t}\n\tif (i == 4)\n\t\tdrm_err(&dev_priv->drm, \"FDI train 1 fail!\\n\");\n\n\t \n\treg = FDI_TX_CTL(pipe);\n\ttemp = intel_de_read(dev_priv, reg);\n\ttemp &= ~FDI_LINK_TRAIN_NONE;\n\ttemp |= FDI_LINK_TRAIN_PATTERN_2;\n\tif (IS_SANDYBRIDGE(dev_priv)) {\n\t\ttemp &= ~FDI_LINK_TRAIN_VOL_EMP_MASK;\n\t\t \n\t\ttemp |= FDI_LINK_TRAIN_400MV_0DB_SNB_B;\n\t}\n\tintel_de_write(dev_priv, reg, temp);\n\n\treg = FDI_RX_CTL(pipe);\n\ttemp = intel_de_read(dev_priv, reg);\n\tif (HAS_PCH_CPT(dev_priv)) {\n\t\ttemp &= ~FDI_LINK_TRAIN_PATTERN_MASK_CPT;\n\t\ttemp |= FDI_LINK_TRAIN_PATTERN_2_CPT;\n\t} else {\n\t\ttemp &= ~FDI_LINK_TRAIN_NONE;\n\t\ttemp |= FDI_LINK_TRAIN_PATTERN_2;\n\t}\n\tintel_de_write(dev_priv, reg, temp);\n\n\tintel_de_posting_read(dev_priv, reg);\n\tudelay(150);\n\n\tfor (i = 0; i < 4; i++) {\n\t\tintel_de_rmw(dev_priv, FDI_TX_CTL(pipe),\n\t\t\t     FDI_LINK_TRAIN_VOL_EMP_MASK, snb_b_fdi_train_param[i]);\n\t\tintel_de_posting_read(dev_priv, FDI_TX_CTL(pipe));\n\t\tudelay(500);\n\n\t\tfor (retry = 0; retry < 5; retry++) {\n\t\t\treg = FDI_RX_IIR(pipe);\n\t\t\ttemp = intel_de_read(dev_priv, reg);\n\t\t\tdrm_dbg_kms(&dev_priv->drm, \"FDI_RX_IIR 0x%x\\n\", temp);\n\t\t\tif (temp & FDI_RX_SYMBOL_LOCK) {\n\t\t\t\tintel_de_write(dev_priv, reg,\n\t\t\t\t\t       temp | FDI_RX_SYMBOL_LOCK);\n\t\t\t\tdrm_dbg_kms(&dev_priv->drm,\n\t\t\t\t\t    \"FDI train 2 done.\\n\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tudelay(50);\n\t\t}\n\t\tif (retry < 5)\n\t\t\tbreak;\n\t}\n\tif (i == 4)\n\t\tdrm_err(&dev_priv->drm, \"FDI train 2 fail!\\n\");\n\n\tdrm_dbg_kms(&dev_priv->drm, \"FDI train done.\\n\");\n}\n\n \nstatic void ivb_manual_fdi_link_train(struct intel_crtc *crtc,\n\t\t\t\t      const struct intel_crtc_state *crtc_state)\n{\n\tstruct drm_device *dev = crtc->base.dev;\n\tstruct drm_i915_private *dev_priv = to_i915(dev);\n\tenum pipe pipe = crtc->pipe;\n\ti915_reg_t reg;\n\tu32 temp, i, j;\n\n\tivb_update_fdi_bc_bifurcation(crtc_state);\n\n\t \n\tintel_de_write(dev_priv, FDI_RX_TUSIZE1(pipe),\n\t\t       intel_de_read(dev_priv, PIPE_DATA_M1(pipe)) & TU_SIZE_MASK);\n\n\t \n\treg = FDI_RX_IMR(pipe);\n\ttemp = intel_de_read(dev_priv, reg);\n\ttemp &= ~FDI_RX_SYMBOL_LOCK;\n\ttemp &= ~FDI_RX_BIT_LOCK;\n\tintel_de_write(dev_priv, reg, temp);\n\n\tintel_de_posting_read(dev_priv, reg);\n\tudelay(150);\n\n\tdrm_dbg_kms(&dev_priv->drm, \"FDI_RX_IIR before link train 0x%x\\n\",\n\t\t    intel_de_read(dev_priv, FDI_RX_IIR(pipe)));\n\n\t \n\tfor (j = 0; j < ARRAY_SIZE(snb_b_fdi_train_param) * 2; j++) {\n\t\t \n\t\treg = FDI_TX_CTL(pipe);\n\t\ttemp = intel_de_read(dev_priv, reg);\n\t\ttemp &= ~(FDI_LINK_TRAIN_AUTO | FDI_LINK_TRAIN_NONE_IVB);\n\t\ttemp &= ~FDI_TX_ENABLE;\n\t\tintel_de_write(dev_priv, reg, temp);\n\n\t\treg = FDI_RX_CTL(pipe);\n\t\ttemp = intel_de_read(dev_priv, reg);\n\t\ttemp &= ~FDI_LINK_TRAIN_AUTO;\n\t\ttemp &= ~FDI_LINK_TRAIN_PATTERN_MASK_CPT;\n\t\ttemp &= ~FDI_RX_ENABLE;\n\t\tintel_de_write(dev_priv, reg, temp);\n\n\t\t \n\t\treg = FDI_TX_CTL(pipe);\n\t\ttemp = intel_de_read(dev_priv, reg);\n\t\ttemp &= ~FDI_DP_PORT_WIDTH_MASK;\n\t\ttemp |= FDI_DP_PORT_WIDTH(crtc_state->fdi_lanes);\n\t\ttemp |= FDI_LINK_TRAIN_PATTERN_1_IVB;\n\t\ttemp &= ~FDI_LINK_TRAIN_VOL_EMP_MASK;\n\t\ttemp |= snb_b_fdi_train_param[j/2];\n\t\ttemp |= FDI_COMPOSITE_SYNC;\n\t\tintel_de_write(dev_priv, reg, temp | FDI_TX_ENABLE);\n\n\t\tintel_de_write(dev_priv, FDI_RX_MISC(pipe),\n\t\t\t       FDI_RX_TP1_TO_TP2_48 | FDI_RX_FDI_DELAY_90);\n\n\t\treg = FDI_RX_CTL(pipe);\n\t\ttemp = intel_de_read(dev_priv, reg);\n\t\ttemp |= FDI_LINK_TRAIN_PATTERN_1_CPT;\n\t\ttemp |= FDI_COMPOSITE_SYNC;\n\t\tintel_de_write(dev_priv, reg, temp | FDI_RX_ENABLE);\n\n\t\tintel_de_posting_read(dev_priv, reg);\n\t\tudelay(1);  \n\n\t\tfor (i = 0; i < 4; i++) {\n\t\t\treg = FDI_RX_IIR(pipe);\n\t\t\ttemp = intel_de_read(dev_priv, reg);\n\t\t\tdrm_dbg_kms(&dev_priv->drm, \"FDI_RX_IIR 0x%x\\n\", temp);\n\n\t\t\tif (temp & FDI_RX_BIT_LOCK ||\n\t\t\t    (intel_de_read(dev_priv, reg) & FDI_RX_BIT_LOCK)) {\n\t\t\t\tintel_de_write(dev_priv, reg,\n\t\t\t\t\t       temp | FDI_RX_BIT_LOCK);\n\t\t\t\tdrm_dbg_kms(&dev_priv->drm,\n\t\t\t\t\t    \"FDI train 1 done, level %i.\\n\",\n\t\t\t\t\t    i);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tudelay(1);  \n\t\t}\n\t\tif (i == 4) {\n\t\t\tdrm_dbg_kms(&dev_priv->drm,\n\t\t\t\t    \"FDI train 1 fail on vswing %d\\n\", j / 2);\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\tintel_de_rmw(dev_priv, FDI_TX_CTL(pipe),\n\t\t\t     FDI_LINK_TRAIN_NONE_IVB,\n\t\t\t     FDI_LINK_TRAIN_PATTERN_2_IVB);\n\t\tintel_de_rmw(dev_priv, FDI_RX_CTL(pipe),\n\t\t\t     FDI_LINK_TRAIN_PATTERN_MASK_CPT,\n\t\t\t     FDI_LINK_TRAIN_PATTERN_2_CPT);\n\t\tintel_de_posting_read(dev_priv, FDI_RX_CTL(pipe));\n\t\tudelay(2);  \n\n\t\tfor (i = 0; i < 4; i++) {\n\t\t\treg = FDI_RX_IIR(pipe);\n\t\t\ttemp = intel_de_read(dev_priv, reg);\n\t\t\tdrm_dbg_kms(&dev_priv->drm, \"FDI_RX_IIR 0x%x\\n\", temp);\n\n\t\t\tif (temp & FDI_RX_SYMBOL_LOCK ||\n\t\t\t    (intel_de_read(dev_priv, reg) & FDI_RX_SYMBOL_LOCK)) {\n\t\t\t\tintel_de_write(dev_priv, reg,\n\t\t\t\t\t       temp | FDI_RX_SYMBOL_LOCK);\n\t\t\t\tdrm_dbg_kms(&dev_priv->drm,\n\t\t\t\t\t    \"FDI train 2 done, level %i.\\n\",\n\t\t\t\t\t    i);\n\t\t\t\tgoto train_done;\n\t\t\t}\n\t\t\tudelay(2);  \n\t\t}\n\t\tif (i == 4)\n\t\t\tdrm_dbg_kms(&dev_priv->drm,\n\t\t\t\t    \"FDI train 2 fail on vswing %d\\n\", j / 2);\n\t}\n\ntrain_done:\n\tdrm_dbg_kms(&dev_priv->drm, \"FDI train done.\\n\");\n}\n\n \nvoid hsw_fdi_link_train(struct intel_encoder *encoder,\n\t\t\tconst struct intel_crtc_state *crtc_state)\n{\n\tstruct intel_crtc *crtc = to_intel_crtc(crtc_state->uapi.crtc);\n\tstruct drm_i915_private *dev_priv = to_i915(crtc->base.dev);\n\tu32 temp, i, rx_ctl_val;\n\tint n_entries;\n\n\tencoder->get_buf_trans(encoder, crtc_state, &n_entries);\n\n\thsw_prepare_dp_ddi_buffers(encoder, crtc_state);\n\n\t \n\tintel_de_write(dev_priv, FDI_RX_MISC(PIPE_A),\n\t\t       FDI_RX_PWRDN_LANE1_VAL(2) | FDI_RX_PWRDN_LANE0_VAL(2) | FDI_RX_TP1_TO_TP2_48 | FDI_RX_FDI_DELAY_90);\n\n\t \n\trx_ctl_val = dev_priv->display.fdi.rx_config | FDI_RX_ENHANCE_FRAME_ENABLE |\n\t\t     FDI_RX_PLL_ENABLE |\n\t\t     FDI_DP_PORT_WIDTH(crtc_state->fdi_lanes);\n\tintel_de_write(dev_priv, FDI_RX_CTL(PIPE_A), rx_ctl_val);\n\tintel_de_posting_read(dev_priv, FDI_RX_CTL(PIPE_A));\n\tudelay(220);\n\n\t \n\trx_ctl_val |= FDI_PCDCLK;\n\tintel_de_write(dev_priv, FDI_RX_CTL(PIPE_A), rx_ctl_val);\n\n\t \n\tdrm_WARN_ON(&dev_priv->drm, crtc_state->shared_dpll->info->id != DPLL_ID_SPLL);\n\tintel_ddi_enable_clock(encoder, crtc_state);\n\n\t \n\tfor (i = 0; i < n_entries * 2; i++) {\n\t\t \n\t\tintel_de_write(dev_priv, DP_TP_CTL(PORT_E),\n\t\t\t       DP_TP_CTL_FDI_AUTOTRAIN |\n\t\t\t       DP_TP_CTL_ENHANCED_FRAME_ENABLE |\n\t\t\t       DP_TP_CTL_LINK_TRAIN_PAT1 |\n\t\t\t       DP_TP_CTL_ENABLE);\n\n\t\t \n\t\tintel_de_write(dev_priv, DDI_BUF_CTL(PORT_E),\n\t\t\t       DDI_BUF_CTL_ENABLE | ((crtc_state->fdi_lanes - 1) << 1) | DDI_BUF_TRANS_SELECT(i / 2));\n\t\tintel_de_posting_read(dev_priv, DDI_BUF_CTL(PORT_E));\n\n\t\tudelay(600);\n\n\t\t \n\t\tintel_de_write(dev_priv, FDI_RX_TUSIZE1(PIPE_A), TU_SIZE(64));\n\n\t\t \n\t\trx_ctl_val |= FDI_RX_ENABLE | FDI_LINK_TRAIN_AUTO;\n\t\tintel_de_write(dev_priv, FDI_RX_CTL(PIPE_A), rx_ctl_val);\n\t\tintel_de_posting_read(dev_priv, FDI_RX_CTL(PIPE_A));\n\n\t\t \n\t\tudelay(30);\n\n\t\t \n\t\tintel_de_rmw(dev_priv, FDI_RX_MISC(PIPE_A),\n\t\t\t     FDI_RX_PWRDN_LANE1_MASK | FDI_RX_PWRDN_LANE0_MASK, 0);\n\t\tintel_de_posting_read(dev_priv, FDI_RX_MISC(PIPE_A));\n\n\t\t \n\t\tudelay(5);\n\n\t\ttemp = intel_de_read(dev_priv, DP_TP_STATUS(PORT_E));\n\t\tif (temp & DP_TP_STATUS_AUTOTRAIN_DONE) {\n\t\t\tdrm_dbg_kms(&dev_priv->drm,\n\t\t\t\t    \"FDI link training done on step %d\\n\", i);\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\tif (i == n_entries * 2 - 1) {\n\t\t\tdrm_err(&dev_priv->drm, \"FDI link training failed!\\n\");\n\t\t\tbreak;\n\t\t}\n\n\t\trx_ctl_val &= ~FDI_RX_ENABLE;\n\t\tintel_de_write(dev_priv, FDI_RX_CTL(PIPE_A), rx_ctl_val);\n\t\tintel_de_posting_read(dev_priv, FDI_RX_CTL(PIPE_A));\n\n\t\tintel_de_rmw(dev_priv, DDI_BUF_CTL(PORT_E), DDI_BUF_CTL_ENABLE, 0);\n\t\tintel_de_posting_read(dev_priv, DDI_BUF_CTL(PORT_E));\n\n\t\t \n\t\tintel_de_rmw(dev_priv, DP_TP_CTL(PORT_E), DP_TP_CTL_ENABLE, 0);\n\t\tintel_de_posting_read(dev_priv, DP_TP_CTL(PORT_E));\n\n\t\tintel_wait_ddi_buf_idle(dev_priv, PORT_E);\n\n\t\t \n\t\tintel_de_rmw(dev_priv, FDI_RX_MISC(PIPE_A),\n\t\t\t     FDI_RX_PWRDN_LANE1_MASK | FDI_RX_PWRDN_LANE0_MASK,\n\t\t\t     FDI_RX_PWRDN_LANE1_VAL(2) | FDI_RX_PWRDN_LANE0_VAL(2));\n\t\tintel_de_posting_read(dev_priv, FDI_RX_MISC(PIPE_A));\n\t}\n\n\t \n\tintel_de_write(dev_priv, DP_TP_CTL(PORT_E),\n\t\t       DP_TP_CTL_FDI_AUTOTRAIN |\n\t\t       DP_TP_CTL_LINK_TRAIN_NORMAL |\n\t\t       DP_TP_CTL_ENHANCED_FRAME_ENABLE |\n\t\t       DP_TP_CTL_ENABLE);\n}\n\nvoid hsw_fdi_disable(struct intel_encoder *encoder)\n{\n\tstruct drm_i915_private *dev_priv = to_i915(encoder->base.dev);\n\n\t \n\tintel_de_rmw(dev_priv, FDI_RX_CTL(PIPE_A), FDI_RX_ENABLE, 0);\n\tintel_de_rmw(dev_priv, DDI_BUF_CTL(PORT_E), DDI_BUF_CTL_ENABLE, 0);\n\tintel_wait_ddi_buf_idle(dev_priv, PORT_E);\n\tintel_ddi_disable_clock(encoder);\n\tintel_de_rmw(dev_priv, FDI_RX_MISC(PIPE_A),\n\t\t     FDI_RX_PWRDN_LANE1_MASK | FDI_RX_PWRDN_LANE0_MASK,\n\t\t     FDI_RX_PWRDN_LANE1_VAL(2) | FDI_RX_PWRDN_LANE0_VAL(2));\n\tintel_de_rmw(dev_priv, FDI_RX_CTL(PIPE_A), FDI_PCDCLK, 0);\n\tintel_de_rmw(dev_priv, FDI_RX_CTL(PIPE_A), FDI_RX_PLL_ENABLE, 0);\n}\n\nvoid ilk_fdi_pll_enable(const struct intel_crtc_state *crtc_state)\n{\n\tstruct intel_crtc *crtc = to_intel_crtc(crtc_state->uapi.crtc);\n\tstruct drm_i915_private *dev_priv = to_i915(crtc->base.dev);\n\tenum pipe pipe = crtc->pipe;\n\ti915_reg_t reg;\n\tu32 temp;\n\n\t \n\treg = FDI_RX_CTL(pipe);\n\ttemp = intel_de_read(dev_priv, reg);\n\ttemp &= ~(FDI_DP_PORT_WIDTH_MASK | (0x7 << 16));\n\ttemp |= FDI_DP_PORT_WIDTH(crtc_state->fdi_lanes);\n\ttemp |= (intel_de_read(dev_priv, TRANSCONF(pipe)) & TRANSCONF_BPC_MASK) << 11;\n\tintel_de_write(dev_priv, reg, temp | FDI_RX_PLL_ENABLE);\n\n\tintel_de_posting_read(dev_priv, reg);\n\tudelay(200);\n\n\t \n\tintel_de_rmw(dev_priv, reg, 0, FDI_PCDCLK);\n\tintel_de_posting_read(dev_priv, reg);\n\tudelay(200);\n\n\t \n\treg = FDI_TX_CTL(pipe);\n\ttemp = intel_de_read(dev_priv, reg);\n\tif ((temp & FDI_TX_PLL_ENABLE) == 0) {\n\t\tintel_de_write(dev_priv, reg, temp | FDI_TX_PLL_ENABLE);\n\n\t\tintel_de_posting_read(dev_priv, reg);\n\t\tudelay(100);\n\t}\n}\n\nvoid ilk_fdi_pll_disable(struct intel_crtc *crtc)\n{\n\tstruct drm_device *dev = crtc->base.dev;\n\tstruct drm_i915_private *dev_priv = to_i915(dev);\n\tenum pipe pipe = crtc->pipe;\n\n\t \n\tintel_de_rmw(dev_priv, FDI_RX_CTL(pipe), FDI_PCDCLK, 0);\n\n\t \n\tintel_de_rmw(dev_priv, FDI_TX_CTL(pipe), FDI_TX_PLL_ENABLE, 0);\n\tintel_de_posting_read(dev_priv, FDI_TX_CTL(pipe));\n\tudelay(100);\n\n\t \n\tintel_de_rmw(dev_priv, FDI_RX_CTL(pipe), FDI_RX_PLL_ENABLE, 0);\n\tintel_de_posting_read(dev_priv, FDI_RX_CTL(pipe));\n\tudelay(100);\n}\n\nvoid ilk_fdi_disable(struct intel_crtc *crtc)\n{\n\tstruct drm_i915_private *dev_priv = to_i915(crtc->base.dev);\n\tenum pipe pipe = crtc->pipe;\n\ti915_reg_t reg;\n\tu32 temp;\n\n\t \n\tintel_de_rmw(dev_priv, FDI_TX_CTL(pipe), FDI_TX_ENABLE, 0);\n\tintel_de_posting_read(dev_priv, FDI_TX_CTL(pipe));\n\n\treg = FDI_RX_CTL(pipe);\n\ttemp = intel_de_read(dev_priv, reg);\n\ttemp &= ~(0x7 << 16);\n\ttemp |= (intel_de_read(dev_priv, TRANSCONF(pipe)) & TRANSCONF_BPC_MASK) << 11;\n\tintel_de_write(dev_priv, reg, temp & ~FDI_RX_ENABLE);\n\n\tintel_de_posting_read(dev_priv, reg);\n\tudelay(100);\n\n\t \n\tif (HAS_PCH_IBX(dev_priv))\n\t\tintel_de_write(dev_priv, FDI_RX_CHICKEN(pipe),\n\t\t\t       FDI_RX_PHASE_SYNC_POINTER_OVR);\n\n\t \n\tintel_de_rmw(dev_priv, FDI_TX_CTL(pipe),\n\t\t     FDI_LINK_TRAIN_NONE, FDI_LINK_TRAIN_PATTERN_1);\n\n\treg = FDI_RX_CTL(pipe);\n\ttemp = intel_de_read(dev_priv, reg);\n\tif (HAS_PCH_CPT(dev_priv)) {\n\t\ttemp &= ~FDI_LINK_TRAIN_PATTERN_MASK_CPT;\n\t\ttemp |= FDI_LINK_TRAIN_PATTERN_1_CPT;\n\t} else {\n\t\ttemp &= ~FDI_LINK_TRAIN_NONE;\n\t\ttemp |= FDI_LINK_TRAIN_PATTERN_1;\n\t}\n\t \n\ttemp &= ~(0x07 << 16);\n\ttemp |= (intel_de_read(dev_priv, TRANSCONF(pipe)) & TRANSCONF_BPC_MASK) << 11;\n\tintel_de_write(dev_priv, reg, temp);\n\n\tintel_de_posting_read(dev_priv, reg);\n\tudelay(100);\n}\n\nstatic const struct intel_fdi_funcs ilk_funcs = {\n\t.fdi_link_train = ilk_fdi_link_train,\n};\n\nstatic const struct intel_fdi_funcs gen6_funcs = {\n\t.fdi_link_train = gen6_fdi_link_train,\n};\n\nstatic const struct intel_fdi_funcs ivb_funcs = {\n\t.fdi_link_train = ivb_manual_fdi_link_train,\n};\n\nvoid\nintel_fdi_init_hook(struct drm_i915_private *dev_priv)\n{\n\tif (IS_IRONLAKE(dev_priv)) {\n\t\tdev_priv->display.funcs.fdi = &ilk_funcs;\n\t} else if (IS_SANDYBRIDGE(dev_priv)) {\n\t\tdev_priv->display.funcs.fdi = &gen6_funcs;\n\t} else if (IS_IVYBRIDGE(dev_priv)) {\n\t\t \n\t\tdev_priv->display.funcs.fdi = &ivb_funcs;\n\t}\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}