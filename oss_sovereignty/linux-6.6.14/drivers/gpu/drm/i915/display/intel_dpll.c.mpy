{
  "module_name": "intel_dpll.c",
  "hash_id": "79e8ec6756df20b2a5ea4bb3c65766daa14888cc794d47704514c61db75e55f5",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/i915/display/intel_dpll.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/string_helpers.h>\n\n#include \"i915_reg.h\"\n#include \"intel_crtc.h\"\n#include \"intel_cx0_phy.h\"\n#include \"intel_de.h\"\n#include \"intel_display.h\"\n#include \"intel_display_types.h\"\n#include \"intel_dpio_phy.h\"\n#include \"intel_dpll.h\"\n#include \"intel_lvds.h\"\n#include \"intel_panel.h\"\n#include \"intel_pps.h\"\n#include \"intel_snps_phy.h\"\n#include \"vlv_sideband.h\"\n\nstruct intel_dpll_funcs {\n\tint (*crtc_compute_clock)(struct intel_atomic_state *state,\n\t\t\t\t  struct intel_crtc *crtc);\n\tint (*crtc_get_shared_dpll)(struct intel_atomic_state *state,\n\t\t\t\t    struct intel_crtc *crtc);\n};\n\nstruct intel_limit {\n\tstruct {\n\t\tint min, max;\n\t} dot, vco, n, m, m1, m2, p, p1;\n\n\tstruct {\n\t\tint dot_limit;\n\t\tint p2_slow, p2_fast;\n\t} p2;\n};\nstatic const struct intel_limit intel_limits_i8xx_dac = {\n\t.dot = { .min = 25000, .max = 350000 },\n\t.vco = { .min = 908000, .max = 1512000 },\n\t.n = { .min = 2, .max = 16 },\n\t.m = { .min = 96, .max = 140 },\n\t.m1 = { .min = 18, .max = 26 },\n\t.m2 = { .min = 6, .max = 16 },\n\t.p = { .min = 4, .max = 128 },\n\t.p1 = { .min = 2, .max = 33 },\n\t.p2 = { .dot_limit = 165000,\n\t\t.p2_slow = 4, .p2_fast = 2 },\n};\n\nstatic const struct intel_limit intel_limits_i8xx_dvo = {\n\t.dot = { .min = 25000, .max = 350000 },\n\t.vco = { .min = 908000, .max = 1512000 },\n\t.n = { .min = 2, .max = 16 },\n\t.m = { .min = 96, .max = 140 },\n\t.m1 = { .min = 18, .max = 26 },\n\t.m2 = { .min = 6, .max = 16 },\n\t.p = { .min = 4, .max = 128 },\n\t.p1 = { .min = 2, .max = 33 },\n\t.p2 = { .dot_limit = 165000,\n\t\t.p2_slow = 4, .p2_fast = 4 },\n};\n\nstatic const struct intel_limit intel_limits_i8xx_lvds = {\n\t.dot = { .min = 25000, .max = 350000 },\n\t.vco = { .min = 908000, .max = 1512000 },\n\t.n = { .min = 2, .max = 16 },\n\t.m = { .min = 96, .max = 140 },\n\t.m1 = { .min = 18, .max = 26 },\n\t.m2 = { .min = 6, .max = 16 },\n\t.p = { .min = 4, .max = 128 },\n\t.p1 = { .min = 1, .max = 6 },\n\t.p2 = { .dot_limit = 165000,\n\t\t.p2_slow = 14, .p2_fast = 7 },\n};\n\nstatic const struct intel_limit intel_limits_i9xx_sdvo = {\n\t.dot = { .min = 20000, .max = 400000 },\n\t.vco = { .min = 1400000, .max = 2800000 },\n\t.n = { .min = 1, .max = 6 },\n\t.m = { .min = 70, .max = 120 },\n\t.m1 = { .min = 8, .max = 18 },\n\t.m2 = { .min = 3, .max = 7 },\n\t.p = { .min = 5, .max = 80 },\n\t.p1 = { .min = 1, .max = 8 },\n\t.p2 = { .dot_limit = 200000,\n\t\t.p2_slow = 10, .p2_fast = 5 },\n};\n\nstatic const struct intel_limit intel_limits_i9xx_lvds = {\n\t.dot = { .min = 20000, .max = 400000 },\n\t.vco = { .min = 1400000, .max = 2800000 },\n\t.n = { .min = 1, .max = 6 },\n\t.m = { .min = 70, .max = 120 },\n\t.m1 = { .min = 8, .max = 18 },\n\t.m2 = { .min = 3, .max = 7 },\n\t.p = { .min = 7, .max = 98 },\n\t.p1 = { .min = 1, .max = 8 },\n\t.p2 = { .dot_limit = 112000,\n\t\t.p2_slow = 14, .p2_fast = 7 },\n};\n\n\nstatic const struct intel_limit intel_limits_g4x_sdvo = {\n\t.dot = { .min = 25000, .max = 270000 },\n\t.vco = { .min = 1750000, .max = 3500000},\n\t.n = { .min = 1, .max = 4 },\n\t.m = { .min = 104, .max = 138 },\n\t.m1 = { .min = 17, .max = 23 },\n\t.m2 = { .min = 5, .max = 11 },\n\t.p = { .min = 10, .max = 30 },\n\t.p1 = { .min = 1, .max = 3},\n\t.p2 = { .dot_limit = 270000,\n\t\t.p2_slow = 10,\n\t\t.p2_fast = 10\n\t},\n};\n\nstatic const struct intel_limit intel_limits_g4x_hdmi = {\n\t.dot = { .min = 22000, .max = 400000 },\n\t.vco = { .min = 1750000, .max = 3500000},\n\t.n = { .min = 1, .max = 4 },\n\t.m = { .min = 104, .max = 138 },\n\t.m1 = { .min = 16, .max = 23 },\n\t.m2 = { .min = 5, .max = 11 },\n\t.p = { .min = 5, .max = 80 },\n\t.p1 = { .min = 1, .max = 8},\n\t.p2 = { .dot_limit = 165000,\n\t\t.p2_slow = 10, .p2_fast = 5 },\n};\n\nstatic const struct intel_limit intel_limits_g4x_single_channel_lvds = {\n\t.dot = { .min = 20000, .max = 115000 },\n\t.vco = { .min = 1750000, .max = 3500000 },\n\t.n = { .min = 1, .max = 3 },\n\t.m = { .min = 104, .max = 138 },\n\t.m1 = { .min = 17, .max = 23 },\n\t.m2 = { .min = 5, .max = 11 },\n\t.p = { .min = 28, .max = 112 },\n\t.p1 = { .min = 2, .max = 8 },\n\t.p2 = { .dot_limit = 0,\n\t\t.p2_slow = 14, .p2_fast = 14\n\t},\n};\n\nstatic const struct intel_limit intel_limits_g4x_dual_channel_lvds = {\n\t.dot = { .min = 80000, .max = 224000 },\n\t.vco = { .min = 1750000, .max = 3500000 },\n\t.n = { .min = 1, .max = 3 },\n\t.m = { .min = 104, .max = 138 },\n\t.m1 = { .min = 17, .max = 23 },\n\t.m2 = { .min = 5, .max = 11 },\n\t.p = { .min = 14, .max = 42 },\n\t.p1 = { .min = 2, .max = 6 },\n\t.p2 = { .dot_limit = 0,\n\t\t.p2_slow = 7, .p2_fast = 7\n\t},\n};\n\nstatic const struct intel_limit pnv_limits_sdvo = {\n\t.dot = { .min = 20000, .max = 400000},\n\t.vco = { .min = 1700000, .max = 3500000 },\n\t \n\t.n = { .min = 3, .max = 6 },\n\t.m = { .min = 2, .max = 256 },\n\t \n\t.m1 = { .min = 0, .max = 0 },\n\t.m2 = { .min = 0, .max = 254 },\n\t.p = { .min = 5, .max = 80 },\n\t.p1 = { .min = 1, .max = 8 },\n\t.p2 = { .dot_limit = 200000,\n\t\t.p2_slow = 10, .p2_fast = 5 },\n};\n\nstatic const struct intel_limit pnv_limits_lvds = {\n\t.dot = { .min = 20000, .max = 400000 },\n\t.vco = { .min = 1700000, .max = 3500000 },\n\t.n = { .min = 3, .max = 6 },\n\t.m = { .min = 2, .max = 256 },\n\t.m1 = { .min = 0, .max = 0 },\n\t.m2 = { .min = 0, .max = 254 },\n\t.p = { .min = 7, .max = 112 },\n\t.p1 = { .min = 1, .max = 8 },\n\t.p2 = { .dot_limit = 112000,\n\t\t.p2_slow = 14, .p2_fast = 14 },\n};\n\n \nstatic const struct intel_limit ilk_limits_dac = {\n\t.dot = { .min = 25000, .max = 350000 },\n\t.vco = { .min = 1760000, .max = 3510000 },\n\t.n = { .min = 1, .max = 5 },\n\t.m = { .min = 79, .max = 127 },\n\t.m1 = { .min = 12, .max = 22 },\n\t.m2 = { .min = 5, .max = 9 },\n\t.p = { .min = 5, .max = 80 },\n\t.p1 = { .min = 1, .max = 8 },\n\t.p2 = { .dot_limit = 225000,\n\t\t.p2_slow = 10, .p2_fast = 5 },\n};\n\nstatic const struct intel_limit ilk_limits_single_lvds = {\n\t.dot = { .min = 25000, .max = 350000 },\n\t.vco = { .min = 1760000, .max = 3510000 },\n\t.n = { .min = 1, .max = 3 },\n\t.m = { .min = 79, .max = 118 },\n\t.m1 = { .min = 12, .max = 22 },\n\t.m2 = { .min = 5, .max = 9 },\n\t.p = { .min = 28, .max = 112 },\n\t.p1 = { .min = 2, .max = 8 },\n\t.p2 = { .dot_limit = 225000,\n\t\t.p2_slow = 14, .p2_fast = 14 },\n};\n\nstatic const struct intel_limit ilk_limits_dual_lvds = {\n\t.dot = { .min = 25000, .max = 350000 },\n\t.vco = { .min = 1760000, .max = 3510000 },\n\t.n = { .min = 1, .max = 3 },\n\t.m = { .min = 79, .max = 127 },\n\t.m1 = { .min = 12, .max = 22 },\n\t.m2 = { .min = 5, .max = 9 },\n\t.p = { .min = 14, .max = 56 },\n\t.p1 = { .min = 2, .max = 8 },\n\t.p2 = { .dot_limit = 225000,\n\t\t.p2_slow = 7, .p2_fast = 7 },\n};\n\n \nstatic const struct intel_limit ilk_limits_single_lvds_100m = {\n\t.dot = { .min = 25000, .max = 350000 },\n\t.vco = { .min = 1760000, .max = 3510000 },\n\t.n = { .min = 1, .max = 2 },\n\t.m = { .min = 79, .max = 126 },\n\t.m1 = { .min = 12, .max = 22 },\n\t.m2 = { .min = 5, .max = 9 },\n\t.p = { .min = 28, .max = 112 },\n\t.p1 = { .min = 2, .max = 8 },\n\t.p2 = { .dot_limit = 225000,\n\t\t.p2_slow = 14, .p2_fast = 14 },\n};\n\nstatic const struct intel_limit ilk_limits_dual_lvds_100m = {\n\t.dot = { .min = 25000, .max = 350000 },\n\t.vco = { .min = 1760000, .max = 3510000 },\n\t.n = { .min = 1, .max = 3 },\n\t.m = { .min = 79, .max = 126 },\n\t.m1 = { .min = 12, .max = 22 },\n\t.m2 = { .min = 5, .max = 9 },\n\t.p = { .min = 14, .max = 42 },\n\t.p1 = { .min = 2, .max = 6 },\n\t.p2 = { .dot_limit = 225000,\n\t\t.p2_slow = 7, .p2_fast = 7 },\n};\n\nstatic const struct intel_limit intel_limits_vlv = {\n\t  \n\t.dot = { .min = 25000, .max = 270000 },\n\t.vco = { .min = 4000000, .max = 6000000 },\n\t.n = { .min = 1, .max = 7 },\n\t.m1 = { .min = 2, .max = 3 },\n\t.m2 = { .min = 11, .max = 156 },\n\t.p1 = { .min = 2, .max = 3 },\n\t.p2 = { .p2_slow = 2, .p2_fast = 20 },  \n};\n\nstatic const struct intel_limit intel_limits_chv = {\n\t \n\t.dot = { .min = 25000, .max = 540000 },\n\t.vco = { .min = 4800000, .max = 6480000 },\n\t.n = { .min = 1, .max = 1 },\n\t.m1 = { .min = 2, .max = 2 },\n\t.m2 = { .min = 24 << 22, .max = 175 << 22 },\n\t.p1 = { .min = 2, .max = 4 },\n\t.p2 = {\t.p2_slow = 1, .p2_fast = 14 },\n};\n\nstatic const struct intel_limit intel_limits_bxt = {\n\t.dot = { .min = 25000, .max = 594000 },\n\t.vco = { .min = 4800000, .max = 6700000 },\n\t.n = { .min = 1, .max = 1 },\n\t.m1 = { .min = 2, .max = 2 },\n\t \n\t.m2 = { .min = 2 << 22, .max = 255 << 22 },\n\t.p1 = { .min = 2, .max = 4 },\n\t.p2 = { .p2_slow = 1, .p2_fast = 20 },\n};\n\n \n \nint pnv_calc_dpll_params(int refclk, struct dpll *clock)\n{\n\tclock->m = clock->m2 + 2;\n\tclock->p = clock->p1 * clock->p2;\n\tif (WARN_ON(clock->n == 0 || clock->p == 0))\n\t\treturn 0;\n\tclock->vco = DIV_ROUND_CLOSEST(refclk * clock->m, clock->n);\n\tclock->dot = DIV_ROUND_CLOSEST(clock->vco, clock->p);\n\n\treturn clock->dot;\n}\n\nstatic u32 i9xx_dpll_compute_m(const struct dpll *dpll)\n{\n\treturn 5 * (dpll->m1 + 2) + (dpll->m2 + 2);\n}\n\nint i9xx_calc_dpll_params(int refclk, struct dpll *clock)\n{\n\tclock->m = i9xx_dpll_compute_m(clock);\n\tclock->p = clock->p1 * clock->p2;\n\tif (WARN_ON(clock->n + 2 == 0 || clock->p == 0))\n\t\treturn 0;\n\tclock->vco = DIV_ROUND_CLOSEST(refclk * clock->m, clock->n + 2);\n\tclock->dot = DIV_ROUND_CLOSEST(clock->vco, clock->p);\n\n\treturn clock->dot;\n}\n\nint vlv_calc_dpll_params(int refclk, struct dpll *clock)\n{\n\tclock->m = clock->m1 * clock->m2;\n\tclock->p = clock->p1 * clock->p2 * 5;\n\tif (WARN_ON(clock->n == 0 || clock->p == 0))\n\t\treturn 0;\n\tclock->vco = DIV_ROUND_CLOSEST(refclk * clock->m, clock->n);\n\tclock->dot = DIV_ROUND_CLOSEST(clock->vco, clock->p);\n\n\treturn clock->dot;\n}\n\nint chv_calc_dpll_params(int refclk, struct dpll *clock)\n{\n\tclock->m = clock->m1 * clock->m2;\n\tclock->p = clock->p1 * clock->p2 * 5;\n\tif (WARN_ON(clock->n == 0 || clock->p == 0))\n\t\treturn 0;\n\tclock->vco = DIV_ROUND_CLOSEST_ULL(mul_u32_u32(refclk, clock->m),\n\t\t\t\t\t   clock->n << 22);\n\tclock->dot = DIV_ROUND_CLOSEST(clock->vco, clock->p);\n\n\treturn clock->dot;\n}\n\n \nstatic bool intel_pll_is_valid(struct drm_i915_private *dev_priv,\n\t\t\t       const struct intel_limit *limit,\n\t\t\t       const struct dpll *clock)\n{\n\tif (clock->n < limit->n.min || limit->n.max < clock->n)\n\t\treturn false;\n\tif (clock->p1 < limit->p1.min || limit->p1.max < clock->p1)\n\t\treturn false;\n\tif (clock->m2 < limit->m2.min || limit->m2.max < clock->m2)\n\t\treturn false;\n\tif (clock->m1 < limit->m1.min || limit->m1.max < clock->m1)\n\t\treturn false;\n\n\tif (!IS_PINEVIEW(dev_priv) && !IS_LP(dev_priv))\n\t\tif (clock->m1 <= clock->m2)\n\t\t\treturn false;\n\n\tif (!IS_LP(dev_priv)) {\n\t\tif (clock->p < limit->p.min || limit->p.max < clock->p)\n\t\t\treturn false;\n\t\tif (clock->m < limit->m.min || limit->m.max < clock->m)\n\t\t\treturn false;\n\t}\n\n\tif (clock->vco < limit->vco.min || limit->vco.max < clock->vco)\n\t\treturn false;\n\t \n\tif (clock->dot < limit->dot.min || limit->dot.max < clock->dot)\n\t\treturn false;\n\n\treturn true;\n}\n\nstatic int\ni9xx_select_p2_div(const struct intel_limit *limit,\n\t\t   const struct intel_crtc_state *crtc_state,\n\t\t   int target)\n{\n\tstruct drm_i915_private *dev_priv = to_i915(crtc_state->uapi.crtc->dev);\n\n\tif (intel_crtc_has_type(crtc_state, INTEL_OUTPUT_LVDS)) {\n\t\t \n\t\tif (intel_is_dual_link_lvds(dev_priv))\n\t\t\treturn limit->p2.p2_fast;\n\t\telse\n\t\t\treturn limit->p2.p2_slow;\n\t} else {\n\t\tif (target < limit->p2.dot_limit)\n\t\t\treturn limit->p2.p2_slow;\n\t\telse\n\t\t\treturn limit->p2.p2_fast;\n\t}\n}\n\n \nstatic bool\ni9xx_find_best_dpll(const struct intel_limit *limit,\n\t\t    struct intel_crtc_state *crtc_state,\n\t\t    int target, int refclk,\n\t\t    const struct dpll *match_clock,\n\t\t    struct dpll *best_clock)\n{\n\tstruct drm_device *dev = crtc_state->uapi.crtc->dev;\n\tstruct dpll clock;\n\tint err = target;\n\n\tmemset(best_clock, 0, sizeof(*best_clock));\n\n\tclock.p2 = i9xx_select_p2_div(limit, crtc_state, target);\n\n\tfor (clock.m1 = limit->m1.min; clock.m1 <= limit->m1.max;\n\t     clock.m1++) {\n\t\tfor (clock.m2 = limit->m2.min;\n\t\t     clock.m2 <= limit->m2.max; clock.m2++) {\n\t\t\tif (clock.m2 >= clock.m1)\n\t\t\t\tbreak;\n\t\t\tfor (clock.n = limit->n.min;\n\t\t\t     clock.n <= limit->n.max; clock.n++) {\n\t\t\t\tfor (clock.p1 = limit->p1.min;\n\t\t\t\t\tclock.p1 <= limit->p1.max; clock.p1++) {\n\t\t\t\t\tint this_err;\n\n\t\t\t\t\ti9xx_calc_dpll_params(refclk, &clock);\n\t\t\t\t\tif (!intel_pll_is_valid(to_i915(dev),\n\t\t\t\t\t\t\t\tlimit,\n\t\t\t\t\t\t\t\t&clock))\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tif (match_clock &&\n\t\t\t\t\t    clock.p != match_clock->p)\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\tthis_err = abs(clock.dot - target);\n\t\t\t\t\tif (this_err < err) {\n\t\t\t\t\t\t*best_clock = clock;\n\t\t\t\t\t\terr = this_err;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn (err != target);\n}\n\n \nstatic bool\npnv_find_best_dpll(const struct intel_limit *limit,\n\t\t   struct intel_crtc_state *crtc_state,\n\t\t   int target, int refclk,\n\t\t   const struct dpll *match_clock,\n\t\t   struct dpll *best_clock)\n{\n\tstruct drm_device *dev = crtc_state->uapi.crtc->dev;\n\tstruct dpll clock;\n\tint err = target;\n\n\tmemset(best_clock, 0, sizeof(*best_clock));\n\n\tclock.p2 = i9xx_select_p2_div(limit, crtc_state, target);\n\n\tfor (clock.m1 = limit->m1.min; clock.m1 <= limit->m1.max;\n\t     clock.m1++) {\n\t\tfor (clock.m2 = limit->m2.min;\n\t\t     clock.m2 <= limit->m2.max; clock.m2++) {\n\t\t\tfor (clock.n = limit->n.min;\n\t\t\t     clock.n <= limit->n.max; clock.n++) {\n\t\t\t\tfor (clock.p1 = limit->p1.min;\n\t\t\t\t\tclock.p1 <= limit->p1.max; clock.p1++) {\n\t\t\t\t\tint this_err;\n\n\t\t\t\t\tpnv_calc_dpll_params(refclk, &clock);\n\t\t\t\t\tif (!intel_pll_is_valid(to_i915(dev),\n\t\t\t\t\t\t\t\tlimit,\n\t\t\t\t\t\t\t\t&clock))\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tif (match_clock &&\n\t\t\t\t\t    clock.p != match_clock->p)\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\tthis_err = abs(clock.dot - target);\n\t\t\t\t\tif (this_err < err) {\n\t\t\t\t\t\t*best_clock = clock;\n\t\t\t\t\t\terr = this_err;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn (err != target);\n}\n\n \nstatic bool\ng4x_find_best_dpll(const struct intel_limit *limit,\n\t\t   struct intel_crtc_state *crtc_state,\n\t\t   int target, int refclk,\n\t\t   const struct dpll *match_clock,\n\t\t   struct dpll *best_clock)\n{\n\tstruct drm_device *dev = crtc_state->uapi.crtc->dev;\n\tstruct dpll clock;\n\tint max_n;\n\tbool found = false;\n\t \n\tint err_most = (target >> 8) + (target >> 9);\n\n\tmemset(best_clock, 0, sizeof(*best_clock));\n\n\tclock.p2 = i9xx_select_p2_div(limit, crtc_state, target);\n\n\tmax_n = limit->n.max;\n\t \n\tfor (clock.n = limit->n.min; clock.n <= max_n; clock.n++) {\n\t\t \n\t\tfor (clock.m1 = limit->m1.max;\n\t\t     clock.m1 >= limit->m1.min; clock.m1--) {\n\t\t\tfor (clock.m2 = limit->m2.max;\n\t\t\t     clock.m2 >= limit->m2.min; clock.m2--) {\n\t\t\t\tfor (clock.p1 = limit->p1.max;\n\t\t\t\t     clock.p1 >= limit->p1.min; clock.p1--) {\n\t\t\t\t\tint this_err;\n\n\t\t\t\t\ti9xx_calc_dpll_params(refclk, &clock);\n\t\t\t\t\tif (!intel_pll_is_valid(to_i915(dev),\n\t\t\t\t\t\t\t\tlimit,\n\t\t\t\t\t\t\t\t&clock))\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\tthis_err = abs(clock.dot - target);\n\t\t\t\t\tif (this_err < err_most) {\n\t\t\t\t\t\t*best_clock = clock;\n\t\t\t\t\t\terr_most = this_err;\n\t\t\t\t\t\tmax_n = clock.n;\n\t\t\t\t\t\tfound = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn found;\n}\n\n \nstatic bool vlv_PLL_is_optimal(struct drm_device *dev, int target_freq,\n\t\t\t       const struct dpll *calculated_clock,\n\t\t\t       const struct dpll *best_clock,\n\t\t\t       unsigned int best_error_ppm,\n\t\t\t       unsigned int *error_ppm)\n{\n\t \n\tif (IS_CHERRYVIEW(to_i915(dev))) {\n\t\t*error_ppm = 0;\n\n\t\treturn calculated_clock->p > best_clock->p;\n\t}\n\n\tif (drm_WARN_ON_ONCE(dev, !target_freq))\n\t\treturn false;\n\n\t*error_ppm = div_u64(1000000ULL *\n\t\t\t\tabs(target_freq - calculated_clock->dot),\n\t\t\t     target_freq);\n\t \n\tif (*error_ppm < 100 && calculated_clock->p > best_clock->p) {\n\t\t*error_ppm = 0;\n\n\t\treturn true;\n\t}\n\n\treturn *error_ppm + 10 < best_error_ppm;\n}\n\n \nstatic bool\nvlv_find_best_dpll(const struct intel_limit *limit,\n\t\t   struct intel_crtc_state *crtc_state,\n\t\t   int target, int refclk,\n\t\t   const struct dpll *match_clock,\n\t\t   struct dpll *best_clock)\n{\n\tstruct intel_crtc *crtc = to_intel_crtc(crtc_state->uapi.crtc);\n\tstruct drm_device *dev = crtc->base.dev;\n\tstruct dpll clock;\n\tunsigned int bestppm = 1000000;\n\t \n\tint max_n = min(limit->n.max, refclk / 19200);\n\tbool found = false;\n\n\tmemset(best_clock, 0, sizeof(*best_clock));\n\n\t \n\tfor (clock.n = limit->n.min; clock.n <= max_n; clock.n++) {\n\t\tfor (clock.p1 = limit->p1.max; clock.p1 >= limit->p1.min; clock.p1--) {\n\t\t\tfor (clock.p2 = limit->p2.p2_fast; clock.p2 >= limit->p2.p2_slow;\n\t\t\t     clock.p2 -= clock.p2 > 10 ? 2 : 1) {\n\t\t\t\tclock.p = clock.p1 * clock.p2 * 5;\n\t\t\t\t \n\t\t\t\tfor (clock.m1 = limit->m1.min; clock.m1 <= limit->m1.max; clock.m1++) {\n\t\t\t\t\tunsigned int ppm;\n\n\t\t\t\t\tclock.m2 = DIV_ROUND_CLOSEST(target * clock.p * clock.n,\n\t\t\t\t\t\t\t\t     refclk * clock.m1);\n\n\t\t\t\t\tvlv_calc_dpll_params(refclk, &clock);\n\n\t\t\t\t\tif (!intel_pll_is_valid(to_i915(dev),\n\t\t\t\t\t\t\t\tlimit,\n\t\t\t\t\t\t\t\t&clock))\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\tif (!vlv_PLL_is_optimal(dev, target,\n\t\t\t\t\t\t\t\t&clock,\n\t\t\t\t\t\t\t\tbest_clock,\n\t\t\t\t\t\t\t\tbestppm, &ppm))\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\t*best_clock = clock;\n\t\t\t\t\tbestppm = ppm;\n\t\t\t\t\tfound = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn found;\n}\n\n \nstatic bool\nchv_find_best_dpll(const struct intel_limit *limit,\n\t\t   struct intel_crtc_state *crtc_state,\n\t\t   int target, int refclk,\n\t\t   const struct dpll *match_clock,\n\t\t   struct dpll *best_clock)\n{\n\tstruct intel_crtc *crtc = to_intel_crtc(crtc_state->uapi.crtc);\n\tstruct drm_device *dev = crtc->base.dev;\n\tunsigned int best_error_ppm;\n\tstruct dpll clock;\n\tu64 m2;\n\tint found = false;\n\n\tmemset(best_clock, 0, sizeof(*best_clock));\n\tbest_error_ppm = 1000000;\n\n\t \n\tclock.n = 1;\n\tclock.m1 = 2;\n\n\tfor (clock.p1 = limit->p1.max; clock.p1 >= limit->p1.min; clock.p1--) {\n\t\tfor (clock.p2 = limit->p2.p2_fast;\n\t\t\t\tclock.p2 >= limit->p2.p2_slow;\n\t\t\t\tclock.p2 -= clock.p2 > 10 ? 2 : 1) {\n\t\t\tunsigned int error_ppm;\n\n\t\t\tclock.p = clock.p1 * clock.p2 * 5;\n\n\t\t\tm2 = DIV_ROUND_CLOSEST_ULL(mul_u32_u32(target, clock.p * clock.n) << 22,\n\t\t\t\t\t\t   refclk * clock.m1);\n\n\t\t\tif (m2 > INT_MAX/clock.m1)\n\t\t\t\tcontinue;\n\n\t\t\tclock.m2 = m2;\n\n\t\t\tchv_calc_dpll_params(refclk, &clock);\n\n\t\t\tif (!intel_pll_is_valid(to_i915(dev), limit, &clock))\n\t\t\t\tcontinue;\n\n\t\t\tif (!vlv_PLL_is_optimal(dev, target, &clock, best_clock,\n\t\t\t\t\t\tbest_error_ppm, &error_ppm))\n\t\t\t\tcontinue;\n\n\t\t\t*best_clock = clock;\n\t\t\tbest_error_ppm = error_ppm;\n\t\t\tfound = true;\n\t\t}\n\t}\n\n\treturn found;\n}\n\nbool bxt_find_best_dpll(struct intel_crtc_state *crtc_state,\n\t\t\tstruct dpll *best_clock)\n{\n\tconst struct intel_limit *limit = &intel_limits_bxt;\n\tint refclk = 100000;\n\n\treturn chv_find_best_dpll(limit, crtc_state,\n\t\t\t\t  crtc_state->port_clock, refclk,\n\t\t\t\t  NULL, best_clock);\n}\n\nu32 i9xx_dpll_compute_fp(const struct dpll *dpll)\n{\n\treturn dpll->n << 16 | dpll->m1 << 8 | dpll->m2;\n}\n\nstatic u32 pnv_dpll_compute_fp(const struct dpll *dpll)\n{\n\treturn (1 << dpll->n) << 16 | dpll->m2;\n}\n\nstatic void i9xx_update_pll_dividers(struct intel_crtc_state *crtc_state,\n\t\t\t\t     const struct dpll *clock,\n\t\t\t\t     const struct dpll *reduced_clock)\n{\n\tstruct intel_crtc *crtc = to_intel_crtc(crtc_state->uapi.crtc);\n\tstruct drm_i915_private *dev_priv = to_i915(crtc->base.dev);\n\tu32 fp, fp2;\n\n\tif (IS_PINEVIEW(dev_priv)) {\n\t\tfp = pnv_dpll_compute_fp(clock);\n\t\tfp2 = pnv_dpll_compute_fp(reduced_clock);\n\t} else {\n\t\tfp = i9xx_dpll_compute_fp(clock);\n\t\tfp2 = i9xx_dpll_compute_fp(reduced_clock);\n\t}\n\n\tcrtc_state->dpll_hw_state.fp0 = fp;\n\tcrtc_state->dpll_hw_state.fp1 = fp2;\n}\n\nstatic void i9xx_compute_dpll(struct intel_crtc_state *crtc_state,\n\t\t\t      const struct dpll *clock,\n\t\t\t      const struct dpll *reduced_clock)\n{\n\tstruct intel_crtc *crtc = to_intel_crtc(crtc_state->uapi.crtc);\n\tstruct drm_i915_private *dev_priv = to_i915(crtc->base.dev);\n\tu32 dpll;\n\n\ti9xx_update_pll_dividers(crtc_state, clock, reduced_clock);\n\n\tdpll = DPLL_VGA_MODE_DIS;\n\n\tif (intel_crtc_has_type(crtc_state, INTEL_OUTPUT_LVDS))\n\t\tdpll |= DPLLB_MODE_LVDS;\n\telse\n\t\tdpll |= DPLLB_MODE_DAC_SERIAL;\n\n\tif (IS_I945G(dev_priv) || IS_I945GM(dev_priv) ||\n\t    IS_G33(dev_priv) || IS_PINEVIEW(dev_priv)) {\n\t\tdpll |= (crtc_state->pixel_multiplier - 1)\n\t\t\t<< SDVO_MULTIPLIER_SHIFT_HIRES;\n\t}\n\n\tif (intel_crtc_has_type(crtc_state, INTEL_OUTPUT_SDVO) ||\n\t    intel_crtc_has_type(crtc_state, INTEL_OUTPUT_HDMI))\n\t\tdpll |= DPLL_SDVO_HIGH_SPEED;\n\n\tif (intel_crtc_has_dp_encoder(crtc_state))\n\t\tdpll |= DPLL_SDVO_HIGH_SPEED;\n\n\t \n\tif (IS_G4X(dev_priv)) {\n\t\tdpll |= (1 << (clock->p1 - 1)) << DPLL_FPA01_P1_POST_DIV_SHIFT;\n\t\tdpll |= (1 << (reduced_clock->p1 - 1)) << DPLL_FPA1_P1_POST_DIV_SHIFT;\n\t} else if (IS_PINEVIEW(dev_priv)) {\n\t\tdpll |= (1 << (clock->p1 - 1)) << DPLL_FPA01_P1_POST_DIV_SHIFT_PINEVIEW;\n\t\tWARN_ON(reduced_clock->p1 != clock->p1);\n\t} else {\n\t\tdpll |= (1 << (clock->p1 - 1)) << DPLL_FPA01_P1_POST_DIV_SHIFT;\n\t\tWARN_ON(reduced_clock->p1 != clock->p1);\n\t}\n\n\tswitch (clock->p2) {\n\tcase 5:\n\t\tdpll |= DPLL_DAC_SERIAL_P2_CLOCK_DIV_5;\n\t\tbreak;\n\tcase 7:\n\t\tdpll |= DPLLB_LVDS_P2_CLOCK_DIV_7;\n\t\tbreak;\n\tcase 10:\n\t\tdpll |= DPLL_DAC_SERIAL_P2_CLOCK_DIV_10;\n\t\tbreak;\n\tcase 14:\n\t\tdpll |= DPLLB_LVDS_P2_CLOCK_DIV_14;\n\t\tbreak;\n\t}\n\tWARN_ON(reduced_clock->p2 != clock->p2);\n\n\tif (DISPLAY_VER(dev_priv) >= 4)\n\t\tdpll |= (6 << PLL_LOAD_PULSE_PHASE_SHIFT);\n\n\tif (crtc_state->sdvo_tv_clock)\n\t\tdpll |= PLL_REF_INPUT_TVCLKINBC;\n\telse if (intel_crtc_has_type(crtc_state, INTEL_OUTPUT_LVDS) &&\n\t\t intel_panel_use_ssc(dev_priv))\n\t\tdpll |= PLLB_REF_INPUT_SPREADSPECTRUMIN;\n\telse\n\t\tdpll |= PLL_REF_INPUT_DREFCLK;\n\n\tdpll |= DPLL_VCO_ENABLE;\n\tcrtc_state->dpll_hw_state.dpll = dpll;\n\n\tif (DISPLAY_VER(dev_priv) >= 4) {\n\t\tu32 dpll_md = (crtc_state->pixel_multiplier - 1)\n\t\t\t<< DPLL_MD_UDI_MULTIPLIER_SHIFT;\n\t\tcrtc_state->dpll_hw_state.dpll_md = dpll_md;\n\t}\n}\n\nstatic void i8xx_compute_dpll(struct intel_crtc_state *crtc_state,\n\t\t\t      const struct dpll *clock,\n\t\t\t      const struct dpll *reduced_clock)\n{\n\tstruct intel_crtc *crtc = to_intel_crtc(crtc_state->uapi.crtc);\n\tstruct drm_i915_private *dev_priv = to_i915(crtc->base.dev);\n\tu32 dpll;\n\n\ti9xx_update_pll_dividers(crtc_state, clock, reduced_clock);\n\n\tdpll = DPLL_VGA_MODE_DIS;\n\n\tif (intel_crtc_has_type(crtc_state, INTEL_OUTPUT_LVDS)) {\n\t\tdpll |= (1 << (clock->p1 - 1)) << DPLL_FPA01_P1_POST_DIV_SHIFT;\n\t} else {\n\t\tif (clock->p1 == 2)\n\t\t\tdpll |= PLL_P1_DIVIDE_BY_TWO;\n\t\telse\n\t\t\tdpll |= (clock->p1 - 2) << DPLL_FPA01_P1_POST_DIV_SHIFT;\n\t\tif (clock->p2 == 4)\n\t\t\tdpll |= PLL_P2_DIVIDE_BY_4;\n\t}\n\tWARN_ON(reduced_clock->p1 != clock->p1);\n\tWARN_ON(reduced_clock->p2 != clock->p2);\n\n\t \n\tif (IS_I830(dev_priv) ||\n\t    intel_crtc_has_type(crtc_state, INTEL_OUTPUT_DVO))\n\t\tdpll |= DPLL_DVO_2X_MODE;\n\n\tif (intel_crtc_has_type(crtc_state, INTEL_OUTPUT_LVDS) &&\n\t    intel_panel_use_ssc(dev_priv))\n\t\tdpll |= PLLB_REF_INPUT_SPREADSPECTRUMIN;\n\telse\n\t\tdpll |= PLL_REF_INPUT_DREFCLK;\n\n\tdpll |= DPLL_VCO_ENABLE;\n\tcrtc_state->dpll_hw_state.dpll = dpll;\n}\n\nstatic int hsw_crtc_compute_clock(struct intel_atomic_state *state,\n\t\t\t\t  struct intel_crtc *crtc)\n{\n\tstruct drm_i915_private *dev_priv = to_i915(state->base.dev);\n\tstruct intel_crtc_state *crtc_state =\n\t\tintel_atomic_get_new_crtc_state(state, crtc);\n\tstruct intel_encoder *encoder =\n\t\tintel_get_crtc_new_encoder(state, crtc_state);\n\tint ret;\n\n\tif (DISPLAY_VER(dev_priv) < 11 &&\n\t    intel_crtc_has_type(crtc_state, INTEL_OUTPUT_DSI))\n\t\treturn 0;\n\n\tret = intel_compute_shared_dplls(state, crtc, encoder);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tif (intel_crtc_has_type(crtc_state, INTEL_OUTPUT_DSI))\n\t\treturn 0;\n\n\t \n\tif (!crtc_state->has_pch_encoder)\n\t\tcrtc_state->hw.adjusted_mode.crtc_clock = intel_crtc_dotclock(crtc_state);\n\n\treturn 0;\n}\n\nstatic int hsw_crtc_get_shared_dpll(struct intel_atomic_state *state,\n\t\t\t\t    struct intel_crtc *crtc)\n{\n\tstruct drm_i915_private *dev_priv = to_i915(state->base.dev);\n\tstruct intel_crtc_state *crtc_state =\n\t\tintel_atomic_get_new_crtc_state(state, crtc);\n\tstruct intel_encoder *encoder =\n\t\tintel_get_crtc_new_encoder(state, crtc_state);\n\n\tif (DISPLAY_VER(dev_priv) < 11 &&\n\t    intel_crtc_has_type(crtc_state, INTEL_OUTPUT_DSI))\n\t\treturn 0;\n\n\treturn intel_reserve_shared_dplls(state, crtc, encoder);\n}\n\nstatic int dg2_crtc_compute_clock(struct intel_atomic_state *state,\n\t\t\t\t  struct intel_crtc *crtc)\n{\n\tstruct intel_crtc_state *crtc_state =\n\t\tintel_atomic_get_new_crtc_state(state, crtc);\n\tstruct intel_encoder *encoder =\n\t\tintel_get_crtc_new_encoder(state, crtc_state);\n\tint ret;\n\n\tret = intel_mpllb_calc_state(crtc_state, encoder);\n\tif (ret)\n\t\treturn ret;\n\n\tcrtc_state->hw.adjusted_mode.crtc_clock = intel_crtc_dotclock(crtc_state);\n\n\treturn 0;\n}\n\nstatic int mtl_crtc_compute_clock(struct intel_atomic_state *state,\n\t\t\t\t  struct intel_crtc *crtc)\n{\n\tstruct drm_i915_private *i915 = to_i915(state->base.dev);\n\tstruct intel_crtc_state *crtc_state =\n\t\tintel_atomic_get_new_crtc_state(state, crtc);\n\tstruct intel_encoder *encoder =\n\t\tintel_get_crtc_new_encoder(state, crtc_state);\n\tenum phy phy = intel_port_to_phy(i915, encoder->port);\n\tint ret;\n\n\tret = intel_cx0pll_calc_state(crtc_state, encoder);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tif (intel_is_c10phy(i915, phy))\n\t\tcrtc_state->port_clock = intel_c10pll_calc_port_clock(encoder, &crtc_state->cx0pll_state.c10);\n\telse\n\t\tcrtc_state->port_clock = intel_c20pll_calc_port_clock(encoder, &crtc_state->cx0pll_state.c20);\n\n\tcrtc_state->hw.adjusted_mode.crtc_clock = intel_crtc_dotclock(crtc_state);\n\n\treturn 0;\n}\n\nstatic bool ilk_needs_fb_cb_tune(const struct dpll *dpll, int factor)\n{\n\treturn dpll->m < factor * dpll->n;\n}\n\nstatic void ilk_update_pll_dividers(struct intel_crtc_state *crtc_state,\n\t\t\t\t    const struct dpll *clock,\n\t\t\t\t    const struct dpll *reduced_clock)\n{\n\tstruct intel_crtc *crtc = to_intel_crtc(crtc_state->uapi.crtc);\n\tstruct drm_i915_private *dev_priv = to_i915(crtc->base.dev);\n\tu32 fp, fp2;\n\tint factor;\n\n\t \n\tfactor = 21;\n\tif (intel_crtc_has_type(crtc_state, INTEL_OUTPUT_LVDS)) {\n\t\tif ((intel_panel_use_ssc(dev_priv) &&\n\t\t     dev_priv->display.vbt.lvds_ssc_freq == 100000) ||\n\t\t    (HAS_PCH_IBX(dev_priv) &&\n\t\t     intel_is_dual_link_lvds(dev_priv)))\n\t\t\tfactor = 25;\n\t} else if (crtc_state->sdvo_tv_clock) {\n\t\tfactor = 20;\n\t}\n\n\tfp = i9xx_dpll_compute_fp(clock);\n\tif (ilk_needs_fb_cb_tune(clock, factor))\n\t\tfp |= FP_CB_TUNE;\n\n\tfp2 = i9xx_dpll_compute_fp(reduced_clock);\n\tif (ilk_needs_fb_cb_tune(reduced_clock, factor))\n\t\tfp2 |= FP_CB_TUNE;\n\n\tcrtc_state->dpll_hw_state.fp0 = fp;\n\tcrtc_state->dpll_hw_state.fp1 = fp2;\n}\n\nstatic void ilk_compute_dpll(struct intel_crtc_state *crtc_state,\n\t\t\t     const struct dpll *clock,\n\t\t\t     const struct dpll *reduced_clock)\n{\n\tstruct intel_crtc *crtc = to_intel_crtc(crtc_state->uapi.crtc);\n\tstruct drm_i915_private *dev_priv = to_i915(crtc->base.dev);\n\tu32 dpll;\n\n\tilk_update_pll_dividers(crtc_state, clock, reduced_clock);\n\n\tdpll = 0;\n\n\tif (intel_crtc_has_type(crtc_state, INTEL_OUTPUT_LVDS))\n\t\tdpll |= DPLLB_MODE_LVDS;\n\telse\n\t\tdpll |= DPLLB_MODE_DAC_SERIAL;\n\n\tdpll |= (crtc_state->pixel_multiplier - 1)\n\t\t<< PLL_REF_SDVO_HDMI_MULTIPLIER_SHIFT;\n\n\tif (intel_crtc_has_type(crtc_state, INTEL_OUTPUT_SDVO) ||\n\t    intel_crtc_has_type(crtc_state, INTEL_OUTPUT_HDMI))\n\t\tdpll |= DPLL_SDVO_HIGH_SPEED;\n\n\tif (intel_crtc_has_dp_encoder(crtc_state))\n\t\tdpll |= DPLL_SDVO_HIGH_SPEED;\n\n\t \n\tif (INTEL_NUM_PIPES(dev_priv) == 3 &&\n\t    intel_crtc_has_type(crtc_state, INTEL_OUTPUT_ANALOG))\n\t\tdpll |= DPLL_SDVO_HIGH_SPEED;\n\n\t \n\tdpll |= (1 << (clock->p1 - 1)) << DPLL_FPA01_P1_POST_DIV_SHIFT;\n\t \n\tdpll |= (1 << (reduced_clock->p1 - 1)) << DPLL_FPA1_P1_POST_DIV_SHIFT;\n\n\tswitch (clock->p2) {\n\tcase 5:\n\t\tdpll |= DPLL_DAC_SERIAL_P2_CLOCK_DIV_5;\n\t\tbreak;\n\tcase 7:\n\t\tdpll |= DPLLB_LVDS_P2_CLOCK_DIV_7;\n\t\tbreak;\n\tcase 10:\n\t\tdpll |= DPLL_DAC_SERIAL_P2_CLOCK_DIV_10;\n\t\tbreak;\n\tcase 14:\n\t\tdpll |= DPLLB_LVDS_P2_CLOCK_DIV_14;\n\t\tbreak;\n\t}\n\tWARN_ON(reduced_clock->p2 != clock->p2);\n\n\tif (intel_crtc_has_type(crtc_state, INTEL_OUTPUT_LVDS) &&\n\t    intel_panel_use_ssc(dev_priv))\n\t\tdpll |= PLLB_REF_INPUT_SPREADSPECTRUMIN;\n\telse\n\t\tdpll |= PLL_REF_INPUT_DREFCLK;\n\n\tdpll |= DPLL_VCO_ENABLE;\n\n\tcrtc_state->dpll_hw_state.dpll = dpll;\n}\n\nstatic int ilk_crtc_compute_clock(struct intel_atomic_state *state,\n\t\t\t\t  struct intel_crtc *crtc)\n{\n\tstruct drm_i915_private *dev_priv = to_i915(state->base.dev);\n\tstruct intel_crtc_state *crtc_state =\n\t\tintel_atomic_get_new_crtc_state(state, crtc);\n\tconst struct intel_limit *limit;\n\tint refclk = 120000;\n\tint ret;\n\n\t \n\tif (!crtc_state->has_pch_encoder)\n\t\treturn 0;\n\n\tif (intel_crtc_has_type(crtc_state, INTEL_OUTPUT_LVDS)) {\n\t\tif (intel_panel_use_ssc(dev_priv)) {\n\t\t\tdrm_dbg_kms(&dev_priv->drm,\n\t\t\t\t    \"using SSC reference clock of %d kHz\\n\",\n\t\t\t\t    dev_priv->display.vbt.lvds_ssc_freq);\n\t\t\trefclk = dev_priv->display.vbt.lvds_ssc_freq;\n\t\t}\n\n\t\tif (intel_is_dual_link_lvds(dev_priv)) {\n\t\t\tif (refclk == 100000)\n\t\t\t\tlimit = &ilk_limits_dual_lvds_100m;\n\t\t\telse\n\t\t\t\tlimit = &ilk_limits_dual_lvds;\n\t\t} else {\n\t\t\tif (refclk == 100000)\n\t\t\t\tlimit = &ilk_limits_single_lvds_100m;\n\t\t\telse\n\t\t\t\tlimit = &ilk_limits_single_lvds;\n\t\t}\n\t} else {\n\t\tlimit = &ilk_limits_dac;\n\t}\n\n\tif (!crtc_state->clock_set &&\n\t    !g4x_find_best_dpll(limit, crtc_state, crtc_state->port_clock,\n\t\t\t\trefclk, NULL, &crtc_state->dpll))\n\t\treturn -EINVAL;\n\n\tilk_compute_dpll(crtc_state, &crtc_state->dpll,\n\t\t\t &crtc_state->dpll);\n\n\tret = intel_compute_shared_dplls(state, crtc, NULL);\n\tif (ret)\n\t\treturn ret;\n\n\tcrtc_state->port_clock = crtc_state->dpll.dot;\n\tcrtc_state->hw.adjusted_mode.crtc_clock = intel_crtc_dotclock(crtc_state);\n\n\treturn ret;\n}\n\nstatic int ilk_crtc_get_shared_dpll(struct intel_atomic_state *state,\n\t\t\t\t    struct intel_crtc *crtc)\n{\n\tstruct intel_crtc_state *crtc_state =\n\t\tintel_atomic_get_new_crtc_state(state, crtc);\n\n\t \n\tif (!crtc_state->has_pch_encoder)\n\t\treturn 0;\n\n\treturn intel_reserve_shared_dplls(state, crtc, NULL);\n}\n\nvoid vlv_compute_dpll(struct intel_crtc_state *crtc_state)\n{\n\tstruct intel_crtc *crtc = to_intel_crtc(crtc_state->uapi.crtc);\n\n\tcrtc_state->dpll_hw_state.dpll = DPLL_INTEGRATED_REF_CLK_VLV |\n\t\tDPLL_REF_CLK_ENABLE_VLV | DPLL_VGA_MODE_DIS;\n\tif (crtc->pipe != PIPE_A)\n\t\tcrtc_state->dpll_hw_state.dpll |= DPLL_INTEGRATED_CRI_CLK_VLV;\n\n\t \n\tif (!intel_crtc_has_type(crtc_state, INTEL_OUTPUT_DSI))\n\t\tcrtc_state->dpll_hw_state.dpll |= DPLL_VCO_ENABLE |\n\t\t\tDPLL_EXT_BUFFER_ENABLE_VLV;\n\n\tcrtc_state->dpll_hw_state.dpll_md =\n\t\t(crtc_state->pixel_multiplier - 1) << DPLL_MD_UDI_MULTIPLIER_SHIFT;\n}\n\nvoid chv_compute_dpll(struct intel_crtc_state *crtc_state)\n{\n\tstruct intel_crtc *crtc = to_intel_crtc(crtc_state->uapi.crtc);\n\n\tcrtc_state->dpll_hw_state.dpll = DPLL_SSC_REF_CLK_CHV |\n\t\tDPLL_REF_CLK_ENABLE_VLV | DPLL_VGA_MODE_DIS;\n\tif (crtc->pipe != PIPE_A)\n\t\tcrtc_state->dpll_hw_state.dpll |= DPLL_INTEGRATED_CRI_CLK_VLV;\n\n\t \n\tif (!intel_crtc_has_type(crtc_state, INTEL_OUTPUT_DSI))\n\t\tcrtc_state->dpll_hw_state.dpll |= DPLL_VCO_ENABLE;\n\n\tcrtc_state->dpll_hw_state.dpll_md =\n\t\t(crtc_state->pixel_multiplier - 1) << DPLL_MD_UDI_MULTIPLIER_SHIFT;\n}\n\nstatic int chv_crtc_compute_clock(struct intel_atomic_state *state,\n\t\t\t\t  struct intel_crtc *crtc)\n{\n\tstruct intel_crtc_state *crtc_state =\n\t\tintel_atomic_get_new_crtc_state(state, crtc);\n\tconst struct intel_limit *limit = &intel_limits_chv;\n\tint refclk = 100000;\n\n\tif (!crtc_state->clock_set &&\n\t    !chv_find_best_dpll(limit, crtc_state, crtc_state->port_clock,\n\t\t\t\trefclk, NULL, &crtc_state->dpll))\n\t\treturn -EINVAL;\n\n\tchv_compute_dpll(crtc_state);\n\n\t \n\tif (intel_crtc_has_type(crtc_state, INTEL_OUTPUT_DSI))\n\t\treturn 0;\n\n\tcrtc_state->port_clock = crtc_state->dpll.dot;\n\tcrtc_state->hw.adjusted_mode.crtc_clock = intel_crtc_dotclock(crtc_state);\n\n\treturn 0;\n}\n\nstatic int vlv_crtc_compute_clock(struct intel_atomic_state *state,\n\t\t\t\t  struct intel_crtc *crtc)\n{\n\tstruct intel_crtc_state *crtc_state =\n\t\tintel_atomic_get_new_crtc_state(state, crtc);\n\tconst struct intel_limit *limit = &intel_limits_vlv;\n\tint refclk = 100000;\n\n\tif (!crtc_state->clock_set &&\n\t    !vlv_find_best_dpll(limit, crtc_state, crtc_state->port_clock,\n\t\t\t\trefclk, NULL, &crtc_state->dpll)) {\n\t\treturn -EINVAL;\n\t}\n\n\tvlv_compute_dpll(crtc_state);\n\n\t \n\tif (intel_crtc_has_type(crtc_state, INTEL_OUTPUT_DSI))\n\t\treturn 0;\n\n\tcrtc_state->port_clock = crtc_state->dpll.dot;\n\tcrtc_state->hw.adjusted_mode.crtc_clock = intel_crtc_dotclock(crtc_state);\n\n\treturn 0;\n}\n\nstatic int g4x_crtc_compute_clock(struct intel_atomic_state *state,\n\t\t\t\t  struct intel_crtc *crtc)\n{\n\tstruct drm_i915_private *dev_priv = to_i915(state->base.dev);\n\tstruct intel_crtc_state *crtc_state =\n\t\tintel_atomic_get_new_crtc_state(state, crtc);\n\tconst struct intel_limit *limit;\n\tint refclk = 96000;\n\n\tif (intel_crtc_has_type(crtc_state, INTEL_OUTPUT_LVDS)) {\n\t\tif (intel_panel_use_ssc(dev_priv)) {\n\t\t\trefclk = dev_priv->display.vbt.lvds_ssc_freq;\n\t\t\tdrm_dbg_kms(&dev_priv->drm,\n\t\t\t\t    \"using SSC reference clock of %d kHz\\n\",\n\t\t\t\t    refclk);\n\t\t}\n\n\t\tif (intel_is_dual_link_lvds(dev_priv))\n\t\t\tlimit = &intel_limits_g4x_dual_channel_lvds;\n\t\telse\n\t\t\tlimit = &intel_limits_g4x_single_channel_lvds;\n\t} else if (intel_crtc_has_type(crtc_state, INTEL_OUTPUT_HDMI) ||\n\t\t   intel_crtc_has_type(crtc_state, INTEL_OUTPUT_ANALOG)) {\n\t\tlimit = &intel_limits_g4x_hdmi;\n\t} else if (intel_crtc_has_type(crtc_state, INTEL_OUTPUT_SDVO)) {\n\t\tlimit = &intel_limits_g4x_sdvo;\n\t} else {\n\t\t \n\t\tlimit = &intel_limits_i9xx_sdvo;\n\t}\n\n\tif (!crtc_state->clock_set &&\n\t    !g4x_find_best_dpll(limit, crtc_state, crtc_state->port_clock,\n\t\t\t\trefclk, NULL, &crtc_state->dpll))\n\t\treturn -EINVAL;\n\n\ti9xx_compute_dpll(crtc_state, &crtc_state->dpll,\n\t\t\t  &crtc_state->dpll);\n\n\tcrtc_state->port_clock = crtc_state->dpll.dot;\n\t \n\tif (!intel_crtc_has_type(crtc_state, INTEL_OUTPUT_TVOUT))\n\t\tcrtc_state->hw.adjusted_mode.crtc_clock = intel_crtc_dotclock(crtc_state);\n\n\treturn 0;\n}\n\nstatic int pnv_crtc_compute_clock(struct intel_atomic_state *state,\n\t\t\t\t  struct intel_crtc *crtc)\n{\n\tstruct drm_i915_private *dev_priv = to_i915(state->base.dev);\n\tstruct intel_crtc_state *crtc_state =\n\t\tintel_atomic_get_new_crtc_state(state, crtc);\n\tconst struct intel_limit *limit;\n\tint refclk = 96000;\n\n\tif (intel_crtc_has_type(crtc_state, INTEL_OUTPUT_LVDS)) {\n\t\tif (intel_panel_use_ssc(dev_priv)) {\n\t\t\trefclk = dev_priv->display.vbt.lvds_ssc_freq;\n\t\t\tdrm_dbg_kms(&dev_priv->drm,\n\t\t\t\t    \"using SSC reference clock of %d kHz\\n\",\n\t\t\t\t    refclk);\n\t\t}\n\n\t\tlimit = &pnv_limits_lvds;\n\t} else {\n\t\tlimit = &pnv_limits_sdvo;\n\t}\n\n\tif (!crtc_state->clock_set &&\n\t    !pnv_find_best_dpll(limit, crtc_state, crtc_state->port_clock,\n\t\t\t\trefclk, NULL, &crtc_state->dpll))\n\t\treturn -EINVAL;\n\n\ti9xx_compute_dpll(crtc_state, &crtc_state->dpll,\n\t\t\t  &crtc_state->dpll);\n\n\tcrtc_state->port_clock = crtc_state->dpll.dot;\n\tcrtc_state->hw.adjusted_mode.crtc_clock = intel_crtc_dotclock(crtc_state);\n\n\treturn 0;\n}\n\nstatic int i9xx_crtc_compute_clock(struct intel_atomic_state *state,\n\t\t\t\t   struct intel_crtc *crtc)\n{\n\tstruct drm_i915_private *dev_priv = to_i915(state->base.dev);\n\tstruct intel_crtc_state *crtc_state =\n\t\tintel_atomic_get_new_crtc_state(state, crtc);\n\tconst struct intel_limit *limit;\n\tint refclk = 96000;\n\n\tif (intel_crtc_has_type(crtc_state, INTEL_OUTPUT_LVDS)) {\n\t\tif (intel_panel_use_ssc(dev_priv)) {\n\t\t\trefclk = dev_priv->display.vbt.lvds_ssc_freq;\n\t\t\tdrm_dbg_kms(&dev_priv->drm,\n\t\t\t\t    \"using SSC reference clock of %d kHz\\n\",\n\t\t\t\t    refclk);\n\t\t}\n\n\t\tlimit = &intel_limits_i9xx_lvds;\n\t} else {\n\t\tlimit = &intel_limits_i9xx_sdvo;\n\t}\n\n\tif (!crtc_state->clock_set &&\n\t    !i9xx_find_best_dpll(limit, crtc_state, crtc_state->port_clock,\n\t\t\t\t refclk, NULL, &crtc_state->dpll))\n\t\treturn -EINVAL;\n\n\ti9xx_compute_dpll(crtc_state, &crtc_state->dpll,\n\t\t\t  &crtc_state->dpll);\n\n\tcrtc_state->port_clock = crtc_state->dpll.dot;\n\t \n\tif (!intel_crtc_has_type(crtc_state, INTEL_OUTPUT_TVOUT))\n\t\tcrtc_state->hw.adjusted_mode.crtc_clock = intel_crtc_dotclock(crtc_state);\n\n\treturn 0;\n}\n\nstatic int i8xx_crtc_compute_clock(struct intel_atomic_state *state,\n\t\t\t\t   struct intel_crtc *crtc)\n{\n\tstruct drm_i915_private *dev_priv = to_i915(state->base.dev);\n\tstruct intel_crtc_state *crtc_state =\n\t\tintel_atomic_get_new_crtc_state(state, crtc);\n\tconst struct intel_limit *limit;\n\tint refclk = 48000;\n\n\tif (intel_crtc_has_type(crtc_state, INTEL_OUTPUT_LVDS)) {\n\t\tif (intel_panel_use_ssc(dev_priv)) {\n\t\t\trefclk = dev_priv->display.vbt.lvds_ssc_freq;\n\t\t\tdrm_dbg_kms(&dev_priv->drm,\n\t\t\t\t    \"using SSC reference clock of %d kHz\\n\",\n\t\t\t\t    refclk);\n\t\t}\n\n\t\tlimit = &intel_limits_i8xx_lvds;\n\t} else if (intel_crtc_has_type(crtc_state, INTEL_OUTPUT_DVO)) {\n\t\tlimit = &intel_limits_i8xx_dvo;\n\t} else {\n\t\tlimit = &intel_limits_i8xx_dac;\n\t}\n\n\tif (!crtc_state->clock_set &&\n\t    !i9xx_find_best_dpll(limit, crtc_state, crtc_state->port_clock,\n\t\t\t\t refclk, NULL, &crtc_state->dpll))\n\t\treturn -EINVAL;\n\n\ti8xx_compute_dpll(crtc_state, &crtc_state->dpll,\n\t\t\t  &crtc_state->dpll);\n\n\tcrtc_state->port_clock = crtc_state->dpll.dot;\n\tcrtc_state->hw.adjusted_mode.crtc_clock = intel_crtc_dotclock(crtc_state);\n\n\treturn 0;\n}\n\nstatic const struct intel_dpll_funcs mtl_dpll_funcs = {\n\t.crtc_compute_clock = mtl_crtc_compute_clock,\n};\n\nstatic const struct intel_dpll_funcs dg2_dpll_funcs = {\n\t.crtc_compute_clock = dg2_crtc_compute_clock,\n};\n\nstatic const struct intel_dpll_funcs hsw_dpll_funcs = {\n\t.crtc_compute_clock = hsw_crtc_compute_clock,\n\t.crtc_get_shared_dpll = hsw_crtc_get_shared_dpll,\n};\n\nstatic const struct intel_dpll_funcs ilk_dpll_funcs = {\n\t.crtc_compute_clock = ilk_crtc_compute_clock,\n\t.crtc_get_shared_dpll = ilk_crtc_get_shared_dpll,\n};\n\nstatic const struct intel_dpll_funcs chv_dpll_funcs = {\n\t.crtc_compute_clock = chv_crtc_compute_clock,\n};\n\nstatic const struct intel_dpll_funcs vlv_dpll_funcs = {\n\t.crtc_compute_clock = vlv_crtc_compute_clock,\n};\n\nstatic const struct intel_dpll_funcs g4x_dpll_funcs = {\n\t.crtc_compute_clock = g4x_crtc_compute_clock,\n};\n\nstatic const struct intel_dpll_funcs pnv_dpll_funcs = {\n\t.crtc_compute_clock = pnv_crtc_compute_clock,\n};\n\nstatic const struct intel_dpll_funcs i9xx_dpll_funcs = {\n\t.crtc_compute_clock = i9xx_crtc_compute_clock,\n};\n\nstatic const struct intel_dpll_funcs i8xx_dpll_funcs = {\n\t.crtc_compute_clock = i8xx_crtc_compute_clock,\n};\n\nint intel_dpll_crtc_compute_clock(struct intel_atomic_state *state,\n\t\t\t\t  struct intel_crtc *crtc)\n{\n\tstruct drm_i915_private *i915 = to_i915(state->base.dev);\n\tstruct intel_crtc_state *crtc_state =\n\t\tintel_atomic_get_new_crtc_state(state, crtc);\n\tint ret;\n\n\tdrm_WARN_ON(&i915->drm, !intel_crtc_needs_modeset(crtc_state));\n\n\tmemset(&crtc_state->dpll_hw_state, 0,\n\t       sizeof(crtc_state->dpll_hw_state));\n\n\tif (!crtc_state->hw.enable)\n\t\treturn 0;\n\n\tret = i915->display.funcs.dpll->crtc_compute_clock(state, crtc);\n\tif (ret) {\n\t\tdrm_dbg_kms(&i915->drm, \"[CRTC:%d:%s] Couldn't calculate DPLL settings\\n\",\n\t\t\t    crtc->base.base.id, crtc->base.name);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nint intel_dpll_crtc_get_shared_dpll(struct intel_atomic_state *state,\n\t\t\t\t    struct intel_crtc *crtc)\n{\n\tstruct drm_i915_private *i915 = to_i915(state->base.dev);\n\tstruct intel_crtc_state *crtc_state =\n\t\tintel_atomic_get_new_crtc_state(state, crtc);\n\tint ret;\n\n\tdrm_WARN_ON(&i915->drm, !intel_crtc_needs_modeset(crtc_state));\n\tdrm_WARN_ON(&i915->drm, !crtc_state->hw.enable && crtc_state->shared_dpll);\n\n\tif (!crtc_state->hw.enable || crtc_state->shared_dpll)\n\t\treturn 0;\n\n\tif (!i915->display.funcs.dpll->crtc_get_shared_dpll)\n\t\treturn 0;\n\n\tret = i915->display.funcs.dpll->crtc_get_shared_dpll(state, crtc);\n\tif (ret) {\n\t\tdrm_dbg_kms(&i915->drm, \"[CRTC:%d:%s] Couldn't get a shared DPLL\\n\",\n\t\t\t    crtc->base.base.id, crtc->base.name);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nvoid\nintel_dpll_init_clock_hook(struct drm_i915_private *dev_priv)\n{\n\tif (DISPLAY_VER(dev_priv) >= 14)\n\t\tdev_priv->display.funcs.dpll = &mtl_dpll_funcs;\n\telse if (IS_DG2(dev_priv))\n\t\tdev_priv->display.funcs.dpll = &dg2_dpll_funcs;\n\telse if (DISPLAY_VER(dev_priv) >= 9 || HAS_DDI(dev_priv))\n\t\tdev_priv->display.funcs.dpll = &hsw_dpll_funcs;\n\telse if (HAS_PCH_SPLIT(dev_priv))\n\t\tdev_priv->display.funcs.dpll = &ilk_dpll_funcs;\n\telse if (IS_CHERRYVIEW(dev_priv))\n\t\tdev_priv->display.funcs.dpll = &chv_dpll_funcs;\n\telse if (IS_VALLEYVIEW(dev_priv))\n\t\tdev_priv->display.funcs.dpll = &vlv_dpll_funcs;\n\telse if (IS_G4X(dev_priv))\n\t\tdev_priv->display.funcs.dpll = &g4x_dpll_funcs;\n\telse if (IS_PINEVIEW(dev_priv))\n\t\tdev_priv->display.funcs.dpll = &pnv_dpll_funcs;\n\telse if (DISPLAY_VER(dev_priv) != 2)\n\t\tdev_priv->display.funcs.dpll = &i9xx_dpll_funcs;\n\telse\n\t\tdev_priv->display.funcs.dpll = &i8xx_dpll_funcs;\n}\n\nstatic bool i9xx_has_pps(struct drm_i915_private *dev_priv)\n{\n\tif (IS_I830(dev_priv))\n\t\treturn false;\n\n\treturn IS_PINEVIEW(dev_priv) || IS_MOBILE(dev_priv);\n}\n\nvoid i9xx_enable_pll(const struct intel_crtc_state *crtc_state)\n{\n\tstruct intel_crtc *crtc = to_intel_crtc(crtc_state->uapi.crtc);\n\tstruct drm_i915_private *dev_priv = to_i915(crtc->base.dev);\n\tu32 dpll = crtc_state->dpll_hw_state.dpll;\n\tenum pipe pipe = crtc->pipe;\n\tint i;\n\n\tassert_transcoder_disabled(dev_priv, crtc_state->cpu_transcoder);\n\n\t \n\tif (i9xx_has_pps(dev_priv))\n\t\tassert_pps_unlocked(dev_priv, pipe);\n\n\tintel_de_write(dev_priv, FP0(pipe), crtc_state->dpll_hw_state.fp0);\n\tintel_de_write(dev_priv, FP1(pipe), crtc_state->dpll_hw_state.fp1);\n\n\t \n\tintel_de_write(dev_priv, DPLL(pipe), dpll & ~DPLL_VGA_MODE_DIS);\n\tintel_de_write(dev_priv, DPLL(pipe), dpll);\n\n\t \n\tintel_de_posting_read(dev_priv, DPLL(pipe));\n\tudelay(150);\n\n\tif (DISPLAY_VER(dev_priv) >= 4) {\n\t\tintel_de_write(dev_priv, DPLL_MD(pipe),\n\t\t\t       crtc_state->dpll_hw_state.dpll_md);\n\t} else {\n\t\t \n\t\tintel_de_write(dev_priv, DPLL(pipe), dpll);\n\t}\n\n\t \n\tfor (i = 0; i < 3; i++) {\n\t\tintel_de_write(dev_priv, DPLL(pipe), dpll);\n\t\tintel_de_posting_read(dev_priv, DPLL(pipe));\n\t\tudelay(150);  \n\t}\n}\n\nstatic void vlv_pllb_recal_opamp(struct drm_i915_private *dev_priv,\n\t\t\t\t enum pipe pipe)\n{\n\tu32 reg_val;\n\n\t \n\treg_val = vlv_dpio_read(dev_priv, pipe, VLV_PLL_DW9(1));\n\treg_val &= 0xffffff00;\n\treg_val |= 0x00000030;\n\tvlv_dpio_write(dev_priv, pipe, VLV_PLL_DW9(1), reg_val);\n\n\treg_val = vlv_dpio_read(dev_priv, pipe, VLV_REF_DW13);\n\treg_val &= 0x00ffffff;\n\treg_val |= 0x8c000000;\n\tvlv_dpio_write(dev_priv, pipe, VLV_REF_DW13, reg_val);\n\n\treg_val = vlv_dpio_read(dev_priv, pipe, VLV_PLL_DW9(1));\n\treg_val &= 0xffffff00;\n\tvlv_dpio_write(dev_priv, pipe, VLV_PLL_DW9(1), reg_val);\n\n\treg_val = vlv_dpio_read(dev_priv, pipe, VLV_REF_DW13);\n\treg_val &= 0x00ffffff;\n\treg_val |= 0xb0000000;\n\tvlv_dpio_write(dev_priv, pipe, VLV_REF_DW13, reg_val);\n}\n\nstatic void vlv_prepare_pll(const struct intel_crtc_state *crtc_state)\n{\n\tstruct intel_crtc *crtc = to_intel_crtc(crtc_state->uapi.crtc);\n\tstruct drm_i915_private *dev_priv = to_i915(crtc->base.dev);\n\tenum pipe pipe = crtc->pipe;\n\tu32 mdiv;\n\tu32 bestn, bestm1, bestm2, bestp1, bestp2;\n\tu32 coreclk, reg_val;\n\n\tvlv_dpio_get(dev_priv);\n\n\tbestn = crtc_state->dpll.n;\n\tbestm1 = crtc_state->dpll.m1;\n\tbestm2 = crtc_state->dpll.m2;\n\tbestp1 = crtc_state->dpll.p1;\n\tbestp2 = crtc_state->dpll.p2;\n\n\t \n\n\t \n\tif (pipe == PIPE_B)\n\t\tvlv_pllb_recal_opamp(dev_priv, pipe);\n\n\t \n\tvlv_dpio_write(dev_priv, pipe, VLV_PLL_DW9_BCAST, 0x0100000f);\n\n\t \n\treg_val = vlv_dpio_read(dev_priv, pipe, VLV_PLL_DW8(pipe));\n\treg_val &= 0x00ffffff;\n\tvlv_dpio_write(dev_priv, pipe, VLV_PLL_DW8(pipe), reg_val);\n\n\t \n\tvlv_dpio_write(dev_priv, pipe, VLV_CMN_DW0, 0x610);\n\n\t \n\tmdiv = ((bestm1 << DPIO_M1DIV_SHIFT) | (bestm2 & DPIO_M2DIV_MASK));\n\tmdiv |= ((bestp1 << DPIO_P1_SHIFT) | (bestp2 << DPIO_P2_SHIFT));\n\tmdiv |= ((bestn << DPIO_N_SHIFT));\n\tmdiv |= (1 << DPIO_K_SHIFT);\n\n\t \n\tmdiv |= (DPIO_POST_DIV_HDMIDP << DPIO_POST_DIV_SHIFT);\n\tvlv_dpio_write(dev_priv, pipe, VLV_PLL_DW3(pipe), mdiv);\n\n\tmdiv |= DPIO_ENABLE_CALIBRATION;\n\tvlv_dpio_write(dev_priv, pipe, VLV_PLL_DW3(pipe), mdiv);\n\n\t \n\tif (crtc_state->port_clock == 162000 ||\n\t    intel_crtc_has_type(crtc_state, INTEL_OUTPUT_ANALOG) ||\n\t    intel_crtc_has_type(crtc_state, INTEL_OUTPUT_HDMI))\n\t\tvlv_dpio_write(dev_priv, pipe, VLV_PLL_DW10(pipe),\n\t\t\t\t 0x009f0003);\n\telse\n\t\tvlv_dpio_write(dev_priv, pipe, VLV_PLL_DW10(pipe),\n\t\t\t\t 0x00d0000f);\n\n\tif (intel_crtc_has_dp_encoder(crtc_state)) {\n\t\t \n\t\tif (pipe == PIPE_A)\n\t\t\tvlv_dpio_write(dev_priv, pipe, VLV_PLL_DW5(pipe),\n\t\t\t\t\t 0x0df40000);\n\t\telse\n\t\t\tvlv_dpio_write(dev_priv, pipe, VLV_PLL_DW5(pipe),\n\t\t\t\t\t 0x0df70000);\n\t} else {  \n\t\t \n\t\tif (pipe == PIPE_A)\n\t\t\tvlv_dpio_write(dev_priv, pipe, VLV_PLL_DW5(pipe),\n\t\t\t\t\t 0x0df70000);\n\t\telse\n\t\t\tvlv_dpio_write(dev_priv, pipe, VLV_PLL_DW5(pipe),\n\t\t\t\t\t 0x0df40000);\n\t}\n\n\tcoreclk = vlv_dpio_read(dev_priv, pipe, VLV_PLL_DW7(pipe));\n\tcoreclk = (coreclk & 0x0000ff00) | 0x01c00000;\n\tif (intel_crtc_has_dp_encoder(crtc_state))\n\t\tcoreclk |= 0x01000000;\n\tvlv_dpio_write(dev_priv, pipe, VLV_PLL_DW7(pipe), coreclk);\n\n\tvlv_dpio_write(dev_priv, pipe, VLV_PLL_DW11(pipe), 0x87871000);\n\n\tvlv_dpio_put(dev_priv);\n}\n\nstatic void _vlv_enable_pll(const struct intel_crtc_state *crtc_state)\n{\n\tstruct intel_crtc *crtc = to_intel_crtc(crtc_state->uapi.crtc);\n\tstruct drm_i915_private *dev_priv = to_i915(crtc->base.dev);\n\tenum pipe pipe = crtc->pipe;\n\n\tintel_de_write(dev_priv, DPLL(pipe), crtc_state->dpll_hw_state.dpll);\n\tintel_de_posting_read(dev_priv, DPLL(pipe));\n\tudelay(150);\n\n\tif (intel_de_wait_for_set(dev_priv, DPLL(pipe), DPLL_LOCK_VLV, 1))\n\t\tdrm_err(&dev_priv->drm, \"DPLL %d failed to lock\\n\", pipe);\n}\n\nvoid vlv_enable_pll(const struct intel_crtc_state *crtc_state)\n{\n\tstruct intel_crtc *crtc = to_intel_crtc(crtc_state->uapi.crtc);\n\tstruct drm_i915_private *dev_priv = to_i915(crtc->base.dev);\n\tenum pipe pipe = crtc->pipe;\n\n\tassert_transcoder_disabled(dev_priv, crtc_state->cpu_transcoder);\n\n\t \n\tassert_pps_unlocked(dev_priv, pipe);\n\n\t \n\tintel_de_write(dev_priv, DPLL(pipe),\n\t\t       crtc_state->dpll_hw_state.dpll &\n\t\t       ~(DPLL_VCO_ENABLE | DPLL_EXT_BUFFER_ENABLE_VLV));\n\n\tif (crtc_state->dpll_hw_state.dpll & DPLL_VCO_ENABLE) {\n\t\tvlv_prepare_pll(crtc_state);\n\t\t_vlv_enable_pll(crtc_state);\n\t}\n\n\tintel_de_write(dev_priv, DPLL_MD(pipe),\n\t\t       crtc_state->dpll_hw_state.dpll_md);\n\tintel_de_posting_read(dev_priv, DPLL_MD(pipe));\n}\n\nstatic void chv_prepare_pll(const struct intel_crtc_state *crtc_state)\n{\n\tstruct intel_crtc *crtc = to_intel_crtc(crtc_state->uapi.crtc);\n\tstruct drm_i915_private *dev_priv = to_i915(crtc->base.dev);\n\tenum pipe pipe = crtc->pipe;\n\tenum dpio_channel port = vlv_pipe_to_channel(pipe);\n\tu32 loopfilter, tribuf_calcntr;\n\tu32 bestm2, bestp1, bestp2, bestm2_frac;\n\tu32 dpio_val;\n\tint vco;\n\n\tbestm2_frac = crtc_state->dpll.m2 & 0x3fffff;\n\tbestm2 = crtc_state->dpll.m2 >> 22;\n\tbestp1 = crtc_state->dpll.p1;\n\tbestp2 = crtc_state->dpll.p2;\n\tvco = crtc_state->dpll.vco;\n\tdpio_val = 0;\n\tloopfilter = 0;\n\n\tvlv_dpio_get(dev_priv);\n\n\t \n\tvlv_dpio_write(dev_priv, pipe, CHV_CMN_DW13(port),\n\t\t\t5 << DPIO_CHV_S1_DIV_SHIFT |\n\t\t\tbestp1 << DPIO_CHV_P1_DIV_SHIFT |\n\t\t\tbestp2 << DPIO_CHV_P2_DIV_SHIFT |\n\t\t\t1 << DPIO_CHV_K_DIV_SHIFT);\n\n\t \n\tvlv_dpio_write(dev_priv, pipe, CHV_PLL_DW0(port), bestm2);\n\n\t \n\tvlv_dpio_write(dev_priv, pipe, CHV_PLL_DW1(port),\n\t\t\tDPIO_CHV_M1_DIV_BY_2 |\n\t\t\t1 << DPIO_CHV_N_DIV_SHIFT);\n\n\t \n\tvlv_dpio_write(dev_priv, pipe, CHV_PLL_DW2(port), bestm2_frac);\n\n\t \n\tdpio_val = vlv_dpio_read(dev_priv, pipe, CHV_PLL_DW3(port));\n\tdpio_val &= ~(DPIO_CHV_FEEDFWD_GAIN_MASK | DPIO_CHV_FRAC_DIV_EN);\n\tdpio_val |= (2 << DPIO_CHV_FEEDFWD_GAIN_SHIFT);\n\tif (bestm2_frac)\n\t\tdpio_val |= DPIO_CHV_FRAC_DIV_EN;\n\tvlv_dpio_write(dev_priv, pipe, CHV_PLL_DW3(port), dpio_val);\n\n\t \n\tdpio_val = vlv_dpio_read(dev_priv, pipe, CHV_PLL_DW9(port));\n\tdpio_val &= ~(DPIO_CHV_INT_LOCK_THRESHOLD_MASK |\n\t\t\t\t\tDPIO_CHV_INT_LOCK_THRESHOLD_SEL_COARSE);\n\tdpio_val |= (0x5 << DPIO_CHV_INT_LOCK_THRESHOLD_SHIFT);\n\tif (!bestm2_frac)\n\t\tdpio_val |= DPIO_CHV_INT_LOCK_THRESHOLD_SEL_COARSE;\n\tvlv_dpio_write(dev_priv, pipe, CHV_PLL_DW9(port), dpio_val);\n\n\t \n\tif (vco == 5400000) {\n\t\tloopfilter |= (0x3 << DPIO_CHV_PROP_COEFF_SHIFT);\n\t\tloopfilter |= (0x8 << DPIO_CHV_INT_COEFF_SHIFT);\n\t\tloopfilter |= (0x1 << DPIO_CHV_GAIN_CTRL_SHIFT);\n\t\ttribuf_calcntr = 0x9;\n\t} else if (vco <= 6200000) {\n\t\tloopfilter |= (0x5 << DPIO_CHV_PROP_COEFF_SHIFT);\n\t\tloopfilter |= (0xB << DPIO_CHV_INT_COEFF_SHIFT);\n\t\tloopfilter |= (0x3 << DPIO_CHV_GAIN_CTRL_SHIFT);\n\t\ttribuf_calcntr = 0x9;\n\t} else if (vco <= 6480000) {\n\t\tloopfilter |= (0x4 << DPIO_CHV_PROP_COEFF_SHIFT);\n\t\tloopfilter |= (0x9 << DPIO_CHV_INT_COEFF_SHIFT);\n\t\tloopfilter |= (0x3 << DPIO_CHV_GAIN_CTRL_SHIFT);\n\t\ttribuf_calcntr = 0x8;\n\t} else {\n\t\t \n\t\tloopfilter |= (0x4 << DPIO_CHV_PROP_COEFF_SHIFT);\n\t\tloopfilter |= (0x9 << DPIO_CHV_INT_COEFF_SHIFT);\n\t\tloopfilter |= (0x3 << DPIO_CHV_GAIN_CTRL_SHIFT);\n\t\ttribuf_calcntr = 0;\n\t}\n\tvlv_dpio_write(dev_priv, pipe, CHV_PLL_DW6(port), loopfilter);\n\n\tdpio_val = vlv_dpio_read(dev_priv, pipe, CHV_PLL_DW8(port));\n\tdpio_val &= ~DPIO_CHV_TDC_TARGET_CNT_MASK;\n\tdpio_val |= (tribuf_calcntr << DPIO_CHV_TDC_TARGET_CNT_SHIFT);\n\tvlv_dpio_write(dev_priv, pipe, CHV_PLL_DW8(port), dpio_val);\n\n\t \n\tvlv_dpio_write(dev_priv, pipe, CHV_CMN_DW14(port),\n\t\t\tvlv_dpio_read(dev_priv, pipe, CHV_CMN_DW14(port)) |\n\t\t\tDPIO_AFC_RECAL);\n\n\tvlv_dpio_put(dev_priv);\n}\n\nstatic void _chv_enable_pll(const struct intel_crtc_state *crtc_state)\n{\n\tstruct intel_crtc *crtc = to_intel_crtc(crtc_state->uapi.crtc);\n\tstruct drm_i915_private *dev_priv = to_i915(crtc->base.dev);\n\tenum pipe pipe = crtc->pipe;\n\tenum dpio_channel port = vlv_pipe_to_channel(pipe);\n\tu32 tmp;\n\n\tvlv_dpio_get(dev_priv);\n\n\t \n\ttmp = vlv_dpio_read(dev_priv, pipe, CHV_CMN_DW14(port));\n\ttmp |= DPIO_DCLKP_EN;\n\tvlv_dpio_write(dev_priv, pipe, CHV_CMN_DW14(port), tmp);\n\n\tvlv_dpio_put(dev_priv);\n\n\t \n\tudelay(1);\n\n\t \n\tintel_de_write(dev_priv, DPLL(pipe), crtc_state->dpll_hw_state.dpll);\n\n\t \n\tif (intel_de_wait_for_set(dev_priv, DPLL(pipe), DPLL_LOCK_VLV, 1))\n\t\tdrm_err(&dev_priv->drm, \"PLL %d failed to lock\\n\", pipe);\n}\n\nvoid chv_enable_pll(const struct intel_crtc_state *crtc_state)\n{\n\tstruct intel_crtc *crtc = to_intel_crtc(crtc_state->uapi.crtc);\n\tstruct drm_i915_private *dev_priv = to_i915(crtc->base.dev);\n\tenum pipe pipe = crtc->pipe;\n\n\tassert_transcoder_disabled(dev_priv, crtc_state->cpu_transcoder);\n\n\t \n\tassert_pps_unlocked(dev_priv, pipe);\n\n\t \n\tintel_de_write(dev_priv, DPLL(pipe),\n\t\t       crtc_state->dpll_hw_state.dpll & ~DPLL_VCO_ENABLE);\n\n\tif (crtc_state->dpll_hw_state.dpll & DPLL_VCO_ENABLE) {\n\t\tchv_prepare_pll(crtc_state);\n\t\t_chv_enable_pll(crtc_state);\n\t}\n\n\tif (pipe != PIPE_A) {\n\t\t \n\t\tintel_de_write(dev_priv, CBR4_VLV, CBR_DPLLBMD_PIPE(pipe));\n\t\tintel_de_write(dev_priv, DPLL_MD(PIPE_B),\n\t\t\t       crtc_state->dpll_hw_state.dpll_md);\n\t\tintel_de_write(dev_priv, CBR4_VLV, 0);\n\t\tdev_priv->display.state.chv_dpll_md[pipe] = crtc_state->dpll_hw_state.dpll_md;\n\n\t\t \n\t\tdrm_WARN_ON(&dev_priv->drm,\n\t\t\t    (intel_de_read(dev_priv, DPLL(PIPE_B)) &\n\t\t\t     DPLL_VGA_MODE_DIS) == 0);\n\t} else {\n\t\tintel_de_write(dev_priv, DPLL_MD(pipe),\n\t\t\t       crtc_state->dpll_hw_state.dpll_md);\n\t\tintel_de_posting_read(dev_priv, DPLL_MD(pipe));\n\t}\n}\n\n \nint vlv_force_pll_on(struct drm_i915_private *dev_priv, enum pipe pipe,\n\t\t     const struct dpll *dpll)\n{\n\tstruct intel_crtc *crtc = intel_crtc_for_pipe(dev_priv, pipe);\n\tstruct intel_crtc_state *crtc_state;\n\n\tcrtc_state = intel_crtc_state_alloc(crtc);\n\tif (!crtc_state)\n\t\treturn -ENOMEM;\n\n\tcrtc_state->cpu_transcoder = (enum transcoder)pipe;\n\tcrtc_state->pixel_multiplier = 1;\n\tcrtc_state->dpll = *dpll;\n\tcrtc_state->output_types = BIT(INTEL_OUTPUT_EDP);\n\n\tif (IS_CHERRYVIEW(dev_priv)) {\n\t\tchv_compute_dpll(crtc_state);\n\t\tchv_enable_pll(crtc_state);\n\t} else {\n\t\tvlv_compute_dpll(crtc_state);\n\t\tvlv_enable_pll(crtc_state);\n\t}\n\n\tkfree(crtc_state);\n\n\treturn 0;\n}\n\nvoid vlv_disable_pll(struct drm_i915_private *dev_priv, enum pipe pipe)\n{\n\tu32 val;\n\n\t \n\tassert_transcoder_disabled(dev_priv, (enum transcoder)pipe);\n\n\tval = DPLL_INTEGRATED_REF_CLK_VLV |\n\t\tDPLL_REF_CLK_ENABLE_VLV | DPLL_VGA_MODE_DIS;\n\tif (pipe != PIPE_A)\n\t\tval |= DPLL_INTEGRATED_CRI_CLK_VLV;\n\n\tintel_de_write(dev_priv, DPLL(pipe), val);\n\tintel_de_posting_read(dev_priv, DPLL(pipe));\n}\n\nvoid chv_disable_pll(struct drm_i915_private *dev_priv, enum pipe pipe)\n{\n\tenum dpio_channel port = vlv_pipe_to_channel(pipe);\n\tu32 val;\n\n\t \n\tassert_transcoder_disabled(dev_priv, (enum transcoder)pipe);\n\n\tval = DPLL_SSC_REF_CLK_CHV |\n\t\tDPLL_REF_CLK_ENABLE_VLV | DPLL_VGA_MODE_DIS;\n\tif (pipe != PIPE_A)\n\t\tval |= DPLL_INTEGRATED_CRI_CLK_VLV;\n\n\tintel_de_write(dev_priv, DPLL(pipe), val);\n\tintel_de_posting_read(dev_priv, DPLL(pipe));\n\n\tvlv_dpio_get(dev_priv);\n\n\t \n\tval = vlv_dpio_read(dev_priv, pipe, CHV_CMN_DW14(port));\n\tval &= ~DPIO_DCLKP_EN;\n\tvlv_dpio_write(dev_priv, pipe, CHV_CMN_DW14(port), val);\n\n\tvlv_dpio_put(dev_priv);\n}\n\nvoid i9xx_disable_pll(const struct intel_crtc_state *crtc_state)\n{\n\tstruct intel_crtc *crtc = to_intel_crtc(crtc_state->uapi.crtc);\n\tstruct drm_i915_private *dev_priv = to_i915(crtc->base.dev);\n\tenum pipe pipe = crtc->pipe;\n\n\t \n\tif (IS_I830(dev_priv))\n\t\treturn;\n\n\t \n\tassert_transcoder_disabled(dev_priv, crtc_state->cpu_transcoder);\n\n\tintel_de_write(dev_priv, DPLL(pipe), DPLL_VGA_MODE_DIS);\n\tintel_de_posting_read(dev_priv, DPLL(pipe));\n}\n\n\n \nvoid vlv_force_pll_off(struct drm_i915_private *dev_priv, enum pipe pipe)\n{\n\tif (IS_CHERRYVIEW(dev_priv))\n\t\tchv_disable_pll(dev_priv, pipe);\n\telse\n\t\tvlv_disable_pll(dev_priv, pipe);\n}\n\n \nstatic void assert_pll(struct drm_i915_private *dev_priv,\n\t\t       enum pipe pipe, bool state)\n{\n\tbool cur_state;\n\n\tcur_state = intel_de_read(dev_priv, DPLL(pipe)) & DPLL_VCO_ENABLE;\n\tI915_STATE_WARN(dev_priv, cur_state != state,\n\t\t\t\"PLL state assertion failure (expected %s, current %s)\\n\",\n\t\t\tstr_on_off(state), str_on_off(cur_state));\n}\n\nvoid assert_pll_enabled(struct drm_i915_private *i915, enum pipe pipe)\n{\n\tassert_pll(i915, pipe, true);\n}\n\nvoid assert_pll_disabled(struct drm_i915_private *i915, enum pipe pipe)\n{\n\tassert_pll(i915, pipe, false);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}