{
  "module_name": "intel_wm.c",
  "hash_id": "8c22842cab8406ade8e571b669c841fc87ac47d779ac163c38f6f63e27d7ac4d",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/i915/display/intel_wm.c",
  "human_readable_source": "\n \n\n#include \"i915_drv.h\"\n#include \"i9xx_wm.h\"\n#include \"intel_display_types.h\"\n#include \"intel_wm.h\"\n#include \"skl_watermark.h\"\n\n \nvoid intel_update_watermarks(struct drm_i915_private *i915)\n{\n\tif (i915->display.funcs.wm->update_wm)\n\t\ti915->display.funcs.wm->update_wm(i915);\n}\n\nint intel_compute_pipe_wm(struct intel_atomic_state *state,\n\t\t\t  struct intel_crtc *crtc)\n{\n\tstruct drm_i915_private *i915 = to_i915(state->base.dev);\n\n\tif (i915->display.funcs.wm->compute_pipe_wm)\n\t\treturn i915->display.funcs.wm->compute_pipe_wm(state, crtc);\n\n\treturn 0;\n}\n\nint intel_compute_intermediate_wm(struct intel_atomic_state *state,\n\t\t\t\t  struct intel_crtc *crtc)\n{\n\tstruct drm_i915_private *i915 = to_i915(state->base.dev);\n\n\tif (!i915->display.funcs.wm->compute_intermediate_wm)\n\t\treturn 0;\n\n\tif (drm_WARN_ON(&i915->drm, !i915->display.funcs.wm->compute_pipe_wm))\n\t\treturn 0;\n\n\treturn i915->display.funcs.wm->compute_intermediate_wm(state, crtc);\n}\n\nbool intel_initial_watermarks(struct intel_atomic_state *state,\n\t\t\t      struct intel_crtc *crtc)\n{\n\tstruct drm_i915_private *i915 = to_i915(state->base.dev);\n\n\tif (i915->display.funcs.wm->initial_watermarks) {\n\t\ti915->display.funcs.wm->initial_watermarks(state, crtc);\n\t\treturn true;\n\t}\n\n\treturn false;\n}\n\nvoid intel_atomic_update_watermarks(struct intel_atomic_state *state,\n\t\t\t\t    struct intel_crtc *crtc)\n{\n\tstruct drm_i915_private *i915 = to_i915(state->base.dev);\n\n\tif (i915->display.funcs.wm->atomic_update_watermarks)\n\t\ti915->display.funcs.wm->atomic_update_watermarks(state, crtc);\n}\n\nvoid intel_optimize_watermarks(struct intel_atomic_state *state,\n\t\t\t       struct intel_crtc *crtc)\n{\n\tstruct drm_i915_private *i915 = to_i915(state->base.dev);\n\n\tif (i915->display.funcs.wm->optimize_watermarks)\n\t\ti915->display.funcs.wm->optimize_watermarks(state, crtc);\n}\n\nint intel_compute_global_watermarks(struct intel_atomic_state *state)\n{\n\tstruct drm_i915_private *i915 = to_i915(state->base.dev);\n\n\tif (i915->display.funcs.wm->compute_global_watermarks)\n\t\treturn i915->display.funcs.wm->compute_global_watermarks(state);\n\n\treturn 0;\n}\n\nvoid intel_wm_get_hw_state(struct drm_i915_private *i915)\n{\n\tif (i915->display.funcs.wm->get_hw_state)\n\t\treturn i915->display.funcs.wm->get_hw_state(i915);\n}\n\nbool intel_wm_plane_visible(const struct intel_crtc_state *crtc_state,\n\t\t\t    const struct intel_plane_state *plane_state)\n{\n\tstruct intel_plane *plane = to_intel_plane(plane_state->uapi.plane);\n\n\t \n\tif (!crtc_state->hw.active)\n\t\treturn false;\n\n\t \n\tif (plane->id == PLANE_CURSOR)\n\t\treturn plane_state->hw.fb != NULL;\n\telse\n\t\treturn plane_state->uapi.visible;\n}\n\nvoid intel_print_wm_latency(struct drm_i915_private *dev_priv,\n\t\t\t    const char *name, const u16 wm[])\n{\n\tint level;\n\n\tfor (level = 0; level < dev_priv->display.wm.num_levels; level++) {\n\t\tunsigned int latency = wm[level];\n\n\t\tif (latency == 0) {\n\t\t\tdrm_dbg_kms(&dev_priv->drm,\n\t\t\t\t    \"%s WM%d latency not provided\\n\",\n\t\t\t\t    name, level);\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\tif (DISPLAY_VER(dev_priv) >= 9)\n\t\t\tlatency *= 10;\n\t\telse if (level > 0)\n\t\t\tlatency *= 5;\n\n\t\tdrm_dbg_kms(&dev_priv->drm,\n\t\t\t    \"%s WM%d latency %u (%u.%u usec)\\n\", name, level,\n\t\t\t    wm[level], latency / 10, latency % 10);\n\t}\n}\n\nvoid intel_wm_init(struct drm_i915_private *i915)\n{\n\tif (DISPLAY_VER(i915) >= 9)\n\t\tskl_wm_init(i915);\n\telse\n\t\ti9xx_wm_init(i915);\n}\n\nstatic void wm_latency_show(struct seq_file *m, const u16 wm[8])\n{\n\tstruct drm_i915_private *dev_priv = m->private;\n\tint level;\n\n\tdrm_modeset_lock_all(&dev_priv->drm);\n\n\tfor (level = 0; level < dev_priv->display.wm.num_levels; level++) {\n\t\tunsigned int latency = wm[level];\n\n\t\t \n\t\tif (DISPLAY_VER(dev_priv) >= 9 ||\n\t\t    IS_VALLEYVIEW(dev_priv) ||\n\t\t    IS_CHERRYVIEW(dev_priv) ||\n\t\t    IS_G4X(dev_priv))\n\t\t\tlatency *= 10;\n\t\telse if (level > 0)\n\t\t\tlatency *= 5;\n\n\t\tseq_printf(m, \"WM%d %u (%u.%u usec)\\n\",\n\t\t\t   level, wm[level], latency / 10, latency % 10);\n\t}\n\n\tdrm_modeset_unlock_all(&dev_priv->drm);\n}\n\nstatic int pri_wm_latency_show(struct seq_file *m, void *data)\n{\n\tstruct drm_i915_private *dev_priv = m->private;\n\tconst u16 *latencies;\n\n\tif (DISPLAY_VER(dev_priv) >= 9)\n\t\tlatencies = dev_priv->display.wm.skl_latency;\n\telse\n\t\tlatencies = dev_priv->display.wm.pri_latency;\n\n\twm_latency_show(m, latencies);\n\n\treturn 0;\n}\n\nstatic int spr_wm_latency_show(struct seq_file *m, void *data)\n{\n\tstruct drm_i915_private *dev_priv = m->private;\n\tconst u16 *latencies;\n\n\tif (DISPLAY_VER(dev_priv) >= 9)\n\t\tlatencies = dev_priv->display.wm.skl_latency;\n\telse\n\t\tlatencies = dev_priv->display.wm.spr_latency;\n\n\twm_latency_show(m, latencies);\n\n\treturn 0;\n}\n\nstatic int cur_wm_latency_show(struct seq_file *m, void *data)\n{\n\tstruct drm_i915_private *dev_priv = m->private;\n\tconst u16 *latencies;\n\n\tif (DISPLAY_VER(dev_priv) >= 9)\n\t\tlatencies = dev_priv->display.wm.skl_latency;\n\telse\n\t\tlatencies = dev_priv->display.wm.cur_latency;\n\n\twm_latency_show(m, latencies);\n\n\treturn 0;\n}\n\nstatic int pri_wm_latency_open(struct inode *inode, struct file *file)\n{\n\tstruct drm_i915_private *dev_priv = inode->i_private;\n\n\tif (DISPLAY_VER(dev_priv) < 5 && !IS_G4X(dev_priv))\n\t\treturn -ENODEV;\n\n\treturn single_open(file, pri_wm_latency_show, dev_priv);\n}\n\nstatic int spr_wm_latency_open(struct inode *inode, struct file *file)\n{\n\tstruct drm_i915_private *dev_priv = inode->i_private;\n\n\tif (HAS_GMCH(dev_priv))\n\t\treturn -ENODEV;\n\n\treturn single_open(file, spr_wm_latency_show, dev_priv);\n}\n\nstatic int cur_wm_latency_open(struct inode *inode, struct file *file)\n{\n\tstruct drm_i915_private *dev_priv = inode->i_private;\n\n\tif (HAS_GMCH(dev_priv))\n\t\treturn -ENODEV;\n\n\treturn single_open(file, cur_wm_latency_show, dev_priv);\n}\n\nstatic ssize_t wm_latency_write(struct file *file, const char __user *ubuf,\n\t\t\t\tsize_t len, loff_t *offp, u16 wm[8])\n{\n\tstruct seq_file *m = file->private_data;\n\tstruct drm_i915_private *dev_priv = m->private;\n\tu16 new[8] = { 0 };\n\tint level;\n\tint ret;\n\tchar tmp[32];\n\n\tif (len >= sizeof(tmp))\n\t\treturn -EINVAL;\n\n\tif (copy_from_user(tmp, ubuf, len))\n\t\treturn -EFAULT;\n\n\ttmp[len] = '\\0';\n\n\tret = sscanf(tmp, \"%hu %hu %hu %hu %hu %hu %hu %hu\",\n\t\t     &new[0], &new[1], &new[2], &new[3],\n\t\t     &new[4], &new[5], &new[6], &new[7]);\n\tif (ret != dev_priv->display.wm.num_levels)\n\t\treturn -EINVAL;\n\n\tdrm_modeset_lock_all(&dev_priv->drm);\n\n\tfor (level = 0; level < dev_priv->display.wm.num_levels; level++)\n\t\twm[level] = new[level];\n\n\tdrm_modeset_unlock_all(&dev_priv->drm);\n\n\treturn len;\n}\n\nstatic ssize_t pri_wm_latency_write(struct file *file, const char __user *ubuf,\n\t\t\t\t    size_t len, loff_t *offp)\n{\n\tstruct seq_file *m = file->private_data;\n\tstruct drm_i915_private *dev_priv = m->private;\n\tu16 *latencies;\n\n\tif (DISPLAY_VER(dev_priv) >= 9)\n\t\tlatencies = dev_priv->display.wm.skl_latency;\n\telse\n\t\tlatencies = dev_priv->display.wm.pri_latency;\n\n\treturn wm_latency_write(file, ubuf, len, offp, latencies);\n}\n\nstatic ssize_t spr_wm_latency_write(struct file *file, const char __user *ubuf,\n\t\t\t\t    size_t len, loff_t *offp)\n{\n\tstruct seq_file *m = file->private_data;\n\tstruct drm_i915_private *dev_priv = m->private;\n\tu16 *latencies;\n\n\tif (DISPLAY_VER(dev_priv) >= 9)\n\t\tlatencies = dev_priv->display.wm.skl_latency;\n\telse\n\t\tlatencies = dev_priv->display.wm.spr_latency;\n\n\treturn wm_latency_write(file, ubuf, len, offp, latencies);\n}\n\nstatic ssize_t cur_wm_latency_write(struct file *file, const char __user *ubuf,\n\t\t\t\t    size_t len, loff_t *offp)\n{\n\tstruct seq_file *m = file->private_data;\n\tstruct drm_i915_private *dev_priv = m->private;\n\tu16 *latencies;\n\n\tif (DISPLAY_VER(dev_priv) >= 9)\n\t\tlatencies = dev_priv->display.wm.skl_latency;\n\telse\n\t\tlatencies = dev_priv->display.wm.cur_latency;\n\n\treturn wm_latency_write(file, ubuf, len, offp, latencies);\n}\n\nstatic const struct file_operations i915_pri_wm_latency_fops = {\n\t.owner = THIS_MODULE,\n\t.open = pri_wm_latency_open,\n\t.read = seq_read,\n\t.llseek = seq_lseek,\n\t.release = single_release,\n\t.write = pri_wm_latency_write\n};\n\nstatic const struct file_operations i915_spr_wm_latency_fops = {\n\t.owner = THIS_MODULE,\n\t.open = spr_wm_latency_open,\n\t.read = seq_read,\n\t.llseek = seq_lseek,\n\t.release = single_release,\n\t.write = spr_wm_latency_write\n};\n\nstatic const struct file_operations i915_cur_wm_latency_fops = {\n\t.owner = THIS_MODULE,\n\t.open = cur_wm_latency_open,\n\t.read = seq_read,\n\t.llseek = seq_lseek,\n\t.release = single_release,\n\t.write = cur_wm_latency_write\n};\n\nvoid intel_wm_debugfs_register(struct drm_i915_private *i915)\n{\n\tstruct drm_minor *minor = i915->drm.primary;\n\n\tdebugfs_create_file(\"i915_pri_wm_latency\", 0644, minor->debugfs_root,\n\t\t\t    i915, &i915_pri_wm_latency_fops);\n\n\tdebugfs_create_file(\"i915_spr_wm_latency\", 0644, minor->debugfs_root,\n\t\t\t    i915, &i915_spr_wm_latency_fops);\n\n\tdebugfs_create_file(\"i915_cur_wm_latency\", 0644, minor->debugfs_root,\n\t\t\t    i915, &i915_cur_wm_latency_fops);\n\n\tskl_watermark_debugfs_register(i915);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}