{
  "module_name": "hsw_ips.c",
  "hash_id": "7d52c81895af0d18cc6b43ae9b0e867c165ebfa21476f722eec862d8c2a0717d",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/i915/display/hsw_ips.c",
  "human_readable_source": "\n \n\n#include \"hsw_ips.h\"\n#include \"i915_drv.h\"\n#include \"i915_reg.h\"\n#include \"intel_de.h\"\n#include \"intel_display_types.h\"\n#include \"intel_pcode.h\"\n\nstatic void hsw_ips_enable(const struct intel_crtc_state *crtc_state)\n{\n\tstruct intel_crtc *crtc = to_intel_crtc(crtc_state->uapi.crtc);\n\tstruct drm_i915_private *i915 = to_i915(crtc->base.dev);\n\tu32 val;\n\n\tif (!crtc_state->ips_enabled)\n\t\treturn;\n\n\t \n\tdrm_WARN_ON(&i915->drm,\n\t\t    !(crtc_state->active_planes & ~BIT(PLANE_CURSOR)));\n\n\tval = IPS_ENABLE;\n\n\tif (i915->display.ips.false_color)\n\t\tval |= IPS_FALSE_COLOR;\n\n\tif (IS_BROADWELL(i915)) {\n\t\tdrm_WARN_ON(&i915->drm,\n\t\t\t    snb_pcode_write(&i915->uncore, DISPLAY_IPS_CONTROL,\n\t\t\t\t\t    val | IPS_PCODE_CONTROL));\n\t\t \n\t} else {\n\t\tintel_de_write(i915, IPS_CTL, val);\n\t\t \n\t\tif (intel_de_wait_for_set(i915, IPS_CTL, IPS_ENABLE, 50))\n\t\t\tdrm_err(&i915->drm,\n\t\t\t\t\"Timed out waiting for IPS enable\\n\");\n\t}\n}\n\nbool hsw_ips_disable(const struct intel_crtc_state *crtc_state)\n{\n\tstruct intel_crtc *crtc = to_intel_crtc(crtc_state->uapi.crtc);\n\tstruct drm_i915_private *i915 = to_i915(crtc->base.dev);\n\tbool need_vblank_wait = false;\n\n\tif (!crtc_state->ips_enabled)\n\t\treturn need_vblank_wait;\n\n\tif (IS_BROADWELL(i915)) {\n\t\tdrm_WARN_ON(&i915->drm,\n\t\t\t    snb_pcode_write(&i915->uncore, DISPLAY_IPS_CONTROL, 0));\n\t\t \n\t\tif (intel_de_wait_for_clear(i915, IPS_CTL, IPS_ENABLE, 100))\n\t\t\tdrm_err(&i915->drm,\n\t\t\t\t\"Timed out waiting for IPS disable\\n\");\n\t} else {\n\t\tintel_de_write(i915, IPS_CTL, 0);\n\t\tintel_de_posting_read(i915, IPS_CTL);\n\t}\n\n\t \n\tneed_vblank_wait = true;\n\n\treturn need_vblank_wait;\n}\n\nstatic bool hsw_ips_need_disable(struct intel_atomic_state *state,\n\t\t\t\t struct intel_crtc *crtc)\n{\n\tstruct drm_i915_private *i915 = to_i915(state->base.dev);\n\tconst struct intel_crtc_state *old_crtc_state =\n\t\tintel_atomic_get_old_crtc_state(state, crtc);\n\tconst struct intel_crtc_state *new_crtc_state =\n\t\tintel_atomic_get_new_crtc_state(state, crtc);\n\n\tif (!old_crtc_state->ips_enabled)\n\t\treturn false;\n\n\tif (intel_crtc_needs_modeset(new_crtc_state))\n\t\treturn true;\n\n\t \n\tif (IS_HASWELL(i915) &&\n\t    intel_crtc_needs_color_update(new_crtc_state) &&\n\t    new_crtc_state->gamma_mode == GAMMA_MODE_MODE_SPLIT)\n\t\treturn true;\n\n\treturn !new_crtc_state->ips_enabled;\n}\n\nbool hsw_ips_pre_update(struct intel_atomic_state *state,\n\t\t\tstruct intel_crtc *crtc)\n{\n\tconst struct intel_crtc_state *old_crtc_state =\n\t\tintel_atomic_get_old_crtc_state(state, crtc);\n\n\tif (!hsw_ips_need_disable(state, crtc))\n\t\treturn false;\n\n\treturn hsw_ips_disable(old_crtc_state);\n}\n\nstatic bool hsw_ips_need_enable(struct intel_atomic_state *state,\n\t\t\t\tstruct intel_crtc *crtc)\n{\n\tstruct drm_i915_private *i915 = to_i915(state->base.dev);\n\tconst struct intel_crtc_state *old_crtc_state =\n\t\tintel_atomic_get_old_crtc_state(state, crtc);\n\tconst struct intel_crtc_state *new_crtc_state =\n\t\tintel_atomic_get_new_crtc_state(state, crtc);\n\n\tif (!new_crtc_state->ips_enabled)\n\t\treturn false;\n\n\tif (intel_crtc_needs_modeset(new_crtc_state))\n\t\treturn true;\n\n\t \n\tif (IS_HASWELL(i915) &&\n\t    intel_crtc_needs_color_update(new_crtc_state) &&\n\t    new_crtc_state->gamma_mode == GAMMA_MODE_MODE_SPLIT)\n\t\treturn true;\n\n\t \n\tif (intel_crtc_needs_fastset(new_crtc_state) && old_crtc_state->inherited)\n\t\treturn true;\n\n\treturn !old_crtc_state->ips_enabled;\n}\n\nvoid hsw_ips_post_update(struct intel_atomic_state *state,\n\t\t\t struct intel_crtc *crtc)\n{\n\tconst struct intel_crtc_state *new_crtc_state =\n\t\tintel_atomic_get_new_crtc_state(state, crtc);\n\n\tif (!hsw_ips_need_enable(state, crtc))\n\t\treturn;\n\n\thsw_ips_enable(new_crtc_state);\n}\n\n \nbool hsw_crtc_supports_ips(struct intel_crtc *crtc)\n{\n\treturn HAS_IPS(to_i915(crtc->base.dev)) && crtc->pipe == PIPE_A;\n}\n\nbool hsw_crtc_state_ips_capable(const struct intel_crtc_state *crtc_state)\n{\n\tstruct intel_crtc *crtc = to_intel_crtc(crtc_state->uapi.crtc);\n\tstruct drm_i915_private *i915 = to_i915(crtc->base.dev);\n\n\t \n\tif (!hsw_crtc_supports_ips(crtc))\n\t\treturn false;\n\n\tif (!i915->params.enable_ips)\n\t\treturn false;\n\n\tif (crtc_state->pipe_bpp > 24)\n\t\treturn false;\n\n\t \n\tif (IS_BROADWELL(i915) &&\n\t    crtc_state->pixel_rate > i915->display.cdclk.max_cdclk_freq * 95 / 100)\n\t\treturn false;\n\n\treturn true;\n}\n\nint hsw_ips_compute_config(struct intel_atomic_state *state,\n\t\t\t   struct intel_crtc *crtc)\n{\n\tstruct drm_i915_private *i915 = to_i915(state->base.dev);\n\tstruct intel_crtc_state *crtc_state =\n\t\tintel_atomic_get_new_crtc_state(state, crtc);\n\n\tcrtc_state->ips_enabled = false;\n\n\tif (!hsw_crtc_state_ips_capable(crtc_state))\n\t\treturn 0;\n\n\t \n\tif (crtc_state->crc_enabled)\n\t\treturn 0;\n\n\t \n\tif (!(crtc_state->active_planes & ~BIT(PLANE_CURSOR)))\n\t\treturn 0;\n\n\tif (IS_BROADWELL(i915)) {\n\t\tconst struct intel_cdclk_state *cdclk_state;\n\n\t\tcdclk_state = intel_atomic_get_cdclk_state(state);\n\t\tif (IS_ERR(cdclk_state))\n\t\t\treturn PTR_ERR(cdclk_state);\n\n\t\t \n\t\tif (crtc_state->pixel_rate > cdclk_state->logical.cdclk * 95 / 100)\n\t\t\treturn 0;\n\t}\n\n\tcrtc_state->ips_enabled = true;\n\n\treturn 0;\n}\n\nvoid hsw_ips_get_config(struct intel_crtc_state *crtc_state)\n{\n\tstruct intel_crtc *crtc = to_intel_crtc(crtc_state->uapi.crtc);\n\tstruct drm_i915_private *i915 = to_i915(crtc->base.dev);\n\n\tif (!hsw_crtc_supports_ips(crtc))\n\t\treturn;\n\n\tif (IS_HASWELL(i915)) {\n\t\tcrtc_state->ips_enabled = intel_de_read(i915, IPS_CTL) & IPS_ENABLE;\n\t} else {\n\t\t \n\t\tcrtc_state->ips_enabled = true;\n\t}\n}\n\nstatic int hsw_ips_debugfs_false_color_get(void *data, u64 *val)\n{\n\tstruct intel_crtc *crtc = data;\n\tstruct drm_i915_private *i915 = to_i915(crtc->base.dev);\n\n\t*val = i915->display.ips.false_color;\n\n\treturn 0;\n}\n\nstatic int hsw_ips_debugfs_false_color_set(void *data, u64 val)\n{\n\tstruct intel_crtc *crtc = data;\n\tstruct drm_i915_private *i915 = to_i915(crtc->base.dev);\n\tstruct intel_crtc_state *crtc_state;\n\tint ret;\n\n\tret = drm_modeset_lock(&crtc->base.mutex, NULL);\n\tif (ret)\n\t\treturn ret;\n\n\ti915->display.ips.false_color = val;\n\n\tcrtc_state = to_intel_crtc_state(crtc->base.state);\n\n\tif (!crtc_state->hw.active)\n\t\tgoto unlock;\n\n\tif (crtc_state->uapi.commit &&\n\t    !try_wait_for_completion(&crtc_state->uapi.commit->hw_done))\n\t\tgoto unlock;\n\n\thsw_ips_enable(crtc_state);\n\n unlock:\n\tdrm_modeset_unlock(&crtc->base.mutex);\n\n\treturn ret;\n}\n\nDEFINE_DEBUGFS_ATTRIBUTE(hsw_ips_debugfs_false_color_fops,\n\t\t\t hsw_ips_debugfs_false_color_get,\n\t\t\t hsw_ips_debugfs_false_color_set,\n\t\t\t \"%llu\\n\");\n\nstatic int hsw_ips_debugfs_status_show(struct seq_file *m, void *unused)\n{\n\tstruct intel_crtc *crtc = m->private;\n\tstruct drm_i915_private *i915 = to_i915(crtc->base.dev);\n\tintel_wakeref_t wakeref;\n\n\twakeref = intel_runtime_pm_get(&i915->runtime_pm);\n\n\tseq_printf(m, \"Enabled by kernel parameter: %s\\n\",\n\t\t   str_yes_no(i915->params.enable_ips));\n\n\tif (DISPLAY_VER(i915) >= 8) {\n\t\tseq_puts(m, \"Currently: unknown\\n\");\n\t} else {\n\t\tif (intel_de_read(i915, IPS_CTL) & IPS_ENABLE)\n\t\t\tseq_puts(m, \"Currently: enabled\\n\");\n\t\telse\n\t\t\tseq_puts(m, \"Currently: disabled\\n\");\n\t}\n\n\tintel_runtime_pm_put(&i915->runtime_pm, wakeref);\n\n\treturn 0;\n}\n\nDEFINE_SHOW_ATTRIBUTE(hsw_ips_debugfs_status);\n\nvoid hsw_ips_crtc_debugfs_add(struct intel_crtc *crtc)\n{\n\tif (!hsw_crtc_supports_ips(crtc))\n\t\treturn;\n\n\tdebugfs_create_file(\"i915_ips_false_color\", 0644, crtc->base.debugfs_entry,\n\t\t\t    crtc, &hsw_ips_debugfs_false_color_fops);\n\n\tdebugfs_create_file(\"i915_ips_status\", 0444, crtc->base.debugfs_entry,\n\t\t\t    crtc, &hsw_ips_debugfs_status_fops);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}