{
  "module_name": "intel_crtc_state_dump.c",
  "hash_id": "d5c1dfd9057c7169a79729ca70a7b6530fd1924c61016bc2f745caaaa3573218",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/i915/display/intel_crtc_state_dump.c",
  "human_readable_source": "\n \n\n#include <drm/drm_edid.h>\n\n#include \"i915_drv.h\"\n#include \"intel_crtc_state_dump.h\"\n#include \"intel_display_types.h\"\n#include \"intel_hdmi.h\"\n#include \"intel_vrr.h\"\n\nstatic void intel_dump_crtc_timings(struct drm_i915_private *i915,\n\t\t\t\t    const struct drm_display_mode *mode)\n{\n\tdrm_dbg_kms(&i915->drm, \"crtc timings: clock=%d, \"\n\t\t    \"hd=%d hb=%d-%d hs=%d-%d ht=%d, \"\n\t\t    \"vd=%d vb=%d-%d vs=%d-%d vt=%d, \"\n\t\t    \"flags=0x%x\\n\",\n\t\t    mode->crtc_clock,\n\t\t    mode->crtc_hdisplay, mode->crtc_hblank_start, mode->crtc_hblank_end,\n\t\t    mode->crtc_hsync_start, mode->crtc_hsync_end, mode->crtc_htotal,\n\t\t    mode->crtc_vdisplay, mode->crtc_vblank_start, mode->crtc_vblank_end,\n\t\t    mode->crtc_vsync_start, mode->crtc_vsync_end, mode->crtc_vtotal,\n\t\t    mode->flags);\n}\n\nstatic void\nintel_dump_m_n_config(const struct intel_crtc_state *pipe_config,\n\t\t      const char *id, unsigned int lane_count,\n\t\t      const struct intel_link_m_n *m_n)\n{\n\tstruct drm_i915_private *i915 = to_i915(pipe_config->uapi.crtc->dev);\n\n\tdrm_dbg_kms(&i915->drm,\n\t\t    \"%s: lanes: %i; data_m: %u, data_n: %u, link_m: %u, link_n: %u, tu: %u\\n\",\n\t\t    id, lane_count,\n\t\t    m_n->data_m, m_n->data_n,\n\t\t    m_n->link_m, m_n->link_n, m_n->tu);\n}\n\nstatic void\nintel_dump_infoframe(struct drm_i915_private *i915,\n\t\t     const union hdmi_infoframe *frame)\n{\n\tif (!drm_debug_enabled(DRM_UT_KMS))\n\t\treturn;\n\n\thdmi_infoframe_log(KERN_DEBUG, i915->drm.dev, frame);\n}\n\nstatic void\nintel_dump_dp_vsc_sdp(struct drm_i915_private *i915,\n\t\t      const struct drm_dp_vsc_sdp *vsc)\n{\n\tif (!drm_debug_enabled(DRM_UT_KMS))\n\t\treturn;\n\n\tdrm_dp_vsc_sdp_log(KERN_DEBUG, i915->drm.dev, vsc);\n}\n\nstatic void\nintel_dump_buffer(struct drm_i915_private *i915,\n\t\t  const char *prefix, const u8 *buf, size_t len)\n{\n\tif (!drm_debug_enabled(DRM_UT_KMS))\n\t\treturn;\n\n\tprint_hex_dump(KERN_DEBUG, prefix, DUMP_PREFIX_NONE,\n\t\t       16, 0, buf, len, false);\n}\n\n#define OUTPUT_TYPE(x) [INTEL_OUTPUT_ ## x] = #x\n\nstatic const char * const output_type_str[] = {\n\tOUTPUT_TYPE(UNUSED),\n\tOUTPUT_TYPE(ANALOG),\n\tOUTPUT_TYPE(DVO),\n\tOUTPUT_TYPE(SDVO),\n\tOUTPUT_TYPE(LVDS),\n\tOUTPUT_TYPE(TVOUT),\n\tOUTPUT_TYPE(HDMI),\n\tOUTPUT_TYPE(DP),\n\tOUTPUT_TYPE(EDP),\n\tOUTPUT_TYPE(DSI),\n\tOUTPUT_TYPE(DDI),\n\tOUTPUT_TYPE(DP_MST),\n};\n\n#undef OUTPUT_TYPE\n\nstatic void snprintf_output_types(char *buf, size_t len,\n\t\t\t\t  unsigned int output_types)\n{\n\tchar *str = buf;\n\tint i;\n\n\tstr[0] = '\\0';\n\n\tfor (i = 0; i < ARRAY_SIZE(output_type_str); i++) {\n\t\tint r;\n\n\t\tif ((output_types & BIT(i)) == 0)\n\t\t\tcontinue;\n\n\t\tr = snprintf(str, len, \"%s%s\",\n\t\t\t     str != buf ? \",\" : \"\", output_type_str[i]);\n\t\tif (r >= len)\n\t\t\tbreak;\n\t\tstr += r;\n\t\tlen -= r;\n\n\t\toutput_types &= ~BIT(i);\n\t}\n\n\tWARN_ON_ONCE(output_types != 0);\n}\n\nstatic const char * const output_format_str[] = {\n\t[INTEL_OUTPUT_FORMAT_RGB] = \"RGB\",\n\t[INTEL_OUTPUT_FORMAT_YCBCR420] = \"YCBCR4:2:0\",\n\t[INTEL_OUTPUT_FORMAT_YCBCR444] = \"YCBCR4:4:4\",\n};\n\nconst char *intel_output_format_name(enum intel_output_format format)\n{\n\tif (format >= ARRAY_SIZE(output_format_str))\n\t\treturn \"invalid\";\n\treturn output_format_str[format];\n}\n\nstatic void intel_dump_plane_state(const struct intel_plane_state *plane_state)\n{\n\tstruct intel_plane *plane = to_intel_plane(plane_state->uapi.plane);\n\tstruct drm_i915_private *i915 = to_i915(plane->base.dev);\n\tconst struct drm_framebuffer *fb = plane_state->hw.fb;\n\n\tif (!fb) {\n\t\tdrm_dbg_kms(&i915->drm,\n\t\t\t    \"[PLANE:%d:%s] fb: [NOFB], visible: %s\\n\",\n\t\t\t    plane->base.base.id, plane->base.name,\n\t\t\t    str_yes_no(plane_state->uapi.visible));\n\t\treturn;\n\t}\n\n\tdrm_dbg_kms(&i915->drm,\n\t\t    \"[PLANE:%d:%s] fb: [FB:%d] %ux%u format = %p4cc modifier = 0x%llx, visible: %s\\n\",\n\t\t    plane->base.base.id, plane->base.name,\n\t\t    fb->base.id, fb->width, fb->height, &fb->format->format,\n\t\t    fb->modifier, str_yes_no(plane_state->uapi.visible));\n\tdrm_dbg_kms(&i915->drm, \"\\trotation: 0x%x, scaler: %d, scaling_filter: %d\\n\",\n\t\t    plane_state->hw.rotation, plane_state->scaler_id, plane_state->hw.scaling_filter);\n\tif (plane_state->uapi.visible)\n\t\tdrm_dbg_kms(&i915->drm,\n\t\t\t    \"\\tsrc: \" DRM_RECT_FP_FMT \" dst: \" DRM_RECT_FMT \"\\n\",\n\t\t\t    DRM_RECT_FP_ARG(&plane_state->uapi.src),\n\t\t\t    DRM_RECT_ARG(&plane_state->uapi.dst));\n}\n\nstatic void\nilk_dump_csc(struct drm_i915_private *i915, const char *name,\n\t     const struct intel_csc_matrix *csc)\n{\n\tint i;\n\n\tdrm_dbg_kms(&i915->drm,\n\t\t    \"%s: pre offsets: 0x%04x 0x%04x 0x%04x\\n\", name,\n\t\t    csc->preoff[0], csc->preoff[1], csc->preoff[2]);\n\n\tfor (i = 0; i < 3; i++)\n\t\tdrm_dbg_kms(&i915->drm,\n\t\t\t    \"%s: coefficients: 0x%04x 0x%04x 0x%04x\\n\", name,\n\t\t\t    csc->coeff[3 * i + 0],\n\t\t\t    csc->coeff[3 * i + 1],\n\t\t\t    csc->coeff[3 * i + 2]);\n\n\tif (DISPLAY_VER(i915) < 7)\n\t\treturn;\n\n\tdrm_dbg_kms(&i915->drm,\n\t\t    \"%s: post offsets: 0x%04x 0x%04x 0x%04x\\n\", name,\n\t\t    csc->postoff[0], csc->postoff[1], csc->postoff[2]);\n}\n\nstatic void\nvlv_dump_csc(struct drm_i915_private *i915, const char *name,\n\t     const struct intel_csc_matrix *csc)\n{\n\tint i;\n\n\tfor (i = 0; i < 3; i++)\n\t\tdrm_dbg_kms(&i915->drm,\n\t\t\t    \"%s: coefficients: 0x%04x 0x%04x 0x%04x\\n\", name,\n\t\t\t    csc->coeff[3 * i + 0],\n\t\t\t    csc->coeff[3 * i + 1],\n\t\t\t    csc->coeff[3 * i + 2]);\n}\n\nvoid intel_crtc_state_dump(const struct intel_crtc_state *pipe_config,\n\t\t\t   struct intel_atomic_state *state,\n\t\t\t   const char *context)\n{\n\tstruct intel_crtc *crtc = to_intel_crtc(pipe_config->uapi.crtc);\n\tstruct drm_i915_private *i915 = to_i915(crtc->base.dev);\n\tconst struct intel_plane_state *plane_state;\n\tstruct intel_plane *plane;\n\tchar buf[64];\n\tint i;\n\n\tdrm_dbg_kms(&i915->drm, \"[CRTC:%d:%s] enable: %s [%s]\\n\",\n\t\t    crtc->base.base.id, crtc->base.name,\n\t\t    str_yes_no(pipe_config->hw.enable), context);\n\n\tif (!pipe_config->hw.enable)\n\t\tgoto dump_planes;\n\n\tsnprintf_output_types(buf, sizeof(buf), pipe_config->output_types);\n\tdrm_dbg_kms(&i915->drm,\n\t\t    \"active: %s, output_types: %s (0x%x), output format: %s, sink format: %s\\n\",\n\t\t    str_yes_no(pipe_config->hw.active),\n\t\t    buf, pipe_config->output_types,\n\t\t    intel_output_format_name(pipe_config->output_format),\n\t\t    intel_output_format_name(pipe_config->sink_format));\n\n\tdrm_dbg_kms(&i915->drm,\n\t\t    \"cpu_transcoder: %s, pipe bpp: %i, dithering: %i\\n\",\n\t\t    transcoder_name(pipe_config->cpu_transcoder),\n\t\t    pipe_config->pipe_bpp, pipe_config->dither);\n\n\tdrm_dbg_kms(&i915->drm, \"MST master transcoder: %s\\n\",\n\t\t    transcoder_name(pipe_config->mst_master_transcoder));\n\n\tdrm_dbg_kms(&i915->drm,\n\t\t    \"port sync: master transcoder: %s, slave transcoder bitmask = 0x%x\\n\",\n\t\t    transcoder_name(pipe_config->master_transcoder),\n\t\t    pipe_config->sync_mode_slaves_mask);\n\n\tdrm_dbg_kms(&i915->drm, \"bigjoiner: %s, pipes: 0x%x\\n\",\n\t\t    intel_crtc_is_bigjoiner_slave(pipe_config) ? \"slave\" :\n\t\t    intel_crtc_is_bigjoiner_master(pipe_config) ? \"master\" : \"no\",\n\t\t    pipe_config->bigjoiner_pipes);\n\n\tdrm_dbg_kms(&i915->drm, \"splitter: %s, link count %d, overlap %d\\n\",\n\t\t    str_enabled_disabled(pipe_config->splitter.enable),\n\t\t    pipe_config->splitter.link_count,\n\t\t    pipe_config->splitter.pixel_overlap);\n\n\tif (pipe_config->has_pch_encoder)\n\t\tintel_dump_m_n_config(pipe_config, \"fdi\",\n\t\t\t\t      pipe_config->fdi_lanes,\n\t\t\t\t      &pipe_config->fdi_m_n);\n\n\tif (intel_crtc_has_dp_encoder(pipe_config)) {\n\t\tintel_dump_m_n_config(pipe_config, \"dp m_n\",\n\t\t\t\t      pipe_config->lane_count,\n\t\t\t\t      &pipe_config->dp_m_n);\n\t\tintel_dump_m_n_config(pipe_config, \"dp m2_n2\",\n\t\t\t\t      pipe_config->lane_count,\n\t\t\t\t      &pipe_config->dp_m2_n2);\n\t\tdrm_dbg_kms(&i915->drm, \"fec: %s, enhanced framing: %s\\n\",\n\t\t\t    str_enabled_disabled(pipe_config->fec_enable),\n\t\t\t    str_enabled_disabled(pipe_config->enhanced_framing));\n\t}\n\n\tdrm_dbg_kms(&i915->drm, \"framestart delay: %d, MSA timing delay: %d\\n\",\n\t\t    pipe_config->framestart_delay, pipe_config->msa_timing_delay);\n\n\tdrm_dbg_kms(&i915->drm,\n\t\t    \"audio: %i, infoframes: %i, infoframes enabled: 0x%x\\n\",\n\t\t    pipe_config->has_audio, pipe_config->has_infoframe,\n\t\t    pipe_config->infoframes.enable);\n\n\tif (pipe_config->infoframes.enable &\n\t    intel_hdmi_infoframe_enable(HDMI_PACKET_TYPE_GENERAL_CONTROL))\n\t\tdrm_dbg_kms(&i915->drm, \"GCP: 0x%x\\n\",\n\t\t\t    pipe_config->infoframes.gcp);\n\tif (pipe_config->infoframes.enable &\n\t    intel_hdmi_infoframe_enable(HDMI_INFOFRAME_TYPE_AVI))\n\t\tintel_dump_infoframe(i915, &pipe_config->infoframes.avi);\n\tif (pipe_config->infoframes.enable &\n\t    intel_hdmi_infoframe_enable(HDMI_INFOFRAME_TYPE_SPD))\n\t\tintel_dump_infoframe(i915, &pipe_config->infoframes.spd);\n\tif (pipe_config->infoframes.enable &\n\t    intel_hdmi_infoframe_enable(HDMI_INFOFRAME_TYPE_VENDOR))\n\t\tintel_dump_infoframe(i915, &pipe_config->infoframes.hdmi);\n\tif (pipe_config->infoframes.enable &\n\t    intel_hdmi_infoframe_enable(HDMI_INFOFRAME_TYPE_DRM))\n\t\tintel_dump_infoframe(i915, &pipe_config->infoframes.drm);\n\tif (pipe_config->infoframes.enable &\n\t    intel_hdmi_infoframe_enable(HDMI_PACKET_TYPE_GAMUT_METADATA))\n\t\tintel_dump_infoframe(i915, &pipe_config->infoframes.drm);\n\tif (pipe_config->infoframes.enable &\n\t    intel_hdmi_infoframe_enable(DP_SDP_VSC))\n\t\tintel_dump_dp_vsc_sdp(i915, &pipe_config->infoframes.vsc);\n\n\tif (pipe_config->has_audio)\n\t\tintel_dump_buffer(i915, \"ELD: \", pipe_config->eld,\n\t\t\t\t  drm_eld_size(pipe_config->eld));\n\n\tdrm_dbg_kms(&i915->drm, \"vrr: %s, vmin: %d, vmax: %d, pipeline full: %d, guardband: %d flipline: %d, vmin vblank: %d, vmax vblank: %d\\n\",\n\t\t    str_yes_no(pipe_config->vrr.enable),\n\t\t    pipe_config->vrr.vmin, pipe_config->vrr.vmax,\n\t\t    pipe_config->vrr.pipeline_full, pipe_config->vrr.guardband,\n\t\t    pipe_config->vrr.flipline,\n\t\t    intel_vrr_vmin_vblank_start(pipe_config),\n\t\t    intel_vrr_vmax_vblank_start(pipe_config));\n\n\tdrm_dbg_kms(&i915->drm, \"requested mode: \" DRM_MODE_FMT \"\\n\",\n\t\t    DRM_MODE_ARG(&pipe_config->hw.mode));\n\tdrm_dbg_kms(&i915->drm, \"adjusted mode: \" DRM_MODE_FMT \"\\n\",\n\t\t    DRM_MODE_ARG(&pipe_config->hw.adjusted_mode));\n\tintel_dump_crtc_timings(i915, &pipe_config->hw.adjusted_mode);\n\tdrm_dbg_kms(&i915->drm, \"pipe mode: \" DRM_MODE_FMT \"\\n\",\n\t\t    DRM_MODE_ARG(&pipe_config->hw.pipe_mode));\n\tintel_dump_crtc_timings(i915, &pipe_config->hw.pipe_mode);\n\tdrm_dbg_kms(&i915->drm,\n\t\t    \"port clock: %d, pipe src: \" DRM_RECT_FMT \", pixel rate %d\\n\",\n\t\t    pipe_config->port_clock, DRM_RECT_ARG(&pipe_config->pipe_src),\n\t\t    pipe_config->pixel_rate);\n\n\tdrm_dbg_kms(&i915->drm, \"linetime: %d, ips linetime: %d\\n\",\n\t\t    pipe_config->linetime, pipe_config->ips_linetime);\n\n\tif (DISPLAY_VER(i915) >= 9)\n\t\tdrm_dbg_kms(&i915->drm,\n\t\t\t    \"num_scalers: %d, scaler_users: 0x%x, scaler_id: %d, scaling_filter: %d\\n\",\n\t\t\t    crtc->num_scalers,\n\t\t\t    pipe_config->scaler_state.scaler_users,\n\t\t\t    pipe_config->scaler_state.scaler_id,\n\t\t\t    pipe_config->hw.scaling_filter);\n\n\tif (HAS_GMCH(i915))\n\t\tdrm_dbg_kms(&i915->drm,\n\t\t\t    \"gmch pfit: control: 0x%08x, ratios: 0x%08x, lvds border: 0x%08x\\n\",\n\t\t\t    pipe_config->gmch_pfit.control,\n\t\t\t    pipe_config->gmch_pfit.pgm_ratios,\n\t\t\t    pipe_config->gmch_pfit.lvds_border_bits);\n\telse\n\t\tdrm_dbg_kms(&i915->drm,\n\t\t\t    \"pch pfit: \" DRM_RECT_FMT \", %s, force thru: %s\\n\",\n\t\t\t    DRM_RECT_ARG(&pipe_config->pch_pfit.dst),\n\t\t\t    str_enabled_disabled(pipe_config->pch_pfit.enabled),\n\t\t\t    str_yes_no(pipe_config->pch_pfit.force_thru));\n\n\tdrm_dbg_kms(&i915->drm, \"ips: %i, double wide: %i, drrs: %i\\n\",\n\t\t    pipe_config->ips_enabled, pipe_config->double_wide,\n\t\t    pipe_config->has_drrs);\n\n\tintel_dpll_dump_hw_state(i915, &pipe_config->dpll_hw_state);\n\n\tif (IS_CHERRYVIEW(i915))\n\t\tdrm_dbg_kms(&i915->drm,\n\t\t\t    \"cgm_mode: 0x%x gamma_mode: 0x%x gamma_enable: %d csc_enable: %d\\n\",\n\t\t\t    pipe_config->cgm_mode, pipe_config->gamma_mode,\n\t\t\t    pipe_config->gamma_enable, pipe_config->csc_enable);\n\telse\n\t\tdrm_dbg_kms(&i915->drm,\n\t\t\t    \"csc_mode: 0x%x gamma_mode: 0x%x gamma_enable: %d csc_enable: %d\\n\",\n\t\t\t    pipe_config->csc_mode, pipe_config->gamma_mode,\n\t\t\t    pipe_config->gamma_enable, pipe_config->csc_enable);\n\n\tdrm_dbg_kms(&i915->drm, \"pre csc lut: %s%d entries, post csc lut: %d entries\\n\",\n\t\t    pipe_config->pre_csc_lut && pipe_config->pre_csc_lut ==\n\t\t    i915->display.color.glk_linear_degamma_lut ? \"(linear) \" : \"\",\n\t\t    pipe_config->pre_csc_lut ?\n\t\t    drm_color_lut_size(pipe_config->pre_csc_lut) : 0,\n\t\t    pipe_config->post_csc_lut ?\n\t\t    drm_color_lut_size(pipe_config->post_csc_lut) : 0);\n\n\tif (DISPLAY_VER(i915) >= 11)\n\t\tilk_dump_csc(i915, \"output csc\", &pipe_config->output_csc);\n\n\tif (!HAS_GMCH(i915))\n\t\tilk_dump_csc(i915, \"pipe csc\", &pipe_config->csc);\n\telse if (IS_CHERRYVIEW(i915))\n\t\tvlv_dump_csc(i915, \"cgm csc\", &pipe_config->csc);\n\telse if (IS_VALLEYVIEW(i915))\n\t\tvlv_dump_csc(i915, \"wgc csc\", &pipe_config->csc);\n\ndump_planes:\n\tif (!state)\n\t\treturn;\n\n\tfor_each_new_intel_plane_in_state(state, plane, plane_state, i) {\n\t\tif (plane->pipe == crtc->pipe)\n\t\t\tintel_dump_plane_state(plane_state);\n\t}\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}