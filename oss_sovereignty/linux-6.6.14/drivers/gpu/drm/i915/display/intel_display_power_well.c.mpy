{
  "module_name": "intel_display_power_well.c",
  "hash_id": "e35164d3fd9c095de8a5b98203662da56b90c6eee2b23c03541075ccffb64700",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/i915/display/intel_display_power_well.c",
  "human_readable_source": "\n \n\n#include \"i915_drv.h\"\n#include \"i915_irq.h\"\n#include \"i915_reg.h\"\n#include \"intel_backlight_regs.h\"\n#include \"intel_combo_phy.h\"\n#include \"intel_combo_phy_regs.h\"\n#include \"intel_crt.h\"\n#include \"intel_de.h\"\n#include \"intel_display_irq.h\"\n#include \"intel_display_power_well.h\"\n#include \"intel_display_types.h\"\n#include \"intel_dkl_phy.h\"\n#include \"intel_dkl_phy_regs.h\"\n#include \"intel_dmc.h\"\n#include \"intel_dp_aux_regs.h\"\n#include \"intel_dpio_phy.h\"\n#include \"intel_dpll.h\"\n#include \"intel_hotplug.h\"\n#include \"intel_pcode.h\"\n#include \"intel_pps.h\"\n#include \"intel_tc.h\"\n#include \"intel_vga.h\"\n#include \"skl_watermark.h\"\n#include \"vlv_sideband.h\"\n#include \"vlv_sideband_reg.h\"\n\nstruct i915_power_well_regs {\n\ti915_reg_t bios;\n\ti915_reg_t driver;\n\ti915_reg_t kvmr;\n\ti915_reg_t debug;\n};\n\nstruct i915_power_well_ops {\n\tconst struct i915_power_well_regs *regs;\n\t \n\tvoid (*sync_hw)(struct drm_i915_private *i915,\n\t\t\tstruct i915_power_well *power_well);\n\t \n\tvoid (*enable)(struct drm_i915_private *i915,\n\t\t       struct i915_power_well *power_well);\n\t \n\tvoid (*disable)(struct drm_i915_private *i915,\n\t\t\tstruct i915_power_well *power_well);\n\t \n\tbool (*is_enabled)(struct drm_i915_private *i915,\n\t\t\t   struct i915_power_well *power_well);\n};\n\nstatic const struct i915_power_well_instance *\ni915_power_well_instance(const struct i915_power_well *power_well)\n{\n\treturn &power_well->desc->instances->list[power_well->instance_idx];\n}\n\nstruct i915_power_well *\nlookup_power_well(struct drm_i915_private *i915,\n\t\t  enum i915_power_well_id power_well_id)\n{\n\tstruct i915_power_well *power_well;\n\n\tfor_each_power_well(i915, power_well)\n\t\tif (i915_power_well_instance(power_well)->id == power_well_id)\n\t\t\treturn power_well;\n\n\t \n\tdrm_WARN(&i915->drm, 1,\n\t\t \"Power well %d not defined for this platform\\n\",\n\t\t power_well_id);\n\treturn &i915->display.power.domains.power_wells[0];\n}\n\nvoid intel_power_well_enable(struct drm_i915_private *i915,\n\t\t\t     struct i915_power_well *power_well)\n{\n\tdrm_dbg_kms(&i915->drm, \"enabling %s\\n\", intel_power_well_name(power_well));\n\tpower_well->desc->ops->enable(i915, power_well);\n\tpower_well->hw_enabled = true;\n}\n\nvoid intel_power_well_disable(struct drm_i915_private *i915,\n\t\t\t      struct i915_power_well *power_well)\n{\n\tdrm_dbg_kms(&i915->drm, \"disabling %s\\n\", intel_power_well_name(power_well));\n\tpower_well->hw_enabled = false;\n\tpower_well->desc->ops->disable(i915, power_well);\n}\n\nvoid intel_power_well_sync_hw(struct drm_i915_private *i915,\n\t\t\t      struct i915_power_well *power_well)\n{\n\tpower_well->desc->ops->sync_hw(i915, power_well);\n\tpower_well->hw_enabled =\n\t\tpower_well->desc->ops->is_enabled(i915, power_well);\n}\n\nvoid intel_power_well_get(struct drm_i915_private *i915,\n\t\t\t  struct i915_power_well *power_well)\n{\n\tif (!power_well->count++)\n\t\tintel_power_well_enable(i915, power_well);\n}\n\nvoid intel_power_well_put(struct drm_i915_private *i915,\n\t\t\t  struct i915_power_well *power_well)\n{\n\tdrm_WARN(&i915->drm, !power_well->count,\n\t\t \"Use count on power well %s is already zero\",\n\t\t i915_power_well_instance(power_well)->name);\n\n\tif (!--power_well->count)\n\t\tintel_power_well_disable(i915, power_well);\n}\n\nbool intel_power_well_is_enabled(struct drm_i915_private *i915,\n\t\t\t\t struct i915_power_well *power_well)\n{\n\treturn power_well->desc->ops->is_enabled(i915, power_well);\n}\n\nbool intel_power_well_is_enabled_cached(struct i915_power_well *power_well)\n{\n\treturn power_well->hw_enabled;\n}\n\nbool intel_display_power_well_is_enabled(struct drm_i915_private *dev_priv,\n\t\t\t\t\t enum i915_power_well_id power_well_id)\n{\n\tstruct i915_power_well *power_well;\n\n\tpower_well = lookup_power_well(dev_priv, power_well_id);\n\n\treturn intel_power_well_is_enabled(dev_priv, power_well);\n}\n\nbool intel_power_well_is_always_on(struct i915_power_well *power_well)\n{\n\treturn power_well->desc->always_on;\n}\n\nconst char *intel_power_well_name(struct i915_power_well *power_well)\n{\n\treturn i915_power_well_instance(power_well)->name;\n}\n\nstruct intel_power_domain_mask *intel_power_well_domains(struct i915_power_well *power_well)\n{\n\treturn &power_well->domains;\n}\n\nint intel_power_well_refcount(struct i915_power_well *power_well)\n{\n\treturn power_well->count;\n}\n\n \nstatic void hsw_power_well_post_enable(struct drm_i915_private *dev_priv,\n\t\t\t\t       u8 irq_pipe_mask, bool has_vga)\n{\n\tif (has_vga)\n\t\tintel_vga_reset_io_mem(dev_priv);\n\n\tif (irq_pipe_mask)\n\t\tgen8_irq_power_well_post_enable(dev_priv, irq_pipe_mask);\n}\n\nstatic void hsw_power_well_pre_disable(struct drm_i915_private *dev_priv,\n\t\t\t\t       u8 irq_pipe_mask)\n{\n\tif (irq_pipe_mask)\n\t\tgen8_irq_power_well_pre_disable(dev_priv, irq_pipe_mask);\n}\n\n#define ICL_AUX_PW_TO_CH(pw_idx)\t\\\n\t((pw_idx) - ICL_PW_CTL_IDX_AUX_A + AUX_CH_A)\n\n#define ICL_TBT_AUX_PW_TO_CH(pw_idx)\t\\\n\t((pw_idx) - ICL_PW_CTL_IDX_AUX_TBT1 + AUX_CH_C)\n\nstatic enum aux_ch icl_aux_pw_to_ch(const struct i915_power_well *power_well)\n{\n\tint pw_idx = i915_power_well_instance(power_well)->hsw.idx;\n\n\treturn power_well->desc->is_tc_tbt ? ICL_TBT_AUX_PW_TO_CH(pw_idx) :\n\t\t\t\t\t     ICL_AUX_PW_TO_CH(pw_idx);\n}\n\nstatic struct intel_digital_port *\naux_ch_to_digital_port(struct drm_i915_private *dev_priv,\n\t\t       enum aux_ch aux_ch)\n{\n\tstruct intel_digital_port *dig_port = NULL;\n\tstruct intel_encoder *encoder;\n\n\tfor_each_intel_encoder(&dev_priv->drm, encoder) {\n\t\t \n\t\tif (encoder->type == INTEL_OUTPUT_DP_MST)\n\t\t\tcontinue;\n\n\t\tdig_port = enc_to_dig_port(encoder);\n\t\tif (!dig_port)\n\t\t\tcontinue;\n\n\t\tif (dig_port->aux_ch != aux_ch) {\n\t\t\tdig_port = NULL;\n\t\t\tcontinue;\n\t\t}\n\n\t\tbreak;\n\t}\n\n\treturn dig_port;\n}\n\nstatic enum phy icl_aux_pw_to_phy(struct drm_i915_private *i915,\n\t\t\t\t  const struct i915_power_well *power_well)\n{\n\tenum aux_ch aux_ch = icl_aux_pw_to_ch(power_well);\n\tstruct intel_digital_port *dig_port = aux_ch_to_digital_port(i915, aux_ch);\n\n\treturn intel_port_to_phy(i915, dig_port->base.port);\n}\n\nstatic void hsw_wait_for_power_well_enable(struct drm_i915_private *dev_priv,\n\t\t\t\t\t   struct i915_power_well *power_well,\n\t\t\t\t\t   bool timeout_expected)\n{\n\tconst struct i915_power_well_regs *regs = power_well->desc->ops->regs;\n\tint pw_idx = i915_power_well_instance(power_well)->hsw.idx;\n\tint timeout = power_well->desc->enable_timeout ? : 1;\n\n\t \n\tif (IS_DG2(dev_priv) && power_well->desc->fixed_enable_delay) {\n\t\tusleep_range(600, 1200);\n\t\treturn;\n\t}\n\n\t \n\tif (intel_de_wait_for_set(dev_priv, regs->driver,\n\t\t\t\t  HSW_PWR_WELL_CTL_STATE(pw_idx), timeout)) {\n\t\tdrm_dbg_kms(&dev_priv->drm, \"%s power well enable timeout\\n\",\n\t\t\t    intel_power_well_name(power_well));\n\n\t\tdrm_WARN_ON(&dev_priv->drm, !timeout_expected);\n\n\t}\n}\n\nstatic u32 hsw_power_well_requesters(struct drm_i915_private *dev_priv,\n\t\t\t\t     const struct i915_power_well_regs *regs,\n\t\t\t\t     int pw_idx)\n{\n\tu32 req_mask = HSW_PWR_WELL_CTL_REQ(pw_idx);\n\tu32 ret;\n\n\tret = intel_de_read(dev_priv, regs->bios) & req_mask ? 1 : 0;\n\tret |= intel_de_read(dev_priv, regs->driver) & req_mask ? 2 : 0;\n\tif (regs->kvmr.reg)\n\t\tret |= intel_de_read(dev_priv, regs->kvmr) & req_mask ? 4 : 0;\n\tret |= intel_de_read(dev_priv, regs->debug) & req_mask ? 8 : 0;\n\n\treturn ret;\n}\n\nstatic void hsw_wait_for_power_well_disable(struct drm_i915_private *dev_priv,\n\t\t\t\t\t    struct i915_power_well *power_well)\n{\n\tconst struct i915_power_well_regs *regs = power_well->desc->ops->regs;\n\tint pw_idx = i915_power_well_instance(power_well)->hsw.idx;\n\tbool disabled;\n\tu32 reqs;\n\n\t \n\twait_for((disabled = !(intel_de_read(dev_priv, regs->driver) &\n\t\t\t       HSW_PWR_WELL_CTL_STATE(pw_idx))) ||\n\t\t (reqs = hsw_power_well_requesters(dev_priv, regs, pw_idx)), 1);\n\tif (disabled)\n\t\treturn;\n\n\tdrm_dbg_kms(&dev_priv->drm,\n\t\t    \"%s forced on (bios:%d driver:%d kvmr:%d debug:%d)\\n\",\n\t\t    intel_power_well_name(power_well),\n\t\t    !!(reqs & 1), !!(reqs & 2), !!(reqs & 4), !!(reqs & 8));\n}\n\nstatic void gen9_wait_for_power_well_fuses(struct drm_i915_private *dev_priv,\n\t\t\t\t\t   enum skl_power_gate pg)\n{\n\t \n\tdrm_WARN_ON(&dev_priv->drm,\n\t\t    intel_de_wait_for_set(dev_priv, SKL_FUSE_STATUS,\n\t\t\t\t\t  SKL_FUSE_PG_DIST_STATUS(pg), 1));\n}\n\nstatic void hsw_power_well_enable(struct drm_i915_private *dev_priv,\n\t\t\t\t  struct i915_power_well *power_well)\n{\n\tconst struct i915_power_well_regs *regs = power_well->desc->ops->regs;\n\tint pw_idx = i915_power_well_instance(power_well)->hsw.idx;\n\n\tif (power_well->desc->has_fuses) {\n\t\tenum skl_power_gate pg;\n\n\t\tpg = DISPLAY_VER(dev_priv) >= 11 ? ICL_PW_CTL_IDX_TO_PG(pw_idx) :\n\t\t\t\t\t\t SKL_PW_CTL_IDX_TO_PG(pw_idx);\n\n\t\t \n\t\tif (IS_ALDERLAKE_P(dev_priv) && pg == SKL_PG1)\n\t\t\tintel_de_rmw(dev_priv, GEN8_CHICKEN_DCPR_1, 0, DISABLE_FLR_SRC);\n\n\t\t \n\t\tif (pg == SKL_PG1)\n\t\t\tgen9_wait_for_power_well_fuses(dev_priv, SKL_PG0);\n\t}\n\n\tintel_de_rmw(dev_priv, regs->driver, 0, HSW_PWR_WELL_CTL_REQ(pw_idx));\n\n\thsw_wait_for_power_well_enable(dev_priv, power_well, false);\n\n\tif (power_well->desc->has_fuses) {\n\t\tenum skl_power_gate pg;\n\n\t\tpg = DISPLAY_VER(dev_priv) >= 11 ? ICL_PW_CTL_IDX_TO_PG(pw_idx) :\n\t\t\t\t\t\t SKL_PW_CTL_IDX_TO_PG(pw_idx);\n\t\tgen9_wait_for_power_well_fuses(dev_priv, pg);\n\t}\n\n\thsw_power_well_post_enable(dev_priv,\n\t\t\t\t   power_well->desc->irq_pipe_mask,\n\t\t\t\t   power_well->desc->has_vga);\n}\n\nstatic void hsw_power_well_disable(struct drm_i915_private *dev_priv,\n\t\t\t\t   struct i915_power_well *power_well)\n{\n\tconst struct i915_power_well_regs *regs = power_well->desc->ops->regs;\n\tint pw_idx = i915_power_well_instance(power_well)->hsw.idx;\n\n\thsw_power_well_pre_disable(dev_priv,\n\t\t\t\t   power_well->desc->irq_pipe_mask);\n\n\tintel_de_rmw(dev_priv, regs->driver, HSW_PWR_WELL_CTL_REQ(pw_idx), 0);\n\thsw_wait_for_power_well_disable(dev_priv, power_well);\n}\n\nstatic bool intel_port_is_edp(struct drm_i915_private *i915, enum port port)\n{\n\tstruct intel_encoder *encoder;\n\n\tfor_each_intel_encoder(&i915->drm, encoder) {\n\t\tif (encoder->type == INTEL_OUTPUT_EDP &&\n\t\t    encoder->port == port)\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}\n\nstatic void\nicl_combo_phy_aux_power_well_enable(struct drm_i915_private *dev_priv,\n\t\t\t\t    struct i915_power_well *power_well)\n{\n\tconst struct i915_power_well_regs *regs = power_well->desc->ops->regs;\n\tint pw_idx = i915_power_well_instance(power_well)->hsw.idx;\n\tenum phy phy = icl_aux_pw_to_phy(dev_priv, power_well);\n\n\tdrm_WARN_ON(&dev_priv->drm, !IS_ICELAKE(dev_priv));\n\n\tintel_de_rmw(dev_priv, regs->driver, 0, HSW_PWR_WELL_CTL_REQ(pw_idx));\n\n\tif (DISPLAY_VER(dev_priv) < 12)\n\t\tintel_de_rmw(dev_priv, ICL_PORT_CL_DW12(phy),\n\t\t\t     0, ICL_LANE_ENABLE_AUX);\n\n\thsw_wait_for_power_well_enable(dev_priv, power_well, false);\n\n\t \n\tif (pw_idx >= ICL_PW_CTL_IDX_AUX_A && pw_idx <= ICL_PW_CTL_IDX_AUX_B &&\n\t    !intel_port_is_edp(dev_priv, (enum port)phy))\n\t\tintel_de_rmw(dev_priv, ICL_AUX_ANAOVRD1(pw_idx),\n\t\t\t     0, ICL_AUX_ANAOVRD1_ENABLE | ICL_AUX_ANAOVRD1_LDO_BYPASS);\n}\n\nstatic void\nicl_combo_phy_aux_power_well_disable(struct drm_i915_private *dev_priv,\n\t\t\t\t     struct i915_power_well *power_well)\n{\n\tconst struct i915_power_well_regs *regs = power_well->desc->ops->regs;\n\tint pw_idx = i915_power_well_instance(power_well)->hsw.idx;\n\tenum phy phy = icl_aux_pw_to_phy(dev_priv, power_well);\n\n\tdrm_WARN_ON(&dev_priv->drm, !IS_ICELAKE(dev_priv));\n\n\tintel_de_rmw(dev_priv, ICL_PORT_CL_DW12(phy), ICL_LANE_ENABLE_AUX, 0);\n\n\tintel_de_rmw(dev_priv, regs->driver, HSW_PWR_WELL_CTL_REQ(pw_idx), 0);\n\n\thsw_wait_for_power_well_disable(dev_priv, power_well);\n}\n\n#if IS_ENABLED(CONFIG_DRM_I915_DEBUG_RUNTIME_PM)\n\nstatic void icl_tc_port_assert_ref_held(struct drm_i915_private *dev_priv,\n\t\t\t\t\tstruct i915_power_well *power_well,\n\t\t\t\t\tstruct intel_digital_port *dig_port)\n{\n\tif (drm_WARN_ON(&dev_priv->drm, !dig_port))\n\t\treturn;\n\n\tif (DISPLAY_VER(dev_priv) == 11 && intel_tc_cold_requires_aux_pw(dig_port))\n\t\treturn;\n\n\tdrm_WARN_ON(&dev_priv->drm, !intel_tc_port_ref_held(dig_port));\n}\n\n#else\n\nstatic void icl_tc_port_assert_ref_held(struct drm_i915_private *dev_priv,\n\t\t\t\t\tstruct i915_power_well *power_well,\n\t\t\t\t\tstruct intel_digital_port *dig_port)\n{\n}\n\n#endif\n\n#define TGL_AUX_PW_TO_TC_PORT(pw_idx)\t((pw_idx) - TGL_PW_CTL_IDX_AUX_TC1)\n\nstatic void icl_tc_cold_exit(struct drm_i915_private *i915)\n{\n\tint ret, tries = 0;\n\n\twhile (1) {\n\t\tret = snb_pcode_write_timeout(&i915->uncore, ICL_PCODE_EXIT_TCCOLD, 0,\n\t\t\t\t\t      250, 1);\n\t\tif (ret != -EAGAIN || ++tries == 3)\n\t\t\tbreak;\n\t\tmsleep(1);\n\t}\n\n\t \n\tif (!ret)\n\t\tmsleep(1);\n\n\t \n\tdrm_dbg_kms(&i915->drm, \"TC cold block %s\\n\", ret ? \"failed\" :\n\t\t    \"succeeded\");\n}\n\nstatic void\nicl_tc_phy_aux_power_well_enable(struct drm_i915_private *dev_priv,\n\t\t\t\t struct i915_power_well *power_well)\n{\n\tenum aux_ch aux_ch = icl_aux_pw_to_ch(power_well);\n\tstruct intel_digital_port *dig_port = aux_ch_to_digital_port(dev_priv, aux_ch);\n\tconst struct i915_power_well_regs *regs = power_well->desc->ops->regs;\n\tbool is_tbt = power_well->desc->is_tc_tbt;\n\tbool timeout_expected;\n\n\ticl_tc_port_assert_ref_held(dev_priv, power_well, dig_port);\n\n\tintel_de_rmw(dev_priv, DP_AUX_CH_CTL(aux_ch),\n\t\t     DP_AUX_CH_CTL_TBT_IO, is_tbt ? DP_AUX_CH_CTL_TBT_IO : 0);\n\n\tintel_de_rmw(dev_priv, regs->driver,\n\t\t     0,\n\t\t     HSW_PWR_WELL_CTL_REQ(i915_power_well_instance(power_well)->hsw.idx));\n\n\t \n\ttimeout_expected = is_tbt || intel_tc_cold_requires_aux_pw(dig_port);\n\tif (DISPLAY_VER(dev_priv) == 11 && intel_tc_cold_requires_aux_pw(dig_port))\n\t\ticl_tc_cold_exit(dev_priv);\n\n\thsw_wait_for_power_well_enable(dev_priv, power_well, timeout_expected);\n\n\tif (DISPLAY_VER(dev_priv) >= 12 && !is_tbt) {\n\t\tenum tc_port tc_port;\n\n\t\ttc_port = TGL_AUX_PW_TO_TC_PORT(i915_power_well_instance(power_well)->hsw.idx);\n\n\t\tif (wait_for(intel_dkl_phy_read(dev_priv, DKL_CMN_UC_DW_27(tc_port)) &\n\t\t\t     DKL_CMN_UC_DW27_UC_HEALTH, 1))\n\t\t\tdrm_warn(&dev_priv->drm,\n\t\t\t\t \"Timeout waiting TC uC health\\n\");\n\t}\n}\n\nstatic void\nicl_aux_power_well_enable(struct drm_i915_private *dev_priv,\n\t\t\t  struct i915_power_well *power_well)\n{\n\tenum phy phy = icl_aux_pw_to_phy(dev_priv, power_well);\n\n\tif (intel_phy_is_tc(dev_priv, phy))\n\t\treturn icl_tc_phy_aux_power_well_enable(dev_priv, power_well);\n\telse if (IS_ICELAKE(dev_priv))\n\t\treturn icl_combo_phy_aux_power_well_enable(dev_priv,\n\t\t\t\t\t\t\t   power_well);\n\telse\n\t\treturn hsw_power_well_enable(dev_priv, power_well);\n}\n\nstatic void\nicl_aux_power_well_disable(struct drm_i915_private *dev_priv,\n\t\t\t   struct i915_power_well *power_well)\n{\n\tenum phy phy = icl_aux_pw_to_phy(dev_priv, power_well);\n\n\tif (intel_phy_is_tc(dev_priv, phy))\n\t\treturn hsw_power_well_disable(dev_priv, power_well);\n\telse if (IS_ICELAKE(dev_priv))\n\t\treturn icl_combo_phy_aux_power_well_disable(dev_priv,\n\t\t\t\t\t\t\t    power_well);\n\telse\n\t\treturn hsw_power_well_disable(dev_priv, power_well);\n}\n\n \nstatic bool hsw_power_well_enabled(struct drm_i915_private *dev_priv,\n\t\t\t\t   struct i915_power_well *power_well)\n{\n\tconst struct i915_power_well_regs *regs = power_well->desc->ops->regs;\n\tenum i915_power_well_id id = i915_power_well_instance(power_well)->id;\n\tint pw_idx = i915_power_well_instance(power_well)->hsw.idx;\n\tu32 mask = HSW_PWR_WELL_CTL_REQ(pw_idx) |\n\t\t   HSW_PWR_WELL_CTL_STATE(pw_idx);\n\tu32 val;\n\n\tval = intel_de_read(dev_priv, regs->driver);\n\n\t \n\tif (DISPLAY_VER(dev_priv) == 9 && !IS_BROXTON(dev_priv) &&\n\t    (id == SKL_DISP_PW_1 || id == SKL_DISP_PW_MISC_IO))\n\t\tval |= intel_de_read(dev_priv, regs->bios);\n\n\treturn (val & mask) == mask;\n}\n\nstatic void assert_can_enable_dc9(struct drm_i915_private *dev_priv)\n{\n\tdrm_WARN_ONCE(&dev_priv->drm,\n\t\t      (intel_de_read(dev_priv, DC_STATE_EN) & DC_STATE_EN_DC9),\n\t\t      \"DC9 already programmed to be enabled.\\n\");\n\tdrm_WARN_ONCE(&dev_priv->drm,\n\t\t      intel_de_read(dev_priv, DC_STATE_EN) &\n\t\t      DC_STATE_EN_UPTO_DC5,\n\t\t      \"DC5 still not disabled to enable DC9.\\n\");\n\tdrm_WARN_ONCE(&dev_priv->drm,\n\t\t      intel_de_read(dev_priv, HSW_PWR_WELL_CTL2) &\n\t\t      HSW_PWR_WELL_CTL_REQ(SKL_PW_CTL_IDX_PW_2),\n\t\t      \"Power well 2 on.\\n\");\n\tdrm_WARN_ONCE(&dev_priv->drm, intel_irqs_enabled(dev_priv),\n\t\t      \"Interrupts not disabled yet.\\n\");\n\n\t  \n}\n\nstatic void assert_can_disable_dc9(struct drm_i915_private *dev_priv)\n{\n\tdrm_WARN_ONCE(&dev_priv->drm, intel_irqs_enabled(dev_priv),\n\t\t      \"Interrupts not disabled yet.\\n\");\n\tdrm_WARN_ONCE(&dev_priv->drm,\n\t\t      intel_de_read(dev_priv, DC_STATE_EN) &\n\t\t      DC_STATE_EN_UPTO_DC5,\n\t\t      \"DC5 still not disabled.\\n\");\n\n\t  \n}\n\nstatic void gen9_write_dc_state(struct drm_i915_private *dev_priv,\n\t\t\t\tu32 state)\n{\n\tint rewrites = 0;\n\tint rereads = 0;\n\tu32 v;\n\n\tintel_de_write(dev_priv, DC_STATE_EN, state);\n\n\t \n\tdo  {\n\t\tv = intel_de_read(dev_priv, DC_STATE_EN);\n\n\t\tif (v != state) {\n\t\t\tintel_de_write(dev_priv, DC_STATE_EN, state);\n\t\t\trewrites++;\n\t\t\trereads = 0;\n\t\t} else if (rereads++ > 5) {\n\t\t\tbreak;\n\t\t}\n\n\t} while (rewrites < 100);\n\n\tif (v != state)\n\t\tdrm_err(&dev_priv->drm,\n\t\t\t\"Writing dc state to 0x%x failed, now 0x%x\\n\",\n\t\t\tstate, v);\n\n\t \n\tif (rewrites > 1)\n\t\tdrm_dbg_kms(&dev_priv->drm,\n\t\t\t    \"Rewrote dc state to 0x%x %d times\\n\",\n\t\t\t    state, rewrites);\n}\n\nstatic u32 gen9_dc_mask(struct drm_i915_private *dev_priv)\n{\n\tu32 mask;\n\n\tmask = DC_STATE_EN_UPTO_DC5;\n\n\tif (DISPLAY_VER(dev_priv) >= 12)\n\t\tmask |= DC_STATE_EN_DC3CO | DC_STATE_EN_UPTO_DC6\n\t\t\t\t\t  | DC_STATE_EN_DC9;\n\telse if (DISPLAY_VER(dev_priv) == 11)\n\t\tmask |= DC_STATE_EN_UPTO_DC6 | DC_STATE_EN_DC9;\n\telse if (IS_GEMINILAKE(dev_priv) || IS_BROXTON(dev_priv))\n\t\tmask |= DC_STATE_EN_DC9;\n\telse\n\t\tmask |= DC_STATE_EN_UPTO_DC6;\n\n\treturn mask;\n}\n\nvoid gen9_sanitize_dc_state(struct drm_i915_private *i915)\n{\n\tstruct i915_power_domains *power_domains = &i915->display.power.domains;\n\tu32 val;\n\n\tif (!HAS_DISPLAY(i915))\n\t\treturn;\n\n\tval = intel_de_read(i915, DC_STATE_EN) & gen9_dc_mask(i915);\n\n\tdrm_dbg_kms(&i915->drm,\n\t\t    \"Resetting DC state tracking from %02x to %02x\\n\",\n\t\t    power_domains->dc_state, val);\n\tpower_domains->dc_state = val;\n}\n\n \nvoid gen9_set_dc_state(struct drm_i915_private *dev_priv, u32 state)\n{\n\tstruct i915_power_domains *power_domains = &dev_priv->display.power.domains;\n\tu32 val;\n\tu32 mask;\n\n\tif (!HAS_DISPLAY(dev_priv))\n\t\treturn;\n\n\tif (drm_WARN_ON_ONCE(&dev_priv->drm,\n\t\t\t     state & ~power_domains->allowed_dc_mask))\n\t\tstate &= power_domains->allowed_dc_mask;\n\n\tval = intel_de_read(dev_priv, DC_STATE_EN);\n\tmask = gen9_dc_mask(dev_priv);\n\tdrm_dbg_kms(&dev_priv->drm, \"Setting DC state from %02x to %02x\\n\",\n\t\t    val & mask, state);\n\n\t \n\tif ((val & mask) != power_domains->dc_state)\n\t\tdrm_err(&dev_priv->drm, \"DC state mismatch (0x%x -> 0x%x)\\n\",\n\t\t\tpower_domains->dc_state, val & mask);\n\n\tval &= ~mask;\n\tval |= state;\n\n\tgen9_write_dc_state(dev_priv, val);\n\n\tpower_domains->dc_state = val & mask;\n}\n\nstatic void tgl_enable_dc3co(struct drm_i915_private *dev_priv)\n{\n\tdrm_dbg_kms(&dev_priv->drm, \"Enabling DC3CO\\n\");\n\tgen9_set_dc_state(dev_priv, DC_STATE_EN_DC3CO);\n}\n\nstatic void tgl_disable_dc3co(struct drm_i915_private *dev_priv)\n{\n\tdrm_dbg_kms(&dev_priv->drm, \"Disabling DC3CO\\n\");\n\tintel_de_rmw(dev_priv, DC_STATE_EN, DC_STATE_DC3CO_STATUS, 0);\n\tgen9_set_dc_state(dev_priv, DC_STATE_DISABLE);\n\t \n\tusleep_range(200, 210);\n}\n\nstatic void assert_can_enable_dc5(struct drm_i915_private *dev_priv)\n{\n\tenum i915_power_well_id high_pg;\n\n\t \n\tif (DISPLAY_VER(dev_priv) == 12)\n\t\thigh_pg = ICL_DISP_PW_3;\n\telse\n\t\thigh_pg = SKL_DISP_PW_2;\n\n\tdrm_WARN_ONCE(&dev_priv->drm,\n\t\t      intel_display_power_well_is_enabled(dev_priv, high_pg),\n\t\t      \"Power wells above platform's DC5 limit still enabled.\\n\");\n\n\tdrm_WARN_ONCE(&dev_priv->drm,\n\t\t      (intel_de_read(dev_priv, DC_STATE_EN) &\n\t\t       DC_STATE_EN_UPTO_DC5),\n\t\t      \"DC5 already programmed to be enabled.\\n\");\n\tassert_rpm_wakelock_held(&dev_priv->runtime_pm);\n\n\tassert_dmc_loaded(dev_priv);\n}\n\nvoid gen9_enable_dc5(struct drm_i915_private *dev_priv)\n{\n\tassert_can_enable_dc5(dev_priv);\n\n\tdrm_dbg_kms(&dev_priv->drm, \"Enabling DC5\\n\");\n\n\t \n\tif (DISPLAY_VER(dev_priv) == 9 && !IS_BROXTON(dev_priv))\n\t\tintel_de_rmw(dev_priv, GEN8_CHICKEN_DCPR_1,\n\t\t\t     0, SKL_SELECT_ALTERNATE_DC_EXIT);\n\n\tgen9_set_dc_state(dev_priv, DC_STATE_EN_UPTO_DC5);\n}\n\nstatic void assert_can_enable_dc6(struct drm_i915_private *dev_priv)\n{\n\tdrm_WARN_ONCE(&dev_priv->drm,\n\t\t      (intel_de_read(dev_priv, UTIL_PIN_CTL) &\n\t\t       (UTIL_PIN_ENABLE | UTIL_PIN_MODE_MASK)) ==\n\t\t      (UTIL_PIN_ENABLE | UTIL_PIN_MODE_PWM),\n\t\t      \"Utility pin enabled in PWM mode\\n\");\n\tdrm_WARN_ONCE(&dev_priv->drm,\n\t\t      (intel_de_read(dev_priv, DC_STATE_EN) &\n\t\t       DC_STATE_EN_UPTO_DC6),\n\t\t      \"DC6 already programmed to be enabled.\\n\");\n\n\tassert_dmc_loaded(dev_priv);\n}\n\nvoid skl_enable_dc6(struct drm_i915_private *dev_priv)\n{\n\tassert_can_enable_dc6(dev_priv);\n\n\tdrm_dbg_kms(&dev_priv->drm, \"Enabling DC6\\n\");\n\n\t \n\tif (DISPLAY_VER(dev_priv) == 9 && !IS_BROXTON(dev_priv))\n\t\tintel_de_rmw(dev_priv, GEN8_CHICKEN_DCPR_1,\n\t\t\t     0, SKL_SELECT_ALTERNATE_DC_EXIT);\n\n\tgen9_set_dc_state(dev_priv, DC_STATE_EN_UPTO_DC6);\n}\n\nvoid bxt_enable_dc9(struct drm_i915_private *dev_priv)\n{\n\tassert_can_enable_dc9(dev_priv);\n\n\tdrm_dbg_kms(&dev_priv->drm, \"Enabling DC9\\n\");\n\t \n\tif (!HAS_PCH_SPLIT(dev_priv))\n\t\tintel_pps_reset_all(dev_priv);\n\tgen9_set_dc_state(dev_priv, DC_STATE_EN_DC9);\n}\n\nvoid bxt_disable_dc9(struct drm_i915_private *dev_priv)\n{\n\tassert_can_disable_dc9(dev_priv);\n\n\tdrm_dbg_kms(&dev_priv->drm, \"Disabling DC9\\n\");\n\n\tgen9_set_dc_state(dev_priv, DC_STATE_DISABLE);\n\n\tintel_pps_unlock_regs_wa(dev_priv);\n}\n\nstatic void hsw_power_well_sync_hw(struct drm_i915_private *dev_priv,\n\t\t\t\t   struct i915_power_well *power_well)\n{\n\tconst struct i915_power_well_regs *regs = power_well->desc->ops->regs;\n\tint pw_idx = i915_power_well_instance(power_well)->hsw.idx;\n\tu32 mask = HSW_PWR_WELL_CTL_REQ(pw_idx);\n\tu32 bios_req = intel_de_read(dev_priv, regs->bios);\n\n\t \n\tif (bios_req & mask) {\n\t\tu32 drv_req = intel_de_read(dev_priv, regs->driver);\n\n\t\tif (!(drv_req & mask))\n\t\t\tintel_de_write(dev_priv, regs->driver, drv_req | mask);\n\t\tintel_de_write(dev_priv, regs->bios, bios_req & ~mask);\n\t}\n}\n\nstatic void bxt_dpio_cmn_power_well_enable(struct drm_i915_private *dev_priv,\n\t\t\t\t\t   struct i915_power_well *power_well)\n{\n\tbxt_ddi_phy_init(dev_priv, i915_power_well_instance(power_well)->bxt.phy);\n}\n\nstatic void bxt_dpio_cmn_power_well_disable(struct drm_i915_private *dev_priv,\n\t\t\t\t\t    struct i915_power_well *power_well)\n{\n\tbxt_ddi_phy_uninit(dev_priv, i915_power_well_instance(power_well)->bxt.phy);\n}\n\nstatic bool bxt_dpio_cmn_power_well_enabled(struct drm_i915_private *dev_priv,\n\t\t\t\t\t    struct i915_power_well *power_well)\n{\n\treturn bxt_ddi_phy_is_enabled(dev_priv, i915_power_well_instance(power_well)->bxt.phy);\n}\n\nstatic void bxt_verify_ddi_phy_power_wells(struct drm_i915_private *dev_priv)\n{\n\tstruct i915_power_well *power_well;\n\n\tpower_well = lookup_power_well(dev_priv, BXT_DISP_PW_DPIO_CMN_A);\n\tif (intel_power_well_refcount(power_well) > 0)\n\t\tbxt_ddi_phy_verify_state(dev_priv, i915_power_well_instance(power_well)->bxt.phy);\n\n\tpower_well = lookup_power_well(dev_priv, VLV_DISP_PW_DPIO_CMN_BC);\n\tif (intel_power_well_refcount(power_well) > 0)\n\t\tbxt_ddi_phy_verify_state(dev_priv, i915_power_well_instance(power_well)->bxt.phy);\n\n\tif (IS_GEMINILAKE(dev_priv)) {\n\t\tpower_well = lookup_power_well(dev_priv,\n\t\t\t\t\t       GLK_DISP_PW_DPIO_CMN_C);\n\t\tif (intel_power_well_refcount(power_well) > 0)\n\t\t\tbxt_ddi_phy_verify_state(dev_priv,\n\t\t\t\t\t\t i915_power_well_instance(power_well)->bxt.phy);\n\t}\n}\n\nstatic bool gen9_dc_off_power_well_enabled(struct drm_i915_private *dev_priv,\n\t\t\t\t\t   struct i915_power_well *power_well)\n{\n\treturn ((intel_de_read(dev_priv, DC_STATE_EN) & DC_STATE_EN_DC3CO) == 0 &&\n\t\t(intel_de_read(dev_priv, DC_STATE_EN) & DC_STATE_EN_UPTO_DC5_DC6_MASK) == 0);\n}\n\nstatic void gen9_assert_dbuf_enabled(struct drm_i915_private *dev_priv)\n{\n\tu8 hw_enabled_dbuf_slices = intel_enabled_dbuf_slices_mask(dev_priv);\n\tu8 enabled_dbuf_slices = dev_priv->display.dbuf.enabled_slices;\n\n\tdrm_WARN(&dev_priv->drm,\n\t\t hw_enabled_dbuf_slices != enabled_dbuf_slices,\n\t\t \"Unexpected DBuf power power state (0x%08x, expected 0x%08x)\\n\",\n\t\t hw_enabled_dbuf_slices,\n\t\t enabled_dbuf_slices);\n}\n\nvoid gen9_disable_dc_states(struct drm_i915_private *dev_priv)\n{\n\tstruct i915_power_domains *power_domains = &dev_priv->display.power.domains;\n\tstruct intel_cdclk_config cdclk_config = {};\n\n\tif (power_domains->target_dc_state == DC_STATE_EN_DC3CO) {\n\t\ttgl_disable_dc3co(dev_priv);\n\t\treturn;\n\t}\n\n\tgen9_set_dc_state(dev_priv, DC_STATE_DISABLE);\n\n\tif (!HAS_DISPLAY(dev_priv))\n\t\treturn;\n\n\tintel_cdclk_get_cdclk(dev_priv, &cdclk_config);\n\t \n\tdrm_WARN_ON(&dev_priv->drm,\n\t\t    intel_cdclk_needs_modeset(&dev_priv->display.cdclk.hw,\n\t\t\t\t\t      &cdclk_config));\n\n\tgen9_assert_dbuf_enabled(dev_priv);\n\n\tif (IS_GEMINILAKE(dev_priv) || IS_BROXTON(dev_priv))\n\t\tbxt_verify_ddi_phy_power_wells(dev_priv);\n\n\tif (DISPLAY_VER(dev_priv) >= 11)\n\t\t \n\t\tintel_combo_phy_init(dev_priv);\n}\n\nstatic void gen9_dc_off_power_well_enable(struct drm_i915_private *dev_priv,\n\t\t\t\t\t  struct i915_power_well *power_well)\n{\n\tgen9_disable_dc_states(dev_priv);\n}\n\nstatic void gen9_dc_off_power_well_disable(struct drm_i915_private *dev_priv,\n\t\t\t\t\t   struct i915_power_well *power_well)\n{\n\tstruct i915_power_domains *power_domains = &dev_priv->display.power.domains;\n\n\tif (!intel_dmc_has_payload(dev_priv))\n\t\treturn;\n\n\tswitch (power_domains->target_dc_state) {\n\tcase DC_STATE_EN_DC3CO:\n\t\ttgl_enable_dc3co(dev_priv);\n\t\tbreak;\n\tcase DC_STATE_EN_UPTO_DC6:\n\t\tskl_enable_dc6(dev_priv);\n\t\tbreak;\n\tcase DC_STATE_EN_UPTO_DC5:\n\t\tgen9_enable_dc5(dev_priv);\n\t\tbreak;\n\t}\n}\n\nstatic void i9xx_power_well_sync_hw_noop(struct drm_i915_private *dev_priv,\n\t\t\t\t\t struct i915_power_well *power_well)\n{\n}\n\nstatic void i9xx_always_on_power_well_noop(struct drm_i915_private *dev_priv,\n\t\t\t\t\t   struct i915_power_well *power_well)\n{\n}\n\nstatic bool i9xx_always_on_power_well_enabled(struct drm_i915_private *dev_priv,\n\t\t\t\t\t     struct i915_power_well *power_well)\n{\n\treturn true;\n}\n\nstatic void i830_pipes_power_well_enable(struct drm_i915_private *dev_priv,\n\t\t\t\t\t struct i915_power_well *power_well)\n{\n\tif ((intel_de_read(dev_priv, TRANSCONF(PIPE_A)) & TRANSCONF_ENABLE) == 0)\n\t\ti830_enable_pipe(dev_priv, PIPE_A);\n\tif ((intel_de_read(dev_priv, TRANSCONF(PIPE_B)) & TRANSCONF_ENABLE) == 0)\n\t\ti830_enable_pipe(dev_priv, PIPE_B);\n}\n\nstatic void i830_pipes_power_well_disable(struct drm_i915_private *dev_priv,\n\t\t\t\t\t  struct i915_power_well *power_well)\n{\n\ti830_disable_pipe(dev_priv, PIPE_B);\n\ti830_disable_pipe(dev_priv, PIPE_A);\n}\n\nstatic bool i830_pipes_power_well_enabled(struct drm_i915_private *dev_priv,\n\t\t\t\t\t  struct i915_power_well *power_well)\n{\n\treturn intel_de_read(dev_priv, TRANSCONF(PIPE_A)) & TRANSCONF_ENABLE &&\n\t\tintel_de_read(dev_priv, TRANSCONF(PIPE_B)) & TRANSCONF_ENABLE;\n}\n\nstatic void i830_pipes_power_well_sync_hw(struct drm_i915_private *dev_priv,\n\t\t\t\t\t  struct i915_power_well *power_well)\n{\n\tif (intel_power_well_refcount(power_well) > 0)\n\t\ti830_pipes_power_well_enable(dev_priv, power_well);\n\telse\n\t\ti830_pipes_power_well_disable(dev_priv, power_well);\n}\n\nstatic void vlv_set_power_well(struct drm_i915_private *dev_priv,\n\t\t\t       struct i915_power_well *power_well, bool enable)\n{\n\tint pw_idx = i915_power_well_instance(power_well)->vlv.idx;\n\tu32 mask;\n\tu32 state;\n\tu32 ctrl;\n\n\tmask = PUNIT_PWRGT_MASK(pw_idx);\n\tstate = enable ? PUNIT_PWRGT_PWR_ON(pw_idx) :\n\t\t\t PUNIT_PWRGT_PWR_GATE(pw_idx);\n\n\tvlv_punit_get(dev_priv);\n\n#define COND \\\n\t((vlv_punit_read(dev_priv, PUNIT_REG_PWRGT_STATUS) & mask) == state)\n\n\tif (COND)\n\t\tgoto out;\n\n\tctrl = vlv_punit_read(dev_priv, PUNIT_REG_PWRGT_CTRL);\n\tctrl &= ~mask;\n\tctrl |= state;\n\tvlv_punit_write(dev_priv, PUNIT_REG_PWRGT_CTRL, ctrl);\n\n\tif (wait_for(COND, 100))\n\t\tdrm_err(&dev_priv->drm,\n\t\t\t\"timeout setting power well state %08x (%08x)\\n\",\n\t\t\tstate,\n\t\t\tvlv_punit_read(dev_priv, PUNIT_REG_PWRGT_CTRL));\n\n#undef COND\n\nout:\n\tvlv_punit_put(dev_priv);\n}\n\nstatic void vlv_power_well_enable(struct drm_i915_private *dev_priv,\n\t\t\t\t  struct i915_power_well *power_well)\n{\n\tvlv_set_power_well(dev_priv, power_well, true);\n}\n\nstatic void vlv_power_well_disable(struct drm_i915_private *dev_priv,\n\t\t\t\t   struct i915_power_well *power_well)\n{\n\tvlv_set_power_well(dev_priv, power_well, false);\n}\n\nstatic bool vlv_power_well_enabled(struct drm_i915_private *dev_priv,\n\t\t\t\t   struct i915_power_well *power_well)\n{\n\tint pw_idx = i915_power_well_instance(power_well)->vlv.idx;\n\tbool enabled = false;\n\tu32 mask;\n\tu32 state;\n\tu32 ctrl;\n\n\tmask = PUNIT_PWRGT_MASK(pw_idx);\n\tctrl = PUNIT_PWRGT_PWR_ON(pw_idx);\n\n\tvlv_punit_get(dev_priv);\n\n\tstate = vlv_punit_read(dev_priv, PUNIT_REG_PWRGT_STATUS) & mask;\n\t \n\tdrm_WARN_ON(&dev_priv->drm, state != PUNIT_PWRGT_PWR_ON(pw_idx) &&\n\t\t    state != PUNIT_PWRGT_PWR_GATE(pw_idx));\n\tif (state == ctrl)\n\t\tenabled = true;\n\n\t \n\tctrl = vlv_punit_read(dev_priv, PUNIT_REG_PWRGT_CTRL) & mask;\n\tdrm_WARN_ON(&dev_priv->drm, ctrl != state);\n\n\tvlv_punit_put(dev_priv);\n\n\treturn enabled;\n}\n\nstatic void vlv_init_display_clock_gating(struct drm_i915_private *dev_priv)\n{\n\t \n\tintel_de_rmw(dev_priv, DSPCLK_GATE_D(dev_priv),\n\t\t     ~DPOUNIT_CLOCK_GATE_DISABLE, VRHUNIT_CLOCK_GATE_DISABLE);\n\n\t \n\tintel_de_write(dev_priv, MI_ARB_VLV,\n\t\t       MI_ARB_DISPLAY_TRICKLE_FEED_DISABLE);\n\tintel_de_write(dev_priv, CBR1_VLV, 0);\n\n\tdrm_WARN_ON(&dev_priv->drm, RUNTIME_INFO(dev_priv)->rawclk_freq == 0);\n\tintel_de_write(dev_priv, RAWCLK_FREQ_VLV,\n\t\t       DIV_ROUND_CLOSEST(RUNTIME_INFO(dev_priv)->rawclk_freq,\n\t\t\t\t\t 1000));\n}\n\nstatic void vlv_display_power_well_init(struct drm_i915_private *dev_priv)\n{\n\tstruct intel_encoder *encoder;\n\tenum pipe pipe;\n\n\t \n\tfor_each_pipe(dev_priv, pipe) {\n\t\tu32 val = intel_de_read(dev_priv, DPLL(pipe));\n\n\t\tval |= DPLL_REF_CLK_ENABLE_VLV | DPLL_VGA_MODE_DIS;\n\t\tif (pipe != PIPE_A)\n\t\t\tval |= DPLL_INTEGRATED_CRI_CLK_VLV;\n\n\t\tintel_de_write(dev_priv, DPLL(pipe), val);\n\t}\n\n\tvlv_init_display_clock_gating(dev_priv);\n\n\tspin_lock_irq(&dev_priv->irq_lock);\n\tvalleyview_enable_display_irqs(dev_priv);\n\tspin_unlock_irq(&dev_priv->irq_lock);\n\n\t \n\tif (dev_priv->display.power.domains.initializing)\n\t\treturn;\n\n\tintel_hpd_init(dev_priv);\n\tintel_hpd_poll_disable(dev_priv);\n\n\t \n\tfor_each_intel_encoder(&dev_priv->drm, encoder) {\n\t\tif (encoder->type == INTEL_OUTPUT_ANALOG)\n\t\t\tintel_crt_reset(&encoder->base);\n\t}\n\n\tintel_vga_redisable_power_on(dev_priv);\n\n\tintel_pps_unlock_regs_wa(dev_priv);\n}\n\nstatic void vlv_display_power_well_deinit(struct drm_i915_private *dev_priv)\n{\n\tspin_lock_irq(&dev_priv->irq_lock);\n\tvalleyview_disable_display_irqs(dev_priv);\n\tspin_unlock_irq(&dev_priv->irq_lock);\n\n\t \n\tintel_synchronize_irq(dev_priv);\n\n\tintel_pps_reset_all(dev_priv);\n\n\t \n\tif (!dev_priv->drm.dev->power.is_suspended)\n\t\tintel_hpd_poll_enable(dev_priv);\n}\n\nstatic void vlv_display_power_well_enable(struct drm_i915_private *dev_priv,\n\t\t\t\t\t  struct i915_power_well *power_well)\n{\n\tvlv_set_power_well(dev_priv, power_well, true);\n\n\tvlv_display_power_well_init(dev_priv);\n}\n\nstatic void vlv_display_power_well_disable(struct drm_i915_private *dev_priv,\n\t\t\t\t\t   struct i915_power_well *power_well)\n{\n\tvlv_display_power_well_deinit(dev_priv);\n\n\tvlv_set_power_well(dev_priv, power_well, false);\n}\n\nstatic void vlv_dpio_cmn_power_well_enable(struct drm_i915_private *dev_priv,\n\t\t\t\t\t   struct i915_power_well *power_well)\n{\n\t \n\tudelay(1);  \n\n\tvlv_set_power_well(dev_priv, power_well, true);\n\n\t \n\tintel_de_rmw(dev_priv, DPIO_CTL, 0, DPIO_CMNRST);\n}\n\nstatic void vlv_dpio_cmn_power_well_disable(struct drm_i915_private *dev_priv,\n\t\t\t\t\t    struct i915_power_well *power_well)\n{\n\tenum pipe pipe;\n\n\tfor_each_pipe(dev_priv, pipe)\n\t\tassert_pll_disabled(dev_priv, pipe);\n\n\t \n\tintel_de_rmw(dev_priv, DPIO_CTL, DPIO_CMNRST, 0);\n\n\tvlv_set_power_well(dev_priv, power_well, false);\n}\n\n#define BITS_SET(val, bits) (((val) & (bits)) == (bits))\n\nstatic void assert_chv_phy_status(struct drm_i915_private *dev_priv)\n{\n\tstruct i915_power_well *cmn_bc =\n\t\tlookup_power_well(dev_priv, VLV_DISP_PW_DPIO_CMN_BC);\n\tstruct i915_power_well *cmn_d =\n\t\tlookup_power_well(dev_priv, CHV_DISP_PW_DPIO_CMN_D);\n\tu32 phy_control = dev_priv->display.power.chv_phy_control;\n\tu32 phy_status = 0;\n\tu32 phy_status_mask = 0xffffffff;\n\n\t \n\tif (!dev_priv->display.power.chv_phy_assert[DPIO_PHY0])\n\t\tphy_status_mask &= ~(PHY_STATUS_CMN_LDO(DPIO_PHY0, DPIO_CH0) |\n\t\t\t\t     PHY_STATUS_SPLINE_LDO(DPIO_PHY0, DPIO_CH0, 0) |\n\t\t\t\t     PHY_STATUS_SPLINE_LDO(DPIO_PHY0, DPIO_CH0, 1) |\n\t\t\t\t     PHY_STATUS_CMN_LDO(DPIO_PHY0, DPIO_CH1) |\n\t\t\t\t     PHY_STATUS_SPLINE_LDO(DPIO_PHY0, DPIO_CH1, 0) |\n\t\t\t\t     PHY_STATUS_SPLINE_LDO(DPIO_PHY0, DPIO_CH1, 1));\n\n\tif (!dev_priv->display.power.chv_phy_assert[DPIO_PHY1])\n\t\tphy_status_mask &= ~(PHY_STATUS_CMN_LDO(DPIO_PHY1, DPIO_CH0) |\n\t\t\t\t     PHY_STATUS_SPLINE_LDO(DPIO_PHY1, DPIO_CH0, 0) |\n\t\t\t\t     PHY_STATUS_SPLINE_LDO(DPIO_PHY1, DPIO_CH0, 1));\n\n\tif (intel_power_well_is_enabled(dev_priv, cmn_bc)) {\n\t\tphy_status |= PHY_POWERGOOD(DPIO_PHY0);\n\n\t\t \n\t\tif ((phy_control & PHY_CH_POWER_DOWN_OVRD_EN(DPIO_PHY0, DPIO_CH0)) == 0)\n\t\t\tphy_control |= PHY_CH_POWER_DOWN_OVRD(0xf, DPIO_PHY0, DPIO_CH0);\n\n\t\tif ((phy_control & PHY_CH_POWER_DOWN_OVRD_EN(DPIO_PHY0, DPIO_CH1)) == 0)\n\t\t\tphy_control |= PHY_CH_POWER_DOWN_OVRD(0xf, DPIO_PHY0, DPIO_CH1);\n\n\t\t \n\t\tif (BITS_SET(phy_control,\n\t\t\t     PHY_CH_POWER_DOWN_OVRD(0xf, DPIO_PHY0, DPIO_CH0) |\n\t\t\t     PHY_CH_POWER_DOWN_OVRD(0xf, DPIO_PHY0, DPIO_CH1)))\n\t\t\tphy_status |= PHY_STATUS_CMN_LDO(DPIO_PHY0, DPIO_CH0);\n\n\t\t \n\t\tif (BITS_SET(phy_control,\n\t\t\t     PHY_CH_POWER_DOWN_OVRD(0xf, DPIO_PHY0, DPIO_CH1)) &&\n\t\t    (intel_de_read(dev_priv, DPLL(PIPE_B)) & DPLL_VCO_ENABLE) == 0)\n\t\t\tphy_status |= PHY_STATUS_CMN_LDO(DPIO_PHY0, DPIO_CH1);\n\n\t\tif (BITS_SET(phy_control,\n\t\t\t     PHY_CH_POWER_DOWN_OVRD(0x3, DPIO_PHY0, DPIO_CH0)))\n\t\t\tphy_status |= PHY_STATUS_SPLINE_LDO(DPIO_PHY0, DPIO_CH0, 0);\n\t\tif (BITS_SET(phy_control,\n\t\t\t     PHY_CH_POWER_DOWN_OVRD(0xc, DPIO_PHY0, DPIO_CH0)))\n\t\t\tphy_status |= PHY_STATUS_SPLINE_LDO(DPIO_PHY0, DPIO_CH0, 1);\n\n\t\tif (BITS_SET(phy_control,\n\t\t\t     PHY_CH_POWER_DOWN_OVRD(0x3, DPIO_PHY0, DPIO_CH1)))\n\t\t\tphy_status |= PHY_STATUS_SPLINE_LDO(DPIO_PHY0, DPIO_CH1, 0);\n\t\tif (BITS_SET(phy_control,\n\t\t\t     PHY_CH_POWER_DOWN_OVRD(0xc, DPIO_PHY0, DPIO_CH1)))\n\t\t\tphy_status |= PHY_STATUS_SPLINE_LDO(DPIO_PHY0, DPIO_CH1, 1);\n\t}\n\n\tif (intel_power_well_is_enabled(dev_priv, cmn_d)) {\n\t\tphy_status |= PHY_POWERGOOD(DPIO_PHY1);\n\n\t\t \n\t\tif ((phy_control & PHY_CH_POWER_DOWN_OVRD_EN(DPIO_PHY1, DPIO_CH0)) == 0)\n\t\t\tphy_control |= PHY_CH_POWER_DOWN_OVRD(0xf, DPIO_PHY1, DPIO_CH0);\n\n\t\tif (BITS_SET(phy_control,\n\t\t\t     PHY_CH_POWER_DOWN_OVRD(0xf, DPIO_PHY1, DPIO_CH0)))\n\t\t\tphy_status |= PHY_STATUS_CMN_LDO(DPIO_PHY1, DPIO_CH0);\n\n\t\tif (BITS_SET(phy_control,\n\t\t\t     PHY_CH_POWER_DOWN_OVRD(0x3, DPIO_PHY1, DPIO_CH0)))\n\t\t\tphy_status |= PHY_STATUS_SPLINE_LDO(DPIO_PHY1, DPIO_CH0, 0);\n\t\tif (BITS_SET(phy_control,\n\t\t\t     PHY_CH_POWER_DOWN_OVRD(0xc, DPIO_PHY1, DPIO_CH0)))\n\t\t\tphy_status |= PHY_STATUS_SPLINE_LDO(DPIO_PHY1, DPIO_CH0, 1);\n\t}\n\n\tphy_status &= phy_status_mask;\n\n\t \n\tif (intel_de_wait_for_register(dev_priv, DISPLAY_PHY_STATUS,\n\t\t\t\t       phy_status_mask, phy_status, 10))\n\t\tdrm_err(&dev_priv->drm,\n\t\t\t\"Unexpected PHY_STATUS 0x%08x, expected 0x%08x (PHY_CONTROL=0x%08x)\\n\",\n\t\t\tintel_de_read(dev_priv, DISPLAY_PHY_STATUS) & phy_status_mask,\n\t\t\tphy_status, dev_priv->display.power.chv_phy_control);\n}\n\n#undef BITS_SET\n\nstatic void chv_dpio_cmn_power_well_enable(struct drm_i915_private *dev_priv,\n\t\t\t\t\t   struct i915_power_well *power_well)\n{\n\tenum i915_power_well_id id = i915_power_well_instance(power_well)->id;\n\tenum dpio_phy phy;\n\tenum pipe pipe;\n\tu32 tmp;\n\n\tdrm_WARN_ON_ONCE(&dev_priv->drm,\n\t\t\t id != VLV_DISP_PW_DPIO_CMN_BC &&\n\t\t\t id != CHV_DISP_PW_DPIO_CMN_D);\n\n\tif (id == VLV_DISP_PW_DPIO_CMN_BC) {\n\t\tpipe = PIPE_A;\n\t\tphy = DPIO_PHY0;\n\t} else {\n\t\tpipe = PIPE_C;\n\t\tphy = DPIO_PHY1;\n\t}\n\n\t \n\tudelay(1);  \n\tvlv_set_power_well(dev_priv, power_well, true);\n\n\t \n\tif (intel_de_wait_for_set(dev_priv, DISPLAY_PHY_STATUS,\n\t\t\t\t  PHY_POWERGOOD(phy), 1))\n\t\tdrm_err(&dev_priv->drm, \"Display PHY %d is not power up\\n\",\n\t\t\tphy);\n\n\tvlv_dpio_get(dev_priv);\n\n\t \n\ttmp = vlv_dpio_read(dev_priv, pipe, CHV_CMN_DW28);\n\ttmp |= DPIO_DYNPWRDOWNEN_CH0 | DPIO_CL1POWERDOWNEN |\n\t\tDPIO_SUS_CLK_CONFIG_GATE_CLKREQ;\n\tvlv_dpio_write(dev_priv, pipe, CHV_CMN_DW28, tmp);\n\n\tif (id == VLV_DISP_PW_DPIO_CMN_BC) {\n\t\ttmp = vlv_dpio_read(dev_priv, pipe, _CHV_CMN_DW6_CH1);\n\t\ttmp |= DPIO_DYNPWRDOWNEN_CH1;\n\t\tvlv_dpio_write(dev_priv, pipe, _CHV_CMN_DW6_CH1, tmp);\n\t} else {\n\t\t \n\t\ttmp = vlv_dpio_read(dev_priv, pipe, CHV_CMN_DW30);\n\t\ttmp |= DPIO_CL2_LDOFUSE_PWRENB;\n\t\tvlv_dpio_write(dev_priv, pipe, CHV_CMN_DW30, tmp);\n\t}\n\n\tvlv_dpio_put(dev_priv);\n\n\tdev_priv->display.power.chv_phy_control |= PHY_COM_LANE_RESET_DEASSERT(phy);\n\tintel_de_write(dev_priv, DISPLAY_PHY_CONTROL,\n\t\t       dev_priv->display.power.chv_phy_control);\n\n\tdrm_dbg_kms(&dev_priv->drm,\n\t\t    \"Enabled DPIO PHY%d (PHY_CONTROL=0x%08x)\\n\",\n\t\t    phy, dev_priv->display.power.chv_phy_control);\n\n\tassert_chv_phy_status(dev_priv);\n}\n\nstatic void chv_dpio_cmn_power_well_disable(struct drm_i915_private *dev_priv,\n\t\t\t\t\t    struct i915_power_well *power_well)\n{\n\tenum i915_power_well_id id = i915_power_well_instance(power_well)->id;\n\tenum dpio_phy phy;\n\n\tdrm_WARN_ON_ONCE(&dev_priv->drm,\n\t\t\t id != VLV_DISP_PW_DPIO_CMN_BC &&\n\t\t\t id != CHV_DISP_PW_DPIO_CMN_D);\n\n\tif (id == VLV_DISP_PW_DPIO_CMN_BC) {\n\t\tphy = DPIO_PHY0;\n\t\tassert_pll_disabled(dev_priv, PIPE_A);\n\t\tassert_pll_disabled(dev_priv, PIPE_B);\n\t} else {\n\t\tphy = DPIO_PHY1;\n\t\tassert_pll_disabled(dev_priv, PIPE_C);\n\t}\n\n\tdev_priv->display.power.chv_phy_control &= ~PHY_COM_LANE_RESET_DEASSERT(phy);\n\tintel_de_write(dev_priv, DISPLAY_PHY_CONTROL,\n\t\t       dev_priv->display.power.chv_phy_control);\n\n\tvlv_set_power_well(dev_priv, power_well, false);\n\n\tdrm_dbg_kms(&dev_priv->drm,\n\t\t    \"Disabled DPIO PHY%d (PHY_CONTROL=0x%08x)\\n\",\n\t\t    phy, dev_priv->display.power.chv_phy_control);\n\n\t \n\tdev_priv->display.power.chv_phy_assert[phy] = true;\n\n\tassert_chv_phy_status(dev_priv);\n}\n\nstatic void assert_chv_phy_powergate(struct drm_i915_private *dev_priv, enum dpio_phy phy,\n\t\t\t\t     enum dpio_channel ch, bool override, unsigned int mask)\n{\n\tenum pipe pipe = phy == DPIO_PHY0 ? PIPE_A : PIPE_C;\n\tu32 reg, val, expected, actual;\n\n\t \n\tif (!dev_priv->display.power.chv_phy_assert[phy])\n\t\treturn;\n\n\tif (ch == DPIO_CH0)\n\t\treg = _CHV_CMN_DW0_CH0;\n\telse\n\t\treg = _CHV_CMN_DW6_CH1;\n\n\tvlv_dpio_get(dev_priv);\n\tval = vlv_dpio_read(dev_priv, pipe, reg);\n\tvlv_dpio_put(dev_priv);\n\n\t \n\tif (!override || mask == 0xf) {\n\t\texpected = DPIO_ALLDL_POWERDOWN | DPIO_ANYDL_POWERDOWN;\n\t\t \n\t\tif (ch == DPIO_CH1 && val == 0)\n\t\t\texpected = 0;\n\t} else if (mask != 0x0) {\n\t\texpected = DPIO_ANYDL_POWERDOWN;\n\t} else {\n\t\texpected = 0;\n\t}\n\n\tif (ch == DPIO_CH0)\n\t\tactual = val >> DPIO_ANYDL_POWERDOWN_SHIFT_CH0;\n\telse\n\t\tactual = val >> DPIO_ANYDL_POWERDOWN_SHIFT_CH1;\n\tactual &= DPIO_ALLDL_POWERDOWN | DPIO_ANYDL_POWERDOWN;\n\n\tdrm_WARN(&dev_priv->drm, actual != expected,\n\t\t \"Unexpected DPIO lane power down: all %d, any %d. Expected: all %d, any %d. (0x%x = 0x%08x)\\n\",\n\t\t !!(actual & DPIO_ALLDL_POWERDOWN),\n\t\t !!(actual & DPIO_ANYDL_POWERDOWN),\n\t\t !!(expected & DPIO_ALLDL_POWERDOWN),\n\t\t !!(expected & DPIO_ANYDL_POWERDOWN),\n\t\t reg, val);\n}\n\nbool chv_phy_powergate_ch(struct drm_i915_private *dev_priv, enum dpio_phy phy,\n\t\t\t  enum dpio_channel ch, bool override)\n{\n\tstruct i915_power_domains *power_domains = &dev_priv->display.power.domains;\n\tbool was_override;\n\n\tmutex_lock(&power_domains->lock);\n\n\twas_override = dev_priv->display.power.chv_phy_control & PHY_CH_POWER_DOWN_OVRD_EN(phy, ch);\n\n\tif (override == was_override)\n\t\tgoto out;\n\n\tif (override)\n\t\tdev_priv->display.power.chv_phy_control |= PHY_CH_POWER_DOWN_OVRD_EN(phy, ch);\n\telse\n\t\tdev_priv->display.power.chv_phy_control &= ~PHY_CH_POWER_DOWN_OVRD_EN(phy, ch);\n\n\tintel_de_write(dev_priv, DISPLAY_PHY_CONTROL,\n\t\t       dev_priv->display.power.chv_phy_control);\n\n\tdrm_dbg_kms(&dev_priv->drm,\n\t\t    \"Power gating DPIO PHY%d CH%d (DPIO_PHY_CONTROL=0x%08x)\\n\",\n\t\t    phy, ch, dev_priv->display.power.chv_phy_control);\n\n\tassert_chv_phy_status(dev_priv);\n\nout:\n\tmutex_unlock(&power_domains->lock);\n\n\treturn was_override;\n}\n\nvoid chv_phy_powergate_lanes(struct intel_encoder *encoder,\n\t\t\t     bool override, unsigned int mask)\n{\n\tstruct drm_i915_private *dev_priv = to_i915(encoder->base.dev);\n\tstruct i915_power_domains *power_domains = &dev_priv->display.power.domains;\n\tenum dpio_phy phy = vlv_dig_port_to_phy(enc_to_dig_port(encoder));\n\tenum dpio_channel ch = vlv_dig_port_to_channel(enc_to_dig_port(encoder));\n\n\tmutex_lock(&power_domains->lock);\n\n\tdev_priv->display.power.chv_phy_control &= ~PHY_CH_POWER_DOWN_OVRD(0xf, phy, ch);\n\tdev_priv->display.power.chv_phy_control |= PHY_CH_POWER_DOWN_OVRD(mask, phy, ch);\n\n\tif (override)\n\t\tdev_priv->display.power.chv_phy_control |= PHY_CH_POWER_DOWN_OVRD_EN(phy, ch);\n\telse\n\t\tdev_priv->display.power.chv_phy_control &= ~PHY_CH_POWER_DOWN_OVRD_EN(phy, ch);\n\n\tintel_de_write(dev_priv, DISPLAY_PHY_CONTROL,\n\t\t       dev_priv->display.power.chv_phy_control);\n\n\tdrm_dbg_kms(&dev_priv->drm,\n\t\t    \"Power gating DPIO PHY%d CH%d lanes 0x%x (PHY_CONTROL=0x%08x)\\n\",\n\t\t    phy, ch, mask, dev_priv->display.power.chv_phy_control);\n\n\tassert_chv_phy_status(dev_priv);\n\n\tassert_chv_phy_powergate(dev_priv, phy, ch, override, mask);\n\n\tmutex_unlock(&power_domains->lock);\n}\n\nstatic bool chv_pipe_power_well_enabled(struct drm_i915_private *dev_priv,\n\t\t\t\t\tstruct i915_power_well *power_well)\n{\n\tenum pipe pipe = PIPE_A;\n\tbool enabled;\n\tu32 state, ctrl;\n\n\tvlv_punit_get(dev_priv);\n\n\tstate = vlv_punit_read(dev_priv, PUNIT_REG_DSPSSPM) & DP_SSS_MASK(pipe);\n\t \n\tdrm_WARN_ON(&dev_priv->drm, state != DP_SSS_PWR_ON(pipe) &&\n\t\t    state != DP_SSS_PWR_GATE(pipe));\n\tenabled = state == DP_SSS_PWR_ON(pipe);\n\n\t \n\tctrl = vlv_punit_read(dev_priv, PUNIT_REG_DSPSSPM) & DP_SSC_MASK(pipe);\n\tdrm_WARN_ON(&dev_priv->drm, ctrl << 16 != state);\n\n\tvlv_punit_put(dev_priv);\n\n\treturn enabled;\n}\n\nstatic void chv_set_pipe_power_well(struct drm_i915_private *dev_priv,\n\t\t\t\t    struct i915_power_well *power_well,\n\t\t\t\t    bool enable)\n{\n\tenum pipe pipe = PIPE_A;\n\tu32 state;\n\tu32 ctrl;\n\n\tstate = enable ? DP_SSS_PWR_ON(pipe) : DP_SSS_PWR_GATE(pipe);\n\n\tvlv_punit_get(dev_priv);\n\n#define COND \\\n\t((vlv_punit_read(dev_priv, PUNIT_REG_DSPSSPM) & DP_SSS_MASK(pipe)) == state)\n\n\tif (COND)\n\t\tgoto out;\n\n\tctrl = vlv_punit_read(dev_priv, PUNIT_REG_DSPSSPM);\n\tctrl &= ~DP_SSC_MASK(pipe);\n\tctrl |= enable ? DP_SSC_PWR_ON(pipe) : DP_SSC_PWR_GATE(pipe);\n\tvlv_punit_write(dev_priv, PUNIT_REG_DSPSSPM, ctrl);\n\n\tif (wait_for(COND, 100))\n\t\tdrm_err(&dev_priv->drm,\n\t\t\t\"timeout setting power well state %08x (%08x)\\n\",\n\t\t\tstate,\n\t\t\tvlv_punit_read(dev_priv, PUNIT_REG_DSPSSPM));\n\n#undef COND\n\nout:\n\tvlv_punit_put(dev_priv);\n}\n\nstatic void chv_pipe_power_well_sync_hw(struct drm_i915_private *dev_priv,\n\t\t\t\t\tstruct i915_power_well *power_well)\n{\n\tintel_de_write(dev_priv, DISPLAY_PHY_CONTROL,\n\t\t       dev_priv->display.power.chv_phy_control);\n}\n\nstatic void chv_pipe_power_well_enable(struct drm_i915_private *dev_priv,\n\t\t\t\t       struct i915_power_well *power_well)\n{\n\tchv_set_pipe_power_well(dev_priv, power_well, true);\n\n\tvlv_display_power_well_init(dev_priv);\n}\n\nstatic void chv_pipe_power_well_disable(struct drm_i915_private *dev_priv,\n\t\t\t\t\tstruct i915_power_well *power_well)\n{\n\tvlv_display_power_well_deinit(dev_priv);\n\n\tchv_set_pipe_power_well(dev_priv, power_well, false);\n}\n\nstatic void\ntgl_tc_cold_request(struct drm_i915_private *i915, bool block)\n{\n\tu8 tries = 0;\n\tint ret;\n\n\twhile (1) {\n\t\tu32 low_val;\n\t\tu32 high_val = 0;\n\n\t\tif (block)\n\t\t\tlow_val = TGL_PCODE_EXIT_TCCOLD_DATA_L_BLOCK_REQ;\n\t\telse\n\t\t\tlow_val = TGL_PCODE_EXIT_TCCOLD_DATA_L_UNBLOCK_REQ;\n\n\t\t \n\t\tret = snb_pcode_read(&i915->uncore, TGL_PCODE_TCCOLD, &low_val, &high_val);\n\t\tif (ret == 0) {\n\t\t\tif (block &&\n\t\t\t    (low_val & TGL_PCODE_EXIT_TCCOLD_DATA_L_EXIT_FAILED))\n\t\t\t\tret = -EIO;\n\t\t\telse\n\t\t\t\tbreak;\n\t\t}\n\n\t\tif (++tries == 3)\n\t\t\tbreak;\n\n\t\tmsleep(1);\n\t}\n\n\tif (ret)\n\t\tdrm_err(&i915->drm, \"TC cold %sblock failed\\n\",\n\t\t\tblock ? \"\" : \"un\");\n\telse\n\t\tdrm_dbg_kms(&i915->drm, \"TC cold %sblock succeeded\\n\",\n\t\t\t    block ? \"\" : \"un\");\n}\n\nstatic void\ntgl_tc_cold_off_power_well_enable(struct drm_i915_private *i915,\n\t\t\t\t  struct i915_power_well *power_well)\n{\n\ttgl_tc_cold_request(i915, true);\n}\n\nstatic void\ntgl_tc_cold_off_power_well_disable(struct drm_i915_private *i915,\n\t\t\t\t   struct i915_power_well *power_well)\n{\n\ttgl_tc_cold_request(i915, false);\n}\n\nstatic void\ntgl_tc_cold_off_power_well_sync_hw(struct drm_i915_private *i915,\n\t\t\t\t   struct i915_power_well *power_well)\n{\n\tif (intel_power_well_refcount(power_well) > 0)\n\t\ttgl_tc_cold_off_power_well_enable(i915, power_well);\n\telse\n\t\ttgl_tc_cold_off_power_well_disable(i915, power_well);\n}\n\nstatic bool\ntgl_tc_cold_off_power_well_is_enabled(struct drm_i915_private *dev_priv,\n\t\t\t\t      struct i915_power_well *power_well)\n{\n\t \n\treturn intel_power_well_refcount(power_well);\n}\n\nstatic void xelpdp_aux_power_well_enable(struct drm_i915_private *dev_priv,\n\t\t\t\t\t struct i915_power_well *power_well)\n{\n\tenum aux_ch aux_ch = i915_power_well_instance(power_well)->xelpdp.aux_ch;\n\n\tintel_de_rmw(dev_priv, XELPDP_DP_AUX_CH_CTL(aux_ch),\n\t\t     XELPDP_DP_AUX_CH_CTL_POWER_REQUEST,\n\t\t     XELPDP_DP_AUX_CH_CTL_POWER_REQUEST);\n\n\t \n\tusleep_range(600, 1200);\n}\n\nstatic void xelpdp_aux_power_well_disable(struct drm_i915_private *dev_priv,\n\t\t\t\t\t  struct i915_power_well *power_well)\n{\n\tenum aux_ch aux_ch = i915_power_well_instance(power_well)->xelpdp.aux_ch;\n\n\tintel_de_rmw(dev_priv, XELPDP_DP_AUX_CH_CTL(aux_ch),\n\t\t     XELPDP_DP_AUX_CH_CTL_POWER_REQUEST,\n\t\t     0);\n\tusleep_range(10, 30);\n}\n\nstatic bool xelpdp_aux_power_well_enabled(struct drm_i915_private *dev_priv,\n\t\t\t\t\t  struct i915_power_well *power_well)\n{\n\tenum aux_ch aux_ch = i915_power_well_instance(power_well)->xelpdp.aux_ch;\n\n\treturn intel_de_read(dev_priv, XELPDP_DP_AUX_CH_CTL(aux_ch)) &\n\t\tXELPDP_DP_AUX_CH_CTL_POWER_STATUS;\n}\n\nconst struct i915_power_well_ops i9xx_always_on_power_well_ops = {\n\t.sync_hw = i9xx_power_well_sync_hw_noop,\n\t.enable = i9xx_always_on_power_well_noop,\n\t.disable = i9xx_always_on_power_well_noop,\n\t.is_enabled = i9xx_always_on_power_well_enabled,\n};\n\nconst struct i915_power_well_ops chv_pipe_power_well_ops = {\n\t.sync_hw = chv_pipe_power_well_sync_hw,\n\t.enable = chv_pipe_power_well_enable,\n\t.disable = chv_pipe_power_well_disable,\n\t.is_enabled = chv_pipe_power_well_enabled,\n};\n\nconst struct i915_power_well_ops chv_dpio_cmn_power_well_ops = {\n\t.sync_hw = i9xx_power_well_sync_hw_noop,\n\t.enable = chv_dpio_cmn_power_well_enable,\n\t.disable = chv_dpio_cmn_power_well_disable,\n\t.is_enabled = vlv_power_well_enabled,\n};\n\nconst struct i915_power_well_ops i830_pipes_power_well_ops = {\n\t.sync_hw = i830_pipes_power_well_sync_hw,\n\t.enable = i830_pipes_power_well_enable,\n\t.disable = i830_pipes_power_well_disable,\n\t.is_enabled = i830_pipes_power_well_enabled,\n};\n\nstatic const struct i915_power_well_regs hsw_power_well_regs = {\n\t.bios\t= HSW_PWR_WELL_CTL1,\n\t.driver\t= HSW_PWR_WELL_CTL2,\n\t.kvmr\t= HSW_PWR_WELL_CTL3,\n\t.debug\t= HSW_PWR_WELL_CTL4,\n};\n\nconst struct i915_power_well_ops hsw_power_well_ops = {\n\t.regs = &hsw_power_well_regs,\n\t.sync_hw = hsw_power_well_sync_hw,\n\t.enable = hsw_power_well_enable,\n\t.disable = hsw_power_well_disable,\n\t.is_enabled = hsw_power_well_enabled,\n};\n\nconst struct i915_power_well_ops gen9_dc_off_power_well_ops = {\n\t.sync_hw = i9xx_power_well_sync_hw_noop,\n\t.enable = gen9_dc_off_power_well_enable,\n\t.disable = gen9_dc_off_power_well_disable,\n\t.is_enabled = gen9_dc_off_power_well_enabled,\n};\n\nconst struct i915_power_well_ops bxt_dpio_cmn_power_well_ops = {\n\t.sync_hw = i9xx_power_well_sync_hw_noop,\n\t.enable = bxt_dpio_cmn_power_well_enable,\n\t.disable = bxt_dpio_cmn_power_well_disable,\n\t.is_enabled = bxt_dpio_cmn_power_well_enabled,\n};\n\nconst struct i915_power_well_ops vlv_display_power_well_ops = {\n\t.sync_hw = i9xx_power_well_sync_hw_noop,\n\t.enable = vlv_display_power_well_enable,\n\t.disable = vlv_display_power_well_disable,\n\t.is_enabled = vlv_power_well_enabled,\n};\n\nconst struct i915_power_well_ops vlv_dpio_cmn_power_well_ops = {\n\t.sync_hw = i9xx_power_well_sync_hw_noop,\n\t.enable = vlv_dpio_cmn_power_well_enable,\n\t.disable = vlv_dpio_cmn_power_well_disable,\n\t.is_enabled = vlv_power_well_enabled,\n};\n\nconst struct i915_power_well_ops vlv_dpio_power_well_ops = {\n\t.sync_hw = i9xx_power_well_sync_hw_noop,\n\t.enable = vlv_power_well_enable,\n\t.disable = vlv_power_well_disable,\n\t.is_enabled = vlv_power_well_enabled,\n};\n\nstatic const struct i915_power_well_regs icl_aux_power_well_regs = {\n\t.bios\t= ICL_PWR_WELL_CTL_AUX1,\n\t.driver\t= ICL_PWR_WELL_CTL_AUX2,\n\t.debug\t= ICL_PWR_WELL_CTL_AUX4,\n};\n\nconst struct i915_power_well_ops icl_aux_power_well_ops = {\n\t.regs = &icl_aux_power_well_regs,\n\t.sync_hw = hsw_power_well_sync_hw,\n\t.enable = icl_aux_power_well_enable,\n\t.disable = icl_aux_power_well_disable,\n\t.is_enabled = hsw_power_well_enabled,\n};\n\nstatic const struct i915_power_well_regs icl_ddi_power_well_regs = {\n\t.bios\t= ICL_PWR_WELL_CTL_DDI1,\n\t.driver\t= ICL_PWR_WELL_CTL_DDI2,\n\t.debug\t= ICL_PWR_WELL_CTL_DDI4,\n};\n\nconst struct i915_power_well_ops icl_ddi_power_well_ops = {\n\t.regs = &icl_ddi_power_well_regs,\n\t.sync_hw = hsw_power_well_sync_hw,\n\t.enable = hsw_power_well_enable,\n\t.disable = hsw_power_well_disable,\n\t.is_enabled = hsw_power_well_enabled,\n};\n\nconst struct i915_power_well_ops tgl_tc_cold_off_ops = {\n\t.sync_hw = tgl_tc_cold_off_power_well_sync_hw,\n\t.enable = tgl_tc_cold_off_power_well_enable,\n\t.disable = tgl_tc_cold_off_power_well_disable,\n\t.is_enabled = tgl_tc_cold_off_power_well_is_enabled,\n};\n\nconst struct i915_power_well_ops xelpdp_aux_power_well_ops = {\n\t.sync_hw = i9xx_power_well_sync_hw_noop,\n\t.enable = xelpdp_aux_power_well_enable,\n\t.disable = xelpdp_aux_power_well_disable,\n\t.is_enabled = xelpdp_aux_power_well_enabled,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}