{
  "module_name": "intel_crt.c",
  "hash_id": "8da0fb25547c3d0bd50463044276770f5e3a58f039dc672c6d91b44989316313",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/i915/display/intel_crt.c",
  "human_readable_source": " \n\n#include <linux/dmi.h>\n#include <linux/i2c.h>\n#include <linux/slab.h>\n\n#include <drm/drm_atomic_helper.h>\n#include <drm/drm_crtc.h>\n#include <drm/drm_edid.h>\n#include <drm/drm_probe_helper.h>\n\n#include \"i915_drv.h\"\n#include \"i915_irq.h\"\n#include \"i915_reg.h\"\n#include \"intel_connector.h\"\n#include \"intel_crt.h\"\n#include \"intel_crtc.h\"\n#include \"intel_ddi.h\"\n#include \"intel_ddi_buf_trans.h\"\n#include \"intel_de.h\"\n#include \"intel_display_types.h\"\n#include \"intel_fdi.h\"\n#include \"intel_fdi_regs.h\"\n#include \"intel_fifo_underrun.h\"\n#include \"intel_gmbus.h\"\n#include \"intel_hotplug.h\"\n#include \"intel_hotplug_irq.h\"\n#include \"intel_load_detect.h\"\n#include \"intel_pch_display.h\"\n#include \"intel_pch_refclk.h\"\n\n \n#define ADPA_HOTPLUG_BITS (ADPA_CRT_HOTPLUG_PERIOD_128 |\t\t\\\n\t\t\t   ADPA_CRT_HOTPLUG_WARMUP_10MS |\t\t\\\n\t\t\t   ADPA_CRT_HOTPLUG_SAMPLE_4S |\t\t\t\\\n\t\t\t   ADPA_CRT_HOTPLUG_VOLTAGE_50 |\t\t\\\n\t\t\t   ADPA_CRT_HOTPLUG_VOLREF_325MV |\t\t\\\n\t\t\t   ADPA_CRT_HOTPLUG_ENABLE)\n\nstruct intel_crt {\n\tstruct intel_encoder base;\n\t \n\tstruct intel_connector *connector;\n\tbool force_hotplug_required;\n\ti915_reg_t adpa_reg;\n};\n\nstatic struct intel_crt *intel_encoder_to_crt(struct intel_encoder *encoder)\n{\n\treturn container_of(encoder, struct intel_crt, base);\n}\n\nstatic struct intel_crt *intel_attached_crt(struct intel_connector *connector)\n{\n\treturn intel_encoder_to_crt(intel_attached_encoder(connector));\n}\n\nbool intel_crt_port_enabled(struct drm_i915_private *dev_priv,\n\t\t\t    i915_reg_t adpa_reg, enum pipe *pipe)\n{\n\tu32 val;\n\n\tval = intel_de_read(dev_priv, adpa_reg);\n\n\t \n\tif (HAS_PCH_CPT(dev_priv))\n\t\t*pipe = (val & ADPA_PIPE_SEL_MASK_CPT) >> ADPA_PIPE_SEL_SHIFT_CPT;\n\telse\n\t\t*pipe = (val & ADPA_PIPE_SEL_MASK) >> ADPA_PIPE_SEL_SHIFT;\n\n\treturn val & ADPA_DAC_ENABLE;\n}\n\nstatic bool intel_crt_get_hw_state(struct intel_encoder *encoder,\n\t\t\t\t   enum pipe *pipe)\n{\n\tstruct drm_i915_private *dev_priv = to_i915(encoder->base.dev);\n\tstruct intel_crt *crt = intel_encoder_to_crt(encoder);\n\tintel_wakeref_t wakeref;\n\tbool ret;\n\n\twakeref = intel_display_power_get_if_enabled(dev_priv,\n\t\t\t\t\t\t     encoder->power_domain);\n\tif (!wakeref)\n\t\treturn false;\n\n\tret = intel_crt_port_enabled(dev_priv, crt->adpa_reg, pipe);\n\n\tintel_display_power_put(dev_priv, encoder->power_domain, wakeref);\n\n\treturn ret;\n}\n\nstatic unsigned int intel_crt_get_flags(struct intel_encoder *encoder)\n{\n\tstruct drm_i915_private *dev_priv = to_i915(encoder->base.dev);\n\tstruct intel_crt *crt = intel_encoder_to_crt(encoder);\n\tu32 tmp, flags = 0;\n\n\ttmp = intel_de_read(dev_priv, crt->adpa_reg);\n\n\tif (tmp & ADPA_HSYNC_ACTIVE_HIGH)\n\t\tflags |= DRM_MODE_FLAG_PHSYNC;\n\telse\n\t\tflags |= DRM_MODE_FLAG_NHSYNC;\n\n\tif (tmp & ADPA_VSYNC_ACTIVE_HIGH)\n\t\tflags |= DRM_MODE_FLAG_PVSYNC;\n\telse\n\t\tflags |= DRM_MODE_FLAG_NVSYNC;\n\n\treturn flags;\n}\n\nstatic void intel_crt_get_config(struct intel_encoder *encoder,\n\t\t\t\t struct intel_crtc_state *pipe_config)\n{\n\tpipe_config->output_types |= BIT(INTEL_OUTPUT_ANALOG);\n\n\tpipe_config->hw.adjusted_mode.flags |= intel_crt_get_flags(encoder);\n\n\tpipe_config->hw.adjusted_mode.crtc_clock = pipe_config->port_clock;\n}\n\nstatic void hsw_crt_get_config(struct intel_encoder *encoder,\n\t\t\t       struct intel_crtc_state *pipe_config)\n{\n\tlpt_pch_get_config(pipe_config);\n\n\thsw_ddi_get_config(encoder, pipe_config);\n\n\tpipe_config->hw.adjusted_mode.flags &= ~(DRM_MODE_FLAG_PHSYNC |\n\t\t\t\t\t      DRM_MODE_FLAG_NHSYNC |\n\t\t\t\t\t      DRM_MODE_FLAG_PVSYNC |\n\t\t\t\t\t      DRM_MODE_FLAG_NVSYNC);\n\tpipe_config->hw.adjusted_mode.flags |= intel_crt_get_flags(encoder);\n}\n\n \nstatic void intel_crt_set_dpms(struct intel_encoder *encoder,\n\t\t\t       const struct intel_crtc_state *crtc_state,\n\t\t\t       int mode)\n{\n\tstruct drm_i915_private *dev_priv = to_i915(encoder->base.dev);\n\tstruct intel_crt *crt = intel_encoder_to_crt(encoder);\n\tstruct intel_crtc *crtc = to_intel_crtc(crtc_state->uapi.crtc);\n\tconst struct drm_display_mode *adjusted_mode = &crtc_state->hw.adjusted_mode;\n\tu32 adpa;\n\n\tif (DISPLAY_VER(dev_priv) >= 5)\n\t\tadpa = ADPA_HOTPLUG_BITS;\n\telse\n\t\tadpa = 0;\n\n\tif (adjusted_mode->flags & DRM_MODE_FLAG_PHSYNC)\n\t\tadpa |= ADPA_HSYNC_ACTIVE_HIGH;\n\tif (adjusted_mode->flags & DRM_MODE_FLAG_PVSYNC)\n\t\tadpa |= ADPA_VSYNC_ACTIVE_HIGH;\n\n\t \n\tif (HAS_PCH_LPT(dev_priv))\n\t\t;  \n\telse if (HAS_PCH_CPT(dev_priv))\n\t\tadpa |= ADPA_PIPE_SEL_CPT(crtc->pipe);\n\telse\n\t\tadpa |= ADPA_PIPE_SEL(crtc->pipe);\n\n\tif (!HAS_PCH_SPLIT(dev_priv))\n\t\tintel_de_write(dev_priv, BCLRPAT(crtc->pipe), 0);\n\n\tswitch (mode) {\n\tcase DRM_MODE_DPMS_ON:\n\t\tadpa |= ADPA_DAC_ENABLE;\n\t\tbreak;\n\tcase DRM_MODE_DPMS_STANDBY:\n\t\tadpa |= ADPA_DAC_ENABLE | ADPA_HSYNC_CNTL_DISABLE;\n\t\tbreak;\n\tcase DRM_MODE_DPMS_SUSPEND:\n\t\tadpa |= ADPA_DAC_ENABLE | ADPA_VSYNC_CNTL_DISABLE;\n\t\tbreak;\n\tcase DRM_MODE_DPMS_OFF:\n\t\tadpa |= ADPA_HSYNC_CNTL_DISABLE | ADPA_VSYNC_CNTL_DISABLE;\n\t\tbreak;\n\t}\n\n\tintel_de_write(dev_priv, crt->adpa_reg, adpa);\n}\n\nstatic void intel_disable_crt(struct intel_atomic_state *state,\n\t\t\t      struct intel_encoder *encoder,\n\t\t\t      const struct intel_crtc_state *old_crtc_state,\n\t\t\t      const struct drm_connector_state *old_conn_state)\n{\n\tintel_crt_set_dpms(encoder, old_crtc_state, DRM_MODE_DPMS_OFF);\n}\n\nstatic void pch_disable_crt(struct intel_atomic_state *state,\n\t\t\t    struct intel_encoder *encoder,\n\t\t\t    const struct intel_crtc_state *old_crtc_state,\n\t\t\t    const struct drm_connector_state *old_conn_state)\n{\n}\n\nstatic void pch_post_disable_crt(struct intel_atomic_state *state,\n\t\t\t\t struct intel_encoder *encoder,\n\t\t\t\t const struct intel_crtc_state *old_crtc_state,\n\t\t\t\t const struct drm_connector_state *old_conn_state)\n{\n\tintel_disable_crt(state, encoder, old_crtc_state, old_conn_state);\n}\n\nstatic void hsw_disable_crt(struct intel_atomic_state *state,\n\t\t\t    struct intel_encoder *encoder,\n\t\t\t    const struct intel_crtc_state *old_crtc_state,\n\t\t\t    const struct drm_connector_state *old_conn_state)\n{\n\tstruct drm_i915_private *dev_priv = to_i915(encoder->base.dev);\n\n\tdrm_WARN_ON(&dev_priv->drm, !old_crtc_state->has_pch_encoder);\n\n\tintel_set_pch_fifo_underrun_reporting(dev_priv, PIPE_A, false);\n}\n\nstatic void hsw_post_disable_crt(struct intel_atomic_state *state,\n\t\t\t\t struct intel_encoder *encoder,\n\t\t\t\t const struct intel_crtc_state *old_crtc_state,\n\t\t\t\t const struct drm_connector_state *old_conn_state)\n{\n\tstruct intel_crtc *crtc = to_intel_crtc(old_crtc_state->uapi.crtc);\n\tstruct drm_i915_private *dev_priv = to_i915(encoder->base.dev);\n\n\tintel_crtc_vblank_off(old_crtc_state);\n\n\tintel_disable_transcoder(old_crtc_state);\n\n\tintel_ddi_disable_transcoder_func(old_crtc_state);\n\n\tilk_pfit_disable(old_crtc_state);\n\n\tintel_ddi_disable_transcoder_clock(old_crtc_state);\n\n\tpch_post_disable_crt(state, encoder, old_crtc_state, old_conn_state);\n\n\tlpt_pch_disable(state, crtc);\n\n\thsw_fdi_disable(encoder);\n\n\tdrm_WARN_ON(&dev_priv->drm, !old_crtc_state->has_pch_encoder);\n\n\tintel_set_pch_fifo_underrun_reporting(dev_priv, PIPE_A, true);\n}\n\nstatic void hsw_pre_pll_enable_crt(struct intel_atomic_state *state,\n\t\t\t\t   struct intel_encoder *encoder,\n\t\t\t\t   const struct intel_crtc_state *crtc_state,\n\t\t\t\t   const struct drm_connector_state *conn_state)\n{\n\tstruct drm_i915_private *dev_priv = to_i915(encoder->base.dev);\n\n\tdrm_WARN_ON(&dev_priv->drm, !crtc_state->has_pch_encoder);\n\n\tintel_set_pch_fifo_underrun_reporting(dev_priv, PIPE_A, false);\n}\n\nstatic void hsw_pre_enable_crt(struct intel_atomic_state *state,\n\t\t\t       struct intel_encoder *encoder,\n\t\t\t       const struct intel_crtc_state *crtc_state,\n\t\t\t       const struct drm_connector_state *conn_state)\n{\n\tstruct drm_i915_private *dev_priv = to_i915(encoder->base.dev);\n\tstruct intel_crtc *crtc = to_intel_crtc(crtc_state->uapi.crtc);\n\tenum pipe pipe = crtc->pipe;\n\n\tdrm_WARN_ON(&dev_priv->drm, !crtc_state->has_pch_encoder);\n\n\tintel_set_cpu_fifo_underrun_reporting(dev_priv, pipe, false);\n\n\thsw_fdi_link_train(encoder, crtc_state);\n\n\tintel_ddi_enable_transcoder_clock(encoder, crtc_state);\n}\n\nstatic void hsw_enable_crt(struct intel_atomic_state *state,\n\t\t\t   struct intel_encoder *encoder,\n\t\t\t   const struct intel_crtc_state *crtc_state,\n\t\t\t   const struct drm_connector_state *conn_state)\n{\n\tstruct drm_i915_private *dev_priv = to_i915(encoder->base.dev);\n\tstruct intel_crtc *crtc = to_intel_crtc(crtc_state->uapi.crtc);\n\tenum pipe pipe = crtc->pipe;\n\n\tdrm_WARN_ON(&dev_priv->drm, !crtc_state->has_pch_encoder);\n\n\tintel_ddi_enable_transcoder_func(encoder, crtc_state);\n\n\tintel_enable_transcoder(crtc_state);\n\n\tlpt_pch_enable(state, crtc);\n\n\tintel_crtc_vblank_on(crtc_state);\n\n\tintel_crt_set_dpms(encoder, crtc_state, DRM_MODE_DPMS_ON);\n\n\tintel_crtc_wait_for_next_vblank(crtc);\n\tintel_crtc_wait_for_next_vblank(crtc);\n\tintel_set_cpu_fifo_underrun_reporting(dev_priv, pipe, true);\n\tintel_set_pch_fifo_underrun_reporting(dev_priv, PIPE_A, true);\n}\n\nstatic void intel_enable_crt(struct intel_atomic_state *state,\n\t\t\t     struct intel_encoder *encoder,\n\t\t\t     const struct intel_crtc_state *crtc_state,\n\t\t\t     const struct drm_connector_state *conn_state)\n{\n\tintel_crt_set_dpms(encoder, crtc_state, DRM_MODE_DPMS_ON);\n}\n\nstatic enum drm_mode_status\nintel_crt_mode_valid(struct drm_connector *connector,\n\t\t     struct drm_display_mode *mode)\n{\n\tstruct drm_device *dev = connector->dev;\n\tstruct drm_i915_private *dev_priv = to_i915(dev);\n\tint max_dotclk = dev_priv->max_dotclk_freq;\n\tenum drm_mode_status status;\n\tint max_clock;\n\n\tstatus = intel_cpu_transcoder_mode_valid(dev_priv, mode);\n\tif (status != MODE_OK)\n\t\treturn status;\n\n\tif (mode->flags & DRM_MODE_FLAG_DBLSCAN)\n\t\treturn MODE_NO_DBLESCAN;\n\n\tif (mode->clock < 25000)\n\t\treturn MODE_CLOCK_LOW;\n\n\tif (HAS_PCH_LPT(dev_priv))\n\t\tmax_clock = 180000;\n\telse if (IS_VALLEYVIEW(dev_priv))\n\t\t \n\t\tmax_clock = 270000;\n\telse if (IS_DISPLAY_VER(dev_priv, 3, 4))\n\t\tmax_clock = 400000;\n\telse\n\t\tmax_clock = 350000;\n\tif (mode->clock > max_clock)\n\t\treturn MODE_CLOCK_HIGH;\n\n\tif (mode->clock > max_dotclk)\n\t\treturn MODE_CLOCK_HIGH;\n\n\t \n\tif (HAS_PCH_LPT(dev_priv) &&\n\t    ilk_get_lanes_required(mode->clock, 270000, 24) > 2)\n\t\treturn MODE_CLOCK_HIGH;\n\n\t \n\tif (mode->hdisplay > 4096)\n\t\treturn MODE_H_ILLEGAL;\n\n\treturn MODE_OK;\n}\n\nstatic int intel_crt_compute_config(struct intel_encoder *encoder,\n\t\t\t\t    struct intel_crtc_state *pipe_config,\n\t\t\t\t    struct drm_connector_state *conn_state)\n{\n\tstruct drm_display_mode *adjusted_mode =\n\t\t&pipe_config->hw.adjusted_mode;\n\n\tif (adjusted_mode->flags & DRM_MODE_FLAG_DBLSCAN)\n\t\treturn -EINVAL;\n\n\tpipe_config->sink_format = INTEL_OUTPUT_FORMAT_RGB;\n\tpipe_config->output_format = INTEL_OUTPUT_FORMAT_RGB;\n\n\treturn 0;\n}\n\nstatic int pch_crt_compute_config(struct intel_encoder *encoder,\n\t\t\t\t  struct intel_crtc_state *pipe_config,\n\t\t\t\t  struct drm_connector_state *conn_state)\n{\n\tstruct drm_display_mode *adjusted_mode =\n\t\t&pipe_config->hw.adjusted_mode;\n\n\tif (adjusted_mode->flags & DRM_MODE_FLAG_DBLSCAN)\n\t\treturn -EINVAL;\n\n\tpipe_config->has_pch_encoder = true;\n\tpipe_config->output_format = INTEL_OUTPUT_FORMAT_RGB;\n\n\treturn 0;\n}\n\nstatic int hsw_crt_compute_config(struct intel_encoder *encoder,\n\t\t\t\t  struct intel_crtc_state *pipe_config,\n\t\t\t\t  struct drm_connector_state *conn_state)\n{\n\tstruct drm_i915_private *dev_priv = to_i915(encoder->base.dev);\n\tstruct drm_display_mode *adjusted_mode =\n\t\t&pipe_config->hw.adjusted_mode;\n\n\tif (adjusted_mode->flags & DRM_MODE_FLAG_DBLSCAN)\n\t\treturn -EINVAL;\n\n\t \n\tif (adjusted_mode->crtc_hdisplay > 4096 ||\n\t    adjusted_mode->crtc_hblank_start > 4096)\n\t\treturn -EINVAL;\n\n\tpipe_config->has_pch_encoder = true;\n\tpipe_config->output_format = INTEL_OUTPUT_FORMAT_RGB;\n\n\t \n\tif (HAS_PCH_LPT(dev_priv)) {\n\t\tif (pipe_config->bw_constrained && pipe_config->pipe_bpp < 24) {\n\t\t\tdrm_dbg_kms(&dev_priv->drm,\n\t\t\t\t    \"LPT only supports 24bpp\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tpipe_config->pipe_bpp = 24;\n\t}\n\n\t \n\tpipe_config->port_clock = 135000 * 2;\n\n\tpipe_config->enhanced_framing = true;\n\n\tadjusted_mode->crtc_clock = lpt_iclkip(pipe_config);\n\n\treturn 0;\n}\n\nstatic bool ilk_crt_detect_hotplug(struct drm_connector *connector)\n{\n\tstruct drm_device *dev = connector->dev;\n\tstruct intel_crt *crt = intel_attached_crt(to_intel_connector(connector));\n\tstruct drm_i915_private *dev_priv = to_i915(dev);\n\tu32 adpa;\n\tbool ret;\n\n\t \n\tif (crt->force_hotplug_required) {\n\t\tbool turn_off_dac = HAS_PCH_SPLIT(dev_priv);\n\t\tu32 save_adpa;\n\n\t\tcrt->force_hotplug_required = false;\n\n\t\tsave_adpa = adpa = intel_de_read(dev_priv, crt->adpa_reg);\n\t\tdrm_dbg_kms(&dev_priv->drm,\n\t\t\t    \"trigger hotplug detect cycle: adpa=0x%x\\n\", adpa);\n\n\t\tadpa |= ADPA_CRT_HOTPLUG_FORCE_TRIGGER;\n\t\tif (turn_off_dac)\n\t\t\tadpa &= ~ADPA_DAC_ENABLE;\n\n\t\tintel_de_write(dev_priv, crt->adpa_reg, adpa);\n\n\t\tif (intel_de_wait_for_clear(dev_priv,\n\t\t\t\t\t    crt->adpa_reg,\n\t\t\t\t\t    ADPA_CRT_HOTPLUG_FORCE_TRIGGER,\n\t\t\t\t\t    1000))\n\t\t\tdrm_dbg_kms(&dev_priv->drm,\n\t\t\t\t    \"timed out waiting for FORCE_TRIGGER\");\n\n\t\tif (turn_off_dac) {\n\t\t\tintel_de_write(dev_priv, crt->adpa_reg, save_adpa);\n\t\t\tintel_de_posting_read(dev_priv, crt->adpa_reg);\n\t\t}\n\t}\n\n\t \n\tadpa = intel_de_read(dev_priv, crt->adpa_reg);\n\tif ((adpa & ADPA_CRT_HOTPLUG_MONITOR_MASK) != 0)\n\t\tret = true;\n\telse\n\t\tret = false;\n\tdrm_dbg_kms(&dev_priv->drm, \"ironlake hotplug adpa=0x%x, result %d\\n\",\n\t\t    adpa, ret);\n\n\treturn ret;\n}\n\nstatic bool valleyview_crt_detect_hotplug(struct drm_connector *connector)\n{\n\tstruct drm_device *dev = connector->dev;\n\tstruct intel_crt *crt = intel_attached_crt(to_intel_connector(connector));\n\tstruct drm_i915_private *dev_priv = to_i915(dev);\n\tbool reenable_hpd;\n\tu32 adpa;\n\tbool ret;\n\tu32 save_adpa;\n\n\t \n\treenable_hpd = intel_hpd_disable(dev_priv, crt->base.hpd_pin);\n\n\tsave_adpa = adpa = intel_de_read(dev_priv, crt->adpa_reg);\n\tdrm_dbg_kms(&dev_priv->drm,\n\t\t    \"trigger hotplug detect cycle: adpa=0x%x\\n\", adpa);\n\n\tadpa |= ADPA_CRT_HOTPLUG_FORCE_TRIGGER;\n\n\tintel_de_write(dev_priv, crt->adpa_reg, adpa);\n\n\tif (intel_de_wait_for_clear(dev_priv, crt->adpa_reg,\n\t\t\t\t    ADPA_CRT_HOTPLUG_FORCE_TRIGGER, 1000)) {\n\t\tdrm_dbg_kms(&dev_priv->drm,\n\t\t\t    \"timed out waiting for FORCE_TRIGGER\");\n\t\tintel_de_write(dev_priv, crt->adpa_reg, save_adpa);\n\t}\n\n\t \n\tadpa = intel_de_read(dev_priv, crt->adpa_reg);\n\tif ((adpa & ADPA_CRT_HOTPLUG_MONITOR_MASK) != 0)\n\t\tret = true;\n\telse\n\t\tret = false;\n\n\tdrm_dbg_kms(&dev_priv->drm,\n\t\t    \"valleyview hotplug adpa=0x%x, result %d\\n\", adpa, ret);\n\n\tif (reenable_hpd)\n\t\tintel_hpd_enable(dev_priv, crt->base.hpd_pin);\n\n\treturn ret;\n}\n\nstatic bool intel_crt_detect_hotplug(struct drm_connector *connector)\n{\n\tstruct drm_device *dev = connector->dev;\n\tstruct drm_i915_private *dev_priv = to_i915(dev);\n\tu32 stat;\n\tbool ret = false;\n\tint i, tries = 0;\n\n\tif (HAS_PCH_SPLIT(dev_priv))\n\t\treturn ilk_crt_detect_hotplug(connector);\n\n\tif (IS_VALLEYVIEW(dev_priv))\n\t\treturn valleyview_crt_detect_hotplug(connector);\n\n\t \n\n\tif (IS_G45(dev_priv))\n\t\ttries = 2;\n\telse\n\t\ttries = 1;\n\n\tfor (i = 0; i < tries ; i++) {\n\t\t \n\t\ti915_hotplug_interrupt_update(dev_priv,\n\t\t\t\t\t      CRT_HOTPLUG_FORCE_DETECT,\n\t\t\t\t\t      CRT_HOTPLUG_FORCE_DETECT);\n\t\t \n\t\tif (intel_de_wait_for_clear(dev_priv, PORT_HOTPLUG_EN,\n\t\t\t\t\t    CRT_HOTPLUG_FORCE_DETECT, 1000))\n\t\t\tdrm_dbg_kms(&dev_priv->drm,\n\t\t\t\t    \"timed out waiting for FORCE_DETECT to go off\");\n\t}\n\n\tstat = intel_de_read(dev_priv, PORT_HOTPLUG_STAT);\n\tif ((stat & CRT_HOTPLUG_MONITOR_MASK) != CRT_HOTPLUG_MONITOR_NONE)\n\t\tret = true;\n\n\t \n\tintel_de_write(dev_priv, PORT_HOTPLUG_STAT, CRT_HOTPLUG_INT_STATUS);\n\n\ti915_hotplug_interrupt_update(dev_priv, CRT_HOTPLUG_FORCE_DETECT, 0);\n\n\treturn ret;\n}\n\nstatic const struct drm_edid *intel_crt_get_edid(struct drm_connector *connector,\n\t\t\t\t\t\t struct i2c_adapter *i2c)\n{\n\tconst struct drm_edid *drm_edid;\n\n\tdrm_edid = drm_edid_read_ddc(connector, i2c);\n\n\tif (!drm_edid && !intel_gmbus_is_forced_bit(i2c)) {\n\t\tdrm_dbg_kms(connector->dev,\n\t\t\t    \"CRT GMBUS EDID read failed, retry using GPIO bit-banging\\n\");\n\t\tintel_gmbus_force_bit(i2c, true);\n\t\tdrm_edid = drm_edid_read_ddc(connector, i2c);\n\t\tintel_gmbus_force_bit(i2c, false);\n\t}\n\n\treturn drm_edid;\n}\n\n \nstatic int intel_crt_ddc_get_modes(struct drm_connector *connector,\n\t\t\t\tstruct i2c_adapter *adapter)\n{\n\tconst struct drm_edid *drm_edid;\n\tint ret;\n\n\tdrm_edid = intel_crt_get_edid(connector, adapter);\n\tif (!drm_edid)\n\t\treturn 0;\n\n\tret = intel_connector_update_modes(connector, drm_edid);\n\n\tdrm_edid_free(drm_edid);\n\n\treturn ret;\n}\n\nstatic bool intel_crt_detect_ddc(struct drm_connector *connector)\n{\n\tstruct intel_crt *crt = intel_attached_crt(to_intel_connector(connector));\n\tstruct drm_i915_private *dev_priv = to_i915(crt->base.base.dev);\n\tconst struct drm_edid *drm_edid;\n\tstruct i2c_adapter *i2c;\n\tbool ret = false;\n\n\ti2c = intel_gmbus_get_adapter(dev_priv, dev_priv->display.vbt.crt_ddc_pin);\n\tdrm_edid = intel_crt_get_edid(connector, i2c);\n\n\tif (drm_edid) {\n\t\tconst struct edid *edid = drm_edid_raw(drm_edid);\n\t\tbool is_digital = edid->input & DRM_EDID_INPUT_DIGITAL;\n\n\t\t \n\t\tif (!is_digital) {\n\t\t\tdrm_dbg_kms(&dev_priv->drm,\n\t\t\t\t    \"CRT detected via DDC:0x50 [EDID]\\n\");\n\t\t\tret = true;\n\t\t} else {\n\t\t\tdrm_dbg_kms(&dev_priv->drm,\n\t\t\t\t    \"CRT not detected via DDC:0x50 [EDID reports a digital panel]\\n\");\n\t\t}\n\t} else {\n\t\tdrm_dbg_kms(&dev_priv->drm,\n\t\t\t    \"CRT not detected via DDC:0x50 [no valid EDID found]\\n\");\n\t}\n\n\tdrm_edid_free(drm_edid);\n\n\treturn ret;\n}\n\nstatic enum drm_connector_status\nintel_crt_load_detect(struct intel_crt *crt, enum pipe pipe)\n{\n\tstruct drm_device *dev = crt->base.base.dev;\n\tstruct drm_i915_private *dev_priv = to_i915(dev);\n\tenum transcoder cpu_transcoder = (enum transcoder)pipe;\n\tu32 save_bclrpat;\n\tu32 save_vtotal;\n\tu32 vtotal, vactive;\n\tu32 vsample;\n\tu32 vblank, vblank_start, vblank_end;\n\tu32 dsl;\n\tu8 st00;\n\tenum drm_connector_status status;\n\n\tdrm_dbg_kms(&dev_priv->drm, \"starting load-detect on CRT\\n\");\n\n\tsave_bclrpat = intel_de_read(dev_priv, BCLRPAT(cpu_transcoder));\n\tsave_vtotal = intel_de_read(dev_priv, TRANS_VTOTAL(cpu_transcoder));\n\tvblank = intel_de_read(dev_priv, TRANS_VBLANK(cpu_transcoder));\n\n\tvtotal = REG_FIELD_GET(VTOTAL_MASK, save_vtotal) + 1;\n\tvactive = REG_FIELD_GET(VACTIVE_MASK, save_vtotal) + 1;\n\n\tvblank_start = REG_FIELD_GET(VBLANK_START_MASK, vblank) + 1;\n\tvblank_end = REG_FIELD_GET(VBLANK_END_MASK, vblank) + 1;\n\n\t \n\tintel_de_write(dev_priv, BCLRPAT(cpu_transcoder), 0x500050);\n\n\tif (DISPLAY_VER(dev_priv) != 2) {\n\t\tu32 transconf = intel_de_read(dev_priv, TRANSCONF(cpu_transcoder));\n\n\t\tintel_de_write(dev_priv, TRANSCONF(cpu_transcoder),\n\t\t\t       transconf | TRANSCONF_FORCE_BORDER);\n\t\tintel_de_posting_read(dev_priv, TRANSCONF(cpu_transcoder));\n\t\t \n\t\tintel_crtc_wait_for_next_vblank(intel_crtc_for_pipe(dev_priv, pipe));\n\t\tst00 = intel_de_read8(dev_priv, _VGA_MSR_WRITE);\n\t\tstatus = ((st00 & (1 << 4)) != 0) ?\n\t\t\tconnector_status_connected :\n\t\t\tconnector_status_disconnected;\n\n\t\tintel_de_write(dev_priv, TRANSCONF(cpu_transcoder), transconf);\n\t} else {\n\t\tbool restore_vblank = false;\n\t\tint count, detect;\n\n\t\t \n\t\tif (vblank_start <= vactive && vblank_end >= vtotal) {\n\t\t\tu32 vsync = intel_de_read(dev_priv, TRANS_VSYNC(cpu_transcoder));\n\t\t\tu32 vsync_start = REG_FIELD_GET(VSYNC_START_MASK, vsync) + 1;\n\n\t\t\tvblank_start = vsync_start;\n\t\t\tintel_de_write(dev_priv, TRANS_VBLANK(cpu_transcoder),\n\t\t\t\t       VBLANK_START(vblank_start - 1) |\n\t\t\t\t       VBLANK_END(vblank_end - 1));\n\t\t\trestore_vblank = true;\n\t\t}\n\t\t \n\t\tif (vblank_start - vactive >= vtotal - vblank_end)\n\t\t\tvsample = (vblank_start + vactive) >> 1;\n\t\telse\n\t\t\tvsample = (vtotal + vblank_end) >> 1;\n\n\t\t \n\t\twhile (intel_de_read(dev_priv, PIPEDSL(pipe)) >= vactive)\n\t\t\t;\n\t\twhile ((dsl = intel_de_read(dev_priv, PIPEDSL(pipe))) <= vsample)\n\t\t\t;\n\t\t \n\t\tdetect = 0;\n\t\tcount = 0;\n\t\tdo {\n\t\t\tcount++;\n\t\t\t \n\t\t\tst00 = intel_de_read8(dev_priv, _VGA_MSR_WRITE);\n\t\t\tif (st00 & (1 << 4))\n\t\t\t\tdetect++;\n\t\t} while ((intel_de_read(dev_priv, PIPEDSL(pipe)) == dsl));\n\n\t\t \n\t\tif (restore_vblank)\n\t\t\tintel_de_write(dev_priv, TRANS_VBLANK(cpu_transcoder), vblank);\n\t\t \n\t\tstatus = detect * 4 > count * 3 ?\n\t\t\t connector_status_connected :\n\t\t\t connector_status_disconnected;\n\t}\n\n\t \n\tintel_de_write(dev_priv, BCLRPAT(cpu_transcoder), save_bclrpat);\n\n\treturn status;\n}\n\nstatic int intel_spurious_crt_detect_dmi_callback(const struct dmi_system_id *id)\n{\n\tDRM_DEBUG_DRIVER(\"Skipping CRT detection for %s\\n\", id->ident);\n\treturn 1;\n}\n\nstatic const struct dmi_system_id intel_spurious_crt_detect[] = {\n\t{\n\t\t.callback = intel_spurious_crt_detect_dmi_callback,\n\t\t.ident = \"ACER ZGB\",\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"ACER\"),\n\t\t\tDMI_MATCH(DMI_PRODUCT_NAME, \"ZGB\"),\n\t\t},\n\t},\n\t{\n\t\t.callback = intel_spurious_crt_detect_dmi_callback,\n\t\t.ident = \"Intel DZ77BH-55K\",\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_BOARD_VENDOR, \"Intel Corporation\"),\n\t\t\tDMI_MATCH(DMI_BOARD_NAME, \"DZ77BH-55K\"),\n\t\t},\n\t},\n\t{ }\n};\n\nstatic int\nintel_crt_detect(struct drm_connector *connector,\n\t\t struct drm_modeset_acquire_ctx *ctx,\n\t\t bool force)\n{\n\tstruct drm_i915_private *dev_priv = to_i915(connector->dev);\n\tstruct intel_crt *crt = intel_attached_crt(to_intel_connector(connector));\n\tstruct intel_encoder *intel_encoder = &crt->base;\n\tstruct drm_atomic_state *state;\n\tintel_wakeref_t wakeref;\n\tint status;\n\n\tdrm_dbg_kms(&dev_priv->drm, \"[CONNECTOR:%d:%s] force=%d\\n\",\n\t\t    connector->base.id, connector->name,\n\t\t    force);\n\n\tif (!INTEL_DISPLAY_ENABLED(dev_priv))\n\t\treturn connector_status_disconnected;\n\n\tif (dev_priv->params.load_detect_test) {\n\t\twakeref = intel_display_power_get(dev_priv,\n\t\t\t\t\t\t  intel_encoder->power_domain);\n\t\tgoto load_detect;\n\t}\n\n\t \n\tif (dmi_check_system(intel_spurious_crt_detect))\n\t\treturn connector_status_disconnected;\n\n\twakeref = intel_display_power_get(dev_priv,\n\t\t\t\t\t  intel_encoder->power_domain);\n\n\tif (I915_HAS_HOTPLUG(dev_priv)) {\n\t\t \n\t\tif (intel_crt_detect_hotplug(connector)) {\n\t\t\tdrm_dbg_kms(&dev_priv->drm,\n\t\t\t\t    \"CRT detected via hotplug\\n\");\n\t\t\tstatus = connector_status_connected;\n\t\t\tgoto out;\n\t\t} else\n\t\t\tdrm_dbg_kms(&dev_priv->drm,\n\t\t\t\t    \"CRT not detected via hotplug\\n\");\n\t}\n\n\tif (intel_crt_detect_ddc(connector)) {\n\t\tstatus = connector_status_connected;\n\t\tgoto out;\n\t}\n\n\t \n\tif (I915_HAS_HOTPLUG(dev_priv)) {\n\t\tstatus = connector_status_disconnected;\n\t\tgoto out;\n\t}\n\nload_detect:\n\tif (!force) {\n\t\tstatus = connector->status;\n\t\tgoto out;\n\t}\n\n\t \n\tstate = intel_load_detect_get_pipe(connector, ctx);\n\tif (IS_ERR(state)) {\n\t\tstatus = PTR_ERR(state);\n\t} else if (!state) {\n\t\tstatus = connector_status_unknown;\n\t} else {\n\t\tif (intel_crt_detect_ddc(connector))\n\t\t\tstatus = connector_status_connected;\n\t\telse if (DISPLAY_VER(dev_priv) < 4)\n\t\t\tstatus = intel_crt_load_detect(crt,\n\t\t\t\tto_intel_crtc(connector->state->crtc)->pipe);\n\t\telse if (dev_priv->params.load_detect_test)\n\t\t\tstatus = connector_status_disconnected;\n\t\telse\n\t\t\tstatus = connector_status_unknown;\n\t\tintel_load_detect_release_pipe(connector, state, ctx);\n\t}\n\nout:\n\tintel_display_power_put(dev_priv, intel_encoder->power_domain, wakeref);\n\n\t \n\tintel_display_power_flush_work(dev_priv);\n\n\treturn status;\n}\n\nstatic int intel_crt_get_modes(struct drm_connector *connector)\n{\n\tstruct drm_device *dev = connector->dev;\n\tstruct drm_i915_private *dev_priv = to_i915(dev);\n\tstruct intel_crt *crt = intel_attached_crt(to_intel_connector(connector));\n\tstruct intel_encoder *intel_encoder = &crt->base;\n\tintel_wakeref_t wakeref;\n\tstruct i2c_adapter *i2c;\n\tint ret;\n\n\twakeref = intel_display_power_get(dev_priv,\n\t\t\t\t\t  intel_encoder->power_domain);\n\n\ti2c = intel_gmbus_get_adapter(dev_priv, dev_priv->display.vbt.crt_ddc_pin);\n\tret = intel_crt_ddc_get_modes(connector, i2c);\n\tif (ret || !IS_G4X(dev_priv))\n\t\tgoto out;\n\n\t \n\ti2c = intel_gmbus_get_adapter(dev_priv, GMBUS_PIN_DPB);\n\tret = intel_crt_ddc_get_modes(connector, i2c);\n\nout:\n\tintel_display_power_put(dev_priv, intel_encoder->power_domain, wakeref);\n\n\treturn ret;\n}\n\nvoid intel_crt_reset(struct drm_encoder *encoder)\n{\n\tstruct drm_i915_private *dev_priv = to_i915(encoder->dev);\n\tstruct intel_crt *crt = intel_encoder_to_crt(to_intel_encoder(encoder));\n\n\tif (DISPLAY_VER(dev_priv) >= 5) {\n\t\tu32 adpa;\n\n\t\tadpa = intel_de_read(dev_priv, crt->adpa_reg);\n\t\tadpa &= ~ADPA_CRT_HOTPLUG_MASK;\n\t\tadpa |= ADPA_HOTPLUG_BITS;\n\t\tintel_de_write(dev_priv, crt->adpa_reg, adpa);\n\t\tintel_de_posting_read(dev_priv, crt->adpa_reg);\n\n\t\tdrm_dbg_kms(&dev_priv->drm, \"crt adpa set to 0x%x\\n\", adpa);\n\t\tcrt->force_hotplug_required = true;\n\t}\n\n}\n\n \n\nstatic const struct drm_connector_funcs intel_crt_connector_funcs = {\n\t.fill_modes = drm_helper_probe_single_connector_modes,\n\t.late_register = intel_connector_register,\n\t.early_unregister = intel_connector_unregister,\n\t.destroy = intel_connector_destroy,\n\t.atomic_destroy_state = drm_atomic_helper_connector_destroy_state,\n\t.atomic_duplicate_state = drm_atomic_helper_connector_duplicate_state,\n};\n\nstatic const struct drm_connector_helper_funcs intel_crt_connector_helper_funcs = {\n\t.detect_ctx = intel_crt_detect,\n\t.mode_valid = intel_crt_mode_valid,\n\t.get_modes = intel_crt_get_modes,\n};\n\nstatic const struct drm_encoder_funcs intel_crt_enc_funcs = {\n\t.reset = intel_crt_reset,\n\t.destroy = intel_encoder_destroy,\n};\n\nvoid intel_crt_init(struct drm_i915_private *dev_priv)\n{\n\tstruct drm_connector *connector;\n\tstruct intel_crt *crt;\n\tstruct intel_connector *intel_connector;\n\ti915_reg_t adpa_reg;\n\tu32 adpa;\n\n\tif (HAS_PCH_SPLIT(dev_priv))\n\t\tadpa_reg = PCH_ADPA;\n\telse if (IS_VALLEYVIEW(dev_priv))\n\t\tadpa_reg = VLV_ADPA;\n\telse\n\t\tadpa_reg = ADPA;\n\n\tadpa = intel_de_read(dev_priv, adpa_reg);\n\tif ((adpa & ADPA_DAC_ENABLE) == 0) {\n\t\t \n\t\tintel_de_write(dev_priv, adpa_reg,\n\t\t\t       adpa | ADPA_DAC_ENABLE | ADPA_HSYNC_CNTL_DISABLE | ADPA_VSYNC_CNTL_DISABLE);\n\t\tif ((intel_de_read(dev_priv, adpa_reg) & ADPA_DAC_ENABLE) == 0)\n\t\t\treturn;\n\t\tintel_de_write(dev_priv, adpa_reg, adpa);\n\t}\n\n\tcrt = kzalloc(sizeof(struct intel_crt), GFP_KERNEL);\n\tif (!crt)\n\t\treturn;\n\n\tintel_connector = intel_connector_alloc();\n\tif (!intel_connector) {\n\t\tkfree(crt);\n\t\treturn;\n\t}\n\n\tconnector = &intel_connector->base;\n\tcrt->connector = intel_connector;\n\tdrm_connector_init(&dev_priv->drm, &intel_connector->base,\n\t\t\t   &intel_crt_connector_funcs, DRM_MODE_CONNECTOR_VGA);\n\n\tdrm_encoder_init(&dev_priv->drm, &crt->base.base, &intel_crt_enc_funcs,\n\t\t\t DRM_MODE_ENCODER_DAC, \"CRT\");\n\n\tintel_connector_attach_encoder(intel_connector, &crt->base);\n\n\tcrt->base.type = INTEL_OUTPUT_ANALOG;\n\tcrt->base.cloneable = BIT(INTEL_OUTPUT_DVO) | BIT(INTEL_OUTPUT_HDMI);\n\tif (IS_I830(dev_priv))\n\t\tcrt->base.pipe_mask = BIT(PIPE_A);\n\telse\n\t\tcrt->base.pipe_mask = ~0;\n\n\tif (DISPLAY_VER(dev_priv) != 2)\n\t\tconnector->interlace_allowed = true;\n\n\tcrt->adpa_reg = adpa_reg;\n\n\tcrt->base.power_domain = POWER_DOMAIN_PORT_CRT;\n\n\tif (I915_HAS_HOTPLUG(dev_priv) &&\n\t    !dmi_check_system(intel_spurious_crt_detect)) {\n\t\tcrt->base.hpd_pin = HPD_CRT;\n\t\tcrt->base.hotplug = intel_encoder_hotplug;\n\t\tintel_connector->polled = DRM_CONNECTOR_POLL_HPD;\n\t} else {\n\t\tintel_connector->polled = DRM_CONNECTOR_POLL_CONNECT;\n\t}\n\n\tif (HAS_DDI(dev_priv)) {\n\t\tassert_port_valid(dev_priv, PORT_E);\n\n\t\tcrt->base.port = PORT_E;\n\t\tcrt->base.get_config = hsw_crt_get_config;\n\t\tcrt->base.get_hw_state = intel_ddi_get_hw_state;\n\t\tcrt->base.compute_config = hsw_crt_compute_config;\n\t\tcrt->base.pre_pll_enable = hsw_pre_pll_enable_crt;\n\t\tcrt->base.pre_enable = hsw_pre_enable_crt;\n\t\tcrt->base.enable = hsw_enable_crt;\n\t\tcrt->base.disable = hsw_disable_crt;\n\t\tcrt->base.post_disable = hsw_post_disable_crt;\n\t\tcrt->base.enable_clock = hsw_ddi_enable_clock;\n\t\tcrt->base.disable_clock = hsw_ddi_disable_clock;\n\t\tcrt->base.is_clock_enabled = hsw_ddi_is_clock_enabled;\n\n\t\tintel_ddi_buf_trans_init(&crt->base);\n\t} else {\n\t\tif (HAS_PCH_SPLIT(dev_priv)) {\n\t\t\tcrt->base.compute_config = pch_crt_compute_config;\n\t\t\tcrt->base.disable = pch_disable_crt;\n\t\t\tcrt->base.post_disable = pch_post_disable_crt;\n\t\t} else {\n\t\t\tcrt->base.compute_config = intel_crt_compute_config;\n\t\t\tcrt->base.disable = intel_disable_crt;\n\t\t}\n\t\tcrt->base.port = PORT_NONE;\n\t\tcrt->base.get_config = intel_crt_get_config;\n\t\tcrt->base.get_hw_state = intel_crt_get_hw_state;\n\t\tcrt->base.enable = intel_enable_crt;\n\t}\n\tintel_connector->get_hw_state = intel_connector_get_hw_state;\n\n\tdrm_connector_helper_add(connector, &intel_crt_connector_helper_funcs);\n\n\t \n\tif (HAS_PCH_LPT(dev_priv)) {\n\t\tu32 fdi_config = FDI_RX_POLARITY_REVERSED_LPT |\n\t\t\t\t FDI_RX_LINK_REVERSAL_OVERRIDE;\n\n\t\tdev_priv->display.fdi.rx_config = intel_de_read(dev_priv,\n\t\t\t\t\t\t\t\tFDI_RX_CTL(PIPE_A)) & fdi_config;\n\t}\n\n\tintel_crt_reset(&crt->base.base);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}