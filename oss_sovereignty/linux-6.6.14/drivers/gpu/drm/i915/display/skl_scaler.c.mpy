{
  "module_name": "skl_scaler.c",
  "hash_id": "122bd7d6c110252486f08296b1416bda5dc2255d4ba2b7780f3d338c486eb703",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/i915/display/skl_scaler.c",
  "human_readable_source": "\n \n\n#include \"i915_reg.h\"\n#include \"intel_de.h\"\n#include \"intel_display_types.h\"\n#include \"intel_fb.h\"\n#include \"skl_scaler.h\"\n#include \"skl_universal_plane.h\"\n\n \nstatic u16 skl_scaler_calc_phase(int sub, int scale, bool chroma_cosited)\n{\n\tint phase = -0x8000;\n\tu16 trip = 0;\n\n\tif (chroma_cosited)\n\t\tphase += (sub - 1) * 0x8000 / sub;\n\n\tphase += scale / (2 * sub);\n\n\t \n\tWARN_ON(phase < -0x8000 || phase > 0x18000);\n\n\tif (phase < 0)\n\t\tphase = 0x10000 + phase;\n\telse\n\t\ttrip = PS_PHASE_TRIP;\n\n\treturn ((phase >> 2) & PS_PHASE_MASK) | trip;\n}\n\n#define SKL_MIN_SRC_W 8\n#define SKL_MAX_SRC_W 4096\n#define SKL_MIN_SRC_H 8\n#define SKL_MAX_SRC_H 4096\n#define SKL_MIN_DST_W 8\n#define SKL_MAX_DST_W 4096\n#define SKL_MIN_DST_H 8\n#define SKL_MAX_DST_H 4096\n#define ICL_MAX_SRC_W 5120\n#define ICL_MAX_SRC_H 4096\n#define ICL_MAX_DST_W 5120\n#define ICL_MAX_DST_H 4096\n#define TGL_MAX_SRC_W 5120\n#define TGL_MAX_SRC_H 8192\n#define TGL_MAX_DST_W 8192\n#define TGL_MAX_DST_H 8192\n#define MTL_MAX_SRC_W 4096\n#define MTL_MAX_SRC_H 8192\n#define MTL_MAX_DST_W 8192\n#define MTL_MAX_DST_H 8192\n#define SKL_MIN_YUV_420_SRC_W 16\n#define SKL_MIN_YUV_420_SRC_H 16\n\nstatic int\nskl_update_scaler(struct intel_crtc_state *crtc_state, bool force_detach,\n\t\t  unsigned int scaler_user, int *scaler_id,\n\t\t  int src_w, int src_h, int dst_w, int dst_h,\n\t\t  const struct drm_format_info *format,\n\t\t  u64 modifier, bool need_scaler)\n{\n\tstruct intel_crtc_scaler_state *scaler_state =\n\t\t&crtc_state->scaler_state;\n\tstruct intel_crtc *crtc = to_intel_crtc(crtc_state->uapi.crtc);\n\tstruct drm_i915_private *dev_priv = to_i915(crtc->base.dev);\n\tconst struct drm_display_mode *adjusted_mode =\n\t\t&crtc_state->hw.adjusted_mode;\n\tint pipe_src_w = drm_rect_width(&crtc_state->pipe_src);\n\tint pipe_src_h = drm_rect_height(&crtc_state->pipe_src);\n\tint min_src_w, min_src_h, min_dst_w, min_dst_h;\n\tint max_src_w, max_src_h, max_dst_w, max_dst_h;\n\n\t \n\tif (src_w != dst_w || src_h != dst_h)\n\t\tneed_scaler = true;\n\n\t \n\tif (DISPLAY_VER(dev_priv) >= 9 && crtc_state->hw.enable &&\n\t    need_scaler && adjusted_mode->flags & DRM_MODE_FLAG_INTERLACE) {\n\t\tdrm_dbg_kms(&dev_priv->drm,\n\t\t\t    \"Pipe/Plane scaling not supported with IF-ID mode\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (force_detach || !need_scaler) {\n\t\tif (*scaler_id >= 0) {\n\t\t\tscaler_state->scaler_users &= ~(1 << scaler_user);\n\t\t\tscaler_state->scalers[*scaler_id].in_use = 0;\n\n\t\t\tdrm_dbg_kms(&dev_priv->drm,\n\t\t\t\t    \"scaler_user index %u.%u: \"\n\t\t\t\t    \"Staged freeing scaler id %d scaler_users = 0x%x\\n\",\n\t\t\t\t    crtc->pipe, scaler_user, *scaler_id,\n\t\t\t\t    scaler_state->scaler_users);\n\t\t\t*scaler_id = -1;\n\t\t}\n\t\treturn 0;\n\t}\n\n\tif (format && intel_format_info_is_yuv_semiplanar(format, modifier) &&\n\t    (src_h < SKL_MIN_YUV_420_SRC_H || src_w < SKL_MIN_YUV_420_SRC_W)) {\n\t\tdrm_dbg_kms(&dev_priv->drm,\n\t\t\t    \"Planar YUV: src dimensions not met\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tmin_src_w = SKL_MIN_SRC_W;\n\tmin_src_h = SKL_MIN_SRC_H;\n\tmin_dst_w = SKL_MIN_DST_W;\n\tmin_dst_h = SKL_MIN_DST_H;\n\n\tif (DISPLAY_VER(dev_priv) < 11) {\n\t\tmax_src_w = SKL_MAX_SRC_W;\n\t\tmax_src_h = SKL_MAX_SRC_H;\n\t\tmax_dst_w = SKL_MAX_DST_W;\n\t\tmax_dst_h = SKL_MAX_DST_H;\n\t} else if (DISPLAY_VER(dev_priv) < 12) {\n\t\tmax_src_w = ICL_MAX_SRC_W;\n\t\tmax_src_h = ICL_MAX_SRC_H;\n\t\tmax_dst_w = ICL_MAX_DST_W;\n\t\tmax_dst_h = ICL_MAX_DST_H;\n\t} else if (DISPLAY_VER(dev_priv) < 14) {\n\t\tmax_src_w = TGL_MAX_SRC_W;\n\t\tmax_src_h = TGL_MAX_SRC_H;\n\t\tmax_dst_w = TGL_MAX_DST_W;\n\t\tmax_dst_h = TGL_MAX_DST_H;\n\t} else {\n\t\tmax_src_w = MTL_MAX_SRC_W;\n\t\tmax_src_h = MTL_MAX_SRC_H;\n\t\tmax_dst_w = MTL_MAX_DST_W;\n\t\tmax_dst_h = MTL_MAX_DST_H;\n\t}\n\n\t \n\tif (src_w < min_src_w || src_h < min_src_h ||\n\t    dst_w < min_dst_w || dst_h < min_dst_h ||\n\t    src_w > max_src_w || src_h > max_src_h ||\n\t    dst_w > max_dst_w || dst_h > max_dst_h) {\n\t\tdrm_dbg_kms(&dev_priv->drm,\n\t\t\t    \"scaler_user index %u.%u: src %ux%u dst %ux%u \"\n\t\t\t    \"size is out of scaler range\\n\",\n\t\t\t    crtc->pipe, scaler_user, src_w, src_h,\n\t\t\t    dst_w, dst_h);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (pipe_src_w > max_src_w || pipe_src_h > max_src_h) {\n\t\tdrm_dbg_kms(&dev_priv->drm,\n\t\t\t    \"scaler_user index %u.%u: pipe src size %ux%u \"\n\t\t\t    \"is out of scaler range\\n\",\n\t\t\t    crtc->pipe, scaler_user, pipe_src_w, pipe_src_h);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tscaler_state->scaler_users |= (1 << scaler_user);\n\tdrm_dbg_kms(&dev_priv->drm, \"scaler_user index %u.%u: \"\n\t\t    \"staged scaling request for %ux%u->%ux%u scaler_users = 0x%x\\n\",\n\t\t    crtc->pipe, scaler_user, src_w, src_h, dst_w, dst_h,\n\t\t    scaler_state->scaler_users);\n\n\treturn 0;\n}\n\nint skl_update_scaler_crtc(struct intel_crtc_state *crtc_state)\n{\n\tconst struct drm_display_mode *pipe_mode = &crtc_state->hw.pipe_mode;\n\tint width, height;\n\n\tif (crtc_state->pch_pfit.enabled) {\n\t\twidth = drm_rect_width(&crtc_state->pch_pfit.dst);\n\t\theight = drm_rect_height(&crtc_state->pch_pfit.dst);\n\t} else {\n\t\twidth = pipe_mode->crtc_hdisplay;\n\t\theight = pipe_mode->crtc_vdisplay;\n\t}\n\treturn skl_update_scaler(crtc_state, !crtc_state->hw.active,\n\t\t\t\t SKL_CRTC_INDEX,\n\t\t\t\t &crtc_state->scaler_state.scaler_id,\n\t\t\t\t drm_rect_width(&crtc_state->pipe_src),\n\t\t\t\t drm_rect_height(&crtc_state->pipe_src),\n\t\t\t\t width, height, NULL, 0,\n\t\t\t\t crtc_state->pch_pfit.enabled);\n}\n\n \nint skl_update_scaler_plane(struct intel_crtc_state *crtc_state,\n\t\t\t    struct intel_plane_state *plane_state)\n{\n\tstruct intel_plane *intel_plane =\n\t\tto_intel_plane(plane_state->uapi.plane);\n\tstruct drm_i915_private *dev_priv = to_i915(intel_plane->base.dev);\n\tstruct drm_framebuffer *fb = plane_state->hw.fb;\n\tint ret;\n\tbool force_detach = !fb || !plane_state->uapi.visible;\n\tbool need_scaler = false;\n\n\t \n\tif (!icl_is_hdr_plane(dev_priv, intel_plane->id) &&\n\t    fb && intel_format_info_is_yuv_semiplanar(fb->format, fb->modifier))\n\t\tneed_scaler = true;\n\n\tret = skl_update_scaler(crtc_state, force_detach,\n\t\t\t\tdrm_plane_index(&intel_plane->base),\n\t\t\t\t&plane_state->scaler_id,\n\t\t\t\tdrm_rect_width(&plane_state->uapi.src) >> 16,\n\t\t\t\tdrm_rect_height(&plane_state->uapi.src) >> 16,\n\t\t\t\tdrm_rect_width(&plane_state->uapi.dst),\n\t\t\t\tdrm_rect_height(&plane_state->uapi.dst),\n\t\t\t\tfb ? fb->format : NULL,\n\t\t\t\tfb ? fb->modifier : 0,\n\t\t\t\tneed_scaler);\n\n\tif (ret || plane_state->scaler_id < 0)\n\t\treturn ret;\n\n\t \n\tif (plane_state->ckey.flags) {\n\t\tdrm_dbg_kms(&dev_priv->drm,\n\t\t\t    \"[PLANE:%d:%s] scaling with color key not allowed\",\n\t\t\t    intel_plane->base.base.id,\n\t\t\t    intel_plane->base.name);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tswitch (fb->format->format) {\n\tcase DRM_FORMAT_RGB565:\n\tcase DRM_FORMAT_XBGR8888:\n\tcase DRM_FORMAT_XRGB8888:\n\tcase DRM_FORMAT_ABGR8888:\n\tcase DRM_FORMAT_ARGB8888:\n\tcase DRM_FORMAT_XRGB2101010:\n\tcase DRM_FORMAT_XBGR2101010:\n\tcase DRM_FORMAT_ARGB2101010:\n\tcase DRM_FORMAT_ABGR2101010:\n\tcase DRM_FORMAT_YUYV:\n\tcase DRM_FORMAT_YVYU:\n\tcase DRM_FORMAT_UYVY:\n\tcase DRM_FORMAT_VYUY:\n\tcase DRM_FORMAT_NV12:\n\tcase DRM_FORMAT_XYUV8888:\n\tcase DRM_FORMAT_P010:\n\tcase DRM_FORMAT_P012:\n\tcase DRM_FORMAT_P016:\n\tcase DRM_FORMAT_Y210:\n\tcase DRM_FORMAT_Y212:\n\tcase DRM_FORMAT_Y216:\n\tcase DRM_FORMAT_XVYU2101010:\n\tcase DRM_FORMAT_XVYU12_16161616:\n\tcase DRM_FORMAT_XVYU16161616:\n\t\tbreak;\n\tcase DRM_FORMAT_XBGR16161616F:\n\tcase DRM_FORMAT_ABGR16161616F:\n\tcase DRM_FORMAT_XRGB16161616F:\n\tcase DRM_FORMAT_ARGB16161616F:\n\t\tif (DISPLAY_VER(dev_priv) >= 11)\n\t\t\tbreak;\n\t\tfallthrough;\n\tdefault:\n\t\tdrm_dbg_kms(&dev_priv->drm,\n\t\t\t    \"[PLANE:%d:%s] FB:%d unsupported scaling format 0x%x\\n\",\n\t\t\t    intel_plane->base.base.id, intel_plane->base.name,\n\t\t\t    fb->base.id, fb->format->format);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int intel_atomic_setup_scaler(struct intel_crtc_scaler_state *scaler_state,\n\t\t\t\t     int num_scalers_need, struct intel_crtc *intel_crtc,\n\t\t\t\t     const char *name, int idx,\n\t\t\t\t     struct intel_plane_state *plane_state,\n\t\t\t\t     int *scaler_id)\n{\n\tstruct drm_i915_private *dev_priv = to_i915(intel_crtc->base.dev);\n\tint j;\n\tu32 mode;\n\n\tif (*scaler_id < 0) {\n\t\t \n\t\tfor (j = 0; j < intel_crtc->num_scalers; j++) {\n\t\t\tif (scaler_state->scalers[j].in_use)\n\t\t\t\tcontinue;\n\n\t\t\t*scaler_id = j;\n\t\t\tscaler_state->scalers[*scaler_id].in_use = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (drm_WARN(&dev_priv->drm, *scaler_id < 0,\n\t\t     \"Cannot find scaler for %s:%d\\n\", name, idx))\n\t\treturn -EINVAL;\n\n\t \n\tif (plane_state && plane_state->hw.fb &&\n\t    plane_state->hw.fb->format->is_yuv &&\n\t    plane_state->hw.fb->format->num_planes > 1) {\n\t\tstruct intel_plane *plane = to_intel_plane(plane_state->uapi.plane);\n\n\t\tif (DISPLAY_VER(dev_priv) == 9) {\n\t\t\tmode = SKL_PS_SCALER_MODE_NV12;\n\t\t} else if (icl_is_hdr_plane(dev_priv, plane->id)) {\n\t\t\t \n\t\t\tmode = PS_SCALER_MODE_NORMAL;\n\t\t} else {\n\t\t\tstruct intel_plane *linked =\n\t\t\t\tplane_state->planar_linked_plane;\n\n\t\t\tmode = PS_SCALER_MODE_PLANAR;\n\n\t\t\tif (linked)\n\t\t\t\tmode |= PS_BINDING_Y_PLANE(linked->id);\n\t\t}\n\t} else if (DISPLAY_VER(dev_priv) >= 10) {\n\t\tmode = PS_SCALER_MODE_NORMAL;\n\t} else if (num_scalers_need == 1 && intel_crtc->num_scalers > 1) {\n\t\t \n\t\tscaler_state->scalers[*scaler_id].in_use = 0;\n\t\t*scaler_id = 0;\n\t\tscaler_state->scalers[0].in_use = 1;\n\t\tmode = SKL_PS_SCALER_MODE_HQ;\n\t} else {\n\t\tmode = SKL_PS_SCALER_MODE_DYN;\n\t}\n\n\t \n\tif (plane_state && plane_state->hw.fb) {\n\t\tconst struct drm_framebuffer *fb = plane_state->hw.fb;\n\t\tconst struct drm_rect *src = &plane_state->uapi.src;\n\t\tconst struct drm_rect *dst = &plane_state->uapi.dst;\n\t\tint hscale, vscale, max_vscale, max_hscale;\n\n\t\t \n\n\t\tif (DISPLAY_VER(dev_priv) >= 14) {\n\t\t\t \n\t\t\tmax_hscale = 0x30000 - 1;\n\t\t\tif (*scaler_id == 0)\n\t\t\t\tmax_vscale = 0x30000 - 1;\n\t\t\telse\n\t\t\t\tmax_vscale = 0x10000;\n\n\t\t} else if (DISPLAY_VER(dev_priv) >= 10 ||\n\t\t\t   !intel_format_info_is_yuv_semiplanar(fb->format, fb->modifier)) {\n\t\t\tmax_hscale = 0x30000 - 1;\n\t\t\tmax_vscale = 0x30000 - 1;\n\t\t} else {\n\t\t\tmax_hscale = 0x20000 - 1;\n\t\t\tmax_vscale = 0x20000 - 1;\n\t\t}\n\n\t\t \n\n\t\t \n\t\thscale = drm_rect_calc_hscale(src, dst, 1, max_hscale);\n\t\tvscale = drm_rect_calc_vscale(src, dst, 1, max_vscale);\n\n\t\tif (hscale < 0 || vscale < 0) {\n\t\t\tdrm_dbg_kms(&dev_priv->drm,\n\t\t\t\t    \"Scaler %d doesn't support required plane scaling\\n\",\n\t\t\t\t    *scaler_id);\n\t\t\tdrm_rect_debug_print(\"src: \", src, true);\n\t\t\tdrm_rect_debug_print(\"dst: \", dst, false);\n\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tdrm_dbg_kms(&dev_priv->drm, \"Attached scaler id %u.%u to %s:%d\\n\",\n\t\t    intel_crtc->pipe, *scaler_id, name, idx);\n\tscaler_state->scalers[*scaler_id].mode = mode;\n\n\treturn 0;\n}\n\n \nint intel_atomic_setup_scalers(struct drm_i915_private *dev_priv,\n\t\t\t       struct intel_crtc *intel_crtc,\n\t\t\t       struct intel_crtc_state *crtc_state)\n{\n\tstruct drm_plane *plane = NULL;\n\tstruct intel_plane *intel_plane;\n\tstruct intel_crtc_scaler_state *scaler_state =\n\t\t&crtc_state->scaler_state;\n\tstruct drm_atomic_state *drm_state = crtc_state->uapi.state;\n\tstruct intel_atomic_state *intel_state = to_intel_atomic_state(drm_state);\n\tint num_scalers_need;\n\tint i;\n\n\tnum_scalers_need = hweight32(scaler_state->scaler_users);\n\n\t \n\n\t \n\tif (num_scalers_need > intel_crtc->num_scalers) {\n\t\tdrm_dbg_kms(&dev_priv->drm,\n\t\t\t    \"Too many scaling requests %d > %d\\n\",\n\t\t\t    num_scalers_need, intel_crtc->num_scalers);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tfor (i = 0; i < sizeof(scaler_state->scaler_users) * 8; i++) {\n\t\tstruct intel_plane_state *plane_state = NULL;\n\t\tint *scaler_id;\n\t\tconst char *name;\n\t\tint idx, ret;\n\n\t\t \n\t\tif (!(scaler_state->scaler_users & (1 << i)))\n\t\t\tcontinue;\n\n\t\tif (i == SKL_CRTC_INDEX) {\n\t\t\tname = \"CRTC\";\n\t\t\tidx = intel_crtc->base.base.id;\n\n\t\t\t \n\t\t\tscaler_id = &scaler_state->scaler_id;\n\t\t} else {\n\t\t\tname = \"PLANE\";\n\n\t\t\t \n\t\t\t \n\t\t\tplane = drm_state->planes[i].ptr;\n\n\t\t\t \n\t\t\tif (!plane) {\n\t\t\t\tstruct drm_plane_state *state;\n\n\t\t\t\t \n\t\t\t\tif (DISPLAY_VER(dev_priv) >= 10)\n\t\t\t\t\tcontinue;\n\n\t\t\t\tplane = drm_plane_from_index(&dev_priv->drm, i);\n\t\t\t\tstate = drm_atomic_get_plane_state(drm_state, plane);\n\t\t\t\tif (IS_ERR(state)) {\n\t\t\t\t\tdrm_dbg_kms(&dev_priv->drm,\n\t\t\t\t\t\t    \"Failed to add [PLANE:%d] to drm_state\\n\",\n\t\t\t\t\t\t    plane->base.id);\n\t\t\t\t\treturn PTR_ERR(state);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tintel_plane = to_intel_plane(plane);\n\t\t\tidx = plane->base.id;\n\n\t\t\t \n\t\t\tif (drm_WARN_ON(&dev_priv->drm,\n\t\t\t\t\tintel_plane->pipe != intel_crtc->pipe))\n\t\t\t\tcontinue;\n\n\t\t\tplane_state = intel_atomic_get_new_plane_state(intel_state,\n\t\t\t\t\t\t\t\t       intel_plane);\n\t\t\tscaler_id = &plane_state->scaler_id;\n\t\t}\n\n\t\tret = intel_atomic_setup_scaler(scaler_state, num_scalers_need,\n\t\t\t\t\t\tintel_crtc, name, idx,\n\t\t\t\t\t\tplane_state, scaler_id);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int glk_coef_tap(int i)\n{\n\treturn i % 7;\n}\n\nstatic u16 glk_nearest_filter_coef(int t)\n{\n\treturn t == 3 ? 0x0800 : 0x3000;\n}\n\n \n\nstatic void glk_program_nearest_filter_coefs(struct drm_i915_private *dev_priv,\n\t\t\t\t\t     enum pipe pipe, int id, int set)\n{\n\tint i;\n\n\tintel_de_write_fw(dev_priv, GLK_PS_COEF_INDEX_SET(pipe, id, set),\n\t\t\t  PS_COEF_INDEX_AUTO_INC);\n\n\tfor (i = 0; i < 17 * 7; i += 2) {\n\t\tu32 tmp;\n\t\tint t;\n\n\t\tt = glk_coef_tap(i);\n\t\ttmp = glk_nearest_filter_coef(t);\n\n\t\tt = glk_coef_tap(i + 1);\n\t\ttmp |= glk_nearest_filter_coef(t) << 16;\n\n\t\tintel_de_write_fw(dev_priv, GLK_PS_COEF_DATA_SET(pipe, id, set),\n\t\t\t\t  tmp);\n\t}\n\n\tintel_de_write_fw(dev_priv, GLK_PS_COEF_INDEX_SET(pipe, id, set), 0);\n}\n\nstatic u32 skl_scaler_get_filter_select(enum drm_scaling_filter filter, int set)\n{\n\tif (filter == DRM_SCALING_FILTER_NEAREST_NEIGHBOR) {\n\t\treturn (PS_FILTER_PROGRAMMED |\n\t\t\tPS_Y_VERT_FILTER_SELECT(set) |\n\t\t\tPS_Y_HORZ_FILTER_SELECT(set) |\n\t\t\tPS_UV_VERT_FILTER_SELECT(set) |\n\t\t\tPS_UV_HORZ_FILTER_SELECT(set));\n\t}\n\n\treturn PS_FILTER_MEDIUM;\n}\n\nstatic void skl_scaler_setup_filter(struct drm_i915_private *dev_priv, enum pipe pipe,\n\t\t\t\t    int id, int set, enum drm_scaling_filter filter)\n{\n\tswitch (filter) {\n\tcase DRM_SCALING_FILTER_DEFAULT:\n\t\tbreak;\n\tcase DRM_SCALING_FILTER_NEAREST_NEIGHBOR:\n\t\tglk_program_nearest_filter_coefs(dev_priv, pipe, id, set);\n\t\tbreak;\n\tdefault:\n\t\tMISSING_CASE(filter);\n\t}\n}\n\nvoid skl_pfit_enable(const struct intel_crtc_state *crtc_state)\n{\n\tstruct intel_crtc *crtc = to_intel_crtc(crtc_state->uapi.crtc);\n\tstruct drm_i915_private *dev_priv = to_i915(crtc->base.dev);\n\tconst struct intel_crtc_scaler_state *scaler_state =\n\t\t&crtc_state->scaler_state;\n\tconst struct drm_rect *dst = &crtc_state->pch_pfit.dst;\n\tu16 uv_rgb_hphase, uv_rgb_vphase;\n\tenum pipe pipe = crtc->pipe;\n\tint width = drm_rect_width(dst);\n\tint height = drm_rect_height(dst);\n\tint x = dst->x1;\n\tint y = dst->y1;\n\tint hscale, vscale;\n\tstruct drm_rect src;\n\tint id;\n\tu32 ps_ctrl;\n\n\tif (!crtc_state->pch_pfit.enabled)\n\t\treturn;\n\n\tif (drm_WARN_ON(&dev_priv->drm,\n\t\t\tcrtc_state->scaler_state.scaler_id < 0))\n\t\treturn;\n\n\tdrm_rect_init(&src, 0, 0,\n\t\t      drm_rect_width(&crtc_state->pipe_src) << 16,\n\t\t      drm_rect_height(&crtc_state->pipe_src) << 16);\n\n\thscale = drm_rect_calc_hscale(&src, dst, 0, INT_MAX);\n\tvscale = drm_rect_calc_vscale(&src, dst, 0, INT_MAX);\n\n\tuv_rgb_hphase = skl_scaler_calc_phase(1, hscale, false);\n\tuv_rgb_vphase = skl_scaler_calc_phase(1, vscale, false);\n\n\tid = scaler_state->scaler_id;\n\n\tps_ctrl = PS_SCALER_EN | PS_BINDING_PIPE | scaler_state->scalers[id].mode |\n\t\tskl_scaler_get_filter_select(crtc_state->hw.scaling_filter, 0);\n\n\tskl_scaler_setup_filter(dev_priv, pipe, id, 0,\n\t\t\t\tcrtc_state->hw.scaling_filter);\n\n\tintel_de_write_fw(dev_priv, SKL_PS_CTRL(pipe, id), ps_ctrl);\n\n\tintel_de_write_fw(dev_priv, SKL_PS_VPHASE(pipe, id),\n\t\t\t  PS_Y_PHASE(0) | PS_UV_RGB_PHASE(uv_rgb_vphase));\n\tintel_de_write_fw(dev_priv, SKL_PS_HPHASE(pipe, id),\n\t\t\t  PS_Y_PHASE(0) | PS_UV_RGB_PHASE(uv_rgb_hphase));\n\tintel_de_write_fw(dev_priv, SKL_PS_WIN_POS(pipe, id),\n\t\t\t  PS_WIN_XPOS(x) | PS_WIN_YPOS(y));\n\tintel_de_write_fw(dev_priv, SKL_PS_WIN_SZ(pipe, id),\n\t\t\t  PS_WIN_XSIZE(width) | PS_WIN_YSIZE(height));\n}\n\nvoid\nskl_program_plane_scaler(struct intel_plane *plane,\n\t\t\t const struct intel_crtc_state *crtc_state,\n\t\t\t const struct intel_plane_state *plane_state)\n{\n\tstruct drm_i915_private *dev_priv = to_i915(plane->base.dev);\n\tconst struct drm_framebuffer *fb = plane_state->hw.fb;\n\tenum pipe pipe = plane->pipe;\n\tint scaler_id = plane_state->scaler_id;\n\tconst struct intel_scaler *scaler =\n\t\t&crtc_state->scaler_state.scalers[scaler_id];\n\tint crtc_x = plane_state->uapi.dst.x1;\n\tint crtc_y = plane_state->uapi.dst.y1;\n\tu32 crtc_w = drm_rect_width(&plane_state->uapi.dst);\n\tu32 crtc_h = drm_rect_height(&plane_state->uapi.dst);\n\tu16 y_hphase, uv_rgb_hphase;\n\tu16 y_vphase, uv_rgb_vphase;\n\tint hscale, vscale;\n\tu32 ps_ctrl;\n\n\thscale = drm_rect_calc_hscale(&plane_state->uapi.src,\n\t\t\t\t      &plane_state->uapi.dst,\n\t\t\t\t      0, INT_MAX);\n\tvscale = drm_rect_calc_vscale(&plane_state->uapi.src,\n\t\t\t\t      &plane_state->uapi.dst,\n\t\t\t\t      0, INT_MAX);\n\n\t \n\tif (intel_format_info_is_yuv_semiplanar(fb->format, fb->modifier) &&\n\t    !icl_is_hdr_plane(dev_priv, plane->id)) {\n\t\ty_hphase = skl_scaler_calc_phase(1, hscale, false);\n\t\ty_vphase = skl_scaler_calc_phase(1, vscale, false);\n\n\t\t \n\t\tuv_rgb_hphase = skl_scaler_calc_phase(2, hscale, true);\n\t\tuv_rgb_vphase = skl_scaler_calc_phase(2, vscale, false);\n\t} else {\n\t\t \n\t\ty_hphase = 0;\n\t\ty_vphase = 0;\n\n\t\tuv_rgb_hphase = skl_scaler_calc_phase(1, hscale, false);\n\t\tuv_rgb_vphase = skl_scaler_calc_phase(1, vscale, false);\n\t}\n\n\tps_ctrl = PS_SCALER_EN | PS_BINDING_PLANE(plane->id) | scaler->mode |\n\t\tskl_scaler_get_filter_select(plane_state->hw.scaling_filter, 0);\n\n\tskl_scaler_setup_filter(dev_priv, pipe, scaler_id, 0,\n\t\t\t\tplane_state->hw.scaling_filter);\n\n\tintel_de_write_fw(dev_priv, SKL_PS_CTRL(pipe, scaler_id), ps_ctrl);\n\tintel_de_write_fw(dev_priv, SKL_PS_VPHASE(pipe, scaler_id),\n\t\t\t  PS_Y_PHASE(y_vphase) | PS_UV_RGB_PHASE(uv_rgb_vphase));\n\tintel_de_write_fw(dev_priv, SKL_PS_HPHASE(pipe, scaler_id),\n\t\t\t  PS_Y_PHASE(y_hphase) | PS_UV_RGB_PHASE(uv_rgb_hphase));\n\tintel_de_write_fw(dev_priv, SKL_PS_WIN_POS(pipe, scaler_id),\n\t\t\t  PS_WIN_XPOS(crtc_x) | PS_WIN_YPOS(crtc_y));\n\tintel_de_write_fw(dev_priv, SKL_PS_WIN_SZ(pipe, scaler_id),\n\t\t\t  PS_WIN_XSIZE(crtc_w) | PS_WIN_YSIZE(crtc_h));\n}\n\nstatic void skl_detach_scaler(struct intel_crtc *crtc, int id)\n{\n\tstruct drm_device *dev = crtc->base.dev;\n\tstruct drm_i915_private *dev_priv = to_i915(dev);\n\n\tintel_de_write_fw(dev_priv, SKL_PS_CTRL(crtc->pipe, id), 0);\n\tintel_de_write_fw(dev_priv, SKL_PS_WIN_POS(crtc->pipe, id), 0);\n\tintel_de_write_fw(dev_priv, SKL_PS_WIN_SZ(crtc->pipe, id), 0);\n}\n\n \nvoid skl_detach_scalers(const struct intel_crtc_state *crtc_state)\n{\n\tstruct intel_crtc *crtc = to_intel_crtc(crtc_state->uapi.crtc);\n\tconst struct intel_crtc_scaler_state *scaler_state =\n\t\t&crtc_state->scaler_state;\n\tint i;\n\n\t \n\tfor (i = 0; i < crtc->num_scalers; i++) {\n\t\tif (!scaler_state->scalers[i].in_use)\n\t\t\tskl_detach_scaler(crtc, i);\n\t}\n}\n\nvoid skl_scaler_disable(const struct intel_crtc_state *old_crtc_state)\n{\n\tstruct intel_crtc *crtc = to_intel_crtc(old_crtc_state->uapi.crtc);\n\tint i;\n\n\tfor (i = 0; i < crtc->num_scalers; i++)\n\t\tskl_detach_scaler(crtc, i);\n}\n\nvoid skl_scaler_get_config(struct intel_crtc_state *crtc_state)\n{\n\tstruct intel_crtc *crtc = to_intel_crtc(crtc_state->uapi.crtc);\n\tstruct drm_i915_private *dev_priv = to_i915(crtc->base.dev);\n\tstruct intel_crtc_scaler_state *scaler_state = &crtc_state->scaler_state;\n\tint id = -1;\n\tint i;\n\n\t \n\tfor (i = 0; i < crtc->num_scalers; i++) {\n\t\tu32 ctl, pos, size;\n\n\t\tctl = intel_de_read(dev_priv, SKL_PS_CTRL(crtc->pipe, i));\n\t\tif ((ctl & (PS_SCALER_EN | PS_BINDING_MASK)) != (PS_SCALER_EN | PS_BINDING_PIPE))\n\t\t\tcontinue;\n\n\t\tid = i;\n\t\tcrtc_state->pch_pfit.enabled = true;\n\n\t\tpos = intel_de_read(dev_priv, SKL_PS_WIN_POS(crtc->pipe, i));\n\t\tsize = intel_de_read(dev_priv, SKL_PS_WIN_SZ(crtc->pipe, i));\n\n\t\tdrm_rect_init(&crtc_state->pch_pfit.dst,\n\t\t\t      REG_FIELD_GET(PS_WIN_XPOS_MASK, pos),\n\t\t\t      REG_FIELD_GET(PS_WIN_YPOS_MASK, pos),\n\t\t\t      REG_FIELD_GET(PS_WIN_XSIZE_MASK, size),\n\t\t\t      REG_FIELD_GET(PS_WIN_YSIZE_MASK, size));\n\n\t\tscaler_state->scalers[i].in_use = true;\n\t\tbreak;\n\t}\n\n\tscaler_state->scaler_id = id;\n\tif (id >= 0)\n\t\tscaler_state->scaler_users |= (1 << SKL_CRTC_INDEX);\n\telse\n\t\tscaler_state->scaler_users &= ~(1 << SKL_CRTC_INDEX);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}