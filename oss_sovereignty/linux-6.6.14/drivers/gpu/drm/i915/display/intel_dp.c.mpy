{
  "module_name": "intel_dp.c",
  "hash_id": "862009da032242854541d53f0bea0b003111533c7d75daee0acf0b6413786367",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/i915/display/intel_dp.c",
  "human_readable_source": " \n\n#include <linux/export.h>\n#include <linux/i2c.h>\n#include <linux/notifier.h>\n#include <linux/slab.h>\n#include <linux/string_helpers.h>\n#include <linux/timekeeping.h>\n#include <linux/types.h>\n\n#include <asm/byteorder.h>\n\n#include <drm/display/drm_dp_helper.h>\n#include <drm/display/drm_dsc_helper.h>\n#include <drm/display/drm_hdmi_helper.h>\n#include <drm/drm_atomic_helper.h>\n#include <drm/drm_crtc.h>\n#include <drm/drm_edid.h>\n#include <drm/drm_probe_helper.h>\n\n#include \"g4x_dp.h\"\n#include \"i915_drv.h\"\n#include \"i915_irq.h\"\n#include \"i915_reg.h\"\n#include \"intel_atomic.h\"\n#include \"intel_audio.h\"\n#include \"intel_backlight.h\"\n#include \"intel_combo_phy_regs.h\"\n#include \"intel_connector.h\"\n#include \"intel_crtc.h\"\n#include \"intel_cx0_phy.h\"\n#include \"intel_ddi.h\"\n#include \"intel_de.h\"\n#include \"intel_display_types.h\"\n#include \"intel_dp.h\"\n#include \"intel_dp_aux.h\"\n#include \"intel_dp_hdcp.h\"\n#include \"intel_dp_link_training.h\"\n#include \"intel_dp_mst.h\"\n#include \"intel_dpio_phy.h\"\n#include \"intel_dpll.h\"\n#include \"intel_fifo_underrun.h\"\n#include \"intel_hdcp.h\"\n#include \"intel_hdmi.h\"\n#include \"intel_hotplug.h\"\n#include \"intel_hotplug_irq.h\"\n#include \"intel_lspcon.h\"\n#include \"intel_lvds.h\"\n#include \"intel_panel.h\"\n#include \"intel_pch_display.h\"\n#include \"intel_pps.h\"\n#include \"intel_psr.h\"\n#include \"intel_tc.h\"\n#include \"intel_vdsc.h\"\n#include \"intel_vrr.h\"\n#include \"intel_crtc_state_dump.h\"\n\n \n#define DP_DSC_PEAK_PIXEL_RATE\t\t\t2720000\n#define DP_DSC_MAX_ENC_THROUGHPUT_0\t\t340000\n#define DP_DSC_MAX_ENC_THROUGHPUT_1\t\t400000\n\n \n#define DP_DSC_FEC_OVERHEAD_FACTOR\t\t972261\n\n \n#define INTEL_DP_RESOLUTION_SHIFT_MASK\t0\n#define INTEL_DP_RESOLUTION_PREFERRED\t(1 << INTEL_DP_RESOLUTION_SHIFT_MASK)\n#define INTEL_DP_RESOLUTION_STANDARD\t(2 << INTEL_DP_RESOLUTION_SHIFT_MASK)\n#define INTEL_DP_RESOLUTION_FAILSAFE\t(3 << INTEL_DP_RESOLUTION_SHIFT_MASK)\n\n\n \nstatic const u8 valid_dsc_bpp[] = {6, 8, 10, 12, 15};\n\n \nstatic const u8 valid_dsc_slicecount[] = {1, 2, 4};\n\n \nbool intel_dp_is_edp(struct intel_dp *intel_dp)\n{\n\tstruct intel_digital_port *dig_port = dp_to_dig_port(intel_dp);\n\n\treturn dig_port->base.type == INTEL_OUTPUT_EDP;\n}\n\nstatic void intel_dp_unset_edid(struct intel_dp *intel_dp);\n\n \nbool intel_dp_is_uhbr(const struct intel_crtc_state *crtc_state)\n{\n\treturn crtc_state->port_clock >= 1000000;\n}\n\nstatic void intel_dp_set_default_sink_rates(struct intel_dp *intel_dp)\n{\n\tintel_dp->sink_rates[0] = 162000;\n\tintel_dp->num_sink_rates = 1;\n}\n\n \nstatic void intel_dp_set_dpcd_sink_rates(struct intel_dp *intel_dp)\n{\n\tstatic const int dp_rates[] = {\n\t\t162000, 270000, 540000, 810000\n\t};\n\tint i, max_rate;\n\tint max_lttpr_rate;\n\n\tif (drm_dp_has_quirk(&intel_dp->desc, DP_DPCD_QUIRK_CAN_DO_MAX_LINK_RATE_3_24_GBPS)) {\n\t\t \n\t\tstatic const int quirk_rates[] = { 162000, 270000, 324000 };\n\n\t\tmemcpy(intel_dp->sink_rates, quirk_rates, sizeof(quirk_rates));\n\t\tintel_dp->num_sink_rates = ARRAY_SIZE(quirk_rates);\n\n\t\treturn;\n\t}\n\n\t \n\tmax_rate = drm_dp_bw_code_to_link_rate(intel_dp->dpcd[DP_MAX_LINK_RATE]);\n\tmax_lttpr_rate = drm_dp_lttpr_max_link_rate(intel_dp->lttpr_common_caps);\n\tif (max_lttpr_rate)\n\t\tmax_rate = min(max_rate, max_lttpr_rate);\n\n\tfor (i = 0; i < ARRAY_SIZE(dp_rates); i++) {\n\t\tif (dp_rates[i] > max_rate)\n\t\t\tbreak;\n\t\tintel_dp->sink_rates[i] = dp_rates[i];\n\t}\n\n\t \n\tif (intel_dp->dpcd[DP_MAIN_LINK_CHANNEL_CODING] & DP_CAP_ANSI_128B132B) {\n\t\tu8 uhbr_rates = 0;\n\n\t\tBUILD_BUG_ON(ARRAY_SIZE(intel_dp->sink_rates) < ARRAY_SIZE(dp_rates) + 3);\n\n\t\tdrm_dp_dpcd_readb(&intel_dp->aux,\n\t\t\t\t  DP_128B132B_SUPPORTED_LINK_RATES, &uhbr_rates);\n\n\t\tif (drm_dp_lttpr_count(intel_dp->lttpr_common_caps)) {\n\t\t\t \n\t\t\tif (intel_dp->lttpr_common_caps[0] >= 0x20 &&\n\t\t\t    intel_dp->lttpr_common_caps[DP_MAIN_LINK_CHANNEL_CODING_PHY_REPEATER -\n\t\t\t\t\t\t\tDP_LT_TUNABLE_PHY_REPEATER_FIELD_DATA_STRUCTURE_REV] &\n\t\t\t    DP_PHY_REPEATER_128B132B_SUPPORTED) {\n\t\t\t\t \n\t\t\t\tuhbr_rates &= intel_dp->lttpr_common_caps[DP_PHY_REPEATER_128B132B_RATES -\n\t\t\t\t\t\t\t\t\t  DP_LT_TUNABLE_PHY_REPEATER_FIELD_DATA_STRUCTURE_REV];\n\t\t\t} else {\n\t\t\t\t \n\t\t\t\tuhbr_rates = 0;\n\t\t\t}\n\t\t}\n\n\t\tif (uhbr_rates & DP_UHBR10)\n\t\t\tintel_dp->sink_rates[i++] = 1000000;\n\t\tif (uhbr_rates & DP_UHBR13_5)\n\t\t\tintel_dp->sink_rates[i++] = 1350000;\n\t\tif (uhbr_rates & DP_UHBR20)\n\t\t\tintel_dp->sink_rates[i++] = 2000000;\n\t}\n\n\tintel_dp->num_sink_rates = i;\n}\n\nstatic void intel_dp_set_sink_rates(struct intel_dp *intel_dp)\n{\n\tstruct intel_connector *connector = intel_dp->attached_connector;\n\tstruct intel_digital_port *intel_dig_port = dp_to_dig_port(intel_dp);\n\tstruct intel_encoder *encoder = &intel_dig_port->base;\n\n\tintel_dp_set_dpcd_sink_rates(intel_dp);\n\n\tif (intel_dp->num_sink_rates)\n\t\treturn;\n\n\tdrm_err(&dp_to_i915(intel_dp)->drm,\n\t\t\"[CONNECTOR:%d:%s][ENCODER:%d:%s] Invalid DPCD with no link rates, using defaults\\n\",\n\t\tconnector->base.base.id, connector->base.name,\n\t\tencoder->base.base.id, encoder->base.name);\n\n\tintel_dp_set_default_sink_rates(intel_dp);\n}\n\nstatic void intel_dp_set_default_max_sink_lane_count(struct intel_dp *intel_dp)\n{\n\tintel_dp->max_sink_lane_count = 1;\n}\n\nstatic void intel_dp_set_max_sink_lane_count(struct intel_dp *intel_dp)\n{\n\tstruct intel_connector *connector = intel_dp->attached_connector;\n\tstruct intel_digital_port *intel_dig_port = dp_to_dig_port(intel_dp);\n\tstruct intel_encoder *encoder = &intel_dig_port->base;\n\n\tintel_dp->max_sink_lane_count = drm_dp_max_lane_count(intel_dp->dpcd);\n\n\tswitch (intel_dp->max_sink_lane_count) {\n\tcase 1:\n\tcase 2:\n\tcase 4:\n\t\treturn;\n\t}\n\n\tdrm_err(&dp_to_i915(intel_dp)->drm,\n\t\t\"[CONNECTOR:%d:%s][ENCODER:%d:%s] Invalid DPCD max lane count (%d), using default\\n\",\n\t\tconnector->base.base.id, connector->base.name,\n\t\tencoder->base.base.id, encoder->base.name,\n\t\tintel_dp->max_sink_lane_count);\n\n\tintel_dp_set_default_max_sink_lane_count(intel_dp);\n}\n\n \nstatic int intel_dp_rate_limit_len(const int *rates, int len, int max_rate)\n{\n\tint i;\n\n\t \n\tfor (i = 0; i < len; i++) {\n\t\tif (rates[len - i - 1] <= max_rate)\n\t\t\treturn len - i;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int intel_dp_common_len_rate_limit(const struct intel_dp *intel_dp,\n\t\t\t\t\t  int max_rate)\n{\n\treturn intel_dp_rate_limit_len(intel_dp->common_rates,\n\t\t\t\t       intel_dp->num_common_rates, max_rate);\n}\n\nstatic int intel_dp_common_rate(struct intel_dp *intel_dp, int index)\n{\n\tif (drm_WARN_ON(&dp_to_i915(intel_dp)->drm,\n\t\t\tindex < 0 || index >= intel_dp->num_common_rates))\n\t\treturn 162000;\n\n\treturn intel_dp->common_rates[index];\n}\n\n \nstatic int intel_dp_max_common_rate(struct intel_dp *intel_dp)\n{\n\treturn intel_dp_common_rate(intel_dp, intel_dp->num_common_rates - 1);\n}\n\nstatic int intel_dp_max_source_lane_count(struct intel_digital_port *dig_port)\n{\n\tint vbt_max_lanes = intel_bios_dp_max_lane_count(dig_port->base.devdata);\n\tint max_lanes = dig_port->max_lanes;\n\n\tif (vbt_max_lanes)\n\t\tmax_lanes = min(max_lanes, vbt_max_lanes);\n\n\treturn max_lanes;\n}\n\n \nstatic int intel_dp_max_common_lane_count(struct intel_dp *intel_dp)\n{\n\tstruct intel_digital_port *dig_port = dp_to_dig_port(intel_dp);\n\tint source_max = intel_dp_max_source_lane_count(dig_port);\n\tint sink_max = intel_dp->max_sink_lane_count;\n\tint fia_max = intel_tc_port_fia_max_lane_count(dig_port);\n\tint lttpr_max = drm_dp_lttpr_max_lane_count(intel_dp->lttpr_common_caps);\n\n\tif (lttpr_max)\n\t\tsink_max = min(sink_max, lttpr_max);\n\n\treturn min3(source_max, sink_max, fia_max);\n}\n\nint intel_dp_max_lane_count(struct intel_dp *intel_dp)\n{\n\tswitch (intel_dp->max_link_lane_count) {\n\tcase 1:\n\tcase 2:\n\tcase 4:\n\t\treturn intel_dp->max_link_lane_count;\n\tdefault:\n\t\tMISSING_CASE(intel_dp->max_link_lane_count);\n\t\treturn 1;\n\t}\n}\n\n \nint\nintel_dp_link_required(int pixel_clock, int bpp)\n{\n\t \n\treturn DIV_ROUND_UP(pixel_clock * bpp, 8);\n}\n\n \nint\nintel_dp_max_data_rate(int max_link_rate, int max_lanes)\n{\n\tif (max_link_rate >= 1000000) {\n\t\t \n\t\tint max_link_rate_kbps = max_link_rate * 10;\n\n\t\tmax_link_rate_kbps = DIV_ROUND_CLOSEST_ULL(mul_u32_u32(max_link_rate_kbps, 9671), 10000);\n\t\tmax_link_rate = max_link_rate_kbps / 8;\n\t}\n\n\t \n\n\treturn max_link_rate * max_lanes;\n}\n\nbool intel_dp_can_bigjoiner(struct intel_dp *intel_dp)\n{\n\tstruct intel_digital_port *intel_dig_port = dp_to_dig_port(intel_dp);\n\tstruct intel_encoder *encoder = &intel_dig_port->base;\n\tstruct drm_i915_private *dev_priv = to_i915(encoder->base.dev);\n\n\treturn DISPLAY_VER(dev_priv) >= 12 ||\n\t\t(DISPLAY_VER(dev_priv) == 11 &&\n\t\t encoder->port != PORT_A);\n}\n\nstatic int dg2_max_source_rate(struct intel_dp *intel_dp)\n{\n\treturn intel_dp_is_edp(intel_dp) ? 810000 : 1350000;\n}\n\nstatic int icl_max_source_rate(struct intel_dp *intel_dp)\n{\n\tstruct intel_digital_port *dig_port = dp_to_dig_port(intel_dp);\n\tstruct drm_i915_private *dev_priv = to_i915(dig_port->base.base.dev);\n\tenum phy phy = intel_port_to_phy(dev_priv, dig_port->base.port);\n\n\tif (intel_phy_is_combo(dev_priv, phy) && !intel_dp_is_edp(intel_dp))\n\t\treturn 540000;\n\n\treturn 810000;\n}\n\nstatic int ehl_max_source_rate(struct intel_dp *intel_dp)\n{\n\tif (intel_dp_is_edp(intel_dp))\n\t\treturn 540000;\n\n\treturn 810000;\n}\n\nstatic int mtl_max_source_rate(struct intel_dp *intel_dp)\n{\n\tstruct intel_digital_port *dig_port = dp_to_dig_port(intel_dp);\n\tstruct drm_i915_private *i915 = to_i915(dig_port->base.base.dev);\n\tenum phy phy = intel_port_to_phy(i915, dig_port->base.port);\n\n\tif (intel_is_c10phy(i915, phy))\n\t\treturn 810000;\n\n\treturn 2000000;\n}\n\nstatic int vbt_max_link_rate(struct intel_dp *intel_dp)\n{\n\tstruct intel_encoder *encoder = &dp_to_dig_port(intel_dp)->base;\n\tint max_rate;\n\n\tmax_rate = intel_bios_dp_max_link_rate(encoder->devdata);\n\n\tif (intel_dp_is_edp(intel_dp)) {\n\t\tstruct intel_connector *connector = intel_dp->attached_connector;\n\t\tint edp_max_rate = connector->panel.vbt.edp.max_link_rate;\n\n\t\tif (max_rate && edp_max_rate)\n\t\t\tmax_rate = min(max_rate, edp_max_rate);\n\t\telse if (edp_max_rate)\n\t\t\tmax_rate = edp_max_rate;\n\t}\n\n\treturn max_rate;\n}\n\nstatic void\nintel_dp_set_source_rates(struct intel_dp *intel_dp)\n{\n\t \n\tstatic const int mtl_rates[] = {\n\t\t162000, 216000, 243000, 270000, 324000, 432000, 540000, 675000,\n\t\t810000,\t1000000, 1350000, 2000000,\n\t};\n\tstatic const int icl_rates[] = {\n\t\t162000, 216000, 270000, 324000, 432000, 540000, 648000, 810000,\n\t\t1000000, 1350000,\n\t};\n\tstatic const int bxt_rates[] = {\n\t\t162000, 216000, 243000, 270000, 324000, 432000, 540000\n\t};\n\tstatic const int skl_rates[] = {\n\t\t162000, 216000, 270000, 324000, 432000, 540000\n\t};\n\tstatic const int hsw_rates[] = {\n\t\t162000, 270000, 540000\n\t};\n\tstatic const int g4x_rates[] = {\n\t\t162000, 270000\n\t};\n\tstruct intel_digital_port *dig_port = dp_to_dig_port(intel_dp);\n\tstruct drm_i915_private *dev_priv = to_i915(dig_port->base.base.dev);\n\tconst int *source_rates;\n\tint size, max_rate = 0, vbt_max_rate;\n\n\t \n\tdrm_WARN_ON(&dev_priv->drm,\n\t\t    intel_dp->source_rates || intel_dp->num_source_rates);\n\n\tif (DISPLAY_VER(dev_priv) >= 14) {\n\t\tsource_rates = mtl_rates;\n\t\tsize = ARRAY_SIZE(mtl_rates);\n\t\tmax_rate = mtl_max_source_rate(intel_dp);\n\t} else if (DISPLAY_VER(dev_priv) >= 11) {\n\t\tsource_rates = icl_rates;\n\t\tsize = ARRAY_SIZE(icl_rates);\n\t\tif (IS_DG2(dev_priv))\n\t\t\tmax_rate = dg2_max_source_rate(intel_dp);\n\t\telse if (IS_ALDERLAKE_P(dev_priv) || IS_ALDERLAKE_S(dev_priv) ||\n\t\t\t IS_DG1(dev_priv) || IS_ROCKETLAKE(dev_priv))\n\t\t\tmax_rate = 810000;\n\t\telse if (IS_JASPERLAKE(dev_priv) || IS_ELKHARTLAKE(dev_priv))\n\t\t\tmax_rate = ehl_max_source_rate(intel_dp);\n\t\telse\n\t\t\tmax_rate = icl_max_source_rate(intel_dp);\n\t} else if (IS_GEMINILAKE(dev_priv) || IS_BROXTON(dev_priv)) {\n\t\tsource_rates = bxt_rates;\n\t\tsize = ARRAY_SIZE(bxt_rates);\n\t} else if (DISPLAY_VER(dev_priv) == 9) {\n\t\tsource_rates = skl_rates;\n\t\tsize = ARRAY_SIZE(skl_rates);\n\t} else if ((IS_HASWELL(dev_priv) && !IS_HASWELL_ULX(dev_priv)) ||\n\t\t   IS_BROADWELL(dev_priv)) {\n\t\tsource_rates = hsw_rates;\n\t\tsize = ARRAY_SIZE(hsw_rates);\n\t} else {\n\t\tsource_rates = g4x_rates;\n\t\tsize = ARRAY_SIZE(g4x_rates);\n\t}\n\n\tvbt_max_rate = vbt_max_link_rate(intel_dp);\n\tif (max_rate && vbt_max_rate)\n\t\tmax_rate = min(max_rate, vbt_max_rate);\n\telse if (vbt_max_rate)\n\t\tmax_rate = vbt_max_rate;\n\n\tif (max_rate)\n\t\tsize = intel_dp_rate_limit_len(source_rates, size, max_rate);\n\n\tintel_dp->source_rates = source_rates;\n\tintel_dp->num_source_rates = size;\n}\n\nstatic int intersect_rates(const int *source_rates, int source_len,\n\t\t\t   const int *sink_rates, int sink_len,\n\t\t\t   int *common_rates)\n{\n\tint i = 0, j = 0, k = 0;\n\n\twhile (i < source_len && j < sink_len) {\n\t\tif (source_rates[i] == sink_rates[j]) {\n\t\t\tif (WARN_ON(k >= DP_MAX_SUPPORTED_RATES))\n\t\t\t\treturn k;\n\t\t\tcommon_rates[k] = source_rates[i];\n\t\t\t++k;\n\t\t\t++i;\n\t\t\t++j;\n\t\t} else if (source_rates[i] < sink_rates[j]) {\n\t\t\t++i;\n\t\t} else {\n\t\t\t++j;\n\t\t}\n\t}\n\treturn k;\n}\n\n \nstatic int intel_dp_rate_index(const int *rates, int len, int rate)\n{\n\tint i;\n\n\tfor (i = 0; i < len; i++)\n\t\tif (rate == rates[i])\n\t\t\treturn i;\n\n\treturn -1;\n}\n\nstatic void intel_dp_set_common_rates(struct intel_dp *intel_dp)\n{\n\tstruct drm_i915_private *i915 = dp_to_i915(intel_dp);\n\n\tdrm_WARN_ON(&i915->drm,\n\t\t    !intel_dp->num_source_rates || !intel_dp->num_sink_rates);\n\n\tintel_dp->num_common_rates = intersect_rates(intel_dp->source_rates,\n\t\t\t\t\t\t     intel_dp->num_source_rates,\n\t\t\t\t\t\t     intel_dp->sink_rates,\n\t\t\t\t\t\t     intel_dp->num_sink_rates,\n\t\t\t\t\t\t     intel_dp->common_rates);\n\n\t \n\tif (drm_WARN_ON(&i915->drm, intel_dp->num_common_rates == 0)) {\n\t\tintel_dp->common_rates[0] = 162000;\n\t\tintel_dp->num_common_rates = 1;\n\t}\n}\n\nstatic bool intel_dp_link_params_valid(struct intel_dp *intel_dp, int link_rate,\n\t\t\t\t       u8 lane_count)\n{\n\t \n\tif (link_rate == 0 ||\n\t    link_rate > intel_dp->max_link_rate)\n\t\treturn false;\n\n\tif (lane_count == 0 ||\n\t    lane_count > intel_dp_max_lane_count(intel_dp))\n\t\treturn false;\n\n\treturn true;\n}\n\nstatic bool intel_dp_can_link_train_fallback_for_edp(struct intel_dp *intel_dp,\n\t\t\t\t\t\t     int link_rate,\n\t\t\t\t\t\t     u8 lane_count)\n{\n\t \n\tconst struct drm_display_mode *fixed_mode =\n\t\tintel_panel_preferred_fixed_mode(intel_dp->attached_connector);\n\tint mode_rate, max_rate;\n\n\tmode_rate = intel_dp_link_required(fixed_mode->clock, 18);\n\tmax_rate = intel_dp_max_data_rate(link_rate, lane_count);\n\tif (mode_rate > max_rate)\n\t\treturn false;\n\n\treturn true;\n}\n\nint intel_dp_get_link_train_fallback_values(struct intel_dp *intel_dp,\n\t\t\t\t\t    int link_rate, u8 lane_count)\n{\n\tstruct drm_i915_private *i915 = dp_to_i915(intel_dp);\n\tint index;\n\n\t \n\tif (intel_dp->is_mst) {\n\t\tdrm_err(&i915->drm, \"Link Training Unsuccessful\\n\");\n\t\treturn -1;\n\t}\n\n\tif (intel_dp_is_edp(intel_dp) && !intel_dp->use_max_params) {\n\t\tdrm_dbg_kms(&i915->drm,\n\t\t\t    \"Retrying Link training for eDP with max parameters\\n\");\n\t\tintel_dp->use_max_params = true;\n\t\treturn 0;\n\t}\n\n\tindex = intel_dp_rate_index(intel_dp->common_rates,\n\t\t\t\t    intel_dp->num_common_rates,\n\t\t\t\t    link_rate);\n\tif (index > 0) {\n\t\tif (intel_dp_is_edp(intel_dp) &&\n\t\t    !intel_dp_can_link_train_fallback_for_edp(intel_dp,\n\t\t\t\t\t\t\t      intel_dp_common_rate(intel_dp, index - 1),\n\t\t\t\t\t\t\t      lane_count)) {\n\t\t\tdrm_dbg_kms(&i915->drm,\n\t\t\t\t    \"Retrying Link training for eDP with same parameters\\n\");\n\t\t\treturn 0;\n\t\t}\n\t\tintel_dp->max_link_rate = intel_dp_common_rate(intel_dp, index - 1);\n\t\tintel_dp->max_link_lane_count = lane_count;\n\t} else if (lane_count > 1) {\n\t\tif (intel_dp_is_edp(intel_dp) &&\n\t\t    !intel_dp_can_link_train_fallback_for_edp(intel_dp,\n\t\t\t\t\t\t\t      intel_dp_max_common_rate(intel_dp),\n\t\t\t\t\t\t\t      lane_count >> 1)) {\n\t\t\tdrm_dbg_kms(&i915->drm,\n\t\t\t\t    \"Retrying Link training for eDP with same parameters\\n\");\n\t\t\treturn 0;\n\t\t}\n\t\tintel_dp->max_link_rate = intel_dp_max_common_rate(intel_dp);\n\t\tintel_dp->max_link_lane_count = lane_count >> 1;\n\t} else {\n\t\tdrm_err(&i915->drm, \"Link Training Unsuccessful\\n\");\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}\n\nu32 intel_dp_mode_to_fec_clock(u32 mode_clock)\n{\n\treturn div_u64(mul_u32_u32(mode_clock, 1000000U),\n\t\t       DP_DSC_FEC_OVERHEAD_FACTOR);\n}\n\nstatic int\nsmall_joiner_ram_size_bits(struct drm_i915_private *i915)\n{\n\tif (DISPLAY_VER(i915) >= 13)\n\t\treturn 17280 * 8;\n\telse if (DISPLAY_VER(i915) >= 11)\n\t\treturn 7680 * 8;\n\telse\n\t\treturn 6144 * 8;\n}\n\nu32 intel_dp_dsc_nearest_valid_bpp(struct drm_i915_private *i915, u32 bpp, u32 pipe_bpp)\n{\n\tu32 bits_per_pixel = bpp;\n\tint i;\n\n\t \n\tif (bits_per_pixel < valid_dsc_bpp[0]) {\n\t\tdrm_dbg_kms(&i915->drm, \"Unsupported BPP %u, min %u\\n\",\n\t\t\t    bits_per_pixel, valid_dsc_bpp[0]);\n\t\treturn 0;\n\t}\n\n\t \n\tif (DISPLAY_VER(i915) >= 13) {\n\t\tbits_per_pixel = min(bits_per_pixel, pipe_bpp - 1);\n\n\t\t \n\t\tif (bits_per_pixel < 8) {\n\t\t\tdrm_dbg_kms(&i915->drm, \"Unsupported BPP %u, min 8\\n\",\n\t\t\t\t    bits_per_pixel);\n\t\t\treturn 0;\n\t\t}\n\t\tbits_per_pixel = min_t(u32, bits_per_pixel, 27);\n\t} else {\n\t\t \n\t\tfor (i = 0; i < ARRAY_SIZE(valid_dsc_bpp) - 1; i++) {\n\t\t\tif (bits_per_pixel < valid_dsc_bpp[i + 1])\n\t\t\t\tbreak;\n\t\t}\n\t\tdrm_dbg_kms(&i915->drm, \"Set dsc bpp from %d to VESA %d\\n\",\n\t\t\t    bits_per_pixel, valid_dsc_bpp[i]);\n\n\t\tbits_per_pixel = valid_dsc_bpp[i];\n\t}\n\n\treturn bits_per_pixel;\n}\n\nu16 intel_dp_dsc_get_output_bpp(struct drm_i915_private *i915,\n\t\t\t\tu32 link_clock, u32 lane_count,\n\t\t\t\tu32 mode_clock, u32 mode_hdisplay,\n\t\t\t\tbool bigjoiner,\n\t\t\t\tu32 pipe_bpp,\n\t\t\t\tu32 timeslots)\n{\n\tu32 bits_per_pixel, max_bpp_small_joiner_ram;\n\n\t \n\tbits_per_pixel = ((link_clock * lane_count) * timeslots) /\n\t\t\t (intel_dp_mode_to_fec_clock(mode_clock) * 8);\n\n\tdrm_dbg_kms(&i915->drm, \"Max link bpp is %u for %u timeslots \"\n\t\t\t\t\"total bw %u pixel clock %u\\n\",\n\t\t\t\tbits_per_pixel, timeslots,\n\t\t\t\t(link_clock * lane_count * 8),\n\t\t\t\tintel_dp_mode_to_fec_clock(mode_clock));\n\n\t \n\tmax_bpp_small_joiner_ram = small_joiner_ram_size_bits(i915) /\n\t\tmode_hdisplay;\n\n\tif (bigjoiner)\n\t\tmax_bpp_small_joiner_ram *= 2;\n\n\t \n\tbits_per_pixel = min(bits_per_pixel, max_bpp_small_joiner_ram);\n\n\tif (bigjoiner) {\n\t\tu32 max_bpp_bigjoiner =\n\t\t\ti915->display.cdclk.max_cdclk_freq * 48 /\n\t\t\tintel_dp_mode_to_fec_clock(mode_clock);\n\n\t\tbits_per_pixel = min(bits_per_pixel, max_bpp_bigjoiner);\n\t}\n\n\tbits_per_pixel = intel_dp_dsc_nearest_valid_bpp(i915, bits_per_pixel, pipe_bpp);\n\n\t \n\treturn bits_per_pixel << 4;\n}\n\nu8 intel_dp_dsc_get_slice_count(struct intel_dp *intel_dp,\n\t\t\t\tint mode_clock, int mode_hdisplay,\n\t\t\t\tbool bigjoiner)\n{\n\tstruct drm_i915_private *i915 = dp_to_i915(intel_dp);\n\tu8 min_slice_count, i;\n\tint max_slice_width;\n\n\tif (mode_clock <= DP_DSC_PEAK_PIXEL_RATE)\n\t\tmin_slice_count = DIV_ROUND_UP(mode_clock,\n\t\t\t\t\t       DP_DSC_MAX_ENC_THROUGHPUT_0);\n\telse\n\t\tmin_slice_count = DIV_ROUND_UP(mode_clock,\n\t\t\t\t\t       DP_DSC_MAX_ENC_THROUGHPUT_1);\n\n\t \n\tif (mode_clock >= ((i915->display.cdclk.max_cdclk_freq * 85) / 100))\n\t\tmin_slice_count = max_t(u8, min_slice_count, 2);\n\n\tmax_slice_width = drm_dp_dsc_sink_max_slice_width(intel_dp->dsc_dpcd);\n\tif (max_slice_width < DP_DSC_MIN_SLICE_WIDTH_VALUE) {\n\t\tdrm_dbg_kms(&i915->drm,\n\t\t\t    \"Unsupported slice width %d by DP DSC Sink device\\n\",\n\t\t\t    max_slice_width);\n\t\treturn 0;\n\t}\n\t \n\tmin_slice_count = max_t(u8, min_slice_count,\n\t\t\t\tDIV_ROUND_UP(mode_hdisplay,\n\t\t\t\t\t     max_slice_width));\n\n\t \n\tfor (i = 0; i < ARRAY_SIZE(valid_dsc_slicecount); i++) {\n\t\tu8 test_slice_count = valid_dsc_slicecount[i] << bigjoiner;\n\n\t\tif (test_slice_count >\n\t\t    drm_dp_dsc_sink_max_slice_count(intel_dp->dsc_dpcd, false))\n\t\t\tbreak;\n\n\t\t \n\t\tif (bigjoiner && test_slice_count < 4)\n\t\t\tcontinue;\n\n\t\tif (min_slice_count <= test_slice_count)\n\t\t\treturn test_slice_count;\n\t}\n\n\tdrm_dbg_kms(&i915->drm, \"Unsupported Slice Count %d\\n\",\n\t\t    min_slice_count);\n\treturn 0;\n}\n\nstatic bool source_can_output(struct intel_dp *intel_dp,\n\t\t\t      enum intel_output_format format)\n{\n\tstruct drm_i915_private *i915 = dp_to_i915(intel_dp);\n\n\tswitch (format) {\n\tcase INTEL_OUTPUT_FORMAT_RGB:\n\t\treturn true;\n\n\tcase INTEL_OUTPUT_FORMAT_YCBCR444:\n\t\t \n\t\treturn !HAS_GMCH(i915) && !IS_IRONLAKE(i915);\n\n\tcase INTEL_OUTPUT_FORMAT_YCBCR420:\n\t\t \n\t\treturn DISPLAY_VER(i915) >= 11;\n\n\tdefault:\n\t\tMISSING_CASE(format);\n\t\treturn false;\n\t}\n}\n\nstatic bool\ndfp_can_convert_from_rgb(struct intel_dp *intel_dp,\n\t\t\t enum intel_output_format sink_format)\n{\n\tif (!drm_dp_is_branch(intel_dp->dpcd))\n\t\treturn false;\n\n\tif (sink_format == INTEL_OUTPUT_FORMAT_YCBCR444)\n\t\treturn intel_dp->dfp.rgb_to_ycbcr;\n\n\tif (sink_format == INTEL_OUTPUT_FORMAT_YCBCR420)\n\t\treturn intel_dp->dfp.rgb_to_ycbcr &&\n\t\t\tintel_dp->dfp.ycbcr_444_to_420;\n\n\treturn false;\n}\n\nstatic bool\ndfp_can_convert_from_ycbcr444(struct intel_dp *intel_dp,\n\t\t\t      enum intel_output_format sink_format)\n{\n\tif (!drm_dp_is_branch(intel_dp->dpcd))\n\t\treturn false;\n\n\tif (sink_format == INTEL_OUTPUT_FORMAT_YCBCR420)\n\t\treturn intel_dp->dfp.ycbcr_444_to_420;\n\n\treturn false;\n}\n\nstatic enum intel_output_format\nintel_dp_output_format(struct intel_connector *connector,\n\t\t       enum intel_output_format sink_format)\n{\n\tstruct intel_dp *intel_dp = intel_attached_dp(connector);\n\tstruct drm_i915_private *i915 = dp_to_i915(intel_dp);\n\tenum intel_output_format output_format;\n\n\tif (intel_dp->force_dsc_output_format)\n\t\treturn intel_dp->force_dsc_output_format;\n\n\tif (sink_format == INTEL_OUTPUT_FORMAT_RGB ||\n\t    dfp_can_convert_from_rgb(intel_dp, sink_format))\n\t\toutput_format = INTEL_OUTPUT_FORMAT_RGB;\n\n\telse if (sink_format == INTEL_OUTPUT_FORMAT_YCBCR444 ||\n\t\t dfp_can_convert_from_ycbcr444(intel_dp, sink_format))\n\t\toutput_format = INTEL_OUTPUT_FORMAT_YCBCR444;\n\n\telse\n\t\toutput_format = INTEL_OUTPUT_FORMAT_YCBCR420;\n\n\tdrm_WARN_ON(&i915->drm, !source_can_output(intel_dp, output_format));\n\n\treturn output_format;\n}\n\nint intel_dp_min_bpp(enum intel_output_format output_format)\n{\n\tif (output_format == INTEL_OUTPUT_FORMAT_RGB)\n\t\treturn 6 * 3;\n\telse\n\t\treturn 8 * 3;\n}\n\nstatic int intel_dp_output_bpp(enum intel_output_format output_format, int bpp)\n{\n\t \n\tif (output_format == INTEL_OUTPUT_FORMAT_YCBCR420)\n\t\tbpp /= 2;\n\n\treturn bpp;\n}\n\nstatic enum intel_output_format\nintel_dp_sink_format(struct intel_connector *connector,\n\t\t     const struct drm_display_mode *mode)\n{\n\tconst struct drm_display_info *info = &connector->base.display_info;\n\n\tif (drm_mode_is_420_only(info, mode))\n\t\treturn INTEL_OUTPUT_FORMAT_YCBCR420;\n\n\treturn INTEL_OUTPUT_FORMAT_RGB;\n}\n\nstatic int\nintel_dp_mode_min_output_bpp(struct intel_connector *connector,\n\t\t\t     const struct drm_display_mode *mode)\n{\n\tenum intel_output_format output_format, sink_format;\n\n\tsink_format = intel_dp_sink_format(connector, mode);\n\n\toutput_format = intel_dp_output_format(connector, sink_format);\n\n\treturn intel_dp_output_bpp(output_format, intel_dp_min_bpp(output_format));\n}\n\nstatic bool intel_dp_hdisplay_bad(struct drm_i915_private *dev_priv,\n\t\t\t\t  int hdisplay)\n{\n\t \n\treturn hdisplay == 4096 && !HAS_DDI(dev_priv);\n}\n\nstatic int intel_dp_max_tmds_clock(struct intel_dp *intel_dp)\n{\n\tstruct intel_connector *connector = intel_dp->attached_connector;\n\tconst struct drm_display_info *info = &connector->base.display_info;\n\tint max_tmds_clock = intel_dp->dfp.max_tmds_clock;\n\n\t \n\tif (max_tmds_clock && info->max_tmds_clock)\n\t\tmax_tmds_clock = min(max_tmds_clock, info->max_tmds_clock);\n\n\treturn max_tmds_clock;\n}\n\nstatic enum drm_mode_status\nintel_dp_tmds_clock_valid(struct intel_dp *intel_dp,\n\t\t\t  int clock, int bpc,\n\t\t\t  enum intel_output_format sink_format,\n\t\t\t  bool respect_downstream_limits)\n{\n\tint tmds_clock, min_tmds_clock, max_tmds_clock;\n\n\tif (!respect_downstream_limits)\n\t\treturn MODE_OK;\n\n\ttmds_clock = intel_hdmi_tmds_clock(clock, bpc, sink_format);\n\n\tmin_tmds_clock = intel_dp->dfp.min_tmds_clock;\n\tmax_tmds_clock = intel_dp_max_tmds_clock(intel_dp);\n\n\tif (min_tmds_clock && tmds_clock < min_tmds_clock)\n\t\treturn MODE_CLOCK_LOW;\n\n\tif (max_tmds_clock && tmds_clock > max_tmds_clock)\n\t\treturn MODE_CLOCK_HIGH;\n\n\treturn MODE_OK;\n}\n\nstatic enum drm_mode_status\nintel_dp_mode_valid_downstream(struct intel_connector *connector,\n\t\t\t       const struct drm_display_mode *mode,\n\t\t\t       int target_clock)\n{\n\tstruct intel_dp *intel_dp = intel_attached_dp(connector);\n\tconst struct drm_display_info *info = &connector->base.display_info;\n\tenum drm_mode_status status;\n\tenum intel_output_format sink_format;\n\n\t \n\tif (intel_dp->dfp.pcon_max_frl_bw) {\n\t\tint target_bw;\n\t\tint max_frl_bw;\n\t\tint bpp = intel_dp_mode_min_output_bpp(connector, mode);\n\n\t\ttarget_bw = bpp * target_clock;\n\n\t\tmax_frl_bw = intel_dp->dfp.pcon_max_frl_bw;\n\n\t\t \n\t\tmax_frl_bw = max_frl_bw * 1000000;\n\n\t\tif (target_bw > max_frl_bw)\n\t\t\treturn MODE_CLOCK_HIGH;\n\n\t\treturn MODE_OK;\n\t}\n\n\tif (intel_dp->dfp.max_dotclock &&\n\t    target_clock > intel_dp->dfp.max_dotclock)\n\t\treturn MODE_CLOCK_HIGH;\n\n\tsink_format = intel_dp_sink_format(connector, mode);\n\n\t \n\tstatus = intel_dp_tmds_clock_valid(intel_dp, target_clock,\n\t\t\t\t\t   8, sink_format, true);\n\n\tif (status != MODE_OK) {\n\t\tif (sink_format == INTEL_OUTPUT_FORMAT_YCBCR420 ||\n\t\t    !connector->base.ycbcr_420_allowed ||\n\t\t    !drm_mode_is_420_also(info, mode))\n\t\t\treturn status;\n\t\tsink_format = INTEL_OUTPUT_FORMAT_YCBCR420;\n\t\tstatus = intel_dp_tmds_clock_valid(intel_dp, target_clock,\n\t\t\t\t\t\t   8, sink_format, true);\n\t\tif (status != MODE_OK)\n\t\t\treturn status;\n\t}\n\n\treturn MODE_OK;\n}\n\nbool intel_dp_need_bigjoiner(struct intel_dp *intel_dp,\n\t\t\t     int hdisplay, int clock)\n{\n\tstruct drm_i915_private *i915 = dp_to_i915(intel_dp);\n\n\tif (!intel_dp_can_bigjoiner(intel_dp))\n\t\treturn false;\n\n\treturn clock > i915->max_dotclk_freq || hdisplay > 5120;\n}\n\nstatic enum drm_mode_status\nintel_dp_mode_valid(struct drm_connector *_connector,\n\t\t    struct drm_display_mode *mode)\n{\n\tstruct intel_connector *connector = to_intel_connector(_connector);\n\tstruct intel_dp *intel_dp = intel_attached_dp(connector);\n\tstruct drm_i915_private *dev_priv = to_i915(connector->base.dev);\n\tconst struct drm_display_mode *fixed_mode;\n\tint target_clock = mode->clock;\n\tint max_rate, mode_rate, max_lanes, max_link_clock;\n\tint max_dotclk = dev_priv->max_dotclk_freq;\n\tu16 dsc_max_output_bpp = 0;\n\tu8 dsc_slice_count = 0;\n\tenum drm_mode_status status;\n\tbool dsc = false, bigjoiner = false;\n\n\tstatus = intel_cpu_transcoder_mode_valid(dev_priv, mode);\n\tif (status != MODE_OK)\n\t\treturn status;\n\n\tif (mode->flags & DRM_MODE_FLAG_DBLCLK)\n\t\treturn MODE_H_ILLEGAL;\n\n\tfixed_mode = intel_panel_fixed_mode(connector, mode);\n\tif (intel_dp_is_edp(intel_dp) && fixed_mode) {\n\t\tstatus = intel_panel_mode_valid(connector, mode);\n\t\tif (status != MODE_OK)\n\t\t\treturn status;\n\n\t\ttarget_clock = fixed_mode->clock;\n\t}\n\n\tif (mode->clock < 10000)\n\t\treturn MODE_CLOCK_LOW;\n\n\tif (intel_dp_need_bigjoiner(intel_dp, mode->hdisplay, target_clock)) {\n\t\tbigjoiner = true;\n\t\tmax_dotclk *= 2;\n\t}\n\tif (target_clock > max_dotclk)\n\t\treturn MODE_CLOCK_HIGH;\n\n\tif (intel_dp_hdisplay_bad(dev_priv, mode->hdisplay))\n\t\treturn MODE_H_ILLEGAL;\n\n\tmax_link_clock = intel_dp_max_link_rate(intel_dp);\n\tmax_lanes = intel_dp_max_lane_count(intel_dp);\n\n\tmax_rate = intel_dp_max_data_rate(max_link_clock, max_lanes);\n\tmode_rate = intel_dp_link_required(target_clock,\n\t\t\t\t\t   intel_dp_mode_min_output_bpp(connector, mode));\n\n\tif (HAS_DSC(dev_priv) &&\n\t    drm_dp_sink_supports_dsc(intel_dp->dsc_dpcd)) {\n\t\t \n\t\tint pipe_bpp = intel_dp_dsc_compute_bpp(intel_dp, U8_MAX);\n\n\t\t \n\t\tif (intel_dp_is_edp(intel_dp)) {\n\t\t\tdsc_max_output_bpp =\n\t\t\t\tdrm_edp_dsc_sink_output_bpp(intel_dp->dsc_dpcd) >> 4;\n\t\t\tdsc_slice_count =\n\t\t\t\tdrm_dp_dsc_sink_max_slice_count(intel_dp->dsc_dpcd,\n\t\t\t\t\t\t\t\ttrue);\n\t\t} else if (drm_dp_sink_supports_fec(intel_dp->fec_capable)) {\n\t\t\tdsc_max_output_bpp =\n\t\t\t\tintel_dp_dsc_get_output_bpp(dev_priv,\n\t\t\t\t\t\t\t    max_link_clock,\n\t\t\t\t\t\t\t    max_lanes,\n\t\t\t\t\t\t\t    target_clock,\n\t\t\t\t\t\t\t    mode->hdisplay,\n\t\t\t\t\t\t\t    bigjoiner,\n\t\t\t\t\t\t\t    pipe_bpp, 64) >> 4;\n\t\t\tdsc_slice_count =\n\t\t\t\tintel_dp_dsc_get_slice_count(intel_dp,\n\t\t\t\t\t\t\t     target_clock,\n\t\t\t\t\t\t\t     mode->hdisplay,\n\t\t\t\t\t\t\t     bigjoiner);\n\t\t}\n\n\t\tdsc = dsc_max_output_bpp && dsc_slice_count;\n\t}\n\n\t \n\tif (DISPLAY_VER(dev_priv) < 13 && bigjoiner && !dsc)\n\t\treturn MODE_CLOCK_HIGH;\n\n\tif (mode_rate > max_rate && !dsc)\n\t\treturn MODE_CLOCK_HIGH;\n\n\tstatus = intel_dp_mode_valid_downstream(connector, mode, target_clock);\n\tif (status != MODE_OK)\n\t\treturn status;\n\n\treturn intel_mode_valid_max_plane_size(dev_priv, mode, bigjoiner);\n}\n\nbool intel_dp_source_supports_tps3(struct drm_i915_private *i915)\n{\n\treturn DISPLAY_VER(i915) >= 9 || IS_BROADWELL(i915) || IS_HASWELL(i915);\n}\n\nbool intel_dp_source_supports_tps4(struct drm_i915_private *i915)\n{\n\treturn DISPLAY_VER(i915) >= 10;\n}\n\nstatic void snprintf_int_array(char *str, size_t len,\n\t\t\t       const int *array, int nelem)\n{\n\tint i;\n\n\tstr[0] = '\\0';\n\n\tfor (i = 0; i < nelem; i++) {\n\t\tint r = snprintf(str, len, \"%s%d\", i ? \", \" : \"\", array[i]);\n\t\tif (r >= len)\n\t\t\treturn;\n\t\tstr += r;\n\t\tlen -= r;\n\t}\n}\n\nstatic void intel_dp_print_rates(struct intel_dp *intel_dp)\n{\n\tstruct drm_i915_private *i915 = dp_to_i915(intel_dp);\n\tchar str[128];  \n\n\tif (!drm_debug_enabled(DRM_UT_KMS))\n\t\treturn;\n\n\tsnprintf_int_array(str, sizeof(str),\n\t\t\t   intel_dp->source_rates, intel_dp->num_source_rates);\n\tdrm_dbg_kms(&i915->drm, \"source rates: %s\\n\", str);\n\n\tsnprintf_int_array(str, sizeof(str),\n\t\t\t   intel_dp->sink_rates, intel_dp->num_sink_rates);\n\tdrm_dbg_kms(&i915->drm, \"sink rates: %s\\n\", str);\n\n\tsnprintf_int_array(str, sizeof(str),\n\t\t\t   intel_dp->common_rates, intel_dp->num_common_rates);\n\tdrm_dbg_kms(&i915->drm, \"common rates: %s\\n\", str);\n}\n\nint\nintel_dp_max_link_rate(struct intel_dp *intel_dp)\n{\n\tint len;\n\n\tlen = intel_dp_common_len_rate_limit(intel_dp, intel_dp->max_link_rate);\n\n\treturn intel_dp_common_rate(intel_dp, len - 1);\n}\n\nint intel_dp_rate_select(struct intel_dp *intel_dp, int rate)\n{\n\tstruct drm_i915_private *i915 = dp_to_i915(intel_dp);\n\tint i = intel_dp_rate_index(intel_dp->sink_rates,\n\t\t\t\t    intel_dp->num_sink_rates, rate);\n\n\tif (drm_WARN_ON(&i915->drm, i < 0))\n\t\ti = 0;\n\n\treturn i;\n}\n\nvoid intel_dp_compute_rate(struct intel_dp *intel_dp, int port_clock,\n\t\t\t   u8 *link_bw, u8 *rate_select)\n{\n\t \n\tif (intel_dp->use_rate_select) {\n\t\t*link_bw = 0;\n\t\t*rate_select =\n\t\t\tintel_dp_rate_select(intel_dp, port_clock);\n\t} else {\n\t\t*link_bw = drm_dp_link_rate_to_bw_code(port_clock);\n\t\t*rate_select = 0;\n\t}\n}\n\nbool intel_dp_has_hdmi_sink(struct intel_dp *intel_dp)\n{\n\tstruct intel_connector *connector = intel_dp->attached_connector;\n\n\treturn connector->base.display_info.is_hdmi;\n}\n\nstatic bool intel_dp_source_supports_fec(struct intel_dp *intel_dp,\n\t\t\t\t\t const struct intel_crtc_state *pipe_config)\n{\n\tstruct drm_i915_private *dev_priv = dp_to_i915(intel_dp);\n\n\t \n\tif (DISPLAY_VER(dev_priv) >= 12)\n\t\treturn true;\n\n\tif (DISPLAY_VER(dev_priv) == 11 && pipe_config->cpu_transcoder != TRANSCODER_A)\n\t\treturn true;\n\n\treturn false;\n}\n\nstatic bool intel_dp_supports_fec(struct intel_dp *intel_dp,\n\t\t\t\t  const struct intel_crtc_state *pipe_config)\n{\n\treturn intel_dp_source_supports_fec(intel_dp, pipe_config) &&\n\t\tdrm_dp_sink_supports_fec(intel_dp->fec_capable);\n}\n\nstatic bool intel_dp_supports_dsc(struct intel_dp *intel_dp,\n\t\t\t\t  const struct intel_crtc_state *crtc_state)\n{\n\tif (intel_crtc_has_type(crtc_state, INTEL_OUTPUT_DP) && !crtc_state->fec_enable)\n\t\treturn false;\n\n\treturn intel_dsc_source_support(crtc_state) &&\n\t\tdrm_dp_sink_supports_dsc(intel_dp->dsc_dpcd);\n}\n\nstatic int intel_dp_hdmi_compute_bpc(struct intel_dp *intel_dp,\n\t\t\t\t     const struct intel_crtc_state *crtc_state,\n\t\t\t\t     int bpc, bool respect_downstream_limits)\n{\n\tint clock = crtc_state->hw.adjusted_mode.crtc_clock;\n\n\t \n\tbpc = max(bpc, 8);\n\n\t \n\tif (!respect_downstream_limits)\n\t\tbpc = 8;\n\n\tfor (; bpc >= 8; bpc -= 2) {\n\t\tif (intel_hdmi_bpc_possible(crtc_state, bpc,\n\t\t\t\t\t    intel_dp_has_hdmi_sink(intel_dp)) &&\n\t\t    intel_dp_tmds_clock_valid(intel_dp, clock, bpc, crtc_state->sink_format,\n\t\t\t\t\t      respect_downstream_limits) == MODE_OK)\n\t\t\treturn bpc;\n\t}\n\n\treturn -EINVAL;\n}\n\nstatic int intel_dp_max_bpp(struct intel_dp *intel_dp,\n\t\t\t    const struct intel_crtc_state *crtc_state,\n\t\t\t    bool respect_downstream_limits)\n{\n\tstruct drm_i915_private *dev_priv = dp_to_i915(intel_dp);\n\tstruct intel_connector *intel_connector = intel_dp->attached_connector;\n\tint bpp, bpc;\n\n\tbpc = crtc_state->pipe_bpp / 3;\n\n\tif (intel_dp->dfp.max_bpc)\n\t\tbpc = min_t(int, bpc, intel_dp->dfp.max_bpc);\n\n\tif (intel_dp->dfp.min_tmds_clock) {\n\t\tint max_hdmi_bpc;\n\n\t\tmax_hdmi_bpc = intel_dp_hdmi_compute_bpc(intel_dp, crtc_state, bpc,\n\t\t\t\t\t\t\t respect_downstream_limits);\n\t\tif (max_hdmi_bpc < 0)\n\t\t\treturn 0;\n\n\t\tbpc = min(bpc, max_hdmi_bpc);\n\t}\n\n\tbpp = bpc * 3;\n\tif (intel_dp_is_edp(intel_dp)) {\n\t\t \n\t\tif (intel_connector->base.display_info.bpc == 0 &&\n\t\t    intel_connector->panel.vbt.edp.bpp &&\n\t\t    intel_connector->panel.vbt.edp.bpp < bpp) {\n\t\t\tdrm_dbg_kms(&dev_priv->drm,\n\t\t\t\t    \"clamping bpp for eDP panel to BIOS-provided %i\\n\",\n\t\t\t\t    intel_connector->panel.vbt.edp.bpp);\n\t\t\tbpp = intel_connector->panel.vbt.edp.bpp;\n\t\t}\n\t}\n\n\treturn bpp;\n}\n\n \nvoid\nintel_dp_adjust_compliance_config(struct intel_dp *intel_dp,\n\t\t\t\t  struct intel_crtc_state *pipe_config,\n\t\t\t\t  struct link_config_limits *limits)\n{\n\tstruct drm_i915_private *i915 = dp_to_i915(intel_dp);\n\n\t \n\tif (intel_dp->compliance.test_data.bpc != 0) {\n\t\tint bpp = 3 * intel_dp->compliance.test_data.bpc;\n\n\t\tlimits->min_bpp = limits->max_bpp = bpp;\n\t\tpipe_config->dither_force_disable = bpp == 6 * 3;\n\n\t\tdrm_dbg_kms(&i915->drm, \"Setting pipe_bpp to %d\\n\", bpp);\n\t}\n\n\t \n\tif (intel_dp->compliance.test_type == DP_TEST_LINK_TRAINING) {\n\t\tint index;\n\n\t\t \n\t\tif (intel_dp_link_params_valid(intel_dp, intel_dp->compliance.test_link_rate,\n\t\t\t\t\t       intel_dp->compliance.test_lane_count)) {\n\t\t\tindex = intel_dp_rate_index(intel_dp->common_rates,\n\t\t\t\t\t\t    intel_dp->num_common_rates,\n\t\t\t\t\t\t    intel_dp->compliance.test_link_rate);\n\t\t\tif (index >= 0)\n\t\t\t\tlimits->min_rate = limits->max_rate =\n\t\t\t\t\tintel_dp->compliance.test_link_rate;\n\t\t\tlimits->min_lane_count = limits->max_lane_count =\n\t\t\t\tintel_dp->compliance.test_lane_count;\n\t\t}\n\t}\n}\n\nstatic bool has_seamless_m_n(struct intel_connector *connector)\n{\n\tstruct drm_i915_private *i915 = to_i915(connector->base.dev);\n\n\t \n\treturn HAS_DOUBLE_BUFFERED_M_N(i915) &&\n\t\tintel_panel_drrs_type(connector) == DRRS_TYPE_SEAMLESS;\n}\n\nstatic int intel_dp_mode_clock(const struct intel_crtc_state *crtc_state,\n\t\t\t       const struct drm_connector_state *conn_state)\n{\n\tstruct intel_connector *connector = to_intel_connector(conn_state->connector);\n\tconst struct drm_display_mode *adjusted_mode = &crtc_state->hw.adjusted_mode;\n\n\t \n\tif (has_seamless_m_n(connector))\n\t\treturn intel_panel_highest_mode(connector, adjusted_mode)->clock;\n\telse\n\t\treturn adjusted_mode->crtc_clock;\n}\n\n \nstatic int\nintel_dp_compute_link_config_wide(struct intel_dp *intel_dp,\n\t\t\t\t  struct intel_crtc_state *pipe_config,\n\t\t\t\t  const struct drm_connector_state *conn_state,\n\t\t\t\t  const struct link_config_limits *limits)\n{\n\tint bpp, i, lane_count, clock = intel_dp_mode_clock(pipe_config, conn_state);\n\tint mode_rate, link_rate, link_avail;\n\n\tfor (bpp = limits->max_bpp; bpp >= limits->min_bpp; bpp -= 2 * 3) {\n\t\tint output_bpp = intel_dp_output_bpp(pipe_config->output_format, bpp);\n\n\t\tmode_rate = intel_dp_link_required(clock, output_bpp);\n\n\t\tfor (i = 0; i < intel_dp->num_common_rates; i++) {\n\t\t\tlink_rate = intel_dp_common_rate(intel_dp, i);\n\t\t\tif (link_rate < limits->min_rate ||\n\t\t\t    link_rate > limits->max_rate)\n\t\t\t\tcontinue;\n\n\t\t\tfor (lane_count = limits->min_lane_count;\n\t\t\t     lane_count <= limits->max_lane_count;\n\t\t\t     lane_count <<= 1) {\n\t\t\t\tlink_avail = intel_dp_max_data_rate(link_rate,\n\t\t\t\t\t\t\t\t    lane_count);\n\n\t\t\t\tif (mode_rate <= link_avail) {\n\t\t\t\t\tpipe_config->lane_count = lane_count;\n\t\t\t\t\tpipe_config->pipe_bpp = bpp;\n\t\t\t\t\tpipe_config->port_clock = link_rate;\n\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn -EINVAL;\n}\n\nint intel_dp_dsc_compute_bpp(struct intel_dp *intel_dp, u8 max_req_bpc)\n{\n\tstruct drm_i915_private *i915 = dp_to_i915(intel_dp);\n\tint i, num_bpc;\n\tu8 dsc_bpc[3] = {0};\n\tu8 dsc_max_bpc;\n\n\t \n\tif (DISPLAY_VER(i915) >= 12)\n\t\tdsc_max_bpc = min_t(u8, 12, max_req_bpc);\n\telse\n\t\tdsc_max_bpc = min_t(u8, 10, max_req_bpc);\n\n\tnum_bpc = drm_dp_dsc_sink_supported_input_bpcs(intel_dp->dsc_dpcd,\n\t\t\t\t\t\t       dsc_bpc);\n\tfor (i = 0; i < num_bpc; i++) {\n\t\tif (dsc_max_bpc >= dsc_bpc[i])\n\t\t\treturn dsc_bpc[i] * 3;\n\t}\n\n\treturn 0;\n}\n\nstatic int intel_dp_source_dsc_version_minor(struct intel_dp *intel_dp)\n{\n\tstruct drm_i915_private *i915 = dp_to_i915(intel_dp);\n\n\treturn DISPLAY_VER(i915) >= 14 ? 2 : 1;\n}\n\nstatic int intel_dp_sink_dsc_version_minor(struct intel_dp *intel_dp)\n{\n\treturn (intel_dp->dsc_dpcd[DP_DSC_REV - DP_DSC_SUPPORT] & DP_DSC_MINOR_MASK) >>\n\t\tDP_DSC_MINOR_SHIFT;\n}\n\nstatic int intel_dp_get_slice_height(int vactive)\n{\n\tint slice_height;\n\n\t \n\tfor (slice_height = 108; slice_height <= vactive; slice_height += 2)\n\t\tif (vactive % slice_height == 0)\n\t\t\treturn slice_height;\n\n\t \n\treturn 2;\n}\n\nstatic int intel_dp_dsc_compute_params(struct intel_encoder *encoder,\n\t\t\t\t       struct intel_crtc_state *crtc_state)\n{\n\tstruct drm_i915_private *i915 = to_i915(encoder->base.dev);\n\tstruct intel_dp *intel_dp = enc_to_intel_dp(encoder);\n\tstruct drm_dsc_config *vdsc_cfg = &crtc_state->dsc.config;\n\tu8 line_buf_depth;\n\tint ret;\n\n\t \n\tvdsc_cfg->rc_model_size = DSC_RC_MODEL_SIZE_CONST;\n\tvdsc_cfg->pic_height = crtc_state->hw.adjusted_mode.crtc_vdisplay;\n\n\tvdsc_cfg->slice_height = intel_dp_get_slice_height(vdsc_cfg->pic_height);\n\n\tret = intel_dsc_compute_params(crtc_state);\n\tif (ret)\n\t\treturn ret;\n\n\tvdsc_cfg->dsc_version_major =\n\t\t(intel_dp->dsc_dpcd[DP_DSC_REV - DP_DSC_SUPPORT] &\n\t\t DP_DSC_MAJOR_MASK) >> DP_DSC_MAJOR_SHIFT;\n\tvdsc_cfg->dsc_version_minor =\n\t\tmin(intel_dp_source_dsc_version_minor(intel_dp),\n\t\t    intel_dp_sink_dsc_version_minor(intel_dp));\n\tif (vdsc_cfg->convert_rgb)\n\t\tvdsc_cfg->convert_rgb =\n\t\t\tintel_dp->dsc_dpcd[DP_DSC_DEC_COLOR_FORMAT_CAP - DP_DSC_SUPPORT] &\n\t\t\tDP_DSC_RGB;\n\n\tline_buf_depth = drm_dp_dsc_sink_line_buf_depth(intel_dp->dsc_dpcd);\n\tif (!line_buf_depth) {\n\t\tdrm_dbg_kms(&i915->drm,\n\t\t\t    \"DSC Sink Line Buffer Depth invalid\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (vdsc_cfg->dsc_version_minor == 2)\n\t\tvdsc_cfg->line_buf_depth = (line_buf_depth == DSC_1_2_MAX_LINEBUF_DEPTH_BITS) ?\n\t\t\tDSC_1_2_MAX_LINEBUF_DEPTH_VAL : line_buf_depth;\n\telse\n\t\tvdsc_cfg->line_buf_depth = (line_buf_depth > DSC_1_1_MAX_LINEBUF_DEPTH_BITS) ?\n\t\t\tDSC_1_1_MAX_LINEBUF_DEPTH_BITS : line_buf_depth;\n\n\tvdsc_cfg->block_pred_enable =\n\t\tintel_dp->dsc_dpcd[DP_DSC_BLK_PREDICTION_SUPPORT - DP_DSC_SUPPORT] &\n\t\tDP_DSC_BLK_PREDICTION_IS_SUPPORTED;\n\n\treturn drm_dsc_compute_rc_parameters(vdsc_cfg);\n}\n\nstatic bool intel_dp_dsc_supports_format(struct intel_dp *intel_dp,\n\t\t\t\t\t enum intel_output_format output_format)\n{\n\tu8 sink_dsc_format;\n\n\tswitch (output_format) {\n\tcase INTEL_OUTPUT_FORMAT_RGB:\n\t\tsink_dsc_format = DP_DSC_RGB;\n\t\tbreak;\n\tcase INTEL_OUTPUT_FORMAT_YCBCR444:\n\t\tsink_dsc_format = DP_DSC_YCbCr444;\n\t\tbreak;\n\tcase INTEL_OUTPUT_FORMAT_YCBCR420:\n\t\tif (min(intel_dp_source_dsc_version_minor(intel_dp),\n\t\t\tintel_dp_sink_dsc_version_minor(intel_dp)) < 2)\n\t\t\treturn false;\n\t\tsink_dsc_format = DP_DSC_YCbCr420_Native;\n\t\tbreak;\n\tdefault:\n\t\treturn false;\n\t}\n\n\treturn drm_dp_dsc_sink_supports_format(intel_dp->dsc_dpcd, sink_dsc_format);\n}\n\nint intel_dp_dsc_compute_config(struct intel_dp *intel_dp,\n\t\t\t\tstruct intel_crtc_state *pipe_config,\n\t\t\t\tstruct drm_connector_state *conn_state,\n\t\t\t\tstruct link_config_limits *limits,\n\t\t\t\tint timeslots,\n\t\t\t\tbool compute_pipe_bpp)\n{\n\tstruct intel_digital_port *dig_port = dp_to_dig_port(intel_dp);\n\tstruct drm_i915_private *dev_priv = to_i915(dig_port->base.base.dev);\n\tconst struct drm_display_mode *adjusted_mode =\n\t\t&pipe_config->hw.adjusted_mode;\n\tint pipe_bpp;\n\tint ret;\n\n\tpipe_config->fec_enable = !intel_dp_is_edp(intel_dp) &&\n\t\tintel_dp_supports_fec(intel_dp, pipe_config);\n\n\tif (!intel_dp_supports_dsc(intel_dp, pipe_config))\n\t\treturn -EINVAL;\n\n\tif (!intel_dp_dsc_supports_format(intel_dp, pipe_config->output_format))\n\t\treturn -EINVAL;\n\n\tif (compute_pipe_bpp)\n\t\tpipe_bpp = intel_dp_dsc_compute_bpp(intel_dp, conn_state->max_requested_bpc);\n\telse\n\t\tpipe_bpp = pipe_config->pipe_bpp;\n\n\tif (intel_dp->force_dsc_bpc) {\n\t\tpipe_bpp = intel_dp->force_dsc_bpc * 3;\n\t\tdrm_dbg_kms(&dev_priv->drm, \"Input DSC BPP forced to %d\", pipe_bpp);\n\t}\n\n\t \n\tif (pipe_bpp < 8 * 3) {\n\t\tdrm_dbg_kms(&dev_priv->drm,\n\t\t\t    \"No DSC support for less than 8bpc\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tpipe_config->pipe_bpp = pipe_bpp;\n\tpipe_config->port_clock = limits->max_rate;\n\tpipe_config->lane_count = limits->max_lane_count;\n\n\tif (intel_dp_is_edp(intel_dp)) {\n\t\tpipe_config->dsc.compressed_bpp =\n\t\t\tmin_t(u16, drm_edp_dsc_sink_output_bpp(intel_dp->dsc_dpcd) >> 4,\n\t\t\t      pipe_config->pipe_bpp);\n\t\tpipe_config->dsc.slice_count =\n\t\t\tdrm_dp_dsc_sink_max_slice_count(intel_dp->dsc_dpcd,\n\t\t\t\t\t\t\ttrue);\n\t\tif (!pipe_config->dsc.slice_count) {\n\t\t\tdrm_dbg_kms(&dev_priv->drm, \"Unsupported Slice Count %d\\n\",\n\t\t\t\t    pipe_config->dsc.slice_count);\n\t\t\treturn -EINVAL;\n\t\t}\n\t} else {\n\t\tu16 dsc_max_output_bpp = 0;\n\t\tu8 dsc_dp_slice_count;\n\n\t\tif (compute_pipe_bpp) {\n\t\t\tdsc_max_output_bpp =\n\t\t\t\tintel_dp_dsc_get_output_bpp(dev_priv,\n\t\t\t\t\t\t\t    pipe_config->port_clock,\n\t\t\t\t\t\t\t    pipe_config->lane_count,\n\t\t\t\t\t\t\t    adjusted_mode->crtc_clock,\n\t\t\t\t\t\t\t    adjusted_mode->crtc_hdisplay,\n\t\t\t\t\t\t\t    pipe_config->bigjoiner_pipes,\n\t\t\t\t\t\t\t    pipe_bpp,\n\t\t\t\t\t\t\t    timeslots);\n\t\t\t \n\t\t\tif (pipe_config->output_format == INTEL_OUTPUT_FORMAT_YCBCR420)\n\t\t\t\tdsc_max_output_bpp = min_t(u16, dsc_max_output_bpp, 31 << 4);\n\n\t\t\tif (!dsc_max_output_bpp) {\n\t\t\t\tdrm_dbg_kms(&dev_priv->drm,\n\t\t\t\t\t    \"Compressed BPP not supported\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t}\n\t\tdsc_dp_slice_count =\n\t\t\tintel_dp_dsc_get_slice_count(intel_dp,\n\t\t\t\t\t\t     adjusted_mode->crtc_clock,\n\t\t\t\t\t\t     adjusted_mode->crtc_hdisplay,\n\t\t\t\t\t\t     pipe_config->bigjoiner_pipes);\n\t\tif (!dsc_dp_slice_count) {\n\t\t\tdrm_dbg_kms(&dev_priv->drm,\n\t\t\t\t    \"Compressed Slice Count not supported\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\t \n\t\tif (compute_pipe_bpp) {\n\t\t\tpipe_config->dsc.compressed_bpp = min_t(u16,\n\t\t\t\t\t\t\t\tdsc_max_output_bpp >> 4,\n\t\t\t\t\t\t\t\tpipe_config->pipe_bpp);\n\t\t}\n\t\tpipe_config->dsc.slice_count = dsc_dp_slice_count;\n\t\tdrm_dbg_kms(&dev_priv->drm, \"DSC: compressed bpp %d slice count %d\\n\",\n\t\t\t    pipe_config->dsc.compressed_bpp,\n\t\t\t    pipe_config->dsc.slice_count);\n\t}\n\t \n\tif (pipe_config->bigjoiner_pipes || pipe_config->dsc.slice_count > 1)\n\t\tpipe_config->dsc.dsc_split = true;\n\n\tret = intel_dp_dsc_compute_params(&dig_port->base, pipe_config);\n\tif (ret < 0) {\n\t\tdrm_dbg_kms(&dev_priv->drm,\n\t\t\t    \"Cannot compute valid DSC parameters for Input Bpp = %d \"\n\t\t\t    \"Compressed BPP = %d\\n\",\n\t\t\t    pipe_config->pipe_bpp,\n\t\t\t    pipe_config->dsc.compressed_bpp);\n\t\treturn ret;\n\t}\n\n\tpipe_config->dsc.compression_enable = true;\n\tdrm_dbg_kms(&dev_priv->drm, \"DP DSC computed with Input Bpp = %d \"\n\t\t    \"Compressed Bpp = %d Slice Count = %d\\n\",\n\t\t    pipe_config->pipe_bpp,\n\t\t    pipe_config->dsc.compressed_bpp,\n\t\t    pipe_config->dsc.slice_count);\n\n\treturn 0;\n}\n\nstatic int\nintel_dp_compute_link_config(struct intel_encoder *encoder,\n\t\t\t     struct intel_crtc_state *pipe_config,\n\t\t\t     struct drm_connector_state *conn_state,\n\t\t\t     bool respect_downstream_limits)\n{\n\tstruct drm_i915_private *i915 = to_i915(encoder->base.dev);\n\tstruct intel_crtc *crtc = to_intel_crtc(pipe_config->uapi.crtc);\n\tconst struct drm_display_mode *adjusted_mode =\n\t\t&pipe_config->hw.adjusted_mode;\n\tstruct intel_dp *intel_dp = enc_to_intel_dp(encoder);\n\tstruct link_config_limits limits;\n\tbool joiner_needs_dsc = false;\n\tint ret;\n\n\tlimits.min_rate = intel_dp_common_rate(intel_dp, 0);\n\tlimits.max_rate = intel_dp_max_link_rate(intel_dp);\n\n\tlimits.min_lane_count = 1;\n\tlimits.max_lane_count = intel_dp_max_lane_count(intel_dp);\n\n\tlimits.min_bpp = intel_dp_min_bpp(pipe_config->output_format);\n\tlimits.max_bpp = intel_dp_max_bpp(intel_dp, pipe_config, respect_downstream_limits);\n\n\tif (intel_dp->use_max_params) {\n\t\t \n\t\tlimits.min_lane_count = limits.max_lane_count;\n\t\tlimits.min_rate = limits.max_rate;\n\t}\n\n\tintel_dp_adjust_compliance_config(intel_dp, pipe_config, &limits);\n\n\tdrm_dbg_kms(&i915->drm, \"DP link computation with max lane count %i \"\n\t\t    \"max rate %d max bpp %d pixel clock %iKHz\\n\",\n\t\t    limits.max_lane_count, limits.max_rate,\n\t\t    limits.max_bpp, adjusted_mode->crtc_clock);\n\n\tif (intel_dp_need_bigjoiner(intel_dp, adjusted_mode->crtc_hdisplay,\n\t\t\t\t    adjusted_mode->crtc_clock))\n\t\tpipe_config->bigjoiner_pipes = GENMASK(crtc->pipe + 1, crtc->pipe);\n\n\t \n\tjoiner_needs_dsc = DISPLAY_VER(i915) < 13 && pipe_config->bigjoiner_pipes;\n\n\t \n\tret = intel_dp_compute_link_config_wide(intel_dp, pipe_config, conn_state, &limits);\n\n\tif (ret || joiner_needs_dsc || intel_dp->force_dsc_en) {\n\t\tdrm_dbg_kms(&i915->drm, \"Try DSC (fallback=%s, joiner=%s, force=%s)\\n\",\n\t\t\t    str_yes_no(ret), str_yes_no(joiner_needs_dsc),\n\t\t\t    str_yes_no(intel_dp->force_dsc_en));\n\t\tret = intel_dp_dsc_compute_config(intel_dp, pipe_config,\n\t\t\t\t\t\t  conn_state, &limits, 64, true);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\tif (pipe_config->dsc.compression_enable) {\n\t\tdrm_dbg_kms(&i915->drm,\n\t\t\t    \"DP lane count %d clock %d Input bpp %d Compressed bpp %d\\n\",\n\t\t\t    pipe_config->lane_count, pipe_config->port_clock,\n\t\t\t    pipe_config->pipe_bpp,\n\t\t\t    pipe_config->dsc.compressed_bpp);\n\n\t\tdrm_dbg_kms(&i915->drm,\n\t\t\t    \"DP link rate required %i available %i\\n\",\n\t\t\t    intel_dp_link_required(adjusted_mode->crtc_clock,\n\t\t\t\t\t\t   pipe_config->dsc.compressed_bpp),\n\t\t\t    intel_dp_max_data_rate(pipe_config->port_clock,\n\t\t\t\t\t\t   pipe_config->lane_count));\n\t} else {\n\t\tdrm_dbg_kms(&i915->drm, \"DP lane count %d clock %d bpp %d\\n\",\n\t\t\t    pipe_config->lane_count, pipe_config->port_clock,\n\t\t\t    pipe_config->pipe_bpp);\n\n\t\tdrm_dbg_kms(&i915->drm,\n\t\t\t    \"DP link rate required %i available %i\\n\",\n\t\t\t    intel_dp_link_required(adjusted_mode->crtc_clock,\n\t\t\t\t\t\t   pipe_config->pipe_bpp),\n\t\t\t    intel_dp_max_data_rate(pipe_config->port_clock,\n\t\t\t\t\t\t   pipe_config->lane_count));\n\t}\n\treturn 0;\n}\n\nbool intel_dp_limited_color_range(const struct intel_crtc_state *crtc_state,\n\t\t\t\t  const struct drm_connector_state *conn_state)\n{\n\tconst struct intel_digital_connector_state *intel_conn_state =\n\t\tto_intel_digital_connector_state(conn_state);\n\tconst struct drm_display_mode *adjusted_mode =\n\t\t&crtc_state->hw.adjusted_mode;\n\n\t \n\tif (crtc_state->output_format != INTEL_OUTPUT_FORMAT_RGB)\n\t\treturn false;\n\n\tif (intel_conn_state->broadcast_rgb == INTEL_BROADCAST_RGB_AUTO) {\n\t\t \n\t\treturn crtc_state->pipe_bpp != 18 &&\n\t\t\tdrm_default_rgb_quant_range(adjusted_mode) ==\n\t\t\tHDMI_QUANTIZATION_RANGE_LIMITED;\n\t} else {\n\t\treturn intel_conn_state->broadcast_rgb ==\n\t\t\tINTEL_BROADCAST_RGB_LIMITED;\n\t}\n}\n\nstatic bool intel_dp_port_has_audio(struct drm_i915_private *dev_priv,\n\t\t\t\t    enum port port)\n{\n\tif (IS_G4X(dev_priv))\n\t\treturn false;\n\tif (DISPLAY_VER(dev_priv) < 12 && port == PORT_A)\n\t\treturn false;\n\n\treturn true;\n}\n\nstatic void intel_dp_compute_vsc_colorimetry(const struct intel_crtc_state *crtc_state,\n\t\t\t\t\t     const struct drm_connector_state *conn_state,\n\t\t\t\t\t     struct drm_dp_vsc_sdp *vsc)\n{\n\tstruct intel_crtc *crtc = to_intel_crtc(crtc_state->uapi.crtc);\n\tstruct drm_i915_private *dev_priv = to_i915(crtc->base.dev);\n\n\t \n\tvsc->revision = 0x5;\n\tvsc->length = 0x13;\n\n\t \n\tswitch (crtc_state->output_format) {\n\tcase INTEL_OUTPUT_FORMAT_YCBCR444:\n\t\tvsc->pixelformat = DP_PIXELFORMAT_YUV444;\n\t\tbreak;\n\tcase INTEL_OUTPUT_FORMAT_YCBCR420:\n\t\tvsc->pixelformat = DP_PIXELFORMAT_YUV420;\n\t\tbreak;\n\tcase INTEL_OUTPUT_FORMAT_RGB:\n\tdefault:\n\t\tvsc->pixelformat = DP_PIXELFORMAT_RGB;\n\t}\n\n\tswitch (conn_state->colorspace) {\n\tcase DRM_MODE_COLORIMETRY_BT709_YCC:\n\t\tvsc->colorimetry = DP_COLORIMETRY_BT709_YCC;\n\t\tbreak;\n\tcase DRM_MODE_COLORIMETRY_XVYCC_601:\n\t\tvsc->colorimetry = DP_COLORIMETRY_XVYCC_601;\n\t\tbreak;\n\tcase DRM_MODE_COLORIMETRY_XVYCC_709:\n\t\tvsc->colorimetry = DP_COLORIMETRY_XVYCC_709;\n\t\tbreak;\n\tcase DRM_MODE_COLORIMETRY_SYCC_601:\n\t\tvsc->colorimetry = DP_COLORIMETRY_SYCC_601;\n\t\tbreak;\n\tcase DRM_MODE_COLORIMETRY_OPYCC_601:\n\t\tvsc->colorimetry = DP_COLORIMETRY_OPYCC_601;\n\t\tbreak;\n\tcase DRM_MODE_COLORIMETRY_BT2020_CYCC:\n\t\tvsc->colorimetry = DP_COLORIMETRY_BT2020_CYCC;\n\t\tbreak;\n\tcase DRM_MODE_COLORIMETRY_BT2020_RGB:\n\t\tvsc->colorimetry = DP_COLORIMETRY_BT2020_RGB;\n\t\tbreak;\n\tcase DRM_MODE_COLORIMETRY_BT2020_YCC:\n\t\tvsc->colorimetry = DP_COLORIMETRY_BT2020_YCC;\n\t\tbreak;\n\tcase DRM_MODE_COLORIMETRY_DCI_P3_RGB_D65:\n\tcase DRM_MODE_COLORIMETRY_DCI_P3_RGB_THEATER:\n\t\tvsc->colorimetry = DP_COLORIMETRY_DCI_P3_RGB;\n\t\tbreak;\n\tdefault:\n\t\t \n\t\tif (crtc_state->output_format == INTEL_OUTPUT_FORMAT_YCBCR420)\n\t\t\tvsc->colorimetry = DP_COLORIMETRY_BT709_YCC;\n\t\telse\n\t\t\tvsc->colorimetry = DP_COLORIMETRY_DEFAULT;\n\t\tbreak;\n\t}\n\n\tvsc->bpc = crtc_state->pipe_bpp / 3;\n\n\t \n\tdrm_WARN_ON(&dev_priv->drm,\n\t\t    vsc->bpc == 6 && vsc->pixelformat != DP_PIXELFORMAT_RGB);\n\n\t \n\tvsc->dynamic_range = DP_DYNAMIC_RANGE_CTA;\n\tvsc->content_type = DP_CONTENT_TYPE_NOT_DEFINED;\n}\n\nstatic void intel_dp_compute_vsc_sdp(struct intel_dp *intel_dp,\n\t\t\t\t     struct intel_crtc_state *crtc_state,\n\t\t\t\t     const struct drm_connector_state *conn_state)\n{\n\tstruct drm_dp_vsc_sdp *vsc = &crtc_state->infoframes.vsc;\n\n\t \n\tif (crtc_state->has_psr)\n\t\treturn;\n\n\tif (!intel_dp_needs_vsc_sdp(crtc_state, conn_state))\n\t\treturn;\n\n\tcrtc_state->infoframes.enable |= intel_hdmi_infoframe_enable(DP_SDP_VSC);\n\tvsc->sdp_type = DP_SDP_VSC;\n\tintel_dp_compute_vsc_colorimetry(crtc_state, conn_state,\n\t\t\t\t\t &crtc_state->infoframes.vsc);\n}\n\nvoid intel_dp_compute_psr_vsc_sdp(struct intel_dp *intel_dp,\n\t\t\t\t  const struct intel_crtc_state *crtc_state,\n\t\t\t\t  const struct drm_connector_state *conn_state,\n\t\t\t\t  struct drm_dp_vsc_sdp *vsc)\n{\n\tvsc->sdp_type = DP_SDP_VSC;\n\n\tif (crtc_state->has_psr2) {\n\t\tif (intel_dp->psr.colorimetry_support &&\n\t\t    intel_dp_needs_vsc_sdp(crtc_state, conn_state)) {\n\t\t\t \n\t\t\tintel_dp_compute_vsc_colorimetry(crtc_state, conn_state,\n\t\t\t\t\t\t\t vsc);\n\t\t} else {\n\t\t\t \n\t\t\tvsc->revision = 0x4;\n\t\t\tvsc->length = 0xe;\n\t\t}\n\t} else {\n\t\t \n\t\tvsc->revision = 0x2;\n\t\tvsc->length = 0x8;\n\t}\n}\n\nstatic void\nintel_dp_compute_hdr_metadata_infoframe_sdp(struct intel_dp *intel_dp,\n\t\t\t\t\t    struct intel_crtc_state *crtc_state,\n\t\t\t\t\t    const struct drm_connector_state *conn_state)\n{\n\tint ret;\n\tstruct drm_i915_private *dev_priv = dp_to_i915(intel_dp);\n\tstruct hdmi_drm_infoframe *drm_infoframe = &crtc_state->infoframes.drm.drm;\n\n\tif (!conn_state->hdr_output_metadata)\n\t\treturn;\n\n\tret = drm_hdmi_infoframe_set_hdr_metadata(drm_infoframe, conn_state);\n\n\tif (ret) {\n\t\tdrm_dbg_kms(&dev_priv->drm, \"couldn't set HDR metadata in infoframe\\n\");\n\t\treturn;\n\t}\n\n\tcrtc_state->infoframes.enable |=\n\t\tintel_hdmi_infoframe_enable(HDMI_PACKET_TYPE_GAMUT_METADATA);\n}\n\nstatic bool cpu_transcoder_has_drrs(struct drm_i915_private *i915,\n\t\t\t\t    enum transcoder cpu_transcoder)\n{\n\tif (HAS_DOUBLE_BUFFERED_M_N(i915))\n\t\treturn true;\n\n\treturn intel_cpu_transcoder_has_m2_n2(i915, cpu_transcoder);\n}\n\nstatic bool can_enable_drrs(struct intel_connector *connector,\n\t\t\t    const struct intel_crtc_state *pipe_config,\n\t\t\t    const struct drm_display_mode *downclock_mode)\n{\n\tstruct drm_i915_private *i915 = to_i915(connector->base.dev);\n\n\tif (pipe_config->vrr.enable)\n\t\treturn false;\n\n\t \n\tif (pipe_config->has_psr)\n\t\treturn false;\n\n\t \n\tif (pipe_config->has_pch_encoder)\n\t\treturn false;\n\n\tif (!cpu_transcoder_has_drrs(i915, pipe_config->cpu_transcoder))\n\t\treturn false;\n\n\treturn downclock_mode &&\n\t\tintel_panel_drrs_type(connector) == DRRS_TYPE_SEAMLESS;\n}\n\nstatic void\nintel_dp_drrs_compute_config(struct intel_connector *connector,\n\t\t\t     struct intel_crtc_state *pipe_config,\n\t\t\t     int output_bpp)\n{\n\tstruct drm_i915_private *i915 = to_i915(connector->base.dev);\n\tconst struct drm_display_mode *downclock_mode =\n\t\tintel_panel_downclock_mode(connector, &pipe_config->hw.adjusted_mode);\n\tint pixel_clock;\n\n\tif (has_seamless_m_n(connector))\n\t\tpipe_config->seamless_m_n = true;\n\n\tif (!can_enable_drrs(connector, pipe_config, downclock_mode)) {\n\t\tif (intel_cpu_transcoder_has_m2_n2(i915, pipe_config->cpu_transcoder))\n\t\t\tintel_zero_m_n(&pipe_config->dp_m2_n2);\n\t\treturn;\n\t}\n\n\tif (IS_IRONLAKE(i915) || IS_SANDYBRIDGE(i915) || IS_IVYBRIDGE(i915))\n\t\tpipe_config->msa_timing_delay = connector->panel.vbt.edp.drrs_msa_timing_delay;\n\n\tpipe_config->has_drrs = true;\n\n\tpixel_clock = downclock_mode->clock;\n\tif (pipe_config->splitter.enable)\n\t\tpixel_clock /= pipe_config->splitter.link_count;\n\n\tintel_link_compute_m_n(output_bpp, pipe_config->lane_count, pixel_clock,\n\t\t\t       pipe_config->port_clock, &pipe_config->dp_m2_n2,\n\t\t\t       pipe_config->fec_enable);\n\n\t \n\tif (pipe_config->splitter.enable)\n\t\tpipe_config->dp_m2_n2.data_m *= pipe_config->splitter.link_count;\n}\n\nstatic bool intel_dp_has_audio(struct intel_encoder *encoder,\n\t\t\t       const struct drm_connector_state *conn_state)\n{\n\tstruct drm_i915_private *i915 = to_i915(encoder->base.dev);\n\tstruct intel_dp *intel_dp = enc_to_intel_dp(encoder);\n\tstruct intel_connector *connector = intel_dp->attached_connector;\n\tconst struct intel_digital_connector_state *intel_conn_state =\n\t\tto_intel_digital_connector_state(conn_state);\n\n\tif (!intel_dp_port_has_audio(i915, encoder->port))\n\t\treturn false;\n\n\tif (intel_conn_state->force_audio == HDMI_AUDIO_AUTO)\n\t\treturn connector->base.display_info.has_audio;\n\telse\n\t\treturn intel_conn_state->force_audio == HDMI_AUDIO_ON;\n}\n\nstatic int\nintel_dp_compute_output_format(struct intel_encoder *encoder,\n\t\t\t       struct intel_crtc_state *crtc_state,\n\t\t\t       struct drm_connector_state *conn_state,\n\t\t\t       bool respect_downstream_limits)\n{\n\tstruct drm_i915_private *i915 = to_i915(encoder->base.dev);\n\tstruct intel_dp *intel_dp = enc_to_intel_dp(encoder);\n\tstruct intel_connector *connector = intel_dp->attached_connector;\n\tconst struct drm_display_info *info = &connector->base.display_info;\n\tconst struct drm_display_mode *adjusted_mode = &crtc_state->hw.adjusted_mode;\n\tbool ycbcr_420_only;\n\tint ret;\n\n\tycbcr_420_only = drm_mode_is_420_only(info, adjusted_mode);\n\n\tif (ycbcr_420_only && !connector->base.ycbcr_420_allowed) {\n\t\tdrm_dbg_kms(&i915->drm,\n\t\t\t    \"YCbCr 4:2:0 mode but YCbCr 4:2:0 output not possible. Falling back to RGB.\\n\");\n\t\tcrtc_state->sink_format = INTEL_OUTPUT_FORMAT_RGB;\n\t} else {\n\t\tcrtc_state->sink_format = intel_dp_sink_format(connector, adjusted_mode);\n\t}\n\n\tcrtc_state->output_format = intel_dp_output_format(connector, crtc_state->sink_format);\n\n\tret = intel_dp_compute_link_config(encoder, crtc_state, conn_state,\n\t\t\t\t\t   respect_downstream_limits);\n\tif (ret) {\n\t\tif (crtc_state->sink_format == INTEL_OUTPUT_FORMAT_YCBCR420 ||\n\t\t    !connector->base.ycbcr_420_allowed ||\n\t\t    !drm_mode_is_420_also(info, adjusted_mode))\n\t\t\treturn ret;\n\n\t\tcrtc_state->sink_format = INTEL_OUTPUT_FORMAT_YCBCR420;\n\t\tcrtc_state->output_format = intel_dp_output_format(connector,\n\t\t\t\t\t\t\t\t   crtc_state->sink_format);\n\t\tret = intel_dp_compute_link_config(encoder, crtc_state, conn_state,\n\t\t\t\t\t\t   respect_downstream_limits);\n\t}\n\n\treturn ret;\n}\n\nstatic void\nintel_dp_audio_compute_config(struct intel_encoder *encoder,\n\t\t\t      struct intel_crtc_state *pipe_config,\n\t\t\t      struct drm_connector_state *conn_state)\n{\n\tstruct drm_i915_private *i915 = to_i915(encoder->base.dev);\n\tstruct drm_connector *connector = conn_state->connector;\n\n\tpipe_config->sdp_split_enable =\n\t\tintel_dp_has_audio(encoder, conn_state) &&\n\t\tintel_dp_is_uhbr(pipe_config);\n\n\tdrm_dbg_kms(&i915->drm, \"[CONNECTOR:%d:%s] SDP split enable: %s\\n\",\n\t\t    connector->base.id, connector->name,\n\t\t    str_yes_no(pipe_config->sdp_split_enable));\n}\n\nint\nintel_dp_compute_config(struct intel_encoder *encoder,\n\t\t\tstruct intel_crtc_state *pipe_config,\n\t\t\tstruct drm_connector_state *conn_state)\n{\n\tstruct drm_i915_private *dev_priv = to_i915(encoder->base.dev);\n\tstruct drm_display_mode *adjusted_mode = &pipe_config->hw.adjusted_mode;\n\tstruct intel_dp *intel_dp = enc_to_intel_dp(encoder);\n\tconst struct drm_display_mode *fixed_mode;\n\tstruct intel_connector *connector = intel_dp->attached_connector;\n\tint ret = 0, output_bpp;\n\n\tif (HAS_PCH_SPLIT(dev_priv) && !HAS_DDI(dev_priv) && encoder->port != PORT_A)\n\t\tpipe_config->has_pch_encoder = true;\n\n\tpipe_config->has_audio =\n\t\tintel_dp_has_audio(encoder, conn_state) &&\n\t\tintel_audio_compute_config(encoder, pipe_config, conn_state);\n\n\tfixed_mode = intel_panel_fixed_mode(connector, adjusted_mode);\n\tif (intel_dp_is_edp(intel_dp) && fixed_mode) {\n\t\tret = intel_panel_compute_config(connector, adjusted_mode);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tif (adjusted_mode->flags & DRM_MODE_FLAG_DBLSCAN)\n\t\treturn -EINVAL;\n\n\tif (!connector->base.interlace_allowed &&\n\t    adjusted_mode->flags & DRM_MODE_FLAG_INTERLACE)\n\t\treturn -EINVAL;\n\n\tif (adjusted_mode->flags & DRM_MODE_FLAG_DBLCLK)\n\t\treturn -EINVAL;\n\n\tif (intel_dp_hdisplay_bad(dev_priv, adjusted_mode->crtc_hdisplay))\n\t\treturn -EINVAL;\n\n\t \n\tret = intel_dp_compute_output_format(encoder, pipe_config, conn_state, true);\n\tif (ret)\n\t\tret = intel_dp_compute_output_format(encoder, pipe_config, conn_state, false);\n\tif (ret)\n\t\treturn ret;\n\n\tif ((intel_dp_is_edp(intel_dp) && fixed_mode) ||\n\t    pipe_config->output_format == INTEL_OUTPUT_FORMAT_YCBCR420) {\n\t\tret = intel_panel_fitting(pipe_config, conn_state);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tpipe_config->limited_color_range =\n\t\tintel_dp_limited_color_range(pipe_config, conn_state);\n\n\tpipe_config->enhanced_framing =\n\t\tdrm_dp_enhanced_frame_cap(intel_dp->dpcd);\n\n\tif (pipe_config->dsc.compression_enable)\n\t\toutput_bpp = pipe_config->dsc.compressed_bpp;\n\telse\n\t\toutput_bpp = intel_dp_output_bpp(pipe_config->output_format,\n\t\t\t\t\t\t pipe_config->pipe_bpp);\n\n\tif (intel_dp->mso_link_count) {\n\t\tint n = intel_dp->mso_link_count;\n\t\tint overlap = intel_dp->mso_pixel_overlap;\n\n\t\tpipe_config->splitter.enable = true;\n\t\tpipe_config->splitter.link_count = n;\n\t\tpipe_config->splitter.pixel_overlap = overlap;\n\n\t\tdrm_dbg_kms(&dev_priv->drm, \"MSO link count %d, pixel overlap %d\\n\",\n\t\t\t    n, overlap);\n\n\t\tadjusted_mode->crtc_hdisplay = adjusted_mode->crtc_hdisplay / n + overlap;\n\t\tadjusted_mode->crtc_hblank_start = adjusted_mode->crtc_hblank_start / n + overlap;\n\t\tadjusted_mode->crtc_hblank_end = adjusted_mode->crtc_hblank_end / n + overlap;\n\t\tadjusted_mode->crtc_hsync_start = adjusted_mode->crtc_hsync_start / n + overlap;\n\t\tadjusted_mode->crtc_hsync_end = adjusted_mode->crtc_hsync_end / n + overlap;\n\t\tadjusted_mode->crtc_htotal = adjusted_mode->crtc_htotal / n + overlap;\n\t\tadjusted_mode->crtc_clock /= n;\n\t}\n\n\tintel_dp_audio_compute_config(encoder, pipe_config, conn_state);\n\n\tintel_link_compute_m_n(output_bpp,\n\t\t\t       pipe_config->lane_count,\n\t\t\t       adjusted_mode->crtc_clock,\n\t\t\t       pipe_config->port_clock,\n\t\t\t       &pipe_config->dp_m_n,\n\t\t\t       pipe_config->fec_enable);\n\n\t \n\tif (pipe_config->splitter.enable)\n\t\tpipe_config->dp_m_n.data_m *= pipe_config->splitter.link_count;\n\n\tif (!HAS_DDI(dev_priv))\n\t\tg4x_dp_set_clock(encoder, pipe_config);\n\n\tintel_vrr_compute_config(pipe_config, conn_state);\n\tintel_psr_compute_config(intel_dp, pipe_config, conn_state);\n\tintel_dp_drrs_compute_config(connector, pipe_config, output_bpp);\n\tintel_dp_compute_vsc_sdp(intel_dp, pipe_config, conn_state);\n\tintel_dp_compute_hdr_metadata_infoframe_sdp(intel_dp, pipe_config, conn_state);\n\n\treturn 0;\n}\n\nvoid intel_dp_set_link_params(struct intel_dp *intel_dp,\n\t\t\t      int link_rate, int lane_count)\n{\n\tmemset(intel_dp->train_set, 0, sizeof(intel_dp->train_set));\n\tintel_dp->link_trained = false;\n\tintel_dp->link_rate = link_rate;\n\tintel_dp->lane_count = lane_count;\n}\n\nstatic void intel_dp_reset_max_link_params(struct intel_dp *intel_dp)\n{\n\tintel_dp->max_link_lane_count = intel_dp_max_common_lane_count(intel_dp);\n\tintel_dp->max_link_rate = intel_dp_max_common_rate(intel_dp);\n}\n\n \nvoid intel_edp_backlight_on(const struct intel_crtc_state *crtc_state,\n\t\t\t    const struct drm_connector_state *conn_state)\n{\n\tstruct intel_dp *intel_dp = enc_to_intel_dp(to_intel_encoder(conn_state->best_encoder));\n\tstruct drm_i915_private *i915 = dp_to_i915(intel_dp);\n\n\tif (!intel_dp_is_edp(intel_dp))\n\t\treturn;\n\n\tdrm_dbg_kms(&i915->drm, \"\\n\");\n\n\tintel_backlight_enable(crtc_state, conn_state);\n\tintel_pps_backlight_on(intel_dp);\n}\n\n \nvoid intel_edp_backlight_off(const struct drm_connector_state *old_conn_state)\n{\n\tstruct intel_dp *intel_dp = enc_to_intel_dp(to_intel_encoder(old_conn_state->best_encoder));\n\tstruct drm_i915_private *i915 = dp_to_i915(intel_dp);\n\n\tif (!intel_dp_is_edp(intel_dp))\n\t\treturn;\n\n\tdrm_dbg_kms(&i915->drm, \"\\n\");\n\n\tintel_pps_backlight_off(intel_dp);\n\tintel_backlight_disable(old_conn_state);\n}\n\nstatic bool downstream_hpd_needs_d0(struct intel_dp *intel_dp)\n{\n\t \n\treturn intel_dp->dpcd[DP_DPCD_REV] == 0x11 &&\n\t\tdrm_dp_is_branch(intel_dp->dpcd) &&\n\t\tintel_dp->downstream_ports[0] & DP_DS_PORT_HPD;\n}\n\nvoid intel_dp_sink_set_decompression_state(struct intel_dp *intel_dp,\n\t\t\t\t\t   const struct intel_crtc_state *crtc_state,\n\t\t\t\t\t   bool enable)\n{\n\tstruct drm_i915_private *i915 = dp_to_i915(intel_dp);\n\tint ret;\n\n\tif (!crtc_state->dsc.compression_enable)\n\t\treturn;\n\n\tret = drm_dp_dpcd_writeb(&intel_dp->aux, DP_DSC_ENABLE,\n\t\t\t\t enable ? DP_DECOMPRESSION_EN : 0);\n\tif (ret < 0)\n\t\tdrm_dbg_kms(&i915->drm,\n\t\t\t    \"Failed to %s sink decompression state\\n\",\n\t\t\t    str_enable_disable(enable));\n}\n\nstatic void\nintel_edp_init_source_oui(struct intel_dp *intel_dp, bool careful)\n{\n\tstruct drm_i915_private *i915 = dp_to_i915(intel_dp);\n\tu8 oui[] = { 0x00, 0xaa, 0x01 };\n\tu8 buf[3] = { 0 };\n\n\t \n\tif (careful) {\n\t\tif (drm_dp_dpcd_read(&intel_dp->aux, DP_SOURCE_OUI, buf, sizeof(buf)) < 0)\n\t\t\tdrm_err(&i915->drm, \"Failed to read source OUI\\n\");\n\n\t\tif (memcmp(oui, buf, sizeof(oui)) == 0)\n\t\t\treturn;\n\t}\n\n\tif (drm_dp_dpcd_write(&intel_dp->aux, DP_SOURCE_OUI, oui, sizeof(oui)) < 0)\n\t\tdrm_err(&i915->drm, \"Failed to write source OUI\\n\");\n\n\tintel_dp->last_oui_write = jiffies;\n}\n\nvoid intel_dp_wait_source_oui(struct intel_dp *intel_dp)\n{\n\tstruct intel_connector *connector = intel_dp->attached_connector;\n\tstruct drm_i915_private *i915 = dp_to_i915(intel_dp);\n\n\tdrm_dbg_kms(&i915->drm, \"[CONNECTOR:%d:%s] Performing OUI wait (%u ms)\\n\",\n\t\t    connector->base.base.id, connector->base.name,\n\t\t    connector->panel.vbt.backlight.hdr_dpcd_refresh_timeout);\n\n\twait_remaining_ms_from_jiffies(intel_dp->last_oui_write,\n\t\t\t\t       connector->panel.vbt.backlight.hdr_dpcd_refresh_timeout);\n}\n\n \nvoid intel_dp_set_power(struct intel_dp *intel_dp, u8 mode)\n{\n\tstruct intel_encoder *encoder = &dp_to_dig_port(intel_dp)->base;\n\tstruct drm_i915_private *i915 = to_i915(encoder->base.dev);\n\tint ret, i;\n\n\t \n\tif (intel_dp->dpcd[DP_DPCD_REV] < 0x11)\n\t\treturn;\n\n\tif (mode != DP_SET_POWER_D0) {\n\t\tif (downstream_hpd_needs_d0(intel_dp))\n\t\t\treturn;\n\n\t\tret = drm_dp_dpcd_writeb(&intel_dp->aux, DP_SET_POWER, mode);\n\t} else {\n\t\tstruct intel_lspcon *lspcon = dp_to_lspcon(intel_dp);\n\n\t\tlspcon_resume(dp_to_dig_port(intel_dp));\n\n\t\t \n\t\tif (intel_dp_is_edp(intel_dp))\n\t\t\tintel_edp_init_source_oui(intel_dp, false);\n\n\t\t \n\t\tfor (i = 0; i < 3; i++) {\n\t\t\tret = drm_dp_dpcd_writeb(&intel_dp->aux, DP_SET_POWER, mode);\n\t\t\tif (ret == 1)\n\t\t\t\tbreak;\n\t\t\tmsleep(1);\n\t\t}\n\n\t\tif (ret == 1 && lspcon->active)\n\t\t\tlspcon_wait_pcon_mode(lspcon);\n\t}\n\n\tif (ret != 1)\n\t\tdrm_dbg_kms(&i915->drm, \"[ENCODER:%d:%s] Set power to %s failed\\n\",\n\t\t\t    encoder->base.base.id, encoder->base.name,\n\t\t\t    mode == DP_SET_POWER_D0 ? \"D0\" : \"D3\");\n}\n\nstatic bool\nintel_dp_get_dpcd(struct intel_dp *intel_dp);\n\n \nvoid intel_dp_sync_state(struct intel_encoder *encoder,\n\t\t\t const struct intel_crtc_state *crtc_state)\n{\n\tstruct intel_dp *intel_dp = enc_to_intel_dp(encoder);\n\n\tif (!crtc_state)\n\t\treturn;\n\n\t \n\tif (intel_dp->dpcd[DP_DPCD_REV] == 0)\n\t\tintel_dp_get_dpcd(intel_dp);\n\n\tintel_dp_reset_max_link_params(intel_dp);\n}\n\nbool intel_dp_initial_fastset_check(struct intel_encoder *encoder,\n\t\t\t\t    struct intel_crtc_state *crtc_state)\n{\n\tstruct drm_i915_private *i915 = to_i915(encoder->base.dev);\n\tstruct intel_dp *intel_dp = enc_to_intel_dp(encoder);\n\tbool fastset = true;\n\n\t \n\tif (intel_dp_rate_index(intel_dp->source_rates, intel_dp->num_source_rates,\n\t\t\t\tcrtc_state->port_clock) < 0) {\n\t\tdrm_dbg_kms(&i915->drm, \"[ENCODER:%d:%s] Forcing full modeset due to unsupported link rate\\n\",\n\t\t\t    encoder->base.base.id, encoder->base.name);\n\t\tcrtc_state->uapi.connectors_changed = true;\n\t\tfastset = false;\n\t}\n\n\t \n\tif (crtc_state->dsc.compression_enable) {\n\t\tdrm_dbg_kms(&i915->drm, \"[ENCODER:%d:%s] Forcing full modeset due to DSC being enabled\\n\",\n\t\t\t    encoder->base.base.id, encoder->base.name);\n\t\tcrtc_state->uapi.mode_changed = true;\n\t\tfastset = false;\n\t}\n\n\tif (CAN_PSR(intel_dp)) {\n\t\tdrm_dbg_kms(&i915->drm, \"[ENCODER:%d:%s] Forcing full modeset to compute PSR state\\n\",\n\t\t\t    encoder->base.base.id, encoder->base.name);\n\t\tcrtc_state->uapi.mode_changed = true;\n\t\tfastset = false;\n\t}\n\n\treturn fastset;\n}\n\nstatic void intel_dp_get_pcon_dsc_cap(struct intel_dp *intel_dp)\n{\n\tstruct drm_i915_private *i915 = dp_to_i915(intel_dp);\n\n\t \n\n\tmemset(intel_dp->pcon_dsc_dpcd, 0, sizeof(intel_dp->pcon_dsc_dpcd));\n\n\tif (drm_dp_dpcd_read(&intel_dp->aux, DP_PCON_DSC_ENCODER,\n\t\t\t     intel_dp->pcon_dsc_dpcd,\n\t\t\t     sizeof(intel_dp->pcon_dsc_dpcd)) < 0)\n\t\tdrm_err(&i915->drm, \"Failed to read DPCD register 0x%x\\n\",\n\t\t\tDP_PCON_DSC_ENCODER);\n\n\tdrm_dbg_kms(&i915->drm, \"PCON ENCODER DSC DPCD: %*ph\\n\",\n\t\t    (int)sizeof(intel_dp->pcon_dsc_dpcd), intel_dp->pcon_dsc_dpcd);\n}\n\nstatic int intel_dp_pcon_get_frl_mask(u8 frl_bw_mask)\n{\n\tint bw_gbps[] = {9, 18, 24, 32, 40, 48};\n\tint i;\n\n\tfor (i = ARRAY_SIZE(bw_gbps) - 1; i >= 0; i--) {\n\t\tif (frl_bw_mask & (1 << i))\n\t\t\treturn bw_gbps[i];\n\t}\n\treturn 0;\n}\n\nstatic int intel_dp_pcon_set_frl_mask(int max_frl)\n{\n\tswitch (max_frl) {\n\tcase 48:\n\t\treturn DP_PCON_FRL_BW_MASK_48GBPS;\n\tcase 40:\n\t\treturn DP_PCON_FRL_BW_MASK_40GBPS;\n\tcase 32:\n\t\treturn DP_PCON_FRL_BW_MASK_32GBPS;\n\tcase 24:\n\t\treturn DP_PCON_FRL_BW_MASK_24GBPS;\n\tcase 18:\n\t\treturn DP_PCON_FRL_BW_MASK_18GBPS;\n\tcase 9:\n\t\treturn DP_PCON_FRL_BW_MASK_9GBPS;\n\t}\n\n\treturn 0;\n}\n\nstatic int intel_dp_hdmi_sink_max_frl(struct intel_dp *intel_dp)\n{\n\tstruct intel_connector *intel_connector = intel_dp->attached_connector;\n\tstruct drm_connector *connector = &intel_connector->base;\n\tint max_frl_rate;\n\tint max_lanes, rate_per_lane;\n\tint max_dsc_lanes, dsc_rate_per_lane;\n\n\tmax_lanes = connector->display_info.hdmi.max_lanes;\n\trate_per_lane = connector->display_info.hdmi.max_frl_rate_per_lane;\n\tmax_frl_rate = max_lanes * rate_per_lane;\n\n\tif (connector->display_info.hdmi.dsc_cap.v_1p2) {\n\t\tmax_dsc_lanes = connector->display_info.hdmi.dsc_cap.max_lanes;\n\t\tdsc_rate_per_lane = connector->display_info.hdmi.dsc_cap.max_frl_rate_per_lane;\n\t\tif (max_dsc_lanes && dsc_rate_per_lane)\n\t\t\tmax_frl_rate = min(max_frl_rate, max_dsc_lanes * dsc_rate_per_lane);\n\t}\n\n\treturn max_frl_rate;\n}\n\nstatic bool\nintel_dp_pcon_is_frl_trained(struct intel_dp *intel_dp,\n\t\t\t     u8 max_frl_bw_mask, u8 *frl_trained_mask)\n{\n\tif (drm_dp_pcon_hdmi_link_active(&intel_dp->aux) &&\n\t    drm_dp_pcon_hdmi_link_mode(&intel_dp->aux, frl_trained_mask) == DP_PCON_HDMI_MODE_FRL &&\n\t    *frl_trained_mask >= max_frl_bw_mask)\n\t\treturn true;\n\n\treturn false;\n}\n\nstatic int intel_dp_pcon_start_frl_training(struct intel_dp *intel_dp)\n{\n#define TIMEOUT_FRL_READY_MS 500\n#define TIMEOUT_HDMI_LINK_ACTIVE_MS 1000\n\n\tstruct drm_i915_private *i915 = dp_to_i915(intel_dp);\n\tint max_frl_bw, max_pcon_frl_bw, max_edid_frl_bw, ret;\n\tu8 max_frl_bw_mask = 0, frl_trained_mask;\n\tbool is_active;\n\n\tmax_pcon_frl_bw = intel_dp->dfp.pcon_max_frl_bw;\n\tdrm_dbg(&i915->drm, \"PCON max rate = %d Gbps\\n\", max_pcon_frl_bw);\n\n\tmax_edid_frl_bw = intel_dp_hdmi_sink_max_frl(intel_dp);\n\tdrm_dbg(&i915->drm, \"Sink max rate from EDID = %d Gbps\\n\", max_edid_frl_bw);\n\n\tmax_frl_bw = min(max_edid_frl_bw, max_pcon_frl_bw);\n\n\tif (max_frl_bw <= 0)\n\t\treturn -EINVAL;\n\n\tmax_frl_bw_mask = intel_dp_pcon_set_frl_mask(max_frl_bw);\n\tdrm_dbg(&i915->drm, \"MAX_FRL_BW_MASK = %u\\n\", max_frl_bw_mask);\n\n\tif (intel_dp_pcon_is_frl_trained(intel_dp, max_frl_bw_mask, &frl_trained_mask))\n\t\tgoto frl_trained;\n\n\tret = drm_dp_pcon_frl_prepare(&intel_dp->aux, false);\n\tif (ret < 0)\n\t\treturn ret;\n\t \n\twait_for(is_active = drm_dp_pcon_is_frl_ready(&intel_dp->aux) == true, TIMEOUT_FRL_READY_MS);\n\n\tif (!is_active)\n\t\treturn -ETIMEDOUT;\n\n\tret = drm_dp_pcon_frl_configure_1(&intel_dp->aux, max_frl_bw,\n\t\t\t\t\t  DP_PCON_ENABLE_SEQUENTIAL_LINK);\n\tif (ret < 0)\n\t\treturn ret;\n\tret = drm_dp_pcon_frl_configure_2(&intel_dp->aux, max_frl_bw_mask,\n\t\t\t\t\t  DP_PCON_FRL_LINK_TRAIN_NORMAL);\n\tif (ret < 0)\n\t\treturn ret;\n\tret = drm_dp_pcon_frl_enable(&intel_dp->aux);\n\tif (ret < 0)\n\t\treturn ret;\n\t \n\twait_for(is_active =\n\t\t intel_dp_pcon_is_frl_trained(intel_dp, max_frl_bw_mask, &frl_trained_mask),\n\t\t TIMEOUT_HDMI_LINK_ACTIVE_MS);\n\n\tif (!is_active)\n\t\treturn -ETIMEDOUT;\n\nfrl_trained:\n\tdrm_dbg(&i915->drm, \"FRL_TRAINED_MASK = %u\\n\", frl_trained_mask);\n\tintel_dp->frl.trained_rate_gbps = intel_dp_pcon_get_frl_mask(frl_trained_mask);\n\tintel_dp->frl.is_trained = true;\n\tdrm_dbg(&i915->drm, \"FRL trained with : %d Gbps\\n\", intel_dp->frl.trained_rate_gbps);\n\n\treturn 0;\n}\n\nstatic bool intel_dp_is_hdmi_2_1_sink(struct intel_dp *intel_dp)\n{\n\tif (drm_dp_is_branch(intel_dp->dpcd) &&\n\t    intel_dp_has_hdmi_sink(intel_dp) &&\n\t    intel_dp_hdmi_sink_max_frl(intel_dp) > 0)\n\t\treturn true;\n\n\treturn false;\n}\n\nstatic\nint intel_dp_pcon_set_tmds_mode(struct intel_dp *intel_dp)\n{\n\tint ret;\n\tu8 buf = 0;\n\n\t \n\tbuf |= DP_PCON_ENABLE_SOURCE_CTL_MODE;\n\n\tret = drm_dp_dpcd_writeb(&intel_dp->aux, DP_PCON_HDMI_LINK_CONFIG_1, buf);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tbuf |= DP_PCON_ENABLE_HDMI_LINK;\n\tret = drm_dp_dpcd_writeb(&intel_dp->aux, DP_PCON_HDMI_LINK_CONFIG_1, buf);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn 0;\n}\n\nvoid intel_dp_check_frl_training(struct intel_dp *intel_dp)\n{\n\tstruct drm_i915_private *dev_priv = dp_to_i915(intel_dp);\n\n\t \n\tif (!(intel_dp->downstream_ports[2] & DP_PCON_SOURCE_CTL_MODE) ||\n\t    !intel_dp_is_hdmi_2_1_sink(intel_dp) ||\n\t    intel_dp->frl.is_trained)\n\t\treturn;\n\n\tif (intel_dp_pcon_start_frl_training(intel_dp) < 0) {\n\t\tint ret, mode;\n\n\t\tdrm_dbg(&dev_priv->drm, \"Couldn't set FRL mode, continuing with TMDS mode\\n\");\n\t\tret = intel_dp_pcon_set_tmds_mode(intel_dp);\n\t\tmode = drm_dp_pcon_hdmi_link_mode(&intel_dp->aux, NULL);\n\n\t\tif (ret < 0 || mode != DP_PCON_HDMI_MODE_TMDS)\n\t\t\tdrm_dbg(&dev_priv->drm, \"Issue with PCON, cannot set TMDS mode\\n\");\n\t} else {\n\t\tdrm_dbg(&dev_priv->drm, \"FRL training Completed\\n\");\n\t}\n}\n\nstatic int\nintel_dp_pcon_dsc_enc_slice_height(const struct intel_crtc_state *crtc_state)\n{\n\tint vactive = crtc_state->hw.adjusted_mode.vdisplay;\n\n\treturn intel_hdmi_dsc_get_slice_height(vactive);\n}\n\nstatic int\nintel_dp_pcon_dsc_enc_slices(struct intel_dp *intel_dp,\n\t\t\t     const struct intel_crtc_state *crtc_state)\n{\n\tstruct intel_connector *intel_connector = intel_dp->attached_connector;\n\tstruct drm_connector *connector = &intel_connector->base;\n\tint hdmi_throughput = connector->display_info.hdmi.dsc_cap.clk_per_slice;\n\tint hdmi_max_slices = connector->display_info.hdmi.dsc_cap.max_slices;\n\tint pcon_max_slices = drm_dp_pcon_dsc_max_slices(intel_dp->pcon_dsc_dpcd);\n\tint pcon_max_slice_width = drm_dp_pcon_dsc_max_slice_width(intel_dp->pcon_dsc_dpcd);\n\n\treturn intel_hdmi_dsc_get_num_slices(crtc_state, pcon_max_slices,\n\t\t\t\t\t     pcon_max_slice_width,\n\t\t\t\t\t     hdmi_max_slices, hdmi_throughput);\n}\n\nstatic int\nintel_dp_pcon_dsc_enc_bpp(struct intel_dp *intel_dp,\n\t\t\t  const struct intel_crtc_state *crtc_state,\n\t\t\t  int num_slices, int slice_width)\n{\n\tstruct intel_connector *intel_connector = intel_dp->attached_connector;\n\tstruct drm_connector *connector = &intel_connector->base;\n\tint output_format = crtc_state->output_format;\n\tbool hdmi_all_bpp = connector->display_info.hdmi.dsc_cap.all_bpp;\n\tint pcon_fractional_bpp = drm_dp_pcon_dsc_bpp_incr(intel_dp->pcon_dsc_dpcd);\n\tint hdmi_max_chunk_bytes =\n\t\tconnector->display_info.hdmi.dsc_cap.total_chunk_kbytes * 1024;\n\n\treturn intel_hdmi_dsc_get_bpp(pcon_fractional_bpp, slice_width,\n\t\t\t\t      num_slices, output_format, hdmi_all_bpp,\n\t\t\t\t      hdmi_max_chunk_bytes);\n}\n\nvoid\nintel_dp_pcon_dsc_configure(struct intel_dp *intel_dp,\n\t\t\t    const struct intel_crtc_state *crtc_state)\n{\n\tu8 pps_param[6];\n\tint slice_height;\n\tint slice_width;\n\tint num_slices;\n\tint bits_per_pixel;\n\tint ret;\n\tstruct intel_connector *intel_connector = intel_dp->attached_connector;\n\tstruct drm_i915_private *i915 = dp_to_i915(intel_dp);\n\tstruct drm_connector *connector;\n\tbool hdmi_is_dsc_1_2;\n\n\tif (!intel_dp_is_hdmi_2_1_sink(intel_dp))\n\t\treturn;\n\n\tif (!intel_connector)\n\t\treturn;\n\tconnector = &intel_connector->base;\n\thdmi_is_dsc_1_2 = connector->display_info.hdmi.dsc_cap.v_1p2;\n\n\tif (!drm_dp_pcon_enc_is_dsc_1_2(intel_dp->pcon_dsc_dpcd) ||\n\t    !hdmi_is_dsc_1_2)\n\t\treturn;\n\n\tslice_height = intel_dp_pcon_dsc_enc_slice_height(crtc_state);\n\tif (!slice_height)\n\t\treturn;\n\n\tnum_slices = intel_dp_pcon_dsc_enc_slices(intel_dp, crtc_state);\n\tif (!num_slices)\n\t\treturn;\n\n\tslice_width = DIV_ROUND_UP(crtc_state->hw.adjusted_mode.hdisplay,\n\t\t\t\t   num_slices);\n\n\tbits_per_pixel = intel_dp_pcon_dsc_enc_bpp(intel_dp, crtc_state,\n\t\t\t\t\t\t   num_slices, slice_width);\n\tif (!bits_per_pixel)\n\t\treturn;\n\n\tpps_param[0] = slice_height & 0xFF;\n\tpps_param[1] = slice_height >> 8;\n\tpps_param[2] = slice_width & 0xFF;\n\tpps_param[3] = slice_width >> 8;\n\tpps_param[4] = bits_per_pixel & 0xFF;\n\tpps_param[5] = (bits_per_pixel >> 8) & 0x3;\n\n\tret = drm_dp_pcon_pps_override_param(&intel_dp->aux, pps_param);\n\tif (ret < 0)\n\t\tdrm_dbg_kms(&i915->drm, \"Failed to set pcon DSC\\n\");\n}\n\nvoid intel_dp_configure_protocol_converter(struct intel_dp *intel_dp,\n\t\t\t\t\t   const struct intel_crtc_state *crtc_state)\n{\n\tstruct drm_i915_private *i915 = dp_to_i915(intel_dp);\n\tbool ycbcr444_to_420 = false;\n\tbool rgb_to_ycbcr = false;\n\tu8 tmp;\n\n\tif (intel_dp->dpcd[DP_DPCD_REV] < 0x13)\n\t\treturn;\n\n\tif (!drm_dp_is_branch(intel_dp->dpcd))\n\t\treturn;\n\n\ttmp = intel_dp_has_hdmi_sink(intel_dp) ? DP_HDMI_DVI_OUTPUT_CONFIG : 0;\n\n\tif (drm_dp_dpcd_writeb(&intel_dp->aux,\n\t\t\t       DP_PROTOCOL_CONVERTER_CONTROL_0, tmp) != 1)\n\t\tdrm_dbg_kms(&i915->drm, \"Failed to %s protocol converter HDMI mode\\n\",\n\t\t\t    str_enable_disable(intel_dp_has_hdmi_sink(intel_dp)));\n\n\tif (crtc_state->sink_format == INTEL_OUTPUT_FORMAT_YCBCR420) {\n\t\tswitch (crtc_state->output_format) {\n\t\tcase INTEL_OUTPUT_FORMAT_YCBCR420:\n\t\t\tbreak;\n\t\tcase INTEL_OUTPUT_FORMAT_YCBCR444:\n\t\t\tycbcr444_to_420 = true;\n\t\t\tbreak;\n\t\tcase INTEL_OUTPUT_FORMAT_RGB:\n\t\t\trgb_to_ycbcr = true;\n\t\t\tycbcr444_to_420 = true;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tMISSING_CASE(crtc_state->output_format);\n\t\t\tbreak;\n\t\t}\n\t} else if (crtc_state->sink_format == INTEL_OUTPUT_FORMAT_YCBCR444) {\n\t\tswitch (crtc_state->output_format) {\n\t\tcase INTEL_OUTPUT_FORMAT_YCBCR444:\n\t\t\tbreak;\n\t\tcase INTEL_OUTPUT_FORMAT_RGB:\n\t\t\trgb_to_ycbcr = true;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tMISSING_CASE(crtc_state->output_format);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\ttmp = ycbcr444_to_420 ? DP_CONVERSION_TO_YCBCR420_ENABLE : 0;\n\n\tif (drm_dp_dpcd_writeb(&intel_dp->aux,\n\t\t\t       DP_PROTOCOL_CONVERTER_CONTROL_1, tmp) != 1)\n\t\tdrm_dbg_kms(&i915->drm,\n\t\t\t    \"Failed to %s protocol converter YCbCr 4:2:0 conversion mode\\n\",\n\t\t\t    str_enable_disable(intel_dp->dfp.ycbcr_444_to_420));\n\n\ttmp = rgb_to_ycbcr ? DP_CONVERSION_BT709_RGB_YCBCR_ENABLE : 0;\n\n\tif (drm_dp_pcon_convert_rgb_to_ycbcr(&intel_dp->aux, tmp) < 0)\n\t\tdrm_dbg_kms(&i915->drm,\n\t\t\t    \"Failed to %s protocol converter RGB->YCbCr conversion mode\\n\",\n\t\t\t    str_enable_disable(tmp));\n}\n\nbool intel_dp_get_colorimetry_status(struct intel_dp *intel_dp)\n{\n\tu8 dprx = 0;\n\n\tif (drm_dp_dpcd_readb(&intel_dp->aux, DP_DPRX_FEATURE_ENUMERATION_LIST,\n\t\t\t      &dprx) != 1)\n\t\treturn false;\n\treturn dprx & DP_VSC_SDP_EXT_FOR_COLORIMETRY_SUPPORTED;\n}\n\nstatic void intel_dp_get_dsc_sink_cap(struct intel_dp *intel_dp)\n{\n\tstruct drm_i915_private *i915 = dp_to_i915(intel_dp);\n\n\t \n\tmemset(intel_dp->dsc_dpcd, 0, sizeof(intel_dp->dsc_dpcd));\n\n\t \n\tintel_dp->fec_capable = 0;\n\n\t \n\tif (intel_dp->dpcd[DP_DPCD_REV] >= 0x14 ||\n\t    intel_dp->edp_dpcd[0] >= DP_EDP_14) {\n\t\tif (drm_dp_dpcd_read(&intel_dp->aux, DP_DSC_SUPPORT,\n\t\t\t\t     intel_dp->dsc_dpcd,\n\t\t\t\t     sizeof(intel_dp->dsc_dpcd)) < 0)\n\t\t\tdrm_err(&i915->drm,\n\t\t\t\t\"Failed to read DPCD register 0x%x\\n\",\n\t\t\t\tDP_DSC_SUPPORT);\n\n\t\tdrm_dbg_kms(&i915->drm, \"DSC DPCD: %*ph\\n\",\n\t\t\t    (int)sizeof(intel_dp->dsc_dpcd),\n\t\t\t    intel_dp->dsc_dpcd);\n\n\t\t \n\t\tif (!intel_dp_is_edp(intel_dp) &&\n\t\t    drm_dp_dpcd_readb(&intel_dp->aux, DP_FEC_CAPABILITY,\n\t\t\t\t      &intel_dp->fec_capable) < 0)\n\t\t\tdrm_err(&i915->drm,\n\t\t\t\t\"Failed to read FEC DPCD register\\n\");\n\n\t\tdrm_dbg_kms(&i915->drm, \"FEC CAPABILITY: %x\\n\",\n\t\t\t    intel_dp->fec_capable);\n\t}\n}\n\nstatic void intel_edp_mso_mode_fixup(struct intel_connector *connector,\n\t\t\t\t     struct drm_display_mode *mode)\n{\n\tstruct intel_dp *intel_dp = intel_attached_dp(connector);\n\tstruct drm_i915_private *i915 = to_i915(connector->base.dev);\n\tint n = intel_dp->mso_link_count;\n\tint overlap = intel_dp->mso_pixel_overlap;\n\n\tif (!mode || !n)\n\t\treturn;\n\n\tmode->hdisplay = (mode->hdisplay - overlap) * n;\n\tmode->hsync_start = (mode->hsync_start - overlap) * n;\n\tmode->hsync_end = (mode->hsync_end - overlap) * n;\n\tmode->htotal = (mode->htotal - overlap) * n;\n\tmode->clock *= n;\n\n\tdrm_mode_set_name(mode);\n\n\tdrm_dbg_kms(&i915->drm,\n\t\t    \"[CONNECTOR:%d:%s] using generated MSO mode: \" DRM_MODE_FMT \"\\n\",\n\t\t    connector->base.base.id, connector->base.name,\n\t\t    DRM_MODE_ARG(mode));\n}\n\nvoid intel_edp_fixup_vbt_bpp(struct intel_encoder *encoder, int pipe_bpp)\n{\n\tstruct drm_i915_private *dev_priv = to_i915(encoder->base.dev);\n\tstruct intel_dp *intel_dp = enc_to_intel_dp(encoder);\n\tstruct intel_connector *connector = intel_dp->attached_connector;\n\n\tif (connector->panel.vbt.edp.bpp && pipe_bpp > connector->panel.vbt.edp.bpp) {\n\t\t \n\t\tdrm_dbg_kms(&dev_priv->drm,\n\t\t\t    \"pipe has %d bpp for eDP panel, overriding BIOS-provided max %d bpp\\n\",\n\t\t\t    pipe_bpp, connector->panel.vbt.edp.bpp);\n\t\tconnector->panel.vbt.edp.bpp = pipe_bpp;\n\t}\n}\n\nstatic void intel_edp_mso_init(struct intel_dp *intel_dp)\n{\n\tstruct drm_i915_private *i915 = dp_to_i915(intel_dp);\n\tstruct intel_connector *connector = intel_dp->attached_connector;\n\tstruct drm_display_info *info = &connector->base.display_info;\n\tu8 mso;\n\n\tif (intel_dp->edp_dpcd[0] < DP_EDP_14)\n\t\treturn;\n\n\tif (drm_dp_dpcd_readb(&intel_dp->aux, DP_EDP_MSO_LINK_CAPABILITIES, &mso) != 1) {\n\t\tdrm_err(&i915->drm, \"Failed to read MSO cap\\n\");\n\t\treturn;\n\t}\n\n\t \n\tmso &= DP_EDP_MSO_NUMBER_OF_LINKS_MASK;\n\tif (mso % 2 || mso > drm_dp_max_lane_count(intel_dp->dpcd)) {\n\t\tdrm_err(&i915->drm, \"Invalid MSO link count cap %u\\n\", mso);\n\t\tmso = 0;\n\t}\n\n\tif (mso) {\n\t\tdrm_dbg_kms(&i915->drm, \"Sink MSO %ux%u configuration, pixel overlap %u\\n\",\n\t\t\t    mso, drm_dp_max_lane_count(intel_dp->dpcd) / mso,\n\t\t\t    info->mso_pixel_overlap);\n\t\tif (!HAS_MSO(i915)) {\n\t\t\tdrm_err(&i915->drm, \"No source MSO support, disabling\\n\");\n\t\t\tmso = 0;\n\t\t}\n\t}\n\n\tintel_dp->mso_link_count = mso;\n\tintel_dp->mso_pixel_overlap = mso ? info->mso_pixel_overlap : 0;\n}\n\nstatic bool\nintel_edp_init_dpcd(struct intel_dp *intel_dp)\n{\n\tstruct drm_i915_private *dev_priv =\n\t\tto_i915(dp_to_dig_port(intel_dp)->base.base.dev);\n\n\t \n\tdrm_WARN_ON(&dev_priv->drm, intel_dp->dpcd[DP_DPCD_REV] != 0);\n\n\tif (drm_dp_read_dpcd_caps(&intel_dp->aux, intel_dp->dpcd) != 0)\n\t\treturn false;\n\n\tdrm_dp_read_desc(&intel_dp->aux, &intel_dp->desc,\n\t\t\t drm_dp_is_branch(intel_dp->dpcd));\n\n\t \n\tif (drm_dp_dpcd_read(&intel_dp->aux, DP_EDP_DPCD_REV,\n\t\t\t     intel_dp->edp_dpcd, sizeof(intel_dp->edp_dpcd)) ==\n\t\t\t     sizeof(intel_dp->edp_dpcd)) {\n\t\tdrm_dbg_kms(&dev_priv->drm, \"eDP DPCD: %*ph\\n\",\n\t\t\t    (int)sizeof(intel_dp->edp_dpcd),\n\t\t\t    intel_dp->edp_dpcd);\n\n\t\tintel_dp->use_max_params = intel_dp->edp_dpcd[0] < DP_EDP_14;\n\t}\n\n\t \n\tintel_psr_init_dpcd(intel_dp);\n\n\t \n\tintel_dp->num_sink_rates = 0;\n\n\t \n\tif (intel_dp->edp_dpcd[0] >= DP_EDP_14) {\n\t\t__le16 sink_rates[DP_MAX_SUPPORTED_RATES];\n\t\tint i;\n\n\t\tdrm_dp_dpcd_read(&intel_dp->aux, DP_SUPPORTED_LINK_RATES,\n\t\t\t\tsink_rates, sizeof(sink_rates));\n\n\t\tfor (i = 0; i < ARRAY_SIZE(sink_rates); i++) {\n\t\t\tint val = le16_to_cpu(sink_rates[i]);\n\n\t\t\tif (val == 0)\n\t\t\t\tbreak;\n\n\t\t\t \n\t\t\tintel_dp->sink_rates[i] = (val * 200) / 10;\n\t\t}\n\t\tintel_dp->num_sink_rates = i;\n\t}\n\n\t \n\tif (intel_dp->num_sink_rates)\n\t\tintel_dp->use_rate_select = true;\n\telse\n\t\tintel_dp_set_sink_rates(intel_dp);\n\tintel_dp_set_max_sink_lane_count(intel_dp);\n\n\t \n\tif (HAS_DSC(dev_priv))\n\t\tintel_dp_get_dsc_sink_cap(intel_dp);\n\n\t \n\tintel_edp_init_source_oui(intel_dp, true);\n\n\treturn true;\n}\n\nstatic bool\nintel_dp_has_sink_count(struct intel_dp *intel_dp)\n{\n\tif (!intel_dp->attached_connector)\n\t\treturn false;\n\n\treturn drm_dp_read_sink_count_cap(&intel_dp->attached_connector->base,\n\t\t\t\t\t  intel_dp->dpcd,\n\t\t\t\t\t  &intel_dp->desc);\n}\n\nstatic bool\nintel_dp_get_dpcd(struct intel_dp *intel_dp)\n{\n\tint ret;\n\n\tif (intel_dp_init_lttpr_and_dprx_caps(intel_dp) < 0)\n\t\treturn false;\n\n\t \n\tif (!intel_dp_is_edp(intel_dp)) {\n\t\tdrm_dp_read_desc(&intel_dp->aux, &intel_dp->desc,\n\t\t\t\t drm_dp_is_branch(intel_dp->dpcd));\n\n\t\tintel_dp_set_sink_rates(intel_dp);\n\t\tintel_dp_set_max_sink_lane_count(intel_dp);\n\t\tintel_dp_set_common_rates(intel_dp);\n\t}\n\n\tif (intel_dp_has_sink_count(intel_dp)) {\n\t\tret = drm_dp_read_sink_count(&intel_dp->aux);\n\t\tif (ret < 0)\n\t\t\treturn false;\n\n\t\t \n\t\tintel_dp->sink_count = ret;\n\n\t\t \n\t\tif (!intel_dp->sink_count)\n\t\t\treturn false;\n\t}\n\n\treturn drm_dp_read_downstream_info(&intel_dp->aux, intel_dp->dpcd,\n\t\t\t\t\t   intel_dp->downstream_ports) == 0;\n}\n\nstatic bool\nintel_dp_can_mst(struct intel_dp *intel_dp)\n{\n\tstruct drm_i915_private *i915 = dp_to_i915(intel_dp);\n\n\treturn i915->params.enable_dp_mst &&\n\t\tintel_dp_mst_source_support(intel_dp) &&\n\t\tdrm_dp_read_mst_cap(&intel_dp->aux, intel_dp->dpcd);\n}\n\nstatic void\nintel_dp_configure_mst(struct intel_dp *intel_dp)\n{\n\tstruct drm_i915_private *i915 = dp_to_i915(intel_dp);\n\tstruct intel_encoder *encoder =\n\t\t&dp_to_dig_port(intel_dp)->base;\n\tbool sink_can_mst = drm_dp_read_mst_cap(&intel_dp->aux, intel_dp->dpcd);\n\n\tdrm_dbg_kms(&i915->drm,\n\t\t    \"[ENCODER:%d:%s] MST support: port: %s, sink: %s, modparam: %s\\n\",\n\t\t    encoder->base.base.id, encoder->base.name,\n\t\t    str_yes_no(intel_dp_mst_source_support(intel_dp)),\n\t\t    str_yes_no(sink_can_mst),\n\t\t    str_yes_no(i915->params.enable_dp_mst));\n\n\tif (!intel_dp_mst_source_support(intel_dp))\n\t\treturn;\n\n\tintel_dp->is_mst = sink_can_mst &&\n\t\ti915->params.enable_dp_mst;\n\n\tdrm_dp_mst_topology_mgr_set_mst(&intel_dp->mst_mgr,\n\t\t\t\t\tintel_dp->is_mst);\n}\n\nstatic bool\nintel_dp_get_sink_irq_esi(struct intel_dp *intel_dp, u8 *esi)\n{\n\treturn drm_dp_dpcd_read(&intel_dp->aux, DP_SINK_COUNT_ESI, esi, 4) == 4;\n}\n\nstatic bool intel_dp_ack_sink_irq_esi(struct intel_dp *intel_dp, u8 esi[4])\n{\n\tint retry;\n\n\tfor (retry = 0; retry < 3; retry++) {\n\t\tif (drm_dp_dpcd_write(&intel_dp->aux, DP_SINK_COUNT_ESI + 1,\n\t\t\t\t      &esi[1], 3) == 3)\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}\n\nbool\nintel_dp_needs_vsc_sdp(const struct intel_crtc_state *crtc_state,\n\t\t       const struct drm_connector_state *conn_state)\n{\n\t \n\tif (crtc_state->output_format == INTEL_OUTPUT_FORMAT_YCBCR420)\n\t\treturn true;\n\n\tswitch (conn_state->colorspace) {\n\tcase DRM_MODE_COLORIMETRY_SYCC_601:\n\tcase DRM_MODE_COLORIMETRY_OPYCC_601:\n\tcase DRM_MODE_COLORIMETRY_BT2020_YCC:\n\tcase DRM_MODE_COLORIMETRY_BT2020_RGB:\n\tcase DRM_MODE_COLORIMETRY_BT2020_CYCC:\n\t\treturn true;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn false;\n}\n\nstatic ssize_t intel_dp_vsc_sdp_pack(const struct drm_dp_vsc_sdp *vsc,\n\t\t\t\t     struct dp_sdp *sdp, size_t size)\n{\n\tsize_t length = sizeof(struct dp_sdp);\n\n\tif (size < length)\n\t\treturn -ENOSPC;\n\n\tmemset(sdp, 0, size);\n\n\t \n\tsdp->sdp_header.HB0 = 0;  \n\tsdp->sdp_header.HB1 = vsc->sdp_type;  \n\tsdp->sdp_header.HB2 = vsc->revision;  \n\tsdp->sdp_header.HB3 = vsc->length;  \n\n\t \n\tif (vsc->revision != 0x5)\n\t\tgoto out;\n\n\t \n\t \n\tsdp->db[16] = (vsc->pixelformat & 0xf) << 4;  \n\tsdp->db[16] |= vsc->colorimetry & 0xf;  \n\n\tswitch (vsc->bpc) {\n\tcase 6:\n\t\t \n\t\tbreak;\n\tcase 8:\n\t\tsdp->db[17] = 0x1;  \n\t\tbreak;\n\tcase 10:\n\t\tsdp->db[17] = 0x2;\n\t\tbreak;\n\tcase 12:\n\t\tsdp->db[17] = 0x3;\n\t\tbreak;\n\tcase 16:\n\t\tsdp->db[17] = 0x4;\n\t\tbreak;\n\tdefault:\n\t\tMISSING_CASE(vsc->bpc);\n\t\tbreak;\n\t}\n\t \n\tif (vsc->dynamic_range == DP_DYNAMIC_RANGE_CTA)\n\t\tsdp->db[17] |= 0x80;   \n\n\t \n\tsdp->db[18] = vsc->content_type & 0x7;\n\nout:\n\treturn length;\n}\n\nstatic ssize_t\nintel_dp_hdr_metadata_infoframe_sdp_pack(struct drm_i915_private *i915,\n\t\t\t\t\t const struct hdmi_drm_infoframe *drm_infoframe,\n\t\t\t\t\t struct dp_sdp *sdp,\n\t\t\t\t\t size_t size)\n{\n\tsize_t length = sizeof(struct dp_sdp);\n\tconst int infoframe_size = HDMI_INFOFRAME_HEADER_SIZE + HDMI_DRM_INFOFRAME_SIZE;\n\tunsigned char buf[HDMI_INFOFRAME_HEADER_SIZE + HDMI_DRM_INFOFRAME_SIZE];\n\tssize_t len;\n\n\tif (size < length)\n\t\treturn -ENOSPC;\n\n\tmemset(sdp, 0, size);\n\n\tlen = hdmi_drm_infoframe_pack_only(drm_infoframe, buf, sizeof(buf));\n\tif (len < 0) {\n\t\tdrm_dbg_kms(&i915->drm, \"buffer size is smaller than hdr metadata infoframe\\n\");\n\t\treturn -ENOSPC;\n\t}\n\n\tif (len != infoframe_size) {\n\t\tdrm_dbg_kms(&i915->drm, \"wrong static hdr metadata size\\n\");\n\t\treturn -ENOSPC;\n\t}\n\n\t \n\n\t \n\tsdp->sdp_header.HB0 = 0;\n\t \n\tsdp->sdp_header.HB1 = drm_infoframe->type;\n\t \n\tsdp->sdp_header.HB2 = 0x1D;\n\t \n\tsdp->sdp_header.HB3 = (0x13 << 2);\n\t \n\tsdp->db[0] = drm_infoframe->version;\n\t \n\tsdp->db[1] = drm_infoframe->length;\n\t \n\tBUILD_BUG_ON(sizeof(sdp->db) < HDMI_DRM_INFOFRAME_SIZE + 2);\n\tmemcpy(&sdp->db[2], &buf[HDMI_INFOFRAME_HEADER_SIZE],\n\t       HDMI_DRM_INFOFRAME_SIZE);\n\n\t \n\treturn sizeof(struct dp_sdp_header) + 2 + HDMI_DRM_INFOFRAME_SIZE;\n}\n\nstatic void intel_write_dp_sdp(struct intel_encoder *encoder,\n\t\t\t       const struct intel_crtc_state *crtc_state,\n\t\t\t       unsigned int type)\n{\n\tstruct intel_digital_port *dig_port = enc_to_dig_port(encoder);\n\tstruct drm_i915_private *dev_priv = to_i915(encoder->base.dev);\n\tstruct dp_sdp sdp = {};\n\tssize_t len;\n\n\tif ((crtc_state->infoframes.enable &\n\t     intel_hdmi_infoframe_enable(type)) == 0)\n\t\treturn;\n\n\tswitch (type) {\n\tcase DP_SDP_VSC:\n\t\tlen = intel_dp_vsc_sdp_pack(&crtc_state->infoframes.vsc, &sdp,\n\t\t\t\t\t    sizeof(sdp));\n\t\tbreak;\n\tcase HDMI_PACKET_TYPE_GAMUT_METADATA:\n\t\tlen = intel_dp_hdr_metadata_infoframe_sdp_pack(dev_priv,\n\t\t\t\t\t\t\t       &crtc_state->infoframes.drm.drm,\n\t\t\t\t\t\t\t       &sdp, sizeof(sdp));\n\t\tbreak;\n\tdefault:\n\t\tMISSING_CASE(type);\n\t\treturn;\n\t}\n\n\tif (drm_WARN_ON(&dev_priv->drm, len < 0))\n\t\treturn;\n\n\tdig_port->write_infoframe(encoder, crtc_state, type, &sdp, len);\n}\n\nvoid intel_write_dp_vsc_sdp(struct intel_encoder *encoder,\n\t\t\t    const struct intel_crtc_state *crtc_state,\n\t\t\t    const struct drm_dp_vsc_sdp *vsc)\n{\n\tstruct intel_digital_port *dig_port = enc_to_dig_port(encoder);\n\tstruct drm_i915_private *dev_priv = to_i915(encoder->base.dev);\n\tstruct dp_sdp sdp = {};\n\tssize_t len;\n\n\tlen = intel_dp_vsc_sdp_pack(vsc, &sdp, sizeof(sdp));\n\n\tif (drm_WARN_ON(&dev_priv->drm, len < 0))\n\t\treturn;\n\n\tdig_port->write_infoframe(encoder, crtc_state, DP_SDP_VSC,\n\t\t\t\t\t&sdp, len);\n}\n\nvoid intel_dp_set_infoframes(struct intel_encoder *encoder,\n\t\t\t     bool enable,\n\t\t\t     const struct intel_crtc_state *crtc_state,\n\t\t\t     const struct drm_connector_state *conn_state)\n{\n\tstruct drm_i915_private *dev_priv = to_i915(encoder->base.dev);\n\ti915_reg_t reg = HSW_TVIDEO_DIP_CTL(crtc_state->cpu_transcoder);\n\tu32 dip_enable = VIDEO_DIP_ENABLE_AVI_HSW | VIDEO_DIP_ENABLE_GCP_HSW |\n\t\t\t VIDEO_DIP_ENABLE_VS_HSW | VIDEO_DIP_ENABLE_GMP_HSW |\n\t\t\t VIDEO_DIP_ENABLE_SPD_HSW | VIDEO_DIP_ENABLE_DRM_GLK;\n\tu32 val = intel_de_read(dev_priv, reg) & ~dip_enable;\n\n\t \n\t \n\tif (!crtc_state->has_psr)\n\t\tval &= ~VIDEO_DIP_ENABLE_VSC_HSW;\n\n\tintel_de_write(dev_priv, reg, val);\n\tintel_de_posting_read(dev_priv, reg);\n\n\tif (!enable)\n\t\treturn;\n\n\t \n\tif (!crtc_state->has_psr)\n\t\tintel_write_dp_sdp(encoder, crtc_state, DP_SDP_VSC);\n\n\tintel_write_dp_sdp(encoder, crtc_state, HDMI_PACKET_TYPE_GAMUT_METADATA);\n}\n\nstatic int intel_dp_vsc_sdp_unpack(struct drm_dp_vsc_sdp *vsc,\n\t\t\t\t   const void *buffer, size_t size)\n{\n\tconst struct dp_sdp *sdp = buffer;\n\n\tif (size < sizeof(struct dp_sdp))\n\t\treturn -EINVAL;\n\n\tmemset(vsc, 0, sizeof(*vsc));\n\n\tif (sdp->sdp_header.HB0 != 0)\n\t\treturn -EINVAL;\n\n\tif (sdp->sdp_header.HB1 != DP_SDP_VSC)\n\t\treturn -EINVAL;\n\n\tvsc->sdp_type = sdp->sdp_header.HB1;\n\tvsc->revision = sdp->sdp_header.HB2;\n\tvsc->length = sdp->sdp_header.HB3;\n\n\tif ((sdp->sdp_header.HB2 == 0x2 && sdp->sdp_header.HB3 == 0x8) ||\n\t    (sdp->sdp_header.HB2 == 0x4 && sdp->sdp_header.HB3 == 0xe)) {\n\t\t \n\t\treturn 0;\n\t} else if (sdp->sdp_header.HB2 == 0x5 && sdp->sdp_header.HB3 == 0x13) {\n\t\t \n\t\tvsc->pixelformat = (sdp->db[16] >> 4) & 0xf;\n\t\tvsc->colorimetry = sdp->db[16] & 0xf;\n\t\tvsc->dynamic_range = (sdp->db[17] >> 7) & 0x1;\n\n\t\tswitch (sdp->db[17] & 0x7) {\n\t\tcase 0x0:\n\t\t\tvsc->bpc = 6;\n\t\t\tbreak;\n\t\tcase 0x1:\n\t\t\tvsc->bpc = 8;\n\t\t\tbreak;\n\t\tcase 0x2:\n\t\t\tvsc->bpc = 10;\n\t\t\tbreak;\n\t\tcase 0x3:\n\t\t\tvsc->bpc = 12;\n\t\t\tbreak;\n\t\tcase 0x4:\n\t\t\tvsc->bpc = 16;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tMISSING_CASE(sdp->db[17] & 0x7);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tvsc->content_type = sdp->db[18] & 0x7;\n\t} else {\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int\nintel_dp_hdr_metadata_infoframe_sdp_unpack(struct hdmi_drm_infoframe *drm_infoframe,\n\t\t\t\t\t   const void *buffer, size_t size)\n{\n\tint ret;\n\n\tconst struct dp_sdp *sdp = buffer;\n\n\tif (size < sizeof(struct dp_sdp))\n\t\treturn -EINVAL;\n\n\tif (sdp->sdp_header.HB0 != 0)\n\t\treturn -EINVAL;\n\n\tif (sdp->sdp_header.HB1 != HDMI_INFOFRAME_TYPE_DRM)\n\t\treturn -EINVAL;\n\n\t \n\tif (sdp->sdp_header.HB2 != 0x1D)\n\t\treturn -EINVAL;\n\n\t \n\tif ((sdp->sdp_header.HB3 & 0x3) != 0)\n\t\treturn -EINVAL;\n\n\t \n\tif (((sdp->sdp_header.HB3 >> 2) & 0x3f) != 0x13)\n\t\treturn -EINVAL;\n\n\t \n\tif (sdp->db[0] != 1)\n\t\treturn -EINVAL;\n\n\t \n\tif (sdp->db[1] != HDMI_DRM_INFOFRAME_SIZE)\n\t\treturn -EINVAL;\n\n\tret = hdmi_drm_infoframe_unpack_only(drm_infoframe, &sdp->db[2],\n\t\t\t\t\t     HDMI_DRM_INFOFRAME_SIZE);\n\n\treturn ret;\n}\n\nstatic void intel_read_dp_vsc_sdp(struct intel_encoder *encoder,\n\t\t\t\t  struct intel_crtc_state *crtc_state,\n\t\t\t\t  struct drm_dp_vsc_sdp *vsc)\n{\n\tstruct intel_digital_port *dig_port = enc_to_dig_port(encoder);\n\tstruct drm_i915_private *dev_priv = to_i915(encoder->base.dev);\n\tunsigned int type = DP_SDP_VSC;\n\tstruct dp_sdp sdp = {};\n\tint ret;\n\n\t \n\tif (crtc_state->has_psr)\n\t\treturn;\n\n\tif ((crtc_state->infoframes.enable &\n\t     intel_hdmi_infoframe_enable(type)) == 0)\n\t\treturn;\n\n\tdig_port->read_infoframe(encoder, crtc_state, type, &sdp, sizeof(sdp));\n\n\tret = intel_dp_vsc_sdp_unpack(vsc, &sdp, sizeof(sdp));\n\n\tif (ret)\n\t\tdrm_dbg_kms(&dev_priv->drm, \"Failed to unpack DP VSC SDP\\n\");\n}\n\nstatic void intel_read_dp_hdr_metadata_infoframe_sdp(struct intel_encoder *encoder,\n\t\t\t\t\t\t     struct intel_crtc_state *crtc_state,\n\t\t\t\t\t\t     struct hdmi_drm_infoframe *drm_infoframe)\n{\n\tstruct intel_digital_port *dig_port = enc_to_dig_port(encoder);\n\tstruct drm_i915_private *dev_priv = to_i915(encoder->base.dev);\n\tunsigned int type = HDMI_PACKET_TYPE_GAMUT_METADATA;\n\tstruct dp_sdp sdp = {};\n\tint ret;\n\n\tif ((crtc_state->infoframes.enable &\n\t    intel_hdmi_infoframe_enable(type)) == 0)\n\t\treturn;\n\n\tdig_port->read_infoframe(encoder, crtc_state, type, &sdp,\n\t\t\t\t sizeof(sdp));\n\n\tret = intel_dp_hdr_metadata_infoframe_sdp_unpack(drm_infoframe, &sdp,\n\t\t\t\t\t\t\t sizeof(sdp));\n\n\tif (ret)\n\t\tdrm_dbg_kms(&dev_priv->drm,\n\t\t\t    \"Failed to unpack DP HDR Metadata Infoframe SDP\\n\");\n}\n\nvoid intel_read_dp_sdp(struct intel_encoder *encoder,\n\t\t       struct intel_crtc_state *crtc_state,\n\t\t       unsigned int type)\n{\n\tswitch (type) {\n\tcase DP_SDP_VSC:\n\t\tintel_read_dp_vsc_sdp(encoder, crtc_state,\n\t\t\t\t      &crtc_state->infoframes.vsc);\n\t\tbreak;\n\tcase HDMI_PACKET_TYPE_GAMUT_METADATA:\n\t\tintel_read_dp_hdr_metadata_infoframe_sdp(encoder, crtc_state,\n\t\t\t\t\t\t\t &crtc_state->infoframes.drm.drm);\n\t\tbreak;\n\tdefault:\n\t\tMISSING_CASE(type);\n\t\tbreak;\n\t}\n}\n\nstatic u8 intel_dp_autotest_link_training(struct intel_dp *intel_dp)\n{\n\tstruct drm_i915_private *i915 = dp_to_i915(intel_dp);\n\tint status = 0;\n\tint test_link_rate;\n\tu8 test_lane_count, test_link_bw;\n\t \n\t \n\tstatus = drm_dp_dpcd_readb(&intel_dp->aux, DP_TEST_LANE_COUNT,\n\t\t\t\t   &test_lane_count);\n\n\tif (status <= 0) {\n\t\tdrm_dbg_kms(&i915->drm, \"Lane count read failed\\n\");\n\t\treturn DP_TEST_NAK;\n\t}\n\ttest_lane_count &= DP_MAX_LANE_COUNT_MASK;\n\n\tstatus = drm_dp_dpcd_readb(&intel_dp->aux, DP_TEST_LINK_RATE,\n\t\t\t\t   &test_link_bw);\n\tif (status <= 0) {\n\t\tdrm_dbg_kms(&i915->drm, \"Link Rate read failed\\n\");\n\t\treturn DP_TEST_NAK;\n\t}\n\ttest_link_rate = drm_dp_bw_code_to_link_rate(test_link_bw);\n\n\t \n\tif (!intel_dp_link_params_valid(intel_dp, test_link_rate,\n\t\t\t\t\ttest_lane_count))\n\t\treturn DP_TEST_NAK;\n\n\tintel_dp->compliance.test_lane_count = test_lane_count;\n\tintel_dp->compliance.test_link_rate = test_link_rate;\n\n\treturn DP_TEST_ACK;\n}\n\nstatic u8 intel_dp_autotest_video_pattern(struct intel_dp *intel_dp)\n{\n\tstruct drm_i915_private *i915 = dp_to_i915(intel_dp);\n\tu8 test_pattern;\n\tu8 test_misc;\n\t__be16 h_width, v_height;\n\tint status = 0;\n\n\t \n\tstatus = drm_dp_dpcd_readb(&intel_dp->aux, DP_TEST_PATTERN,\n\t\t\t\t   &test_pattern);\n\tif (status <= 0) {\n\t\tdrm_dbg_kms(&i915->drm, \"Test pattern read failed\\n\");\n\t\treturn DP_TEST_NAK;\n\t}\n\tif (test_pattern != DP_COLOR_RAMP)\n\t\treturn DP_TEST_NAK;\n\n\tstatus = drm_dp_dpcd_read(&intel_dp->aux, DP_TEST_H_WIDTH_HI,\n\t\t\t\t  &h_width, 2);\n\tif (status <= 0) {\n\t\tdrm_dbg_kms(&i915->drm, \"H Width read failed\\n\");\n\t\treturn DP_TEST_NAK;\n\t}\n\n\tstatus = drm_dp_dpcd_read(&intel_dp->aux, DP_TEST_V_HEIGHT_HI,\n\t\t\t\t  &v_height, 2);\n\tif (status <= 0) {\n\t\tdrm_dbg_kms(&i915->drm, \"V Height read failed\\n\");\n\t\treturn DP_TEST_NAK;\n\t}\n\n\tstatus = drm_dp_dpcd_readb(&intel_dp->aux, DP_TEST_MISC0,\n\t\t\t\t   &test_misc);\n\tif (status <= 0) {\n\t\tdrm_dbg_kms(&i915->drm, \"TEST MISC read failed\\n\");\n\t\treturn DP_TEST_NAK;\n\t}\n\tif ((test_misc & DP_TEST_COLOR_FORMAT_MASK) != DP_COLOR_FORMAT_RGB)\n\t\treturn DP_TEST_NAK;\n\tif (test_misc & DP_TEST_DYNAMIC_RANGE_CEA)\n\t\treturn DP_TEST_NAK;\n\tswitch (test_misc & DP_TEST_BIT_DEPTH_MASK) {\n\tcase DP_TEST_BIT_DEPTH_6:\n\t\tintel_dp->compliance.test_data.bpc = 6;\n\t\tbreak;\n\tcase DP_TEST_BIT_DEPTH_8:\n\t\tintel_dp->compliance.test_data.bpc = 8;\n\t\tbreak;\n\tdefault:\n\t\treturn DP_TEST_NAK;\n\t}\n\n\tintel_dp->compliance.test_data.video_pattern = test_pattern;\n\tintel_dp->compliance.test_data.hdisplay = be16_to_cpu(h_width);\n\tintel_dp->compliance.test_data.vdisplay = be16_to_cpu(v_height);\n\t \n\tintel_dp->compliance.test_active = true;\n\n\treturn DP_TEST_ACK;\n}\n\nstatic u8 intel_dp_autotest_edid(struct intel_dp *intel_dp)\n{\n\tstruct drm_i915_private *i915 = dp_to_i915(intel_dp);\n\tu8 test_result = DP_TEST_ACK;\n\tstruct intel_connector *intel_connector = intel_dp->attached_connector;\n\tstruct drm_connector *connector = &intel_connector->base;\n\n\tif (intel_connector->detect_edid == NULL ||\n\t    connector->edid_corrupt ||\n\t    intel_dp->aux.i2c_defer_count > 6) {\n\t\t \n\t\tif (intel_dp->aux.i2c_nack_count > 0 ||\n\t\t\tintel_dp->aux.i2c_defer_count > 0)\n\t\t\tdrm_dbg_kms(&i915->drm,\n\t\t\t\t    \"EDID read had %d NACKs, %d DEFERs\\n\",\n\t\t\t\t    intel_dp->aux.i2c_nack_count,\n\t\t\t\t    intel_dp->aux.i2c_defer_count);\n\t\tintel_dp->compliance.test_data.edid = INTEL_DP_RESOLUTION_FAILSAFE;\n\t} else {\n\t\t \n\t\tconst struct edid *block = drm_edid_raw(intel_connector->detect_edid);\n\n\t\t \n\t\tblock += block->extensions;\n\n\t\tif (drm_dp_dpcd_writeb(&intel_dp->aux, DP_TEST_EDID_CHECKSUM,\n\t\t\t\t       block->checksum) <= 0)\n\t\t\tdrm_dbg_kms(&i915->drm,\n\t\t\t\t    \"Failed to write EDID checksum\\n\");\n\n\t\ttest_result = DP_TEST_ACK | DP_TEST_EDID_CHECKSUM_WRITE;\n\t\tintel_dp->compliance.test_data.edid = INTEL_DP_RESOLUTION_PREFERRED;\n\t}\n\n\t \n\tintel_dp->compliance.test_active = true;\n\n\treturn test_result;\n}\n\nstatic void intel_dp_phy_pattern_update(struct intel_dp *intel_dp,\n\t\t\t\t\tconst struct intel_crtc_state *crtc_state)\n{\n\tstruct drm_i915_private *dev_priv =\n\t\t\tto_i915(dp_to_dig_port(intel_dp)->base.base.dev);\n\tstruct drm_dp_phy_test_params *data =\n\t\t\t&intel_dp->compliance.test_data.phytest;\n\tstruct intel_crtc *crtc = to_intel_crtc(crtc_state->uapi.crtc);\n\tenum pipe pipe = crtc->pipe;\n\tu32 pattern_val;\n\n\tswitch (data->phy_pattern) {\n\tcase DP_PHY_TEST_PATTERN_NONE:\n\t\tdrm_dbg_kms(&dev_priv->drm, \"Disable Phy Test Pattern\\n\");\n\t\tintel_de_write(dev_priv, DDI_DP_COMP_CTL(pipe), 0x0);\n\t\tbreak;\n\tcase DP_PHY_TEST_PATTERN_D10_2:\n\t\tdrm_dbg_kms(&dev_priv->drm, \"Set D10.2 Phy Test Pattern\\n\");\n\t\tintel_de_write(dev_priv, DDI_DP_COMP_CTL(pipe),\n\t\t\t       DDI_DP_COMP_CTL_ENABLE | DDI_DP_COMP_CTL_D10_2);\n\t\tbreak;\n\tcase DP_PHY_TEST_PATTERN_ERROR_COUNT:\n\t\tdrm_dbg_kms(&dev_priv->drm, \"Set Error Count Phy Test Pattern\\n\");\n\t\tintel_de_write(dev_priv, DDI_DP_COMP_CTL(pipe),\n\t\t\t       DDI_DP_COMP_CTL_ENABLE |\n\t\t\t       DDI_DP_COMP_CTL_SCRAMBLED_0);\n\t\tbreak;\n\tcase DP_PHY_TEST_PATTERN_PRBS7:\n\t\tdrm_dbg_kms(&dev_priv->drm, \"Set PRBS7 Phy Test Pattern\\n\");\n\t\tintel_de_write(dev_priv, DDI_DP_COMP_CTL(pipe),\n\t\t\t       DDI_DP_COMP_CTL_ENABLE | DDI_DP_COMP_CTL_PRBS7);\n\t\tbreak;\n\tcase DP_PHY_TEST_PATTERN_80BIT_CUSTOM:\n\t\t \n\t\tdrm_dbg_kms(&dev_priv->drm,\n\t\t\t    \"Set 80Bit Custom Phy Test Pattern 0x3e0f83e0 0x0f83e0f8 0x0000f83e\\n\");\n\t\tpattern_val = 0x3e0f83e0;\n\t\tintel_de_write(dev_priv, DDI_DP_COMP_PAT(pipe, 0), pattern_val);\n\t\tpattern_val = 0x0f83e0f8;\n\t\tintel_de_write(dev_priv, DDI_DP_COMP_PAT(pipe, 1), pattern_val);\n\t\tpattern_val = 0x0000f83e;\n\t\tintel_de_write(dev_priv, DDI_DP_COMP_PAT(pipe, 2), pattern_val);\n\t\tintel_de_write(dev_priv, DDI_DP_COMP_CTL(pipe),\n\t\t\t       DDI_DP_COMP_CTL_ENABLE |\n\t\t\t       DDI_DP_COMP_CTL_CUSTOM80);\n\t\tbreak;\n\tcase DP_PHY_TEST_PATTERN_CP2520:\n\t\t \n\t\tdrm_dbg_kms(&dev_priv->drm, \"Set HBR2 compliance Phy Test Pattern\\n\");\n\t\tpattern_val = 0xFB;\n\t\tintel_de_write(dev_priv, DDI_DP_COMP_CTL(pipe),\n\t\t\t       DDI_DP_COMP_CTL_ENABLE | DDI_DP_COMP_CTL_HBR2 |\n\t\t\t       pattern_val);\n\t\tbreak;\n\tdefault:\n\t\tWARN(1, \"Invalid Phy Test Pattern\\n\");\n\t}\n}\n\nstatic void intel_dp_process_phy_request(struct intel_dp *intel_dp,\n\t\t\t\t\t const struct intel_crtc_state *crtc_state)\n{\n\tstruct drm_i915_private *i915 = dp_to_i915(intel_dp);\n\tstruct drm_dp_phy_test_params *data =\n\t\t&intel_dp->compliance.test_data.phytest;\n\tu8 link_status[DP_LINK_STATUS_SIZE];\n\n\tif (drm_dp_dpcd_read_phy_link_status(&intel_dp->aux, DP_PHY_DPRX,\n\t\t\t\t\t     link_status) < 0) {\n\t\tdrm_dbg_kms(&i915->drm, \"failed to get link status\\n\");\n\t\treturn;\n\t}\n\n\t \n\tintel_dp_get_adjust_train(intel_dp, crtc_state, DP_PHY_DPRX,\n\t\t\t\t  link_status);\n\n\tintel_dp_set_signal_levels(intel_dp, crtc_state, DP_PHY_DPRX);\n\n\tintel_dp_phy_pattern_update(intel_dp, crtc_state);\n\n\tdrm_dp_dpcd_write(&intel_dp->aux, DP_TRAINING_LANE0_SET,\n\t\t\t  intel_dp->train_set, crtc_state->lane_count);\n\n\tdrm_dp_set_phy_test_pattern(&intel_dp->aux, data,\n\t\t\t\t    intel_dp->dpcd[DP_DPCD_REV]);\n}\n\nstatic u8 intel_dp_autotest_phy_pattern(struct intel_dp *intel_dp)\n{\n\tstruct drm_i915_private *i915 = dp_to_i915(intel_dp);\n\tstruct drm_dp_phy_test_params *data =\n\t\t&intel_dp->compliance.test_data.phytest;\n\n\tif (drm_dp_get_phy_test_pattern(&intel_dp->aux, data)) {\n\t\tdrm_dbg_kms(&i915->drm, \"DP Phy Test pattern AUX read failure\\n\");\n\t\treturn DP_TEST_NAK;\n\t}\n\n\t \n\tintel_dp->compliance.test_active = true;\n\n\treturn DP_TEST_ACK;\n}\n\nstatic void intel_dp_handle_test_request(struct intel_dp *intel_dp)\n{\n\tstruct drm_i915_private *i915 = dp_to_i915(intel_dp);\n\tu8 response = DP_TEST_NAK;\n\tu8 request = 0;\n\tint status;\n\n\tstatus = drm_dp_dpcd_readb(&intel_dp->aux, DP_TEST_REQUEST, &request);\n\tif (status <= 0) {\n\t\tdrm_dbg_kms(&i915->drm,\n\t\t\t    \"Could not read test request from sink\\n\");\n\t\tgoto update_status;\n\t}\n\n\tswitch (request) {\n\tcase DP_TEST_LINK_TRAINING:\n\t\tdrm_dbg_kms(&i915->drm, \"LINK_TRAINING test requested\\n\");\n\t\tresponse = intel_dp_autotest_link_training(intel_dp);\n\t\tbreak;\n\tcase DP_TEST_LINK_VIDEO_PATTERN:\n\t\tdrm_dbg_kms(&i915->drm, \"TEST_PATTERN test requested\\n\");\n\t\tresponse = intel_dp_autotest_video_pattern(intel_dp);\n\t\tbreak;\n\tcase DP_TEST_LINK_EDID_READ:\n\t\tdrm_dbg_kms(&i915->drm, \"EDID test requested\\n\");\n\t\tresponse = intel_dp_autotest_edid(intel_dp);\n\t\tbreak;\n\tcase DP_TEST_LINK_PHY_TEST_PATTERN:\n\t\tdrm_dbg_kms(&i915->drm, \"PHY_PATTERN test requested\\n\");\n\t\tresponse = intel_dp_autotest_phy_pattern(intel_dp);\n\t\tbreak;\n\tdefault:\n\t\tdrm_dbg_kms(&i915->drm, \"Invalid test request '%02x'\\n\",\n\t\t\t    request);\n\t\tbreak;\n\t}\n\n\tif (response & DP_TEST_ACK)\n\t\tintel_dp->compliance.test_type = request;\n\nupdate_status:\n\tstatus = drm_dp_dpcd_writeb(&intel_dp->aux, DP_TEST_RESPONSE, response);\n\tif (status <= 0)\n\t\tdrm_dbg_kms(&i915->drm,\n\t\t\t    \"Could not write test response to sink\\n\");\n}\n\nstatic bool intel_dp_link_ok(struct intel_dp *intel_dp,\n\t\t\t     u8 link_status[DP_LINK_STATUS_SIZE])\n{\n\tstruct intel_encoder *encoder = &dp_to_dig_port(intel_dp)->base;\n\tstruct drm_i915_private *i915 = to_i915(encoder->base.dev);\n\tbool uhbr = intel_dp->link_rate >= 1000000;\n\tbool ok;\n\n\tif (uhbr)\n\t\tok = drm_dp_128b132b_lane_channel_eq_done(link_status,\n\t\t\t\t\t\t\t  intel_dp->lane_count);\n\telse\n\t\tok = drm_dp_channel_eq_ok(link_status, intel_dp->lane_count);\n\n\tif (ok)\n\t\treturn true;\n\n\tintel_dp_dump_link_status(intel_dp, DP_PHY_DPRX, link_status);\n\tdrm_dbg_kms(&i915->drm,\n\t\t    \"[ENCODER:%d:%s] %s link not ok, retraining\\n\",\n\t\t    encoder->base.base.id, encoder->base.name,\n\t\t    uhbr ? \"128b/132b\" : \"8b/10b\");\n\n\treturn false;\n}\n\nstatic void\nintel_dp_mst_hpd_irq(struct intel_dp *intel_dp, u8 *esi, u8 *ack)\n{\n\tbool handled = false;\n\n\tdrm_dp_mst_hpd_irq_handle_event(&intel_dp->mst_mgr, esi, ack, &handled);\n\n\tif (esi[1] & DP_CP_IRQ) {\n\t\tintel_hdcp_handle_cp_irq(intel_dp->attached_connector);\n\t\tack[1] |= DP_CP_IRQ;\n\t}\n}\n\nstatic bool intel_dp_mst_link_status(struct intel_dp *intel_dp)\n{\n\tstruct intel_encoder *encoder = &dp_to_dig_port(intel_dp)->base;\n\tstruct drm_i915_private *i915 = to_i915(encoder->base.dev);\n\tu8 link_status[DP_LINK_STATUS_SIZE] = {};\n\tconst size_t esi_link_status_size = DP_LINK_STATUS_SIZE - 2;\n\n\tif (drm_dp_dpcd_read(&intel_dp->aux, DP_LANE0_1_STATUS_ESI, link_status,\n\t\t\t     esi_link_status_size) != esi_link_status_size) {\n\t\tdrm_err(&i915->drm,\n\t\t\t\"[ENCODER:%d:%s] Failed to read link status\\n\",\n\t\t\tencoder->base.base.id, encoder->base.name);\n\t\treturn false;\n\t}\n\n\treturn intel_dp_link_ok(intel_dp, link_status);\n}\n\n \nstatic bool\nintel_dp_check_mst_status(struct intel_dp *intel_dp)\n{\n\tstruct drm_i915_private *i915 = dp_to_i915(intel_dp);\n\tbool link_ok = true;\n\n\tdrm_WARN_ON_ONCE(&i915->drm, intel_dp->active_mst_links < 0);\n\n\tfor (;;) {\n\t\tu8 esi[4] = {};\n\t\tu8 ack[4] = {};\n\n\t\tif (!intel_dp_get_sink_irq_esi(intel_dp, esi)) {\n\t\t\tdrm_dbg_kms(&i915->drm,\n\t\t\t\t    \"failed to get ESI - device may have failed\\n\");\n\t\t\tlink_ok = false;\n\n\t\t\tbreak;\n\t\t}\n\n\t\tdrm_dbg_kms(&i915->drm, \"DPRX ESI: %4ph\\n\", esi);\n\n\t\tif (intel_dp->active_mst_links > 0 && link_ok &&\n\t\t    esi[3] & LINK_STATUS_CHANGED) {\n\t\t\tif (!intel_dp_mst_link_status(intel_dp))\n\t\t\t\tlink_ok = false;\n\t\t\tack[3] |= LINK_STATUS_CHANGED;\n\t\t}\n\n\t\tintel_dp_mst_hpd_irq(intel_dp, esi, ack);\n\n\t\tif (!memchr_inv(ack, 0, sizeof(ack)))\n\t\t\tbreak;\n\n\t\tif (!intel_dp_ack_sink_irq_esi(intel_dp, ack))\n\t\t\tdrm_dbg_kms(&i915->drm, \"Failed to ack ESI\\n\");\n\n\t\tif (ack[1] & (DP_DOWN_REP_MSG_RDY | DP_UP_REQ_MSG_RDY))\n\t\t\tdrm_dp_mst_hpd_irq_send_new_request(&intel_dp->mst_mgr);\n\t}\n\n\treturn link_ok;\n}\n\nstatic void\nintel_dp_handle_hdmi_link_status_change(struct intel_dp *intel_dp)\n{\n\tbool is_active;\n\tu8 buf = 0;\n\n\tis_active = drm_dp_pcon_hdmi_link_active(&intel_dp->aux);\n\tif (intel_dp->frl.is_trained && !is_active) {\n\t\tif (drm_dp_dpcd_readb(&intel_dp->aux, DP_PCON_HDMI_LINK_CONFIG_1, &buf) < 0)\n\t\t\treturn;\n\n\t\tbuf &=  ~DP_PCON_ENABLE_HDMI_LINK;\n\t\tif (drm_dp_dpcd_writeb(&intel_dp->aux, DP_PCON_HDMI_LINK_CONFIG_1, buf) < 0)\n\t\t\treturn;\n\n\t\tdrm_dp_pcon_hdmi_frl_link_error_count(&intel_dp->aux, &intel_dp->attached_connector->base);\n\n\t\tintel_dp->frl.is_trained = false;\n\n\t\t \n\t\tintel_dp_check_frl_training(intel_dp);\n\t}\n}\n\nstatic bool\nintel_dp_needs_link_retrain(struct intel_dp *intel_dp)\n{\n\tu8 link_status[DP_LINK_STATUS_SIZE];\n\n\tif (!intel_dp->link_trained)\n\t\treturn false;\n\n\t \n\tif (intel_psr_enabled(intel_dp))\n\t\treturn false;\n\n\tif (drm_dp_dpcd_read_phy_link_status(&intel_dp->aux, DP_PHY_DPRX,\n\t\t\t\t\t     link_status) < 0)\n\t\treturn false;\n\n\t \n\tif (!intel_dp_link_params_valid(intel_dp, intel_dp->link_rate,\n\t\t\t\t\tintel_dp->lane_count))\n\t\treturn false;\n\n\t \n\treturn !intel_dp_link_ok(intel_dp, link_status);\n}\n\nstatic bool intel_dp_has_connector(struct intel_dp *intel_dp,\n\t\t\t\t   const struct drm_connector_state *conn_state)\n{\n\tstruct drm_i915_private *i915 = dp_to_i915(intel_dp);\n\tstruct intel_encoder *encoder;\n\tenum pipe pipe;\n\n\tif (!conn_state->best_encoder)\n\t\treturn false;\n\n\t \n\tencoder = &dp_to_dig_port(intel_dp)->base;\n\tif (conn_state->best_encoder == &encoder->base)\n\t\treturn true;\n\n\t \n\tfor_each_pipe(i915, pipe) {\n\t\tencoder = &intel_dp->mst_encoders[pipe]->base;\n\t\tif (conn_state->best_encoder == &encoder->base)\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}\n\nint intel_dp_get_active_pipes(struct intel_dp *intel_dp,\n\t\t\t      struct drm_modeset_acquire_ctx *ctx,\n\t\t\t      u8 *pipe_mask)\n{\n\tstruct drm_i915_private *i915 = dp_to_i915(intel_dp);\n\tstruct drm_connector_list_iter conn_iter;\n\tstruct intel_connector *connector;\n\tint ret = 0;\n\n\t*pipe_mask = 0;\n\n\tdrm_connector_list_iter_begin(&i915->drm, &conn_iter);\n\tfor_each_intel_connector_iter(connector, &conn_iter) {\n\t\tstruct drm_connector_state *conn_state =\n\t\t\tconnector->base.state;\n\t\tstruct intel_crtc_state *crtc_state;\n\t\tstruct intel_crtc *crtc;\n\n\t\tif (!intel_dp_has_connector(intel_dp, conn_state))\n\t\t\tcontinue;\n\n\t\tcrtc = to_intel_crtc(conn_state->crtc);\n\t\tif (!crtc)\n\t\t\tcontinue;\n\n\t\tret = drm_modeset_lock(&crtc->base.mutex, ctx);\n\t\tif (ret)\n\t\t\tbreak;\n\n\t\tcrtc_state = to_intel_crtc_state(crtc->base.state);\n\n\t\tdrm_WARN_ON(&i915->drm, !intel_crtc_has_dp_encoder(crtc_state));\n\n\t\tif (!crtc_state->hw.active)\n\t\t\tcontinue;\n\n\t\tif (conn_state->commit &&\n\t\t    !try_wait_for_completion(&conn_state->commit->hw_done))\n\t\t\tcontinue;\n\n\t\t*pipe_mask |= BIT(crtc->pipe);\n\t}\n\tdrm_connector_list_iter_end(&conn_iter);\n\n\treturn ret;\n}\n\nstatic bool intel_dp_is_connected(struct intel_dp *intel_dp)\n{\n\tstruct intel_connector *connector = intel_dp->attached_connector;\n\n\treturn connector->base.status == connector_status_connected ||\n\t\tintel_dp->is_mst;\n}\n\nint intel_dp_retrain_link(struct intel_encoder *encoder,\n\t\t\t  struct drm_modeset_acquire_ctx *ctx)\n{\n\tstruct drm_i915_private *dev_priv = to_i915(encoder->base.dev);\n\tstruct intel_dp *intel_dp = enc_to_intel_dp(encoder);\n\tstruct intel_crtc *crtc;\n\tu8 pipe_mask;\n\tint ret;\n\n\tif (!intel_dp_is_connected(intel_dp))\n\t\treturn 0;\n\n\tret = drm_modeset_lock(&dev_priv->drm.mode_config.connection_mutex,\n\t\t\t       ctx);\n\tif (ret)\n\t\treturn ret;\n\n\tif (!intel_dp_needs_link_retrain(intel_dp))\n\t\treturn 0;\n\n\tret = intel_dp_get_active_pipes(intel_dp, ctx, &pipe_mask);\n\tif (ret)\n\t\treturn ret;\n\n\tif (pipe_mask == 0)\n\t\treturn 0;\n\n\tif (!intel_dp_needs_link_retrain(intel_dp))\n\t\treturn 0;\n\n\tdrm_dbg_kms(&dev_priv->drm, \"[ENCODER:%d:%s] retraining link\\n\",\n\t\t    encoder->base.base.id, encoder->base.name);\n\n\tfor_each_intel_crtc_in_pipe_mask(&dev_priv->drm, crtc, pipe_mask) {\n\t\tconst struct intel_crtc_state *crtc_state =\n\t\t\tto_intel_crtc_state(crtc->base.state);\n\n\t\t \n\t\tintel_set_cpu_fifo_underrun_reporting(dev_priv, crtc->pipe, false);\n\t\tif (crtc_state->has_pch_encoder)\n\t\t\tintel_set_pch_fifo_underrun_reporting(dev_priv,\n\t\t\t\t\t\t\t      intel_crtc_pch_transcoder(crtc), false);\n\t}\n\n\tfor_each_intel_crtc_in_pipe_mask(&dev_priv->drm, crtc, pipe_mask) {\n\t\tconst struct intel_crtc_state *crtc_state =\n\t\t\tto_intel_crtc_state(crtc->base.state);\n\n\t\t \n\t\tif (DISPLAY_VER(dev_priv) >= 12 &&\n\t\t    intel_crtc_has_type(crtc_state, INTEL_OUTPUT_DP_MST) &&\n\t\t    !intel_dp_mst_is_master_trans(crtc_state))\n\t\t\tcontinue;\n\n\t\tintel_dp_check_frl_training(intel_dp);\n\t\tintel_dp_pcon_dsc_configure(intel_dp, crtc_state);\n\t\tintel_dp_start_link_train(intel_dp, crtc_state);\n\t\tintel_dp_stop_link_train(intel_dp, crtc_state);\n\t\tbreak;\n\t}\n\n\tfor_each_intel_crtc_in_pipe_mask(&dev_priv->drm, crtc, pipe_mask) {\n\t\tconst struct intel_crtc_state *crtc_state =\n\t\t\tto_intel_crtc_state(crtc->base.state);\n\n\t\t \n\t\tintel_crtc_wait_for_next_vblank(crtc);\n\n\t\tintel_set_cpu_fifo_underrun_reporting(dev_priv, crtc->pipe, true);\n\t\tif (crtc_state->has_pch_encoder)\n\t\t\tintel_set_pch_fifo_underrun_reporting(dev_priv,\n\t\t\t\t\t\t\t      intel_crtc_pch_transcoder(crtc), true);\n\t}\n\n\treturn 0;\n}\n\nstatic int intel_dp_prep_phy_test(struct intel_dp *intel_dp,\n\t\t\t\t  struct drm_modeset_acquire_ctx *ctx,\n\t\t\t\t  u8 *pipe_mask)\n{\n\tstruct drm_i915_private *i915 = dp_to_i915(intel_dp);\n\tstruct drm_connector_list_iter conn_iter;\n\tstruct intel_connector *connector;\n\tint ret = 0;\n\n\t*pipe_mask = 0;\n\n\tdrm_connector_list_iter_begin(&i915->drm, &conn_iter);\n\tfor_each_intel_connector_iter(connector, &conn_iter) {\n\t\tstruct drm_connector_state *conn_state =\n\t\t\tconnector->base.state;\n\t\tstruct intel_crtc_state *crtc_state;\n\t\tstruct intel_crtc *crtc;\n\n\t\tif (!intel_dp_has_connector(intel_dp, conn_state))\n\t\t\tcontinue;\n\n\t\tcrtc = to_intel_crtc(conn_state->crtc);\n\t\tif (!crtc)\n\t\t\tcontinue;\n\n\t\tret = drm_modeset_lock(&crtc->base.mutex, ctx);\n\t\tif (ret)\n\t\t\tbreak;\n\n\t\tcrtc_state = to_intel_crtc_state(crtc->base.state);\n\n\t\tdrm_WARN_ON(&i915->drm, !intel_crtc_has_dp_encoder(crtc_state));\n\n\t\tif (!crtc_state->hw.active)\n\t\t\tcontinue;\n\n\t\tif (conn_state->commit &&\n\t\t    !try_wait_for_completion(&conn_state->commit->hw_done))\n\t\t\tcontinue;\n\n\t\t*pipe_mask |= BIT(crtc->pipe);\n\t}\n\tdrm_connector_list_iter_end(&conn_iter);\n\n\treturn ret;\n}\n\nstatic int intel_dp_do_phy_test(struct intel_encoder *encoder,\n\t\t\t\tstruct drm_modeset_acquire_ctx *ctx)\n{\n\tstruct drm_i915_private *dev_priv = to_i915(encoder->base.dev);\n\tstruct intel_dp *intel_dp = enc_to_intel_dp(encoder);\n\tstruct intel_crtc *crtc;\n\tu8 pipe_mask;\n\tint ret;\n\n\tret = drm_modeset_lock(&dev_priv->drm.mode_config.connection_mutex,\n\t\t\t       ctx);\n\tif (ret)\n\t\treturn ret;\n\n\tret = intel_dp_prep_phy_test(intel_dp, ctx, &pipe_mask);\n\tif (ret)\n\t\treturn ret;\n\n\tif (pipe_mask == 0)\n\t\treturn 0;\n\n\tdrm_dbg_kms(&dev_priv->drm, \"[ENCODER:%d:%s] PHY test\\n\",\n\t\t    encoder->base.base.id, encoder->base.name);\n\n\tfor_each_intel_crtc_in_pipe_mask(&dev_priv->drm, crtc, pipe_mask) {\n\t\tconst struct intel_crtc_state *crtc_state =\n\t\t\tto_intel_crtc_state(crtc->base.state);\n\n\t\t \n\t\tif (DISPLAY_VER(dev_priv) >= 12 &&\n\t\t    intel_crtc_has_type(crtc_state, INTEL_OUTPUT_DP_MST) &&\n\t\t    !intel_dp_mst_is_master_trans(crtc_state))\n\t\t\tcontinue;\n\n\t\tintel_dp_process_phy_request(intel_dp, crtc_state);\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nvoid intel_dp_phy_test(struct intel_encoder *encoder)\n{\n\tstruct drm_modeset_acquire_ctx ctx;\n\tint ret;\n\n\tdrm_modeset_acquire_init(&ctx, 0);\n\n\tfor (;;) {\n\t\tret = intel_dp_do_phy_test(encoder, &ctx);\n\n\t\tif (ret == -EDEADLK) {\n\t\t\tdrm_modeset_backoff(&ctx);\n\t\t\tcontinue;\n\t\t}\n\n\t\tbreak;\n\t}\n\n\tdrm_modeset_drop_locks(&ctx);\n\tdrm_modeset_acquire_fini(&ctx);\n\tdrm_WARN(encoder->base.dev, ret,\n\t\t \"Acquiring modeset locks failed with %i\\n\", ret);\n}\n\nstatic void intel_dp_check_device_service_irq(struct intel_dp *intel_dp)\n{\n\tstruct drm_i915_private *i915 = dp_to_i915(intel_dp);\n\tu8 val;\n\n\tif (intel_dp->dpcd[DP_DPCD_REV] < 0x11)\n\t\treturn;\n\n\tif (drm_dp_dpcd_readb(&intel_dp->aux,\n\t\t\t      DP_DEVICE_SERVICE_IRQ_VECTOR, &val) != 1 || !val)\n\t\treturn;\n\n\tdrm_dp_dpcd_writeb(&intel_dp->aux, DP_DEVICE_SERVICE_IRQ_VECTOR, val);\n\n\tif (val & DP_AUTOMATED_TEST_REQUEST)\n\t\tintel_dp_handle_test_request(intel_dp);\n\n\tif (val & DP_CP_IRQ)\n\t\tintel_hdcp_handle_cp_irq(intel_dp->attached_connector);\n\n\tif (val & DP_SINK_SPECIFIC_IRQ)\n\t\tdrm_dbg_kms(&i915->drm, \"Sink specific irq unhandled\\n\");\n}\n\nstatic void intel_dp_check_link_service_irq(struct intel_dp *intel_dp)\n{\n\tu8 val;\n\n\tif (intel_dp->dpcd[DP_DPCD_REV] < 0x11)\n\t\treturn;\n\n\tif (drm_dp_dpcd_readb(&intel_dp->aux,\n\t\t\t      DP_LINK_SERVICE_IRQ_VECTOR_ESI0, &val) != 1 || !val)\n\t\treturn;\n\n\tif (drm_dp_dpcd_writeb(&intel_dp->aux,\n\t\t\t       DP_LINK_SERVICE_IRQ_VECTOR_ESI0, val) != 1)\n\t\treturn;\n\n\tif (val & HDMI_LINK_STATUS_CHANGED)\n\t\tintel_dp_handle_hdmi_link_status_change(intel_dp);\n}\n\n \nstatic bool\nintel_dp_short_pulse(struct intel_dp *intel_dp)\n{\n\tstruct drm_i915_private *dev_priv = dp_to_i915(intel_dp);\n\tu8 old_sink_count = intel_dp->sink_count;\n\tbool ret;\n\n\t \n\tmemset(&intel_dp->compliance, 0, sizeof(intel_dp->compliance));\n\n\t \n\tret = intel_dp_get_dpcd(intel_dp);\n\n\tif ((old_sink_count != intel_dp->sink_count) || !ret) {\n\t\t \n\t\treturn false;\n\t}\n\n\tintel_dp_check_device_service_irq(intel_dp);\n\tintel_dp_check_link_service_irq(intel_dp);\n\n\t \n\tdrm_dp_cec_irq(&intel_dp->aux);\n\n\t \n\tif (intel_dp_needs_link_retrain(intel_dp))\n\t\treturn false;\n\n\tintel_psr_short_pulse(intel_dp);\n\n\tswitch (intel_dp->compliance.test_type) {\n\tcase DP_TEST_LINK_TRAINING:\n\t\tdrm_dbg_kms(&dev_priv->drm,\n\t\t\t    \"Link Training Compliance Test requested\\n\");\n\t\t \n\t\tdrm_kms_helper_hotplug_event(&dev_priv->drm);\n\t\tbreak;\n\tcase DP_TEST_LINK_PHY_TEST_PATTERN:\n\t\tdrm_dbg_kms(&dev_priv->drm,\n\t\t\t    \"PHY test pattern Compliance Test requested\\n\");\n\t\t \n\t\treturn false;\n\t}\n\n\treturn true;\n}\n\n \nstatic enum drm_connector_status\nintel_dp_detect_dpcd(struct intel_dp *intel_dp)\n{\n\tstruct drm_i915_private *i915 = dp_to_i915(intel_dp);\n\tstruct intel_digital_port *dig_port = dp_to_dig_port(intel_dp);\n\tu8 *dpcd = intel_dp->dpcd;\n\tu8 type;\n\n\tif (drm_WARN_ON(&i915->drm, intel_dp_is_edp(intel_dp)))\n\t\treturn connector_status_connected;\n\n\tlspcon_resume(dig_port);\n\n\tif (!intel_dp_get_dpcd(intel_dp))\n\t\treturn connector_status_disconnected;\n\n\t \n\tif (!drm_dp_is_branch(dpcd))\n\t\treturn connector_status_connected;\n\n\t \n\tif (intel_dp_has_sink_count(intel_dp) &&\n\t    intel_dp->downstream_ports[0] & DP_DS_PORT_HPD) {\n\t\treturn intel_dp->sink_count ?\n\t\tconnector_status_connected : connector_status_disconnected;\n\t}\n\n\tif (intel_dp_can_mst(intel_dp))\n\t\treturn connector_status_connected;\n\n\t \n\tif (drm_probe_ddc(&intel_dp->aux.ddc))\n\t\treturn connector_status_connected;\n\n\t \n\tif (intel_dp->dpcd[DP_DPCD_REV] >= 0x11) {\n\t\ttype = intel_dp->downstream_ports[0] & DP_DS_PORT_TYPE_MASK;\n\t\tif (type == DP_DS_PORT_TYPE_VGA ||\n\t\t    type == DP_DS_PORT_TYPE_NON_EDID)\n\t\t\treturn connector_status_unknown;\n\t} else {\n\t\ttype = intel_dp->dpcd[DP_DOWNSTREAMPORT_PRESENT] &\n\t\t\tDP_DWN_STRM_PORT_TYPE_MASK;\n\t\tif (type == DP_DWN_STRM_PORT_TYPE_ANALOG ||\n\t\t    type == DP_DWN_STRM_PORT_TYPE_OTHER)\n\t\t\treturn connector_status_unknown;\n\t}\n\n\t \n\tdrm_dbg_kms(&i915->drm, \"Broken DP branch device, ignoring\\n\");\n\treturn connector_status_disconnected;\n}\n\nstatic enum drm_connector_status\nedp_detect(struct intel_dp *intel_dp)\n{\n\treturn connector_status_connected;\n}\n\n \nbool intel_digital_port_connected(struct intel_encoder *encoder)\n{\n\tstruct drm_i915_private *dev_priv = to_i915(encoder->base.dev);\n\tstruct intel_digital_port *dig_port = enc_to_dig_port(encoder);\n\tbool is_connected = false;\n\tintel_wakeref_t wakeref;\n\n\twith_intel_display_power(dev_priv, POWER_DOMAIN_DISPLAY_CORE, wakeref)\n\t\tis_connected = dig_port->connected(encoder);\n\n\treturn is_connected;\n}\n\nstatic const struct drm_edid *\nintel_dp_get_edid(struct intel_dp *intel_dp)\n{\n\tstruct intel_connector *connector = intel_dp->attached_connector;\n\tconst struct drm_edid *fixed_edid = connector->panel.fixed_edid;\n\n\t \n\tif (fixed_edid) {\n\t\t \n\t\tif (IS_ERR(fixed_edid))\n\t\t\treturn NULL;\n\n\t\treturn drm_edid_dup(fixed_edid);\n\t}\n\n\treturn drm_edid_read_ddc(&connector->base, &intel_dp->aux.ddc);\n}\n\nstatic void\nintel_dp_update_dfp(struct intel_dp *intel_dp,\n\t\t    const struct drm_edid *drm_edid)\n{\n\tstruct drm_i915_private *i915 = dp_to_i915(intel_dp);\n\tstruct intel_connector *connector = intel_dp->attached_connector;\n\tconst struct edid *edid;\n\n\t \n\tedid = drm_edid_raw(drm_edid);\n\n\tintel_dp->dfp.max_bpc =\n\t\tdrm_dp_downstream_max_bpc(intel_dp->dpcd,\n\t\t\t\t\t  intel_dp->downstream_ports, edid);\n\n\tintel_dp->dfp.max_dotclock =\n\t\tdrm_dp_downstream_max_dotclock(intel_dp->dpcd,\n\t\t\t\t\t       intel_dp->downstream_ports);\n\n\tintel_dp->dfp.min_tmds_clock =\n\t\tdrm_dp_downstream_min_tmds_clock(intel_dp->dpcd,\n\t\t\t\t\t\t intel_dp->downstream_ports,\n\t\t\t\t\t\t edid);\n\tintel_dp->dfp.max_tmds_clock =\n\t\tdrm_dp_downstream_max_tmds_clock(intel_dp->dpcd,\n\t\t\t\t\t\t intel_dp->downstream_ports,\n\t\t\t\t\t\t edid);\n\n\tintel_dp->dfp.pcon_max_frl_bw =\n\t\tdrm_dp_get_pcon_max_frl_bw(intel_dp->dpcd,\n\t\t\t\t\t   intel_dp->downstream_ports);\n\n\tdrm_dbg_kms(&i915->drm,\n\t\t    \"[CONNECTOR:%d:%s] DFP max bpc %d, max dotclock %d, TMDS clock %d-%d, PCON Max FRL BW %dGbps\\n\",\n\t\t    connector->base.base.id, connector->base.name,\n\t\t    intel_dp->dfp.max_bpc,\n\t\t    intel_dp->dfp.max_dotclock,\n\t\t    intel_dp->dfp.min_tmds_clock,\n\t\t    intel_dp->dfp.max_tmds_clock,\n\t\t    intel_dp->dfp.pcon_max_frl_bw);\n\n\tintel_dp_get_pcon_dsc_cap(intel_dp);\n}\n\nstatic bool\nintel_dp_can_ycbcr420(struct intel_dp *intel_dp)\n{\n\tif (source_can_output(intel_dp, INTEL_OUTPUT_FORMAT_YCBCR420) &&\n\t    (!drm_dp_is_branch(intel_dp->dpcd) || intel_dp->dfp.ycbcr420_passthrough))\n\t\treturn true;\n\n\tif (source_can_output(intel_dp, INTEL_OUTPUT_FORMAT_RGB) &&\n\t    dfp_can_convert_from_rgb(intel_dp, INTEL_OUTPUT_FORMAT_YCBCR420))\n\t\treturn true;\n\n\tif (source_can_output(intel_dp, INTEL_OUTPUT_FORMAT_YCBCR444) &&\n\t    dfp_can_convert_from_ycbcr444(intel_dp, INTEL_OUTPUT_FORMAT_YCBCR420))\n\t\treturn true;\n\n\treturn false;\n}\n\nstatic void\nintel_dp_update_420(struct intel_dp *intel_dp)\n{\n\tstruct drm_i915_private *i915 = dp_to_i915(intel_dp);\n\tstruct intel_connector *connector = intel_dp->attached_connector;\n\n\tintel_dp->dfp.ycbcr420_passthrough =\n\t\tdrm_dp_downstream_420_passthrough(intel_dp->dpcd,\n\t\t\t\t\t\t  intel_dp->downstream_ports);\n\t \n\tintel_dp->dfp.ycbcr_444_to_420 =\n\t\tdp_to_dig_port(intel_dp)->lspcon.active ||\n\t\tdrm_dp_downstream_444_to_420_conversion(intel_dp->dpcd,\n\t\t\t\t\t\t\tintel_dp->downstream_ports);\n\tintel_dp->dfp.rgb_to_ycbcr =\n\t\tdrm_dp_downstream_rgb_to_ycbcr_conversion(intel_dp->dpcd,\n\t\t\t\t\t\t\t  intel_dp->downstream_ports,\n\t\t\t\t\t\t\t  DP_DS_HDMI_BT709_RGB_YCBCR_CONV);\n\n\tconnector->base.ycbcr_420_allowed = intel_dp_can_ycbcr420(intel_dp);\n\n\tdrm_dbg_kms(&i915->drm,\n\t\t    \"[CONNECTOR:%d:%s] RGB->YcbCr conversion? %s, YCbCr 4:2:0 allowed? %s, YCbCr 4:4:4->4:2:0 conversion? %s\\n\",\n\t\t    connector->base.base.id, connector->base.name,\n\t\t    str_yes_no(intel_dp->dfp.rgb_to_ycbcr),\n\t\t    str_yes_no(connector->base.ycbcr_420_allowed),\n\t\t    str_yes_no(intel_dp->dfp.ycbcr_444_to_420));\n}\n\nstatic void\nintel_dp_set_edid(struct intel_dp *intel_dp)\n{\n\tstruct drm_i915_private *i915 = dp_to_i915(intel_dp);\n\tstruct intel_connector *connector = intel_dp->attached_connector;\n\tconst struct drm_edid *drm_edid;\n\tconst struct edid *edid;\n\tbool vrr_capable;\n\n\tintel_dp_unset_edid(intel_dp);\n\tdrm_edid = intel_dp_get_edid(intel_dp);\n\tconnector->detect_edid = drm_edid;\n\n\t \n\tdrm_edid_connector_update(&connector->base, drm_edid);\n\n\tvrr_capable = intel_vrr_is_capable(connector);\n\tdrm_dbg_kms(&i915->drm, \"[CONNECTOR:%d:%s] VRR capable: %s\\n\",\n\t\t    connector->base.base.id, connector->base.name, str_yes_no(vrr_capable));\n\tdrm_connector_set_vrr_capable_property(&connector->base, vrr_capable);\n\n\tintel_dp_update_dfp(intel_dp, drm_edid);\n\tintel_dp_update_420(intel_dp);\n\n\t \n\tedid = drm_edid_raw(drm_edid);\n\n\tdrm_dp_cec_set_edid(&intel_dp->aux, edid);\n}\n\nstatic void\nintel_dp_unset_edid(struct intel_dp *intel_dp)\n{\n\tstruct intel_connector *connector = intel_dp->attached_connector;\n\n\tdrm_dp_cec_unset_edid(&intel_dp->aux);\n\tdrm_edid_free(connector->detect_edid);\n\tconnector->detect_edid = NULL;\n\n\tintel_dp->dfp.max_bpc = 0;\n\tintel_dp->dfp.max_dotclock = 0;\n\tintel_dp->dfp.min_tmds_clock = 0;\n\tintel_dp->dfp.max_tmds_clock = 0;\n\n\tintel_dp->dfp.pcon_max_frl_bw = 0;\n\n\tintel_dp->dfp.ycbcr_444_to_420 = false;\n\tconnector->base.ycbcr_420_allowed = false;\n\n\tdrm_connector_set_vrr_capable_property(&connector->base,\n\t\t\t\t\t       false);\n}\n\nstatic int\nintel_dp_detect(struct drm_connector *connector,\n\t\tstruct drm_modeset_acquire_ctx *ctx,\n\t\tbool force)\n{\n\tstruct drm_i915_private *dev_priv = to_i915(connector->dev);\n\tstruct intel_dp *intel_dp = intel_attached_dp(to_intel_connector(connector));\n\tstruct intel_digital_port *dig_port = dp_to_dig_port(intel_dp);\n\tstruct intel_encoder *encoder = &dig_port->base;\n\tenum drm_connector_status status;\n\n\tdrm_dbg_kms(&dev_priv->drm, \"[CONNECTOR:%d:%s]\\n\",\n\t\t    connector->base.id, connector->name);\n\tdrm_WARN_ON(&dev_priv->drm,\n\t\t    !drm_modeset_is_locked(&dev_priv->drm.mode_config.connection_mutex));\n\n\tif (!INTEL_DISPLAY_ENABLED(dev_priv))\n\t\treturn connector_status_disconnected;\n\n\t \n\tif (intel_dp_is_edp(intel_dp))\n\t\tstatus = edp_detect(intel_dp);\n\telse if (intel_digital_port_connected(encoder))\n\t\tstatus = intel_dp_detect_dpcd(intel_dp);\n\telse\n\t\tstatus = connector_status_disconnected;\n\n\tif (status == connector_status_disconnected) {\n\t\tmemset(&intel_dp->compliance, 0, sizeof(intel_dp->compliance));\n\t\tmemset(intel_dp->dsc_dpcd, 0, sizeof(intel_dp->dsc_dpcd));\n\n\t\tif (intel_dp->is_mst) {\n\t\t\tdrm_dbg_kms(&dev_priv->drm,\n\t\t\t\t    \"MST device may have disappeared %d vs %d\\n\",\n\t\t\t\t    intel_dp->is_mst,\n\t\t\t\t    intel_dp->mst_mgr.mst_state);\n\t\t\tintel_dp->is_mst = false;\n\t\t\tdrm_dp_mst_topology_mgr_set_mst(&intel_dp->mst_mgr,\n\t\t\t\t\t\t\tintel_dp->is_mst);\n\t\t}\n\n\t\tgoto out;\n\t}\n\n\t \n\tif (HAS_DSC(dev_priv))\n\t\tintel_dp_get_dsc_sink_cap(intel_dp);\n\n\tintel_dp_configure_mst(intel_dp);\n\n\t \n\tif (intel_dp->reset_link_params || intel_dp->is_mst) {\n\t\tintel_dp_reset_max_link_params(intel_dp);\n\t\tintel_dp->reset_link_params = false;\n\t}\n\n\tintel_dp_print_rates(intel_dp);\n\n\tif (intel_dp->is_mst) {\n\t\t \n\t\tstatus = connector_status_disconnected;\n\t\tgoto out;\n\t}\n\n\t \n\tif (!intel_dp_is_edp(intel_dp)) {\n\t\tint ret;\n\n\t\tret = intel_dp_retrain_link(encoder, ctx);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\t \n\tintel_dp->aux.i2c_nack_count = 0;\n\tintel_dp->aux.i2c_defer_count = 0;\n\n\tintel_dp_set_edid(intel_dp);\n\tif (intel_dp_is_edp(intel_dp) ||\n\t    to_intel_connector(connector)->detect_edid)\n\t\tstatus = connector_status_connected;\n\n\tintel_dp_check_device_service_irq(intel_dp);\n\nout:\n\tif (status != connector_status_connected && !intel_dp->is_mst)\n\t\tintel_dp_unset_edid(intel_dp);\n\n\t \n\tintel_display_power_flush_work(dev_priv);\n\n\tif (!intel_dp_is_edp(intel_dp))\n\t\tdrm_dp_set_subconnector_property(connector,\n\t\t\t\t\t\t status,\n\t\t\t\t\t\t intel_dp->dpcd,\n\t\t\t\t\t\t intel_dp->downstream_ports);\n\treturn status;\n}\n\nstatic void\nintel_dp_force(struct drm_connector *connector)\n{\n\tstruct intel_dp *intel_dp = intel_attached_dp(to_intel_connector(connector));\n\tstruct intel_digital_port *dig_port = dp_to_dig_port(intel_dp);\n\tstruct intel_encoder *intel_encoder = &dig_port->base;\n\tstruct drm_i915_private *dev_priv = to_i915(intel_encoder->base.dev);\n\tenum intel_display_power_domain aux_domain =\n\t\tintel_aux_power_domain(dig_port);\n\tintel_wakeref_t wakeref;\n\n\tdrm_dbg_kms(&dev_priv->drm, \"[CONNECTOR:%d:%s]\\n\",\n\t\t    connector->base.id, connector->name);\n\tintel_dp_unset_edid(intel_dp);\n\n\tif (connector->status != connector_status_connected)\n\t\treturn;\n\n\twakeref = intel_display_power_get(dev_priv, aux_domain);\n\n\tintel_dp_set_edid(intel_dp);\n\n\tintel_display_power_put(dev_priv, aux_domain, wakeref);\n}\n\nstatic int intel_dp_get_modes(struct drm_connector *connector)\n{\n\tstruct intel_connector *intel_connector = to_intel_connector(connector);\n\tint num_modes;\n\n\t \n\tnum_modes = drm_edid_connector_add_modes(connector);\n\n\t \n\tif (intel_dp_is_edp(intel_attached_dp(intel_connector)))\n\t\tnum_modes += intel_panel_get_modes(intel_connector);\n\n\tif (num_modes)\n\t\treturn num_modes;\n\n\tif (!intel_connector->detect_edid) {\n\t\tstruct intel_dp *intel_dp = intel_attached_dp(intel_connector);\n\t\tstruct drm_display_mode *mode;\n\n\t\tmode = drm_dp_downstream_mode(connector->dev,\n\t\t\t\t\t      intel_dp->dpcd,\n\t\t\t\t\t      intel_dp->downstream_ports);\n\t\tif (mode) {\n\t\t\tdrm_mode_probed_add(connector, mode);\n\t\t\tnum_modes++;\n\t\t}\n\t}\n\n\treturn num_modes;\n}\n\nstatic int\nintel_dp_connector_register(struct drm_connector *connector)\n{\n\tstruct drm_i915_private *i915 = to_i915(connector->dev);\n\tstruct intel_dp *intel_dp = intel_attached_dp(to_intel_connector(connector));\n\tstruct intel_digital_port *dig_port = dp_to_dig_port(intel_dp);\n\tstruct intel_lspcon *lspcon = &dig_port->lspcon;\n\tint ret;\n\n\tret = intel_connector_register(connector);\n\tif (ret)\n\t\treturn ret;\n\n\tdrm_dbg_kms(&i915->drm, \"registering %s bus for %s\\n\",\n\t\t    intel_dp->aux.name, connector->kdev->kobj.name);\n\n\tintel_dp->aux.dev = connector->kdev;\n\tret = drm_dp_aux_register(&intel_dp->aux);\n\tif (!ret)\n\t\tdrm_dp_cec_register_connector(&intel_dp->aux, connector);\n\n\tif (!intel_bios_encoder_is_lspcon(dig_port->base.devdata))\n\t\treturn ret;\n\n\t \n\tif (lspcon_init(dig_port)) {\n\t\tlspcon_detect_hdr_capability(lspcon);\n\t\tif (lspcon->hdr_supported)\n\t\t\tdrm_connector_attach_hdr_output_metadata_property(connector);\n\t}\n\n\treturn ret;\n}\n\nstatic void\nintel_dp_connector_unregister(struct drm_connector *connector)\n{\n\tstruct intel_dp *intel_dp = intel_attached_dp(to_intel_connector(connector));\n\n\tdrm_dp_cec_unregister_connector(&intel_dp->aux);\n\tdrm_dp_aux_unregister(&intel_dp->aux);\n\tintel_connector_unregister(connector);\n}\n\nvoid intel_dp_encoder_flush_work(struct drm_encoder *encoder)\n{\n\tstruct intel_digital_port *dig_port = enc_to_dig_port(to_intel_encoder(encoder));\n\tstruct intel_dp *intel_dp = &dig_port->dp;\n\n\tintel_dp_mst_encoder_cleanup(dig_port);\n\n\tintel_pps_vdd_off_sync(intel_dp);\n\n\t \n\tintel_pps_wait_power_cycle(intel_dp);\n\n\tintel_dp_aux_fini(intel_dp);\n}\n\nvoid intel_dp_encoder_suspend(struct intel_encoder *intel_encoder)\n{\n\tstruct intel_dp *intel_dp = enc_to_intel_dp(intel_encoder);\n\n\tintel_pps_vdd_off_sync(intel_dp);\n}\n\nvoid intel_dp_encoder_shutdown(struct intel_encoder *intel_encoder)\n{\n\tstruct intel_dp *intel_dp = enc_to_intel_dp(intel_encoder);\n\n\tintel_pps_wait_power_cycle(intel_dp);\n}\n\nstatic int intel_modeset_tile_group(struct intel_atomic_state *state,\n\t\t\t\t    int tile_group_id)\n{\n\tstruct drm_i915_private *dev_priv = to_i915(state->base.dev);\n\tstruct drm_connector_list_iter conn_iter;\n\tstruct drm_connector *connector;\n\tint ret = 0;\n\n\tdrm_connector_list_iter_begin(&dev_priv->drm, &conn_iter);\n\tdrm_for_each_connector_iter(connector, &conn_iter) {\n\t\tstruct drm_connector_state *conn_state;\n\t\tstruct intel_crtc_state *crtc_state;\n\t\tstruct intel_crtc *crtc;\n\n\t\tif (!connector->has_tile ||\n\t\t    connector->tile_group->id != tile_group_id)\n\t\t\tcontinue;\n\n\t\tconn_state = drm_atomic_get_connector_state(&state->base,\n\t\t\t\t\t\t\t    connector);\n\t\tif (IS_ERR(conn_state)) {\n\t\t\tret = PTR_ERR(conn_state);\n\t\t\tbreak;\n\t\t}\n\n\t\tcrtc = to_intel_crtc(conn_state->crtc);\n\n\t\tif (!crtc)\n\t\t\tcontinue;\n\n\t\tcrtc_state = intel_atomic_get_new_crtc_state(state, crtc);\n\t\tcrtc_state->uapi.mode_changed = true;\n\n\t\tret = drm_atomic_add_affected_planes(&state->base, &crtc->base);\n\t\tif (ret)\n\t\t\tbreak;\n\t}\n\tdrm_connector_list_iter_end(&conn_iter);\n\n\treturn ret;\n}\n\nstatic int intel_modeset_affected_transcoders(struct intel_atomic_state *state, u8 transcoders)\n{\n\tstruct drm_i915_private *dev_priv = to_i915(state->base.dev);\n\tstruct intel_crtc *crtc;\n\n\tif (transcoders == 0)\n\t\treturn 0;\n\n\tfor_each_intel_crtc(&dev_priv->drm, crtc) {\n\t\tstruct intel_crtc_state *crtc_state;\n\t\tint ret;\n\n\t\tcrtc_state = intel_atomic_get_crtc_state(&state->base, crtc);\n\t\tif (IS_ERR(crtc_state))\n\t\t\treturn PTR_ERR(crtc_state);\n\n\t\tif (!crtc_state->hw.enable)\n\t\t\tcontinue;\n\n\t\tif (!(transcoders & BIT(crtc_state->cpu_transcoder)))\n\t\t\tcontinue;\n\n\t\tcrtc_state->uapi.mode_changed = true;\n\n\t\tret = drm_atomic_add_affected_connectors(&state->base, &crtc->base);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tret = drm_atomic_add_affected_planes(&state->base, &crtc->base);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\ttranscoders &= ~BIT(crtc_state->cpu_transcoder);\n\t}\n\n\tdrm_WARN_ON(&dev_priv->drm, transcoders != 0);\n\n\treturn 0;\n}\n\nstatic int intel_modeset_synced_crtcs(struct intel_atomic_state *state,\n\t\t\t\t      struct drm_connector *connector)\n{\n\tconst struct drm_connector_state *old_conn_state =\n\t\tdrm_atomic_get_old_connector_state(&state->base, connector);\n\tconst struct intel_crtc_state *old_crtc_state;\n\tstruct intel_crtc *crtc;\n\tu8 transcoders;\n\n\tcrtc = to_intel_crtc(old_conn_state->crtc);\n\tif (!crtc)\n\t\treturn 0;\n\n\told_crtc_state = intel_atomic_get_old_crtc_state(state, crtc);\n\n\tif (!old_crtc_state->hw.active)\n\t\treturn 0;\n\n\ttranscoders = old_crtc_state->sync_mode_slaves_mask;\n\tif (old_crtc_state->master_transcoder != INVALID_TRANSCODER)\n\t\ttranscoders |= BIT(old_crtc_state->master_transcoder);\n\n\treturn intel_modeset_affected_transcoders(state,\n\t\t\t\t\t\t  transcoders);\n}\n\nstatic int intel_dp_connector_atomic_check(struct drm_connector *conn,\n\t\t\t\t\t   struct drm_atomic_state *_state)\n{\n\tstruct drm_i915_private *dev_priv = to_i915(conn->dev);\n\tstruct intel_atomic_state *state = to_intel_atomic_state(_state);\n\tstruct drm_connector_state *conn_state = drm_atomic_get_new_connector_state(_state, conn);\n\tstruct intel_connector *intel_conn = to_intel_connector(conn);\n\tstruct intel_dp *intel_dp = enc_to_intel_dp(intel_conn->encoder);\n\tint ret;\n\n\tret = intel_digital_connector_atomic_check(conn, &state->base);\n\tif (ret)\n\t\treturn ret;\n\n\tif (intel_dp_mst_source_support(intel_dp)) {\n\t\tret = drm_dp_mst_root_conn_atomic_check(conn_state, &intel_dp->mst_mgr);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\t \n\tif (DISPLAY_VER(dev_priv) < 9)\n\t\treturn 0;\n\n\tif (!intel_connector_needs_modeset(state, conn))\n\t\treturn 0;\n\n\tif (conn->has_tile) {\n\t\tret = intel_modeset_tile_group(state, conn->tile_group->id);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn intel_modeset_synced_crtcs(state, conn);\n}\n\nstatic void intel_dp_oob_hotplug_event(struct drm_connector *connector)\n{\n\tstruct intel_encoder *encoder = intel_attached_encoder(to_intel_connector(connector));\n\tstruct drm_i915_private *i915 = to_i915(connector->dev);\n\n\tspin_lock_irq(&i915->irq_lock);\n\ti915->display.hotplug.event_bits |= BIT(encoder->hpd_pin);\n\tspin_unlock_irq(&i915->irq_lock);\n\tqueue_delayed_work(i915->unordered_wq, &i915->display.hotplug.hotplug_work, 0);\n}\n\nstatic const struct drm_connector_funcs intel_dp_connector_funcs = {\n\t.force = intel_dp_force,\n\t.fill_modes = drm_helper_probe_single_connector_modes,\n\t.atomic_get_property = intel_digital_connector_atomic_get_property,\n\t.atomic_set_property = intel_digital_connector_atomic_set_property,\n\t.late_register = intel_dp_connector_register,\n\t.early_unregister = intel_dp_connector_unregister,\n\t.destroy = intel_connector_destroy,\n\t.atomic_destroy_state = drm_atomic_helper_connector_destroy_state,\n\t.atomic_duplicate_state = intel_digital_connector_duplicate_state,\n\t.oob_hotplug_event = intel_dp_oob_hotplug_event,\n};\n\nstatic const struct drm_connector_helper_funcs intel_dp_connector_helper_funcs = {\n\t.detect_ctx = intel_dp_detect,\n\t.get_modes = intel_dp_get_modes,\n\t.mode_valid = intel_dp_mode_valid,\n\t.atomic_check = intel_dp_connector_atomic_check,\n};\n\nenum irqreturn\nintel_dp_hpd_pulse(struct intel_digital_port *dig_port, bool long_hpd)\n{\n\tstruct drm_i915_private *i915 = to_i915(dig_port->base.base.dev);\n\tstruct intel_dp *intel_dp = &dig_port->dp;\n\n\tif (dig_port->base.type == INTEL_OUTPUT_EDP &&\n\t    (long_hpd || !intel_pps_have_panel_power_or_vdd(intel_dp))) {\n\t\t \n\t\tdrm_dbg_kms(&i915->drm,\n\t\t\t    \"ignoring %s hpd on eDP [ENCODER:%d:%s]\\n\",\n\t\t\t    long_hpd ? \"long\" : \"short\",\n\t\t\t    dig_port->base.base.base.id,\n\t\t\t    dig_port->base.base.name);\n\t\treturn IRQ_HANDLED;\n\t}\n\n\tdrm_dbg_kms(&i915->drm, \"got hpd irq on [ENCODER:%d:%s] - %s\\n\",\n\t\t    dig_port->base.base.base.id,\n\t\t    dig_port->base.base.name,\n\t\t    long_hpd ? \"long\" : \"short\");\n\n\tif (long_hpd) {\n\t\tintel_dp->reset_link_params = true;\n\t\treturn IRQ_NONE;\n\t}\n\n\tif (intel_dp->is_mst) {\n\t\tif (!intel_dp_check_mst_status(intel_dp))\n\t\t\treturn IRQ_NONE;\n\t} else if (!intel_dp_short_pulse(intel_dp)) {\n\t\treturn IRQ_NONE;\n\t}\n\n\treturn IRQ_HANDLED;\n}\n\nstatic bool _intel_dp_is_port_edp(struct drm_i915_private *dev_priv,\n\t\t\t\t  const struct intel_bios_encoder_data *devdata,\n\t\t\t\t  enum port port)\n{\n\t \n\tif (DISPLAY_VER(dev_priv) < 5)\n\t\treturn false;\n\n\tif (DISPLAY_VER(dev_priv) < 9 && port == PORT_A)\n\t\treturn true;\n\n\treturn devdata && intel_bios_encoder_supports_edp(devdata);\n}\n\nbool intel_dp_is_port_edp(struct drm_i915_private *i915, enum port port)\n{\n\tconst struct intel_bios_encoder_data *devdata =\n\t\tintel_bios_encoder_data_lookup(i915, port);\n\n\treturn _intel_dp_is_port_edp(i915, devdata, port);\n}\n\nstatic bool\nhas_gamut_metadata_dip(struct intel_encoder *encoder)\n{\n\tstruct drm_i915_private *i915 = to_i915(encoder->base.dev);\n\tenum port port = encoder->port;\n\n\tif (intel_bios_encoder_is_lspcon(encoder->devdata))\n\t\treturn false;\n\n\tif (DISPLAY_VER(i915) >= 11)\n\t\treturn true;\n\n\tif (port == PORT_A)\n\t\treturn false;\n\n\tif (IS_HASWELL(i915) || IS_BROADWELL(i915) ||\n\t    DISPLAY_VER(i915) >= 9)\n\t\treturn true;\n\n\treturn false;\n}\n\nstatic void\nintel_dp_add_properties(struct intel_dp *intel_dp, struct drm_connector *connector)\n{\n\tstruct drm_i915_private *dev_priv = to_i915(connector->dev);\n\tenum port port = dp_to_dig_port(intel_dp)->base.port;\n\n\tif (!intel_dp_is_edp(intel_dp))\n\t\tdrm_connector_attach_dp_subconnector_property(connector);\n\n\tif (!IS_G4X(dev_priv) && port != PORT_A)\n\t\tintel_attach_force_audio_property(connector);\n\n\tintel_attach_broadcast_rgb_property(connector);\n\tif (HAS_GMCH(dev_priv))\n\t\tdrm_connector_attach_max_bpc_property(connector, 6, 10);\n\telse if (DISPLAY_VER(dev_priv) >= 5)\n\t\tdrm_connector_attach_max_bpc_property(connector, 6, 12);\n\n\t \n\tif (intel_bios_encoder_is_lspcon(dp_to_dig_port(intel_dp)->base.devdata)) {\n\t\tdrm_connector_attach_content_type_property(connector);\n\t\tintel_attach_hdmi_colorspace_property(connector);\n\t} else {\n\t\tintel_attach_dp_colorspace_property(connector);\n\t}\n\n\tif (has_gamut_metadata_dip(&dp_to_dig_port(intel_dp)->base))\n\t\tdrm_connector_attach_hdr_output_metadata_property(connector);\n\n\tif (HAS_VRR(dev_priv))\n\t\tdrm_connector_attach_vrr_capable_property(connector);\n}\n\nstatic void\nintel_edp_add_properties(struct intel_dp *intel_dp)\n{\n\tstruct intel_connector *connector = intel_dp->attached_connector;\n\tstruct drm_i915_private *i915 = to_i915(connector->base.dev);\n\tconst struct drm_display_mode *fixed_mode =\n\t\tintel_panel_preferred_fixed_mode(connector);\n\n\tintel_attach_scaling_mode_property(&connector->base);\n\n\tdrm_connector_set_panel_orientation_with_quirk(&connector->base,\n\t\t\t\t\t\t       i915->display.vbt.orientation,\n\t\t\t\t\t\t       fixed_mode->hdisplay,\n\t\t\t\t\t\t       fixed_mode->vdisplay);\n}\n\nstatic void intel_edp_backlight_setup(struct intel_dp *intel_dp,\n\t\t\t\t      struct intel_connector *connector)\n{\n\tstruct drm_i915_private *i915 = dp_to_i915(intel_dp);\n\tenum pipe pipe = INVALID_PIPE;\n\n\tif (IS_VALLEYVIEW(i915) || IS_CHERRYVIEW(i915)) {\n\t\t \n\t\tpipe = vlv_active_pipe(intel_dp);\n\n\t\tif (pipe != PIPE_A && pipe != PIPE_B)\n\t\t\tpipe = intel_dp->pps.pps_pipe;\n\n\t\tif (pipe != PIPE_A && pipe != PIPE_B)\n\t\t\tpipe = PIPE_A;\n\t}\n\n\tintel_backlight_setup(connector, pipe);\n}\n\nstatic bool intel_edp_init_connector(struct intel_dp *intel_dp,\n\t\t\t\t     struct intel_connector *intel_connector)\n{\n\tstruct drm_i915_private *dev_priv = dp_to_i915(intel_dp);\n\tstruct drm_connector *connector = &intel_connector->base;\n\tstruct drm_display_mode *fixed_mode;\n\tstruct intel_encoder *encoder = &dp_to_dig_port(intel_dp)->base;\n\tbool has_dpcd;\n\tconst struct drm_edid *drm_edid;\n\n\tif (!intel_dp_is_edp(intel_dp))\n\t\treturn true;\n\n\t \n\tif (intel_get_lvds_encoder(dev_priv)) {\n\t\tdrm_WARN_ON(&dev_priv->drm,\n\t\t\t    !(HAS_PCH_IBX(dev_priv) || HAS_PCH_CPT(dev_priv)));\n\t\tdrm_info(&dev_priv->drm,\n\t\t\t \"LVDS was detected, not registering eDP\\n\");\n\n\t\treturn false;\n\t}\n\n\tintel_bios_init_panel_early(dev_priv, &intel_connector->panel,\n\t\t\t\t    encoder->devdata);\n\n\tif (!intel_pps_init(intel_dp)) {\n\t\tdrm_info(&dev_priv->drm,\n\t\t\t \"[ENCODER:%d:%s] unusable PPS, disabling eDP\\n\",\n\t\t\t encoder->base.base.id, encoder->base.name);\n\t\t \n\t\tgoto out_vdd_off;\n\t}\n\n\t \n\tintel_hpd_enable_detection(encoder);\n\n\t \n\thas_dpcd = intel_edp_init_dpcd(intel_dp);\n\n\tif (!has_dpcd) {\n\t\t \n\t\tdrm_info(&dev_priv->drm,\n\t\t\t \"[ENCODER:%d:%s] failed to retrieve link info, disabling eDP\\n\",\n\t\t\t encoder->base.base.id, encoder->base.name);\n\t\tgoto out_vdd_off;\n\t}\n\n\t \n\tif (intel_bios_dp_has_shared_aux_ch(encoder->devdata)) {\n\t\t \n\t\tif (!intel_digital_port_connected(encoder)) {\n\t\t\tdrm_info(&dev_priv->drm,\n\t\t\t\t \"[ENCODER:%d:%s] HPD is down, disabling eDP\\n\",\n\t\t\t\t encoder->base.base.id, encoder->base.name);\n\t\t\tgoto out_vdd_off;\n\t\t}\n\n\t\t \n\t\tif (DISPLAY_VER(dev_priv) == 9 && drm_dp_is_branch(intel_dp->dpcd) &&\n\t\t    (intel_dp->dpcd[DP_DOWNSTREAMPORT_PRESENT] & DP_DWN_STRM_PORT_TYPE_MASK) ==\n\t\t    DP_DWN_STRM_PORT_TYPE_ANALOG) {\n\t\t\tdrm_info(&dev_priv->drm,\n\t\t\t\t \"[ENCODER:%d:%s] VGA converter detected, disabling eDP\\n\",\n\t\t\t\t encoder->base.base.id, encoder->base.name);\n\t\t\tgoto out_vdd_off;\n\t\t}\n\t}\n\n\tmutex_lock(&dev_priv->drm.mode_config.mutex);\n\tdrm_edid = drm_edid_read_ddc(connector, &intel_dp->aux.ddc);\n\tif (!drm_edid) {\n\t\t \n\t\tdrm_edid = intel_opregion_get_edid(intel_connector);\n\t\tif (drm_edid)\n\t\t\tdrm_dbg_kms(&dev_priv->drm,\n\t\t\t\t    \"[CONNECTOR:%d:%s] Using OpRegion EDID\\n\",\n\t\t\t\t    connector->base.id, connector->name);\n\t}\n\tif (drm_edid) {\n\t\tif (drm_edid_connector_update(connector, drm_edid) ||\n\t\t    !drm_edid_connector_add_modes(connector)) {\n\t\t\tdrm_edid_connector_update(connector, NULL);\n\t\t\tdrm_edid_free(drm_edid);\n\t\t\tdrm_edid = ERR_PTR(-EINVAL);\n\t\t}\n\t} else {\n\t\tdrm_edid = ERR_PTR(-ENOENT);\n\t}\n\n\tintel_bios_init_panel_late(dev_priv, &intel_connector->panel, encoder->devdata,\n\t\t\t\t   IS_ERR(drm_edid) ? NULL : drm_edid);\n\n\tintel_panel_add_edid_fixed_modes(intel_connector, true);\n\n\t \n\tintel_edp_mso_init(intel_dp);\n\n\t \n\tlist_for_each_entry(fixed_mode, &intel_connector->panel.fixed_modes, head)\n\t\tintel_edp_mso_mode_fixup(intel_connector, fixed_mode);\n\n\t \n\tif (!intel_panel_preferred_fixed_mode(intel_connector))\n\t\tintel_panel_add_vbt_lfp_fixed_mode(intel_connector);\n\n\tmutex_unlock(&dev_priv->drm.mode_config.mutex);\n\n\tif (!intel_panel_preferred_fixed_mode(intel_connector)) {\n\t\tdrm_info(&dev_priv->drm,\n\t\t\t \"[ENCODER:%d:%s] failed to find fixed mode for the panel, disabling eDP\\n\",\n\t\t\t encoder->base.base.id, encoder->base.name);\n\t\tgoto out_vdd_off;\n\t}\n\n\tintel_panel_init(intel_connector, drm_edid);\n\n\tintel_edp_backlight_setup(intel_dp, intel_connector);\n\n\tintel_edp_add_properties(intel_dp);\n\n\tintel_pps_init_late(intel_dp);\n\n\treturn true;\n\nout_vdd_off:\n\tintel_pps_vdd_off_sync(intel_dp);\n\n\treturn false;\n}\n\nstatic void intel_dp_modeset_retry_work_fn(struct work_struct *work)\n{\n\tstruct intel_connector *intel_connector;\n\tstruct drm_connector *connector;\n\n\tintel_connector = container_of(work, typeof(*intel_connector),\n\t\t\t\t       modeset_retry_work);\n\tconnector = &intel_connector->base;\n\tdrm_dbg_kms(connector->dev, \"[CONNECTOR:%d:%s]\\n\", connector->base.id,\n\t\t    connector->name);\n\n\t \n\tmutex_lock(&connector->dev->mode_config.mutex);\n\t \n\tdrm_connector_set_link_status_property(connector,\n\t\t\t\t\t       DRM_MODE_LINK_STATUS_BAD);\n\tmutex_unlock(&connector->dev->mode_config.mutex);\n\t \n\tdrm_kms_helper_connector_hotplug_event(connector);\n}\n\nbool\nintel_dp_init_connector(struct intel_digital_port *dig_port,\n\t\t\tstruct intel_connector *intel_connector)\n{\n\tstruct drm_connector *connector = &intel_connector->base;\n\tstruct intel_dp *intel_dp = &dig_port->dp;\n\tstruct intel_encoder *intel_encoder = &dig_port->base;\n\tstruct drm_device *dev = intel_encoder->base.dev;\n\tstruct drm_i915_private *dev_priv = to_i915(dev);\n\tenum port port = intel_encoder->port;\n\tenum phy phy = intel_port_to_phy(dev_priv, port);\n\tint type;\n\n\t \n\tINIT_WORK(&intel_connector->modeset_retry_work,\n\t\t  intel_dp_modeset_retry_work_fn);\n\n\tif (drm_WARN(dev, dig_port->max_lanes < 1,\n\t\t     \"Not enough lanes (%d) for DP on [ENCODER:%d:%s]\\n\",\n\t\t     dig_port->max_lanes, intel_encoder->base.base.id,\n\t\t     intel_encoder->base.name))\n\t\treturn false;\n\n\tintel_dp->reset_link_params = true;\n\tintel_dp->pps.pps_pipe = INVALID_PIPE;\n\tintel_dp->pps.active_pipe = INVALID_PIPE;\n\n\t \n\tintel_dp->DP = intel_de_read(dev_priv, intel_dp->output_reg);\n\tintel_dp->attached_connector = intel_connector;\n\n\tif (_intel_dp_is_port_edp(dev_priv, intel_encoder->devdata, port)) {\n\t\t \n\t\tdrm_WARN_ON(dev, intel_phy_is_tc(dev_priv, phy));\n\t\ttype = DRM_MODE_CONNECTOR_eDP;\n\t\tintel_encoder->type = INTEL_OUTPUT_EDP;\n\n\t\t \n\t\tif (drm_WARN_ON(dev, (IS_VALLEYVIEW(dev_priv) ||\n\t\t\t\t      IS_CHERRYVIEW(dev_priv)) &&\n\t\t\t\tport != PORT_B && port != PORT_C))\n\t\t\treturn false;\n\t} else {\n\t\ttype = DRM_MODE_CONNECTOR_DisplayPort;\n\t}\n\n\tintel_dp_set_default_sink_rates(intel_dp);\n\tintel_dp_set_default_max_sink_lane_count(intel_dp);\n\n\tif (IS_VALLEYVIEW(dev_priv) || IS_CHERRYVIEW(dev_priv))\n\t\tintel_dp->pps.active_pipe = vlv_active_pipe(intel_dp);\n\n\tdrm_dbg_kms(&dev_priv->drm,\n\t\t    \"Adding %s connector on [ENCODER:%d:%s]\\n\",\n\t\t    type == DRM_MODE_CONNECTOR_eDP ? \"eDP\" : \"DP\",\n\t\t    intel_encoder->base.base.id, intel_encoder->base.name);\n\n\tdrm_connector_init(dev, connector, &intel_dp_connector_funcs, type);\n\tdrm_connector_helper_add(connector, &intel_dp_connector_helper_funcs);\n\n\tif (!HAS_GMCH(dev_priv) && DISPLAY_VER(dev_priv) < 12)\n\t\tconnector->interlace_allowed = true;\n\n\tintel_connector->polled = DRM_CONNECTOR_POLL_HPD;\n\n\tintel_dp_aux_init(intel_dp);\n\n\tintel_connector_attach_encoder(intel_connector, intel_encoder);\n\n\tif (HAS_DDI(dev_priv))\n\t\tintel_connector->get_hw_state = intel_ddi_connector_get_hw_state;\n\telse\n\t\tintel_connector->get_hw_state = intel_connector_get_hw_state;\n\n\tif (!intel_edp_init_connector(intel_dp, intel_connector)) {\n\t\tintel_dp_aux_fini(intel_dp);\n\t\tgoto fail;\n\t}\n\n\tintel_dp_set_source_rates(intel_dp);\n\tintel_dp_set_common_rates(intel_dp);\n\tintel_dp_reset_max_link_params(intel_dp);\n\n\t \n\tintel_dp_mst_encoder_init(dig_port,\n\t\t\t\t  intel_connector->base.base.id);\n\n\tintel_dp_add_properties(intel_dp, connector);\n\n\tif (is_hdcp_supported(dev_priv, port) && !intel_dp_is_edp(intel_dp)) {\n\t\tint ret = intel_dp_hdcp_init(dig_port, intel_connector);\n\t\tif (ret)\n\t\t\tdrm_dbg_kms(&dev_priv->drm,\n\t\t\t\t    \"HDCP init failed, skipping.\\n\");\n\t}\n\n\t \n\tif (IS_G45(dev_priv)) {\n\t\tu32 temp = intel_de_read(dev_priv, PEG_BAND_GAP_DATA);\n\t\tintel_de_write(dev_priv, PEG_BAND_GAP_DATA,\n\t\t\t       (temp & ~0xf) | 0xd);\n\t}\n\n\tintel_dp->frl.is_trained = false;\n\tintel_dp->frl.trained_rate_gbps = 0;\n\n\tintel_psr_init(intel_dp);\n\n\treturn true;\n\nfail:\n\tintel_display_power_flush_work(dev_priv);\n\tdrm_connector_cleanup(connector);\n\n\treturn false;\n}\n\nvoid intel_dp_mst_suspend(struct drm_i915_private *dev_priv)\n{\n\tstruct intel_encoder *encoder;\n\n\tif (!HAS_DISPLAY(dev_priv))\n\t\treturn;\n\n\tfor_each_intel_encoder(&dev_priv->drm, encoder) {\n\t\tstruct intel_dp *intel_dp;\n\n\t\tif (encoder->type != INTEL_OUTPUT_DDI)\n\t\t\tcontinue;\n\n\t\tintel_dp = enc_to_intel_dp(encoder);\n\n\t\tif (!intel_dp_mst_source_support(intel_dp))\n\t\t\tcontinue;\n\n\t\tif (intel_dp->is_mst)\n\t\t\tdrm_dp_mst_topology_mgr_suspend(&intel_dp->mst_mgr);\n\t}\n}\n\nvoid intel_dp_mst_resume(struct drm_i915_private *dev_priv)\n{\n\tstruct intel_encoder *encoder;\n\n\tif (!HAS_DISPLAY(dev_priv))\n\t\treturn;\n\n\tfor_each_intel_encoder(&dev_priv->drm, encoder) {\n\t\tstruct intel_dp *intel_dp;\n\t\tint ret;\n\n\t\tif (encoder->type != INTEL_OUTPUT_DDI)\n\t\t\tcontinue;\n\n\t\tintel_dp = enc_to_intel_dp(encoder);\n\n\t\tif (!intel_dp_mst_source_support(intel_dp))\n\t\t\tcontinue;\n\n\t\tret = drm_dp_mst_topology_mgr_resume(&intel_dp->mst_mgr,\n\t\t\t\t\t\t     true);\n\t\tif (ret) {\n\t\t\tintel_dp->is_mst = false;\n\t\t\tdrm_dp_mst_topology_mgr_set_mst(&intel_dp->mst_mgr,\n\t\t\t\t\t\t\tfalse);\n\t\t}\n\t}\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}