{
  "module_name": "intel_dsi_vbt.c",
  "hash_id": "3279e7a2ab6d58fd072c03245de0249f7ba104fcf76f40f66b9beda4f1d2de08",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/i915/display/intel_dsi_vbt.c",
  "human_readable_source": " \n\n#include <linux/gpio/consumer.h>\n#include <linux/gpio/machine.h>\n#include <linux/mfd/intel_soc_pmic.h>\n#include <linux/pinctrl/consumer.h>\n#include <linux/pinctrl/machine.h>\n#include <linux/slab.h>\n#include <linux/string_helpers.h>\n\n#include <asm/unaligned.h>\n\n#include <drm/drm_crtc.h>\n#include <drm/drm_edid.h>\n\n#include <video/mipi_display.h>\n\n#include \"i915_drv.h\"\n#include \"i915_reg.h\"\n#include \"intel_de.h\"\n#include \"intel_display_types.h\"\n#include \"intel_dsi.h\"\n#include \"intel_dsi_vbt.h\"\n#include \"intel_gmbus_regs.h\"\n#include \"intel_pps_regs.h\"\n#include \"vlv_dsi.h\"\n#include \"vlv_dsi_regs.h\"\n#include \"vlv_sideband.h\"\n\n#define MIPI_TRANSFER_MODE_SHIFT\t0\n#define MIPI_VIRTUAL_CHANNEL_SHIFT\t1\n#define MIPI_PORT_SHIFT\t\t\t3\n\n \n#define VLV_GPIO_NC_0_HV_DDI0_HPD\t0x4130\n#define VLV_GPIO_NC_1_HV_DDI0_DDC_SDA\t0x4120\n#define VLV_GPIO_NC_2_HV_DDI0_DDC_SCL\t0x4110\n#define VLV_GPIO_NC_3_PANEL0_VDDEN\t0x4140\n#define VLV_GPIO_NC_4_PANEL0_BKLTEN\t0x4150\n#define VLV_GPIO_NC_5_PANEL0_BKLTCTL\t0x4160\n#define VLV_GPIO_NC_6_HV_DDI1_HPD\t0x4180\n#define VLV_GPIO_NC_7_HV_DDI1_DDC_SDA\t0x4190\n#define VLV_GPIO_NC_8_HV_DDI1_DDC_SCL\t0x4170\n#define VLV_GPIO_NC_9_PANEL1_VDDEN\t0x4100\n#define VLV_GPIO_NC_10_PANEL1_BKLTEN\t0x40E0\n#define VLV_GPIO_NC_11_PANEL1_BKLTCTL\t0x40F0\n\n#define VLV_GPIO_PCONF0(base_offset)\t(base_offset)\n#define VLV_GPIO_PAD_VAL(base_offset)\t((base_offset) + 8)\n\nstruct gpio_map {\n\tu16 base_offset;\n\tbool init;\n};\n\nstatic struct gpio_map vlv_gpio_table[] = {\n\t{ VLV_GPIO_NC_0_HV_DDI0_HPD },\n\t{ VLV_GPIO_NC_1_HV_DDI0_DDC_SDA },\n\t{ VLV_GPIO_NC_2_HV_DDI0_DDC_SCL },\n\t{ VLV_GPIO_NC_3_PANEL0_VDDEN },\n\t{ VLV_GPIO_NC_4_PANEL0_BKLTEN },\n\t{ VLV_GPIO_NC_5_PANEL0_BKLTCTL },\n\t{ VLV_GPIO_NC_6_HV_DDI1_HPD },\n\t{ VLV_GPIO_NC_7_HV_DDI1_DDC_SDA },\n\t{ VLV_GPIO_NC_8_HV_DDI1_DDC_SCL },\n\t{ VLV_GPIO_NC_9_PANEL1_VDDEN },\n\t{ VLV_GPIO_NC_10_PANEL1_BKLTEN },\n\t{ VLV_GPIO_NC_11_PANEL1_BKLTCTL },\n};\n\nstruct i2c_adapter_lookup {\n\tu16 slave_addr;\n\tstruct intel_dsi *intel_dsi;\n\tacpi_handle dev_handle;\n};\n\n#define CHV_GPIO_IDX_START_N\t\t0\n#define CHV_GPIO_IDX_START_E\t\t73\n#define CHV_GPIO_IDX_START_SW\t\t100\n#define CHV_GPIO_IDX_START_SE\t\t198\n\n#define CHV_VBT_MAX_PINS_PER_FMLY\t15\n\n#define CHV_GPIO_PAD_CFG0(f, i)\t\t(0x4400 + (f) * 0x400 + (i) * 8)\n#define  CHV_GPIO_GPIOEN\t\t(1 << 15)\n#define  CHV_GPIO_GPIOCFG_GPIO\t\t(0 << 8)\n#define  CHV_GPIO_GPIOCFG_GPO\t\t(1 << 8)\n#define  CHV_GPIO_GPIOCFG_GPI\t\t(2 << 8)\n#define  CHV_GPIO_GPIOCFG_HIZ\t\t(3 << 8)\n#define  CHV_GPIO_GPIOTXSTATE(state)\t((!!(state)) << 1)\n\n#define CHV_GPIO_PAD_CFG1(f, i)\t\t(0x4400 + (f) * 0x400 + (i) * 8 + 4)\n#define  CHV_GPIO_CFGLOCK\t\t(1 << 31)\n\n \n#define  ICL_GPIO_DDSP_HPD_A\t\t0\n#define  ICL_GPIO_L_VDDEN_1\t\t1\n#define  ICL_GPIO_L_BKLTEN_1\t\t2\n#define  ICL_GPIO_DDPA_CTRLCLK_1\t3\n#define  ICL_GPIO_DDPA_CTRLDATA_1\t4\n#define  ICL_GPIO_DDSP_HPD_B\t\t5\n#define  ICL_GPIO_L_VDDEN_2\t\t6\n#define  ICL_GPIO_L_BKLTEN_2\t\t7\n#define  ICL_GPIO_DDPA_CTRLCLK_2\t8\n#define  ICL_GPIO_DDPA_CTRLDATA_2\t9\n\nstatic enum port intel_dsi_seq_port_to_port(struct intel_dsi *intel_dsi,\n\t\t\t\t\t    u8 seq_port)\n{\n\t \n\tif (hweight8(intel_dsi->ports) == 1)\n\t\treturn ffs(intel_dsi->ports) - 1;\n\n\tif (seq_port) {\n\t\tif (intel_dsi->ports & BIT(PORT_B))\n\t\t\treturn PORT_B;\n\t\telse if (intel_dsi->ports & BIT(PORT_C))\n\t\t\treturn PORT_C;\n\t}\n\n\treturn PORT_A;\n}\n\nstatic const u8 *mipi_exec_send_packet(struct intel_dsi *intel_dsi,\n\t\t\t\t       const u8 *data)\n{\n\tstruct drm_i915_private *dev_priv = to_i915(intel_dsi->base.base.dev);\n\tstruct mipi_dsi_device *dsi_device;\n\tu8 type, flags, seq_port;\n\tu16 len;\n\tenum port port;\n\n\tdrm_dbg_kms(&dev_priv->drm, \"\\n\");\n\n\tflags = *data++;\n\ttype = *data++;\n\n\tlen = *((u16 *) data);\n\tdata += 2;\n\n\tseq_port = (flags >> MIPI_PORT_SHIFT) & 3;\n\n\tport = intel_dsi_seq_port_to_port(intel_dsi, seq_port);\n\n\tif (drm_WARN_ON(&dev_priv->drm, !intel_dsi->dsi_hosts[port]))\n\t\tgoto out;\n\n\tdsi_device = intel_dsi->dsi_hosts[port]->device;\n\tif (!dsi_device) {\n\t\tdrm_dbg_kms(&dev_priv->drm, \"no dsi device for port %c\\n\",\n\t\t\t    port_name(port));\n\t\tgoto out;\n\t}\n\n\tif ((flags >> MIPI_TRANSFER_MODE_SHIFT) & 1)\n\t\tdsi_device->mode_flags &= ~MIPI_DSI_MODE_LPM;\n\telse\n\t\tdsi_device->mode_flags |= MIPI_DSI_MODE_LPM;\n\n\tdsi_device->channel = (flags >> MIPI_VIRTUAL_CHANNEL_SHIFT) & 3;\n\n\tswitch (type) {\n\tcase MIPI_DSI_GENERIC_SHORT_WRITE_0_PARAM:\n\t\tmipi_dsi_generic_write(dsi_device, NULL, 0);\n\t\tbreak;\n\tcase MIPI_DSI_GENERIC_SHORT_WRITE_1_PARAM:\n\t\tmipi_dsi_generic_write(dsi_device, data, 1);\n\t\tbreak;\n\tcase MIPI_DSI_GENERIC_SHORT_WRITE_2_PARAM:\n\t\tmipi_dsi_generic_write(dsi_device, data, 2);\n\t\tbreak;\n\tcase MIPI_DSI_GENERIC_READ_REQUEST_0_PARAM:\n\tcase MIPI_DSI_GENERIC_READ_REQUEST_1_PARAM:\n\tcase MIPI_DSI_GENERIC_READ_REQUEST_2_PARAM:\n\t\tdrm_dbg(&dev_priv->drm,\n\t\t\t\"Generic Read not yet implemented or used\\n\");\n\t\tbreak;\n\tcase MIPI_DSI_GENERIC_LONG_WRITE:\n\t\tmipi_dsi_generic_write(dsi_device, data, len);\n\t\tbreak;\n\tcase MIPI_DSI_DCS_SHORT_WRITE:\n\t\tmipi_dsi_dcs_write_buffer(dsi_device, data, 1);\n\t\tbreak;\n\tcase MIPI_DSI_DCS_SHORT_WRITE_PARAM:\n\t\tmipi_dsi_dcs_write_buffer(dsi_device, data, 2);\n\t\tbreak;\n\tcase MIPI_DSI_DCS_READ:\n\t\tdrm_dbg(&dev_priv->drm,\n\t\t\t\"DCS Read not yet implemented or used\\n\");\n\t\tbreak;\n\tcase MIPI_DSI_DCS_LONG_WRITE:\n\t\tmipi_dsi_dcs_write_buffer(dsi_device, data, len);\n\t\tbreak;\n\t}\n\n\tif (DISPLAY_VER(dev_priv) < 11)\n\t\tvlv_dsi_wait_for_fifo_empty(intel_dsi, port);\n\nout:\n\tdata += len;\n\n\treturn data;\n}\n\nstatic const u8 *mipi_exec_delay(struct intel_dsi *intel_dsi, const u8 *data)\n{\n\tstruct drm_i915_private *i915 = to_i915(intel_dsi->base.base.dev);\n\tu32 delay = *((const u32 *) data);\n\n\tdrm_dbg_kms(&i915->drm, \"%d usecs\\n\", delay);\n\n\tusleep_range(delay, delay + 10);\n\tdata += 4;\n\n\treturn data;\n}\n\nstatic void vlv_exec_gpio(struct intel_connector *connector,\n\t\t\t  u8 gpio_source, u8 gpio_index, bool value)\n{\n\tstruct drm_i915_private *dev_priv = to_i915(connector->base.dev);\n\tstruct gpio_map *map;\n\tu16 pconf0, padval;\n\tu32 tmp;\n\tu8 port;\n\n\tif (gpio_index >= ARRAY_SIZE(vlv_gpio_table)) {\n\t\tdrm_dbg_kms(&dev_priv->drm, \"unknown gpio index %u\\n\",\n\t\t\t    gpio_index);\n\t\treturn;\n\t}\n\n\tmap = &vlv_gpio_table[gpio_index];\n\n\tif (connector->panel.vbt.dsi.seq_version >= 3) {\n\t\t \n\t\tport = IOSF_PORT_GPIO_NC;\n\t} else {\n\t\tif (gpio_source == 0) {\n\t\t\tport = IOSF_PORT_GPIO_NC;\n\t\t} else if (gpio_source == 1) {\n\t\t\tdrm_dbg_kms(&dev_priv->drm, \"SC gpio not supported\\n\");\n\t\t\treturn;\n\t\t} else {\n\t\t\tdrm_dbg_kms(&dev_priv->drm,\n\t\t\t\t    \"unknown gpio source %u\\n\", gpio_source);\n\t\t\treturn;\n\t\t}\n\t}\n\n\tpconf0 = VLV_GPIO_PCONF0(map->base_offset);\n\tpadval = VLV_GPIO_PAD_VAL(map->base_offset);\n\n\tvlv_iosf_sb_get(dev_priv, BIT(VLV_IOSF_SB_GPIO));\n\tif (!map->init) {\n\t\t \n\t\tvlv_iosf_sb_write(dev_priv, port, pconf0, 0x2000CC00);\n\t\tmap->init = true;\n\t}\n\n\ttmp = 0x4 | value;\n\tvlv_iosf_sb_write(dev_priv, port, padval, tmp);\n\tvlv_iosf_sb_put(dev_priv, BIT(VLV_IOSF_SB_GPIO));\n}\n\nstatic void chv_exec_gpio(struct intel_connector *connector,\n\t\t\t  u8 gpio_source, u8 gpio_index, bool value)\n{\n\tstruct drm_i915_private *dev_priv = to_i915(connector->base.dev);\n\tu16 cfg0, cfg1;\n\tu16 family_num;\n\tu8 port;\n\n\tif (connector->panel.vbt.dsi.seq_version >= 3) {\n\t\tif (gpio_index >= CHV_GPIO_IDX_START_SE) {\n\t\t\t \n\t\t\tgpio_index -= CHV_GPIO_IDX_START_SE;\n\t\t\tport = CHV_IOSF_PORT_GPIO_SE;\n\t\t} else if (gpio_index >= CHV_GPIO_IDX_START_SW) {\n\t\t\tgpio_index -= CHV_GPIO_IDX_START_SW;\n\t\t\tport = CHV_IOSF_PORT_GPIO_SW;\n\t\t} else if (gpio_index >= CHV_GPIO_IDX_START_E) {\n\t\t\tgpio_index -= CHV_GPIO_IDX_START_E;\n\t\t\tport = CHV_IOSF_PORT_GPIO_E;\n\t\t} else {\n\t\t\tport = CHV_IOSF_PORT_GPIO_N;\n\t\t}\n\t} else {\n\t\t \n\t\tif (gpio_source != 0) {\n\t\t\tdrm_dbg_kms(&dev_priv->drm,\n\t\t\t\t    \"unknown gpio source %u\\n\", gpio_source);\n\t\t\treturn;\n\t\t}\n\n\t\tif (gpio_index >= CHV_GPIO_IDX_START_E) {\n\t\t\tdrm_dbg_kms(&dev_priv->drm,\n\t\t\t\t    \"invalid gpio index %u for GPIO N\\n\",\n\t\t\t\t    gpio_index);\n\t\t\treturn;\n\t\t}\n\n\t\tport = CHV_IOSF_PORT_GPIO_N;\n\t}\n\n\tfamily_num = gpio_index / CHV_VBT_MAX_PINS_PER_FMLY;\n\tgpio_index = gpio_index % CHV_VBT_MAX_PINS_PER_FMLY;\n\n\tcfg0 = CHV_GPIO_PAD_CFG0(family_num, gpio_index);\n\tcfg1 = CHV_GPIO_PAD_CFG1(family_num, gpio_index);\n\n\tvlv_iosf_sb_get(dev_priv, BIT(VLV_IOSF_SB_GPIO));\n\tvlv_iosf_sb_write(dev_priv, port, cfg1, 0);\n\tvlv_iosf_sb_write(dev_priv, port, cfg0,\n\t\t\t  CHV_GPIO_GPIOEN | CHV_GPIO_GPIOCFG_GPO |\n\t\t\t  CHV_GPIO_GPIOTXSTATE(value));\n\tvlv_iosf_sb_put(dev_priv, BIT(VLV_IOSF_SB_GPIO));\n}\n\nstatic void bxt_exec_gpio(struct intel_connector *connector,\n\t\t\t  u8 gpio_source, u8 gpio_index, bool value)\n{\n\tstruct drm_i915_private *dev_priv = to_i915(connector->base.dev);\n\t \n\tstatic struct gpio_desc *bxt_gpio_table[U8_MAX + 1];\n\tstruct gpio_desc *gpio_desc = bxt_gpio_table[gpio_index];\n\n\tif (!gpio_desc) {\n\t\tgpio_desc = devm_gpiod_get_index(dev_priv->drm.dev,\n\t\t\t\t\t\t NULL, gpio_index,\n\t\t\t\t\t\t value ? GPIOD_OUT_LOW :\n\t\t\t\t\t\t GPIOD_OUT_HIGH);\n\n\t\tif (IS_ERR_OR_NULL(gpio_desc)) {\n\t\t\tdrm_err(&dev_priv->drm,\n\t\t\t\t\"GPIO index %u request failed (%ld)\\n\",\n\t\t\t\tgpio_index, PTR_ERR(gpio_desc));\n\t\t\treturn;\n\t\t}\n\n\t\tbxt_gpio_table[gpio_index] = gpio_desc;\n\t}\n\n\tgpiod_set_value(gpio_desc, value);\n}\n\nstatic void icl_exec_gpio(struct intel_connector *connector,\n\t\t\t  u8 gpio_source, u8 gpio_index, bool value)\n{\n\tstruct drm_i915_private *dev_priv = to_i915(connector->base.dev);\n\n\tdrm_dbg_kms(&dev_priv->drm, \"Skipping ICL GPIO element execution\\n\");\n}\n\nenum {\n\tMIPI_RESET_1 = 0,\n\tMIPI_AVDD_EN_1,\n\tMIPI_BKLT_EN_1,\n\tMIPI_AVEE_EN_1,\n\tMIPI_VIO_EN_1,\n\tMIPI_RESET_2,\n\tMIPI_AVDD_EN_2,\n\tMIPI_BKLT_EN_2,\n\tMIPI_AVEE_EN_2,\n\tMIPI_VIO_EN_2,\n};\n\nstatic void icl_native_gpio_set_value(struct drm_i915_private *dev_priv,\n\t\t\t\t      int gpio, bool value)\n{\n\tint index;\n\n\tif (drm_WARN_ON(&dev_priv->drm, DISPLAY_VER(dev_priv) == 11 && gpio >= MIPI_RESET_2))\n\t\treturn;\n\n\tswitch (gpio) {\n\tcase MIPI_RESET_1:\n\tcase MIPI_RESET_2:\n\t\tindex = gpio == MIPI_RESET_1 ? HPD_PORT_A : HPD_PORT_B;\n\n\t\t \n\t\tspin_lock_irq(&dev_priv->irq_lock);\n\t\tintel_de_rmw(dev_priv, SHOTPLUG_CTL_DDI,\n\t\t\t     SHOTPLUG_CTL_DDI_HPD_ENABLE(index) |\n\t\t\t     SHOTPLUG_CTL_DDI_HPD_OUTPUT_DATA(index),\n\t\t\t     value ? SHOTPLUG_CTL_DDI_HPD_OUTPUT_DATA(index) : 0);\n\t\tspin_unlock_irq(&dev_priv->irq_lock);\n\t\tbreak;\n\tcase MIPI_AVDD_EN_1:\n\tcase MIPI_AVDD_EN_2:\n\t\tindex = gpio == MIPI_AVDD_EN_1 ? 0 : 1;\n\n\t\tintel_de_rmw(dev_priv, PP_CONTROL(index), PANEL_POWER_ON,\n\t\t\t     value ? PANEL_POWER_ON : 0);\n\t\tbreak;\n\tcase MIPI_BKLT_EN_1:\n\tcase MIPI_BKLT_EN_2:\n\t\tindex = gpio == MIPI_BKLT_EN_1 ? 0 : 1;\n\n\t\tintel_de_rmw(dev_priv, PP_CONTROL(index), EDP_BLC_ENABLE,\n\t\t\t     value ? EDP_BLC_ENABLE : 0);\n\t\tbreak;\n\tcase MIPI_AVEE_EN_1:\n\tcase MIPI_AVEE_EN_2:\n\t\tindex = gpio == MIPI_AVEE_EN_1 ? 1 : 2;\n\n\t\tintel_de_rmw(dev_priv, GPIO(dev_priv, index),\n\t\t\t     GPIO_CLOCK_VAL_OUT,\n\t\t\t     GPIO_CLOCK_DIR_MASK | GPIO_CLOCK_DIR_OUT |\n\t\t\t     GPIO_CLOCK_VAL_MASK | (value ? GPIO_CLOCK_VAL_OUT : 0));\n\t\tbreak;\n\tcase MIPI_VIO_EN_1:\n\tcase MIPI_VIO_EN_2:\n\t\tindex = gpio == MIPI_VIO_EN_1 ? 1 : 2;\n\n\t\tintel_de_rmw(dev_priv, GPIO(dev_priv, index),\n\t\t\t     GPIO_DATA_VAL_OUT,\n\t\t\t     GPIO_DATA_DIR_MASK | GPIO_DATA_DIR_OUT |\n\t\t\t     GPIO_DATA_VAL_MASK | (value ? GPIO_DATA_VAL_OUT : 0));\n\t\tbreak;\n\tdefault:\n\t\tMISSING_CASE(gpio);\n\t}\n}\n\nstatic const u8 *mipi_exec_gpio(struct intel_dsi *intel_dsi, const u8 *data)\n{\n\tstruct drm_device *dev = intel_dsi->base.base.dev;\n\tstruct drm_i915_private *dev_priv = to_i915(dev);\n\tstruct intel_connector *connector = intel_dsi->attached_connector;\n\tu8 gpio_source, gpio_index = 0, gpio_number;\n\tbool value;\n\tbool native = DISPLAY_VER(dev_priv) >= 11;\n\n\tif (connector->panel.vbt.dsi.seq_version >= 3)\n\t\tgpio_index = *data++;\n\n\tgpio_number = *data++;\n\n\t \n\tif (connector->panel.vbt.dsi.seq_version == 2)\n\t\tgpio_source = (*data >> 1) & 3;\n\telse\n\t\tgpio_source = 0;\n\n\tif (connector->panel.vbt.dsi.seq_version >= 4 && *data & BIT(1))\n\t\tnative = false;\n\n\t \n\tvalue = *data++ & 1;\n\n\tdrm_dbg_kms(&dev_priv->drm, \"GPIO index %u, number %u, source %u, native %s, set to %s\\n\",\n\t\t    gpio_index, gpio_number, gpio_source, str_yes_no(native), str_on_off(value));\n\n\tif (native)\n\t\ticl_native_gpio_set_value(dev_priv, gpio_number, value);\n\telse if (DISPLAY_VER(dev_priv) >= 11)\n\t\ticl_exec_gpio(connector, gpio_source, gpio_index, value);\n\telse if (IS_VALLEYVIEW(dev_priv))\n\t\tvlv_exec_gpio(connector, gpio_source, gpio_number, value);\n\telse if (IS_CHERRYVIEW(dev_priv))\n\t\tchv_exec_gpio(connector, gpio_source, gpio_number, value);\n\telse\n\t\tbxt_exec_gpio(connector, gpio_source, gpio_index, value);\n\n\treturn data;\n}\n\n#ifdef CONFIG_ACPI\nstatic int i2c_adapter_lookup(struct acpi_resource *ares, void *data)\n{\n\tstruct i2c_adapter_lookup *lookup = data;\n\tstruct intel_dsi *intel_dsi = lookup->intel_dsi;\n\tstruct acpi_resource_i2c_serialbus *sb;\n\tstruct i2c_adapter *adapter;\n\tacpi_handle adapter_handle;\n\tacpi_status status;\n\n\tif (!i2c_acpi_get_i2c_resource(ares, &sb))\n\t\treturn 1;\n\n\tif (lookup->slave_addr != sb->slave_address)\n\t\treturn 1;\n\n\tstatus = acpi_get_handle(lookup->dev_handle,\n\t\t\t\t sb->resource_source.string_ptr,\n\t\t\t\t &adapter_handle);\n\tif (ACPI_FAILURE(status))\n\t\treturn 1;\n\n\tadapter = i2c_acpi_find_adapter_by_handle(adapter_handle);\n\tif (adapter)\n\t\tintel_dsi->i2c_bus_num = adapter->nr;\n\n\treturn 1;\n}\n\nstatic void i2c_acpi_find_adapter(struct intel_dsi *intel_dsi,\n\t\t\t\t  const u16 slave_addr)\n{\n\tstruct drm_device *drm_dev = intel_dsi->base.base.dev;\n\tstruct acpi_device *adev = ACPI_COMPANION(drm_dev->dev);\n\tstruct i2c_adapter_lookup lookup = {\n\t\t.slave_addr = slave_addr,\n\t\t.intel_dsi = intel_dsi,\n\t\t.dev_handle = acpi_device_handle(adev),\n\t};\n\tLIST_HEAD(resource_list);\n\n\tacpi_dev_get_resources(adev, &resource_list, i2c_adapter_lookup, &lookup);\n\tacpi_dev_free_resource_list(&resource_list);\n}\n#else\nstatic inline void i2c_acpi_find_adapter(struct intel_dsi *intel_dsi,\n\t\t\t\t\t const u16 slave_addr)\n{\n}\n#endif\n\nstatic const u8 *mipi_exec_i2c(struct intel_dsi *intel_dsi, const u8 *data)\n{\n\tstruct drm_i915_private *i915 = to_i915(intel_dsi->base.base.dev);\n\tstruct i2c_adapter *adapter;\n\tstruct i2c_msg msg;\n\tint ret;\n\tu8 vbt_i2c_bus_num = *(data + 2);\n\tu16 slave_addr = *(u16 *)(data + 3);\n\tu8 reg_offset = *(data + 5);\n\tu8 payload_size = *(data + 6);\n\tu8 *payload_data;\n\n\tif (intel_dsi->i2c_bus_num < 0) {\n\t\tintel_dsi->i2c_bus_num = vbt_i2c_bus_num;\n\t\ti2c_acpi_find_adapter(intel_dsi, slave_addr);\n\t}\n\n\tadapter = i2c_get_adapter(intel_dsi->i2c_bus_num);\n\tif (!adapter) {\n\t\tdrm_err(&i915->drm, \"Cannot find a valid i2c bus for xfer\\n\");\n\t\tgoto err_bus;\n\t}\n\n\tpayload_data = kzalloc(payload_size + 1, GFP_KERNEL);\n\tif (!payload_data)\n\t\tgoto err_alloc;\n\n\tpayload_data[0] = reg_offset;\n\tmemcpy(&payload_data[1], (data + 7), payload_size);\n\n\tmsg.addr = slave_addr;\n\tmsg.flags = 0;\n\tmsg.len = payload_size + 1;\n\tmsg.buf = payload_data;\n\n\tret = i2c_transfer(adapter, &msg, 1);\n\tif (ret < 0)\n\t\tdrm_err(&i915->drm,\n\t\t\t\"Failed to xfer payload of size (%u) to reg (%u)\\n\",\n\t\t\tpayload_size, reg_offset);\n\n\tkfree(payload_data);\nerr_alloc:\n\ti2c_put_adapter(adapter);\nerr_bus:\n\treturn data + payload_size + 7;\n}\n\nstatic const u8 *mipi_exec_spi(struct intel_dsi *intel_dsi, const u8 *data)\n{\n\tstruct drm_i915_private *i915 = to_i915(intel_dsi->base.base.dev);\n\n\tdrm_dbg_kms(&i915->drm, \"Skipping SPI element execution\\n\");\n\n\treturn data + *(data + 5) + 6;\n}\n\nstatic const u8 *mipi_exec_pmic(struct intel_dsi *intel_dsi, const u8 *data)\n{\n\tstruct drm_i915_private *i915 = to_i915(intel_dsi->base.base.dev);\n#ifdef CONFIG_PMIC_OPREGION\n\tu32 value, mask, reg_address;\n\tu16 i2c_address;\n\tint ret;\n\n\t \n\ti2c_address\t= get_unaligned_le16(data + 1);\n\treg_address\t= get_unaligned_le32(data + 3);\n\tvalue\t\t= get_unaligned_le32(data + 7);\n\tmask\t\t= get_unaligned_le32(data + 11);\n\n\tret = intel_soc_pmic_exec_mipi_pmic_seq_element(i2c_address,\n\t\t\t\t\t\t\treg_address,\n\t\t\t\t\t\t\tvalue, mask);\n\tif (ret)\n\t\tdrm_err(&i915->drm, \"%s failed, error: %d\\n\", __func__, ret);\n#else\n\tdrm_err(&i915->drm,\n\t\t\"Your hardware requires CONFIG_PMIC_OPREGION and it is not set\\n\");\n#endif\n\n\treturn data + 15;\n}\n\ntypedef const u8 * (*fn_mipi_elem_exec)(struct intel_dsi *intel_dsi,\n\t\t\t\t\tconst u8 *data);\nstatic const fn_mipi_elem_exec exec_elem[] = {\n\t[MIPI_SEQ_ELEM_SEND_PKT] = mipi_exec_send_packet,\n\t[MIPI_SEQ_ELEM_DELAY] = mipi_exec_delay,\n\t[MIPI_SEQ_ELEM_GPIO] = mipi_exec_gpio,\n\t[MIPI_SEQ_ELEM_I2C] = mipi_exec_i2c,\n\t[MIPI_SEQ_ELEM_SPI] = mipi_exec_spi,\n\t[MIPI_SEQ_ELEM_PMIC] = mipi_exec_pmic,\n};\n\n \n\nstatic const char * const seq_name[] = {\n\t[MIPI_SEQ_DEASSERT_RESET] = \"MIPI_SEQ_DEASSERT_RESET\",\n\t[MIPI_SEQ_INIT_OTP] = \"MIPI_SEQ_INIT_OTP\",\n\t[MIPI_SEQ_DISPLAY_ON] = \"MIPI_SEQ_DISPLAY_ON\",\n\t[MIPI_SEQ_DISPLAY_OFF]  = \"MIPI_SEQ_DISPLAY_OFF\",\n\t[MIPI_SEQ_ASSERT_RESET] = \"MIPI_SEQ_ASSERT_RESET\",\n\t[MIPI_SEQ_BACKLIGHT_ON] = \"MIPI_SEQ_BACKLIGHT_ON\",\n\t[MIPI_SEQ_BACKLIGHT_OFF] = \"MIPI_SEQ_BACKLIGHT_OFF\",\n\t[MIPI_SEQ_TEAR_ON] = \"MIPI_SEQ_TEAR_ON\",\n\t[MIPI_SEQ_TEAR_OFF] = \"MIPI_SEQ_TEAR_OFF\",\n\t[MIPI_SEQ_POWER_ON] = \"MIPI_SEQ_POWER_ON\",\n\t[MIPI_SEQ_POWER_OFF] = \"MIPI_SEQ_POWER_OFF\",\n};\n\nstatic const char *sequence_name(enum mipi_seq seq_id)\n{\n\tif (seq_id < ARRAY_SIZE(seq_name) && seq_name[seq_id])\n\t\treturn seq_name[seq_id];\n\telse\n\t\treturn \"(unknown)\";\n}\n\nstatic void intel_dsi_vbt_exec(struct intel_dsi *intel_dsi,\n\t\t\t       enum mipi_seq seq_id)\n{\n\tstruct drm_i915_private *dev_priv = to_i915(intel_dsi->base.base.dev);\n\tstruct intel_connector *connector = intel_dsi->attached_connector;\n\tconst u8 *data;\n\tfn_mipi_elem_exec mipi_elem_exec;\n\n\tif (drm_WARN_ON(&dev_priv->drm,\n\t\t\tseq_id >= ARRAY_SIZE(connector->panel.vbt.dsi.sequence)))\n\t\treturn;\n\n\tdata = connector->panel.vbt.dsi.sequence[seq_id];\n\tif (!data)\n\t\treturn;\n\n\tdrm_WARN_ON(&dev_priv->drm, *data != seq_id);\n\n\tdrm_dbg_kms(&dev_priv->drm, \"Starting MIPI sequence %d - %s\\n\",\n\t\t    seq_id, sequence_name(seq_id));\n\n\t \n\tdata++;\n\n\t \n\tif (connector->panel.vbt.dsi.seq_version >= 3)\n\t\tdata += 4;\n\n\twhile (1) {\n\t\tu8 operation_byte = *data++;\n\t\tu8 operation_size = 0;\n\n\t\tif (operation_byte == MIPI_SEQ_ELEM_END)\n\t\t\tbreak;\n\n\t\tif (operation_byte < ARRAY_SIZE(exec_elem))\n\t\t\tmipi_elem_exec = exec_elem[operation_byte];\n\t\telse\n\t\t\tmipi_elem_exec = NULL;\n\n\t\t \n\t\tif (connector->panel.vbt.dsi.seq_version >= 3)\n\t\t\toperation_size = *data++;\n\n\t\tif (mipi_elem_exec) {\n\t\t\tconst u8 *next = data + operation_size;\n\n\t\t\tdata = mipi_elem_exec(intel_dsi, data);\n\n\t\t\t \n\t\t\tif (operation_size && data != next) {\n\t\t\t\tdrm_err(&dev_priv->drm,\n\t\t\t\t\t\"Inconsistent operation size\\n\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t} else if (operation_size) {\n\t\t\t \n\t\t\tdrm_dbg_kms(&dev_priv->drm,\n\t\t\t\t    \"Unsupported MIPI operation byte %u\\n\",\n\t\t\t\t    operation_byte);\n\t\t\tdata += operation_size;\n\t\t} else {\n\t\t\t \n\t\t\tdrm_err(&dev_priv->drm,\n\t\t\t\t\"Unsupported MIPI operation byte %u\\n\",\n\t\t\t\toperation_byte);\n\t\t\treturn;\n\t\t}\n\t}\n}\n\nvoid intel_dsi_vbt_exec_sequence(struct intel_dsi *intel_dsi,\n\t\t\t\t enum mipi_seq seq_id)\n{\n\tif (seq_id == MIPI_SEQ_POWER_ON && intel_dsi->gpio_panel)\n\t\tgpiod_set_value_cansleep(intel_dsi->gpio_panel, 1);\n\tif (seq_id == MIPI_SEQ_BACKLIGHT_ON && intel_dsi->gpio_backlight)\n\t\tgpiod_set_value_cansleep(intel_dsi->gpio_backlight, 1);\n\n\tintel_dsi_vbt_exec(intel_dsi, seq_id);\n\n\tif (seq_id == MIPI_SEQ_POWER_OFF && intel_dsi->gpio_panel)\n\t\tgpiod_set_value_cansleep(intel_dsi->gpio_panel, 0);\n\tif (seq_id == MIPI_SEQ_BACKLIGHT_OFF && intel_dsi->gpio_backlight)\n\t\tgpiod_set_value_cansleep(intel_dsi->gpio_backlight, 0);\n}\n\nvoid intel_dsi_log_params(struct intel_dsi *intel_dsi)\n{\n\tstruct drm_i915_private *i915 = to_i915(intel_dsi->base.base.dev);\n\n\tdrm_dbg_kms(&i915->drm, \"Pclk %d\\n\", intel_dsi->pclk);\n\tdrm_dbg_kms(&i915->drm, \"Pixel overlap %d\\n\",\n\t\t    intel_dsi->pixel_overlap);\n\tdrm_dbg_kms(&i915->drm, \"Lane count %d\\n\", intel_dsi->lane_count);\n\tdrm_dbg_kms(&i915->drm, \"DPHY param reg 0x%x\\n\", intel_dsi->dphy_reg);\n\tdrm_dbg_kms(&i915->drm, \"Video mode format %s\\n\",\n\t\t    intel_dsi->video_mode == NON_BURST_SYNC_PULSE ?\n\t\t    \"non-burst with sync pulse\" :\n\t\t    intel_dsi->video_mode == NON_BURST_SYNC_EVENTS ?\n\t\t    \"non-burst with sync events\" :\n\t\t    intel_dsi->video_mode == BURST_MODE ?\n\t\t    \"burst\" : \"<unknown>\");\n\tdrm_dbg_kms(&i915->drm, \"Burst mode ratio %d\\n\",\n\t\t    intel_dsi->burst_mode_ratio);\n\tdrm_dbg_kms(&i915->drm, \"Reset timer %d\\n\", intel_dsi->rst_timer_val);\n\tdrm_dbg_kms(&i915->drm, \"Eot %s\\n\",\n\t\t    str_enabled_disabled(intel_dsi->eotp_pkt));\n\tdrm_dbg_kms(&i915->drm, \"Clockstop %s\\n\",\n\t\t    str_enabled_disabled(!intel_dsi->clock_stop));\n\tdrm_dbg_kms(&i915->drm, \"Mode %s\\n\",\n\t\t    intel_dsi->operation_mode ? \"command\" : \"video\");\n\tif (intel_dsi->dual_link == DSI_DUAL_LINK_FRONT_BACK)\n\t\tdrm_dbg_kms(&i915->drm,\n\t\t\t    \"Dual link: DSI_DUAL_LINK_FRONT_BACK\\n\");\n\telse if (intel_dsi->dual_link == DSI_DUAL_LINK_PIXEL_ALT)\n\t\tdrm_dbg_kms(&i915->drm,\n\t\t\t    \"Dual link: DSI_DUAL_LINK_PIXEL_ALT\\n\");\n\telse\n\t\tdrm_dbg_kms(&i915->drm, \"Dual link: NONE\\n\");\n\tdrm_dbg_kms(&i915->drm, \"Pixel Format %d\\n\", intel_dsi->pixel_format);\n\tdrm_dbg_kms(&i915->drm, \"TLPX %d\\n\", intel_dsi->escape_clk_div);\n\tdrm_dbg_kms(&i915->drm, \"LP RX Timeout 0x%x\\n\",\n\t\t    intel_dsi->lp_rx_timeout);\n\tdrm_dbg_kms(&i915->drm, \"Turnaround Timeout 0x%x\\n\",\n\t\t    intel_dsi->turn_arnd_val);\n\tdrm_dbg_kms(&i915->drm, \"Init Count 0x%x\\n\", intel_dsi->init_count);\n\tdrm_dbg_kms(&i915->drm, \"HS to LP Count 0x%x\\n\",\n\t\t    intel_dsi->hs_to_lp_count);\n\tdrm_dbg_kms(&i915->drm, \"LP Byte Clock %d\\n\", intel_dsi->lp_byte_clk);\n\tdrm_dbg_kms(&i915->drm, \"DBI BW Timer 0x%x\\n\", intel_dsi->bw_timer);\n\tdrm_dbg_kms(&i915->drm, \"LP to HS Clock Count 0x%x\\n\",\n\t\t    intel_dsi->clk_lp_to_hs_count);\n\tdrm_dbg_kms(&i915->drm, \"HS to LP Clock Count 0x%x\\n\",\n\t\t    intel_dsi->clk_hs_to_lp_count);\n\tdrm_dbg_kms(&i915->drm, \"BTA %s\\n\",\n\t\t    str_enabled_disabled(!(intel_dsi->video_frmt_cfg_bits & DISABLE_VIDEO_BTA)));\n}\n\nbool intel_dsi_vbt_init(struct intel_dsi *intel_dsi, u16 panel_id)\n{\n\tstruct drm_device *dev = intel_dsi->base.base.dev;\n\tstruct drm_i915_private *dev_priv = to_i915(dev);\n\tstruct intel_connector *connector = intel_dsi->attached_connector;\n\tstruct mipi_config *mipi_config = connector->panel.vbt.dsi.config;\n\tstruct mipi_pps_data *pps = connector->panel.vbt.dsi.pps;\n\tstruct drm_display_mode *mode = connector->panel.vbt.lfp_lvds_vbt_mode;\n\tu16 burst_mode_ratio;\n\tenum port port;\n\n\tdrm_dbg_kms(&dev_priv->drm, \"\\n\");\n\n\tintel_dsi->eotp_pkt = mipi_config->eot_pkt_disabled ? 0 : 1;\n\tintel_dsi->clock_stop = mipi_config->enable_clk_stop ? 1 : 0;\n\tintel_dsi->lane_count = mipi_config->lane_cnt + 1;\n\tintel_dsi->pixel_format =\n\t\t\tpixel_format_from_register_bits(\n\t\t\t\tmipi_config->videomode_color_format << 7);\n\n\tintel_dsi->dual_link = mipi_config->dual_link;\n\tintel_dsi->pixel_overlap = mipi_config->pixel_overlap;\n\tintel_dsi->operation_mode = mipi_config->is_cmd_mode;\n\tintel_dsi->video_mode = mipi_config->video_transfer_mode;\n\tintel_dsi->escape_clk_div = mipi_config->byte_clk_sel;\n\tintel_dsi->lp_rx_timeout = mipi_config->lp_rx_timeout;\n\tintel_dsi->hs_tx_timeout = mipi_config->hs_tx_timeout;\n\tintel_dsi->turn_arnd_val = mipi_config->turn_around_timeout;\n\tintel_dsi->rst_timer_val = mipi_config->device_reset_timer;\n\tintel_dsi->init_count = mipi_config->master_init_timer;\n\tintel_dsi->bw_timer = mipi_config->dbi_bw_timer;\n\tintel_dsi->video_frmt_cfg_bits =\n\t\tmipi_config->bta_enabled ? DISABLE_VIDEO_BTA : 0;\n\tintel_dsi->bgr_enabled = mipi_config->rgb_flip;\n\n\t \n\tintel_dsi->pclk = mode->clock;\n\n\t \n\tif (intel_dsi->dual_link) {\n\t\tintel_dsi->pclk /= 2;\n\n\t\t \n\t\tif (intel_dsi->dual_link == DSI_DUAL_LINK_FRONT_BACK) {\n\t\t\tintel_dsi->pclk += DIV_ROUND_UP(mode->vtotal * intel_dsi->pixel_overlap * 60, 1000);\n\t\t}\n\t}\n\n\t \n\tif (intel_dsi->video_mode == BURST_MODE) {\n\t\tif (mipi_config->target_burst_mode_freq) {\n\t\t\tu32 bitrate = intel_dsi_bitrate(intel_dsi);\n\n\t\t\t \n\t\t\tif (mipi_config->target_burst_mode_freq < bitrate &&\n\t\t\t    intel_fuzzy_clock_check(\n\t\t\t\t\tmipi_config->target_burst_mode_freq,\n\t\t\t\t\tbitrate))\n\t\t\t\tmipi_config->target_burst_mode_freq = bitrate;\n\n\t\t\tif (mipi_config->target_burst_mode_freq < bitrate) {\n\t\t\t\tdrm_err(&dev_priv->drm,\n\t\t\t\t\t\"Burst mode freq is less than computed\\n\");\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tburst_mode_ratio = DIV_ROUND_UP(\n\t\t\t\tmipi_config->target_burst_mode_freq * 100,\n\t\t\t\tbitrate);\n\n\t\t\tintel_dsi->pclk = DIV_ROUND_UP(intel_dsi->pclk * burst_mode_ratio, 100);\n\t\t} else {\n\t\t\tdrm_err(&dev_priv->drm,\n\t\t\t\t\"Burst mode target is not set\\n\");\n\t\t\treturn false;\n\t\t}\n\t} else\n\t\tburst_mode_ratio = 100;\n\n\tintel_dsi->burst_mode_ratio = burst_mode_ratio;\n\n\t \n\tintel_dsi->backlight_off_delay = pps->bl_disable_delay / 10;\n\tintel_dsi->backlight_on_delay = pps->bl_enable_delay / 10;\n\tintel_dsi->panel_on_delay = pps->panel_on_delay / 10;\n\tintel_dsi->panel_off_delay = pps->panel_off_delay / 10;\n\tintel_dsi->panel_pwr_cycle_delay = pps->panel_power_cycle_delay / 10;\n\n\tintel_dsi->i2c_bus_num = -1;\n\n\t \n\tfor_each_dsi_port(port, intel_dsi->ports) {\n\t\tmipi_dsi_attach(intel_dsi->dsi_hosts[port]->device);\n\t}\n\n\treturn true;\n}\n\n \nstatic struct gpiod_lookup_table pmic_panel_gpio_table = {\n\t \n\t.dev_id = \"0000:00:02.0\",\n\t.table = {\n\t\t \n\t\tGPIO_LOOKUP(\"gpio_crystalcove\", 94, \"panel\", GPIO_ACTIVE_HIGH),\n\t\t{ }\n\t},\n};\n\nstatic struct gpiod_lookup_table soc_panel_gpio_table = {\n\t.dev_id = \"0000:00:02.0\",\n\t.table = {\n\t\tGPIO_LOOKUP(\"INT33FC:01\", 10, \"backlight\", GPIO_ACTIVE_HIGH),\n\t\tGPIO_LOOKUP(\"INT33FC:01\", 11, \"panel\", GPIO_ACTIVE_HIGH),\n\t\t{ }\n\t},\n};\n\nstatic const struct pinctrl_map soc_pwm_pinctrl_map[] = {\n\tPIN_MAP_MUX_GROUP(\"0000:00:02.0\", \"soc_pwm0\", \"INT33FC:00\",\n\t\t\t  \"pwm0_grp\", \"pwm\"),\n};\n\nvoid intel_dsi_vbt_gpio_init(struct intel_dsi *intel_dsi, bool panel_is_on)\n{\n\tstruct drm_device *dev = intel_dsi->base.base.dev;\n\tstruct drm_i915_private *dev_priv = to_i915(dev);\n\tstruct intel_connector *connector = intel_dsi->attached_connector;\n\tstruct mipi_config *mipi_config = connector->panel.vbt.dsi.config;\n\tenum gpiod_flags flags = panel_is_on ? GPIOD_OUT_HIGH : GPIOD_OUT_LOW;\n\tbool want_backlight_gpio = false;\n\tbool want_panel_gpio = false;\n\tstruct pinctrl *pinctrl;\n\tint ret;\n\n\tif ((IS_VALLEYVIEW(dev_priv) || IS_CHERRYVIEW(dev_priv)) &&\n\t    mipi_config->pwm_blc == PPS_BLC_PMIC) {\n\t\tgpiod_add_lookup_table(&pmic_panel_gpio_table);\n\t\twant_panel_gpio = true;\n\t}\n\n\tif (IS_VALLEYVIEW(dev_priv) && mipi_config->pwm_blc == PPS_BLC_SOC) {\n\t\tgpiod_add_lookup_table(&soc_panel_gpio_table);\n\t\twant_panel_gpio = true;\n\t\twant_backlight_gpio = true;\n\n\t\t \n\t\tret = pinctrl_register_mappings(soc_pwm_pinctrl_map,\n\t\t\t\t\t     ARRAY_SIZE(soc_pwm_pinctrl_map));\n\t\tif (ret)\n\t\t\tdrm_err(&dev_priv->drm,\n\t\t\t\t\"Failed to register pwm0 pinmux mapping\\n\");\n\n\t\tpinctrl = devm_pinctrl_get_select(dev->dev, \"soc_pwm0\");\n\t\tif (IS_ERR(pinctrl))\n\t\t\tdrm_err(&dev_priv->drm,\n\t\t\t\t\"Failed to set pinmux to PWM\\n\");\n\t}\n\n\tif (want_panel_gpio) {\n\t\tintel_dsi->gpio_panel = gpiod_get(dev->dev, \"panel\", flags);\n\t\tif (IS_ERR(intel_dsi->gpio_panel)) {\n\t\t\tdrm_err(&dev_priv->drm,\n\t\t\t\t\"Failed to own gpio for panel control\\n\");\n\t\t\tintel_dsi->gpio_panel = NULL;\n\t\t}\n\t}\n\n\tif (want_backlight_gpio) {\n\t\tintel_dsi->gpio_backlight =\n\t\t\tgpiod_get(dev->dev, \"backlight\", flags);\n\t\tif (IS_ERR(intel_dsi->gpio_backlight)) {\n\t\t\tdrm_err(&dev_priv->drm,\n\t\t\t\t\"Failed to own gpio for backlight control\\n\");\n\t\t\tintel_dsi->gpio_backlight = NULL;\n\t\t}\n\t}\n}\n\nvoid intel_dsi_vbt_gpio_cleanup(struct intel_dsi *intel_dsi)\n{\n\tstruct drm_device *dev = intel_dsi->base.base.dev;\n\tstruct drm_i915_private *dev_priv = to_i915(dev);\n\tstruct intel_connector *connector = intel_dsi->attached_connector;\n\tstruct mipi_config *mipi_config = connector->panel.vbt.dsi.config;\n\n\tif (intel_dsi->gpio_panel) {\n\t\tgpiod_put(intel_dsi->gpio_panel);\n\t\tintel_dsi->gpio_panel = NULL;\n\t}\n\n\tif (intel_dsi->gpio_backlight) {\n\t\tgpiod_put(intel_dsi->gpio_backlight);\n\t\tintel_dsi->gpio_backlight = NULL;\n\t}\n\n\tif ((IS_VALLEYVIEW(dev_priv) || IS_CHERRYVIEW(dev_priv)) &&\n\t    mipi_config->pwm_blc == PPS_BLC_PMIC)\n\t\tgpiod_remove_lookup_table(&pmic_panel_gpio_table);\n\n\tif (IS_VALLEYVIEW(dev_priv) && mipi_config->pwm_blc == PPS_BLC_SOC) {\n\t\tpinctrl_unregister_mappings(soc_pwm_pinctrl_map);\n\t\tgpiod_remove_lookup_table(&soc_panel_gpio_table);\n\t}\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}