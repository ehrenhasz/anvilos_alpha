{
  "module_name": "intel_dp_hdcp.c",
  "hash_id": "fb2f9cfc36f2d3e2634259630fedf8a22065d1bb532aa8cfe815e63319e1a477",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/i915/display/intel_dp_hdcp.c",
  "human_readable_source": " \n \n\n#include <drm/display/drm_dp_helper.h>\n#include <drm/display/drm_dp_mst_helper.h>\n#include <drm/display/drm_hdcp_helper.h>\n#include <drm/drm_print.h>\n\n#include \"i915_reg.h\"\n#include \"intel_ddi.h\"\n#include \"intel_de.h\"\n#include \"intel_display_types.h\"\n#include \"intel_dp.h\"\n#include \"intel_dp_hdcp.h\"\n#include \"intel_hdcp.h\"\n#include \"intel_hdcp_regs.h\"\n\nstatic u32 transcoder_to_stream_enc_status(enum transcoder cpu_transcoder)\n{\n\tswitch (cpu_transcoder) {\n\tcase TRANSCODER_A:\n\t\treturn HDCP_STATUS_STREAM_A_ENC;\n\tcase TRANSCODER_B:\n\t\treturn HDCP_STATUS_STREAM_B_ENC;\n\tcase TRANSCODER_C:\n\t\treturn HDCP_STATUS_STREAM_C_ENC;\n\tcase TRANSCODER_D:\n\t\treturn HDCP_STATUS_STREAM_D_ENC;\n\tdefault:\n\t\treturn 0;\n\t}\n}\n\nstatic void intel_dp_hdcp_wait_for_cp_irq(struct intel_hdcp *hdcp, int timeout)\n{\n\tlong ret;\n\n#define C (hdcp->cp_irq_count_cached != atomic_read(&hdcp->cp_irq_count))\n\tret = wait_event_interruptible_timeout(hdcp->cp_irq_queue, C,\n\t\t\t\t\t       msecs_to_jiffies(timeout));\n\n\tif (!ret)\n\t\tDRM_DEBUG_KMS(\"Timedout at waiting for CP_IRQ\\n\");\n}\n\nstatic\nint intel_dp_hdcp_write_an_aksv(struct intel_digital_port *dig_port,\n\t\t\t\tu8 *an)\n{\n\tstruct drm_i915_private *i915 = to_i915(dig_port->base.base.dev);\n\tu8 aksv[DRM_HDCP_KSV_LEN] = {};\n\tssize_t dpcd_ret;\n\n\t \n\tdpcd_ret = drm_dp_dpcd_write(&dig_port->dp.aux, DP_AUX_HDCP_AN,\n\t\t\t\t     an, DRM_HDCP_AN_LEN);\n\tif (dpcd_ret != DRM_HDCP_AN_LEN) {\n\t\tdrm_dbg_kms(&i915->drm,\n\t\t\t    \"Failed to write An over DP/AUX (%zd)\\n\",\n\t\t\t    dpcd_ret);\n\t\treturn dpcd_ret >= 0 ? -EIO : dpcd_ret;\n\t}\n\n\t \n\tdpcd_ret = drm_dp_dpcd_write(&dig_port->dp.aux, DP_AUX_HDCP_AKSV,\n\t\t\t\t     aksv, DRM_HDCP_KSV_LEN);\n\tif (dpcd_ret != DRM_HDCP_KSV_LEN) {\n\t\tdrm_dbg_kms(&i915->drm,\n\t\t\t    \"Failed to write Aksv over DP/AUX (%zd)\\n\",\n\t\t\t    dpcd_ret);\n\t\treturn dpcd_ret >= 0 ? -EIO : dpcd_ret;\n\t}\n\treturn 0;\n}\n\nstatic int intel_dp_hdcp_read_bksv(struct intel_digital_port *dig_port,\n\t\t\t\t   u8 *bksv)\n{\n\tstruct drm_i915_private *i915 = to_i915(dig_port->base.base.dev);\n\tssize_t ret;\n\n\tret = drm_dp_dpcd_read(&dig_port->dp.aux, DP_AUX_HDCP_BKSV, bksv,\n\t\t\t       DRM_HDCP_KSV_LEN);\n\tif (ret != DRM_HDCP_KSV_LEN) {\n\t\tdrm_dbg_kms(&i915->drm,\n\t\t\t    \"Read Bksv from DP/AUX failed (%zd)\\n\", ret);\n\t\treturn ret >= 0 ? -EIO : ret;\n\t}\n\treturn 0;\n}\n\nstatic int intel_dp_hdcp_read_bstatus(struct intel_digital_port *dig_port,\n\t\t\t\t      u8 *bstatus)\n{\n\tstruct drm_i915_private *i915 = to_i915(dig_port->base.base.dev);\n\tssize_t ret;\n\n\t \n\tret = drm_dp_dpcd_read(&dig_port->dp.aux, DP_AUX_HDCP_BINFO,\n\t\t\t       bstatus, DRM_HDCP_BSTATUS_LEN);\n\tif (ret != DRM_HDCP_BSTATUS_LEN) {\n\t\tdrm_dbg_kms(&i915->drm,\n\t\t\t    \"Read bstatus from DP/AUX failed (%zd)\\n\", ret);\n\t\treturn ret >= 0 ? -EIO : ret;\n\t}\n\treturn 0;\n}\n\nstatic\nint intel_dp_hdcp_read_bcaps(struct intel_digital_port *dig_port,\n\t\t\t     u8 *bcaps)\n{\n\tstruct drm_i915_private *i915 = to_i915(dig_port->base.base.dev);\n\tssize_t ret;\n\n\tret = drm_dp_dpcd_read(&dig_port->dp.aux, DP_AUX_HDCP_BCAPS,\n\t\t\t       bcaps, 1);\n\tif (ret != 1) {\n\t\tdrm_dbg_kms(&i915->drm,\n\t\t\t    \"Read bcaps from DP/AUX failed (%zd)\\n\", ret);\n\t\treturn ret >= 0 ? -EIO : ret;\n\t}\n\n\treturn 0;\n}\n\nstatic\nint intel_dp_hdcp_repeater_present(struct intel_digital_port *dig_port,\n\t\t\t\t   bool *repeater_present)\n{\n\tssize_t ret;\n\tu8 bcaps;\n\n\tret = intel_dp_hdcp_read_bcaps(dig_port, &bcaps);\n\tif (ret)\n\t\treturn ret;\n\n\t*repeater_present = bcaps & DP_BCAPS_REPEATER_PRESENT;\n\treturn 0;\n}\n\nstatic\nint intel_dp_hdcp_read_ri_prime(struct intel_digital_port *dig_port,\n\t\t\t\tu8 *ri_prime)\n{\n\tstruct drm_i915_private *i915 = to_i915(dig_port->base.base.dev);\n\tssize_t ret;\n\n\tret = drm_dp_dpcd_read(&dig_port->dp.aux, DP_AUX_HDCP_RI_PRIME,\n\t\t\t       ri_prime, DRM_HDCP_RI_LEN);\n\tif (ret != DRM_HDCP_RI_LEN) {\n\t\tdrm_dbg_kms(&i915->drm, \"Read Ri' from DP/AUX failed (%zd)\\n\",\n\t\t\t    ret);\n\t\treturn ret >= 0 ? -EIO : ret;\n\t}\n\treturn 0;\n}\n\nstatic\nint intel_dp_hdcp_read_ksv_ready(struct intel_digital_port *dig_port,\n\t\t\t\t bool *ksv_ready)\n{\n\tstruct drm_i915_private *i915 = to_i915(dig_port->base.base.dev);\n\tssize_t ret;\n\tu8 bstatus;\n\n\tret = drm_dp_dpcd_read(&dig_port->dp.aux, DP_AUX_HDCP_BSTATUS,\n\t\t\t       &bstatus, 1);\n\tif (ret != 1) {\n\t\tdrm_dbg_kms(&i915->drm,\n\t\t\t    \"Read bstatus from DP/AUX failed (%zd)\\n\", ret);\n\t\treturn ret >= 0 ? -EIO : ret;\n\t}\n\t*ksv_ready = bstatus & DP_BSTATUS_READY;\n\treturn 0;\n}\n\nstatic\nint intel_dp_hdcp_read_ksv_fifo(struct intel_digital_port *dig_port,\n\t\t\t\tint num_downstream, u8 *ksv_fifo)\n{\n\tstruct drm_i915_private *i915 = to_i915(dig_port->base.base.dev);\n\tssize_t ret;\n\tint i;\n\n\t \n\tfor (i = 0; i < num_downstream; i += 3) {\n\t\tsize_t len = min(num_downstream - i, 3) * DRM_HDCP_KSV_LEN;\n\t\tret = drm_dp_dpcd_read(&dig_port->dp.aux,\n\t\t\t\t       DP_AUX_HDCP_KSV_FIFO,\n\t\t\t\t       ksv_fifo + i * DRM_HDCP_KSV_LEN,\n\t\t\t\t       len);\n\t\tif (ret != len) {\n\t\t\tdrm_dbg_kms(&i915->drm,\n\t\t\t\t    \"Read ksv[%d] from DP/AUX failed (%zd)\\n\",\n\t\t\t\t    i, ret);\n\t\t\treturn ret >= 0 ? -EIO : ret;\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic\nint intel_dp_hdcp_read_v_prime_part(struct intel_digital_port *dig_port,\n\t\t\t\t    int i, u32 *part)\n{\n\tstruct drm_i915_private *i915 = to_i915(dig_port->base.base.dev);\n\tssize_t ret;\n\n\tif (i >= DRM_HDCP_V_PRIME_NUM_PARTS)\n\t\treturn -EINVAL;\n\n\tret = drm_dp_dpcd_read(&dig_port->dp.aux,\n\t\t\t       DP_AUX_HDCP_V_PRIME(i), part,\n\t\t\t       DRM_HDCP_V_PRIME_PART_LEN);\n\tif (ret != DRM_HDCP_V_PRIME_PART_LEN) {\n\t\tdrm_dbg_kms(&i915->drm,\n\t\t\t    \"Read v'[%d] from DP/AUX failed (%zd)\\n\", i, ret);\n\t\treturn ret >= 0 ? -EIO : ret;\n\t}\n\treturn 0;\n}\n\nstatic\nint intel_dp_hdcp_toggle_signalling(struct intel_digital_port *dig_port,\n\t\t\t\t    enum transcoder cpu_transcoder,\n\t\t\t\t    bool enable)\n{\n\t \n\treturn 0;\n}\n\nstatic\nbool intel_dp_hdcp_check_link(struct intel_digital_port *dig_port,\n\t\t\t      struct intel_connector *connector)\n{\n\tstruct drm_i915_private *i915 = to_i915(dig_port->base.base.dev);\n\tssize_t ret;\n\tu8 bstatus;\n\n\tret = drm_dp_dpcd_read(&dig_port->dp.aux, DP_AUX_HDCP_BSTATUS,\n\t\t\t       &bstatus, 1);\n\tif (ret != 1) {\n\t\tdrm_dbg_kms(&i915->drm,\n\t\t\t    \"Read bstatus from DP/AUX failed (%zd)\\n\", ret);\n\t\treturn false;\n\t}\n\n\treturn !(bstatus & (DP_BSTATUS_LINK_FAILURE | DP_BSTATUS_REAUTH_REQ));\n}\n\nstatic\nint intel_dp_hdcp_capable(struct intel_digital_port *dig_port,\n\t\t\t  bool *hdcp_capable)\n{\n\tssize_t ret;\n\tu8 bcaps;\n\n\tret = intel_dp_hdcp_read_bcaps(dig_port, &bcaps);\n\tif (ret)\n\t\treturn ret;\n\n\t*hdcp_capable = bcaps & DP_BCAPS_HDCP_CAPABLE;\n\treturn 0;\n}\n\nstruct hdcp2_dp_errata_stream_type {\n\tu8\tmsg_id;\n\tu8\tstream_type;\n} __packed;\n\nstruct hdcp2_dp_msg_data {\n\tu8 msg_id;\n\tu32 offset;\n\tbool msg_detectable;\n\tu32 timeout;\n\tu32 timeout2;  \n\t \n\tu32 msg_read_timeout;\n};\n\nstatic const struct hdcp2_dp_msg_data hdcp2_dp_msg_data[] = {\n\t{ HDCP_2_2_AKE_INIT, DP_HDCP_2_2_AKE_INIT_OFFSET, false, 0, 0, 0},\n\t{ HDCP_2_2_AKE_SEND_CERT, DP_HDCP_2_2_AKE_SEND_CERT_OFFSET,\n\t  false, HDCP_2_2_CERT_TIMEOUT_MS, 0, HDCP_2_2_DP_CERT_READ_TIMEOUT_MS},\n\t{ HDCP_2_2_AKE_NO_STORED_KM, DP_HDCP_2_2_AKE_NO_STORED_KM_OFFSET,\n\t  false, 0, 0, 0 },\n\t{ HDCP_2_2_AKE_STORED_KM, DP_HDCP_2_2_AKE_STORED_KM_OFFSET,\n\t  false, 0, 0, 0 },\n\t{ HDCP_2_2_AKE_SEND_HPRIME, DP_HDCP_2_2_AKE_SEND_HPRIME_OFFSET,\n\t  true, HDCP_2_2_HPRIME_PAIRED_TIMEOUT_MS,\n\t  HDCP_2_2_HPRIME_NO_PAIRED_TIMEOUT_MS, HDCP_2_2_DP_HPRIME_READ_TIMEOUT_MS},\n\t{ HDCP_2_2_AKE_SEND_PAIRING_INFO,\n\t  DP_HDCP_2_2_AKE_SEND_PAIRING_INFO_OFFSET, true,\n\t  HDCP_2_2_PAIRING_TIMEOUT_MS, 0, HDCP_2_2_DP_PAIRING_READ_TIMEOUT_MS },\n\t{ HDCP_2_2_LC_INIT, DP_HDCP_2_2_LC_INIT_OFFSET, false, 0, 0, 0 },\n\t{ HDCP_2_2_LC_SEND_LPRIME, DP_HDCP_2_2_LC_SEND_LPRIME_OFFSET,\n\t  false, HDCP_2_2_DP_LPRIME_TIMEOUT_MS, 0, 0 },\n\t{ HDCP_2_2_SKE_SEND_EKS, DP_HDCP_2_2_SKE_SEND_EKS_OFFSET, false,\n\t  0, 0, 0 },\n\t{ HDCP_2_2_REP_SEND_RECVID_LIST,\n\t  DP_HDCP_2_2_REP_SEND_RECVID_LIST_OFFSET, true,\n\t  HDCP_2_2_RECVID_LIST_TIMEOUT_MS, 0, 0 },\n\t{ HDCP_2_2_REP_SEND_ACK, DP_HDCP_2_2_REP_SEND_ACK_OFFSET, false,\n\t  0, 0, 0 },\n\t{ HDCP_2_2_REP_STREAM_MANAGE,\n\t  DP_HDCP_2_2_REP_STREAM_MANAGE_OFFSET, false,\n\t  0, 0, 0},\n\t{ HDCP_2_2_REP_STREAM_READY, DP_HDCP_2_2_REP_STREAM_READY_OFFSET,\n\t  false, HDCP_2_2_STREAM_READY_TIMEOUT_MS, 0, 0 },\n \n#define HDCP_2_2_ERRATA_DP_STREAM_TYPE\t50\n\t{ HDCP_2_2_ERRATA_DP_STREAM_TYPE,\n\t  DP_HDCP_2_2_REG_STREAM_TYPE_OFFSET, false,\n\t  0, 0 },\n};\n\nstatic int\nintel_dp_hdcp2_read_rx_status(struct intel_digital_port *dig_port,\n\t\t\t      u8 *rx_status)\n{\n\tstruct drm_i915_private *i915 = to_i915(dig_port->base.base.dev);\n\tssize_t ret;\n\n\tret = drm_dp_dpcd_read(&dig_port->dp.aux,\n\t\t\t       DP_HDCP_2_2_REG_RXSTATUS_OFFSET, rx_status,\n\t\t\t       HDCP_2_2_DP_RXSTATUS_LEN);\n\tif (ret != HDCP_2_2_DP_RXSTATUS_LEN) {\n\t\tdrm_dbg_kms(&i915->drm,\n\t\t\t    \"Read bstatus from DP/AUX failed (%zd)\\n\", ret);\n\t\treturn ret >= 0 ? -EIO : ret;\n\t}\n\n\treturn 0;\n}\n\nstatic\nint hdcp2_detect_msg_availability(struct intel_digital_port *dig_port,\n\t\t\t\t  u8 msg_id, bool *msg_ready)\n{\n\tu8 rx_status;\n\tint ret;\n\n\t*msg_ready = false;\n\tret = intel_dp_hdcp2_read_rx_status(dig_port, &rx_status);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tswitch (msg_id) {\n\tcase HDCP_2_2_AKE_SEND_HPRIME:\n\t\tif (HDCP_2_2_DP_RXSTATUS_H_PRIME(rx_status))\n\t\t\t*msg_ready = true;\n\t\tbreak;\n\tcase HDCP_2_2_AKE_SEND_PAIRING_INFO:\n\t\tif (HDCP_2_2_DP_RXSTATUS_PAIRING(rx_status))\n\t\t\t*msg_ready = true;\n\t\tbreak;\n\tcase HDCP_2_2_REP_SEND_RECVID_LIST:\n\t\tif (HDCP_2_2_DP_RXSTATUS_READY(rx_status))\n\t\t\t*msg_ready = true;\n\t\tbreak;\n\tdefault:\n\t\tDRM_ERROR(\"Unidentified msg_id: %d\\n\", msg_id);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic ssize_t\nintel_dp_hdcp2_wait_for_msg(struct intel_digital_port *dig_port,\n\t\t\t    const struct hdcp2_dp_msg_data *hdcp2_msg_data)\n{\n\tstruct drm_i915_private *i915 = to_i915(dig_port->base.base.dev);\n\tstruct intel_dp *dp = &dig_port->dp;\n\tstruct intel_hdcp *hdcp = &dp->attached_connector->hdcp;\n\tu8 msg_id = hdcp2_msg_data->msg_id;\n\tint ret, timeout;\n\tbool msg_ready = false;\n\n\tif (msg_id == HDCP_2_2_AKE_SEND_HPRIME && !hdcp->is_paired)\n\t\ttimeout = hdcp2_msg_data->timeout2;\n\telse\n\t\ttimeout = hdcp2_msg_data->timeout;\n\n\t \n\tif (!hdcp2_msg_data->msg_detectable) {\n\t\tmdelay(timeout);\n\t\tret = 0;\n\t} else {\n\t\t \n\t\tintel_dp_hdcp_wait_for_cp_irq(hdcp, timeout);\n\t\tret = hdcp2_detect_msg_availability(dig_port,\n\t\t\t\t\t\t    msg_id, &msg_ready);\n\t\tif (!msg_ready)\n\t\t\tret = -ETIMEDOUT;\n\t}\n\n\tif (ret)\n\t\tdrm_dbg_kms(&i915->drm,\n\t\t\t    \"msg_id %d, ret %d, timeout(mSec): %d\\n\",\n\t\t\t    hdcp2_msg_data->msg_id, ret, timeout);\n\n\treturn ret;\n}\n\nstatic const struct hdcp2_dp_msg_data *get_hdcp2_dp_msg_data(u8 msg_id)\n{\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(hdcp2_dp_msg_data); i++)\n\t\tif (hdcp2_dp_msg_data[i].msg_id == msg_id)\n\t\t\treturn &hdcp2_dp_msg_data[i];\n\n\treturn NULL;\n}\n\nstatic\nint intel_dp_hdcp2_write_msg(struct intel_digital_port *dig_port,\n\t\t\t     void *buf, size_t size)\n{\n\tunsigned int offset;\n\tu8 *byte = buf;\n\tssize_t ret, bytes_to_write, len;\n\tconst struct hdcp2_dp_msg_data *hdcp2_msg_data;\n\n\thdcp2_msg_data = get_hdcp2_dp_msg_data(*byte);\n\tif (!hdcp2_msg_data)\n\t\treturn -EINVAL;\n\n\toffset = hdcp2_msg_data->offset;\n\n\t \n\tbytes_to_write = size - 1;\n\tbyte++;\n\n\twhile (bytes_to_write) {\n\t\tlen = bytes_to_write > DP_AUX_MAX_PAYLOAD_BYTES ?\n\t\t\t\tDP_AUX_MAX_PAYLOAD_BYTES : bytes_to_write;\n\n\t\tret = drm_dp_dpcd_write(&dig_port->dp.aux,\n\t\t\t\t\toffset, (void *)byte, len);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tbytes_to_write -= ret;\n\t\tbyte += ret;\n\t\toffset += ret;\n\t}\n\n\treturn size;\n}\n\nstatic\nssize_t get_receiver_id_list_rx_info(struct intel_digital_port *dig_port, u32 *dev_cnt, u8 *byte)\n{\n\tssize_t ret;\n\tu8 *rx_info = byte;\n\n\tret = drm_dp_dpcd_read(&dig_port->dp.aux,\n\t\t\t       DP_HDCP_2_2_REG_RXINFO_OFFSET,\n\t\t\t       (void *)rx_info, HDCP_2_2_RXINFO_LEN);\n\tif (ret != HDCP_2_2_RXINFO_LEN)\n\t\treturn ret >= 0 ? -EIO : ret;\n\n\t*dev_cnt = (HDCP_2_2_DEV_COUNT_HI(rx_info[0]) << 4 |\n\t\t   HDCP_2_2_DEV_COUNT_LO(rx_info[1]));\n\n\tif (*dev_cnt > HDCP_2_2_MAX_DEVICE_COUNT)\n\t\t*dev_cnt = HDCP_2_2_MAX_DEVICE_COUNT;\n\n\treturn ret;\n}\n\nstatic\nint intel_dp_hdcp2_read_msg(struct intel_digital_port *dig_port,\n\t\t\t    u8 msg_id, void *buf, size_t size)\n{\n\tstruct drm_i915_private *i915 = to_i915(dig_port->base.base.dev);\n\tstruct intel_dp *dp = &dig_port->dp;\n\tstruct intel_hdcp *hdcp = &dp->attached_connector->hdcp;\n\tunsigned int offset;\n\tu8 *byte = buf;\n\tssize_t ret, bytes_to_recv, len;\n\tconst struct hdcp2_dp_msg_data *hdcp2_msg_data;\n\tktime_t msg_end = ktime_set(0, 0);\n\tbool msg_expired;\n\tu32 dev_cnt;\n\n\thdcp2_msg_data = get_hdcp2_dp_msg_data(msg_id);\n\tif (!hdcp2_msg_data)\n\t\treturn -EINVAL;\n\toffset = hdcp2_msg_data->offset;\n\n\tret = intel_dp_hdcp2_wait_for_msg(dig_port, hdcp2_msg_data);\n\tif (ret < 0)\n\t\treturn ret;\n\n\thdcp->cp_irq_count_cached = atomic_read(&hdcp->cp_irq_count);\n\n\t \n\tbyte++;\n\n\tif (msg_id == HDCP_2_2_REP_SEND_RECVID_LIST) {\n\t\tret = get_receiver_id_list_rx_info(dig_port, &dev_cnt, byte);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tbyte += ret;\n\t\tsize = sizeof(struct hdcp2_rep_send_receiverid_list) -\n\t\tHDCP_2_2_RXINFO_LEN - HDCP_2_2_RECEIVER_IDS_MAX_LEN +\n\t\t(dev_cnt * HDCP_2_2_RECEIVER_ID_LEN);\n\t\toffset += HDCP_2_2_RXINFO_LEN;\n\t}\n\n\tbytes_to_recv = size - 1;\n\n\twhile (bytes_to_recv) {\n\t\tlen = bytes_to_recv > DP_AUX_MAX_PAYLOAD_BYTES ?\n\t\t      DP_AUX_MAX_PAYLOAD_BYTES : bytes_to_recv;\n\n\t\t \n\t\tif (bytes_to_recv == size - 1 && hdcp2_msg_data->msg_read_timeout > 0)\n\t\t\tmsg_end = ktime_add_ms(ktime_get_raw(),\n\t\t\t\t\t       hdcp2_msg_data->msg_read_timeout);\n\n\t\tret = drm_dp_dpcd_read(&dig_port->dp.aux, offset,\n\t\t\t\t       (void *)byte, len);\n\t\tif (ret < 0) {\n\t\t\tdrm_dbg_kms(&i915->drm, \"msg_id %d, ret %zd\\n\",\n\t\t\t\t    msg_id, ret);\n\t\t\treturn ret;\n\t\t}\n\n\t\tbytes_to_recv -= ret;\n\t\tbyte += ret;\n\t\toffset += ret;\n\t}\n\n\tif (hdcp2_msg_data->msg_read_timeout > 0) {\n\t\tmsg_expired = ktime_after(ktime_get_raw(), msg_end);\n\t\tif (msg_expired) {\n\t\t\tdrm_dbg_kms(&i915->drm, \"msg_id %d, entire msg read timeout(mSec): %d\\n\",\n\t\t\t\t    msg_id, hdcp2_msg_data->msg_read_timeout);\n\t\t\treturn -ETIMEDOUT;\n\t\t}\n\t}\n\n\tbyte = buf;\n\t*byte = msg_id;\n\n\treturn size;\n}\n\nstatic\nint intel_dp_hdcp2_config_stream_type(struct intel_digital_port *dig_port,\n\t\t\t\t      bool is_repeater, u8 content_type)\n{\n\tint ret;\n\tstruct hdcp2_dp_errata_stream_type stream_type_msg;\n\n\tif (is_repeater)\n\t\treturn 0;\n\n\t \n\tstream_type_msg.msg_id = HDCP_2_2_ERRATA_DP_STREAM_TYPE;\n\tstream_type_msg.stream_type = content_type;\n\n\tret =  intel_dp_hdcp2_write_msg(dig_port, &stream_type_msg,\n\t\t\t\t\tsizeof(stream_type_msg));\n\n\treturn ret < 0 ? ret : 0;\n\n}\n\nstatic\nint intel_dp_hdcp2_check_link(struct intel_digital_port *dig_port,\n\t\t\t      struct intel_connector *connector)\n{\n\tu8 rx_status;\n\tint ret;\n\n\tret = intel_dp_hdcp2_read_rx_status(dig_port, &rx_status);\n\tif (ret)\n\t\treturn ret;\n\n\tif (HDCP_2_2_DP_RXSTATUS_REAUTH_REQ(rx_status))\n\t\tret = HDCP_REAUTH_REQUEST;\n\telse if (HDCP_2_2_DP_RXSTATUS_LINK_FAILED(rx_status))\n\t\tret = HDCP_LINK_INTEGRITY_FAILURE;\n\telse if (HDCP_2_2_DP_RXSTATUS_READY(rx_status))\n\t\tret = HDCP_TOPOLOGY_CHANGE;\n\n\treturn ret;\n}\n\nstatic\nint intel_dp_hdcp2_capable(struct intel_digital_port *dig_port,\n\t\t\t   bool *capable)\n{\n\tu8 rx_caps[3];\n\tint ret;\n\n\t*capable = false;\n\tret = drm_dp_dpcd_read(&dig_port->dp.aux,\n\t\t\t       DP_HDCP_2_2_REG_RX_CAPS_OFFSET,\n\t\t\t       rx_caps, HDCP_2_2_RXCAPS_LEN);\n\tif (ret != HDCP_2_2_RXCAPS_LEN)\n\t\treturn ret >= 0 ? -EIO : ret;\n\n\tif (rx_caps[0] == HDCP_2_2_RX_CAPS_VERSION_VAL &&\n\t    HDCP_2_2_DP_HDCP_CAPABLE(rx_caps[2]))\n\t\t*capable = true;\n\n\treturn 0;\n}\n\nstatic const struct intel_hdcp_shim intel_dp_hdcp_shim = {\n\t.write_an_aksv = intel_dp_hdcp_write_an_aksv,\n\t.read_bksv = intel_dp_hdcp_read_bksv,\n\t.read_bstatus = intel_dp_hdcp_read_bstatus,\n\t.repeater_present = intel_dp_hdcp_repeater_present,\n\t.read_ri_prime = intel_dp_hdcp_read_ri_prime,\n\t.read_ksv_ready = intel_dp_hdcp_read_ksv_ready,\n\t.read_ksv_fifo = intel_dp_hdcp_read_ksv_fifo,\n\t.read_v_prime_part = intel_dp_hdcp_read_v_prime_part,\n\t.toggle_signalling = intel_dp_hdcp_toggle_signalling,\n\t.check_link = intel_dp_hdcp_check_link,\n\t.hdcp_capable = intel_dp_hdcp_capable,\n\t.write_2_2_msg = intel_dp_hdcp2_write_msg,\n\t.read_2_2_msg = intel_dp_hdcp2_read_msg,\n\t.config_stream_type = intel_dp_hdcp2_config_stream_type,\n\t.check_2_2_link = intel_dp_hdcp2_check_link,\n\t.hdcp_2_2_capable = intel_dp_hdcp2_capable,\n\t.protocol = HDCP_PROTOCOL_DP,\n};\n\nstatic int\nintel_dp_mst_toggle_hdcp_stream_select(struct intel_connector *connector,\n\t\t\t\t       bool enable)\n{\n\tstruct intel_digital_port *dig_port = intel_attached_dig_port(connector);\n\tstruct drm_i915_private *i915 = to_i915(connector->base.dev);\n\tstruct intel_hdcp *hdcp = &connector->hdcp;\n\tint ret;\n\n\tret = intel_ddi_toggle_hdcp_bits(&dig_port->base,\n\t\t\t\t\t hdcp->stream_transcoder, enable,\n\t\t\t\t\t TRANS_DDI_HDCP_SELECT);\n\tif (ret)\n\t\tdrm_err(&i915->drm, \"%s HDCP stream select failed (%d)\\n\",\n\t\t\tenable ? \"Enable\" : \"Disable\", ret);\n\treturn ret;\n}\n\nstatic int\nintel_dp_mst_hdcp_stream_encryption(struct intel_connector *connector,\n\t\t\t\t    bool enable)\n{\n\tstruct intel_digital_port *dig_port = intel_attached_dig_port(connector);\n\tstruct drm_i915_private *i915 = to_i915(connector->base.dev);\n\tstruct intel_hdcp *hdcp = &connector->hdcp;\n\tenum port port = dig_port->base.port;\n\tenum transcoder cpu_transcoder = hdcp->stream_transcoder;\n\tu32 stream_enc_status;\n\tint ret;\n\n\tret = intel_dp_mst_toggle_hdcp_stream_select(connector, enable);\n\tif (ret)\n\t\treturn ret;\n\n\tstream_enc_status =  transcoder_to_stream_enc_status(cpu_transcoder);\n\tif (!stream_enc_status)\n\t\treturn -EINVAL;\n\n\t \n\tif (intel_de_wait_for_register(i915,\n\t\t\t\t       HDCP_STATUS(i915, cpu_transcoder, port),\n\t\t\t\t       stream_enc_status,\n\t\t\t\t       enable ? stream_enc_status : 0,\n\t\t\t\t       HDCP_ENCRYPT_STATUS_CHANGE_TIMEOUT_MS)) {\n\t\tdrm_err(&i915->drm, \"Timed out waiting for transcoder: %s stream encryption %s\\n\",\n\t\t\ttranscoder_name(cpu_transcoder), enable ? \"enabled\" : \"disabled\");\n\t\treturn -ETIMEDOUT;\n\t}\n\n\treturn 0;\n}\n\nstatic int\nintel_dp_mst_hdcp2_stream_encryption(struct intel_connector *connector,\n\t\t\t\t     bool enable)\n{\n\tstruct intel_digital_port *dig_port = intel_attached_dig_port(connector);\n\tstruct drm_i915_private *i915 = to_i915(connector->base.dev);\n\tstruct hdcp_port_data *data = &dig_port->hdcp_port_data;\n\tstruct intel_hdcp *hdcp = &connector->hdcp;\n\tenum transcoder cpu_transcoder = hdcp->stream_transcoder;\n\tenum pipe pipe = (enum pipe)cpu_transcoder;\n\tenum port port = dig_port->base.port;\n\tint ret;\n\n\tdrm_WARN_ON(&i915->drm, enable &&\n\t\t    !!(intel_de_read(i915, HDCP2_AUTH_STREAM(i915, cpu_transcoder, port))\n\t\t    & AUTH_STREAM_TYPE) != data->streams[0].stream_type);\n\n\tret = intel_dp_mst_toggle_hdcp_stream_select(connector, enable);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tif (intel_de_wait_for_register(i915,\n\t\t\t\t       HDCP2_STREAM_STATUS(i915, cpu_transcoder, pipe),\n\t\t\t\t       STREAM_ENCRYPTION_STATUS,\n\t\t\t\t       enable ? STREAM_ENCRYPTION_STATUS : 0,\n\t\t\t\t       HDCP_ENCRYPT_STATUS_CHANGE_TIMEOUT_MS)) {\n\t\tdrm_err(&i915->drm, \"Timed out waiting for transcoder: %s stream encryption %s\\n\",\n\t\t\ttranscoder_name(cpu_transcoder), enable ? \"enabled\" : \"disabled\");\n\t\treturn -ETIMEDOUT;\n\t}\n\n\treturn 0;\n}\n\nstatic\nint intel_dp_mst_hdcp2_check_link(struct intel_digital_port *dig_port,\n\t\t\t\t  struct intel_connector *connector)\n{\n\tstruct intel_hdcp *hdcp = &connector->hdcp;\n\tint ret;\n\n\t \n\tif (hdcp->is_repeater) {\n\t\tret = intel_dp_hdcp2_check_link(dig_port, connector);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic const struct intel_hdcp_shim intel_dp_mst_hdcp_shim = {\n\t.write_an_aksv = intel_dp_hdcp_write_an_aksv,\n\t.read_bksv = intel_dp_hdcp_read_bksv,\n\t.read_bstatus = intel_dp_hdcp_read_bstatus,\n\t.repeater_present = intel_dp_hdcp_repeater_present,\n\t.read_ri_prime = intel_dp_hdcp_read_ri_prime,\n\t.read_ksv_ready = intel_dp_hdcp_read_ksv_ready,\n\t.read_ksv_fifo = intel_dp_hdcp_read_ksv_fifo,\n\t.read_v_prime_part = intel_dp_hdcp_read_v_prime_part,\n\t.toggle_signalling = intel_dp_hdcp_toggle_signalling,\n\t.stream_encryption = intel_dp_mst_hdcp_stream_encryption,\n\t.check_link = intel_dp_hdcp_check_link,\n\t.hdcp_capable = intel_dp_hdcp_capable,\n\t.write_2_2_msg = intel_dp_hdcp2_write_msg,\n\t.read_2_2_msg = intel_dp_hdcp2_read_msg,\n\t.config_stream_type = intel_dp_hdcp2_config_stream_type,\n\t.stream_2_2_encryption = intel_dp_mst_hdcp2_stream_encryption,\n\t.check_2_2_link = intel_dp_mst_hdcp2_check_link,\n\t.hdcp_2_2_capable = intel_dp_hdcp2_capable,\n\t.protocol = HDCP_PROTOCOL_DP,\n};\n\nint intel_dp_hdcp_init(struct intel_digital_port *dig_port,\n\t\t       struct intel_connector *intel_connector)\n{\n\tstruct drm_device *dev = intel_connector->base.dev;\n\tstruct drm_i915_private *dev_priv = to_i915(dev);\n\tstruct intel_encoder *intel_encoder = &dig_port->base;\n\tenum port port = intel_encoder->port;\n\tstruct intel_dp *intel_dp = &dig_port->dp;\n\n\tif (!is_hdcp_supported(dev_priv, port))\n\t\treturn 0;\n\n\tif (intel_connector->mst_port)\n\t\treturn intel_hdcp_init(intel_connector, dig_port,\n\t\t\t\t       &intel_dp_mst_hdcp_shim);\n\telse if (!intel_dp_is_edp(intel_dp))\n\t\treturn intel_hdcp_init(intel_connector, dig_port,\n\t\t\t\t       &intel_dp_hdcp_shim);\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}