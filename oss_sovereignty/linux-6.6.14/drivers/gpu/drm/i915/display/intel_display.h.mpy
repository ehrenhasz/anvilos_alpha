{
  "module_name": "intel_display.h",
  "hash_id": "06d90764c4a5ccbeaf6d1a52de33b9d61c6eb13f496c0907bd51103a93584674",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/i915/display/intel_display.h",
  "human_readable_source": " \n\n#ifndef _INTEL_DISPLAY_H_\n#define _INTEL_DISPLAY_H_\n\n#include <drm/drm_util.h>\n\n#include \"i915_reg_defs.h\"\n#include \"intel_display_limits.h\"\n\nenum drm_scaling_filter;\nstruct dpll;\nstruct drm_atomic_state;\nstruct drm_connector;\nstruct drm_device;\nstruct drm_display_mode;\nstruct drm_encoder;\nstruct drm_file;\nstruct drm_format_info;\nstruct drm_framebuffer;\nstruct drm_i915_gem_object;\nstruct drm_i915_private;\nstruct drm_mode_fb_cmd2;\nstruct drm_modeset_acquire_ctx;\nstruct drm_plane;\nstruct drm_plane_state;\nstruct i915_address_space;\nstruct i915_gtt_view;\nstruct intel_atomic_state;\nstruct intel_crtc;\nstruct intel_crtc_state;\nstruct intel_digital_port;\nstruct intel_dp;\nstruct intel_encoder;\nstruct intel_initial_plane_config;\nstruct intel_link_m_n;\nstruct intel_plane;\nstruct intel_plane_state;\nstruct intel_power_domain_mask;\nstruct intel_remapped_info;\nstruct intel_rotation_info;\nstruct pci_dev;\nstruct work_struct;\n\n\n#define pipe_name(p) ((p) + 'A')\n\nstatic inline const char *transcoder_name(enum transcoder transcoder)\n{\n\tswitch (transcoder) {\n\tcase TRANSCODER_A:\n\t\treturn \"A\";\n\tcase TRANSCODER_B:\n\t\treturn \"B\";\n\tcase TRANSCODER_C:\n\t\treturn \"C\";\n\tcase TRANSCODER_D:\n\t\treturn \"D\";\n\tcase TRANSCODER_EDP:\n\t\treturn \"EDP\";\n\tcase TRANSCODER_DSI_A:\n\t\treturn \"DSI A\";\n\tcase TRANSCODER_DSI_C:\n\t\treturn \"DSI C\";\n\tdefault:\n\t\treturn \"<invalid>\";\n\t}\n}\n\nstatic inline bool transcoder_is_dsi(enum transcoder transcoder)\n{\n\treturn transcoder == TRANSCODER_DSI_A || transcoder == TRANSCODER_DSI_C;\n}\n\n \nenum i9xx_plane_id {\n\tPLANE_A,\n\tPLANE_B,\n\tPLANE_C,\n};\n\n#define plane_name(p) ((p) + 'A')\n#define sprite_name(p, s) ((p) * DISPLAY_RUNTIME_INFO(dev_priv)->num_sprites[(p)] + (s) + 'A')\n\n#define for_each_plane_id_on_crtc(__crtc, __p) \\\n\tfor ((__p) = PLANE_PRIMARY; (__p) < I915_MAX_PLANES; (__p)++) \\\n\t\tfor_each_if((__crtc)->plane_ids_mask & BIT(__p))\n\n#define for_each_dbuf_slice(__dev_priv, __slice) \\\n\tfor ((__slice) = DBUF_S1; (__slice) < I915_MAX_DBUF_SLICES; (__slice)++) \\\n\t\tfor_each_if(DISPLAY_INFO(__dev_priv)->dbuf.slice_mask & BIT(__slice))\n\n#define for_each_dbuf_slice_in_mask(__dev_priv, __slice, __mask) \\\n\tfor_each_dbuf_slice((__dev_priv), (__slice)) \\\n\t\tfor_each_if((__mask) & BIT(__slice))\n\n#define port_name(p) ((p) + 'A')\n\n \nstatic inline const char *port_identifier(enum port port)\n{\n\tswitch (port) {\n\tcase PORT_A:\n\t\treturn \"Port A\";\n\tcase PORT_B:\n\t\treturn \"Port B\";\n\tcase PORT_C:\n\t\treturn \"Port C\";\n\tcase PORT_D:\n\t\treturn \"Port D\";\n\tcase PORT_E:\n\t\treturn \"Port E\";\n\tcase PORT_F:\n\t\treturn \"Port F\";\n\tcase PORT_G:\n\t\treturn \"Port G\";\n\tcase PORT_H:\n\t\treturn \"Port H\";\n\tcase PORT_I:\n\t\treturn \"Port I\";\n\tdefault:\n\t\treturn \"<invalid>\";\n\t}\n}\n\nenum tc_port {\n\tTC_PORT_NONE = -1,\n\n\tTC_PORT_1 = 0,\n\tTC_PORT_2,\n\tTC_PORT_3,\n\tTC_PORT_4,\n\tTC_PORT_5,\n\tTC_PORT_6,\n\n\tI915_MAX_TC_PORTS\n};\n\nenum aux_ch {\n\tAUX_CH_NONE = -1,\n\n\tAUX_CH_A,\n\tAUX_CH_B,\n\tAUX_CH_C,\n\tAUX_CH_D,\n\tAUX_CH_E,  \n\tAUX_CH_F,\n\tAUX_CH_G,\n\tAUX_CH_H,\n\tAUX_CH_I,\n\n\t \n\tAUX_CH_USBC1 = AUX_CH_D,\n\tAUX_CH_USBC2,\n\tAUX_CH_USBC3,\n\tAUX_CH_USBC4,\n\tAUX_CH_USBC5,\n\tAUX_CH_USBC6,\n\n\t \n\tAUX_CH_D_XELPD = AUX_CH_USBC5,\n\tAUX_CH_E_XELPD,\n};\n\n#define aux_ch_name(a) ((a) + 'A')\n\nenum phy {\n\tPHY_NONE = -1,\n\n\tPHY_A = 0,\n\tPHY_B,\n\tPHY_C,\n\tPHY_D,\n\tPHY_E,\n\tPHY_F,\n\tPHY_G,\n\tPHY_H,\n\tPHY_I,\n\n\tI915_MAX_PHYS\n};\n\n#define phy_name(a) ((a) + 'A')\n\nenum phy_fia {\n\tFIA1,\n\tFIA2,\n\tFIA3,\n};\n\n#define for_each_hpd_pin(__pin) \\\n\tfor ((__pin) = (HPD_NONE + 1); (__pin) < HPD_NUM_PINS; (__pin)++)\n\n#define for_each_pipe(__dev_priv, __p) \\\n\tfor ((__p) = 0; (__p) < I915_MAX_PIPES; (__p)++) \\\n\t\tfor_each_if(DISPLAY_RUNTIME_INFO(__dev_priv)->pipe_mask & BIT(__p))\n\n#define for_each_pipe_masked(__dev_priv, __p, __mask) \\\n\tfor_each_pipe(__dev_priv, __p) \\\n\t\tfor_each_if((__mask) & BIT(__p))\n\n#define for_each_cpu_transcoder(__dev_priv, __t) \\\n\tfor ((__t) = 0; (__t) < I915_MAX_TRANSCODERS; (__t)++)\t\\\n\t\tfor_each_if (DISPLAY_RUNTIME_INFO(__dev_priv)->cpu_transcoder_mask & BIT(__t))\n\n#define for_each_cpu_transcoder_masked(__dev_priv, __t, __mask) \\\n\tfor_each_cpu_transcoder(__dev_priv, __t) \\\n\t\tfor_each_if ((__mask) & BIT(__t))\n\n#define for_each_sprite(__dev_priv, __p, __s)\t\t\t\t\\\n\tfor ((__s) = 0;\t\t\t\t\t\t\t\\\n\t     (__s) < DISPLAY_RUNTIME_INFO(__dev_priv)->num_sprites[(__p)];\t\\\n\t     (__s)++)\n\n#define for_each_port(__port) \\\n\tfor ((__port) = PORT_A; (__port) < I915_MAX_PORTS; (__port)++)\n\n#define for_each_port_masked(__port, __ports_mask)\t\t\t\\\n\tfor_each_port(__port)\t\t\t\t\t\t\\\n\t\tfor_each_if((__ports_mask) & BIT(__port))\n\n#define for_each_phy_masked(__phy, __phys_mask) \\\n\tfor ((__phy) = PHY_A; (__phy) < I915_MAX_PHYS; (__phy)++)\t\\\n\t\tfor_each_if((__phys_mask) & BIT(__phy))\n\n#define for_each_crtc(dev, crtc) \\\n\tlist_for_each_entry(crtc, &(dev)->mode_config.crtc_list, head)\n\n#define for_each_intel_plane(dev, intel_plane) \\\n\tlist_for_each_entry(intel_plane,\t\t\t\\\n\t\t\t    &(dev)->mode_config.plane_list,\t\\\n\t\t\t    base.head)\n\n#define for_each_intel_plane_mask(dev, intel_plane, plane_mask)\t\t\\\n\tlist_for_each_entry(intel_plane,\t\t\t\t\\\n\t\t\t    &(dev)->mode_config.plane_list,\t\t\\\n\t\t\t    base.head)\t\t\t\t\t\\\n\t\tfor_each_if((plane_mask) &\t\t\t\t\\\n\t\t\t    drm_plane_mask(&intel_plane->base))\n\n#define for_each_intel_plane_on_crtc(dev, intel_crtc, intel_plane)\t\\\n\tlist_for_each_entry(intel_plane,\t\t\t\t\\\n\t\t\t    &(dev)->mode_config.plane_list,\t\t\\\n\t\t\t    base.head)\t\t\t\t\t\\\n\t\tfor_each_if((intel_plane)->pipe == (intel_crtc)->pipe)\n\n#define for_each_intel_crtc(dev, intel_crtc)\t\t\t\t\\\n\tlist_for_each_entry(intel_crtc,\t\t\t\t\t\\\n\t\t\t    &(dev)->mode_config.crtc_list,\t\t\\\n\t\t\t    base.head)\n\n#define for_each_intel_crtc_in_pipe_mask(dev, intel_crtc, pipe_mask)\t\\\n\tlist_for_each_entry(intel_crtc,\t\t\t\t\t\\\n\t\t\t    &(dev)->mode_config.crtc_list,\t\t\\\n\t\t\t    base.head)\t\t\t\t\t\\\n\t\tfor_each_if((pipe_mask) & BIT(intel_crtc->pipe))\n\n#define for_each_intel_encoder(dev, intel_encoder)\t\t\\\n\tlist_for_each_entry(intel_encoder,\t\t\t\\\n\t\t\t    &(dev)->mode_config.encoder_list,\t\\\n\t\t\t    base.head)\n\n#define for_each_intel_encoder_mask(dev, intel_encoder, encoder_mask)\t\\\n\tlist_for_each_entry(intel_encoder,\t\t\t\t\\\n\t\t\t    &(dev)->mode_config.encoder_list,\t\t\\\n\t\t\t    base.head)\t\t\t\t\t\\\n\t\tfor_each_if((encoder_mask) &\t\t\t\t\\\n\t\t\t    drm_encoder_mask(&intel_encoder->base))\n\n#define for_each_intel_encoder_mask_with_psr(dev, intel_encoder, encoder_mask) \\\n\tlist_for_each_entry((intel_encoder), &(dev)->mode_config.encoder_list, base.head) \\\n\t\tfor_each_if(((encoder_mask) & drm_encoder_mask(&(intel_encoder)->base)) && \\\n\t\t\t    intel_encoder_can_psr(intel_encoder))\n\n#define for_each_intel_dp(dev, intel_encoder)\t\t\t\\\n\tfor_each_intel_encoder(dev, intel_encoder)\t\t\\\n\t\tfor_each_if(intel_encoder_is_dp(intel_encoder))\n\n#define for_each_intel_encoder_with_psr(dev, intel_encoder) \\\n\tfor_each_intel_encoder((dev), (intel_encoder)) \\\n\t\tfor_each_if(intel_encoder_can_psr(intel_encoder))\n\n#define for_each_intel_connector_iter(intel_connector, iter) \\\n\twhile ((intel_connector = to_intel_connector(drm_connector_list_iter_next(iter))))\n\n#define for_each_encoder_on_crtc(dev, __crtc, intel_encoder) \\\n\tlist_for_each_entry((intel_encoder), &(dev)->mode_config.encoder_list, base.head) \\\n\t\tfor_each_if((intel_encoder)->base.crtc == (__crtc))\n\n#define for_each_old_intel_plane_in_state(__state, plane, old_plane_state, __i) \\\n\tfor ((__i) = 0; \\\n\t     (__i) < (__state)->base.dev->mode_config.num_total_plane && \\\n\t\t     ((plane) = to_intel_plane((__state)->base.planes[__i].ptr), \\\n\t\t      (old_plane_state) = to_intel_plane_state((__state)->base.planes[__i].old_state), 1); \\\n\t     (__i)++) \\\n\t\tfor_each_if(plane)\n\n#define for_each_old_intel_crtc_in_state(__state, crtc, old_crtc_state, __i) \\\n\tfor ((__i) = 0; \\\n\t     (__i) < (__state)->base.dev->mode_config.num_crtc && \\\n\t\t     ((crtc) = to_intel_crtc((__state)->base.crtcs[__i].ptr), \\\n\t\t      (old_crtc_state) = to_intel_crtc_state((__state)->base.crtcs[__i].old_state), 1); \\\n\t     (__i)++) \\\n\t\tfor_each_if(crtc)\n\n#define for_each_new_intel_plane_in_state(__state, plane, new_plane_state, __i) \\\n\tfor ((__i) = 0; \\\n\t     (__i) < (__state)->base.dev->mode_config.num_total_plane && \\\n\t\t     ((plane) = to_intel_plane((__state)->base.planes[__i].ptr), \\\n\t\t      (new_plane_state) = to_intel_plane_state((__state)->base.planes[__i].new_state), 1); \\\n\t     (__i)++) \\\n\t\tfor_each_if(plane)\n\n#define for_each_new_intel_crtc_in_state(__state, crtc, new_crtc_state, __i) \\\n\tfor ((__i) = 0; \\\n\t     (__i) < (__state)->base.dev->mode_config.num_crtc && \\\n\t\t     ((crtc) = to_intel_crtc((__state)->base.crtcs[__i].ptr), \\\n\t\t      (new_crtc_state) = to_intel_crtc_state((__state)->base.crtcs[__i].new_state), 1); \\\n\t     (__i)++) \\\n\t\tfor_each_if(crtc)\n\n#define for_each_oldnew_intel_plane_in_state(__state, plane, old_plane_state, new_plane_state, __i) \\\n\tfor ((__i) = 0; \\\n\t     (__i) < (__state)->base.dev->mode_config.num_total_plane && \\\n\t\t     ((plane) = to_intel_plane((__state)->base.planes[__i].ptr), \\\n\t\t      (old_plane_state) = to_intel_plane_state((__state)->base.planes[__i].old_state), \\\n\t\t      (new_plane_state) = to_intel_plane_state((__state)->base.planes[__i].new_state), 1); \\\n\t     (__i)++) \\\n\t\tfor_each_if(plane)\n\n#define for_each_oldnew_intel_crtc_in_state(__state, crtc, old_crtc_state, new_crtc_state, __i) \\\n\tfor ((__i) = 0; \\\n\t     (__i) < (__state)->base.dev->mode_config.num_crtc && \\\n\t\t     ((crtc) = to_intel_crtc((__state)->base.crtcs[__i].ptr), \\\n\t\t      (old_crtc_state) = to_intel_crtc_state((__state)->base.crtcs[__i].old_state), \\\n\t\t      (new_crtc_state) = to_intel_crtc_state((__state)->base.crtcs[__i].new_state), 1); \\\n\t     (__i)++) \\\n\t\tfor_each_if(crtc)\n\n#define for_each_oldnew_intel_crtc_in_state_reverse(__state, crtc, old_crtc_state, new_crtc_state, __i) \\\n\tfor ((__i) = (__state)->base.dev->mode_config.num_crtc - 1; \\\n\t     (__i) >= 0  && \\\n\t     ((crtc) = to_intel_crtc((__state)->base.crtcs[__i].ptr), \\\n\t      (old_crtc_state) = to_intel_crtc_state((__state)->base.crtcs[__i].old_state), \\\n\t      (new_crtc_state) = to_intel_crtc_state((__state)->base.crtcs[__i].new_state), 1); \\\n\t     (__i)--) \\\n\t\tfor_each_if(crtc)\n\n#define intel_atomic_crtc_state_for_each_plane_state( \\\n\t\t  plane, plane_state, \\\n\t\t  crtc_state) \\\n\tfor_each_intel_plane_mask(((crtc_state)->uapi.state->dev), (plane), \\\n\t\t\t\t((crtc_state)->uapi.plane_mask)) \\\n\t\tfor_each_if ((plane_state = \\\n\t\t\t      to_intel_plane_state(__drm_atomic_get_current_plane_state((crtc_state)->uapi.state, &plane->base))))\n\n#define for_each_new_intel_connector_in_state(__state, connector, new_connector_state, __i) \\\n\tfor ((__i) = 0; \\\n\t     (__i) < (__state)->base.num_connector; \\\n\t     (__i)++) \\\n\t\tfor_each_if ((__state)->base.connectors[__i].ptr && \\\n\t\t\t     ((connector) = to_intel_connector((__state)->base.connectors[__i].ptr), \\\n\t\t\t     (new_connector_state) = to_intel_digital_connector_state((__state)->base.connectors[__i].new_state), 1))\n\nint intel_atomic_check(struct drm_device *dev, struct drm_atomic_state *state);\nint intel_atomic_add_affected_planes(struct intel_atomic_state *state,\n\t\t\t\t     struct intel_crtc *crtc);\nu8 intel_calc_active_pipes(struct intel_atomic_state *state,\n\t\t\t   u8 active_pipes);\nvoid intel_link_compute_m_n(u16 bpp, int nlanes,\n\t\t\t    int pixel_clock, int link_clock,\n\t\t\t    struct intel_link_m_n *m_n,\n\t\t\t    bool fec_enable);\nu32 intel_plane_fb_max_stride(struct drm_i915_private *dev_priv,\n\t\t\t      u32 pixel_format, u64 modifier);\nenum drm_mode_status\nintel_mode_valid_max_plane_size(struct drm_i915_private *dev_priv,\n\t\t\t\tconst struct drm_display_mode *mode,\n\t\t\t\tbool bigjoiner);\nenum drm_mode_status\nintel_cpu_transcoder_mode_valid(struct drm_i915_private *i915,\n\t\t\t\tconst struct drm_display_mode *mode);\nenum phy intel_port_to_phy(struct drm_i915_private *i915, enum port port);\nbool is_trans_port_sync_mode(const struct intel_crtc_state *state);\nbool is_trans_port_sync_master(const struct intel_crtc_state *state);\nbool intel_crtc_is_bigjoiner_slave(const struct intel_crtc_state *crtc_state);\nbool intel_crtc_is_bigjoiner_master(const struct intel_crtc_state *crtc_state);\nu8 intel_crtc_bigjoiner_slave_pipes(const struct intel_crtc_state *crtc_state);\nstruct intel_crtc *intel_master_crtc(const struct intel_crtc_state *crtc_state);\nbool intel_crtc_get_pipe_config(struct intel_crtc_state *crtc_state);\nbool intel_pipe_config_compare(const struct intel_crtc_state *current_config,\n\t\t\t       const struct intel_crtc_state *pipe_config,\n\t\t\t       bool fastset);\n\nvoid intel_plane_destroy(struct drm_plane *plane);\nvoid i9xx_set_pipeconf(const struct intel_crtc_state *crtc_state);\nvoid ilk_set_pipeconf(const struct intel_crtc_state *crtc_state);\nvoid intel_enable_transcoder(const struct intel_crtc_state *new_crtc_state);\nvoid intel_disable_transcoder(const struct intel_crtc_state *old_crtc_state);\nvoid i830_enable_pipe(struct drm_i915_private *dev_priv, enum pipe pipe);\nvoid i830_disable_pipe(struct drm_i915_private *dev_priv, enum pipe pipe);\nint vlv_get_hpll_vco(struct drm_i915_private *dev_priv);\nint vlv_get_cck_clock(struct drm_i915_private *dev_priv,\n\t\t      const char *name, u32 reg, int ref_freq);\nint vlv_get_cck_clock_hpll(struct drm_i915_private *dev_priv,\n\t\t\t   const char *name, u32 reg);\nvoid intel_init_display_hooks(struct drm_i915_private *dev_priv);\nunsigned int intel_fb_xy_to_linear(int x, int y,\n\t\t\t\t   const struct intel_plane_state *state,\n\t\t\t\t   int plane);\nvoid intel_add_fb_offsets(int *x, int *y,\n\t\t\t  const struct intel_plane_state *state, int plane);\nunsigned int intel_rotation_info_size(const struct intel_rotation_info *rot_info);\nunsigned int intel_remapped_info_size(const struct intel_remapped_info *rem_info);\nbool intel_has_pending_fb_unpin(struct drm_i915_private *dev_priv);\nvoid intel_encoder_destroy(struct drm_encoder *encoder);\nstruct drm_display_mode *\nintel_encoder_current_mode(struct intel_encoder *encoder);\nvoid intel_encoder_get_config(struct intel_encoder *encoder,\n\t\t\t      struct intel_crtc_state *crtc_state);\nbool intel_phy_is_combo(struct drm_i915_private *dev_priv, enum phy phy);\nbool intel_phy_is_tc(struct drm_i915_private *dev_priv, enum phy phy);\nbool intel_phy_is_snps(struct drm_i915_private *dev_priv, enum phy phy);\nenum tc_port intel_port_to_tc(struct drm_i915_private *dev_priv,\n\t\t\t      enum port port);\nint intel_get_pipe_from_crtc_id_ioctl(struct drm_device *dev, void *data,\n\t\t\t\t      struct drm_file *file_priv);\n\nint ilk_get_lanes_required(int target_clock, int link_bw, int bpp);\nvoid vlv_wait_port_ready(struct drm_i915_private *dev_priv,\n\t\t\t struct intel_digital_port *dig_port,\n\t\t\t unsigned int expected_mask);\nstruct drm_framebuffer *\nintel_framebuffer_create(struct drm_i915_gem_object *obj,\n\t\t\t struct drm_mode_fb_cmd2 *mode_cmd);\n\nbool intel_fuzzy_clock_check(int clock1, int clock2);\n\nvoid intel_zero_m_n(struct intel_link_m_n *m_n);\nvoid intel_set_m_n(struct drm_i915_private *i915,\n\t\t   const struct intel_link_m_n *m_n,\n\t\t   i915_reg_t data_m_reg, i915_reg_t data_n_reg,\n\t\t   i915_reg_t link_m_reg, i915_reg_t link_n_reg);\nvoid intel_get_m_n(struct drm_i915_private *i915,\n\t\t   struct intel_link_m_n *m_n,\n\t\t   i915_reg_t data_m_reg, i915_reg_t data_n_reg,\n\t\t   i915_reg_t link_m_reg, i915_reg_t link_n_reg);\nbool intel_cpu_transcoder_has_m2_n2(struct drm_i915_private *dev_priv,\n\t\t\t\t    enum transcoder transcoder);\nvoid intel_cpu_transcoder_set_m1_n1(struct intel_crtc *crtc,\n\t\t\t\t    enum transcoder cpu_transcoder,\n\t\t\t\t    const struct intel_link_m_n *m_n);\nvoid intel_cpu_transcoder_set_m2_n2(struct intel_crtc *crtc,\n\t\t\t\t    enum transcoder cpu_transcoder,\n\t\t\t\t    const struct intel_link_m_n *m_n);\nvoid intel_cpu_transcoder_get_m1_n1(struct intel_crtc *crtc,\n\t\t\t\t    enum transcoder cpu_transcoder,\n\t\t\t\t    struct intel_link_m_n *m_n);\nvoid intel_cpu_transcoder_get_m2_n2(struct intel_crtc *crtc,\n\t\t\t\t    enum transcoder cpu_transcoder,\n\t\t\t\t    struct intel_link_m_n *m_n);\nvoid i9xx_crtc_clock_get(struct intel_crtc *crtc,\n\t\t\t struct intel_crtc_state *pipe_config);\nint intel_dotclock_calculate(int link_freq, const struct intel_link_m_n *m_n);\nint intel_crtc_dotclock(const struct intel_crtc_state *pipe_config);\nenum intel_display_power_domain intel_port_to_power_domain(struct intel_digital_port *dig_port);\nenum intel_display_power_domain\nintel_aux_power_domain(struct intel_digital_port *dig_port);\nvoid intel_crtc_arm_fifo_underrun(struct intel_crtc *crtc,\n\t\t\t\t  struct intel_crtc_state *crtc_state);\nvoid ilk_pfit_disable(const struct intel_crtc_state *old_crtc_state);\n\nint bdw_get_pipe_misc_bpp(struct intel_crtc *crtc);\nunsigned int intel_plane_fence_y_offset(const struct intel_plane_state *plane_state);\n\nbool intel_plane_uses_fence(const struct intel_plane_state *plane_state);\n\nstruct intel_encoder *\nintel_get_crtc_new_encoder(const struct intel_atomic_state *state,\n\t\t\t   const struct intel_crtc_state *crtc_state);\nvoid intel_plane_disable_noatomic(struct intel_crtc *crtc,\n\t\t\t\t  struct intel_plane *plane);\nvoid intel_set_plane_visible(struct intel_crtc_state *crtc_state,\n\t\t\t     struct intel_plane_state *plane_state,\n\t\t\t     bool visible);\nvoid intel_plane_fixup_bitmasks(struct intel_crtc_state *crtc_state);\n\nvoid intel_update_watermarks(struct drm_i915_private *i915);\n\n \nint intel_modeset_all_pipes(struct intel_atomic_state *state,\n\t\t\t    const char *reason);\nvoid intel_modeset_get_crtc_power_domains(struct intel_crtc_state *crtc_state,\n\t\t\t\t\t  struct intel_power_domain_mask *old_domains);\nvoid intel_modeset_put_crtc_power_domains(struct intel_crtc *crtc,\n\t\t\t\t\t  struct intel_power_domain_mask *domains);\n\n \nvoid intel_setup_outputs(struct drm_i915_private *i915);\nint intel_initial_commit(struct drm_device *dev);\nvoid intel_panel_sanitize_ssc(struct drm_i915_private *i915);\nvoid intel_update_czclk(struct drm_i915_private *i915);\nvoid intel_atomic_helper_free_state_worker(struct work_struct *work);\nenum drm_mode_status intel_mode_valid(struct drm_device *dev,\n\t\t\t\t      const struct drm_display_mode *mode);\nint intel_atomic_commit(struct drm_device *dev, struct drm_atomic_state *_state,\n\t\t\tbool nonblock);\n\nvoid intel_hpd_poll_fini(struct drm_i915_private *i915);\n\n \nvoid assert_transcoder(struct drm_i915_private *dev_priv,\n\t\t       enum transcoder cpu_transcoder, bool state);\n#define assert_transcoder_enabled(d, t) assert_transcoder(d, t, true)\n#define assert_transcoder_disabled(d, t) assert_transcoder(d, t, false)\n\nbool assert_port_valid(struct drm_i915_private *i915, enum port port);\n\n \n#define I915_STATE_WARN(__i915, condition, format...) ({\t\t\\\n\tstruct drm_device *drm = &(__i915)->drm;\t\t\t\\\n\tint __ret_warn_on = !!(condition);\t\t\t\t\\\n\tif (unlikely(__ret_warn_on))\t\t\t\t\t\\\n\t\tif (!drm_WARN(drm, i915_modparams.verbose_state_checks, format)) \\\n\t\t\tdrm_err(drm, format);\t\t\t\t\\\n\tunlikely(__ret_warn_on);\t\t\t\t\t\\\n})\n\nbool intel_scanout_needs_vtd_wa(struct drm_i915_private *i915);\n\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}