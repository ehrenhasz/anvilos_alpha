{
  "module_name": "intel_fbdev.c",
  "hash_id": "f539eafad9147753b824b4cd9de3f8cde81da1da9c0cf4b0b6ef8528ee228732",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/i915/display/intel_fbdev.c",
  "human_readable_source": " \n\n#include <linux/async.h>\n#include <linux/console.h>\n#include <linux/delay.h>\n#include <linux/errno.h>\n#include <linux/fb.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n#include <linux/string.h>\n#include <linux/sysrq.h>\n#include <linux/tty.h>\n#include <linux/vga_switcheroo.h>\n\n#include <drm/drm_crtc.h>\n#include <drm/drm_fb_helper.h>\n#include <drm/drm_fourcc.h>\n#include <drm/drm_gem_framebuffer_helper.h>\n\n#include \"gem/i915_gem_lmem.h\"\n#include \"gem/i915_gem_mman.h\"\n\n#include \"i915_drv.h\"\n#include \"intel_display_types.h\"\n#include \"intel_fb.h\"\n#include \"intel_fb_pin.h\"\n#include \"intel_fbdev.h\"\n#include \"intel_frontbuffer.h\"\n\nstruct intel_fbdev {\n\tstruct drm_fb_helper helper;\n\tstruct intel_framebuffer *fb;\n\tstruct i915_vma *vma;\n\tunsigned long vma_flags;\n\tasync_cookie_t cookie;\n\tint preferred_bpp;\n\n\t \n\tbool hpd_suspended: 1;\n\t \n\tbool hpd_waiting: 1;\n\n\t \n\tstruct mutex hpd_lock;\n};\n\nstatic struct intel_fbdev *to_intel_fbdev(struct drm_fb_helper *fb_helper)\n{\n\treturn container_of(fb_helper, struct intel_fbdev, helper);\n}\n\nstatic struct intel_frontbuffer *to_frontbuffer(struct intel_fbdev *ifbdev)\n{\n\treturn ifbdev->fb->frontbuffer;\n}\n\nstatic void intel_fbdev_invalidate(struct intel_fbdev *ifbdev)\n{\n\tintel_frontbuffer_invalidate(to_frontbuffer(ifbdev), ORIGIN_CPU);\n}\n\nFB_GEN_DEFAULT_DEFERRED_IOMEM_OPS(intel_fbdev,\n\t\t\t\t  drm_fb_helper_damage_range,\n\t\t\t\t  drm_fb_helper_damage_area)\n\nstatic int intel_fbdev_set_par(struct fb_info *info)\n{\n\tstruct intel_fbdev *ifbdev = to_intel_fbdev(info->par);\n\tint ret;\n\n\tret = drm_fb_helper_set_par(info);\n\tif (ret == 0)\n\t\tintel_fbdev_invalidate(ifbdev);\n\n\treturn ret;\n}\n\nstatic int intel_fbdev_blank(int blank, struct fb_info *info)\n{\n\tstruct intel_fbdev *ifbdev = to_intel_fbdev(info->par);\n\tint ret;\n\n\tret = drm_fb_helper_blank(blank, info);\n\tif (ret == 0)\n\t\tintel_fbdev_invalidate(ifbdev);\n\n\treturn ret;\n}\n\nstatic int intel_fbdev_pan_display(struct fb_var_screeninfo *var,\n\t\t\t\t   struct fb_info *info)\n{\n\tstruct intel_fbdev *ifbdev = to_intel_fbdev(info->par);\n\tint ret;\n\n\tret = drm_fb_helper_pan_display(var, info);\n\tif (ret == 0)\n\t\tintel_fbdev_invalidate(ifbdev);\n\n\treturn ret;\n}\n\nstatic int intel_fbdev_mmap(struct fb_info *info, struct vm_area_struct *vma)\n{\n\tstruct intel_fbdev *fbdev = to_intel_fbdev(info->par);\n\tstruct drm_gem_object *bo = drm_gem_fb_get_obj(&fbdev->fb->base, 0);\n\tstruct drm_i915_gem_object *obj = to_intel_bo(bo);\n\n\treturn i915_gem_fb_mmap(obj, vma);\n}\n\nstatic const struct fb_ops intelfb_ops = {\n\t.owner = THIS_MODULE,\n\t__FB_DEFAULT_DEFERRED_OPS_RDWR(intel_fbdev),\n\tDRM_FB_HELPER_DEFAULT_OPS,\n\t.fb_set_par = intel_fbdev_set_par,\n\t.fb_blank = intel_fbdev_blank,\n\t.fb_pan_display = intel_fbdev_pan_display,\n\t__FB_DEFAULT_DEFERRED_OPS_DRAW(intel_fbdev),\n\t.fb_mmap = intel_fbdev_mmap,\n};\n\nstatic int intelfb_alloc(struct drm_fb_helper *helper,\n\t\t\t struct drm_fb_helper_surface_size *sizes)\n{\n\tstruct intel_fbdev *ifbdev = to_intel_fbdev(helper);\n\tstruct drm_framebuffer *fb;\n\tstruct drm_device *dev = helper->dev;\n\tstruct drm_i915_private *dev_priv = to_i915(dev);\n\tstruct drm_mode_fb_cmd2 mode_cmd = {};\n\tstruct drm_i915_gem_object *obj;\n\tint size;\n\n\t \n\tif (sizes->surface_bpp == 24)\n\t\tsizes->surface_bpp = 32;\n\n\tmode_cmd.width = sizes->surface_width;\n\tmode_cmd.height = sizes->surface_height;\n\n\tmode_cmd.pitches[0] = ALIGN(mode_cmd.width *\n\t\t\t\t    DIV_ROUND_UP(sizes->surface_bpp, 8), 64);\n\tmode_cmd.pixel_format = drm_mode_legacy_fb_format(sizes->surface_bpp,\n\t\t\t\t\t\t\t  sizes->surface_depth);\n\n\tsize = mode_cmd.pitches[0] * mode_cmd.height;\n\tsize = PAGE_ALIGN(size);\n\n\tobj = ERR_PTR(-ENODEV);\n\tif (HAS_LMEM(dev_priv)) {\n\t\tobj = i915_gem_object_create_lmem(dev_priv, size,\n\t\t\t\t\t\t  I915_BO_ALLOC_CONTIGUOUS |\n\t\t\t\t\t\t  I915_BO_ALLOC_USER);\n\t} else {\n\t\t \n\t\tif (!(IS_METEORLAKE(dev_priv)) && size * 2 < dev_priv->dsm.usable_size)\n\t\t\tobj = i915_gem_object_create_stolen(dev_priv, size);\n\t\tif (IS_ERR(obj))\n\t\t\tobj = i915_gem_object_create_shmem(dev_priv, size);\n\t}\n\n\tif (IS_ERR(obj)) {\n\t\tdrm_err(&dev_priv->drm, \"failed to allocate framebuffer (%pe)\\n\", obj);\n\t\treturn PTR_ERR(obj);\n\t}\n\n\tfb = intel_framebuffer_create(obj, &mode_cmd);\n\ti915_gem_object_put(obj);\n\tif (IS_ERR(fb))\n\t\treturn PTR_ERR(fb);\n\n\tifbdev->fb = to_intel_framebuffer(fb);\n\treturn 0;\n}\n\nstatic int intelfb_create(struct drm_fb_helper *helper,\n\t\t\t  struct drm_fb_helper_surface_size *sizes)\n{\n\tstruct intel_fbdev *ifbdev = to_intel_fbdev(helper);\n\tstruct intel_framebuffer *intel_fb = ifbdev->fb;\n\tstruct drm_device *dev = helper->dev;\n\tstruct drm_i915_private *dev_priv = to_i915(dev);\n\tstruct pci_dev *pdev = to_pci_dev(dev_priv->drm.dev);\n\tstruct i915_ggtt *ggtt = to_gt(dev_priv)->ggtt;\n\tconst struct i915_gtt_view view = {\n\t\t.type = I915_GTT_VIEW_NORMAL,\n\t};\n\tintel_wakeref_t wakeref;\n\tstruct fb_info *info;\n\tstruct i915_vma *vma;\n\tunsigned long flags = 0;\n\tbool prealloc = false;\n\tvoid __iomem *vaddr;\n\tstruct drm_i915_gem_object *obj;\n\tstruct i915_gem_ww_ctx ww;\n\tint ret;\n\n\tmutex_lock(&ifbdev->hpd_lock);\n\tret = ifbdev->hpd_suspended ? -EAGAIN : 0;\n\tmutex_unlock(&ifbdev->hpd_lock);\n\tif (ret)\n\t\treturn ret;\n\n\tif (intel_fb &&\n\t    (sizes->fb_width > intel_fb->base.width ||\n\t     sizes->fb_height > intel_fb->base.height)) {\n\t\tdrm_dbg_kms(&dev_priv->drm,\n\t\t\t    \"BIOS fb too small (%dx%d), we require (%dx%d),\"\n\t\t\t    \" releasing it\\n\",\n\t\t\t    intel_fb->base.width, intel_fb->base.height,\n\t\t\t    sizes->fb_width, sizes->fb_height);\n\t\tdrm_framebuffer_put(&intel_fb->base);\n\t\tintel_fb = ifbdev->fb = NULL;\n\t}\n\tif (!intel_fb || drm_WARN_ON(dev, !intel_fb_obj(&intel_fb->base))) {\n\t\tdrm_dbg_kms(&dev_priv->drm,\n\t\t\t    \"no BIOS fb, allocating a new one\\n\");\n\t\tret = intelfb_alloc(helper, sizes);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tintel_fb = ifbdev->fb;\n\t} else {\n\t\tdrm_dbg_kms(&dev_priv->drm, \"re-using BIOS fb\\n\");\n\t\tprealloc = true;\n\t\tsizes->fb_width = intel_fb->base.width;\n\t\tsizes->fb_height = intel_fb->base.height;\n\t}\n\n\twakeref = intel_runtime_pm_get(&dev_priv->runtime_pm);\n\n\t \n\tvma = intel_pin_and_fence_fb_obj(&ifbdev->fb->base, false,\n\t\t\t\t\t &view, false, &flags);\n\tif (IS_ERR(vma)) {\n\t\tret = PTR_ERR(vma);\n\t\tgoto out_unlock;\n\t}\n\n\tinfo = drm_fb_helper_alloc_info(helper);\n\tif (IS_ERR(info)) {\n\t\tdrm_err(&dev_priv->drm, \"Failed to allocate fb_info (%pe)\\n\", info);\n\t\tret = PTR_ERR(info);\n\t\tgoto out_unpin;\n\t}\n\n\tifbdev->helper.fb = &ifbdev->fb->base;\n\n\tinfo->fbops = &intelfb_ops;\n\n\tobj = intel_fb_obj(&intel_fb->base);\n\tif (i915_gem_object_is_lmem(obj)) {\n\t\tstruct intel_memory_region *mem = obj->mm.region;\n\n\t\t \n\t\tinfo->fix.smem_start =\n\t\t\t(unsigned long)(mem->io_start +\n\t\t\t\t\ti915_gem_object_get_dma_address(obj, 0));\n\t\tinfo->fix.smem_len = obj->base.size;\n\t} else {\n\t\t \n\t\tinfo->fix.smem_start =\n\t\t\t(unsigned long)(ggtt->gmadr.start + i915_ggtt_offset(vma));\n\t\tinfo->fix.smem_len = vma->size;\n\t}\n\n\tfor_i915_gem_ww(&ww, ret, false) {\n\t\tret = i915_gem_object_lock(vma->obj, &ww);\n\n\t\tif (ret)\n\t\t\tcontinue;\n\n\t\tvaddr = i915_vma_pin_iomap(vma);\n\t\tif (IS_ERR(vaddr)) {\n\t\t\tdrm_err(&dev_priv->drm,\n\t\t\t\t\"Failed to remap framebuffer into virtual memory (%pe)\\n\", vaddr);\n\t\t\tret = PTR_ERR(vaddr);\n\t\t\tcontinue;\n\t\t}\n\t}\n\n\tif (ret)\n\t\tgoto out_unpin;\n\n\tinfo->screen_base = vaddr;\n\tinfo->screen_size = vma->size;\n\n\tdrm_fb_helper_fill_info(info, &ifbdev->helper, sizes);\n\n\t \n\tif (!i915_gem_object_is_shmem(vma->obj) && !prealloc)\n\t\tmemset_io(info->screen_base, 0, info->screen_size);\n\n\t \n\n\tdrm_dbg_kms(&dev_priv->drm, \"allocated %dx%d fb: 0x%08x\\n\",\n\t\t    ifbdev->fb->base.width, ifbdev->fb->base.height,\n\t\t    i915_ggtt_offset(vma));\n\tifbdev->vma = vma;\n\tifbdev->vma_flags = flags;\n\n\tintel_runtime_pm_put(&dev_priv->runtime_pm, wakeref);\n\tvga_switcheroo_client_fb_set(pdev, info);\n\treturn 0;\n\nout_unpin:\n\tintel_unpin_fb_vma(vma, flags);\nout_unlock:\n\tintel_runtime_pm_put(&dev_priv->runtime_pm, wakeref);\n\treturn ret;\n}\n\nstatic int intelfb_dirty(struct drm_fb_helper *helper, struct drm_clip_rect *clip)\n{\n\tif (!(clip->x1 < clip->x2 && clip->y1 < clip->y2))\n\t\treturn 0;\n\n\tif (helper->fb->funcs->dirty)\n\t\treturn helper->fb->funcs->dirty(helper->fb, NULL, 0, 0, clip, 1);\n\n\treturn 0;\n}\n\nstatic const struct drm_fb_helper_funcs intel_fb_helper_funcs = {\n\t.fb_probe = intelfb_create,\n\t.fb_dirty = intelfb_dirty,\n};\n\nstatic void intel_fbdev_destroy(struct intel_fbdev *ifbdev)\n{\n\t \n\n\tdrm_fb_helper_fini(&ifbdev->helper);\n\n\tif (ifbdev->vma)\n\t\tintel_unpin_fb_vma(ifbdev->vma, ifbdev->vma_flags);\n\n\tif (ifbdev->fb)\n\t\tdrm_framebuffer_remove(&ifbdev->fb->base);\n\n\tdrm_fb_helper_unprepare(&ifbdev->helper);\n\tkfree(ifbdev);\n}\n\n \nstatic bool intel_fbdev_init_bios(struct drm_device *dev,\n\t\t\t\t  struct intel_fbdev *ifbdev)\n{\n\tstruct drm_i915_private *i915 = to_i915(dev);\n\tstruct intel_framebuffer *fb = NULL;\n\tstruct intel_crtc *crtc;\n\tunsigned int max_size = 0;\n\n\t \n\tfor_each_intel_crtc(dev, crtc) {\n\t\tstruct intel_crtc_state *crtc_state =\n\t\t\tto_intel_crtc_state(crtc->base.state);\n\t\tstruct intel_plane *plane =\n\t\t\tto_intel_plane(crtc->base.primary);\n\t\tstruct intel_plane_state *plane_state =\n\t\t\tto_intel_plane_state(plane->base.state);\n\t\tstruct drm_i915_gem_object *obj =\n\t\t\tintel_fb_obj(plane_state->uapi.fb);\n\n\t\tif (!crtc_state->uapi.active) {\n\t\t\tdrm_dbg_kms(&i915->drm,\n\t\t\t\t    \"[CRTC:%d:%s] not active, skipping\\n\",\n\t\t\t\t    crtc->base.base.id, crtc->base.name);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!obj) {\n\t\t\tdrm_dbg_kms(&i915->drm,\n\t\t\t\t    \"[PLANE:%d:%s] no fb, skipping\\n\",\n\t\t\t\t    plane->base.base.id, plane->base.name);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (obj->base.size > max_size) {\n\t\t\tdrm_dbg_kms(&i915->drm,\n\t\t\t\t    \"found possible fb from [PLANE:%d:%s]\\n\",\n\t\t\t\t    plane->base.base.id, plane->base.name);\n\t\t\tfb = to_intel_framebuffer(plane_state->uapi.fb);\n\t\t\tmax_size = obj->base.size;\n\t\t}\n\t}\n\n\tif (!fb) {\n\t\tdrm_dbg_kms(&i915->drm,\n\t\t\t    \"no active fbs found, not using BIOS config\\n\");\n\t\tgoto out;\n\t}\n\n\t \n\tfor_each_intel_crtc(dev, crtc) {\n\t\tstruct intel_crtc_state *crtc_state =\n\t\t\tto_intel_crtc_state(crtc->base.state);\n\t\tstruct intel_plane *plane =\n\t\t\tto_intel_plane(crtc->base.primary);\n\t\tunsigned int cur_size;\n\n\t\tif (!crtc_state->uapi.active) {\n\t\t\tdrm_dbg_kms(&i915->drm,\n\t\t\t\t    \"[CRTC:%d:%s] not active, skipping\\n\",\n\t\t\t\t    crtc->base.base.id, crtc->base.name);\n\t\t\tcontinue;\n\t\t}\n\n\t\tdrm_dbg_kms(&i915->drm, \"checking [PLANE:%d:%s] for BIOS fb\\n\",\n\t\t\t    plane->base.base.id, plane->base.name);\n\n\t\t \n\t\tcur_size = crtc_state->uapi.adjusted_mode.crtc_hdisplay;\n\t\tcur_size = cur_size * fb->base.format->cpp[0];\n\t\tif (fb->base.pitches[0] < cur_size) {\n\t\t\tdrm_dbg_kms(&i915->drm,\n\t\t\t\t    \"fb not wide enough for [PLANE:%d:%s] (%d vs %d)\\n\",\n\t\t\t\t    plane->base.base.id, plane->base.name,\n\t\t\t\t    cur_size, fb->base.pitches[0]);\n\t\t\tfb = NULL;\n\t\t\tbreak;\n\t\t}\n\n\t\tcur_size = crtc_state->uapi.adjusted_mode.crtc_vdisplay;\n\t\tcur_size = intel_fb_align_height(&fb->base, 0, cur_size);\n\t\tcur_size *= fb->base.pitches[0];\n\t\tdrm_dbg_kms(&i915->drm,\n\t\t\t    \"[CRTC:%d:%s] area: %dx%d, bpp: %d, size: %d\\n\",\n\t\t\t    crtc->base.base.id, crtc->base.name,\n\t\t\t    crtc_state->uapi.adjusted_mode.crtc_hdisplay,\n\t\t\t    crtc_state->uapi.adjusted_mode.crtc_vdisplay,\n\t\t\t    fb->base.format->cpp[0] * 8,\n\t\t\t    cur_size);\n\n\t\tif (cur_size > max_size) {\n\t\t\tdrm_dbg_kms(&i915->drm,\n\t\t\t\t    \"fb not big enough for [PLANE:%d:%s] (%d vs %d)\\n\",\n\t\t\t\t    plane->base.base.id, plane->base.name,\n\t\t\t\t    cur_size, max_size);\n\t\t\tfb = NULL;\n\t\t\tbreak;\n\t\t}\n\n\t\tdrm_dbg_kms(&i915->drm,\n\t\t\t    \"fb big enough [PLANE:%d:%s] (%d >= %d)\\n\",\n\t\t\t    plane->base.base.id, plane->base.name,\n\t\t\t    max_size, cur_size);\n\t}\n\n\tif (!fb) {\n\t\tdrm_dbg_kms(&i915->drm,\n\t\t\t    \"BIOS fb not suitable for all pipes, not using\\n\");\n\t\tgoto out;\n\t}\n\n\tifbdev->preferred_bpp = fb->base.format->cpp[0] * 8;\n\tifbdev->fb = fb;\n\n\tdrm_framebuffer_get(&ifbdev->fb->base);\n\n\t \n\tfor_each_intel_crtc(dev, crtc) {\n\t\tstruct intel_crtc_state *crtc_state =\n\t\t\tto_intel_crtc_state(crtc->base.state);\n\t\tstruct intel_plane *plane =\n\t\t\tto_intel_plane(crtc->base.primary);\n\t\tstruct intel_plane_state *plane_state =\n\t\t\tto_intel_plane_state(plane->base.state);\n\n\t\tif (!crtc_state->uapi.active)\n\t\t\tcontinue;\n\n\t\tdrm_WARN(dev, !plane_state->uapi.fb,\n\t\t\t \"re-used BIOS config but lost an fb on [PLANE:%d:%s]\\n\",\n\t\t\t plane->base.base.id, plane->base.name);\n\t}\n\n\n\tdrm_dbg_kms(&i915->drm, \"using BIOS fb for initial console\\n\");\n\treturn true;\n\nout:\n\n\treturn false;\n}\n\nstatic void intel_fbdev_suspend_worker(struct work_struct *work)\n{\n\tintel_fbdev_set_suspend(&container_of(work,\n\t\t\t\t\t      struct drm_i915_private,\n\t\t\t\t\t      display.fbdev.suspend_work)->drm,\n\t\t\t\tFBINFO_STATE_RUNNING,\n\t\t\t\ttrue);\n}\n\nint intel_fbdev_init(struct drm_device *dev)\n{\n\tstruct drm_i915_private *dev_priv = to_i915(dev);\n\tstruct intel_fbdev *ifbdev;\n\tint ret;\n\n\tif (drm_WARN_ON(dev, !HAS_DISPLAY(dev_priv)))\n\t\treturn -ENODEV;\n\n\tifbdev = kzalloc(sizeof(struct intel_fbdev), GFP_KERNEL);\n\tif (ifbdev == NULL)\n\t\treturn -ENOMEM;\n\n\tmutex_init(&ifbdev->hpd_lock);\n\tdrm_fb_helper_prepare(dev, &ifbdev->helper, 32, &intel_fb_helper_funcs);\n\n\tif (intel_fbdev_init_bios(dev, ifbdev))\n\t\tifbdev->helper.preferred_bpp = ifbdev->preferred_bpp;\n\telse\n\t\tifbdev->preferred_bpp = ifbdev->helper.preferred_bpp;\n\n\tret = drm_fb_helper_init(dev, &ifbdev->helper);\n\tif (ret) {\n\t\tkfree(ifbdev);\n\t\treturn ret;\n\t}\n\n\tdev_priv->display.fbdev.fbdev = ifbdev;\n\tINIT_WORK(&dev_priv->display.fbdev.suspend_work, intel_fbdev_suspend_worker);\n\n\treturn 0;\n}\n\nstatic void intel_fbdev_initial_config(void *data, async_cookie_t cookie)\n{\n\tstruct intel_fbdev *ifbdev = data;\n\n\t \n\tif (drm_fb_helper_initial_config(&ifbdev->helper))\n\t\tintel_fbdev_unregister(to_i915(ifbdev->helper.dev));\n}\n\nvoid intel_fbdev_initial_config_async(struct drm_i915_private *dev_priv)\n{\n\tstruct intel_fbdev *ifbdev = dev_priv->display.fbdev.fbdev;\n\n\tif (!ifbdev)\n\t\treturn;\n\n\tifbdev->cookie = async_schedule(intel_fbdev_initial_config, ifbdev);\n}\n\nstatic void intel_fbdev_sync(struct intel_fbdev *ifbdev)\n{\n\tif (!ifbdev->cookie)\n\t\treturn;\n\n\t \n\tasync_synchronize_cookie(ifbdev->cookie + 1);\n\tifbdev->cookie = 0;\n}\n\nvoid intel_fbdev_unregister(struct drm_i915_private *dev_priv)\n{\n\tstruct intel_fbdev *ifbdev = dev_priv->display.fbdev.fbdev;\n\n\tif (!ifbdev)\n\t\treturn;\n\n\tintel_fbdev_set_suspend(&dev_priv->drm, FBINFO_STATE_SUSPENDED, true);\n\n\tif (!current_is_async())\n\t\tintel_fbdev_sync(ifbdev);\n\n\tdrm_fb_helper_unregister_info(&ifbdev->helper);\n}\n\nvoid intel_fbdev_fini(struct drm_i915_private *dev_priv)\n{\n\tstruct intel_fbdev *ifbdev = fetch_and_zero(&dev_priv->display.fbdev.fbdev);\n\n\tif (!ifbdev)\n\t\treturn;\n\n\tintel_fbdev_destroy(ifbdev);\n}\n\n \nstatic void intel_fbdev_hpd_set_suspend(struct drm_i915_private *i915, int state)\n{\n\tstruct intel_fbdev *ifbdev = i915->display.fbdev.fbdev;\n\tbool send_hpd = false;\n\n\tmutex_lock(&ifbdev->hpd_lock);\n\tifbdev->hpd_suspended = state == FBINFO_STATE_SUSPENDED;\n\tsend_hpd = !ifbdev->hpd_suspended && ifbdev->hpd_waiting;\n\tifbdev->hpd_waiting = false;\n\tmutex_unlock(&ifbdev->hpd_lock);\n\n\tif (send_hpd) {\n\t\tdrm_dbg_kms(&i915->drm, \"Handling delayed fbcon HPD event\\n\");\n\t\tdrm_fb_helper_hotplug_event(&ifbdev->helper);\n\t}\n}\n\nvoid intel_fbdev_set_suspend(struct drm_device *dev, int state, bool synchronous)\n{\n\tstruct drm_i915_private *dev_priv = to_i915(dev);\n\tstruct intel_fbdev *ifbdev = dev_priv->display.fbdev.fbdev;\n\tstruct fb_info *info;\n\n\tif (!ifbdev)\n\t\treturn;\n\n\tif (drm_WARN_ON(&dev_priv->drm, !HAS_DISPLAY(dev_priv)))\n\t\treturn;\n\n\tif (!ifbdev->vma)\n\t\tgoto set_suspend;\n\n\tinfo = ifbdev->helper.info;\n\n\tif (synchronous) {\n\t\t \n\t\tif (state != FBINFO_STATE_RUNNING)\n\t\t\tflush_work(&dev_priv->display.fbdev.suspend_work);\n\n\t\tconsole_lock();\n\t} else {\n\t\t \n\t\tdrm_WARN_ON(dev, state != FBINFO_STATE_RUNNING);\n\t\tif (!console_trylock()) {\n\t\t\t \n\t\t\tqueue_work(dev_priv->unordered_wq,\n\t\t\t\t   &dev_priv->display.fbdev.suspend_work);\n\t\t\treturn;\n\t\t}\n\t}\n\n\t \n\tif (state == FBINFO_STATE_RUNNING &&\n\t    !i915_gem_object_is_shmem(intel_fb_obj(&ifbdev->fb->base)))\n\t\tmemset_io(info->screen_base, 0, info->screen_size);\n\n\tdrm_fb_helper_set_suspend(&ifbdev->helper, state);\n\tconsole_unlock();\n\nset_suspend:\n\tintel_fbdev_hpd_set_suspend(dev_priv, state);\n}\n\nvoid intel_fbdev_output_poll_changed(struct drm_device *dev)\n{\n\tstruct intel_fbdev *ifbdev = to_i915(dev)->display.fbdev.fbdev;\n\tbool send_hpd;\n\n\tif (!ifbdev)\n\t\treturn;\n\n\tintel_fbdev_sync(ifbdev);\n\n\tmutex_lock(&ifbdev->hpd_lock);\n\tsend_hpd = !ifbdev->hpd_suspended;\n\tifbdev->hpd_waiting = true;\n\tmutex_unlock(&ifbdev->hpd_lock);\n\n\tif (send_hpd && (ifbdev->vma || ifbdev->helper.deferred_setup))\n\t\tdrm_fb_helper_hotplug_event(&ifbdev->helper);\n}\n\nvoid intel_fbdev_restore_mode(struct drm_i915_private *dev_priv)\n{\n\tstruct intel_fbdev *ifbdev = dev_priv->display.fbdev.fbdev;\n\n\tif (!ifbdev)\n\t\treturn;\n\n\tintel_fbdev_sync(ifbdev);\n\tif (!ifbdev->vma)\n\t\treturn;\n\n\tif (drm_fb_helper_restore_fbdev_mode_unlocked(&ifbdev->helper) == 0)\n\t\tintel_fbdev_invalidate(ifbdev);\n}\n\nstruct intel_framebuffer *intel_fbdev_framebuffer(struct intel_fbdev *fbdev)\n{\n\tif (!fbdev || !fbdev->helper.fb)\n\t\treturn NULL;\n\n\treturn to_intel_framebuffer(fbdev->helper.fb);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}