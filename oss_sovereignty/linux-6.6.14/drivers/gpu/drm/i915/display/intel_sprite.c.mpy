{
  "module_name": "intel_sprite.c",
  "hash_id": "efc59c2baf58697cd648713dcab3c16bd6f7f9f7de0792d9a9655c027ecd638f",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/i915/display/intel_sprite.c",
  "human_readable_source": " \n\n#include <linux/string_helpers.h>\n\n#include <drm/drm_atomic_helper.h>\n#include <drm/drm_blend.h>\n#include <drm/drm_color_mgmt.h>\n#include <drm/drm_fourcc.h>\n#include <drm/drm_rect.h>\n\n#include \"i915_drv.h\"\n#include \"i915_reg.h\"\n#include \"i9xx_plane.h\"\n#include \"intel_atomic_plane.h\"\n#include \"intel_de.h\"\n#include \"intel_display_types.h\"\n#include \"intel_fb.h\"\n#include \"intel_sprite.h\"\n\nstatic void i9xx_plane_linear_gamma(u16 gamma[8])\n{\n\t \n\tstatic const u8 in[8] = { 0, 1, 2, 4, 8, 16, 24, 32 };\n\tint i;\n\n\tfor (i = 0; i < 8; i++)\n\t\tgamma[i] = (in[i] << 8) / 32;\n}\n\nstatic void\nchv_sprite_update_csc(const struct intel_plane_state *plane_state)\n{\n\tstruct intel_plane *plane = to_intel_plane(plane_state->uapi.plane);\n\tstruct drm_i915_private *dev_priv = to_i915(plane->base.dev);\n\tconst struct drm_framebuffer *fb = plane_state->hw.fb;\n\tenum plane_id plane_id = plane->id;\n\t \n\tstatic const s16 csc_matrix[][9] = {\n\t\t \n\t\t[DRM_COLOR_YCBCR_BT601] = {\n\t\t\t 5743, 4096,     0,\n\t\t\t-2925, 4096, -1410,\n\t\t\t    0, 4096,  7258,\n\t\t},\n\t\t \n\t\t[DRM_COLOR_YCBCR_BT709] = {\n\t\t\t 6450, 4096,     0,\n\t\t\t-1917, 4096,  -767,\n\t\t\t    0, 4096,  7601,\n\t\t},\n\t};\n\tconst s16 *csc = csc_matrix[plane_state->hw.color_encoding];\n\n\t \n\tif (!fb->format->is_yuv)\n\t\treturn;\n\n\tintel_de_write_fw(dev_priv, SPCSCYGOFF(plane_id),\n\t\t\t  SPCSC_OOFF(0) | SPCSC_IOFF(0));\n\tintel_de_write_fw(dev_priv, SPCSCCBOFF(plane_id),\n\t\t\t  SPCSC_OOFF(0) | SPCSC_IOFF(0));\n\tintel_de_write_fw(dev_priv, SPCSCCROFF(plane_id),\n\t\t\t  SPCSC_OOFF(0) | SPCSC_IOFF(0));\n\n\tintel_de_write_fw(dev_priv, SPCSCC01(plane_id),\n\t\t\t  SPCSC_C1(csc[1]) | SPCSC_C0(csc[0]));\n\tintel_de_write_fw(dev_priv, SPCSCC23(plane_id),\n\t\t\t  SPCSC_C1(csc[3]) | SPCSC_C0(csc[2]));\n\tintel_de_write_fw(dev_priv, SPCSCC45(plane_id),\n\t\t\t  SPCSC_C1(csc[5]) | SPCSC_C0(csc[4]));\n\tintel_de_write_fw(dev_priv, SPCSCC67(plane_id),\n\t\t\t  SPCSC_C1(csc[7]) | SPCSC_C0(csc[6]));\n\tintel_de_write_fw(dev_priv, SPCSCC8(plane_id), SPCSC_C0(csc[8]));\n\n\tintel_de_write_fw(dev_priv, SPCSCYGICLAMP(plane_id),\n\t\t\t  SPCSC_IMAX(1023) | SPCSC_IMIN(0));\n\tintel_de_write_fw(dev_priv, SPCSCCBICLAMP(plane_id),\n\t\t\t  SPCSC_IMAX(512) | SPCSC_IMIN(-512));\n\tintel_de_write_fw(dev_priv, SPCSCCRICLAMP(plane_id),\n\t\t\t  SPCSC_IMAX(512) | SPCSC_IMIN(-512));\n\n\tintel_de_write_fw(dev_priv, SPCSCYGOCLAMP(plane_id),\n\t\t\t  SPCSC_OMAX(1023) | SPCSC_OMIN(0));\n\tintel_de_write_fw(dev_priv, SPCSCCBOCLAMP(plane_id),\n\t\t\t  SPCSC_OMAX(1023) | SPCSC_OMIN(0));\n\tintel_de_write_fw(dev_priv, SPCSCCROCLAMP(plane_id),\n\t\t\t  SPCSC_OMAX(1023) | SPCSC_OMIN(0));\n}\n\n#define SIN_0 0\n#define COS_0 1\n\nstatic void\nvlv_sprite_update_clrc(const struct intel_plane_state *plane_state)\n{\n\tstruct intel_plane *plane = to_intel_plane(plane_state->uapi.plane);\n\tstruct drm_i915_private *dev_priv = to_i915(plane->base.dev);\n\tconst struct drm_framebuffer *fb = plane_state->hw.fb;\n\tenum pipe pipe = plane->pipe;\n\tenum plane_id plane_id = plane->id;\n\tint contrast, brightness, sh_scale, sh_sin, sh_cos;\n\n\tif (fb->format->is_yuv &&\n\t    plane_state->hw.color_range == DRM_COLOR_YCBCR_LIMITED_RANGE) {\n\t\t \n\t\tcontrast = DIV_ROUND_CLOSEST(255 << 6, 235 - 16);\n\t\tbrightness = -DIV_ROUND_CLOSEST(16 * 255, 235 - 16);\n\t\tsh_scale = DIV_ROUND_CLOSEST(128 << 7, 240 - 128);\n\t\tsh_sin = SIN_0 * sh_scale;\n\t\tsh_cos = COS_0 * sh_scale;\n\t} else {\n\t\t \n\t\tcontrast = 1 << 6;\n\t\tbrightness = 0;\n\t\tsh_scale = 1 << 7;\n\t\tsh_sin = SIN_0 * sh_scale;\n\t\tsh_cos = COS_0 * sh_scale;\n\t}\n\n\t \n\tintel_de_write_fw(dev_priv, SPCLRC0(pipe, plane_id),\n\t\t\t  SP_CONTRAST(contrast) | SP_BRIGHTNESS(brightness));\n\tintel_de_write_fw(dev_priv, SPCLRC1(pipe, plane_id),\n\t\t\t  SP_SH_SIN(sh_sin) | SP_SH_COS(sh_cos));\n}\n\nstatic void\nvlv_plane_ratio(const struct intel_crtc_state *crtc_state,\n\t\tconst struct intel_plane_state *plane_state,\n\t\tunsigned int *num, unsigned int *den)\n{\n\tu8 active_planes = crtc_state->active_planes & ~BIT(PLANE_CURSOR);\n\tconst struct drm_framebuffer *fb = plane_state->hw.fb;\n\tunsigned int cpp = fb->format->cpp[0];\n\n\t \n\tif (hweight8(active_planes) == 3) {\n\t\tswitch (cpp) {\n\t\tcase 8:\n\t\t\t*num = 11;\n\t\t\t*den = 8;\n\t\t\tbreak;\n\t\tcase 4:\n\t\t\t*num = 18;\n\t\t\t*den = 16;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t*num = 1;\n\t\t\t*den = 1;\n\t\t\tbreak;\n\t\t}\n\t} else if (hweight8(active_planes) == 2) {\n\t\tswitch (cpp) {\n\t\tcase 8:\n\t\t\t*num = 10;\n\t\t\t*den = 8;\n\t\t\tbreak;\n\t\tcase 4:\n\t\t\t*num = 17;\n\t\t\t*den = 16;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t*num = 1;\n\t\t\t*den = 1;\n\t\t\tbreak;\n\t\t}\n\t} else {\n\t\tswitch (cpp) {\n\t\tcase 8:\n\t\t\t*num = 10;\n\t\t\t*den = 8;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t*num = 1;\n\t\t\t*den = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\nint vlv_plane_min_cdclk(const struct intel_crtc_state *crtc_state,\n\t\t\tconst struct intel_plane_state *plane_state)\n{\n\tunsigned int pixel_rate;\n\tunsigned int num, den;\n\n\t \n\tpixel_rate = crtc_state->pixel_rate;\n\n\tvlv_plane_ratio(crtc_state, plane_state, &num, &den);\n\n\treturn DIV_ROUND_UP(pixel_rate * num, den);\n}\n\nstatic u32 vlv_sprite_ctl_crtc(const struct intel_crtc_state *crtc_state)\n{\n\tu32 sprctl = 0;\n\n\tif (crtc_state->gamma_enable)\n\t\tsprctl |= SP_PIPE_GAMMA_ENABLE;\n\n\treturn sprctl;\n}\n\nstatic u32 vlv_sprite_ctl(const struct intel_crtc_state *crtc_state,\n\t\t\t  const struct intel_plane_state *plane_state)\n{\n\tconst struct drm_framebuffer *fb = plane_state->hw.fb;\n\tunsigned int rotation = plane_state->hw.rotation;\n\tconst struct drm_intel_sprite_colorkey *key = &plane_state->ckey;\n\tu32 sprctl;\n\n\tsprctl = SP_ENABLE;\n\n\tswitch (fb->format->format) {\n\tcase DRM_FORMAT_YUYV:\n\t\tsprctl |= SP_FORMAT_YUV422 | SP_YUV_ORDER_YUYV;\n\t\tbreak;\n\tcase DRM_FORMAT_YVYU:\n\t\tsprctl |= SP_FORMAT_YUV422 | SP_YUV_ORDER_YVYU;\n\t\tbreak;\n\tcase DRM_FORMAT_UYVY:\n\t\tsprctl |= SP_FORMAT_YUV422 | SP_YUV_ORDER_UYVY;\n\t\tbreak;\n\tcase DRM_FORMAT_VYUY:\n\t\tsprctl |= SP_FORMAT_YUV422 | SP_YUV_ORDER_VYUY;\n\t\tbreak;\n\tcase DRM_FORMAT_C8:\n\t\tsprctl |= SP_FORMAT_8BPP;\n\t\tbreak;\n\tcase DRM_FORMAT_RGB565:\n\t\tsprctl |= SP_FORMAT_BGR565;\n\t\tbreak;\n\tcase DRM_FORMAT_XRGB8888:\n\t\tsprctl |= SP_FORMAT_BGRX8888;\n\t\tbreak;\n\tcase DRM_FORMAT_ARGB8888:\n\t\tsprctl |= SP_FORMAT_BGRA8888;\n\t\tbreak;\n\tcase DRM_FORMAT_XBGR2101010:\n\t\tsprctl |= SP_FORMAT_RGBX1010102;\n\t\tbreak;\n\tcase DRM_FORMAT_ABGR2101010:\n\t\tsprctl |= SP_FORMAT_RGBA1010102;\n\t\tbreak;\n\tcase DRM_FORMAT_XRGB2101010:\n\t\tsprctl |= SP_FORMAT_BGRX1010102;\n\t\tbreak;\n\tcase DRM_FORMAT_ARGB2101010:\n\t\tsprctl |= SP_FORMAT_BGRA1010102;\n\t\tbreak;\n\tcase DRM_FORMAT_XBGR8888:\n\t\tsprctl |= SP_FORMAT_RGBX8888;\n\t\tbreak;\n\tcase DRM_FORMAT_ABGR8888:\n\t\tsprctl |= SP_FORMAT_RGBA8888;\n\t\tbreak;\n\tdefault:\n\t\tMISSING_CASE(fb->format->format);\n\t\treturn 0;\n\t}\n\n\tif (plane_state->hw.color_encoding == DRM_COLOR_YCBCR_BT709)\n\t\tsprctl |= SP_YUV_FORMAT_BT709;\n\n\tif (fb->modifier == I915_FORMAT_MOD_X_TILED)\n\t\tsprctl |= SP_TILED;\n\n\tif (rotation & DRM_MODE_ROTATE_180)\n\t\tsprctl |= SP_ROTATE_180;\n\n\tif (rotation & DRM_MODE_REFLECT_X)\n\t\tsprctl |= SP_MIRROR;\n\n\tif (key->flags & I915_SET_COLORKEY_SOURCE)\n\t\tsprctl |= SP_SOURCE_KEY;\n\n\treturn sprctl;\n}\n\nstatic void vlv_sprite_update_gamma(const struct intel_plane_state *plane_state)\n{\n\tstruct intel_plane *plane = to_intel_plane(plane_state->uapi.plane);\n\tstruct drm_i915_private *dev_priv = to_i915(plane->base.dev);\n\tconst struct drm_framebuffer *fb = plane_state->hw.fb;\n\tenum pipe pipe = plane->pipe;\n\tenum plane_id plane_id = plane->id;\n\tu16 gamma[8];\n\tint i;\n\n\t \n\tif (!fb->format->is_yuv)\n\t\treturn;\n\n\ti9xx_plane_linear_gamma(gamma);\n\n\t \n\t \n\tfor (i = 1; i < 8 - 1; i++)\n\t\tintel_de_write_fw(dev_priv, SPGAMC(pipe, plane_id, i - 1),\n\t\t\t\t  gamma[i] << 16 | gamma[i] << 8 | gamma[i]);\n}\n\nstatic void\nvlv_sprite_update_noarm(struct intel_plane *plane,\n\t\t\tconst struct intel_crtc_state *crtc_state,\n\t\t\tconst struct intel_plane_state *plane_state)\n{\n\tstruct drm_i915_private *dev_priv = to_i915(plane->base.dev);\n\tenum pipe pipe = plane->pipe;\n\tenum plane_id plane_id = plane->id;\n\tint crtc_x = plane_state->uapi.dst.x1;\n\tint crtc_y = plane_state->uapi.dst.y1;\n\tu32 crtc_w = drm_rect_width(&plane_state->uapi.dst);\n\tu32 crtc_h = drm_rect_height(&plane_state->uapi.dst);\n\n\tintel_de_write_fw(dev_priv, SPSTRIDE(pipe, plane_id),\n\t\t\t  plane_state->view.color_plane[0].mapping_stride);\n\tintel_de_write_fw(dev_priv, SPPOS(pipe, plane_id),\n\t\t\t  SP_POS_Y(crtc_y) | SP_POS_X(crtc_x));\n\tintel_de_write_fw(dev_priv, SPSIZE(pipe, plane_id),\n\t\t\t  SP_HEIGHT(crtc_h - 1) | SP_WIDTH(crtc_w - 1));\n}\n\nstatic void\nvlv_sprite_update_arm(struct intel_plane *plane,\n\t\t      const struct intel_crtc_state *crtc_state,\n\t\t      const struct intel_plane_state *plane_state)\n{\n\tstruct drm_i915_private *dev_priv = to_i915(plane->base.dev);\n\tenum pipe pipe = plane->pipe;\n\tenum plane_id plane_id = plane->id;\n\tconst struct drm_intel_sprite_colorkey *key = &plane_state->ckey;\n\tu32 sprsurf_offset = plane_state->view.color_plane[0].offset;\n\tu32 x = plane_state->view.color_plane[0].x;\n\tu32 y = plane_state->view.color_plane[0].y;\n\tu32 sprctl, linear_offset;\n\n\tsprctl = plane_state->ctl | vlv_sprite_ctl_crtc(crtc_state);\n\n\tlinear_offset = intel_fb_xy_to_linear(x, y, plane_state, 0);\n\n\tif (IS_CHERRYVIEW(dev_priv) && pipe == PIPE_B)\n\t\tchv_sprite_update_csc(plane_state);\n\n\tif (key->flags) {\n\t\tintel_de_write_fw(dev_priv, SPKEYMINVAL(pipe, plane_id),\n\t\t\t\t  key->min_value);\n\t\tintel_de_write_fw(dev_priv, SPKEYMSK(pipe, plane_id),\n\t\t\t\t  key->channel_mask);\n\t\tintel_de_write_fw(dev_priv, SPKEYMAXVAL(pipe, plane_id),\n\t\t\t\t  key->max_value);\n\t}\n\n\tintel_de_write_fw(dev_priv, SPCONSTALPHA(pipe, plane_id), 0);\n\n\tintel_de_write_fw(dev_priv, SPLINOFF(pipe, plane_id), linear_offset);\n\tintel_de_write_fw(dev_priv, SPTILEOFF(pipe, plane_id),\n\t\t\t  SP_OFFSET_Y(y) | SP_OFFSET_X(x));\n\n\t \n\tintel_de_write_fw(dev_priv, SPCNTR(pipe, plane_id), sprctl);\n\tintel_de_write_fw(dev_priv, SPSURF(pipe, plane_id),\n\t\t\t  intel_plane_ggtt_offset(plane_state) + sprsurf_offset);\n\n\tvlv_sprite_update_clrc(plane_state);\n\tvlv_sprite_update_gamma(plane_state);\n}\n\nstatic void\nvlv_sprite_disable_arm(struct intel_plane *plane,\n\t\t       const struct intel_crtc_state *crtc_state)\n{\n\tstruct drm_i915_private *dev_priv = to_i915(plane->base.dev);\n\tenum pipe pipe = plane->pipe;\n\tenum plane_id plane_id = plane->id;\n\n\tintel_de_write_fw(dev_priv, SPCNTR(pipe, plane_id), 0);\n\tintel_de_write_fw(dev_priv, SPSURF(pipe, plane_id), 0);\n}\n\nstatic bool\nvlv_sprite_get_hw_state(struct intel_plane *plane,\n\t\t\tenum pipe *pipe)\n{\n\tstruct drm_i915_private *dev_priv = to_i915(plane->base.dev);\n\tenum intel_display_power_domain power_domain;\n\tenum plane_id plane_id = plane->id;\n\tintel_wakeref_t wakeref;\n\tbool ret;\n\n\tpower_domain = POWER_DOMAIN_PIPE(plane->pipe);\n\twakeref = intel_display_power_get_if_enabled(dev_priv, power_domain);\n\tif (!wakeref)\n\t\treturn false;\n\n\tret = intel_de_read(dev_priv, SPCNTR(plane->pipe, plane_id)) & SP_ENABLE;\n\n\t*pipe = plane->pipe;\n\n\tintel_display_power_put(dev_priv, power_domain, wakeref);\n\n\treturn ret;\n}\n\nstatic void ivb_plane_ratio(const struct intel_crtc_state *crtc_state,\n\t\t\t    const struct intel_plane_state *plane_state,\n\t\t\t    unsigned int *num, unsigned int *den)\n{\n\tu8 active_planes = crtc_state->active_planes & ~BIT(PLANE_CURSOR);\n\tconst struct drm_framebuffer *fb = plane_state->hw.fb;\n\tunsigned int cpp = fb->format->cpp[0];\n\n\tif (hweight8(active_planes) == 2) {\n\t\tswitch (cpp) {\n\t\tcase 8:\n\t\t\t*num = 10;\n\t\t\t*den = 8;\n\t\t\tbreak;\n\t\tcase 4:\n\t\t\t*num = 17;\n\t\t\t*den = 16;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t*num = 1;\n\t\t\t*den = 1;\n\t\t\tbreak;\n\t\t}\n\t} else {\n\t\tswitch (cpp) {\n\t\tcase 8:\n\t\t\t*num = 9;\n\t\t\t*den = 8;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t*num = 1;\n\t\t\t*den = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\nstatic void ivb_plane_ratio_scaling(const struct intel_crtc_state *crtc_state,\n\t\t\t\t    const struct intel_plane_state *plane_state,\n\t\t\t\t    unsigned int *num, unsigned int *den)\n{\n\tconst struct drm_framebuffer *fb = plane_state->hw.fb;\n\tunsigned int cpp = fb->format->cpp[0];\n\n\tswitch (cpp) {\n\tcase 8:\n\t\t*num = 12;\n\t\t*den = 8;\n\t\tbreak;\n\tcase 4:\n\t\t*num = 19;\n\t\t*den = 16;\n\t\tbreak;\n\tcase 2:\n\t\t*num = 33;\n\t\t*den = 32;\n\t\tbreak;\n\tdefault:\n\t\t*num = 1;\n\t\t*den = 1;\n\t\tbreak;\n\t}\n}\n\nint ivb_plane_min_cdclk(const struct intel_crtc_state *crtc_state,\n\t\t\tconst struct intel_plane_state *plane_state)\n{\n\tunsigned int pixel_rate;\n\tunsigned int num, den;\n\n\t \n\tpixel_rate = crtc_state->pixel_rate;\n\n\tivb_plane_ratio(crtc_state, plane_state, &num, &den);\n\n\treturn DIV_ROUND_UP(pixel_rate * num, den);\n}\n\nstatic int ivb_sprite_min_cdclk(const struct intel_crtc_state *crtc_state,\n\t\t\t\tconst struct intel_plane_state *plane_state)\n{\n\tunsigned int src_w, dst_w, pixel_rate;\n\tunsigned int num, den;\n\n\t \n\tpixel_rate = crtc_state->pixel_rate;\n\n\tsrc_w = drm_rect_width(&plane_state->uapi.src) >> 16;\n\tdst_w = drm_rect_width(&plane_state->uapi.dst);\n\n\tif (src_w != dst_w)\n\t\tivb_plane_ratio_scaling(crtc_state, plane_state, &num, &den);\n\telse\n\t\tivb_plane_ratio(crtc_state, plane_state, &num, &den);\n\n\t \n\tdst_w = min(src_w, dst_w);\n\n\treturn DIV_ROUND_UP_ULL(mul_u32_u32(pixel_rate, num * src_w),\n\t\t\t\tden * dst_w);\n}\n\nstatic void hsw_plane_ratio(const struct intel_crtc_state *crtc_state,\n\t\t\t    const struct intel_plane_state *plane_state,\n\t\t\t    unsigned int *num, unsigned int *den)\n{\n\tu8 active_planes = crtc_state->active_planes & ~BIT(PLANE_CURSOR);\n\tconst struct drm_framebuffer *fb = plane_state->hw.fb;\n\tunsigned int cpp = fb->format->cpp[0];\n\n\tif (hweight8(active_planes) == 2) {\n\t\tswitch (cpp) {\n\t\tcase 8:\n\t\t\t*num = 10;\n\t\t\t*den = 8;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t*num = 1;\n\t\t\t*den = 1;\n\t\t\tbreak;\n\t\t}\n\t} else {\n\t\tswitch (cpp) {\n\t\tcase 8:\n\t\t\t*num = 9;\n\t\t\t*den = 8;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t*num = 1;\n\t\t\t*den = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\nint hsw_plane_min_cdclk(const struct intel_crtc_state *crtc_state,\n\t\t\tconst struct intel_plane_state *plane_state)\n{\n\tunsigned int pixel_rate = crtc_state->pixel_rate;\n\tunsigned int num, den;\n\n\thsw_plane_ratio(crtc_state, plane_state, &num, &den);\n\n\treturn DIV_ROUND_UP(pixel_rate * num, den);\n}\n\nstatic u32 ivb_sprite_ctl_crtc(const struct intel_crtc_state *crtc_state)\n{\n\tu32 sprctl = 0;\n\n\tif (crtc_state->gamma_enable)\n\t\tsprctl |= SPRITE_PIPE_GAMMA_ENABLE;\n\n\tif (crtc_state->csc_enable)\n\t\tsprctl |= SPRITE_PIPE_CSC_ENABLE;\n\n\treturn sprctl;\n}\n\nstatic bool ivb_need_sprite_gamma(const struct intel_plane_state *plane_state)\n{\n\tstruct drm_i915_private *dev_priv =\n\t\tto_i915(plane_state->uapi.plane->dev);\n\tconst struct drm_framebuffer *fb = plane_state->hw.fb;\n\n\treturn fb->format->cpp[0] == 8 &&\n\t\t(IS_IVYBRIDGE(dev_priv) || IS_HASWELL(dev_priv));\n}\n\nstatic u32 ivb_sprite_ctl(const struct intel_crtc_state *crtc_state,\n\t\t\t  const struct intel_plane_state *plane_state)\n{\n\tstruct drm_i915_private *dev_priv =\n\t\tto_i915(plane_state->uapi.plane->dev);\n\tconst struct drm_framebuffer *fb = plane_state->hw.fb;\n\tunsigned int rotation = plane_state->hw.rotation;\n\tconst struct drm_intel_sprite_colorkey *key = &plane_state->ckey;\n\tu32 sprctl;\n\n\tsprctl = SPRITE_ENABLE;\n\n\tif (IS_IVYBRIDGE(dev_priv))\n\t\tsprctl |= SPRITE_TRICKLE_FEED_DISABLE;\n\n\tswitch (fb->format->format) {\n\tcase DRM_FORMAT_XBGR8888:\n\t\tsprctl |= SPRITE_FORMAT_RGBX888 | SPRITE_RGB_ORDER_RGBX;\n\t\tbreak;\n\tcase DRM_FORMAT_XRGB8888:\n\t\tsprctl |= SPRITE_FORMAT_RGBX888;\n\t\tbreak;\n\tcase DRM_FORMAT_XBGR2101010:\n\t\tsprctl |= SPRITE_FORMAT_RGBX101010 | SPRITE_RGB_ORDER_RGBX;\n\t\tbreak;\n\tcase DRM_FORMAT_XRGB2101010:\n\t\tsprctl |= SPRITE_FORMAT_RGBX101010;\n\t\tbreak;\n\tcase DRM_FORMAT_XBGR16161616F:\n\t\tsprctl |= SPRITE_FORMAT_RGBX161616 | SPRITE_RGB_ORDER_RGBX;\n\t\tbreak;\n\tcase DRM_FORMAT_XRGB16161616F:\n\t\tsprctl |= SPRITE_FORMAT_RGBX161616;\n\t\tbreak;\n\tcase DRM_FORMAT_YUYV:\n\t\tsprctl |= SPRITE_FORMAT_YUV422 | SPRITE_YUV_ORDER_YUYV;\n\t\tbreak;\n\tcase DRM_FORMAT_YVYU:\n\t\tsprctl |= SPRITE_FORMAT_YUV422 | SPRITE_YUV_ORDER_YVYU;\n\t\tbreak;\n\tcase DRM_FORMAT_UYVY:\n\t\tsprctl |= SPRITE_FORMAT_YUV422 | SPRITE_YUV_ORDER_UYVY;\n\t\tbreak;\n\tcase DRM_FORMAT_VYUY:\n\t\tsprctl |= SPRITE_FORMAT_YUV422 | SPRITE_YUV_ORDER_VYUY;\n\t\tbreak;\n\tdefault:\n\t\tMISSING_CASE(fb->format->format);\n\t\treturn 0;\n\t}\n\n\tif (!ivb_need_sprite_gamma(plane_state))\n\t\tsprctl |= SPRITE_PLANE_GAMMA_DISABLE;\n\n\tif (plane_state->hw.color_encoding == DRM_COLOR_YCBCR_BT709)\n\t\tsprctl |= SPRITE_YUV_TO_RGB_CSC_FORMAT_BT709;\n\n\tif (plane_state->hw.color_range == DRM_COLOR_YCBCR_FULL_RANGE)\n\t\tsprctl |= SPRITE_YUV_RANGE_CORRECTION_DISABLE;\n\n\tif (fb->modifier == I915_FORMAT_MOD_X_TILED)\n\t\tsprctl |= SPRITE_TILED;\n\n\tif (rotation & DRM_MODE_ROTATE_180)\n\t\tsprctl |= SPRITE_ROTATE_180;\n\n\tif (key->flags & I915_SET_COLORKEY_DESTINATION)\n\t\tsprctl |= SPRITE_DEST_KEY;\n\telse if (key->flags & I915_SET_COLORKEY_SOURCE)\n\t\tsprctl |= SPRITE_SOURCE_KEY;\n\n\treturn sprctl;\n}\n\nstatic void ivb_sprite_linear_gamma(const struct intel_plane_state *plane_state,\n\t\t\t\t    u16 gamma[18])\n{\n\tint scale, i;\n\n\t \n\tscale = 4;\n\n\tfor (i = 0; i < 16; i++)\n\t\tgamma[i] = min((scale * i << 10) / 16, (1 << 10) - 1);\n\n\tgamma[i] = min((scale * i << 10) / 16, 1 << 10);\n\ti++;\n\n\tgamma[i] = 3 << 10;\n\ti++;\n}\n\nstatic void ivb_sprite_update_gamma(const struct intel_plane_state *plane_state)\n{\n\tstruct intel_plane *plane = to_intel_plane(plane_state->uapi.plane);\n\tstruct drm_i915_private *dev_priv = to_i915(plane->base.dev);\n\tenum pipe pipe = plane->pipe;\n\tu16 gamma[18];\n\tint i;\n\n\tif (!ivb_need_sprite_gamma(plane_state))\n\t\treturn;\n\n\tivb_sprite_linear_gamma(plane_state, gamma);\n\n\t \n\tfor (i = 0; i < 16; i++)\n\t\tintel_de_write_fw(dev_priv, SPRGAMC(pipe, i),\n\t\t\t\t  gamma[i] << 20 | gamma[i] << 10 | gamma[i]);\n\n\tintel_de_write_fw(dev_priv, SPRGAMC16(pipe, 0), gamma[i]);\n\tintel_de_write_fw(dev_priv, SPRGAMC16(pipe, 1), gamma[i]);\n\tintel_de_write_fw(dev_priv, SPRGAMC16(pipe, 2), gamma[i]);\n\ti++;\n\n\tintel_de_write_fw(dev_priv, SPRGAMC17(pipe, 0), gamma[i]);\n\tintel_de_write_fw(dev_priv, SPRGAMC17(pipe, 1), gamma[i]);\n\tintel_de_write_fw(dev_priv, SPRGAMC17(pipe, 2), gamma[i]);\n\ti++;\n}\n\nstatic void\nivb_sprite_update_noarm(struct intel_plane *plane,\n\t\t\tconst struct intel_crtc_state *crtc_state,\n\t\t\tconst struct intel_plane_state *plane_state)\n{\n\tstruct drm_i915_private *dev_priv = to_i915(plane->base.dev);\n\tenum pipe pipe = plane->pipe;\n\tint crtc_x = plane_state->uapi.dst.x1;\n\tint crtc_y = plane_state->uapi.dst.y1;\n\tu32 crtc_w = drm_rect_width(&plane_state->uapi.dst);\n\tu32 crtc_h = drm_rect_height(&plane_state->uapi.dst);\n\tu32 src_w = drm_rect_width(&plane_state->uapi.src) >> 16;\n\tu32 src_h = drm_rect_height(&plane_state->uapi.src) >> 16;\n\tu32 sprscale = 0;\n\n\tif (crtc_w != src_w || crtc_h != src_h)\n\t\tsprscale = SPRITE_SCALE_ENABLE |\n\t\t\tSPRITE_SRC_WIDTH(src_w - 1) |\n\t\t\tSPRITE_SRC_HEIGHT(src_h - 1);\n\n\tintel_de_write_fw(dev_priv, SPRSTRIDE(pipe),\n\t\t\t  plane_state->view.color_plane[0].mapping_stride);\n\tintel_de_write_fw(dev_priv, SPRPOS(pipe),\n\t\t\t  SPRITE_POS_Y(crtc_y) | SPRITE_POS_X(crtc_x));\n\tintel_de_write_fw(dev_priv, SPRSIZE(pipe),\n\t\t\t  SPRITE_HEIGHT(crtc_h - 1) | SPRITE_WIDTH(crtc_w - 1));\n\tif (IS_IVYBRIDGE(dev_priv))\n\t\tintel_de_write_fw(dev_priv, SPRSCALE(pipe), sprscale);\n}\n\nstatic void\nivb_sprite_update_arm(struct intel_plane *plane,\n\t\t      const struct intel_crtc_state *crtc_state,\n\t\t      const struct intel_plane_state *plane_state)\n{\n\tstruct drm_i915_private *dev_priv = to_i915(plane->base.dev);\n\tenum pipe pipe = plane->pipe;\n\tconst struct drm_intel_sprite_colorkey *key = &plane_state->ckey;\n\tu32 sprsurf_offset = plane_state->view.color_plane[0].offset;\n\tu32 x = plane_state->view.color_plane[0].x;\n\tu32 y = plane_state->view.color_plane[0].y;\n\tu32 sprctl, linear_offset;\n\n\tsprctl = plane_state->ctl | ivb_sprite_ctl_crtc(crtc_state);\n\n\tlinear_offset = intel_fb_xy_to_linear(x, y, plane_state, 0);\n\n\tif (key->flags) {\n\t\tintel_de_write_fw(dev_priv, SPRKEYVAL(pipe), key->min_value);\n\t\tintel_de_write_fw(dev_priv, SPRKEYMSK(pipe),\n\t\t\t\t  key->channel_mask);\n\t\tintel_de_write_fw(dev_priv, SPRKEYMAX(pipe), key->max_value);\n\t}\n\n\t \n\tif (IS_HASWELL(dev_priv) || IS_BROADWELL(dev_priv)) {\n\t\tintel_de_write_fw(dev_priv, SPROFFSET(pipe),\n\t\t\t\t  SPRITE_OFFSET_Y(y) | SPRITE_OFFSET_X(x));\n\t} else {\n\t\tintel_de_write_fw(dev_priv, SPRLINOFF(pipe), linear_offset);\n\t\tintel_de_write_fw(dev_priv, SPRTILEOFF(pipe),\n\t\t\t\t  SPRITE_OFFSET_Y(y) | SPRITE_OFFSET_X(x));\n\t}\n\n\t \n\tintel_de_write_fw(dev_priv, SPRCTL(pipe), sprctl);\n\tintel_de_write_fw(dev_priv, SPRSURF(pipe),\n\t\t\t  intel_plane_ggtt_offset(plane_state) + sprsurf_offset);\n\n\tivb_sprite_update_gamma(plane_state);\n}\n\nstatic void\nivb_sprite_disable_arm(struct intel_plane *plane,\n\t\t       const struct intel_crtc_state *crtc_state)\n{\n\tstruct drm_i915_private *dev_priv = to_i915(plane->base.dev);\n\tenum pipe pipe = plane->pipe;\n\n\tintel_de_write_fw(dev_priv, SPRCTL(pipe), 0);\n\t \n\tif (IS_IVYBRIDGE(dev_priv))\n\t\tintel_de_write_fw(dev_priv, SPRSCALE(pipe), 0);\n\tintel_de_write_fw(dev_priv, SPRSURF(pipe), 0);\n}\n\nstatic bool\nivb_sprite_get_hw_state(struct intel_plane *plane,\n\t\t\tenum pipe *pipe)\n{\n\tstruct drm_i915_private *dev_priv = to_i915(plane->base.dev);\n\tenum intel_display_power_domain power_domain;\n\tintel_wakeref_t wakeref;\n\tbool ret;\n\n\tpower_domain = POWER_DOMAIN_PIPE(plane->pipe);\n\twakeref = intel_display_power_get_if_enabled(dev_priv, power_domain);\n\tif (!wakeref)\n\t\treturn false;\n\n\tret =  intel_de_read(dev_priv, SPRCTL(plane->pipe)) & SPRITE_ENABLE;\n\n\t*pipe = plane->pipe;\n\n\tintel_display_power_put(dev_priv, power_domain, wakeref);\n\n\treturn ret;\n}\n\nstatic int g4x_sprite_min_cdclk(const struct intel_crtc_state *crtc_state,\n\t\t\t\tconst struct intel_plane_state *plane_state)\n{\n\tconst struct drm_framebuffer *fb = plane_state->hw.fb;\n\tunsigned int hscale, pixel_rate;\n\tunsigned int limit, decimate;\n\n\t \n\tpixel_rate = crtc_state->pixel_rate;\n\n\t \n\thscale = drm_rect_calc_hscale(&plane_state->uapi.src,\n\t\t\t\t      &plane_state->uapi.dst,\n\t\t\t\t      0, INT_MAX);\n\thscale = max(hscale, 0x10000u);\n\n\t \n\tdecimate = ilog2(hscale >> 16);\n\thscale >>= decimate;\n\n\t \n\tlimit = 9;\n\n\t \n\tlimit -= decimate;\n\n\t \n\tif (!fb->format->is_yuv)\n\t\tlimit--;\n\n\t \n\n\treturn DIV_ROUND_UP_ULL(mul_u32_u32(pixel_rate, 10 * hscale),\n\t\t\t\tlimit << 16);\n}\n\nstatic unsigned int\ng4x_sprite_max_stride(struct intel_plane *plane,\n\t\t      u32 pixel_format, u64 modifier,\n\t\t      unsigned int rotation)\n{\n\tconst struct drm_format_info *info = drm_format_info(pixel_format);\n\tint cpp = info->cpp[0];\n\n\t \n\tif (modifier == I915_FORMAT_MOD_X_TILED)\n\t\treturn min(4096 * cpp, 16 * 1024);\n\telse\n\t\treturn 16 * 1024;\n}\n\nstatic unsigned int\nhsw_sprite_max_stride(struct intel_plane *plane,\n\t\t      u32 pixel_format, u64 modifier,\n\t\t      unsigned int rotation)\n{\n\tconst struct drm_format_info *info = drm_format_info(pixel_format);\n\tint cpp = info->cpp[0];\n\n\t \n\treturn min(8192 * cpp, 16 * 1024);\n}\n\nstatic u32 g4x_sprite_ctl_crtc(const struct intel_crtc_state *crtc_state)\n{\n\tu32 dvscntr = 0;\n\n\tif (crtc_state->gamma_enable)\n\t\tdvscntr |= DVS_PIPE_GAMMA_ENABLE;\n\n\tif (crtc_state->csc_enable)\n\t\tdvscntr |= DVS_PIPE_CSC_ENABLE;\n\n\treturn dvscntr;\n}\n\nstatic u32 g4x_sprite_ctl(const struct intel_crtc_state *crtc_state,\n\t\t\t  const struct intel_plane_state *plane_state)\n{\n\tstruct drm_i915_private *dev_priv =\n\t\tto_i915(plane_state->uapi.plane->dev);\n\tconst struct drm_framebuffer *fb = plane_state->hw.fb;\n\tunsigned int rotation = plane_state->hw.rotation;\n\tconst struct drm_intel_sprite_colorkey *key = &plane_state->ckey;\n\tu32 dvscntr;\n\n\tdvscntr = DVS_ENABLE;\n\n\tif (IS_SANDYBRIDGE(dev_priv))\n\t\tdvscntr |= DVS_TRICKLE_FEED_DISABLE;\n\n\tswitch (fb->format->format) {\n\tcase DRM_FORMAT_XBGR8888:\n\t\tdvscntr |= DVS_FORMAT_RGBX888 | DVS_RGB_ORDER_XBGR;\n\t\tbreak;\n\tcase DRM_FORMAT_XRGB8888:\n\t\tdvscntr |= DVS_FORMAT_RGBX888;\n\t\tbreak;\n\tcase DRM_FORMAT_XBGR2101010:\n\t\tdvscntr |= DVS_FORMAT_RGBX101010 | DVS_RGB_ORDER_XBGR;\n\t\tbreak;\n\tcase DRM_FORMAT_XRGB2101010:\n\t\tdvscntr |= DVS_FORMAT_RGBX101010;\n\t\tbreak;\n\tcase DRM_FORMAT_XBGR16161616F:\n\t\tdvscntr |= DVS_FORMAT_RGBX161616 | DVS_RGB_ORDER_XBGR;\n\t\tbreak;\n\tcase DRM_FORMAT_XRGB16161616F:\n\t\tdvscntr |= DVS_FORMAT_RGBX161616;\n\t\tbreak;\n\tcase DRM_FORMAT_YUYV:\n\t\tdvscntr |= DVS_FORMAT_YUV422 | DVS_YUV_ORDER_YUYV;\n\t\tbreak;\n\tcase DRM_FORMAT_YVYU:\n\t\tdvscntr |= DVS_FORMAT_YUV422 | DVS_YUV_ORDER_YVYU;\n\t\tbreak;\n\tcase DRM_FORMAT_UYVY:\n\t\tdvscntr |= DVS_FORMAT_YUV422 | DVS_YUV_ORDER_UYVY;\n\t\tbreak;\n\tcase DRM_FORMAT_VYUY:\n\t\tdvscntr |= DVS_FORMAT_YUV422 | DVS_YUV_ORDER_VYUY;\n\t\tbreak;\n\tdefault:\n\t\tMISSING_CASE(fb->format->format);\n\t\treturn 0;\n\t}\n\n\tif (plane_state->hw.color_encoding == DRM_COLOR_YCBCR_BT709)\n\t\tdvscntr |= DVS_YUV_FORMAT_BT709;\n\n\tif (plane_state->hw.color_range == DRM_COLOR_YCBCR_FULL_RANGE)\n\t\tdvscntr |= DVS_YUV_RANGE_CORRECTION_DISABLE;\n\n\tif (fb->modifier == I915_FORMAT_MOD_X_TILED)\n\t\tdvscntr |= DVS_TILED;\n\n\tif (rotation & DRM_MODE_ROTATE_180)\n\t\tdvscntr |= DVS_ROTATE_180;\n\n\tif (key->flags & I915_SET_COLORKEY_DESTINATION)\n\t\tdvscntr |= DVS_DEST_KEY;\n\telse if (key->flags & I915_SET_COLORKEY_SOURCE)\n\t\tdvscntr |= DVS_SOURCE_KEY;\n\n\treturn dvscntr;\n}\n\nstatic void g4x_sprite_update_gamma(const struct intel_plane_state *plane_state)\n{\n\tstruct intel_plane *plane = to_intel_plane(plane_state->uapi.plane);\n\tstruct drm_i915_private *dev_priv = to_i915(plane->base.dev);\n\tconst struct drm_framebuffer *fb = plane_state->hw.fb;\n\tenum pipe pipe = plane->pipe;\n\tu16 gamma[8];\n\tint i;\n\n\t \n\tif (!fb->format->is_yuv)\n\t\treturn;\n\n\ti9xx_plane_linear_gamma(gamma);\n\n\t \n\t \n\tfor (i = 1; i < 8 - 1; i++)\n\t\tintel_de_write_fw(dev_priv, DVSGAMC_G4X(pipe, i - 1),\n\t\t\t\t  gamma[i] << 16 | gamma[i] << 8 | gamma[i]);\n}\n\nstatic void ilk_sprite_linear_gamma(u16 gamma[17])\n{\n\tint i;\n\n\tfor (i = 0; i < 17; i++)\n\t\tgamma[i] = (i << 10) / 16;\n}\n\nstatic void ilk_sprite_update_gamma(const struct intel_plane_state *plane_state)\n{\n\tstruct intel_plane *plane = to_intel_plane(plane_state->uapi.plane);\n\tstruct drm_i915_private *dev_priv = to_i915(plane->base.dev);\n\tconst struct drm_framebuffer *fb = plane_state->hw.fb;\n\tenum pipe pipe = plane->pipe;\n\tu16 gamma[17];\n\tint i;\n\n\t \n\tif (!fb->format->is_yuv)\n\t\treturn;\n\n\tilk_sprite_linear_gamma(gamma);\n\n\t \n\tfor (i = 0; i < 16; i++)\n\t\tintel_de_write_fw(dev_priv, DVSGAMC_ILK(pipe, i),\n\t\t\t\t  gamma[i] << 20 | gamma[i] << 10 | gamma[i]);\n\n\tintel_de_write_fw(dev_priv, DVSGAMCMAX_ILK(pipe, 0), gamma[i]);\n\tintel_de_write_fw(dev_priv, DVSGAMCMAX_ILK(pipe, 1), gamma[i]);\n\tintel_de_write_fw(dev_priv, DVSGAMCMAX_ILK(pipe, 2), gamma[i]);\n\ti++;\n}\n\nstatic void\ng4x_sprite_update_noarm(struct intel_plane *plane,\n\t\t\tconst struct intel_crtc_state *crtc_state,\n\t\t\tconst struct intel_plane_state *plane_state)\n{\n\tstruct drm_i915_private *dev_priv = to_i915(plane->base.dev);\n\tenum pipe pipe = plane->pipe;\n\tint crtc_x = plane_state->uapi.dst.x1;\n\tint crtc_y = plane_state->uapi.dst.y1;\n\tu32 crtc_w = drm_rect_width(&plane_state->uapi.dst);\n\tu32 crtc_h = drm_rect_height(&plane_state->uapi.dst);\n\tu32 src_w = drm_rect_width(&plane_state->uapi.src) >> 16;\n\tu32 src_h = drm_rect_height(&plane_state->uapi.src) >> 16;\n\tu32 dvsscale = 0;\n\n\tif (crtc_w != src_w || crtc_h != src_h)\n\t\tdvsscale = DVS_SCALE_ENABLE |\n\t\t\tDVS_SRC_WIDTH(src_w - 1) |\n\t\t\tDVS_SRC_HEIGHT(src_h - 1);\n\n\tintel_de_write_fw(dev_priv, DVSSTRIDE(pipe),\n\t\t\t  plane_state->view.color_plane[0].mapping_stride);\n\tintel_de_write_fw(dev_priv, DVSPOS(pipe),\n\t\t\t  DVS_POS_Y(crtc_y) | DVS_POS_X(crtc_x));\n\tintel_de_write_fw(dev_priv, DVSSIZE(pipe),\n\t\t\t  DVS_HEIGHT(crtc_h - 1) | DVS_WIDTH(crtc_w - 1));\n\tintel_de_write_fw(dev_priv, DVSSCALE(pipe), dvsscale);\n}\n\nstatic void\ng4x_sprite_update_arm(struct intel_plane *plane,\n\t\t      const struct intel_crtc_state *crtc_state,\n\t\t      const struct intel_plane_state *plane_state)\n{\n\tstruct drm_i915_private *dev_priv = to_i915(plane->base.dev);\n\tenum pipe pipe = plane->pipe;\n\tconst struct drm_intel_sprite_colorkey *key = &plane_state->ckey;\n\tu32 dvssurf_offset = plane_state->view.color_plane[0].offset;\n\tu32 x = plane_state->view.color_plane[0].x;\n\tu32 y = plane_state->view.color_plane[0].y;\n\tu32 dvscntr, linear_offset;\n\n\tdvscntr = plane_state->ctl | g4x_sprite_ctl_crtc(crtc_state);\n\n\tlinear_offset = intel_fb_xy_to_linear(x, y, plane_state, 0);\n\n\tif (key->flags) {\n\t\tintel_de_write_fw(dev_priv, DVSKEYVAL(pipe), key->min_value);\n\t\tintel_de_write_fw(dev_priv, DVSKEYMSK(pipe),\n\t\t\t\t  key->channel_mask);\n\t\tintel_de_write_fw(dev_priv, DVSKEYMAX(pipe), key->max_value);\n\t}\n\n\tintel_de_write_fw(dev_priv, DVSLINOFF(pipe), linear_offset);\n\tintel_de_write_fw(dev_priv, DVSTILEOFF(pipe),\n\t\t\t  DVS_OFFSET_Y(y) | DVS_OFFSET_X(x));\n\n\t \n\tintel_de_write_fw(dev_priv, DVSCNTR(pipe), dvscntr);\n\tintel_de_write_fw(dev_priv, DVSSURF(pipe),\n\t\t\t  intel_plane_ggtt_offset(plane_state) + dvssurf_offset);\n\n\tif (IS_G4X(dev_priv))\n\t\tg4x_sprite_update_gamma(plane_state);\n\telse\n\t\tilk_sprite_update_gamma(plane_state);\n}\n\nstatic void\ng4x_sprite_disable_arm(struct intel_plane *plane,\n\t\t       const struct intel_crtc_state *crtc_state)\n{\n\tstruct drm_i915_private *dev_priv = to_i915(plane->base.dev);\n\tenum pipe pipe = plane->pipe;\n\n\tintel_de_write_fw(dev_priv, DVSCNTR(pipe), 0);\n\t \n\tintel_de_write_fw(dev_priv, DVSSCALE(pipe), 0);\n\tintel_de_write_fw(dev_priv, DVSSURF(pipe), 0);\n}\n\nstatic bool\ng4x_sprite_get_hw_state(struct intel_plane *plane,\n\t\t\tenum pipe *pipe)\n{\n\tstruct drm_i915_private *dev_priv = to_i915(plane->base.dev);\n\tenum intel_display_power_domain power_domain;\n\tintel_wakeref_t wakeref;\n\tbool ret;\n\n\tpower_domain = POWER_DOMAIN_PIPE(plane->pipe);\n\twakeref = intel_display_power_get_if_enabled(dev_priv, power_domain);\n\tif (!wakeref)\n\t\treturn false;\n\n\tret = intel_de_read(dev_priv, DVSCNTR(plane->pipe)) & DVS_ENABLE;\n\n\t*pipe = plane->pipe;\n\n\tintel_display_power_put(dev_priv, power_domain, wakeref);\n\n\treturn ret;\n}\n\nstatic bool g4x_fb_scalable(const struct drm_framebuffer *fb)\n{\n\tif (!fb)\n\t\treturn false;\n\n\tswitch (fb->format->format) {\n\tcase DRM_FORMAT_C8:\n\tcase DRM_FORMAT_XRGB16161616F:\n\tcase DRM_FORMAT_ARGB16161616F:\n\tcase DRM_FORMAT_XBGR16161616F:\n\tcase DRM_FORMAT_ABGR16161616F:\n\t\treturn false;\n\tdefault:\n\t\treturn true;\n\t}\n}\n\nstatic int\ng4x_sprite_check_scaling(struct intel_crtc_state *crtc_state,\n\t\t\t struct intel_plane_state *plane_state)\n{\n\tstruct drm_i915_private *i915 = to_i915(plane_state->uapi.plane->dev);\n\tconst struct drm_framebuffer *fb = plane_state->hw.fb;\n\tconst struct drm_rect *src = &plane_state->uapi.src;\n\tconst struct drm_rect *dst = &plane_state->uapi.dst;\n\tint src_x, src_w, src_h, crtc_w, crtc_h;\n\tconst struct drm_display_mode *adjusted_mode =\n\t\t&crtc_state->hw.adjusted_mode;\n\tunsigned int stride = plane_state->view.color_plane[0].mapping_stride;\n\tunsigned int cpp = fb->format->cpp[0];\n\tunsigned int width_bytes;\n\tint min_width, min_height;\n\n\tcrtc_w = drm_rect_width(dst);\n\tcrtc_h = drm_rect_height(dst);\n\n\tsrc_x = src->x1 >> 16;\n\tsrc_w = drm_rect_width(src) >> 16;\n\tsrc_h = drm_rect_height(src) >> 16;\n\n\tif (src_w == crtc_w && src_h == crtc_h)\n\t\treturn 0;\n\n\tmin_width = 3;\n\n\tif (adjusted_mode->flags & DRM_MODE_FLAG_INTERLACE) {\n\t\tif (src_h & 1) {\n\t\t\tdrm_dbg_kms(&i915->drm, \"Source height must be even with interlaced modes\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tmin_height = 6;\n\t} else {\n\t\tmin_height = 3;\n\t}\n\n\twidth_bytes = ((src_x * cpp) & 63) + src_w * cpp;\n\n\tif (src_w < min_width || src_h < min_height ||\n\t    src_w > 2048 || src_h > 2048) {\n\t\tdrm_dbg_kms(&i915->drm, \"Source dimensions (%dx%d) exceed hardware limits (%dx%d - %dx%d)\\n\",\n\t\t\t    src_w, src_h, min_width, min_height, 2048, 2048);\n\t\treturn -EINVAL;\n\t}\n\n\tif (width_bytes > 4096) {\n\t\tdrm_dbg_kms(&i915->drm, \"Fetch width (%d) exceeds hardware max with scaling (%u)\\n\",\n\t\t\t    width_bytes, 4096);\n\t\treturn -EINVAL;\n\t}\n\n\tif (stride > 4096) {\n\t\tdrm_dbg_kms(&i915->drm, \"Stride (%u) exceeds hardware max with scaling (%u)\\n\",\n\t\t\t    stride, 4096);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int\ng4x_sprite_check(struct intel_crtc_state *crtc_state,\n\t\t struct intel_plane_state *plane_state)\n{\n\tstruct intel_plane *plane = to_intel_plane(plane_state->uapi.plane);\n\tstruct drm_i915_private *dev_priv = to_i915(plane->base.dev);\n\tint min_scale = DRM_PLANE_NO_SCALING;\n\tint max_scale = DRM_PLANE_NO_SCALING;\n\tint ret;\n\n\tif (g4x_fb_scalable(plane_state->hw.fb)) {\n\t\tif (DISPLAY_VER(dev_priv) < 7) {\n\t\t\tmin_scale = 1;\n\t\t\tmax_scale = 16 << 16;\n\t\t} else if (IS_IVYBRIDGE(dev_priv)) {\n\t\t\tmin_scale = 1;\n\t\t\tmax_scale = 2 << 16;\n\t\t}\n\t}\n\n\tret = intel_atomic_plane_check_clipping(plane_state, crtc_state,\n\t\t\t\t\t\tmin_scale, max_scale, true);\n\tif (ret)\n\t\treturn ret;\n\n\tret = i9xx_check_plane_surface(plane_state);\n\tif (ret)\n\t\treturn ret;\n\n\tif (!plane_state->uapi.visible)\n\t\treturn 0;\n\n\tret = intel_plane_check_src_coordinates(plane_state);\n\tif (ret)\n\t\treturn ret;\n\n\tret = g4x_sprite_check_scaling(crtc_state, plane_state);\n\tif (ret)\n\t\treturn ret;\n\n\tif (DISPLAY_VER(dev_priv) >= 7)\n\t\tplane_state->ctl = ivb_sprite_ctl(crtc_state, plane_state);\n\telse\n\t\tplane_state->ctl = g4x_sprite_ctl(crtc_state, plane_state);\n\n\treturn 0;\n}\n\nint chv_plane_check_rotation(const struct intel_plane_state *plane_state)\n{\n\tstruct intel_plane *plane = to_intel_plane(plane_state->uapi.plane);\n\tstruct drm_i915_private *dev_priv = to_i915(plane->base.dev);\n\tunsigned int rotation = plane_state->hw.rotation;\n\n\t \n\tif (IS_CHERRYVIEW(dev_priv) &&\n\t    rotation & DRM_MODE_ROTATE_180 &&\n\t    rotation & DRM_MODE_REFLECT_X) {\n\t\tdrm_dbg_kms(&dev_priv->drm,\n\t\t\t    \"Cannot rotate and reflect at the same time\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int\nvlv_sprite_check(struct intel_crtc_state *crtc_state,\n\t\t struct intel_plane_state *plane_state)\n{\n\tint ret;\n\n\tret = chv_plane_check_rotation(plane_state);\n\tif (ret)\n\t\treturn ret;\n\n\tret = intel_atomic_plane_check_clipping(plane_state, crtc_state,\n\t\t\t\t\t\tDRM_PLANE_NO_SCALING,\n\t\t\t\t\t\tDRM_PLANE_NO_SCALING,\n\t\t\t\t\t\ttrue);\n\tif (ret)\n\t\treturn ret;\n\n\tret = i9xx_check_plane_surface(plane_state);\n\tif (ret)\n\t\treturn ret;\n\n\tif (!plane_state->uapi.visible)\n\t\treturn 0;\n\n\tret = intel_plane_check_src_coordinates(plane_state);\n\tif (ret)\n\t\treturn ret;\n\n\tplane_state->ctl = vlv_sprite_ctl(crtc_state, plane_state);\n\n\treturn 0;\n}\n\nstatic const u32 g4x_sprite_formats[] = {\n\tDRM_FORMAT_XRGB8888,\n\tDRM_FORMAT_YUYV,\n\tDRM_FORMAT_YVYU,\n\tDRM_FORMAT_UYVY,\n\tDRM_FORMAT_VYUY,\n};\n\nstatic const u32 snb_sprite_formats[] = {\n\tDRM_FORMAT_XRGB8888,\n\tDRM_FORMAT_XBGR8888,\n\tDRM_FORMAT_XRGB2101010,\n\tDRM_FORMAT_XBGR2101010,\n\tDRM_FORMAT_XRGB16161616F,\n\tDRM_FORMAT_XBGR16161616F,\n\tDRM_FORMAT_YUYV,\n\tDRM_FORMAT_YVYU,\n\tDRM_FORMAT_UYVY,\n\tDRM_FORMAT_VYUY,\n};\n\nstatic const u32 vlv_sprite_formats[] = {\n\tDRM_FORMAT_C8,\n\tDRM_FORMAT_RGB565,\n\tDRM_FORMAT_XRGB8888,\n\tDRM_FORMAT_XBGR8888,\n\tDRM_FORMAT_ARGB8888,\n\tDRM_FORMAT_ABGR8888,\n\tDRM_FORMAT_XBGR2101010,\n\tDRM_FORMAT_ABGR2101010,\n\tDRM_FORMAT_YUYV,\n\tDRM_FORMAT_YVYU,\n\tDRM_FORMAT_UYVY,\n\tDRM_FORMAT_VYUY,\n};\n\nstatic const u32 chv_pipe_b_sprite_formats[] = {\n\tDRM_FORMAT_C8,\n\tDRM_FORMAT_RGB565,\n\tDRM_FORMAT_XRGB8888,\n\tDRM_FORMAT_XBGR8888,\n\tDRM_FORMAT_ARGB8888,\n\tDRM_FORMAT_ABGR8888,\n\tDRM_FORMAT_XRGB2101010,\n\tDRM_FORMAT_XBGR2101010,\n\tDRM_FORMAT_ARGB2101010,\n\tDRM_FORMAT_ABGR2101010,\n\tDRM_FORMAT_YUYV,\n\tDRM_FORMAT_YVYU,\n\tDRM_FORMAT_UYVY,\n\tDRM_FORMAT_VYUY,\n};\n\nstatic bool g4x_sprite_format_mod_supported(struct drm_plane *_plane,\n\t\t\t\t\t    u32 format, u64 modifier)\n{\n\tif (!intel_fb_plane_supports_modifier(to_intel_plane(_plane), modifier))\n\t\treturn false;\n\n\tswitch (format) {\n\tcase DRM_FORMAT_XRGB8888:\n\tcase DRM_FORMAT_YUYV:\n\tcase DRM_FORMAT_YVYU:\n\tcase DRM_FORMAT_UYVY:\n\tcase DRM_FORMAT_VYUY:\n\t\tif (modifier == DRM_FORMAT_MOD_LINEAR ||\n\t\t    modifier == I915_FORMAT_MOD_X_TILED)\n\t\t\treturn true;\n\t\tfallthrough;\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nstatic bool snb_sprite_format_mod_supported(struct drm_plane *_plane,\n\t\t\t\t\t    u32 format, u64 modifier)\n{\n\tif (!intel_fb_plane_supports_modifier(to_intel_plane(_plane), modifier))\n\t\treturn false;\n\n\tswitch (format) {\n\tcase DRM_FORMAT_XRGB8888:\n\tcase DRM_FORMAT_XBGR8888:\n\tcase DRM_FORMAT_XRGB2101010:\n\tcase DRM_FORMAT_XBGR2101010:\n\tcase DRM_FORMAT_XRGB16161616F:\n\tcase DRM_FORMAT_XBGR16161616F:\n\tcase DRM_FORMAT_YUYV:\n\tcase DRM_FORMAT_YVYU:\n\tcase DRM_FORMAT_UYVY:\n\tcase DRM_FORMAT_VYUY:\n\t\tif (modifier == DRM_FORMAT_MOD_LINEAR ||\n\t\t    modifier == I915_FORMAT_MOD_X_TILED)\n\t\t\treturn true;\n\t\tfallthrough;\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nstatic bool vlv_sprite_format_mod_supported(struct drm_plane *_plane,\n\t\t\t\t\t    u32 format, u64 modifier)\n{\n\tif (!intel_fb_plane_supports_modifier(to_intel_plane(_plane), modifier))\n\t\treturn false;\n\n\tswitch (format) {\n\tcase DRM_FORMAT_C8:\n\tcase DRM_FORMAT_RGB565:\n\tcase DRM_FORMAT_ABGR8888:\n\tcase DRM_FORMAT_ARGB8888:\n\tcase DRM_FORMAT_XBGR8888:\n\tcase DRM_FORMAT_XRGB8888:\n\tcase DRM_FORMAT_XBGR2101010:\n\tcase DRM_FORMAT_ABGR2101010:\n\tcase DRM_FORMAT_XRGB2101010:\n\tcase DRM_FORMAT_ARGB2101010:\n\tcase DRM_FORMAT_YUYV:\n\tcase DRM_FORMAT_YVYU:\n\tcase DRM_FORMAT_UYVY:\n\tcase DRM_FORMAT_VYUY:\n\t\tif (modifier == DRM_FORMAT_MOD_LINEAR ||\n\t\t    modifier == I915_FORMAT_MOD_X_TILED)\n\t\t\treturn true;\n\t\tfallthrough;\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nstatic const struct drm_plane_funcs g4x_sprite_funcs = {\n\t.update_plane = drm_atomic_helper_update_plane,\n\t.disable_plane = drm_atomic_helper_disable_plane,\n\t.destroy = intel_plane_destroy,\n\t.atomic_duplicate_state = intel_plane_duplicate_state,\n\t.atomic_destroy_state = intel_plane_destroy_state,\n\t.format_mod_supported = g4x_sprite_format_mod_supported,\n};\n\nstatic const struct drm_plane_funcs snb_sprite_funcs = {\n\t.update_plane = drm_atomic_helper_update_plane,\n\t.disable_plane = drm_atomic_helper_disable_plane,\n\t.destroy = intel_plane_destroy,\n\t.atomic_duplicate_state = intel_plane_duplicate_state,\n\t.atomic_destroy_state = intel_plane_destroy_state,\n\t.format_mod_supported = snb_sprite_format_mod_supported,\n};\n\nstatic const struct drm_plane_funcs vlv_sprite_funcs = {\n\t.update_plane = drm_atomic_helper_update_plane,\n\t.disable_plane = drm_atomic_helper_disable_plane,\n\t.destroy = intel_plane_destroy,\n\t.atomic_duplicate_state = intel_plane_duplicate_state,\n\t.atomic_destroy_state = intel_plane_destroy_state,\n\t.format_mod_supported = vlv_sprite_format_mod_supported,\n};\n\nstruct intel_plane *\nintel_sprite_plane_create(struct drm_i915_private *dev_priv,\n\t\t\t  enum pipe pipe, int sprite)\n{\n\tstruct intel_plane *plane;\n\tconst struct drm_plane_funcs *plane_funcs;\n\tunsigned int supported_rotations;\n\tconst u64 *modifiers;\n\tconst u32 *formats;\n\tint num_formats;\n\tint ret, zpos;\n\n\tplane = intel_plane_alloc();\n\tif (IS_ERR(plane))\n\t\treturn plane;\n\n\tif (IS_VALLEYVIEW(dev_priv) || IS_CHERRYVIEW(dev_priv)) {\n\t\tplane->update_noarm = vlv_sprite_update_noarm;\n\t\tplane->update_arm = vlv_sprite_update_arm;\n\t\tplane->disable_arm = vlv_sprite_disable_arm;\n\t\tplane->get_hw_state = vlv_sprite_get_hw_state;\n\t\tplane->check_plane = vlv_sprite_check;\n\t\tplane->max_stride = i965_plane_max_stride;\n\t\tplane->min_cdclk = vlv_plane_min_cdclk;\n\n\t\tif (IS_CHERRYVIEW(dev_priv) && pipe == PIPE_B) {\n\t\t\tformats = chv_pipe_b_sprite_formats;\n\t\t\tnum_formats = ARRAY_SIZE(chv_pipe_b_sprite_formats);\n\t\t} else {\n\t\t\tformats = vlv_sprite_formats;\n\t\t\tnum_formats = ARRAY_SIZE(vlv_sprite_formats);\n\t\t}\n\n\t\tplane_funcs = &vlv_sprite_funcs;\n\t} else if (DISPLAY_VER(dev_priv) >= 7) {\n\t\tplane->update_noarm = ivb_sprite_update_noarm;\n\t\tplane->update_arm = ivb_sprite_update_arm;\n\t\tplane->disable_arm = ivb_sprite_disable_arm;\n\t\tplane->get_hw_state = ivb_sprite_get_hw_state;\n\t\tplane->check_plane = g4x_sprite_check;\n\n\t\tif (IS_BROADWELL(dev_priv) || IS_HASWELL(dev_priv)) {\n\t\t\tplane->max_stride = hsw_sprite_max_stride;\n\t\t\tplane->min_cdclk = hsw_plane_min_cdclk;\n\t\t} else {\n\t\t\tplane->max_stride = g4x_sprite_max_stride;\n\t\t\tplane->min_cdclk = ivb_sprite_min_cdclk;\n\t\t}\n\n\t\tformats = snb_sprite_formats;\n\t\tnum_formats = ARRAY_SIZE(snb_sprite_formats);\n\n\t\tplane_funcs = &snb_sprite_funcs;\n\t} else {\n\t\tplane->update_noarm = g4x_sprite_update_noarm;\n\t\tplane->update_arm = g4x_sprite_update_arm;\n\t\tplane->disable_arm = g4x_sprite_disable_arm;\n\t\tplane->get_hw_state = g4x_sprite_get_hw_state;\n\t\tplane->check_plane = g4x_sprite_check;\n\t\tplane->max_stride = g4x_sprite_max_stride;\n\t\tplane->min_cdclk = g4x_sprite_min_cdclk;\n\n\t\tif (IS_SANDYBRIDGE(dev_priv)) {\n\t\t\tformats = snb_sprite_formats;\n\t\t\tnum_formats = ARRAY_SIZE(snb_sprite_formats);\n\n\t\t\tplane_funcs = &snb_sprite_funcs;\n\t\t} else {\n\t\t\tformats = g4x_sprite_formats;\n\t\t\tnum_formats = ARRAY_SIZE(g4x_sprite_formats);\n\n\t\t\tplane_funcs = &g4x_sprite_funcs;\n\t\t}\n\t}\n\n\tif (IS_CHERRYVIEW(dev_priv) && pipe == PIPE_B) {\n\t\tsupported_rotations =\n\t\t\tDRM_MODE_ROTATE_0 | DRM_MODE_ROTATE_180 |\n\t\t\tDRM_MODE_REFLECT_X;\n\t} else {\n\t\tsupported_rotations =\n\t\t\tDRM_MODE_ROTATE_0 | DRM_MODE_ROTATE_180;\n\t}\n\n\tplane->pipe = pipe;\n\tplane->id = PLANE_SPRITE0 + sprite;\n\tplane->frontbuffer_bit = INTEL_FRONTBUFFER(pipe, plane->id);\n\n\tmodifiers = intel_fb_plane_get_modifiers(dev_priv, INTEL_PLANE_CAP_TILING_X);\n\n\tret = drm_universal_plane_init(&dev_priv->drm, &plane->base,\n\t\t\t\t       0, plane_funcs,\n\t\t\t\t       formats, num_formats, modifiers,\n\t\t\t\t       DRM_PLANE_TYPE_OVERLAY,\n\t\t\t\t       \"sprite %c\", sprite_name(pipe, sprite));\n\tkfree(modifiers);\n\n\tif (ret)\n\t\tgoto fail;\n\n\tdrm_plane_create_rotation_property(&plane->base,\n\t\t\t\t\t   DRM_MODE_ROTATE_0,\n\t\t\t\t\t   supported_rotations);\n\n\tdrm_plane_create_color_properties(&plane->base,\n\t\t\t\t\t  BIT(DRM_COLOR_YCBCR_BT601) |\n\t\t\t\t\t  BIT(DRM_COLOR_YCBCR_BT709),\n\t\t\t\t\t  BIT(DRM_COLOR_YCBCR_LIMITED_RANGE) |\n\t\t\t\t\t  BIT(DRM_COLOR_YCBCR_FULL_RANGE),\n\t\t\t\t\t  DRM_COLOR_YCBCR_BT709,\n\t\t\t\t\t  DRM_COLOR_YCBCR_LIMITED_RANGE);\n\n\tzpos = sprite + 1;\n\tdrm_plane_create_zpos_immutable_property(&plane->base, zpos);\n\n\tintel_plane_helper_add(plane);\n\n\treturn plane;\n\nfail:\n\tintel_plane_free(plane);\n\n\treturn ERR_PTR(ret);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}