{
  "module_name": "intel_hdmi.c",
  "hash_id": "e0bc2e225d1f05fad2d866a1bd0de3e59c53a0b97095c95829033d74762c3cc7",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/i915/display/intel_hdmi.c",
  "human_readable_source": " \n\n#include <linux/delay.h>\n#include <linux/hdmi.h>\n#include <linux/i2c.h>\n#include <linux/slab.h>\n#include <linux/string_helpers.h>\n\n#include <drm/display/drm_hdcp_helper.h>\n#include <drm/display/drm_hdmi_helper.h>\n#include <drm/display/drm_scdc_helper.h>\n#include <drm/drm_atomic_helper.h>\n#include <drm/drm_crtc.h>\n#include <drm/drm_edid.h>\n#include <drm/intel_lpe_audio.h>\n\n#include \"g4x_hdmi.h\"\n#include \"i915_drv.h\"\n#include \"i915_reg.h\"\n#include \"intel_atomic.h\"\n#include \"intel_audio.h\"\n#include \"intel_connector.h\"\n#include \"intel_cx0_phy.h\"\n#include \"intel_ddi.h\"\n#include \"intel_de.h\"\n#include \"intel_display_types.h\"\n#include \"intel_dp.h\"\n#include \"intel_gmbus.h\"\n#include \"intel_hdcp.h\"\n#include \"intel_hdcp_regs.h\"\n#include \"intel_hdmi.h\"\n#include \"intel_lspcon.h\"\n#include \"intel_panel.h\"\n#include \"intel_snps_phy.h\"\n\ninline struct drm_i915_private *intel_hdmi_to_i915(struct intel_hdmi *intel_hdmi)\n{\n\treturn to_i915(hdmi_to_dig_port(intel_hdmi)->base.base.dev);\n}\n\nstatic void\nassert_hdmi_port_disabled(struct intel_hdmi *intel_hdmi)\n{\n\tstruct drm_i915_private *dev_priv = intel_hdmi_to_i915(intel_hdmi);\n\tu32 enabled_bits;\n\n\tenabled_bits = HAS_DDI(dev_priv) ? DDI_BUF_CTL_ENABLE : SDVO_ENABLE;\n\n\tdrm_WARN(&dev_priv->drm,\n\t\t intel_de_read(dev_priv, intel_hdmi->hdmi_reg) & enabled_bits,\n\t\t \"HDMI port enabled, expecting disabled\\n\");\n}\n\nstatic void\nassert_hdmi_transcoder_func_disabled(struct drm_i915_private *dev_priv,\n\t\t\t\t     enum transcoder cpu_transcoder)\n{\n\tdrm_WARN(&dev_priv->drm,\n\t\t intel_de_read(dev_priv, TRANS_DDI_FUNC_CTL(cpu_transcoder)) &\n\t\t TRANS_DDI_FUNC_ENABLE,\n\t\t \"HDMI transcoder function enabled, expecting disabled\\n\");\n}\n\nstatic u32 g4x_infoframe_index(unsigned int type)\n{\n\tswitch (type) {\n\tcase HDMI_PACKET_TYPE_GAMUT_METADATA:\n\t\treturn VIDEO_DIP_SELECT_GAMUT;\n\tcase HDMI_INFOFRAME_TYPE_AVI:\n\t\treturn VIDEO_DIP_SELECT_AVI;\n\tcase HDMI_INFOFRAME_TYPE_SPD:\n\t\treturn VIDEO_DIP_SELECT_SPD;\n\tcase HDMI_INFOFRAME_TYPE_VENDOR:\n\t\treturn VIDEO_DIP_SELECT_VENDOR;\n\tdefault:\n\t\tMISSING_CASE(type);\n\t\treturn 0;\n\t}\n}\n\nstatic u32 g4x_infoframe_enable(unsigned int type)\n{\n\tswitch (type) {\n\tcase HDMI_PACKET_TYPE_GENERAL_CONTROL:\n\t\treturn VIDEO_DIP_ENABLE_GCP;\n\tcase HDMI_PACKET_TYPE_GAMUT_METADATA:\n\t\treturn VIDEO_DIP_ENABLE_GAMUT;\n\tcase DP_SDP_VSC:\n\t\treturn 0;\n\tcase HDMI_INFOFRAME_TYPE_AVI:\n\t\treturn VIDEO_DIP_ENABLE_AVI;\n\tcase HDMI_INFOFRAME_TYPE_SPD:\n\t\treturn VIDEO_DIP_ENABLE_SPD;\n\tcase HDMI_INFOFRAME_TYPE_VENDOR:\n\t\treturn VIDEO_DIP_ENABLE_VENDOR;\n\tcase HDMI_INFOFRAME_TYPE_DRM:\n\t\treturn 0;\n\tdefault:\n\t\tMISSING_CASE(type);\n\t\treturn 0;\n\t}\n}\n\nstatic u32 hsw_infoframe_enable(unsigned int type)\n{\n\tswitch (type) {\n\tcase HDMI_PACKET_TYPE_GENERAL_CONTROL:\n\t\treturn VIDEO_DIP_ENABLE_GCP_HSW;\n\tcase HDMI_PACKET_TYPE_GAMUT_METADATA:\n\t\treturn VIDEO_DIP_ENABLE_GMP_HSW;\n\tcase DP_SDP_VSC:\n\t\treturn VIDEO_DIP_ENABLE_VSC_HSW;\n\tcase DP_SDP_PPS:\n\t\treturn VDIP_ENABLE_PPS;\n\tcase HDMI_INFOFRAME_TYPE_AVI:\n\t\treturn VIDEO_DIP_ENABLE_AVI_HSW;\n\tcase HDMI_INFOFRAME_TYPE_SPD:\n\t\treturn VIDEO_DIP_ENABLE_SPD_HSW;\n\tcase HDMI_INFOFRAME_TYPE_VENDOR:\n\t\treturn VIDEO_DIP_ENABLE_VS_HSW;\n\tcase HDMI_INFOFRAME_TYPE_DRM:\n\t\treturn VIDEO_DIP_ENABLE_DRM_GLK;\n\tdefault:\n\t\tMISSING_CASE(type);\n\t\treturn 0;\n\t}\n}\n\nstatic i915_reg_t\nhsw_dip_data_reg(struct drm_i915_private *dev_priv,\n\t\t enum transcoder cpu_transcoder,\n\t\t unsigned int type,\n\t\t int i)\n{\n\tswitch (type) {\n\tcase HDMI_PACKET_TYPE_GAMUT_METADATA:\n\t\treturn HSW_TVIDEO_DIP_GMP_DATA(cpu_transcoder, i);\n\tcase DP_SDP_VSC:\n\t\treturn HSW_TVIDEO_DIP_VSC_DATA(cpu_transcoder, i);\n\tcase DP_SDP_PPS:\n\t\treturn ICL_VIDEO_DIP_PPS_DATA(cpu_transcoder, i);\n\tcase HDMI_INFOFRAME_TYPE_AVI:\n\t\treturn HSW_TVIDEO_DIP_AVI_DATA(cpu_transcoder, i);\n\tcase HDMI_INFOFRAME_TYPE_SPD:\n\t\treturn HSW_TVIDEO_DIP_SPD_DATA(cpu_transcoder, i);\n\tcase HDMI_INFOFRAME_TYPE_VENDOR:\n\t\treturn HSW_TVIDEO_DIP_VS_DATA(cpu_transcoder, i);\n\tcase HDMI_INFOFRAME_TYPE_DRM:\n\t\treturn GLK_TVIDEO_DIP_DRM_DATA(cpu_transcoder, i);\n\tdefault:\n\t\tMISSING_CASE(type);\n\t\treturn INVALID_MMIO_REG;\n\t}\n}\n\nstatic int hsw_dip_data_size(struct drm_i915_private *dev_priv,\n\t\t\t     unsigned int type)\n{\n\tswitch (type) {\n\tcase DP_SDP_VSC:\n\t\treturn VIDEO_DIP_VSC_DATA_SIZE;\n\tcase DP_SDP_PPS:\n\t\treturn VIDEO_DIP_PPS_DATA_SIZE;\n\tcase HDMI_PACKET_TYPE_GAMUT_METADATA:\n\t\tif (DISPLAY_VER(dev_priv) >= 11)\n\t\t\treturn VIDEO_DIP_GMP_DATA_SIZE;\n\t\telse\n\t\t\treturn VIDEO_DIP_DATA_SIZE;\n\tdefault:\n\t\treturn VIDEO_DIP_DATA_SIZE;\n\t}\n}\n\nstatic void g4x_write_infoframe(struct intel_encoder *encoder,\n\t\t\t\tconst struct intel_crtc_state *crtc_state,\n\t\t\t\tunsigned int type,\n\t\t\t\tconst void *frame, ssize_t len)\n{\n\tconst u32 *data = frame;\n\tstruct drm_i915_private *dev_priv = to_i915(encoder->base.dev);\n\tu32 val = intel_de_read(dev_priv, VIDEO_DIP_CTL);\n\tint i;\n\n\tdrm_WARN(&dev_priv->drm, !(val & VIDEO_DIP_ENABLE),\n\t\t \"Writing DIP with CTL reg disabled\\n\");\n\n\tval &= ~(VIDEO_DIP_SELECT_MASK | 0xf);  \n\tval |= g4x_infoframe_index(type);\n\n\tval &= ~g4x_infoframe_enable(type);\n\n\tintel_de_write(dev_priv, VIDEO_DIP_CTL, val);\n\n\tfor (i = 0; i < len; i += 4) {\n\t\tintel_de_write(dev_priv, VIDEO_DIP_DATA, *data);\n\t\tdata++;\n\t}\n\t \n\tfor (; i < VIDEO_DIP_DATA_SIZE; i += 4)\n\t\tintel_de_write(dev_priv, VIDEO_DIP_DATA, 0);\n\n\tval |= g4x_infoframe_enable(type);\n\tval &= ~VIDEO_DIP_FREQ_MASK;\n\tval |= VIDEO_DIP_FREQ_VSYNC;\n\n\tintel_de_write(dev_priv, VIDEO_DIP_CTL, val);\n\tintel_de_posting_read(dev_priv, VIDEO_DIP_CTL);\n}\n\nstatic void g4x_read_infoframe(struct intel_encoder *encoder,\n\t\t\t       const struct intel_crtc_state *crtc_state,\n\t\t\t       unsigned int type,\n\t\t\t       void *frame, ssize_t len)\n{\n\tstruct drm_i915_private *dev_priv = to_i915(encoder->base.dev);\n\tu32 *data = frame;\n\tint i;\n\n\tintel_de_rmw(dev_priv, VIDEO_DIP_CTL,\n\t\t     VIDEO_DIP_SELECT_MASK | 0xf, g4x_infoframe_index(type));\n\n\tfor (i = 0; i < len; i += 4)\n\t\t*data++ = intel_de_read(dev_priv, VIDEO_DIP_DATA);\n}\n\nstatic u32 g4x_infoframes_enabled(struct intel_encoder *encoder,\n\t\t\t\t  const struct intel_crtc_state *pipe_config)\n{\n\tstruct drm_i915_private *dev_priv = to_i915(encoder->base.dev);\n\tu32 val = intel_de_read(dev_priv, VIDEO_DIP_CTL);\n\n\tif ((val & VIDEO_DIP_ENABLE) == 0)\n\t\treturn 0;\n\n\tif ((val & VIDEO_DIP_PORT_MASK) != VIDEO_DIP_PORT(encoder->port))\n\t\treturn 0;\n\n\treturn val & (VIDEO_DIP_ENABLE_AVI |\n\t\t      VIDEO_DIP_ENABLE_VENDOR | VIDEO_DIP_ENABLE_SPD);\n}\n\nstatic void ibx_write_infoframe(struct intel_encoder *encoder,\n\t\t\t\tconst struct intel_crtc_state *crtc_state,\n\t\t\t\tunsigned int type,\n\t\t\t\tconst void *frame, ssize_t len)\n{\n\tconst u32 *data = frame;\n\tstruct drm_i915_private *dev_priv = to_i915(encoder->base.dev);\n\tstruct intel_crtc *crtc = to_intel_crtc(crtc_state->uapi.crtc);\n\ti915_reg_t reg = TVIDEO_DIP_CTL(crtc->pipe);\n\tu32 val = intel_de_read(dev_priv, reg);\n\tint i;\n\n\tdrm_WARN(&dev_priv->drm, !(val & VIDEO_DIP_ENABLE),\n\t\t \"Writing DIP with CTL reg disabled\\n\");\n\n\tval &= ~(VIDEO_DIP_SELECT_MASK | 0xf);  \n\tval |= g4x_infoframe_index(type);\n\n\tval &= ~g4x_infoframe_enable(type);\n\n\tintel_de_write(dev_priv, reg, val);\n\n\tfor (i = 0; i < len; i += 4) {\n\t\tintel_de_write(dev_priv, TVIDEO_DIP_DATA(crtc->pipe),\n\t\t\t       *data);\n\t\tdata++;\n\t}\n\t \n\tfor (; i < VIDEO_DIP_DATA_SIZE; i += 4)\n\t\tintel_de_write(dev_priv, TVIDEO_DIP_DATA(crtc->pipe), 0);\n\n\tval |= g4x_infoframe_enable(type);\n\tval &= ~VIDEO_DIP_FREQ_MASK;\n\tval |= VIDEO_DIP_FREQ_VSYNC;\n\n\tintel_de_write(dev_priv, reg, val);\n\tintel_de_posting_read(dev_priv, reg);\n}\n\nstatic void ibx_read_infoframe(struct intel_encoder *encoder,\n\t\t\t       const struct intel_crtc_state *crtc_state,\n\t\t\t       unsigned int type,\n\t\t\t       void *frame, ssize_t len)\n{\n\tstruct drm_i915_private *dev_priv = to_i915(encoder->base.dev);\n\tstruct intel_crtc *crtc = to_intel_crtc(crtc_state->uapi.crtc);\n\tu32 *data = frame;\n\tint i;\n\n\tintel_de_rmw(dev_priv, TVIDEO_DIP_CTL(crtc->pipe),\n\t\t     VIDEO_DIP_SELECT_MASK | 0xf, g4x_infoframe_index(type));\n\n\tfor (i = 0; i < len; i += 4)\n\t\t*data++ = intel_de_read(dev_priv, TVIDEO_DIP_DATA(crtc->pipe));\n}\n\nstatic u32 ibx_infoframes_enabled(struct intel_encoder *encoder,\n\t\t\t\t  const struct intel_crtc_state *pipe_config)\n{\n\tstruct drm_i915_private *dev_priv = to_i915(encoder->base.dev);\n\tenum pipe pipe = to_intel_crtc(pipe_config->uapi.crtc)->pipe;\n\ti915_reg_t reg = TVIDEO_DIP_CTL(pipe);\n\tu32 val = intel_de_read(dev_priv, reg);\n\n\tif ((val & VIDEO_DIP_ENABLE) == 0)\n\t\treturn 0;\n\n\tif ((val & VIDEO_DIP_PORT_MASK) != VIDEO_DIP_PORT(encoder->port))\n\t\treturn 0;\n\n\treturn val & (VIDEO_DIP_ENABLE_AVI |\n\t\t      VIDEO_DIP_ENABLE_VENDOR | VIDEO_DIP_ENABLE_GAMUT |\n\t\t      VIDEO_DIP_ENABLE_SPD | VIDEO_DIP_ENABLE_GCP);\n}\n\nstatic void cpt_write_infoframe(struct intel_encoder *encoder,\n\t\t\t\tconst struct intel_crtc_state *crtc_state,\n\t\t\t\tunsigned int type,\n\t\t\t\tconst void *frame, ssize_t len)\n{\n\tconst u32 *data = frame;\n\tstruct drm_i915_private *dev_priv = to_i915(encoder->base.dev);\n\tstruct intel_crtc *crtc = to_intel_crtc(crtc_state->uapi.crtc);\n\ti915_reg_t reg = TVIDEO_DIP_CTL(crtc->pipe);\n\tu32 val = intel_de_read(dev_priv, reg);\n\tint i;\n\n\tdrm_WARN(&dev_priv->drm, !(val & VIDEO_DIP_ENABLE),\n\t\t \"Writing DIP with CTL reg disabled\\n\");\n\n\tval &= ~(VIDEO_DIP_SELECT_MASK | 0xf);  \n\tval |= g4x_infoframe_index(type);\n\n\t \n\tif (type != HDMI_INFOFRAME_TYPE_AVI)\n\t\tval &= ~g4x_infoframe_enable(type);\n\n\tintel_de_write(dev_priv, reg, val);\n\n\tfor (i = 0; i < len; i += 4) {\n\t\tintel_de_write(dev_priv, TVIDEO_DIP_DATA(crtc->pipe),\n\t\t\t       *data);\n\t\tdata++;\n\t}\n\t \n\tfor (; i < VIDEO_DIP_DATA_SIZE; i += 4)\n\t\tintel_de_write(dev_priv, TVIDEO_DIP_DATA(crtc->pipe), 0);\n\n\tval |= g4x_infoframe_enable(type);\n\tval &= ~VIDEO_DIP_FREQ_MASK;\n\tval |= VIDEO_DIP_FREQ_VSYNC;\n\n\tintel_de_write(dev_priv, reg, val);\n\tintel_de_posting_read(dev_priv, reg);\n}\n\nstatic void cpt_read_infoframe(struct intel_encoder *encoder,\n\t\t\t       const struct intel_crtc_state *crtc_state,\n\t\t\t       unsigned int type,\n\t\t\t       void *frame, ssize_t len)\n{\n\tstruct drm_i915_private *dev_priv = to_i915(encoder->base.dev);\n\tstruct intel_crtc *crtc = to_intel_crtc(crtc_state->uapi.crtc);\n\tu32 *data = frame;\n\tint i;\n\n\tintel_de_rmw(dev_priv, TVIDEO_DIP_CTL(crtc->pipe),\n\t\t     VIDEO_DIP_SELECT_MASK | 0xf, g4x_infoframe_index(type));\n\n\tfor (i = 0; i < len; i += 4)\n\t\t*data++ = intel_de_read(dev_priv, TVIDEO_DIP_DATA(crtc->pipe));\n}\n\nstatic u32 cpt_infoframes_enabled(struct intel_encoder *encoder,\n\t\t\t\t  const struct intel_crtc_state *pipe_config)\n{\n\tstruct drm_i915_private *dev_priv = to_i915(encoder->base.dev);\n\tenum pipe pipe = to_intel_crtc(pipe_config->uapi.crtc)->pipe;\n\tu32 val = intel_de_read(dev_priv, TVIDEO_DIP_CTL(pipe));\n\n\tif ((val & VIDEO_DIP_ENABLE) == 0)\n\t\treturn 0;\n\n\treturn val & (VIDEO_DIP_ENABLE_AVI |\n\t\t      VIDEO_DIP_ENABLE_VENDOR | VIDEO_DIP_ENABLE_GAMUT |\n\t\t      VIDEO_DIP_ENABLE_SPD | VIDEO_DIP_ENABLE_GCP);\n}\n\nstatic void vlv_write_infoframe(struct intel_encoder *encoder,\n\t\t\t\tconst struct intel_crtc_state *crtc_state,\n\t\t\t\tunsigned int type,\n\t\t\t\tconst void *frame, ssize_t len)\n{\n\tconst u32 *data = frame;\n\tstruct drm_i915_private *dev_priv = to_i915(encoder->base.dev);\n\tstruct intel_crtc *crtc = to_intel_crtc(crtc_state->uapi.crtc);\n\ti915_reg_t reg = VLV_TVIDEO_DIP_CTL(crtc->pipe);\n\tu32 val = intel_de_read(dev_priv, reg);\n\tint i;\n\n\tdrm_WARN(&dev_priv->drm, !(val & VIDEO_DIP_ENABLE),\n\t\t \"Writing DIP with CTL reg disabled\\n\");\n\n\tval &= ~(VIDEO_DIP_SELECT_MASK | 0xf);  \n\tval |= g4x_infoframe_index(type);\n\n\tval &= ~g4x_infoframe_enable(type);\n\n\tintel_de_write(dev_priv, reg, val);\n\n\tfor (i = 0; i < len; i += 4) {\n\t\tintel_de_write(dev_priv,\n\t\t\t       VLV_TVIDEO_DIP_DATA(crtc->pipe), *data);\n\t\tdata++;\n\t}\n\t \n\tfor (; i < VIDEO_DIP_DATA_SIZE; i += 4)\n\t\tintel_de_write(dev_priv,\n\t\t\t       VLV_TVIDEO_DIP_DATA(crtc->pipe), 0);\n\n\tval |= g4x_infoframe_enable(type);\n\tval &= ~VIDEO_DIP_FREQ_MASK;\n\tval |= VIDEO_DIP_FREQ_VSYNC;\n\n\tintel_de_write(dev_priv, reg, val);\n\tintel_de_posting_read(dev_priv, reg);\n}\n\nstatic void vlv_read_infoframe(struct intel_encoder *encoder,\n\t\t\t       const struct intel_crtc_state *crtc_state,\n\t\t\t       unsigned int type,\n\t\t\t       void *frame, ssize_t len)\n{\n\tstruct drm_i915_private *dev_priv = to_i915(encoder->base.dev);\n\tstruct intel_crtc *crtc = to_intel_crtc(crtc_state->uapi.crtc);\n\tu32 *data = frame;\n\tint i;\n\n\tintel_de_rmw(dev_priv, VLV_TVIDEO_DIP_CTL(crtc->pipe),\n\t\t     VIDEO_DIP_SELECT_MASK | 0xf, g4x_infoframe_index(type));\n\n\tfor (i = 0; i < len; i += 4)\n\t\t*data++ = intel_de_read(dev_priv,\n\t\t\t\t        VLV_TVIDEO_DIP_DATA(crtc->pipe));\n}\n\nstatic u32 vlv_infoframes_enabled(struct intel_encoder *encoder,\n\t\t\t\t  const struct intel_crtc_state *pipe_config)\n{\n\tstruct drm_i915_private *dev_priv = to_i915(encoder->base.dev);\n\tenum pipe pipe = to_intel_crtc(pipe_config->uapi.crtc)->pipe;\n\tu32 val = intel_de_read(dev_priv, VLV_TVIDEO_DIP_CTL(pipe));\n\n\tif ((val & VIDEO_DIP_ENABLE) == 0)\n\t\treturn 0;\n\n\tif ((val & VIDEO_DIP_PORT_MASK) != VIDEO_DIP_PORT(encoder->port))\n\t\treturn 0;\n\n\treturn val & (VIDEO_DIP_ENABLE_AVI |\n\t\t      VIDEO_DIP_ENABLE_VENDOR | VIDEO_DIP_ENABLE_GAMUT |\n\t\t      VIDEO_DIP_ENABLE_SPD | VIDEO_DIP_ENABLE_GCP);\n}\n\nvoid hsw_write_infoframe(struct intel_encoder *encoder,\n\t\t\t const struct intel_crtc_state *crtc_state,\n\t\t\t unsigned int type,\n\t\t\t const void *frame, ssize_t len)\n{\n\tconst u32 *data = frame;\n\tstruct drm_i915_private *dev_priv = to_i915(encoder->base.dev);\n\tenum transcoder cpu_transcoder = crtc_state->cpu_transcoder;\n\ti915_reg_t ctl_reg = HSW_TVIDEO_DIP_CTL(cpu_transcoder);\n\tint data_size;\n\tint i;\n\tu32 val = intel_de_read(dev_priv, ctl_reg);\n\n\tdata_size = hsw_dip_data_size(dev_priv, type);\n\n\tdrm_WARN_ON(&dev_priv->drm, len > data_size);\n\n\tval &= ~hsw_infoframe_enable(type);\n\tintel_de_write(dev_priv, ctl_reg, val);\n\n\tfor (i = 0; i < len; i += 4) {\n\t\tintel_de_write(dev_priv,\n\t\t\t       hsw_dip_data_reg(dev_priv, cpu_transcoder, type, i >> 2),\n\t\t\t       *data);\n\t\tdata++;\n\t}\n\t \n\tfor (; i < data_size; i += 4)\n\t\tintel_de_write(dev_priv,\n\t\t\t       hsw_dip_data_reg(dev_priv, cpu_transcoder, type, i >> 2),\n\t\t\t       0);\n\n\t \n\tif (IS_DISPLAY_VER(dev_priv, 13, 14) && crtc_state->has_psr && type == DP_SDP_VSC)\n\t\treturn;\n\n\tval |= hsw_infoframe_enable(type);\n\tintel_de_write(dev_priv, ctl_reg, val);\n\tintel_de_posting_read(dev_priv, ctl_reg);\n}\n\nvoid hsw_read_infoframe(struct intel_encoder *encoder,\n\t\t\tconst struct intel_crtc_state *crtc_state,\n\t\t\tunsigned int type, void *frame, ssize_t len)\n{\n\tstruct drm_i915_private *dev_priv = to_i915(encoder->base.dev);\n\tenum transcoder cpu_transcoder = crtc_state->cpu_transcoder;\n\tu32 *data = frame;\n\tint i;\n\n\tfor (i = 0; i < len; i += 4)\n\t\t*data++ = intel_de_read(dev_priv,\n\t\t\t\t        hsw_dip_data_reg(dev_priv, cpu_transcoder, type, i >> 2));\n}\n\nstatic u32 hsw_infoframes_enabled(struct intel_encoder *encoder,\n\t\t\t\t  const struct intel_crtc_state *pipe_config)\n{\n\tstruct drm_i915_private *dev_priv = to_i915(encoder->base.dev);\n\tu32 val = intel_de_read(dev_priv,\n\t\t\t\tHSW_TVIDEO_DIP_CTL(pipe_config->cpu_transcoder));\n\tu32 mask;\n\n\tmask = (VIDEO_DIP_ENABLE_VSC_HSW | VIDEO_DIP_ENABLE_AVI_HSW |\n\t\tVIDEO_DIP_ENABLE_GCP_HSW | VIDEO_DIP_ENABLE_VS_HSW |\n\t\tVIDEO_DIP_ENABLE_GMP_HSW | VIDEO_DIP_ENABLE_SPD_HSW);\n\n\tif (DISPLAY_VER(dev_priv) >= 10)\n\t\tmask |= VIDEO_DIP_ENABLE_DRM_GLK;\n\n\treturn val & mask;\n}\n\nstatic const u8 infoframe_type_to_idx[] = {\n\tHDMI_PACKET_TYPE_GENERAL_CONTROL,\n\tHDMI_PACKET_TYPE_GAMUT_METADATA,\n\tDP_SDP_VSC,\n\tHDMI_INFOFRAME_TYPE_AVI,\n\tHDMI_INFOFRAME_TYPE_SPD,\n\tHDMI_INFOFRAME_TYPE_VENDOR,\n\tHDMI_INFOFRAME_TYPE_DRM,\n};\n\nu32 intel_hdmi_infoframe_enable(unsigned int type)\n{\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(infoframe_type_to_idx); i++) {\n\t\tif (infoframe_type_to_idx[i] == type)\n\t\t\treturn BIT(i);\n\t}\n\n\treturn 0;\n}\n\nu32 intel_hdmi_infoframes_enabled(struct intel_encoder *encoder,\n\t\t\t\t  const struct intel_crtc_state *crtc_state)\n{\n\tstruct drm_i915_private *dev_priv = to_i915(encoder->base.dev);\n\tstruct intel_digital_port *dig_port = enc_to_dig_port(encoder);\n\tu32 val, ret = 0;\n\tint i;\n\n\tval = dig_port->infoframes_enabled(encoder, crtc_state);\n\n\t \n\tfor (i = 0; i < ARRAY_SIZE(infoframe_type_to_idx); i++) {\n\t\tunsigned int type = infoframe_type_to_idx[i];\n\n\t\tif (HAS_DDI(dev_priv)) {\n\t\t\tif (val & hsw_infoframe_enable(type))\n\t\t\t\tret |= BIT(i);\n\t\t} else {\n\t\t\tif (val & g4x_infoframe_enable(type))\n\t\t\t\tret |= BIT(i);\n\t\t}\n\t}\n\n\treturn ret;\n}\n\n \nstatic void intel_write_infoframe(struct intel_encoder *encoder,\n\t\t\t\t  const struct intel_crtc_state *crtc_state,\n\t\t\t\t  enum hdmi_infoframe_type type,\n\t\t\t\t  const union hdmi_infoframe *frame)\n{\n\tstruct intel_digital_port *dig_port = enc_to_dig_port(encoder);\n\tu8 buffer[VIDEO_DIP_DATA_SIZE];\n\tssize_t len;\n\n\tif ((crtc_state->infoframes.enable &\n\t     intel_hdmi_infoframe_enable(type)) == 0)\n\t\treturn;\n\n\tif (drm_WARN_ON(encoder->base.dev, frame->any.type != type))\n\t\treturn;\n\n\t \n\tlen = hdmi_infoframe_pack_only(frame, buffer + 1, sizeof(buffer) - 1);\n\tif (drm_WARN_ON(encoder->base.dev, len < 0))\n\t\treturn;\n\n\t \n\tmemmove(&buffer[0], &buffer[1], 3);\n\tbuffer[3] = 0;\n\tlen++;\n\n\tdig_port->write_infoframe(encoder, crtc_state, type, buffer, len);\n}\n\nvoid intel_read_infoframe(struct intel_encoder *encoder,\n\t\t\t  const struct intel_crtc_state *crtc_state,\n\t\t\t  enum hdmi_infoframe_type type,\n\t\t\t  union hdmi_infoframe *frame)\n{\n\tstruct intel_digital_port *dig_port = enc_to_dig_port(encoder);\n\tu8 buffer[VIDEO_DIP_DATA_SIZE];\n\tint ret;\n\n\tif ((crtc_state->infoframes.enable &\n\t     intel_hdmi_infoframe_enable(type)) == 0)\n\t\treturn;\n\n\tdig_port->read_infoframe(encoder, crtc_state,\n\t\t\t\t       type, buffer, sizeof(buffer));\n\n\t \n\tmemmove(&buffer[1], &buffer[0], 3);\n\n\t \n\tret = hdmi_infoframe_unpack(frame, buffer + 1, sizeof(buffer) - 1);\n\tif (ret) {\n\t\tdrm_dbg_kms(encoder->base.dev,\n\t\t\t    \"Failed to unpack infoframe type 0x%02x\\n\", type);\n\t\treturn;\n\t}\n\n\tif (frame->any.type != type)\n\t\tdrm_dbg_kms(encoder->base.dev,\n\t\t\t    \"Found the wrong infoframe type 0x%x (expected 0x%02x)\\n\",\n\t\t\t    frame->any.type, type);\n}\n\nstatic bool\nintel_hdmi_compute_avi_infoframe(struct intel_encoder *encoder,\n\t\t\t\t struct intel_crtc_state *crtc_state,\n\t\t\t\t struct drm_connector_state *conn_state)\n{\n\tstruct hdmi_avi_infoframe *frame = &crtc_state->infoframes.avi.avi;\n\tconst struct drm_display_mode *adjusted_mode =\n\t\t&crtc_state->hw.adjusted_mode;\n\tstruct drm_connector *connector = conn_state->connector;\n\tint ret;\n\n\tif (!crtc_state->has_infoframe)\n\t\treturn true;\n\n\tcrtc_state->infoframes.enable |=\n\t\tintel_hdmi_infoframe_enable(HDMI_INFOFRAME_TYPE_AVI);\n\n\tret = drm_hdmi_avi_infoframe_from_display_mode(frame, connector,\n\t\t\t\t\t\t       adjusted_mode);\n\tif (ret)\n\t\treturn false;\n\n\tif (crtc_state->output_format == INTEL_OUTPUT_FORMAT_YCBCR420)\n\t\tframe->colorspace = HDMI_COLORSPACE_YUV420;\n\telse if (crtc_state->output_format == INTEL_OUTPUT_FORMAT_YCBCR444)\n\t\tframe->colorspace = HDMI_COLORSPACE_YUV444;\n\telse\n\t\tframe->colorspace = HDMI_COLORSPACE_RGB;\n\n\tdrm_hdmi_avi_infoframe_colorimetry(frame, conn_state);\n\n\t \n\tdrm_WARN_ON(encoder->base.dev, crtc_state->limited_color_range &&\n\t\t    crtc_state->output_format != INTEL_OUTPUT_FORMAT_RGB);\n\n\tif (crtc_state->output_format == INTEL_OUTPUT_FORMAT_RGB) {\n\t\tdrm_hdmi_avi_infoframe_quant_range(frame, connector,\n\t\t\t\t\t\t   adjusted_mode,\n\t\t\t\t\t\t   crtc_state->limited_color_range ?\n\t\t\t\t\t\t   HDMI_QUANTIZATION_RANGE_LIMITED :\n\t\t\t\t\t\t   HDMI_QUANTIZATION_RANGE_FULL);\n\t} else {\n\t\tframe->quantization_range = HDMI_QUANTIZATION_RANGE_DEFAULT;\n\t\tframe->ycc_quantization_range = HDMI_YCC_QUANTIZATION_RANGE_LIMITED;\n\t}\n\n\tdrm_hdmi_avi_infoframe_content_type(frame, conn_state);\n\n\t \n\n\tret = hdmi_avi_infoframe_check(frame);\n\tif (drm_WARN_ON(encoder->base.dev, ret))\n\t\treturn false;\n\n\treturn true;\n}\n\nstatic bool\nintel_hdmi_compute_spd_infoframe(struct intel_encoder *encoder,\n\t\t\t\t struct intel_crtc_state *crtc_state,\n\t\t\t\t struct drm_connector_state *conn_state)\n{\n\tstruct drm_i915_private *i915 = to_i915(encoder->base.dev);\n\tstruct hdmi_spd_infoframe *frame = &crtc_state->infoframes.spd.spd;\n\tint ret;\n\n\tif (!crtc_state->has_infoframe)\n\t\treturn true;\n\n\tcrtc_state->infoframes.enable |=\n\t\tintel_hdmi_infoframe_enable(HDMI_INFOFRAME_TYPE_SPD);\n\n\tif (IS_DGFX(i915))\n\t\tret = hdmi_spd_infoframe_init(frame, \"Intel\", \"Discrete gfx\");\n\telse\n\t\tret = hdmi_spd_infoframe_init(frame, \"Intel\", \"Integrated gfx\");\n\n\tif (drm_WARN_ON(encoder->base.dev, ret))\n\t\treturn false;\n\n\tframe->sdi = HDMI_SPD_SDI_PC;\n\n\tret = hdmi_spd_infoframe_check(frame);\n\tif (drm_WARN_ON(encoder->base.dev, ret))\n\t\treturn false;\n\n\treturn true;\n}\n\nstatic bool\nintel_hdmi_compute_hdmi_infoframe(struct intel_encoder *encoder,\n\t\t\t\t  struct intel_crtc_state *crtc_state,\n\t\t\t\t  struct drm_connector_state *conn_state)\n{\n\tstruct hdmi_vendor_infoframe *frame =\n\t\t&crtc_state->infoframes.hdmi.vendor.hdmi;\n\tconst struct drm_display_info *info =\n\t\t&conn_state->connector->display_info;\n\tint ret;\n\n\tif (!crtc_state->has_infoframe || !info->has_hdmi_infoframe)\n\t\treturn true;\n\n\tcrtc_state->infoframes.enable |=\n\t\tintel_hdmi_infoframe_enable(HDMI_INFOFRAME_TYPE_VENDOR);\n\n\tret = drm_hdmi_vendor_infoframe_from_display_mode(frame,\n\t\t\t\t\t\t\t  conn_state->connector,\n\t\t\t\t\t\t\t  &crtc_state->hw.adjusted_mode);\n\tif (drm_WARN_ON(encoder->base.dev, ret))\n\t\treturn false;\n\n\tret = hdmi_vendor_infoframe_check(frame);\n\tif (drm_WARN_ON(encoder->base.dev, ret))\n\t\treturn false;\n\n\treturn true;\n}\n\nstatic bool\nintel_hdmi_compute_drm_infoframe(struct intel_encoder *encoder,\n\t\t\t\t struct intel_crtc_state *crtc_state,\n\t\t\t\t struct drm_connector_state *conn_state)\n{\n\tstruct hdmi_drm_infoframe *frame = &crtc_state->infoframes.drm.drm;\n\tstruct drm_i915_private *dev_priv = to_i915(encoder->base.dev);\n\tint ret;\n\n\tif (DISPLAY_VER(dev_priv) < 10)\n\t\treturn true;\n\n\tif (!crtc_state->has_infoframe)\n\t\treturn true;\n\n\tif (!conn_state->hdr_output_metadata)\n\t\treturn true;\n\n\tcrtc_state->infoframes.enable |=\n\t\tintel_hdmi_infoframe_enable(HDMI_INFOFRAME_TYPE_DRM);\n\n\tret = drm_hdmi_infoframe_set_hdr_metadata(frame, conn_state);\n\tif (ret < 0) {\n\t\tdrm_dbg_kms(&dev_priv->drm,\n\t\t\t    \"couldn't set HDR metadata in infoframe\\n\");\n\t\treturn false;\n\t}\n\n\tret = hdmi_drm_infoframe_check(frame);\n\tif (drm_WARN_ON(&dev_priv->drm, ret))\n\t\treturn false;\n\n\treturn true;\n}\n\nstatic void g4x_set_infoframes(struct intel_encoder *encoder,\n\t\t\t       bool enable,\n\t\t\t       const struct intel_crtc_state *crtc_state,\n\t\t\t       const struct drm_connector_state *conn_state)\n{\n\tstruct drm_i915_private *dev_priv = to_i915(encoder->base.dev);\n\tstruct intel_digital_port *dig_port = enc_to_dig_port(encoder);\n\tstruct intel_hdmi *intel_hdmi = &dig_port->hdmi;\n\ti915_reg_t reg = VIDEO_DIP_CTL;\n\tu32 val = intel_de_read(dev_priv, reg);\n\tu32 port = VIDEO_DIP_PORT(encoder->port);\n\n\tassert_hdmi_port_disabled(intel_hdmi);\n\n\t \n\tval |= VIDEO_DIP_SELECT_AVI | VIDEO_DIP_FREQ_VSYNC;\n\n\tif (!enable) {\n\t\tif (!(val & VIDEO_DIP_ENABLE))\n\t\t\treturn;\n\t\tif (port != (val & VIDEO_DIP_PORT_MASK)) {\n\t\t\tdrm_dbg_kms(&dev_priv->drm,\n\t\t\t\t    \"video DIP still enabled on port %c\\n\",\n\t\t\t\t    (val & VIDEO_DIP_PORT_MASK) >> 29);\n\t\t\treturn;\n\t\t}\n\t\tval &= ~(VIDEO_DIP_ENABLE | VIDEO_DIP_ENABLE_AVI |\n\t\t\t VIDEO_DIP_ENABLE_VENDOR | VIDEO_DIP_ENABLE_SPD);\n\t\tintel_de_write(dev_priv, reg, val);\n\t\tintel_de_posting_read(dev_priv, reg);\n\t\treturn;\n\t}\n\n\tif (port != (val & VIDEO_DIP_PORT_MASK)) {\n\t\tif (val & VIDEO_DIP_ENABLE) {\n\t\t\tdrm_dbg_kms(&dev_priv->drm,\n\t\t\t\t    \"video DIP already enabled on port %c\\n\",\n\t\t\t\t    (val & VIDEO_DIP_PORT_MASK) >> 29);\n\t\t\treturn;\n\t\t}\n\t\tval &= ~VIDEO_DIP_PORT_MASK;\n\t\tval |= port;\n\t}\n\n\tval |= VIDEO_DIP_ENABLE;\n\tval &= ~(VIDEO_DIP_ENABLE_AVI |\n\t\t VIDEO_DIP_ENABLE_VENDOR | VIDEO_DIP_ENABLE_SPD);\n\n\tintel_de_write(dev_priv, reg, val);\n\tintel_de_posting_read(dev_priv, reg);\n\n\tintel_write_infoframe(encoder, crtc_state,\n\t\t\t      HDMI_INFOFRAME_TYPE_AVI,\n\t\t\t      &crtc_state->infoframes.avi);\n\tintel_write_infoframe(encoder, crtc_state,\n\t\t\t      HDMI_INFOFRAME_TYPE_SPD,\n\t\t\t      &crtc_state->infoframes.spd);\n\tintel_write_infoframe(encoder, crtc_state,\n\t\t\t      HDMI_INFOFRAME_TYPE_VENDOR,\n\t\t\t      &crtc_state->infoframes.hdmi);\n}\n\n \nstatic bool gcp_default_phase_possible(int pipe_bpp,\n\t\t\t\t       const struct drm_display_mode *mode)\n{\n\tunsigned int pixels_per_group;\n\n\tswitch (pipe_bpp) {\n\tcase 30:\n\t\t \n\t\tpixels_per_group = 4;\n\t\tbreak;\n\tcase 36:\n\t\t \n\t\tpixels_per_group = 2;\n\t\tbreak;\n\tcase 48:\n\t\t \n\t\tpixels_per_group = 1;\n\t\tbreak;\n\tdefault:\n\t\t \n\t\treturn false;\n\t}\n\n\treturn mode->crtc_hdisplay % pixels_per_group == 0 &&\n\t\tmode->crtc_htotal % pixels_per_group == 0 &&\n\t\tmode->crtc_hblank_start % pixels_per_group == 0 &&\n\t\tmode->crtc_hblank_end % pixels_per_group == 0 &&\n\t\tmode->crtc_hsync_start % pixels_per_group == 0 &&\n\t\tmode->crtc_hsync_end % pixels_per_group == 0 &&\n\t\t((mode->flags & DRM_MODE_FLAG_INTERLACE) == 0 ||\n\t\t mode->crtc_htotal/2 % pixels_per_group == 0);\n}\n\nstatic bool intel_hdmi_set_gcp_infoframe(struct intel_encoder *encoder,\n\t\t\t\t\t const struct intel_crtc_state *crtc_state,\n\t\t\t\t\t const struct drm_connector_state *conn_state)\n{\n\tstruct drm_i915_private *dev_priv = to_i915(encoder->base.dev);\n\tstruct intel_crtc *crtc = to_intel_crtc(crtc_state->uapi.crtc);\n\ti915_reg_t reg;\n\n\tif ((crtc_state->infoframes.enable &\n\t     intel_hdmi_infoframe_enable(HDMI_PACKET_TYPE_GENERAL_CONTROL)) == 0)\n\t\treturn false;\n\n\tif (HAS_DDI(dev_priv))\n\t\treg = HSW_TVIDEO_DIP_GCP(crtc_state->cpu_transcoder);\n\telse if (IS_VALLEYVIEW(dev_priv) || IS_CHERRYVIEW(dev_priv))\n\t\treg = VLV_TVIDEO_DIP_GCP(crtc->pipe);\n\telse if (HAS_PCH_SPLIT(dev_priv))\n\t\treg = TVIDEO_DIP_GCP(crtc->pipe);\n\telse\n\t\treturn false;\n\n\tintel_de_write(dev_priv, reg, crtc_state->infoframes.gcp);\n\n\treturn true;\n}\n\nvoid intel_hdmi_read_gcp_infoframe(struct intel_encoder *encoder,\n\t\t\t\t   struct intel_crtc_state *crtc_state)\n{\n\tstruct drm_i915_private *dev_priv = to_i915(encoder->base.dev);\n\tstruct intel_crtc *crtc = to_intel_crtc(crtc_state->uapi.crtc);\n\ti915_reg_t reg;\n\n\tif ((crtc_state->infoframes.enable &\n\t     intel_hdmi_infoframe_enable(HDMI_PACKET_TYPE_GENERAL_CONTROL)) == 0)\n\t\treturn;\n\n\tif (HAS_DDI(dev_priv))\n\t\treg = HSW_TVIDEO_DIP_GCP(crtc_state->cpu_transcoder);\n\telse if (IS_VALLEYVIEW(dev_priv) || IS_CHERRYVIEW(dev_priv))\n\t\treg = VLV_TVIDEO_DIP_GCP(crtc->pipe);\n\telse if (HAS_PCH_SPLIT(dev_priv))\n\t\treg = TVIDEO_DIP_GCP(crtc->pipe);\n\telse\n\t\treturn;\n\n\tcrtc_state->infoframes.gcp = intel_de_read(dev_priv, reg);\n}\n\nstatic void intel_hdmi_compute_gcp_infoframe(struct intel_encoder *encoder,\n\t\t\t\t\t     struct intel_crtc_state *crtc_state,\n\t\t\t\t\t     struct drm_connector_state *conn_state)\n{\n\tstruct drm_i915_private *dev_priv = to_i915(encoder->base.dev);\n\n\tif (IS_G4X(dev_priv) || !crtc_state->has_infoframe)\n\t\treturn;\n\n\tcrtc_state->infoframes.enable |=\n\t\tintel_hdmi_infoframe_enable(HDMI_PACKET_TYPE_GENERAL_CONTROL);\n\n\t \n\tif (crtc_state->pipe_bpp > 24)\n\t\tcrtc_state->infoframes.gcp |= GCP_COLOR_INDICATION;\n\n\t \n\tif (gcp_default_phase_possible(crtc_state->pipe_bpp,\n\t\t\t\t       &crtc_state->hw.adjusted_mode))\n\t\tcrtc_state->infoframes.gcp |= GCP_DEFAULT_PHASE_ENABLE;\n}\n\nstatic void ibx_set_infoframes(struct intel_encoder *encoder,\n\t\t\t       bool enable,\n\t\t\t       const struct intel_crtc_state *crtc_state,\n\t\t\t       const struct drm_connector_state *conn_state)\n{\n\tstruct drm_i915_private *dev_priv = to_i915(encoder->base.dev);\n\tstruct intel_crtc *crtc = to_intel_crtc(crtc_state->uapi.crtc);\n\tstruct intel_digital_port *dig_port = enc_to_dig_port(encoder);\n\tstruct intel_hdmi *intel_hdmi = &dig_port->hdmi;\n\ti915_reg_t reg = TVIDEO_DIP_CTL(crtc->pipe);\n\tu32 val = intel_de_read(dev_priv, reg);\n\tu32 port = VIDEO_DIP_PORT(encoder->port);\n\n\tassert_hdmi_port_disabled(intel_hdmi);\n\n\t \n\tval |= VIDEO_DIP_SELECT_AVI | VIDEO_DIP_FREQ_VSYNC;\n\n\tif (!enable) {\n\t\tif (!(val & VIDEO_DIP_ENABLE))\n\t\t\treturn;\n\t\tval &= ~(VIDEO_DIP_ENABLE | VIDEO_DIP_ENABLE_AVI |\n\t\t\t VIDEO_DIP_ENABLE_VENDOR | VIDEO_DIP_ENABLE_GAMUT |\n\t\t\t VIDEO_DIP_ENABLE_SPD | VIDEO_DIP_ENABLE_GCP);\n\t\tintel_de_write(dev_priv, reg, val);\n\t\tintel_de_posting_read(dev_priv, reg);\n\t\treturn;\n\t}\n\n\tif (port != (val & VIDEO_DIP_PORT_MASK)) {\n\t\tdrm_WARN(&dev_priv->drm, val & VIDEO_DIP_ENABLE,\n\t\t\t \"DIP already enabled on port %c\\n\",\n\t\t\t (val & VIDEO_DIP_PORT_MASK) >> 29);\n\t\tval &= ~VIDEO_DIP_PORT_MASK;\n\t\tval |= port;\n\t}\n\n\tval |= VIDEO_DIP_ENABLE;\n\tval &= ~(VIDEO_DIP_ENABLE_AVI |\n\t\t VIDEO_DIP_ENABLE_VENDOR | VIDEO_DIP_ENABLE_GAMUT |\n\t\t VIDEO_DIP_ENABLE_SPD | VIDEO_DIP_ENABLE_GCP);\n\n\tif (intel_hdmi_set_gcp_infoframe(encoder, crtc_state, conn_state))\n\t\tval |= VIDEO_DIP_ENABLE_GCP;\n\n\tintel_de_write(dev_priv, reg, val);\n\tintel_de_posting_read(dev_priv, reg);\n\n\tintel_write_infoframe(encoder, crtc_state,\n\t\t\t      HDMI_INFOFRAME_TYPE_AVI,\n\t\t\t      &crtc_state->infoframes.avi);\n\tintel_write_infoframe(encoder, crtc_state,\n\t\t\t      HDMI_INFOFRAME_TYPE_SPD,\n\t\t\t      &crtc_state->infoframes.spd);\n\tintel_write_infoframe(encoder, crtc_state,\n\t\t\t      HDMI_INFOFRAME_TYPE_VENDOR,\n\t\t\t      &crtc_state->infoframes.hdmi);\n}\n\nstatic void cpt_set_infoframes(struct intel_encoder *encoder,\n\t\t\t       bool enable,\n\t\t\t       const struct intel_crtc_state *crtc_state,\n\t\t\t       const struct drm_connector_state *conn_state)\n{\n\tstruct drm_i915_private *dev_priv = to_i915(encoder->base.dev);\n\tstruct intel_crtc *crtc = to_intel_crtc(crtc_state->uapi.crtc);\n\tstruct intel_hdmi *intel_hdmi = enc_to_intel_hdmi(encoder);\n\ti915_reg_t reg = TVIDEO_DIP_CTL(crtc->pipe);\n\tu32 val = intel_de_read(dev_priv, reg);\n\n\tassert_hdmi_port_disabled(intel_hdmi);\n\n\t \n\tval |= VIDEO_DIP_SELECT_AVI | VIDEO_DIP_FREQ_VSYNC;\n\n\tif (!enable) {\n\t\tif (!(val & VIDEO_DIP_ENABLE))\n\t\t\treturn;\n\t\tval &= ~(VIDEO_DIP_ENABLE | VIDEO_DIP_ENABLE_AVI |\n\t\t\t VIDEO_DIP_ENABLE_VENDOR | VIDEO_DIP_ENABLE_GAMUT |\n\t\t\t VIDEO_DIP_ENABLE_SPD | VIDEO_DIP_ENABLE_GCP);\n\t\tintel_de_write(dev_priv, reg, val);\n\t\tintel_de_posting_read(dev_priv, reg);\n\t\treturn;\n\t}\n\n\t \n\tval |= VIDEO_DIP_ENABLE | VIDEO_DIP_ENABLE_AVI;\n\tval &= ~(VIDEO_DIP_ENABLE_VENDOR | VIDEO_DIP_ENABLE_GAMUT |\n\t\t VIDEO_DIP_ENABLE_SPD | VIDEO_DIP_ENABLE_GCP);\n\n\tif (intel_hdmi_set_gcp_infoframe(encoder, crtc_state, conn_state))\n\t\tval |= VIDEO_DIP_ENABLE_GCP;\n\n\tintel_de_write(dev_priv, reg, val);\n\tintel_de_posting_read(dev_priv, reg);\n\n\tintel_write_infoframe(encoder, crtc_state,\n\t\t\t      HDMI_INFOFRAME_TYPE_AVI,\n\t\t\t      &crtc_state->infoframes.avi);\n\tintel_write_infoframe(encoder, crtc_state,\n\t\t\t      HDMI_INFOFRAME_TYPE_SPD,\n\t\t\t      &crtc_state->infoframes.spd);\n\tintel_write_infoframe(encoder, crtc_state,\n\t\t\t      HDMI_INFOFRAME_TYPE_VENDOR,\n\t\t\t      &crtc_state->infoframes.hdmi);\n}\n\nstatic void vlv_set_infoframes(struct intel_encoder *encoder,\n\t\t\t       bool enable,\n\t\t\t       const struct intel_crtc_state *crtc_state,\n\t\t\t       const struct drm_connector_state *conn_state)\n{\n\tstruct drm_i915_private *dev_priv = to_i915(encoder->base.dev);\n\tstruct intel_crtc *crtc = to_intel_crtc(crtc_state->uapi.crtc);\n\tstruct intel_hdmi *intel_hdmi = enc_to_intel_hdmi(encoder);\n\ti915_reg_t reg = VLV_TVIDEO_DIP_CTL(crtc->pipe);\n\tu32 val = intel_de_read(dev_priv, reg);\n\tu32 port = VIDEO_DIP_PORT(encoder->port);\n\n\tassert_hdmi_port_disabled(intel_hdmi);\n\n\t \n\tval |= VIDEO_DIP_SELECT_AVI | VIDEO_DIP_FREQ_VSYNC;\n\n\tif (!enable) {\n\t\tif (!(val & VIDEO_DIP_ENABLE))\n\t\t\treturn;\n\t\tval &= ~(VIDEO_DIP_ENABLE | VIDEO_DIP_ENABLE_AVI |\n\t\t\t VIDEO_DIP_ENABLE_VENDOR | VIDEO_DIP_ENABLE_GAMUT |\n\t\t\t VIDEO_DIP_ENABLE_SPD | VIDEO_DIP_ENABLE_GCP);\n\t\tintel_de_write(dev_priv, reg, val);\n\t\tintel_de_posting_read(dev_priv, reg);\n\t\treturn;\n\t}\n\n\tif (port != (val & VIDEO_DIP_PORT_MASK)) {\n\t\tdrm_WARN(&dev_priv->drm, val & VIDEO_DIP_ENABLE,\n\t\t\t \"DIP already enabled on port %c\\n\",\n\t\t\t (val & VIDEO_DIP_PORT_MASK) >> 29);\n\t\tval &= ~VIDEO_DIP_PORT_MASK;\n\t\tval |= port;\n\t}\n\n\tval |= VIDEO_DIP_ENABLE;\n\tval &= ~(VIDEO_DIP_ENABLE_AVI |\n\t\t VIDEO_DIP_ENABLE_VENDOR | VIDEO_DIP_ENABLE_GAMUT |\n\t\t VIDEO_DIP_ENABLE_SPD | VIDEO_DIP_ENABLE_GCP);\n\n\tif (intel_hdmi_set_gcp_infoframe(encoder, crtc_state, conn_state))\n\t\tval |= VIDEO_DIP_ENABLE_GCP;\n\n\tintel_de_write(dev_priv, reg, val);\n\tintel_de_posting_read(dev_priv, reg);\n\n\tintel_write_infoframe(encoder, crtc_state,\n\t\t\t      HDMI_INFOFRAME_TYPE_AVI,\n\t\t\t      &crtc_state->infoframes.avi);\n\tintel_write_infoframe(encoder, crtc_state,\n\t\t\t      HDMI_INFOFRAME_TYPE_SPD,\n\t\t\t      &crtc_state->infoframes.spd);\n\tintel_write_infoframe(encoder, crtc_state,\n\t\t\t      HDMI_INFOFRAME_TYPE_VENDOR,\n\t\t\t      &crtc_state->infoframes.hdmi);\n}\n\nstatic void hsw_set_infoframes(struct intel_encoder *encoder,\n\t\t\t       bool enable,\n\t\t\t       const struct intel_crtc_state *crtc_state,\n\t\t\t       const struct drm_connector_state *conn_state)\n{\n\tstruct drm_i915_private *dev_priv = to_i915(encoder->base.dev);\n\ti915_reg_t reg = HSW_TVIDEO_DIP_CTL(crtc_state->cpu_transcoder);\n\tu32 val = intel_de_read(dev_priv, reg);\n\n\tassert_hdmi_transcoder_func_disabled(dev_priv,\n\t\t\t\t\t     crtc_state->cpu_transcoder);\n\n\tval &= ~(VIDEO_DIP_ENABLE_VSC_HSW | VIDEO_DIP_ENABLE_AVI_HSW |\n\t\t VIDEO_DIP_ENABLE_GCP_HSW | VIDEO_DIP_ENABLE_VS_HSW |\n\t\t VIDEO_DIP_ENABLE_GMP_HSW | VIDEO_DIP_ENABLE_SPD_HSW |\n\t\t VIDEO_DIP_ENABLE_DRM_GLK);\n\n\tif (!enable) {\n\t\tintel_de_write(dev_priv, reg, val);\n\t\tintel_de_posting_read(dev_priv, reg);\n\t\treturn;\n\t}\n\n\tif (intel_hdmi_set_gcp_infoframe(encoder, crtc_state, conn_state))\n\t\tval |= VIDEO_DIP_ENABLE_GCP_HSW;\n\n\tintel_de_write(dev_priv, reg, val);\n\tintel_de_posting_read(dev_priv, reg);\n\n\tintel_write_infoframe(encoder, crtc_state,\n\t\t\t      HDMI_INFOFRAME_TYPE_AVI,\n\t\t\t      &crtc_state->infoframes.avi);\n\tintel_write_infoframe(encoder, crtc_state,\n\t\t\t      HDMI_INFOFRAME_TYPE_SPD,\n\t\t\t      &crtc_state->infoframes.spd);\n\tintel_write_infoframe(encoder, crtc_state,\n\t\t\t      HDMI_INFOFRAME_TYPE_VENDOR,\n\t\t\t      &crtc_state->infoframes.hdmi);\n\tintel_write_infoframe(encoder, crtc_state,\n\t\t\t      HDMI_INFOFRAME_TYPE_DRM,\n\t\t\t      &crtc_state->infoframes.drm);\n}\n\nvoid intel_dp_dual_mode_set_tmds_output(struct intel_hdmi *hdmi, bool enable)\n{\n\tstruct drm_i915_private *dev_priv = intel_hdmi_to_i915(hdmi);\n\tstruct i2c_adapter *adapter;\n\n\tif (hdmi->dp_dual_mode.type < DRM_DP_DUAL_MODE_TYPE2_DVI)\n\t\treturn;\n\n\tadapter = intel_gmbus_get_adapter(dev_priv, hdmi->ddc_bus);\n\n\tdrm_dbg_kms(&dev_priv->drm, \"%s DP dual mode adaptor TMDS output\\n\",\n\t\t    enable ? \"Enabling\" : \"Disabling\");\n\n\tdrm_dp_dual_mode_set_tmds_output(&dev_priv->drm, hdmi->dp_dual_mode.type, adapter, enable);\n}\n\nstatic int intel_hdmi_hdcp_read(struct intel_digital_port *dig_port,\n\t\t\t\tunsigned int offset, void *buffer, size_t size)\n{\n\tstruct drm_i915_private *i915 = to_i915(dig_port->base.base.dev);\n\tstruct intel_hdmi *hdmi = &dig_port->hdmi;\n\tstruct i2c_adapter *adapter = intel_gmbus_get_adapter(i915,\n\t\t\t\t\t\t\t      hdmi->ddc_bus);\n\tint ret;\n\tu8 start = offset & 0xff;\n\tstruct i2c_msg msgs[] = {\n\t\t{\n\t\t\t.addr = DRM_HDCP_DDC_ADDR,\n\t\t\t.flags = 0,\n\t\t\t.len = 1,\n\t\t\t.buf = &start,\n\t\t},\n\t\t{\n\t\t\t.addr = DRM_HDCP_DDC_ADDR,\n\t\t\t.flags = I2C_M_RD,\n\t\t\t.len = size,\n\t\t\t.buf = buffer\n\t\t}\n\t};\n\tret = i2c_transfer(adapter, msgs, ARRAY_SIZE(msgs));\n\tif (ret == ARRAY_SIZE(msgs))\n\t\treturn 0;\n\treturn ret >= 0 ? -EIO : ret;\n}\n\nstatic int intel_hdmi_hdcp_write(struct intel_digital_port *dig_port,\n\t\t\t\t unsigned int offset, void *buffer, size_t size)\n{\n\tstruct drm_i915_private *i915 = to_i915(dig_port->base.base.dev);\n\tstruct intel_hdmi *hdmi = &dig_port->hdmi;\n\tstruct i2c_adapter *adapter = intel_gmbus_get_adapter(i915,\n\t\t\t\t\t\t\t      hdmi->ddc_bus);\n\tint ret;\n\tu8 *write_buf;\n\tstruct i2c_msg msg;\n\n\twrite_buf = kzalloc(size + 1, GFP_KERNEL);\n\tif (!write_buf)\n\t\treturn -ENOMEM;\n\n\twrite_buf[0] = offset & 0xff;\n\tmemcpy(&write_buf[1], buffer, size);\n\n\tmsg.addr = DRM_HDCP_DDC_ADDR;\n\tmsg.flags = 0,\n\tmsg.len = size + 1,\n\tmsg.buf = write_buf;\n\n\tret = i2c_transfer(adapter, &msg, 1);\n\tif (ret == 1)\n\t\tret = 0;\n\telse if (ret >= 0)\n\t\tret = -EIO;\n\n\tkfree(write_buf);\n\treturn ret;\n}\n\nstatic\nint intel_hdmi_hdcp_write_an_aksv(struct intel_digital_port *dig_port,\n\t\t\t\t  u8 *an)\n{\n\tstruct drm_i915_private *i915 = to_i915(dig_port->base.base.dev);\n\tstruct intel_hdmi *hdmi = &dig_port->hdmi;\n\tstruct i2c_adapter *adapter = intel_gmbus_get_adapter(i915,\n\t\t\t\t\t\t\t      hdmi->ddc_bus);\n\tint ret;\n\n\tret = intel_hdmi_hdcp_write(dig_port, DRM_HDCP_DDC_AN, an,\n\t\t\t\t    DRM_HDCP_AN_LEN);\n\tif (ret) {\n\t\tdrm_dbg_kms(&i915->drm, \"Write An over DDC failed (%d)\\n\",\n\t\t\t    ret);\n\t\treturn ret;\n\t}\n\n\tret = intel_gmbus_output_aksv(adapter);\n\tif (ret < 0) {\n\t\tdrm_dbg_kms(&i915->drm, \"Failed to output aksv (%d)\\n\", ret);\n\t\treturn ret;\n\t}\n\treturn 0;\n}\n\nstatic int intel_hdmi_hdcp_read_bksv(struct intel_digital_port *dig_port,\n\t\t\t\t     u8 *bksv)\n{\n\tstruct drm_i915_private *i915 = to_i915(dig_port->base.base.dev);\n\n\tint ret;\n\tret = intel_hdmi_hdcp_read(dig_port, DRM_HDCP_DDC_BKSV, bksv,\n\t\t\t\t   DRM_HDCP_KSV_LEN);\n\tif (ret)\n\t\tdrm_dbg_kms(&i915->drm, \"Read Bksv over DDC failed (%d)\\n\",\n\t\t\t    ret);\n\treturn ret;\n}\n\nstatic\nint intel_hdmi_hdcp_read_bstatus(struct intel_digital_port *dig_port,\n\t\t\t\t u8 *bstatus)\n{\n\tstruct drm_i915_private *i915 = to_i915(dig_port->base.base.dev);\n\n\tint ret;\n\tret = intel_hdmi_hdcp_read(dig_port, DRM_HDCP_DDC_BSTATUS,\n\t\t\t\t   bstatus, DRM_HDCP_BSTATUS_LEN);\n\tif (ret)\n\t\tdrm_dbg_kms(&i915->drm, \"Read bstatus over DDC failed (%d)\\n\",\n\t\t\t    ret);\n\treturn ret;\n}\n\nstatic\nint intel_hdmi_hdcp_repeater_present(struct intel_digital_port *dig_port,\n\t\t\t\t     bool *repeater_present)\n{\n\tstruct drm_i915_private *i915 = to_i915(dig_port->base.base.dev);\n\tint ret;\n\tu8 val;\n\n\tret = intel_hdmi_hdcp_read(dig_port, DRM_HDCP_DDC_BCAPS, &val, 1);\n\tif (ret) {\n\t\tdrm_dbg_kms(&i915->drm, \"Read bcaps over DDC failed (%d)\\n\",\n\t\t\t    ret);\n\t\treturn ret;\n\t}\n\t*repeater_present = val & DRM_HDCP_DDC_BCAPS_REPEATER_PRESENT;\n\treturn 0;\n}\n\nstatic\nint intel_hdmi_hdcp_read_ri_prime(struct intel_digital_port *dig_port,\n\t\t\t\t  u8 *ri_prime)\n{\n\tstruct drm_i915_private *i915 = to_i915(dig_port->base.base.dev);\n\n\tint ret;\n\tret = intel_hdmi_hdcp_read(dig_port, DRM_HDCP_DDC_RI_PRIME,\n\t\t\t\t   ri_prime, DRM_HDCP_RI_LEN);\n\tif (ret)\n\t\tdrm_dbg_kms(&i915->drm, \"Read Ri' over DDC failed (%d)\\n\",\n\t\t\t    ret);\n\treturn ret;\n}\n\nstatic\nint intel_hdmi_hdcp_read_ksv_ready(struct intel_digital_port *dig_port,\n\t\t\t\t   bool *ksv_ready)\n{\n\tstruct drm_i915_private *i915 = to_i915(dig_port->base.base.dev);\n\tint ret;\n\tu8 val;\n\n\tret = intel_hdmi_hdcp_read(dig_port, DRM_HDCP_DDC_BCAPS, &val, 1);\n\tif (ret) {\n\t\tdrm_dbg_kms(&i915->drm, \"Read bcaps over DDC failed (%d)\\n\",\n\t\t\t    ret);\n\t\treturn ret;\n\t}\n\t*ksv_ready = val & DRM_HDCP_DDC_BCAPS_KSV_FIFO_READY;\n\treturn 0;\n}\n\nstatic\nint intel_hdmi_hdcp_read_ksv_fifo(struct intel_digital_port *dig_port,\n\t\t\t\t  int num_downstream, u8 *ksv_fifo)\n{\n\tstruct drm_i915_private *i915 = to_i915(dig_port->base.base.dev);\n\tint ret;\n\tret = intel_hdmi_hdcp_read(dig_port, DRM_HDCP_DDC_KSV_FIFO,\n\t\t\t\t   ksv_fifo, num_downstream * DRM_HDCP_KSV_LEN);\n\tif (ret) {\n\t\tdrm_dbg_kms(&i915->drm,\n\t\t\t    \"Read ksv fifo over DDC failed (%d)\\n\", ret);\n\t\treturn ret;\n\t}\n\treturn 0;\n}\n\nstatic\nint intel_hdmi_hdcp_read_v_prime_part(struct intel_digital_port *dig_port,\n\t\t\t\t      int i, u32 *part)\n{\n\tstruct drm_i915_private *i915 = to_i915(dig_port->base.base.dev);\n\tint ret;\n\n\tif (i >= DRM_HDCP_V_PRIME_NUM_PARTS)\n\t\treturn -EINVAL;\n\n\tret = intel_hdmi_hdcp_read(dig_port, DRM_HDCP_DDC_V_PRIME(i),\n\t\t\t\t   part, DRM_HDCP_V_PRIME_PART_LEN);\n\tif (ret)\n\t\tdrm_dbg_kms(&i915->drm, \"Read V'[%d] over DDC failed (%d)\\n\",\n\t\t\t    i, ret);\n\treturn ret;\n}\n\nstatic int kbl_repositioning_enc_en_signal(struct intel_connector *connector,\n\t\t\t\t\t   enum transcoder cpu_transcoder)\n{\n\tstruct drm_i915_private *dev_priv = to_i915(connector->base.dev);\n\tstruct intel_digital_port *dig_port = intel_attached_dig_port(connector);\n\tstruct intel_crtc *crtc = to_intel_crtc(connector->base.state->crtc);\n\tu32 scanline;\n\tint ret;\n\n\tfor (;;) {\n\t\tscanline = intel_de_read(dev_priv, PIPEDSL(crtc->pipe));\n\t\tif (scanline > 100 && scanline < 200)\n\t\t\tbreak;\n\t\tusleep_range(25, 50);\n\t}\n\n\tret = intel_ddi_toggle_hdcp_bits(&dig_port->base, cpu_transcoder,\n\t\t\t\t\t false, TRANS_DDI_HDCP_SIGNALLING);\n\tif (ret) {\n\t\tdrm_err(&dev_priv->drm,\n\t\t\t\"Disable HDCP signalling failed (%d)\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = intel_ddi_toggle_hdcp_bits(&dig_port->base, cpu_transcoder,\n\t\t\t\t\t true, TRANS_DDI_HDCP_SIGNALLING);\n\tif (ret) {\n\t\tdrm_err(&dev_priv->drm,\n\t\t\t\"Enable HDCP signalling failed (%d)\\n\", ret);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic\nint intel_hdmi_hdcp_toggle_signalling(struct intel_digital_port *dig_port,\n\t\t\t\t      enum transcoder cpu_transcoder,\n\t\t\t\t      bool enable)\n{\n\tstruct intel_hdmi *hdmi = &dig_port->hdmi;\n\tstruct intel_connector *connector = hdmi->attached_connector;\n\tstruct drm_i915_private *dev_priv = to_i915(connector->base.dev);\n\tint ret;\n\n\tif (!enable)\n\t\tusleep_range(6, 60);  \n\n\tret = intel_ddi_toggle_hdcp_bits(&dig_port->base,\n\t\t\t\t\t cpu_transcoder, enable,\n\t\t\t\t\t TRANS_DDI_HDCP_SIGNALLING);\n\tif (ret) {\n\t\tdrm_err(&dev_priv->drm, \"%s HDCP signalling failed (%d)\\n\",\n\t\t\tenable ? \"Enable\" : \"Disable\", ret);\n\t\treturn ret;\n\t}\n\n\t \n\tif (IS_KABYLAKE(dev_priv) && enable)\n\t\treturn kbl_repositioning_enc_en_signal(connector,\n\t\t\t\t\t\t       cpu_transcoder);\n\n\treturn 0;\n}\n\nstatic\nbool intel_hdmi_hdcp_check_link_once(struct intel_digital_port *dig_port,\n\t\t\t\t     struct intel_connector *connector)\n{\n\tstruct drm_i915_private *i915 = to_i915(dig_port->base.base.dev);\n\tenum port port = dig_port->base.port;\n\tenum transcoder cpu_transcoder = connector->hdcp.cpu_transcoder;\n\tint ret;\n\tunion {\n\t\tu32 reg;\n\t\tu8 shim[DRM_HDCP_RI_LEN];\n\t} ri;\n\n\tret = intel_hdmi_hdcp_read_ri_prime(dig_port, ri.shim);\n\tif (ret)\n\t\treturn false;\n\n\tintel_de_write(i915, HDCP_RPRIME(i915, cpu_transcoder, port), ri.reg);\n\n\t \n\tif (wait_for((intel_de_read(i915, HDCP_STATUS(i915, cpu_transcoder, port)) &\n\t\t      (HDCP_STATUS_RI_MATCH | HDCP_STATUS_ENC)) ==\n\t\t     (HDCP_STATUS_RI_MATCH | HDCP_STATUS_ENC), 1)) {\n\t\tdrm_dbg_kms(&i915->drm, \"Ri' mismatch detected (%x)\\n\",\n\t\t\tintel_de_read(i915, HDCP_STATUS(i915, cpu_transcoder,\n\t\t\t\t\t\t\tport)));\n\t\treturn false;\n\t}\n\treturn true;\n}\n\nstatic\nbool intel_hdmi_hdcp_check_link(struct intel_digital_port *dig_port,\n\t\t\t\tstruct intel_connector *connector)\n{\n\tstruct drm_i915_private *i915 = to_i915(dig_port->base.base.dev);\n\tint retry;\n\n\tfor (retry = 0; retry < 3; retry++)\n\t\tif (intel_hdmi_hdcp_check_link_once(dig_port, connector))\n\t\t\treturn true;\n\n\tdrm_err(&i915->drm, \"Link check failed\\n\");\n\treturn false;\n}\n\nstruct hdcp2_hdmi_msg_timeout {\n\tu8 msg_id;\n\tu16 timeout;\n};\n\nstatic const struct hdcp2_hdmi_msg_timeout hdcp2_msg_timeout[] = {\n\t{ HDCP_2_2_AKE_SEND_CERT, HDCP_2_2_CERT_TIMEOUT_MS, },\n\t{ HDCP_2_2_AKE_SEND_PAIRING_INFO, HDCP_2_2_PAIRING_TIMEOUT_MS, },\n\t{ HDCP_2_2_LC_SEND_LPRIME, HDCP_2_2_HDMI_LPRIME_TIMEOUT_MS, },\n\t{ HDCP_2_2_REP_SEND_RECVID_LIST, HDCP_2_2_RECVID_LIST_TIMEOUT_MS, },\n\t{ HDCP_2_2_REP_STREAM_READY, HDCP_2_2_STREAM_READY_TIMEOUT_MS, },\n};\n\nstatic\nint intel_hdmi_hdcp2_read_rx_status(struct intel_digital_port *dig_port,\n\t\t\t\t    u8 *rx_status)\n{\n\treturn intel_hdmi_hdcp_read(dig_port,\n\t\t\t\t    HDCP_2_2_HDMI_REG_RXSTATUS_OFFSET,\n\t\t\t\t    rx_status,\n\t\t\t\t    HDCP_2_2_HDMI_RXSTATUS_LEN);\n}\n\nstatic int get_hdcp2_msg_timeout(u8 msg_id, bool is_paired)\n{\n\tint i;\n\n\tif (msg_id == HDCP_2_2_AKE_SEND_HPRIME) {\n\t\tif (is_paired)\n\t\t\treturn HDCP_2_2_HPRIME_PAIRED_TIMEOUT_MS;\n\t\telse\n\t\t\treturn HDCP_2_2_HPRIME_NO_PAIRED_TIMEOUT_MS;\n\t}\n\n\tfor (i = 0; i < ARRAY_SIZE(hdcp2_msg_timeout); i++) {\n\t\tif (hdcp2_msg_timeout[i].msg_id == msg_id)\n\t\t\treturn hdcp2_msg_timeout[i].timeout;\n\t}\n\n\treturn -EINVAL;\n}\n\nstatic int\nhdcp2_detect_msg_availability(struct intel_digital_port *dig_port,\n\t\t\t      u8 msg_id, bool *msg_ready,\n\t\t\t      ssize_t *msg_sz)\n{\n\tstruct drm_i915_private *i915 = to_i915(dig_port->base.base.dev);\n\tu8 rx_status[HDCP_2_2_HDMI_RXSTATUS_LEN];\n\tint ret;\n\n\tret = intel_hdmi_hdcp2_read_rx_status(dig_port, rx_status);\n\tif (ret < 0) {\n\t\tdrm_dbg_kms(&i915->drm, \"rx_status read failed. Err %d\\n\",\n\t\t\t    ret);\n\t\treturn ret;\n\t}\n\n\t*msg_sz = ((HDCP_2_2_HDMI_RXSTATUS_MSG_SZ_HI(rx_status[1]) << 8) |\n\t\t  rx_status[0]);\n\n\tif (msg_id == HDCP_2_2_REP_SEND_RECVID_LIST)\n\t\t*msg_ready = (HDCP_2_2_HDMI_RXSTATUS_READY(rx_status[1]) &&\n\t\t\t     *msg_sz);\n\telse\n\t\t*msg_ready = *msg_sz;\n\n\treturn 0;\n}\n\nstatic ssize_t\nintel_hdmi_hdcp2_wait_for_msg(struct intel_digital_port *dig_port,\n\t\t\t      u8 msg_id, bool paired)\n{\n\tstruct drm_i915_private *i915 = to_i915(dig_port->base.base.dev);\n\tbool msg_ready = false;\n\tint timeout, ret;\n\tssize_t msg_sz = 0;\n\n\ttimeout = get_hdcp2_msg_timeout(msg_id, paired);\n\tif (timeout < 0)\n\t\treturn timeout;\n\n\tret = __wait_for(ret = hdcp2_detect_msg_availability(dig_port,\n\t\t\t\t\t\t\t     msg_id, &msg_ready,\n\t\t\t\t\t\t\t     &msg_sz),\n\t\t\t !ret && msg_ready && msg_sz, timeout * 1000,\n\t\t\t 1000, 5 * 1000);\n\tif (ret)\n\t\tdrm_dbg_kms(&i915->drm, \"msg_id: %d, ret: %d, timeout: %d\\n\",\n\t\t\t    msg_id, ret, timeout);\n\n\treturn ret ? ret : msg_sz;\n}\n\nstatic\nint intel_hdmi_hdcp2_write_msg(struct intel_digital_port *dig_port,\n\t\t\t       void *buf, size_t size)\n{\n\tunsigned int offset;\n\n\toffset = HDCP_2_2_HDMI_REG_WR_MSG_OFFSET;\n\treturn intel_hdmi_hdcp_write(dig_port, offset, buf, size);\n}\n\nstatic\nint intel_hdmi_hdcp2_read_msg(struct intel_digital_port *dig_port,\n\t\t\t      u8 msg_id, void *buf, size_t size)\n{\n\tstruct drm_i915_private *i915 = to_i915(dig_port->base.base.dev);\n\tstruct intel_hdmi *hdmi = &dig_port->hdmi;\n\tstruct intel_hdcp *hdcp = &hdmi->attached_connector->hdcp;\n\tunsigned int offset;\n\tssize_t ret;\n\n\tret = intel_hdmi_hdcp2_wait_for_msg(dig_port, msg_id,\n\t\t\t\t\t    hdcp->is_paired);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tif (ret > size) {\n\t\tdrm_dbg_kms(&i915->drm,\n\t\t\t    \"msg_sz(%zd) is more than exp size(%zu)\\n\",\n\t\t\t    ret, size);\n\t\treturn -EINVAL;\n\t}\n\n\toffset = HDCP_2_2_HDMI_REG_RD_MSG_OFFSET;\n\tret = intel_hdmi_hdcp_read(dig_port, offset, buf, ret);\n\tif (ret)\n\t\tdrm_dbg_kms(&i915->drm, \"Failed to read msg_id: %d(%zd)\\n\",\n\t\t\t    msg_id, ret);\n\n\treturn ret;\n}\n\nstatic\nint intel_hdmi_hdcp2_check_link(struct intel_digital_port *dig_port,\n\t\t\t\tstruct intel_connector *connector)\n{\n\tu8 rx_status[HDCP_2_2_HDMI_RXSTATUS_LEN];\n\tint ret;\n\n\tret = intel_hdmi_hdcp2_read_rx_status(dig_port, rx_status);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tif (HDCP_2_2_HDMI_RXSTATUS_REAUTH_REQ(rx_status[1]))\n\t\tret = HDCP_REAUTH_REQUEST;\n\telse if (HDCP_2_2_HDMI_RXSTATUS_READY(rx_status[1]))\n\t\tret = HDCP_TOPOLOGY_CHANGE;\n\n\treturn ret;\n}\n\nstatic\nint intel_hdmi_hdcp2_capable(struct intel_digital_port *dig_port,\n\t\t\t     bool *capable)\n{\n\tu8 hdcp2_version;\n\tint ret;\n\n\t*capable = false;\n\tret = intel_hdmi_hdcp_read(dig_port, HDCP_2_2_HDMI_REG_VER_OFFSET,\n\t\t\t\t   &hdcp2_version, sizeof(hdcp2_version));\n\tif (!ret && hdcp2_version & HDCP_2_2_HDMI_SUPPORT_MASK)\n\t\t*capable = true;\n\n\treturn ret;\n}\n\nstatic const struct intel_hdcp_shim intel_hdmi_hdcp_shim = {\n\t.write_an_aksv = intel_hdmi_hdcp_write_an_aksv,\n\t.read_bksv = intel_hdmi_hdcp_read_bksv,\n\t.read_bstatus = intel_hdmi_hdcp_read_bstatus,\n\t.repeater_present = intel_hdmi_hdcp_repeater_present,\n\t.read_ri_prime = intel_hdmi_hdcp_read_ri_prime,\n\t.read_ksv_ready = intel_hdmi_hdcp_read_ksv_ready,\n\t.read_ksv_fifo = intel_hdmi_hdcp_read_ksv_fifo,\n\t.read_v_prime_part = intel_hdmi_hdcp_read_v_prime_part,\n\t.toggle_signalling = intel_hdmi_hdcp_toggle_signalling,\n\t.check_link = intel_hdmi_hdcp_check_link,\n\t.write_2_2_msg = intel_hdmi_hdcp2_write_msg,\n\t.read_2_2_msg = intel_hdmi_hdcp2_read_msg,\n\t.check_2_2_link\t= intel_hdmi_hdcp2_check_link,\n\t.hdcp_2_2_capable = intel_hdmi_hdcp2_capable,\n\t.protocol = HDCP_PROTOCOL_HDMI,\n};\n\nstatic int intel_hdmi_source_max_tmds_clock(struct intel_encoder *encoder)\n{\n\tstruct drm_i915_private *dev_priv = to_i915(encoder->base.dev);\n\tint max_tmds_clock, vbt_max_tmds_clock;\n\n\tif (DISPLAY_VER(dev_priv) >= 10)\n\t\tmax_tmds_clock = 594000;\n\telse if (DISPLAY_VER(dev_priv) >= 8 || IS_HASWELL(dev_priv))\n\t\tmax_tmds_clock = 300000;\n\telse if (DISPLAY_VER(dev_priv) >= 5)\n\t\tmax_tmds_clock = 225000;\n\telse\n\t\tmax_tmds_clock = 165000;\n\n\tvbt_max_tmds_clock = intel_bios_hdmi_max_tmds_clock(encoder->devdata);\n\tif (vbt_max_tmds_clock)\n\t\tmax_tmds_clock = min(max_tmds_clock, vbt_max_tmds_clock);\n\n\treturn max_tmds_clock;\n}\n\nstatic bool intel_has_hdmi_sink(struct intel_hdmi *hdmi,\n\t\t\t\tconst struct drm_connector_state *conn_state)\n{\n\tstruct intel_connector *connector = hdmi->attached_connector;\n\n\treturn connector->base.display_info.is_hdmi &&\n\t\tREAD_ONCE(to_intel_digital_connector_state(conn_state)->force_audio) != HDMI_AUDIO_OFF_DVI;\n}\n\nstatic bool intel_hdmi_is_ycbcr420(const struct intel_crtc_state *crtc_state)\n{\n\treturn crtc_state->output_format == INTEL_OUTPUT_FORMAT_YCBCR420;\n}\n\nstatic int hdmi_port_clock_limit(struct intel_hdmi *hdmi,\n\t\t\t\t bool respect_downstream_limits,\n\t\t\t\t bool has_hdmi_sink)\n{\n\tstruct intel_encoder *encoder = &hdmi_to_dig_port(hdmi)->base;\n\tint max_tmds_clock = intel_hdmi_source_max_tmds_clock(encoder);\n\n\tif (respect_downstream_limits) {\n\t\tstruct intel_connector *connector = hdmi->attached_connector;\n\t\tconst struct drm_display_info *info = &connector->base.display_info;\n\n\t\tif (hdmi->dp_dual_mode.max_tmds_clock)\n\t\t\tmax_tmds_clock = min(max_tmds_clock,\n\t\t\t\t\t     hdmi->dp_dual_mode.max_tmds_clock);\n\n\t\tif (info->max_tmds_clock)\n\t\t\tmax_tmds_clock = min(max_tmds_clock,\n\t\t\t\t\t     info->max_tmds_clock);\n\t\telse if (!has_hdmi_sink)\n\t\t\tmax_tmds_clock = min(max_tmds_clock, 165000);\n\t}\n\n\treturn max_tmds_clock;\n}\n\nstatic enum drm_mode_status\nhdmi_port_clock_valid(struct intel_hdmi *hdmi,\n\t\t      int clock, bool respect_downstream_limits,\n\t\t      bool has_hdmi_sink)\n{\n\tstruct drm_i915_private *dev_priv = intel_hdmi_to_i915(hdmi);\n\tenum phy phy = intel_port_to_phy(dev_priv, hdmi_to_dig_port(hdmi)->base.port);\n\n\tif (clock < 25000)\n\t\treturn MODE_CLOCK_LOW;\n\tif (clock > hdmi_port_clock_limit(hdmi, respect_downstream_limits,\n\t\t\t\t\t  has_hdmi_sink))\n\t\treturn MODE_CLOCK_HIGH;\n\n\t \n\tif (IS_GEMINILAKE(dev_priv) && clock > 446666 && clock < 480000)\n\t\treturn MODE_CLOCK_RANGE;\n\n\t \n\tif ((IS_GEMINILAKE(dev_priv) || IS_BROXTON(dev_priv)) &&\n\t    clock > 223333 && clock < 240000)\n\t\treturn MODE_CLOCK_RANGE;\n\n\t \n\tif (IS_CHERRYVIEW(dev_priv) && clock > 216000 && clock < 240000)\n\t\treturn MODE_CLOCK_RANGE;\n\n\t \n\tif (intel_phy_is_combo(dev_priv, phy) && clock > 500000 && clock < 533200)\n\t\treturn MODE_CLOCK_RANGE;\n\n\t \n\tif (intel_phy_is_tc(dev_priv, phy) && clock > 500000 && clock < 532800)\n\t\treturn MODE_CLOCK_RANGE;\n\n\t \n\tif (DISPLAY_VER(dev_priv) >= 14)\n\t\treturn intel_cx0_phy_check_hdmi_link_rate(hdmi, clock);\n\telse if (IS_DG2(dev_priv))\n\t\treturn intel_snps_phy_check_hdmi_link_rate(clock);\n\n\treturn MODE_OK;\n}\n\nint intel_hdmi_tmds_clock(int clock, int bpc,\n\t\t\t  enum intel_output_format sink_format)\n{\n\t \n\tif (sink_format == INTEL_OUTPUT_FORMAT_YCBCR420)\n\t\tclock /= 2;\n\n\t \n\treturn DIV_ROUND_CLOSEST(clock * bpc, 8);\n}\n\nstatic bool intel_hdmi_source_bpc_possible(struct drm_i915_private *i915, int bpc)\n{\n\tswitch (bpc) {\n\tcase 12:\n\t\treturn !HAS_GMCH(i915);\n\tcase 10:\n\t\treturn DISPLAY_VER(i915) >= 11;\n\tcase 8:\n\t\treturn true;\n\tdefault:\n\t\tMISSING_CASE(bpc);\n\t\treturn false;\n\t}\n}\n\nstatic bool intel_hdmi_sink_bpc_possible(struct drm_connector *connector,\n\t\t\t\t\t int bpc, bool has_hdmi_sink,\n\t\t\t\t\t enum intel_output_format sink_format)\n{\n\tconst struct drm_display_info *info = &connector->display_info;\n\tconst struct drm_hdmi_info *hdmi = &info->hdmi;\n\n\tswitch (bpc) {\n\tcase 12:\n\t\tif (!has_hdmi_sink)\n\t\t\treturn false;\n\n\t\tif (sink_format == INTEL_OUTPUT_FORMAT_YCBCR420)\n\t\t\treturn hdmi->y420_dc_modes & DRM_EDID_YCBCR420_DC_36;\n\t\telse\n\t\t\treturn info->edid_hdmi_rgb444_dc_modes & DRM_EDID_HDMI_DC_36;\n\tcase 10:\n\t\tif (!has_hdmi_sink)\n\t\t\treturn false;\n\n\t\tif (sink_format == INTEL_OUTPUT_FORMAT_YCBCR420)\n\t\t\treturn hdmi->y420_dc_modes & DRM_EDID_YCBCR420_DC_30;\n\t\telse\n\t\t\treturn info->edid_hdmi_rgb444_dc_modes & DRM_EDID_HDMI_DC_30;\n\tcase 8:\n\t\treturn true;\n\tdefault:\n\t\tMISSING_CASE(bpc);\n\t\treturn false;\n\t}\n}\n\nstatic enum drm_mode_status\nintel_hdmi_mode_clock_valid(struct drm_connector *connector, int clock,\n\t\t\t    bool has_hdmi_sink,\n\t\t\t    enum intel_output_format sink_format)\n{\n\tstruct drm_i915_private *i915 = to_i915(connector->dev);\n\tstruct intel_hdmi *hdmi = intel_attached_hdmi(to_intel_connector(connector));\n\tenum drm_mode_status status = MODE_OK;\n\tint bpc;\n\n\t \n\tfor (bpc = 12; bpc >= 8; bpc -= 2) {\n\t\tint tmds_clock = intel_hdmi_tmds_clock(clock, bpc, sink_format);\n\n\t\tif (!intel_hdmi_source_bpc_possible(i915, bpc))\n\t\t\tcontinue;\n\n\t\tif (!intel_hdmi_sink_bpc_possible(connector, bpc, has_hdmi_sink, sink_format))\n\t\t\tcontinue;\n\n\t\tstatus = hdmi_port_clock_valid(hdmi, tmds_clock, true, has_hdmi_sink);\n\t\tif (status == MODE_OK)\n\t\t\treturn MODE_OK;\n\t}\n\n\t \n\tdrm_WARN_ON(&i915->drm, status == MODE_OK);\n\n\treturn status;\n}\n\nstatic enum drm_mode_status\nintel_hdmi_mode_valid(struct drm_connector *connector,\n\t\t      struct drm_display_mode *mode)\n{\n\tstruct intel_hdmi *hdmi = intel_attached_hdmi(to_intel_connector(connector));\n\tstruct drm_i915_private *dev_priv = intel_hdmi_to_i915(hdmi);\n\tenum drm_mode_status status;\n\tint clock = mode->clock;\n\tint max_dotclk = to_i915(connector->dev)->max_dotclk_freq;\n\tbool has_hdmi_sink = intel_has_hdmi_sink(hdmi, connector->state);\n\tbool ycbcr_420_only;\n\tenum intel_output_format sink_format;\n\n\tstatus = intel_cpu_transcoder_mode_valid(dev_priv, mode);\n\tif (status != MODE_OK)\n\t\treturn status;\n\n\tif ((mode->flags & DRM_MODE_FLAG_3D_MASK) == DRM_MODE_FLAG_3D_FRAME_PACKING)\n\t\tclock *= 2;\n\n\tif (clock > max_dotclk)\n\t\treturn MODE_CLOCK_HIGH;\n\n\tif (mode->flags & DRM_MODE_FLAG_DBLCLK) {\n\t\tif (!has_hdmi_sink)\n\t\t\treturn MODE_CLOCK_LOW;\n\t\tclock *= 2;\n\t}\n\n\t \n\tif (clock > 600000)\n\t\treturn MODE_CLOCK_HIGH;\n\n\tycbcr_420_only = drm_mode_is_420_only(&connector->display_info, mode);\n\n\tif (ycbcr_420_only)\n\t\tsink_format = INTEL_OUTPUT_FORMAT_YCBCR420;\n\telse\n\t\tsink_format = INTEL_OUTPUT_FORMAT_RGB;\n\n\tstatus = intel_hdmi_mode_clock_valid(connector, clock, has_hdmi_sink, sink_format);\n\tif (status != MODE_OK) {\n\t\tif (ycbcr_420_only ||\n\t\t    !connector->ycbcr_420_allowed ||\n\t\t    !drm_mode_is_420_also(&connector->display_info, mode))\n\t\t\treturn status;\n\n\t\tsink_format = INTEL_OUTPUT_FORMAT_YCBCR420;\n\t\tstatus = intel_hdmi_mode_clock_valid(connector, clock, has_hdmi_sink, sink_format);\n\t\tif (status != MODE_OK)\n\t\t\treturn status;\n\t}\n\n\treturn intel_mode_valid_max_plane_size(dev_priv, mode, false);\n}\n\nbool intel_hdmi_bpc_possible(const struct intel_crtc_state *crtc_state,\n\t\t\t     int bpc, bool has_hdmi_sink)\n{\n\tstruct drm_atomic_state *state = crtc_state->uapi.state;\n\tstruct drm_connector_state *connector_state;\n\tstruct drm_connector *connector;\n\tint i;\n\n\tfor_each_new_connector_in_state(state, connector, connector_state, i) {\n\t\tif (connector_state->crtc != crtc_state->uapi.crtc)\n\t\t\tcontinue;\n\n\t\tif (!intel_hdmi_sink_bpc_possible(connector, bpc, has_hdmi_sink,\n\t\t\t\t\t\t  crtc_state->sink_format))\n\t\t\treturn false;\n\t}\n\n\treturn true;\n}\n\nstatic bool hdmi_bpc_possible(const struct intel_crtc_state *crtc_state, int bpc)\n{\n\tstruct drm_i915_private *dev_priv =\n\t\tto_i915(crtc_state->uapi.crtc->dev);\n\tconst struct drm_display_mode *adjusted_mode =\n\t\t&crtc_state->hw.adjusted_mode;\n\n\tif (!intel_hdmi_source_bpc_possible(dev_priv, bpc))\n\t\treturn false;\n\n\t \n\tif (intel_hdmi_is_ycbcr420(crtc_state) &&\n\t    bpc == 10 && DISPLAY_VER(dev_priv) == 11 &&\n\t    (adjusted_mode->crtc_hblank_end -\n\t     adjusted_mode->crtc_hblank_start) % 8 == 2)\n\t\treturn false;\n\n\treturn intel_hdmi_bpc_possible(crtc_state, bpc, crtc_state->has_hdmi_sink);\n}\n\nstatic int intel_hdmi_compute_bpc(struct intel_encoder *encoder,\n\t\t\t\t  struct intel_crtc_state *crtc_state,\n\t\t\t\t  int clock, bool respect_downstream_limits)\n{\n\tstruct intel_hdmi *intel_hdmi = enc_to_intel_hdmi(encoder);\n\tint bpc;\n\n\t \n\tbpc = max(crtc_state->pipe_bpp / 3, 8);\n\n\t \n\tif (!respect_downstream_limits)\n\t\tbpc = 8;\n\n\tfor (; bpc >= 8; bpc -= 2) {\n\t\tint tmds_clock = intel_hdmi_tmds_clock(clock, bpc,\n\t\t\t\t\t\t       crtc_state->sink_format);\n\n\t\tif (hdmi_bpc_possible(crtc_state, bpc) &&\n\t\t    hdmi_port_clock_valid(intel_hdmi, tmds_clock,\n\t\t\t\t\t  respect_downstream_limits,\n\t\t\t\t\t  crtc_state->has_hdmi_sink) == MODE_OK)\n\t\t\treturn bpc;\n\t}\n\n\treturn -EINVAL;\n}\n\nstatic int intel_hdmi_compute_clock(struct intel_encoder *encoder,\n\t\t\t\t    struct intel_crtc_state *crtc_state,\n\t\t\t\t    bool respect_downstream_limits)\n{\n\tstruct drm_i915_private *i915 = to_i915(encoder->base.dev);\n\tconst struct drm_display_mode *adjusted_mode =\n\t\t&crtc_state->hw.adjusted_mode;\n\tint bpc, clock = adjusted_mode->crtc_clock;\n\n\tif (adjusted_mode->flags & DRM_MODE_FLAG_DBLCLK)\n\t\tclock *= 2;\n\n\tbpc = intel_hdmi_compute_bpc(encoder, crtc_state, clock,\n\t\t\t\t     respect_downstream_limits);\n\tif (bpc < 0)\n\t\treturn bpc;\n\n\tcrtc_state->port_clock =\n\t\tintel_hdmi_tmds_clock(clock, bpc, crtc_state->sink_format);\n\n\t \n\tcrtc_state->pipe_bpp = min(crtc_state->pipe_bpp, bpc * 3);\n\n\tdrm_dbg_kms(&i915->drm,\n\t\t    \"picking %d bpc for HDMI output (pipe bpp: %d)\\n\",\n\t\t    bpc, crtc_state->pipe_bpp);\n\n\treturn 0;\n}\n\nbool intel_hdmi_limited_color_range(const struct intel_crtc_state *crtc_state,\n\t\t\t\t    const struct drm_connector_state *conn_state)\n{\n\tconst struct intel_digital_connector_state *intel_conn_state =\n\t\tto_intel_digital_connector_state(conn_state);\n\tconst struct drm_display_mode *adjusted_mode =\n\t\t&crtc_state->hw.adjusted_mode;\n\n\t \n\tif (crtc_state->output_format != INTEL_OUTPUT_FORMAT_RGB)\n\t\treturn false;\n\n\tif (intel_conn_state->broadcast_rgb == INTEL_BROADCAST_RGB_AUTO) {\n\t\t \n\t\treturn crtc_state->has_hdmi_sink &&\n\t\t\tdrm_default_rgb_quant_range(adjusted_mode) ==\n\t\t\tHDMI_QUANTIZATION_RANGE_LIMITED;\n\t} else {\n\t\treturn intel_conn_state->broadcast_rgb == INTEL_BROADCAST_RGB_LIMITED;\n\t}\n}\n\nstatic bool intel_hdmi_has_audio(struct intel_encoder *encoder,\n\t\t\t\t const struct intel_crtc_state *crtc_state,\n\t\t\t\t const struct drm_connector_state *conn_state)\n{\n\tstruct drm_connector *connector = conn_state->connector;\n\tconst struct intel_digital_connector_state *intel_conn_state =\n\t\tto_intel_digital_connector_state(conn_state);\n\n\tif (!crtc_state->has_hdmi_sink)\n\t\treturn false;\n\n\tif (intel_conn_state->force_audio == HDMI_AUDIO_AUTO)\n\t\treturn connector->display_info.has_audio;\n\telse\n\t\treturn intel_conn_state->force_audio == HDMI_AUDIO_ON;\n}\n\nstatic enum intel_output_format\nintel_hdmi_sink_format(const struct intel_crtc_state *crtc_state,\n\t\t       struct intel_connector *connector,\n\t\t       bool ycbcr_420_output)\n{\n\tif (!crtc_state->has_hdmi_sink)\n\t\treturn INTEL_OUTPUT_FORMAT_RGB;\n\n\tif (connector->base.ycbcr_420_allowed && ycbcr_420_output)\n\t\treturn INTEL_OUTPUT_FORMAT_YCBCR420;\n\telse\n\t\treturn INTEL_OUTPUT_FORMAT_RGB;\n}\n\nstatic enum intel_output_format\nintel_hdmi_output_format(const struct intel_crtc_state *crtc_state)\n{\n\treturn crtc_state->sink_format;\n}\n\nstatic int intel_hdmi_compute_output_format(struct intel_encoder *encoder,\n\t\t\t\t\t    struct intel_crtc_state *crtc_state,\n\t\t\t\t\t    const struct drm_connector_state *conn_state,\n\t\t\t\t\t    bool respect_downstream_limits)\n{\n\tstruct intel_connector *connector = to_intel_connector(conn_state->connector);\n\tconst struct drm_display_mode *adjusted_mode = &crtc_state->hw.adjusted_mode;\n\tconst struct drm_display_info *info = &connector->base.display_info;\n\tstruct drm_i915_private *i915 = to_i915(connector->base.dev);\n\tbool ycbcr_420_only = drm_mode_is_420_only(info, adjusted_mode);\n\tint ret;\n\n\tcrtc_state->sink_format =\n\t\tintel_hdmi_sink_format(crtc_state, connector, ycbcr_420_only);\n\n\tif (ycbcr_420_only && crtc_state->sink_format != INTEL_OUTPUT_FORMAT_YCBCR420) {\n\t\tdrm_dbg_kms(&i915->drm,\n\t\t\t    \"YCbCr 4:2:0 mode but YCbCr 4:2:0 output not possible. Falling back to RGB.\\n\");\n\t\tcrtc_state->sink_format = INTEL_OUTPUT_FORMAT_RGB;\n\t}\n\n\tcrtc_state->output_format = intel_hdmi_output_format(crtc_state);\n\tret = intel_hdmi_compute_clock(encoder, crtc_state, respect_downstream_limits);\n\tif (ret) {\n\t\tif (crtc_state->sink_format == INTEL_OUTPUT_FORMAT_YCBCR420 ||\n\t\t    !crtc_state->has_hdmi_sink ||\n\t\t    !connector->base.ycbcr_420_allowed ||\n\t\t    !drm_mode_is_420_also(info, adjusted_mode))\n\t\t\treturn ret;\n\n\t\tcrtc_state->sink_format = INTEL_OUTPUT_FORMAT_YCBCR420;\n\t\tcrtc_state->output_format = intel_hdmi_output_format(crtc_state);\n\t\tret = intel_hdmi_compute_clock(encoder, crtc_state, respect_downstream_limits);\n\t}\n\n\treturn ret;\n}\n\nstatic bool intel_hdmi_is_cloned(const struct intel_crtc_state *crtc_state)\n{\n\treturn crtc_state->uapi.encoder_mask &&\n\t\t!is_power_of_2(crtc_state->uapi.encoder_mask);\n}\n\nstatic bool source_supports_scrambling(struct intel_encoder *encoder)\n{\n\t \n\treturn intel_hdmi_source_max_tmds_clock(encoder) > 340000;\n}\n\nbool intel_hdmi_compute_has_hdmi_sink(struct intel_encoder *encoder,\n\t\t\t\t      const struct intel_crtc_state *crtc_state,\n\t\t\t\t      const struct drm_connector_state *conn_state)\n{\n\tstruct intel_hdmi *hdmi = enc_to_intel_hdmi(encoder);\n\n\treturn intel_has_hdmi_sink(hdmi, conn_state) &&\n\t\t!intel_hdmi_is_cloned(crtc_state);\n}\n\nint intel_hdmi_compute_config(struct intel_encoder *encoder,\n\t\t\t      struct intel_crtc_state *pipe_config,\n\t\t\t      struct drm_connector_state *conn_state)\n{\n\tstruct drm_i915_private *dev_priv = to_i915(encoder->base.dev);\n\tstruct drm_display_mode *adjusted_mode = &pipe_config->hw.adjusted_mode;\n\tstruct drm_connector *connector = conn_state->connector;\n\tstruct drm_scdc *scdc = &connector->display_info.hdmi.scdc;\n\tint ret;\n\n\tif (adjusted_mode->flags & DRM_MODE_FLAG_DBLSCAN)\n\t\treturn -EINVAL;\n\n\tif (!connector->interlace_allowed &&\n\t    adjusted_mode->flags & DRM_MODE_FLAG_INTERLACE)\n\t\treturn -EINVAL;\n\n\tpipe_config->output_format = INTEL_OUTPUT_FORMAT_RGB;\n\n\tif (pipe_config->has_hdmi_sink)\n\t\tpipe_config->has_infoframe = true;\n\n\tif (adjusted_mode->flags & DRM_MODE_FLAG_DBLCLK)\n\t\tpipe_config->pixel_multiplier = 2;\n\n\tpipe_config->has_audio =\n\t\tintel_hdmi_has_audio(encoder, pipe_config, conn_state) &&\n\t\tintel_audio_compute_config(encoder, pipe_config, conn_state);\n\n\t \n\tret = intel_hdmi_compute_output_format(encoder, pipe_config, conn_state, true);\n\tif (ret)\n\t\tret = intel_hdmi_compute_output_format(encoder, pipe_config, conn_state, false);\n\tif (ret) {\n\t\tdrm_dbg_kms(&dev_priv->drm,\n\t\t\t    \"unsupported HDMI clock (%d kHz), rejecting mode\\n\",\n\t\t\t    pipe_config->hw.adjusted_mode.crtc_clock);\n\t\treturn ret;\n\t}\n\n\tif (intel_hdmi_is_ycbcr420(pipe_config)) {\n\t\tret = intel_panel_fitting(pipe_config, conn_state);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tpipe_config->limited_color_range =\n\t\tintel_hdmi_limited_color_range(pipe_config, conn_state);\n\n\tif (conn_state->picture_aspect_ratio)\n\t\tadjusted_mode->picture_aspect_ratio =\n\t\t\tconn_state->picture_aspect_ratio;\n\n\tpipe_config->lane_count = 4;\n\n\tif (scdc->scrambling.supported && source_supports_scrambling(encoder)) {\n\t\tif (scdc->scrambling.low_rates)\n\t\t\tpipe_config->hdmi_scrambling = true;\n\n\t\tif (pipe_config->port_clock > 340000) {\n\t\t\tpipe_config->hdmi_scrambling = true;\n\t\t\tpipe_config->hdmi_high_tmds_clock_ratio = true;\n\t\t}\n\t}\n\n\tintel_hdmi_compute_gcp_infoframe(encoder, pipe_config,\n\t\t\t\t\t conn_state);\n\n\tif (!intel_hdmi_compute_avi_infoframe(encoder, pipe_config, conn_state)) {\n\t\tdrm_dbg_kms(&dev_priv->drm, \"bad AVI infoframe\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (!intel_hdmi_compute_spd_infoframe(encoder, pipe_config, conn_state)) {\n\t\tdrm_dbg_kms(&dev_priv->drm, \"bad SPD infoframe\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (!intel_hdmi_compute_hdmi_infoframe(encoder, pipe_config, conn_state)) {\n\t\tdrm_dbg_kms(&dev_priv->drm, \"bad HDMI infoframe\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (!intel_hdmi_compute_drm_infoframe(encoder, pipe_config, conn_state)) {\n\t\tdrm_dbg_kms(&dev_priv->drm, \"bad DRM infoframe\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nvoid intel_hdmi_encoder_shutdown(struct intel_encoder *encoder)\n{\n\tstruct intel_hdmi *intel_hdmi = enc_to_intel_hdmi(encoder);\n\n\t \n\tintel_dp_dual_mode_set_tmds_output(intel_hdmi, true);\n}\n\nstatic void\nintel_hdmi_unset_edid(struct drm_connector *connector)\n{\n\tstruct intel_hdmi *intel_hdmi = intel_attached_hdmi(to_intel_connector(connector));\n\n\tintel_hdmi->dp_dual_mode.type = DRM_DP_DUAL_MODE_NONE;\n\tintel_hdmi->dp_dual_mode.max_tmds_clock = 0;\n\n\tdrm_edid_free(to_intel_connector(connector)->detect_edid);\n\tto_intel_connector(connector)->detect_edid = NULL;\n}\n\nstatic void\nintel_hdmi_dp_dual_mode_detect(struct drm_connector *connector)\n{\n\tstruct drm_i915_private *dev_priv = to_i915(connector->dev);\n\tstruct intel_hdmi *hdmi = intel_attached_hdmi(to_intel_connector(connector));\n\tstruct intel_encoder *encoder = &hdmi_to_dig_port(hdmi)->base;\n\tstruct i2c_adapter *adapter =\n\t\tintel_gmbus_get_adapter(dev_priv, hdmi->ddc_bus);\n\tenum drm_dp_dual_mode_type type = drm_dp_dual_mode_detect(&dev_priv->drm, adapter);\n\n\t \n\tif (type == DRM_DP_DUAL_MODE_UNKNOWN) {\n\t\tif (!connector->force &&\n\t\t    intel_bios_encoder_supports_dp_dual_mode(encoder->devdata)) {\n\t\t\tdrm_dbg_kms(&dev_priv->drm,\n\t\t\t\t    \"Assuming DP dual mode adaptor presence based on VBT\\n\");\n\t\t\ttype = DRM_DP_DUAL_MODE_TYPE1_DVI;\n\t\t} else {\n\t\t\ttype = DRM_DP_DUAL_MODE_NONE;\n\t\t}\n\t}\n\n\tif (type == DRM_DP_DUAL_MODE_NONE)\n\t\treturn;\n\n\thdmi->dp_dual_mode.type = type;\n\thdmi->dp_dual_mode.max_tmds_clock =\n\t\tdrm_dp_dual_mode_max_tmds_clock(&dev_priv->drm, type, adapter);\n\n\tdrm_dbg_kms(&dev_priv->drm,\n\t\t    \"DP dual mode adaptor (%s) detected (max TMDS clock: %d kHz)\\n\",\n\t\t    drm_dp_get_dual_mode_type_name(type),\n\t\t    hdmi->dp_dual_mode.max_tmds_clock);\n\n\t \n\tif ((DISPLAY_VER(dev_priv) >= 8 || IS_HASWELL(dev_priv)) &&\n\t    !intel_bios_encoder_supports_dp_dual_mode(encoder->devdata)) {\n\t\tdrm_dbg_kms(&dev_priv->drm,\n\t\t\t    \"Ignoring DP dual mode adaptor max TMDS clock for native HDMI port\\n\");\n\t\thdmi->dp_dual_mode.max_tmds_clock = 0;\n\t}\n}\n\nstatic bool\nintel_hdmi_set_edid(struct drm_connector *connector)\n{\n\tstruct drm_i915_private *dev_priv = to_i915(connector->dev);\n\tstruct intel_hdmi *intel_hdmi = intel_attached_hdmi(to_intel_connector(connector));\n\tintel_wakeref_t wakeref;\n\tconst struct drm_edid *drm_edid;\n\tconst struct edid *edid;\n\tbool connected = false;\n\tstruct i2c_adapter *i2c;\n\n\twakeref = intel_display_power_get(dev_priv, POWER_DOMAIN_GMBUS);\n\n\ti2c = intel_gmbus_get_adapter(dev_priv, intel_hdmi->ddc_bus);\n\n\tdrm_edid = drm_edid_read_ddc(connector, i2c);\n\n\tif (!drm_edid && !intel_gmbus_is_forced_bit(i2c)) {\n\t\tdrm_dbg_kms(&dev_priv->drm,\n\t\t\t    \"HDMI GMBUS EDID read failed, retry using GPIO bit-banging\\n\");\n\t\tintel_gmbus_force_bit(i2c, true);\n\t\tdrm_edid = drm_edid_read_ddc(connector, i2c);\n\t\tintel_gmbus_force_bit(i2c, false);\n\t}\n\n\t \n\tdrm_edid_connector_update(connector, drm_edid);\n\n\tto_intel_connector(connector)->detect_edid = drm_edid;\n\n\t \n\tedid = drm_edid_raw(drm_edid);\n\tif (edid && edid->input & DRM_EDID_INPUT_DIGITAL) {\n\t\tintel_hdmi_dp_dual_mode_detect(connector);\n\n\t\tconnected = true;\n\t}\n\n\tintel_display_power_put(dev_priv, POWER_DOMAIN_GMBUS, wakeref);\n\n\tcec_notifier_set_phys_addr_from_edid(intel_hdmi->cec_notifier, edid);\n\n\treturn connected;\n}\n\nstatic enum drm_connector_status\nintel_hdmi_detect(struct drm_connector *connector, bool force)\n{\n\tenum drm_connector_status status = connector_status_disconnected;\n\tstruct drm_i915_private *dev_priv = to_i915(connector->dev);\n\tstruct intel_hdmi *intel_hdmi = intel_attached_hdmi(to_intel_connector(connector));\n\tstruct intel_encoder *encoder = &hdmi_to_dig_port(intel_hdmi)->base;\n\tintel_wakeref_t wakeref;\n\n\tdrm_dbg_kms(&dev_priv->drm, \"[CONNECTOR:%d:%s]\\n\",\n\t\t    connector->base.id, connector->name);\n\n\tif (!INTEL_DISPLAY_ENABLED(dev_priv))\n\t\treturn connector_status_disconnected;\n\n\twakeref = intel_display_power_get(dev_priv, POWER_DOMAIN_GMBUS);\n\n\tif (DISPLAY_VER(dev_priv) >= 11 &&\n\t    !intel_digital_port_connected(encoder))\n\t\tgoto out;\n\n\tintel_hdmi_unset_edid(connector);\n\n\tif (intel_hdmi_set_edid(connector))\n\t\tstatus = connector_status_connected;\n\nout:\n\tintel_display_power_put(dev_priv, POWER_DOMAIN_GMBUS, wakeref);\n\n\tif (status != connector_status_connected)\n\t\tcec_notifier_phys_addr_invalidate(intel_hdmi->cec_notifier);\n\n\t \n\tintel_display_power_flush_work(dev_priv);\n\n\treturn status;\n}\n\nstatic void\nintel_hdmi_force(struct drm_connector *connector)\n{\n\tstruct drm_i915_private *i915 = to_i915(connector->dev);\n\n\tdrm_dbg_kms(&i915->drm, \"[CONNECTOR:%d:%s]\\n\",\n\t\t    connector->base.id, connector->name);\n\n\tintel_hdmi_unset_edid(connector);\n\n\tif (connector->status != connector_status_connected)\n\t\treturn;\n\n\tintel_hdmi_set_edid(connector);\n}\n\nstatic int intel_hdmi_get_modes(struct drm_connector *connector)\n{\n\t \n\treturn drm_edid_connector_add_modes(connector);\n}\n\nstatic struct i2c_adapter *\nintel_hdmi_get_i2c_adapter(struct drm_connector *connector)\n{\n\tstruct drm_i915_private *dev_priv = to_i915(connector->dev);\n\tstruct intel_hdmi *intel_hdmi = intel_attached_hdmi(to_intel_connector(connector));\n\n\treturn intel_gmbus_get_adapter(dev_priv, intel_hdmi->ddc_bus);\n}\n\nstatic void intel_hdmi_create_i2c_symlink(struct drm_connector *connector)\n{\n\tstruct drm_i915_private *i915 = to_i915(connector->dev);\n\tstruct i2c_adapter *adapter = intel_hdmi_get_i2c_adapter(connector);\n\tstruct kobject *i2c_kobj = &adapter->dev.kobj;\n\tstruct kobject *connector_kobj = &connector->kdev->kobj;\n\tint ret;\n\n\tret = sysfs_create_link(connector_kobj, i2c_kobj, i2c_kobj->name);\n\tif (ret)\n\t\tdrm_err(&i915->drm, \"Failed to create i2c symlink (%d)\\n\", ret);\n}\n\nstatic void intel_hdmi_remove_i2c_symlink(struct drm_connector *connector)\n{\n\tstruct i2c_adapter *adapter = intel_hdmi_get_i2c_adapter(connector);\n\tstruct kobject *i2c_kobj = &adapter->dev.kobj;\n\tstruct kobject *connector_kobj = &connector->kdev->kobj;\n\n\tsysfs_remove_link(connector_kobj, i2c_kobj->name);\n}\n\nstatic int\nintel_hdmi_connector_register(struct drm_connector *connector)\n{\n\tint ret;\n\n\tret = intel_connector_register(connector);\n\tif (ret)\n\t\treturn ret;\n\n\tintel_hdmi_create_i2c_symlink(connector);\n\n\treturn ret;\n}\n\nstatic void intel_hdmi_connector_unregister(struct drm_connector *connector)\n{\n\tstruct cec_notifier *n = intel_attached_hdmi(to_intel_connector(connector))->cec_notifier;\n\n\tcec_notifier_conn_unregister(n);\n\n\tintel_hdmi_remove_i2c_symlink(connector);\n\tintel_connector_unregister(connector);\n}\n\nstatic const struct drm_connector_funcs intel_hdmi_connector_funcs = {\n\t.detect = intel_hdmi_detect,\n\t.force = intel_hdmi_force,\n\t.fill_modes = drm_helper_probe_single_connector_modes,\n\t.atomic_get_property = intel_digital_connector_atomic_get_property,\n\t.atomic_set_property = intel_digital_connector_atomic_set_property,\n\t.late_register = intel_hdmi_connector_register,\n\t.early_unregister = intel_hdmi_connector_unregister,\n\t.destroy = intel_connector_destroy,\n\t.atomic_destroy_state = drm_atomic_helper_connector_destroy_state,\n\t.atomic_duplicate_state = intel_digital_connector_duplicate_state,\n};\n\nstatic int intel_hdmi_connector_atomic_check(struct drm_connector *connector,\n\t\t\t\t\t     struct drm_atomic_state *state)\n{\n\tstruct drm_i915_private *i915 = to_i915(state->dev);\n\n\tif (HAS_DDI(i915))\n\t\treturn intel_digital_connector_atomic_check(connector, state);\n\telse\n\t\treturn g4x_hdmi_connector_atomic_check(connector, state);\n}\n\nstatic const struct drm_connector_helper_funcs intel_hdmi_connector_helper_funcs = {\n\t.get_modes = intel_hdmi_get_modes,\n\t.mode_valid = intel_hdmi_mode_valid,\n\t.atomic_check = intel_hdmi_connector_atomic_check,\n};\n\nstatic void\nintel_hdmi_add_properties(struct intel_hdmi *intel_hdmi, struct drm_connector *connector)\n{\n\tstruct drm_i915_private *dev_priv = to_i915(connector->dev);\n\n\tintel_attach_force_audio_property(connector);\n\tintel_attach_broadcast_rgb_property(connector);\n\tintel_attach_aspect_ratio_property(connector);\n\n\tintel_attach_hdmi_colorspace_property(connector);\n\tdrm_connector_attach_content_type_property(connector);\n\n\tif (DISPLAY_VER(dev_priv) >= 10)\n\t\tdrm_connector_attach_hdr_output_metadata_property(connector);\n\n\tif (!HAS_GMCH(dev_priv))\n\t\tdrm_connector_attach_max_bpc_property(connector, 8, 12);\n}\n\n \nbool intel_hdmi_handle_sink_scrambling(struct intel_encoder *encoder,\n\t\t\t\t       struct drm_connector *connector,\n\t\t\t\t       bool high_tmds_clock_ratio,\n\t\t\t\t       bool scrambling)\n{\n\tstruct drm_i915_private *dev_priv = to_i915(encoder->base.dev);\n\tstruct drm_scrambling *sink_scrambling =\n\t\t&connector->display_info.hdmi.scdc.scrambling;\n\n\tif (!sink_scrambling->supported)\n\t\treturn true;\n\n\tdrm_dbg_kms(&dev_priv->drm,\n\t\t    \"[CONNECTOR:%d:%s] scrambling=%s, TMDS bit clock ratio=1/%d\\n\",\n\t\t    connector->base.id, connector->name,\n\t\t    str_yes_no(scrambling), high_tmds_clock_ratio ? 40 : 10);\n\n\t \n\treturn drm_scdc_set_high_tmds_clock_ratio(connector, high_tmds_clock_ratio) &&\n\t\tdrm_scdc_set_scrambling(connector, scrambling);\n}\n\nstatic u8 chv_port_to_ddc_pin(struct drm_i915_private *dev_priv, enum port port)\n{\n\tu8 ddc_pin;\n\n\tswitch (port) {\n\tcase PORT_B:\n\t\tddc_pin = GMBUS_PIN_DPB;\n\t\tbreak;\n\tcase PORT_C:\n\t\tddc_pin = GMBUS_PIN_DPC;\n\t\tbreak;\n\tcase PORT_D:\n\t\tddc_pin = GMBUS_PIN_DPD_CHV;\n\t\tbreak;\n\tdefault:\n\t\tMISSING_CASE(port);\n\t\tddc_pin = GMBUS_PIN_DPB;\n\t\tbreak;\n\t}\n\treturn ddc_pin;\n}\n\nstatic u8 bxt_port_to_ddc_pin(struct drm_i915_private *dev_priv, enum port port)\n{\n\tu8 ddc_pin;\n\n\tswitch (port) {\n\tcase PORT_B:\n\t\tddc_pin = GMBUS_PIN_1_BXT;\n\t\tbreak;\n\tcase PORT_C:\n\t\tddc_pin = GMBUS_PIN_2_BXT;\n\t\tbreak;\n\tdefault:\n\t\tMISSING_CASE(port);\n\t\tddc_pin = GMBUS_PIN_1_BXT;\n\t\tbreak;\n\t}\n\treturn ddc_pin;\n}\n\nstatic u8 cnp_port_to_ddc_pin(struct drm_i915_private *dev_priv,\n\t\t\t      enum port port)\n{\n\tu8 ddc_pin;\n\n\tswitch (port) {\n\tcase PORT_B:\n\t\tddc_pin = GMBUS_PIN_1_BXT;\n\t\tbreak;\n\tcase PORT_C:\n\t\tddc_pin = GMBUS_PIN_2_BXT;\n\t\tbreak;\n\tcase PORT_D:\n\t\tddc_pin = GMBUS_PIN_4_CNP;\n\t\tbreak;\n\tcase PORT_F:\n\t\tddc_pin = GMBUS_PIN_3_BXT;\n\t\tbreak;\n\tdefault:\n\t\tMISSING_CASE(port);\n\t\tddc_pin = GMBUS_PIN_1_BXT;\n\t\tbreak;\n\t}\n\treturn ddc_pin;\n}\n\nstatic u8 icl_port_to_ddc_pin(struct drm_i915_private *dev_priv, enum port port)\n{\n\tenum phy phy = intel_port_to_phy(dev_priv, port);\n\n\tif (intel_phy_is_combo(dev_priv, phy))\n\t\treturn GMBUS_PIN_1_BXT + port;\n\telse if (intel_phy_is_tc(dev_priv, phy))\n\t\treturn GMBUS_PIN_9_TC1_ICP + intel_port_to_tc(dev_priv, port);\n\n\tdrm_WARN(&dev_priv->drm, 1, \"Unknown port:%c\\n\", port_name(port));\n\treturn GMBUS_PIN_2_BXT;\n}\n\nstatic u8 mcc_port_to_ddc_pin(struct drm_i915_private *dev_priv, enum port port)\n{\n\tenum phy phy = intel_port_to_phy(dev_priv, port);\n\tu8 ddc_pin;\n\n\tswitch (phy) {\n\tcase PHY_A:\n\t\tddc_pin = GMBUS_PIN_1_BXT;\n\t\tbreak;\n\tcase PHY_B:\n\t\tddc_pin = GMBUS_PIN_2_BXT;\n\t\tbreak;\n\tcase PHY_C:\n\t\tddc_pin = GMBUS_PIN_9_TC1_ICP;\n\t\tbreak;\n\tdefault:\n\t\tMISSING_CASE(phy);\n\t\tddc_pin = GMBUS_PIN_1_BXT;\n\t\tbreak;\n\t}\n\treturn ddc_pin;\n}\n\nstatic u8 rkl_port_to_ddc_pin(struct drm_i915_private *dev_priv, enum port port)\n{\n\tenum phy phy = intel_port_to_phy(dev_priv, port);\n\n\tWARN_ON(port == PORT_C);\n\n\t \n\tif (INTEL_PCH_TYPE(dev_priv) >= PCH_TGP && phy >= PHY_C)\n\t\treturn GMBUS_PIN_9_TC1_ICP + phy - PHY_C;\n\n\treturn GMBUS_PIN_1_BXT + phy;\n}\n\nstatic u8 gen9bc_tgp_port_to_ddc_pin(struct drm_i915_private *i915, enum port port)\n{\n\tenum phy phy = intel_port_to_phy(i915, port);\n\n\tdrm_WARN_ON(&i915->drm, port == PORT_A);\n\n\t \n\tif (INTEL_PCH_TYPE(i915) >= PCH_TGP && phy >= PHY_C)\n\t\treturn GMBUS_PIN_9_TC1_ICP + phy - PHY_C;\n\n\treturn GMBUS_PIN_1_BXT + phy;\n}\n\nstatic u8 dg1_port_to_ddc_pin(struct drm_i915_private *dev_priv, enum port port)\n{\n\treturn intel_port_to_phy(dev_priv, port) + 1;\n}\n\nstatic u8 adls_port_to_ddc_pin(struct drm_i915_private *dev_priv, enum port port)\n{\n\tenum phy phy = intel_port_to_phy(dev_priv, port);\n\n\tWARN_ON(port == PORT_B || port == PORT_C);\n\n\t \n\tif (phy == PHY_A)\n\t\treturn GMBUS_PIN_1_BXT;\n\n\treturn GMBUS_PIN_9_TC1_ICP + phy - PHY_B;\n}\n\nstatic u8 g4x_port_to_ddc_pin(struct drm_i915_private *dev_priv,\n\t\t\t      enum port port)\n{\n\tu8 ddc_pin;\n\n\tswitch (port) {\n\tcase PORT_B:\n\t\tddc_pin = GMBUS_PIN_DPB;\n\t\tbreak;\n\tcase PORT_C:\n\t\tddc_pin = GMBUS_PIN_DPC;\n\t\tbreak;\n\tcase PORT_D:\n\t\tddc_pin = GMBUS_PIN_DPD;\n\t\tbreak;\n\tdefault:\n\t\tMISSING_CASE(port);\n\t\tddc_pin = GMBUS_PIN_DPB;\n\t\tbreak;\n\t}\n\treturn ddc_pin;\n}\n\nstatic u8 intel_hdmi_default_ddc_pin(struct intel_encoder *encoder)\n{\n\tstruct drm_i915_private *dev_priv = to_i915(encoder->base.dev);\n\tenum port port = encoder->port;\n\tu8 ddc_pin;\n\n\tif (IS_ALDERLAKE_S(dev_priv))\n\t\tddc_pin = adls_port_to_ddc_pin(dev_priv, port);\n\telse if (INTEL_PCH_TYPE(dev_priv) >= PCH_DG1)\n\t\tddc_pin = dg1_port_to_ddc_pin(dev_priv, port);\n\telse if (IS_ROCKETLAKE(dev_priv))\n\t\tddc_pin = rkl_port_to_ddc_pin(dev_priv, port);\n\telse if (DISPLAY_VER(dev_priv) == 9 && HAS_PCH_TGP(dev_priv))\n\t\tddc_pin = gen9bc_tgp_port_to_ddc_pin(dev_priv, port);\n\telse if ((IS_JASPERLAKE(dev_priv) || IS_ELKHARTLAKE(dev_priv)) &&\n\t\t HAS_PCH_TGP(dev_priv))\n\t\tddc_pin = mcc_port_to_ddc_pin(dev_priv, port);\n\telse if (INTEL_PCH_TYPE(dev_priv) >= PCH_ICP)\n\t\tddc_pin = icl_port_to_ddc_pin(dev_priv, port);\n\telse if (HAS_PCH_CNP(dev_priv))\n\t\tddc_pin = cnp_port_to_ddc_pin(dev_priv, port);\n\telse if (IS_GEMINILAKE(dev_priv) || IS_BROXTON(dev_priv))\n\t\tddc_pin = bxt_port_to_ddc_pin(dev_priv, port);\n\telse if (IS_CHERRYVIEW(dev_priv))\n\t\tddc_pin = chv_port_to_ddc_pin(dev_priv, port);\n\telse\n\t\tddc_pin = g4x_port_to_ddc_pin(dev_priv, port);\n\n\treturn ddc_pin;\n}\n\nstatic struct intel_encoder *\nget_encoder_by_ddc_pin(struct intel_encoder *encoder, u8 ddc_pin)\n{\n\tstruct drm_i915_private *i915 = to_i915(encoder->base.dev);\n\tstruct intel_encoder *other;\n\n\tfor_each_intel_encoder(&i915->drm, other) {\n\t\tif (other == encoder)\n\t\t\tcontinue;\n\n\t\tif (!intel_encoder_is_dig_port(other))\n\t\t\tcontinue;\n\n\t\tif (enc_to_dig_port(other)->hdmi.ddc_bus == ddc_pin)\n\t\t\treturn other;\n\t}\n\n\treturn NULL;\n}\n\nstatic u8 intel_hdmi_ddc_pin(struct intel_encoder *encoder)\n{\n\tstruct drm_i915_private *i915 = to_i915(encoder->base.dev);\n\tstruct intel_encoder *other;\n\tconst char *source;\n\tu8 ddc_pin;\n\n\tddc_pin = intel_bios_hdmi_ddc_pin(encoder->devdata);\n\tsource = \"VBT\";\n\n\tif (!ddc_pin) {\n\t\tddc_pin = intel_hdmi_default_ddc_pin(encoder);\n\t\tsource = \"platform default\";\n\t}\n\n\tif (!intel_gmbus_is_valid_pin(i915, ddc_pin)) {\n\t\tdrm_dbg_kms(&i915->drm, \"[ENCODER:%d:%s] Invalid DDC pin %d\\n\",\n\t\t\t    encoder->base.base.id, encoder->base.name, ddc_pin);\n\t\treturn 0;\n\t}\n\n\tother = get_encoder_by_ddc_pin(encoder, ddc_pin);\n\tif (other) {\n\t\tdrm_dbg_kms(&i915->drm, \"[ENCODER:%d:%s] DDC pin %d already claimed by [ENCODER:%d:%s]\\n\",\n\t\t\t    encoder->base.base.id, encoder->base.name, ddc_pin,\n\t\t\t    other->base.base.id, other->base.name);\n\t\treturn 0;\n\t}\n\n\tdrm_dbg_kms(&i915->drm,\n\t\t    \"[ENCODER:%d:%s] Using DDC pin 0x%x (%s)\\n\",\n\t\t    encoder->base.base.id, encoder->base.name,\n\t\t    ddc_pin, source);\n\n\treturn ddc_pin;\n}\n\nvoid intel_infoframe_init(struct intel_digital_port *dig_port)\n{\n\tstruct drm_i915_private *dev_priv =\n\t\tto_i915(dig_port->base.base.dev);\n\n\tif (IS_VALLEYVIEW(dev_priv) || IS_CHERRYVIEW(dev_priv)) {\n\t\tdig_port->write_infoframe = vlv_write_infoframe;\n\t\tdig_port->read_infoframe = vlv_read_infoframe;\n\t\tdig_port->set_infoframes = vlv_set_infoframes;\n\t\tdig_port->infoframes_enabled = vlv_infoframes_enabled;\n\t} else if (IS_G4X(dev_priv)) {\n\t\tdig_port->write_infoframe = g4x_write_infoframe;\n\t\tdig_port->read_infoframe = g4x_read_infoframe;\n\t\tdig_port->set_infoframes = g4x_set_infoframes;\n\t\tdig_port->infoframes_enabled = g4x_infoframes_enabled;\n\t} else if (HAS_DDI(dev_priv)) {\n\t\tif (intel_bios_encoder_is_lspcon(dig_port->base.devdata)) {\n\t\t\tdig_port->write_infoframe = lspcon_write_infoframe;\n\t\t\tdig_port->read_infoframe = lspcon_read_infoframe;\n\t\t\tdig_port->set_infoframes = lspcon_set_infoframes;\n\t\t\tdig_port->infoframes_enabled = lspcon_infoframes_enabled;\n\t\t} else {\n\t\t\tdig_port->write_infoframe = hsw_write_infoframe;\n\t\t\tdig_port->read_infoframe = hsw_read_infoframe;\n\t\t\tdig_port->set_infoframes = hsw_set_infoframes;\n\t\t\tdig_port->infoframes_enabled = hsw_infoframes_enabled;\n\t\t}\n\t} else if (HAS_PCH_IBX(dev_priv)) {\n\t\tdig_port->write_infoframe = ibx_write_infoframe;\n\t\tdig_port->read_infoframe = ibx_read_infoframe;\n\t\tdig_port->set_infoframes = ibx_set_infoframes;\n\t\tdig_port->infoframes_enabled = ibx_infoframes_enabled;\n\t} else {\n\t\tdig_port->write_infoframe = cpt_write_infoframe;\n\t\tdig_port->read_infoframe = cpt_read_infoframe;\n\t\tdig_port->set_infoframes = cpt_set_infoframes;\n\t\tdig_port->infoframes_enabled = cpt_infoframes_enabled;\n\t}\n}\n\nvoid intel_hdmi_init_connector(struct intel_digital_port *dig_port,\n\t\t\t       struct intel_connector *intel_connector)\n{\n\tstruct drm_connector *connector = &intel_connector->base;\n\tstruct intel_hdmi *intel_hdmi = &dig_port->hdmi;\n\tstruct intel_encoder *intel_encoder = &dig_port->base;\n\tstruct drm_device *dev = intel_encoder->base.dev;\n\tstruct drm_i915_private *dev_priv = to_i915(dev);\n\tstruct i2c_adapter *ddc;\n\tenum port port = intel_encoder->port;\n\tstruct cec_connector_info conn_info;\n\n\tdrm_dbg_kms(&dev_priv->drm,\n\t\t    \"Adding HDMI connector on [ENCODER:%d:%s]\\n\",\n\t\t    intel_encoder->base.base.id, intel_encoder->base.name);\n\n\tif (DISPLAY_VER(dev_priv) < 12 && drm_WARN_ON(dev, port == PORT_A))\n\t\treturn;\n\n\tif (drm_WARN(dev, dig_port->max_lanes < 4,\n\t\t     \"Not enough lanes (%d) for HDMI on [ENCODER:%d:%s]\\n\",\n\t\t     dig_port->max_lanes, intel_encoder->base.base.id,\n\t\t     intel_encoder->base.name))\n\t\treturn;\n\n\tintel_hdmi->ddc_bus = intel_hdmi_ddc_pin(intel_encoder);\n\tif (!intel_hdmi->ddc_bus)\n\t\treturn;\n\n\tddc = intel_gmbus_get_adapter(dev_priv, intel_hdmi->ddc_bus);\n\n\tdrm_connector_init_with_ddc(dev, connector,\n\t\t\t\t    &intel_hdmi_connector_funcs,\n\t\t\t\t    DRM_MODE_CONNECTOR_HDMIA,\n\t\t\t\t    ddc);\n\tdrm_connector_helper_add(connector, &intel_hdmi_connector_helper_funcs);\n\n\tif (DISPLAY_VER(dev_priv) < 12)\n\t\tconnector->interlace_allowed = true;\n\n\tconnector->stereo_allowed = true;\n\n\tif (DISPLAY_VER(dev_priv) >= 10)\n\t\tconnector->ycbcr_420_allowed = true;\n\n\tintel_connector->polled = DRM_CONNECTOR_POLL_HPD;\n\n\tif (HAS_DDI(dev_priv))\n\t\tintel_connector->get_hw_state = intel_ddi_connector_get_hw_state;\n\telse\n\t\tintel_connector->get_hw_state = intel_connector_get_hw_state;\n\n\tintel_hdmi_add_properties(intel_hdmi, connector);\n\n\tintel_connector_attach_encoder(intel_connector, intel_encoder);\n\tintel_hdmi->attached_connector = intel_connector;\n\n\tif (is_hdcp_supported(dev_priv, port)) {\n\t\tint ret = intel_hdcp_init(intel_connector, dig_port,\n\t\t\t\t\t  &intel_hdmi_hdcp_shim);\n\t\tif (ret)\n\t\t\tdrm_dbg_kms(&dev_priv->drm,\n\t\t\t\t    \"HDCP init failed, skipping.\\n\");\n\t}\n\n\t \n\tif (IS_G45(dev_priv)) {\n\t\tu32 temp = intel_de_read(dev_priv, PEG_BAND_GAP_DATA);\n\t\tintel_de_write(dev_priv, PEG_BAND_GAP_DATA,\n\t\t               (temp & ~0xf) | 0xd);\n\t}\n\n\tcec_fill_conn_info_from_drm(&conn_info, connector);\n\n\tintel_hdmi->cec_notifier =\n\t\tcec_notifier_conn_register(dev->dev, port_identifier(port),\n\t\t\t\t\t   &conn_info);\n\tif (!intel_hdmi->cec_notifier)\n\t\tdrm_dbg_kms(&dev_priv->drm, \"CEC notifier get failed\\n\");\n}\n\n \nint intel_hdmi_dsc_get_slice_height(int vactive)\n{\n\tint slice_height;\n\n\t \n\tfor (slice_height = 96; slice_height <= vactive; slice_height += 2)\n\t\tif (vactive % slice_height == 0)\n\t\t\treturn slice_height;\n\n\treturn 0;\n}\n\n \nint\nintel_hdmi_dsc_get_num_slices(const struct intel_crtc_state *crtc_state,\n\t\t\t      int src_max_slices, int src_max_slice_width,\n\t\t\t      int hdmi_max_slices, int hdmi_throughput)\n{\n \n#define HDMI_DSC_PEAK_PIXEL_RATE\t\t2720000\n \n#define HDMI_DSC_MAX_ENC_THROUGHPUT_0\t\t340000\n#define HDMI_DSC_MAX_ENC_THROUGHPUT_1\t\t400000\n\n \n#define MAX_HDMI_SLICE_WIDTH\t\t\t2720\n\tint kslice_adjust;\n\tint adjusted_clk_khz;\n\tint min_slices;\n\tint target_slices;\n\tint max_throughput;  \n\tint max_slice_width;\n\tint slice_width;\n\tint pixel_clock = crtc_state->hw.adjusted_mode.crtc_clock;\n\n\tif (!hdmi_throughput)\n\t\treturn 0;\n\n\t \n\tif (crtc_state->output_format == INTEL_OUTPUT_FORMAT_YCBCR444 ||\n\t    crtc_state->output_format == INTEL_OUTPUT_FORMAT_RGB)\n\t\tkslice_adjust = 10;\n\telse\n\t\tkslice_adjust = 5;\n\n\t \n\n\tadjusted_clk_khz = DIV_ROUND_UP(kslice_adjust * pixel_clock, 10);\n\n\tif (adjusted_clk_khz <= HDMI_DSC_PEAK_PIXEL_RATE)\n\t\tmax_throughput = HDMI_DSC_MAX_ENC_THROUGHPUT_0;\n\telse\n\t\tmax_throughput = HDMI_DSC_MAX_ENC_THROUGHPUT_1;\n\n\t \n\tmax_throughput = min(max_throughput, hdmi_throughput * 1000);\n\n\tmin_slices = DIV_ROUND_UP(adjusted_clk_khz, max_throughput);\n\tmax_slice_width = min(MAX_HDMI_SLICE_WIDTH, src_max_slice_width);\n\n\t \n\tslice_width = max_slice_width;\n\n\tdo {\n\t\tif (min_slices <= 1 && src_max_slices >= 1 && hdmi_max_slices >= 1)\n\t\t\ttarget_slices = 1;\n\t\telse if (min_slices <= 2 && src_max_slices >= 2 && hdmi_max_slices >= 2)\n\t\t\ttarget_slices = 2;\n\t\telse if (min_slices <= 4 && src_max_slices >= 4 && hdmi_max_slices >= 4)\n\t\t\ttarget_slices = 4;\n\t\telse if (min_slices <= 8 && src_max_slices >= 8 && hdmi_max_slices >= 8)\n\t\t\ttarget_slices = 8;\n\t\telse if (min_slices <= 12 && src_max_slices >= 12 && hdmi_max_slices >= 12)\n\t\t\ttarget_slices = 12;\n\t\telse if (min_slices <= 16 && src_max_slices >= 16 && hdmi_max_slices >= 16)\n\t\t\ttarget_slices = 16;\n\t\telse\n\t\t\treturn 0;\n\n\t\tslice_width = DIV_ROUND_UP(crtc_state->hw.adjusted_mode.hdisplay, target_slices);\n\t\tif (slice_width >= max_slice_width)\n\t\t\tmin_slices = target_slices + 1;\n\t} while (slice_width >= max_slice_width);\n\n\treturn target_slices;\n}\n\n \nint\nintel_hdmi_dsc_get_bpp(int src_fractional_bpp, int slice_width, int num_slices,\n\t\t       int output_format, bool hdmi_all_bpp,\n\t\t       int hdmi_max_chunk_bytes)\n{\n\tint max_dsc_bpp, min_dsc_bpp;\n\tint target_bytes;\n\tbool bpp_found = false;\n\tint bpp_decrement_x16;\n\tint bpp_target;\n\tint bpp_target_x16;\n\n\t \n\n\t \n\tif (output_format == INTEL_OUTPUT_FORMAT_YCBCR420) {\n\t\tmin_dsc_bpp = 6;\n\t\tmax_dsc_bpp = 3 * 4;  \n\t} else if (output_format == INTEL_OUTPUT_FORMAT_YCBCR444 ||\n\t\t   output_format == INTEL_OUTPUT_FORMAT_RGB) {\n\t\tmin_dsc_bpp = 8;\n\t\tmax_dsc_bpp = 3 * 8;  \n\t} else {\n\t\t \n\t\tmin_dsc_bpp = 7;\n\t\tmax_dsc_bpp = 2 * 8;  \n\t}\n\n\t \n\tif (!hdmi_all_bpp)\n\t\tmax_dsc_bpp = min(max_dsc_bpp, 12);\n\n\t \n\n\tbpp_target = max_dsc_bpp;\n\n\t \n\tif (!src_fractional_bpp)\n\t\tsrc_fractional_bpp = 1;\n\tbpp_decrement_x16 = DIV_ROUND_UP(16, src_fractional_bpp);\n\tbpp_target_x16 = (bpp_target * 16) - bpp_decrement_x16;\n\n\twhile (bpp_target_x16 > (min_dsc_bpp * 16)) {\n\t\tint bpp;\n\n\t\tbpp = DIV_ROUND_UP(bpp_target_x16, 16);\n\t\ttarget_bytes = DIV_ROUND_UP((num_slices * slice_width * bpp), 8);\n\t\tif (target_bytes <= hdmi_max_chunk_bytes) {\n\t\t\tbpp_found = true;\n\t\t\tbreak;\n\t\t}\n\t\tbpp_target_x16 -= bpp_decrement_x16;\n\t}\n\tif (bpp_found)\n\t\treturn bpp_target_x16;\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}