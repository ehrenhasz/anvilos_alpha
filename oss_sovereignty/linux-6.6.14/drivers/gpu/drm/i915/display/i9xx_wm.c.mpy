{
  "module_name": "i9xx_wm.c",
  "hash_id": "941a702aeafd94ce54cdf454e172fdd4c44b3d29926e2658ec5e3c6e333d0aec",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/i915/display/i9xx_wm.c",
  "human_readable_source": "\n \n\n#include \"i915_drv.h\"\n#include \"i915_reg.h\"\n#include \"i9xx_wm.h\"\n#include \"intel_atomic.h\"\n#include \"intel_display.h\"\n#include \"intel_display_trace.h\"\n#include \"intel_mchbar_regs.h\"\n#include \"intel_wm.h\"\n#include \"skl_watermark.h\"\n#include \"vlv_sideband.h\"\n\n \nstruct intel_wm_config {\n\tunsigned int num_pipes_active;\n\tbool sprites_enabled;\n\tbool sprites_scaled;\n};\n\nstruct cxsr_latency {\n\tbool is_desktop : 1;\n\tbool is_ddr3 : 1;\n\tu16 fsb_freq;\n\tu16 mem_freq;\n\tu16 display_sr;\n\tu16 display_hpll_disable;\n\tu16 cursor_sr;\n\tu16 cursor_hpll_disable;\n};\n\nstatic const struct cxsr_latency cxsr_latency_table[] = {\n\t{1, 0, 800, 400, 3382, 33382, 3983, 33983},     \n\t{1, 0, 800, 667, 3354, 33354, 3807, 33807},     \n\t{1, 0, 800, 800, 3347, 33347, 3763, 33763},     \n\t{1, 1, 800, 667, 6420, 36420, 6873, 36873},     \n\t{1, 1, 800, 800, 5902, 35902, 6318, 36318},     \n\n\t{1, 0, 667, 400, 3400, 33400, 4021, 34021},     \n\t{1, 0, 667, 667, 3372, 33372, 3845, 33845},     \n\t{1, 0, 667, 800, 3386, 33386, 3822, 33822},     \n\t{1, 1, 667, 667, 6438, 36438, 6911, 36911},     \n\t{1, 1, 667, 800, 5941, 35941, 6377, 36377},     \n\n\t{1, 0, 400, 400, 3472, 33472, 4173, 34173},     \n\t{1, 0, 400, 667, 3443, 33443, 3996, 33996},     \n\t{1, 0, 400, 800, 3430, 33430, 3946, 33946},     \n\t{1, 1, 400, 667, 6509, 36509, 7062, 37062},     \n\t{1, 1, 400, 800, 5985, 35985, 6501, 36501},     \n\n\t{0, 0, 800, 400, 3438, 33438, 4065, 34065},     \n\t{0, 0, 800, 667, 3410, 33410, 3889, 33889},     \n\t{0, 0, 800, 800, 3403, 33403, 3845, 33845},     \n\t{0, 1, 800, 667, 6476, 36476, 6955, 36955},     \n\t{0, 1, 800, 800, 5958, 35958, 6400, 36400},     \n\n\t{0, 0, 667, 400, 3456, 33456, 4103, 34106},     \n\t{0, 0, 667, 667, 3428, 33428, 3927, 33927},     \n\t{0, 0, 667, 800, 3443, 33443, 3905, 33905},     \n\t{0, 1, 667, 667, 6494, 36494, 6993, 36993},     \n\t{0, 1, 667, 800, 5998, 35998, 6460, 36460},     \n\n\t{0, 0, 400, 400, 3528, 33528, 4255, 34255},     \n\t{0, 0, 400, 667, 3500, 33500, 4079, 34079},     \n\t{0, 0, 400, 800, 3487, 33487, 4029, 34029},     \n\t{0, 1, 400, 667, 6566, 36566, 7145, 37145},     \n\t{0, 1, 400, 800, 6042, 36042, 6584, 36584},     \n};\n\nstatic const struct cxsr_latency *intel_get_cxsr_latency(bool is_desktop,\n\t\t\t\t\t\t\t bool is_ddr3,\n\t\t\t\t\t\t\t int fsb,\n\t\t\t\t\t\t\t int mem)\n{\n\tconst struct cxsr_latency *latency;\n\tint i;\n\n\tif (fsb == 0 || mem == 0)\n\t\treturn NULL;\n\n\tfor (i = 0; i < ARRAY_SIZE(cxsr_latency_table); i++) {\n\t\tlatency = &cxsr_latency_table[i];\n\t\tif (is_desktop == latency->is_desktop &&\n\t\t    is_ddr3 == latency->is_ddr3 &&\n\t\t    fsb == latency->fsb_freq && mem == latency->mem_freq)\n\t\t\treturn latency;\n\t}\n\n\tDRM_DEBUG_KMS(\"Unknown FSB/MEM found, disable CxSR\\n\");\n\n\treturn NULL;\n}\n\nstatic void chv_set_memory_dvfs(struct drm_i915_private *dev_priv, bool enable)\n{\n\tu32 val;\n\n\tvlv_punit_get(dev_priv);\n\n\tval = vlv_punit_read(dev_priv, PUNIT_REG_DDR_SETUP2);\n\tif (enable)\n\t\tval &= ~FORCE_DDR_HIGH_FREQ;\n\telse\n\t\tval |= FORCE_DDR_HIGH_FREQ;\n\tval &= ~FORCE_DDR_LOW_FREQ;\n\tval |= FORCE_DDR_FREQ_REQ_ACK;\n\tvlv_punit_write(dev_priv, PUNIT_REG_DDR_SETUP2, val);\n\n\tif (wait_for((vlv_punit_read(dev_priv, PUNIT_REG_DDR_SETUP2) &\n\t\t      FORCE_DDR_FREQ_REQ_ACK) == 0, 3))\n\t\tdrm_err(&dev_priv->drm,\n\t\t\t\"timed out waiting for Punit DDR DVFS request\\n\");\n\n\tvlv_punit_put(dev_priv);\n}\n\nstatic void chv_set_memory_pm5(struct drm_i915_private *dev_priv, bool enable)\n{\n\tu32 val;\n\n\tvlv_punit_get(dev_priv);\n\n\tval = vlv_punit_read(dev_priv, PUNIT_REG_DSPSSPM);\n\tif (enable)\n\t\tval |= DSP_MAXFIFO_PM5_ENABLE;\n\telse\n\t\tval &= ~DSP_MAXFIFO_PM5_ENABLE;\n\tvlv_punit_write(dev_priv, PUNIT_REG_DSPSSPM, val);\n\n\tvlv_punit_put(dev_priv);\n}\n\n#define FW_WM(value, plane) \\\n\t(((value) << DSPFW_ ## plane ## _SHIFT) & DSPFW_ ## plane ## _MASK)\n\nstatic bool _intel_set_memory_cxsr(struct drm_i915_private *dev_priv, bool enable)\n{\n\tbool was_enabled;\n\tu32 val;\n\n\tif (IS_VALLEYVIEW(dev_priv) || IS_CHERRYVIEW(dev_priv)) {\n\t\twas_enabled = intel_uncore_read(&dev_priv->uncore, FW_BLC_SELF_VLV) & FW_CSPWRDWNEN;\n\t\tintel_uncore_write(&dev_priv->uncore, FW_BLC_SELF_VLV, enable ? FW_CSPWRDWNEN : 0);\n\t\tintel_uncore_posting_read(&dev_priv->uncore, FW_BLC_SELF_VLV);\n\t} else if (IS_G4X(dev_priv) || IS_I965GM(dev_priv)) {\n\t\twas_enabled = intel_uncore_read(&dev_priv->uncore, FW_BLC_SELF) & FW_BLC_SELF_EN;\n\t\tintel_uncore_write(&dev_priv->uncore, FW_BLC_SELF, enable ? FW_BLC_SELF_EN : 0);\n\t\tintel_uncore_posting_read(&dev_priv->uncore, FW_BLC_SELF);\n\t} else if (IS_PINEVIEW(dev_priv)) {\n\t\tval = intel_uncore_read(&dev_priv->uncore, DSPFW3);\n\t\twas_enabled = val & PINEVIEW_SELF_REFRESH_EN;\n\t\tif (enable)\n\t\t\tval |= PINEVIEW_SELF_REFRESH_EN;\n\t\telse\n\t\t\tval &= ~PINEVIEW_SELF_REFRESH_EN;\n\t\tintel_uncore_write(&dev_priv->uncore, DSPFW3, val);\n\t\tintel_uncore_posting_read(&dev_priv->uncore, DSPFW3);\n\t} else if (IS_I945G(dev_priv) || IS_I945GM(dev_priv)) {\n\t\twas_enabled = intel_uncore_read(&dev_priv->uncore, FW_BLC_SELF) & FW_BLC_SELF_EN;\n\t\tval = enable ? _MASKED_BIT_ENABLE(FW_BLC_SELF_EN) :\n\t\t\t       _MASKED_BIT_DISABLE(FW_BLC_SELF_EN);\n\t\tintel_uncore_write(&dev_priv->uncore, FW_BLC_SELF, val);\n\t\tintel_uncore_posting_read(&dev_priv->uncore, FW_BLC_SELF);\n\t} else if (IS_I915GM(dev_priv)) {\n\t\t \n\t\twas_enabled = intel_uncore_read(&dev_priv->uncore, INSTPM) & INSTPM_SELF_EN;\n\t\tval = enable ? _MASKED_BIT_ENABLE(INSTPM_SELF_EN) :\n\t\t\t       _MASKED_BIT_DISABLE(INSTPM_SELF_EN);\n\t\tintel_uncore_write(&dev_priv->uncore, INSTPM, val);\n\t\tintel_uncore_posting_read(&dev_priv->uncore, INSTPM);\n\t} else {\n\t\treturn false;\n\t}\n\n\ttrace_intel_memory_cxsr(dev_priv, was_enabled, enable);\n\n\tdrm_dbg_kms(&dev_priv->drm, \"memory self-refresh is %s (was %s)\\n\",\n\t\t    str_enabled_disabled(enable),\n\t\t    str_enabled_disabled(was_enabled));\n\n\treturn was_enabled;\n}\n\n \nbool intel_set_memory_cxsr(struct drm_i915_private *dev_priv, bool enable)\n{\n\tbool ret;\n\n\tmutex_lock(&dev_priv->display.wm.wm_mutex);\n\tret = _intel_set_memory_cxsr(dev_priv, enable);\n\tif (IS_VALLEYVIEW(dev_priv) || IS_CHERRYVIEW(dev_priv))\n\t\tdev_priv->display.wm.vlv.cxsr = enable;\n\telse if (IS_G4X(dev_priv))\n\t\tdev_priv->display.wm.g4x.cxsr = enable;\n\tmutex_unlock(&dev_priv->display.wm.wm_mutex);\n\n\treturn ret;\n}\n\n \nstatic const int pessimal_latency_ns = 5000;\n\n#define VLV_FIFO_START(dsparb, dsparb2, lo_shift, hi_shift) \\\n\t((((dsparb) >> (lo_shift)) & 0xff) | ((((dsparb2) >> (hi_shift)) & 0x1) << 8))\n\nstatic void vlv_get_fifo_size(struct intel_crtc_state *crtc_state)\n{\n\tstruct intel_crtc *crtc = to_intel_crtc(crtc_state->uapi.crtc);\n\tstruct drm_i915_private *dev_priv = to_i915(crtc->base.dev);\n\tstruct vlv_fifo_state *fifo_state = &crtc_state->wm.vlv.fifo_state;\n\tenum pipe pipe = crtc->pipe;\n\tint sprite0_start, sprite1_start;\n\tu32 dsparb, dsparb2, dsparb3;\n\n\tswitch (pipe) {\n\tcase PIPE_A:\n\t\tdsparb = intel_uncore_read(&dev_priv->uncore, DSPARB);\n\t\tdsparb2 = intel_uncore_read(&dev_priv->uncore, DSPARB2);\n\t\tsprite0_start = VLV_FIFO_START(dsparb, dsparb2, 0, 0);\n\t\tsprite1_start = VLV_FIFO_START(dsparb, dsparb2, 8, 4);\n\t\tbreak;\n\tcase PIPE_B:\n\t\tdsparb = intel_uncore_read(&dev_priv->uncore, DSPARB);\n\t\tdsparb2 = intel_uncore_read(&dev_priv->uncore, DSPARB2);\n\t\tsprite0_start = VLV_FIFO_START(dsparb, dsparb2, 16, 8);\n\t\tsprite1_start = VLV_FIFO_START(dsparb, dsparb2, 24, 12);\n\t\tbreak;\n\tcase PIPE_C:\n\t\tdsparb2 = intel_uncore_read(&dev_priv->uncore, DSPARB2);\n\t\tdsparb3 = intel_uncore_read(&dev_priv->uncore, DSPARB3);\n\t\tsprite0_start = VLV_FIFO_START(dsparb3, dsparb2, 0, 16);\n\t\tsprite1_start = VLV_FIFO_START(dsparb3, dsparb2, 8, 20);\n\t\tbreak;\n\tdefault:\n\t\tMISSING_CASE(pipe);\n\t\treturn;\n\t}\n\n\tfifo_state->plane[PLANE_PRIMARY] = sprite0_start;\n\tfifo_state->plane[PLANE_SPRITE0] = sprite1_start - sprite0_start;\n\tfifo_state->plane[PLANE_SPRITE1] = 511 - sprite1_start;\n\tfifo_state->plane[PLANE_CURSOR] = 63;\n}\n\nstatic int i9xx_get_fifo_size(struct drm_i915_private *dev_priv,\n\t\t\t      enum i9xx_plane_id i9xx_plane)\n{\n\tu32 dsparb = intel_uncore_read(&dev_priv->uncore, DSPARB);\n\tint size;\n\n\tsize = dsparb & 0x7f;\n\tif (i9xx_plane == PLANE_B)\n\t\tsize = ((dsparb >> DSPARB_CSTART_SHIFT) & 0x7f) - size;\n\n\tdrm_dbg_kms(&dev_priv->drm, \"FIFO size - (0x%08x) %c: %d\\n\",\n\t\t    dsparb, plane_name(i9xx_plane), size);\n\n\treturn size;\n}\n\nstatic int i830_get_fifo_size(struct drm_i915_private *dev_priv,\n\t\t\t      enum i9xx_plane_id i9xx_plane)\n{\n\tu32 dsparb = intel_uncore_read(&dev_priv->uncore, DSPARB);\n\tint size;\n\n\tsize = dsparb & 0x1ff;\n\tif (i9xx_plane == PLANE_B)\n\t\tsize = ((dsparb >> DSPARB_BEND_SHIFT) & 0x1ff) - size;\n\tsize >>= 1;  \n\n\tdrm_dbg_kms(&dev_priv->drm, \"FIFO size - (0x%08x) %c: %d\\n\",\n\t\t    dsparb, plane_name(i9xx_plane), size);\n\n\treturn size;\n}\n\nstatic int i845_get_fifo_size(struct drm_i915_private *dev_priv,\n\t\t\t      enum i9xx_plane_id i9xx_plane)\n{\n\tu32 dsparb = intel_uncore_read(&dev_priv->uncore, DSPARB);\n\tint size;\n\n\tsize = dsparb & 0x7f;\n\tsize >>= 2;  \n\n\tdrm_dbg_kms(&dev_priv->drm, \"FIFO size - (0x%08x) %c: %d\\n\",\n\t\t    dsparb, plane_name(i9xx_plane), size);\n\n\treturn size;\n}\n\n \nstatic const struct intel_watermark_params pnv_display_wm = {\n\t.fifo_size = PINEVIEW_DISPLAY_FIFO,\n\t.max_wm = PINEVIEW_MAX_WM,\n\t.default_wm = PINEVIEW_DFT_WM,\n\t.guard_size = PINEVIEW_GUARD_WM,\n\t.cacheline_size = PINEVIEW_FIFO_LINE_SIZE,\n};\n\nstatic const struct intel_watermark_params pnv_display_hplloff_wm = {\n\t.fifo_size = PINEVIEW_DISPLAY_FIFO,\n\t.max_wm = PINEVIEW_MAX_WM,\n\t.default_wm = PINEVIEW_DFT_HPLLOFF_WM,\n\t.guard_size = PINEVIEW_GUARD_WM,\n\t.cacheline_size = PINEVIEW_FIFO_LINE_SIZE,\n};\n\nstatic const struct intel_watermark_params pnv_cursor_wm = {\n\t.fifo_size = PINEVIEW_CURSOR_FIFO,\n\t.max_wm = PINEVIEW_CURSOR_MAX_WM,\n\t.default_wm = PINEVIEW_CURSOR_DFT_WM,\n\t.guard_size = PINEVIEW_CURSOR_GUARD_WM,\n\t.cacheline_size = PINEVIEW_FIFO_LINE_SIZE,\n};\n\nstatic const struct intel_watermark_params pnv_cursor_hplloff_wm = {\n\t.fifo_size = PINEVIEW_CURSOR_FIFO,\n\t.max_wm = PINEVIEW_CURSOR_MAX_WM,\n\t.default_wm = PINEVIEW_CURSOR_DFT_WM,\n\t.guard_size = PINEVIEW_CURSOR_GUARD_WM,\n\t.cacheline_size = PINEVIEW_FIFO_LINE_SIZE,\n};\n\nstatic const struct intel_watermark_params i965_cursor_wm_info = {\n\t.fifo_size = I965_CURSOR_FIFO,\n\t.max_wm = I965_CURSOR_MAX_WM,\n\t.default_wm = I965_CURSOR_DFT_WM,\n\t.guard_size = 2,\n\t.cacheline_size = I915_FIFO_LINE_SIZE,\n};\n\nstatic const struct intel_watermark_params i945_wm_info = {\n\t.fifo_size = I945_FIFO_SIZE,\n\t.max_wm = I915_MAX_WM,\n\t.default_wm = 1,\n\t.guard_size = 2,\n\t.cacheline_size = I915_FIFO_LINE_SIZE,\n};\n\nstatic const struct intel_watermark_params i915_wm_info = {\n\t.fifo_size = I915_FIFO_SIZE,\n\t.max_wm = I915_MAX_WM,\n\t.default_wm = 1,\n\t.guard_size = 2,\n\t.cacheline_size = I915_FIFO_LINE_SIZE,\n};\n\nstatic const struct intel_watermark_params i830_a_wm_info = {\n\t.fifo_size = I855GM_FIFO_SIZE,\n\t.max_wm = I915_MAX_WM,\n\t.default_wm = 1,\n\t.guard_size = 2,\n\t.cacheline_size = I830_FIFO_LINE_SIZE,\n};\n\nstatic const struct intel_watermark_params i830_bc_wm_info = {\n\t.fifo_size = I855GM_FIFO_SIZE,\n\t.max_wm = I915_MAX_WM / 2,\n\t.default_wm = 1,\n\t.guard_size = 2,\n\t.cacheline_size = I830_FIFO_LINE_SIZE,\n};\n\nstatic const struct intel_watermark_params i845_wm_info = {\n\t.fifo_size = I830_FIFO_SIZE,\n\t.max_wm = I915_MAX_WM,\n\t.default_wm = 1,\n\t.guard_size = 2,\n\t.cacheline_size = I830_FIFO_LINE_SIZE,\n};\n\n \nstatic unsigned int intel_wm_method1(unsigned int pixel_rate,\n\t\t\t\t     unsigned int cpp,\n\t\t\t\t     unsigned int latency)\n{\n\tu64 ret;\n\n\tret = mul_u32_u32(pixel_rate, cpp * latency);\n\tret = DIV_ROUND_UP_ULL(ret, 10000);\n\n\treturn ret;\n}\n\n \nstatic unsigned int intel_wm_method2(unsigned int pixel_rate,\n\t\t\t\t     unsigned int htotal,\n\t\t\t\t     unsigned int width,\n\t\t\t\t     unsigned int cpp,\n\t\t\t\t     unsigned int latency)\n{\n\tunsigned int ret;\n\n\t \n\tif (WARN_ON_ONCE(htotal == 0))\n\t\thtotal = 1;\n\n\tret = (latency * pixel_rate) / (htotal * 10000);\n\tret = (ret + 1) * width * cpp;\n\n\treturn ret;\n}\n\n \nstatic unsigned int intel_calculate_wm(int pixel_rate,\n\t\t\t\t       const struct intel_watermark_params *wm,\n\t\t\t\t       int fifo_size, int cpp,\n\t\t\t\t       unsigned int latency_ns)\n{\n\tint entries, wm_size;\n\n\t \n\tentries = intel_wm_method1(pixel_rate, cpp,\n\t\t\t\t   latency_ns / 100);\n\tentries = DIV_ROUND_UP(entries, wm->cacheline_size) +\n\t\twm->guard_size;\n\tDRM_DEBUG_KMS(\"FIFO entries required for mode: %d\\n\", entries);\n\n\twm_size = fifo_size - entries;\n\tDRM_DEBUG_KMS(\"FIFO watermark level: %d\\n\", wm_size);\n\n\t \n\tif (wm_size > wm->max_wm)\n\t\twm_size = wm->max_wm;\n\tif (wm_size <= 0)\n\t\twm_size = wm->default_wm;\n\n\t \n\tif (wm_size <= 8)\n\t\twm_size = 8;\n\n\treturn wm_size;\n}\n\nstatic bool is_disabling(int old, int new, int threshold)\n{\n\treturn old >= threshold && new < threshold;\n}\n\nstatic bool is_enabling(int old, int new, int threshold)\n{\n\treturn old < threshold && new >= threshold;\n}\n\nstatic bool intel_crtc_active(struct intel_crtc *crtc)\n{\n\t \n\treturn crtc && crtc->active && crtc->base.primary->state->fb &&\n\t\tcrtc->config->hw.adjusted_mode.crtc_clock;\n}\n\nstatic struct intel_crtc *single_enabled_crtc(struct drm_i915_private *dev_priv)\n{\n\tstruct intel_crtc *crtc, *enabled = NULL;\n\n\tfor_each_intel_crtc(&dev_priv->drm, crtc) {\n\t\tif (intel_crtc_active(crtc)) {\n\t\t\tif (enabled)\n\t\t\t\treturn NULL;\n\t\t\tenabled = crtc;\n\t\t}\n\t}\n\n\treturn enabled;\n}\n\nstatic void pnv_update_wm(struct drm_i915_private *dev_priv)\n{\n\tstruct intel_crtc *crtc;\n\tconst struct cxsr_latency *latency;\n\tu32 reg;\n\tunsigned int wm;\n\n\tlatency = intel_get_cxsr_latency(!IS_MOBILE(dev_priv),\n\t\t\t\t\t dev_priv->is_ddr3,\n\t\t\t\t\t dev_priv->fsb_freq,\n\t\t\t\t\t dev_priv->mem_freq);\n\tif (!latency) {\n\t\tdrm_dbg_kms(&dev_priv->drm,\n\t\t\t    \"Unknown FSB/MEM found, disable CxSR\\n\");\n\t\tintel_set_memory_cxsr(dev_priv, false);\n\t\treturn;\n\t}\n\n\tcrtc = single_enabled_crtc(dev_priv);\n\tif (crtc) {\n\t\tconst struct drm_framebuffer *fb =\n\t\t\tcrtc->base.primary->state->fb;\n\t\tint pixel_rate = crtc->config->pixel_rate;\n\t\tint cpp = fb->format->cpp[0];\n\n\t\t \n\t\twm = intel_calculate_wm(pixel_rate, &pnv_display_wm,\n\t\t\t\t\tpnv_display_wm.fifo_size,\n\t\t\t\t\tcpp, latency->display_sr);\n\t\treg = intel_uncore_read(&dev_priv->uncore, DSPFW1);\n\t\treg &= ~DSPFW_SR_MASK;\n\t\treg |= FW_WM(wm, SR);\n\t\tintel_uncore_write(&dev_priv->uncore, DSPFW1, reg);\n\t\tdrm_dbg_kms(&dev_priv->drm, \"DSPFW1 register is %x\\n\", reg);\n\n\t\t \n\t\twm = intel_calculate_wm(pixel_rate, &pnv_cursor_wm,\n\t\t\t\t\tpnv_display_wm.fifo_size,\n\t\t\t\t\t4, latency->cursor_sr);\n\t\tintel_uncore_rmw(&dev_priv->uncore, DSPFW3, DSPFW_CURSOR_SR_MASK,\n\t\t\t\t FW_WM(wm, CURSOR_SR));\n\n\t\t \n\t\twm = intel_calculate_wm(pixel_rate, &pnv_display_hplloff_wm,\n\t\t\t\t\tpnv_display_hplloff_wm.fifo_size,\n\t\t\t\t\tcpp, latency->display_hpll_disable);\n\t\tintel_uncore_rmw(&dev_priv->uncore, DSPFW3, DSPFW_HPLL_SR_MASK, FW_WM(wm, HPLL_SR));\n\n\t\t \n\t\twm = intel_calculate_wm(pixel_rate, &pnv_cursor_hplloff_wm,\n\t\t\t\t\tpnv_display_hplloff_wm.fifo_size,\n\t\t\t\t\t4, latency->cursor_hpll_disable);\n\t\treg = intel_uncore_read(&dev_priv->uncore, DSPFW3);\n\t\treg &= ~DSPFW_HPLL_CURSOR_MASK;\n\t\treg |= FW_WM(wm, HPLL_CURSOR);\n\t\tintel_uncore_write(&dev_priv->uncore, DSPFW3, reg);\n\t\tdrm_dbg_kms(&dev_priv->drm, \"DSPFW3 register is %x\\n\", reg);\n\n\t\tintel_set_memory_cxsr(dev_priv, true);\n\t} else {\n\t\tintel_set_memory_cxsr(dev_priv, false);\n\t}\n}\n\n \nstatic unsigned int g4x_tlb_miss_wa(int fifo_size, int width, int cpp)\n{\n\tint tlb_miss = fifo_size * 64 - width * cpp * 8;\n\n\treturn max(0, tlb_miss);\n}\n\nstatic void g4x_write_wm_values(struct drm_i915_private *dev_priv,\n\t\t\t\tconst struct g4x_wm_values *wm)\n{\n\tenum pipe pipe;\n\n\tfor_each_pipe(dev_priv, pipe)\n\t\ttrace_g4x_wm(intel_crtc_for_pipe(dev_priv, pipe), wm);\n\n\tintel_uncore_write(&dev_priv->uncore, DSPFW1,\n\t\t\t   FW_WM(wm->sr.plane, SR) |\n\t\t\t   FW_WM(wm->pipe[PIPE_B].plane[PLANE_CURSOR], CURSORB) |\n\t\t\t   FW_WM(wm->pipe[PIPE_B].plane[PLANE_PRIMARY], PLANEB) |\n\t\t\t   FW_WM(wm->pipe[PIPE_A].plane[PLANE_PRIMARY], PLANEA));\n\tintel_uncore_write(&dev_priv->uncore, DSPFW2,\n\t\t\t   (wm->fbc_en ? DSPFW_FBC_SR_EN : 0) |\n\t\t\t   FW_WM(wm->sr.fbc, FBC_SR) |\n\t\t\t   FW_WM(wm->hpll.fbc, FBC_HPLL_SR) |\n\t\t\t   FW_WM(wm->pipe[PIPE_B].plane[PLANE_SPRITE0], SPRITEB) |\n\t\t\t   FW_WM(wm->pipe[PIPE_A].plane[PLANE_CURSOR], CURSORA) |\n\t\t\t   FW_WM(wm->pipe[PIPE_A].plane[PLANE_SPRITE0], SPRITEA));\n\tintel_uncore_write(&dev_priv->uncore, DSPFW3,\n\t\t\t   (wm->hpll_en ? DSPFW_HPLL_SR_EN : 0) |\n\t\t\t   FW_WM(wm->sr.cursor, CURSOR_SR) |\n\t\t\t   FW_WM(wm->hpll.cursor, HPLL_CURSOR) |\n\t\t\t   FW_WM(wm->hpll.plane, HPLL_SR));\n\n\tintel_uncore_posting_read(&dev_priv->uncore, DSPFW1);\n}\n\n#define FW_WM_VLV(value, plane) \\\n\t(((value) << DSPFW_ ## plane ## _SHIFT) & DSPFW_ ## plane ## _MASK_VLV)\n\nstatic void vlv_write_wm_values(struct drm_i915_private *dev_priv,\n\t\t\t\tconst struct vlv_wm_values *wm)\n{\n\tenum pipe pipe;\n\n\tfor_each_pipe(dev_priv, pipe) {\n\t\ttrace_vlv_wm(intel_crtc_for_pipe(dev_priv, pipe), wm);\n\n\t\tintel_uncore_write(&dev_priv->uncore, VLV_DDL(pipe),\n\t\t\t\t   (wm->ddl[pipe].plane[PLANE_CURSOR] << DDL_CURSOR_SHIFT) |\n\t\t\t\t   (wm->ddl[pipe].plane[PLANE_SPRITE1] << DDL_SPRITE_SHIFT(1)) |\n\t\t\t\t   (wm->ddl[pipe].plane[PLANE_SPRITE0] << DDL_SPRITE_SHIFT(0)) |\n\t\t\t\t   (wm->ddl[pipe].plane[PLANE_PRIMARY] << DDL_PLANE_SHIFT));\n\t}\n\n\t \n\tintel_uncore_write(&dev_priv->uncore, DSPHOWM, 0);\n\tintel_uncore_write(&dev_priv->uncore, DSPHOWM1, 0);\n\tintel_uncore_write(&dev_priv->uncore, DSPFW4, 0);\n\tintel_uncore_write(&dev_priv->uncore, DSPFW5, 0);\n\tintel_uncore_write(&dev_priv->uncore, DSPFW6, 0);\n\n\tintel_uncore_write(&dev_priv->uncore, DSPFW1,\n\t\t\t   FW_WM(wm->sr.plane, SR) |\n\t\t\t   FW_WM(wm->pipe[PIPE_B].plane[PLANE_CURSOR], CURSORB) |\n\t\t\t   FW_WM_VLV(wm->pipe[PIPE_B].plane[PLANE_PRIMARY], PLANEB) |\n\t\t\t   FW_WM_VLV(wm->pipe[PIPE_A].plane[PLANE_PRIMARY], PLANEA));\n\tintel_uncore_write(&dev_priv->uncore, DSPFW2,\n\t\t\t   FW_WM_VLV(wm->pipe[PIPE_A].plane[PLANE_SPRITE1], SPRITEB) |\n\t\t\t   FW_WM(wm->pipe[PIPE_A].plane[PLANE_CURSOR], CURSORA) |\n\t\t\t   FW_WM_VLV(wm->pipe[PIPE_A].plane[PLANE_SPRITE0], SPRITEA));\n\tintel_uncore_write(&dev_priv->uncore, DSPFW3,\n\t\t\t   FW_WM(wm->sr.cursor, CURSOR_SR));\n\n\tif (IS_CHERRYVIEW(dev_priv)) {\n\t\tintel_uncore_write(&dev_priv->uncore, DSPFW7_CHV,\n\t\t\t\t   FW_WM_VLV(wm->pipe[PIPE_B].plane[PLANE_SPRITE1], SPRITED) |\n\t\t\t\t   FW_WM_VLV(wm->pipe[PIPE_B].plane[PLANE_SPRITE0], SPRITEC));\n\t\tintel_uncore_write(&dev_priv->uncore, DSPFW8_CHV,\n\t\t\t\t   FW_WM_VLV(wm->pipe[PIPE_C].plane[PLANE_SPRITE1], SPRITEF) |\n\t\t\t\t   FW_WM_VLV(wm->pipe[PIPE_C].plane[PLANE_SPRITE0], SPRITEE));\n\t\tintel_uncore_write(&dev_priv->uncore, DSPFW9_CHV,\n\t\t\t\t   FW_WM_VLV(wm->pipe[PIPE_C].plane[PLANE_PRIMARY], PLANEC) |\n\t\t\t\t   FW_WM(wm->pipe[PIPE_C].plane[PLANE_CURSOR], CURSORC));\n\t\tintel_uncore_write(&dev_priv->uncore, DSPHOWM,\n\t\t\t\t   FW_WM(wm->sr.plane >> 9, SR_HI) |\n\t\t\t\t   FW_WM(wm->pipe[PIPE_C].plane[PLANE_SPRITE1] >> 8, SPRITEF_HI) |\n\t\t\t\t   FW_WM(wm->pipe[PIPE_C].plane[PLANE_SPRITE0] >> 8, SPRITEE_HI) |\n\t\t\t\t   FW_WM(wm->pipe[PIPE_C].plane[PLANE_PRIMARY] >> 8, PLANEC_HI) |\n\t\t\t\t   FW_WM(wm->pipe[PIPE_B].plane[PLANE_SPRITE1] >> 8, SPRITED_HI) |\n\t\t\t\t   FW_WM(wm->pipe[PIPE_B].plane[PLANE_SPRITE0] >> 8, SPRITEC_HI) |\n\t\t\t\t   FW_WM(wm->pipe[PIPE_B].plane[PLANE_PRIMARY] >> 8, PLANEB_HI) |\n\t\t\t\t   FW_WM(wm->pipe[PIPE_A].plane[PLANE_SPRITE1] >> 8, SPRITEB_HI) |\n\t\t\t\t   FW_WM(wm->pipe[PIPE_A].plane[PLANE_SPRITE0] >> 8, SPRITEA_HI) |\n\t\t\t\t   FW_WM(wm->pipe[PIPE_A].plane[PLANE_PRIMARY] >> 8, PLANEA_HI));\n\t} else {\n\t\tintel_uncore_write(&dev_priv->uncore, DSPFW7,\n\t\t\t\t   FW_WM_VLV(wm->pipe[PIPE_B].plane[PLANE_SPRITE1], SPRITED) |\n\t\t\t\t   FW_WM_VLV(wm->pipe[PIPE_B].plane[PLANE_SPRITE0], SPRITEC));\n\t\tintel_uncore_write(&dev_priv->uncore, DSPHOWM,\n\t\t\t\t   FW_WM(wm->sr.plane >> 9, SR_HI) |\n\t\t\t\t   FW_WM(wm->pipe[PIPE_B].plane[PLANE_SPRITE1] >> 8, SPRITED_HI) |\n\t\t\t\t   FW_WM(wm->pipe[PIPE_B].plane[PLANE_SPRITE0] >> 8, SPRITEC_HI) |\n\t\t\t\t   FW_WM(wm->pipe[PIPE_B].plane[PLANE_PRIMARY] >> 8, PLANEB_HI) |\n\t\t\t\t   FW_WM(wm->pipe[PIPE_A].plane[PLANE_SPRITE1] >> 8, SPRITEB_HI) |\n\t\t\t\t   FW_WM(wm->pipe[PIPE_A].plane[PLANE_SPRITE0] >> 8, SPRITEA_HI) |\n\t\t\t\t   FW_WM(wm->pipe[PIPE_A].plane[PLANE_PRIMARY] >> 8, PLANEA_HI));\n\t}\n\n\tintel_uncore_posting_read(&dev_priv->uncore, DSPFW1);\n}\n\n#undef FW_WM_VLV\n\nstatic void g4x_setup_wm_latency(struct drm_i915_private *dev_priv)\n{\n\t \n\tdev_priv->display.wm.pri_latency[G4X_WM_LEVEL_NORMAL] = 5;\n\tdev_priv->display.wm.pri_latency[G4X_WM_LEVEL_SR] = 12;\n\tdev_priv->display.wm.pri_latency[G4X_WM_LEVEL_HPLL] = 35;\n\n\tdev_priv->display.wm.num_levels = G4X_WM_LEVEL_HPLL + 1;\n}\n\nstatic int g4x_plane_fifo_size(enum plane_id plane_id, int level)\n{\n\t \n\tswitch (plane_id) {\n\tcase PLANE_CURSOR:\n\t\treturn 63;\n\tcase PLANE_PRIMARY:\n\t\treturn level == G4X_WM_LEVEL_NORMAL ? 127 : 511;\n\tcase PLANE_SPRITE0:\n\t\treturn level == G4X_WM_LEVEL_NORMAL ? 127 : 0;\n\tdefault:\n\t\tMISSING_CASE(plane_id);\n\t\treturn 0;\n\t}\n}\n\nstatic int g4x_fbc_fifo_size(int level)\n{\n\tswitch (level) {\n\tcase G4X_WM_LEVEL_SR:\n\t\treturn 7;\n\tcase G4X_WM_LEVEL_HPLL:\n\t\treturn 15;\n\tdefault:\n\t\tMISSING_CASE(level);\n\t\treturn 0;\n\t}\n}\n\nstatic u16 g4x_compute_wm(const struct intel_crtc_state *crtc_state,\n\t\t\t  const struct intel_plane_state *plane_state,\n\t\t\t  int level)\n{\n\tstruct intel_plane *plane = to_intel_plane(plane_state->uapi.plane);\n\tstruct drm_i915_private *dev_priv = to_i915(plane->base.dev);\n\tconst struct drm_display_mode *pipe_mode =\n\t\t&crtc_state->hw.pipe_mode;\n\tunsigned int latency = dev_priv->display.wm.pri_latency[level] * 10;\n\tunsigned int pixel_rate, htotal, cpp, width, wm;\n\n\tif (latency == 0)\n\t\treturn USHRT_MAX;\n\n\tif (!intel_wm_plane_visible(crtc_state, plane_state))\n\t\treturn 0;\n\n\tcpp = plane_state->hw.fb->format->cpp[0];\n\n\t \n\tif (plane->id == PLANE_PRIMARY &&\n\t    level != G4X_WM_LEVEL_NORMAL)\n\t\tcpp = max(cpp, 4u);\n\n\tpixel_rate = crtc_state->pixel_rate;\n\thtotal = pipe_mode->crtc_htotal;\n\twidth = drm_rect_width(&plane_state->uapi.src) >> 16;\n\n\tif (plane->id == PLANE_CURSOR) {\n\t\twm = intel_wm_method2(pixel_rate, htotal, width, cpp, latency);\n\t} else if (plane->id == PLANE_PRIMARY &&\n\t\t   level == G4X_WM_LEVEL_NORMAL) {\n\t\twm = intel_wm_method1(pixel_rate, cpp, latency);\n\t} else {\n\t\tunsigned int small, large;\n\n\t\tsmall = intel_wm_method1(pixel_rate, cpp, latency);\n\t\tlarge = intel_wm_method2(pixel_rate, htotal, width, cpp, latency);\n\n\t\twm = min(small, large);\n\t}\n\n\twm += g4x_tlb_miss_wa(g4x_plane_fifo_size(plane->id, level),\n\t\t\t      width, cpp);\n\n\twm = DIV_ROUND_UP(wm, 64) + 2;\n\n\treturn min_t(unsigned int, wm, USHRT_MAX);\n}\n\nstatic bool g4x_raw_plane_wm_set(struct intel_crtc_state *crtc_state,\n\t\t\t\t int level, enum plane_id plane_id, u16 value)\n{\n\tstruct drm_i915_private *dev_priv = to_i915(crtc_state->uapi.crtc->dev);\n\tbool dirty = false;\n\n\tfor (; level < dev_priv->display.wm.num_levels; level++) {\n\t\tstruct g4x_pipe_wm *raw = &crtc_state->wm.g4x.raw[level];\n\n\t\tdirty |= raw->plane[plane_id] != value;\n\t\traw->plane[plane_id] = value;\n\t}\n\n\treturn dirty;\n}\n\nstatic bool g4x_raw_fbc_wm_set(struct intel_crtc_state *crtc_state,\n\t\t\t       int level, u16 value)\n{\n\tstruct drm_i915_private *dev_priv = to_i915(crtc_state->uapi.crtc->dev);\n\tbool dirty = false;\n\n\t \n\tlevel = max(level, G4X_WM_LEVEL_SR);\n\n\tfor (; level < dev_priv->display.wm.num_levels; level++) {\n\t\tstruct g4x_pipe_wm *raw = &crtc_state->wm.g4x.raw[level];\n\n\t\tdirty |= raw->fbc != value;\n\t\traw->fbc = value;\n\t}\n\n\treturn dirty;\n}\n\nstatic u32 ilk_compute_fbc_wm(const struct intel_crtc_state *crtc_state,\n\t\t\t      const struct intel_plane_state *plane_state,\n\t\t\t      u32 pri_val);\n\nstatic bool g4x_raw_plane_wm_compute(struct intel_crtc_state *crtc_state,\n\t\t\t\t     const struct intel_plane_state *plane_state)\n{\n\tstruct intel_plane *plane = to_intel_plane(plane_state->uapi.plane);\n\tstruct drm_i915_private *dev_priv = to_i915(crtc_state->uapi.crtc->dev);\n\tenum plane_id plane_id = plane->id;\n\tbool dirty = false;\n\tint level;\n\n\tif (!intel_wm_plane_visible(crtc_state, plane_state)) {\n\t\tdirty |= g4x_raw_plane_wm_set(crtc_state, 0, plane_id, 0);\n\t\tif (plane_id == PLANE_PRIMARY)\n\t\t\tdirty |= g4x_raw_fbc_wm_set(crtc_state, 0, 0);\n\t\tgoto out;\n\t}\n\n\tfor (level = 0; level < dev_priv->display.wm.num_levels; level++) {\n\t\tstruct g4x_pipe_wm *raw = &crtc_state->wm.g4x.raw[level];\n\t\tint wm, max_wm;\n\n\t\twm = g4x_compute_wm(crtc_state, plane_state, level);\n\t\tmax_wm = g4x_plane_fifo_size(plane_id, level);\n\n\t\tif (wm > max_wm)\n\t\t\tbreak;\n\n\t\tdirty |= raw->plane[plane_id] != wm;\n\t\traw->plane[plane_id] = wm;\n\n\t\tif (plane_id != PLANE_PRIMARY ||\n\t\t    level == G4X_WM_LEVEL_NORMAL)\n\t\t\tcontinue;\n\n\t\twm = ilk_compute_fbc_wm(crtc_state, plane_state,\n\t\t\t\t\traw->plane[plane_id]);\n\t\tmax_wm = g4x_fbc_fifo_size(level);\n\n\t\t \n\t\tif (wm > max_wm)\n\t\t\twm = USHRT_MAX;\n\n\t\tdirty |= raw->fbc != wm;\n\t\traw->fbc = wm;\n\t}\n\n\t \n\tdirty |= g4x_raw_plane_wm_set(crtc_state, level, plane_id, USHRT_MAX);\n\n\tif (plane_id == PLANE_PRIMARY)\n\t\tdirty |= g4x_raw_fbc_wm_set(crtc_state, level, USHRT_MAX);\n\n out:\n\tif (dirty) {\n\t\tdrm_dbg_kms(&dev_priv->drm,\n\t\t\t    \"%s watermarks: normal=%d, SR=%d, HPLL=%d\\n\",\n\t\t\t    plane->base.name,\n\t\t\t    crtc_state->wm.g4x.raw[G4X_WM_LEVEL_NORMAL].plane[plane_id],\n\t\t\t    crtc_state->wm.g4x.raw[G4X_WM_LEVEL_SR].plane[plane_id],\n\t\t\t    crtc_state->wm.g4x.raw[G4X_WM_LEVEL_HPLL].plane[plane_id]);\n\n\t\tif (plane_id == PLANE_PRIMARY)\n\t\t\tdrm_dbg_kms(&dev_priv->drm,\n\t\t\t\t    \"FBC watermarks: SR=%d, HPLL=%d\\n\",\n\t\t\t\t    crtc_state->wm.g4x.raw[G4X_WM_LEVEL_SR].fbc,\n\t\t\t\t    crtc_state->wm.g4x.raw[G4X_WM_LEVEL_HPLL].fbc);\n\t}\n\n\treturn dirty;\n}\n\nstatic bool g4x_raw_plane_wm_is_valid(const struct intel_crtc_state *crtc_state,\n\t\t\t\t      enum plane_id plane_id, int level)\n{\n\tconst struct g4x_pipe_wm *raw = &crtc_state->wm.g4x.raw[level];\n\n\treturn raw->plane[plane_id] <= g4x_plane_fifo_size(plane_id, level);\n}\n\nstatic bool g4x_raw_crtc_wm_is_valid(const struct intel_crtc_state *crtc_state,\n\t\t\t\t     int level)\n{\n\tstruct drm_i915_private *dev_priv = to_i915(crtc_state->uapi.crtc->dev);\n\n\tif (level >= dev_priv->display.wm.num_levels)\n\t\treturn false;\n\n\treturn g4x_raw_plane_wm_is_valid(crtc_state, PLANE_PRIMARY, level) &&\n\t\tg4x_raw_plane_wm_is_valid(crtc_state, PLANE_SPRITE0, level) &&\n\t\tg4x_raw_plane_wm_is_valid(crtc_state, PLANE_CURSOR, level);\n}\n\n \nstatic void g4x_invalidate_wms(struct intel_crtc *crtc,\n\t\t\t       struct g4x_wm_state *wm_state, int level)\n{\n\tif (level <= G4X_WM_LEVEL_NORMAL) {\n\t\tenum plane_id plane_id;\n\n\t\tfor_each_plane_id_on_crtc(crtc, plane_id)\n\t\t\twm_state->wm.plane[plane_id] = USHRT_MAX;\n\t}\n\n\tif (level <= G4X_WM_LEVEL_SR) {\n\t\twm_state->cxsr = false;\n\t\twm_state->sr.cursor = USHRT_MAX;\n\t\twm_state->sr.plane = USHRT_MAX;\n\t\twm_state->sr.fbc = USHRT_MAX;\n\t}\n\n\tif (level <= G4X_WM_LEVEL_HPLL) {\n\t\twm_state->hpll_en = false;\n\t\twm_state->hpll.cursor = USHRT_MAX;\n\t\twm_state->hpll.plane = USHRT_MAX;\n\t\twm_state->hpll.fbc = USHRT_MAX;\n\t}\n}\n\nstatic bool g4x_compute_fbc_en(const struct g4x_wm_state *wm_state,\n\t\t\t       int level)\n{\n\tif (level < G4X_WM_LEVEL_SR)\n\t\treturn false;\n\n\tif (level >= G4X_WM_LEVEL_SR &&\n\t    wm_state->sr.fbc > g4x_fbc_fifo_size(G4X_WM_LEVEL_SR))\n\t\treturn false;\n\n\tif (level >= G4X_WM_LEVEL_HPLL &&\n\t    wm_state->hpll.fbc > g4x_fbc_fifo_size(G4X_WM_LEVEL_HPLL))\n\t\treturn false;\n\n\treturn true;\n}\n\nstatic int _g4x_compute_pipe_wm(struct intel_crtc_state *crtc_state)\n{\n\tstruct intel_crtc *crtc = to_intel_crtc(crtc_state->uapi.crtc);\n\tstruct g4x_wm_state *wm_state = &crtc_state->wm.g4x.optimal;\n\tu8 active_planes = crtc_state->active_planes & ~BIT(PLANE_CURSOR);\n\tconst struct g4x_pipe_wm *raw;\n\tenum plane_id plane_id;\n\tint level;\n\n\tlevel = G4X_WM_LEVEL_NORMAL;\n\tif (!g4x_raw_crtc_wm_is_valid(crtc_state, level))\n\t\tgoto out;\n\n\traw = &crtc_state->wm.g4x.raw[level];\n\tfor_each_plane_id_on_crtc(crtc, plane_id)\n\t\twm_state->wm.plane[plane_id] = raw->plane[plane_id];\n\n\tlevel = G4X_WM_LEVEL_SR;\n\tif (!g4x_raw_crtc_wm_is_valid(crtc_state, level))\n\t\tgoto out;\n\n\traw = &crtc_state->wm.g4x.raw[level];\n\twm_state->sr.plane = raw->plane[PLANE_PRIMARY];\n\twm_state->sr.cursor = raw->plane[PLANE_CURSOR];\n\twm_state->sr.fbc = raw->fbc;\n\n\twm_state->cxsr = active_planes == BIT(PLANE_PRIMARY);\n\n\tlevel = G4X_WM_LEVEL_HPLL;\n\tif (!g4x_raw_crtc_wm_is_valid(crtc_state, level))\n\t\tgoto out;\n\n\traw = &crtc_state->wm.g4x.raw[level];\n\twm_state->hpll.plane = raw->plane[PLANE_PRIMARY];\n\twm_state->hpll.cursor = raw->plane[PLANE_CURSOR];\n\twm_state->hpll.fbc = raw->fbc;\n\n\twm_state->hpll_en = wm_state->cxsr;\n\n\tlevel++;\n\n out:\n\tif (level == G4X_WM_LEVEL_NORMAL)\n\t\treturn -EINVAL;\n\n\t \n\tg4x_invalidate_wms(crtc, wm_state, level);\n\n\t \n\twm_state->fbc_en = g4x_compute_fbc_en(wm_state, level - 1);\n\n\treturn 0;\n}\n\nstatic int g4x_compute_pipe_wm(struct intel_atomic_state *state,\n\t\t\t       struct intel_crtc *crtc)\n{\n\tstruct intel_crtc_state *crtc_state =\n\t\tintel_atomic_get_new_crtc_state(state, crtc);\n\tconst struct intel_plane_state *old_plane_state;\n\tconst struct intel_plane_state *new_plane_state;\n\tstruct intel_plane *plane;\n\tunsigned int dirty = 0;\n\tint i;\n\n\tfor_each_oldnew_intel_plane_in_state(state, plane,\n\t\t\t\t\t     old_plane_state,\n\t\t\t\t\t     new_plane_state, i) {\n\t\tif (new_plane_state->hw.crtc != &crtc->base &&\n\t\t    old_plane_state->hw.crtc != &crtc->base)\n\t\t\tcontinue;\n\n\t\tif (g4x_raw_plane_wm_compute(crtc_state, new_plane_state))\n\t\t\tdirty |= BIT(plane->id);\n\t}\n\n\tif (!dirty)\n\t\treturn 0;\n\n\treturn _g4x_compute_pipe_wm(crtc_state);\n}\n\nstatic int g4x_compute_intermediate_wm(struct intel_atomic_state *state,\n\t\t\t\t       struct intel_crtc *crtc)\n{\n\tstruct drm_i915_private *dev_priv = to_i915(crtc->base.dev);\n\tstruct intel_crtc_state *new_crtc_state =\n\t\tintel_atomic_get_new_crtc_state(state, crtc);\n\tconst struct intel_crtc_state *old_crtc_state =\n\t\tintel_atomic_get_old_crtc_state(state, crtc);\n\tstruct g4x_wm_state *intermediate = &new_crtc_state->wm.g4x.intermediate;\n\tconst struct g4x_wm_state *optimal = &new_crtc_state->wm.g4x.optimal;\n\tconst struct g4x_wm_state *active = &old_crtc_state->wm.g4x.optimal;\n\tenum plane_id plane_id;\n\n\tif (!new_crtc_state->hw.active ||\n\t    intel_crtc_needs_modeset(new_crtc_state)) {\n\t\t*intermediate = *optimal;\n\n\t\tintermediate->cxsr = false;\n\t\tintermediate->hpll_en = false;\n\t\tgoto out;\n\t}\n\n\tintermediate->cxsr = optimal->cxsr && active->cxsr &&\n\t\t!new_crtc_state->disable_cxsr;\n\tintermediate->hpll_en = optimal->hpll_en && active->hpll_en &&\n\t\t!new_crtc_state->disable_cxsr;\n\tintermediate->fbc_en = optimal->fbc_en && active->fbc_en;\n\n\tfor_each_plane_id_on_crtc(crtc, plane_id) {\n\t\tintermediate->wm.plane[plane_id] =\n\t\t\tmax(optimal->wm.plane[plane_id],\n\t\t\t    active->wm.plane[plane_id]);\n\n\t\tdrm_WARN_ON(&dev_priv->drm, intermediate->wm.plane[plane_id] >\n\t\t\t    g4x_plane_fifo_size(plane_id, G4X_WM_LEVEL_NORMAL));\n\t}\n\n\tintermediate->sr.plane = max(optimal->sr.plane,\n\t\t\t\t     active->sr.plane);\n\tintermediate->sr.cursor = max(optimal->sr.cursor,\n\t\t\t\t      active->sr.cursor);\n\tintermediate->sr.fbc = max(optimal->sr.fbc,\n\t\t\t\t   active->sr.fbc);\n\n\tintermediate->hpll.plane = max(optimal->hpll.plane,\n\t\t\t\t       active->hpll.plane);\n\tintermediate->hpll.cursor = max(optimal->hpll.cursor,\n\t\t\t\t\tactive->hpll.cursor);\n\tintermediate->hpll.fbc = max(optimal->hpll.fbc,\n\t\t\t\t     active->hpll.fbc);\n\n\tdrm_WARN_ON(&dev_priv->drm,\n\t\t    (intermediate->sr.plane >\n\t\t     g4x_plane_fifo_size(PLANE_PRIMARY, G4X_WM_LEVEL_SR) ||\n\t\t     intermediate->sr.cursor >\n\t\t     g4x_plane_fifo_size(PLANE_CURSOR, G4X_WM_LEVEL_SR)) &&\n\t\t    intermediate->cxsr);\n\tdrm_WARN_ON(&dev_priv->drm,\n\t\t    (intermediate->sr.plane >\n\t\t     g4x_plane_fifo_size(PLANE_PRIMARY, G4X_WM_LEVEL_HPLL) ||\n\t\t     intermediate->sr.cursor >\n\t\t     g4x_plane_fifo_size(PLANE_CURSOR, G4X_WM_LEVEL_HPLL)) &&\n\t\t    intermediate->hpll_en);\n\n\tdrm_WARN_ON(&dev_priv->drm,\n\t\t    intermediate->sr.fbc > g4x_fbc_fifo_size(1) &&\n\t\t    intermediate->fbc_en && intermediate->cxsr);\n\tdrm_WARN_ON(&dev_priv->drm,\n\t\t    intermediate->hpll.fbc > g4x_fbc_fifo_size(2) &&\n\t\t    intermediate->fbc_en && intermediate->hpll_en);\n\nout:\n\t \n\tif (memcmp(intermediate, optimal, sizeof(*intermediate)) != 0)\n\t\tnew_crtc_state->wm.need_postvbl_update = true;\n\n\treturn 0;\n}\n\nstatic void g4x_merge_wm(struct drm_i915_private *dev_priv,\n\t\t\t struct g4x_wm_values *wm)\n{\n\tstruct intel_crtc *crtc;\n\tint num_active_pipes = 0;\n\n\twm->cxsr = true;\n\twm->hpll_en = true;\n\twm->fbc_en = true;\n\n\tfor_each_intel_crtc(&dev_priv->drm, crtc) {\n\t\tconst struct g4x_wm_state *wm_state = &crtc->wm.active.g4x;\n\n\t\tif (!crtc->active)\n\t\t\tcontinue;\n\n\t\tif (!wm_state->cxsr)\n\t\t\twm->cxsr = false;\n\t\tif (!wm_state->hpll_en)\n\t\t\twm->hpll_en = false;\n\t\tif (!wm_state->fbc_en)\n\t\t\twm->fbc_en = false;\n\n\t\tnum_active_pipes++;\n\t}\n\n\tif (num_active_pipes != 1) {\n\t\twm->cxsr = false;\n\t\twm->hpll_en = false;\n\t\twm->fbc_en = false;\n\t}\n\n\tfor_each_intel_crtc(&dev_priv->drm, crtc) {\n\t\tconst struct g4x_wm_state *wm_state = &crtc->wm.active.g4x;\n\t\tenum pipe pipe = crtc->pipe;\n\n\t\twm->pipe[pipe] = wm_state->wm;\n\t\tif (crtc->active && wm->cxsr)\n\t\t\twm->sr = wm_state->sr;\n\t\tif (crtc->active && wm->hpll_en)\n\t\t\twm->hpll = wm_state->hpll;\n\t}\n}\n\nstatic void g4x_program_watermarks(struct drm_i915_private *dev_priv)\n{\n\tstruct g4x_wm_values *old_wm = &dev_priv->display.wm.g4x;\n\tstruct g4x_wm_values new_wm = {};\n\n\tg4x_merge_wm(dev_priv, &new_wm);\n\n\tif (memcmp(old_wm, &new_wm, sizeof(new_wm)) == 0)\n\t\treturn;\n\n\tif (is_disabling(old_wm->cxsr, new_wm.cxsr, true))\n\t\t_intel_set_memory_cxsr(dev_priv, false);\n\n\tg4x_write_wm_values(dev_priv, &new_wm);\n\n\tif (is_enabling(old_wm->cxsr, new_wm.cxsr, true))\n\t\t_intel_set_memory_cxsr(dev_priv, true);\n\n\t*old_wm = new_wm;\n}\n\nstatic void g4x_initial_watermarks(struct intel_atomic_state *state,\n\t\t\t\t   struct intel_crtc *crtc)\n{\n\tstruct drm_i915_private *dev_priv = to_i915(crtc->base.dev);\n\tconst struct intel_crtc_state *crtc_state =\n\t\tintel_atomic_get_new_crtc_state(state, crtc);\n\n\tmutex_lock(&dev_priv->display.wm.wm_mutex);\n\tcrtc->wm.active.g4x = crtc_state->wm.g4x.intermediate;\n\tg4x_program_watermarks(dev_priv);\n\tmutex_unlock(&dev_priv->display.wm.wm_mutex);\n}\n\nstatic void g4x_optimize_watermarks(struct intel_atomic_state *state,\n\t\t\t\t    struct intel_crtc *crtc)\n{\n\tstruct drm_i915_private *dev_priv = to_i915(crtc->base.dev);\n\tconst struct intel_crtc_state *crtc_state =\n\t\tintel_atomic_get_new_crtc_state(state, crtc);\n\n\tif (!crtc_state->wm.need_postvbl_update)\n\t\treturn;\n\n\tmutex_lock(&dev_priv->display.wm.wm_mutex);\n\tcrtc->wm.active.g4x = crtc_state->wm.g4x.optimal;\n\tg4x_program_watermarks(dev_priv);\n\tmutex_unlock(&dev_priv->display.wm.wm_mutex);\n}\n\n \nstatic unsigned int vlv_wm_method2(unsigned int pixel_rate,\n\t\t\t\t   unsigned int htotal,\n\t\t\t\t   unsigned int width,\n\t\t\t\t   unsigned int cpp,\n\t\t\t\t   unsigned int latency)\n{\n\tunsigned int ret;\n\n\tret = intel_wm_method2(pixel_rate, htotal,\n\t\t\t       width, cpp, latency);\n\tret = DIV_ROUND_UP(ret, 64);\n\n\treturn ret;\n}\n\nstatic void vlv_setup_wm_latency(struct drm_i915_private *dev_priv)\n{\n\t \n\tdev_priv->display.wm.pri_latency[VLV_WM_LEVEL_PM2] = 3;\n\n\tdev_priv->display.wm.num_levels = VLV_WM_LEVEL_PM2 + 1;\n\n\tif (IS_CHERRYVIEW(dev_priv)) {\n\t\tdev_priv->display.wm.pri_latency[VLV_WM_LEVEL_PM5] = 12;\n\t\tdev_priv->display.wm.pri_latency[VLV_WM_LEVEL_DDR_DVFS] = 33;\n\n\t\tdev_priv->display.wm.num_levels = VLV_WM_LEVEL_DDR_DVFS + 1;\n\t}\n}\n\nstatic u16 vlv_compute_wm_level(const struct intel_crtc_state *crtc_state,\n\t\t\t\tconst struct intel_plane_state *plane_state,\n\t\t\t\tint level)\n{\n\tstruct intel_plane *plane = to_intel_plane(plane_state->uapi.plane);\n\tstruct drm_i915_private *dev_priv = to_i915(plane->base.dev);\n\tconst struct drm_display_mode *pipe_mode =\n\t\t&crtc_state->hw.pipe_mode;\n\tunsigned int pixel_rate, htotal, cpp, width, wm;\n\n\tif (dev_priv->display.wm.pri_latency[level] == 0)\n\t\treturn USHRT_MAX;\n\n\tif (!intel_wm_plane_visible(crtc_state, plane_state))\n\t\treturn 0;\n\n\tcpp = plane_state->hw.fb->format->cpp[0];\n\tpixel_rate = crtc_state->pixel_rate;\n\thtotal = pipe_mode->crtc_htotal;\n\twidth = drm_rect_width(&plane_state->uapi.src) >> 16;\n\n\tif (plane->id == PLANE_CURSOR) {\n\t\t \n\t\twm = 63;\n\t} else {\n\t\twm = vlv_wm_method2(pixel_rate, htotal, width, cpp,\n\t\t\t\t    dev_priv->display.wm.pri_latency[level] * 10);\n\t}\n\n\treturn min_t(unsigned int, wm, USHRT_MAX);\n}\n\nstatic bool vlv_need_sprite0_fifo_workaround(unsigned int active_planes)\n{\n\treturn (active_planes & (BIT(PLANE_SPRITE0) |\n\t\t\t\t BIT(PLANE_SPRITE1))) == BIT(PLANE_SPRITE1);\n}\n\nstatic int vlv_compute_fifo(struct intel_crtc_state *crtc_state)\n{\n\tstruct intel_crtc *crtc = to_intel_crtc(crtc_state->uapi.crtc);\n\tstruct drm_i915_private *dev_priv = to_i915(crtc->base.dev);\n\tconst struct g4x_pipe_wm *raw =\n\t\t&crtc_state->wm.vlv.raw[VLV_WM_LEVEL_PM2];\n\tstruct vlv_fifo_state *fifo_state = &crtc_state->wm.vlv.fifo_state;\n\tu8 active_planes = crtc_state->active_planes & ~BIT(PLANE_CURSOR);\n\tint num_active_planes = hweight8(active_planes);\n\tconst int fifo_size = 511;\n\tint fifo_extra, fifo_left = fifo_size;\n\tint sprite0_fifo_extra = 0;\n\tunsigned int total_rate;\n\tenum plane_id plane_id;\n\n\t \n\tif (vlv_need_sprite0_fifo_workaround(active_planes))\n\t\tsprite0_fifo_extra = 1;\n\n\ttotal_rate = raw->plane[PLANE_PRIMARY] +\n\t\traw->plane[PLANE_SPRITE0] +\n\t\traw->plane[PLANE_SPRITE1] +\n\t\tsprite0_fifo_extra;\n\n\tif (total_rate > fifo_size)\n\t\treturn -EINVAL;\n\n\tif (total_rate == 0)\n\t\ttotal_rate = 1;\n\n\tfor_each_plane_id_on_crtc(crtc, plane_id) {\n\t\tunsigned int rate;\n\n\t\tif ((active_planes & BIT(plane_id)) == 0) {\n\t\t\tfifo_state->plane[plane_id] = 0;\n\t\t\tcontinue;\n\t\t}\n\n\t\trate = raw->plane[plane_id];\n\t\tfifo_state->plane[plane_id] = fifo_size * rate / total_rate;\n\t\tfifo_left -= fifo_state->plane[plane_id];\n\t}\n\n\tfifo_state->plane[PLANE_SPRITE0] += sprite0_fifo_extra;\n\tfifo_left -= sprite0_fifo_extra;\n\n\tfifo_state->plane[PLANE_CURSOR] = 63;\n\n\tfifo_extra = DIV_ROUND_UP(fifo_left, num_active_planes ?: 1);\n\n\t \n\tfor_each_plane_id_on_crtc(crtc, plane_id) {\n\t\tint plane_extra;\n\n\t\tif (fifo_left == 0)\n\t\t\tbreak;\n\n\t\tif ((active_planes & BIT(plane_id)) == 0)\n\t\t\tcontinue;\n\n\t\tplane_extra = min(fifo_extra, fifo_left);\n\t\tfifo_state->plane[plane_id] += plane_extra;\n\t\tfifo_left -= plane_extra;\n\t}\n\n\tdrm_WARN_ON(&dev_priv->drm, active_planes != 0 && fifo_left != 0);\n\n\t \n\tif (active_planes == 0) {\n\t\tdrm_WARN_ON(&dev_priv->drm, fifo_left != fifo_size);\n\t\tfifo_state->plane[PLANE_PRIMARY] = fifo_left;\n\t}\n\n\treturn 0;\n}\n\n \nstatic void vlv_invalidate_wms(struct intel_crtc *crtc,\n\t\t\t       struct vlv_wm_state *wm_state, int level)\n{\n\tstruct drm_i915_private *dev_priv = to_i915(crtc->base.dev);\n\n\tfor (; level < dev_priv->display.wm.num_levels; level++) {\n\t\tenum plane_id plane_id;\n\n\t\tfor_each_plane_id_on_crtc(crtc, plane_id)\n\t\t\twm_state->wm[level].plane[plane_id] = USHRT_MAX;\n\n\t\twm_state->sr[level].cursor = USHRT_MAX;\n\t\twm_state->sr[level].plane = USHRT_MAX;\n\t}\n}\n\nstatic u16 vlv_invert_wm_value(u16 wm, u16 fifo_size)\n{\n\tif (wm > fifo_size)\n\t\treturn USHRT_MAX;\n\telse\n\t\treturn fifo_size - wm;\n}\n\n \nstatic bool vlv_raw_plane_wm_set(struct intel_crtc_state *crtc_state,\n\t\t\t\t int level, enum plane_id plane_id, u16 value)\n{\n\tstruct drm_i915_private *dev_priv = to_i915(crtc_state->uapi.crtc->dev);\n\tbool dirty = false;\n\n\tfor (; level < dev_priv->display.wm.num_levels; level++) {\n\t\tstruct g4x_pipe_wm *raw = &crtc_state->wm.vlv.raw[level];\n\n\t\tdirty |= raw->plane[plane_id] != value;\n\t\traw->plane[plane_id] = value;\n\t}\n\n\treturn dirty;\n}\n\nstatic bool vlv_raw_plane_wm_compute(struct intel_crtc_state *crtc_state,\n\t\t\t\t     const struct intel_plane_state *plane_state)\n{\n\tstruct intel_plane *plane = to_intel_plane(plane_state->uapi.plane);\n\tstruct drm_i915_private *dev_priv = to_i915(crtc_state->uapi.crtc->dev);\n\tenum plane_id plane_id = plane->id;\n\tint level;\n\tbool dirty = false;\n\n\tif (!intel_wm_plane_visible(crtc_state, plane_state)) {\n\t\tdirty |= vlv_raw_plane_wm_set(crtc_state, 0, plane_id, 0);\n\t\tgoto out;\n\t}\n\n\tfor (level = 0; level < dev_priv->display.wm.num_levels; level++) {\n\t\tstruct g4x_pipe_wm *raw = &crtc_state->wm.vlv.raw[level];\n\t\tint wm = vlv_compute_wm_level(crtc_state, plane_state, level);\n\t\tint max_wm = plane_id == PLANE_CURSOR ? 63 : 511;\n\n\t\tif (wm > max_wm)\n\t\t\tbreak;\n\n\t\tdirty |= raw->plane[plane_id] != wm;\n\t\traw->plane[plane_id] = wm;\n\t}\n\n\t \n\tdirty |= vlv_raw_plane_wm_set(crtc_state, level, plane_id, USHRT_MAX);\n\nout:\n\tif (dirty)\n\t\tdrm_dbg_kms(&dev_priv->drm,\n\t\t\t    \"%s watermarks: PM2=%d, PM5=%d, DDR DVFS=%d\\n\",\n\t\t\t    plane->base.name,\n\t\t\t    crtc_state->wm.vlv.raw[VLV_WM_LEVEL_PM2].plane[plane_id],\n\t\t\t    crtc_state->wm.vlv.raw[VLV_WM_LEVEL_PM5].plane[plane_id],\n\t\t\t    crtc_state->wm.vlv.raw[VLV_WM_LEVEL_DDR_DVFS].plane[plane_id]);\n\n\treturn dirty;\n}\n\nstatic bool vlv_raw_plane_wm_is_valid(const struct intel_crtc_state *crtc_state,\n\t\t\t\t      enum plane_id plane_id, int level)\n{\n\tconst struct g4x_pipe_wm *raw =\n\t\t&crtc_state->wm.vlv.raw[level];\n\tconst struct vlv_fifo_state *fifo_state =\n\t\t&crtc_state->wm.vlv.fifo_state;\n\n\treturn raw->plane[plane_id] <= fifo_state->plane[plane_id];\n}\n\nstatic bool vlv_raw_crtc_wm_is_valid(const struct intel_crtc_state *crtc_state, int level)\n{\n\treturn vlv_raw_plane_wm_is_valid(crtc_state, PLANE_PRIMARY, level) &&\n\t\tvlv_raw_plane_wm_is_valid(crtc_state, PLANE_SPRITE0, level) &&\n\t\tvlv_raw_plane_wm_is_valid(crtc_state, PLANE_SPRITE1, level) &&\n\t\tvlv_raw_plane_wm_is_valid(crtc_state, PLANE_CURSOR, level);\n}\n\nstatic int _vlv_compute_pipe_wm(struct intel_crtc_state *crtc_state)\n{\n\tstruct intel_crtc *crtc = to_intel_crtc(crtc_state->uapi.crtc);\n\tstruct drm_i915_private *dev_priv = to_i915(crtc->base.dev);\n\tstruct vlv_wm_state *wm_state = &crtc_state->wm.vlv.optimal;\n\tconst struct vlv_fifo_state *fifo_state =\n\t\t&crtc_state->wm.vlv.fifo_state;\n\tu8 active_planes = crtc_state->active_planes & ~BIT(PLANE_CURSOR);\n\tint num_active_planes = hweight8(active_planes);\n\tenum plane_id plane_id;\n\tint level;\n\n\t \n\twm_state->num_levels = dev_priv->display.wm.num_levels;\n\t \n\twm_state->cxsr = crtc->pipe != PIPE_C && num_active_planes == 1;\n\n\tfor (level = 0; level < wm_state->num_levels; level++) {\n\t\tconst struct g4x_pipe_wm *raw = &crtc_state->wm.vlv.raw[level];\n\t\tconst int sr_fifo_size = INTEL_NUM_PIPES(dev_priv) * 512 - 1;\n\n\t\tif (!vlv_raw_crtc_wm_is_valid(crtc_state, level))\n\t\t\tbreak;\n\n\t\tfor_each_plane_id_on_crtc(crtc, plane_id) {\n\t\t\twm_state->wm[level].plane[plane_id] =\n\t\t\t\tvlv_invert_wm_value(raw->plane[plane_id],\n\t\t\t\t\t\t    fifo_state->plane[plane_id]);\n\t\t}\n\n\t\twm_state->sr[level].plane =\n\t\t\tvlv_invert_wm_value(max3(raw->plane[PLANE_PRIMARY],\n\t\t\t\t\t\t raw->plane[PLANE_SPRITE0],\n\t\t\t\t\t\t raw->plane[PLANE_SPRITE1]),\n\t\t\t\t\t    sr_fifo_size);\n\n\t\twm_state->sr[level].cursor =\n\t\t\tvlv_invert_wm_value(raw->plane[PLANE_CURSOR],\n\t\t\t\t\t    63);\n\t}\n\n\tif (level == 0)\n\t\treturn -EINVAL;\n\n\t \n\twm_state->num_levels = level;\n\n\t \n\tvlv_invalidate_wms(crtc, wm_state, level);\n\n\treturn 0;\n}\n\nstatic int vlv_compute_pipe_wm(struct intel_atomic_state *state,\n\t\t\t       struct intel_crtc *crtc)\n{\n\tstruct intel_crtc_state *crtc_state =\n\t\tintel_atomic_get_new_crtc_state(state, crtc);\n\tconst struct intel_plane_state *old_plane_state;\n\tconst struct intel_plane_state *new_plane_state;\n\tstruct intel_plane *plane;\n\tunsigned int dirty = 0;\n\tint i;\n\n\tfor_each_oldnew_intel_plane_in_state(state, plane,\n\t\t\t\t\t     old_plane_state,\n\t\t\t\t\t     new_plane_state, i) {\n\t\tif (new_plane_state->hw.crtc != &crtc->base &&\n\t\t    old_plane_state->hw.crtc != &crtc->base)\n\t\t\tcontinue;\n\n\t\tif (vlv_raw_plane_wm_compute(crtc_state, new_plane_state))\n\t\t\tdirty |= BIT(plane->id);\n\t}\n\n\t \n\tif (intel_crtc_needs_modeset(crtc_state))\n\t\tdirty = ~0;\n\n\tif (!dirty)\n\t\treturn 0;\n\n\t \n\tif (dirty & ~BIT(PLANE_CURSOR)) {\n\t\tconst struct intel_crtc_state *old_crtc_state =\n\t\t\tintel_atomic_get_old_crtc_state(state, crtc);\n\t\tconst struct vlv_fifo_state *old_fifo_state =\n\t\t\t&old_crtc_state->wm.vlv.fifo_state;\n\t\tconst struct vlv_fifo_state *new_fifo_state =\n\t\t\t&crtc_state->wm.vlv.fifo_state;\n\t\tint ret;\n\n\t\tret = vlv_compute_fifo(crtc_state);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tif (intel_crtc_needs_modeset(crtc_state) ||\n\t\t    memcmp(old_fifo_state, new_fifo_state,\n\t\t\t   sizeof(*new_fifo_state)) != 0)\n\t\t\tcrtc_state->fifo_changed = true;\n\t}\n\n\treturn _vlv_compute_pipe_wm(crtc_state);\n}\n\n#define VLV_FIFO(plane, value) \\\n\t(((value) << DSPARB_ ## plane ## _SHIFT_VLV) & DSPARB_ ## plane ## _MASK_VLV)\n\nstatic void vlv_atomic_update_fifo(struct intel_atomic_state *state,\n\t\t\t\t   struct intel_crtc *crtc)\n{\n\tstruct drm_i915_private *dev_priv = to_i915(crtc->base.dev);\n\tstruct intel_uncore *uncore = &dev_priv->uncore;\n\tconst struct intel_crtc_state *crtc_state =\n\t\tintel_atomic_get_new_crtc_state(state, crtc);\n\tconst struct vlv_fifo_state *fifo_state =\n\t\t&crtc_state->wm.vlv.fifo_state;\n\tint sprite0_start, sprite1_start, fifo_size;\n\tu32 dsparb, dsparb2, dsparb3;\n\n\tif (!crtc_state->fifo_changed)\n\t\treturn;\n\n\tsprite0_start = fifo_state->plane[PLANE_PRIMARY];\n\tsprite1_start = fifo_state->plane[PLANE_SPRITE0] + sprite0_start;\n\tfifo_size = fifo_state->plane[PLANE_SPRITE1] + sprite1_start;\n\n\tdrm_WARN_ON(&dev_priv->drm, fifo_state->plane[PLANE_CURSOR] != 63);\n\tdrm_WARN_ON(&dev_priv->drm, fifo_size != 511);\n\n\ttrace_vlv_fifo_size(crtc, sprite0_start, sprite1_start, fifo_size);\n\n\t \n\tspin_lock(&uncore->lock);\n\n\tswitch (crtc->pipe) {\n\tcase PIPE_A:\n\t\tdsparb = intel_uncore_read_fw(uncore, DSPARB);\n\t\tdsparb2 = intel_uncore_read_fw(uncore, DSPARB2);\n\n\t\tdsparb &= ~(VLV_FIFO(SPRITEA, 0xff) |\n\t\t\t    VLV_FIFO(SPRITEB, 0xff));\n\t\tdsparb |= (VLV_FIFO(SPRITEA, sprite0_start) |\n\t\t\t   VLV_FIFO(SPRITEB, sprite1_start));\n\n\t\tdsparb2 &= ~(VLV_FIFO(SPRITEA_HI, 0x1) |\n\t\t\t     VLV_FIFO(SPRITEB_HI, 0x1));\n\t\tdsparb2 |= (VLV_FIFO(SPRITEA_HI, sprite0_start >> 8) |\n\t\t\t   VLV_FIFO(SPRITEB_HI, sprite1_start >> 8));\n\n\t\tintel_uncore_write_fw(uncore, DSPARB, dsparb);\n\t\tintel_uncore_write_fw(uncore, DSPARB2, dsparb2);\n\t\tbreak;\n\tcase PIPE_B:\n\t\tdsparb = intel_uncore_read_fw(uncore, DSPARB);\n\t\tdsparb2 = intel_uncore_read_fw(uncore, DSPARB2);\n\n\t\tdsparb &= ~(VLV_FIFO(SPRITEC, 0xff) |\n\t\t\t    VLV_FIFO(SPRITED, 0xff));\n\t\tdsparb |= (VLV_FIFO(SPRITEC, sprite0_start) |\n\t\t\t   VLV_FIFO(SPRITED, sprite1_start));\n\n\t\tdsparb2 &= ~(VLV_FIFO(SPRITEC_HI, 0xff) |\n\t\t\t     VLV_FIFO(SPRITED_HI, 0xff));\n\t\tdsparb2 |= (VLV_FIFO(SPRITEC_HI, sprite0_start >> 8) |\n\t\t\t   VLV_FIFO(SPRITED_HI, sprite1_start >> 8));\n\n\t\tintel_uncore_write_fw(uncore, DSPARB, dsparb);\n\t\tintel_uncore_write_fw(uncore, DSPARB2, dsparb2);\n\t\tbreak;\n\tcase PIPE_C:\n\t\tdsparb3 = intel_uncore_read_fw(uncore, DSPARB3);\n\t\tdsparb2 = intel_uncore_read_fw(uncore, DSPARB2);\n\n\t\tdsparb3 &= ~(VLV_FIFO(SPRITEE, 0xff) |\n\t\t\t     VLV_FIFO(SPRITEF, 0xff));\n\t\tdsparb3 |= (VLV_FIFO(SPRITEE, sprite0_start) |\n\t\t\t    VLV_FIFO(SPRITEF, sprite1_start));\n\n\t\tdsparb2 &= ~(VLV_FIFO(SPRITEE_HI, 0xff) |\n\t\t\t     VLV_FIFO(SPRITEF_HI, 0xff));\n\t\tdsparb2 |= (VLV_FIFO(SPRITEE_HI, sprite0_start >> 8) |\n\t\t\t   VLV_FIFO(SPRITEF_HI, sprite1_start >> 8));\n\n\t\tintel_uncore_write_fw(uncore, DSPARB3, dsparb3);\n\t\tintel_uncore_write_fw(uncore, DSPARB2, dsparb2);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tintel_uncore_posting_read_fw(uncore, DSPARB);\n\n\tspin_unlock(&uncore->lock);\n}\n\n#undef VLV_FIFO\n\nstatic int vlv_compute_intermediate_wm(struct intel_atomic_state *state,\n\t\t\t\t       struct intel_crtc *crtc)\n{\n\tstruct intel_crtc_state *new_crtc_state =\n\t\tintel_atomic_get_new_crtc_state(state, crtc);\n\tconst struct intel_crtc_state *old_crtc_state =\n\t\tintel_atomic_get_old_crtc_state(state, crtc);\n\tstruct vlv_wm_state *intermediate = &new_crtc_state->wm.vlv.intermediate;\n\tconst struct vlv_wm_state *optimal = &new_crtc_state->wm.vlv.optimal;\n\tconst struct vlv_wm_state *active = &old_crtc_state->wm.vlv.optimal;\n\tint level;\n\n\tif (!new_crtc_state->hw.active ||\n\t    intel_crtc_needs_modeset(new_crtc_state)) {\n\t\t*intermediate = *optimal;\n\n\t\tintermediate->cxsr = false;\n\t\tgoto out;\n\t}\n\n\tintermediate->num_levels = min(optimal->num_levels, active->num_levels);\n\tintermediate->cxsr = optimal->cxsr && active->cxsr &&\n\t\t!new_crtc_state->disable_cxsr;\n\n\tfor (level = 0; level < intermediate->num_levels; level++) {\n\t\tenum plane_id plane_id;\n\n\t\tfor_each_plane_id_on_crtc(crtc, plane_id) {\n\t\t\tintermediate->wm[level].plane[plane_id] =\n\t\t\t\tmin(optimal->wm[level].plane[plane_id],\n\t\t\t\t    active->wm[level].plane[plane_id]);\n\t\t}\n\n\t\tintermediate->sr[level].plane = min(optimal->sr[level].plane,\n\t\t\t\t\t\t    active->sr[level].plane);\n\t\tintermediate->sr[level].cursor = min(optimal->sr[level].cursor,\n\t\t\t\t\t\t     active->sr[level].cursor);\n\t}\n\n\tvlv_invalidate_wms(crtc, intermediate, level);\n\nout:\n\t \n\tif (memcmp(intermediate, optimal, sizeof(*intermediate)) != 0)\n\t\tnew_crtc_state->wm.need_postvbl_update = true;\n\n\treturn 0;\n}\n\nstatic void vlv_merge_wm(struct drm_i915_private *dev_priv,\n\t\t\t struct vlv_wm_values *wm)\n{\n\tstruct intel_crtc *crtc;\n\tint num_active_pipes = 0;\n\n\twm->level = dev_priv->display.wm.num_levels - 1;\n\twm->cxsr = true;\n\n\tfor_each_intel_crtc(&dev_priv->drm, crtc) {\n\t\tconst struct vlv_wm_state *wm_state = &crtc->wm.active.vlv;\n\n\t\tif (!crtc->active)\n\t\t\tcontinue;\n\n\t\tif (!wm_state->cxsr)\n\t\t\twm->cxsr = false;\n\n\t\tnum_active_pipes++;\n\t\twm->level = min_t(int, wm->level, wm_state->num_levels - 1);\n\t}\n\n\tif (num_active_pipes != 1)\n\t\twm->cxsr = false;\n\n\tif (num_active_pipes > 1)\n\t\twm->level = VLV_WM_LEVEL_PM2;\n\n\tfor_each_intel_crtc(&dev_priv->drm, crtc) {\n\t\tconst struct vlv_wm_state *wm_state = &crtc->wm.active.vlv;\n\t\tenum pipe pipe = crtc->pipe;\n\n\t\twm->pipe[pipe] = wm_state->wm[wm->level];\n\t\tif (crtc->active && wm->cxsr)\n\t\t\twm->sr = wm_state->sr[wm->level];\n\n\t\twm->ddl[pipe].plane[PLANE_PRIMARY] = DDL_PRECISION_HIGH | 2;\n\t\twm->ddl[pipe].plane[PLANE_SPRITE0] = DDL_PRECISION_HIGH | 2;\n\t\twm->ddl[pipe].plane[PLANE_SPRITE1] = DDL_PRECISION_HIGH | 2;\n\t\twm->ddl[pipe].plane[PLANE_CURSOR] = DDL_PRECISION_HIGH | 2;\n\t}\n}\n\nstatic void vlv_program_watermarks(struct drm_i915_private *dev_priv)\n{\n\tstruct vlv_wm_values *old_wm = &dev_priv->display.wm.vlv;\n\tstruct vlv_wm_values new_wm = {};\n\n\tvlv_merge_wm(dev_priv, &new_wm);\n\n\tif (memcmp(old_wm, &new_wm, sizeof(new_wm)) == 0)\n\t\treturn;\n\n\tif (is_disabling(old_wm->level, new_wm.level, VLV_WM_LEVEL_DDR_DVFS))\n\t\tchv_set_memory_dvfs(dev_priv, false);\n\n\tif (is_disabling(old_wm->level, new_wm.level, VLV_WM_LEVEL_PM5))\n\t\tchv_set_memory_pm5(dev_priv, false);\n\n\tif (is_disabling(old_wm->cxsr, new_wm.cxsr, true))\n\t\t_intel_set_memory_cxsr(dev_priv, false);\n\n\tvlv_write_wm_values(dev_priv, &new_wm);\n\n\tif (is_enabling(old_wm->cxsr, new_wm.cxsr, true))\n\t\t_intel_set_memory_cxsr(dev_priv, true);\n\n\tif (is_enabling(old_wm->level, new_wm.level, VLV_WM_LEVEL_PM5))\n\t\tchv_set_memory_pm5(dev_priv, true);\n\n\tif (is_enabling(old_wm->level, new_wm.level, VLV_WM_LEVEL_DDR_DVFS))\n\t\tchv_set_memory_dvfs(dev_priv, true);\n\n\t*old_wm = new_wm;\n}\n\nstatic void vlv_initial_watermarks(struct intel_atomic_state *state,\n\t\t\t\t   struct intel_crtc *crtc)\n{\n\tstruct drm_i915_private *dev_priv = to_i915(crtc->base.dev);\n\tconst struct intel_crtc_state *crtc_state =\n\t\tintel_atomic_get_new_crtc_state(state, crtc);\n\n\tmutex_lock(&dev_priv->display.wm.wm_mutex);\n\tcrtc->wm.active.vlv = crtc_state->wm.vlv.intermediate;\n\tvlv_program_watermarks(dev_priv);\n\tmutex_unlock(&dev_priv->display.wm.wm_mutex);\n}\n\nstatic void vlv_optimize_watermarks(struct intel_atomic_state *state,\n\t\t\t\t    struct intel_crtc *crtc)\n{\n\tstruct drm_i915_private *dev_priv = to_i915(crtc->base.dev);\n\tconst struct intel_crtc_state *crtc_state =\n\t\tintel_atomic_get_new_crtc_state(state, crtc);\n\n\tif (!crtc_state->wm.need_postvbl_update)\n\t\treturn;\n\n\tmutex_lock(&dev_priv->display.wm.wm_mutex);\n\tcrtc->wm.active.vlv = crtc_state->wm.vlv.optimal;\n\tvlv_program_watermarks(dev_priv);\n\tmutex_unlock(&dev_priv->display.wm.wm_mutex);\n}\n\nstatic void i965_update_wm(struct drm_i915_private *dev_priv)\n{\n\tstruct intel_crtc *crtc;\n\tint srwm = 1;\n\tint cursor_sr = 16;\n\tbool cxsr_enabled;\n\n\t \n\tcrtc = single_enabled_crtc(dev_priv);\n\tif (crtc) {\n\t\t \n\t\tstatic const int sr_latency_ns = 12000;\n\t\tconst struct drm_display_mode *pipe_mode =\n\t\t\t&crtc->config->hw.pipe_mode;\n\t\tconst struct drm_framebuffer *fb =\n\t\t\tcrtc->base.primary->state->fb;\n\t\tint pixel_rate = crtc->config->pixel_rate;\n\t\tint htotal = pipe_mode->crtc_htotal;\n\t\tint width = drm_rect_width(&crtc->base.primary->state->src) >> 16;\n\t\tint cpp = fb->format->cpp[0];\n\t\tint entries;\n\n\t\tentries = intel_wm_method2(pixel_rate, htotal,\n\t\t\t\t\t   width, cpp, sr_latency_ns / 100);\n\t\tentries = DIV_ROUND_UP(entries, I915_FIFO_LINE_SIZE);\n\t\tsrwm = I965_FIFO_SIZE - entries;\n\t\tif (srwm < 0)\n\t\t\tsrwm = 1;\n\t\tsrwm &= 0x1ff;\n\t\tdrm_dbg_kms(&dev_priv->drm,\n\t\t\t    \"self-refresh entries: %d, wm: %d\\n\",\n\t\t\t    entries, srwm);\n\n\t\tentries = intel_wm_method2(pixel_rate, htotal,\n\t\t\t\t\t   crtc->base.cursor->state->crtc_w, 4,\n\t\t\t\t\t   sr_latency_ns / 100);\n\t\tentries = DIV_ROUND_UP(entries,\n\t\t\t\t       i965_cursor_wm_info.cacheline_size) +\n\t\t\ti965_cursor_wm_info.guard_size;\n\n\t\tcursor_sr = i965_cursor_wm_info.fifo_size - entries;\n\t\tif (cursor_sr > i965_cursor_wm_info.max_wm)\n\t\t\tcursor_sr = i965_cursor_wm_info.max_wm;\n\n\t\tdrm_dbg_kms(&dev_priv->drm,\n\t\t\t    \"self-refresh watermark: display plane %d \"\n\t\t\t    \"cursor %d\\n\", srwm, cursor_sr);\n\n\t\tcxsr_enabled = true;\n\t} else {\n\t\tcxsr_enabled = false;\n\t\t \n\t\tintel_set_memory_cxsr(dev_priv, false);\n\t}\n\n\tdrm_dbg_kms(&dev_priv->drm,\n\t\t    \"Setting FIFO watermarks - A: 8, B: 8, C: 8, SR %d\\n\",\n\t\t    srwm);\n\n\t \n\tintel_uncore_write(&dev_priv->uncore, DSPFW1, FW_WM(srwm, SR) |\n\t\t   FW_WM(8, CURSORB) |\n\t\t   FW_WM(8, PLANEB) |\n\t\t   FW_WM(8, PLANEA));\n\tintel_uncore_write(&dev_priv->uncore, DSPFW2, FW_WM(8, CURSORA) |\n\t\t   FW_WM(8, PLANEC_OLD));\n\t \n\tintel_uncore_write(&dev_priv->uncore, DSPFW3, FW_WM(cursor_sr, CURSOR_SR));\n\n\tif (cxsr_enabled)\n\t\tintel_set_memory_cxsr(dev_priv, true);\n}\n\n#undef FW_WM\n\nstatic struct intel_crtc *intel_crtc_for_plane(struct drm_i915_private *i915,\n\t\t\t\t\t       enum i9xx_plane_id i9xx_plane)\n{\n\tstruct intel_plane *plane;\n\n\tfor_each_intel_plane(&i915->drm, plane) {\n\t\tif (plane->id == PLANE_PRIMARY &&\n\t\t    plane->i9xx_plane == i9xx_plane)\n\t\t\treturn intel_crtc_for_pipe(i915, plane->pipe);\n\t}\n\n\treturn NULL;\n}\n\nstatic void i9xx_update_wm(struct drm_i915_private *dev_priv)\n{\n\tconst struct intel_watermark_params *wm_info;\n\tu32 fwater_lo;\n\tu32 fwater_hi;\n\tint cwm, srwm = 1;\n\tint fifo_size;\n\tint planea_wm, planeb_wm;\n\tstruct intel_crtc *crtc;\n\n\tif (IS_I945GM(dev_priv))\n\t\twm_info = &i945_wm_info;\n\telse if (DISPLAY_VER(dev_priv) != 2)\n\t\twm_info = &i915_wm_info;\n\telse\n\t\twm_info = &i830_a_wm_info;\n\n\tif (DISPLAY_VER(dev_priv) == 2)\n\t\tfifo_size = i830_get_fifo_size(dev_priv, PLANE_A);\n\telse\n\t\tfifo_size = i9xx_get_fifo_size(dev_priv, PLANE_A);\n\tcrtc = intel_crtc_for_plane(dev_priv, PLANE_A);\n\tif (intel_crtc_active(crtc)) {\n\t\tconst struct drm_framebuffer *fb =\n\t\t\tcrtc->base.primary->state->fb;\n\t\tint cpp;\n\n\t\tif (DISPLAY_VER(dev_priv) == 2)\n\t\t\tcpp = 4;\n\t\telse\n\t\t\tcpp = fb->format->cpp[0];\n\n\t\tplanea_wm = intel_calculate_wm(crtc->config->pixel_rate,\n\t\t\t\t\t       wm_info, fifo_size, cpp,\n\t\t\t\t\t       pessimal_latency_ns);\n\t} else {\n\t\tplanea_wm = fifo_size - wm_info->guard_size;\n\t\tif (planea_wm > (long)wm_info->max_wm)\n\t\t\tplanea_wm = wm_info->max_wm;\n\t}\n\n\tif (DISPLAY_VER(dev_priv) == 2)\n\t\twm_info = &i830_bc_wm_info;\n\n\tif (DISPLAY_VER(dev_priv) == 2)\n\t\tfifo_size = i830_get_fifo_size(dev_priv, PLANE_B);\n\telse\n\t\tfifo_size = i9xx_get_fifo_size(dev_priv, PLANE_B);\n\tcrtc = intel_crtc_for_plane(dev_priv, PLANE_B);\n\tif (intel_crtc_active(crtc)) {\n\t\tconst struct drm_framebuffer *fb =\n\t\t\tcrtc->base.primary->state->fb;\n\t\tint cpp;\n\n\t\tif (DISPLAY_VER(dev_priv) == 2)\n\t\t\tcpp = 4;\n\t\telse\n\t\t\tcpp = fb->format->cpp[0];\n\n\t\tplaneb_wm = intel_calculate_wm(crtc->config->pixel_rate,\n\t\t\t\t\t       wm_info, fifo_size, cpp,\n\t\t\t\t\t       pessimal_latency_ns);\n\t} else {\n\t\tplaneb_wm = fifo_size - wm_info->guard_size;\n\t\tif (planeb_wm > (long)wm_info->max_wm)\n\t\t\tplaneb_wm = wm_info->max_wm;\n\t}\n\n\tdrm_dbg_kms(&dev_priv->drm,\n\t\t    \"FIFO watermarks - A: %d, B: %d\\n\", planea_wm, planeb_wm);\n\n\tcrtc = single_enabled_crtc(dev_priv);\n\tif (IS_I915GM(dev_priv) && crtc) {\n\t\tstruct drm_i915_gem_object *obj;\n\n\t\tobj = intel_fb_obj(crtc->base.primary->state->fb);\n\n\t\t \n\t\tif (!i915_gem_object_is_tiled(obj))\n\t\t\tcrtc = NULL;\n\t}\n\n\t \n\tcwm = 2;\n\n\t \n\tintel_set_memory_cxsr(dev_priv, false);\n\n\t \n\tif (HAS_FW_BLC(dev_priv) && crtc) {\n\t\t \n\t\tstatic const int sr_latency_ns = 6000;\n\t\tconst struct drm_display_mode *pipe_mode =\n\t\t\t&crtc->config->hw.pipe_mode;\n\t\tconst struct drm_framebuffer *fb =\n\t\t\tcrtc->base.primary->state->fb;\n\t\tint pixel_rate = crtc->config->pixel_rate;\n\t\tint htotal = pipe_mode->crtc_htotal;\n\t\tint width = drm_rect_width(&crtc->base.primary->state->src) >> 16;\n\t\tint cpp;\n\t\tint entries;\n\n\t\tif (IS_I915GM(dev_priv) || IS_I945GM(dev_priv))\n\t\t\tcpp = 4;\n\t\telse\n\t\t\tcpp = fb->format->cpp[0];\n\n\t\tentries = intel_wm_method2(pixel_rate, htotal, width, cpp,\n\t\t\t\t\t   sr_latency_ns / 100);\n\t\tentries = DIV_ROUND_UP(entries, wm_info->cacheline_size);\n\t\tdrm_dbg_kms(&dev_priv->drm,\n\t\t\t    \"self-refresh entries: %d\\n\", entries);\n\t\tsrwm = wm_info->fifo_size - entries;\n\t\tif (srwm < 0)\n\t\t\tsrwm = 1;\n\n\t\tif (IS_I945G(dev_priv) || IS_I945GM(dev_priv))\n\t\t\tintel_uncore_write(&dev_priv->uncore, FW_BLC_SELF,\n\t\t\t\t   FW_BLC_SELF_FIFO_MASK | (srwm & 0xff));\n\t\telse\n\t\t\tintel_uncore_write(&dev_priv->uncore, FW_BLC_SELF, srwm & 0x3f);\n\t}\n\n\tdrm_dbg_kms(&dev_priv->drm,\n\t\t    \"Setting FIFO watermarks - A: %d, B: %d, C: %d, SR %d\\n\",\n\t\t     planea_wm, planeb_wm, cwm, srwm);\n\n\tfwater_lo = ((planeb_wm & 0x3f) << 16) | (planea_wm & 0x3f);\n\tfwater_hi = (cwm & 0x1f);\n\n\t \n\tfwater_lo = fwater_lo | (1 << 24) | (1 << 8);\n\tfwater_hi = fwater_hi | (1 << 8);\n\n\tintel_uncore_write(&dev_priv->uncore, FW_BLC, fwater_lo);\n\tintel_uncore_write(&dev_priv->uncore, FW_BLC2, fwater_hi);\n\n\tif (crtc)\n\t\tintel_set_memory_cxsr(dev_priv, true);\n}\n\nstatic void i845_update_wm(struct drm_i915_private *dev_priv)\n{\n\tstruct intel_crtc *crtc;\n\tu32 fwater_lo;\n\tint planea_wm;\n\n\tcrtc = single_enabled_crtc(dev_priv);\n\tif (crtc == NULL)\n\t\treturn;\n\n\tplanea_wm = intel_calculate_wm(crtc->config->pixel_rate,\n\t\t\t\t       &i845_wm_info,\n\t\t\t\t       i845_get_fifo_size(dev_priv, PLANE_A),\n\t\t\t\t       4, pessimal_latency_ns);\n\tfwater_lo = intel_uncore_read(&dev_priv->uncore, FW_BLC) & ~0xfff;\n\tfwater_lo |= (3<<8) | planea_wm;\n\n\tdrm_dbg_kms(&dev_priv->drm,\n\t\t    \"Setting FIFO watermarks - A: %d\\n\", planea_wm);\n\n\tintel_uncore_write(&dev_priv->uncore, FW_BLC, fwater_lo);\n}\n\n \nstatic unsigned int ilk_wm_method1(unsigned int pixel_rate,\n\t\t\t\t   unsigned int cpp,\n\t\t\t\t   unsigned int latency)\n{\n\tunsigned int ret;\n\n\tret = intel_wm_method1(pixel_rate, cpp, latency);\n\tret = DIV_ROUND_UP(ret, 64) + 2;\n\n\treturn ret;\n}\n\n \nstatic unsigned int ilk_wm_method2(unsigned int pixel_rate,\n\t\t\t\t   unsigned int htotal,\n\t\t\t\t   unsigned int width,\n\t\t\t\t   unsigned int cpp,\n\t\t\t\t   unsigned int latency)\n{\n\tunsigned int ret;\n\n\tret = intel_wm_method2(pixel_rate, htotal,\n\t\t\t       width, cpp, latency);\n\tret = DIV_ROUND_UP(ret, 64) + 2;\n\n\treturn ret;\n}\n\nstatic u32 ilk_wm_fbc(u32 pri_val, u32 horiz_pixels, u8 cpp)\n{\n\t \n\tif (WARN_ON(!cpp))\n\t\treturn 0;\n\tif (WARN_ON(!horiz_pixels))\n\t\treturn 0;\n\n\treturn DIV_ROUND_UP(pri_val * 64, horiz_pixels * cpp) + 2;\n}\n\nstruct ilk_wm_maximums {\n\tu16 pri;\n\tu16 spr;\n\tu16 cur;\n\tu16 fbc;\n};\n\n \nstatic u32 ilk_compute_pri_wm(const struct intel_crtc_state *crtc_state,\n\t\t\t      const struct intel_plane_state *plane_state,\n\t\t\t      u32 mem_value, bool is_lp)\n{\n\tu32 method1, method2;\n\tint cpp;\n\n\tif (mem_value == 0)\n\t\treturn U32_MAX;\n\n\tif (!intel_wm_plane_visible(crtc_state, plane_state))\n\t\treturn 0;\n\n\tcpp = plane_state->hw.fb->format->cpp[0];\n\n\tmethod1 = ilk_wm_method1(crtc_state->pixel_rate, cpp, mem_value);\n\n\tif (!is_lp)\n\t\treturn method1;\n\n\tmethod2 = ilk_wm_method2(crtc_state->pixel_rate,\n\t\t\t\t crtc_state->hw.pipe_mode.crtc_htotal,\n\t\t\t\t drm_rect_width(&plane_state->uapi.src) >> 16,\n\t\t\t\t cpp, mem_value);\n\n\treturn min(method1, method2);\n}\n\n \nstatic u32 ilk_compute_spr_wm(const struct intel_crtc_state *crtc_state,\n\t\t\t      const struct intel_plane_state *plane_state,\n\t\t\t      u32 mem_value)\n{\n\tu32 method1, method2;\n\tint cpp;\n\n\tif (mem_value == 0)\n\t\treturn U32_MAX;\n\n\tif (!intel_wm_plane_visible(crtc_state, plane_state))\n\t\treturn 0;\n\n\tcpp = plane_state->hw.fb->format->cpp[0];\n\n\tmethod1 = ilk_wm_method1(crtc_state->pixel_rate, cpp, mem_value);\n\tmethod2 = ilk_wm_method2(crtc_state->pixel_rate,\n\t\t\t\t crtc_state->hw.pipe_mode.crtc_htotal,\n\t\t\t\t drm_rect_width(&plane_state->uapi.src) >> 16,\n\t\t\t\t cpp, mem_value);\n\treturn min(method1, method2);\n}\n\n \nstatic u32 ilk_compute_cur_wm(const struct intel_crtc_state *crtc_state,\n\t\t\t      const struct intel_plane_state *plane_state,\n\t\t\t      u32 mem_value)\n{\n\tint cpp;\n\n\tif (mem_value == 0)\n\t\treturn U32_MAX;\n\n\tif (!intel_wm_plane_visible(crtc_state, plane_state))\n\t\treturn 0;\n\n\tcpp = plane_state->hw.fb->format->cpp[0];\n\n\treturn ilk_wm_method2(crtc_state->pixel_rate,\n\t\t\t      crtc_state->hw.pipe_mode.crtc_htotal,\n\t\t\t      drm_rect_width(&plane_state->uapi.src) >> 16,\n\t\t\t      cpp, mem_value);\n}\n\n \nstatic u32 ilk_compute_fbc_wm(const struct intel_crtc_state *crtc_state,\n\t\t\t      const struct intel_plane_state *plane_state,\n\t\t\t      u32 pri_val)\n{\n\tint cpp;\n\n\tif (!intel_wm_plane_visible(crtc_state, plane_state))\n\t\treturn 0;\n\n\tcpp = plane_state->hw.fb->format->cpp[0];\n\n\treturn ilk_wm_fbc(pri_val, drm_rect_width(&plane_state->uapi.src) >> 16,\n\t\t\t  cpp);\n}\n\nstatic unsigned int\nilk_display_fifo_size(const struct drm_i915_private *dev_priv)\n{\n\tif (DISPLAY_VER(dev_priv) >= 8)\n\t\treturn 3072;\n\telse if (DISPLAY_VER(dev_priv) >= 7)\n\t\treturn 768;\n\telse\n\t\treturn 512;\n}\n\nstatic unsigned int\nilk_plane_wm_reg_max(const struct drm_i915_private *dev_priv,\n\t\t     int level, bool is_sprite)\n{\n\tif (DISPLAY_VER(dev_priv) >= 8)\n\t\t \n\t\treturn level == 0 ? 255 : 2047;\n\telse if (DISPLAY_VER(dev_priv) >= 7)\n\t\t \n\t\treturn level == 0 ? 127 : 1023;\n\telse if (!is_sprite)\n\t\t \n\t\treturn level == 0 ? 127 : 511;\n\telse\n\t\t \n\t\treturn level == 0 ? 63 : 255;\n}\n\nstatic unsigned int\nilk_cursor_wm_reg_max(const struct drm_i915_private *dev_priv, int level)\n{\n\tif (DISPLAY_VER(dev_priv) >= 7)\n\t\treturn level == 0 ? 63 : 255;\n\telse\n\t\treturn level == 0 ? 31 : 63;\n}\n\nstatic unsigned int ilk_fbc_wm_reg_max(const struct drm_i915_private *dev_priv)\n{\n\tif (DISPLAY_VER(dev_priv) >= 8)\n\t\treturn 31;\n\telse\n\t\treturn 15;\n}\n\n \nstatic unsigned int ilk_plane_wm_max(const struct drm_i915_private *dev_priv,\n\t\t\t\t     int level,\n\t\t\t\t     const struct intel_wm_config *config,\n\t\t\t\t     enum intel_ddb_partitioning ddb_partitioning,\n\t\t\t\t     bool is_sprite)\n{\n\tunsigned int fifo_size = ilk_display_fifo_size(dev_priv);\n\n\t \n\tif (is_sprite && !config->sprites_enabled)\n\t\treturn 0;\n\n\t \n\tif (level == 0 || config->num_pipes_active > 1) {\n\t\tfifo_size /= INTEL_NUM_PIPES(dev_priv);\n\n\t\t \n\t\tif (DISPLAY_VER(dev_priv) <= 6)\n\t\t\tfifo_size /= 2;\n\t}\n\n\tif (config->sprites_enabled) {\n\t\t \n\t\tif (level > 0 && ddb_partitioning == INTEL_DDB_PART_5_6) {\n\t\t\tif (is_sprite)\n\t\t\t\tfifo_size *= 5;\n\t\t\tfifo_size /= 6;\n\t\t} else {\n\t\t\tfifo_size /= 2;\n\t\t}\n\t}\n\n\t \n\treturn min(fifo_size, ilk_plane_wm_reg_max(dev_priv, level, is_sprite));\n}\n\n \nstatic unsigned int ilk_cursor_wm_max(const struct drm_i915_private *dev_priv,\n\t\t\t\t      int level,\n\t\t\t\t      const struct intel_wm_config *config)\n{\n\t \n\tif (level > 0 && config->num_pipes_active > 1)\n\t\treturn 64;\n\n\t \n\treturn ilk_cursor_wm_reg_max(dev_priv, level);\n}\n\nstatic void ilk_compute_wm_maximums(const struct drm_i915_private *dev_priv,\n\t\t\t\t    int level,\n\t\t\t\t    const struct intel_wm_config *config,\n\t\t\t\t    enum intel_ddb_partitioning ddb_partitioning,\n\t\t\t\t    struct ilk_wm_maximums *max)\n{\n\tmax->pri = ilk_plane_wm_max(dev_priv, level, config, ddb_partitioning, false);\n\tmax->spr = ilk_plane_wm_max(dev_priv, level, config, ddb_partitioning, true);\n\tmax->cur = ilk_cursor_wm_max(dev_priv, level, config);\n\tmax->fbc = ilk_fbc_wm_reg_max(dev_priv);\n}\n\nstatic void ilk_compute_wm_reg_maximums(const struct drm_i915_private *dev_priv,\n\t\t\t\t\tint level,\n\t\t\t\t\tstruct ilk_wm_maximums *max)\n{\n\tmax->pri = ilk_plane_wm_reg_max(dev_priv, level, false);\n\tmax->spr = ilk_plane_wm_reg_max(dev_priv, level, true);\n\tmax->cur = ilk_cursor_wm_reg_max(dev_priv, level);\n\tmax->fbc = ilk_fbc_wm_reg_max(dev_priv);\n}\n\nstatic bool ilk_validate_wm_level(int level,\n\t\t\t\t  const struct ilk_wm_maximums *max,\n\t\t\t\t  struct intel_wm_level *result)\n{\n\tbool ret;\n\n\t \n\tif (!result->enable)\n\t\treturn false;\n\n\tresult->enable = result->pri_val <= max->pri &&\n\t\t\t result->spr_val <= max->spr &&\n\t\t\t result->cur_val <= max->cur;\n\n\tret = result->enable;\n\n\t \n\tif (level == 0 && !result->enable) {\n\t\tif (result->pri_val > max->pri)\n\t\t\tDRM_DEBUG_KMS(\"Primary WM%d too large %u (max %u)\\n\",\n\t\t\t\t      level, result->pri_val, max->pri);\n\t\tif (result->spr_val > max->spr)\n\t\t\tDRM_DEBUG_KMS(\"Sprite WM%d too large %u (max %u)\\n\",\n\t\t\t\t      level, result->spr_val, max->spr);\n\t\tif (result->cur_val > max->cur)\n\t\t\tDRM_DEBUG_KMS(\"Cursor WM%d too large %u (max %u)\\n\",\n\t\t\t\t      level, result->cur_val, max->cur);\n\n\t\tresult->pri_val = min_t(u32, result->pri_val, max->pri);\n\t\tresult->spr_val = min_t(u32, result->spr_val, max->spr);\n\t\tresult->cur_val = min_t(u32, result->cur_val, max->cur);\n\t\tresult->enable = true;\n\t}\n\n\treturn ret;\n}\n\nstatic void ilk_compute_wm_level(const struct drm_i915_private *dev_priv,\n\t\t\t\t const struct intel_crtc *crtc,\n\t\t\t\t int level,\n\t\t\t\t struct intel_crtc_state *crtc_state,\n\t\t\t\t const struct intel_plane_state *pristate,\n\t\t\t\t const struct intel_plane_state *sprstate,\n\t\t\t\t const struct intel_plane_state *curstate,\n\t\t\t\t struct intel_wm_level *result)\n{\n\tu16 pri_latency = dev_priv->display.wm.pri_latency[level];\n\tu16 spr_latency = dev_priv->display.wm.spr_latency[level];\n\tu16 cur_latency = dev_priv->display.wm.cur_latency[level];\n\n\t \n\tif (level > 0) {\n\t\tpri_latency *= 5;\n\t\tspr_latency *= 5;\n\t\tcur_latency *= 5;\n\t}\n\n\tif (pristate) {\n\t\tresult->pri_val = ilk_compute_pri_wm(crtc_state, pristate,\n\t\t\t\t\t\t     pri_latency, level);\n\t\tresult->fbc_val = ilk_compute_fbc_wm(crtc_state, pristate, result->pri_val);\n\t}\n\n\tif (sprstate)\n\t\tresult->spr_val = ilk_compute_spr_wm(crtc_state, sprstate, spr_latency);\n\n\tif (curstate)\n\t\tresult->cur_val = ilk_compute_cur_wm(crtc_state, curstate, cur_latency);\n\n\tresult->enable = true;\n}\n\nstatic void hsw_read_wm_latency(struct drm_i915_private *i915, u16 wm[])\n{\n\tu64 sskpd;\n\n\ti915->display.wm.num_levels = 5;\n\n\tsskpd = intel_uncore_read64(&i915->uncore, MCH_SSKPD);\n\n\twm[0] = REG_FIELD_GET64(SSKPD_NEW_WM0_MASK_HSW, sskpd);\n\tif (wm[0] == 0)\n\t\twm[0] = REG_FIELD_GET64(SSKPD_OLD_WM0_MASK_HSW, sskpd);\n\twm[1] = REG_FIELD_GET64(SSKPD_WM1_MASK_HSW, sskpd);\n\twm[2] = REG_FIELD_GET64(SSKPD_WM2_MASK_HSW, sskpd);\n\twm[3] = REG_FIELD_GET64(SSKPD_WM3_MASK_HSW, sskpd);\n\twm[4] = REG_FIELD_GET64(SSKPD_WM4_MASK_HSW, sskpd);\n}\n\nstatic void snb_read_wm_latency(struct drm_i915_private *i915, u16 wm[])\n{\n\tu32 sskpd;\n\n\ti915->display.wm.num_levels = 4;\n\n\tsskpd = intel_uncore_read(&i915->uncore, MCH_SSKPD);\n\n\twm[0] = REG_FIELD_GET(SSKPD_WM0_MASK_SNB, sskpd);\n\twm[1] = REG_FIELD_GET(SSKPD_WM1_MASK_SNB, sskpd);\n\twm[2] = REG_FIELD_GET(SSKPD_WM2_MASK_SNB, sskpd);\n\twm[3] = REG_FIELD_GET(SSKPD_WM3_MASK_SNB, sskpd);\n}\n\nstatic void ilk_read_wm_latency(struct drm_i915_private *i915, u16 wm[])\n{\n\tu32 mltr;\n\n\ti915->display.wm.num_levels = 3;\n\n\tmltr = intel_uncore_read(&i915->uncore, MLTR_ILK);\n\n\t \n\twm[0] = 7;\n\twm[1] = REG_FIELD_GET(MLTR_WM1_MASK, mltr);\n\twm[2] = REG_FIELD_GET(MLTR_WM2_MASK, mltr);\n}\n\nstatic void intel_fixup_spr_wm_latency(struct drm_i915_private *dev_priv,\n\t\t\t\t       u16 wm[5])\n{\n\t \n\tif (DISPLAY_VER(dev_priv) == 5)\n\t\twm[0] = 13;\n}\n\nstatic void intel_fixup_cur_wm_latency(struct drm_i915_private *dev_priv,\n\t\t\t\t       u16 wm[5])\n{\n\t \n\tif (DISPLAY_VER(dev_priv) == 5)\n\t\twm[0] = 13;\n}\n\nstatic bool ilk_increase_wm_latency(struct drm_i915_private *dev_priv,\n\t\t\t\t    u16 wm[5], u16 min)\n{\n\tint level;\n\n\tif (wm[0] >= min)\n\t\treturn false;\n\n\twm[0] = max(wm[0], min);\n\tfor (level = 1; level < dev_priv->display.wm.num_levels; level++)\n\t\twm[level] = max_t(u16, wm[level], DIV_ROUND_UP(min, 5));\n\n\treturn true;\n}\n\nstatic void snb_wm_latency_quirk(struct drm_i915_private *dev_priv)\n{\n\tbool changed;\n\n\t \n\tchanged = ilk_increase_wm_latency(dev_priv, dev_priv->display.wm.pri_latency, 12);\n\tchanged |= ilk_increase_wm_latency(dev_priv, dev_priv->display.wm.spr_latency, 12);\n\tchanged |= ilk_increase_wm_latency(dev_priv, dev_priv->display.wm.cur_latency, 12);\n\n\tif (!changed)\n\t\treturn;\n\n\tdrm_dbg_kms(&dev_priv->drm,\n\t\t    \"WM latency values increased to avoid potential underruns\\n\");\n\tintel_print_wm_latency(dev_priv, \"Primary\", dev_priv->display.wm.pri_latency);\n\tintel_print_wm_latency(dev_priv, \"Sprite\", dev_priv->display.wm.spr_latency);\n\tintel_print_wm_latency(dev_priv, \"Cursor\", dev_priv->display.wm.cur_latency);\n}\n\nstatic void snb_wm_lp3_irq_quirk(struct drm_i915_private *dev_priv)\n{\n\t \n\tif (dev_priv->display.wm.pri_latency[3] == 0 &&\n\t    dev_priv->display.wm.spr_latency[3] == 0 &&\n\t    dev_priv->display.wm.cur_latency[3] == 0)\n\t\treturn;\n\n\tdev_priv->display.wm.pri_latency[3] = 0;\n\tdev_priv->display.wm.spr_latency[3] = 0;\n\tdev_priv->display.wm.cur_latency[3] = 0;\n\n\tdrm_dbg_kms(&dev_priv->drm,\n\t\t    \"LP3 watermarks disabled due to potential for lost interrupts\\n\");\n\tintel_print_wm_latency(dev_priv, \"Primary\", dev_priv->display.wm.pri_latency);\n\tintel_print_wm_latency(dev_priv, \"Sprite\", dev_priv->display.wm.spr_latency);\n\tintel_print_wm_latency(dev_priv, \"Cursor\", dev_priv->display.wm.cur_latency);\n}\n\nstatic void ilk_setup_wm_latency(struct drm_i915_private *dev_priv)\n{\n\tif (IS_BROADWELL(dev_priv) || IS_HASWELL(dev_priv))\n\t\thsw_read_wm_latency(dev_priv, dev_priv->display.wm.pri_latency);\n\telse if (DISPLAY_VER(dev_priv) >= 6)\n\t\tsnb_read_wm_latency(dev_priv, dev_priv->display.wm.pri_latency);\n\telse\n\t\tilk_read_wm_latency(dev_priv, dev_priv->display.wm.pri_latency);\n\n\tmemcpy(dev_priv->display.wm.spr_latency, dev_priv->display.wm.pri_latency,\n\t       sizeof(dev_priv->display.wm.pri_latency));\n\tmemcpy(dev_priv->display.wm.cur_latency, dev_priv->display.wm.pri_latency,\n\t       sizeof(dev_priv->display.wm.pri_latency));\n\n\tintel_fixup_spr_wm_latency(dev_priv, dev_priv->display.wm.spr_latency);\n\tintel_fixup_cur_wm_latency(dev_priv, dev_priv->display.wm.cur_latency);\n\n\tintel_print_wm_latency(dev_priv, \"Primary\", dev_priv->display.wm.pri_latency);\n\tintel_print_wm_latency(dev_priv, \"Sprite\", dev_priv->display.wm.spr_latency);\n\tintel_print_wm_latency(dev_priv, \"Cursor\", dev_priv->display.wm.cur_latency);\n\n\tif (DISPLAY_VER(dev_priv) == 6) {\n\t\tsnb_wm_latency_quirk(dev_priv);\n\t\tsnb_wm_lp3_irq_quirk(dev_priv);\n\t}\n}\n\nstatic bool ilk_validate_pipe_wm(const struct drm_i915_private *dev_priv,\n\t\t\t\t struct intel_pipe_wm *pipe_wm)\n{\n\t \n\tconst struct intel_wm_config config = {\n\t\t.num_pipes_active = 1,\n\t\t.sprites_enabled = pipe_wm->sprites_enabled,\n\t\t.sprites_scaled = pipe_wm->sprites_scaled,\n\t};\n\tstruct ilk_wm_maximums max;\n\n\t \n\tilk_compute_wm_maximums(dev_priv, 0, &config, INTEL_DDB_PART_1_2, &max);\n\n\t \n\tif (!ilk_validate_wm_level(0, &max, &pipe_wm->wm[0])) {\n\t\tdrm_dbg_kms(&dev_priv->drm, \"LP0 watermark invalid\\n\");\n\t\treturn false;\n\t}\n\n\treturn true;\n}\n\n \nstatic int ilk_compute_pipe_wm(struct intel_atomic_state *state,\n\t\t\t       struct intel_crtc *crtc)\n{\n\tstruct drm_i915_private *dev_priv = to_i915(state->base.dev);\n\tstruct intel_crtc_state *crtc_state =\n\t\tintel_atomic_get_new_crtc_state(state, crtc);\n\tstruct intel_pipe_wm *pipe_wm;\n\tstruct intel_plane *plane;\n\tconst struct intel_plane_state *plane_state;\n\tconst struct intel_plane_state *pristate = NULL;\n\tconst struct intel_plane_state *sprstate = NULL;\n\tconst struct intel_plane_state *curstate = NULL;\n\tstruct ilk_wm_maximums max;\n\tint level, usable_level;\n\n\tpipe_wm = &crtc_state->wm.ilk.optimal;\n\n\tintel_atomic_crtc_state_for_each_plane_state(plane, plane_state, crtc_state) {\n\t\tif (plane->base.type == DRM_PLANE_TYPE_PRIMARY)\n\t\t\tpristate = plane_state;\n\t\telse if (plane->base.type == DRM_PLANE_TYPE_OVERLAY)\n\t\t\tsprstate = plane_state;\n\t\telse if (plane->base.type == DRM_PLANE_TYPE_CURSOR)\n\t\t\tcurstate = plane_state;\n\t}\n\n\tpipe_wm->pipe_enabled = crtc_state->hw.active;\n\tpipe_wm->sprites_enabled = crtc_state->active_planes & BIT(PLANE_SPRITE0);\n\tpipe_wm->sprites_scaled = crtc_state->scaled_planes & BIT(PLANE_SPRITE0);\n\n\tusable_level = dev_priv->display.wm.num_levels - 1;\n\n\t \n\tif (DISPLAY_VER(dev_priv) <= 6 && pipe_wm->sprites_enabled)\n\t\tusable_level = 1;\n\n\t \n\tif (pipe_wm->sprites_scaled)\n\t\tusable_level = 0;\n\n\tmemset(&pipe_wm->wm, 0, sizeof(pipe_wm->wm));\n\tilk_compute_wm_level(dev_priv, crtc, 0, crtc_state,\n\t\t\t     pristate, sprstate, curstate, &pipe_wm->wm[0]);\n\n\tif (!ilk_validate_pipe_wm(dev_priv, pipe_wm))\n\t\treturn -EINVAL;\n\n\tilk_compute_wm_reg_maximums(dev_priv, 1, &max);\n\n\tfor (level = 1; level <= usable_level; level++) {\n\t\tstruct intel_wm_level *wm = &pipe_wm->wm[level];\n\n\t\tilk_compute_wm_level(dev_priv, crtc, level, crtc_state,\n\t\t\t\t     pristate, sprstate, curstate, wm);\n\n\t\t \n\t\tif (!ilk_validate_wm_level(level, &max, wm)) {\n\t\t\tmemset(wm, 0, sizeof(*wm));\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n \nstatic int ilk_compute_intermediate_wm(struct intel_atomic_state *state,\n\t\t\t\t       struct intel_crtc *crtc)\n{\n\tstruct drm_i915_private *dev_priv = to_i915(crtc->base.dev);\n\tstruct intel_crtc_state *new_crtc_state =\n\t\tintel_atomic_get_new_crtc_state(state, crtc);\n\tconst struct intel_crtc_state *old_crtc_state =\n\t\tintel_atomic_get_old_crtc_state(state, crtc);\n\tstruct intel_pipe_wm *a = &new_crtc_state->wm.ilk.intermediate;\n\tconst struct intel_pipe_wm *b = &old_crtc_state->wm.ilk.optimal;\n\tint level;\n\n\t \n\t*a = new_crtc_state->wm.ilk.optimal;\n\tif (!new_crtc_state->hw.active ||\n\t    intel_crtc_needs_modeset(new_crtc_state) ||\n\t    state->skip_intermediate_wm)\n\t\treturn 0;\n\n\ta->pipe_enabled |= b->pipe_enabled;\n\ta->sprites_enabled |= b->sprites_enabled;\n\ta->sprites_scaled |= b->sprites_scaled;\n\n\tfor (level = 0; level < dev_priv->display.wm.num_levels; level++) {\n\t\tstruct intel_wm_level *a_wm = &a->wm[level];\n\t\tconst struct intel_wm_level *b_wm = &b->wm[level];\n\n\t\ta_wm->enable &= b_wm->enable;\n\t\ta_wm->pri_val = max(a_wm->pri_val, b_wm->pri_val);\n\t\ta_wm->spr_val = max(a_wm->spr_val, b_wm->spr_val);\n\t\ta_wm->cur_val = max(a_wm->cur_val, b_wm->cur_val);\n\t\ta_wm->fbc_val = max(a_wm->fbc_val, b_wm->fbc_val);\n\t}\n\n\t \n\tif (!ilk_validate_pipe_wm(dev_priv, a))\n\t\treturn -EINVAL;\n\n\t \n\tif (memcmp(a, &new_crtc_state->wm.ilk.optimal, sizeof(*a)) != 0)\n\t\tnew_crtc_state->wm.need_postvbl_update = true;\n\n\treturn 0;\n}\n\n \nstatic void ilk_merge_wm_level(struct drm_i915_private *dev_priv,\n\t\t\t       int level,\n\t\t\t       struct intel_wm_level *ret_wm)\n{\n\tconst struct intel_crtc *crtc;\n\n\tret_wm->enable = true;\n\n\tfor_each_intel_crtc(&dev_priv->drm, crtc) {\n\t\tconst struct intel_pipe_wm *active = &crtc->wm.active.ilk;\n\t\tconst struct intel_wm_level *wm = &active->wm[level];\n\n\t\tif (!active->pipe_enabled)\n\t\t\tcontinue;\n\n\t\t \n\t\tif (!wm->enable)\n\t\t\tret_wm->enable = false;\n\n\t\tret_wm->pri_val = max(ret_wm->pri_val, wm->pri_val);\n\t\tret_wm->spr_val = max(ret_wm->spr_val, wm->spr_val);\n\t\tret_wm->cur_val = max(ret_wm->cur_val, wm->cur_val);\n\t\tret_wm->fbc_val = max(ret_wm->fbc_val, wm->fbc_val);\n\t}\n}\n\n \nstatic void ilk_wm_merge(struct drm_i915_private *dev_priv,\n\t\t\t const struct intel_wm_config *config,\n\t\t\t const struct ilk_wm_maximums *max,\n\t\t\t struct intel_pipe_wm *merged)\n{\n\tint level, num_levels = dev_priv->display.wm.num_levels;\n\tint last_enabled_level = num_levels - 1;\n\n\t \n\tif ((DISPLAY_VER(dev_priv) <= 6 || IS_IVYBRIDGE(dev_priv)) &&\n\t    config->num_pipes_active > 1)\n\t\tlast_enabled_level = 0;\n\n\t \n\tmerged->fbc_wm_enabled = DISPLAY_VER(dev_priv) >= 6;\n\n\t \n\tfor (level = 1; level < num_levels; level++) {\n\t\tstruct intel_wm_level *wm = &merged->wm[level];\n\n\t\tilk_merge_wm_level(dev_priv, level, wm);\n\n\t\tif (level > last_enabled_level)\n\t\t\twm->enable = false;\n\t\telse if (!ilk_validate_wm_level(level, max, wm))\n\t\t\t \n\t\t\tlast_enabled_level = level - 1;\n\n\t\t \n\t\tif (wm->fbc_val > max->fbc) {\n\t\t\tif (wm->enable)\n\t\t\t\tmerged->fbc_wm_enabled = false;\n\t\t\twm->fbc_val = 0;\n\t\t}\n\t}\n\n\t \n\tif (DISPLAY_VER(dev_priv) == 5 && HAS_FBC(dev_priv) &&\n\t    dev_priv->params.enable_fbc && !merged->fbc_wm_enabled) {\n\t\tfor (level = 2; level < num_levels; level++) {\n\t\t\tstruct intel_wm_level *wm = &merged->wm[level];\n\n\t\t\twm->enable = false;\n\t\t}\n\t}\n}\n\nstatic int ilk_wm_lp_to_level(int wm_lp, const struct intel_pipe_wm *pipe_wm)\n{\n\t \n\treturn wm_lp + (wm_lp >= 2 && pipe_wm->wm[4].enable);\n}\n\n \nstatic unsigned int ilk_wm_lp_latency(struct drm_i915_private *dev_priv,\n\t\t\t\t      int level)\n{\n\tif (IS_HASWELL(dev_priv) || IS_BROADWELL(dev_priv))\n\t\treturn 2 * level;\n\telse\n\t\treturn dev_priv->display.wm.pri_latency[level];\n}\n\nstatic void ilk_compute_wm_results(struct drm_i915_private *dev_priv,\n\t\t\t\t   const struct intel_pipe_wm *merged,\n\t\t\t\t   enum intel_ddb_partitioning partitioning,\n\t\t\t\t   struct ilk_wm_values *results)\n{\n\tstruct intel_crtc *crtc;\n\tint level, wm_lp;\n\n\tresults->enable_fbc_wm = merged->fbc_wm_enabled;\n\tresults->partitioning = partitioning;\n\n\t \n\tfor (wm_lp = 1; wm_lp <= 3; wm_lp++) {\n\t\tconst struct intel_wm_level *r;\n\n\t\tlevel = ilk_wm_lp_to_level(wm_lp, merged);\n\n\t\tr = &merged->wm[level];\n\n\t\t \n\t\tresults->wm_lp[wm_lp - 1] =\n\t\t\tWM_LP_LATENCY(ilk_wm_lp_latency(dev_priv, level)) |\n\t\t\tWM_LP_PRIMARY(r->pri_val) |\n\t\t\tWM_LP_CURSOR(r->cur_val);\n\n\t\tif (r->enable)\n\t\t\tresults->wm_lp[wm_lp - 1] |= WM_LP_ENABLE;\n\n\t\tif (DISPLAY_VER(dev_priv) >= 8)\n\t\t\tresults->wm_lp[wm_lp - 1] |= WM_LP_FBC_BDW(r->fbc_val);\n\t\telse\n\t\t\tresults->wm_lp[wm_lp - 1] |= WM_LP_FBC_ILK(r->fbc_val);\n\n\t\tresults->wm_lp_spr[wm_lp - 1] = WM_LP_SPRITE(r->spr_val);\n\n\t\t \n\t\tif (DISPLAY_VER(dev_priv) <= 6 && r->spr_val) {\n\t\t\tdrm_WARN_ON(&dev_priv->drm, wm_lp != 1);\n\t\t\tresults->wm_lp_spr[wm_lp - 1] |= WM_LP_SPRITE_ENABLE;\n\t\t}\n\t}\n\n\t \n\tfor_each_intel_crtc(&dev_priv->drm, crtc) {\n\t\tenum pipe pipe = crtc->pipe;\n\t\tconst struct intel_pipe_wm *pipe_wm = &crtc->wm.active.ilk;\n\t\tconst struct intel_wm_level *r = &pipe_wm->wm[0];\n\n\t\tif (drm_WARN_ON(&dev_priv->drm, !r->enable))\n\t\t\tcontinue;\n\n\t\tresults->wm_pipe[pipe] =\n\t\t\tWM0_PIPE_PRIMARY(r->pri_val) |\n\t\t\tWM0_PIPE_SPRITE(r->spr_val) |\n\t\t\tWM0_PIPE_CURSOR(r->cur_val);\n\t}\n}\n\n \nstatic struct intel_pipe_wm *\nilk_find_best_result(struct drm_i915_private *dev_priv,\n\t\t     struct intel_pipe_wm *r1,\n\t\t     struct intel_pipe_wm *r2)\n{\n\tint level, level1 = 0, level2 = 0;\n\n\tfor (level = 1; level < dev_priv->display.wm.num_levels; level++) {\n\t\tif (r1->wm[level].enable)\n\t\t\tlevel1 = level;\n\t\tif (r2->wm[level].enable)\n\t\t\tlevel2 = level;\n\t}\n\n\tif (level1 == level2) {\n\t\tif (r2->fbc_wm_enabled && !r1->fbc_wm_enabled)\n\t\t\treturn r2;\n\t\telse\n\t\t\treturn r1;\n\t} else if (level1 > level2) {\n\t\treturn r1;\n\t} else {\n\t\treturn r2;\n\t}\n}\n\n \n#define WM_DIRTY_PIPE(pipe) (1 << (pipe))\n#define WM_DIRTY_LP(wm_lp) (1 << (15 + (wm_lp)))\n#define WM_DIRTY_LP_ALL (WM_DIRTY_LP(1) | WM_DIRTY_LP(2) | WM_DIRTY_LP(3))\n#define WM_DIRTY_FBC (1 << 24)\n#define WM_DIRTY_DDB (1 << 25)\n\nstatic unsigned int ilk_compute_wm_dirty(struct drm_i915_private *dev_priv,\n\t\t\t\t\t const struct ilk_wm_values *old,\n\t\t\t\t\t const struct ilk_wm_values *new)\n{\n\tunsigned int dirty = 0;\n\tenum pipe pipe;\n\tint wm_lp;\n\n\tfor_each_pipe(dev_priv, pipe) {\n\t\tif (old->wm_pipe[pipe] != new->wm_pipe[pipe]) {\n\t\t\tdirty |= WM_DIRTY_PIPE(pipe);\n\t\t\t \n\t\t\tdirty |= WM_DIRTY_LP_ALL;\n\t\t}\n\t}\n\n\tif (old->enable_fbc_wm != new->enable_fbc_wm) {\n\t\tdirty |= WM_DIRTY_FBC;\n\t\t \n\t\tdirty |= WM_DIRTY_LP_ALL;\n\t}\n\n\tif (old->partitioning != new->partitioning) {\n\t\tdirty |= WM_DIRTY_DDB;\n\t\t \n\t\tdirty |= WM_DIRTY_LP_ALL;\n\t}\n\n\t \n\tif (dirty & WM_DIRTY_LP_ALL)\n\t\treturn dirty;\n\n\t \n\tfor (wm_lp = 1; wm_lp <= 3; wm_lp++) {\n\t\tif (old->wm_lp[wm_lp - 1] != new->wm_lp[wm_lp - 1] ||\n\t\t    old->wm_lp_spr[wm_lp - 1] != new->wm_lp_spr[wm_lp - 1])\n\t\t\tbreak;\n\t}\n\n\t \n\tfor (; wm_lp <= 3; wm_lp++)\n\t\tdirty |= WM_DIRTY_LP(wm_lp);\n\n\treturn dirty;\n}\n\nstatic bool _ilk_disable_lp_wm(struct drm_i915_private *dev_priv,\n\t\t\t       unsigned int dirty)\n{\n\tstruct ilk_wm_values *previous = &dev_priv->display.wm.hw;\n\tbool changed = false;\n\n\tif (dirty & WM_DIRTY_LP(3) && previous->wm_lp[2] & WM_LP_ENABLE) {\n\t\tprevious->wm_lp[2] &= ~WM_LP_ENABLE;\n\t\tintel_uncore_write(&dev_priv->uncore, WM3_LP_ILK, previous->wm_lp[2]);\n\t\tchanged = true;\n\t}\n\tif (dirty & WM_DIRTY_LP(2) && previous->wm_lp[1] & WM_LP_ENABLE) {\n\t\tprevious->wm_lp[1] &= ~WM_LP_ENABLE;\n\t\tintel_uncore_write(&dev_priv->uncore, WM2_LP_ILK, previous->wm_lp[1]);\n\t\tchanged = true;\n\t}\n\tif (dirty & WM_DIRTY_LP(1) && previous->wm_lp[0] & WM_LP_ENABLE) {\n\t\tprevious->wm_lp[0] &= ~WM_LP_ENABLE;\n\t\tintel_uncore_write(&dev_priv->uncore, WM1_LP_ILK, previous->wm_lp[0]);\n\t\tchanged = true;\n\t}\n\n\t \n\n\treturn changed;\n}\n\n \nstatic void ilk_write_wm_values(struct drm_i915_private *dev_priv,\n\t\t\t\tstruct ilk_wm_values *results)\n{\n\tstruct ilk_wm_values *previous = &dev_priv->display.wm.hw;\n\tunsigned int dirty;\n\n\tdirty = ilk_compute_wm_dirty(dev_priv, previous, results);\n\tif (!dirty)\n\t\treturn;\n\n\t_ilk_disable_lp_wm(dev_priv, dirty);\n\n\tif (dirty & WM_DIRTY_PIPE(PIPE_A))\n\t\tintel_uncore_write(&dev_priv->uncore, WM0_PIPE_ILK(PIPE_A), results->wm_pipe[0]);\n\tif (dirty & WM_DIRTY_PIPE(PIPE_B))\n\t\tintel_uncore_write(&dev_priv->uncore, WM0_PIPE_ILK(PIPE_B), results->wm_pipe[1]);\n\tif (dirty & WM_DIRTY_PIPE(PIPE_C))\n\t\tintel_uncore_write(&dev_priv->uncore, WM0_PIPE_ILK(PIPE_C), results->wm_pipe[2]);\n\n\tif (dirty & WM_DIRTY_DDB) {\n\t\tif (IS_HASWELL(dev_priv) || IS_BROADWELL(dev_priv))\n\t\t\tintel_uncore_rmw(&dev_priv->uncore, WM_MISC, WM_MISC_DATA_PARTITION_5_6,\n\t\t\t\t\t results->partitioning == INTEL_DDB_PART_1_2 ? 0 :\n\t\t\t\t\t WM_MISC_DATA_PARTITION_5_6);\n\t\telse\n\t\t\tintel_uncore_rmw(&dev_priv->uncore, DISP_ARB_CTL2, DISP_DATA_PARTITION_5_6,\n\t\t\t\t\t results->partitioning == INTEL_DDB_PART_1_2 ? 0 :\n\t\t\t\t\t DISP_DATA_PARTITION_5_6);\n\t}\n\n\tif (dirty & WM_DIRTY_FBC)\n\t\tintel_uncore_rmw(&dev_priv->uncore, DISP_ARB_CTL, DISP_FBC_WM_DIS,\n\t\t\t\t results->enable_fbc_wm ? 0 : DISP_FBC_WM_DIS);\n\n\tif (dirty & WM_DIRTY_LP(1) &&\n\t    previous->wm_lp_spr[0] != results->wm_lp_spr[0])\n\t\tintel_uncore_write(&dev_priv->uncore, WM1S_LP_ILK, results->wm_lp_spr[0]);\n\n\tif (DISPLAY_VER(dev_priv) >= 7) {\n\t\tif (dirty & WM_DIRTY_LP(2) && previous->wm_lp_spr[1] != results->wm_lp_spr[1])\n\t\t\tintel_uncore_write(&dev_priv->uncore, WM2S_LP_IVB, results->wm_lp_spr[1]);\n\t\tif (dirty & WM_DIRTY_LP(3) && previous->wm_lp_spr[2] != results->wm_lp_spr[2])\n\t\t\tintel_uncore_write(&dev_priv->uncore, WM3S_LP_IVB, results->wm_lp_spr[2]);\n\t}\n\n\tif (dirty & WM_DIRTY_LP(1) && previous->wm_lp[0] != results->wm_lp[0])\n\t\tintel_uncore_write(&dev_priv->uncore, WM1_LP_ILK, results->wm_lp[0]);\n\tif (dirty & WM_DIRTY_LP(2) && previous->wm_lp[1] != results->wm_lp[1])\n\t\tintel_uncore_write(&dev_priv->uncore, WM2_LP_ILK, results->wm_lp[1]);\n\tif (dirty & WM_DIRTY_LP(3) && previous->wm_lp[2] != results->wm_lp[2])\n\t\tintel_uncore_write(&dev_priv->uncore, WM3_LP_ILK, results->wm_lp[2]);\n\n\tdev_priv->display.wm.hw = *results;\n}\n\nbool ilk_disable_lp_wm(struct drm_i915_private *dev_priv)\n{\n\treturn _ilk_disable_lp_wm(dev_priv, WM_DIRTY_LP_ALL);\n}\n\nstatic void ilk_compute_wm_config(struct drm_i915_private *dev_priv,\n\t\t\t\t  struct intel_wm_config *config)\n{\n\tstruct intel_crtc *crtc;\n\n\t \n\tfor_each_intel_crtc(&dev_priv->drm, crtc) {\n\t\tconst struct intel_pipe_wm *wm = &crtc->wm.active.ilk;\n\n\t\tif (!wm->pipe_enabled)\n\t\t\tcontinue;\n\n\t\tconfig->sprites_enabled |= wm->sprites_enabled;\n\t\tconfig->sprites_scaled |= wm->sprites_scaled;\n\t\tconfig->num_pipes_active++;\n\t}\n}\n\nstatic void ilk_program_watermarks(struct drm_i915_private *dev_priv)\n{\n\tstruct intel_pipe_wm lp_wm_1_2 = {}, lp_wm_5_6 = {}, *best_lp_wm;\n\tstruct ilk_wm_maximums max;\n\tstruct intel_wm_config config = {};\n\tstruct ilk_wm_values results = {};\n\tenum intel_ddb_partitioning partitioning;\n\n\tilk_compute_wm_config(dev_priv, &config);\n\n\tilk_compute_wm_maximums(dev_priv, 1, &config, INTEL_DDB_PART_1_2, &max);\n\tilk_wm_merge(dev_priv, &config, &max, &lp_wm_1_2);\n\n\t \n\tif (DISPLAY_VER(dev_priv) >= 7 &&\n\t    config.num_pipes_active == 1 && config.sprites_enabled) {\n\t\tilk_compute_wm_maximums(dev_priv, 1, &config, INTEL_DDB_PART_5_6, &max);\n\t\tilk_wm_merge(dev_priv, &config, &max, &lp_wm_5_6);\n\n\t\tbest_lp_wm = ilk_find_best_result(dev_priv, &lp_wm_1_2, &lp_wm_5_6);\n\t} else {\n\t\tbest_lp_wm = &lp_wm_1_2;\n\t}\n\n\tpartitioning = (best_lp_wm == &lp_wm_1_2) ?\n\t\t       INTEL_DDB_PART_1_2 : INTEL_DDB_PART_5_6;\n\n\tilk_compute_wm_results(dev_priv, best_lp_wm, partitioning, &results);\n\n\tilk_write_wm_values(dev_priv, &results);\n}\n\nstatic void ilk_initial_watermarks(struct intel_atomic_state *state,\n\t\t\t\t   struct intel_crtc *crtc)\n{\n\tstruct drm_i915_private *dev_priv = to_i915(crtc->base.dev);\n\tconst struct intel_crtc_state *crtc_state =\n\t\tintel_atomic_get_new_crtc_state(state, crtc);\n\n\tmutex_lock(&dev_priv->display.wm.wm_mutex);\n\tcrtc->wm.active.ilk = crtc_state->wm.ilk.intermediate;\n\tilk_program_watermarks(dev_priv);\n\tmutex_unlock(&dev_priv->display.wm.wm_mutex);\n}\n\nstatic void ilk_optimize_watermarks(struct intel_atomic_state *state,\n\t\t\t\t    struct intel_crtc *crtc)\n{\n\tstruct drm_i915_private *dev_priv = to_i915(crtc->base.dev);\n\tconst struct intel_crtc_state *crtc_state =\n\t\tintel_atomic_get_new_crtc_state(state, crtc);\n\n\tif (!crtc_state->wm.need_postvbl_update)\n\t\treturn;\n\n\tmutex_lock(&dev_priv->display.wm.wm_mutex);\n\tcrtc->wm.active.ilk = crtc_state->wm.ilk.optimal;\n\tilk_program_watermarks(dev_priv);\n\tmutex_unlock(&dev_priv->display.wm.wm_mutex);\n}\n\nstatic void ilk_pipe_wm_get_hw_state(struct intel_crtc *crtc)\n{\n\tstruct drm_device *dev = crtc->base.dev;\n\tstruct drm_i915_private *dev_priv = to_i915(dev);\n\tstruct ilk_wm_values *hw = &dev_priv->display.wm.hw;\n\tstruct intel_crtc_state *crtc_state = to_intel_crtc_state(crtc->base.state);\n\tstruct intel_pipe_wm *active = &crtc_state->wm.ilk.optimal;\n\tenum pipe pipe = crtc->pipe;\n\n\thw->wm_pipe[pipe] = intel_uncore_read(&dev_priv->uncore, WM0_PIPE_ILK(pipe));\n\n\tmemset(active, 0, sizeof(*active));\n\n\tactive->pipe_enabled = crtc->active;\n\n\tif (active->pipe_enabled) {\n\t\tu32 tmp = hw->wm_pipe[pipe];\n\n\t\t \n\t\tactive->wm[0].enable = true;\n\t\tactive->wm[0].pri_val = REG_FIELD_GET(WM0_PIPE_PRIMARY_MASK, tmp);\n\t\tactive->wm[0].spr_val = REG_FIELD_GET(WM0_PIPE_SPRITE_MASK, tmp);\n\t\tactive->wm[0].cur_val = REG_FIELD_GET(WM0_PIPE_CURSOR_MASK, tmp);\n\t} else {\n\t\tint level;\n\n\t\t \n\t\tfor (level = 0; level < dev_priv->display.wm.num_levels; level++)\n\t\t\tactive->wm[level].enable = true;\n\t}\n\n\tcrtc->wm.active.ilk = *active;\n}\n\nstatic int ilk_sanitize_watermarks_add_affected(struct drm_atomic_state *state)\n{\n\tstruct drm_plane *plane;\n\tstruct intel_crtc *crtc;\n\n\tfor_each_intel_crtc(state->dev, crtc) {\n\t\tstruct intel_crtc_state *crtc_state;\n\n\t\tcrtc_state = intel_atomic_get_crtc_state(state, crtc);\n\t\tif (IS_ERR(crtc_state))\n\t\t\treturn PTR_ERR(crtc_state);\n\n\t\tif (crtc_state->hw.active) {\n\t\t\t \n\t\t\tcrtc_state->inherited = true;\n\t\t}\n\t}\n\n\tdrm_for_each_plane(plane, state->dev) {\n\t\tstruct drm_plane_state *plane_state;\n\n\t\tplane_state = drm_atomic_get_plane_state(state, plane);\n\t\tif (IS_ERR(plane_state))\n\t\t\treturn PTR_ERR(plane_state);\n\t}\n\n\treturn 0;\n}\n\n \nvoid ilk_wm_sanitize(struct drm_i915_private *dev_priv)\n{\n\tstruct drm_atomic_state *state;\n\tstruct intel_atomic_state *intel_state;\n\tstruct intel_crtc *crtc;\n\tstruct intel_crtc_state *crtc_state;\n\tstruct drm_modeset_acquire_ctx ctx;\n\tint ret;\n\tint i;\n\n\t \n\tif (!dev_priv->display.funcs.wm->optimize_watermarks)\n\t\treturn;\n\n\tif (drm_WARN_ON(&dev_priv->drm, DISPLAY_VER(dev_priv) >= 9))\n\t\treturn;\n\n\tstate = drm_atomic_state_alloc(&dev_priv->drm);\n\tif (drm_WARN_ON(&dev_priv->drm, !state))\n\t\treturn;\n\n\tintel_state = to_intel_atomic_state(state);\n\n\tdrm_modeset_acquire_init(&ctx, 0);\n\n\tstate->acquire_ctx = &ctx;\n\tto_intel_atomic_state(state)->internal = true;\n\nretry:\n\t \n\tif (!HAS_GMCH(dev_priv))\n\t\tintel_state->skip_intermediate_wm = true;\n\n\tret = ilk_sanitize_watermarks_add_affected(state);\n\tif (ret)\n\t\tgoto fail;\n\n\tret = intel_atomic_check(&dev_priv->drm, state);\n\tif (ret)\n\t\tgoto fail;\n\n\t \n\tfor_each_new_intel_crtc_in_state(intel_state, crtc, crtc_state, i) {\n\t\tcrtc_state->wm.need_postvbl_update = true;\n\t\tintel_optimize_watermarks(intel_state, crtc);\n\n\t\tto_intel_crtc_state(crtc->base.state)->wm = crtc_state->wm;\n\t}\n\nfail:\n\tif (ret == -EDEADLK) {\n\t\tdrm_atomic_state_clear(state);\n\t\tdrm_modeset_backoff(&ctx);\n\t\tgoto retry;\n\t}\n\n\t \n\tdrm_WARN(&dev_priv->drm, ret,\n\t\t \"Could not determine valid watermarks for inherited state\\n\");\n\n\tdrm_atomic_state_put(state);\n\n\tdrm_modeset_drop_locks(&ctx);\n\tdrm_modeset_acquire_fini(&ctx);\n}\n\n#define _FW_WM(value, plane) \\\n\t(((value) & DSPFW_ ## plane ## _MASK) >> DSPFW_ ## plane ## _SHIFT)\n#define _FW_WM_VLV(value, plane) \\\n\t(((value) & DSPFW_ ## plane ## _MASK_VLV) >> DSPFW_ ## plane ## _SHIFT)\n\nstatic void g4x_read_wm_values(struct drm_i915_private *dev_priv,\n\t\t\t       struct g4x_wm_values *wm)\n{\n\tu32 tmp;\n\n\ttmp = intel_uncore_read(&dev_priv->uncore, DSPFW1);\n\twm->sr.plane = _FW_WM(tmp, SR);\n\twm->pipe[PIPE_B].plane[PLANE_CURSOR] = _FW_WM(tmp, CURSORB);\n\twm->pipe[PIPE_B].plane[PLANE_PRIMARY] = _FW_WM(tmp, PLANEB);\n\twm->pipe[PIPE_A].plane[PLANE_PRIMARY] = _FW_WM(tmp, PLANEA);\n\n\ttmp = intel_uncore_read(&dev_priv->uncore, DSPFW2);\n\twm->fbc_en = tmp & DSPFW_FBC_SR_EN;\n\twm->sr.fbc = _FW_WM(tmp, FBC_SR);\n\twm->hpll.fbc = _FW_WM(tmp, FBC_HPLL_SR);\n\twm->pipe[PIPE_B].plane[PLANE_SPRITE0] = _FW_WM(tmp, SPRITEB);\n\twm->pipe[PIPE_A].plane[PLANE_CURSOR] = _FW_WM(tmp, CURSORA);\n\twm->pipe[PIPE_A].plane[PLANE_SPRITE0] = _FW_WM(tmp, SPRITEA);\n\n\ttmp = intel_uncore_read(&dev_priv->uncore, DSPFW3);\n\twm->hpll_en = tmp & DSPFW_HPLL_SR_EN;\n\twm->sr.cursor = _FW_WM(tmp, CURSOR_SR);\n\twm->hpll.cursor = _FW_WM(tmp, HPLL_CURSOR);\n\twm->hpll.plane = _FW_WM(tmp, HPLL_SR);\n}\n\nstatic void vlv_read_wm_values(struct drm_i915_private *dev_priv,\n\t\t\t       struct vlv_wm_values *wm)\n{\n\tenum pipe pipe;\n\tu32 tmp;\n\n\tfor_each_pipe(dev_priv, pipe) {\n\t\ttmp = intel_uncore_read(&dev_priv->uncore, VLV_DDL(pipe));\n\n\t\twm->ddl[pipe].plane[PLANE_PRIMARY] =\n\t\t\t(tmp >> DDL_PLANE_SHIFT) & (DDL_PRECISION_HIGH | DRAIN_LATENCY_MASK);\n\t\twm->ddl[pipe].plane[PLANE_CURSOR] =\n\t\t\t(tmp >> DDL_CURSOR_SHIFT) & (DDL_PRECISION_HIGH | DRAIN_LATENCY_MASK);\n\t\twm->ddl[pipe].plane[PLANE_SPRITE0] =\n\t\t\t(tmp >> DDL_SPRITE_SHIFT(0)) & (DDL_PRECISION_HIGH | DRAIN_LATENCY_MASK);\n\t\twm->ddl[pipe].plane[PLANE_SPRITE1] =\n\t\t\t(tmp >> DDL_SPRITE_SHIFT(1)) & (DDL_PRECISION_HIGH | DRAIN_LATENCY_MASK);\n\t}\n\n\ttmp = intel_uncore_read(&dev_priv->uncore, DSPFW1);\n\twm->sr.plane = _FW_WM(tmp, SR);\n\twm->pipe[PIPE_B].plane[PLANE_CURSOR] = _FW_WM(tmp, CURSORB);\n\twm->pipe[PIPE_B].plane[PLANE_PRIMARY] = _FW_WM_VLV(tmp, PLANEB);\n\twm->pipe[PIPE_A].plane[PLANE_PRIMARY] = _FW_WM_VLV(tmp, PLANEA);\n\n\ttmp = intel_uncore_read(&dev_priv->uncore, DSPFW2);\n\twm->pipe[PIPE_A].plane[PLANE_SPRITE1] = _FW_WM_VLV(tmp, SPRITEB);\n\twm->pipe[PIPE_A].plane[PLANE_CURSOR] = _FW_WM(tmp, CURSORA);\n\twm->pipe[PIPE_A].plane[PLANE_SPRITE0] = _FW_WM_VLV(tmp, SPRITEA);\n\n\ttmp = intel_uncore_read(&dev_priv->uncore, DSPFW3);\n\twm->sr.cursor = _FW_WM(tmp, CURSOR_SR);\n\n\tif (IS_CHERRYVIEW(dev_priv)) {\n\t\ttmp = intel_uncore_read(&dev_priv->uncore, DSPFW7_CHV);\n\t\twm->pipe[PIPE_B].plane[PLANE_SPRITE1] = _FW_WM_VLV(tmp, SPRITED);\n\t\twm->pipe[PIPE_B].plane[PLANE_SPRITE0] = _FW_WM_VLV(tmp, SPRITEC);\n\n\t\ttmp = intel_uncore_read(&dev_priv->uncore, DSPFW8_CHV);\n\t\twm->pipe[PIPE_C].plane[PLANE_SPRITE1] = _FW_WM_VLV(tmp, SPRITEF);\n\t\twm->pipe[PIPE_C].plane[PLANE_SPRITE0] = _FW_WM_VLV(tmp, SPRITEE);\n\n\t\ttmp = intel_uncore_read(&dev_priv->uncore, DSPFW9_CHV);\n\t\twm->pipe[PIPE_C].plane[PLANE_PRIMARY] = _FW_WM_VLV(tmp, PLANEC);\n\t\twm->pipe[PIPE_C].plane[PLANE_CURSOR] = _FW_WM(tmp, CURSORC);\n\n\t\ttmp = intel_uncore_read(&dev_priv->uncore, DSPHOWM);\n\t\twm->sr.plane |= _FW_WM(tmp, SR_HI) << 9;\n\t\twm->pipe[PIPE_C].plane[PLANE_SPRITE1] |= _FW_WM(tmp, SPRITEF_HI) << 8;\n\t\twm->pipe[PIPE_C].plane[PLANE_SPRITE0] |= _FW_WM(tmp, SPRITEE_HI) << 8;\n\t\twm->pipe[PIPE_C].plane[PLANE_PRIMARY] |= _FW_WM(tmp, PLANEC_HI) << 8;\n\t\twm->pipe[PIPE_B].plane[PLANE_SPRITE1] |= _FW_WM(tmp, SPRITED_HI) << 8;\n\t\twm->pipe[PIPE_B].plane[PLANE_SPRITE0] |= _FW_WM(tmp, SPRITEC_HI) << 8;\n\t\twm->pipe[PIPE_B].plane[PLANE_PRIMARY] |= _FW_WM(tmp, PLANEB_HI) << 8;\n\t\twm->pipe[PIPE_A].plane[PLANE_SPRITE1] |= _FW_WM(tmp, SPRITEB_HI) << 8;\n\t\twm->pipe[PIPE_A].plane[PLANE_SPRITE0] |= _FW_WM(tmp, SPRITEA_HI) << 8;\n\t\twm->pipe[PIPE_A].plane[PLANE_PRIMARY] |= _FW_WM(tmp, PLANEA_HI) << 8;\n\t} else {\n\t\ttmp = intel_uncore_read(&dev_priv->uncore, DSPFW7);\n\t\twm->pipe[PIPE_B].plane[PLANE_SPRITE1] = _FW_WM_VLV(tmp, SPRITED);\n\t\twm->pipe[PIPE_B].plane[PLANE_SPRITE0] = _FW_WM_VLV(tmp, SPRITEC);\n\n\t\ttmp = intel_uncore_read(&dev_priv->uncore, DSPHOWM);\n\t\twm->sr.plane |= _FW_WM(tmp, SR_HI) << 9;\n\t\twm->pipe[PIPE_B].plane[PLANE_SPRITE1] |= _FW_WM(tmp, SPRITED_HI) << 8;\n\t\twm->pipe[PIPE_B].plane[PLANE_SPRITE0] |= _FW_WM(tmp, SPRITEC_HI) << 8;\n\t\twm->pipe[PIPE_B].plane[PLANE_PRIMARY] |= _FW_WM(tmp, PLANEB_HI) << 8;\n\t\twm->pipe[PIPE_A].plane[PLANE_SPRITE1] |= _FW_WM(tmp, SPRITEB_HI) << 8;\n\t\twm->pipe[PIPE_A].plane[PLANE_SPRITE0] |= _FW_WM(tmp, SPRITEA_HI) << 8;\n\t\twm->pipe[PIPE_A].plane[PLANE_PRIMARY] |= _FW_WM(tmp, PLANEA_HI) << 8;\n\t}\n}\n\n#undef _FW_WM\n#undef _FW_WM_VLV\n\nstatic void g4x_wm_get_hw_state(struct drm_i915_private *dev_priv)\n{\n\tstruct g4x_wm_values *wm = &dev_priv->display.wm.g4x;\n\tstruct intel_crtc *crtc;\n\n\tg4x_read_wm_values(dev_priv, wm);\n\n\twm->cxsr = intel_uncore_read(&dev_priv->uncore, FW_BLC_SELF) & FW_BLC_SELF_EN;\n\n\tfor_each_intel_crtc(&dev_priv->drm, crtc) {\n\t\tstruct intel_crtc_state *crtc_state =\n\t\t\tto_intel_crtc_state(crtc->base.state);\n\t\tstruct g4x_wm_state *active = &crtc->wm.active.g4x;\n\t\tstruct g4x_pipe_wm *raw;\n\t\tenum pipe pipe = crtc->pipe;\n\t\tenum plane_id plane_id;\n\t\tint level, max_level;\n\n\t\tactive->cxsr = wm->cxsr;\n\t\tactive->hpll_en = wm->hpll_en;\n\t\tactive->fbc_en = wm->fbc_en;\n\n\t\tactive->sr = wm->sr;\n\t\tactive->hpll = wm->hpll;\n\n\t\tfor_each_plane_id_on_crtc(crtc, plane_id) {\n\t\t\tactive->wm.plane[plane_id] =\n\t\t\t\twm->pipe[pipe].plane[plane_id];\n\t\t}\n\n\t\tif (wm->cxsr && wm->hpll_en)\n\t\t\tmax_level = G4X_WM_LEVEL_HPLL;\n\t\telse if (wm->cxsr)\n\t\t\tmax_level = G4X_WM_LEVEL_SR;\n\t\telse\n\t\t\tmax_level = G4X_WM_LEVEL_NORMAL;\n\n\t\tlevel = G4X_WM_LEVEL_NORMAL;\n\t\traw = &crtc_state->wm.g4x.raw[level];\n\t\tfor_each_plane_id_on_crtc(crtc, plane_id)\n\t\t\traw->plane[plane_id] = active->wm.plane[plane_id];\n\n\t\tlevel = G4X_WM_LEVEL_SR;\n\t\tif (level > max_level)\n\t\t\tgoto out;\n\n\t\traw = &crtc_state->wm.g4x.raw[level];\n\t\traw->plane[PLANE_PRIMARY] = active->sr.plane;\n\t\traw->plane[PLANE_CURSOR] = active->sr.cursor;\n\t\traw->plane[PLANE_SPRITE0] = 0;\n\t\traw->fbc = active->sr.fbc;\n\n\t\tlevel = G4X_WM_LEVEL_HPLL;\n\t\tif (level > max_level)\n\t\t\tgoto out;\n\n\t\traw = &crtc_state->wm.g4x.raw[level];\n\t\traw->plane[PLANE_PRIMARY] = active->hpll.plane;\n\t\traw->plane[PLANE_CURSOR] = active->hpll.cursor;\n\t\traw->plane[PLANE_SPRITE0] = 0;\n\t\traw->fbc = active->hpll.fbc;\n\n\t\tlevel++;\n\tout:\n\t\tfor_each_plane_id_on_crtc(crtc, plane_id)\n\t\t\tg4x_raw_plane_wm_set(crtc_state, level,\n\t\t\t\t\t     plane_id, USHRT_MAX);\n\t\tg4x_raw_fbc_wm_set(crtc_state, level, USHRT_MAX);\n\n\t\tg4x_invalidate_wms(crtc, active, level);\n\n\t\tcrtc_state->wm.g4x.optimal = *active;\n\t\tcrtc_state->wm.g4x.intermediate = *active;\n\n\t\tdrm_dbg_kms(&dev_priv->drm,\n\t\t\t    \"Initial watermarks: pipe %c, plane=%d, cursor=%d, sprite=%d\\n\",\n\t\t\t    pipe_name(pipe),\n\t\t\t    wm->pipe[pipe].plane[PLANE_PRIMARY],\n\t\t\t    wm->pipe[pipe].plane[PLANE_CURSOR],\n\t\t\t    wm->pipe[pipe].plane[PLANE_SPRITE0]);\n\t}\n\n\tdrm_dbg_kms(&dev_priv->drm,\n\t\t    \"Initial SR watermarks: plane=%d, cursor=%d fbc=%d\\n\",\n\t\t    wm->sr.plane, wm->sr.cursor, wm->sr.fbc);\n\tdrm_dbg_kms(&dev_priv->drm,\n\t\t    \"Initial HPLL watermarks: plane=%d, SR cursor=%d fbc=%d\\n\",\n\t\t    wm->hpll.plane, wm->hpll.cursor, wm->hpll.fbc);\n\tdrm_dbg_kms(&dev_priv->drm, \"Initial SR=%s HPLL=%s FBC=%s\\n\",\n\t\t    str_yes_no(wm->cxsr), str_yes_no(wm->hpll_en),\n\t\t    str_yes_no(wm->fbc_en));\n}\n\nstatic void g4x_wm_sanitize(struct drm_i915_private *dev_priv)\n{\n\tstruct intel_plane *plane;\n\tstruct intel_crtc *crtc;\n\n\tmutex_lock(&dev_priv->display.wm.wm_mutex);\n\n\tfor_each_intel_plane(&dev_priv->drm, plane) {\n\t\tstruct intel_crtc *crtc =\n\t\t\tintel_crtc_for_pipe(dev_priv, plane->pipe);\n\t\tstruct intel_crtc_state *crtc_state =\n\t\t\tto_intel_crtc_state(crtc->base.state);\n\t\tstruct intel_plane_state *plane_state =\n\t\t\tto_intel_plane_state(plane->base.state);\n\t\tenum plane_id plane_id = plane->id;\n\t\tint level;\n\n\t\tif (plane_state->uapi.visible)\n\t\t\tcontinue;\n\n\t\tfor (level = 0; level < dev_priv->display.wm.num_levels; level++) {\n\t\t\tstruct g4x_pipe_wm *raw =\n\t\t\t\t&crtc_state->wm.g4x.raw[level];\n\n\t\t\traw->plane[plane_id] = 0;\n\n\t\t\tif (plane_id == PLANE_PRIMARY)\n\t\t\t\traw->fbc = 0;\n\t\t}\n\t}\n\n\tfor_each_intel_crtc(&dev_priv->drm, crtc) {\n\t\tstruct intel_crtc_state *crtc_state =\n\t\t\tto_intel_crtc_state(crtc->base.state);\n\t\tint ret;\n\n\t\tret = _g4x_compute_pipe_wm(crtc_state);\n\t\tdrm_WARN_ON(&dev_priv->drm, ret);\n\n\t\tcrtc_state->wm.g4x.intermediate =\n\t\t\tcrtc_state->wm.g4x.optimal;\n\t\tcrtc->wm.active.g4x = crtc_state->wm.g4x.optimal;\n\t}\n\n\tg4x_program_watermarks(dev_priv);\n\n\tmutex_unlock(&dev_priv->display.wm.wm_mutex);\n}\n\nstatic void g4x_wm_get_hw_state_and_sanitize(struct drm_i915_private *i915)\n{\n\tg4x_wm_get_hw_state(i915);\n\tg4x_wm_sanitize(i915);\n}\n\nstatic void vlv_wm_get_hw_state(struct drm_i915_private *dev_priv)\n{\n\tstruct vlv_wm_values *wm = &dev_priv->display.wm.vlv;\n\tstruct intel_crtc *crtc;\n\tu32 val;\n\n\tvlv_read_wm_values(dev_priv, wm);\n\n\twm->cxsr = intel_uncore_read(&dev_priv->uncore, FW_BLC_SELF_VLV) & FW_CSPWRDWNEN;\n\twm->level = VLV_WM_LEVEL_PM2;\n\n\tif (IS_CHERRYVIEW(dev_priv)) {\n\t\tvlv_punit_get(dev_priv);\n\n\t\tval = vlv_punit_read(dev_priv, PUNIT_REG_DSPSSPM);\n\t\tif (val & DSP_MAXFIFO_PM5_ENABLE)\n\t\t\twm->level = VLV_WM_LEVEL_PM5;\n\n\t\t \n\t\tval = vlv_punit_read(dev_priv, PUNIT_REG_DDR_SETUP2);\n\t\tval |= FORCE_DDR_FREQ_REQ_ACK;\n\t\tvlv_punit_write(dev_priv, PUNIT_REG_DDR_SETUP2, val);\n\n\t\tif (wait_for((vlv_punit_read(dev_priv, PUNIT_REG_DDR_SETUP2) &\n\t\t\t      FORCE_DDR_FREQ_REQ_ACK) == 0, 3)) {\n\t\t\tdrm_dbg_kms(&dev_priv->drm,\n\t\t\t\t    \"Punit not acking DDR DVFS request, \"\n\t\t\t\t    \"assuming DDR DVFS is disabled\\n\");\n\t\t\tdev_priv->display.wm.num_levels = VLV_WM_LEVEL_PM5 + 1;\n\t\t} else {\n\t\t\tval = vlv_punit_read(dev_priv, PUNIT_REG_DDR_SETUP2);\n\t\t\tif ((val & FORCE_DDR_HIGH_FREQ) == 0)\n\t\t\t\twm->level = VLV_WM_LEVEL_DDR_DVFS;\n\t\t}\n\n\t\tvlv_punit_put(dev_priv);\n\t}\n\n\tfor_each_intel_crtc(&dev_priv->drm, crtc) {\n\t\tstruct intel_crtc_state *crtc_state =\n\t\t\tto_intel_crtc_state(crtc->base.state);\n\t\tstruct vlv_wm_state *active = &crtc->wm.active.vlv;\n\t\tconst struct vlv_fifo_state *fifo_state =\n\t\t\t&crtc_state->wm.vlv.fifo_state;\n\t\tenum pipe pipe = crtc->pipe;\n\t\tenum plane_id plane_id;\n\t\tint level;\n\n\t\tvlv_get_fifo_size(crtc_state);\n\n\t\tactive->num_levels = wm->level + 1;\n\t\tactive->cxsr = wm->cxsr;\n\n\t\tfor (level = 0; level < active->num_levels; level++) {\n\t\t\tstruct g4x_pipe_wm *raw =\n\t\t\t\t&crtc_state->wm.vlv.raw[level];\n\n\t\t\tactive->sr[level].plane = wm->sr.plane;\n\t\t\tactive->sr[level].cursor = wm->sr.cursor;\n\n\t\t\tfor_each_plane_id_on_crtc(crtc, plane_id) {\n\t\t\t\tactive->wm[level].plane[plane_id] =\n\t\t\t\t\twm->pipe[pipe].plane[plane_id];\n\n\t\t\t\traw->plane[plane_id] =\n\t\t\t\t\tvlv_invert_wm_value(active->wm[level].plane[plane_id],\n\t\t\t\t\t\t\t    fifo_state->plane[plane_id]);\n\t\t\t}\n\t\t}\n\n\t\tfor_each_plane_id_on_crtc(crtc, plane_id)\n\t\t\tvlv_raw_plane_wm_set(crtc_state, level,\n\t\t\t\t\t     plane_id, USHRT_MAX);\n\t\tvlv_invalidate_wms(crtc, active, level);\n\n\t\tcrtc_state->wm.vlv.optimal = *active;\n\t\tcrtc_state->wm.vlv.intermediate = *active;\n\n\t\tdrm_dbg_kms(&dev_priv->drm,\n\t\t\t    \"Initial watermarks: pipe %c, plane=%d, cursor=%d, sprite0=%d, sprite1=%d\\n\",\n\t\t\t    pipe_name(pipe),\n\t\t\t    wm->pipe[pipe].plane[PLANE_PRIMARY],\n\t\t\t    wm->pipe[pipe].plane[PLANE_CURSOR],\n\t\t\t    wm->pipe[pipe].plane[PLANE_SPRITE0],\n\t\t\t    wm->pipe[pipe].plane[PLANE_SPRITE1]);\n\t}\n\n\tdrm_dbg_kms(&dev_priv->drm,\n\t\t    \"Initial watermarks: SR plane=%d, SR cursor=%d level=%d cxsr=%d\\n\",\n\t\t    wm->sr.plane, wm->sr.cursor, wm->level, wm->cxsr);\n}\n\nstatic void vlv_wm_sanitize(struct drm_i915_private *dev_priv)\n{\n\tstruct intel_plane *plane;\n\tstruct intel_crtc *crtc;\n\n\tmutex_lock(&dev_priv->display.wm.wm_mutex);\n\n\tfor_each_intel_plane(&dev_priv->drm, plane) {\n\t\tstruct intel_crtc *crtc =\n\t\t\tintel_crtc_for_pipe(dev_priv, plane->pipe);\n\t\tstruct intel_crtc_state *crtc_state =\n\t\t\tto_intel_crtc_state(crtc->base.state);\n\t\tstruct intel_plane_state *plane_state =\n\t\t\tto_intel_plane_state(plane->base.state);\n\t\tenum plane_id plane_id = plane->id;\n\t\tint level;\n\n\t\tif (plane_state->uapi.visible)\n\t\t\tcontinue;\n\n\t\tfor (level = 0; level < dev_priv->display.wm.num_levels; level++) {\n\t\t\tstruct g4x_pipe_wm *raw =\n\t\t\t\t&crtc_state->wm.vlv.raw[level];\n\n\t\t\traw->plane[plane_id] = 0;\n\t\t}\n\t}\n\n\tfor_each_intel_crtc(&dev_priv->drm, crtc) {\n\t\tstruct intel_crtc_state *crtc_state =\n\t\t\tto_intel_crtc_state(crtc->base.state);\n\t\tint ret;\n\n\t\tret = _vlv_compute_pipe_wm(crtc_state);\n\t\tdrm_WARN_ON(&dev_priv->drm, ret);\n\n\t\tcrtc_state->wm.vlv.intermediate =\n\t\t\tcrtc_state->wm.vlv.optimal;\n\t\tcrtc->wm.active.vlv = crtc_state->wm.vlv.optimal;\n\t}\n\n\tvlv_program_watermarks(dev_priv);\n\n\tmutex_unlock(&dev_priv->display.wm.wm_mutex);\n}\n\nstatic void vlv_wm_get_hw_state_and_sanitize(struct drm_i915_private *i915)\n{\n\tvlv_wm_get_hw_state(i915);\n\tvlv_wm_sanitize(i915);\n}\n\n \nstatic void ilk_init_lp_watermarks(struct drm_i915_private *dev_priv)\n{\n\tintel_uncore_rmw(&dev_priv->uncore, WM3_LP_ILK, WM_LP_ENABLE, 0);\n\tintel_uncore_rmw(&dev_priv->uncore, WM2_LP_ILK, WM_LP_ENABLE, 0);\n\tintel_uncore_rmw(&dev_priv->uncore, WM1_LP_ILK, WM_LP_ENABLE, 0);\n\n\t \n}\n\nstatic void ilk_wm_get_hw_state(struct drm_i915_private *dev_priv)\n{\n\tstruct ilk_wm_values *hw = &dev_priv->display.wm.hw;\n\tstruct intel_crtc *crtc;\n\n\tilk_init_lp_watermarks(dev_priv);\n\n\tfor_each_intel_crtc(&dev_priv->drm, crtc)\n\t\tilk_pipe_wm_get_hw_state(crtc);\n\n\thw->wm_lp[0] = intel_uncore_read(&dev_priv->uncore, WM1_LP_ILK);\n\thw->wm_lp[1] = intel_uncore_read(&dev_priv->uncore, WM2_LP_ILK);\n\thw->wm_lp[2] = intel_uncore_read(&dev_priv->uncore, WM3_LP_ILK);\n\n\thw->wm_lp_spr[0] = intel_uncore_read(&dev_priv->uncore, WM1S_LP_ILK);\n\tif (DISPLAY_VER(dev_priv) >= 7) {\n\t\thw->wm_lp_spr[1] = intel_uncore_read(&dev_priv->uncore, WM2S_LP_IVB);\n\t\thw->wm_lp_spr[2] = intel_uncore_read(&dev_priv->uncore, WM3S_LP_IVB);\n\t}\n\n\tif (IS_HASWELL(dev_priv) || IS_BROADWELL(dev_priv))\n\t\thw->partitioning = (intel_uncore_read(&dev_priv->uncore, WM_MISC) &\n\t\t\t\t    WM_MISC_DATA_PARTITION_5_6) ?\n\t\t\tINTEL_DDB_PART_5_6 : INTEL_DDB_PART_1_2;\n\telse if (IS_IVYBRIDGE(dev_priv))\n\t\thw->partitioning = (intel_uncore_read(&dev_priv->uncore, DISP_ARB_CTL2) &\n\t\t\t\t    DISP_DATA_PARTITION_5_6) ?\n\t\t\tINTEL_DDB_PART_5_6 : INTEL_DDB_PART_1_2;\n\n\thw->enable_fbc_wm =\n\t\t!(intel_uncore_read(&dev_priv->uncore, DISP_ARB_CTL) & DISP_FBC_WM_DIS);\n}\n\nstatic const struct intel_wm_funcs ilk_wm_funcs = {\n\t.compute_pipe_wm = ilk_compute_pipe_wm,\n\t.compute_intermediate_wm = ilk_compute_intermediate_wm,\n\t.initial_watermarks = ilk_initial_watermarks,\n\t.optimize_watermarks = ilk_optimize_watermarks,\n\t.get_hw_state = ilk_wm_get_hw_state,\n};\n\nstatic const struct intel_wm_funcs vlv_wm_funcs = {\n\t.compute_pipe_wm = vlv_compute_pipe_wm,\n\t.compute_intermediate_wm = vlv_compute_intermediate_wm,\n\t.initial_watermarks = vlv_initial_watermarks,\n\t.optimize_watermarks = vlv_optimize_watermarks,\n\t.atomic_update_watermarks = vlv_atomic_update_fifo,\n\t.get_hw_state = vlv_wm_get_hw_state_and_sanitize,\n};\n\nstatic const struct intel_wm_funcs g4x_wm_funcs = {\n\t.compute_pipe_wm = g4x_compute_pipe_wm,\n\t.compute_intermediate_wm = g4x_compute_intermediate_wm,\n\t.initial_watermarks = g4x_initial_watermarks,\n\t.optimize_watermarks = g4x_optimize_watermarks,\n\t.get_hw_state = g4x_wm_get_hw_state_and_sanitize,\n};\n\nstatic const struct intel_wm_funcs pnv_wm_funcs = {\n\t.update_wm = pnv_update_wm,\n};\n\nstatic const struct intel_wm_funcs i965_wm_funcs = {\n\t.update_wm = i965_update_wm,\n};\n\nstatic const struct intel_wm_funcs i9xx_wm_funcs = {\n\t.update_wm = i9xx_update_wm,\n};\n\nstatic const struct intel_wm_funcs i845_wm_funcs = {\n\t.update_wm = i845_update_wm,\n};\n\nstatic const struct intel_wm_funcs nop_funcs = {\n};\n\nvoid i9xx_wm_init(struct drm_i915_private *dev_priv)\n{\n\t \n\tif (HAS_PCH_SPLIT(dev_priv)) {\n\t\tilk_setup_wm_latency(dev_priv);\n\t\tdev_priv->display.funcs.wm = &ilk_wm_funcs;\n\t} else if (IS_VALLEYVIEW(dev_priv) || IS_CHERRYVIEW(dev_priv)) {\n\t\tvlv_setup_wm_latency(dev_priv);\n\t\tdev_priv->display.funcs.wm = &vlv_wm_funcs;\n\t} else if (IS_G4X(dev_priv)) {\n\t\tg4x_setup_wm_latency(dev_priv);\n\t\tdev_priv->display.funcs.wm = &g4x_wm_funcs;\n\t} else if (IS_PINEVIEW(dev_priv)) {\n\t\tif (!intel_get_cxsr_latency(!IS_MOBILE(dev_priv),\n\t\t\t\t\t    dev_priv->is_ddr3,\n\t\t\t\t\t    dev_priv->fsb_freq,\n\t\t\t\t\t    dev_priv->mem_freq)) {\n\t\t\tdrm_info(&dev_priv->drm,\n\t\t\t\t \"failed to find known CxSR latency \"\n\t\t\t\t \"(found ddr%s fsb freq %d, mem freq %d), \"\n\t\t\t\t \"disabling CxSR\\n\",\n\t\t\t\t (dev_priv->is_ddr3 == 1) ? \"3\" : \"2\",\n\t\t\t\t dev_priv->fsb_freq, dev_priv->mem_freq);\n\t\t\t \n\t\t\tintel_set_memory_cxsr(dev_priv, false);\n\t\t\tdev_priv->display.funcs.wm = &nop_funcs;\n\t\t} else {\n\t\t\tdev_priv->display.funcs.wm = &pnv_wm_funcs;\n\t\t}\n\t} else if (DISPLAY_VER(dev_priv) == 4) {\n\t\tdev_priv->display.funcs.wm = &i965_wm_funcs;\n\t} else if (DISPLAY_VER(dev_priv) == 3) {\n\t\tdev_priv->display.funcs.wm = &i9xx_wm_funcs;\n\t} else if (DISPLAY_VER(dev_priv) == 2) {\n\t\tif (INTEL_NUM_PIPES(dev_priv) == 1)\n\t\t\tdev_priv->display.funcs.wm = &i845_wm_funcs;\n\t\telse\n\t\t\tdev_priv->display.funcs.wm = &i9xx_wm_funcs;\n\t} else {\n\t\tdrm_err(&dev_priv->drm,\n\t\t\t\"unexpected fall-through in %s\\n\", __func__);\n\t\tdev_priv->display.funcs.wm = &nop_funcs;\n\t}\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}