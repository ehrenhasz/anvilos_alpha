{
  "module_name": "intel_hdcp.c",
  "hash_id": "2adf340351078c1c97543f5ab1620ea7b1fb00660872340ef591bb1753d0574a",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/i915/display/intel_hdcp.c",
  "human_readable_source": " \n \n\n#include <linux/component.h>\n#include <linux/i2c.h>\n#include <linux/random.h>\n\n#include <drm/display/drm_hdcp_helper.h>\n#include <drm/i915_component.h>\n\n#include \"i915_drv.h\"\n#include \"i915_reg.h\"\n#include \"intel_connector.h\"\n#include \"intel_de.h\"\n#include \"intel_display_power.h\"\n#include \"intel_display_power_well.h\"\n#include \"intel_display_types.h\"\n#include \"intel_hdcp.h\"\n#include \"intel_hdcp_gsc.h\"\n#include \"intel_hdcp_regs.h\"\n#include \"intel_pcode.h\"\n\n#define KEY_LOAD_TRIES\t5\n#define HDCP2_LC_RETRY_CNT\t\t\t3\n\nstatic int intel_conn_to_vcpi(struct drm_atomic_state *state,\n\t\t\t      struct intel_connector *connector)\n{\n\tstruct drm_dp_mst_topology_mgr *mgr;\n\tstruct drm_dp_mst_atomic_payload *payload;\n\tstruct drm_dp_mst_topology_state *mst_state;\n\tint vcpi = 0;\n\n\t \n\tif (!connector->port)\n\t\treturn 0;\n\tmgr = connector->port->mgr;\n\n\tdrm_modeset_lock(&mgr->base.lock, state->acquire_ctx);\n\tmst_state = to_drm_dp_mst_topology_state(mgr->base.state);\n\tpayload = drm_atomic_get_mst_payload_state(mst_state, connector->port);\n\tif (drm_WARN_ON(mgr->dev, !payload))\n\t\tgoto out;\n\n\tvcpi = payload->vcpi;\n\tif (drm_WARN_ON(mgr->dev, vcpi < 0)) {\n\t\tvcpi = 0;\n\t\tgoto out;\n\t}\nout:\n\treturn vcpi;\n}\n\n \nstatic void\nintel_hdcp_required_content_stream(struct intel_digital_port *dig_port)\n{\n\tstruct hdcp_port_data *data = &dig_port->hdcp_port_data;\n\tbool enforce_type0 = false;\n\tint k;\n\n\tif (dig_port->hdcp_auth_status)\n\t\treturn;\n\n\tif (!dig_port->hdcp_mst_type1_capable)\n\t\tenforce_type0 = true;\n\n\t \n\tfor (k = 0; k < data->k; k++)\n\t\tdata->streams[k].stream_type =\n\t\t\tenforce_type0 ? DRM_MODE_HDCP_CONTENT_TYPE0 : DRM_MODE_HDCP_CONTENT_TYPE1;\n}\n\nstatic void intel_hdcp_prepare_streams(struct intel_connector *connector)\n{\n\tstruct intel_digital_port *dig_port = intel_attached_dig_port(connector);\n\tstruct hdcp_port_data *data = &dig_port->hdcp_port_data;\n\tstruct intel_hdcp *hdcp = &connector->hdcp;\n\n\tif (!intel_encoder_is_mst(intel_attached_encoder(connector))) {\n\t\tdata->streams[0].stream_type = hdcp->content_type;\n\t} else {\n\t\tintel_hdcp_required_content_stream(dig_port);\n\t}\n}\n\nstatic\nbool intel_hdcp_is_ksv_valid(u8 *ksv)\n{\n\tint i, ones = 0;\n\t \n\tfor (i = 0; i < DRM_HDCP_KSV_LEN; i++)\n\t\tones += hweight8(ksv[i]);\n\tif (ones != 20)\n\t\treturn false;\n\n\treturn true;\n}\n\nstatic\nint intel_hdcp_read_valid_bksv(struct intel_digital_port *dig_port,\n\t\t\t       const struct intel_hdcp_shim *shim, u8 *bksv)\n{\n\tstruct drm_i915_private *i915 = to_i915(dig_port->base.base.dev);\n\tint ret, i, tries = 2;\n\n\t \n\tfor (i = 0; i < tries; i++) {\n\t\tret = shim->read_bksv(dig_port, bksv);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tif (intel_hdcp_is_ksv_valid(bksv))\n\t\t\tbreak;\n\t}\n\tif (i == tries) {\n\t\tdrm_dbg_kms(&i915->drm, \"Bksv is invalid\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\treturn 0;\n}\n\n \nbool intel_hdcp_capable(struct intel_connector *connector)\n{\n\tstruct intel_digital_port *dig_port = intel_attached_dig_port(connector);\n\tconst struct intel_hdcp_shim *shim = connector->hdcp.shim;\n\tbool capable = false;\n\tu8 bksv[5];\n\n\tif (!shim)\n\t\treturn capable;\n\n\tif (shim->hdcp_capable) {\n\t\tshim->hdcp_capable(dig_port, &capable);\n\t} else {\n\t\tif (!intel_hdcp_read_valid_bksv(dig_port, shim, bksv))\n\t\t\tcapable = true;\n\t}\n\n\treturn capable;\n}\n\n \nbool intel_hdcp2_capable(struct intel_connector *connector)\n{\n\tstruct intel_digital_port *dig_port = intel_attached_dig_port(connector);\n\tstruct drm_i915_private *i915 = to_i915(connector->base.dev);\n\tstruct intel_hdcp *hdcp = &connector->hdcp;\n\tbool capable = false;\n\n\t \n\tif (!hdcp->hdcp2_supported)\n\t\treturn false;\n\n\t \n\tif (intel_hdcp_gsc_cs_required(i915)) {\n\t\tstruct intel_gt *gt = i915->media_gt;\n\t\tstruct intel_gsc_uc *gsc = gt ? &gt->uc.gsc : NULL;\n\n\t\tif (!gsc || !intel_uc_fw_is_running(&gsc->fw)) {\n\t\t\tdrm_dbg_kms(&i915->drm,\n\t\t\t\t    \"GSC components required for HDCP2.2 are not ready\\n\");\n\t\t\treturn false;\n\t\t}\n\t}\n\n\t \n\tmutex_lock(&i915->display.hdcp.hdcp_mutex);\n\tif (!i915->display.hdcp.comp_added ||  !i915->display.hdcp.arbiter) {\n\t\tmutex_unlock(&i915->display.hdcp.hdcp_mutex);\n\t\treturn false;\n\t}\n\tmutex_unlock(&i915->display.hdcp.hdcp_mutex);\n\n\t \n\thdcp->shim->hdcp_2_2_capable(dig_port, &capable);\n\n\treturn capable;\n}\n\nstatic bool intel_hdcp_in_use(struct drm_i915_private *i915,\n\t\t\t      enum transcoder cpu_transcoder, enum port port)\n{\n\treturn intel_de_read(i915,\n\t\t\t     HDCP_STATUS(i915, cpu_transcoder, port)) &\n\t\tHDCP_STATUS_ENC;\n}\n\nstatic bool intel_hdcp2_in_use(struct drm_i915_private *i915,\n\t\t\t       enum transcoder cpu_transcoder, enum port port)\n{\n\treturn intel_de_read(i915,\n\t\t\t     HDCP2_STATUS(i915, cpu_transcoder, port)) &\n\t\tLINK_ENCRYPTION_STATUS;\n}\n\nstatic int intel_hdcp_poll_ksv_fifo(struct intel_digital_port *dig_port,\n\t\t\t\t    const struct intel_hdcp_shim *shim)\n{\n\tint ret, read_ret;\n\tbool ksv_ready;\n\n\t \n\tret = __wait_for(read_ret = shim->read_ksv_ready(dig_port,\n\t\t\t\t\t\t\t &ksv_ready),\n\t\t\t read_ret || ksv_ready, 5 * 1000 * 1000, 1000,\n\t\t\t 100 * 1000);\n\tif (ret)\n\t\treturn ret;\n\tif (read_ret)\n\t\treturn read_ret;\n\tif (!ksv_ready)\n\t\treturn -ETIMEDOUT;\n\n\treturn 0;\n}\n\nstatic bool hdcp_key_loadable(struct drm_i915_private *i915)\n{\n\tenum i915_power_well_id id;\n\tintel_wakeref_t wakeref;\n\tbool enabled = false;\n\n\t \n\tif (IS_HASWELL(i915) || IS_BROADWELL(i915))\n\t\tid = HSW_DISP_PW_GLOBAL;\n\telse\n\t\tid = SKL_DISP_PW_1;\n\n\t \n\twith_intel_runtime_pm(&i915->runtime_pm, wakeref)\n\t\tenabled = intel_display_power_well_is_enabled(i915, id);\n\n\t \n\n\treturn enabled;\n}\n\nstatic void intel_hdcp_clear_keys(struct drm_i915_private *i915)\n{\n\tintel_de_write(i915, HDCP_KEY_CONF, HDCP_CLEAR_KEYS_TRIGGER);\n\tintel_de_write(i915, HDCP_KEY_STATUS,\n\t\t       HDCP_KEY_LOAD_DONE | HDCP_KEY_LOAD_STATUS | HDCP_FUSE_IN_PROGRESS | HDCP_FUSE_ERROR | HDCP_FUSE_DONE);\n}\n\nstatic int intel_hdcp_load_keys(struct drm_i915_private *i915)\n{\n\tint ret;\n\tu32 val;\n\n\tval = intel_de_read(i915, HDCP_KEY_STATUS);\n\tif ((val & HDCP_KEY_LOAD_DONE) && (val & HDCP_KEY_LOAD_STATUS))\n\t\treturn 0;\n\n\t \n\tif (IS_HASWELL(i915) || IS_BROADWELL(i915))\n\t\tif (!(intel_de_read(i915, HDCP_KEY_STATUS) & HDCP_KEY_LOAD_DONE))\n\t\t\treturn -ENXIO;\n\n\t \n\tif (DISPLAY_VER(i915) == 9 && !IS_BROXTON(i915)) {\n\t\tret = snb_pcode_write(&i915->uncore, SKL_PCODE_LOAD_HDCP_KEYS, 1);\n\t\tif (ret) {\n\t\t\tdrm_err(&i915->drm,\n\t\t\t\t\"Failed to initiate HDCP key load (%d)\\n\",\n\t\t\t\tret);\n\t\t\treturn ret;\n\t\t}\n\t} else {\n\t\tintel_de_write(i915, HDCP_KEY_CONF, HDCP_KEY_LOAD_TRIGGER);\n\t}\n\n\t \n\tret = __intel_wait_for_register(&i915->uncore, HDCP_KEY_STATUS,\n\t\t\t\t\tHDCP_KEY_LOAD_DONE, HDCP_KEY_LOAD_DONE,\n\t\t\t\t\t10, 1, &val);\n\tif (ret)\n\t\treturn ret;\n\telse if (!(val & HDCP_KEY_LOAD_STATUS))\n\t\treturn -ENXIO;\n\n\t \n\tintel_de_write(i915, HDCP_KEY_CONF, HDCP_AKSV_SEND_TRIGGER);\n\n\treturn 0;\n}\n\n \nstatic int intel_write_sha_text(struct drm_i915_private *i915, u32 sha_text)\n{\n\tintel_de_write(i915, HDCP_SHA_TEXT, sha_text);\n\tif (intel_de_wait_for_set(i915, HDCP_REP_CTL, HDCP_SHA1_READY, 1)) {\n\t\tdrm_err(&i915->drm, \"Timed out waiting for SHA1 ready\\n\");\n\t\treturn -ETIMEDOUT;\n\t}\n\treturn 0;\n}\n\nstatic\nu32 intel_hdcp_get_repeater_ctl(struct drm_i915_private *i915,\n\t\t\t\tenum transcoder cpu_transcoder, enum port port)\n{\n\tif (DISPLAY_VER(i915) >= 12) {\n\t\tswitch (cpu_transcoder) {\n\t\tcase TRANSCODER_A:\n\t\t\treturn HDCP_TRANSA_REP_PRESENT |\n\t\t\t       HDCP_TRANSA_SHA1_M0;\n\t\tcase TRANSCODER_B:\n\t\t\treturn HDCP_TRANSB_REP_PRESENT |\n\t\t\t       HDCP_TRANSB_SHA1_M0;\n\t\tcase TRANSCODER_C:\n\t\t\treturn HDCP_TRANSC_REP_PRESENT |\n\t\t\t       HDCP_TRANSC_SHA1_M0;\n\t\tcase TRANSCODER_D:\n\t\t\treturn HDCP_TRANSD_REP_PRESENT |\n\t\t\t       HDCP_TRANSD_SHA1_M0;\n\t\tdefault:\n\t\t\tdrm_err(&i915->drm, \"Unknown transcoder %d\\n\",\n\t\t\t\tcpu_transcoder);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tswitch (port) {\n\tcase PORT_A:\n\t\treturn HDCP_DDIA_REP_PRESENT | HDCP_DDIA_SHA1_M0;\n\tcase PORT_B:\n\t\treturn HDCP_DDIB_REP_PRESENT | HDCP_DDIB_SHA1_M0;\n\tcase PORT_C:\n\t\treturn HDCP_DDIC_REP_PRESENT | HDCP_DDIC_SHA1_M0;\n\tcase PORT_D:\n\t\treturn HDCP_DDID_REP_PRESENT | HDCP_DDID_SHA1_M0;\n\tcase PORT_E:\n\t\treturn HDCP_DDIE_REP_PRESENT | HDCP_DDIE_SHA1_M0;\n\tdefault:\n\t\tdrm_err(&i915->drm, \"Unknown port %d\\n\", port);\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic\nint intel_hdcp_validate_v_prime(struct intel_connector *connector,\n\t\t\t\tconst struct intel_hdcp_shim *shim,\n\t\t\t\tu8 *ksv_fifo, u8 num_downstream, u8 *bstatus)\n{\n\tstruct intel_digital_port *dig_port = intel_attached_dig_port(connector);\n\tstruct drm_i915_private *i915 = to_i915(connector->base.dev);\n\tenum transcoder cpu_transcoder = connector->hdcp.cpu_transcoder;\n\tenum port port = dig_port->base.port;\n\tu32 vprime, sha_text, sha_leftovers, rep_ctl;\n\tint ret, i, j, sha_idx;\n\n\t \n\tfor (i = 0; i < DRM_HDCP_V_PRIME_NUM_PARTS; i++) {\n\t\tret = shim->read_v_prime_part(dig_port, i, &vprime);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tintel_de_write(i915, HDCP_SHA_V_PRIME(i), vprime);\n\t}\n\n\t \n\tsha_idx = 0;\n\tsha_text = 0;\n\tsha_leftovers = 0;\n\trep_ctl = intel_hdcp_get_repeater_ctl(i915, cpu_transcoder, port);\n\tintel_de_write(i915, HDCP_REP_CTL, rep_ctl | HDCP_SHA1_TEXT_32);\n\tfor (i = 0; i < num_downstream; i++) {\n\t\tunsigned int sha_empty;\n\t\tu8 *ksv = &ksv_fifo[i * DRM_HDCP_KSV_LEN];\n\n\t\t \n\t\tsha_empty = sizeof(sha_text) - sha_leftovers;\n\t\tfor (j = 0; j < sha_empty; j++) {\n\t\t\tu8 off = ((sizeof(sha_text) - j - 1 - sha_leftovers) * 8);\n\t\t\tsha_text |= ksv[j] << off;\n\t\t}\n\n\t\tret = intel_write_sha_text(i915, sha_text);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\t \n\t\tsha_idx += sizeof(sha_text);\n\t\tif (!(sha_idx % 64))\n\t\t\tintel_de_write(i915, HDCP_REP_CTL,\n\t\t\t\t       rep_ctl | HDCP_SHA1_TEXT_32);\n\n\t\t \n\t\tsha_leftovers = DRM_HDCP_KSV_LEN - sha_empty;\n\t\tsha_text = 0;\n\t\tfor (j = 0; j < sha_leftovers; j++)\n\t\t\tsha_text |= ksv[sha_empty + j] <<\n\t\t\t\t\t((sizeof(sha_text) - j - 1) * 8);\n\n\t\t \n\t\tif (sizeof(sha_text) > sha_leftovers)\n\t\t\tcontinue;\n\n\t\tret = intel_write_sha_text(i915, sha_text);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tsha_leftovers = 0;\n\t\tsha_text = 0;\n\t\tsha_idx += sizeof(sha_text);\n\t}\n\n\t \n\tif (sha_leftovers == 0) {\n\t\t \n\t\tintel_de_write(i915, HDCP_REP_CTL,\n\t\t\t       rep_ctl | HDCP_SHA1_TEXT_16);\n\t\tret = intel_write_sha_text(i915,\n\t\t\t\t\t   bstatus[0] << 8 | bstatus[1]);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tsha_idx += sizeof(sha_text);\n\n\t\t \n\t\tintel_de_write(i915, HDCP_REP_CTL,\n\t\t\t       rep_ctl | HDCP_SHA1_TEXT_0);\n\t\tret = intel_write_sha_text(i915, 0);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tsha_idx += sizeof(sha_text);\n\n\t\t \n\t\tintel_de_write(i915, HDCP_REP_CTL,\n\t\t\t       rep_ctl | HDCP_SHA1_TEXT_16);\n\t\tret = intel_write_sha_text(i915, 0);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tsha_idx += sizeof(sha_text);\n\n\t} else if (sha_leftovers == 1) {\n\t\t \n\t\tintel_de_write(i915, HDCP_REP_CTL,\n\t\t\t       rep_ctl | HDCP_SHA1_TEXT_24);\n\t\tsha_text |= bstatus[0] << 16 | bstatus[1] << 8;\n\t\t \n\t\tsha_text = (sha_text & 0xffffff00) >> 8;\n\t\tret = intel_write_sha_text(i915, sha_text);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tsha_idx += sizeof(sha_text);\n\n\t\t \n\t\tintel_de_write(i915, HDCP_REP_CTL,\n\t\t\t       rep_ctl | HDCP_SHA1_TEXT_0);\n\t\tret = intel_write_sha_text(i915, 0);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tsha_idx += sizeof(sha_text);\n\n\t\t \n\t\tintel_de_write(i915, HDCP_REP_CTL,\n\t\t\t       rep_ctl | HDCP_SHA1_TEXT_8);\n\t\tret = intel_write_sha_text(i915, 0);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tsha_idx += sizeof(sha_text);\n\n\t} else if (sha_leftovers == 2) {\n\t\t \n\t\tintel_de_write(i915, HDCP_REP_CTL,\n\t\t\t       rep_ctl | HDCP_SHA1_TEXT_32);\n\t\tsha_text |= bstatus[0] << 8 | bstatus[1];\n\t\tret = intel_write_sha_text(i915, sha_text);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tsha_idx += sizeof(sha_text);\n\n\t\t \n\t\tintel_de_write(i915, HDCP_REP_CTL,\n\t\t\t       rep_ctl | HDCP_SHA1_TEXT_0);\n\t\tfor (i = 0; i < 2; i++) {\n\t\t\tret = intel_write_sha_text(i915, 0);\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\t\t\tsha_idx += sizeof(sha_text);\n\t\t}\n\n\t\t \n\t\tintel_de_write(i915, HDCP_REP_CTL,\n\t\t\t       rep_ctl | HDCP_SHA1_TEXT_32);\n\t\tsha_text = DRM_HDCP_SHA1_TERMINATOR << 24;\n\t\tret = intel_write_sha_text(i915, sha_text);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tsha_idx += sizeof(sha_text);\n\t} else if (sha_leftovers == 3) {\n\t\t \n\t\tintel_de_write(i915, HDCP_REP_CTL,\n\t\t\t       rep_ctl | HDCP_SHA1_TEXT_32);\n\t\tsha_text |= bstatus[0];\n\t\tret = intel_write_sha_text(i915, sha_text);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tsha_idx += sizeof(sha_text);\n\n\t\t \n\t\tintel_de_write(i915, HDCP_REP_CTL,\n\t\t\t       rep_ctl | HDCP_SHA1_TEXT_8);\n\t\tret = intel_write_sha_text(i915, bstatus[1]);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tsha_idx += sizeof(sha_text);\n\n\t\t \n\t\tintel_de_write(i915, HDCP_REP_CTL,\n\t\t\t       rep_ctl | HDCP_SHA1_TEXT_0);\n\t\tret = intel_write_sha_text(i915, 0);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tsha_idx += sizeof(sha_text);\n\n\t\t \n\t\tintel_de_write(i915, HDCP_REP_CTL,\n\t\t\t       rep_ctl | HDCP_SHA1_TEXT_24);\n\t\tret = intel_write_sha_text(i915, 0);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tsha_idx += sizeof(sha_text);\n\t} else {\n\t\tdrm_dbg_kms(&i915->drm, \"Invalid number of leftovers %d\\n\",\n\t\t\t    sha_leftovers);\n\t\treturn -EINVAL;\n\t}\n\n\tintel_de_write(i915, HDCP_REP_CTL, rep_ctl | HDCP_SHA1_TEXT_32);\n\t \n\twhile ((sha_idx % 64) < (64 - sizeof(sha_text))) {\n\t\tret = intel_write_sha_text(i915, 0);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tsha_idx += sizeof(sha_text);\n\t}\n\n\t \n\tsha_text = (num_downstream * 5 + 10) * 8;\n\tret = intel_write_sha_text(i915, sha_text);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tintel_de_write(i915, HDCP_REP_CTL,\n\t\t       rep_ctl | HDCP_SHA1_COMPLETE_HASH);\n\tif (intel_de_wait_for_set(i915, HDCP_REP_CTL,\n\t\t\t\t  HDCP_SHA1_COMPLETE, 1)) {\n\t\tdrm_err(&i915->drm, \"Timed out waiting for SHA1 complete\\n\");\n\t\treturn -ETIMEDOUT;\n\t}\n\tif (!(intel_de_read(i915, HDCP_REP_CTL) & HDCP_SHA1_V_MATCH)) {\n\t\tdrm_dbg_kms(&i915->drm, \"SHA-1 mismatch, HDCP failed\\n\");\n\t\treturn -ENXIO;\n\t}\n\n\treturn 0;\n}\n\n \nstatic\nint intel_hdcp_auth_downstream(struct intel_connector *connector)\n{\n\tstruct intel_digital_port *dig_port = intel_attached_dig_port(connector);\n\tstruct drm_i915_private *i915 = to_i915(connector->base.dev);\n\tconst struct intel_hdcp_shim *shim = connector->hdcp.shim;\n\tu8 bstatus[2], num_downstream, *ksv_fifo;\n\tint ret, i, tries = 3;\n\n\tret = intel_hdcp_poll_ksv_fifo(dig_port, shim);\n\tif (ret) {\n\t\tdrm_dbg_kms(&i915->drm,\n\t\t\t    \"KSV list failed to become ready (%d)\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = shim->read_bstatus(dig_port, bstatus);\n\tif (ret)\n\t\treturn ret;\n\n\tif (DRM_HDCP_MAX_DEVICE_EXCEEDED(bstatus[0]) ||\n\t    DRM_HDCP_MAX_CASCADE_EXCEEDED(bstatus[1])) {\n\t\tdrm_dbg_kms(&i915->drm, \"Max Topology Limit Exceeded\\n\");\n\t\treturn -EPERM;\n\t}\n\n\t \n\tnum_downstream = DRM_HDCP_NUM_DOWNSTREAM(bstatus[0]);\n\tif (num_downstream == 0) {\n\t\tdrm_dbg_kms(&i915->drm,\n\t\t\t    \"Repeater with zero downstream devices\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tksv_fifo = kcalloc(DRM_HDCP_KSV_LEN, num_downstream, GFP_KERNEL);\n\tif (!ksv_fifo) {\n\t\tdrm_dbg_kms(&i915->drm, \"Out of mem: ksv_fifo\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tret = shim->read_ksv_fifo(dig_port, num_downstream, ksv_fifo);\n\tif (ret)\n\t\tgoto err;\n\n\tif (drm_hdcp_check_ksvs_revoked(&i915->drm, ksv_fifo,\n\t\t\t\t\tnum_downstream) > 0) {\n\t\tdrm_err(&i915->drm, \"Revoked Ksv(s) in ksv_fifo\\n\");\n\t\tret = -EPERM;\n\t\tgoto err;\n\t}\n\n\t \n\tfor (i = 0; i < tries; i++) {\n\t\tret = intel_hdcp_validate_v_prime(connector, shim,\n\t\t\t\t\t\t  ksv_fifo, num_downstream,\n\t\t\t\t\t\t  bstatus);\n\t\tif (!ret)\n\t\t\tbreak;\n\t}\n\n\tif (i == tries) {\n\t\tdrm_dbg_kms(&i915->drm,\n\t\t\t    \"V Prime validation failed.(%d)\\n\", ret);\n\t\tgoto err;\n\t}\n\n\tdrm_dbg_kms(&i915->drm, \"HDCP is enabled (%d downstream devices)\\n\",\n\t\t    num_downstream);\n\tret = 0;\nerr:\n\tkfree(ksv_fifo);\n\treturn ret;\n}\n\n \nstatic int intel_hdcp_auth(struct intel_connector *connector)\n{\n\tstruct intel_digital_port *dig_port = intel_attached_dig_port(connector);\n\tstruct drm_i915_private *i915 = to_i915(connector->base.dev);\n\tstruct intel_hdcp *hdcp = &connector->hdcp;\n\tconst struct intel_hdcp_shim *shim = hdcp->shim;\n\tenum transcoder cpu_transcoder = connector->hdcp.cpu_transcoder;\n\tenum port port = dig_port->base.port;\n\tunsigned long r0_prime_gen_start;\n\tint ret, i, tries = 2;\n\tunion {\n\t\tu32 reg[2];\n\t\tu8 shim[DRM_HDCP_AN_LEN];\n\t} an;\n\tunion {\n\t\tu32 reg[2];\n\t\tu8 shim[DRM_HDCP_KSV_LEN];\n\t} bksv;\n\tunion {\n\t\tu32 reg;\n\t\tu8 shim[DRM_HDCP_RI_LEN];\n\t} ri;\n\tbool repeater_present, hdcp_capable;\n\n\t \n\tif (shim->hdcp_capable) {\n\t\tret = shim->hdcp_capable(dig_port, &hdcp_capable);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tif (!hdcp_capable) {\n\t\t\tdrm_dbg_kms(&i915->drm,\n\t\t\t\t    \"Panel is not HDCP capable\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\t \n\tfor (i = 0; i < 2; i++)\n\t\tintel_de_write(i915,\n\t\t\t       HDCP_ANINIT(i915, cpu_transcoder, port),\n\t\t\t       get_random_u32());\n\tintel_de_write(i915, HDCP_CONF(i915, cpu_transcoder, port),\n\t\t       HDCP_CONF_CAPTURE_AN);\n\n\t \n\tif (intel_de_wait_for_set(i915,\n\t\t\t\t  HDCP_STATUS(i915, cpu_transcoder, port),\n\t\t\t\t  HDCP_STATUS_AN_READY, 1)) {\n\t\tdrm_err(&i915->drm, \"Timed out waiting for An\\n\");\n\t\treturn -ETIMEDOUT;\n\t}\n\n\tan.reg[0] = intel_de_read(i915,\n\t\t\t\t  HDCP_ANLO(i915, cpu_transcoder, port));\n\tan.reg[1] = intel_de_read(i915,\n\t\t\t\t  HDCP_ANHI(i915, cpu_transcoder, port));\n\tret = shim->write_an_aksv(dig_port, an.shim);\n\tif (ret)\n\t\treturn ret;\n\n\tr0_prime_gen_start = jiffies;\n\n\tmemset(&bksv, 0, sizeof(bksv));\n\n\tret = intel_hdcp_read_valid_bksv(dig_port, shim, bksv.shim);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (drm_hdcp_check_ksvs_revoked(&i915->drm, bksv.shim, 1) > 0) {\n\t\tdrm_err(&i915->drm, \"BKSV is revoked\\n\");\n\t\treturn -EPERM;\n\t}\n\n\tintel_de_write(i915, HDCP_BKSVLO(i915, cpu_transcoder, port),\n\t\t       bksv.reg[0]);\n\tintel_de_write(i915, HDCP_BKSVHI(i915, cpu_transcoder, port),\n\t\t       bksv.reg[1]);\n\n\tret = shim->repeater_present(dig_port, &repeater_present);\n\tif (ret)\n\t\treturn ret;\n\tif (repeater_present)\n\t\tintel_de_write(i915, HDCP_REP_CTL,\n\t\t\t       intel_hdcp_get_repeater_ctl(i915, cpu_transcoder, port));\n\n\tret = shim->toggle_signalling(dig_port, cpu_transcoder, true);\n\tif (ret)\n\t\treturn ret;\n\n\tintel_de_write(i915, HDCP_CONF(i915, cpu_transcoder, port),\n\t\t       HDCP_CONF_AUTH_AND_ENC);\n\n\t \n\tif (wait_for(intel_de_read(i915, HDCP_STATUS(i915, cpu_transcoder, port)) &\n\t\t     (HDCP_STATUS_R0_READY | HDCP_STATUS_ENC), 1)) {\n\t\tdrm_err(&i915->drm, \"Timed out waiting for R0 ready\\n\");\n\t\treturn -ETIMEDOUT;\n\t}\n\n\t \n\twait_remaining_ms_from_jiffies(r0_prime_gen_start, 300);\n\n\ttries = 3;\n\n\t \n\tfor (i = 0; i < tries; i++) {\n\t\tri.reg = 0;\n\t\tret = shim->read_ri_prime(dig_port, ri.shim);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tintel_de_write(i915,\n\t\t\t       HDCP_RPRIME(i915, cpu_transcoder, port),\n\t\t\t       ri.reg);\n\n\t\t \n\t\tif (!wait_for(intel_de_read(i915, HDCP_STATUS(i915, cpu_transcoder, port)) &\n\t\t\t      (HDCP_STATUS_RI_MATCH | HDCP_STATUS_ENC), 1))\n\t\t\tbreak;\n\t}\n\n\tif (i == tries) {\n\t\tdrm_dbg_kms(&i915->drm,\n\t\t\t    \"Timed out waiting for Ri prime match (%x)\\n\",\n\t\t\t    intel_de_read(i915,\n\t\t\t\t\t  HDCP_STATUS(i915, cpu_transcoder, port)));\n\t\treturn -ETIMEDOUT;\n\t}\n\n\t \n\tif (intel_de_wait_for_set(i915,\n\t\t\t\t  HDCP_STATUS(i915, cpu_transcoder, port),\n\t\t\t\t  HDCP_STATUS_ENC,\n\t\t\t\t  HDCP_ENCRYPT_STATUS_CHANGE_TIMEOUT_MS)) {\n\t\tdrm_err(&i915->drm, \"Timed out waiting for encryption\\n\");\n\t\treturn -ETIMEDOUT;\n\t}\n\n\t \n\tif (shim->stream_encryption) {\n\t\tret = shim->stream_encryption(connector, true);\n\t\tif (ret) {\n\t\t\tdrm_err(&i915->drm, \"[%s:%d] Failed to enable HDCP 1.4 stream enc\\n\",\n\t\t\t\tconnector->base.name, connector->base.base.id);\n\t\t\treturn ret;\n\t\t}\n\t\tdrm_dbg_kms(&i915->drm, \"HDCP 1.4 transcoder: %s stream encrypted\\n\",\n\t\t\t    transcoder_name(hdcp->stream_transcoder));\n\t}\n\n\tif (repeater_present)\n\t\treturn intel_hdcp_auth_downstream(connector);\n\n\tdrm_dbg_kms(&i915->drm, \"HDCP is enabled (no repeater present)\\n\");\n\treturn 0;\n}\n\nstatic int _intel_hdcp_disable(struct intel_connector *connector)\n{\n\tstruct intel_digital_port *dig_port = intel_attached_dig_port(connector);\n\tstruct drm_i915_private *i915 = to_i915(connector->base.dev);\n\tstruct intel_hdcp *hdcp = &connector->hdcp;\n\tenum port port = dig_port->base.port;\n\tenum transcoder cpu_transcoder = hdcp->cpu_transcoder;\n\tu32 repeater_ctl;\n\tint ret;\n\n\tdrm_dbg_kms(&i915->drm, \"[%s:%d] HDCP is being disabled...\\n\",\n\t\t    connector->base.name, connector->base.base.id);\n\n\tif (hdcp->shim->stream_encryption) {\n\t\tret = hdcp->shim->stream_encryption(connector, false);\n\t\tif (ret) {\n\t\t\tdrm_err(&i915->drm, \"[%s:%d] Failed to disable HDCP 1.4 stream enc\\n\",\n\t\t\t\tconnector->base.name, connector->base.base.id);\n\t\t\treturn ret;\n\t\t}\n\t\tdrm_dbg_kms(&i915->drm, \"HDCP 1.4 transcoder: %s stream encryption disabled\\n\",\n\t\t\t    transcoder_name(hdcp->stream_transcoder));\n\t\t \n\t\tif (dig_port->num_hdcp_streams > 0)\n\t\t\treturn 0;\n\t}\n\n\thdcp->hdcp_encrypted = false;\n\tintel_de_write(i915, HDCP_CONF(i915, cpu_transcoder, port), 0);\n\tif (intel_de_wait_for_clear(i915,\n\t\t\t\t    HDCP_STATUS(i915, cpu_transcoder, port),\n\t\t\t\t    ~0, HDCP_ENCRYPT_STATUS_CHANGE_TIMEOUT_MS)) {\n\t\tdrm_err(&i915->drm,\n\t\t\t\"Failed to disable HDCP, timeout clearing status\\n\");\n\t\treturn -ETIMEDOUT;\n\t}\n\n\trepeater_ctl = intel_hdcp_get_repeater_ctl(i915, cpu_transcoder,\n\t\t\t\t\t\t   port);\n\tintel_de_rmw(i915, HDCP_REP_CTL, repeater_ctl, 0);\n\n\tret = hdcp->shim->toggle_signalling(dig_port, cpu_transcoder, false);\n\tif (ret) {\n\t\tdrm_err(&i915->drm, \"Failed to disable HDCP signalling\\n\");\n\t\treturn ret;\n\t}\n\n\tdrm_dbg_kms(&i915->drm, \"HDCP is disabled\\n\");\n\treturn 0;\n}\n\nstatic int _intel_hdcp_enable(struct intel_connector *connector)\n{\n\tstruct drm_i915_private *i915 = to_i915(connector->base.dev);\n\tstruct intel_hdcp *hdcp = &connector->hdcp;\n\tint i, ret, tries = 3;\n\n\tdrm_dbg_kms(&i915->drm, \"[%s:%d] HDCP is being enabled...\\n\",\n\t\t    connector->base.name, connector->base.base.id);\n\n\tif (!hdcp_key_loadable(i915)) {\n\t\tdrm_err(&i915->drm, \"HDCP key Load is not possible\\n\");\n\t\treturn -ENXIO;\n\t}\n\n\tfor (i = 0; i < KEY_LOAD_TRIES; i++) {\n\t\tret = intel_hdcp_load_keys(i915);\n\t\tif (!ret)\n\t\t\tbreak;\n\t\tintel_hdcp_clear_keys(i915);\n\t}\n\tif (ret) {\n\t\tdrm_err(&i915->drm, \"Could not load HDCP keys, (%d)\\n\",\n\t\t\tret);\n\t\treturn ret;\n\t}\n\n\t \n\tfor (i = 0; i < tries; i++) {\n\t\tret = intel_hdcp_auth(connector);\n\t\tif (!ret) {\n\t\t\thdcp->hdcp_encrypted = true;\n\t\t\treturn 0;\n\t\t}\n\n\t\tdrm_dbg_kms(&i915->drm, \"HDCP Auth failure (%d)\\n\", ret);\n\n\t\t \n\t\t_intel_hdcp_disable(connector);\n\t}\n\n\tdrm_dbg_kms(&i915->drm,\n\t\t    \"HDCP authentication failed (%d tries/%d)\\n\", tries, ret);\n\treturn ret;\n}\n\nstatic struct intel_connector *intel_hdcp_to_connector(struct intel_hdcp *hdcp)\n{\n\treturn container_of(hdcp, struct intel_connector, hdcp);\n}\n\nstatic void intel_hdcp_update_value(struct intel_connector *connector,\n\t\t\t\t    u64 value, bool update_property)\n{\n\tstruct drm_device *dev = connector->base.dev;\n\tstruct intel_digital_port *dig_port = intel_attached_dig_port(connector);\n\tstruct intel_hdcp *hdcp = &connector->hdcp;\n\tstruct drm_i915_private *i915 = to_i915(connector->base.dev);\n\n\tdrm_WARN_ON(connector->base.dev, !mutex_is_locked(&hdcp->mutex));\n\n\tif (hdcp->value == value)\n\t\treturn;\n\n\tdrm_WARN_ON(dev, !mutex_is_locked(&dig_port->hdcp_mutex));\n\n\tif (hdcp->value == DRM_MODE_CONTENT_PROTECTION_ENABLED) {\n\t\tif (!drm_WARN_ON(dev, dig_port->num_hdcp_streams == 0))\n\t\t\tdig_port->num_hdcp_streams--;\n\t} else if (value == DRM_MODE_CONTENT_PROTECTION_ENABLED) {\n\t\tdig_port->num_hdcp_streams++;\n\t}\n\n\thdcp->value = value;\n\tif (update_property) {\n\t\tdrm_connector_get(&connector->base);\n\t\tqueue_work(i915->unordered_wq, &hdcp->prop_work);\n\t}\n}\n\n \nstatic int intel_hdcp_check_link(struct intel_connector *connector)\n{\n\tstruct intel_digital_port *dig_port = intel_attached_dig_port(connector);\n\tstruct drm_i915_private *i915 = to_i915(connector->base.dev);\n\tstruct intel_hdcp *hdcp = &connector->hdcp;\n\tenum port port = dig_port->base.port;\n\tenum transcoder cpu_transcoder;\n\tint ret = 0;\n\n\tmutex_lock(&hdcp->mutex);\n\tmutex_lock(&dig_port->hdcp_mutex);\n\n\tcpu_transcoder = hdcp->cpu_transcoder;\n\n\t \n\tif (hdcp->value != DRM_MODE_CONTENT_PROTECTION_ENABLED ||\n\t    !hdcp->hdcp_encrypted) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tif (drm_WARN_ON(&i915->drm,\n\t\t\t!intel_hdcp_in_use(i915, cpu_transcoder, port))) {\n\t\tdrm_err(&i915->drm,\n\t\t\t\"%s:%d HDCP link stopped encryption,%x\\n\",\n\t\t\tconnector->base.name, connector->base.base.id,\n\t\t\tintel_de_read(i915, HDCP_STATUS(i915, cpu_transcoder, port)));\n\t\tret = -ENXIO;\n\t\tintel_hdcp_update_value(connector,\n\t\t\t\t\tDRM_MODE_CONTENT_PROTECTION_DESIRED,\n\t\t\t\t\ttrue);\n\t\tgoto out;\n\t}\n\n\tif (hdcp->shim->check_link(dig_port, connector)) {\n\t\tif (hdcp->value != DRM_MODE_CONTENT_PROTECTION_UNDESIRED) {\n\t\t\tintel_hdcp_update_value(connector,\n\t\t\t\tDRM_MODE_CONTENT_PROTECTION_ENABLED, true);\n\t\t}\n\t\tgoto out;\n\t}\n\n\tdrm_dbg_kms(&i915->drm,\n\t\t    \"[%s:%d] HDCP link failed, retrying authentication\\n\",\n\t\t    connector->base.name, connector->base.base.id);\n\n\tret = _intel_hdcp_disable(connector);\n\tif (ret) {\n\t\tdrm_err(&i915->drm, \"Failed to disable hdcp (%d)\\n\", ret);\n\t\tintel_hdcp_update_value(connector,\n\t\t\t\t\tDRM_MODE_CONTENT_PROTECTION_DESIRED,\n\t\t\t\t\ttrue);\n\t\tgoto out;\n\t}\n\n\tret = _intel_hdcp_enable(connector);\n\tif (ret) {\n\t\tdrm_err(&i915->drm, \"Failed to enable hdcp (%d)\\n\", ret);\n\t\tintel_hdcp_update_value(connector,\n\t\t\t\t\tDRM_MODE_CONTENT_PROTECTION_DESIRED,\n\t\t\t\t\ttrue);\n\t\tgoto out;\n\t}\n\nout:\n\tmutex_unlock(&dig_port->hdcp_mutex);\n\tmutex_unlock(&hdcp->mutex);\n\treturn ret;\n}\n\nstatic void intel_hdcp_prop_work(struct work_struct *work)\n{\n\tstruct intel_hdcp *hdcp = container_of(work, struct intel_hdcp,\n\t\t\t\t\t       prop_work);\n\tstruct intel_connector *connector = intel_hdcp_to_connector(hdcp);\n\tstruct drm_i915_private *i915 = to_i915(connector->base.dev);\n\n\tdrm_modeset_lock(&i915->drm.mode_config.connection_mutex, NULL);\n\tmutex_lock(&hdcp->mutex);\n\n\t \n\tif (hdcp->value != DRM_MODE_CONTENT_PROTECTION_UNDESIRED)\n\t\tdrm_hdcp_update_content_protection(&connector->base,\n\t\t\t\t\t\t   hdcp->value);\n\n\tmutex_unlock(&hdcp->mutex);\n\tdrm_modeset_unlock(&i915->drm.mode_config.connection_mutex);\n\n\tdrm_connector_put(&connector->base);\n}\n\nbool is_hdcp_supported(struct drm_i915_private *i915, enum port port)\n{\n\treturn DISPLAY_RUNTIME_INFO(i915)->has_hdcp &&\n\t\t(DISPLAY_VER(i915) >= 12 || port < PORT_E);\n}\n\nstatic int\nhdcp2_prepare_ake_init(struct intel_connector *connector,\n\t\t       struct hdcp2_ake_init *ake_data)\n{\n\tstruct intel_digital_port *dig_port = intel_attached_dig_port(connector);\n\tstruct hdcp_port_data *data = &dig_port->hdcp_port_data;\n\tstruct drm_i915_private *i915 = to_i915(connector->base.dev);\n\tstruct i915_hdcp_arbiter *arbiter;\n\tint ret;\n\n\tmutex_lock(&i915->display.hdcp.hdcp_mutex);\n\tarbiter = i915->display.hdcp.arbiter;\n\n\tif (!arbiter || !arbiter->ops) {\n\t\tmutex_unlock(&i915->display.hdcp.hdcp_mutex);\n\t\treturn -EINVAL;\n\t}\n\n\tret = arbiter->ops->initiate_hdcp2_session(arbiter->hdcp_dev, data, ake_data);\n\tif (ret)\n\t\tdrm_dbg_kms(&i915->drm, \"Prepare_ake_init failed. %d\\n\",\n\t\t\t    ret);\n\tmutex_unlock(&i915->display.hdcp.hdcp_mutex);\n\n\treturn ret;\n}\n\nstatic int\nhdcp2_verify_rx_cert_prepare_km(struct intel_connector *connector,\n\t\t\t\tstruct hdcp2_ake_send_cert *rx_cert,\n\t\t\t\tbool *paired,\n\t\t\t\tstruct hdcp2_ake_no_stored_km *ek_pub_km,\n\t\t\t\tsize_t *msg_sz)\n{\n\tstruct intel_digital_port *dig_port = intel_attached_dig_port(connector);\n\tstruct hdcp_port_data *data = &dig_port->hdcp_port_data;\n\tstruct drm_i915_private *i915 = to_i915(connector->base.dev);\n\tstruct i915_hdcp_arbiter *arbiter;\n\tint ret;\n\n\tmutex_lock(&i915->display.hdcp.hdcp_mutex);\n\tarbiter = i915->display.hdcp.arbiter;\n\n\tif (!arbiter || !arbiter->ops) {\n\t\tmutex_unlock(&i915->display.hdcp.hdcp_mutex);\n\t\treturn -EINVAL;\n\t}\n\n\tret = arbiter->ops->verify_receiver_cert_prepare_km(arbiter->hdcp_dev, data,\n\t\t\t\t\t\t\t rx_cert, paired,\n\t\t\t\t\t\t\t ek_pub_km, msg_sz);\n\tif (ret < 0)\n\t\tdrm_dbg_kms(&i915->drm, \"Verify rx_cert failed. %d\\n\",\n\t\t\t    ret);\n\tmutex_unlock(&i915->display.hdcp.hdcp_mutex);\n\n\treturn ret;\n}\n\nstatic int hdcp2_verify_hprime(struct intel_connector *connector,\n\t\t\t       struct hdcp2_ake_send_hprime *rx_hprime)\n{\n\tstruct intel_digital_port *dig_port = intel_attached_dig_port(connector);\n\tstruct hdcp_port_data *data = &dig_port->hdcp_port_data;\n\tstruct drm_i915_private *i915 = to_i915(connector->base.dev);\n\tstruct i915_hdcp_arbiter *arbiter;\n\tint ret;\n\n\tmutex_lock(&i915->display.hdcp.hdcp_mutex);\n\tarbiter = i915->display.hdcp.arbiter;\n\n\tif (!arbiter || !arbiter->ops) {\n\t\tmutex_unlock(&i915->display.hdcp.hdcp_mutex);\n\t\treturn -EINVAL;\n\t}\n\n\tret = arbiter->ops->verify_hprime(arbiter->hdcp_dev, data, rx_hprime);\n\tif (ret < 0)\n\t\tdrm_dbg_kms(&i915->drm, \"Verify hprime failed. %d\\n\", ret);\n\tmutex_unlock(&i915->display.hdcp.hdcp_mutex);\n\n\treturn ret;\n}\n\nstatic int\nhdcp2_store_pairing_info(struct intel_connector *connector,\n\t\t\t struct hdcp2_ake_send_pairing_info *pairing_info)\n{\n\tstruct intel_digital_port *dig_port = intel_attached_dig_port(connector);\n\tstruct hdcp_port_data *data = &dig_port->hdcp_port_data;\n\tstruct drm_i915_private *i915 = to_i915(connector->base.dev);\n\tstruct i915_hdcp_arbiter *arbiter;\n\tint ret;\n\n\tmutex_lock(&i915->display.hdcp.hdcp_mutex);\n\tarbiter = i915->display.hdcp.arbiter;\n\n\tif (!arbiter || !arbiter->ops) {\n\t\tmutex_unlock(&i915->display.hdcp.hdcp_mutex);\n\t\treturn -EINVAL;\n\t}\n\n\tret = arbiter->ops->store_pairing_info(arbiter->hdcp_dev, data, pairing_info);\n\tif (ret < 0)\n\t\tdrm_dbg_kms(&i915->drm, \"Store pairing info failed. %d\\n\",\n\t\t\t    ret);\n\tmutex_unlock(&i915->display.hdcp.hdcp_mutex);\n\n\treturn ret;\n}\n\nstatic int\nhdcp2_prepare_lc_init(struct intel_connector *connector,\n\t\t      struct hdcp2_lc_init *lc_init)\n{\n\tstruct intel_digital_port *dig_port = intel_attached_dig_port(connector);\n\tstruct hdcp_port_data *data = &dig_port->hdcp_port_data;\n\tstruct drm_i915_private *i915 = to_i915(connector->base.dev);\n\tstruct i915_hdcp_arbiter *arbiter;\n\tint ret;\n\n\tmutex_lock(&i915->display.hdcp.hdcp_mutex);\n\tarbiter = i915->display.hdcp.arbiter;\n\n\tif (!arbiter || !arbiter->ops) {\n\t\tmutex_unlock(&i915->display.hdcp.hdcp_mutex);\n\t\treturn -EINVAL;\n\t}\n\n\tret = arbiter->ops->initiate_locality_check(arbiter->hdcp_dev, data, lc_init);\n\tif (ret < 0)\n\t\tdrm_dbg_kms(&i915->drm, \"Prepare lc_init failed. %d\\n\",\n\t\t\t    ret);\n\tmutex_unlock(&i915->display.hdcp.hdcp_mutex);\n\n\treturn ret;\n}\n\nstatic int\nhdcp2_verify_lprime(struct intel_connector *connector,\n\t\t    struct hdcp2_lc_send_lprime *rx_lprime)\n{\n\tstruct intel_digital_port *dig_port = intel_attached_dig_port(connector);\n\tstruct hdcp_port_data *data = &dig_port->hdcp_port_data;\n\tstruct drm_i915_private *i915 = to_i915(connector->base.dev);\n\tstruct i915_hdcp_arbiter *arbiter;\n\tint ret;\n\n\tmutex_lock(&i915->display.hdcp.hdcp_mutex);\n\tarbiter = i915->display.hdcp.arbiter;\n\n\tif (!arbiter || !arbiter->ops) {\n\t\tmutex_unlock(&i915->display.hdcp.hdcp_mutex);\n\t\treturn -EINVAL;\n\t}\n\n\tret = arbiter->ops->verify_lprime(arbiter->hdcp_dev, data, rx_lprime);\n\tif (ret < 0)\n\t\tdrm_dbg_kms(&i915->drm, \"Verify L_Prime failed. %d\\n\",\n\t\t\t    ret);\n\tmutex_unlock(&i915->display.hdcp.hdcp_mutex);\n\n\treturn ret;\n}\n\nstatic int hdcp2_prepare_skey(struct intel_connector *connector,\n\t\t\t      struct hdcp2_ske_send_eks *ske_data)\n{\n\tstruct intel_digital_port *dig_port = intel_attached_dig_port(connector);\n\tstruct hdcp_port_data *data = &dig_port->hdcp_port_data;\n\tstruct drm_i915_private *i915 = to_i915(connector->base.dev);\n\tstruct i915_hdcp_arbiter *arbiter;\n\tint ret;\n\n\tmutex_lock(&i915->display.hdcp.hdcp_mutex);\n\tarbiter = i915->display.hdcp.arbiter;\n\n\tif (!arbiter || !arbiter->ops) {\n\t\tmutex_unlock(&i915->display.hdcp.hdcp_mutex);\n\t\treturn -EINVAL;\n\t}\n\n\tret = arbiter->ops->get_session_key(arbiter->hdcp_dev, data, ske_data);\n\tif (ret < 0)\n\t\tdrm_dbg_kms(&i915->drm, \"Get session key failed. %d\\n\",\n\t\t\t    ret);\n\tmutex_unlock(&i915->display.hdcp.hdcp_mutex);\n\n\treturn ret;\n}\n\nstatic int\nhdcp2_verify_rep_topology_prepare_ack(struct intel_connector *connector,\n\t\t\t\t      struct hdcp2_rep_send_receiverid_list\n\t\t\t\t\t\t\t\t*rep_topology,\n\t\t\t\t      struct hdcp2_rep_send_ack *rep_send_ack)\n{\n\tstruct intel_digital_port *dig_port = intel_attached_dig_port(connector);\n\tstruct hdcp_port_data *data = &dig_port->hdcp_port_data;\n\tstruct drm_i915_private *i915 = to_i915(connector->base.dev);\n\tstruct i915_hdcp_arbiter *arbiter;\n\tint ret;\n\n\tmutex_lock(&i915->display.hdcp.hdcp_mutex);\n\tarbiter = i915->display.hdcp.arbiter;\n\n\tif (!arbiter || !arbiter->ops) {\n\t\tmutex_unlock(&i915->display.hdcp.hdcp_mutex);\n\t\treturn -EINVAL;\n\t}\n\n\tret = arbiter->ops->repeater_check_flow_prepare_ack(arbiter->hdcp_dev,\n\t\t\t\t\t\t\t    data,\n\t\t\t\t\t\t\t    rep_topology,\n\t\t\t\t\t\t\t    rep_send_ack);\n\tif (ret < 0)\n\t\tdrm_dbg_kms(&i915->drm,\n\t\t\t    \"Verify rep topology failed. %d\\n\", ret);\n\tmutex_unlock(&i915->display.hdcp.hdcp_mutex);\n\n\treturn ret;\n}\n\nstatic int\nhdcp2_verify_mprime(struct intel_connector *connector,\n\t\t    struct hdcp2_rep_stream_ready *stream_ready)\n{\n\tstruct intel_digital_port *dig_port = intel_attached_dig_port(connector);\n\tstruct hdcp_port_data *data = &dig_port->hdcp_port_data;\n\tstruct drm_i915_private *i915 = to_i915(connector->base.dev);\n\tstruct i915_hdcp_arbiter *arbiter;\n\tint ret;\n\n\tmutex_lock(&i915->display.hdcp.hdcp_mutex);\n\tarbiter = i915->display.hdcp.arbiter;\n\n\tif (!arbiter || !arbiter->ops) {\n\t\tmutex_unlock(&i915->display.hdcp.hdcp_mutex);\n\t\treturn -EINVAL;\n\t}\n\n\tret = arbiter->ops->verify_mprime(arbiter->hdcp_dev, data, stream_ready);\n\tif (ret < 0)\n\t\tdrm_dbg_kms(&i915->drm, \"Verify mprime failed. %d\\n\", ret);\n\tmutex_unlock(&i915->display.hdcp.hdcp_mutex);\n\n\treturn ret;\n}\n\nstatic int hdcp2_authenticate_port(struct intel_connector *connector)\n{\n\tstruct intel_digital_port *dig_port = intel_attached_dig_port(connector);\n\tstruct hdcp_port_data *data = &dig_port->hdcp_port_data;\n\tstruct drm_i915_private *i915 = to_i915(connector->base.dev);\n\tstruct i915_hdcp_arbiter *arbiter;\n\tint ret;\n\n\tmutex_lock(&i915->display.hdcp.hdcp_mutex);\n\tarbiter = i915->display.hdcp.arbiter;\n\n\tif (!arbiter || !arbiter->ops) {\n\t\tmutex_unlock(&i915->display.hdcp.hdcp_mutex);\n\t\treturn -EINVAL;\n\t}\n\n\tret = arbiter->ops->enable_hdcp_authentication(arbiter->hdcp_dev, data);\n\tif (ret < 0)\n\t\tdrm_dbg_kms(&i915->drm, \"Enable hdcp auth failed. %d\\n\",\n\t\t\t    ret);\n\tmutex_unlock(&i915->display.hdcp.hdcp_mutex);\n\n\treturn ret;\n}\n\nstatic int hdcp2_close_session(struct intel_connector *connector)\n{\n\tstruct intel_digital_port *dig_port = intel_attached_dig_port(connector);\n\tstruct drm_i915_private *i915 = to_i915(connector->base.dev);\n\tstruct i915_hdcp_arbiter *arbiter;\n\tint ret;\n\n\tmutex_lock(&i915->display.hdcp.hdcp_mutex);\n\tarbiter = i915->display.hdcp.arbiter;\n\n\tif (!arbiter || !arbiter->ops) {\n\t\tmutex_unlock(&i915->display.hdcp.hdcp_mutex);\n\t\treturn -EINVAL;\n\t}\n\n\tret = arbiter->ops->close_hdcp_session(arbiter->hdcp_dev,\n\t\t\t\t\t     &dig_port->hdcp_port_data);\n\tmutex_unlock(&i915->display.hdcp.hdcp_mutex);\n\n\treturn ret;\n}\n\nstatic int hdcp2_deauthenticate_port(struct intel_connector *connector)\n{\n\treturn hdcp2_close_session(connector);\n}\n\n \nstatic int hdcp2_authentication_key_exchange(struct intel_connector *connector)\n{\n\tstruct intel_digital_port *dig_port = intel_attached_dig_port(connector);\n\tstruct drm_i915_private *i915 = to_i915(connector->base.dev);\n\tstruct intel_hdcp *hdcp = &connector->hdcp;\n\tunion {\n\t\tstruct hdcp2_ake_init ake_init;\n\t\tstruct hdcp2_ake_send_cert send_cert;\n\t\tstruct hdcp2_ake_no_stored_km no_stored_km;\n\t\tstruct hdcp2_ake_send_hprime send_hprime;\n\t\tstruct hdcp2_ake_send_pairing_info pairing_info;\n\t} msgs;\n\tconst struct intel_hdcp_shim *shim = hdcp->shim;\n\tsize_t size;\n\tint ret;\n\n\t \n\thdcp->seq_num_v = 0;\n\thdcp->seq_num_m = 0;\n\n\tret = hdcp2_prepare_ake_init(connector, &msgs.ake_init);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = shim->write_2_2_msg(dig_port, &msgs.ake_init,\n\t\t\t\t  sizeof(msgs.ake_init));\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = shim->read_2_2_msg(dig_port, HDCP_2_2_AKE_SEND_CERT,\n\t\t\t\t &msgs.send_cert, sizeof(msgs.send_cert));\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (msgs.send_cert.rx_caps[0] != HDCP_2_2_RX_CAPS_VERSION_VAL) {\n\t\tdrm_dbg_kms(&i915->drm, \"cert.rx_caps dont claim HDCP2.2\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\thdcp->is_repeater = HDCP_2_2_RX_REPEATER(msgs.send_cert.rx_caps[2]);\n\n\tif (drm_hdcp_check_ksvs_revoked(&i915->drm,\n\t\t\t\t\tmsgs.send_cert.cert_rx.receiver_id,\n\t\t\t\t\t1) > 0) {\n\t\tdrm_err(&i915->drm, \"Receiver ID is revoked\\n\");\n\t\treturn -EPERM;\n\t}\n\n\t \n\tret = hdcp2_verify_rx_cert_prepare_km(connector, &msgs.send_cert,\n\t\t\t\t\t      &hdcp->is_paired,\n\t\t\t\t\t      &msgs.no_stored_km, &size);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = shim->write_2_2_msg(dig_port, &msgs.no_stored_km, size);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = shim->read_2_2_msg(dig_port, HDCP_2_2_AKE_SEND_HPRIME,\n\t\t\t\t &msgs.send_hprime, sizeof(msgs.send_hprime));\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = hdcp2_verify_hprime(connector, &msgs.send_hprime);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (!hdcp->is_paired) {\n\t\t \n\t\tret = shim->read_2_2_msg(dig_port,\n\t\t\t\t\t HDCP_2_2_AKE_SEND_PAIRING_INFO,\n\t\t\t\t\t &msgs.pairing_info,\n\t\t\t\t\t sizeof(msgs.pairing_info));\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tret = hdcp2_store_pairing_info(connector, &msgs.pairing_info);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\thdcp->is_paired = true;\n\t}\n\n\treturn 0;\n}\n\nstatic int hdcp2_locality_check(struct intel_connector *connector)\n{\n\tstruct intel_digital_port *dig_port = intel_attached_dig_port(connector);\n\tstruct intel_hdcp *hdcp = &connector->hdcp;\n\tunion {\n\t\tstruct hdcp2_lc_init lc_init;\n\t\tstruct hdcp2_lc_send_lprime send_lprime;\n\t} msgs;\n\tconst struct intel_hdcp_shim *shim = hdcp->shim;\n\tint tries = HDCP2_LC_RETRY_CNT, ret, i;\n\n\tfor (i = 0; i < tries; i++) {\n\t\tret = hdcp2_prepare_lc_init(connector, &msgs.lc_init);\n\t\tif (ret < 0)\n\t\t\tcontinue;\n\n\t\tret = shim->write_2_2_msg(dig_port, &msgs.lc_init,\n\t\t\t\t      sizeof(msgs.lc_init));\n\t\tif (ret < 0)\n\t\t\tcontinue;\n\n\t\tret = shim->read_2_2_msg(dig_port,\n\t\t\t\t\t HDCP_2_2_LC_SEND_LPRIME,\n\t\t\t\t\t &msgs.send_lprime,\n\t\t\t\t\t sizeof(msgs.send_lprime));\n\t\tif (ret < 0)\n\t\t\tcontinue;\n\n\t\tret = hdcp2_verify_lprime(connector, &msgs.send_lprime);\n\t\tif (!ret)\n\t\t\tbreak;\n\t}\n\n\treturn ret;\n}\n\nstatic int hdcp2_session_key_exchange(struct intel_connector *connector)\n{\n\tstruct intel_digital_port *dig_port = intel_attached_dig_port(connector);\n\tstruct intel_hdcp *hdcp = &connector->hdcp;\n\tstruct hdcp2_ske_send_eks send_eks;\n\tint ret;\n\n\tret = hdcp2_prepare_skey(connector, &send_eks);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = hdcp->shim->write_2_2_msg(dig_port, &send_eks,\n\t\t\t\t\tsizeof(send_eks));\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn 0;\n}\n\nstatic\nint _hdcp2_propagate_stream_management_info(struct intel_connector *connector)\n{\n\tstruct intel_digital_port *dig_port = intel_attached_dig_port(connector);\n\tstruct hdcp_port_data *data = &dig_port->hdcp_port_data;\n\tstruct intel_hdcp *hdcp = &connector->hdcp;\n\tunion {\n\t\tstruct hdcp2_rep_stream_manage stream_manage;\n\t\tstruct hdcp2_rep_stream_ready stream_ready;\n\t} msgs;\n\tconst struct intel_hdcp_shim *shim = hdcp->shim;\n\tint ret, streams_size_delta, i;\n\n\tif (connector->hdcp.seq_num_m > HDCP_2_2_SEQ_NUM_MAX)\n\t\treturn -ERANGE;\n\n\t \n\tmsgs.stream_manage.msg_id = HDCP_2_2_REP_STREAM_MANAGE;\n\tdrm_hdcp_cpu_to_be24(msgs.stream_manage.seq_num_m, hdcp->seq_num_m);\n\n\tmsgs.stream_manage.k = cpu_to_be16(data->k);\n\n\tfor (i = 0; i < data->k; i++) {\n\t\tmsgs.stream_manage.streams[i].stream_id = data->streams[i].stream_id;\n\t\tmsgs.stream_manage.streams[i].stream_type = data->streams[i].stream_type;\n\t}\n\n\tstreams_size_delta = (HDCP_2_2_MAX_CONTENT_STREAMS_CNT - data->k) *\n\t\t\t\tsizeof(struct hdcp2_streamid_type);\n\t \n\tret = shim->write_2_2_msg(dig_port, &msgs.stream_manage,\n\t\t\t\t  sizeof(msgs.stream_manage) - streams_size_delta);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tret = shim->read_2_2_msg(dig_port, HDCP_2_2_REP_STREAM_READY,\n\t\t\t\t &msgs.stream_ready, sizeof(msgs.stream_ready));\n\tif (ret < 0)\n\t\tgoto out;\n\n\tdata->seq_num_m = hdcp->seq_num_m;\n\n\tret = hdcp2_verify_mprime(connector, &msgs.stream_ready);\n\nout:\n\thdcp->seq_num_m++;\n\n\treturn ret;\n}\n\nstatic\nint hdcp2_authenticate_repeater_topology(struct intel_connector *connector)\n{\n\tstruct intel_digital_port *dig_port = intel_attached_dig_port(connector);\n\tstruct drm_i915_private *i915 = to_i915(connector->base.dev);\n\tstruct intel_hdcp *hdcp = &connector->hdcp;\n\tunion {\n\t\tstruct hdcp2_rep_send_receiverid_list recvid_list;\n\t\tstruct hdcp2_rep_send_ack rep_ack;\n\t} msgs;\n\tconst struct intel_hdcp_shim *shim = hdcp->shim;\n\tu32 seq_num_v, device_cnt;\n\tu8 *rx_info;\n\tint ret;\n\n\tret = shim->read_2_2_msg(dig_port, HDCP_2_2_REP_SEND_RECVID_LIST,\n\t\t\t\t &msgs.recvid_list, sizeof(msgs.recvid_list));\n\tif (ret < 0)\n\t\treturn ret;\n\n\trx_info = msgs.recvid_list.rx_info;\n\n\tif (HDCP_2_2_MAX_CASCADE_EXCEEDED(rx_info[1]) ||\n\t    HDCP_2_2_MAX_DEVS_EXCEEDED(rx_info[1])) {\n\t\tdrm_dbg_kms(&i915->drm, \"Topology Max Size Exceeded\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tdig_port->hdcp_mst_type1_capable =\n\t\t!HDCP_2_2_HDCP1_DEVICE_CONNECTED(rx_info[1]) &&\n\t\t!HDCP_2_2_HDCP_2_0_REP_CONNECTED(rx_info[1]);\n\n\t \n\tseq_num_v =\n\t\tdrm_hdcp_be24_to_cpu((const u8 *)msgs.recvid_list.seq_num_v);\n\n\tif (!hdcp->hdcp2_encrypted && seq_num_v) {\n\t\tdrm_dbg_kms(&i915->drm,\n\t\t\t    \"Non zero Seq_num_v at first RecvId_List msg\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (seq_num_v < hdcp->seq_num_v) {\n\t\t \n\t\tdrm_dbg_kms(&i915->drm, \"Seq_num_v roll over.\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tdevice_cnt = (HDCP_2_2_DEV_COUNT_HI(rx_info[0]) << 4 |\n\t\t      HDCP_2_2_DEV_COUNT_LO(rx_info[1]));\n\tif (drm_hdcp_check_ksvs_revoked(&i915->drm,\n\t\t\t\t\tmsgs.recvid_list.receiver_ids,\n\t\t\t\t\tdevice_cnt) > 0) {\n\t\tdrm_err(&i915->drm, \"Revoked receiver ID(s) is in list\\n\");\n\t\treturn -EPERM;\n\t}\n\n\tret = hdcp2_verify_rep_topology_prepare_ack(connector,\n\t\t\t\t\t\t    &msgs.recvid_list,\n\t\t\t\t\t\t    &msgs.rep_ack);\n\tif (ret < 0)\n\t\treturn ret;\n\n\thdcp->seq_num_v = seq_num_v;\n\tret = shim->write_2_2_msg(dig_port, &msgs.rep_ack,\n\t\t\t\t  sizeof(msgs.rep_ack));\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn 0;\n}\n\nstatic int hdcp2_authenticate_sink(struct intel_connector *connector)\n{\n\tstruct intel_digital_port *dig_port = intel_attached_dig_port(connector);\n\tstruct drm_i915_private *i915 = to_i915(connector->base.dev);\n\tstruct intel_hdcp *hdcp = &connector->hdcp;\n\tconst struct intel_hdcp_shim *shim = hdcp->shim;\n\tint ret;\n\n\tret = hdcp2_authentication_key_exchange(connector);\n\tif (ret < 0) {\n\t\tdrm_dbg_kms(&i915->drm, \"AKE Failed. Err : %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = hdcp2_locality_check(connector);\n\tif (ret < 0) {\n\t\tdrm_dbg_kms(&i915->drm,\n\t\t\t    \"Locality Check failed. Err : %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = hdcp2_session_key_exchange(connector);\n\tif (ret < 0) {\n\t\tdrm_dbg_kms(&i915->drm, \"SKE Failed. Err : %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tif (shim->config_stream_type) {\n\t\tret = shim->config_stream_type(dig_port,\n\t\t\t\t\t       hdcp->is_repeater,\n\t\t\t\t\t       hdcp->content_type);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\tif (hdcp->is_repeater) {\n\t\tret = hdcp2_authenticate_repeater_topology(connector);\n\t\tif (ret < 0) {\n\t\t\tdrm_dbg_kms(&i915->drm,\n\t\t\t\t    \"Repeater Auth Failed. Err: %d\\n\", ret);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn ret;\n}\n\nstatic int hdcp2_enable_stream_encryption(struct intel_connector *connector)\n{\n\tstruct intel_digital_port *dig_port = intel_attached_dig_port(connector);\n\tstruct drm_i915_private *i915 = to_i915(connector->base.dev);\n\tstruct hdcp_port_data *data = &dig_port->hdcp_port_data;\n\tstruct intel_hdcp *hdcp = &connector->hdcp;\n\tenum transcoder cpu_transcoder = hdcp->cpu_transcoder;\n\tenum port port = dig_port->base.port;\n\tint ret = 0;\n\n\tif (!(intel_de_read(i915, HDCP2_STATUS(i915, cpu_transcoder, port)) &\n\t\t\t    LINK_ENCRYPTION_STATUS)) {\n\t\tdrm_err(&i915->drm, \"[%s:%d] HDCP 2.2 Link is not encrypted\\n\",\n\t\t\tconnector->base.name, connector->base.base.id);\n\t\tret = -EPERM;\n\t\tgoto link_recover;\n\t}\n\n\tif (hdcp->shim->stream_2_2_encryption) {\n\t\tret = hdcp->shim->stream_2_2_encryption(connector, true);\n\t\tif (ret) {\n\t\t\tdrm_err(&i915->drm, \"[%s:%d] Failed to enable HDCP 2.2 stream enc\\n\",\n\t\t\t\tconnector->base.name, connector->base.base.id);\n\t\t\treturn ret;\n\t\t}\n\t\tdrm_dbg_kms(&i915->drm, \"HDCP 2.2 transcoder: %s stream encrypted\\n\",\n\t\t\t    transcoder_name(hdcp->stream_transcoder));\n\t}\n\n\treturn 0;\n\nlink_recover:\n\tif (hdcp2_deauthenticate_port(connector) < 0)\n\t\tdrm_dbg_kms(&i915->drm, \"Port deauth failed.\\n\");\n\n\tdig_port->hdcp_auth_status = false;\n\tdata->k = 0;\n\n\treturn ret;\n}\n\nstatic int hdcp2_enable_encryption(struct intel_connector *connector)\n{\n\tstruct intel_digital_port *dig_port = intel_attached_dig_port(connector);\n\tstruct drm_i915_private *i915 = to_i915(connector->base.dev);\n\tstruct intel_hdcp *hdcp = &connector->hdcp;\n\tenum port port = dig_port->base.port;\n\tenum transcoder cpu_transcoder = hdcp->cpu_transcoder;\n\tint ret;\n\n\tdrm_WARN_ON(&i915->drm,\n\t\t    intel_de_read(i915, HDCP2_STATUS(i915, cpu_transcoder, port)) &\n\t\t    LINK_ENCRYPTION_STATUS);\n\tif (hdcp->shim->toggle_signalling) {\n\t\tret = hdcp->shim->toggle_signalling(dig_port, cpu_transcoder,\n\t\t\t\t\t\t    true);\n\t\tif (ret) {\n\t\t\tdrm_err(&i915->drm,\n\t\t\t\t\"Failed to enable HDCP signalling. %d\\n\",\n\t\t\t\tret);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tif (intel_de_read(i915, HDCP2_STATUS(i915, cpu_transcoder, port)) &\n\t    LINK_AUTH_STATUS)\n\t\t \n\t\tintel_de_rmw(i915, HDCP2_CTL(i915, cpu_transcoder, port),\n\t\t\t     0, CTL_LINK_ENCRYPTION_REQ);\n\n\tret = intel_de_wait_for_set(i915,\n\t\t\t\t    HDCP2_STATUS(i915, cpu_transcoder,\n\t\t\t\t\t\t port),\n\t\t\t\t    LINK_ENCRYPTION_STATUS,\n\t\t\t\t    HDCP_ENCRYPT_STATUS_CHANGE_TIMEOUT_MS);\n\tdig_port->hdcp_auth_status = true;\n\n\treturn ret;\n}\n\nstatic int hdcp2_disable_encryption(struct intel_connector *connector)\n{\n\tstruct intel_digital_port *dig_port = intel_attached_dig_port(connector);\n\tstruct drm_i915_private *i915 = to_i915(connector->base.dev);\n\tstruct intel_hdcp *hdcp = &connector->hdcp;\n\tenum port port = dig_port->base.port;\n\tenum transcoder cpu_transcoder = hdcp->cpu_transcoder;\n\tint ret;\n\n\tdrm_WARN_ON(&i915->drm, !(intel_de_read(i915, HDCP2_STATUS(i915, cpu_transcoder, port)) &\n\t\t\t\t      LINK_ENCRYPTION_STATUS));\n\n\tintel_de_rmw(i915, HDCP2_CTL(i915, cpu_transcoder, port),\n\t\t     CTL_LINK_ENCRYPTION_REQ, 0);\n\n\tret = intel_de_wait_for_clear(i915,\n\t\t\t\t      HDCP2_STATUS(i915, cpu_transcoder,\n\t\t\t\t\t\t   port),\n\t\t\t\t      LINK_ENCRYPTION_STATUS,\n\t\t\t\t      HDCP_ENCRYPT_STATUS_CHANGE_TIMEOUT_MS);\n\tif (ret == -ETIMEDOUT)\n\t\tdrm_dbg_kms(&i915->drm, \"Disable Encryption Timedout\");\n\n\tif (hdcp->shim->toggle_signalling) {\n\t\tret = hdcp->shim->toggle_signalling(dig_port, cpu_transcoder,\n\t\t\t\t\t\t    false);\n\t\tif (ret) {\n\t\t\tdrm_err(&i915->drm,\n\t\t\t\t\"Failed to disable HDCP signalling. %d\\n\",\n\t\t\t\tret);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn ret;\n}\n\nstatic int\nhdcp2_propagate_stream_management_info(struct intel_connector *connector)\n{\n\tstruct drm_i915_private *i915 = to_i915(connector->base.dev);\n\tint i, tries = 3, ret;\n\n\tif (!connector->hdcp.is_repeater)\n\t\treturn 0;\n\n\tfor (i = 0; i < tries; i++) {\n\t\tret = _hdcp2_propagate_stream_management_info(connector);\n\t\tif (!ret)\n\t\t\tbreak;\n\n\t\t \n\t\tif (connector->hdcp.seq_num_m > HDCP_2_2_SEQ_NUM_MAX) {\n\t\t\tdrm_dbg_kms(&i915->drm,\n\t\t\t\t    \"seq_num_m roll over.(%d)\\n\", ret);\n\t\t\tbreak;\n\t\t}\n\n\t\tdrm_dbg_kms(&i915->drm,\n\t\t\t    \"HDCP2 stream management %d of %d Failed.(%d)\\n\",\n\t\t\t    i + 1, tries, ret);\n\t}\n\n\treturn ret;\n}\n\nstatic int hdcp2_authenticate_and_encrypt(struct intel_connector *connector)\n{\n\tstruct intel_digital_port *dig_port = intel_attached_dig_port(connector);\n\tstruct drm_i915_private *i915 = to_i915(connector->base.dev);\n\tint ret = 0, i, tries = 3;\n\n\tfor (i = 0; i < tries && !dig_port->hdcp_auth_status; i++) {\n\t\tret = hdcp2_authenticate_sink(connector);\n\t\tif (!ret) {\n\t\t\tintel_hdcp_prepare_streams(connector);\n\n\t\t\tret = hdcp2_propagate_stream_management_info(connector);\n\t\t\tif (ret) {\n\t\t\t\tdrm_dbg_kms(&i915->drm,\n\t\t\t\t\t    \"Stream management failed.(%d)\\n\",\n\t\t\t\t\t    ret);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tret = hdcp2_authenticate_port(connector);\n\t\t\tif (!ret)\n\t\t\t\tbreak;\n\t\t\tdrm_dbg_kms(&i915->drm, \"HDCP2 port auth failed.(%d)\\n\",\n\t\t\t\t    ret);\n\t\t}\n\n\t\t \n\t\tdrm_dbg_kms(&i915->drm, \"HDCP2.2 Auth %d of %d Failed.(%d)\\n\",\n\t\t\t    i + 1, tries, ret);\n\t\tif (hdcp2_deauthenticate_port(connector) < 0)\n\t\t\tdrm_dbg_kms(&i915->drm, \"Port deauth failed.\\n\");\n\t}\n\n\tif (!ret && !dig_port->hdcp_auth_status) {\n\t\t \n\t\tmsleep(HDCP_2_2_DELAY_BEFORE_ENCRYPTION_EN);\n\t\tret = hdcp2_enable_encryption(connector);\n\t\tif (ret < 0) {\n\t\t\tdrm_dbg_kms(&i915->drm,\n\t\t\t\t    \"Encryption Enable Failed.(%d)\\n\", ret);\n\t\t\tif (hdcp2_deauthenticate_port(connector) < 0)\n\t\t\t\tdrm_dbg_kms(&i915->drm, \"Port deauth failed.\\n\");\n\t\t}\n\t}\n\n\tif (!ret)\n\t\tret = hdcp2_enable_stream_encryption(connector);\n\n\treturn ret;\n}\n\nstatic int _intel_hdcp2_enable(struct intel_connector *connector)\n{\n\tstruct drm_i915_private *i915 = to_i915(connector->base.dev);\n\tstruct intel_hdcp *hdcp = &connector->hdcp;\n\tint ret;\n\n\tdrm_dbg_kms(&i915->drm, \"[%s:%d] HDCP2.2 is being enabled. Type: %d\\n\",\n\t\t    connector->base.name, connector->base.base.id,\n\t\t    hdcp->content_type);\n\n\tret = hdcp2_authenticate_and_encrypt(connector);\n\tif (ret) {\n\t\tdrm_dbg_kms(&i915->drm, \"HDCP2 Type%d  Enabling Failed. (%d)\\n\",\n\t\t\t    hdcp->content_type, ret);\n\t\treturn ret;\n\t}\n\n\tdrm_dbg_kms(&i915->drm, \"[%s:%d] HDCP2.2 is enabled. Type %d\\n\",\n\t\t    connector->base.name, connector->base.base.id,\n\t\t    hdcp->content_type);\n\n\thdcp->hdcp2_encrypted = true;\n\treturn 0;\n}\n\nstatic int\n_intel_hdcp2_disable(struct intel_connector *connector, bool hdcp2_link_recovery)\n{\n\tstruct intel_digital_port *dig_port = intel_attached_dig_port(connector);\n\tstruct drm_i915_private *i915 = to_i915(connector->base.dev);\n\tstruct hdcp_port_data *data = &dig_port->hdcp_port_data;\n\tstruct intel_hdcp *hdcp = &connector->hdcp;\n\tint ret;\n\n\tdrm_dbg_kms(&i915->drm, \"[%s:%d] HDCP2.2 is being Disabled\\n\",\n\t\t    connector->base.name, connector->base.base.id);\n\n\tif (hdcp->shim->stream_2_2_encryption) {\n\t\tret = hdcp->shim->stream_2_2_encryption(connector, false);\n\t\tif (ret) {\n\t\t\tdrm_err(&i915->drm, \"[%s:%d] Failed to disable HDCP 2.2 stream enc\\n\",\n\t\t\t\tconnector->base.name, connector->base.base.id);\n\t\t\treturn ret;\n\t\t}\n\t\tdrm_dbg_kms(&i915->drm, \"HDCP 2.2 transcoder: %s stream encryption disabled\\n\",\n\t\t\t    transcoder_name(hdcp->stream_transcoder));\n\n\t\tif (dig_port->num_hdcp_streams > 0 && !hdcp2_link_recovery)\n\t\t\treturn 0;\n\t}\n\n\tret = hdcp2_disable_encryption(connector);\n\n\tif (hdcp2_deauthenticate_port(connector) < 0)\n\t\tdrm_dbg_kms(&i915->drm, \"Port deauth failed.\\n\");\n\n\tconnector->hdcp.hdcp2_encrypted = false;\n\tdig_port->hdcp_auth_status = false;\n\tdata->k = 0;\n\n\treturn ret;\n}\n\n \nstatic int intel_hdcp2_check_link(struct intel_connector *connector)\n{\n\tstruct intel_digital_port *dig_port = intel_attached_dig_port(connector);\n\tstruct drm_i915_private *i915 = to_i915(connector->base.dev);\n\tstruct intel_hdcp *hdcp = &connector->hdcp;\n\tenum port port = dig_port->base.port;\n\tenum transcoder cpu_transcoder;\n\tint ret = 0;\n\n\tmutex_lock(&hdcp->mutex);\n\tmutex_lock(&dig_port->hdcp_mutex);\n\tcpu_transcoder = hdcp->cpu_transcoder;\n\n\t \n\tif (hdcp->value != DRM_MODE_CONTENT_PROTECTION_ENABLED ||\n\t    !hdcp->hdcp2_encrypted) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tif (drm_WARN_ON(&i915->drm,\n\t\t\t!intel_hdcp2_in_use(i915, cpu_transcoder, port))) {\n\t\tdrm_err(&i915->drm,\n\t\t\t\"HDCP2.2 link stopped the encryption, %x\\n\",\n\t\t\tintel_de_read(i915, HDCP2_STATUS(i915, cpu_transcoder, port)));\n\t\tret = -ENXIO;\n\t\t_intel_hdcp2_disable(connector, true);\n\t\tintel_hdcp_update_value(connector,\n\t\t\t\t\tDRM_MODE_CONTENT_PROTECTION_DESIRED,\n\t\t\t\t\ttrue);\n\t\tgoto out;\n\t}\n\n\tret = hdcp->shim->check_2_2_link(dig_port, connector);\n\tif (ret == HDCP_LINK_PROTECTED) {\n\t\tif (hdcp->value != DRM_MODE_CONTENT_PROTECTION_UNDESIRED) {\n\t\t\tintel_hdcp_update_value(connector,\n\t\t\t\t\tDRM_MODE_CONTENT_PROTECTION_ENABLED,\n\t\t\t\t\ttrue);\n\t\t}\n\t\tgoto out;\n\t}\n\n\tif (ret == HDCP_TOPOLOGY_CHANGE) {\n\t\tif (hdcp->value == DRM_MODE_CONTENT_PROTECTION_UNDESIRED)\n\t\t\tgoto out;\n\n\t\tdrm_dbg_kms(&i915->drm,\n\t\t\t    \"HDCP2.2 Downstream topology change\\n\");\n\t\tret = hdcp2_authenticate_repeater_topology(connector);\n\t\tif (!ret) {\n\t\t\tintel_hdcp_update_value(connector,\n\t\t\t\t\tDRM_MODE_CONTENT_PROTECTION_ENABLED,\n\t\t\t\t\ttrue);\n\t\t\tgoto out;\n\t\t}\n\t\tdrm_dbg_kms(&i915->drm,\n\t\t\t    \"[%s:%d] Repeater topology auth failed.(%d)\\n\",\n\t\t\t    connector->base.name, connector->base.base.id,\n\t\t\t    ret);\n\t} else {\n\t\tdrm_dbg_kms(&i915->drm,\n\t\t\t    \"[%s:%d] HDCP2.2 link failed, retrying auth\\n\",\n\t\t\t    connector->base.name, connector->base.base.id);\n\t}\n\n\tret = _intel_hdcp2_disable(connector, true);\n\tif (ret) {\n\t\tdrm_err(&i915->drm,\n\t\t\t\"[%s:%d] Failed to disable hdcp2.2 (%d)\\n\",\n\t\t\tconnector->base.name, connector->base.base.id, ret);\n\t\tintel_hdcp_update_value(connector,\n\t\t\t\tDRM_MODE_CONTENT_PROTECTION_DESIRED, true);\n\t\tgoto out;\n\t}\n\n\tret = _intel_hdcp2_enable(connector);\n\tif (ret) {\n\t\tdrm_dbg_kms(&i915->drm,\n\t\t\t    \"[%s:%d] Failed to enable hdcp2.2 (%d)\\n\",\n\t\t\t    connector->base.name, connector->base.base.id,\n\t\t\t    ret);\n\t\tintel_hdcp_update_value(connector,\n\t\t\t\t\tDRM_MODE_CONTENT_PROTECTION_DESIRED,\n\t\t\t\t\ttrue);\n\t\tgoto out;\n\t}\n\nout:\n\tmutex_unlock(&dig_port->hdcp_mutex);\n\tmutex_unlock(&hdcp->mutex);\n\treturn ret;\n}\n\nstatic void intel_hdcp_check_work(struct work_struct *work)\n{\n\tstruct intel_hdcp *hdcp = container_of(to_delayed_work(work),\n\t\t\t\t\t       struct intel_hdcp,\n\t\t\t\t\t       check_work);\n\tstruct intel_connector *connector = intel_hdcp_to_connector(hdcp);\n\tstruct drm_i915_private *i915 = to_i915(connector->base.dev);\n\n\tif (drm_connector_is_unregistered(&connector->base))\n\t\treturn;\n\n\tif (!intel_hdcp2_check_link(connector))\n\t\tqueue_delayed_work(i915->unordered_wq, &hdcp->check_work,\n\t\t\t\t   DRM_HDCP2_CHECK_PERIOD_MS);\n\telse if (!intel_hdcp_check_link(connector))\n\t\tqueue_delayed_work(i915->unordered_wq, &hdcp->check_work,\n\t\t\t\t   DRM_HDCP_CHECK_PERIOD_MS);\n}\n\nstatic int i915_hdcp_component_bind(struct device *i915_kdev,\n\t\t\t\t    struct device *mei_kdev, void *data)\n{\n\tstruct drm_i915_private *i915 = kdev_to_i915(i915_kdev);\n\n\tdrm_dbg(&i915->drm, \"I915 HDCP comp bind\\n\");\n\tmutex_lock(&i915->display.hdcp.hdcp_mutex);\n\ti915->display.hdcp.arbiter = (struct i915_hdcp_arbiter *)data;\n\ti915->display.hdcp.arbiter->hdcp_dev = mei_kdev;\n\tmutex_unlock(&i915->display.hdcp.hdcp_mutex);\n\n\treturn 0;\n}\n\nstatic void i915_hdcp_component_unbind(struct device *i915_kdev,\n\t\t\t\t       struct device *mei_kdev, void *data)\n{\n\tstruct drm_i915_private *i915 = kdev_to_i915(i915_kdev);\n\n\tdrm_dbg(&i915->drm, \"I915 HDCP comp unbind\\n\");\n\tmutex_lock(&i915->display.hdcp.hdcp_mutex);\n\ti915->display.hdcp.arbiter = NULL;\n\tmutex_unlock(&i915->display.hdcp.hdcp_mutex);\n}\n\nstatic const struct component_ops i915_hdcp_ops = {\n\t.bind   = i915_hdcp_component_bind,\n\t.unbind = i915_hdcp_component_unbind,\n};\n\nstatic enum hdcp_ddi intel_get_hdcp_ddi_index(enum port port)\n{\n\tswitch (port) {\n\tcase PORT_A:\n\t\treturn HDCP_DDI_A;\n\tcase PORT_B ... PORT_F:\n\t\treturn (enum hdcp_ddi)port;\n\tdefault:\n\t\treturn HDCP_DDI_INVALID_PORT;\n\t}\n}\n\nstatic enum hdcp_transcoder intel_get_hdcp_transcoder(enum transcoder cpu_transcoder)\n{\n\tswitch (cpu_transcoder) {\n\tcase TRANSCODER_A ... TRANSCODER_D:\n\t\treturn (enum hdcp_transcoder)(cpu_transcoder | 0x10);\n\tdefault:  \n\t\treturn HDCP_INVALID_TRANSCODER;\n\t}\n}\n\nstatic int initialize_hdcp_port_data(struct intel_connector *connector,\n\t\t\t\t     struct intel_digital_port *dig_port,\n\t\t\t\t     const struct intel_hdcp_shim *shim)\n{\n\tstruct drm_i915_private *i915 = to_i915(connector->base.dev);\n\tstruct hdcp_port_data *data = &dig_port->hdcp_port_data;\n\tenum port port = dig_port->base.port;\n\n\tif (DISPLAY_VER(i915) < 12)\n\t\tdata->hdcp_ddi = intel_get_hdcp_ddi_index(port);\n\telse\n\t\t \n\t\tdata->hdcp_ddi = HDCP_DDI_INVALID_PORT;\n\n\t \n\tdata->hdcp_transcoder = HDCP_INVALID_TRANSCODER;\n\n\tdata->port_type = (u8)HDCP_PORT_TYPE_INTEGRATED;\n\tdata->protocol = (u8)shim->protocol;\n\n\tif (!data->streams)\n\t\tdata->streams = kcalloc(INTEL_NUM_PIPES(i915),\n\t\t\t\t\tsizeof(struct hdcp2_streamid_type),\n\t\t\t\t\tGFP_KERNEL);\n\tif (!data->streams) {\n\t\tdrm_err(&i915->drm, \"Out of Memory\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\treturn 0;\n}\n\nstatic bool is_hdcp2_supported(struct drm_i915_private *i915)\n{\n\tif (intel_hdcp_gsc_cs_required(i915))\n\t\treturn true;\n\n\tif (!IS_ENABLED(CONFIG_INTEL_MEI_HDCP))\n\t\treturn false;\n\n\treturn (DISPLAY_VER(i915) >= 10 ||\n\t\tIS_KABYLAKE(i915) ||\n\t\tIS_COFFEELAKE(i915) ||\n\t\tIS_COMETLAKE(i915));\n}\n\nvoid intel_hdcp_component_init(struct drm_i915_private *i915)\n{\n\tint ret;\n\n\tif (!is_hdcp2_supported(i915))\n\t\treturn;\n\n\tmutex_lock(&i915->display.hdcp.hdcp_mutex);\n\tdrm_WARN_ON(&i915->drm, i915->display.hdcp.comp_added);\n\n\ti915->display.hdcp.comp_added = true;\n\tmutex_unlock(&i915->display.hdcp.hdcp_mutex);\n\tif (intel_hdcp_gsc_cs_required(i915))\n\t\tret = intel_hdcp_gsc_init(i915);\n\telse\n\t\tret = component_add_typed(i915->drm.dev, &i915_hdcp_ops,\n\t\t\t\t\t  I915_COMPONENT_HDCP);\n\n\tif (ret < 0) {\n\t\tdrm_dbg_kms(&i915->drm, \"Failed at fw component add(%d)\\n\",\n\t\t\t    ret);\n\t\tmutex_lock(&i915->display.hdcp.hdcp_mutex);\n\t\ti915->display.hdcp.comp_added = false;\n\t\tmutex_unlock(&i915->display.hdcp.hdcp_mutex);\n\t\treturn;\n\t}\n}\n\nstatic void intel_hdcp2_init(struct intel_connector *connector,\n\t\t\t     struct intel_digital_port *dig_port,\n\t\t\t     const struct intel_hdcp_shim *shim)\n{\n\tstruct drm_i915_private *i915 = to_i915(connector->base.dev);\n\tstruct intel_hdcp *hdcp = &connector->hdcp;\n\tint ret;\n\n\tret = initialize_hdcp_port_data(connector, dig_port, shim);\n\tif (ret) {\n\t\tdrm_dbg_kms(&i915->drm, \"Mei hdcp data init failed\\n\");\n\t\treturn;\n\t}\n\n\thdcp->hdcp2_supported = true;\n}\n\nint intel_hdcp_init(struct intel_connector *connector,\n\t\t    struct intel_digital_port *dig_port,\n\t\t    const struct intel_hdcp_shim *shim)\n{\n\tstruct drm_i915_private *i915 = to_i915(connector->base.dev);\n\tstruct intel_hdcp *hdcp = &connector->hdcp;\n\tint ret;\n\n\tif (!shim)\n\t\treturn -EINVAL;\n\n\tif (is_hdcp2_supported(i915))\n\t\tintel_hdcp2_init(connector, dig_port, shim);\n\n\tret =\n\tdrm_connector_attach_content_protection_property(&connector->base,\n\t\t\t\t\t\t\t hdcp->hdcp2_supported);\n\tif (ret) {\n\t\thdcp->hdcp2_supported = false;\n\t\tkfree(dig_port->hdcp_port_data.streams);\n\t\treturn ret;\n\t}\n\n\thdcp->shim = shim;\n\tmutex_init(&hdcp->mutex);\n\tINIT_DELAYED_WORK(&hdcp->check_work, intel_hdcp_check_work);\n\tINIT_WORK(&hdcp->prop_work, intel_hdcp_prop_work);\n\tinit_waitqueue_head(&hdcp->cp_irq_queue);\n\n\treturn 0;\n}\n\nstatic int\nintel_hdcp_set_streams(struct intel_digital_port *dig_port,\n\t\t       struct intel_atomic_state *state)\n{\n\tstruct drm_connector_list_iter conn_iter;\n\tstruct intel_digital_port *conn_dig_port;\n\tstruct intel_connector *connector;\n\tstruct drm_i915_private *i915 = to_i915(dig_port->base.base.dev);\n\tstruct hdcp_port_data *data = &dig_port->hdcp_port_data;\n\n\tif (!intel_encoder_is_mst(&dig_port->base)) {\n\t\tdata->k = 1;\n\t\tdata->streams[0].stream_id = 0;\n\t\treturn 0;\n\t}\n\n\tdata->k = 0;\n\n\tdrm_connector_list_iter_begin(&i915->drm, &conn_iter);\n\tfor_each_intel_connector_iter(connector, &conn_iter) {\n\t\tif (connector->base.status == connector_status_disconnected)\n\t\t\tcontinue;\n\n\t\tif (!intel_encoder_is_mst(intel_attached_encoder(connector)))\n\t\t\tcontinue;\n\n\t\tconn_dig_port = intel_attached_dig_port(connector);\n\t\tif (conn_dig_port != dig_port)\n\t\t\tcontinue;\n\n\t\tdata->streams[data->k].stream_id =\n\t\t\tintel_conn_to_vcpi(&state->base, connector);\n\t\tdata->k++;\n\n\t\t \n\t\tif (dig_port->dp.active_mst_links <= 1)\n\t\t\tbreak;\n\t}\n\tdrm_connector_list_iter_end(&conn_iter);\n\n\tif (drm_WARN_ON(&i915->drm, data->k > INTEL_NUM_PIPES(i915) || data->k == 0))\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nint intel_hdcp_enable(struct intel_atomic_state *state,\n\t\t      struct intel_encoder *encoder,\n\t\t      const struct intel_crtc_state *pipe_config,\n\t\t      const struct drm_connector_state *conn_state)\n{\n\tstruct drm_i915_private *i915 = to_i915(encoder->base.dev);\n\tstruct intel_connector *connector =\n\t\tto_intel_connector(conn_state->connector);\n\tstruct intel_digital_port *dig_port = intel_attached_dig_port(connector);\n\tstruct intel_hdcp *hdcp = &connector->hdcp;\n\tunsigned long check_link_interval = DRM_HDCP_CHECK_PERIOD_MS;\n\tint ret = -EINVAL;\n\n\tif (!hdcp->shim)\n\t\treturn -ENOENT;\n\n\tif (!connector->encoder) {\n\t\tdrm_err(&i915->drm, \"[%s:%d] encoder is not initialized\\n\",\n\t\t\tconnector->base.name, connector->base.base.id);\n\t\treturn -ENODEV;\n\t}\n\n\tmutex_lock(&hdcp->mutex);\n\tmutex_lock(&dig_port->hdcp_mutex);\n\tdrm_WARN_ON(&i915->drm,\n\t\t    hdcp->value == DRM_MODE_CONTENT_PROTECTION_ENABLED);\n\thdcp->content_type = (u8)conn_state->hdcp_content_type;\n\n\tif (intel_crtc_has_type(pipe_config, INTEL_OUTPUT_DP_MST)) {\n\t\thdcp->cpu_transcoder = pipe_config->mst_master_transcoder;\n\t\thdcp->stream_transcoder = pipe_config->cpu_transcoder;\n\t} else {\n\t\thdcp->cpu_transcoder = pipe_config->cpu_transcoder;\n\t\thdcp->stream_transcoder = INVALID_TRANSCODER;\n\t}\n\n\tif (DISPLAY_VER(i915) >= 12)\n\t\tdig_port->hdcp_port_data.hdcp_transcoder =\n\t\t\tintel_get_hdcp_transcoder(hdcp->cpu_transcoder);\n\n\t \n\tif (intel_hdcp2_capable(connector)) {\n\t\tret = intel_hdcp_set_streams(dig_port, state);\n\t\tif (!ret) {\n\t\t\tret = _intel_hdcp2_enable(connector);\n\t\t\tif (!ret)\n\t\t\t\tcheck_link_interval =\n\t\t\t\t\tDRM_HDCP2_CHECK_PERIOD_MS;\n\t\t} else {\n\t\t\tdrm_dbg_kms(&i915->drm,\n\t\t\t\t    \"Set content streams failed: (%d)\\n\",\n\t\t\t\t    ret);\n\t\t}\n\t}\n\n\t \n\tif (ret && intel_hdcp_capable(connector) &&\n\t    hdcp->content_type != DRM_MODE_HDCP_CONTENT_TYPE1) {\n\t\tret = _intel_hdcp_enable(connector);\n\t}\n\n\tif (!ret) {\n\t\tqueue_delayed_work(i915->unordered_wq, &hdcp->check_work,\n\t\t\t\t   check_link_interval);\n\t\tintel_hdcp_update_value(connector,\n\t\t\t\t\tDRM_MODE_CONTENT_PROTECTION_ENABLED,\n\t\t\t\t\ttrue);\n\t}\n\n\tmutex_unlock(&dig_port->hdcp_mutex);\n\tmutex_unlock(&hdcp->mutex);\n\treturn ret;\n}\n\nint intel_hdcp_disable(struct intel_connector *connector)\n{\n\tstruct intel_digital_port *dig_port = intel_attached_dig_port(connector);\n\tstruct intel_hdcp *hdcp = &connector->hdcp;\n\tint ret = 0;\n\n\tif (!hdcp->shim)\n\t\treturn -ENOENT;\n\n\tmutex_lock(&hdcp->mutex);\n\tmutex_lock(&dig_port->hdcp_mutex);\n\n\tif (hdcp->value == DRM_MODE_CONTENT_PROTECTION_UNDESIRED)\n\t\tgoto out;\n\n\tintel_hdcp_update_value(connector,\n\t\t\t\tDRM_MODE_CONTENT_PROTECTION_UNDESIRED, false);\n\tif (hdcp->hdcp2_encrypted)\n\t\tret = _intel_hdcp2_disable(connector, false);\n\telse if (hdcp->hdcp_encrypted)\n\t\tret = _intel_hdcp_disable(connector);\n\nout:\n\tmutex_unlock(&dig_port->hdcp_mutex);\n\tmutex_unlock(&hdcp->mutex);\n\tcancel_delayed_work_sync(&hdcp->check_work);\n\treturn ret;\n}\n\nvoid intel_hdcp_update_pipe(struct intel_atomic_state *state,\n\t\t\t    struct intel_encoder *encoder,\n\t\t\t    const struct intel_crtc_state *crtc_state,\n\t\t\t    const struct drm_connector_state *conn_state)\n{\n\tstruct intel_connector *connector =\n\t\t\t\tto_intel_connector(conn_state->connector);\n\tstruct intel_hdcp *hdcp = &connector->hdcp;\n\tbool content_protection_type_changed, desired_and_not_enabled = false;\n\tstruct drm_i915_private *i915 = to_i915(connector->base.dev);\n\n\tif (!connector->hdcp.shim)\n\t\treturn;\n\n\tcontent_protection_type_changed =\n\t\t(conn_state->hdcp_content_type != hdcp->content_type &&\n\t\t conn_state->content_protection !=\n\t\t DRM_MODE_CONTENT_PROTECTION_UNDESIRED);\n\n\t \n\tif (conn_state->content_protection ==\n\t    DRM_MODE_CONTENT_PROTECTION_UNDESIRED ||\n\t    content_protection_type_changed)\n\t\tintel_hdcp_disable(connector);\n\n\t \n\tif (content_protection_type_changed) {\n\t\tmutex_lock(&hdcp->mutex);\n\t\thdcp->value = DRM_MODE_CONTENT_PROTECTION_DESIRED;\n\t\tdrm_connector_get(&connector->base);\n\t\tqueue_work(i915->unordered_wq, &hdcp->prop_work);\n\t\tmutex_unlock(&hdcp->mutex);\n\t}\n\n\tif (conn_state->content_protection ==\n\t    DRM_MODE_CONTENT_PROTECTION_DESIRED) {\n\t\tmutex_lock(&hdcp->mutex);\n\t\t \n\t\tdesired_and_not_enabled =\n\t\t\thdcp->value != DRM_MODE_CONTENT_PROTECTION_ENABLED;\n\t\tmutex_unlock(&hdcp->mutex);\n\t\t \n\t\tif (!desired_and_not_enabled && !content_protection_type_changed) {\n\t\t\tdrm_connector_get(&connector->base);\n\t\t\tqueue_work(i915->unordered_wq, &hdcp->prop_work);\n\t\t}\n\t}\n\n\tif (desired_and_not_enabled || content_protection_type_changed)\n\t\tintel_hdcp_enable(state, encoder, crtc_state, conn_state);\n}\n\nvoid intel_hdcp_component_fini(struct drm_i915_private *i915)\n{\n\tmutex_lock(&i915->display.hdcp.hdcp_mutex);\n\tif (!i915->display.hdcp.comp_added) {\n\t\tmutex_unlock(&i915->display.hdcp.hdcp_mutex);\n\t\treturn;\n\t}\n\n\ti915->display.hdcp.comp_added = false;\n\tmutex_unlock(&i915->display.hdcp.hdcp_mutex);\n\n\tif (intel_hdcp_gsc_cs_required(i915))\n\t\tintel_hdcp_gsc_fini(i915);\n\telse\n\t\tcomponent_del(i915->drm.dev, &i915_hdcp_ops);\n}\n\nvoid intel_hdcp_cleanup(struct intel_connector *connector)\n{\n\tstruct intel_hdcp *hdcp = &connector->hdcp;\n\n\tif (!hdcp->shim)\n\t\treturn;\n\n\t \n\tdrm_WARN_ON(connector->base.dev,\n\t\tconnector->base.registration_state == DRM_CONNECTOR_REGISTERED);\n\n\t \n\tcancel_delayed_work_sync(&hdcp->check_work);\n\n\t \n\tdrm_WARN_ON(connector->base.dev, work_pending(&hdcp->prop_work));\n\n\tmutex_lock(&hdcp->mutex);\n\thdcp->shim = NULL;\n\tmutex_unlock(&hdcp->mutex);\n}\n\nvoid intel_hdcp_atomic_check(struct drm_connector *connector,\n\t\t\t     struct drm_connector_state *old_state,\n\t\t\t     struct drm_connector_state *new_state)\n{\n\tu64 old_cp = old_state->content_protection;\n\tu64 new_cp = new_state->content_protection;\n\tstruct drm_crtc_state *crtc_state;\n\n\tif (!new_state->crtc) {\n\t\t \n\t\tif (old_cp == DRM_MODE_CONTENT_PROTECTION_ENABLED)\n\t\t\tnew_state->content_protection =\n\t\t\t\tDRM_MODE_CONTENT_PROTECTION_DESIRED;\n\t\treturn;\n\t}\n\n\tcrtc_state = drm_atomic_get_new_crtc_state(new_state->state,\n\t\t\t\t\t\t   new_state->crtc);\n\t \n\tif (drm_atomic_crtc_needs_modeset(crtc_state) &&\n\t    (old_cp == DRM_MODE_CONTENT_PROTECTION_ENABLED &&\n\t    new_cp != DRM_MODE_CONTENT_PROTECTION_UNDESIRED))\n\t\tnew_state->content_protection =\n\t\t\tDRM_MODE_CONTENT_PROTECTION_DESIRED;\n\n\t \n\tif (old_cp == new_cp ||\n\t    (old_cp == DRM_MODE_CONTENT_PROTECTION_DESIRED &&\n\t     new_cp == DRM_MODE_CONTENT_PROTECTION_ENABLED)) {\n\t\tif (old_state->hdcp_content_type ==\n\t\t\t\tnew_state->hdcp_content_type)\n\t\t\treturn;\n\t}\n\n\tcrtc_state->mode_changed = true;\n}\n\n \nvoid intel_hdcp_handle_cp_irq(struct intel_connector *connector)\n{\n\tstruct intel_hdcp *hdcp = &connector->hdcp;\n\tstruct drm_i915_private *i915 = to_i915(connector->base.dev);\n\n\tif (!hdcp->shim)\n\t\treturn;\n\n\tatomic_inc(&connector->hdcp.cp_irq_count);\n\twake_up_all(&connector->hdcp.cp_irq_queue);\n\n\tqueue_delayed_work(i915->unordered_wq, &hdcp->check_work, 0);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}