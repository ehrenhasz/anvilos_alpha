{
  "module_name": "intel_dpt.c",
  "hash_id": "f3d6f61a51ae60ed8c65570ef55be58f9b54ca80cbba1d7e691da458ed59fea2",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/i915/display/intel_dpt.c",
  "human_readable_source": "\n \n\n#include \"gem/i915_gem_domain.h\"\n#include \"gem/i915_gem_internal.h\"\n#include \"gem/i915_gem_lmem.h\"\n#include \"gt/gen8_ppgtt.h\"\n\n#include \"i915_drv.h\"\n#include \"i915_reg.h\"\n#include \"intel_de.h\"\n#include \"intel_display_types.h\"\n#include \"intel_dpt.h\"\n#include \"intel_fb.h\"\n\nstruct i915_dpt {\n\tstruct i915_address_space vm;\n\n\tstruct drm_i915_gem_object *obj;\n\tstruct i915_vma *vma;\n\tvoid __iomem *iomem;\n};\n\n#define i915_is_dpt(vm) ((vm)->is_dpt)\n\nstatic inline struct i915_dpt *\ni915_vm_to_dpt(struct i915_address_space *vm)\n{\n\tBUILD_BUG_ON(offsetof(struct i915_dpt, vm));\n\tGEM_BUG_ON(!i915_is_dpt(vm));\n\treturn container_of(vm, struct i915_dpt, vm);\n}\n\n#define dpt_total_entries(dpt) ((dpt)->vm.total >> PAGE_SHIFT)\n\nstatic void gen8_set_pte(void __iomem *addr, gen8_pte_t pte)\n{\n\twriteq(pte, addr);\n}\n\nstatic void dpt_insert_page(struct i915_address_space *vm,\n\t\t\t    dma_addr_t addr,\n\t\t\t    u64 offset,\n\t\t\t    unsigned int pat_index,\n\t\t\t    u32 flags)\n{\n\tstruct i915_dpt *dpt = i915_vm_to_dpt(vm);\n\tgen8_pte_t __iomem *base = dpt->iomem;\n\n\tgen8_set_pte(base + offset / I915_GTT_PAGE_SIZE,\n\t\t     vm->pte_encode(addr, pat_index, flags));\n}\n\nstatic void dpt_insert_entries(struct i915_address_space *vm,\n\t\t\t       struct i915_vma_resource *vma_res,\n\t\t\t       unsigned int pat_index,\n\t\t\t       u32 flags)\n{\n\tstruct i915_dpt *dpt = i915_vm_to_dpt(vm);\n\tgen8_pte_t __iomem *base = dpt->iomem;\n\tconst gen8_pte_t pte_encode = vm->pte_encode(0, pat_index, flags);\n\tstruct sgt_iter sgt_iter;\n\tdma_addr_t addr;\n\tint i;\n\n\t \n\n\ti = vma_res->start / I915_GTT_PAGE_SIZE;\n\tfor_each_sgt_daddr(addr, sgt_iter, vma_res->bi.pages)\n\t\tgen8_set_pte(&base[i++], pte_encode | addr);\n}\n\nstatic void dpt_clear_range(struct i915_address_space *vm,\n\t\t\t    u64 start, u64 length)\n{\n}\n\nstatic void dpt_bind_vma(struct i915_address_space *vm,\n\t\t\t struct i915_vm_pt_stash *stash,\n\t\t\t struct i915_vma_resource *vma_res,\n\t\t\t unsigned int pat_index,\n\t\t\t u32 flags)\n{\n\tu32 pte_flags;\n\n\tif (vma_res->bound_flags)\n\t\treturn;\n\n\t \n\tpte_flags = 0;\n\tif (vm->has_read_only && vma_res->bi.readonly)\n\t\tpte_flags |= PTE_READ_ONLY;\n\tif (vma_res->bi.lmem)\n\t\tpte_flags |= PTE_LM;\n\n\tvm->insert_entries(vm, vma_res, pat_index, pte_flags);\n\n\tvma_res->page_sizes_gtt = I915_GTT_PAGE_SIZE;\n\n\t \n\tvma_res->bound_flags = I915_VMA_GLOBAL_BIND | I915_VMA_LOCAL_BIND;\n}\n\nstatic void dpt_unbind_vma(struct i915_address_space *vm,\n\t\t\t   struct i915_vma_resource *vma_res)\n{\n\tvm->clear_range(vm, vma_res->start, vma_res->vma_size);\n}\n\nstatic void dpt_cleanup(struct i915_address_space *vm)\n{\n\tstruct i915_dpt *dpt = i915_vm_to_dpt(vm);\n\n\ti915_gem_object_put(dpt->obj);\n}\n\nstruct i915_vma *intel_dpt_pin(struct i915_address_space *vm)\n{\n\tstruct drm_i915_private *i915 = vm->i915;\n\tstruct i915_dpt *dpt = i915_vm_to_dpt(vm);\n\tintel_wakeref_t wakeref;\n\tstruct i915_vma *vma;\n\tvoid __iomem *iomem;\n\tstruct i915_gem_ww_ctx ww;\n\tu64 pin_flags = 0;\n\tint err;\n\n\tif (i915_gem_object_is_stolen(dpt->obj))\n\t\tpin_flags |= PIN_MAPPABLE;\n\n\twakeref = intel_runtime_pm_get(&i915->runtime_pm);\n\tatomic_inc(&i915->gpu_error.pending_fb_pin);\n\n\tfor_i915_gem_ww(&ww, err, true) {\n\t\terr = i915_gem_object_lock(dpt->obj, &ww);\n\t\tif (err)\n\t\t\tcontinue;\n\n\t\tvma = i915_gem_object_ggtt_pin_ww(dpt->obj, &ww, NULL, 0, 4096,\n\t\t\t\t\t\t  pin_flags);\n\t\tif (IS_ERR(vma)) {\n\t\t\terr = PTR_ERR(vma);\n\t\t\tcontinue;\n\t\t}\n\n\t\tiomem = i915_vma_pin_iomap(vma);\n\t\ti915_vma_unpin(vma);\n\n\t\tif (IS_ERR(iomem)) {\n\t\t\terr = PTR_ERR(iomem);\n\t\t\tcontinue;\n\t\t}\n\n\t\tdpt->vma = vma;\n\t\tdpt->iomem = iomem;\n\n\t\ti915_vma_get(vma);\n\t}\n\n\tdpt->obj->mm.dirty = true;\n\n\tatomic_dec(&i915->gpu_error.pending_fb_pin);\n\tintel_runtime_pm_put(&i915->runtime_pm, wakeref);\n\n\treturn err ? ERR_PTR(err) : vma;\n}\n\nvoid intel_dpt_unpin(struct i915_address_space *vm)\n{\n\tstruct i915_dpt *dpt = i915_vm_to_dpt(vm);\n\n\ti915_vma_unpin_iomap(dpt->vma);\n\ti915_vma_put(dpt->vma);\n}\n\n \nvoid intel_dpt_resume(struct drm_i915_private *i915)\n{\n\tstruct drm_framebuffer *drm_fb;\n\n\tif (!HAS_DISPLAY(i915))\n\t\treturn;\n\n\tmutex_lock(&i915->drm.mode_config.fb_lock);\n\tdrm_for_each_fb(drm_fb, &i915->drm) {\n\t\tstruct intel_framebuffer *fb = to_intel_framebuffer(drm_fb);\n\n\t\tif (fb->dpt_vm)\n\t\t\ti915_ggtt_resume_vm(fb->dpt_vm);\n\t}\n\tmutex_unlock(&i915->drm.mode_config.fb_lock);\n}\n\n \nvoid intel_dpt_suspend(struct drm_i915_private *i915)\n{\n\tstruct drm_framebuffer *drm_fb;\n\n\tif (!HAS_DISPLAY(i915))\n\t\treturn;\n\n\tmutex_lock(&i915->drm.mode_config.fb_lock);\n\n\tdrm_for_each_fb(drm_fb, &i915->drm) {\n\t\tstruct intel_framebuffer *fb = to_intel_framebuffer(drm_fb);\n\n\t\tif (fb->dpt_vm)\n\t\t\ti915_ggtt_suspend_vm(fb->dpt_vm);\n\t}\n\n\tmutex_unlock(&i915->drm.mode_config.fb_lock);\n}\n\nstruct i915_address_space *\nintel_dpt_create(struct intel_framebuffer *fb)\n{\n\tstruct drm_gem_object *obj = &intel_fb_obj(&fb->base)->base;\n\tstruct drm_i915_private *i915 = to_i915(obj->dev);\n\tstruct drm_i915_gem_object *dpt_obj;\n\tstruct i915_address_space *vm;\n\tstruct i915_dpt *dpt;\n\tsize_t size;\n\tint ret;\n\n\tif (intel_fb_needs_pot_stride_remap(fb))\n\t\tsize = intel_remapped_info_size(&fb->remapped_view.gtt.remapped);\n\telse\n\t\tsize = DIV_ROUND_UP_ULL(obj->size, I915_GTT_PAGE_SIZE);\n\n\tsize = round_up(size * sizeof(gen8_pte_t), I915_GTT_PAGE_SIZE);\n\n\tdpt_obj = i915_gem_object_create_lmem(i915, size, I915_BO_ALLOC_CONTIGUOUS);\n\tif (IS_ERR(dpt_obj) && i915_ggtt_has_aperture(to_gt(i915)->ggtt))\n\t\tdpt_obj = i915_gem_object_create_stolen(i915, size);\n\tif (IS_ERR(dpt_obj) && !HAS_LMEM(i915)) {\n\t\tdrm_dbg_kms(&i915->drm, \"Allocating dpt from smem\\n\");\n\t\tdpt_obj = i915_gem_object_create_shmem(i915, size);\n\t}\n\tif (IS_ERR(dpt_obj))\n\t\treturn ERR_CAST(dpt_obj);\n\n\tret = i915_gem_object_lock_interruptible(dpt_obj, NULL);\n\tif (!ret) {\n\t\tret = i915_gem_object_set_cache_level(dpt_obj, I915_CACHE_NONE);\n\t\ti915_gem_object_unlock(dpt_obj);\n\t}\n\tif (ret) {\n\t\ti915_gem_object_put(dpt_obj);\n\t\treturn ERR_PTR(ret);\n\t}\n\n\tdpt = kzalloc(sizeof(*dpt), GFP_KERNEL);\n\tif (!dpt) {\n\t\ti915_gem_object_put(dpt_obj);\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\n\tvm = &dpt->vm;\n\n\tvm->gt = to_gt(i915);\n\tvm->i915 = i915;\n\tvm->dma = i915->drm.dev;\n\tvm->total = (size / sizeof(gen8_pte_t)) * I915_GTT_PAGE_SIZE;\n\tvm->is_dpt = true;\n\n\ti915_address_space_init(vm, VM_CLASS_DPT);\n\n\tvm->insert_page = dpt_insert_page;\n\tvm->clear_range = dpt_clear_range;\n\tvm->insert_entries = dpt_insert_entries;\n\tvm->cleanup = dpt_cleanup;\n\n\tvm->vma_ops.bind_vma    = dpt_bind_vma;\n\tvm->vma_ops.unbind_vma  = dpt_unbind_vma;\n\n\tvm->pte_encode = vm->gt->ggtt->vm.pte_encode;\n\n\tdpt->obj = dpt_obj;\n\tdpt->obj->is_dpt = true;\n\n\treturn &dpt->vm;\n}\n\nvoid intel_dpt_destroy(struct i915_address_space *vm)\n{\n\tstruct i915_dpt *dpt = i915_vm_to_dpt(vm);\n\n\tdpt->obj->is_dpt = false;\n\ti915_vm_put(&dpt->vm);\n}\n\nvoid intel_dpt_configure(struct intel_crtc *crtc)\n{\n\tstruct drm_i915_private *i915 = to_i915(crtc->base.dev);\n\n\tif (DISPLAY_VER(i915) == 14) {\n\t\tenum pipe pipe = crtc->pipe;\n\t\tenum plane_id plane_id;\n\n\t\tfor_each_plane_id_on_crtc(crtc, plane_id) {\n\t\t\tif (plane_id == PLANE_CURSOR)\n\t\t\t\tcontinue;\n\n\t\t\tintel_de_rmw(i915, PLANE_CHICKEN(pipe, plane_id),\n\t\t\t\t     PLANE_CHICKEN_DISABLE_DPT,\n\t\t\t\t     i915->params.enable_dpt ? 0 : PLANE_CHICKEN_DISABLE_DPT);\n\t\t}\n\t} else if (DISPLAY_VER(i915) == 13) {\n\t\tintel_de_rmw(i915, CHICKEN_MISC_2,\n\t\t\t     CHICKEN_MISC_DISABLE_DPT,\n\t\t\t     i915->params.enable_dpt ? 0 : CHICKEN_MISC_DISABLE_DPT);\n\t}\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}