{
  "module_name": "intel_dsb.c",
  "hash_id": "23d5136e7a4afefec85977830eeb0f901a4e25f284cd36fb455be1dcc9073f87",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/i915/display/intel_dsb.c",
  "human_readable_source": "\n \n\n#include \"gem/i915_gem_internal.h\"\n\n#include \"i915_drv.h\"\n#include \"i915_reg.h\"\n#include \"intel_de.h\"\n#include \"intel_display_types.h\"\n#include \"intel_dsb.h\"\n#include \"intel_dsb_regs.h\"\n\nstruct i915_vma;\n\nenum dsb_id {\n\tINVALID_DSB = -1,\n\tDSB1,\n\tDSB2,\n\tDSB3,\n\tMAX_DSB_PER_PIPE\n};\n\nstruct intel_dsb {\n\tenum dsb_id id;\n\n\tu32 *cmd_buf;\n\tstruct i915_vma *vma;\n\tstruct intel_crtc *crtc;\n\n\t \n\tunsigned int size;\n\n\t \n\tunsigned int free_pos;\n\n\t \n\tunsigned int ins_start_offset;\n};\n\n \n\n \n#define DSB_OPCODE_SHIFT\t\t24\n#define DSB_OPCODE_NOOP\t\t\t0x0\n#define DSB_OPCODE_MMIO_WRITE\t\t0x1\n#define DSB_OPCODE_WAIT_USEC\t\t0x2\n#define DSB_OPCODE_WAIT_LINES\t\t0x3\n#define DSB_OPCODE_WAIT_VBLANKS\t\t0x4\n#define DSB_OPCODE_WAIT_DSL_IN\t\t0x5\n#define DSB_OPCODE_WAIT_DSL_OUT\t\t0x6\n#define DSB_OPCODE_INTERRUPT\t\t0x7\n#define DSB_OPCODE_INDEXED_WRITE\t0x9\n#define DSB_OPCODE_POLL\t\t\t0xA\n#define DSB_BYTE_EN\t\t\t0xF\n#define DSB_BYTE_EN_SHIFT\t\t20\n#define DSB_REG_VALUE_MASK\t\t0xfffff\n\nstatic bool assert_dsb_has_room(struct intel_dsb *dsb)\n{\n\tstruct intel_crtc *crtc = dsb->crtc;\n\tstruct drm_i915_private *i915 = to_i915(crtc->base.dev);\n\n\t \n\treturn !drm_WARN(&i915->drm, dsb->free_pos > dsb->size - 2,\n\t\t\t \"[CRTC:%d:%s] DSB %d buffer overflow\\n\",\n\t\t\t crtc->base.base.id, crtc->base.name, dsb->id);\n}\n\nstatic bool is_dsb_busy(struct drm_i915_private *i915, enum pipe pipe,\n\t\t\tenum dsb_id id)\n{\n\treturn intel_de_read(i915, DSB_CTRL(pipe, id)) & DSB_STATUS_BUSY;\n}\n\nstatic void intel_dsb_emit(struct intel_dsb *dsb, u32 ldw, u32 udw)\n{\n\tu32 *buf = dsb->cmd_buf;\n\n\tif (!assert_dsb_has_room(dsb))\n\t\treturn;\n\n\t \n\tdsb->free_pos = ALIGN(dsb->free_pos, 2);\n\n\tdsb->ins_start_offset = dsb->free_pos;\n\n\tbuf[dsb->free_pos++] = ldw;\n\tbuf[dsb->free_pos++] = udw;\n}\n\nstatic bool intel_dsb_prev_ins_is_write(struct intel_dsb *dsb,\n\t\t\t\t\tu32 opcode, i915_reg_t reg)\n{\n\tconst u32 *buf = dsb->cmd_buf;\n\tu32 prev_opcode, prev_reg;\n\n\tprev_opcode = buf[dsb->ins_start_offset + 1] >> DSB_OPCODE_SHIFT;\n\tprev_reg = buf[dsb->ins_start_offset + 1] & DSB_REG_VALUE_MASK;\n\n\treturn prev_opcode == opcode && prev_reg == i915_mmio_reg_offset(reg);\n}\n\nstatic bool intel_dsb_prev_ins_is_mmio_write(struct intel_dsb *dsb, i915_reg_t reg)\n{\n\treturn intel_dsb_prev_ins_is_write(dsb, DSB_OPCODE_MMIO_WRITE, reg);\n}\n\nstatic bool intel_dsb_prev_ins_is_indexed_write(struct intel_dsb *dsb, i915_reg_t reg)\n{\n\treturn intel_dsb_prev_ins_is_write(dsb, DSB_OPCODE_INDEXED_WRITE, reg);\n}\n\n \nvoid intel_dsb_reg_write(struct intel_dsb *dsb,\n\t\t\t i915_reg_t reg, u32 val)\n{\n\t \n\tif (!intel_dsb_prev_ins_is_mmio_write(dsb, reg) &&\n\t    !intel_dsb_prev_ins_is_indexed_write(dsb, reg)) {\n\t\tintel_dsb_emit(dsb, val,\n\t\t\t       (DSB_OPCODE_MMIO_WRITE << DSB_OPCODE_SHIFT) |\n\t\t\t       (DSB_BYTE_EN << DSB_BYTE_EN_SHIFT) |\n\t\t\t       i915_mmio_reg_offset(reg));\n\t} else {\n\t\tu32 *buf = dsb->cmd_buf;\n\n\t\tif (!assert_dsb_has_room(dsb))\n\t\t\treturn;\n\n\t\t \n\t\tif (intel_dsb_prev_ins_is_mmio_write(dsb, reg)) {\n\t\t\tu32 prev_val = buf[dsb->ins_start_offset + 0];\n\n\t\t\tbuf[dsb->ins_start_offset + 0] = 1;  \n\t\t\tbuf[dsb->ins_start_offset + 1] =\n\t\t\t\t(DSB_OPCODE_INDEXED_WRITE << DSB_OPCODE_SHIFT) |\n\t\t\t\ti915_mmio_reg_offset(reg);\n\t\t\tbuf[dsb->ins_start_offset + 2] = prev_val;\n\n\t\t\tdsb->free_pos++;\n\t\t}\n\n\t\tbuf[dsb->free_pos++] = val;\n\t\t \n\t\tbuf[dsb->ins_start_offset]++;\n\n\t\t \n\t\tif (dsb->free_pos & 0x1)\n\t\t\tbuf[dsb->free_pos] = 0;\n\t}\n}\n\nstatic void intel_dsb_align_tail(struct intel_dsb *dsb)\n{\n\tu32 aligned_tail, tail;\n\n\ttail = dsb->free_pos * 4;\n\taligned_tail = ALIGN(tail, CACHELINE_BYTES);\n\n\tif (aligned_tail > tail)\n\t\tmemset(&dsb->cmd_buf[dsb->free_pos], 0,\n\t\t       aligned_tail - tail);\n\n\tdsb->free_pos = aligned_tail / 4;\n}\n\nvoid intel_dsb_finish(struct intel_dsb *dsb)\n{\n\tintel_dsb_align_tail(dsb);\n}\n\n \nvoid intel_dsb_commit(struct intel_dsb *dsb, bool wait_for_vblank)\n{\n\tstruct intel_crtc *crtc = dsb->crtc;\n\tstruct drm_i915_private *dev_priv = to_i915(crtc->base.dev);\n\tenum pipe pipe = crtc->pipe;\n\tu32 tail;\n\n\ttail = dsb->free_pos * 4;\n\tif (drm_WARN_ON(&dev_priv->drm, !IS_ALIGNED(tail, CACHELINE_BYTES)))\n\t\treturn;\n\n\tif (is_dsb_busy(dev_priv, pipe, dsb->id)) {\n\t\tdrm_err(&dev_priv->drm, \"[CRTC:%d:%s] DSB %d is busy\\n\",\n\t\t\tcrtc->base.base.id, crtc->base.name, dsb->id);\n\t\treturn;\n\t}\n\n\tintel_de_write(dev_priv, DSB_CTRL(pipe, dsb->id),\n\t\t       (wait_for_vblank ? DSB_WAIT_FOR_VBLANK : 0) |\n\t\t       DSB_ENABLE);\n\tintel_de_write(dev_priv, DSB_HEAD(pipe, dsb->id),\n\t\t       i915_ggtt_offset(dsb->vma));\n\tintel_de_write(dev_priv, DSB_TAIL(pipe, dsb->id),\n\t\t       i915_ggtt_offset(dsb->vma) + tail);\n}\n\nvoid intel_dsb_wait(struct intel_dsb *dsb)\n{\n\tstruct intel_crtc *crtc = dsb->crtc;\n\tstruct drm_i915_private *dev_priv = to_i915(crtc->base.dev);\n\tenum pipe pipe = crtc->pipe;\n\n\tif (wait_for(!is_dsb_busy(dev_priv, pipe, dsb->id), 1))\n\t\tdrm_err(&dev_priv->drm,\n\t\t\t\"[CRTC:%d:%s] DSB %d timed out waiting for idle\\n\",\n\t\t\tcrtc->base.base.id, crtc->base.name, dsb->id);\n\n\t \n\tdsb->free_pos = 0;\n\tdsb->ins_start_offset = 0;\n\tintel_de_write(dev_priv, DSB_CTRL(pipe, dsb->id), 0);\n}\n\n \nstruct intel_dsb *intel_dsb_prepare(struct intel_crtc *crtc,\n\t\t\t\t    unsigned int max_cmds)\n{\n\tstruct drm_i915_private *i915 = to_i915(crtc->base.dev);\n\tstruct drm_i915_gem_object *obj;\n\tintel_wakeref_t wakeref;\n\tstruct intel_dsb *dsb;\n\tstruct i915_vma *vma;\n\tunsigned int size;\n\tu32 *buf;\n\n\tif (!HAS_DSB(i915))\n\t\treturn NULL;\n\n\tdsb = kzalloc(sizeof(*dsb), GFP_KERNEL);\n\tif (!dsb)\n\t\tgoto out;\n\n\twakeref = intel_runtime_pm_get(&i915->runtime_pm);\n\n\t \n\tsize = ALIGN(max_cmds * 8, CACHELINE_BYTES);\n\n\tobj = i915_gem_object_create_internal(i915, PAGE_ALIGN(size));\n\tif (IS_ERR(obj))\n\t\tgoto out_put_rpm;\n\n\tvma = i915_gem_object_ggtt_pin(obj, NULL, 0, 0, 0);\n\tif (IS_ERR(vma)) {\n\t\ti915_gem_object_put(obj);\n\t\tgoto out_put_rpm;\n\t}\n\n\tbuf = i915_gem_object_pin_map_unlocked(vma->obj, I915_MAP_WC);\n\tif (IS_ERR(buf)) {\n\t\ti915_vma_unpin_and_release(&vma, I915_VMA_RELEASE_MAP);\n\t\tgoto out_put_rpm;\n\t}\n\n\tintel_runtime_pm_put(&i915->runtime_pm, wakeref);\n\n\tdsb->id = DSB1;\n\tdsb->vma = vma;\n\tdsb->crtc = crtc;\n\tdsb->cmd_buf = buf;\n\tdsb->size = size / 4;  \n\tdsb->free_pos = 0;\n\tdsb->ins_start_offset = 0;\n\n\treturn dsb;\n\nout_put_rpm:\n\tintel_runtime_pm_put(&i915->runtime_pm, wakeref);\n\tkfree(dsb);\nout:\n\tdrm_info_once(&i915->drm,\n\t\t      \"[CRTC:%d:%s] DSB %d queue setup failed, will fallback to MMIO for display HW programming\\n\",\n\t\t      crtc->base.base.id, crtc->base.name, DSB1);\n\n\treturn NULL;\n}\n\n \nvoid intel_dsb_cleanup(struct intel_dsb *dsb)\n{\n\ti915_vma_unpin_and_release(&dsb->vma, I915_VMA_RELEASE_MAP);\n\tkfree(dsb);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}