{
  "module_name": "intel_lvds.c",
  "hash_id": "4ed3da9b3f6122b835d305949b3d3c930cbd73c34249a4021dfa582212f1fd27",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/i915/display/intel_lvds.c",
  "human_readable_source": " \n\n#include <acpi/button.h>\n#include <linux/acpi.h>\n#include <linux/dmi.h>\n#include <linux/i2c.h>\n#include <linux/slab.h>\n#include <linux/vga_switcheroo.h>\n\n#include <drm/drm_atomic_helper.h>\n#include <drm/drm_crtc.h>\n#include <drm/drm_edid.h>\n\n#include \"i915_drv.h\"\n#include \"i915_reg.h\"\n#include \"intel_atomic.h\"\n#include \"intel_backlight.h\"\n#include \"intel_connector.h\"\n#include \"intel_de.h\"\n#include \"intel_display_types.h\"\n#include \"intel_dpll.h\"\n#include \"intel_fdi.h\"\n#include \"intel_gmbus.h\"\n#include \"intel_lvds.h\"\n#include \"intel_lvds_regs.h\"\n#include \"intel_panel.h\"\n#include \"intel_pps_regs.h\"\n\n \nstruct intel_lvds_pps {\n\t \n\tint t1_t2;\n\tint t3;\n\tint t4;\n\tint t5;\n\tint tx;\n\n\tint divider;\n\n\tint port;\n\tbool powerdown_on_reset;\n};\n\nstruct intel_lvds_encoder {\n\tstruct intel_encoder base;\n\n\tbool is_dual_link;\n\ti915_reg_t reg;\n\tu32 a3_power;\n\n\tstruct intel_lvds_pps init_pps;\n\tu32 init_lvds_val;\n\n\tstruct intel_connector *attached_connector;\n};\n\nstatic struct intel_lvds_encoder *to_lvds_encoder(struct intel_encoder *encoder)\n{\n\treturn container_of(encoder, struct intel_lvds_encoder, base);\n}\n\nbool intel_lvds_port_enabled(struct drm_i915_private *i915,\n\t\t\t     i915_reg_t lvds_reg, enum pipe *pipe)\n{\n\tu32 val;\n\n\tval = intel_de_read(i915, lvds_reg);\n\n\t \n\tif (HAS_PCH_CPT(i915))\n\t\t*pipe = REG_FIELD_GET(LVDS_PIPE_SEL_MASK_CPT, val);\n\telse\n\t\t*pipe = REG_FIELD_GET(LVDS_PIPE_SEL_MASK, val);\n\n\treturn val & LVDS_PORT_EN;\n}\n\nstatic bool intel_lvds_get_hw_state(struct intel_encoder *encoder,\n\t\t\t\t    enum pipe *pipe)\n{\n\tstruct drm_i915_private *i915 = to_i915(encoder->base.dev);\n\tstruct intel_lvds_encoder *lvds_encoder = to_lvds_encoder(encoder);\n\tintel_wakeref_t wakeref;\n\tbool ret;\n\n\twakeref = intel_display_power_get_if_enabled(i915, encoder->power_domain);\n\tif (!wakeref)\n\t\treturn false;\n\n\tret = intel_lvds_port_enabled(i915, lvds_encoder->reg, pipe);\n\n\tintel_display_power_put(i915, encoder->power_domain, wakeref);\n\n\treturn ret;\n}\n\nstatic void intel_lvds_get_config(struct intel_encoder *encoder,\n\t\t\t\t  struct intel_crtc_state *crtc_state)\n{\n\tstruct drm_i915_private *dev_priv = to_i915(encoder->base.dev);\n\tstruct intel_lvds_encoder *lvds_encoder = to_lvds_encoder(encoder);\n\tu32 tmp, flags = 0;\n\n\tcrtc_state->output_types |= BIT(INTEL_OUTPUT_LVDS);\n\n\ttmp = intel_de_read(dev_priv, lvds_encoder->reg);\n\tif (tmp & LVDS_HSYNC_POLARITY)\n\t\tflags |= DRM_MODE_FLAG_NHSYNC;\n\telse\n\t\tflags |= DRM_MODE_FLAG_PHSYNC;\n\tif (tmp & LVDS_VSYNC_POLARITY)\n\t\tflags |= DRM_MODE_FLAG_NVSYNC;\n\telse\n\t\tflags |= DRM_MODE_FLAG_PVSYNC;\n\n\tcrtc_state->hw.adjusted_mode.flags |= flags;\n\n\tif (DISPLAY_VER(dev_priv) < 5)\n\t\tcrtc_state->gmch_pfit.lvds_border_bits =\n\t\t\ttmp & LVDS_BORDER_ENABLE;\n\n\t \n\tif (DISPLAY_VER(dev_priv) < 4) {\n\t\ttmp = intel_de_read(dev_priv, PFIT_CONTROL);\n\n\t\tcrtc_state->gmch_pfit.control |= tmp & PFIT_PANEL_8TO6_DITHER_ENABLE;\n\t}\n\n\tcrtc_state->hw.adjusted_mode.crtc_clock = crtc_state->port_clock;\n}\n\nstatic void intel_lvds_pps_get_hw_state(struct drm_i915_private *dev_priv,\n\t\t\t\t\tstruct intel_lvds_pps *pps)\n{\n\tu32 val;\n\n\tpps->powerdown_on_reset = intel_de_read(dev_priv, PP_CONTROL(0)) & PANEL_POWER_RESET;\n\n\tval = intel_de_read(dev_priv, PP_ON_DELAYS(0));\n\tpps->port = REG_FIELD_GET(PANEL_PORT_SELECT_MASK, val);\n\tpps->t1_t2 = REG_FIELD_GET(PANEL_POWER_UP_DELAY_MASK, val);\n\tpps->t5 = REG_FIELD_GET(PANEL_LIGHT_ON_DELAY_MASK, val);\n\n\tval = intel_de_read(dev_priv, PP_OFF_DELAYS(0));\n\tpps->t3 = REG_FIELD_GET(PANEL_POWER_DOWN_DELAY_MASK, val);\n\tpps->tx = REG_FIELD_GET(PANEL_LIGHT_OFF_DELAY_MASK, val);\n\n\tval = intel_de_read(dev_priv, PP_DIVISOR(0));\n\tpps->divider = REG_FIELD_GET(PP_REFERENCE_DIVIDER_MASK, val);\n\tval = REG_FIELD_GET(PANEL_POWER_CYCLE_DELAY_MASK, val);\n\t \n\tif (val)\n\t\tval--;\n\t \n\tpps->t4 = val * 1000;\n\n\tif (DISPLAY_VER(dev_priv) <= 4 &&\n\t    pps->t1_t2 == 0 && pps->t5 == 0 && pps->t3 == 0 && pps->tx == 0) {\n\t\tdrm_dbg_kms(&dev_priv->drm,\n\t\t\t    \"Panel power timings uninitialized, \"\n\t\t\t    \"setting defaults\\n\");\n\t\t \n\t\tpps->t1_t2 = 40 * 10;\n\t\tpps->t5 = 200 * 10;\n\t\t \n\t\tpps->t3 = 35 * 10;\n\t\tpps->tx = 200 * 10;\n\t}\n\n\tdrm_dbg(&dev_priv->drm, \"LVDS PPS:t1+t2 %d t3 %d t4 %d t5 %d tx %d \"\n\t\t\"divider %d port %d powerdown_on_reset %d\\n\",\n\t\tpps->t1_t2, pps->t3, pps->t4, pps->t5, pps->tx,\n\t\tpps->divider, pps->port, pps->powerdown_on_reset);\n}\n\nstatic void intel_lvds_pps_init_hw(struct drm_i915_private *dev_priv,\n\t\t\t\t   struct intel_lvds_pps *pps)\n{\n\tu32 val;\n\n\tval = intel_de_read(dev_priv, PP_CONTROL(0));\n\tdrm_WARN_ON(&dev_priv->drm,\n\t\t    (val & PANEL_UNLOCK_MASK) != PANEL_UNLOCK_REGS);\n\tif (pps->powerdown_on_reset)\n\t\tval |= PANEL_POWER_RESET;\n\tintel_de_write(dev_priv, PP_CONTROL(0), val);\n\n\tintel_de_write(dev_priv, PP_ON_DELAYS(0),\n\t\t       REG_FIELD_PREP(PANEL_PORT_SELECT_MASK, pps->port) |\n\t\t       REG_FIELD_PREP(PANEL_POWER_UP_DELAY_MASK, pps->t1_t2) |\n\t\t       REG_FIELD_PREP(PANEL_LIGHT_ON_DELAY_MASK, pps->t5));\n\n\tintel_de_write(dev_priv, PP_OFF_DELAYS(0),\n\t\t       REG_FIELD_PREP(PANEL_POWER_DOWN_DELAY_MASK, pps->t3) |\n\t\t       REG_FIELD_PREP(PANEL_LIGHT_OFF_DELAY_MASK, pps->tx));\n\n\tintel_de_write(dev_priv, PP_DIVISOR(0),\n\t\t       REG_FIELD_PREP(PP_REFERENCE_DIVIDER_MASK, pps->divider) |\n\t\t       REG_FIELD_PREP(PANEL_POWER_CYCLE_DELAY_MASK, DIV_ROUND_UP(pps->t4, 1000) + 1));\n}\n\nstatic void intel_pre_enable_lvds(struct intel_atomic_state *state,\n\t\t\t\t  struct intel_encoder *encoder,\n\t\t\t\t  const struct intel_crtc_state *crtc_state,\n\t\t\t\t  const struct drm_connector_state *conn_state)\n{\n\tstruct intel_lvds_encoder *lvds_encoder = to_lvds_encoder(encoder);\n\tstruct drm_i915_private *i915 = to_i915(encoder->base.dev);\n\tstruct intel_crtc *crtc = to_intel_crtc(crtc_state->uapi.crtc);\n\tconst struct drm_display_mode *adjusted_mode = &crtc_state->hw.adjusted_mode;\n\tenum pipe pipe = crtc->pipe;\n\tu32 temp;\n\n\tif (HAS_PCH_SPLIT(i915)) {\n\t\tassert_fdi_rx_pll_disabled(i915, pipe);\n\t\tassert_shared_dpll_disabled(i915, crtc_state->shared_dpll);\n\t} else {\n\t\tassert_pll_disabled(i915, pipe);\n\t}\n\n\tintel_lvds_pps_init_hw(i915, &lvds_encoder->init_pps);\n\n\ttemp = lvds_encoder->init_lvds_val;\n\ttemp |= LVDS_PORT_EN | LVDS_A0A2_CLKA_POWER_UP;\n\n\tif (HAS_PCH_CPT(i915)) {\n\t\ttemp &= ~LVDS_PIPE_SEL_MASK_CPT;\n\t\ttemp |= LVDS_PIPE_SEL_CPT(pipe);\n\t} else {\n\t\ttemp &= ~LVDS_PIPE_SEL_MASK;\n\t\ttemp |= LVDS_PIPE_SEL(pipe);\n\t}\n\n\t \n\ttemp &= ~LVDS_BORDER_ENABLE;\n\ttemp |= crtc_state->gmch_pfit.lvds_border_bits;\n\n\t \n\tif (lvds_encoder->is_dual_link)\n\t\ttemp |= LVDS_B0B3_POWER_UP | LVDS_CLKB_POWER_UP;\n\telse\n\t\ttemp &= ~(LVDS_B0B3_POWER_UP | LVDS_CLKB_POWER_UP);\n\n\t \n\ttemp &= ~LVDS_A3_POWER_MASK;\n\ttemp |= lvds_encoder->a3_power;\n\n\t \n\tif (DISPLAY_VER(i915) == 4) {\n\t\t \n\t\tif (crtc_state->dither && crtc_state->pipe_bpp == 18)\n\t\t\ttemp |= LVDS_ENABLE_DITHER;\n\t\telse\n\t\t\ttemp &= ~LVDS_ENABLE_DITHER;\n\t}\n\ttemp &= ~(LVDS_HSYNC_POLARITY | LVDS_VSYNC_POLARITY);\n\tif (adjusted_mode->flags & DRM_MODE_FLAG_NHSYNC)\n\t\ttemp |= LVDS_HSYNC_POLARITY;\n\tif (adjusted_mode->flags & DRM_MODE_FLAG_NVSYNC)\n\t\ttemp |= LVDS_VSYNC_POLARITY;\n\n\tintel_de_write(i915, lvds_encoder->reg, temp);\n}\n\n \nstatic void intel_enable_lvds(struct intel_atomic_state *state,\n\t\t\t      struct intel_encoder *encoder,\n\t\t\t      const struct intel_crtc_state *crtc_state,\n\t\t\t      const struct drm_connector_state *conn_state)\n{\n\tstruct intel_lvds_encoder *lvds_encoder = to_lvds_encoder(encoder);\n\tstruct drm_i915_private *dev_priv = to_i915(encoder->base.dev);\n\n\tintel_de_rmw(dev_priv, lvds_encoder->reg, 0, LVDS_PORT_EN);\n\n\tintel_de_rmw(dev_priv, PP_CONTROL(0), 0, PANEL_POWER_ON);\n\tintel_de_posting_read(dev_priv, lvds_encoder->reg);\n\n\tif (intel_de_wait_for_set(dev_priv, PP_STATUS(0), PP_ON, 5000))\n\t\tdrm_err(&dev_priv->drm,\n\t\t\t\"timed out waiting for panel to power on\\n\");\n\n\tintel_backlight_enable(crtc_state, conn_state);\n}\n\nstatic void intel_disable_lvds(struct intel_atomic_state *state,\n\t\t\t       struct intel_encoder *encoder,\n\t\t\t       const struct intel_crtc_state *old_crtc_state,\n\t\t\t       const struct drm_connector_state *old_conn_state)\n{\n\tstruct intel_lvds_encoder *lvds_encoder = to_lvds_encoder(encoder);\n\tstruct drm_i915_private *dev_priv = to_i915(encoder->base.dev);\n\n\tintel_de_rmw(dev_priv, PP_CONTROL(0), PANEL_POWER_ON, 0);\n\tif (intel_de_wait_for_clear(dev_priv, PP_STATUS(0), PP_ON, 1000))\n\t\tdrm_err(&dev_priv->drm,\n\t\t\t\"timed out waiting for panel to power off\\n\");\n\n\tintel_de_rmw(dev_priv, lvds_encoder->reg, LVDS_PORT_EN, 0);\n\tintel_de_posting_read(dev_priv, lvds_encoder->reg);\n}\n\nstatic void gmch_disable_lvds(struct intel_atomic_state *state,\n\t\t\t      struct intel_encoder *encoder,\n\t\t\t      const struct intel_crtc_state *old_crtc_state,\n\t\t\t      const struct drm_connector_state *old_conn_state)\n\n{\n\tintel_backlight_disable(old_conn_state);\n\n\tintel_disable_lvds(state, encoder, old_crtc_state, old_conn_state);\n}\n\nstatic void pch_disable_lvds(struct intel_atomic_state *state,\n\t\t\t     struct intel_encoder *encoder,\n\t\t\t     const struct intel_crtc_state *old_crtc_state,\n\t\t\t     const struct drm_connector_state *old_conn_state)\n{\n\tintel_backlight_disable(old_conn_state);\n}\n\nstatic void pch_post_disable_lvds(struct intel_atomic_state *state,\n\t\t\t\t  struct intel_encoder *encoder,\n\t\t\t\t  const struct intel_crtc_state *old_crtc_state,\n\t\t\t\t  const struct drm_connector_state *old_conn_state)\n{\n\tintel_disable_lvds(state, encoder, old_crtc_state, old_conn_state);\n}\n\nstatic void intel_lvds_shutdown(struct intel_encoder *encoder)\n{\n\tstruct drm_i915_private *dev_priv = to_i915(encoder->base.dev);\n\n\tif (intel_de_wait_for_clear(dev_priv, PP_STATUS(0), PP_CYCLE_DELAY_ACTIVE, 5000))\n\t\tdrm_err(&dev_priv->drm,\n\t\t\t\"timed out waiting for panel power cycle delay\\n\");\n}\n\nstatic enum drm_mode_status\nintel_lvds_mode_valid(struct drm_connector *_connector,\n\t\t      struct drm_display_mode *mode)\n{\n\tstruct intel_connector *connector = to_intel_connector(_connector);\n\tstruct drm_i915_private *i915 = to_i915(connector->base.dev);\n\tconst struct drm_display_mode *fixed_mode =\n\t\tintel_panel_fixed_mode(connector, mode);\n\tint max_pixclk = to_i915(connector->base.dev)->max_dotclk_freq;\n\tenum drm_mode_status status;\n\n\tstatus = intel_cpu_transcoder_mode_valid(i915, mode);\n\tif (status != MODE_OK)\n\t\treturn status;\n\n\tif (mode->flags & DRM_MODE_FLAG_DBLSCAN)\n\t\treturn MODE_NO_DBLESCAN;\n\n\tstatus = intel_panel_mode_valid(connector, mode);\n\tif (status != MODE_OK)\n\t\treturn status;\n\n\tif (fixed_mode->clock > max_pixclk)\n\t\treturn MODE_CLOCK_HIGH;\n\n\treturn MODE_OK;\n}\n\nstatic int intel_lvds_compute_config(struct intel_encoder *encoder,\n\t\t\t\t     struct intel_crtc_state *crtc_state,\n\t\t\t\t     struct drm_connector_state *conn_state)\n{\n\tstruct drm_i915_private *i915 = to_i915(encoder->base.dev);\n\tstruct intel_lvds_encoder *lvds_encoder = to_lvds_encoder(encoder);\n\tstruct intel_connector *connector = lvds_encoder->attached_connector;\n\tstruct drm_display_mode *adjusted_mode = &crtc_state->hw.adjusted_mode;\n\tstruct intel_crtc *crtc = to_intel_crtc(crtc_state->uapi.crtc);\n\tunsigned int lvds_bpp;\n\tint ret;\n\n\t \n\tif (DISPLAY_VER(i915) < 4 && crtc->pipe == 0) {\n\t\tdrm_err(&i915->drm, \"Can't support LVDS on pipe A\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (lvds_encoder->a3_power == LVDS_A3_POWER_UP)\n\t\tlvds_bpp = 8*3;\n\telse\n\t\tlvds_bpp = 6*3;\n\n\tif (lvds_bpp != crtc_state->pipe_bpp && !crtc_state->bw_constrained) {\n\t\tdrm_dbg_kms(&i915->drm,\n\t\t\t    \"forcing display bpp (was %d) to LVDS (%d)\\n\",\n\t\t\t    crtc_state->pipe_bpp, lvds_bpp);\n\t\tcrtc_state->pipe_bpp = lvds_bpp;\n\t}\n\n\tcrtc_state->sink_format = INTEL_OUTPUT_FORMAT_RGB;\n\tcrtc_state->output_format = INTEL_OUTPUT_FORMAT_RGB;\n\n\t \n\tret = intel_panel_compute_config(connector, adjusted_mode);\n\tif (ret)\n\t\treturn ret;\n\n\tif (adjusted_mode->flags & DRM_MODE_FLAG_DBLSCAN)\n\t\treturn -EINVAL;\n\n\tif (HAS_PCH_SPLIT(i915))\n\t\tcrtc_state->has_pch_encoder = true;\n\n\tret = intel_panel_fitting(crtc_state, conn_state);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\n\treturn 0;\n}\n\n \nstatic int intel_lvds_get_modes(struct drm_connector *_connector)\n{\n\tstruct intel_connector *connector = to_intel_connector(_connector);\n\tconst struct drm_edid *fixed_edid = connector->panel.fixed_edid;\n\n\t \n\tif (!IS_ERR_OR_NULL(fixed_edid)) {\n\t\tdrm_edid_connector_update(&connector->base, fixed_edid);\n\n\t\treturn drm_edid_connector_add_modes(&connector->base);\n\t}\n\n\treturn intel_panel_get_modes(connector);\n}\n\nstatic const struct drm_connector_helper_funcs intel_lvds_connector_helper_funcs = {\n\t.get_modes = intel_lvds_get_modes,\n\t.mode_valid = intel_lvds_mode_valid,\n\t.atomic_check = intel_digital_connector_atomic_check,\n};\n\nstatic const struct drm_connector_funcs intel_lvds_connector_funcs = {\n\t.detect = intel_panel_detect,\n\t.fill_modes = drm_helper_probe_single_connector_modes,\n\t.atomic_get_property = intel_digital_connector_atomic_get_property,\n\t.atomic_set_property = intel_digital_connector_atomic_set_property,\n\t.late_register = intel_connector_register,\n\t.early_unregister = intel_connector_unregister,\n\t.destroy = intel_connector_destroy,\n\t.atomic_destroy_state = drm_atomic_helper_connector_destroy_state,\n\t.atomic_duplicate_state = intel_digital_connector_duplicate_state,\n};\n\nstatic const struct drm_encoder_funcs intel_lvds_enc_funcs = {\n\t.destroy = intel_encoder_destroy,\n};\n\nstatic int intel_no_lvds_dmi_callback(const struct dmi_system_id *id)\n{\n\tDRM_INFO(\"Skipping LVDS initialization for %s\\n\", id->ident);\n\treturn 1;\n}\n\n \nstatic const struct dmi_system_id intel_no_lvds[] = {\n\t{\n\t\t.callback = intel_no_lvds_dmi_callback,\n\t\t.ident = \"Apple Mac Mini (Core series)\",\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"Apple\"),\n\t\t\tDMI_MATCH(DMI_PRODUCT_NAME, \"Macmini1,1\"),\n\t\t},\n\t},\n\t{\n\t\t.callback = intel_no_lvds_dmi_callback,\n\t\t.ident = \"Apple Mac Mini (Core 2 series)\",\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"Apple\"),\n\t\t\tDMI_MATCH(DMI_PRODUCT_NAME, \"Macmini2,1\"),\n\t\t},\n\t},\n\t{\n\t\t.callback = intel_no_lvds_dmi_callback,\n\t\t.ident = \"MSI IM-945GSE-A\",\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"MSI\"),\n\t\t\tDMI_MATCH(DMI_PRODUCT_NAME, \"A9830IMS\"),\n\t\t},\n\t},\n\t{\n\t\t.callback = intel_no_lvds_dmi_callback,\n\t\t.ident = \"Dell Studio Hybrid\",\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"Dell Inc.\"),\n\t\t\tDMI_MATCH(DMI_PRODUCT_NAME, \"Studio Hybrid 140g\"),\n\t\t},\n\t},\n\t{\n\t\t.callback = intel_no_lvds_dmi_callback,\n\t\t.ident = \"Dell OptiPlex FX170\",\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"Dell Inc.\"),\n\t\t\tDMI_MATCH(DMI_PRODUCT_NAME, \"OptiPlex FX170\"),\n\t\t},\n\t},\n\t{\n\t\t.callback = intel_no_lvds_dmi_callback,\n\t\t.ident = \"AOpen Mini PC\",\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"AOpen\"),\n\t\t\tDMI_MATCH(DMI_PRODUCT_NAME, \"i965GMx-IF\"),\n\t\t},\n\t},\n\t{\n\t\t.callback = intel_no_lvds_dmi_callback,\n\t\t.ident = \"AOpen Mini PC MP915\",\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_BOARD_VENDOR, \"AOpen\"),\n\t\t\tDMI_MATCH(DMI_BOARD_NAME, \"i915GMx-F\"),\n\t\t},\n\t},\n\t{\n\t\t.callback = intel_no_lvds_dmi_callback,\n\t\t.ident = \"AOpen i915GMm-HFS\",\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_BOARD_VENDOR, \"AOpen\"),\n\t\t\tDMI_MATCH(DMI_BOARD_NAME, \"i915GMm-HFS\"),\n\t\t},\n\t},\n\t{\n\t\t.callback = intel_no_lvds_dmi_callback,\n\t\t.ident = \"AOpen i45GMx-I\",\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_BOARD_VENDOR, \"AOpen\"),\n\t\t\tDMI_MATCH(DMI_BOARD_NAME, \"i45GMx-I\"),\n\t\t},\n\t},\n\t{\n\t\t.callback = intel_no_lvds_dmi_callback,\n\t\t.ident = \"Aopen i945GTt-VFA\",\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_PRODUCT_VERSION, \"AO00001JW\"),\n\t\t},\n\t},\n\t{\n\t\t.callback = intel_no_lvds_dmi_callback,\n\t\t.ident = \"Clientron U800\",\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"Clientron\"),\n\t\t\tDMI_MATCH(DMI_PRODUCT_NAME, \"U800\"),\n\t\t},\n\t},\n\t{\n\t\t.callback = intel_no_lvds_dmi_callback,\n\t\t.ident = \"Clientron E830\",\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"Clientron\"),\n\t\t\tDMI_MATCH(DMI_PRODUCT_NAME, \"E830\"),\n\t\t},\n\t},\n\t{\n\t\t.callback = intel_no_lvds_dmi_callback,\n\t\t.ident = \"Asus EeeBox PC EB1007\",\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"ASUSTeK Computer INC.\"),\n\t\t\tDMI_MATCH(DMI_PRODUCT_NAME, \"EB1007\"),\n\t\t},\n\t},\n\t{\n\t\t.callback = intel_no_lvds_dmi_callback,\n\t\t.ident = \"Asus AT5NM10T-I\",\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_BOARD_VENDOR, \"ASUSTeK Computer INC.\"),\n\t\t\tDMI_MATCH(DMI_BOARD_NAME, \"AT5NM10T-I\"),\n\t\t},\n\t},\n\t{\n\t\t.callback = intel_no_lvds_dmi_callback,\n\t\t.ident = \"Hewlett-Packard HP t5740\",\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_BOARD_VENDOR, \"Hewlett-Packard\"),\n\t\t\tDMI_MATCH(DMI_PRODUCT_NAME, \" t5740\"),\n\t\t},\n\t},\n\t{\n\t\t.callback = intel_no_lvds_dmi_callback,\n\t\t.ident = \"Hewlett-Packard t5745\",\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_BOARD_VENDOR, \"Hewlett-Packard\"),\n\t\t\tDMI_MATCH(DMI_PRODUCT_NAME, \"hp t5745\"),\n\t\t},\n\t},\n\t{\n\t\t.callback = intel_no_lvds_dmi_callback,\n\t\t.ident = \"Hewlett-Packard st5747\",\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_BOARD_VENDOR, \"Hewlett-Packard\"),\n\t\t\tDMI_MATCH(DMI_PRODUCT_NAME, \"hp st5747\"),\n\t\t},\n\t},\n\t{\n\t\t.callback = intel_no_lvds_dmi_callback,\n\t\t.ident = \"MSI Wind Box DC500\",\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_BOARD_VENDOR, \"MICRO-STAR INTERNATIONAL CO., LTD\"),\n\t\t\tDMI_MATCH(DMI_BOARD_NAME, \"MS-7469\"),\n\t\t},\n\t},\n\t{\n\t\t.callback = intel_no_lvds_dmi_callback,\n\t\t.ident = \"Gigabyte GA-D525TUD\",\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_BOARD_VENDOR, \"Gigabyte Technology Co., Ltd.\"),\n\t\t\tDMI_MATCH(DMI_BOARD_NAME, \"D525TUD\"),\n\t\t},\n\t},\n\t{\n\t\t.callback = intel_no_lvds_dmi_callback,\n\t\t.ident = \"Supermicro X7SPA-H\",\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"Supermicro\"),\n\t\t\tDMI_MATCH(DMI_PRODUCT_NAME, \"X7SPA-H\"),\n\t\t},\n\t},\n\t{\n\t\t.callback = intel_no_lvds_dmi_callback,\n\t\t.ident = \"Fujitsu Esprimo Q900\",\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"FUJITSU\"),\n\t\t\tDMI_MATCH(DMI_PRODUCT_NAME, \"ESPRIMO Q900\"),\n\t\t},\n\t},\n\t{\n\t\t.callback = intel_no_lvds_dmi_callback,\n\t\t.ident = \"Intel D410PT\",\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_BOARD_VENDOR, \"Intel\"),\n\t\t\tDMI_MATCH(DMI_BOARD_NAME, \"D410PT\"),\n\t\t},\n\t},\n\t{\n\t\t.callback = intel_no_lvds_dmi_callback,\n\t\t.ident = \"Intel D425KT\",\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_BOARD_VENDOR, \"Intel\"),\n\t\t\tDMI_EXACT_MATCH(DMI_BOARD_NAME, \"D425KT\"),\n\t\t},\n\t},\n\t{\n\t\t.callback = intel_no_lvds_dmi_callback,\n\t\t.ident = \"Intel D510MO\",\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_BOARD_VENDOR, \"Intel\"),\n\t\t\tDMI_EXACT_MATCH(DMI_BOARD_NAME, \"D510MO\"),\n\t\t},\n\t},\n\t{\n\t\t.callback = intel_no_lvds_dmi_callback,\n\t\t.ident = \"Intel D525MW\",\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_BOARD_VENDOR, \"Intel\"),\n\t\t\tDMI_EXACT_MATCH(DMI_BOARD_NAME, \"D525MW\"),\n\t\t},\n\t},\n\t{\n\t\t.callback = intel_no_lvds_dmi_callback,\n\t\t.ident = \"Radiant P845\",\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"Radiant Systems Inc\"),\n\t\t\tDMI_MATCH(DMI_PRODUCT_NAME, \"P845\"),\n\t\t},\n\t},\n\n\t{ }\t \n};\n\nstatic int intel_dual_link_lvds_callback(const struct dmi_system_id *id)\n{\n\tDRM_INFO(\"Forcing lvds to dual link mode on %s\\n\", id->ident);\n\treturn 1;\n}\n\nstatic const struct dmi_system_id intel_dual_link_lvds[] = {\n\t{\n\t\t.callback = intel_dual_link_lvds_callback,\n\t\t.ident = \"Apple MacBook Pro 15\\\" (2010)\",\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"Apple Inc.\"),\n\t\t\tDMI_MATCH(DMI_PRODUCT_NAME, \"MacBookPro6,2\"),\n\t\t},\n\t},\n\t{\n\t\t.callback = intel_dual_link_lvds_callback,\n\t\t.ident = \"Apple MacBook Pro 15\\\" (2011)\",\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"Apple Inc.\"),\n\t\t\tDMI_MATCH(DMI_PRODUCT_NAME, \"MacBookPro8,2\"),\n\t\t},\n\t},\n\t{\n\t\t.callback = intel_dual_link_lvds_callback,\n\t\t.ident = \"Apple MacBook Pro 15\\\" (2012)\",\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"Apple Inc.\"),\n\t\t\tDMI_MATCH(DMI_PRODUCT_NAME, \"MacBookPro9,1\"),\n\t\t},\n\t},\n\t{ }\t \n};\n\nstruct intel_encoder *intel_get_lvds_encoder(struct drm_i915_private *i915)\n{\n\tstruct intel_encoder *encoder;\n\n\tfor_each_intel_encoder(&i915->drm, encoder) {\n\t\tif (encoder->type == INTEL_OUTPUT_LVDS)\n\t\t\treturn encoder;\n\t}\n\n\treturn NULL;\n}\n\nbool intel_is_dual_link_lvds(struct drm_i915_private *i915)\n{\n\tstruct intel_encoder *encoder = intel_get_lvds_encoder(i915);\n\n\treturn encoder && to_lvds_encoder(encoder)->is_dual_link;\n}\n\nstatic bool compute_is_dual_link_lvds(struct intel_lvds_encoder *lvds_encoder)\n{\n\tstruct drm_i915_private *i915 = to_i915(lvds_encoder->base.base.dev);\n\tstruct intel_connector *connector = lvds_encoder->attached_connector;\n\tconst struct drm_display_mode *fixed_mode =\n\t\tintel_panel_preferred_fixed_mode(connector);\n\tunsigned int val;\n\n\t \n\tif (i915->params.lvds_channel_mode > 0)\n\t\treturn i915->params.lvds_channel_mode == 2;\n\n\t \n\tif (fixed_mode->clock > 112999)\n\t\treturn true;\n\n\tif (dmi_check_system(intel_dual_link_lvds))\n\t\treturn true;\n\n\t \n\tval = intel_de_read(i915, lvds_encoder->reg);\n\tif (HAS_PCH_CPT(i915))\n\t\tval &= ~(LVDS_DETECTED | LVDS_PIPE_SEL_MASK_CPT);\n\telse\n\t\tval &= ~(LVDS_DETECTED | LVDS_PIPE_SEL_MASK);\n\tif (val == 0)\n\t\tval = connector->panel.vbt.bios_lvds_val;\n\n\treturn (val & LVDS_CLKB_POWER_MASK) == LVDS_CLKB_POWER_UP;\n}\n\nstatic void intel_lvds_add_properties(struct drm_connector *connector)\n{\n\tintel_attach_scaling_mode_property(connector);\n}\n\n \nvoid intel_lvds_init(struct drm_i915_private *i915)\n{\n\tstruct intel_lvds_encoder *lvds_encoder;\n\tstruct intel_connector *connector;\n\tconst struct drm_edid *drm_edid;\n\tstruct intel_encoder *encoder;\n\ti915_reg_t lvds_reg;\n\tu32 lvds;\n\tu8 pin;\n\n\t \n\tif (dmi_check_system(intel_no_lvds)) {\n\t\tdrm_WARN(&i915->drm, !i915->display.vbt.int_lvds_support,\n\t\t\t \"Useless DMI match. Internal LVDS support disabled by VBT\\n\");\n\t\treturn;\n\t}\n\n\tif (!i915->display.vbt.int_lvds_support) {\n\t\tdrm_dbg_kms(&i915->drm,\n\t\t\t    \"Internal LVDS support disabled by VBT\\n\");\n\t\treturn;\n\t}\n\n\tif (HAS_PCH_SPLIT(i915))\n\t\tlvds_reg = PCH_LVDS;\n\telse\n\t\tlvds_reg = LVDS;\n\n\tlvds = intel_de_read(i915, lvds_reg);\n\n\tif (HAS_PCH_SPLIT(i915)) {\n\t\tif ((lvds & LVDS_DETECTED) == 0)\n\t\t\treturn;\n\t}\n\n\tpin = GMBUS_PIN_PANEL;\n\tif (!intel_bios_is_lvds_present(i915, &pin)) {\n\t\tif ((lvds & LVDS_PORT_EN) == 0) {\n\t\t\tdrm_dbg_kms(&i915->drm,\n\t\t\t\t    \"LVDS is not present in VBT\\n\");\n\t\t\treturn;\n\t\t}\n\t\tdrm_dbg_kms(&i915->drm,\n\t\t\t    \"LVDS is not present in VBT, but enabled anyway\\n\");\n\t}\n\n\tlvds_encoder = kzalloc(sizeof(*lvds_encoder), GFP_KERNEL);\n\tif (!lvds_encoder)\n\t\treturn;\n\n\tconnector = intel_connector_alloc();\n\tif (!connector) {\n\t\tkfree(lvds_encoder);\n\t\treturn;\n\t}\n\n\tlvds_encoder->attached_connector = connector;\n\tencoder = &lvds_encoder->base;\n\n\tdrm_connector_init(&i915->drm, &connector->base, &intel_lvds_connector_funcs,\n\t\t\t   DRM_MODE_CONNECTOR_LVDS);\n\n\tdrm_encoder_init(&i915->drm, &encoder->base, &intel_lvds_enc_funcs,\n\t\t\t DRM_MODE_ENCODER_LVDS, \"LVDS\");\n\n\tencoder->enable = intel_enable_lvds;\n\tencoder->pre_enable = intel_pre_enable_lvds;\n\tencoder->compute_config = intel_lvds_compute_config;\n\tif (HAS_PCH_SPLIT(i915)) {\n\t\tencoder->disable = pch_disable_lvds;\n\t\tencoder->post_disable = pch_post_disable_lvds;\n\t} else {\n\t\tencoder->disable = gmch_disable_lvds;\n\t}\n\tencoder->get_hw_state = intel_lvds_get_hw_state;\n\tencoder->get_config = intel_lvds_get_config;\n\tencoder->update_pipe = intel_backlight_update;\n\tencoder->shutdown = intel_lvds_shutdown;\n\tconnector->get_hw_state = intel_connector_get_hw_state;\n\n\tintel_connector_attach_encoder(connector, encoder);\n\n\tencoder->type = INTEL_OUTPUT_LVDS;\n\tencoder->power_domain = POWER_DOMAIN_PORT_OTHER;\n\tencoder->port = PORT_NONE;\n\tencoder->cloneable = 0;\n\tif (DISPLAY_VER(i915) < 4)\n\t\tencoder->pipe_mask = BIT(PIPE_B);\n\telse\n\t\tencoder->pipe_mask = ~0;\n\n\tdrm_connector_helper_add(&connector->base, &intel_lvds_connector_helper_funcs);\n\tconnector->base.display_info.subpixel_order = SubPixelHorizontalRGB;\n\n\tlvds_encoder->reg = lvds_reg;\n\n\tintel_lvds_add_properties(&connector->base);\n\n\tintel_lvds_pps_get_hw_state(i915, &lvds_encoder->init_pps);\n\tlvds_encoder->init_lvds_val = lvds;\n\n\t \n\n\t \n\tmutex_lock(&i915->drm.mode_config.mutex);\n\tif (vga_switcheroo_handler_flags() & VGA_SWITCHEROO_CAN_SWITCH_DDC) {\n\t\tdrm_edid = drm_edid_read_switcheroo(&connector->base,\n\t\t\t\t\t\t    intel_gmbus_get_adapter(i915, pin));\n\t} else {\n\t\tdrm_edid = drm_edid_read_ddc(&connector->base,\n\t\t\t\t\t     intel_gmbus_get_adapter(i915, pin));\n\t}\n\tif (drm_edid) {\n\t\tif (drm_edid_connector_update(&connector->base, drm_edid) ||\n\t\t    !drm_edid_connector_add_modes(&connector->base)) {\n\t\t\tdrm_edid_connector_update(&connector->base, NULL);\n\t\t\tdrm_edid_free(drm_edid);\n\t\t\tdrm_edid = ERR_PTR(-EINVAL);\n\t\t}\n\t} else {\n\t\tdrm_edid = ERR_PTR(-ENOENT);\n\t}\n\tintel_bios_init_panel_late(i915, &connector->panel, NULL,\n\t\t\t\t   IS_ERR(drm_edid) ? NULL : drm_edid);\n\n\t \n\tintel_panel_add_edid_fixed_modes(connector, true);\n\n\t \n\tif (!intel_panel_preferred_fixed_mode(connector))\n\t\tintel_panel_add_vbt_lfp_fixed_mode(connector);\n\n\t \n\tif (!intel_panel_preferred_fixed_mode(connector))\n\t\tintel_panel_add_encoder_fixed_mode(connector, encoder);\n\n\tmutex_unlock(&i915->drm.mode_config.mutex);\n\n\t \n\tif (!intel_panel_preferred_fixed_mode(connector))\n\t\tgoto failed;\n\n\tintel_panel_init(connector, drm_edid);\n\n\tintel_backlight_setup(connector, INVALID_PIPE);\n\n\tlvds_encoder->is_dual_link = compute_is_dual_link_lvds(lvds_encoder);\n\tdrm_dbg_kms(&i915->drm, \"detected %s-link lvds configuration\\n\",\n\t\t    lvds_encoder->is_dual_link ? \"dual\" : \"single\");\n\n\tlvds_encoder->a3_power = lvds & LVDS_A3_POWER_MASK;\n\n\treturn;\n\nfailed:\n\tdrm_dbg_kms(&i915->drm, \"No LVDS modes found, disabling.\\n\");\n\tdrm_connector_cleanup(&connector->base);\n\tdrm_encoder_cleanup(&encoder->base);\n\tkfree(lvds_encoder);\n\tintel_connector_free(connector);\n\treturn;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}