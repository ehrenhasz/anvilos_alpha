{
  "module_name": "intel_display_debugfs.c",
  "hash_id": "010501c66b5fd82f634a6267e71dd6185ca7a749bfc86e3d85a998156a22315a",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/i915/display/intel_display_debugfs.c",
  "human_readable_source": "\n \n\n#include <linux/string_helpers.h>\n\n#include <drm/drm_debugfs.h>\n#include <drm/drm_edid.h>\n#include <drm/drm_fourcc.h>\n\n#include \"hsw_ips.h\"\n#include \"i915_debugfs.h\"\n#include \"i915_irq.h\"\n#include \"i915_reg.h\"\n#include \"intel_crtc.h\"\n#include \"intel_de.h\"\n#include \"intel_crtc_state_dump.h\"\n#include \"intel_display_debugfs.h\"\n#include \"intel_display_power.h\"\n#include \"intel_display_power_well.h\"\n#include \"intel_display_types.h\"\n#include \"intel_dmc.h\"\n#include \"intel_dp.h\"\n#include \"intel_dp_mst.h\"\n#include \"intel_drrs.h\"\n#include \"intel_fbc.h\"\n#include \"intel_fbdev.h\"\n#include \"intel_hdcp.h\"\n#include \"intel_hdmi.h\"\n#include \"intel_hotplug.h\"\n#include \"intel_panel.h\"\n#include \"intel_psr.h\"\n#include \"intel_psr_regs.h\"\n#include \"intel_wm.h\"\n\nstatic inline struct drm_i915_private *node_to_i915(struct drm_info_node *node)\n{\n\treturn to_i915(node->minor->dev);\n}\n\nstatic int i915_frontbuffer_tracking(struct seq_file *m, void *unused)\n{\n\tstruct drm_i915_private *dev_priv = node_to_i915(m->private);\n\n\tseq_printf(m, \"FB tracking busy bits: 0x%08x\\n\",\n\t\t   dev_priv->display.fb_tracking.busy_bits);\n\n\tseq_printf(m, \"FB tracking flip bits: 0x%08x\\n\",\n\t\t   dev_priv->display.fb_tracking.flip_bits);\n\n\treturn 0;\n}\n\nstatic int i915_sr_status(struct seq_file *m, void *unused)\n{\n\tstruct drm_i915_private *dev_priv = node_to_i915(m->private);\n\tintel_wakeref_t wakeref;\n\tbool sr_enabled = false;\n\n\twakeref = intel_display_power_get(dev_priv, POWER_DOMAIN_INIT);\n\n\tif (DISPLAY_VER(dev_priv) >= 9)\n\t\t ;\n\telse if (HAS_PCH_SPLIT(dev_priv))\n\t\tsr_enabled = intel_de_read(dev_priv, WM1_LP_ILK) & WM_LP_ENABLE;\n\telse if (IS_I965GM(dev_priv) || IS_G4X(dev_priv) ||\n\t\t IS_I945G(dev_priv) || IS_I945GM(dev_priv))\n\t\tsr_enabled = intel_de_read(dev_priv, FW_BLC_SELF) & FW_BLC_SELF_EN;\n\telse if (IS_I915GM(dev_priv))\n\t\tsr_enabled = intel_de_read(dev_priv, INSTPM) & INSTPM_SELF_EN;\n\telse if (IS_PINEVIEW(dev_priv))\n\t\tsr_enabled = intel_de_read(dev_priv, DSPFW3) & PINEVIEW_SELF_REFRESH_EN;\n\telse if (IS_VALLEYVIEW(dev_priv) || IS_CHERRYVIEW(dev_priv))\n\t\tsr_enabled = intel_de_read(dev_priv, FW_BLC_SELF_VLV) & FW_CSPWRDWNEN;\n\n\tintel_display_power_put(dev_priv, POWER_DOMAIN_INIT, wakeref);\n\n\tseq_printf(m, \"self-refresh: %s\\n\", str_enabled_disabled(sr_enabled));\n\n\treturn 0;\n}\n\nstatic int i915_opregion(struct seq_file *m, void *unused)\n{\n\tstruct drm_i915_private *i915 = node_to_i915(m->private);\n\tstruct intel_opregion *opregion = &i915->display.opregion;\n\n\tif (opregion->header)\n\t\tseq_write(m, opregion->header, OPREGION_SIZE);\n\n\treturn 0;\n}\n\nstatic int i915_vbt(struct seq_file *m, void *unused)\n{\n\tstruct drm_i915_private *i915 = node_to_i915(m->private);\n\tstruct intel_opregion *opregion = &i915->display.opregion;\n\n\tif (opregion->vbt)\n\t\tseq_write(m, opregion->vbt, opregion->vbt_size);\n\n\treturn 0;\n}\n\nstatic int i915_gem_framebuffer_info(struct seq_file *m, void *data)\n{\n\tstruct drm_i915_private *dev_priv = node_to_i915(m->private);\n\tstruct intel_framebuffer *fbdev_fb = NULL;\n\tstruct drm_framebuffer *drm_fb;\n\n#ifdef CONFIG_DRM_FBDEV_EMULATION\n\tfbdev_fb = intel_fbdev_framebuffer(dev_priv->display.fbdev.fbdev);\n\tif (fbdev_fb) {\n\t\tseq_printf(m, \"fbcon size: %d x %d, depth %d, %d bpp, modifier 0x%llx, refcount %d, obj \",\n\t\t\t   fbdev_fb->base.width,\n\t\t\t   fbdev_fb->base.height,\n\t\t\t   fbdev_fb->base.format->depth,\n\t\t\t   fbdev_fb->base.format->cpp[0] * 8,\n\t\t\t   fbdev_fb->base.modifier,\n\t\t\t   drm_framebuffer_read_refcount(&fbdev_fb->base));\n\t\ti915_debugfs_describe_obj(m, intel_fb_obj(&fbdev_fb->base));\n\t\tseq_putc(m, '\\n');\n\t}\n#endif\n\n\tmutex_lock(&dev_priv->drm.mode_config.fb_lock);\n\tdrm_for_each_fb(drm_fb, &dev_priv->drm) {\n\t\tstruct intel_framebuffer *fb = to_intel_framebuffer(drm_fb);\n\t\tif (fb == fbdev_fb)\n\t\t\tcontinue;\n\n\t\tseq_printf(m, \"user size: %d x %d, depth %d, %d bpp, modifier 0x%llx, refcount %d, obj \",\n\t\t\t   fb->base.width,\n\t\t\t   fb->base.height,\n\t\t\t   fb->base.format->depth,\n\t\t\t   fb->base.format->cpp[0] * 8,\n\t\t\t   fb->base.modifier,\n\t\t\t   drm_framebuffer_read_refcount(&fb->base));\n\t\ti915_debugfs_describe_obj(m, intel_fb_obj(&fb->base));\n\t\tseq_putc(m, '\\n');\n\t}\n\tmutex_unlock(&dev_priv->drm.mode_config.fb_lock);\n\n\treturn 0;\n}\n\nstatic int i915_power_domain_info(struct seq_file *m, void *unused)\n{\n\tstruct drm_i915_private *i915 = node_to_i915(m->private);\n\n\tintel_display_power_debug(i915, m);\n\n\treturn 0;\n}\n\nstatic void intel_seq_print_mode(struct seq_file *m, int tabs,\n\t\t\t\t const struct drm_display_mode *mode)\n{\n\tint i;\n\n\tfor (i = 0; i < tabs; i++)\n\t\tseq_putc(m, '\\t');\n\n\tseq_printf(m, DRM_MODE_FMT \"\\n\", DRM_MODE_ARG(mode));\n}\n\nstatic void intel_encoder_info(struct seq_file *m,\n\t\t\t       struct intel_crtc *crtc,\n\t\t\t       struct intel_encoder *encoder)\n{\n\tstruct drm_i915_private *dev_priv = node_to_i915(m->private);\n\tstruct drm_connector_list_iter conn_iter;\n\tstruct drm_connector *connector;\n\n\tseq_printf(m, \"\\t[ENCODER:%d:%s]: connectors:\\n\",\n\t\t   encoder->base.base.id, encoder->base.name);\n\n\tdrm_connector_list_iter_begin(&dev_priv->drm, &conn_iter);\n\tdrm_for_each_connector_iter(connector, &conn_iter) {\n\t\tconst struct drm_connector_state *conn_state =\n\t\t\tconnector->state;\n\n\t\tif (conn_state->best_encoder != &encoder->base)\n\t\t\tcontinue;\n\n\t\tseq_printf(m, \"\\t\\t[CONNECTOR:%d:%s]\\n\",\n\t\t\t   connector->base.id, connector->name);\n\t}\n\tdrm_connector_list_iter_end(&conn_iter);\n}\n\nstatic void intel_panel_info(struct seq_file *m,\n\t\t\t     struct intel_connector *connector)\n{\n\tconst struct drm_display_mode *fixed_mode;\n\n\tif (list_empty(&connector->panel.fixed_modes))\n\t\treturn;\n\n\tseq_puts(m, \"\\tfixed modes:\\n\");\n\n\tlist_for_each_entry(fixed_mode, &connector->panel.fixed_modes, head)\n\t\tintel_seq_print_mode(m, 2, fixed_mode);\n}\n\nstatic void intel_hdcp_info(struct seq_file *m,\n\t\t\t    struct intel_connector *intel_connector)\n{\n\tbool hdcp_cap, hdcp2_cap;\n\n\tif (!intel_connector->hdcp.shim) {\n\t\tseq_puts(m, \"No Connector Support\");\n\t\tgoto out;\n\t}\n\n\thdcp_cap = intel_hdcp_capable(intel_connector);\n\thdcp2_cap = intel_hdcp2_capable(intel_connector);\n\n\tif (hdcp_cap)\n\t\tseq_puts(m, \"HDCP1.4 \");\n\tif (hdcp2_cap)\n\t\tseq_puts(m, \"HDCP2.2 \");\n\n\tif (!hdcp_cap && !hdcp2_cap)\n\t\tseq_puts(m, \"None\");\n\nout:\n\tseq_puts(m, \"\\n\");\n}\n\nstatic void intel_dp_info(struct seq_file *m, struct intel_connector *connector)\n{\n\tstruct intel_encoder *intel_encoder = intel_attached_encoder(connector);\n\tstruct intel_dp *intel_dp = enc_to_intel_dp(intel_encoder);\n\tconst struct edid *edid = drm_edid_raw(connector->detect_edid);\n\n\tseq_printf(m, \"\\tDPCD rev: %x\\n\", intel_dp->dpcd[DP_DPCD_REV]);\n\tseq_printf(m, \"\\taudio support: %s\\n\",\n\t\t   str_yes_no(connector->base.display_info.has_audio));\n\n\tdrm_dp_downstream_debug(m, intel_dp->dpcd, intel_dp->downstream_ports,\n\t\t\t\tedid, &intel_dp->aux);\n}\n\nstatic void intel_dp_mst_info(struct seq_file *m,\n\t\t\t      struct intel_connector *connector)\n{\n\tbool has_audio = connector->base.display_info.has_audio;\n\n\tseq_printf(m, \"\\taudio support: %s\\n\", str_yes_no(has_audio));\n}\n\nstatic void intel_hdmi_info(struct seq_file *m,\n\t\t\t    struct intel_connector *connector)\n{\n\tbool has_audio = connector->base.display_info.has_audio;\n\n\tseq_printf(m, \"\\taudio support: %s\\n\", str_yes_no(has_audio));\n}\n\nstatic void intel_connector_info(struct seq_file *m,\n\t\t\t\t struct drm_connector *connector)\n{\n\tstruct intel_connector *intel_connector = to_intel_connector(connector);\n\tconst struct drm_connector_state *conn_state = connector->state;\n\tstruct intel_encoder *encoder =\n\t\tto_intel_encoder(conn_state->best_encoder);\n\tconst struct drm_display_mode *mode;\n\n\tseq_printf(m, \"[CONNECTOR:%d:%s]: status: %s\\n\",\n\t\t   connector->base.id, connector->name,\n\t\t   drm_get_connector_status_name(connector->status));\n\n\tif (connector->status == connector_status_disconnected)\n\t\treturn;\n\n\tseq_printf(m, \"\\tphysical dimensions: %dx%dmm\\n\",\n\t\t   connector->display_info.width_mm,\n\t\t   connector->display_info.height_mm);\n\tseq_printf(m, \"\\tsubpixel order: %s\\n\",\n\t\t   drm_get_subpixel_order_name(connector->display_info.subpixel_order));\n\tseq_printf(m, \"\\tCEA rev: %d\\n\", connector->display_info.cea_rev);\n\n\tif (!encoder)\n\t\treturn;\n\n\tswitch (connector->connector_type) {\n\tcase DRM_MODE_CONNECTOR_DisplayPort:\n\tcase DRM_MODE_CONNECTOR_eDP:\n\t\tif (encoder->type == INTEL_OUTPUT_DP_MST)\n\t\t\tintel_dp_mst_info(m, intel_connector);\n\t\telse\n\t\t\tintel_dp_info(m, intel_connector);\n\t\tbreak;\n\tcase DRM_MODE_CONNECTOR_HDMIA:\n\t\tif (encoder->type == INTEL_OUTPUT_HDMI ||\n\t\t    encoder->type == INTEL_OUTPUT_DDI)\n\t\t\tintel_hdmi_info(m, intel_connector);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tseq_puts(m, \"\\tHDCP version: \");\n\tintel_hdcp_info(m, intel_connector);\n\n\tseq_printf(m, \"\\tmax bpc: %u\\n\", connector->display_info.bpc);\n\n\tintel_panel_info(m, intel_connector);\n\n\tseq_printf(m, \"\\tmodes:\\n\");\n\tlist_for_each_entry(mode, &connector->modes, head)\n\t\tintel_seq_print_mode(m, 2, mode);\n}\n\nstatic const char *plane_type(enum drm_plane_type type)\n{\n\tswitch (type) {\n\tcase DRM_PLANE_TYPE_OVERLAY:\n\t\treturn \"OVL\";\n\tcase DRM_PLANE_TYPE_PRIMARY:\n\t\treturn \"PRI\";\n\tcase DRM_PLANE_TYPE_CURSOR:\n\t\treturn \"CUR\";\n\t \n\t}\n\n\treturn \"unknown\";\n}\n\nstatic void plane_rotation(char *buf, size_t bufsize, unsigned int rotation)\n{\n\t \n\tsnprintf(buf, bufsize,\n\t\t \"%s%s%s%s%s%s(0x%08x)\",\n\t\t (rotation & DRM_MODE_ROTATE_0) ? \"0 \" : \"\",\n\t\t (rotation & DRM_MODE_ROTATE_90) ? \"90 \" : \"\",\n\t\t (rotation & DRM_MODE_ROTATE_180) ? \"180 \" : \"\",\n\t\t (rotation & DRM_MODE_ROTATE_270) ? \"270 \" : \"\",\n\t\t (rotation & DRM_MODE_REFLECT_X) ? \"FLIPX \" : \"\",\n\t\t (rotation & DRM_MODE_REFLECT_Y) ? \"FLIPY \" : \"\",\n\t\t rotation);\n}\n\nstatic const char *plane_visibility(const struct intel_plane_state *plane_state)\n{\n\tif (plane_state->uapi.visible)\n\t\treturn \"visible\";\n\n\tif (plane_state->planar_slave)\n\t\treturn \"planar-slave\";\n\n\treturn \"hidden\";\n}\n\nstatic void intel_plane_uapi_info(struct seq_file *m, struct intel_plane *plane)\n{\n\tconst struct intel_plane_state *plane_state =\n\t\tto_intel_plane_state(plane->base.state);\n\tconst struct drm_framebuffer *fb = plane_state->uapi.fb;\n\tstruct drm_rect src, dst;\n\tchar rot_str[48];\n\n\tsrc = drm_plane_state_src(&plane_state->uapi);\n\tdst = drm_plane_state_dest(&plane_state->uapi);\n\n\tplane_rotation(rot_str, sizeof(rot_str),\n\t\t       plane_state->uapi.rotation);\n\n\tseq_puts(m, \"\\t\\tuapi: [FB:\");\n\tif (fb)\n\t\tseq_printf(m, \"%d] %p4cc,0x%llx,%dx%d\", fb->base.id,\n\t\t\t   &fb->format->format, fb->modifier, fb->width,\n\t\t\t   fb->height);\n\telse\n\t\tseq_puts(m, \"0] n/a,0x0,0x0,\");\n\tseq_printf(m, \", visible=%s, src=\" DRM_RECT_FP_FMT \", dst=\" DRM_RECT_FMT\n\t\t   \", rotation=%s\\n\", plane_visibility(plane_state),\n\t\t   DRM_RECT_FP_ARG(&src), DRM_RECT_ARG(&dst), rot_str);\n\n\tif (plane_state->planar_linked_plane)\n\t\tseq_printf(m, \"\\t\\tplanar: Linked to [PLANE:%d:%s] as a %s\\n\",\n\t\t\t   plane_state->planar_linked_plane->base.base.id, plane_state->planar_linked_plane->base.name,\n\t\t\t   plane_state->planar_slave ? \"slave\" : \"master\");\n}\n\nstatic void intel_plane_hw_info(struct seq_file *m, struct intel_plane *plane)\n{\n\tconst struct intel_plane_state *plane_state =\n\t\tto_intel_plane_state(plane->base.state);\n\tconst struct drm_framebuffer *fb = plane_state->hw.fb;\n\tchar rot_str[48];\n\n\tif (!fb)\n\t\treturn;\n\n\tplane_rotation(rot_str, sizeof(rot_str),\n\t\t       plane_state->hw.rotation);\n\n\tseq_printf(m, \"\\t\\thw: [FB:%d] %p4cc,0x%llx,%dx%d, visible=%s, src=\"\n\t\t   DRM_RECT_FP_FMT \", dst=\" DRM_RECT_FMT \", rotation=%s\\n\",\n\t\t   fb->base.id, &fb->format->format,\n\t\t   fb->modifier, fb->width, fb->height,\n\t\t   str_yes_no(plane_state->uapi.visible),\n\t\t   DRM_RECT_FP_ARG(&plane_state->uapi.src),\n\t\t   DRM_RECT_ARG(&plane_state->uapi.dst),\n\t\t   rot_str);\n}\n\nstatic void intel_plane_info(struct seq_file *m, struct intel_crtc *crtc)\n{\n\tstruct drm_i915_private *dev_priv = node_to_i915(m->private);\n\tstruct intel_plane *plane;\n\n\tfor_each_intel_plane_on_crtc(&dev_priv->drm, crtc, plane) {\n\t\tseq_printf(m, \"\\t[PLANE:%d:%s]: type=%s\\n\",\n\t\t\t   plane->base.base.id, plane->base.name,\n\t\t\t   plane_type(plane->base.type));\n\t\tintel_plane_uapi_info(m, plane);\n\t\tintel_plane_hw_info(m, plane);\n\t}\n}\n\nstatic void intel_scaler_info(struct seq_file *m, struct intel_crtc *crtc)\n{\n\tconst struct intel_crtc_state *crtc_state =\n\t\tto_intel_crtc_state(crtc->base.state);\n\tint num_scalers = crtc->num_scalers;\n\tint i;\n\n\t \n\tif (num_scalers) {\n\t\tseq_printf(m, \"\\tnum_scalers=%d, scaler_users=%x scaler_id=%d scaling_filter=%d\",\n\t\t\t   num_scalers,\n\t\t\t   crtc_state->scaler_state.scaler_users,\n\t\t\t   crtc_state->scaler_state.scaler_id,\n\t\t\t   crtc_state->hw.scaling_filter);\n\n\t\tfor (i = 0; i < num_scalers; i++) {\n\t\t\tconst struct intel_scaler *sc =\n\t\t\t\t&crtc_state->scaler_state.scalers[i];\n\n\t\t\tseq_printf(m, \", scalers[%d]: use=%s, mode=%x\",\n\t\t\t\t   i, str_yes_no(sc->in_use), sc->mode);\n\t\t}\n\t\tseq_puts(m, \"\\n\");\n\t} else {\n\t\tseq_puts(m, \"\\tNo scalers available on this platform\\n\");\n\t}\n}\n\n#if IS_ENABLED(CONFIG_DRM_I915_DEBUG_VBLANK_EVADE)\nstatic void crtc_updates_info(struct seq_file *m,\n\t\t\t      struct intel_crtc *crtc,\n\t\t\t      const char *hdr)\n{\n\tu64 count;\n\tint row;\n\n\tcount = 0;\n\tfor (row = 0; row < ARRAY_SIZE(crtc->debug.vbl.times); row++)\n\t\tcount += crtc->debug.vbl.times[row];\n\tseq_printf(m, \"%sUpdates: %llu\\n\", hdr, count);\n\tif (!count)\n\t\treturn;\n\n\tfor (row = 0; row < ARRAY_SIZE(crtc->debug.vbl.times); row++) {\n\t\tchar columns[80] = \"       |\";\n\t\tunsigned int x;\n\n\t\tif (row & 1) {\n\t\t\tconst char *units;\n\n\t\t\tif (row > 10) {\n\t\t\t\tx = 1000000;\n\t\t\t\tunits = \"ms\";\n\t\t\t} else {\n\t\t\t\tx = 1000;\n\t\t\t\tunits = \"us\";\n\t\t\t}\n\n\t\t\tsnprintf(columns, sizeof(columns), \"%4ld%s |\",\n\t\t\t\t DIV_ROUND_CLOSEST(BIT(row + 9), x), units);\n\t\t}\n\n\t\tif (crtc->debug.vbl.times[row]) {\n\t\t\tx = ilog2(crtc->debug.vbl.times[row]);\n\t\t\tmemset(columns + 8, '*', x);\n\t\t\tcolumns[8 + x] = '\\0';\n\t\t}\n\n\t\tseq_printf(m, \"%s%s\\n\", hdr, columns);\n\t}\n\n\tseq_printf(m, \"%sMin update: %lluns\\n\",\n\t\t   hdr, crtc->debug.vbl.min);\n\tseq_printf(m, \"%sMax update: %lluns\\n\",\n\t\t   hdr, crtc->debug.vbl.max);\n\tseq_printf(m, \"%sAverage update: %lluns\\n\",\n\t\t   hdr, div64_u64(crtc->debug.vbl.sum,  count));\n\tseq_printf(m, \"%sOverruns > %uus: %u\\n\",\n\t\t   hdr, VBLANK_EVASION_TIME_US, crtc->debug.vbl.over);\n}\n\nstatic int crtc_updates_show(struct seq_file *m, void *data)\n{\n\tcrtc_updates_info(m, m->private, \"\");\n\treturn 0;\n}\n\nstatic int crtc_updates_open(struct inode *inode, struct file *file)\n{\n\treturn single_open(file, crtc_updates_show, inode->i_private);\n}\n\nstatic ssize_t crtc_updates_write(struct file *file,\n\t\t\t\t  const char __user *ubuf,\n\t\t\t\t  size_t len, loff_t *offp)\n{\n\tstruct seq_file *m = file->private_data;\n\tstruct intel_crtc *crtc = m->private;\n\n\t \n\tmemset(&crtc->debug.vbl, 0, sizeof(crtc->debug.vbl));\n\n\treturn len;\n}\n\nstatic const struct file_operations crtc_updates_fops = {\n\t.owner = THIS_MODULE,\n\t.open = crtc_updates_open,\n\t.read = seq_read,\n\t.llseek = seq_lseek,\n\t.release = single_release,\n\t.write = crtc_updates_write\n};\n\nstatic void crtc_updates_add(struct intel_crtc *crtc)\n{\n\tdebugfs_create_file(\"i915_update_info\", 0644, crtc->base.debugfs_entry,\n\t\t\t    crtc, &crtc_updates_fops);\n}\n\n#else\nstatic void crtc_updates_info(struct seq_file *m,\n\t\t\t      struct intel_crtc *crtc,\n\t\t\t      const char *hdr)\n{\n}\n\nstatic void crtc_updates_add(struct intel_crtc *crtc)\n{\n}\n#endif\n\nstatic void intel_crtc_info(struct seq_file *m, struct intel_crtc *crtc)\n{\n\tstruct drm_i915_private *dev_priv = node_to_i915(m->private);\n\tconst struct intel_crtc_state *crtc_state =\n\t\tto_intel_crtc_state(crtc->base.state);\n\tstruct intel_encoder *encoder;\n\n\tseq_printf(m, \"[CRTC:%d:%s]:\\n\",\n\t\t   crtc->base.base.id, crtc->base.name);\n\n\tseq_printf(m, \"\\tuapi: enable=%s, active=%s, mode=\" DRM_MODE_FMT \"\\n\",\n\t\t   str_yes_no(crtc_state->uapi.enable),\n\t\t   str_yes_no(crtc_state->uapi.active),\n\t\t   DRM_MODE_ARG(&crtc_state->uapi.mode));\n\n\tseq_printf(m, \"\\thw: enable=%s, active=%s\\n\",\n\t\t   str_yes_no(crtc_state->hw.enable), str_yes_no(crtc_state->hw.active));\n\tseq_printf(m, \"\\tadjusted_mode=\" DRM_MODE_FMT \"\\n\",\n\t\t   DRM_MODE_ARG(&crtc_state->hw.adjusted_mode));\n\tseq_printf(m, \"\\tpipe__mode=\" DRM_MODE_FMT \"\\n\",\n\t\t   DRM_MODE_ARG(&crtc_state->hw.pipe_mode));\n\n\tseq_printf(m, \"\\tpipe src=\" DRM_RECT_FMT \", dither=%s, bpp=%d\\n\",\n\t\t   DRM_RECT_ARG(&crtc_state->pipe_src),\n\t\t   str_yes_no(crtc_state->dither), crtc_state->pipe_bpp);\n\n\tintel_scaler_info(m, crtc);\n\n\tif (crtc_state->bigjoiner_pipes)\n\t\tseq_printf(m, \"\\tLinked to 0x%x pipes as a %s\\n\",\n\t\t\t   crtc_state->bigjoiner_pipes,\n\t\t\t   intel_crtc_is_bigjoiner_slave(crtc_state) ? \"slave\" : \"master\");\n\n\tfor_each_intel_encoder_mask(&dev_priv->drm, encoder,\n\t\t\t\t    crtc_state->uapi.encoder_mask)\n\t\tintel_encoder_info(m, crtc, encoder);\n\n\tintel_plane_info(m, crtc);\n\n\tseq_printf(m, \"\\tunderrun reporting: cpu=%s pch=%s\\n\",\n\t\t   str_yes_no(!crtc->cpu_fifo_underrun_disabled),\n\t\t   str_yes_no(!crtc->pch_fifo_underrun_disabled));\n\n\tcrtc_updates_info(m, crtc, \"\\t\");\n}\n\nstatic int i915_display_info(struct seq_file *m, void *unused)\n{\n\tstruct drm_i915_private *dev_priv = node_to_i915(m->private);\n\tstruct intel_crtc *crtc;\n\tstruct drm_connector *connector;\n\tstruct drm_connector_list_iter conn_iter;\n\tintel_wakeref_t wakeref;\n\n\twakeref = intel_runtime_pm_get(&dev_priv->runtime_pm);\n\n\tdrm_modeset_lock_all(&dev_priv->drm);\n\n\tseq_printf(m, \"CRTC info\\n\");\n\tseq_printf(m, \"---------\\n\");\n\tfor_each_intel_crtc(&dev_priv->drm, crtc)\n\t\tintel_crtc_info(m, crtc);\n\n\tseq_printf(m, \"\\n\");\n\tseq_printf(m, \"Connector info\\n\");\n\tseq_printf(m, \"--------------\\n\");\n\tdrm_connector_list_iter_begin(&dev_priv->drm, &conn_iter);\n\tdrm_for_each_connector_iter(connector, &conn_iter)\n\t\tintel_connector_info(m, connector);\n\tdrm_connector_list_iter_end(&conn_iter);\n\n\tdrm_modeset_unlock_all(&dev_priv->drm);\n\n\tintel_runtime_pm_put(&dev_priv->runtime_pm, wakeref);\n\n\treturn 0;\n}\n\nstatic int i915_shared_dplls_info(struct seq_file *m, void *unused)\n{\n\tstruct drm_i915_private *dev_priv = node_to_i915(m->private);\n\tint i;\n\n\tdrm_modeset_lock_all(&dev_priv->drm);\n\n\tseq_printf(m, \"PLL refclks: non-SSC: %d kHz, SSC: %d kHz\\n\",\n\t\t   dev_priv->display.dpll.ref_clks.nssc,\n\t\t   dev_priv->display.dpll.ref_clks.ssc);\n\n\tfor (i = 0; i < dev_priv->display.dpll.num_shared_dpll; i++) {\n\t\tstruct intel_shared_dpll *pll = &dev_priv->display.dpll.shared_dplls[i];\n\n\t\tseq_printf(m, \"DPLL%i: %s, id: %i\\n\", i, pll->info->name,\n\t\t\t   pll->info->id);\n\t\tseq_printf(m, \" pipe_mask: 0x%x, active: 0x%x, on: %s\\n\",\n\t\t\t   pll->state.pipe_mask, pll->active_mask,\n\t\t\t   str_yes_no(pll->on));\n\t\tseq_printf(m, \" tracked hardware state:\\n\");\n\t\tseq_printf(m, \" dpll:    0x%08x\\n\", pll->state.hw_state.dpll);\n\t\tseq_printf(m, \" dpll_md: 0x%08x\\n\",\n\t\t\t   pll->state.hw_state.dpll_md);\n\t\tseq_printf(m, \" fp0:     0x%08x\\n\", pll->state.hw_state.fp0);\n\t\tseq_printf(m, \" fp1:     0x%08x\\n\", pll->state.hw_state.fp1);\n\t\tseq_printf(m, \" wrpll:   0x%08x\\n\", pll->state.hw_state.wrpll);\n\t\tseq_printf(m, \" cfgcr0:  0x%08x\\n\", pll->state.hw_state.cfgcr0);\n\t\tseq_printf(m, \" cfgcr1:  0x%08x\\n\", pll->state.hw_state.cfgcr1);\n\t\tseq_printf(m, \" div0:    0x%08x\\n\", pll->state.hw_state.div0);\n\t\tseq_printf(m, \" mg_refclkin_ctl:        0x%08x\\n\",\n\t\t\t   pll->state.hw_state.mg_refclkin_ctl);\n\t\tseq_printf(m, \" mg_clktop2_coreclkctl1: 0x%08x\\n\",\n\t\t\t   pll->state.hw_state.mg_clktop2_coreclkctl1);\n\t\tseq_printf(m, \" mg_clktop2_hsclkctl:    0x%08x\\n\",\n\t\t\t   pll->state.hw_state.mg_clktop2_hsclkctl);\n\t\tseq_printf(m, \" mg_pll_div0:  0x%08x\\n\",\n\t\t\t   pll->state.hw_state.mg_pll_div0);\n\t\tseq_printf(m, \" mg_pll_div1:  0x%08x\\n\",\n\t\t\t   pll->state.hw_state.mg_pll_div1);\n\t\tseq_printf(m, \" mg_pll_lf:    0x%08x\\n\",\n\t\t\t   pll->state.hw_state.mg_pll_lf);\n\t\tseq_printf(m, \" mg_pll_frac_lock: 0x%08x\\n\",\n\t\t\t   pll->state.hw_state.mg_pll_frac_lock);\n\t\tseq_printf(m, \" mg_pll_ssc:   0x%08x\\n\",\n\t\t\t   pll->state.hw_state.mg_pll_ssc);\n\t\tseq_printf(m, \" mg_pll_bias:  0x%08x\\n\",\n\t\t\t   pll->state.hw_state.mg_pll_bias);\n\t\tseq_printf(m, \" mg_pll_tdc_coldst_bias: 0x%08x\\n\",\n\t\t\t   pll->state.hw_state.mg_pll_tdc_coldst_bias);\n\t}\n\tdrm_modeset_unlock_all(&dev_priv->drm);\n\n\treturn 0;\n}\n\nstatic int i915_ddb_info(struct seq_file *m, void *unused)\n{\n\tstruct drm_i915_private *dev_priv = node_to_i915(m->private);\n\tstruct skl_ddb_entry *entry;\n\tstruct intel_crtc *crtc;\n\n\tif (DISPLAY_VER(dev_priv) < 9)\n\t\treturn -ENODEV;\n\n\tdrm_modeset_lock_all(&dev_priv->drm);\n\n\tseq_printf(m, \"%-15s%8s%8s%8s\\n\", \"\", \"Start\", \"End\", \"Size\");\n\n\tfor_each_intel_crtc(&dev_priv->drm, crtc) {\n\t\tstruct intel_crtc_state *crtc_state =\n\t\t\tto_intel_crtc_state(crtc->base.state);\n\t\tenum pipe pipe = crtc->pipe;\n\t\tenum plane_id plane_id;\n\n\t\tseq_printf(m, \"Pipe %c\\n\", pipe_name(pipe));\n\n\t\tfor_each_plane_id_on_crtc(crtc, plane_id) {\n\t\t\tentry = &crtc_state->wm.skl.plane_ddb[plane_id];\n\t\t\tseq_printf(m, \"  Plane%-8d%8u%8u%8u\\n\", plane_id + 1,\n\t\t\t\t   entry->start, entry->end,\n\t\t\t\t   skl_ddb_entry_size(entry));\n\t\t}\n\n\t\tentry = &crtc_state->wm.skl.plane_ddb[PLANE_CURSOR];\n\t\tseq_printf(m, \"  %-13s%8u%8u%8u\\n\", \"Cursor\", entry->start,\n\t\t\t   entry->end, skl_ddb_entry_size(entry));\n\t}\n\n\tdrm_modeset_unlock_all(&dev_priv->drm);\n\n\treturn 0;\n}\n\nstatic bool\nintel_lpsp_power_well_enabled(struct drm_i915_private *i915,\n\t\t\t      enum i915_power_well_id power_well_id)\n{\n\tintel_wakeref_t wakeref;\n\tbool is_enabled;\n\n\twakeref = intel_runtime_pm_get(&i915->runtime_pm);\n\tis_enabled = intel_display_power_well_is_enabled(i915,\n\t\t\t\t\t\t\t power_well_id);\n\tintel_runtime_pm_put(&i915->runtime_pm, wakeref);\n\n\treturn is_enabled;\n}\n\nstatic int i915_lpsp_status(struct seq_file *m, void *unused)\n{\n\tstruct drm_i915_private *i915 = node_to_i915(m->private);\n\tbool lpsp_enabled = false;\n\n\tif (DISPLAY_VER(i915) >= 13 || IS_DISPLAY_VER(i915, 9, 10)) {\n\t\tlpsp_enabled = !intel_lpsp_power_well_enabled(i915, SKL_DISP_PW_2);\n\t} else if (IS_DISPLAY_VER(i915, 11, 12)) {\n\t\tlpsp_enabled = !intel_lpsp_power_well_enabled(i915, ICL_DISP_PW_3);\n\t} else if (IS_HASWELL(i915) || IS_BROADWELL(i915)) {\n\t\tlpsp_enabled = !intel_lpsp_power_well_enabled(i915, HSW_DISP_PW_GLOBAL);\n\t} else {\n\t\tseq_puts(m, \"LPSP: not supported\\n\");\n\t\treturn 0;\n\t}\n\n\tseq_printf(m, \"LPSP: %s\\n\", str_enabled_disabled(lpsp_enabled));\n\n\treturn 0;\n}\n\nstatic int i915_dp_mst_info(struct seq_file *m, void *unused)\n{\n\tstruct drm_i915_private *dev_priv = node_to_i915(m->private);\n\tstruct intel_encoder *intel_encoder;\n\tstruct intel_digital_port *dig_port;\n\tstruct drm_connector *connector;\n\tstruct drm_connector_list_iter conn_iter;\n\n\tdrm_connector_list_iter_begin(&dev_priv->drm, &conn_iter);\n\tdrm_for_each_connector_iter(connector, &conn_iter) {\n\t\tif (connector->connector_type != DRM_MODE_CONNECTOR_DisplayPort)\n\t\t\tcontinue;\n\n\t\tintel_encoder = intel_attached_encoder(to_intel_connector(connector));\n\t\tif (!intel_encoder || intel_encoder->type == INTEL_OUTPUT_DP_MST)\n\t\t\tcontinue;\n\n\t\tdig_port = enc_to_dig_port(intel_encoder);\n\t\tif (!intel_dp_mst_source_support(&dig_port->dp))\n\t\t\tcontinue;\n\n\t\tseq_printf(m, \"MST Source Port [ENCODER:%d:%s]\\n\",\n\t\t\t   dig_port->base.base.base.id,\n\t\t\t   dig_port->base.base.name);\n\t\tdrm_dp_mst_dump_topology(m, &dig_port->dp.mst_mgr);\n\t}\n\tdrm_connector_list_iter_end(&conn_iter);\n\n\treturn 0;\n}\n\nstatic ssize_t i915_displayport_test_active_write(struct file *file,\n\t\t\t\t\t\t  const char __user *ubuf,\n\t\t\t\t\t\t  size_t len, loff_t *offp)\n{\n\tchar *input_buffer;\n\tint status = 0;\n\tstruct drm_device *dev;\n\tstruct drm_connector *connector;\n\tstruct drm_connector_list_iter conn_iter;\n\tstruct intel_dp *intel_dp;\n\tint val = 0;\n\n\tdev = ((struct seq_file *)file->private_data)->private;\n\n\tif (len == 0)\n\t\treturn 0;\n\n\tinput_buffer = memdup_user_nul(ubuf, len);\n\tif (IS_ERR(input_buffer))\n\t\treturn PTR_ERR(input_buffer);\n\n\tdrm_dbg(dev, \"Copied %d bytes from user\\n\", (unsigned int)len);\n\n\tdrm_connector_list_iter_begin(dev, &conn_iter);\n\tdrm_for_each_connector_iter(connector, &conn_iter) {\n\t\tstruct intel_encoder *encoder;\n\n\t\tif (connector->connector_type !=\n\t\t    DRM_MODE_CONNECTOR_DisplayPort)\n\t\t\tcontinue;\n\n\t\tencoder = to_intel_encoder(connector->encoder);\n\t\tif (encoder && encoder->type == INTEL_OUTPUT_DP_MST)\n\t\t\tcontinue;\n\n\t\tif (encoder && connector->status == connector_status_connected) {\n\t\t\tintel_dp = enc_to_intel_dp(encoder);\n\t\t\tstatus = kstrtoint(input_buffer, 10, &val);\n\t\t\tif (status < 0)\n\t\t\t\tbreak;\n\t\t\tdrm_dbg(dev, \"Got %d for test active\\n\", val);\n\t\t\t \n\t\t\tif (val == 1)\n\t\t\t\tintel_dp->compliance.test_active = true;\n\t\t\telse\n\t\t\t\tintel_dp->compliance.test_active = false;\n\t\t}\n\t}\n\tdrm_connector_list_iter_end(&conn_iter);\n\tkfree(input_buffer);\n\tif (status < 0)\n\t\treturn status;\n\n\t*offp += len;\n\treturn len;\n}\n\nstatic int i915_displayport_test_active_show(struct seq_file *m, void *data)\n{\n\tstruct drm_i915_private *dev_priv = m->private;\n\tstruct drm_connector *connector;\n\tstruct drm_connector_list_iter conn_iter;\n\tstruct intel_dp *intel_dp;\n\n\tdrm_connector_list_iter_begin(&dev_priv->drm, &conn_iter);\n\tdrm_for_each_connector_iter(connector, &conn_iter) {\n\t\tstruct intel_encoder *encoder;\n\n\t\tif (connector->connector_type !=\n\t\t    DRM_MODE_CONNECTOR_DisplayPort)\n\t\t\tcontinue;\n\n\t\tencoder = to_intel_encoder(connector->encoder);\n\t\tif (encoder && encoder->type == INTEL_OUTPUT_DP_MST)\n\t\t\tcontinue;\n\n\t\tif (encoder && connector->status == connector_status_connected) {\n\t\t\tintel_dp = enc_to_intel_dp(encoder);\n\t\t\tif (intel_dp->compliance.test_active)\n\t\t\t\tseq_puts(m, \"1\");\n\t\t\telse\n\t\t\t\tseq_puts(m, \"0\");\n\t\t} else\n\t\t\tseq_puts(m, \"0\");\n\t}\n\tdrm_connector_list_iter_end(&conn_iter);\n\n\treturn 0;\n}\n\nstatic int i915_displayport_test_active_open(struct inode *inode,\n\t\t\t\t\t     struct file *file)\n{\n\treturn single_open(file, i915_displayport_test_active_show,\n\t\t\t   inode->i_private);\n}\n\nstatic const struct file_operations i915_displayport_test_active_fops = {\n\t.owner = THIS_MODULE,\n\t.open = i915_displayport_test_active_open,\n\t.read = seq_read,\n\t.llseek = seq_lseek,\n\t.release = single_release,\n\t.write = i915_displayport_test_active_write\n};\n\nstatic int i915_displayport_test_data_show(struct seq_file *m, void *data)\n{\n\tstruct drm_i915_private *dev_priv = m->private;\n\tstruct drm_connector *connector;\n\tstruct drm_connector_list_iter conn_iter;\n\tstruct intel_dp *intel_dp;\n\n\tdrm_connector_list_iter_begin(&dev_priv->drm, &conn_iter);\n\tdrm_for_each_connector_iter(connector, &conn_iter) {\n\t\tstruct intel_encoder *encoder;\n\n\t\tif (connector->connector_type !=\n\t\t    DRM_MODE_CONNECTOR_DisplayPort)\n\t\t\tcontinue;\n\n\t\tencoder = to_intel_encoder(connector->encoder);\n\t\tif (encoder && encoder->type == INTEL_OUTPUT_DP_MST)\n\t\t\tcontinue;\n\n\t\tif (encoder && connector->status == connector_status_connected) {\n\t\t\tintel_dp = enc_to_intel_dp(encoder);\n\t\t\tif (intel_dp->compliance.test_type ==\n\t\t\t    DP_TEST_LINK_EDID_READ)\n\t\t\t\tseq_printf(m, \"%lx\",\n\t\t\t\t\t   intel_dp->compliance.test_data.edid);\n\t\t\telse if (intel_dp->compliance.test_type ==\n\t\t\t\t DP_TEST_LINK_VIDEO_PATTERN) {\n\t\t\t\tseq_printf(m, \"hdisplay: %d\\n\",\n\t\t\t\t\t   intel_dp->compliance.test_data.hdisplay);\n\t\t\t\tseq_printf(m, \"vdisplay: %d\\n\",\n\t\t\t\t\t   intel_dp->compliance.test_data.vdisplay);\n\t\t\t\tseq_printf(m, \"bpc: %u\\n\",\n\t\t\t\t\t   intel_dp->compliance.test_data.bpc);\n\t\t\t} else if (intel_dp->compliance.test_type ==\n\t\t\t\t   DP_TEST_LINK_PHY_TEST_PATTERN) {\n\t\t\t\tseq_printf(m, \"pattern: %d\\n\",\n\t\t\t\t\t   intel_dp->compliance.test_data.phytest.phy_pattern);\n\t\t\t\tseq_printf(m, \"Number of lanes: %d\\n\",\n\t\t\t\t\t   intel_dp->compliance.test_data.phytest.num_lanes);\n\t\t\t\tseq_printf(m, \"Link Rate: %d\\n\",\n\t\t\t\t\t   intel_dp->compliance.test_data.phytest.link_rate);\n\t\t\t\tseq_printf(m, \"level: %02x\\n\",\n\t\t\t\t\t   intel_dp->train_set[0]);\n\t\t\t}\n\t\t} else\n\t\t\tseq_puts(m, \"0\");\n\t}\n\tdrm_connector_list_iter_end(&conn_iter);\n\n\treturn 0;\n}\nDEFINE_SHOW_ATTRIBUTE(i915_displayport_test_data);\n\nstatic int i915_displayport_test_type_show(struct seq_file *m, void *data)\n{\n\tstruct drm_i915_private *dev_priv = m->private;\n\tstruct drm_connector *connector;\n\tstruct drm_connector_list_iter conn_iter;\n\tstruct intel_dp *intel_dp;\n\n\tdrm_connector_list_iter_begin(&dev_priv->drm, &conn_iter);\n\tdrm_for_each_connector_iter(connector, &conn_iter) {\n\t\tstruct intel_encoder *encoder;\n\n\t\tif (connector->connector_type !=\n\t\t    DRM_MODE_CONNECTOR_DisplayPort)\n\t\t\tcontinue;\n\n\t\tencoder = to_intel_encoder(connector->encoder);\n\t\tif (encoder && encoder->type == INTEL_OUTPUT_DP_MST)\n\t\t\tcontinue;\n\n\t\tif (encoder && connector->status == connector_status_connected) {\n\t\t\tintel_dp = enc_to_intel_dp(encoder);\n\t\t\tseq_printf(m, \"%02lx\\n\", intel_dp->compliance.test_type);\n\t\t} else\n\t\t\tseq_puts(m, \"0\");\n\t}\n\tdrm_connector_list_iter_end(&conn_iter);\n\n\treturn 0;\n}\nDEFINE_SHOW_ATTRIBUTE(i915_displayport_test_type);\n\nstatic ssize_t\ni915_fifo_underrun_reset_write(struct file *filp,\n\t\t\t       const char __user *ubuf,\n\t\t\t       size_t cnt, loff_t *ppos)\n{\n\tstruct drm_i915_private *dev_priv = filp->private_data;\n\tstruct intel_crtc *crtc;\n\tint ret;\n\tbool reset;\n\n\tret = kstrtobool_from_user(ubuf, cnt, &reset);\n\tif (ret)\n\t\treturn ret;\n\n\tif (!reset)\n\t\treturn cnt;\n\n\tfor_each_intel_crtc(&dev_priv->drm, crtc) {\n\t\tstruct drm_crtc_commit *commit;\n\t\tstruct intel_crtc_state *crtc_state;\n\n\t\tret = drm_modeset_lock_single_interruptible(&crtc->base.mutex);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tcrtc_state = to_intel_crtc_state(crtc->base.state);\n\t\tcommit = crtc_state->uapi.commit;\n\t\tif (commit) {\n\t\t\tret = wait_for_completion_interruptible(&commit->hw_done);\n\t\t\tif (!ret)\n\t\t\t\tret = wait_for_completion_interruptible(&commit->flip_done);\n\t\t}\n\n\t\tif (!ret && crtc_state->hw.active) {\n\t\t\tdrm_dbg_kms(&dev_priv->drm,\n\t\t\t\t    \"Re-arming FIFO underruns on pipe %c\\n\",\n\t\t\t\t    pipe_name(crtc->pipe));\n\n\t\t\tintel_crtc_arm_fifo_underrun(crtc, crtc_state);\n\t\t}\n\n\t\tdrm_modeset_unlock(&crtc->base.mutex);\n\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tintel_fbc_reset_underrun(dev_priv);\n\n\treturn cnt;\n}\n\nstatic const struct file_operations i915_fifo_underrun_reset_ops = {\n\t.owner = THIS_MODULE,\n\t.open = simple_open,\n\t.write = i915_fifo_underrun_reset_write,\n\t.llseek = default_llseek,\n};\n\nstatic const struct drm_info_list intel_display_debugfs_list[] = {\n\t{\"i915_frontbuffer_tracking\", i915_frontbuffer_tracking, 0},\n\t{\"i915_sr_status\", i915_sr_status, 0},\n\t{\"i915_opregion\", i915_opregion, 0},\n\t{\"i915_vbt\", i915_vbt, 0},\n\t{\"i915_gem_framebuffer\", i915_gem_framebuffer_info, 0},\n\t{\"i915_power_domain_info\", i915_power_domain_info, 0},\n\t{\"i915_display_info\", i915_display_info, 0},\n\t{\"i915_shared_dplls_info\", i915_shared_dplls_info, 0},\n\t{\"i915_dp_mst_info\", i915_dp_mst_info, 0},\n\t{\"i915_ddb_info\", i915_ddb_info, 0},\n\t{\"i915_lpsp_status\", i915_lpsp_status, 0},\n};\n\nstatic const struct {\n\tconst char *name;\n\tconst struct file_operations *fops;\n} intel_display_debugfs_files[] = {\n\t{\"i915_fifo_underrun_reset\", &i915_fifo_underrun_reset_ops},\n\t{\"i915_dp_test_data\", &i915_displayport_test_data_fops},\n\t{\"i915_dp_test_type\", &i915_displayport_test_type_fops},\n\t{\"i915_dp_test_active\", &i915_displayport_test_active_fops},\n};\n\nvoid intel_display_debugfs_register(struct drm_i915_private *i915)\n{\n\tstruct drm_minor *minor = i915->drm.primary;\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(intel_display_debugfs_files); i++) {\n\t\tdebugfs_create_file(intel_display_debugfs_files[i].name,\n\t\t\t\t    S_IRUGO | S_IWUSR,\n\t\t\t\t    minor->debugfs_root,\n\t\t\t\t    to_i915(minor->dev),\n\t\t\t\t    intel_display_debugfs_files[i].fops);\n\t}\n\n\tdrm_debugfs_create_files(intel_display_debugfs_list,\n\t\t\t\t ARRAY_SIZE(intel_display_debugfs_list),\n\t\t\t\t minor->debugfs_root, minor);\n\n\tintel_cdclk_debugfs_register(i915);\n\tintel_dmc_debugfs_register(i915);\n\tintel_fbc_debugfs_register(i915);\n\tintel_hpd_debugfs_register(i915);\n\tintel_psr_debugfs_register(i915);\n\tintel_wm_debugfs_register(i915);\n}\n\nstatic int i915_panel_show(struct seq_file *m, void *data)\n{\n\tstruct drm_connector *connector = m->private;\n\tstruct intel_dp *intel_dp =\n\t\tintel_attached_dp(to_intel_connector(connector));\n\n\tif (connector->status != connector_status_connected)\n\t\treturn -ENODEV;\n\n\tseq_printf(m, \"Panel power up delay: %d\\n\",\n\t\t   intel_dp->pps.panel_power_up_delay);\n\tseq_printf(m, \"Panel power down delay: %d\\n\",\n\t\t   intel_dp->pps.panel_power_down_delay);\n\tseq_printf(m, \"Backlight on delay: %d\\n\",\n\t\t   intel_dp->pps.backlight_on_delay);\n\tseq_printf(m, \"Backlight off delay: %d\\n\",\n\t\t   intel_dp->pps.backlight_off_delay);\n\n\treturn 0;\n}\nDEFINE_SHOW_ATTRIBUTE(i915_panel);\n\nstatic int i915_hdcp_sink_capability_show(struct seq_file *m, void *data)\n{\n\tstruct drm_connector *connector = m->private;\n\tstruct drm_i915_private *i915 = to_i915(connector->dev);\n\tstruct intel_connector *intel_connector = to_intel_connector(connector);\n\tint ret;\n\n\tret = drm_modeset_lock_single_interruptible(&i915->drm.mode_config.connection_mutex);\n\tif (ret)\n\t\treturn ret;\n\n\tif (!connector->encoder || connector->status != connector_status_connected) {\n\t\tret = -ENODEV;\n\t\tgoto out;\n\t}\n\n\tseq_printf(m, \"%s:%d HDCP version: \", connector->name,\n\t\t   connector->base.id);\n\tintel_hdcp_info(m, intel_connector);\n\nout:\n\tdrm_modeset_unlock(&i915->drm.mode_config.connection_mutex);\n\n\treturn ret;\n}\nDEFINE_SHOW_ATTRIBUTE(i915_hdcp_sink_capability);\n\nstatic int i915_lpsp_capability_show(struct seq_file *m, void *data)\n{\n\tstruct drm_connector *connector = m->private;\n\tstruct drm_i915_private *i915 = to_i915(connector->dev);\n\tstruct intel_encoder *encoder;\n\tbool lpsp_capable = false;\n\n\tencoder = intel_attached_encoder(to_intel_connector(connector));\n\tif (!encoder)\n\t\treturn -ENODEV;\n\n\tif (connector->status != connector_status_connected)\n\t\treturn -ENODEV;\n\n\tif (DISPLAY_VER(i915) >= 13)\n\t\tlpsp_capable = encoder->port <= PORT_B;\n\telse if (DISPLAY_VER(i915) >= 12)\n\t\t \n\t\tlpsp_capable = encoder->port <= PORT_B;\n\telse if (DISPLAY_VER(i915) == 11)\n\t\tlpsp_capable = (connector->connector_type == DRM_MODE_CONNECTOR_DSI ||\n\t\t\t\tconnector->connector_type == DRM_MODE_CONNECTOR_eDP);\n\telse if (IS_DISPLAY_VER(i915, 9, 10))\n\t\tlpsp_capable = (encoder->port == PORT_A &&\n\t\t\t\t(connector->connector_type == DRM_MODE_CONNECTOR_DSI ||\n\t\t\t\t connector->connector_type == DRM_MODE_CONNECTOR_eDP ||\n\t\t\t\t connector->connector_type == DRM_MODE_CONNECTOR_DisplayPort));\n\telse if (IS_HASWELL(i915) || IS_BROADWELL(i915))\n\t\tlpsp_capable = connector->connector_type == DRM_MODE_CONNECTOR_eDP;\n\n\tseq_printf(m, \"LPSP: %s\\n\", lpsp_capable ? \"capable\" : \"incapable\");\n\n\treturn 0;\n}\nDEFINE_SHOW_ATTRIBUTE(i915_lpsp_capability);\n\nstatic int i915_dsc_fec_support_show(struct seq_file *m, void *data)\n{\n\tstruct drm_connector *connector = m->private;\n\tstruct drm_device *dev = connector->dev;\n\tstruct drm_crtc *crtc;\n\tstruct intel_dp *intel_dp;\n\tstruct drm_modeset_acquire_ctx ctx;\n\tstruct intel_crtc_state *crtc_state = NULL;\n\tint ret = 0;\n\tbool try_again = false;\n\n\tdrm_modeset_acquire_init(&ctx, DRM_MODESET_ACQUIRE_INTERRUPTIBLE);\n\n\tdo {\n\t\ttry_again = false;\n\t\tret = drm_modeset_lock(&dev->mode_config.connection_mutex,\n\t\t\t\t       &ctx);\n\t\tif (ret) {\n\t\t\tif (ret == -EDEADLK && !drm_modeset_backoff(&ctx)) {\n\t\t\t\ttry_again = true;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tcrtc = connector->state->crtc;\n\t\tif (connector->status != connector_status_connected || !crtc) {\n\t\t\tret = -ENODEV;\n\t\t\tbreak;\n\t\t}\n\t\tret = drm_modeset_lock(&crtc->mutex, &ctx);\n\t\tif (ret == -EDEADLK) {\n\t\t\tret = drm_modeset_backoff(&ctx);\n\t\t\tif (!ret) {\n\t\t\t\ttry_again = true;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tbreak;\n\t\t} else if (ret) {\n\t\t\tbreak;\n\t\t}\n\t\tintel_dp = intel_attached_dp(to_intel_connector(connector));\n\t\tcrtc_state = to_intel_crtc_state(crtc->state);\n\t\tseq_printf(m, \"DSC_Enabled: %s\\n\",\n\t\t\t   str_yes_no(crtc_state->dsc.compression_enable));\n\t\tseq_printf(m, \"DSC_Sink_Support: %s\\n\",\n\t\t\t   str_yes_no(drm_dp_sink_supports_dsc(intel_dp->dsc_dpcd)));\n\t\tseq_printf(m, \"DSC_Output_Format_Sink_Support: RGB: %s YCBCR420: %s YCBCR444: %s\\n\",\n\t\t\t   str_yes_no(drm_dp_dsc_sink_supports_format(intel_dp->dsc_dpcd,\n\t\t\t\t\t\t\t\t      DP_DSC_RGB)),\n\t\t\t   str_yes_no(drm_dp_dsc_sink_supports_format(intel_dp->dsc_dpcd,\n\t\t\t\t\t\t\t\t      DP_DSC_YCbCr420_Native)),\n\t\t\t   str_yes_no(drm_dp_dsc_sink_supports_format(intel_dp->dsc_dpcd,\n\t\t\t\t\t\t\t\t      DP_DSC_YCbCr444)));\n\t\tseq_printf(m, \"Force_DSC_Enable: %s\\n\",\n\t\t\t   str_yes_no(intel_dp->force_dsc_en));\n\t\tif (!intel_dp_is_edp(intel_dp))\n\t\t\tseq_printf(m, \"FEC_Sink_Support: %s\\n\",\n\t\t\t\t   str_yes_no(drm_dp_sink_supports_fec(intel_dp->fec_capable)));\n\t} while (try_again);\n\n\tdrm_modeset_drop_locks(&ctx);\n\tdrm_modeset_acquire_fini(&ctx);\n\n\treturn ret;\n}\n\nstatic ssize_t i915_dsc_fec_support_write(struct file *file,\n\t\t\t\t\t  const char __user *ubuf,\n\t\t\t\t\t  size_t len, loff_t *offp)\n{\n\tbool dsc_enable = false;\n\tint ret;\n\tstruct drm_connector *connector =\n\t\t((struct seq_file *)file->private_data)->private;\n\tstruct intel_encoder *encoder = intel_attached_encoder(to_intel_connector(connector));\n\tstruct drm_i915_private *i915 = to_i915(encoder->base.dev);\n\tstruct intel_dp *intel_dp = enc_to_intel_dp(encoder);\n\n\tif (len == 0)\n\t\treturn 0;\n\n\tdrm_dbg(&i915->drm,\n\t\t\"Copied %zu bytes from user to force DSC\\n\", len);\n\n\tret = kstrtobool_from_user(ubuf, len, &dsc_enable);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tdrm_dbg(&i915->drm, \"Got %s for DSC Enable\\n\",\n\t\t(dsc_enable) ? \"true\" : \"false\");\n\tintel_dp->force_dsc_en = dsc_enable;\n\n\t*offp += len;\n\treturn len;\n}\n\nstatic int i915_dsc_fec_support_open(struct inode *inode,\n\t\t\t\t     struct file *file)\n{\n\treturn single_open(file, i915_dsc_fec_support_show,\n\t\t\t   inode->i_private);\n}\n\nstatic const struct file_operations i915_dsc_fec_support_fops = {\n\t.owner = THIS_MODULE,\n\t.open = i915_dsc_fec_support_open,\n\t.read = seq_read,\n\t.llseek = seq_lseek,\n\t.release = single_release,\n\t.write = i915_dsc_fec_support_write\n};\n\nstatic int i915_dsc_bpc_show(struct seq_file *m, void *data)\n{\n\tstruct drm_connector *connector = m->private;\n\tstruct drm_device *dev = connector->dev;\n\tstruct drm_crtc *crtc;\n\tstruct intel_crtc_state *crtc_state;\n\tstruct intel_encoder *encoder = intel_attached_encoder(to_intel_connector(connector));\n\tint ret;\n\n\tif (!encoder)\n\t\treturn -ENODEV;\n\n\tret = drm_modeset_lock_single_interruptible(&dev->mode_config.connection_mutex);\n\tif (ret)\n\t\treturn ret;\n\n\tcrtc = connector->state->crtc;\n\tif (connector->status != connector_status_connected || !crtc) {\n\t\tret = -ENODEV;\n\t\tgoto out;\n\t}\n\n\tcrtc_state = to_intel_crtc_state(crtc->state);\n\tseq_printf(m, \"Input_BPC: %d\\n\", crtc_state->dsc.config.bits_per_component);\n\nout:\tdrm_modeset_unlock(&dev->mode_config.connection_mutex);\n\n\treturn ret;\n}\n\nstatic ssize_t i915_dsc_bpc_write(struct file *file,\n\t\t\t\t  const char __user *ubuf,\n\t\t\t\t  size_t len, loff_t *offp)\n{\n\tstruct drm_connector *connector =\n\t\t((struct seq_file *)file->private_data)->private;\n\tstruct intel_encoder *encoder = intel_attached_encoder(to_intel_connector(connector));\n\tstruct intel_dp *intel_dp = enc_to_intel_dp(encoder);\n\tint dsc_bpc = 0;\n\tint ret;\n\n\tret = kstrtoint_from_user(ubuf, len, 0, &dsc_bpc);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tintel_dp->force_dsc_bpc = dsc_bpc;\n\t*offp += len;\n\n\treturn len;\n}\n\nstatic int i915_dsc_bpc_open(struct inode *inode,\n\t\t\t     struct file *file)\n{\n\treturn single_open(file, i915_dsc_bpc_show, inode->i_private);\n}\n\nstatic const struct file_operations i915_dsc_bpc_fops = {\n\t.owner = THIS_MODULE,\n\t.open = i915_dsc_bpc_open,\n\t.read = seq_read,\n\t.llseek = seq_lseek,\n\t.release = single_release,\n\t.write = i915_dsc_bpc_write\n};\n\nstatic int i915_dsc_output_format_show(struct seq_file *m, void *data)\n{\n\tstruct drm_connector *connector = m->private;\n\tstruct drm_device *dev = connector->dev;\n\tstruct drm_crtc *crtc;\n\tstruct intel_crtc_state *crtc_state;\n\tstruct intel_encoder *encoder = intel_attached_encoder(to_intel_connector(connector));\n\tint ret;\n\n\tif (!encoder)\n\t\treturn -ENODEV;\n\n\tret = drm_modeset_lock_single_interruptible(&dev->mode_config.connection_mutex);\n\tif (ret)\n\t\treturn ret;\n\n\tcrtc = connector->state->crtc;\n\tif (connector->status != connector_status_connected || !crtc) {\n\t\tret = -ENODEV;\n\t\tgoto out;\n\t}\n\n\tcrtc_state = to_intel_crtc_state(crtc->state);\n\tseq_printf(m, \"DSC_Output_Format: %s\\n\",\n\t\t   intel_output_format_name(crtc_state->output_format));\n\nout:\tdrm_modeset_unlock(&dev->mode_config.connection_mutex);\n\n\treturn ret;\n}\n\nstatic ssize_t i915_dsc_output_format_write(struct file *file,\n\t\t\t\t\t    const char __user *ubuf,\n\t\t\t\t\t    size_t len, loff_t *offp)\n{\n\tstruct drm_connector *connector =\n\t\t((struct seq_file *)file->private_data)->private;\n\tstruct intel_encoder *encoder = intel_attached_encoder(to_intel_connector(connector));\n\tstruct intel_dp *intel_dp = enc_to_intel_dp(encoder);\n\tint dsc_output_format = 0;\n\tint ret;\n\n\tret = kstrtoint_from_user(ubuf, len, 0, &dsc_output_format);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tintel_dp->force_dsc_output_format = dsc_output_format;\n\t*offp += len;\n\n\treturn len;\n}\n\nstatic int i915_dsc_output_format_open(struct inode *inode,\n\t\t\t\t       struct file *file)\n{\n\treturn single_open(file, i915_dsc_output_format_show, inode->i_private);\n}\n\nstatic const struct file_operations i915_dsc_output_format_fops = {\n\t.owner = THIS_MODULE,\n\t.open = i915_dsc_output_format_open,\n\t.read = seq_read,\n\t.llseek = seq_lseek,\n\t.release = single_release,\n\t.write = i915_dsc_output_format_write\n};\n\n \nstatic int i915_current_bpc_show(struct seq_file *m, void *data)\n{\n\tstruct intel_crtc *crtc = m->private;\n\tstruct intel_crtc_state *crtc_state;\n\tint ret;\n\n\tret = drm_modeset_lock_single_interruptible(&crtc->base.mutex);\n\tif (ret)\n\t\treturn ret;\n\n\tcrtc_state = to_intel_crtc_state(crtc->base.state);\n\tseq_printf(m, \"Current: %u\\n\", crtc_state->pipe_bpp / 3);\n\n\tdrm_modeset_unlock(&crtc->base.mutex);\n\n\treturn ret;\n}\nDEFINE_SHOW_ATTRIBUTE(i915_current_bpc);\n\n \nstatic int intel_crtc_pipe_show(struct seq_file *m, void *unused)\n{\n\tstruct intel_crtc *crtc = m->private;\n\n\tseq_printf(m, \"%c\\n\", pipe_name(crtc->pipe));\n\n\treturn 0;\n}\nDEFINE_SHOW_ATTRIBUTE(intel_crtc_pipe);\n\n \nvoid intel_connector_debugfs_add(struct intel_connector *intel_connector)\n{\n\tstruct drm_connector *connector = &intel_connector->base;\n\tstruct dentry *root = connector->debugfs_entry;\n\tstruct drm_i915_private *dev_priv = to_i915(connector->dev);\n\n\t \n\tif (!root)\n\t\treturn;\n\n\tintel_drrs_connector_debugfs_add(intel_connector);\n\tintel_psr_connector_debugfs_add(intel_connector);\n\n\tif (connector->connector_type == DRM_MODE_CONNECTOR_eDP)\n\t\tdebugfs_create_file(\"i915_panel_timings\", S_IRUGO, root,\n\t\t\t\t    connector, &i915_panel_fops);\n\n\tif (connector->connector_type == DRM_MODE_CONNECTOR_DisplayPort ||\n\t    connector->connector_type == DRM_MODE_CONNECTOR_HDMIA ||\n\t    connector->connector_type == DRM_MODE_CONNECTOR_HDMIB) {\n\t\tdebugfs_create_file(\"i915_hdcp_sink_capability\", S_IRUGO, root,\n\t\t\t\t    connector, &i915_hdcp_sink_capability_fops);\n\t}\n\n\tif (DISPLAY_VER(dev_priv) >= 11 &&\n\t    ((connector->connector_type == DRM_MODE_CONNECTOR_DisplayPort &&\n\t    !to_intel_connector(connector)->mst_port) ||\n\t    connector->connector_type == DRM_MODE_CONNECTOR_eDP)) {\n\t\tdebugfs_create_file(\"i915_dsc_fec_support\", 0644, root,\n\t\t\t\t    connector, &i915_dsc_fec_support_fops);\n\n\t\tdebugfs_create_file(\"i915_dsc_bpc\", 0644, root,\n\t\t\t\t    connector, &i915_dsc_bpc_fops);\n\n\t\tdebugfs_create_file(\"i915_dsc_output_format\", 0644, root,\n\t\t\t\t    connector, &i915_dsc_output_format_fops);\n\t}\n\n\tif (connector->connector_type == DRM_MODE_CONNECTOR_DSI ||\n\t    connector->connector_type == DRM_MODE_CONNECTOR_eDP ||\n\t    connector->connector_type == DRM_MODE_CONNECTOR_DisplayPort ||\n\t    connector->connector_type == DRM_MODE_CONNECTOR_HDMIA ||\n\t    connector->connector_type == DRM_MODE_CONNECTOR_HDMIB)\n\t\tdebugfs_create_file(\"i915_lpsp_capability\", 0444, root,\n\t\t\t\t    connector, &i915_lpsp_capability_fops);\n}\n\n \nvoid intel_crtc_debugfs_add(struct intel_crtc *crtc)\n{\n\tstruct dentry *root = crtc->base.debugfs_entry;\n\n\tif (!root)\n\t\treturn;\n\n\tcrtc_updates_add(crtc);\n\tintel_drrs_crtc_debugfs_add(crtc);\n\tintel_fbc_crtc_debugfs_add(crtc);\n\thsw_ips_crtc_debugfs_add(crtc);\n\n\tdebugfs_create_file(\"i915_current_bpc\", 0444, root, crtc,\n\t\t\t    &i915_current_bpc_fops);\n\tdebugfs_create_file(\"i915_pipe\", 0444, root, crtc,\n\t\t\t    &intel_crtc_pipe_fops);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}