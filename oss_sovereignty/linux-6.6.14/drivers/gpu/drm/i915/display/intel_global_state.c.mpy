{
  "module_name": "intel_global_state.c",
  "hash_id": "1a388976d7b587162c1e6392c9169530aabacc5a25c66b4648ab48d9e53e9958",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/i915/display/intel_global_state.c",
  "human_readable_source": "\n \n\n#include <linux/string.h>\n\n#include \"i915_drv.h\"\n#include \"intel_atomic.h\"\n#include \"intel_display_types.h\"\n#include \"intel_global_state.h\"\n\nstatic void __intel_atomic_global_state_free(struct kref *kref)\n{\n\tstruct intel_global_state *obj_state =\n\t\tcontainer_of(kref, struct intel_global_state, ref);\n\tstruct intel_global_obj *obj = obj_state->obj;\n\n\tobj->funcs->atomic_destroy_state(obj, obj_state);\n}\n\nstatic void intel_atomic_global_state_put(struct intel_global_state *obj_state)\n{\n\tkref_put(&obj_state->ref, __intel_atomic_global_state_free);\n}\n\nstatic struct intel_global_state *\nintel_atomic_global_state_get(struct intel_global_state *obj_state)\n{\n\tkref_get(&obj_state->ref);\n\n\treturn obj_state;\n}\n\nvoid intel_atomic_global_obj_init(struct drm_i915_private *dev_priv,\n\t\t\t\t  struct intel_global_obj *obj,\n\t\t\t\t  struct intel_global_state *state,\n\t\t\t\t  const struct intel_global_state_funcs *funcs)\n{\n\tmemset(obj, 0, sizeof(*obj));\n\n\tstate->obj = obj;\n\n\tkref_init(&state->ref);\n\n\tobj->state = state;\n\tobj->funcs = funcs;\n\tlist_add_tail(&obj->head, &dev_priv->display.global.obj_list);\n}\n\nvoid intel_atomic_global_obj_cleanup(struct drm_i915_private *dev_priv)\n{\n\tstruct intel_global_obj *obj, *next;\n\n\tlist_for_each_entry_safe(obj, next, &dev_priv->display.global.obj_list, head) {\n\t\tlist_del(&obj->head);\n\n\t\tdrm_WARN_ON(&dev_priv->drm, kref_read(&obj->state->ref) != 1);\n\t\tintel_atomic_global_state_put(obj->state);\n\t}\n}\n\nstatic void assert_global_state_write_locked(struct drm_i915_private *dev_priv)\n{\n\tstruct intel_crtc *crtc;\n\n\tfor_each_intel_crtc(&dev_priv->drm, crtc)\n\t\tdrm_modeset_lock_assert_held(&crtc->base.mutex);\n}\n\nstatic bool modeset_lock_is_held(struct drm_modeset_acquire_ctx *ctx,\n\t\t\t\t struct drm_modeset_lock *lock)\n{\n\tstruct drm_modeset_lock *l;\n\n\tlist_for_each_entry(l, &ctx->locked, head) {\n\t\tif (lock == l)\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}\n\nstatic void assert_global_state_read_locked(struct intel_atomic_state *state)\n{\n\tstruct drm_modeset_acquire_ctx *ctx = state->base.acquire_ctx;\n\tstruct drm_i915_private *dev_priv = to_i915(state->base.dev);\n\tstruct intel_crtc *crtc;\n\n\tfor_each_intel_crtc(&dev_priv->drm, crtc) {\n\t\tif (modeset_lock_is_held(ctx, &crtc->base.mutex))\n\t\t\treturn;\n\t}\n\n\tdrm_WARN(&dev_priv->drm, 1, \"Global state not read locked\\n\");\n}\n\nstruct intel_global_state *\nintel_atomic_get_global_obj_state(struct intel_atomic_state *state,\n\t\t\t\t  struct intel_global_obj *obj)\n{\n\tstruct drm_i915_private *i915 = to_i915(state->base.dev);\n\tint index, num_objs, i;\n\tsize_t size;\n\tstruct __intel_global_objs_state *arr;\n\tstruct intel_global_state *obj_state;\n\n\tfor (i = 0; i < state->num_global_objs; i++)\n\t\tif (obj == state->global_objs[i].ptr)\n\t\t\treturn state->global_objs[i].state;\n\n\tassert_global_state_read_locked(state);\n\n\tnum_objs = state->num_global_objs + 1;\n\tsize = sizeof(*state->global_objs) * num_objs;\n\tarr = krealloc(state->global_objs, size, GFP_KERNEL);\n\tif (!arr)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tstate->global_objs = arr;\n\tindex = state->num_global_objs;\n\tmemset(&state->global_objs[index], 0, sizeof(*state->global_objs));\n\n\tobj_state = obj->funcs->atomic_duplicate_state(obj);\n\tif (!obj_state)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tobj_state->obj = obj;\n\tobj_state->changed = false;\n\n\tkref_init(&obj_state->ref);\n\n\tstate->global_objs[index].state = obj_state;\n\tstate->global_objs[index].old_state =\n\t\tintel_atomic_global_state_get(obj->state);\n\tstate->global_objs[index].new_state = obj_state;\n\tstate->global_objs[index].ptr = obj;\n\tobj_state->state = state;\n\n\tstate->num_global_objs = num_objs;\n\n\tdrm_dbg_atomic(&i915->drm, \"Added new global object %p state %p to %p\\n\",\n\t\t       obj, obj_state, state);\n\n\treturn obj_state;\n}\n\nstruct intel_global_state *\nintel_atomic_get_old_global_obj_state(struct intel_atomic_state *state,\n\t\t\t\t      struct intel_global_obj *obj)\n{\n\tint i;\n\n\tfor (i = 0; i < state->num_global_objs; i++)\n\t\tif (obj == state->global_objs[i].ptr)\n\t\t\treturn state->global_objs[i].old_state;\n\n\treturn NULL;\n}\n\nstruct intel_global_state *\nintel_atomic_get_new_global_obj_state(struct intel_atomic_state *state,\n\t\t\t\t      struct intel_global_obj *obj)\n{\n\tint i;\n\n\tfor (i = 0; i < state->num_global_objs; i++)\n\t\tif (obj == state->global_objs[i].ptr)\n\t\t\treturn state->global_objs[i].new_state;\n\n\treturn NULL;\n}\n\nvoid intel_atomic_swap_global_state(struct intel_atomic_state *state)\n{\n\tstruct drm_i915_private *dev_priv = to_i915(state->base.dev);\n\tstruct intel_global_state *old_obj_state, *new_obj_state;\n\tstruct intel_global_obj *obj;\n\tint i;\n\n\tfor_each_oldnew_global_obj_in_state(state, obj, old_obj_state,\n\t\t\t\t\t    new_obj_state, i) {\n\t\tdrm_WARN_ON(&dev_priv->drm, obj->state != old_obj_state);\n\n\t\t \n\t\tif (!new_obj_state->changed)\n\t\t\tcontinue;\n\n\t\tassert_global_state_write_locked(dev_priv);\n\n\t\told_obj_state->state = state;\n\t\tnew_obj_state->state = NULL;\n\n\t\tstate->global_objs[i].state = old_obj_state;\n\n\t\tintel_atomic_global_state_put(obj->state);\n\t\tobj->state = intel_atomic_global_state_get(new_obj_state);\n\t}\n}\n\nvoid intel_atomic_clear_global_state(struct intel_atomic_state *state)\n{\n\tint i;\n\n\tfor (i = 0; i < state->num_global_objs; i++) {\n\t\tintel_atomic_global_state_put(state->global_objs[i].old_state);\n\t\tintel_atomic_global_state_put(state->global_objs[i].new_state);\n\n\t\tstate->global_objs[i].ptr = NULL;\n\t\tstate->global_objs[i].state = NULL;\n\t\tstate->global_objs[i].old_state = NULL;\n\t\tstate->global_objs[i].new_state = NULL;\n\t}\n\tstate->num_global_objs = 0;\n}\n\nint intel_atomic_lock_global_state(struct intel_global_state *obj_state)\n{\n\tstruct intel_atomic_state *state = obj_state->state;\n\tstruct drm_i915_private *dev_priv = to_i915(state->base.dev);\n\tstruct intel_crtc *crtc;\n\n\tfor_each_intel_crtc(&dev_priv->drm, crtc) {\n\t\tint ret;\n\n\t\tret = drm_modeset_lock(&crtc->base.mutex,\n\t\t\t\t       state->base.acquire_ctx);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tobj_state->changed = true;\n\n\treturn 0;\n}\n\nint intel_atomic_serialize_global_state(struct intel_global_state *obj_state)\n{\n\tstruct intel_atomic_state *state = obj_state->state;\n\tstruct drm_i915_private *dev_priv = to_i915(state->base.dev);\n\tstruct intel_crtc *crtc;\n\n\tfor_each_intel_crtc(&dev_priv->drm, crtc) {\n\t\tstruct intel_crtc_state *crtc_state;\n\n\t\tcrtc_state = intel_atomic_get_crtc_state(&state->base, crtc);\n\t\tif (IS_ERR(crtc_state))\n\t\t\treturn PTR_ERR(crtc_state);\n\t}\n\n\tobj_state->changed = true;\n\n\treturn 0;\n}\n\nbool\nintel_atomic_global_state_is_serialized(struct intel_atomic_state *state)\n{\n\tstruct drm_i915_private *i915 = to_i915(state->base.dev);\n\tstruct intel_crtc *crtc;\n\n\tfor_each_intel_crtc(&i915->drm, crtc)\n\t\tif (!intel_atomic_get_new_crtc_state(state, crtc))\n\t\t\treturn false;\n\treturn true;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}