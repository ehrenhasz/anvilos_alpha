{
  "module_name": "i9xx_plane.c",
  "hash_id": "d1e88a588672e62aa424a8377ba11c58b72ee182a5d244568e6ace982f76cf73",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/i915/display/i9xx_plane.c",
  "human_readable_source": "\n \n#include <linux/kernel.h>\n\n#include <drm/drm_atomic_helper.h>\n#include <drm/drm_blend.h>\n#include <drm/drm_fourcc.h>\n\n#include \"i915_reg.h\"\n#include \"i9xx_plane.h\"\n#include \"intel_atomic.h\"\n#include \"intel_atomic_plane.h\"\n#include \"intel_de.h\"\n#include \"intel_display_irq.h\"\n#include \"intel_display_types.h\"\n#include \"intel_fb.h\"\n#include \"intel_fbc.h\"\n#include \"intel_sprite.h\"\n\n \nstatic const u32 i8xx_primary_formats[] = {\n\tDRM_FORMAT_C8,\n\tDRM_FORMAT_XRGB1555,\n\tDRM_FORMAT_RGB565,\n\tDRM_FORMAT_XRGB8888,\n};\n\n \nstatic const u32 ivb_primary_formats[] = {\n\tDRM_FORMAT_C8,\n\tDRM_FORMAT_RGB565,\n\tDRM_FORMAT_XRGB8888,\n\tDRM_FORMAT_XBGR8888,\n\tDRM_FORMAT_XRGB2101010,\n\tDRM_FORMAT_XBGR2101010,\n};\n\n \nstatic const u32 i965_primary_formats[] = {\n\tDRM_FORMAT_C8,\n\tDRM_FORMAT_RGB565,\n\tDRM_FORMAT_XRGB8888,\n\tDRM_FORMAT_XBGR8888,\n\tDRM_FORMAT_XRGB2101010,\n\tDRM_FORMAT_XBGR2101010,\n\tDRM_FORMAT_XBGR16161616F,\n};\n\n \nstatic const u32 vlv_primary_formats[] = {\n\tDRM_FORMAT_C8,\n\tDRM_FORMAT_RGB565,\n\tDRM_FORMAT_XRGB8888,\n\tDRM_FORMAT_XBGR8888,\n\tDRM_FORMAT_ARGB8888,\n\tDRM_FORMAT_ABGR8888,\n\tDRM_FORMAT_XRGB2101010,\n\tDRM_FORMAT_XBGR2101010,\n\tDRM_FORMAT_ARGB2101010,\n\tDRM_FORMAT_ABGR2101010,\n\tDRM_FORMAT_XBGR16161616F,\n};\n\nstatic bool i8xx_plane_format_mod_supported(struct drm_plane *_plane,\n\t\t\t\t\t    u32 format, u64 modifier)\n{\n\tif (!intel_fb_plane_supports_modifier(to_intel_plane(_plane), modifier))\n\t\treturn false;\n\n\tswitch (format) {\n\tcase DRM_FORMAT_C8:\n\tcase DRM_FORMAT_RGB565:\n\tcase DRM_FORMAT_XRGB1555:\n\tcase DRM_FORMAT_XRGB8888:\n\t\treturn modifier == DRM_FORMAT_MOD_LINEAR ||\n\t\t\tmodifier == I915_FORMAT_MOD_X_TILED;\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nstatic bool i965_plane_format_mod_supported(struct drm_plane *_plane,\n\t\t\t\t\t    u32 format, u64 modifier)\n{\n\tif (!intel_fb_plane_supports_modifier(to_intel_plane(_plane), modifier))\n\t\treturn false;\n\n\tswitch (format) {\n\tcase DRM_FORMAT_C8:\n\tcase DRM_FORMAT_RGB565:\n\tcase DRM_FORMAT_XRGB8888:\n\tcase DRM_FORMAT_XBGR8888:\n\tcase DRM_FORMAT_ARGB8888:\n\tcase DRM_FORMAT_ABGR8888:\n\tcase DRM_FORMAT_XRGB2101010:\n\tcase DRM_FORMAT_XBGR2101010:\n\tcase DRM_FORMAT_ARGB2101010:\n\tcase DRM_FORMAT_ABGR2101010:\n\tcase DRM_FORMAT_XBGR16161616F:\n\t\treturn modifier == DRM_FORMAT_MOD_LINEAR ||\n\t\t\tmodifier == I915_FORMAT_MOD_X_TILED;\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nstatic bool i9xx_plane_has_fbc(struct drm_i915_private *dev_priv,\n\t\t\t       enum i9xx_plane_id i9xx_plane)\n{\n\tif (!HAS_FBC(dev_priv))\n\t\treturn false;\n\n\tif (IS_BROADWELL(dev_priv) || IS_HASWELL(dev_priv))\n\t\treturn i9xx_plane == PLANE_A;  \n\telse if (IS_IVYBRIDGE(dev_priv))\n\t\treturn i9xx_plane == PLANE_A || i9xx_plane == PLANE_B ||\n\t\t\ti9xx_plane == PLANE_C;\n\telse if (DISPLAY_VER(dev_priv) >= 4)\n\t\treturn i9xx_plane == PLANE_A || i9xx_plane == PLANE_B;\n\telse\n\t\treturn i9xx_plane == PLANE_A;\n}\n\nstatic struct intel_fbc *i9xx_plane_fbc(struct drm_i915_private *dev_priv,\n\t\t\t\t\tenum i9xx_plane_id i9xx_plane)\n{\n\tif (i9xx_plane_has_fbc(dev_priv, i9xx_plane))\n\t\treturn dev_priv->display.fbc[INTEL_FBC_A];\n\telse\n\t\treturn NULL;\n}\n\nstatic bool i9xx_plane_has_windowing(struct intel_plane *plane)\n{\n\tstruct drm_i915_private *dev_priv = to_i915(plane->base.dev);\n\tenum i9xx_plane_id i9xx_plane = plane->i9xx_plane;\n\n\tif (IS_CHERRYVIEW(dev_priv))\n\t\treturn i9xx_plane == PLANE_B;\n\telse if (DISPLAY_VER(dev_priv) >= 5 || IS_G4X(dev_priv))\n\t\treturn false;\n\telse if (DISPLAY_VER(dev_priv) == 4)\n\t\treturn i9xx_plane == PLANE_C;\n\telse\n\t\treturn i9xx_plane == PLANE_B ||\n\t\t\ti9xx_plane == PLANE_C;\n}\n\nstatic u32 i9xx_plane_ctl(const struct intel_crtc_state *crtc_state,\n\t\t\t  const struct intel_plane_state *plane_state)\n{\n\tstruct drm_i915_private *dev_priv =\n\t\tto_i915(plane_state->uapi.plane->dev);\n\tconst struct drm_framebuffer *fb = plane_state->hw.fb;\n\tunsigned int rotation = plane_state->hw.rotation;\n\tu32 dspcntr;\n\n\tdspcntr = DISP_ENABLE;\n\n\tif (IS_G4X(dev_priv) || IS_IRONLAKE(dev_priv) ||\n\t    IS_SANDYBRIDGE(dev_priv) || IS_IVYBRIDGE(dev_priv))\n\t\tdspcntr |= DISP_TRICKLE_FEED_DISABLE;\n\n\tswitch (fb->format->format) {\n\tcase DRM_FORMAT_C8:\n\t\tdspcntr |= DISP_FORMAT_8BPP;\n\t\tbreak;\n\tcase DRM_FORMAT_XRGB1555:\n\t\tdspcntr |= DISP_FORMAT_BGRX555;\n\t\tbreak;\n\tcase DRM_FORMAT_ARGB1555:\n\t\tdspcntr |= DISP_FORMAT_BGRA555;\n\t\tbreak;\n\tcase DRM_FORMAT_RGB565:\n\t\tdspcntr |= DISP_FORMAT_BGRX565;\n\t\tbreak;\n\tcase DRM_FORMAT_XRGB8888:\n\t\tdspcntr |= DISP_FORMAT_BGRX888;\n\t\tbreak;\n\tcase DRM_FORMAT_XBGR8888:\n\t\tdspcntr |= DISP_FORMAT_RGBX888;\n\t\tbreak;\n\tcase DRM_FORMAT_ARGB8888:\n\t\tdspcntr |= DISP_FORMAT_BGRA888;\n\t\tbreak;\n\tcase DRM_FORMAT_ABGR8888:\n\t\tdspcntr |= DISP_FORMAT_RGBA888;\n\t\tbreak;\n\tcase DRM_FORMAT_XRGB2101010:\n\t\tdspcntr |= DISP_FORMAT_BGRX101010;\n\t\tbreak;\n\tcase DRM_FORMAT_XBGR2101010:\n\t\tdspcntr |= DISP_FORMAT_RGBX101010;\n\t\tbreak;\n\tcase DRM_FORMAT_ARGB2101010:\n\t\tdspcntr |= DISP_FORMAT_BGRA101010;\n\t\tbreak;\n\tcase DRM_FORMAT_ABGR2101010:\n\t\tdspcntr |= DISP_FORMAT_RGBA101010;\n\t\tbreak;\n\tcase DRM_FORMAT_XBGR16161616F:\n\t\tdspcntr |= DISP_FORMAT_RGBX161616;\n\t\tbreak;\n\tdefault:\n\t\tMISSING_CASE(fb->format->format);\n\t\treturn 0;\n\t}\n\n\tif (DISPLAY_VER(dev_priv) >= 4 &&\n\t    fb->modifier == I915_FORMAT_MOD_X_TILED)\n\t\tdspcntr |= DISP_TILED;\n\n\tif (rotation & DRM_MODE_ROTATE_180)\n\t\tdspcntr |= DISP_ROTATE_180;\n\n\tif (rotation & DRM_MODE_REFLECT_X)\n\t\tdspcntr |= DISP_MIRROR;\n\n\treturn dspcntr;\n}\n\nint i9xx_check_plane_surface(struct intel_plane_state *plane_state)\n{\n\tstruct drm_i915_private *dev_priv =\n\t\tto_i915(plane_state->uapi.plane->dev);\n\tconst struct drm_framebuffer *fb = plane_state->hw.fb;\n\tint src_x, src_y, src_w;\n\tu32 offset;\n\tint ret;\n\n\tret = intel_plane_compute_gtt(plane_state);\n\tif (ret)\n\t\treturn ret;\n\n\tif (!plane_state->uapi.visible)\n\t\treturn 0;\n\n\tsrc_w = drm_rect_width(&plane_state->uapi.src) >> 16;\n\tsrc_x = plane_state->uapi.src.x1 >> 16;\n\tsrc_y = plane_state->uapi.src.y1 >> 16;\n\n\t \n\tif (HAS_GMCH(dev_priv) && fb->format->cpp[0] == 8 && src_w > 2048)\n\t\treturn -EINVAL;\n\n\tintel_add_fb_offsets(&src_x, &src_y, plane_state, 0);\n\n\tif (DISPLAY_VER(dev_priv) >= 4)\n\t\toffset = intel_plane_compute_aligned_offset(&src_x, &src_y,\n\t\t\t\t\t\t\t    plane_state, 0);\n\telse\n\t\toffset = 0;\n\n\t \n\tif (DISPLAY_VER(dev_priv) >= 4 && fb->modifier == I915_FORMAT_MOD_X_TILED) {\n\t\tu32 alignment = intel_surf_alignment(fb, 0);\n\t\tint cpp = fb->format->cpp[0];\n\n\t\twhile ((src_x + src_w) * cpp > plane_state->view.color_plane[0].mapping_stride) {\n\t\t\tif (offset == 0) {\n\t\t\t\tdrm_dbg_kms(&dev_priv->drm,\n\t\t\t\t\t    \"Unable to find suitable display surface offset due to X-tiling\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\n\t\t\toffset = intel_plane_adjust_aligned_offset(&src_x, &src_y, plane_state, 0,\n\t\t\t\t\t\t\t\t   offset, offset - alignment);\n\t\t}\n\t}\n\n\t \n\tdrm_rect_translate_to(&plane_state->uapi.src,\n\t\t\t      src_x << 16, src_y << 16);\n\n\t \n\tif (!IS_HASWELL(dev_priv) && !IS_BROADWELL(dev_priv)) {\n\t\tunsigned int rotation = plane_state->hw.rotation;\n\t\tint src_w = drm_rect_width(&plane_state->uapi.src) >> 16;\n\t\tint src_h = drm_rect_height(&plane_state->uapi.src) >> 16;\n\n\t\tif (rotation & DRM_MODE_ROTATE_180) {\n\t\t\tsrc_x += src_w - 1;\n\t\t\tsrc_y += src_h - 1;\n\t\t} else if (rotation & DRM_MODE_REFLECT_X) {\n\t\t\tsrc_x += src_w - 1;\n\t\t}\n\t}\n\n\tif (IS_HASWELL(dev_priv) || IS_BROADWELL(dev_priv)) {\n\t\tdrm_WARN_ON(&dev_priv->drm, src_x > 8191 || src_y > 4095);\n\t} else if (DISPLAY_VER(dev_priv) >= 4 &&\n\t\t   fb->modifier == I915_FORMAT_MOD_X_TILED) {\n\t\tdrm_WARN_ON(&dev_priv->drm, src_x > 4095 || src_y > 4095);\n\t}\n\n\tplane_state->view.color_plane[0].offset = offset;\n\tplane_state->view.color_plane[0].x = src_x;\n\tplane_state->view.color_plane[0].y = src_y;\n\n\treturn 0;\n}\n\nstatic int\ni9xx_plane_check(struct intel_crtc_state *crtc_state,\n\t\t struct intel_plane_state *plane_state)\n{\n\tstruct intel_plane *plane = to_intel_plane(plane_state->uapi.plane);\n\tint ret;\n\n\tret = chv_plane_check_rotation(plane_state);\n\tif (ret)\n\t\treturn ret;\n\n\tret = intel_atomic_plane_check_clipping(plane_state, crtc_state,\n\t\t\t\t\t\tDRM_PLANE_NO_SCALING,\n\t\t\t\t\t\tDRM_PLANE_NO_SCALING,\n\t\t\t\t\t\ti9xx_plane_has_windowing(plane));\n\tif (ret)\n\t\treturn ret;\n\n\tret = i9xx_check_plane_surface(plane_state);\n\tif (ret)\n\t\treturn ret;\n\n\tif (!plane_state->uapi.visible)\n\t\treturn 0;\n\n\tret = intel_plane_check_src_coordinates(plane_state);\n\tif (ret)\n\t\treturn ret;\n\n\tplane_state->ctl = i9xx_plane_ctl(crtc_state, plane_state);\n\n\treturn 0;\n}\n\nstatic u32 i9xx_plane_ctl_crtc(const struct intel_crtc_state *crtc_state)\n{\n\tstruct intel_crtc *crtc = to_intel_crtc(crtc_state->uapi.crtc);\n\tstruct drm_i915_private *dev_priv = to_i915(crtc->base.dev);\n\tu32 dspcntr = 0;\n\n\tif (crtc_state->gamma_enable)\n\t\tdspcntr |= DISP_PIPE_GAMMA_ENABLE;\n\n\tif (crtc_state->csc_enable)\n\t\tdspcntr |= DISP_PIPE_CSC_ENABLE;\n\n\tif (DISPLAY_VER(dev_priv) < 5)\n\t\tdspcntr |= DISP_PIPE_SEL(crtc->pipe);\n\n\treturn dspcntr;\n}\n\nstatic void i9xx_plane_ratio(const struct intel_crtc_state *crtc_state,\n\t\t\t     const struct intel_plane_state *plane_state,\n\t\t\t     unsigned int *num, unsigned int *den)\n{\n\tconst struct drm_framebuffer *fb = plane_state->hw.fb;\n\tunsigned int cpp = fb->format->cpp[0];\n\n\t \n\tif (cpp == 8) {\n\t\t*num = 10;\n\t\t*den = 8;\n\t} else {\n\t\t*num = 1;\n\t\t*den = 1;\n\t}\n}\n\nstatic int i9xx_plane_min_cdclk(const struct intel_crtc_state *crtc_state,\n\t\t\t\tconst struct intel_plane_state *plane_state)\n{\n\tunsigned int pixel_rate;\n\tunsigned int num, den;\n\n\t \n\tpixel_rate = crtc_state->pixel_rate;\n\n\ti9xx_plane_ratio(crtc_state, plane_state, &num, &den);\n\n\t \n\tif (crtc_state->double_wide)\n\t\tden *= 2;\n\n\treturn DIV_ROUND_UP(pixel_rate * num, den);\n}\n\nstatic void i9xx_plane_update_noarm(struct intel_plane *plane,\n\t\t\t\t    const struct intel_crtc_state *crtc_state,\n\t\t\t\t    const struct intel_plane_state *plane_state)\n{\n\tstruct drm_i915_private *dev_priv = to_i915(plane->base.dev);\n\tenum i9xx_plane_id i9xx_plane = plane->i9xx_plane;\n\n\tintel_de_write_fw(dev_priv, DSPSTRIDE(i9xx_plane),\n\t\t\t  plane_state->view.color_plane[0].mapping_stride);\n\n\tif (DISPLAY_VER(dev_priv) < 4) {\n\t\tint crtc_x = plane_state->uapi.dst.x1;\n\t\tint crtc_y = plane_state->uapi.dst.y1;\n\t\tint crtc_w = drm_rect_width(&plane_state->uapi.dst);\n\t\tint crtc_h = drm_rect_height(&plane_state->uapi.dst);\n\n\t\t \n\t\tintel_de_write_fw(dev_priv, DSPPOS(i9xx_plane),\n\t\t\t\t  DISP_POS_Y(crtc_y) | DISP_POS_X(crtc_x));\n\t\tintel_de_write_fw(dev_priv, DSPSIZE(i9xx_plane),\n\t\t\t\t  DISP_HEIGHT(crtc_h - 1) | DISP_WIDTH(crtc_w - 1));\n\t}\n}\n\nstatic void i9xx_plane_update_arm(struct intel_plane *plane,\n\t\t\t\t  const struct intel_crtc_state *crtc_state,\n\t\t\t\t  const struct intel_plane_state *plane_state)\n{\n\tstruct drm_i915_private *dev_priv = to_i915(plane->base.dev);\n\tenum i9xx_plane_id i9xx_plane = plane->i9xx_plane;\n\tint x = plane_state->view.color_plane[0].x;\n\tint y = plane_state->view.color_plane[0].y;\n\tu32 dspcntr, dspaddr_offset, linear_offset;\n\n\tdspcntr = plane_state->ctl | i9xx_plane_ctl_crtc(crtc_state);\n\n\tlinear_offset = intel_fb_xy_to_linear(x, y, plane_state, 0);\n\n\tif (DISPLAY_VER(dev_priv) >= 4)\n\t\tdspaddr_offset = plane_state->view.color_plane[0].offset;\n\telse\n\t\tdspaddr_offset = linear_offset;\n\n\tif (IS_CHERRYVIEW(dev_priv) && i9xx_plane == PLANE_B) {\n\t\tint crtc_x = plane_state->uapi.dst.x1;\n\t\tint crtc_y = plane_state->uapi.dst.y1;\n\t\tint crtc_w = drm_rect_width(&plane_state->uapi.dst);\n\t\tint crtc_h = drm_rect_height(&plane_state->uapi.dst);\n\n\t\tintel_de_write_fw(dev_priv, PRIMPOS(i9xx_plane),\n\t\t\t\t  PRIM_POS_Y(crtc_y) | PRIM_POS_X(crtc_x));\n\t\tintel_de_write_fw(dev_priv, PRIMSIZE(i9xx_plane),\n\t\t\t\t  PRIM_HEIGHT(crtc_h - 1) | PRIM_WIDTH(crtc_w - 1));\n\t\tintel_de_write_fw(dev_priv, PRIMCNSTALPHA(i9xx_plane), 0);\n\t}\n\n\tif (IS_HASWELL(dev_priv) || IS_BROADWELL(dev_priv)) {\n\t\tintel_de_write_fw(dev_priv, DSPOFFSET(i9xx_plane),\n\t\t\t\t  DISP_OFFSET_Y(y) | DISP_OFFSET_X(x));\n\t} else if (DISPLAY_VER(dev_priv) >= 4) {\n\t\tintel_de_write_fw(dev_priv, DSPLINOFF(i9xx_plane),\n\t\t\t\t  linear_offset);\n\t\tintel_de_write_fw(dev_priv, DSPTILEOFF(i9xx_plane),\n\t\t\t\t  DISP_OFFSET_Y(y) | DISP_OFFSET_X(x));\n\t}\n\n\t \n\tintel_de_write_fw(dev_priv, DSPCNTR(i9xx_plane), dspcntr);\n\n\tif (DISPLAY_VER(dev_priv) >= 4)\n\t\tintel_de_write_fw(dev_priv, DSPSURF(i9xx_plane),\n\t\t\t\t  intel_plane_ggtt_offset(plane_state) + dspaddr_offset);\n\telse\n\t\tintel_de_write_fw(dev_priv, DSPADDR(i9xx_plane),\n\t\t\t\t  intel_plane_ggtt_offset(plane_state) + dspaddr_offset);\n}\n\nstatic void i830_plane_update_arm(struct intel_plane *plane,\n\t\t\t\t  const struct intel_crtc_state *crtc_state,\n\t\t\t\t  const struct intel_plane_state *plane_state)\n{\n\t \n\ti9xx_plane_update_noarm(plane, crtc_state, plane_state);\n\ti9xx_plane_update_arm(plane, crtc_state, plane_state);\n}\n\nstatic void i9xx_plane_disable_arm(struct intel_plane *plane,\n\t\t\t\t   const struct intel_crtc_state *crtc_state)\n{\n\tstruct drm_i915_private *dev_priv = to_i915(plane->base.dev);\n\tenum i9xx_plane_id i9xx_plane = plane->i9xx_plane;\n\tu32 dspcntr;\n\n\t \n\tdspcntr = i9xx_plane_ctl_crtc(crtc_state);\n\n\tintel_de_write_fw(dev_priv, DSPCNTR(i9xx_plane), dspcntr);\n\n\tif (DISPLAY_VER(dev_priv) >= 4)\n\t\tintel_de_write_fw(dev_priv, DSPSURF(i9xx_plane), 0);\n\telse\n\t\tintel_de_write_fw(dev_priv, DSPADDR(i9xx_plane), 0);\n}\n\nstatic void\ng4x_primary_async_flip(struct intel_plane *plane,\n\t\t       const struct intel_crtc_state *crtc_state,\n\t\t       const struct intel_plane_state *plane_state,\n\t\t       bool async_flip)\n{\n\tstruct drm_i915_private *dev_priv = to_i915(plane->base.dev);\n\tu32 dspcntr = plane_state->ctl | i9xx_plane_ctl_crtc(crtc_state);\n\tu32 dspaddr_offset = plane_state->view.color_plane[0].offset;\n\tenum i9xx_plane_id i9xx_plane = plane->i9xx_plane;\n\n\tif (async_flip)\n\t\tdspcntr |= DISP_ASYNC_FLIP;\n\n\tintel_de_write_fw(dev_priv, DSPCNTR(i9xx_plane), dspcntr);\n\n\tintel_de_write_fw(dev_priv, DSPSURF(i9xx_plane),\n\t\t\t  intel_plane_ggtt_offset(plane_state) + dspaddr_offset);\n}\n\nstatic void\nvlv_primary_async_flip(struct intel_plane *plane,\n\t\t       const struct intel_crtc_state *crtc_state,\n\t\t       const struct intel_plane_state *plane_state,\n\t\t       bool async_flip)\n{\n\tstruct drm_i915_private *dev_priv = to_i915(plane->base.dev);\n\tu32 dspaddr_offset = plane_state->view.color_plane[0].offset;\n\tenum i9xx_plane_id i9xx_plane = plane->i9xx_plane;\n\n\tintel_de_write_fw(dev_priv, DSPADDR_VLV(i9xx_plane),\n\t\t\t  intel_plane_ggtt_offset(plane_state) + dspaddr_offset);\n}\n\nstatic void\nbdw_primary_enable_flip_done(struct intel_plane *plane)\n{\n\tstruct drm_i915_private *i915 = to_i915(plane->base.dev);\n\tenum pipe pipe = plane->pipe;\n\n\tspin_lock_irq(&i915->irq_lock);\n\tbdw_enable_pipe_irq(i915, pipe, GEN8_PIPE_PRIMARY_FLIP_DONE);\n\tspin_unlock_irq(&i915->irq_lock);\n}\n\nstatic void\nbdw_primary_disable_flip_done(struct intel_plane *plane)\n{\n\tstruct drm_i915_private *i915 = to_i915(plane->base.dev);\n\tenum pipe pipe = plane->pipe;\n\n\tspin_lock_irq(&i915->irq_lock);\n\tbdw_disable_pipe_irq(i915, pipe, GEN8_PIPE_PRIMARY_FLIP_DONE);\n\tspin_unlock_irq(&i915->irq_lock);\n}\n\nstatic void\nivb_primary_enable_flip_done(struct intel_plane *plane)\n{\n\tstruct drm_i915_private *i915 = to_i915(plane->base.dev);\n\n\tspin_lock_irq(&i915->irq_lock);\n\tilk_enable_display_irq(i915, DE_PLANE_FLIP_DONE_IVB(plane->i9xx_plane));\n\tspin_unlock_irq(&i915->irq_lock);\n}\n\nstatic void\nivb_primary_disable_flip_done(struct intel_plane *plane)\n{\n\tstruct drm_i915_private *i915 = to_i915(plane->base.dev);\n\n\tspin_lock_irq(&i915->irq_lock);\n\tilk_disable_display_irq(i915, DE_PLANE_FLIP_DONE_IVB(plane->i9xx_plane));\n\tspin_unlock_irq(&i915->irq_lock);\n}\n\nstatic void\nilk_primary_enable_flip_done(struct intel_plane *plane)\n{\n\tstruct drm_i915_private *i915 = to_i915(plane->base.dev);\n\n\tspin_lock_irq(&i915->irq_lock);\n\tilk_enable_display_irq(i915, DE_PLANE_FLIP_DONE(plane->i9xx_plane));\n\tspin_unlock_irq(&i915->irq_lock);\n}\n\nstatic void\nilk_primary_disable_flip_done(struct intel_plane *plane)\n{\n\tstruct drm_i915_private *i915 = to_i915(plane->base.dev);\n\n\tspin_lock_irq(&i915->irq_lock);\n\tilk_disable_display_irq(i915, DE_PLANE_FLIP_DONE(plane->i9xx_plane));\n\tspin_unlock_irq(&i915->irq_lock);\n}\n\nstatic void\nvlv_primary_enable_flip_done(struct intel_plane *plane)\n{\n\tstruct drm_i915_private *i915 = to_i915(plane->base.dev);\n\tenum pipe pipe = plane->pipe;\n\n\tspin_lock_irq(&i915->irq_lock);\n\ti915_enable_pipestat(i915, pipe, PLANE_FLIP_DONE_INT_STATUS_VLV);\n\tspin_unlock_irq(&i915->irq_lock);\n}\n\nstatic void\nvlv_primary_disable_flip_done(struct intel_plane *plane)\n{\n\tstruct drm_i915_private *i915 = to_i915(plane->base.dev);\n\tenum pipe pipe = plane->pipe;\n\n\tspin_lock_irq(&i915->irq_lock);\n\ti915_disable_pipestat(i915, pipe, PLANE_FLIP_DONE_INT_STATUS_VLV);\n\tspin_unlock_irq(&i915->irq_lock);\n}\n\nstatic bool i9xx_plane_get_hw_state(struct intel_plane *plane,\n\t\t\t\t    enum pipe *pipe)\n{\n\tstruct drm_i915_private *dev_priv = to_i915(plane->base.dev);\n\tenum intel_display_power_domain power_domain;\n\tenum i9xx_plane_id i9xx_plane = plane->i9xx_plane;\n\tintel_wakeref_t wakeref;\n\tbool ret;\n\tu32 val;\n\n\t \n\tpower_domain = POWER_DOMAIN_PIPE(plane->pipe);\n\twakeref = intel_display_power_get_if_enabled(dev_priv, power_domain);\n\tif (!wakeref)\n\t\treturn false;\n\n\tval = intel_de_read(dev_priv, DSPCNTR(i9xx_plane));\n\n\tret = val & DISP_ENABLE;\n\n\tif (DISPLAY_VER(dev_priv) >= 5)\n\t\t*pipe = plane->pipe;\n\telse\n\t\t*pipe = REG_FIELD_GET(DISP_PIPE_SEL_MASK, val);\n\n\tintel_display_power_put(dev_priv, power_domain, wakeref);\n\n\treturn ret;\n}\n\nstatic unsigned int\nhsw_primary_max_stride(struct intel_plane *plane,\n\t\t       u32 pixel_format, u64 modifier,\n\t\t       unsigned int rotation)\n{\n\tconst struct drm_format_info *info = drm_format_info(pixel_format);\n\tint cpp = info->cpp[0];\n\n\t \n\treturn min(8192 * cpp, 32 * 1024);\n}\n\nstatic unsigned int\nilk_primary_max_stride(struct intel_plane *plane,\n\t\t       u32 pixel_format, u64 modifier,\n\t\t       unsigned int rotation)\n{\n\tconst struct drm_format_info *info = drm_format_info(pixel_format);\n\tint cpp = info->cpp[0];\n\n\t \n\tif (modifier == I915_FORMAT_MOD_X_TILED)\n\t\treturn min(4096 * cpp, 32 * 1024);\n\telse\n\t\treturn 32 * 1024;\n}\n\nunsigned int\ni965_plane_max_stride(struct intel_plane *plane,\n\t\t      u32 pixel_format, u64 modifier,\n\t\t      unsigned int rotation)\n{\n\tconst struct drm_format_info *info = drm_format_info(pixel_format);\n\tint cpp = info->cpp[0];\n\n\t \n\tif (modifier == I915_FORMAT_MOD_X_TILED)\n\t\treturn min(4096 * cpp, 16 * 1024);\n\telse\n\t\treturn 32 * 1024;\n}\n\nstatic unsigned int\ni9xx_plane_max_stride(struct intel_plane *plane,\n\t\t      u32 pixel_format, u64 modifier,\n\t\t      unsigned int rotation)\n{\n\tstruct drm_i915_private *dev_priv = to_i915(plane->base.dev);\n\n\tif (DISPLAY_VER(dev_priv) >= 3) {\n\t\tif (modifier == I915_FORMAT_MOD_X_TILED)\n\t\t\treturn 8*1024;\n\t\telse\n\t\t\treturn 16*1024;\n\t} else {\n\t\tif (plane->i9xx_plane == PLANE_C)\n\t\t\treturn 4*1024;\n\t\telse\n\t\t\treturn 8*1024;\n\t}\n}\n\nstatic const struct drm_plane_funcs i965_plane_funcs = {\n\t.update_plane = drm_atomic_helper_update_plane,\n\t.disable_plane = drm_atomic_helper_disable_plane,\n\t.destroy = intel_plane_destroy,\n\t.atomic_duplicate_state = intel_plane_duplicate_state,\n\t.atomic_destroy_state = intel_plane_destroy_state,\n\t.format_mod_supported = i965_plane_format_mod_supported,\n};\n\nstatic const struct drm_plane_funcs i8xx_plane_funcs = {\n\t.update_plane = drm_atomic_helper_update_plane,\n\t.disable_plane = drm_atomic_helper_disable_plane,\n\t.destroy = intel_plane_destroy,\n\t.atomic_duplicate_state = intel_plane_duplicate_state,\n\t.atomic_destroy_state = intel_plane_destroy_state,\n\t.format_mod_supported = i8xx_plane_format_mod_supported,\n};\n\nstruct intel_plane *\nintel_primary_plane_create(struct drm_i915_private *dev_priv, enum pipe pipe)\n{\n\tstruct intel_plane *plane;\n\tconst struct drm_plane_funcs *plane_funcs;\n\tunsigned int supported_rotations;\n\tconst u64 *modifiers;\n\tconst u32 *formats;\n\tint num_formats;\n\tint ret, zpos;\n\n\tplane = intel_plane_alloc();\n\tif (IS_ERR(plane))\n\t\treturn plane;\n\n\tplane->pipe = pipe;\n\t \n\tif (HAS_FBC(dev_priv) && DISPLAY_VER(dev_priv) < 4 &&\n\t    INTEL_NUM_PIPES(dev_priv) == 2)\n\t\tplane->i9xx_plane = (enum i9xx_plane_id) !pipe;\n\telse\n\t\tplane->i9xx_plane = (enum i9xx_plane_id) pipe;\n\tplane->id = PLANE_PRIMARY;\n\tplane->frontbuffer_bit = INTEL_FRONTBUFFER(pipe, plane->id);\n\n\tintel_fbc_add_plane(i9xx_plane_fbc(dev_priv, plane->i9xx_plane), plane);\n\n\tif (IS_VALLEYVIEW(dev_priv) || IS_CHERRYVIEW(dev_priv)) {\n\t\tformats = vlv_primary_formats;\n\t\tnum_formats = ARRAY_SIZE(vlv_primary_formats);\n\t} else if (DISPLAY_VER(dev_priv) >= 4) {\n\t\t \n\t\tif (IS_IVYBRIDGE(dev_priv)) {\n\t\t\tformats = ivb_primary_formats;\n\t\t\tnum_formats = ARRAY_SIZE(ivb_primary_formats);\n\t\t} else {\n\t\t\tformats = i965_primary_formats;\n\t\t\tnum_formats = ARRAY_SIZE(i965_primary_formats);\n\t\t}\n\t} else {\n\t\tformats = i8xx_primary_formats;\n\t\tnum_formats = ARRAY_SIZE(i8xx_primary_formats);\n\t}\n\n\tif (DISPLAY_VER(dev_priv) >= 4)\n\t\tplane_funcs = &i965_plane_funcs;\n\telse\n\t\tplane_funcs = &i8xx_plane_funcs;\n\n\tif (IS_VALLEYVIEW(dev_priv) || IS_CHERRYVIEW(dev_priv))\n\t\tplane->min_cdclk = vlv_plane_min_cdclk;\n\telse if (IS_BROADWELL(dev_priv) || IS_HASWELL(dev_priv))\n\t\tplane->min_cdclk = hsw_plane_min_cdclk;\n\telse if (IS_IVYBRIDGE(dev_priv))\n\t\tplane->min_cdclk = ivb_plane_min_cdclk;\n\telse\n\t\tplane->min_cdclk = i9xx_plane_min_cdclk;\n\n\tif (HAS_GMCH(dev_priv)) {\n\t\tif (DISPLAY_VER(dev_priv) >= 4)\n\t\t\tplane->max_stride = i965_plane_max_stride;\n\t\telse\n\t\t\tplane->max_stride = i9xx_plane_max_stride;\n\t} else {\n\t\tif (IS_BROADWELL(dev_priv) || IS_HASWELL(dev_priv))\n\t\t\tplane->max_stride = hsw_primary_max_stride;\n\t\telse\n\t\t\tplane->max_stride = ilk_primary_max_stride;\n\t}\n\n\tif (IS_I830(dev_priv) || IS_I845G(dev_priv)) {\n\t\tplane->update_arm = i830_plane_update_arm;\n\t} else {\n\t\tplane->update_noarm = i9xx_plane_update_noarm;\n\t\tplane->update_arm = i9xx_plane_update_arm;\n\t}\n\tplane->disable_arm = i9xx_plane_disable_arm;\n\tplane->get_hw_state = i9xx_plane_get_hw_state;\n\tplane->check_plane = i9xx_plane_check;\n\n\tif (IS_VALLEYVIEW(dev_priv) || IS_CHERRYVIEW(dev_priv)) {\n\t\tplane->async_flip = vlv_primary_async_flip;\n\t\tplane->enable_flip_done = vlv_primary_enable_flip_done;\n\t\tplane->disable_flip_done = vlv_primary_disable_flip_done;\n\t} else if (IS_BROADWELL(dev_priv)) {\n\t\tplane->need_async_flip_disable_wa = true;\n\t\tplane->async_flip = g4x_primary_async_flip;\n\t\tplane->enable_flip_done = bdw_primary_enable_flip_done;\n\t\tplane->disable_flip_done = bdw_primary_disable_flip_done;\n\t} else if (DISPLAY_VER(dev_priv) >= 7) {\n\t\tplane->async_flip = g4x_primary_async_flip;\n\t\tplane->enable_flip_done = ivb_primary_enable_flip_done;\n\t\tplane->disable_flip_done = ivb_primary_disable_flip_done;\n\t} else if (DISPLAY_VER(dev_priv) >= 5) {\n\t\tplane->async_flip = g4x_primary_async_flip;\n\t\tplane->enable_flip_done = ilk_primary_enable_flip_done;\n\t\tplane->disable_flip_done = ilk_primary_disable_flip_done;\n\t}\n\n\tmodifiers = intel_fb_plane_get_modifiers(dev_priv, INTEL_PLANE_CAP_TILING_X);\n\n\tif (DISPLAY_VER(dev_priv) >= 5 || IS_G4X(dev_priv))\n\t\tret = drm_universal_plane_init(&dev_priv->drm, &plane->base,\n\t\t\t\t\t       0, plane_funcs,\n\t\t\t\t\t       formats, num_formats,\n\t\t\t\t\t       modifiers,\n\t\t\t\t\t       DRM_PLANE_TYPE_PRIMARY,\n\t\t\t\t\t       \"primary %c\", pipe_name(pipe));\n\telse\n\t\tret = drm_universal_plane_init(&dev_priv->drm, &plane->base,\n\t\t\t\t\t       0, plane_funcs,\n\t\t\t\t\t       formats, num_formats,\n\t\t\t\t\t       modifiers,\n\t\t\t\t\t       DRM_PLANE_TYPE_PRIMARY,\n\t\t\t\t\t       \"plane %c\",\n\t\t\t\t\t       plane_name(plane->i9xx_plane));\n\n\tkfree(modifiers);\n\n\tif (ret)\n\t\tgoto fail;\n\n\tif (IS_CHERRYVIEW(dev_priv) && pipe == PIPE_B) {\n\t\tsupported_rotations =\n\t\t\tDRM_MODE_ROTATE_0 | DRM_MODE_ROTATE_180 |\n\t\t\tDRM_MODE_REFLECT_X;\n\t} else if (DISPLAY_VER(dev_priv) >= 4) {\n\t\tsupported_rotations =\n\t\t\tDRM_MODE_ROTATE_0 | DRM_MODE_ROTATE_180;\n\t} else {\n\t\tsupported_rotations = DRM_MODE_ROTATE_0;\n\t}\n\n\tif (DISPLAY_VER(dev_priv) >= 4)\n\t\tdrm_plane_create_rotation_property(&plane->base,\n\t\t\t\t\t\t   DRM_MODE_ROTATE_0,\n\t\t\t\t\t\t   supported_rotations);\n\n\tzpos = 0;\n\tdrm_plane_create_zpos_immutable_property(&plane->base, zpos);\n\n\tintel_plane_helper_add(plane);\n\n\treturn plane;\n\nfail:\n\tintel_plane_free(plane);\n\n\treturn ERR_PTR(ret);\n}\n\nstatic int i9xx_format_to_fourcc(int format)\n{\n\tswitch (format) {\n\tcase DISP_FORMAT_8BPP:\n\t\treturn DRM_FORMAT_C8;\n\tcase DISP_FORMAT_BGRA555:\n\t\treturn DRM_FORMAT_ARGB1555;\n\tcase DISP_FORMAT_BGRX555:\n\t\treturn DRM_FORMAT_XRGB1555;\n\tcase DISP_FORMAT_BGRX565:\n\t\treturn DRM_FORMAT_RGB565;\n\tdefault:\n\tcase DISP_FORMAT_BGRX888:\n\t\treturn DRM_FORMAT_XRGB8888;\n\tcase DISP_FORMAT_RGBX888:\n\t\treturn DRM_FORMAT_XBGR8888;\n\tcase DISP_FORMAT_BGRA888:\n\t\treturn DRM_FORMAT_ARGB8888;\n\tcase DISP_FORMAT_RGBA888:\n\t\treturn DRM_FORMAT_ABGR8888;\n\tcase DISP_FORMAT_BGRX101010:\n\t\treturn DRM_FORMAT_XRGB2101010;\n\tcase DISP_FORMAT_RGBX101010:\n\t\treturn DRM_FORMAT_XBGR2101010;\n\tcase DISP_FORMAT_BGRA101010:\n\t\treturn DRM_FORMAT_ARGB2101010;\n\tcase DISP_FORMAT_RGBA101010:\n\t\treturn DRM_FORMAT_ABGR2101010;\n\tcase DISP_FORMAT_RGBX161616:\n\t\treturn DRM_FORMAT_XBGR16161616F;\n\t}\n}\n\nvoid\ni9xx_get_initial_plane_config(struct intel_crtc *crtc,\n\t\t\t      struct intel_initial_plane_config *plane_config)\n{\n\tstruct drm_device *dev = crtc->base.dev;\n\tstruct drm_i915_private *dev_priv = to_i915(dev);\n\tstruct intel_plane *plane = to_intel_plane(crtc->base.primary);\n\tenum i9xx_plane_id i9xx_plane = plane->i9xx_plane;\n\tenum pipe pipe;\n\tu32 val, base, offset;\n\tint fourcc, pixel_format;\n\tunsigned int aligned_height;\n\tstruct drm_framebuffer *fb;\n\tstruct intel_framebuffer *intel_fb;\n\n\tif (!plane->get_hw_state(plane, &pipe))\n\t\treturn;\n\n\tdrm_WARN_ON(dev, pipe != crtc->pipe);\n\n\tintel_fb = kzalloc(sizeof(*intel_fb), GFP_KERNEL);\n\tif (!intel_fb) {\n\t\tdrm_dbg_kms(&dev_priv->drm, \"failed to alloc fb\\n\");\n\t\treturn;\n\t}\n\n\tfb = &intel_fb->base;\n\n\tfb->dev = dev;\n\n\tval = intel_de_read(dev_priv, DSPCNTR(i9xx_plane));\n\n\tif (DISPLAY_VER(dev_priv) >= 4) {\n\t\tif (val & DISP_TILED) {\n\t\t\tplane_config->tiling = I915_TILING_X;\n\t\t\tfb->modifier = I915_FORMAT_MOD_X_TILED;\n\t\t}\n\n\t\tif (val & DISP_ROTATE_180)\n\t\t\tplane_config->rotation = DRM_MODE_ROTATE_180;\n\t}\n\n\tif (IS_CHERRYVIEW(dev_priv) && pipe == PIPE_B &&\n\t    val & DISP_MIRROR)\n\t\tplane_config->rotation |= DRM_MODE_REFLECT_X;\n\n\tpixel_format = val & DISP_FORMAT_MASK;\n\tfourcc = i9xx_format_to_fourcc(pixel_format);\n\tfb->format = drm_format_info(fourcc);\n\n\tif (IS_HASWELL(dev_priv) || IS_BROADWELL(dev_priv)) {\n\t\toffset = intel_de_read(dev_priv, DSPOFFSET(i9xx_plane));\n\t\tbase = intel_de_read(dev_priv, DSPSURF(i9xx_plane)) & DISP_ADDR_MASK;\n\t} else if (DISPLAY_VER(dev_priv) >= 4) {\n\t\tif (plane_config->tiling)\n\t\t\toffset = intel_de_read(dev_priv,\n\t\t\t\t\t       DSPTILEOFF(i9xx_plane));\n\t\telse\n\t\t\toffset = intel_de_read(dev_priv,\n\t\t\t\t\t       DSPLINOFF(i9xx_plane));\n\t\tbase = intel_de_read(dev_priv, DSPSURF(i9xx_plane)) & DISP_ADDR_MASK;\n\t} else {\n\t\toffset = 0;\n\t\tbase = intel_de_read(dev_priv, DSPADDR(i9xx_plane));\n\t}\n\tplane_config->base = base;\n\n\tdrm_WARN_ON(&dev_priv->drm, offset != 0);\n\n\tval = intel_de_read(dev_priv, PIPESRC(pipe));\n\tfb->width = REG_FIELD_GET(PIPESRC_WIDTH_MASK, val) + 1;\n\tfb->height = REG_FIELD_GET(PIPESRC_HEIGHT_MASK, val) + 1;\n\n\tval = intel_de_read(dev_priv, DSPSTRIDE(i9xx_plane));\n\tfb->pitches[0] = val & 0xffffffc0;\n\n\taligned_height = intel_fb_align_height(fb, 0, fb->height);\n\n\tplane_config->size = fb->pitches[0] * aligned_height;\n\n\tdrm_dbg_kms(&dev_priv->drm,\n\t\t    \"%s/%s with fb: size=%dx%d@%d, offset=%x, pitch %d, size 0x%x\\n\",\n\t\t    crtc->base.name, plane->base.name, fb->width, fb->height,\n\t\t    fb->format->cpp[0] * 8, base, fb->pitches[0],\n\t\t    plane_config->size);\n\n\tplane_config->fb = intel_fb;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}