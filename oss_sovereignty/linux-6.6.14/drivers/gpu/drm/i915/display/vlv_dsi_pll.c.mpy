{
  "module_name": "vlv_dsi_pll.c",
  "hash_id": "2eb8383d0c22a3a70cffb6f2ab844bd94fc1f71af54603437fc24ce5fb88389c",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/i915/display/vlv_dsi_pll.c",
  "human_readable_source": " \n\n#include <linux/kernel.h>\n#include <linux/string_helpers.h>\n\n#include \"i915_drv.h\"\n#include \"intel_de.h\"\n#include \"intel_display_types.h\"\n#include \"intel_dsi.h\"\n#include \"vlv_dsi_pll.h\"\n#include \"vlv_dsi_pll_regs.h\"\n#include \"vlv_sideband.h\"\n\nstatic const u16 lfsr_converts[] = {\n\t426, 469, 234, 373, 442, 221, 110, 311, 411,\t\t \n\t461, 486, 243, 377, 188, 350, 175, 343, 427, 213,\t \n\t106, 53, 282, 397, 454, 227, 113, 56, 284, 142,\t\t \n\t71, 35, 273, 136, 324, 418, 465, 488, 500, 506\t\t \n};\n\n \nstatic u32 dsi_clk_from_pclk(u32 pclk, enum mipi_dsi_pixel_format fmt,\n\t\t\t     int lane_count)\n{\n\tu32 dsi_clk_khz;\n\tu32 bpp = mipi_dsi_pixel_format_to_bpp(fmt);\n\n\t \n\tdsi_clk_khz = DIV_ROUND_CLOSEST(pclk * bpp, lane_count);\n\n\treturn dsi_clk_khz;\n}\n\nstatic int dsi_calc_mnp(struct drm_i915_private *dev_priv,\n\t\t\tstruct intel_crtc_state *config,\n\t\t\tint target_dsi_clk)\n{\n\tunsigned int m_min, m_max, p_min = 2, p_max = 6;\n\tunsigned int m, n, p;\n\tunsigned int calc_m, calc_p;\n\tint delta, ref_clk;\n\n\t \n\tif (target_dsi_clk < 300000 || target_dsi_clk > 1150000) {\n\t\tdrm_err(&dev_priv->drm, \"DSI CLK Out of Range\\n\");\n\t\treturn -ECHRNG;\n\t}\n\n\tif (IS_CHERRYVIEW(dev_priv)) {\n\t\tref_clk = 100000;\n\t\tn = 4;\n\t\tm_min = 70;\n\t\tm_max = 96;\n\t} else {\n\t\tref_clk = 25000;\n\t\tn = 1;\n\t\tm_min = 62;\n\t\tm_max = 92;\n\t}\n\n\tcalc_p = p_min;\n\tcalc_m = m_min;\n\tdelta = abs(target_dsi_clk - (m_min * ref_clk) / (p_min * n));\n\n\tfor (m = m_min; m <= m_max && delta; m++) {\n\t\tfor (p = p_min; p <= p_max && delta; p++) {\n\t\t\t \n\t\t\tint calc_dsi_clk = (m * ref_clk) / (p * n);\n\t\t\tint d = abs(target_dsi_clk - calc_dsi_clk);\n\t\t\tif (d < delta) {\n\t\t\t\tdelta = d;\n\t\t\t\tcalc_m = m;\n\t\t\t\tcalc_p = p;\n\t\t\t}\n\t\t}\n\t}\n\n\t \n\tconfig->dsi_pll.ctrl = 1 << (DSI_PLL_P1_POST_DIV_SHIFT + calc_p - 2);\n\tconfig->dsi_pll.div =\n\t\t(ffs(n) - 1) << DSI_PLL_N1_DIV_SHIFT |\n\t\t(u32)lfsr_converts[calc_m - 62] << DSI_PLL_M1_DIV_SHIFT;\n\n\treturn 0;\n}\n\nstatic int vlv_dsi_pclk(struct intel_encoder *encoder,\n\t\t\tstruct intel_crtc_state *config)\n{\n\tstruct drm_i915_private *dev_priv = to_i915(encoder->base.dev);\n\tstruct intel_dsi *intel_dsi = enc_to_intel_dsi(encoder);\n\tint bpp = mipi_dsi_pixel_format_to_bpp(intel_dsi->pixel_format);\n\tu32 dsi_clock;\n\tu32 pll_ctl, pll_div;\n\tu32 m = 0, p = 0, n;\n\tint refclk = IS_CHERRYVIEW(dev_priv) ? 100000 : 25000;\n\tint i;\n\n\tpll_ctl = config->dsi_pll.ctrl;\n\tpll_div = config->dsi_pll.div;\n\n\t \n\tpll_ctl &= DSI_PLL_P1_POST_DIV_MASK;\n\tpll_ctl = pll_ctl >> (DSI_PLL_P1_POST_DIV_SHIFT - 2);\n\n\t \n\tn = (pll_div & DSI_PLL_N1_DIV_MASK) >> DSI_PLL_N1_DIV_SHIFT;\n\tn = 1 << n;  \n\n\t \n\tpll_div &= DSI_PLL_M1_DIV_MASK;\n\tpll_div = pll_div >> DSI_PLL_M1_DIV_SHIFT;\n\n\twhile (pll_ctl) {\n\t\tpll_ctl = pll_ctl >> 1;\n\t\tp++;\n\t}\n\tp--;\n\n\tif (!p) {\n\t\tdrm_err(&dev_priv->drm, \"wrong P1 divisor\\n\");\n\t\treturn 0;\n\t}\n\n\tfor (i = 0; i < ARRAY_SIZE(lfsr_converts); i++) {\n\t\tif (lfsr_converts[i] == pll_div)\n\t\t\tbreak;\n\t}\n\n\tif (i == ARRAY_SIZE(lfsr_converts)) {\n\t\tdrm_err(&dev_priv->drm, \"wrong m_seed programmed\\n\");\n\t\treturn 0;\n\t}\n\n\tm = i + 62;\n\n\tdsi_clock = (m * refclk) / (p * n);\n\n\treturn DIV_ROUND_CLOSEST(dsi_clock * intel_dsi->lane_count, bpp);\n}\n\n \nint vlv_dsi_pll_compute(struct intel_encoder *encoder,\n\t\t\tstruct intel_crtc_state *config)\n{\n\tstruct drm_i915_private *dev_priv = to_i915(encoder->base.dev);\n\tstruct intel_dsi *intel_dsi = enc_to_intel_dsi(encoder);\n\tint pclk, dsi_clk, ret;\n\n\tdsi_clk = dsi_clk_from_pclk(intel_dsi->pclk, intel_dsi->pixel_format,\n\t\t\t\t    intel_dsi->lane_count);\n\n\tret = dsi_calc_mnp(dev_priv, config, dsi_clk);\n\tif (ret) {\n\t\tdrm_dbg_kms(&dev_priv->drm, \"dsi_calc_mnp failed\\n\");\n\t\treturn ret;\n\t}\n\n\tif (intel_dsi->ports & (1 << PORT_A))\n\t\tconfig->dsi_pll.ctrl |= DSI_PLL_CLK_GATE_DSI0_DSIPLL;\n\n\tif (intel_dsi->ports & (1 << PORT_C))\n\t\tconfig->dsi_pll.ctrl |= DSI_PLL_CLK_GATE_DSI1_DSIPLL;\n\n\tconfig->dsi_pll.ctrl |= DSI_PLL_VCO_EN;\n\n\tdrm_dbg_kms(&dev_priv->drm, \"dsi pll div %08x, ctrl %08x\\n\",\n\t\t    config->dsi_pll.div, config->dsi_pll.ctrl);\n\n\tpclk = vlv_dsi_pclk(encoder, config);\n\tconfig->port_clock = pclk;\n\n\t \n\tconfig->hw.adjusted_mode.crtc_clock = pclk;\n\tif (intel_dsi->dual_link)\n\t\tconfig->hw.adjusted_mode.crtc_clock *= 2;\n\n\treturn 0;\n}\n\nvoid vlv_dsi_pll_enable(struct intel_encoder *encoder,\n\t\t\tconst struct intel_crtc_state *config)\n{\n\tstruct drm_i915_private *dev_priv = to_i915(encoder->base.dev);\n\n\tdrm_dbg_kms(&dev_priv->drm, \"\\n\");\n\n\tvlv_cck_get(dev_priv);\n\n\tvlv_cck_write(dev_priv, CCK_REG_DSI_PLL_CONTROL, 0);\n\tvlv_cck_write(dev_priv, CCK_REG_DSI_PLL_DIVIDER, config->dsi_pll.div);\n\tvlv_cck_write(dev_priv, CCK_REG_DSI_PLL_CONTROL,\n\t\t      config->dsi_pll.ctrl & ~DSI_PLL_VCO_EN);\n\n\t \n\tusleep_range(10, 50);\n\n\tvlv_cck_write(dev_priv, CCK_REG_DSI_PLL_CONTROL, config->dsi_pll.ctrl);\n\n\tif (wait_for(vlv_cck_read(dev_priv, CCK_REG_DSI_PLL_CONTROL) &\n\t\t\t\t\t\tDSI_PLL_LOCK, 20)) {\n\n\t\tvlv_cck_put(dev_priv);\n\t\tdrm_err(&dev_priv->drm, \"DSI PLL lock failed\\n\");\n\t\treturn;\n\t}\n\tvlv_cck_put(dev_priv);\n\n\tdrm_dbg_kms(&dev_priv->drm, \"DSI PLL locked\\n\");\n}\n\nvoid vlv_dsi_pll_disable(struct intel_encoder *encoder)\n{\n\tstruct drm_i915_private *dev_priv = to_i915(encoder->base.dev);\n\tu32 tmp;\n\n\tdrm_dbg_kms(&dev_priv->drm, \"\\n\");\n\n\tvlv_cck_get(dev_priv);\n\n\ttmp = vlv_cck_read(dev_priv, CCK_REG_DSI_PLL_CONTROL);\n\ttmp &= ~DSI_PLL_VCO_EN;\n\ttmp |= DSI_PLL_LDO_GATE;\n\tvlv_cck_write(dev_priv, CCK_REG_DSI_PLL_CONTROL, tmp);\n\n\tvlv_cck_put(dev_priv);\n}\n\nbool bxt_dsi_pll_is_enabled(struct drm_i915_private *dev_priv)\n{\n\tbool enabled;\n\tu32 val;\n\tu32 mask;\n\n\tmask = BXT_DSI_PLL_DO_ENABLE | BXT_DSI_PLL_LOCKED;\n\tval = intel_de_read(dev_priv, BXT_DSI_PLL_ENABLE);\n\tenabled = (val & mask) == mask;\n\n\tif (!enabled)\n\t\treturn false;\n\n\t \n\tval = intel_de_read(dev_priv, BXT_DSI_PLL_CTL);\n\tif (IS_GEMINILAKE(dev_priv)) {\n\t\tif (!(val & BXT_DSIA_16X_MASK)) {\n\t\t\tdrm_dbg(&dev_priv->drm,\n\t\t\t\t\"Invalid PLL divider (%08x)\\n\", val);\n\t\t\tenabled = false;\n\t\t}\n\t} else {\n\t\tif (!(val & BXT_DSIA_16X_MASK) || !(val & BXT_DSIC_16X_MASK)) {\n\t\t\tdrm_dbg(&dev_priv->drm,\n\t\t\t\t\"Invalid PLL divider (%08x)\\n\", val);\n\t\t\tenabled = false;\n\t\t}\n\t}\n\n\treturn enabled;\n}\n\nvoid bxt_dsi_pll_disable(struct intel_encoder *encoder)\n{\n\tstruct drm_i915_private *dev_priv = to_i915(encoder->base.dev);\n\n\tdrm_dbg_kms(&dev_priv->drm, \"\\n\");\n\n\tintel_de_rmw(dev_priv, BXT_DSI_PLL_ENABLE, BXT_DSI_PLL_DO_ENABLE, 0);\n\n\t \n\tif (intel_de_wait_for_clear(dev_priv, BXT_DSI_PLL_ENABLE,\n\t\t\t\t    BXT_DSI_PLL_LOCKED, 1))\n\t\tdrm_err(&dev_priv->drm,\n\t\t\t\"Timeout waiting for PLL lock deassertion\\n\");\n}\n\nu32 vlv_dsi_get_pclk(struct intel_encoder *encoder,\n\t\t     struct intel_crtc_state *config)\n{\n\tstruct drm_i915_private *dev_priv = to_i915(encoder->base.dev);\n\tu32 pll_ctl, pll_div;\n\n\tdrm_dbg_kms(&dev_priv->drm, \"\\n\");\n\n\tvlv_cck_get(dev_priv);\n\tpll_ctl = vlv_cck_read(dev_priv, CCK_REG_DSI_PLL_CONTROL);\n\tpll_div = vlv_cck_read(dev_priv, CCK_REG_DSI_PLL_DIVIDER);\n\tvlv_cck_put(dev_priv);\n\n\tconfig->dsi_pll.ctrl = pll_ctl & ~DSI_PLL_LOCK;\n\tconfig->dsi_pll.div = pll_div;\n\n\treturn vlv_dsi_pclk(encoder, config);\n}\n\nstatic int bxt_dsi_pclk(struct intel_encoder *encoder,\n\t\t\tconst struct intel_crtc_state *config)\n{\n\tstruct intel_dsi *intel_dsi = enc_to_intel_dsi(encoder);\n\tint bpp = mipi_dsi_pixel_format_to_bpp(intel_dsi->pixel_format);\n\tu32 dsi_ratio, dsi_clk;\n\n\tdsi_ratio = config->dsi_pll.ctrl & BXT_DSI_PLL_RATIO_MASK;\n\tdsi_clk = (dsi_ratio * BXT_REF_CLOCK_KHZ) / 2;\n\n\treturn DIV_ROUND_CLOSEST(dsi_clk * intel_dsi->lane_count, bpp);\n}\n\nu32 bxt_dsi_get_pclk(struct intel_encoder *encoder,\n\t\t     struct intel_crtc_state *config)\n{\n\tstruct drm_i915_private *dev_priv = to_i915(encoder->base.dev);\n\tu32 pclk;\n\n\tconfig->dsi_pll.ctrl = intel_de_read(dev_priv, BXT_DSI_PLL_CTL);\n\n\tpclk = bxt_dsi_pclk(encoder, config);\n\n\tdrm_dbg(&dev_priv->drm, \"Calculated pclk=%u\\n\", pclk);\n\treturn pclk;\n}\n\nvoid vlv_dsi_reset_clocks(struct intel_encoder *encoder, enum port port)\n{\n\tu32 temp;\n\tstruct drm_i915_private *dev_priv = to_i915(encoder->base.dev);\n\tstruct intel_dsi *intel_dsi = enc_to_intel_dsi(encoder);\n\n\ttemp = intel_de_read(dev_priv, MIPI_CTRL(port));\n\ttemp &= ~ESCAPE_CLOCK_DIVIDER_MASK;\n\tintel_de_write(dev_priv, MIPI_CTRL(port),\n\t\t       temp | intel_dsi->escape_clk_div << ESCAPE_CLOCK_DIVIDER_SHIFT);\n}\n\nstatic void glk_dsi_program_esc_clock(struct drm_device *dev,\n\t\t\t\t   const struct intel_crtc_state *config)\n{\n\tstruct drm_i915_private *dev_priv = to_i915(dev);\n\tu32 dsi_rate = 0;\n\tu32 pll_ratio = 0;\n\tu32 ddr_clk = 0;\n\tu32 div1_value = 0;\n\tu32 div2_value = 0;\n\tu32 txesc1_div = 0;\n\tu32 txesc2_div = 0;\n\n\tpll_ratio = config->dsi_pll.ctrl & BXT_DSI_PLL_RATIO_MASK;\n\n\tdsi_rate = (BXT_REF_CLOCK_KHZ * pll_ratio) / 2;\n\n\tddr_clk = dsi_rate / 2;\n\n\t \n\tdiv1_value = DIV_ROUND_CLOSEST(ddr_clk, 20000);\n\n\t \n\tif (div1_value <= 10)\n\t\ttxesc1_div = div1_value;\n\telse if ((div1_value > 10) && (div1_value <= 20))\n\t\ttxesc1_div = DIV_ROUND_UP(div1_value, 2);\n\telse if ((div1_value > 20) && (div1_value <= 30))\n\t\ttxesc1_div = DIV_ROUND_UP(div1_value, 4);\n\telse if ((div1_value > 30) && (div1_value <= 40))\n\t\ttxesc1_div = DIV_ROUND_UP(div1_value, 6);\n\telse if ((div1_value > 40) && (div1_value <= 50))\n\t\ttxesc1_div = DIV_ROUND_UP(div1_value, 8);\n\telse\n\t\ttxesc1_div = 10;\n\n\t \n\tdiv2_value = DIV_ROUND_UP(div1_value, txesc1_div);\n\n\ttxesc2_div = min_t(u32, div2_value, 10);\n\n\tintel_de_write(dev_priv, MIPIO_TXESC_CLK_DIV1,\n\t\t       (1 << (txesc1_div - 1)) & GLK_TX_ESC_CLK_DIV1_MASK);\n\tintel_de_write(dev_priv, MIPIO_TXESC_CLK_DIV2,\n\t\t       (1 << (txesc2_div - 1)) & GLK_TX_ESC_CLK_DIV2_MASK);\n}\n\n \nstatic void bxt_dsi_program_clocks(struct drm_device *dev, enum port port,\n\t\t\t\t   const struct intel_crtc_state *config)\n{\n\tstruct drm_i915_private *dev_priv = to_i915(dev);\n\tu32 tmp;\n\tu32 dsi_rate = 0;\n\tu32 pll_ratio = 0;\n\tu32 rx_div;\n\tu32 tx_div;\n\tu32 rx_div_upper;\n\tu32 rx_div_lower;\n\tu32 mipi_8by3_divider;\n\n\t \n\ttmp = intel_de_read(dev_priv, BXT_MIPI_CLOCK_CTL);\n\ttmp &= ~(BXT_MIPI_TX_ESCLK_FIXDIV_MASK(port));\n\ttmp &= ~(BXT_MIPI_RX_ESCLK_UPPER_FIXDIV_MASK(port));\n\ttmp &= ~(BXT_MIPI_8X_BY3_DIVIDER_MASK(port));\n\ttmp &= ~(BXT_MIPI_RX_ESCLK_LOWER_FIXDIV_MASK(port));\n\n\t \n\tpll_ratio = config->dsi_pll.ctrl & BXT_DSI_PLL_RATIO_MASK;\n\tdsi_rate = (BXT_REF_CLOCK_KHZ * pll_ratio) / 2;\n\n\t \n\ttx_div = DIV_ROUND_UP(dsi_rate, 20000) - 1;\n\t \n\trx_div = DIV_ROUND_UP(dsi_rate, 150000) - 1;\n\n\t \n\trx_div_lower = rx_div & RX_DIVIDER_BIT_1_2;\n\trx_div_upper = (rx_div & RX_DIVIDER_BIT_3_4) >> 2;\n\n\tmipi_8by3_divider = 0x2;\n\n\ttmp |= BXT_MIPI_8X_BY3_DIVIDER(port, mipi_8by3_divider);\n\ttmp |= BXT_MIPI_TX_ESCLK_DIVIDER(port, tx_div);\n\ttmp |= BXT_MIPI_RX_ESCLK_LOWER_DIVIDER(port, rx_div_lower);\n\ttmp |= BXT_MIPI_RX_ESCLK_UPPER_DIVIDER(port, rx_div_upper);\n\n\tintel_de_write(dev_priv, BXT_MIPI_CLOCK_CTL, tmp);\n}\n\nint bxt_dsi_pll_compute(struct intel_encoder *encoder,\n\t\t\tstruct intel_crtc_state *config)\n{\n\tstruct drm_i915_private *dev_priv = to_i915(encoder->base.dev);\n\tstruct intel_dsi *intel_dsi = enc_to_intel_dsi(encoder);\n\tu8 dsi_ratio, dsi_ratio_min, dsi_ratio_max;\n\tu32 dsi_clk;\n\tint pclk;\n\n\tdsi_clk = dsi_clk_from_pclk(intel_dsi->pclk, intel_dsi->pixel_format,\n\t\t\t\t    intel_dsi->lane_count);\n\n\t \n\tdsi_ratio = DIV_ROUND_UP(dsi_clk * 2, BXT_REF_CLOCK_KHZ);\n\n\tif (IS_BROXTON(dev_priv)) {\n\t\tdsi_ratio_min = BXT_DSI_PLL_RATIO_MIN;\n\t\tdsi_ratio_max = BXT_DSI_PLL_RATIO_MAX;\n\t} else {\n\t\tdsi_ratio_min = GLK_DSI_PLL_RATIO_MIN;\n\t\tdsi_ratio_max = GLK_DSI_PLL_RATIO_MAX;\n\t}\n\n\tif (dsi_ratio < dsi_ratio_min || dsi_ratio > dsi_ratio_max) {\n\t\tdrm_err(&dev_priv->drm,\n\t\t\t\"Can't get a suitable ratio from DSI PLL ratios\\n\");\n\t\treturn -ECHRNG;\n\t} else\n\t\tdrm_dbg_kms(&dev_priv->drm, \"DSI PLL calculation is Done!!\\n\");\n\n\t \n\tconfig->dsi_pll.ctrl = dsi_ratio | BXT_DSIA_16X_BY2 | BXT_DSIC_16X_BY2;\n\n\t \n\tif (IS_BROXTON(dev_priv) && dsi_ratio <= 50)\n\t\tconfig->dsi_pll.ctrl |= BXT_DSI_PLL_PVD_RATIO_1;\n\n\tpclk = bxt_dsi_pclk(encoder, config);\n\tconfig->port_clock = pclk;\n\n\t \n\tconfig->hw.adjusted_mode.crtc_clock = pclk;\n\tif (intel_dsi->dual_link)\n\t\tconfig->hw.adjusted_mode.crtc_clock *= 2;\n\n\treturn 0;\n}\n\nvoid bxt_dsi_pll_enable(struct intel_encoder *encoder,\n\t\t\tconst struct intel_crtc_state *config)\n{\n\tstruct drm_i915_private *dev_priv = to_i915(encoder->base.dev);\n\tstruct intel_dsi *intel_dsi = enc_to_intel_dsi(encoder);\n\tenum port port;\n\n\tdrm_dbg_kms(&dev_priv->drm, \"\\n\");\n\n\t \n\tintel_de_write(dev_priv, BXT_DSI_PLL_CTL, config->dsi_pll.ctrl);\n\tintel_de_posting_read(dev_priv, BXT_DSI_PLL_CTL);\n\n\t \n\tif (IS_BROXTON(dev_priv)) {\n\t\tfor_each_dsi_port(port, intel_dsi->ports)\n\t\t\tbxt_dsi_program_clocks(encoder->base.dev, port, config);\n\t} else {\n\t\tglk_dsi_program_esc_clock(encoder->base.dev, config);\n\t}\n\n\t \n\tintel_de_rmw(dev_priv, BXT_DSI_PLL_ENABLE, 0, BXT_DSI_PLL_DO_ENABLE);\n\n\t \n\tif (intel_de_wait_for_set(dev_priv, BXT_DSI_PLL_ENABLE,\n\t\t\t\t  BXT_DSI_PLL_LOCKED, 1)) {\n\t\tdrm_err(&dev_priv->drm,\n\t\t\t\"Timed out waiting for DSI PLL to lock\\n\");\n\t\treturn;\n\t}\n\n\tdrm_dbg_kms(&dev_priv->drm, \"DSI PLL locked\\n\");\n}\n\nvoid bxt_dsi_reset_clocks(struct intel_encoder *encoder, enum port port)\n{\n\tu32 tmp;\n\tstruct drm_device *dev = encoder->base.dev;\n\tstruct drm_i915_private *dev_priv = to_i915(dev);\n\n\t \n\tif (IS_BROXTON(dev_priv)) {\n\t\ttmp = intel_de_read(dev_priv, BXT_MIPI_CLOCK_CTL);\n\t\ttmp &= ~(BXT_MIPI_TX_ESCLK_FIXDIV_MASK(port));\n\t\ttmp &= ~(BXT_MIPI_RX_ESCLK_UPPER_FIXDIV_MASK(port));\n\t\ttmp &= ~(BXT_MIPI_8X_BY3_DIVIDER_MASK(port));\n\t\ttmp &= ~(BXT_MIPI_RX_ESCLK_LOWER_FIXDIV_MASK(port));\n\t\tintel_de_write(dev_priv, BXT_MIPI_CLOCK_CTL, tmp);\n\t} else {\n\t\tintel_de_rmw(dev_priv, MIPIO_TXESC_CLK_DIV1, GLK_TX_ESC_CLK_DIV1_MASK, 0);\n\n\t\tintel_de_rmw(dev_priv, MIPIO_TXESC_CLK_DIV2, GLK_TX_ESC_CLK_DIV2_MASK, 0);\n\t}\n\tintel_de_write(dev_priv, MIPI_EOT_DISABLE(port), CLOCKSTOP);\n}\n\nstatic void assert_dsi_pll(struct drm_i915_private *i915, bool state)\n{\n\tbool cur_state;\n\n\tvlv_cck_get(i915);\n\tcur_state = vlv_cck_read(i915, CCK_REG_DSI_PLL_CONTROL) & DSI_PLL_VCO_EN;\n\tvlv_cck_put(i915);\n\n\tI915_STATE_WARN(i915, cur_state != state,\n\t\t\t\"DSI PLL state assertion failure (expected %s, current %s)\\n\",\n\t\t\tstr_on_off(state), str_on_off(cur_state));\n}\n\nvoid assert_dsi_pll_enabled(struct drm_i915_private *i915)\n{\n\tassert_dsi_pll(i915, true);\n}\n\nvoid assert_dsi_pll_disabled(struct drm_i915_private *i915)\n{\n\tassert_dsi_pll(i915, false);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}