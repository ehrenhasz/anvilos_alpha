{
  "module_name": "icl_dsi.c",
  "hash_id": "1a407b72a2f4edc7f310a71c7e8887a225d7a3357064ad828f04b8fb34db415c",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/i915/display/icl_dsi.c",
  "human_readable_source": " \n\n#include <drm/display/drm_dsc_helper.h>\n#include <drm/drm_atomic_helper.h>\n#include <drm/drm_mipi_dsi.h>\n\n#include \"i915_reg.h\"\n#include \"icl_dsi.h\"\n#include \"icl_dsi_regs.h\"\n#include \"intel_atomic.h\"\n#include \"intel_backlight.h\"\n#include \"intel_backlight_regs.h\"\n#include \"intel_combo_phy.h\"\n#include \"intel_combo_phy_regs.h\"\n#include \"intel_connector.h\"\n#include \"intel_crtc.h\"\n#include \"intel_ddi.h\"\n#include \"intel_de.h\"\n#include \"intel_dsi.h\"\n#include \"intel_dsi_vbt.h\"\n#include \"intel_panel.h\"\n#include \"intel_vdsc.h\"\n#include \"intel_vdsc_regs.h\"\n#include \"skl_scaler.h\"\n#include \"skl_universal_plane.h\"\n\nstatic int header_credits_available(struct drm_i915_private *dev_priv,\n\t\t\t\t    enum transcoder dsi_trans)\n{\n\treturn (intel_de_read(dev_priv, DSI_CMD_TXCTL(dsi_trans)) & FREE_HEADER_CREDIT_MASK)\n\t\t>> FREE_HEADER_CREDIT_SHIFT;\n}\n\nstatic int payload_credits_available(struct drm_i915_private *dev_priv,\n\t\t\t\t     enum transcoder dsi_trans)\n{\n\treturn (intel_de_read(dev_priv, DSI_CMD_TXCTL(dsi_trans)) & FREE_PLOAD_CREDIT_MASK)\n\t\t>> FREE_PLOAD_CREDIT_SHIFT;\n}\n\nstatic bool wait_for_header_credits(struct drm_i915_private *dev_priv,\n\t\t\t\t    enum transcoder dsi_trans, int hdr_credit)\n{\n\tif (wait_for_us(header_credits_available(dev_priv, dsi_trans) >=\n\t\t\thdr_credit, 100)) {\n\t\tdrm_err(&dev_priv->drm, \"DSI header credits not released\\n\");\n\t\treturn false;\n\t}\n\n\treturn true;\n}\n\nstatic bool wait_for_payload_credits(struct drm_i915_private *dev_priv,\n\t\t\t\t     enum transcoder dsi_trans, int payld_credit)\n{\n\tif (wait_for_us(payload_credits_available(dev_priv, dsi_trans) >=\n\t\t\tpayld_credit, 100)) {\n\t\tdrm_err(&dev_priv->drm, \"DSI payload credits not released\\n\");\n\t\treturn false;\n\t}\n\n\treturn true;\n}\n\nstatic enum transcoder dsi_port_to_transcoder(enum port port)\n{\n\tif (port == PORT_A)\n\t\treturn TRANSCODER_DSI_0;\n\telse\n\t\treturn TRANSCODER_DSI_1;\n}\n\nstatic void wait_for_cmds_dispatched_to_panel(struct intel_encoder *encoder)\n{\n\tstruct drm_i915_private *dev_priv = to_i915(encoder->base.dev);\n\tstruct intel_dsi *intel_dsi = enc_to_intel_dsi(encoder);\n\tstruct mipi_dsi_device *dsi;\n\tenum port port;\n\tenum transcoder dsi_trans;\n\tint ret;\n\n\t \n\tfor_each_dsi_port(port, intel_dsi->ports) {\n\t\tdsi_trans = dsi_port_to_transcoder(port);\n\t\twait_for_header_credits(dev_priv, dsi_trans, MAX_HEADER_CREDIT);\n\t\twait_for_payload_credits(dev_priv, dsi_trans, MAX_PLOAD_CREDIT);\n\t}\n\n\t \n\tfor_each_dsi_port(port, intel_dsi->ports) {\n\t\tdsi = intel_dsi->dsi_hosts[port]->device;\n\t\tdsi->mode_flags |= MIPI_DSI_MODE_LPM;\n\t\tdsi->channel = 0;\n\t\tret = mipi_dsi_dcs_nop(dsi);\n\t\tif (ret < 0)\n\t\t\tdrm_err(&dev_priv->drm,\n\t\t\t\t\"error sending DCS NOP command\\n\");\n\t}\n\n\t \n\tfor_each_dsi_port(port, intel_dsi->ports) {\n\t\tdsi_trans = dsi_port_to_transcoder(port);\n\t\twait_for_header_credits(dev_priv, dsi_trans, MAX_HEADER_CREDIT);\n\t}\n\n\t \n\tfor_each_dsi_port(port, intel_dsi->ports) {\n\t\tdsi_trans = dsi_port_to_transcoder(port);\n\t\tif (wait_for_us(!(intel_de_read(dev_priv, DSI_LP_MSG(dsi_trans)) &\n\t\t\t\t  LPTX_IN_PROGRESS), 20))\n\t\t\tdrm_err(&dev_priv->drm, \"LPTX bit not cleared\\n\");\n\t}\n}\n\nstatic int dsi_send_pkt_payld(struct intel_dsi_host *host,\n\t\t\t      const struct mipi_dsi_packet *packet)\n{\n\tstruct intel_dsi *intel_dsi = host->intel_dsi;\n\tstruct drm_i915_private *i915 = to_i915(intel_dsi->base.base.dev);\n\tenum transcoder dsi_trans = dsi_port_to_transcoder(host->port);\n\tconst u8 *data = packet->payload;\n\tu32 len = packet->payload_length;\n\tint i, j;\n\n\t \n\tif (len > MAX_PLOAD_CREDIT * 4) {\n\t\tdrm_err(&i915->drm, \"payload size exceeds max queue limit\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tfor (i = 0; i < len; i += 4) {\n\t\tu32 tmp = 0;\n\n\t\tif (!wait_for_payload_credits(i915, dsi_trans, 1))\n\t\t\treturn -EBUSY;\n\n\t\tfor (j = 0; j < min_t(u32, len - i, 4); j++)\n\t\t\ttmp |= *data++ << 8 * j;\n\n\t\tintel_de_write(i915, DSI_CMD_TXPYLD(dsi_trans), tmp);\n\t}\n\n\treturn 0;\n}\n\nstatic int dsi_send_pkt_hdr(struct intel_dsi_host *host,\n\t\t\t    const struct mipi_dsi_packet *packet,\n\t\t\t    bool enable_lpdt)\n{\n\tstruct intel_dsi *intel_dsi = host->intel_dsi;\n\tstruct drm_i915_private *dev_priv = to_i915(intel_dsi->base.base.dev);\n\tenum transcoder dsi_trans = dsi_port_to_transcoder(host->port);\n\tu32 tmp;\n\n\tif (!wait_for_header_credits(dev_priv, dsi_trans, 1))\n\t\treturn -EBUSY;\n\n\ttmp = intel_de_read(dev_priv, DSI_CMD_TXHDR(dsi_trans));\n\n\tif (packet->payload)\n\t\ttmp |= PAYLOAD_PRESENT;\n\telse\n\t\ttmp &= ~PAYLOAD_PRESENT;\n\n\ttmp &= ~VBLANK_FENCE;\n\n\tif (enable_lpdt)\n\t\ttmp |= LP_DATA_TRANSFER;\n\telse\n\t\ttmp &= ~LP_DATA_TRANSFER;\n\n\ttmp &= ~(PARAM_WC_MASK | VC_MASK | DT_MASK);\n\ttmp |= ((packet->header[0] & VC_MASK) << VC_SHIFT);\n\ttmp |= ((packet->header[0] & DT_MASK) << DT_SHIFT);\n\ttmp |= (packet->header[1] << PARAM_WC_LOWER_SHIFT);\n\ttmp |= (packet->header[2] << PARAM_WC_UPPER_SHIFT);\n\tintel_de_write(dev_priv, DSI_CMD_TXHDR(dsi_trans), tmp);\n\n\treturn 0;\n}\n\nvoid icl_dsi_frame_update(struct intel_crtc_state *crtc_state)\n{\n\tstruct intel_crtc *crtc = to_intel_crtc(crtc_state->uapi.crtc);\n\tstruct drm_i915_private *dev_priv = to_i915(crtc->base.dev);\n\tu32 mode_flags;\n\tenum port port;\n\n\tmode_flags = crtc_state->mode_flags;\n\n\t \n\tif (mode_flags & I915_MODE_FLAG_DSI_USE_TE0)\n\t\tport = PORT_A;\n\telse if (mode_flags & I915_MODE_FLAG_DSI_USE_TE1)\n\t\tport = PORT_B;\n\telse\n\t\treturn;\n\n\tintel_de_rmw(dev_priv, DSI_CMD_FRMCTL(port), 0, DSI_FRAME_UPDATE_REQUEST);\n}\n\nstatic void dsi_program_swing_and_deemphasis(struct intel_encoder *encoder)\n{\n\tstruct drm_i915_private *dev_priv = to_i915(encoder->base.dev);\n\tstruct intel_dsi *intel_dsi = enc_to_intel_dsi(encoder);\n\tenum phy phy;\n\tu32 tmp, mask, val;\n\tint lane;\n\n\tfor_each_dsi_phy(phy, intel_dsi->phys) {\n\t\t \n\t\tmask = SCALING_MODE_SEL_MASK | RTERM_SELECT_MASK;\n\t\tval = SCALING_MODE_SEL(0x2) | TAP2_DISABLE | TAP3_DISABLE |\n\t\t      RTERM_SELECT(0x6);\n\t\ttmp = intel_de_read(dev_priv, ICL_PORT_TX_DW5_LN(0, phy));\n\t\ttmp &= ~mask;\n\t\ttmp |= val;\n\t\tintel_de_write(dev_priv, ICL_PORT_TX_DW5_GRP(phy), tmp);\n\t\tintel_de_rmw(dev_priv, ICL_PORT_TX_DW5_AUX(phy), mask, val);\n\n\t\tmask = SWING_SEL_LOWER_MASK | SWING_SEL_UPPER_MASK |\n\t\t       RCOMP_SCALAR_MASK;\n\t\tval = SWING_SEL_UPPER(0x2) | SWING_SEL_LOWER(0x2) |\n\t\t      RCOMP_SCALAR(0x98);\n\t\ttmp = intel_de_read(dev_priv, ICL_PORT_TX_DW2_LN(0, phy));\n\t\ttmp &= ~mask;\n\t\ttmp |= val;\n\t\tintel_de_write(dev_priv, ICL_PORT_TX_DW2_GRP(phy), tmp);\n\t\tintel_de_rmw(dev_priv, ICL_PORT_TX_DW2_AUX(phy), mask, val);\n\n\t\tmask = POST_CURSOR_1_MASK | POST_CURSOR_2_MASK |\n\t\t       CURSOR_COEFF_MASK;\n\t\tval = POST_CURSOR_1(0x0) | POST_CURSOR_2(0x0) |\n\t\t      CURSOR_COEFF(0x3f);\n\t\tintel_de_rmw(dev_priv, ICL_PORT_TX_DW4_AUX(phy), mask, val);\n\n\t\t \n\t\tfor (lane = 0; lane <= 3; lane++)\n\t\t\tintel_de_rmw(dev_priv, ICL_PORT_TX_DW4_LN(lane, phy),\n\t\t\t\t     mask, val);\n\t}\n}\n\nstatic void configure_dual_link_mode(struct intel_encoder *encoder,\n\t\t\t\t     const struct intel_crtc_state *pipe_config)\n{\n\tstruct drm_i915_private *dev_priv = to_i915(encoder->base.dev);\n\tstruct intel_dsi *intel_dsi = enc_to_intel_dsi(encoder);\n\ti915_reg_t dss_ctl1_reg, dss_ctl2_reg;\n\tu32 dss_ctl1;\n\n\t \n\tif (DISPLAY_VER(dev_priv) >= 12) {\n\t\tstruct intel_crtc *crtc = to_intel_crtc(pipe_config->uapi.crtc);\n\n\t\tdss_ctl1_reg = ICL_PIPE_DSS_CTL1(crtc->pipe);\n\t\tdss_ctl2_reg = ICL_PIPE_DSS_CTL2(crtc->pipe);\n\t} else {\n\t\tdss_ctl1_reg = DSS_CTL1;\n\t\tdss_ctl2_reg = DSS_CTL2;\n\t}\n\n\tdss_ctl1 = intel_de_read(dev_priv, dss_ctl1_reg);\n\tdss_ctl1 |= SPLITTER_ENABLE;\n\tdss_ctl1 &= ~OVERLAP_PIXELS_MASK;\n\tdss_ctl1 |= OVERLAP_PIXELS(intel_dsi->pixel_overlap);\n\n\tif (intel_dsi->dual_link == DSI_DUAL_LINK_FRONT_BACK) {\n\t\tconst struct drm_display_mode *adjusted_mode =\n\t\t\t\t\t&pipe_config->hw.adjusted_mode;\n\t\tu16 hactive = adjusted_mode->crtc_hdisplay;\n\t\tu16 dl_buffer_depth;\n\n\t\tdss_ctl1 &= ~DUAL_LINK_MODE_INTERLEAVE;\n\t\tdl_buffer_depth = hactive / 2 + intel_dsi->pixel_overlap;\n\n\t\tif (dl_buffer_depth > MAX_DL_BUFFER_TARGET_DEPTH)\n\t\t\tdrm_err(&dev_priv->drm,\n\t\t\t\t\"DL buffer depth exceed max value\\n\");\n\n\t\tdss_ctl1 &= ~LEFT_DL_BUF_TARGET_DEPTH_MASK;\n\t\tdss_ctl1 |= LEFT_DL_BUF_TARGET_DEPTH(dl_buffer_depth);\n\t\tintel_de_rmw(dev_priv, dss_ctl2_reg, RIGHT_DL_BUF_TARGET_DEPTH_MASK,\n\t\t\t     RIGHT_DL_BUF_TARGET_DEPTH(dl_buffer_depth));\n\t} else {\n\t\t \n\t\tdss_ctl1 |= DUAL_LINK_MODE_INTERLEAVE;\n\t}\n\n\tintel_de_write(dev_priv, dss_ctl1_reg, dss_ctl1);\n}\n\n \nstatic int afe_clk(struct intel_encoder *encoder,\n\t\t   const struct intel_crtc_state *crtc_state)\n{\n\tstruct intel_dsi *intel_dsi = enc_to_intel_dsi(encoder);\n\tint bpp;\n\n\tif (crtc_state->dsc.compression_enable)\n\t\tbpp = crtc_state->dsc.compressed_bpp;\n\telse\n\t\tbpp = mipi_dsi_pixel_format_to_bpp(intel_dsi->pixel_format);\n\n\treturn DIV_ROUND_CLOSEST(intel_dsi->pclk * bpp, intel_dsi->lane_count);\n}\n\nstatic void gen11_dsi_program_esc_clk_div(struct intel_encoder *encoder,\n\t\t\t\t\t  const struct intel_crtc_state *crtc_state)\n{\n\tstruct drm_i915_private *dev_priv = to_i915(encoder->base.dev);\n\tstruct intel_dsi *intel_dsi = enc_to_intel_dsi(encoder);\n\tenum port port;\n\tint afe_clk_khz;\n\tint theo_word_clk, act_word_clk;\n\tu32 esc_clk_div_m, esc_clk_div_m_phy;\n\n\tafe_clk_khz = afe_clk(encoder, crtc_state);\n\n\tif (IS_ALDERLAKE_S(dev_priv) || IS_ALDERLAKE_P(dev_priv)) {\n\t\ttheo_word_clk = DIV_ROUND_UP(afe_clk_khz, 8 * DSI_MAX_ESC_CLK);\n\t\tact_word_clk = max(3, theo_word_clk + (theo_word_clk + 1) % 2);\n\t\tesc_clk_div_m = act_word_clk * 8;\n\t\tesc_clk_div_m_phy = (act_word_clk - 1) / 2;\n\t} else {\n\t\tesc_clk_div_m = DIV_ROUND_UP(afe_clk_khz, DSI_MAX_ESC_CLK);\n\t}\n\n\tfor_each_dsi_port(port, intel_dsi->ports) {\n\t\tintel_de_write(dev_priv, ICL_DSI_ESC_CLK_DIV(port),\n\t\t\t       esc_clk_div_m & ICL_ESC_CLK_DIV_MASK);\n\t\tintel_de_posting_read(dev_priv, ICL_DSI_ESC_CLK_DIV(port));\n\t}\n\n\tfor_each_dsi_port(port, intel_dsi->ports) {\n\t\tintel_de_write(dev_priv, ICL_DPHY_ESC_CLK_DIV(port),\n\t\t\t       esc_clk_div_m & ICL_ESC_CLK_DIV_MASK);\n\t\tintel_de_posting_read(dev_priv, ICL_DPHY_ESC_CLK_DIV(port));\n\t}\n\n\tif (IS_ALDERLAKE_S(dev_priv) || IS_ALDERLAKE_P(dev_priv)) {\n\t\tfor_each_dsi_port(port, intel_dsi->ports) {\n\t\t\tintel_de_write(dev_priv, ADL_MIPIO_DW(port, 8),\n\t\t\t\t       esc_clk_div_m_phy & TX_ESC_CLK_DIV_PHY);\n\t\t\tintel_de_posting_read(dev_priv, ADL_MIPIO_DW(port, 8));\n\t\t}\n\t}\n}\n\nstatic void get_dsi_io_power_domains(struct drm_i915_private *dev_priv,\n\t\t\t\t     struct intel_dsi *intel_dsi)\n{\n\tenum port port;\n\n\tfor_each_dsi_port(port, intel_dsi->ports) {\n\t\tdrm_WARN_ON(&dev_priv->drm, intel_dsi->io_wakeref[port]);\n\t\tintel_dsi->io_wakeref[port] =\n\t\t\tintel_display_power_get(dev_priv,\n\t\t\t\t\t\tport == PORT_A ?\n\t\t\t\t\t\tPOWER_DOMAIN_PORT_DDI_IO_A :\n\t\t\t\t\t\tPOWER_DOMAIN_PORT_DDI_IO_B);\n\t}\n}\n\nstatic void gen11_dsi_enable_io_power(struct intel_encoder *encoder)\n{\n\tstruct drm_i915_private *dev_priv = to_i915(encoder->base.dev);\n\tstruct intel_dsi *intel_dsi = enc_to_intel_dsi(encoder);\n\tenum port port;\n\n\tfor_each_dsi_port(port, intel_dsi->ports)\n\t\tintel_de_rmw(dev_priv, ICL_DSI_IO_MODECTL(port),\n\t\t\t     0, COMBO_PHY_MODE_DSI);\n\n\tget_dsi_io_power_domains(dev_priv, intel_dsi);\n}\n\nstatic void gen11_dsi_power_up_lanes(struct intel_encoder *encoder)\n{\n\tstruct drm_i915_private *dev_priv = to_i915(encoder->base.dev);\n\tstruct intel_dsi *intel_dsi = enc_to_intel_dsi(encoder);\n\tenum phy phy;\n\n\tfor_each_dsi_phy(phy, intel_dsi->phys)\n\t\tintel_combo_phy_power_up_lanes(dev_priv, phy, true,\n\t\t\t\t\t       intel_dsi->lane_count, false);\n}\n\nstatic void gen11_dsi_config_phy_lanes_sequence(struct intel_encoder *encoder)\n{\n\tstruct drm_i915_private *dev_priv = to_i915(encoder->base.dev);\n\tstruct intel_dsi *intel_dsi = enc_to_intel_dsi(encoder);\n\tenum phy phy;\n\tu32 tmp;\n\tint lane;\n\n\t \n\tfor_each_dsi_phy(phy, intel_dsi->phys) {\n\t\tintel_de_rmw(dev_priv, ICL_PORT_TX_DW4_AUX(phy), LOADGEN_SELECT, 0);\n\t\tfor (lane = 0; lane <= 3; lane++)\n\t\t\tintel_de_rmw(dev_priv, ICL_PORT_TX_DW4_LN(lane, phy),\n\t\t\t\t     LOADGEN_SELECT, lane != 2 ? LOADGEN_SELECT : 0);\n\t}\n\n\t \n\tfor_each_dsi_phy(phy, intel_dsi->phys) {\n\t\tintel_de_rmw(dev_priv, ICL_PORT_TX_DW2_AUX(phy),\n\t\t\t     FRC_LATENCY_OPTIM_MASK, FRC_LATENCY_OPTIM_VAL(0x5));\n\t\ttmp = intel_de_read(dev_priv, ICL_PORT_TX_DW2_LN(0, phy));\n\t\ttmp &= ~FRC_LATENCY_OPTIM_MASK;\n\t\ttmp |= FRC_LATENCY_OPTIM_VAL(0x5);\n\t\tintel_de_write(dev_priv, ICL_PORT_TX_DW2_GRP(phy), tmp);\n\n\t\t \n\t\tif (IS_JASPERLAKE(dev_priv) || IS_ELKHARTLAKE(dev_priv) ||\n\t\t    (DISPLAY_VER(dev_priv) >= 12)) {\n\t\t\tintel_de_rmw(dev_priv, ICL_PORT_PCS_DW1_AUX(phy),\n\t\t\t\t     LATENCY_OPTIM_MASK, LATENCY_OPTIM_VAL(0));\n\n\t\t\ttmp = intel_de_read(dev_priv,\n\t\t\t\t\t    ICL_PORT_PCS_DW1_LN(0, phy));\n\t\t\ttmp &= ~LATENCY_OPTIM_MASK;\n\t\t\ttmp |= LATENCY_OPTIM_VAL(0x1);\n\t\t\tintel_de_write(dev_priv, ICL_PORT_PCS_DW1_GRP(phy),\n\t\t\t\t       tmp);\n\t\t}\n\t}\n\n}\n\nstatic void gen11_dsi_voltage_swing_program_seq(struct intel_encoder *encoder)\n{\n\tstruct drm_i915_private *dev_priv = to_i915(encoder->base.dev);\n\tstruct intel_dsi *intel_dsi = enc_to_intel_dsi(encoder);\n\tu32 tmp;\n\tenum phy phy;\n\n\t \n\tfor_each_dsi_phy(phy, intel_dsi->phys) {\n\t\ttmp = intel_de_read(dev_priv, ICL_PORT_PCS_DW1_LN(0, phy));\n\t\ttmp &= ~COMMON_KEEPER_EN;\n\t\tintel_de_write(dev_priv, ICL_PORT_PCS_DW1_GRP(phy), tmp);\n\t\tintel_de_rmw(dev_priv, ICL_PORT_PCS_DW1_AUX(phy), COMMON_KEEPER_EN, 0);\n\t}\n\n\t \n\tfor_each_dsi_phy(phy, intel_dsi->phys)\n\t\tintel_de_rmw(dev_priv, ICL_PORT_CL_DW5(phy), 0, SUS_CLOCK_CONFIG);\n\n\t \n\tfor_each_dsi_phy(phy, intel_dsi->phys) {\n\t\ttmp = intel_de_read(dev_priv, ICL_PORT_TX_DW5_LN(0, phy));\n\t\ttmp &= ~TX_TRAINING_EN;\n\t\tintel_de_write(dev_priv, ICL_PORT_TX_DW5_GRP(phy), tmp);\n\t\tintel_de_rmw(dev_priv, ICL_PORT_TX_DW5_AUX(phy), TX_TRAINING_EN, 0);\n\t}\n\n\t \n\tdsi_program_swing_and_deemphasis(encoder);\n\n\t \n\tfor_each_dsi_phy(phy, intel_dsi->phys) {\n\t\ttmp = intel_de_read(dev_priv, ICL_PORT_TX_DW5_LN(0, phy));\n\t\ttmp |= TX_TRAINING_EN;\n\t\tintel_de_write(dev_priv, ICL_PORT_TX_DW5_GRP(phy), tmp);\n\t\tintel_de_rmw(dev_priv, ICL_PORT_TX_DW5_AUX(phy), 0, TX_TRAINING_EN);\n\t}\n}\n\nstatic void gen11_dsi_enable_ddi_buffer(struct intel_encoder *encoder)\n{\n\tstruct drm_i915_private *dev_priv = to_i915(encoder->base.dev);\n\tstruct intel_dsi *intel_dsi = enc_to_intel_dsi(encoder);\n\tenum port port;\n\n\tfor_each_dsi_port(port, intel_dsi->ports) {\n\t\tintel_de_rmw(dev_priv, DDI_BUF_CTL(port), 0, DDI_BUF_CTL_ENABLE);\n\n\t\tif (wait_for_us(!(intel_de_read(dev_priv, DDI_BUF_CTL(port)) &\n\t\t\t\t  DDI_BUF_IS_IDLE),\n\t\t\t\t  500))\n\t\t\tdrm_err(&dev_priv->drm, \"DDI port:%c buffer idle\\n\",\n\t\t\t\tport_name(port));\n\t}\n}\n\nstatic void\ngen11_dsi_setup_dphy_timings(struct intel_encoder *encoder,\n\t\t\t     const struct intel_crtc_state *crtc_state)\n{\n\tstruct drm_i915_private *dev_priv = to_i915(encoder->base.dev);\n\tstruct intel_dsi *intel_dsi = enc_to_intel_dsi(encoder);\n\tenum port port;\n\tenum phy phy;\n\n\t \n\tfor_each_dsi_port(port, intel_dsi->ports)\n\t\tintel_de_write(dev_priv, DPHY_CLK_TIMING_PARAM(port),\n\t\t\t       intel_dsi->dphy_reg);\n\n\t \n\tfor_each_dsi_port(port, intel_dsi->ports)\n\t\tintel_de_write(dev_priv, DPHY_DATA_TIMING_PARAM(port),\n\t\t\t       intel_dsi->dphy_data_lane_reg);\n\n\t \n\tif (DISPLAY_VER(dev_priv) == 11) {\n\t\tif (afe_clk(encoder, crtc_state) <= 800000) {\n\t\t\tfor_each_dsi_port(port, intel_dsi->ports)\n\t\t\t\tintel_de_rmw(dev_priv, DPHY_TA_TIMING_PARAM(port),\n\t\t\t\t\t     TA_SURE_MASK,\n\t\t\t\t\t     TA_SURE_OVERRIDE | TA_SURE(0));\n\t\t}\n\t}\n\n\tif (IS_JASPERLAKE(dev_priv) || IS_ELKHARTLAKE(dev_priv)) {\n\t\tfor_each_dsi_phy(phy, intel_dsi->phys)\n\t\t\tintel_de_rmw(dev_priv, ICL_DPHY_CHKN(phy),\n\t\t\t\t     0, ICL_DPHY_CHKN_AFE_OVER_PPI_STRAP);\n\t}\n}\n\nstatic void\ngen11_dsi_setup_timings(struct intel_encoder *encoder,\n\t\t\tconst struct intel_crtc_state *crtc_state)\n{\n\tstruct drm_i915_private *dev_priv = to_i915(encoder->base.dev);\n\tstruct intel_dsi *intel_dsi = enc_to_intel_dsi(encoder);\n\tenum port port;\n\n\t \n\tfor_each_dsi_port(port, intel_dsi->ports)\n\t\tintel_de_rmw(dev_priv, ICL_DSI_T_INIT_MASTER(port),\n\t\t\t     DSI_T_INIT_MASTER_MASK, intel_dsi->init_count);\n\n\t \n\tfor_each_dsi_port(port, intel_dsi->ports)\n\t\tintel_de_write(dev_priv, DSI_CLK_TIMING_PARAM(port),\n\t\t\t       intel_dsi->dphy_reg);\n\n\t \n\tfor_each_dsi_port(port, intel_dsi->ports)\n\t\tintel_de_write(dev_priv, DSI_DATA_TIMING_PARAM(port),\n\t\t\t       intel_dsi->dphy_data_lane_reg);\n\n\t \n\tif (DISPLAY_VER(dev_priv) == 11) {\n\t\tif (afe_clk(encoder, crtc_state) <= 800000) {\n\t\t\tfor_each_dsi_port(port, intel_dsi->ports) {\n\t\t\t\tintel_de_rmw(dev_priv, DSI_TA_TIMING_PARAM(port),\n\t\t\t\t\t     TA_SURE_MASK,\n\t\t\t\t\t     TA_SURE_OVERRIDE | TA_SURE(0));\n\t\t\t}\n\t\t}\n\t}\n}\n\nstatic void gen11_dsi_gate_clocks(struct intel_encoder *encoder)\n{\n\tstruct drm_i915_private *dev_priv = to_i915(encoder->base.dev);\n\tstruct intel_dsi *intel_dsi = enc_to_intel_dsi(encoder);\n\tu32 tmp;\n\tenum phy phy;\n\n\tmutex_lock(&dev_priv->display.dpll.lock);\n\ttmp = intel_de_read(dev_priv, ICL_DPCLKA_CFGCR0);\n\tfor_each_dsi_phy(phy, intel_dsi->phys)\n\t\ttmp |= ICL_DPCLKA_CFGCR0_DDI_CLK_OFF(phy);\n\n\tintel_de_write(dev_priv, ICL_DPCLKA_CFGCR0, tmp);\n\tmutex_unlock(&dev_priv->display.dpll.lock);\n}\n\nstatic void gen11_dsi_ungate_clocks(struct intel_encoder *encoder)\n{\n\tstruct drm_i915_private *dev_priv = to_i915(encoder->base.dev);\n\tstruct intel_dsi *intel_dsi = enc_to_intel_dsi(encoder);\n\tu32 tmp;\n\tenum phy phy;\n\n\tmutex_lock(&dev_priv->display.dpll.lock);\n\ttmp = intel_de_read(dev_priv, ICL_DPCLKA_CFGCR0);\n\tfor_each_dsi_phy(phy, intel_dsi->phys)\n\t\ttmp &= ~ICL_DPCLKA_CFGCR0_DDI_CLK_OFF(phy);\n\n\tintel_de_write(dev_priv, ICL_DPCLKA_CFGCR0, tmp);\n\tmutex_unlock(&dev_priv->display.dpll.lock);\n}\n\nstatic bool gen11_dsi_is_clock_enabled(struct intel_encoder *encoder)\n{\n\tstruct drm_i915_private *dev_priv = to_i915(encoder->base.dev);\n\tstruct intel_dsi *intel_dsi = enc_to_intel_dsi(encoder);\n\tbool clock_enabled = false;\n\tenum phy phy;\n\tu32 tmp;\n\n\ttmp = intel_de_read(dev_priv, ICL_DPCLKA_CFGCR0);\n\n\tfor_each_dsi_phy(phy, intel_dsi->phys) {\n\t\tif (!(tmp & ICL_DPCLKA_CFGCR0_DDI_CLK_OFF(phy)))\n\t\t\tclock_enabled = true;\n\t}\n\n\treturn clock_enabled;\n}\n\nstatic void gen11_dsi_map_pll(struct intel_encoder *encoder,\n\t\t\t      const struct intel_crtc_state *crtc_state)\n{\n\tstruct drm_i915_private *dev_priv = to_i915(encoder->base.dev);\n\tstruct intel_dsi *intel_dsi = enc_to_intel_dsi(encoder);\n\tstruct intel_shared_dpll *pll = crtc_state->shared_dpll;\n\tenum phy phy;\n\tu32 val;\n\n\tmutex_lock(&dev_priv->display.dpll.lock);\n\n\tval = intel_de_read(dev_priv, ICL_DPCLKA_CFGCR0);\n\tfor_each_dsi_phy(phy, intel_dsi->phys) {\n\t\tval &= ~ICL_DPCLKA_CFGCR0_DDI_CLK_SEL_MASK(phy);\n\t\tval |= ICL_DPCLKA_CFGCR0_DDI_CLK_SEL(pll->info->id, phy);\n\t}\n\tintel_de_write(dev_priv, ICL_DPCLKA_CFGCR0, val);\n\n\tfor_each_dsi_phy(phy, intel_dsi->phys) {\n\t\tval &= ~ICL_DPCLKA_CFGCR0_DDI_CLK_OFF(phy);\n\t}\n\tintel_de_write(dev_priv, ICL_DPCLKA_CFGCR0, val);\n\n\tintel_de_posting_read(dev_priv, ICL_DPCLKA_CFGCR0);\n\n\tmutex_unlock(&dev_priv->display.dpll.lock);\n}\n\nstatic void\ngen11_dsi_configure_transcoder(struct intel_encoder *encoder,\n\t\t\t       const struct intel_crtc_state *pipe_config)\n{\n\tstruct drm_i915_private *dev_priv = to_i915(encoder->base.dev);\n\tstruct intel_dsi *intel_dsi = enc_to_intel_dsi(encoder);\n\tstruct intel_crtc *crtc = to_intel_crtc(pipe_config->uapi.crtc);\n\tenum pipe pipe = crtc->pipe;\n\tu32 tmp;\n\tenum port port;\n\tenum transcoder dsi_trans;\n\n\tfor_each_dsi_port(port, intel_dsi->ports) {\n\t\tdsi_trans = dsi_port_to_transcoder(port);\n\t\ttmp = intel_de_read(dev_priv, DSI_TRANS_FUNC_CONF(dsi_trans));\n\n\t\tif (intel_dsi->eotp_pkt)\n\t\t\ttmp &= ~EOTP_DISABLED;\n\t\telse\n\t\t\ttmp |= EOTP_DISABLED;\n\n\t\t \n\t\tif (afe_clk(encoder, pipe_config) >= 1500 * 1000) {\n\t\t\ttmp &= ~LINK_CALIBRATION_MASK;\n\t\t\ttmp |= CALIBRATION_ENABLED_INITIAL_ONLY;\n\t\t}\n\n\t\t \n\t\ttmp &= ~CONTINUOUS_CLK_MASK;\n\t\tif (intel_dsi->clock_stop)\n\t\t\ttmp |= CLK_ENTER_LP_AFTER_DATA;\n\t\telse\n\t\t\ttmp |= CLK_HS_CONTINUOUS;\n\n\t\t \n\t\ttmp &= ~PIX_BUF_THRESHOLD_MASK;\n\t\ttmp |= PIX_BUF_THRESHOLD_1_4;\n\n\t\t \n\t\ttmp &= ~PIX_VIRT_CHAN_MASK;\n\t\ttmp |= PIX_VIRT_CHAN(0);\n\n\t\t \n\t\tif (intel_dsi->bgr_enabled)\n\t\t\ttmp |= BGR_TRANSMISSION;\n\n\t\t \n\t\ttmp &= ~PIX_FMT_MASK;\n\t\tif (pipe_config->dsc.compression_enable) {\n\t\t\ttmp |= PIX_FMT_COMPRESSED;\n\t\t} else {\n\t\t\tswitch (intel_dsi->pixel_format) {\n\t\t\tdefault:\n\t\t\t\tMISSING_CASE(intel_dsi->pixel_format);\n\t\t\t\tfallthrough;\n\t\t\tcase MIPI_DSI_FMT_RGB565:\n\t\t\t\ttmp |= PIX_FMT_RGB565;\n\t\t\t\tbreak;\n\t\t\tcase MIPI_DSI_FMT_RGB666_PACKED:\n\t\t\t\ttmp |= PIX_FMT_RGB666_PACKED;\n\t\t\t\tbreak;\n\t\t\tcase MIPI_DSI_FMT_RGB666:\n\t\t\t\ttmp |= PIX_FMT_RGB666_LOOSE;\n\t\t\t\tbreak;\n\t\t\tcase MIPI_DSI_FMT_RGB888:\n\t\t\t\ttmp |= PIX_FMT_RGB888;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (DISPLAY_VER(dev_priv) >= 12) {\n\t\t\tif (is_vid_mode(intel_dsi))\n\t\t\t\ttmp |= BLANKING_PACKET_ENABLE;\n\t\t}\n\n\t\t \n\t\tif (is_vid_mode(intel_dsi)) {\n\t\t\ttmp &= ~OP_MODE_MASK;\n\t\t\tswitch (intel_dsi->video_mode) {\n\t\t\tdefault:\n\t\t\t\tMISSING_CASE(intel_dsi->video_mode);\n\t\t\t\tfallthrough;\n\t\t\tcase NON_BURST_SYNC_EVENTS:\n\t\t\t\ttmp |= VIDEO_MODE_SYNC_EVENT;\n\t\t\t\tbreak;\n\t\t\tcase NON_BURST_SYNC_PULSE:\n\t\t\t\ttmp |= VIDEO_MODE_SYNC_PULSE;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else {\n\t\t\t \n\t\t\ttmp &= ~OP_MODE_MASK;\n\t\t\ttmp |= CMD_MODE_TE_GATE;\n\t\t\ttmp |= TE_SOURCE_GPIO;\n\t\t}\n\n\t\tintel_de_write(dev_priv, DSI_TRANS_FUNC_CONF(dsi_trans), tmp);\n\t}\n\n\t \n\tif (intel_dsi->dual_link) {\n\t\tfor_each_dsi_port(port, intel_dsi->ports) {\n\t\t\tdsi_trans = dsi_port_to_transcoder(port);\n\t\t\tintel_de_rmw(dev_priv, TRANS_DDI_FUNC_CTL2(dsi_trans),\n\t\t\t\t     0, PORT_SYNC_MODE_ENABLE);\n\t\t}\n\n\t\t \n\t\tconfigure_dual_link_mode(encoder, pipe_config);\n\t}\n\n\tfor_each_dsi_port(port, intel_dsi->ports) {\n\t\tdsi_trans = dsi_port_to_transcoder(port);\n\n\t\t \n\t\ttmp = intel_de_read(dev_priv, TRANS_DDI_FUNC_CTL(dsi_trans));\n\t\ttmp &= ~DDI_PORT_WIDTH_MASK;\n\t\ttmp |= DDI_PORT_WIDTH(intel_dsi->lane_count);\n\n\t\t \n\t\ttmp &= ~TRANS_DDI_EDP_INPUT_MASK;\n\t\tswitch (pipe) {\n\t\tdefault:\n\t\t\tMISSING_CASE(pipe);\n\t\t\tfallthrough;\n\t\tcase PIPE_A:\n\t\t\ttmp |= TRANS_DDI_EDP_INPUT_A_ON;\n\t\t\tbreak;\n\t\tcase PIPE_B:\n\t\t\ttmp |= TRANS_DDI_EDP_INPUT_B_ONOFF;\n\t\t\tbreak;\n\t\tcase PIPE_C:\n\t\t\ttmp |= TRANS_DDI_EDP_INPUT_C_ONOFF;\n\t\t\tbreak;\n\t\tcase PIPE_D:\n\t\t\ttmp |= TRANS_DDI_EDP_INPUT_D_ONOFF;\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\ttmp |= TRANS_DDI_FUNC_ENABLE;\n\t\tintel_de_write(dev_priv, TRANS_DDI_FUNC_CTL(dsi_trans), tmp);\n\t}\n\n\t \n\tfor_each_dsi_port(port, intel_dsi->ports) {\n\t\tdsi_trans = dsi_port_to_transcoder(port);\n\t\tif (wait_for_us((intel_de_read(dev_priv, DSI_TRANS_FUNC_CONF(dsi_trans)) &\n\t\t\t\t LINK_READY), 2500))\n\t\t\tdrm_err(&dev_priv->drm, \"DSI link not ready\\n\");\n\t}\n}\n\nstatic void\ngen11_dsi_set_transcoder_timings(struct intel_encoder *encoder,\n\t\t\t\t const struct intel_crtc_state *crtc_state)\n{\n\tstruct drm_i915_private *dev_priv = to_i915(encoder->base.dev);\n\tstruct intel_dsi *intel_dsi = enc_to_intel_dsi(encoder);\n\tconst struct drm_display_mode *adjusted_mode =\n\t\t&crtc_state->hw.adjusted_mode;\n\tenum port port;\n\tenum transcoder dsi_trans;\n\t \n\tu16 htotal, hactive, hsync_start, hsync_end, hsync_size;\n\tu16 hback_porch;\n\t \n\tu16 vtotal, vactive, vsync_start, vsync_end, vsync_shift;\n\tint mul = 1, div = 1;\n\n\t \n\tif (crtc_state->dsc.compression_enable) {\n\t\tmul = crtc_state->dsc.compressed_bpp;\n\t\tdiv = mipi_dsi_pixel_format_to_bpp(intel_dsi->pixel_format);\n\t}\n\n\thactive = adjusted_mode->crtc_hdisplay;\n\n\tif (is_vid_mode(intel_dsi))\n\t\thtotal = DIV_ROUND_UP(adjusted_mode->crtc_htotal * mul, div);\n\telse\n\t\thtotal = DIV_ROUND_UP((hactive + 160) * mul, div);\n\n\thsync_start = DIV_ROUND_UP(adjusted_mode->crtc_hsync_start * mul, div);\n\thsync_end = DIV_ROUND_UP(adjusted_mode->crtc_hsync_end * mul, div);\n\thsync_size  = hsync_end - hsync_start;\n\thback_porch = (adjusted_mode->crtc_htotal -\n\t\t       adjusted_mode->crtc_hsync_end);\n\tvactive = adjusted_mode->crtc_vdisplay;\n\n\tif (is_vid_mode(intel_dsi)) {\n\t\tvtotal = adjusted_mode->crtc_vtotal;\n\t} else {\n\t\tint bpp, line_time_us, byte_clk_period_ns;\n\n\t\tif (crtc_state->dsc.compression_enable)\n\t\t\tbpp = crtc_state->dsc.compressed_bpp;\n\t\telse\n\t\t\tbpp = mipi_dsi_pixel_format_to_bpp(intel_dsi->pixel_format);\n\n\t\tbyte_clk_period_ns = 1000000 / afe_clk(encoder, crtc_state);\n\t\tline_time_us = (htotal * (bpp / 8) * byte_clk_period_ns) / (1000 * intel_dsi->lane_count);\n\t\tvtotal = vactive + DIV_ROUND_UP(400, line_time_us);\n\t}\n\tvsync_start = adjusted_mode->crtc_vsync_start;\n\tvsync_end = adjusted_mode->crtc_vsync_end;\n\tvsync_shift = hsync_start - htotal / 2;\n\n\tif (intel_dsi->dual_link) {\n\t\thactive /= 2;\n\t\tif (intel_dsi->dual_link == DSI_DUAL_LINK_FRONT_BACK)\n\t\t\thactive += intel_dsi->pixel_overlap;\n\t\thtotal /= 2;\n\t}\n\n\t \n\tif (adjusted_mode->crtc_hdisplay < 256)\n\t\tdrm_err(&dev_priv->drm, \"hactive is less then 256 pixels\\n\");\n\n\t \n\tif (intel_dsi->pixel_format == MIPI_DSI_FMT_RGB666 && hactive % 4 != 0)\n\t\tdrm_err(&dev_priv->drm,\n\t\t\t\"hactive pixels are not multiple of 4\\n\");\n\n\t \n\tfor_each_dsi_port(port, intel_dsi->ports) {\n\t\tdsi_trans = dsi_port_to_transcoder(port);\n\t\tintel_de_write(dev_priv, TRANS_HTOTAL(dsi_trans),\n\t\t\t       HACTIVE(hactive - 1) | HTOTAL(htotal - 1));\n\t}\n\n\t \n\tif (is_vid_mode(intel_dsi)) {\n\t\tif (intel_dsi->video_mode == NON_BURST_SYNC_PULSE) {\n\t\t\t \n\t\t\tif (hsync_size < 16)\n\t\t\t\tdrm_err(&dev_priv->drm,\n\t\t\t\t\t\"hsync size < 16 pixels\\n\");\n\t\t}\n\n\t\tif (hback_porch < 16)\n\t\t\tdrm_err(&dev_priv->drm, \"hback porch < 16 pixels\\n\");\n\n\t\tif (intel_dsi->dual_link) {\n\t\t\thsync_start /= 2;\n\t\t\thsync_end /= 2;\n\t\t}\n\n\t\tfor_each_dsi_port(port, intel_dsi->ports) {\n\t\t\tdsi_trans = dsi_port_to_transcoder(port);\n\t\t\tintel_de_write(dev_priv, TRANS_HSYNC(dsi_trans),\n\t\t\t\t       HSYNC_START(hsync_start - 1) | HSYNC_END(hsync_end - 1));\n\t\t}\n\t}\n\n\t \n\tfor_each_dsi_port(port, intel_dsi->ports) {\n\t\tdsi_trans = dsi_port_to_transcoder(port);\n\t\t \n\t\tintel_de_write(dev_priv, TRANS_VTOTAL(dsi_trans),\n\t\t\t       VACTIVE(vactive - 1) | VTOTAL(vtotal - 1));\n\t}\n\n\tif (vsync_end < vsync_start || vsync_end > vtotal)\n\t\tdrm_err(&dev_priv->drm, \"Invalid vsync_end value\\n\");\n\n\tif (vsync_start < vactive)\n\t\tdrm_err(&dev_priv->drm, \"vsync_start less than vactive\\n\");\n\n\t \n\tif (is_vid_mode(intel_dsi)) {\n\t\tfor_each_dsi_port(port, intel_dsi->ports) {\n\t\t\tdsi_trans = dsi_port_to_transcoder(port);\n\t\t\tintel_de_write(dev_priv, TRANS_VSYNC(dsi_trans),\n\t\t\t\t       VSYNC_START(vsync_start - 1) | VSYNC_END(vsync_end - 1));\n\t\t}\n\t}\n\n\t \n\tif (is_vid_mode(intel_dsi)) {\n\t\tfor_each_dsi_port(port, intel_dsi->ports) {\n\t\t\tdsi_trans = dsi_port_to_transcoder(port);\n\t\t\tintel_de_write(dev_priv, TRANS_VSYNCSHIFT(dsi_trans),\n\t\t\t\t       vsync_shift);\n\t\t}\n\t}\n\n\t \n\tif (DISPLAY_VER(dev_priv) >= 12) {\n\t\tfor_each_dsi_port(port, intel_dsi->ports) {\n\t\t\tdsi_trans = dsi_port_to_transcoder(port);\n\t\t\tintel_de_write(dev_priv, TRANS_VBLANK(dsi_trans),\n\t\t\t\t       VBLANK_START(vactive - 1) | VBLANK_END(vtotal - 1));\n\t\t}\n\t}\n}\n\nstatic void gen11_dsi_enable_transcoder(struct intel_encoder *encoder)\n{\n\tstruct drm_i915_private *dev_priv = to_i915(encoder->base.dev);\n\tstruct intel_dsi *intel_dsi = enc_to_intel_dsi(encoder);\n\tenum port port;\n\tenum transcoder dsi_trans;\n\n\tfor_each_dsi_port(port, intel_dsi->ports) {\n\t\tdsi_trans = dsi_port_to_transcoder(port);\n\t\tintel_de_rmw(dev_priv, TRANSCONF(dsi_trans), 0, TRANSCONF_ENABLE);\n\n\t\t \n\t\tif (intel_de_wait_for_set(dev_priv, TRANSCONF(dsi_trans),\n\t\t\t\t\t  TRANSCONF_STATE_ENABLE, 10))\n\t\t\tdrm_err(&dev_priv->drm,\n\t\t\t\t\"DSI transcoder not enabled\\n\");\n\t}\n}\n\nstatic void gen11_dsi_setup_timeouts(struct intel_encoder *encoder,\n\t\t\t\t     const struct intel_crtc_state *crtc_state)\n{\n\tstruct drm_i915_private *dev_priv = to_i915(encoder->base.dev);\n\tstruct intel_dsi *intel_dsi = enc_to_intel_dsi(encoder);\n\tenum port port;\n\tenum transcoder dsi_trans;\n\tu32 hs_tx_timeout, lp_rx_timeout, ta_timeout, divisor, mul;\n\n\t \n\tdivisor = intel_dsi_tlpx_ns(intel_dsi) * afe_clk(encoder, crtc_state) * 1000;\n\tmul = 8 * 1000000;\n\ths_tx_timeout = DIV_ROUND_UP(intel_dsi->hs_tx_timeout * mul,\n\t\t\t\t     divisor);\n\tlp_rx_timeout = DIV_ROUND_UP(intel_dsi->lp_rx_timeout * mul, divisor);\n\tta_timeout = DIV_ROUND_UP(intel_dsi->turn_arnd_val * mul, divisor);\n\n\tfor_each_dsi_port(port, intel_dsi->ports) {\n\t\tdsi_trans = dsi_port_to_transcoder(port);\n\n\t\t \n\t\tintel_de_rmw(dev_priv, DSI_HSTX_TO(dsi_trans),\n\t\t\t     HSTX_TIMEOUT_VALUE_MASK,\n\t\t\t     HSTX_TIMEOUT_VALUE(hs_tx_timeout));\n\n\t\t \n\n\t\t \n\t\tintel_de_rmw(dev_priv, DSI_LPRX_HOST_TO(dsi_trans),\n\t\t\t     LPRX_TIMEOUT_VALUE_MASK,\n\t\t\t     LPRX_TIMEOUT_VALUE(lp_rx_timeout));\n\n\t\t \n\n\t\t \n\t\tintel_de_rmw(dev_priv, DSI_TA_TO(dsi_trans),\n\t\t\t     TA_TIMEOUT_VALUE_MASK,\n\t\t\t     TA_TIMEOUT_VALUE(ta_timeout));\n\t}\n}\n\nstatic void gen11_dsi_config_util_pin(struct intel_encoder *encoder,\n\t\t\t\t      bool enable)\n{\n\tstruct drm_i915_private *dev_priv = to_i915(encoder->base.dev);\n\tstruct intel_dsi *intel_dsi = enc_to_intel_dsi(encoder);\n\tu32 tmp;\n\n\t \n\tif (is_vid_mode(intel_dsi) || (intel_dsi->ports & BIT(PORT_B)))\n\t\treturn;\n\n\ttmp = intel_de_read(dev_priv, UTIL_PIN_CTL);\n\n\tif (enable) {\n\t\ttmp |= UTIL_PIN_DIRECTION_INPUT;\n\t\ttmp |= UTIL_PIN_ENABLE;\n\t} else {\n\t\ttmp &= ~UTIL_PIN_ENABLE;\n\t}\n\tintel_de_write(dev_priv, UTIL_PIN_CTL, tmp);\n}\n\nstatic void\ngen11_dsi_enable_port_and_phy(struct intel_encoder *encoder,\n\t\t\t      const struct intel_crtc_state *crtc_state)\n{\n\t \n\tgen11_dsi_power_up_lanes(encoder);\n\n\t \n\tgen11_dsi_config_phy_lanes_sequence(encoder);\n\n\t \n\tgen11_dsi_voltage_swing_program_seq(encoder);\n\n\t \n\tgen11_dsi_setup_dphy_timings(encoder, crtc_state);\n\n\t \n\tgen11_dsi_enable_ddi_buffer(encoder);\n\n\tgen11_dsi_gate_clocks(encoder);\n\n\tgen11_dsi_setup_timings(encoder, crtc_state);\n\n\t \n\tgen11_dsi_config_util_pin(encoder, true);\n\n\t \n\tgen11_dsi_setup_timeouts(encoder, crtc_state);\n\n\t \n\tgen11_dsi_configure_transcoder(encoder, crtc_state);\n}\n\nstatic void gen11_dsi_powerup_panel(struct intel_encoder *encoder)\n{\n\tstruct drm_i915_private *dev_priv = to_i915(encoder->base.dev);\n\tstruct intel_dsi *intel_dsi = enc_to_intel_dsi(encoder);\n\tstruct mipi_dsi_device *dsi;\n\tenum port port;\n\tenum transcoder dsi_trans;\n\tu32 tmp;\n\tint ret;\n\n\t \n\tfor_each_dsi_port(port, intel_dsi->ports) {\n\t\tdsi_trans = dsi_port_to_transcoder(port);\n\n\t\t \n\t\ttmp = intel_de_read(dev_priv, DSI_CMD_RXCTL(dsi_trans));\n\t\ttmp &= NUMBER_RX_PLOAD_DW_MASK;\n\t\t \n\t\ttmp = tmp * 4;\n\t\tdsi = intel_dsi->dsi_hosts[port]->device;\n\t\tret = mipi_dsi_set_maximum_return_packet_size(dsi, tmp);\n\t\tif (ret < 0)\n\t\t\tdrm_err(&dev_priv->drm,\n\t\t\t\t\"error setting max return pkt size%d\\n\", tmp);\n\t}\n\n\tintel_dsi_vbt_exec_sequence(intel_dsi, MIPI_SEQ_INIT_OTP);\n\n\t \n\twait_for_cmds_dispatched_to_panel(encoder);\n}\n\nstatic void gen11_dsi_pre_pll_enable(struct intel_atomic_state *state,\n\t\t\t\t     struct intel_encoder *encoder,\n\t\t\t\t     const struct intel_crtc_state *crtc_state,\n\t\t\t\t     const struct drm_connector_state *conn_state)\n{\n\tstruct intel_dsi *intel_dsi = enc_to_intel_dsi(encoder);\n\n\tintel_dsi_wait_panel_power_cycle(intel_dsi);\n\n\tintel_dsi_vbt_exec_sequence(intel_dsi, MIPI_SEQ_POWER_ON);\n\tmsleep(intel_dsi->panel_on_delay);\n\tintel_dsi_vbt_exec_sequence(intel_dsi, MIPI_SEQ_DEASSERT_RESET);\n\n\t \n\tgen11_dsi_enable_io_power(encoder);\n\n\t \n\tgen11_dsi_program_esc_clk_div(encoder, crtc_state);\n}\n\nstatic void gen11_dsi_pre_enable(struct intel_atomic_state *state,\n\t\t\t\t struct intel_encoder *encoder,\n\t\t\t\t const struct intel_crtc_state *pipe_config,\n\t\t\t\t const struct drm_connector_state *conn_state)\n{\n\t \n\tgen11_dsi_map_pll(encoder, pipe_config);\n\n\t \n\tgen11_dsi_enable_port_and_phy(encoder, pipe_config);\n\n\t \n\tgen11_dsi_powerup_panel(encoder);\n\n\tintel_dsc_dsi_pps_write(encoder, pipe_config);\n\n\t \n\tgen11_dsi_set_transcoder_timings(encoder, pipe_config);\n}\n\n \nstatic void icl_apply_kvmr_pipe_a_wa(struct intel_encoder *encoder,\n\t\t\t\t     enum pipe pipe, bool enable)\n{\n\tstruct drm_i915_private *dev_priv = to_i915(encoder->base.dev);\n\n\tif (DISPLAY_VER(dev_priv) == 11 && pipe == PIPE_B)\n\t\tintel_de_rmw(dev_priv, CHICKEN_PAR1_1,\n\t\t\t     IGNORE_KVMR_PIPE_A,\n\t\t\t     enable ? IGNORE_KVMR_PIPE_A : 0);\n}\n\n \nstatic void adlp_set_lp_hs_wakeup_gb(struct intel_encoder *encoder)\n{\n\tstruct drm_i915_private *i915 = to_i915(encoder->base.dev);\n\tstruct intel_dsi *intel_dsi = enc_to_intel_dsi(encoder);\n\tenum port port;\n\n\tif (DISPLAY_VER(i915) == 13) {\n\t\tfor_each_dsi_port(port, intel_dsi->ports)\n\t\t\tintel_de_rmw(i915, TGL_DSI_CHKN_REG(port),\n\t\t\t\t     TGL_DSI_CHKN_LSHS_GB_MASK,\n\t\t\t\t     TGL_DSI_CHKN_LSHS_GB(4));\n\t}\n}\n\nstatic void gen11_dsi_enable(struct intel_atomic_state *state,\n\t\t\t     struct intel_encoder *encoder,\n\t\t\t     const struct intel_crtc_state *crtc_state,\n\t\t\t     const struct drm_connector_state *conn_state)\n{\n\tstruct intel_dsi *intel_dsi = enc_to_intel_dsi(encoder);\n\tstruct intel_crtc *crtc = to_intel_crtc(crtc_state->uapi.crtc);\n\n\t \n\ticl_apply_kvmr_pipe_a_wa(encoder, crtc->pipe, true);\n\n\t \n\tadlp_set_lp_hs_wakeup_gb(encoder);\n\n\t \n\tgen11_dsi_enable_transcoder(encoder);\n\n\tintel_dsi_vbt_exec_sequence(intel_dsi, MIPI_SEQ_DISPLAY_ON);\n\n\t \n\tintel_backlight_enable(crtc_state, conn_state);\n\tintel_dsi_vbt_exec_sequence(intel_dsi, MIPI_SEQ_BACKLIGHT_ON);\n\n\tintel_crtc_vblank_on(crtc_state);\n}\n\nstatic void gen11_dsi_disable_transcoder(struct intel_encoder *encoder)\n{\n\tstruct drm_i915_private *dev_priv = to_i915(encoder->base.dev);\n\tstruct intel_dsi *intel_dsi = enc_to_intel_dsi(encoder);\n\tenum port port;\n\tenum transcoder dsi_trans;\n\n\tfor_each_dsi_port(port, intel_dsi->ports) {\n\t\tdsi_trans = dsi_port_to_transcoder(port);\n\n\t\t \n\t\tintel_de_rmw(dev_priv, TRANSCONF(dsi_trans), TRANSCONF_ENABLE, 0);\n\n\t\t \n\t\tif (intel_de_wait_for_clear(dev_priv, TRANSCONF(dsi_trans),\n\t\t\t\t\t    TRANSCONF_STATE_ENABLE, 50))\n\t\t\tdrm_err(&dev_priv->drm,\n\t\t\t\t\"DSI trancoder not disabled\\n\");\n\t}\n}\n\nstatic void gen11_dsi_powerdown_panel(struct intel_encoder *encoder)\n{\n\tstruct intel_dsi *intel_dsi = enc_to_intel_dsi(encoder);\n\n\tintel_dsi_vbt_exec_sequence(intel_dsi, MIPI_SEQ_DISPLAY_OFF);\n\n\t \n\twait_for_cmds_dispatched_to_panel(encoder);\n}\n\nstatic void gen11_dsi_deconfigure_trancoder(struct intel_encoder *encoder)\n{\n\tstruct drm_i915_private *dev_priv = to_i915(encoder->base.dev);\n\tstruct intel_dsi *intel_dsi = enc_to_intel_dsi(encoder);\n\tenum port port;\n\tenum transcoder dsi_trans;\n\tu32 tmp;\n\n\t \n\tif (is_cmd_mode(intel_dsi)) {\n\t\tfor_each_dsi_port(port, intel_dsi->ports)\n\t\t\tintel_de_rmw(dev_priv, DSI_CMD_FRMCTL(port),\n\t\t\t\t     DSI_PERIODIC_FRAME_UPDATE_ENABLE, 0);\n\t}\n\n\t \n\tfor_each_dsi_port(port, intel_dsi->ports) {\n\t\tdsi_trans = dsi_port_to_transcoder(port);\n\t\ttmp = intel_de_read(dev_priv, DSI_LP_MSG(dsi_trans));\n\t\ttmp |= LINK_ENTER_ULPS;\n\t\ttmp &= ~LINK_ULPS_TYPE_LP11;\n\t\tintel_de_write(dev_priv, DSI_LP_MSG(dsi_trans), tmp);\n\n\t\tif (wait_for_us((intel_de_read(dev_priv, DSI_LP_MSG(dsi_trans)) &\n\t\t\t\t LINK_IN_ULPS),\n\t\t\t\t10))\n\t\t\tdrm_err(&dev_priv->drm, \"DSI link not in ULPS\\n\");\n\t}\n\n\t \n\tfor_each_dsi_port(port, intel_dsi->ports) {\n\t\tdsi_trans = dsi_port_to_transcoder(port);\n\t\tintel_de_rmw(dev_priv, TRANS_DDI_FUNC_CTL(dsi_trans),\n\t\t\t     TRANS_DDI_FUNC_ENABLE, 0);\n\t}\n\n\t \n\tif (intel_dsi->dual_link) {\n\t\tfor_each_dsi_port(port, intel_dsi->ports) {\n\t\t\tdsi_trans = dsi_port_to_transcoder(port);\n\t\t\tintel_de_rmw(dev_priv, TRANS_DDI_FUNC_CTL2(dsi_trans),\n\t\t\t\t     PORT_SYNC_MODE_ENABLE, 0);\n\t\t}\n\t}\n}\n\nstatic void gen11_dsi_disable_port(struct intel_encoder *encoder)\n{\n\tstruct drm_i915_private *dev_priv = to_i915(encoder->base.dev);\n\tstruct intel_dsi *intel_dsi = enc_to_intel_dsi(encoder);\n\tenum port port;\n\n\tgen11_dsi_ungate_clocks(encoder);\n\tfor_each_dsi_port(port, intel_dsi->ports) {\n\t\tintel_de_rmw(dev_priv, DDI_BUF_CTL(port), DDI_BUF_CTL_ENABLE, 0);\n\n\t\tif (wait_for_us((intel_de_read(dev_priv, DDI_BUF_CTL(port)) &\n\t\t\t\t DDI_BUF_IS_IDLE),\n\t\t\t\t 8))\n\t\t\tdrm_err(&dev_priv->drm,\n\t\t\t\t\"DDI port:%c buffer not idle\\n\",\n\t\t\t\tport_name(port));\n\t}\n\tgen11_dsi_gate_clocks(encoder);\n}\n\nstatic void gen11_dsi_disable_io_power(struct intel_encoder *encoder)\n{\n\tstruct drm_i915_private *dev_priv = to_i915(encoder->base.dev);\n\tstruct intel_dsi *intel_dsi = enc_to_intel_dsi(encoder);\n\tenum port port;\n\n\tfor_each_dsi_port(port, intel_dsi->ports) {\n\t\tintel_wakeref_t wakeref;\n\n\t\twakeref = fetch_and_zero(&intel_dsi->io_wakeref[port]);\n\t\tintel_display_power_put(dev_priv,\n\t\t\t\t\tport == PORT_A ?\n\t\t\t\t\tPOWER_DOMAIN_PORT_DDI_IO_A :\n\t\t\t\t\tPOWER_DOMAIN_PORT_DDI_IO_B,\n\t\t\t\t\twakeref);\n\t}\n\n\t \n\tfor_each_dsi_port(port, intel_dsi->ports)\n\t\tintel_de_rmw(dev_priv, ICL_DSI_IO_MODECTL(port),\n\t\t\t     COMBO_PHY_MODE_DSI, 0);\n}\n\nstatic void gen11_dsi_disable(struct intel_atomic_state *state,\n\t\t\t      struct intel_encoder *encoder,\n\t\t\t      const struct intel_crtc_state *old_crtc_state,\n\t\t\t      const struct drm_connector_state *old_conn_state)\n{\n\tstruct intel_dsi *intel_dsi = enc_to_intel_dsi(encoder);\n\n\t \n\tintel_dsi_vbt_exec_sequence(intel_dsi, MIPI_SEQ_BACKLIGHT_OFF);\n\tintel_backlight_disable(old_conn_state);\n}\n\nstatic void gen11_dsi_post_disable(struct intel_atomic_state *state,\n\t\t\t\t   struct intel_encoder *encoder,\n\t\t\t\t   const struct intel_crtc_state *old_crtc_state,\n\t\t\t\t   const struct drm_connector_state *old_conn_state)\n{\n\tstruct intel_dsi *intel_dsi = enc_to_intel_dsi(encoder);\n\tstruct intel_crtc *crtc = to_intel_crtc(old_crtc_state->uapi.crtc);\n\n\tintel_crtc_vblank_off(old_crtc_state);\n\n\t \n\tgen11_dsi_disable_transcoder(encoder);\n\n\t \n\ticl_apply_kvmr_pipe_a_wa(encoder, crtc->pipe, false);\n\n\t \n\tgen11_dsi_powerdown_panel(encoder);\n\n\t \n\tgen11_dsi_deconfigure_trancoder(encoder);\n\n\tintel_dsc_disable(old_crtc_state);\n\tskl_scaler_disable(old_crtc_state);\n\n\t \n\tgen11_dsi_disable_port(encoder);\n\n\tgen11_dsi_config_util_pin(encoder, false);\n\n\t \n\tgen11_dsi_disable_io_power(encoder);\n\n\tintel_dsi_vbt_exec_sequence(intel_dsi, MIPI_SEQ_ASSERT_RESET);\n\n\tmsleep(intel_dsi->panel_off_delay);\n\tintel_dsi_vbt_exec_sequence(intel_dsi, MIPI_SEQ_POWER_OFF);\n\n\tintel_dsi->panel_power_off_time = ktime_get_boottime();\n}\n\nstatic enum drm_mode_status gen11_dsi_mode_valid(struct drm_connector *connector,\n\t\t\t\t\t\t struct drm_display_mode *mode)\n{\n\tstruct drm_i915_private *i915 = to_i915(connector->dev);\n\tenum drm_mode_status status;\n\n\tstatus = intel_cpu_transcoder_mode_valid(i915, mode);\n\tif (status != MODE_OK)\n\t\treturn status;\n\n\t \n\treturn intel_dsi_mode_valid(connector, mode);\n}\n\nstatic void gen11_dsi_get_timings(struct intel_encoder *encoder,\n\t\t\t\t  struct intel_crtc_state *pipe_config)\n{\n\tstruct intel_dsi *intel_dsi = enc_to_intel_dsi(encoder);\n\tstruct drm_display_mode *adjusted_mode =\n\t\t\t\t\t&pipe_config->hw.adjusted_mode;\n\n\tif (pipe_config->dsc.compressed_bpp) {\n\t\tint div = pipe_config->dsc.compressed_bpp;\n\t\tint mul = mipi_dsi_pixel_format_to_bpp(intel_dsi->pixel_format);\n\n\t\tadjusted_mode->crtc_htotal =\n\t\t\tDIV_ROUND_UP(adjusted_mode->crtc_htotal * mul, div);\n\t\tadjusted_mode->crtc_hsync_start =\n\t\t\tDIV_ROUND_UP(adjusted_mode->crtc_hsync_start * mul, div);\n\t\tadjusted_mode->crtc_hsync_end =\n\t\t\tDIV_ROUND_UP(adjusted_mode->crtc_hsync_end * mul, div);\n\t}\n\n\tif (intel_dsi->dual_link) {\n\t\tadjusted_mode->crtc_hdisplay *= 2;\n\t\tif (intel_dsi->dual_link == DSI_DUAL_LINK_FRONT_BACK)\n\t\t\tadjusted_mode->crtc_hdisplay -=\n\t\t\t\t\t\tintel_dsi->pixel_overlap;\n\t\tadjusted_mode->crtc_htotal *= 2;\n\t}\n\tadjusted_mode->crtc_hblank_start = adjusted_mode->crtc_hdisplay;\n\tadjusted_mode->crtc_hblank_end = adjusted_mode->crtc_htotal;\n\n\tif (intel_dsi->operation_mode == INTEL_DSI_VIDEO_MODE) {\n\t\tif (intel_dsi->dual_link) {\n\t\t\tadjusted_mode->crtc_hsync_start *= 2;\n\t\t\tadjusted_mode->crtc_hsync_end *= 2;\n\t\t}\n\t}\n\tadjusted_mode->crtc_vblank_start = adjusted_mode->crtc_vdisplay;\n\tadjusted_mode->crtc_vblank_end = adjusted_mode->crtc_vtotal;\n}\n\nstatic bool gen11_dsi_is_periodic_cmd_mode(struct intel_dsi *intel_dsi)\n{\n\tstruct drm_device *dev = intel_dsi->base.base.dev;\n\tstruct drm_i915_private *dev_priv = to_i915(dev);\n\tenum transcoder dsi_trans;\n\tu32 val;\n\n\tif (intel_dsi->ports == BIT(PORT_B))\n\t\tdsi_trans = TRANSCODER_DSI_1;\n\telse\n\t\tdsi_trans = TRANSCODER_DSI_0;\n\n\tval = intel_de_read(dev_priv, DSI_TRANS_FUNC_CONF(dsi_trans));\n\treturn (val & DSI_PERIODIC_FRAME_UPDATE_ENABLE);\n}\n\nstatic void gen11_dsi_get_cmd_mode_config(struct intel_dsi *intel_dsi,\n\t\t\t\t\t  struct intel_crtc_state *pipe_config)\n{\n\tif (intel_dsi->ports == (BIT(PORT_B) | BIT(PORT_A)))\n\t\tpipe_config->mode_flags |= I915_MODE_FLAG_DSI_USE_TE1 |\n\t\t\t\t\t    I915_MODE_FLAG_DSI_USE_TE0;\n\telse if (intel_dsi->ports == BIT(PORT_B))\n\t\tpipe_config->mode_flags |= I915_MODE_FLAG_DSI_USE_TE1;\n\telse\n\t\tpipe_config->mode_flags |= I915_MODE_FLAG_DSI_USE_TE0;\n}\n\nstatic void gen11_dsi_get_config(struct intel_encoder *encoder,\n\t\t\t\t struct intel_crtc_state *pipe_config)\n{\n\tstruct intel_crtc *crtc = to_intel_crtc(pipe_config->uapi.crtc);\n\tstruct intel_dsi *intel_dsi = enc_to_intel_dsi(encoder);\n\n\tintel_ddi_get_clock(encoder, pipe_config, icl_ddi_combo_get_pll(encoder));\n\n\tpipe_config->hw.adjusted_mode.crtc_clock = intel_dsi->pclk;\n\tif (intel_dsi->dual_link)\n\t\tpipe_config->hw.adjusted_mode.crtc_clock *= 2;\n\n\tgen11_dsi_get_timings(encoder, pipe_config);\n\tpipe_config->output_types |= BIT(INTEL_OUTPUT_DSI);\n\tpipe_config->pipe_bpp = bdw_get_pipe_misc_bpp(crtc);\n\n\t \n\tif (is_cmd_mode(intel_dsi))\n\t\tgen11_dsi_get_cmd_mode_config(intel_dsi, pipe_config);\n\n\tif (gen11_dsi_is_periodic_cmd_mode(intel_dsi))\n\t\tpipe_config->mode_flags |= I915_MODE_FLAG_DSI_PERIODIC_CMD_MODE;\n}\n\nstatic void gen11_dsi_sync_state(struct intel_encoder *encoder,\n\t\t\t\t const struct intel_crtc_state *crtc_state)\n{\n\tstruct drm_i915_private *dev_priv = to_i915(encoder->base.dev);\n\tstruct intel_crtc *intel_crtc;\n\tenum pipe pipe;\n\n\tif (!crtc_state)\n\t\treturn;\n\n\tintel_crtc = to_intel_crtc(crtc_state->uapi.crtc);\n\tpipe = intel_crtc->pipe;\n\n\t \n\tif (DISPLAY_VER(dev_priv) == 11 && pipe == PIPE_B &&\n\t    !(intel_de_read(dev_priv, CHICKEN_PAR1_1) & IGNORE_KVMR_PIPE_A))\n\t\tdrm_dbg_kms(&dev_priv->drm,\n\t\t\t    \"[ENCODER:%d:%s] BIOS left IGNORE_KVMR_PIPE_A cleared with pipe B enabled\\n\",\n\t\t\t    encoder->base.base.id,\n\t\t\t    encoder->base.name);\n}\n\nstatic int gen11_dsi_dsc_compute_config(struct intel_encoder *encoder,\n\t\t\t\t\tstruct intel_crtc_state *crtc_state)\n{\n\tstruct drm_i915_private *dev_priv = to_i915(encoder->base.dev);\n\tstruct drm_dsc_config *vdsc_cfg = &crtc_state->dsc.config;\n\tint dsc_max_bpc = DISPLAY_VER(dev_priv) >= 12 ? 12 : 10;\n\tbool use_dsc;\n\tint ret;\n\n\tuse_dsc = intel_bios_get_dsc_params(encoder, crtc_state, dsc_max_bpc);\n\tif (!use_dsc)\n\t\treturn 0;\n\n\tif (crtc_state->pipe_bpp < 8 * 3)\n\t\treturn -EINVAL;\n\n\t \n\tif (crtc_state->dsc.slice_count > 1)\n\t\tcrtc_state->dsc.dsc_split = true;\n\n\t \n\tvdsc_cfg->rc_model_size = DSC_RC_MODEL_SIZE_CONST;\n\n\tvdsc_cfg->pic_height = crtc_state->hw.adjusted_mode.crtc_vdisplay;\n\n\tret = intel_dsc_compute_params(crtc_state);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tdrm_WARN_ON(&dev_priv->drm, vdsc_cfg->vbr_enable);\n\tdrm_WARN_ON(&dev_priv->drm, vdsc_cfg->simple_422);\n\tdrm_WARN_ON(&dev_priv->drm,\n\t\t    vdsc_cfg->pic_width % vdsc_cfg->slice_width);\n\tdrm_WARN_ON(&dev_priv->drm, vdsc_cfg->slice_height < 8);\n\tdrm_WARN_ON(&dev_priv->drm,\n\t\t    vdsc_cfg->pic_height % vdsc_cfg->slice_height);\n\n\tret = drm_dsc_compute_rc_parameters(vdsc_cfg);\n\tif (ret)\n\t\treturn ret;\n\n\tcrtc_state->dsc.compression_enable = true;\n\n\treturn 0;\n}\n\nstatic int gen11_dsi_compute_config(struct intel_encoder *encoder,\n\t\t\t\t    struct intel_crtc_state *pipe_config,\n\t\t\t\t    struct drm_connector_state *conn_state)\n{\n\tstruct drm_i915_private *i915 = to_i915(encoder->base.dev);\n\tstruct intel_dsi *intel_dsi = container_of(encoder, struct intel_dsi,\n\t\t\t\t\t\t   base);\n\tstruct intel_connector *intel_connector = intel_dsi->attached_connector;\n\tstruct drm_display_mode *adjusted_mode =\n\t\t&pipe_config->hw.adjusted_mode;\n\tint ret;\n\n\tpipe_config->sink_format = INTEL_OUTPUT_FORMAT_RGB;\n\tpipe_config->output_format = INTEL_OUTPUT_FORMAT_RGB;\n\n\tret = intel_panel_compute_config(intel_connector, adjusted_mode);\n\tif (ret)\n\t\treturn ret;\n\n\tret = intel_panel_fitting(pipe_config, conn_state);\n\tif (ret)\n\t\treturn ret;\n\n\tadjusted_mode->flags = 0;\n\n\t \n\tif (intel_dsi->ports == BIT(PORT_B))\n\t\tpipe_config->cpu_transcoder = TRANSCODER_DSI_1;\n\telse\n\t\tpipe_config->cpu_transcoder = TRANSCODER_DSI_0;\n\n\tif (intel_dsi->pixel_format == MIPI_DSI_FMT_RGB888)\n\t\tpipe_config->pipe_bpp = 24;\n\telse\n\t\tpipe_config->pipe_bpp = 18;\n\n\tpipe_config->clock_set = true;\n\n\tif (gen11_dsi_dsc_compute_config(encoder, pipe_config))\n\t\tdrm_dbg_kms(&i915->drm, \"Attempting to use DSC failed\\n\");\n\n\tpipe_config->port_clock = afe_clk(encoder, pipe_config) / 5;\n\n\t \n\tif (is_cmd_mode(intel_dsi))\n\t\tgen11_dsi_get_cmd_mode_config(intel_dsi, pipe_config);\n\n\treturn 0;\n}\n\nstatic void gen11_dsi_get_power_domains(struct intel_encoder *encoder,\n\t\t\t\t\tstruct intel_crtc_state *crtc_state)\n{\n\tstruct drm_i915_private *i915 = to_i915(encoder->base.dev);\n\n\tget_dsi_io_power_domains(i915,\n\t\t\t\t enc_to_intel_dsi(encoder));\n}\n\nstatic bool gen11_dsi_get_hw_state(struct intel_encoder *encoder,\n\t\t\t\t   enum pipe *pipe)\n{\n\tstruct drm_i915_private *dev_priv = to_i915(encoder->base.dev);\n\tstruct intel_dsi *intel_dsi = enc_to_intel_dsi(encoder);\n\tenum transcoder dsi_trans;\n\tintel_wakeref_t wakeref;\n\tenum port port;\n\tbool ret = false;\n\tu32 tmp;\n\n\twakeref = intel_display_power_get_if_enabled(dev_priv,\n\t\t\t\t\t\t     encoder->power_domain);\n\tif (!wakeref)\n\t\treturn false;\n\n\tfor_each_dsi_port(port, intel_dsi->ports) {\n\t\tdsi_trans = dsi_port_to_transcoder(port);\n\t\ttmp = intel_de_read(dev_priv, TRANS_DDI_FUNC_CTL(dsi_trans));\n\t\tswitch (tmp & TRANS_DDI_EDP_INPUT_MASK) {\n\t\tcase TRANS_DDI_EDP_INPUT_A_ON:\n\t\t\t*pipe = PIPE_A;\n\t\t\tbreak;\n\t\tcase TRANS_DDI_EDP_INPUT_B_ONOFF:\n\t\t\t*pipe = PIPE_B;\n\t\t\tbreak;\n\t\tcase TRANS_DDI_EDP_INPUT_C_ONOFF:\n\t\t\t*pipe = PIPE_C;\n\t\t\tbreak;\n\t\tcase TRANS_DDI_EDP_INPUT_D_ONOFF:\n\t\t\t*pipe = PIPE_D;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdrm_err(&dev_priv->drm, \"Invalid PIPE input\\n\");\n\t\t\tgoto out;\n\t\t}\n\n\t\ttmp = intel_de_read(dev_priv, TRANSCONF(dsi_trans));\n\t\tret = tmp & TRANSCONF_ENABLE;\n\t}\nout:\n\tintel_display_power_put(dev_priv, encoder->power_domain, wakeref);\n\treturn ret;\n}\n\nstatic bool gen11_dsi_initial_fastset_check(struct intel_encoder *encoder,\n\t\t\t\t\t    struct intel_crtc_state *crtc_state)\n{\n\tif (crtc_state->dsc.compression_enable) {\n\t\tdrm_dbg_kms(encoder->base.dev, \"Forcing full modeset due to DSC being enabled\\n\");\n\t\tcrtc_state->uapi.mode_changed = true;\n\n\t\treturn false;\n\t}\n\n\treturn true;\n}\n\nstatic void gen11_dsi_encoder_destroy(struct drm_encoder *encoder)\n{\n\tintel_encoder_destroy(encoder);\n}\n\nstatic const struct drm_encoder_funcs gen11_dsi_encoder_funcs = {\n\t.destroy = gen11_dsi_encoder_destroy,\n};\n\nstatic const struct drm_connector_funcs gen11_dsi_connector_funcs = {\n\t.detect = intel_panel_detect,\n\t.late_register = intel_connector_register,\n\t.early_unregister = intel_connector_unregister,\n\t.destroy = intel_connector_destroy,\n\t.fill_modes = drm_helper_probe_single_connector_modes,\n\t.atomic_get_property = intel_digital_connector_atomic_get_property,\n\t.atomic_set_property = intel_digital_connector_atomic_set_property,\n\t.atomic_destroy_state = drm_atomic_helper_connector_destroy_state,\n\t.atomic_duplicate_state = intel_digital_connector_duplicate_state,\n};\n\nstatic const struct drm_connector_helper_funcs gen11_dsi_connector_helper_funcs = {\n\t.get_modes = intel_dsi_get_modes,\n\t.mode_valid = gen11_dsi_mode_valid,\n\t.atomic_check = intel_digital_connector_atomic_check,\n};\n\nstatic int gen11_dsi_host_attach(struct mipi_dsi_host *host,\n\t\t\t\t struct mipi_dsi_device *dsi)\n{\n\treturn 0;\n}\n\nstatic int gen11_dsi_host_detach(struct mipi_dsi_host *host,\n\t\t\t\t struct mipi_dsi_device *dsi)\n{\n\treturn 0;\n}\n\nstatic ssize_t gen11_dsi_host_transfer(struct mipi_dsi_host *host,\n\t\t\t\t       const struct mipi_dsi_msg *msg)\n{\n\tstruct intel_dsi_host *intel_dsi_host = to_intel_dsi_host(host);\n\tstruct mipi_dsi_packet dsi_pkt;\n\tssize_t ret;\n\tbool enable_lpdt = false;\n\n\tret = mipi_dsi_create_packet(&dsi_pkt, msg);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (msg->flags & MIPI_DSI_MSG_USE_LPM)\n\t\tenable_lpdt = true;\n\n\t \n\tif (mipi_dsi_packet_format_is_long(msg->type)) {\n\t\tret = dsi_send_pkt_payld(intel_dsi_host, &dsi_pkt);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\t \n\tret  = dsi_send_pkt_hdr(intel_dsi_host, &dsi_pkt, enable_lpdt);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t\n\n\tret = sizeof(dsi_pkt.header) + dsi_pkt.payload_length;\n\n\treturn ret;\n}\n\nstatic const struct mipi_dsi_host_ops gen11_dsi_host_ops = {\n\t.attach = gen11_dsi_host_attach,\n\t.detach = gen11_dsi_host_detach,\n\t.transfer = gen11_dsi_host_transfer,\n};\n\n#define ICL_PREPARE_CNT_MAX\t0x7\n#define ICL_CLK_ZERO_CNT_MAX\t0xf\n#define ICL_TRAIL_CNT_MAX\t0x7\n#define ICL_TCLK_PRE_CNT_MAX\t0x3\n#define ICL_TCLK_POST_CNT_MAX\t0x7\n#define ICL_HS_ZERO_CNT_MAX\t0xf\n#define ICL_EXIT_ZERO_CNT_MAX\t0x7\n\nstatic void icl_dphy_param_init(struct intel_dsi *intel_dsi)\n{\n\tstruct drm_device *dev = intel_dsi->base.base.dev;\n\tstruct drm_i915_private *dev_priv = to_i915(dev);\n\tstruct intel_connector *connector = intel_dsi->attached_connector;\n\tstruct mipi_config *mipi_config = connector->panel.vbt.dsi.config;\n\tu32 tlpx_ns;\n\tu32 prepare_cnt, exit_zero_cnt, clk_zero_cnt, trail_cnt;\n\tu32 ths_prepare_ns, tclk_trail_ns;\n\tu32 hs_zero_cnt;\n\tu32 tclk_pre_cnt, tclk_post_cnt;\n\n\ttlpx_ns = intel_dsi_tlpx_ns(intel_dsi);\n\n\ttclk_trail_ns = max(mipi_config->tclk_trail, mipi_config->ths_trail);\n\tths_prepare_ns = max(mipi_config->ths_prepare,\n\t\t\t     mipi_config->tclk_prepare);\n\n\t \n\tprepare_cnt = DIV_ROUND_UP(ths_prepare_ns * 4, tlpx_ns);\n\tif (prepare_cnt > ICL_PREPARE_CNT_MAX) {\n\t\tdrm_dbg_kms(&dev_priv->drm, \"prepare_cnt out of range (%d)\\n\",\n\t\t\t    prepare_cnt);\n\t\tprepare_cnt = ICL_PREPARE_CNT_MAX;\n\t}\n\n\t \n\tclk_zero_cnt = DIV_ROUND_UP(mipi_config->tclk_prepare_clkzero -\n\t\t\t\t    ths_prepare_ns, tlpx_ns);\n\tif (clk_zero_cnt > ICL_CLK_ZERO_CNT_MAX) {\n\t\tdrm_dbg_kms(&dev_priv->drm,\n\t\t\t    \"clk_zero_cnt out of range (%d)\\n\", clk_zero_cnt);\n\t\tclk_zero_cnt = ICL_CLK_ZERO_CNT_MAX;\n\t}\n\n\t \n\ttrail_cnt = DIV_ROUND_UP(tclk_trail_ns, tlpx_ns);\n\tif (trail_cnt > ICL_TRAIL_CNT_MAX) {\n\t\tdrm_dbg_kms(&dev_priv->drm, \"trail_cnt out of range (%d)\\n\",\n\t\t\t    trail_cnt);\n\t\ttrail_cnt = ICL_TRAIL_CNT_MAX;\n\t}\n\n\t \n\ttclk_pre_cnt = DIV_ROUND_UP(mipi_config->tclk_pre, tlpx_ns);\n\tif (tclk_pre_cnt > ICL_TCLK_PRE_CNT_MAX) {\n\t\tdrm_dbg_kms(&dev_priv->drm,\n\t\t\t    \"tclk_pre_cnt out of range (%d)\\n\", tclk_pre_cnt);\n\t\ttclk_pre_cnt = ICL_TCLK_PRE_CNT_MAX;\n\t}\n\n\t \n\ttclk_post_cnt = DIV_ROUND_UP(mipi_config->tclk_post, tlpx_ns);\n\tif (tclk_post_cnt > ICL_TCLK_POST_CNT_MAX) {\n\t\tdrm_dbg_kms(&dev_priv->drm,\n\t\t\t    \"tclk_post_cnt out of range (%d)\\n\",\n\t\t\t    tclk_post_cnt);\n\t\ttclk_post_cnt = ICL_TCLK_POST_CNT_MAX;\n\t}\n\n\t \n\ths_zero_cnt = DIV_ROUND_UP(mipi_config->ths_prepare_hszero -\n\t\t\t\t   ths_prepare_ns, tlpx_ns);\n\tif (hs_zero_cnt > ICL_HS_ZERO_CNT_MAX) {\n\t\tdrm_dbg_kms(&dev_priv->drm, \"hs_zero_cnt out of range (%d)\\n\",\n\t\t\t    hs_zero_cnt);\n\t\ths_zero_cnt = ICL_HS_ZERO_CNT_MAX;\n\t}\n\n\t \n\texit_zero_cnt = DIV_ROUND_UP(mipi_config->ths_exit, tlpx_ns);\n\tif (exit_zero_cnt > ICL_EXIT_ZERO_CNT_MAX) {\n\t\tdrm_dbg_kms(&dev_priv->drm,\n\t\t\t    \"exit_zero_cnt out of range (%d)\\n\",\n\t\t\t    exit_zero_cnt);\n\t\texit_zero_cnt = ICL_EXIT_ZERO_CNT_MAX;\n\t}\n\n\t \n\tintel_dsi->dphy_reg = (CLK_PREPARE_OVERRIDE |\n\t\t\t       CLK_PREPARE(prepare_cnt) |\n\t\t\t       CLK_ZERO_OVERRIDE |\n\t\t\t       CLK_ZERO(clk_zero_cnt) |\n\t\t\t       CLK_PRE_OVERRIDE |\n\t\t\t       CLK_PRE(tclk_pre_cnt) |\n\t\t\t       CLK_POST_OVERRIDE |\n\t\t\t       CLK_POST(tclk_post_cnt) |\n\t\t\t       CLK_TRAIL_OVERRIDE |\n\t\t\t       CLK_TRAIL(trail_cnt));\n\n\t \n\tintel_dsi->dphy_data_lane_reg = (HS_PREPARE_OVERRIDE |\n\t\t\t\t\t HS_PREPARE(prepare_cnt) |\n\t\t\t\t\t HS_ZERO_OVERRIDE |\n\t\t\t\t\t HS_ZERO(hs_zero_cnt) |\n\t\t\t\t\t HS_TRAIL_OVERRIDE |\n\t\t\t\t\t HS_TRAIL(trail_cnt) |\n\t\t\t\t\t HS_EXIT_OVERRIDE |\n\t\t\t\t\t HS_EXIT(exit_zero_cnt));\n\n\tintel_dsi_log_params(intel_dsi);\n}\n\nstatic void icl_dsi_add_properties(struct intel_connector *connector)\n{\n\tconst struct drm_display_mode *fixed_mode =\n\t\tintel_panel_preferred_fixed_mode(connector);\n\n\tintel_attach_scaling_mode_property(&connector->base);\n\n\tdrm_connector_set_panel_orientation_with_quirk(&connector->base,\n\t\t\t\t\t\t       intel_dsi_get_panel_orientation(connector),\n\t\t\t\t\t\t       fixed_mode->hdisplay,\n\t\t\t\t\t\t       fixed_mode->vdisplay);\n}\n\nvoid icl_dsi_init(struct drm_i915_private *dev_priv,\n\t\t  const struct intel_bios_encoder_data *devdata)\n{\n\tstruct intel_dsi *intel_dsi;\n\tstruct intel_encoder *encoder;\n\tstruct intel_connector *intel_connector;\n\tstruct drm_connector *connector;\n\tenum port port;\n\n\tport = intel_bios_encoder_port(devdata);\n\tif (port == PORT_NONE)\n\t\treturn;\n\n\tintel_dsi = kzalloc(sizeof(*intel_dsi), GFP_KERNEL);\n\tif (!intel_dsi)\n\t\treturn;\n\n\tintel_connector = intel_connector_alloc();\n\tif (!intel_connector) {\n\t\tkfree(intel_dsi);\n\t\treturn;\n\t}\n\n\tencoder = &intel_dsi->base;\n\tintel_dsi->attached_connector = intel_connector;\n\tconnector = &intel_connector->base;\n\n\tencoder->devdata = devdata;\n\n\t \n\tdrm_encoder_init(&dev_priv->drm, &encoder->base, &gen11_dsi_encoder_funcs,\n\t\t\t DRM_MODE_ENCODER_DSI, \"DSI %c\", port_name(port));\n\n\tencoder->pre_pll_enable = gen11_dsi_pre_pll_enable;\n\tencoder->pre_enable = gen11_dsi_pre_enable;\n\tencoder->enable = gen11_dsi_enable;\n\tencoder->disable = gen11_dsi_disable;\n\tencoder->post_disable = gen11_dsi_post_disable;\n\tencoder->port = port;\n\tencoder->get_config = gen11_dsi_get_config;\n\tencoder->sync_state = gen11_dsi_sync_state;\n\tencoder->update_pipe = intel_backlight_update;\n\tencoder->compute_config = gen11_dsi_compute_config;\n\tencoder->get_hw_state = gen11_dsi_get_hw_state;\n\tencoder->initial_fastset_check = gen11_dsi_initial_fastset_check;\n\tencoder->type = INTEL_OUTPUT_DSI;\n\tencoder->cloneable = 0;\n\tencoder->pipe_mask = ~0;\n\tencoder->power_domain = POWER_DOMAIN_PORT_DSI;\n\tencoder->get_power_domains = gen11_dsi_get_power_domains;\n\tencoder->disable_clock = gen11_dsi_gate_clocks;\n\tencoder->is_clock_enabled = gen11_dsi_is_clock_enabled;\n\tencoder->shutdown = intel_dsi_shutdown;\n\n\t \n\tdrm_connector_init(&dev_priv->drm, connector, &gen11_dsi_connector_funcs,\n\t\t\t   DRM_MODE_CONNECTOR_DSI);\n\tdrm_connector_helper_add(connector, &gen11_dsi_connector_helper_funcs);\n\tconnector->display_info.subpixel_order = SubPixelHorizontalRGB;\n\tintel_connector->get_hw_state = intel_connector_get_hw_state;\n\n\t \n\tintel_connector_attach_encoder(intel_connector, encoder);\n\n\tintel_dsi->panel_power_off_time = ktime_get_boottime();\n\n\tintel_bios_init_panel_late(dev_priv, &intel_connector->panel, encoder->devdata, NULL);\n\n\tmutex_lock(&dev_priv->drm.mode_config.mutex);\n\tintel_panel_add_vbt_lfp_fixed_mode(intel_connector);\n\tmutex_unlock(&dev_priv->drm.mode_config.mutex);\n\n\tif (!intel_panel_preferred_fixed_mode(intel_connector)) {\n\t\tdrm_err(&dev_priv->drm, \"DSI fixed mode info missing\\n\");\n\t\tgoto err;\n\t}\n\n\tintel_panel_init(intel_connector, NULL);\n\n\tintel_backlight_setup(intel_connector, INVALID_PIPE);\n\n\tif (intel_connector->panel.vbt.dsi.config->dual_link)\n\t\tintel_dsi->ports = BIT(PORT_A) | BIT(PORT_B);\n\telse\n\t\tintel_dsi->ports = BIT(port);\n\n\tif (drm_WARN_ON(&dev_priv->drm, intel_connector->panel.vbt.dsi.bl_ports & ~intel_dsi->ports))\n\t\tintel_connector->panel.vbt.dsi.bl_ports &= intel_dsi->ports;\n\n\tif (drm_WARN_ON(&dev_priv->drm, intel_connector->panel.vbt.dsi.cabc_ports & ~intel_dsi->ports))\n\t\tintel_connector->panel.vbt.dsi.cabc_ports &= intel_dsi->ports;\n\n\tfor_each_dsi_port(port, intel_dsi->ports) {\n\t\tstruct intel_dsi_host *host;\n\n\t\thost = intel_dsi_host_init(intel_dsi, &gen11_dsi_host_ops, port);\n\t\tif (!host)\n\t\t\tgoto err;\n\n\t\tintel_dsi->dsi_hosts[port] = host;\n\t}\n\n\tif (!intel_dsi_vbt_init(intel_dsi, MIPI_DSI_GENERIC_PANEL_ID)) {\n\t\tdrm_dbg_kms(&dev_priv->drm, \"no device found\\n\");\n\t\tgoto err;\n\t}\n\n\ticl_dphy_param_init(intel_dsi);\n\n\ticl_dsi_add_properties(intel_connector);\n\treturn;\n\nerr:\n\tdrm_connector_cleanup(connector);\n\tdrm_encoder_cleanup(&encoder->base);\n\tkfree(intel_dsi);\n\tkfree(intel_connector);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}