{
  "module_name": "dvo_ivch.c",
  "hash_id": "4ced207bf79ea9e275dad521a54c25ff8f6d04d6c674b241331e8aa395f38336",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/i915/display/dvo_ivch.c",
  "human_readable_source": " \n\n#include \"intel_display_types.h\"\n#include \"intel_dvo_dev.h\"\n\n \n\n \n#define VR00\t\t0x00\n# define VR00_BASE_ADDRESS_MASK\t\t0x007f\n\n \n#define VR01\t\t0x01\n\n \n# define VR01_PANEL_FIT_ENABLE\t\t(1 << 3)\n \n# define VR01_LCD_ENABLE\t\t(1 << 2)\n \n# define VR01_DVO_BYPASS_ENABLE\t\t(1 << 1)\n \n# define VR01_DVO_ENABLE\t\t(1 << 0)\n \n# define VR01_DITHER_ENABLE             (1 << 4)\n\n \n#define VR10\t\t0x10\n \n# define VR10_LVDS_ENABLE\t\t(1 << 4)\n \n# define VR10_INTERFACE_1X18\t\t(0 << 2)\n \n# define VR10_INTERFACE_1X24\t\t(1 << 2)\n \n# define VR10_INTERFACE_2X18\t\t(2 << 2)\n \n# define VR10_INTERFACE_2X24\t\t(3 << 2)\n \n# define VR10_INTERFACE_DEPTH_MASK      (3 << 2)\n\n \n#define VR20\t0x20\n\n \n#define VR21\t0x21\n\n \n#define VR30\t\t0x30\n \n# define VR30_PANEL_ON\t\t\t(1 << 15)\n\n#define VR40\t\t0x40\n# define VR40_STALL_ENABLE\t\t(1 << 13)\n# define VR40_VERTICAL_INTERP_ENABLE\t(1 << 12)\n# define VR40_ENHANCED_PANEL_FITTING\t(1 << 11)\n# define VR40_HORIZONTAL_INTERP_ENABLE\t(1 << 10)\n# define VR40_AUTO_RATIO_ENABLE\t\t(1 << 9)\n# define VR40_CLOCK_GATING_ENABLE\t(1 << 8)\n\n \n#define VR41\t\t0x41\n\n \n#define VR42\t\t0x42\n\n \n#define VR43\t\t0x43\n\n \n#define VR80\t    0x80\n#define VR81\t    0x81\n#define VR82\t    0x82\n#define VR83\t    0x83\n#define VR84\t    0x84\n#define VR85\t    0x85\n#define VR86\t    0x86\n#define VR87\t    0x87\n\n \n#define VR88\t    0x88\n\n \n#define VR8E\t    0x8E\n# define VR8E_PANEL_TYPE_MASK\t\t(0xf << 0)\n# define VR8E_PANEL_INTERFACE_CMOS\t(0 << 4)\n# define VR8E_PANEL_INTERFACE_LVDS\t(1 << 4)\n# define VR8E_FORCE_DEFAULT_PANEL\t(1 << 5)\n\n \n#define VR8F\t    0x8F\n# define VR8F_VCH_PRESENT\t\t(1 << 0)\n# define VR8F_DISPLAY_CONN\t\t(1 << 1)\n# define VR8F_POWER_MASK\t\t(0x3c)\n# define VR8F_POWER_POS\t\t\t(2)\n\n \nstatic const u16 backup_addresses[] = {\n\t0x11, 0x12,\n\t0x18, 0x19, 0x1a, 0x1f,\n\t0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27,\n\t0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37,\n\t0x8e, 0x8f,\n\t0x10\t\t \n};\n\n\nstruct ivch_priv {\n\tbool quiet;\n\n\tu16 width, height;\n\n\t \n\n\tu16 reg_backup[ARRAY_SIZE(backup_addresses)];\n};\n\n\nstatic void ivch_dump_regs(struct intel_dvo_device *dvo);\n \nstatic bool ivch_read(struct intel_dvo_device *dvo, int addr, u16 *data)\n{\n\tstruct ivch_priv *priv = dvo->dev_priv;\n\tstruct i2c_adapter *adapter = dvo->i2c_bus;\n\tu8 out_buf[1];\n\tu8 in_buf[2];\n\n\tstruct i2c_msg msgs[] = {\n\t\t{\n\t\t\t.addr = dvo->slave_addr,\n\t\t\t.flags = I2C_M_RD,\n\t\t\t.len = 0,\n\t\t},\n\t\t{\n\t\t\t.addr = 0,\n\t\t\t.flags = I2C_M_NOSTART,\n\t\t\t.len = 1,\n\t\t\t.buf = out_buf,\n\t\t},\n\t\t{\n\t\t\t.addr = dvo->slave_addr,\n\t\t\t.flags = I2C_M_RD | I2C_M_NOSTART,\n\t\t\t.len = 2,\n\t\t\t.buf = in_buf,\n\t\t}\n\t};\n\n\tout_buf[0] = addr;\n\n\tif (i2c_transfer(adapter, msgs, 3) == 3) {\n\t\t*data = (in_buf[1] << 8) | in_buf[0];\n\t\treturn true;\n\t}\n\n\tif (!priv->quiet) {\n\t\tDRM_DEBUG_KMS(\"Unable to read register 0x%02x from \"\n\t\t\t\t\"%s:%02x.\\n\",\n\t\t\t  addr, adapter->name, dvo->slave_addr);\n\t}\n\treturn false;\n}\n\n \nstatic bool ivch_write(struct intel_dvo_device *dvo, int addr, u16 data)\n{\n\tstruct ivch_priv *priv = dvo->dev_priv;\n\tstruct i2c_adapter *adapter = dvo->i2c_bus;\n\tu8 out_buf[3];\n\tstruct i2c_msg msg = {\n\t\t.addr = dvo->slave_addr,\n\t\t.flags = 0,\n\t\t.len = 3,\n\t\t.buf = out_buf,\n\t};\n\n\tout_buf[0] = addr;\n\tout_buf[1] = data & 0xff;\n\tout_buf[2] = data >> 8;\n\n\tif (i2c_transfer(adapter, &msg, 1) == 1)\n\t\treturn true;\n\n\tif (!priv->quiet) {\n\t\tDRM_DEBUG_KMS(\"Unable to write register 0x%02x to %s:%d.\\n\",\n\t\t\t  addr, adapter->name, dvo->slave_addr);\n\t}\n\n\treturn false;\n}\n\n \nstatic bool ivch_init(struct intel_dvo_device *dvo,\n\t\t      struct i2c_adapter *adapter)\n{\n\tstruct ivch_priv *priv;\n\tu16 temp;\n\tint i;\n\n\tpriv = kzalloc(sizeof(struct ivch_priv), GFP_KERNEL);\n\tif (priv == NULL)\n\t\treturn false;\n\n\tdvo->i2c_bus = adapter;\n\tdvo->dev_priv = priv;\n\tpriv->quiet = true;\n\n\tif (!ivch_read(dvo, VR00, &temp))\n\t\tgoto out;\n\tpriv->quiet = false;\n\n\t \n\tif ((temp & VR00_BASE_ADDRESS_MASK) != dvo->slave_addr) {\n\t\tDRM_DEBUG_KMS(\"ivch detect failed due to address mismatch \"\n\t\t\t  \"(%d vs %d)\\n\",\n\t\t\t  (temp & VR00_BASE_ADDRESS_MASK), dvo->slave_addr);\n\t\tgoto out;\n\t}\n\n\tivch_read(dvo, VR20, &priv->width);\n\tivch_read(dvo, VR21, &priv->height);\n\n\t \n\tfor (i = 0; i < ARRAY_SIZE(backup_addresses); i++)\n\t\tivch_read(dvo, backup_addresses[i], priv->reg_backup + i);\n\n\tivch_dump_regs(dvo);\n\n\treturn true;\n\nout:\n\tkfree(priv);\n\treturn false;\n}\n\nstatic enum drm_connector_status ivch_detect(struct intel_dvo_device *dvo)\n{\n\treturn connector_status_connected;\n}\n\nstatic enum drm_mode_status ivch_mode_valid(struct intel_dvo_device *dvo,\n\t\t\t\t\t    struct drm_display_mode *mode)\n{\n\tif (mode->clock > 112000)\n\t\treturn MODE_CLOCK_HIGH;\n\n\treturn MODE_OK;\n}\n\n \nstatic void ivch_reset(struct intel_dvo_device *dvo)\n{\n\tstruct ivch_priv *priv = dvo->dev_priv;\n\tint i;\n\n\tDRM_DEBUG_KMS(\"Resetting the IVCH registers\\n\");\n\n\tivch_write(dvo, VR10, 0x0000);\n\n\tfor (i = 0; i < ARRAY_SIZE(backup_addresses); i++)\n\t\tivch_write(dvo, backup_addresses[i], priv->reg_backup[i]);\n}\n\n \nstatic void ivch_dpms(struct intel_dvo_device *dvo, bool enable)\n{\n\tint i;\n\tu16 vr01, vr30, backlight;\n\n\tivch_reset(dvo);\n\n\t \n\tif (!ivch_read(dvo, VR01, &vr01))\n\t\treturn;\n\n\tif (enable)\n\t\tbacklight = 1;\n\telse\n\t\tbacklight = 0;\n\n\tivch_write(dvo, VR80, backlight);\n\n\tif (enable)\n\t\tvr01 |= VR01_LCD_ENABLE | VR01_DVO_ENABLE;\n\telse\n\t\tvr01 &= ~(VR01_LCD_ENABLE | VR01_DVO_ENABLE);\n\n\tivch_write(dvo, VR01, vr01);\n\n\t \n\tfor (i = 0; i < 100; i++) {\n\t\tif (!ivch_read(dvo, VR30, &vr30))\n\t\t\tbreak;\n\n\t\tif (((vr30 & VR30_PANEL_ON) != 0) == enable)\n\t\t\tbreak;\n\t\tudelay(1000);\n\t}\n\t \n\tudelay(16 * 1000);\n}\n\nstatic bool ivch_get_hw_state(struct intel_dvo_device *dvo)\n{\n\tu16 vr01;\n\n\tivch_reset(dvo);\n\n\t \n\tif (!ivch_read(dvo, VR01, &vr01))\n\t\treturn false;\n\n\tif (vr01 & VR01_LCD_ENABLE)\n\t\treturn true;\n\telse\n\t\treturn false;\n}\n\nstatic void ivch_mode_set(struct intel_dvo_device *dvo,\n\t\t\t  const struct drm_display_mode *mode,\n\t\t\t  const struct drm_display_mode *adjusted_mode)\n{\n\tstruct ivch_priv *priv = dvo->dev_priv;\n\tu16 vr40 = 0;\n\tu16 vr01 = 0;\n\tu16 vr10;\n\n\tivch_reset(dvo);\n\n\tvr10 = priv->reg_backup[ARRAY_SIZE(backup_addresses) - 1];\n\n\t \n\tvr10 &= VR10_INTERFACE_DEPTH_MASK;\n\tif (vr10 == VR10_INTERFACE_2X18 || vr10 == VR10_INTERFACE_1X18)\n\t\tvr01 = VR01_DITHER_ENABLE;\n\n\tvr40 = (VR40_STALL_ENABLE | VR40_VERTICAL_INTERP_ENABLE |\n\t\tVR40_HORIZONTAL_INTERP_ENABLE);\n\n\tif (mode->hdisplay != adjusted_mode->crtc_hdisplay ||\n\t    mode->vdisplay != adjusted_mode->crtc_vdisplay) {\n\t\tu16 x_ratio, y_ratio;\n\n\t\tvr01 |= VR01_PANEL_FIT_ENABLE;\n\t\tvr40 |= VR40_CLOCK_GATING_ENABLE;\n\t\tx_ratio = (((mode->hdisplay - 1) << 16) /\n\t\t\t   (adjusted_mode->crtc_hdisplay - 1)) >> 2;\n\t\ty_ratio = (((mode->vdisplay - 1) << 16) /\n\t\t\t   (adjusted_mode->crtc_vdisplay - 1)) >> 2;\n\t\tivch_write(dvo, VR42, x_ratio);\n\t\tivch_write(dvo, VR41, y_ratio);\n\t} else {\n\t\tvr01 &= ~VR01_PANEL_FIT_ENABLE;\n\t\tvr40 &= ~VR40_CLOCK_GATING_ENABLE;\n\t}\n\tvr40 &= ~VR40_AUTO_RATIO_ENABLE;\n\n\tivch_write(dvo, VR01, vr01);\n\tivch_write(dvo, VR40, vr40);\n}\n\nstatic void ivch_dump_regs(struct intel_dvo_device *dvo)\n{\n\tu16 val;\n\n\tivch_read(dvo, VR00, &val);\n\tDRM_DEBUG_KMS(\"VR00: 0x%04x\\n\", val);\n\tivch_read(dvo, VR01, &val);\n\tDRM_DEBUG_KMS(\"VR01: 0x%04x\\n\", val);\n\tivch_read(dvo, VR10, &val);\n\tDRM_DEBUG_KMS(\"VR10: 0x%04x\\n\", val);\n\tivch_read(dvo, VR30, &val);\n\tDRM_DEBUG_KMS(\"VR30: 0x%04x\\n\", val);\n\tivch_read(dvo, VR40, &val);\n\tDRM_DEBUG_KMS(\"VR40: 0x%04x\\n\", val);\n\n\t \n\tivch_read(dvo, VR80, &val);\n\tDRM_DEBUG_KMS(\"VR80: 0x%04x\\n\", val);\n\tivch_read(dvo, VR81, &val);\n\tDRM_DEBUG_KMS(\"VR81: 0x%04x\\n\", val);\n\tivch_read(dvo, VR82, &val);\n\tDRM_DEBUG_KMS(\"VR82: 0x%04x\\n\", val);\n\tivch_read(dvo, VR83, &val);\n\tDRM_DEBUG_KMS(\"VR83: 0x%04x\\n\", val);\n\tivch_read(dvo, VR84, &val);\n\tDRM_DEBUG_KMS(\"VR84: 0x%04x\\n\", val);\n\tivch_read(dvo, VR85, &val);\n\tDRM_DEBUG_KMS(\"VR85: 0x%04x\\n\", val);\n\tivch_read(dvo, VR86, &val);\n\tDRM_DEBUG_KMS(\"VR86: 0x%04x\\n\", val);\n\tivch_read(dvo, VR87, &val);\n\tDRM_DEBUG_KMS(\"VR87: 0x%04x\\n\", val);\n\tivch_read(dvo, VR88, &val);\n\tDRM_DEBUG_KMS(\"VR88: 0x%04x\\n\", val);\n\n\t \n\tivch_read(dvo, VR8E, &val);\n\tDRM_DEBUG_KMS(\"VR8E: 0x%04x\\n\", val);\n\n\t \n\tivch_read(dvo, VR8F, &val);\n\tDRM_DEBUG_KMS(\"VR8F: 0x%04x\\n\", val);\n}\n\nstatic void ivch_destroy(struct intel_dvo_device *dvo)\n{\n\tstruct ivch_priv *priv = dvo->dev_priv;\n\n\tif (priv) {\n\t\tkfree(priv);\n\t\tdvo->dev_priv = NULL;\n\t}\n}\n\nconst struct intel_dvo_dev_ops ivch_ops = {\n\t.init = ivch_init,\n\t.dpms = ivch_dpms,\n\t.get_hw_state = ivch_get_hw_state,\n\t.mode_valid = ivch_mode_valid,\n\t.mode_set = ivch_mode_set,\n\t.detect = ivch_detect,\n\t.dump_regs = ivch_dump_regs,\n\t.destroy = ivch_destroy,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}