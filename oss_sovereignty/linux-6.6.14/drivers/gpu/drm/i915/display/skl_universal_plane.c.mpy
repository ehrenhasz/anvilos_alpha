{
  "module_name": "skl_universal_plane.c",
  "hash_id": "6f9f41c8d736d558fc8e9712c0a876ea4d97473815e42803b3e93beda5a40b9b",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/i915/display/skl_universal_plane.c",
  "human_readable_source": "\n \n\n#include <drm/drm_atomic_helper.h>\n#include <drm/drm_blend.h>\n#include <drm/drm_damage_helper.h>\n#include <drm/drm_fourcc.h>\n\n#include \"i915_drv.h\"\n#include \"i915_reg.h\"\n#include \"intel_atomic_plane.h\"\n#include \"intel_de.h\"\n#include \"intel_display_irq.h\"\n#include \"intel_display_types.h\"\n#include \"intel_fb.h\"\n#include \"intel_fbc.h\"\n#include \"intel_psr.h\"\n#include \"skl_scaler.h\"\n#include \"skl_universal_plane.h\"\n#include \"skl_watermark.h\"\n#include \"pxp/intel_pxp.h\"\n\nstatic const u32 skl_plane_formats[] = {\n\tDRM_FORMAT_C8,\n\tDRM_FORMAT_RGB565,\n\tDRM_FORMAT_XRGB8888,\n\tDRM_FORMAT_XBGR8888,\n\tDRM_FORMAT_ARGB8888,\n\tDRM_FORMAT_ABGR8888,\n\tDRM_FORMAT_XRGB2101010,\n\tDRM_FORMAT_XBGR2101010,\n\tDRM_FORMAT_XRGB16161616F,\n\tDRM_FORMAT_XBGR16161616F,\n\tDRM_FORMAT_YUYV,\n\tDRM_FORMAT_YVYU,\n\tDRM_FORMAT_UYVY,\n\tDRM_FORMAT_VYUY,\n\tDRM_FORMAT_XYUV8888,\n};\n\nstatic const u32 skl_planar_formats[] = {\n\tDRM_FORMAT_C8,\n\tDRM_FORMAT_RGB565,\n\tDRM_FORMAT_XRGB8888,\n\tDRM_FORMAT_XBGR8888,\n\tDRM_FORMAT_ARGB8888,\n\tDRM_FORMAT_ABGR8888,\n\tDRM_FORMAT_XRGB2101010,\n\tDRM_FORMAT_XBGR2101010,\n\tDRM_FORMAT_XRGB16161616F,\n\tDRM_FORMAT_XBGR16161616F,\n\tDRM_FORMAT_YUYV,\n\tDRM_FORMAT_YVYU,\n\tDRM_FORMAT_UYVY,\n\tDRM_FORMAT_VYUY,\n\tDRM_FORMAT_NV12,\n\tDRM_FORMAT_XYUV8888,\n};\n\nstatic const u32 glk_planar_formats[] = {\n\tDRM_FORMAT_C8,\n\tDRM_FORMAT_RGB565,\n\tDRM_FORMAT_XRGB8888,\n\tDRM_FORMAT_XBGR8888,\n\tDRM_FORMAT_ARGB8888,\n\tDRM_FORMAT_ABGR8888,\n\tDRM_FORMAT_XRGB2101010,\n\tDRM_FORMAT_XBGR2101010,\n\tDRM_FORMAT_XRGB16161616F,\n\tDRM_FORMAT_XBGR16161616F,\n\tDRM_FORMAT_YUYV,\n\tDRM_FORMAT_YVYU,\n\tDRM_FORMAT_UYVY,\n\tDRM_FORMAT_VYUY,\n\tDRM_FORMAT_NV12,\n\tDRM_FORMAT_XYUV8888,\n\tDRM_FORMAT_P010,\n\tDRM_FORMAT_P012,\n\tDRM_FORMAT_P016,\n};\n\nstatic const u32 icl_sdr_y_plane_formats[] = {\n\tDRM_FORMAT_C8,\n\tDRM_FORMAT_RGB565,\n\tDRM_FORMAT_XRGB8888,\n\tDRM_FORMAT_XBGR8888,\n\tDRM_FORMAT_ARGB8888,\n\tDRM_FORMAT_ABGR8888,\n\tDRM_FORMAT_XRGB2101010,\n\tDRM_FORMAT_XBGR2101010,\n\tDRM_FORMAT_ARGB2101010,\n\tDRM_FORMAT_ABGR2101010,\n\tDRM_FORMAT_YUYV,\n\tDRM_FORMAT_YVYU,\n\tDRM_FORMAT_UYVY,\n\tDRM_FORMAT_VYUY,\n\tDRM_FORMAT_Y210,\n\tDRM_FORMAT_Y212,\n\tDRM_FORMAT_Y216,\n\tDRM_FORMAT_XYUV8888,\n\tDRM_FORMAT_XVYU2101010,\n\tDRM_FORMAT_XVYU12_16161616,\n\tDRM_FORMAT_XVYU16161616,\n};\n\nstatic const u32 icl_sdr_uv_plane_formats[] = {\n\tDRM_FORMAT_C8,\n\tDRM_FORMAT_RGB565,\n\tDRM_FORMAT_XRGB8888,\n\tDRM_FORMAT_XBGR8888,\n\tDRM_FORMAT_ARGB8888,\n\tDRM_FORMAT_ABGR8888,\n\tDRM_FORMAT_XRGB2101010,\n\tDRM_FORMAT_XBGR2101010,\n\tDRM_FORMAT_ARGB2101010,\n\tDRM_FORMAT_ABGR2101010,\n\tDRM_FORMAT_YUYV,\n\tDRM_FORMAT_YVYU,\n\tDRM_FORMAT_UYVY,\n\tDRM_FORMAT_VYUY,\n\tDRM_FORMAT_NV12,\n\tDRM_FORMAT_P010,\n\tDRM_FORMAT_P012,\n\tDRM_FORMAT_P016,\n\tDRM_FORMAT_Y210,\n\tDRM_FORMAT_Y212,\n\tDRM_FORMAT_Y216,\n\tDRM_FORMAT_XYUV8888,\n\tDRM_FORMAT_XVYU2101010,\n\tDRM_FORMAT_XVYU12_16161616,\n\tDRM_FORMAT_XVYU16161616,\n};\n\nstatic const u32 icl_hdr_plane_formats[] = {\n\tDRM_FORMAT_C8,\n\tDRM_FORMAT_RGB565,\n\tDRM_FORMAT_XRGB8888,\n\tDRM_FORMAT_XBGR8888,\n\tDRM_FORMAT_ARGB8888,\n\tDRM_FORMAT_ABGR8888,\n\tDRM_FORMAT_XRGB2101010,\n\tDRM_FORMAT_XBGR2101010,\n\tDRM_FORMAT_ARGB2101010,\n\tDRM_FORMAT_ABGR2101010,\n\tDRM_FORMAT_XRGB16161616F,\n\tDRM_FORMAT_XBGR16161616F,\n\tDRM_FORMAT_ARGB16161616F,\n\tDRM_FORMAT_ABGR16161616F,\n\tDRM_FORMAT_YUYV,\n\tDRM_FORMAT_YVYU,\n\tDRM_FORMAT_UYVY,\n\tDRM_FORMAT_VYUY,\n\tDRM_FORMAT_NV12,\n\tDRM_FORMAT_P010,\n\tDRM_FORMAT_P012,\n\tDRM_FORMAT_P016,\n\tDRM_FORMAT_Y210,\n\tDRM_FORMAT_Y212,\n\tDRM_FORMAT_Y216,\n\tDRM_FORMAT_XYUV8888,\n\tDRM_FORMAT_XVYU2101010,\n\tDRM_FORMAT_XVYU12_16161616,\n\tDRM_FORMAT_XVYU16161616,\n};\n\nint skl_format_to_fourcc(int format, bool rgb_order, bool alpha)\n{\n\tswitch (format) {\n\tcase PLANE_CTL_FORMAT_RGB_565:\n\t\treturn DRM_FORMAT_RGB565;\n\tcase PLANE_CTL_FORMAT_NV12:\n\t\treturn DRM_FORMAT_NV12;\n\tcase PLANE_CTL_FORMAT_XYUV:\n\t\treturn DRM_FORMAT_XYUV8888;\n\tcase PLANE_CTL_FORMAT_P010:\n\t\treturn DRM_FORMAT_P010;\n\tcase PLANE_CTL_FORMAT_P012:\n\t\treturn DRM_FORMAT_P012;\n\tcase PLANE_CTL_FORMAT_P016:\n\t\treturn DRM_FORMAT_P016;\n\tcase PLANE_CTL_FORMAT_Y210:\n\t\treturn DRM_FORMAT_Y210;\n\tcase PLANE_CTL_FORMAT_Y212:\n\t\treturn DRM_FORMAT_Y212;\n\tcase PLANE_CTL_FORMAT_Y216:\n\t\treturn DRM_FORMAT_Y216;\n\tcase PLANE_CTL_FORMAT_Y410:\n\t\treturn DRM_FORMAT_XVYU2101010;\n\tcase PLANE_CTL_FORMAT_Y412:\n\t\treturn DRM_FORMAT_XVYU12_16161616;\n\tcase PLANE_CTL_FORMAT_Y416:\n\t\treturn DRM_FORMAT_XVYU16161616;\n\tdefault:\n\tcase PLANE_CTL_FORMAT_XRGB_8888:\n\t\tif (rgb_order) {\n\t\t\tif (alpha)\n\t\t\t\treturn DRM_FORMAT_ABGR8888;\n\t\t\telse\n\t\t\t\treturn DRM_FORMAT_XBGR8888;\n\t\t} else {\n\t\t\tif (alpha)\n\t\t\t\treturn DRM_FORMAT_ARGB8888;\n\t\t\telse\n\t\t\t\treturn DRM_FORMAT_XRGB8888;\n\t\t}\n\tcase PLANE_CTL_FORMAT_XRGB_2101010:\n\t\tif (rgb_order) {\n\t\t\tif (alpha)\n\t\t\t\treturn DRM_FORMAT_ABGR2101010;\n\t\t\telse\n\t\t\t\treturn DRM_FORMAT_XBGR2101010;\n\t\t} else {\n\t\t\tif (alpha)\n\t\t\t\treturn DRM_FORMAT_ARGB2101010;\n\t\t\telse\n\t\t\t\treturn DRM_FORMAT_XRGB2101010;\n\t\t}\n\tcase PLANE_CTL_FORMAT_XRGB_16161616F:\n\t\tif (rgb_order) {\n\t\t\tif (alpha)\n\t\t\t\treturn DRM_FORMAT_ABGR16161616F;\n\t\t\telse\n\t\t\t\treturn DRM_FORMAT_XBGR16161616F;\n\t\t} else {\n\t\t\tif (alpha)\n\t\t\t\treturn DRM_FORMAT_ARGB16161616F;\n\t\t\telse\n\t\t\t\treturn DRM_FORMAT_XRGB16161616F;\n\t\t}\n\t}\n}\n\nstatic u8 icl_nv12_y_plane_mask(struct drm_i915_private *i915)\n{\n\tif (DISPLAY_VER(i915) >= 13 || HAS_D12_PLANE_MINIMIZATION(i915))\n\t\treturn BIT(PLANE_SPRITE2) | BIT(PLANE_SPRITE3);\n\telse\n\t\treturn BIT(PLANE_SPRITE4) | BIT(PLANE_SPRITE5);\n}\n\nbool icl_is_nv12_y_plane(struct drm_i915_private *dev_priv,\n\t\t\t enum plane_id plane_id)\n{\n\treturn DISPLAY_VER(dev_priv) >= 11 &&\n\t\ticl_nv12_y_plane_mask(dev_priv) & BIT(plane_id);\n}\n\nu8 icl_hdr_plane_mask(void)\n{\n\treturn BIT(PLANE_PRIMARY) | BIT(PLANE_SPRITE0) | BIT(PLANE_SPRITE1);\n}\n\nbool icl_is_hdr_plane(struct drm_i915_private *dev_priv, enum plane_id plane_id)\n{\n\treturn DISPLAY_VER(dev_priv) >= 11 &&\n\t\ticl_hdr_plane_mask() & BIT(plane_id);\n}\n\nstatic int icl_plane_min_cdclk(const struct intel_crtc_state *crtc_state,\n\t\t\t       const struct intel_plane_state *plane_state)\n{\n\tunsigned int pixel_rate = intel_plane_pixel_rate(crtc_state, plane_state);\n\n\t \n\treturn DIV_ROUND_UP(pixel_rate, 2);\n}\n\nstatic void\nglk_plane_ratio(const struct intel_plane_state *plane_state,\n\t\tunsigned int *num, unsigned int *den)\n{\n\tconst struct drm_framebuffer *fb = plane_state->hw.fb;\n\n\tif (fb->format->cpp[0] == 8) {\n\t\t*num = 10;\n\t\t*den = 8;\n\t} else {\n\t\t*num = 1;\n\t\t*den = 1;\n\t}\n}\n\nstatic int glk_plane_min_cdclk(const struct intel_crtc_state *crtc_state,\n\t\t\t       const struct intel_plane_state *plane_state)\n{\n\tunsigned int pixel_rate = intel_plane_pixel_rate(crtc_state, plane_state);\n\tunsigned int num, den;\n\n\tglk_plane_ratio(plane_state, &num, &den);\n\n\t \n\treturn DIV_ROUND_UP(pixel_rate * num, 2 * den);\n}\n\nstatic void\nskl_plane_ratio(const struct intel_plane_state *plane_state,\n\t\tunsigned int *num, unsigned int *den)\n{\n\tconst struct drm_framebuffer *fb = plane_state->hw.fb;\n\n\tif (fb->format->cpp[0] == 8) {\n\t\t*num = 9;\n\t\t*den = 8;\n\t} else {\n\t\t*num = 1;\n\t\t*den = 1;\n\t}\n}\n\nstatic int skl_plane_min_cdclk(const struct intel_crtc_state *crtc_state,\n\t\t\t       const struct intel_plane_state *plane_state)\n{\n\tunsigned int pixel_rate = intel_plane_pixel_rate(crtc_state, plane_state);\n\tunsigned int num, den;\n\n\tskl_plane_ratio(plane_state, &num, &den);\n\n\treturn DIV_ROUND_UP(pixel_rate * num, den);\n}\n\nstatic int skl_plane_max_width(const struct drm_framebuffer *fb,\n\t\t\t       int color_plane,\n\t\t\t       unsigned int rotation)\n{\n\tint cpp = fb->format->cpp[color_plane];\n\n\tswitch (fb->modifier) {\n\tcase DRM_FORMAT_MOD_LINEAR:\n\tcase I915_FORMAT_MOD_X_TILED:\n\t\t \n\t\tif (cpp == 8)\n\t\t\treturn 4096;\n\t\telse\n\t\t\treturn 5120;\n\tcase I915_FORMAT_MOD_Y_TILED_CCS:\n\tcase I915_FORMAT_MOD_Yf_TILED_CCS:\n\tcase I915_FORMAT_MOD_Y_TILED_GEN12_MC_CCS:\n\t\t \n\tcase I915_FORMAT_MOD_Y_TILED:\n\tcase I915_FORMAT_MOD_Yf_TILED:\n\t\tif (cpp == 8)\n\t\t\treturn 2048;\n\t\telse\n\t\t\treturn 4096;\n\tdefault:\n\t\tMISSING_CASE(fb->modifier);\n\t\treturn 2048;\n\t}\n}\n\nstatic int glk_plane_max_width(const struct drm_framebuffer *fb,\n\t\t\t       int color_plane,\n\t\t\t       unsigned int rotation)\n{\n\tint cpp = fb->format->cpp[color_plane];\n\n\tswitch (fb->modifier) {\n\tcase DRM_FORMAT_MOD_LINEAR:\n\tcase I915_FORMAT_MOD_X_TILED:\n\t\tif (cpp == 8)\n\t\t\treturn 4096;\n\t\telse\n\t\t\treturn 5120;\n\tcase I915_FORMAT_MOD_Y_TILED_CCS:\n\tcase I915_FORMAT_MOD_Yf_TILED_CCS:\n\t\t \n\tcase I915_FORMAT_MOD_Y_TILED:\n\tcase I915_FORMAT_MOD_Yf_TILED:\n\t\tif (cpp == 8)\n\t\t\treturn 2048;\n\t\telse\n\t\t\treturn 5120;\n\tdefault:\n\t\tMISSING_CASE(fb->modifier);\n\t\treturn 2048;\n\t}\n}\n\nstatic int icl_plane_min_width(const struct drm_framebuffer *fb,\n\t\t\t       int color_plane,\n\t\t\t       unsigned int rotation)\n{\n\t \n\tswitch (fb->format->format) {\n\tcase DRM_FORMAT_C8:\n\t\treturn 18;\n\tcase DRM_FORMAT_RGB565:\n\t\treturn 10;\n\tcase DRM_FORMAT_XRGB8888:\n\tcase DRM_FORMAT_XBGR8888:\n\tcase DRM_FORMAT_ARGB8888:\n\tcase DRM_FORMAT_ABGR8888:\n\tcase DRM_FORMAT_XRGB2101010:\n\tcase DRM_FORMAT_XBGR2101010:\n\tcase DRM_FORMAT_ARGB2101010:\n\tcase DRM_FORMAT_ABGR2101010:\n\tcase DRM_FORMAT_XVYU2101010:\n\tcase DRM_FORMAT_Y212:\n\tcase DRM_FORMAT_Y216:\n\t\treturn 6;\n\tcase DRM_FORMAT_NV12:\n\t\treturn 20;\n\tcase DRM_FORMAT_P010:\n\tcase DRM_FORMAT_P012:\n\tcase DRM_FORMAT_P016:\n\t\treturn 12;\n\tcase DRM_FORMAT_XRGB16161616F:\n\tcase DRM_FORMAT_XBGR16161616F:\n\tcase DRM_FORMAT_ARGB16161616F:\n\tcase DRM_FORMAT_ABGR16161616F:\n\tcase DRM_FORMAT_XVYU12_16161616:\n\tcase DRM_FORMAT_XVYU16161616:\n\t\treturn 4;\n\tdefault:\n\t\treturn 1;\n\t}\n}\n\nstatic int icl_hdr_plane_max_width(const struct drm_framebuffer *fb,\n\t\t\t\t   int color_plane,\n\t\t\t\t   unsigned int rotation)\n{\n\tif (intel_format_info_is_yuv_semiplanar(fb->format, fb->modifier))\n\t\treturn 4096;\n\telse\n\t\treturn 5120;\n}\n\nstatic int icl_sdr_plane_max_width(const struct drm_framebuffer *fb,\n\t\t\t\t   int color_plane,\n\t\t\t\t   unsigned int rotation)\n{\n\treturn 5120;\n}\n\nstatic int skl_plane_max_height(const struct drm_framebuffer *fb,\n\t\t\t\tint color_plane,\n\t\t\t\tunsigned int rotation)\n{\n\treturn 4096;\n}\n\nstatic int icl_plane_max_height(const struct drm_framebuffer *fb,\n\t\t\t\tint color_plane,\n\t\t\t\tunsigned int rotation)\n{\n\treturn 4320;\n}\n\nstatic unsigned int\nskl_plane_max_stride(struct intel_plane *plane,\n\t\t     u32 pixel_format, u64 modifier,\n\t\t     unsigned int rotation)\n{\n\tstruct drm_i915_private *i915 = to_i915(plane->base.dev);\n\tconst struct drm_format_info *info = drm_format_info(pixel_format);\n\tint cpp = info->cpp[0];\n\tint max_horizontal_pixels = 8192;\n\tint max_stride_bytes;\n\n\tif (DISPLAY_VER(i915) >= 13) {\n\t\t \n\t\tmax_stride_bytes = 131072;\n\t\tif (cpp == 8)\n\t\t\tmax_horizontal_pixels = 16384;\n\t\telse\n\t\t\tmax_horizontal_pixels = 65536;\n\t} else {\n\t\t \n\t\tmax_stride_bytes = 32768;\n\t}\n\n\tif (drm_rotation_90_or_270(rotation))\n\t\treturn min(max_horizontal_pixels, max_stride_bytes / cpp);\n\telse\n\t\treturn min(max_horizontal_pixels * cpp, max_stride_bytes);\n}\n\n\n \n#define PREOFF_YUV_TO_RGB_HI\t\t0x1800\n#define PREOFF_YUV_TO_RGB_ME\t\t0x0000\n#define PREOFF_YUV_TO_RGB_LO\t\t0x1800\n\n#define  ROFF(x)          (((x) & 0xffff) << 16)\n#define  GOFF(x)          (((x) & 0xffff) << 0)\n#define  BOFF(x)          (((x) & 0xffff) << 16)\n\n \nstatic void\nicl_program_input_csc(struct intel_plane *plane,\n\t\t      const struct intel_crtc_state *crtc_state,\n\t\t      const struct intel_plane_state *plane_state)\n{\n\tstruct drm_i915_private *dev_priv = to_i915(plane->base.dev);\n\tenum pipe pipe = plane->pipe;\n\tenum plane_id plane_id = plane->id;\n\n\tstatic const u16 input_csc_matrix[][9] = {\n\t\t \n\t\t[DRM_COLOR_YCBCR_BT601] = {\n\t\t\t0x7AF8, 0x7800, 0x0,\n\t\t\t0x8B28, 0x7800, 0x9AC0,\n\t\t\t0x0, 0x7800, 0x7DD8,\n\t\t},\n\t\t \n\t\t[DRM_COLOR_YCBCR_BT709] = {\n\t\t\t0x7C98, 0x7800, 0x0,\n\t\t\t0x9EF8, 0x7800, 0xAC00,\n\t\t\t0x0, 0x7800,  0x7ED8,\n\t\t},\n\t\t \n\t\t[DRM_COLOR_YCBCR_BT2020] = {\n\t\t\t0x7BC8, 0x7800, 0x0,\n\t\t\t0x8928, 0x7800, 0xAA88,\n\t\t\t0x0, 0x7800, 0x7F10,\n\t\t},\n\t};\n\tconst u16 *csc = input_csc_matrix[plane_state->hw.color_encoding];\n\n\tintel_de_write_fw(dev_priv, PLANE_INPUT_CSC_COEFF(pipe, plane_id, 0),\n\t\t\t  ROFF(csc[0]) | GOFF(csc[1]));\n\tintel_de_write_fw(dev_priv, PLANE_INPUT_CSC_COEFF(pipe, plane_id, 1),\n\t\t\t  BOFF(csc[2]));\n\tintel_de_write_fw(dev_priv, PLANE_INPUT_CSC_COEFF(pipe, plane_id, 2),\n\t\t\t  ROFF(csc[3]) | GOFF(csc[4]));\n\tintel_de_write_fw(dev_priv, PLANE_INPUT_CSC_COEFF(pipe, plane_id, 3),\n\t\t\t  BOFF(csc[5]));\n\tintel_de_write_fw(dev_priv, PLANE_INPUT_CSC_COEFF(pipe, plane_id, 4),\n\t\t\t  ROFF(csc[6]) | GOFF(csc[7]));\n\tintel_de_write_fw(dev_priv, PLANE_INPUT_CSC_COEFF(pipe, plane_id, 5),\n\t\t\t  BOFF(csc[8]));\n\n\tintel_de_write_fw(dev_priv, PLANE_INPUT_CSC_PREOFF(pipe, plane_id, 0),\n\t\t\t  PREOFF_YUV_TO_RGB_HI);\n\tintel_de_write_fw(dev_priv, PLANE_INPUT_CSC_PREOFF(pipe, plane_id, 1),\n\t\t\t  PREOFF_YUV_TO_RGB_ME);\n\tintel_de_write_fw(dev_priv, PLANE_INPUT_CSC_PREOFF(pipe, plane_id, 2),\n\t\t\t  PREOFF_YUV_TO_RGB_LO);\n\tintel_de_write_fw(dev_priv,\n\t\t\t  PLANE_INPUT_CSC_POSTOFF(pipe, plane_id, 0), 0x0);\n\tintel_de_write_fw(dev_priv,\n\t\t\t  PLANE_INPUT_CSC_POSTOFF(pipe, plane_id, 1), 0x0);\n\tintel_de_write_fw(dev_priv,\n\t\t\t  PLANE_INPUT_CSC_POSTOFF(pipe, plane_id, 2), 0x0);\n}\n\nstatic unsigned int skl_plane_stride_mult(const struct drm_framebuffer *fb,\n\t\t\t\t\t  int color_plane, unsigned int rotation)\n{\n\t \n\tif (is_surface_linear(fb, color_plane))\n\t\treturn 64;\n\telse if (drm_rotation_90_or_270(rotation))\n\t\treturn intel_tile_height(fb, color_plane);\n\telse\n\t\treturn intel_tile_width_bytes(fb, color_plane);\n}\n\nstatic u32 skl_plane_stride(const struct intel_plane_state *plane_state,\n\t\t\t    int color_plane)\n{\n\tconst struct drm_framebuffer *fb = plane_state->hw.fb;\n\tunsigned int rotation = plane_state->hw.rotation;\n\tu32 stride = plane_state->view.color_plane[color_plane].scanout_stride;\n\n\tif (color_plane >= fb->format->num_planes)\n\t\treturn 0;\n\n\treturn stride / skl_plane_stride_mult(fb, color_plane, rotation);\n}\n\nstatic void\nskl_plane_disable_arm(struct intel_plane *plane,\n\t\t      const struct intel_crtc_state *crtc_state)\n{\n\tstruct drm_i915_private *dev_priv = to_i915(plane->base.dev);\n\tenum plane_id plane_id = plane->id;\n\tenum pipe pipe = plane->pipe;\n\n\tskl_write_plane_wm(plane, crtc_state);\n\n\tintel_de_write_fw(dev_priv, PLANE_CTL(pipe, plane_id), 0);\n\tintel_de_write_fw(dev_priv, PLANE_SURF(pipe, plane_id), 0);\n}\n\nstatic void\nicl_plane_disable_arm(struct intel_plane *plane,\n\t\t      const struct intel_crtc_state *crtc_state)\n{\n\tstruct drm_i915_private *dev_priv = to_i915(plane->base.dev);\n\tenum plane_id plane_id = plane->id;\n\tenum pipe pipe = plane->pipe;\n\n\tif (icl_is_hdr_plane(dev_priv, plane_id))\n\t\tintel_de_write_fw(dev_priv, PLANE_CUS_CTL(pipe, plane_id), 0);\n\n\tskl_write_plane_wm(plane, crtc_state);\n\n\tintel_psr2_disable_plane_sel_fetch_arm(plane, crtc_state);\n\tintel_de_write_fw(dev_priv, PLANE_CTL(pipe, plane_id), 0);\n\tintel_de_write_fw(dev_priv, PLANE_SURF(pipe, plane_id), 0);\n}\n\nstatic bool\nskl_plane_get_hw_state(struct intel_plane *plane,\n\t\t       enum pipe *pipe)\n{\n\tstruct drm_i915_private *dev_priv = to_i915(plane->base.dev);\n\tenum intel_display_power_domain power_domain;\n\tenum plane_id plane_id = plane->id;\n\tintel_wakeref_t wakeref;\n\tbool ret;\n\n\tpower_domain = POWER_DOMAIN_PIPE(plane->pipe);\n\twakeref = intel_display_power_get_if_enabled(dev_priv, power_domain);\n\tif (!wakeref)\n\t\treturn false;\n\n\tret = intel_de_read(dev_priv, PLANE_CTL(plane->pipe, plane_id)) & PLANE_CTL_ENABLE;\n\n\t*pipe = plane->pipe;\n\n\tintel_display_power_put(dev_priv, power_domain, wakeref);\n\n\treturn ret;\n}\n\nstatic u32 skl_plane_ctl_format(u32 pixel_format)\n{\n\tswitch (pixel_format) {\n\tcase DRM_FORMAT_C8:\n\t\treturn PLANE_CTL_FORMAT_INDEXED;\n\tcase DRM_FORMAT_RGB565:\n\t\treturn PLANE_CTL_FORMAT_RGB_565;\n\tcase DRM_FORMAT_XBGR8888:\n\tcase DRM_FORMAT_ABGR8888:\n\t\treturn PLANE_CTL_FORMAT_XRGB_8888 | PLANE_CTL_ORDER_RGBX;\n\tcase DRM_FORMAT_XRGB8888:\n\tcase DRM_FORMAT_ARGB8888:\n\t\treturn PLANE_CTL_FORMAT_XRGB_8888;\n\tcase DRM_FORMAT_XBGR2101010:\n\tcase DRM_FORMAT_ABGR2101010:\n\t\treturn PLANE_CTL_FORMAT_XRGB_2101010 | PLANE_CTL_ORDER_RGBX;\n\tcase DRM_FORMAT_XRGB2101010:\n\tcase DRM_FORMAT_ARGB2101010:\n\t\treturn PLANE_CTL_FORMAT_XRGB_2101010;\n\tcase DRM_FORMAT_XBGR16161616F:\n\tcase DRM_FORMAT_ABGR16161616F:\n\t\treturn PLANE_CTL_FORMAT_XRGB_16161616F | PLANE_CTL_ORDER_RGBX;\n\tcase DRM_FORMAT_XRGB16161616F:\n\tcase DRM_FORMAT_ARGB16161616F:\n\t\treturn PLANE_CTL_FORMAT_XRGB_16161616F;\n\tcase DRM_FORMAT_XYUV8888:\n\t\treturn PLANE_CTL_FORMAT_XYUV;\n\tcase DRM_FORMAT_YUYV:\n\t\treturn PLANE_CTL_FORMAT_YUV422 | PLANE_CTL_YUV422_ORDER_YUYV;\n\tcase DRM_FORMAT_YVYU:\n\t\treturn PLANE_CTL_FORMAT_YUV422 | PLANE_CTL_YUV422_ORDER_YVYU;\n\tcase DRM_FORMAT_UYVY:\n\t\treturn PLANE_CTL_FORMAT_YUV422 | PLANE_CTL_YUV422_ORDER_UYVY;\n\tcase DRM_FORMAT_VYUY:\n\t\treturn PLANE_CTL_FORMAT_YUV422 | PLANE_CTL_YUV422_ORDER_VYUY;\n\tcase DRM_FORMAT_NV12:\n\t\treturn PLANE_CTL_FORMAT_NV12;\n\tcase DRM_FORMAT_P010:\n\t\treturn PLANE_CTL_FORMAT_P010;\n\tcase DRM_FORMAT_P012:\n\t\treturn PLANE_CTL_FORMAT_P012;\n\tcase DRM_FORMAT_P016:\n\t\treturn PLANE_CTL_FORMAT_P016;\n\tcase DRM_FORMAT_Y210:\n\t\treturn PLANE_CTL_FORMAT_Y210;\n\tcase DRM_FORMAT_Y212:\n\t\treturn PLANE_CTL_FORMAT_Y212;\n\tcase DRM_FORMAT_Y216:\n\t\treturn PLANE_CTL_FORMAT_Y216;\n\tcase DRM_FORMAT_XVYU2101010:\n\t\treturn PLANE_CTL_FORMAT_Y410;\n\tcase DRM_FORMAT_XVYU12_16161616:\n\t\treturn PLANE_CTL_FORMAT_Y412;\n\tcase DRM_FORMAT_XVYU16161616:\n\t\treturn PLANE_CTL_FORMAT_Y416;\n\tdefault:\n\t\tMISSING_CASE(pixel_format);\n\t}\n\n\treturn 0;\n}\n\nstatic u32 skl_plane_ctl_alpha(const struct intel_plane_state *plane_state)\n{\n\tif (!plane_state->hw.fb->format->has_alpha)\n\t\treturn PLANE_CTL_ALPHA_DISABLE;\n\n\tswitch (plane_state->hw.pixel_blend_mode) {\n\tcase DRM_MODE_BLEND_PIXEL_NONE:\n\t\treturn PLANE_CTL_ALPHA_DISABLE;\n\tcase DRM_MODE_BLEND_PREMULTI:\n\t\treturn PLANE_CTL_ALPHA_SW_PREMULTIPLY;\n\tcase DRM_MODE_BLEND_COVERAGE:\n\t\treturn PLANE_CTL_ALPHA_HW_PREMULTIPLY;\n\tdefault:\n\t\tMISSING_CASE(plane_state->hw.pixel_blend_mode);\n\t\treturn PLANE_CTL_ALPHA_DISABLE;\n\t}\n}\n\nstatic u32 glk_plane_color_ctl_alpha(const struct intel_plane_state *plane_state)\n{\n\tif (!plane_state->hw.fb->format->has_alpha)\n\t\treturn PLANE_COLOR_ALPHA_DISABLE;\n\n\tswitch (plane_state->hw.pixel_blend_mode) {\n\tcase DRM_MODE_BLEND_PIXEL_NONE:\n\t\treturn PLANE_COLOR_ALPHA_DISABLE;\n\tcase DRM_MODE_BLEND_PREMULTI:\n\t\treturn PLANE_COLOR_ALPHA_SW_PREMULTIPLY;\n\tcase DRM_MODE_BLEND_COVERAGE:\n\t\treturn PLANE_COLOR_ALPHA_HW_PREMULTIPLY;\n\tdefault:\n\t\tMISSING_CASE(plane_state->hw.pixel_blend_mode);\n\t\treturn PLANE_COLOR_ALPHA_DISABLE;\n\t}\n}\n\nstatic u32 skl_plane_ctl_tiling(u64 fb_modifier)\n{\n\tswitch (fb_modifier) {\n\tcase DRM_FORMAT_MOD_LINEAR:\n\t\tbreak;\n\tcase I915_FORMAT_MOD_X_TILED:\n\t\treturn PLANE_CTL_TILED_X;\n\tcase I915_FORMAT_MOD_Y_TILED:\n\t\treturn PLANE_CTL_TILED_Y;\n\tcase I915_FORMAT_MOD_4_TILED:\n\t\treturn PLANE_CTL_TILED_4;\n\tcase I915_FORMAT_MOD_4_TILED_DG2_RC_CCS:\n\t\treturn PLANE_CTL_TILED_4 |\n\t\t\tPLANE_CTL_RENDER_DECOMPRESSION_ENABLE |\n\t\t\tPLANE_CTL_CLEAR_COLOR_DISABLE;\n\tcase I915_FORMAT_MOD_4_TILED_DG2_MC_CCS:\n\t\treturn PLANE_CTL_TILED_4 |\n\t\t\tPLANE_CTL_MEDIA_DECOMPRESSION_ENABLE |\n\t\t\tPLANE_CTL_CLEAR_COLOR_DISABLE;\n\tcase I915_FORMAT_MOD_4_TILED_DG2_RC_CCS_CC:\n\t\treturn PLANE_CTL_TILED_4 | PLANE_CTL_RENDER_DECOMPRESSION_ENABLE;\n\tcase I915_FORMAT_MOD_4_TILED_MTL_RC_CCS:\n\t\treturn PLANE_CTL_TILED_4 |\n\t\t\tPLANE_CTL_RENDER_DECOMPRESSION_ENABLE |\n\t\t\tPLANE_CTL_CLEAR_COLOR_DISABLE;\n\tcase I915_FORMAT_MOD_4_TILED_MTL_RC_CCS_CC:\n\t\treturn PLANE_CTL_TILED_4 | PLANE_CTL_RENDER_DECOMPRESSION_ENABLE;\n\tcase I915_FORMAT_MOD_4_TILED_MTL_MC_CCS:\n\t\treturn PLANE_CTL_TILED_4 | PLANE_CTL_MEDIA_DECOMPRESSION_ENABLE;\n\tcase I915_FORMAT_MOD_Y_TILED_CCS:\n\tcase I915_FORMAT_MOD_Y_TILED_GEN12_RC_CCS_CC:\n\t\treturn PLANE_CTL_TILED_Y | PLANE_CTL_RENDER_DECOMPRESSION_ENABLE;\n\tcase I915_FORMAT_MOD_Y_TILED_GEN12_RC_CCS:\n\t\treturn PLANE_CTL_TILED_Y |\n\t\t       PLANE_CTL_RENDER_DECOMPRESSION_ENABLE |\n\t\t       PLANE_CTL_CLEAR_COLOR_DISABLE;\n\tcase I915_FORMAT_MOD_Y_TILED_GEN12_MC_CCS:\n\t\treturn PLANE_CTL_TILED_Y | PLANE_CTL_MEDIA_DECOMPRESSION_ENABLE;\n\tcase I915_FORMAT_MOD_Yf_TILED:\n\t\treturn PLANE_CTL_TILED_YF;\n\tcase I915_FORMAT_MOD_Yf_TILED_CCS:\n\t\treturn PLANE_CTL_TILED_YF | PLANE_CTL_RENDER_DECOMPRESSION_ENABLE;\n\tdefault:\n\t\tMISSING_CASE(fb_modifier);\n\t}\n\n\treturn 0;\n}\n\nstatic u32 skl_plane_ctl_rotate(unsigned int rotate)\n{\n\tswitch (rotate) {\n\tcase DRM_MODE_ROTATE_0:\n\t\tbreak;\n\t \n\tcase DRM_MODE_ROTATE_90:\n\t\treturn PLANE_CTL_ROTATE_270;\n\tcase DRM_MODE_ROTATE_180:\n\t\treturn PLANE_CTL_ROTATE_180;\n\tcase DRM_MODE_ROTATE_270:\n\t\treturn PLANE_CTL_ROTATE_90;\n\tdefault:\n\t\tMISSING_CASE(rotate);\n\t}\n\n\treturn 0;\n}\n\nstatic u32 icl_plane_ctl_flip(unsigned int reflect)\n{\n\tswitch (reflect) {\n\tcase 0:\n\t\tbreak;\n\tcase DRM_MODE_REFLECT_X:\n\t\treturn PLANE_CTL_FLIP_HORIZONTAL;\n\tcase DRM_MODE_REFLECT_Y:\n\tdefault:\n\t\tMISSING_CASE(reflect);\n\t}\n\n\treturn 0;\n}\n\nstatic u32 adlp_plane_ctl_arb_slots(const struct intel_plane_state *plane_state)\n{\n\tconst struct drm_framebuffer *fb = plane_state->hw.fb;\n\n\tif (intel_format_info_is_yuv_semiplanar(fb->format, fb->modifier)) {\n\t\tswitch (fb->format->cpp[0]) {\n\t\tcase 2:\n\t\t\treturn PLANE_CTL_ARB_SLOTS(1);\n\t\tdefault:\n\t\t\treturn PLANE_CTL_ARB_SLOTS(0);\n\t\t}\n\t} else {\n\t\tswitch (fb->format->cpp[0]) {\n\t\tcase 8:\n\t\t\treturn PLANE_CTL_ARB_SLOTS(3);\n\t\tcase 4:\n\t\t\treturn PLANE_CTL_ARB_SLOTS(1);\n\t\tdefault:\n\t\t\treturn PLANE_CTL_ARB_SLOTS(0);\n\t\t}\n\t}\n}\n\nstatic u32 skl_plane_ctl_crtc(const struct intel_crtc_state *crtc_state)\n{\n\tstruct drm_i915_private *dev_priv = to_i915(crtc_state->uapi.crtc->dev);\n\tu32 plane_ctl = 0;\n\n\tif (DISPLAY_VER(dev_priv) >= 10)\n\t\treturn plane_ctl;\n\n\tif (crtc_state->gamma_enable)\n\t\tplane_ctl |= PLANE_CTL_PIPE_GAMMA_ENABLE;\n\n\tif (crtc_state->csc_enable)\n\t\tplane_ctl |= PLANE_CTL_PIPE_CSC_ENABLE;\n\n\treturn plane_ctl;\n}\n\nstatic u32 skl_plane_ctl(const struct intel_crtc_state *crtc_state,\n\t\t\t const struct intel_plane_state *plane_state)\n{\n\tstruct drm_i915_private *dev_priv =\n\t\tto_i915(plane_state->uapi.plane->dev);\n\tconst struct drm_framebuffer *fb = plane_state->hw.fb;\n\tunsigned int rotation = plane_state->hw.rotation;\n\tconst struct drm_intel_sprite_colorkey *key = &plane_state->ckey;\n\tu32 plane_ctl;\n\n\tplane_ctl = PLANE_CTL_ENABLE;\n\n\tif (DISPLAY_VER(dev_priv) < 10) {\n\t\tplane_ctl |= skl_plane_ctl_alpha(plane_state);\n\t\tplane_ctl |= PLANE_CTL_PLANE_GAMMA_DISABLE;\n\n\t\tif (plane_state->hw.color_encoding == DRM_COLOR_YCBCR_BT709)\n\t\t\tplane_ctl |= PLANE_CTL_YUV_TO_RGB_CSC_FORMAT_BT709;\n\n\t\tif (plane_state->hw.color_range == DRM_COLOR_YCBCR_FULL_RANGE)\n\t\t\tplane_ctl |= PLANE_CTL_YUV_RANGE_CORRECTION_DISABLE;\n\t}\n\n\tplane_ctl |= skl_plane_ctl_format(fb->format->format);\n\tplane_ctl |= skl_plane_ctl_tiling(fb->modifier);\n\tplane_ctl |= skl_plane_ctl_rotate(rotation & DRM_MODE_ROTATE_MASK);\n\n\tif (DISPLAY_VER(dev_priv) >= 11)\n\t\tplane_ctl |= icl_plane_ctl_flip(rotation &\n\t\t\t\t\t\tDRM_MODE_REFLECT_MASK);\n\n\tif (key->flags & I915_SET_COLORKEY_DESTINATION)\n\t\tplane_ctl |= PLANE_CTL_KEY_ENABLE_DESTINATION;\n\telse if (key->flags & I915_SET_COLORKEY_SOURCE)\n\t\tplane_ctl |= PLANE_CTL_KEY_ENABLE_SOURCE;\n\n\t \n\tif (DISPLAY_VER(dev_priv) == 13)\n\t\tplane_ctl |= adlp_plane_ctl_arb_slots(plane_state);\n\n\treturn plane_ctl;\n}\n\nstatic u32 glk_plane_color_ctl_crtc(const struct intel_crtc_state *crtc_state)\n{\n\tstruct drm_i915_private *dev_priv = to_i915(crtc_state->uapi.crtc->dev);\n\tu32 plane_color_ctl = 0;\n\n\tif (DISPLAY_VER(dev_priv) >= 11)\n\t\treturn plane_color_ctl;\n\n\tif (crtc_state->gamma_enable)\n\t\tplane_color_ctl |= PLANE_COLOR_PIPE_GAMMA_ENABLE;\n\n\tif (crtc_state->csc_enable)\n\t\tplane_color_ctl |= PLANE_COLOR_PIPE_CSC_ENABLE;\n\n\treturn plane_color_ctl;\n}\n\nstatic u32 glk_plane_color_ctl(const struct intel_crtc_state *crtc_state,\n\t\t\t       const struct intel_plane_state *plane_state)\n{\n\tstruct drm_i915_private *dev_priv =\n\t\tto_i915(plane_state->uapi.plane->dev);\n\tconst struct drm_framebuffer *fb = plane_state->hw.fb;\n\tstruct intel_plane *plane = to_intel_plane(plane_state->uapi.plane);\n\tu32 plane_color_ctl = 0;\n\n\tplane_color_ctl |= PLANE_COLOR_PLANE_GAMMA_DISABLE;\n\tplane_color_ctl |= glk_plane_color_ctl_alpha(plane_state);\n\n\tif (fb->format->is_yuv && !icl_is_hdr_plane(dev_priv, plane->id)) {\n\t\tswitch (plane_state->hw.color_encoding) {\n\t\tcase DRM_COLOR_YCBCR_BT709:\n\t\t\tplane_color_ctl |= PLANE_COLOR_CSC_MODE_YUV709_TO_RGB709;\n\t\t\tbreak;\n\t\tcase DRM_COLOR_YCBCR_BT2020:\n\t\t\tplane_color_ctl |=\n\t\t\t\tPLANE_COLOR_CSC_MODE_YUV2020_TO_RGB2020;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tplane_color_ctl |=\n\t\t\t\tPLANE_COLOR_CSC_MODE_YUV601_TO_RGB601;\n\t\t}\n\t\tif (plane_state->hw.color_range == DRM_COLOR_YCBCR_FULL_RANGE)\n\t\t\tplane_color_ctl |= PLANE_COLOR_YUV_RANGE_CORRECTION_DISABLE;\n\t} else if (fb->format->is_yuv) {\n\t\tplane_color_ctl |= PLANE_COLOR_INPUT_CSC_ENABLE;\n\t\tif (plane_state->hw.color_range == DRM_COLOR_YCBCR_FULL_RANGE)\n\t\t\tplane_color_ctl |= PLANE_COLOR_YUV_RANGE_CORRECTION_DISABLE;\n\t}\n\n\tif (plane_state->force_black)\n\t\tplane_color_ctl |= PLANE_COLOR_PLANE_CSC_ENABLE;\n\n\treturn plane_color_ctl;\n}\n\nstatic u32 skl_surf_address(const struct intel_plane_state *plane_state,\n\t\t\t    int color_plane)\n{\n\tstruct drm_i915_private *i915 = to_i915(plane_state->uapi.plane->dev);\n\tconst struct drm_framebuffer *fb = plane_state->hw.fb;\n\tu32 offset = plane_state->view.color_plane[color_plane].offset;\n\n\tif (intel_fb_uses_dpt(fb)) {\n\t\t \n\t\tdrm_WARN_ON(&i915->drm, plane_state->dpt_vma->node.start);\n\t\tdrm_WARN_ON(&i915->drm, offset & 0x1fffff);\n\t\treturn offset >> 9;\n\t} else {\n\t\tdrm_WARN_ON(&i915->drm, offset & 0xfff);\n\t\treturn offset;\n\t}\n}\n\nstatic u32 skl_plane_surf(const struct intel_plane_state *plane_state,\n\t\t\t  int color_plane)\n{\n\tu32 plane_surf;\n\n\tplane_surf = intel_plane_ggtt_offset(plane_state) +\n\t\tskl_surf_address(plane_state, color_plane);\n\n\tif (plane_state->decrypt)\n\t\tplane_surf |= PLANE_SURF_DECRYPT;\n\n\treturn plane_surf;\n}\n\nstatic u32 skl_plane_aux_dist(const struct intel_plane_state *plane_state,\n\t\t\t      int color_plane)\n{\n\tstruct drm_i915_private *i915 = to_i915(plane_state->uapi.plane->dev);\n\tconst struct drm_framebuffer *fb = plane_state->hw.fb;\n\tint aux_plane = skl_main_to_aux_plane(fb, color_plane);\n\tu32 aux_dist;\n\n\tif (!aux_plane)\n\t\treturn 0;\n\n\taux_dist = skl_surf_address(plane_state, aux_plane) -\n\t\tskl_surf_address(plane_state, color_plane);\n\n\tif (DISPLAY_VER(i915) < 12)\n\t\taux_dist |= PLANE_AUX_STRIDE(skl_plane_stride(plane_state, aux_plane));\n\n\treturn aux_dist;\n}\n\nstatic u32 skl_plane_keyval(const struct intel_plane_state *plane_state)\n{\n\tconst struct drm_intel_sprite_colorkey *key = &plane_state->ckey;\n\n\treturn key->min_value;\n}\n\nstatic u32 skl_plane_keymax(const struct intel_plane_state *plane_state)\n{\n\tconst struct drm_intel_sprite_colorkey *key = &plane_state->ckey;\n\tu8 alpha = plane_state->hw.alpha >> 8;\n\n\treturn (key->max_value & 0xffffff) | PLANE_KEYMAX_ALPHA(alpha);\n}\n\nstatic u32 skl_plane_keymsk(const struct intel_plane_state *plane_state)\n{\n\tconst struct drm_intel_sprite_colorkey *key = &plane_state->ckey;\n\tu8 alpha = plane_state->hw.alpha >> 8;\n\tu32 keymsk;\n\n\tkeymsk = key->channel_mask & 0x7ffffff;\n\tif (alpha < 0xff)\n\t\tkeymsk |= PLANE_KEYMSK_ALPHA_ENABLE;\n\n\treturn keymsk;\n}\n\nstatic void icl_plane_csc_load_black(struct intel_plane *plane)\n{\n\tstruct drm_i915_private *i915 = to_i915(plane->base.dev);\n\tenum plane_id plane_id = plane->id;\n\tenum pipe pipe = plane->pipe;\n\n\tintel_de_write_fw(i915, PLANE_CSC_COEFF(pipe, plane_id, 0), 0);\n\tintel_de_write_fw(i915, PLANE_CSC_COEFF(pipe, plane_id, 1), 0);\n\n\tintel_de_write_fw(i915, PLANE_CSC_COEFF(pipe, plane_id, 2), 0);\n\tintel_de_write_fw(i915, PLANE_CSC_COEFF(pipe, plane_id, 3), 0);\n\n\tintel_de_write_fw(i915, PLANE_CSC_COEFF(pipe, plane_id, 4), 0);\n\tintel_de_write_fw(i915, PLANE_CSC_COEFF(pipe, plane_id, 5), 0);\n\n\tintel_de_write_fw(i915, PLANE_CSC_PREOFF(pipe, plane_id, 0), 0);\n\tintel_de_write_fw(i915, PLANE_CSC_PREOFF(pipe, plane_id, 1), 0);\n\tintel_de_write_fw(i915, PLANE_CSC_PREOFF(pipe, plane_id, 2), 0);\n\n\tintel_de_write_fw(i915, PLANE_CSC_POSTOFF(pipe, plane_id, 0), 0);\n\tintel_de_write_fw(i915, PLANE_CSC_POSTOFF(pipe, plane_id, 1), 0);\n\tintel_de_write_fw(i915, PLANE_CSC_POSTOFF(pipe, plane_id, 2), 0);\n}\n\nstatic int icl_plane_color_plane(const struct intel_plane_state *plane_state)\n{\n\t \n\tif (plane_state->planar_linked_plane && !plane_state->planar_slave)\n\t\treturn 1;\n\telse\n\t\treturn 0;\n}\n\nstatic void\nskl_plane_update_noarm(struct intel_plane *plane,\n\t\t       const struct intel_crtc_state *crtc_state,\n\t\t       const struct intel_plane_state *plane_state)\n{\n\tstruct drm_i915_private *dev_priv = to_i915(plane->base.dev);\n\tenum plane_id plane_id = plane->id;\n\tenum pipe pipe = plane->pipe;\n\tu32 stride = skl_plane_stride(plane_state, 0);\n\tint crtc_x = plane_state->uapi.dst.x1;\n\tint crtc_y = plane_state->uapi.dst.y1;\n\tu32 src_w = drm_rect_width(&plane_state->uapi.src) >> 16;\n\tu32 src_h = drm_rect_height(&plane_state->uapi.src) >> 16;\n\n\t \n\tif (plane_state->scaler_id >= 0) {\n\t\tcrtc_x = 0;\n\t\tcrtc_y = 0;\n\t}\n\n\tintel_de_write_fw(dev_priv, PLANE_STRIDE(pipe, plane_id),\n\t\t\t  PLANE_STRIDE_(stride));\n\tintel_de_write_fw(dev_priv, PLANE_POS(pipe, plane_id),\n\t\t\t  PLANE_POS_Y(crtc_y) | PLANE_POS_X(crtc_x));\n\tintel_de_write_fw(dev_priv, PLANE_SIZE(pipe, plane_id),\n\t\t\t  PLANE_HEIGHT(src_h - 1) | PLANE_WIDTH(src_w - 1));\n\n\tskl_write_plane_wm(plane, crtc_state);\n}\n\nstatic void\nskl_plane_update_arm(struct intel_plane *plane,\n\t\t     const struct intel_crtc_state *crtc_state,\n\t\t     const struct intel_plane_state *plane_state)\n{\n\tstruct drm_i915_private *dev_priv = to_i915(plane->base.dev);\n\tenum plane_id plane_id = plane->id;\n\tenum pipe pipe = plane->pipe;\n\tu32 x = plane_state->view.color_plane[0].x;\n\tu32 y = plane_state->view.color_plane[0].y;\n\tu32 plane_ctl, plane_color_ctl = 0;\n\n\tplane_ctl = plane_state->ctl |\n\t\tskl_plane_ctl_crtc(crtc_state);\n\n\tif (DISPLAY_VER(dev_priv) >= 10)\n\t\tplane_color_ctl = plane_state->color_ctl |\n\t\t\tglk_plane_color_ctl_crtc(crtc_state);\n\n\tintel_de_write_fw(dev_priv, PLANE_KEYVAL(pipe, plane_id), skl_plane_keyval(plane_state));\n\tintel_de_write_fw(dev_priv, PLANE_KEYMSK(pipe, plane_id), skl_plane_keymsk(plane_state));\n\tintel_de_write_fw(dev_priv, PLANE_KEYMAX(pipe, plane_id), skl_plane_keymax(plane_state));\n\n\tintel_de_write_fw(dev_priv, PLANE_OFFSET(pipe, plane_id),\n\t\t\t  PLANE_OFFSET_Y(y) | PLANE_OFFSET_X(x));\n\n\tintel_de_write_fw(dev_priv, PLANE_AUX_DIST(pipe, plane_id),\n\t\t\t  skl_plane_aux_dist(plane_state, 0));\n\n\tintel_de_write_fw(dev_priv, PLANE_AUX_OFFSET(pipe, plane_id),\n\t\t\t  PLANE_OFFSET_Y(plane_state->view.color_plane[1].y) |\n\t\t\t  PLANE_OFFSET_X(plane_state->view.color_plane[1].x));\n\n\tif (DISPLAY_VER(dev_priv) >= 10)\n\t\tintel_de_write_fw(dev_priv, PLANE_COLOR_CTL(pipe, plane_id), plane_color_ctl);\n\n\t \n\tif (plane_state->scaler_id >= 0)\n\t\tskl_program_plane_scaler(plane, crtc_state, plane_state);\n\n\t \n\tintel_de_write_fw(dev_priv, PLANE_CTL(pipe, plane_id), plane_ctl);\n\tintel_de_write_fw(dev_priv, PLANE_SURF(pipe, plane_id),\n\t\t\t  skl_plane_surf(plane_state, 0));\n}\n\nstatic void\nicl_plane_update_noarm(struct intel_plane *plane,\n\t\t       const struct intel_crtc_state *crtc_state,\n\t\t       const struct intel_plane_state *plane_state)\n{\n\tstruct drm_i915_private *dev_priv = to_i915(plane->base.dev);\n\tenum plane_id plane_id = plane->id;\n\tenum pipe pipe = plane->pipe;\n\tint color_plane = icl_plane_color_plane(plane_state);\n\tu32 stride = skl_plane_stride(plane_state, color_plane);\n\tconst struct drm_framebuffer *fb = plane_state->hw.fb;\n\tint crtc_x = plane_state->uapi.dst.x1;\n\tint crtc_y = plane_state->uapi.dst.y1;\n\tint x = plane_state->view.color_plane[color_plane].x;\n\tint y = plane_state->view.color_plane[color_plane].y;\n\tint src_w = drm_rect_width(&plane_state->uapi.src) >> 16;\n\tint src_h = drm_rect_height(&plane_state->uapi.src) >> 16;\n\tu32 plane_color_ctl;\n\n\tplane_color_ctl = plane_state->color_ctl |\n\t\tglk_plane_color_ctl_crtc(crtc_state);\n\n\t \n\tif (plane_state->scaler_id >= 0) {\n\t\tcrtc_x = 0;\n\t\tcrtc_y = 0;\n\t}\n\n\tintel_de_write_fw(dev_priv, PLANE_STRIDE(pipe, plane_id),\n\t\t\t  PLANE_STRIDE_(stride));\n\tintel_de_write_fw(dev_priv, PLANE_POS(pipe, plane_id),\n\t\t\t  PLANE_POS_Y(crtc_y) | PLANE_POS_X(crtc_x));\n\tintel_de_write_fw(dev_priv, PLANE_SIZE(pipe, plane_id),\n\t\t\t  PLANE_HEIGHT(src_h - 1) | PLANE_WIDTH(src_w - 1));\n\n\tintel_de_write_fw(dev_priv, PLANE_KEYVAL(pipe, plane_id), skl_plane_keyval(plane_state));\n\tintel_de_write_fw(dev_priv, PLANE_KEYMSK(pipe, plane_id), skl_plane_keymsk(plane_state));\n\tintel_de_write_fw(dev_priv, PLANE_KEYMAX(pipe, plane_id), skl_plane_keymax(plane_state));\n\n\tintel_de_write_fw(dev_priv, PLANE_OFFSET(pipe, plane_id),\n\t\t\t  PLANE_OFFSET_Y(y) | PLANE_OFFSET_X(x));\n\n\tif (intel_fb_is_rc_ccs_cc_modifier(fb->modifier)) {\n\t\tintel_de_write_fw(dev_priv, PLANE_CC_VAL(pipe, plane_id, 0),\n\t\t\t\t  lower_32_bits(plane_state->ccval));\n\t\tintel_de_write_fw(dev_priv, PLANE_CC_VAL(pipe, plane_id, 1),\n\t\t\t\t  upper_32_bits(plane_state->ccval));\n\t}\n\n\t \n\tif (!HAS_FLAT_CCS(dev_priv))\n\t\tintel_de_write_fw(dev_priv, PLANE_AUX_DIST(pipe, plane_id),\n\t\t\t\t  skl_plane_aux_dist(plane_state, color_plane));\n\n\tif (icl_is_hdr_plane(dev_priv, plane_id))\n\t\tintel_de_write_fw(dev_priv, PLANE_CUS_CTL(pipe, plane_id),\n\t\t\t\t  plane_state->cus_ctl);\n\n\tintel_de_write_fw(dev_priv, PLANE_COLOR_CTL(pipe, plane_id), plane_color_ctl);\n\n\tif (fb->format->is_yuv && icl_is_hdr_plane(dev_priv, plane_id))\n\t\ticl_program_input_csc(plane, crtc_state, plane_state);\n\n\tskl_write_plane_wm(plane, crtc_state);\n\n\t \n\tif (plane_state->force_black)\n\t\ticl_plane_csc_load_black(plane);\n\n\tintel_psr2_program_plane_sel_fetch_noarm(plane, crtc_state, plane_state, color_plane);\n}\n\nstatic void\nicl_plane_update_arm(struct intel_plane *plane,\n\t\t     const struct intel_crtc_state *crtc_state,\n\t\t     const struct intel_plane_state *plane_state)\n{\n\tstruct drm_i915_private *dev_priv = to_i915(plane->base.dev);\n\tenum plane_id plane_id = plane->id;\n\tenum pipe pipe = plane->pipe;\n\tint color_plane = icl_plane_color_plane(plane_state);\n\tu32 plane_ctl;\n\n\tplane_ctl = plane_state->ctl |\n\t\tskl_plane_ctl_crtc(crtc_state);\n\n\t \n\tif (plane_state->scaler_id >= 0)\n\t\tskl_program_plane_scaler(plane, crtc_state, plane_state);\n\n\tintel_psr2_program_plane_sel_fetch_arm(plane, crtc_state, plane_state);\n\n\t \n\tintel_de_write_fw(dev_priv, PLANE_CTL(pipe, plane_id), plane_ctl);\n\tintel_de_write_fw(dev_priv, PLANE_SURF(pipe, plane_id),\n\t\t\t  skl_plane_surf(plane_state, color_plane));\n}\n\nstatic void\nskl_plane_async_flip(struct intel_plane *plane,\n\t\t     const struct intel_crtc_state *crtc_state,\n\t\t     const struct intel_plane_state *plane_state,\n\t\t     bool async_flip)\n{\n\tstruct drm_i915_private *dev_priv = to_i915(plane->base.dev);\n\tenum plane_id plane_id = plane->id;\n\tenum pipe pipe = plane->pipe;\n\tu32 plane_ctl = plane_state->ctl;\n\n\tplane_ctl |= skl_plane_ctl_crtc(crtc_state);\n\n\tif (async_flip)\n\t\tplane_ctl |= PLANE_CTL_ASYNC_FLIP;\n\n\tintel_de_write_fw(dev_priv, PLANE_CTL(pipe, plane_id), plane_ctl);\n\tintel_de_write_fw(dev_priv, PLANE_SURF(pipe, plane_id),\n\t\t\t  skl_plane_surf(plane_state, 0));\n}\n\nstatic bool intel_format_is_p01x(u32 format)\n{\n\tswitch (format) {\n\tcase DRM_FORMAT_P010:\n\tcase DRM_FORMAT_P012:\n\tcase DRM_FORMAT_P016:\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nstatic int skl_plane_check_fb(const struct intel_crtc_state *crtc_state,\n\t\t\t      const struct intel_plane_state *plane_state)\n{\n\tstruct intel_plane *plane = to_intel_plane(plane_state->uapi.plane);\n\tstruct drm_i915_private *dev_priv = to_i915(plane->base.dev);\n\tconst struct drm_framebuffer *fb = plane_state->hw.fb;\n\tunsigned int rotation = plane_state->hw.rotation;\n\n\tif (!fb)\n\t\treturn 0;\n\n\tif (rotation & ~(DRM_MODE_ROTATE_0 | DRM_MODE_ROTATE_180) &&\n\t    intel_fb_is_ccs_modifier(fb->modifier)) {\n\t\tdrm_dbg_kms(&dev_priv->drm,\n\t\t\t    \"RC support only with 0/180 degree rotation (%x)\\n\",\n\t\t\t    rotation);\n\t\treturn -EINVAL;\n\t}\n\n\tif (rotation & DRM_MODE_REFLECT_X &&\n\t    fb->modifier == DRM_FORMAT_MOD_LINEAR) {\n\t\tdrm_dbg_kms(&dev_priv->drm,\n\t\t\t    \"horizontal flip is not supported with linear surface formats\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (drm_rotation_90_or_270(rotation)) {\n\t\tif (!intel_fb_supports_90_270_rotation(to_intel_framebuffer(fb))) {\n\t\t\tdrm_dbg_kms(&dev_priv->drm,\n\t\t\t\t    \"Y/Yf tiling required for 90/270!\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\t \n\t\tswitch (fb->format->format) {\n\t\tcase DRM_FORMAT_RGB565:\n\t\t\tif (DISPLAY_VER(dev_priv) >= 11)\n\t\t\t\tbreak;\n\t\t\tfallthrough;\n\t\tcase DRM_FORMAT_C8:\n\t\tcase DRM_FORMAT_XRGB16161616F:\n\t\tcase DRM_FORMAT_XBGR16161616F:\n\t\tcase DRM_FORMAT_ARGB16161616F:\n\t\tcase DRM_FORMAT_ABGR16161616F:\n\t\tcase DRM_FORMAT_Y210:\n\t\tcase DRM_FORMAT_Y212:\n\t\tcase DRM_FORMAT_Y216:\n\t\tcase DRM_FORMAT_XVYU12_16161616:\n\t\tcase DRM_FORMAT_XVYU16161616:\n\t\t\tdrm_dbg_kms(&dev_priv->drm,\n\t\t\t\t    \"Unsupported pixel format %p4cc for 90/270!\\n\",\n\t\t\t\t    &fb->format->format);\n\t\t\treturn -EINVAL;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t \n\tif (crtc_state->hw.enable &&\n\t    crtc_state->hw.adjusted_mode.flags & DRM_MODE_FLAG_INTERLACE &&\n\t    fb->modifier != DRM_FORMAT_MOD_LINEAR &&\n\t    fb->modifier != I915_FORMAT_MOD_X_TILED) {\n\t\tdrm_dbg_kms(&dev_priv->drm,\n\t\t\t    \"Y/Yf tiling not supported in IF-ID mode\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif ((IS_ALDERLAKE_S(dev_priv) || IS_TIGERLAKE(dev_priv)) &&\n\t    plane_state->ckey.flags & I915_SET_COLORKEY_SOURCE &&\n\t    intel_format_is_p01x(fb->format->format)) {\n\t\tdrm_dbg_kms(&dev_priv->drm,\n\t\t\t    \"Source color keying not supported with P01x formats\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int skl_plane_check_dst_coordinates(const struct intel_crtc_state *crtc_state,\n\t\t\t\t\t   const struct intel_plane_state *plane_state)\n{\n\tstruct drm_i915_private *dev_priv =\n\t\tto_i915(plane_state->uapi.plane->dev);\n\tint crtc_x = plane_state->uapi.dst.x1;\n\tint crtc_w = drm_rect_width(&plane_state->uapi.dst);\n\tint pipe_src_w = drm_rect_width(&crtc_state->pipe_src);\n\n\t \n\tif (DISPLAY_VER(dev_priv) == 10 &&\n\t    (crtc_x + crtc_w < 4 || crtc_x > pipe_src_w - 4)) {\n\t\tdrm_dbg_kms(&dev_priv->drm,\n\t\t\t    \"requested plane X %s position %d invalid (valid range %d-%d)\\n\",\n\t\t\t    crtc_x + crtc_w < 4 ? \"end\" : \"start\",\n\t\t\t    crtc_x + crtc_w < 4 ? crtc_x + crtc_w : crtc_x,\n\t\t\t    4, pipe_src_w - 4);\n\t\treturn -ERANGE;\n\t}\n\n\treturn 0;\n}\n\nstatic int skl_plane_check_nv12_rotation(const struct intel_plane_state *plane_state)\n{\n\tstruct drm_i915_private *i915 = to_i915(plane_state->uapi.plane->dev);\n\tconst struct drm_framebuffer *fb = plane_state->hw.fb;\n\tunsigned int rotation = plane_state->hw.rotation;\n\tint src_w = drm_rect_width(&plane_state->uapi.src) >> 16;\n\n\t \n\tif (intel_format_info_is_yuv_semiplanar(fb->format, fb->modifier) &&\n\t    src_w & 3 &&\n\t    (rotation == DRM_MODE_ROTATE_270 ||\n\t     rotation == (DRM_MODE_REFLECT_X | DRM_MODE_ROTATE_90))) {\n\t\tdrm_dbg_kms(&i915->drm, \"src width must be multiple of 4 for rotated planar YUV\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int skl_plane_max_scale(struct drm_i915_private *dev_priv,\n\t\t\t       const struct drm_framebuffer *fb)\n{\n\t \n\tif (DISPLAY_VER(dev_priv) >= 10 ||\n\t    !intel_format_info_is_yuv_semiplanar(fb->format, fb->modifier))\n\t\treturn 0x30000 - 1;\n\telse\n\t\treturn 0x20000 - 1;\n}\n\nstatic int intel_plane_min_width(struct intel_plane *plane,\n\t\t\t\t const struct drm_framebuffer *fb,\n\t\t\t\t int color_plane,\n\t\t\t\t unsigned int rotation)\n{\n\tif (plane->min_width)\n\t\treturn plane->min_width(fb, color_plane, rotation);\n\telse\n\t\treturn 1;\n}\n\nstatic int intel_plane_max_width(struct intel_plane *plane,\n\t\t\t\t const struct drm_framebuffer *fb,\n\t\t\t\t int color_plane,\n\t\t\t\t unsigned int rotation)\n{\n\tif (plane->max_width)\n\t\treturn plane->max_width(fb, color_plane, rotation);\n\telse\n\t\treturn INT_MAX;\n}\n\nstatic int intel_plane_max_height(struct intel_plane *plane,\n\t\t\t\t  const struct drm_framebuffer *fb,\n\t\t\t\t  int color_plane,\n\t\t\t\t  unsigned int rotation)\n{\n\tif (plane->max_height)\n\t\treturn plane->max_height(fb, color_plane, rotation);\n\telse\n\t\treturn INT_MAX;\n}\n\nstatic bool\nskl_check_main_ccs_coordinates(struct intel_plane_state *plane_state,\n\t\t\t       int main_x, int main_y, u32 main_offset,\n\t\t\t       int ccs_plane)\n{\n\tconst struct drm_framebuffer *fb = plane_state->hw.fb;\n\tint aux_x = plane_state->view.color_plane[ccs_plane].x;\n\tint aux_y = plane_state->view.color_plane[ccs_plane].y;\n\tu32 aux_offset = plane_state->view.color_plane[ccs_plane].offset;\n\tu32 alignment = intel_surf_alignment(fb, ccs_plane);\n\tint hsub;\n\tint vsub;\n\n\tintel_fb_plane_get_subsampling(&hsub, &vsub, fb, ccs_plane);\n\twhile (aux_offset >= main_offset && aux_y <= main_y) {\n\t\tint x, y;\n\n\t\tif (aux_x == main_x && aux_y == main_y)\n\t\t\tbreak;\n\n\t\tif (aux_offset == 0)\n\t\t\tbreak;\n\n\t\tx = aux_x / hsub;\n\t\ty = aux_y / vsub;\n\t\taux_offset = intel_plane_adjust_aligned_offset(&x, &y,\n\t\t\t\t\t\t\t       plane_state,\n\t\t\t\t\t\t\t       ccs_plane,\n\t\t\t\t\t\t\t       aux_offset,\n\t\t\t\t\t\t\t       aux_offset -\n\t\t\t\t\t\t\t\talignment);\n\t\taux_x = x * hsub + aux_x % hsub;\n\t\taux_y = y * vsub + aux_y % vsub;\n\t}\n\n\tif (aux_x != main_x || aux_y != main_y)\n\t\treturn false;\n\n\tplane_state->view.color_plane[ccs_plane].offset = aux_offset;\n\tplane_state->view.color_plane[ccs_plane].x = aux_x;\n\tplane_state->view.color_plane[ccs_plane].y = aux_y;\n\n\treturn true;\n}\n\n\nint skl_calc_main_surface_offset(const struct intel_plane_state *plane_state,\n\t\t\t\t int *x, int *y, u32 *offset)\n{\n\tstruct intel_plane *plane = to_intel_plane(plane_state->uapi.plane);\n\tstruct drm_i915_private *dev_priv = to_i915(plane->base.dev);\n\tconst struct drm_framebuffer *fb = plane_state->hw.fb;\n\tconst int aux_plane = skl_main_to_aux_plane(fb, 0);\n\tconst u32 aux_offset = plane_state->view.color_plane[aux_plane].offset;\n\tconst u32 alignment = intel_surf_alignment(fb, 0);\n\tconst int w = drm_rect_width(&plane_state->uapi.src) >> 16;\n\n\tintel_add_fb_offsets(x, y, plane_state, 0);\n\t*offset = intel_plane_compute_aligned_offset(x, y, plane_state, 0);\n\tif (drm_WARN_ON(&dev_priv->drm, alignment && !is_power_of_2(alignment)))\n\t\treturn -EINVAL;\n\n\t \n\tif (aux_plane && *offset > aux_offset)\n\t\t*offset = intel_plane_adjust_aligned_offset(x, y, plane_state, 0,\n\t\t\t\t\t\t\t    *offset,\n\t\t\t\t\t\t\t    aux_offset & ~(alignment - 1));\n\n\t \n\tif (fb->modifier == I915_FORMAT_MOD_X_TILED) {\n\t\tint cpp = fb->format->cpp[0];\n\n\t\twhile ((*x + w) * cpp > plane_state->view.color_plane[0].mapping_stride) {\n\t\t\tif (*offset == 0) {\n\t\t\t\tdrm_dbg_kms(&dev_priv->drm,\n\t\t\t\t\t    \"Unable to find suitable display surface offset due to X-tiling\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\n\t\t\t*offset = intel_plane_adjust_aligned_offset(x, y, plane_state, 0,\n\t\t\t\t\t\t\t\t    *offset,\n\t\t\t\t\t\t\t\t    *offset - alignment);\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int skl_check_main_surface(struct intel_plane_state *plane_state)\n{\n\tstruct intel_plane *plane = to_intel_plane(plane_state->uapi.plane);\n\tstruct drm_i915_private *dev_priv = to_i915(plane->base.dev);\n\tconst struct drm_framebuffer *fb = plane_state->hw.fb;\n\tconst unsigned int rotation = plane_state->hw.rotation;\n\tint x = plane_state->uapi.src.x1 >> 16;\n\tint y = plane_state->uapi.src.y1 >> 16;\n\tconst int w = drm_rect_width(&plane_state->uapi.src) >> 16;\n\tconst int h = drm_rect_height(&plane_state->uapi.src) >> 16;\n\tconst int min_width = intel_plane_min_width(plane, fb, 0, rotation);\n\tconst int max_width = intel_plane_max_width(plane, fb, 0, rotation);\n\tconst int max_height = intel_plane_max_height(plane, fb, 0, rotation);\n\tconst int aux_plane = skl_main_to_aux_plane(fb, 0);\n\tconst u32 alignment = intel_surf_alignment(fb, 0);\n\tu32 offset;\n\tint ret;\n\n\tif (w > max_width || w < min_width || h > max_height || h < 1) {\n\t\tdrm_dbg_kms(&dev_priv->drm,\n\t\t\t    \"requested Y/RGB source size %dx%d outside limits (min: %dx1 max: %dx%d)\\n\",\n\t\t\t    w, h, min_width, max_width, max_height);\n\t\treturn -EINVAL;\n\t}\n\n\tret = skl_calc_main_surface_offset(plane_state, &x, &y, &offset);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tif (intel_fb_is_ccs_modifier(fb->modifier) && aux_plane) {\n\t\twhile (!skl_check_main_ccs_coordinates(plane_state, x, y,\n\t\t\t\t\t\t       offset, aux_plane)) {\n\t\t\tif (offset == 0)\n\t\t\t\tbreak;\n\n\t\t\toffset = intel_plane_adjust_aligned_offset(&x, &y, plane_state, 0,\n\t\t\t\t\t\t\t\t   offset, offset - alignment);\n\t\t}\n\n\t\tif (x != plane_state->view.color_plane[aux_plane].x ||\n\t\t    y != plane_state->view.color_plane[aux_plane].y) {\n\t\t\tdrm_dbg_kms(&dev_priv->drm,\n\t\t\t\t    \"Unable to find suitable display surface offset due to CCS\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tif (DISPLAY_VER(dev_priv) >= 13)\n\t\tdrm_WARN_ON(&dev_priv->drm, x > 65535 || y > 65535);\n\telse\n\t\tdrm_WARN_ON(&dev_priv->drm, x > 8191 || y > 8191);\n\n\tplane_state->view.color_plane[0].offset = offset;\n\tplane_state->view.color_plane[0].x = x;\n\tplane_state->view.color_plane[0].y = y;\n\n\t \n\tdrm_rect_translate_to(&plane_state->uapi.src,\n\t\t\t      x << 16, y << 16);\n\n\treturn 0;\n}\n\nstatic int skl_check_nv12_aux_surface(struct intel_plane_state *plane_state)\n{\n\tstruct intel_plane *plane = to_intel_plane(plane_state->uapi.plane);\n\tstruct drm_i915_private *i915 = to_i915(plane->base.dev);\n\tconst struct drm_framebuffer *fb = plane_state->hw.fb;\n\tunsigned int rotation = plane_state->hw.rotation;\n\tint uv_plane = 1;\n\tint ccs_plane = intel_fb_is_ccs_modifier(fb->modifier) ?\n\t\t\tskl_main_to_aux_plane(fb, uv_plane) : 0;\n\tint max_width = intel_plane_max_width(plane, fb, uv_plane, rotation);\n\tint max_height = intel_plane_max_height(plane, fb, uv_plane, rotation);\n\tint x = plane_state->uapi.src.x1 >> 17;\n\tint y = plane_state->uapi.src.y1 >> 17;\n\tint w = drm_rect_width(&plane_state->uapi.src) >> 17;\n\tint h = drm_rect_height(&plane_state->uapi.src) >> 17;\n\tu32 offset;\n\n\t \n\tif (w > max_width || h > max_height) {\n\t\tdrm_dbg_kms(&i915->drm,\n\t\t\t    \"CbCr source size %dx%d too big (limit %dx%d)\\n\",\n\t\t\t    w, h, max_width, max_height);\n\t\treturn -EINVAL;\n\t}\n\n\tintel_add_fb_offsets(&x, &y, plane_state, uv_plane);\n\toffset = intel_plane_compute_aligned_offset(&x, &y,\n\t\t\t\t\t\t    plane_state, uv_plane);\n\n\tif (ccs_plane) {\n\t\tu32 aux_offset = plane_state->view.color_plane[ccs_plane].offset;\n\t\tu32 alignment = intel_surf_alignment(fb, uv_plane);\n\n\t\tif (offset > aux_offset)\n\t\t\toffset = intel_plane_adjust_aligned_offset(&x, &y,\n\t\t\t\t\t\t\t\t   plane_state,\n\t\t\t\t\t\t\t\t   uv_plane,\n\t\t\t\t\t\t\t\t   offset,\n\t\t\t\t\t\t\t\t   aux_offset & ~(alignment - 1));\n\n\t\twhile (!skl_check_main_ccs_coordinates(plane_state, x, y,\n\t\t\t\t\t\t       offset, ccs_plane)) {\n\t\t\tif (offset == 0)\n\t\t\t\tbreak;\n\n\t\t\toffset = intel_plane_adjust_aligned_offset(&x, &y,\n\t\t\t\t\t\t\t\t   plane_state,\n\t\t\t\t\t\t\t\t   uv_plane,\n\t\t\t\t\t\t\t\t   offset, offset - alignment);\n\t\t}\n\n\t\tif (x != plane_state->view.color_plane[ccs_plane].x ||\n\t\t    y != plane_state->view.color_plane[ccs_plane].y) {\n\t\t\tdrm_dbg_kms(&i915->drm,\n\t\t\t\t    \"Unable to find suitable display surface offset due to CCS\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tif (DISPLAY_VER(i915) >= 13)\n\t\tdrm_WARN_ON(&i915->drm, x > 65535 || y > 65535);\n\telse\n\t\tdrm_WARN_ON(&i915->drm, x > 8191 || y > 8191);\n\n\tplane_state->view.color_plane[uv_plane].offset = offset;\n\tplane_state->view.color_plane[uv_plane].x = x;\n\tplane_state->view.color_plane[uv_plane].y = y;\n\n\treturn 0;\n}\n\nstatic int skl_check_ccs_aux_surface(struct intel_plane_state *plane_state)\n{\n\tconst struct drm_framebuffer *fb = plane_state->hw.fb;\n\tint src_x = plane_state->uapi.src.x1 >> 16;\n\tint src_y = plane_state->uapi.src.y1 >> 16;\n\tu32 offset;\n\tint ccs_plane;\n\n\tfor (ccs_plane = 0; ccs_plane < fb->format->num_planes; ccs_plane++) {\n\t\tint main_hsub, main_vsub;\n\t\tint hsub, vsub;\n\t\tint x, y;\n\n\t\tif (!intel_fb_is_ccs_aux_plane(fb, ccs_plane))\n\t\t\tcontinue;\n\n\t\tintel_fb_plane_get_subsampling(&main_hsub, &main_vsub, fb,\n\t\t\t\t\t       skl_ccs_to_main_plane(fb, ccs_plane));\n\t\tintel_fb_plane_get_subsampling(&hsub, &vsub, fb, ccs_plane);\n\n\t\thsub *= main_hsub;\n\t\tvsub *= main_vsub;\n\t\tx = src_x / hsub;\n\t\ty = src_y / vsub;\n\n\t\tintel_add_fb_offsets(&x, &y, plane_state, ccs_plane);\n\n\t\toffset = intel_plane_compute_aligned_offset(&x, &y,\n\t\t\t\t\t\t\t    plane_state,\n\t\t\t\t\t\t\t    ccs_plane);\n\n\t\tplane_state->view.color_plane[ccs_plane].offset = offset;\n\t\tplane_state->view.color_plane[ccs_plane].x = (x * hsub + src_x % hsub) / main_hsub;\n\t\tplane_state->view.color_plane[ccs_plane].y = (y * vsub + src_y % vsub) / main_vsub;\n\t}\n\n\treturn 0;\n}\n\nstatic int skl_check_plane_surface(struct intel_plane_state *plane_state)\n{\n\tconst struct drm_framebuffer *fb = plane_state->hw.fb;\n\tint ret;\n\n\tret = intel_plane_compute_gtt(plane_state);\n\tif (ret)\n\t\treturn ret;\n\n\tif (!plane_state->uapi.visible)\n\t\treturn 0;\n\n\t \n\tif (intel_fb_is_ccs_modifier(fb->modifier)) {\n\t\tret = skl_check_ccs_aux_surface(plane_state);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tif (intel_format_info_is_yuv_semiplanar(fb->format,\n\t\t\t\t\t\tfb->modifier)) {\n\t\tret = skl_check_nv12_aux_surface(plane_state);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tret = skl_check_main_surface(plane_state);\n\tif (ret)\n\t\treturn ret;\n\n\treturn 0;\n}\n\nstatic bool skl_fb_scalable(const struct drm_framebuffer *fb)\n{\n\tif (!fb)\n\t\treturn false;\n\n\tswitch (fb->format->format) {\n\tcase DRM_FORMAT_C8:\n\t\treturn false;\n\tcase DRM_FORMAT_XRGB16161616F:\n\tcase DRM_FORMAT_ARGB16161616F:\n\tcase DRM_FORMAT_XBGR16161616F:\n\tcase DRM_FORMAT_ABGR16161616F:\n\t\treturn DISPLAY_VER(to_i915(fb->dev)) >= 11;\n\tdefault:\n\t\treturn true;\n\t}\n}\n\nstatic bool bo_has_valid_encryption(struct drm_i915_gem_object *obj)\n{\n\tstruct drm_i915_private *i915 = to_i915(obj->base.dev);\n\n\treturn intel_pxp_key_check(i915->pxp, obj, false) == 0;\n}\n\nstatic bool pxp_is_borked(struct drm_i915_gem_object *obj)\n{\n\treturn i915_gem_object_is_protected(obj) && !bo_has_valid_encryption(obj);\n}\n\nstatic int skl_plane_check(struct intel_crtc_state *crtc_state,\n\t\t\t   struct intel_plane_state *plane_state)\n{\n\tstruct intel_plane *plane = to_intel_plane(plane_state->uapi.plane);\n\tstruct drm_i915_private *dev_priv = to_i915(plane->base.dev);\n\tconst struct drm_framebuffer *fb = plane_state->hw.fb;\n\tint min_scale = DRM_PLANE_NO_SCALING;\n\tint max_scale = DRM_PLANE_NO_SCALING;\n\tint ret;\n\n\tret = skl_plane_check_fb(crtc_state, plane_state);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tif (!plane_state->ckey.flags && skl_fb_scalable(fb)) {\n\t\tmin_scale = 1;\n\t\tmax_scale = skl_plane_max_scale(dev_priv, fb);\n\t}\n\n\tret = intel_atomic_plane_check_clipping(plane_state, crtc_state,\n\t\t\t\t\t\tmin_scale, max_scale, true);\n\tif (ret)\n\t\treturn ret;\n\n\tret = skl_check_plane_surface(plane_state);\n\tif (ret)\n\t\treturn ret;\n\n\tif (!plane_state->uapi.visible)\n\t\treturn 0;\n\n\tret = skl_plane_check_dst_coordinates(crtc_state, plane_state);\n\tif (ret)\n\t\treturn ret;\n\n\tret = intel_plane_check_src_coordinates(plane_state);\n\tif (ret)\n\t\treturn ret;\n\n\tret = skl_plane_check_nv12_rotation(plane_state);\n\tif (ret)\n\t\treturn ret;\n\n\tif (DISPLAY_VER(dev_priv) >= 11) {\n\t\tplane_state->decrypt = bo_has_valid_encryption(intel_fb_obj(fb));\n\t\tplane_state->force_black = pxp_is_borked(intel_fb_obj(fb));\n\t}\n\n\t \n\tif (!(plane_state->hw.alpha >> 8))\n\t\tplane_state->uapi.visible = false;\n\n\tplane_state->ctl = skl_plane_ctl(crtc_state, plane_state);\n\n\tif (DISPLAY_VER(dev_priv) >= 10)\n\t\tplane_state->color_ctl = glk_plane_color_ctl(crtc_state,\n\t\t\t\t\t\t\t     plane_state);\n\n\tif (intel_format_info_is_yuv_semiplanar(fb->format, fb->modifier) &&\n\t    icl_is_hdr_plane(dev_priv, plane->id))\n\t\t \n\t\tplane_state->cus_ctl = PLANE_CUS_ENABLE |\n\t\t\tPLANE_CUS_HPHASE_0 |\n\t\t\tPLANE_CUS_VPHASE_SIGN_NEGATIVE | PLANE_CUS_VPHASE_0_25;\n\telse\n\t\tplane_state->cus_ctl = 0;\n\n\treturn 0;\n}\n\nstatic enum intel_fbc_id skl_fbc_id_for_pipe(enum pipe pipe)\n{\n\treturn pipe - PIPE_A + INTEL_FBC_A;\n}\n\nstatic bool skl_plane_has_fbc(struct drm_i915_private *dev_priv,\n\t\t\t      enum intel_fbc_id fbc_id, enum plane_id plane_id)\n{\n\tif ((DISPLAY_RUNTIME_INFO(dev_priv)->fbc_mask & BIT(fbc_id)) == 0)\n\t\treturn false;\n\n\treturn plane_id == PLANE_PRIMARY;\n}\n\nstatic struct intel_fbc *skl_plane_fbc(struct drm_i915_private *dev_priv,\n\t\t\t\t       enum pipe pipe, enum plane_id plane_id)\n{\n\tenum intel_fbc_id fbc_id = skl_fbc_id_for_pipe(pipe);\n\n\tif (skl_plane_has_fbc(dev_priv, fbc_id, plane_id))\n\t\treturn dev_priv->display.fbc[fbc_id];\n\telse\n\t\treturn NULL;\n}\n\nstatic bool skl_plane_has_planar(struct drm_i915_private *dev_priv,\n\t\t\t\t enum pipe pipe, enum plane_id plane_id)\n{\n\t \n\tif (IS_SKYLAKE(dev_priv) || IS_BROXTON(dev_priv))\n\t\treturn false;\n\n\tif (DISPLAY_VER(dev_priv) == 9 && pipe == PIPE_C)\n\t\treturn false;\n\n\tif (plane_id != PLANE_PRIMARY && plane_id != PLANE_SPRITE0)\n\t\treturn false;\n\n\treturn true;\n}\n\nstatic const u32 *skl_get_plane_formats(struct drm_i915_private *dev_priv,\n\t\t\t\t\tenum pipe pipe, enum plane_id plane_id,\n\t\t\t\t\tint *num_formats)\n{\n\tif (skl_plane_has_planar(dev_priv, pipe, plane_id)) {\n\t\t*num_formats = ARRAY_SIZE(skl_planar_formats);\n\t\treturn skl_planar_formats;\n\t} else {\n\t\t*num_formats = ARRAY_SIZE(skl_plane_formats);\n\t\treturn skl_plane_formats;\n\t}\n}\n\nstatic const u32 *glk_get_plane_formats(struct drm_i915_private *dev_priv,\n\t\t\t\t\tenum pipe pipe, enum plane_id plane_id,\n\t\t\t\t\tint *num_formats)\n{\n\tif (skl_plane_has_planar(dev_priv, pipe, plane_id)) {\n\t\t*num_formats = ARRAY_SIZE(glk_planar_formats);\n\t\treturn glk_planar_formats;\n\t} else {\n\t\t*num_formats = ARRAY_SIZE(skl_plane_formats);\n\t\treturn skl_plane_formats;\n\t}\n}\n\nstatic const u32 *icl_get_plane_formats(struct drm_i915_private *dev_priv,\n\t\t\t\t\tenum pipe pipe, enum plane_id plane_id,\n\t\t\t\t\tint *num_formats)\n{\n\tif (icl_is_hdr_plane(dev_priv, plane_id)) {\n\t\t*num_formats = ARRAY_SIZE(icl_hdr_plane_formats);\n\t\treturn icl_hdr_plane_formats;\n\t} else if (icl_is_nv12_y_plane(dev_priv, plane_id)) {\n\t\t*num_formats = ARRAY_SIZE(icl_sdr_y_plane_formats);\n\t\treturn icl_sdr_y_plane_formats;\n\t} else {\n\t\t*num_formats = ARRAY_SIZE(icl_sdr_uv_plane_formats);\n\t\treturn icl_sdr_uv_plane_formats;\n\t}\n}\n\nstatic bool skl_plane_format_mod_supported(struct drm_plane *_plane,\n\t\t\t\t\t   u32 format, u64 modifier)\n{\n\tstruct intel_plane *plane = to_intel_plane(_plane);\n\n\tif (!intel_fb_plane_supports_modifier(plane, modifier))\n\t\treturn false;\n\n\tswitch (format) {\n\tcase DRM_FORMAT_XRGB8888:\n\tcase DRM_FORMAT_XBGR8888:\n\tcase DRM_FORMAT_ARGB8888:\n\tcase DRM_FORMAT_ABGR8888:\n\t\tif (intel_fb_is_ccs_modifier(modifier))\n\t\t\treturn true;\n\t\tfallthrough;\n\tcase DRM_FORMAT_RGB565:\n\tcase DRM_FORMAT_XRGB2101010:\n\tcase DRM_FORMAT_XBGR2101010:\n\tcase DRM_FORMAT_ARGB2101010:\n\tcase DRM_FORMAT_ABGR2101010:\n\tcase DRM_FORMAT_YUYV:\n\tcase DRM_FORMAT_YVYU:\n\tcase DRM_FORMAT_UYVY:\n\tcase DRM_FORMAT_VYUY:\n\tcase DRM_FORMAT_NV12:\n\tcase DRM_FORMAT_XYUV8888:\n\tcase DRM_FORMAT_P010:\n\tcase DRM_FORMAT_P012:\n\tcase DRM_FORMAT_P016:\n\tcase DRM_FORMAT_XVYU2101010:\n\t\tif (modifier == I915_FORMAT_MOD_Yf_TILED)\n\t\t\treturn true;\n\t\tfallthrough;\n\tcase DRM_FORMAT_C8:\n\tcase DRM_FORMAT_XBGR16161616F:\n\tcase DRM_FORMAT_ABGR16161616F:\n\tcase DRM_FORMAT_XRGB16161616F:\n\tcase DRM_FORMAT_ARGB16161616F:\n\tcase DRM_FORMAT_Y210:\n\tcase DRM_FORMAT_Y212:\n\tcase DRM_FORMAT_Y216:\n\tcase DRM_FORMAT_XVYU12_16161616:\n\tcase DRM_FORMAT_XVYU16161616:\n\t\tif (modifier == DRM_FORMAT_MOD_LINEAR ||\n\t\t    modifier == I915_FORMAT_MOD_X_TILED ||\n\t\t    modifier == I915_FORMAT_MOD_Y_TILED)\n\t\t\treturn true;\n\t\tfallthrough;\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nstatic bool gen12_plane_format_mod_supported(struct drm_plane *_plane,\n\t\t\t\t\t     u32 format, u64 modifier)\n{\n\tstruct intel_plane *plane = to_intel_plane(_plane);\n\n\tif (!intel_fb_plane_supports_modifier(plane, modifier))\n\t\treturn false;\n\n\tswitch (format) {\n\tcase DRM_FORMAT_XRGB8888:\n\tcase DRM_FORMAT_XBGR8888:\n\tcase DRM_FORMAT_ARGB8888:\n\tcase DRM_FORMAT_ABGR8888:\n\t\tif (intel_fb_is_ccs_modifier(modifier))\n\t\t\treturn true;\n\t\tfallthrough;\n\tcase DRM_FORMAT_YUYV:\n\tcase DRM_FORMAT_YVYU:\n\tcase DRM_FORMAT_UYVY:\n\tcase DRM_FORMAT_VYUY:\n\tcase DRM_FORMAT_NV12:\n\tcase DRM_FORMAT_XYUV8888:\n\tcase DRM_FORMAT_P010:\n\tcase DRM_FORMAT_P012:\n\tcase DRM_FORMAT_P016:\n\t\tif (intel_fb_is_mc_ccs_modifier(modifier))\n\t\t\treturn true;\n\t\tfallthrough;\n\tcase DRM_FORMAT_RGB565:\n\tcase DRM_FORMAT_XRGB2101010:\n\tcase DRM_FORMAT_XBGR2101010:\n\tcase DRM_FORMAT_ARGB2101010:\n\tcase DRM_FORMAT_ABGR2101010:\n\tcase DRM_FORMAT_XVYU2101010:\n\tcase DRM_FORMAT_C8:\n\tcase DRM_FORMAT_XBGR16161616F:\n\tcase DRM_FORMAT_ABGR16161616F:\n\tcase DRM_FORMAT_XRGB16161616F:\n\tcase DRM_FORMAT_ARGB16161616F:\n\tcase DRM_FORMAT_Y210:\n\tcase DRM_FORMAT_Y212:\n\tcase DRM_FORMAT_Y216:\n\tcase DRM_FORMAT_XVYU12_16161616:\n\tcase DRM_FORMAT_XVYU16161616:\n\t\tif (!intel_fb_is_ccs_modifier(modifier))\n\t\t\treturn true;\n\t\tfallthrough;\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nstatic const struct drm_plane_funcs skl_plane_funcs = {\n\t.update_plane = drm_atomic_helper_update_plane,\n\t.disable_plane = drm_atomic_helper_disable_plane,\n\t.destroy = intel_plane_destroy,\n\t.atomic_duplicate_state = intel_plane_duplicate_state,\n\t.atomic_destroy_state = intel_plane_destroy_state,\n\t.format_mod_supported = skl_plane_format_mod_supported,\n};\n\nstatic const struct drm_plane_funcs gen12_plane_funcs = {\n\t.update_plane = drm_atomic_helper_update_plane,\n\t.disable_plane = drm_atomic_helper_disable_plane,\n\t.destroy = intel_plane_destroy,\n\t.atomic_duplicate_state = intel_plane_duplicate_state,\n\t.atomic_destroy_state = intel_plane_destroy_state,\n\t.format_mod_supported = gen12_plane_format_mod_supported,\n};\n\nstatic void\nskl_plane_enable_flip_done(struct intel_plane *plane)\n{\n\tstruct drm_i915_private *i915 = to_i915(plane->base.dev);\n\tenum pipe pipe = plane->pipe;\n\n\tspin_lock_irq(&i915->irq_lock);\n\tbdw_enable_pipe_irq(i915, pipe, GEN9_PIPE_PLANE_FLIP_DONE(plane->id));\n\tspin_unlock_irq(&i915->irq_lock);\n}\n\nstatic void\nskl_plane_disable_flip_done(struct intel_plane *plane)\n{\n\tstruct drm_i915_private *i915 = to_i915(plane->base.dev);\n\tenum pipe pipe = plane->pipe;\n\n\tspin_lock_irq(&i915->irq_lock);\n\tbdw_disable_pipe_irq(i915, pipe, GEN9_PIPE_PLANE_FLIP_DONE(plane->id));\n\tspin_unlock_irq(&i915->irq_lock);\n}\n\nstatic bool skl_plane_has_rc_ccs(struct drm_i915_private *i915,\n\t\t\t\t enum pipe pipe, enum plane_id plane_id)\n{\n\t \n\tif (IS_MTL_GRAPHICS_STEP(i915, M, STEP_A0, STEP_B0) ||\n\t    IS_MTL_GRAPHICS_STEP(i915, P, STEP_A0, STEP_B0))\n\t\treturn false;\n\n\t \n\tif (IS_ALDERLAKE_P(i915) && IS_DISPLAY_STEP(i915, STEP_A0, STEP_B0))\n\t\treturn false;\n\n\tif (DISPLAY_VER(i915) >= 11)\n\t\treturn true;\n\n\tif (IS_GEMINILAKE(i915))\n\t\treturn pipe != PIPE_C;\n\n\treturn pipe != PIPE_C &&\n\t\t(plane_id == PLANE_PRIMARY ||\n\t\t plane_id == PLANE_SPRITE0);\n}\n\nstatic bool gen12_plane_has_mc_ccs(struct drm_i915_private *i915,\n\t\t\t\t   enum plane_id plane_id)\n{\n\tif (DISPLAY_VER(i915) < 12)\n\t\treturn false;\n\n\t \n\tif (IS_DG1(i915) || IS_ROCKETLAKE(i915) ||\n\t\t(IS_TIGERLAKE(i915) && IS_DISPLAY_STEP(i915, STEP_A0, STEP_D0)))\n\t\treturn false;\n\n\t \n\tif (IS_ALDERLAKE_P(i915) && IS_DISPLAY_STEP(i915, STEP_A0, STEP_B0))\n\t\treturn false;\n\n\t \n\tif (IS_DG2_DISPLAY_STEP(i915, STEP_A0, STEP_C0))\n\t\treturn false;\n\n\treturn plane_id < PLANE_SPRITE4;\n}\n\nstatic u8 skl_get_plane_caps(struct drm_i915_private *i915,\n\t\t\t     enum pipe pipe, enum plane_id plane_id)\n{\n\tu8 caps = INTEL_PLANE_CAP_TILING_X;\n\n\tif (DISPLAY_VER(i915) < 13 || IS_ALDERLAKE_P(i915))\n\t\tcaps |= INTEL_PLANE_CAP_TILING_Y;\n\tif (DISPLAY_VER(i915) < 12)\n\t\tcaps |= INTEL_PLANE_CAP_TILING_Yf;\n\tif (HAS_4TILE(i915))\n\t\tcaps |= INTEL_PLANE_CAP_TILING_4;\n\n\tif (skl_plane_has_rc_ccs(i915, pipe, plane_id)) {\n\t\tcaps |= INTEL_PLANE_CAP_CCS_RC;\n\t\tif (DISPLAY_VER(i915) >= 12)\n\t\t\tcaps |= INTEL_PLANE_CAP_CCS_RC_CC;\n\t}\n\n\tif (gen12_plane_has_mc_ccs(i915, plane_id))\n\t\tcaps |= INTEL_PLANE_CAP_CCS_MC;\n\n\treturn caps;\n}\n\nstruct intel_plane *\nskl_universal_plane_create(struct drm_i915_private *dev_priv,\n\t\t\t   enum pipe pipe, enum plane_id plane_id)\n{\n\tconst struct drm_plane_funcs *plane_funcs;\n\tstruct intel_plane *plane;\n\tenum drm_plane_type plane_type;\n\tunsigned int supported_rotations;\n\tunsigned int supported_csc;\n\tconst u64 *modifiers;\n\tconst u32 *formats;\n\tint num_formats;\n\tint ret;\n\n\tplane = intel_plane_alloc();\n\tif (IS_ERR(plane))\n\t\treturn plane;\n\n\tplane->pipe = pipe;\n\tplane->id = plane_id;\n\tplane->frontbuffer_bit = INTEL_FRONTBUFFER(pipe, plane_id);\n\n\tintel_fbc_add_plane(skl_plane_fbc(dev_priv, pipe, plane_id), plane);\n\n\tif (DISPLAY_VER(dev_priv) >= 11) {\n\t\tplane->min_width = icl_plane_min_width;\n\t\tif (icl_is_hdr_plane(dev_priv, plane_id))\n\t\t\tplane->max_width = icl_hdr_plane_max_width;\n\t\telse\n\t\t\tplane->max_width = icl_sdr_plane_max_width;\n\t\tplane->max_height = icl_plane_max_height;\n\t\tplane->min_cdclk = icl_plane_min_cdclk;\n\t} else if (DISPLAY_VER(dev_priv) >= 10) {\n\t\tplane->max_width = glk_plane_max_width;\n\t\tplane->max_height = skl_plane_max_height;\n\t\tplane->min_cdclk = glk_plane_min_cdclk;\n\t} else {\n\t\tplane->max_width = skl_plane_max_width;\n\t\tplane->max_height = skl_plane_max_height;\n\t\tplane->min_cdclk = skl_plane_min_cdclk;\n\t}\n\n\tplane->max_stride = skl_plane_max_stride;\n\tif (DISPLAY_VER(dev_priv) >= 11) {\n\t\tplane->update_noarm = icl_plane_update_noarm;\n\t\tplane->update_arm = icl_plane_update_arm;\n\t\tplane->disable_arm = icl_plane_disable_arm;\n\t} else {\n\t\tplane->update_noarm = skl_plane_update_noarm;\n\t\tplane->update_arm = skl_plane_update_arm;\n\t\tplane->disable_arm = skl_plane_disable_arm;\n\t}\n\tplane->get_hw_state = skl_plane_get_hw_state;\n\tplane->check_plane = skl_plane_check;\n\n\tif (plane_id == PLANE_PRIMARY) {\n\t\tplane->need_async_flip_disable_wa = IS_DISPLAY_VER(dev_priv,\n\t\t\t\t\t\t\t\t   9, 10);\n\t\tplane->async_flip = skl_plane_async_flip;\n\t\tplane->enable_flip_done = skl_plane_enable_flip_done;\n\t\tplane->disable_flip_done = skl_plane_disable_flip_done;\n\t}\n\n\tif (DISPLAY_VER(dev_priv) >= 11)\n\t\tformats = icl_get_plane_formats(dev_priv, pipe,\n\t\t\t\t\t\tplane_id, &num_formats);\n\telse if (DISPLAY_VER(dev_priv) >= 10)\n\t\tformats = glk_get_plane_formats(dev_priv, pipe,\n\t\t\t\t\t\tplane_id, &num_formats);\n\telse\n\t\tformats = skl_get_plane_formats(dev_priv, pipe,\n\t\t\t\t\t\tplane_id, &num_formats);\n\n\tif (DISPLAY_VER(dev_priv) >= 12)\n\t\tplane_funcs = &gen12_plane_funcs;\n\telse\n\t\tplane_funcs = &skl_plane_funcs;\n\n\tif (plane_id == PLANE_PRIMARY)\n\t\tplane_type = DRM_PLANE_TYPE_PRIMARY;\n\telse\n\t\tplane_type = DRM_PLANE_TYPE_OVERLAY;\n\n\tmodifiers = intel_fb_plane_get_modifiers(dev_priv,\n\t\t\t\t\t\t skl_get_plane_caps(dev_priv, pipe, plane_id));\n\n\tret = drm_universal_plane_init(&dev_priv->drm, &plane->base,\n\t\t\t\t       0, plane_funcs,\n\t\t\t\t       formats, num_formats, modifiers,\n\t\t\t\t       plane_type,\n\t\t\t\t       \"plane %d%c\", plane_id + 1,\n\t\t\t\t       pipe_name(pipe));\n\n\tkfree(modifiers);\n\n\tif (ret)\n\t\tgoto fail;\n\n\tif (DISPLAY_VER(dev_priv) >= 13)\n\t\tsupported_rotations = DRM_MODE_ROTATE_0 | DRM_MODE_ROTATE_180;\n\telse\n\t\tsupported_rotations =\n\t\t\tDRM_MODE_ROTATE_0 | DRM_MODE_ROTATE_90 |\n\t\t\tDRM_MODE_ROTATE_180 | DRM_MODE_ROTATE_270;\n\n\tif (DISPLAY_VER(dev_priv) >= 11)\n\t\tsupported_rotations |= DRM_MODE_REFLECT_X;\n\n\tdrm_plane_create_rotation_property(&plane->base,\n\t\t\t\t\t   DRM_MODE_ROTATE_0,\n\t\t\t\t\t   supported_rotations);\n\n\tsupported_csc = BIT(DRM_COLOR_YCBCR_BT601) | BIT(DRM_COLOR_YCBCR_BT709);\n\n\tif (DISPLAY_VER(dev_priv) >= 10)\n\t\tsupported_csc |= BIT(DRM_COLOR_YCBCR_BT2020);\n\n\tdrm_plane_create_color_properties(&plane->base,\n\t\t\t\t\t  supported_csc,\n\t\t\t\t\t  BIT(DRM_COLOR_YCBCR_LIMITED_RANGE) |\n\t\t\t\t\t  BIT(DRM_COLOR_YCBCR_FULL_RANGE),\n\t\t\t\t\t  DRM_COLOR_YCBCR_BT709,\n\t\t\t\t\t  DRM_COLOR_YCBCR_LIMITED_RANGE);\n\n\tdrm_plane_create_alpha_property(&plane->base);\n\tdrm_plane_create_blend_mode_property(&plane->base,\n\t\t\t\t\t     BIT(DRM_MODE_BLEND_PIXEL_NONE) |\n\t\t\t\t\t     BIT(DRM_MODE_BLEND_PREMULTI) |\n\t\t\t\t\t     BIT(DRM_MODE_BLEND_COVERAGE));\n\n\tdrm_plane_create_zpos_immutable_property(&plane->base, plane_id);\n\n\tif (DISPLAY_VER(dev_priv) >= 12)\n\t\tdrm_plane_enable_fb_damage_clips(&plane->base);\n\n\tif (DISPLAY_VER(dev_priv) >= 11)\n\t\tdrm_plane_create_scaling_filter_property(&plane->base,\n\t\t\t\t\t\tBIT(DRM_SCALING_FILTER_DEFAULT) |\n\t\t\t\t\t\tBIT(DRM_SCALING_FILTER_NEAREST_NEIGHBOR));\n\n\tintel_plane_helper_add(plane);\n\n\treturn plane;\n\nfail:\n\tintel_plane_free(plane);\n\n\treturn ERR_PTR(ret);\n}\n\nvoid\nskl_get_initial_plane_config(struct intel_crtc *crtc,\n\t\t\t     struct intel_initial_plane_config *plane_config)\n{\n\tstruct intel_crtc_state *crtc_state = to_intel_crtc_state(crtc->base.state);\n\tstruct drm_device *dev = crtc->base.dev;\n\tstruct drm_i915_private *dev_priv = to_i915(dev);\n\tstruct intel_plane *plane = to_intel_plane(crtc->base.primary);\n\tenum plane_id plane_id = plane->id;\n\tenum pipe pipe;\n\tu32 val, base, offset, stride_mult, tiling, alpha;\n\tint fourcc, pixel_format;\n\tunsigned int aligned_height;\n\tstruct drm_framebuffer *fb;\n\tstruct intel_framebuffer *intel_fb;\n\tstatic_assert(PLANE_CTL_TILED_YF == PLANE_CTL_TILED_4);\n\n\tif (!plane->get_hw_state(plane, &pipe))\n\t\treturn;\n\n\tdrm_WARN_ON(dev, pipe != crtc->pipe);\n\n\tif (crtc_state->bigjoiner_pipes) {\n\t\tdrm_dbg_kms(&dev_priv->drm,\n\t\t\t    \"Unsupported bigjoiner configuration for initial FB\\n\");\n\t\treturn;\n\t}\n\n\tintel_fb = kzalloc(sizeof(*intel_fb), GFP_KERNEL);\n\tif (!intel_fb) {\n\t\tdrm_dbg_kms(&dev_priv->drm, \"failed to alloc fb\\n\");\n\t\treturn;\n\t}\n\n\tfb = &intel_fb->base;\n\n\tfb->dev = dev;\n\n\tval = intel_de_read(dev_priv, PLANE_CTL(pipe, plane_id));\n\n\tif (DISPLAY_VER(dev_priv) >= 11)\n\t\tpixel_format = val & PLANE_CTL_FORMAT_MASK_ICL;\n\telse\n\t\tpixel_format = val & PLANE_CTL_FORMAT_MASK_SKL;\n\n\tif (DISPLAY_VER(dev_priv) >= 10) {\n\t\tu32 color_ctl;\n\n\t\tcolor_ctl = intel_de_read(dev_priv, PLANE_COLOR_CTL(pipe, plane_id));\n\t\talpha = REG_FIELD_GET(PLANE_COLOR_ALPHA_MASK, color_ctl);\n\t} else {\n\t\talpha = REG_FIELD_GET(PLANE_CTL_ALPHA_MASK, val);\n\t}\n\n\tfourcc = skl_format_to_fourcc(pixel_format,\n\t\t\t\t      val & PLANE_CTL_ORDER_RGBX, alpha);\n\tfb->format = drm_format_info(fourcc);\n\n\ttiling = val & PLANE_CTL_TILED_MASK;\n\tswitch (tiling) {\n\tcase PLANE_CTL_TILED_LINEAR:\n\t\tfb->modifier = DRM_FORMAT_MOD_LINEAR;\n\t\tbreak;\n\tcase PLANE_CTL_TILED_X:\n\t\tplane_config->tiling = I915_TILING_X;\n\t\tfb->modifier = I915_FORMAT_MOD_X_TILED;\n\t\tbreak;\n\tcase PLANE_CTL_TILED_Y:\n\t\tplane_config->tiling = I915_TILING_Y;\n\t\tif (val & PLANE_CTL_RENDER_DECOMPRESSION_ENABLE)\n\t\t\tif (DISPLAY_VER(dev_priv) >= 14)\n\t\t\t\tfb->modifier = I915_FORMAT_MOD_4_TILED_MTL_RC_CCS;\n\t\t\telse if (DISPLAY_VER(dev_priv) >= 12)\n\t\t\t\tfb->modifier = I915_FORMAT_MOD_Y_TILED_GEN12_RC_CCS;\n\t\t\telse\n\t\t\t\tfb->modifier = I915_FORMAT_MOD_Y_TILED_CCS;\n\t\telse if (val & PLANE_CTL_MEDIA_DECOMPRESSION_ENABLE)\n\t\t\tif (DISPLAY_VER(dev_priv) >= 14)\n\t\t\t\tfb->modifier = I915_FORMAT_MOD_4_TILED_MTL_MC_CCS;\n\t\t\telse\n\t\t\t\tfb->modifier = I915_FORMAT_MOD_Y_TILED_GEN12_MC_CCS;\n\t\telse\n\t\t\tfb->modifier = I915_FORMAT_MOD_Y_TILED;\n\t\tbreak;\n\tcase PLANE_CTL_TILED_YF:  \n\t\tif (HAS_4TILE(dev_priv)) {\n\t\t\tu32 rc_mask = PLANE_CTL_RENDER_DECOMPRESSION_ENABLE |\n\t\t\t\t      PLANE_CTL_CLEAR_COLOR_DISABLE;\n\n\t\t\tif ((val & rc_mask) == rc_mask)\n\t\t\t\tfb->modifier = I915_FORMAT_MOD_4_TILED_DG2_RC_CCS;\n\t\t\telse if (val & PLANE_CTL_MEDIA_DECOMPRESSION_ENABLE)\n\t\t\t\tfb->modifier = I915_FORMAT_MOD_4_TILED_DG2_MC_CCS;\n\t\t\telse if (val & PLANE_CTL_RENDER_DECOMPRESSION_ENABLE)\n\t\t\t\tfb->modifier = I915_FORMAT_MOD_4_TILED_DG2_RC_CCS_CC;\n\t\t\telse\n\t\t\t\tfb->modifier = I915_FORMAT_MOD_4_TILED;\n\t\t} else {\n\t\t\tif (val & PLANE_CTL_RENDER_DECOMPRESSION_ENABLE)\n\t\t\t\tfb->modifier = I915_FORMAT_MOD_Yf_TILED_CCS;\n\t\t\telse\n\t\t\t\tfb->modifier = I915_FORMAT_MOD_Yf_TILED;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tMISSING_CASE(tiling);\n\t\tgoto error;\n\t}\n\n\tif (!dev_priv->params.enable_dpt &&\n\t    intel_fb_modifier_uses_dpt(dev_priv, fb->modifier)) {\n\t\tdrm_dbg_kms(&dev_priv->drm, \"DPT disabled, skipping initial FB\\n\");\n\t\tgoto error;\n\t}\n\n\t \n\tswitch (val & PLANE_CTL_ROTATE_MASK) {\n\tcase PLANE_CTL_ROTATE_0:\n\t\tplane_config->rotation = DRM_MODE_ROTATE_0;\n\t\tbreak;\n\tcase PLANE_CTL_ROTATE_90:\n\t\tplane_config->rotation = DRM_MODE_ROTATE_270;\n\t\tbreak;\n\tcase PLANE_CTL_ROTATE_180:\n\t\tplane_config->rotation = DRM_MODE_ROTATE_180;\n\t\tbreak;\n\tcase PLANE_CTL_ROTATE_270:\n\t\tplane_config->rotation = DRM_MODE_ROTATE_90;\n\t\tbreak;\n\t}\n\n\tif (DISPLAY_VER(dev_priv) >= 11 && val & PLANE_CTL_FLIP_HORIZONTAL)\n\t\tplane_config->rotation |= DRM_MODE_REFLECT_X;\n\n\t \n\tif (drm_rotation_90_or_270(plane_config->rotation))\n\t\tgoto error;\n\n\tbase = intel_de_read(dev_priv, PLANE_SURF(pipe, plane_id)) & PLANE_SURF_ADDR_MASK;\n\tplane_config->base = base;\n\n\toffset = intel_de_read(dev_priv, PLANE_OFFSET(pipe, plane_id));\n\tdrm_WARN_ON(&dev_priv->drm, offset != 0);\n\n\tval = intel_de_read(dev_priv, PLANE_SIZE(pipe, plane_id));\n\tfb->height = REG_FIELD_GET(PLANE_HEIGHT_MASK, val) + 1;\n\tfb->width = REG_FIELD_GET(PLANE_WIDTH_MASK, val) + 1;\n\n\tval = intel_de_read(dev_priv, PLANE_STRIDE(pipe, plane_id));\n\tstride_mult = skl_plane_stride_mult(fb, 0, DRM_MODE_ROTATE_0);\n\n\tfb->pitches[0] = REG_FIELD_GET(PLANE_STRIDE__MASK, val) * stride_mult;\n\n\taligned_height = intel_fb_align_height(fb, 0, fb->height);\n\n\tplane_config->size = fb->pitches[0] * aligned_height;\n\n\tdrm_dbg_kms(&dev_priv->drm,\n\t\t    \"%s/%s with fb: size=%dx%d@%d, offset=%x, pitch %d, size 0x%x\\n\",\n\t\t    crtc->base.name, plane->base.name, fb->width, fb->height,\n\t\t    fb->format->cpp[0] * 8, base, fb->pitches[0],\n\t\t    plane_config->size);\n\n\tplane_config->fb = intel_fb;\n\treturn;\n\nerror:\n\tkfree(intel_fb);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}