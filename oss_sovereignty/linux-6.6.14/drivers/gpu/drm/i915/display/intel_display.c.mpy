{
  "module_name": "intel_display.c",
  "hash_id": "c2d69b5ef9aedbc00be200bff7a8a0db2f931fc57f516f0a98273926409bc6b1",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/i915/display/intel_display.c",
  "human_readable_source": " \n\n#include <linux/dma-resv.h>\n#include <linux/i2c.h>\n#include <linux/input.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/string_helpers.h>\n\n#include <drm/display/drm_dp_helper.h>\n#include <drm/drm_atomic.h>\n#include <drm/drm_atomic_helper.h>\n#include <drm/drm_atomic_uapi.h>\n#include <drm/drm_damage_helper.h>\n#include <drm/drm_edid.h>\n#include <drm/drm_fourcc.h>\n#include <drm/drm_probe_helper.h>\n#include <drm/drm_rect.h>\n\n#include \"gem/i915_gem_lmem.h\"\n#include \"gem/i915_gem_object.h\"\n\n#include \"g4x_dp.h\"\n#include \"g4x_hdmi.h\"\n#include \"hsw_ips.h\"\n#include \"i915_drv.h\"\n#include \"i915_reg.h\"\n#include \"i915_utils.h\"\n#include \"i9xx_plane.h\"\n#include \"i9xx_wm.h\"\n#include \"intel_atomic.h\"\n#include \"intel_atomic_plane.h\"\n#include \"intel_audio.h\"\n#include \"intel_bw.h\"\n#include \"intel_cdclk.h\"\n#include \"intel_clock_gating.h\"\n#include \"intel_color.h\"\n#include \"intel_crt.h\"\n#include \"intel_crtc.h\"\n#include \"intel_crtc_state_dump.h\"\n#include \"intel_ddi.h\"\n#include \"intel_de.h\"\n#include \"intel_display_driver.h\"\n#include \"intel_display_power.h\"\n#include \"intel_display_types.h\"\n#include \"intel_dmc.h\"\n#include \"intel_dp.h\"\n#include \"intel_dp_link_training.h\"\n#include \"intel_dp_mst.h\"\n#include \"intel_dpio_phy.h\"\n#include \"intel_dpll.h\"\n#include \"intel_dpll_mgr.h\"\n#include \"intel_dpt.h\"\n#include \"intel_drrs.h\"\n#include \"intel_dsi.h\"\n#include \"intel_dvo.h\"\n#include \"intel_fb.h\"\n#include \"intel_fbc.h\"\n#include \"intel_fbdev.h\"\n#include \"intel_fdi.h\"\n#include \"intel_fifo_underrun.h\"\n#include \"intel_frontbuffer.h\"\n#include \"intel_hdmi.h\"\n#include \"intel_hotplug.h\"\n#include \"intel_lvds.h\"\n#include \"intel_lvds_regs.h\"\n#include \"intel_modeset_setup.h\"\n#include \"intel_modeset_verify.h\"\n#include \"intel_overlay.h\"\n#include \"intel_panel.h\"\n#include \"intel_pch_display.h\"\n#include \"intel_pch_refclk.h\"\n#include \"intel_pcode.h\"\n#include \"intel_pipe_crc.h\"\n#include \"intel_plane_initial.h\"\n#include \"intel_pmdemand.h\"\n#include \"intel_pps.h\"\n#include \"intel_psr.h\"\n#include \"intel_sdvo.h\"\n#include \"intel_snps_phy.h\"\n#include \"intel_tc.h\"\n#include \"intel_tv.h\"\n#include \"intel_vblank.h\"\n#include \"intel_vdsc.h\"\n#include \"intel_vdsc_regs.h\"\n#include \"intel_vga.h\"\n#include \"intel_vrr.h\"\n#include \"intel_wm.h\"\n#include \"skl_scaler.h\"\n#include \"skl_universal_plane.h\"\n#include \"skl_watermark.h\"\n#include \"vlv_dsi.h\"\n#include \"vlv_dsi_pll.h\"\n#include \"vlv_dsi_regs.h\"\n#include \"vlv_sideband.h\"\n\nstatic void intel_set_transcoder_timings(const struct intel_crtc_state *crtc_state);\nstatic void intel_set_pipe_src_size(const struct intel_crtc_state *crtc_state);\nstatic void hsw_set_transconf(const struct intel_crtc_state *crtc_state);\nstatic void bdw_set_pipe_misc(const struct intel_crtc_state *crtc_state);\n\n \nint vlv_get_hpll_vco(struct drm_i915_private *dev_priv)\n{\n\tint hpll_freq, vco_freq[] = { 800, 1600, 2000, 2400 };\n\n\t \n\thpll_freq = vlv_cck_read(dev_priv, CCK_FUSE_REG) &\n\t\tCCK_FUSE_HPLL_FREQ_MASK;\n\n\treturn vco_freq[hpll_freq] * 1000;\n}\n\nint vlv_get_cck_clock(struct drm_i915_private *dev_priv,\n\t\t      const char *name, u32 reg, int ref_freq)\n{\n\tu32 val;\n\tint divider;\n\n\tval = vlv_cck_read(dev_priv, reg);\n\tdivider = val & CCK_FREQUENCY_VALUES;\n\n\tdrm_WARN(&dev_priv->drm, (val & CCK_FREQUENCY_STATUS) !=\n\t\t (divider << CCK_FREQUENCY_STATUS_SHIFT),\n\t\t \"%s change in progress\\n\", name);\n\n\treturn DIV_ROUND_CLOSEST(ref_freq << 1, divider + 1);\n}\n\nint vlv_get_cck_clock_hpll(struct drm_i915_private *dev_priv,\n\t\t\t   const char *name, u32 reg)\n{\n\tint hpll;\n\n\tvlv_cck_get(dev_priv);\n\n\tif (dev_priv->hpll_freq == 0)\n\t\tdev_priv->hpll_freq = vlv_get_hpll_vco(dev_priv);\n\n\thpll = vlv_get_cck_clock(dev_priv, name, reg, dev_priv->hpll_freq);\n\n\tvlv_cck_put(dev_priv);\n\n\treturn hpll;\n}\n\nvoid intel_update_czclk(struct drm_i915_private *dev_priv)\n{\n\tif (!(IS_VALLEYVIEW(dev_priv) || IS_CHERRYVIEW(dev_priv)))\n\t\treturn;\n\n\tdev_priv->czclk_freq = vlv_get_cck_clock_hpll(dev_priv, \"czclk\",\n\t\t\t\t\t\t      CCK_CZ_CLOCK_CONTROL);\n\n\tdrm_dbg(&dev_priv->drm, \"CZ clock rate: %d kHz\\n\",\n\t\tdev_priv->czclk_freq);\n}\n\nstatic bool is_hdr_mode(const struct intel_crtc_state *crtc_state)\n{\n\treturn (crtc_state->active_planes &\n\t\t~(icl_hdr_plane_mask() | BIT(PLANE_CURSOR))) == 0;\n}\n\n \nstatic void\nskl_wa_827(struct drm_i915_private *dev_priv, enum pipe pipe, bool enable)\n{\n\tif (enable)\n\t\tintel_de_rmw(dev_priv, CLKGATE_DIS_PSL(pipe),\n\t\t\t     0, DUPS1_GATING_DIS | DUPS2_GATING_DIS);\n\telse\n\t\tintel_de_rmw(dev_priv, CLKGATE_DIS_PSL(pipe),\n\t\t\t     DUPS1_GATING_DIS | DUPS2_GATING_DIS, 0);\n}\n\n \nstatic void\nicl_wa_scalerclkgating(struct drm_i915_private *dev_priv, enum pipe pipe,\n\t\t       bool enable)\n{\n\tif (enable)\n\t\tintel_de_rmw(dev_priv, CLKGATE_DIS_PSL(pipe), 0, DPFR_GATING_DIS);\n\telse\n\t\tintel_de_rmw(dev_priv, CLKGATE_DIS_PSL(pipe), DPFR_GATING_DIS, 0);\n}\n\n \nstatic void\nicl_wa_cursorclkgating(struct drm_i915_private *dev_priv, enum pipe pipe,\n\t\t       bool enable)\n{\n\tintel_de_rmw(dev_priv, CLKGATE_DIS_PSL(pipe), CURSOR_GATING_DIS,\n\t\t     enable ? CURSOR_GATING_DIS : 0);\n}\n\nstatic bool\nis_trans_port_sync_slave(const struct intel_crtc_state *crtc_state)\n{\n\treturn crtc_state->master_transcoder != INVALID_TRANSCODER;\n}\n\nbool\nis_trans_port_sync_master(const struct intel_crtc_state *crtc_state)\n{\n\treturn crtc_state->sync_mode_slaves_mask != 0;\n}\n\nbool\nis_trans_port_sync_mode(const struct intel_crtc_state *crtc_state)\n{\n\treturn is_trans_port_sync_master(crtc_state) ||\n\t\tis_trans_port_sync_slave(crtc_state);\n}\n\nstatic enum pipe bigjoiner_master_pipe(const struct intel_crtc_state *crtc_state)\n{\n\treturn ffs(crtc_state->bigjoiner_pipes) - 1;\n}\n\nu8 intel_crtc_bigjoiner_slave_pipes(const struct intel_crtc_state *crtc_state)\n{\n\tif (crtc_state->bigjoiner_pipes)\n\t\treturn crtc_state->bigjoiner_pipes & ~BIT(bigjoiner_master_pipe(crtc_state));\n\telse\n\t\treturn 0;\n}\n\nbool intel_crtc_is_bigjoiner_slave(const struct intel_crtc_state *crtc_state)\n{\n\tstruct intel_crtc *crtc = to_intel_crtc(crtc_state->uapi.crtc);\n\n\treturn crtc_state->bigjoiner_pipes &&\n\t\tcrtc->pipe != bigjoiner_master_pipe(crtc_state);\n}\n\nbool intel_crtc_is_bigjoiner_master(const struct intel_crtc_state *crtc_state)\n{\n\tstruct intel_crtc *crtc = to_intel_crtc(crtc_state->uapi.crtc);\n\n\treturn crtc_state->bigjoiner_pipes &&\n\t\tcrtc->pipe == bigjoiner_master_pipe(crtc_state);\n}\n\nstatic int intel_bigjoiner_num_pipes(const struct intel_crtc_state *crtc_state)\n{\n\treturn hweight8(crtc_state->bigjoiner_pipes);\n}\n\nstruct intel_crtc *intel_master_crtc(const struct intel_crtc_state *crtc_state)\n{\n\tstruct drm_i915_private *i915 = to_i915(crtc_state->uapi.crtc->dev);\n\n\tif (intel_crtc_is_bigjoiner_slave(crtc_state))\n\t\treturn intel_crtc_for_pipe(i915, bigjoiner_master_pipe(crtc_state));\n\telse\n\t\treturn to_intel_crtc(crtc_state->uapi.crtc);\n}\n\nstatic void\nintel_wait_for_pipe_off(const struct intel_crtc_state *old_crtc_state)\n{\n\tstruct intel_crtc *crtc = to_intel_crtc(old_crtc_state->uapi.crtc);\n\tstruct drm_i915_private *dev_priv = to_i915(crtc->base.dev);\n\n\tif (DISPLAY_VER(dev_priv) >= 4) {\n\t\tenum transcoder cpu_transcoder = old_crtc_state->cpu_transcoder;\n\n\t\t \n\t\tif (intel_de_wait_for_clear(dev_priv, TRANSCONF(cpu_transcoder),\n\t\t\t\t\t    TRANSCONF_STATE_ENABLE, 100))\n\t\t\tdrm_WARN(&dev_priv->drm, 1, \"pipe_off wait timed out\\n\");\n\t} else {\n\t\tintel_wait_for_pipe_scanline_stopped(crtc);\n\t}\n}\n\nvoid assert_transcoder(struct drm_i915_private *dev_priv,\n\t\t       enum transcoder cpu_transcoder, bool state)\n{\n\tbool cur_state;\n\tenum intel_display_power_domain power_domain;\n\tintel_wakeref_t wakeref;\n\n\t \n\tif (IS_I830(dev_priv))\n\t\tstate = true;\n\n\tpower_domain = POWER_DOMAIN_TRANSCODER(cpu_transcoder);\n\twakeref = intel_display_power_get_if_enabled(dev_priv, power_domain);\n\tif (wakeref) {\n\t\tu32 val = intel_de_read(dev_priv, TRANSCONF(cpu_transcoder));\n\t\tcur_state = !!(val & TRANSCONF_ENABLE);\n\n\t\tintel_display_power_put(dev_priv, power_domain, wakeref);\n\t} else {\n\t\tcur_state = false;\n\t}\n\n\tI915_STATE_WARN(dev_priv, cur_state != state,\n\t\t\t\"transcoder %s assertion failure (expected %s, current %s)\\n\",\n\t\t\ttranscoder_name(cpu_transcoder), str_on_off(state),\n\t\t\tstr_on_off(cur_state));\n}\n\nstatic void assert_plane(struct intel_plane *plane, bool state)\n{\n\tstruct drm_i915_private *i915 = to_i915(plane->base.dev);\n\tenum pipe pipe;\n\tbool cur_state;\n\n\tcur_state = plane->get_hw_state(plane, &pipe);\n\n\tI915_STATE_WARN(i915, cur_state != state,\n\t\t\t\"%s assertion failure (expected %s, current %s)\\n\",\n\t\t\tplane->base.name, str_on_off(state),\n\t\t\tstr_on_off(cur_state));\n}\n\n#define assert_plane_enabled(p) assert_plane(p, true)\n#define assert_plane_disabled(p) assert_plane(p, false)\n\nstatic void assert_planes_disabled(struct intel_crtc *crtc)\n{\n\tstruct drm_i915_private *dev_priv = to_i915(crtc->base.dev);\n\tstruct intel_plane *plane;\n\n\tfor_each_intel_plane_on_crtc(&dev_priv->drm, crtc, plane)\n\t\tassert_plane_disabled(plane);\n}\n\nvoid vlv_wait_port_ready(struct drm_i915_private *dev_priv,\n\t\t\t struct intel_digital_port *dig_port,\n\t\t\t unsigned int expected_mask)\n{\n\tu32 port_mask;\n\ti915_reg_t dpll_reg;\n\n\tswitch (dig_port->base.port) {\n\tdefault:\n\t\tMISSING_CASE(dig_port->base.port);\n\t\tfallthrough;\n\tcase PORT_B:\n\t\tport_mask = DPLL_PORTB_READY_MASK;\n\t\tdpll_reg = DPLL(0);\n\t\tbreak;\n\tcase PORT_C:\n\t\tport_mask = DPLL_PORTC_READY_MASK;\n\t\tdpll_reg = DPLL(0);\n\t\texpected_mask <<= 4;\n\t\tbreak;\n\tcase PORT_D:\n\t\tport_mask = DPLL_PORTD_READY_MASK;\n\t\tdpll_reg = DPIO_PHY_STATUS;\n\t\tbreak;\n\t}\n\n\tif (intel_de_wait_for_register(dev_priv, dpll_reg,\n\t\t\t\t       port_mask, expected_mask, 1000))\n\t\tdrm_WARN(&dev_priv->drm, 1,\n\t\t\t \"timed out waiting for [ENCODER:%d:%s] port ready: got 0x%x, expected 0x%x\\n\",\n\t\t\t dig_port->base.base.base.id, dig_port->base.base.name,\n\t\t\t intel_de_read(dev_priv, dpll_reg) & port_mask,\n\t\t\t expected_mask);\n}\n\nvoid intel_enable_transcoder(const struct intel_crtc_state *new_crtc_state)\n{\n\tstruct intel_crtc *crtc = to_intel_crtc(new_crtc_state->uapi.crtc);\n\tstruct drm_i915_private *dev_priv = to_i915(crtc->base.dev);\n\tenum transcoder cpu_transcoder = new_crtc_state->cpu_transcoder;\n\tenum pipe pipe = crtc->pipe;\n\ti915_reg_t reg;\n\tu32 val;\n\n\tdrm_dbg_kms(&dev_priv->drm, \"enabling pipe %c\\n\", pipe_name(pipe));\n\n\tassert_planes_disabled(crtc);\n\n\t \n\tif (HAS_GMCH(dev_priv)) {\n\t\tif (intel_crtc_has_type(new_crtc_state, INTEL_OUTPUT_DSI))\n\t\t\tassert_dsi_pll_enabled(dev_priv);\n\t\telse\n\t\t\tassert_pll_enabled(dev_priv, pipe);\n\t} else {\n\t\tif (new_crtc_state->has_pch_encoder) {\n\t\t\t \n\t\t\tassert_fdi_rx_pll_enabled(dev_priv,\n\t\t\t\t\t\t  intel_crtc_pch_transcoder(crtc));\n\t\t\tassert_fdi_tx_pll_enabled(dev_priv,\n\t\t\t\t\t\t  (enum pipe) cpu_transcoder);\n\t\t}\n\t\t \n\t}\n\n\t \n\tif (DISPLAY_VER(dev_priv) == 13)\n\t\tintel_de_rmw(dev_priv, PIPE_ARB_CTL(pipe),\n\t\t\t     0, PIPE_ARB_USE_PROG_SLOTS);\n\n\treg = TRANSCONF(cpu_transcoder);\n\tval = intel_de_read(dev_priv, reg);\n\tif (val & TRANSCONF_ENABLE) {\n\t\t \n\t\tdrm_WARN_ON(&dev_priv->drm, !IS_I830(dev_priv));\n\t\treturn;\n\t}\n\n\tintel_de_write(dev_priv, reg, val | TRANSCONF_ENABLE);\n\tintel_de_posting_read(dev_priv, reg);\n\n\t \n\tif (intel_crtc_max_vblank_count(new_crtc_state) == 0)\n\t\tintel_wait_for_pipe_scanline_moving(crtc);\n}\n\nvoid intel_disable_transcoder(const struct intel_crtc_state *old_crtc_state)\n{\n\tstruct intel_crtc *crtc = to_intel_crtc(old_crtc_state->uapi.crtc);\n\tstruct drm_i915_private *dev_priv = to_i915(crtc->base.dev);\n\tenum transcoder cpu_transcoder = old_crtc_state->cpu_transcoder;\n\tenum pipe pipe = crtc->pipe;\n\ti915_reg_t reg;\n\tu32 val;\n\n\tdrm_dbg_kms(&dev_priv->drm, \"disabling pipe %c\\n\", pipe_name(pipe));\n\n\t \n\tassert_planes_disabled(crtc);\n\n\treg = TRANSCONF(cpu_transcoder);\n\tval = intel_de_read(dev_priv, reg);\n\tif ((val & TRANSCONF_ENABLE) == 0)\n\t\treturn;\n\n\t \n\tif (old_crtc_state->double_wide)\n\t\tval &= ~TRANSCONF_DOUBLE_WIDE;\n\n\t \n\tif (!IS_I830(dev_priv))\n\t\tval &= ~TRANSCONF_ENABLE;\n\n\tif (DISPLAY_VER(dev_priv) >= 14)\n\t\tintel_de_rmw(dev_priv, MTL_CHICKEN_TRANS(cpu_transcoder),\n\t\t\t     FECSTALL_DIS_DPTSTREAM_DPTTG, 0);\n\telse if (DISPLAY_VER(dev_priv) >= 12)\n\t\tintel_de_rmw(dev_priv, CHICKEN_TRANS(cpu_transcoder),\n\t\t\t     FECSTALL_DIS_DPTSTREAM_DPTTG, 0);\n\n\tintel_de_write(dev_priv, reg, val);\n\tif ((val & TRANSCONF_ENABLE) == 0)\n\t\tintel_wait_for_pipe_off(old_crtc_state);\n}\n\nunsigned int intel_rotation_info_size(const struct intel_rotation_info *rot_info)\n{\n\tunsigned int size = 0;\n\tint i;\n\n\tfor (i = 0 ; i < ARRAY_SIZE(rot_info->plane); i++)\n\t\tsize += rot_info->plane[i].dst_stride * rot_info->plane[i].width;\n\n\treturn size;\n}\n\nunsigned int intel_remapped_info_size(const struct intel_remapped_info *rem_info)\n{\n\tunsigned int size = 0;\n\tint i;\n\n\tfor (i = 0 ; i < ARRAY_SIZE(rem_info->plane); i++) {\n\t\tunsigned int plane_size;\n\n\t\tif (rem_info->plane[i].linear)\n\t\t\tplane_size = rem_info->plane[i].size;\n\t\telse\n\t\t\tplane_size = rem_info->plane[i].dst_stride * rem_info->plane[i].height;\n\n\t\tif (plane_size == 0)\n\t\t\tcontinue;\n\n\t\tif (rem_info->plane_alignment)\n\t\t\tsize = ALIGN(size, rem_info->plane_alignment);\n\n\t\tsize += plane_size;\n\t}\n\n\treturn size;\n}\n\nbool intel_plane_uses_fence(const struct intel_plane_state *plane_state)\n{\n\tstruct intel_plane *plane = to_intel_plane(plane_state->uapi.plane);\n\tstruct drm_i915_private *dev_priv = to_i915(plane->base.dev);\n\n\treturn DISPLAY_VER(dev_priv) < 4 ||\n\t\t(plane->fbc &&\n\t\t plane_state->view.gtt.type == I915_GTT_VIEW_NORMAL);\n}\n\n \nu32 intel_fb_xy_to_linear(int x, int y,\n\t\t\t  const struct intel_plane_state *state,\n\t\t\t  int color_plane)\n{\n\tconst struct drm_framebuffer *fb = state->hw.fb;\n\tunsigned int cpp = fb->format->cpp[color_plane];\n\tunsigned int pitch = state->view.color_plane[color_plane].mapping_stride;\n\n\treturn y * pitch + x * cpp;\n}\n\n \nvoid intel_add_fb_offsets(int *x, int *y,\n\t\t\t  const struct intel_plane_state *state,\n\t\t\t  int color_plane)\n\n{\n\t*x += state->view.color_plane[color_plane].x;\n\t*y += state->view.color_plane[color_plane].y;\n}\n\nu32 intel_plane_fb_max_stride(struct drm_i915_private *dev_priv,\n\t\t\t      u32 pixel_format, u64 modifier)\n{\n\tstruct intel_crtc *crtc;\n\tstruct intel_plane *plane;\n\n\tif (!HAS_DISPLAY(dev_priv))\n\t\treturn 0;\n\n\t \n\tcrtc = intel_first_crtc(dev_priv);\n\tif (!crtc)\n\t\treturn 0;\n\n\tplane = to_intel_plane(crtc->base.primary);\n\n\treturn plane->max_stride(plane, pixel_format, modifier,\n\t\t\t\t DRM_MODE_ROTATE_0);\n}\n\nvoid intel_set_plane_visible(struct intel_crtc_state *crtc_state,\n\t\t\t     struct intel_plane_state *plane_state,\n\t\t\t     bool visible)\n{\n\tstruct intel_plane *plane = to_intel_plane(plane_state->uapi.plane);\n\n\tplane_state->uapi.visible = visible;\n\n\tif (visible)\n\t\tcrtc_state->uapi.plane_mask |= drm_plane_mask(&plane->base);\n\telse\n\t\tcrtc_state->uapi.plane_mask &= ~drm_plane_mask(&plane->base);\n}\n\nvoid intel_plane_fixup_bitmasks(struct intel_crtc_state *crtc_state)\n{\n\tstruct drm_i915_private *dev_priv = to_i915(crtc_state->uapi.crtc->dev);\n\tstruct drm_plane *plane;\n\n\t \n\tcrtc_state->enabled_planes = 0;\n\tcrtc_state->active_planes = 0;\n\n\tdrm_for_each_plane_mask(plane, &dev_priv->drm,\n\t\t\t\tcrtc_state->uapi.plane_mask) {\n\t\tcrtc_state->enabled_planes |= BIT(to_intel_plane(plane)->id);\n\t\tcrtc_state->active_planes |= BIT(to_intel_plane(plane)->id);\n\t}\n}\n\nvoid intel_plane_disable_noatomic(struct intel_crtc *crtc,\n\t\t\t\t  struct intel_plane *plane)\n{\n\tstruct drm_i915_private *dev_priv = to_i915(crtc->base.dev);\n\tstruct intel_crtc_state *crtc_state =\n\t\tto_intel_crtc_state(crtc->base.state);\n\tstruct intel_plane_state *plane_state =\n\t\tto_intel_plane_state(plane->base.state);\n\n\tdrm_dbg_kms(&dev_priv->drm,\n\t\t    \"Disabling [PLANE:%d:%s] on [CRTC:%d:%s]\\n\",\n\t\t    plane->base.base.id, plane->base.name,\n\t\t    crtc->base.base.id, crtc->base.name);\n\n\tintel_set_plane_visible(crtc_state, plane_state, false);\n\tintel_plane_fixup_bitmasks(crtc_state);\n\tcrtc_state->data_rate[plane->id] = 0;\n\tcrtc_state->data_rate_y[plane->id] = 0;\n\tcrtc_state->rel_data_rate[plane->id] = 0;\n\tcrtc_state->rel_data_rate_y[plane->id] = 0;\n\tcrtc_state->min_cdclk[plane->id] = 0;\n\n\tif ((crtc_state->active_planes & ~BIT(PLANE_CURSOR)) == 0 &&\n\t    hsw_ips_disable(crtc_state)) {\n\t\tcrtc_state->ips_enabled = false;\n\t\tintel_crtc_wait_for_next_vblank(crtc);\n\t}\n\n\t \n\tif (HAS_GMCH(dev_priv) &&\n\t    intel_set_memory_cxsr(dev_priv, false))\n\t\tintel_crtc_wait_for_next_vblank(crtc);\n\n\t \n\tif (DISPLAY_VER(dev_priv) == 2 && !crtc_state->active_planes)\n\t\tintel_set_cpu_fifo_underrun_reporting(dev_priv, crtc->pipe, false);\n\n\tintel_plane_disable_arm(plane, crtc_state);\n\tintel_crtc_wait_for_next_vblank(crtc);\n}\n\nunsigned int\nintel_plane_fence_y_offset(const struct intel_plane_state *plane_state)\n{\n\tint x = 0, y = 0;\n\n\tintel_plane_adjust_aligned_offset(&x, &y, plane_state, 0,\n\t\t\t\t\t  plane_state->view.color_plane[0].offset, 0);\n\n\treturn y;\n}\n\nstatic void icl_set_pipe_chicken(const struct intel_crtc_state *crtc_state)\n{\n\tstruct intel_crtc *crtc = to_intel_crtc(crtc_state->uapi.crtc);\n\tstruct drm_i915_private *dev_priv = to_i915(crtc->base.dev);\n\tenum pipe pipe = crtc->pipe;\n\tu32 tmp;\n\n\ttmp = intel_de_read(dev_priv, PIPE_CHICKEN(pipe));\n\n\t \n\ttmp |= PER_PIXEL_ALPHA_BYPASS_EN;\n\t \n\ttmp |= PIXEL_ROUNDING_TRUNC_FB_PASSTHRU;\n\n\t \n\tif (IS_DG2(dev_priv))\n\t\ttmp &= ~UNDERRUN_RECOVERY_ENABLE_DG2;\n\telse if (DISPLAY_VER(dev_priv) >= 13)\n\t\ttmp |= UNDERRUN_RECOVERY_DISABLE_ADLP;\n\n\t \n\tif (IS_DG2_DISPLAY_STEP(dev_priv, STEP_B0, STEP_FOREVER))\n\t\ttmp |= DG2_RENDER_CCSTAG_4_3_EN;\n\n\tintel_de_write(dev_priv, PIPE_CHICKEN(pipe), tmp);\n}\n\nbool intel_has_pending_fb_unpin(struct drm_i915_private *dev_priv)\n{\n\tstruct drm_crtc *crtc;\n\tbool cleanup_done;\n\n\tdrm_for_each_crtc(crtc, &dev_priv->drm) {\n\t\tstruct drm_crtc_commit *commit;\n\t\tspin_lock(&crtc->commit_lock);\n\t\tcommit = list_first_entry_or_null(&crtc->commit_list,\n\t\t\t\t\t\t  struct drm_crtc_commit, commit_entry);\n\t\tcleanup_done = commit ?\n\t\t\ttry_wait_for_completion(&commit->cleanup_done) : true;\n\t\tspin_unlock(&crtc->commit_lock);\n\n\t\tif (cleanup_done)\n\t\t\tcontinue;\n\n\t\tintel_crtc_wait_for_next_vblank(to_intel_crtc(crtc));\n\n\t\treturn true;\n\t}\n\n\treturn false;\n}\n\n \nstruct intel_encoder *\nintel_get_crtc_new_encoder(const struct intel_atomic_state *state,\n\t\t\t   const struct intel_crtc_state *crtc_state)\n{\n\tconst struct drm_connector_state *connector_state;\n\tconst struct drm_connector *connector;\n\tstruct intel_encoder *encoder = NULL;\n\tstruct intel_crtc *master_crtc;\n\tint num_encoders = 0;\n\tint i;\n\n\tmaster_crtc = intel_master_crtc(crtc_state);\n\n\tfor_each_new_connector_in_state(&state->base, connector, connector_state, i) {\n\t\tif (connector_state->crtc != &master_crtc->base)\n\t\t\tcontinue;\n\n\t\tencoder = to_intel_encoder(connector_state->best_encoder);\n\t\tnum_encoders++;\n\t}\n\n\tdrm_WARN(state->base.dev, num_encoders != 1,\n\t\t \"%d encoders for pipe %c\\n\",\n\t\t num_encoders, pipe_name(master_crtc->pipe));\n\n\treturn encoder;\n}\n\nstatic void ilk_pfit_enable(const struct intel_crtc_state *crtc_state)\n{\n\tstruct intel_crtc *crtc = to_intel_crtc(crtc_state->uapi.crtc);\n\tstruct drm_i915_private *dev_priv = to_i915(crtc->base.dev);\n\tconst struct drm_rect *dst = &crtc_state->pch_pfit.dst;\n\tenum pipe pipe = crtc->pipe;\n\tint width = drm_rect_width(dst);\n\tint height = drm_rect_height(dst);\n\tint x = dst->x1;\n\tint y = dst->y1;\n\n\tif (!crtc_state->pch_pfit.enabled)\n\t\treturn;\n\n\t \n\tif (IS_IVYBRIDGE(dev_priv) || IS_HASWELL(dev_priv))\n\t\tintel_de_write_fw(dev_priv, PF_CTL(pipe), PF_ENABLE |\n\t\t\t\t  PF_FILTER_MED_3x3 | PF_PIPE_SEL_IVB(pipe));\n\telse\n\t\tintel_de_write_fw(dev_priv, PF_CTL(pipe), PF_ENABLE |\n\t\t\t\t  PF_FILTER_MED_3x3);\n\tintel_de_write_fw(dev_priv, PF_WIN_POS(pipe),\n\t\t\t  PF_WIN_XPOS(x) | PF_WIN_YPOS(y));\n\tintel_de_write_fw(dev_priv, PF_WIN_SZ(pipe),\n\t\t\t  PF_WIN_XSIZE(width) | PF_WIN_YSIZE(height));\n}\n\nstatic void intel_crtc_dpms_overlay_disable(struct intel_crtc *crtc)\n{\n\tif (crtc->overlay)\n\t\t(void) intel_overlay_switch_off(crtc->overlay);\n\n\t \n}\n\nstatic bool needs_nv12_wa(const struct intel_crtc_state *crtc_state)\n{\n\tstruct drm_i915_private *dev_priv = to_i915(crtc_state->uapi.crtc->dev);\n\n\tif (!crtc_state->nv12_planes)\n\t\treturn false;\n\n\t \n\tif (DISPLAY_VER(dev_priv) == 9)\n\t\treturn true;\n\n\treturn false;\n}\n\nstatic bool needs_scalerclk_wa(const struct intel_crtc_state *crtc_state)\n{\n\tstruct drm_i915_private *dev_priv = to_i915(crtc_state->uapi.crtc->dev);\n\n\t \n\tif (crtc_state->scaler_state.scaler_users > 0 && DISPLAY_VER(dev_priv) == 11)\n\t\treturn true;\n\n\treturn false;\n}\n\nstatic bool needs_cursorclk_wa(const struct intel_crtc_state *crtc_state)\n{\n\tstruct drm_i915_private *dev_priv = to_i915(crtc_state->uapi.crtc->dev);\n\n\t \n\tif (is_hdr_mode(crtc_state) &&\n\t    crtc_state->active_planes & BIT(PLANE_CURSOR) &&\n\t    DISPLAY_VER(dev_priv) == 11)\n\t\treturn true;\n\n\treturn false;\n}\n\nstatic void intel_async_flip_vtd_wa(struct drm_i915_private *i915,\n\t\t\t\t    enum pipe pipe, bool enable)\n{\n\tif (DISPLAY_VER(i915) == 9) {\n\t\t \n\t\tintel_de_rmw(i915, CHICKEN_PIPESL_1(pipe),\n\t\t\t     SKL_PLANE1_STRETCH_MAX_MASK,\n\t\t\t     enable ? SKL_PLANE1_STRETCH_MAX_X1 : SKL_PLANE1_STRETCH_MAX_X8);\n\t} else {\n\t\t \n\t\tintel_de_rmw(i915, CHICKEN_PIPESL_1(pipe),\n\t\t\t     HSW_PRI_STRETCH_MAX_MASK,\n\t\t\t     enable ? HSW_PRI_STRETCH_MAX_X1 : HSW_PRI_STRETCH_MAX_X8);\n\t}\n}\n\nstatic bool needs_async_flip_vtd_wa(const struct intel_crtc_state *crtc_state)\n{\n\tstruct drm_i915_private *i915 = to_i915(crtc_state->uapi.crtc->dev);\n\n\treturn crtc_state->uapi.async_flip && i915_vtd_active(i915) &&\n\t\t(DISPLAY_VER(i915) == 9 || IS_BROADWELL(i915) || IS_HASWELL(i915));\n}\n\n#define is_enabling(feature, old_crtc_state, new_crtc_state) \\\n\t((!(old_crtc_state)->feature || intel_crtc_needs_modeset(new_crtc_state)) && \\\n\t (new_crtc_state)->feature)\n#define is_disabling(feature, old_crtc_state, new_crtc_state) \\\n\t((old_crtc_state)->feature && \\\n\t (!(new_crtc_state)->feature || intel_crtc_needs_modeset(new_crtc_state)))\n\nstatic bool planes_enabling(const struct intel_crtc_state *old_crtc_state,\n\t\t\t    const struct intel_crtc_state *new_crtc_state)\n{\n\treturn is_enabling(active_planes, old_crtc_state, new_crtc_state);\n}\n\nstatic bool planes_disabling(const struct intel_crtc_state *old_crtc_state,\n\t\t\t     const struct intel_crtc_state *new_crtc_state)\n{\n\treturn is_disabling(active_planes, old_crtc_state, new_crtc_state);\n}\n\nstatic bool vrr_enabling(const struct intel_crtc_state *old_crtc_state,\n\t\t\t const struct intel_crtc_state *new_crtc_state)\n{\n\treturn is_enabling(vrr.enable, old_crtc_state, new_crtc_state);\n}\n\nstatic bool vrr_disabling(const struct intel_crtc_state *old_crtc_state,\n\t\t\t  const struct intel_crtc_state *new_crtc_state)\n{\n\treturn is_disabling(vrr.enable, old_crtc_state, new_crtc_state);\n}\n\n#undef is_disabling\n#undef is_enabling\n\nstatic void intel_post_plane_update(struct intel_atomic_state *state,\n\t\t\t\t    struct intel_crtc *crtc)\n{\n\tstruct drm_i915_private *dev_priv = to_i915(state->base.dev);\n\tconst struct intel_crtc_state *old_crtc_state =\n\t\tintel_atomic_get_old_crtc_state(state, crtc);\n\tconst struct intel_crtc_state *new_crtc_state =\n\t\tintel_atomic_get_new_crtc_state(state, crtc);\n\tenum pipe pipe = crtc->pipe;\n\n\tintel_frontbuffer_flip(dev_priv, new_crtc_state->fb_bits);\n\n\tif (new_crtc_state->update_wm_post && new_crtc_state->hw.active)\n\t\tintel_update_watermarks(dev_priv);\n\n\tintel_fbc_post_update(state, crtc);\n\n\tif (needs_async_flip_vtd_wa(old_crtc_state) &&\n\t    !needs_async_flip_vtd_wa(new_crtc_state))\n\t\tintel_async_flip_vtd_wa(dev_priv, pipe, false);\n\n\tif (needs_nv12_wa(old_crtc_state) &&\n\t    !needs_nv12_wa(new_crtc_state))\n\t\tskl_wa_827(dev_priv, pipe, false);\n\n\tif (needs_scalerclk_wa(old_crtc_state) &&\n\t    !needs_scalerclk_wa(new_crtc_state))\n\t\ticl_wa_scalerclkgating(dev_priv, pipe, false);\n\n\tif (needs_cursorclk_wa(old_crtc_state) &&\n\t    !needs_cursorclk_wa(new_crtc_state))\n\t\ticl_wa_cursorclkgating(dev_priv, pipe, false);\n\n\tif (intel_crtc_needs_color_update(new_crtc_state))\n\t\tintel_color_post_update(new_crtc_state);\n}\n\nstatic void intel_crtc_enable_flip_done(struct intel_atomic_state *state,\n\t\t\t\t\tstruct intel_crtc *crtc)\n{\n\tconst struct intel_crtc_state *crtc_state =\n\t\tintel_atomic_get_new_crtc_state(state, crtc);\n\tu8 update_planes = crtc_state->update_planes;\n\tconst struct intel_plane_state __maybe_unused *plane_state;\n\tstruct intel_plane *plane;\n\tint i;\n\n\tfor_each_new_intel_plane_in_state(state, plane, plane_state, i) {\n\t\tif (plane->pipe == crtc->pipe &&\n\t\t    update_planes & BIT(plane->id))\n\t\t\tplane->enable_flip_done(plane);\n\t}\n}\n\nstatic void intel_crtc_disable_flip_done(struct intel_atomic_state *state,\n\t\t\t\t\t struct intel_crtc *crtc)\n{\n\tconst struct intel_crtc_state *crtc_state =\n\t\tintel_atomic_get_new_crtc_state(state, crtc);\n\tu8 update_planes = crtc_state->update_planes;\n\tconst struct intel_plane_state __maybe_unused *plane_state;\n\tstruct intel_plane *plane;\n\tint i;\n\n\tfor_each_new_intel_plane_in_state(state, plane, plane_state, i) {\n\t\tif (plane->pipe == crtc->pipe &&\n\t\t    update_planes & BIT(plane->id))\n\t\t\tplane->disable_flip_done(plane);\n\t}\n}\n\nstatic void intel_crtc_async_flip_disable_wa(struct intel_atomic_state *state,\n\t\t\t\t\t     struct intel_crtc *crtc)\n{\n\tconst struct intel_crtc_state *old_crtc_state =\n\t\tintel_atomic_get_old_crtc_state(state, crtc);\n\tconst struct intel_crtc_state *new_crtc_state =\n\t\tintel_atomic_get_new_crtc_state(state, crtc);\n\tu8 disable_async_flip_planes = old_crtc_state->async_flip_planes &\n\t\t\t\t       ~new_crtc_state->async_flip_planes;\n\tconst struct intel_plane_state *old_plane_state;\n\tstruct intel_plane *plane;\n\tbool need_vbl_wait = false;\n\tint i;\n\n\tfor_each_old_intel_plane_in_state(state, plane, old_plane_state, i) {\n\t\tif (plane->need_async_flip_disable_wa &&\n\t\t    plane->pipe == crtc->pipe &&\n\t\t    disable_async_flip_planes & BIT(plane->id)) {\n\t\t\t \n\t\t\tplane->async_flip(plane, old_crtc_state,\n\t\t\t\t\t  old_plane_state, false);\n\t\t\tneed_vbl_wait = true;\n\t\t}\n\t}\n\n\tif (need_vbl_wait)\n\t\tintel_crtc_wait_for_next_vblank(crtc);\n}\n\nstatic void intel_pre_plane_update(struct intel_atomic_state *state,\n\t\t\t\t   struct intel_crtc *crtc)\n{\n\tstruct drm_i915_private *dev_priv = to_i915(state->base.dev);\n\tconst struct intel_crtc_state *old_crtc_state =\n\t\tintel_atomic_get_old_crtc_state(state, crtc);\n\tconst struct intel_crtc_state *new_crtc_state =\n\t\tintel_atomic_get_new_crtc_state(state, crtc);\n\tenum pipe pipe = crtc->pipe;\n\n\tif (vrr_disabling(old_crtc_state, new_crtc_state)) {\n\t\tintel_vrr_disable(old_crtc_state);\n\t\tintel_crtc_update_active_timings(old_crtc_state, false);\n\t}\n\n\tintel_drrs_deactivate(old_crtc_state);\n\n\tintel_psr_pre_plane_update(state, crtc);\n\n\tif (hsw_ips_pre_update(state, crtc))\n\t\tintel_crtc_wait_for_next_vblank(crtc);\n\n\tif (intel_fbc_pre_update(state, crtc))\n\t\tintel_crtc_wait_for_next_vblank(crtc);\n\n\tif (!needs_async_flip_vtd_wa(old_crtc_state) &&\n\t    needs_async_flip_vtd_wa(new_crtc_state))\n\t\tintel_async_flip_vtd_wa(dev_priv, pipe, true);\n\n\t \n\tif (!needs_nv12_wa(old_crtc_state) &&\n\t    needs_nv12_wa(new_crtc_state))\n\t\tskl_wa_827(dev_priv, pipe, true);\n\n\t \n\tif (!needs_scalerclk_wa(old_crtc_state) &&\n\t    needs_scalerclk_wa(new_crtc_state))\n\t\ticl_wa_scalerclkgating(dev_priv, pipe, true);\n\n\t \n\tif (!needs_cursorclk_wa(old_crtc_state) &&\n\t    needs_cursorclk_wa(new_crtc_state))\n\t\ticl_wa_cursorclkgating(dev_priv, pipe, true);\n\n\t \n\tif (HAS_GMCH(dev_priv) && old_crtc_state->hw.active &&\n\t    new_crtc_state->disable_cxsr && intel_set_memory_cxsr(dev_priv, false))\n\t\tintel_crtc_wait_for_next_vblank(crtc);\n\n\t \n\tif (old_crtc_state->hw.active &&\n\t    new_crtc_state->disable_lp_wm && ilk_disable_lp_wm(dev_priv))\n\t\tintel_crtc_wait_for_next_vblank(crtc);\n\n\t \n\tif (!intel_crtc_needs_modeset(new_crtc_state)) {\n\t\t \n\t\tif (!intel_initial_watermarks(state, crtc))\n\t\t\tif (new_crtc_state->update_wm_pre)\n\t\t\t\tintel_update_watermarks(dev_priv);\n\t}\n\n\t \n\tif (DISPLAY_VER(dev_priv) == 2 && planes_disabling(old_crtc_state, new_crtc_state))\n\t\tintel_set_cpu_fifo_underrun_reporting(dev_priv, pipe, false);\n\n\t \n\tif (old_crtc_state->async_flip_planes & ~new_crtc_state->async_flip_planes)\n\t\tintel_crtc_async_flip_disable_wa(state, crtc);\n}\n\nstatic void intel_crtc_disable_planes(struct intel_atomic_state *state,\n\t\t\t\t      struct intel_crtc *crtc)\n{\n\tstruct drm_i915_private *dev_priv = to_i915(crtc->base.dev);\n\tconst struct intel_crtc_state *new_crtc_state =\n\t\tintel_atomic_get_new_crtc_state(state, crtc);\n\tunsigned int update_mask = new_crtc_state->update_planes;\n\tconst struct intel_plane_state *old_plane_state;\n\tstruct intel_plane *plane;\n\tunsigned fb_bits = 0;\n\tint i;\n\n\tintel_crtc_dpms_overlay_disable(crtc);\n\n\tfor_each_old_intel_plane_in_state(state, plane, old_plane_state, i) {\n\t\tif (crtc->pipe != plane->pipe ||\n\t\t    !(update_mask & BIT(plane->id)))\n\t\t\tcontinue;\n\n\t\tintel_plane_disable_arm(plane, new_crtc_state);\n\n\t\tif (old_plane_state->uapi.visible)\n\t\t\tfb_bits |= plane->frontbuffer_bit;\n\t}\n\n\tintel_frontbuffer_flip(dev_priv, fb_bits);\n}\n\nstatic void intel_encoders_update_prepare(struct intel_atomic_state *state)\n{\n\tstruct drm_i915_private *i915 = to_i915(state->base.dev);\n\tstruct intel_crtc_state *new_crtc_state, *old_crtc_state;\n\tstruct intel_crtc *crtc;\n\tint i;\n\n\t \n\tif (i915->display.dpll.mgr) {\n\t\tfor_each_oldnew_intel_crtc_in_state(state, crtc, old_crtc_state, new_crtc_state, i) {\n\t\t\tif (intel_crtc_needs_modeset(new_crtc_state))\n\t\t\t\tcontinue;\n\n\t\t\tnew_crtc_state->shared_dpll = old_crtc_state->shared_dpll;\n\t\t\tnew_crtc_state->dpll_hw_state = old_crtc_state->dpll_hw_state;\n\t\t}\n\t}\n}\n\nstatic void intel_encoders_pre_pll_enable(struct intel_atomic_state *state,\n\t\t\t\t\t  struct intel_crtc *crtc)\n{\n\tconst struct intel_crtc_state *crtc_state =\n\t\tintel_atomic_get_new_crtc_state(state, crtc);\n\tconst struct drm_connector_state *conn_state;\n\tstruct drm_connector *conn;\n\tint i;\n\n\tfor_each_new_connector_in_state(&state->base, conn, conn_state, i) {\n\t\tstruct intel_encoder *encoder =\n\t\t\tto_intel_encoder(conn_state->best_encoder);\n\n\t\tif (conn_state->crtc != &crtc->base)\n\t\t\tcontinue;\n\n\t\tif (encoder->pre_pll_enable)\n\t\t\tencoder->pre_pll_enable(state, encoder,\n\t\t\t\t\t\tcrtc_state, conn_state);\n\t}\n}\n\nstatic void intel_encoders_pre_enable(struct intel_atomic_state *state,\n\t\t\t\t      struct intel_crtc *crtc)\n{\n\tconst struct intel_crtc_state *crtc_state =\n\t\tintel_atomic_get_new_crtc_state(state, crtc);\n\tconst struct drm_connector_state *conn_state;\n\tstruct drm_connector *conn;\n\tint i;\n\n\tfor_each_new_connector_in_state(&state->base, conn, conn_state, i) {\n\t\tstruct intel_encoder *encoder =\n\t\t\tto_intel_encoder(conn_state->best_encoder);\n\n\t\tif (conn_state->crtc != &crtc->base)\n\t\t\tcontinue;\n\n\t\tif (encoder->pre_enable)\n\t\t\tencoder->pre_enable(state, encoder,\n\t\t\t\t\t    crtc_state, conn_state);\n\t}\n}\n\nstatic void intel_encoders_enable(struct intel_atomic_state *state,\n\t\t\t\t  struct intel_crtc *crtc)\n{\n\tconst struct intel_crtc_state *crtc_state =\n\t\tintel_atomic_get_new_crtc_state(state, crtc);\n\tconst struct drm_connector_state *conn_state;\n\tstruct drm_connector *conn;\n\tint i;\n\n\tfor_each_new_connector_in_state(&state->base, conn, conn_state, i) {\n\t\tstruct intel_encoder *encoder =\n\t\t\tto_intel_encoder(conn_state->best_encoder);\n\n\t\tif (conn_state->crtc != &crtc->base)\n\t\t\tcontinue;\n\n\t\tif (encoder->enable)\n\t\t\tencoder->enable(state, encoder,\n\t\t\t\t\tcrtc_state, conn_state);\n\t\tintel_opregion_notify_encoder(encoder, true);\n\t}\n}\n\nstatic void intel_encoders_disable(struct intel_atomic_state *state,\n\t\t\t\t   struct intel_crtc *crtc)\n{\n\tconst struct intel_crtc_state *old_crtc_state =\n\t\tintel_atomic_get_old_crtc_state(state, crtc);\n\tconst struct drm_connector_state *old_conn_state;\n\tstruct drm_connector *conn;\n\tint i;\n\n\tfor_each_old_connector_in_state(&state->base, conn, old_conn_state, i) {\n\t\tstruct intel_encoder *encoder =\n\t\t\tto_intel_encoder(old_conn_state->best_encoder);\n\n\t\tif (old_conn_state->crtc != &crtc->base)\n\t\t\tcontinue;\n\n\t\tintel_opregion_notify_encoder(encoder, false);\n\t\tif (encoder->disable)\n\t\t\tencoder->disable(state, encoder,\n\t\t\t\t\t old_crtc_state, old_conn_state);\n\t}\n}\n\nstatic void intel_encoders_post_disable(struct intel_atomic_state *state,\n\t\t\t\t\tstruct intel_crtc *crtc)\n{\n\tconst struct intel_crtc_state *old_crtc_state =\n\t\tintel_atomic_get_old_crtc_state(state, crtc);\n\tconst struct drm_connector_state *old_conn_state;\n\tstruct drm_connector *conn;\n\tint i;\n\n\tfor_each_old_connector_in_state(&state->base, conn, old_conn_state, i) {\n\t\tstruct intel_encoder *encoder =\n\t\t\tto_intel_encoder(old_conn_state->best_encoder);\n\n\t\tif (old_conn_state->crtc != &crtc->base)\n\t\t\tcontinue;\n\n\t\tif (encoder->post_disable)\n\t\t\tencoder->post_disable(state, encoder,\n\t\t\t\t\t      old_crtc_state, old_conn_state);\n\t}\n}\n\nstatic void intel_encoders_post_pll_disable(struct intel_atomic_state *state,\n\t\t\t\t\t    struct intel_crtc *crtc)\n{\n\tconst struct intel_crtc_state *old_crtc_state =\n\t\tintel_atomic_get_old_crtc_state(state, crtc);\n\tconst struct drm_connector_state *old_conn_state;\n\tstruct drm_connector *conn;\n\tint i;\n\n\tfor_each_old_connector_in_state(&state->base, conn, old_conn_state, i) {\n\t\tstruct intel_encoder *encoder =\n\t\t\tto_intel_encoder(old_conn_state->best_encoder);\n\n\t\tif (old_conn_state->crtc != &crtc->base)\n\t\t\tcontinue;\n\n\t\tif (encoder->post_pll_disable)\n\t\t\tencoder->post_pll_disable(state, encoder,\n\t\t\t\t\t\t  old_crtc_state, old_conn_state);\n\t}\n}\n\nstatic void intel_encoders_update_pipe(struct intel_atomic_state *state,\n\t\t\t\t       struct intel_crtc *crtc)\n{\n\tconst struct intel_crtc_state *crtc_state =\n\t\tintel_atomic_get_new_crtc_state(state, crtc);\n\tconst struct drm_connector_state *conn_state;\n\tstruct drm_connector *conn;\n\tint i;\n\n\tfor_each_new_connector_in_state(&state->base, conn, conn_state, i) {\n\t\tstruct intel_encoder *encoder =\n\t\t\tto_intel_encoder(conn_state->best_encoder);\n\n\t\tif (conn_state->crtc != &crtc->base)\n\t\t\tcontinue;\n\n\t\tif (encoder->update_pipe)\n\t\t\tencoder->update_pipe(state, encoder,\n\t\t\t\t\t     crtc_state, conn_state);\n\t}\n}\n\nstatic void intel_disable_primary_plane(const struct intel_crtc_state *crtc_state)\n{\n\tstruct intel_crtc *crtc = to_intel_crtc(crtc_state->uapi.crtc);\n\tstruct intel_plane *plane = to_intel_plane(crtc->base.primary);\n\n\tplane->disable_arm(plane, crtc_state);\n}\n\nstatic void ilk_configure_cpu_transcoder(const struct intel_crtc_state *crtc_state)\n{\n\tstruct intel_crtc *crtc = to_intel_crtc(crtc_state->uapi.crtc);\n\tenum transcoder cpu_transcoder = crtc_state->cpu_transcoder;\n\n\tif (crtc_state->has_pch_encoder) {\n\t\tintel_cpu_transcoder_set_m1_n1(crtc, cpu_transcoder,\n\t\t\t\t\t       &crtc_state->fdi_m_n);\n\t} else if (intel_crtc_has_dp_encoder(crtc_state)) {\n\t\tintel_cpu_transcoder_set_m1_n1(crtc, cpu_transcoder,\n\t\t\t\t\t       &crtc_state->dp_m_n);\n\t\tintel_cpu_transcoder_set_m2_n2(crtc, cpu_transcoder,\n\t\t\t\t\t       &crtc_state->dp_m2_n2);\n\t}\n\n\tintel_set_transcoder_timings(crtc_state);\n\n\tilk_set_pipeconf(crtc_state);\n}\n\nstatic void ilk_crtc_enable(struct intel_atomic_state *state,\n\t\t\t    struct intel_crtc *crtc)\n{\n\tconst struct intel_crtc_state *new_crtc_state =\n\t\tintel_atomic_get_new_crtc_state(state, crtc);\n\tstruct drm_i915_private *dev_priv = to_i915(crtc->base.dev);\n\tenum pipe pipe = crtc->pipe;\n\n\tif (drm_WARN_ON(&dev_priv->drm, crtc->active))\n\t\treturn;\n\n\t \n\tintel_set_cpu_fifo_underrun_reporting(dev_priv, pipe, false);\n\tintel_set_pch_fifo_underrun_reporting(dev_priv, pipe, false);\n\n\tilk_configure_cpu_transcoder(new_crtc_state);\n\n\tintel_set_pipe_src_size(new_crtc_state);\n\n\tcrtc->active = true;\n\n\tintel_encoders_pre_enable(state, crtc);\n\n\tif (new_crtc_state->has_pch_encoder) {\n\t\tilk_pch_pre_enable(state, crtc);\n\t} else {\n\t\tassert_fdi_tx_disabled(dev_priv, pipe);\n\t\tassert_fdi_rx_disabled(dev_priv, pipe);\n\t}\n\n\tilk_pfit_enable(new_crtc_state);\n\n\t \n\tintel_color_load_luts(new_crtc_state);\n\tintel_color_commit_noarm(new_crtc_state);\n\tintel_color_commit_arm(new_crtc_state);\n\t \n\tintel_disable_primary_plane(new_crtc_state);\n\n\tintel_initial_watermarks(state, crtc);\n\tintel_enable_transcoder(new_crtc_state);\n\n\tif (new_crtc_state->has_pch_encoder)\n\t\tilk_pch_enable(state, crtc);\n\n\tintel_crtc_vblank_on(new_crtc_state);\n\n\tintel_encoders_enable(state, crtc);\n\n\tif (HAS_PCH_CPT(dev_priv))\n\t\tintel_wait_for_pipe_scanline_moving(crtc);\n\n\t \n\tif (new_crtc_state->has_pch_encoder) {\n\t\tintel_crtc_wait_for_next_vblank(crtc);\n\t\tintel_crtc_wait_for_next_vblank(crtc);\n\t}\n\tintel_set_cpu_fifo_underrun_reporting(dev_priv, pipe, true);\n\tintel_set_pch_fifo_underrun_reporting(dev_priv, pipe, true);\n}\n\nstatic void glk_pipe_scaler_clock_gating_wa(struct drm_i915_private *dev_priv,\n\t\t\t\t\t    enum pipe pipe, bool apply)\n{\n\tu32 val = intel_de_read(dev_priv, CLKGATE_DIS_PSL(pipe));\n\tu32 mask = DPF_GATING_DIS | DPF_RAM_GATING_DIS | DPFR_GATING_DIS;\n\n\tif (apply)\n\t\tval |= mask;\n\telse\n\t\tval &= ~mask;\n\n\tintel_de_write(dev_priv, CLKGATE_DIS_PSL(pipe), val);\n}\n\nstatic void hsw_set_linetime_wm(const struct intel_crtc_state *crtc_state)\n{\n\tstruct intel_crtc *crtc = to_intel_crtc(crtc_state->uapi.crtc);\n\tstruct drm_i915_private *dev_priv = to_i915(crtc->base.dev);\n\n\tintel_de_write(dev_priv, WM_LINETIME(crtc->pipe),\n\t\t       HSW_LINETIME(crtc_state->linetime) |\n\t\t       HSW_IPS_LINETIME(crtc_state->ips_linetime));\n}\n\nstatic void hsw_set_frame_start_delay(const struct intel_crtc_state *crtc_state)\n{\n\tstruct intel_crtc *crtc = to_intel_crtc(crtc_state->uapi.crtc);\n\tstruct drm_i915_private *dev_priv = to_i915(crtc->base.dev);\n\tenum transcoder transcoder = crtc_state->cpu_transcoder;\n\ti915_reg_t reg = DISPLAY_VER(dev_priv) >= 14 ? MTL_CHICKEN_TRANS(transcoder) :\n\t\t\t CHICKEN_TRANS(transcoder);\n\n\tintel_de_rmw(dev_priv, reg,\n\t\t     HSW_FRAME_START_DELAY_MASK,\n\t\t     HSW_FRAME_START_DELAY(crtc_state->framestart_delay - 1));\n}\n\nstatic void icl_ddi_bigjoiner_pre_enable(struct intel_atomic_state *state,\n\t\t\t\t\t const struct intel_crtc_state *crtc_state)\n{\n\tstruct intel_crtc *master_crtc = intel_master_crtc(crtc_state);\n\n\t \n\tif (intel_crtc_is_bigjoiner_slave(crtc_state))\n\t\tintel_encoders_pre_pll_enable(state, master_crtc);\n\n\tif (crtc_state->shared_dpll)\n\t\tintel_enable_shared_dpll(crtc_state);\n\n\tif (intel_crtc_is_bigjoiner_slave(crtc_state))\n\t\tintel_encoders_pre_enable(state, master_crtc);\n}\n\nstatic void hsw_configure_cpu_transcoder(const struct intel_crtc_state *crtc_state)\n{\n\tstruct intel_crtc *crtc = to_intel_crtc(crtc_state->uapi.crtc);\n\tstruct drm_i915_private *dev_priv = to_i915(crtc->base.dev);\n\tenum transcoder cpu_transcoder = crtc_state->cpu_transcoder;\n\n\tif (crtc_state->has_pch_encoder) {\n\t\tintel_cpu_transcoder_set_m1_n1(crtc, cpu_transcoder,\n\t\t\t\t\t       &crtc_state->fdi_m_n);\n\t} else if (intel_crtc_has_dp_encoder(crtc_state)) {\n\t\tintel_cpu_transcoder_set_m1_n1(crtc, cpu_transcoder,\n\t\t\t\t\t       &crtc_state->dp_m_n);\n\t\tintel_cpu_transcoder_set_m2_n2(crtc, cpu_transcoder,\n\t\t\t\t\t       &crtc_state->dp_m2_n2);\n\t}\n\n\tintel_set_transcoder_timings(crtc_state);\n\tif (HAS_VRR(dev_priv))\n\t\tintel_vrr_set_transcoder_timings(crtc_state);\n\n\tif (cpu_transcoder != TRANSCODER_EDP)\n\t\tintel_de_write(dev_priv, TRANS_MULT(cpu_transcoder),\n\t\t\t       crtc_state->pixel_multiplier - 1);\n\n\thsw_set_frame_start_delay(crtc_state);\n\n\thsw_set_transconf(crtc_state);\n}\n\nstatic void hsw_crtc_enable(struct intel_atomic_state *state,\n\t\t\t    struct intel_crtc *crtc)\n{\n\tconst struct intel_crtc_state *new_crtc_state =\n\t\tintel_atomic_get_new_crtc_state(state, crtc);\n\tstruct drm_i915_private *dev_priv = to_i915(crtc->base.dev);\n\tenum pipe pipe = crtc->pipe, hsw_workaround_pipe;\n\tenum transcoder cpu_transcoder = new_crtc_state->cpu_transcoder;\n\tbool psl_clkgate_wa;\n\n\tif (drm_WARN_ON(&dev_priv->drm, crtc->active))\n\t\treturn;\n\n\tintel_dmc_enable_pipe(dev_priv, crtc->pipe);\n\n\tif (!new_crtc_state->bigjoiner_pipes) {\n\t\tintel_encoders_pre_pll_enable(state, crtc);\n\n\t\tif (new_crtc_state->shared_dpll)\n\t\t\tintel_enable_shared_dpll(new_crtc_state);\n\n\t\tintel_encoders_pre_enable(state, crtc);\n\t} else {\n\t\ticl_ddi_bigjoiner_pre_enable(state, new_crtc_state);\n\t}\n\n\tintel_dsc_enable(new_crtc_state);\n\n\tif (DISPLAY_VER(dev_priv) >= 13)\n\t\tintel_uncompressed_joiner_enable(new_crtc_state);\n\n\tintel_set_pipe_src_size(new_crtc_state);\n\tif (DISPLAY_VER(dev_priv) >= 9 || IS_BROADWELL(dev_priv))\n\t\tbdw_set_pipe_misc(new_crtc_state);\n\n\tif (!intel_crtc_is_bigjoiner_slave(new_crtc_state) &&\n\t    !transcoder_is_dsi(cpu_transcoder))\n\t\thsw_configure_cpu_transcoder(new_crtc_state);\n\n\tcrtc->active = true;\n\n\t \n\tpsl_clkgate_wa = DISPLAY_VER(dev_priv) == 10 &&\n\t\tnew_crtc_state->pch_pfit.enabled;\n\tif (psl_clkgate_wa)\n\t\tglk_pipe_scaler_clock_gating_wa(dev_priv, pipe, true);\n\n\tif (DISPLAY_VER(dev_priv) >= 9)\n\t\tskl_pfit_enable(new_crtc_state);\n\telse\n\t\tilk_pfit_enable(new_crtc_state);\n\n\t \n\tintel_color_load_luts(new_crtc_state);\n\tintel_color_commit_noarm(new_crtc_state);\n\tintel_color_commit_arm(new_crtc_state);\n\t \n\tif (DISPLAY_VER(dev_priv) < 9)\n\t\tintel_disable_primary_plane(new_crtc_state);\n\n\thsw_set_linetime_wm(new_crtc_state);\n\n\tif (DISPLAY_VER(dev_priv) >= 11)\n\t\ticl_set_pipe_chicken(new_crtc_state);\n\n\tintel_initial_watermarks(state, crtc);\n\n\tif (intel_crtc_is_bigjoiner_slave(new_crtc_state))\n\t\tintel_crtc_vblank_on(new_crtc_state);\n\n\tintel_encoders_enable(state, crtc);\n\n\tif (psl_clkgate_wa) {\n\t\tintel_crtc_wait_for_next_vblank(crtc);\n\t\tglk_pipe_scaler_clock_gating_wa(dev_priv, pipe, false);\n\t}\n\n\t \n\thsw_workaround_pipe = new_crtc_state->hsw_workaround_pipe;\n\tif (IS_HASWELL(dev_priv) && hsw_workaround_pipe != INVALID_PIPE) {\n\t\tstruct intel_crtc *wa_crtc;\n\n\t\twa_crtc = intel_crtc_for_pipe(dev_priv, hsw_workaround_pipe);\n\n\t\tintel_crtc_wait_for_next_vblank(wa_crtc);\n\t\tintel_crtc_wait_for_next_vblank(wa_crtc);\n\t}\n}\n\nvoid ilk_pfit_disable(const struct intel_crtc_state *old_crtc_state)\n{\n\tstruct intel_crtc *crtc = to_intel_crtc(old_crtc_state->uapi.crtc);\n\tstruct drm_i915_private *dev_priv = to_i915(crtc->base.dev);\n\tenum pipe pipe = crtc->pipe;\n\n\t \n\tif (!old_crtc_state->pch_pfit.enabled)\n\t\treturn;\n\n\tintel_de_write_fw(dev_priv, PF_CTL(pipe), 0);\n\tintel_de_write_fw(dev_priv, PF_WIN_POS(pipe), 0);\n\tintel_de_write_fw(dev_priv, PF_WIN_SZ(pipe), 0);\n}\n\nstatic void ilk_crtc_disable(struct intel_atomic_state *state,\n\t\t\t     struct intel_crtc *crtc)\n{\n\tconst struct intel_crtc_state *old_crtc_state =\n\t\tintel_atomic_get_old_crtc_state(state, crtc);\n\tstruct drm_i915_private *dev_priv = to_i915(crtc->base.dev);\n\tenum pipe pipe = crtc->pipe;\n\n\t \n\tintel_set_cpu_fifo_underrun_reporting(dev_priv, pipe, false);\n\tintel_set_pch_fifo_underrun_reporting(dev_priv, pipe, false);\n\n\tintel_encoders_disable(state, crtc);\n\n\tintel_crtc_vblank_off(old_crtc_state);\n\n\tintel_disable_transcoder(old_crtc_state);\n\n\tilk_pfit_disable(old_crtc_state);\n\n\tif (old_crtc_state->has_pch_encoder)\n\t\tilk_pch_disable(state, crtc);\n\n\tintel_encoders_post_disable(state, crtc);\n\n\tif (old_crtc_state->has_pch_encoder)\n\t\tilk_pch_post_disable(state, crtc);\n\n\tintel_set_cpu_fifo_underrun_reporting(dev_priv, pipe, true);\n\tintel_set_pch_fifo_underrun_reporting(dev_priv, pipe, true);\n\n\tintel_disable_shared_dpll(old_crtc_state);\n}\n\nstatic void hsw_crtc_disable(struct intel_atomic_state *state,\n\t\t\t     struct intel_crtc *crtc)\n{\n\tconst struct intel_crtc_state *old_crtc_state =\n\t\tintel_atomic_get_old_crtc_state(state, crtc);\n\tstruct drm_i915_private *i915 = to_i915(crtc->base.dev);\n\n\t \n\tif (!intel_crtc_is_bigjoiner_slave(old_crtc_state)) {\n\t\tintel_encoders_disable(state, crtc);\n\t\tintel_encoders_post_disable(state, crtc);\n\t}\n\n\tintel_disable_shared_dpll(old_crtc_state);\n\n\tif (!intel_crtc_is_bigjoiner_slave(old_crtc_state)) {\n\t\tstruct intel_crtc *slave_crtc;\n\n\t\tintel_encoders_post_pll_disable(state, crtc);\n\n\t\tintel_dmc_disable_pipe(i915, crtc->pipe);\n\n\t\tfor_each_intel_crtc_in_pipe_mask(&i915->drm, slave_crtc,\n\t\t\t\t\t\t intel_crtc_bigjoiner_slave_pipes(old_crtc_state))\n\t\t\tintel_dmc_disable_pipe(i915, slave_crtc->pipe);\n\t}\n}\n\nstatic void i9xx_pfit_enable(const struct intel_crtc_state *crtc_state)\n{\n\tstruct intel_crtc *crtc = to_intel_crtc(crtc_state->uapi.crtc);\n\tstruct drm_i915_private *dev_priv = to_i915(crtc->base.dev);\n\n\tif (!crtc_state->gmch_pfit.control)\n\t\treturn;\n\n\t \n\tdrm_WARN_ON(&dev_priv->drm,\n\t\t    intel_de_read(dev_priv, PFIT_CONTROL) & PFIT_ENABLE);\n\tassert_transcoder_disabled(dev_priv, crtc_state->cpu_transcoder);\n\n\tintel_de_write(dev_priv, PFIT_PGM_RATIOS,\n\t\t       crtc_state->gmch_pfit.pgm_ratios);\n\tintel_de_write(dev_priv, PFIT_CONTROL, crtc_state->gmch_pfit.control);\n\n\t \n\tintel_de_write(dev_priv, BCLRPAT(crtc->pipe), 0);\n}\n\nbool intel_phy_is_combo(struct drm_i915_private *dev_priv, enum phy phy)\n{\n\tif (phy == PHY_NONE)\n\t\treturn false;\n\telse if (IS_ALDERLAKE_S(dev_priv))\n\t\treturn phy <= PHY_E;\n\telse if (IS_DG1(dev_priv) || IS_ROCKETLAKE(dev_priv))\n\t\treturn phy <= PHY_D;\n\telse if (IS_JASPERLAKE(dev_priv) || IS_ELKHARTLAKE(dev_priv))\n\t\treturn phy <= PHY_C;\n\telse if (IS_ALDERLAKE_P(dev_priv) || IS_DISPLAY_VER(dev_priv, 11, 12))\n\t\treturn phy <= PHY_B;\n\telse\n\t\t \n\t\treturn false;\n}\n\nbool intel_phy_is_tc(struct drm_i915_private *dev_priv, enum phy phy)\n{\n\tif (IS_DG2(dev_priv))\n\t\t \n\t\treturn false;\n\telse if (IS_ALDERLAKE_P(dev_priv) || IS_METEORLAKE(dev_priv))\n\t\treturn phy >= PHY_F && phy <= PHY_I;\n\telse if (IS_TIGERLAKE(dev_priv))\n\t\treturn phy >= PHY_D && phy <= PHY_I;\n\telse if (IS_ICELAKE(dev_priv))\n\t\treturn phy >= PHY_C && phy <= PHY_F;\n\telse\n\t\treturn false;\n}\n\nbool intel_phy_is_snps(struct drm_i915_private *dev_priv, enum phy phy)\n{\n\tif (phy == PHY_NONE)\n\t\treturn false;\n\telse if (IS_DG2(dev_priv))\n\t\t \n\t\treturn phy <= PHY_E;\n\n\treturn false;\n}\n\nenum phy intel_port_to_phy(struct drm_i915_private *i915, enum port port)\n{\n\tif (DISPLAY_VER(i915) >= 13 && port >= PORT_D_XELPD)\n\t\treturn PHY_D + port - PORT_D_XELPD;\n\telse if (DISPLAY_VER(i915) >= 13 && port >= PORT_TC1)\n\t\treturn PHY_F + port - PORT_TC1;\n\telse if (IS_ALDERLAKE_S(i915) && port >= PORT_TC1)\n\t\treturn PHY_B + port - PORT_TC1;\n\telse if ((IS_DG1(i915) || IS_ROCKETLAKE(i915)) && port >= PORT_TC1)\n\t\treturn PHY_C + port - PORT_TC1;\n\telse if ((IS_JASPERLAKE(i915) || IS_ELKHARTLAKE(i915)) &&\n\t\t port == PORT_D)\n\t\treturn PHY_A;\n\n\treturn PHY_A + port - PORT_A;\n}\n\nenum tc_port intel_port_to_tc(struct drm_i915_private *dev_priv, enum port port)\n{\n\tif (!intel_phy_is_tc(dev_priv, intel_port_to_phy(dev_priv, port)))\n\t\treturn TC_PORT_NONE;\n\n\tif (DISPLAY_VER(dev_priv) >= 12)\n\t\treturn TC_PORT_1 + port - PORT_TC1;\n\telse\n\t\treturn TC_PORT_1 + port - PORT_C;\n}\n\nenum intel_display_power_domain\nintel_aux_power_domain(struct intel_digital_port *dig_port)\n{\n\tstruct drm_i915_private *i915 = to_i915(dig_port->base.base.dev);\n\n\tif (intel_tc_port_in_tbt_alt_mode(dig_port))\n\t\treturn intel_display_power_tbt_aux_domain(i915, dig_port->aux_ch);\n\n\treturn intel_display_power_legacy_aux_domain(i915, dig_port->aux_ch);\n}\n\nstatic void get_crtc_power_domains(struct intel_crtc_state *crtc_state,\n\t\t\t\t   struct intel_power_domain_mask *mask)\n{\n\tstruct intel_crtc *crtc = to_intel_crtc(crtc_state->uapi.crtc);\n\tstruct drm_i915_private *dev_priv = to_i915(crtc->base.dev);\n\tenum transcoder cpu_transcoder = crtc_state->cpu_transcoder;\n\tstruct drm_encoder *encoder;\n\tenum pipe pipe = crtc->pipe;\n\n\tbitmap_zero(mask->bits, POWER_DOMAIN_NUM);\n\n\tif (!crtc_state->hw.active)\n\t\treturn;\n\n\tset_bit(POWER_DOMAIN_PIPE(pipe), mask->bits);\n\tset_bit(POWER_DOMAIN_TRANSCODER(cpu_transcoder), mask->bits);\n\tif (crtc_state->pch_pfit.enabled ||\n\t    crtc_state->pch_pfit.force_thru)\n\t\tset_bit(POWER_DOMAIN_PIPE_PANEL_FITTER(pipe), mask->bits);\n\n\tdrm_for_each_encoder_mask(encoder, &dev_priv->drm,\n\t\t\t\t  crtc_state->uapi.encoder_mask) {\n\t\tstruct intel_encoder *intel_encoder = to_intel_encoder(encoder);\n\n\t\tset_bit(intel_encoder->power_domain, mask->bits);\n\t}\n\n\tif (HAS_DDI(dev_priv) && crtc_state->has_audio)\n\t\tset_bit(POWER_DOMAIN_AUDIO_MMIO, mask->bits);\n\n\tif (crtc_state->shared_dpll)\n\t\tset_bit(POWER_DOMAIN_DISPLAY_CORE, mask->bits);\n\n\tif (crtc_state->dsc.compression_enable)\n\t\tset_bit(intel_dsc_power_domain(crtc, cpu_transcoder), mask->bits);\n}\n\nvoid intel_modeset_get_crtc_power_domains(struct intel_crtc_state *crtc_state,\n\t\t\t\t\t  struct intel_power_domain_mask *old_domains)\n{\n\tstruct intel_crtc *crtc = to_intel_crtc(crtc_state->uapi.crtc);\n\tstruct drm_i915_private *dev_priv = to_i915(crtc->base.dev);\n\tenum intel_display_power_domain domain;\n\tstruct intel_power_domain_mask domains, new_domains;\n\n\tget_crtc_power_domains(crtc_state, &domains);\n\n\tbitmap_andnot(new_domains.bits,\n\t\t      domains.bits,\n\t\t      crtc->enabled_power_domains.mask.bits,\n\t\t      POWER_DOMAIN_NUM);\n\tbitmap_andnot(old_domains->bits,\n\t\t      crtc->enabled_power_domains.mask.bits,\n\t\t      domains.bits,\n\t\t      POWER_DOMAIN_NUM);\n\n\tfor_each_power_domain(domain, &new_domains)\n\t\tintel_display_power_get_in_set(dev_priv,\n\t\t\t\t\t       &crtc->enabled_power_domains,\n\t\t\t\t\t       domain);\n}\n\nvoid intel_modeset_put_crtc_power_domains(struct intel_crtc *crtc,\n\t\t\t\t\t  struct intel_power_domain_mask *domains)\n{\n\tintel_display_power_put_mask_in_set(to_i915(crtc->base.dev),\n\t\t\t\t\t    &crtc->enabled_power_domains,\n\t\t\t\t\t    domains);\n}\n\nstatic void i9xx_configure_cpu_transcoder(const struct intel_crtc_state *crtc_state)\n{\n\tstruct intel_crtc *crtc = to_intel_crtc(crtc_state->uapi.crtc);\n\tenum transcoder cpu_transcoder = crtc_state->cpu_transcoder;\n\n\tif (intel_crtc_has_dp_encoder(crtc_state)) {\n\t\tintel_cpu_transcoder_set_m1_n1(crtc, cpu_transcoder,\n\t\t\t\t\t       &crtc_state->dp_m_n);\n\t\tintel_cpu_transcoder_set_m2_n2(crtc, cpu_transcoder,\n\t\t\t\t\t       &crtc_state->dp_m2_n2);\n\t}\n\n\tintel_set_transcoder_timings(crtc_state);\n\n\ti9xx_set_pipeconf(crtc_state);\n}\n\nstatic void valleyview_crtc_enable(struct intel_atomic_state *state,\n\t\t\t\t   struct intel_crtc *crtc)\n{\n\tconst struct intel_crtc_state *new_crtc_state =\n\t\tintel_atomic_get_new_crtc_state(state, crtc);\n\tstruct drm_i915_private *dev_priv = to_i915(crtc->base.dev);\n\tenum pipe pipe = crtc->pipe;\n\n\tif (drm_WARN_ON(&dev_priv->drm, crtc->active))\n\t\treturn;\n\n\ti9xx_configure_cpu_transcoder(new_crtc_state);\n\n\tintel_set_pipe_src_size(new_crtc_state);\n\n\tintel_de_write(dev_priv, VLV_PIPE_MSA_MISC(pipe), 0);\n\n\tif (IS_CHERRYVIEW(dev_priv) && pipe == PIPE_B) {\n\t\tintel_de_write(dev_priv, CHV_BLEND(pipe), CHV_BLEND_LEGACY);\n\t\tintel_de_write(dev_priv, CHV_CANVAS(pipe), 0);\n\t}\n\n\tcrtc->active = true;\n\n\tintel_set_cpu_fifo_underrun_reporting(dev_priv, pipe, true);\n\n\tintel_encoders_pre_pll_enable(state, crtc);\n\n\tif (IS_CHERRYVIEW(dev_priv))\n\t\tchv_enable_pll(new_crtc_state);\n\telse\n\t\tvlv_enable_pll(new_crtc_state);\n\n\tintel_encoders_pre_enable(state, crtc);\n\n\ti9xx_pfit_enable(new_crtc_state);\n\n\tintel_color_load_luts(new_crtc_state);\n\tintel_color_commit_noarm(new_crtc_state);\n\tintel_color_commit_arm(new_crtc_state);\n\t \n\tintel_disable_primary_plane(new_crtc_state);\n\n\tintel_initial_watermarks(state, crtc);\n\tintel_enable_transcoder(new_crtc_state);\n\n\tintel_crtc_vblank_on(new_crtc_state);\n\n\tintel_encoders_enable(state, crtc);\n}\n\nstatic void i9xx_crtc_enable(struct intel_atomic_state *state,\n\t\t\t     struct intel_crtc *crtc)\n{\n\tconst struct intel_crtc_state *new_crtc_state =\n\t\tintel_atomic_get_new_crtc_state(state, crtc);\n\tstruct drm_i915_private *dev_priv = to_i915(crtc->base.dev);\n\tenum pipe pipe = crtc->pipe;\n\n\tif (drm_WARN_ON(&dev_priv->drm, crtc->active))\n\t\treturn;\n\n\ti9xx_configure_cpu_transcoder(new_crtc_state);\n\n\tintel_set_pipe_src_size(new_crtc_state);\n\n\tcrtc->active = true;\n\n\tif (DISPLAY_VER(dev_priv) != 2)\n\t\tintel_set_cpu_fifo_underrun_reporting(dev_priv, pipe, true);\n\n\tintel_encoders_pre_enable(state, crtc);\n\n\ti9xx_enable_pll(new_crtc_state);\n\n\ti9xx_pfit_enable(new_crtc_state);\n\n\tintel_color_load_luts(new_crtc_state);\n\tintel_color_commit_noarm(new_crtc_state);\n\tintel_color_commit_arm(new_crtc_state);\n\t \n\tintel_disable_primary_plane(new_crtc_state);\n\n\tif (!intel_initial_watermarks(state, crtc))\n\t\tintel_update_watermarks(dev_priv);\n\tintel_enable_transcoder(new_crtc_state);\n\n\tintel_crtc_vblank_on(new_crtc_state);\n\n\tintel_encoders_enable(state, crtc);\n\n\t \n\tif (DISPLAY_VER(dev_priv) == 2)\n\t\tintel_crtc_wait_for_next_vblank(crtc);\n}\n\nstatic void i9xx_pfit_disable(const struct intel_crtc_state *old_crtc_state)\n{\n\tstruct intel_crtc *crtc = to_intel_crtc(old_crtc_state->uapi.crtc);\n\tstruct drm_i915_private *dev_priv = to_i915(crtc->base.dev);\n\n\tif (!old_crtc_state->gmch_pfit.control)\n\t\treturn;\n\n\tassert_transcoder_disabled(dev_priv, old_crtc_state->cpu_transcoder);\n\n\tdrm_dbg_kms(&dev_priv->drm, \"disabling pfit, current: 0x%08x\\n\",\n\t\t    intel_de_read(dev_priv, PFIT_CONTROL));\n\tintel_de_write(dev_priv, PFIT_CONTROL, 0);\n}\n\nstatic void i9xx_crtc_disable(struct intel_atomic_state *state,\n\t\t\t      struct intel_crtc *crtc)\n{\n\tstruct intel_crtc_state *old_crtc_state =\n\t\tintel_atomic_get_old_crtc_state(state, crtc);\n\tstruct drm_i915_private *dev_priv = to_i915(crtc->base.dev);\n\tenum pipe pipe = crtc->pipe;\n\n\t \n\tif (DISPLAY_VER(dev_priv) == 2)\n\t\tintel_crtc_wait_for_next_vblank(crtc);\n\n\tintel_encoders_disable(state, crtc);\n\n\tintel_crtc_vblank_off(old_crtc_state);\n\n\tintel_disable_transcoder(old_crtc_state);\n\n\ti9xx_pfit_disable(old_crtc_state);\n\n\tintel_encoders_post_disable(state, crtc);\n\n\tif (!intel_crtc_has_type(old_crtc_state, INTEL_OUTPUT_DSI)) {\n\t\tif (IS_CHERRYVIEW(dev_priv))\n\t\t\tchv_disable_pll(dev_priv, pipe);\n\t\telse if (IS_VALLEYVIEW(dev_priv))\n\t\t\tvlv_disable_pll(dev_priv, pipe);\n\t\telse\n\t\t\ti9xx_disable_pll(old_crtc_state);\n\t}\n\n\tintel_encoders_post_pll_disable(state, crtc);\n\n\tif (DISPLAY_VER(dev_priv) != 2)\n\t\tintel_set_cpu_fifo_underrun_reporting(dev_priv, pipe, false);\n\n\tif (!dev_priv->display.funcs.wm->initial_watermarks)\n\t\tintel_update_watermarks(dev_priv);\n\n\t \n\tif (IS_I830(dev_priv))\n\t\ti830_enable_pipe(dev_priv, pipe);\n}\n\nvoid intel_encoder_destroy(struct drm_encoder *encoder)\n{\n\tstruct intel_encoder *intel_encoder = to_intel_encoder(encoder);\n\n\tdrm_encoder_cleanup(encoder);\n\tkfree(intel_encoder);\n}\n\nstatic bool intel_crtc_supports_double_wide(const struct intel_crtc *crtc)\n{\n\tconst struct drm_i915_private *dev_priv = to_i915(crtc->base.dev);\n\n\t \n\treturn DISPLAY_VER(dev_priv) < 4 &&\n\t\t(crtc->pipe == PIPE_A || IS_I915G(dev_priv));\n}\n\nstatic u32 ilk_pipe_pixel_rate(const struct intel_crtc_state *crtc_state)\n{\n\tu32 pixel_rate = crtc_state->hw.pipe_mode.crtc_clock;\n\tstruct drm_rect src;\n\n\t \n\n\tif (!crtc_state->pch_pfit.enabled)\n\t\treturn pixel_rate;\n\n\tdrm_rect_init(&src, 0, 0,\n\t\t      drm_rect_width(&crtc_state->pipe_src) << 16,\n\t\t      drm_rect_height(&crtc_state->pipe_src) << 16);\n\n\treturn intel_adjusted_rate(&src, &crtc_state->pch_pfit.dst,\n\t\t\t\t   pixel_rate);\n}\n\nstatic void intel_mode_from_crtc_timings(struct drm_display_mode *mode,\n\t\t\t\t\t const struct drm_display_mode *timings)\n{\n\tmode->hdisplay = timings->crtc_hdisplay;\n\tmode->htotal = timings->crtc_htotal;\n\tmode->hsync_start = timings->crtc_hsync_start;\n\tmode->hsync_end = timings->crtc_hsync_end;\n\n\tmode->vdisplay = timings->crtc_vdisplay;\n\tmode->vtotal = timings->crtc_vtotal;\n\tmode->vsync_start = timings->crtc_vsync_start;\n\tmode->vsync_end = timings->crtc_vsync_end;\n\n\tmode->flags = timings->flags;\n\tmode->type = DRM_MODE_TYPE_DRIVER;\n\n\tmode->clock = timings->crtc_clock;\n\n\tdrm_mode_set_name(mode);\n}\n\nstatic void intel_crtc_compute_pixel_rate(struct intel_crtc_state *crtc_state)\n{\n\tstruct drm_i915_private *dev_priv = to_i915(crtc_state->uapi.crtc->dev);\n\n\tif (HAS_GMCH(dev_priv))\n\t\t \n\t\tcrtc_state->pixel_rate =\n\t\t\tcrtc_state->hw.pipe_mode.crtc_clock;\n\telse\n\t\tcrtc_state->pixel_rate =\n\t\t\tilk_pipe_pixel_rate(crtc_state);\n}\n\nstatic void intel_bigjoiner_adjust_timings(const struct intel_crtc_state *crtc_state,\n\t\t\t\t\t   struct drm_display_mode *mode)\n{\n\tint num_pipes = intel_bigjoiner_num_pipes(crtc_state);\n\n\tif (num_pipes < 2)\n\t\treturn;\n\n\tmode->crtc_clock /= num_pipes;\n\tmode->crtc_hdisplay /= num_pipes;\n\tmode->crtc_hblank_start /= num_pipes;\n\tmode->crtc_hblank_end /= num_pipes;\n\tmode->crtc_hsync_start /= num_pipes;\n\tmode->crtc_hsync_end /= num_pipes;\n\tmode->crtc_htotal /= num_pipes;\n}\n\nstatic void intel_splitter_adjust_timings(const struct intel_crtc_state *crtc_state,\n\t\t\t\t\t  struct drm_display_mode *mode)\n{\n\tint overlap = crtc_state->splitter.pixel_overlap;\n\tint n = crtc_state->splitter.link_count;\n\n\tif (!crtc_state->splitter.enable)\n\t\treturn;\n\n\t \n\tmode->crtc_hdisplay = (mode->crtc_hdisplay - overlap) * n;\n\tmode->crtc_hblank_start = (mode->crtc_hblank_start - overlap) * n;\n\tmode->crtc_hblank_end = (mode->crtc_hblank_end - overlap) * n;\n\tmode->crtc_hsync_start = (mode->crtc_hsync_start - overlap) * n;\n\tmode->crtc_hsync_end = (mode->crtc_hsync_end - overlap) * n;\n\tmode->crtc_htotal = (mode->crtc_htotal - overlap) * n;\n\tmode->crtc_clock *= n;\n}\n\nstatic void intel_crtc_readout_derived_state(struct intel_crtc_state *crtc_state)\n{\n\tstruct drm_display_mode *mode = &crtc_state->hw.mode;\n\tstruct drm_display_mode *pipe_mode = &crtc_state->hw.pipe_mode;\n\tstruct drm_display_mode *adjusted_mode = &crtc_state->hw.adjusted_mode;\n\n\t \n\tdrm_mode_copy(pipe_mode, adjusted_mode);\n\n\t \n\tintel_splitter_adjust_timings(crtc_state, pipe_mode);\n\n\t \n\tintel_mode_from_crtc_timings(adjusted_mode, pipe_mode);\n\n\t \n\tdrm_mode_copy(mode, pipe_mode);\n\tintel_mode_from_crtc_timings(mode, mode);\n\tmode->hdisplay = drm_rect_width(&crtc_state->pipe_src) *\n\t\t(intel_bigjoiner_num_pipes(crtc_state) ?: 1);\n\tmode->vdisplay = drm_rect_height(&crtc_state->pipe_src);\n\n\t \n\tintel_bigjoiner_adjust_timings(crtc_state, pipe_mode);\n\tintel_mode_from_crtc_timings(pipe_mode, pipe_mode);\n\n\tintel_crtc_compute_pixel_rate(crtc_state);\n}\n\nvoid intel_encoder_get_config(struct intel_encoder *encoder,\n\t\t\t      struct intel_crtc_state *crtc_state)\n{\n\tencoder->get_config(encoder, crtc_state);\n\n\tintel_crtc_readout_derived_state(crtc_state);\n}\n\nstatic void intel_bigjoiner_compute_pipe_src(struct intel_crtc_state *crtc_state)\n{\n\tint num_pipes = intel_bigjoiner_num_pipes(crtc_state);\n\tint width, height;\n\n\tif (num_pipes < 2)\n\t\treturn;\n\n\twidth = drm_rect_width(&crtc_state->pipe_src);\n\theight = drm_rect_height(&crtc_state->pipe_src);\n\n\tdrm_rect_init(&crtc_state->pipe_src, 0, 0,\n\t\t      width / num_pipes, height);\n}\n\nstatic int intel_crtc_compute_pipe_src(struct intel_crtc_state *crtc_state)\n{\n\tstruct intel_crtc *crtc = to_intel_crtc(crtc_state->uapi.crtc);\n\tstruct drm_i915_private *i915 = to_i915(crtc->base.dev);\n\n\tintel_bigjoiner_compute_pipe_src(crtc_state);\n\n\t \n\tif (drm_rect_width(&crtc_state->pipe_src) & 1) {\n\t\tif (crtc_state->double_wide) {\n\t\t\tdrm_dbg_kms(&i915->drm,\n\t\t\t\t    \"[CRTC:%d:%s] Odd pipe source width not supported with double wide pipe\\n\",\n\t\t\t\t    crtc->base.base.id, crtc->base.name);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (intel_crtc_has_type(crtc_state, INTEL_OUTPUT_LVDS) &&\n\t\t    intel_is_dual_link_lvds(i915)) {\n\t\t\tdrm_dbg_kms(&i915->drm,\n\t\t\t\t    \"[CRTC:%d:%s] Odd pipe source width not supported with dual link LVDS\\n\",\n\t\t\t\t    crtc->base.base.id, crtc->base.name);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int intel_crtc_compute_pipe_mode(struct intel_crtc_state *crtc_state)\n{\n\tstruct intel_crtc *crtc = to_intel_crtc(crtc_state->uapi.crtc);\n\tstruct drm_i915_private *i915 = to_i915(crtc->base.dev);\n\tstruct drm_display_mode *adjusted_mode = &crtc_state->hw.adjusted_mode;\n\tstruct drm_display_mode *pipe_mode = &crtc_state->hw.pipe_mode;\n\tint clock_limit = i915->max_dotclk_freq;\n\n\t \n\tdrm_mode_copy(pipe_mode, adjusted_mode);\n\n\t \n\tintel_splitter_adjust_timings(crtc_state, pipe_mode);\n\n\t \n\tintel_bigjoiner_adjust_timings(crtc_state, pipe_mode);\n\tintel_mode_from_crtc_timings(pipe_mode, pipe_mode);\n\n\tif (DISPLAY_VER(i915) < 4) {\n\t\tclock_limit = i915->display.cdclk.max_cdclk_freq * 9 / 10;\n\n\t\t \n\t\tif (intel_crtc_supports_double_wide(crtc) &&\n\t\t    pipe_mode->crtc_clock > clock_limit) {\n\t\t\tclock_limit = i915->max_dotclk_freq;\n\t\t\tcrtc_state->double_wide = true;\n\t\t}\n\t}\n\n\tif (pipe_mode->crtc_clock > clock_limit) {\n\t\tdrm_dbg_kms(&i915->drm,\n\t\t\t    \"[CRTC:%d:%s] requested pixel clock (%d kHz) too high (max: %d kHz, double wide: %s)\\n\",\n\t\t\t    crtc->base.base.id, crtc->base.name,\n\t\t\t    pipe_mode->crtc_clock, clock_limit,\n\t\t\t    str_yes_no(crtc_state->double_wide));\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int intel_crtc_compute_config(struct intel_atomic_state *state,\n\t\t\t\t     struct intel_crtc *crtc)\n{\n\tstruct intel_crtc_state *crtc_state =\n\t\tintel_atomic_get_new_crtc_state(state, crtc);\n\tint ret;\n\n\tret = intel_dpll_crtc_compute_clock(state, crtc);\n\tif (ret)\n\t\treturn ret;\n\n\tret = intel_crtc_compute_pipe_src(crtc_state);\n\tif (ret)\n\t\treturn ret;\n\n\tret = intel_crtc_compute_pipe_mode(crtc_state);\n\tif (ret)\n\t\treturn ret;\n\n\tintel_crtc_compute_pixel_rate(crtc_state);\n\n\tif (crtc_state->has_pch_encoder)\n\t\treturn ilk_fdi_compute_config(crtc, crtc_state);\n\n\treturn 0;\n}\n\nstatic void\nintel_reduce_m_n_ratio(u32 *num, u32 *den)\n{\n\twhile (*num > DATA_LINK_M_N_MASK ||\n\t       *den > DATA_LINK_M_N_MASK) {\n\t\t*num >>= 1;\n\t\t*den >>= 1;\n\t}\n}\n\nstatic void compute_m_n(u32 *ret_m, u32 *ret_n,\n\t\t\tu32 m, u32 n, u32 constant_n)\n{\n\tif (constant_n)\n\t\t*ret_n = constant_n;\n\telse\n\t\t*ret_n = min_t(unsigned int, roundup_pow_of_two(n), DATA_LINK_N_MAX);\n\n\t*ret_m = div_u64(mul_u32_u32(m, *ret_n), n);\n\tintel_reduce_m_n_ratio(ret_m, ret_n);\n}\n\nvoid\nintel_link_compute_m_n(u16 bits_per_pixel, int nlanes,\n\t\t       int pixel_clock, int link_clock,\n\t\t       struct intel_link_m_n *m_n,\n\t\t       bool fec_enable)\n{\n\tu32 data_clock = bits_per_pixel * pixel_clock;\n\n\tif (fec_enable)\n\t\tdata_clock = intel_dp_mode_to_fec_clock(data_clock);\n\n\t \n\tm_n->tu = 64;\n\tcompute_m_n(&m_n->data_m, &m_n->data_n,\n\t\t    data_clock, link_clock * nlanes * 8,\n\t\t    0x8000000);\n\n\tcompute_m_n(&m_n->link_m, &m_n->link_n,\n\t\t    pixel_clock, link_clock,\n\t\t    0x80000);\n}\n\nvoid intel_panel_sanitize_ssc(struct drm_i915_private *dev_priv)\n{\n\t \n\tif (HAS_PCH_IBX(dev_priv) || HAS_PCH_CPT(dev_priv)) {\n\t\tbool bios_lvds_use_ssc = intel_de_read(dev_priv,\n\t\t\t\t\t\t       PCH_DREF_CONTROL) &\n\t\t\tDREF_SSC1_ENABLE;\n\n\t\tif (dev_priv->display.vbt.lvds_use_ssc != bios_lvds_use_ssc) {\n\t\t\tdrm_dbg_kms(&dev_priv->drm,\n\t\t\t\t    \"SSC %s by BIOS, overriding VBT which says %s\\n\",\n\t\t\t\t    str_enabled_disabled(bios_lvds_use_ssc),\n\t\t\t\t    str_enabled_disabled(dev_priv->display.vbt.lvds_use_ssc));\n\t\t\tdev_priv->display.vbt.lvds_use_ssc = bios_lvds_use_ssc;\n\t\t}\n\t}\n}\n\nvoid intel_zero_m_n(struct intel_link_m_n *m_n)\n{\n\t \n\tmemset(m_n, 0, sizeof(*m_n));\n\tm_n->tu = 1;\n}\n\nvoid intel_set_m_n(struct drm_i915_private *i915,\n\t\t   const struct intel_link_m_n *m_n,\n\t\t   i915_reg_t data_m_reg, i915_reg_t data_n_reg,\n\t\t   i915_reg_t link_m_reg, i915_reg_t link_n_reg)\n{\n\tintel_de_write(i915, data_m_reg, TU_SIZE(m_n->tu) | m_n->data_m);\n\tintel_de_write(i915, data_n_reg, m_n->data_n);\n\tintel_de_write(i915, link_m_reg, m_n->link_m);\n\t \n\tintel_de_write(i915, link_n_reg, m_n->link_n);\n}\n\nbool intel_cpu_transcoder_has_m2_n2(struct drm_i915_private *dev_priv,\n\t\t\t\t    enum transcoder transcoder)\n{\n\tif (IS_HASWELL(dev_priv))\n\t\treturn transcoder == TRANSCODER_EDP;\n\n\treturn IS_DISPLAY_VER(dev_priv, 5, 7) || IS_CHERRYVIEW(dev_priv);\n}\n\nvoid intel_cpu_transcoder_set_m1_n1(struct intel_crtc *crtc,\n\t\t\t\t    enum transcoder transcoder,\n\t\t\t\t    const struct intel_link_m_n *m_n)\n{\n\tstruct drm_i915_private *dev_priv = to_i915(crtc->base.dev);\n\tenum pipe pipe = crtc->pipe;\n\n\tif (DISPLAY_VER(dev_priv) >= 5)\n\t\tintel_set_m_n(dev_priv, m_n,\n\t\t\t      PIPE_DATA_M1(transcoder), PIPE_DATA_N1(transcoder),\n\t\t\t      PIPE_LINK_M1(transcoder), PIPE_LINK_N1(transcoder));\n\telse\n\t\tintel_set_m_n(dev_priv, m_n,\n\t\t\t      PIPE_DATA_M_G4X(pipe), PIPE_DATA_N_G4X(pipe),\n\t\t\t      PIPE_LINK_M_G4X(pipe), PIPE_LINK_N_G4X(pipe));\n}\n\nvoid intel_cpu_transcoder_set_m2_n2(struct intel_crtc *crtc,\n\t\t\t\t    enum transcoder transcoder,\n\t\t\t\t    const struct intel_link_m_n *m_n)\n{\n\tstruct drm_i915_private *dev_priv = to_i915(crtc->base.dev);\n\n\tif (!intel_cpu_transcoder_has_m2_n2(dev_priv, transcoder))\n\t\treturn;\n\n\tintel_set_m_n(dev_priv, m_n,\n\t\t      PIPE_DATA_M2(transcoder), PIPE_DATA_N2(transcoder),\n\t\t      PIPE_LINK_M2(transcoder), PIPE_LINK_N2(transcoder));\n}\n\nstatic void intel_set_transcoder_timings(const struct intel_crtc_state *crtc_state)\n{\n\tstruct intel_crtc *crtc = to_intel_crtc(crtc_state->uapi.crtc);\n\tstruct drm_i915_private *dev_priv = to_i915(crtc->base.dev);\n\tenum pipe pipe = crtc->pipe;\n\tenum transcoder cpu_transcoder = crtc_state->cpu_transcoder;\n\tconst struct drm_display_mode *adjusted_mode = &crtc_state->hw.adjusted_mode;\n\tu32 crtc_vdisplay, crtc_vtotal, crtc_vblank_start, crtc_vblank_end;\n\tint vsyncshift = 0;\n\n\t \n\tcrtc_vdisplay = adjusted_mode->crtc_vdisplay;\n\tcrtc_vtotal = adjusted_mode->crtc_vtotal;\n\tcrtc_vblank_start = adjusted_mode->crtc_vblank_start;\n\tcrtc_vblank_end = adjusted_mode->crtc_vblank_end;\n\n\tif (adjusted_mode->flags & DRM_MODE_FLAG_INTERLACE) {\n\t\t \n\t\tcrtc_vtotal -= 1;\n\t\tcrtc_vblank_end -= 1;\n\n\t\tif (intel_crtc_has_type(crtc_state, INTEL_OUTPUT_SDVO))\n\t\t\tvsyncshift = (adjusted_mode->crtc_htotal - 1) / 2;\n\t\telse\n\t\t\tvsyncshift = adjusted_mode->crtc_hsync_start -\n\t\t\t\tadjusted_mode->crtc_htotal / 2;\n\t\tif (vsyncshift < 0)\n\t\t\tvsyncshift += adjusted_mode->crtc_htotal;\n\t}\n\n\t \n\tif (DISPLAY_VER(dev_priv) >= 13) {\n\t\tintel_de_write(dev_priv, TRANS_SET_CONTEXT_LATENCY(cpu_transcoder),\n\t\t\t       crtc_vblank_start - crtc_vdisplay);\n\n\t\t \n\t\tcrtc_vblank_start = 1;\n\t}\n\n\tif (DISPLAY_VER(dev_priv) > 3)\n\t\tintel_de_write(dev_priv, TRANS_VSYNCSHIFT(cpu_transcoder),\n\t\t\t       vsyncshift);\n\n\tintel_de_write(dev_priv, TRANS_HTOTAL(cpu_transcoder),\n\t\t       HACTIVE(adjusted_mode->crtc_hdisplay - 1) |\n\t\t       HTOTAL(adjusted_mode->crtc_htotal - 1));\n\tintel_de_write(dev_priv, TRANS_HBLANK(cpu_transcoder),\n\t\t       HBLANK_START(adjusted_mode->crtc_hblank_start - 1) |\n\t\t       HBLANK_END(adjusted_mode->crtc_hblank_end - 1));\n\tintel_de_write(dev_priv, TRANS_HSYNC(cpu_transcoder),\n\t\t       HSYNC_START(adjusted_mode->crtc_hsync_start - 1) |\n\t\t       HSYNC_END(adjusted_mode->crtc_hsync_end - 1));\n\n\tintel_de_write(dev_priv, TRANS_VTOTAL(cpu_transcoder),\n\t\t       VACTIVE(crtc_vdisplay - 1) |\n\t\t       VTOTAL(crtc_vtotal - 1));\n\tintel_de_write(dev_priv, TRANS_VBLANK(cpu_transcoder),\n\t\t       VBLANK_START(crtc_vblank_start - 1) |\n\t\t       VBLANK_END(crtc_vblank_end - 1));\n\tintel_de_write(dev_priv, TRANS_VSYNC(cpu_transcoder),\n\t\t       VSYNC_START(adjusted_mode->crtc_vsync_start - 1) |\n\t\t       VSYNC_END(adjusted_mode->crtc_vsync_end - 1));\n\n\t \n\tif (IS_HASWELL(dev_priv) && cpu_transcoder == TRANSCODER_EDP &&\n\t    (pipe == PIPE_B || pipe == PIPE_C))\n\t\tintel_de_write(dev_priv, TRANS_VTOTAL(pipe),\n\t\t\t       VACTIVE(crtc_vdisplay - 1) |\n\t\t\t       VTOTAL(crtc_vtotal - 1));\n}\n\nstatic void intel_set_pipe_src_size(const struct intel_crtc_state *crtc_state)\n{\n\tstruct intel_crtc *crtc = to_intel_crtc(crtc_state->uapi.crtc);\n\tstruct drm_i915_private *dev_priv = to_i915(crtc->base.dev);\n\tint width = drm_rect_width(&crtc_state->pipe_src);\n\tint height = drm_rect_height(&crtc_state->pipe_src);\n\tenum pipe pipe = crtc->pipe;\n\n\t \n\tintel_de_write(dev_priv, PIPESRC(pipe),\n\t\t       PIPESRC_WIDTH(width - 1) | PIPESRC_HEIGHT(height - 1));\n}\n\nstatic bool intel_pipe_is_interlaced(const struct intel_crtc_state *crtc_state)\n{\n\tstruct drm_i915_private *dev_priv = to_i915(crtc_state->uapi.crtc->dev);\n\tenum transcoder cpu_transcoder = crtc_state->cpu_transcoder;\n\n\tif (DISPLAY_VER(dev_priv) == 2)\n\t\treturn false;\n\n\tif (DISPLAY_VER(dev_priv) >= 9 ||\n\t    IS_BROADWELL(dev_priv) || IS_HASWELL(dev_priv))\n\t\treturn intel_de_read(dev_priv, TRANSCONF(cpu_transcoder)) & TRANSCONF_INTERLACE_MASK_HSW;\n\telse\n\t\treturn intel_de_read(dev_priv, TRANSCONF(cpu_transcoder)) & TRANSCONF_INTERLACE_MASK;\n}\n\nstatic void intel_get_transcoder_timings(struct intel_crtc *crtc,\n\t\t\t\t\t struct intel_crtc_state *pipe_config)\n{\n\tstruct drm_device *dev = crtc->base.dev;\n\tstruct drm_i915_private *dev_priv = to_i915(dev);\n\tenum transcoder cpu_transcoder = pipe_config->cpu_transcoder;\n\tstruct drm_display_mode *adjusted_mode = &pipe_config->hw.adjusted_mode;\n\tu32 tmp;\n\n\ttmp = intel_de_read(dev_priv, TRANS_HTOTAL(cpu_transcoder));\n\tadjusted_mode->crtc_hdisplay = REG_FIELD_GET(HACTIVE_MASK, tmp) + 1;\n\tadjusted_mode->crtc_htotal = REG_FIELD_GET(HTOTAL_MASK, tmp) + 1;\n\n\tif (!transcoder_is_dsi(cpu_transcoder)) {\n\t\ttmp = intel_de_read(dev_priv, TRANS_HBLANK(cpu_transcoder));\n\t\tadjusted_mode->crtc_hblank_start = REG_FIELD_GET(HBLANK_START_MASK, tmp) + 1;\n\t\tadjusted_mode->crtc_hblank_end = REG_FIELD_GET(HBLANK_END_MASK, tmp) + 1;\n\t}\n\n\ttmp = intel_de_read(dev_priv, TRANS_HSYNC(cpu_transcoder));\n\tadjusted_mode->crtc_hsync_start = REG_FIELD_GET(HSYNC_START_MASK, tmp) + 1;\n\tadjusted_mode->crtc_hsync_end = REG_FIELD_GET(HSYNC_END_MASK, tmp) + 1;\n\n\ttmp = intel_de_read(dev_priv, TRANS_VTOTAL(cpu_transcoder));\n\tadjusted_mode->crtc_vdisplay = REG_FIELD_GET(VACTIVE_MASK, tmp) + 1;\n\tadjusted_mode->crtc_vtotal = REG_FIELD_GET(VTOTAL_MASK, tmp) + 1;\n\n\t \n\tif (!transcoder_is_dsi(cpu_transcoder)) {\n\t\ttmp = intel_de_read(dev_priv, TRANS_VBLANK(cpu_transcoder));\n\t\tadjusted_mode->crtc_vblank_start = REG_FIELD_GET(VBLANK_START_MASK, tmp) + 1;\n\t\tadjusted_mode->crtc_vblank_end = REG_FIELD_GET(VBLANK_END_MASK, tmp) + 1;\n\t}\n\ttmp = intel_de_read(dev_priv, TRANS_VSYNC(cpu_transcoder));\n\tadjusted_mode->crtc_vsync_start = REG_FIELD_GET(VSYNC_START_MASK, tmp) + 1;\n\tadjusted_mode->crtc_vsync_end = REG_FIELD_GET(VSYNC_END_MASK, tmp) + 1;\n\n\tif (intel_pipe_is_interlaced(pipe_config)) {\n\t\tadjusted_mode->flags |= DRM_MODE_FLAG_INTERLACE;\n\t\tadjusted_mode->crtc_vtotal += 1;\n\t\tadjusted_mode->crtc_vblank_end += 1;\n\t}\n\n\tif (DISPLAY_VER(dev_priv) >= 13 && !transcoder_is_dsi(cpu_transcoder))\n\t\tadjusted_mode->crtc_vblank_start =\n\t\t\tadjusted_mode->crtc_vdisplay +\n\t\t\tintel_de_read(dev_priv, TRANS_SET_CONTEXT_LATENCY(cpu_transcoder));\n}\n\nstatic void intel_bigjoiner_adjust_pipe_src(struct intel_crtc_state *crtc_state)\n{\n\tstruct intel_crtc *crtc = to_intel_crtc(crtc_state->uapi.crtc);\n\tint num_pipes = intel_bigjoiner_num_pipes(crtc_state);\n\tenum pipe master_pipe, pipe = crtc->pipe;\n\tint width;\n\n\tif (num_pipes < 2)\n\t\treturn;\n\n\tmaster_pipe = bigjoiner_master_pipe(crtc_state);\n\twidth = drm_rect_width(&crtc_state->pipe_src);\n\n\tdrm_rect_translate_to(&crtc_state->pipe_src,\n\t\t\t      (pipe - master_pipe) * width, 0);\n}\n\nstatic void intel_get_pipe_src_size(struct intel_crtc *crtc,\n\t\t\t\t    struct intel_crtc_state *pipe_config)\n{\n\tstruct drm_device *dev = crtc->base.dev;\n\tstruct drm_i915_private *dev_priv = to_i915(dev);\n\tu32 tmp;\n\n\ttmp = intel_de_read(dev_priv, PIPESRC(crtc->pipe));\n\n\tdrm_rect_init(&pipe_config->pipe_src, 0, 0,\n\t\t      REG_FIELD_GET(PIPESRC_WIDTH_MASK, tmp) + 1,\n\t\t      REG_FIELD_GET(PIPESRC_HEIGHT_MASK, tmp) + 1);\n\n\tintel_bigjoiner_adjust_pipe_src(pipe_config);\n}\n\nvoid i9xx_set_pipeconf(const struct intel_crtc_state *crtc_state)\n{\n\tstruct intel_crtc *crtc = to_intel_crtc(crtc_state->uapi.crtc);\n\tstruct drm_i915_private *dev_priv = to_i915(crtc->base.dev);\n\tenum transcoder cpu_transcoder = crtc_state->cpu_transcoder;\n\tu32 val = 0;\n\n\t \n\tif (IS_I830(dev_priv) || !intel_crtc_needs_modeset(crtc_state))\n\t\tval |= TRANSCONF_ENABLE;\n\n\tif (crtc_state->double_wide)\n\t\tval |= TRANSCONF_DOUBLE_WIDE;\n\n\t \n\tif (IS_G4X(dev_priv) || IS_VALLEYVIEW(dev_priv) ||\n\t    IS_CHERRYVIEW(dev_priv)) {\n\t\t \n\t\tif (crtc_state->dither && crtc_state->pipe_bpp != 30)\n\t\t\tval |= TRANSCONF_DITHER_EN |\n\t\t\t\tTRANSCONF_DITHER_TYPE_SP;\n\n\t\tswitch (crtc_state->pipe_bpp) {\n\t\tdefault:\n\t\t\t \n\t\t\tMISSING_CASE(crtc_state->pipe_bpp);\n\t\t\tfallthrough;\n\t\tcase 18:\n\t\t\tval |= TRANSCONF_BPC_6;\n\t\t\tbreak;\n\t\tcase 24:\n\t\t\tval |= TRANSCONF_BPC_8;\n\t\t\tbreak;\n\t\tcase 30:\n\t\t\tval |= TRANSCONF_BPC_10;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (crtc_state->hw.adjusted_mode.flags & DRM_MODE_FLAG_INTERLACE) {\n\t\tif (DISPLAY_VER(dev_priv) < 4 ||\n\t\t    intel_crtc_has_type(crtc_state, INTEL_OUTPUT_SDVO))\n\t\t\tval |= TRANSCONF_INTERLACE_W_FIELD_INDICATION;\n\t\telse\n\t\t\tval |= TRANSCONF_INTERLACE_W_SYNC_SHIFT;\n\t} else {\n\t\tval |= TRANSCONF_INTERLACE_PROGRESSIVE;\n\t}\n\n\tif ((IS_VALLEYVIEW(dev_priv) || IS_CHERRYVIEW(dev_priv)) &&\n\t     crtc_state->limited_color_range)\n\t\tval |= TRANSCONF_COLOR_RANGE_SELECT;\n\n\tval |= TRANSCONF_GAMMA_MODE(crtc_state->gamma_mode);\n\n\tif (crtc_state->wgc_enable)\n\t\tval |= TRANSCONF_WGC_ENABLE;\n\n\tval |= TRANSCONF_FRAME_START_DELAY(crtc_state->framestart_delay - 1);\n\n\tintel_de_write(dev_priv, TRANSCONF(cpu_transcoder), val);\n\tintel_de_posting_read(dev_priv, TRANSCONF(cpu_transcoder));\n}\n\nstatic bool i9xx_has_pfit(struct drm_i915_private *dev_priv)\n{\n\tif (IS_I830(dev_priv))\n\t\treturn false;\n\n\treturn DISPLAY_VER(dev_priv) >= 4 ||\n\t\tIS_PINEVIEW(dev_priv) || IS_MOBILE(dev_priv);\n}\n\nstatic void i9xx_get_pfit_config(struct intel_crtc_state *crtc_state)\n{\n\tstruct intel_crtc *crtc = to_intel_crtc(crtc_state->uapi.crtc);\n\tstruct drm_i915_private *dev_priv = to_i915(crtc->base.dev);\n\tenum pipe pipe;\n\tu32 tmp;\n\n\tif (!i9xx_has_pfit(dev_priv))\n\t\treturn;\n\n\ttmp = intel_de_read(dev_priv, PFIT_CONTROL);\n\tif (!(tmp & PFIT_ENABLE))\n\t\treturn;\n\n\t \n\tif (DISPLAY_VER(dev_priv) >= 4)\n\t\tpipe = REG_FIELD_GET(PFIT_PIPE_MASK, tmp);\n\telse\n\t\tpipe = PIPE_B;\n\n\tif (pipe != crtc->pipe)\n\t\treturn;\n\n\tcrtc_state->gmch_pfit.control = tmp;\n\tcrtc_state->gmch_pfit.pgm_ratios =\n\t\tintel_de_read(dev_priv, PFIT_PGM_RATIOS);\n}\n\nstatic void vlv_crtc_clock_get(struct intel_crtc *crtc,\n\t\t\t       struct intel_crtc_state *pipe_config)\n{\n\tstruct drm_device *dev = crtc->base.dev;\n\tstruct drm_i915_private *dev_priv = to_i915(dev);\n\tenum pipe pipe = crtc->pipe;\n\tstruct dpll clock;\n\tu32 mdiv;\n\tint refclk = 100000;\n\n\t \n\tif ((pipe_config->dpll_hw_state.dpll & DPLL_VCO_ENABLE) == 0)\n\t\treturn;\n\n\tvlv_dpio_get(dev_priv);\n\tmdiv = vlv_dpio_read(dev_priv, pipe, VLV_PLL_DW3(pipe));\n\tvlv_dpio_put(dev_priv);\n\n\tclock.m1 = (mdiv >> DPIO_M1DIV_SHIFT) & 7;\n\tclock.m2 = mdiv & DPIO_M2DIV_MASK;\n\tclock.n = (mdiv >> DPIO_N_SHIFT) & 0xf;\n\tclock.p1 = (mdiv >> DPIO_P1_SHIFT) & 7;\n\tclock.p2 = (mdiv >> DPIO_P2_SHIFT) & 0x1f;\n\n\tpipe_config->port_clock = vlv_calc_dpll_params(refclk, &clock);\n}\n\nstatic void chv_crtc_clock_get(struct intel_crtc *crtc,\n\t\t\t       struct intel_crtc_state *pipe_config)\n{\n\tstruct drm_device *dev = crtc->base.dev;\n\tstruct drm_i915_private *dev_priv = to_i915(dev);\n\tenum pipe pipe = crtc->pipe;\n\tenum dpio_channel port = vlv_pipe_to_channel(pipe);\n\tstruct dpll clock;\n\tu32 cmn_dw13, pll_dw0, pll_dw1, pll_dw2, pll_dw3;\n\tint refclk = 100000;\n\n\t \n\tif ((pipe_config->dpll_hw_state.dpll & DPLL_VCO_ENABLE) == 0)\n\t\treturn;\n\n\tvlv_dpio_get(dev_priv);\n\tcmn_dw13 = vlv_dpio_read(dev_priv, pipe, CHV_CMN_DW13(port));\n\tpll_dw0 = vlv_dpio_read(dev_priv, pipe, CHV_PLL_DW0(port));\n\tpll_dw1 = vlv_dpio_read(dev_priv, pipe, CHV_PLL_DW1(port));\n\tpll_dw2 = vlv_dpio_read(dev_priv, pipe, CHV_PLL_DW2(port));\n\tpll_dw3 = vlv_dpio_read(dev_priv, pipe, CHV_PLL_DW3(port));\n\tvlv_dpio_put(dev_priv);\n\n\tclock.m1 = (pll_dw1 & 0x7) == DPIO_CHV_M1_DIV_BY_2 ? 2 : 0;\n\tclock.m2 = (pll_dw0 & 0xff) << 22;\n\tif (pll_dw3 & DPIO_CHV_FRAC_DIV_EN)\n\t\tclock.m2 |= pll_dw2 & 0x3fffff;\n\tclock.n = (pll_dw1 >> DPIO_CHV_N_DIV_SHIFT) & 0xf;\n\tclock.p1 = (cmn_dw13 >> DPIO_CHV_P1_DIV_SHIFT) & 0x7;\n\tclock.p2 = (cmn_dw13 >> DPIO_CHV_P2_DIV_SHIFT) & 0x1f;\n\n\tpipe_config->port_clock = chv_calc_dpll_params(refclk, &clock);\n}\n\nstatic enum intel_output_format\nbdw_get_pipe_misc_output_format(struct intel_crtc *crtc)\n{\n\tstruct drm_i915_private *dev_priv = to_i915(crtc->base.dev);\n\tu32 tmp;\n\n\ttmp = intel_de_read(dev_priv, PIPE_MISC(crtc->pipe));\n\n\tif (tmp & PIPE_MISC_YUV420_ENABLE) {\n\t\t \n\t\tdrm_WARN_ON(&dev_priv->drm,\n\t\t\t    (tmp & PIPE_MISC_YUV420_MODE_FULL_BLEND) == 0);\n\n\t\treturn INTEL_OUTPUT_FORMAT_YCBCR420;\n\t} else if (tmp & PIPE_MISC_OUTPUT_COLORSPACE_YUV) {\n\t\treturn INTEL_OUTPUT_FORMAT_YCBCR444;\n\t} else {\n\t\treturn INTEL_OUTPUT_FORMAT_RGB;\n\t}\n}\n\nstatic void i9xx_get_pipe_color_config(struct intel_crtc_state *crtc_state)\n{\n\tstruct intel_crtc *crtc = to_intel_crtc(crtc_state->uapi.crtc);\n\tstruct intel_plane *plane = to_intel_plane(crtc->base.primary);\n\tstruct drm_i915_private *dev_priv = to_i915(crtc->base.dev);\n\tenum i9xx_plane_id i9xx_plane = plane->i9xx_plane;\n\tu32 tmp;\n\n\ttmp = intel_de_read(dev_priv, DSPCNTR(i9xx_plane));\n\n\tif (tmp & DISP_PIPE_GAMMA_ENABLE)\n\t\tcrtc_state->gamma_enable = true;\n\n\tif (!HAS_GMCH(dev_priv) &&\n\t    tmp & DISP_PIPE_CSC_ENABLE)\n\t\tcrtc_state->csc_enable = true;\n}\n\nstatic bool i9xx_get_pipe_config(struct intel_crtc *crtc,\n\t\t\t\t struct intel_crtc_state *pipe_config)\n{\n\tstruct drm_i915_private *dev_priv = to_i915(crtc->base.dev);\n\tenum intel_display_power_domain power_domain;\n\tintel_wakeref_t wakeref;\n\tu32 tmp;\n\tbool ret;\n\n\tpower_domain = POWER_DOMAIN_PIPE(crtc->pipe);\n\twakeref = intel_display_power_get_if_enabled(dev_priv, power_domain);\n\tif (!wakeref)\n\t\treturn false;\n\n\tpipe_config->output_format = INTEL_OUTPUT_FORMAT_RGB;\n\tpipe_config->sink_format = pipe_config->output_format;\n\tpipe_config->cpu_transcoder = (enum transcoder) crtc->pipe;\n\tpipe_config->shared_dpll = NULL;\n\n\tret = false;\n\n\ttmp = intel_de_read(dev_priv, TRANSCONF(pipe_config->cpu_transcoder));\n\tif (!(tmp & TRANSCONF_ENABLE))\n\t\tgoto out;\n\n\tif (IS_G4X(dev_priv) || IS_VALLEYVIEW(dev_priv) ||\n\t    IS_CHERRYVIEW(dev_priv)) {\n\t\tswitch (tmp & TRANSCONF_BPC_MASK) {\n\t\tcase TRANSCONF_BPC_6:\n\t\t\tpipe_config->pipe_bpp = 18;\n\t\t\tbreak;\n\t\tcase TRANSCONF_BPC_8:\n\t\t\tpipe_config->pipe_bpp = 24;\n\t\t\tbreak;\n\t\tcase TRANSCONF_BPC_10:\n\t\t\tpipe_config->pipe_bpp = 30;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tMISSING_CASE(tmp);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif ((IS_VALLEYVIEW(dev_priv) || IS_CHERRYVIEW(dev_priv)) &&\n\t    (tmp & TRANSCONF_COLOR_RANGE_SELECT))\n\t\tpipe_config->limited_color_range = true;\n\n\tpipe_config->gamma_mode = REG_FIELD_GET(TRANSCONF_GAMMA_MODE_MASK_I9XX, tmp);\n\n\tpipe_config->framestart_delay = REG_FIELD_GET(TRANSCONF_FRAME_START_DELAY_MASK, tmp) + 1;\n\n\tif ((IS_VALLEYVIEW(dev_priv) || IS_CHERRYVIEW(dev_priv)) &&\n\t    (tmp & TRANSCONF_WGC_ENABLE))\n\t\tpipe_config->wgc_enable = true;\n\n\tif (IS_CHERRYVIEW(dev_priv))\n\t\tpipe_config->cgm_mode = intel_de_read(dev_priv,\n\t\t\t\t\t\t      CGM_PIPE_MODE(crtc->pipe));\n\n\ti9xx_get_pipe_color_config(pipe_config);\n\tintel_color_get_config(pipe_config);\n\n\tif (DISPLAY_VER(dev_priv) < 4)\n\t\tpipe_config->double_wide = tmp & TRANSCONF_DOUBLE_WIDE;\n\n\tintel_get_transcoder_timings(crtc, pipe_config);\n\tintel_get_pipe_src_size(crtc, pipe_config);\n\n\ti9xx_get_pfit_config(pipe_config);\n\n\tif (DISPLAY_VER(dev_priv) >= 4) {\n\t\t \n\t\tif (IS_CHERRYVIEW(dev_priv) && crtc->pipe != PIPE_A)\n\t\t\ttmp = dev_priv->display.state.chv_dpll_md[crtc->pipe];\n\t\telse\n\t\t\ttmp = intel_de_read(dev_priv, DPLL_MD(crtc->pipe));\n\t\tpipe_config->pixel_multiplier =\n\t\t\t((tmp & DPLL_MD_UDI_MULTIPLIER_MASK)\n\t\t\t >> DPLL_MD_UDI_MULTIPLIER_SHIFT) + 1;\n\t\tpipe_config->dpll_hw_state.dpll_md = tmp;\n\t} else if (IS_I945G(dev_priv) || IS_I945GM(dev_priv) ||\n\t\t   IS_G33(dev_priv) || IS_PINEVIEW(dev_priv)) {\n\t\ttmp = intel_de_read(dev_priv, DPLL(crtc->pipe));\n\t\tpipe_config->pixel_multiplier =\n\t\t\t((tmp & SDVO_MULTIPLIER_MASK)\n\t\t\t >> SDVO_MULTIPLIER_SHIFT_HIRES) + 1;\n\t} else {\n\t\t \n\t\tpipe_config->pixel_multiplier = 1;\n\t}\n\tpipe_config->dpll_hw_state.dpll = intel_de_read(dev_priv,\n\t\t\t\t\t\t\tDPLL(crtc->pipe));\n\tif (!IS_VALLEYVIEW(dev_priv) && !IS_CHERRYVIEW(dev_priv)) {\n\t\tpipe_config->dpll_hw_state.fp0 = intel_de_read(dev_priv,\n\t\t\t\t\t\t\t       FP0(crtc->pipe));\n\t\tpipe_config->dpll_hw_state.fp1 = intel_de_read(dev_priv,\n\t\t\t\t\t\t\t       FP1(crtc->pipe));\n\t} else {\n\t\t \n\t\tpipe_config->dpll_hw_state.dpll &= ~(DPLL_LOCK_VLV |\n\t\t\t\t\t\t     DPLL_PORTC_READY_MASK |\n\t\t\t\t\t\t     DPLL_PORTB_READY_MASK);\n\t}\n\n\tif (IS_CHERRYVIEW(dev_priv))\n\t\tchv_crtc_clock_get(crtc, pipe_config);\n\telse if (IS_VALLEYVIEW(dev_priv))\n\t\tvlv_crtc_clock_get(crtc, pipe_config);\n\telse\n\t\ti9xx_crtc_clock_get(crtc, pipe_config);\n\n\t \n\tpipe_config->hw.adjusted_mode.crtc_clock =\n\t\tpipe_config->port_clock / pipe_config->pixel_multiplier;\n\n\tret = true;\n\nout:\n\tintel_display_power_put(dev_priv, power_domain, wakeref);\n\n\treturn ret;\n}\n\nvoid ilk_set_pipeconf(const struct intel_crtc_state *crtc_state)\n{\n\tstruct intel_crtc *crtc = to_intel_crtc(crtc_state->uapi.crtc);\n\tstruct drm_i915_private *dev_priv = to_i915(crtc->base.dev);\n\tenum transcoder cpu_transcoder = crtc_state->cpu_transcoder;\n\tu32 val = 0;\n\n\t \n\tif (!intel_crtc_needs_modeset(crtc_state))\n\t\tval |= TRANSCONF_ENABLE;\n\n\tswitch (crtc_state->pipe_bpp) {\n\tdefault:\n\t\t \n\t\tMISSING_CASE(crtc_state->pipe_bpp);\n\t\tfallthrough;\n\tcase 18:\n\t\tval |= TRANSCONF_BPC_6;\n\t\tbreak;\n\tcase 24:\n\t\tval |= TRANSCONF_BPC_8;\n\t\tbreak;\n\tcase 30:\n\t\tval |= TRANSCONF_BPC_10;\n\t\tbreak;\n\tcase 36:\n\t\tval |= TRANSCONF_BPC_12;\n\t\tbreak;\n\t}\n\n\tif (crtc_state->dither)\n\t\tval |= TRANSCONF_DITHER_EN | TRANSCONF_DITHER_TYPE_SP;\n\n\tif (crtc_state->hw.adjusted_mode.flags & DRM_MODE_FLAG_INTERLACE)\n\t\tval |= TRANSCONF_INTERLACE_IF_ID_ILK;\n\telse\n\t\tval |= TRANSCONF_INTERLACE_PF_PD_ILK;\n\n\t \n\tdrm_WARN_ON(&dev_priv->drm, crtc_state->limited_color_range &&\n\t\t    crtc_state->output_format != INTEL_OUTPUT_FORMAT_RGB);\n\n\tif (crtc_state->limited_color_range &&\n\t    !intel_crtc_has_type(crtc_state, INTEL_OUTPUT_SDVO))\n\t\tval |= TRANSCONF_COLOR_RANGE_SELECT;\n\n\tif (crtc_state->output_format != INTEL_OUTPUT_FORMAT_RGB)\n\t\tval |= TRANSCONF_OUTPUT_COLORSPACE_YUV709;\n\n\tval |= TRANSCONF_GAMMA_MODE(crtc_state->gamma_mode);\n\n\tval |= TRANSCONF_FRAME_START_DELAY(crtc_state->framestart_delay - 1);\n\tval |= TRANSCONF_MSA_TIMING_DELAY(crtc_state->msa_timing_delay);\n\n\tintel_de_write(dev_priv, TRANSCONF(cpu_transcoder), val);\n\tintel_de_posting_read(dev_priv, TRANSCONF(cpu_transcoder));\n}\n\nstatic void hsw_set_transconf(const struct intel_crtc_state *crtc_state)\n{\n\tstruct intel_crtc *crtc = to_intel_crtc(crtc_state->uapi.crtc);\n\tstruct drm_i915_private *dev_priv = to_i915(crtc->base.dev);\n\tenum transcoder cpu_transcoder = crtc_state->cpu_transcoder;\n\tu32 val = 0;\n\n\t \n\tif (!intel_crtc_needs_modeset(crtc_state))\n\t\tval |= TRANSCONF_ENABLE;\n\n\tif (IS_HASWELL(dev_priv) && crtc_state->dither)\n\t\tval |= TRANSCONF_DITHER_EN | TRANSCONF_DITHER_TYPE_SP;\n\n\tif (crtc_state->hw.adjusted_mode.flags & DRM_MODE_FLAG_INTERLACE)\n\t\tval |= TRANSCONF_INTERLACE_IF_ID_ILK;\n\telse\n\t\tval |= TRANSCONF_INTERLACE_PF_PD_ILK;\n\n\tif (IS_HASWELL(dev_priv) &&\n\t    crtc_state->output_format != INTEL_OUTPUT_FORMAT_RGB)\n\t\tval |= TRANSCONF_OUTPUT_COLORSPACE_YUV_HSW;\n\n\tintel_de_write(dev_priv, TRANSCONF(cpu_transcoder), val);\n\tintel_de_posting_read(dev_priv, TRANSCONF(cpu_transcoder));\n}\n\nstatic void bdw_set_pipe_misc(const struct intel_crtc_state *crtc_state)\n{\n\tstruct intel_crtc *crtc = to_intel_crtc(crtc_state->uapi.crtc);\n\tstruct drm_i915_private *dev_priv = to_i915(crtc->base.dev);\n\tu32 val = 0;\n\n\tswitch (crtc_state->pipe_bpp) {\n\tcase 18:\n\t\tval |= PIPE_MISC_BPC_6;\n\t\tbreak;\n\tcase 24:\n\t\tval |= PIPE_MISC_BPC_8;\n\t\tbreak;\n\tcase 30:\n\t\tval |= PIPE_MISC_BPC_10;\n\t\tbreak;\n\tcase 36:\n\t\t \n\t\tif (DISPLAY_VER(dev_priv) > 12)\n\t\t\tval |= PIPE_MISC_BPC_12_ADLP;\n\t\tbreak;\n\tdefault:\n\t\tMISSING_CASE(crtc_state->pipe_bpp);\n\t\tbreak;\n\t}\n\n\tif (crtc_state->dither)\n\t\tval |= PIPE_MISC_DITHER_ENABLE | PIPE_MISC_DITHER_TYPE_SP;\n\n\tif (crtc_state->output_format == INTEL_OUTPUT_FORMAT_YCBCR420 ||\n\t    crtc_state->output_format == INTEL_OUTPUT_FORMAT_YCBCR444)\n\t\tval |= PIPE_MISC_OUTPUT_COLORSPACE_YUV;\n\n\tif (crtc_state->output_format == INTEL_OUTPUT_FORMAT_YCBCR420)\n\t\tval |= PIPE_MISC_YUV420_ENABLE |\n\t\t\tPIPE_MISC_YUV420_MODE_FULL_BLEND;\n\n\tif (DISPLAY_VER(dev_priv) >= 11 && is_hdr_mode(crtc_state))\n\t\tval |= PIPE_MISC_HDR_MODE_PRECISION;\n\n\tif (DISPLAY_VER(dev_priv) >= 12)\n\t\tval |= PIPE_MISC_PIXEL_ROUNDING_TRUNC;\n\n\t \n\tif (IS_BROADWELL(dev_priv))\n\t\tval |= PIPE_MISC_PSR_MASK_SPRITE_ENABLE;\n\n\tintel_de_write(dev_priv, PIPE_MISC(crtc->pipe), val);\n}\n\nint bdw_get_pipe_misc_bpp(struct intel_crtc *crtc)\n{\n\tstruct drm_i915_private *dev_priv = to_i915(crtc->base.dev);\n\tu32 tmp;\n\n\ttmp = intel_de_read(dev_priv, PIPE_MISC(crtc->pipe));\n\n\tswitch (tmp & PIPE_MISC_BPC_MASK) {\n\tcase PIPE_MISC_BPC_6:\n\t\treturn 18;\n\tcase PIPE_MISC_BPC_8:\n\t\treturn 24;\n\tcase PIPE_MISC_BPC_10:\n\t\treturn 30;\n\t \n\tcase PIPE_MISC_BPC_12_ADLP:\n\t\tif (DISPLAY_VER(dev_priv) > 12)\n\t\t\treturn 36;\n\t\tfallthrough;\n\tdefault:\n\t\tMISSING_CASE(tmp);\n\t\treturn 0;\n\t}\n}\n\nint ilk_get_lanes_required(int target_clock, int link_bw, int bpp)\n{\n\t \n\tu32 bps = target_clock * bpp * 21 / 20;\n\treturn DIV_ROUND_UP(bps, link_bw * 8);\n}\n\nvoid intel_get_m_n(struct drm_i915_private *i915,\n\t\t   struct intel_link_m_n *m_n,\n\t\t   i915_reg_t data_m_reg, i915_reg_t data_n_reg,\n\t\t   i915_reg_t link_m_reg, i915_reg_t link_n_reg)\n{\n\tm_n->link_m = intel_de_read(i915, link_m_reg) & DATA_LINK_M_N_MASK;\n\tm_n->link_n = intel_de_read(i915, link_n_reg) & DATA_LINK_M_N_MASK;\n\tm_n->data_m = intel_de_read(i915, data_m_reg) & DATA_LINK_M_N_MASK;\n\tm_n->data_n = intel_de_read(i915, data_n_reg) & DATA_LINK_M_N_MASK;\n\tm_n->tu = REG_FIELD_GET(TU_SIZE_MASK, intel_de_read(i915, data_m_reg)) + 1;\n}\n\nvoid intel_cpu_transcoder_get_m1_n1(struct intel_crtc *crtc,\n\t\t\t\t    enum transcoder transcoder,\n\t\t\t\t    struct intel_link_m_n *m_n)\n{\n\tstruct drm_i915_private *dev_priv = to_i915(crtc->base.dev);\n\tenum pipe pipe = crtc->pipe;\n\n\tif (DISPLAY_VER(dev_priv) >= 5)\n\t\tintel_get_m_n(dev_priv, m_n,\n\t\t\t      PIPE_DATA_M1(transcoder), PIPE_DATA_N1(transcoder),\n\t\t\t      PIPE_LINK_M1(transcoder), PIPE_LINK_N1(transcoder));\n\telse\n\t\tintel_get_m_n(dev_priv, m_n,\n\t\t\t      PIPE_DATA_M_G4X(pipe), PIPE_DATA_N_G4X(pipe),\n\t\t\t      PIPE_LINK_M_G4X(pipe), PIPE_LINK_N_G4X(pipe));\n}\n\nvoid intel_cpu_transcoder_get_m2_n2(struct intel_crtc *crtc,\n\t\t\t\t    enum transcoder transcoder,\n\t\t\t\t    struct intel_link_m_n *m_n)\n{\n\tstruct drm_i915_private *dev_priv = to_i915(crtc->base.dev);\n\n\tif (!intel_cpu_transcoder_has_m2_n2(dev_priv, transcoder))\n\t\treturn;\n\n\tintel_get_m_n(dev_priv, m_n,\n\t\t      PIPE_DATA_M2(transcoder), PIPE_DATA_N2(transcoder),\n\t\t      PIPE_LINK_M2(transcoder), PIPE_LINK_N2(transcoder));\n}\n\nstatic void ilk_get_pfit_config(struct intel_crtc_state *crtc_state)\n{\n\tstruct intel_crtc *crtc = to_intel_crtc(crtc_state->uapi.crtc);\n\tstruct drm_i915_private *dev_priv = to_i915(crtc->base.dev);\n\tu32 ctl, pos, size;\n\tenum pipe pipe;\n\n\tctl = intel_de_read(dev_priv, PF_CTL(crtc->pipe));\n\tif ((ctl & PF_ENABLE) == 0)\n\t\treturn;\n\n\tif (IS_IVYBRIDGE(dev_priv) || IS_HASWELL(dev_priv))\n\t\tpipe = REG_FIELD_GET(PF_PIPE_SEL_MASK_IVB, ctl);\n\telse\n\t\tpipe = crtc->pipe;\n\n\tcrtc_state->pch_pfit.enabled = true;\n\n\tpos = intel_de_read(dev_priv, PF_WIN_POS(crtc->pipe));\n\tsize = intel_de_read(dev_priv, PF_WIN_SZ(crtc->pipe));\n\n\tdrm_rect_init(&crtc_state->pch_pfit.dst,\n\t\t      REG_FIELD_GET(PF_WIN_XPOS_MASK, pos),\n\t\t      REG_FIELD_GET(PF_WIN_YPOS_MASK, pos),\n\t\t      REG_FIELD_GET(PF_WIN_XSIZE_MASK, size),\n\t\t      REG_FIELD_GET(PF_WIN_YSIZE_MASK, size));\n\n\t \n\tdrm_WARN_ON(&dev_priv->drm, pipe != crtc->pipe);\n}\n\nstatic bool ilk_get_pipe_config(struct intel_crtc *crtc,\n\t\t\t\tstruct intel_crtc_state *pipe_config)\n{\n\tstruct drm_device *dev = crtc->base.dev;\n\tstruct drm_i915_private *dev_priv = to_i915(dev);\n\tenum intel_display_power_domain power_domain;\n\tintel_wakeref_t wakeref;\n\tu32 tmp;\n\tbool ret;\n\n\tpower_domain = POWER_DOMAIN_PIPE(crtc->pipe);\n\twakeref = intel_display_power_get_if_enabled(dev_priv, power_domain);\n\tif (!wakeref)\n\t\treturn false;\n\n\tpipe_config->cpu_transcoder = (enum transcoder) crtc->pipe;\n\tpipe_config->shared_dpll = NULL;\n\n\tret = false;\n\ttmp = intel_de_read(dev_priv, TRANSCONF(pipe_config->cpu_transcoder));\n\tif (!(tmp & TRANSCONF_ENABLE))\n\t\tgoto out;\n\n\tswitch (tmp & TRANSCONF_BPC_MASK) {\n\tcase TRANSCONF_BPC_6:\n\t\tpipe_config->pipe_bpp = 18;\n\t\tbreak;\n\tcase TRANSCONF_BPC_8:\n\t\tpipe_config->pipe_bpp = 24;\n\t\tbreak;\n\tcase TRANSCONF_BPC_10:\n\t\tpipe_config->pipe_bpp = 30;\n\t\tbreak;\n\tcase TRANSCONF_BPC_12:\n\t\tpipe_config->pipe_bpp = 36;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tif (tmp & TRANSCONF_COLOR_RANGE_SELECT)\n\t\tpipe_config->limited_color_range = true;\n\n\tswitch (tmp & TRANSCONF_OUTPUT_COLORSPACE_MASK) {\n\tcase TRANSCONF_OUTPUT_COLORSPACE_YUV601:\n\tcase TRANSCONF_OUTPUT_COLORSPACE_YUV709:\n\t\tpipe_config->output_format = INTEL_OUTPUT_FORMAT_YCBCR444;\n\t\tbreak;\n\tdefault:\n\t\tpipe_config->output_format = INTEL_OUTPUT_FORMAT_RGB;\n\t\tbreak;\n\t}\n\n\tpipe_config->sink_format = pipe_config->output_format;\n\n\tpipe_config->gamma_mode = REG_FIELD_GET(TRANSCONF_GAMMA_MODE_MASK_ILK, tmp);\n\n\tpipe_config->framestart_delay = REG_FIELD_GET(TRANSCONF_FRAME_START_DELAY_MASK, tmp) + 1;\n\n\tpipe_config->msa_timing_delay = REG_FIELD_GET(TRANSCONF_MSA_TIMING_DELAY_MASK, tmp);\n\n\tpipe_config->csc_mode = intel_de_read(dev_priv,\n\t\t\t\t\t      PIPE_CSC_MODE(crtc->pipe));\n\n\ti9xx_get_pipe_color_config(pipe_config);\n\tintel_color_get_config(pipe_config);\n\n\tpipe_config->pixel_multiplier = 1;\n\n\tilk_pch_get_config(pipe_config);\n\n\tintel_get_transcoder_timings(crtc, pipe_config);\n\tintel_get_pipe_src_size(crtc, pipe_config);\n\n\tilk_get_pfit_config(pipe_config);\n\n\tret = true;\n\nout:\n\tintel_display_power_put(dev_priv, power_domain, wakeref);\n\n\treturn ret;\n}\n\nstatic u8 bigjoiner_pipes(struct drm_i915_private *i915)\n{\n\tu8 pipes;\n\n\tif (DISPLAY_VER(i915) >= 12)\n\t\tpipes = BIT(PIPE_A) | BIT(PIPE_B) | BIT(PIPE_C) | BIT(PIPE_D);\n\telse if (DISPLAY_VER(i915) >= 11)\n\t\tpipes = BIT(PIPE_B) | BIT(PIPE_C);\n\telse\n\t\tpipes = 0;\n\n\treturn pipes & DISPLAY_RUNTIME_INFO(i915)->pipe_mask;\n}\n\nstatic bool transcoder_ddi_func_is_enabled(struct drm_i915_private *dev_priv,\n\t\t\t\t\t   enum transcoder cpu_transcoder)\n{\n\tenum intel_display_power_domain power_domain;\n\tintel_wakeref_t wakeref;\n\tu32 tmp = 0;\n\n\tpower_domain = POWER_DOMAIN_TRANSCODER(cpu_transcoder);\n\n\twith_intel_display_power_if_enabled(dev_priv, power_domain, wakeref)\n\t\ttmp = intel_de_read(dev_priv, TRANS_DDI_FUNC_CTL(cpu_transcoder));\n\n\treturn tmp & TRANS_DDI_FUNC_ENABLE;\n}\n\nstatic void enabled_bigjoiner_pipes(struct drm_i915_private *dev_priv,\n\t\t\t\t    u8 *master_pipes, u8 *slave_pipes)\n{\n\tstruct intel_crtc *crtc;\n\n\t*master_pipes = 0;\n\t*slave_pipes = 0;\n\n\tfor_each_intel_crtc_in_pipe_mask(&dev_priv->drm, crtc,\n\t\t\t\t\t bigjoiner_pipes(dev_priv)) {\n\t\tenum intel_display_power_domain power_domain;\n\t\tenum pipe pipe = crtc->pipe;\n\t\tintel_wakeref_t wakeref;\n\n\t\tpower_domain = intel_dsc_power_domain(crtc, (enum transcoder) pipe);\n\t\twith_intel_display_power_if_enabled(dev_priv, power_domain, wakeref) {\n\t\t\tu32 tmp = intel_de_read(dev_priv, ICL_PIPE_DSS_CTL1(pipe));\n\n\t\t\tif (!(tmp & BIG_JOINER_ENABLE))\n\t\t\t\tcontinue;\n\n\t\t\tif (tmp & MASTER_BIG_JOINER_ENABLE)\n\t\t\t\t*master_pipes |= BIT(pipe);\n\t\t\telse\n\t\t\t\t*slave_pipes |= BIT(pipe);\n\t\t}\n\n\t\tif (DISPLAY_VER(dev_priv) < 13)\n\t\t\tcontinue;\n\n\t\tpower_domain = POWER_DOMAIN_PIPE(pipe);\n\t\twith_intel_display_power_if_enabled(dev_priv, power_domain, wakeref) {\n\t\t\tu32 tmp = intel_de_read(dev_priv, ICL_PIPE_DSS_CTL1(pipe));\n\n\t\t\tif (tmp & UNCOMPRESSED_JOINER_MASTER)\n\t\t\t\t*master_pipes |= BIT(pipe);\n\t\t\tif (tmp & UNCOMPRESSED_JOINER_SLAVE)\n\t\t\t\t*slave_pipes |= BIT(pipe);\n\t\t}\n\t}\n\n\t \n\tdrm_WARN(&dev_priv->drm, *slave_pipes != *master_pipes << 1,\n\t\t \"Bigjoiner misconfigured (master pipes 0x%x, slave pipes 0x%x)\\n\",\n\t\t *master_pipes, *slave_pipes);\n}\n\nstatic enum pipe get_bigjoiner_master_pipe(enum pipe pipe, u8 master_pipes, u8 slave_pipes)\n{\n\tif ((slave_pipes & BIT(pipe)) == 0)\n\t\treturn pipe;\n\n\t \n\tmaster_pipes &= ~GENMASK(7, pipe);\n\n\t \n\treturn fls(master_pipes) - 1;\n}\n\nstatic u8 get_bigjoiner_slave_pipes(enum pipe pipe, u8 master_pipes, u8 slave_pipes)\n{\n\tenum pipe master_pipe, next_master_pipe;\n\n\tmaster_pipe = get_bigjoiner_master_pipe(pipe, master_pipes, slave_pipes);\n\n\tif ((master_pipes & BIT(master_pipe)) == 0)\n\t\treturn 0;\n\n\t \n\tmaster_pipes &= ~GENMASK(master_pipe, 0);\n\t \n\tmaster_pipes |= BIT(7);\n\t \n\tnext_master_pipe = ffs(master_pipes) - 1;\n\n\treturn slave_pipes & GENMASK(next_master_pipe - 1, master_pipe);\n}\n\nstatic u8 hsw_panel_transcoders(struct drm_i915_private *i915)\n{\n\tu8 panel_transcoder_mask = BIT(TRANSCODER_EDP);\n\n\tif (DISPLAY_VER(i915) >= 11)\n\t\tpanel_transcoder_mask |= BIT(TRANSCODER_DSI_0) | BIT(TRANSCODER_DSI_1);\n\n\treturn panel_transcoder_mask;\n}\n\nstatic u8 hsw_enabled_transcoders(struct intel_crtc *crtc)\n{\n\tstruct drm_device *dev = crtc->base.dev;\n\tstruct drm_i915_private *dev_priv = to_i915(dev);\n\tu8 panel_transcoder_mask = hsw_panel_transcoders(dev_priv);\n\tenum transcoder cpu_transcoder;\n\tu8 master_pipes, slave_pipes;\n\tu8 enabled_transcoders = 0;\n\n\t \n\tfor_each_cpu_transcoder_masked(dev_priv, cpu_transcoder,\n\t\t\t\t       panel_transcoder_mask) {\n\t\tenum intel_display_power_domain power_domain;\n\t\tintel_wakeref_t wakeref;\n\t\tenum pipe trans_pipe;\n\t\tu32 tmp = 0;\n\n\t\tpower_domain = POWER_DOMAIN_TRANSCODER(cpu_transcoder);\n\t\twith_intel_display_power_if_enabled(dev_priv, power_domain, wakeref)\n\t\t\ttmp = intel_de_read(dev_priv, TRANS_DDI_FUNC_CTL(cpu_transcoder));\n\n\t\tif (!(tmp & TRANS_DDI_FUNC_ENABLE))\n\t\t\tcontinue;\n\n\t\tswitch (tmp & TRANS_DDI_EDP_INPUT_MASK) {\n\t\tdefault:\n\t\t\tdrm_WARN(dev, 1,\n\t\t\t\t \"unknown pipe linked to transcoder %s\\n\",\n\t\t\t\t transcoder_name(cpu_transcoder));\n\t\t\tfallthrough;\n\t\tcase TRANS_DDI_EDP_INPUT_A_ONOFF:\n\t\tcase TRANS_DDI_EDP_INPUT_A_ON:\n\t\t\ttrans_pipe = PIPE_A;\n\t\t\tbreak;\n\t\tcase TRANS_DDI_EDP_INPUT_B_ONOFF:\n\t\t\ttrans_pipe = PIPE_B;\n\t\t\tbreak;\n\t\tcase TRANS_DDI_EDP_INPUT_C_ONOFF:\n\t\t\ttrans_pipe = PIPE_C;\n\t\t\tbreak;\n\t\tcase TRANS_DDI_EDP_INPUT_D_ONOFF:\n\t\t\ttrans_pipe = PIPE_D;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (trans_pipe == crtc->pipe)\n\t\t\tenabled_transcoders |= BIT(cpu_transcoder);\n\t}\n\n\t \n\tcpu_transcoder = (enum transcoder) crtc->pipe;\n\tif (transcoder_ddi_func_is_enabled(dev_priv, cpu_transcoder))\n\t\tenabled_transcoders |= BIT(cpu_transcoder);\n\n\t \n\tenabled_bigjoiner_pipes(dev_priv, &master_pipes, &slave_pipes);\n\tif (slave_pipes & BIT(crtc->pipe)) {\n\t\tcpu_transcoder = (enum transcoder)\n\t\t\tget_bigjoiner_master_pipe(crtc->pipe, master_pipes, slave_pipes);\n\t\tif (transcoder_ddi_func_is_enabled(dev_priv, cpu_transcoder))\n\t\t\tenabled_transcoders |= BIT(cpu_transcoder);\n\t}\n\n\treturn enabled_transcoders;\n}\n\nstatic bool has_edp_transcoders(u8 enabled_transcoders)\n{\n\treturn enabled_transcoders & BIT(TRANSCODER_EDP);\n}\n\nstatic bool has_dsi_transcoders(u8 enabled_transcoders)\n{\n\treturn enabled_transcoders & (BIT(TRANSCODER_DSI_0) |\n\t\t\t\t      BIT(TRANSCODER_DSI_1));\n}\n\nstatic bool has_pipe_transcoders(u8 enabled_transcoders)\n{\n\treturn enabled_transcoders & ~(BIT(TRANSCODER_EDP) |\n\t\t\t\t       BIT(TRANSCODER_DSI_0) |\n\t\t\t\t       BIT(TRANSCODER_DSI_1));\n}\n\nstatic void assert_enabled_transcoders(struct drm_i915_private *i915,\n\t\t\t\t       u8 enabled_transcoders)\n{\n\t \n\tdrm_WARN_ON(&i915->drm,\n\t\t    has_edp_transcoders(enabled_transcoders) +\n\t\t    has_dsi_transcoders(enabled_transcoders) +\n\t\t    has_pipe_transcoders(enabled_transcoders) > 1);\n\n\t \n\tdrm_WARN_ON(&i915->drm,\n\t\t    !has_dsi_transcoders(enabled_transcoders) &&\n\t\t    !is_power_of_2(enabled_transcoders));\n}\n\nstatic bool hsw_get_transcoder_state(struct intel_crtc *crtc,\n\t\t\t\t     struct intel_crtc_state *pipe_config,\n\t\t\t\t     struct intel_display_power_domain_set *power_domain_set)\n{\n\tstruct drm_device *dev = crtc->base.dev;\n\tstruct drm_i915_private *dev_priv = to_i915(dev);\n\tunsigned long enabled_transcoders;\n\tu32 tmp;\n\n\tenabled_transcoders = hsw_enabled_transcoders(crtc);\n\tif (!enabled_transcoders)\n\t\treturn false;\n\n\tassert_enabled_transcoders(dev_priv, enabled_transcoders);\n\n\t \n\tpipe_config->cpu_transcoder = ffs(enabled_transcoders) - 1;\n\n\tif (!intel_display_power_get_in_set_if_enabled(dev_priv, power_domain_set,\n\t\t\t\t\t\t       POWER_DOMAIN_TRANSCODER(pipe_config->cpu_transcoder)))\n\t\treturn false;\n\n\tif (hsw_panel_transcoders(dev_priv) & BIT(pipe_config->cpu_transcoder)) {\n\t\ttmp = intel_de_read(dev_priv, TRANS_DDI_FUNC_CTL(pipe_config->cpu_transcoder));\n\n\t\tif ((tmp & TRANS_DDI_EDP_INPUT_MASK) == TRANS_DDI_EDP_INPUT_A_ONOFF)\n\t\t\tpipe_config->pch_pfit.force_thru = true;\n\t}\n\n\ttmp = intel_de_read(dev_priv, TRANSCONF(pipe_config->cpu_transcoder));\n\n\treturn tmp & TRANSCONF_ENABLE;\n}\n\nstatic bool bxt_get_dsi_transcoder_state(struct intel_crtc *crtc,\n\t\t\t\t\t struct intel_crtc_state *pipe_config,\n\t\t\t\t\t struct intel_display_power_domain_set *power_domain_set)\n{\n\tstruct drm_device *dev = crtc->base.dev;\n\tstruct drm_i915_private *dev_priv = to_i915(dev);\n\tenum transcoder cpu_transcoder;\n\tenum port port;\n\tu32 tmp;\n\n\tfor_each_port_masked(port, BIT(PORT_A) | BIT(PORT_C)) {\n\t\tif (port == PORT_A)\n\t\t\tcpu_transcoder = TRANSCODER_DSI_A;\n\t\telse\n\t\t\tcpu_transcoder = TRANSCODER_DSI_C;\n\n\t\tif (!intel_display_power_get_in_set_if_enabled(dev_priv, power_domain_set,\n\t\t\t\t\t\t\t       POWER_DOMAIN_TRANSCODER(cpu_transcoder)))\n\t\t\tcontinue;\n\n\t\t \n\t\tif (!bxt_dsi_pll_is_enabled(dev_priv))\n\t\t\tbreak;\n\n\t\t \n\t\ttmp = intel_de_read(dev_priv, BXT_MIPI_PORT_CTRL(port));\n\t\tif (!(tmp & DPI_ENABLE))\n\t\t\tcontinue;\n\n\t\ttmp = intel_de_read(dev_priv, MIPI_CTRL(port));\n\t\tif ((tmp & BXT_PIPE_SELECT_MASK) != BXT_PIPE_SELECT(crtc->pipe))\n\t\t\tcontinue;\n\n\t\tpipe_config->cpu_transcoder = cpu_transcoder;\n\t\tbreak;\n\t}\n\n\treturn transcoder_is_dsi(pipe_config->cpu_transcoder);\n}\n\nstatic void intel_bigjoiner_get_config(struct intel_crtc_state *crtc_state)\n{\n\tstruct intel_crtc *crtc = to_intel_crtc(crtc_state->uapi.crtc);\n\tstruct drm_i915_private *i915 = to_i915(crtc->base.dev);\n\tu8 master_pipes, slave_pipes;\n\tenum pipe pipe = crtc->pipe;\n\n\tenabled_bigjoiner_pipes(i915, &master_pipes, &slave_pipes);\n\n\tif (((master_pipes | slave_pipes) & BIT(pipe)) == 0)\n\t\treturn;\n\n\tcrtc_state->bigjoiner_pipes =\n\t\tBIT(get_bigjoiner_master_pipe(pipe, master_pipes, slave_pipes)) |\n\t\tget_bigjoiner_slave_pipes(pipe, master_pipes, slave_pipes);\n}\n\nstatic bool hsw_get_pipe_config(struct intel_crtc *crtc,\n\t\t\t\tstruct intel_crtc_state *pipe_config)\n{\n\tstruct drm_i915_private *dev_priv = to_i915(crtc->base.dev);\n\tbool active;\n\tu32 tmp;\n\n\tif (!intel_display_power_get_in_set_if_enabled(dev_priv, &crtc->hw_readout_power_domains,\n\t\t\t\t\t\t       POWER_DOMAIN_PIPE(crtc->pipe)))\n\t\treturn false;\n\n\tpipe_config->shared_dpll = NULL;\n\n\tactive = hsw_get_transcoder_state(crtc, pipe_config, &crtc->hw_readout_power_domains);\n\n\tif ((IS_GEMINILAKE(dev_priv) || IS_BROXTON(dev_priv)) &&\n\t    bxt_get_dsi_transcoder_state(crtc, pipe_config, &crtc->hw_readout_power_domains)) {\n\t\tdrm_WARN_ON(&dev_priv->drm, active);\n\t\tactive = true;\n\t}\n\n\tif (!active)\n\t\tgoto out;\n\n\tintel_dsc_get_config(pipe_config);\n\tintel_bigjoiner_get_config(pipe_config);\n\n\tif (!transcoder_is_dsi(pipe_config->cpu_transcoder) ||\n\t    DISPLAY_VER(dev_priv) >= 11)\n\t\tintel_get_transcoder_timings(crtc, pipe_config);\n\n\tif (HAS_VRR(dev_priv) && !transcoder_is_dsi(pipe_config->cpu_transcoder))\n\t\tintel_vrr_get_config(pipe_config);\n\n\tintel_get_pipe_src_size(crtc, pipe_config);\n\n\tif (IS_HASWELL(dev_priv)) {\n\t\tu32 tmp = intel_de_read(dev_priv,\n\t\t\t\t\tTRANSCONF(pipe_config->cpu_transcoder));\n\n\t\tif (tmp & TRANSCONF_OUTPUT_COLORSPACE_YUV_HSW)\n\t\t\tpipe_config->output_format = INTEL_OUTPUT_FORMAT_YCBCR444;\n\t\telse\n\t\t\tpipe_config->output_format = INTEL_OUTPUT_FORMAT_RGB;\n\t} else {\n\t\tpipe_config->output_format =\n\t\t\tbdw_get_pipe_misc_output_format(crtc);\n\t}\n\n\tpipe_config->sink_format = pipe_config->output_format;\n\n\tpipe_config->gamma_mode = intel_de_read(dev_priv,\n\t\t\t\t\t\tGAMMA_MODE(crtc->pipe));\n\n\tpipe_config->csc_mode = intel_de_read(dev_priv,\n\t\t\t\t\t      PIPE_CSC_MODE(crtc->pipe));\n\n\tif (DISPLAY_VER(dev_priv) >= 9) {\n\t\ttmp = intel_de_read(dev_priv, SKL_BOTTOM_COLOR(crtc->pipe));\n\n\t\tif (tmp & SKL_BOTTOM_COLOR_GAMMA_ENABLE)\n\t\t\tpipe_config->gamma_enable = true;\n\n\t\tif (tmp & SKL_BOTTOM_COLOR_CSC_ENABLE)\n\t\t\tpipe_config->csc_enable = true;\n\t} else {\n\t\ti9xx_get_pipe_color_config(pipe_config);\n\t}\n\n\tintel_color_get_config(pipe_config);\n\n\ttmp = intel_de_read(dev_priv, WM_LINETIME(crtc->pipe));\n\tpipe_config->linetime = REG_FIELD_GET(HSW_LINETIME_MASK, tmp);\n\tif (IS_BROADWELL(dev_priv) || IS_HASWELL(dev_priv))\n\t\tpipe_config->ips_linetime =\n\t\t\tREG_FIELD_GET(HSW_IPS_LINETIME_MASK, tmp);\n\n\tif (intel_display_power_get_in_set_if_enabled(dev_priv, &crtc->hw_readout_power_domains,\n\t\t\t\t\t\t      POWER_DOMAIN_PIPE_PANEL_FITTER(crtc->pipe))) {\n\t\tif (DISPLAY_VER(dev_priv) >= 9)\n\t\t\tskl_scaler_get_config(pipe_config);\n\t\telse\n\t\t\tilk_get_pfit_config(pipe_config);\n\t}\n\n\thsw_ips_get_config(pipe_config);\n\n\tif (pipe_config->cpu_transcoder != TRANSCODER_EDP &&\n\t    !transcoder_is_dsi(pipe_config->cpu_transcoder)) {\n\t\tpipe_config->pixel_multiplier =\n\t\t\tintel_de_read(dev_priv,\n\t\t\t\t      TRANS_MULT(pipe_config->cpu_transcoder)) + 1;\n\t} else {\n\t\tpipe_config->pixel_multiplier = 1;\n\t}\n\n\tif (!transcoder_is_dsi(pipe_config->cpu_transcoder)) {\n\t\ttmp = intel_de_read(dev_priv, DISPLAY_VER(dev_priv) >= 14 ?\n\t\t\t\t    MTL_CHICKEN_TRANS(pipe_config->cpu_transcoder) :\n\t\t\t\t    CHICKEN_TRANS(pipe_config->cpu_transcoder));\n\n\t\tpipe_config->framestart_delay = REG_FIELD_GET(HSW_FRAME_START_DELAY_MASK, tmp) + 1;\n\t} else {\n\t\t \n\t\tpipe_config->framestart_delay = 1;\n\t}\n\nout:\n\tintel_display_power_put_all_in_set(dev_priv, &crtc->hw_readout_power_domains);\n\n\treturn active;\n}\n\nbool intel_crtc_get_pipe_config(struct intel_crtc_state *crtc_state)\n{\n\tstruct intel_crtc *crtc = to_intel_crtc(crtc_state->uapi.crtc);\n\tstruct drm_i915_private *i915 = to_i915(crtc->base.dev);\n\n\tif (!i915->display.funcs.display->get_pipe_config(crtc, crtc_state))\n\t\treturn false;\n\n\tcrtc_state->hw.active = true;\n\n\tintel_crtc_readout_derived_state(crtc_state);\n\n\treturn true;\n}\n\nstatic int i9xx_pll_refclk(struct drm_device *dev,\n\t\t\t   const struct intel_crtc_state *pipe_config)\n{\n\tstruct drm_i915_private *dev_priv = to_i915(dev);\n\tu32 dpll = pipe_config->dpll_hw_state.dpll;\n\n\tif ((dpll & PLL_REF_INPUT_MASK) == PLLB_REF_INPUT_SPREADSPECTRUMIN)\n\t\treturn dev_priv->display.vbt.lvds_ssc_freq;\n\telse if (HAS_PCH_SPLIT(dev_priv))\n\t\treturn 120000;\n\telse if (DISPLAY_VER(dev_priv) != 2)\n\t\treturn 96000;\n\telse\n\t\treturn 48000;\n}\n\n \nvoid i9xx_crtc_clock_get(struct intel_crtc *crtc,\n\t\t\t struct intel_crtc_state *pipe_config)\n{\n\tstruct drm_device *dev = crtc->base.dev;\n\tstruct drm_i915_private *dev_priv = to_i915(dev);\n\tu32 dpll = pipe_config->dpll_hw_state.dpll;\n\tu32 fp;\n\tstruct dpll clock;\n\tint port_clock;\n\tint refclk = i9xx_pll_refclk(dev, pipe_config);\n\n\tif ((dpll & DISPLAY_RATE_SELECT_FPA1) == 0)\n\t\tfp = pipe_config->dpll_hw_state.fp0;\n\telse\n\t\tfp = pipe_config->dpll_hw_state.fp1;\n\n\tclock.m1 = (fp & FP_M1_DIV_MASK) >> FP_M1_DIV_SHIFT;\n\tif (IS_PINEVIEW(dev_priv)) {\n\t\tclock.n = ffs((fp & FP_N_PINEVIEW_DIV_MASK) >> FP_N_DIV_SHIFT) - 1;\n\t\tclock.m2 = (fp & FP_M2_PINEVIEW_DIV_MASK) >> FP_M2_DIV_SHIFT;\n\t} else {\n\t\tclock.n = (fp & FP_N_DIV_MASK) >> FP_N_DIV_SHIFT;\n\t\tclock.m2 = (fp & FP_M2_DIV_MASK) >> FP_M2_DIV_SHIFT;\n\t}\n\n\tif (DISPLAY_VER(dev_priv) != 2) {\n\t\tif (IS_PINEVIEW(dev_priv))\n\t\t\tclock.p1 = ffs((dpll & DPLL_FPA01_P1_POST_DIV_MASK_PINEVIEW) >>\n\t\t\t\tDPLL_FPA01_P1_POST_DIV_SHIFT_PINEVIEW);\n\t\telse\n\t\t\tclock.p1 = ffs((dpll & DPLL_FPA01_P1_POST_DIV_MASK) >>\n\t\t\t       DPLL_FPA01_P1_POST_DIV_SHIFT);\n\n\t\tswitch (dpll & DPLL_MODE_MASK) {\n\t\tcase DPLLB_MODE_DAC_SERIAL:\n\t\t\tclock.p2 = dpll & DPLL_DAC_SERIAL_P2_CLOCK_DIV_5 ?\n\t\t\t\t5 : 10;\n\t\t\tbreak;\n\t\tcase DPLLB_MODE_LVDS:\n\t\t\tclock.p2 = dpll & DPLLB_LVDS_P2_CLOCK_DIV_7 ?\n\t\t\t\t7 : 14;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdrm_dbg_kms(&dev_priv->drm,\n\t\t\t\t    \"Unknown DPLL mode %08x in programmed \"\n\t\t\t\t    \"mode\\n\", (int)(dpll & DPLL_MODE_MASK));\n\t\t\treturn;\n\t\t}\n\n\t\tif (IS_PINEVIEW(dev_priv))\n\t\t\tport_clock = pnv_calc_dpll_params(refclk, &clock);\n\t\telse\n\t\t\tport_clock = i9xx_calc_dpll_params(refclk, &clock);\n\t} else {\n\t\tenum pipe lvds_pipe;\n\n\t\tif (IS_I85X(dev_priv) &&\n\t\t    intel_lvds_port_enabled(dev_priv, LVDS, &lvds_pipe) &&\n\t\t    lvds_pipe == crtc->pipe) {\n\t\t\tu32 lvds = intel_de_read(dev_priv, LVDS);\n\n\t\t\tclock.p1 = ffs((dpll & DPLL_FPA01_P1_POST_DIV_MASK_I830_LVDS) >>\n\t\t\t\t       DPLL_FPA01_P1_POST_DIV_SHIFT);\n\n\t\t\tif (lvds & LVDS_CLKB_POWER_UP)\n\t\t\t\tclock.p2 = 7;\n\t\t\telse\n\t\t\t\tclock.p2 = 14;\n\t\t} else {\n\t\t\tif (dpll & PLL_P1_DIVIDE_BY_TWO)\n\t\t\t\tclock.p1 = 2;\n\t\t\telse {\n\t\t\t\tclock.p1 = ((dpll & DPLL_FPA01_P1_POST_DIV_MASK_I830) >>\n\t\t\t\t\t    DPLL_FPA01_P1_POST_DIV_SHIFT) + 2;\n\t\t\t}\n\t\t\tif (dpll & PLL_P2_DIVIDE_BY_4)\n\t\t\t\tclock.p2 = 4;\n\t\t\telse\n\t\t\t\tclock.p2 = 2;\n\t\t}\n\n\t\tport_clock = i9xx_calc_dpll_params(refclk, &clock);\n\t}\n\n\t \n\tpipe_config->port_clock = port_clock;\n}\n\nint intel_dotclock_calculate(int link_freq,\n\t\t\t     const struct intel_link_m_n *m_n)\n{\n\t \n\n\tif (!m_n->link_n)\n\t\treturn 0;\n\n\treturn DIV_ROUND_UP_ULL(mul_u32_u32(m_n->link_m, link_freq),\n\t\t\t\tm_n->link_n);\n}\n\nint intel_crtc_dotclock(const struct intel_crtc_state *pipe_config)\n{\n\tint dotclock;\n\n\tif (intel_crtc_has_dp_encoder(pipe_config))\n\t\tdotclock = intel_dotclock_calculate(pipe_config->port_clock,\n\t\t\t\t\t\t    &pipe_config->dp_m_n);\n\telse if (pipe_config->has_hdmi_sink && pipe_config->pipe_bpp > 24)\n\t\tdotclock = DIV_ROUND_CLOSEST(pipe_config->port_clock * 24,\n\t\t\t\t\t     pipe_config->pipe_bpp);\n\telse\n\t\tdotclock = pipe_config->port_clock;\n\n\tif (pipe_config->output_format == INTEL_OUTPUT_FORMAT_YCBCR420 &&\n\t    !intel_crtc_has_dp_encoder(pipe_config))\n\t\tdotclock *= 2;\n\n\tif (pipe_config->pixel_multiplier)\n\t\tdotclock /= pipe_config->pixel_multiplier;\n\n\treturn dotclock;\n}\n\n \nstruct drm_display_mode *\nintel_encoder_current_mode(struct intel_encoder *encoder)\n{\n\tstruct drm_i915_private *dev_priv = to_i915(encoder->base.dev);\n\tstruct intel_crtc_state *crtc_state;\n\tstruct drm_display_mode *mode;\n\tstruct intel_crtc *crtc;\n\tenum pipe pipe;\n\n\tif (!encoder->get_hw_state(encoder, &pipe))\n\t\treturn NULL;\n\n\tcrtc = intel_crtc_for_pipe(dev_priv, pipe);\n\n\tmode = kzalloc(sizeof(*mode), GFP_KERNEL);\n\tif (!mode)\n\t\treturn NULL;\n\n\tcrtc_state = intel_crtc_state_alloc(crtc);\n\tif (!crtc_state) {\n\t\tkfree(mode);\n\t\treturn NULL;\n\t}\n\n\tif (!intel_crtc_get_pipe_config(crtc_state)) {\n\t\tkfree(crtc_state);\n\t\tkfree(mode);\n\t\treturn NULL;\n\t}\n\n\tintel_encoder_get_config(encoder, crtc_state);\n\n\tintel_mode_from_crtc_timings(mode, &crtc_state->hw.adjusted_mode);\n\n\tkfree(crtc_state);\n\n\treturn mode;\n}\n\nstatic bool encoders_cloneable(const struct intel_encoder *a,\n\t\t\t       const struct intel_encoder *b)\n{\n\t \n\treturn a == b || (a->cloneable & BIT(b->type) &&\n\t\t\t  b->cloneable & BIT(a->type));\n}\n\nstatic bool check_single_encoder_cloning(struct intel_atomic_state *state,\n\t\t\t\t\t struct intel_crtc *crtc,\n\t\t\t\t\t struct intel_encoder *encoder)\n{\n\tstruct intel_encoder *source_encoder;\n\tstruct drm_connector *connector;\n\tstruct drm_connector_state *connector_state;\n\tint i;\n\n\tfor_each_new_connector_in_state(&state->base, connector, connector_state, i) {\n\t\tif (connector_state->crtc != &crtc->base)\n\t\t\tcontinue;\n\n\t\tsource_encoder =\n\t\t\tto_intel_encoder(connector_state->best_encoder);\n\t\tif (!encoders_cloneable(encoder, source_encoder))\n\t\t\treturn false;\n\t}\n\n\treturn true;\n}\n\nstatic int icl_add_linked_planes(struct intel_atomic_state *state)\n{\n\tstruct intel_plane *plane, *linked;\n\tstruct intel_plane_state *plane_state, *linked_plane_state;\n\tint i;\n\n\tfor_each_new_intel_plane_in_state(state, plane, plane_state, i) {\n\t\tlinked = plane_state->planar_linked_plane;\n\n\t\tif (!linked)\n\t\t\tcontinue;\n\n\t\tlinked_plane_state = intel_atomic_get_plane_state(state, linked);\n\t\tif (IS_ERR(linked_plane_state))\n\t\t\treturn PTR_ERR(linked_plane_state);\n\n\t\tdrm_WARN_ON(state->base.dev,\n\t\t\t    linked_plane_state->planar_linked_plane != plane);\n\t\tdrm_WARN_ON(state->base.dev,\n\t\t\t    linked_plane_state->planar_slave == plane_state->planar_slave);\n\t}\n\n\treturn 0;\n}\n\nstatic int icl_check_nv12_planes(struct intel_crtc_state *crtc_state)\n{\n\tstruct intel_crtc *crtc = to_intel_crtc(crtc_state->uapi.crtc);\n\tstruct drm_i915_private *dev_priv = to_i915(crtc->base.dev);\n\tstruct intel_atomic_state *state = to_intel_atomic_state(crtc_state->uapi.state);\n\tstruct intel_plane *plane, *linked;\n\tstruct intel_plane_state *plane_state;\n\tint i;\n\n\tif (DISPLAY_VER(dev_priv) < 11)\n\t\treturn 0;\n\n\t \n\tfor_each_new_intel_plane_in_state(state, plane, plane_state, i) {\n\t\tif (plane->pipe != crtc->pipe || !plane_state->planar_linked_plane)\n\t\t\tcontinue;\n\n\t\tplane_state->planar_linked_plane = NULL;\n\t\tif (plane_state->planar_slave && !plane_state->uapi.visible) {\n\t\t\tcrtc_state->enabled_planes &= ~BIT(plane->id);\n\t\t\tcrtc_state->active_planes &= ~BIT(plane->id);\n\t\t\tcrtc_state->update_planes |= BIT(plane->id);\n\t\t\tcrtc_state->data_rate[plane->id] = 0;\n\t\t\tcrtc_state->rel_data_rate[plane->id] = 0;\n\t\t}\n\n\t\tplane_state->planar_slave = false;\n\t}\n\n\tif (!crtc_state->nv12_planes)\n\t\treturn 0;\n\n\tfor_each_new_intel_plane_in_state(state, plane, plane_state, i) {\n\t\tstruct intel_plane_state *linked_state = NULL;\n\n\t\tif (plane->pipe != crtc->pipe ||\n\t\t    !(crtc_state->nv12_planes & BIT(plane->id)))\n\t\t\tcontinue;\n\n\t\tfor_each_intel_plane_on_crtc(&dev_priv->drm, crtc, linked) {\n\t\t\tif (!icl_is_nv12_y_plane(dev_priv, linked->id))\n\t\t\t\tcontinue;\n\n\t\t\tif (crtc_state->active_planes & BIT(linked->id))\n\t\t\t\tcontinue;\n\n\t\t\tlinked_state = intel_atomic_get_plane_state(state, linked);\n\t\t\tif (IS_ERR(linked_state))\n\t\t\t\treturn PTR_ERR(linked_state);\n\n\t\t\tbreak;\n\t\t}\n\n\t\tif (!linked_state) {\n\t\t\tdrm_dbg_kms(&dev_priv->drm,\n\t\t\t\t    \"Need %d free Y planes for planar YUV\\n\",\n\t\t\t\t    hweight8(crtc_state->nv12_planes));\n\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tplane_state->planar_linked_plane = linked;\n\n\t\tlinked_state->planar_slave = true;\n\t\tlinked_state->planar_linked_plane = plane;\n\t\tcrtc_state->enabled_planes |= BIT(linked->id);\n\t\tcrtc_state->active_planes |= BIT(linked->id);\n\t\tcrtc_state->update_planes |= BIT(linked->id);\n\t\tcrtc_state->data_rate[linked->id] =\n\t\t\tcrtc_state->data_rate_y[plane->id];\n\t\tcrtc_state->rel_data_rate[linked->id] =\n\t\t\tcrtc_state->rel_data_rate_y[plane->id];\n\t\tdrm_dbg_kms(&dev_priv->drm, \"Using %s as Y plane for %s\\n\",\n\t\t\t    linked->base.name, plane->base.name);\n\n\t\t \n\t\tlinked_state->ctl = plane_state->ctl | PLANE_CTL_YUV420_Y_PLANE;\n\t\tlinked_state->color_ctl = plane_state->color_ctl;\n\t\tlinked_state->view = plane_state->view;\n\t\tlinked_state->decrypt = plane_state->decrypt;\n\n\t\tintel_plane_copy_hw_state(linked_state, plane_state);\n\t\tlinked_state->uapi.src = plane_state->uapi.src;\n\t\tlinked_state->uapi.dst = plane_state->uapi.dst;\n\n\t\tif (icl_is_hdr_plane(dev_priv, plane->id)) {\n\t\t\tif (linked->id == PLANE_SPRITE5)\n\t\t\t\tplane_state->cus_ctl |= PLANE_CUS_Y_PLANE_7_ICL;\n\t\t\telse if (linked->id == PLANE_SPRITE4)\n\t\t\t\tplane_state->cus_ctl |= PLANE_CUS_Y_PLANE_6_ICL;\n\t\t\telse if (linked->id == PLANE_SPRITE3)\n\t\t\t\tplane_state->cus_ctl |= PLANE_CUS_Y_PLANE_5_RKL;\n\t\t\telse if (linked->id == PLANE_SPRITE2)\n\t\t\t\tplane_state->cus_ctl |= PLANE_CUS_Y_PLANE_4_RKL;\n\t\t\telse\n\t\t\t\tMISSING_CASE(linked->id);\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic bool c8_planes_changed(const struct intel_crtc_state *new_crtc_state)\n{\n\tstruct intel_crtc *crtc = to_intel_crtc(new_crtc_state->uapi.crtc);\n\tstruct intel_atomic_state *state =\n\t\tto_intel_atomic_state(new_crtc_state->uapi.state);\n\tconst struct intel_crtc_state *old_crtc_state =\n\t\tintel_atomic_get_old_crtc_state(state, crtc);\n\n\treturn !old_crtc_state->c8_planes != !new_crtc_state->c8_planes;\n}\n\nstatic u16 hsw_linetime_wm(const struct intel_crtc_state *crtc_state)\n{\n\tconst struct drm_display_mode *pipe_mode =\n\t\t&crtc_state->hw.pipe_mode;\n\tint linetime_wm;\n\n\tif (!crtc_state->hw.enable)\n\t\treturn 0;\n\n\tlinetime_wm = DIV_ROUND_CLOSEST(pipe_mode->crtc_htotal * 1000 * 8,\n\t\t\t\t\tpipe_mode->crtc_clock);\n\n\treturn min(linetime_wm, 0x1ff);\n}\n\nstatic u16 hsw_ips_linetime_wm(const struct intel_crtc_state *crtc_state,\n\t\t\t       const struct intel_cdclk_state *cdclk_state)\n{\n\tconst struct drm_display_mode *pipe_mode =\n\t\t&crtc_state->hw.pipe_mode;\n\tint linetime_wm;\n\n\tif (!crtc_state->hw.enable)\n\t\treturn 0;\n\n\tlinetime_wm = DIV_ROUND_CLOSEST(pipe_mode->crtc_htotal * 1000 * 8,\n\t\t\t\t\tcdclk_state->logical.cdclk);\n\n\treturn min(linetime_wm, 0x1ff);\n}\n\nstatic u16 skl_linetime_wm(const struct intel_crtc_state *crtc_state)\n{\n\tstruct intel_crtc *crtc = to_intel_crtc(crtc_state->uapi.crtc);\n\tstruct drm_i915_private *dev_priv = to_i915(crtc->base.dev);\n\tconst struct drm_display_mode *pipe_mode =\n\t\t&crtc_state->hw.pipe_mode;\n\tint linetime_wm;\n\n\tif (!crtc_state->hw.enable)\n\t\treturn 0;\n\n\tlinetime_wm = DIV_ROUND_UP(pipe_mode->crtc_htotal * 1000 * 8,\n\t\t\t\t   crtc_state->pixel_rate);\n\n\t \n\tif ((IS_GEMINILAKE(dev_priv) || IS_BROXTON(dev_priv)) &&\n\t    skl_watermark_ipc_enabled(dev_priv))\n\t\tlinetime_wm /= 2;\n\n\treturn min(linetime_wm, 0x1ff);\n}\n\nstatic int hsw_compute_linetime_wm(struct intel_atomic_state *state,\n\t\t\t\t   struct intel_crtc *crtc)\n{\n\tstruct drm_i915_private *dev_priv = to_i915(crtc->base.dev);\n\tstruct intel_crtc_state *crtc_state =\n\t\tintel_atomic_get_new_crtc_state(state, crtc);\n\tconst struct intel_cdclk_state *cdclk_state;\n\n\tif (DISPLAY_VER(dev_priv) >= 9)\n\t\tcrtc_state->linetime = skl_linetime_wm(crtc_state);\n\telse\n\t\tcrtc_state->linetime = hsw_linetime_wm(crtc_state);\n\n\tif (!hsw_crtc_supports_ips(crtc))\n\t\treturn 0;\n\n\tcdclk_state = intel_atomic_get_cdclk_state(state);\n\tif (IS_ERR(cdclk_state))\n\t\treturn PTR_ERR(cdclk_state);\n\n\tcrtc_state->ips_linetime = hsw_ips_linetime_wm(crtc_state,\n\t\t\t\t\t\t       cdclk_state);\n\n\treturn 0;\n}\n\nstatic int intel_crtc_atomic_check(struct intel_atomic_state *state,\n\t\t\t\t   struct intel_crtc *crtc)\n{\n\tstruct drm_i915_private *dev_priv = to_i915(crtc->base.dev);\n\tstruct intel_crtc_state *crtc_state =\n\t\tintel_atomic_get_new_crtc_state(state, crtc);\n\tint ret;\n\n\tif (DISPLAY_VER(dev_priv) < 5 && !IS_G4X(dev_priv) &&\n\t    intel_crtc_needs_modeset(crtc_state) &&\n\t    !crtc_state->hw.active)\n\t\tcrtc_state->update_wm_post = true;\n\n\tif (intel_crtc_needs_modeset(crtc_state)) {\n\t\tret = intel_dpll_crtc_get_shared_dpll(state, crtc);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\t \n\tif (c8_planes_changed(crtc_state))\n\t\tcrtc_state->uapi.color_mgmt_changed = true;\n\n\tif (intel_crtc_needs_color_update(crtc_state)) {\n\t\tret = intel_color_check(crtc_state);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tret = intel_compute_pipe_wm(state, crtc);\n\tif (ret) {\n\t\tdrm_dbg_kms(&dev_priv->drm,\n\t\t\t    \"Target pipe watermarks are invalid\\n\");\n\t\treturn ret;\n\t}\n\n\t \n\tret = intel_compute_intermediate_wm(state, crtc);\n\tif (ret) {\n\t\tdrm_dbg_kms(&dev_priv->drm,\n\t\t\t    \"No valid intermediate pipe watermarks are possible\\n\");\n\t\treturn ret;\n\t}\n\n\tif (DISPLAY_VER(dev_priv) >= 9) {\n\t\tif (intel_crtc_needs_modeset(crtc_state) ||\n\t\t    intel_crtc_needs_fastset(crtc_state)) {\n\t\t\tret = skl_update_scaler_crtc(crtc_state);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t}\n\n\t\tret = intel_atomic_setup_scalers(dev_priv, crtc, crtc_state);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tif (HAS_IPS(dev_priv)) {\n\t\tret = hsw_ips_compute_config(state, crtc);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tif (DISPLAY_VER(dev_priv) >= 9 ||\n\t    IS_BROADWELL(dev_priv) || IS_HASWELL(dev_priv)) {\n\t\tret = hsw_compute_linetime_wm(state, crtc);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t}\n\n\tret = intel_psr2_sel_fetch_update(state, crtc);\n\tif (ret)\n\t\treturn ret;\n\n\treturn 0;\n}\n\nstatic int\ncompute_sink_pipe_bpp(const struct drm_connector_state *conn_state,\n\t\t      struct intel_crtc_state *crtc_state)\n{\n\tstruct drm_connector *connector = conn_state->connector;\n\tstruct drm_i915_private *i915 = to_i915(crtc_state->uapi.crtc->dev);\n\tconst struct drm_display_info *info = &connector->display_info;\n\tint bpp;\n\n\tswitch (conn_state->max_bpc) {\n\tcase 6 ... 7:\n\t\tbpp = 6 * 3;\n\t\tbreak;\n\tcase 8 ... 9:\n\t\tbpp = 8 * 3;\n\t\tbreak;\n\tcase 10 ... 11:\n\t\tbpp = 10 * 3;\n\t\tbreak;\n\tcase 12 ... 16:\n\t\tbpp = 12 * 3;\n\t\tbreak;\n\tdefault:\n\t\tMISSING_CASE(conn_state->max_bpc);\n\t\treturn -EINVAL;\n\t}\n\n\tif (bpp < crtc_state->pipe_bpp) {\n\t\tdrm_dbg_kms(&i915->drm,\n\t\t\t    \"[CONNECTOR:%d:%s] Limiting display bpp to %d \"\n\t\t\t    \"(EDID bpp %d, max requested bpp %d, max platform bpp %d)\\n\",\n\t\t\t    connector->base.id, connector->name,\n\t\t\t    bpp, 3 * info->bpc,\n\t\t\t    3 * conn_state->max_requested_bpc,\n\t\t\t    crtc_state->pipe_bpp);\n\n\t\tcrtc_state->pipe_bpp = bpp;\n\t}\n\n\treturn 0;\n}\n\nstatic int\ncompute_baseline_pipe_bpp(struct intel_atomic_state *state,\n\t\t\t  struct intel_crtc *crtc)\n{\n\tstruct drm_i915_private *dev_priv = to_i915(crtc->base.dev);\n\tstruct intel_crtc_state *crtc_state =\n\t\tintel_atomic_get_new_crtc_state(state, crtc);\n\tstruct drm_connector *connector;\n\tstruct drm_connector_state *connector_state;\n\tint bpp, i;\n\n\tif ((IS_G4X(dev_priv) || IS_VALLEYVIEW(dev_priv) ||\n\t    IS_CHERRYVIEW(dev_priv)))\n\t\tbpp = 10*3;\n\telse if (DISPLAY_VER(dev_priv) >= 5)\n\t\tbpp = 12*3;\n\telse\n\t\tbpp = 8*3;\n\n\tcrtc_state->pipe_bpp = bpp;\n\n\t \n\tfor_each_new_connector_in_state(&state->base, connector, connector_state, i) {\n\t\tint ret;\n\n\t\tif (connector_state->crtc != &crtc->base)\n\t\t\tcontinue;\n\n\t\tret = compute_sink_pipe_bpp(connector_state, crtc_state);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic bool check_digital_port_conflicts(struct intel_atomic_state *state)\n{\n\tstruct drm_device *dev = state->base.dev;\n\tstruct drm_connector *connector;\n\tstruct drm_connector_list_iter conn_iter;\n\tunsigned int used_ports = 0;\n\tunsigned int used_mst_ports = 0;\n\tbool ret = true;\n\n\t \n\tdrm_modeset_lock_assert_held(&dev->mode_config.connection_mutex);\n\n\t \n\tdrm_connector_list_iter_begin(dev, &conn_iter);\n\tdrm_for_each_connector_iter(connector, &conn_iter) {\n\t\tstruct drm_connector_state *connector_state;\n\t\tstruct intel_encoder *encoder;\n\n\t\tconnector_state =\n\t\t\tdrm_atomic_get_new_connector_state(&state->base,\n\t\t\t\t\t\t\t   connector);\n\t\tif (!connector_state)\n\t\t\tconnector_state = connector->state;\n\n\t\tif (!connector_state->best_encoder)\n\t\t\tcontinue;\n\n\t\tencoder = to_intel_encoder(connector_state->best_encoder);\n\n\t\tdrm_WARN_ON(dev, !connector_state->crtc);\n\n\t\tswitch (encoder->type) {\n\t\tcase INTEL_OUTPUT_DDI:\n\t\t\tif (drm_WARN_ON(dev, !HAS_DDI(to_i915(dev))))\n\t\t\t\tbreak;\n\t\t\tfallthrough;\n\t\tcase INTEL_OUTPUT_DP:\n\t\tcase INTEL_OUTPUT_HDMI:\n\t\tcase INTEL_OUTPUT_EDP:\n\t\t\t \n\t\t\tif (used_ports & BIT(encoder->port))\n\t\t\t\tret = false;\n\n\t\t\tused_ports |= BIT(encoder->port);\n\t\t\tbreak;\n\t\tcase INTEL_OUTPUT_DP_MST:\n\t\t\tused_mst_ports |=\n\t\t\t\t1 << encoder->port;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\tdrm_connector_list_iter_end(&conn_iter);\n\n\t \n\tif (used_ports & used_mst_ports)\n\t\treturn false;\n\n\treturn ret;\n}\n\nstatic void\nintel_crtc_copy_uapi_to_hw_state_nomodeset(struct intel_atomic_state *state,\n\t\t\t\t\t   struct intel_crtc *crtc)\n{\n\tstruct intel_crtc_state *crtc_state =\n\t\tintel_atomic_get_new_crtc_state(state, crtc);\n\n\tWARN_ON(intel_crtc_is_bigjoiner_slave(crtc_state));\n\n\tdrm_property_replace_blob(&crtc_state->hw.degamma_lut,\n\t\t\t\t  crtc_state->uapi.degamma_lut);\n\tdrm_property_replace_blob(&crtc_state->hw.gamma_lut,\n\t\t\t\t  crtc_state->uapi.gamma_lut);\n\tdrm_property_replace_blob(&crtc_state->hw.ctm,\n\t\t\t\t  crtc_state->uapi.ctm);\n}\n\nstatic void\nintel_crtc_copy_uapi_to_hw_state_modeset(struct intel_atomic_state *state,\n\t\t\t\t\t struct intel_crtc *crtc)\n{\n\tstruct intel_crtc_state *crtc_state =\n\t\tintel_atomic_get_new_crtc_state(state, crtc);\n\n\tWARN_ON(intel_crtc_is_bigjoiner_slave(crtc_state));\n\n\tcrtc_state->hw.enable = crtc_state->uapi.enable;\n\tcrtc_state->hw.active = crtc_state->uapi.active;\n\tdrm_mode_copy(&crtc_state->hw.mode,\n\t\t      &crtc_state->uapi.mode);\n\tdrm_mode_copy(&crtc_state->hw.adjusted_mode,\n\t\t      &crtc_state->uapi.adjusted_mode);\n\tcrtc_state->hw.scaling_filter = crtc_state->uapi.scaling_filter;\n\n\tintel_crtc_copy_uapi_to_hw_state_nomodeset(state, crtc);\n}\n\nstatic void\ncopy_bigjoiner_crtc_state_nomodeset(struct intel_atomic_state *state,\n\t\t\t\t    struct intel_crtc *slave_crtc)\n{\n\tstruct intel_crtc_state *slave_crtc_state =\n\t\tintel_atomic_get_new_crtc_state(state, slave_crtc);\n\tstruct intel_crtc *master_crtc = intel_master_crtc(slave_crtc_state);\n\tconst struct intel_crtc_state *master_crtc_state =\n\t\tintel_atomic_get_new_crtc_state(state, master_crtc);\n\n\tdrm_property_replace_blob(&slave_crtc_state->hw.degamma_lut,\n\t\t\t\t  master_crtc_state->hw.degamma_lut);\n\tdrm_property_replace_blob(&slave_crtc_state->hw.gamma_lut,\n\t\t\t\t  master_crtc_state->hw.gamma_lut);\n\tdrm_property_replace_blob(&slave_crtc_state->hw.ctm,\n\t\t\t\t  master_crtc_state->hw.ctm);\n\n\tslave_crtc_state->uapi.color_mgmt_changed = master_crtc_state->uapi.color_mgmt_changed;\n}\n\nstatic int\ncopy_bigjoiner_crtc_state_modeset(struct intel_atomic_state *state,\n\t\t\t\t  struct intel_crtc *slave_crtc)\n{\n\tstruct intel_crtc_state *slave_crtc_state =\n\t\tintel_atomic_get_new_crtc_state(state, slave_crtc);\n\tstruct intel_crtc *master_crtc = intel_master_crtc(slave_crtc_state);\n\tconst struct intel_crtc_state *master_crtc_state =\n\t\tintel_atomic_get_new_crtc_state(state, master_crtc);\n\tstruct intel_crtc_state *saved_state;\n\n\tWARN_ON(master_crtc_state->bigjoiner_pipes !=\n\t\tslave_crtc_state->bigjoiner_pipes);\n\n\tsaved_state = kmemdup(master_crtc_state, sizeof(*saved_state), GFP_KERNEL);\n\tif (!saved_state)\n\t\treturn -ENOMEM;\n\n\t \n\tsaved_state->uapi = slave_crtc_state->uapi;\n\tsaved_state->scaler_state = slave_crtc_state->scaler_state;\n\tsaved_state->shared_dpll = slave_crtc_state->shared_dpll;\n\tsaved_state->crc_enabled = slave_crtc_state->crc_enabled;\n\n\tintel_crtc_free_hw_state(slave_crtc_state);\n\tmemcpy(slave_crtc_state, saved_state, sizeof(*slave_crtc_state));\n\tkfree(saved_state);\n\n\t \n\tmemset(&slave_crtc_state->hw, 0, sizeof(slave_crtc_state->hw));\n\tslave_crtc_state->hw.enable = master_crtc_state->hw.enable;\n\tslave_crtc_state->hw.active = master_crtc_state->hw.active;\n\tdrm_mode_copy(&slave_crtc_state->hw.mode,\n\t\t      &master_crtc_state->hw.mode);\n\tdrm_mode_copy(&slave_crtc_state->hw.pipe_mode,\n\t\t      &master_crtc_state->hw.pipe_mode);\n\tdrm_mode_copy(&slave_crtc_state->hw.adjusted_mode,\n\t\t      &master_crtc_state->hw.adjusted_mode);\n\tslave_crtc_state->hw.scaling_filter = master_crtc_state->hw.scaling_filter;\n\n\tcopy_bigjoiner_crtc_state_nomodeset(state, slave_crtc);\n\n\tslave_crtc_state->uapi.mode_changed = master_crtc_state->uapi.mode_changed;\n\tslave_crtc_state->uapi.connectors_changed = master_crtc_state->uapi.connectors_changed;\n\tslave_crtc_state->uapi.active_changed = master_crtc_state->uapi.active_changed;\n\n\tWARN_ON(master_crtc_state->bigjoiner_pipes !=\n\t\tslave_crtc_state->bigjoiner_pipes);\n\n\treturn 0;\n}\n\nstatic int\nintel_crtc_prepare_cleared_state(struct intel_atomic_state *state,\n\t\t\t\t struct intel_crtc *crtc)\n{\n\tstruct intel_crtc_state *crtc_state =\n\t\tintel_atomic_get_new_crtc_state(state, crtc);\n\tstruct drm_i915_private *dev_priv = to_i915(crtc->base.dev);\n\tstruct intel_crtc_state *saved_state;\n\n\tsaved_state = intel_crtc_state_alloc(crtc);\n\tif (!saved_state)\n\t\treturn -ENOMEM;\n\n\t \n\tintel_crtc_free_hw_state(crtc_state);\n\n\t \n\n\tsaved_state->uapi = crtc_state->uapi;\n\tsaved_state->inherited = crtc_state->inherited;\n\tsaved_state->scaler_state = crtc_state->scaler_state;\n\tsaved_state->shared_dpll = crtc_state->shared_dpll;\n\tsaved_state->dpll_hw_state = crtc_state->dpll_hw_state;\n\tmemcpy(saved_state->icl_port_dplls, crtc_state->icl_port_dplls,\n\t       sizeof(saved_state->icl_port_dplls));\n\tsaved_state->crc_enabled = crtc_state->crc_enabled;\n\tif (IS_G4X(dev_priv) ||\n\t    IS_VALLEYVIEW(dev_priv) || IS_CHERRYVIEW(dev_priv))\n\t\tsaved_state->wm = crtc_state->wm;\n\n\tmemcpy(crtc_state, saved_state, sizeof(*crtc_state));\n\tkfree(saved_state);\n\n\tintel_crtc_copy_uapi_to_hw_state_modeset(state, crtc);\n\n\treturn 0;\n}\n\nstatic int\nintel_modeset_pipe_config(struct intel_atomic_state *state,\n\t\t\t  struct intel_crtc *crtc)\n{\n\tstruct drm_i915_private *i915 = to_i915(crtc->base.dev);\n\tstruct intel_crtc_state *crtc_state =\n\t\tintel_atomic_get_new_crtc_state(state, crtc);\n\tstruct drm_connector *connector;\n\tstruct drm_connector_state *connector_state;\n\tint pipe_src_w, pipe_src_h;\n\tint base_bpp, ret, i;\n\tbool retry = true;\n\n\tcrtc_state->cpu_transcoder = (enum transcoder) crtc->pipe;\n\n\tcrtc_state->framestart_delay = 1;\n\n\t \n\tif (!(crtc_state->hw.adjusted_mode.flags &\n\t      (DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_NHSYNC)))\n\t\tcrtc_state->hw.adjusted_mode.flags |= DRM_MODE_FLAG_NHSYNC;\n\n\tif (!(crtc_state->hw.adjusted_mode.flags &\n\t      (DRM_MODE_FLAG_PVSYNC | DRM_MODE_FLAG_NVSYNC)))\n\t\tcrtc_state->hw.adjusted_mode.flags |= DRM_MODE_FLAG_NVSYNC;\n\n\tret = compute_baseline_pipe_bpp(state, crtc);\n\tif (ret)\n\t\treturn ret;\n\n\tbase_bpp = crtc_state->pipe_bpp;\n\n\t \n\tdrm_mode_get_hv_timing(&crtc_state->hw.mode,\n\t\t\t       &pipe_src_w, &pipe_src_h);\n\tdrm_rect_init(&crtc_state->pipe_src, 0, 0,\n\t\t      pipe_src_w, pipe_src_h);\n\n\tfor_each_new_connector_in_state(&state->base, connector, connector_state, i) {\n\t\tstruct intel_encoder *encoder =\n\t\t\tto_intel_encoder(connector_state->best_encoder);\n\n\t\tif (connector_state->crtc != &crtc->base)\n\t\t\tcontinue;\n\n\t\tif (!check_single_encoder_cloning(state, crtc, encoder)) {\n\t\t\tdrm_dbg_kms(&i915->drm,\n\t\t\t\t    \"[ENCODER:%d:%s] rejecting invalid cloning configuration\\n\",\n\t\t\t\t    encoder->base.base.id, encoder->base.name);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\t \n\t\tif (encoder->compute_output_type)\n\t\t\tcrtc_state->output_types |=\n\t\t\t\tBIT(encoder->compute_output_type(encoder, crtc_state,\n\t\t\t\t\t\t\t\t connector_state));\n\t\telse\n\t\t\tcrtc_state->output_types |= BIT(encoder->type);\n\t}\n\nencoder_retry:\n\t \n\tcrtc_state->port_clock = 0;\n\tcrtc_state->pixel_multiplier = 1;\n\n\t \n\tdrm_mode_set_crtcinfo(&crtc_state->hw.adjusted_mode,\n\t\t\t      CRTC_STEREO_DOUBLE);\n\n\t \n\tfor_each_new_connector_in_state(&state->base, connector, connector_state, i) {\n\t\tstruct intel_encoder *encoder =\n\t\t\tto_intel_encoder(connector_state->best_encoder);\n\n\t\tif (connector_state->crtc != &crtc->base)\n\t\t\tcontinue;\n\n\t\tret = encoder->compute_config(encoder, crtc_state,\n\t\t\t\t\t      connector_state);\n\t\tif (ret == -EDEADLK)\n\t\t\treturn ret;\n\t\tif (ret < 0) {\n\t\t\tdrm_dbg_kms(&i915->drm, \"[ENCODER:%d:%s] config failure: %d\\n\",\n\t\t\t\t    encoder->base.base.id, encoder->base.name, ret);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\t \n\tif (!crtc_state->port_clock)\n\t\tcrtc_state->port_clock = crtc_state->hw.adjusted_mode.crtc_clock\n\t\t\t* crtc_state->pixel_multiplier;\n\n\tret = intel_crtc_compute_config(state, crtc);\n\tif (ret == -EDEADLK)\n\t\treturn ret;\n\tif (ret == -EAGAIN) {\n\t\tif (drm_WARN(&i915->drm, !retry,\n\t\t\t     \"[CRTC:%d:%s] loop in pipe configuration computation\\n\",\n\t\t\t     crtc->base.base.id, crtc->base.name))\n\t\t\treturn -EINVAL;\n\n\t\tdrm_dbg_kms(&i915->drm, \"[CRTC:%d:%s] bw constrained, retrying\\n\",\n\t\t\t    crtc->base.base.id, crtc->base.name);\n\t\tretry = false;\n\t\tgoto encoder_retry;\n\t}\n\tif (ret < 0) {\n\t\tdrm_dbg_kms(&i915->drm, \"[CRTC:%d:%s] config failure: %d\\n\",\n\t\t\t    crtc->base.base.id, crtc->base.name, ret);\n\t\treturn ret;\n\t}\n\n\t \n\tcrtc_state->dither = (crtc_state->pipe_bpp == 6*3) &&\n\t\t!crtc_state->dither_force_disable;\n\tdrm_dbg_kms(&i915->drm,\n\t\t    \"[CRTC:%d:%s] hw max bpp: %i, pipe bpp: %i, dithering: %i\\n\",\n\t\t    crtc->base.base.id, crtc->base.name,\n\t\t    base_bpp, crtc_state->pipe_bpp, crtc_state->dither);\n\n\treturn 0;\n}\n\nstatic int\nintel_modeset_pipe_config_late(struct intel_atomic_state *state,\n\t\t\t       struct intel_crtc *crtc)\n{\n\tstruct intel_crtc_state *crtc_state =\n\t\tintel_atomic_get_new_crtc_state(state, crtc);\n\tstruct drm_connector_state *conn_state;\n\tstruct drm_connector *connector;\n\tint i;\n\n\tintel_bigjoiner_adjust_pipe_src(crtc_state);\n\n\tfor_each_new_connector_in_state(&state->base, connector,\n\t\t\t\t\tconn_state, i) {\n\t\tstruct intel_encoder *encoder =\n\t\t\tto_intel_encoder(conn_state->best_encoder);\n\t\tint ret;\n\n\t\tif (conn_state->crtc != &crtc->base ||\n\t\t    !encoder->compute_config_late)\n\t\t\tcontinue;\n\n\t\tret = encoder->compute_config_late(encoder, crtc_state,\n\t\t\t\t\t\t   conn_state);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nbool intel_fuzzy_clock_check(int clock1, int clock2)\n{\n\tint diff;\n\n\tif (clock1 == clock2)\n\t\treturn true;\n\n\tif (!clock1 || !clock2)\n\t\treturn false;\n\n\tdiff = abs(clock1 - clock2);\n\n\tif (((((diff + clock1 + clock2) * 100)) / (clock1 + clock2)) < 105)\n\t\treturn true;\n\n\treturn false;\n}\n\nstatic bool\nintel_compare_link_m_n(const struct intel_link_m_n *m_n,\n\t\t       const struct intel_link_m_n *m2_n2)\n{\n\treturn m_n->tu == m2_n2->tu &&\n\t\tm_n->data_m == m2_n2->data_m &&\n\t\tm_n->data_n == m2_n2->data_n &&\n\t\tm_n->link_m == m2_n2->link_m &&\n\t\tm_n->link_n == m2_n2->link_n;\n}\n\nstatic bool\nintel_compare_infoframe(const union hdmi_infoframe *a,\n\t\t\tconst union hdmi_infoframe *b)\n{\n\treturn memcmp(a, b, sizeof(*a)) == 0;\n}\n\nstatic bool\nintel_compare_dp_vsc_sdp(const struct drm_dp_vsc_sdp *a,\n\t\t\t const struct drm_dp_vsc_sdp *b)\n{\n\treturn memcmp(a, b, sizeof(*a)) == 0;\n}\n\nstatic bool\nintel_compare_buffer(const u8 *a, const u8 *b, size_t len)\n{\n\treturn memcmp(a, b, len) == 0;\n}\n\nstatic void\npipe_config_infoframe_mismatch(struct drm_i915_private *dev_priv,\n\t\t\t       bool fastset, const char *name,\n\t\t\t       const union hdmi_infoframe *a,\n\t\t\t       const union hdmi_infoframe *b)\n{\n\tif (fastset) {\n\t\tif (!drm_debug_enabled(DRM_UT_KMS))\n\t\t\treturn;\n\n\t\tdrm_dbg_kms(&dev_priv->drm,\n\t\t\t    \"fastset requirement not met in %s infoframe\\n\", name);\n\t\tdrm_dbg_kms(&dev_priv->drm, \"expected:\\n\");\n\t\thdmi_infoframe_log(KERN_DEBUG, dev_priv->drm.dev, a);\n\t\tdrm_dbg_kms(&dev_priv->drm, \"found:\\n\");\n\t\thdmi_infoframe_log(KERN_DEBUG, dev_priv->drm.dev, b);\n\t} else {\n\t\tdrm_err(&dev_priv->drm, \"mismatch in %s infoframe\\n\", name);\n\t\tdrm_err(&dev_priv->drm, \"expected:\\n\");\n\t\thdmi_infoframe_log(KERN_ERR, dev_priv->drm.dev, a);\n\t\tdrm_err(&dev_priv->drm, \"found:\\n\");\n\t\thdmi_infoframe_log(KERN_ERR, dev_priv->drm.dev, b);\n\t}\n}\n\nstatic void\npipe_config_dp_vsc_sdp_mismatch(struct drm_i915_private *dev_priv,\n\t\t\t\tbool fastset, const char *name,\n\t\t\t\tconst struct drm_dp_vsc_sdp *a,\n\t\t\t\tconst struct drm_dp_vsc_sdp *b)\n{\n\tif (fastset) {\n\t\tif (!drm_debug_enabled(DRM_UT_KMS))\n\t\t\treturn;\n\n\t\tdrm_dbg_kms(&dev_priv->drm,\n\t\t\t    \"fastset requirement not met in %s dp sdp\\n\", name);\n\t\tdrm_dbg_kms(&dev_priv->drm, \"expected:\\n\");\n\t\tdrm_dp_vsc_sdp_log(KERN_DEBUG, dev_priv->drm.dev, a);\n\t\tdrm_dbg_kms(&dev_priv->drm, \"found:\\n\");\n\t\tdrm_dp_vsc_sdp_log(KERN_DEBUG, dev_priv->drm.dev, b);\n\t} else {\n\t\tdrm_err(&dev_priv->drm, \"mismatch in %s dp sdp\\n\", name);\n\t\tdrm_err(&dev_priv->drm, \"expected:\\n\");\n\t\tdrm_dp_vsc_sdp_log(KERN_ERR, dev_priv->drm.dev, a);\n\t\tdrm_err(&dev_priv->drm, \"found:\\n\");\n\t\tdrm_dp_vsc_sdp_log(KERN_ERR, dev_priv->drm.dev, b);\n\t}\n}\n\n \nstatic size_t\nmemcmp_diff_len(const u8 *a, const u8 *b, size_t len)\n{\n\tint i;\n\n\tfor (i = len - 1; i >= 0; i--) {\n\t\tif (a[i] != b[i])\n\t\t\treturn i + 1;\n\t}\n\n\treturn 0;\n}\n\nstatic void\npipe_config_buffer_mismatch(struct drm_i915_private *dev_priv,\n\t\t\t    bool fastset, const char *name,\n\t\t\t    const u8 *a, const u8 *b, size_t len)\n{\n\tif (fastset) {\n\t\tif (!drm_debug_enabled(DRM_UT_KMS))\n\t\t\treturn;\n\n\t\t \n\t\tlen = memcmp_diff_len(a, b, len);\n\n\t\tdrm_dbg_kms(&dev_priv->drm,\n\t\t\t    \"fastset requirement not met in %s buffer\\n\", name);\n\t\tprint_hex_dump(KERN_DEBUG, \"expected: \", DUMP_PREFIX_NONE,\n\t\t\t       16, 0, a, len, false);\n\t\tprint_hex_dump(KERN_DEBUG, \"found: \", DUMP_PREFIX_NONE,\n\t\t\t       16, 0, b, len, false);\n\t} else {\n\t\t \n\t\tlen = memcmp_diff_len(a, b, len);\n\n\t\tdrm_err(&dev_priv->drm, \"mismatch in %s buffer\\n\", name);\n\t\tprint_hex_dump(KERN_ERR, \"expected: \", DUMP_PREFIX_NONE,\n\t\t\t       16, 0, a, len, false);\n\t\tprint_hex_dump(KERN_ERR, \"found: \", DUMP_PREFIX_NONE,\n\t\t\t       16, 0, b, len, false);\n\t}\n}\n\nstatic void __printf(4, 5)\npipe_config_mismatch(bool fastset, const struct intel_crtc *crtc,\n\t\t     const char *name, const char *format, ...)\n{\n\tstruct drm_i915_private *i915 = to_i915(crtc->base.dev);\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, format);\n\tvaf.fmt = format;\n\tvaf.va = &args;\n\n\tif (fastset)\n\t\tdrm_dbg_kms(&i915->drm,\n\t\t\t    \"[CRTC:%d:%s] fastset requirement not met in %s %pV\\n\",\n\t\t\t    crtc->base.base.id, crtc->base.name, name, &vaf);\n\telse\n\t\tdrm_err(&i915->drm, \"[CRTC:%d:%s] mismatch in %s %pV\\n\",\n\t\t\tcrtc->base.base.id, crtc->base.name, name, &vaf);\n\n\tva_end(args);\n}\n\nstatic bool fastboot_enabled(struct drm_i915_private *dev_priv)\n{\n\tif (dev_priv->params.fastboot != -1)\n\t\treturn dev_priv->params.fastboot;\n\n\t \n\tif (DISPLAY_VER(dev_priv) >= 9)\n\t\treturn true;\n\n\t \n\tif (IS_VALLEYVIEW(dev_priv) || IS_CHERRYVIEW(dev_priv))\n\t\treturn true;\n\n\t \n\treturn false;\n}\n\nbool\nintel_pipe_config_compare(const struct intel_crtc_state *current_config,\n\t\t\t  const struct intel_crtc_state *pipe_config,\n\t\t\t  bool fastset)\n{\n\tstruct drm_i915_private *dev_priv = to_i915(current_config->uapi.crtc->dev);\n\tstruct intel_crtc *crtc = to_intel_crtc(pipe_config->uapi.crtc);\n\tbool ret = true;\n\tbool fixup_inherited = fastset &&\n\t\tcurrent_config->inherited && !pipe_config->inherited;\n\n\tif (fixup_inherited && !fastboot_enabled(dev_priv)) {\n\t\tdrm_dbg_kms(&dev_priv->drm,\n\t\t\t    \"initial modeset and fastboot not set\\n\");\n\t\tret = false;\n\t}\n\n#define PIPE_CONF_CHECK_X(name) do { \\\n\tif (current_config->name != pipe_config->name) { \\\n\t\tpipe_config_mismatch(fastset, crtc, __stringify(name), \\\n\t\t\t\t     \"(expected 0x%08x, found 0x%08x)\", \\\n\t\t\t\t     current_config->name, \\\n\t\t\t\t     pipe_config->name); \\\n\t\tret = false; \\\n\t} \\\n} while (0)\n\n#define PIPE_CONF_CHECK_X_WITH_MASK(name, mask) do { \\\n\tif ((current_config->name & (mask)) != (pipe_config->name & (mask))) { \\\n\t\tpipe_config_mismatch(fastset, crtc, __stringify(name), \\\n\t\t\t\t     \"(expected 0x%08x, found 0x%08x)\", \\\n\t\t\t\t     current_config->name & (mask), \\\n\t\t\t\t     pipe_config->name & (mask)); \\\n\t\tret = false; \\\n\t} \\\n} while (0)\n\n#define PIPE_CONF_CHECK_I(name) do { \\\n\tif (current_config->name != pipe_config->name) { \\\n\t\tpipe_config_mismatch(fastset, crtc, __stringify(name), \\\n\t\t\t\t     \"(expected %i, found %i)\", \\\n\t\t\t\t     current_config->name, \\\n\t\t\t\t     pipe_config->name); \\\n\t\tret = false; \\\n\t} \\\n} while (0)\n\n#define PIPE_CONF_CHECK_BOOL(name) do { \\\n\tif (current_config->name != pipe_config->name) { \\\n\t\tpipe_config_mismatch(fastset, crtc,  __stringify(name), \\\n\t\t\t\t     \"(expected %s, found %s)\", \\\n\t\t\t\t     str_yes_no(current_config->name), \\\n\t\t\t\t     str_yes_no(pipe_config->name)); \\\n\t\tret = false; \\\n\t} \\\n} while (0)\n\n \n#define PIPE_CONF_CHECK_BOOL_INCOMPLETE(name) do { \\\n\tif (!fixup_inherited || (!current_config->name && !pipe_config->name)) { \\\n\t\tPIPE_CONF_CHECK_BOOL(name); \\\n\t} else { \\\n\t\tpipe_config_mismatch(fastset, crtc, __stringify(name), \\\n\t\t\t\t     \"unable to verify whether state matches exactly, forcing modeset (expected %s, found %s)\", \\\n\t\t\t\t     str_yes_no(current_config->name), \\\n\t\t\t\t     str_yes_no(pipe_config->name)); \\\n\t\tret = false; \\\n\t} \\\n} while (0)\n\n#define PIPE_CONF_CHECK_P(name) do { \\\n\tif (current_config->name != pipe_config->name) { \\\n\t\tpipe_config_mismatch(fastset, crtc, __stringify(name), \\\n\t\t\t\t     \"(expected %p, found %p)\", \\\n\t\t\t\t     current_config->name, \\\n\t\t\t\t     pipe_config->name); \\\n\t\tret = false; \\\n\t} \\\n} while (0)\n\n#define PIPE_CONF_CHECK_M_N(name) do { \\\n\tif (!intel_compare_link_m_n(&current_config->name, \\\n\t\t\t\t    &pipe_config->name)) { \\\n\t\tpipe_config_mismatch(fastset, crtc, __stringify(name), \\\n\t\t\t\t     \"(expected tu %i data %i/%i link %i/%i, \" \\\n\t\t\t\t     \"found tu %i, data %i/%i link %i/%i)\", \\\n\t\t\t\t     current_config->name.tu, \\\n\t\t\t\t     current_config->name.data_m, \\\n\t\t\t\t     current_config->name.data_n, \\\n\t\t\t\t     current_config->name.link_m, \\\n\t\t\t\t     current_config->name.link_n, \\\n\t\t\t\t     pipe_config->name.tu, \\\n\t\t\t\t     pipe_config->name.data_m, \\\n\t\t\t\t     pipe_config->name.data_n, \\\n\t\t\t\t     pipe_config->name.link_m, \\\n\t\t\t\t     pipe_config->name.link_n); \\\n\t\tret = false; \\\n\t} \\\n} while (0)\n\n#define PIPE_CONF_CHECK_TIMINGS(name) do { \\\n\tPIPE_CONF_CHECK_I(name.crtc_hdisplay); \\\n\tPIPE_CONF_CHECK_I(name.crtc_htotal); \\\n\tPIPE_CONF_CHECK_I(name.crtc_hblank_start); \\\n\tPIPE_CONF_CHECK_I(name.crtc_hblank_end); \\\n\tPIPE_CONF_CHECK_I(name.crtc_hsync_start); \\\n\tPIPE_CONF_CHECK_I(name.crtc_hsync_end); \\\n\tPIPE_CONF_CHECK_I(name.crtc_vdisplay); \\\n\tPIPE_CONF_CHECK_I(name.crtc_vtotal); \\\n\tPIPE_CONF_CHECK_I(name.crtc_vblank_start); \\\n\tPIPE_CONF_CHECK_I(name.crtc_vblank_end); \\\n\tPIPE_CONF_CHECK_I(name.crtc_vsync_start); \\\n\tPIPE_CONF_CHECK_I(name.crtc_vsync_end); \\\n} while (0)\n\n#define PIPE_CONF_CHECK_RECT(name) do { \\\n\tPIPE_CONF_CHECK_I(name.x1); \\\n\tPIPE_CONF_CHECK_I(name.x2); \\\n\tPIPE_CONF_CHECK_I(name.y1); \\\n\tPIPE_CONF_CHECK_I(name.y2); \\\n} while (0)\n\n#define PIPE_CONF_CHECK_FLAGS(name, mask) do { \\\n\tif ((current_config->name ^ pipe_config->name) & (mask)) { \\\n\t\tpipe_config_mismatch(fastset, crtc, __stringify(name), \\\n\t\t\t\t     \"(%x) (expected %i, found %i)\", \\\n\t\t\t\t     (mask), \\\n\t\t\t\t     current_config->name & (mask), \\\n\t\t\t\t     pipe_config->name & (mask)); \\\n\t\tret = false; \\\n\t} \\\n} while (0)\n\n#define PIPE_CONF_CHECK_INFOFRAME(name) do { \\\n\tif (!intel_compare_infoframe(&current_config->infoframes.name, \\\n\t\t\t\t     &pipe_config->infoframes.name)) { \\\n\t\tpipe_config_infoframe_mismatch(dev_priv, fastset, __stringify(name), \\\n\t\t\t\t\t       &current_config->infoframes.name, \\\n\t\t\t\t\t       &pipe_config->infoframes.name); \\\n\t\tret = false; \\\n\t} \\\n} while (0)\n\n#define PIPE_CONF_CHECK_DP_VSC_SDP(name) do { \\\n\tif (!current_config->has_psr && !pipe_config->has_psr && \\\n\t    !intel_compare_dp_vsc_sdp(&current_config->infoframes.name, \\\n\t\t\t\t      &pipe_config->infoframes.name)) { \\\n\t\tpipe_config_dp_vsc_sdp_mismatch(dev_priv, fastset, __stringify(name), \\\n\t\t\t\t\t\t&current_config->infoframes.name, \\\n\t\t\t\t\t\t&pipe_config->infoframes.name); \\\n\t\tret = false; \\\n\t} \\\n} while (0)\n\n#define PIPE_CONF_CHECK_BUFFER(name, len) do { \\\n\tBUILD_BUG_ON(sizeof(current_config->name) != (len)); \\\n\tBUILD_BUG_ON(sizeof(pipe_config->name) != (len)); \\\n\tif (!intel_compare_buffer(current_config->name, pipe_config->name, (len))) { \\\n\t\tpipe_config_buffer_mismatch(dev_priv, fastset, __stringify(name), \\\n\t\t\t\t\t    current_config->name, \\\n\t\t\t\t\t    pipe_config->name, \\\n\t\t\t\t\t    (len)); \\\n\t\tret = false; \\\n\t} \\\n} while (0)\n\n#define PIPE_CONF_CHECK_COLOR_LUT(lut, is_pre_csc_lut) do { \\\n\tif (current_config->gamma_mode == pipe_config->gamma_mode && \\\n\t    !intel_color_lut_equal(current_config, \\\n\t\t\t\t   current_config->lut, pipe_config->lut, \\\n\t\t\t\t   is_pre_csc_lut)) {\t\\\n\t\tpipe_config_mismatch(fastset, crtc, __stringify(lut), \\\n\t\t\t\t     \"hw_state doesn't match sw_state\"); \\\n\t\tret = false; \\\n\t} \\\n} while (0)\n\n#define PIPE_CONF_CHECK_CSC(name) do { \\\n\tPIPE_CONF_CHECK_X(name.preoff[0]); \\\n\tPIPE_CONF_CHECK_X(name.preoff[1]); \\\n\tPIPE_CONF_CHECK_X(name.preoff[2]); \\\n\tPIPE_CONF_CHECK_X(name.coeff[0]); \\\n\tPIPE_CONF_CHECK_X(name.coeff[1]); \\\n\tPIPE_CONF_CHECK_X(name.coeff[2]); \\\n\tPIPE_CONF_CHECK_X(name.coeff[3]); \\\n\tPIPE_CONF_CHECK_X(name.coeff[4]); \\\n\tPIPE_CONF_CHECK_X(name.coeff[5]); \\\n\tPIPE_CONF_CHECK_X(name.coeff[6]); \\\n\tPIPE_CONF_CHECK_X(name.coeff[7]); \\\n\tPIPE_CONF_CHECK_X(name.coeff[8]); \\\n\tPIPE_CONF_CHECK_X(name.postoff[0]); \\\n\tPIPE_CONF_CHECK_X(name.postoff[1]); \\\n\tPIPE_CONF_CHECK_X(name.postoff[2]); \\\n} while (0)\n\n#define PIPE_CONF_QUIRK(quirk) \\\n\t((current_config->quirks | pipe_config->quirks) & (quirk))\n\n\tPIPE_CONF_CHECK_I(hw.enable);\n\tPIPE_CONF_CHECK_I(hw.active);\n\n\tPIPE_CONF_CHECK_I(cpu_transcoder);\n\tPIPE_CONF_CHECK_I(mst_master_transcoder);\n\n\tPIPE_CONF_CHECK_BOOL(has_pch_encoder);\n\tPIPE_CONF_CHECK_I(fdi_lanes);\n\tPIPE_CONF_CHECK_M_N(fdi_m_n);\n\n\tPIPE_CONF_CHECK_I(lane_count);\n\tPIPE_CONF_CHECK_X(lane_lat_optim_mask);\n\n\tif (HAS_DOUBLE_BUFFERED_M_N(dev_priv)) {\n\t\tif (!fastset || !pipe_config->seamless_m_n)\n\t\t\tPIPE_CONF_CHECK_M_N(dp_m_n);\n\t} else {\n\t\tPIPE_CONF_CHECK_M_N(dp_m_n);\n\t\tPIPE_CONF_CHECK_M_N(dp_m2_n2);\n\t}\n\n\tPIPE_CONF_CHECK_X(output_types);\n\n\tPIPE_CONF_CHECK_I(framestart_delay);\n\tPIPE_CONF_CHECK_I(msa_timing_delay);\n\n\tPIPE_CONF_CHECK_TIMINGS(hw.pipe_mode);\n\tPIPE_CONF_CHECK_TIMINGS(hw.adjusted_mode);\n\n\tPIPE_CONF_CHECK_I(pixel_multiplier);\n\n\tPIPE_CONF_CHECK_FLAGS(hw.adjusted_mode.flags,\n\t\t\t      DRM_MODE_FLAG_INTERLACE);\n\n\tif (!PIPE_CONF_QUIRK(PIPE_CONFIG_QUIRK_MODE_SYNC_FLAGS)) {\n\t\tPIPE_CONF_CHECK_FLAGS(hw.adjusted_mode.flags,\n\t\t\t\t      DRM_MODE_FLAG_PHSYNC);\n\t\tPIPE_CONF_CHECK_FLAGS(hw.adjusted_mode.flags,\n\t\t\t\t      DRM_MODE_FLAG_NHSYNC);\n\t\tPIPE_CONF_CHECK_FLAGS(hw.adjusted_mode.flags,\n\t\t\t\t      DRM_MODE_FLAG_PVSYNC);\n\t\tPIPE_CONF_CHECK_FLAGS(hw.adjusted_mode.flags,\n\t\t\t\t      DRM_MODE_FLAG_NVSYNC);\n\t}\n\n\tPIPE_CONF_CHECK_I(output_format);\n\tPIPE_CONF_CHECK_BOOL(has_hdmi_sink);\n\tif ((DISPLAY_VER(dev_priv) < 8 && !IS_HASWELL(dev_priv)) ||\n\t    IS_VALLEYVIEW(dev_priv) || IS_CHERRYVIEW(dev_priv))\n\t\tPIPE_CONF_CHECK_BOOL(limited_color_range);\n\n\tPIPE_CONF_CHECK_BOOL(hdmi_scrambling);\n\tPIPE_CONF_CHECK_BOOL(hdmi_high_tmds_clock_ratio);\n\tPIPE_CONF_CHECK_BOOL(has_infoframe);\n\tPIPE_CONF_CHECK_BOOL(enhanced_framing);\n\tPIPE_CONF_CHECK_BOOL(fec_enable);\n\n\tPIPE_CONF_CHECK_BOOL_INCOMPLETE(has_audio);\n\tPIPE_CONF_CHECK_BUFFER(eld, MAX_ELD_BYTES);\n\n\tPIPE_CONF_CHECK_X(gmch_pfit.control);\n\t \n\tif (DISPLAY_VER(dev_priv) < 4)\n\t\tPIPE_CONF_CHECK_X(gmch_pfit.pgm_ratios);\n\tPIPE_CONF_CHECK_X(gmch_pfit.lvds_border_bits);\n\n\t \n\tPIPE_CONF_CHECK_BOOL(pch_pfit.force_thru);\n\n\tif (!fastset) {\n\t\tPIPE_CONF_CHECK_RECT(pipe_src);\n\n\t\tPIPE_CONF_CHECK_BOOL(pch_pfit.enabled);\n\t\tPIPE_CONF_CHECK_RECT(pch_pfit.dst);\n\n\t\tPIPE_CONF_CHECK_I(scaler_state.scaler_id);\n\t\tPIPE_CONF_CHECK_I(pixel_rate);\n\n\t\tPIPE_CONF_CHECK_X(gamma_mode);\n\t\tif (IS_CHERRYVIEW(dev_priv))\n\t\t\tPIPE_CONF_CHECK_X(cgm_mode);\n\t\telse\n\t\t\tPIPE_CONF_CHECK_X(csc_mode);\n\t\tPIPE_CONF_CHECK_BOOL(gamma_enable);\n\t\tPIPE_CONF_CHECK_BOOL(csc_enable);\n\t\tPIPE_CONF_CHECK_BOOL(wgc_enable);\n\n\t\tPIPE_CONF_CHECK_I(linetime);\n\t\tPIPE_CONF_CHECK_I(ips_linetime);\n\n\t\tPIPE_CONF_CHECK_COLOR_LUT(pre_csc_lut, true);\n\t\tPIPE_CONF_CHECK_COLOR_LUT(post_csc_lut, false);\n\n\t\tPIPE_CONF_CHECK_CSC(csc);\n\t\tPIPE_CONF_CHECK_CSC(output_csc);\n\n\t\tif (current_config->active_planes) {\n\t\t\tPIPE_CONF_CHECK_BOOL(has_psr);\n\t\t\tPIPE_CONF_CHECK_BOOL(has_psr2);\n\t\t\tPIPE_CONF_CHECK_BOOL(enable_psr2_sel_fetch);\n\t\t\tPIPE_CONF_CHECK_I(dc3co_exitline);\n\t\t}\n\t}\n\n\tPIPE_CONF_CHECK_BOOL(double_wide);\n\n\tif (dev_priv->display.dpll.mgr) {\n\t\tPIPE_CONF_CHECK_P(shared_dpll);\n\n\t\tPIPE_CONF_CHECK_X(dpll_hw_state.dpll);\n\t\tPIPE_CONF_CHECK_X(dpll_hw_state.dpll_md);\n\t\tPIPE_CONF_CHECK_X(dpll_hw_state.fp0);\n\t\tPIPE_CONF_CHECK_X(dpll_hw_state.fp1);\n\t\tPIPE_CONF_CHECK_X(dpll_hw_state.wrpll);\n\t\tPIPE_CONF_CHECK_X(dpll_hw_state.spll);\n\t\tPIPE_CONF_CHECK_X(dpll_hw_state.ctrl1);\n\t\tPIPE_CONF_CHECK_X(dpll_hw_state.cfgcr1);\n\t\tPIPE_CONF_CHECK_X(dpll_hw_state.cfgcr2);\n\t\tPIPE_CONF_CHECK_X(dpll_hw_state.cfgcr0);\n\t\tPIPE_CONF_CHECK_X(dpll_hw_state.div0);\n\t\tPIPE_CONF_CHECK_X(dpll_hw_state.ebb0);\n\t\tPIPE_CONF_CHECK_X(dpll_hw_state.ebb4);\n\t\tPIPE_CONF_CHECK_X(dpll_hw_state.pll0);\n\t\tPIPE_CONF_CHECK_X(dpll_hw_state.pll1);\n\t\tPIPE_CONF_CHECK_X(dpll_hw_state.pll2);\n\t\tPIPE_CONF_CHECK_X(dpll_hw_state.pll3);\n\t\tPIPE_CONF_CHECK_X(dpll_hw_state.pll6);\n\t\tPIPE_CONF_CHECK_X(dpll_hw_state.pll8);\n\t\tPIPE_CONF_CHECK_X(dpll_hw_state.pll9);\n\t\tPIPE_CONF_CHECK_X(dpll_hw_state.pll10);\n\t\tPIPE_CONF_CHECK_X(dpll_hw_state.pcsdw12);\n\t\tPIPE_CONF_CHECK_X(dpll_hw_state.mg_refclkin_ctl);\n\t\tPIPE_CONF_CHECK_X(dpll_hw_state.mg_clktop2_coreclkctl1);\n\t\tPIPE_CONF_CHECK_X(dpll_hw_state.mg_clktop2_hsclkctl);\n\t\tPIPE_CONF_CHECK_X(dpll_hw_state.mg_pll_div0);\n\t\tPIPE_CONF_CHECK_X(dpll_hw_state.mg_pll_div1);\n\t\tPIPE_CONF_CHECK_X(dpll_hw_state.mg_pll_lf);\n\t\tPIPE_CONF_CHECK_X(dpll_hw_state.mg_pll_frac_lock);\n\t\tPIPE_CONF_CHECK_X(dpll_hw_state.mg_pll_ssc);\n\t\tPIPE_CONF_CHECK_X(dpll_hw_state.mg_pll_bias);\n\t\tPIPE_CONF_CHECK_X(dpll_hw_state.mg_pll_tdc_coldst_bias);\n\t}\n\n\tPIPE_CONF_CHECK_X(dsi_pll.ctrl);\n\tPIPE_CONF_CHECK_X(dsi_pll.div);\n\n\tif (IS_G4X(dev_priv) || DISPLAY_VER(dev_priv) >= 5)\n\t\tPIPE_CONF_CHECK_I(pipe_bpp);\n\n\tif (!fastset || !pipe_config->seamless_m_n) {\n\t\tPIPE_CONF_CHECK_I(hw.pipe_mode.crtc_clock);\n\t\tPIPE_CONF_CHECK_I(hw.adjusted_mode.crtc_clock);\n\t}\n\tPIPE_CONF_CHECK_I(port_clock);\n\n\tPIPE_CONF_CHECK_I(min_voltage_level);\n\n\tif (current_config->has_psr || pipe_config->has_psr)\n\t\tPIPE_CONF_CHECK_X_WITH_MASK(infoframes.enable,\n\t\t\t\t\t    ~intel_hdmi_infoframe_enable(DP_SDP_VSC));\n\telse\n\t\tPIPE_CONF_CHECK_X(infoframes.enable);\n\n\tPIPE_CONF_CHECK_X(infoframes.gcp);\n\tPIPE_CONF_CHECK_INFOFRAME(avi);\n\tPIPE_CONF_CHECK_INFOFRAME(spd);\n\tPIPE_CONF_CHECK_INFOFRAME(hdmi);\n\tPIPE_CONF_CHECK_INFOFRAME(drm);\n\tPIPE_CONF_CHECK_DP_VSC_SDP(vsc);\n\n\tPIPE_CONF_CHECK_X(sync_mode_slaves_mask);\n\tPIPE_CONF_CHECK_I(master_transcoder);\n\tPIPE_CONF_CHECK_X(bigjoiner_pipes);\n\n\tPIPE_CONF_CHECK_I(dsc.compression_enable);\n\tPIPE_CONF_CHECK_I(dsc.dsc_split);\n\tPIPE_CONF_CHECK_I(dsc.compressed_bpp);\n\n\tPIPE_CONF_CHECK_BOOL(splitter.enable);\n\tPIPE_CONF_CHECK_I(splitter.link_count);\n\tPIPE_CONF_CHECK_I(splitter.pixel_overlap);\n\n\tif (!fastset)\n\t\tPIPE_CONF_CHECK_BOOL(vrr.enable);\n\tPIPE_CONF_CHECK_I(vrr.vmin);\n\tPIPE_CONF_CHECK_I(vrr.vmax);\n\tPIPE_CONF_CHECK_I(vrr.flipline);\n\tPIPE_CONF_CHECK_I(vrr.pipeline_full);\n\tPIPE_CONF_CHECK_I(vrr.guardband);\n\n#undef PIPE_CONF_CHECK_X\n#undef PIPE_CONF_CHECK_I\n#undef PIPE_CONF_CHECK_BOOL\n#undef PIPE_CONF_CHECK_BOOL_INCOMPLETE\n#undef PIPE_CONF_CHECK_P\n#undef PIPE_CONF_CHECK_FLAGS\n#undef PIPE_CONF_CHECK_COLOR_LUT\n#undef PIPE_CONF_CHECK_TIMINGS\n#undef PIPE_CONF_CHECK_RECT\n#undef PIPE_CONF_QUIRK\n\n\treturn ret;\n}\n\nstatic void\nintel_verify_planes(struct intel_atomic_state *state)\n{\n\tstruct intel_plane *plane;\n\tconst struct intel_plane_state *plane_state;\n\tint i;\n\n\tfor_each_new_intel_plane_in_state(state, plane,\n\t\t\t\t\t  plane_state, i)\n\t\tassert_plane(plane, plane_state->planar_slave ||\n\t\t\t     plane_state->uapi.visible);\n}\n\nint intel_modeset_all_pipes(struct intel_atomic_state *state,\n\t\t\t    const char *reason)\n{\n\tstruct drm_i915_private *dev_priv = to_i915(state->base.dev);\n\tstruct intel_crtc *crtc;\n\n\t \n\tfor_each_intel_crtc(&dev_priv->drm, crtc) {\n\t\tstruct intel_crtc_state *crtc_state;\n\t\tint ret;\n\n\t\tcrtc_state = intel_atomic_get_crtc_state(&state->base, crtc);\n\t\tif (IS_ERR(crtc_state))\n\t\t\treturn PTR_ERR(crtc_state);\n\n\t\tif (!crtc_state->hw.active ||\n\t\t    intel_crtc_needs_modeset(crtc_state))\n\t\t\tcontinue;\n\n\t\tdrm_dbg_kms(&dev_priv->drm, \"[CRTC:%d:%s] Full modeset due to %s\\n\",\n\t\t\t    crtc->base.base.id, crtc->base.name, reason);\n\n\t\tcrtc_state->uapi.mode_changed = true;\n\t\tcrtc_state->update_pipe = false;\n\n\t\tret = drm_atomic_add_affected_connectors(&state->base,\n\t\t\t\t\t\t\t &crtc->base);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tret = intel_dp_mst_add_topology_state_for_crtc(state, crtc);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tret = intel_atomic_add_affected_planes(state, crtc);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tcrtc_state->update_planes |= crtc_state->active_planes;\n\t\tcrtc_state->async_flip_planes = 0;\n\t\tcrtc_state->do_async_flip = false;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int hsw_mode_set_planes_workaround(struct intel_atomic_state *state)\n{\n\tstruct intel_crtc_state *crtc_state;\n\tstruct intel_crtc *crtc;\n\tstruct intel_crtc_state *first_crtc_state = NULL;\n\tstruct intel_crtc_state *other_crtc_state = NULL;\n\tenum pipe first_pipe = INVALID_PIPE, enabled_pipe = INVALID_PIPE;\n\tint i;\n\n\t \n\tfor_each_new_intel_crtc_in_state(state, crtc, crtc_state, i) {\n\t\tif (!crtc_state->hw.active ||\n\t\t    !intel_crtc_needs_modeset(crtc_state))\n\t\t\tcontinue;\n\n\t\tif (first_crtc_state) {\n\t\t\tother_crtc_state = crtc_state;\n\t\t\tbreak;\n\t\t} else {\n\t\t\tfirst_crtc_state = crtc_state;\n\t\t\tfirst_pipe = crtc->pipe;\n\t\t}\n\t}\n\n\t \n\tif (!first_crtc_state)\n\t\treturn 0;\n\n\t \n\tfor_each_intel_crtc(state->base.dev, crtc) {\n\t\tcrtc_state = intel_atomic_get_crtc_state(&state->base, crtc);\n\t\tif (IS_ERR(crtc_state))\n\t\t\treturn PTR_ERR(crtc_state);\n\n\t\tcrtc_state->hsw_workaround_pipe = INVALID_PIPE;\n\n\t\tif (!crtc_state->hw.active ||\n\t\t    intel_crtc_needs_modeset(crtc_state))\n\t\t\tcontinue;\n\n\t\t \n\t\tif (enabled_pipe != INVALID_PIPE)\n\t\t\treturn 0;\n\n\t\tenabled_pipe = crtc->pipe;\n\t}\n\n\tif (enabled_pipe != INVALID_PIPE)\n\t\tfirst_crtc_state->hsw_workaround_pipe = enabled_pipe;\n\telse if (other_crtc_state)\n\t\tother_crtc_state->hsw_workaround_pipe = first_pipe;\n\n\treturn 0;\n}\n\nu8 intel_calc_active_pipes(struct intel_atomic_state *state,\n\t\t\t   u8 active_pipes)\n{\n\tconst struct intel_crtc_state *crtc_state;\n\tstruct intel_crtc *crtc;\n\tint i;\n\n\tfor_each_new_intel_crtc_in_state(state, crtc, crtc_state, i) {\n\t\tif (crtc_state->hw.active)\n\t\t\tactive_pipes |= BIT(crtc->pipe);\n\t\telse\n\t\t\tactive_pipes &= ~BIT(crtc->pipe);\n\t}\n\n\treturn active_pipes;\n}\n\nstatic int intel_modeset_checks(struct intel_atomic_state *state)\n{\n\tstruct drm_i915_private *dev_priv = to_i915(state->base.dev);\n\n\tstate->modeset = true;\n\n\tif (IS_HASWELL(dev_priv))\n\t\treturn hsw_mode_set_planes_workaround(state);\n\n\treturn 0;\n}\n\nstatic void intel_crtc_check_fastset(const struct intel_crtc_state *old_crtc_state,\n\t\t\t\t     struct intel_crtc_state *new_crtc_state)\n{\n\tstruct drm_i915_private *i915 = to_i915(old_crtc_state->uapi.crtc->dev);\n\n\tif (!intel_pipe_config_compare(old_crtc_state, new_crtc_state, true)) {\n\t\tdrm_dbg_kms(&i915->drm, \"fastset requirement not met, forcing full modeset\\n\");\n\n\t\treturn;\n\t}\n\n\tnew_crtc_state->uapi.mode_changed = false;\n\tif (!intel_crtc_needs_modeset(new_crtc_state))\n\t\tnew_crtc_state->update_pipe = true;\n}\n\nstatic int intel_crtc_add_planes_to_state(struct intel_atomic_state *state,\n\t\t\t\t\t  struct intel_crtc *crtc,\n\t\t\t\t\t  u8 plane_ids_mask)\n{\n\tstruct drm_i915_private *dev_priv = to_i915(state->base.dev);\n\tstruct intel_plane *plane;\n\n\tfor_each_intel_plane_on_crtc(&dev_priv->drm, crtc, plane) {\n\t\tstruct intel_plane_state *plane_state;\n\n\t\tif ((plane_ids_mask & BIT(plane->id)) == 0)\n\t\t\tcontinue;\n\n\t\tplane_state = intel_atomic_get_plane_state(state, plane);\n\t\tif (IS_ERR(plane_state))\n\t\t\treturn PTR_ERR(plane_state);\n\t}\n\n\treturn 0;\n}\n\nint intel_atomic_add_affected_planes(struct intel_atomic_state *state,\n\t\t\t\t     struct intel_crtc *crtc)\n{\n\tconst struct intel_crtc_state *old_crtc_state =\n\t\tintel_atomic_get_old_crtc_state(state, crtc);\n\tconst struct intel_crtc_state *new_crtc_state =\n\t\tintel_atomic_get_new_crtc_state(state, crtc);\n\n\treturn intel_crtc_add_planes_to_state(state, crtc,\n\t\t\t\t\t      old_crtc_state->enabled_planes |\n\t\t\t\t\t      new_crtc_state->enabled_planes);\n}\n\nstatic bool active_planes_affects_min_cdclk(struct drm_i915_private *dev_priv)\n{\n\t \n\treturn IS_BROADWELL(dev_priv) || IS_HASWELL(dev_priv) ||\n\t\tIS_CHERRYVIEW(dev_priv) || IS_VALLEYVIEW(dev_priv) ||\n\t\tIS_IVYBRIDGE(dev_priv);\n}\n\nstatic int intel_crtc_add_bigjoiner_planes(struct intel_atomic_state *state,\n\t\t\t\t\t   struct intel_crtc *crtc,\n\t\t\t\t\t   struct intel_crtc *other)\n{\n\tconst struct intel_plane_state __maybe_unused *plane_state;\n\tstruct intel_plane *plane;\n\tu8 plane_ids = 0;\n\tint i;\n\n\tfor_each_new_intel_plane_in_state(state, plane, plane_state, i) {\n\t\tif (plane->pipe == crtc->pipe)\n\t\t\tplane_ids |= BIT(plane->id);\n\t}\n\n\treturn intel_crtc_add_planes_to_state(state, other, plane_ids);\n}\n\nstatic int intel_bigjoiner_add_affected_planes(struct intel_atomic_state *state)\n{\n\tstruct drm_i915_private *i915 = to_i915(state->base.dev);\n\tconst struct intel_crtc_state *crtc_state;\n\tstruct intel_crtc *crtc;\n\tint i;\n\n\tfor_each_new_intel_crtc_in_state(state, crtc, crtc_state, i) {\n\t\tstruct intel_crtc *other;\n\n\t\tfor_each_intel_crtc_in_pipe_mask(&i915->drm, other,\n\t\t\t\t\t\t crtc_state->bigjoiner_pipes) {\n\t\t\tint ret;\n\n\t\t\tif (crtc == other)\n\t\t\t\tcontinue;\n\n\t\t\tret = intel_crtc_add_bigjoiner_planes(state, crtc, other);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int intel_atomic_check_planes(struct intel_atomic_state *state)\n{\n\tstruct drm_i915_private *dev_priv = to_i915(state->base.dev);\n\tstruct intel_crtc_state *old_crtc_state, *new_crtc_state;\n\tstruct intel_plane_state __maybe_unused *plane_state;\n\tstruct intel_plane *plane;\n\tstruct intel_crtc *crtc;\n\tint i, ret;\n\n\tret = icl_add_linked_planes(state);\n\tif (ret)\n\t\treturn ret;\n\n\tret = intel_bigjoiner_add_affected_planes(state);\n\tif (ret)\n\t\treturn ret;\n\n\tfor_each_new_intel_plane_in_state(state, plane, plane_state, i) {\n\t\tret = intel_plane_atomic_check(state, plane);\n\t\tif (ret) {\n\t\t\tdrm_dbg_atomic(&dev_priv->drm,\n\t\t\t\t       \"[PLANE:%d:%s] atomic driver check failed\\n\",\n\t\t\t\t       plane->base.base.id, plane->base.name);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tfor_each_oldnew_intel_crtc_in_state(state, crtc, old_crtc_state,\n\t\t\t\t\t    new_crtc_state, i) {\n\t\tu8 old_active_planes, new_active_planes;\n\n\t\tret = icl_check_nv12_planes(new_crtc_state);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\t \n\t\tif (!active_planes_affects_min_cdclk(dev_priv))\n\t\t\tcontinue;\n\n\t\told_active_planes = old_crtc_state->active_planes & ~BIT(PLANE_CURSOR);\n\t\tnew_active_planes = new_crtc_state->active_planes & ~BIT(PLANE_CURSOR);\n\n\t\tif (hweight8(old_active_planes) == hweight8(new_active_planes))\n\t\t\tcontinue;\n\n\t\tret = intel_crtc_add_planes_to_state(state, crtc, new_active_planes);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int intel_atomic_check_crtcs(struct intel_atomic_state *state)\n{\n\tstruct intel_crtc_state __maybe_unused *crtc_state;\n\tstruct intel_crtc *crtc;\n\tint i;\n\n\tfor_each_new_intel_crtc_in_state(state, crtc, crtc_state, i) {\n\t\tstruct drm_i915_private *i915 = to_i915(crtc->base.dev);\n\t\tint ret;\n\n\t\tret = intel_crtc_atomic_check(state, crtc);\n\t\tif (ret) {\n\t\t\tdrm_dbg_atomic(&i915->drm,\n\t\t\t\t       \"[CRTC:%d:%s] atomic driver check failed\\n\",\n\t\t\t\t       crtc->base.base.id, crtc->base.name);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic bool intel_cpu_transcoders_need_modeset(struct intel_atomic_state *state,\n\t\t\t\t\t       u8 transcoders)\n{\n\tconst struct intel_crtc_state *new_crtc_state;\n\tstruct intel_crtc *crtc;\n\tint i;\n\n\tfor_each_new_intel_crtc_in_state(state, crtc, new_crtc_state, i) {\n\t\tif (new_crtc_state->hw.enable &&\n\t\t    transcoders & BIT(new_crtc_state->cpu_transcoder) &&\n\t\t    intel_crtc_needs_modeset(new_crtc_state))\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}\n\nstatic bool intel_pipes_need_modeset(struct intel_atomic_state *state,\n\t\t\t\t     u8 pipes)\n{\n\tconst struct intel_crtc_state *new_crtc_state;\n\tstruct intel_crtc *crtc;\n\tint i;\n\n\tfor_each_new_intel_crtc_in_state(state, crtc, new_crtc_state, i) {\n\t\tif (new_crtc_state->hw.enable &&\n\t\t    pipes & BIT(crtc->pipe) &&\n\t\t    intel_crtc_needs_modeset(new_crtc_state))\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}\n\nstatic int intel_atomic_check_bigjoiner(struct intel_atomic_state *state,\n\t\t\t\t\tstruct intel_crtc *master_crtc)\n{\n\tstruct drm_i915_private *i915 = to_i915(state->base.dev);\n\tstruct intel_crtc_state *master_crtc_state =\n\t\tintel_atomic_get_new_crtc_state(state, master_crtc);\n\tstruct intel_crtc *slave_crtc;\n\n\tif (!master_crtc_state->bigjoiner_pipes)\n\t\treturn 0;\n\n\t \n\tif (drm_WARN_ON(&i915->drm,\n\t\t\tmaster_crtc->pipe != bigjoiner_master_pipe(master_crtc_state)))\n\t\treturn -EINVAL;\n\n\tif (master_crtc_state->bigjoiner_pipes & ~bigjoiner_pipes(i915)) {\n\t\tdrm_dbg_kms(&i915->drm,\n\t\t\t    \"[CRTC:%d:%s] Cannot act as big joiner master \"\n\t\t\t    \"(need 0x%x as pipes, only 0x%x possible)\\n\",\n\t\t\t    master_crtc->base.base.id, master_crtc->base.name,\n\t\t\t    master_crtc_state->bigjoiner_pipes, bigjoiner_pipes(i915));\n\t\treturn -EINVAL;\n\t}\n\n\tfor_each_intel_crtc_in_pipe_mask(&i915->drm, slave_crtc,\n\t\t\t\t\t intel_crtc_bigjoiner_slave_pipes(master_crtc_state)) {\n\t\tstruct intel_crtc_state *slave_crtc_state;\n\t\tint ret;\n\n\t\tslave_crtc_state = intel_atomic_get_crtc_state(&state->base, slave_crtc);\n\t\tif (IS_ERR(slave_crtc_state))\n\t\t\treturn PTR_ERR(slave_crtc_state);\n\n\t\t \n\t\tif (slave_crtc_state->uapi.enable) {\n\t\t\tdrm_dbg_kms(&i915->drm,\n\t\t\t\t    \"[CRTC:%d:%s] Slave is enabled as normal CRTC, but \"\n\t\t\t\t    \"[CRTC:%d:%s] claiming this CRTC for bigjoiner.\\n\",\n\t\t\t\t    slave_crtc->base.base.id, slave_crtc->base.name,\n\t\t\t\t    master_crtc->base.base.id, master_crtc->base.name);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\t \n\t\tif (WARN_ON(drm_crtc_index(&master_crtc->base) >\n\t\t\t    drm_crtc_index(&slave_crtc->base)))\n\t\t\treturn -EINVAL;\n\n\t\tdrm_dbg_kms(&i915->drm,\n\t\t\t    \"[CRTC:%d:%s] Used as slave for big joiner master [CRTC:%d:%s]\\n\",\n\t\t\t    slave_crtc->base.base.id, slave_crtc->base.name,\n\t\t\t    master_crtc->base.base.id, master_crtc->base.name);\n\n\t\tslave_crtc_state->bigjoiner_pipes =\n\t\t\tmaster_crtc_state->bigjoiner_pipes;\n\n\t\tret = copy_bigjoiner_crtc_state_modeset(state, slave_crtc);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic void kill_bigjoiner_slave(struct intel_atomic_state *state,\n\t\t\t\t struct intel_crtc *master_crtc)\n{\n\tstruct drm_i915_private *i915 = to_i915(state->base.dev);\n\tstruct intel_crtc_state *master_crtc_state =\n\t\tintel_atomic_get_new_crtc_state(state, master_crtc);\n\tstruct intel_crtc *slave_crtc;\n\n\tfor_each_intel_crtc_in_pipe_mask(&i915->drm, slave_crtc,\n\t\t\t\t\t intel_crtc_bigjoiner_slave_pipes(master_crtc_state)) {\n\t\tstruct intel_crtc_state *slave_crtc_state =\n\t\t\tintel_atomic_get_new_crtc_state(state, slave_crtc);\n\n\t\tslave_crtc_state->bigjoiner_pipes = 0;\n\n\t\tintel_crtc_copy_uapi_to_hw_state_modeset(state, slave_crtc);\n\t}\n\n\tmaster_crtc_state->bigjoiner_pipes = 0;\n}\n\n \nstatic int intel_async_flip_check_uapi(struct intel_atomic_state *state,\n\t\t\t\t       struct intel_crtc *crtc)\n{\n\tstruct drm_i915_private *i915 = to_i915(state->base.dev);\n\tconst struct intel_crtc_state *new_crtc_state =\n\t\tintel_atomic_get_new_crtc_state(state, crtc);\n\tconst struct intel_plane_state *old_plane_state;\n\tstruct intel_plane_state *new_plane_state;\n\tstruct intel_plane *plane;\n\tint i;\n\n\tif (!new_crtc_state->uapi.async_flip)\n\t\treturn 0;\n\n\tif (!new_crtc_state->uapi.active) {\n\t\tdrm_dbg_kms(&i915->drm,\n\t\t\t    \"[CRTC:%d:%s] not active\\n\",\n\t\t\t    crtc->base.base.id, crtc->base.name);\n\t\treturn -EINVAL;\n\t}\n\n\tif (intel_crtc_needs_modeset(new_crtc_state)) {\n\t\tdrm_dbg_kms(&i915->drm,\n\t\t\t    \"[CRTC:%d:%s] modeset required\\n\",\n\t\t\t    crtc->base.base.id, crtc->base.name);\n\t\treturn -EINVAL;\n\t}\n\n\tfor_each_oldnew_intel_plane_in_state(state, plane, old_plane_state,\n\t\t\t\t\t     new_plane_state, i) {\n\t\tif (plane->pipe != crtc->pipe)\n\t\t\tcontinue;\n\n\t\t \n\t\tif (!plane->async_flip) {\n\t\t\tdrm_dbg_kms(&i915->drm,\n\t\t\t\t    \"[PLANE:%d:%s] async flip not supported\\n\",\n\t\t\t\t    plane->base.base.id, plane->base.name);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (!old_plane_state->uapi.fb || !new_plane_state->uapi.fb) {\n\t\t\tdrm_dbg_kms(&i915->drm,\n\t\t\t\t    \"[PLANE:%d:%s] no old or new framebuffer\\n\",\n\t\t\t\t    plane->base.base.id, plane->base.name);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int intel_async_flip_check_hw(struct intel_atomic_state *state, struct intel_crtc *crtc)\n{\n\tstruct drm_i915_private *i915 = to_i915(state->base.dev);\n\tconst struct intel_crtc_state *old_crtc_state, *new_crtc_state;\n\tconst struct intel_plane_state *new_plane_state, *old_plane_state;\n\tstruct intel_plane *plane;\n\tint i;\n\n\told_crtc_state = intel_atomic_get_old_crtc_state(state, crtc);\n\tnew_crtc_state = intel_atomic_get_new_crtc_state(state, crtc);\n\n\tif (!new_crtc_state->uapi.async_flip)\n\t\treturn 0;\n\n\tif (!new_crtc_state->hw.active) {\n\t\tdrm_dbg_kms(&i915->drm,\n\t\t\t    \"[CRTC:%d:%s] not active\\n\",\n\t\t\t    crtc->base.base.id, crtc->base.name);\n\t\treturn -EINVAL;\n\t}\n\n\tif (intel_crtc_needs_modeset(new_crtc_state)) {\n\t\tdrm_dbg_kms(&i915->drm,\n\t\t\t    \"[CRTC:%d:%s] modeset required\\n\",\n\t\t\t    crtc->base.base.id, crtc->base.name);\n\t\treturn -EINVAL;\n\t}\n\n\tif (old_crtc_state->active_planes != new_crtc_state->active_planes) {\n\t\tdrm_dbg_kms(&i915->drm,\n\t\t\t    \"[CRTC:%d:%s] Active planes cannot be in async flip\\n\",\n\t\t\t    crtc->base.base.id, crtc->base.name);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (new_crtc_state->bigjoiner_pipes) {\n\t\tdrm_dbg_kms(&i915->drm,\n\t\t\t    \"[CRTC:%d:%s] async flip disallowed with bigjoiner\\n\",\n\t\t\t    crtc->base.base.id, crtc->base.name);\n\t\treturn -EINVAL;\n\t}\n\n\tfor_each_oldnew_intel_plane_in_state(state, plane, old_plane_state,\n\t\t\t\t\t     new_plane_state, i) {\n\t\tif (plane->pipe != crtc->pipe)\n\t\t\tcontinue;\n\n\t\t \n\t\tif (drm_WARN_ON(&i915->drm,\n\t\t\t\tnew_crtc_state->do_async_flip && !plane->async_flip))\n\t\t\treturn -EINVAL;\n\n\t\t \n\t\tif (!plane->async_flip)\n\t\t\tcontinue;\n\n\t\t \n\t\tswitch (new_plane_state->hw.fb->modifier) {\n\t\tcase DRM_FORMAT_MOD_LINEAR:\n\t\t\t \n\t\t\tif (DISPLAY_VER(i915) < 12) {\n\t\t\t\tdrm_dbg_kms(&i915->drm,\n\t\t\t\t\t    \"[PLANE:%d:%s] Modifier 0x%llx does not support async flip on display ver %d\\n\",\n\t\t\t\t\t    plane->base.base.id, plane->base.name,\n\t\t\t\t\t    new_plane_state->hw.fb->modifier, DISPLAY_VER(i915));\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase I915_FORMAT_MOD_X_TILED:\n\t\tcase I915_FORMAT_MOD_Y_TILED:\n\t\tcase I915_FORMAT_MOD_Yf_TILED:\n\t\tcase I915_FORMAT_MOD_4_TILED:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdrm_dbg_kms(&i915->drm,\n\t\t\t\t    \"[PLANE:%d:%s] Modifier 0x%llx does not support async flip\\n\",\n\t\t\t\t    plane->base.base.id, plane->base.name,\n\t\t\t\t    new_plane_state->hw.fb->modifier);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (new_plane_state->hw.fb->format->num_planes > 1) {\n\t\t\tdrm_dbg_kms(&i915->drm,\n\t\t\t\t    \"[PLANE:%d:%s] Planar formats do not support async flips\\n\",\n\t\t\t\t    plane->base.base.id, plane->base.name);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (old_plane_state->view.color_plane[0].mapping_stride !=\n\t\t    new_plane_state->view.color_plane[0].mapping_stride) {\n\t\t\tdrm_dbg_kms(&i915->drm,\n\t\t\t\t    \"[PLANE:%d:%s] Stride cannot be changed in async flip\\n\",\n\t\t\t\t    plane->base.base.id, plane->base.name);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (old_plane_state->hw.fb->modifier !=\n\t\t    new_plane_state->hw.fb->modifier) {\n\t\t\tdrm_dbg_kms(&i915->drm,\n\t\t\t\t    \"[PLANE:%d:%s] Modifier cannot be changed in async flip\\n\",\n\t\t\t\t    plane->base.base.id, plane->base.name);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (old_plane_state->hw.fb->format !=\n\t\t    new_plane_state->hw.fb->format) {\n\t\t\tdrm_dbg_kms(&i915->drm,\n\t\t\t\t    \"[PLANE:%d:%s] Pixel format cannot be changed in async flip\\n\",\n\t\t\t\t    plane->base.base.id, plane->base.name);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (old_plane_state->hw.rotation !=\n\t\t    new_plane_state->hw.rotation) {\n\t\t\tdrm_dbg_kms(&i915->drm,\n\t\t\t\t    \"[PLANE:%d:%s] Rotation cannot be changed in async flip\\n\",\n\t\t\t\t    plane->base.base.id, plane->base.name);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (!drm_rect_equals(&old_plane_state->uapi.src, &new_plane_state->uapi.src) ||\n\t\t    !drm_rect_equals(&old_plane_state->uapi.dst, &new_plane_state->uapi.dst)) {\n\t\t\tdrm_dbg_kms(&i915->drm,\n\t\t\t\t    \"[PLANE:%d:%s] Size/co-ordinates cannot be changed in async flip\\n\",\n\t\t\t\t    plane->base.base.id, plane->base.name);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (old_plane_state->hw.alpha != new_plane_state->hw.alpha) {\n\t\t\tdrm_dbg_kms(&i915->drm,\n\t\t\t\t    \"[PLANES:%d:%s] Alpha value cannot be changed in async flip\\n\",\n\t\t\t\t    plane->base.base.id, plane->base.name);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (old_plane_state->hw.pixel_blend_mode !=\n\t\t    new_plane_state->hw.pixel_blend_mode) {\n\t\t\tdrm_dbg_kms(&i915->drm,\n\t\t\t\t    \"[PLANE:%d:%s] Pixel blend mode cannot be changed in async flip\\n\",\n\t\t\t\t    plane->base.base.id, plane->base.name);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (old_plane_state->hw.color_encoding != new_plane_state->hw.color_encoding) {\n\t\t\tdrm_dbg_kms(&i915->drm,\n\t\t\t\t    \"[PLANE:%d:%s] Color encoding cannot be changed in async flip\\n\",\n\t\t\t\t    plane->base.base.id, plane->base.name);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (old_plane_state->hw.color_range != new_plane_state->hw.color_range) {\n\t\t\tdrm_dbg_kms(&i915->drm,\n\t\t\t\t    \"[PLANE:%d:%s] Color range cannot be changed in async flip\\n\",\n\t\t\t\t    plane->base.base.id, plane->base.name);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\t \n\t\tif (old_plane_state->decrypt != new_plane_state->decrypt) {\n\t\t\tdrm_dbg_kms(&i915->drm,\n\t\t\t\t    \"[PLANE:%d:%s] Decryption cannot be changed in async flip\\n\",\n\t\t\t\t    plane->base.base.id, plane->base.name);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int intel_bigjoiner_add_affected_crtcs(struct intel_atomic_state *state)\n{\n\tstruct drm_i915_private *i915 = to_i915(state->base.dev);\n\tstruct intel_crtc_state *crtc_state;\n\tstruct intel_crtc *crtc;\n\tu8 affected_pipes = 0;\n\tu8 modeset_pipes = 0;\n\tint i;\n\n\tfor_each_new_intel_crtc_in_state(state, crtc, crtc_state, i) {\n\t\taffected_pipes |= crtc_state->bigjoiner_pipes;\n\t\tif (intel_crtc_needs_modeset(crtc_state))\n\t\t\tmodeset_pipes |= crtc_state->bigjoiner_pipes;\n\t}\n\n\tfor_each_intel_crtc_in_pipe_mask(&i915->drm, crtc, affected_pipes) {\n\t\tcrtc_state = intel_atomic_get_crtc_state(&state->base, crtc);\n\t\tif (IS_ERR(crtc_state))\n\t\t\treturn PTR_ERR(crtc_state);\n\t}\n\n\tfor_each_intel_crtc_in_pipe_mask(&i915->drm, crtc, modeset_pipes) {\n\t\tint ret;\n\n\t\tcrtc_state = intel_atomic_get_new_crtc_state(state, crtc);\n\n\t\tcrtc_state->uapi.mode_changed = true;\n\n\t\tret = drm_atomic_add_affected_connectors(&state->base, &crtc->base);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tret = intel_atomic_add_affected_planes(state, crtc);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tfor_each_new_intel_crtc_in_state(state, crtc, crtc_state, i) {\n\t\t \n\t\tif (intel_crtc_needs_modeset(crtc_state) &&\n\t\t    intel_crtc_is_bigjoiner_master(crtc_state))\n\t\t\tkill_bigjoiner_slave(state, crtc);\n\t}\n\n\treturn 0;\n}\n\n \nint intel_atomic_check(struct drm_device *dev,\n\t\t       struct drm_atomic_state *_state)\n{\n\tstruct drm_i915_private *dev_priv = to_i915(dev);\n\tstruct intel_atomic_state *state = to_intel_atomic_state(_state);\n\tstruct intel_crtc_state *old_crtc_state, *new_crtc_state;\n\tstruct intel_crtc *crtc;\n\tint ret, i;\n\tbool any_ms = false;\n\n\tfor_each_oldnew_intel_crtc_in_state(state, crtc, old_crtc_state,\n\t\t\t\t\t    new_crtc_state, i) {\n\t\t \n\t\tif (!state->internal)\n\t\t\tnew_crtc_state->inherited = false;\n\n\t\tif (new_crtc_state->inherited != old_crtc_state->inherited)\n\t\t\tnew_crtc_state->uapi.mode_changed = true;\n\n\t\tif (new_crtc_state->uapi.scaling_filter !=\n\t\t    old_crtc_state->uapi.scaling_filter)\n\t\t\tnew_crtc_state->uapi.mode_changed = true;\n\t}\n\n\tintel_vrr_check_modeset(state);\n\n\tret = drm_atomic_helper_check_modeset(dev, &state->base);\n\tif (ret)\n\t\tgoto fail;\n\n\tfor_each_new_intel_crtc_in_state(state, crtc, new_crtc_state, i) {\n\t\tret = intel_async_flip_check_uapi(state, crtc);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tret = intel_bigjoiner_add_affected_crtcs(state);\n\tif (ret)\n\t\tgoto fail;\n\n\tfor_each_oldnew_intel_crtc_in_state(state, crtc, old_crtc_state,\n\t\t\t\t\t    new_crtc_state, i) {\n\t\tif (!intel_crtc_needs_modeset(new_crtc_state)) {\n\t\t\tif (intel_crtc_is_bigjoiner_slave(new_crtc_state))\n\t\t\t\tcopy_bigjoiner_crtc_state_nomodeset(state, crtc);\n\t\t\telse\n\t\t\t\tintel_crtc_copy_uapi_to_hw_state_nomodeset(state, crtc);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (intel_crtc_is_bigjoiner_slave(new_crtc_state)) {\n\t\t\tdrm_WARN_ON(&dev_priv->drm, new_crtc_state->uapi.enable);\n\t\t\tcontinue;\n\t\t}\n\n\t\tret = intel_crtc_prepare_cleared_state(state, crtc);\n\t\tif (ret)\n\t\t\tgoto fail;\n\n\t\tif (!new_crtc_state->hw.enable)\n\t\t\tcontinue;\n\n\t\tret = intel_modeset_pipe_config(state, crtc);\n\t\tif (ret)\n\t\t\tgoto fail;\n\n\t\tret = intel_atomic_check_bigjoiner(state, crtc);\n\t\tif (ret)\n\t\t\tgoto fail;\n\t}\n\n\tfor_each_oldnew_intel_crtc_in_state(state, crtc, old_crtc_state,\n\t\t\t\t\t    new_crtc_state, i) {\n\t\tif (!intel_crtc_needs_modeset(new_crtc_state))\n\t\t\tcontinue;\n\n\t\tif (new_crtc_state->hw.enable) {\n\t\t\tret = intel_modeset_pipe_config_late(state, crtc);\n\t\t\tif (ret)\n\t\t\t\tgoto fail;\n\t\t}\n\n\t\tintel_crtc_check_fastset(old_crtc_state, new_crtc_state);\n\t}\n\n\t \n\tfor_each_new_intel_crtc_in_state(state, crtc, new_crtc_state, i) {\n\t\tif (!new_crtc_state->hw.enable || intel_crtc_needs_modeset(new_crtc_state))\n\t\t\tcontinue;\n\n\t\tif (intel_dp_mst_is_slave_trans(new_crtc_state)) {\n\t\t\tenum transcoder master = new_crtc_state->mst_master_transcoder;\n\n\t\t\tif (intel_cpu_transcoders_need_modeset(state, BIT(master))) {\n\t\t\t\tnew_crtc_state->uapi.mode_changed = true;\n\t\t\t\tnew_crtc_state->update_pipe = false;\n\t\t\t}\n\t\t}\n\n\t\tif (is_trans_port_sync_mode(new_crtc_state)) {\n\t\t\tu8 trans = new_crtc_state->sync_mode_slaves_mask;\n\n\t\t\tif (new_crtc_state->master_transcoder != INVALID_TRANSCODER)\n\t\t\t\ttrans |= BIT(new_crtc_state->master_transcoder);\n\n\t\t\tif (intel_cpu_transcoders_need_modeset(state, trans)) {\n\t\t\t\tnew_crtc_state->uapi.mode_changed = true;\n\t\t\t\tnew_crtc_state->update_pipe = false;\n\t\t\t}\n\t\t}\n\n\t\tif (new_crtc_state->bigjoiner_pipes) {\n\t\t\tif (intel_pipes_need_modeset(state, new_crtc_state->bigjoiner_pipes)) {\n\t\t\t\tnew_crtc_state->uapi.mode_changed = true;\n\t\t\t\tnew_crtc_state->update_pipe = false;\n\t\t\t}\n\t\t}\n\t}\n\n\tfor_each_oldnew_intel_crtc_in_state(state, crtc, old_crtc_state,\n\t\t\t\t\t    new_crtc_state, i) {\n\t\tif (!intel_crtc_needs_modeset(new_crtc_state))\n\t\t\tcontinue;\n\n\t\tany_ms = true;\n\n\t\tintel_release_shared_dplls(state, crtc);\n\t}\n\n\tif (any_ms && !check_digital_port_conflicts(state)) {\n\t\tdrm_dbg_kms(&dev_priv->drm,\n\t\t\t    \"rejecting conflicting digital port configuration\\n\");\n\t\tret = -EINVAL;\n\t\tgoto fail;\n\t}\n\n\tret = drm_dp_mst_atomic_check(&state->base);\n\tif (ret)\n\t\tgoto fail;\n\n\tret = intel_atomic_check_planes(state);\n\tif (ret)\n\t\tgoto fail;\n\n\tret = intel_compute_global_watermarks(state);\n\tif (ret)\n\t\tgoto fail;\n\n\tret = intel_bw_atomic_check(state);\n\tif (ret)\n\t\tgoto fail;\n\n\tret = intel_cdclk_atomic_check(state, &any_ms);\n\tif (ret)\n\t\tgoto fail;\n\n\tif (intel_any_crtc_needs_modeset(state))\n\t\tany_ms = true;\n\n\tif (any_ms) {\n\t\tret = intel_modeset_checks(state);\n\t\tif (ret)\n\t\t\tgoto fail;\n\n\t\tret = intel_modeset_calc_cdclk(state);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tret = intel_pmdemand_atomic_check(state);\n\tif (ret)\n\t\tgoto fail;\n\n\tret = intel_atomic_check_crtcs(state);\n\tif (ret)\n\t\tgoto fail;\n\n\tret = intel_fbc_atomic_check(state);\n\tif (ret)\n\t\tgoto fail;\n\n\tfor_each_oldnew_intel_crtc_in_state(state, crtc, old_crtc_state,\n\t\t\t\t\t    new_crtc_state, i) {\n\t\tintel_color_assert_luts(new_crtc_state);\n\n\t\tret = intel_async_flip_check_hw(state, crtc);\n\t\tif (ret)\n\t\t\tgoto fail;\n\n\t\t \n\t\tdrm_WARN_ON(&dev_priv->drm,\n\t\t\t    intel_crtc_needs_modeset(new_crtc_state) &&\n\t\t\t    intel_crtc_needs_fastset(new_crtc_state));\n\n\t\tif (!intel_crtc_needs_modeset(new_crtc_state) &&\n\t\t    !intel_crtc_needs_fastset(new_crtc_state))\n\t\t\tcontinue;\n\n\t\tintel_crtc_state_dump(new_crtc_state, state,\n\t\t\t\t      intel_crtc_needs_modeset(new_crtc_state) ?\n\t\t\t\t      \"modeset\" : \"fastset\");\n\t}\n\n\treturn 0;\n\n fail:\n\tif (ret == -EDEADLK)\n\t\treturn ret;\n\n\t \n\tfor_each_oldnew_intel_crtc_in_state(state, crtc, old_crtc_state,\n\t\t\t\t\t    new_crtc_state, i)\n\t\tintel_crtc_state_dump(new_crtc_state, state, \"failed\");\n\n\treturn ret;\n}\n\nstatic int intel_atomic_prepare_commit(struct intel_atomic_state *state)\n{\n\tstruct intel_crtc_state *crtc_state;\n\tstruct intel_crtc *crtc;\n\tint i, ret;\n\n\tret = drm_atomic_helper_prepare_planes(state->base.dev, &state->base);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tfor_each_new_intel_crtc_in_state(state, crtc, crtc_state, i) {\n\t\tif (intel_crtc_needs_color_update(crtc_state))\n\t\t\tintel_color_prepare_commit(crtc_state);\n\t}\n\n\treturn 0;\n}\n\nvoid intel_crtc_arm_fifo_underrun(struct intel_crtc *crtc,\n\t\t\t\t  struct intel_crtc_state *crtc_state)\n{\n\tstruct drm_i915_private *dev_priv = to_i915(crtc->base.dev);\n\n\tif (DISPLAY_VER(dev_priv) != 2 || crtc_state->active_planes)\n\t\tintel_set_cpu_fifo_underrun_reporting(dev_priv, crtc->pipe, true);\n\n\tif (crtc_state->has_pch_encoder) {\n\t\tenum pipe pch_transcoder =\n\t\t\tintel_crtc_pch_transcoder(crtc);\n\n\t\tintel_set_pch_fifo_underrun_reporting(dev_priv, pch_transcoder, true);\n\t}\n}\n\nstatic void intel_pipe_fastset(const struct intel_crtc_state *old_crtc_state,\n\t\t\t       const struct intel_crtc_state *new_crtc_state)\n{\n\tstruct intel_crtc *crtc = to_intel_crtc(new_crtc_state->uapi.crtc);\n\tstruct drm_i915_private *dev_priv = to_i915(crtc->base.dev);\n\n\t \n\tintel_set_pipe_src_size(new_crtc_state);\n\n\t \n\tif (DISPLAY_VER(dev_priv) >= 9) {\n\t\tif (new_crtc_state->pch_pfit.enabled)\n\t\t\tskl_pfit_enable(new_crtc_state);\n\t} else if (HAS_PCH_SPLIT(dev_priv)) {\n\t\tif (new_crtc_state->pch_pfit.enabled)\n\t\t\tilk_pfit_enable(new_crtc_state);\n\t\telse if (old_crtc_state->pch_pfit.enabled)\n\t\t\tilk_pfit_disable(old_crtc_state);\n\t}\n\n\t \n\tif (DISPLAY_VER(dev_priv) >= 9 ||\n\t    IS_BROADWELL(dev_priv) || IS_HASWELL(dev_priv))\n\t\thsw_set_linetime_wm(new_crtc_state);\n\n\tif (new_crtc_state->seamless_m_n)\n\t\tintel_cpu_transcoder_set_m1_n1(crtc, new_crtc_state->cpu_transcoder,\n\t\t\t\t\t       &new_crtc_state->dp_m_n);\n}\n\nstatic void commit_pipe_pre_planes(struct intel_atomic_state *state,\n\t\t\t\t   struct intel_crtc *crtc)\n{\n\tstruct drm_i915_private *dev_priv = to_i915(state->base.dev);\n\tconst struct intel_crtc_state *old_crtc_state =\n\t\tintel_atomic_get_old_crtc_state(state, crtc);\n\tconst struct intel_crtc_state *new_crtc_state =\n\t\tintel_atomic_get_new_crtc_state(state, crtc);\n\tbool modeset = intel_crtc_needs_modeset(new_crtc_state);\n\n\t \n\tif (!modeset) {\n\t\tif (intel_crtc_needs_color_update(new_crtc_state))\n\t\t\tintel_color_commit_arm(new_crtc_state);\n\n\t\tif (DISPLAY_VER(dev_priv) >= 9 || IS_BROADWELL(dev_priv))\n\t\t\tbdw_set_pipe_misc(new_crtc_state);\n\n\t\tif (intel_crtc_needs_fastset(new_crtc_state))\n\t\t\tintel_pipe_fastset(old_crtc_state, new_crtc_state);\n\t}\n\n\tintel_psr2_program_trans_man_trk_ctl(new_crtc_state);\n\n\tintel_atomic_update_watermarks(state, crtc);\n}\n\nstatic void commit_pipe_post_planes(struct intel_atomic_state *state,\n\t\t\t\t    struct intel_crtc *crtc)\n{\n\tstruct drm_i915_private *dev_priv = to_i915(state->base.dev);\n\tconst struct intel_crtc_state *new_crtc_state =\n\t\tintel_atomic_get_new_crtc_state(state, crtc);\n\n\t \n\tif (DISPLAY_VER(dev_priv) >= 9 &&\n\t    !intel_crtc_needs_modeset(new_crtc_state))\n\t\tskl_detach_scalers(new_crtc_state);\n}\n\nstatic void intel_enable_crtc(struct intel_atomic_state *state,\n\t\t\t      struct intel_crtc *crtc)\n{\n\tstruct drm_i915_private *dev_priv = to_i915(state->base.dev);\n\tconst struct intel_crtc_state *new_crtc_state =\n\t\tintel_atomic_get_new_crtc_state(state, crtc);\n\n\tif (!intel_crtc_needs_modeset(new_crtc_state))\n\t\treturn;\n\n\t \n\tintel_crtc_update_active_timings(new_crtc_state, false);\n\n\tdev_priv->display.funcs.display->crtc_enable(state, crtc);\n\n\tif (intel_crtc_is_bigjoiner_slave(new_crtc_state))\n\t\treturn;\n\n\t \n\tintel_crtc_enable_pipe_crc(crtc);\n}\n\nstatic void intel_update_crtc(struct intel_atomic_state *state,\n\t\t\t      struct intel_crtc *crtc)\n{\n\tstruct drm_i915_private *i915 = to_i915(state->base.dev);\n\tconst struct intel_crtc_state *old_crtc_state =\n\t\tintel_atomic_get_old_crtc_state(state, crtc);\n\tstruct intel_crtc_state *new_crtc_state =\n\t\tintel_atomic_get_new_crtc_state(state, crtc);\n\tbool modeset = intel_crtc_needs_modeset(new_crtc_state);\n\n\tif (old_crtc_state->inherited ||\n\t    intel_crtc_needs_modeset(new_crtc_state)) {\n\t\tif (HAS_DPT(i915))\n\t\t\tintel_dpt_configure(crtc);\n\t}\n\n\tif (vrr_enabling(old_crtc_state, new_crtc_state)) {\n\t\tintel_vrr_enable(new_crtc_state);\n\t\tintel_crtc_update_active_timings(new_crtc_state,\n\t\t\t\t\t\t new_crtc_state->vrr.enable);\n\t}\n\n\tif (!modeset) {\n\t\tif (new_crtc_state->preload_luts &&\n\t\t    intel_crtc_needs_color_update(new_crtc_state))\n\t\t\tintel_color_load_luts(new_crtc_state);\n\n\t\tintel_pre_plane_update(state, crtc);\n\n\t\tif (intel_crtc_needs_fastset(new_crtc_state))\n\t\t\tintel_encoders_update_pipe(state, crtc);\n\n\t\tif (DISPLAY_VER(i915) >= 11 &&\n\t\t    intel_crtc_needs_fastset(new_crtc_state))\n\t\t\ticl_set_pipe_chicken(new_crtc_state);\n\t}\n\n\tintel_fbc_update(state, crtc);\n\n\tdrm_WARN_ON(&i915->drm, !intel_display_power_is_enabled(i915, POWER_DOMAIN_DC_OFF));\n\n\tif (!modeset &&\n\t    intel_crtc_needs_color_update(new_crtc_state))\n\t\tintel_color_commit_noarm(new_crtc_state);\n\n\tintel_crtc_planes_update_noarm(state, crtc);\n\n\t \n\tintel_pipe_update_start(new_crtc_state);\n\n\tcommit_pipe_pre_planes(state, crtc);\n\n\tintel_crtc_planes_update_arm(state, crtc);\n\n\tcommit_pipe_post_planes(state, crtc);\n\n\tintel_pipe_update_end(new_crtc_state);\n\n\t \n\tif (intel_crtc_needs_fastset(new_crtc_state) && !modeset &&\n\t    old_crtc_state->inherited)\n\t\tintel_crtc_arm_fifo_underrun(crtc, new_crtc_state);\n}\n\nstatic void intel_old_crtc_state_disables(struct intel_atomic_state *state,\n\t\t\t\t\t  struct intel_crtc_state *old_crtc_state,\n\t\t\t\t\t  struct intel_crtc_state *new_crtc_state,\n\t\t\t\t\t  struct intel_crtc *crtc)\n{\n\tstruct drm_i915_private *dev_priv = to_i915(state->base.dev);\n\n\t \n\tintel_crtc_disable_pipe_crc(crtc);\n\n\tdev_priv->display.funcs.display->crtc_disable(state, crtc);\n\tcrtc->active = false;\n\tintel_fbc_disable(crtc);\n\n\tif (!new_crtc_state->hw.active)\n\t\tintel_initial_watermarks(state, crtc);\n}\n\nstatic void intel_commit_modeset_disables(struct intel_atomic_state *state)\n{\n\tstruct intel_crtc_state *new_crtc_state, *old_crtc_state;\n\tstruct intel_crtc *crtc;\n\tu32 handled = 0;\n\tint i;\n\n\tfor_each_oldnew_intel_crtc_in_state(state, crtc, old_crtc_state,\n\t\t\t\t\t    new_crtc_state, i) {\n\t\tif (!intel_crtc_needs_modeset(new_crtc_state))\n\t\t\tcontinue;\n\n\t\tintel_pre_plane_update(state, crtc);\n\n\t\tif (!old_crtc_state->hw.active)\n\t\t\tcontinue;\n\n\t\tintel_crtc_disable_planes(state, crtc);\n\t}\n\n\t \n\tfor_each_oldnew_intel_crtc_in_state(state, crtc, old_crtc_state,\n\t\t\t\t\t    new_crtc_state, i) {\n\t\tif (!intel_crtc_needs_modeset(new_crtc_state))\n\t\t\tcontinue;\n\n\t\tif (!old_crtc_state->hw.active)\n\t\t\tcontinue;\n\n\t\t \n\t\tif (!is_trans_port_sync_slave(old_crtc_state) &&\n\t\t    !intel_dp_mst_is_slave_trans(old_crtc_state) &&\n\t\t    !intel_crtc_is_bigjoiner_slave(old_crtc_state))\n\t\t\tcontinue;\n\n\t\tintel_old_crtc_state_disables(state, old_crtc_state,\n\t\t\t\t\t      new_crtc_state, crtc);\n\t\thandled |= BIT(crtc->pipe);\n\t}\n\n\t \n\tfor_each_oldnew_intel_crtc_in_state(state, crtc, old_crtc_state,\n\t\t\t\t\t    new_crtc_state, i) {\n\t\tif (!intel_crtc_needs_modeset(new_crtc_state) ||\n\t\t    (handled & BIT(crtc->pipe)))\n\t\t\tcontinue;\n\n\t\tif (!old_crtc_state->hw.active)\n\t\t\tcontinue;\n\n\t\tintel_old_crtc_state_disables(state, old_crtc_state,\n\t\t\t\t\t      new_crtc_state, crtc);\n\t}\n}\n\nstatic void intel_commit_modeset_enables(struct intel_atomic_state *state)\n{\n\tstruct intel_crtc_state *new_crtc_state;\n\tstruct intel_crtc *crtc;\n\tint i;\n\n\tfor_each_new_intel_crtc_in_state(state, crtc, new_crtc_state, i) {\n\t\tif (!new_crtc_state->hw.active)\n\t\t\tcontinue;\n\n\t\tintel_enable_crtc(state, crtc);\n\t\tintel_update_crtc(state, crtc);\n\t}\n}\n\nstatic void skl_commit_modeset_enables(struct intel_atomic_state *state)\n{\n\tstruct drm_i915_private *dev_priv = to_i915(state->base.dev);\n\tstruct intel_crtc *crtc;\n\tstruct intel_crtc_state *old_crtc_state, *new_crtc_state;\n\tstruct skl_ddb_entry entries[I915_MAX_PIPES] = {};\n\tu8 update_pipes = 0, modeset_pipes = 0;\n\tint i;\n\n\tfor_each_oldnew_intel_crtc_in_state(state, crtc, old_crtc_state, new_crtc_state, i) {\n\t\tenum pipe pipe = crtc->pipe;\n\n\t\tif (!new_crtc_state->hw.active)\n\t\t\tcontinue;\n\n\t\t \n\t\tif (!intel_crtc_needs_modeset(new_crtc_state)) {\n\t\t\tentries[pipe] = old_crtc_state->wm.skl.ddb;\n\t\t\tupdate_pipes |= BIT(pipe);\n\t\t} else {\n\t\t\tmodeset_pipes |= BIT(pipe);\n\t\t}\n\t}\n\n\t \n\twhile (update_pipes) {\n\t\tfor_each_oldnew_intel_crtc_in_state(state, crtc, old_crtc_state,\n\t\t\t\t\t\t    new_crtc_state, i) {\n\t\t\tenum pipe pipe = crtc->pipe;\n\n\t\t\tif ((update_pipes & BIT(pipe)) == 0)\n\t\t\t\tcontinue;\n\n\t\t\tif (skl_ddb_allocation_overlaps(&new_crtc_state->wm.skl.ddb,\n\t\t\t\t\t\t\tentries, I915_MAX_PIPES, pipe))\n\t\t\t\tcontinue;\n\n\t\t\tentries[pipe] = new_crtc_state->wm.skl.ddb;\n\t\t\tupdate_pipes &= ~BIT(pipe);\n\n\t\t\tintel_update_crtc(state, crtc);\n\n\t\t\t \n\t\t\tif (!skl_ddb_entry_equal(&new_crtc_state->wm.skl.ddb,\n\t\t\t\t\t\t &old_crtc_state->wm.skl.ddb) &&\n\t\t\t    (update_pipes | modeset_pipes))\n\t\t\t\tintel_crtc_wait_for_next_vblank(crtc);\n\t\t}\n\t}\n\n\tupdate_pipes = modeset_pipes;\n\n\t \n\tfor_each_new_intel_crtc_in_state(state, crtc, new_crtc_state, i) {\n\t\tenum pipe pipe = crtc->pipe;\n\n\t\tif ((modeset_pipes & BIT(pipe)) == 0)\n\t\t\tcontinue;\n\n\t\tif (intel_dp_mst_is_slave_trans(new_crtc_state) ||\n\t\t    is_trans_port_sync_master(new_crtc_state) ||\n\t\t    intel_crtc_is_bigjoiner_master(new_crtc_state))\n\t\t\tcontinue;\n\n\t\tmodeset_pipes &= ~BIT(pipe);\n\n\t\tintel_enable_crtc(state, crtc);\n\t}\n\n\t \n\tfor_each_new_intel_crtc_in_state(state, crtc, new_crtc_state, i) {\n\t\tenum pipe pipe = crtc->pipe;\n\n\t\tif ((modeset_pipes & BIT(pipe)) == 0)\n\t\t\tcontinue;\n\n\t\tmodeset_pipes &= ~BIT(pipe);\n\n\t\tintel_enable_crtc(state, crtc);\n\t}\n\n\t \n\tfor_each_new_intel_crtc_in_state(state, crtc, new_crtc_state, i) {\n\t\tenum pipe pipe = crtc->pipe;\n\n\t\tif ((update_pipes & BIT(pipe)) == 0)\n\t\t\tcontinue;\n\n\t\tdrm_WARN_ON(&dev_priv->drm, skl_ddb_allocation_overlaps(&new_crtc_state->wm.skl.ddb,\n\t\t\t\t\t\t\t\t\tentries, I915_MAX_PIPES, pipe));\n\n\t\tentries[pipe] = new_crtc_state->wm.skl.ddb;\n\t\tupdate_pipes &= ~BIT(pipe);\n\n\t\tintel_update_crtc(state, crtc);\n\t}\n\n\tdrm_WARN_ON(&dev_priv->drm, modeset_pipes);\n\tdrm_WARN_ON(&dev_priv->drm, update_pipes);\n}\n\nstatic void intel_atomic_helper_free_state(struct drm_i915_private *dev_priv)\n{\n\tstruct intel_atomic_state *state, *next;\n\tstruct llist_node *freed;\n\n\tfreed = llist_del_all(&dev_priv->display.atomic_helper.free_list);\n\tllist_for_each_entry_safe(state, next, freed, freed)\n\t\tdrm_atomic_state_put(&state->base);\n}\n\nvoid intel_atomic_helper_free_state_worker(struct work_struct *work)\n{\n\tstruct drm_i915_private *dev_priv =\n\t\tcontainer_of(work, typeof(*dev_priv), display.atomic_helper.free_work);\n\n\tintel_atomic_helper_free_state(dev_priv);\n}\n\nstatic void intel_atomic_commit_fence_wait(struct intel_atomic_state *intel_state)\n{\n\tstruct wait_queue_entry wait_fence, wait_reset;\n\tstruct drm_i915_private *dev_priv = to_i915(intel_state->base.dev);\n\n\tinit_wait_entry(&wait_fence, 0);\n\tinit_wait_entry(&wait_reset, 0);\n\tfor (;;) {\n\t\tprepare_to_wait(&intel_state->commit_ready.wait,\n\t\t\t\t&wait_fence, TASK_UNINTERRUPTIBLE);\n\t\tprepare_to_wait(bit_waitqueue(&to_gt(dev_priv)->reset.flags,\n\t\t\t\t\t      I915_RESET_MODESET),\n\t\t\t\t&wait_reset, TASK_UNINTERRUPTIBLE);\n\n\n\t\tif (i915_sw_fence_done(&intel_state->commit_ready) ||\n\t\t    test_bit(I915_RESET_MODESET, &to_gt(dev_priv)->reset.flags))\n\t\t\tbreak;\n\n\t\tschedule();\n\t}\n\tfinish_wait(&intel_state->commit_ready.wait, &wait_fence);\n\tfinish_wait(bit_waitqueue(&to_gt(dev_priv)->reset.flags,\n\t\t\t\t  I915_RESET_MODESET),\n\t\t    &wait_reset);\n}\n\nstatic void intel_atomic_cleanup_work(struct work_struct *work)\n{\n\tstruct intel_atomic_state *state =\n\t\tcontainer_of(work, struct intel_atomic_state, base.commit_work);\n\tstruct drm_i915_private *i915 = to_i915(state->base.dev);\n\tstruct intel_crtc_state *old_crtc_state;\n\tstruct intel_crtc *crtc;\n\tint i;\n\n\tfor_each_old_intel_crtc_in_state(state, crtc, old_crtc_state, i)\n\t\tintel_color_cleanup_commit(old_crtc_state);\n\n\tdrm_atomic_helper_cleanup_planes(&i915->drm, &state->base);\n\tdrm_atomic_helper_commit_cleanup_done(&state->base);\n\tdrm_atomic_state_put(&state->base);\n\n\tintel_atomic_helper_free_state(i915);\n}\n\nstatic void intel_atomic_prepare_plane_clear_colors(struct intel_atomic_state *state)\n{\n\tstruct drm_i915_private *i915 = to_i915(state->base.dev);\n\tstruct intel_plane *plane;\n\tstruct intel_plane_state *plane_state;\n\tint i;\n\n\tfor_each_new_intel_plane_in_state(state, plane, plane_state, i) {\n\t\tstruct drm_framebuffer *fb = plane_state->hw.fb;\n\t\tint cc_plane;\n\t\tint ret;\n\n\t\tif (!fb)\n\t\t\tcontinue;\n\n\t\tcc_plane = intel_fb_rc_ccs_cc_plane(fb);\n\t\tif (cc_plane < 0)\n\t\t\tcontinue;\n\n\t\t \n\t\tret = i915_gem_object_read_from_page(intel_fb_obj(fb),\n\t\t\t\t\t\t     fb->offsets[cc_plane] + 16,\n\t\t\t\t\t\t     &plane_state->ccval,\n\t\t\t\t\t\t     sizeof(plane_state->ccval));\n\t\t \n\t\tdrm_WARN_ON(&i915->drm, ret);\n\t}\n}\n\nstatic void intel_atomic_commit_tail(struct intel_atomic_state *state)\n{\n\tstruct drm_device *dev = state->base.dev;\n\tstruct drm_i915_private *dev_priv = to_i915(dev);\n\tstruct intel_crtc_state *new_crtc_state, *old_crtc_state;\n\tstruct intel_crtc *crtc;\n\tstruct intel_power_domain_mask put_domains[I915_MAX_PIPES] = {};\n\tintel_wakeref_t wakeref = 0;\n\tint i;\n\n\tintel_atomic_commit_fence_wait(state);\n\n\tdrm_atomic_helper_wait_for_dependencies(&state->base);\n\tdrm_dp_mst_atomic_wait_for_dependencies(&state->base);\n\n\t \n\twakeref = intel_display_power_get(dev_priv, POWER_DOMAIN_DC_OFF);\n\n\tintel_atomic_prepare_plane_clear_colors(state);\n\n\tfor_each_oldnew_intel_crtc_in_state(state, crtc, old_crtc_state,\n\t\t\t\t\t    new_crtc_state, i) {\n\t\tif (intel_crtc_needs_modeset(new_crtc_state) ||\n\t\t    intel_crtc_needs_fastset(new_crtc_state))\n\t\t\tintel_modeset_get_crtc_power_domains(new_crtc_state, &put_domains[crtc->pipe]);\n\t}\n\n\tintel_commit_modeset_disables(state);\n\n\t \n\tfor_each_new_intel_crtc_in_state(state, crtc, new_crtc_state, i)\n\t\tcrtc->config = new_crtc_state;\n\n\t \n\tintel_pmdemand_pre_plane_update(state);\n\n\tif (state->modeset) {\n\t\tdrm_atomic_helper_update_legacy_modeset_state(dev, &state->base);\n\n\t\tintel_set_cdclk_pre_plane_update(state);\n\n\t\tintel_modeset_verify_disabled(dev_priv, state);\n\t}\n\n\tintel_sagv_pre_plane_update(state);\n\n\t \n\tfor_each_new_intel_crtc_in_state(state, crtc, new_crtc_state, i) {\n\t\tbool modeset = intel_crtc_needs_modeset(new_crtc_state);\n\n\t\t \n\t\tif (modeset && !new_crtc_state->hw.active && new_crtc_state->uapi.event) {\n\t\t\tspin_lock_irq(&dev->event_lock);\n\t\t\tdrm_crtc_send_vblank_event(&crtc->base,\n\t\t\t\t\t\t   new_crtc_state->uapi.event);\n\t\t\tspin_unlock_irq(&dev->event_lock);\n\n\t\t\tnew_crtc_state->uapi.event = NULL;\n\t\t}\n\t}\n\n\tintel_encoders_update_prepare(state);\n\n\tintel_dbuf_pre_plane_update(state);\n\tintel_mbus_dbox_update(state);\n\n\tfor_each_new_intel_crtc_in_state(state, crtc, new_crtc_state, i) {\n\t\tif (new_crtc_state->do_async_flip)\n\t\t\tintel_crtc_enable_flip_done(state, crtc);\n\t}\n\n\t \n\tdev_priv->display.funcs.display->commit_modeset_enables(state);\n\n\tif (state->modeset)\n\t\tintel_set_cdclk_post_plane_update(state);\n\n\tintel_wait_for_vblank_workers(state);\n\n\t \n\tdrm_atomic_helper_wait_for_flip_done(dev, &state->base);\n\n\tfor_each_new_intel_crtc_in_state(state, crtc, new_crtc_state, i) {\n\t\tif (new_crtc_state->do_async_flip)\n\t\t\tintel_crtc_disable_flip_done(state, crtc);\n\t}\n\n\t \n\tfor_each_oldnew_intel_crtc_in_state(state, crtc, old_crtc_state,\n\t\t\t\t\t    new_crtc_state, i) {\n\t\t \n\t\tif (DISPLAY_VER(dev_priv) == 2 && planes_enabling(old_crtc_state, new_crtc_state))\n\t\t\tintel_set_cpu_fifo_underrun_reporting(dev_priv, crtc->pipe, true);\n\n\t\tintel_optimize_watermarks(state, crtc);\n\t}\n\n\tintel_dbuf_post_plane_update(state);\n\tintel_psr_post_plane_update(state);\n\n\tfor_each_oldnew_intel_crtc_in_state(state, crtc, old_crtc_state, new_crtc_state, i) {\n\t\tintel_post_plane_update(state, crtc);\n\n\t\tintel_modeset_put_crtc_power_domains(crtc, &put_domains[crtc->pipe]);\n\n\t\tintel_modeset_verify_crtc(crtc, state, old_crtc_state, new_crtc_state);\n\n\t\t \n\t\thsw_ips_post_update(state, crtc);\n\n\t\t \n\t\tintel_drrs_activate(new_crtc_state);\n\n\t\t \n\t\told_crtc_state->dsb = fetch_and_zero(&new_crtc_state->dsb);\n\t}\n\n\t \n\tintel_check_cpu_fifo_underruns(dev_priv);\n\tintel_check_pch_fifo_underruns(dev_priv);\n\n\tif (state->modeset)\n\t\tintel_verify_planes(state);\n\n\tintel_sagv_post_plane_update(state);\n\tintel_pmdemand_post_plane_update(state);\n\n\tdrm_atomic_helper_commit_hw_done(&state->base);\n\n\tif (state->modeset) {\n\t\t \n\t\tintel_uncore_arm_unclaimed_mmio_detection(&dev_priv->uncore);\n\t}\n\t \n\tintel_display_power_put_async_delay(dev_priv, POWER_DOMAIN_DC_OFF, wakeref, 17);\n\tintel_runtime_pm_put(&dev_priv->runtime_pm, state->wakeref);\n\n\t \n\tINIT_WORK(&state->base.commit_work, intel_atomic_cleanup_work);\n\tqueue_work(system_highpri_wq, &state->base.commit_work);\n}\n\nstatic void intel_atomic_commit_work(struct work_struct *work)\n{\n\tstruct intel_atomic_state *state =\n\t\tcontainer_of(work, struct intel_atomic_state, base.commit_work);\n\n\tintel_atomic_commit_tail(state);\n}\n\nstatic int\nintel_atomic_commit_ready(struct i915_sw_fence *fence,\n\t\t\t  enum i915_sw_fence_notify notify)\n{\n\tstruct intel_atomic_state *state =\n\t\tcontainer_of(fence, struct intel_atomic_state, commit_ready);\n\n\tswitch (notify) {\n\tcase FENCE_COMPLETE:\n\t\t \n\t\tbreak;\n\tcase FENCE_FREE:\n\t\t{\n\t\t\tstruct drm_i915_private *i915 = to_i915(state->base.dev);\n\t\t\tstruct intel_atomic_helper *helper =\n\t\t\t\t&i915->display.atomic_helper;\n\n\t\t\tif (llist_add(&state->freed, &helper->free_list))\n\t\t\t\tqueue_work(i915->unordered_wq, &helper->free_work);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn NOTIFY_DONE;\n}\n\nstatic void intel_atomic_track_fbs(struct intel_atomic_state *state)\n{\n\tstruct intel_plane_state *old_plane_state, *new_plane_state;\n\tstruct intel_plane *plane;\n\tint i;\n\n\tfor_each_oldnew_intel_plane_in_state(state, plane, old_plane_state,\n\t\t\t\t\t     new_plane_state, i)\n\t\tintel_frontbuffer_track(to_intel_frontbuffer(old_plane_state->hw.fb),\n\t\t\t\t\tto_intel_frontbuffer(new_plane_state->hw.fb),\n\t\t\t\t\tplane->frontbuffer_bit);\n}\n\nint intel_atomic_commit(struct drm_device *dev, struct drm_atomic_state *_state,\n\t\t\tbool nonblock)\n{\n\tstruct intel_atomic_state *state = to_intel_atomic_state(_state);\n\tstruct drm_i915_private *dev_priv = to_i915(dev);\n\tint ret = 0;\n\n\tstate->wakeref = intel_runtime_pm_get(&dev_priv->runtime_pm);\n\n\tdrm_atomic_state_get(&state->base);\n\ti915_sw_fence_init(&state->commit_ready,\n\t\t\t   intel_atomic_commit_ready);\n\n\t \n\tif (DISPLAY_VER(dev_priv) < 9 && state->base.legacy_cursor_update) {\n\t\tstruct intel_crtc_state *new_crtc_state;\n\t\tstruct intel_crtc *crtc;\n\t\tint i;\n\n\t\tfor_each_new_intel_crtc_in_state(state, crtc, new_crtc_state, i)\n\t\t\tif (new_crtc_state->wm.need_postvbl_update ||\n\t\t\t    new_crtc_state->update_wm_post)\n\t\t\t\tstate->base.legacy_cursor_update = false;\n\t}\n\n\tret = intel_atomic_prepare_commit(state);\n\tif (ret) {\n\t\tdrm_dbg_atomic(&dev_priv->drm,\n\t\t\t       \"Preparing state failed with %i\\n\", ret);\n\t\ti915_sw_fence_commit(&state->commit_ready);\n\t\tintel_runtime_pm_put(&dev_priv->runtime_pm, state->wakeref);\n\t\treturn ret;\n\t}\n\n\tret = drm_atomic_helper_setup_commit(&state->base, nonblock);\n\tif (!ret)\n\t\tret = drm_atomic_helper_swap_state(&state->base, true);\n\tif (!ret)\n\t\tintel_atomic_swap_global_state(state);\n\n\tif (ret) {\n\t\tstruct intel_crtc_state *new_crtc_state;\n\t\tstruct intel_crtc *crtc;\n\t\tint i;\n\n\t\ti915_sw_fence_commit(&state->commit_ready);\n\n\t\tfor_each_new_intel_crtc_in_state(state, crtc, new_crtc_state, i)\n\t\t\tintel_color_cleanup_commit(new_crtc_state);\n\n\t\tdrm_atomic_helper_unprepare_planes(dev, &state->base);\n\t\tintel_runtime_pm_put(&dev_priv->runtime_pm, state->wakeref);\n\t\treturn ret;\n\t}\n\tintel_shared_dpll_swap_state(state);\n\tintel_atomic_track_fbs(state);\n\n\tdrm_atomic_state_get(&state->base);\n\tINIT_WORK(&state->base.commit_work, intel_atomic_commit_work);\n\n\ti915_sw_fence_commit(&state->commit_ready);\n\tif (nonblock && state->modeset) {\n\t\tqueue_work(dev_priv->display.wq.modeset, &state->base.commit_work);\n\t} else if (nonblock) {\n\t\tqueue_work(dev_priv->display.wq.flip, &state->base.commit_work);\n\t} else {\n\t\tif (state->modeset)\n\t\t\tflush_workqueue(dev_priv->display.wq.modeset);\n\t\tintel_atomic_commit_tail(state);\n\t}\n\n\treturn 0;\n}\n\n \nvoid intel_plane_destroy(struct drm_plane *plane)\n{\n\tdrm_plane_cleanup(plane);\n\tkfree(to_intel_plane(plane));\n}\n\nint intel_get_pipe_from_crtc_id_ioctl(struct drm_device *dev, void *data,\n\t\t\t\t      struct drm_file *file)\n{\n\tstruct drm_i915_get_pipe_from_crtc_id *pipe_from_crtc_id = data;\n\tstruct drm_crtc *drmmode_crtc;\n\tstruct intel_crtc *crtc;\n\n\tdrmmode_crtc = drm_crtc_find(dev, file, pipe_from_crtc_id->crtc_id);\n\tif (!drmmode_crtc)\n\t\treturn -ENOENT;\n\n\tcrtc = to_intel_crtc(drmmode_crtc);\n\tpipe_from_crtc_id->pipe = crtc->pipe;\n\n\treturn 0;\n}\n\nstatic u32 intel_encoder_possible_clones(struct intel_encoder *encoder)\n{\n\tstruct drm_device *dev = encoder->base.dev;\n\tstruct intel_encoder *source_encoder;\n\tu32 possible_clones = 0;\n\n\tfor_each_intel_encoder(dev, source_encoder) {\n\t\tif (encoders_cloneable(encoder, source_encoder))\n\t\t\tpossible_clones |= drm_encoder_mask(&source_encoder->base);\n\t}\n\n\treturn possible_clones;\n}\n\nstatic u32 intel_encoder_possible_crtcs(struct intel_encoder *encoder)\n{\n\tstruct drm_device *dev = encoder->base.dev;\n\tstruct intel_crtc *crtc;\n\tu32 possible_crtcs = 0;\n\n\tfor_each_intel_crtc_in_pipe_mask(dev, crtc, encoder->pipe_mask)\n\t\tpossible_crtcs |= drm_crtc_mask(&crtc->base);\n\n\treturn possible_crtcs;\n}\n\nstatic bool ilk_has_edp_a(struct drm_i915_private *dev_priv)\n{\n\tif (!IS_MOBILE(dev_priv))\n\t\treturn false;\n\n\tif ((intel_de_read(dev_priv, DP_A) & DP_DETECTED) == 0)\n\t\treturn false;\n\n\tif (IS_IRONLAKE(dev_priv) && (intel_de_read(dev_priv, FUSE_STRAP) & ILK_eDP_A_DISABLE))\n\t\treturn false;\n\n\treturn true;\n}\n\nstatic bool intel_ddi_crt_present(struct drm_i915_private *dev_priv)\n{\n\tif (DISPLAY_VER(dev_priv) >= 9)\n\t\treturn false;\n\n\tif (IS_HASWELL_ULT(dev_priv) || IS_BROADWELL_ULT(dev_priv))\n\t\treturn false;\n\n\tif (HAS_PCH_LPT_H(dev_priv) &&\n\t    intel_de_read(dev_priv, SFUSE_STRAP) & SFUSE_STRAP_CRT_DISABLED)\n\t\treturn false;\n\n\t \n\tif (intel_de_read(dev_priv, DDI_BUF_CTL(PORT_A)) & DDI_A_4_LANES)\n\t\treturn false;\n\n\tif (!dev_priv->display.vbt.int_crt_support)\n\t\treturn false;\n\n\treturn true;\n}\n\nbool assert_port_valid(struct drm_i915_private *i915, enum port port)\n{\n\treturn !drm_WARN(&i915->drm, !(DISPLAY_RUNTIME_INFO(i915)->port_mask & BIT(port)),\n\t\t\t \"Platform does not support port %c\\n\", port_name(port));\n}\n\nvoid intel_setup_outputs(struct drm_i915_private *dev_priv)\n{\n\tstruct intel_encoder *encoder;\n\tbool dpd_is_edp = false;\n\n\tintel_pps_unlock_regs_wa(dev_priv);\n\n\tif (!HAS_DISPLAY(dev_priv))\n\t\treturn;\n\n\tif (HAS_DDI(dev_priv)) {\n\t\tif (intel_ddi_crt_present(dev_priv))\n\t\t\tintel_crt_init(dev_priv);\n\n\t\tintel_bios_for_each_encoder(dev_priv, intel_ddi_init);\n\n\t\tif (IS_GEMINILAKE(dev_priv) || IS_BROXTON(dev_priv))\n\t\t\tvlv_dsi_init(dev_priv);\n\t} else if (HAS_PCH_SPLIT(dev_priv)) {\n\t\tint found;\n\n\t\t \n\t\tintel_lvds_init(dev_priv);\n\t\tintel_crt_init(dev_priv);\n\n\t\tdpd_is_edp = intel_dp_is_port_edp(dev_priv, PORT_D);\n\n\t\tif (ilk_has_edp_a(dev_priv))\n\t\t\tg4x_dp_init(dev_priv, DP_A, PORT_A);\n\n\t\tif (intel_de_read(dev_priv, PCH_HDMIB) & SDVO_DETECTED) {\n\t\t\t \n\t\t\tfound = intel_sdvo_init(dev_priv, PCH_SDVOB, PORT_B);\n\t\t\tif (!found)\n\t\t\t\tg4x_hdmi_init(dev_priv, PCH_HDMIB, PORT_B);\n\t\t\tif (!found && (intel_de_read(dev_priv, PCH_DP_B) & DP_DETECTED))\n\t\t\t\tg4x_dp_init(dev_priv, PCH_DP_B, PORT_B);\n\t\t}\n\n\t\tif (intel_de_read(dev_priv, PCH_HDMIC) & SDVO_DETECTED)\n\t\t\tg4x_hdmi_init(dev_priv, PCH_HDMIC, PORT_C);\n\n\t\tif (!dpd_is_edp && intel_de_read(dev_priv, PCH_HDMID) & SDVO_DETECTED)\n\t\t\tg4x_hdmi_init(dev_priv, PCH_HDMID, PORT_D);\n\n\t\tif (intel_de_read(dev_priv, PCH_DP_C) & DP_DETECTED)\n\t\t\tg4x_dp_init(dev_priv, PCH_DP_C, PORT_C);\n\n\t\tif (intel_de_read(dev_priv, PCH_DP_D) & DP_DETECTED)\n\t\t\tg4x_dp_init(dev_priv, PCH_DP_D, PORT_D);\n\t} else if (IS_VALLEYVIEW(dev_priv) || IS_CHERRYVIEW(dev_priv)) {\n\t\tbool has_edp, has_port;\n\n\t\tif (IS_VALLEYVIEW(dev_priv) && dev_priv->display.vbt.int_crt_support)\n\t\t\tintel_crt_init(dev_priv);\n\n\t\t \n\t\thas_edp = intel_dp_is_port_edp(dev_priv, PORT_B);\n\t\thas_port = intel_bios_is_port_present(dev_priv, PORT_B);\n\t\tif (intel_de_read(dev_priv, VLV_DP_B) & DP_DETECTED || has_port)\n\t\t\thas_edp &= g4x_dp_init(dev_priv, VLV_DP_B, PORT_B);\n\t\tif ((intel_de_read(dev_priv, VLV_HDMIB) & SDVO_DETECTED || has_port) && !has_edp)\n\t\t\tg4x_hdmi_init(dev_priv, VLV_HDMIB, PORT_B);\n\n\t\thas_edp = intel_dp_is_port_edp(dev_priv, PORT_C);\n\t\thas_port = intel_bios_is_port_present(dev_priv, PORT_C);\n\t\tif (intel_de_read(dev_priv, VLV_DP_C) & DP_DETECTED || has_port)\n\t\t\thas_edp &= g4x_dp_init(dev_priv, VLV_DP_C, PORT_C);\n\t\tif ((intel_de_read(dev_priv, VLV_HDMIC) & SDVO_DETECTED || has_port) && !has_edp)\n\t\t\tg4x_hdmi_init(dev_priv, VLV_HDMIC, PORT_C);\n\n\t\tif (IS_CHERRYVIEW(dev_priv)) {\n\t\t\t \n\t\t\thas_port = intel_bios_is_port_present(dev_priv, PORT_D);\n\t\t\tif (intel_de_read(dev_priv, CHV_DP_D) & DP_DETECTED || has_port)\n\t\t\t\tg4x_dp_init(dev_priv, CHV_DP_D, PORT_D);\n\t\t\tif (intel_de_read(dev_priv, CHV_HDMID) & SDVO_DETECTED || has_port)\n\t\t\t\tg4x_hdmi_init(dev_priv, CHV_HDMID, PORT_D);\n\t\t}\n\n\t\tvlv_dsi_init(dev_priv);\n\t} else if (IS_PINEVIEW(dev_priv)) {\n\t\tintel_lvds_init(dev_priv);\n\t\tintel_crt_init(dev_priv);\n\t} else if (IS_DISPLAY_VER(dev_priv, 3, 4)) {\n\t\tbool found = false;\n\n\t\tif (IS_MOBILE(dev_priv))\n\t\t\tintel_lvds_init(dev_priv);\n\n\t\tintel_crt_init(dev_priv);\n\n\t\tif (intel_de_read(dev_priv, GEN3_SDVOB) & SDVO_DETECTED) {\n\t\t\tdrm_dbg_kms(&dev_priv->drm, \"probing SDVOB\\n\");\n\t\t\tfound = intel_sdvo_init(dev_priv, GEN3_SDVOB, PORT_B);\n\t\t\tif (!found && IS_G4X(dev_priv)) {\n\t\t\t\tdrm_dbg_kms(&dev_priv->drm,\n\t\t\t\t\t    \"probing HDMI on SDVOB\\n\");\n\t\t\t\tg4x_hdmi_init(dev_priv, GEN4_HDMIB, PORT_B);\n\t\t\t}\n\n\t\t\tif (!found && IS_G4X(dev_priv))\n\t\t\t\tg4x_dp_init(dev_priv, DP_B, PORT_B);\n\t\t}\n\n\t\t \n\n\t\tif (intel_de_read(dev_priv, GEN3_SDVOB) & SDVO_DETECTED) {\n\t\t\tdrm_dbg_kms(&dev_priv->drm, \"probing SDVOC\\n\");\n\t\t\tfound = intel_sdvo_init(dev_priv, GEN3_SDVOC, PORT_C);\n\t\t}\n\n\t\tif (!found && (intel_de_read(dev_priv, GEN3_SDVOC) & SDVO_DETECTED)) {\n\n\t\t\tif (IS_G4X(dev_priv)) {\n\t\t\t\tdrm_dbg_kms(&dev_priv->drm,\n\t\t\t\t\t    \"probing HDMI on SDVOC\\n\");\n\t\t\t\tg4x_hdmi_init(dev_priv, GEN4_HDMIC, PORT_C);\n\t\t\t}\n\t\t\tif (IS_G4X(dev_priv))\n\t\t\t\tg4x_dp_init(dev_priv, DP_C, PORT_C);\n\t\t}\n\n\t\tif (IS_G4X(dev_priv) && (intel_de_read(dev_priv, DP_D) & DP_DETECTED))\n\t\t\tg4x_dp_init(dev_priv, DP_D, PORT_D);\n\n\t\tif (SUPPORTS_TV(dev_priv))\n\t\t\tintel_tv_init(dev_priv);\n\t} else if (DISPLAY_VER(dev_priv) == 2) {\n\t\tif (IS_I85X(dev_priv))\n\t\t\tintel_lvds_init(dev_priv);\n\n\t\tintel_crt_init(dev_priv);\n\t\tintel_dvo_init(dev_priv);\n\t}\n\n\tfor_each_intel_encoder(&dev_priv->drm, encoder) {\n\t\tencoder->base.possible_crtcs =\n\t\t\tintel_encoder_possible_crtcs(encoder);\n\t\tencoder->base.possible_clones =\n\t\t\tintel_encoder_possible_clones(encoder);\n\t}\n\n\tintel_init_pch_refclk(dev_priv);\n\n\tdrm_helper_move_panel_connectors_to_head(&dev_priv->drm);\n}\n\nstatic int max_dotclock(struct drm_i915_private *i915)\n{\n\tint max_dotclock = i915->max_dotclk_freq;\n\n\t \n\tif (DISPLAY_VER(i915) >= 11)\n\t\tmax_dotclock *= 2;\n\n\treturn max_dotclock;\n}\n\nenum drm_mode_status intel_mode_valid(struct drm_device *dev,\n\t\t\t\t      const struct drm_display_mode *mode)\n{\n\tstruct drm_i915_private *dev_priv = to_i915(dev);\n\tint hdisplay_max, htotal_max;\n\tint vdisplay_max, vtotal_max;\n\n\t \n\n\tif (mode->vscan > 1)\n\t\treturn MODE_NO_VSCAN;\n\n\tif (mode->flags & DRM_MODE_FLAG_HSKEW)\n\t\treturn MODE_H_ILLEGAL;\n\n\tif (mode->flags & (DRM_MODE_FLAG_CSYNC |\n\t\t\t   DRM_MODE_FLAG_NCSYNC |\n\t\t\t   DRM_MODE_FLAG_PCSYNC))\n\t\treturn MODE_HSYNC;\n\n\tif (mode->flags & (DRM_MODE_FLAG_BCAST |\n\t\t\t   DRM_MODE_FLAG_PIXMUX |\n\t\t\t   DRM_MODE_FLAG_CLKDIV2))\n\t\treturn MODE_BAD;\n\n\t \n\tif (mode->clock > max_dotclock(dev_priv))\n\t\treturn MODE_CLOCK_HIGH;\n\n\t \n\tif (DISPLAY_VER(dev_priv) >= 11) {\n\t\thdisplay_max = 16384;\n\t\tvdisplay_max = 8192;\n\t\thtotal_max = 16384;\n\t\tvtotal_max = 8192;\n\t} else if (DISPLAY_VER(dev_priv) >= 9 ||\n\t\t   IS_BROADWELL(dev_priv) || IS_HASWELL(dev_priv)) {\n\t\thdisplay_max = 8192;  \n\t\tvdisplay_max = 4096;\n\t\thtotal_max = 8192;\n\t\tvtotal_max = 8192;\n\t} else if (DISPLAY_VER(dev_priv) >= 3) {\n\t\thdisplay_max = 4096;\n\t\tvdisplay_max = 4096;\n\t\thtotal_max = 8192;\n\t\tvtotal_max = 8192;\n\t} else {\n\t\thdisplay_max = 2048;\n\t\tvdisplay_max = 2048;\n\t\thtotal_max = 4096;\n\t\tvtotal_max = 4096;\n\t}\n\n\tif (mode->hdisplay > hdisplay_max ||\n\t    mode->hsync_start > htotal_max ||\n\t    mode->hsync_end > htotal_max ||\n\t    mode->htotal > htotal_max)\n\t\treturn MODE_H_ILLEGAL;\n\n\tif (mode->vdisplay > vdisplay_max ||\n\t    mode->vsync_start > vtotal_max ||\n\t    mode->vsync_end > vtotal_max ||\n\t    mode->vtotal > vtotal_max)\n\t\treturn MODE_V_ILLEGAL;\n\n\treturn MODE_OK;\n}\n\nenum drm_mode_status intel_cpu_transcoder_mode_valid(struct drm_i915_private *dev_priv,\n\t\t\t\t\t\t     const struct drm_display_mode *mode)\n{\n\t \n\tif (DISPLAY_VER(dev_priv) >= 5) {\n\t\tif (mode->hdisplay < 64 ||\n\t\t    mode->htotal - mode->hdisplay < 32)\n\t\t\treturn MODE_H_ILLEGAL;\n\n\t\tif (mode->vtotal - mode->vdisplay < 5)\n\t\t\treturn MODE_V_ILLEGAL;\n\t} else {\n\t\tif (mode->htotal - mode->hdisplay < 32)\n\t\t\treturn MODE_H_ILLEGAL;\n\n\t\tif (mode->vtotal - mode->vdisplay < 3)\n\t\t\treturn MODE_V_ILLEGAL;\n\t}\n\n\t \n\tif ((DISPLAY_VER(dev_priv) > 4 || IS_G4X(dev_priv)) &&\n\t    mode->hsync_start == mode->hdisplay)\n\t\treturn MODE_H_ILLEGAL;\n\n\treturn MODE_OK;\n}\n\nenum drm_mode_status\nintel_mode_valid_max_plane_size(struct drm_i915_private *dev_priv,\n\t\t\t\tconst struct drm_display_mode *mode,\n\t\t\t\tbool bigjoiner)\n{\n\tint plane_width_max, plane_height_max;\n\n\t \n\tif (DISPLAY_VER(dev_priv) < 9)\n\t\treturn MODE_OK;\n\n\t \n\tif (DISPLAY_VER(dev_priv) >= 11) {\n\t\tplane_width_max = 5120 << bigjoiner;\n\t\tplane_height_max = 4320;\n\t} else {\n\t\tplane_width_max = 5120;\n\t\tplane_height_max = 4096;\n\t}\n\n\tif (mode->hdisplay > plane_width_max)\n\t\treturn MODE_H_ILLEGAL;\n\n\tif (mode->vdisplay > plane_height_max)\n\t\treturn MODE_V_ILLEGAL;\n\n\treturn MODE_OK;\n}\n\nstatic const struct intel_display_funcs skl_display_funcs = {\n\t.get_pipe_config = hsw_get_pipe_config,\n\t.crtc_enable = hsw_crtc_enable,\n\t.crtc_disable = hsw_crtc_disable,\n\t.commit_modeset_enables = skl_commit_modeset_enables,\n\t.get_initial_plane_config = skl_get_initial_plane_config,\n};\n\nstatic const struct intel_display_funcs ddi_display_funcs = {\n\t.get_pipe_config = hsw_get_pipe_config,\n\t.crtc_enable = hsw_crtc_enable,\n\t.crtc_disable = hsw_crtc_disable,\n\t.commit_modeset_enables = intel_commit_modeset_enables,\n\t.get_initial_plane_config = i9xx_get_initial_plane_config,\n};\n\nstatic const struct intel_display_funcs pch_split_display_funcs = {\n\t.get_pipe_config = ilk_get_pipe_config,\n\t.crtc_enable = ilk_crtc_enable,\n\t.crtc_disable = ilk_crtc_disable,\n\t.commit_modeset_enables = intel_commit_modeset_enables,\n\t.get_initial_plane_config = i9xx_get_initial_plane_config,\n};\n\nstatic const struct intel_display_funcs vlv_display_funcs = {\n\t.get_pipe_config = i9xx_get_pipe_config,\n\t.crtc_enable = valleyview_crtc_enable,\n\t.crtc_disable = i9xx_crtc_disable,\n\t.commit_modeset_enables = intel_commit_modeset_enables,\n\t.get_initial_plane_config = i9xx_get_initial_plane_config,\n};\n\nstatic const struct intel_display_funcs i9xx_display_funcs = {\n\t.get_pipe_config = i9xx_get_pipe_config,\n\t.crtc_enable = i9xx_crtc_enable,\n\t.crtc_disable = i9xx_crtc_disable,\n\t.commit_modeset_enables = intel_commit_modeset_enables,\n\t.get_initial_plane_config = i9xx_get_initial_plane_config,\n};\n\n \nvoid intel_init_display_hooks(struct drm_i915_private *dev_priv)\n{\n\tif (DISPLAY_VER(dev_priv) >= 9) {\n\t\tdev_priv->display.funcs.display = &skl_display_funcs;\n\t} else if (HAS_DDI(dev_priv)) {\n\t\tdev_priv->display.funcs.display = &ddi_display_funcs;\n\t} else if (HAS_PCH_SPLIT(dev_priv)) {\n\t\tdev_priv->display.funcs.display = &pch_split_display_funcs;\n\t} else if (IS_CHERRYVIEW(dev_priv) ||\n\t\t   IS_VALLEYVIEW(dev_priv)) {\n\t\tdev_priv->display.funcs.display = &vlv_display_funcs;\n\t} else {\n\t\tdev_priv->display.funcs.display = &i9xx_display_funcs;\n\t}\n}\n\nint intel_initial_commit(struct drm_device *dev)\n{\n\tstruct drm_atomic_state *state = NULL;\n\tstruct drm_modeset_acquire_ctx ctx;\n\tstruct intel_crtc *crtc;\n\tint ret = 0;\n\n\tstate = drm_atomic_state_alloc(dev);\n\tif (!state)\n\t\treturn -ENOMEM;\n\n\tdrm_modeset_acquire_init(&ctx, 0);\n\n\tstate->acquire_ctx = &ctx;\n\tto_intel_atomic_state(state)->internal = true;\n\nretry:\n\tfor_each_intel_crtc(dev, crtc) {\n\t\tstruct intel_crtc_state *crtc_state =\n\t\t\tintel_atomic_get_crtc_state(state, crtc);\n\n\t\tif (IS_ERR(crtc_state)) {\n\t\t\tret = PTR_ERR(crtc_state);\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (crtc_state->hw.active) {\n\t\t\tstruct intel_encoder *encoder;\n\n\t\t\tret = drm_atomic_add_affected_planes(state, &crtc->base);\n\t\t\tif (ret)\n\t\t\t\tgoto out;\n\n\t\t\t \n\t\t\tcrtc_state->uapi.color_mgmt_changed = true;\n\n\t\t\tfor_each_intel_encoder_mask(dev, encoder,\n\t\t\t\t\t\t    crtc_state->uapi.encoder_mask) {\n\t\t\t\tif (encoder->initial_fastset_check &&\n\t\t\t\t    !encoder->initial_fastset_check(encoder, crtc_state)) {\n\t\t\t\t\tret = drm_atomic_add_affected_connectors(state,\n\t\t\t\t\t\t\t\t\t\t &crtc->base);\n\t\t\t\t\tif (ret)\n\t\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tret = drm_atomic_commit(state);\n\nout:\n\tif (ret == -EDEADLK) {\n\t\tdrm_atomic_state_clear(state);\n\t\tdrm_modeset_backoff(&ctx);\n\t\tgoto retry;\n\t}\n\n\tdrm_atomic_state_put(state);\n\n\tdrm_modeset_drop_locks(&ctx);\n\tdrm_modeset_acquire_fini(&ctx);\n\n\treturn ret;\n}\n\nvoid i830_enable_pipe(struct drm_i915_private *dev_priv, enum pipe pipe)\n{\n\tstruct intel_crtc *crtc = intel_crtc_for_pipe(dev_priv, pipe);\n\tenum transcoder cpu_transcoder = (enum transcoder)pipe;\n\t \n\tstruct dpll clock = {\n\t\t.m1 = 18,\n\t\t.m2 = 7,\n\t\t.p1 = 13,\n\t\t.p2 = 4,\n\t\t.n = 2,\n\t};\n\tu32 dpll, fp;\n\tint i;\n\n\tdrm_WARN_ON(&dev_priv->drm,\n\t\t    i9xx_calc_dpll_params(48000, &clock) != 25154);\n\n\tdrm_dbg_kms(&dev_priv->drm,\n\t\t    \"enabling pipe %c due to force quirk (vco=%d dot=%d)\\n\",\n\t\t    pipe_name(pipe), clock.vco, clock.dot);\n\n\tfp = i9xx_dpll_compute_fp(&clock);\n\tdpll = DPLL_DVO_2X_MODE |\n\t\tDPLL_VGA_MODE_DIS |\n\t\t((clock.p1 - 2) << DPLL_FPA01_P1_POST_DIV_SHIFT) |\n\t\tPLL_P2_DIVIDE_BY_4 |\n\t\tPLL_REF_INPUT_DREFCLK |\n\t\tDPLL_VCO_ENABLE;\n\n\tintel_de_write(dev_priv, TRANS_HTOTAL(cpu_transcoder),\n\t\t       HACTIVE(640 - 1) | HTOTAL(800 - 1));\n\tintel_de_write(dev_priv, TRANS_HBLANK(cpu_transcoder),\n\t\t       HBLANK_START(640 - 1) | HBLANK_END(800 - 1));\n\tintel_de_write(dev_priv, TRANS_HSYNC(cpu_transcoder),\n\t\t       HSYNC_START(656 - 1) | HSYNC_END(752 - 1));\n\tintel_de_write(dev_priv, TRANS_VTOTAL(cpu_transcoder),\n\t\t       VACTIVE(480 - 1) | VTOTAL(525 - 1));\n\tintel_de_write(dev_priv, TRANS_VBLANK(cpu_transcoder),\n\t\t       VBLANK_START(480 - 1) | VBLANK_END(525 - 1));\n\tintel_de_write(dev_priv, TRANS_VSYNC(cpu_transcoder),\n\t\t       VSYNC_START(490 - 1) | VSYNC_END(492 - 1));\n\tintel_de_write(dev_priv, PIPESRC(pipe),\n\t\t       PIPESRC_WIDTH(640 - 1) | PIPESRC_HEIGHT(480 - 1));\n\n\tintel_de_write(dev_priv, FP0(pipe), fp);\n\tintel_de_write(dev_priv, FP1(pipe), fp);\n\n\t \n\tintel_de_write(dev_priv, DPLL(pipe), dpll & ~DPLL_VGA_MODE_DIS);\n\tintel_de_write(dev_priv, DPLL(pipe), dpll);\n\n\t \n\tintel_de_posting_read(dev_priv, DPLL(pipe));\n\tudelay(150);\n\n\t \n\tintel_de_write(dev_priv, DPLL(pipe), dpll);\n\n\t \n\tfor (i = 0; i < 3 ; i++) {\n\t\tintel_de_write(dev_priv, DPLL(pipe), dpll);\n\t\tintel_de_posting_read(dev_priv, DPLL(pipe));\n\t\tudelay(150);  \n\t}\n\n\tintel_de_write(dev_priv, TRANSCONF(pipe), TRANSCONF_ENABLE);\n\tintel_de_posting_read(dev_priv, TRANSCONF(pipe));\n\n\tintel_wait_for_pipe_scanline_moving(crtc);\n}\n\nvoid i830_disable_pipe(struct drm_i915_private *dev_priv, enum pipe pipe)\n{\n\tstruct intel_crtc *crtc = intel_crtc_for_pipe(dev_priv, pipe);\n\n\tdrm_dbg_kms(&dev_priv->drm, \"disabling pipe %c due to force quirk\\n\",\n\t\t    pipe_name(pipe));\n\n\tdrm_WARN_ON(&dev_priv->drm,\n\t\t    intel_de_read(dev_priv, DSPCNTR(PLANE_A)) & DISP_ENABLE);\n\tdrm_WARN_ON(&dev_priv->drm,\n\t\t    intel_de_read(dev_priv, DSPCNTR(PLANE_B)) & DISP_ENABLE);\n\tdrm_WARN_ON(&dev_priv->drm,\n\t\t    intel_de_read(dev_priv, DSPCNTR(PLANE_C)) & DISP_ENABLE);\n\tdrm_WARN_ON(&dev_priv->drm,\n\t\t    intel_de_read(dev_priv, CURCNTR(PIPE_A)) & MCURSOR_MODE_MASK);\n\tdrm_WARN_ON(&dev_priv->drm,\n\t\t    intel_de_read(dev_priv, CURCNTR(PIPE_B)) & MCURSOR_MODE_MASK);\n\n\tintel_de_write(dev_priv, TRANSCONF(pipe), 0);\n\tintel_de_posting_read(dev_priv, TRANSCONF(pipe));\n\n\tintel_wait_for_pipe_scanline_stopped(crtc);\n\n\tintel_de_write(dev_priv, DPLL(pipe), DPLL_VGA_MODE_DIS);\n\tintel_de_posting_read(dev_priv, DPLL(pipe));\n}\n\nvoid intel_hpd_poll_fini(struct drm_i915_private *i915)\n{\n\tstruct intel_connector *connector;\n\tstruct drm_connector_list_iter conn_iter;\n\n\t \n\tdrm_connector_list_iter_begin(&i915->drm, &conn_iter);\n\tfor_each_intel_connector_iter(connector, &conn_iter) {\n\t\tif (connector->modeset_retry_work.func)\n\t\t\tcancel_work_sync(&connector->modeset_retry_work);\n\t\tif (connector->hdcp.shim) {\n\t\t\tcancel_delayed_work_sync(&connector->hdcp.check_work);\n\t\t\tcancel_work_sync(&connector->hdcp.prop_work);\n\t\t}\n\t}\n\tdrm_connector_list_iter_end(&conn_iter);\n}\n\nbool intel_scanout_needs_vtd_wa(struct drm_i915_private *i915)\n{\n\treturn DISPLAY_VER(i915) >= 6 && i915_vtd_active(i915);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}