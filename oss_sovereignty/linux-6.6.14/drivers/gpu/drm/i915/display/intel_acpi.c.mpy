{
  "module_name": "intel_acpi.c",
  "hash_id": "4ff5259f560f7f02ccdc9feb6bb257d07d2082b702094f8d3ed1434412ea4a0e",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/i915/display/intel_acpi.c",
  "human_readable_source": "\n \n\n#include <linux/pci.h>\n#include <linux/acpi.h>\n#include <acpi/video.h>\n\n#include \"i915_drv.h\"\n#include \"intel_acpi.h\"\n#include \"intel_display_types.h\"\n\n#define INTEL_DSM_REVISION_ID 1  \n#define INTEL_DSM_FN_PLATFORM_MUX_INFO 1  \n\nstatic const guid_t intel_dsm_guid =\n\tGUID_INIT(0x7ed873d3, 0xc2d0, 0x4e4f,\n\t\t  0xa8, 0x54, 0x0f, 0x13, 0x17, 0xb0, 0x1c, 0x2c);\n\n#define INTEL_DSM_FN_GET_BIOS_DATA_FUNCS_SUPPORTED 0  \n\nstatic const guid_t intel_dsm_guid2 =\n\tGUID_INIT(0x3e5b41c6, 0xeb1d, 0x4260,\n\t\t  0x9d, 0x15, 0xc7, 0x1f, 0xba, 0xda, 0xe4, 0x14);\n\nstatic char *intel_dsm_port_name(u8 id)\n{\n\tswitch (id) {\n\tcase 0:\n\t\treturn \"Reserved\";\n\tcase 1:\n\t\treturn \"Analog VGA\";\n\tcase 2:\n\t\treturn \"LVDS\";\n\tcase 3:\n\t\treturn \"Reserved\";\n\tcase 4:\n\t\treturn \"HDMI/DVI_B\";\n\tcase 5:\n\t\treturn \"HDMI/DVI_C\";\n\tcase 6:\n\t\treturn \"HDMI/DVI_D\";\n\tcase 7:\n\t\treturn \"DisplayPort_A\";\n\tcase 8:\n\t\treturn \"DisplayPort_B\";\n\tcase 9:\n\t\treturn \"DisplayPort_C\";\n\tcase 0xa:\n\t\treturn \"DisplayPort_D\";\n\tcase 0xb:\n\tcase 0xc:\n\tcase 0xd:\n\t\treturn \"Reserved\";\n\tcase 0xe:\n\t\treturn \"WiDi\";\n\tdefault:\n\t\treturn \"bad type\";\n\t}\n}\n\nstatic char *intel_dsm_mux_type(u8 type)\n{\n\tswitch (type) {\n\tcase 0:\n\t\treturn \"unknown\";\n\tcase 1:\n\t\treturn \"No MUX, iGPU only\";\n\tcase 2:\n\t\treturn \"No MUX, dGPU only\";\n\tcase 3:\n\t\treturn \"MUXed between iGPU and dGPU\";\n\tdefault:\n\t\treturn \"bad type\";\n\t}\n}\n\nstatic void intel_dsm_platform_mux_info(acpi_handle dhandle)\n{\n\tint i;\n\tunion acpi_object *pkg, *connector_count;\n\n\tpkg = acpi_evaluate_dsm_typed(dhandle, &intel_dsm_guid,\n\t\t\tINTEL_DSM_REVISION_ID, INTEL_DSM_FN_PLATFORM_MUX_INFO,\n\t\t\tNULL, ACPI_TYPE_PACKAGE);\n\tif (!pkg) {\n\t\tDRM_DEBUG_DRIVER(\"failed to evaluate _DSM\\n\");\n\t\treturn;\n\t}\n\n\tif (!pkg->package.count) {\n\t\tDRM_DEBUG_DRIVER(\"no connection in _DSM\\n\");\n\t\treturn;\n\t}\n\n\tconnector_count = &pkg->package.elements[0];\n\tDRM_DEBUG_DRIVER(\"MUX info connectors: %lld\\n\",\n\t\t  (unsigned long long)connector_count->integer.value);\n\tfor (i = 1; i < pkg->package.count; i++) {\n\t\tunion acpi_object *obj = &pkg->package.elements[i];\n\t\tunion acpi_object *connector_id;\n\t\tunion acpi_object *info;\n\n\t\tif (obj->type != ACPI_TYPE_PACKAGE || obj->package.count < 2) {\n\t\t\tDRM_DEBUG_DRIVER(\"Invalid object for MUX #%d\\n\", i);\n\t\t\tcontinue;\n\t\t}\n\n\t\tconnector_id = &obj->package.elements[0];\n\t\tinfo = &obj->package.elements[1];\n\t\tif (info->type != ACPI_TYPE_BUFFER || info->buffer.length < 4) {\n\t\t\tDRM_DEBUG_DRIVER(\"Invalid info for MUX obj #%d\\n\", i);\n\t\t\tcontinue;\n\t\t}\n\n\t\tDRM_DEBUG_DRIVER(\"Connector id: 0x%016llx\\n\",\n\t\t\t  (unsigned long long)connector_id->integer.value);\n\t\tDRM_DEBUG_DRIVER(\"  port id: %s\\n\",\n\t\t       intel_dsm_port_name(info->buffer.pointer[0]));\n\t\tDRM_DEBUG_DRIVER(\"  display mux info: %s\\n\",\n\t\t       intel_dsm_mux_type(info->buffer.pointer[1]));\n\t\tDRM_DEBUG_DRIVER(\"  aux/dc mux info: %s\\n\",\n\t\t       intel_dsm_mux_type(info->buffer.pointer[2]));\n\t\tDRM_DEBUG_DRIVER(\"  hpd mux info: %s\\n\",\n\t\t       intel_dsm_mux_type(info->buffer.pointer[3]));\n\t}\n\n\tACPI_FREE(pkg);\n}\n\nstatic acpi_handle intel_dsm_pci_probe(struct pci_dev *pdev)\n{\n\tacpi_handle dhandle;\n\n\tdhandle = ACPI_HANDLE(&pdev->dev);\n\tif (!dhandle)\n\t\treturn NULL;\n\n\tif (!acpi_check_dsm(dhandle, &intel_dsm_guid, INTEL_DSM_REVISION_ID,\n\t\t\t    1 << INTEL_DSM_FN_PLATFORM_MUX_INFO)) {\n\t\tDRM_DEBUG_KMS(\"no _DSM method for intel device\\n\");\n\t\treturn NULL;\n\t}\n\n\tintel_dsm_platform_mux_info(dhandle);\n\n\treturn dhandle;\n}\n\nstatic bool intel_dsm_detect(void)\n{\n\tacpi_handle dhandle = NULL;\n\tchar acpi_method_name[255] = { 0 };\n\tstruct acpi_buffer buffer = {sizeof(acpi_method_name), acpi_method_name};\n\tstruct pci_dev *pdev = NULL;\n\tint vga_count = 0;\n\n\twhile ((pdev = pci_get_class(PCI_CLASS_DISPLAY_VGA << 8, pdev)) != NULL) {\n\t\tvga_count++;\n\t\tdhandle = intel_dsm_pci_probe(pdev) ?: dhandle;\n\t}\n\n\tif (vga_count == 2 && dhandle) {\n\t\tacpi_get_name(dhandle, ACPI_FULL_PATHNAME, &buffer);\n\t\tDRM_DEBUG_DRIVER(\"vga_switcheroo: detected DSM switching method %s handle\\n\",\n\t\t\t\t acpi_method_name);\n\t\treturn true;\n\t}\n\n\treturn false;\n}\n\nvoid intel_register_dsm_handler(void)\n{\n\tif (!intel_dsm_detect())\n\t\treturn;\n}\n\nvoid intel_unregister_dsm_handler(void)\n{\n}\n\nvoid intel_dsm_get_bios_data_funcs_supported(struct drm_i915_private *i915)\n{\n\tstruct pci_dev *pdev = to_pci_dev(i915->drm.dev);\n\tacpi_handle dhandle;\n\tunion acpi_object *obj;\n\n\tdhandle = ACPI_HANDLE(&pdev->dev);\n\tif (!dhandle)\n\t\treturn;\n\n\tobj = acpi_evaluate_dsm(dhandle, &intel_dsm_guid2, INTEL_DSM_REVISION_ID,\n\t\t\t\tINTEL_DSM_FN_GET_BIOS_DATA_FUNCS_SUPPORTED, NULL);\n\tif (obj)\n\t\tACPI_FREE(obj);\n}\n\n \n#define ACPI_DISPLAY_INDEX_SHIFT\t\t0\n#define ACPI_DISPLAY_INDEX_MASK\t\t\t(0xf << 0)\n#define ACPI_DISPLAY_PORT_ATTACHMENT_SHIFT\t4\n#define ACPI_DISPLAY_PORT_ATTACHMENT_MASK\t(0xf << 4)\n#define ACPI_DISPLAY_TYPE_SHIFT\t\t\t8\n#define ACPI_DISPLAY_TYPE_MASK\t\t\t(0xf << 8)\n#define ACPI_DISPLAY_TYPE_OTHER\t\t\t(0 << 8)\n#define ACPI_DISPLAY_TYPE_VGA\t\t\t(1 << 8)\n#define ACPI_DISPLAY_TYPE_TV\t\t\t(2 << 8)\n#define ACPI_DISPLAY_TYPE_EXTERNAL_DIGITAL\t(3 << 8)\n#define ACPI_DISPLAY_TYPE_INTERNAL_DIGITAL\t(4 << 8)\n#define ACPI_VENDOR_SPECIFIC_SHIFT\t\t12\n#define ACPI_VENDOR_SPECIFIC_MASK\t\t(0xf << 12)\n#define ACPI_BIOS_CAN_DETECT\t\t\t(1 << 16)\n#define ACPI_DEPENDS_ON_VGA\t\t\t(1 << 17)\n#define ACPI_PIPE_ID_SHIFT\t\t\t18\n#define ACPI_PIPE_ID_MASK\t\t\t(7 << 18)\n#define ACPI_DEVICE_ID_SCHEME\t\t\t(1ULL << 31)\n\nstatic u32 acpi_display_type(struct intel_connector *connector)\n{\n\tu32 display_type;\n\n\tswitch (connector->base.connector_type) {\n\tcase DRM_MODE_CONNECTOR_VGA:\n\tcase DRM_MODE_CONNECTOR_DVIA:\n\t\tdisplay_type = ACPI_DISPLAY_TYPE_VGA;\n\t\tbreak;\n\tcase DRM_MODE_CONNECTOR_Composite:\n\tcase DRM_MODE_CONNECTOR_SVIDEO:\n\tcase DRM_MODE_CONNECTOR_Component:\n\tcase DRM_MODE_CONNECTOR_9PinDIN:\n\tcase DRM_MODE_CONNECTOR_TV:\n\t\tdisplay_type = ACPI_DISPLAY_TYPE_TV;\n\t\tbreak;\n\tcase DRM_MODE_CONNECTOR_DVII:\n\tcase DRM_MODE_CONNECTOR_DVID:\n\tcase DRM_MODE_CONNECTOR_DisplayPort:\n\tcase DRM_MODE_CONNECTOR_HDMIA:\n\tcase DRM_MODE_CONNECTOR_HDMIB:\n\t\tdisplay_type = ACPI_DISPLAY_TYPE_EXTERNAL_DIGITAL;\n\t\tbreak;\n\tcase DRM_MODE_CONNECTOR_LVDS:\n\tcase DRM_MODE_CONNECTOR_eDP:\n\tcase DRM_MODE_CONNECTOR_DSI:\n\t\tdisplay_type = ACPI_DISPLAY_TYPE_INTERNAL_DIGITAL;\n\t\tbreak;\n\tcase DRM_MODE_CONNECTOR_Unknown:\n\tcase DRM_MODE_CONNECTOR_VIRTUAL:\n\t\tdisplay_type = ACPI_DISPLAY_TYPE_OTHER;\n\t\tbreak;\n\tdefault:\n\t\tMISSING_CASE(connector->base.connector_type);\n\t\tdisplay_type = ACPI_DISPLAY_TYPE_OTHER;\n\t\tbreak;\n\t}\n\n\treturn display_type;\n}\n\nvoid intel_acpi_device_id_update(struct drm_i915_private *dev_priv)\n{\n\tstruct drm_device *drm_dev = &dev_priv->drm;\n\tstruct intel_connector *connector;\n\tstruct drm_connector_list_iter conn_iter;\n\tu8 display_index[16] = {};\n\n\t \n\tdrm_connector_list_iter_begin(drm_dev, &conn_iter);\n\tfor_each_intel_connector_iter(connector, &conn_iter) {\n\t\tu32 device_id, type;\n\n\t\tdevice_id = acpi_display_type(connector);\n\n\t\t \n\t\ttype = (device_id & ACPI_DISPLAY_TYPE_MASK)\n\t\t\t>> ACPI_DISPLAY_TYPE_SHIFT;\n\t\tdevice_id |= display_index[type]++ << ACPI_DISPLAY_INDEX_SHIFT;\n\n\t\tconnector->acpi_device_id = device_id;\n\t}\n\tdrm_connector_list_iter_end(&conn_iter);\n}\n\n \nvoid intel_acpi_assign_connector_fwnodes(struct drm_i915_private *i915)\n{\n\tstruct drm_connector_list_iter conn_iter;\n\tstruct drm_device *drm_dev = &i915->drm;\n\tstruct fwnode_handle *fwnode = NULL;\n\tstruct drm_connector *connector;\n\tstruct acpi_device *adev;\n\n\tdrm_connector_list_iter_begin(drm_dev, &conn_iter);\n\tdrm_for_each_connector_iter(connector, &conn_iter) {\n\t\t \n\t\tfwnode = device_get_next_child_node(drm_dev->dev, fwnode);\n\t\tif (!fwnode)\n\t\t\tbreak;\n\n\t\tswitch (connector->connector_type) {\n\t\tcase DRM_MODE_CONNECTOR_LVDS:\n\t\tcase DRM_MODE_CONNECTOR_eDP:\n\t\tcase DRM_MODE_CONNECTOR_DSI:\n\t\t\t \n\t\t\tadev = acpi_find_child_device(ACPI_COMPANION(drm_dev->dev),\n\t\t\t\t\t\t      0x1f, 0);\n\t\t\tif (adev) {\n\t\t\t\tconnector->fwnode =\n\t\t\t\t\tfwnode_handle_get(acpi_fwnode_handle(adev));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tfallthrough;\n\t\tdefault:\n\t\t\tconnector->fwnode = fwnode_handle_get(fwnode);\n\t\t\tbreak;\n\t\t}\n\t}\n\tdrm_connector_list_iter_end(&conn_iter);\n\t \n\tfwnode_handle_put(fwnode);\n}\n\nvoid intel_acpi_video_register(struct drm_i915_private *i915)\n{\n\tstruct drm_connector_list_iter conn_iter;\n\tstruct drm_connector *connector;\n\n\tacpi_video_register();\n\n\t \n\tdrm_connector_list_iter_begin(&i915->drm, &conn_iter);\n\tdrm_for_each_connector_iter(connector, &conn_iter) {\n\t\tstruct intel_panel *panel = &to_intel_connector(connector)->panel;\n\n\t\tif (panel->backlight.funcs && !panel->backlight.device) {\n\t\t\tacpi_video_register_backlight();\n\t\t\tbreak;\n\t\t}\n\t}\n\tdrm_connector_list_iter_end(&conn_iter);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}