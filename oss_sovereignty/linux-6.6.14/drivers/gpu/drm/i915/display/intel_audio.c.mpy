{
  "module_name": "intel_audio.c",
  "hash_id": "89807943052c25f671543cfa4104ea86a9e16d1035773b2e50f56f4eeed81d04",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/i915/display/intel_audio.c",
  "human_readable_source": " \n\n#include <linux/component.h>\n#include <linux/kernel.h>\n\n#include <drm/drm_edid.h>\n#include <drm/i915_component.h>\n\n#include \"i915_drv.h\"\n#include \"intel_atomic.h\"\n#include \"intel_audio.h\"\n#include \"intel_audio_regs.h\"\n#include \"intel_cdclk.h\"\n#include \"intel_crtc.h\"\n#include \"intel_de.h\"\n#include \"intel_display_types.h\"\n#include \"intel_lpe_audio.h\"\n\n \n\nstruct intel_audio_funcs {\n\tvoid (*audio_codec_enable)(struct intel_encoder *encoder,\n\t\t\t\t   const struct intel_crtc_state *crtc_state,\n\t\t\t\t   const struct drm_connector_state *conn_state);\n\tvoid (*audio_codec_disable)(struct intel_encoder *encoder,\n\t\t\t\t    const struct intel_crtc_state *old_crtc_state,\n\t\t\t\t    const struct drm_connector_state *old_conn_state);\n\tvoid (*audio_codec_get_config)(struct intel_encoder *encoder,\n\t\t\t\t       struct intel_crtc_state *crtc_state);\n};\n\n \n#define LC_810M\t810000\n#define LC_540M\t540000\n#define LC_270M\t270000\n#define LC_162M\t162000\n\nstruct dp_aud_n_m {\n\tint sample_rate;\n\tint clock;\n\tu16 m;\n\tu16 n;\n};\n\nstruct hdmi_aud_ncts {\n\tint sample_rate;\n\tint clock;\n\tint n;\n\tint cts;\n};\n\n \nstatic const struct dp_aud_n_m dp_aud_n_m[] = {\n\t{ 32000, LC_162M, 1024, 10125 },\n\t{ 44100, LC_162M, 784, 5625 },\n\t{ 48000, LC_162M, 512, 3375 },\n\t{ 64000, LC_162M, 2048, 10125 },\n\t{ 88200, LC_162M, 1568, 5625 },\n\t{ 96000, LC_162M, 1024, 3375 },\n\t{ 128000, LC_162M, 4096, 10125 },\n\t{ 176400, LC_162M, 3136, 5625 },\n\t{ 192000, LC_162M, 2048, 3375 },\n\t{ 32000, LC_270M, 1024, 16875 },\n\t{ 44100, LC_270M, 784, 9375 },\n\t{ 48000, LC_270M, 512, 5625 },\n\t{ 64000, LC_270M, 2048, 16875 },\n\t{ 88200, LC_270M, 1568, 9375 },\n\t{ 96000, LC_270M, 1024, 5625 },\n\t{ 128000, LC_270M, 4096, 16875 },\n\t{ 176400, LC_270M, 3136, 9375 },\n\t{ 192000, LC_270M, 2048, 5625 },\n\t{ 32000, LC_540M, 1024, 33750 },\n\t{ 44100, LC_540M, 784, 18750 },\n\t{ 48000, LC_540M, 512, 11250 },\n\t{ 64000, LC_540M, 2048, 33750 },\n\t{ 88200, LC_540M, 1568, 18750 },\n\t{ 96000, LC_540M, 1024, 11250 },\n\t{ 128000, LC_540M, 4096, 33750 },\n\t{ 176400, LC_540M, 3136, 18750 },\n\t{ 192000, LC_540M, 2048, 11250 },\n\t{ 32000, LC_810M, 1024, 50625 },\n\t{ 44100, LC_810M, 784, 28125 },\n\t{ 48000, LC_810M, 512, 16875 },\n\t{ 64000, LC_810M, 2048, 50625 },\n\t{ 88200, LC_810M, 1568, 28125 },\n\t{ 96000, LC_810M, 1024, 16875 },\n\t{ 128000, LC_810M, 4096, 50625 },\n\t{ 176400, LC_810M, 3136, 28125 },\n\t{ 192000, LC_810M, 2048, 16875 },\n};\n\nstatic const struct dp_aud_n_m *\naudio_config_dp_get_n_m(const struct intel_crtc_state *crtc_state, int rate)\n{\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(dp_aud_n_m); i++) {\n\t\tif (rate == dp_aud_n_m[i].sample_rate &&\n\t\t    crtc_state->port_clock == dp_aud_n_m[i].clock)\n\t\t\treturn &dp_aud_n_m[i];\n\t}\n\n\treturn NULL;\n}\n\nstatic const struct {\n\tint clock;\n\tu32 config;\n} hdmi_audio_clock[] = {\n\t{ 25175, AUD_CONFIG_PIXEL_CLOCK_HDMI_25175 },\n\t{ 25200, AUD_CONFIG_PIXEL_CLOCK_HDMI_25200 },  \n\t{ 27000, AUD_CONFIG_PIXEL_CLOCK_HDMI_27000 },\n\t{ 27027, AUD_CONFIG_PIXEL_CLOCK_HDMI_27027 },\n\t{ 54000, AUD_CONFIG_PIXEL_CLOCK_HDMI_54000 },\n\t{ 54054, AUD_CONFIG_PIXEL_CLOCK_HDMI_54054 },\n\t{ 74176, AUD_CONFIG_PIXEL_CLOCK_HDMI_74176 },\n\t{ 74250, AUD_CONFIG_PIXEL_CLOCK_HDMI_74250 },\n\t{ 148352, AUD_CONFIG_PIXEL_CLOCK_HDMI_148352 },\n\t{ 148500, AUD_CONFIG_PIXEL_CLOCK_HDMI_148500 },\n\t{ 296703, AUD_CONFIG_PIXEL_CLOCK_HDMI_296703 },\n\t{ 297000, AUD_CONFIG_PIXEL_CLOCK_HDMI_297000 },\n\t{ 593407, AUD_CONFIG_PIXEL_CLOCK_HDMI_593407 },\n\t{ 594000, AUD_CONFIG_PIXEL_CLOCK_HDMI_594000 },\n};\n\n \n#define TMDS_297M 297000\n#define TMDS_296M 296703\n#define TMDS_594M 594000\n#define TMDS_593M 593407\n\nstatic const struct hdmi_aud_ncts hdmi_aud_ncts_24bpp[] = {\n\t{ 32000, TMDS_296M, 5824, 421875 },\n\t{ 32000, TMDS_297M, 3072, 222750 },\n\t{ 32000, TMDS_593M, 5824, 843750 },\n\t{ 32000, TMDS_594M, 3072, 445500 },\n\t{ 44100, TMDS_296M, 4459, 234375 },\n\t{ 44100, TMDS_297M, 4704, 247500 },\n\t{ 44100, TMDS_593M, 8918, 937500 },\n\t{ 44100, TMDS_594M, 9408, 990000 },\n\t{ 88200, TMDS_296M, 8918, 234375 },\n\t{ 88200, TMDS_297M, 9408, 247500 },\n\t{ 88200, TMDS_593M, 17836, 937500 },\n\t{ 88200, TMDS_594M, 18816, 990000 },\n\t{ 176400, TMDS_296M, 17836, 234375 },\n\t{ 176400, TMDS_297M, 18816, 247500 },\n\t{ 176400, TMDS_593M, 35672, 937500 },\n\t{ 176400, TMDS_594M, 37632, 990000 },\n\t{ 48000, TMDS_296M, 5824, 281250 },\n\t{ 48000, TMDS_297M, 5120, 247500 },\n\t{ 48000, TMDS_593M, 5824, 562500 },\n\t{ 48000, TMDS_594M, 6144, 594000 },\n\t{ 96000, TMDS_296M, 11648, 281250 },\n\t{ 96000, TMDS_297M, 10240, 247500 },\n\t{ 96000, TMDS_593M, 11648, 562500 },\n\t{ 96000, TMDS_594M, 12288, 594000 },\n\t{ 192000, TMDS_296M, 23296, 281250 },\n\t{ 192000, TMDS_297M, 20480, 247500 },\n\t{ 192000, TMDS_593M, 23296, 562500 },\n\t{ 192000, TMDS_594M, 24576, 594000 },\n};\n\n \n \n#define TMDS_371M 371250\n#define TMDS_370M 370878\n\nstatic const struct hdmi_aud_ncts hdmi_aud_ncts_30bpp[] = {\n\t{ 32000, TMDS_370M, 5824, 527344 },\n\t{ 32000, TMDS_371M, 6144, 556875 },\n\t{ 44100, TMDS_370M, 8918, 585938 },\n\t{ 44100, TMDS_371M, 4704, 309375 },\n\t{ 88200, TMDS_370M, 17836, 585938 },\n\t{ 88200, TMDS_371M, 9408, 309375 },\n\t{ 176400, TMDS_370M, 35672, 585938 },\n\t{ 176400, TMDS_371M, 18816, 309375 },\n\t{ 48000, TMDS_370M, 11648, 703125 },\n\t{ 48000, TMDS_371M, 5120, 309375 },\n\t{ 96000, TMDS_370M, 23296, 703125 },\n\t{ 96000, TMDS_371M, 10240, 309375 },\n\t{ 192000, TMDS_370M, 46592, 703125 },\n\t{ 192000, TMDS_371M, 20480, 309375 },\n};\n\n \n#define TMDS_445_5M 445500\n#define TMDS_445M 445054\n\nstatic const struct hdmi_aud_ncts hdmi_aud_ncts_36bpp[] = {\n\t{ 32000, TMDS_445M, 5824, 632813 },\n\t{ 32000, TMDS_445_5M, 4096, 445500 },\n\t{ 44100, TMDS_445M, 8918, 703125 },\n\t{ 44100, TMDS_445_5M, 4704, 371250 },\n\t{ 88200, TMDS_445M, 17836, 703125 },\n\t{ 88200, TMDS_445_5M, 9408, 371250 },\n\t{ 176400, TMDS_445M, 35672, 703125 },\n\t{ 176400, TMDS_445_5M, 18816, 371250 },\n\t{ 48000, TMDS_445M, 5824, 421875 },\n\t{ 48000, TMDS_445_5M, 5120, 371250 },\n\t{ 96000, TMDS_445M, 11648, 421875 },\n\t{ 96000, TMDS_445_5M, 10240, 371250 },\n\t{ 192000, TMDS_445M, 23296, 421875 },\n\t{ 192000, TMDS_445_5M, 20480, 371250 },\n};\n\n \nstatic u32 audio_config_hdmi_pixel_clock(const struct intel_crtc_state *crtc_state)\n{\n\tstruct drm_i915_private *i915 = to_i915(crtc_state->uapi.crtc->dev);\n\tconst struct drm_display_mode *adjusted_mode =\n\t\t&crtc_state->hw.adjusted_mode;\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(hdmi_audio_clock); i++) {\n\t\tif (adjusted_mode->crtc_clock == hdmi_audio_clock[i].clock)\n\t\t\tbreak;\n\t}\n\n\tif (DISPLAY_VER(i915) < 12 && adjusted_mode->crtc_clock > 148500)\n\t\ti = ARRAY_SIZE(hdmi_audio_clock);\n\n\tif (i == ARRAY_SIZE(hdmi_audio_clock)) {\n\t\tdrm_dbg_kms(&i915->drm,\n\t\t\t    \"HDMI audio pixel clock setting for %d not found, falling back to defaults\\n\",\n\t\t\t    adjusted_mode->crtc_clock);\n\t\ti = 1;\n\t}\n\n\tdrm_dbg_kms(&i915->drm,\n\t\t    \"Configuring HDMI audio for pixel clock %d (0x%08x)\\n\",\n\t\t    hdmi_audio_clock[i].clock,\n\t\t    hdmi_audio_clock[i].config);\n\n\treturn hdmi_audio_clock[i].config;\n}\n\nstatic int audio_config_hdmi_get_n(const struct intel_crtc_state *crtc_state,\n\t\t\t\t   int rate)\n{\n\tconst struct hdmi_aud_ncts *hdmi_ncts_table;\n\tint i, size;\n\n\tif (crtc_state->pipe_bpp == 36) {\n\t\thdmi_ncts_table = hdmi_aud_ncts_36bpp;\n\t\tsize = ARRAY_SIZE(hdmi_aud_ncts_36bpp);\n\t} else if (crtc_state->pipe_bpp == 30) {\n\t\thdmi_ncts_table = hdmi_aud_ncts_30bpp;\n\t\tsize = ARRAY_SIZE(hdmi_aud_ncts_30bpp);\n\t} else {\n\t\thdmi_ncts_table = hdmi_aud_ncts_24bpp;\n\t\tsize = ARRAY_SIZE(hdmi_aud_ncts_24bpp);\n\t}\n\n\tfor (i = 0; i < size; i++) {\n\t\tif (rate == hdmi_ncts_table[i].sample_rate &&\n\t\t    crtc_state->port_clock == hdmi_ncts_table[i].clock) {\n\t\t\treturn hdmi_ncts_table[i].n;\n\t\t}\n\t}\n\treturn 0;\n}\n\n \nstatic int g4x_eld_buffer_size(struct drm_i915_private *i915)\n{\n\tu32 tmp;\n\n\ttmp = intel_de_read(i915, G4X_AUD_CNTL_ST);\n\n\treturn REG_FIELD_GET(G4X_ELD_BUFFER_SIZE_MASK, tmp);\n}\n\nstatic void g4x_audio_codec_get_config(struct intel_encoder *encoder,\n\t\t\t\t       struct intel_crtc_state *crtc_state)\n{\n\tstruct drm_i915_private *i915 = to_i915(encoder->base.dev);\n\tu32 *eld = (u32 *)crtc_state->eld;\n\tint eld_buffer_size, len, i;\n\tu32 tmp;\n\n\ttmp = intel_de_read(i915, G4X_AUD_CNTL_ST);\n\tif ((tmp & G4X_ELD_VALID) == 0)\n\t\treturn;\n\n\tintel_de_rmw(i915, G4X_AUD_CNTL_ST, G4X_ELD_ADDRESS_MASK, 0);\n\n\teld_buffer_size = g4x_eld_buffer_size(i915);\n\tlen = min_t(int, sizeof(crtc_state->eld) / 4, eld_buffer_size);\n\n\tfor (i = 0; i < len; i++)\n\t\teld[i] = intel_de_read(i915, G4X_HDMIW_HDMIEDID);\n}\n\nstatic void g4x_audio_codec_disable(struct intel_encoder *encoder,\n\t\t\t\t    const struct intel_crtc_state *old_crtc_state,\n\t\t\t\t    const struct drm_connector_state *old_conn_state)\n{\n\tstruct drm_i915_private *i915 = to_i915(encoder->base.dev);\n\tstruct intel_crtc *crtc = to_intel_crtc(old_crtc_state->uapi.crtc);\n\n\t \n\tintel_de_rmw(i915, G4X_AUD_CNTL_ST,\n\t\t     G4X_ELD_VALID, 0);\n\n\tintel_crtc_wait_for_next_vblank(crtc);\n\tintel_crtc_wait_for_next_vblank(crtc);\n}\n\nstatic void g4x_audio_codec_enable(struct intel_encoder *encoder,\n\t\t\t\t   const struct intel_crtc_state *crtc_state,\n\t\t\t\t   const struct drm_connector_state *conn_state)\n{\n\tstruct drm_i915_private *i915 = to_i915(encoder->base.dev);\n\tstruct intel_crtc *crtc = to_intel_crtc(crtc_state->uapi.crtc);\n\tconst u32 *eld = (const u32 *)crtc_state->eld;\n\tint eld_buffer_size, len, i;\n\n\tintel_crtc_wait_for_next_vblank(crtc);\n\n\tintel_de_rmw(i915, G4X_AUD_CNTL_ST,\n\t\t     G4X_ELD_VALID | G4X_ELD_ADDRESS_MASK, 0);\n\n\teld_buffer_size = g4x_eld_buffer_size(i915);\n\tlen = min(drm_eld_size(crtc_state->eld) / 4, eld_buffer_size);\n\n\tfor (i = 0; i < len; i++)\n\t\tintel_de_write(i915, G4X_HDMIW_HDMIEDID, eld[i]);\n\tfor (; i < eld_buffer_size; i++)\n\t\tintel_de_write(i915, G4X_HDMIW_HDMIEDID, 0);\n\n\tdrm_WARN_ON(&i915->drm,\n\t\t    (intel_de_read(i915, G4X_AUD_CNTL_ST) & G4X_ELD_ADDRESS_MASK) != 0);\n\n\tintel_de_rmw(i915, G4X_AUD_CNTL_ST,\n\t\t     0, G4X_ELD_VALID);\n}\n\nstatic void\nhsw_dp_audio_config_update(struct intel_encoder *encoder,\n\t\t\t   const struct intel_crtc_state *crtc_state)\n{\n\tstruct drm_i915_private *i915 = to_i915(encoder->base.dev);\n\tstruct i915_audio_component *acomp = i915->display.audio.component;\n\tenum transcoder cpu_transcoder = crtc_state->cpu_transcoder;\n\tenum port port = encoder->port;\n\tconst struct dp_aud_n_m *nm;\n\tint rate;\n\tu32 tmp;\n\n\trate = acomp ? acomp->aud_sample_rate[port] : 0;\n\tnm = audio_config_dp_get_n_m(crtc_state, rate);\n\tif (nm)\n\t\tdrm_dbg_kms(&i915->drm, \"using Maud %u, Naud %u\\n\", nm->m,\n\t\t\t    nm->n);\n\telse\n\t\tdrm_dbg_kms(&i915->drm, \"using automatic Maud, Naud\\n\");\n\n\ttmp = intel_de_read(i915, HSW_AUD_CFG(cpu_transcoder));\n\ttmp &= ~AUD_CONFIG_N_VALUE_INDEX;\n\ttmp &= ~AUD_CONFIG_PIXEL_CLOCK_HDMI_MASK;\n\ttmp &= ~AUD_CONFIG_N_PROG_ENABLE;\n\ttmp |= AUD_CONFIG_N_VALUE_INDEX;\n\n\tif (nm) {\n\t\ttmp &= ~AUD_CONFIG_N_MASK;\n\t\ttmp |= AUD_CONFIG_N(nm->n);\n\t\ttmp |= AUD_CONFIG_N_PROG_ENABLE;\n\t}\n\n\tintel_de_write(i915, HSW_AUD_CFG(cpu_transcoder), tmp);\n\n\ttmp = intel_de_read(i915, HSW_AUD_M_CTS_ENABLE(cpu_transcoder));\n\ttmp &= ~AUD_CONFIG_M_MASK;\n\ttmp &= ~AUD_M_CTS_M_VALUE_INDEX;\n\ttmp &= ~AUD_M_CTS_M_PROG_ENABLE;\n\n\tif (nm) {\n\t\ttmp |= nm->m;\n\t\ttmp |= AUD_M_CTS_M_VALUE_INDEX;\n\t\ttmp |= AUD_M_CTS_M_PROG_ENABLE;\n\t}\n\n\tintel_de_write(i915, HSW_AUD_M_CTS_ENABLE(cpu_transcoder), tmp);\n}\n\nstatic void\nhsw_hdmi_audio_config_update(struct intel_encoder *encoder,\n\t\t\t     const struct intel_crtc_state *crtc_state)\n{\n\tstruct drm_i915_private *i915 = to_i915(encoder->base.dev);\n\tstruct i915_audio_component *acomp = i915->display.audio.component;\n\tenum transcoder cpu_transcoder = crtc_state->cpu_transcoder;\n\tenum port port = encoder->port;\n\tint n, rate;\n\tu32 tmp;\n\n\trate = acomp ? acomp->aud_sample_rate[port] : 0;\n\n\ttmp = intel_de_read(i915, HSW_AUD_CFG(cpu_transcoder));\n\ttmp &= ~AUD_CONFIG_N_VALUE_INDEX;\n\ttmp &= ~AUD_CONFIG_PIXEL_CLOCK_HDMI_MASK;\n\ttmp &= ~AUD_CONFIG_N_PROG_ENABLE;\n\ttmp |= audio_config_hdmi_pixel_clock(crtc_state);\n\n\tn = audio_config_hdmi_get_n(crtc_state, rate);\n\tif (n != 0) {\n\t\tdrm_dbg_kms(&i915->drm, \"using N %d\\n\", n);\n\n\t\ttmp &= ~AUD_CONFIG_N_MASK;\n\t\ttmp |= AUD_CONFIG_N(n);\n\t\ttmp |= AUD_CONFIG_N_PROG_ENABLE;\n\t} else {\n\t\tdrm_dbg_kms(&i915->drm, \"using automatic N\\n\");\n\t}\n\n\tintel_de_write(i915, HSW_AUD_CFG(cpu_transcoder), tmp);\n\n\t \n\ttmp = intel_de_read(i915, HSW_AUD_M_CTS_ENABLE(cpu_transcoder));\n\ttmp &= ~AUD_M_CTS_M_PROG_ENABLE;\n\ttmp &= ~AUD_M_CTS_M_VALUE_INDEX;\n\tintel_de_write(i915, HSW_AUD_M_CTS_ENABLE(cpu_transcoder), tmp);\n}\n\nstatic void\nhsw_audio_config_update(struct intel_encoder *encoder,\n\t\t\tconst struct intel_crtc_state *crtc_state)\n{\n\tif (intel_crtc_has_dp_encoder(crtc_state))\n\t\thsw_dp_audio_config_update(encoder, crtc_state);\n\telse\n\t\thsw_hdmi_audio_config_update(encoder, crtc_state);\n}\n\nstatic void hsw_audio_codec_disable(struct intel_encoder *encoder,\n\t\t\t\t    const struct intel_crtc_state *old_crtc_state,\n\t\t\t\t    const struct drm_connector_state *old_conn_state)\n{\n\tstruct drm_i915_private *i915 = to_i915(encoder->base.dev);\n\tstruct intel_crtc *crtc = to_intel_crtc(old_crtc_state->uapi.crtc);\n\tenum transcoder cpu_transcoder = old_crtc_state->cpu_transcoder;\n\n\tmutex_lock(&i915->display.audio.mutex);\n\n\t \n\tintel_de_rmw(i915, HSW_AUD_CFG(cpu_transcoder),\n\t\t     AUD_CONFIG_N_VALUE_INDEX |\n\t\t     AUD_CONFIG_UPPER_N_MASK |\n\t\t     AUD_CONFIG_LOWER_N_MASK,\n\t\t     AUD_CONFIG_N_PROG_ENABLE |\n\t\t     (intel_crtc_has_dp_encoder(old_crtc_state) ?\n\t\t      AUD_CONFIG_N_VALUE_INDEX : 0));\n\n\t \n\tintel_de_rmw(i915, HSW_AUD_PIN_ELD_CP_VLD,\n\t\t     AUDIO_ELD_VALID(cpu_transcoder), 0);\n\n\tintel_crtc_wait_for_next_vblank(crtc);\n\tintel_crtc_wait_for_next_vblank(crtc);\n\n\t \n\tintel_de_rmw(i915, HSW_AUD_PIN_ELD_CP_VLD,\n\t\t     AUDIO_OUTPUT_ENABLE(cpu_transcoder), 0);\n\n\tmutex_unlock(&i915->display.audio.mutex);\n}\n\nstatic unsigned int calc_hblank_early_prog(struct intel_encoder *encoder,\n\t\t\t\t\t   const struct intel_crtc_state *crtc_state)\n{\n\tstruct drm_i915_private *i915 = to_i915(encoder->base.dev);\n\tunsigned int link_clks_available, link_clks_required;\n\tunsigned int tu_data, tu_line, link_clks_active;\n\tunsigned int h_active, h_total, hblank_delta, pixel_clk;\n\tunsigned int fec_coeff, cdclk, vdsc_bpp;\n\tunsigned int link_clk, lanes;\n\tunsigned int hblank_rise;\n\n\th_active = crtc_state->hw.adjusted_mode.crtc_hdisplay;\n\th_total = crtc_state->hw.adjusted_mode.crtc_htotal;\n\tpixel_clk = crtc_state->hw.adjusted_mode.crtc_clock;\n\tvdsc_bpp = crtc_state->dsc.compressed_bpp;\n\tcdclk = i915->display.cdclk.hw.cdclk;\n\t \n\tfec_coeff = 972261;\n\tlink_clk = crtc_state->port_clock;\n\tlanes = crtc_state->lane_count;\n\n\tdrm_dbg_kms(&i915->drm, \"h_active = %u link_clk = %u :\"\n\t\t    \"lanes = %u vdsc_bpp = %u cdclk = %u\\n\",\n\t\t    h_active, link_clk, lanes, vdsc_bpp, cdclk);\n\n\tif (WARN_ON(!link_clk || !pixel_clk || !lanes || !vdsc_bpp || !cdclk))\n\t\treturn 0;\n\n\tlink_clks_available = (h_total - h_active) * link_clk / pixel_clk - 28;\n\tlink_clks_required = DIV_ROUND_UP(192000 * h_total, 1000 * pixel_clk) * (48 / lanes + 2);\n\n\tif (link_clks_available > link_clks_required)\n\t\thblank_delta = 32;\n\telse\n\t\thblank_delta = DIV64_U64_ROUND_UP(mul_u32_u32(5 * (link_clk + cdclk), pixel_clk),\n\t\t\t\t\t\t  mul_u32_u32(link_clk, cdclk));\n\n\ttu_data = div64_u64(mul_u32_u32(pixel_clk * vdsc_bpp * 8, 1000000),\n\t\t\t    mul_u32_u32(link_clk * lanes, fec_coeff));\n\ttu_line = div64_u64(h_active * mul_u32_u32(link_clk, fec_coeff),\n\t\t\t    mul_u32_u32(64 * pixel_clk, 1000000));\n\tlink_clks_active  = (tu_line - 1) * 64 + tu_data;\n\n\thblank_rise = (link_clks_active + 6 * DIV_ROUND_UP(link_clks_active, 250) + 4) * pixel_clk / link_clk;\n\n\treturn h_active - hblank_rise + hblank_delta;\n}\n\nstatic unsigned int calc_samples_room(const struct intel_crtc_state *crtc_state)\n{\n\tunsigned int h_active, h_total, pixel_clk;\n\tunsigned int link_clk, lanes;\n\n\th_active = crtc_state->hw.adjusted_mode.hdisplay;\n\th_total = crtc_state->hw.adjusted_mode.htotal;\n\tpixel_clk = crtc_state->hw.adjusted_mode.clock;\n\tlink_clk = crtc_state->port_clock;\n\tlanes = crtc_state->lane_count;\n\n\treturn ((h_total - h_active) * link_clk - 12 * pixel_clk) /\n\t\t(pixel_clk * (48 / lanes + 2));\n}\n\nstatic void enable_audio_dsc_wa(struct intel_encoder *encoder,\n\t\t\t\tconst struct intel_crtc_state *crtc_state)\n{\n\tstruct drm_i915_private *i915 = to_i915(encoder->base.dev);\n\tenum transcoder cpu_transcoder = crtc_state->cpu_transcoder;\n\tunsigned int hblank_early_prog, samples_room;\n\tunsigned int val;\n\n\tif (DISPLAY_VER(i915) < 11)\n\t\treturn;\n\n\tval = intel_de_read(i915, AUD_CONFIG_BE);\n\n\tif (DISPLAY_VER(i915) == 11)\n\t\tval |= HBLANK_EARLY_ENABLE_ICL(cpu_transcoder);\n\telse if (DISPLAY_VER(i915) >= 12)\n\t\tval |= HBLANK_EARLY_ENABLE_TGL(cpu_transcoder);\n\n\tif (crtc_state->dsc.compression_enable &&\n\t    crtc_state->hw.adjusted_mode.hdisplay >= 3840 &&\n\t    crtc_state->hw.adjusted_mode.vdisplay >= 2160) {\n\t\t \n\t\tval &= ~HBLANK_START_COUNT_MASK(cpu_transcoder);\n\t\thblank_early_prog = calc_hblank_early_prog(encoder, crtc_state);\n\t\tif (hblank_early_prog < 32)\n\t\t\tval |= HBLANK_START_COUNT(cpu_transcoder, HBLANK_START_COUNT_32);\n\t\telse if (hblank_early_prog < 64)\n\t\t\tval |= HBLANK_START_COUNT(cpu_transcoder, HBLANK_START_COUNT_64);\n\t\telse if (hblank_early_prog < 96)\n\t\t\tval |= HBLANK_START_COUNT(cpu_transcoder, HBLANK_START_COUNT_96);\n\t\telse\n\t\t\tval |= HBLANK_START_COUNT(cpu_transcoder, HBLANK_START_COUNT_128);\n\n\t\t \n\t\tval &= ~NUMBER_SAMPLES_PER_LINE_MASK(cpu_transcoder);\n\t\tsamples_room = calc_samples_room(crtc_state);\n\t\tif (samples_room < 3)\n\t\t\tval |= NUMBER_SAMPLES_PER_LINE(cpu_transcoder, samples_room);\n\t\telse  \n\t\t\tval |= NUMBER_SAMPLES_PER_LINE(cpu_transcoder, 0x0);\n\t}\n\n\tintel_de_write(i915, AUD_CONFIG_BE, val);\n}\n\nstatic void hsw_audio_codec_enable(struct intel_encoder *encoder,\n\t\t\t\t   const struct intel_crtc_state *crtc_state,\n\t\t\t\t   const struct drm_connector_state *conn_state)\n{\n\tstruct drm_i915_private *i915 = to_i915(encoder->base.dev);\n\tstruct intel_crtc *crtc = to_intel_crtc(crtc_state->uapi.crtc);\n\tenum transcoder cpu_transcoder = crtc_state->cpu_transcoder;\n\n\tmutex_lock(&i915->display.audio.mutex);\n\n\t \n\tif (intel_crtc_has_type(crtc_state, INTEL_OUTPUT_DP))\n\t\tenable_audio_dsc_wa(encoder, crtc_state);\n\n\t \n\tintel_de_rmw(i915, HSW_AUD_PIN_ELD_CP_VLD,\n\t\t     0, AUDIO_OUTPUT_ENABLE(cpu_transcoder));\n\n\tintel_crtc_wait_for_next_vblank(crtc);\n\n\t \n\tintel_de_rmw(i915, HSW_AUD_PIN_ELD_CP_VLD,\n\t\t     AUDIO_ELD_VALID(cpu_transcoder), 0);\n\n\t \n\n\t \n\thsw_audio_config_update(encoder, crtc_state);\n\n\tmutex_unlock(&i915->display.audio.mutex);\n}\n\nstruct ibx_audio_regs {\n\ti915_reg_t hdmiw_hdmiedid, aud_config, aud_cntl_st, aud_cntrl_st2;\n};\n\nstatic void ibx_audio_regs_init(struct drm_i915_private *i915,\n\t\t\t\tenum pipe pipe,\n\t\t\t\tstruct ibx_audio_regs *regs)\n{\n\tif (IS_VALLEYVIEW(i915) || IS_CHERRYVIEW(i915)) {\n\t\tregs->hdmiw_hdmiedid = VLV_HDMIW_HDMIEDID(pipe);\n\t\tregs->aud_config = VLV_AUD_CFG(pipe);\n\t\tregs->aud_cntl_st = VLV_AUD_CNTL_ST(pipe);\n\t\tregs->aud_cntrl_st2 = VLV_AUD_CNTL_ST2;\n\t} else if (HAS_PCH_CPT(i915)) {\n\t\tregs->hdmiw_hdmiedid = CPT_HDMIW_HDMIEDID(pipe);\n\t\tregs->aud_config = CPT_AUD_CFG(pipe);\n\t\tregs->aud_cntl_st = CPT_AUD_CNTL_ST(pipe);\n\t\tregs->aud_cntrl_st2 = CPT_AUD_CNTRL_ST2;\n\t} else if (HAS_PCH_IBX(i915)) {\n\t\tregs->hdmiw_hdmiedid = IBX_HDMIW_HDMIEDID(pipe);\n\t\tregs->aud_config = IBX_AUD_CFG(pipe);\n\t\tregs->aud_cntl_st = IBX_AUD_CNTL_ST(pipe);\n\t\tregs->aud_cntrl_st2 = IBX_AUD_CNTL_ST2;\n\t}\n}\n\nstatic void ibx_audio_codec_disable(struct intel_encoder *encoder,\n\t\t\t\t    const struct intel_crtc_state *old_crtc_state,\n\t\t\t\t    const struct drm_connector_state *old_conn_state)\n{\n\tstruct drm_i915_private *i915 = to_i915(encoder->base.dev);\n\tstruct intel_crtc *crtc = to_intel_crtc(old_crtc_state->uapi.crtc);\n\tenum port port = encoder->port;\n\tenum pipe pipe = crtc->pipe;\n\tstruct ibx_audio_regs regs;\n\n\tif (drm_WARN_ON(&i915->drm, port == PORT_A))\n\t\treturn;\n\n\tibx_audio_regs_init(i915, pipe, &regs);\n\n\tmutex_lock(&i915->display.audio.mutex);\n\n\t \n\tintel_de_rmw(i915, regs.aud_config,\n\t\t     AUD_CONFIG_N_VALUE_INDEX |\n\t\t     AUD_CONFIG_UPPER_N_MASK |\n\t\t     AUD_CONFIG_LOWER_N_MASK,\n\t\t     AUD_CONFIG_N_PROG_ENABLE |\n\t\t     (intel_crtc_has_dp_encoder(old_crtc_state) ?\n\t\t      AUD_CONFIG_N_VALUE_INDEX : 0));\n\n\t \n\tintel_de_rmw(i915, regs.aud_cntrl_st2,\n\t\t     IBX_ELD_VALID(port), 0);\n\n\tmutex_unlock(&i915->display.audio.mutex);\n\n\tintel_crtc_wait_for_next_vblank(crtc);\n\tintel_crtc_wait_for_next_vblank(crtc);\n}\n\nstatic void ibx_audio_codec_enable(struct intel_encoder *encoder,\n\t\t\t\t   const struct intel_crtc_state *crtc_state,\n\t\t\t\t   const struct drm_connector_state *conn_state)\n{\n\tstruct drm_i915_private *i915 = to_i915(encoder->base.dev);\n\tstruct intel_crtc *crtc = to_intel_crtc(crtc_state->uapi.crtc);\n\tenum port port = encoder->port;\n\tenum pipe pipe = crtc->pipe;\n\tstruct ibx_audio_regs regs;\n\n\tif (drm_WARN_ON(&i915->drm, port == PORT_A))\n\t\treturn;\n\n\tintel_crtc_wait_for_next_vblank(crtc);\n\n\tibx_audio_regs_init(i915, pipe, &regs);\n\n\tmutex_lock(&i915->display.audio.mutex);\n\n\t \n\tintel_de_rmw(i915, regs.aud_cntrl_st2,\n\t\t     IBX_ELD_VALID(port), 0);\n\n\t \n\n\t \n\tintel_de_rmw(i915, regs.aud_config,\n\t\t     AUD_CONFIG_N_VALUE_INDEX |\n\t\t     AUD_CONFIG_N_PROG_ENABLE |\n\t\t     AUD_CONFIG_PIXEL_CLOCK_HDMI_MASK,\n\t\t     (intel_crtc_has_dp_encoder(crtc_state) ?\n\t\t      AUD_CONFIG_N_VALUE_INDEX :\n\t\t      audio_config_hdmi_pixel_clock(crtc_state)));\n\n\tmutex_unlock(&i915->display.audio.mutex);\n}\n\nvoid intel_audio_sdp_split_update(struct intel_encoder *encoder,\n\t\t\t\t  const struct intel_crtc_state *crtc_state)\n{\n\tstruct drm_i915_private *i915 = to_i915(encoder->base.dev);\n\tenum transcoder trans = crtc_state->cpu_transcoder;\n\n\tif (HAS_DP20(i915))\n\t\tintel_de_rmw(i915, AUD_DP_2DOT0_CTRL(trans), AUD_ENABLE_SDP_SPLIT,\n\t\t\t     crtc_state->sdp_split_enable ? AUD_ENABLE_SDP_SPLIT : 0);\n}\n\nbool intel_audio_compute_config(struct intel_encoder *encoder,\n\t\t\t\tstruct intel_crtc_state *crtc_state,\n\t\t\t\tstruct drm_connector_state *conn_state)\n{\n\tstruct drm_i915_private *i915 = to_i915(encoder->base.dev);\n\tstruct drm_connector *connector = conn_state->connector;\n\tconst struct drm_display_mode *adjusted_mode =\n\t\t&crtc_state->hw.adjusted_mode;\n\n\tif (!connector->eld[0]) {\n\t\tdrm_dbg_kms(&i915->drm,\n\t\t\t    \"Bogus ELD on [CONNECTOR:%d:%s]\\n\",\n\t\t\t    connector->base.id, connector->name);\n\t\treturn false;\n\t}\n\n\tBUILD_BUG_ON(sizeof(crtc_state->eld) != sizeof(connector->eld));\n\tmemcpy(crtc_state->eld, connector->eld, sizeof(crtc_state->eld));\n\n\tcrtc_state->eld[6] = drm_av_sync_delay(connector, adjusted_mode) / 2;\n\n\treturn true;\n}\n\n \nvoid intel_audio_codec_enable(struct intel_encoder *encoder,\n\t\t\t      const struct intel_crtc_state *crtc_state,\n\t\t\t      const struct drm_connector_state *conn_state)\n{\n\tstruct drm_i915_private *i915 = to_i915(encoder->base.dev);\n\tstruct i915_audio_component *acomp = i915->display.audio.component;\n\tstruct intel_crtc *crtc = to_intel_crtc(crtc_state->uapi.crtc);\n\tstruct intel_connector *connector = to_intel_connector(conn_state->connector);\n\tenum transcoder cpu_transcoder = crtc_state->cpu_transcoder;\n\tstruct intel_audio_state *audio_state;\n\tenum port port = encoder->port;\n\n\tif (!crtc_state->has_audio)\n\t\treturn;\n\n\tdrm_dbg_kms(&i915->drm, \"[CONNECTOR:%d:%s][ENCODER:%d:%s] Enable audio codec on [CRTC:%d:%s], %u bytes ELD\\n\",\n\t\t    connector->base.base.id, connector->base.name,\n\t\t    encoder->base.base.id, encoder->base.name,\n\t\t    crtc->base.base.id, crtc->base.name,\n\t\t    drm_eld_size(crtc_state->eld));\n\n\tif (i915->display.funcs.audio)\n\t\ti915->display.funcs.audio->audio_codec_enable(encoder,\n\t\t\t\t\t\t\t      crtc_state,\n\t\t\t\t\t\t\t      conn_state);\n\n\tmutex_lock(&i915->display.audio.mutex);\n\n\taudio_state = &i915->display.audio.state[cpu_transcoder];\n\n\taudio_state->encoder = encoder;\n\tBUILD_BUG_ON(sizeof(audio_state->eld) != sizeof(crtc_state->eld));\n\tmemcpy(audio_state->eld, crtc_state->eld, sizeof(audio_state->eld));\n\n\tmutex_unlock(&i915->display.audio.mutex);\n\n\tif (acomp && acomp->base.audio_ops &&\n\t    acomp->base.audio_ops->pin_eld_notify) {\n\t\t \n\t\tif (!intel_crtc_has_type(crtc_state, INTEL_OUTPUT_DP_MST))\n\t\t\tcpu_transcoder = -1;\n\t\tacomp->base.audio_ops->pin_eld_notify(acomp->base.audio_ops->audio_ptr,\n\t\t\t\t\t\t      (int)port, (int)cpu_transcoder);\n\t}\n\n\tintel_lpe_audio_notify(i915, cpu_transcoder, port, crtc_state->eld,\n\t\t\t       crtc_state->port_clock,\n\t\t\t       intel_crtc_has_dp_encoder(crtc_state));\n}\n\n \nvoid intel_audio_codec_disable(struct intel_encoder *encoder,\n\t\t\t       const struct intel_crtc_state *old_crtc_state,\n\t\t\t       const struct drm_connector_state *old_conn_state)\n{\n\tstruct drm_i915_private *i915 = to_i915(encoder->base.dev);\n\tstruct i915_audio_component *acomp = i915->display.audio.component;\n\tstruct intel_crtc *crtc = to_intel_crtc(old_crtc_state->uapi.crtc);\n\tstruct intel_connector *connector = to_intel_connector(old_conn_state->connector);\n\tenum transcoder cpu_transcoder = old_crtc_state->cpu_transcoder;\n\tstruct intel_audio_state *audio_state;\n\tenum port port = encoder->port;\n\n\tif (!old_crtc_state->has_audio)\n\t\treturn;\n\n\tdrm_dbg_kms(&i915->drm, \"[CONNECTOR:%d:%s][ENCODER:%d:%s] Disable audio codec on [CRTC:%d:%s]\\n\",\n\t\t    connector->base.base.id, connector->base.name,\n\t\t    encoder->base.base.id, encoder->base.name,\n\t\t    crtc->base.base.id, crtc->base.name);\n\n\tif (i915->display.funcs.audio)\n\t\ti915->display.funcs.audio->audio_codec_disable(encoder,\n\t\t\t\t\t\t\t       old_crtc_state,\n\t\t\t\t\t\t\t       old_conn_state);\n\n\tmutex_lock(&i915->display.audio.mutex);\n\n\taudio_state = &i915->display.audio.state[cpu_transcoder];\n\n\taudio_state->encoder = NULL;\n\tmemset(audio_state->eld, 0, sizeof(audio_state->eld));\n\n\tmutex_unlock(&i915->display.audio.mutex);\n\n\tif (acomp && acomp->base.audio_ops &&\n\t    acomp->base.audio_ops->pin_eld_notify) {\n\t\t \n\t\tif (!intel_crtc_has_type(old_crtc_state, INTEL_OUTPUT_DP_MST))\n\t\t\tcpu_transcoder = -1;\n\t\tacomp->base.audio_ops->pin_eld_notify(acomp->base.audio_ops->audio_ptr,\n\t\t\t\t\t\t      (int)port, (int)cpu_transcoder);\n\t}\n\n\tintel_lpe_audio_notify(i915, cpu_transcoder, port, NULL, 0, false);\n}\n\nstatic void intel_acomp_get_config(struct intel_encoder *encoder,\n\t\t\t\t   struct intel_crtc_state *crtc_state)\n{\n\tstruct drm_i915_private *i915 = to_i915(encoder->base.dev);\n\tenum transcoder cpu_transcoder = crtc_state->cpu_transcoder;\n\tstruct intel_audio_state *audio_state;\n\n\tmutex_lock(&i915->display.audio.mutex);\n\n\taudio_state = &i915->display.audio.state[cpu_transcoder];\n\n\tif (audio_state->encoder)\n\t\tmemcpy(crtc_state->eld, audio_state->eld, sizeof(audio_state->eld));\n\n\tmutex_unlock(&i915->display.audio.mutex);\n}\n\nvoid intel_audio_codec_get_config(struct intel_encoder *encoder,\n\t\t\t\t  struct intel_crtc_state *crtc_state)\n{\n\tstruct drm_i915_private *i915 = to_i915(encoder->base.dev);\n\n\tif (!crtc_state->has_audio)\n\t\treturn;\n\n\tif (i915->display.funcs.audio)\n\t\ti915->display.funcs.audio->audio_codec_get_config(encoder, crtc_state);\n}\n\nstatic const struct intel_audio_funcs g4x_audio_funcs = {\n\t.audio_codec_enable = g4x_audio_codec_enable,\n\t.audio_codec_disable = g4x_audio_codec_disable,\n\t.audio_codec_get_config = g4x_audio_codec_get_config,\n};\n\nstatic const struct intel_audio_funcs ibx_audio_funcs = {\n\t.audio_codec_enable = ibx_audio_codec_enable,\n\t.audio_codec_disable = ibx_audio_codec_disable,\n\t.audio_codec_get_config = intel_acomp_get_config,\n};\n\nstatic const struct intel_audio_funcs hsw_audio_funcs = {\n\t.audio_codec_enable = hsw_audio_codec_enable,\n\t.audio_codec_disable = hsw_audio_codec_disable,\n\t.audio_codec_get_config = intel_acomp_get_config,\n};\n\n \nvoid intel_audio_hooks_init(struct drm_i915_private *i915)\n{\n\tif (IS_G4X(i915))\n\t\ti915->display.funcs.audio = &g4x_audio_funcs;\n\telse if (IS_VALLEYVIEW(i915) || IS_CHERRYVIEW(i915) ||\n\t\t HAS_PCH_CPT(i915) || HAS_PCH_IBX(i915))\n\t\ti915->display.funcs.audio = &ibx_audio_funcs;\n\telse if (IS_HASWELL(i915) || DISPLAY_VER(i915) >= 8)\n\t\ti915->display.funcs.audio = &hsw_audio_funcs;\n}\n\nstruct aud_ts_cdclk_m_n {\n\tu8 m;\n\tu16 n;\n};\n\nvoid intel_audio_cdclk_change_pre(struct drm_i915_private *i915)\n{\n\tif (DISPLAY_VER(i915) >= 13)\n\t\tintel_de_rmw(i915, AUD_TS_CDCLK_M, AUD_TS_CDCLK_M_EN, 0);\n}\n\nstatic void get_aud_ts_cdclk_m_n(int refclk, int cdclk, struct aud_ts_cdclk_m_n *aud_ts)\n{\n\taud_ts->m = 60;\n\taud_ts->n = cdclk * aud_ts->m / 24000;\n}\n\nvoid intel_audio_cdclk_change_post(struct drm_i915_private *i915)\n{\n\tstruct aud_ts_cdclk_m_n aud_ts;\n\n\tif (DISPLAY_VER(i915) >= 13) {\n\t\tget_aud_ts_cdclk_m_n(i915->display.cdclk.hw.ref, i915->display.cdclk.hw.cdclk, &aud_ts);\n\n\t\tintel_de_write(i915, AUD_TS_CDCLK_N, aud_ts.n);\n\t\tintel_de_write(i915, AUD_TS_CDCLK_M, aud_ts.m | AUD_TS_CDCLK_M_EN);\n\t\tdrm_dbg_kms(&i915->drm, \"aud_ts_cdclk set to M=%u, N=%u\\n\", aud_ts.m, aud_ts.n);\n\t}\n}\n\nstatic int glk_force_audio_cdclk_commit(struct intel_atomic_state *state,\n\t\t\t\t\tstruct intel_crtc *crtc,\n\t\t\t\t\tbool enable)\n{\n\tstruct intel_cdclk_state *cdclk_state;\n\tint ret;\n\n\t \n\tret = drm_modeset_lock(&crtc->base.mutex, state->base.acquire_ctx);\n\tif (ret)\n\t\treturn ret;\n\n\tcdclk_state = intel_atomic_get_cdclk_state(state);\n\tif (IS_ERR(cdclk_state))\n\t\treturn PTR_ERR(cdclk_state);\n\n\tcdclk_state->force_min_cdclk = enable ? 2 * 96000 : 0;\n\n\treturn drm_atomic_commit(&state->base);\n}\n\nstatic void glk_force_audio_cdclk(struct drm_i915_private *i915,\n\t\t\t\t  bool enable)\n{\n\tstruct drm_modeset_acquire_ctx ctx;\n\tstruct drm_atomic_state *state;\n\tstruct intel_crtc *crtc;\n\tint ret;\n\n\tcrtc = intel_first_crtc(i915);\n\tif (!crtc)\n\t\treturn;\n\n\tdrm_modeset_acquire_init(&ctx, 0);\n\tstate = drm_atomic_state_alloc(&i915->drm);\n\tif (drm_WARN_ON(&i915->drm, !state))\n\t\treturn;\n\n\tstate->acquire_ctx = &ctx;\n\tto_intel_atomic_state(state)->internal = true;\n\nretry:\n\tret = glk_force_audio_cdclk_commit(to_intel_atomic_state(state), crtc,\n\t\t\t\t\t   enable);\n\tif (ret == -EDEADLK) {\n\t\tdrm_atomic_state_clear(state);\n\t\tdrm_modeset_backoff(&ctx);\n\t\tgoto retry;\n\t}\n\n\tdrm_WARN_ON(&i915->drm, ret);\n\n\tdrm_atomic_state_put(state);\n\n\tdrm_modeset_drop_locks(&ctx);\n\tdrm_modeset_acquire_fini(&ctx);\n}\n\nstatic unsigned long i915_audio_component_get_power(struct device *kdev)\n{\n\tstruct drm_i915_private *i915 = kdev_to_i915(kdev);\n\tintel_wakeref_t ret;\n\n\t \n\tBUILD_BUG_ON(sizeof(intel_wakeref_t) > sizeof(unsigned long));\n\n\tret = intel_display_power_get(i915, POWER_DOMAIN_AUDIO_PLAYBACK);\n\n\tif (i915->display.audio.power_refcount++ == 0) {\n\t\tif (DISPLAY_VER(i915) >= 9) {\n\t\t\tintel_de_write(i915, AUD_FREQ_CNTRL,\n\t\t\t\t       i915->display.audio.freq_cntrl);\n\t\t\tdrm_dbg_kms(&i915->drm,\n\t\t\t\t    \"restored AUD_FREQ_CNTRL to 0x%x\\n\",\n\t\t\t\t    i915->display.audio.freq_cntrl);\n\t\t}\n\n\t\t \n\t\tif (IS_GEMINILAKE(i915))\n\t\t\tglk_force_audio_cdclk(i915, true);\n\n\t\tif (DISPLAY_VER(i915) >= 10)\n\t\t\tintel_de_rmw(i915, AUD_PIN_BUF_CTL,\n\t\t\t\t     0, AUD_PIN_BUF_ENABLE);\n\t}\n\n\treturn ret;\n}\n\nstatic void i915_audio_component_put_power(struct device *kdev,\n\t\t\t\t\t   unsigned long cookie)\n{\n\tstruct drm_i915_private *i915 = kdev_to_i915(kdev);\n\n\t \n\tif (--i915->display.audio.power_refcount == 0)\n\t\tif (IS_GEMINILAKE(i915))\n\t\t\tglk_force_audio_cdclk(i915, false);\n\n\tintel_display_power_put(i915, POWER_DOMAIN_AUDIO_PLAYBACK, cookie);\n}\n\nstatic void i915_audio_component_codec_wake_override(struct device *kdev,\n\t\t\t\t\t\t     bool enable)\n{\n\tstruct drm_i915_private *i915 = kdev_to_i915(kdev);\n\tunsigned long cookie;\n\n\tif (DISPLAY_VER(i915) < 9)\n\t\treturn;\n\n\tcookie = i915_audio_component_get_power(kdev);\n\n\t \n\tintel_de_rmw(i915, HSW_AUD_CHICKENBIT,\n\t\t     SKL_AUD_CODEC_WAKE_SIGNAL, 0);\n\tusleep_range(1000, 1500);\n\n\tif (enable) {\n\t\tintel_de_rmw(i915, HSW_AUD_CHICKENBIT,\n\t\t\t     0, SKL_AUD_CODEC_WAKE_SIGNAL);\n\t\tusleep_range(1000, 1500);\n\t}\n\n\ti915_audio_component_put_power(kdev, cookie);\n}\n\n \nstatic int i915_audio_component_get_cdclk_freq(struct device *kdev)\n{\n\tstruct drm_i915_private *i915 = kdev_to_i915(kdev);\n\n\tif (drm_WARN_ON_ONCE(&i915->drm, !HAS_DDI(i915)))\n\t\treturn -ENODEV;\n\n\treturn i915->display.cdclk.hw.cdclk;\n}\n\n \nstatic struct intel_audio_state *find_audio_state(struct drm_i915_private *i915,\n\t\t\t\t\t\t  int port, int cpu_transcoder)\n{\n\t \n\tif (cpu_transcoder >= 0) {\n\t\tstruct intel_audio_state *audio_state;\n\t\tstruct intel_encoder *encoder;\n\n\t\tif (drm_WARN_ON(&i915->drm,\n\t\t\t\tcpu_transcoder >= ARRAY_SIZE(i915->display.audio.state)))\n\t\t\treturn NULL;\n\n\t\taudio_state = &i915->display.audio.state[cpu_transcoder];\n\t\tencoder = audio_state->encoder;\n\n\t\tif (encoder && encoder->port == port &&\n\t\t    encoder->type == INTEL_OUTPUT_DP_MST)\n\t\t\treturn audio_state;\n\t}\n\n\t \n\tif (cpu_transcoder > 0)\n\t\treturn NULL;\n\n\tfor_each_cpu_transcoder(i915, cpu_transcoder) {\n\t\tstruct intel_audio_state *audio_state;\n\t\tstruct intel_encoder *encoder;\n\n\t\taudio_state = &i915->display.audio.state[cpu_transcoder];\n\t\tencoder = audio_state->encoder;\n\n\t\tif (encoder && encoder->port == port &&\n\t\t    encoder->type != INTEL_OUTPUT_DP_MST)\n\t\t\treturn audio_state;\n\t}\n\n\treturn NULL;\n}\n\nstatic int i915_audio_component_sync_audio_rate(struct device *kdev, int port,\n\t\t\t\t\t\tint cpu_transcoder, int rate)\n{\n\tstruct drm_i915_private *i915 = kdev_to_i915(kdev);\n\tstruct i915_audio_component *acomp = i915->display.audio.component;\n\tconst struct intel_audio_state *audio_state;\n\tstruct intel_encoder *encoder;\n\tstruct intel_crtc *crtc;\n\tunsigned long cookie;\n\tint err = 0;\n\n\tif (!HAS_DDI(i915))\n\t\treturn 0;\n\n\tcookie = i915_audio_component_get_power(kdev);\n\tmutex_lock(&i915->display.audio.mutex);\n\n\taudio_state = find_audio_state(i915, port, cpu_transcoder);\n\tif (!audio_state) {\n\t\tdrm_dbg_kms(&i915->drm, \"Not valid for port %c\\n\", port_name(port));\n\t\terr = -ENODEV;\n\t\tgoto unlock;\n\t}\n\n\tencoder = audio_state->encoder;\n\n\t \n\tcrtc = to_intel_crtc(encoder->base.crtc);\n\n\t \n\tacomp->aud_sample_rate[port] = rate;\n\n\t \n\thsw_audio_config_update(encoder, crtc->config);\n\n unlock:\n\tmutex_unlock(&i915->display.audio.mutex);\n\ti915_audio_component_put_power(kdev, cookie);\n\treturn err;\n}\n\nstatic int i915_audio_component_get_eld(struct device *kdev, int port,\n\t\t\t\t\tint cpu_transcoder, bool *enabled,\n\t\t\t\t\tunsigned char *buf, int max_bytes)\n{\n\tstruct drm_i915_private *i915 = kdev_to_i915(kdev);\n\tconst struct intel_audio_state *audio_state;\n\tint ret = 0;\n\n\tmutex_lock(&i915->display.audio.mutex);\n\n\taudio_state = find_audio_state(i915, port, cpu_transcoder);\n\tif (!audio_state) {\n\t\tdrm_dbg_kms(&i915->drm, \"Not valid for port %c\\n\", port_name(port));\n\t\tmutex_unlock(&i915->display.audio.mutex);\n\t\treturn -EINVAL;\n\t}\n\n\t*enabled = audio_state->encoder != NULL;\n\tif (*enabled) {\n\t\tconst u8 *eld = audio_state->eld;\n\n\t\tret = drm_eld_size(eld);\n\t\tmemcpy(buf, eld, min(max_bytes, ret));\n\t}\n\n\tmutex_unlock(&i915->display.audio.mutex);\n\treturn ret;\n}\n\nstatic const struct drm_audio_component_ops i915_audio_component_ops = {\n\t.owner\t\t= THIS_MODULE,\n\t.get_power\t= i915_audio_component_get_power,\n\t.put_power\t= i915_audio_component_put_power,\n\t.codec_wake_override = i915_audio_component_codec_wake_override,\n\t.get_cdclk_freq\t= i915_audio_component_get_cdclk_freq,\n\t.sync_audio_rate = i915_audio_component_sync_audio_rate,\n\t.get_eld\t= i915_audio_component_get_eld,\n};\n\nstatic int i915_audio_component_bind(struct device *i915_kdev,\n\t\t\t\t     struct device *hda_kdev, void *data)\n{\n\tstruct i915_audio_component *acomp = data;\n\tstruct drm_i915_private *i915 = kdev_to_i915(i915_kdev);\n\tint i;\n\n\tif (drm_WARN_ON(&i915->drm, acomp->base.ops || acomp->base.dev))\n\t\treturn -EEXIST;\n\n\tif (drm_WARN_ON(&i915->drm,\n\t\t\t!device_link_add(hda_kdev, i915_kdev,\n\t\t\t\t\t DL_FLAG_STATELESS)))\n\t\treturn -ENOMEM;\n\n\tdrm_modeset_lock_all(&i915->drm);\n\tacomp->base.ops = &i915_audio_component_ops;\n\tacomp->base.dev = i915_kdev;\n\tBUILD_BUG_ON(MAX_PORTS != I915_MAX_PORTS);\n\tfor (i = 0; i < ARRAY_SIZE(acomp->aud_sample_rate); i++)\n\t\tacomp->aud_sample_rate[i] = 0;\n\ti915->display.audio.component = acomp;\n\tdrm_modeset_unlock_all(&i915->drm);\n\n\treturn 0;\n}\n\nstatic void i915_audio_component_unbind(struct device *i915_kdev,\n\t\t\t\t\tstruct device *hda_kdev, void *data)\n{\n\tstruct i915_audio_component *acomp = data;\n\tstruct drm_i915_private *i915 = kdev_to_i915(i915_kdev);\n\n\tdrm_modeset_lock_all(&i915->drm);\n\tacomp->base.ops = NULL;\n\tacomp->base.dev = NULL;\n\ti915->display.audio.component = NULL;\n\tdrm_modeset_unlock_all(&i915->drm);\n\n\tdevice_link_remove(hda_kdev, i915_kdev);\n\n\tif (i915->display.audio.power_refcount)\n\t\tdrm_err(&i915->drm, \"audio power refcount %d after unbind\\n\",\n\t\t\ti915->display.audio.power_refcount);\n}\n\nstatic const struct component_ops i915_audio_component_bind_ops = {\n\t.bind\t= i915_audio_component_bind,\n\t.unbind\t= i915_audio_component_unbind,\n};\n\n#define AUD_FREQ_TMODE_SHIFT\t14\n#define AUD_FREQ_4T\t\t0\n#define AUD_FREQ_8T\t\t(2 << AUD_FREQ_TMODE_SHIFT)\n#define AUD_FREQ_PULLCLKS(x)\t(((x) & 0x3) << 11)\n#define AUD_FREQ_BCLK_96M\tBIT(4)\n\n#define AUD_FREQ_GEN12          (AUD_FREQ_8T | AUD_FREQ_PULLCLKS(0) | AUD_FREQ_BCLK_96M)\n#define AUD_FREQ_TGL_BROKEN     (AUD_FREQ_8T | AUD_FREQ_PULLCLKS(2) | AUD_FREQ_BCLK_96M)\n\n \nstatic void i915_audio_component_init(struct drm_i915_private *i915)\n{\n\tu32 aud_freq, aud_freq_init;\n\tint ret;\n\n\tret = component_add_typed(i915->drm.dev,\n\t\t\t\t  &i915_audio_component_bind_ops,\n\t\t\t\t  I915_COMPONENT_AUDIO);\n\tif (ret < 0) {\n\t\tdrm_err(&i915->drm,\n\t\t\t\"failed to add audio component (%d)\\n\", ret);\n\t\t \n\t\treturn;\n\t}\n\n\tif (DISPLAY_VER(i915) >= 9) {\n\t\taud_freq_init = intel_de_read(i915, AUD_FREQ_CNTRL);\n\n\t\tif (DISPLAY_VER(i915) >= 12)\n\t\t\taud_freq = AUD_FREQ_GEN12;\n\t\telse\n\t\t\taud_freq = aud_freq_init;\n\n\t\t \n\t\tif ((IS_TIGERLAKE(i915) || IS_ROCKETLAKE(i915)) &&\n\t\t    aud_freq_init != AUD_FREQ_TGL_BROKEN)\n\t\t\taud_freq = aud_freq_init;\n\n\t\tdrm_dbg_kms(&i915->drm, \"use AUD_FREQ_CNTRL of 0x%x (init value 0x%x)\\n\",\n\t\t\t    aud_freq, aud_freq_init);\n\n\t\ti915->display.audio.freq_cntrl = aud_freq;\n\t}\n\n\t \n\tintel_audio_cdclk_change_post(i915);\n\n\ti915->display.audio.component_registered = true;\n}\n\n \nstatic void i915_audio_component_cleanup(struct drm_i915_private *i915)\n{\n\tif (!i915->display.audio.component_registered)\n\t\treturn;\n\n\tcomponent_del(i915->drm.dev, &i915_audio_component_bind_ops);\n\ti915->display.audio.component_registered = false;\n}\n\n \nvoid intel_audio_init(struct drm_i915_private *i915)\n{\n\tif (intel_lpe_audio_init(i915) < 0)\n\t\ti915_audio_component_init(i915);\n}\n\n \nvoid intel_audio_deinit(struct drm_i915_private *i915)\n{\n\tif (i915->display.audio.lpe.platdev != NULL)\n\t\tintel_lpe_audio_teardown(i915);\n\telse\n\t\ti915_audio_component_cleanup(i915);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}