{
  "module_name": "g4x_dp.c",
  "hash_id": "4ddf774d3285f40dcc85b3733250ef7f468273e942ec19acbc2f081144d31ad9",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/i915/display/g4x_dp.c",
  "human_readable_source": "\n \n\n#include <linux/string_helpers.h>\n\n#include \"g4x_dp.h\"\n#include \"i915_reg.h\"\n#include \"intel_audio.h\"\n#include \"intel_backlight.h\"\n#include \"intel_connector.h\"\n#include \"intel_crtc.h\"\n#include \"intel_de.h\"\n#include \"intel_display_power.h\"\n#include \"intel_display_types.h\"\n#include \"intel_dp.h\"\n#include \"intel_dp_aux.h\"\n#include \"intel_dp_link_training.h\"\n#include \"intel_dpio_phy.h\"\n#include \"intel_fifo_underrun.h\"\n#include \"intel_hdmi.h\"\n#include \"intel_hotplug.h\"\n#include \"intel_pch_display.h\"\n#include \"intel_pps.h\"\n#include \"vlv_sideband.h\"\n\nstatic const struct dpll g4x_dpll[] = {\n\t{ .dot = 162000, .p1 = 2, .p2 = 10, .n = 2, .m1 = 23, .m2 = 8, },\n\t{ .dot = 270000, .p1 = 1, .p2 = 10, .n = 1, .m1 = 14, .m2 = 2, },\n};\n\nstatic const struct dpll pch_dpll[] = {\n\t{ .dot = 162000, .p1 = 2, .p2 = 10, .n = 1, .m1 = 12, .m2 = 9, },\n\t{ .dot = 270000, .p1 = 1, .p2 = 10, .n = 2, .m1 = 14, .m2 = 8, },\n};\n\nstatic const struct dpll vlv_dpll[] = {\n\t{ .dot = 162000, .p1 = 3, .p2 = 2, .n = 5, .m1 = 3, .m2 = 81, },\n\t{ .dot = 270000, .p1 = 2, .p2 = 2, .n = 1, .m1 = 2, .m2 = 27, },\n};\n\nstatic const struct dpll chv_dpll[] = {\n\t \n\t{ .dot = 162000, .p1 = 4, .p2 = 2, .n = 1, .m1 = 2, .m2 = 0x819999a   },\n\t{ .dot = 270000, .p1 = 4, .p2 = 1, .n = 1, .m1 = 2, .m2 = 0x6c00000   },\n};\n\nconst struct dpll *vlv_get_dpll(struct drm_i915_private *i915)\n{\n\treturn IS_CHERRYVIEW(i915) ? &chv_dpll[0] : &vlv_dpll[0];\n}\n\nvoid g4x_dp_set_clock(struct intel_encoder *encoder,\n\t\t      struct intel_crtc_state *pipe_config)\n{\n\tstruct drm_i915_private *dev_priv = to_i915(encoder->base.dev);\n\tconst struct dpll *divisor = NULL;\n\tint i, count = 0;\n\n\tif (IS_G4X(dev_priv)) {\n\t\tdivisor = g4x_dpll;\n\t\tcount = ARRAY_SIZE(g4x_dpll);\n\t} else if (HAS_PCH_SPLIT(dev_priv)) {\n\t\tdivisor = pch_dpll;\n\t\tcount = ARRAY_SIZE(pch_dpll);\n\t} else if (IS_CHERRYVIEW(dev_priv)) {\n\t\tdivisor = chv_dpll;\n\t\tcount = ARRAY_SIZE(chv_dpll);\n\t} else if (IS_VALLEYVIEW(dev_priv)) {\n\t\tdivisor = vlv_dpll;\n\t\tcount = ARRAY_SIZE(vlv_dpll);\n\t}\n\n\tif (divisor && count) {\n\t\tfor (i = 0; i < count; i++) {\n\t\t\tif (pipe_config->port_clock == divisor[i].dot) {\n\t\t\t\tpipe_config->dpll = divisor[i];\n\t\t\t\tpipe_config->clock_set = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n}\n\nstatic void intel_dp_prepare(struct intel_encoder *encoder,\n\t\t\t     const struct intel_crtc_state *pipe_config)\n{\n\tstruct drm_i915_private *dev_priv = to_i915(encoder->base.dev);\n\tstruct intel_dp *intel_dp = enc_to_intel_dp(encoder);\n\tenum port port = encoder->port;\n\tstruct intel_crtc *crtc = to_intel_crtc(pipe_config->uapi.crtc);\n\tconst struct drm_display_mode *adjusted_mode = &pipe_config->hw.adjusted_mode;\n\n\tintel_dp_set_link_params(intel_dp,\n\t\t\t\t pipe_config->port_clock,\n\t\t\t\t pipe_config->lane_count);\n\n\t \n\n\t \n\tintel_dp->DP = intel_de_read(dev_priv, intel_dp->output_reg) & DP_DETECTED;\n\n\t \n\tintel_dp->DP |= DP_VOLTAGE_0_4 | DP_PRE_EMPHASIS_0;\n\tintel_dp->DP |= DP_PORT_WIDTH(pipe_config->lane_count);\n\n\t \n\n\tif (IS_IVYBRIDGE(dev_priv) && port == PORT_A) {\n\t\tif (adjusted_mode->flags & DRM_MODE_FLAG_PHSYNC)\n\t\t\tintel_dp->DP |= DP_SYNC_HS_HIGH;\n\t\tif (adjusted_mode->flags & DRM_MODE_FLAG_PVSYNC)\n\t\t\tintel_dp->DP |= DP_SYNC_VS_HIGH;\n\t\tintel_dp->DP |= DP_LINK_TRAIN_OFF_CPT;\n\n\t\tif (drm_dp_enhanced_frame_cap(intel_dp->dpcd))\n\t\t\tintel_dp->DP |= DP_ENHANCED_FRAMING;\n\n\t\tintel_dp->DP |= DP_PIPE_SEL_IVB(crtc->pipe);\n\t} else if (HAS_PCH_CPT(dev_priv) && port != PORT_A) {\n\t\tintel_dp->DP |= DP_LINK_TRAIN_OFF_CPT;\n\n\t\tintel_de_rmw(dev_priv, TRANS_DP_CTL(crtc->pipe),\n\t\t\t     TRANS_DP_ENH_FRAMING,\n\t\t\t     pipe_config->enhanced_framing ?\n\t\t\t     TRANS_DP_ENH_FRAMING : 0);\n\t} else {\n\t\tif (IS_G4X(dev_priv) && pipe_config->limited_color_range)\n\t\t\tintel_dp->DP |= DP_COLOR_RANGE_16_235;\n\n\t\tif (adjusted_mode->flags & DRM_MODE_FLAG_PHSYNC)\n\t\t\tintel_dp->DP |= DP_SYNC_HS_HIGH;\n\t\tif (adjusted_mode->flags & DRM_MODE_FLAG_PVSYNC)\n\t\t\tintel_dp->DP |= DP_SYNC_VS_HIGH;\n\t\tintel_dp->DP |= DP_LINK_TRAIN_OFF;\n\n\t\tif (pipe_config->enhanced_framing)\n\t\t\tintel_dp->DP |= DP_ENHANCED_FRAMING;\n\n\t\tif (IS_CHERRYVIEW(dev_priv))\n\t\t\tintel_dp->DP |= DP_PIPE_SEL_CHV(crtc->pipe);\n\t\telse\n\t\t\tintel_dp->DP |= DP_PIPE_SEL(crtc->pipe);\n\t}\n}\n\nstatic void assert_dp_port(struct intel_dp *intel_dp, bool state)\n{\n\tstruct intel_digital_port *dig_port = dp_to_dig_port(intel_dp);\n\tstruct drm_i915_private *dev_priv = to_i915(dig_port->base.base.dev);\n\tbool cur_state = intel_de_read(dev_priv, intel_dp->output_reg) & DP_PORT_EN;\n\n\tI915_STATE_WARN(dev_priv, cur_state != state,\n\t\t\t\"[ENCODER:%d:%s] state assertion failure (expected %s, current %s)\\n\",\n\t\t\tdig_port->base.base.base.id, dig_port->base.base.name,\n\t\t\tstr_on_off(state), str_on_off(cur_state));\n}\n#define assert_dp_port_disabled(d) assert_dp_port((d), false)\n\nstatic void assert_edp_pll(struct drm_i915_private *dev_priv, bool state)\n{\n\tbool cur_state = intel_de_read(dev_priv, DP_A) & DP_PLL_ENABLE;\n\n\tI915_STATE_WARN(dev_priv, cur_state != state,\n\t\t\t\"eDP PLL state assertion failure (expected %s, current %s)\\n\",\n\t\t\tstr_on_off(state), str_on_off(cur_state));\n}\n#define assert_edp_pll_enabled(d) assert_edp_pll((d), true)\n#define assert_edp_pll_disabled(d) assert_edp_pll((d), false)\n\nstatic void ilk_edp_pll_on(struct intel_dp *intel_dp,\n\t\t\t   const struct intel_crtc_state *pipe_config)\n{\n\tstruct intel_crtc *crtc = to_intel_crtc(pipe_config->uapi.crtc);\n\tstruct drm_i915_private *dev_priv = to_i915(crtc->base.dev);\n\n\tassert_transcoder_disabled(dev_priv, pipe_config->cpu_transcoder);\n\tassert_dp_port_disabled(intel_dp);\n\tassert_edp_pll_disabled(dev_priv);\n\n\tdrm_dbg_kms(&dev_priv->drm, \"enabling eDP PLL for clock %d\\n\",\n\t\t    pipe_config->port_clock);\n\n\tintel_dp->DP &= ~DP_PLL_FREQ_MASK;\n\n\tif (pipe_config->port_clock == 162000)\n\t\tintel_dp->DP |= DP_PLL_FREQ_162MHZ;\n\telse\n\t\tintel_dp->DP |= DP_PLL_FREQ_270MHZ;\n\n\tintel_de_write(dev_priv, DP_A, intel_dp->DP);\n\tintel_de_posting_read(dev_priv, DP_A);\n\tudelay(500);\n\n\t \n\tif (IS_IRONLAKE(dev_priv))\n\t\tintel_wait_for_vblank_if_active(dev_priv, !crtc->pipe);\n\n\tintel_dp->DP |= DP_PLL_ENABLE;\n\n\tintel_de_write(dev_priv, DP_A, intel_dp->DP);\n\tintel_de_posting_read(dev_priv, DP_A);\n\tudelay(200);\n}\n\nstatic void ilk_edp_pll_off(struct intel_dp *intel_dp,\n\t\t\t    const struct intel_crtc_state *old_crtc_state)\n{\n\tstruct intel_crtc *crtc = to_intel_crtc(old_crtc_state->uapi.crtc);\n\tstruct drm_i915_private *dev_priv = to_i915(crtc->base.dev);\n\n\tassert_transcoder_disabled(dev_priv, old_crtc_state->cpu_transcoder);\n\tassert_dp_port_disabled(intel_dp);\n\tassert_edp_pll_enabled(dev_priv);\n\n\tdrm_dbg_kms(&dev_priv->drm, \"disabling eDP PLL\\n\");\n\n\tintel_dp->DP &= ~DP_PLL_ENABLE;\n\n\tintel_de_write(dev_priv, DP_A, intel_dp->DP);\n\tintel_de_posting_read(dev_priv, DP_A);\n\tudelay(200);\n}\n\nstatic bool cpt_dp_port_selected(struct drm_i915_private *dev_priv,\n\t\t\t\t enum port port, enum pipe *pipe)\n{\n\tenum pipe p;\n\n\tfor_each_pipe(dev_priv, p) {\n\t\tu32 val = intel_de_read(dev_priv, TRANS_DP_CTL(p));\n\n\t\tif ((val & TRANS_DP_PORT_SEL_MASK) == TRANS_DP_PORT_SEL(port)) {\n\t\t\t*pipe = p;\n\t\t\treturn true;\n\t\t}\n\t}\n\n\tdrm_dbg_kms(&dev_priv->drm, \"No pipe for DP port %c found\\n\",\n\t\t    port_name(port));\n\n\t \n\t*pipe = PIPE_A;\n\n\treturn false;\n}\n\nbool g4x_dp_port_enabled(struct drm_i915_private *dev_priv,\n\t\t\t i915_reg_t dp_reg, enum port port,\n\t\t\t enum pipe *pipe)\n{\n\tbool ret;\n\tu32 val;\n\n\tval = intel_de_read(dev_priv, dp_reg);\n\n\tret = val & DP_PORT_EN;\n\n\t \n\tif (IS_IVYBRIDGE(dev_priv) && port == PORT_A)\n\t\t*pipe = (val & DP_PIPE_SEL_MASK_IVB) >> DP_PIPE_SEL_SHIFT_IVB;\n\telse if (HAS_PCH_CPT(dev_priv) && port != PORT_A)\n\t\tret &= cpt_dp_port_selected(dev_priv, port, pipe);\n\telse if (IS_CHERRYVIEW(dev_priv))\n\t\t*pipe = (val & DP_PIPE_SEL_MASK_CHV) >> DP_PIPE_SEL_SHIFT_CHV;\n\telse\n\t\t*pipe = (val & DP_PIPE_SEL_MASK) >> DP_PIPE_SEL_SHIFT;\n\n\treturn ret;\n}\n\nstatic bool intel_dp_get_hw_state(struct intel_encoder *encoder,\n\t\t\t\t  enum pipe *pipe)\n{\n\tstruct drm_i915_private *dev_priv = to_i915(encoder->base.dev);\n\tstruct intel_dp *intel_dp = enc_to_intel_dp(encoder);\n\tintel_wakeref_t wakeref;\n\tbool ret;\n\n\twakeref = intel_display_power_get_if_enabled(dev_priv,\n\t\t\t\t\t\t     encoder->power_domain);\n\tif (!wakeref)\n\t\treturn false;\n\n\tret = g4x_dp_port_enabled(dev_priv, intel_dp->output_reg,\n\t\t\t\t  encoder->port, pipe);\n\n\tintel_display_power_put(dev_priv, encoder->power_domain, wakeref);\n\n\treturn ret;\n}\n\nstatic void g4x_dp_get_m_n(struct intel_crtc_state *crtc_state)\n{\n\tstruct intel_crtc *crtc = to_intel_crtc(crtc_state->uapi.crtc);\n\n\tif (crtc_state->has_pch_encoder) {\n\t\tintel_pch_transcoder_get_m1_n1(crtc, &crtc_state->dp_m_n);\n\t\tintel_pch_transcoder_get_m2_n2(crtc, &crtc_state->dp_m2_n2);\n\t} else {\n\t\tintel_cpu_transcoder_get_m1_n1(crtc, crtc_state->cpu_transcoder,\n\t\t\t\t\t       &crtc_state->dp_m_n);\n\t\tintel_cpu_transcoder_get_m2_n2(crtc, crtc_state->cpu_transcoder,\n\t\t\t\t\t       &crtc_state->dp_m2_n2);\n\t}\n}\n\nstatic void intel_dp_get_config(struct intel_encoder *encoder,\n\t\t\t\tstruct intel_crtc_state *pipe_config)\n{\n\tstruct drm_i915_private *dev_priv = to_i915(encoder->base.dev);\n\tstruct intel_dp *intel_dp = enc_to_intel_dp(encoder);\n\tu32 tmp, flags = 0;\n\tenum port port = encoder->port;\n\tstruct intel_crtc *crtc = to_intel_crtc(pipe_config->uapi.crtc);\n\n\tif (encoder->type == INTEL_OUTPUT_EDP)\n\t\tpipe_config->output_types |= BIT(INTEL_OUTPUT_EDP);\n\telse\n\t\tpipe_config->output_types |= BIT(INTEL_OUTPUT_DP);\n\n\ttmp = intel_de_read(dev_priv, intel_dp->output_reg);\n\n\tpipe_config->has_audio = tmp & DP_AUDIO_OUTPUT_ENABLE && port != PORT_A;\n\n\tif (HAS_PCH_CPT(dev_priv) && port != PORT_A) {\n\t\tu32 trans_dp = intel_de_read(dev_priv,\n\t\t\t\t\t     TRANS_DP_CTL(crtc->pipe));\n\n\t\tif (trans_dp & TRANS_DP_ENH_FRAMING)\n\t\t\tpipe_config->enhanced_framing = true;\n\n\t\tif (trans_dp & TRANS_DP_HSYNC_ACTIVE_HIGH)\n\t\t\tflags |= DRM_MODE_FLAG_PHSYNC;\n\t\telse\n\t\t\tflags |= DRM_MODE_FLAG_NHSYNC;\n\n\t\tif (trans_dp & TRANS_DP_VSYNC_ACTIVE_HIGH)\n\t\t\tflags |= DRM_MODE_FLAG_PVSYNC;\n\t\telse\n\t\t\tflags |= DRM_MODE_FLAG_NVSYNC;\n\t} else {\n\t\tif (tmp & DP_ENHANCED_FRAMING)\n\t\t\tpipe_config->enhanced_framing = true;\n\n\t\tif (tmp & DP_SYNC_HS_HIGH)\n\t\t\tflags |= DRM_MODE_FLAG_PHSYNC;\n\t\telse\n\t\t\tflags |= DRM_MODE_FLAG_NHSYNC;\n\n\t\tif (tmp & DP_SYNC_VS_HIGH)\n\t\t\tflags |= DRM_MODE_FLAG_PVSYNC;\n\t\telse\n\t\t\tflags |= DRM_MODE_FLAG_NVSYNC;\n\t}\n\n\tpipe_config->hw.adjusted_mode.flags |= flags;\n\n\tif (IS_G4X(dev_priv) && tmp & DP_COLOR_RANGE_16_235)\n\t\tpipe_config->limited_color_range = true;\n\n\tpipe_config->lane_count =\n\t\t((tmp & DP_PORT_WIDTH_MASK) >> DP_PORT_WIDTH_SHIFT) + 1;\n\n\tg4x_dp_get_m_n(pipe_config);\n\n\tif (port == PORT_A) {\n\t\tif ((intel_de_read(dev_priv, DP_A) & DP_PLL_FREQ_MASK) == DP_PLL_FREQ_162MHZ)\n\t\t\tpipe_config->port_clock = 162000;\n\t\telse\n\t\t\tpipe_config->port_clock = 270000;\n\t}\n\n\tpipe_config->hw.adjusted_mode.crtc_clock =\n\t\tintel_dotclock_calculate(pipe_config->port_clock,\n\t\t\t\t\t &pipe_config->dp_m_n);\n\n\tif (intel_dp_is_edp(intel_dp))\n\t\tintel_edp_fixup_vbt_bpp(encoder, pipe_config->pipe_bpp);\n\n\tintel_audio_codec_get_config(encoder, pipe_config);\n}\n\nstatic void\nintel_dp_link_down(struct intel_encoder *encoder,\n\t\t   const struct intel_crtc_state *old_crtc_state)\n{\n\tstruct drm_i915_private *dev_priv = to_i915(encoder->base.dev);\n\tstruct intel_dp *intel_dp = enc_to_intel_dp(encoder);\n\tstruct intel_crtc *crtc = to_intel_crtc(old_crtc_state->uapi.crtc);\n\tenum port port = encoder->port;\n\n\tif (drm_WARN_ON(&dev_priv->drm,\n\t\t\t(intel_de_read(dev_priv, intel_dp->output_reg) &\n\t\t\t DP_PORT_EN) == 0))\n\t\treturn;\n\n\tdrm_dbg_kms(&dev_priv->drm, \"\\n\");\n\n\tif ((IS_IVYBRIDGE(dev_priv) && port == PORT_A) ||\n\t    (HAS_PCH_CPT(dev_priv) && port != PORT_A)) {\n\t\tintel_dp->DP &= ~DP_LINK_TRAIN_MASK_CPT;\n\t\tintel_dp->DP |= DP_LINK_TRAIN_PAT_IDLE_CPT;\n\t} else {\n\t\tintel_dp->DP &= ~DP_LINK_TRAIN_MASK;\n\t\tintel_dp->DP |= DP_LINK_TRAIN_PAT_IDLE;\n\t}\n\tintel_de_write(dev_priv, intel_dp->output_reg, intel_dp->DP);\n\tintel_de_posting_read(dev_priv, intel_dp->output_reg);\n\n\tintel_dp->DP &= ~(DP_PORT_EN | DP_AUDIO_OUTPUT_ENABLE);\n\tintel_de_write(dev_priv, intel_dp->output_reg, intel_dp->DP);\n\tintel_de_posting_read(dev_priv, intel_dp->output_reg);\n\n\t \n\tif (HAS_PCH_IBX(dev_priv) && crtc->pipe == PIPE_B && port != PORT_A) {\n\t\t \n\t\tintel_set_cpu_fifo_underrun_reporting(dev_priv, PIPE_A, false);\n\t\tintel_set_pch_fifo_underrun_reporting(dev_priv, PIPE_A, false);\n\n\t\t \n\t\tintel_dp->DP &= ~(DP_PIPE_SEL_MASK | DP_LINK_TRAIN_MASK);\n\t\tintel_dp->DP |= DP_PORT_EN | DP_PIPE_SEL(PIPE_A) |\n\t\t\tDP_LINK_TRAIN_PAT_1;\n\t\tintel_de_write(dev_priv, intel_dp->output_reg, intel_dp->DP);\n\t\tintel_de_posting_read(dev_priv, intel_dp->output_reg);\n\n\t\tintel_dp->DP &= ~DP_PORT_EN;\n\t\tintel_de_write(dev_priv, intel_dp->output_reg, intel_dp->DP);\n\t\tintel_de_posting_read(dev_priv, intel_dp->output_reg);\n\n\t\tintel_wait_for_vblank_if_active(dev_priv, PIPE_A);\n\t\tintel_set_cpu_fifo_underrun_reporting(dev_priv, PIPE_A, true);\n\t\tintel_set_pch_fifo_underrun_reporting(dev_priv, PIPE_A, true);\n\t}\n\n\tmsleep(intel_dp->pps.panel_power_down_delay);\n\n\tif (IS_VALLEYVIEW(dev_priv) || IS_CHERRYVIEW(dev_priv)) {\n\t\tintel_wakeref_t wakeref;\n\n\t\twith_intel_pps_lock(intel_dp, wakeref)\n\t\t\tintel_dp->pps.active_pipe = INVALID_PIPE;\n\t}\n}\n\nstatic void intel_disable_dp(struct intel_atomic_state *state,\n\t\t\t     struct intel_encoder *encoder,\n\t\t\t     const struct intel_crtc_state *old_crtc_state,\n\t\t\t     const struct drm_connector_state *old_conn_state)\n{\n\tstruct intel_dp *intel_dp = enc_to_intel_dp(encoder);\n\n\tintel_dp->link_trained = false;\n\n\tintel_audio_codec_disable(encoder, old_crtc_state, old_conn_state);\n\n\t \n\tintel_pps_vdd_on(intel_dp);\n\tintel_edp_backlight_off(old_conn_state);\n\tintel_dp_set_power(intel_dp, DP_SET_POWER_D3);\n\tintel_pps_off(intel_dp);\n}\n\nstatic void g4x_disable_dp(struct intel_atomic_state *state,\n\t\t\t   struct intel_encoder *encoder,\n\t\t\t   const struct intel_crtc_state *old_crtc_state,\n\t\t\t   const struct drm_connector_state *old_conn_state)\n{\n\tintel_disable_dp(state, encoder, old_crtc_state, old_conn_state);\n}\n\nstatic void vlv_disable_dp(struct intel_atomic_state *state,\n\t\t\t   struct intel_encoder *encoder,\n\t\t\t   const struct intel_crtc_state *old_crtc_state,\n\t\t\t   const struct drm_connector_state *old_conn_state)\n{\n\tintel_disable_dp(state, encoder, old_crtc_state, old_conn_state);\n}\n\nstatic void g4x_post_disable_dp(struct intel_atomic_state *state,\n\t\t\t\tstruct intel_encoder *encoder,\n\t\t\t\tconst struct intel_crtc_state *old_crtc_state,\n\t\t\t\tconst struct drm_connector_state *old_conn_state)\n{\n\tstruct intel_dp *intel_dp = enc_to_intel_dp(encoder);\n\tenum port port = encoder->port;\n\n\t \n\tintel_dp_link_down(encoder, old_crtc_state);\n\n\t \n\tif (port == PORT_A)\n\t\tilk_edp_pll_off(intel_dp, old_crtc_state);\n}\n\nstatic void vlv_post_disable_dp(struct intel_atomic_state *state,\n\t\t\t\tstruct intel_encoder *encoder,\n\t\t\t\tconst struct intel_crtc_state *old_crtc_state,\n\t\t\t\tconst struct drm_connector_state *old_conn_state)\n{\n\tintel_dp_link_down(encoder, old_crtc_state);\n}\n\nstatic void chv_post_disable_dp(struct intel_atomic_state *state,\n\t\t\t\tstruct intel_encoder *encoder,\n\t\t\t\tconst struct intel_crtc_state *old_crtc_state,\n\t\t\t\tconst struct drm_connector_state *old_conn_state)\n{\n\tstruct drm_i915_private *dev_priv = to_i915(encoder->base.dev);\n\n\tintel_dp_link_down(encoder, old_crtc_state);\n\n\tvlv_dpio_get(dev_priv);\n\n\t \n\tchv_data_lane_soft_reset(encoder, old_crtc_state, true);\n\n\tvlv_dpio_put(dev_priv);\n}\n\nstatic void\ncpt_set_link_train(struct intel_dp *intel_dp,\n\t\t   const struct intel_crtc_state *crtc_state,\n\t\t   u8 dp_train_pat)\n{\n\tstruct drm_i915_private *dev_priv = dp_to_i915(intel_dp);\n\n\tintel_dp->DP &= ~DP_LINK_TRAIN_MASK_CPT;\n\n\tswitch (intel_dp_training_pattern_symbol(dp_train_pat)) {\n\tcase DP_TRAINING_PATTERN_DISABLE:\n\t\tintel_dp->DP |= DP_LINK_TRAIN_OFF_CPT;\n\t\tbreak;\n\tcase DP_TRAINING_PATTERN_1:\n\t\tintel_dp->DP |= DP_LINK_TRAIN_PAT_1_CPT;\n\t\tbreak;\n\tcase DP_TRAINING_PATTERN_2:\n\t\tintel_dp->DP |= DP_LINK_TRAIN_PAT_2_CPT;\n\t\tbreak;\n\tdefault:\n\t\tMISSING_CASE(intel_dp_training_pattern_symbol(dp_train_pat));\n\t\treturn;\n\t}\n\n\tintel_de_write(dev_priv, intel_dp->output_reg, intel_dp->DP);\n\tintel_de_posting_read(dev_priv, intel_dp->output_reg);\n}\n\nstatic void\ng4x_set_link_train(struct intel_dp *intel_dp,\n\t\t   const struct intel_crtc_state *crtc_state,\n\t\t   u8 dp_train_pat)\n{\n\tstruct drm_i915_private *dev_priv = dp_to_i915(intel_dp);\n\n\tintel_dp->DP &= ~DP_LINK_TRAIN_MASK;\n\n\tswitch (intel_dp_training_pattern_symbol(dp_train_pat)) {\n\tcase DP_TRAINING_PATTERN_DISABLE:\n\t\tintel_dp->DP |= DP_LINK_TRAIN_OFF;\n\t\tbreak;\n\tcase DP_TRAINING_PATTERN_1:\n\t\tintel_dp->DP |= DP_LINK_TRAIN_PAT_1;\n\t\tbreak;\n\tcase DP_TRAINING_PATTERN_2:\n\t\tintel_dp->DP |= DP_LINK_TRAIN_PAT_2;\n\t\tbreak;\n\tdefault:\n\t\tMISSING_CASE(intel_dp_training_pattern_symbol(dp_train_pat));\n\t\treturn;\n\t}\n\n\tintel_de_write(dev_priv, intel_dp->output_reg, intel_dp->DP);\n\tintel_de_posting_read(dev_priv, intel_dp->output_reg);\n}\n\nstatic void intel_dp_enable_port(struct intel_dp *intel_dp,\n\t\t\t\t const struct intel_crtc_state *crtc_state)\n{\n\tstruct drm_i915_private *dev_priv = dp_to_i915(intel_dp);\n\n\t \n\n\tintel_dp_program_link_training_pattern(intel_dp, crtc_state,\n\t\t\t\t\t       DP_PHY_DPRX, DP_TRAINING_PATTERN_1);\n\n\t \n\tintel_dp->DP |= DP_PORT_EN;\n\tif (crtc_state->has_audio)\n\t\tintel_dp->DP |= DP_AUDIO_OUTPUT_ENABLE;\n\n\tintel_de_write(dev_priv, intel_dp->output_reg, intel_dp->DP);\n\tintel_de_posting_read(dev_priv, intel_dp->output_reg);\n}\n\nstatic void intel_enable_dp(struct intel_atomic_state *state,\n\t\t\t    struct intel_encoder *encoder,\n\t\t\t    const struct intel_crtc_state *pipe_config,\n\t\t\t    const struct drm_connector_state *conn_state)\n{\n\tstruct drm_i915_private *dev_priv = to_i915(encoder->base.dev);\n\tstruct intel_dp *intel_dp = enc_to_intel_dp(encoder);\n\tu32 dp_reg = intel_de_read(dev_priv, intel_dp->output_reg);\n\tintel_wakeref_t wakeref;\n\n\tif (drm_WARN_ON(&dev_priv->drm, dp_reg & DP_PORT_EN))\n\t\treturn;\n\n\twith_intel_pps_lock(intel_dp, wakeref) {\n\t\tif (IS_VALLEYVIEW(dev_priv) || IS_CHERRYVIEW(dev_priv))\n\t\t\tvlv_pps_init(encoder, pipe_config);\n\n\t\tintel_dp_enable_port(intel_dp, pipe_config);\n\n\t\tintel_pps_vdd_on_unlocked(intel_dp);\n\t\tintel_pps_on_unlocked(intel_dp);\n\t\tintel_pps_vdd_off_unlocked(intel_dp, true);\n\t}\n\n\tif (IS_VALLEYVIEW(dev_priv) || IS_CHERRYVIEW(dev_priv)) {\n\t\tunsigned int lane_mask = 0x0;\n\n\t\tif (IS_CHERRYVIEW(dev_priv))\n\t\t\tlane_mask = intel_dp_unused_lane_mask(pipe_config->lane_count);\n\n\t\tvlv_wait_port_ready(dev_priv, dp_to_dig_port(intel_dp),\n\t\t\t\t    lane_mask);\n\t}\n\n\tintel_dp_set_power(intel_dp, DP_SET_POWER_D0);\n\tintel_dp_configure_protocol_converter(intel_dp, pipe_config);\n\tintel_dp_check_frl_training(intel_dp);\n\tintel_dp_pcon_dsc_configure(intel_dp, pipe_config);\n\tintel_dp_start_link_train(intel_dp, pipe_config);\n\tintel_dp_stop_link_train(intel_dp, pipe_config);\n}\n\nstatic void g4x_enable_dp(struct intel_atomic_state *state,\n\t\t\t  struct intel_encoder *encoder,\n\t\t\t  const struct intel_crtc_state *pipe_config,\n\t\t\t  const struct drm_connector_state *conn_state)\n{\n\tintel_enable_dp(state, encoder, pipe_config, conn_state);\n\tintel_audio_codec_enable(encoder, pipe_config, conn_state);\n\tintel_edp_backlight_on(pipe_config, conn_state);\n}\n\nstatic void vlv_enable_dp(struct intel_atomic_state *state,\n\t\t\t  struct intel_encoder *encoder,\n\t\t\t  const struct intel_crtc_state *pipe_config,\n\t\t\t  const struct drm_connector_state *conn_state)\n{\n\tintel_audio_codec_enable(encoder, pipe_config, conn_state);\n\tintel_edp_backlight_on(pipe_config, conn_state);\n}\n\nstatic void g4x_pre_enable_dp(struct intel_atomic_state *state,\n\t\t\t      struct intel_encoder *encoder,\n\t\t\t      const struct intel_crtc_state *pipe_config,\n\t\t\t      const struct drm_connector_state *conn_state)\n{\n\tstruct intel_dp *intel_dp = enc_to_intel_dp(encoder);\n\tenum port port = encoder->port;\n\n\tintel_dp_prepare(encoder, pipe_config);\n\n\t \n\tif (port == PORT_A)\n\t\tilk_edp_pll_on(intel_dp, pipe_config);\n}\n\nstatic void vlv_pre_enable_dp(struct intel_atomic_state *state,\n\t\t\t      struct intel_encoder *encoder,\n\t\t\t      const struct intel_crtc_state *pipe_config,\n\t\t\t      const struct drm_connector_state *conn_state)\n{\n\tvlv_phy_pre_encoder_enable(encoder, pipe_config);\n\n\tintel_enable_dp(state, encoder, pipe_config, conn_state);\n}\n\nstatic void vlv_dp_pre_pll_enable(struct intel_atomic_state *state,\n\t\t\t\t  struct intel_encoder *encoder,\n\t\t\t\t  const struct intel_crtc_state *pipe_config,\n\t\t\t\t  const struct drm_connector_state *conn_state)\n{\n\tintel_dp_prepare(encoder, pipe_config);\n\n\tvlv_phy_pre_pll_enable(encoder, pipe_config);\n}\n\nstatic void chv_pre_enable_dp(struct intel_atomic_state *state,\n\t\t\t      struct intel_encoder *encoder,\n\t\t\t      const struct intel_crtc_state *pipe_config,\n\t\t\t      const struct drm_connector_state *conn_state)\n{\n\tchv_phy_pre_encoder_enable(encoder, pipe_config);\n\n\tintel_enable_dp(state, encoder, pipe_config, conn_state);\n\n\t \n\tchv_phy_release_cl2_override(encoder);\n}\n\nstatic void chv_dp_pre_pll_enable(struct intel_atomic_state *state,\n\t\t\t\t  struct intel_encoder *encoder,\n\t\t\t\t  const struct intel_crtc_state *pipe_config,\n\t\t\t\t  const struct drm_connector_state *conn_state)\n{\n\tintel_dp_prepare(encoder, pipe_config);\n\n\tchv_phy_pre_pll_enable(encoder, pipe_config);\n}\n\nstatic void chv_dp_post_pll_disable(struct intel_atomic_state *state,\n\t\t\t\t    struct intel_encoder *encoder,\n\t\t\t\t    const struct intel_crtc_state *old_crtc_state,\n\t\t\t\t    const struct drm_connector_state *old_conn_state)\n{\n\tchv_phy_post_pll_disable(encoder, old_crtc_state);\n}\n\nstatic u8 intel_dp_voltage_max_2(struct intel_dp *intel_dp,\n\t\t\t\t const struct intel_crtc_state *crtc_state)\n{\n\treturn DP_TRAIN_VOLTAGE_SWING_LEVEL_2;\n}\n\nstatic u8 intel_dp_voltage_max_3(struct intel_dp *intel_dp,\n\t\t\t\t const struct intel_crtc_state *crtc_state)\n{\n\treturn DP_TRAIN_VOLTAGE_SWING_LEVEL_3;\n}\n\nstatic u8 intel_dp_preemph_max_2(struct intel_dp *intel_dp)\n{\n\treturn DP_TRAIN_PRE_EMPH_LEVEL_2;\n}\n\nstatic u8 intel_dp_preemph_max_3(struct intel_dp *intel_dp)\n{\n\treturn DP_TRAIN_PRE_EMPH_LEVEL_3;\n}\n\nstatic void vlv_set_signal_levels(struct intel_encoder *encoder,\n\t\t\t\t  const struct intel_crtc_state *crtc_state)\n{\n\tstruct intel_dp *intel_dp = enc_to_intel_dp(encoder);\n\tunsigned long demph_reg_value, preemph_reg_value,\n\t\tuniqtranscale_reg_value;\n\tu8 train_set = intel_dp->train_set[0];\n\n\tswitch (train_set & DP_TRAIN_PRE_EMPHASIS_MASK) {\n\tcase DP_TRAIN_PRE_EMPH_LEVEL_0:\n\t\tpreemph_reg_value = 0x0004000;\n\t\tswitch (train_set & DP_TRAIN_VOLTAGE_SWING_MASK) {\n\t\tcase DP_TRAIN_VOLTAGE_SWING_LEVEL_0:\n\t\t\tdemph_reg_value = 0x2B405555;\n\t\t\tuniqtranscale_reg_value = 0x552AB83A;\n\t\t\tbreak;\n\t\tcase DP_TRAIN_VOLTAGE_SWING_LEVEL_1:\n\t\t\tdemph_reg_value = 0x2B404040;\n\t\t\tuniqtranscale_reg_value = 0x5548B83A;\n\t\t\tbreak;\n\t\tcase DP_TRAIN_VOLTAGE_SWING_LEVEL_2:\n\t\t\tdemph_reg_value = 0x2B245555;\n\t\t\tuniqtranscale_reg_value = 0x5560B83A;\n\t\t\tbreak;\n\t\tcase DP_TRAIN_VOLTAGE_SWING_LEVEL_3:\n\t\t\tdemph_reg_value = 0x2B405555;\n\t\t\tuniqtranscale_reg_value = 0x5598DA3A;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn;\n\t\t}\n\t\tbreak;\n\tcase DP_TRAIN_PRE_EMPH_LEVEL_1:\n\t\tpreemph_reg_value = 0x0002000;\n\t\tswitch (train_set & DP_TRAIN_VOLTAGE_SWING_MASK) {\n\t\tcase DP_TRAIN_VOLTAGE_SWING_LEVEL_0:\n\t\t\tdemph_reg_value = 0x2B404040;\n\t\t\tuniqtranscale_reg_value = 0x5552B83A;\n\t\t\tbreak;\n\t\tcase DP_TRAIN_VOLTAGE_SWING_LEVEL_1:\n\t\t\tdemph_reg_value = 0x2B404848;\n\t\t\tuniqtranscale_reg_value = 0x5580B83A;\n\t\t\tbreak;\n\t\tcase DP_TRAIN_VOLTAGE_SWING_LEVEL_2:\n\t\t\tdemph_reg_value = 0x2B404040;\n\t\t\tuniqtranscale_reg_value = 0x55ADDA3A;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn;\n\t\t}\n\t\tbreak;\n\tcase DP_TRAIN_PRE_EMPH_LEVEL_2:\n\t\tpreemph_reg_value = 0x0000000;\n\t\tswitch (train_set & DP_TRAIN_VOLTAGE_SWING_MASK) {\n\t\tcase DP_TRAIN_VOLTAGE_SWING_LEVEL_0:\n\t\t\tdemph_reg_value = 0x2B305555;\n\t\t\tuniqtranscale_reg_value = 0x5570B83A;\n\t\t\tbreak;\n\t\tcase DP_TRAIN_VOLTAGE_SWING_LEVEL_1:\n\t\t\tdemph_reg_value = 0x2B2B4040;\n\t\t\tuniqtranscale_reg_value = 0x55ADDA3A;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn;\n\t\t}\n\t\tbreak;\n\tcase DP_TRAIN_PRE_EMPH_LEVEL_3:\n\t\tpreemph_reg_value = 0x0006000;\n\t\tswitch (train_set & DP_TRAIN_VOLTAGE_SWING_MASK) {\n\t\tcase DP_TRAIN_VOLTAGE_SWING_LEVEL_0:\n\t\t\tdemph_reg_value = 0x1B405555;\n\t\t\tuniqtranscale_reg_value = 0x55ADDA3A;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\treturn;\n\t}\n\n\tvlv_set_phy_signal_level(encoder, crtc_state,\n\t\t\t\t demph_reg_value, preemph_reg_value,\n\t\t\t\t uniqtranscale_reg_value, 0);\n}\n\nstatic void chv_set_signal_levels(struct intel_encoder *encoder,\n\t\t\t\t  const struct intel_crtc_state *crtc_state)\n{\n\tstruct intel_dp *intel_dp = enc_to_intel_dp(encoder);\n\tu32 deemph_reg_value, margin_reg_value;\n\tbool uniq_trans_scale = false;\n\tu8 train_set = intel_dp->train_set[0];\n\n\tswitch (train_set & DP_TRAIN_PRE_EMPHASIS_MASK) {\n\tcase DP_TRAIN_PRE_EMPH_LEVEL_0:\n\t\tswitch (train_set & DP_TRAIN_VOLTAGE_SWING_MASK) {\n\t\tcase DP_TRAIN_VOLTAGE_SWING_LEVEL_0:\n\t\t\tdeemph_reg_value = 128;\n\t\t\tmargin_reg_value = 52;\n\t\t\tbreak;\n\t\tcase DP_TRAIN_VOLTAGE_SWING_LEVEL_1:\n\t\t\tdeemph_reg_value = 128;\n\t\t\tmargin_reg_value = 77;\n\t\t\tbreak;\n\t\tcase DP_TRAIN_VOLTAGE_SWING_LEVEL_2:\n\t\t\tdeemph_reg_value = 128;\n\t\t\tmargin_reg_value = 102;\n\t\t\tbreak;\n\t\tcase DP_TRAIN_VOLTAGE_SWING_LEVEL_3:\n\t\t\tdeemph_reg_value = 128;\n\t\t\tmargin_reg_value = 154;\n\t\t\tuniq_trans_scale = true;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn;\n\t\t}\n\t\tbreak;\n\tcase DP_TRAIN_PRE_EMPH_LEVEL_1:\n\t\tswitch (train_set & DP_TRAIN_VOLTAGE_SWING_MASK) {\n\t\tcase DP_TRAIN_VOLTAGE_SWING_LEVEL_0:\n\t\t\tdeemph_reg_value = 85;\n\t\t\tmargin_reg_value = 78;\n\t\t\tbreak;\n\t\tcase DP_TRAIN_VOLTAGE_SWING_LEVEL_1:\n\t\t\tdeemph_reg_value = 85;\n\t\t\tmargin_reg_value = 116;\n\t\t\tbreak;\n\t\tcase DP_TRAIN_VOLTAGE_SWING_LEVEL_2:\n\t\t\tdeemph_reg_value = 85;\n\t\t\tmargin_reg_value = 154;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn;\n\t\t}\n\t\tbreak;\n\tcase DP_TRAIN_PRE_EMPH_LEVEL_2:\n\t\tswitch (train_set & DP_TRAIN_VOLTAGE_SWING_MASK) {\n\t\tcase DP_TRAIN_VOLTAGE_SWING_LEVEL_0:\n\t\t\tdeemph_reg_value = 64;\n\t\t\tmargin_reg_value = 104;\n\t\t\tbreak;\n\t\tcase DP_TRAIN_VOLTAGE_SWING_LEVEL_1:\n\t\t\tdeemph_reg_value = 64;\n\t\t\tmargin_reg_value = 154;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn;\n\t\t}\n\t\tbreak;\n\tcase DP_TRAIN_PRE_EMPH_LEVEL_3:\n\t\tswitch (train_set & DP_TRAIN_VOLTAGE_SWING_MASK) {\n\t\tcase DP_TRAIN_VOLTAGE_SWING_LEVEL_0:\n\t\t\tdeemph_reg_value = 43;\n\t\t\tmargin_reg_value = 154;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\treturn;\n\t}\n\n\tchv_set_phy_signal_level(encoder, crtc_state,\n\t\t\t\t deemph_reg_value, margin_reg_value,\n\t\t\t\t uniq_trans_scale);\n}\n\nstatic u32 g4x_signal_levels(u8 train_set)\n{\n\tu32 signal_levels = 0;\n\n\tswitch (train_set & DP_TRAIN_VOLTAGE_SWING_MASK) {\n\tcase DP_TRAIN_VOLTAGE_SWING_LEVEL_0:\n\tdefault:\n\t\tsignal_levels |= DP_VOLTAGE_0_4;\n\t\tbreak;\n\tcase DP_TRAIN_VOLTAGE_SWING_LEVEL_1:\n\t\tsignal_levels |= DP_VOLTAGE_0_6;\n\t\tbreak;\n\tcase DP_TRAIN_VOLTAGE_SWING_LEVEL_2:\n\t\tsignal_levels |= DP_VOLTAGE_0_8;\n\t\tbreak;\n\tcase DP_TRAIN_VOLTAGE_SWING_LEVEL_3:\n\t\tsignal_levels |= DP_VOLTAGE_1_2;\n\t\tbreak;\n\t}\n\tswitch (train_set & DP_TRAIN_PRE_EMPHASIS_MASK) {\n\tcase DP_TRAIN_PRE_EMPH_LEVEL_0:\n\tdefault:\n\t\tsignal_levels |= DP_PRE_EMPHASIS_0;\n\t\tbreak;\n\tcase DP_TRAIN_PRE_EMPH_LEVEL_1:\n\t\tsignal_levels |= DP_PRE_EMPHASIS_3_5;\n\t\tbreak;\n\tcase DP_TRAIN_PRE_EMPH_LEVEL_2:\n\t\tsignal_levels |= DP_PRE_EMPHASIS_6;\n\t\tbreak;\n\tcase DP_TRAIN_PRE_EMPH_LEVEL_3:\n\t\tsignal_levels |= DP_PRE_EMPHASIS_9_5;\n\t\tbreak;\n\t}\n\treturn signal_levels;\n}\n\nstatic void\ng4x_set_signal_levels(struct intel_encoder *encoder,\n\t\t      const struct intel_crtc_state *crtc_state)\n{\n\tstruct drm_i915_private *dev_priv = to_i915(encoder->base.dev);\n\tstruct intel_dp *intel_dp = enc_to_intel_dp(encoder);\n\tu8 train_set = intel_dp->train_set[0];\n\tu32 signal_levels;\n\n\tsignal_levels = g4x_signal_levels(train_set);\n\n\tdrm_dbg_kms(&dev_priv->drm, \"Using signal levels %08x\\n\",\n\t\t    signal_levels);\n\n\tintel_dp->DP &= ~(DP_VOLTAGE_MASK | DP_PRE_EMPHASIS_MASK);\n\tintel_dp->DP |= signal_levels;\n\n\tintel_de_write(dev_priv, intel_dp->output_reg, intel_dp->DP);\n\tintel_de_posting_read(dev_priv, intel_dp->output_reg);\n}\n\n \nstatic u32 snb_cpu_edp_signal_levels(u8 train_set)\n{\n\tu8 signal_levels = train_set & (DP_TRAIN_VOLTAGE_SWING_MASK |\n\t\t\t\t\tDP_TRAIN_PRE_EMPHASIS_MASK);\n\n\tswitch (signal_levels) {\n\tcase DP_TRAIN_VOLTAGE_SWING_LEVEL_0 | DP_TRAIN_PRE_EMPH_LEVEL_0:\n\tcase DP_TRAIN_VOLTAGE_SWING_LEVEL_1 | DP_TRAIN_PRE_EMPH_LEVEL_0:\n\t\treturn EDP_LINK_TRAIN_400_600MV_0DB_SNB_B;\n\tcase DP_TRAIN_VOLTAGE_SWING_LEVEL_0 | DP_TRAIN_PRE_EMPH_LEVEL_1:\n\t\treturn EDP_LINK_TRAIN_400MV_3_5DB_SNB_B;\n\tcase DP_TRAIN_VOLTAGE_SWING_LEVEL_0 | DP_TRAIN_PRE_EMPH_LEVEL_2:\n\tcase DP_TRAIN_VOLTAGE_SWING_LEVEL_1 | DP_TRAIN_PRE_EMPH_LEVEL_2:\n\t\treturn EDP_LINK_TRAIN_400_600MV_6DB_SNB_B;\n\tcase DP_TRAIN_VOLTAGE_SWING_LEVEL_1 | DP_TRAIN_PRE_EMPH_LEVEL_1:\n\tcase DP_TRAIN_VOLTAGE_SWING_LEVEL_2 | DP_TRAIN_PRE_EMPH_LEVEL_1:\n\t\treturn EDP_LINK_TRAIN_600_800MV_3_5DB_SNB_B;\n\tcase DP_TRAIN_VOLTAGE_SWING_LEVEL_2 | DP_TRAIN_PRE_EMPH_LEVEL_0:\n\tcase DP_TRAIN_VOLTAGE_SWING_LEVEL_3 | DP_TRAIN_PRE_EMPH_LEVEL_0:\n\t\treturn EDP_LINK_TRAIN_800_1200MV_0DB_SNB_B;\n\tdefault:\n\t\tMISSING_CASE(signal_levels);\n\t\treturn EDP_LINK_TRAIN_400_600MV_0DB_SNB_B;\n\t}\n}\n\nstatic void\nsnb_cpu_edp_set_signal_levels(struct intel_encoder *encoder,\n\t\t\t      const struct intel_crtc_state *crtc_state)\n{\n\tstruct drm_i915_private *dev_priv = to_i915(encoder->base.dev);\n\tstruct intel_dp *intel_dp = enc_to_intel_dp(encoder);\n\tu8 train_set = intel_dp->train_set[0];\n\tu32 signal_levels;\n\n\tsignal_levels = snb_cpu_edp_signal_levels(train_set);\n\n\tdrm_dbg_kms(&dev_priv->drm, \"Using signal levels %08x\\n\",\n\t\t    signal_levels);\n\n\tintel_dp->DP &= ~EDP_LINK_TRAIN_VOL_EMP_MASK_SNB;\n\tintel_dp->DP |= signal_levels;\n\n\tintel_de_write(dev_priv, intel_dp->output_reg, intel_dp->DP);\n\tintel_de_posting_read(dev_priv, intel_dp->output_reg);\n}\n\n \nstatic u32 ivb_cpu_edp_signal_levels(u8 train_set)\n{\n\tu8 signal_levels = train_set & (DP_TRAIN_VOLTAGE_SWING_MASK |\n\t\t\t\t\tDP_TRAIN_PRE_EMPHASIS_MASK);\n\n\tswitch (signal_levels) {\n\tcase DP_TRAIN_VOLTAGE_SWING_LEVEL_0 | DP_TRAIN_PRE_EMPH_LEVEL_0:\n\t\treturn EDP_LINK_TRAIN_400MV_0DB_IVB;\n\tcase DP_TRAIN_VOLTAGE_SWING_LEVEL_0 | DP_TRAIN_PRE_EMPH_LEVEL_1:\n\t\treturn EDP_LINK_TRAIN_400MV_3_5DB_IVB;\n\tcase DP_TRAIN_VOLTAGE_SWING_LEVEL_0 | DP_TRAIN_PRE_EMPH_LEVEL_2:\n\tcase DP_TRAIN_VOLTAGE_SWING_LEVEL_1 | DP_TRAIN_PRE_EMPH_LEVEL_2:\n\t\treturn EDP_LINK_TRAIN_400MV_6DB_IVB;\n\n\tcase DP_TRAIN_VOLTAGE_SWING_LEVEL_1 | DP_TRAIN_PRE_EMPH_LEVEL_0:\n\t\treturn EDP_LINK_TRAIN_600MV_0DB_IVB;\n\tcase DP_TRAIN_VOLTAGE_SWING_LEVEL_1 | DP_TRAIN_PRE_EMPH_LEVEL_1:\n\t\treturn EDP_LINK_TRAIN_600MV_3_5DB_IVB;\n\n\tcase DP_TRAIN_VOLTAGE_SWING_LEVEL_2 | DP_TRAIN_PRE_EMPH_LEVEL_0:\n\t\treturn EDP_LINK_TRAIN_800MV_0DB_IVB;\n\tcase DP_TRAIN_VOLTAGE_SWING_LEVEL_2 | DP_TRAIN_PRE_EMPH_LEVEL_1:\n\t\treturn EDP_LINK_TRAIN_800MV_3_5DB_IVB;\n\n\tdefault:\n\t\tMISSING_CASE(signal_levels);\n\t\treturn EDP_LINK_TRAIN_500MV_0DB_IVB;\n\t}\n}\n\nstatic void\nivb_cpu_edp_set_signal_levels(struct intel_encoder *encoder,\n\t\t\t      const struct intel_crtc_state *crtc_state)\n{\n\tstruct drm_i915_private *dev_priv = to_i915(encoder->base.dev);\n\tstruct intel_dp *intel_dp = enc_to_intel_dp(encoder);\n\tu8 train_set = intel_dp->train_set[0];\n\tu32 signal_levels;\n\n\tsignal_levels = ivb_cpu_edp_signal_levels(train_set);\n\n\tdrm_dbg_kms(&dev_priv->drm, \"Using signal levels %08x\\n\",\n\t\t    signal_levels);\n\n\tintel_dp->DP &= ~EDP_LINK_TRAIN_VOL_EMP_MASK_IVB;\n\tintel_dp->DP |= signal_levels;\n\n\tintel_de_write(dev_priv, intel_dp->output_reg, intel_dp->DP);\n\tintel_de_posting_read(dev_priv, intel_dp->output_reg);\n}\n\n \nstatic enum intel_hotplug_state\nintel_dp_hotplug(struct intel_encoder *encoder,\n\t\t struct intel_connector *connector)\n{\n\tstruct intel_dp *intel_dp = enc_to_intel_dp(encoder);\n\tstruct drm_modeset_acquire_ctx ctx;\n\tenum intel_hotplug_state state;\n\tint ret;\n\n\tif (intel_dp->compliance.test_active &&\n\t    intel_dp->compliance.test_type == DP_TEST_LINK_PHY_TEST_PATTERN) {\n\t\tintel_dp_phy_test(encoder);\n\t\t \n\t\treturn INTEL_HOTPLUG_UNCHANGED;\n\t}\n\n\tstate = intel_encoder_hotplug(encoder, connector);\n\n\tdrm_modeset_acquire_init(&ctx, 0);\n\n\tfor (;;) {\n\t\tret = intel_dp_retrain_link(encoder, &ctx);\n\n\t\tif (ret == -EDEADLK) {\n\t\t\tdrm_modeset_backoff(&ctx);\n\t\t\tcontinue;\n\t\t}\n\n\t\tbreak;\n\t}\n\n\tdrm_modeset_drop_locks(&ctx);\n\tdrm_modeset_acquire_fini(&ctx);\n\tdrm_WARN(encoder->base.dev, ret,\n\t\t \"Acquiring modeset locks failed with %i\\n\", ret);\n\n\t \n\tif (state == INTEL_HOTPLUG_UNCHANGED && !connector->hotplug_retries)\n\t\tstate = INTEL_HOTPLUG_RETRY;\n\n\treturn state;\n}\n\nstatic bool ibx_digital_port_connected(struct intel_encoder *encoder)\n{\n\tstruct drm_i915_private *dev_priv = to_i915(encoder->base.dev);\n\tu32 bit = dev_priv->display.hotplug.pch_hpd[encoder->hpd_pin];\n\n\treturn intel_de_read(dev_priv, SDEISR) & bit;\n}\n\nstatic bool g4x_digital_port_connected(struct intel_encoder *encoder)\n{\n\tstruct drm_i915_private *dev_priv = to_i915(encoder->base.dev);\n\tu32 bit;\n\n\tswitch (encoder->hpd_pin) {\n\tcase HPD_PORT_B:\n\t\tbit = PORTB_HOTPLUG_LIVE_STATUS_G4X;\n\t\tbreak;\n\tcase HPD_PORT_C:\n\t\tbit = PORTC_HOTPLUG_LIVE_STATUS_G4X;\n\t\tbreak;\n\tcase HPD_PORT_D:\n\t\tbit = PORTD_HOTPLUG_LIVE_STATUS_G4X;\n\t\tbreak;\n\tdefault:\n\t\tMISSING_CASE(encoder->hpd_pin);\n\t\treturn false;\n\t}\n\n\treturn intel_de_read(dev_priv, PORT_HOTPLUG_STAT) & bit;\n}\n\nstatic bool ilk_digital_port_connected(struct intel_encoder *encoder)\n{\n\tstruct drm_i915_private *dev_priv = to_i915(encoder->base.dev);\n\tu32 bit = dev_priv->display.hotplug.hpd[encoder->hpd_pin];\n\n\treturn intel_de_read(dev_priv, DEISR) & bit;\n}\n\nstatic void intel_dp_encoder_destroy(struct drm_encoder *encoder)\n{\n\tintel_dp_encoder_flush_work(encoder);\n\n\tdrm_encoder_cleanup(encoder);\n\tkfree(enc_to_dig_port(to_intel_encoder(encoder)));\n}\n\nenum pipe vlv_active_pipe(struct intel_dp *intel_dp)\n{\n\tstruct drm_i915_private *dev_priv = dp_to_i915(intel_dp);\n\tstruct intel_encoder *encoder = &dp_to_dig_port(intel_dp)->base;\n\tenum pipe pipe;\n\n\tif (g4x_dp_port_enabled(dev_priv, intel_dp->output_reg,\n\t\t\t\tencoder->port, &pipe))\n\t\treturn pipe;\n\n\treturn INVALID_PIPE;\n}\n\nstatic void intel_dp_encoder_reset(struct drm_encoder *encoder)\n{\n\tstruct drm_i915_private *dev_priv = to_i915(encoder->dev);\n\tstruct intel_dp *intel_dp = enc_to_intel_dp(to_intel_encoder(encoder));\n\n\tintel_dp->DP = intel_de_read(dev_priv, intel_dp->output_reg);\n\n\tintel_dp->reset_link_params = true;\n\n\tif (IS_VALLEYVIEW(dev_priv) || IS_CHERRYVIEW(dev_priv)) {\n\t\tintel_wakeref_t wakeref;\n\n\t\twith_intel_pps_lock(intel_dp, wakeref)\n\t\t\tintel_dp->pps.active_pipe = vlv_active_pipe(intel_dp);\n\t}\n\n\tintel_pps_encoder_reset(intel_dp);\n}\n\nstatic const struct drm_encoder_funcs intel_dp_enc_funcs = {\n\t.reset = intel_dp_encoder_reset,\n\t.destroy = intel_dp_encoder_destroy,\n};\n\nbool g4x_dp_init(struct drm_i915_private *dev_priv,\n\t\t i915_reg_t output_reg, enum port port)\n{\n\tconst struct intel_bios_encoder_data *devdata;\n\tstruct intel_digital_port *dig_port;\n\tstruct intel_encoder *intel_encoder;\n\tstruct drm_encoder *encoder;\n\tstruct intel_connector *intel_connector;\n\n\tif (!assert_port_valid(dev_priv, port))\n\t\treturn false;\n\n\tdevdata = intel_bios_encoder_data_lookup(dev_priv, port);\n\n\t \n\tif (!devdata)\n\t\tdrm_dbg_kms(&dev_priv->drm, \"No VBT child device for DP-%c\\n\",\n\t\t\t    port_name(port));\n\n\tdig_port = kzalloc(sizeof(*dig_port), GFP_KERNEL);\n\tif (!dig_port)\n\t\treturn false;\n\n\tdig_port->aux_ch = AUX_CH_NONE;\n\n\tintel_connector = intel_connector_alloc();\n\tif (!intel_connector)\n\t\tgoto err_connector_alloc;\n\n\tintel_encoder = &dig_port->base;\n\tencoder = &intel_encoder->base;\n\n\tintel_encoder->devdata = devdata;\n\n\tmutex_init(&dig_port->hdcp_mutex);\n\n\tif (drm_encoder_init(&dev_priv->drm, &intel_encoder->base,\n\t\t\t     &intel_dp_enc_funcs, DRM_MODE_ENCODER_TMDS,\n\t\t\t     \"DP %c\", port_name(port)))\n\t\tgoto err_encoder_init;\n\n\tintel_encoder->hotplug = intel_dp_hotplug;\n\tintel_encoder->compute_config = intel_dp_compute_config;\n\tintel_encoder->get_hw_state = intel_dp_get_hw_state;\n\tintel_encoder->get_config = intel_dp_get_config;\n\tintel_encoder->sync_state = intel_dp_sync_state;\n\tintel_encoder->initial_fastset_check = intel_dp_initial_fastset_check;\n\tintel_encoder->update_pipe = intel_backlight_update;\n\tintel_encoder->suspend = intel_dp_encoder_suspend;\n\tintel_encoder->shutdown = intel_dp_encoder_shutdown;\n\tif (IS_CHERRYVIEW(dev_priv)) {\n\t\tintel_encoder->pre_pll_enable = chv_dp_pre_pll_enable;\n\t\tintel_encoder->pre_enable = chv_pre_enable_dp;\n\t\tintel_encoder->enable = vlv_enable_dp;\n\t\tintel_encoder->disable = vlv_disable_dp;\n\t\tintel_encoder->post_disable = chv_post_disable_dp;\n\t\tintel_encoder->post_pll_disable = chv_dp_post_pll_disable;\n\t} else if (IS_VALLEYVIEW(dev_priv)) {\n\t\tintel_encoder->pre_pll_enable = vlv_dp_pre_pll_enable;\n\t\tintel_encoder->pre_enable = vlv_pre_enable_dp;\n\t\tintel_encoder->enable = vlv_enable_dp;\n\t\tintel_encoder->disable = vlv_disable_dp;\n\t\tintel_encoder->post_disable = vlv_post_disable_dp;\n\t} else {\n\t\tintel_encoder->pre_enable = g4x_pre_enable_dp;\n\t\tintel_encoder->enable = g4x_enable_dp;\n\t\tintel_encoder->disable = g4x_disable_dp;\n\t\tintel_encoder->post_disable = g4x_post_disable_dp;\n\t}\n\n\tif ((IS_IVYBRIDGE(dev_priv) && port == PORT_A) ||\n\t    (HAS_PCH_CPT(dev_priv) && port != PORT_A))\n\t\tdig_port->dp.set_link_train = cpt_set_link_train;\n\telse\n\t\tdig_port->dp.set_link_train = g4x_set_link_train;\n\n\tif (IS_CHERRYVIEW(dev_priv))\n\t\tintel_encoder->set_signal_levels = chv_set_signal_levels;\n\telse if (IS_VALLEYVIEW(dev_priv))\n\t\tintel_encoder->set_signal_levels = vlv_set_signal_levels;\n\telse if (IS_IVYBRIDGE(dev_priv) && port == PORT_A)\n\t\tintel_encoder->set_signal_levels = ivb_cpu_edp_set_signal_levels;\n\telse if (IS_SANDYBRIDGE(dev_priv) && port == PORT_A)\n\t\tintel_encoder->set_signal_levels = snb_cpu_edp_set_signal_levels;\n\telse\n\t\tintel_encoder->set_signal_levels = g4x_set_signal_levels;\n\n\tif (IS_VALLEYVIEW(dev_priv) || IS_CHERRYVIEW(dev_priv) ||\n\t    (HAS_PCH_SPLIT(dev_priv) && port != PORT_A)) {\n\t\tdig_port->dp.preemph_max = intel_dp_preemph_max_3;\n\t\tdig_port->dp.voltage_max = intel_dp_voltage_max_3;\n\t} else {\n\t\tdig_port->dp.preemph_max = intel_dp_preemph_max_2;\n\t\tdig_port->dp.voltage_max = intel_dp_voltage_max_2;\n\t}\n\n\tdig_port->dp.output_reg = output_reg;\n\tdig_port->max_lanes = 4;\n\n\tintel_encoder->type = INTEL_OUTPUT_DP;\n\tintel_encoder->power_domain = intel_display_power_ddi_lanes_domain(dev_priv, port);\n\tif (IS_CHERRYVIEW(dev_priv)) {\n\t\tif (port == PORT_D)\n\t\t\tintel_encoder->pipe_mask = BIT(PIPE_C);\n\t\telse\n\t\t\tintel_encoder->pipe_mask = BIT(PIPE_A) | BIT(PIPE_B);\n\t} else {\n\t\tintel_encoder->pipe_mask = ~0;\n\t}\n\tintel_encoder->cloneable = 0;\n\tintel_encoder->port = port;\n\tintel_encoder->hpd_pin = intel_hpd_pin_default(dev_priv, port);\n\n\tdig_port->hpd_pulse = intel_dp_hpd_pulse;\n\n\tif (HAS_GMCH(dev_priv)) {\n\t\tdig_port->connected = g4x_digital_port_connected;\n\t} else {\n\t\tif (port == PORT_A)\n\t\t\tdig_port->connected = ilk_digital_port_connected;\n\t\telse\n\t\t\tdig_port->connected = ibx_digital_port_connected;\n\t}\n\n\tif (port != PORT_A)\n\t\tintel_infoframe_init(dig_port);\n\n\tdig_port->aux_ch = intel_dp_aux_ch(intel_encoder);\n\tif (dig_port->aux_ch == AUX_CH_NONE)\n\t\tgoto err_init_connector;\n\n\tif (!intel_dp_init_connector(dig_port, intel_connector))\n\t\tgoto err_init_connector;\n\n\treturn true;\n\nerr_init_connector:\n\tdrm_encoder_cleanup(encoder);\nerr_encoder_init:\n\tkfree(intel_connector);\nerr_connector_alloc:\n\tkfree(dig_port);\n\treturn false;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}