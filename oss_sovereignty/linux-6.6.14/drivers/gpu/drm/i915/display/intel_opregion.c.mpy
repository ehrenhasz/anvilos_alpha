{
  "module_name": "intel_opregion.c",
  "hash_id": "0f87dfc296bfdaa71f00796cd1406463cc507d830361eb8f986dd3ed30a59df3",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/i915/display/intel_opregion.c",
  "human_readable_source": " \n\n#include <linux/acpi.h>\n#include <linux/dmi.h>\n#include <linux/firmware.h>\n#include <acpi/video.h>\n\n#include <drm/drm_edid.h>\n\n#include \"i915_drv.h\"\n#include \"intel_acpi.h\"\n#include \"intel_backlight.h\"\n#include \"intel_display_types.h\"\n#include \"intel_opregion.h\"\n#include \"intel_pci_config.h\"\n\n#define OPREGION_HEADER_OFFSET 0\n#define OPREGION_ACPI_OFFSET   0x100\n#define   ACPI_CLID 0x01ac  \n#define   ACPI_CDCK 0x01b0  \n#define OPREGION_SWSCI_OFFSET  0x200\n#define OPREGION_ASLE_OFFSET   0x300\n#define OPREGION_VBT_OFFSET    0x400\n#define OPREGION_ASLE_EXT_OFFSET\t0x1C00\n\n#define OPREGION_SIGNATURE \"IntelGraphicsMem\"\n#define MBOX_ACPI\t\tBIT(0)\t \n#define MBOX_SWSCI\t\tBIT(1)\t \n#define MBOX_ASLE\t\tBIT(2)\t \n#define MBOX_ASLE_EXT\t\tBIT(4)\t \n#define MBOX_BACKLIGHT\t\tBIT(5)\t \n\n#define PCON_HEADLESS_SKU\tBIT(13)\n\nstruct opregion_header {\n\tu8 signature[16];\n\tu32 size;\n\tstruct {\n\t\tu8 rsvd;\n\t\tu8 revision;\n\t\tu8 minor;\n\t\tu8 major;\n\t}  __packed over;\n\tu8 bios_ver[32];\n\tu8 vbios_ver[16];\n\tu8 driver_ver[16];\n\tu32 mboxes;\n\tu32 driver_model;\n\tu32 pcon;\n\tu8 dver[32];\n\tu8 rsvd[124];\n} __packed;\n\n \nstruct opregion_acpi {\n\tu32 drdy;        \n\tu32 csts;        \n\tu32 cevt;        \n\tu8 rsvd1[20];\n\tu32 didl[8];     \n\tu32 cpdl[8];     \n\tu32 cadl[8];     \n\tu32 nadl[8];     \n\tu32 aslp;        \n\tu32 tidx;        \n\tu32 chpd;        \n\tu32 clid;        \n\tu32 cdck;        \n\tu32 sxsw;        \n\tu32 evts;        \n\tu32 cnot;        \n\tu32 nrdy;        \n\tu32 did2[7];\t \n\tu32 cpd2[7];\t \n\tu8 rsvd2[4];\n} __packed;\n\n \nstruct opregion_swsci {\n\tu32 scic;        \n\tu32 parm;        \n\tu32 dslp;        \n\tu8 rsvd[244];\n} __packed;\n\n \nstruct opregion_asle {\n\tu32 ardy;        \n\tu32 aslc;        \n\tu32 tche;        \n\tu32 alsi;        \n\tu32 bclp;        \n\tu32 pfit;        \n\tu32 cblv;        \n\tu16 bclm[20];    \n\tu32 cpfm;        \n\tu32 epfm;        \n\tu8 plut[74];     \n\tu32 pfmb;        \n\tu32 cddv;        \n\tu32 pcft;        \n\tu32 srot;        \n\tu32 iuer;        \n\tu64 fdss;\n\tu32 fdsp;\n\tu32 stat;\n\tu64 rvda;\t \n\tu32 rvds;\t \n\tu8 rsvd[58];\n} __packed;\n\n \nstruct opregion_asle_ext {\n\tu32 phed;\t \n\tu8 bddc[256];\t \n\tu8 rsvd[764];\n} __packed;\n\n \n#define ASLE_ARDY_READY\t\t(1 << 0)\n#define ASLE_ARDY_NOT_READY\t(0 << 0)\n\n \n#define ASLC_SET_ALS_ILLUM\t\t(1 << 0)\n#define ASLC_SET_BACKLIGHT\t\t(1 << 1)\n#define ASLC_SET_PFIT\t\t\t(1 << 2)\n#define ASLC_SET_PWM_FREQ\t\t(1 << 3)\n#define ASLC_SUPPORTED_ROTATION_ANGLES\t(1 << 4)\n#define ASLC_BUTTON_ARRAY\t\t(1 << 5)\n#define ASLC_CONVERTIBLE_INDICATOR\t(1 << 6)\n#define ASLC_DOCKING_INDICATOR\t\t(1 << 7)\n#define ASLC_ISCT_STATE_CHANGE\t\t(1 << 8)\n#define ASLC_REQ_MSK\t\t\t0x1ff\n \n#define ASLC_ALS_ILLUM_FAILED\t\t(1 << 10)\n#define ASLC_BACKLIGHT_FAILED\t\t(1 << 12)\n#define ASLC_PFIT_FAILED\t\t(1 << 14)\n#define ASLC_PWM_FREQ_FAILED\t\t(1 << 16)\n#define ASLC_ROTATION_ANGLES_FAILED\t(1 << 18)\n#define ASLC_BUTTON_ARRAY_FAILED\t(1 << 20)\n#define ASLC_CONVERTIBLE_FAILED\t\t(1 << 22)\n#define ASLC_DOCKING_FAILED\t\t(1 << 24)\n#define ASLC_ISCT_STATE_FAILED\t\t(1 << 26)\n\n \n#define ASLE_TCHE_ALS_EN\t(1 << 0)\n#define ASLE_TCHE_BLC_EN\t(1 << 1)\n#define ASLE_TCHE_PFIT_EN\t(1 << 2)\n#define ASLE_TCHE_PFMB_EN\t(1 << 3)\n\n \n#define ASLE_BCLP_VALID                (1<<31)\n#define ASLE_BCLP_MSK          (~(1<<31))\n\n \n#define ASLE_PFIT_VALID         (1<<31)\n#define ASLE_PFIT_CENTER (1<<0)\n#define ASLE_PFIT_STRETCH_TEXT (1<<1)\n#define ASLE_PFIT_STRETCH_GFX (1<<2)\n\n \n#define ASLE_PFMB_BRIGHTNESS_MASK (0xff)\n#define ASLE_PFMB_BRIGHTNESS_VALID (1<<8)\n#define ASLE_PFMB_PWM_MASK (0x7ffffe00)\n#define ASLE_PFMB_PWM_VALID (1<<31)\n\n#define ASLE_CBLV_VALID         (1<<31)\n\n \n#define ASLE_IUER_DOCKING\t\t(1 << 7)\n#define ASLE_IUER_CONVERTIBLE\t\t(1 << 6)\n#define ASLE_IUER_ROTATION_LOCK_BTN\t(1 << 4)\n#define ASLE_IUER_VOLUME_DOWN_BTN\t(1 << 3)\n#define ASLE_IUER_VOLUME_UP_BTN\t\t(1 << 2)\n#define ASLE_IUER_WINDOWS_BTN\t\t(1 << 1)\n#define ASLE_IUER_POWER_BTN\t\t(1 << 0)\n\n#define ASLE_PHED_EDID_VALID_MASK\t0x3\n\n \n#define SWSCI_SCIC_INDICATOR\t\t(1 << 0)\n#define SWSCI_SCIC_MAIN_FUNCTION_SHIFT\t1\n#define SWSCI_SCIC_MAIN_FUNCTION_MASK\t(0xf << 1)\n#define SWSCI_SCIC_SUB_FUNCTION_SHIFT\t8\n#define SWSCI_SCIC_SUB_FUNCTION_MASK\t(0xff << 8)\n#define SWSCI_SCIC_EXIT_PARAMETER_SHIFT\t8\n#define SWSCI_SCIC_EXIT_PARAMETER_MASK\t(0xff << 8)\n#define SWSCI_SCIC_EXIT_STATUS_SHIFT\t5\n#define SWSCI_SCIC_EXIT_STATUS_MASK\t(7 << 5)\n#define SWSCI_SCIC_EXIT_STATUS_SUCCESS\t1\n\n#define SWSCI_FUNCTION_CODE(main, sub) \\\n\t((main) << SWSCI_SCIC_MAIN_FUNCTION_SHIFT | \\\n\t (sub) << SWSCI_SCIC_SUB_FUNCTION_SHIFT)\n\n \n#define SWSCI_GBDA\t\t\t4\n#define SWSCI_GBDA_SUPPORTED_CALLS\tSWSCI_FUNCTION_CODE(SWSCI_GBDA, 0)\n#define SWSCI_GBDA_REQUESTED_CALLBACKS\tSWSCI_FUNCTION_CODE(SWSCI_GBDA, 1)\n#define SWSCI_GBDA_BOOT_DISPLAY_PREF\tSWSCI_FUNCTION_CODE(SWSCI_GBDA, 4)\n#define SWSCI_GBDA_PANEL_DETAILS\tSWSCI_FUNCTION_CODE(SWSCI_GBDA, 5)\n#define SWSCI_GBDA_TV_STANDARD\t\tSWSCI_FUNCTION_CODE(SWSCI_GBDA, 6)\n#define SWSCI_GBDA_INTERNAL_GRAPHICS\tSWSCI_FUNCTION_CODE(SWSCI_GBDA, 7)\n#define SWSCI_GBDA_SPREAD_SPECTRUM\tSWSCI_FUNCTION_CODE(SWSCI_GBDA, 10)\n\n \n#define SWSCI_SBCB\t\t\t6\n#define SWSCI_SBCB_SUPPORTED_CALLBACKS\tSWSCI_FUNCTION_CODE(SWSCI_SBCB, 0)\n#define SWSCI_SBCB_INIT_COMPLETION\tSWSCI_FUNCTION_CODE(SWSCI_SBCB, 1)\n#define SWSCI_SBCB_PRE_HIRES_SET_MODE\tSWSCI_FUNCTION_CODE(SWSCI_SBCB, 3)\n#define SWSCI_SBCB_POST_HIRES_SET_MODE\tSWSCI_FUNCTION_CODE(SWSCI_SBCB, 4)\n#define SWSCI_SBCB_DISPLAY_SWITCH\tSWSCI_FUNCTION_CODE(SWSCI_SBCB, 5)\n#define SWSCI_SBCB_SET_TV_FORMAT\tSWSCI_FUNCTION_CODE(SWSCI_SBCB, 6)\n#define SWSCI_SBCB_ADAPTER_POWER_STATE\tSWSCI_FUNCTION_CODE(SWSCI_SBCB, 7)\n#define SWSCI_SBCB_DISPLAY_POWER_STATE\tSWSCI_FUNCTION_CODE(SWSCI_SBCB, 8)\n#define SWSCI_SBCB_SET_BOOT_DISPLAY\tSWSCI_FUNCTION_CODE(SWSCI_SBCB, 9)\n#define SWSCI_SBCB_SET_PANEL_DETAILS\tSWSCI_FUNCTION_CODE(SWSCI_SBCB, 10)\n#define SWSCI_SBCB_SET_INTERNAL_GFX\tSWSCI_FUNCTION_CODE(SWSCI_SBCB, 11)\n#define SWSCI_SBCB_POST_HIRES_TO_DOS_FS\tSWSCI_FUNCTION_CODE(SWSCI_SBCB, 16)\n#define SWSCI_SBCB_SUSPEND_RESUME\tSWSCI_FUNCTION_CODE(SWSCI_SBCB, 17)\n#define SWSCI_SBCB_SET_SPREAD_SPECTRUM\tSWSCI_FUNCTION_CODE(SWSCI_SBCB, 18)\n#define SWSCI_SBCB_POST_VBE_PM\t\tSWSCI_FUNCTION_CODE(SWSCI_SBCB, 19)\n#define SWSCI_SBCB_ENABLE_DISABLE_AUDIO\tSWSCI_FUNCTION_CODE(SWSCI_SBCB, 21)\n\n#define MAX_DSLP\t1500\n\nstatic int check_swsci_function(struct drm_i915_private *i915, u32 function)\n{\n\tstruct opregion_swsci *swsci = i915->display.opregion.swsci;\n\tu32 main_function, sub_function;\n\n\tif (!swsci)\n\t\treturn -ENODEV;\n\n\tmain_function = (function & SWSCI_SCIC_MAIN_FUNCTION_MASK) >>\n\t\tSWSCI_SCIC_MAIN_FUNCTION_SHIFT;\n\tsub_function = (function & SWSCI_SCIC_SUB_FUNCTION_MASK) >>\n\t\tSWSCI_SCIC_SUB_FUNCTION_SHIFT;\n\n\t \n\tif (main_function == SWSCI_SBCB) {\n\t\tif ((i915->display.opregion.swsci_sbcb_sub_functions &\n\t\t     (1 << sub_function)) == 0)\n\t\t\treturn -EINVAL;\n\t} else if (main_function == SWSCI_GBDA) {\n\t\tif ((i915->display.opregion.swsci_gbda_sub_functions &\n\t\t     (1 << sub_function)) == 0)\n\t\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int swsci(struct drm_i915_private *dev_priv,\n\t\t u32 function, u32 parm, u32 *parm_out)\n{\n\tstruct opregion_swsci *swsci = dev_priv->display.opregion.swsci;\n\tstruct pci_dev *pdev = to_pci_dev(dev_priv->drm.dev);\n\tu32 scic, dslp;\n\tu16 swsci_val;\n\tint ret;\n\n\tret = check_swsci_function(dev_priv, function);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tdslp = swsci->dslp;\n\tif (!dslp) {\n\t\t \n\t\tdslp = 50;\n\t} else if (dslp > MAX_DSLP) {\n\t\t \n\t\tDRM_INFO_ONCE(\"ACPI BIOS requests an excessive sleep of %u ms, \"\n\t\t\t      \"using %u ms instead\\n\", dslp, MAX_DSLP);\n\t\tdslp = MAX_DSLP;\n\t}\n\n\t \n\tscic = swsci->scic;\n\tif (scic & SWSCI_SCIC_INDICATOR) {\n\t\tdrm_dbg(&dev_priv->drm, \"SWSCI request already in progress\\n\");\n\t\treturn -EBUSY;\n\t}\n\n\tscic = function | SWSCI_SCIC_INDICATOR;\n\n\tswsci->parm = parm;\n\tswsci->scic = scic;\n\n\t \n\tpci_read_config_word(pdev, SWSCI, &swsci_val);\n\tif (!(swsci_val & SWSCI_SCISEL) || (swsci_val & SWSCI_GSSCIE)) {\n\t\tswsci_val |= SWSCI_SCISEL;\n\t\tswsci_val &= ~SWSCI_GSSCIE;\n\t\tpci_write_config_word(pdev, SWSCI, swsci_val);\n\t}\n\n\t \n\tswsci_val |= SWSCI_GSSCIE;\n\tpci_write_config_word(pdev, SWSCI, swsci_val);\n\n\t \n#define C (((scic = swsci->scic) & SWSCI_SCIC_INDICATOR) == 0)\n\tif (wait_for(C, dslp)) {\n\t\tdrm_dbg(&dev_priv->drm, \"SWSCI request timed out\\n\");\n\t\treturn -ETIMEDOUT;\n\t}\n\n\tscic = (scic & SWSCI_SCIC_EXIT_STATUS_MASK) >>\n\t\tSWSCI_SCIC_EXIT_STATUS_SHIFT;\n\n\t \n\tif (scic != SWSCI_SCIC_EXIT_STATUS_SUCCESS) {\n\t\tdrm_dbg(&dev_priv->drm, \"SWSCI request error %u\\n\", scic);\n\t\treturn -EIO;\n\t}\n\n\tif (parm_out)\n\t\t*parm_out = swsci->parm;\n\n\treturn 0;\n\n#undef C\n}\n\n#define DISPLAY_TYPE_CRT\t\t\t0\n#define DISPLAY_TYPE_TV\t\t\t\t1\n#define DISPLAY_TYPE_EXTERNAL_FLAT_PANEL\t2\n#define DISPLAY_TYPE_INTERNAL_FLAT_PANEL\t3\n\nint intel_opregion_notify_encoder(struct intel_encoder *intel_encoder,\n\t\t\t\t  bool enable)\n{\n\tstruct drm_i915_private *dev_priv = to_i915(intel_encoder->base.dev);\n\tu32 parm = 0;\n\tu32 type = 0;\n\tu32 port;\n\tint ret;\n\n\t \n\tif (!HAS_DDI(dev_priv))\n\t\treturn 0;\n\n\t \n\tret = check_swsci_function(dev_priv, SWSCI_SBCB_DISPLAY_POWER_STATE);\n\tif (ret)\n\t\treturn ret;\n\n\tif (intel_encoder->type == INTEL_OUTPUT_DSI)\n\t\tport = 0;\n\telse\n\t\tport = intel_encoder->port;\n\n\tif (port == PORT_E)  {\n\t\tport = 0;\n\t} else {\n\t\tparm |= 1 << port;\n\t\tport++;\n\t}\n\n\t \n\tif (port > 4) {\n\t\tdrm_dbg_kms(&dev_priv->drm,\n\t\t\t    \"[ENCODER:%d:%s] port %c (index %u) out of bounds for display power state notification\\n\",\n\t\t\t    intel_encoder->base.base.id, intel_encoder->base.name,\n\t\t\t    port_name(intel_encoder->port), port);\n\t\treturn -EINVAL;\n\t}\n\n\tif (!enable)\n\t\tparm |= 4 << 8;\n\n\tswitch (intel_encoder->type) {\n\tcase INTEL_OUTPUT_ANALOG:\n\t\ttype = DISPLAY_TYPE_CRT;\n\t\tbreak;\n\tcase INTEL_OUTPUT_DDI:\n\tcase INTEL_OUTPUT_DP:\n\tcase INTEL_OUTPUT_HDMI:\n\tcase INTEL_OUTPUT_DP_MST:\n\t\ttype = DISPLAY_TYPE_EXTERNAL_FLAT_PANEL;\n\t\tbreak;\n\tcase INTEL_OUTPUT_EDP:\n\tcase INTEL_OUTPUT_DSI:\n\t\ttype = DISPLAY_TYPE_INTERNAL_FLAT_PANEL;\n\t\tbreak;\n\tdefault:\n\t\tdrm_WARN_ONCE(&dev_priv->drm, 1,\n\t\t\t      \"unsupported intel_encoder type %d\\n\",\n\t\t\t      intel_encoder->type);\n\t\treturn -EINVAL;\n\t}\n\n\tparm |= type << (16 + port * 3);\n\n\treturn swsci(dev_priv, SWSCI_SBCB_DISPLAY_POWER_STATE, parm, NULL);\n}\n\nstatic const struct {\n\tpci_power_t pci_power_state;\n\tu32 parm;\n} power_state_map[] = {\n\t{ PCI_D0,\t0x00 },\n\t{ PCI_D1,\t0x01 },\n\t{ PCI_D2,\t0x02 },\n\t{ PCI_D3hot,\t0x04 },\n\t{ PCI_D3cold,\t0x04 },\n};\n\nint intel_opregion_notify_adapter(struct drm_i915_private *dev_priv,\n\t\t\t\t  pci_power_t state)\n{\n\tint i;\n\n\tif (!HAS_DDI(dev_priv))\n\t\treturn 0;\n\n\tfor (i = 0; i < ARRAY_SIZE(power_state_map); i++) {\n\t\tif (state == power_state_map[i].pci_power_state)\n\t\t\treturn swsci(dev_priv, SWSCI_SBCB_ADAPTER_POWER_STATE,\n\t\t\t\t     power_state_map[i].parm, NULL);\n\t}\n\n\treturn -EINVAL;\n}\n\nstatic u32 asle_set_backlight(struct drm_i915_private *dev_priv, u32 bclp)\n{\n\tstruct intel_connector *connector;\n\tstruct drm_connector_list_iter conn_iter;\n\tstruct opregion_asle *asle = dev_priv->display.opregion.asle;\n\n\tdrm_dbg(&dev_priv->drm, \"bclp = 0x%08x\\n\", bclp);\n\n\tif (acpi_video_get_backlight_type() == acpi_backlight_native) {\n\t\tdrm_dbg_kms(&dev_priv->drm,\n\t\t\t    \"opregion backlight request ignored\\n\");\n\t\treturn 0;\n\t}\n\n\tif (!(bclp & ASLE_BCLP_VALID))\n\t\treturn ASLC_BACKLIGHT_FAILED;\n\n\tbclp &= ASLE_BCLP_MSK;\n\tif (bclp > 255)\n\t\treturn ASLC_BACKLIGHT_FAILED;\n\n\tdrm_modeset_lock(&dev_priv->drm.mode_config.connection_mutex, NULL);\n\n\t \n\tdrm_dbg_kms(&dev_priv->drm, \"updating opregion backlight %d/255\\n\",\n\t\t    bclp);\n\tdrm_connector_list_iter_begin(&dev_priv->drm, &conn_iter);\n\tfor_each_intel_connector_iter(connector, &conn_iter)\n\t\tintel_backlight_set_acpi(connector->base.state, bclp, 255);\n\tdrm_connector_list_iter_end(&conn_iter);\n\tasle->cblv = DIV_ROUND_UP(bclp * 100, 255) | ASLE_CBLV_VALID;\n\n\tdrm_modeset_unlock(&dev_priv->drm.mode_config.connection_mutex);\n\n\n\treturn 0;\n}\n\nstatic u32 asle_set_als_illum(struct drm_i915_private *dev_priv, u32 alsi)\n{\n\t \n\tdrm_dbg(&dev_priv->drm, \"Illum is not supported\\n\");\n\treturn ASLC_ALS_ILLUM_FAILED;\n}\n\nstatic u32 asle_set_pwm_freq(struct drm_i915_private *dev_priv, u32 pfmb)\n{\n\tdrm_dbg(&dev_priv->drm, \"PWM freq is not supported\\n\");\n\treturn ASLC_PWM_FREQ_FAILED;\n}\n\nstatic u32 asle_set_pfit(struct drm_i915_private *dev_priv, u32 pfit)\n{\n\t \n\tdrm_dbg(&dev_priv->drm, \"Pfit is not supported\\n\");\n\treturn ASLC_PFIT_FAILED;\n}\n\nstatic u32 asle_set_supported_rotation_angles(struct drm_i915_private *dev_priv, u32 srot)\n{\n\tdrm_dbg(&dev_priv->drm, \"SROT is not supported\\n\");\n\treturn ASLC_ROTATION_ANGLES_FAILED;\n}\n\nstatic u32 asle_set_button_array(struct drm_i915_private *dev_priv, u32 iuer)\n{\n\tif (!iuer)\n\t\tdrm_dbg(&dev_priv->drm,\n\t\t\t\"Button array event is not supported (nothing)\\n\");\n\tif (iuer & ASLE_IUER_ROTATION_LOCK_BTN)\n\t\tdrm_dbg(&dev_priv->drm,\n\t\t\t\"Button array event is not supported (rotation lock)\\n\");\n\tif (iuer & ASLE_IUER_VOLUME_DOWN_BTN)\n\t\tdrm_dbg(&dev_priv->drm,\n\t\t\t\"Button array event is not supported (volume down)\\n\");\n\tif (iuer & ASLE_IUER_VOLUME_UP_BTN)\n\t\tdrm_dbg(&dev_priv->drm,\n\t\t\t\"Button array event is not supported (volume up)\\n\");\n\tif (iuer & ASLE_IUER_WINDOWS_BTN)\n\t\tdrm_dbg(&dev_priv->drm,\n\t\t\t\"Button array event is not supported (windows)\\n\");\n\tif (iuer & ASLE_IUER_POWER_BTN)\n\t\tdrm_dbg(&dev_priv->drm,\n\t\t\t\"Button array event is not supported (power)\\n\");\n\n\treturn ASLC_BUTTON_ARRAY_FAILED;\n}\n\nstatic u32 asle_set_convertible(struct drm_i915_private *dev_priv, u32 iuer)\n{\n\tif (iuer & ASLE_IUER_CONVERTIBLE)\n\t\tdrm_dbg(&dev_priv->drm,\n\t\t\t\"Convertible is not supported (clamshell)\\n\");\n\telse\n\t\tdrm_dbg(&dev_priv->drm,\n\t\t\t\"Convertible is not supported (slate)\\n\");\n\n\treturn ASLC_CONVERTIBLE_FAILED;\n}\n\nstatic u32 asle_set_docking(struct drm_i915_private *dev_priv, u32 iuer)\n{\n\tif (iuer & ASLE_IUER_DOCKING)\n\t\tdrm_dbg(&dev_priv->drm, \"Docking is not supported (docked)\\n\");\n\telse\n\t\tdrm_dbg(&dev_priv->drm,\n\t\t\t\"Docking is not supported (undocked)\\n\");\n\n\treturn ASLC_DOCKING_FAILED;\n}\n\nstatic u32 asle_isct_state(struct drm_i915_private *dev_priv)\n{\n\tdrm_dbg(&dev_priv->drm, \"ISCT is not supported\\n\");\n\treturn ASLC_ISCT_STATE_FAILED;\n}\n\nstatic void asle_work(struct work_struct *work)\n{\n\tstruct intel_opregion *opregion =\n\t\tcontainer_of(work, struct intel_opregion, asle_work);\n\tstruct drm_i915_private *dev_priv =\n\t\tcontainer_of(opregion, struct drm_i915_private, display.opregion);\n\tstruct opregion_asle *asle = dev_priv->display.opregion.asle;\n\tu32 aslc_stat = 0;\n\tu32 aslc_req;\n\n\tif (!asle)\n\t\treturn;\n\n\taslc_req = asle->aslc;\n\n\tif (!(aslc_req & ASLC_REQ_MSK)) {\n\t\tdrm_dbg(&dev_priv->drm,\n\t\t\t\"No request on ASLC interrupt 0x%08x\\n\", aslc_req);\n\t\treturn;\n\t}\n\n\tif (aslc_req & ASLC_SET_ALS_ILLUM)\n\t\taslc_stat |= asle_set_als_illum(dev_priv, asle->alsi);\n\n\tif (aslc_req & ASLC_SET_BACKLIGHT)\n\t\taslc_stat |= asle_set_backlight(dev_priv, asle->bclp);\n\n\tif (aslc_req & ASLC_SET_PFIT)\n\t\taslc_stat |= asle_set_pfit(dev_priv, asle->pfit);\n\n\tif (aslc_req & ASLC_SET_PWM_FREQ)\n\t\taslc_stat |= asle_set_pwm_freq(dev_priv, asle->pfmb);\n\n\tif (aslc_req & ASLC_SUPPORTED_ROTATION_ANGLES)\n\t\taslc_stat |= asle_set_supported_rotation_angles(dev_priv,\n\t\t\t\t\t\t\tasle->srot);\n\n\tif (aslc_req & ASLC_BUTTON_ARRAY)\n\t\taslc_stat |= asle_set_button_array(dev_priv, asle->iuer);\n\n\tif (aslc_req & ASLC_CONVERTIBLE_INDICATOR)\n\t\taslc_stat |= asle_set_convertible(dev_priv, asle->iuer);\n\n\tif (aslc_req & ASLC_DOCKING_INDICATOR)\n\t\taslc_stat |= asle_set_docking(dev_priv, asle->iuer);\n\n\tif (aslc_req & ASLC_ISCT_STATE_CHANGE)\n\t\taslc_stat |= asle_isct_state(dev_priv);\n\n\tasle->aslc = aslc_stat;\n}\n\nvoid intel_opregion_asle_intr(struct drm_i915_private *dev_priv)\n{\n\tif (dev_priv->display.opregion.asle)\n\t\tqueue_work(dev_priv->unordered_wq,\n\t\t\t   &dev_priv->display.opregion.asle_work);\n}\n\n#define ACPI_EV_DISPLAY_SWITCH (1<<0)\n#define ACPI_EV_LID            (1<<1)\n#define ACPI_EV_DOCK           (1<<2)\n\n \nstatic int intel_opregion_video_event(struct notifier_block *nb,\n\t\t\t\t      unsigned long val, void *data)\n{\n\tstruct intel_opregion *opregion = container_of(nb, struct intel_opregion,\n\t\t\t\t\t\t       acpi_notifier);\n\tstruct acpi_bus_event *event = data;\n\tstruct opregion_acpi *acpi;\n\tint ret = NOTIFY_OK;\n\n\tif (strcmp(event->device_class, ACPI_VIDEO_CLASS) != 0)\n\t\treturn NOTIFY_DONE;\n\n\tacpi = opregion->acpi;\n\n\tif (event->type == 0x80 && ((acpi->cevt & 1) == 0))\n\t\tret = NOTIFY_BAD;\n\n\tacpi->csts = 0;\n\n\treturn ret;\n}\n\n \n\nstatic void set_did(struct intel_opregion *opregion, int i, u32 val)\n{\n\tif (i < ARRAY_SIZE(opregion->acpi->didl)) {\n\t\topregion->acpi->didl[i] = val;\n\t} else {\n\t\ti -= ARRAY_SIZE(opregion->acpi->didl);\n\n\t\tif (WARN_ON(i >= ARRAY_SIZE(opregion->acpi->did2)))\n\t\t\treturn;\n\n\t\topregion->acpi->did2[i] = val;\n\t}\n}\n\nstatic void intel_didl_outputs(struct drm_i915_private *dev_priv)\n{\n\tstruct intel_opregion *opregion = &dev_priv->display.opregion;\n\tstruct intel_connector *connector;\n\tstruct drm_connector_list_iter conn_iter;\n\tint i = 0, max_outputs;\n\n\t \n\tmax_outputs = ARRAY_SIZE(opregion->acpi->didl) +\n\t\tARRAY_SIZE(opregion->acpi->did2);\n\n\tintel_acpi_device_id_update(dev_priv);\n\n\tdrm_connector_list_iter_begin(&dev_priv->drm, &conn_iter);\n\tfor_each_intel_connector_iter(connector, &conn_iter) {\n\t\tif (i < max_outputs)\n\t\t\tset_did(opregion, i, connector->acpi_device_id);\n\t\ti++;\n\t}\n\tdrm_connector_list_iter_end(&conn_iter);\n\n\tdrm_dbg_kms(&dev_priv->drm, \"%d outputs detected\\n\", i);\n\n\tif (i > max_outputs)\n\t\tdrm_err(&dev_priv->drm,\n\t\t\t\"More than %d outputs in connector list\\n\",\n\t\t\tmax_outputs);\n\n\t \n\tif (i < max_outputs)\n\t\tset_did(opregion, i, 0);\n}\n\nstatic void intel_setup_cadls(struct drm_i915_private *dev_priv)\n{\n\tstruct intel_opregion *opregion = &dev_priv->display.opregion;\n\tstruct intel_connector *connector;\n\tstruct drm_connector_list_iter conn_iter;\n\tint i = 0;\n\n\t \n\tdrm_connector_list_iter_begin(&dev_priv->drm, &conn_iter);\n\tfor_each_intel_connector_iter(connector, &conn_iter) {\n\t\tif (i >= ARRAY_SIZE(opregion->acpi->cadl))\n\t\t\tbreak;\n\t\topregion->acpi->cadl[i++] = connector->acpi_device_id;\n\t}\n\tdrm_connector_list_iter_end(&conn_iter);\n\n\t \n\tif (i < ARRAY_SIZE(opregion->acpi->cadl))\n\t\topregion->acpi->cadl[i] = 0;\n}\n\nstatic void swsci_setup(struct drm_i915_private *dev_priv)\n{\n\tstruct intel_opregion *opregion = &dev_priv->display.opregion;\n\tbool requested_callbacks = false;\n\tu32 tmp;\n\n\t \n\topregion->swsci_gbda_sub_functions = 1;\n\topregion->swsci_sbcb_sub_functions = 1;\n\n\t \n\tif (swsci(dev_priv, SWSCI_GBDA_SUPPORTED_CALLS, 0, &tmp) == 0) {\n\t\t \n\t\ttmp <<= 1;\n\t\topregion->swsci_gbda_sub_functions |= tmp;\n\t}\n\n\t \n\tif (swsci(dev_priv, SWSCI_GBDA_REQUESTED_CALLBACKS, 0, &tmp) == 0) {\n\t\t \n\t\topregion->swsci_sbcb_sub_functions |= tmp;\n\t\trequested_callbacks = true;\n\t}\n\n\t \n\tif (swsci(dev_priv, SWSCI_SBCB_SUPPORTED_CALLBACKS, 0, &tmp) == 0) {\n\t\t \n\t\tu32 low = tmp & 0x7ff;\n\t\tu32 high = tmp & ~0xfff;  \n\t\ttmp = (high << 4) | (low << 1) | 1;\n\n\t\t \n\t\tif (requested_callbacks) {\n\t\t\tu32 req = opregion->swsci_sbcb_sub_functions;\n\t\t\tif ((req & tmp) != req)\n\t\t\t\tdrm_dbg(&dev_priv->drm,\n\t\t\t\t\t\"SWSCI BIOS requested (%08x) SBCB callbacks that are not supported (%08x)\\n\",\n\t\t\t\t\treq, tmp);\n\t\t\t \n\t\t\t \n\t\t} else {\n\t\t\topregion->swsci_sbcb_sub_functions |= tmp;\n\t\t}\n\t}\n\n\tdrm_dbg(&dev_priv->drm,\n\t\t\"SWSCI GBDA callbacks %08x, SBCB callbacks %08x\\n\",\n\t\topregion->swsci_gbda_sub_functions,\n\t\topregion->swsci_sbcb_sub_functions);\n}\n\nstatic int intel_no_opregion_vbt_callback(const struct dmi_system_id *id)\n{\n\tDRM_DEBUG_KMS(\"Falling back to manually reading VBT from \"\n\t\t      \"VBIOS ROM for %s\\n\", id->ident);\n\treturn 1;\n}\n\nstatic const struct dmi_system_id intel_no_opregion_vbt[] = {\n\t{\n\t\t.callback = intel_no_opregion_vbt_callback,\n\t\t.ident = \"ThinkCentre A57\",\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"LENOVO\"),\n\t\t\tDMI_MATCH(DMI_PRODUCT_NAME, \"97027RG\"),\n\t\t},\n\t},\n\t{ }\n};\n\nstatic int intel_load_vbt_firmware(struct drm_i915_private *dev_priv)\n{\n\tstruct intel_opregion *opregion = &dev_priv->display.opregion;\n\tconst struct firmware *fw = NULL;\n\tconst char *name = dev_priv->params.vbt_firmware;\n\tint ret;\n\n\tif (!name || !*name)\n\t\treturn -ENOENT;\n\n\tret = request_firmware(&fw, name, dev_priv->drm.dev);\n\tif (ret) {\n\t\tdrm_err(&dev_priv->drm,\n\t\t\t\"Requesting VBT firmware \\\"%s\\\" failed (%d)\\n\",\n\t\t\tname, ret);\n\t\treturn ret;\n\t}\n\n\tif (intel_bios_is_valid_vbt(fw->data, fw->size)) {\n\t\topregion->vbt_firmware = kmemdup(fw->data, fw->size, GFP_KERNEL);\n\t\tif (opregion->vbt_firmware) {\n\t\t\tdrm_dbg_kms(&dev_priv->drm,\n\t\t\t\t    \"Found valid VBT firmware \\\"%s\\\"\\n\", name);\n\t\t\topregion->vbt = opregion->vbt_firmware;\n\t\t\topregion->vbt_size = fw->size;\n\t\t\tret = 0;\n\t\t} else {\n\t\t\tret = -ENOMEM;\n\t\t}\n\t} else {\n\t\tdrm_dbg_kms(&dev_priv->drm, \"Invalid VBT firmware \\\"%s\\\"\\n\",\n\t\t\t    name);\n\t\tret = -EINVAL;\n\t}\n\n\trelease_firmware(fw);\n\n\treturn ret;\n}\n\nint intel_opregion_setup(struct drm_i915_private *dev_priv)\n{\n\tstruct intel_opregion *opregion = &dev_priv->display.opregion;\n\tstruct pci_dev *pdev = to_pci_dev(dev_priv->drm.dev);\n\tu32 asls, mboxes;\n\tchar buf[sizeof(OPREGION_SIGNATURE)];\n\tint err = 0;\n\tvoid *base;\n\tconst void *vbt;\n\tu32 vbt_size;\n\n\tBUILD_BUG_ON(sizeof(struct opregion_header) != 0x100);\n\tBUILD_BUG_ON(sizeof(struct opregion_acpi) != 0x100);\n\tBUILD_BUG_ON(sizeof(struct opregion_swsci) != 0x100);\n\tBUILD_BUG_ON(sizeof(struct opregion_asle) != 0x100);\n\tBUILD_BUG_ON(sizeof(struct opregion_asle_ext) != 0x400);\n\n\tpci_read_config_dword(pdev, ASLS, &asls);\n\tdrm_dbg(&dev_priv->drm, \"graphic opregion physical addr: 0x%x\\n\",\n\t\tasls);\n\tif (asls == 0) {\n\t\tdrm_dbg(&dev_priv->drm, \"ACPI OpRegion not supported!\\n\");\n\t\treturn -ENOTSUPP;\n\t}\n\n\tINIT_WORK(&opregion->asle_work, asle_work);\n\n\tbase = memremap(asls, OPREGION_SIZE, MEMREMAP_WB);\n\tif (!base)\n\t\treturn -ENOMEM;\n\n\tmemcpy(buf, base, sizeof(buf));\n\n\tif (memcmp(buf, OPREGION_SIGNATURE, 16)) {\n\t\tdrm_dbg(&dev_priv->drm, \"opregion signature mismatch\\n\");\n\t\terr = -EINVAL;\n\t\tgoto err_out;\n\t}\n\topregion->header = base;\n\topregion->lid_state = base + ACPI_CLID;\n\n\tdrm_dbg(&dev_priv->drm, \"ACPI OpRegion version %u.%u.%u\\n\",\n\t\topregion->header->over.major,\n\t\topregion->header->over.minor,\n\t\topregion->header->over.revision);\n\n\tmboxes = opregion->header->mboxes;\n\tif (mboxes & MBOX_ACPI) {\n\t\tdrm_dbg(&dev_priv->drm, \"Public ACPI methods supported\\n\");\n\t\topregion->acpi = base + OPREGION_ACPI_OFFSET;\n\t\t \n\t\topregion->acpi->chpd = 1;\n\t}\n\n\tif (mboxes & MBOX_SWSCI) {\n\t\tu8 major = opregion->header->over.major;\n\n\t\tif (major >= 3) {\n\t\t\tdrm_err(&dev_priv->drm, \"SWSCI Mailbox #2 present for opregion v3.x, ignoring\\n\");\n\t\t} else {\n\t\t\tif (major >= 2)\n\t\t\t\tdrm_dbg(&dev_priv->drm, \"SWSCI Mailbox #2 present for opregion v2.x\\n\");\n\t\t\tdrm_dbg(&dev_priv->drm, \"SWSCI supported\\n\");\n\t\t\topregion->swsci = base + OPREGION_SWSCI_OFFSET;\n\t\t\tswsci_setup(dev_priv);\n\t\t}\n\t}\n\n\tif (mboxes & MBOX_ASLE) {\n\t\tdrm_dbg(&dev_priv->drm, \"ASLE supported\\n\");\n\t\topregion->asle = base + OPREGION_ASLE_OFFSET;\n\n\t\topregion->asle->ardy = ASLE_ARDY_NOT_READY;\n\t}\n\n\tif (mboxes & MBOX_ASLE_EXT) {\n\t\tdrm_dbg(&dev_priv->drm, \"ASLE extension supported\\n\");\n\t\topregion->asle_ext = base + OPREGION_ASLE_EXT_OFFSET;\n\t}\n\n\tif (mboxes & MBOX_BACKLIGHT) {\n\t\tdrm_dbg(&dev_priv->drm, \"Mailbox #2 for backlight present\\n\");\n\t}\n\n\tif (intel_load_vbt_firmware(dev_priv) == 0)\n\t\tgoto out;\n\n\tif (dmi_check_system(intel_no_opregion_vbt))\n\t\tgoto out;\n\n\tif (opregion->header->over.major >= 2 && opregion->asle &&\n\t    opregion->asle->rvda && opregion->asle->rvds) {\n\t\tresource_size_t rvda = opregion->asle->rvda;\n\n\t\t \n\t\tif (opregion->header->over.major > 2 ||\n\t\t    opregion->header->over.minor >= 1) {\n\t\t\tdrm_WARN_ON(&dev_priv->drm, rvda < OPREGION_SIZE);\n\n\t\t\trvda += asls;\n\t\t}\n\n\t\topregion->rvda = memremap(rvda, opregion->asle->rvds,\n\t\t\t\t\t  MEMREMAP_WB);\n\n\t\tvbt = opregion->rvda;\n\t\tvbt_size = opregion->asle->rvds;\n\t\tif (intel_bios_is_valid_vbt(vbt, vbt_size)) {\n\t\t\tdrm_dbg_kms(&dev_priv->drm,\n\t\t\t\t    \"Found valid VBT in ACPI OpRegion (RVDA)\\n\");\n\t\t\topregion->vbt = vbt;\n\t\t\topregion->vbt_size = vbt_size;\n\t\t\tgoto out;\n\t\t} else {\n\t\t\tdrm_dbg_kms(&dev_priv->drm,\n\t\t\t\t    \"Invalid VBT in ACPI OpRegion (RVDA)\\n\");\n\t\t\tmemunmap(opregion->rvda);\n\t\t\topregion->rvda = NULL;\n\t\t}\n\t}\n\n\tvbt = base + OPREGION_VBT_OFFSET;\n\t \n\tvbt_size = (mboxes & MBOX_ASLE_EXT) ?\n\t\tOPREGION_ASLE_EXT_OFFSET : OPREGION_SIZE;\n\tvbt_size -= OPREGION_VBT_OFFSET;\n\tif (intel_bios_is_valid_vbt(vbt, vbt_size)) {\n\t\tdrm_dbg_kms(&dev_priv->drm,\n\t\t\t    \"Found valid VBT in ACPI OpRegion (Mailbox #4)\\n\");\n\t\topregion->vbt = vbt;\n\t\topregion->vbt_size = vbt_size;\n\t} else {\n\t\tdrm_dbg_kms(&dev_priv->drm,\n\t\t\t    \"Invalid VBT in ACPI OpRegion (Mailbox #4)\\n\");\n\t}\n\nout:\n\treturn 0;\n\nerr_out:\n\tmemunmap(base);\n\treturn err;\n}\n\nstatic int intel_use_opregion_panel_type_callback(const struct dmi_system_id *id)\n{\n\tDRM_INFO(\"Using panel type from OpRegion on %s\\n\", id->ident);\n\treturn 1;\n}\n\nstatic const struct dmi_system_id intel_use_opregion_panel_type[] = {\n\t{\n\t\t.callback = intel_use_opregion_panel_type_callback,\n\t\t.ident = \"Conrac GmbH IX45GM2\",\n\t\t.matches = {DMI_MATCH(DMI_SYS_VENDOR, \"Conrac GmbH\"),\n\t\t\t    DMI_MATCH(DMI_PRODUCT_NAME, \"IX45GM2\"),\n\t\t},\n\t},\n\t{ }\n};\n\nint\nintel_opregion_get_panel_type(struct drm_i915_private *dev_priv)\n{\n\tu32 panel_details;\n\tint ret;\n\n\tret = swsci(dev_priv, SWSCI_GBDA_PANEL_DETAILS, 0x0, &panel_details);\n\tif (ret)\n\t\treturn ret;\n\n\tret = (panel_details >> 8) & 0xff;\n\tif (ret > 0x10) {\n\t\tdrm_dbg_kms(&dev_priv->drm,\n\t\t\t    \"Invalid OpRegion panel type 0x%x\\n\", ret);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (ret == 0x0) {\n\t\tdrm_dbg_kms(&dev_priv->drm, \"No panel type in OpRegion\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\t \n\tif (!dmi_check_system(intel_use_opregion_panel_type)) {\n\t\tdrm_dbg_kms(&dev_priv->drm,\n\t\t\t    \"Ignoring OpRegion panel type (%d)\\n\", ret - 1);\n\t\treturn -ENODEV;\n\t}\n\n\treturn ret - 1;\n}\n\n \nconst struct drm_edid *intel_opregion_get_edid(struct intel_connector *intel_connector)\n{\n\tstruct drm_connector *connector = &intel_connector->base;\n\tstruct drm_i915_private *i915 = to_i915(connector->dev);\n\tstruct intel_opregion *opregion = &i915->display.opregion;\n\tconst struct drm_edid *drm_edid;\n\tconst void *edid;\n\tint len;\n\n\tif (!opregion->asle_ext)\n\t\treturn NULL;\n\n\tedid = opregion->asle_ext->bddc;\n\n\t \n\tlen = (opregion->asle_ext->phed & ASLE_PHED_EDID_VALID_MASK) * 128;\n\tif (!len || !memchr_inv(edid, 0, len))\n\t\treturn NULL;\n\n\tdrm_edid = drm_edid_alloc(edid, len);\n\n\tif (!drm_edid_valid(drm_edid)) {\n\t\tdrm_dbg_kms(&i915->drm, \"Invalid EDID in ACPI OpRegion (Mailbox #5)\\n\");\n\t\tdrm_edid_free(drm_edid);\n\t\tdrm_edid = NULL;\n\t}\n\n\treturn drm_edid;\n}\n\nbool intel_opregion_headless_sku(struct drm_i915_private *i915)\n{\n\tstruct intel_opregion *opregion = &i915->display.opregion;\n\tstruct opregion_header *header = opregion->header;\n\n\tif (!header || header->over.major < 2 ||\n\t    (header->over.major == 2 && header->over.minor < 3))\n\t\treturn false;\n\n\treturn opregion->header->pcon & PCON_HEADLESS_SKU;\n}\n\nvoid intel_opregion_register(struct drm_i915_private *i915)\n{\n\tstruct intel_opregion *opregion = &i915->display.opregion;\n\n\tif (!opregion->header)\n\t\treturn;\n\n\tif (opregion->acpi) {\n\t\topregion->acpi_notifier.notifier_call =\n\t\t\tintel_opregion_video_event;\n\t\tregister_acpi_notifier(&opregion->acpi_notifier);\n\t}\n\n\tintel_opregion_resume(i915);\n}\n\nstatic void intel_opregion_resume_display(struct drm_i915_private *i915)\n{\n\tstruct intel_opregion *opregion = &i915->display.opregion;\n\n\tif (opregion->acpi) {\n\t\tintel_didl_outputs(i915);\n\t\tintel_setup_cadls(i915);\n\n\t\t \n\t\topregion->acpi->csts = 0;\n\t\topregion->acpi->drdy = 1;\n\t}\n\n\tif (opregion->asle) {\n\t\topregion->asle->tche = ASLE_TCHE_BLC_EN;\n\t\topregion->asle->ardy = ASLE_ARDY_READY;\n\t}\n\n\t \n\tintel_dsm_get_bios_data_funcs_supported(i915);\n}\n\nvoid intel_opregion_resume(struct drm_i915_private *i915)\n{\n\tstruct intel_opregion *opregion = &i915->display.opregion;\n\n\tif (!opregion->header)\n\t\treturn;\n\n\tif (HAS_DISPLAY(i915))\n\t\tintel_opregion_resume_display(i915);\n\n\tintel_opregion_notify_adapter(i915, PCI_D0);\n}\n\nstatic void intel_opregion_suspend_display(struct drm_i915_private *i915)\n{\n\tstruct intel_opregion *opregion = &i915->display.opregion;\n\n\tif (opregion->asle)\n\t\topregion->asle->ardy = ASLE_ARDY_NOT_READY;\n\n\tcancel_work_sync(&i915->display.opregion.asle_work);\n\n\tif (opregion->acpi)\n\t\topregion->acpi->drdy = 0;\n}\n\nvoid intel_opregion_suspend(struct drm_i915_private *i915, pci_power_t state)\n{\n\tstruct intel_opregion *opregion = &i915->display.opregion;\n\n\tif (!opregion->header)\n\t\treturn;\n\n\tintel_opregion_notify_adapter(i915, state);\n\n\tif (HAS_DISPLAY(i915))\n\t\tintel_opregion_suspend_display(i915);\n}\n\nvoid intel_opregion_unregister(struct drm_i915_private *i915)\n{\n\tstruct intel_opregion *opregion = &i915->display.opregion;\n\n\tintel_opregion_suspend(i915, PCI_D1);\n\n\tif (!opregion->header)\n\t\treturn;\n\n\tif (opregion->acpi_notifier.notifier_call) {\n\t\tunregister_acpi_notifier(&opregion->acpi_notifier);\n\t\topregion->acpi_notifier.notifier_call = NULL;\n\t}\n}\n\nvoid intel_opregion_cleanup(struct drm_i915_private *i915)\n{\n\tstruct intel_opregion *opregion = &i915->display.opregion;\n\n\tif (!opregion->header)\n\t\treturn;\n\n\t \n\tmemunmap(opregion->header);\n\tif (opregion->rvda) {\n\t\tmemunmap(opregion->rvda);\n\t\topregion->rvda = NULL;\n\t}\n\tif (opregion->vbt_firmware) {\n\t\tkfree(opregion->vbt_firmware);\n\t\topregion->vbt_firmware = NULL;\n\t}\n\topregion->header = NULL;\n\topregion->acpi = NULL;\n\topregion->swsci = NULL;\n\topregion->asle = NULL;\n\topregion->asle_ext = NULL;\n\topregion->vbt = NULL;\n\topregion->lid_state = NULL;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}