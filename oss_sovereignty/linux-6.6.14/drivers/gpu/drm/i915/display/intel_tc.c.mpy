{
  "module_name": "intel_tc.c",
  "hash_id": "ec5beda58a2c92d0828b4fc08fdaaf988eb030263eb0c0d55af0c4552d6f7f3f",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/i915/display/intel_tc.c",
  "human_readable_source": "\n \n\n#include \"i915_drv.h\"\n#include \"i915_reg.h\"\n#include \"intel_atomic.h\"\n#include \"intel_cx0_phy_regs.h\"\n#include \"intel_ddi.h\"\n#include \"intel_de.h\"\n#include \"intel_display.h\"\n#include \"intel_display_driver.h\"\n#include \"intel_display_power_map.h\"\n#include \"intel_display_types.h\"\n#include \"intel_dkl_phy_regs.h\"\n#include \"intel_dp.h\"\n#include \"intel_dp_mst.h\"\n#include \"intel_mg_phy_regs.h\"\n#include \"intel_modeset_lock.h\"\n#include \"intel_tc.h\"\n\n#define DP_PIN_ASSIGNMENT_C\t0x3\n#define DP_PIN_ASSIGNMENT_D\t0x4\n#define DP_PIN_ASSIGNMENT_E\t0x5\n\nenum tc_port_mode {\n\tTC_PORT_DISCONNECTED,\n\tTC_PORT_TBT_ALT,\n\tTC_PORT_DP_ALT,\n\tTC_PORT_LEGACY,\n};\n\nstruct intel_tc_port;\n\nstruct intel_tc_phy_ops {\n\tenum intel_display_power_domain (*cold_off_domain)(struct intel_tc_port *tc);\n\tu32 (*hpd_live_status)(struct intel_tc_port *tc);\n\tbool (*is_ready)(struct intel_tc_port *tc);\n\tbool (*is_owned)(struct intel_tc_port *tc);\n\tvoid (*get_hw_state)(struct intel_tc_port *tc);\n\tbool (*connect)(struct intel_tc_port *tc, int required_lanes);\n\tvoid (*disconnect)(struct intel_tc_port *tc);\n\tvoid (*init)(struct intel_tc_port *tc);\n};\n\nstruct intel_tc_port {\n\tstruct intel_digital_port *dig_port;\n\n\tconst struct intel_tc_phy_ops *phy_ops;\n\n\tstruct mutex lock;\t \n\tintel_wakeref_t lock_wakeref;\n#if IS_ENABLED(CONFIG_DRM_I915_DEBUG_RUNTIME_PM)\n\tenum intel_display_power_domain lock_power_domain;\n#endif\n\tstruct delayed_work disconnect_phy_work;\n\tstruct delayed_work link_reset_work;\n\tint link_refcount;\n\tbool legacy_port:1;\n\tconst char *port_name;\n\tenum tc_port_mode mode;\n\tenum tc_port_mode init_mode;\n\tenum phy_fia phy_fia;\n\tu8 phy_fia_idx;\n};\n\nstatic enum intel_display_power_domain\ntc_phy_cold_off_domain(struct intel_tc_port *);\nstatic u32 tc_phy_hpd_live_status(struct intel_tc_port *tc);\nstatic bool tc_phy_is_ready(struct intel_tc_port *tc);\nstatic bool tc_phy_wait_for_ready(struct intel_tc_port *tc);\nstatic enum tc_port_mode tc_phy_get_current_mode(struct intel_tc_port *tc);\n\nstatic const char *tc_port_mode_name(enum tc_port_mode mode)\n{\n\tstatic const char * const names[] = {\n\t\t[TC_PORT_DISCONNECTED] = \"disconnected\",\n\t\t[TC_PORT_TBT_ALT] = \"tbt-alt\",\n\t\t[TC_PORT_DP_ALT] = \"dp-alt\",\n\t\t[TC_PORT_LEGACY] = \"legacy\",\n\t};\n\n\tif (WARN_ON(mode >= ARRAY_SIZE(names)))\n\t\tmode = TC_PORT_DISCONNECTED;\n\n\treturn names[mode];\n}\n\nstatic struct intel_tc_port *to_tc_port(struct intel_digital_port *dig_port)\n{\n\treturn dig_port->tc;\n}\n\nstatic struct drm_i915_private *tc_to_i915(struct intel_tc_port *tc)\n{\n\treturn to_i915(tc->dig_port->base.base.dev);\n}\n\nstatic bool intel_tc_port_in_mode(struct intel_digital_port *dig_port,\n\t\t\t\t  enum tc_port_mode mode)\n{\n\tstruct drm_i915_private *i915 = to_i915(dig_port->base.base.dev);\n\tenum phy phy = intel_port_to_phy(i915, dig_port->base.port);\n\tstruct intel_tc_port *tc = to_tc_port(dig_port);\n\n\treturn intel_phy_is_tc(i915, phy) && tc->mode == mode;\n}\n\nbool intel_tc_port_in_tbt_alt_mode(struct intel_digital_port *dig_port)\n{\n\treturn intel_tc_port_in_mode(dig_port, TC_PORT_TBT_ALT);\n}\n\nbool intel_tc_port_in_dp_alt_mode(struct intel_digital_port *dig_port)\n{\n\treturn intel_tc_port_in_mode(dig_port, TC_PORT_DP_ALT);\n}\n\nbool intel_tc_port_in_legacy_mode(struct intel_digital_port *dig_port)\n{\n\treturn intel_tc_port_in_mode(dig_port, TC_PORT_LEGACY);\n}\n\n \nbool intel_tc_cold_requires_aux_pw(struct intel_digital_port *dig_port)\n{\n\tstruct drm_i915_private *i915 = to_i915(dig_port->base.base.dev);\n\tstruct intel_tc_port *tc = to_tc_port(dig_port);\n\n\treturn tc_phy_cold_off_domain(tc) ==\n\t       intel_display_power_legacy_aux_domain(i915, dig_port->aux_ch);\n}\n\nstatic intel_wakeref_t\n__tc_cold_block(struct intel_tc_port *tc, enum intel_display_power_domain *domain)\n{\n\tstruct drm_i915_private *i915 = tc_to_i915(tc);\n\n\t*domain = tc_phy_cold_off_domain(tc);\n\n\treturn intel_display_power_get(i915, *domain);\n}\n\nstatic intel_wakeref_t\ntc_cold_block(struct intel_tc_port *tc)\n{\n\tenum intel_display_power_domain domain;\n\tintel_wakeref_t wakeref;\n\n\twakeref = __tc_cold_block(tc, &domain);\n#if IS_ENABLED(CONFIG_DRM_I915_DEBUG_RUNTIME_PM)\n\ttc->lock_power_domain = domain;\n#endif\n\treturn wakeref;\n}\n\nstatic void\n__tc_cold_unblock(struct intel_tc_port *tc, enum intel_display_power_domain domain,\n\t\t  intel_wakeref_t wakeref)\n{\n\tstruct drm_i915_private *i915 = tc_to_i915(tc);\n\n\tintel_display_power_put(i915, domain, wakeref);\n}\n\nstatic void\ntc_cold_unblock(struct intel_tc_port *tc, intel_wakeref_t wakeref)\n{\n\tenum intel_display_power_domain domain = tc_phy_cold_off_domain(tc);\n\n#if IS_ENABLED(CONFIG_DRM_I915_DEBUG_RUNTIME_PM)\n\tdrm_WARN_ON(&tc_to_i915(tc)->drm, tc->lock_power_domain != domain);\n#endif\n\t__tc_cold_unblock(tc, domain, wakeref);\n}\n\nstatic void\nassert_display_core_power_enabled(struct intel_tc_port *tc)\n{\n\tstruct drm_i915_private *i915 = tc_to_i915(tc);\n\n\tdrm_WARN_ON(&i915->drm,\n\t\t    !intel_display_power_is_enabled(i915, POWER_DOMAIN_DISPLAY_CORE));\n}\n\nstatic void\nassert_tc_cold_blocked(struct intel_tc_port *tc)\n{\n\tstruct drm_i915_private *i915 = tc_to_i915(tc);\n\tbool enabled;\n\n\tenabled = intel_display_power_is_enabled(i915,\n\t\t\t\t\t\t tc_phy_cold_off_domain(tc));\n\tdrm_WARN_ON(&i915->drm, !enabled);\n}\n\nstatic enum intel_display_power_domain\ntc_port_power_domain(struct intel_tc_port *tc)\n{\n\tstruct drm_i915_private *i915 = tc_to_i915(tc);\n\tenum tc_port tc_port = intel_port_to_tc(i915, tc->dig_port->base.port);\n\n\treturn POWER_DOMAIN_PORT_DDI_LANES_TC1 + tc_port - TC_PORT_1;\n}\n\nstatic void\nassert_tc_port_power_enabled(struct intel_tc_port *tc)\n{\n\tstruct drm_i915_private *i915 = tc_to_i915(tc);\n\n\tdrm_WARN_ON(&i915->drm,\n\t\t    !intel_display_power_is_enabled(i915, tc_port_power_domain(tc)));\n}\n\nu32 intel_tc_port_get_lane_mask(struct intel_digital_port *dig_port)\n{\n\tstruct drm_i915_private *i915 = to_i915(dig_port->base.base.dev);\n\tstruct intel_tc_port *tc = to_tc_port(dig_port);\n\tu32 lane_mask;\n\n\tlane_mask = intel_de_read(i915, PORT_TX_DFLEXDPSP(tc->phy_fia));\n\n\tdrm_WARN_ON(&i915->drm, lane_mask == 0xffffffff);\n\tassert_tc_cold_blocked(tc);\n\n\tlane_mask &= DP_LANE_ASSIGNMENT_MASK(tc->phy_fia_idx);\n\treturn lane_mask >> DP_LANE_ASSIGNMENT_SHIFT(tc->phy_fia_idx);\n}\n\nu32 intel_tc_port_get_pin_assignment_mask(struct intel_digital_port *dig_port)\n{\n\tstruct drm_i915_private *i915 = to_i915(dig_port->base.base.dev);\n\tstruct intel_tc_port *tc = to_tc_port(dig_port);\n\tu32 pin_mask;\n\n\tpin_mask = intel_de_read(i915, PORT_TX_DFLEXPA1(tc->phy_fia));\n\n\tdrm_WARN_ON(&i915->drm, pin_mask == 0xffffffff);\n\tassert_tc_cold_blocked(tc);\n\n\treturn (pin_mask & DP_PIN_ASSIGNMENT_MASK(tc->phy_fia_idx)) >>\n\t       DP_PIN_ASSIGNMENT_SHIFT(tc->phy_fia_idx);\n}\n\nstatic int mtl_tc_port_get_pin_assignment_mask(struct intel_digital_port *dig_port)\n{\n\tstruct drm_i915_private *i915 = to_i915(dig_port->base.base.dev);\n\tintel_wakeref_t wakeref;\n\tu32 pin_mask;\n\n\twith_intel_display_power(i915, POWER_DOMAIN_DISPLAY_CORE, wakeref)\n\t\tpin_mask = intel_tc_port_get_pin_assignment_mask(dig_port);\n\n\tswitch (pin_mask) {\n\tdefault:\n\t\tMISSING_CASE(pin_mask);\n\t\tfallthrough;\n\tcase DP_PIN_ASSIGNMENT_D:\n\t\treturn 2;\n\tcase DP_PIN_ASSIGNMENT_C:\n\tcase DP_PIN_ASSIGNMENT_E:\n\t\treturn 4;\n\t}\n}\n\nint intel_tc_port_fia_max_lane_count(struct intel_digital_port *dig_port)\n{\n\tstruct drm_i915_private *i915 = to_i915(dig_port->base.base.dev);\n\tstruct intel_tc_port *tc = to_tc_port(dig_port);\n\tenum phy phy = intel_port_to_phy(i915, dig_port->base.port);\n\tintel_wakeref_t wakeref;\n\tu32 lane_mask;\n\n\tif (!intel_phy_is_tc(i915, phy) || tc->mode != TC_PORT_DP_ALT)\n\t\treturn 4;\n\n\tassert_tc_cold_blocked(tc);\n\n\tif (DISPLAY_VER(i915) >= 14)\n\t\treturn mtl_tc_port_get_pin_assignment_mask(dig_port);\n\n\tlane_mask = 0;\n\twith_intel_display_power(i915, POWER_DOMAIN_DISPLAY_CORE, wakeref)\n\t\tlane_mask = intel_tc_port_get_lane_mask(dig_port);\n\n\tswitch (lane_mask) {\n\tdefault:\n\t\tMISSING_CASE(lane_mask);\n\t\tfallthrough;\n\tcase 0x1:\n\tcase 0x2:\n\tcase 0x4:\n\tcase 0x8:\n\t\treturn 1;\n\tcase 0x3:\n\tcase 0xc:\n\t\treturn 2;\n\tcase 0xf:\n\t\treturn 4;\n\t}\n}\n\nvoid intel_tc_port_set_fia_lane_count(struct intel_digital_port *dig_port,\n\t\t\t\t      int required_lanes)\n{\n\tstruct drm_i915_private *i915 = to_i915(dig_port->base.base.dev);\n\tstruct intel_tc_port *tc = to_tc_port(dig_port);\n\tbool lane_reversal = dig_port->saved_port_bits & DDI_BUF_PORT_REVERSAL;\n\tu32 val;\n\n\tdrm_WARN_ON(&i915->drm,\n\t\t    lane_reversal && tc->mode != TC_PORT_LEGACY);\n\n\tassert_tc_cold_blocked(tc);\n\n\tval = intel_de_read(i915, PORT_TX_DFLEXDPMLE1(tc->phy_fia));\n\tval &= ~DFLEXDPMLE1_DPMLETC_MASK(tc->phy_fia_idx);\n\n\tswitch (required_lanes) {\n\tcase 1:\n\t\tval |= lane_reversal ?\n\t\t\tDFLEXDPMLE1_DPMLETC_ML3(tc->phy_fia_idx) :\n\t\t\tDFLEXDPMLE1_DPMLETC_ML0(tc->phy_fia_idx);\n\t\tbreak;\n\tcase 2:\n\t\tval |= lane_reversal ?\n\t\t\tDFLEXDPMLE1_DPMLETC_ML3_2(tc->phy_fia_idx) :\n\t\t\tDFLEXDPMLE1_DPMLETC_ML1_0(tc->phy_fia_idx);\n\t\tbreak;\n\tcase 4:\n\t\tval |= DFLEXDPMLE1_DPMLETC_ML3_0(tc->phy_fia_idx);\n\t\tbreak;\n\tdefault:\n\t\tMISSING_CASE(required_lanes);\n\t}\n\n\tintel_de_write(i915, PORT_TX_DFLEXDPMLE1(tc->phy_fia), val);\n}\n\nstatic void tc_port_fixup_legacy_flag(struct intel_tc_port *tc,\n\t\t\t\t      u32 live_status_mask)\n{\n\tstruct drm_i915_private *i915 = tc_to_i915(tc);\n\tu32 valid_hpd_mask;\n\n\tdrm_WARN_ON(&i915->drm, tc->mode != TC_PORT_DISCONNECTED);\n\n\tif (hweight32(live_status_mask) != 1)\n\t\treturn;\n\n\tif (tc->legacy_port)\n\t\tvalid_hpd_mask = BIT(TC_PORT_LEGACY);\n\telse\n\t\tvalid_hpd_mask = BIT(TC_PORT_DP_ALT) |\n\t\t\t\t BIT(TC_PORT_TBT_ALT);\n\n\tif (!(live_status_mask & ~valid_hpd_mask))\n\t\treturn;\n\n\t \n\tdrm_dbg_kms(&i915->drm,\n\t\t    \"Port %s: live status %08x mismatches the legacy port flag %08x, fixing flag\\n\",\n\t\t    tc->port_name, live_status_mask, valid_hpd_mask);\n\n\ttc->legacy_port = !tc->legacy_port;\n}\n\nstatic void tc_phy_load_fia_params(struct intel_tc_port *tc, bool modular_fia)\n{\n\tstruct drm_i915_private *i915 = tc_to_i915(tc);\n\tenum port port = tc->dig_port->base.port;\n\tenum tc_port tc_port = intel_port_to_tc(i915, port);\n\n\t \n\tif (modular_fia) {\n\t\ttc->phy_fia = tc_port / 2;\n\t\ttc->phy_fia_idx = tc_port % 2;\n\t} else {\n\t\ttc->phy_fia = FIA1;\n\t\ttc->phy_fia_idx = tc_port;\n\t}\n}\n\n \nstatic enum intel_display_power_domain\nicl_tc_phy_cold_off_domain(struct intel_tc_port *tc)\n{\n\tstruct drm_i915_private *i915 = tc_to_i915(tc);\n\tstruct intel_digital_port *dig_port = tc->dig_port;\n\n\tif (tc->legacy_port)\n\t\treturn intel_display_power_legacy_aux_domain(i915, dig_port->aux_ch);\n\n\treturn POWER_DOMAIN_TC_COLD_OFF;\n}\n\nstatic u32 icl_tc_phy_hpd_live_status(struct intel_tc_port *tc)\n{\n\tstruct drm_i915_private *i915 = tc_to_i915(tc);\n\tstruct intel_digital_port *dig_port = tc->dig_port;\n\tu32 isr_bit = i915->display.hotplug.pch_hpd[dig_port->base.hpd_pin];\n\tintel_wakeref_t wakeref;\n\tu32 fia_isr;\n\tu32 pch_isr;\n\tu32 mask = 0;\n\n\twith_intel_display_power(i915, tc_phy_cold_off_domain(tc), wakeref) {\n\t\tfia_isr = intel_de_read(i915, PORT_TX_DFLEXDPSP(tc->phy_fia));\n\t\tpch_isr = intel_de_read(i915, SDEISR);\n\t}\n\n\tif (fia_isr == 0xffffffff) {\n\t\tdrm_dbg_kms(&i915->drm,\n\t\t\t    \"Port %s: PHY in TCCOLD, nothing connected\\n\",\n\t\t\t    tc->port_name);\n\t\treturn mask;\n\t}\n\n\tif (fia_isr & TC_LIVE_STATE_TBT(tc->phy_fia_idx))\n\t\tmask |= BIT(TC_PORT_TBT_ALT);\n\tif (fia_isr & TC_LIVE_STATE_TC(tc->phy_fia_idx))\n\t\tmask |= BIT(TC_PORT_DP_ALT);\n\n\tif (pch_isr & isr_bit)\n\t\tmask |= BIT(TC_PORT_LEGACY);\n\n\treturn mask;\n}\n\n \nstatic bool icl_tc_phy_is_ready(struct intel_tc_port *tc)\n{\n\tstruct drm_i915_private *i915 = tc_to_i915(tc);\n\tu32 val;\n\n\tassert_tc_cold_blocked(tc);\n\n\tval = intel_de_read(i915, PORT_TX_DFLEXDPPMS(tc->phy_fia));\n\tif (val == 0xffffffff) {\n\t\tdrm_dbg_kms(&i915->drm,\n\t\t\t    \"Port %s: PHY in TCCOLD, assuming not ready\\n\",\n\t\t\t    tc->port_name);\n\t\treturn false;\n\t}\n\n\treturn val & DP_PHY_MODE_STATUS_COMPLETED(tc->phy_fia_idx);\n}\n\nstatic bool icl_tc_phy_take_ownership(struct intel_tc_port *tc,\n\t\t\t\t      bool take)\n{\n\tstruct drm_i915_private *i915 = tc_to_i915(tc);\n\tu32 val;\n\n\tassert_tc_cold_blocked(tc);\n\n\tval = intel_de_read(i915, PORT_TX_DFLEXDPCSSS(tc->phy_fia));\n\tif (val == 0xffffffff) {\n\t\tdrm_dbg_kms(&i915->drm,\n\t\t\t    \"Port %s: PHY in TCCOLD, can't %s ownership\\n\",\n\t\t\t    tc->port_name, take ? \"take\" : \"release\");\n\n\t\treturn false;\n\t}\n\n\tval &= ~DP_PHY_MODE_STATUS_NOT_SAFE(tc->phy_fia_idx);\n\tif (take)\n\t\tval |= DP_PHY_MODE_STATUS_NOT_SAFE(tc->phy_fia_idx);\n\n\tintel_de_write(i915, PORT_TX_DFLEXDPCSSS(tc->phy_fia), val);\n\n\treturn true;\n}\n\nstatic bool icl_tc_phy_is_owned(struct intel_tc_port *tc)\n{\n\tstruct drm_i915_private *i915 = tc_to_i915(tc);\n\tu32 val;\n\n\tassert_tc_cold_blocked(tc);\n\n\tval = intel_de_read(i915, PORT_TX_DFLEXDPCSSS(tc->phy_fia));\n\tif (val == 0xffffffff) {\n\t\tdrm_dbg_kms(&i915->drm,\n\t\t\t    \"Port %s: PHY in TCCOLD, assume not owned\\n\",\n\t\t\t    tc->port_name);\n\t\treturn false;\n\t}\n\n\treturn val & DP_PHY_MODE_STATUS_NOT_SAFE(tc->phy_fia_idx);\n}\n\nstatic void icl_tc_phy_get_hw_state(struct intel_tc_port *tc)\n{\n\tenum intel_display_power_domain domain;\n\tintel_wakeref_t tc_cold_wref;\n\n\ttc_cold_wref = __tc_cold_block(tc, &domain);\n\n\ttc->mode = tc_phy_get_current_mode(tc);\n\tif (tc->mode != TC_PORT_DISCONNECTED)\n\t\ttc->lock_wakeref = tc_cold_block(tc);\n\n\t__tc_cold_unblock(tc, domain, tc_cold_wref);\n}\n\n \nstatic bool tc_phy_verify_legacy_or_dp_alt_mode(struct intel_tc_port *tc,\n\t\t\t\t\t\tint required_lanes)\n{\n\tstruct drm_i915_private *i915 = tc_to_i915(tc);\n\tstruct intel_digital_port *dig_port = tc->dig_port;\n\tint max_lanes;\n\n\tmax_lanes = intel_tc_port_fia_max_lane_count(dig_port);\n\tif (tc->mode == TC_PORT_LEGACY) {\n\t\tdrm_WARN_ON(&i915->drm, max_lanes != 4);\n\t\treturn true;\n\t}\n\n\tdrm_WARN_ON(&i915->drm, tc->mode != TC_PORT_DP_ALT);\n\n\t \n\tif (!(tc_phy_hpd_live_status(tc) & BIT(TC_PORT_DP_ALT))) {\n\t\tdrm_dbg_kms(&i915->drm, \"Port %s: PHY sudden disconnect\\n\",\n\t\t\t    tc->port_name);\n\t\treturn false;\n\t}\n\n\tif (max_lanes < required_lanes) {\n\t\tdrm_dbg_kms(&i915->drm,\n\t\t\t    \"Port %s: PHY max lanes %d < required lanes %d\\n\",\n\t\t\t    tc->port_name,\n\t\t\t    max_lanes, required_lanes);\n\t\treturn false;\n\t}\n\n\treturn true;\n}\n\nstatic bool icl_tc_phy_connect(struct intel_tc_port *tc,\n\t\t\t       int required_lanes)\n{\n\tstruct drm_i915_private *i915 = tc_to_i915(tc);\n\n\ttc->lock_wakeref = tc_cold_block(tc);\n\n\tif (tc->mode == TC_PORT_TBT_ALT)\n\t\treturn true;\n\n\tif ((!tc_phy_is_ready(tc) ||\n\t     !icl_tc_phy_take_ownership(tc, true)) &&\n\t    !drm_WARN_ON(&i915->drm, tc->mode == TC_PORT_LEGACY)) {\n\t\tdrm_dbg_kms(&i915->drm, \"Port %s: can't take PHY ownership (ready %s)\\n\",\n\t\t\t    tc->port_name,\n\t\t\t    str_yes_no(tc_phy_is_ready(tc)));\n\t\tgoto out_unblock_tc_cold;\n\t}\n\n\n\tif (!tc_phy_verify_legacy_or_dp_alt_mode(tc, required_lanes))\n\t\tgoto out_release_phy;\n\n\treturn true;\n\nout_release_phy:\n\ticl_tc_phy_take_ownership(tc, false);\nout_unblock_tc_cold:\n\ttc_cold_unblock(tc, fetch_and_zero(&tc->lock_wakeref));\n\n\treturn false;\n}\n\n \nstatic void icl_tc_phy_disconnect(struct intel_tc_port *tc)\n{\n\tswitch (tc->mode) {\n\tcase TC_PORT_LEGACY:\n\tcase TC_PORT_DP_ALT:\n\t\ticl_tc_phy_take_ownership(tc, false);\n\t\tfallthrough;\n\tcase TC_PORT_TBT_ALT:\n\t\ttc_cold_unblock(tc, fetch_and_zero(&tc->lock_wakeref));\n\t\tbreak;\n\tdefault:\n\t\tMISSING_CASE(tc->mode);\n\t}\n}\n\nstatic void icl_tc_phy_init(struct intel_tc_port *tc)\n{\n\ttc_phy_load_fia_params(tc, false);\n}\n\nstatic const struct intel_tc_phy_ops icl_tc_phy_ops = {\n\t.cold_off_domain = icl_tc_phy_cold_off_domain,\n\t.hpd_live_status = icl_tc_phy_hpd_live_status,\n\t.is_ready = icl_tc_phy_is_ready,\n\t.is_owned = icl_tc_phy_is_owned,\n\t.get_hw_state = icl_tc_phy_get_hw_state,\n\t.connect = icl_tc_phy_connect,\n\t.disconnect = icl_tc_phy_disconnect,\n\t.init = icl_tc_phy_init,\n};\n\n \nstatic enum intel_display_power_domain\ntgl_tc_phy_cold_off_domain(struct intel_tc_port *tc)\n{\n\treturn POWER_DOMAIN_TC_COLD_OFF;\n}\n\nstatic void tgl_tc_phy_init(struct intel_tc_port *tc)\n{\n\tstruct drm_i915_private *i915 = tc_to_i915(tc);\n\tintel_wakeref_t wakeref;\n\tu32 val;\n\n\twith_intel_display_power(i915, tc_phy_cold_off_domain(tc), wakeref)\n\t\tval = intel_de_read(i915, PORT_TX_DFLEXDPSP(FIA1));\n\n\tdrm_WARN_ON(&i915->drm, val == 0xffffffff);\n\n\ttc_phy_load_fia_params(tc, val & MODULAR_FIA_MASK);\n}\n\nstatic const struct intel_tc_phy_ops tgl_tc_phy_ops = {\n\t.cold_off_domain = tgl_tc_phy_cold_off_domain,\n\t.hpd_live_status = icl_tc_phy_hpd_live_status,\n\t.is_ready = icl_tc_phy_is_ready,\n\t.is_owned = icl_tc_phy_is_owned,\n\t.get_hw_state = icl_tc_phy_get_hw_state,\n\t.connect = icl_tc_phy_connect,\n\t.disconnect = icl_tc_phy_disconnect,\n\t.init = tgl_tc_phy_init,\n};\n\n \nstatic enum intel_display_power_domain\nadlp_tc_phy_cold_off_domain(struct intel_tc_port *tc)\n{\n\tstruct drm_i915_private *i915 = tc_to_i915(tc);\n\tstruct intel_digital_port *dig_port = tc->dig_port;\n\n\tif (tc->mode != TC_PORT_TBT_ALT)\n\t\treturn intel_display_power_legacy_aux_domain(i915, dig_port->aux_ch);\n\n\treturn POWER_DOMAIN_TC_COLD_OFF;\n}\n\nstatic u32 adlp_tc_phy_hpd_live_status(struct intel_tc_port *tc)\n{\n\tstruct drm_i915_private *i915 = tc_to_i915(tc);\n\tstruct intel_digital_port *dig_port = tc->dig_port;\n\tenum hpd_pin hpd_pin = dig_port->base.hpd_pin;\n\tu32 cpu_isr_bits = i915->display.hotplug.hpd[hpd_pin];\n\tu32 pch_isr_bit = i915->display.hotplug.pch_hpd[hpd_pin];\n\tintel_wakeref_t wakeref;\n\tu32 cpu_isr;\n\tu32 pch_isr;\n\tu32 mask = 0;\n\n\twith_intel_display_power(i915, POWER_DOMAIN_DISPLAY_CORE, wakeref) {\n\t\tcpu_isr = intel_de_read(i915, GEN11_DE_HPD_ISR);\n\t\tpch_isr = intel_de_read(i915, SDEISR);\n\t}\n\n\tif (cpu_isr & (cpu_isr_bits & GEN11_DE_TC_HOTPLUG_MASK))\n\t\tmask |= BIT(TC_PORT_DP_ALT);\n\tif (cpu_isr & (cpu_isr_bits & GEN11_DE_TBT_HOTPLUG_MASK))\n\t\tmask |= BIT(TC_PORT_TBT_ALT);\n\n\tif (pch_isr & pch_isr_bit)\n\t\tmask |= BIT(TC_PORT_LEGACY);\n\n\treturn mask;\n}\n\n \nstatic bool adlp_tc_phy_is_ready(struct intel_tc_port *tc)\n{\n\tstruct drm_i915_private *i915 = tc_to_i915(tc);\n\tenum tc_port tc_port = intel_port_to_tc(i915, tc->dig_port->base.port);\n\tu32 val;\n\n\tassert_display_core_power_enabled(tc);\n\n\tval = intel_de_read(i915, TCSS_DDI_STATUS(tc_port));\n\tif (val == 0xffffffff) {\n\t\tdrm_dbg_kms(&i915->drm,\n\t\t\t    \"Port %s: PHY in TCCOLD, assuming not ready\\n\",\n\t\t\t    tc->port_name);\n\t\treturn false;\n\t}\n\n\treturn val & TCSS_DDI_STATUS_READY;\n}\n\nstatic bool adlp_tc_phy_take_ownership(struct intel_tc_port *tc,\n\t\t\t\t       bool take)\n{\n\tstruct drm_i915_private *i915 = tc_to_i915(tc);\n\tenum port port = tc->dig_port->base.port;\n\n\tassert_tc_port_power_enabled(tc);\n\n\tintel_de_rmw(i915, DDI_BUF_CTL(port), DDI_BUF_CTL_TC_PHY_OWNERSHIP,\n\t\t     take ? DDI_BUF_CTL_TC_PHY_OWNERSHIP : 0);\n\n\treturn true;\n}\n\nstatic bool adlp_tc_phy_is_owned(struct intel_tc_port *tc)\n{\n\tstruct drm_i915_private *i915 = tc_to_i915(tc);\n\tenum port port = tc->dig_port->base.port;\n\tu32 val;\n\n\tassert_tc_port_power_enabled(tc);\n\n\tval = intel_de_read(i915, DDI_BUF_CTL(port));\n\treturn val & DDI_BUF_CTL_TC_PHY_OWNERSHIP;\n}\n\nstatic void adlp_tc_phy_get_hw_state(struct intel_tc_port *tc)\n{\n\tstruct drm_i915_private *i915 = tc_to_i915(tc);\n\tenum intel_display_power_domain port_power_domain =\n\t\ttc_port_power_domain(tc);\n\tintel_wakeref_t port_wakeref;\n\n\tport_wakeref = intel_display_power_get(i915, port_power_domain);\n\n\ttc->mode = tc_phy_get_current_mode(tc);\n\tif (tc->mode != TC_PORT_DISCONNECTED)\n\t\ttc->lock_wakeref = tc_cold_block(tc);\n\n\tintel_display_power_put(i915, port_power_domain, port_wakeref);\n}\n\nstatic bool adlp_tc_phy_connect(struct intel_tc_port *tc, int required_lanes)\n{\n\tstruct drm_i915_private *i915 = tc_to_i915(tc);\n\tenum intel_display_power_domain port_power_domain =\n\t\ttc_port_power_domain(tc);\n\tintel_wakeref_t port_wakeref;\n\n\tif (tc->mode == TC_PORT_TBT_ALT) {\n\t\ttc->lock_wakeref = tc_cold_block(tc);\n\t\treturn true;\n\t}\n\n\tport_wakeref = intel_display_power_get(i915, port_power_domain);\n\n\tif (!adlp_tc_phy_take_ownership(tc, true) &&\n\t    !drm_WARN_ON(&i915->drm, tc->mode == TC_PORT_LEGACY)) {\n\t\tdrm_dbg_kms(&i915->drm, \"Port %s: can't take PHY ownership\\n\",\n\t\t\t    tc->port_name);\n\t\tgoto out_put_port_power;\n\t}\n\n\tif (!tc_phy_is_ready(tc) &&\n\t    !drm_WARN_ON(&i915->drm, tc->mode == TC_PORT_LEGACY)) {\n\t\tdrm_dbg_kms(&i915->drm, \"Port %s: PHY not ready\\n\",\n\t\t\t    tc->port_name);\n\t\tgoto out_release_phy;\n\t}\n\n\ttc->lock_wakeref = tc_cold_block(tc);\n\n\tif (!tc_phy_verify_legacy_or_dp_alt_mode(tc, required_lanes))\n\t\tgoto out_unblock_tc_cold;\n\n\tintel_display_power_put(i915, port_power_domain, port_wakeref);\n\n\treturn true;\n\nout_unblock_tc_cold:\n\ttc_cold_unblock(tc, fetch_and_zero(&tc->lock_wakeref));\nout_release_phy:\n\tadlp_tc_phy_take_ownership(tc, false);\nout_put_port_power:\n\tintel_display_power_put(i915, port_power_domain, port_wakeref);\n\n\treturn false;\n}\n\nstatic void adlp_tc_phy_disconnect(struct intel_tc_port *tc)\n{\n\tstruct drm_i915_private *i915 = tc_to_i915(tc);\n\tenum intel_display_power_domain port_power_domain =\n\t\ttc_port_power_domain(tc);\n\tintel_wakeref_t port_wakeref;\n\n\tport_wakeref = intel_display_power_get(i915, port_power_domain);\n\n\ttc_cold_unblock(tc, fetch_and_zero(&tc->lock_wakeref));\n\n\tswitch (tc->mode) {\n\tcase TC_PORT_LEGACY:\n\tcase TC_PORT_DP_ALT:\n\t\tadlp_tc_phy_take_ownership(tc, false);\n\t\tfallthrough;\n\tcase TC_PORT_TBT_ALT:\n\t\tbreak;\n\tdefault:\n\t\tMISSING_CASE(tc->mode);\n\t}\n\n\tintel_display_power_put(i915, port_power_domain, port_wakeref);\n}\n\nstatic void adlp_tc_phy_init(struct intel_tc_port *tc)\n{\n\ttc_phy_load_fia_params(tc, true);\n}\n\nstatic const struct intel_tc_phy_ops adlp_tc_phy_ops = {\n\t.cold_off_domain = adlp_tc_phy_cold_off_domain,\n\t.hpd_live_status = adlp_tc_phy_hpd_live_status,\n\t.is_ready = adlp_tc_phy_is_ready,\n\t.is_owned = adlp_tc_phy_is_owned,\n\t.get_hw_state = adlp_tc_phy_get_hw_state,\n\t.connect = adlp_tc_phy_connect,\n\t.disconnect = adlp_tc_phy_disconnect,\n\t.init = adlp_tc_phy_init,\n};\n\n \nstatic u32 xelpdp_tc_phy_hpd_live_status(struct intel_tc_port *tc)\n{\n\tstruct drm_i915_private *i915 = tc_to_i915(tc);\n\tstruct intel_digital_port *dig_port = tc->dig_port;\n\tenum hpd_pin hpd_pin = dig_port->base.hpd_pin;\n\tu32 pica_isr_bits = i915->display.hotplug.hpd[hpd_pin];\n\tu32 pch_isr_bit = i915->display.hotplug.pch_hpd[hpd_pin];\n\tintel_wakeref_t wakeref;\n\tu32 pica_isr;\n\tu32 pch_isr;\n\tu32 mask = 0;\n\n\twith_intel_display_power(i915, POWER_DOMAIN_DISPLAY_CORE, wakeref) {\n\t\tpica_isr = intel_de_read(i915, PICAINTERRUPT_ISR);\n\t\tpch_isr = intel_de_read(i915, SDEISR);\n\t}\n\n\tif (pica_isr & (pica_isr_bits & XELPDP_DP_ALT_HOTPLUG_MASK))\n\t\tmask |= BIT(TC_PORT_DP_ALT);\n\tif (pica_isr & (pica_isr_bits & XELPDP_TBT_HOTPLUG_MASK))\n\t\tmask |= BIT(TC_PORT_TBT_ALT);\n\n\tif (tc->legacy_port && (pch_isr & pch_isr_bit))\n\t\tmask |= BIT(TC_PORT_LEGACY);\n\n\treturn mask;\n}\n\nstatic bool\nxelpdp_tc_phy_tcss_power_is_enabled(struct intel_tc_port *tc)\n{\n\tstruct drm_i915_private *i915 = tc_to_i915(tc);\n\tenum port port = tc->dig_port->base.port;\n\n\tassert_tc_cold_blocked(tc);\n\n\treturn intel_de_read(i915, XELPDP_PORT_BUF_CTL1(port)) & XELPDP_TCSS_POWER_STATE;\n}\n\nstatic bool\nxelpdp_tc_phy_wait_for_tcss_power(struct intel_tc_port *tc, bool enabled)\n{\n\tstruct drm_i915_private *i915 = tc_to_i915(tc);\n\n\tif (wait_for(xelpdp_tc_phy_tcss_power_is_enabled(tc) == enabled, 5)) {\n\t\tdrm_dbg_kms(&i915->drm,\n\t\t\t    \"Port %s: timeout waiting for TCSS power to get %s\\n\",\n\t\t\t    enabled ? \"enabled\" : \"disabled\",\n\t\t\t    tc->port_name);\n\t\treturn false;\n\t}\n\n\treturn true;\n}\n\nstatic void __xelpdp_tc_phy_enable_tcss_power(struct intel_tc_port *tc, bool enable)\n{\n\tstruct drm_i915_private *i915 = tc_to_i915(tc);\n\tenum port port = tc->dig_port->base.port;\n\tu32 val;\n\n\tassert_tc_cold_blocked(tc);\n\n\tval = intel_de_read(i915, XELPDP_PORT_BUF_CTL1(port));\n\tif (enable)\n\t\tval |= XELPDP_TCSS_POWER_REQUEST;\n\telse\n\t\tval &= ~XELPDP_TCSS_POWER_REQUEST;\n\tintel_de_write(i915, XELPDP_PORT_BUF_CTL1(port), val);\n}\n\nstatic bool xelpdp_tc_phy_enable_tcss_power(struct intel_tc_port *tc, bool enable)\n{\n\tstruct drm_i915_private *i915 = tc_to_i915(tc);\n\n\t__xelpdp_tc_phy_enable_tcss_power(tc, enable);\n\n\tif ((!tc_phy_wait_for_ready(tc) ||\n\t     !xelpdp_tc_phy_wait_for_tcss_power(tc, enable)) &&\n\t    !drm_WARN_ON(&i915->drm, tc->mode == TC_PORT_LEGACY)) {\n\t\tif (enable) {\n\t\t\t__xelpdp_tc_phy_enable_tcss_power(tc, false);\n\t\t\txelpdp_tc_phy_wait_for_tcss_power(tc, false);\n\t\t}\n\n\t\treturn false;\n\t}\n\n\treturn true;\n}\n\nstatic void xelpdp_tc_phy_take_ownership(struct intel_tc_port *tc, bool take)\n{\n\tstruct drm_i915_private *i915 = tc_to_i915(tc);\n\tenum port port = tc->dig_port->base.port;\n\tu32 val;\n\n\tassert_tc_cold_blocked(tc);\n\n\tval = intel_de_read(i915, XELPDP_PORT_BUF_CTL1(port));\n\tif (take)\n\t\tval |= XELPDP_TC_PHY_OWNERSHIP;\n\telse\n\t\tval &= ~XELPDP_TC_PHY_OWNERSHIP;\n\tintel_de_write(i915, XELPDP_PORT_BUF_CTL1(port), val);\n}\n\nstatic bool xelpdp_tc_phy_is_owned(struct intel_tc_port *tc)\n{\n\tstruct drm_i915_private *i915 = tc_to_i915(tc);\n\tenum port port = tc->dig_port->base.port;\n\n\tassert_tc_cold_blocked(tc);\n\n\treturn intel_de_read(i915, XELPDP_PORT_BUF_CTL1(port)) & XELPDP_TC_PHY_OWNERSHIP;\n}\n\nstatic void xelpdp_tc_phy_get_hw_state(struct intel_tc_port *tc)\n{\n\tstruct drm_i915_private *i915 = tc_to_i915(tc);\n\tintel_wakeref_t tc_cold_wref;\n\tenum intel_display_power_domain domain;\n\n\ttc_cold_wref = __tc_cold_block(tc, &domain);\n\n\ttc->mode = tc_phy_get_current_mode(tc);\n\tif (tc->mode != TC_PORT_DISCONNECTED)\n\t\ttc->lock_wakeref = tc_cold_block(tc);\n\n\tdrm_WARN_ON(&i915->drm,\n\t\t    (tc->mode == TC_PORT_DP_ALT || tc->mode == TC_PORT_LEGACY) &&\n\t\t    !xelpdp_tc_phy_tcss_power_is_enabled(tc));\n\n\t__tc_cold_unblock(tc, domain, tc_cold_wref);\n}\n\nstatic bool xelpdp_tc_phy_connect(struct intel_tc_port *tc, int required_lanes)\n{\n\ttc->lock_wakeref = tc_cold_block(tc);\n\n\tif (tc->mode == TC_PORT_TBT_ALT)\n\t\treturn true;\n\n\tif (!xelpdp_tc_phy_enable_tcss_power(tc, true))\n\t\tgoto out_unblock_tccold;\n\n\txelpdp_tc_phy_take_ownership(tc, true);\n\n\tif (!tc_phy_verify_legacy_or_dp_alt_mode(tc, required_lanes))\n\t\tgoto out_release_phy;\n\n\treturn true;\n\nout_release_phy:\n\txelpdp_tc_phy_take_ownership(tc, false);\n\txelpdp_tc_phy_wait_for_tcss_power(tc, false);\n\nout_unblock_tccold:\n\ttc_cold_unblock(tc, fetch_and_zero(&tc->lock_wakeref));\n\n\treturn false;\n}\n\nstatic void xelpdp_tc_phy_disconnect(struct intel_tc_port *tc)\n{\n\tswitch (tc->mode) {\n\tcase TC_PORT_LEGACY:\n\tcase TC_PORT_DP_ALT:\n\t\txelpdp_tc_phy_take_ownership(tc, false);\n\t\txelpdp_tc_phy_enable_tcss_power(tc, false);\n\t\tfallthrough;\n\tcase TC_PORT_TBT_ALT:\n\t\ttc_cold_unblock(tc, fetch_and_zero(&tc->lock_wakeref));\n\t\tbreak;\n\tdefault:\n\t\tMISSING_CASE(tc->mode);\n\t}\n}\n\nstatic const struct intel_tc_phy_ops xelpdp_tc_phy_ops = {\n\t.cold_off_domain = tgl_tc_phy_cold_off_domain,\n\t.hpd_live_status = xelpdp_tc_phy_hpd_live_status,\n\t.is_ready = adlp_tc_phy_is_ready,\n\t.is_owned = xelpdp_tc_phy_is_owned,\n\t.get_hw_state = xelpdp_tc_phy_get_hw_state,\n\t.connect = xelpdp_tc_phy_connect,\n\t.disconnect = xelpdp_tc_phy_disconnect,\n\t.init = adlp_tc_phy_init,\n};\n\n \nstatic enum intel_display_power_domain\ntc_phy_cold_off_domain(struct intel_tc_port *tc)\n{\n\treturn tc->phy_ops->cold_off_domain(tc);\n}\n\nstatic u32 tc_phy_hpd_live_status(struct intel_tc_port *tc)\n{\n\tstruct drm_i915_private *i915 = tc_to_i915(tc);\n\tu32 mask;\n\n\tmask = tc->phy_ops->hpd_live_status(tc);\n\n\t \n\tdrm_WARN_ON_ONCE(&i915->drm, hweight32(mask) > 1);\n\n\treturn mask;\n}\n\nstatic bool tc_phy_is_ready(struct intel_tc_port *tc)\n{\n\treturn tc->phy_ops->is_ready(tc);\n}\n\nstatic bool tc_phy_is_owned(struct intel_tc_port *tc)\n{\n\treturn tc->phy_ops->is_owned(tc);\n}\n\nstatic void tc_phy_get_hw_state(struct intel_tc_port *tc)\n{\n\ttc->phy_ops->get_hw_state(tc);\n}\n\nstatic bool tc_phy_is_ready_and_owned(struct intel_tc_port *tc,\n\t\t\t\t      bool phy_is_ready, bool phy_is_owned)\n{\n\tstruct drm_i915_private *i915 = tc_to_i915(tc);\n\n\tdrm_WARN_ON(&i915->drm, phy_is_owned && !phy_is_ready);\n\n\treturn phy_is_ready && phy_is_owned;\n}\n\nstatic bool tc_phy_is_connected(struct intel_tc_port *tc,\n\t\t\t\tenum icl_port_dpll_id port_pll_type)\n{\n\tstruct intel_encoder *encoder = &tc->dig_port->base;\n\tstruct drm_i915_private *i915 = to_i915(encoder->base.dev);\n\tbool phy_is_ready = tc_phy_is_ready(tc);\n\tbool phy_is_owned = tc_phy_is_owned(tc);\n\tbool is_connected;\n\n\tif (tc_phy_is_ready_and_owned(tc, phy_is_ready, phy_is_owned))\n\t\tis_connected = port_pll_type == ICL_PORT_DPLL_MG_PHY;\n\telse\n\t\tis_connected = port_pll_type == ICL_PORT_DPLL_DEFAULT;\n\n\tdrm_dbg_kms(&i915->drm,\n\t\t    \"Port %s: PHY connected: %s (ready: %s, owned: %s, pll_type: %s)\\n\",\n\t\t    tc->port_name,\n\t\t    str_yes_no(is_connected),\n\t\t    str_yes_no(phy_is_ready),\n\t\t    str_yes_no(phy_is_owned),\n\t\t    port_pll_type == ICL_PORT_DPLL_DEFAULT ? \"tbt\" : \"non-tbt\");\n\n\treturn is_connected;\n}\n\nstatic bool tc_phy_wait_for_ready(struct intel_tc_port *tc)\n{\n\tstruct drm_i915_private *i915 = tc_to_i915(tc);\n\n\tif (wait_for(tc_phy_is_ready(tc), 500)) {\n\t\tdrm_err(&i915->drm, \"Port %s: timeout waiting for PHY ready\\n\",\n\t\t\ttc->port_name);\n\n\t\treturn false;\n\t}\n\n\treturn true;\n}\n\nstatic enum tc_port_mode\nhpd_mask_to_tc_mode(u32 live_status_mask)\n{\n\tif (live_status_mask)\n\t\treturn fls(live_status_mask) - 1;\n\n\treturn TC_PORT_DISCONNECTED;\n}\n\nstatic enum tc_port_mode\ntc_phy_hpd_live_mode(struct intel_tc_port *tc)\n{\n\tu32 live_status_mask = tc_phy_hpd_live_status(tc);\n\n\treturn hpd_mask_to_tc_mode(live_status_mask);\n}\n\nstatic enum tc_port_mode\nget_tc_mode_in_phy_owned_state(struct intel_tc_port *tc,\n\t\t\t       enum tc_port_mode live_mode)\n{\n\tswitch (live_mode) {\n\tcase TC_PORT_LEGACY:\n\tcase TC_PORT_DP_ALT:\n\t\treturn live_mode;\n\tdefault:\n\t\tMISSING_CASE(live_mode);\n\t\tfallthrough;\n\tcase TC_PORT_TBT_ALT:\n\tcase TC_PORT_DISCONNECTED:\n\t\tif (tc->legacy_port)\n\t\t\treturn TC_PORT_LEGACY;\n\t\telse\n\t\t\treturn TC_PORT_DP_ALT;\n\t}\n}\n\nstatic enum tc_port_mode\nget_tc_mode_in_phy_not_owned_state(struct intel_tc_port *tc,\n\t\t\t\t   enum tc_port_mode live_mode)\n{\n\tswitch (live_mode) {\n\tcase TC_PORT_LEGACY:\n\t\treturn TC_PORT_DISCONNECTED;\n\tcase TC_PORT_DP_ALT:\n\tcase TC_PORT_TBT_ALT:\n\t\treturn TC_PORT_TBT_ALT;\n\tdefault:\n\t\tMISSING_CASE(live_mode);\n\t\tfallthrough;\n\tcase TC_PORT_DISCONNECTED:\n\t\tif (tc->legacy_port)\n\t\t\treturn TC_PORT_DISCONNECTED;\n\t\telse\n\t\t\treturn TC_PORT_TBT_ALT;\n\t}\n}\n\nstatic enum tc_port_mode\ntc_phy_get_current_mode(struct intel_tc_port *tc)\n{\n\tstruct drm_i915_private *i915 = tc_to_i915(tc);\n\tenum tc_port_mode live_mode = tc_phy_hpd_live_mode(tc);\n\tbool phy_is_ready;\n\tbool phy_is_owned;\n\tenum tc_port_mode mode;\n\n\t \n\tif (tc->legacy_port)\n\t\ttc_phy_wait_for_ready(tc);\n\n\tphy_is_ready = tc_phy_is_ready(tc);\n\tphy_is_owned = tc_phy_is_owned(tc);\n\n\tif (!tc_phy_is_ready_and_owned(tc, phy_is_ready, phy_is_owned)) {\n\t\tmode = get_tc_mode_in_phy_not_owned_state(tc, live_mode);\n\t} else {\n\t\tdrm_WARN_ON(&i915->drm, live_mode == TC_PORT_TBT_ALT);\n\t\tmode = get_tc_mode_in_phy_owned_state(tc, live_mode);\n\t}\n\n\tdrm_dbg_kms(&i915->drm,\n\t\t    \"Port %s: PHY mode: %s (ready: %s, owned: %s, HPD: %s)\\n\",\n\t\t    tc->port_name,\n\t\t    tc_port_mode_name(mode),\n\t\t    str_yes_no(phy_is_ready),\n\t\t    str_yes_no(phy_is_owned),\n\t\t    tc_port_mode_name(live_mode));\n\n\treturn mode;\n}\n\nstatic enum tc_port_mode default_tc_mode(struct intel_tc_port *tc)\n{\n\tif (tc->legacy_port)\n\t\treturn TC_PORT_LEGACY;\n\n\treturn TC_PORT_TBT_ALT;\n}\n\nstatic enum tc_port_mode\nhpd_mask_to_target_mode(struct intel_tc_port *tc, u32 live_status_mask)\n{\n\tenum tc_port_mode mode = hpd_mask_to_tc_mode(live_status_mask);\n\n\tif (mode != TC_PORT_DISCONNECTED)\n\t\treturn mode;\n\n\treturn default_tc_mode(tc);\n}\n\nstatic enum tc_port_mode\ntc_phy_get_target_mode(struct intel_tc_port *tc)\n{\n\tu32 live_status_mask = tc_phy_hpd_live_status(tc);\n\n\treturn hpd_mask_to_target_mode(tc, live_status_mask);\n}\n\nstatic void tc_phy_connect(struct intel_tc_port *tc, int required_lanes)\n{\n\tstruct drm_i915_private *i915 = tc_to_i915(tc);\n\tu32 live_status_mask = tc_phy_hpd_live_status(tc);\n\tbool connected;\n\n\ttc_port_fixup_legacy_flag(tc, live_status_mask);\n\n\ttc->mode = hpd_mask_to_target_mode(tc, live_status_mask);\n\n\tconnected = tc->phy_ops->connect(tc, required_lanes);\n\tif (!connected && tc->mode != default_tc_mode(tc)) {\n\t\ttc->mode = default_tc_mode(tc);\n\t\tconnected = tc->phy_ops->connect(tc, required_lanes);\n\t}\n\n\tdrm_WARN_ON(&i915->drm, !connected);\n}\n\nstatic void tc_phy_disconnect(struct intel_tc_port *tc)\n{\n\tif (tc->mode != TC_PORT_DISCONNECTED) {\n\t\ttc->phy_ops->disconnect(tc);\n\t\ttc->mode = TC_PORT_DISCONNECTED;\n\t}\n}\n\nstatic void tc_phy_init(struct intel_tc_port *tc)\n{\n\tmutex_lock(&tc->lock);\n\ttc->phy_ops->init(tc);\n\tmutex_unlock(&tc->lock);\n}\n\nstatic void intel_tc_port_reset_mode(struct intel_tc_port *tc,\n\t\t\t\t     int required_lanes, bool force_disconnect)\n{\n\tstruct drm_i915_private *i915 = tc_to_i915(tc);\n\tstruct intel_digital_port *dig_port = tc->dig_port;\n\tenum tc_port_mode old_tc_mode = tc->mode;\n\n\tintel_display_power_flush_work(i915);\n\tif (!intel_tc_cold_requires_aux_pw(dig_port)) {\n\t\tenum intel_display_power_domain aux_domain;\n\t\tbool aux_powered;\n\n\t\taux_domain = intel_aux_power_domain(dig_port);\n\t\taux_powered = intel_display_power_is_enabled(i915, aux_domain);\n\t\tdrm_WARN_ON(&i915->drm, aux_powered);\n\t}\n\n\ttc_phy_disconnect(tc);\n\tif (!force_disconnect)\n\t\ttc_phy_connect(tc, required_lanes);\n\n\tdrm_dbg_kms(&i915->drm, \"Port %s: TC port mode reset (%s -> %s)\\n\",\n\t\t    tc->port_name,\n\t\t    tc_port_mode_name(old_tc_mode),\n\t\t    tc_port_mode_name(tc->mode));\n}\n\nstatic bool intel_tc_port_needs_reset(struct intel_tc_port *tc)\n{\n\treturn tc_phy_get_target_mode(tc) != tc->mode;\n}\n\nstatic void intel_tc_port_update_mode(struct intel_tc_port *tc,\n\t\t\t\t      int required_lanes, bool force_disconnect)\n{\n\tif (force_disconnect ||\n\t    intel_tc_port_needs_reset(tc))\n\t\tintel_tc_port_reset_mode(tc, required_lanes, force_disconnect);\n}\n\nstatic void __intel_tc_port_get_link(struct intel_tc_port *tc)\n{\n\ttc->link_refcount++;\n}\n\nstatic void __intel_tc_port_put_link(struct intel_tc_port *tc)\n{\n\ttc->link_refcount--;\n}\n\nstatic bool tc_port_is_enabled(struct intel_tc_port *tc)\n{\n\tstruct drm_i915_private *i915 = tc_to_i915(tc);\n\tstruct intel_digital_port *dig_port = tc->dig_port;\n\n\tassert_tc_port_power_enabled(tc);\n\n\treturn intel_de_read(i915, DDI_BUF_CTL(dig_port->base.port)) &\n\t       DDI_BUF_CTL_ENABLE;\n}\n\n \nvoid intel_tc_port_init_mode(struct intel_digital_port *dig_port)\n{\n\tstruct drm_i915_private *i915 = to_i915(dig_port->base.base.dev);\n\tstruct intel_tc_port *tc = to_tc_port(dig_port);\n\tbool update_mode = false;\n\n\tmutex_lock(&tc->lock);\n\n\tdrm_WARN_ON(&i915->drm, tc->mode != TC_PORT_DISCONNECTED);\n\tdrm_WARN_ON(&i915->drm, tc->lock_wakeref);\n\tdrm_WARN_ON(&i915->drm, tc->link_refcount);\n\n\ttc_phy_get_hw_state(tc);\n\t \n\ttc->init_mode = tc->mode;\n\n\t \n\tif (!tc_port_is_enabled(tc)) {\n\t\tupdate_mode = true;\n\t} else if (tc->mode == TC_PORT_DISCONNECTED) {\n\t\tdrm_WARN_ON(&i915->drm, !tc->legacy_port);\n\t\tdrm_err(&i915->drm,\n\t\t\t\"Port %s: PHY disconnected on enabled port, connecting it\\n\",\n\t\t\ttc->port_name);\n\t\tupdate_mode = true;\n\t}\n\n\tif (update_mode)\n\t\tintel_tc_port_update_mode(tc, 1, false);\n\n\t \n\t__intel_tc_port_get_link(tc);\n\n\tmutex_unlock(&tc->lock);\n}\n\nstatic bool tc_port_has_active_links(struct intel_tc_port *tc,\n\t\t\t\t     const struct intel_crtc_state *crtc_state)\n{\n\tstruct drm_i915_private *i915 = tc_to_i915(tc);\n\tstruct intel_digital_port *dig_port = tc->dig_port;\n\tenum icl_port_dpll_id pll_type = ICL_PORT_DPLL_DEFAULT;\n\tint active_links = 0;\n\n\tif (dig_port->dp.is_mst) {\n\t\t \n\t\tactive_links = intel_dp_mst_encoder_active_links(dig_port);\n\t} else if (crtc_state && crtc_state->hw.active) {\n\t\tpll_type = intel_ddi_port_pll_type(&dig_port->base, crtc_state);\n\t\tactive_links = 1;\n\t}\n\n\tif (active_links && !tc_phy_is_connected(tc, pll_type))\n\t\tdrm_err(&i915->drm,\n\t\t\t\"Port %s: PHY disconnected with %d active link(s)\\n\",\n\t\t\ttc->port_name, active_links);\n\n\treturn active_links;\n}\n\n \nvoid intel_tc_port_sanitize_mode(struct intel_digital_port *dig_port,\n\t\t\t\t const struct intel_crtc_state *crtc_state)\n{\n\tstruct drm_i915_private *i915 = to_i915(dig_port->base.base.dev);\n\tstruct intel_tc_port *tc = to_tc_port(dig_port);\n\n\tmutex_lock(&tc->lock);\n\n\tdrm_WARN_ON(&i915->drm, tc->link_refcount != 1);\n\tif (!tc_port_has_active_links(tc, crtc_state)) {\n\t\t \n\t\tif (tc->init_mode != TC_PORT_TBT_ALT &&\n\t\t    tc->init_mode != TC_PORT_DISCONNECTED)\n\t\t\tdrm_dbg_kms(&i915->drm,\n\t\t\t\t    \"Port %s: PHY left in %s mode on disabled port, disconnecting it\\n\",\n\t\t\t\t    tc->port_name,\n\t\t\t\t    tc_port_mode_name(tc->init_mode));\n\t\ttc_phy_disconnect(tc);\n\t\t__intel_tc_port_put_link(tc);\n\t}\n\n\tdrm_dbg_kms(&i915->drm, \"Port %s: sanitize mode (%s)\\n\",\n\t\t    tc->port_name,\n\t\t    tc_port_mode_name(tc->mode));\n\n\tmutex_unlock(&tc->lock);\n}\n\n \nbool intel_tc_port_connected_locked(struct intel_encoder *encoder)\n{\n\tstruct intel_digital_port *dig_port = enc_to_dig_port(encoder);\n\tstruct drm_i915_private *i915 = to_i915(dig_port->base.base.dev);\n\tstruct intel_tc_port *tc = to_tc_port(dig_port);\n\tu32 mask = ~0;\n\n\tdrm_WARN_ON(&i915->drm, !intel_tc_port_ref_held(dig_port));\n\n\tif (tc->mode != TC_PORT_DISCONNECTED)\n\t\tmask = BIT(tc->mode);\n\n\treturn tc_phy_hpd_live_status(tc) & mask;\n}\n\nbool intel_tc_port_connected(struct intel_encoder *encoder)\n{\n\tstruct intel_digital_port *dig_port = enc_to_dig_port(encoder);\n\tstruct intel_tc_port *tc = to_tc_port(dig_port);\n\tbool is_connected;\n\n\tmutex_lock(&tc->lock);\n\tis_connected = intel_tc_port_connected_locked(encoder);\n\tmutex_unlock(&tc->lock);\n\n\treturn is_connected;\n}\n\nstatic bool __intel_tc_port_link_needs_reset(struct intel_tc_port *tc)\n{\n\tbool ret;\n\n\tmutex_lock(&tc->lock);\n\n\tret = tc->link_refcount &&\n\t      tc->mode == TC_PORT_DP_ALT &&\n\t      intel_tc_port_needs_reset(tc);\n\n\tmutex_unlock(&tc->lock);\n\n\treturn ret;\n}\n\nbool intel_tc_port_link_needs_reset(struct intel_digital_port *dig_port)\n{\n\tstruct drm_i915_private *i915 = to_i915(dig_port->base.base.dev);\n\tenum phy phy = intel_port_to_phy(i915, dig_port->base.port);\n\n\tif (!intel_phy_is_tc(i915, phy))\n\t\treturn false;\n\n\treturn __intel_tc_port_link_needs_reset(to_tc_port(dig_port));\n}\n\nstatic int reset_link_commit(struct intel_tc_port *tc,\n\t\t\t     struct intel_atomic_state *state,\n\t\t\t     struct drm_modeset_acquire_ctx *ctx)\n{\n\tstruct drm_i915_private *i915 = tc_to_i915(tc);\n\tstruct intel_digital_port *dig_port = tc->dig_port;\n\tstruct intel_dp *intel_dp = enc_to_intel_dp(&dig_port->base);\n\tstruct intel_crtc *crtc;\n\tu8 pipe_mask;\n\tint ret;\n\n\tret = drm_modeset_lock(&i915->drm.mode_config.connection_mutex, ctx);\n\tif (ret)\n\t\treturn ret;\n\n\tret = intel_dp_get_active_pipes(intel_dp, ctx, &pipe_mask);\n\tif (ret)\n\t\treturn ret;\n\n\tif (!pipe_mask)\n\t\treturn 0;\n\n\tfor_each_intel_crtc_in_pipe_mask(&i915->drm, crtc, pipe_mask) {\n\t\tstruct intel_crtc_state *crtc_state;\n\n\t\tcrtc_state = intel_atomic_get_crtc_state(&state->base, crtc);\n\t\tif (IS_ERR(crtc_state))\n\t\t\treturn PTR_ERR(crtc_state);\n\n\t\tcrtc_state->uapi.connectors_changed = true;\n\t}\n\n\tif (!__intel_tc_port_link_needs_reset(tc))\n\t\treturn 0;\n\n\treturn drm_atomic_commit(&state->base);\n}\n\nstatic int reset_link(struct intel_tc_port *tc)\n{\n\tstruct drm_i915_private *i915 = tc_to_i915(tc);\n\tstruct drm_modeset_acquire_ctx ctx;\n\tstruct drm_atomic_state *_state;\n\tstruct intel_atomic_state *state;\n\tint ret;\n\n\t_state = drm_atomic_state_alloc(&i915->drm);\n\tif (!_state)\n\t\treturn -ENOMEM;\n\n\tstate = to_intel_atomic_state(_state);\n\tstate->internal = true;\n\n\tintel_modeset_lock_ctx_retry(&ctx, state, 0, ret)\n\t\tret = reset_link_commit(tc, state, &ctx);\n\n\tdrm_atomic_state_put(&state->base);\n\n\treturn ret;\n}\n\nstatic void intel_tc_port_link_reset_work(struct work_struct *work)\n{\n\tstruct intel_tc_port *tc =\n\t\tcontainer_of(work, struct intel_tc_port, link_reset_work.work);\n\tstruct drm_i915_private *i915 = tc_to_i915(tc);\n\tint ret;\n\n\tif (!__intel_tc_port_link_needs_reset(tc))\n\t\treturn;\n\n\tmutex_lock(&i915->drm.mode_config.mutex);\n\n\tdrm_dbg_kms(&i915->drm,\n\t\t    \"Port %s: TypeC DP-alt sink disconnected, resetting link\\n\",\n\t\t    tc->port_name);\n\tret = reset_link(tc);\n\tdrm_WARN_ON(&i915->drm, ret);\n\n\tmutex_unlock(&i915->drm.mode_config.mutex);\n}\n\nbool intel_tc_port_link_reset(struct intel_digital_port *dig_port)\n{\n\tif (!intel_tc_port_link_needs_reset(dig_port))\n\t\treturn false;\n\n\tqueue_delayed_work(system_unbound_wq,\n\t\t\t   &to_tc_port(dig_port)->link_reset_work,\n\t\t\t   msecs_to_jiffies(2000));\n\n\treturn true;\n}\n\nvoid intel_tc_port_link_cancel_reset_work(struct intel_digital_port *dig_port)\n{\n\tstruct drm_i915_private *i915 = to_i915(dig_port->base.base.dev);\n\tenum phy phy = intel_port_to_phy(i915, dig_port->base.port);\n\tstruct intel_tc_port *tc = to_tc_port(dig_port);\n\n\tif (!intel_phy_is_tc(i915, phy))\n\t\treturn;\n\n\tcancel_delayed_work(&tc->link_reset_work);\n}\n\nstatic void __intel_tc_port_lock(struct intel_tc_port *tc,\n\t\t\t\t int required_lanes)\n{\n\tstruct drm_i915_private *i915 = tc_to_i915(tc);\n\n\tmutex_lock(&tc->lock);\n\n\tcancel_delayed_work(&tc->disconnect_phy_work);\n\n\tif (!tc->link_refcount)\n\t\tintel_tc_port_update_mode(tc, required_lanes,\n\t\t\t\t\t  false);\n\n\tdrm_WARN_ON(&i915->drm, tc->mode == TC_PORT_DISCONNECTED);\n\tdrm_WARN_ON(&i915->drm, tc->mode != TC_PORT_TBT_ALT &&\n\t\t\t\t!tc_phy_is_owned(tc));\n}\n\nvoid intel_tc_port_lock(struct intel_digital_port *dig_port)\n{\n\t__intel_tc_port_lock(to_tc_port(dig_port), 1);\n}\n\n \nstatic void intel_tc_port_disconnect_phy_work(struct work_struct *work)\n{\n\tstruct intel_tc_port *tc =\n\t\tcontainer_of(work, struct intel_tc_port, disconnect_phy_work.work);\n\n\tmutex_lock(&tc->lock);\n\n\tif (!tc->link_refcount)\n\t\tintel_tc_port_update_mode(tc, 1, true);\n\n\tmutex_unlock(&tc->lock);\n}\n\n \nstatic void intel_tc_port_flush_work(struct intel_digital_port *dig_port)\n{\n\tflush_delayed_work(&to_tc_port(dig_port)->disconnect_phy_work);\n}\n\nvoid intel_tc_port_suspend(struct intel_digital_port *dig_port)\n{\n\tstruct intel_tc_port *tc = to_tc_port(dig_port);\n\n\tcancel_delayed_work_sync(&tc->link_reset_work);\n\tintel_tc_port_flush_work(dig_port);\n}\n\nvoid intel_tc_port_unlock(struct intel_digital_port *dig_port)\n{\n\tstruct intel_tc_port *tc = to_tc_port(dig_port);\n\n\tif (!tc->link_refcount && tc->mode != TC_PORT_DISCONNECTED)\n\t\tqueue_delayed_work(system_unbound_wq, &tc->disconnect_phy_work,\n\t\t\t\t   msecs_to_jiffies(1000));\n\n\tmutex_unlock(&tc->lock);\n}\n\nbool intel_tc_port_ref_held(struct intel_digital_port *dig_port)\n{\n\tstruct intel_tc_port *tc = to_tc_port(dig_port);\n\n\treturn mutex_is_locked(&tc->lock) ||\n\t       tc->link_refcount;\n}\n\nvoid intel_tc_port_get_link(struct intel_digital_port *dig_port,\n\t\t\t    int required_lanes)\n{\n\tstruct intel_tc_port *tc = to_tc_port(dig_port);\n\n\t__intel_tc_port_lock(tc, required_lanes);\n\t__intel_tc_port_get_link(tc);\n\tintel_tc_port_unlock(dig_port);\n}\n\nvoid intel_tc_port_put_link(struct intel_digital_port *dig_port)\n{\n\tstruct intel_tc_port *tc = to_tc_port(dig_port);\n\n\tintel_tc_port_lock(dig_port);\n\t__intel_tc_port_put_link(tc);\n\tintel_tc_port_unlock(dig_port);\n\n\t \n\tintel_tc_port_flush_work(dig_port);\n}\n\nint intel_tc_port_init(struct intel_digital_port *dig_port, bool is_legacy)\n{\n\tstruct drm_i915_private *i915 = to_i915(dig_port->base.base.dev);\n\tstruct intel_tc_port *tc;\n\tenum port port = dig_port->base.port;\n\tenum tc_port tc_port = intel_port_to_tc(i915, port);\n\n\tif (drm_WARN_ON(&i915->drm, tc_port == TC_PORT_NONE))\n\t\treturn -EINVAL;\n\n\ttc = kzalloc(sizeof(*tc), GFP_KERNEL);\n\tif (!tc)\n\t\treturn -ENOMEM;\n\n\tdig_port->tc = tc;\n\ttc->dig_port = dig_port;\n\n\tif (DISPLAY_VER(i915) >= 14)\n\t\ttc->phy_ops = &xelpdp_tc_phy_ops;\n\telse if (DISPLAY_VER(i915) >= 13)\n\t\ttc->phy_ops = &adlp_tc_phy_ops;\n\telse if (DISPLAY_VER(i915) >= 12)\n\t\ttc->phy_ops = &tgl_tc_phy_ops;\n\telse\n\t\ttc->phy_ops = &icl_tc_phy_ops;\n\n\ttc->port_name = kasprintf(GFP_KERNEL, \"%c/TC#%d\", port_name(port),\n\t\t\t\t  tc_port + 1);\n\tif (!tc->port_name) {\n\t\tkfree(tc);\n\t\treturn -ENOMEM;\n\t}\n\n\tmutex_init(&tc->lock);\n\t \n\tINIT_DELAYED_WORK(&tc->disconnect_phy_work, intel_tc_port_disconnect_phy_work);\n\tINIT_DELAYED_WORK(&tc->link_reset_work, intel_tc_port_link_reset_work);\n\ttc->legacy_port = is_legacy;\n\ttc->mode = TC_PORT_DISCONNECTED;\n\ttc->link_refcount = 0;\n\n\ttc_phy_init(tc);\n\n\tintel_tc_port_init_mode(dig_port);\n\n\treturn 0;\n}\n\nvoid intel_tc_port_cleanup(struct intel_digital_port *dig_port)\n{\n\tintel_tc_port_suspend(dig_port);\n\n\tkfree(dig_port->tc->port_name);\n\tkfree(dig_port->tc);\n\tdig_port->tc = NULL;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}