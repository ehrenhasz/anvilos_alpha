{
  "module_name": "i915_sysfs.c",
  "hash_id": "d99b3a37ec11b6bb5d39a75596dbde72c122098064e36ec55f7b2a2d440862c7",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/i915/i915_sysfs.c",
  "human_readable_source": " \n\n#include <linux/device.h>\n#include <linux/module.h>\n#include <linux/stat.h>\n#include <linux/sysfs.h>\n\n#include \"gt/intel_gt_regs.h\"\n#include \"gt/intel_rc6.h\"\n#include \"gt/intel_rps.h\"\n#include \"gt/sysfs_engines.h\"\n\n#include \"i915_drv.h\"\n#include \"i915_sysfs.h\"\n\nstruct drm_i915_private *kdev_minor_to_i915(struct device *kdev)\n{\n\tstruct drm_minor *minor = dev_get_drvdata(kdev);\n\treturn to_i915(minor->dev);\n}\n\nstatic int l3_access_valid(struct drm_i915_private *i915, loff_t offset)\n{\n\tif (!HAS_L3_DPF(i915))\n\t\treturn -EPERM;\n\n\tif (!IS_ALIGNED(offset, sizeof(u32)))\n\t\treturn -EINVAL;\n\n\tif (offset >= GEN7_L3LOG_SIZE)\n\t\treturn -ENXIO;\n\n\treturn 0;\n}\n\nstatic ssize_t\ni915_l3_read(struct file *filp, struct kobject *kobj,\n\t     struct bin_attribute *attr, char *buf,\n\t     loff_t offset, size_t count)\n{\n\tstruct device *kdev = kobj_to_dev(kobj);\n\tstruct drm_i915_private *i915 = kdev_minor_to_i915(kdev);\n\tint slice = (int)(uintptr_t)attr->private;\n\tint ret;\n\n\tret = l3_access_valid(i915, offset);\n\tif (ret)\n\t\treturn ret;\n\n\tcount = round_down(count, sizeof(u32));\n\tcount = min_t(size_t, GEN7_L3LOG_SIZE - offset, count);\n\tmemset(buf, 0, count);\n\n\tspin_lock(&i915->gem.contexts.lock);\n\tif (i915->l3_parity.remap_info[slice])\n\t\tmemcpy(buf,\n\t\t       i915->l3_parity.remap_info[slice] + offset / sizeof(u32),\n\t\t       count);\n\tspin_unlock(&i915->gem.contexts.lock);\n\n\treturn count;\n}\n\nstatic ssize_t\ni915_l3_write(struct file *filp, struct kobject *kobj,\n\t      struct bin_attribute *attr, char *buf,\n\t      loff_t offset, size_t count)\n{\n\tstruct device *kdev = kobj_to_dev(kobj);\n\tstruct drm_i915_private *i915 = kdev_minor_to_i915(kdev);\n\tint slice = (int)(uintptr_t)attr->private;\n\tu32 *remap_info, *freeme = NULL;\n\tstruct i915_gem_context *ctx;\n\tint ret;\n\n\tret = l3_access_valid(i915, offset);\n\tif (ret)\n\t\treturn ret;\n\n\tif (count < sizeof(u32))\n\t\treturn -EINVAL;\n\n\tremap_info = kzalloc(GEN7_L3LOG_SIZE, GFP_KERNEL);\n\tif (!remap_info)\n\t\treturn -ENOMEM;\n\n\tspin_lock(&i915->gem.contexts.lock);\n\n\tif (i915->l3_parity.remap_info[slice]) {\n\t\tfreeme = remap_info;\n\t\tremap_info = i915->l3_parity.remap_info[slice];\n\t} else {\n\t\ti915->l3_parity.remap_info[slice] = remap_info;\n\t}\n\n\tcount = round_down(count, sizeof(u32));\n\tmemcpy(remap_info + offset / sizeof(u32), buf, count);\n\n\t \n\tlist_for_each_entry(ctx, &i915->gem.contexts.list, link)\n\t\tctx->remap_slice |= BIT(slice);\n\n\tspin_unlock(&i915->gem.contexts.lock);\n\tkfree(freeme);\n\n\t \n\n\treturn count;\n}\n\nstatic const struct bin_attribute dpf_attrs = {\n\t.attr = {.name = \"l3_parity\", .mode = (S_IRUSR | S_IWUSR)},\n\t.size = GEN7_L3LOG_SIZE,\n\t.read = i915_l3_read,\n\t.write = i915_l3_write,\n\t.mmap = NULL,\n\t.private = (void *)0\n};\n\nstatic const struct bin_attribute dpf_attrs_1 = {\n\t.attr = {.name = \"l3_parity_slice_1\", .mode = (S_IRUSR | S_IWUSR)},\n\t.size = GEN7_L3LOG_SIZE,\n\t.read = i915_l3_read,\n\t.write = i915_l3_write,\n\t.mmap = NULL,\n\t.private = (void *)1\n};\n\n#if IS_ENABLED(CONFIG_DRM_I915_CAPTURE_ERROR)\n\nstatic ssize_t error_state_read(struct file *filp, struct kobject *kobj,\n\t\t\t\tstruct bin_attribute *attr, char *buf,\n\t\t\t\tloff_t off, size_t count)\n{\n\n\tstruct device *kdev = kobj_to_dev(kobj);\n\tstruct drm_i915_private *i915 = kdev_minor_to_i915(kdev);\n\tstruct i915_gpu_coredump *gpu;\n\tssize_t ret = 0;\n\n\t \n\n\tgpu = i915_first_error_state(i915);\n\tif (IS_ERR(gpu)) {\n\t\tret = PTR_ERR(gpu);\n\t} else if (gpu) {\n\t\tret = i915_gpu_coredump_copy_to_buffer(gpu, buf, off, count);\n\t\ti915_gpu_coredump_put(gpu);\n\t} else {\n\t\tconst char *str = \"No error state collected\\n\";\n\t\tsize_t len = strlen(str);\n\n\t\tif (off < len) {\n\t\t\tret = min_t(size_t, count, len - off);\n\t\t\tmemcpy(buf, str + off, ret);\n\t\t}\n\t}\n\n\treturn ret;\n}\n\nstatic ssize_t error_state_write(struct file *file, struct kobject *kobj,\n\t\t\t\t struct bin_attribute *attr, char *buf,\n\t\t\t\t loff_t off, size_t count)\n{\n\tstruct device *kdev = kobj_to_dev(kobj);\n\tstruct drm_i915_private *dev_priv = kdev_minor_to_i915(kdev);\n\n\tdrm_dbg(&dev_priv->drm, \"Resetting error state\\n\");\n\ti915_reset_error_state(dev_priv);\n\n\treturn count;\n}\n\nstatic const struct bin_attribute error_state_attr = {\n\t.attr.name = \"error\",\n\t.attr.mode = S_IRUSR | S_IWUSR,\n\t.size = 0,\n\t.read = error_state_read,\n\t.write = error_state_write,\n};\n\nstatic void i915_setup_error_capture(struct device *kdev)\n{\n\tif (sysfs_create_bin_file(&kdev->kobj, &error_state_attr))\n\t\tdrm_err(&kdev_minor_to_i915(kdev)->drm,\n\t\t\t\"error_state sysfs setup failed\\n\");\n}\n\nstatic void i915_teardown_error_capture(struct device *kdev)\n{\n\tsysfs_remove_bin_file(&kdev->kobj, &error_state_attr);\n}\n#else\nstatic void i915_setup_error_capture(struct device *kdev) {}\nstatic void i915_teardown_error_capture(struct device *kdev) {}\n#endif\n\nvoid i915_setup_sysfs(struct drm_i915_private *dev_priv)\n{\n\tstruct device *kdev = dev_priv->drm.primary->kdev;\n\tint ret;\n\n\tif (HAS_L3_DPF(dev_priv)) {\n\t\tret = device_create_bin_file(kdev, &dpf_attrs);\n\t\tif (ret)\n\t\t\tdrm_err(&dev_priv->drm,\n\t\t\t\t\"l3 parity sysfs setup failed\\n\");\n\n\t\tif (NUM_L3_SLICES(dev_priv) > 1) {\n\t\t\tret = device_create_bin_file(kdev,\n\t\t\t\t\t\t     &dpf_attrs_1);\n\t\t\tif (ret)\n\t\t\t\tdrm_err(&dev_priv->drm,\n\t\t\t\t\t\"l3 parity slice 1 setup failed\\n\");\n\t\t}\n\t}\n\n\tdev_priv->sysfs_gt = kobject_create_and_add(\"gt\", &kdev->kobj);\n\tif (!dev_priv->sysfs_gt)\n\t\tdrm_warn(&dev_priv->drm,\n\t\t\t \"failed to register GT sysfs directory\\n\");\n\n\ti915_setup_error_capture(kdev);\n\n\tintel_engines_add_sysfs(dev_priv);\n}\n\nvoid i915_teardown_sysfs(struct drm_i915_private *dev_priv)\n{\n\tstruct device *kdev = dev_priv->drm.primary->kdev;\n\n\ti915_teardown_error_capture(kdev);\n\n\tdevice_remove_bin_file(kdev,  &dpf_attrs_1);\n\tdevice_remove_bin_file(kdev,  &dpf_attrs);\n\n\tkobject_put(dev_priv->sysfs_gt);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}