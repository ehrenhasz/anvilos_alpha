{
  "module_name": "i915_ttm_buddy_manager.c",
  "hash_id": "57214792412a0ffb4d77addef618bdcb5d36d4fa0a2a41da404f7ef99764cd7a",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/i915/i915_ttm_buddy_manager.c",
  "human_readable_source": "\n \n\n#include <linux/slab.h>\n\n#include <drm/ttm/ttm_placement.h>\n#include <drm/ttm/ttm_bo.h>\n\n#include <drm/drm_buddy.h>\n\n#include \"i915_ttm_buddy_manager.h\"\n\n#include \"i915_gem.h\"\n\nstruct i915_ttm_buddy_manager {\n\tstruct ttm_resource_manager manager;\n\tstruct drm_buddy mm;\n\tstruct list_head reserved;\n\tstruct mutex lock;\n\tunsigned long visible_size;\n\tunsigned long visible_avail;\n\tunsigned long visible_reserved;\n\tu64 default_page_size;\n};\n\nstatic struct i915_ttm_buddy_manager *\nto_buddy_manager(struct ttm_resource_manager *man)\n{\n\treturn container_of(man, struct i915_ttm_buddy_manager, manager);\n}\n\nstatic int i915_ttm_buddy_man_alloc(struct ttm_resource_manager *man,\n\t\t\t\t    struct ttm_buffer_object *bo,\n\t\t\t\t    const struct ttm_place *place,\n\t\t\t\t    struct ttm_resource **res)\n{\n\tstruct i915_ttm_buddy_manager *bman = to_buddy_manager(man);\n\tstruct i915_ttm_buddy_resource *bman_res;\n\tstruct drm_buddy *mm = &bman->mm;\n\tunsigned long n_pages, lpfn;\n\tu64 min_page_size;\n\tu64 size;\n\tint err;\n\n\tlpfn = place->lpfn;\n\tif (!lpfn)\n\t\tlpfn = man->size;\n\n\tbman_res = kzalloc(sizeof(*bman_res), GFP_KERNEL);\n\tif (!bman_res)\n\t\treturn -ENOMEM;\n\n\tttm_resource_init(bo, place, &bman_res->base);\n\tINIT_LIST_HEAD(&bman_res->blocks);\n\tbman_res->mm = mm;\n\n\tif (place->flags & TTM_PL_FLAG_TOPDOWN)\n\t\tbman_res->flags |= DRM_BUDDY_TOPDOWN_ALLOCATION;\n\n\tif (place->fpfn || lpfn != man->size)\n\t\tbman_res->flags |= DRM_BUDDY_RANGE_ALLOCATION;\n\n\tGEM_BUG_ON(!bman_res->base.size);\n\tsize = bman_res->base.size;\n\n\tmin_page_size = bman->default_page_size;\n\tif (bo->page_alignment)\n\t\tmin_page_size = bo->page_alignment << PAGE_SHIFT;\n\n\tGEM_BUG_ON(min_page_size < mm->chunk_size);\n\tGEM_BUG_ON(!IS_ALIGNED(size, min_page_size));\n\n\tif (place->fpfn + PFN_UP(bman_res->base.size) != place->lpfn &&\n\t    place->flags & TTM_PL_FLAG_CONTIGUOUS) {\n\t\tunsigned long pages;\n\n\t\tsize = roundup_pow_of_two(size);\n\t\tmin_page_size = size;\n\n\t\tpages = size >> ilog2(mm->chunk_size);\n\t\tif (pages > lpfn)\n\t\t\tlpfn = pages;\n\t}\n\n\tif (size > lpfn << PAGE_SHIFT) {\n\t\terr = -E2BIG;\n\t\tgoto err_free_res;\n\t}\n\n\tn_pages = size >> ilog2(mm->chunk_size);\n\n\tmutex_lock(&bman->lock);\n\tif (lpfn <= bman->visible_size && n_pages > bman->visible_avail) {\n\t\tmutex_unlock(&bman->lock);\n\t\terr = -ENOSPC;\n\t\tgoto err_free_res;\n\t}\n\n\terr = drm_buddy_alloc_blocks(mm, (u64)place->fpfn << PAGE_SHIFT,\n\t\t\t\t     (u64)lpfn << PAGE_SHIFT,\n\t\t\t\t     (u64)n_pages << PAGE_SHIFT,\n\t\t\t\t     min_page_size,\n\t\t\t\t     &bman_res->blocks,\n\t\t\t\t     bman_res->flags);\n\tif (unlikely(err))\n\t\tgoto err_free_blocks;\n\n\tif (place->flags & TTM_PL_FLAG_CONTIGUOUS) {\n\t\tu64 original_size = (u64)bman_res->base.size;\n\n\t\tdrm_buddy_block_trim(mm,\n\t\t\t\t     original_size,\n\t\t\t\t     &bman_res->blocks);\n\t}\n\n\tif (lpfn <= bman->visible_size) {\n\t\tbman_res->used_visible_size = PFN_UP(bman_res->base.size);\n\t} else {\n\t\tstruct drm_buddy_block *block;\n\n\t\tlist_for_each_entry(block, &bman_res->blocks, link) {\n\t\t\tunsigned long start =\n\t\t\t\tdrm_buddy_block_offset(block) >> PAGE_SHIFT;\n\n\t\t\tif (start < bman->visible_size) {\n\t\t\t\tunsigned long end = start +\n\t\t\t\t\t(drm_buddy_block_size(mm, block) >> PAGE_SHIFT);\n\n\t\t\t\tbman_res->used_visible_size +=\n\t\t\t\t\tmin(end, bman->visible_size) - start;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (bman_res->used_visible_size)\n\t\tbman->visible_avail -= bman_res->used_visible_size;\n\n\tmutex_unlock(&bman->lock);\n\n\t*res = &bman_res->base;\n\treturn 0;\n\nerr_free_blocks:\n\tdrm_buddy_free_list(mm, &bman_res->blocks);\n\tmutex_unlock(&bman->lock);\nerr_free_res:\n\tttm_resource_fini(man, &bman_res->base);\n\tkfree(bman_res);\n\treturn err;\n}\n\nstatic void i915_ttm_buddy_man_free(struct ttm_resource_manager *man,\n\t\t\t\t    struct ttm_resource *res)\n{\n\tstruct i915_ttm_buddy_resource *bman_res = to_ttm_buddy_resource(res);\n\tstruct i915_ttm_buddy_manager *bman = to_buddy_manager(man);\n\n\tmutex_lock(&bman->lock);\n\tdrm_buddy_free_list(&bman->mm, &bman_res->blocks);\n\tbman->visible_avail += bman_res->used_visible_size;\n\tmutex_unlock(&bman->lock);\n\n\tttm_resource_fini(man, res);\n\tkfree(bman_res);\n}\n\nstatic bool i915_ttm_buddy_man_intersects(struct ttm_resource_manager *man,\n\t\t\t\t\t  struct ttm_resource *res,\n\t\t\t\t\t  const struct ttm_place *place,\n\t\t\t\t\t  size_t size)\n{\n\tstruct i915_ttm_buddy_resource *bman_res = to_ttm_buddy_resource(res);\n\tstruct i915_ttm_buddy_manager *bman = to_buddy_manager(man);\n\tstruct drm_buddy *mm = &bman->mm;\n\tstruct drm_buddy_block *block;\n\n\tif (!place->fpfn && !place->lpfn)\n\t\treturn true;\n\n\tGEM_BUG_ON(!place->lpfn);\n\n\t \n\tif (!place->fpfn &&\n\t    place->lpfn == i915_ttm_buddy_man_visible_size(man))\n\t\treturn bman_res->used_visible_size > 0;\n\n\t \n\tlist_for_each_entry(block, &bman_res->blocks, link) {\n\t\tunsigned long fpfn =\n\t\t\tdrm_buddy_block_offset(block) >> PAGE_SHIFT;\n\t\tunsigned long lpfn = fpfn +\n\t\t\t(drm_buddy_block_size(mm, block) >> PAGE_SHIFT);\n\n\t\tif (place->fpfn < lpfn && place->lpfn > fpfn)\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}\n\nstatic bool i915_ttm_buddy_man_compatible(struct ttm_resource_manager *man,\n\t\t\t\t\t  struct ttm_resource *res,\n\t\t\t\t\t  const struct ttm_place *place,\n\t\t\t\t\t  size_t size)\n{\n\tstruct i915_ttm_buddy_resource *bman_res = to_ttm_buddy_resource(res);\n\tstruct i915_ttm_buddy_manager *bman = to_buddy_manager(man);\n\tstruct drm_buddy *mm = &bman->mm;\n\tstruct drm_buddy_block *block;\n\n\tif (!place->fpfn && !place->lpfn)\n\t\treturn true;\n\n\tGEM_BUG_ON(!place->lpfn);\n\n\tif (!place->fpfn &&\n\t    place->lpfn == i915_ttm_buddy_man_visible_size(man))\n\t\treturn bman_res->used_visible_size == PFN_UP(res->size);\n\n\t \n\tlist_for_each_entry(block, &bman_res->blocks, link) {\n\t\tunsigned long fpfn =\n\t\t\tdrm_buddy_block_offset(block) >> PAGE_SHIFT;\n\t\tunsigned long lpfn = fpfn +\n\t\t\t(drm_buddy_block_size(mm, block) >> PAGE_SHIFT);\n\n\t\tif (fpfn < place->fpfn || lpfn > place->lpfn)\n\t\t\treturn false;\n\t}\n\n\treturn true;\n}\n\nstatic void i915_ttm_buddy_man_debug(struct ttm_resource_manager *man,\n\t\t\t\t     struct drm_printer *printer)\n{\n\tstruct i915_ttm_buddy_manager *bman = to_buddy_manager(man);\n\tstruct drm_buddy_block *block;\n\n\tmutex_lock(&bman->lock);\n\tdrm_printf(printer, \"default_page_size: %lluKiB\\n\",\n\t\t   bman->default_page_size >> 10);\n\tdrm_printf(printer, \"visible_avail: %lluMiB\\n\",\n\t\t   (u64)bman->visible_avail << PAGE_SHIFT >> 20);\n\tdrm_printf(printer, \"visible_size: %lluMiB\\n\",\n\t\t   (u64)bman->visible_size << PAGE_SHIFT >> 20);\n\tdrm_printf(printer, \"visible_reserved: %lluMiB\\n\",\n\t\t   (u64)bman->visible_reserved << PAGE_SHIFT >> 20);\n\n\tdrm_buddy_print(&bman->mm, printer);\n\n\tdrm_printf(printer, \"reserved:\\n\");\n\tlist_for_each_entry(block, &bman->reserved, link)\n\t\tdrm_buddy_block_print(&bman->mm, block, printer);\n\tmutex_unlock(&bman->lock);\n}\n\nstatic const struct ttm_resource_manager_func i915_ttm_buddy_manager_func = {\n\t.alloc = i915_ttm_buddy_man_alloc,\n\t.free = i915_ttm_buddy_man_free,\n\t.intersects = i915_ttm_buddy_man_intersects,\n\t.compatible = i915_ttm_buddy_man_compatible,\n\t.debug = i915_ttm_buddy_man_debug,\n};\n\n \nint i915_ttm_buddy_man_init(struct ttm_device *bdev,\n\t\t\t    unsigned int type, bool use_tt,\n\t\t\t    u64 size, u64 visible_size, u64 default_page_size,\n\t\t\t    u64 chunk_size)\n{\n\tstruct ttm_resource_manager *man;\n\tstruct i915_ttm_buddy_manager *bman;\n\tint err;\n\n\tbman = kzalloc(sizeof(*bman), GFP_KERNEL);\n\tif (!bman)\n\t\treturn -ENOMEM;\n\n\terr = drm_buddy_init(&bman->mm, size, chunk_size);\n\tif (err)\n\t\tgoto err_free_bman;\n\n\tmutex_init(&bman->lock);\n\tINIT_LIST_HEAD(&bman->reserved);\n\tGEM_BUG_ON(default_page_size < chunk_size);\n\tbman->default_page_size = default_page_size;\n\tbman->visible_size = visible_size >> PAGE_SHIFT;\n\tbman->visible_avail = bman->visible_size;\n\n\tman = &bman->manager;\n\tman->use_tt = use_tt;\n\tman->func = &i915_ttm_buddy_manager_func;\n\tttm_resource_manager_init(man, bdev, bman->mm.size >> PAGE_SHIFT);\n\n\tttm_resource_manager_set_used(man, true);\n\tttm_set_driver_manager(bdev, type, man);\n\n\treturn 0;\n\nerr_free_bman:\n\tkfree(bman);\n\treturn err;\n}\n\n \nint i915_ttm_buddy_man_fini(struct ttm_device *bdev, unsigned int type)\n{\n\tstruct ttm_resource_manager *man = ttm_manager_type(bdev, type);\n\tstruct i915_ttm_buddy_manager *bman = to_buddy_manager(man);\n\tstruct drm_buddy *mm = &bman->mm;\n\tint ret;\n\n\tttm_resource_manager_set_used(man, false);\n\n\tret = ttm_resource_manager_evict_all(bdev, man);\n\tif (ret)\n\t\treturn ret;\n\n\tttm_set_driver_manager(bdev, type, NULL);\n\n\tmutex_lock(&bman->lock);\n\tdrm_buddy_free_list(mm, &bman->reserved);\n\tdrm_buddy_fini(mm);\n\tbman->visible_avail += bman->visible_reserved;\n\tWARN_ON_ONCE(bman->visible_avail != bman->visible_size);\n\tmutex_unlock(&bman->lock);\n\n\tttm_resource_manager_cleanup(man);\n\tkfree(bman);\n\n\treturn 0;\n}\n\n \nint i915_ttm_buddy_man_reserve(struct ttm_resource_manager *man,\n\t\t\t       u64 start, u64 size)\n{\n\tstruct i915_ttm_buddy_manager *bman = to_buddy_manager(man);\n\tstruct drm_buddy *mm = &bman->mm;\n\tunsigned long fpfn = start >> PAGE_SHIFT;\n\tunsigned long flags = 0;\n\tint ret;\n\n\tflags |= DRM_BUDDY_RANGE_ALLOCATION;\n\n\tmutex_lock(&bman->lock);\n\tret = drm_buddy_alloc_blocks(mm, start,\n\t\t\t\t     start + size,\n\t\t\t\t     size, mm->chunk_size,\n\t\t\t\t     &bman->reserved,\n\t\t\t\t     flags);\n\n\tif (fpfn < bman->visible_size) {\n\t\tunsigned long lpfn = fpfn + (size >> PAGE_SHIFT);\n\t\tunsigned long visible = min(lpfn, bman->visible_size) - fpfn;\n\n\t\tbman->visible_reserved += visible;\n\t\tbman->visible_avail -= visible;\n\t}\n\tmutex_unlock(&bman->lock);\n\n\treturn ret;\n}\n\n \nu64 i915_ttm_buddy_man_visible_size(struct ttm_resource_manager *man)\n{\n\tstruct i915_ttm_buddy_manager *bman = to_buddy_manager(man);\n\n\treturn bman->visible_size;\n}\n\n \nvoid i915_ttm_buddy_man_avail(struct ttm_resource_manager *man,\n\t\t\t      u64 *avail, u64 *visible_avail)\n{\n\tstruct i915_ttm_buddy_manager *bman = to_buddy_manager(man);\n\n\tmutex_lock(&bman->lock);\n\t*avail = bman->mm.avail >> PAGE_SHIFT;\n\t*visible_avail = bman->visible_avail;\n\tmutex_unlock(&bman->lock);\n}\n\n#if IS_ENABLED(CONFIG_DRM_I915_SELFTEST)\nvoid i915_ttm_buddy_man_force_visible_size(struct ttm_resource_manager *man,\n\t\t\t\t\t   u64 size)\n{\n\tstruct i915_ttm_buddy_manager *bman = to_buddy_manager(man);\n\n\tbman->visible_size = size;\n}\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}