{
  "module_name": "i915_gem_internal.c",
  "hash_id": "09153ff6abb4a2b24a4cb48411db16ee684f2a327495e1b6447ef04422d5bee0",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/i915/gem/i915_gem_internal.c",
  "human_readable_source": " \n\n#include <linux/scatterlist.h>\n#include <linux/slab.h>\n\n#include \"i915_drv.h\"\n#include \"i915_gem.h\"\n#include \"i915_gem_internal.h\"\n#include \"i915_gem_object.h\"\n#include \"i915_scatterlist.h\"\n#include \"i915_utils.h\"\n\n#define QUIET (__GFP_NORETRY | __GFP_NOWARN)\n#define MAYFAIL (__GFP_RETRY_MAYFAIL | __GFP_NOWARN)\n\nstatic void internal_free_pages(struct sg_table *st)\n{\n\tstruct scatterlist *sg;\n\n\tfor (sg = st->sgl; sg; sg = __sg_next(sg)) {\n\t\tif (sg_page(sg))\n\t\t\t__free_pages(sg_page(sg), get_order(sg->length));\n\t}\n\n\tsg_free_table(st);\n\tkfree(st);\n}\n\nstatic int i915_gem_object_get_pages_internal(struct drm_i915_gem_object *obj)\n{\n\tstruct drm_i915_private *i915 = to_i915(obj->base.dev);\n\tstruct sg_table *st;\n\tstruct scatterlist *sg;\n\tunsigned int npages;  \n\tint max_order = MAX_ORDER;\n\tunsigned int max_segment;\n\tgfp_t gfp;\n\n\tif (overflows_type(obj->base.size >> PAGE_SHIFT, npages))\n\t\treturn -E2BIG;\n\n\tnpages = obj->base.size >> PAGE_SHIFT;\n\tmax_segment = i915_sg_segment_size(i915->drm.dev) >> PAGE_SHIFT;\n\tmax_order = min(max_order, get_order(max_segment));\n\n\tgfp = GFP_KERNEL | __GFP_HIGHMEM | __GFP_RECLAIMABLE;\n\tif (IS_I965GM(i915) || IS_I965G(i915)) {\n\t\t \n\t\tgfp &= ~__GFP_HIGHMEM;\n\t\tgfp |= __GFP_DMA32;\n\t}\n\ncreate_st:\n\tst = kmalloc(sizeof(*st), GFP_KERNEL);\n\tif (!st)\n\t\treturn -ENOMEM;\n\n\tif (sg_alloc_table(st, npages, GFP_KERNEL)) {\n\t\tkfree(st);\n\t\treturn -ENOMEM;\n\t}\n\n\tsg = st->sgl;\n\tst->nents = 0;\n\n\tdo {\n\t\tint order = min(fls(npages) - 1, max_order);\n\t\tstruct page *page;\n\n\t\tdo {\n\t\t\tpage = alloc_pages(gfp | (order ? QUIET : MAYFAIL),\n\t\t\t\t\t   order);\n\t\t\tif (page)\n\t\t\t\tbreak;\n\t\t\tif (!order--)\n\t\t\t\tgoto err;\n\n\t\t\t \n\t\t\tmax_order = order;\n\t\t} while (1);\n\n\t\tsg_set_page(sg, page, PAGE_SIZE << order, 0);\n\t\tst->nents++;\n\n\t\tnpages -= 1 << order;\n\t\tif (!npages) {\n\t\t\tsg_mark_end(sg);\n\t\t\tbreak;\n\t\t}\n\n\t\tsg = __sg_next(sg);\n\t} while (1);\n\n\tif (i915_gem_gtt_prepare_pages(obj, st)) {\n\t\t \n\t\tif (get_order(st->sgl->length)) {\n\t\t\tinternal_free_pages(st);\n\t\t\tmax_order = 0;\n\t\t\tgoto create_st;\n\t\t}\n\t\tgoto err;\n\t}\n\n\t__i915_gem_object_set_pages(obj, st);\n\n\treturn 0;\n\nerr:\n\tsg_set_page(sg, NULL, 0, 0);\n\tsg_mark_end(sg);\n\tinternal_free_pages(st);\n\n\treturn -ENOMEM;\n}\n\nstatic void i915_gem_object_put_pages_internal(struct drm_i915_gem_object *obj,\n\t\t\t\t\t       struct sg_table *pages)\n{\n\ti915_gem_gtt_finish_pages(obj, pages);\n\tinternal_free_pages(pages);\n\n\tobj->mm.dirty = false;\n\n\t__start_cpu_write(obj);\n}\n\nstatic const struct drm_i915_gem_object_ops i915_gem_object_internal_ops = {\n\t.name = \"i915_gem_object_internal\",\n\t.flags = I915_GEM_OBJECT_IS_SHRINKABLE,\n\t.get_pages = i915_gem_object_get_pages_internal,\n\t.put_pages = i915_gem_object_put_pages_internal,\n};\n\nstruct drm_i915_gem_object *\n__i915_gem_object_create_internal(struct drm_i915_private *i915,\n\t\t\t\t  const struct drm_i915_gem_object_ops *ops,\n\t\t\t\t  phys_addr_t size)\n{\n\tstatic struct lock_class_key lock_class;\n\tstruct drm_i915_gem_object *obj;\n\tunsigned int cache_level;\n\n\tGEM_BUG_ON(!size);\n\tGEM_BUG_ON(!IS_ALIGNED(size, PAGE_SIZE));\n\n\tif (overflows_type(size, obj->base.size))\n\t\treturn ERR_PTR(-E2BIG);\n\n\tobj = i915_gem_object_alloc();\n\tif (!obj)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tdrm_gem_private_object_init(&i915->drm, &obj->base, size);\n\ti915_gem_object_init(obj, ops, &lock_class, 0);\n\tobj->mem_flags |= I915_BO_FLAG_STRUCT_PAGE;\n\n\t \n\ti915_gem_object_set_volatile(obj);\n\n\tobj->read_domains = I915_GEM_DOMAIN_CPU;\n\tobj->write_domain = I915_GEM_DOMAIN_CPU;\n\n\tcache_level = HAS_LLC(i915) ? I915_CACHE_LLC : I915_CACHE_NONE;\n\ti915_gem_object_set_cache_coherency(obj, cache_level);\n\n\treturn obj;\n}\n\n \nstruct drm_i915_gem_object *\ni915_gem_object_create_internal(struct drm_i915_private *i915,\n\t\t\t\tphys_addr_t size)\n{\n\treturn __i915_gem_object_create_internal(i915, &i915_gem_object_internal_ops, size);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}