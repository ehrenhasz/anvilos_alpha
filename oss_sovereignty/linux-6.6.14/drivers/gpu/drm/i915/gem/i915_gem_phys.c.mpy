{
  "module_name": "i915_gem_phys.c",
  "hash_id": "e218b2ee7d9a997659f56d61ed3cc48496f25d97b5d06534d81497f414f671b6",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/i915/gem/i915_gem_phys.c",
  "human_readable_source": " \n\n#include <linux/highmem.h>\n#include <linux/shmem_fs.h>\n#include <linux/swap.h>\n\n#include <drm/drm_cache.h>\n\n#include \"gt/intel_gt.h\"\n#include \"i915_drv.h\"\n#include \"i915_gem_object.h\"\n#include \"i915_gem_region.h\"\n#include \"i915_gem_tiling.h\"\n#include \"i915_scatterlist.h\"\n\nstatic int i915_gem_object_get_pages_phys(struct drm_i915_gem_object *obj)\n{\n\tstruct address_space *mapping = obj->base.filp->f_mapping;\n\tstruct drm_i915_private *i915 = to_i915(obj->base.dev);\n\tstruct scatterlist *sg;\n\tstruct sg_table *st;\n\tdma_addr_t dma;\n\tvoid *vaddr;\n\tvoid *dst;\n\tint i;\n\n\t \n\tif (overflows_type(obj->base.size, sg->length))\n\t\treturn -E2BIG;\n\n\tif (GEM_WARN_ON(i915_gem_object_needs_bit17_swizzle(obj)))\n\t\treturn -EINVAL;\n\n\t \n\tvaddr = dma_alloc_coherent(obj->base.dev->dev,\n\t\t\t\t   roundup_pow_of_two(obj->base.size),\n\t\t\t\t   &dma, GFP_KERNEL);\n\tif (!vaddr)\n\t\treturn -ENOMEM;\n\n\tst = kmalloc(sizeof(*st), GFP_KERNEL);\n\tif (!st)\n\t\tgoto err_pci;\n\n\tif (sg_alloc_table(st, 1, GFP_KERNEL))\n\t\tgoto err_st;\n\n\tsg = st->sgl;\n\tsg->offset = 0;\n\tsg->length = obj->base.size;\n\n\tsg_assign_page(sg, (struct page *)vaddr);\n\tsg_dma_address(sg) = dma;\n\tsg_dma_len(sg) = obj->base.size;\n\n\tdst = vaddr;\n\tfor (i = 0; i < obj->base.size / PAGE_SIZE; i++) {\n\t\tstruct page *page;\n\t\tvoid *src;\n\n\t\tpage = shmem_read_mapping_page(mapping, i);\n\t\tif (IS_ERR(page))\n\t\t\tgoto err_st;\n\n\t\tsrc = kmap_atomic(page);\n\t\tmemcpy(dst, src, PAGE_SIZE);\n\t\tdrm_clflush_virt_range(dst, PAGE_SIZE);\n\t\tkunmap_atomic(src);\n\n\t\tput_page(page);\n\t\tdst += PAGE_SIZE;\n\t}\n\n\tintel_gt_chipset_flush(to_gt(i915));\n\n\t \n\tobj->mem_flags &= ~I915_BO_FLAG_STRUCT_PAGE;\n\t__i915_gem_object_set_pages(obj, st);\n\n\treturn 0;\n\nerr_st:\n\tkfree(st);\nerr_pci:\n\tdma_free_coherent(obj->base.dev->dev,\n\t\t\t  roundup_pow_of_two(obj->base.size),\n\t\t\t  vaddr, dma);\n\treturn -ENOMEM;\n}\n\nvoid\ni915_gem_object_put_pages_phys(struct drm_i915_gem_object *obj,\n\t\t\t       struct sg_table *pages)\n{\n\tdma_addr_t dma = sg_dma_address(pages->sgl);\n\tvoid *vaddr = sg_page(pages->sgl);\n\n\t__i915_gem_object_release_shmem(obj, pages, false);\n\n\tif (obj->mm.dirty) {\n\t\tstruct address_space *mapping = obj->base.filp->f_mapping;\n\t\tvoid *src = vaddr;\n\t\tint i;\n\n\t\tfor (i = 0; i < obj->base.size / PAGE_SIZE; i++) {\n\t\t\tstruct page *page;\n\t\t\tchar *dst;\n\n\t\t\tpage = shmem_read_mapping_page(mapping, i);\n\t\t\tif (IS_ERR(page))\n\t\t\t\tcontinue;\n\n\t\t\tdst = kmap_atomic(page);\n\t\t\tdrm_clflush_virt_range(src, PAGE_SIZE);\n\t\t\tmemcpy(dst, src, PAGE_SIZE);\n\t\t\tkunmap_atomic(dst);\n\n\t\t\tset_page_dirty(page);\n\t\t\tif (obj->mm.madv == I915_MADV_WILLNEED)\n\t\t\t\tmark_page_accessed(page);\n\t\t\tput_page(page);\n\n\t\t\tsrc += PAGE_SIZE;\n\t\t}\n\t\tobj->mm.dirty = false;\n\t}\n\n\tsg_free_table(pages);\n\tkfree(pages);\n\n\tdma_free_coherent(obj->base.dev->dev,\n\t\t\t  roundup_pow_of_two(obj->base.size),\n\t\t\t  vaddr, dma);\n}\n\nint i915_gem_object_pwrite_phys(struct drm_i915_gem_object *obj,\n\t\t\t\tconst struct drm_i915_gem_pwrite *args)\n{\n\tvoid *vaddr = sg_page(obj->mm.pages->sgl) + args->offset;\n\tchar __user *user_data = u64_to_user_ptr(args->data_ptr);\n\tstruct drm_i915_private *i915 = to_i915(obj->base.dev);\n\tint err;\n\n\terr = i915_gem_object_wait(obj,\n\t\t\t\t   I915_WAIT_INTERRUPTIBLE |\n\t\t\t\t   I915_WAIT_ALL,\n\t\t\t\t   MAX_SCHEDULE_TIMEOUT);\n\tif (err)\n\t\treturn err;\n\n\t \n\ti915_gem_object_invalidate_frontbuffer(obj, ORIGIN_CPU);\n\n\tif (copy_from_user(vaddr, user_data, args->size))\n\t\treturn -EFAULT;\n\n\tdrm_clflush_virt_range(vaddr, args->size);\n\tintel_gt_chipset_flush(to_gt(i915));\n\n\ti915_gem_object_flush_frontbuffer(obj, ORIGIN_CPU);\n\treturn 0;\n}\n\nint i915_gem_object_pread_phys(struct drm_i915_gem_object *obj,\n\t\t\t       const struct drm_i915_gem_pread *args)\n{\n\tvoid *vaddr = sg_page(obj->mm.pages->sgl) + args->offset;\n\tchar __user *user_data = u64_to_user_ptr(args->data_ptr);\n\tint err;\n\n\terr = i915_gem_object_wait(obj,\n\t\t\t\t   I915_WAIT_INTERRUPTIBLE,\n\t\t\t\t   MAX_SCHEDULE_TIMEOUT);\n\tif (err)\n\t\treturn err;\n\n\tdrm_clflush_virt_range(vaddr, args->size);\n\tif (copy_to_user(user_data, vaddr, args->size))\n\t\treturn -EFAULT;\n\n\treturn 0;\n}\n\nstatic int i915_gem_object_shmem_to_phys(struct drm_i915_gem_object *obj)\n{\n\tstruct sg_table *pages;\n\tint err;\n\n\tpages = __i915_gem_object_unset_pages(obj);\n\n\terr = i915_gem_object_get_pages_phys(obj);\n\tif (err)\n\t\tgoto err_xfer;\n\n\t \n\t__i915_gem_object_pin_pages(obj);\n\n\tif (!IS_ERR_OR_NULL(pages))\n\t\ti915_gem_object_put_pages_shmem(obj, pages);\n\n\ti915_gem_object_release_memory_region(obj);\n\treturn 0;\n\nerr_xfer:\n\tif (!IS_ERR_OR_NULL(pages))\n\t\t__i915_gem_object_set_pages(obj, pages);\n\treturn err;\n}\n\nint i915_gem_object_attach_phys(struct drm_i915_gem_object *obj, int align)\n{\n\tint err;\n\n\tassert_object_held(obj);\n\n\tif (align > obj->base.size)\n\t\treturn -EINVAL;\n\n\tif (!i915_gem_object_is_shmem(obj))\n\t\treturn -EINVAL;\n\n\tif (!i915_gem_object_has_struct_page(obj))\n\t\treturn 0;\n\n\terr = i915_gem_object_unbind(obj, I915_GEM_OBJECT_UNBIND_ACTIVE);\n\tif (err)\n\t\treturn err;\n\n\tif (obj->mm.madv != I915_MADV_WILLNEED)\n\t\treturn -EFAULT;\n\n\tif (i915_gem_object_has_tiling_quirk(obj))\n\t\treturn -EFAULT;\n\n\tif (obj->mm.mapping || i915_gem_object_has_pinned_pages(obj))\n\t\treturn -EBUSY;\n\n\tif (unlikely(obj->mm.madv != I915_MADV_WILLNEED)) {\n\t\tdrm_dbg(obj->base.dev,\n\t\t\t\"Attempting to obtain a purgeable object\\n\");\n\t\treturn -EFAULT;\n\t}\n\n\treturn i915_gem_object_shmem_to_phys(obj);\n}\n\n#if IS_ENABLED(CONFIG_DRM_I915_SELFTEST)\n#include \"selftests/i915_gem_phys.c\"\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}