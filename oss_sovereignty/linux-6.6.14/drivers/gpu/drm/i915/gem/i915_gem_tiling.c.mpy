{
  "module_name": "i915_gem_tiling.c",
  "hash_id": "1d8d4818f20c31dc18dfceb3754c47a6e077539d8468ff1f4c84b9d1eb8daa3c",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/i915/gem/i915_gem_tiling.c",
  "human_readable_source": " \n\n#include <linux/string.h>\n#include <linux/bitops.h>\n\n#include \"i915_drv.h\"\n#include \"i915_gem.h\"\n#include \"i915_gem_ioctls.h\"\n#include \"i915_gem_mman.h\"\n#include \"i915_gem_object.h\"\n#include \"i915_gem_tiling.h\"\n#include \"i915_reg.h\"\n\n \n\n \nu32 i915_gem_fence_size(struct drm_i915_private *i915,\n\t\t\tu32 size, unsigned int tiling, unsigned int stride)\n{\n\tu32 ggtt_size;\n\n\tGEM_BUG_ON(!size);\n\n\tif (tiling == I915_TILING_NONE)\n\t\treturn size;\n\n\tGEM_BUG_ON(!stride);\n\n\tif (GRAPHICS_VER(i915) >= 4) {\n\t\tstride *= i915_gem_tile_height(tiling);\n\t\tGEM_BUG_ON(!IS_ALIGNED(stride, I965_FENCE_PAGE));\n\t\treturn roundup(size, stride);\n\t}\n\n\t \n\tif (GRAPHICS_VER(i915) == 3)\n\t\tggtt_size = 1024*1024;\n\telse\n\t\tggtt_size = 512*1024;\n\n\twhile (ggtt_size < size)\n\t\tggtt_size <<= 1;\n\n\treturn ggtt_size;\n}\n\n \nu32 i915_gem_fence_alignment(struct drm_i915_private *i915, u32 size,\n\t\t\t     unsigned int tiling, unsigned int stride)\n{\n\tGEM_BUG_ON(!size);\n\n\t \n\tif (tiling == I915_TILING_NONE)\n\t\treturn I915_GTT_MIN_ALIGNMENT;\n\n\tif (GRAPHICS_VER(i915) >= 4)\n\t\treturn I965_FENCE_PAGE;\n\n\t \n\treturn i915_gem_fence_size(i915, size, tiling, stride);\n}\n\n \nstatic bool\ni915_tiling_ok(struct drm_i915_gem_object *obj,\n\t       unsigned int tiling, unsigned int stride)\n{\n\tstruct drm_i915_private *i915 = to_i915(obj->base.dev);\n\tunsigned int tile_width;\n\n\t \n\tif (tiling == I915_TILING_NONE)\n\t\treturn true;\n\n\tif (tiling > I915_TILING_LAST)\n\t\treturn false;\n\n\t \n\t \n\tif (GRAPHICS_VER(i915) >= 7) {\n\t\tif (stride / 128 > GEN7_FENCE_MAX_PITCH_VAL)\n\t\t\treturn false;\n\t} else if (GRAPHICS_VER(i915) >= 4) {\n\t\tif (stride / 128 > I965_FENCE_MAX_PITCH_VAL)\n\t\t\treturn false;\n\t} else {\n\t\tif (stride > 8192)\n\t\t\treturn false;\n\n\t\tif (!is_power_of_2(stride))\n\t\t\treturn false;\n\t}\n\n\tif (GRAPHICS_VER(i915) == 2 ||\n\t    (tiling == I915_TILING_Y && HAS_128_BYTE_Y_TILING(i915)))\n\t\ttile_width = 128;\n\telse\n\t\ttile_width = 512;\n\n\tif (!stride || !IS_ALIGNED(stride, tile_width))\n\t\treturn false;\n\n\treturn true;\n}\n\nstatic bool i915_vma_fence_prepare(struct i915_vma *vma,\n\t\t\t\t   int tiling_mode, unsigned int stride)\n{\n\tstruct drm_i915_private *i915 = vma->vm->i915;\n\tu32 size, alignment;\n\n\tif (!i915_vma_is_map_and_fenceable(vma))\n\t\treturn true;\n\n\tsize = i915_gem_fence_size(i915, vma->size, tiling_mode, stride);\n\tif (i915_vma_size(vma) < size)\n\t\treturn false;\n\n\talignment = i915_gem_fence_alignment(i915, vma->size, tiling_mode, stride);\n\tif (!IS_ALIGNED(i915_ggtt_offset(vma), alignment))\n\t\treturn false;\n\n\treturn true;\n}\n\n \nstatic int\ni915_gem_object_fence_prepare(struct drm_i915_gem_object *obj,\n\t\t\t      int tiling_mode, unsigned int stride)\n{\n\tstruct drm_i915_private *i915 = to_i915(obj->base.dev);\n\tstruct i915_ggtt *ggtt = to_gt(i915)->ggtt;\n\tstruct i915_vma *vma, *vn;\n\tLIST_HEAD(unbind);\n\tint ret = 0;\n\n\tif (tiling_mode == I915_TILING_NONE)\n\t\treturn 0;\n\n\tmutex_lock(&ggtt->vm.mutex);\n\n\tspin_lock(&obj->vma.lock);\n\tfor_each_ggtt_vma(vma, obj) {\n\t\tGEM_BUG_ON(vma->vm != &ggtt->vm);\n\n\t\tif (i915_vma_fence_prepare(vma, tiling_mode, stride))\n\t\t\tcontinue;\n\n\t\tlist_move(&vma->vm_link, &unbind);\n\t}\n\tspin_unlock(&obj->vma.lock);\n\n\tlist_for_each_entry_safe(vma, vn, &unbind, vm_link) {\n\t\tret = __i915_vma_unbind(vma);\n\t\tif (ret) {\n\t\t\t \n\t\t\tlist_splice(&unbind, &ggtt->vm.bound_list);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tmutex_unlock(&ggtt->vm.mutex);\n\n\treturn ret;\n}\n\nbool i915_gem_object_needs_bit17_swizzle(struct drm_i915_gem_object *obj)\n{\n\tstruct drm_i915_private *i915 = to_i915(obj->base.dev);\n\n\treturn to_gt(i915)->ggtt->bit_6_swizzle_x == I915_BIT_6_SWIZZLE_9_10_17 &&\n\t\ti915_gem_object_is_tiled(obj);\n}\n\nint\ni915_gem_object_set_tiling(struct drm_i915_gem_object *obj,\n\t\t\t   unsigned int tiling, unsigned int stride)\n{\n\tstruct drm_i915_private *i915 = to_i915(obj->base.dev);\n\tstruct i915_vma *vma;\n\tint err;\n\n\t \n\tBUILD_BUG_ON(I915_TILING_LAST & STRIDE_MASK);\n\n\tGEM_BUG_ON(!i915_tiling_ok(obj, tiling, stride));\n\tGEM_BUG_ON(!stride ^ (tiling == I915_TILING_NONE));\n\n\tif ((tiling | stride) == obj->tiling_and_stride)\n\t\treturn 0;\n\n\tif (i915_gem_object_is_framebuffer(obj))\n\t\treturn -EBUSY;\n\n\t \n\n\ti915_gem_object_lock(obj, NULL);\n\tif (i915_gem_object_is_framebuffer(obj)) {\n\t\ti915_gem_object_unlock(obj);\n\t\treturn -EBUSY;\n\t}\n\n\terr = i915_gem_object_fence_prepare(obj, tiling, stride);\n\tif (err) {\n\t\ti915_gem_object_unlock(obj);\n\t\treturn err;\n\t}\n\n\t \n\tif (i915_gem_object_has_pages(obj) &&\n\t    obj->mm.madv == I915_MADV_WILLNEED &&\n\t    i915->gem_quirks & GEM_QUIRK_PIN_SWIZZLED_PAGES) {\n\t\tif (tiling == I915_TILING_NONE) {\n\t\t\tGEM_BUG_ON(!i915_gem_object_has_tiling_quirk(obj));\n\t\t\ti915_gem_object_clear_tiling_quirk(obj);\n\t\t\ti915_gem_object_make_shrinkable(obj);\n\t\t}\n\t\tif (!i915_gem_object_is_tiled(obj)) {\n\t\t\tGEM_BUG_ON(i915_gem_object_has_tiling_quirk(obj));\n\t\t\ti915_gem_object_make_unshrinkable(obj);\n\t\t\ti915_gem_object_set_tiling_quirk(obj);\n\t\t}\n\t}\n\n\tspin_lock(&obj->vma.lock);\n\tfor_each_ggtt_vma(vma, obj) {\n\t\tvma->fence_size =\n\t\t\ti915_gem_fence_size(i915, vma->size, tiling, stride);\n\t\tvma->fence_alignment =\n\t\t\ti915_gem_fence_alignment(i915,\n\t\t\t\t\t\t vma->size, tiling, stride);\n\n\t\tif (vma->fence)\n\t\t\tvma->fence->dirty = true;\n\t}\n\tspin_unlock(&obj->vma.lock);\n\n\tobj->tiling_and_stride = tiling | stride;\n\n\t \n\tif (i915_gem_object_needs_bit17_swizzle(obj)) {\n\t\tif (!obj->bit_17) {\n\t\t\tobj->bit_17 = bitmap_zalloc(obj->base.size >> PAGE_SHIFT,\n\t\t\t\t\t\t    GFP_KERNEL);\n\t\t}\n\t} else {\n\t\tbitmap_free(obj->bit_17);\n\t\tobj->bit_17 = NULL;\n\t}\n\n\ti915_gem_object_unlock(obj);\n\n\t \n\ti915_gem_object_release_mmap_gtt(obj);\n\n\treturn 0;\n}\n\n \nint\ni915_gem_set_tiling_ioctl(struct drm_device *dev, void *data,\n\t\t\t  struct drm_file *file)\n{\n\tstruct drm_i915_private *dev_priv = to_i915(dev);\n\tstruct drm_i915_gem_set_tiling *args = data;\n\tstruct drm_i915_gem_object *obj;\n\tint err;\n\n\tif (!to_gt(dev_priv)->ggtt->num_fences)\n\t\treturn -EOPNOTSUPP;\n\n\tobj = i915_gem_object_lookup(file, args->handle);\n\tif (!obj)\n\t\treturn -ENOENT;\n\n\t \n\tif (i915_gem_object_is_proxy(obj)) {\n\t\terr = -ENXIO;\n\t\tgoto err;\n\t}\n\n\tif (!i915_tiling_ok(obj, args->tiling_mode, args->stride)) {\n\t\terr = -EINVAL;\n\t\tgoto err;\n\t}\n\n\tif (args->tiling_mode == I915_TILING_NONE) {\n\t\targs->swizzle_mode = I915_BIT_6_SWIZZLE_NONE;\n\t\targs->stride = 0;\n\t} else {\n\t\tif (args->tiling_mode == I915_TILING_X)\n\t\t\targs->swizzle_mode = to_gt(dev_priv)->ggtt->bit_6_swizzle_x;\n\t\telse\n\t\t\targs->swizzle_mode = to_gt(dev_priv)->ggtt->bit_6_swizzle_y;\n\n\t\t \n\t\tif (args->swizzle_mode == I915_BIT_6_SWIZZLE_9_17)\n\t\t\targs->swizzle_mode = I915_BIT_6_SWIZZLE_9;\n\t\tif (args->swizzle_mode == I915_BIT_6_SWIZZLE_9_10_17)\n\t\t\targs->swizzle_mode = I915_BIT_6_SWIZZLE_9_10;\n\n\t\t \n\t\tif (args->swizzle_mode == I915_BIT_6_SWIZZLE_UNKNOWN) {\n\t\t\targs->tiling_mode = I915_TILING_NONE;\n\t\t\targs->swizzle_mode = I915_BIT_6_SWIZZLE_NONE;\n\t\t\targs->stride = 0;\n\t\t}\n\t}\n\n\terr = i915_gem_object_set_tiling(obj, args->tiling_mode, args->stride);\n\n\t \n\targs->stride = i915_gem_object_get_stride(obj);\n\targs->tiling_mode = i915_gem_object_get_tiling(obj);\n\nerr:\n\ti915_gem_object_put(obj);\n\treturn err;\n}\n\n \nint\ni915_gem_get_tiling_ioctl(struct drm_device *dev, void *data,\n\t\t\t  struct drm_file *file)\n{\n\tstruct drm_i915_gem_get_tiling *args = data;\n\tstruct drm_i915_private *dev_priv = to_i915(dev);\n\tstruct drm_i915_gem_object *obj;\n\tint err = -ENOENT;\n\n\tif (!to_gt(dev_priv)->ggtt->num_fences)\n\t\treturn -EOPNOTSUPP;\n\n\trcu_read_lock();\n\tobj = i915_gem_object_lookup_rcu(file, args->handle);\n\tif (obj) {\n\t\targs->tiling_mode =\n\t\t\tREAD_ONCE(obj->tiling_and_stride) & TILING_MASK;\n\t\terr = 0;\n\t}\n\trcu_read_unlock();\n\tif (unlikely(err))\n\t\treturn err;\n\n\tswitch (args->tiling_mode) {\n\tcase I915_TILING_X:\n\t\targs->swizzle_mode = to_gt(dev_priv)->ggtt->bit_6_swizzle_x;\n\t\tbreak;\n\tcase I915_TILING_Y:\n\t\targs->swizzle_mode = to_gt(dev_priv)->ggtt->bit_6_swizzle_y;\n\t\tbreak;\n\tdefault:\n\tcase I915_TILING_NONE:\n\t\targs->swizzle_mode = I915_BIT_6_SWIZZLE_NONE;\n\t\tbreak;\n\t}\n\n\t \n\tif (dev_priv->gem_quirks & GEM_QUIRK_PIN_SWIZZLED_PAGES)\n\t\targs->phys_swizzle_mode = I915_BIT_6_SWIZZLE_UNKNOWN;\n\telse\n\t\targs->phys_swizzle_mode = args->swizzle_mode;\n\tif (args->swizzle_mode == I915_BIT_6_SWIZZLE_9_17)\n\t\targs->swizzle_mode = I915_BIT_6_SWIZZLE_9;\n\tif (args->swizzle_mode == I915_BIT_6_SWIZZLE_9_10_17)\n\t\targs->swizzle_mode = I915_BIT_6_SWIZZLE_9_10;\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}