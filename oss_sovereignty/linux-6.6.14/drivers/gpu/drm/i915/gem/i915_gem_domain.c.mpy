{
  "module_name": "i915_gem_domain.c",
  "hash_id": "56f442b376413559f31820387fb745aaee9382516344b700a1c13cbf48bcf52f",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/i915/gem/i915_gem_domain.c",
  "human_readable_source": " \n\n#include \"display/intel_display.h\"\n#include \"display/intel_frontbuffer.h\"\n#include \"gt/intel_gt.h\"\n\n#include \"i915_drv.h\"\n#include \"i915_gem_clflush.h\"\n#include \"i915_gem_domain.h\"\n#include \"i915_gem_gtt.h\"\n#include \"i915_gem_ioctls.h\"\n#include \"i915_gem_lmem.h\"\n#include \"i915_gem_mman.h\"\n#include \"i915_gem_object.h\"\n#include \"i915_vma.h\"\n\n#define VTD_GUARD (168u * I915_GTT_PAGE_SIZE)  \n\nstatic bool gpu_write_needs_clflush(struct drm_i915_gem_object *obj)\n{\n\tstruct drm_i915_private *i915 = to_i915(obj->base.dev);\n\n\tif (IS_DGFX(i915))\n\t\treturn false;\n\n\t \n\treturn !(i915_gem_object_has_cache_level(obj, I915_CACHE_NONE) ||\n\t\t i915_gem_object_has_cache_level(obj, I915_CACHE_WT));\n}\n\nbool i915_gem_cpu_write_needs_clflush(struct drm_i915_gem_object *obj)\n{\n\tstruct drm_i915_private *i915 = to_i915(obj->base.dev);\n\n\tif (obj->cache_dirty)\n\t\treturn false;\n\n\tif (IS_DGFX(i915))\n\t\treturn false;\n\n\tif (!(obj->cache_coherent & I915_BO_CACHE_COHERENT_FOR_WRITE))\n\t\treturn true;\n\n\t \n\treturn i915_gem_object_is_framebuffer(obj);\n}\n\nstatic void\nflush_write_domain(struct drm_i915_gem_object *obj, unsigned int flush_domains)\n{\n\tstruct i915_vma *vma;\n\n\tassert_object_held(obj);\n\n\tif (!(obj->write_domain & flush_domains))\n\t\treturn;\n\n\tswitch (obj->write_domain) {\n\tcase I915_GEM_DOMAIN_GTT:\n\t\tspin_lock(&obj->vma.lock);\n\t\tfor_each_ggtt_vma(vma, obj)\n\t\t\ti915_vma_flush_writes(vma);\n\t\tspin_unlock(&obj->vma.lock);\n\n\t\ti915_gem_object_flush_frontbuffer(obj, ORIGIN_CPU);\n\t\tbreak;\n\n\tcase I915_GEM_DOMAIN_WC:\n\t\twmb();\n\t\tbreak;\n\n\tcase I915_GEM_DOMAIN_CPU:\n\t\ti915_gem_clflush_object(obj, I915_CLFLUSH_SYNC);\n\t\tbreak;\n\n\tcase I915_GEM_DOMAIN_RENDER:\n\t\tif (gpu_write_needs_clflush(obj))\n\t\t\tobj->cache_dirty = true;\n\t\tbreak;\n\t}\n\n\tobj->write_domain = 0;\n}\n\nstatic void __i915_gem_object_flush_for_display(struct drm_i915_gem_object *obj)\n{\n\t \n\tflush_write_domain(obj, ~I915_GEM_DOMAIN_CPU);\n\tif (obj->cache_dirty)\n\t\ti915_gem_clflush_object(obj, I915_CLFLUSH_FORCE);\n\tobj->write_domain = 0;\n}\n\nvoid i915_gem_object_flush_if_display(struct drm_i915_gem_object *obj)\n{\n\tif (!i915_gem_object_is_framebuffer(obj))\n\t\treturn;\n\n\ti915_gem_object_lock(obj, NULL);\n\t__i915_gem_object_flush_for_display(obj);\n\ti915_gem_object_unlock(obj);\n}\n\nvoid i915_gem_object_flush_if_display_locked(struct drm_i915_gem_object *obj)\n{\n\tif (i915_gem_object_is_framebuffer(obj))\n\t\t__i915_gem_object_flush_for_display(obj);\n}\n\n \nint\ni915_gem_object_set_to_wc_domain(struct drm_i915_gem_object *obj, bool write)\n{\n\tint ret;\n\n\tassert_object_held(obj);\n\n\tret = i915_gem_object_wait(obj,\n\t\t\t\t   I915_WAIT_INTERRUPTIBLE |\n\t\t\t\t   (write ? I915_WAIT_ALL : 0),\n\t\t\t\t   MAX_SCHEDULE_TIMEOUT);\n\tif (ret)\n\t\treturn ret;\n\n\tif (obj->write_domain == I915_GEM_DOMAIN_WC)\n\t\treturn 0;\n\n\t \n\tret = i915_gem_object_pin_pages(obj);\n\tif (ret)\n\t\treturn ret;\n\n\tflush_write_domain(obj, ~I915_GEM_DOMAIN_WC);\n\n\t \n\tif ((obj->read_domains & I915_GEM_DOMAIN_WC) == 0)\n\t\tmb();\n\n\t \n\tGEM_BUG_ON((obj->write_domain & ~I915_GEM_DOMAIN_WC) != 0);\n\tobj->read_domains |= I915_GEM_DOMAIN_WC;\n\tif (write) {\n\t\tobj->read_domains = I915_GEM_DOMAIN_WC;\n\t\tobj->write_domain = I915_GEM_DOMAIN_WC;\n\t\tobj->mm.dirty = true;\n\t}\n\n\ti915_gem_object_unpin_pages(obj);\n\treturn 0;\n}\n\n \nint\ni915_gem_object_set_to_gtt_domain(struct drm_i915_gem_object *obj, bool write)\n{\n\tint ret;\n\n\tassert_object_held(obj);\n\n\tret = i915_gem_object_wait(obj,\n\t\t\t\t   I915_WAIT_INTERRUPTIBLE |\n\t\t\t\t   (write ? I915_WAIT_ALL : 0),\n\t\t\t\t   MAX_SCHEDULE_TIMEOUT);\n\tif (ret)\n\t\treturn ret;\n\n\tif (obj->write_domain == I915_GEM_DOMAIN_GTT)\n\t\treturn 0;\n\n\t \n\tret = i915_gem_object_pin_pages(obj);\n\tif (ret)\n\t\treturn ret;\n\n\tflush_write_domain(obj, ~I915_GEM_DOMAIN_GTT);\n\n\t \n\tif ((obj->read_domains & I915_GEM_DOMAIN_GTT) == 0)\n\t\tmb();\n\n\t \n\tGEM_BUG_ON((obj->write_domain & ~I915_GEM_DOMAIN_GTT) != 0);\n\tobj->read_domains |= I915_GEM_DOMAIN_GTT;\n\tif (write) {\n\t\tstruct i915_vma *vma;\n\n\t\tobj->read_domains = I915_GEM_DOMAIN_GTT;\n\t\tobj->write_domain = I915_GEM_DOMAIN_GTT;\n\t\tobj->mm.dirty = true;\n\n\t\tspin_lock(&obj->vma.lock);\n\t\tfor_each_ggtt_vma(vma, obj)\n\t\t\tif (i915_vma_is_bound(vma, I915_VMA_GLOBAL_BIND))\n\t\t\t\ti915_vma_set_ggtt_write(vma);\n\t\tspin_unlock(&obj->vma.lock);\n\t}\n\n\ti915_gem_object_unpin_pages(obj);\n\treturn 0;\n}\n\n \nint i915_gem_object_set_cache_level(struct drm_i915_gem_object *obj,\n\t\t\t\t    enum i915_cache_level cache_level)\n{\n\tint ret;\n\n\t \n\tif (i915_gem_object_has_cache_level(obj, cache_level))\n\t\treturn 0;\n\n\tret = i915_gem_object_wait(obj,\n\t\t\t\t   I915_WAIT_INTERRUPTIBLE |\n\t\t\t\t   I915_WAIT_ALL,\n\t\t\t\t   MAX_SCHEDULE_TIMEOUT);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\ti915_gem_object_set_cache_coherency(obj, cache_level);\n\tobj->cache_dirty = true;\n\n\t \n\treturn i915_gem_object_unbind(obj,\n\t\t\t\t      I915_GEM_OBJECT_UNBIND_ACTIVE |\n\t\t\t\t      I915_GEM_OBJECT_UNBIND_BARRIER);\n}\n\nint i915_gem_get_caching_ioctl(struct drm_device *dev, void *data,\n\t\t\t       struct drm_file *file)\n{\n\tstruct drm_i915_gem_caching *args = data;\n\tstruct drm_i915_gem_object *obj;\n\tint err = 0;\n\n\tif (IS_DGFX(to_i915(dev)))\n\t\treturn -ENODEV;\n\n\trcu_read_lock();\n\tobj = i915_gem_object_lookup_rcu(file, args->handle);\n\tif (!obj) {\n\t\terr = -ENOENT;\n\t\tgoto out;\n\t}\n\n\t \n\tif (obj->pat_set_by_user) {\n\t\terr = -EOPNOTSUPP;\n\t\tgoto out;\n\t}\n\n\tif (i915_gem_object_has_cache_level(obj, I915_CACHE_LLC) ||\n\t    i915_gem_object_has_cache_level(obj, I915_CACHE_L3_LLC))\n\t\targs->caching = I915_CACHING_CACHED;\n\telse if (i915_gem_object_has_cache_level(obj, I915_CACHE_WT))\n\t\targs->caching = I915_CACHING_DISPLAY;\n\telse\n\t\targs->caching = I915_CACHING_NONE;\nout:\n\trcu_read_unlock();\n\treturn err;\n}\n\nint i915_gem_set_caching_ioctl(struct drm_device *dev, void *data,\n\t\t\t       struct drm_file *file)\n{\n\tstruct drm_i915_private *i915 = to_i915(dev);\n\tstruct drm_i915_gem_caching *args = data;\n\tstruct drm_i915_gem_object *obj;\n\tenum i915_cache_level level;\n\tint ret = 0;\n\n\tif (IS_DGFX(i915))\n\t\treturn -ENODEV;\n\n\tif (GRAPHICS_VER_FULL(i915) >= IP_VER(12, 70))\n\t\treturn -EOPNOTSUPP;\n\n\tswitch (args->caching) {\n\tcase I915_CACHING_NONE:\n\t\tlevel = I915_CACHE_NONE;\n\t\tbreak;\n\tcase I915_CACHING_CACHED:\n\t\t \n\t\tif (!HAS_LLC(i915) && !HAS_SNOOP(i915))\n\t\t\treturn -ENODEV;\n\n\t\tlevel = I915_CACHE_LLC;\n\t\tbreak;\n\tcase I915_CACHING_DISPLAY:\n\t\tlevel = HAS_WT(i915) ? I915_CACHE_WT : I915_CACHE_NONE;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tobj = i915_gem_object_lookup(file, args->handle);\n\tif (!obj)\n\t\treturn -ENOENT;\n\n\t \n\tif (obj->pat_set_by_user) {\n\t\tret = -EOPNOTSUPP;\n\t\tgoto out;\n\t}\n\n\t \n\tif (i915_gem_object_is_proxy(obj)) {\n\t\t \n\t\tif (!i915_gem_object_is_userptr(obj) ||\n\t\t    args->caching != I915_CACHING_CACHED)\n\t\t\tret = -ENXIO;\n\n\t\tgoto out;\n\t}\n\n\tret = i915_gem_object_lock_interruptible(obj, NULL);\n\tif (ret)\n\t\tgoto out;\n\n\tret = i915_gem_object_set_cache_level(obj, level);\n\ti915_gem_object_unlock(obj);\n\nout:\n\ti915_gem_object_put(obj);\n\treturn ret;\n}\n\n \nstruct i915_vma *\ni915_gem_object_pin_to_display_plane(struct drm_i915_gem_object *obj,\n\t\t\t\t     struct i915_gem_ww_ctx *ww,\n\t\t\t\t     u32 alignment,\n\t\t\t\t     const struct i915_gtt_view *view,\n\t\t\t\t     unsigned int flags)\n{\n\tstruct drm_i915_private *i915 = to_i915(obj->base.dev);\n\tstruct i915_vma *vma;\n\tint ret;\n\n\t \n\tif (HAS_LMEM(i915) && !i915_gem_object_is_lmem(obj))\n\t\treturn ERR_PTR(-EINVAL);\n\n\t \n\tret = i915_gem_object_set_cache_level(obj,\n\t\t\t\t\t      HAS_WT(i915) ?\n\t\t\t\t\t      I915_CACHE_WT : I915_CACHE_NONE);\n\tif (ret)\n\t\treturn ERR_PTR(ret);\n\n\t \n\tif (intel_scanout_needs_vtd_wa(i915)) {\n\t\tunsigned int guard = VTD_GUARD;\n\n\t\tif (i915_gem_object_is_tiled(obj))\n\t\t\tguard = max(guard,\n\t\t\t\t    i915_gem_object_get_tile_row_size(obj));\n\n\t\tflags |= PIN_OFFSET_GUARD | guard;\n\t}\n\n\t \n\tvma = ERR_PTR(-ENOSPC);\n\tif ((flags & PIN_MAPPABLE) == 0 &&\n\t    (!view || view->type == I915_GTT_VIEW_NORMAL))\n\t\tvma = i915_gem_object_ggtt_pin_ww(obj, ww, view, 0, alignment,\n\t\t\t\t\t\t  flags | PIN_MAPPABLE |\n\t\t\t\t\t\t  PIN_NONBLOCK);\n\tif (IS_ERR(vma) && vma != ERR_PTR(-EDEADLK))\n\t\tvma = i915_gem_object_ggtt_pin_ww(obj, ww, view, 0,\n\t\t\t\t\t\t  alignment, flags);\n\tif (IS_ERR(vma))\n\t\treturn vma;\n\n\tvma->display_alignment = max(vma->display_alignment, alignment);\n\ti915_vma_mark_scanout(vma);\n\n\ti915_gem_object_flush_if_display_locked(obj);\n\n\treturn vma;\n}\n\n \nint\ni915_gem_object_set_to_cpu_domain(struct drm_i915_gem_object *obj, bool write)\n{\n\tint ret;\n\n\tassert_object_held(obj);\n\n\tret = i915_gem_object_wait(obj,\n\t\t\t\t   I915_WAIT_INTERRUPTIBLE |\n\t\t\t\t   (write ? I915_WAIT_ALL : 0),\n\t\t\t\t   MAX_SCHEDULE_TIMEOUT);\n\tif (ret)\n\t\treturn ret;\n\n\tflush_write_domain(obj, ~I915_GEM_DOMAIN_CPU);\n\n\t \n\tif ((obj->read_domains & I915_GEM_DOMAIN_CPU) == 0) {\n\t\ti915_gem_clflush_object(obj, I915_CLFLUSH_SYNC);\n\t\tobj->read_domains |= I915_GEM_DOMAIN_CPU;\n\t}\n\n\t \n\tGEM_BUG_ON(obj->write_domain & ~I915_GEM_DOMAIN_CPU);\n\n\t \n\tif (write)\n\t\t__start_cpu_write(obj);\n\n\treturn 0;\n}\n\n \nint\ni915_gem_set_domain_ioctl(struct drm_device *dev, void *data,\n\t\t\t  struct drm_file *file)\n{\n\tstruct drm_i915_gem_set_domain *args = data;\n\tstruct drm_i915_gem_object *obj;\n\tu32 read_domains = args->read_domains;\n\tu32 write_domain = args->write_domain;\n\tint err;\n\n\tif (IS_DGFX(to_i915(dev)))\n\t\treturn -ENODEV;\n\n\t \n\tif ((write_domain | read_domains) & I915_GEM_GPU_DOMAINS)\n\t\treturn -EINVAL;\n\n\t \n\tif (write_domain && read_domains != write_domain)\n\t\treturn -EINVAL;\n\n\tif (!read_domains)\n\t\treturn 0;\n\n\tobj = i915_gem_object_lookup(file, args->handle);\n\tif (!obj)\n\t\treturn -ENOENT;\n\n\t \n\terr = i915_gem_object_wait(obj,\n\t\t\t\t   I915_WAIT_INTERRUPTIBLE |\n\t\t\t\t   I915_WAIT_PRIORITY |\n\t\t\t\t   (write_domain ? I915_WAIT_ALL : 0),\n\t\t\t\t   MAX_SCHEDULE_TIMEOUT);\n\tif (err)\n\t\tgoto out;\n\n\tif (i915_gem_object_is_userptr(obj)) {\n\t\t \n\t\terr = i915_gem_object_userptr_validate(obj);\n\t\tif (!err)\n\t\t\terr = i915_gem_object_wait(obj,\n\t\t\t\t\t\t   I915_WAIT_INTERRUPTIBLE |\n\t\t\t\t\t\t   I915_WAIT_PRIORITY |\n\t\t\t\t\t\t   (write_domain ? I915_WAIT_ALL : 0),\n\t\t\t\t\t\t   MAX_SCHEDULE_TIMEOUT);\n\t\tgoto out;\n\t}\n\n\t \n\tif (i915_gem_object_is_proxy(obj)) {\n\t\terr = -ENXIO;\n\t\tgoto out;\n\t}\n\n\terr = i915_gem_object_lock_interruptible(obj, NULL);\n\tif (err)\n\t\tgoto out;\n\n\t \n\terr = i915_gem_object_pin_pages(obj);\n\tif (err)\n\t\tgoto out_unlock;\n\n\t \n\tif (READ_ONCE(obj->write_domain) == read_domains)\n\t\tgoto out_unpin;\n\n\tif (read_domains & I915_GEM_DOMAIN_WC)\n\t\terr = i915_gem_object_set_to_wc_domain(obj, write_domain);\n\telse if (read_domains & I915_GEM_DOMAIN_GTT)\n\t\terr = i915_gem_object_set_to_gtt_domain(obj, write_domain);\n\telse\n\t\terr = i915_gem_object_set_to_cpu_domain(obj, write_domain);\n\nout_unpin:\n\ti915_gem_object_unpin_pages(obj);\n\nout_unlock:\n\ti915_gem_object_unlock(obj);\n\n\tif (!err && write_domain)\n\t\ti915_gem_object_invalidate_frontbuffer(obj, ORIGIN_CPU);\n\nout:\n\ti915_gem_object_put(obj);\n\treturn err;\n}\n\n \nint i915_gem_object_prepare_read(struct drm_i915_gem_object *obj,\n\t\t\t\t unsigned int *needs_clflush)\n{\n\tint ret;\n\n\t*needs_clflush = 0;\n\tif (!i915_gem_object_has_struct_page(obj))\n\t\treturn -ENODEV;\n\n\tassert_object_held(obj);\n\n\tret = i915_gem_object_wait(obj,\n\t\t\t\t   I915_WAIT_INTERRUPTIBLE,\n\t\t\t\t   MAX_SCHEDULE_TIMEOUT);\n\tif (ret)\n\t\treturn ret;\n\n\tret = i915_gem_object_pin_pages(obj);\n\tif (ret)\n\t\treturn ret;\n\n\tif (obj->cache_coherent & I915_BO_CACHE_COHERENT_FOR_READ ||\n\t    !static_cpu_has(X86_FEATURE_CLFLUSH)) {\n\t\tret = i915_gem_object_set_to_cpu_domain(obj, false);\n\t\tif (ret)\n\t\t\tgoto err_unpin;\n\t\telse\n\t\t\tgoto out;\n\t}\n\n\tflush_write_domain(obj, ~I915_GEM_DOMAIN_CPU);\n\n\t \n\tif (!obj->cache_dirty &&\n\t    !(obj->read_domains & I915_GEM_DOMAIN_CPU))\n\t\t*needs_clflush = CLFLUSH_BEFORE;\n\nout:\n\t \n\treturn 0;\n\nerr_unpin:\n\ti915_gem_object_unpin_pages(obj);\n\treturn ret;\n}\n\nint i915_gem_object_prepare_write(struct drm_i915_gem_object *obj,\n\t\t\t\t  unsigned int *needs_clflush)\n{\n\tint ret;\n\n\t*needs_clflush = 0;\n\tif (!i915_gem_object_has_struct_page(obj))\n\t\treturn -ENODEV;\n\n\tassert_object_held(obj);\n\n\tret = i915_gem_object_wait(obj,\n\t\t\t\t   I915_WAIT_INTERRUPTIBLE |\n\t\t\t\t   I915_WAIT_ALL,\n\t\t\t\t   MAX_SCHEDULE_TIMEOUT);\n\tif (ret)\n\t\treturn ret;\n\n\tret = i915_gem_object_pin_pages(obj);\n\tif (ret)\n\t\treturn ret;\n\n\tif (obj->cache_coherent & I915_BO_CACHE_COHERENT_FOR_WRITE ||\n\t    !static_cpu_has(X86_FEATURE_CLFLUSH)) {\n\t\tret = i915_gem_object_set_to_cpu_domain(obj, true);\n\t\tif (ret)\n\t\t\tgoto err_unpin;\n\t\telse\n\t\t\tgoto out;\n\t}\n\n\tflush_write_domain(obj, ~I915_GEM_DOMAIN_CPU);\n\n\t \n\tif (!obj->cache_dirty) {\n\t\t*needs_clflush |= CLFLUSH_AFTER;\n\n\t\t \n\t\tif (!(obj->read_domains & I915_GEM_DOMAIN_CPU))\n\t\t\t*needs_clflush |= CLFLUSH_BEFORE;\n\t}\n\nout:\n\ti915_gem_object_invalidate_frontbuffer(obj, ORIGIN_CPU);\n\tobj->mm.dirty = true;\n\t \n\treturn 0;\n\nerr_unpin:\n\ti915_gem_object_unpin_pages(obj);\n\treturn ret;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}