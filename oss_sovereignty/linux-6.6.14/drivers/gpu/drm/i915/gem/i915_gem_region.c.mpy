{
  "module_name": "i915_gem_region.c",
  "hash_id": "41875abf20fb0ce75e41f7134ad67eeaba5e4fd94311f889a8f3b608a19fb004",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/i915/gem/i915_gem_region.c",
  "human_readable_source": "\n \n\n#include <uapi/drm/i915_drm.h>\n\n#include \"intel_memory_region.h\"\n#include \"i915_gem_region.h\"\n#include \"i915_drv.h\"\n#include \"i915_trace.h\"\n\nvoid i915_gem_object_init_memory_region(struct drm_i915_gem_object *obj,\n\t\t\t\t\tstruct intel_memory_region *mem)\n{\n\tobj->mm.region = mem;\n\n\tmutex_lock(&mem->objects.lock);\n\tlist_add(&obj->mm.region_link, &mem->objects.list);\n\tmutex_unlock(&mem->objects.lock);\n}\n\nvoid i915_gem_object_release_memory_region(struct drm_i915_gem_object *obj)\n{\n\tstruct intel_memory_region *mem = obj->mm.region;\n\n\tmutex_lock(&mem->objects.lock);\n\tlist_del(&obj->mm.region_link);\n\tmutex_unlock(&mem->objects.lock);\n}\n\nstatic struct drm_i915_gem_object *\n__i915_gem_object_create_region(struct intel_memory_region *mem,\n\t\t\t\tresource_size_t offset,\n\t\t\t\tresource_size_t size,\n\t\t\t\tresource_size_t page_size,\n\t\t\t\tunsigned int flags)\n{\n\tstruct drm_i915_gem_object *obj;\n\tresource_size_t default_page_size;\n\tint err;\n\n\t \n\n\tGEM_BUG_ON(flags & ~I915_BO_ALLOC_FLAGS);\n\n\tif (WARN_ON_ONCE(flags & I915_BO_ALLOC_GPU_ONLY &&\n\t\t\t (flags & I915_BO_ALLOC_CPU_CLEAR ||\n\t\t\t  flags & I915_BO_ALLOC_PM_EARLY)))\n\t\treturn ERR_PTR(-EINVAL);\n\n\tif (!mem)\n\t\treturn ERR_PTR(-ENODEV);\n\n\tdefault_page_size = mem->min_page_size;\n\tif (page_size)\n\t\tdefault_page_size = page_size;\n\n\t \n\tGEM_BUG_ON(overflows_type(default_page_size, u32));\n\tGEM_BUG_ON(!is_power_of_2_u64(default_page_size));\n\tGEM_BUG_ON(default_page_size < PAGE_SIZE);\n\n\tsize = round_up(size, default_page_size);\n\n\tif (default_page_size == size)\n\t\tflags |= I915_BO_ALLOC_CONTIGUOUS;\n\n\tGEM_BUG_ON(!size);\n\tGEM_BUG_ON(!IS_ALIGNED(size, I915_GTT_MIN_ALIGNMENT));\n\n\tif (i915_gem_object_size_2big(size))\n\t\treturn ERR_PTR(-E2BIG);\n\n\tobj = i915_gem_object_alloc();\n\tif (!obj)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\t \n\tif (default_page_size < mem->min_page_size)\n\t\tflags |= I915_BO_ALLOC_PM_EARLY;\n\n\terr = mem->ops->init_object(mem, obj, offset, size, page_size, flags);\n\tif (err)\n\t\tgoto err_object_free;\n\n\ttrace_i915_gem_object_create(obj);\n\treturn obj;\n\nerr_object_free:\n\ti915_gem_object_free(obj);\n\treturn ERR_PTR(err);\n}\n\nstruct drm_i915_gem_object *\ni915_gem_object_create_region(struct intel_memory_region *mem,\n\t\t\t      resource_size_t size,\n\t\t\t      resource_size_t page_size,\n\t\t\t      unsigned int flags)\n{\n\treturn __i915_gem_object_create_region(mem, I915_BO_INVALID_OFFSET,\n\t\t\t\t\t       size, page_size, flags);\n}\n\nstruct drm_i915_gem_object *\ni915_gem_object_create_region_at(struct intel_memory_region *mem,\n\t\t\t\t resource_size_t offset,\n\t\t\t\t resource_size_t size,\n\t\t\t\t unsigned int flags)\n{\n\tGEM_BUG_ON(offset == I915_BO_INVALID_OFFSET);\n\n\tif (GEM_WARN_ON(!IS_ALIGNED(size, mem->min_page_size)) ||\n\t    GEM_WARN_ON(!IS_ALIGNED(offset, mem->min_page_size)))\n\t\treturn ERR_PTR(-EINVAL);\n\n\tif (range_overflows(offset, size, resource_size(&mem->region)))\n\t\treturn ERR_PTR(-EINVAL);\n\n\tif (!(flags & I915_BO_ALLOC_GPU_ONLY) &&\n\t    offset + size > mem->io_size &&\n\t    !i915_ggtt_has_aperture(to_gt(mem->i915)->ggtt))\n\t\treturn ERR_PTR(-ENOSPC);\n\n\treturn __i915_gem_object_create_region(mem, offset, size, 0,\n\t\t\t\t\t       flags | I915_BO_ALLOC_CONTIGUOUS);\n}\n\n \nint i915_gem_process_region(struct intel_memory_region *mr,\n\t\t\t    struct i915_gem_apply_to_region *apply)\n{\n\tconst struct i915_gem_apply_to_region_ops *ops = apply->ops;\n\tstruct drm_i915_gem_object *obj;\n\tstruct list_head still_in_list;\n\tint ret = 0;\n\n\t \n\tGEM_WARN_ON(apply->ww);\n\n\tINIT_LIST_HEAD(&still_in_list);\n\tmutex_lock(&mr->objects.lock);\n\tfor (;;) {\n\t\tstruct i915_gem_ww_ctx ww;\n\n\t\tobj = list_first_entry_or_null(&mr->objects.list, typeof(*obj),\n\t\t\t\t\t       mm.region_link);\n\t\tif (!obj)\n\t\t\tbreak;\n\n\t\tlist_move_tail(&obj->mm.region_link, &still_in_list);\n\t\tif (!kref_get_unless_zero(&obj->base.refcount))\n\t\t\tcontinue;\n\n\t\t \n\t\tmutex_unlock(&mr->objects.lock);\n\t\tapply->ww = &ww;\n\t\tfor_i915_gem_ww(&ww, ret, apply->interruptible) {\n\t\t\tret = i915_gem_object_lock(obj, apply->ww);\n\t\t\tif (ret)\n\t\t\t\tcontinue;\n\n\t\t\tif (obj->mm.region == mr)\n\t\t\t\tret = ops->process_obj(apply, obj);\n\t\t\t \n\t\t}\n\n\t\ti915_gem_object_put(obj);\n\t\tmutex_lock(&mr->objects.lock);\n\t\tif (ret)\n\t\t\tbreak;\n\t}\n\tlist_splice_tail(&still_in_list, &mr->objects.list);\n\tmutex_unlock(&mr->objects.lock);\n\n\treturn ret;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}