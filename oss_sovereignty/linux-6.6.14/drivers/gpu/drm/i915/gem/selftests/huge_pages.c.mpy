{
  "module_name": "huge_pages.c",
  "hash_id": "1f7539c8c9b31933432452109c95c1797447fd827781268043bacfec7cf7d73c",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/i915/gem/selftests/huge_pages.c",
  "human_readable_source": " \n\n#include <linux/prime_numbers.h>\n#include <linux/string_helpers.h>\n#include <linux/swap.h>\n\n#include \"i915_selftest.h\"\n\n#include \"gem/i915_gem_internal.h\"\n#include \"gem/i915_gem_lmem.h\"\n#include \"gem/i915_gem_pm.h\"\n#include \"gem/i915_gem_region.h\"\n\n#include \"gt/intel_gt.h\"\n\n#include \"igt_gem_utils.h\"\n#include \"mock_context.h\"\n\n#include \"selftests/mock_drm.h\"\n#include \"selftests/mock_gem_device.h\"\n#include \"selftests/mock_region.h\"\n#include \"selftests/i915_random.h\"\n\nstatic struct i915_gem_context *hugepage_ctx(struct drm_i915_private *i915,\n\t\t\t\t\t     struct file *file)\n{\n\tstruct i915_gem_context *ctx = live_context(i915, file);\n\tstruct i915_address_space *vm;\n\n\tif (IS_ERR(ctx))\n\t\treturn ctx;\n\n\tvm = ctx->vm;\n\tif (vm)\n\t\tWRITE_ONCE(vm->scrub_64K, true);\n\n\treturn ctx;\n}\n\nstatic const unsigned int page_sizes[] = {\n\tI915_GTT_PAGE_SIZE_2M,\n\tI915_GTT_PAGE_SIZE_64K,\n\tI915_GTT_PAGE_SIZE_4K,\n};\n\nstatic unsigned int get_largest_page_size(struct drm_i915_private *i915,\n\t\t\t\t\t  u64 rem)\n{\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(page_sizes); ++i) {\n\t\tunsigned int page_size = page_sizes[i];\n\n\t\tif (HAS_PAGE_SIZES(i915, page_size) && rem >= page_size)\n\t\t\treturn page_size;\n\t}\n\n\treturn 0;\n}\n\nstatic void huge_pages_free_pages(struct sg_table *st)\n{\n\tstruct scatterlist *sg;\n\n\tfor (sg = st->sgl; sg; sg = __sg_next(sg)) {\n\t\tif (sg_page(sg))\n\t\t\t__free_pages(sg_page(sg), get_order(sg->length));\n\t}\n\n\tsg_free_table(st);\n\tkfree(st);\n}\n\nstatic int get_huge_pages(struct drm_i915_gem_object *obj)\n{\n#define GFP (GFP_KERNEL | __GFP_NOWARN | __GFP_NORETRY)\n\tunsigned int page_mask = obj->mm.page_mask;\n\tstruct sg_table *st;\n\tstruct scatterlist *sg;\n\tunsigned int sg_page_sizes;\n\tu64 rem;\n\n\t \n\tif (overflows_type(obj->base.size >> PAGE_SHIFT, unsigned int))\n\t\treturn -E2BIG;\n\n\tst = kmalloc(sizeof(*st), GFP);\n\tif (!st)\n\t\treturn -ENOMEM;\n\n\tif (sg_alloc_table(st, obj->base.size >> PAGE_SHIFT, GFP)) {\n\t\tkfree(st);\n\t\treturn -ENOMEM;\n\t}\n\n\trem = obj->base.size;\n\tsg = st->sgl;\n\tst->nents = 0;\n\tsg_page_sizes = 0;\n\n\t \n\tdo {\n\t\tunsigned int bit = ilog2(page_mask);\n\t\tunsigned int page_size = BIT(bit);\n\t\tint order = get_order(page_size);\n\n\t\tdo {\n\t\t\tstruct page *page;\n\n\t\t\tGEM_BUG_ON(order > MAX_ORDER);\n\t\t\tpage = alloc_pages(GFP | __GFP_ZERO, order);\n\t\t\tif (!page)\n\t\t\t\tgoto err;\n\n\t\t\tsg_set_page(sg, page, page_size, 0);\n\t\t\tsg_page_sizes |= page_size;\n\t\t\tst->nents++;\n\n\t\t\trem -= page_size;\n\t\t\tif (!rem) {\n\t\t\t\tsg_mark_end(sg);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tsg = __sg_next(sg);\n\t\t} while ((rem - ((page_size-1) & page_mask)) >= page_size);\n\n\t\tpage_mask &= (page_size-1);\n\t} while (page_mask);\n\n\tif (i915_gem_gtt_prepare_pages(obj, st))\n\t\tgoto err;\n\n\tGEM_BUG_ON(sg_page_sizes != obj->mm.page_mask);\n\t__i915_gem_object_set_pages(obj, st);\n\n\treturn 0;\n\nerr:\n\tsg_set_page(sg, NULL, 0, 0);\n\tsg_mark_end(sg);\n\thuge_pages_free_pages(st);\n\n\treturn -ENOMEM;\n}\n\nstatic void put_huge_pages(struct drm_i915_gem_object *obj,\n\t\t\t   struct sg_table *pages)\n{\n\ti915_gem_gtt_finish_pages(obj, pages);\n\thuge_pages_free_pages(pages);\n\n\tobj->mm.dirty = false;\n\n\t__start_cpu_write(obj);\n}\n\nstatic const struct drm_i915_gem_object_ops huge_page_ops = {\n\t.name = \"huge-gem\",\n\t.flags = I915_GEM_OBJECT_IS_SHRINKABLE,\n\t.get_pages = get_huge_pages,\n\t.put_pages = put_huge_pages,\n};\n\nstatic struct drm_i915_gem_object *\nhuge_pages_object(struct drm_i915_private *i915,\n\t\t  u64 size,\n\t\t  unsigned int page_mask)\n{\n\tstatic struct lock_class_key lock_class;\n\tstruct drm_i915_gem_object *obj;\n\tunsigned int cache_level;\n\n\tGEM_BUG_ON(!size);\n\tGEM_BUG_ON(!IS_ALIGNED(size, BIT(__ffs(page_mask))));\n\n\tif (size >> PAGE_SHIFT > INT_MAX)\n\t\treturn ERR_PTR(-E2BIG);\n\n\tif (overflows_type(size, obj->base.size))\n\t\treturn ERR_PTR(-E2BIG);\n\n\tobj = i915_gem_object_alloc();\n\tif (!obj)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tdrm_gem_private_object_init(&i915->drm, &obj->base, size);\n\ti915_gem_object_init(obj, &huge_page_ops, &lock_class, 0);\n\tobj->mem_flags |= I915_BO_FLAG_STRUCT_PAGE;\n\ti915_gem_object_set_volatile(obj);\n\n\tobj->write_domain = I915_GEM_DOMAIN_CPU;\n\tobj->read_domains = I915_GEM_DOMAIN_CPU;\n\n\tcache_level = HAS_LLC(i915) ? I915_CACHE_LLC : I915_CACHE_NONE;\n\ti915_gem_object_set_cache_coherency(obj, cache_level);\n\n\tobj->mm.page_mask = page_mask;\n\n\treturn obj;\n}\n\nstatic int fake_get_huge_pages(struct drm_i915_gem_object *obj)\n{\n\tstruct drm_i915_private *i915 = to_i915(obj->base.dev);\n\tconst u64 max_len = rounddown_pow_of_two(UINT_MAX);\n\tstruct sg_table *st;\n\tstruct scatterlist *sg;\n\tu64 rem;\n\n\t \n\tif (overflows_type(obj->base.size >> PAGE_SHIFT, unsigned int))\n\t\treturn -E2BIG;\n\n\tst = kmalloc(sizeof(*st), GFP);\n\tif (!st)\n\t\treturn -ENOMEM;\n\n\tif (sg_alloc_table(st, obj->base.size >> PAGE_SHIFT, GFP)) {\n\t\tkfree(st);\n\t\treturn -ENOMEM;\n\t}\n\n\t \n\trem = obj->base.size;\n\tsg = st->sgl;\n\tst->nents = 0;\n\tdo {\n\t\tunsigned int page_size = get_largest_page_size(i915, rem);\n\t\tunsigned int len = min(page_size * div_u64(rem, page_size),\n\t\t\t\t       max_len);\n\n\t\tGEM_BUG_ON(!page_size);\n\n\t\tsg->offset = 0;\n\t\tsg->length = len;\n\t\tsg_dma_len(sg) = len;\n\t\tsg_dma_address(sg) = page_size;\n\n\t\tst->nents++;\n\n\t\trem -= len;\n\t\tif (!rem) {\n\t\t\tsg_mark_end(sg);\n\t\t\tbreak;\n\t\t}\n\n\t\tsg = sg_next(sg);\n\t} while (1);\n\n\ti915_sg_trim(st);\n\n\t__i915_gem_object_set_pages(obj, st);\n\n\treturn 0;\n}\n\nstatic int fake_get_huge_pages_single(struct drm_i915_gem_object *obj)\n{\n\tstruct drm_i915_private *i915 = to_i915(obj->base.dev);\n\tstruct sg_table *st;\n\tstruct scatterlist *sg;\n\tunsigned int page_size;\n\n\tst = kmalloc(sizeof(*st), GFP);\n\tif (!st)\n\t\treturn -ENOMEM;\n\n\tif (sg_alloc_table(st, 1, GFP)) {\n\t\tkfree(st);\n\t\treturn -ENOMEM;\n\t}\n\n\tsg = st->sgl;\n\tst->nents = 1;\n\n\tpage_size = get_largest_page_size(i915, obj->base.size);\n\tGEM_BUG_ON(!page_size);\n\n\tsg->offset = 0;\n\tsg->length = obj->base.size;\n\tsg_dma_len(sg) = obj->base.size;\n\tsg_dma_address(sg) = page_size;\n\n\t__i915_gem_object_set_pages(obj, st);\n\n\treturn 0;\n#undef GFP\n}\n\nstatic void fake_free_huge_pages(struct drm_i915_gem_object *obj,\n\t\t\t\t struct sg_table *pages)\n{\n\tsg_free_table(pages);\n\tkfree(pages);\n}\n\nstatic void fake_put_huge_pages(struct drm_i915_gem_object *obj,\n\t\t\t\tstruct sg_table *pages)\n{\n\tfake_free_huge_pages(obj, pages);\n\tobj->mm.dirty = false;\n}\n\nstatic const struct drm_i915_gem_object_ops fake_ops = {\n\t.name = \"fake-gem\",\n\t.flags = I915_GEM_OBJECT_IS_SHRINKABLE,\n\t.get_pages = fake_get_huge_pages,\n\t.put_pages = fake_put_huge_pages,\n};\n\nstatic const struct drm_i915_gem_object_ops fake_ops_single = {\n\t.name = \"fake-gem\",\n\t.flags = I915_GEM_OBJECT_IS_SHRINKABLE,\n\t.get_pages = fake_get_huge_pages_single,\n\t.put_pages = fake_put_huge_pages,\n};\n\nstatic struct drm_i915_gem_object *\nfake_huge_pages_object(struct drm_i915_private *i915, u64 size, bool single)\n{\n\tstatic struct lock_class_key lock_class;\n\tstruct drm_i915_gem_object *obj;\n\n\tGEM_BUG_ON(!size);\n\tGEM_BUG_ON(!IS_ALIGNED(size, I915_GTT_PAGE_SIZE));\n\n\tif (size >> PAGE_SHIFT > UINT_MAX)\n\t\treturn ERR_PTR(-E2BIG);\n\n\tif (overflows_type(size, obj->base.size))\n\t\treturn ERR_PTR(-E2BIG);\n\n\tobj = i915_gem_object_alloc();\n\tif (!obj)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tdrm_gem_private_object_init(&i915->drm, &obj->base, size);\n\n\tif (single)\n\t\ti915_gem_object_init(obj, &fake_ops_single, &lock_class, 0);\n\telse\n\t\ti915_gem_object_init(obj, &fake_ops, &lock_class, 0);\n\n\ti915_gem_object_set_volatile(obj);\n\n\tobj->write_domain = I915_GEM_DOMAIN_CPU;\n\tobj->read_domains = I915_GEM_DOMAIN_CPU;\n\tobj->pat_index = i915_gem_get_pat_index(i915, I915_CACHE_NONE);\n\n\treturn obj;\n}\n\nstatic int igt_check_page_sizes(struct i915_vma *vma)\n{\n\tstruct drm_i915_private *i915 = vma->vm->i915;\n\tunsigned int supported = RUNTIME_INFO(i915)->page_sizes;\n\tstruct drm_i915_gem_object *obj = vma->obj;\n\tint err;\n\n\t \n\terr = i915_vma_sync(vma);\n\tif (err)\n\t\treturn err;\n\n\tif (!HAS_PAGE_SIZES(i915, vma->page_sizes.sg)) {\n\t\tpr_err(\"unsupported page_sizes.sg=%u, supported=%u\\n\",\n\t\t       vma->page_sizes.sg & ~supported, supported);\n\t\terr = -EINVAL;\n\t}\n\n\tif (!HAS_PAGE_SIZES(i915, vma->resource->page_sizes_gtt)) {\n\t\tpr_err(\"unsupported page_sizes.gtt=%u, supported=%u\\n\",\n\t\t       vma->resource->page_sizes_gtt & ~supported, supported);\n\t\terr = -EINVAL;\n\t}\n\n\tif (vma->page_sizes.phys != obj->mm.page_sizes.phys) {\n\t\tpr_err(\"vma->page_sizes.phys(%u) != obj->mm.page_sizes.phys(%u)\\n\",\n\t\t       vma->page_sizes.phys, obj->mm.page_sizes.phys);\n\t\terr = -EINVAL;\n\t}\n\n\tif (vma->page_sizes.sg != obj->mm.page_sizes.sg) {\n\t\tpr_err(\"vma->page_sizes.sg(%u) != obj->mm.page_sizes.sg(%u)\\n\",\n\t\t       vma->page_sizes.sg, obj->mm.page_sizes.sg);\n\t\terr = -EINVAL;\n\t}\n\n\t \n\tif (i915_gem_object_is_lmem(obj) &&\n\t    IS_ALIGNED(i915_vma_offset(vma), SZ_2M) &&\n\t    vma->page_sizes.sg & SZ_2M &&\n\t    vma->resource->page_sizes_gtt < SZ_2M) {\n\t\tpr_err(\"gtt pages mismatch for LMEM, expected 2M GTT pages, sg(%u), gtt(%u)\\n\",\n\t\t       vma->page_sizes.sg, vma->resource->page_sizes_gtt);\n\t\terr = -EINVAL;\n\t}\n\n\treturn err;\n}\n\nstatic int igt_mock_exhaust_device_supported_pages(void *arg)\n{\n\tstruct i915_ppgtt *ppgtt = arg;\n\tstruct drm_i915_private *i915 = ppgtt->vm.i915;\n\tunsigned int saved_mask = RUNTIME_INFO(i915)->page_sizes;\n\tstruct drm_i915_gem_object *obj;\n\tstruct i915_vma *vma;\n\tint i, j, single;\n\tint err;\n\n\t \n\n\tfor (i = 1; i < BIT(ARRAY_SIZE(page_sizes)); i++) {\n\t\tunsigned int combination = SZ_4K;  \n\n\t\tfor (j = 0; j < ARRAY_SIZE(page_sizes); j++) {\n\t\t\tif (i & BIT(j))\n\t\t\t\tcombination |= page_sizes[j];\n\t\t}\n\n\t\tRUNTIME_INFO(i915)->page_sizes = combination;\n\n\t\tfor (single = 0; single <= 1; ++single) {\n\t\t\tobj = fake_huge_pages_object(i915, combination, !!single);\n\t\t\tif (IS_ERR(obj)) {\n\t\t\t\terr = PTR_ERR(obj);\n\t\t\t\tgoto out_device;\n\t\t\t}\n\n\t\t\tif (obj->base.size != combination) {\n\t\t\t\tpr_err(\"obj->base.size=%zu, expected=%u\\n\",\n\t\t\t\t       obj->base.size, combination);\n\t\t\t\terr = -EINVAL;\n\t\t\t\tgoto out_put;\n\t\t\t}\n\n\t\t\tvma = i915_vma_instance(obj, &ppgtt->vm, NULL);\n\t\t\tif (IS_ERR(vma)) {\n\t\t\t\terr = PTR_ERR(vma);\n\t\t\t\tgoto out_put;\n\t\t\t}\n\n\t\t\terr = i915_vma_pin(vma, 0, 0, PIN_USER);\n\t\t\tif (err)\n\t\t\t\tgoto out_put;\n\n\t\t\terr = igt_check_page_sizes(vma);\n\n\t\t\tif (vma->page_sizes.sg != combination) {\n\t\t\t\tpr_err(\"page_sizes.sg=%u, expected=%u\\n\",\n\t\t\t\t       vma->page_sizes.sg, combination);\n\t\t\t\terr = -EINVAL;\n\t\t\t}\n\n\t\t\ti915_vma_unpin(vma);\n\t\t\ti915_gem_object_put(obj);\n\n\t\t\tif (err)\n\t\t\t\tgoto out_device;\n\t\t}\n\t}\n\n\tgoto out_device;\n\nout_put:\n\ti915_gem_object_put(obj);\nout_device:\n\tRUNTIME_INFO(i915)->page_sizes = saved_mask;\n\n\treturn err;\n}\n\nstatic int igt_mock_memory_region_huge_pages(void *arg)\n{\n\tconst unsigned int flags[] = { 0, I915_BO_ALLOC_CONTIGUOUS };\n\tstruct i915_ppgtt *ppgtt = arg;\n\tstruct drm_i915_private *i915 = ppgtt->vm.i915;\n\tunsigned long supported = RUNTIME_INFO(i915)->page_sizes;\n\tstruct intel_memory_region *mem;\n\tstruct drm_i915_gem_object *obj;\n\tstruct i915_vma *vma;\n\tint bit;\n\tint err = 0;\n\n\tmem = mock_region_create(i915, 0, SZ_2G, I915_GTT_PAGE_SIZE_4K, 0, 0);\n\tif (IS_ERR(mem)) {\n\t\tpr_err(\"%s failed to create memory region\\n\", __func__);\n\t\treturn PTR_ERR(mem);\n\t}\n\n\tfor_each_set_bit(bit, &supported, ilog2(I915_GTT_MAX_PAGE_SIZE) + 1) {\n\t\tunsigned int page_size = BIT(bit);\n\t\tresource_size_t phys;\n\t\tint i;\n\n\t\tfor (i = 0; i < ARRAY_SIZE(flags); ++i) {\n\t\t\tobj = i915_gem_object_create_region(mem,\n\t\t\t\t\t\t\t    page_size, page_size,\n\t\t\t\t\t\t\t    flags[i]);\n\t\t\tif (IS_ERR(obj)) {\n\t\t\t\terr = PTR_ERR(obj);\n\t\t\t\tgoto out_region;\n\t\t\t}\n\n\t\t\tvma = i915_vma_instance(obj, &ppgtt->vm, NULL);\n\t\t\tif (IS_ERR(vma)) {\n\t\t\t\terr = PTR_ERR(vma);\n\t\t\t\tgoto out_put;\n\t\t\t}\n\n\t\t\terr = i915_vma_pin(vma, 0, 0, PIN_USER);\n\t\t\tif (err)\n\t\t\t\tgoto out_put;\n\n\t\t\terr = igt_check_page_sizes(vma);\n\t\t\tif (err)\n\t\t\t\tgoto out_unpin;\n\n\t\t\tphys = i915_gem_object_get_dma_address(obj, 0);\n\t\t\tif (!IS_ALIGNED(phys, page_size)) {\n\t\t\t\tpr_err(\"%s addr misaligned(%pa) page_size=%u\\n\",\n\t\t\t\t       __func__, &phys, page_size);\n\t\t\t\terr = -EINVAL;\n\t\t\t\tgoto out_unpin;\n\t\t\t}\n\n\t\t\tif (vma->resource->page_sizes_gtt != page_size) {\n\t\t\t\tpr_err(\"%s page_sizes.gtt=%u, expected=%u\\n\",\n\t\t\t\t       __func__, vma->resource->page_sizes_gtt,\n\t\t\t\t       page_size);\n\t\t\t\terr = -EINVAL;\n\t\t\t\tgoto out_unpin;\n\t\t\t}\n\n\t\t\ti915_vma_unpin(vma);\n\t\t\t__i915_gem_object_put_pages(obj);\n\t\t\ti915_gem_object_put(obj);\n\t\t}\n\t}\n\n\tgoto out_region;\n\nout_unpin:\n\ti915_vma_unpin(vma);\nout_put:\n\ti915_gem_object_put(obj);\nout_region:\n\tintel_memory_region_destroy(mem);\n\treturn err;\n}\n\nstatic int igt_mock_ppgtt_misaligned_dma(void *arg)\n{\n\tstruct i915_ppgtt *ppgtt = arg;\n\tstruct drm_i915_private *i915 = ppgtt->vm.i915;\n\tunsigned long supported = RUNTIME_INFO(i915)->page_sizes;\n\tstruct drm_i915_gem_object *obj;\n\tint bit;\n\tint err;\n\n\t \n\n\tbit = ilog2(I915_GTT_PAGE_SIZE_64K);\n\n\tfor_each_set_bit_from(bit, &supported,\n\t\t\t      ilog2(I915_GTT_MAX_PAGE_SIZE) + 1) {\n\t\tIGT_TIMEOUT(end_time);\n\t\tunsigned int page_size = BIT(bit);\n\t\tunsigned int flags = PIN_USER | PIN_OFFSET_FIXED;\n\t\tunsigned int offset;\n\t\tunsigned int size =\n\t\t\tround_up(page_size, I915_GTT_PAGE_SIZE_2M) << 1;\n\t\tstruct i915_vma *vma;\n\n\t\tobj = fake_huge_pages_object(i915, size, true);\n\t\tif (IS_ERR(obj))\n\t\t\treturn PTR_ERR(obj);\n\n\t\tif (obj->base.size != size) {\n\t\t\tpr_err(\"obj->base.size=%zu, expected=%u\\n\",\n\t\t\t       obj->base.size, size);\n\t\t\terr = -EINVAL;\n\t\t\tgoto out_put;\n\t\t}\n\n\t\terr = i915_gem_object_pin_pages_unlocked(obj);\n\t\tif (err)\n\t\t\tgoto out_put;\n\n\t\t \n\t\tobj->mm.page_sizes.sg = page_size;\n\n\t\tvma = i915_vma_instance(obj, &ppgtt->vm, NULL);\n\t\tif (IS_ERR(vma)) {\n\t\t\terr = PTR_ERR(vma);\n\t\t\tgoto out_unpin;\n\t\t}\n\n\t\terr = i915_vma_pin(vma, 0, 0, flags);\n\t\tif (err)\n\t\t\tgoto out_unpin;\n\n\n\t\terr = igt_check_page_sizes(vma);\n\n\t\tif (vma->resource->page_sizes_gtt != page_size) {\n\t\t\tpr_err(\"page_sizes.gtt=%u, expected %u\\n\",\n\t\t\t       vma->resource->page_sizes_gtt, page_size);\n\t\t\terr = -EINVAL;\n\t\t}\n\n\t\ti915_vma_unpin(vma);\n\n\t\tif (err)\n\t\t\tgoto out_unpin;\n\n\t\t \n\t\tfor (offset = 4096; offset < page_size; offset += 4096) {\n\t\t\terr = i915_vma_unbind_unlocked(vma);\n\t\t\tif (err)\n\t\t\t\tgoto out_unpin;\n\n\t\t\terr = i915_vma_pin(vma, 0, 0, flags | offset);\n\t\t\tif (err)\n\t\t\t\tgoto out_unpin;\n\n\t\t\terr = igt_check_page_sizes(vma);\n\n\t\t\tif (vma->resource->page_sizes_gtt != I915_GTT_PAGE_SIZE_4K) {\n\t\t\t\tpr_err(\"page_sizes.gtt=%u, expected %llu\\n\",\n\t\t\t\t       vma->resource->page_sizes_gtt,\n\t\t\t\t       I915_GTT_PAGE_SIZE_4K);\n\t\t\t\terr = -EINVAL;\n\t\t\t}\n\n\t\t\ti915_vma_unpin(vma);\n\n\t\t\tif (err)\n\t\t\t\tgoto out_unpin;\n\n\t\t\tif (igt_timeout(end_time,\n\t\t\t\t\t\"%s timed out at offset %x with page-size %x\\n\",\n\t\t\t\t\t__func__, offset, page_size))\n\t\t\t\tbreak;\n\t\t}\n\n\t\ti915_gem_object_lock(obj, NULL);\n\t\ti915_gem_object_unpin_pages(obj);\n\t\t__i915_gem_object_put_pages(obj);\n\t\ti915_gem_object_unlock(obj);\n\t\ti915_gem_object_put(obj);\n\t}\n\n\treturn 0;\n\nout_unpin:\n\ti915_gem_object_lock(obj, NULL);\n\ti915_gem_object_unpin_pages(obj);\n\ti915_gem_object_unlock(obj);\nout_put:\n\ti915_gem_object_put(obj);\n\n\treturn err;\n}\n\nstatic void close_object_list(struct list_head *objects)\n{\n\tstruct drm_i915_gem_object *obj, *on;\n\n\tlist_for_each_entry_safe(obj, on, objects, st_link) {\n\t\tlist_del(&obj->st_link);\n\t\ti915_gem_object_lock(obj, NULL);\n\t\ti915_gem_object_unpin_pages(obj);\n\t\t__i915_gem_object_put_pages(obj);\n\t\ti915_gem_object_unlock(obj);\n\t\ti915_gem_object_put(obj);\n\t}\n}\n\nstatic int igt_ppgtt_huge_fill(void *arg)\n{\n\tstruct drm_i915_private *i915 = arg;\n\tunsigned int supported = RUNTIME_INFO(i915)->page_sizes;\n\tbool has_pte64 = GRAPHICS_VER_FULL(i915) >= IP_VER(12, 50);\n\tstruct i915_address_space *vm;\n\tstruct i915_gem_context *ctx;\n\tunsigned long max_pages;\n\tunsigned long page_num;\n\tstruct file *file;\n\tbool single = false;\n\tLIST_HEAD(objects);\n\tIGT_TIMEOUT(end_time);\n\tint err = -ENODEV;\n\n\tif (supported == I915_GTT_PAGE_SIZE_4K)\n\t\treturn 0;\n\n\tfile = mock_file(i915);\n\tif (IS_ERR(file))\n\t\treturn PTR_ERR(file);\n\n\tctx = hugepage_ctx(i915, file);\n\tif (IS_ERR(ctx)) {\n\t\terr = PTR_ERR(ctx);\n\t\tgoto out;\n\t}\n\tvm = i915_gem_context_get_eb_vm(ctx);\n\tmax_pages = vm->total >> PAGE_SHIFT;\n\n\tfor_each_prime_number_from(page_num, 1, max_pages) {\n\t\tstruct drm_i915_gem_object *obj;\n\t\tu64 size = page_num << PAGE_SHIFT;\n\t\tstruct i915_vma *vma;\n\t\tunsigned int expected_gtt = 0;\n\t\tint i;\n\n\t\tobj = fake_huge_pages_object(i915, size, single);\n\t\tif (IS_ERR(obj)) {\n\t\t\terr = PTR_ERR(obj);\n\t\t\tbreak;\n\t\t}\n\n\t\tif (obj->base.size != size) {\n\t\t\tpr_err(\"obj->base.size=%zd, expected=%llu\\n\",\n\t\t\t       obj->base.size, size);\n\t\t\ti915_gem_object_put(obj);\n\t\t\terr = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\terr = i915_gem_object_pin_pages_unlocked(obj);\n\t\tif (err) {\n\t\t\ti915_gem_object_put(obj);\n\t\t\tbreak;\n\t\t}\n\n\t\tlist_add(&obj->st_link, &objects);\n\n\t\tvma = i915_vma_instance(obj, vm, NULL);\n\t\tif (IS_ERR(vma)) {\n\t\t\terr = PTR_ERR(vma);\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\terr = i915_vma_pin(vma, 0, BIT(21), PIN_USER);\n\t\tif (err)\n\t\t\tbreak;\n\n\t\terr = igt_check_page_sizes(vma);\n\t\tif (err) {\n\t\t\ti915_vma_unpin(vma);\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\tfor (i = 0; i < ARRAY_SIZE(page_sizes); ++i) {\n\t\t\tunsigned int page_size = page_sizes[i];\n\n\t\t\tif (HAS_PAGE_SIZES(i915, page_size) &&\n\t\t\t    size >= page_size) {\n\t\t\t\texpected_gtt |= page_size;\n\t\t\t\tsize &= page_size-1;\n\t\t\t}\n\t\t}\n\n\t\tGEM_BUG_ON(!expected_gtt);\n\t\tGEM_BUG_ON(size);\n\n\t\tif (!has_pte64 && (obj->base.size < I915_GTT_PAGE_SIZE_2M ||\n\t\t\t\t   expected_gtt & I915_GTT_PAGE_SIZE_2M))\n\t\t\texpected_gtt &= ~I915_GTT_PAGE_SIZE_64K;\n\n\t\ti915_vma_unpin(vma);\n\n\t\tif (!has_pte64 && vma->page_sizes.sg & I915_GTT_PAGE_SIZE_64K) {\n\t\t\tif (!IS_ALIGNED(vma->node.start,\n\t\t\t\t\tI915_GTT_PAGE_SIZE_2M)) {\n\t\t\t\tpr_err(\"node.start(%llx) not aligned to 2M\\n\",\n\t\t\t\t       vma->node.start);\n\t\t\t\terr = -EINVAL;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (!IS_ALIGNED(vma->node.size,\n\t\t\t\t\tI915_GTT_PAGE_SIZE_2M)) {\n\t\t\t\tpr_err(\"node.size(%llx) not aligned to 2M\\n\",\n\t\t\t\t       vma->node.size);\n\t\t\t\terr = -EINVAL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (vma->resource->page_sizes_gtt != expected_gtt) {\n\t\t\tpr_err(\"gtt=%#x, expected=%#x, size=0x%zx, single=%s\\n\",\n\t\t\t       vma->resource->page_sizes_gtt, expected_gtt,\n\t\t\t       obj->base.size, str_yes_no(!!single));\n\t\t\terr = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (igt_timeout(end_time,\n\t\t\t\t\"%s timed out at size %zd\\n\",\n\t\t\t\t__func__, obj->base.size))\n\t\t\tbreak;\n\n\t\tsingle = !single;\n\t}\n\n\tclose_object_list(&objects);\n\n\tif (err == -ENOMEM || err == -ENOSPC)\n\t\terr = 0;\n\n\ti915_vm_put(vm);\nout:\n\tfput(file);\n\treturn err;\n}\n\nstatic int igt_ppgtt_64K(void *arg)\n{\n\tstruct drm_i915_private *i915 = arg;\n\tbool has_pte64 = GRAPHICS_VER_FULL(i915) >= IP_VER(12, 50);\n\tstruct drm_i915_gem_object *obj;\n\tstruct i915_address_space *vm;\n\tstruct i915_gem_context *ctx;\n\tstruct file *file;\n\tconst struct object_info {\n\t\tunsigned int size;\n\t\tunsigned int gtt;\n\t\tunsigned int offset;\n\t} objects[] = {\n\t\t \n\t\t{\n\t\t\t.size = SZ_64K,\n\t\t\t.gtt = I915_GTT_PAGE_SIZE_64K,\n\t\t\t.offset = 0,\n\t\t},\n\t\t{\n\t\t\t.size = SZ_64K + SZ_4K,\n\t\t\t.gtt = I915_GTT_PAGE_SIZE_4K,\n\t\t\t.offset = 0,\n\t\t},\n\t\t{\n\t\t\t.size = SZ_64K - SZ_4K,\n\t\t\t.gtt = I915_GTT_PAGE_SIZE_4K,\n\t\t\t.offset = 0,\n\t\t},\n\t\t{\n\t\t\t.size = SZ_2M,\n\t\t\t.gtt = I915_GTT_PAGE_SIZE_64K,\n\t\t\t.offset = 0,\n\t\t},\n\t\t{\n\t\t\t.size = SZ_2M - SZ_4K,\n\t\t\t.gtt = I915_GTT_PAGE_SIZE_4K,\n\t\t\t.offset = 0,\n\t\t},\n\t\t{\n\t\t\t.size = SZ_2M + SZ_4K,\n\t\t\t.gtt = I915_GTT_PAGE_SIZE_64K | I915_GTT_PAGE_SIZE_4K,\n\t\t\t.offset = 0,\n\t\t},\n\t\t{\n\t\t\t.size = SZ_2M + SZ_64K,\n\t\t\t.gtt = I915_GTT_PAGE_SIZE_64K,\n\t\t\t.offset = 0,\n\t\t},\n\t\t{\n\t\t\t.size = SZ_2M - SZ_64K,\n\t\t\t.gtt = I915_GTT_PAGE_SIZE_64K,\n\t\t\t.offset = 0,\n\t\t},\n\t\t \n\t\t{\n\t\t\t.size = SZ_64K,\n\t\t\t.offset = SZ_2M,\n\t\t\t.gtt = I915_GTT_PAGE_SIZE_4K,\n\t\t},\n\t\t{\n\t\t\t.size = SZ_128K,\n\t\t\t.offset = SZ_2M - SZ_64K,\n\t\t\t.gtt = I915_GTT_PAGE_SIZE_4K,\n\t\t},\n\t};\n\tstruct i915_vma *vma;\n\tint i, single;\n\tint err;\n\n\t \n\n\tif (!HAS_PAGE_SIZES(i915, I915_GTT_PAGE_SIZE_64K))\n\t\treturn 0;\n\n\tfile = mock_file(i915);\n\tif (IS_ERR(file))\n\t\treturn PTR_ERR(file);\n\n\tctx = hugepage_ctx(i915, file);\n\tif (IS_ERR(ctx)) {\n\t\terr = PTR_ERR(ctx);\n\t\tgoto out;\n\t}\n\tvm = i915_gem_context_get_eb_vm(ctx);\n\n\tfor (i = 0; i < ARRAY_SIZE(objects); ++i) {\n\t\tunsigned int size = objects[i].size;\n\t\tunsigned int expected_gtt = objects[i].gtt;\n\t\tunsigned int offset = objects[i].offset;\n\t\tunsigned int flags = PIN_USER;\n\n\t\t \n\t\tif (has_pte64) {\n\t\t\texpected_gtt = 0;\n\t\t\tif (size >= SZ_64K)\n\t\t\t\texpected_gtt |= I915_GTT_PAGE_SIZE_64K;\n\t\t\tif (size & (SZ_64K - 1))\n\t\t\t\texpected_gtt |= I915_GTT_PAGE_SIZE_4K;\n\t\t}\n\n\t\tfor (single = 0; single <= 1; single++) {\n\t\t\tobj = fake_huge_pages_object(i915, size, !!single);\n\t\t\tif (IS_ERR(obj)) {\n\t\t\t\terr = PTR_ERR(obj);\n\t\t\t\tgoto out_vm;\n\t\t\t}\n\n\t\t\terr = i915_gem_object_pin_pages_unlocked(obj);\n\t\t\tif (err)\n\t\t\t\tgoto out_object_put;\n\n\t\t\t \n\t\t\tobj->mm.page_sizes.sg &= ~I915_GTT_PAGE_SIZE_2M;\n\n\t\t\tvma = i915_vma_instance(obj, vm, NULL);\n\t\t\tif (IS_ERR(vma)) {\n\t\t\t\terr = PTR_ERR(vma);\n\t\t\t\tgoto out_object_unpin;\n\t\t\t}\n\n\t\t\tif (offset)\n\t\t\t\tflags |= PIN_OFFSET_FIXED | offset;\n\n\t\t\terr = i915_vma_pin(vma, 0, 0, flags);\n\t\t\tif (err)\n\t\t\t\tgoto out_object_unpin;\n\n\t\t\terr = igt_check_page_sizes(vma);\n\t\t\tif (err)\n\t\t\t\tgoto out_vma_unpin;\n\n\t\t\tif (!has_pte64 && !offset &&\n\t\t\t    vma->page_sizes.sg & I915_GTT_PAGE_SIZE_64K) {\n\t\t\t\tif (!IS_ALIGNED(vma->node.start,\n\t\t\t\t\t\tI915_GTT_PAGE_SIZE_2M)) {\n\t\t\t\t\tpr_err(\"node.start(%llx) not aligned to 2M\\n\",\n\t\t\t\t\t       vma->node.start);\n\t\t\t\t\terr = -EINVAL;\n\t\t\t\t\tgoto out_vma_unpin;\n\t\t\t\t}\n\n\t\t\t\tif (!IS_ALIGNED(vma->node.size,\n\t\t\t\t\t\tI915_GTT_PAGE_SIZE_2M)) {\n\t\t\t\t\tpr_err(\"node.size(%llx) not aligned to 2M\\n\",\n\t\t\t\t\t       vma->node.size);\n\t\t\t\t\terr = -EINVAL;\n\t\t\t\t\tgoto out_vma_unpin;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (vma->resource->page_sizes_gtt != expected_gtt) {\n\t\t\t\tpr_err(\"gtt=%#x, expected=%#x, i=%d, single=%s offset=%#x size=%#x\\n\",\n\t\t\t\t       vma->resource->page_sizes_gtt,\n\t\t\t\t       expected_gtt, i, str_yes_no(!!single),\n\t\t\t\t       offset, size);\n\t\t\t\terr = -EINVAL;\n\t\t\t\tgoto out_vma_unpin;\n\t\t\t}\n\n\t\t\ti915_vma_unpin(vma);\n\t\t\ti915_gem_object_lock(obj, NULL);\n\t\t\ti915_gem_object_unpin_pages(obj);\n\t\t\t__i915_gem_object_put_pages(obj);\n\t\t\ti915_gem_object_unlock(obj);\n\t\t\ti915_gem_object_put(obj);\n\n\t\t\ti915_gem_drain_freed_objects(i915);\n\t\t}\n\t}\n\n\tgoto out_vm;\n\nout_vma_unpin:\n\ti915_vma_unpin(vma);\nout_object_unpin:\n\ti915_gem_object_lock(obj, NULL);\n\ti915_gem_object_unpin_pages(obj);\n\ti915_gem_object_unlock(obj);\nout_object_put:\n\ti915_gem_object_put(obj);\nout_vm:\n\ti915_vm_put(vm);\nout:\n\tfput(file);\n\treturn err;\n}\n\nstatic int gpu_write(struct intel_context *ce,\n\t\t     struct i915_vma *vma,\n\t\t     u32 dw,\n\t\t     u32 val)\n{\n\tint err;\n\n\ti915_gem_object_lock(vma->obj, NULL);\n\terr = i915_gem_object_set_to_gtt_domain(vma->obj, true);\n\ti915_gem_object_unlock(vma->obj);\n\tif (err)\n\t\treturn err;\n\n\treturn igt_gpu_fill_dw(ce, vma, dw * sizeof(u32),\n\t\t\t       vma->size >> PAGE_SHIFT, val);\n}\n\nstatic int\n__cpu_check_shmem(struct drm_i915_gem_object *obj, u32 dword, u32 val)\n{\n\tunsigned int needs_flush;\n\tunsigned long n;\n\tint err;\n\n\ti915_gem_object_lock(obj, NULL);\n\terr = i915_gem_object_prepare_read(obj, &needs_flush);\n\tif (err)\n\t\tgoto err_unlock;\n\n\tfor (n = 0; n < obj->base.size >> PAGE_SHIFT; ++n) {\n\t\tu32 *ptr = kmap_atomic(i915_gem_object_get_page(obj, n));\n\n\t\tif (needs_flush & CLFLUSH_BEFORE)\n\t\t\tdrm_clflush_virt_range(ptr, PAGE_SIZE);\n\n\t\tif (ptr[dword] != val) {\n\t\t\tpr_err(\"n=%lu ptr[%u]=%u, val=%u\\n\",\n\t\t\t       n, dword, ptr[dword], val);\n\t\t\tkunmap_atomic(ptr);\n\t\t\terr = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\tkunmap_atomic(ptr);\n\t}\n\n\ti915_gem_object_finish_access(obj);\nerr_unlock:\n\ti915_gem_object_unlock(obj);\n\n\treturn err;\n}\n\nstatic int __cpu_check_vmap(struct drm_i915_gem_object *obj, u32 dword, u32 val)\n{\n\tunsigned long n = obj->base.size >> PAGE_SHIFT;\n\tu32 *ptr;\n\tint err;\n\n\terr = i915_gem_object_wait(obj, 0, MAX_SCHEDULE_TIMEOUT);\n\tif (err)\n\t\treturn err;\n\n\tptr = i915_gem_object_pin_map_unlocked(obj, I915_MAP_WC);\n\tif (IS_ERR(ptr))\n\t\treturn PTR_ERR(ptr);\n\n\tptr += dword;\n\twhile (n--) {\n\t\tif (*ptr != val) {\n\t\t\tpr_err(\"base[%u]=%08x, val=%08x\\n\",\n\t\t\t       dword, *ptr, val);\n\t\t\terr = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\tptr += PAGE_SIZE / sizeof(*ptr);\n\t}\n\n\ti915_gem_object_unpin_map(obj);\n\treturn err;\n}\n\nstatic int cpu_check(struct drm_i915_gem_object *obj, u32 dword, u32 val)\n{\n\tif (i915_gem_object_has_struct_page(obj))\n\t\treturn __cpu_check_shmem(obj, dword, val);\n\telse\n\t\treturn __cpu_check_vmap(obj, dword, val);\n}\n\nstatic int __igt_write_huge(struct intel_context *ce,\n\t\t\t    struct drm_i915_gem_object *obj,\n\t\t\t    u64 size, u64 offset,\n\t\t\t    u32 dword, u32 val)\n{\n\tunsigned int flags = PIN_USER | PIN_OFFSET_FIXED;\n\tstruct i915_vma *vma;\n\tint err;\n\n\tvma = i915_vma_instance(obj, ce->vm, NULL);\n\tif (IS_ERR(vma))\n\t\treturn PTR_ERR(vma);\n\n\terr = i915_vma_pin(vma, size, 0, flags | offset);\n\tif (err) {\n\t\t \n\t\tif (err == -ENOSPC && i915_is_ggtt(ce->vm))\n\t\t\terr = 0;\n\n\t\treturn err;\n\t}\n\n\terr = igt_check_page_sizes(vma);\n\tif (err)\n\t\tgoto out_vma_unpin;\n\n\terr = gpu_write(ce, vma, dword, val);\n\tif (err) {\n\t\tpr_err(\"gpu-write failed at offset=%llx\\n\", offset);\n\t\tgoto out_vma_unpin;\n\t}\n\n\terr = cpu_check(obj, dword, val);\n\tif (err) {\n\t\tpr_err(\"cpu-check failed at offset=%llx\\n\", offset);\n\t\tgoto out_vma_unpin;\n\t}\n\nout_vma_unpin:\n\ti915_vma_unpin(vma);\n\treturn err;\n}\n\nstatic int igt_write_huge(struct drm_i915_private *i915,\n\t\t\t  struct drm_i915_gem_object *obj)\n{\n\tstruct i915_gem_engines *engines;\n\tstruct i915_gem_engines_iter it;\n\tstruct intel_context *ce;\n\tI915_RND_STATE(prng);\n\tIGT_TIMEOUT(end_time);\n\tunsigned int max_page_size;\n\tunsigned int count;\n\tstruct i915_gem_context *ctx;\n\tstruct file *file;\n\tu64 max;\n\tu64 num;\n\tu64 size;\n\tint *order;\n\tint i, n;\n\tint err = 0;\n\n\tfile = mock_file(i915);\n\tif (IS_ERR(file))\n\t\treturn PTR_ERR(file);\n\n\tctx = hugepage_ctx(i915, file);\n\tif (IS_ERR(ctx)) {\n\t\terr = PTR_ERR(ctx);\n\t\tgoto out;\n\t}\n\n\tGEM_BUG_ON(!i915_gem_object_has_pinned_pages(obj));\n\n\tsize = obj->base.size;\n\tif (obj->mm.page_sizes.sg & I915_GTT_PAGE_SIZE_64K &&\n\t    !HAS_64K_PAGES(i915))\n\t\tsize = round_up(size, I915_GTT_PAGE_SIZE_2M);\n\n\tn = 0;\n\tcount = 0;\n\tmax = U64_MAX;\n\tfor_each_gem_engine(ce, i915_gem_context_lock_engines(ctx), it) {\n\t\tcount++;\n\t\tif (!intel_engine_can_store_dword(ce->engine))\n\t\t\tcontinue;\n\n\t\tmax = min(max, ce->vm->total);\n\t\tn++;\n\t}\n\ti915_gem_context_unlock_engines(ctx);\n\tif (!n)\n\t\tgoto out;\n\n\t \n\torder = i915_random_order(count * count, &prng);\n\tif (!order) {\n\t\terr = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tmax_page_size = rounddown_pow_of_two(obj->mm.page_sizes.sg);\n\tmax = div_u64(max - size, max_page_size);\n\n\t \n\ti = 0;\n\tengines = i915_gem_context_lock_engines(ctx);\n\tfor_each_prime_number_from(num, 0, max) {\n\t\tu64 offset_low = num * max_page_size;\n\t\tu64 offset_high = (max - num) * max_page_size;\n\t\tu32 dword = offset_in_page(num) / 4;\n\t\tstruct intel_context *ce;\n\n\t\tce = engines->engines[order[i] % engines->num_engines];\n\t\ti = (i + 1) % (count * count);\n\t\tif (!ce || !intel_engine_can_store_dword(ce->engine))\n\t\t\tcontinue;\n\n\t\t \n\t\tif (obj->mm.page_sizes.sg & I915_GTT_PAGE_SIZE_64K)\n\t\t\toffset_low = round_down(offset_low,\n\t\t\t\t\t\tI915_GTT_PAGE_SIZE_2M);\n\n\t\terr = __igt_write_huge(ce, obj, size, offset_low,\n\t\t\t\t       dword, num + 1);\n\t\tif (err)\n\t\t\tbreak;\n\n\t\terr = __igt_write_huge(ce, obj, size, offset_high,\n\t\t\t\t       dword, num + 1);\n\t\tif (err)\n\t\t\tbreak;\n\n\t\tif (igt_timeout(end_time,\n\t\t\t\t\"%s timed out on %s, offset_low=%llx offset_high=%llx, max_page_size=%x\\n\",\n\t\t\t\t__func__, ce->engine->name, offset_low, offset_high,\n\t\t\t\tmax_page_size))\n\t\t\tbreak;\n\t}\n\ti915_gem_context_unlock_engines(ctx);\n\n\tkfree(order);\n\nout:\n\tfput(file);\n\treturn err;\n}\n\ntypedef struct drm_i915_gem_object *\n(*igt_create_fn)(struct drm_i915_private *i915, u32 size, u32 flags);\n\nstatic inline bool igt_can_allocate_thp(struct drm_i915_private *i915)\n{\n\treturn i915->mm.gemfs && has_transparent_hugepage();\n}\n\nstatic struct drm_i915_gem_object *\nigt_create_shmem(struct drm_i915_private *i915, u32 size, u32 flags)\n{\n\tif (!igt_can_allocate_thp(i915)) {\n\t\tpr_info(\"%s missing THP support, skipping\\n\", __func__);\n\t\treturn ERR_PTR(-ENODEV);\n\t}\n\n\treturn i915_gem_object_create_shmem(i915, size);\n}\n\nstatic struct drm_i915_gem_object *\nigt_create_internal(struct drm_i915_private *i915, u32 size, u32 flags)\n{\n\treturn i915_gem_object_create_internal(i915, size);\n}\n\nstatic struct drm_i915_gem_object *\nigt_create_system(struct drm_i915_private *i915, u32 size, u32 flags)\n{\n\treturn huge_pages_object(i915, size, size);\n}\n\nstatic struct drm_i915_gem_object *\nigt_create_local(struct drm_i915_private *i915, u32 size, u32 flags)\n{\n\treturn i915_gem_object_create_lmem(i915, size, flags);\n}\n\nstatic u32 igt_random_size(struct rnd_state *prng,\n\t\t\t   u32 min_page_size,\n\t\t\t   u32 max_page_size)\n{\n\tu64 mask;\n\tu32 size;\n\n\tGEM_BUG_ON(!is_power_of_2(min_page_size));\n\tGEM_BUG_ON(!is_power_of_2(max_page_size));\n\tGEM_BUG_ON(min_page_size < PAGE_SIZE);\n\tGEM_BUG_ON(min_page_size > max_page_size);\n\n\tmask = ((max_page_size << 1ULL) - 1) & PAGE_MASK;\n\tsize = prandom_u32_state(prng) & mask;\n\tif (size < min_page_size)\n\t\tsize |= min_page_size;\n\n\treturn size;\n}\n\nstatic int igt_ppgtt_smoke_huge(void *arg)\n{\n\tstruct drm_i915_private *i915 = arg;\n\tstruct drm_i915_gem_object *obj;\n\tI915_RND_STATE(prng);\n\tstruct {\n\t\tigt_create_fn fn;\n\t\tu32 min;\n\t\tu32 max;\n\t} backends[] = {\n\t\t{ igt_create_internal, SZ_64K, SZ_2M,  },\n\t\t{ igt_create_shmem,    SZ_64K, SZ_32M, },\n\t\t{ igt_create_local,    SZ_64K, SZ_1G,  },\n\t};\n\tint err;\n\tint i;\n\n\t \n\n\tfor (i = 0; i < ARRAY_SIZE(backends); ++i) {\n\t\tu32 min = backends[i].min;\n\t\tu32 max = backends[i].max;\n\t\tu32 size = max;\n\ntry_again:\n\t\tsize = igt_random_size(&prng, min, rounddown_pow_of_two(size));\n\n\t\tobj = backends[i].fn(i915, size, 0);\n\t\tif (IS_ERR(obj)) {\n\t\t\terr = PTR_ERR(obj);\n\t\t\tif (err == -E2BIG) {\n\t\t\t\tsize >>= 1;\n\t\t\t\tgoto try_again;\n\t\t\t} else if (err == -ENODEV) {\n\t\t\t\terr = 0;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\treturn err;\n\t\t}\n\n\t\terr = i915_gem_object_pin_pages_unlocked(obj);\n\t\tif (err) {\n\t\t\tif (err == -ENXIO || err == -E2BIG || err == -ENOMEM) {\n\t\t\t\ti915_gem_object_put(obj);\n\t\t\t\tsize >>= 1;\n\t\t\t\tgoto try_again;\n\t\t\t}\n\t\t\tgoto out_put;\n\t\t}\n\n\t\tif (obj->mm.page_sizes.phys < min) {\n\t\t\tpr_info(\"%s unable to allocate huge-page(s) with size=%u, i=%d\\n\",\n\t\t\t\t__func__, size, i);\n\t\t\terr = -ENOMEM;\n\t\t\tgoto out_unpin;\n\t\t}\n\n\t\terr = igt_write_huge(i915, obj);\n\t\tif (err) {\n\t\t\tpr_err(\"%s write-huge failed with size=%u, i=%d\\n\",\n\t\t\t       __func__, size, i);\n\t\t}\nout_unpin:\n\t\ti915_gem_object_lock(obj, NULL);\n\t\ti915_gem_object_unpin_pages(obj);\n\t\t__i915_gem_object_put_pages(obj);\n\t\ti915_gem_object_unlock(obj);\nout_put:\n\t\ti915_gem_object_put(obj);\n\n\t\tif (err == -ENOMEM || err == -ENXIO)\n\t\t\terr = 0;\n\n\t\tif (err)\n\t\t\tbreak;\n\n\t\tcond_resched();\n\t}\n\n\treturn err;\n}\n\nstatic int igt_ppgtt_sanity_check(void *arg)\n{\n\tstruct drm_i915_private *i915 = arg;\n\tunsigned int supported = RUNTIME_INFO(i915)->page_sizes;\n\tstruct {\n\t\tigt_create_fn fn;\n\t\tunsigned int flags;\n\t} backends[] = {\n\t\t{ igt_create_system, 0,                        },\n\t\t{ igt_create_local,  0,                        },\n\t\t{ igt_create_local,  I915_BO_ALLOC_CONTIGUOUS, },\n\t};\n\tstruct {\n\t\tu32 size;\n\t\tu32 pages;\n\t} combos[] = {\n\t\t{ SZ_64K,\t\tSZ_64K\t\t},\n\t\t{ SZ_2M,\t\tSZ_2M\t\t},\n\t\t{ SZ_2M,\t\tSZ_64K\t\t},\n\t\t{ SZ_2M - SZ_64K,\tSZ_64K\t\t},\n\t\t{ SZ_2M - SZ_4K,\tSZ_64K | SZ_4K\t},\n\t\t{ SZ_2M + SZ_4K,\tSZ_64K | SZ_4K\t},\n\t\t{ SZ_2M + SZ_4K,\tSZ_2M  | SZ_4K\t},\n\t\t{ SZ_2M + SZ_64K,\tSZ_2M  | SZ_64K },\n\t\t{ SZ_2M + SZ_64K,\tSZ_64K\t\t},\n\t};\n\tint i, j;\n\tint err;\n\n\tif (supported == I915_GTT_PAGE_SIZE_4K)\n\t\treturn 0;\n\n\t \n\n\tfor (i = 0; i < ARRAY_SIZE(backends); ++i) {\n\t\tfor (j = 0; j < ARRAY_SIZE(combos); ++j) {\n\t\t\tstruct drm_i915_gem_object *obj;\n\t\t\tu32 size = combos[j].size;\n\t\t\tu32 pages = combos[j].pages;\n\n\t\t\tobj = backends[i].fn(i915, size, backends[i].flags);\n\t\t\tif (IS_ERR(obj)) {\n\t\t\t\terr = PTR_ERR(obj);\n\t\t\t\tif (err == -ENODEV) {\n\t\t\t\t\tpr_info(\"Device lacks local memory, skipping\\n\");\n\t\t\t\t\terr = 0;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\treturn err;\n\t\t\t}\n\n\t\t\terr = i915_gem_object_pin_pages_unlocked(obj);\n\t\t\tif (err) {\n\t\t\t\ti915_gem_object_put(obj);\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tGEM_BUG_ON(pages > obj->base.size);\n\t\t\tpages = pages & supported;\n\n\t\t\tif (pages)\n\t\t\t\tobj->mm.page_sizes.sg = pages;\n\n\t\t\terr = igt_write_huge(i915, obj);\n\n\t\t\ti915_gem_object_lock(obj, NULL);\n\t\t\ti915_gem_object_unpin_pages(obj);\n\t\t\t__i915_gem_object_put_pages(obj);\n\t\t\ti915_gem_object_unlock(obj);\n\t\t\ti915_gem_object_put(obj);\n\n\t\t\tif (err) {\n\t\t\t\tpr_err(\"%s write-huge failed with size=%u pages=%u i=%d, j=%d\\n\",\n\t\t\t\t       __func__, size, pages, i, j);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\n\t\tcond_resched();\n\t}\n\nout:\n\tif (err == -ENOMEM)\n\t\terr = 0;\n\n\treturn err;\n}\n\nstatic int igt_ppgtt_compact(void *arg)\n{\n\tstruct drm_i915_private *i915 = arg;\n\tstruct drm_i915_gem_object *obj;\n\tint err;\n\n\t \n\n\tif (!HAS_64K_PAGES(i915)) {\n\t\tpr_info(\"device lacks compact 64K page support, skipping\\n\");\n\t\treturn 0;\n\t}\n\n\tif (!HAS_LMEM(i915)) {\n\t\tpr_info(\"device lacks LMEM support, skipping\\n\");\n\t\treturn 0;\n\t}\n\n\t \n\tobj = i915_gem_object_create_lmem(i915, SZ_4M, 0);\n\tif (IS_ERR(obj))\n\t\treturn PTR_ERR(obj);\n\n\terr = i915_gem_object_pin_pages_unlocked(obj);\n\tif (err)\n\t\tgoto out_put;\n\n\tif (obj->mm.page_sizes.phys < I915_GTT_PAGE_SIZE_64K) {\n\t\tpr_info(\"LMEM compact unable to allocate huge-page(s)\\n\");\n\t\tgoto out_unpin;\n\t}\n\n\t \n\tobj->mm.page_sizes.sg = I915_GTT_PAGE_SIZE_64K;\n\n\terr = igt_write_huge(i915, obj);\n\tif (err)\n\t\tpr_err(\"LMEM compact write-huge failed\\n\");\n\nout_unpin:\n\ti915_gem_object_unpin_pages(obj);\nout_put:\n\ti915_gem_object_put(obj);\n\n\tif (err == -ENOMEM)\n\t\terr = 0;\n\n\treturn err;\n}\n\nstatic int igt_ppgtt_mixed(void *arg)\n{\n\tstruct drm_i915_private *i915 = arg;\n\tconst unsigned long flags = PIN_OFFSET_FIXED | PIN_USER;\n\tstruct drm_i915_gem_object *obj, *on;\n\tstruct i915_gem_engines *engines;\n\tstruct i915_gem_engines_iter it;\n\tstruct i915_address_space *vm;\n\tstruct i915_gem_context *ctx;\n\tstruct intel_context *ce;\n\tstruct file *file;\n\tI915_RND_STATE(prng);\n\tLIST_HEAD(objects);\n\tstruct intel_memory_region *mr;\n\tstruct i915_vma *vma;\n\tunsigned int count;\n\tu32 i, addr;\n\tint *order;\n\tint n, err;\n\n\t \n\n\tif (!HAS_64K_PAGES(i915)) {\n\t\tpr_info(\"device lacks PS64, skipping\\n\");\n\t\treturn 0;\n\t}\n\n\tfile = mock_file(i915);\n\tif (IS_ERR(file))\n\t\treturn PTR_ERR(file);\n\n\tctx = hugepage_ctx(i915, file);\n\tif (IS_ERR(ctx)) {\n\t\terr = PTR_ERR(ctx);\n\t\tgoto out;\n\t}\n\tvm = i915_gem_context_get_eb_vm(ctx);\n\n\ti = 0;\n\taddr = 0;\n\tdo {\n\t\tu32 sz;\n\n\t\tsz = i915_prandom_u32_max_state(SZ_4M, &prng);\n\t\tsz = max_t(u32, sz, SZ_4K);\n\n\t\tmr = i915->mm.regions[INTEL_REGION_LMEM_0];\n\t\tif (i & 1)\n\t\t\tmr = i915->mm.regions[INTEL_REGION_SMEM];\n\n\t\tobj = i915_gem_object_create_region(mr, sz, 0, 0);\n\t\tif (IS_ERR(obj)) {\n\t\t\terr = PTR_ERR(obj);\n\t\t\tgoto out_vm;\n\t\t}\n\n\t\tlist_add_tail(&obj->st_link, &objects);\n\n\t\tvma = i915_vma_instance(obj, vm, NULL);\n\t\tif (IS_ERR(vma)) {\n\t\t\terr = PTR_ERR(vma);\n\t\t\tgoto err_put;\n\t\t}\n\n\t\taddr = round_up(addr, mr->min_page_size);\n\t\terr = i915_vma_pin(vma, 0, 0, addr | flags);\n\t\tif (err)\n\t\t\tgoto err_put;\n\n\t\tif (mr->type == INTEL_MEMORY_LOCAL &&\n\t\t    (vma->resource->page_sizes_gtt & I915_GTT_PAGE_SIZE_4K)) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto err_put;\n\t\t}\n\n\t\taddr += obj->base.size;\n\t\ti++;\n\t} while (addr <= SZ_16M);\n\n\tn = 0;\n\tcount = 0;\n\tfor_each_gem_engine(ce, i915_gem_context_lock_engines(ctx), it) {\n\t\tcount++;\n\t\tif (!intel_engine_can_store_dword(ce->engine))\n\t\t\tcontinue;\n\n\t\tn++;\n\t}\n\ti915_gem_context_unlock_engines(ctx);\n\tif (!n)\n\t\tgoto err_put;\n\n\torder = i915_random_order(count * count, &prng);\n\tif (!order) {\n\t\terr = -ENOMEM;\n\t\tgoto err_put;\n\t}\n\n\ti = 0;\n\taddr = 0;\n\tengines = i915_gem_context_lock_engines(ctx);\n\tlist_for_each_entry(obj, &objects, st_link) {\n\t\tu32 rnd = i915_prandom_u32_max_state(UINT_MAX, &prng);\n\n\t\taddr = round_up(addr, obj->mm.region->min_page_size);\n\n\t\tce = engines->engines[order[i] % engines->num_engines];\n\t\ti = (i + 1) % (count * count);\n\t\tif (!ce || !intel_engine_can_store_dword(ce->engine))\n\t\t\tcontinue;\n\n\t\terr = __igt_write_huge(ce, obj, obj->base.size, addr, 0, rnd);\n\t\tif (err)\n\t\t\tbreak;\n\n\t\terr = __igt_write_huge(ce, obj, obj->base.size, addr,\n\t\t\t\t       offset_in_page(rnd) / sizeof(u32), rnd + 1);\n\t\tif (err)\n\t\t\tbreak;\n\n\t\terr = __igt_write_huge(ce, obj, obj->base.size, addr,\n\t\t\t\t       (PAGE_SIZE / sizeof(u32)) - 1,\n\t\t\t\t       rnd + 2);\n\t\tif (err)\n\t\t\tbreak;\n\n\t\taddr += obj->base.size;\n\n\t\tcond_resched();\n\t}\n\n\ti915_gem_context_unlock_engines(ctx);\n\tkfree(order);\nerr_put:\n\tlist_for_each_entry_safe(obj, on, &objects, st_link) {\n\t\tlist_del(&obj->st_link);\n\t\ti915_gem_object_put(obj);\n\t}\nout_vm:\n\ti915_vm_put(vm);\nout:\n\tfput(file);\n\treturn err;\n}\n\nstatic int igt_tmpfs_fallback(void *arg)\n{\n\tstruct drm_i915_private *i915 = arg;\n\tstruct i915_address_space *vm;\n\tstruct i915_gem_context *ctx;\n\tstruct vfsmount *gemfs = i915->mm.gemfs;\n\tstruct drm_i915_gem_object *obj;\n\tstruct i915_vma *vma;\n\tstruct file *file;\n\tu32 *vaddr;\n\tint err = 0;\n\n\tfile = mock_file(i915);\n\tif (IS_ERR(file))\n\t\treturn PTR_ERR(file);\n\n\tctx = hugepage_ctx(i915, file);\n\tif (IS_ERR(ctx)) {\n\t\terr = PTR_ERR(ctx);\n\t\tgoto out;\n\t}\n\tvm = i915_gem_context_get_eb_vm(ctx);\n\n\t \n\n\ti915->mm.gemfs = NULL;\n\n\tobj = i915_gem_object_create_shmem(i915, PAGE_SIZE);\n\tif (IS_ERR(obj)) {\n\t\terr = PTR_ERR(obj);\n\t\tgoto out_restore;\n\t}\n\n\tvaddr = i915_gem_object_pin_map_unlocked(obj, I915_MAP_WB);\n\tif (IS_ERR(vaddr)) {\n\t\terr = PTR_ERR(vaddr);\n\t\tgoto out_put;\n\t}\n\t*vaddr = 0xdeadbeaf;\n\n\t__i915_gem_object_flush_map(obj, 0, 64);\n\ti915_gem_object_unpin_map(obj);\n\n\tvma = i915_vma_instance(obj, vm, NULL);\n\tif (IS_ERR(vma)) {\n\t\terr = PTR_ERR(vma);\n\t\tgoto out_put;\n\t}\n\n\terr = i915_vma_pin(vma, 0, 0, PIN_USER);\n\tif (err)\n\t\tgoto out_put;\n\n\terr = igt_check_page_sizes(vma);\n\n\ti915_vma_unpin(vma);\nout_put:\n\ti915_gem_object_put(obj);\nout_restore:\n\ti915->mm.gemfs = gemfs;\n\n\ti915_vm_put(vm);\nout:\n\tfput(file);\n\treturn err;\n}\n\nstatic int igt_shrink_thp(void *arg)\n{\n\tstruct drm_i915_private *i915 = arg;\n\tstruct i915_address_space *vm;\n\tstruct i915_gem_context *ctx;\n\tstruct drm_i915_gem_object *obj;\n\tstruct i915_gem_engines_iter it;\n\tstruct intel_context *ce;\n\tstruct i915_vma *vma;\n\tstruct file *file;\n\tunsigned int flags = PIN_USER;\n\tunsigned int n;\n\tintel_wakeref_t wf;\n\tbool should_swap;\n\tint err;\n\n\tif (!igt_can_allocate_thp(i915)) {\n\t\tpr_info(\"missing THP support, skipping\\n\");\n\t\treturn 0;\n\t}\n\n\tfile = mock_file(i915);\n\tif (IS_ERR(file))\n\t\treturn PTR_ERR(file);\n\n\tctx = hugepage_ctx(i915, file);\n\tif (IS_ERR(ctx)) {\n\t\terr = PTR_ERR(ctx);\n\t\tgoto out;\n\t}\n\tvm = i915_gem_context_get_eb_vm(ctx);\n\n\t \n\n\tobj = i915_gem_object_create_shmem(i915, SZ_2M);\n\tif (IS_ERR(obj)) {\n\t\terr = PTR_ERR(obj);\n\t\tgoto out_vm;\n\t}\n\n\tvma = i915_vma_instance(obj, vm, NULL);\n\tif (IS_ERR(vma)) {\n\t\terr = PTR_ERR(vma);\n\t\tgoto out_put;\n\t}\n\n\twf = intel_runtime_pm_get(&i915->runtime_pm);  \n\n\terr = i915_vma_pin(vma, 0, 0, flags);\n\tif (err)\n\t\tgoto out_wf;\n\n\tif (obj->mm.page_sizes.phys < I915_GTT_PAGE_SIZE_2M) {\n\t\tpr_info(\"failed to allocate THP, finishing test early\\n\");\n\t\tgoto out_unpin;\n\t}\n\n\terr = igt_check_page_sizes(vma);\n\tif (err)\n\t\tgoto out_unpin;\n\n\tn = 0;\n\n\tfor_each_gem_engine(ce, i915_gem_context_lock_engines(ctx), it) {\n\t\tif (!intel_engine_can_store_dword(ce->engine))\n\t\t\tcontinue;\n\n\t\terr = gpu_write(ce, vma, n++, 0xdeadbeaf);\n\t\tif (err)\n\t\t\tbreak;\n\t}\n\ti915_gem_context_unlock_engines(ctx);\n\t \n\ti915_gem_shrink(NULL, i915, -1UL, NULL,\n\t\t\tI915_SHRINK_BOUND |\n\t\t\tI915_SHRINK_UNBOUND |\n\t\t\tI915_SHRINK_ACTIVE);\n\ti915_vma_unpin(vma);\n\tif (err)\n\t\tgoto out_wf;\n\n\t \n\tshould_swap = get_nr_swap_pages() > 0;\n\ti915_gem_shrink(NULL, i915, -1UL, NULL,\n\t\t\tI915_SHRINK_BOUND |\n\t\t\tI915_SHRINK_UNBOUND |\n\t\t\tI915_SHRINK_ACTIVE |\n\t\t\tI915_SHRINK_WRITEBACK);\n\tif (should_swap == i915_gem_object_has_pages(obj)) {\n\t\tpr_err(\"unexpected pages mismatch, should_swap=%s\\n\",\n\t\t       str_yes_no(should_swap));\n\t\terr = -EINVAL;\n\t\tgoto out_wf;\n\t}\n\n\tif (should_swap == (obj->mm.page_sizes.sg || obj->mm.page_sizes.phys)) {\n\t\tpr_err(\"unexpected residual page-size bits, should_swap=%s\\n\",\n\t\t       str_yes_no(should_swap));\n\t\terr = -EINVAL;\n\t\tgoto out_wf;\n\t}\n\n\terr = i915_vma_pin(vma, 0, 0, flags);\n\tif (err)\n\t\tgoto out_wf;\n\n\twhile (n--) {\n\t\terr = cpu_check(obj, n, 0xdeadbeaf);\n\t\tif (err)\n\t\t\tbreak;\n\t}\n\nout_unpin:\n\ti915_vma_unpin(vma);\nout_wf:\n\tintel_runtime_pm_put(&i915->runtime_pm, wf);\nout_put:\n\ti915_gem_object_put(obj);\nout_vm:\n\ti915_vm_put(vm);\nout:\n\tfput(file);\n\treturn err;\n}\n\nint i915_gem_huge_page_mock_selftests(void)\n{\n\tstatic const struct i915_subtest tests[] = {\n\t\tSUBTEST(igt_mock_exhaust_device_supported_pages),\n\t\tSUBTEST(igt_mock_memory_region_huge_pages),\n\t\tSUBTEST(igt_mock_ppgtt_misaligned_dma),\n\t};\n\tstruct drm_i915_private *dev_priv;\n\tstruct i915_ppgtt *ppgtt;\n\tint err;\n\n\tdev_priv = mock_gem_device();\n\tif (!dev_priv)\n\t\treturn -ENOMEM;\n\n\t \n\tRUNTIME_INFO(dev_priv)->ppgtt_type = INTEL_PPGTT_FULL;\n\tRUNTIME_INFO(dev_priv)->ppgtt_size = 48;\n\n\tppgtt = i915_ppgtt_create(to_gt(dev_priv), 0);\n\tif (IS_ERR(ppgtt)) {\n\t\terr = PTR_ERR(ppgtt);\n\t\tgoto out_unlock;\n\t}\n\n\tif (!i915_vm_is_4lvl(&ppgtt->vm)) {\n\t\tpr_err(\"failed to create 48b PPGTT\\n\");\n\t\terr = -EINVAL;\n\t\tgoto out_put;\n\t}\n\n\t \n\tif (!i915_vm_has_scratch_64K(&ppgtt->vm)) {\n\t\tpr_err(\"PPGTT missing 64K scratch page\\n\");\n\t\terr = -EINVAL;\n\t\tgoto out_put;\n\t}\n\n\terr = i915_subtests(tests, ppgtt);\n\nout_put:\n\ti915_vm_put(&ppgtt->vm);\nout_unlock:\n\tmock_destroy_device(dev_priv);\n\treturn err;\n}\n\nint i915_gem_huge_page_live_selftests(struct drm_i915_private *i915)\n{\n\tstatic const struct i915_subtest tests[] = {\n\t\tSUBTEST(igt_shrink_thp),\n\t\tSUBTEST(igt_tmpfs_fallback),\n\t\tSUBTEST(igt_ppgtt_smoke_huge),\n\t\tSUBTEST(igt_ppgtt_sanity_check),\n\t\tSUBTEST(igt_ppgtt_compact),\n\t\tSUBTEST(igt_ppgtt_mixed),\n\t\tSUBTEST(igt_ppgtt_huge_fill),\n\t\tSUBTEST(igt_ppgtt_64K),\n\t};\n\n\tif (!HAS_PPGTT(i915)) {\n\t\tpr_info(\"PPGTT not supported, skipping live-selftests\\n\");\n\t\treturn 0;\n\t}\n\n\tif (intel_gt_is_wedged(to_gt(i915)))\n\t\treturn 0;\n\n\treturn i915_live_subtests(tests, i915);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}