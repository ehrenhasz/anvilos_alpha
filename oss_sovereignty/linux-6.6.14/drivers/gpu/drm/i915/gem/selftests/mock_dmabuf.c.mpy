{
  "module_name": "mock_dmabuf.c",
  "hash_id": "691bd9e5e7c7b6714e1f9572f46bb66daf6213a006999691c00e1c478af4aa76",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/i915/gem/selftests/mock_dmabuf.c",
  "human_readable_source": " \n\n#include \"mock_dmabuf.h\"\n\nstatic struct sg_table *mock_map_dma_buf(struct dma_buf_attachment *attachment,\n\t\t\t\t\t enum dma_data_direction dir)\n{\n\tstruct mock_dmabuf *mock = to_mock(attachment->dmabuf);\n\tstruct sg_table *st;\n\tstruct scatterlist *sg;\n\tint i, err;\n\n\tst = kmalloc(sizeof(*st), GFP_KERNEL);\n\tif (!st)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\terr = sg_alloc_table(st, mock->npages, GFP_KERNEL);\n\tif (err)\n\t\tgoto err_free;\n\n\tsg = st->sgl;\n\tfor (i = 0; i < mock->npages; i++) {\n\t\tsg_set_page(sg, mock->pages[i], PAGE_SIZE, 0);\n\t\tsg = sg_next(sg);\n\t}\n\n\terr = dma_map_sgtable(attachment->dev, st, dir, 0);\n\tif (err)\n\t\tgoto err_st;\n\n\treturn st;\n\nerr_st:\n\tsg_free_table(st);\nerr_free:\n\tkfree(st);\n\treturn ERR_PTR(err);\n}\n\nstatic void mock_unmap_dma_buf(struct dma_buf_attachment *attachment,\n\t\t\t       struct sg_table *st,\n\t\t\t       enum dma_data_direction dir)\n{\n\tdma_unmap_sgtable(attachment->dev, st, dir, 0);\n\tsg_free_table(st);\n\tkfree(st);\n}\n\nstatic void mock_dmabuf_release(struct dma_buf *dma_buf)\n{\n\tstruct mock_dmabuf *mock = to_mock(dma_buf);\n\tint i;\n\n\tfor (i = 0; i < mock->npages; i++)\n\t\tput_page(mock->pages[i]);\n\n\tkfree(mock);\n}\n\nstatic int mock_dmabuf_vmap(struct dma_buf *dma_buf, struct iosys_map *map)\n{\n\tstruct mock_dmabuf *mock = to_mock(dma_buf);\n\tvoid *vaddr;\n\n\tvaddr = vm_map_ram(mock->pages, mock->npages, 0);\n\tif (!vaddr)\n\t\treturn -ENOMEM;\n\tiosys_map_set_vaddr(map, vaddr);\n\n\treturn 0;\n}\n\nstatic void mock_dmabuf_vunmap(struct dma_buf *dma_buf, struct iosys_map *map)\n{\n\tstruct mock_dmabuf *mock = to_mock(dma_buf);\n\n\tvm_unmap_ram(map->vaddr, mock->npages);\n}\n\nstatic int mock_dmabuf_mmap(struct dma_buf *dma_buf, struct vm_area_struct *vma)\n{\n\treturn -ENODEV;\n}\n\nstatic const struct dma_buf_ops mock_dmabuf_ops =  {\n\t.map_dma_buf = mock_map_dma_buf,\n\t.unmap_dma_buf = mock_unmap_dma_buf,\n\t.release = mock_dmabuf_release,\n\t.mmap = mock_dmabuf_mmap,\n\t.vmap = mock_dmabuf_vmap,\n\t.vunmap = mock_dmabuf_vunmap,\n};\n\nstatic struct dma_buf *mock_dmabuf(int npages)\n{\n\tstruct mock_dmabuf *mock;\n\tDEFINE_DMA_BUF_EXPORT_INFO(exp_info);\n\tstruct dma_buf *dmabuf;\n\tint i;\n\n\tmock = kmalloc(sizeof(*mock) + npages * sizeof(struct page *),\n\t\t       GFP_KERNEL);\n\tif (!mock)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tmock->npages = npages;\n\tfor (i = 0; i < npages; i++) {\n\t\tmock->pages[i] = alloc_page(GFP_KERNEL);\n\t\tif (!mock->pages[i])\n\t\t\tgoto err;\n\t}\n\n\texp_info.ops = &mock_dmabuf_ops;\n\texp_info.size = npages * PAGE_SIZE;\n\texp_info.flags = O_CLOEXEC;\n\texp_info.priv = mock;\n\n\tdmabuf = dma_buf_export(&exp_info);\n\tif (IS_ERR(dmabuf))\n\t\tgoto err;\n\n\treturn dmabuf;\n\nerr:\n\twhile (i--)\n\t\tput_page(mock->pages[i]);\n\tkfree(mock);\n\treturn ERR_PTR(-ENOMEM);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}