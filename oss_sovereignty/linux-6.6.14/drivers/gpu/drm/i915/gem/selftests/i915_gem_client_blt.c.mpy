{
  "module_name": "i915_gem_client_blt.c",
  "hash_id": "d809b61dc95f9031b1d6264be09638422b9e04579ae7ed0483a09ad8a5700f72",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/i915/gem/selftests/i915_gem_client_blt.c",
  "human_readable_source": "\n \n\n#include \"i915_selftest.h\"\n\n#include \"gt/intel_context.h\"\n#include \"gt/intel_engine_regs.h\"\n#include \"gt/intel_engine_user.h\"\n#include \"gt/intel_gpu_commands.h\"\n#include \"gt/intel_gt.h\"\n#include \"gt/intel_gt_regs.h\"\n#include \"gem/i915_gem_lmem.h\"\n\n#include \"gem/selftests/igt_gem_utils.h\"\n#include \"selftests/igt_flush_test.h\"\n#include \"selftests/mock_drm.h\"\n#include \"selftests/i915_random.h\"\n#include \"huge_gem_object.h\"\n#include \"mock_context.h\"\n\n#define OW_SIZE 16                       \n#define F_SUBTILE_SIZE 64                \n#define F_TILE_WIDTH 128                 \n#define F_TILE_HEIGHT 32                 \n#define F_SUBTILE_WIDTH  OW_SIZE         \n#define F_SUBTILE_HEIGHT 4               \n\nstatic int linear_x_y_to_ftiled_pos(int x, int y, u32 stride, int bpp)\n{\n\tint tile_base;\n\tint tile_x, tile_y;\n\tint swizzle, subtile;\n\tint pixel_size = bpp / 8;\n\tint pos;\n\n\t \n\tstatic const u8 f_subtile_map[] = {\n\t\t 0,  1,  2,  3,  8,  9, 10, 11,\n\t\t 4,  5,  6,  7, 12, 13, 14, 15,\n\t\t16, 17, 18, 19, 24, 25, 26, 27,\n\t\t20, 21, 22, 23, 28, 29, 30, 31,\n\t\t32, 33, 34, 35, 40, 41, 42, 43,\n\t\t36, 37, 38, 39, 44, 45, 46, 47,\n\t\t48, 49, 50, 51, 56, 57, 58, 59,\n\t\t52, 53, 54, 55, 60, 61, 62, 63\n\t};\n\n\tx *= pixel_size;\n\t \n\ttile_base =\n\t\ty / F_TILE_HEIGHT * stride * F_TILE_HEIGHT +\n\t\tx / F_TILE_WIDTH * 4096;\n\n\t \n\ttile_x = x % F_TILE_WIDTH;\n\ttile_y = y % F_TILE_HEIGHT;\n\n\t \n\tsubtile = tile_y / F_SUBTILE_HEIGHT * 8 + tile_x / F_SUBTILE_WIDTH;\n\n\t \n\tswizzle = f_subtile_map[subtile];\n\n\t \n\tpos = tile_base +\n\t\tswizzle * F_SUBTILE_SIZE +\n\t\ttile_y % F_SUBTILE_HEIGHT * OW_SIZE +\n\t\ttile_x % F_SUBTILE_WIDTH;\n\n\tGEM_BUG_ON(!IS_ALIGNED(pos, pixel_size));\n\n\treturn pos / pixel_size * 4;\n}\n\nenum client_tiling {\n\tCLIENT_TILING_LINEAR,\n\tCLIENT_TILING_X,\n\tCLIENT_TILING_Y,\n\tCLIENT_TILING_4,\n\tCLIENT_NUM_TILING_TYPES\n};\n\n#define WIDTH 512\n#define HEIGHT 32\n\nstruct blit_buffer {\n\tstruct i915_vma *vma;\n\tu32 start_val;\n\tenum client_tiling tiling;\n};\n\nstruct tiled_blits {\n\tstruct intel_context *ce;\n\tstruct blit_buffer buffers[3];\n\tstruct blit_buffer scratch;\n\tstruct i915_vma *batch;\n\tu64 hole;\n\tu64 align;\n\tu32 width;\n\tu32 height;\n};\n\nstatic bool fastblit_supports_x_tiling(const struct drm_i915_private *i915)\n{\n\tint gen = GRAPHICS_VER(i915);\n\n\t \n\tdrm_WARN_ON(&i915->drm, gen < 9);\n\n\tif (gen < 12)\n\t\treturn true;\n\n\tif (GRAPHICS_VER_FULL(i915) < IP_VER(12, 50))\n\t\treturn false;\n\n\treturn HAS_DISPLAY(i915);\n}\n\nstatic bool fast_blit_ok(const struct blit_buffer *buf)\n{\n\t \n\tif (GRAPHICS_VER(buf->vma->vm->i915) < 9)\n\t\treturn false;\n\n\t \n\tif (buf->tiling == CLIENT_TILING_X && !fastblit_supports_x_tiling(buf->vma->vm->i915))\n\t\treturn false;\n\n\treturn true;\n}\n\nstatic int prepare_blit(const struct tiled_blits *t,\n\t\t\tstruct blit_buffer *dst,\n\t\t\tstruct blit_buffer *src,\n\t\t\tstruct drm_i915_gem_object *batch)\n{\n\tconst int ver = GRAPHICS_VER(to_i915(batch->base.dev));\n\tbool use_64b_reloc = ver >= 8;\n\tu32 src_pitch, dst_pitch;\n\tu32 cmd, *cs;\n\n\tcs = i915_gem_object_pin_map_unlocked(batch, I915_MAP_WC);\n\tif (IS_ERR(cs))\n\t\treturn PTR_ERR(cs);\n\n\tif (fast_blit_ok(dst) && fast_blit_ok(src)) {\n\t\tstruct intel_gt *gt = t->ce->engine->gt;\n\t\tu32 src_tiles = 0, dst_tiles = 0;\n\t\tu32 src_4t = 0, dst_4t = 0;\n\n\t\t \n\t\t*cs++ = MI_LOAD_REGISTER_IMM(1);\n\t\t*cs++ = i915_mmio_reg_offset(BLIT_CCTL(t->ce->engine->mmio_base));\n\t\t*cs++ = (BLIT_CCTL_SRC_MOCS(gt->mocs.uc_index) |\n\t\t\t BLIT_CCTL_DST_MOCS(gt->mocs.uc_index));\n\n\t\tsrc_pitch = t->width;  \n\t\tif (src->tiling == CLIENT_TILING_4) {\n\t\t\tsrc_tiles = XY_FAST_COPY_BLT_D0_SRC_TILE_MODE(YMAJOR);\n\t\t\tsrc_4t = XY_FAST_COPY_BLT_D1_SRC_TILE4;\n\t\t} else if (src->tiling == CLIENT_TILING_Y) {\n\t\t\tsrc_tiles = XY_FAST_COPY_BLT_D0_SRC_TILE_MODE(YMAJOR);\n\t\t} else if (src->tiling == CLIENT_TILING_X) {\n\t\t\tsrc_tiles = XY_FAST_COPY_BLT_D0_SRC_TILE_MODE(TILE_X);\n\t\t} else {\n\t\t\tsrc_pitch *= 4;  \n\t\t}\n\n\t\tdst_pitch = t->width;  \n\t\tif (dst->tiling == CLIENT_TILING_4) {\n\t\t\tdst_tiles = XY_FAST_COPY_BLT_D0_DST_TILE_MODE(YMAJOR);\n\t\t\tdst_4t = XY_FAST_COPY_BLT_D1_DST_TILE4;\n\t\t} else if (dst->tiling == CLIENT_TILING_Y) {\n\t\t\tdst_tiles = XY_FAST_COPY_BLT_D0_DST_TILE_MODE(YMAJOR);\n\t\t} else if (dst->tiling == CLIENT_TILING_X) {\n\t\t\tdst_tiles = XY_FAST_COPY_BLT_D0_DST_TILE_MODE(TILE_X);\n\t\t} else {\n\t\t\tdst_pitch *= 4;  \n\t\t}\n\n\t\t*cs++ = GEN9_XY_FAST_COPY_BLT_CMD | (10 - 2) |\n\t\t\tsrc_tiles | dst_tiles;\n\t\t*cs++ = src_4t | dst_4t | BLT_DEPTH_32 | dst_pitch;\n\t\t*cs++ = 0;\n\t\t*cs++ = t->height << 16 | t->width;\n\t\t*cs++ = lower_32_bits(i915_vma_offset(dst->vma));\n\t\t*cs++ = upper_32_bits(i915_vma_offset(dst->vma));\n\t\t*cs++ = 0;\n\t\t*cs++ = src_pitch;\n\t\t*cs++ = lower_32_bits(i915_vma_offset(src->vma));\n\t\t*cs++ = upper_32_bits(i915_vma_offset(src->vma));\n\t} else {\n\t\tif (ver >= 6) {\n\t\t\t*cs++ = MI_LOAD_REGISTER_IMM(1);\n\t\t\t*cs++ = i915_mmio_reg_offset(BCS_SWCTRL);\n\t\t\tcmd = (BCS_SRC_Y | BCS_DST_Y) << 16;\n\t\t\tif (src->tiling == CLIENT_TILING_Y)\n\t\t\t\tcmd |= BCS_SRC_Y;\n\t\t\tif (dst->tiling == CLIENT_TILING_Y)\n\t\t\t\tcmd |= BCS_DST_Y;\n\t\t\t*cs++ = cmd;\n\n\t\t\tcmd = MI_FLUSH_DW;\n\t\t\tif (ver >= 8)\n\t\t\t\tcmd++;\n\t\t\t*cs++ = cmd;\n\t\t\t*cs++ = 0;\n\t\t\t*cs++ = 0;\n\t\t\t*cs++ = 0;\n\t\t}\n\n\t\tcmd = XY_SRC_COPY_BLT_CMD | BLT_WRITE_RGBA | (8 - 2);\n\t\tif (ver >= 8)\n\t\t\tcmd += 2;\n\n\t\tsrc_pitch = t->width * 4;\n\t\tif (src->tiling) {\n\t\t\tcmd |= XY_SRC_COPY_BLT_SRC_TILED;\n\t\t\tsrc_pitch /= 4;\n\t\t}\n\n\t\tdst_pitch = t->width * 4;\n\t\tif (dst->tiling) {\n\t\t\tcmd |= XY_SRC_COPY_BLT_DST_TILED;\n\t\t\tdst_pitch /= 4;\n\t\t}\n\n\t\t*cs++ = cmd;\n\t\t*cs++ = BLT_DEPTH_32 | BLT_ROP_SRC_COPY | dst_pitch;\n\t\t*cs++ = 0;\n\t\t*cs++ = t->height << 16 | t->width;\n\t\t*cs++ = lower_32_bits(i915_vma_offset(dst->vma));\n\t\tif (use_64b_reloc)\n\t\t\t*cs++ = upper_32_bits(i915_vma_offset(dst->vma));\n\t\t*cs++ = 0;\n\t\t*cs++ = src_pitch;\n\t\t*cs++ = lower_32_bits(i915_vma_offset(src->vma));\n\t\tif (use_64b_reloc)\n\t\t\t*cs++ = upper_32_bits(i915_vma_offset(src->vma));\n\t}\n\n\t*cs++ = MI_BATCH_BUFFER_END;\n\n\ti915_gem_object_flush_map(batch);\n\ti915_gem_object_unpin_map(batch);\n\n\treturn 0;\n}\n\nstatic void tiled_blits_destroy_buffers(struct tiled_blits *t)\n{\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(t->buffers); i++)\n\t\ti915_vma_put(t->buffers[i].vma);\n\n\ti915_vma_put(t->scratch.vma);\n\ti915_vma_put(t->batch);\n}\n\nstatic struct i915_vma *\n__create_vma(struct tiled_blits *t, size_t size, bool lmem)\n{\n\tstruct drm_i915_private *i915 = t->ce->vm->i915;\n\tstruct drm_i915_gem_object *obj;\n\tstruct i915_vma *vma;\n\n\tif (lmem)\n\t\tobj = i915_gem_object_create_lmem(i915, size, 0);\n\telse\n\t\tobj = i915_gem_object_create_shmem(i915, size);\n\tif (IS_ERR(obj))\n\t\treturn ERR_CAST(obj);\n\n\tvma = i915_vma_instance(obj, t->ce->vm, NULL);\n\tif (IS_ERR(vma))\n\t\ti915_gem_object_put(obj);\n\n\treturn vma;\n}\n\nstatic struct i915_vma *create_vma(struct tiled_blits *t, bool lmem)\n{\n\treturn __create_vma(t, PAGE_ALIGN(t->width * t->height * 4), lmem);\n}\n\nstatic int tiled_blits_create_buffers(struct tiled_blits *t,\n\t\t\t\t      int width, int height,\n\t\t\t\t      struct rnd_state *prng)\n{\n\tstruct drm_i915_private *i915 = t->ce->engine->i915;\n\tint i;\n\n\tt->width = width;\n\tt->height = height;\n\n\tt->batch = __create_vma(t, PAGE_SIZE, false);\n\tif (IS_ERR(t->batch))\n\t\treturn PTR_ERR(t->batch);\n\n\tt->scratch.vma = create_vma(t, false);\n\tif (IS_ERR(t->scratch.vma)) {\n\t\ti915_vma_put(t->batch);\n\t\treturn PTR_ERR(t->scratch.vma);\n\t}\n\n\tfor (i = 0; i < ARRAY_SIZE(t->buffers); i++) {\n\t\tstruct i915_vma *vma;\n\n\t\tvma = create_vma(t, HAS_LMEM(i915) && i % 2);\n\t\tif (IS_ERR(vma)) {\n\t\t\ttiled_blits_destroy_buffers(t);\n\t\t\treturn PTR_ERR(vma);\n\t\t}\n\n\t\tt->buffers[i].vma = vma;\n\t\tt->buffers[i].tiling =\n\t\t\ti915_prandom_u32_max_state(CLIENT_NUM_TILING_TYPES, prng);\n\n\t\t \n\t\tif (HAS_4TILE(i915) && t->buffers[i].tiling == CLIENT_TILING_Y)\n\t\t\tt->buffers[i].tiling = CLIENT_TILING_4;\n\t\telse if (!HAS_4TILE(i915) && t->buffers[i].tiling == CLIENT_TILING_4)\n\t\t\tt->buffers[i].tiling = CLIENT_TILING_Y;\n\t}\n\n\treturn 0;\n}\n\nstatic void fill_scratch(struct tiled_blits *t, u32 *vaddr, u32 val)\n{\n\tint i;\n\n\tt->scratch.start_val = val;\n\tfor (i = 0; i < t->width * t->height; i++)\n\t\tvaddr[i] = val++;\n\n\ti915_gem_object_flush_map(t->scratch.vma->obj);\n}\n\nstatic u64 swizzle_bit(unsigned int bit, u64 offset)\n{\n\treturn (offset & BIT_ULL(bit)) >> (bit - 6);\n}\n\nstatic u64 tiled_offset(const struct intel_gt *gt,\n\t\t\tu64 v,\n\t\t\tunsigned int stride,\n\t\t\tenum client_tiling tiling,\n\t\t\tint x_pos, int y_pos)\n{\n\tunsigned int swizzle;\n\tu64 x, y;\n\n\tif (tiling == CLIENT_TILING_LINEAR)\n\t\treturn v;\n\n\ty = div64_u64_rem(v, stride, &x);\n\n\tif (tiling == CLIENT_TILING_4) {\n\t\tv = linear_x_y_to_ftiled_pos(x_pos, y_pos, stride, 32);\n\n\t\t \n\t\tswizzle = I915_BIT_6_SWIZZLE_NONE;\n\t} else if (tiling == CLIENT_TILING_X) {\n\t\tv = div64_u64_rem(y, 8, &y) * stride * 8;\n\t\tv += y * 512;\n\t\tv += div64_u64_rem(x, 512, &x) << 12;\n\t\tv += x;\n\n\t\tswizzle = gt->ggtt->bit_6_swizzle_x;\n\t} else {\n\t\tconst unsigned int ytile_span = 16;\n\t\tconst unsigned int ytile_height = 512;\n\n\t\tv = div64_u64_rem(y, 32, &y) * stride * 32;\n\t\tv += y * ytile_span;\n\t\tv += div64_u64_rem(x, ytile_span, &x) * ytile_height;\n\t\tv += x;\n\n\t\tswizzle = gt->ggtt->bit_6_swizzle_y;\n\t}\n\n\tswitch (swizzle) {\n\tcase I915_BIT_6_SWIZZLE_9:\n\t\tv ^= swizzle_bit(9, v);\n\t\tbreak;\n\tcase I915_BIT_6_SWIZZLE_9_10:\n\t\tv ^= swizzle_bit(9, v) ^ swizzle_bit(10, v);\n\t\tbreak;\n\tcase I915_BIT_6_SWIZZLE_9_11:\n\t\tv ^= swizzle_bit(9, v) ^ swizzle_bit(11, v);\n\t\tbreak;\n\tcase I915_BIT_6_SWIZZLE_9_10_11:\n\t\tv ^= swizzle_bit(9, v) ^ swizzle_bit(10, v) ^ swizzle_bit(11, v);\n\t\tbreak;\n\t}\n\n\treturn v;\n}\n\nstatic const char *repr_tiling(enum client_tiling tiling)\n{\n\tswitch (tiling) {\n\tcase CLIENT_TILING_LINEAR: return \"linear\";\n\tcase CLIENT_TILING_X: return \"X\";\n\tcase CLIENT_TILING_Y: return \"Y\";\n\tcase CLIENT_TILING_4: return \"F\";\n\tdefault: return \"unknown\";\n\t}\n}\n\nstatic int verify_buffer(const struct tiled_blits *t,\n\t\t\t struct blit_buffer *buf,\n\t\t\t struct rnd_state *prng)\n{\n\tconst u32 *vaddr;\n\tint ret = 0;\n\tint x, y, p;\n\n\tx = i915_prandom_u32_max_state(t->width, prng);\n\ty = i915_prandom_u32_max_state(t->height, prng);\n\tp = y * t->width + x;\n\n\tvaddr = i915_gem_object_pin_map_unlocked(buf->vma->obj, I915_MAP_WC);\n\tif (IS_ERR(vaddr))\n\t\treturn PTR_ERR(vaddr);\n\n\tif (vaddr[0] != buf->start_val) {\n\t\tret = -EINVAL;\n\t} else {\n\t\tu64 v = tiled_offset(buf->vma->vm->gt,\n\t\t\t\t     p * 4, t->width * 4,\n\t\t\t\t     buf->tiling, x, y);\n\n\t\tif (vaddr[v / sizeof(*vaddr)] != buf->start_val + p)\n\t\t\tret = -EINVAL;\n\t}\n\tif (ret) {\n\t\tpr_err(\"Invalid %s tiling detected at (%d, %d), start_val %x\\n\",\n\t\t       repr_tiling(buf->tiling),\n\t\t       x, y, buf->start_val);\n\t\tigt_hexdump(vaddr, 4096);\n\t}\n\n\ti915_gem_object_unpin_map(buf->vma->obj);\n\treturn ret;\n}\n\nstatic int pin_buffer(struct i915_vma *vma, u64 addr)\n{\n\tint err;\n\n\tif (drm_mm_node_allocated(&vma->node) && i915_vma_offset(vma) != addr) {\n\t\terr = i915_vma_unbind_unlocked(vma);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\terr = i915_vma_pin(vma, 0, 0, PIN_USER | PIN_OFFSET_FIXED | addr);\n\tif (err)\n\t\treturn err;\n\n\tGEM_BUG_ON(i915_vma_offset(vma) != addr);\n\treturn 0;\n}\n\nstatic int\ntiled_blit(struct tiled_blits *t,\n\t   struct blit_buffer *dst, u64 dst_addr,\n\t   struct blit_buffer *src, u64 src_addr)\n{\n\tstruct i915_request *rq;\n\tint err;\n\n\terr = pin_buffer(src->vma, src_addr);\n\tif (err) {\n\t\tpr_err(\"Cannot pin src @ %llx\\n\", src_addr);\n\t\treturn err;\n\t}\n\n\terr = pin_buffer(dst->vma, dst_addr);\n\tif (err) {\n\t\tpr_err(\"Cannot pin dst @ %llx\\n\", dst_addr);\n\t\tgoto err_src;\n\t}\n\n\terr = i915_vma_pin(t->batch, 0, 0, PIN_USER | PIN_HIGH);\n\tif (err) {\n\t\tpr_err(\"cannot pin batch\\n\");\n\t\tgoto err_dst;\n\t}\n\n\terr = prepare_blit(t, dst, src, t->batch->obj);\n\tif (err)\n\t\tgoto err_bb;\n\n\trq = intel_context_create_request(t->ce);\n\tif (IS_ERR(rq)) {\n\t\terr = PTR_ERR(rq);\n\t\tgoto err_bb;\n\t}\n\n\terr = igt_vma_move_to_active_unlocked(t->batch, rq, 0);\n\tif (!err)\n\t\terr = igt_vma_move_to_active_unlocked(src->vma, rq, 0);\n\tif (!err)\n\t\terr = igt_vma_move_to_active_unlocked(dst->vma, rq, 0);\n\tif (!err)\n\t\terr = rq->engine->emit_bb_start(rq,\n\t\t\t\t\t\ti915_vma_offset(t->batch),\n\t\t\t\t\t\ti915_vma_size(t->batch),\n\t\t\t\t\t\t0);\n\ti915_request_get(rq);\n\ti915_request_add(rq);\n\tif (i915_request_wait(rq, 0, HZ / 2) < 0)\n\t\terr = -ETIME;\n\ti915_request_put(rq);\n\n\tdst->start_val = src->start_val;\nerr_bb:\n\ti915_vma_unpin(t->batch);\nerr_dst:\n\ti915_vma_unpin(dst->vma);\nerr_src:\n\ti915_vma_unpin(src->vma);\n\treturn err;\n}\n\nstatic struct tiled_blits *\ntiled_blits_create(struct intel_engine_cs *engine, struct rnd_state *prng)\n{\n\tstruct drm_mm_node hole;\n\tstruct tiled_blits *t;\n\tu64 hole_size;\n\tint err;\n\n\tt = kzalloc(sizeof(*t), GFP_KERNEL);\n\tif (!t)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tt->ce = intel_context_create(engine);\n\tif (IS_ERR(t->ce)) {\n\t\terr = PTR_ERR(t->ce);\n\t\tgoto err_free;\n\t}\n\n\tt->align = i915_vm_min_alignment(t->ce->vm, INTEL_MEMORY_LOCAL);\n\tt->align = max(t->align,\n\t\t       i915_vm_min_alignment(t->ce->vm, INTEL_MEMORY_SYSTEM));\n\n\thole_size = 2 * round_up(WIDTH * HEIGHT * 4, t->align);\n\thole_size *= 2;  \n\thole_size += 2 * t->align;  \n\n\tmutex_lock(&t->ce->vm->mutex);\n\tmemset(&hole, 0, sizeof(hole));\n\terr = drm_mm_insert_node_in_range(&t->ce->vm->mm, &hole,\n\t\t\t\t\t  hole_size, t->align,\n\t\t\t\t\t  I915_COLOR_UNEVICTABLE,\n\t\t\t\t\t  0, U64_MAX,\n\t\t\t\t\t  DRM_MM_INSERT_BEST);\n\tif (!err)\n\t\tdrm_mm_remove_node(&hole);\n\tmutex_unlock(&t->ce->vm->mutex);\n\tif (err) {\n\t\terr = -ENODEV;\n\t\tgoto err_put;\n\t}\n\n\tt->hole = hole.start + t->align;\n\tpr_info(\"Using hole at %llx\\n\", t->hole);\n\n\terr = tiled_blits_create_buffers(t, WIDTH, HEIGHT, prng);\n\tif (err)\n\t\tgoto err_put;\n\n\treturn t;\n\nerr_put:\n\tintel_context_put(t->ce);\nerr_free:\n\tkfree(t);\n\treturn ERR_PTR(err);\n}\n\nstatic void tiled_blits_destroy(struct tiled_blits *t)\n{\n\ttiled_blits_destroy_buffers(t);\n\n\tintel_context_put(t->ce);\n\tkfree(t);\n}\n\nstatic int tiled_blits_prepare(struct tiled_blits *t,\n\t\t\t       struct rnd_state *prng)\n{\n\tu64 offset = round_up(t->width * t->height * 4, t->align);\n\tu32 *map;\n\tint err;\n\tint i;\n\n\tmap = i915_gem_object_pin_map_unlocked(t->scratch.vma->obj, I915_MAP_WC);\n\tif (IS_ERR(map))\n\t\treturn PTR_ERR(map);\n\n\t \n\tfor (i = 0; i < ARRAY_SIZE(t->buffers); i++) {\n\t\tfill_scratch(t, map, prandom_u32_state(prng));\n\t\tGEM_BUG_ON(verify_buffer(t, &t->scratch, prng));\n\n\t\terr = tiled_blit(t,\n\t\t\t\t &t->buffers[i], t->hole + offset,\n\t\t\t\t &t->scratch, t->hole);\n\t\tif (err == 0)\n\t\t\terr = verify_buffer(t, &t->buffers[i], prng);\n\t\tif (err) {\n\t\t\tpr_err(\"Failed to create buffer %d\\n\", i);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\ti915_gem_object_unpin_map(t->scratch.vma->obj);\n\treturn err;\n}\n\nstatic int tiled_blits_bounce(struct tiled_blits *t, struct rnd_state *prng)\n{\n\tu64 offset = round_up(t->width * t->height * 4, 2 * t->align);\n\tint err;\n\n\t \n\n\terr = tiled_blit(t,\n\t\t\t &t->buffers[1], t->hole + offset / 2,\n\t\t\t &t->buffers[0], t->hole + 2 * offset);\n\tif (err)\n\t\treturn err;\n\n\t \n\tt->buffers[2].tiling = t->buffers[0].tiling;\n\n\t \n\terr = tiled_blit(t,\n\t\t\t &t->buffers[2], t->hole + t->align,\n\t\t\t &t->buffers[1], t->hole + 3 * offset / 2);\n\tif (err)\n\t\treturn err;\n\n\terr = verify_buffer(t, &t->buffers[2], prng);\n\tif (err)\n\t\treturn err;\n\n\treturn 0;\n}\n\nstatic int __igt_client_tiled_blits(struct intel_engine_cs *engine,\n\t\t\t\t    struct rnd_state *prng)\n{\n\tstruct tiled_blits *t;\n\tint err;\n\n\tt = tiled_blits_create(engine, prng);\n\tif (IS_ERR(t))\n\t\treturn PTR_ERR(t);\n\n\terr = tiled_blits_prepare(t, prng);\n\tif (err)\n\t\tgoto out;\n\n\terr = tiled_blits_bounce(t, prng);\n\tif (err)\n\t\tgoto out;\n\nout:\n\ttiled_blits_destroy(t);\n\treturn err;\n}\n\nstatic bool has_bit17_swizzle(int sw)\n{\n\treturn (sw == I915_BIT_6_SWIZZLE_9_10_17 ||\n\t\tsw == I915_BIT_6_SWIZZLE_9_17);\n}\n\nstatic bool bad_swizzling(struct drm_i915_private *i915)\n{\n\tstruct i915_ggtt *ggtt = to_gt(i915)->ggtt;\n\n\tif (i915->gem_quirks & GEM_QUIRK_PIN_SWIZZLED_PAGES)\n\t\treturn true;\n\n\tif (has_bit17_swizzle(ggtt->bit_6_swizzle_x) ||\n\t    has_bit17_swizzle(ggtt->bit_6_swizzle_y))\n\t\treturn true;\n\n\treturn false;\n}\n\nstatic int igt_client_tiled_blits(void *arg)\n{\n\tstruct drm_i915_private *i915 = arg;\n\tI915_RND_STATE(prng);\n\tint inst = 0;\n\n\t \n\tif (GRAPHICS_VER(i915) < 4)\n\t\treturn 0;\n\n\tif (bad_swizzling(i915))  \n\t\treturn 0;\n\n\tdo {\n\t\tstruct intel_engine_cs *engine;\n\t\tint err;\n\n\t\tengine = intel_engine_lookup_user(i915,\n\t\t\t\t\t\t  I915_ENGINE_CLASS_COPY,\n\t\t\t\t\t\t  inst++);\n\t\tif (!engine)\n\t\t\treturn 0;\n\n\t\terr = __igt_client_tiled_blits(engine, &prng);\n\t\tif (err == -ENODEV)\n\t\t\terr = 0;\n\t\tif (err)\n\t\t\treturn err;\n\t} while (1);\n}\n\nint i915_gem_client_blt_live_selftests(struct drm_i915_private *i915)\n{\n\tstatic const struct i915_subtest tests[] = {\n\t\tSUBTEST(igt_client_tiled_blits),\n\t};\n\n\tif (intel_gt_is_wedged(to_gt(i915)))\n\t\treturn 0;\n\n\treturn i915_live_subtests(tests, i915);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}