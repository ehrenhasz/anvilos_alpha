{
  "module_name": "huge_gem_object.c",
  "hash_id": "57f987aae75d89f7accd368dfb4519ab22312f4bcb92766b259d9354ff944464",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/i915/gem/selftests/huge_gem_object.c",
  "human_readable_source": " \n\n#include \"i915_scatterlist.h\"\n\n#include \"huge_gem_object.h\"\n\nstatic void huge_free_pages(struct drm_i915_gem_object *obj,\n\t\t\t    struct sg_table *pages)\n{\n\tunsigned long nreal = obj->scratch / PAGE_SIZE;\n\tstruct sgt_iter sgt_iter;\n\tstruct page *page;\n\n\tfor_each_sgt_page(page, sgt_iter, pages) {\n\t\t__free_page(page);\n\t\tif (!--nreal)\n\t\t\tbreak;\n\t}\n\n\tsg_free_table(pages);\n\tkfree(pages);\n}\n\nstatic int huge_get_pages(struct drm_i915_gem_object *obj)\n{\n#define GFP (GFP_KERNEL | __GFP_NOWARN | __GFP_RETRY_MAYFAIL)\n\tconst unsigned long nreal = obj->scratch / PAGE_SIZE;\n\tunsigned int npages;  \n\tstruct scatterlist *sg, *src, *end;\n\tstruct sg_table *pages;\n\tunsigned long n;\n\n\tif (overflows_type(obj->base.size / PAGE_SIZE, npages))\n\t\treturn -E2BIG;\n\n\tnpages = obj->base.size / PAGE_SIZE;\n\tpages = kmalloc(sizeof(*pages), GFP);\n\tif (!pages)\n\t\treturn -ENOMEM;\n\n\tif (sg_alloc_table(pages, npages, GFP)) {\n\t\tkfree(pages);\n\t\treturn -ENOMEM;\n\t}\n\n\tsg = pages->sgl;\n\tfor (n = 0; n < nreal; n++) {\n\t\tstruct page *page;\n\n\t\tpage = alloc_page(GFP | __GFP_HIGHMEM);\n\t\tif (!page) {\n\t\t\tsg_mark_end(sg);\n\t\t\tgoto err;\n\t\t}\n\n\t\tsg_set_page(sg, page, PAGE_SIZE, 0);\n\t\tsg = __sg_next(sg);\n\t}\n\tif (nreal < npages) {\n\t\tfor (end = sg, src = pages->sgl; sg; sg = __sg_next(sg)) {\n\t\t\tsg_set_page(sg, sg_page(src), PAGE_SIZE, 0);\n\t\t\tsrc = __sg_next(src);\n\t\t\tif (src == end)\n\t\t\t\tsrc = pages->sgl;\n\t\t}\n\t}\n\n\tif (i915_gem_gtt_prepare_pages(obj, pages))\n\t\tgoto err;\n\n\t__i915_gem_object_set_pages(obj, pages);\n\n\treturn 0;\n\nerr:\n\thuge_free_pages(obj, pages);\n\treturn -ENOMEM;\n#undef GFP\n}\n\nstatic void huge_put_pages(struct drm_i915_gem_object *obj,\n\t\t\t   struct sg_table *pages)\n{\n\ti915_gem_gtt_finish_pages(obj, pages);\n\thuge_free_pages(obj, pages);\n\n\tobj->mm.dirty = false;\n}\n\nstatic const struct drm_i915_gem_object_ops huge_ops = {\n\t.name = \"huge-gem\",\n\t.get_pages = huge_get_pages,\n\t.put_pages = huge_put_pages,\n};\n\nstruct drm_i915_gem_object *\nhuge_gem_object(struct drm_i915_private *i915,\n\t\tphys_addr_t phys_size,\n\t\tdma_addr_t dma_size)\n{\n\tstatic struct lock_class_key lock_class;\n\tstruct drm_i915_gem_object *obj;\n\tunsigned int cache_level;\n\n\tGEM_BUG_ON(!phys_size || phys_size > dma_size);\n\tGEM_BUG_ON(!IS_ALIGNED(phys_size, PAGE_SIZE));\n\tGEM_BUG_ON(!IS_ALIGNED(dma_size, I915_GTT_PAGE_SIZE));\n\n\tif (overflows_type(dma_size, obj->base.size))\n\t\treturn ERR_PTR(-E2BIG);\n\n\tobj = i915_gem_object_alloc();\n\tif (!obj)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tdrm_gem_private_object_init(&i915->drm, &obj->base, dma_size);\n\ti915_gem_object_init(obj, &huge_ops, &lock_class, 0);\n\tobj->mem_flags |= I915_BO_FLAG_STRUCT_PAGE;\n\n\tobj->read_domains = I915_GEM_DOMAIN_CPU;\n\tobj->write_domain = I915_GEM_DOMAIN_CPU;\n\tcache_level = HAS_LLC(i915) ? I915_CACHE_LLC : I915_CACHE_NONE;\n\ti915_gem_object_set_cache_coherency(obj, cache_level);\n\tobj->scratch = phys_size;\n\n\treturn obj;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}