{
  "module_name": "i915_gem_dmabuf.c",
  "hash_id": "408092424d783edc0cff6e3094cf9b3d9ea576343d0e572ba3c591978f56c582",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/i915/gem/selftests/i915_gem_dmabuf.c",
  "human_readable_source": " \n\n#include \"i915_drv.h\"\n#include \"i915_selftest.h\"\n#include \"gem/i915_gem_context.h\"\n\n#include \"mock_context.h\"\n#include \"mock_dmabuf.h\"\n#include \"igt_gem_utils.h\"\n#include \"selftests/mock_drm.h\"\n#include \"selftests/mock_gem_device.h\"\n\nstatic int igt_dmabuf_export(void *arg)\n{\n\tstruct drm_i915_private *i915 = arg;\n\tstruct drm_i915_gem_object *obj;\n\tstruct dma_buf *dmabuf;\n\n\tobj = i915_gem_object_create_shmem(i915, PAGE_SIZE);\n\tif (IS_ERR(obj))\n\t\treturn PTR_ERR(obj);\n\n\tdmabuf = i915_gem_prime_export(&obj->base, 0);\n\ti915_gem_object_put(obj);\n\tif (IS_ERR(dmabuf)) {\n\t\tpr_err(\"i915_gem_prime_export failed with err=%d\\n\",\n\t\t       (int)PTR_ERR(dmabuf));\n\t\treturn PTR_ERR(dmabuf);\n\t}\n\n\tdma_buf_put(dmabuf);\n\treturn 0;\n}\n\nstatic int igt_dmabuf_import_self(void *arg)\n{\n\tstruct drm_i915_private *i915 = arg;\n\tstruct drm_i915_gem_object *obj, *import_obj;\n\tstruct drm_gem_object *import;\n\tstruct dma_buf *dmabuf;\n\tint err;\n\n\tobj = i915_gem_object_create_shmem(i915, PAGE_SIZE);\n\tif (IS_ERR(obj))\n\t\treturn PTR_ERR(obj);\n\n\tdmabuf = i915_gem_prime_export(&obj->base, 0);\n\tif (IS_ERR(dmabuf)) {\n\t\tpr_err(\"i915_gem_prime_export failed with err=%d\\n\",\n\t\t       (int)PTR_ERR(dmabuf));\n\t\terr = PTR_ERR(dmabuf);\n\t\tgoto out;\n\t}\n\n\timport = i915_gem_prime_import(&i915->drm, dmabuf);\n\tif (IS_ERR(import)) {\n\t\tpr_err(\"i915_gem_prime_import failed with err=%d\\n\",\n\t\t       (int)PTR_ERR(import));\n\t\terr = PTR_ERR(import);\n\t\tgoto out_dmabuf;\n\t}\n\timport_obj = to_intel_bo(import);\n\n\tif (import != &obj->base) {\n\t\tpr_err(\"i915_gem_prime_import created a new object!\\n\");\n\t\terr = -EINVAL;\n\t\tgoto out_import;\n\t}\n\n\ti915_gem_object_lock(import_obj, NULL);\n\terr = __i915_gem_object_get_pages(import_obj);\n\ti915_gem_object_unlock(import_obj);\n\tif (err) {\n\t\tpr_err(\"Same object dma-buf get_pages failed!\\n\");\n\t\tgoto out_import;\n\t}\n\n\terr = 0;\nout_import:\n\ti915_gem_object_put(import_obj);\nout_dmabuf:\n\tdma_buf_put(dmabuf);\nout:\n\ti915_gem_object_put(obj);\n\treturn err;\n}\n\nstatic int igt_dmabuf_import_same_driver_lmem(void *arg)\n{\n\tstruct drm_i915_private *i915 = arg;\n\tstruct intel_memory_region *lmem = i915->mm.regions[INTEL_REGION_LMEM_0];\n\tstruct drm_i915_gem_object *obj;\n\tstruct drm_gem_object *import;\n\tstruct dma_buf *dmabuf;\n\tint err;\n\n\tif (!lmem)\n\t\treturn 0;\n\n\tforce_different_devices = true;\n\n\tobj = __i915_gem_object_create_user(i915, PAGE_SIZE, &lmem, 1);\n\tif (IS_ERR(obj)) {\n\t\tpr_err(\"__i915_gem_object_create_user failed with err=%ld\\n\",\n\t\t       PTR_ERR(obj));\n\t\terr = PTR_ERR(obj);\n\t\tgoto out_ret;\n\t}\n\n\tdmabuf = i915_gem_prime_export(&obj->base, 0);\n\tif (IS_ERR(dmabuf)) {\n\t\tpr_err(\"i915_gem_prime_export failed with err=%ld\\n\",\n\t\t       PTR_ERR(dmabuf));\n\t\terr = PTR_ERR(dmabuf);\n\t\tgoto out;\n\t}\n\n\t \n\timport = i915_gem_prime_import(&i915->drm, dmabuf);\n\tif (!IS_ERR(import)) {\n\t\tdrm_gem_object_put(import);\n\t\tpr_err(\"i915_gem_prime_import succeeded when it shouldn't have\\n\");\n\t\terr = -EINVAL;\n\t} else if (PTR_ERR(import) != -EOPNOTSUPP) {\n\t\tpr_err(\"i915_gem_prime_import failed with the wrong err=%ld\\n\",\n\t\t       PTR_ERR(import));\n\t\terr = PTR_ERR(import);\n\t} else {\n\t\terr = 0;\n\t}\n\n\tdma_buf_put(dmabuf);\nout:\n\ti915_gem_object_put(obj);\nout_ret:\n\tforce_different_devices = false;\n\treturn err;\n}\n\nstatic int verify_access(struct drm_i915_private *i915,\n\t\t\t struct drm_i915_gem_object *native_obj,\n\t\t\t struct drm_i915_gem_object *import_obj)\n{\n\tstruct i915_gem_engines_iter it;\n\tstruct i915_gem_context *ctx;\n\tstruct intel_context *ce;\n\tstruct i915_vma *vma;\n\tstruct file *file;\n\tu32 *vaddr;\n\tint err = 0, i;\n\n\tfile = mock_file(i915);\n\tif (IS_ERR(file))\n\t\treturn PTR_ERR(file);\n\n\tctx = live_context(i915, file);\n\tif (IS_ERR(ctx)) {\n\t\terr = PTR_ERR(ctx);\n\t\tgoto out_file;\n\t}\n\n\tfor_each_gem_engine(ce, i915_gem_context_lock_engines(ctx), it) {\n\t\tif (intel_engine_can_store_dword(ce->engine))\n\t\t\tbreak;\n\t}\n\ti915_gem_context_unlock_engines(ctx);\n\tif (!ce)\n\t\tgoto out_file;\n\n\tvma = i915_vma_instance(import_obj, ce->vm, NULL);\n\tif (IS_ERR(vma)) {\n\t\terr = PTR_ERR(vma);\n\t\tgoto out_file;\n\t}\n\n\terr = i915_vma_pin(vma, 0, 0, PIN_USER);\n\tif (err)\n\t\tgoto out_file;\n\n\terr = igt_gpu_fill_dw(ce, vma, 0,\n\t\t\t      vma->size >> PAGE_SHIFT, 0xdeadbeaf);\n\ti915_vma_unpin(vma);\n\tif (err)\n\t\tgoto out_file;\n\n\terr = i915_gem_object_wait(import_obj, 0, MAX_SCHEDULE_TIMEOUT);\n\tif (err)\n\t\tgoto out_file;\n\n\tvaddr = i915_gem_object_pin_map_unlocked(native_obj, I915_MAP_WB);\n\tif (IS_ERR(vaddr)) {\n\t\terr = PTR_ERR(vaddr);\n\t\tgoto out_file;\n\t}\n\n\tfor (i = 0; i < native_obj->base.size / sizeof(u32); i += PAGE_SIZE / sizeof(u32)) {\n\t\tif (vaddr[i] != 0xdeadbeaf) {\n\t\t\tpr_err(\"Data mismatch [%d]=%u\\n\", i, vaddr[i]);\n\t\t\terr = -EINVAL;\n\t\t\tgoto out_file;\n\t\t}\n\t}\n\nout_file:\n\tfput(file);\n\treturn err;\n}\n\nstatic int igt_dmabuf_import_same_driver(struct drm_i915_private *i915,\n\t\t\t\t\t struct intel_memory_region **regions,\n\t\t\t\t\t unsigned int num_regions)\n{\n\tstruct drm_i915_gem_object *obj, *import_obj;\n\tstruct drm_gem_object *import;\n\tstruct dma_buf *dmabuf;\n\tstruct dma_buf_attachment *import_attach;\n\tstruct sg_table *st;\n\tlong timeout;\n\tint err;\n\n\tforce_different_devices = true;\n\n\tobj = __i915_gem_object_create_user(i915, SZ_8M,\n\t\t\t\t\t    regions, num_regions);\n\tif (IS_ERR(obj)) {\n\t\tpr_err(\"__i915_gem_object_create_user failed with err=%ld\\n\",\n\t\t       PTR_ERR(obj));\n\t\terr = PTR_ERR(obj);\n\t\tgoto out_ret;\n\t}\n\n\tdmabuf = i915_gem_prime_export(&obj->base, 0);\n\tif (IS_ERR(dmabuf)) {\n\t\tpr_err(\"i915_gem_prime_export failed with err=%ld\\n\",\n\t\t       PTR_ERR(dmabuf));\n\t\terr = PTR_ERR(dmabuf);\n\t\tgoto out;\n\t}\n\n\timport = i915_gem_prime_import(&i915->drm, dmabuf);\n\tif (IS_ERR(import)) {\n\t\tpr_err(\"i915_gem_prime_import failed with err=%ld\\n\",\n\t\t       PTR_ERR(import));\n\t\terr = PTR_ERR(import);\n\t\tgoto out_dmabuf;\n\t}\n\timport_obj = to_intel_bo(import);\n\n\tif (import == &obj->base) {\n\t\tpr_err(\"i915_gem_prime_import reused gem object!\\n\");\n\t\terr = -EINVAL;\n\t\tgoto out_import;\n\t}\n\n\ti915_gem_object_lock(import_obj, NULL);\n\terr = __i915_gem_object_get_pages(import_obj);\n\tif (err) {\n\t\tpr_err(\"Different objects dma-buf get_pages failed!\\n\");\n\t\ti915_gem_object_unlock(import_obj);\n\t\tgoto out_import;\n\t}\n\n\t \n\tif (obj->mm.region != i915->mm.regions[INTEL_REGION_SMEM]) {\n\t\tpr_err(\"Exported dma-buf is not in system memory\\n\");\n\t\terr = -EINVAL;\n\t}\n\n\ti915_gem_object_unlock(import_obj);\n\n\terr = verify_access(i915, obj, import_obj);\n\tif (err)\n\t\tgoto out_import;\n\n\t \n\timport_attach = dma_buf_attach(dmabuf, obj->base.dev->dev);\n\tif (IS_ERR(import_attach)) {\n\t\terr = PTR_ERR(import_attach);\n\t\tgoto out_import;\n\t}\n\n\tst = dma_buf_map_attachment_unlocked(import_attach, DMA_BIDIRECTIONAL);\n\tif (IS_ERR(st)) {\n\t\terr = PTR_ERR(st);\n\t\tgoto out_detach;\n\t}\n\n\ttimeout = dma_resv_wait_timeout(dmabuf->resv, DMA_RESV_USAGE_WRITE,\n\t\t\t\t\ttrue, 5 * HZ);\n\tif (!timeout) {\n\t\tpr_err(\"dmabuf wait for exclusive fence timed out.\\n\");\n\t\ttimeout = -ETIME;\n\t}\n\terr = timeout > 0 ? 0 : timeout;\n\tdma_buf_unmap_attachment_unlocked(import_attach, st, DMA_BIDIRECTIONAL);\nout_detach:\n\tdma_buf_detach(dmabuf, import_attach);\nout_import:\n\ti915_gem_object_put(import_obj);\nout_dmabuf:\n\tdma_buf_put(dmabuf);\nout:\n\ti915_gem_object_put(obj);\nout_ret:\n\tforce_different_devices = false;\n\treturn err;\n}\n\nstatic int igt_dmabuf_import_same_driver_smem(void *arg)\n{\n\tstruct drm_i915_private *i915 = arg;\n\tstruct intel_memory_region *smem = i915->mm.regions[INTEL_REGION_SMEM];\n\n\treturn igt_dmabuf_import_same_driver(i915, &smem, 1);\n}\n\nstatic int igt_dmabuf_import_same_driver_lmem_smem(void *arg)\n{\n\tstruct drm_i915_private *i915 = arg;\n\tstruct intel_memory_region *regions[2];\n\n\tif (!i915->mm.regions[INTEL_REGION_LMEM_0])\n\t\treturn 0;\n\n\tregions[0] = i915->mm.regions[INTEL_REGION_LMEM_0];\n\tregions[1] = i915->mm.regions[INTEL_REGION_SMEM];\n\treturn igt_dmabuf_import_same_driver(i915, regions, 2);\n}\n\nstatic int igt_dmabuf_import(void *arg)\n{\n\tstruct drm_i915_private *i915 = arg;\n\tstruct drm_i915_gem_object *obj;\n\tstruct dma_buf *dmabuf;\n\tvoid *obj_map, *dma_map;\n\tstruct iosys_map map;\n\tu32 pattern[] = { 0, 0xaa, 0xcc, 0x55, 0xff };\n\tint err, i;\n\n\tdmabuf = mock_dmabuf(1);\n\tif (IS_ERR(dmabuf))\n\t\treturn PTR_ERR(dmabuf);\n\n\tobj = to_intel_bo(i915_gem_prime_import(&i915->drm, dmabuf));\n\tif (IS_ERR(obj)) {\n\t\tpr_err(\"i915_gem_prime_import failed with err=%d\\n\",\n\t\t       (int)PTR_ERR(obj));\n\t\terr = PTR_ERR(obj);\n\t\tgoto out_dmabuf;\n\t}\n\n\tif (obj->base.dev != &i915->drm) {\n\t\tpr_err(\"i915_gem_prime_import created a non-i915 object!\\n\");\n\t\terr = -EINVAL;\n\t\tgoto out_obj;\n\t}\n\n\tif (obj->base.size != PAGE_SIZE) {\n\t\tpr_err(\"i915_gem_prime_import is wrong size found %lld, expected %ld\\n\",\n\t\t       (long long)obj->base.size, PAGE_SIZE);\n\t\terr = -EINVAL;\n\t\tgoto out_obj;\n\t}\n\n\terr = dma_buf_vmap_unlocked(dmabuf, &map);\n\tdma_map = err ? NULL : map.vaddr;\n\tif (!dma_map) {\n\t\tpr_err(\"dma_buf_vmap failed\\n\");\n\t\terr = -ENOMEM;\n\t\tgoto out_obj;\n\t}\n\n\tif (0) {  \n\t\tobj_map = i915_gem_object_pin_map(obj, I915_MAP_WB);\n\t\tif (IS_ERR(obj_map)) {\n\t\t\terr = PTR_ERR(obj_map);\n\t\t\tpr_err(\"i915_gem_object_pin_map failed with err=%d\\n\", err);\n\t\t\tgoto out_dma_map;\n\t\t}\n\n\t\tfor (i = 0; i < ARRAY_SIZE(pattern); i++) {\n\t\t\tmemset(dma_map, pattern[i], PAGE_SIZE);\n\t\t\tif (memchr_inv(obj_map, pattern[i], PAGE_SIZE)) {\n\t\t\t\terr = -EINVAL;\n\t\t\t\tpr_err(\"imported vmap not all set to %x!\\n\", pattern[i]);\n\t\t\t\ti915_gem_object_unpin_map(obj);\n\t\t\t\tgoto out_dma_map;\n\t\t\t}\n\t\t}\n\n\t\tfor (i = 0; i < ARRAY_SIZE(pattern); i++) {\n\t\t\tmemset(obj_map, pattern[i], PAGE_SIZE);\n\t\t\tif (memchr_inv(dma_map, pattern[i], PAGE_SIZE)) {\n\t\t\t\terr = -EINVAL;\n\t\t\t\tpr_err(\"exported vmap not all set to %x!\\n\", pattern[i]);\n\t\t\t\ti915_gem_object_unpin_map(obj);\n\t\t\t\tgoto out_dma_map;\n\t\t\t}\n\t\t}\n\n\t\ti915_gem_object_unpin_map(obj);\n\t}\n\n\terr = 0;\nout_dma_map:\n\tdma_buf_vunmap_unlocked(dmabuf, &map);\nout_obj:\n\ti915_gem_object_put(obj);\nout_dmabuf:\n\tdma_buf_put(dmabuf);\n\treturn err;\n}\n\nstatic int igt_dmabuf_import_ownership(void *arg)\n{\n\tstruct drm_i915_private *i915 = arg;\n\tstruct drm_i915_gem_object *obj;\n\tstruct dma_buf *dmabuf;\n\tstruct iosys_map map;\n\tvoid *ptr;\n\tint err;\n\n\tdmabuf = mock_dmabuf(1);\n\tif (IS_ERR(dmabuf))\n\t\treturn PTR_ERR(dmabuf);\n\n\terr = dma_buf_vmap_unlocked(dmabuf, &map);\n\tptr = err ? NULL : map.vaddr;\n\tif (!ptr) {\n\t\tpr_err(\"dma_buf_vmap failed\\n\");\n\t\terr = -ENOMEM;\n\t\tgoto err_dmabuf;\n\t}\n\n\tmemset(ptr, 0xc5, PAGE_SIZE);\n\tdma_buf_vunmap_unlocked(dmabuf, &map);\n\n\tobj = to_intel_bo(i915_gem_prime_import(&i915->drm, dmabuf));\n\tif (IS_ERR(obj)) {\n\t\tpr_err(\"i915_gem_prime_import failed with err=%d\\n\",\n\t\t       (int)PTR_ERR(obj));\n\t\terr = PTR_ERR(obj);\n\t\tgoto err_dmabuf;\n\t}\n\n\tdma_buf_put(dmabuf);\n\n\terr = i915_gem_object_pin_pages_unlocked(obj);\n\tif (err) {\n\t\tpr_err(\"i915_gem_object_pin_pages failed with err=%d\\n\", err);\n\t\tgoto out_obj;\n\t}\n\n\terr = 0;\n\ti915_gem_object_unpin_pages(obj);\nout_obj:\n\ti915_gem_object_put(obj);\n\treturn err;\n\nerr_dmabuf:\n\tdma_buf_put(dmabuf);\n\treturn err;\n}\n\nstatic int igt_dmabuf_export_vmap(void *arg)\n{\n\tstruct drm_i915_private *i915 = arg;\n\tstruct drm_i915_gem_object *obj;\n\tstruct dma_buf *dmabuf;\n\tstruct iosys_map map;\n\tvoid *ptr;\n\tint err;\n\n\tobj = i915_gem_object_create_shmem(i915, PAGE_SIZE);\n\tif (IS_ERR(obj))\n\t\treturn PTR_ERR(obj);\n\n\tdmabuf = i915_gem_prime_export(&obj->base, 0);\n\tif (IS_ERR(dmabuf)) {\n\t\tpr_err(\"i915_gem_prime_export failed with err=%d\\n\",\n\t\t       (int)PTR_ERR(dmabuf));\n\t\terr = PTR_ERR(dmabuf);\n\t\tgoto err_obj;\n\t}\n\ti915_gem_object_put(obj);\n\n\terr = dma_buf_vmap_unlocked(dmabuf, &map);\n\tptr = err ? NULL : map.vaddr;\n\tif (!ptr) {\n\t\tpr_err(\"dma_buf_vmap failed\\n\");\n\t\terr = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tif (memchr_inv(ptr, 0, dmabuf->size)) {\n\t\tpr_err(\"Exported object not initialiased to zero!\\n\");\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tmemset(ptr, 0xc5, dmabuf->size);\n\n\terr = 0;\n\tdma_buf_vunmap_unlocked(dmabuf, &map);\nout:\n\tdma_buf_put(dmabuf);\n\treturn err;\n\nerr_obj:\n\ti915_gem_object_put(obj);\n\treturn err;\n}\n\nint i915_gem_dmabuf_mock_selftests(void)\n{\n\tstatic const struct i915_subtest tests[] = {\n\t\tSUBTEST(igt_dmabuf_export),\n\t\tSUBTEST(igt_dmabuf_import_self),\n\t\tSUBTEST(igt_dmabuf_import),\n\t\tSUBTEST(igt_dmabuf_import_ownership),\n\t\tSUBTEST(igt_dmabuf_export_vmap),\n\t};\n\tstruct drm_i915_private *i915;\n\tint err;\n\n\ti915 = mock_gem_device();\n\tif (!i915)\n\t\treturn -ENOMEM;\n\n\terr = i915_subtests(tests, i915);\n\n\tmock_destroy_device(i915);\n\treturn err;\n}\n\nint i915_gem_dmabuf_live_selftests(struct drm_i915_private *i915)\n{\n\tstatic const struct i915_subtest tests[] = {\n\t\tSUBTEST(igt_dmabuf_export),\n\t\tSUBTEST(igt_dmabuf_import_same_driver_lmem),\n\t\tSUBTEST(igt_dmabuf_import_same_driver_smem),\n\t\tSUBTEST(igt_dmabuf_import_same_driver_lmem_smem),\n\t};\n\n\treturn i915_live_subtests(tests, i915);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}