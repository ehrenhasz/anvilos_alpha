{
  "module_name": "i915_gem_coherency.c",
  "hash_id": "687a6854074a2206ef0a89419e8f90e908d70f01ad6825352e6933fd4dfbc7ce",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/i915/gem/selftests/i915_gem_coherency.c",
  "human_readable_source": " \n\n#include <linux/prime_numbers.h>\n\n#include \"gt/intel_engine_pm.h\"\n#include \"gt/intel_gpu_commands.h\"\n#include \"gt/intel_gt.h\"\n#include \"gt/intel_gt_pm.h\"\n#include \"gt/intel_ring.h\"\n\n#include \"i915_selftest.h\"\n#include \"selftests/i915_random.h\"\n\nstruct context {\n\tstruct drm_i915_gem_object *obj;\n\tstruct intel_engine_cs *engine;\n};\n\nstatic int cpu_set(struct context *ctx, unsigned long offset, u32 v)\n{\n\tunsigned int needs_clflush;\n\tstruct page *page;\n\tvoid *map;\n\tu32 *cpu;\n\tint err;\n\n\ti915_gem_object_lock(ctx->obj, NULL);\n\terr = i915_gem_object_prepare_write(ctx->obj, &needs_clflush);\n\tif (err)\n\t\tgoto out;\n\n\tpage = i915_gem_object_get_page(ctx->obj, offset >> PAGE_SHIFT);\n\tmap = kmap_atomic(page);\n\tcpu = map + offset_in_page(offset);\n\n\tif (needs_clflush & CLFLUSH_BEFORE)\n\t\tdrm_clflush_virt_range(cpu, sizeof(*cpu));\n\n\t*cpu = v;\n\n\tif (needs_clflush & CLFLUSH_AFTER)\n\t\tdrm_clflush_virt_range(cpu, sizeof(*cpu));\n\n\tkunmap_atomic(map);\n\ti915_gem_object_finish_access(ctx->obj);\n\nout:\n\ti915_gem_object_unlock(ctx->obj);\n\treturn err;\n}\n\nstatic int cpu_get(struct context *ctx, unsigned long offset, u32 *v)\n{\n\tunsigned int needs_clflush;\n\tstruct page *page;\n\tvoid *map;\n\tu32 *cpu;\n\tint err;\n\n\ti915_gem_object_lock(ctx->obj, NULL);\n\terr = i915_gem_object_prepare_read(ctx->obj, &needs_clflush);\n\tif (err)\n\t\tgoto out;\n\n\tpage = i915_gem_object_get_page(ctx->obj, offset >> PAGE_SHIFT);\n\tmap = kmap_atomic(page);\n\tcpu = map + offset_in_page(offset);\n\n\tif (needs_clflush & CLFLUSH_BEFORE)\n\t\tdrm_clflush_virt_range(cpu, sizeof(*cpu));\n\n\t*v = *cpu;\n\n\tkunmap_atomic(map);\n\ti915_gem_object_finish_access(ctx->obj);\n\nout:\n\ti915_gem_object_unlock(ctx->obj);\n\treturn err;\n}\n\nstatic int gtt_set(struct context *ctx, unsigned long offset, u32 v)\n{\n\tstruct i915_vma *vma;\n\tu32 __iomem *map;\n\tint err = 0;\n\n\ti915_gem_object_lock(ctx->obj, NULL);\n\terr = i915_gem_object_set_to_gtt_domain(ctx->obj, true);\n\ti915_gem_object_unlock(ctx->obj);\n\tif (err)\n\t\treturn err;\n\n\tvma = i915_gem_object_ggtt_pin(ctx->obj, NULL, 0, 0, PIN_MAPPABLE);\n\tif (IS_ERR(vma))\n\t\treturn PTR_ERR(vma);\n\n\tintel_gt_pm_get(vma->vm->gt);\n\n\tmap = i915_vma_pin_iomap(vma);\n\ti915_vma_unpin(vma);\n\tif (IS_ERR(map)) {\n\t\terr = PTR_ERR(map);\n\t\tgoto out_rpm;\n\t}\n\n\tiowrite32(v, &map[offset / sizeof(*map)]);\n\ti915_vma_unpin_iomap(vma);\n\nout_rpm:\n\tintel_gt_pm_put(vma->vm->gt);\n\treturn err;\n}\n\nstatic int gtt_get(struct context *ctx, unsigned long offset, u32 *v)\n{\n\tstruct i915_vma *vma;\n\tu32 __iomem *map;\n\tint err = 0;\n\n\ti915_gem_object_lock(ctx->obj, NULL);\n\terr = i915_gem_object_set_to_gtt_domain(ctx->obj, false);\n\ti915_gem_object_unlock(ctx->obj);\n\tif (err)\n\t\treturn err;\n\n\tvma = i915_gem_object_ggtt_pin(ctx->obj, NULL, 0, 0, PIN_MAPPABLE);\n\tif (IS_ERR(vma))\n\t\treturn PTR_ERR(vma);\n\n\tintel_gt_pm_get(vma->vm->gt);\n\n\tmap = i915_vma_pin_iomap(vma);\n\ti915_vma_unpin(vma);\n\tif (IS_ERR(map)) {\n\t\terr = PTR_ERR(map);\n\t\tgoto out_rpm;\n\t}\n\n\t*v = ioread32(&map[offset / sizeof(*map)]);\n\ti915_vma_unpin_iomap(vma);\n\nout_rpm:\n\tintel_gt_pm_put(vma->vm->gt);\n\treturn err;\n}\n\nstatic int wc_set(struct context *ctx, unsigned long offset, u32 v)\n{\n\tu32 *map;\n\tint err;\n\n\ti915_gem_object_lock(ctx->obj, NULL);\n\terr = i915_gem_object_set_to_wc_domain(ctx->obj, true);\n\ti915_gem_object_unlock(ctx->obj);\n\tif (err)\n\t\treturn err;\n\n\tmap = i915_gem_object_pin_map_unlocked(ctx->obj, I915_MAP_WC);\n\tif (IS_ERR(map))\n\t\treturn PTR_ERR(map);\n\n\tmap[offset / sizeof(*map)] = v;\n\n\t__i915_gem_object_flush_map(ctx->obj, offset, sizeof(*map));\n\ti915_gem_object_unpin_map(ctx->obj);\n\n\treturn 0;\n}\n\nstatic int wc_get(struct context *ctx, unsigned long offset, u32 *v)\n{\n\tu32 *map;\n\tint err;\n\n\ti915_gem_object_lock(ctx->obj, NULL);\n\terr = i915_gem_object_set_to_wc_domain(ctx->obj, false);\n\ti915_gem_object_unlock(ctx->obj);\n\tif (err)\n\t\treturn err;\n\n\tmap = i915_gem_object_pin_map_unlocked(ctx->obj, I915_MAP_WC);\n\tif (IS_ERR(map))\n\t\treturn PTR_ERR(map);\n\n\t*v = map[offset / sizeof(*map)];\n\ti915_gem_object_unpin_map(ctx->obj);\n\n\treturn 0;\n}\n\nstatic int gpu_set(struct context *ctx, unsigned long offset, u32 v)\n{\n\tstruct i915_request *rq;\n\tstruct i915_vma *vma;\n\tu32 *cs;\n\tint err;\n\n\tvma = i915_gem_object_ggtt_pin(ctx->obj, NULL, 0, 0, 0);\n\tif (IS_ERR(vma))\n\t\treturn PTR_ERR(vma);\n\n\ti915_gem_object_lock(ctx->obj, NULL);\n\terr = i915_gem_object_set_to_gtt_domain(ctx->obj, true);\n\tif (err)\n\t\tgoto out_unlock;\n\n\trq = intel_engine_create_kernel_request(ctx->engine);\n\tif (IS_ERR(rq)) {\n\t\terr = PTR_ERR(rq);\n\t\tgoto out_unpin;\n\t}\n\n\tcs = intel_ring_begin(rq, 4);\n\tif (IS_ERR(cs)) {\n\t\terr = PTR_ERR(cs);\n\t\tgoto out_rq;\n\t}\n\n\tif (GRAPHICS_VER(ctx->engine->i915) >= 8) {\n\t\t*cs++ = MI_STORE_DWORD_IMM_GEN4 | MI_USE_GGTT;\n\t\t*cs++ = lower_32_bits(i915_ggtt_offset(vma) + offset);\n\t\t*cs++ = upper_32_bits(i915_ggtt_offset(vma) + offset);\n\t\t*cs++ = v;\n\t} else if (GRAPHICS_VER(ctx->engine->i915) >= 4) {\n\t\t*cs++ = MI_STORE_DWORD_IMM_GEN4 | MI_USE_GGTT;\n\t\t*cs++ = 0;\n\t\t*cs++ = i915_ggtt_offset(vma) + offset;\n\t\t*cs++ = v;\n\t} else {\n\t\t*cs++ = MI_STORE_DWORD_IMM | MI_MEM_VIRTUAL;\n\t\t*cs++ = i915_ggtt_offset(vma) + offset;\n\t\t*cs++ = v;\n\t\t*cs++ = MI_NOOP;\n\t}\n\tintel_ring_advance(rq, cs);\n\n\terr = i915_vma_move_to_active(vma, rq, EXEC_OBJECT_WRITE);\n\nout_rq:\n\ti915_request_add(rq);\nout_unpin:\n\ti915_vma_unpin(vma);\nout_unlock:\n\ti915_gem_object_unlock(ctx->obj);\n\n\treturn err;\n}\n\nstatic bool always_valid(struct context *ctx)\n{\n\treturn true;\n}\n\nstatic bool needs_fence_registers(struct context *ctx)\n{\n\tstruct intel_gt *gt = ctx->engine->gt;\n\n\tif (intel_gt_is_wedged(gt))\n\t\treturn false;\n\n\treturn gt->ggtt->num_fences;\n}\n\nstatic bool needs_mi_store_dword(struct context *ctx)\n{\n\tif (intel_gt_is_wedged(ctx->engine->gt))\n\t\treturn false;\n\n\treturn intel_engine_can_store_dword(ctx->engine);\n}\n\nstatic const struct igt_coherency_mode {\n\tconst char *name;\n\tint (*set)(struct context *ctx, unsigned long offset, u32 v);\n\tint (*get)(struct context *ctx, unsigned long offset, u32 *v);\n\tbool (*valid)(struct context *ctx);\n} igt_coherency_mode[] = {\n\t{ \"cpu\", cpu_set, cpu_get, always_valid },\n\t{ \"gtt\", gtt_set, gtt_get, needs_fence_registers },\n\t{ \"wc\", wc_set, wc_get, always_valid },\n\t{ \"gpu\", gpu_set, NULL, needs_mi_store_dword },\n\t{ },\n};\n\nstatic struct intel_engine_cs *\nrandom_engine(struct drm_i915_private *i915, struct rnd_state *prng)\n{\n\tstruct intel_engine_cs *engine;\n\tunsigned int count;\n\n\tcount = 0;\n\tfor_each_uabi_engine(engine, i915)\n\t\tcount++;\n\n\tcount = i915_prandom_u32_max_state(count, prng);\n\tfor_each_uabi_engine(engine, i915)\n\t\tif (count-- == 0)\n\t\t\treturn engine;\n\n\treturn NULL;\n}\n\nstatic int igt_gem_coherency(void *arg)\n{\n\tconst unsigned int ncachelines = PAGE_SIZE/64;\n\tstruct drm_i915_private *i915 = arg;\n\tconst struct igt_coherency_mode *read, *write, *over;\n\tunsigned long count, n;\n\tu32 *offsets, *values;\n\tI915_RND_STATE(prng);\n\tstruct context ctx;\n\tint err = 0;\n\n\t \n\n\toffsets = kmalloc_array(ncachelines, 2*sizeof(u32), GFP_KERNEL);\n\tif (!offsets)\n\t\treturn -ENOMEM;\n\tfor (count = 0; count < ncachelines; count++)\n\t\toffsets[count] = count * 64 + 4 * (count % 16);\n\n\tvalues = offsets + ncachelines;\n\n\tctx.engine = random_engine(i915, &prng);\n\tif (!ctx.engine) {\n\t\terr = -ENODEV;\n\t\tgoto out_free;\n\t}\n\tpr_info(\"%s: using %s\\n\", __func__, ctx.engine->name);\n\tintel_engine_pm_get(ctx.engine);\n\n\tfor (over = igt_coherency_mode; over->name; over++) {\n\t\tif (!over->set)\n\t\t\tcontinue;\n\n\t\tif (!over->valid(&ctx))\n\t\t\tcontinue;\n\n\t\tfor (write = igt_coherency_mode; write->name; write++) {\n\t\t\tif (!write->set)\n\t\t\t\tcontinue;\n\n\t\t\tif (!write->valid(&ctx))\n\t\t\t\tcontinue;\n\n\t\t\tfor (read = igt_coherency_mode; read->name; read++) {\n\t\t\t\tif (!read->get)\n\t\t\t\t\tcontinue;\n\n\t\t\t\tif (!read->valid(&ctx))\n\t\t\t\t\tcontinue;\n\n\t\t\t\tfor_each_prime_number_from(count, 1, ncachelines) {\n\t\t\t\t\tctx.obj = i915_gem_object_create_internal(i915, PAGE_SIZE);\n\t\t\t\t\tif (IS_ERR(ctx.obj)) {\n\t\t\t\t\t\terr = PTR_ERR(ctx.obj);\n\t\t\t\t\t\tgoto out_pm;\n\t\t\t\t\t}\n\n\t\t\t\t\ti915_random_reorder(offsets, ncachelines, &prng);\n\t\t\t\t\tfor (n = 0; n < count; n++)\n\t\t\t\t\t\tvalues[n] = prandom_u32_state(&prng);\n\n\t\t\t\t\tfor (n = 0; n < count; n++) {\n\t\t\t\t\t\terr = over->set(&ctx, offsets[n], ~values[n]);\n\t\t\t\t\t\tif (err) {\n\t\t\t\t\t\t\tpr_err(\"Failed to set stale value[%ld/%ld] in object using %s, err=%d\\n\",\n\t\t\t\t\t\t\t       n, count, over->name, err);\n\t\t\t\t\t\t\tgoto put_object;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tfor (n = 0; n < count; n++) {\n\t\t\t\t\t\terr = write->set(&ctx, offsets[n], values[n]);\n\t\t\t\t\t\tif (err) {\n\t\t\t\t\t\t\tpr_err(\"Failed to set value[%ld/%ld] in object using %s, err=%d\\n\",\n\t\t\t\t\t\t\t       n, count, write->name, err);\n\t\t\t\t\t\t\tgoto put_object;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tfor (n = 0; n < count; n++) {\n\t\t\t\t\t\tu32 found;\n\n\t\t\t\t\t\terr = read->get(&ctx, offsets[n], &found);\n\t\t\t\t\t\tif (err) {\n\t\t\t\t\t\t\tpr_err(\"Failed to get value[%ld/%ld] in object using %s, err=%d\\n\",\n\t\t\t\t\t\t\t       n, count, read->name, err);\n\t\t\t\t\t\t\tgoto put_object;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (found != values[n]) {\n\t\t\t\t\t\t\tpr_err(\"Value[%ld/%ld] mismatch, (overwrite with %s) wrote [%s] %x read [%s] %x (inverse %x), at offset %x\\n\",\n\t\t\t\t\t\t\t       n, count, over->name,\n\t\t\t\t\t\t\t       write->name, values[n],\n\t\t\t\t\t\t\t       read->name, found,\n\t\t\t\t\t\t\t       ~values[n], offsets[n]);\n\t\t\t\t\t\t\terr = -EINVAL;\n\t\t\t\t\t\t\tgoto put_object;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\ti915_gem_object_put(ctx.obj);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\nout_pm:\n\tintel_engine_pm_put(ctx.engine);\nout_free:\n\tkfree(offsets);\n\treturn err;\n\nput_object:\n\ti915_gem_object_put(ctx.obj);\n\tgoto out_pm;\n}\n\nint i915_gem_coherency_live_selftests(struct drm_i915_private *i915)\n{\n\tstatic const struct i915_subtest tests[] = {\n\t\tSUBTEST(igt_gem_coherency),\n\t};\n\n\treturn i915_live_subtests(tests, i915);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}