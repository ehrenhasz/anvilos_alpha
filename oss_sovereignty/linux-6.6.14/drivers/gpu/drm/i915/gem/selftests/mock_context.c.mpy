{
  "module_name": "mock_context.c",
  "hash_id": "c49b3c9d4bebe0ad798e6f6aebb08c2433f25e6c8cf7a805e24954ffa961d928",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/i915/gem/selftests/mock_context.c",
  "human_readable_source": " \n\n#include \"i915_file_private.h\"\n#include \"mock_context.h\"\n#include \"selftests/mock_drm.h\"\n#include \"selftests/mock_gtt.h\"\n\nstruct i915_gem_context *\nmock_context(struct drm_i915_private *i915,\n\t     const char *name)\n{\n\tstruct i915_gem_context *ctx;\n\tstruct i915_gem_engines *e;\n\tstruct intel_sseu null_sseu = {};\n\n\tctx = kzalloc(sizeof(*ctx), GFP_KERNEL);\n\tif (!ctx)\n\t\treturn NULL;\n\n\tkref_init(&ctx->ref);\n\tINIT_LIST_HEAD(&ctx->link);\n\tctx->i915 = i915;\n\tINIT_WORK(&ctx->release_work, i915_gem_context_release_work);\n\n\tmutex_init(&ctx->mutex);\n\n\tspin_lock_init(&ctx->stale.lock);\n\tINIT_LIST_HEAD(&ctx->stale.engines);\n\n\ti915_gem_context_set_persistence(ctx);\n\n\tif (name) {\n\t\tstruct i915_ppgtt *ppgtt;\n\n\t\tstrncpy(ctx->name, name, sizeof(ctx->name) - 1);\n\n\t\tppgtt = mock_ppgtt(i915, name);\n\t\tif (!ppgtt)\n\t\t\tgoto err_free;\n\n\t\tctx->vm = &ppgtt->vm;\n\t}\n\n\tmutex_init(&ctx->engines_mutex);\n\te = default_engines(ctx, null_sseu);\n\tif (IS_ERR(e))\n\t\tgoto err_vm;\n\tRCU_INIT_POINTER(ctx->engines, e);\n\n\tINIT_RADIX_TREE(&ctx->handles_vma, GFP_KERNEL);\n\tmutex_init(&ctx->lut_mutex);\n\n\treturn ctx;\n\nerr_vm:\n\tif (ctx->vm)\n\t\ti915_vm_put(ctx->vm);\nerr_free:\n\tkfree(ctx);\n\treturn NULL;\n}\n\nvoid mock_context_close(struct i915_gem_context *ctx)\n{\n\tcontext_close(ctx);\n}\n\nvoid mock_init_contexts(struct drm_i915_private *i915)\n{\n\tinit_contexts(&i915->gem.contexts);\n}\n\nstruct i915_gem_context *\nlive_context(struct drm_i915_private *i915, struct file *file)\n{\n\tstruct drm_i915_file_private *fpriv = to_drm_file(file)->driver_priv;\n\tstruct i915_gem_proto_context *pc;\n\tstruct i915_gem_context *ctx;\n\tint err;\n\tu32 id;\n\n\tpc = proto_context_create(i915, 0);\n\tif (IS_ERR(pc))\n\t\treturn ERR_CAST(pc);\n\n\tctx = i915_gem_create_context(i915, pc);\n\tproto_context_close(i915, pc);\n\tif (IS_ERR(ctx))\n\t\treturn ctx;\n\n\ti915_gem_context_set_no_error_capture(ctx);\n\n\terr = xa_alloc(&fpriv->context_xa, &id, NULL, xa_limit_32b, GFP_KERNEL);\n\tif (err < 0)\n\t\tgoto err_ctx;\n\n\tgem_context_register(ctx, fpriv, id);\n\n\treturn ctx;\n\nerr_ctx:\n\tcontext_close(ctx);\n\treturn ERR_PTR(err);\n}\n\nstruct i915_gem_context *\nlive_context_for_engine(struct intel_engine_cs *engine, struct file *file)\n{\n\tstruct i915_gem_engines *engines;\n\tstruct i915_gem_context *ctx;\n\tstruct intel_sseu null_sseu = {};\n\tstruct intel_context *ce;\n\n\tengines = alloc_engines(1);\n\tif (!engines)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tctx = live_context(engine->i915, file);\n\tif (IS_ERR(ctx)) {\n\t\t__free_engines(engines, 0);\n\t\treturn ctx;\n\t}\n\n\tce = intel_context_create(engine);\n\tif (IS_ERR(ce)) {\n\t\t__free_engines(engines, 0);\n\t\treturn ERR_CAST(ce);\n\t}\n\n\tintel_context_set_gem(ce, ctx, null_sseu);\n\tengines->engines[0] = ce;\n\tengines->num_engines = 1;\n\n\tmutex_lock(&ctx->engines_mutex);\n\ti915_gem_context_set_user_engines(ctx);\n\tengines = rcu_replace_pointer(ctx->engines, engines, 1);\n\tmutex_unlock(&ctx->engines_mutex);\n\n\tengines_idle_release(ctx, engines);\n\n\treturn ctx;\n}\n\nstruct i915_gem_context *\nkernel_context(struct drm_i915_private *i915,\n\t       struct i915_address_space *vm)\n{\n\tstruct i915_gem_context *ctx;\n\tstruct i915_gem_proto_context *pc;\n\n\tpc = proto_context_create(i915, 0);\n\tif (IS_ERR(pc))\n\t\treturn ERR_CAST(pc);\n\n\tif (vm) {\n\t\tif (pc->vm)\n\t\t\ti915_vm_put(pc->vm);\n\t\tpc->vm = i915_vm_get(vm);\n\t}\n\n\tctx = i915_gem_create_context(i915, pc);\n\tproto_context_close(i915, pc);\n\tif (IS_ERR(ctx))\n\t\treturn ctx;\n\n\ti915_gem_context_clear_bannable(ctx);\n\ti915_gem_context_set_persistence(ctx);\n\ti915_gem_context_set_no_error_capture(ctx);\n\n\treturn ctx;\n}\n\nvoid kernel_context_close(struct i915_gem_context *ctx)\n{\n\tcontext_close(ctx);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}