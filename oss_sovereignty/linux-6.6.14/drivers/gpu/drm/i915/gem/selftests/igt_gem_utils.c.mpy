{
  "module_name": "igt_gem_utils.c",
  "hash_id": "0bb91529d6b45151dd5e129b85fc0ab45703585fb42f12851590f217527fe398",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/i915/gem/selftests/igt_gem_utils.c",
  "human_readable_source": " \n\n#include \"igt_gem_utils.h\"\n\n#include \"gem/i915_gem_context.h\"\n#include \"gem/i915_gem_internal.h\"\n#include \"gem/i915_gem_pm.h\"\n#include \"gt/intel_context.h\"\n#include \"gt/intel_gpu_commands.h\"\n#include \"gt/intel_gt.h\"\n#include \"i915_vma.h\"\n#include \"i915_drv.h\"\n\n#include \"i915_request.h\"\n\nstruct i915_request *\nigt_request_alloc(struct i915_gem_context *ctx, struct intel_engine_cs *engine)\n{\n\tstruct intel_context *ce;\n\tstruct i915_request *rq;\n\n\t \n\tce = i915_gem_context_get_engine(ctx, engine->legacy_idx);\n\tif (IS_ERR(ce))\n\t\treturn ERR_CAST(ce);\n\n\trq = intel_context_create_request(ce);\n\tintel_context_put(ce);\n\n\treturn rq;\n}\n\nstruct i915_vma *\nigt_emit_store_dw(struct i915_vma *vma,\n\t\t  u64 offset,\n\t\t  unsigned long count,\n\t\t  u32 val)\n{\n\tstruct drm_i915_gem_object *obj;\n\tconst int ver = GRAPHICS_VER(vma->vm->i915);\n\tunsigned long n, size;\n\tu32 *cmd;\n\tint err;\n\n\tsize = (4 * count + 1) * sizeof(u32);\n\tsize = round_up(size, PAGE_SIZE);\n\tobj = i915_gem_object_create_internal(vma->vm->i915, size);\n\tif (IS_ERR(obj))\n\t\treturn ERR_CAST(obj);\n\n\tcmd = i915_gem_object_pin_map_unlocked(obj, I915_MAP_WC);\n\tif (IS_ERR(cmd)) {\n\t\terr = PTR_ERR(cmd);\n\t\tgoto err;\n\t}\n\n\tGEM_BUG_ON(offset + (count - 1) * PAGE_SIZE > i915_vma_size(vma));\n\toffset += i915_vma_offset(vma);\n\n\tfor (n = 0; n < count; n++) {\n\t\tif (ver >= 8) {\n\t\t\t*cmd++ = MI_STORE_DWORD_IMM_GEN4;\n\t\t\t*cmd++ = lower_32_bits(offset);\n\t\t\t*cmd++ = upper_32_bits(offset);\n\t\t\t*cmd++ = val;\n\t\t} else if (ver >= 4) {\n\t\t\t*cmd++ = MI_STORE_DWORD_IMM_GEN4 |\n\t\t\t\t(ver < 6 ? MI_USE_GGTT : 0);\n\t\t\t*cmd++ = 0;\n\t\t\t*cmd++ = offset;\n\t\t\t*cmd++ = val;\n\t\t} else {\n\t\t\t*cmd++ = MI_STORE_DWORD_IMM | MI_MEM_VIRTUAL;\n\t\t\t*cmd++ = offset;\n\t\t\t*cmd++ = val;\n\t\t}\n\t\toffset += PAGE_SIZE;\n\t}\n\t*cmd = MI_BATCH_BUFFER_END;\n\n\ti915_gem_object_flush_map(obj);\n\ti915_gem_object_unpin_map(obj);\n\n\tintel_gt_chipset_flush(vma->vm->gt);\n\n\tvma = i915_vma_instance(obj, vma->vm, NULL);\n\tif (IS_ERR(vma)) {\n\t\terr = PTR_ERR(vma);\n\t\tgoto err;\n\t}\n\n\terr = i915_vma_pin(vma, 0, 0, PIN_USER);\n\tif (err)\n\t\tgoto err;\n\n\treturn vma;\n\nerr:\n\ti915_gem_object_put(obj);\n\treturn ERR_PTR(err);\n}\n\nint igt_gpu_fill_dw(struct intel_context *ce,\n\t\t    struct i915_vma *vma, u64 offset,\n\t\t    unsigned long count, u32 val)\n{\n\tstruct i915_request *rq;\n\tstruct i915_vma *batch;\n\tunsigned int flags;\n\tint err;\n\n\tGEM_BUG_ON(!intel_engine_can_store_dword(ce->engine));\n\tGEM_BUG_ON(!i915_vma_is_pinned(vma));\n\n\tbatch = igt_emit_store_dw(vma, offset, count, val);\n\tif (IS_ERR(batch))\n\t\treturn PTR_ERR(batch);\n\n\trq = intel_context_create_request(ce);\n\tif (IS_ERR(rq)) {\n\t\terr = PTR_ERR(rq);\n\t\tgoto err_batch;\n\t}\n\n\terr = igt_vma_move_to_active_unlocked(batch, rq, 0);\n\tif (err)\n\t\tgoto skip_request;\n\n\terr = igt_vma_move_to_active_unlocked(vma, rq, EXEC_OBJECT_WRITE);\n\tif (err)\n\t\tgoto skip_request;\n\n\tflags = 0;\n\tif (GRAPHICS_VER(ce->vm->i915) <= 5)\n\t\tflags |= I915_DISPATCH_SECURE;\n\n\terr = rq->engine->emit_bb_start(rq,\n\t\t\t\t\ti915_vma_offset(batch),\n\t\t\t\t\ti915_vma_size(batch),\n\t\t\t\t\tflags);\n\nskip_request:\n\tif (err)\n\t\ti915_request_set_error_once(rq, err);\n\ti915_request_add(rq);\nerr_batch:\n\ti915_vma_unpin_and_release(&batch, 0);\n\treturn err;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}