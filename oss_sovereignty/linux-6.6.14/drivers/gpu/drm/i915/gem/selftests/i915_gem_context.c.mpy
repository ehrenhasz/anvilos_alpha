{
  "module_name": "i915_gem_context.c",
  "hash_id": "9b8070e897eacde0a1742b5531bcca2dfa6f2ce798dcd8b368a52c77bc4f4262",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/i915/gem/selftests/i915_gem_context.c",
  "human_readable_source": " \n\n#include <linux/prime_numbers.h>\n#include <linux/string_helpers.h>\n\n#include \"gem/i915_gem_internal.h\"\n#include \"gem/i915_gem_pm.h\"\n#include \"gt/intel_engine_pm.h\"\n#include \"gt/intel_engine_regs.h\"\n#include \"gt/intel_gt.h\"\n#include \"gt/intel_gt_requests.h\"\n#include \"gt/intel_reset.h\"\n#include \"i915_selftest.h\"\n\n#include \"gem/selftests/igt_gem_utils.h\"\n#include \"selftests/i915_random.h\"\n#include \"selftests/igt_flush_test.h\"\n#include \"selftests/igt_live_test.h\"\n#include \"selftests/igt_reset.h\"\n#include \"selftests/igt_spinner.h\"\n#include \"selftests/mock_drm.h\"\n#include \"selftests/mock_gem_device.h\"\n\n#include \"huge_gem_object.h\"\n#include \"igt_gem_utils.h\"\n\n#define DW_PER_PAGE (PAGE_SIZE / sizeof(u32))\n\nstatic int live_nop_switch(void *arg)\n{\n\tconst unsigned int nctx = 1024;\n\tstruct drm_i915_private *i915 = arg;\n\tstruct intel_engine_cs *engine;\n\tstruct i915_gem_context **ctx;\n\tstruct igt_live_test t;\n\tstruct file *file;\n\tunsigned long n;\n\tint err = -ENODEV;\n\n\t \n\n\tif (!DRIVER_CAPS(i915)->has_logical_contexts)\n\t\treturn 0;\n\n\tfile = mock_file(i915);\n\tif (IS_ERR(file))\n\t\treturn PTR_ERR(file);\n\n\tctx = kcalloc(nctx, sizeof(*ctx), GFP_KERNEL);\n\tif (!ctx) {\n\t\terr = -ENOMEM;\n\t\tgoto out_file;\n\t}\n\n\tfor (n = 0; n < nctx; n++) {\n\t\tctx[n] = live_context(i915, file);\n\t\tif (IS_ERR(ctx[n])) {\n\t\t\terr = PTR_ERR(ctx[n]);\n\t\t\tgoto out_ctx;\n\t\t}\n\t}\n\n\tfor_each_uabi_engine(engine, i915) {\n\t\tstruct i915_request *rq = NULL;\n\t\tunsigned long end_time, prime;\n\t\tktime_t times[2] = {};\n\n\t\ttimes[0] = ktime_get_raw();\n\t\tfor (n = 0; n < nctx; n++) {\n\t\t\tstruct i915_request *this;\n\n\t\t\tthis = igt_request_alloc(ctx[n], engine);\n\t\t\tif (IS_ERR(this)) {\n\t\t\t\terr = PTR_ERR(this);\n\t\t\t\tgoto out_ctx;\n\t\t\t}\n\t\t\tif (rq) {\n\t\t\t\ti915_request_await_dma_fence(this, &rq->fence);\n\t\t\t\ti915_request_put(rq);\n\t\t\t}\n\t\t\trq = i915_request_get(this);\n\t\t\ti915_request_add(this);\n\t\t}\n\t\tif (i915_request_wait(rq, 0, 10 * HZ) < 0) {\n\t\t\tpr_err(\"Failed to populated %d contexts\\n\", nctx);\n\t\t\tintel_gt_set_wedged(engine->gt);\n\t\t\ti915_request_put(rq);\n\t\t\terr = -EIO;\n\t\t\tgoto out_ctx;\n\t\t}\n\t\ti915_request_put(rq);\n\n\t\ttimes[1] = ktime_get_raw();\n\n\t\tpr_info(\"Populated %d contexts on %s in %lluns\\n\",\n\t\t\tnctx, engine->name, ktime_to_ns(times[1] - times[0]));\n\n\t\terr = igt_live_test_begin(&t, i915, __func__, engine->name);\n\t\tif (err)\n\t\t\tgoto out_ctx;\n\n\t\tend_time = jiffies + i915_selftest.timeout_jiffies;\n\t\tfor_each_prime_number_from(prime, 2, 8192) {\n\t\t\ttimes[1] = ktime_get_raw();\n\n\t\t\trq = NULL;\n\t\t\tfor (n = 0; n < prime; n++) {\n\t\t\t\tstruct i915_request *this;\n\n\t\t\t\tthis = igt_request_alloc(ctx[n % nctx], engine);\n\t\t\t\tif (IS_ERR(this)) {\n\t\t\t\t\terr = PTR_ERR(this);\n\t\t\t\t\tgoto out_ctx;\n\t\t\t\t}\n\n\t\t\t\tif (rq) {  \n\t\t\t\t\ti915_request_await_dma_fence(this, &rq->fence);\n\t\t\t\t\ti915_request_put(rq);\n\t\t\t\t}\n\n\t\t\t\t \n\n\t\t\t\trq = i915_request_get(this);\n\t\t\t\ti915_request_add(this);\n\t\t\t}\n\t\t\tGEM_BUG_ON(!rq);\n\t\t\tif (i915_request_wait(rq, 0, HZ / 5) < 0) {\n\t\t\t\tpr_err(\"Switching between %ld contexts timed out\\n\",\n\t\t\t\t       prime);\n\t\t\t\tintel_gt_set_wedged(engine->gt);\n\t\t\t\ti915_request_put(rq);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\ti915_request_put(rq);\n\n\t\t\ttimes[1] = ktime_sub(ktime_get_raw(), times[1]);\n\t\t\tif (prime == 2)\n\t\t\t\ttimes[0] = times[1];\n\n\t\t\tif (__igt_timeout(end_time, NULL))\n\t\t\t\tbreak;\n\t\t}\n\n\t\terr = igt_live_test_end(&t);\n\t\tif (err)\n\t\t\tgoto out_ctx;\n\n\t\tpr_info(\"Switch latencies on %s: 1 = %lluns, %lu = %lluns\\n\",\n\t\t\tengine->name,\n\t\t\tktime_to_ns(times[0]),\n\t\t\tprime - 1, div64_u64(ktime_to_ns(times[1]), prime - 1));\n\t}\n\nout_ctx:\n\tkfree(ctx);\nout_file:\n\tfput(file);\n\treturn err;\n}\n\nstruct parallel_switch {\n\tstruct kthread_worker *worker;\n\tstruct kthread_work work;\n\tstruct intel_context *ce[2];\n\tint result;\n};\n\nstatic void __live_parallel_switch1(struct kthread_work *work)\n{\n\tstruct parallel_switch *arg =\n\t\tcontainer_of(work, typeof(*arg), work);\n\tIGT_TIMEOUT(end_time);\n\tunsigned long count;\n\n\tcount = 0;\n\targ->result = 0;\n\tdo {\n\t\tstruct i915_request *rq = NULL;\n\t\tint n;\n\n\t\tfor (n = 0; !arg->result && n < ARRAY_SIZE(arg->ce); n++) {\n\t\t\tstruct i915_request *prev = rq;\n\n\t\t\trq = i915_request_create(arg->ce[n]);\n\t\t\tif (IS_ERR(rq)) {\n\t\t\t\ti915_request_put(prev);\n\t\t\t\targ->result = PTR_ERR(rq);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\ti915_request_get(rq);\n\t\t\tif (prev) {\n\t\t\t\targ->result =\n\t\t\t\t\ti915_request_await_dma_fence(rq,\n\t\t\t\t\t\t\t\t     &prev->fence);\n\t\t\t\ti915_request_put(prev);\n\t\t\t}\n\n\t\t\ti915_request_add(rq);\n\t\t}\n\n\t\tif (IS_ERR_OR_NULL(rq))\n\t\t\tbreak;\n\n\t\tif (i915_request_wait(rq, 0, HZ) < 0)\n\t\t\targ->result = -ETIME;\n\n\t\ti915_request_put(rq);\n\n\t\tcount++;\n\t} while (!arg->result && !__igt_timeout(end_time, NULL));\n\n\tpr_info(\"%s: %lu switches (sync) <%d>\\n\",\n\t\targ->ce[0]->engine->name, count, arg->result);\n}\n\nstatic void __live_parallel_switchN(struct kthread_work *work)\n{\n\tstruct parallel_switch *arg =\n\t\tcontainer_of(work, typeof(*arg), work);\n\tstruct i915_request *rq = NULL;\n\tIGT_TIMEOUT(end_time);\n\tunsigned long count;\n\tint n;\n\n\tcount = 0;\n\targ->result = 0;\n\tdo {\n\t\tfor (n = 0; !arg->result && n < ARRAY_SIZE(arg->ce); n++) {\n\t\t\tstruct i915_request *prev = rq;\n\n\t\t\trq = i915_request_create(arg->ce[n]);\n\t\t\tif (IS_ERR(rq)) {\n\t\t\t\ti915_request_put(prev);\n\t\t\t\targ->result = PTR_ERR(rq);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\ti915_request_get(rq);\n\t\t\tif (prev) {\n\t\t\t\targ->result =\n\t\t\t\t\ti915_request_await_dma_fence(rq,\n\t\t\t\t\t\t\t\t     &prev->fence);\n\t\t\t\ti915_request_put(prev);\n\t\t\t}\n\n\t\t\ti915_request_add(rq);\n\t\t}\n\n\t\tcount++;\n\t} while (!arg->result && !__igt_timeout(end_time, NULL));\n\n\tif (!IS_ERR_OR_NULL(rq))\n\t\ti915_request_put(rq);\n\n\tpr_info(\"%s: %lu switches (many) <%d>\\n\",\n\t\targ->ce[0]->engine->name, count, arg->result);\n}\n\nstatic int live_parallel_switch(void *arg)\n{\n\tstruct drm_i915_private *i915 = arg;\n\tstatic void (* const func[])(struct kthread_work *) = {\n\t\t__live_parallel_switch1,\n\t\t__live_parallel_switchN,\n\t\tNULL,\n\t};\n\tstruct parallel_switch *data = NULL;\n\tstruct i915_gem_engines *engines;\n\tstruct i915_gem_engines_iter it;\n\tvoid (* const *fn)(struct kthread_work *);\n\tstruct i915_gem_context *ctx;\n\tstruct intel_context *ce;\n\tstruct file *file;\n\tint n, m, count;\n\tint err = 0;\n\n\t \n\n\tif (!DRIVER_CAPS(i915)->has_logical_contexts)\n\t\treturn 0;\n\n\tfile = mock_file(i915);\n\tif (IS_ERR(file))\n\t\treturn PTR_ERR(file);\n\n\tctx = live_context(i915, file);\n\tif (IS_ERR(ctx)) {\n\t\terr = PTR_ERR(ctx);\n\t\tgoto out_file;\n\t}\n\n\tengines = i915_gem_context_lock_engines(ctx);\n\tcount = engines->num_engines;\n\n\tdata = kcalloc(count, sizeof(*data), GFP_KERNEL);\n\tif (!data) {\n\t\ti915_gem_context_unlock_engines(ctx);\n\t\terr = -ENOMEM;\n\t\tgoto out_file;\n\t}\n\n\tm = 0;  \n\tfor_each_gem_engine(ce, engines, it) {\n\t\terr = intel_context_pin(ce);\n\t\tif (err) {\n\t\t\ti915_gem_context_unlock_engines(ctx);\n\t\t\tgoto out;\n\t\t}\n\t\tdata[m++].ce[0] = intel_context_get(ce);\n\t}\n\ti915_gem_context_unlock_engines(ctx);\n\n\t \n\tfor (n = 1; n < ARRAY_SIZE(data->ce); n++) {\n\t\tctx = live_context(i915, file);\n\t\tif (IS_ERR(ctx)) {\n\t\t\terr = PTR_ERR(ctx);\n\t\t\tgoto out;\n\t\t}\n\n\t\tfor (m = 0; m < count; m++) {\n\t\t\tif (!data[m].ce[0])\n\t\t\t\tcontinue;\n\n\t\t\tce = intel_context_create(data[m].ce[0]->engine);\n\t\t\tif (IS_ERR(ce)) {\n\t\t\t\terr = PTR_ERR(ce);\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\terr = intel_context_pin(ce);\n\t\t\tif (err) {\n\t\t\t\tintel_context_put(ce);\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tdata[m].ce[n] = ce;\n\t\t}\n\t}\n\n\tfor (n = 0; n < count; n++) {\n\t\tstruct kthread_worker *worker;\n\n\t\tif (!data[n].ce[0])\n\t\t\tcontinue;\n\n\t\tworker = kthread_create_worker(0, \"igt/parallel:%s\",\n\t\t\t\t\t       data[n].ce[0]->engine->name);\n\t\tif (IS_ERR(worker)) {\n\t\t\terr = PTR_ERR(worker);\n\t\t\tgoto out;\n\t\t}\n\n\t\tdata[n].worker = worker;\n\t}\n\n\tfor (fn = func; !err && *fn; fn++) {\n\t\tstruct igt_live_test t;\n\n\t\terr = igt_live_test_begin(&t, i915, __func__, \"\");\n\t\tif (err)\n\t\t\tbreak;\n\n\t\tfor (n = 0; n < count; n++) {\n\t\t\tif (!data[n].ce[0])\n\t\t\t\tcontinue;\n\n\t\t\tdata[n].result = 0;\n\t\t\tkthread_init_work(&data[n].work, *fn);\n\t\t\tkthread_queue_work(data[n].worker, &data[n].work);\n\t\t}\n\n\t\tfor (n = 0; n < count; n++) {\n\t\t\tif (data[n].ce[0]) {\n\t\t\t\tkthread_flush_work(&data[n].work);\n\t\t\t\tif (data[n].result && !err)\n\t\t\t\t\terr = data[n].result;\n\t\t\t}\n\t\t}\n\n\t\tif (igt_live_test_end(&t)) {\n\t\t\terr = err ?: -EIO;\n\t\t\tbreak;\n\t\t}\n\t}\n\nout:\n\tfor (n = 0; n < count; n++) {\n\t\tfor (m = 0; m < ARRAY_SIZE(data->ce); m++) {\n\t\t\tif (!data[n].ce[m])\n\t\t\t\tcontinue;\n\n\t\t\tintel_context_unpin(data[n].ce[m]);\n\t\t\tintel_context_put(data[n].ce[m]);\n\t\t}\n\n\t\tif (data[n].worker)\n\t\t\tkthread_destroy_worker(data[n].worker);\n\t}\n\tkfree(data);\nout_file:\n\tfput(file);\n\treturn err;\n}\n\nstatic unsigned long real_page_count(struct drm_i915_gem_object *obj)\n{\n\treturn huge_gem_object_phys_size(obj) >> PAGE_SHIFT;\n}\n\nstatic unsigned long fake_page_count(struct drm_i915_gem_object *obj)\n{\n\treturn huge_gem_object_dma_size(obj) >> PAGE_SHIFT;\n}\n\nstatic int gpu_fill(struct intel_context *ce,\n\t\t    struct drm_i915_gem_object *obj,\n\t\t    unsigned int dw)\n{\n\tstruct i915_vma *vma;\n\tint err;\n\n\tGEM_BUG_ON(obj->base.size > ce->vm->total);\n\tGEM_BUG_ON(!intel_engine_can_store_dword(ce->engine));\n\n\tvma = i915_vma_instance(obj, ce->vm, NULL);\n\tif (IS_ERR(vma))\n\t\treturn PTR_ERR(vma);\n\n\terr = i915_vma_pin(vma, 0, 0, PIN_HIGH | PIN_USER);\n\tif (err)\n\t\treturn err;\n\n\t \n\terr = igt_gpu_fill_dw(ce, vma,\n\t\t\t      (dw * real_page_count(obj)) << PAGE_SHIFT |\n\t\t\t      (dw * sizeof(u32)),\n\t\t\t      real_page_count(obj),\n\t\t\t      dw);\n\ti915_vma_unpin(vma);\n\n\treturn err;\n}\n\nstatic int cpu_fill(struct drm_i915_gem_object *obj, u32 value)\n{\n\tconst bool has_llc = HAS_LLC(to_i915(obj->base.dev));\n\tunsigned int need_flush;\n\tunsigned long n, m;\n\tint err;\n\n\ti915_gem_object_lock(obj, NULL);\n\terr = i915_gem_object_prepare_write(obj, &need_flush);\n\tif (err)\n\t\tgoto out;\n\n\tfor (n = 0; n < real_page_count(obj); n++) {\n\t\tu32 *map;\n\n\t\tmap = kmap_atomic(i915_gem_object_get_page(obj, n));\n\t\tfor (m = 0; m < DW_PER_PAGE; m++)\n\t\t\tmap[m] = value;\n\t\tif (!has_llc)\n\t\t\tdrm_clflush_virt_range(map, PAGE_SIZE);\n\t\tkunmap_atomic(map);\n\t}\n\n\ti915_gem_object_finish_access(obj);\n\tobj->read_domains = I915_GEM_DOMAIN_GTT | I915_GEM_DOMAIN_CPU;\n\tobj->write_domain = 0;\nout:\n\ti915_gem_object_unlock(obj);\n\treturn err;\n}\n\nstatic noinline int cpu_check(struct drm_i915_gem_object *obj,\n\t\t\t      unsigned int idx, unsigned int max)\n{\n\tunsigned int needs_flush;\n\tunsigned long n;\n\tint err;\n\n\ti915_gem_object_lock(obj, NULL);\n\terr = i915_gem_object_prepare_read(obj, &needs_flush);\n\tif (err)\n\t\tgoto out_unlock;\n\n\tfor (n = 0; n < real_page_count(obj); n++) {\n\t\tu32 *map, m;\n\n\t\tmap = kmap_atomic(i915_gem_object_get_page(obj, n));\n\t\tif (needs_flush & CLFLUSH_BEFORE)\n\t\t\tdrm_clflush_virt_range(map, PAGE_SIZE);\n\n\t\tfor (m = 0; m < max; m++) {\n\t\t\tif (map[m] != m) {\n\t\t\t\tpr_err(\"%pS: Invalid value at object %d page %ld/%ld, offset %d/%d: found %x expected %x\\n\",\n\t\t\t\t       __builtin_return_address(0), idx,\n\t\t\t\t       n, real_page_count(obj), m, max,\n\t\t\t\t       map[m], m);\n\t\t\t\terr = -EINVAL;\n\t\t\t\tgoto out_unmap;\n\t\t\t}\n\t\t}\n\n\t\tfor (; m < DW_PER_PAGE; m++) {\n\t\t\tif (map[m] != STACK_MAGIC) {\n\t\t\t\tpr_err(\"%pS: Invalid value at object %d page %ld, offset %d: found %x expected %x (uninitialised)\\n\",\n\t\t\t\t       __builtin_return_address(0), idx, n, m,\n\t\t\t\t       map[m], STACK_MAGIC);\n\t\t\t\terr = -EINVAL;\n\t\t\t\tgoto out_unmap;\n\t\t\t}\n\t\t}\n\nout_unmap:\n\t\tkunmap_atomic(map);\n\t\tif (err)\n\t\t\tbreak;\n\t}\n\n\ti915_gem_object_finish_access(obj);\nout_unlock:\n\ti915_gem_object_unlock(obj);\n\treturn err;\n}\n\nstatic int file_add_object(struct file *file, struct drm_i915_gem_object *obj)\n{\n\tint err;\n\n\tGEM_BUG_ON(obj->base.handle_count);\n\n\t \n\terr = idr_alloc(&to_drm_file(file)->object_idr,\n\t\t\t&obj->base, 1, 0, GFP_KERNEL);\n\tif (err < 0)\n\t\treturn err;\n\n\ti915_gem_object_get(obj);\n\tobj->base.handle_count++;\n\treturn 0;\n}\n\nstatic struct drm_i915_gem_object *\ncreate_test_object(struct i915_address_space *vm,\n\t\t   struct file *file,\n\t\t   struct list_head *objects)\n{\n\tstruct drm_i915_gem_object *obj;\n\tu64 size;\n\tint err;\n\n\t \n\tintel_gt_retire_requests(vm->gt);\n\n\tsize = min(vm->total / 2, 1024ull * DW_PER_PAGE * PAGE_SIZE);\n\tsize = round_down(size, DW_PER_PAGE * PAGE_SIZE);\n\n\tobj = huge_gem_object(vm->i915, DW_PER_PAGE * PAGE_SIZE, size);\n\tif (IS_ERR(obj))\n\t\treturn obj;\n\n\terr = file_add_object(file, obj);\n\ti915_gem_object_put(obj);\n\tif (err)\n\t\treturn ERR_PTR(err);\n\n\terr = cpu_fill(obj, STACK_MAGIC);\n\tif (err) {\n\t\tpr_err(\"Failed to fill object with cpu, err=%d\\n\",\n\t\t       err);\n\t\treturn ERR_PTR(err);\n\t}\n\n\tlist_add_tail(&obj->st_link, objects);\n\treturn obj;\n}\n\nstatic unsigned long max_dwords(struct drm_i915_gem_object *obj)\n{\n\tunsigned long npages = fake_page_count(obj);\n\n\tGEM_BUG_ON(!IS_ALIGNED(npages, DW_PER_PAGE));\n\treturn npages / DW_PER_PAGE;\n}\n\nstatic void throttle_release(struct i915_request **q, int count)\n{\n\tint i;\n\n\tfor (i = 0; i < count; i++) {\n\t\tif (IS_ERR_OR_NULL(q[i]))\n\t\t\tcontinue;\n\n\t\ti915_request_put(fetch_and_zero(&q[i]));\n\t}\n}\n\nstatic int throttle(struct intel_context *ce,\n\t\t    struct i915_request **q, int count)\n{\n\tint i;\n\n\tif (!IS_ERR_OR_NULL(q[0])) {\n\t\tif (i915_request_wait(q[0],\n\t\t\t\t      I915_WAIT_INTERRUPTIBLE,\n\t\t\t\t      MAX_SCHEDULE_TIMEOUT) < 0)\n\t\t\treturn -EINTR;\n\n\t\ti915_request_put(q[0]);\n\t}\n\n\tfor (i = 0; i < count - 1; i++)\n\t\tq[i] = q[i + 1];\n\n\tq[i] = intel_context_create_request(ce);\n\tif (IS_ERR(q[i]))\n\t\treturn PTR_ERR(q[i]);\n\n\ti915_request_get(q[i]);\n\ti915_request_add(q[i]);\n\n\treturn 0;\n}\n\nstatic int igt_ctx_exec(void *arg)\n{\n\tstruct drm_i915_private *i915 = arg;\n\tstruct intel_engine_cs *engine;\n\tint err = -ENODEV;\n\n\t \n\n\tif (!DRIVER_CAPS(i915)->has_logical_contexts)\n\t\treturn 0;\n\n\tfor_each_uabi_engine(engine, i915) {\n\t\tstruct drm_i915_gem_object *obj = NULL;\n\t\tunsigned long ncontexts, ndwords, dw;\n\t\tstruct i915_request *tq[5] = {};\n\t\tstruct igt_live_test t;\n\t\tIGT_TIMEOUT(end_time);\n\t\tLIST_HEAD(objects);\n\t\tstruct file *file;\n\n\t\tif (!intel_engine_can_store_dword(engine))\n\t\t\tcontinue;\n\n\t\tif (!engine->context_size)\n\t\t\tcontinue;  \n\n\t\tfile = mock_file(i915);\n\t\tif (IS_ERR(file))\n\t\t\treturn PTR_ERR(file);\n\n\t\terr = igt_live_test_begin(&t, i915, __func__, engine->name);\n\t\tif (err)\n\t\t\tgoto out_file;\n\n\t\tncontexts = 0;\n\t\tndwords = 0;\n\t\tdw = 0;\n\t\twhile (!time_after(jiffies, end_time)) {\n\t\t\tstruct i915_gem_context *ctx;\n\t\t\tstruct intel_context *ce;\n\n\t\t\tctx = kernel_context(i915, NULL);\n\t\t\tif (IS_ERR(ctx)) {\n\t\t\t\terr = PTR_ERR(ctx);\n\t\t\t\tgoto out_file;\n\t\t\t}\n\n\t\t\tce = i915_gem_context_get_engine(ctx, engine->legacy_idx);\n\t\t\tGEM_BUG_ON(IS_ERR(ce));\n\n\t\t\tif (!obj) {\n\t\t\t\tobj = create_test_object(ce->vm, file, &objects);\n\t\t\t\tif (IS_ERR(obj)) {\n\t\t\t\t\terr = PTR_ERR(obj);\n\t\t\t\t\tintel_context_put(ce);\n\t\t\t\t\tkernel_context_close(ctx);\n\t\t\t\t\tgoto out_file;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\terr = gpu_fill(ce, obj, dw);\n\t\t\tif (err) {\n\t\t\t\tpr_err(\"Failed to fill dword %lu [%lu/%lu] with gpu (%s) [full-ppgtt? %s], err=%d\\n\",\n\t\t\t\t       ndwords, dw, max_dwords(obj),\n\t\t\t\t       engine->name,\n\t\t\t\t       str_yes_no(i915_gem_context_has_full_ppgtt(ctx)),\n\t\t\t\t       err);\n\t\t\t\tintel_context_put(ce);\n\t\t\t\tkernel_context_close(ctx);\n\t\t\t\tgoto out_file;\n\t\t\t}\n\n\t\t\terr = throttle(ce, tq, ARRAY_SIZE(tq));\n\t\t\tif (err) {\n\t\t\t\tintel_context_put(ce);\n\t\t\t\tkernel_context_close(ctx);\n\t\t\t\tgoto out_file;\n\t\t\t}\n\n\t\t\tif (++dw == max_dwords(obj)) {\n\t\t\t\tobj = NULL;\n\t\t\t\tdw = 0;\n\t\t\t}\n\n\t\t\tndwords++;\n\t\t\tncontexts++;\n\n\t\t\tintel_context_put(ce);\n\t\t\tkernel_context_close(ctx);\n\t\t}\n\n\t\tpr_info(\"Submitted %lu contexts to %s, filling %lu dwords\\n\",\n\t\t\tncontexts, engine->name, ndwords);\n\n\t\tncontexts = dw = 0;\n\t\tlist_for_each_entry(obj, &objects, st_link) {\n\t\t\tunsigned int rem =\n\t\t\t\tmin_t(unsigned int, ndwords - dw, max_dwords(obj));\n\n\t\t\terr = cpu_check(obj, ncontexts++, rem);\n\t\t\tif (err)\n\t\t\t\tbreak;\n\n\t\t\tdw += rem;\n\t\t}\n\nout_file:\n\t\tthrottle_release(tq, ARRAY_SIZE(tq));\n\t\tif (igt_live_test_end(&t))\n\t\t\terr = -EIO;\n\n\t\tfput(file);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\ti915_gem_drain_freed_objects(i915);\n\t}\n\n\treturn 0;\n}\n\nstatic int igt_shared_ctx_exec(void *arg)\n{\n\tstruct drm_i915_private *i915 = arg;\n\tstruct i915_request *tq[5] = {};\n\tstruct i915_gem_context *parent;\n\tstruct intel_engine_cs *engine;\n\tstruct igt_live_test t;\n\tstruct file *file;\n\tint err = 0;\n\n\t \n\tif (!DRIVER_CAPS(i915)->has_logical_contexts)\n\t\treturn 0;\n\n\tfile = mock_file(i915);\n\tif (IS_ERR(file))\n\t\treturn PTR_ERR(file);\n\n\tparent = live_context(i915, file);\n\tif (IS_ERR(parent)) {\n\t\terr = PTR_ERR(parent);\n\t\tgoto out_file;\n\t}\n\n\tif (!parent->vm) {  \n\t\terr = 0;\n\t\tgoto out_file;\n\t}\n\n\terr = igt_live_test_begin(&t, i915, __func__, \"\");\n\tif (err)\n\t\tgoto out_file;\n\n\tfor_each_uabi_engine(engine, i915) {\n\t\tunsigned long ncontexts, ndwords, dw;\n\t\tstruct drm_i915_gem_object *obj = NULL;\n\t\tIGT_TIMEOUT(end_time);\n\t\tLIST_HEAD(objects);\n\n\t\tif (!intel_engine_can_store_dword(engine))\n\t\t\tcontinue;\n\n\t\tdw = 0;\n\t\tndwords = 0;\n\t\tncontexts = 0;\n\t\twhile (!time_after(jiffies, end_time)) {\n\t\t\tstruct i915_gem_context *ctx;\n\t\t\tstruct intel_context *ce;\n\n\t\t\tctx = kernel_context(i915, parent->vm);\n\t\t\tif (IS_ERR(ctx)) {\n\t\t\t\terr = PTR_ERR(ctx);\n\t\t\t\tgoto out_test;\n\t\t\t}\n\n\t\t\tce = i915_gem_context_get_engine(ctx, engine->legacy_idx);\n\t\t\tGEM_BUG_ON(IS_ERR(ce));\n\n\t\t\tif (!obj) {\n\t\t\t\tobj = create_test_object(parent->vm,\n\t\t\t\t\t\t\t file, &objects);\n\t\t\t\tif (IS_ERR(obj)) {\n\t\t\t\t\terr = PTR_ERR(obj);\n\t\t\t\t\tintel_context_put(ce);\n\t\t\t\t\tkernel_context_close(ctx);\n\t\t\t\t\tgoto out_test;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\terr = gpu_fill(ce, obj, dw);\n\t\t\tif (err) {\n\t\t\t\tpr_err(\"Failed to fill dword %lu [%lu/%lu] with gpu (%s) [full-ppgtt? %s], err=%d\\n\",\n\t\t\t\t       ndwords, dw, max_dwords(obj),\n\t\t\t\t       engine->name,\n\t\t\t\t       str_yes_no(i915_gem_context_has_full_ppgtt(ctx)),\n\t\t\t\t       err);\n\t\t\t\tintel_context_put(ce);\n\t\t\t\tkernel_context_close(ctx);\n\t\t\t\tgoto out_test;\n\t\t\t}\n\n\t\t\terr = throttle(ce, tq, ARRAY_SIZE(tq));\n\t\t\tif (err) {\n\t\t\t\tintel_context_put(ce);\n\t\t\t\tkernel_context_close(ctx);\n\t\t\t\tgoto out_test;\n\t\t\t}\n\n\t\t\tif (++dw == max_dwords(obj)) {\n\t\t\t\tobj = NULL;\n\t\t\t\tdw = 0;\n\t\t\t}\n\n\t\t\tndwords++;\n\t\t\tncontexts++;\n\n\t\t\tintel_context_put(ce);\n\t\t\tkernel_context_close(ctx);\n\t\t}\n\t\tpr_info(\"Submitted %lu contexts to %s, filling %lu dwords\\n\",\n\t\t\tncontexts, engine->name, ndwords);\n\n\t\tncontexts = dw = 0;\n\t\tlist_for_each_entry(obj, &objects, st_link) {\n\t\t\tunsigned int rem =\n\t\t\t\tmin_t(unsigned int, ndwords - dw, max_dwords(obj));\n\n\t\t\terr = cpu_check(obj, ncontexts++, rem);\n\t\t\tif (err)\n\t\t\t\tgoto out_test;\n\n\t\t\tdw += rem;\n\t\t}\n\n\t\ti915_gem_drain_freed_objects(i915);\n\t}\nout_test:\n\tthrottle_release(tq, ARRAY_SIZE(tq));\n\tif (igt_live_test_end(&t))\n\t\terr = -EIO;\nout_file:\n\tfput(file);\n\treturn err;\n}\n\nstatic int rpcs_query_batch(struct drm_i915_gem_object *rpcs,\n\t\t\t    struct i915_vma *vma,\n\t\t\t    struct intel_engine_cs *engine)\n{\n\tu32 *cmd;\n\n\tGEM_BUG_ON(GRAPHICS_VER(vma->vm->i915) < 8);\n\n\tcmd = i915_gem_object_pin_map(rpcs, I915_MAP_WB);\n\tif (IS_ERR(cmd))\n\t\treturn PTR_ERR(cmd);\n\n\t*cmd++ = MI_STORE_REGISTER_MEM_GEN8;\n\t*cmd++ = i915_mmio_reg_offset(GEN8_R_PWR_CLK_STATE(engine->mmio_base));\n\t*cmd++ = lower_32_bits(i915_vma_offset(vma));\n\t*cmd++ = upper_32_bits(i915_vma_offset(vma));\n\t*cmd = MI_BATCH_BUFFER_END;\n\n\t__i915_gem_object_flush_map(rpcs, 0, 64);\n\ti915_gem_object_unpin_map(rpcs);\n\n\tintel_gt_chipset_flush(vma->vm->gt);\n\n\treturn 0;\n}\n\nstatic int\nemit_rpcs_query(struct drm_i915_gem_object *obj,\n\t\tstruct intel_context *ce,\n\t\tstruct i915_request **rq_out)\n{\n\tstruct drm_i915_private *i915 = to_i915(obj->base.dev);\n\tstruct i915_request *rq;\n\tstruct i915_gem_ww_ctx ww;\n\tstruct i915_vma *batch;\n\tstruct i915_vma *vma;\n\tstruct drm_i915_gem_object *rpcs;\n\tint err;\n\n\tGEM_BUG_ON(!intel_engine_can_store_dword(ce->engine));\n\n\tif (GRAPHICS_VER(i915) < 8)\n\t\treturn -EINVAL;\n\n\tvma = i915_vma_instance(obj, ce->vm, NULL);\n\tif (IS_ERR(vma))\n\t\treturn PTR_ERR(vma);\n\n\trpcs = i915_gem_object_create_internal(i915, PAGE_SIZE);\n\tif (IS_ERR(rpcs))\n\t\treturn PTR_ERR(rpcs);\n\n\tbatch = i915_vma_instance(rpcs, ce->vm, NULL);\n\tif (IS_ERR(batch)) {\n\t\terr = PTR_ERR(batch);\n\t\tgoto err_put;\n\t}\n\n\ti915_gem_ww_ctx_init(&ww, false);\nretry:\n\terr = i915_gem_object_lock(obj, &ww);\n\tif (!err)\n\t\terr = i915_gem_object_lock(rpcs, &ww);\n\tif (!err)\n\t\terr = i915_gem_object_set_to_gtt_domain(obj, false);\n\tif (!err)\n\t\terr = i915_vma_pin_ww(vma, &ww, 0, 0, PIN_USER);\n\tif (err)\n\t\tgoto err_put;\n\n\terr = i915_vma_pin_ww(batch, &ww, 0, 0, PIN_USER);\n\tif (err)\n\t\tgoto err_vma;\n\n\terr = rpcs_query_batch(rpcs, vma, ce->engine);\n\tif (err)\n\t\tgoto err_batch;\n\n\trq = i915_request_create(ce);\n\tif (IS_ERR(rq)) {\n\t\terr = PTR_ERR(rq);\n\t\tgoto err_batch;\n\t}\n\n\terr = i915_vma_move_to_active(batch, rq, 0);\n\tif (err)\n\t\tgoto skip_request;\n\n\terr = i915_vma_move_to_active(vma, rq, EXEC_OBJECT_WRITE);\n\tif (err)\n\t\tgoto skip_request;\n\n\tif (rq->engine->emit_init_breadcrumb) {\n\t\terr = rq->engine->emit_init_breadcrumb(rq);\n\t\tif (err)\n\t\t\tgoto skip_request;\n\t}\n\n\terr = rq->engine->emit_bb_start(rq,\n\t\t\t\t\ti915_vma_offset(batch),\n\t\t\t\t\ti915_vma_size(batch),\n\t\t\t\t\t0);\n\tif (err)\n\t\tgoto skip_request;\n\n\t*rq_out = i915_request_get(rq);\n\nskip_request:\n\tif (err)\n\t\ti915_request_set_error_once(rq, err);\n\ti915_request_add(rq);\nerr_batch:\n\ti915_vma_unpin(batch);\nerr_vma:\n\ti915_vma_unpin(vma);\nerr_put:\n\tif (err == -EDEADLK) {\n\t\terr = i915_gem_ww_ctx_backoff(&ww);\n\t\tif (!err)\n\t\t\tgoto retry;\n\t}\n\ti915_gem_ww_ctx_fini(&ww);\n\ti915_gem_object_put(rpcs);\n\treturn err;\n}\n\n#define TEST_IDLE\tBIT(0)\n#define TEST_BUSY\tBIT(1)\n#define TEST_RESET\tBIT(2)\n\nstatic int\n__sseu_prepare(const char *name,\n\t       unsigned int flags,\n\t       struct intel_context *ce,\n\t       struct igt_spinner **spin)\n{\n\tstruct i915_request *rq;\n\tint ret;\n\n\t*spin = NULL;\n\tif (!(flags & (TEST_BUSY | TEST_RESET)))\n\t\treturn 0;\n\n\t*spin = kzalloc(sizeof(**spin), GFP_KERNEL);\n\tif (!*spin)\n\t\treturn -ENOMEM;\n\n\tret = igt_spinner_init(*spin, ce->engine->gt);\n\tif (ret)\n\t\tgoto err_free;\n\n\trq = igt_spinner_create_request(*spin, ce, MI_NOOP);\n\tif (IS_ERR(rq)) {\n\t\tret = PTR_ERR(rq);\n\t\tgoto err_fini;\n\t}\n\n\ti915_request_add(rq);\n\n\tif (!igt_wait_for_spinner(*spin, rq)) {\n\t\tpr_err(\"%s: Spinner failed to start!\\n\", name);\n\t\tret = -ETIMEDOUT;\n\t\tgoto err_end;\n\t}\n\n\treturn 0;\n\nerr_end:\n\tigt_spinner_end(*spin);\nerr_fini:\n\tigt_spinner_fini(*spin);\nerr_free:\n\tkfree(fetch_and_zero(spin));\n\treturn ret;\n}\n\nstatic int\n__read_slice_count(struct intel_context *ce,\n\t\t   struct drm_i915_gem_object *obj,\n\t\t   struct igt_spinner *spin,\n\t\t   u32 *rpcs)\n{\n\tstruct i915_request *rq = NULL;\n\tu32 s_mask, s_shift;\n\tunsigned int cnt;\n\tu32 *buf, val;\n\tlong ret;\n\n\tret = emit_rpcs_query(obj, ce, &rq);\n\tif (ret)\n\t\treturn ret;\n\n\tif (spin)\n\t\tigt_spinner_end(spin);\n\n\tret = i915_request_wait(rq, 0, MAX_SCHEDULE_TIMEOUT);\n\ti915_request_put(rq);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tbuf = i915_gem_object_pin_map_unlocked(obj, I915_MAP_WB);\n\tif (IS_ERR(buf)) {\n\t\tret = PTR_ERR(buf);\n\t\treturn ret;\n\t}\n\n\tif (GRAPHICS_VER(ce->engine->i915) >= 11) {\n\t\ts_mask = GEN11_RPCS_S_CNT_MASK;\n\t\ts_shift = GEN11_RPCS_S_CNT_SHIFT;\n\t} else {\n\t\ts_mask = GEN8_RPCS_S_CNT_MASK;\n\t\ts_shift = GEN8_RPCS_S_CNT_SHIFT;\n\t}\n\n\tval = *buf;\n\tcnt = (val & s_mask) >> s_shift;\n\t*rpcs = val;\n\n\ti915_gem_object_unpin_map(obj);\n\n\treturn cnt;\n}\n\nstatic int\n__check_rpcs(const char *name, u32 rpcs, int slices, unsigned int expected,\n\t     const char *prefix, const char *suffix)\n{\n\tif (slices == expected)\n\t\treturn 0;\n\n\tif (slices < 0) {\n\t\tpr_err(\"%s: %s read slice count failed with %d%s\\n\",\n\t\t       name, prefix, slices, suffix);\n\t\treturn slices;\n\t}\n\n\tpr_err(\"%s: %s slice count %d is not %u%s\\n\",\n\t       name, prefix, slices, expected, suffix);\n\n\tpr_info(\"RPCS=0x%x; %u%sx%u%s\\n\",\n\t\trpcs, slices,\n\t\t(rpcs & GEN8_RPCS_S_CNT_ENABLE) ? \"*\" : \"\",\n\t\t(rpcs & GEN8_RPCS_SS_CNT_MASK) >> GEN8_RPCS_SS_CNT_SHIFT,\n\t\t(rpcs & GEN8_RPCS_SS_CNT_ENABLE) ? \"*\" : \"\");\n\n\treturn -EINVAL;\n}\n\nstatic int\n__sseu_finish(const char *name,\n\t      unsigned int flags,\n\t      struct intel_context *ce,\n\t      struct drm_i915_gem_object *obj,\n\t      unsigned int expected,\n\t      struct igt_spinner *spin)\n{\n\tunsigned int slices = hweight32(ce->engine->sseu.slice_mask);\n\tu32 rpcs = 0;\n\tint ret = 0;\n\n\tif (flags & TEST_RESET) {\n\t\tret = intel_engine_reset(ce->engine, \"sseu\");\n\t\tif (ret)\n\t\t\tgoto out;\n\t}\n\n\tret = __read_slice_count(ce, obj,\n\t\t\t\t flags & TEST_RESET ? NULL : spin, &rpcs);\n\tret = __check_rpcs(name, rpcs, ret, expected, \"Context\", \"!\");\n\tif (ret)\n\t\tgoto out;\n\n\tret = __read_slice_count(ce->engine->kernel_context, obj, NULL, &rpcs);\n\tret = __check_rpcs(name, rpcs, ret, slices, \"Kernel context\", \"!\");\n\nout:\n\tif (spin)\n\t\tigt_spinner_end(spin);\n\n\tif ((flags & TEST_IDLE) && ret == 0) {\n\t\tret = igt_flush_test(ce->engine->i915);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tret = __read_slice_count(ce, obj, NULL, &rpcs);\n\t\tret = __check_rpcs(name, rpcs, ret, expected,\n\t\t\t\t   \"Context\", \" after idle!\");\n\t}\n\n\treturn ret;\n}\n\nstatic int\n__sseu_test(const char *name,\n\t    unsigned int flags,\n\t    struct intel_context *ce,\n\t    struct drm_i915_gem_object *obj,\n\t    struct intel_sseu sseu)\n{\n\tstruct igt_spinner *spin = NULL;\n\tint ret;\n\n\tintel_engine_pm_get(ce->engine);\n\n\tret = __sseu_prepare(name, flags, ce, &spin);\n\tif (ret)\n\t\tgoto out_pm;\n\n\tret = intel_context_reconfigure_sseu(ce, sseu);\n\tif (ret)\n\t\tgoto out_spin;\n\n\tret = __sseu_finish(name, flags, ce, obj,\n\t\t\t    hweight32(sseu.slice_mask), spin);\n\nout_spin:\n\tif (spin) {\n\t\tigt_spinner_end(spin);\n\t\tigt_spinner_fini(spin);\n\t\tkfree(spin);\n\t}\nout_pm:\n\tintel_engine_pm_put(ce->engine);\n\treturn ret;\n}\n\nstatic int\n__igt_ctx_sseu(struct drm_i915_private *i915,\n\t       const char *name,\n\t       unsigned int flags)\n{\n\tstruct drm_i915_gem_object *obj;\n\tint inst = 0;\n\tint ret = 0;\n\n\tif (GRAPHICS_VER(i915) < 9)\n\t\treturn 0;\n\n\tif (flags & TEST_RESET)\n\t\tigt_global_reset_lock(to_gt(i915));\n\n\tobj = i915_gem_object_create_internal(i915, PAGE_SIZE);\n\tif (IS_ERR(obj)) {\n\t\tret = PTR_ERR(obj);\n\t\tgoto out_unlock;\n\t}\n\n\tdo {\n\t\tstruct intel_engine_cs *engine;\n\t\tstruct intel_context *ce;\n\t\tstruct intel_sseu pg_sseu;\n\n\t\tengine = intel_engine_lookup_user(i915,\n\t\t\t\t\t\t  I915_ENGINE_CLASS_RENDER,\n\t\t\t\t\t\t  inst++);\n\t\tif (!engine)\n\t\t\tbreak;\n\n\t\tif (hweight32(engine->sseu.slice_mask) < 2)\n\t\t\tcontinue;\n\n\t\tif (!engine->gt->info.sseu.has_slice_pg)\n\t\t\tcontinue;\n\n\t\t \n\t\tpg_sseu = engine->sseu;\n\t\tpg_sseu.slice_mask = 1;\n\t\tpg_sseu.subslice_mask =\n\t\t\t~(~0 << (hweight32(engine->sseu.subslice_mask) / 2));\n\n\t\tpr_info(\"%s: SSEU subtest '%s', flags=%x, def_slices=%u, pg_slices=%u\\n\",\n\t\t\tengine->name, name, flags,\n\t\t\thweight32(engine->sseu.slice_mask),\n\t\t\thweight32(pg_sseu.slice_mask));\n\n\t\tce = intel_context_create(engine);\n\t\tif (IS_ERR(ce)) {\n\t\t\tret = PTR_ERR(ce);\n\t\t\tgoto out_put;\n\t\t}\n\n\t\tret = intel_context_pin(ce);\n\t\tif (ret)\n\t\t\tgoto out_ce;\n\n\t\t \n\t\tret = __sseu_test(name, flags, ce, obj, engine->sseu);\n\t\tif (ret)\n\t\t\tgoto out_unpin;\n\n\t\t \n\t\tret = __sseu_test(name, flags, ce, obj, pg_sseu);\n\t\tif (ret)\n\t\t\tgoto out_unpin;\n\n\t\t \n\t\tret = __sseu_test(name, flags, ce, obj, engine->sseu);\n\t\tif (ret)\n\t\t\tgoto out_unpin;\n\n\t\t \n\t\tret = __sseu_test(name, flags, ce, obj, pg_sseu);\n\t\tif (ret)\n\t\t\tgoto out_unpin;\n\nout_unpin:\n\t\tintel_context_unpin(ce);\nout_ce:\n\t\tintel_context_put(ce);\n\t} while (!ret);\n\n\tif (igt_flush_test(i915))\n\t\tret = -EIO;\n\nout_put:\n\ti915_gem_object_put(obj);\n\nout_unlock:\n\tif (flags & TEST_RESET)\n\t\tigt_global_reset_unlock(to_gt(i915));\n\n\tif (ret)\n\t\tpr_err(\"%s: Failed with %d!\\n\", name, ret);\n\n\treturn ret;\n}\n\nstatic int igt_ctx_sseu(void *arg)\n{\n\tstruct {\n\t\tconst char *name;\n\t\tunsigned int flags;\n\t} *phase, phases[] = {\n\t\t{ .name = \"basic\", .flags = 0 },\n\t\t{ .name = \"idle\", .flags = TEST_IDLE },\n\t\t{ .name = \"busy\", .flags = TEST_BUSY },\n\t\t{ .name = \"busy-reset\", .flags = TEST_BUSY | TEST_RESET },\n\t\t{ .name = \"busy-idle\", .flags = TEST_BUSY | TEST_IDLE },\n\t\t{ .name = \"reset-idle\", .flags = TEST_RESET | TEST_IDLE },\n\t};\n\tunsigned int i;\n\tint ret = 0;\n\n\tfor (i = 0, phase = phases; ret == 0 && i < ARRAY_SIZE(phases);\n\t     i++, phase++)\n\t\tret = __igt_ctx_sseu(arg, phase->name, phase->flags);\n\n\treturn ret;\n}\n\nstatic int igt_ctx_readonly(void *arg)\n{\n\tstruct drm_i915_private *i915 = arg;\n\tunsigned long idx, ndwords, dw, num_engines;\n\tstruct drm_i915_gem_object *obj = NULL;\n\tstruct i915_request *tq[5] = {};\n\tstruct i915_gem_engines_iter it;\n\tstruct i915_address_space *vm;\n\tstruct i915_gem_context *ctx;\n\tstruct intel_context *ce;\n\tstruct igt_live_test t;\n\tI915_RND_STATE(prng);\n\tIGT_TIMEOUT(end_time);\n\tLIST_HEAD(objects);\n\tstruct file *file;\n\tint err = -ENODEV;\n\n\t \n\n\tfile = mock_file(i915);\n\tif (IS_ERR(file))\n\t\treturn PTR_ERR(file);\n\n\terr = igt_live_test_begin(&t, i915, __func__, \"\");\n\tif (err)\n\t\tgoto out_file;\n\n\tctx = live_context(i915, file);\n\tif (IS_ERR(ctx)) {\n\t\terr = PTR_ERR(ctx);\n\t\tgoto out_file;\n\t}\n\n\tvm = ctx->vm ?: &to_gt(i915)->ggtt->alias->vm;\n\tif (!vm || !vm->has_read_only) {\n\t\terr = 0;\n\t\tgoto out_file;\n\t}\n\n\tnum_engines = 0;\n\tfor_each_gem_engine(ce, i915_gem_context_lock_engines(ctx), it)\n\t\tif (intel_engine_can_store_dword(ce->engine))\n\t\t\tnum_engines++;\n\ti915_gem_context_unlock_engines(ctx);\n\n\tndwords = 0;\n\tdw = 0;\n\twhile (!time_after(jiffies, end_time)) {\n\t\tfor_each_gem_engine(ce,\n\t\t\t\t    i915_gem_context_lock_engines(ctx), it) {\n\t\t\tif (!intel_engine_can_store_dword(ce->engine))\n\t\t\t\tcontinue;\n\n\t\t\tif (!obj) {\n\t\t\t\tobj = create_test_object(ce->vm, file, &objects);\n\t\t\t\tif (IS_ERR(obj)) {\n\t\t\t\t\terr = PTR_ERR(obj);\n\t\t\t\t\ti915_gem_context_unlock_engines(ctx);\n\t\t\t\t\tgoto out_file;\n\t\t\t\t}\n\n\t\t\t\tif (prandom_u32_state(&prng) & 1)\n\t\t\t\t\ti915_gem_object_set_readonly(obj);\n\t\t\t}\n\n\t\t\terr = gpu_fill(ce, obj, dw);\n\t\t\tif (err) {\n\t\t\t\tpr_err(\"Failed to fill dword %lu [%lu/%lu] with gpu (%s) [full-ppgtt? %s], err=%d\\n\",\n\t\t\t\t       ndwords, dw, max_dwords(obj),\n\t\t\t\t       ce->engine->name,\n\t\t\t\t       str_yes_no(i915_gem_context_has_full_ppgtt(ctx)),\n\t\t\t\t       err);\n\t\t\t\ti915_gem_context_unlock_engines(ctx);\n\t\t\t\tgoto out_file;\n\t\t\t}\n\n\t\t\terr = throttle(ce, tq, ARRAY_SIZE(tq));\n\t\t\tif (err) {\n\t\t\t\ti915_gem_context_unlock_engines(ctx);\n\t\t\t\tgoto out_file;\n\t\t\t}\n\n\t\t\tif (++dw == max_dwords(obj)) {\n\t\t\t\tobj = NULL;\n\t\t\t\tdw = 0;\n\t\t\t}\n\t\t\tndwords++;\n\t\t}\n\t\ti915_gem_context_unlock_engines(ctx);\n\t}\n\tpr_info(\"Submitted %lu dwords (across %lu engines)\\n\",\n\t\tndwords, num_engines);\n\n\tdw = 0;\n\tidx = 0;\n\tlist_for_each_entry(obj, &objects, st_link) {\n\t\tunsigned int rem =\n\t\t\tmin_t(unsigned int, ndwords - dw, max_dwords(obj));\n\t\tunsigned int num_writes;\n\n\t\tnum_writes = rem;\n\t\tif (i915_gem_object_is_readonly(obj))\n\t\t\tnum_writes = 0;\n\n\t\terr = cpu_check(obj, idx++, num_writes);\n\t\tif (err)\n\t\t\tbreak;\n\n\t\tdw += rem;\n\t}\n\nout_file:\n\tthrottle_release(tq, ARRAY_SIZE(tq));\n\tif (igt_live_test_end(&t))\n\t\terr = -EIO;\n\n\tfput(file);\n\treturn err;\n}\n\nstatic int check_scratch(struct i915_address_space *vm, u64 offset)\n{\n\tstruct drm_mm_node *node;\n\n\tmutex_lock(&vm->mutex);\n\tnode = __drm_mm_interval_first(&vm->mm,\n\t\t\t\t       offset, offset + sizeof(u32) - 1);\n\tmutex_unlock(&vm->mutex);\n\tif (!node || node->start > offset)\n\t\treturn 0;\n\n\tGEM_BUG_ON(offset >= node->start + node->size);\n\n\tpr_err(\"Target offset 0x%08x_%08x overlaps with a node in the mm!\\n\",\n\t       upper_32_bits(offset), lower_32_bits(offset));\n\treturn -EINVAL;\n}\n\nstatic int write_to_scratch(struct i915_gem_context *ctx,\n\t\t\t    struct intel_engine_cs *engine,\n\t\t\t    struct drm_i915_gem_object *obj,\n\t\t\t    u64 offset, u32 value)\n{\n\tstruct drm_i915_private *i915 = ctx->i915;\n\tstruct i915_address_space *vm;\n\tstruct i915_request *rq;\n\tstruct i915_vma *vma;\n\tu32 *cmd;\n\tint err;\n\n\tGEM_BUG_ON(offset < I915_GTT_PAGE_SIZE);\n\n\terr = check_scratch(ctx->vm, offset);\n\tif (err)\n\t\treturn err;\n\n\tcmd = i915_gem_object_pin_map_unlocked(obj, I915_MAP_WB);\n\tif (IS_ERR(cmd))\n\t\treturn PTR_ERR(cmd);\n\n\t*cmd++ = MI_STORE_DWORD_IMM_GEN4;\n\tif (GRAPHICS_VER(i915) >= 8) {\n\t\t*cmd++ = lower_32_bits(offset);\n\t\t*cmd++ = upper_32_bits(offset);\n\t} else {\n\t\t*cmd++ = 0;\n\t\t*cmd++ = offset;\n\t}\n\t*cmd++ = value;\n\t*cmd = MI_BATCH_BUFFER_END;\n\t__i915_gem_object_flush_map(obj, 0, 64);\n\ti915_gem_object_unpin_map(obj);\n\n\tintel_gt_chipset_flush(engine->gt);\n\n\tvm = i915_gem_context_get_eb_vm(ctx);\n\tvma = i915_vma_instance(obj, vm, NULL);\n\tif (IS_ERR(vma)) {\n\t\terr = PTR_ERR(vma);\n\t\tgoto out_vm;\n\t}\n\n\terr = i915_vma_pin(vma, 0, 0, PIN_USER | PIN_OFFSET_FIXED);\n\tif (err)\n\t\tgoto out_vm;\n\n\trq = igt_request_alloc(ctx, engine);\n\tif (IS_ERR(rq)) {\n\t\terr = PTR_ERR(rq);\n\t\tgoto err_unpin;\n\t}\n\n\terr = igt_vma_move_to_active_unlocked(vma, rq, 0);\n\tif (err)\n\t\tgoto skip_request;\n\n\tif (rq->engine->emit_init_breadcrumb) {\n\t\terr = rq->engine->emit_init_breadcrumb(rq);\n\t\tif (err)\n\t\t\tgoto skip_request;\n\t}\n\n\terr = engine->emit_bb_start(rq, i915_vma_offset(vma),\n\t\t\t\t    i915_vma_size(vma), 0);\n\tif (err)\n\t\tgoto skip_request;\n\n\ti915_vma_unpin(vma);\n\n\ti915_request_add(rq);\n\n\tgoto out_vm;\nskip_request:\n\ti915_request_set_error_once(rq, err);\n\ti915_request_add(rq);\nerr_unpin:\n\ti915_vma_unpin(vma);\nout_vm:\n\ti915_vm_put(vm);\n\n\tif (!err)\n\t\terr = i915_gem_object_wait(obj, 0, MAX_SCHEDULE_TIMEOUT);\n\n\treturn err;\n}\n\nstatic int read_from_scratch(struct i915_gem_context *ctx,\n\t\t\t     struct intel_engine_cs *engine,\n\t\t\t     struct drm_i915_gem_object *obj,\n\t\t\t     u64 offset, u32 *value)\n{\n\tstruct drm_i915_private *i915 = ctx->i915;\n\tstruct i915_address_space *vm;\n\tconst u32 result = 0x100;\n\tstruct i915_request *rq;\n\tstruct i915_vma *vma;\n\tunsigned int flags;\n\tu32 *cmd;\n\tint err;\n\n\tGEM_BUG_ON(offset < I915_GTT_PAGE_SIZE);\n\n\terr = check_scratch(ctx->vm, offset);\n\tif (err)\n\t\treturn err;\n\n\tif (GRAPHICS_VER(i915) >= 8) {\n\t\tconst u32 GPR0 = engine->mmio_base + 0x600;\n\n\t\tvm = i915_gem_context_get_eb_vm(ctx);\n\t\tvma = i915_vma_instance(obj, vm, NULL);\n\t\tif (IS_ERR(vma)) {\n\t\t\terr = PTR_ERR(vma);\n\t\t\tgoto out_vm;\n\t\t}\n\n\t\terr = i915_vma_pin(vma, 0, 0, PIN_USER | PIN_OFFSET_FIXED);\n\t\tif (err)\n\t\t\tgoto out_vm;\n\n\t\tcmd = i915_gem_object_pin_map_unlocked(obj, I915_MAP_WB);\n\t\tif (IS_ERR(cmd)) {\n\t\t\terr = PTR_ERR(cmd);\n\t\t\tgoto err_unpin;\n\t\t}\n\n\t\tmemset(cmd, POISON_INUSE, PAGE_SIZE);\n\t\t*cmd++ = MI_LOAD_REGISTER_MEM_GEN8;\n\t\t*cmd++ = GPR0;\n\t\t*cmd++ = lower_32_bits(offset);\n\t\t*cmd++ = upper_32_bits(offset);\n\t\t*cmd++ = MI_STORE_REGISTER_MEM_GEN8;\n\t\t*cmd++ = GPR0;\n\t\t*cmd++ = result;\n\t\t*cmd++ = 0;\n\t\t*cmd = MI_BATCH_BUFFER_END;\n\n\t\ti915_gem_object_flush_map(obj);\n\t\ti915_gem_object_unpin_map(obj);\n\n\t\tflags = 0;\n\t} else {\n\t\tconst u32 reg = engine->mmio_base + 0x420;\n\n\t\t \n\t\tvm = i915_vm_get(&engine->gt->ggtt->vm);\n\t\tvma = i915_vma_instance(obj, vm, NULL);\n\t\tif (IS_ERR(vma)) {\n\t\t\terr = PTR_ERR(vma);\n\t\t\tgoto out_vm;\n\t\t}\n\n\t\terr = i915_vma_pin(vma, 0, 0, PIN_GLOBAL);\n\t\tif (err)\n\t\t\tgoto out_vm;\n\n\t\tcmd = i915_gem_object_pin_map_unlocked(obj, I915_MAP_WB);\n\t\tif (IS_ERR(cmd)) {\n\t\t\terr = PTR_ERR(cmd);\n\t\t\tgoto err_unpin;\n\t\t}\n\n\t\tmemset(cmd, POISON_INUSE, PAGE_SIZE);\n\t\t*cmd++ = MI_LOAD_REGISTER_MEM;\n\t\t*cmd++ = reg;\n\t\t*cmd++ = offset;\n\t\t*cmd++ = MI_STORE_REGISTER_MEM | MI_USE_GGTT;\n\t\t*cmd++ = reg;\n\t\t*cmd++ = i915_vma_offset(vma) + result;\n\t\t*cmd = MI_BATCH_BUFFER_END;\n\n\t\ti915_gem_object_flush_map(obj);\n\t\ti915_gem_object_unpin_map(obj);\n\n\t\tflags = I915_DISPATCH_SECURE;\n\t}\n\n\tintel_gt_chipset_flush(engine->gt);\n\n\trq = igt_request_alloc(ctx, engine);\n\tif (IS_ERR(rq)) {\n\t\terr = PTR_ERR(rq);\n\t\tgoto err_unpin;\n\t}\n\n\terr = igt_vma_move_to_active_unlocked(vma, rq, EXEC_OBJECT_WRITE);\n\tif (err)\n\t\tgoto skip_request;\n\n\tif (rq->engine->emit_init_breadcrumb) {\n\t\terr = rq->engine->emit_init_breadcrumb(rq);\n\t\tif (err)\n\t\t\tgoto skip_request;\n\t}\n\n\terr = engine->emit_bb_start(rq, i915_vma_offset(vma),\n\t\t\t\t    i915_vma_size(vma), flags);\n\tif (err)\n\t\tgoto skip_request;\n\n\ti915_vma_unpin(vma);\n\n\ti915_request_add(rq);\n\n\ti915_gem_object_lock(obj, NULL);\n\terr = i915_gem_object_set_to_cpu_domain(obj, false);\n\ti915_gem_object_unlock(obj);\n\tif (err)\n\t\tgoto out_vm;\n\n\tcmd = i915_gem_object_pin_map_unlocked(obj, I915_MAP_WB);\n\tif (IS_ERR(cmd)) {\n\t\terr = PTR_ERR(cmd);\n\t\tgoto out_vm;\n\t}\n\n\t*value = cmd[result / sizeof(*cmd)];\n\ti915_gem_object_unpin_map(obj);\n\n\tgoto out_vm;\nskip_request:\n\ti915_request_set_error_once(rq, err);\n\ti915_request_add(rq);\nerr_unpin:\n\ti915_vma_unpin(vma);\nout_vm:\n\ti915_vm_put(vm);\n\n\tif (!err)\n\t\terr = i915_gem_object_wait(obj, 0, MAX_SCHEDULE_TIMEOUT);\n\n\treturn err;\n}\n\nstatic int check_scratch_page(struct i915_gem_context *ctx, u32 *out)\n{\n\tstruct i915_address_space *vm;\n\tu32 *vaddr;\n\tint err = 0;\n\n\tvm = ctx->vm;\n\tif (!vm)\n\t\treturn -ENODEV;\n\n\tif (!vm->scratch[0]) {\n\t\tpr_err(\"No scratch page!\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tvaddr = __px_vaddr(vm->scratch[0]);\n\n\tmemcpy(out, vaddr, sizeof(*out));\n\tif (memchr_inv(vaddr, *out, PAGE_SIZE)) {\n\t\tpr_err(\"Inconsistent initial state of scratch page!\\n\");\n\t\terr = -EINVAL;\n\t}\n\n\treturn err;\n}\n\nstatic int igt_vm_isolation(void *arg)\n{\n\tstruct drm_i915_private *i915 = arg;\n\tstruct i915_gem_context *ctx_a, *ctx_b;\n\tstruct drm_i915_gem_object *obj_a, *obj_b;\n\tunsigned long num_engines, count;\n\tstruct intel_engine_cs *engine;\n\tstruct igt_live_test t;\n\tI915_RND_STATE(prng);\n\tstruct file *file;\n\tu64 vm_total;\n\tu32 expected;\n\tint err;\n\n\tif (GRAPHICS_VER(i915) < 7)\n\t\treturn 0;\n\n\t \n\n\tfile = mock_file(i915);\n\tif (IS_ERR(file))\n\t\treturn PTR_ERR(file);\n\n\terr = igt_live_test_begin(&t, i915, __func__, \"\");\n\tif (err)\n\t\tgoto out_file;\n\n\tctx_a = live_context(i915, file);\n\tif (IS_ERR(ctx_a)) {\n\t\terr = PTR_ERR(ctx_a);\n\t\tgoto out_file;\n\t}\n\n\tctx_b = live_context(i915, file);\n\tif (IS_ERR(ctx_b)) {\n\t\terr = PTR_ERR(ctx_b);\n\t\tgoto out_file;\n\t}\n\n\t \n\tif (ctx_a->vm == ctx_b->vm)\n\t\tgoto out_file;\n\n\t \n\terr = check_scratch_page(ctx_a, &expected);\n\tif (err)\n\t\tgoto out_file;\n\n\terr = check_scratch_page(ctx_b, &expected);\n\tif (err)\n\t\tgoto out_file;\n\n\tvm_total = ctx_a->vm->total;\n\tGEM_BUG_ON(ctx_b->vm->total != vm_total);\n\n\tobj_a = i915_gem_object_create_internal(i915, PAGE_SIZE);\n\tif (IS_ERR(obj_a)) {\n\t\terr = PTR_ERR(obj_a);\n\t\tgoto out_file;\n\t}\n\n\tobj_b = i915_gem_object_create_internal(i915, PAGE_SIZE);\n\tif (IS_ERR(obj_b)) {\n\t\terr = PTR_ERR(obj_b);\n\t\tgoto put_a;\n\t}\n\n\tcount = 0;\n\tnum_engines = 0;\n\tfor_each_uabi_engine(engine, i915) {\n\t\tIGT_TIMEOUT(end_time);\n\t\tunsigned long this = 0;\n\n\t\tif (!intel_engine_can_store_dword(engine))\n\t\t\tcontinue;\n\n\t\t \n\t\tif (GRAPHICS_VER(i915) < 8 && engine->class != RENDER_CLASS)\n\t\t\tcontinue;\n\n\t\twhile (!__igt_timeout(end_time, NULL)) {\n\t\t\tu32 value = 0xc5c5c5c5;\n\t\t\tu64 offset;\n\n\t\t\t \n\t\t\toffset = igt_random_offset(&prng,\n\t\t\t\t\t\t   I915_GTT_PAGE_SIZE, vm_total,\n\t\t\t\t\t\t   sizeof(u32), alignof_dword);\n\n\t\t\terr = write_to_scratch(ctx_a, engine, obj_a,\n\t\t\t\t\t       offset, 0xdeadbeef);\n\t\t\tif (err == 0)\n\t\t\t\terr = read_from_scratch(ctx_b, engine, obj_b,\n\t\t\t\t\t\t\toffset, &value);\n\t\t\tif (err)\n\t\t\t\tgoto put_b;\n\n\t\t\tif (value != expected) {\n\t\t\t\tpr_err(\"%s: Read %08x from scratch (offset 0x%08x_%08x), after %lu reads!\\n\",\n\t\t\t\t       engine->name, value,\n\t\t\t\t       upper_32_bits(offset),\n\t\t\t\t       lower_32_bits(offset),\n\t\t\t\t       this);\n\t\t\t\terr = -EINVAL;\n\t\t\t\tgoto put_b;\n\t\t\t}\n\n\t\t\tthis++;\n\t\t}\n\t\tcount += this;\n\t\tnum_engines++;\n\t}\n\tpr_info(\"Checked %lu scratch offsets across %lu engines\\n\",\n\t\tcount, num_engines);\n\nput_b:\n\ti915_gem_object_put(obj_b);\nput_a:\n\ti915_gem_object_put(obj_a);\nout_file:\n\tif (igt_live_test_end(&t))\n\t\terr = -EIO;\n\tfput(file);\n\treturn err;\n}\n\nint i915_gem_context_live_selftests(struct drm_i915_private *i915)\n{\n\tstatic const struct i915_subtest tests[] = {\n\t\tSUBTEST(live_nop_switch),\n\t\tSUBTEST(live_parallel_switch),\n\t\tSUBTEST(igt_ctx_exec),\n\t\tSUBTEST(igt_ctx_readonly),\n\t\tSUBTEST(igt_ctx_sseu),\n\t\tSUBTEST(igt_shared_ctx_exec),\n\t\tSUBTEST(igt_vm_isolation),\n\t};\n\n\tif (intel_gt_is_wedged(to_gt(i915)))\n\t\treturn 0;\n\n\treturn i915_live_subtests(tests, i915);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}