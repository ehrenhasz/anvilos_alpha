{
  "module_name": "i915_gem_dmabuf.c",
  "hash_id": "00fd204e51c3d46b434310dba4feaea28632f18f50007876e80b8e893f1a584e",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/i915/gem/i915_gem_dmabuf.c",
  "human_readable_source": " \n\n#include <linux/dma-buf.h>\n#include <linux/highmem.h>\n#include <linux/dma-resv.h>\n#include <linux/module.h>\n\n#include <asm/smp.h>\n\n#include \"gem/i915_gem_dmabuf.h\"\n#include \"i915_drv.h\"\n#include \"i915_gem_object.h\"\n#include \"i915_scatterlist.h\"\n\nMODULE_IMPORT_NS(DMA_BUF);\n\nI915_SELFTEST_DECLARE(static bool force_different_devices;)\n\nstatic struct drm_i915_gem_object *dma_buf_to_obj(struct dma_buf *buf)\n{\n\treturn to_intel_bo(buf->priv);\n}\n\nstatic struct sg_table *i915_gem_map_dma_buf(struct dma_buf_attachment *attach,\n\t\t\t\t\t     enum dma_data_direction dir)\n{\n\tstruct drm_i915_gem_object *obj = dma_buf_to_obj(attach->dmabuf);\n\tstruct sg_table *sgt;\n\tstruct scatterlist *src, *dst;\n\tint ret, i;\n\n\t \n\tsgt = kmalloc(sizeof(*sgt), GFP_KERNEL);\n\tif (!sgt) {\n\t\tret = -ENOMEM;\n\t\tgoto err;\n\t}\n\n\tret = sg_alloc_table(sgt, obj->mm.pages->orig_nents, GFP_KERNEL);\n\tif (ret)\n\t\tgoto err_free;\n\n\tdst = sgt->sgl;\n\tfor_each_sg(obj->mm.pages->sgl, src, obj->mm.pages->orig_nents, i) {\n\t\tsg_set_page(dst, sg_page(src), src->length, 0);\n\t\tdst = sg_next(dst);\n\t}\n\n\tret = dma_map_sgtable(attach->dev, sgt, dir, DMA_ATTR_SKIP_CPU_SYNC);\n\tif (ret)\n\t\tgoto err_free_sg;\n\n\treturn sgt;\n\nerr_free_sg:\n\tsg_free_table(sgt);\nerr_free:\n\tkfree(sgt);\nerr:\n\treturn ERR_PTR(ret);\n}\n\nstatic int i915_gem_dmabuf_vmap(struct dma_buf *dma_buf,\n\t\t\t\tstruct iosys_map *map)\n{\n\tstruct drm_i915_gem_object *obj = dma_buf_to_obj(dma_buf);\n\tvoid *vaddr;\n\n\tvaddr = i915_gem_object_pin_map(obj, I915_MAP_WB);\n\tif (IS_ERR(vaddr))\n\t\treturn PTR_ERR(vaddr);\n\n\tiosys_map_set_vaddr(map, vaddr);\n\n\treturn 0;\n}\n\nstatic void i915_gem_dmabuf_vunmap(struct dma_buf *dma_buf,\n\t\t\t\t   struct iosys_map *map)\n{\n\tstruct drm_i915_gem_object *obj = dma_buf_to_obj(dma_buf);\n\n\ti915_gem_object_flush_map(obj);\n\ti915_gem_object_unpin_map(obj);\n}\n\nstatic int i915_gem_dmabuf_mmap(struct dma_buf *dma_buf, struct vm_area_struct *vma)\n{\n\tstruct drm_i915_gem_object *obj = dma_buf_to_obj(dma_buf);\n\tstruct drm_i915_private *i915 = to_i915(obj->base.dev);\n\tint ret;\n\n\tif (obj->base.size < vma->vm_end - vma->vm_start)\n\t\treturn -EINVAL;\n\n\tif (HAS_LMEM(i915))\n\t\treturn drm_gem_prime_mmap(&obj->base, vma);\n\n\tif (!obj->base.filp)\n\t\treturn -ENODEV;\n\n\tret = call_mmap(obj->base.filp, vma);\n\tif (ret)\n\t\treturn ret;\n\n\tvma_set_file(vma, obj->base.filp);\n\n\treturn 0;\n}\n\nstatic int i915_gem_begin_cpu_access(struct dma_buf *dma_buf, enum dma_data_direction direction)\n{\n\tstruct drm_i915_gem_object *obj = dma_buf_to_obj(dma_buf);\n\tbool write = (direction == DMA_BIDIRECTIONAL || direction == DMA_TO_DEVICE);\n\tstruct i915_gem_ww_ctx ww;\n\tint err;\n\n\ti915_gem_ww_ctx_init(&ww, true);\nretry:\n\terr = i915_gem_object_lock(obj, &ww);\n\tif (!err)\n\t\terr = i915_gem_object_pin_pages(obj);\n\tif (!err) {\n\t\terr = i915_gem_object_set_to_cpu_domain(obj, write);\n\t\ti915_gem_object_unpin_pages(obj);\n\t}\n\tif (err == -EDEADLK) {\n\t\terr = i915_gem_ww_ctx_backoff(&ww);\n\t\tif (!err)\n\t\t\tgoto retry;\n\t}\n\ti915_gem_ww_ctx_fini(&ww);\n\treturn err;\n}\n\nstatic int i915_gem_end_cpu_access(struct dma_buf *dma_buf, enum dma_data_direction direction)\n{\n\tstruct drm_i915_gem_object *obj = dma_buf_to_obj(dma_buf);\n\tstruct i915_gem_ww_ctx ww;\n\tint err;\n\n\ti915_gem_ww_ctx_init(&ww, true);\nretry:\n\terr = i915_gem_object_lock(obj, &ww);\n\tif (!err)\n\t\terr = i915_gem_object_pin_pages(obj);\n\tif (!err) {\n\t\terr = i915_gem_object_set_to_gtt_domain(obj, false);\n\t\ti915_gem_object_unpin_pages(obj);\n\t}\n\tif (err == -EDEADLK) {\n\t\terr = i915_gem_ww_ctx_backoff(&ww);\n\t\tif (!err)\n\t\t\tgoto retry;\n\t}\n\ti915_gem_ww_ctx_fini(&ww);\n\treturn err;\n}\n\nstatic int i915_gem_dmabuf_attach(struct dma_buf *dmabuf,\n\t\t\t\t  struct dma_buf_attachment *attach)\n{\n\tstruct drm_i915_gem_object *obj = dma_buf_to_obj(dmabuf);\n\tstruct i915_gem_ww_ctx ww;\n\tint err;\n\n\tif (!i915_gem_object_can_migrate(obj, INTEL_REGION_SMEM))\n\t\treturn -EOPNOTSUPP;\n\n\tfor_i915_gem_ww(&ww, err, true) {\n\t\terr = i915_gem_object_lock(obj, &ww);\n\t\tif (err)\n\t\t\tcontinue;\n\n\t\terr = i915_gem_object_migrate(obj, &ww, INTEL_REGION_SMEM);\n\t\tif (err)\n\t\t\tcontinue;\n\n\t\terr = i915_gem_object_wait_migration(obj, 0);\n\t\tif (err)\n\t\t\tcontinue;\n\n\t\terr = i915_gem_object_pin_pages(obj);\n\t}\n\n\treturn err;\n}\n\nstatic void i915_gem_dmabuf_detach(struct dma_buf *dmabuf,\n\t\t\t\t   struct dma_buf_attachment *attach)\n{\n\tstruct drm_i915_gem_object *obj = dma_buf_to_obj(dmabuf);\n\n\ti915_gem_object_unpin_pages(obj);\n}\n\nstatic const struct dma_buf_ops i915_dmabuf_ops =  {\n\t.attach = i915_gem_dmabuf_attach,\n\t.detach = i915_gem_dmabuf_detach,\n\t.map_dma_buf = i915_gem_map_dma_buf,\n\t.unmap_dma_buf = drm_gem_unmap_dma_buf,\n\t.release = drm_gem_dmabuf_release,\n\t.mmap = i915_gem_dmabuf_mmap,\n\t.vmap = i915_gem_dmabuf_vmap,\n\t.vunmap = i915_gem_dmabuf_vunmap,\n\t.begin_cpu_access = i915_gem_begin_cpu_access,\n\t.end_cpu_access = i915_gem_end_cpu_access,\n};\n\nstruct dma_buf *i915_gem_prime_export(struct drm_gem_object *gem_obj, int flags)\n{\n\tstruct drm_i915_gem_object *obj = to_intel_bo(gem_obj);\n\tDEFINE_DMA_BUF_EXPORT_INFO(exp_info);\n\n\texp_info.ops = &i915_dmabuf_ops;\n\texp_info.size = gem_obj->size;\n\texp_info.flags = flags;\n\texp_info.priv = gem_obj;\n\texp_info.resv = obj->base.resv;\n\n\tif (obj->ops->dmabuf_export) {\n\t\tint ret = obj->ops->dmabuf_export(obj);\n\t\tif (ret)\n\t\t\treturn ERR_PTR(ret);\n\t}\n\n\treturn drm_gem_dmabuf_export(gem_obj->dev, &exp_info);\n}\n\nstatic int i915_gem_object_get_pages_dmabuf(struct drm_i915_gem_object *obj)\n{\n\tstruct drm_i915_private *i915 = to_i915(obj->base.dev);\n\tstruct sg_table *sgt;\n\n\tassert_object_held(obj);\n\n\tsgt = dma_buf_map_attachment(obj->base.import_attach,\n\t\t\t\t     DMA_BIDIRECTIONAL);\n\tif (IS_ERR(sgt))\n\t\treturn PTR_ERR(sgt);\n\n\t \n\tif (i915_gem_object_can_bypass_llc(obj) ||\n\t    (!HAS_LLC(i915) && !IS_DG1(i915)))\n\t\twbinvd_on_all_cpus();\n\n\t__i915_gem_object_set_pages(obj, sgt);\n\n\treturn 0;\n}\n\nstatic void i915_gem_object_put_pages_dmabuf(struct drm_i915_gem_object *obj,\n\t\t\t\t\t     struct sg_table *sgt)\n{\n\tdma_buf_unmap_attachment(obj->base.import_attach, sgt,\n\t\t\t\t DMA_BIDIRECTIONAL);\n}\n\nstatic const struct drm_i915_gem_object_ops i915_gem_object_dmabuf_ops = {\n\t.name = \"i915_gem_object_dmabuf\",\n\t.get_pages = i915_gem_object_get_pages_dmabuf,\n\t.put_pages = i915_gem_object_put_pages_dmabuf,\n};\n\nstruct drm_gem_object *i915_gem_prime_import(struct drm_device *dev,\n\t\t\t\t\t     struct dma_buf *dma_buf)\n{\n\tstatic struct lock_class_key lock_class;\n\tstruct dma_buf_attachment *attach;\n\tstruct drm_i915_gem_object *obj;\n\tint ret;\n\n\t \n\tif (dma_buf->ops == &i915_dmabuf_ops) {\n\t\tobj = dma_buf_to_obj(dma_buf);\n\t\t \n\t\tif (obj->base.dev == dev &&\n\t\t    !I915_SELFTEST_ONLY(force_different_devices)) {\n\t\t\t \n\t\t\treturn &i915_gem_object_get(obj)->base;\n\t\t}\n\t}\n\n\tif (i915_gem_object_size_2big(dma_buf->size))\n\t\treturn ERR_PTR(-E2BIG);\n\n\t \n\tattach = dma_buf_attach(dma_buf, dev->dev);\n\tif (IS_ERR(attach))\n\t\treturn ERR_CAST(attach);\n\n\tget_dma_buf(dma_buf);\n\n\tobj = i915_gem_object_alloc();\n\tif (!obj) {\n\t\tret = -ENOMEM;\n\t\tgoto fail_detach;\n\t}\n\n\tdrm_gem_private_object_init(dev, &obj->base, dma_buf->size);\n\ti915_gem_object_init(obj, &i915_gem_object_dmabuf_ops, &lock_class,\n\t\t\t     I915_BO_ALLOC_USER);\n\tobj->base.import_attach = attach;\n\tobj->base.resv = dma_buf->resv;\n\n\t \n\tobj->read_domains = I915_GEM_DOMAIN_GTT;\n\tobj->write_domain = 0;\n\n\treturn &obj->base;\n\nfail_detach:\n\tdma_buf_detach(dma_buf, attach);\n\tdma_buf_put(dma_buf);\n\n\treturn ERR_PTR(ret);\n}\n\n#if IS_ENABLED(CONFIG_DRM_I915_SELFTEST)\n#include \"selftests/mock_dmabuf.c\"\n#include \"selftests/i915_gem_dmabuf.c\"\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}