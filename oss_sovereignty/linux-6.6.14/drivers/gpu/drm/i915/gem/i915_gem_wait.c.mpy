{
  "module_name": "i915_gem_wait.c",
  "hash_id": "28725cd1e482d615b01d36f0394b8149477db2d22157ad3f26ad638ce5d9991b",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/i915/gem/i915_gem_wait.c",
  "human_readable_source": " \n\n#include <linux/dma-fence-array.h>\n#include <linux/dma-fence-chain.h>\n#include <linux/jiffies.h>\n\n#include \"gt/intel_engine.h\"\n#include \"gt/intel_rps.h\"\n\n#include \"i915_gem_ioctls.h\"\n#include \"i915_gem_object.h\"\n\nstatic long\ni915_gem_object_wait_fence(struct dma_fence *fence,\n\t\t\t   unsigned int flags,\n\t\t\t   long timeout)\n{\n\tBUILD_BUG_ON(I915_WAIT_INTERRUPTIBLE != 0x1);\n\n\tif (test_bit(DMA_FENCE_FLAG_SIGNALED_BIT, &fence->flags))\n\t\treturn timeout;\n\n\tif (dma_fence_is_i915(fence))\n\t\treturn i915_request_wait_timeout(to_request(fence), flags, timeout);\n\n\treturn dma_fence_wait_timeout(fence,\n\t\t\t\t      flags & I915_WAIT_INTERRUPTIBLE,\n\t\t\t\t      timeout);\n}\n\nstatic void\ni915_gem_object_boost(struct dma_resv *resv, unsigned int flags)\n{\n\tstruct dma_resv_iter cursor;\n\tstruct dma_fence *fence;\n\n\t \n\n\tdma_resv_iter_begin(&cursor, resv,\n\t\t\t    dma_resv_usage_rw(flags & I915_WAIT_ALL));\n\tdma_resv_for_each_fence_unlocked(&cursor, fence)\n\t\tif (dma_fence_is_i915(fence) &&\n\t\t    !i915_request_started(to_request(fence)))\n\t\t\tintel_rps_boost(to_request(fence));\n\tdma_resv_iter_end(&cursor);\n}\n\nstatic long\ni915_gem_object_wait_reservation(struct dma_resv *resv,\n\t\t\t\t unsigned int flags,\n\t\t\t\t long timeout)\n{\n\tstruct dma_resv_iter cursor;\n\tstruct dma_fence *fence;\n\tlong ret = timeout ?: 1;\n\n\ti915_gem_object_boost(resv, flags);\n\n\tdma_resv_iter_begin(&cursor, resv,\n\t\t\t    dma_resv_usage_rw(flags & I915_WAIT_ALL));\n\tdma_resv_for_each_fence_unlocked(&cursor, fence) {\n\t\tret = i915_gem_object_wait_fence(fence, flags, timeout);\n\t\tif (ret <= 0)\n\t\t\tbreak;\n\n\t\tif (timeout)\n\t\t\ttimeout = ret;\n\t}\n\tdma_resv_iter_end(&cursor);\n\n\treturn ret;\n}\n\nstatic void fence_set_priority(struct dma_fence *fence,\n\t\t\t       const struct i915_sched_attr *attr)\n{\n\tstruct i915_request *rq;\n\tstruct intel_engine_cs *engine;\n\n\tif (dma_fence_is_signaled(fence) || !dma_fence_is_i915(fence))\n\t\treturn;\n\n\trq = to_request(fence);\n\tengine = rq->engine;\n\n\trcu_read_lock();  \n\tif (engine->sched_engine->schedule)\n\t\tengine->sched_engine->schedule(rq, attr);\n\trcu_read_unlock();\n}\n\nstatic inline bool __dma_fence_is_chain(const struct dma_fence *fence)\n{\n\treturn fence->ops == &dma_fence_chain_ops;\n}\n\nvoid i915_gem_fence_wait_priority(struct dma_fence *fence,\n\t\t\t\t  const struct i915_sched_attr *attr)\n{\n\tif (dma_fence_is_signaled(fence))\n\t\treturn;\n\n\tlocal_bh_disable();\n\n\t \n\tif (dma_fence_is_array(fence)) {\n\t\tstruct dma_fence_array *array = to_dma_fence_array(fence);\n\t\tint i;\n\n\t\tfor (i = 0; i < array->num_fences; i++)\n\t\t\tfence_set_priority(array->fences[i], attr);\n\t} else if (__dma_fence_is_chain(fence)) {\n\t\tstruct dma_fence *iter;\n\n\t\t \n\t\tdma_fence_chain_for_each(iter, fence) {\n\t\t\tfence_set_priority(to_dma_fence_chain(iter)->fence,\n\t\t\t\t\t   attr);\n\t\t\tbreak;\n\t\t}\n\t\tdma_fence_put(iter);\n\t} else {\n\t\tfence_set_priority(fence, attr);\n\t}\n\n\tlocal_bh_enable();  \n}\n\nint\ni915_gem_object_wait_priority(struct drm_i915_gem_object *obj,\n\t\t\t      unsigned int flags,\n\t\t\t      const struct i915_sched_attr *attr)\n{\n\tstruct dma_resv_iter cursor;\n\tstruct dma_fence *fence;\n\n\tdma_resv_iter_begin(&cursor, obj->base.resv,\n\t\t\t    dma_resv_usage_rw(flags & I915_WAIT_ALL));\n\tdma_resv_for_each_fence_unlocked(&cursor, fence)\n\t\ti915_gem_fence_wait_priority(fence, attr);\n\tdma_resv_iter_end(&cursor);\n\treturn 0;\n}\n\n \nint\ni915_gem_object_wait(struct drm_i915_gem_object *obj,\n\t\t     unsigned int flags,\n\t\t     long timeout)\n{\n\tmight_sleep();\n\tGEM_BUG_ON(timeout < 0);\n\n\ttimeout = i915_gem_object_wait_reservation(obj->base.resv,\n\t\t\t\t\t\t   flags, timeout);\n\n\tif (timeout < 0)\n\t\treturn timeout;\n\n\treturn !timeout ? -ETIME : 0;\n}\n\nstatic inline unsigned long nsecs_to_jiffies_timeout(const u64 n)\n{\n\t \n\tif ((NSEC_PER_SEC % HZ) != 0 &&\n\t    div_u64(n, NSEC_PER_SEC) >= MAX_JIFFY_OFFSET / HZ)\n\t\treturn MAX_JIFFY_OFFSET;\n\n\treturn min_t(u64, MAX_JIFFY_OFFSET, nsecs_to_jiffies64(n) + 1);\n}\n\nstatic unsigned long to_wait_timeout(s64 timeout_ns)\n{\n\tif (timeout_ns < 0)\n\t\treturn MAX_SCHEDULE_TIMEOUT;\n\n\tif (timeout_ns == 0)\n\t\treturn 0;\n\n\treturn nsecs_to_jiffies_timeout(timeout_ns);\n}\n\n \nint\ni915_gem_wait_ioctl(struct drm_device *dev, void *data, struct drm_file *file)\n{\n\tstruct drm_i915_gem_wait *args = data;\n\tstruct drm_i915_gem_object *obj;\n\tktime_t start;\n\tlong ret;\n\n\tif (args->flags != 0)\n\t\treturn -EINVAL;\n\n\tobj = i915_gem_object_lookup(file, args->bo_handle);\n\tif (!obj)\n\t\treturn -ENOENT;\n\n\tstart = ktime_get();\n\n\tret = i915_gem_object_wait(obj,\n\t\t\t\t   I915_WAIT_INTERRUPTIBLE |\n\t\t\t\t   I915_WAIT_PRIORITY |\n\t\t\t\t   I915_WAIT_ALL,\n\t\t\t\t   to_wait_timeout(args->timeout_ns));\n\n\tif (args->timeout_ns > 0) {\n\t\targs->timeout_ns -= ktime_to_ns(ktime_sub(ktime_get(), start));\n\t\tif (args->timeout_ns < 0)\n\t\t\targs->timeout_ns = 0;\n\n\t\t \n\t\tif (ret == -ETIME && !nsecs_to_jiffies(args->timeout_ns))\n\t\t\targs->timeout_ns = 0;\n\n\t\t \n\t\tif (ret == -ETIME && args->timeout_ns)\n\t\t\tret = -EAGAIN;\n\t}\n\n\ti915_gem_object_put(obj);\n\treturn ret;\n}\n\n \nint i915_gem_object_wait_migration(struct drm_i915_gem_object *obj,\n\t\t\t\t   unsigned int flags)\n{\n\tmight_sleep();\n\n\treturn i915_gem_object_wait_moving_fence(obj, !!(flags & I915_WAIT_INTERRUPTIBLE));\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}