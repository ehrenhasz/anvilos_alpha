{
  "module_name": "i915_gem_create.c",
  "hash_id": "190099ca5c1cdd4ea47e34dbbaf240e1172591496041f132b084b5076b5995fd",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/i915/gem/i915_gem_create.c",
  "human_readable_source": "\n \n\n#include <drm/drm_fourcc.h>\n\n#include \"display/intel_display.h\"\n#include \"gem/i915_gem_ioctls.h\"\n#include \"gem/i915_gem_lmem.h\"\n#include \"gem/i915_gem_region.h\"\n#include \"pxp/intel_pxp.h\"\n\n#include \"i915_drv.h\"\n#include \"i915_gem_create.h\"\n#include \"i915_trace.h\"\n#include \"i915_user_extensions.h\"\n\nstatic u32 object_max_page_size(struct intel_memory_region **placements,\n\t\t\t\tunsigned int n_placements)\n{\n\tu32 max_page_size = 0;\n\tint i;\n\n\tfor (i = 0; i < n_placements; i++) {\n\t\tstruct intel_memory_region *mr = placements[i];\n\n\t\tGEM_BUG_ON(!is_power_of_2(mr->min_page_size));\n\t\tmax_page_size = max_t(u32, max_page_size, mr->min_page_size);\n\t}\n\n\tGEM_BUG_ON(!max_page_size);\n\treturn max_page_size;\n}\n\nstatic int object_set_placements(struct drm_i915_gem_object *obj,\n\t\t\t\t struct intel_memory_region **placements,\n\t\t\t\t unsigned int n_placements)\n{\n\tstruct intel_memory_region **arr;\n\tunsigned int i;\n\n\tGEM_BUG_ON(!n_placements);\n\n\t \n\tif (n_placements == 1) {\n\t\tstruct intel_memory_region *mr = placements[0];\n\t\tstruct drm_i915_private *i915 = mr->i915;\n\n\t\tobj->mm.placements = &i915->mm.regions[mr->id];\n\t\tobj->mm.n_placements = 1;\n\t} else {\n\t\tarr = kmalloc_array(n_placements,\n\t\t\t\t    sizeof(struct intel_memory_region *),\n\t\t\t\t    GFP_KERNEL);\n\t\tif (!arr)\n\t\t\treturn -ENOMEM;\n\n\t\tfor (i = 0; i < n_placements; i++)\n\t\t\tarr[i] = placements[i];\n\n\t\tobj->mm.placements = arr;\n\t\tobj->mm.n_placements = n_placements;\n\t}\n\n\treturn 0;\n}\n\nstatic int i915_gem_publish(struct drm_i915_gem_object *obj,\n\t\t\t    struct drm_file *file,\n\t\t\t    u64 *size_p,\n\t\t\t    u32 *handle_p)\n{\n\tu64 size = obj->base.size;\n\tint ret;\n\n\tret = drm_gem_handle_create(file, &obj->base, handle_p);\n\t \n\ti915_gem_object_put(obj);\n\tif (ret)\n\t\treturn ret;\n\n\t*size_p = size;\n\treturn 0;\n}\n\nstatic struct drm_i915_gem_object *\n__i915_gem_object_create_user_ext(struct drm_i915_private *i915, u64 size,\n\t\t\t\t  struct intel_memory_region **placements,\n\t\t\t\t  unsigned int n_placements,\n\t\t\t\t  unsigned int ext_flags)\n{\n\tstruct intel_memory_region *mr = placements[0];\n\tstruct drm_i915_gem_object *obj;\n\tunsigned int flags;\n\tint ret;\n\n\ti915_gem_flush_free_objects(i915);\n\n\tsize = round_up(size, object_max_page_size(placements, n_placements));\n\tif (size == 0)\n\t\treturn ERR_PTR(-EINVAL);\n\n\t \n\tGEM_BUG_ON(!IS_ALIGNED(size, PAGE_SIZE));\n\n\tif (i915_gem_object_size_2big(size))\n\t\treturn ERR_PTR(-E2BIG);\n\n\tobj = i915_gem_object_alloc();\n\tif (!obj)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tret = object_set_placements(obj, placements, n_placements);\n\tif (ret)\n\t\tgoto object_free;\n\n\t \n\tflags = I915_BO_ALLOC_USER;\n\n\tret = mr->ops->init_object(mr, obj, I915_BO_INVALID_OFFSET, size, 0, flags);\n\tif (ret)\n\t\tgoto object_free;\n\n\tGEM_BUG_ON(size != obj->base.size);\n\n\t \n\tobj->flags |= ext_flags;\n\n\ttrace_i915_gem_object_create(obj);\n\treturn obj;\n\nobject_free:\n\tif (obj->mm.n_placements > 1)\n\t\tkfree(obj->mm.placements);\n\ti915_gem_object_free(obj);\n\treturn ERR_PTR(ret);\n}\n\n \nstruct drm_i915_gem_object *\n__i915_gem_object_create_user(struct drm_i915_private *i915, u64 size,\n\t\t\t      struct intel_memory_region **placements,\n\t\t\t      unsigned int n_placements)\n{\n\treturn __i915_gem_object_create_user_ext(i915, size, placements,\n\t\t\t\t\t\t n_placements, 0);\n}\n\nint\ni915_gem_dumb_create(struct drm_file *file,\n\t\t     struct drm_device *dev,\n\t\t     struct drm_mode_create_dumb *args)\n{\n\tstruct drm_i915_gem_object *obj;\n\tstruct intel_memory_region *mr;\n\tenum intel_memory_type mem_type;\n\tint cpp = DIV_ROUND_UP(args->bpp, 8);\n\tu32 format;\n\n\tswitch (cpp) {\n\tcase 1:\n\t\tformat = DRM_FORMAT_C8;\n\t\tbreak;\n\tcase 2:\n\t\tformat = DRM_FORMAT_RGB565;\n\t\tbreak;\n\tcase 4:\n\t\tformat = DRM_FORMAT_XRGB8888;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\t \n\targs->pitch = ALIGN(args->width * cpp, 64);\n\n\t \n\tif (args->pitch > intel_plane_fb_max_stride(to_i915(dev), format,\n\t\t\t\t\t\t    DRM_FORMAT_MOD_LINEAR))\n\t\targs->pitch = ALIGN(args->pitch, 4096);\n\n\tif (args->pitch < args->width)\n\t\treturn -EINVAL;\n\n\targs->size = mul_u32_u32(args->pitch, args->height);\n\n\tmem_type = INTEL_MEMORY_SYSTEM;\n\tif (HAS_LMEM(to_i915(dev)))\n\t\tmem_type = INTEL_MEMORY_LOCAL;\n\n\tmr = intel_memory_region_by_type(to_i915(dev), mem_type);\n\n\tobj = __i915_gem_object_create_user(to_i915(dev), args->size, &mr, 1);\n\tif (IS_ERR(obj))\n\t\treturn PTR_ERR(obj);\n\n\treturn i915_gem_publish(obj, file, &args->size, &args->handle);\n}\n\n \nint\ni915_gem_create_ioctl(struct drm_device *dev, void *data,\n\t\t      struct drm_file *file)\n{\n\tstruct drm_i915_private *i915 = to_i915(dev);\n\tstruct drm_i915_gem_create *args = data;\n\tstruct drm_i915_gem_object *obj;\n\tstruct intel_memory_region *mr;\n\n\tmr = intel_memory_region_by_type(i915, INTEL_MEMORY_SYSTEM);\n\n\tobj = __i915_gem_object_create_user(i915, args->size, &mr, 1);\n\tif (IS_ERR(obj))\n\t\treturn PTR_ERR(obj);\n\n\treturn i915_gem_publish(obj, file, &args->size, &args->handle);\n}\n\nstruct create_ext {\n\tstruct drm_i915_private *i915;\n\tstruct intel_memory_region *placements[INTEL_REGION_UNKNOWN];\n\tunsigned int n_placements;\n\tunsigned int placement_mask;\n\tunsigned long flags;\n\tunsigned int pat_index;\n};\n\nstatic void repr_placements(char *buf, size_t size,\n\t\t\t    struct intel_memory_region **placements,\n\t\t\t    int n_placements)\n{\n\tint i;\n\n\tbuf[0] = '\\0';\n\n\tfor (i = 0; i < n_placements; i++) {\n\t\tstruct intel_memory_region *mr = placements[i];\n\t\tint r;\n\n\t\tr = snprintf(buf, size, \"\\n  %s -> { class: %d, inst: %d }\",\n\t\t\t     mr->name, mr->type, mr->instance);\n\t\tif (r >= size)\n\t\t\treturn;\n\n\t\tbuf += r;\n\t\tsize -= r;\n\t}\n}\n\nstatic int set_placements(struct drm_i915_gem_create_ext_memory_regions *args,\n\t\t\t  struct create_ext *ext_data)\n{\n\tstruct drm_i915_private *i915 = ext_data->i915;\n\tstruct drm_i915_gem_memory_class_instance __user *uregions =\n\t\tu64_to_user_ptr(args->regions);\n\tstruct intel_memory_region *placements[INTEL_REGION_UNKNOWN];\n\tu32 mask;\n\tint i, ret = 0;\n\n\tif (args->pad) {\n\t\tdrm_dbg(&i915->drm, \"pad should be zero\\n\");\n\t\tret = -EINVAL;\n\t}\n\n\tif (!args->num_regions) {\n\t\tdrm_dbg(&i915->drm, \"num_regions is zero\\n\");\n\t\tret = -EINVAL;\n\t}\n\n\tBUILD_BUG_ON(ARRAY_SIZE(i915->mm.regions) != ARRAY_SIZE(placements));\n\tBUILD_BUG_ON(ARRAY_SIZE(ext_data->placements) != ARRAY_SIZE(placements));\n\tif (args->num_regions > ARRAY_SIZE(i915->mm.regions)) {\n\t\tdrm_dbg(&i915->drm, \"num_regions is too large\\n\");\n\t\tret = -EINVAL;\n\t}\n\n\tif (ret)\n\t\treturn ret;\n\n\tmask = 0;\n\tfor (i = 0; i < args->num_regions; i++) {\n\t\tstruct drm_i915_gem_memory_class_instance region;\n\t\tstruct intel_memory_region *mr;\n\n\t\tif (copy_from_user(&region, uregions, sizeof(region)))\n\t\t\treturn -EFAULT;\n\n\t\tmr = intel_memory_region_lookup(i915,\n\t\t\t\t\t\tregion.memory_class,\n\t\t\t\t\t\tregion.memory_instance);\n\t\tif (!mr || mr->private) {\n\t\t\tdrm_dbg(&i915->drm, \"Device is missing region { class: %d, inst: %d } at index = %d\\n\",\n\t\t\t\tregion.memory_class, region.memory_instance, i);\n\t\t\tret = -EINVAL;\n\t\t\tgoto out_dump;\n\t\t}\n\n\t\tif (mask & BIT(mr->id)) {\n\t\t\tdrm_dbg(&i915->drm, \"Found duplicate placement %s -> { class: %d, inst: %d } at index = %d\\n\",\n\t\t\t\tmr->name, region.memory_class,\n\t\t\t\tregion.memory_instance, i);\n\t\t\tret = -EINVAL;\n\t\t\tgoto out_dump;\n\t\t}\n\n\t\tplacements[i] = mr;\n\t\tmask |= BIT(mr->id);\n\n\t\t++uregions;\n\t}\n\n\tif (ext_data->n_placements) {\n\t\tret = -EINVAL;\n\t\tgoto out_dump;\n\t}\n\n\text_data->n_placements = args->num_regions;\n\tfor (i = 0; i < args->num_regions; i++)\n\t\text_data->placements[i] = placements[i];\n\n\text_data->placement_mask = mask;\n\treturn 0;\n\nout_dump:\n\tif (1) {\n\t\tchar buf[256];\n\n\t\tif (ext_data->n_placements) {\n\t\t\trepr_placements(buf,\n\t\t\t\t\tsizeof(buf),\n\t\t\t\t\text_data->placements,\n\t\t\t\t\text_data->n_placements);\n\t\t\tdrm_dbg(&i915->drm,\n\t\t\t\t\"Placements were already set in previous EXT. Existing placements: %s\\n\",\n\t\t\t\tbuf);\n\t\t}\n\n\t\trepr_placements(buf, sizeof(buf), placements, i);\n\t\tdrm_dbg(&i915->drm, \"New placements(so far validated): %s\\n\", buf);\n\t}\n\n\treturn ret;\n}\n\nstatic int ext_set_placements(struct i915_user_extension __user *base,\n\t\t\t      void *data)\n{\n\tstruct drm_i915_gem_create_ext_memory_regions ext;\n\n\tif (copy_from_user(&ext, base, sizeof(ext)))\n\t\treturn -EFAULT;\n\n\treturn set_placements(&ext, data);\n}\n\nstatic int ext_set_protected(struct i915_user_extension __user *base, void *data)\n{\n\tstruct drm_i915_gem_create_ext_protected_content ext;\n\tstruct create_ext *ext_data = data;\n\n\tif (copy_from_user(&ext, base, sizeof(ext)))\n\t\treturn -EFAULT;\n\n\tif (ext.flags)\n\t\treturn -EINVAL;\n\n\tif (!intel_pxp_is_enabled(ext_data->i915->pxp))\n\t\treturn -ENODEV;\n\n\text_data->flags |= I915_BO_PROTECTED;\n\n\treturn 0;\n}\n\nstatic int ext_set_pat(struct i915_user_extension __user *base, void *data)\n{\n\tstruct create_ext *ext_data = data;\n\tstruct drm_i915_private *i915 = ext_data->i915;\n\tstruct drm_i915_gem_create_ext_set_pat ext;\n\tunsigned int max_pat_index;\n\n\tBUILD_BUG_ON(sizeof(struct drm_i915_gem_create_ext_set_pat) !=\n\t\t     offsetofend(struct drm_i915_gem_create_ext_set_pat, rsvd));\n\n\t \n\tif (!IS_METEORLAKE(i915))\n\t\treturn -ENODEV;\n\n\tif (copy_from_user(&ext, base, sizeof(ext)))\n\t\treturn -EFAULT;\n\n\tmax_pat_index = INTEL_INFO(i915)->max_pat_index;\n\n\tif (ext.pat_index > max_pat_index) {\n\t\tdrm_dbg(&i915->drm, \"PAT index is invalid: %u\\n\",\n\t\t\text.pat_index);\n\t\treturn -EINVAL;\n\t}\n\n\text_data->pat_index = ext.pat_index;\n\n\treturn 0;\n}\n\nstatic const i915_user_extension_fn create_extensions[] = {\n\t[I915_GEM_CREATE_EXT_MEMORY_REGIONS] = ext_set_placements,\n\t[I915_GEM_CREATE_EXT_PROTECTED_CONTENT] = ext_set_protected,\n\t[I915_GEM_CREATE_EXT_SET_PAT] = ext_set_pat,\n};\n\n#define PAT_INDEX_NOT_SET\t0xffff\n \nint\ni915_gem_create_ext_ioctl(struct drm_device *dev, void *data,\n\t\t\t  struct drm_file *file)\n{\n\tstruct drm_i915_private *i915 = to_i915(dev);\n\tstruct drm_i915_gem_create_ext *args = data;\n\tstruct create_ext ext_data = { .i915 = i915 };\n\tstruct drm_i915_gem_object *obj;\n\tint ret;\n\n\tif (args->flags & ~I915_GEM_CREATE_EXT_FLAG_NEEDS_CPU_ACCESS)\n\t\treturn -EINVAL;\n\n\text_data.pat_index = PAT_INDEX_NOT_SET;\n\tret = i915_user_extensions(u64_to_user_ptr(args->extensions),\n\t\t\t\t   create_extensions,\n\t\t\t\t   ARRAY_SIZE(create_extensions),\n\t\t\t\t   &ext_data);\n\tif (ret)\n\t\treturn ret;\n\n\tif (!ext_data.n_placements) {\n\t\text_data.placements[0] =\n\t\t\tintel_memory_region_by_type(i915, INTEL_MEMORY_SYSTEM);\n\t\text_data.n_placements = 1;\n\t}\n\n\tif (args->flags & I915_GEM_CREATE_EXT_FLAG_NEEDS_CPU_ACCESS) {\n\t\tif (ext_data.n_placements == 1)\n\t\t\treturn -EINVAL;\n\n\t\t \n\t\tif (!(ext_data.placement_mask & BIT(INTEL_REGION_SMEM)))\n\t\t\treturn -EINVAL;\n\t} else {\n\t\tif (ext_data.n_placements > 1 ||\n\t\t    ext_data.placements[0]->type != INTEL_MEMORY_SYSTEM)\n\t\t\text_data.flags |= I915_BO_ALLOC_GPU_ONLY;\n\t}\n\n\tobj = __i915_gem_object_create_user_ext(i915, args->size,\n\t\t\t\t\t\text_data.placements,\n\t\t\t\t\t\text_data.n_placements,\n\t\t\t\t\t\text_data.flags);\n\tif (IS_ERR(obj))\n\t\treturn PTR_ERR(obj);\n\n\tif (ext_data.pat_index != PAT_INDEX_NOT_SET) {\n\t\ti915_gem_object_set_pat_index(obj, ext_data.pat_index);\n\t\t \n\t\tobj->pat_set_by_user = true;\n\t}\n\n\treturn i915_gem_publish(obj, file, &args->size, &args->handle);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}