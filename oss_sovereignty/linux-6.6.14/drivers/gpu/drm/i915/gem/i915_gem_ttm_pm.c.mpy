{
  "module_name": "i915_gem_ttm_pm.c",
  "hash_id": "ef96241e474faf0c75b11589011838b1e100199c117a1949558a1305dbc51e05",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/i915/gem/i915_gem_ttm_pm.c",
  "human_readable_source": "\n \n\n#include <drm/ttm/ttm_placement.h>\n#include <drm/ttm/ttm_tt.h>\n\n#include \"i915_drv.h\"\n#include \"intel_memory_region.h\"\n#include \"intel_region_ttm.h\"\n\n#include \"gem/i915_gem_region.h\"\n#include \"gem/i915_gem_ttm.h\"\n#include \"gem/i915_gem_ttm_move.h\"\n#include \"gem/i915_gem_ttm_pm.h\"\n\n \nvoid i915_ttm_backup_free(struct drm_i915_gem_object *obj)\n{\n\tif (obj->ttm.backup) {\n\t\ti915_gem_object_put(obj->ttm.backup);\n\t\tobj->ttm.backup = NULL;\n\t}\n}\n\n \nstruct i915_gem_ttm_pm_apply {\n\tstruct i915_gem_apply_to_region base;\n\tbool allow_gpu : 1;\n\tbool backup_pinned : 1;\n};\n\nstatic int i915_ttm_backup(struct i915_gem_apply_to_region *apply,\n\t\t\t   struct drm_i915_gem_object *obj)\n{\n\tstruct i915_gem_ttm_pm_apply *pm_apply =\n\t\tcontainer_of(apply, typeof(*pm_apply), base);\n\tstruct ttm_buffer_object *bo = i915_gem_to_ttm(obj);\n\tstruct ttm_buffer_object *backup_bo;\n\tstruct drm_i915_private *i915 =\n\t\tcontainer_of(bo->bdev, typeof(*i915), bdev);\n\tstruct drm_i915_gem_object *backup;\n\tstruct ttm_operation_ctx ctx = {};\n\tunsigned int flags;\n\tint err = 0;\n\n\tif (!i915_ttm_cpu_maps_iomem(bo->resource) || obj->ttm.backup)\n\t\treturn 0;\n\n\tif (pm_apply->allow_gpu && i915_gem_object_evictable(obj))\n\t\treturn ttm_bo_validate(bo, i915_ttm_sys_placement(), &ctx);\n\n\tif (!pm_apply->backup_pinned ||\n\t    (pm_apply->allow_gpu && (obj->flags & I915_BO_ALLOC_PM_EARLY)))\n\t\treturn 0;\n\n\tif (obj->flags & I915_BO_ALLOC_PM_VOLATILE)\n\t\treturn 0;\n\n\t \n\tflags = 0;\n\tif (i915_gem_object_needs_ccs_pages(obj)) {\n\t\tWARN_ON_ONCE(!i915_gem_object_is_framebuffer(obj));\n\t\tWARN_ON_ONCE(!pm_apply->allow_gpu);\n\n\t\tflags = I915_BO_ALLOC_CCS_AUX;\n\t}\n\tbackup = i915_gem_object_create_region(i915->mm.regions[INTEL_REGION_SMEM],\n\t\t\t\t\t       obj->base.size, 0, flags);\n\tif (IS_ERR(backup))\n\t\treturn PTR_ERR(backup);\n\n\terr = i915_gem_object_lock(backup, apply->ww);\n\tif (err)\n\t\tgoto out_no_lock;\n\n\tbackup_bo = i915_gem_to_ttm(backup);\n\terr = ttm_tt_populate(backup_bo->bdev, backup_bo->ttm, &ctx);\n\tif (err)\n\t\tgoto out_no_populate;\n\n\terr = i915_gem_obj_copy_ttm(backup, obj, pm_apply->allow_gpu, false);\n\tif (err) {\n\t\tdrm_err(&i915->drm,\n\t\t\t\"Unable to copy from device to system memory, err:%pe\\n\",\n\t\t\tERR_PTR(err));\n\t\tgoto out_no_populate;\n\t}\n\tttm_bo_wait_ctx(backup_bo, &ctx);\n\n\tobj->ttm.backup = backup;\n\treturn 0;\n\nout_no_populate:\n\ti915_gem_ww_unlock_single(backup);\nout_no_lock:\n\ti915_gem_object_put(backup);\n\n\treturn err;\n}\n\nstatic int i915_ttm_recover(struct i915_gem_apply_to_region *apply,\n\t\t\t    struct drm_i915_gem_object *obj)\n{\n\ti915_ttm_backup_free(obj);\n\treturn 0;\n}\n\n \nvoid i915_ttm_recover_region(struct intel_memory_region *mr)\n{\n\tstatic const struct i915_gem_apply_to_region_ops recover_ops = {\n\t\t.process_obj = i915_ttm_recover,\n\t};\n\tstruct i915_gem_apply_to_region apply = {.ops = &recover_ops};\n\tint ret;\n\n\tret = i915_gem_process_region(mr, &apply);\n\tGEM_WARN_ON(ret);\n}\n\n \nint i915_ttm_backup_region(struct intel_memory_region *mr, u32 flags)\n{\n\tstatic const struct i915_gem_apply_to_region_ops backup_ops = {\n\t\t.process_obj = i915_ttm_backup,\n\t};\n\tstruct i915_gem_ttm_pm_apply pm_apply = {\n\t\t.base = {.ops = &backup_ops},\n\t\t.allow_gpu = flags & I915_TTM_BACKUP_ALLOW_GPU,\n\t\t.backup_pinned = flags & I915_TTM_BACKUP_PINNED,\n\t};\n\n\treturn i915_gem_process_region(mr, &pm_apply.base);\n}\n\nstatic int i915_ttm_restore(struct i915_gem_apply_to_region *apply,\n\t\t\t    struct drm_i915_gem_object *obj)\n{\n\tstruct i915_gem_ttm_pm_apply *pm_apply =\n\t\tcontainer_of(apply, typeof(*pm_apply), base);\n\tstruct drm_i915_gem_object *backup = obj->ttm.backup;\n\tstruct ttm_buffer_object *backup_bo = i915_gem_to_ttm(backup);\n\tstruct ttm_operation_ctx ctx = {};\n\tint err;\n\n\tif (!backup)\n\t\treturn 0;\n\n\tif (!pm_apply->allow_gpu && !(obj->flags & I915_BO_ALLOC_PM_EARLY))\n\t\treturn 0;\n\n\terr = i915_gem_object_lock(backup, apply->ww);\n\tif (err)\n\t\treturn err;\n\n\t \n\tif (!backup_bo->resource)\n\t\terr = ttm_bo_validate(backup_bo, i915_ttm_sys_placement(), &ctx);\n\tif (!err)\n\t\terr = ttm_tt_populate(backup_bo->bdev, backup_bo->ttm, &ctx);\n\tif (!err) {\n\t\terr = i915_gem_obj_copy_ttm(obj, backup, pm_apply->allow_gpu,\n\t\t\t\t\t    false);\n\t\tGEM_WARN_ON(err);\n\t\tttm_bo_wait_ctx(backup_bo, &ctx);\n\n\t\tobj->ttm.backup = NULL;\n\t\terr = 0;\n\t}\n\n\ti915_gem_ww_unlock_single(backup);\n\n\tif (!err)\n\t\ti915_gem_object_put(backup);\n\n\treturn err;\n}\n\n \nint i915_ttm_restore_region(struct intel_memory_region *mr, u32 flags)\n{\n\tstatic const struct i915_gem_apply_to_region_ops restore_ops = {\n\t\t.process_obj = i915_ttm_restore,\n\t};\n\tstruct i915_gem_ttm_pm_apply pm_apply = {\n\t\t.base = {.ops = &restore_ops},\n\t\t.allow_gpu = flags & I915_TTM_BACKUP_ALLOW_GPU,\n\t};\n\n\treturn i915_gem_process_region(mr, &pm_apply.base);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}