{
  "module_name": "i915_gem_clflush.c",
  "hash_id": "446e9b3e670b213e2ec337852ee8580c7241b4b313457ad5e9f5cf91f48d9b93",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/i915/gem/i915_gem_clflush.c",
  "human_readable_source": " \n\n#include <drm/drm_cache.h>\n\n#include \"display/intel_frontbuffer.h\"\n\n#include \"i915_config.h\"\n#include \"i915_drv.h\"\n#include \"i915_gem_clflush.h\"\n#include \"i915_sw_fence_work.h\"\n#include \"i915_trace.h\"\n\nstruct clflush {\n\tstruct dma_fence_work base;\n\tstruct drm_i915_gem_object *obj;\n};\n\nstatic void __do_clflush(struct drm_i915_gem_object *obj)\n{\n\tGEM_BUG_ON(!i915_gem_object_has_pages(obj));\n\tdrm_clflush_sg(obj->mm.pages);\n\n\ti915_gem_object_flush_frontbuffer(obj, ORIGIN_CPU);\n}\n\nstatic void clflush_work(struct dma_fence_work *base)\n{\n\tstruct clflush *clflush = container_of(base, typeof(*clflush), base);\n\n\t__do_clflush(clflush->obj);\n}\n\nstatic void clflush_release(struct dma_fence_work *base)\n{\n\tstruct clflush *clflush = container_of(base, typeof(*clflush), base);\n\n\ti915_gem_object_unpin_pages(clflush->obj);\n\ti915_gem_object_put(clflush->obj);\n}\n\nstatic const struct dma_fence_work_ops clflush_ops = {\n\t.name = \"clflush\",\n\t.work = clflush_work,\n\t.release = clflush_release,\n};\n\nstatic struct clflush *clflush_work_create(struct drm_i915_gem_object *obj)\n{\n\tstruct clflush *clflush;\n\n\tGEM_BUG_ON(!obj->cache_dirty);\n\n\tclflush = kmalloc(sizeof(*clflush), GFP_KERNEL);\n\tif (!clflush)\n\t\treturn NULL;\n\n\tif (__i915_gem_object_get_pages(obj) < 0) {\n\t\tkfree(clflush);\n\t\treturn NULL;\n\t}\n\n\tdma_fence_work_init(&clflush->base, &clflush_ops);\n\tclflush->obj = i915_gem_object_get(obj);  \n\n\treturn clflush;\n}\n\nbool i915_gem_clflush_object(struct drm_i915_gem_object *obj,\n\t\t\t     unsigned int flags)\n{\n\tstruct drm_i915_private *i915 = to_i915(obj->base.dev);\n\tstruct clflush *clflush;\n\n\tassert_object_held(obj);\n\n\tif (IS_DGFX(i915)) {\n\t\tWARN_ON_ONCE(obj->cache_dirty);\n\t\treturn false;\n\t}\n\n\t \n\tif (!i915_gem_object_has_struct_page(obj)) {\n\t\tobj->cache_dirty = false;\n\t\treturn false;\n\t}\n\n\t \n\tif (!(flags & I915_CLFLUSH_FORCE) &&\n\t    obj->cache_coherent & I915_BO_CACHE_COHERENT_FOR_READ)\n\t\treturn false;\n\n\ttrace_i915_gem_object_clflush(obj);\n\n\tclflush = NULL;\n\tif (!(flags & I915_CLFLUSH_SYNC) &&\n\t    dma_resv_reserve_fences(obj->base.resv, 1) == 0)\n\t\tclflush = clflush_work_create(obj);\n\tif (clflush) {\n\t\ti915_sw_fence_await_reservation(&clflush->base.chain,\n\t\t\t\t\t\tobj->base.resv, true,\n\t\t\t\t\t\ti915_fence_timeout(i915),\n\t\t\t\t\t\tI915_FENCE_GFP);\n\t\tdma_resv_add_fence(obj->base.resv, &clflush->base.dma,\n\t\t\t\t   DMA_RESV_USAGE_KERNEL);\n\t\tdma_fence_work_commit(&clflush->base);\n\t\t \n\t\tobj->cache_dirty = false;\n\t} else if (obj->mm.pages) {\n\t\t__do_clflush(obj);\n\t\tobj->cache_dirty = false;\n\t} else {\n\t\tGEM_BUG_ON(obj->write_domain != I915_GEM_DOMAIN_CPU);\n\t}\n\n\treturn true;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}