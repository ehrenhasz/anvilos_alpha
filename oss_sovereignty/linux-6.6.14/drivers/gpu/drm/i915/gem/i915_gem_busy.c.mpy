{
  "module_name": "i915_gem_busy.c",
  "hash_id": "911ead57774d17c91b1810339310e7c9b45990088c9ae67b4a14d7e4de2e7497",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/i915/gem/i915_gem_busy.c",
  "human_readable_source": " \n\n#include <linux/dma-fence-array.h>\n\n#include \"gt/intel_engine.h\"\n\n#include \"i915_gem_ioctls.h\"\n#include \"i915_gem_object.h\"\n\nstatic __always_inline u32 __busy_read_flag(u16 id)\n{\n\tif (id == (u16)I915_ENGINE_CLASS_INVALID)\n\t\treturn 0xffff0000u;\n\n\tGEM_BUG_ON(id >= 16);\n\treturn 0x10000u << id;\n}\n\nstatic __always_inline u32 __busy_write_id(u16 id)\n{\n\t \n\tif (id == (u16)I915_ENGINE_CLASS_INVALID)\n\t\treturn 0xffffffffu;\n\n\treturn (id + 1) | __busy_read_flag(id);\n}\n\nstatic __always_inline unsigned int\n__busy_set_if_active(struct dma_fence *fence, u32 (*flag)(u16 id))\n{\n\tconst struct i915_request *rq;\n\n\t \n\tif (dma_fence_is_array(fence)) {\n\t\tstruct dma_fence_array *array = to_dma_fence_array(fence);\n\t\tstruct dma_fence **child = array->fences;\n\t\tunsigned int nchild = array->num_fences;\n\n\t\tdo {\n\t\t\tstruct dma_fence *current_fence = *child++;\n\n\t\t\t \n\t\t\tif (!dma_fence_is_i915(current_fence) ||\n\t\t\t    !test_bit(I915_FENCE_FLAG_COMPOSITE,\n\t\t\t\t      &current_fence->flags)) {\n\t\t\t\treturn 0;\n\t\t\t}\n\n\t\t\trq = to_request(current_fence);\n\t\t\tif (!i915_request_completed(rq))\n\t\t\t\treturn flag(rq->engine->uabi_class);\n\t\t} while (--nchild);\n\n\t\t \n\t\treturn 0;\n\t} else {\n\t\tif (!dma_fence_is_i915(fence))\n\t\t\treturn 0;\n\n\t\trq = to_request(fence);\n\t\tif (i915_request_completed(rq))\n\t\t\treturn 0;\n\n\t\t \n\t\tBUILD_BUG_ON(!typecheck(u16, rq->engine->uabi_class));\n\t\treturn flag(rq->engine->uabi_class);\n\t}\n}\n\nstatic __always_inline unsigned int\nbusy_check_reader(struct dma_fence *fence)\n{\n\treturn __busy_set_if_active(fence, __busy_read_flag);\n}\n\nstatic __always_inline unsigned int\nbusy_check_writer(struct dma_fence *fence)\n{\n\tif (!fence)\n\t\treturn 0;\n\n\treturn __busy_set_if_active(fence, __busy_write_id);\n}\n\nint\ni915_gem_busy_ioctl(struct drm_device *dev, void *data,\n\t\t    struct drm_file *file)\n{\n\tstruct drm_i915_gem_busy *args = data;\n\tstruct drm_i915_gem_object *obj;\n\tstruct dma_resv_iter cursor;\n\tstruct dma_fence *fence;\n\tint err;\n\n\terr = -ENOENT;\n\trcu_read_lock();\n\tobj = i915_gem_object_lookup_rcu(file, args->handle);\n\tif (!obj)\n\t\tgoto out;\n\n\t \n\targs->busy = 0;\n\tdma_resv_iter_begin(&cursor, obj->base.resv, DMA_RESV_USAGE_READ);\n\tdma_resv_for_each_fence_unlocked(&cursor, fence) {\n\t\tif (dma_resv_iter_is_restarted(&cursor))\n\t\t\targs->busy = 0;\n\n\t\tif (dma_resv_iter_usage(&cursor) <= DMA_RESV_USAGE_WRITE)\n\t\t\t \n\t\t\targs->busy |= busy_check_writer(fence);\n\t\telse\n\t\t\t \n\t\t\targs->busy |= busy_check_reader(fence);\n\t}\n\tdma_resv_iter_end(&cursor);\n\n\terr = 0;\nout:\n\trcu_read_unlock();\n\treturn err;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}