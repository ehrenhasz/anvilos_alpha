{
  "module_name": "i915_sw_fence.c",
  "hash_id": "58c7fd006630f34e708868b6dd81cf92b077389ba0c2c0493797eebc01121dd9",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/i915/i915_sw_fence.c",
  "human_readable_source": " \n\n#include <linux/slab.h>\n#include <linux/dma-fence.h>\n#include <linux/irq_work.h>\n#include <linux/dma-resv.h>\n\n#include \"i915_sw_fence.h\"\n#include \"i915_selftest.h\"\n\n#if IS_ENABLED(CONFIG_DRM_I915_DEBUG)\n#define I915_SW_FENCE_BUG_ON(expr) BUG_ON(expr)\n#else\n#define I915_SW_FENCE_BUG_ON(expr) BUILD_BUG_ON_INVALID(expr)\n#endif\n\n#ifdef CONFIG_DRM_I915_SW_FENCE_CHECK_DAG\nstatic DEFINE_SPINLOCK(i915_sw_fence_lock);\n#endif\n\n#define WQ_FLAG_BITS \\\n\tBITS_PER_TYPE(typeof_member(struct wait_queue_entry, flags))\n\n \n#define I915_SW_FENCE_FLAG_FENCE BIT(WQ_FLAG_BITS - 1)\n#define I915_SW_FENCE_FLAG_ALLOC BIT(WQ_FLAG_BITS - 2)\n\nenum {\n\tDEBUG_FENCE_IDLE = 0,\n\tDEBUG_FENCE_NOTIFY,\n};\n\nstatic void *i915_sw_fence_debug_hint(void *addr)\n{\n\treturn (void *)(((struct i915_sw_fence *)addr)->fn);\n}\n\n#ifdef CONFIG_DRM_I915_SW_FENCE_DEBUG_OBJECTS\n\nstatic const struct debug_obj_descr i915_sw_fence_debug_descr = {\n\t.name = \"i915_sw_fence\",\n\t.debug_hint = i915_sw_fence_debug_hint,\n};\n\nstatic inline void debug_fence_init(struct i915_sw_fence *fence)\n{\n\tdebug_object_init(fence, &i915_sw_fence_debug_descr);\n}\n\nstatic inline void debug_fence_init_onstack(struct i915_sw_fence *fence)\n{\n\tdebug_object_init_on_stack(fence, &i915_sw_fence_debug_descr);\n}\n\nstatic inline void debug_fence_activate(struct i915_sw_fence *fence)\n{\n\tdebug_object_activate(fence, &i915_sw_fence_debug_descr);\n}\n\nstatic inline void debug_fence_set_state(struct i915_sw_fence *fence,\n\t\t\t\t\t int old, int new)\n{\n\tdebug_object_active_state(fence, &i915_sw_fence_debug_descr, old, new);\n}\n\nstatic inline void debug_fence_deactivate(struct i915_sw_fence *fence)\n{\n\tdebug_object_deactivate(fence, &i915_sw_fence_debug_descr);\n}\n\nstatic inline void debug_fence_destroy(struct i915_sw_fence *fence)\n{\n\tdebug_object_destroy(fence, &i915_sw_fence_debug_descr);\n}\n\nstatic inline void debug_fence_free(struct i915_sw_fence *fence)\n{\n\tdebug_object_free(fence, &i915_sw_fence_debug_descr);\n\tsmp_wmb();  \n}\n\nstatic inline void debug_fence_assert(struct i915_sw_fence *fence)\n{\n\tdebug_object_assert_init(fence, &i915_sw_fence_debug_descr);\n}\n\n#else\n\nstatic inline void debug_fence_init(struct i915_sw_fence *fence)\n{\n}\n\nstatic inline void debug_fence_init_onstack(struct i915_sw_fence *fence)\n{\n}\n\nstatic inline void debug_fence_activate(struct i915_sw_fence *fence)\n{\n}\n\nstatic inline void debug_fence_set_state(struct i915_sw_fence *fence,\n\t\t\t\t\t int old, int new)\n{\n}\n\nstatic inline void debug_fence_deactivate(struct i915_sw_fence *fence)\n{\n}\n\nstatic inline void debug_fence_destroy(struct i915_sw_fence *fence)\n{\n}\n\nstatic inline void debug_fence_free(struct i915_sw_fence *fence)\n{\n}\n\nstatic inline void debug_fence_assert(struct i915_sw_fence *fence)\n{\n}\n\n#endif\n\nstatic int __i915_sw_fence_notify(struct i915_sw_fence *fence,\n\t\t\t\t  enum i915_sw_fence_notify state)\n{\n\treturn fence->fn(fence, state);\n}\n\n#ifdef CONFIG_DRM_I915_SW_FENCE_DEBUG_OBJECTS\nvoid i915_sw_fence_fini(struct i915_sw_fence *fence)\n{\n\tdebug_fence_free(fence);\n}\n#endif\n\nstatic void __i915_sw_fence_wake_up_all(struct i915_sw_fence *fence,\n\t\t\t\t\tstruct list_head *continuation)\n{\n\twait_queue_head_t *x = &fence->wait;\n\twait_queue_entry_t *pos, *next;\n\tunsigned long flags;\n\n\tdebug_fence_deactivate(fence);\n\tatomic_set_release(&fence->pending, -1);  \n\n\t \n\n\tspin_lock_irqsave_nested(&x->lock, flags, 1 + !!continuation);\n\tif (continuation) {\n\t\tlist_for_each_entry_safe(pos, next, &x->head, entry) {\n\t\t\tif (pos->flags & I915_SW_FENCE_FLAG_FENCE)\n\t\t\t\tlist_move_tail(&pos->entry, continuation);\n\t\t\telse\n\t\t\t\tpos->func(pos, TASK_NORMAL, 0, continuation);\n\t\t}\n\t} else {\n\t\tLIST_HEAD(extra);\n\n\t\tdo {\n\t\t\tlist_for_each_entry_safe(pos, next, &x->head, entry) {\n\t\t\t\tint wake_flags;\n\n\t\t\t\twake_flags = 0;\n\t\t\t\tif (pos->flags & I915_SW_FENCE_FLAG_FENCE)\n\t\t\t\t\twake_flags = fence->error;\n\n\t\t\t\tpos->func(pos, TASK_NORMAL, wake_flags, &extra);\n\t\t\t}\n\n\t\t\tif (list_empty(&extra))\n\t\t\t\tbreak;\n\n\t\t\tlist_splice_tail_init(&extra, &x->head);\n\t\t} while (1);\n\t}\n\tspin_unlock_irqrestore(&x->lock, flags);\n\n\tdebug_fence_assert(fence);\n}\n\nstatic void __i915_sw_fence_complete(struct i915_sw_fence *fence,\n\t\t\t\t     struct list_head *continuation)\n{\n\tdebug_fence_assert(fence);\n\n\tif (!atomic_dec_and_test(&fence->pending))\n\t\treturn;\n\n\tdebug_fence_set_state(fence, DEBUG_FENCE_IDLE, DEBUG_FENCE_NOTIFY);\n\n\tif (__i915_sw_fence_notify(fence, FENCE_COMPLETE) != NOTIFY_DONE)\n\t\treturn;\n\n\tdebug_fence_set_state(fence, DEBUG_FENCE_NOTIFY, DEBUG_FENCE_IDLE);\n\n\t__i915_sw_fence_wake_up_all(fence, continuation);\n\n\tdebug_fence_destroy(fence);\n\t__i915_sw_fence_notify(fence, FENCE_FREE);\n}\n\nvoid i915_sw_fence_complete(struct i915_sw_fence *fence)\n{\n\tdebug_fence_assert(fence);\n\n\tif (WARN_ON(i915_sw_fence_done(fence)))\n\t\treturn;\n\n\t__i915_sw_fence_complete(fence, NULL);\n}\n\nbool i915_sw_fence_await(struct i915_sw_fence *fence)\n{\n\tint pending;\n\n\t \n\tpending = atomic_read(&fence->pending);\n\tdo {\n\t\tif (pending < 1)\n\t\t\treturn false;\n\t} while (!atomic_try_cmpxchg(&fence->pending, &pending, pending + 1));\n\n\treturn true;\n}\n\nvoid __i915_sw_fence_init(struct i915_sw_fence *fence,\n\t\t\t  i915_sw_fence_notify_t fn,\n\t\t\t  const char *name,\n\t\t\t  struct lock_class_key *key)\n{\n\t__init_waitqueue_head(&fence->wait, name, key);\n\tfence->fn = fn;\n#ifdef CONFIG_DRM_I915_SW_FENCE_CHECK_DAG\n\tfence->flags = 0;\n#endif\n\n\ti915_sw_fence_reinit(fence);\n}\n\nvoid i915_sw_fence_reinit(struct i915_sw_fence *fence)\n{\n\tdebug_fence_init(fence);\n\n\tatomic_set(&fence->pending, 1);\n\tfence->error = 0;\n\n\tI915_SW_FENCE_BUG_ON(!list_empty(&fence->wait.head));\n}\n\nvoid i915_sw_fence_commit(struct i915_sw_fence *fence)\n{\n\tdebug_fence_activate(fence);\n\ti915_sw_fence_complete(fence);\n}\n\nstatic int i915_sw_fence_wake(wait_queue_entry_t *wq, unsigned mode, int flags, void *key)\n{\n\ti915_sw_fence_set_error_once(wq->private, flags);\n\n\tlist_del(&wq->entry);\n\t__i915_sw_fence_complete(wq->private, key);\n\n\tif (wq->flags & I915_SW_FENCE_FLAG_ALLOC)\n\t\tkfree(wq);\n\treturn 0;\n}\n\n#ifdef CONFIG_DRM_I915_SW_FENCE_CHECK_DAG\nstatic bool __i915_sw_fence_check_if_after(struct i915_sw_fence *fence,\n\t\t\t\t    const struct i915_sw_fence * const signaler)\n{\n\twait_queue_entry_t *wq;\n\n\tif (__test_and_set_bit(I915_SW_FENCE_CHECKED_BIT, &fence->flags))\n\t\treturn false;\n\n\tif (fence == signaler)\n\t\treturn true;\n\n\tlist_for_each_entry(wq, &fence->wait.head, entry) {\n\t\tif (wq->func != i915_sw_fence_wake)\n\t\t\tcontinue;\n\n\t\tif (__i915_sw_fence_check_if_after(wq->private, signaler))\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}\n\nstatic void __i915_sw_fence_clear_checked_bit(struct i915_sw_fence *fence)\n{\n\twait_queue_entry_t *wq;\n\n\tif (!__test_and_clear_bit(I915_SW_FENCE_CHECKED_BIT, &fence->flags))\n\t\treturn;\n\n\tlist_for_each_entry(wq, &fence->wait.head, entry) {\n\t\tif (wq->func != i915_sw_fence_wake)\n\t\t\tcontinue;\n\n\t\t__i915_sw_fence_clear_checked_bit(wq->private);\n\t}\n}\n\nstatic bool i915_sw_fence_check_if_after(struct i915_sw_fence *fence,\n\t\t\t\t  const struct i915_sw_fence * const signaler)\n{\n\tunsigned long flags;\n\tbool err;\n\n\tspin_lock_irqsave(&i915_sw_fence_lock, flags);\n\terr = __i915_sw_fence_check_if_after(fence, signaler);\n\t__i915_sw_fence_clear_checked_bit(fence);\n\tspin_unlock_irqrestore(&i915_sw_fence_lock, flags);\n\n\treturn err;\n}\n#else\nstatic bool i915_sw_fence_check_if_after(struct i915_sw_fence *fence,\n\t\t\t\t\t const struct i915_sw_fence * const signaler)\n{\n\treturn false;\n}\n#endif\n\nstatic int __i915_sw_fence_await_sw_fence(struct i915_sw_fence *fence,\n\t\t\t\t\t  struct i915_sw_fence *signaler,\n\t\t\t\t\t  wait_queue_entry_t *wq, gfp_t gfp)\n{\n\tunsigned int pending;\n\tunsigned long flags;\n\n\tdebug_fence_assert(fence);\n\tmight_sleep_if(gfpflags_allow_blocking(gfp));\n\n\tif (i915_sw_fence_done(signaler)) {\n\t\ti915_sw_fence_set_error_once(fence, signaler->error);\n\t\treturn 0;\n\t}\n\n\tdebug_fence_assert(signaler);\n\n\t \n\tif (unlikely(i915_sw_fence_check_if_after(fence, signaler)))\n\t\treturn -EINVAL;\n\n\tpending = I915_SW_FENCE_FLAG_FENCE;\n\tif (!wq) {\n\t\twq = kmalloc(sizeof(*wq), gfp);\n\t\tif (!wq) {\n\t\t\tif (!gfpflags_allow_blocking(gfp))\n\t\t\t\treturn -ENOMEM;\n\n\t\t\ti915_sw_fence_wait(signaler);\n\t\t\ti915_sw_fence_set_error_once(fence, signaler->error);\n\t\t\treturn 0;\n\t\t}\n\n\t\tpending |= I915_SW_FENCE_FLAG_ALLOC;\n\t}\n\n\tINIT_LIST_HEAD(&wq->entry);\n\twq->flags = pending;\n\twq->func = i915_sw_fence_wake;\n\twq->private = fence;\n\n\ti915_sw_fence_await(fence);\n\n\tspin_lock_irqsave(&signaler->wait.lock, flags);\n\tif (likely(!i915_sw_fence_done(signaler))) {\n\t\t__add_wait_queue_entry_tail(&signaler->wait, wq);\n\t\tpending = 1;\n\t} else {\n\t\ti915_sw_fence_wake(wq, 0, signaler->error, NULL);\n\t\tpending = 0;\n\t}\n\tspin_unlock_irqrestore(&signaler->wait.lock, flags);\n\n\treturn pending;\n}\n\nint i915_sw_fence_await_sw_fence(struct i915_sw_fence *fence,\n\t\t\t\t struct i915_sw_fence *signaler,\n\t\t\t\t wait_queue_entry_t *wq)\n{\n\treturn __i915_sw_fence_await_sw_fence(fence, signaler, wq, 0);\n}\n\nint i915_sw_fence_await_sw_fence_gfp(struct i915_sw_fence *fence,\n\t\t\t\t     struct i915_sw_fence *signaler,\n\t\t\t\t     gfp_t gfp)\n{\n\treturn __i915_sw_fence_await_sw_fence(fence, signaler, NULL, gfp);\n}\n\nstruct i915_sw_dma_fence_cb_timer {\n\tstruct i915_sw_dma_fence_cb base;\n\tstruct dma_fence *dma;\n\tstruct timer_list timer;\n\tstruct irq_work work;\n\tstruct rcu_head rcu;\n};\n\nstatic void dma_i915_sw_fence_wake(struct dma_fence *dma,\n\t\t\t\t   struct dma_fence_cb *data)\n{\n\tstruct i915_sw_dma_fence_cb *cb = container_of(data, typeof(*cb), base);\n\n\ti915_sw_fence_set_error_once(cb->fence, dma->error);\n\ti915_sw_fence_complete(cb->fence);\n\tkfree(cb);\n}\n\nstatic void timer_i915_sw_fence_wake(struct timer_list *t)\n{\n\tstruct i915_sw_dma_fence_cb_timer *cb = from_timer(cb, t, timer);\n\tstruct i915_sw_fence *fence;\n\n\tfence = xchg(&cb->base.fence, NULL);\n\tif (!fence)\n\t\treturn;\n\n\tpr_notice(\"Asynchronous wait on fence %s:%s:%llx timed out (hint:%ps)\\n\",\n\t\t  cb->dma->ops->get_driver_name(cb->dma),\n\t\t  cb->dma->ops->get_timeline_name(cb->dma),\n\t\t  cb->dma->seqno,\n\t\t  i915_sw_fence_debug_hint(fence));\n\n\ti915_sw_fence_set_error_once(fence, -ETIMEDOUT);\n\ti915_sw_fence_complete(fence);\n}\n\nstatic void dma_i915_sw_fence_wake_timer(struct dma_fence *dma,\n\t\t\t\t\t struct dma_fence_cb *data)\n{\n\tstruct i915_sw_dma_fence_cb_timer *cb =\n\t\tcontainer_of(data, typeof(*cb), base.base);\n\tstruct i915_sw_fence *fence;\n\n\tfence = xchg(&cb->base.fence, NULL);\n\tif (fence) {\n\t\ti915_sw_fence_set_error_once(fence, dma->error);\n\t\ti915_sw_fence_complete(fence);\n\t}\n\n\tirq_work_queue(&cb->work);\n}\n\nstatic void irq_i915_sw_fence_work(struct irq_work *wrk)\n{\n\tstruct i915_sw_dma_fence_cb_timer *cb =\n\t\tcontainer_of(wrk, typeof(*cb), work);\n\n\ttimer_shutdown_sync(&cb->timer);\n\tdma_fence_put(cb->dma);\n\n\tkfree_rcu(cb, rcu);\n}\n\nint i915_sw_fence_await_dma_fence(struct i915_sw_fence *fence,\n\t\t\t\t  struct dma_fence *dma,\n\t\t\t\t  unsigned long timeout,\n\t\t\t\t  gfp_t gfp)\n{\n\tstruct i915_sw_dma_fence_cb *cb;\n\tdma_fence_func_t func;\n\tint ret;\n\n\tdebug_fence_assert(fence);\n\tmight_sleep_if(gfpflags_allow_blocking(gfp));\n\n\tif (dma_fence_is_signaled(dma)) {\n\t\ti915_sw_fence_set_error_once(fence, dma->error);\n\t\treturn 0;\n\t}\n\n\tcb = kmalloc(timeout ?\n\t\t     sizeof(struct i915_sw_dma_fence_cb_timer) :\n\t\t     sizeof(struct i915_sw_dma_fence_cb),\n\t\t     gfp);\n\tif (!cb) {\n\t\tif (!gfpflags_allow_blocking(gfp))\n\t\t\treturn -ENOMEM;\n\n\t\tret = dma_fence_wait(dma, false);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\ti915_sw_fence_set_error_once(fence, dma->error);\n\t\treturn 0;\n\t}\n\n\tcb->fence = fence;\n\ti915_sw_fence_await(fence);\n\n\tfunc = dma_i915_sw_fence_wake;\n\tif (timeout) {\n\t\tstruct i915_sw_dma_fence_cb_timer *timer =\n\t\t\tcontainer_of(cb, typeof(*timer), base);\n\n\t\ttimer->dma = dma_fence_get(dma);\n\t\tinit_irq_work(&timer->work, irq_i915_sw_fence_work);\n\n\t\ttimer_setup(&timer->timer,\n\t\t\t    timer_i915_sw_fence_wake, TIMER_IRQSAFE);\n\t\tmod_timer(&timer->timer, round_jiffies_up(jiffies + timeout));\n\n\t\tfunc = dma_i915_sw_fence_wake_timer;\n\t}\n\n\tret = dma_fence_add_callback(dma, &cb->base, func);\n\tif (ret == 0) {\n\t\tret = 1;\n\t} else {\n\t\tfunc(dma, &cb->base);\n\t\tif (ret == -ENOENT)  \n\t\t\tret = 0;\n\t}\n\n\treturn ret;\n}\n\nstatic void __dma_i915_sw_fence_wake(struct dma_fence *dma,\n\t\t\t\t     struct dma_fence_cb *data)\n{\n\tstruct i915_sw_dma_fence_cb *cb = container_of(data, typeof(*cb), base);\n\n\ti915_sw_fence_set_error_once(cb->fence, dma->error);\n\ti915_sw_fence_complete(cb->fence);\n}\n\nint __i915_sw_fence_await_dma_fence(struct i915_sw_fence *fence,\n\t\t\t\t    struct dma_fence *dma,\n\t\t\t\t    struct i915_sw_dma_fence_cb *cb)\n{\n\tint ret;\n\n\tdebug_fence_assert(fence);\n\n\tif (dma_fence_is_signaled(dma)) {\n\t\ti915_sw_fence_set_error_once(fence, dma->error);\n\t\treturn 0;\n\t}\n\n\tcb->fence = fence;\n\ti915_sw_fence_await(fence);\n\n\tret = 1;\n\tif (dma_fence_add_callback(dma, &cb->base, __dma_i915_sw_fence_wake)) {\n\t\t \n\t\t__dma_i915_sw_fence_wake(dma, &cb->base);\n\t\tret = 0;\n\t}\n\n\treturn ret;\n}\n\nint i915_sw_fence_await_reservation(struct i915_sw_fence *fence,\n\t\t\t\t    struct dma_resv *resv,\n\t\t\t\t    bool write,\n\t\t\t\t    unsigned long timeout,\n\t\t\t\t    gfp_t gfp)\n{\n\tstruct dma_resv_iter cursor;\n\tstruct dma_fence *f;\n\tint ret = 0, pending;\n\n\tdebug_fence_assert(fence);\n\tmight_sleep_if(gfpflags_allow_blocking(gfp));\n\n\tdma_resv_iter_begin(&cursor, resv, dma_resv_usage_rw(write));\n\tdma_resv_for_each_fence_unlocked(&cursor, f) {\n\t\tpending = i915_sw_fence_await_dma_fence(fence, f, timeout,\n\t\t\t\t\t\t\tgfp);\n\t\tif (pending < 0) {\n\t\t\tret = pending;\n\t\t\tbreak;\n\t\t}\n\n\t\tret |= pending;\n\t}\n\tdma_resv_iter_end(&cursor);\n\treturn ret;\n}\n\n#if IS_ENABLED(CONFIG_DRM_I915_SELFTEST)\n#include \"selftests/lib_sw_fence.c\"\n#include \"selftests/i915_sw_fence.c\"\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}