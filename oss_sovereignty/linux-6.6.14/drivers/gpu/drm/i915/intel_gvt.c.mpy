{
  "module_name": "intel_gvt.c",
  "hash_id": "78b73b9f2bbe2b4bd965ba24a5caaca412121ec723a143c914ef1d66aea890f8",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/i915/intel_gvt.c",
  "human_readable_source": " \n\n#include \"i915_drv.h\"\n#include \"i915_vgpu.h\"\n#include \"intel_gvt.h\"\n#include \"gem/i915_gem_dmabuf.h\"\n#include \"gt/intel_context.h\"\n#include \"gt/intel_ring.h\"\n#include \"gt/shmem_utils.h\"\n\n \n\nstatic LIST_HEAD(intel_gvt_devices);\nstatic const struct intel_vgpu_ops *intel_gvt_ops;\nstatic DEFINE_MUTEX(intel_gvt_mutex);\n\nstatic bool is_supported_device(struct drm_i915_private *dev_priv)\n{\n\tif (IS_BROADWELL(dev_priv))\n\t\treturn true;\n\tif (IS_SKYLAKE(dev_priv))\n\t\treturn true;\n\tif (IS_KABYLAKE(dev_priv))\n\t\treturn true;\n\tif (IS_BROXTON(dev_priv))\n\t\treturn true;\n\tif (IS_COFFEELAKE(dev_priv))\n\t\treturn true;\n\tif (IS_COMETLAKE(dev_priv))\n\t\treturn true;\n\n\treturn false;\n}\n\nstatic void free_initial_hw_state(struct drm_i915_private *dev_priv)\n{\n\tstruct i915_virtual_gpu *vgpu = &dev_priv->vgpu;\n\n\tvfree(vgpu->initial_mmio);\n\tvgpu->initial_mmio = NULL;\n\n\tkfree(vgpu->initial_cfg_space);\n\tvgpu->initial_cfg_space = NULL;\n}\n\nstatic void save_mmio(struct intel_gvt_mmio_table_iter *iter, u32 offset,\n\t\t      u32 size)\n{\n\tstruct drm_i915_private *dev_priv = iter->i915;\n\tu32 *mmio, i;\n\n\tfor (i = offset; i < offset + size; i += 4) {\n\t\tmmio = iter->data + i;\n\t\t*mmio = intel_uncore_read_notrace(to_gt(dev_priv)->uncore,\n\t\t\t\t\t\t  _MMIO(i));\n\t}\n}\n\nstatic int handle_mmio(struct intel_gvt_mmio_table_iter *iter,\n\t\t       u32 offset, u32 size)\n{\n\tif (WARN_ON(!IS_ALIGNED(offset, 4)))\n\t\treturn -EINVAL;\n\n\tsave_mmio(iter, offset, size);\n\treturn 0;\n}\n\nstatic int save_initial_hw_state(struct drm_i915_private *dev_priv)\n{\n\tstruct pci_dev *pdev = to_pci_dev(dev_priv->drm.dev);\n\tstruct i915_virtual_gpu *vgpu = &dev_priv->vgpu;\n\tstruct intel_gvt_mmio_table_iter iter;\n\tvoid *mem;\n\tint i, ret;\n\n\tmem = kzalloc(PCI_CFG_SPACE_EXP_SIZE, GFP_KERNEL);\n\tif (!mem)\n\t\treturn -ENOMEM;\n\n\tvgpu->initial_cfg_space = mem;\n\n\tfor (i = 0; i < PCI_CFG_SPACE_EXP_SIZE; i += 4)\n\t\tpci_read_config_dword(pdev, i, mem + i);\n\n\tmem = vzalloc(2 * SZ_1M);\n\tif (!mem) {\n\t\tret = -ENOMEM;\n\t\tgoto err_mmio;\n\t}\n\n\tvgpu->initial_mmio = mem;\n\n\titer.i915 = dev_priv;\n\titer.data = vgpu->initial_mmio;\n\titer.handle_mmio_cb = handle_mmio;\n\n\tret = intel_gvt_iterate_mmio_table(&iter);\n\tif (ret)\n\t\tgoto err_iterate;\n\n\treturn 0;\n\nerr_iterate:\n\tvfree(vgpu->initial_mmio);\n\tvgpu->initial_mmio = NULL;\nerr_mmio:\n\tkfree(vgpu->initial_cfg_space);\n\tvgpu->initial_cfg_space = NULL;\n\n\treturn ret;\n}\n\nstatic void intel_gvt_init_device(struct drm_i915_private *dev_priv)\n{\n\tif (!dev_priv->params.enable_gvt) {\n\t\tdrm_dbg(&dev_priv->drm,\n\t\t\t\"GVT-g is disabled by kernel params\\n\");\n\t\treturn;\n\t}\n\n\tif (intel_vgpu_active(dev_priv)) {\n\t\tdrm_info(&dev_priv->drm, \"GVT-g is disabled for guest\\n\");\n\t\treturn;\n\t}\n\n\tif (!is_supported_device(dev_priv)) {\n\t\tdrm_info(&dev_priv->drm,\n\t\t\t \"Unsupported device. GVT-g is disabled\\n\");\n\t\treturn;\n\t}\n\n\tif (intel_uc_wants_guc_submission(&to_gt(dev_priv)->uc)) {\n\t\tdrm_err(&dev_priv->drm,\n\t\t\t\"Graphics virtualization is not yet supported with GuC submission\\n\");\n\t\treturn;\n\t}\n\n\tif (save_initial_hw_state(dev_priv)) {\n\t\tdrm_dbg(&dev_priv->drm, \"Failed to save initial HW state\\n\");\n\t\treturn;\n\t}\n\n\tif (intel_gvt_ops->init_device(dev_priv))\n\t\tdrm_dbg(&dev_priv->drm, \"Fail to init GVT device\\n\");\n}\n\nstatic void intel_gvt_clean_device(struct drm_i915_private *dev_priv)\n{\n\tif (dev_priv->gvt)\n\t\tintel_gvt_ops->clean_device(dev_priv);\n\tfree_initial_hw_state(dev_priv);\n}\n\nint intel_gvt_set_ops(const struct intel_vgpu_ops *ops)\n{\n\tstruct drm_i915_private *dev_priv;\n\n\tmutex_lock(&intel_gvt_mutex);\n\tif (intel_gvt_ops) {\n\t\tmutex_unlock(&intel_gvt_mutex);\n\t\treturn -EINVAL;\n\t}\n\tintel_gvt_ops = ops;\n\n\tlist_for_each_entry(dev_priv, &intel_gvt_devices, vgpu.entry)\n\t\tintel_gvt_init_device(dev_priv);\n\tmutex_unlock(&intel_gvt_mutex);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_NS_GPL(intel_gvt_set_ops, I915_GVT);\n\nvoid intel_gvt_clear_ops(const struct intel_vgpu_ops *ops)\n{\n\tstruct drm_i915_private *dev_priv;\n\n\tmutex_lock(&intel_gvt_mutex);\n\tif (intel_gvt_ops != ops) {\n\t\tmutex_unlock(&intel_gvt_mutex);\n\t\treturn;\n\t}\n\n\tlist_for_each_entry(dev_priv, &intel_gvt_devices, vgpu.entry)\n\t\tintel_gvt_clean_device(dev_priv);\n\n\tintel_gvt_ops = NULL;\n\tmutex_unlock(&intel_gvt_mutex);\n}\nEXPORT_SYMBOL_NS_GPL(intel_gvt_clear_ops, I915_GVT);\n\n \nint intel_gvt_init(struct drm_i915_private *dev_priv)\n{\n\tif (i915_inject_probe_failure(dev_priv))\n\t\treturn -ENODEV;\n\n\tmutex_lock(&intel_gvt_mutex);\n\tlist_add_tail(&dev_priv->vgpu.entry, &intel_gvt_devices);\n\tif (intel_gvt_ops)\n\t\tintel_gvt_init_device(dev_priv);\n\tmutex_unlock(&intel_gvt_mutex);\n\n\treturn 0;\n}\n\n \nvoid intel_gvt_driver_remove(struct drm_i915_private *dev_priv)\n{\n\tmutex_lock(&intel_gvt_mutex);\n\tintel_gvt_clean_device(dev_priv);\n\tlist_del(&dev_priv->vgpu.entry);\n\tmutex_unlock(&intel_gvt_mutex);\n}\n\n \nvoid intel_gvt_resume(struct drm_i915_private *dev_priv)\n{\n\tmutex_lock(&intel_gvt_mutex);\n\tif (dev_priv->gvt)\n\t\tintel_gvt_ops->pm_resume(dev_priv);\n\tmutex_unlock(&intel_gvt_mutex);\n}\n\n \nEXPORT_SYMBOL_NS_GPL(i915_gem_object_alloc, I915_GVT);\nEXPORT_SYMBOL_NS_GPL(i915_gem_object_create_shmem, I915_GVT);\nEXPORT_SYMBOL_NS_GPL(i915_gem_object_init, I915_GVT);\nEXPORT_SYMBOL_NS_GPL(i915_gem_object_ggtt_pin_ww, I915_GVT);\nEXPORT_SYMBOL_NS_GPL(i915_gem_object_pin_map, I915_GVT);\nEXPORT_SYMBOL_NS_GPL(i915_gem_object_set_to_cpu_domain, I915_GVT);\nEXPORT_SYMBOL_NS_GPL(__i915_gem_object_flush_map, I915_GVT);\nEXPORT_SYMBOL_NS_GPL(__i915_gem_object_set_pages, I915_GVT);\nEXPORT_SYMBOL_NS_GPL(i915_gem_gtt_insert, I915_GVT);\nEXPORT_SYMBOL_NS_GPL(i915_gem_prime_export, I915_GVT);\nEXPORT_SYMBOL_NS_GPL(i915_gem_ww_ctx_init, I915_GVT);\nEXPORT_SYMBOL_NS_GPL(i915_gem_ww_ctx_backoff, I915_GVT);\nEXPORT_SYMBOL_NS_GPL(i915_gem_ww_ctx_fini, I915_GVT);\nEXPORT_SYMBOL_NS_GPL(i915_ppgtt_create, I915_GVT);\nEXPORT_SYMBOL_NS_GPL(i915_request_add, I915_GVT);\nEXPORT_SYMBOL_NS_GPL(i915_request_create, I915_GVT);\nEXPORT_SYMBOL_NS_GPL(i915_request_wait, I915_GVT);\nEXPORT_SYMBOL_NS_GPL(i915_reserve_fence, I915_GVT);\nEXPORT_SYMBOL_NS_GPL(i915_unreserve_fence, I915_GVT);\nEXPORT_SYMBOL_NS_GPL(i915_vm_release, I915_GVT);\nEXPORT_SYMBOL_NS_GPL(_i915_vma_move_to_active, I915_GVT);\nEXPORT_SYMBOL_NS_GPL(intel_context_create, I915_GVT);\nEXPORT_SYMBOL_NS_GPL(__intel_context_do_pin, I915_GVT);\nEXPORT_SYMBOL_NS_GPL(__intel_context_do_unpin, I915_GVT);\nEXPORT_SYMBOL_NS_GPL(intel_ring_begin, I915_GVT);\nEXPORT_SYMBOL_NS_GPL(intel_runtime_pm_get, I915_GVT);\n#if IS_ENABLED(CONFIG_DRM_I915_DEBUG_RUNTIME_PM)\nEXPORT_SYMBOL_NS_GPL(intel_runtime_pm_put, I915_GVT);\n#endif\nEXPORT_SYMBOL_NS_GPL(intel_runtime_pm_put_unchecked, I915_GVT);\nEXPORT_SYMBOL_NS_GPL(intel_uncore_forcewake_for_reg, I915_GVT);\nEXPORT_SYMBOL_NS_GPL(intel_uncore_forcewake_get, I915_GVT);\nEXPORT_SYMBOL_NS_GPL(intel_uncore_forcewake_put, I915_GVT);\nEXPORT_SYMBOL_NS_GPL(shmem_pin_map, I915_GVT);\nEXPORT_SYMBOL_NS_GPL(shmem_unpin_map, I915_GVT);\nEXPORT_SYMBOL_NS_GPL(__px_dma, I915_GVT);\nEXPORT_SYMBOL_NS_GPL(i915_fence_ops, I915_GVT);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}