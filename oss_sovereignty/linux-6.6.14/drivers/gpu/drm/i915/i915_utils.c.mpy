{
  "module_name": "i915_utils.c",
  "hash_id": "8a3c1a38efe24068ac6a6bb043ff0d80ed77d0887e3ae7a18d05d72d95d26173",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/i915/i915_utils.c",
  "human_readable_source": "\n \n\n#include <linux/device.h>\n\n#include <drm/drm_drv.h>\n\n#include \"i915_drv.h\"\n#include \"i915_utils.h\"\n\n#define FDO_BUG_MSG \"Please file a bug on drm/i915; see \" FDO_BUG_URL \" for details.\"\n\nvoid\n__i915_printk(struct drm_i915_private *dev_priv, const char *level,\n\t      const char *fmt, ...)\n{\n\tstatic bool shown_bug_once;\n\tstruct device *kdev = dev_priv->drm.dev;\n\tbool is_error = level[1] <= KERN_ERR[1];\n\tbool is_debug = level[1] == KERN_DEBUG[1];\n\tstruct va_format vaf;\n\tva_list args;\n\n\tif (is_debug && !drm_debug_enabled(DRM_UT_DRIVER))\n\t\treturn;\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tif (is_error)\n\t\tdev_printk(level, kdev, \"%pV\", &vaf);\n\telse\n\t\tdev_printk(level, kdev, \"[\" DRM_NAME \":%ps] %pV\",\n\t\t\t   __builtin_return_address(0), &vaf);\n\n\tva_end(args);\n\n\tif (is_error && !shown_bug_once) {\n\t\t \n\t\tif (!test_taint(TAINT_USER))\n\t\t\tdev_notice(kdev, \"%s\", FDO_BUG_MSG);\n\t\tshown_bug_once = true;\n\t}\n}\n\nvoid add_taint_for_CI(struct drm_i915_private *i915, unsigned int taint)\n{\n\t__i915_printk(i915, KERN_NOTICE, \"CI tainted:%#x by %pS\\n\",\n\t\t      taint, (void *)_RET_IP_);\n\n\t \n\tif (!i915_error_injected())\n\t\t__add_taint_for_CI(taint);\n}\n\n#if IS_ENABLED(CONFIG_DRM_I915_DEBUG)\nstatic unsigned int i915_probe_fail_count;\n\nint __i915_inject_probe_error(struct drm_i915_private *i915, int err,\n\t\t\t      const char *func, int line)\n{\n\tif (i915_probe_fail_count >= i915_modparams.inject_probe_failure)\n\t\treturn 0;\n\n\tif (++i915_probe_fail_count < i915_modparams.inject_probe_failure)\n\t\treturn 0;\n\n\t__i915_printk(i915, KERN_INFO,\n\t\t      \"Injecting failure %d at checkpoint %u [%s:%d]\\n\",\n\t\t      err, i915_modparams.inject_probe_failure, func, line);\n\ti915_modparams.inject_probe_failure = 0;\n\treturn err;\n}\n\nbool i915_error_injected(void)\n{\n\treturn i915_probe_fail_count && !i915_modparams.inject_probe_failure;\n}\n\n#endif\n\nvoid cancel_timer(struct timer_list *t)\n{\n\tif (!timer_active(t))\n\t\treturn;\n\n\tdel_timer(t);\n\tWRITE_ONCE(t->expires, 0);\n}\n\nvoid set_timer_ms(struct timer_list *t, unsigned long timeout)\n{\n\tif (!timeout) {\n\t\tcancel_timer(t);\n\t\treturn;\n\t}\n\n\ttimeout = msecs_to_jiffies(timeout);\n\n\t \n\tbarrier();\n\n\t \n\tmod_timer(t, jiffies + timeout ?: 1);\n}\n\nbool i915_vtd_active(struct drm_i915_private *i915)\n{\n\tif (device_iommu_mapped(i915->drm.dev))\n\t\treturn true;\n\n\t \n\treturn i915_run_as_guest();\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}