{
  "module_name": "i915_scatterlist.c",
  "hash_id": "c905a472e52bb1cb9bff8188706f9d2eefc464e57427f913e64611e9129ba7d5",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/i915/i915_scatterlist.c",
  "human_readable_source": " \n\n#include \"i915_scatterlist.h\"\n#include \"i915_ttm_buddy_manager.h\"\n\n#include <drm/drm_buddy.h>\n#include <drm/drm_mm.h>\n\n#include <linux/slab.h>\n\nbool i915_sg_trim(struct sg_table *orig_st)\n{\n\tstruct sg_table new_st;\n\tstruct scatterlist *sg, *new_sg;\n\tunsigned int i;\n\n\tif (orig_st->nents == orig_st->orig_nents)\n\t\treturn false;\n\n\tif (sg_alloc_table(&new_st, orig_st->nents, GFP_KERNEL | __GFP_NOWARN))\n\t\treturn false;\n\n\tnew_sg = new_st.sgl;\n\tfor_each_sg(orig_st->sgl, sg, orig_st->nents, i) {\n\t\tsg_set_page(new_sg, sg_page(sg), sg->length, 0);\n\t\tsg_dma_address(new_sg) = sg_dma_address(sg);\n\t\tsg_dma_len(new_sg) = sg_dma_len(sg);\n\n\t\tnew_sg = sg_next(new_sg);\n\t}\n\tGEM_BUG_ON(new_sg);  \n\n\tsg_free_table(orig_st);\n\n\t*orig_st = new_st;\n\treturn true;\n}\n\nstatic void i915_refct_sgt_release(struct kref *ref)\n{\n\tstruct i915_refct_sgt *rsgt =\n\t\tcontainer_of(ref, typeof(*rsgt), kref);\n\n\tsg_free_table(&rsgt->table);\n\tkfree(rsgt);\n}\n\nstatic const struct i915_refct_sgt_ops rsgt_ops = {\n\t.release = i915_refct_sgt_release\n};\n\n \nvoid i915_refct_sgt_init(struct i915_refct_sgt *rsgt, size_t size)\n{\n\t__i915_refct_sgt_init(rsgt, size, &rsgt_ops);\n}\n\n \nstruct i915_refct_sgt *i915_rsgt_from_mm_node(const struct drm_mm_node *node,\n\t\t\t\t\t      u64 region_start,\n\t\t\t\t\t      u32 page_alignment)\n{\n\tconst u32 max_segment = round_down(UINT_MAX, page_alignment);\n\tconst u32 segment_pages = max_segment >> PAGE_SHIFT;\n\tu64 block_size, offset, prev_end;\n\tstruct i915_refct_sgt *rsgt;\n\tstruct sg_table *st;\n\tstruct scatterlist *sg;\n\n\tGEM_BUG_ON(!max_segment);\n\n\trsgt = kmalloc(sizeof(*rsgt), GFP_KERNEL);\n\tif (!rsgt)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\ti915_refct_sgt_init(rsgt, node->size << PAGE_SHIFT);\n\tst = &rsgt->table;\n\t \n\tif (WARN_ON(overflows_type(DIV_ROUND_UP_ULL(node->size, segment_pages),\n\t\t\t\t   unsigned int))) {\n\t\ti915_refct_sgt_put(rsgt);\n\t\treturn ERR_PTR(-E2BIG);\n\t}\n\n\tif (sg_alloc_table(st, DIV_ROUND_UP_ULL(node->size, segment_pages),\n\t\t\t   GFP_KERNEL)) {\n\t\ti915_refct_sgt_put(rsgt);\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\n\tsg = st->sgl;\n\tst->nents = 0;\n\tprev_end = (resource_size_t)-1;\n\tblock_size = node->size << PAGE_SHIFT;\n\toffset = node->start << PAGE_SHIFT;\n\n\twhile (block_size) {\n\t\tu64 len;\n\n\t\tif (offset != prev_end || sg->length >= max_segment) {\n\t\t\tif (st->nents)\n\t\t\t\tsg = __sg_next(sg);\n\n\t\t\tsg_dma_address(sg) = region_start + offset;\n\t\t\tGEM_BUG_ON(!IS_ALIGNED(sg_dma_address(sg),\n\t\t\t\t\t       page_alignment));\n\t\t\tsg_dma_len(sg) = 0;\n\t\t\tsg->length = 0;\n\t\t\tst->nents++;\n\t\t}\n\n\t\tlen = min_t(u64, block_size, max_segment - sg->length);\n\t\tsg->length += len;\n\t\tsg_dma_len(sg) += len;\n\n\t\toffset += len;\n\t\tblock_size -= len;\n\n\t\tprev_end = offset;\n\t}\n\n\tsg_mark_end(sg);\n\ti915_sg_trim(st);\n\n\treturn rsgt;\n}\n\n \nstruct i915_refct_sgt *i915_rsgt_from_buddy_resource(struct ttm_resource *res,\n\t\t\t\t\t\t     u64 region_start,\n\t\t\t\t\t\t     u32 page_alignment)\n{\n\tstruct i915_ttm_buddy_resource *bman_res = to_ttm_buddy_resource(res);\n\tconst u64 size = res->size;\n\tconst u32 max_segment = round_down(UINT_MAX, page_alignment);\n\tstruct drm_buddy *mm = bman_res->mm;\n\tstruct list_head *blocks = &bman_res->blocks;\n\tstruct drm_buddy_block *block;\n\tstruct i915_refct_sgt *rsgt;\n\tstruct scatterlist *sg;\n\tstruct sg_table *st;\n\tresource_size_t prev_end;\n\n\tGEM_BUG_ON(list_empty(blocks));\n\tGEM_BUG_ON(!max_segment);\n\n\trsgt = kmalloc(sizeof(*rsgt), GFP_KERNEL);\n\tif (!rsgt)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\ti915_refct_sgt_init(rsgt, size);\n\tst = &rsgt->table;\n\t \n\tif (WARN_ON(overflows_type(PFN_UP(res->size), unsigned int))) {\n\t\ti915_refct_sgt_put(rsgt);\n\t\treturn ERR_PTR(-E2BIG);\n\t}\n\n\tif (sg_alloc_table(st, PFN_UP(res->size), GFP_KERNEL)) {\n\t\ti915_refct_sgt_put(rsgt);\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\n\tsg = st->sgl;\n\tst->nents = 0;\n\tprev_end = (resource_size_t)-1;\n\n\tlist_for_each_entry(block, blocks, link) {\n\t\tu64 block_size, offset;\n\n\t\tblock_size = min_t(u64, size, drm_buddy_block_size(mm, block));\n\t\toffset = drm_buddy_block_offset(block);\n\n\t\twhile (block_size) {\n\t\t\tu64 len;\n\n\t\t\tif (offset != prev_end || sg->length >= max_segment) {\n\t\t\t\tif (st->nents)\n\t\t\t\t\tsg = __sg_next(sg);\n\n\t\t\t\tsg_dma_address(sg) = region_start + offset;\n\t\t\t\tGEM_BUG_ON(!IS_ALIGNED(sg_dma_address(sg),\n\t\t\t\t\t\t       page_alignment));\n\t\t\t\tsg_dma_len(sg) = 0;\n\t\t\t\tsg->length = 0;\n\t\t\t\tst->nents++;\n\t\t\t}\n\n\t\t\tlen = min_t(u64, block_size, max_segment - sg->length);\n\t\t\tsg->length += len;\n\t\t\tsg_dma_len(sg) += len;\n\n\t\t\toffset += len;\n\t\t\tblock_size -= len;\n\n\t\t\tprev_end = offset;\n\t\t}\n\t}\n\n\tsg_mark_end(sg);\n\ti915_sg_trim(st);\n\n\treturn rsgt;\n}\n\n#if IS_ENABLED(CONFIG_DRM_I915_SELFTEST)\n#include \"selftests/scatterlist.c\"\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}