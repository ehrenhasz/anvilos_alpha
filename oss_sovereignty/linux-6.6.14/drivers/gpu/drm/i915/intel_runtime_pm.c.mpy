{
  "module_name": "intel_runtime_pm.c",
  "hash_id": "1adc83d1734ee7a8ee9b0e4a9167c7331d169a4e9d914613c0efa6813be8d87f",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/i915/intel_runtime_pm.c",
  "human_readable_source": " \n\n#include <linux/pm_runtime.h>\n\n#include <drm/drm_print.h>\n\n#include \"i915_drv.h\"\n#include \"i915_trace.h\"\n\n \n\n#if IS_ENABLED(CONFIG_DRM_I915_DEBUG_RUNTIME_PM)\n\n#include <linux/sort.h>\n\n#define STACKDEPTH 8\n\nstatic noinline depot_stack_handle_t __save_depot_stack(void)\n{\n\tunsigned long entries[STACKDEPTH];\n\tunsigned int n;\n\n\tn = stack_trace_save(entries, ARRAY_SIZE(entries), 1);\n\treturn stack_depot_save(entries, n, GFP_NOWAIT | __GFP_NOWARN);\n}\n\nstatic void init_intel_runtime_pm_wakeref(struct intel_runtime_pm *rpm)\n{\n\tspin_lock_init(&rpm->debug.lock);\n\tstack_depot_init();\n}\n\nstatic noinline depot_stack_handle_t\ntrack_intel_runtime_pm_wakeref(struct intel_runtime_pm *rpm)\n{\n\tdepot_stack_handle_t stack, *stacks;\n\tunsigned long flags;\n\n\tif (rpm->no_wakeref_tracking)\n\t\treturn -1;\n\n\tstack = __save_depot_stack();\n\tif (!stack)\n\t\treturn -1;\n\n\tspin_lock_irqsave(&rpm->debug.lock, flags);\n\n\tif (!rpm->debug.count)\n\t\trpm->debug.last_acquire = stack;\n\n\tstacks = krealloc(rpm->debug.owners,\n\t\t\t  (rpm->debug.count + 1) * sizeof(*stacks),\n\t\t\t  GFP_NOWAIT | __GFP_NOWARN);\n\tif (stacks) {\n\t\tstacks[rpm->debug.count++] = stack;\n\t\trpm->debug.owners = stacks;\n\t} else {\n\t\tstack = -1;\n\t}\n\n\tspin_unlock_irqrestore(&rpm->debug.lock, flags);\n\n\treturn stack;\n}\n\nstatic void untrack_intel_runtime_pm_wakeref(struct intel_runtime_pm *rpm,\n\t\t\t\t\t     depot_stack_handle_t stack)\n{\n\tstruct drm_i915_private *i915 = container_of(rpm,\n\t\t\t\t\t\t     struct drm_i915_private,\n\t\t\t\t\t\t     runtime_pm);\n\tunsigned long flags, n;\n\tbool found = false;\n\n\tif (unlikely(stack == -1))\n\t\treturn;\n\n\tspin_lock_irqsave(&rpm->debug.lock, flags);\n\tfor (n = rpm->debug.count; n--; ) {\n\t\tif (rpm->debug.owners[n] == stack) {\n\t\t\tmemmove(rpm->debug.owners + n,\n\t\t\t\trpm->debug.owners + n + 1,\n\t\t\t\t(--rpm->debug.count - n) * sizeof(stack));\n\t\t\tfound = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock_irqrestore(&rpm->debug.lock, flags);\n\n\tif (drm_WARN(&i915->drm, !found,\n\t\t     \"Unmatched wakeref (tracking %lu), count %u\\n\",\n\t\t     rpm->debug.count, atomic_read(&rpm->wakeref_count))) {\n\t\tchar *buf;\n\n\t\tbuf = kmalloc(PAGE_SIZE, GFP_NOWAIT | __GFP_NOWARN);\n\t\tif (!buf)\n\t\t\treturn;\n\n\t\tstack_depot_snprint(stack, buf, PAGE_SIZE, 2);\n\t\tDRM_DEBUG_DRIVER(\"wakeref %x from\\n%s\", stack, buf);\n\n\t\tstack = READ_ONCE(rpm->debug.last_release);\n\t\tif (stack) {\n\t\t\tstack_depot_snprint(stack, buf, PAGE_SIZE, 2);\n\t\t\tDRM_DEBUG_DRIVER(\"wakeref last released at\\n%s\", buf);\n\t\t}\n\n\t\tkfree(buf);\n\t}\n}\n\nstatic int cmphandle(const void *_a, const void *_b)\n{\n\tconst depot_stack_handle_t * const a = _a, * const b = _b;\n\n\tif (*a < *b)\n\t\treturn -1;\n\telse if (*a > *b)\n\t\treturn 1;\n\telse\n\t\treturn 0;\n}\n\nstatic void\n__print_intel_runtime_pm_wakeref(struct drm_printer *p,\n\t\t\t\t const struct intel_runtime_pm_debug *dbg)\n{\n\tunsigned long i;\n\tchar *buf;\n\n\tbuf = kmalloc(PAGE_SIZE, GFP_NOWAIT | __GFP_NOWARN);\n\tif (!buf)\n\t\treturn;\n\n\tif (dbg->last_acquire) {\n\t\tstack_depot_snprint(dbg->last_acquire, buf, PAGE_SIZE, 2);\n\t\tdrm_printf(p, \"Wakeref last acquired:\\n%s\", buf);\n\t}\n\n\tif (dbg->last_release) {\n\t\tstack_depot_snprint(dbg->last_release, buf, PAGE_SIZE, 2);\n\t\tdrm_printf(p, \"Wakeref last released:\\n%s\", buf);\n\t}\n\n\tdrm_printf(p, \"Wakeref count: %lu\\n\", dbg->count);\n\n\tsort(dbg->owners, dbg->count, sizeof(*dbg->owners), cmphandle, NULL);\n\n\tfor (i = 0; i < dbg->count; i++) {\n\t\tdepot_stack_handle_t stack = dbg->owners[i];\n\t\tunsigned long rep;\n\n\t\trep = 1;\n\t\twhile (i + 1 < dbg->count && dbg->owners[i + 1] == stack)\n\t\t\trep++, i++;\n\t\tstack_depot_snprint(stack, buf, PAGE_SIZE, 2);\n\t\tdrm_printf(p, \"Wakeref x%lu taken at:\\n%s\", rep, buf);\n\t}\n\n\tkfree(buf);\n}\n\nstatic noinline void\n__untrack_all_wakerefs(struct intel_runtime_pm_debug *debug,\n\t\t       struct intel_runtime_pm_debug *saved)\n{\n\t*saved = *debug;\n\n\tdebug->owners = NULL;\n\tdebug->count = 0;\n\tdebug->last_release = __save_depot_stack();\n}\n\nstatic void\ndump_and_free_wakeref_tracking(struct intel_runtime_pm_debug *debug)\n{\n\tif (debug->count) {\n\t\tstruct drm_printer p = drm_debug_printer(\"i915\");\n\n\t\t__print_intel_runtime_pm_wakeref(&p, debug);\n\t}\n\n\tkfree(debug->owners);\n}\n\nstatic noinline void\n__intel_wakeref_dec_and_check_tracking(struct intel_runtime_pm *rpm)\n{\n\tstruct intel_runtime_pm_debug dbg = {};\n\tunsigned long flags;\n\n\tif (!atomic_dec_and_lock_irqsave(&rpm->wakeref_count,\n\t\t\t\t\t &rpm->debug.lock,\n\t\t\t\t\t flags))\n\t\treturn;\n\n\t__untrack_all_wakerefs(&rpm->debug, &dbg);\n\tspin_unlock_irqrestore(&rpm->debug.lock, flags);\n\n\tdump_and_free_wakeref_tracking(&dbg);\n}\n\nstatic noinline void\nuntrack_all_intel_runtime_pm_wakerefs(struct intel_runtime_pm *rpm)\n{\n\tstruct intel_runtime_pm_debug dbg = {};\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&rpm->debug.lock, flags);\n\t__untrack_all_wakerefs(&rpm->debug, &dbg);\n\tspin_unlock_irqrestore(&rpm->debug.lock, flags);\n\n\tdump_and_free_wakeref_tracking(&dbg);\n}\n\nvoid print_intel_runtime_pm_wakeref(struct intel_runtime_pm *rpm,\n\t\t\t\t    struct drm_printer *p)\n{\n\tstruct intel_runtime_pm_debug dbg = {};\n\n\tdo {\n\t\tunsigned long alloc = dbg.count;\n\t\tdepot_stack_handle_t *s;\n\n\t\tspin_lock_irq(&rpm->debug.lock);\n\t\tdbg.count = rpm->debug.count;\n\t\tif (dbg.count <= alloc) {\n\t\t\tmemcpy(dbg.owners,\n\t\t\t       rpm->debug.owners,\n\t\t\t       dbg.count * sizeof(*s));\n\t\t}\n\t\tdbg.last_acquire = rpm->debug.last_acquire;\n\t\tdbg.last_release = rpm->debug.last_release;\n\t\tspin_unlock_irq(&rpm->debug.lock);\n\t\tif (dbg.count <= alloc)\n\t\t\tbreak;\n\n\t\ts = krealloc(dbg.owners,\n\t\t\t     dbg.count * sizeof(*s),\n\t\t\t     GFP_NOWAIT | __GFP_NOWARN);\n\t\tif (!s)\n\t\t\tgoto out;\n\n\t\tdbg.owners = s;\n\t} while (1);\n\n\t__print_intel_runtime_pm_wakeref(p, &dbg);\n\nout:\n\tkfree(dbg.owners);\n}\n\n#else\n\nstatic void init_intel_runtime_pm_wakeref(struct intel_runtime_pm *rpm)\n{\n}\n\nstatic depot_stack_handle_t\ntrack_intel_runtime_pm_wakeref(struct intel_runtime_pm *rpm)\n{\n\treturn -1;\n}\n\nstatic void untrack_intel_runtime_pm_wakeref(struct intel_runtime_pm *rpm,\n\t\t\t\t\t     intel_wakeref_t wref)\n{\n}\n\nstatic void\n__intel_wakeref_dec_and_check_tracking(struct intel_runtime_pm *rpm)\n{\n\tatomic_dec(&rpm->wakeref_count);\n}\n\nstatic void\nuntrack_all_intel_runtime_pm_wakerefs(struct intel_runtime_pm *rpm)\n{\n}\n\n#endif\n\nstatic void\nintel_runtime_pm_acquire(struct intel_runtime_pm *rpm, bool wakelock)\n{\n\tif (wakelock) {\n\t\tatomic_add(1 + INTEL_RPM_WAKELOCK_BIAS, &rpm->wakeref_count);\n\t\tassert_rpm_wakelock_held(rpm);\n\t} else {\n\t\tatomic_inc(&rpm->wakeref_count);\n\t\tassert_rpm_raw_wakeref_held(rpm);\n\t}\n}\n\nstatic void\nintel_runtime_pm_release(struct intel_runtime_pm *rpm, int wakelock)\n{\n\tif (wakelock) {\n\t\tassert_rpm_wakelock_held(rpm);\n\t\tatomic_sub(INTEL_RPM_WAKELOCK_BIAS, &rpm->wakeref_count);\n\t} else {\n\t\tassert_rpm_raw_wakeref_held(rpm);\n\t}\n\n\t__intel_wakeref_dec_and_check_tracking(rpm);\n}\n\nstatic intel_wakeref_t __intel_runtime_pm_get(struct intel_runtime_pm *rpm,\n\t\t\t\t\t      bool wakelock)\n{\n\tstruct drm_i915_private *i915 = container_of(rpm,\n\t\t\t\t\t\t     struct drm_i915_private,\n\t\t\t\t\t\t     runtime_pm);\n\tint ret;\n\n\tret = pm_runtime_get_sync(rpm->kdev);\n\tdrm_WARN_ONCE(&i915->drm, ret < 0,\n\t\t      \"pm_runtime_get_sync() failed: %d\\n\", ret);\n\n\tintel_runtime_pm_acquire(rpm, wakelock);\n\n\treturn track_intel_runtime_pm_wakeref(rpm);\n}\n\n \nintel_wakeref_t intel_runtime_pm_get_raw(struct intel_runtime_pm *rpm)\n{\n\treturn __intel_runtime_pm_get(rpm, false);\n}\n\n \nintel_wakeref_t intel_runtime_pm_get(struct intel_runtime_pm *rpm)\n{\n\treturn __intel_runtime_pm_get(rpm, true);\n}\n\n \nstatic intel_wakeref_t __intel_runtime_pm_get_if_active(struct intel_runtime_pm *rpm,\n\t\t\t\t\t\t\tbool ignore_usecount)\n{\n\tif (IS_ENABLED(CONFIG_PM)) {\n\t\t \n\t\tif (pm_runtime_get_if_active(rpm->kdev, ignore_usecount) <= 0)\n\t\t\treturn 0;\n\t}\n\n\tintel_runtime_pm_acquire(rpm, true);\n\n\treturn track_intel_runtime_pm_wakeref(rpm);\n}\n\nintel_wakeref_t intel_runtime_pm_get_if_in_use(struct intel_runtime_pm *rpm)\n{\n\treturn __intel_runtime_pm_get_if_active(rpm, false);\n}\n\nintel_wakeref_t intel_runtime_pm_get_if_active(struct intel_runtime_pm *rpm)\n{\n\treturn __intel_runtime_pm_get_if_active(rpm, true);\n}\n\n \nintel_wakeref_t intel_runtime_pm_get_noresume(struct intel_runtime_pm *rpm)\n{\n\tassert_rpm_wakelock_held(rpm);\n\tpm_runtime_get_noresume(rpm->kdev);\n\n\tintel_runtime_pm_acquire(rpm, true);\n\n\treturn track_intel_runtime_pm_wakeref(rpm);\n}\n\nstatic void __intel_runtime_pm_put(struct intel_runtime_pm *rpm,\n\t\t\t\t   intel_wakeref_t wref,\n\t\t\t\t   bool wakelock)\n{\n\tstruct device *kdev = rpm->kdev;\n\n\tuntrack_intel_runtime_pm_wakeref(rpm, wref);\n\n\tintel_runtime_pm_release(rpm, wakelock);\n\n\tpm_runtime_mark_last_busy(kdev);\n\tpm_runtime_put_autosuspend(kdev);\n}\n\n \nvoid\nintel_runtime_pm_put_raw(struct intel_runtime_pm *rpm, intel_wakeref_t wref)\n{\n\t__intel_runtime_pm_put(rpm, wref, false);\n}\n\n \nvoid intel_runtime_pm_put_unchecked(struct intel_runtime_pm *rpm)\n{\n\t__intel_runtime_pm_put(rpm, -1, true);\n}\n\n#if IS_ENABLED(CONFIG_DRM_I915_DEBUG_RUNTIME_PM)\n \nvoid intel_runtime_pm_put(struct intel_runtime_pm *rpm, intel_wakeref_t wref)\n{\n\t__intel_runtime_pm_put(rpm, wref, true);\n}\n#endif\n\n \nvoid intel_runtime_pm_enable(struct intel_runtime_pm *rpm)\n{\n\tstruct drm_i915_private *i915 = container_of(rpm,\n\t\t\t\t\t\t     struct drm_i915_private,\n\t\t\t\t\t\t     runtime_pm);\n\tstruct device *kdev = rpm->kdev;\n\n\t \n\tdev_pm_set_driver_flags(kdev, DPM_FLAG_NO_DIRECT_COMPLETE);\n\n\tpm_runtime_set_autosuspend_delay(kdev, 10000);  \n\tpm_runtime_mark_last_busy(kdev);\n\n\t \n\tif (!rpm->available) {\n\t\tint ret;\n\n\t\tpm_runtime_dont_use_autosuspend(kdev);\n\t\tret = pm_runtime_get_sync(kdev);\n\t\tdrm_WARN(&i915->drm, ret < 0,\n\t\t\t \"pm_runtime_get_sync() failed: %d\\n\", ret);\n\t} else {\n\t\tpm_runtime_use_autosuspend(kdev);\n\t}\n\n\t \n\tif (!IS_DGFX(i915))\n\t\tpm_runtime_allow(kdev);\n\n\t \n\tpm_runtime_put_autosuspend(kdev);\n}\n\nvoid intel_runtime_pm_disable(struct intel_runtime_pm *rpm)\n{\n\tstruct drm_i915_private *i915 = container_of(rpm,\n\t\t\t\t\t\t     struct drm_i915_private,\n\t\t\t\t\t\t     runtime_pm);\n\tstruct device *kdev = rpm->kdev;\n\n\t \n\tdrm_WARN(&i915->drm, pm_runtime_get_sync(kdev) < 0,\n\t\t \"Failed to pass rpm ownership back to core\\n\");\n\n\tpm_runtime_dont_use_autosuspend(kdev);\n\n\tif (!rpm->available)\n\t\tpm_runtime_put(kdev);\n}\n\nvoid intel_runtime_pm_driver_release(struct intel_runtime_pm *rpm)\n{\n\tstruct drm_i915_private *i915 = container_of(rpm,\n\t\t\t\t\t\t     struct drm_i915_private,\n\t\t\t\t\t\t     runtime_pm);\n\tint count = atomic_read(&rpm->wakeref_count);\n\n\tintel_wakeref_auto_fini(&rpm->userfault_wakeref);\n\n\tdrm_WARN(&i915->drm, count,\n\t\t \"i915 raw-wakerefs=%d wakelocks=%d on cleanup\\n\",\n\t\t intel_rpm_raw_wakeref_count(count),\n\t\t intel_rpm_wakelock_count(count));\n\n\tuntrack_all_intel_runtime_pm_wakerefs(rpm);\n}\n\nvoid intel_runtime_pm_init_early(struct intel_runtime_pm *rpm)\n{\n\tstruct drm_i915_private *i915 =\n\t\t\tcontainer_of(rpm, struct drm_i915_private, runtime_pm);\n\tstruct pci_dev *pdev = to_pci_dev(i915->drm.dev);\n\tstruct device *kdev = &pdev->dev;\n\n\trpm->kdev = kdev;\n\trpm->available = HAS_RUNTIME_PM(i915);\n\trpm->suspended = false;\n\tatomic_set(&rpm->wakeref_count, 0);\n\n\tinit_intel_runtime_pm_wakeref(rpm);\n\tINIT_LIST_HEAD(&rpm->lmem_userfault_list);\n\tspin_lock_init(&rpm->lmem_userfault_lock);\n\tintel_wakeref_auto_init(&rpm->userfault_wakeref, i915);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}