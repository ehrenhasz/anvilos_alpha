{
  "module_name": "i915_deps.c",
  "hash_id": "fe412858a579ff994b49249b2ab4db10307fd26b888e5090207636b7cad0f4eb",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/i915/i915_deps.c",
  "human_readable_source": "\n \n\n#include <linux/dma-fence.h>\n#include <linux/slab.h>\n\n#include <drm/ttm/ttm_bo.h>\n\n#include \"i915_deps.h\"\n\n \n\n \n#define I915_DEPS_MIN_ALLOC_CHUNK 8U\n\nstatic void i915_deps_reset_fences(struct i915_deps *deps)\n{\n\tif (deps->fences != &deps->single)\n\t\tkfree(deps->fences);\n\tdeps->num_deps = 0;\n\tdeps->fences_size = 1;\n\tdeps->fences = &deps->single;\n}\n\n \nvoid i915_deps_init(struct i915_deps *deps, gfp_t gfp)\n{\n\tdeps->fences = NULL;\n\tdeps->gfp = gfp;\n\ti915_deps_reset_fences(deps);\n}\n\n \nvoid i915_deps_fini(struct i915_deps *deps)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < deps->num_deps; ++i)\n\t\tdma_fence_put(deps->fences[i]);\n\n\tif (deps->fences != &deps->single)\n\t\tkfree(deps->fences);\n}\n\nstatic int i915_deps_grow(struct i915_deps *deps, struct dma_fence *fence,\n\t\t\t  const struct ttm_operation_ctx *ctx)\n{\n\tint ret;\n\n\tif (deps->num_deps >= deps->fences_size) {\n\t\tunsigned int new_size = 2 * deps->fences_size;\n\t\tstruct dma_fence **new_fences;\n\n\t\tnew_size = max(new_size, I915_DEPS_MIN_ALLOC_CHUNK);\n\t\tnew_fences = kmalloc_array(new_size, sizeof(*new_fences), deps->gfp);\n\t\tif (!new_fences)\n\t\t\tgoto sync;\n\n\t\tmemcpy(new_fences, deps->fences,\n\t\t       deps->fences_size * sizeof(*new_fences));\n\t\tswap(new_fences, deps->fences);\n\t\tif (new_fences != &deps->single)\n\t\t\tkfree(new_fences);\n\t\tdeps->fences_size = new_size;\n\t}\n\tdeps->fences[deps->num_deps++] = dma_fence_get(fence);\n\treturn 0;\n\nsync:\n\tif (ctx->no_wait_gpu && !dma_fence_is_signaled(fence)) {\n\t\tret = -EBUSY;\n\t\tgoto unref;\n\t}\n\n\tret = dma_fence_wait(fence, ctx->interruptible);\n\tif (ret)\n\t\tgoto unref;\n\n\tret = fence->error;\n\tif (ret)\n\t\tgoto unref;\n\n\treturn 0;\n\nunref:\n\ti915_deps_fini(deps);\n\treturn ret;\n}\n\n \nint i915_deps_sync(const struct i915_deps *deps, const struct ttm_operation_ctx *ctx)\n{\n\tstruct dma_fence **fences = deps->fences;\n\tunsigned int i;\n\tint ret = 0;\n\n\tfor (i = 0; i < deps->num_deps; ++i, ++fences) {\n\t\tif (ctx->no_wait_gpu && !dma_fence_is_signaled(*fences)) {\n\t\t\tret = -EBUSY;\n\t\t\tbreak;\n\t\t}\n\n\t\tret = dma_fence_wait(*fences, ctx->interruptible);\n\t\tif (!ret)\n\t\t\tret = (*fences)->error;\n\t\tif (ret)\n\t\t\tbreak;\n\t}\n\n\treturn ret;\n}\n\n \nint i915_deps_add_dependency(struct i915_deps *deps,\n\t\t\t     struct dma_fence *fence,\n\t\t\t     const struct ttm_operation_ctx *ctx)\n{\n\tunsigned int i;\n\tint ret;\n\n\tif (!fence)\n\t\treturn 0;\n\n\tif (dma_fence_is_signaled(fence)) {\n\t\tret = fence->error;\n\t\tif (ret)\n\t\t\ti915_deps_fini(deps);\n\t\treturn ret;\n\t}\n\n\tfor (i = 0; i < deps->num_deps; ++i) {\n\t\tstruct dma_fence *entry = deps->fences[i];\n\n\t\tif (!entry->context || entry->context != fence->context)\n\t\t\tcontinue;\n\n\t\tif (dma_fence_is_later(fence, entry)) {\n\t\t\tdma_fence_put(entry);\n\t\t\tdeps->fences[i] = dma_fence_get(fence);\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\treturn i915_deps_grow(deps, fence, ctx);\n}\n\n \nint i915_deps_add_resv(struct i915_deps *deps, struct dma_resv *resv,\n\t\t       const struct ttm_operation_ctx *ctx)\n{\n\tstruct dma_resv_iter iter;\n\tstruct dma_fence *fence;\n\n\tdma_resv_assert_held(resv);\n\tdma_resv_for_each_fence(&iter, resv, dma_resv_usage_rw(true), fence) {\n\t\tint ret = i915_deps_add_dependency(deps, fence, ctx);\n\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}