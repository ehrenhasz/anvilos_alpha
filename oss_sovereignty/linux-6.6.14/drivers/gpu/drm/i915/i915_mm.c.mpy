{
  "module_name": "i915_mm.c",
  "hash_id": "981412cf298229b05a72a7dcb60408a1817ee68360b66faf2e831785f5eacf81",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/i915/i915_mm.c",
  "human_readable_source": " \n\n#include <linux/mm.h>\n#include <linux/io-mapping.h>\n\n\n#include \"i915_drv.h\"\n#include \"i915_mm.h\"\n\nstruct remap_pfn {\n\tstruct mm_struct *mm;\n\tunsigned long pfn;\n\tpgprot_t prot;\n\n\tstruct sgt_iter sgt;\n\tresource_size_t iobase;\n};\n\n#define use_dma(io) ((io) != -1)\n\nstatic inline unsigned long sgt_pfn(const struct remap_pfn *r)\n{\n\tif (use_dma(r->iobase))\n\t\treturn (r->sgt.dma + r->sgt.curr + r->iobase) >> PAGE_SHIFT;\n\telse\n\t\treturn r->sgt.pfn + (r->sgt.curr >> PAGE_SHIFT);\n}\n\nstatic int remap_sg(pte_t *pte, unsigned long addr, void *data)\n{\n\tstruct remap_pfn *r = data;\n\n\tif (GEM_WARN_ON(!r->sgt.sgp))\n\t\treturn -EINVAL;\n\n\t \n\tset_pte_at(r->mm, addr, pte,\n\t\t   pte_mkspecial(pfn_pte(sgt_pfn(r), r->prot)));\n\tr->pfn++;  \n\n\tr->sgt.curr += PAGE_SIZE;\n\tif (r->sgt.curr >= r->sgt.max)\n\t\tr->sgt = __sgt_iter(__sg_next(r->sgt.sgp), use_dma(r->iobase));\n\n\treturn 0;\n}\n\n#define EXPECTED_FLAGS (VM_PFNMAP | VM_DONTEXPAND | VM_DONTDUMP)\n\n#if IS_ENABLED(CONFIG_X86)\nstatic int remap_pfn(pte_t *pte, unsigned long addr, void *data)\n{\n\tstruct remap_pfn *r = data;\n\n\t \n\tset_pte_at(r->mm, addr, pte, pte_mkspecial(pfn_pte(r->pfn, r->prot)));\n\tr->pfn++;\n\n\treturn 0;\n}\n\n \nint remap_io_mapping(struct vm_area_struct *vma,\n\t\t     unsigned long addr, unsigned long pfn, unsigned long size,\n\t\t     struct io_mapping *iomap)\n{\n\tstruct remap_pfn r;\n\tint err;\n\n\tGEM_BUG_ON((vma->vm_flags & EXPECTED_FLAGS) != EXPECTED_FLAGS);\n\n\t \n\tr.mm = vma->vm_mm;\n\tr.pfn = pfn;\n\tr.prot = __pgprot((pgprot_val(iomap->prot) & _PAGE_CACHE_MASK) |\n\t\t\t  (pgprot_val(vma->vm_page_prot) & ~_PAGE_CACHE_MASK));\n\n\terr = apply_to_page_range(r.mm, addr, size, remap_pfn, &r);\n\tif (unlikely(err)) {\n\t\tzap_vma_ptes(vma, addr, (r.pfn - pfn) << PAGE_SHIFT);\n\t\treturn err;\n\t}\n\n\treturn 0;\n}\n#endif\n\n \nint remap_io_sg(struct vm_area_struct *vma,\n\t\tunsigned long addr, unsigned long size,\n\t\tstruct scatterlist *sgl, resource_size_t iobase)\n{\n\tstruct remap_pfn r = {\n\t\t.mm = vma->vm_mm,\n\t\t.prot = vma->vm_page_prot,\n\t\t.sgt = __sgt_iter(sgl, use_dma(iobase)),\n\t\t.iobase = iobase,\n\t};\n\tint err;\n\n\t \n\tGEM_BUG_ON((vma->vm_flags & EXPECTED_FLAGS) != EXPECTED_FLAGS);\n\n\tif (!use_dma(iobase))\n\t\tflush_cache_range(vma, addr, size);\n\n\terr = apply_to_page_range(r.mm, addr, size, remap_sg, &r);\n\tif (unlikely(err)) {\n\t\tzap_vma_ptes(vma, addr, r.pfn << PAGE_SHIFT);\n\t\treturn err;\n\t}\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}