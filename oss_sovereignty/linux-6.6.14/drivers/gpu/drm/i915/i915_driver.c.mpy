{
  "module_name": "i915_driver.c",
  "hash_id": "6c99e7a424863ebf61aa133fdd1126aeee105eec4890ce9e4032969a2bf89a55",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/i915/i915_driver.c",
  "human_readable_source": " \n \n\n#include <linux/acpi.h>\n#include <linux/device.h>\n#include <linux/module.h>\n#include <linux/oom.h>\n#include <linux/pci.h>\n#include <linux/pm.h>\n#include <linux/pm_runtime.h>\n#include <linux/slab.h>\n#include <linux/string_helpers.h>\n#include <linux/vga_switcheroo.h>\n#include <linux/vt.h>\n\n#include <drm/drm_aperture.h>\n#include <drm/drm_atomic_helper.h>\n#include <drm/drm_ioctl.h>\n#include <drm/drm_managed.h>\n#include <drm/drm_probe_helper.h>\n\n#include \"display/intel_acpi.h\"\n#include \"display/intel_bw.h\"\n#include \"display/intel_cdclk.h\"\n#include \"display/intel_display_driver.h\"\n#include \"display/intel_display_types.h\"\n#include \"display/intel_dmc.h\"\n#include \"display/intel_dp.h\"\n#include \"display/intel_dpt.h\"\n#include \"display/intel_fbdev.h\"\n#include \"display/intel_hotplug.h\"\n#include \"display/intel_overlay.h\"\n#include \"display/intel_pch_refclk.h\"\n#include \"display/intel_pipe_crc.h\"\n#include \"display/intel_pps.h\"\n#include \"display/intel_sprite.h\"\n#include \"display/intel_vga.h\"\n#include \"display/skl_watermark.h\"\n\n#include \"gem/i915_gem_context.h\"\n#include \"gem/i915_gem_create.h\"\n#include \"gem/i915_gem_dmabuf.h\"\n#include \"gem/i915_gem_ioctls.h\"\n#include \"gem/i915_gem_mman.h\"\n#include \"gem/i915_gem_pm.h\"\n#include \"gt/intel_gt.h\"\n#include \"gt/intel_gt_pm.h\"\n#include \"gt/intel_rc6.h\"\n\n#include \"pxp/intel_pxp.h\"\n#include \"pxp/intel_pxp_debugfs.h\"\n#include \"pxp/intel_pxp_pm.h\"\n\n#include \"soc/intel_dram.h\"\n#include \"soc/intel_gmch.h\"\n\n#include \"i915_debugfs.h\"\n#include \"i915_driver.h\"\n#include \"i915_drm_client.h\"\n#include \"i915_drv.h\"\n#include \"i915_file_private.h\"\n#include \"i915_getparam.h\"\n#include \"i915_hwmon.h\"\n#include \"i915_ioc32.h\"\n#include \"i915_ioctl.h\"\n#include \"i915_irq.h\"\n#include \"i915_memcpy.h\"\n#include \"i915_perf.h\"\n#include \"i915_query.h\"\n#include \"i915_suspend.h\"\n#include \"i915_switcheroo.h\"\n#include \"i915_sysfs.h\"\n#include \"i915_utils.h\"\n#include \"i915_vgpu.h\"\n#include \"intel_clock_gating.h\"\n#include \"intel_gvt.h\"\n#include \"intel_memory_region.h\"\n#include \"intel_pci_config.h\"\n#include \"intel_pcode.h\"\n#include \"intel_region_ttm.h\"\n#include \"vlv_suspend.h\"\n\nstatic const struct drm_driver i915_drm_driver;\n\nstatic int i915_workqueues_init(struct drm_i915_private *dev_priv)\n{\n\t \n\tdev_priv->wq = alloc_ordered_workqueue(\"i915\", 0);\n\tif (dev_priv->wq == NULL)\n\t\tgoto out_err;\n\n\tdev_priv->display.hotplug.dp_wq = alloc_ordered_workqueue(\"i915-dp\", 0);\n\tif (dev_priv->display.hotplug.dp_wq == NULL)\n\t\tgoto out_free_wq;\n\n\t \n\tdev_priv->unordered_wq = alloc_workqueue(\"i915-unordered\", 0, 0);\n\tif (dev_priv->unordered_wq == NULL)\n\t\tgoto out_free_dp_wq;\n\n\treturn 0;\n\nout_free_dp_wq:\n\tdestroy_workqueue(dev_priv->display.hotplug.dp_wq);\nout_free_wq:\n\tdestroy_workqueue(dev_priv->wq);\nout_err:\n\tdrm_err(&dev_priv->drm, \"Failed to allocate workqueues.\\n\");\n\n\treturn -ENOMEM;\n}\n\nstatic void i915_workqueues_cleanup(struct drm_i915_private *dev_priv)\n{\n\tdestroy_workqueue(dev_priv->unordered_wq);\n\tdestroy_workqueue(dev_priv->display.hotplug.dp_wq);\n\tdestroy_workqueue(dev_priv->wq);\n}\n\n \nstatic void intel_detect_preproduction_hw(struct drm_i915_private *dev_priv)\n{\n\tbool pre = false;\n\n\tpre |= IS_HASWELL_EARLY_SDV(dev_priv);\n\tpre |= IS_SKYLAKE(dev_priv) && INTEL_REVID(dev_priv) < 0x6;\n\tpre |= IS_BROXTON(dev_priv) && INTEL_REVID(dev_priv) < 0xA;\n\tpre |= IS_KABYLAKE(dev_priv) && INTEL_REVID(dev_priv) < 0x1;\n\tpre |= IS_GEMINILAKE(dev_priv) && INTEL_REVID(dev_priv) < 0x3;\n\tpre |= IS_ICELAKE(dev_priv) && INTEL_REVID(dev_priv) < 0x7;\n\tpre |= IS_TIGERLAKE(dev_priv) && INTEL_REVID(dev_priv) < 0x1;\n\tpre |= IS_DG1(dev_priv) && INTEL_REVID(dev_priv) < 0x1;\n\n\tif (pre) {\n\t\tdrm_err(&dev_priv->drm, \"This is a pre-production stepping. \"\n\t\t\t  \"It may not be fully functional.\\n\");\n\t\tadd_taint(TAINT_MACHINE_CHECK, LOCKDEP_STILL_OK);\n\t}\n}\n\nstatic void sanitize_gpu(struct drm_i915_private *i915)\n{\n\tif (!INTEL_INFO(i915)->gpu_reset_clobbers_display) {\n\t\tstruct intel_gt *gt;\n\t\tunsigned int i;\n\n\t\tfor_each_gt(gt, i915, i)\n\t\t\t__intel_gt_reset(gt, ALL_ENGINES);\n\t}\n}\n\n \nstatic int i915_driver_early_probe(struct drm_i915_private *dev_priv)\n{\n\tint ret = 0;\n\n\tif (i915_inject_probe_failure(dev_priv))\n\t\treturn -ENODEV;\n\n\tintel_device_info_runtime_init_early(dev_priv);\n\n\tintel_step_init(dev_priv);\n\n\tintel_uncore_mmio_debug_init_early(dev_priv);\n\n\tspin_lock_init(&dev_priv->irq_lock);\n\tspin_lock_init(&dev_priv->gpu_error.lock);\n\tmutex_init(&dev_priv->display.backlight.lock);\n\n\tmutex_init(&dev_priv->sb_lock);\n\tcpu_latency_qos_add_request(&dev_priv->sb_qos, PM_QOS_DEFAULT_VALUE);\n\n\tmutex_init(&dev_priv->display.audio.mutex);\n\tmutex_init(&dev_priv->display.wm.wm_mutex);\n\tmutex_init(&dev_priv->display.pps.mutex);\n\tmutex_init(&dev_priv->display.hdcp.hdcp_mutex);\n\n\ti915_memcpy_init_early(dev_priv);\n\tintel_runtime_pm_init_early(&dev_priv->runtime_pm);\n\n\tret = i915_workqueues_init(dev_priv);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = vlv_suspend_init(dev_priv);\n\tif (ret < 0)\n\t\tgoto err_workqueues;\n\n\tret = intel_region_ttm_device_init(dev_priv);\n\tif (ret)\n\t\tgoto err_ttm;\n\n\tret = intel_root_gt_init_early(dev_priv);\n\tif (ret < 0)\n\t\tgoto err_rootgt;\n\n\ti915_gem_init_early(dev_priv);\n\n\t \n\tintel_detect_pch(dev_priv);\n\n\tintel_irq_init(dev_priv);\n\tintel_display_driver_early_probe(dev_priv);\n\tintel_clock_gating_hooks_init(dev_priv);\n\n\tintel_detect_preproduction_hw(dev_priv);\n\n\treturn 0;\n\nerr_rootgt:\n\tintel_region_ttm_device_fini(dev_priv);\nerr_ttm:\n\tvlv_suspend_cleanup(dev_priv);\nerr_workqueues:\n\ti915_workqueues_cleanup(dev_priv);\n\treturn ret;\n}\n\n \nstatic void i915_driver_late_release(struct drm_i915_private *dev_priv)\n{\n\tintel_irq_fini(dev_priv);\n\tintel_power_domains_cleanup(dev_priv);\n\ti915_gem_cleanup_early(dev_priv);\n\tintel_gt_driver_late_release_all(dev_priv);\n\tintel_region_ttm_device_fini(dev_priv);\n\tvlv_suspend_cleanup(dev_priv);\n\ti915_workqueues_cleanup(dev_priv);\n\n\tcpu_latency_qos_remove_request(&dev_priv->sb_qos);\n\tmutex_destroy(&dev_priv->sb_lock);\n\n\ti915_params_free(&dev_priv->params);\n}\n\n \nstatic int i915_driver_mmio_probe(struct drm_i915_private *dev_priv)\n{\n\tstruct intel_gt *gt;\n\tint ret, i;\n\n\tif (i915_inject_probe_failure(dev_priv))\n\t\treturn -ENODEV;\n\n\tret = intel_gmch_bridge_setup(dev_priv);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tfor_each_gt(gt, dev_priv, i) {\n\t\tret = intel_uncore_init_mmio(gt->uncore);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tret = drmm_add_action_or_reset(&dev_priv->drm,\n\t\t\t\t\t       intel_uncore_fini_mmio,\n\t\t\t\t\t       gt->uncore);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\t \n\tintel_gmch_bar_setup(dev_priv);\n\tintel_device_info_runtime_init(dev_priv);\n\n\tfor_each_gt(gt, dev_priv, i) {\n\t\tret = intel_gt_init_mmio(gt);\n\t\tif (ret)\n\t\t\tgoto err_uncore;\n\t}\n\n\t \n\tsanitize_gpu(dev_priv);\n\n\treturn 0;\n\nerr_uncore:\n\tintel_gmch_bar_teardown(dev_priv);\n\n\treturn ret;\n}\n\n \nstatic void i915_driver_mmio_release(struct drm_i915_private *dev_priv)\n{\n\tintel_gmch_bar_teardown(dev_priv);\n}\n\n \nstatic int i915_set_dma_info(struct drm_i915_private *i915)\n{\n\tunsigned int mask_size = INTEL_INFO(i915)->dma_mask_size;\n\tint ret;\n\n\tGEM_BUG_ON(!mask_size);\n\n\t \n\tdma_set_max_seg_size(i915->drm.dev, UINT_MAX);\n\n\tret = dma_set_mask(i915->drm.dev, DMA_BIT_MASK(mask_size));\n\tif (ret)\n\t\tgoto mask_err;\n\n\t \n\tif (GRAPHICS_VER(i915) == 2)\n\t\tmask_size = 30;\n\n\t \n\tif (IS_I965G(i915) || IS_I965GM(i915))\n\t\tmask_size = 32;\n\n\tret = dma_set_coherent_mask(i915->drm.dev, DMA_BIT_MASK(mask_size));\n\tif (ret)\n\t\tgoto mask_err;\n\n\treturn 0;\n\nmask_err:\n\tdrm_err(&i915->drm, \"Can't set DMA mask/consistent mask (%d)\\n\", ret);\n\treturn ret;\n}\n\nstatic int i915_pcode_init(struct drm_i915_private *i915)\n{\n\tstruct intel_gt *gt;\n\tint id, ret;\n\n\tfor_each_gt(gt, i915, id) {\n\t\tret = intel_pcode_init(gt->uncore);\n\t\tif (ret) {\n\t\t\tdrm_err(&gt->i915->drm, \"gt%d: intel_pcode_init failed %d\\n\", id, ret);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n \nstatic int i915_driver_hw_probe(struct drm_i915_private *dev_priv)\n{\n\tstruct pci_dev *pdev = to_pci_dev(dev_priv->drm.dev);\n\tint ret;\n\n\tif (i915_inject_probe_failure(dev_priv))\n\t\treturn -ENODEV;\n\n\tif (HAS_PPGTT(dev_priv)) {\n\t\tif (intel_vgpu_active(dev_priv) &&\n\t\t    !intel_vgpu_has_full_ppgtt(dev_priv)) {\n\t\t\ti915_report_error(dev_priv,\n\t\t\t\t\t  \"incompatible vGPU found, support for isolated ppGTT required\\n\");\n\t\t\treturn -ENXIO;\n\t\t}\n\t}\n\n\tif (HAS_EXECLISTS(dev_priv)) {\n\t\t \n\t\tif (intel_vgpu_active(dev_priv) &&\n\t\t    !intel_vgpu_has_hwsp_emulation(dev_priv)) {\n\t\t\ti915_report_error(dev_priv,\n\t\t\t\t\t  \"old vGPU host found, support for HWSP emulation required\\n\");\n\t\t\treturn -ENXIO;\n\t\t}\n\t}\n\n\t \n\tintel_dram_edram_detect(dev_priv);\n\n\tret = i915_set_dma_info(dev_priv);\n\tif (ret)\n\t\treturn ret;\n\n\tret = i915_perf_init(dev_priv);\n\tif (ret)\n\t\treturn ret;\n\n\tret = i915_ggtt_probe_hw(dev_priv);\n\tif (ret)\n\t\tgoto err_perf;\n\n\tret = drm_aperture_remove_conflicting_pci_framebuffers(pdev, dev_priv->drm.driver);\n\tif (ret)\n\t\tgoto err_ggtt;\n\n\tret = i915_ggtt_init_hw(dev_priv);\n\tif (ret)\n\t\tgoto err_ggtt;\n\n\t \n\tret = intel_gt_tiles_init(dev_priv);\n\tif (ret)\n\t\tgoto err_ggtt;\n\n\tret = intel_memory_regions_hw_probe(dev_priv);\n\tif (ret)\n\t\tgoto err_ggtt;\n\n\tret = i915_ggtt_enable_hw(dev_priv);\n\tif (ret) {\n\t\tdrm_err(&dev_priv->drm, \"failed to enable GGTT\\n\");\n\t\tgoto err_mem_regions;\n\t}\n\n\tpci_set_master(pdev);\n\n\t \n\tif (GRAPHICS_VER(dev_priv) >= 5) {\n\t\tif (pci_enable_msi(pdev) < 0)\n\t\t\tdrm_dbg(&dev_priv->drm, \"can't enable MSI\");\n\t}\n\n\tret = intel_gvt_init(dev_priv);\n\tif (ret)\n\t\tgoto err_msi;\n\n\tintel_opregion_setup(dev_priv);\n\n\tret = i915_pcode_init(dev_priv);\n\tif (ret)\n\t\tgoto err_opregion;\n\n\t \n\tintel_dram_detect(dev_priv);\n\n\tintel_bw_init_hw(dev_priv);\n\n\treturn 0;\n\nerr_opregion:\n\tintel_opregion_cleanup(dev_priv);\nerr_msi:\n\tif (pdev->msi_enabled)\n\t\tpci_disable_msi(pdev);\nerr_mem_regions:\n\tintel_memory_regions_driver_release(dev_priv);\nerr_ggtt:\n\ti915_ggtt_driver_release(dev_priv);\n\ti915_gem_drain_freed_objects(dev_priv);\n\ti915_ggtt_driver_late_release(dev_priv);\nerr_perf:\n\ti915_perf_fini(dev_priv);\n\treturn ret;\n}\n\n \nstatic void i915_driver_hw_remove(struct drm_i915_private *dev_priv)\n{\n\tstruct pci_dev *pdev = to_pci_dev(dev_priv->drm.dev);\n\n\ti915_perf_fini(dev_priv);\n\n\tintel_opregion_cleanup(dev_priv);\n\n\tif (pdev->msi_enabled)\n\t\tpci_disable_msi(pdev);\n}\n\n \nstatic void i915_driver_register(struct drm_i915_private *dev_priv)\n{\n\tstruct intel_gt *gt;\n\tunsigned int i;\n\n\ti915_gem_driver_register(dev_priv);\n\ti915_pmu_register(dev_priv);\n\n\tintel_vgpu_register(dev_priv);\n\n\t \n\tif (drm_dev_register(&dev_priv->drm, 0)) {\n\t\tdrm_err(&dev_priv->drm,\n\t\t\t\"Failed to register driver for userspace access!\\n\");\n\t\treturn;\n\t}\n\n\ti915_debugfs_register(dev_priv);\n\ti915_setup_sysfs(dev_priv);\n\n\t \n\ti915_perf_register(dev_priv);\n\n\tfor_each_gt(gt, dev_priv, i)\n\t\tintel_gt_driver_register(gt);\n\n\tintel_pxp_debugfs_register(dev_priv->pxp);\n\n\ti915_hwmon_register(dev_priv);\n\n\tintel_display_driver_register(dev_priv);\n\n\tintel_power_domains_enable(dev_priv);\n\tintel_runtime_pm_enable(&dev_priv->runtime_pm);\n\n\tintel_register_dsm_handler();\n\n\tif (i915_switcheroo_register(dev_priv))\n\t\tdrm_err(&dev_priv->drm, \"Failed to register vga switcheroo!\\n\");\n}\n\n \nstatic void i915_driver_unregister(struct drm_i915_private *dev_priv)\n{\n\tstruct intel_gt *gt;\n\tunsigned int i;\n\n\ti915_switcheroo_unregister(dev_priv);\n\n\tintel_unregister_dsm_handler();\n\n\tintel_runtime_pm_disable(&dev_priv->runtime_pm);\n\tintel_power_domains_disable(dev_priv);\n\n\tintel_display_driver_unregister(dev_priv);\n\n\tintel_pxp_fini(dev_priv);\n\n\tfor_each_gt(gt, dev_priv, i)\n\t\tintel_gt_driver_unregister(gt);\n\n\ti915_hwmon_unregister(dev_priv);\n\n\ti915_perf_unregister(dev_priv);\n\ti915_pmu_unregister(dev_priv);\n\n\ti915_teardown_sysfs(dev_priv);\n\tdrm_dev_unplug(&dev_priv->drm);\n\n\ti915_gem_driver_unregister(dev_priv);\n}\n\nvoid\ni915_print_iommu_status(struct drm_i915_private *i915, struct drm_printer *p)\n{\n\tdrm_printf(p, \"iommu: %s\\n\",\n\t\t   str_enabled_disabled(i915_vtd_active(i915)));\n}\n\nstatic void i915_welcome_messages(struct drm_i915_private *dev_priv)\n{\n\tif (drm_debug_enabled(DRM_UT_DRIVER)) {\n\t\tstruct drm_printer p = drm_debug_printer(\"i915 device info:\");\n\t\tstruct intel_gt *gt;\n\t\tunsigned int i;\n\n\t\tdrm_printf(&p, \"pciid=0x%04x rev=0x%02x platform=%s (subplatform=0x%x) gen=%i\\n\",\n\t\t\t   INTEL_DEVID(dev_priv),\n\t\t\t   INTEL_REVID(dev_priv),\n\t\t\t   intel_platform_name(INTEL_INFO(dev_priv)->platform),\n\t\t\t   intel_subplatform(RUNTIME_INFO(dev_priv),\n\t\t\t\t\t     INTEL_INFO(dev_priv)->platform),\n\t\t\t   GRAPHICS_VER(dev_priv));\n\n\t\tintel_device_info_print(INTEL_INFO(dev_priv),\n\t\t\t\t\tRUNTIME_INFO(dev_priv), &p);\n\t\tintel_display_device_info_print(DISPLAY_INFO(dev_priv),\n\t\t\t\t\t\tDISPLAY_RUNTIME_INFO(dev_priv), &p);\n\t\ti915_print_iommu_status(dev_priv, &p);\n\t\tfor_each_gt(gt, dev_priv, i)\n\t\t\tintel_gt_info_print(&gt->info, &p);\n\t}\n\n\tif (IS_ENABLED(CONFIG_DRM_I915_DEBUG))\n\t\tdrm_info(&dev_priv->drm, \"DRM_I915_DEBUG enabled\\n\");\n\tif (IS_ENABLED(CONFIG_DRM_I915_DEBUG_GEM))\n\t\tdrm_info(&dev_priv->drm, \"DRM_I915_DEBUG_GEM enabled\\n\");\n\tif (IS_ENABLED(CONFIG_DRM_I915_DEBUG_RUNTIME_PM))\n\t\tdrm_info(&dev_priv->drm,\n\t\t\t \"DRM_I915_DEBUG_RUNTIME_PM enabled\\n\");\n}\n\nstatic struct drm_i915_private *\ni915_driver_create(struct pci_dev *pdev, const struct pci_device_id *ent)\n{\n\tconst struct intel_device_info *match_info =\n\t\t(struct intel_device_info *)ent->driver_data;\n\tstruct drm_i915_private *i915;\n\n\ti915 = devm_drm_dev_alloc(&pdev->dev, &i915_drm_driver,\n\t\t\t\t  struct drm_i915_private, drm);\n\tif (IS_ERR(i915))\n\t\treturn i915;\n\n\tpci_set_drvdata(pdev, i915);\n\n\t \n\ti915_params_copy(&i915->params, &i915_modparams);\n\n\t \n\tintel_device_info_driver_create(i915, pdev->device, match_info);\n\n\treturn i915;\n}\n\n \nint i915_driver_probe(struct pci_dev *pdev, const struct pci_device_id *ent)\n{\n\tstruct drm_i915_private *i915;\n\tint ret;\n\n\tret = pci_enable_device(pdev);\n\tif (ret) {\n\t\tpr_err(\"Failed to enable graphics device: %pe\\n\", ERR_PTR(ret));\n\t\treturn ret;\n\t}\n\n\ti915 = i915_driver_create(pdev, ent);\n\tif (IS_ERR(i915)) {\n\t\tpci_disable_device(pdev);\n\t\treturn PTR_ERR(i915);\n\t}\n\n\tret = i915_driver_early_probe(i915);\n\tif (ret < 0)\n\t\tgoto out_pci_disable;\n\n\tdisable_rpm_wakeref_asserts(&i915->runtime_pm);\n\n\tintel_vgpu_detect(i915);\n\n\tret = intel_gt_probe_all(i915);\n\tif (ret < 0)\n\t\tgoto out_runtime_pm_put;\n\n\tret = i915_driver_mmio_probe(i915);\n\tif (ret < 0)\n\t\tgoto out_runtime_pm_put;\n\n\tret = i915_driver_hw_probe(i915);\n\tif (ret < 0)\n\t\tgoto out_cleanup_mmio;\n\n\tret = intel_display_driver_probe_noirq(i915);\n\tif (ret < 0)\n\t\tgoto out_cleanup_hw;\n\n\tret = intel_irq_install(i915);\n\tif (ret)\n\t\tgoto out_cleanup_modeset;\n\n\tret = intel_display_driver_probe_nogem(i915);\n\tif (ret)\n\t\tgoto out_cleanup_irq;\n\n\tret = i915_gem_init(i915);\n\tif (ret)\n\t\tgoto out_cleanup_modeset2;\n\n\tintel_pxp_init(i915);\n\n\tret = intel_display_driver_probe(i915);\n\tif (ret)\n\t\tgoto out_cleanup_gem;\n\n\ti915_driver_register(i915);\n\n\tenable_rpm_wakeref_asserts(&i915->runtime_pm);\n\n\ti915_welcome_messages(i915);\n\n\ti915->do_release = true;\n\n\treturn 0;\n\nout_cleanup_gem:\n\ti915_gem_suspend(i915);\n\ti915_gem_driver_remove(i915);\n\ti915_gem_driver_release(i915);\nout_cleanup_modeset2:\n\t \n\tintel_display_driver_remove(i915);\n\tintel_irq_uninstall(i915);\n\tintel_display_driver_remove_noirq(i915);\n\tgoto out_cleanup_modeset;\nout_cleanup_irq:\n\tintel_irq_uninstall(i915);\nout_cleanup_modeset:\n\tintel_display_driver_remove_nogem(i915);\nout_cleanup_hw:\n\ti915_driver_hw_remove(i915);\n\tintel_memory_regions_driver_release(i915);\n\ti915_ggtt_driver_release(i915);\n\ti915_gem_drain_freed_objects(i915);\n\ti915_ggtt_driver_late_release(i915);\nout_cleanup_mmio:\n\ti915_driver_mmio_release(i915);\nout_runtime_pm_put:\n\tenable_rpm_wakeref_asserts(&i915->runtime_pm);\n\ti915_driver_late_release(i915);\nout_pci_disable:\n\tpci_disable_device(pdev);\n\ti915_probe_error(i915, \"Device initialization failed (%d)\\n\", ret);\n\treturn ret;\n}\n\nvoid i915_driver_remove(struct drm_i915_private *i915)\n{\n\tintel_wakeref_t wakeref;\n\n\twakeref = intel_runtime_pm_get(&i915->runtime_pm);\n\n\ti915_driver_unregister(i915);\n\n\t \n\tsynchronize_rcu();\n\n\ti915_gem_suspend(i915);\n\n\tintel_gvt_driver_remove(i915);\n\n\tintel_display_driver_remove(i915);\n\n\tintel_irq_uninstall(i915);\n\n\tintel_display_driver_remove_noirq(i915);\n\n\ti915_reset_error_state(i915);\n\ti915_gem_driver_remove(i915);\n\n\tintel_display_driver_remove_nogem(i915);\n\n\ti915_driver_hw_remove(i915);\n\n\tintel_runtime_pm_put(&i915->runtime_pm, wakeref);\n}\n\nstatic void i915_driver_release(struct drm_device *dev)\n{\n\tstruct drm_i915_private *dev_priv = to_i915(dev);\n\tstruct intel_runtime_pm *rpm = &dev_priv->runtime_pm;\n\tintel_wakeref_t wakeref;\n\n\tif (!dev_priv->do_release)\n\t\treturn;\n\n\twakeref = intel_runtime_pm_get(rpm);\n\n\ti915_gem_driver_release(dev_priv);\n\n\tintel_memory_regions_driver_release(dev_priv);\n\ti915_ggtt_driver_release(dev_priv);\n\ti915_gem_drain_freed_objects(dev_priv);\n\ti915_ggtt_driver_late_release(dev_priv);\n\n\ti915_driver_mmio_release(dev_priv);\n\n\tintel_runtime_pm_put(rpm, wakeref);\n\n\tintel_runtime_pm_driver_release(rpm);\n\n\ti915_driver_late_release(dev_priv);\n}\n\nstatic int i915_driver_open(struct drm_device *dev, struct drm_file *file)\n{\n\tstruct drm_i915_private *i915 = to_i915(dev);\n\tint ret;\n\n\tret = i915_gem_open(i915, file);\n\tif (ret)\n\t\treturn ret;\n\n\treturn 0;\n}\n\n \nstatic void i915_driver_lastclose(struct drm_device *dev)\n{\n\tstruct drm_i915_private *i915 = to_i915(dev);\n\n\tintel_fbdev_restore_mode(i915);\n\n\tvga_switcheroo_process_delayed_switch();\n}\n\nstatic void i915_driver_postclose(struct drm_device *dev, struct drm_file *file)\n{\n\tstruct drm_i915_file_private *file_priv = file->driver_priv;\n\n\ti915_gem_context_close(file);\n\ti915_drm_client_put(file_priv->client);\n\n\tkfree_rcu(file_priv, rcu);\n\n\t \n\ti915_gem_flush_free_objects(to_i915(dev));\n}\n\nstatic void intel_suspend_encoders(struct drm_i915_private *dev_priv)\n{\n\tstruct intel_encoder *encoder;\n\n\tif (!HAS_DISPLAY(dev_priv))\n\t\treturn;\n\n\t \n\tdrm_modeset_lock_all(&dev_priv->drm);\n\tfor_each_intel_encoder(&dev_priv->drm, encoder)\n\t\tif (encoder->suspend)\n\t\t\tencoder->suspend(encoder);\n\tdrm_modeset_unlock_all(&dev_priv->drm);\n\n\tfor_each_intel_encoder(&dev_priv->drm, encoder)\n\t\tif (encoder->suspend_complete)\n\t\t\tencoder->suspend_complete(encoder);\n}\n\nstatic void intel_shutdown_encoders(struct drm_i915_private *dev_priv)\n{\n\tstruct intel_encoder *encoder;\n\n\tif (!HAS_DISPLAY(dev_priv))\n\t\treturn;\n\n\t \n\tdrm_modeset_lock_all(&dev_priv->drm);\n\tfor_each_intel_encoder(&dev_priv->drm, encoder)\n\t\tif (encoder->shutdown)\n\t\t\tencoder->shutdown(encoder);\n\tdrm_modeset_unlock_all(&dev_priv->drm);\n\n\tfor_each_intel_encoder(&dev_priv->drm, encoder)\n\t\tif (encoder->shutdown_complete)\n\t\t\tencoder->shutdown_complete(encoder);\n}\n\nvoid i915_driver_shutdown(struct drm_i915_private *i915)\n{\n\tdisable_rpm_wakeref_asserts(&i915->runtime_pm);\n\tintel_runtime_pm_disable(&i915->runtime_pm);\n\tintel_power_domains_disable(i915);\n\n\tif (HAS_DISPLAY(i915)) {\n\t\tdrm_kms_helper_poll_disable(&i915->drm);\n\n\t\tdrm_atomic_helper_shutdown(&i915->drm);\n\t}\n\n\tintel_dp_mst_suspend(i915);\n\n\tintel_runtime_pm_disable_interrupts(i915);\n\tintel_hpd_cancel_work(i915);\n\n\tintel_suspend_encoders(i915);\n\tintel_shutdown_encoders(i915);\n\n\tintel_dmc_suspend(i915);\n\n\ti915_gem_suspend(i915);\n\n\t \n\tintel_power_domains_driver_remove(i915);\n\tenable_rpm_wakeref_asserts(&i915->runtime_pm);\n\n\tintel_runtime_pm_driver_release(&i915->runtime_pm);\n}\n\nstatic bool suspend_to_idle(struct drm_i915_private *dev_priv)\n{\n#if IS_ENABLED(CONFIG_ACPI_SLEEP)\n\tif (acpi_target_system_state() < ACPI_STATE_S3)\n\t\treturn true;\n#endif\n\treturn false;\n}\n\nstatic void i915_drm_complete(struct drm_device *dev)\n{\n\tstruct drm_i915_private *i915 = to_i915(dev);\n\n\tintel_pxp_resume_complete(i915->pxp);\n}\n\nstatic int i915_drm_prepare(struct drm_device *dev)\n{\n\tstruct drm_i915_private *i915 = to_i915(dev);\n\n\tintel_pxp_suspend_prepare(i915->pxp);\n\n\t \n\treturn i915_gem_backup_suspend(i915);\n}\n\nstatic int i915_drm_suspend(struct drm_device *dev)\n{\n\tstruct drm_i915_private *dev_priv = to_i915(dev);\n\tstruct pci_dev *pdev = to_pci_dev(dev_priv->drm.dev);\n\tpci_power_t opregion_target_state;\n\n\tdisable_rpm_wakeref_asserts(&dev_priv->runtime_pm);\n\n\t \n\tintel_power_domains_disable(dev_priv);\n\tif (HAS_DISPLAY(dev_priv))\n\t\tdrm_kms_helper_poll_disable(dev);\n\n\tpci_save_state(pdev);\n\n\tintel_display_driver_suspend(dev_priv);\n\n\tintel_dp_mst_suspend(dev_priv);\n\n\tintel_runtime_pm_disable_interrupts(dev_priv);\n\tintel_hpd_cancel_work(dev_priv);\n\n\tintel_suspend_encoders(dev_priv);\n\n\t \n\tintel_dpt_suspend(dev_priv);\n\ti915_ggtt_suspend(to_gt(dev_priv)->ggtt);\n\n\ti915_save_display(dev_priv);\n\n\topregion_target_state = suspend_to_idle(dev_priv) ? PCI_D1 : PCI_D3cold;\n\tintel_opregion_suspend(dev_priv, opregion_target_state);\n\n\tintel_fbdev_set_suspend(dev, FBINFO_STATE_SUSPENDED, true);\n\n\tdev_priv->suspend_count++;\n\n\tintel_dmc_suspend(dev_priv);\n\n\tenable_rpm_wakeref_asserts(&dev_priv->runtime_pm);\n\n\ti915_gem_drain_freed_objects(dev_priv);\n\n\treturn 0;\n}\n\nstatic int i915_drm_suspend_late(struct drm_device *dev, bool hibernation)\n{\n\tstruct drm_i915_private *dev_priv = to_i915(dev);\n\tstruct pci_dev *pdev = to_pci_dev(dev_priv->drm.dev);\n\tstruct intel_runtime_pm *rpm = &dev_priv->runtime_pm;\n\tstruct intel_gt *gt;\n\tint ret, i;\n\tbool s2idle = !hibernation && suspend_to_idle(dev_priv);\n\n\tdisable_rpm_wakeref_asserts(rpm);\n\n\tintel_pxp_suspend(dev_priv->pxp);\n\n\ti915_gem_suspend_late(dev_priv);\n\n\tfor_each_gt(gt, dev_priv, i)\n\t\tintel_uncore_suspend(gt->uncore);\n\n\tintel_power_domains_suspend(dev_priv, s2idle);\n\n\tintel_display_power_suspend_late(dev_priv);\n\n\tret = vlv_suspend_complete(dev_priv);\n\tif (ret) {\n\t\tdrm_err(&dev_priv->drm, \"Suspend complete failed: %d\\n\", ret);\n\t\tintel_power_domains_resume(dev_priv);\n\n\t\tgoto out;\n\t}\n\n\tpci_disable_device(pdev);\n\t \n\tif (!(hibernation && GRAPHICS_VER(dev_priv) < 6))\n\t\tpci_set_power_state(pdev, PCI_D3hot);\n\nout:\n\tenable_rpm_wakeref_asserts(rpm);\n\tif (!dev_priv->uncore.user_forcewake_count)\n\t\tintel_runtime_pm_driver_release(rpm);\n\n\treturn ret;\n}\n\nint i915_driver_suspend_switcheroo(struct drm_i915_private *i915,\n\t\t\t\t   pm_message_t state)\n{\n\tint error;\n\n\tif (drm_WARN_ON_ONCE(&i915->drm, state.event != PM_EVENT_SUSPEND &&\n\t\t\t     state.event != PM_EVENT_FREEZE))\n\t\treturn -EINVAL;\n\n\tif (i915->drm.switch_power_state == DRM_SWITCH_POWER_OFF)\n\t\treturn 0;\n\n\terror = i915_drm_suspend(&i915->drm);\n\tif (error)\n\t\treturn error;\n\n\treturn i915_drm_suspend_late(&i915->drm, false);\n}\n\nstatic int i915_drm_resume(struct drm_device *dev)\n{\n\tstruct drm_i915_private *dev_priv = to_i915(dev);\n\tstruct intel_gt *gt;\n\tint ret, i;\n\n\tdisable_rpm_wakeref_asserts(&dev_priv->runtime_pm);\n\n\tret = i915_pcode_init(dev_priv);\n\tif (ret)\n\t\treturn ret;\n\n\tsanitize_gpu(dev_priv);\n\n\tret = i915_ggtt_enable_hw(dev_priv);\n\tif (ret)\n\t\tdrm_err(&dev_priv->drm, \"failed to re-enable GGTT\\n\");\n\n\ti915_ggtt_resume(to_gt(dev_priv)->ggtt);\n\n\tfor_each_gt(gt, dev_priv, i)\n\t\tif (GRAPHICS_VER(gt->i915) >= 8)\n\t\t\tsetup_private_pat(gt);\n\n\t \n\tintel_dpt_resume(dev_priv);\n\n\tintel_dmc_resume(dev_priv);\n\n\ti915_restore_display(dev_priv);\n\tintel_pps_unlock_regs_wa(dev_priv);\n\n\tintel_init_pch_refclk(dev_priv);\n\n\t \n\tintel_runtime_pm_enable_interrupts(dev_priv);\n\n\tif (HAS_DISPLAY(dev_priv))\n\t\tdrm_mode_config_reset(dev);\n\n\ti915_gem_resume(dev_priv);\n\n\tintel_display_driver_init_hw(dev_priv);\n\n\tintel_clock_gating_init(dev_priv);\n\tintel_hpd_init(dev_priv);\n\n\t \n\tintel_dp_mst_resume(dev_priv);\n\tintel_display_driver_resume(dev_priv);\n\n\tintel_hpd_poll_disable(dev_priv);\n\tif (HAS_DISPLAY(dev_priv))\n\t\tdrm_kms_helper_poll_enable(dev);\n\n\tintel_opregion_resume(dev_priv);\n\n\tintel_fbdev_set_suspend(dev, FBINFO_STATE_RUNNING, false);\n\n\tintel_power_domains_enable(dev_priv);\n\n\tintel_gvt_resume(dev_priv);\n\n\tenable_rpm_wakeref_asserts(&dev_priv->runtime_pm);\n\n\treturn 0;\n}\n\nstatic int i915_drm_resume_early(struct drm_device *dev)\n{\n\tstruct drm_i915_private *dev_priv = to_i915(dev);\n\tstruct pci_dev *pdev = to_pci_dev(dev_priv->drm.dev);\n\tstruct intel_gt *gt;\n\tint ret, i;\n\n\t \n\n\t \n\tret = pci_set_power_state(pdev, PCI_D0);\n\tif (ret) {\n\t\tdrm_err(&dev_priv->drm,\n\t\t\t\"failed to set PCI D0 power state (%d)\\n\", ret);\n\t\treturn ret;\n\t}\n\n\t \n\tif (pci_enable_device(pdev))\n\t\treturn -EIO;\n\n\tpci_set_master(pdev);\n\n\tdisable_rpm_wakeref_asserts(&dev_priv->runtime_pm);\n\n\tret = vlv_resume_prepare(dev_priv, false);\n\tif (ret)\n\t\tdrm_err(&dev_priv->drm,\n\t\t\t\"Resume prepare failed: %d, continuing anyway\\n\", ret);\n\n\tfor_each_gt(gt, dev_priv, i) {\n\t\tintel_uncore_resume_early(gt->uncore);\n\t\tintel_gt_check_and_clear_faults(gt);\n\t}\n\n\tintel_display_power_resume_early(dev_priv);\n\n\tintel_power_domains_resume(dev_priv);\n\n\tenable_rpm_wakeref_asserts(&dev_priv->runtime_pm);\n\n\treturn ret;\n}\n\nint i915_driver_resume_switcheroo(struct drm_i915_private *i915)\n{\n\tint ret;\n\n\tif (i915->drm.switch_power_state == DRM_SWITCH_POWER_OFF)\n\t\treturn 0;\n\n\tret = i915_drm_resume_early(&i915->drm);\n\tif (ret)\n\t\treturn ret;\n\n\treturn i915_drm_resume(&i915->drm);\n}\n\nstatic int i915_pm_prepare(struct device *kdev)\n{\n\tstruct drm_i915_private *i915 = kdev_to_i915(kdev);\n\n\tif (!i915) {\n\t\tdev_err(kdev, \"DRM not initialized, aborting suspend.\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tif (i915->drm.switch_power_state == DRM_SWITCH_POWER_OFF)\n\t\treturn 0;\n\n\treturn i915_drm_prepare(&i915->drm);\n}\n\nstatic int i915_pm_suspend(struct device *kdev)\n{\n\tstruct drm_i915_private *i915 = kdev_to_i915(kdev);\n\n\tif (!i915) {\n\t\tdev_err(kdev, \"DRM not initialized, aborting suspend.\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tif (i915->drm.switch_power_state == DRM_SWITCH_POWER_OFF)\n\t\treturn 0;\n\n\treturn i915_drm_suspend(&i915->drm);\n}\n\nstatic int i915_pm_suspend_late(struct device *kdev)\n{\n\tstruct drm_i915_private *i915 = kdev_to_i915(kdev);\n\n\t \n\tif (i915->drm.switch_power_state == DRM_SWITCH_POWER_OFF)\n\t\treturn 0;\n\n\treturn i915_drm_suspend_late(&i915->drm, false);\n}\n\nstatic int i915_pm_poweroff_late(struct device *kdev)\n{\n\tstruct drm_i915_private *i915 = kdev_to_i915(kdev);\n\n\tif (i915->drm.switch_power_state == DRM_SWITCH_POWER_OFF)\n\t\treturn 0;\n\n\treturn i915_drm_suspend_late(&i915->drm, true);\n}\n\nstatic int i915_pm_resume_early(struct device *kdev)\n{\n\tstruct drm_i915_private *i915 = kdev_to_i915(kdev);\n\n\tif (i915->drm.switch_power_state == DRM_SWITCH_POWER_OFF)\n\t\treturn 0;\n\n\treturn i915_drm_resume_early(&i915->drm);\n}\n\nstatic int i915_pm_resume(struct device *kdev)\n{\n\tstruct drm_i915_private *i915 = kdev_to_i915(kdev);\n\n\tif (i915->drm.switch_power_state == DRM_SWITCH_POWER_OFF)\n\t\treturn 0;\n\n\treturn i915_drm_resume(&i915->drm);\n}\n\nstatic void i915_pm_complete(struct device *kdev)\n{\n\tstruct drm_i915_private *i915 = kdev_to_i915(kdev);\n\n\tif (i915->drm.switch_power_state == DRM_SWITCH_POWER_OFF)\n\t\treturn;\n\n\ti915_drm_complete(&i915->drm);\n}\n\n \nstatic int i915_pm_freeze(struct device *kdev)\n{\n\tstruct drm_i915_private *i915 = kdev_to_i915(kdev);\n\tint ret;\n\n\tif (i915->drm.switch_power_state != DRM_SWITCH_POWER_OFF) {\n\t\tret = i915_drm_suspend(&i915->drm);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tret = i915_gem_freeze(i915);\n\tif (ret)\n\t\treturn ret;\n\n\treturn 0;\n}\n\nstatic int i915_pm_freeze_late(struct device *kdev)\n{\n\tstruct drm_i915_private *i915 = kdev_to_i915(kdev);\n\tint ret;\n\n\tif (i915->drm.switch_power_state != DRM_SWITCH_POWER_OFF) {\n\t\tret = i915_drm_suspend_late(&i915->drm, true);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tret = i915_gem_freeze_late(i915);\n\tif (ret)\n\t\treturn ret;\n\n\treturn 0;\n}\n\n \nstatic int i915_pm_thaw_early(struct device *kdev)\n{\n\treturn i915_pm_resume_early(kdev);\n}\n\nstatic int i915_pm_thaw(struct device *kdev)\n{\n\treturn i915_pm_resume(kdev);\n}\n\n \nstatic int i915_pm_restore_early(struct device *kdev)\n{\n\treturn i915_pm_resume_early(kdev);\n}\n\nstatic int i915_pm_restore(struct device *kdev)\n{\n\treturn i915_pm_resume(kdev);\n}\n\nstatic int intel_runtime_suspend(struct device *kdev)\n{\n\tstruct drm_i915_private *dev_priv = kdev_to_i915(kdev);\n\tstruct intel_runtime_pm *rpm = &dev_priv->runtime_pm;\n\tstruct pci_dev *pdev = to_pci_dev(dev_priv->drm.dev);\n\tstruct pci_dev *root_pdev;\n\tstruct intel_gt *gt;\n\tint ret, i;\n\n\tif (drm_WARN_ON_ONCE(&dev_priv->drm, !HAS_RUNTIME_PM(dev_priv)))\n\t\treturn -ENODEV;\n\n\tdrm_dbg(&dev_priv->drm, \"Suspending device\\n\");\n\n\tdisable_rpm_wakeref_asserts(rpm);\n\n\t \n\ti915_gem_runtime_suspend(dev_priv);\n\n\tintel_pxp_runtime_suspend(dev_priv->pxp);\n\n\tfor_each_gt(gt, dev_priv, i)\n\t\tintel_gt_runtime_suspend(gt);\n\n\tintel_runtime_pm_disable_interrupts(dev_priv);\n\n\tfor_each_gt(gt, dev_priv, i)\n\t\tintel_uncore_suspend(gt->uncore);\n\n\tintel_display_power_suspend(dev_priv);\n\n\tret = vlv_suspend_complete(dev_priv);\n\tif (ret) {\n\t\tdrm_err(&dev_priv->drm,\n\t\t\t\"Runtime suspend failed, disabling it (%d)\\n\", ret);\n\t\tintel_uncore_runtime_resume(&dev_priv->uncore);\n\n\t\tintel_runtime_pm_enable_interrupts(dev_priv);\n\n\t\tfor_each_gt(gt, dev_priv, i)\n\t\t\tintel_gt_runtime_resume(gt);\n\n\t\tenable_rpm_wakeref_asserts(rpm);\n\n\t\treturn ret;\n\t}\n\n\tenable_rpm_wakeref_asserts(rpm);\n\tintel_runtime_pm_driver_release(rpm);\n\n\tif (intel_uncore_arm_unclaimed_mmio_detection(&dev_priv->uncore))\n\t\tdrm_err(&dev_priv->drm,\n\t\t\t\"Unclaimed access detected prior to suspending\\n\");\n\n\t \n\troot_pdev = pcie_find_root_port(pdev);\n\tif (root_pdev)\n\t\tpci_d3cold_disable(root_pdev);\n\n\trpm->suspended = true;\n\n\t \n\tif (IS_BROADWELL(dev_priv)) {\n\t\t \n\t\tintel_opregion_notify_adapter(dev_priv, PCI_D3hot);\n\t} else {\n\t\t \n\t\tintel_opregion_notify_adapter(dev_priv, PCI_D1);\n\t}\n\n\tassert_forcewakes_inactive(&dev_priv->uncore);\n\n\tif (!IS_VALLEYVIEW(dev_priv) && !IS_CHERRYVIEW(dev_priv))\n\t\tintel_hpd_poll_enable(dev_priv);\n\n\tdrm_dbg(&dev_priv->drm, \"Device suspended\\n\");\n\treturn 0;\n}\n\nstatic int intel_runtime_resume(struct device *kdev)\n{\n\tstruct drm_i915_private *dev_priv = kdev_to_i915(kdev);\n\tstruct intel_runtime_pm *rpm = &dev_priv->runtime_pm;\n\tstruct pci_dev *pdev = to_pci_dev(dev_priv->drm.dev);\n\tstruct pci_dev *root_pdev;\n\tstruct intel_gt *gt;\n\tint ret, i;\n\n\tif (drm_WARN_ON_ONCE(&dev_priv->drm, !HAS_RUNTIME_PM(dev_priv)))\n\t\treturn -ENODEV;\n\n\tdrm_dbg(&dev_priv->drm, \"Resuming device\\n\");\n\n\tdrm_WARN_ON_ONCE(&dev_priv->drm, atomic_read(&rpm->wakeref_count));\n\tdisable_rpm_wakeref_asserts(rpm);\n\n\tintel_opregion_notify_adapter(dev_priv, PCI_D0);\n\trpm->suspended = false;\n\n\troot_pdev = pcie_find_root_port(pdev);\n\tif (root_pdev)\n\t\tpci_d3cold_enable(root_pdev);\n\n\tif (intel_uncore_unclaimed_mmio(&dev_priv->uncore))\n\t\tdrm_dbg(&dev_priv->drm,\n\t\t\t\"Unclaimed access during suspend, bios?\\n\");\n\n\tintel_display_power_resume(dev_priv);\n\n\tret = vlv_resume_prepare(dev_priv, true);\n\n\tfor_each_gt(gt, dev_priv, i)\n\t\tintel_uncore_runtime_resume(gt->uncore);\n\n\tintel_runtime_pm_enable_interrupts(dev_priv);\n\n\t \n\tfor_each_gt(gt, dev_priv, i)\n\t\tintel_gt_runtime_resume(gt);\n\n\tintel_pxp_runtime_resume(dev_priv->pxp);\n\n\t \n\tif (!IS_VALLEYVIEW(dev_priv) && !IS_CHERRYVIEW(dev_priv)) {\n\t\tintel_hpd_init(dev_priv);\n\t\tintel_hpd_poll_disable(dev_priv);\n\t}\n\n\tskl_watermark_ipc_update(dev_priv);\n\n\tenable_rpm_wakeref_asserts(rpm);\n\n\tif (ret)\n\t\tdrm_err(&dev_priv->drm,\n\t\t\t\"Runtime resume failed, disabling it (%d)\\n\", ret);\n\telse\n\t\tdrm_dbg(&dev_priv->drm, \"Device resumed\\n\");\n\n\treturn ret;\n}\n\nconst struct dev_pm_ops i915_pm_ops = {\n\t \n\t.prepare = i915_pm_prepare,\n\t.suspend = i915_pm_suspend,\n\t.suspend_late = i915_pm_suspend_late,\n\t.resume_early = i915_pm_resume_early,\n\t.resume = i915_pm_resume,\n\t.complete = i915_pm_complete,\n\n\t \n\t.freeze = i915_pm_freeze,\n\t.freeze_late = i915_pm_freeze_late,\n\t.thaw_early = i915_pm_thaw_early,\n\t.thaw = i915_pm_thaw,\n\t.poweroff = i915_pm_suspend,\n\t.poweroff_late = i915_pm_poweroff_late,\n\t.restore_early = i915_pm_restore_early,\n\t.restore = i915_pm_restore,\n\n\t \n\t.runtime_suspend = intel_runtime_suspend,\n\t.runtime_resume = intel_runtime_resume,\n};\n\nstatic const struct file_operations i915_driver_fops = {\n\t.owner = THIS_MODULE,\n\t.open = drm_open,\n\t.release = drm_release_noglobal,\n\t.unlocked_ioctl = drm_ioctl,\n\t.mmap = i915_gem_mmap,\n\t.poll = drm_poll,\n\t.read = drm_read,\n\t.compat_ioctl = i915_ioc32_compat_ioctl,\n\t.llseek = noop_llseek,\n#ifdef CONFIG_PROC_FS\n\t.show_fdinfo = drm_show_fdinfo,\n#endif\n};\n\nstatic int\ni915_gem_reject_pin_ioctl(struct drm_device *dev, void *data,\n\t\t\t  struct drm_file *file)\n{\n\treturn -ENODEV;\n}\n\nstatic const struct drm_ioctl_desc i915_ioctls[] = {\n\tDRM_IOCTL_DEF_DRV(I915_INIT, drm_noop, DRM_AUTH|DRM_MASTER|DRM_ROOT_ONLY),\n\tDRM_IOCTL_DEF_DRV(I915_FLUSH, drm_noop, DRM_AUTH),\n\tDRM_IOCTL_DEF_DRV(I915_FLIP, drm_noop, DRM_AUTH),\n\tDRM_IOCTL_DEF_DRV(I915_BATCHBUFFER, drm_noop, DRM_AUTH),\n\tDRM_IOCTL_DEF_DRV(I915_IRQ_EMIT, drm_noop, DRM_AUTH),\n\tDRM_IOCTL_DEF_DRV(I915_IRQ_WAIT, drm_noop, DRM_AUTH),\n\tDRM_IOCTL_DEF_DRV(I915_GETPARAM, i915_getparam_ioctl, DRM_RENDER_ALLOW),\n\tDRM_IOCTL_DEF_DRV(I915_SETPARAM, drm_noop, DRM_AUTH|DRM_MASTER|DRM_ROOT_ONLY),\n\tDRM_IOCTL_DEF_DRV(I915_ALLOC, drm_noop, DRM_AUTH),\n\tDRM_IOCTL_DEF_DRV(I915_FREE, drm_noop, DRM_AUTH),\n\tDRM_IOCTL_DEF_DRV(I915_INIT_HEAP, drm_noop, DRM_AUTH|DRM_MASTER|DRM_ROOT_ONLY),\n\tDRM_IOCTL_DEF_DRV(I915_CMDBUFFER, drm_noop, DRM_AUTH),\n\tDRM_IOCTL_DEF_DRV(I915_DESTROY_HEAP,  drm_noop, DRM_AUTH|DRM_MASTER|DRM_ROOT_ONLY),\n\tDRM_IOCTL_DEF_DRV(I915_SET_VBLANK_PIPE,  drm_noop, DRM_AUTH|DRM_MASTER|DRM_ROOT_ONLY),\n\tDRM_IOCTL_DEF_DRV(I915_GET_VBLANK_PIPE,  drm_noop, DRM_AUTH),\n\tDRM_IOCTL_DEF_DRV(I915_VBLANK_SWAP, drm_noop, DRM_AUTH),\n\tDRM_IOCTL_DEF_DRV(I915_HWS_ADDR, drm_noop, DRM_AUTH|DRM_MASTER|DRM_ROOT_ONLY),\n\tDRM_IOCTL_DEF_DRV(I915_GEM_INIT, drm_noop, DRM_AUTH|DRM_MASTER|DRM_ROOT_ONLY),\n\tDRM_IOCTL_DEF_DRV(I915_GEM_EXECBUFFER, drm_invalid_op, DRM_AUTH),\n\tDRM_IOCTL_DEF_DRV(I915_GEM_EXECBUFFER2_WR, i915_gem_execbuffer2_ioctl, DRM_RENDER_ALLOW),\n\tDRM_IOCTL_DEF_DRV(I915_GEM_PIN, i915_gem_reject_pin_ioctl, DRM_AUTH|DRM_ROOT_ONLY),\n\tDRM_IOCTL_DEF_DRV(I915_GEM_UNPIN, i915_gem_reject_pin_ioctl, DRM_AUTH|DRM_ROOT_ONLY),\n\tDRM_IOCTL_DEF_DRV(I915_GEM_BUSY, i915_gem_busy_ioctl, DRM_RENDER_ALLOW),\n\tDRM_IOCTL_DEF_DRV(I915_GEM_SET_CACHING, i915_gem_set_caching_ioctl, DRM_RENDER_ALLOW),\n\tDRM_IOCTL_DEF_DRV(I915_GEM_GET_CACHING, i915_gem_get_caching_ioctl, DRM_RENDER_ALLOW),\n\tDRM_IOCTL_DEF_DRV(I915_GEM_THROTTLE, i915_gem_throttle_ioctl, DRM_RENDER_ALLOW),\n\tDRM_IOCTL_DEF_DRV(I915_GEM_ENTERVT, drm_noop, DRM_AUTH|DRM_MASTER|DRM_ROOT_ONLY),\n\tDRM_IOCTL_DEF_DRV(I915_GEM_LEAVEVT, drm_noop, DRM_AUTH|DRM_MASTER|DRM_ROOT_ONLY),\n\tDRM_IOCTL_DEF_DRV(I915_GEM_CREATE, i915_gem_create_ioctl, DRM_RENDER_ALLOW),\n\tDRM_IOCTL_DEF_DRV(I915_GEM_CREATE_EXT, i915_gem_create_ext_ioctl, DRM_RENDER_ALLOW),\n\tDRM_IOCTL_DEF_DRV(I915_GEM_PREAD, i915_gem_pread_ioctl, DRM_RENDER_ALLOW),\n\tDRM_IOCTL_DEF_DRV(I915_GEM_PWRITE, i915_gem_pwrite_ioctl, DRM_RENDER_ALLOW),\n\tDRM_IOCTL_DEF_DRV(I915_GEM_MMAP, i915_gem_mmap_ioctl, DRM_RENDER_ALLOW),\n\tDRM_IOCTL_DEF_DRV(I915_GEM_MMAP_OFFSET, i915_gem_mmap_offset_ioctl, DRM_RENDER_ALLOW),\n\tDRM_IOCTL_DEF_DRV(I915_GEM_SET_DOMAIN, i915_gem_set_domain_ioctl, DRM_RENDER_ALLOW),\n\tDRM_IOCTL_DEF_DRV(I915_GEM_SW_FINISH, i915_gem_sw_finish_ioctl, DRM_RENDER_ALLOW),\n\tDRM_IOCTL_DEF_DRV(I915_GEM_SET_TILING, i915_gem_set_tiling_ioctl, DRM_RENDER_ALLOW),\n\tDRM_IOCTL_DEF_DRV(I915_GEM_GET_TILING, i915_gem_get_tiling_ioctl, DRM_RENDER_ALLOW),\n\tDRM_IOCTL_DEF_DRV(I915_GEM_GET_APERTURE, i915_gem_get_aperture_ioctl, DRM_RENDER_ALLOW),\n\tDRM_IOCTL_DEF_DRV(I915_GET_PIPE_FROM_CRTC_ID, intel_get_pipe_from_crtc_id_ioctl, 0),\n\tDRM_IOCTL_DEF_DRV(I915_GEM_MADVISE, i915_gem_madvise_ioctl, DRM_RENDER_ALLOW),\n\tDRM_IOCTL_DEF_DRV(I915_OVERLAY_PUT_IMAGE, intel_overlay_put_image_ioctl, DRM_MASTER),\n\tDRM_IOCTL_DEF_DRV(I915_OVERLAY_ATTRS, intel_overlay_attrs_ioctl, DRM_MASTER),\n\tDRM_IOCTL_DEF_DRV(I915_SET_SPRITE_COLORKEY, intel_sprite_set_colorkey_ioctl, DRM_MASTER),\n\tDRM_IOCTL_DEF_DRV(I915_GET_SPRITE_COLORKEY, drm_noop, DRM_MASTER),\n\tDRM_IOCTL_DEF_DRV(I915_GEM_WAIT, i915_gem_wait_ioctl, DRM_RENDER_ALLOW),\n\tDRM_IOCTL_DEF_DRV(I915_GEM_CONTEXT_CREATE_EXT, i915_gem_context_create_ioctl, DRM_RENDER_ALLOW),\n\tDRM_IOCTL_DEF_DRV(I915_GEM_CONTEXT_DESTROY, i915_gem_context_destroy_ioctl, DRM_RENDER_ALLOW),\n\tDRM_IOCTL_DEF_DRV(I915_REG_READ, i915_reg_read_ioctl, DRM_RENDER_ALLOW),\n\tDRM_IOCTL_DEF_DRV(I915_GET_RESET_STATS, i915_gem_context_reset_stats_ioctl, DRM_RENDER_ALLOW),\n\tDRM_IOCTL_DEF_DRV(I915_GEM_USERPTR, i915_gem_userptr_ioctl, DRM_RENDER_ALLOW),\n\tDRM_IOCTL_DEF_DRV(I915_GEM_CONTEXT_GETPARAM, i915_gem_context_getparam_ioctl, DRM_RENDER_ALLOW),\n\tDRM_IOCTL_DEF_DRV(I915_GEM_CONTEXT_SETPARAM, i915_gem_context_setparam_ioctl, DRM_RENDER_ALLOW),\n\tDRM_IOCTL_DEF_DRV(I915_PERF_OPEN, i915_perf_open_ioctl, DRM_RENDER_ALLOW),\n\tDRM_IOCTL_DEF_DRV(I915_PERF_ADD_CONFIG, i915_perf_add_config_ioctl, DRM_RENDER_ALLOW),\n\tDRM_IOCTL_DEF_DRV(I915_PERF_REMOVE_CONFIG, i915_perf_remove_config_ioctl, DRM_RENDER_ALLOW),\n\tDRM_IOCTL_DEF_DRV(I915_QUERY, i915_query_ioctl, DRM_RENDER_ALLOW),\n\tDRM_IOCTL_DEF_DRV(I915_GEM_VM_CREATE, i915_gem_vm_create_ioctl, DRM_RENDER_ALLOW),\n\tDRM_IOCTL_DEF_DRV(I915_GEM_VM_DESTROY, i915_gem_vm_destroy_ioctl, DRM_RENDER_ALLOW),\n};\n\n \n#define DRIVER_MAJOR\t\t1\n#define DRIVER_MINOR\t\t6\n#define DRIVER_PATCHLEVEL\t0\n\nstatic const struct drm_driver i915_drm_driver = {\n\t \n\t.driver_features =\n\t    DRIVER_GEM |\n\t    DRIVER_RENDER | DRIVER_MODESET | DRIVER_ATOMIC | DRIVER_SYNCOBJ |\n\t    DRIVER_SYNCOBJ_TIMELINE,\n\t.release = i915_driver_release,\n\t.open = i915_driver_open,\n\t.lastclose = i915_driver_lastclose,\n\t.postclose = i915_driver_postclose,\n\t.show_fdinfo = PTR_IF(IS_ENABLED(CONFIG_PROC_FS), i915_drm_client_fdinfo),\n\n\t.gem_prime_import = i915_gem_prime_import,\n\n\t.dumb_create = i915_gem_dumb_create,\n\t.dumb_map_offset = i915_gem_dumb_mmap_offset,\n\n\t.ioctls = i915_ioctls,\n\t.num_ioctls = ARRAY_SIZE(i915_ioctls),\n\t.fops = &i915_driver_fops,\n\t.name = DRIVER_NAME,\n\t.desc = DRIVER_DESC,\n\t.date = DRIVER_DATE,\n\t.major = DRIVER_MAJOR,\n\t.minor = DRIVER_MINOR,\n\t.patchlevel = DRIVER_PATCHLEVEL,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}