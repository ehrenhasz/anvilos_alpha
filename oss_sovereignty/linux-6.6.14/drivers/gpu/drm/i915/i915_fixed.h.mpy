{
  "module_name": "i915_fixed.h",
  "hash_id": "bbd10a1a579143d339f21a2c44e3552bad5dccf6db26cb758ede8b411a972930",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/i915/i915_fixed.h",
  "human_readable_source": " \n \n\n#ifndef _I915_FIXED_H_\n#define _I915_FIXED_H_\n\n#include <linux/bug.h>\n#include <linux/kernel.h>\n#include <linux/math64.h>\n#include <linux/types.h>\n\ntypedef struct {\n\tu32 val;\n} uint_fixed_16_16_t;\n\n#define FP_16_16_MAX ((uint_fixed_16_16_t){ .val = UINT_MAX })\n\nstatic inline bool is_fixed16_zero(uint_fixed_16_16_t val)\n{\n\treturn val.val == 0;\n}\n\nstatic inline uint_fixed_16_16_t u32_to_fixed16(u32 val)\n{\n\tuint_fixed_16_16_t fp = { .val = val << 16 };\n\n\tWARN_ON(val > U16_MAX);\n\n\treturn fp;\n}\n\nstatic inline u32 fixed16_to_u32_round_up(uint_fixed_16_16_t fp)\n{\n\treturn DIV_ROUND_UP(fp.val, 1 << 16);\n}\n\nstatic inline u32 fixed16_to_u32(uint_fixed_16_16_t fp)\n{\n\treturn fp.val >> 16;\n}\n\nstatic inline uint_fixed_16_16_t min_fixed16(uint_fixed_16_16_t min1,\n\t\t\t\t\t     uint_fixed_16_16_t min2)\n{\n\tuint_fixed_16_16_t min = { .val = min(min1.val, min2.val) };\n\n\treturn min;\n}\n\nstatic inline uint_fixed_16_16_t max_fixed16(uint_fixed_16_16_t max1,\n\t\t\t\t\t     uint_fixed_16_16_t max2)\n{\n\tuint_fixed_16_16_t max = { .val = max(max1.val, max2.val) };\n\n\treturn max;\n}\n\nstatic inline uint_fixed_16_16_t clamp_u64_to_fixed16(u64 val)\n{\n\tuint_fixed_16_16_t fp = { .val = (u32)val };\n\n\tWARN_ON(val > U32_MAX);\n\n\treturn fp;\n}\n\nstatic inline u32 div_round_up_fixed16(uint_fixed_16_16_t val,\n\t\t\t\t       uint_fixed_16_16_t d)\n{\n\treturn DIV_ROUND_UP(val.val, d.val);\n}\n\nstatic inline u32 mul_round_up_u32_fixed16(u32 val, uint_fixed_16_16_t mul)\n{\n\tu64 tmp;\n\n\ttmp = mul_u32_u32(val, mul.val);\n\ttmp = DIV_ROUND_UP_ULL(tmp, 1 << 16);\n\tWARN_ON(tmp > U32_MAX);\n\n\treturn (u32)tmp;\n}\n\nstatic inline uint_fixed_16_16_t mul_fixed16(uint_fixed_16_16_t val,\n\t\t\t\t\t     uint_fixed_16_16_t mul)\n{\n\tu64 tmp;\n\n\ttmp = mul_u32_u32(val.val, mul.val);\n\ttmp = tmp >> 16;\n\n\treturn clamp_u64_to_fixed16(tmp);\n}\n\nstatic inline uint_fixed_16_16_t div_fixed16(u32 val, u32 d)\n{\n\tu64 tmp;\n\n\ttmp = (u64)val << 16;\n\ttmp = DIV_ROUND_UP_ULL(tmp, d);\n\n\treturn clamp_u64_to_fixed16(tmp);\n}\n\nstatic inline u32 div_round_up_u32_fixed16(u32 val, uint_fixed_16_16_t d)\n{\n\tu64 tmp;\n\n\ttmp = (u64)val << 16;\n\ttmp = DIV_ROUND_UP_ULL(tmp, d.val);\n\tWARN_ON(tmp > U32_MAX);\n\n\treturn (u32)tmp;\n}\n\nstatic inline uint_fixed_16_16_t mul_u32_fixed16(u32 val, uint_fixed_16_16_t mul)\n{\n\tu64 tmp;\n\n\ttmp = mul_u32_u32(val, mul.val);\n\n\treturn clamp_u64_to_fixed16(tmp);\n}\n\nstatic inline uint_fixed_16_16_t add_fixed16(uint_fixed_16_16_t add1,\n\t\t\t\t\t     uint_fixed_16_16_t add2)\n{\n\tu64 tmp;\n\n\ttmp = (u64)add1.val + add2.val;\n\n\treturn clamp_u64_to_fixed16(tmp);\n}\n\nstatic inline uint_fixed_16_16_t add_fixed16_u32(uint_fixed_16_16_t add1,\n\t\t\t\t\t\t u32 add2)\n{\n\tuint_fixed_16_16_t tmp_add2 = u32_to_fixed16(add2);\n\tu64 tmp;\n\n\ttmp = (u64)add1.val + tmp_add2.val;\n\n\treturn clamp_u64_to_fixed16(tmp);\n}\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}