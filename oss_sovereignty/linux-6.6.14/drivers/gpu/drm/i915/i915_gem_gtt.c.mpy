{
  "module_name": "i915_gem_gtt.c",
  "hash_id": "db84d7549488a1a91ebbe817c2d7f720a4af73d34d121717ece5dde32181bb4d",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/i915/i915_gem_gtt.c",
  "human_readable_source": "\n \n\n#include <linux/slab.h>  \n\n#include <linux/fault-inject.h>\n#include <linux/log2.h>\n#include <linux/random.h>\n#include <linux/seq_file.h>\n#include <linux/stop_machine.h>\n\n#include <asm/set_memory.h>\n#include <asm/smp.h>\n\n#include \"display/intel_frontbuffer.h\"\n#include \"gt/intel_gt.h\"\n#include \"gt/intel_gt_requests.h\"\n\n#include \"i915_drv.h\"\n#include \"i915_gem_evict.h\"\n#include \"i915_scatterlist.h\"\n#include \"i915_trace.h\"\n#include \"i915_vgpu.h\"\n\nint i915_gem_gtt_prepare_pages(struct drm_i915_gem_object *obj,\n\t\t\t       struct sg_table *pages)\n{\n\tdo {\n\t\tif (dma_map_sg_attrs(obj->base.dev->dev,\n\t\t\t\t     pages->sgl, pages->nents,\n\t\t\t\t     DMA_BIDIRECTIONAL,\n\t\t\t\t     DMA_ATTR_SKIP_CPU_SYNC |\n\t\t\t\t     DMA_ATTR_NO_KERNEL_MAPPING |\n\t\t\t\t     DMA_ATTR_NO_WARN))\n\t\t\treturn 0;\n\n\t\t \n\t\tGEM_BUG_ON(obj->mm.pages == pages);\n\t} while (i915_gem_shrink(NULL, to_i915(obj->base.dev),\n\t\t\t\t obj->base.size >> PAGE_SHIFT, NULL,\n\t\t\t\t I915_SHRINK_BOUND |\n\t\t\t\t I915_SHRINK_UNBOUND));\n\n\treturn -ENOSPC;\n}\n\nvoid i915_gem_gtt_finish_pages(struct drm_i915_gem_object *obj,\n\t\t\t       struct sg_table *pages)\n{\n\tstruct drm_i915_private *i915 = to_i915(obj->base.dev);\n\tstruct i915_ggtt *ggtt = to_gt(i915)->ggtt;\n\n\t \n\tif (unlikely(ggtt->do_idle_maps))\n\t\t \n\t\tusleep_range(100, 250);\n\n\tdma_unmap_sg(i915->drm.dev, pages->sgl, pages->nents,\n\t\t     DMA_BIDIRECTIONAL);\n}\n\n \nint i915_gem_gtt_reserve(struct i915_address_space *vm,\n\t\t\t struct i915_gem_ww_ctx *ww,\n\t\t\t struct drm_mm_node *node,\n\t\t\t u64 size, u64 offset, unsigned long color,\n\t\t\t unsigned int flags)\n{\n\tint err;\n\n\tGEM_BUG_ON(!size);\n\tGEM_BUG_ON(!IS_ALIGNED(size, I915_GTT_PAGE_SIZE));\n\tGEM_BUG_ON(!IS_ALIGNED(offset, I915_GTT_MIN_ALIGNMENT));\n\tGEM_BUG_ON(range_overflows(offset, size, vm->total));\n\tGEM_BUG_ON(vm == &to_gt(vm->i915)->ggtt->alias->vm);\n\tGEM_BUG_ON(drm_mm_node_allocated(node));\n\n\tnode->size = size;\n\tnode->start = offset;\n\tnode->color = color;\n\n\terr = drm_mm_reserve_node(&vm->mm, node);\n\tif (err != -ENOSPC)\n\t\treturn err;\n\n\tif (flags & PIN_NOEVICT)\n\t\treturn -ENOSPC;\n\n\terr = i915_gem_evict_for_node(vm, ww, node, flags);\n\tif (err == 0)\n\t\terr = drm_mm_reserve_node(&vm->mm, node);\n\n\treturn err;\n}\n\nstatic u64 random_offset(u64 start, u64 end, u64 len, u64 align)\n{\n\tu64 range, addr;\n\n\tGEM_BUG_ON(range_overflows(start, len, end));\n\tGEM_BUG_ON(round_up(start, align) > round_down(end - len, align));\n\n\trange = round_down(end - len, align) - round_up(start, align);\n\tif (range) {\n\t\tif (sizeof(unsigned long) == sizeof(u64)) {\n\t\t\taddr = get_random_u64();\n\t\t} else {\n\t\t\taddr = get_random_u32();\n\t\t\tif (range > U32_MAX) {\n\t\t\t\taddr <<= 32;\n\t\t\t\taddr |= get_random_u32();\n\t\t\t}\n\t\t}\n\t\tdiv64_u64_rem(addr, range, &addr);\n\t\tstart += addr;\n\t}\n\n\treturn round_up(start, align);\n}\n\n \nint i915_gem_gtt_insert(struct i915_address_space *vm,\n\t\t\tstruct i915_gem_ww_ctx *ww,\n\t\t\tstruct drm_mm_node *node,\n\t\t\tu64 size, u64 alignment, unsigned long color,\n\t\t\tu64 start, u64 end, unsigned int flags)\n{\n\tenum drm_mm_insert_mode mode;\n\tu64 offset;\n\tint err;\n\n\tlockdep_assert_held(&vm->mutex);\n\n\tGEM_BUG_ON(!size);\n\tGEM_BUG_ON(!IS_ALIGNED(size, I915_GTT_PAGE_SIZE));\n\tGEM_BUG_ON(alignment && !is_power_of_2(alignment));\n\tGEM_BUG_ON(alignment && !IS_ALIGNED(alignment, I915_GTT_MIN_ALIGNMENT));\n\tGEM_BUG_ON(start >= end);\n\tGEM_BUG_ON(start > 0  && !IS_ALIGNED(start, I915_GTT_PAGE_SIZE));\n\tGEM_BUG_ON(end < U64_MAX && !IS_ALIGNED(end, I915_GTT_PAGE_SIZE));\n\tGEM_BUG_ON(vm == &to_gt(vm->i915)->ggtt->alias->vm);\n\tGEM_BUG_ON(drm_mm_node_allocated(node));\n\n\tif (unlikely(range_overflows(start, size, end)))\n\t\treturn -ENOSPC;\n\n\tif (unlikely(round_up(start, alignment) > round_down(end - size, alignment)))\n\t\treturn -ENOSPC;\n\n\tmode = DRM_MM_INSERT_BEST;\n\tif (flags & PIN_HIGH)\n\t\tmode = DRM_MM_INSERT_HIGHEST;\n\tif (flags & PIN_MAPPABLE)\n\t\tmode = DRM_MM_INSERT_LOW;\n\n\t \n\tBUILD_BUG_ON(I915_GTT_MIN_ALIGNMENT > I915_GTT_PAGE_SIZE);\n\tif (alignment <= I915_GTT_MIN_ALIGNMENT)\n\t\talignment = 0;\n\n\terr = drm_mm_insert_node_in_range(&vm->mm, node,\n\t\t\t\t\t  size, alignment, color,\n\t\t\t\t\t  start, end, mode);\n\tif (err != -ENOSPC)\n\t\treturn err;\n\n\tif (mode & DRM_MM_INSERT_ONCE) {\n\t\terr = drm_mm_insert_node_in_range(&vm->mm, node,\n\t\t\t\t\t\t  size, alignment, color,\n\t\t\t\t\t\t  start, end,\n\t\t\t\t\t\t  DRM_MM_INSERT_BEST);\n\t\tif (err != -ENOSPC)\n\t\t\treturn err;\n\t}\n\n\tif (flags & PIN_NOEVICT)\n\t\treturn -ENOSPC;\n\n\t \n\toffset = random_offset(start, end,\n\t\t\t       size, alignment ?: I915_GTT_MIN_ALIGNMENT);\n\terr = i915_gem_gtt_reserve(vm, ww, node, size, offset, color, flags);\n\tif (err != -ENOSPC)\n\t\treturn err;\n\n\tif (flags & PIN_NOSEARCH)\n\t\treturn -ENOSPC;\n\n\t \n\terr = i915_gem_evict_something(vm, ww, size, alignment, color,\n\t\t\t\t       start, end, flags);\n\tif (err)\n\t\treturn err;\n\n\treturn drm_mm_insert_node_in_range(&vm->mm, node,\n\t\t\t\t\t   size, alignment, color,\n\t\t\t\t\t   start, end, DRM_MM_INSERT_EVICT);\n}\n\n#if IS_ENABLED(CONFIG_DRM_I915_SELFTEST)\n#include \"selftests/i915_gem_gtt.c\"\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}