{
  "module_name": "vlv_sideband.c",
  "hash_id": "08b36fb2370cb9369baffbdfd0488fdb856a760de29e2bc5341c36bd784c46c7",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/i915/vlv_sideband.c",
  "human_readable_source": "\n \n\n#include \"i915_drv.h\"\n#include \"i915_iosf_mbi.h\"\n#include \"i915_reg.h\"\n#include \"vlv_sideband.h\"\n\n#include \"display/intel_dpio_phy.h\"\n#include \"display/intel_display_types.h\"\n\n \n\n \n#define SB_MRD_NP\t0x00\n \n#define SB_MWR_NP\t0x01\n \n#define SB_CRRDDA_NP\t0x06\n \n#define SB_CRWRDA_NP\t0x07\n\nstatic void ping(void *info)\n{\n}\n\nstatic void __vlv_punit_get(struct drm_i915_private *i915)\n{\n\tiosf_mbi_punit_acquire();\n\n\t \n\tif (IS_VALLEYVIEW(i915)) {\n\t\tcpu_latency_qos_update_request(&i915->sb_qos, 0);\n\t\ton_each_cpu(ping, NULL, 1);\n\t}\n}\n\nstatic void __vlv_punit_put(struct drm_i915_private *i915)\n{\n\tif (IS_VALLEYVIEW(i915))\n\t\tcpu_latency_qos_update_request(&i915->sb_qos,\n\t\t\t\t\t       PM_QOS_DEFAULT_VALUE);\n\n\tiosf_mbi_punit_release();\n}\n\nvoid vlv_iosf_sb_get(struct drm_i915_private *i915, unsigned long ports)\n{\n\tif (ports & BIT(VLV_IOSF_SB_PUNIT))\n\t\t__vlv_punit_get(i915);\n\n\tmutex_lock(&i915->sb_lock);\n}\n\nvoid vlv_iosf_sb_put(struct drm_i915_private *i915, unsigned long ports)\n{\n\tmutex_unlock(&i915->sb_lock);\n\n\tif (ports & BIT(VLV_IOSF_SB_PUNIT))\n\t\t__vlv_punit_put(i915);\n}\n\nstatic int vlv_sideband_rw(struct drm_i915_private *i915,\n\t\t\t   u32 devfn, u32 port, u32 opcode,\n\t\t\t   u32 addr, u32 *val)\n{\n\tstruct intel_uncore *uncore = &i915->uncore;\n\tconst bool is_read = (opcode == SB_MRD_NP || opcode == SB_CRRDDA_NP);\n\tint err;\n\n\tlockdep_assert_held(&i915->sb_lock);\n\tif (port == IOSF_PORT_PUNIT)\n\t\tiosf_mbi_assert_punit_acquired();\n\n\t \n\tif (intel_wait_for_register(uncore,\n\t\t\t\t    VLV_IOSF_DOORBELL_REQ, IOSF_SB_BUSY, 0,\n\t\t\t\t    5)) {\n\t\tdrm_dbg(&i915->drm, \"IOSF sideband idle wait (%s) timed out\\n\",\n\t\t\tis_read ? \"read\" : \"write\");\n\t\treturn -EAGAIN;\n\t}\n\n\tpreempt_disable();\n\n\tintel_uncore_write_fw(uncore, VLV_IOSF_ADDR, addr);\n\tintel_uncore_write_fw(uncore, VLV_IOSF_DATA, is_read ? 0 : *val);\n\tintel_uncore_write_fw(uncore, VLV_IOSF_DOORBELL_REQ,\n\t\t\t      (devfn << IOSF_DEVFN_SHIFT) |\n\t\t\t      (opcode << IOSF_OPCODE_SHIFT) |\n\t\t\t      (port << IOSF_PORT_SHIFT) |\n\t\t\t      (0xf << IOSF_BYTE_ENABLES_SHIFT) |\n\t\t\t      (0 << IOSF_BAR_SHIFT) |\n\t\t\t      IOSF_SB_BUSY);\n\n\tif (__intel_wait_for_register_fw(uncore,\n\t\t\t\t\t VLV_IOSF_DOORBELL_REQ, IOSF_SB_BUSY, 0,\n\t\t\t\t\t 10000, 0, NULL) == 0) {\n\t\tif (is_read)\n\t\t\t*val = intel_uncore_read_fw(uncore, VLV_IOSF_DATA);\n\t\terr = 0;\n\t} else {\n\t\tdrm_dbg(&i915->drm, \"IOSF sideband finish wait (%s) timed out\\n\",\n\t\t\tis_read ? \"read\" : \"write\");\n\t\terr = -ETIMEDOUT;\n\t}\n\n\tpreempt_enable();\n\n\treturn err;\n}\n\nu32 vlv_punit_read(struct drm_i915_private *i915, u32 addr)\n{\n\tu32 val = 0;\n\n\tvlv_sideband_rw(i915, PCI_DEVFN(0, 0), IOSF_PORT_PUNIT,\n\t\t\tSB_CRRDDA_NP, addr, &val);\n\n\treturn val;\n}\n\nint vlv_punit_write(struct drm_i915_private *i915, u32 addr, u32 val)\n{\n\treturn vlv_sideband_rw(i915, PCI_DEVFN(0, 0), IOSF_PORT_PUNIT,\n\t\t\t       SB_CRWRDA_NP, addr, &val);\n}\n\nu32 vlv_bunit_read(struct drm_i915_private *i915, u32 reg)\n{\n\tu32 val = 0;\n\n\tvlv_sideband_rw(i915, PCI_DEVFN(0, 0), IOSF_PORT_BUNIT,\n\t\t\tSB_CRRDDA_NP, reg, &val);\n\n\treturn val;\n}\n\nvoid vlv_bunit_write(struct drm_i915_private *i915, u32 reg, u32 val)\n{\n\tvlv_sideband_rw(i915, PCI_DEVFN(0, 0), IOSF_PORT_BUNIT,\n\t\t\tSB_CRWRDA_NP, reg, &val);\n}\n\nu32 vlv_nc_read(struct drm_i915_private *i915, u8 addr)\n{\n\tu32 val = 0;\n\n\tvlv_sideband_rw(i915, PCI_DEVFN(0, 0), IOSF_PORT_NC,\n\t\t\tSB_CRRDDA_NP, addr, &val);\n\n\treturn val;\n}\n\nu32 vlv_iosf_sb_read(struct drm_i915_private *i915, u8 port, u32 reg)\n{\n\tu32 val = 0;\n\n\tvlv_sideband_rw(i915, PCI_DEVFN(0, 0), port,\n\t\t\tSB_CRRDDA_NP, reg, &val);\n\n\treturn val;\n}\n\nvoid vlv_iosf_sb_write(struct drm_i915_private *i915,\n\t\t       u8 port, u32 reg, u32 val)\n{\n\tvlv_sideband_rw(i915, PCI_DEVFN(0, 0), port,\n\t\t\tSB_CRWRDA_NP, reg, &val);\n}\n\nu32 vlv_cck_read(struct drm_i915_private *i915, u32 reg)\n{\n\tu32 val = 0;\n\n\tvlv_sideband_rw(i915, PCI_DEVFN(0, 0), IOSF_PORT_CCK,\n\t\t\tSB_CRRDDA_NP, reg, &val);\n\n\treturn val;\n}\n\nvoid vlv_cck_write(struct drm_i915_private *i915, u32 reg, u32 val)\n{\n\tvlv_sideband_rw(i915, PCI_DEVFN(0, 0), IOSF_PORT_CCK,\n\t\t\tSB_CRWRDA_NP, reg, &val);\n}\n\nu32 vlv_ccu_read(struct drm_i915_private *i915, u32 reg)\n{\n\tu32 val = 0;\n\n\tvlv_sideband_rw(i915, PCI_DEVFN(0, 0), IOSF_PORT_CCU,\n\t\t\tSB_CRRDDA_NP, reg, &val);\n\n\treturn val;\n}\n\nvoid vlv_ccu_write(struct drm_i915_private *i915, u32 reg, u32 val)\n{\n\tvlv_sideband_rw(i915, PCI_DEVFN(0, 0), IOSF_PORT_CCU,\n\t\t\tSB_CRWRDA_NP, reg, &val);\n}\n\nstatic u32 vlv_dpio_phy_iosf_port(struct drm_i915_private *i915, enum dpio_phy phy)\n{\n\t \n\tif (IS_CHERRYVIEW(i915))\n\t\treturn phy == DPIO_PHY0 ? IOSF_PORT_DPIO_2 : IOSF_PORT_DPIO;\n\telse\n\t\treturn IOSF_PORT_DPIO;\n}\n\nu32 vlv_dpio_read(struct drm_i915_private *i915, enum pipe pipe, int reg)\n{\n\tu32 port = vlv_dpio_phy_iosf_port(i915, DPIO_PHY(pipe));\n\tu32 val = 0;\n\n\tvlv_sideband_rw(i915, DPIO_DEVFN, port, SB_MRD_NP, reg, &val);\n\n\t \n\tdrm_WARN(&i915->drm, val == 0xffffffff,\n\t\t \"DPIO read pipe %c reg 0x%x == 0x%x\\n\",\n\t\t pipe_name(pipe), reg, val);\n\n\treturn val;\n}\n\nvoid vlv_dpio_write(struct drm_i915_private *i915,\n\t\t    enum pipe pipe, int reg, u32 val)\n{\n\tu32 port = vlv_dpio_phy_iosf_port(i915, DPIO_PHY(pipe));\n\n\tvlv_sideband_rw(i915, DPIO_DEVFN, port, SB_MWR_NP, reg, &val);\n}\n\nu32 vlv_flisdsi_read(struct drm_i915_private *i915, u32 reg)\n{\n\tu32 val = 0;\n\n\tvlv_sideband_rw(i915, DPIO_DEVFN, IOSF_PORT_FLISDSI, SB_CRRDDA_NP,\n\t\t\treg, &val);\n\treturn val;\n}\n\nvoid vlv_flisdsi_write(struct drm_i915_private *i915, u32 reg, u32 val)\n{\n\tvlv_sideband_rw(i915, DPIO_DEVFN, IOSF_PORT_FLISDSI, SB_CRWRDA_NP,\n\t\t\treg, &val);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}