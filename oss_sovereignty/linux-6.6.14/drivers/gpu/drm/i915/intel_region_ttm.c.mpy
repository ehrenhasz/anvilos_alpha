{
  "module_name": "intel_region_ttm.c",
  "hash_id": "04a8fa2ea477011954eaf461e40385fc410296fb53c955e7a9ecbd0ec6339c36",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/i915/intel_region_ttm.c",
  "human_readable_source": "\n \n#include <drm/ttm/ttm_device.h>\n#include <drm/ttm/ttm_range_manager.h>\n\n#include \"i915_drv.h\"\n#include \"i915_scatterlist.h\"\n#include \"i915_ttm_buddy_manager.h\"\n\n#include \"intel_region_ttm.h\"\n\n#include \"gem/i915_gem_region.h\"\n#include \"gem/i915_gem_ttm.h\"  \n \n\n \nint intel_region_ttm_device_init(struct drm_i915_private *dev_priv)\n{\n\tstruct drm_device *drm = &dev_priv->drm;\n\n\treturn ttm_device_init(&dev_priv->bdev, i915_ttm_driver(),\n\t\t\t       drm->dev, drm->anon_inode->i_mapping,\n\t\t\t       drm->vma_offset_manager, false, false);\n}\n\n \nvoid intel_region_ttm_device_fini(struct drm_i915_private *dev_priv)\n{\n\tttm_device_fini(&dev_priv->bdev);\n}\n\n \nint intel_region_to_ttm_type(const struct intel_memory_region *mem)\n{\n\tint type;\n\n\tGEM_BUG_ON(mem->type != INTEL_MEMORY_LOCAL &&\n\t\t   mem->type != INTEL_MEMORY_MOCK &&\n\t\t   mem->type != INTEL_MEMORY_SYSTEM);\n\n\tif (mem->type == INTEL_MEMORY_SYSTEM)\n\t\treturn TTM_PL_SYSTEM;\n\n\ttype = mem->instance + TTM_PL_PRIV;\n\tGEM_BUG_ON(type >= TTM_NUM_MEM_TYPES);\n\n\treturn type;\n}\n\n \nint intel_region_ttm_init(struct intel_memory_region *mem)\n{\n\tstruct ttm_device *bdev = &mem->i915->bdev;\n\tint mem_type = intel_region_to_ttm_type(mem);\n\tint ret;\n\n\tret = i915_ttm_buddy_man_init(bdev, mem_type, false,\n\t\t\t\t      resource_size(&mem->region),\n\t\t\t\t      mem->io_size,\n\t\t\t\t      mem->min_page_size, PAGE_SIZE);\n\tif (ret)\n\t\treturn ret;\n\n\tmem->region_private = ttm_manager_type(bdev, mem_type);\n\n\treturn 0;\n}\n\n \nint intel_region_ttm_fini(struct intel_memory_region *mem)\n{\n\tstruct ttm_resource_manager *man = mem->region_private;\n\tint ret = -EBUSY;\n\tint count;\n\n\t \n\tif (man)\n\t\tttm_resource_manager_cleanup(man);\n\n\t \n\tfor (count = 0; count < 10; ++count) {\n\t\ti915_gem_flush_free_objects(mem->i915);\n\n\t\tmutex_lock(&mem->objects.lock);\n\t\tif (list_empty(&mem->objects.list))\n\t\t\tret = 0;\n\t\tmutex_unlock(&mem->objects.lock);\n\t\tif (!ret)\n\t\t\tbreak;\n\n\t\tmsleep(20);\n\t\tdrain_workqueue(mem->i915->bdev.wq);\n\t}\n\n\t \n\tif (ret || !man)\n\t\treturn ret;\n\n\tret = i915_ttm_buddy_man_fini(&mem->i915->bdev,\n\t\t\t\t      intel_region_to_ttm_type(mem));\n\tGEM_WARN_ON(ret);\n\tmem->region_private = NULL;\n\n\treturn ret;\n}\n\n \nstruct i915_refct_sgt *\nintel_region_ttm_resource_to_rsgt(struct intel_memory_region *mem,\n\t\t\t\t  struct ttm_resource *res,\n\t\t\t\t  u32 page_alignment)\n{\n\tif (mem->is_range_manager) {\n\t\tstruct ttm_range_mgr_node *range_node =\n\t\t\tto_ttm_range_mgr_node(res);\n\n\t\treturn i915_rsgt_from_mm_node(&range_node->mm_nodes[0],\n\t\t\t\t\t      mem->region.start,\n\t\t\t\t\t      page_alignment);\n\t} else {\n\t\treturn i915_rsgt_from_buddy_resource(res, mem->region.start,\n\t\t\t\t\t\t     page_alignment);\n\t}\n}\n\n#ifdef CONFIG_DRM_I915_SELFTEST\n \nstruct ttm_resource *\nintel_region_ttm_resource_alloc(struct intel_memory_region *mem,\n\t\t\t\tresource_size_t offset,\n\t\t\t\tresource_size_t size,\n\t\t\t\tunsigned int flags)\n{\n\tstruct ttm_resource_manager *man = mem->region_private;\n\tstruct ttm_place place = {};\n\tstruct ttm_buffer_object mock_bo = {};\n\tstruct ttm_resource *res;\n\tint ret;\n\n\tif (flags & I915_BO_ALLOC_CONTIGUOUS)\n\t\tplace.flags |= TTM_PL_FLAG_CONTIGUOUS;\n\tif (offset != I915_BO_INVALID_OFFSET) {\n\t\tif (WARN_ON(overflows_type(offset >> PAGE_SHIFT, place.fpfn))) {\n\t\t\tret = -E2BIG;\n\t\t\tgoto out;\n\t\t}\n\t\tplace.fpfn = offset >> PAGE_SHIFT;\n\t\tif (WARN_ON(overflows_type(place.fpfn + (size >> PAGE_SHIFT), place.lpfn))) {\n\t\t\tret = -E2BIG;\n\t\t\tgoto out;\n\t\t}\n\t\tplace.lpfn = place.fpfn + (size >> PAGE_SHIFT);\n\t} else if (mem->io_size && mem->io_size < mem->total) {\n\t\tif (flags & I915_BO_ALLOC_GPU_ONLY) {\n\t\t\tplace.flags |= TTM_PL_FLAG_TOPDOWN;\n\t\t} else {\n\t\t\tplace.fpfn = 0;\n\t\t\tif (WARN_ON(overflows_type(mem->io_size >> PAGE_SHIFT, place.lpfn))) {\n\t\t\t\tret = -E2BIG;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tplace.lpfn = mem->io_size >> PAGE_SHIFT;\n\t\t}\n\t}\n\n\tmock_bo.base.size = size;\n\tmock_bo.bdev = &mem->i915->bdev;\n\n\tret = man->func->alloc(man, &mock_bo, &place, &res);\n\nout:\n\tif (ret == -ENOSPC)\n\t\tret = -ENXIO;\n\tif (!ret)\n\t\tres->bo = NULL;  \n\treturn ret ? ERR_PTR(ret) : res;\n}\n\n#endif\n\n \nvoid intel_region_ttm_resource_free(struct intel_memory_region *mem,\n\t\t\t\t    struct ttm_resource *res)\n{\n\tstruct ttm_resource_manager *man = mem->region_private;\n\tstruct ttm_buffer_object mock_bo = {};\n\n\tmock_bo.base.size = res->size;\n\tmock_bo.bdev = &mem->i915->bdev;\n\tres->bo = &mock_bo;\n\n\tman->func->free(man, res);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}