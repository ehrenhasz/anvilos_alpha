{
  "module_name": "intel_wakeref.h",
  "hash_id": "23ad4ee86405c6558df0e92252fe20bbeebf22af2d25b50bed20cca46ff5c9fc",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/i915/intel_wakeref.h",
  "human_readable_source": " \n\n#ifndef INTEL_WAKEREF_H\n#define INTEL_WAKEREF_H\n\n#include <linux/atomic.h>\n#include <linux/bitfield.h>\n#include <linux/bits.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/refcount.h>\n#include <linux/stackdepot.h>\n#include <linux/timer.h>\n#include <linux/workqueue.h>\n\n#if IS_ENABLED(CONFIG_DRM_I915_DEBUG)\n#define INTEL_WAKEREF_BUG_ON(expr) BUG_ON(expr)\n#else\n#define INTEL_WAKEREF_BUG_ON(expr) BUILD_BUG_ON_INVALID(expr)\n#endif\n\nstruct intel_runtime_pm;\nstruct intel_wakeref;\n\ntypedef depot_stack_handle_t intel_wakeref_t;\n\nstruct intel_wakeref_ops {\n\tint (*get)(struct intel_wakeref *wf);\n\tint (*put)(struct intel_wakeref *wf);\n};\n\nstruct intel_wakeref {\n\tatomic_t count;\n\tstruct mutex mutex;\n\n\tintel_wakeref_t wakeref;\n\n\tstruct drm_i915_private *i915;\n\tconst struct intel_wakeref_ops *ops;\n\n\tstruct delayed_work work;\n};\n\nstruct intel_wakeref_lockclass {\n\tstruct lock_class_key mutex;\n\tstruct lock_class_key work;\n};\n\nvoid __intel_wakeref_init(struct intel_wakeref *wf,\n\t\t\t  struct drm_i915_private *i915,\n\t\t\t  const struct intel_wakeref_ops *ops,\n\t\t\t  struct intel_wakeref_lockclass *key);\n#define intel_wakeref_init(wf, i915, ops) do {\t\t\t\t\\\n\tstatic struct intel_wakeref_lockclass __key;\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\t__intel_wakeref_init((wf), (i915), (ops), &__key);\t\t\\\n} while (0)\n\nint __intel_wakeref_get_first(struct intel_wakeref *wf);\nvoid __intel_wakeref_put_last(struct intel_wakeref *wf, unsigned long flags);\n\n \nstatic inline int\nintel_wakeref_get(struct intel_wakeref *wf)\n{\n\tmight_sleep();\n\tif (unlikely(!atomic_inc_not_zero(&wf->count)))\n\t\treturn __intel_wakeref_get_first(wf);\n\n\treturn 0;\n}\n\n \nstatic inline void\n__intel_wakeref_get(struct intel_wakeref *wf)\n{\n\tINTEL_WAKEREF_BUG_ON(atomic_read(&wf->count) <= 0);\n\tatomic_inc(&wf->count);\n}\n\n \nstatic inline bool\nintel_wakeref_get_if_active(struct intel_wakeref *wf)\n{\n\treturn atomic_inc_not_zero(&wf->count);\n}\n\nenum {\n\tINTEL_WAKEREF_PUT_ASYNC_BIT = 0,\n\t__INTEL_WAKEREF_PUT_LAST_BIT__\n};\n\nstatic inline void\nintel_wakeref_might_get(struct intel_wakeref *wf)\n{\n\tmight_lock(&wf->mutex);\n}\n\n \nstatic inline void\n__intel_wakeref_put(struct intel_wakeref *wf, unsigned long flags)\n#define INTEL_WAKEREF_PUT_ASYNC BIT(INTEL_WAKEREF_PUT_ASYNC_BIT)\n#define INTEL_WAKEREF_PUT_DELAY \\\n\tGENMASK(BITS_PER_LONG - 1, __INTEL_WAKEREF_PUT_LAST_BIT__)\n{\n\tINTEL_WAKEREF_BUG_ON(atomic_read(&wf->count) <= 0);\n\tif (unlikely(!atomic_add_unless(&wf->count, -1, 1)))\n\t\t__intel_wakeref_put_last(wf, flags);\n}\n\nstatic inline void\nintel_wakeref_put(struct intel_wakeref *wf)\n{\n\tmight_sleep();\n\t__intel_wakeref_put(wf, 0);\n}\n\nstatic inline void\nintel_wakeref_put_async(struct intel_wakeref *wf)\n{\n\t__intel_wakeref_put(wf, INTEL_WAKEREF_PUT_ASYNC);\n}\n\nstatic inline void\nintel_wakeref_put_delay(struct intel_wakeref *wf, unsigned long delay)\n{\n\t__intel_wakeref_put(wf,\n\t\t\t    INTEL_WAKEREF_PUT_ASYNC |\n\t\t\t    FIELD_PREP(INTEL_WAKEREF_PUT_DELAY, delay));\n}\n\nstatic inline void\nintel_wakeref_might_put(struct intel_wakeref *wf)\n{\n\tmight_lock(&wf->mutex);\n}\n\n \nstatic inline void\nintel_wakeref_lock(struct intel_wakeref *wf)\n\t__acquires(wf->mutex)\n{\n\tmutex_lock(&wf->mutex);\n}\n\n \nstatic inline void\nintel_wakeref_unlock(struct intel_wakeref *wf)\n\t__releases(wf->mutex)\n{\n\tmutex_unlock(&wf->mutex);\n}\n\n \nstatic inline void\nintel_wakeref_unlock_wait(struct intel_wakeref *wf)\n{\n\tmutex_lock(&wf->mutex);\n\tmutex_unlock(&wf->mutex);\n\tflush_delayed_work(&wf->work);\n}\n\n \nstatic inline bool\nintel_wakeref_is_active(const struct intel_wakeref *wf)\n{\n\treturn READ_ONCE(wf->wakeref);\n}\n\n \nstatic inline void\n__intel_wakeref_defer_park(struct intel_wakeref *wf)\n{\n\tlockdep_assert_held(&wf->mutex);\n\tINTEL_WAKEREF_BUG_ON(atomic_read(&wf->count));\n\tatomic_set_release(&wf->count, 1);\n}\n\n \nint intel_wakeref_wait_for_idle(struct intel_wakeref *wf);\n\nstruct intel_wakeref_auto {\n\tstruct drm_i915_private *i915;\n\tstruct timer_list timer;\n\tintel_wakeref_t wakeref;\n\tspinlock_t lock;\n\trefcount_t count;\n};\n\n \nvoid intel_wakeref_auto(struct intel_wakeref_auto *wf, unsigned long timeout);\n\nvoid intel_wakeref_auto_init(struct intel_wakeref_auto *wf,\n\t\t\t     struct drm_i915_private *i915);\nvoid intel_wakeref_auto_fini(struct intel_wakeref_auto *wf);\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}