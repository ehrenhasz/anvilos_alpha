{
  "module_name": "i915_cmd_parser.c",
  "hash_id": "5554090be1efd2b38d4a06be6a9bd8f286c69762c7fe91d73a34abfa1628e6fa",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/i915/i915_cmd_parser.c",
  "human_readable_source": " \n\n#include <linux/highmem.h>\n\n#include <drm/drm_cache.h>\n\n#include \"gt/intel_engine.h\"\n#include \"gt/intel_engine_regs.h\"\n#include \"gt/intel_gpu_commands.h\"\n#include \"gt/intel_gt_regs.h\"\n\n#include \"i915_cmd_parser.h\"\n#include \"i915_drv.h\"\n#include \"i915_memcpy.h\"\n#include \"i915_reg.h\"\n\n \n\n \nstruct drm_i915_cmd_descriptor {\n\t \n\tu32 flags;\n#define CMD_DESC_FIXED    (1<<0)\n#define CMD_DESC_SKIP     (1<<1)\n#define CMD_DESC_REJECT   (1<<2)\n#define CMD_DESC_REGISTER (1<<3)\n#define CMD_DESC_BITMASK  (1<<4)\n\n\t \n\tstruct {\n\t\tu32 value;\n\t\tu32 mask;\n\t} cmd;\n\n\t \n\tunion {\n\t\tu32 fixed;\n\t\tu32 mask;\n\t} length;\n\n\t \n\tstruct {\n\t\tu32 offset;\n\t\tu32 mask;\n\t\tu32 step;\n\t} reg;\n\n#define MAX_CMD_DESC_BITMASKS 3\n\t \n\tstruct {\n\t\tu32 offset;\n\t\tu32 mask;\n\t\tu32 expected;\n\t\tu32 condition_offset;\n\t\tu32 condition_mask;\n\t} bits[MAX_CMD_DESC_BITMASKS];\n};\n\n \nstruct drm_i915_cmd_table {\n\tconst struct drm_i915_cmd_descriptor *table;\n\tint count;\n};\n\n#define STD_MI_OPCODE_SHIFT  (32 - 9)\n#define STD_3D_OPCODE_SHIFT  (32 - 16)\n#define STD_2D_OPCODE_SHIFT  (32 - 10)\n#define STD_MFX_OPCODE_SHIFT (32 - 16)\n#define MIN_OPCODE_SHIFT 16\n\n#define CMD(op, opm, f, lm, fl, ...)\t\t\t\t\\\n\t{\t\t\t\t\t\t\t\\\n\t\t.flags = (fl) | ((f) ? CMD_DESC_FIXED : 0),\t\\\n\t\t.cmd = { (op & ~0u << (opm)), ~0u << (opm) },\t\\\n\t\t.length = { (lm) },\t\t\t\t\\\n\t\t__VA_ARGS__\t\t\t\t\t\\\n\t}\n\n \n#define SMI STD_MI_OPCODE_SHIFT\n#define S3D STD_3D_OPCODE_SHIFT\n#define S2D STD_2D_OPCODE_SHIFT\n#define SMFX STD_MFX_OPCODE_SHIFT\n#define F true\n#define S CMD_DESC_SKIP\n#define R CMD_DESC_REJECT\n#define W CMD_DESC_REGISTER\n#define B CMD_DESC_BITMASK\n\n \nstatic const struct drm_i915_cmd_descriptor gen7_common_cmds[] = {\n\tCMD(  MI_NOOP,                          SMI,    F,  1,      S  ),\n\tCMD(  MI_USER_INTERRUPT,                SMI,    F,  1,      R  ),\n\tCMD(  MI_WAIT_FOR_EVENT,                SMI,    F,  1,      R  ),\n\tCMD(  MI_ARB_CHECK,                     SMI,    F,  1,      S  ),\n\tCMD(  MI_REPORT_HEAD,                   SMI,    F,  1,      S  ),\n\tCMD(  MI_SUSPEND_FLUSH,                 SMI,    F,  1,      S  ),\n\tCMD(  MI_SEMAPHORE_MBOX,                SMI,   !F,  0xFF,   R  ),\n\tCMD(  MI_STORE_DWORD_INDEX,             SMI,   !F,  0xFF,   R  ),\n\tCMD(  MI_LOAD_REGISTER_IMM(1),          SMI,   !F,  0xFF,   W,\n\t      .reg = { .offset = 1, .mask = 0x007FFFFC, .step = 2 }    ),\n\tCMD(  MI_STORE_REGISTER_MEM,            SMI,    F,  3,     W | B,\n\t      .reg = { .offset = 1, .mask = 0x007FFFFC },\n\t      .bits = {{\n\t\t\t.offset = 0,\n\t\t\t.mask = MI_GLOBAL_GTT,\n\t\t\t.expected = 0,\n\t      }},\t\t\t\t\t\t       ),\n\tCMD(  MI_LOAD_REGISTER_MEM,             SMI,    F,  3,     W | B,\n\t      .reg = { .offset = 1, .mask = 0x007FFFFC },\n\t      .bits = {{\n\t\t\t.offset = 0,\n\t\t\t.mask = MI_GLOBAL_GTT,\n\t\t\t.expected = 0,\n\t      }},\t\t\t\t\t\t       ),\n\t \n\tCMD(  MI_BATCH_BUFFER_START,            SMI,   !F,  0xFF,   S  ),\n};\n\nstatic const struct drm_i915_cmd_descriptor gen7_render_cmds[] = {\n\tCMD(  MI_FLUSH,                         SMI,    F,  1,      S  ),\n\tCMD(  MI_ARB_ON_OFF,                    SMI,    F,  1,      R  ),\n\tCMD(  MI_PREDICATE,                     SMI,    F,  1,      S  ),\n\tCMD(  MI_TOPOLOGY_FILTER,               SMI,    F,  1,      S  ),\n\tCMD(  MI_SET_APPID,                     SMI,    F,  1,      S  ),\n\tCMD(  MI_DISPLAY_FLIP,                  SMI,   !F,  0xFF,   R  ),\n\tCMD(  MI_SET_CONTEXT,                   SMI,   !F,  0xFF,   R  ),\n\tCMD(  MI_URB_CLEAR,                     SMI,   !F,  0xFF,   S  ),\n\tCMD(  MI_STORE_DWORD_IMM,               SMI,   !F,  0x3F,   B,\n\t      .bits = {{\n\t\t\t.offset = 0,\n\t\t\t.mask = MI_GLOBAL_GTT,\n\t\t\t.expected = 0,\n\t      }},\t\t\t\t\t\t       ),\n\tCMD(  MI_UPDATE_GTT,                    SMI,   !F,  0xFF,   R  ),\n\tCMD(  MI_CLFLUSH,                       SMI,   !F,  0x3FF,  B,\n\t      .bits = {{\n\t\t\t.offset = 0,\n\t\t\t.mask = MI_GLOBAL_GTT,\n\t\t\t.expected = 0,\n\t      }},\t\t\t\t\t\t       ),\n\tCMD(  MI_REPORT_PERF_COUNT,             SMI,   !F,  0x3F,   B,\n\t      .bits = {{\n\t\t\t.offset = 1,\n\t\t\t.mask = MI_REPORT_PERF_COUNT_GGTT,\n\t\t\t.expected = 0,\n\t      }},\t\t\t\t\t\t       ),\n\tCMD(  MI_CONDITIONAL_BATCH_BUFFER_END,  SMI,   !F,  0xFF,   B,\n\t      .bits = {{\n\t\t\t.offset = 0,\n\t\t\t.mask = MI_GLOBAL_GTT,\n\t\t\t.expected = 0,\n\t      }},\t\t\t\t\t\t       ),\n\tCMD(  GFX_OP_3DSTATE_VF_STATISTICS,     S3D,    F,  1,      S  ),\n\tCMD(  PIPELINE_SELECT,                  S3D,    F,  1,      S  ),\n\tCMD(  MEDIA_VFE_STATE,\t\t\tS3D,   !F,  0xFFFF, B,\n\t      .bits = {{\n\t\t\t.offset = 2,\n\t\t\t.mask = MEDIA_VFE_STATE_MMIO_ACCESS_MASK,\n\t\t\t.expected = 0,\n\t      }},\t\t\t\t\t\t       ),\n\tCMD(  GPGPU_OBJECT,                     S3D,   !F,  0xFF,   S  ),\n\tCMD(  GPGPU_WALKER,                     S3D,   !F,  0xFF,   S  ),\n\tCMD(  GFX_OP_3DSTATE_SO_DECL_LIST,      S3D,   !F,  0x1FF,  S  ),\n\tCMD(  GFX_OP_PIPE_CONTROL(5),           S3D,   !F,  0xFF,   B,\n\t      .bits = {{\n\t\t\t.offset = 1,\n\t\t\t.mask = (PIPE_CONTROL_MMIO_WRITE | PIPE_CONTROL_NOTIFY),\n\t\t\t.expected = 0,\n\t      },\n\t      {\n\t\t\t.offset = 1,\n\t\t        .mask = (PIPE_CONTROL_GLOBAL_GTT_IVB |\n\t\t\t\t PIPE_CONTROL_STORE_DATA_INDEX),\n\t\t\t.expected = 0,\n\t\t\t.condition_offset = 1,\n\t\t\t.condition_mask = PIPE_CONTROL_POST_SYNC_OP_MASK,\n\t      }},\t\t\t\t\t\t       ),\n};\n\nstatic const struct drm_i915_cmd_descriptor hsw_render_cmds[] = {\n\tCMD(  MI_SET_PREDICATE,                 SMI,    F,  1,      S  ),\n\tCMD(  MI_RS_CONTROL,                    SMI,    F,  1,      S  ),\n\tCMD(  MI_URB_ATOMIC_ALLOC,              SMI,    F,  1,      S  ),\n\tCMD(  MI_SET_APPID,                     SMI,    F,  1,      S  ),\n\tCMD(  MI_RS_CONTEXT,                    SMI,    F,  1,      S  ),\n\tCMD(  MI_LOAD_SCAN_LINES_INCL,          SMI,   !F,  0x3F,   R  ),\n\tCMD(  MI_LOAD_SCAN_LINES_EXCL,          SMI,   !F,  0x3F,   R  ),\n\tCMD(  MI_LOAD_REGISTER_REG,             SMI,   !F,  0xFF,   W,\n\t      .reg = { .offset = 1, .mask = 0x007FFFFC, .step = 1 }    ),\n\tCMD(  MI_RS_STORE_DATA_IMM,             SMI,   !F,  0xFF,   S  ),\n\tCMD(  MI_LOAD_URB_MEM,                  SMI,   !F,  0xFF,   S  ),\n\tCMD(  MI_STORE_URB_MEM,                 SMI,   !F,  0xFF,   S  ),\n\tCMD(  GFX_OP_3DSTATE_DX9_CONSTANTF_VS,  S3D,   !F,  0x7FF,  S  ),\n\tCMD(  GFX_OP_3DSTATE_DX9_CONSTANTF_PS,  S3D,   !F,  0x7FF,  S  ),\n\n\tCMD(  GFX_OP_3DSTATE_BINDING_TABLE_EDIT_VS,  S3D,   !F,  0x1FF,  S  ),\n\tCMD(  GFX_OP_3DSTATE_BINDING_TABLE_EDIT_GS,  S3D,   !F,  0x1FF,  S  ),\n\tCMD(  GFX_OP_3DSTATE_BINDING_TABLE_EDIT_HS,  S3D,   !F,  0x1FF,  S  ),\n\tCMD(  GFX_OP_3DSTATE_BINDING_TABLE_EDIT_DS,  S3D,   !F,  0x1FF,  S  ),\n\tCMD(  GFX_OP_3DSTATE_BINDING_TABLE_EDIT_PS,  S3D,   !F,  0x1FF,  S  ),\n};\n\nstatic const struct drm_i915_cmd_descriptor gen7_video_cmds[] = {\n\tCMD(  MI_ARB_ON_OFF,                    SMI,    F,  1,      R  ),\n\tCMD(  MI_SET_APPID,                     SMI,    F,  1,      S  ),\n\tCMD(  MI_STORE_DWORD_IMM,               SMI,   !F,  0xFF,   B,\n\t      .bits = {{\n\t\t\t.offset = 0,\n\t\t\t.mask = MI_GLOBAL_GTT,\n\t\t\t.expected = 0,\n\t      }},\t\t\t\t\t\t       ),\n\tCMD(  MI_UPDATE_GTT,                    SMI,   !F,  0x3F,   R  ),\n\tCMD(  MI_FLUSH_DW,                      SMI,   !F,  0x3F,   B,\n\t      .bits = {{\n\t\t\t.offset = 0,\n\t\t\t.mask = MI_FLUSH_DW_NOTIFY,\n\t\t\t.expected = 0,\n\t      },\n\t      {\n\t\t\t.offset = 1,\n\t\t\t.mask = MI_FLUSH_DW_USE_GTT,\n\t\t\t.expected = 0,\n\t\t\t.condition_offset = 0,\n\t\t\t.condition_mask = MI_FLUSH_DW_OP_MASK,\n\t      },\n\t      {\n\t\t\t.offset = 0,\n\t\t\t.mask = MI_FLUSH_DW_STORE_INDEX,\n\t\t\t.expected = 0,\n\t\t\t.condition_offset = 0,\n\t\t\t.condition_mask = MI_FLUSH_DW_OP_MASK,\n\t      }},\t\t\t\t\t\t       ),\n\tCMD(  MI_CONDITIONAL_BATCH_BUFFER_END,  SMI,   !F,  0xFF,   B,\n\t      .bits = {{\n\t\t\t.offset = 0,\n\t\t\t.mask = MI_GLOBAL_GTT,\n\t\t\t.expected = 0,\n\t      }},\t\t\t\t\t\t       ),\n\t \n\tCMD(  MFX_WAIT,                         SMFX,   F,  1,      S  ),\n};\n\nstatic const struct drm_i915_cmd_descriptor gen7_vecs_cmds[] = {\n\tCMD(  MI_ARB_ON_OFF,                    SMI,    F,  1,      R  ),\n\tCMD(  MI_SET_APPID,                     SMI,    F,  1,      S  ),\n\tCMD(  MI_STORE_DWORD_IMM,               SMI,   !F,  0xFF,   B,\n\t      .bits = {{\n\t\t\t.offset = 0,\n\t\t\t.mask = MI_GLOBAL_GTT,\n\t\t\t.expected = 0,\n\t      }},\t\t\t\t\t\t       ),\n\tCMD(  MI_UPDATE_GTT,                    SMI,   !F,  0x3F,   R  ),\n\tCMD(  MI_FLUSH_DW,                      SMI,   !F,  0x3F,   B,\n\t      .bits = {{\n\t\t\t.offset = 0,\n\t\t\t.mask = MI_FLUSH_DW_NOTIFY,\n\t\t\t.expected = 0,\n\t      },\n\t      {\n\t\t\t.offset = 1,\n\t\t\t.mask = MI_FLUSH_DW_USE_GTT,\n\t\t\t.expected = 0,\n\t\t\t.condition_offset = 0,\n\t\t\t.condition_mask = MI_FLUSH_DW_OP_MASK,\n\t      },\n\t      {\n\t\t\t.offset = 0,\n\t\t\t.mask = MI_FLUSH_DW_STORE_INDEX,\n\t\t\t.expected = 0,\n\t\t\t.condition_offset = 0,\n\t\t\t.condition_mask = MI_FLUSH_DW_OP_MASK,\n\t      }},\t\t\t\t\t\t       ),\n\tCMD(  MI_CONDITIONAL_BATCH_BUFFER_END,  SMI,   !F,  0xFF,   B,\n\t      .bits = {{\n\t\t\t.offset = 0,\n\t\t\t.mask = MI_GLOBAL_GTT,\n\t\t\t.expected = 0,\n\t      }},\t\t\t\t\t\t       ),\n};\n\nstatic const struct drm_i915_cmd_descriptor gen7_blt_cmds[] = {\n\tCMD(  MI_DISPLAY_FLIP,                  SMI,   !F,  0xFF,   R  ),\n\tCMD(  MI_STORE_DWORD_IMM,               SMI,   !F,  0x3FF,  B,\n\t      .bits = {{\n\t\t\t.offset = 0,\n\t\t\t.mask = MI_GLOBAL_GTT,\n\t\t\t.expected = 0,\n\t      }},\t\t\t\t\t\t       ),\n\tCMD(  MI_UPDATE_GTT,                    SMI,   !F,  0x3F,   R  ),\n\tCMD(  MI_FLUSH_DW,                      SMI,   !F,  0x3F,   B,\n\t      .bits = {{\n\t\t\t.offset = 0,\n\t\t\t.mask = MI_FLUSH_DW_NOTIFY,\n\t\t\t.expected = 0,\n\t      },\n\t      {\n\t\t\t.offset = 1,\n\t\t\t.mask = MI_FLUSH_DW_USE_GTT,\n\t\t\t.expected = 0,\n\t\t\t.condition_offset = 0,\n\t\t\t.condition_mask = MI_FLUSH_DW_OP_MASK,\n\t      },\n\t      {\n\t\t\t.offset = 0,\n\t\t\t.mask = MI_FLUSH_DW_STORE_INDEX,\n\t\t\t.expected = 0,\n\t\t\t.condition_offset = 0,\n\t\t\t.condition_mask = MI_FLUSH_DW_OP_MASK,\n\t      }},\t\t\t\t\t\t       ),\n\tCMD(  COLOR_BLT,                        S2D,   !F,  0x3F,   S  ),\n\tCMD(  SRC_COPY_BLT,                     S2D,   !F,  0x3F,   S  ),\n};\n\nstatic const struct drm_i915_cmd_descriptor hsw_blt_cmds[] = {\n\tCMD(  MI_LOAD_SCAN_LINES_INCL,          SMI,   !F,  0x3F,   R  ),\n\tCMD(  MI_LOAD_SCAN_LINES_EXCL,          SMI,   !F,  0x3F,   R  ),\n};\n\n \nstatic const struct drm_i915_cmd_descriptor gen9_blt_cmds[] = {\n\tCMD(  MI_NOOP,                          SMI,    F,  1,      S  ),\n\tCMD(  MI_USER_INTERRUPT,                SMI,    F,  1,      S  ),\n\tCMD(  MI_WAIT_FOR_EVENT,                SMI,    F,  1,      S  ),\n\tCMD(  MI_FLUSH,                         SMI,    F,  1,      S  ),\n\tCMD(  MI_ARB_CHECK,                     SMI,    F,  1,      S  ),\n\tCMD(  MI_REPORT_HEAD,                   SMI,    F,  1,      S  ),\n\tCMD(  MI_ARB_ON_OFF,                    SMI,    F,  1,      S  ),\n\tCMD(  MI_SUSPEND_FLUSH,                 SMI,    F,  1,      S  ),\n\tCMD(  MI_LOAD_SCAN_LINES_INCL,          SMI,   !F,  0x3F,   S  ),\n\tCMD(  MI_LOAD_SCAN_LINES_EXCL,          SMI,   !F,  0x3F,   S  ),\n\tCMD(  MI_STORE_DWORD_IMM,               SMI,   !F,  0x3FF,  S  ),\n\tCMD(  MI_LOAD_REGISTER_IMM(1),          SMI,   !F,  0xFF,   W,\n\t      .reg = { .offset = 1, .mask = 0x007FFFFC, .step = 2 }    ),\n\tCMD(  MI_UPDATE_GTT,                    SMI,   !F,  0x3FF,  S  ),\n\tCMD(  MI_STORE_REGISTER_MEM_GEN8,       SMI,    F,  4,      W,\n\t      .reg = { .offset = 1, .mask = 0x007FFFFC }               ),\n\tCMD(  MI_FLUSH_DW,                      SMI,   !F,  0x3F,   S  ),\n\tCMD(  MI_LOAD_REGISTER_MEM_GEN8,        SMI,    F,  4,      W,\n\t      .reg = { .offset = 1, .mask = 0x007FFFFC }               ),\n\tCMD(  MI_LOAD_REGISTER_REG,             SMI,    !F,  0xFF,  W,\n\t      .reg = { .offset = 1, .mask = 0x007FFFFC, .step = 1 }    ),\n\n\t \n#define MI_BB_START_OPERAND_MASK   GENMASK(SMI-1, 0)\n#define MI_BB_START_OPERAND_EXPECT (MI_BATCH_PPGTT_HSW | 1)\n\tCMD(  MI_BATCH_BUFFER_START_GEN8,       SMI,    !F,  0xFF,  B,\n\t      .bits = {{\n\t\t\t.offset = 0,\n\t\t\t.mask = MI_BB_START_OPERAND_MASK,\n\t\t\t.expected = MI_BB_START_OPERAND_EXPECT,\n\t      }},\t\t\t\t\t\t       ),\n};\n\nstatic const struct drm_i915_cmd_descriptor noop_desc =\n\tCMD(MI_NOOP, SMI, F, 1, S);\n\n#undef CMD\n#undef SMI\n#undef S3D\n#undef S2D\n#undef SMFX\n#undef F\n#undef S\n#undef R\n#undef W\n#undef B\n\nstatic const struct drm_i915_cmd_table gen7_render_cmd_table[] = {\n\t{ gen7_common_cmds, ARRAY_SIZE(gen7_common_cmds) },\n\t{ gen7_render_cmds, ARRAY_SIZE(gen7_render_cmds) },\n};\n\nstatic const struct drm_i915_cmd_table hsw_render_ring_cmd_table[] = {\n\t{ gen7_common_cmds, ARRAY_SIZE(gen7_common_cmds) },\n\t{ gen7_render_cmds, ARRAY_SIZE(gen7_render_cmds) },\n\t{ hsw_render_cmds, ARRAY_SIZE(hsw_render_cmds) },\n};\n\nstatic const struct drm_i915_cmd_table gen7_video_cmd_table[] = {\n\t{ gen7_common_cmds, ARRAY_SIZE(gen7_common_cmds) },\n\t{ gen7_video_cmds, ARRAY_SIZE(gen7_video_cmds) },\n};\n\nstatic const struct drm_i915_cmd_table hsw_vebox_cmd_table[] = {\n\t{ gen7_common_cmds, ARRAY_SIZE(gen7_common_cmds) },\n\t{ gen7_vecs_cmds, ARRAY_SIZE(gen7_vecs_cmds) },\n};\n\nstatic const struct drm_i915_cmd_table gen7_blt_cmd_table[] = {\n\t{ gen7_common_cmds, ARRAY_SIZE(gen7_common_cmds) },\n\t{ gen7_blt_cmds, ARRAY_SIZE(gen7_blt_cmds) },\n};\n\nstatic const struct drm_i915_cmd_table hsw_blt_ring_cmd_table[] = {\n\t{ gen7_common_cmds, ARRAY_SIZE(gen7_common_cmds) },\n\t{ gen7_blt_cmds, ARRAY_SIZE(gen7_blt_cmds) },\n\t{ hsw_blt_cmds, ARRAY_SIZE(hsw_blt_cmds) },\n};\n\nstatic const struct drm_i915_cmd_table gen9_blt_cmd_table[] = {\n\t{ gen9_blt_cmds, ARRAY_SIZE(gen9_blt_cmds) },\n};\n\n\n \n\n \nstruct drm_i915_reg_descriptor {\n\ti915_reg_t addr;\n\tu32 mask;\n\tu32 value;\n};\n\n \n#define REG32(_reg, ...) \\\n\t{ .addr = (_reg), __VA_ARGS__ }\n\n#define REG32_IDX(_reg, idx) \\\n\t{ .addr = _reg(idx) }\n\n \n#define REG64(_reg) \\\n\t{ .addr = _reg }, \\\n\t{ .addr = _reg ## _UDW }\n\n#define REG64_IDX(_reg, idx) \\\n\t{ .addr = _reg(idx) }, \\\n\t{ .addr = _reg ## _UDW(idx) }\n\n#define REG64_BASE_IDX(_reg, base, idx) \\\n\t{ .addr = _reg(base, idx) }, \\\n\t{ .addr = _reg ## _UDW(base, idx) }\n\nstatic const struct drm_i915_reg_descriptor gen7_render_regs[] = {\n\tREG64(GPGPU_THREADS_DISPATCHED),\n\tREG64(HS_INVOCATION_COUNT),\n\tREG64(DS_INVOCATION_COUNT),\n\tREG64(IA_VERTICES_COUNT),\n\tREG64(IA_PRIMITIVES_COUNT),\n\tREG64(VS_INVOCATION_COUNT),\n\tREG64(GS_INVOCATION_COUNT),\n\tREG64(GS_PRIMITIVES_COUNT),\n\tREG64(CL_INVOCATION_COUNT),\n\tREG64(CL_PRIMITIVES_COUNT),\n\tREG64(PS_INVOCATION_COUNT),\n\tREG64(PS_DEPTH_COUNT),\n\tREG64_IDX(RING_TIMESTAMP, RENDER_RING_BASE),\n\tREG64_IDX(MI_PREDICATE_SRC0, RENDER_RING_BASE),\n\tREG64_IDX(MI_PREDICATE_SRC1, RENDER_RING_BASE),\n\tREG32(GEN7_3DPRIM_END_OFFSET),\n\tREG32(GEN7_3DPRIM_START_VERTEX),\n\tREG32(GEN7_3DPRIM_VERTEX_COUNT),\n\tREG32(GEN7_3DPRIM_INSTANCE_COUNT),\n\tREG32(GEN7_3DPRIM_START_INSTANCE),\n\tREG32(GEN7_3DPRIM_BASE_VERTEX),\n\tREG32(GEN7_GPGPU_DISPATCHDIMX),\n\tREG32(GEN7_GPGPU_DISPATCHDIMY),\n\tREG32(GEN7_GPGPU_DISPATCHDIMZ),\n\tREG64_IDX(RING_TIMESTAMP, BSD_RING_BASE),\n\tREG64_IDX(GEN7_SO_NUM_PRIMS_WRITTEN, 0),\n\tREG64_IDX(GEN7_SO_NUM_PRIMS_WRITTEN, 1),\n\tREG64_IDX(GEN7_SO_NUM_PRIMS_WRITTEN, 2),\n\tREG64_IDX(GEN7_SO_NUM_PRIMS_WRITTEN, 3),\n\tREG64_IDX(GEN7_SO_PRIM_STORAGE_NEEDED, 0),\n\tREG64_IDX(GEN7_SO_PRIM_STORAGE_NEEDED, 1),\n\tREG64_IDX(GEN7_SO_PRIM_STORAGE_NEEDED, 2),\n\tREG64_IDX(GEN7_SO_PRIM_STORAGE_NEEDED, 3),\n\tREG32(GEN7_SO_WRITE_OFFSET(0)),\n\tREG32(GEN7_SO_WRITE_OFFSET(1)),\n\tREG32(GEN7_SO_WRITE_OFFSET(2)),\n\tREG32(GEN7_SO_WRITE_OFFSET(3)),\n\tREG32(GEN7_L3SQCREG1),\n\tREG32(GEN7_L3CNTLREG2),\n\tREG32(GEN7_L3CNTLREG3),\n\tREG64_IDX(RING_TIMESTAMP, BLT_RING_BASE),\n};\n\nstatic const struct drm_i915_reg_descriptor hsw_render_regs[] = {\n\tREG64_BASE_IDX(GEN8_RING_CS_GPR, RENDER_RING_BASE, 0),\n\tREG64_BASE_IDX(GEN8_RING_CS_GPR, RENDER_RING_BASE, 1),\n\tREG64_BASE_IDX(GEN8_RING_CS_GPR, RENDER_RING_BASE, 2),\n\tREG64_BASE_IDX(GEN8_RING_CS_GPR, RENDER_RING_BASE, 3),\n\tREG64_BASE_IDX(GEN8_RING_CS_GPR, RENDER_RING_BASE, 4),\n\tREG64_BASE_IDX(GEN8_RING_CS_GPR, RENDER_RING_BASE, 5),\n\tREG64_BASE_IDX(GEN8_RING_CS_GPR, RENDER_RING_BASE, 6),\n\tREG64_BASE_IDX(GEN8_RING_CS_GPR, RENDER_RING_BASE, 7),\n\tREG64_BASE_IDX(GEN8_RING_CS_GPR, RENDER_RING_BASE, 8),\n\tREG64_BASE_IDX(GEN8_RING_CS_GPR, RENDER_RING_BASE, 9),\n\tREG64_BASE_IDX(GEN8_RING_CS_GPR, RENDER_RING_BASE, 10),\n\tREG64_BASE_IDX(GEN8_RING_CS_GPR, RENDER_RING_BASE, 11),\n\tREG64_BASE_IDX(GEN8_RING_CS_GPR, RENDER_RING_BASE, 12),\n\tREG64_BASE_IDX(GEN8_RING_CS_GPR, RENDER_RING_BASE, 13),\n\tREG64_BASE_IDX(GEN8_RING_CS_GPR, RENDER_RING_BASE, 14),\n\tREG64_BASE_IDX(GEN8_RING_CS_GPR, RENDER_RING_BASE, 15),\n\tREG32(HSW_SCRATCH1,\n\t      .mask = ~HSW_SCRATCH1_L3_DATA_ATOMICS_DISABLE,\n\t      .value = 0),\n\tREG32(HSW_ROW_CHICKEN3,\n\t      .mask = ~(HSW_ROW_CHICKEN3_L3_GLOBAL_ATOMICS_DISABLE << 16 |\n                        HSW_ROW_CHICKEN3_L3_GLOBAL_ATOMICS_DISABLE),\n\t      .value = 0),\n};\n\nstatic const struct drm_i915_reg_descriptor gen7_blt_regs[] = {\n\tREG64_IDX(RING_TIMESTAMP, RENDER_RING_BASE),\n\tREG64_IDX(RING_TIMESTAMP, BSD_RING_BASE),\n\tREG32(BCS_SWCTRL),\n\tREG64_IDX(RING_TIMESTAMP, BLT_RING_BASE),\n};\n\nstatic const struct drm_i915_reg_descriptor gen9_blt_regs[] = {\n\tREG64_IDX(RING_TIMESTAMP, RENDER_RING_BASE),\n\tREG64_IDX(RING_TIMESTAMP, BSD_RING_BASE),\n\tREG32(BCS_SWCTRL),\n\tREG64_IDX(RING_TIMESTAMP, BLT_RING_BASE),\n\tREG32_IDX(RING_CTX_TIMESTAMP, BLT_RING_BASE),\n\tREG64_BASE_IDX(GEN8_RING_CS_GPR, BLT_RING_BASE, 0),\n\tREG64_BASE_IDX(GEN8_RING_CS_GPR, BLT_RING_BASE, 1),\n\tREG64_BASE_IDX(GEN8_RING_CS_GPR, BLT_RING_BASE, 2),\n\tREG64_BASE_IDX(GEN8_RING_CS_GPR, BLT_RING_BASE, 3),\n\tREG64_BASE_IDX(GEN8_RING_CS_GPR, BLT_RING_BASE, 4),\n\tREG64_BASE_IDX(GEN8_RING_CS_GPR, BLT_RING_BASE, 5),\n\tREG64_BASE_IDX(GEN8_RING_CS_GPR, BLT_RING_BASE, 6),\n\tREG64_BASE_IDX(GEN8_RING_CS_GPR, BLT_RING_BASE, 7),\n\tREG64_BASE_IDX(GEN8_RING_CS_GPR, BLT_RING_BASE, 8),\n\tREG64_BASE_IDX(GEN8_RING_CS_GPR, BLT_RING_BASE, 9),\n\tREG64_BASE_IDX(GEN8_RING_CS_GPR, BLT_RING_BASE, 10),\n\tREG64_BASE_IDX(GEN8_RING_CS_GPR, BLT_RING_BASE, 11),\n\tREG64_BASE_IDX(GEN8_RING_CS_GPR, BLT_RING_BASE, 12),\n\tREG64_BASE_IDX(GEN8_RING_CS_GPR, BLT_RING_BASE, 13),\n\tREG64_BASE_IDX(GEN8_RING_CS_GPR, BLT_RING_BASE, 14),\n\tREG64_BASE_IDX(GEN8_RING_CS_GPR, BLT_RING_BASE, 15),\n};\n\n#undef REG64\n#undef REG32\n\nstruct drm_i915_reg_table {\n\tconst struct drm_i915_reg_descriptor *regs;\n\tint num_regs;\n};\n\nstatic const struct drm_i915_reg_table ivb_render_reg_tables[] = {\n\t{ gen7_render_regs, ARRAY_SIZE(gen7_render_regs) },\n};\n\nstatic const struct drm_i915_reg_table ivb_blt_reg_tables[] = {\n\t{ gen7_blt_regs, ARRAY_SIZE(gen7_blt_regs) },\n};\n\nstatic const struct drm_i915_reg_table hsw_render_reg_tables[] = {\n\t{ gen7_render_regs, ARRAY_SIZE(gen7_render_regs) },\n\t{ hsw_render_regs, ARRAY_SIZE(hsw_render_regs) },\n};\n\nstatic const struct drm_i915_reg_table hsw_blt_reg_tables[] = {\n\t{ gen7_blt_regs, ARRAY_SIZE(gen7_blt_regs) },\n};\n\nstatic const struct drm_i915_reg_table gen9_blt_reg_tables[] = {\n\t{ gen9_blt_regs, ARRAY_SIZE(gen9_blt_regs) },\n};\n\nstatic u32 gen7_render_get_cmd_length_mask(u32 cmd_header)\n{\n\tu32 client = cmd_header >> INSTR_CLIENT_SHIFT;\n\tu32 subclient =\n\t\t(cmd_header & INSTR_SUBCLIENT_MASK) >> INSTR_SUBCLIENT_SHIFT;\n\n\tif (client == INSTR_MI_CLIENT)\n\t\treturn 0x3F;\n\telse if (client == INSTR_RC_CLIENT) {\n\t\tif (subclient == INSTR_MEDIA_SUBCLIENT)\n\t\t\treturn 0xFFFF;\n\t\telse\n\t\t\treturn 0xFF;\n\t}\n\n\tDRM_DEBUG(\"CMD: Abnormal rcs cmd length! 0x%08X\\n\", cmd_header);\n\treturn 0;\n}\n\nstatic u32 gen7_bsd_get_cmd_length_mask(u32 cmd_header)\n{\n\tu32 client = cmd_header >> INSTR_CLIENT_SHIFT;\n\tu32 subclient =\n\t\t(cmd_header & INSTR_SUBCLIENT_MASK) >> INSTR_SUBCLIENT_SHIFT;\n\tu32 op = (cmd_header & INSTR_26_TO_24_MASK) >> INSTR_26_TO_24_SHIFT;\n\n\tif (client == INSTR_MI_CLIENT)\n\t\treturn 0x3F;\n\telse if (client == INSTR_RC_CLIENT) {\n\t\tif (subclient == INSTR_MEDIA_SUBCLIENT) {\n\t\t\tif (op == 6)\n\t\t\t\treturn 0xFFFF;\n\t\t\telse\n\t\t\t\treturn 0xFFF;\n\t\t} else\n\t\t\treturn 0xFF;\n\t}\n\n\tDRM_DEBUG(\"CMD: Abnormal bsd cmd length! 0x%08X\\n\", cmd_header);\n\treturn 0;\n}\n\nstatic u32 gen7_blt_get_cmd_length_mask(u32 cmd_header)\n{\n\tu32 client = cmd_header >> INSTR_CLIENT_SHIFT;\n\n\tif (client == INSTR_MI_CLIENT)\n\t\treturn 0x3F;\n\telse if (client == INSTR_BC_CLIENT)\n\t\treturn 0xFF;\n\n\tDRM_DEBUG(\"CMD: Abnormal blt cmd length! 0x%08X\\n\", cmd_header);\n\treturn 0;\n}\n\nstatic u32 gen9_blt_get_cmd_length_mask(u32 cmd_header)\n{\n\tu32 client = cmd_header >> INSTR_CLIENT_SHIFT;\n\n\tif (client == INSTR_MI_CLIENT || client == INSTR_BC_CLIENT)\n\t\treturn 0xFF;\n\n\tDRM_DEBUG(\"CMD: Abnormal blt cmd length! 0x%08X\\n\", cmd_header);\n\treturn 0;\n}\n\nstatic bool validate_cmds_sorted(const struct intel_engine_cs *engine,\n\t\t\t\t const struct drm_i915_cmd_table *cmd_tables,\n\t\t\t\t int cmd_table_count)\n{\n\tint i;\n\tbool ret = true;\n\n\tif (!cmd_tables || cmd_table_count == 0)\n\t\treturn true;\n\n\tfor (i = 0; i < cmd_table_count; i++) {\n\t\tconst struct drm_i915_cmd_table *table = &cmd_tables[i];\n\t\tu32 previous = 0;\n\t\tint j;\n\n\t\tfor (j = 0; j < table->count; j++) {\n\t\t\tconst struct drm_i915_cmd_descriptor *desc =\n\t\t\t\t&table->table[j];\n\t\t\tu32 curr = desc->cmd.value & desc->cmd.mask;\n\n\t\t\tif (curr < previous) {\n\t\t\t\tdrm_err(&engine->i915->drm,\n\t\t\t\t\t\"CMD: %s [%d] command table not sorted: \"\n\t\t\t\t\t\"table=%d entry=%d cmd=0x%08X prev=0x%08X\\n\",\n\t\t\t\t\tengine->name, engine->id,\n\t\t\t\t\ti, j, curr, previous);\n\t\t\t\tret = false;\n\t\t\t}\n\n\t\t\tprevious = curr;\n\t\t}\n\t}\n\n\treturn ret;\n}\n\nstatic bool check_sorted(const struct intel_engine_cs *engine,\n\t\t\t const struct drm_i915_reg_descriptor *reg_table,\n\t\t\t int reg_count)\n{\n\tint i;\n\tu32 previous = 0;\n\tbool ret = true;\n\n\tfor (i = 0; i < reg_count; i++) {\n\t\tu32 curr = i915_mmio_reg_offset(reg_table[i].addr);\n\n\t\tif (curr < previous) {\n\t\t\tdrm_err(&engine->i915->drm,\n\t\t\t\t\"CMD: %s [%d] register table not sorted: \"\n\t\t\t\t\"entry=%d reg=0x%08X prev=0x%08X\\n\",\n\t\t\t\tengine->name, engine->id,\n\t\t\t\ti, curr, previous);\n\t\t\tret = false;\n\t\t}\n\n\t\tprevious = curr;\n\t}\n\n\treturn ret;\n}\n\nstatic bool validate_regs_sorted(struct intel_engine_cs *engine)\n{\n\tint i;\n\tconst struct drm_i915_reg_table *table;\n\n\tfor (i = 0; i < engine->reg_table_count; i++) {\n\t\ttable = &engine->reg_tables[i];\n\t\tif (!check_sorted(engine, table->regs, table->num_regs))\n\t\t\treturn false;\n\t}\n\n\treturn true;\n}\n\nstruct cmd_node {\n\tconst struct drm_i915_cmd_descriptor *desc;\n\tstruct hlist_node node;\n};\n\n \nstatic inline u32 cmd_header_key(u32 x)\n{\n\tswitch (x >> INSTR_CLIENT_SHIFT) {\n\tdefault:\n\tcase INSTR_MI_CLIENT:\n\t\treturn x >> STD_MI_OPCODE_SHIFT;\n\tcase INSTR_RC_CLIENT:\n\t\treturn x >> STD_3D_OPCODE_SHIFT;\n\tcase INSTR_BC_CLIENT:\n\t\treturn x >> STD_2D_OPCODE_SHIFT;\n\t}\n}\n\nstatic int init_hash_table(struct intel_engine_cs *engine,\n\t\t\t   const struct drm_i915_cmd_table *cmd_tables,\n\t\t\t   int cmd_table_count)\n{\n\tint i, j;\n\n\thash_init(engine->cmd_hash);\n\n\tfor (i = 0; i < cmd_table_count; i++) {\n\t\tconst struct drm_i915_cmd_table *table = &cmd_tables[i];\n\n\t\tfor (j = 0; j < table->count; j++) {\n\t\t\tconst struct drm_i915_cmd_descriptor *desc =\n\t\t\t\t&table->table[j];\n\t\t\tstruct cmd_node *desc_node =\n\t\t\t\tkmalloc(sizeof(*desc_node), GFP_KERNEL);\n\n\t\t\tif (!desc_node)\n\t\t\t\treturn -ENOMEM;\n\n\t\t\tdesc_node->desc = desc;\n\t\t\thash_add(engine->cmd_hash, &desc_node->node,\n\t\t\t\t cmd_header_key(desc->cmd.value));\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic void fini_hash_table(struct intel_engine_cs *engine)\n{\n\tstruct hlist_node *tmp;\n\tstruct cmd_node *desc_node;\n\tint i;\n\n\thash_for_each_safe(engine->cmd_hash, i, tmp, desc_node, node) {\n\t\thash_del(&desc_node->node);\n\t\tkfree(desc_node);\n\t}\n}\n\n \nint intel_engine_init_cmd_parser(struct intel_engine_cs *engine)\n{\n\tconst struct drm_i915_cmd_table *cmd_tables;\n\tint cmd_table_count;\n\tint ret;\n\n\tif (GRAPHICS_VER(engine->i915) != 7 && !(GRAPHICS_VER(engine->i915) == 9 &&\n\t\t\t\t\t\t engine->class == COPY_ENGINE_CLASS))\n\t\treturn 0;\n\n\tswitch (engine->class) {\n\tcase RENDER_CLASS:\n\t\tif (IS_HASWELL(engine->i915)) {\n\t\t\tcmd_tables = hsw_render_ring_cmd_table;\n\t\t\tcmd_table_count =\n\t\t\t\tARRAY_SIZE(hsw_render_ring_cmd_table);\n\t\t} else {\n\t\t\tcmd_tables = gen7_render_cmd_table;\n\t\t\tcmd_table_count = ARRAY_SIZE(gen7_render_cmd_table);\n\t\t}\n\n\t\tif (IS_HASWELL(engine->i915)) {\n\t\t\tengine->reg_tables = hsw_render_reg_tables;\n\t\t\tengine->reg_table_count = ARRAY_SIZE(hsw_render_reg_tables);\n\t\t} else {\n\t\t\tengine->reg_tables = ivb_render_reg_tables;\n\t\t\tengine->reg_table_count = ARRAY_SIZE(ivb_render_reg_tables);\n\t\t}\n\t\tengine->get_cmd_length_mask = gen7_render_get_cmd_length_mask;\n\t\tbreak;\n\tcase VIDEO_DECODE_CLASS:\n\t\tcmd_tables = gen7_video_cmd_table;\n\t\tcmd_table_count = ARRAY_SIZE(gen7_video_cmd_table);\n\t\tengine->get_cmd_length_mask = gen7_bsd_get_cmd_length_mask;\n\t\tbreak;\n\tcase COPY_ENGINE_CLASS:\n\t\tengine->get_cmd_length_mask = gen7_blt_get_cmd_length_mask;\n\t\tif (GRAPHICS_VER(engine->i915) == 9) {\n\t\t\tcmd_tables = gen9_blt_cmd_table;\n\t\t\tcmd_table_count = ARRAY_SIZE(gen9_blt_cmd_table);\n\t\t\tengine->get_cmd_length_mask =\n\t\t\t\tgen9_blt_get_cmd_length_mask;\n\n\t\t\t \n\t\t\tengine->flags |= I915_ENGINE_REQUIRES_CMD_PARSER;\n\t\t} else if (IS_HASWELL(engine->i915)) {\n\t\t\tcmd_tables = hsw_blt_ring_cmd_table;\n\t\t\tcmd_table_count = ARRAY_SIZE(hsw_blt_ring_cmd_table);\n\t\t} else {\n\t\t\tcmd_tables = gen7_blt_cmd_table;\n\t\t\tcmd_table_count = ARRAY_SIZE(gen7_blt_cmd_table);\n\t\t}\n\n\t\tif (GRAPHICS_VER(engine->i915) == 9) {\n\t\t\tengine->reg_tables = gen9_blt_reg_tables;\n\t\t\tengine->reg_table_count =\n\t\t\t\tARRAY_SIZE(gen9_blt_reg_tables);\n\t\t} else if (IS_HASWELL(engine->i915)) {\n\t\t\tengine->reg_tables = hsw_blt_reg_tables;\n\t\t\tengine->reg_table_count = ARRAY_SIZE(hsw_blt_reg_tables);\n\t\t} else {\n\t\t\tengine->reg_tables = ivb_blt_reg_tables;\n\t\t\tengine->reg_table_count = ARRAY_SIZE(ivb_blt_reg_tables);\n\t\t}\n\t\tbreak;\n\tcase VIDEO_ENHANCEMENT_CLASS:\n\t\tcmd_tables = hsw_vebox_cmd_table;\n\t\tcmd_table_count = ARRAY_SIZE(hsw_vebox_cmd_table);\n\t\t \n\t\tengine->get_cmd_length_mask = gen7_bsd_get_cmd_length_mask;\n\t\tbreak;\n\tdefault:\n\t\tMISSING_CASE(engine->class);\n\t\tgoto out;\n\t}\n\n\tif (!validate_cmds_sorted(engine, cmd_tables, cmd_table_count)) {\n\t\tdrm_err(&engine->i915->drm,\n\t\t\t\"%s: command descriptions are not sorted\\n\",\n\t\t\tengine->name);\n\t\tgoto out;\n\t}\n\tif (!validate_regs_sorted(engine)) {\n\t\tdrm_err(&engine->i915->drm,\n\t\t\t\"%s: registers are not sorted\\n\", engine->name);\n\t\tgoto out;\n\t}\n\n\tret = init_hash_table(engine, cmd_tables, cmd_table_count);\n\tif (ret) {\n\t\tdrm_err(&engine->i915->drm,\n\t\t\t\"%s: initialised failed!\\n\", engine->name);\n\t\tfini_hash_table(engine);\n\t\tgoto out;\n\t}\n\n\tengine->flags |= I915_ENGINE_USING_CMD_PARSER;\n\nout:\n\tif (intel_engine_requires_cmd_parser(engine) &&\n\t    !intel_engine_using_cmd_parser(engine))\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\n \nvoid intel_engine_cleanup_cmd_parser(struct intel_engine_cs *engine)\n{\n\tif (!intel_engine_using_cmd_parser(engine))\n\t\treturn;\n\n\tfini_hash_table(engine);\n}\n\nstatic const struct drm_i915_cmd_descriptor*\nfind_cmd_in_table(struct intel_engine_cs *engine,\n\t\t  u32 cmd_header)\n{\n\tstruct cmd_node *desc_node;\n\n\thash_for_each_possible(engine->cmd_hash, desc_node, node,\n\t\t\t       cmd_header_key(cmd_header)) {\n\t\tconst struct drm_i915_cmd_descriptor *desc = desc_node->desc;\n\t\tif (((cmd_header ^ desc->cmd.value) & desc->cmd.mask) == 0)\n\t\t\treturn desc;\n\t}\n\n\treturn NULL;\n}\n\n \nstatic const struct drm_i915_cmd_descriptor*\nfind_cmd(struct intel_engine_cs *engine,\n\t u32 cmd_header,\n\t const struct drm_i915_cmd_descriptor *desc,\n\t struct drm_i915_cmd_descriptor *default_desc)\n{\n\tu32 mask;\n\n\tif (((cmd_header ^ desc->cmd.value) & desc->cmd.mask) == 0)\n\t\treturn desc;\n\n\tdesc = find_cmd_in_table(engine, cmd_header);\n\tif (desc)\n\t\treturn desc;\n\n\tmask = engine->get_cmd_length_mask(cmd_header);\n\tif (!mask)\n\t\treturn NULL;\n\n\tdefault_desc->cmd.value = cmd_header;\n\tdefault_desc->cmd.mask = ~0u << MIN_OPCODE_SHIFT;\n\tdefault_desc->length.mask = mask;\n\tdefault_desc->flags = CMD_DESC_SKIP;\n\treturn default_desc;\n}\n\nstatic const struct drm_i915_reg_descriptor *\n__find_reg(const struct drm_i915_reg_descriptor *table, int count, u32 addr)\n{\n\tint start = 0, end = count;\n\twhile (start < end) {\n\t\tint mid = start + (end - start) / 2;\n\t\tint ret = addr - i915_mmio_reg_offset(table[mid].addr);\n\t\tif (ret < 0)\n\t\t\tend = mid;\n\t\telse if (ret > 0)\n\t\t\tstart = mid + 1;\n\t\telse\n\t\t\treturn &table[mid];\n\t}\n\treturn NULL;\n}\n\nstatic const struct drm_i915_reg_descriptor *\nfind_reg(const struct intel_engine_cs *engine, u32 addr)\n{\n\tconst struct drm_i915_reg_table *table = engine->reg_tables;\n\tconst struct drm_i915_reg_descriptor *reg = NULL;\n\tint count = engine->reg_table_count;\n\n\tfor (; !reg && (count > 0); ++table, --count)\n\t\treg = __find_reg(table->regs, table->num_regs, addr);\n\n\treturn reg;\n}\n\n \nstatic u32 *copy_batch(struct drm_i915_gem_object *dst_obj,\n\t\t       struct drm_i915_gem_object *src_obj,\n\t\t       unsigned long offset, unsigned long length,\n\t\t       bool *needs_clflush_after)\n{\n\tunsigned int src_needs_clflush;\n\tunsigned int dst_needs_clflush;\n\tvoid *dst, *src;\n\tint ret;\n\n\tret = i915_gem_object_prepare_write(dst_obj, &dst_needs_clflush);\n\tif (ret)\n\t\treturn ERR_PTR(ret);\n\n\tdst = i915_gem_object_pin_map(dst_obj, I915_MAP_WB);\n\ti915_gem_object_finish_access(dst_obj);\n\tif (IS_ERR(dst))\n\t\treturn dst;\n\n\tret = i915_gem_object_prepare_read(src_obj, &src_needs_clflush);\n\tif (ret) {\n\t\ti915_gem_object_unpin_map(dst_obj);\n\t\treturn ERR_PTR(ret);\n\t}\n\n\tsrc = ERR_PTR(-ENODEV);\n\tif (src_needs_clflush && i915_has_memcpy_from_wc()) {\n\t\tsrc = i915_gem_object_pin_map(src_obj, I915_MAP_WC);\n\t\tif (!IS_ERR(src)) {\n\t\t\ti915_unaligned_memcpy_from_wc(dst,\n\t\t\t\t\t\t      src + offset,\n\t\t\t\t\t\t      length);\n\t\t\ti915_gem_object_unpin_map(src_obj);\n\t\t}\n\t}\n\tif (IS_ERR(src)) {\n\t\tunsigned long x, n, remain;\n\t\tvoid *ptr;\n\n\t\t \n\t\tremain = length;\n\t\tif (dst_needs_clflush & CLFLUSH_BEFORE)\n\t\t\tremain = round_up(remain,\n\t\t\t\t\t  boot_cpu_data.x86_clflush_size);\n\n\t\tptr = dst;\n\t\tx = offset_in_page(offset);\n\t\tfor (n = offset >> PAGE_SHIFT; remain; n++) {\n\t\t\tint len = min(remain, PAGE_SIZE - x);\n\n\t\t\tsrc = kmap_atomic(i915_gem_object_get_page(src_obj, n));\n\t\t\tif (src_needs_clflush)\n\t\t\t\tdrm_clflush_virt_range(src + x, len);\n\t\t\tmemcpy(ptr, src + x, len);\n\t\t\tkunmap_atomic(src);\n\n\t\t\tptr += len;\n\t\t\tremain -= len;\n\t\t\tx = 0;\n\t\t}\n\t}\n\n\ti915_gem_object_finish_access(src_obj);\n\n\tmemset32(dst + length, 0, (dst_obj->base.size - length) / sizeof(u32));\n\n\t \n\t*needs_clflush_after = dst_needs_clflush & CLFLUSH_AFTER;\n\n\treturn dst;\n}\n\nstatic inline bool cmd_desc_is(const struct drm_i915_cmd_descriptor * const desc,\n\t\t\t       const u32 cmd)\n{\n\treturn desc->cmd.value == (cmd & desc->cmd.mask);\n}\n\nstatic bool check_cmd(const struct intel_engine_cs *engine,\n\t\t      const struct drm_i915_cmd_descriptor *desc,\n\t\t      const u32 *cmd, u32 length)\n{\n\tif (desc->flags & CMD_DESC_SKIP)\n\t\treturn true;\n\n\tif (desc->flags & CMD_DESC_REJECT) {\n\t\tDRM_DEBUG(\"CMD: Rejected command: 0x%08X\\n\", *cmd);\n\t\treturn false;\n\t}\n\n\tif (desc->flags & CMD_DESC_REGISTER) {\n\t\t \n\t\tconst u32 step = desc->reg.step ? desc->reg.step : length;\n\t\tu32 offset;\n\n\t\tfor (offset = desc->reg.offset; offset < length;\n\t\t     offset += step) {\n\t\t\tconst u32 reg_addr = cmd[offset] & desc->reg.mask;\n\t\t\tconst struct drm_i915_reg_descriptor *reg =\n\t\t\t\tfind_reg(engine, reg_addr);\n\n\t\t\tif (!reg) {\n\t\t\t\tDRM_DEBUG(\"CMD: Rejected register 0x%08X in command: 0x%08X (%s)\\n\",\n\t\t\t\t\t  reg_addr, *cmd, engine->name);\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\t \n\t\t\tif (reg->mask) {\n\t\t\t\tif (cmd_desc_is(desc, MI_LOAD_REGISTER_MEM)) {\n\t\t\t\t\tDRM_DEBUG(\"CMD: Rejected LRM to masked register 0x%08X\\n\",\n\t\t\t\t\t\t  reg_addr);\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\tif (cmd_desc_is(desc, MI_LOAD_REGISTER_REG)) {\n\t\t\t\t\tDRM_DEBUG(\"CMD: Rejected LRR to masked register 0x%08X\\n\",\n\t\t\t\t\t\t  reg_addr);\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\tif (cmd_desc_is(desc, MI_LOAD_REGISTER_IMM(1)) &&\n\t\t\t\t    (offset + 2 > length ||\n\t\t\t\t     (cmd[offset + 1] & reg->mask) != reg->value)) {\n\t\t\t\t\tDRM_DEBUG(\"CMD: Rejected LRI to masked register 0x%08X\\n\",\n\t\t\t\t\t\t  reg_addr);\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tif (desc->flags & CMD_DESC_BITMASK) {\n\t\tint i;\n\n\t\tfor (i = 0; i < MAX_CMD_DESC_BITMASKS; i++) {\n\t\t\tu32 dword;\n\n\t\t\tif (desc->bits[i].mask == 0)\n\t\t\t\tbreak;\n\n\t\t\tif (desc->bits[i].condition_mask != 0) {\n\t\t\t\tu32 offset =\n\t\t\t\t\tdesc->bits[i].condition_offset;\n\t\t\t\tu32 condition = cmd[offset] &\n\t\t\t\t\tdesc->bits[i].condition_mask;\n\n\t\t\t\tif (condition == 0)\n\t\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (desc->bits[i].offset >= length) {\n\t\t\t\tDRM_DEBUG(\"CMD: Rejected command 0x%08X, too short to check bitmask (%s)\\n\",\n\t\t\t\t\t  *cmd, engine->name);\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tdword = cmd[desc->bits[i].offset] &\n\t\t\t\tdesc->bits[i].mask;\n\n\t\t\tif (dword != desc->bits[i].expected) {\n\t\t\t\tDRM_DEBUG(\"CMD: Rejected command 0x%08X for bitmask 0x%08X (exp=0x%08X act=0x%08X) (%s)\\n\",\n\t\t\t\t\t  *cmd,\n\t\t\t\t\t  desc->bits[i].mask,\n\t\t\t\t\t  desc->bits[i].expected,\n\t\t\t\t\t  dword, engine->name);\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn true;\n}\n\nstatic int check_bbstart(u32 *cmd, u32 offset, u32 length,\n\t\t\t u32 batch_length,\n\t\t\t u64 batch_addr,\n\t\t\t u64 shadow_addr,\n\t\t\t const unsigned long *jump_whitelist)\n{\n\tu64 jump_offset, jump_target;\n\tu32 target_cmd_offset, target_cmd_index;\n\n\t \n\tif (!jump_whitelist) {\n\t\tDRM_DEBUG(\"CMD: Rejecting BB_START for ggtt based submission\\n\");\n\t\treturn -EACCES;\n\t}\n\n\tif (length != 3) {\n\t\tDRM_DEBUG(\"CMD: Recursive BB_START with bad length(%u)\\n\",\n\t\t\t  length);\n\t\treturn -EINVAL;\n\t}\n\n\tjump_target = *(u64 *)(cmd + 1);\n\tjump_offset = jump_target - batch_addr;\n\n\t \n\tif (jump_offset >= batch_length) {\n\t\tDRM_DEBUG(\"CMD: BB_START to 0x%llx jumps out of BB\\n\",\n\t\t\t  jump_target);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\ttarget_cmd_offset = lower_32_bits(jump_offset);\n\ttarget_cmd_index = target_cmd_offset / sizeof(u32);\n\n\t*(u64 *)(cmd + 1) = shadow_addr + target_cmd_offset;\n\n\tif (target_cmd_index == offset)\n\t\treturn 0;\n\n\tif (IS_ERR(jump_whitelist))\n\t\treturn PTR_ERR(jump_whitelist);\n\n\tif (!test_bit(target_cmd_index, jump_whitelist)) {\n\t\tDRM_DEBUG(\"CMD: BB_START to 0x%llx not a previously executed cmd\\n\",\n\t\t\t  jump_target);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic unsigned long *alloc_whitelist(u32 batch_length)\n{\n\tunsigned long *jmp;\n\n\t \n\n\t \n\tjmp = bitmap_zalloc(DIV_ROUND_UP(batch_length, sizeof(u32)),\n\t\t\t    GFP_KERNEL | __GFP_RETRY_MAYFAIL | __GFP_NOWARN);\n\tif (!jmp)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\treturn jmp;\n}\n\n#define LENGTH_BIAS 2\n\n \n\nint intel_engine_cmd_parser(struct intel_engine_cs *engine,\n\t\t\t    struct i915_vma *batch,\n\t\t\t    unsigned long batch_offset,\n\t\t\t    unsigned long batch_length,\n\t\t\t    struct i915_vma *shadow,\n\t\t\t    bool trampoline)\n{\n\tu32 *cmd, *batch_end, offset = 0;\n\tstruct drm_i915_cmd_descriptor default_desc = noop_desc;\n\tconst struct drm_i915_cmd_descriptor *desc = &default_desc;\n\tbool needs_clflush_after = false;\n\tunsigned long *jump_whitelist;\n\tu64 batch_addr, shadow_addr;\n\tint ret = 0;\n\n\tGEM_BUG_ON(!IS_ALIGNED(batch_offset, sizeof(*cmd)));\n\tGEM_BUG_ON(!IS_ALIGNED(batch_length, sizeof(*cmd)));\n\tGEM_BUG_ON(range_overflows_t(u64, batch_offset, batch_length,\n\t\t\t\t     batch->size));\n\tGEM_BUG_ON(!batch_length);\n\n\tcmd = copy_batch(shadow->obj, batch->obj,\n\t\t\t batch_offset, batch_length,\n\t\t\t &needs_clflush_after);\n\tif (IS_ERR(cmd)) {\n\t\tDRM_DEBUG(\"CMD: Failed to copy batch\\n\");\n\t\treturn PTR_ERR(cmd);\n\t}\n\n\tjump_whitelist = NULL;\n\tif (!trampoline)\n\t\t \n\t\tjump_whitelist = alloc_whitelist(batch_length);\n\n\tshadow_addr = gen8_canonical_addr(i915_vma_offset(shadow));\n\tbatch_addr = gen8_canonical_addr(i915_vma_offset(batch) + batch_offset);\n\n\t \n\tbatch_end = cmd + batch_length / sizeof(*batch_end);\n\tdo {\n\t\tu32 length;\n\n\t\tif (*cmd == MI_BATCH_BUFFER_END)\n\t\t\tbreak;\n\n\t\tdesc = find_cmd(engine, *cmd, desc, &default_desc);\n\t\tif (!desc) {\n\t\t\tDRM_DEBUG(\"CMD: Unrecognized command: 0x%08X\\n\", *cmd);\n\t\t\tret = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (desc->flags & CMD_DESC_FIXED)\n\t\t\tlength = desc->length.fixed;\n\t\telse\n\t\t\tlength = (*cmd & desc->length.mask) + LENGTH_BIAS;\n\n\t\tif ((batch_end - cmd) < length) {\n\t\t\tDRM_DEBUG(\"CMD: Command length exceeds batch length: 0x%08X length=%u batchlen=%td\\n\",\n\t\t\t\t  *cmd,\n\t\t\t\t  length,\n\t\t\t\t  batch_end - cmd);\n\t\t\tret = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (!check_cmd(engine, desc, cmd, length)) {\n\t\t\tret = -EACCES;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (cmd_desc_is(desc, MI_BATCH_BUFFER_START)) {\n\t\t\tret = check_bbstart(cmd, offset, length, batch_length,\n\t\t\t\t\t    batch_addr, shadow_addr,\n\t\t\t\t\t    jump_whitelist);\n\t\t\tbreak;\n\t\t}\n\n\t\tif (!IS_ERR_OR_NULL(jump_whitelist))\n\t\t\t__set_bit(offset, jump_whitelist);\n\n\t\tcmd += length;\n\t\toffset += length;\n\t\tif  (cmd >= batch_end) {\n\t\t\tDRM_DEBUG(\"CMD: Got to the end of the buffer w/o a BBE cmd!\\n\");\n\t\t\tret = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\t} while (1);\n\n\tif (trampoline) {\n\t\t \n\t\t*batch_end = MI_BATCH_BUFFER_END;\n\n\t\tif (ret) {\n\t\t\t \n\t\t\tcmd = page_mask_bits(shadow->obj->mm.mapping);\n\t\t\t*cmd = MI_BATCH_BUFFER_END;\n\n\t\t\t \n\t\t\tif (ret == -EACCES) {\n\t\t\t\tunsigned int flags;\n\n\t\t\t\tflags = MI_BATCH_NON_SECURE_I965;\n\t\t\t\tif (IS_HASWELL(engine->i915))\n\t\t\t\t\tflags = MI_BATCH_NON_SECURE_HSW;\n\n\t\t\t\tGEM_BUG_ON(!IS_GRAPHICS_VER(engine->i915, 6, 7));\n\t\t\t\t__gen6_emit_bb_start(batch_end,\n\t\t\t\t\t\t     batch_addr,\n\t\t\t\t\t\t     flags);\n\n\t\t\t\tret = 0;  \n\t\t\t}\n\t\t}\n\t}\n\n\ti915_gem_object_flush_map(shadow->obj);\n\n\tif (!IS_ERR_OR_NULL(jump_whitelist))\n\t\tkfree(jump_whitelist);\n\ti915_gem_object_unpin_map(shadow->obj);\n\treturn ret;\n}\n\n \nint i915_cmd_parser_get_version(struct drm_i915_private *dev_priv)\n{\n\tstruct intel_engine_cs *engine;\n\tbool active = false;\n\n\t \n\tfor_each_uabi_engine(engine, dev_priv) {\n\t\tif (intel_engine_using_cmd_parser(engine)) {\n\t\t\tactive = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (!active)\n\t\treturn 0;\n\n\t \n\treturn 10;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}