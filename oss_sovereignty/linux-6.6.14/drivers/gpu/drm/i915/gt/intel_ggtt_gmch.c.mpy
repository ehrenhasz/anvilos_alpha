{
  "module_name": "intel_ggtt_gmch.c",
  "hash_id": "882f5fff90d19148affe4117985a1555a02d5cc8cbcbbab644ee76a2c51d1111",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/i915/gt/intel_ggtt_gmch.c",
  "human_readable_source": "\n \n\n#include \"intel_ggtt_gmch.h\"\n\n#include <drm/intel-gtt.h>\n\n#include <linux/agp_backend.h>\n\n#include \"i915_drv.h\"\n#include \"i915_utils.h\"\n#include \"intel_gtt.h\"\n#include \"intel_gt_regs.h\"\n#include \"intel_gt.h\"\n\nstatic void gmch_ggtt_insert_page(struct i915_address_space *vm,\n\t\t\t\t  dma_addr_t addr,\n\t\t\t\t  u64 offset,\n\t\t\t\t  unsigned int pat_index,\n\t\t\t\t  u32 unused)\n{\n\tunsigned int flags = (pat_index == I915_CACHE_NONE) ?\n\t\tAGP_USER_MEMORY : AGP_USER_CACHED_MEMORY;\n\n\tintel_gmch_gtt_insert_page(addr, offset >> PAGE_SHIFT, flags);\n}\n\nstatic void gmch_ggtt_insert_entries(struct i915_address_space *vm,\n\t\t\t\t     struct i915_vma_resource *vma_res,\n\t\t\t\t     unsigned int pat_index,\n\t\t\t\t     u32 unused)\n{\n\tunsigned int flags = (pat_index == I915_CACHE_NONE) ?\n\t\tAGP_USER_MEMORY : AGP_USER_CACHED_MEMORY;\n\n\tintel_gmch_gtt_insert_sg_entries(vma_res->bi.pages, vma_res->start >> PAGE_SHIFT,\n\t\t\t\t\t flags);\n}\n\nstatic void gmch_ggtt_invalidate(struct i915_ggtt *ggtt)\n{\n\tintel_gmch_gtt_flush();\n}\n\nstatic void gmch_ggtt_clear_range(struct i915_address_space *vm,\n\t\t\t\t  u64 start, u64 length)\n{\n\tintel_gmch_gtt_clear_range(start >> PAGE_SHIFT, length >> PAGE_SHIFT);\n}\n\nstatic void gmch_ggtt_remove(struct i915_address_space *vm)\n{\n\tintel_gmch_remove();\n}\n\n \nstatic bool needs_idle_maps(struct drm_i915_private *i915)\n{\n\t \n\tif (!i915_vtd_active(i915))\n\t\treturn false;\n\n\tif (GRAPHICS_VER(i915) == 5 && IS_MOBILE(i915))\n\t\treturn true;\n\n\treturn false;\n}\n\nint intel_ggtt_gmch_probe(struct i915_ggtt *ggtt)\n{\n\tstruct drm_i915_private *i915 = ggtt->vm.i915;\n\tphys_addr_t gmadr_base;\n\tint ret;\n\n\tret = intel_gmch_probe(i915->gmch.pdev, to_pci_dev(i915->drm.dev), NULL);\n\tif (!ret) {\n\t\tdrm_err(&i915->drm, \"failed to set up gmch\\n\");\n\t\treturn -EIO;\n\t}\n\n\tintel_gmch_gtt_get(&ggtt->vm.total, &gmadr_base, &ggtt->mappable_end);\n\n\tggtt->gmadr = DEFINE_RES_MEM(gmadr_base, ggtt->mappable_end);\n\n\tggtt->vm.alloc_pt_dma = alloc_pt_dma;\n\tggtt->vm.alloc_scratch_dma = alloc_pt_dma;\n\n\tif (needs_idle_maps(i915)) {\n\t\tdrm_notice(&i915->drm,\n\t\t\t   \"Flushing DMA requests before IOMMU unmaps; performance may be degraded\\n\");\n\t\tggtt->do_idle_maps = true;\n\t}\n\n\tggtt->vm.insert_page = gmch_ggtt_insert_page;\n\tggtt->vm.insert_entries = gmch_ggtt_insert_entries;\n\tggtt->vm.clear_range = gmch_ggtt_clear_range;\n\tggtt->vm.scratch_range = gmch_ggtt_clear_range;\n\tggtt->vm.cleanup = gmch_ggtt_remove;\n\n\tggtt->invalidate = gmch_ggtt_invalidate;\n\n\tggtt->vm.vma_ops.bind_vma    = intel_ggtt_bind_vma;\n\tggtt->vm.vma_ops.unbind_vma  = intel_ggtt_unbind_vma;\n\n\tif (unlikely(ggtt->do_idle_maps))\n\t\tdrm_notice(&i915->drm,\n\t\t\t   \"Applying Ironlake quirks for intel_iommu\\n\");\n\n\treturn 0;\n}\n\nint intel_ggtt_gmch_enable_hw(struct drm_i915_private *i915)\n{\n\tif (!intel_gmch_enable_gtt())\n\t\treturn -EIO;\n\n\treturn 0;\n}\n\nvoid intel_ggtt_gmch_flush(void)\n{\n\tintel_gmch_gtt_flush();\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}