{
  "module_name": "intel_rc6.c",
  "hash_id": "a95188dd1f0ceee4ee403a2a6a6efcfff034fd9f12836c565f01addd1b55aaf5",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/i915/gt/intel_rc6.c",
  "human_readable_source": "\n \n\n#include <linux/pm_runtime.h>\n#include <linux/string_helpers.h>\n\n#include \"gem/i915_gem_region.h\"\n#include \"i915_drv.h\"\n#include \"i915_reg.h\"\n#include \"i915_vgpu.h\"\n#include \"intel_engine_regs.h\"\n#include \"intel_gt.h\"\n#include \"intel_gt_pm.h\"\n#include \"intel_gt_regs.h\"\n#include \"intel_pcode.h\"\n#include \"intel_rc6.h\"\n\n \n\nstatic struct intel_gt *rc6_to_gt(struct intel_rc6 *rc6)\n{\n\treturn container_of(rc6, struct intel_gt, rc6);\n}\n\nstatic struct intel_uncore *rc6_to_uncore(struct intel_rc6 *rc)\n{\n\treturn rc6_to_gt(rc)->uncore;\n}\n\nstatic struct drm_i915_private *rc6_to_i915(struct intel_rc6 *rc)\n{\n\treturn rc6_to_gt(rc)->i915;\n}\n\nstatic void gen11_rc6_enable(struct intel_rc6 *rc6)\n{\n\tstruct intel_gt *gt = rc6_to_gt(rc6);\n\tstruct intel_uncore *uncore = gt->uncore;\n\tstruct intel_engine_cs *engine;\n\tenum intel_engine_id id;\n\tu32 pg_enable;\n\tint i;\n\n\t \n\tif (!intel_uc_uses_guc_rc(&gt->uc)) {\n\t\t \n\t\tintel_uncore_write_fw(uncore, GEN6_RC6_WAKE_RATE_LIMIT, 54 << 16 | 85);\n\t\tintel_uncore_write_fw(uncore, GEN10_MEDIA_WAKE_RATE_LIMIT, 150);\n\n\t\tintel_uncore_write_fw(uncore, GEN6_RC_EVALUATION_INTERVAL, 125000);  \n\t\tintel_uncore_write_fw(uncore, GEN6_RC_IDLE_HYSTERSIS, 25);  \n\t\tfor_each_engine(engine, rc6_to_gt(rc6), id)\n\t\t\tintel_uncore_write_fw(uncore, RING_MAX_IDLE(engine->mmio_base), 10);\n\n\t\tintel_uncore_write_fw(uncore, GUC_MAX_IDLE_COUNT, 0xA);\n\n\t\tintel_uncore_write_fw(uncore, GEN6_RC_SLEEP, 0);\n\n\t\tintel_uncore_write_fw(uncore, GEN6_RC6_THRESHOLD, 50000);  \n\t}\n\n\t \n\tintel_uncore_write_fw(uncore, GEN9_MEDIA_PG_IDLE_HYSTERESIS, 60);\n\tintel_uncore_write_fw(uncore, GEN9_RENDER_PG_IDLE_HYSTERESIS, 60);\n\n\t \n\tif (!intel_guc_rc_enable(&gt->uc.guc))\n\t\trc6->ctl_enable = GEN6_RC_CTL_RC6_ENABLE;\n\telse\n\t\trc6->ctl_enable =\n\t\t\tGEN6_RC_CTL_HW_ENABLE |\n\t\t\tGEN6_RC_CTL_RC6_ENABLE |\n\t\t\tGEN6_RC_CTL_EI_MODE(1);\n\n\t \n\tif (IS_METEORLAKE(gt->i915) ||\n\t    IS_DG2_GRAPHICS_STEP(gt->i915, G10, STEP_A0, STEP_C0) ||\n\t    IS_DG2_GRAPHICS_STEP(gt->i915, G11, STEP_A0, STEP_B0))\n\t\tpg_enable =\n\t\t\tGEN9_MEDIA_PG_ENABLE |\n\t\t\tGEN11_MEDIA_SAMPLER_PG_ENABLE;\n\telse\n\t\tpg_enable =\n\t\t\tGEN9_RENDER_PG_ENABLE |\n\t\t\tGEN9_MEDIA_PG_ENABLE |\n\t\t\tGEN11_MEDIA_SAMPLER_PG_ENABLE;\n\n\tif (GRAPHICS_VER(gt->i915) >= 12) {\n\t\tfor (i = 0; i < I915_MAX_VCS; i++)\n\t\t\tif (HAS_ENGINE(gt, _VCS(i)))\n\t\t\t\tpg_enable |= (VDN_HCP_POWERGATE_ENABLE(i) |\n\t\t\t\t\t      VDN_MFX_POWERGATE_ENABLE(i));\n\t}\n\n\tintel_uncore_write_fw(uncore, GEN9_PG_ENABLE, pg_enable);\n}\n\nstatic void gen9_rc6_enable(struct intel_rc6 *rc6)\n{\n\tstruct intel_uncore *uncore = rc6_to_uncore(rc6);\n\tstruct intel_engine_cs *engine;\n\tenum intel_engine_id id;\n\n\t \n\tif (GRAPHICS_VER(rc6_to_i915(rc6)) >= 11) {\n\t\tintel_uncore_write_fw(uncore, GEN6_RC6_WAKE_RATE_LIMIT, 54 << 16 | 85);\n\t\tintel_uncore_write_fw(uncore, GEN10_MEDIA_WAKE_RATE_LIMIT, 150);\n\t} else if (IS_SKYLAKE(rc6_to_i915(rc6))) {\n\t\t \n\t\tintel_uncore_write_fw(uncore, GEN6_RC6_WAKE_RATE_LIMIT, 108 << 16);\n\t} else {\n\t\tintel_uncore_write_fw(uncore, GEN6_RC6_WAKE_RATE_LIMIT, 54 << 16);\n\t}\n\n\tintel_uncore_write_fw(uncore, GEN6_RC_EVALUATION_INTERVAL, 125000);  \n\tintel_uncore_write_fw(uncore, GEN6_RC_IDLE_HYSTERSIS, 25);  \n\tfor_each_engine(engine, rc6_to_gt(rc6), id)\n\t\tintel_uncore_write_fw(uncore, RING_MAX_IDLE(engine->mmio_base), 10);\n\n\tintel_uncore_write_fw(uncore, GUC_MAX_IDLE_COUNT, 0xA);\n\n\tintel_uncore_write_fw(uncore, GEN6_RC_SLEEP, 0);\n\n\t \n\tintel_uncore_write_fw(uncore, GEN9_MEDIA_PG_IDLE_HYSTERESIS, 250);\n\tintel_uncore_write_fw(uncore, GEN9_RENDER_PG_IDLE_HYSTERESIS, 250);\n\n\t \n\tintel_uncore_write_fw(uncore, GEN6_RC6_THRESHOLD, 37500);  \n\n\trc6->ctl_enable =\n\t\tGEN6_RC_CTL_HW_ENABLE |\n\t\tGEN6_RC_CTL_RC6_ENABLE |\n\t\tGEN6_RC_CTL_EI_MODE(1);\n\n\t \n\tif (!NEEDS_WaRsDisableCoarsePowerGating(rc6_to_i915(rc6)))\n\t\tintel_uncore_write_fw(uncore, GEN9_PG_ENABLE,\n\t\t\t\t      GEN9_RENDER_PG_ENABLE | GEN9_MEDIA_PG_ENABLE);\n}\n\nstatic void gen8_rc6_enable(struct intel_rc6 *rc6)\n{\n\tstruct intel_uncore *uncore = rc6_to_uncore(rc6);\n\tstruct intel_engine_cs *engine;\n\tenum intel_engine_id id;\n\n\t \n\tintel_uncore_write_fw(uncore, GEN6_RC6_WAKE_RATE_LIMIT, 40 << 16);\n\tintel_uncore_write_fw(uncore, GEN6_RC_EVALUATION_INTERVAL, 125000);  \n\tintel_uncore_write_fw(uncore, GEN6_RC_IDLE_HYSTERSIS, 25);  \n\tfor_each_engine(engine, rc6_to_gt(rc6), id)\n\t\tintel_uncore_write_fw(uncore, RING_MAX_IDLE(engine->mmio_base), 10);\n\tintel_uncore_write_fw(uncore, GEN6_RC_SLEEP, 0);\n\tintel_uncore_write_fw(uncore, GEN6_RC6_THRESHOLD, 625);  \n\n\t \n\trc6->ctl_enable =\n\t    GEN6_RC_CTL_HW_ENABLE |\n\t    GEN7_RC_CTL_TO_MODE |\n\t    GEN6_RC_CTL_RC6_ENABLE;\n}\n\nstatic void gen6_rc6_enable(struct intel_rc6 *rc6)\n{\n\tstruct intel_uncore *uncore = rc6_to_uncore(rc6);\n\tstruct drm_i915_private *i915 = rc6_to_i915(rc6);\n\tstruct intel_engine_cs *engine;\n\tenum intel_engine_id id;\n\tu32 rc6vids, rc6_mask;\n\tint ret;\n\n\tintel_uncore_write_fw(uncore, GEN6_RC1_WAKE_RATE_LIMIT, 1000 << 16);\n\tintel_uncore_write_fw(uncore, GEN6_RC6_WAKE_RATE_LIMIT, 40 << 16 | 30);\n\tintel_uncore_write_fw(uncore, GEN6_RC6pp_WAKE_RATE_LIMIT, 30);\n\tintel_uncore_write_fw(uncore, GEN6_RC_EVALUATION_INTERVAL, 125000);\n\tintel_uncore_write_fw(uncore, GEN6_RC_IDLE_HYSTERSIS, 25);\n\n\tfor_each_engine(engine, rc6_to_gt(rc6), id)\n\t\tintel_uncore_write_fw(uncore, RING_MAX_IDLE(engine->mmio_base), 10);\n\n\tintel_uncore_write_fw(uncore, GEN6_RC_SLEEP, 0);\n\tintel_uncore_write_fw(uncore, GEN6_RC1e_THRESHOLD, 1000);\n\tintel_uncore_write_fw(uncore, GEN6_RC6_THRESHOLD, 50000);\n\tintel_uncore_write_fw(uncore, GEN6_RC6p_THRESHOLD, 150000);\n\tintel_uncore_write_fw(uncore, GEN6_RC6pp_THRESHOLD, 64000);  \n\n\t \n\trc6_mask = GEN6_RC_CTL_RC6_ENABLE;\n\tif (HAS_RC6p(i915))\n\t\trc6_mask |= GEN6_RC_CTL_RC6p_ENABLE;\n\tif (HAS_RC6pp(i915))\n\t\trc6_mask |= GEN6_RC_CTL_RC6pp_ENABLE;\n\trc6->ctl_enable =\n\t    rc6_mask |\n\t    GEN6_RC_CTL_EI_MODE(1) |\n\t    GEN6_RC_CTL_HW_ENABLE;\n\n\trc6vids = 0;\n\tret = snb_pcode_read(rc6_to_gt(rc6)->uncore, GEN6_PCODE_READ_RC6VIDS, &rc6vids, NULL);\n\tif (GRAPHICS_VER(i915) == 6 && ret) {\n\t\tdrm_dbg(&i915->drm, \"Couldn't check for BIOS workaround\\n\");\n\t} else if (GRAPHICS_VER(i915) == 6 &&\n\t\t   (GEN6_DECODE_RC6_VID(rc6vids & 0xff) < 450)) {\n\t\tdrm_dbg(&i915->drm,\n\t\t\t\"You should update your BIOS. Correcting minimum rc6 voltage (%dmV->%dmV)\\n\",\n\t\t\tGEN6_DECODE_RC6_VID(rc6vids & 0xff), 450);\n\t\trc6vids &= 0xffff00;\n\t\trc6vids |= GEN6_ENCODE_RC6_VID(450);\n\t\tret = snb_pcode_write(rc6_to_gt(rc6)->uncore, GEN6_PCODE_WRITE_RC6VIDS, rc6vids);\n\t\tif (ret)\n\t\t\tdrm_err(&i915->drm,\n\t\t\t\t\"Couldn't fix incorrect rc6 voltage\\n\");\n\t}\n}\n\n \nstatic int chv_rc6_init(struct intel_rc6 *rc6)\n{\n\tstruct intel_uncore *uncore = rc6_to_uncore(rc6);\n\tstruct drm_i915_private *i915 = rc6_to_i915(rc6);\n\tresource_size_t pctx_paddr, paddr;\n\tresource_size_t pctx_size = 32 * SZ_1K;\n\tu32 pcbr;\n\n\tpcbr = intel_uncore_read(uncore, VLV_PCBR);\n\tif ((pcbr >> VLV_PCBR_ADDR_SHIFT) == 0) {\n\t\tdrm_dbg(&i915->drm, \"BIOS didn't set up PCBR, fixing up\\n\");\n\t\tpaddr = i915->dsm.stolen.end + 1 - pctx_size;\n\t\tGEM_BUG_ON(paddr > U32_MAX);\n\n\t\tpctx_paddr = (paddr & ~4095);\n\t\tintel_uncore_write(uncore, VLV_PCBR, pctx_paddr);\n\t}\n\n\treturn 0;\n}\n\nstatic int vlv_rc6_init(struct intel_rc6 *rc6)\n{\n\tstruct drm_i915_private *i915 = rc6_to_i915(rc6);\n\tstruct intel_uncore *uncore = rc6_to_uncore(rc6);\n\tstruct drm_i915_gem_object *pctx;\n\tresource_size_t pctx_paddr;\n\tresource_size_t pctx_size = 24 * SZ_1K;\n\tu32 pcbr;\n\n\tpcbr = intel_uncore_read(uncore, VLV_PCBR);\n\tif (pcbr) {\n\t\t \n\t\tresource_size_t pcbr_offset;\n\n\t\tpcbr_offset = (pcbr & ~4095) - i915->dsm.stolen.start;\n\t\tpctx = i915_gem_object_create_region_at(i915->mm.stolen_region,\n\t\t\t\t\t\t\tpcbr_offset,\n\t\t\t\t\t\t\tpctx_size,\n\t\t\t\t\t\t\t0);\n\t\tif (IS_ERR(pctx))\n\t\t\treturn PTR_ERR(pctx);\n\n\t\tgoto out;\n\t}\n\n\tdrm_dbg(&i915->drm, \"BIOS didn't set up PCBR, fixing up\\n\");\n\n\t \n\tpctx = i915_gem_object_create_stolen(i915, pctx_size);\n\tif (IS_ERR(pctx)) {\n\t\tdrm_dbg(&i915->drm,\n\t\t\t\"not enough stolen space for PCTX, disabling\\n\");\n\t\treturn PTR_ERR(pctx);\n\t}\n\n\tGEM_BUG_ON(range_overflows_end_t(u64,\n\t\t\t\t\t i915->dsm.stolen.start,\n\t\t\t\t\t pctx->stolen->start,\n\t\t\t\t\t U32_MAX));\n\tpctx_paddr = i915->dsm.stolen.start + pctx->stolen->start;\n\tintel_uncore_write(uncore, VLV_PCBR, pctx_paddr);\n\nout:\n\trc6->pctx = pctx;\n\treturn 0;\n}\n\nstatic void chv_rc6_enable(struct intel_rc6 *rc6)\n{\n\tstruct intel_uncore *uncore = rc6_to_uncore(rc6);\n\tstruct intel_engine_cs *engine;\n\tenum intel_engine_id id;\n\n\t \n\tintel_uncore_write_fw(uncore, GEN6_RC6_WAKE_RATE_LIMIT, 40 << 16);\n\tintel_uncore_write_fw(uncore, GEN6_RC_EVALUATION_INTERVAL, 125000);  \n\tintel_uncore_write_fw(uncore, GEN6_RC_IDLE_HYSTERSIS, 25);  \n\n\tfor_each_engine(engine, rc6_to_gt(rc6), id)\n\t\tintel_uncore_write_fw(uncore, RING_MAX_IDLE(engine->mmio_base), 10);\n\tintel_uncore_write_fw(uncore, GEN6_RC_SLEEP, 0);\n\n\t \n\tintel_uncore_write_fw(uncore, GEN6_RC6_THRESHOLD, 0x186);\n\n\t \n\tintel_uncore_write_fw(uncore, VLV_COUNTER_CONTROL,\n\t\t\t      _MASKED_BIT_ENABLE(VLV_COUNT_RANGE_HIGH |\n\t\t\t\t\t\t VLV_MEDIA_RC6_COUNT_EN |\n\t\t\t\t\t\t VLV_RENDER_RC6_COUNT_EN));\n\n\t \n\trc6->ctl_enable = GEN7_RC_CTL_TO_MODE;\n}\n\nstatic void vlv_rc6_enable(struct intel_rc6 *rc6)\n{\n\tstruct intel_uncore *uncore = rc6_to_uncore(rc6);\n\tstruct intel_engine_cs *engine;\n\tenum intel_engine_id id;\n\n\tintel_uncore_write_fw(uncore, GEN6_RC6_WAKE_RATE_LIMIT, 0x00280000);\n\tintel_uncore_write_fw(uncore, GEN6_RC_EVALUATION_INTERVAL, 125000);\n\tintel_uncore_write_fw(uncore, GEN6_RC_IDLE_HYSTERSIS, 25);\n\n\tfor_each_engine(engine, rc6_to_gt(rc6), id)\n\t\tintel_uncore_write_fw(uncore, RING_MAX_IDLE(engine->mmio_base), 10);\n\n\tintel_uncore_write_fw(uncore, GEN6_RC6_THRESHOLD, 0x557);\n\n\t \n\tintel_uncore_write_fw(uncore, VLV_COUNTER_CONTROL,\n\t\t\t      _MASKED_BIT_ENABLE(VLV_COUNT_RANGE_HIGH |\n\t\t\t\t\t\t VLV_MEDIA_RC0_COUNT_EN |\n\t\t\t\t\t\t VLV_RENDER_RC0_COUNT_EN |\n\t\t\t\t\t\t VLV_MEDIA_RC6_COUNT_EN |\n\t\t\t\t\t\t VLV_RENDER_RC6_COUNT_EN));\n\n\trc6->ctl_enable =\n\t    GEN7_RC_CTL_TO_MODE | VLV_RC_CTL_CTX_RST_PARALLEL;\n}\n\nbool intel_check_bios_c6_setup(struct intel_rc6 *rc6)\n{\n\tif (!rc6->bios_state_captured) {\n\t\tstruct intel_uncore *uncore = rc6_to_uncore(rc6);\n\t\tintel_wakeref_t wakeref;\n\n\t\twith_intel_runtime_pm(uncore->rpm, wakeref)\n\t\t\trc6->bios_rc_state = intel_uncore_read(uncore, GEN6_RC_STATE);\n\n\t\trc6->bios_state_captured = true;\n\t}\n\n\treturn rc6->bios_rc_state & RC_SW_TARGET_STATE_MASK;\n}\n\nstatic bool bxt_check_bios_rc6_setup(struct intel_rc6 *rc6)\n{\n\tstruct intel_uncore *uncore = rc6_to_uncore(rc6);\n\tstruct drm_i915_private *i915 = rc6_to_i915(rc6);\n\tu32 rc6_ctx_base, rc_ctl, rc_sw_target;\n\tbool enable_rc6 = true;\n\n\trc_ctl = intel_uncore_read(uncore, GEN6_RC_CONTROL);\n\trc_sw_target = intel_uncore_read(uncore, GEN6_RC_STATE);\n\trc_sw_target &= RC_SW_TARGET_STATE_MASK;\n\trc_sw_target >>= RC_SW_TARGET_STATE_SHIFT;\n\tdrm_dbg(&i915->drm, \"BIOS enabled RC states: \"\n\t\t\t \"HW_CTRL %s HW_RC6 %s SW_TARGET_STATE %x\\n\",\n\t\t\t str_on_off(rc_ctl & GEN6_RC_CTL_HW_ENABLE),\n\t\t\t str_on_off(rc_ctl & GEN6_RC_CTL_RC6_ENABLE),\n\t\t\t rc_sw_target);\n\n\tif (!(intel_uncore_read(uncore, RC6_LOCATION) & RC6_CTX_IN_DRAM)) {\n\t\tdrm_dbg(&i915->drm, \"RC6 Base location not set properly.\\n\");\n\t\tenable_rc6 = false;\n\t}\n\n\t \n\trc6_ctx_base =\n\t\tintel_uncore_read(uncore, RC6_CTX_BASE) & RC6_CTX_BASE_MASK;\n\tif (!(rc6_ctx_base >= i915->dsm.reserved.start &&\n\t      rc6_ctx_base + PAGE_SIZE < i915->dsm.reserved.end)) {\n\t\tdrm_dbg(&i915->drm, \"RC6 Base address not as expected.\\n\");\n\t\tenable_rc6 = false;\n\t}\n\n\tif (!((intel_uncore_read(uncore, PWRCTX_MAXCNT(RENDER_RING_BASE)) & IDLE_TIME_MASK) > 1 &&\n\t      (intel_uncore_read(uncore, PWRCTX_MAXCNT(GEN6_BSD_RING_BASE)) & IDLE_TIME_MASK) > 1 &&\n\t      (intel_uncore_read(uncore, PWRCTX_MAXCNT(BLT_RING_BASE)) & IDLE_TIME_MASK) > 1 &&\n\t      (intel_uncore_read(uncore, PWRCTX_MAXCNT(VEBOX_RING_BASE)) & IDLE_TIME_MASK) > 1)) {\n\t\tdrm_dbg(&i915->drm,\n\t\t\t\"Engine Idle wait time not set properly.\\n\");\n\t\tenable_rc6 = false;\n\t}\n\n\tif (!intel_uncore_read(uncore, GEN8_PUSHBUS_CONTROL) ||\n\t    !intel_uncore_read(uncore, GEN8_PUSHBUS_ENABLE) ||\n\t    !intel_uncore_read(uncore, GEN8_PUSHBUS_SHIFT)) {\n\t\tdrm_dbg(&i915->drm, \"Pushbus not setup properly.\\n\");\n\t\tenable_rc6 = false;\n\t}\n\n\tif (!intel_uncore_read(uncore, GEN6_GFXPAUSE)) {\n\t\tdrm_dbg(&i915->drm, \"GFX pause not setup properly.\\n\");\n\t\tenable_rc6 = false;\n\t}\n\n\tif (!intel_uncore_read(uncore, GEN8_MISC_CTRL0)) {\n\t\tdrm_dbg(&i915->drm, \"GPM control not setup properly.\\n\");\n\t\tenable_rc6 = false;\n\t}\n\n\treturn enable_rc6;\n}\n\nstatic bool rc6_supported(struct intel_rc6 *rc6)\n{\n\tstruct drm_i915_private *i915 = rc6_to_i915(rc6);\n\tstruct intel_gt *gt = rc6_to_gt(rc6);\n\n\tif (!HAS_RC6(i915))\n\t\treturn false;\n\n\tif (intel_vgpu_active(i915))\n\t\treturn false;\n\n\tif (is_mock_gt(rc6_to_gt(rc6)))\n\t\treturn false;\n\n\tif (IS_GEN9_LP(i915) && !bxt_check_bios_rc6_setup(rc6)) {\n\t\tdrm_notice(&i915->drm,\n\t\t\t   \"RC6 and powersaving disabled by BIOS\\n\");\n\t\treturn false;\n\t}\n\n\tif (IS_METEORLAKE(gt->i915) &&\n\t    !intel_check_bios_c6_setup(rc6)) {\n\t\tdrm_notice(&i915->drm,\n\t\t\t   \"C6 disabled by BIOS\\n\");\n\t\treturn false;\n\t}\n\n\tif (IS_MTL_MEDIA_STEP(gt->i915, STEP_A0, STEP_B0) &&\n\t    gt->type == GT_MEDIA) {\n\t\tdrm_notice(&i915->drm,\n\t\t\t   \"Media RC6 disabled on A step\\n\");\n\t\treturn false;\n\t}\n\n\treturn true;\n}\n\nstatic void rpm_get(struct intel_rc6 *rc6)\n{\n\tGEM_BUG_ON(rc6->wakeref);\n\tpm_runtime_get_sync(rc6_to_i915(rc6)->drm.dev);\n\trc6->wakeref = true;\n}\n\nstatic void rpm_put(struct intel_rc6 *rc6)\n{\n\tGEM_BUG_ON(!rc6->wakeref);\n\tpm_runtime_put(rc6_to_i915(rc6)->drm.dev);\n\trc6->wakeref = false;\n}\n\nstatic bool pctx_corrupted(struct intel_rc6 *rc6)\n{\n\tstruct drm_i915_private *i915 = rc6_to_i915(rc6);\n\n\tif (!NEEDS_RC6_CTX_CORRUPTION_WA(i915))\n\t\treturn false;\n\n\tif (intel_uncore_read(rc6_to_uncore(rc6), GEN8_RC6_CTX_INFO))\n\t\treturn false;\n\n\tdrm_notice(&i915->drm,\n\t\t   \"RC6 context corruption, disabling runtime power management\\n\");\n\treturn true;\n}\n\nstatic void __intel_rc6_disable(struct intel_rc6 *rc6)\n{\n\tstruct drm_i915_private *i915 = rc6_to_i915(rc6);\n\tstruct intel_uncore *uncore = rc6_to_uncore(rc6);\n\tstruct intel_gt *gt = rc6_to_gt(rc6);\n\n\t \n\tintel_guc_rc_disable(&gt->uc.guc);\n\n\tintel_uncore_forcewake_get(uncore, FORCEWAKE_ALL);\n\tif (GRAPHICS_VER(i915) >= 9)\n\t\tintel_uncore_write_fw(uncore, GEN9_PG_ENABLE, 0);\n\tintel_uncore_write_fw(uncore, GEN6_RC_CONTROL, 0);\n\tintel_uncore_write_fw(uncore, GEN6_RC_STATE, 0);\n\tintel_uncore_forcewake_put(uncore, FORCEWAKE_ALL);\n}\n\nstatic void rc6_res_reg_init(struct intel_rc6 *rc6)\n{\n\ti915_reg_t res_reg[INTEL_RC6_RES_MAX] = {\n\t\t[0 ... INTEL_RC6_RES_MAX - 1] = INVALID_MMIO_REG,\n\t};\n\n\tswitch (rc6_to_gt(rc6)->type) {\n\tcase GT_MEDIA:\n\t\tres_reg[INTEL_RC6_RES_RC6] = MTL_MEDIA_MC6;\n\t\tbreak;\n\tdefault:\n\t\tres_reg[INTEL_RC6_RES_RC6_LOCKED] = GEN6_GT_GFX_RC6_LOCKED;\n\t\tres_reg[INTEL_RC6_RES_RC6] = GEN6_GT_GFX_RC6;\n\t\tres_reg[INTEL_RC6_RES_RC6p] = GEN6_GT_GFX_RC6p;\n\t\tres_reg[INTEL_RC6_RES_RC6pp] = GEN6_GT_GFX_RC6pp;\n\t\tbreak;\n\t}\n\n\tmemcpy(rc6->res_reg, res_reg, sizeof(res_reg));\n}\n\nvoid intel_rc6_init(struct intel_rc6 *rc6)\n{\n\tstruct drm_i915_private *i915 = rc6_to_i915(rc6);\n\tint err;\n\n\t \n\trpm_get(rc6);\n\n\tif (!rc6_supported(rc6))\n\t\treturn;\n\n\trc6_res_reg_init(rc6);\n\n\tif (IS_CHERRYVIEW(i915))\n\t\terr = chv_rc6_init(rc6);\n\telse if (IS_VALLEYVIEW(i915))\n\t\terr = vlv_rc6_init(rc6);\n\telse\n\t\terr = 0;\n\n\t \n\t__intel_rc6_disable(rc6);\n\n\trc6->supported = err == 0;\n}\n\nvoid intel_rc6_sanitize(struct intel_rc6 *rc6)\n{\n\tmemset(rc6->prev_hw_residency, 0, sizeof(rc6->prev_hw_residency));\n\n\tif (rc6->enabled) {  \n\t\trpm_get(rc6);\n\t\trc6->enabled = false;\n\t}\n\n\tif (rc6->supported)\n\t\t__intel_rc6_disable(rc6);\n}\n\nvoid intel_rc6_enable(struct intel_rc6 *rc6)\n{\n\tstruct drm_i915_private *i915 = rc6_to_i915(rc6);\n\tstruct intel_uncore *uncore = rc6_to_uncore(rc6);\n\n\tif (!rc6->supported)\n\t\treturn;\n\n\tGEM_BUG_ON(rc6->enabled);\n\n\tintel_uncore_forcewake_get(uncore, FORCEWAKE_ALL);\n\n\tif (IS_CHERRYVIEW(i915))\n\t\tchv_rc6_enable(rc6);\n\telse if (IS_VALLEYVIEW(i915))\n\t\tvlv_rc6_enable(rc6);\n\telse if (GRAPHICS_VER(i915) >= 11)\n\t\tgen11_rc6_enable(rc6);\n\telse if (GRAPHICS_VER(i915) >= 9)\n\t\tgen9_rc6_enable(rc6);\n\telse if (IS_BROADWELL(i915))\n\t\tgen8_rc6_enable(rc6);\n\telse if (GRAPHICS_VER(i915) >= 6)\n\t\tgen6_rc6_enable(rc6);\n\n\trc6->manual = rc6->ctl_enable & GEN6_RC_CTL_RC6_ENABLE;\n\tif (NEEDS_RC6_CTX_CORRUPTION_WA(i915))\n\t\trc6->ctl_enable = 0;\n\n\tintel_uncore_forcewake_put(uncore, FORCEWAKE_ALL);\n\n\tif (unlikely(pctx_corrupted(rc6)))\n\t\treturn;\n\n\t \n\trpm_put(rc6);\n\trc6->enabled = true;\n}\n\nvoid intel_rc6_unpark(struct intel_rc6 *rc6)\n{\n\tstruct intel_uncore *uncore = rc6_to_uncore(rc6);\n\n\tif (!rc6->enabled)\n\t\treturn;\n\n\t \n\tintel_uncore_write_fw(uncore, GEN6_RC_CONTROL, rc6->ctl_enable);\n}\n\nvoid intel_rc6_park(struct intel_rc6 *rc6)\n{\n\tstruct intel_uncore *uncore = rc6_to_uncore(rc6);\n\tunsigned int target;\n\n\tif (!rc6->enabled)\n\t\treturn;\n\n\tif (unlikely(pctx_corrupted(rc6))) {\n\t\tintel_rc6_disable(rc6);\n\t\treturn;\n\t}\n\n\tif (!rc6->manual)\n\t\treturn;\n\n\t \n\tintel_uncore_write_fw(uncore, GEN6_RC_CONTROL, GEN6_RC_CTL_RC6_ENABLE);\n\n\tif (HAS_RC6pp(rc6_to_i915(rc6)))\n\t\ttarget = 0x6;  \n\telse if (HAS_RC6p(rc6_to_i915(rc6)))\n\t\ttarget = 0x5;  \n\telse\n\t\ttarget = 0x4;  \n\tintel_uncore_write_fw(uncore, GEN6_RC_STATE, target << RC_SW_TARGET_STATE_SHIFT);\n}\n\nvoid intel_rc6_disable(struct intel_rc6 *rc6)\n{\n\tif (!rc6->enabled)\n\t\treturn;\n\n\trpm_get(rc6);\n\trc6->enabled = false;\n\n\t__intel_rc6_disable(rc6);\n}\n\nvoid intel_rc6_fini(struct intel_rc6 *rc6)\n{\n\tstruct drm_i915_gem_object *pctx;\n\tstruct intel_uncore *uncore = rc6_to_uncore(rc6);\n\n\tintel_rc6_disable(rc6);\n\n\t \n\tif (IS_METEORLAKE(rc6_to_i915(rc6)) && rc6->bios_state_captured)\n\t\tintel_uncore_write_fw(uncore, GEN6_RC_STATE, rc6->bios_rc_state);\n\n\tpctx = fetch_and_zero(&rc6->pctx);\n\tif (pctx)\n\t\ti915_gem_object_put(pctx);\n\n\tif (rc6->wakeref)\n\t\trpm_put(rc6);\n}\n\nstatic u64 vlv_residency_raw(struct intel_uncore *uncore, const i915_reg_t reg)\n{\n\tu32 lower, upper, tmp;\n\tint loop = 2;\n\n\t \n\tlockdep_assert_held(&uncore->lock);\n\n\t \n\tintel_uncore_write_fw(uncore, VLV_COUNTER_CONTROL,\n\t\t\t      _MASKED_BIT_ENABLE(VLV_COUNT_RANGE_HIGH));\n\tupper = intel_uncore_read_fw(uncore, reg);\n\tdo {\n\t\ttmp = upper;\n\n\t\tintel_uncore_write_fw(uncore, VLV_COUNTER_CONTROL,\n\t\t\t\t      _MASKED_BIT_DISABLE(VLV_COUNT_RANGE_HIGH));\n\t\tlower = intel_uncore_read_fw(uncore, reg);\n\n\t\tintel_uncore_write_fw(uncore, VLV_COUNTER_CONTROL,\n\t\t\t\t      _MASKED_BIT_ENABLE(VLV_COUNT_RANGE_HIGH));\n\t\tupper = intel_uncore_read_fw(uncore, reg);\n\t} while (upper != tmp && --loop);\n\n\t \n\n\treturn lower | (u64)upper << 8;\n}\n\nu64 intel_rc6_residency_ns(struct intel_rc6 *rc6, enum intel_rc6_res_type id)\n{\n\tstruct drm_i915_private *i915 = rc6_to_i915(rc6);\n\tstruct intel_uncore *uncore = rc6_to_uncore(rc6);\n\tu64 time_hw, prev_hw, overflow_hw;\n\ti915_reg_t reg = rc6->res_reg[id];\n\tunsigned int fw_domains;\n\tunsigned long flags;\n\tu32 mul, div;\n\n\tif (!rc6->supported)\n\t\treturn 0;\n\n\tfw_domains = intel_uncore_forcewake_for_reg(uncore, reg, FW_REG_READ);\n\n\tspin_lock_irqsave(&uncore->lock, flags);\n\tintel_uncore_forcewake_get__locked(uncore, fw_domains);\n\n\t \n\tif (IS_VALLEYVIEW(i915) || IS_CHERRYVIEW(i915)) {\n\t\tmul = 1000000;\n\t\tdiv = i915->czclk_freq;\n\t\toverflow_hw = BIT_ULL(40);\n\t\ttime_hw = vlv_residency_raw(uncore, reg);\n\t} else {\n\t\t \n\t\tif (IS_GEN9_LP(i915)) {\n\t\t\tmul = 10000;\n\t\t\tdiv = 12;\n\t\t} else {\n\t\t\tmul = 1280;\n\t\t\tdiv = 1;\n\t\t}\n\n\t\toverflow_hw = BIT_ULL(32);\n\t\ttime_hw = intel_uncore_read_fw(uncore, reg);\n\t}\n\n\t \n\tprev_hw = rc6->prev_hw_residency[id];\n\trc6->prev_hw_residency[id] = time_hw;\n\n\t \n\tif (time_hw >= prev_hw)\n\t\ttime_hw -= prev_hw;\n\telse\n\t\ttime_hw += overflow_hw - prev_hw;\n\n\t \n\ttime_hw += rc6->cur_residency[id];\n\trc6->cur_residency[id] = time_hw;\n\n\tintel_uncore_forcewake_put__locked(uncore, fw_domains);\n\tspin_unlock_irqrestore(&uncore->lock, flags);\n\n\treturn mul_u64_u32_div(time_hw, mul, div);\n}\n\nu64 intel_rc6_residency_us(struct intel_rc6 *rc6, enum intel_rc6_res_type id)\n{\n\treturn DIV_ROUND_UP_ULL(intel_rc6_residency_ns(rc6, id), 1000);\n}\n\nvoid intel_rc6_print_residency(struct seq_file *m, const char *title,\n\t\t\t       enum intel_rc6_res_type id)\n{\n\tstruct intel_gt *gt = m->private;\n\ti915_reg_t reg = gt->rc6.res_reg[id];\n\tintel_wakeref_t wakeref;\n\n\twith_intel_runtime_pm(gt->uncore->rpm, wakeref)\n\t\tseq_printf(m, \"%s %u (%llu us)\\n\", title,\n\t\t\t   intel_uncore_read(gt->uncore, reg),\n\t\t\t   intel_rc6_residency_us(&gt->rc6, id));\n}\n\n#if IS_ENABLED(CONFIG_DRM_I915_SELFTEST)\n#include \"selftest_rc6.c\"\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}