{
  "module_name": "intel_gt_requests.c",
  "hash_id": "b6d3d577321a29cf71562bf9c548b693b8c77ef2a5b8a745be3e2b8ca2e1a468",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/i915/gt/intel_gt_requests.c",
  "human_readable_source": "\n \n\n#include <linux/workqueue.h>\n\n#include \"i915_drv.h\"  \n#include \"i915_request.h\"\n#include \"intel_engine_heartbeat.h\"\n#include \"intel_execlists_submission.h\"\n#include \"intel_gt.h\"\n#include \"intel_gt_pm.h\"\n#include \"intel_gt_requests.h\"\n#include \"intel_timeline.h\"\n\nstatic bool retire_requests(struct intel_timeline *tl)\n{\n\tstruct i915_request *rq, *rn;\n\n\tlist_for_each_entry_safe(rq, rn, &tl->requests, link)\n\t\tif (!i915_request_retire(rq))\n\t\t\treturn false;\n\n\t \n\treturn !i915_active_fence_isset(&tl->last_request);\n}\n\nstatic bool engine_active(const struct intel_engine_cs *engine)\n{\n\treturn !list_empty(&engine->kernel_context->timeline->requests);\n}\n\nstatic bool flush_submission(struct intel_gt *gt, long timeout)\n{\n\tstruct intel_engine_cs *engine;\n\tenum intel_engine_id id;\n\tbool active = false;\n\n\tif (!timeout)\n\t\treturn false;\n\n\tif (!intel_gt_pm_is_awake(gt))\n\t\treturn false;\n\n\tfor_each_engine(engine, gt, id) {\n\t\tintel_engine_flush_submission(engine);\n\n\t\t \n\t\tflush_work(&engine->retire_work);\n\t\tflush_delayed_work(&engine->wakeref.work);\n\n\t\t \n\t\tactive |= engine_active(engine);\n\t}\n\n\treturn active;\n}\n\nstatic void engine_retire(struct work_struct *work)\n{\n\tstruct intel_engine_cs *engine =\n\t\tcontainer_of(work, typeof(*engine), retire_work);\n\tstruct intel_timeline *tl = xchg(&engine->retire, NULL);\n\n\tdo {\n\t\tstruct intel_timeline *next = xchg(&tl->retire, NULL);\n\n\t\t \n\t\tif (mutex_trylock(&tl->mutex)) {\n\t\t\tretire_requests(tl);\n\t\t\tmutex_unlock(&tl->mutex);\n\t\t}\n\t\tintel_timeline_put(tl);\n\n\t\tGEM_BUG_ON(!next);\n\t\ttl = ptr_mask_bits(next, 1);\n\t} while (tl);\n}\n\nstatic bool add_retire(struct intel_engine_cs *engine,\n\t\t       struct intel_timeline *tl)\n{\n#define STUB ((struct intel_timeline *)1)\n\tstruct intel_timeline *first;\n\n\t \n\n\tif (cmpxchg(&tl->retire, NULL, STUB))  \n\t\treturn false;\n\n\tintel_timeline_get(tl);\n\tfirst = READ_ONCE(engine->retire);\n\tdo\n\t\ttl->retire = ptr_pack_bits(first, 1, 1);\n\twhile (!try_cmpxchg(&engine->retire, &first, tl));\n\n\treturn !first;\n}\n\nvoid intel_engine_add_retire(struct intel_engine_cs *engine,\n\t\t\t     struct intel_timeline *tl)\n{\n\t \n\tGEM_BUG_ON(intel_engine_is_virtual(engine));\n\n\tif (add_retire(engine, tl))\n\t\tqueue_work(engine->i915->unordered_wq, &engine->retire_work);\n}\n\nvoid intel_engine_init_retire(struct intel_engine_cs *engine)\n{\n\tINIT_WORK(&engine->retire_work, engine_retire);\n}\n\nvoid intel_engine_fini_retire(struct intel_engine_cs *engine)\n{\n\tflush_work(&engine->retire_work);\n\tGEM_BUG_ON(engine->retire);\n}\n\nlong intel_gt_retire_requests_timeout(struct intel_gt *gt, long timeout,\n\t\t\t\t      long *remaining_timeout)\n{\n\tstruct intel_gt_timelines *timelines = &gt->timelines;\n\tstruct intel_timeline *tl, *tn;\n\tunsigned long active_count = 0;\n\tLIST_HEAD(free);\n\n\tflush_submission(gt, timeout);  \n\tspin_lock(&timelines->lock);\n\tlist_for_each_entry_safe(tl, tn, &timelines->active_list, link) {\n\t\tif (!mutex_trylock(&tl->mutex)) {\n\t\t\tactive_count++;  \n\t\t\tcontinue;\n\t\t}\n\n\t\tintel_timeline_get(tl);\n\t\tGEM_BUG_ON(!atomic_read(&tl->active_count));\n\t\tatomic_inc(&tl->active_count);  \n\t\tspin_unlock(&timelines->lock);\n\n\t\tif (timeout > 0) {\n\t\t\tstruct dma_fence *fence;\n\n\t\t\tfence = i915_active_fence_get(&tl->last_request);\n\t\t\tif (fence) {\n\t\t\t\tmutex_unlock(&tl->mutex);\n\n\t\t\t\ttimeout = dma_fence_wait_timeout(fence,\n\t\t\t\t\t\t\t\t true,\n\t\t\t\t\t\t\t\t timeout);\n\t\t\t\tdma_fence_put(fence);\n\n\t\t\t\t \n\t\t\t\tif (!mutex_trylock(&tl->mutex)) {\n\t\t\t\t\tactive_count++;\n\t\t\t\t\tgoto out_active;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (!retire_requests(tl))\n\t\t\tactive_count++;\n\t\tmutex_unlock(&tl->mutex);\n\nout_active:\tspin_lock(&timelines->lock);\n\n\t\t \n\t\tlist_safe_reset_next(tl, tn, link);\n\t\tif (atomic_dec_and_test(&tl->active_count))\n\t\t\tlist_del(&tl->link);\n\n\t\t \n\t\tif (refcount_dec_and_test(&tl->kref.refcount)) {\n\t\t\tGEM_BUG_ON(atomic_read(&tl->active_count));\n\t\t\tlist_add(&tl->link, &free);\n\t\t}\n\t}\n\tspin_unlock(&timelines->lock);\n\n\tlist_for_each_entry_safe(tl, tn, &free, link)\n\t\t__intel_timeline_free(&tl->kref);\n\n\tif (flush_submission(gt, timeout))  \n\t\tactive_count++;\n\n\tif (remaining_timeout)\n\t\t*remaining_timeout = timeout;\n\n\treturn active_count ? timeout ?: -ETIME : 0;\n}\n\nstatic void retire_work_handler(struct work_struct *work)\n{\n\tstruct intel_gt *gt =\n\t\tcontainer_of(work, typeof(*gt), requests.retire_work.work);\n\n\tqueue_delayed_work(gt->i915->unordered_wq, &gt->requests.retire_work,\n\t\t\t   round_jiffies_up_relative(HZ));\n\tintel_gt_retire_requests(gt);\n}\n\nvoid intel_gt_init_requests(struct intel_gt *gt)\n{\n\tINIT_DELAYED_WORK(&gt->requests.retire_work, retire_work_handler);\n}\n\nvoid intel_gt_park_requests(struct intel_gt *gt)\n{\n\tcancel_delayed_work(&gt->requests.retire_work);\n}\n\nvoid intel_gt_unpark_requests(struct intel_gt *gt)\n{\n\tqueue_delayed_work(gt->i915->unordered_wq, &gt->requests.retire_work,\n\t\t\t   round_jiffies_up_relative(HZ));\n}\n\nvoid intel_gt_fini_requests(struct intel_gt *gt)\n{\n\t \n\tcancel_delayed_work_sync(&gt->requests.retire_work);\n\n\tflush_work(&gt->watchdog.work);\n}\n\nvoid intel_gt_watchdog_work(struct work_struct *work)\n{\n\tstruct intel_gt *gt =\n\t\tcontainer_of(work, typeof(*gt), watchdog.work);\n\tstruct i915_request *rq, *rn;\n\tstruct llist_node *first;\n\n\tfirst = llist_del_all(&gt->watchdog.list);\n\tif (!first)\n\t\treturn;\n\n\tllist_for_each_entry_safe(rq, rn, first, watchdog.link) {\n\t\tif (!i915_request_completed(rq)) {\n\t\t\tstruct dma_fence *f = &rq->fence;\n\n\t\t\tpr_notice(\"Fence expiration time out i915-%s:%s:%llx!\\n\",\n\t\t\t\t  f->ops->get_driver_name(f),\n\t\t\t\t  f->ops->get_timeline_name(f),\n\t\t\t\t  f->seqno);\n\t\t\ti915_request_cancel(rq, -EINTR);\n\t\t}\n\t\ti915_request_put(rq);\n\t}\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}