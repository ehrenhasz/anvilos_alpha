{
  "module_name": "selftest_engine_pm.c",
  "hash_id": "032a4016ab88dc9c91fef83f9a57834cdca1fe2f414f8a3127c08a13bfa57b22",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/i915/gt/selftest_engine_pm.c",
  "human_readable_source": "\n \n\n#include <linux/sort.h>\n\n#include \"gt/intel_gt_print.h\"\n#include \"i915_selftest.h\"\n#include \"intel_engine_regs.h\"\n#include \"intel_gpu_commands.h\"\n#include \"intel_gt_clock_utils.h\"\n#include \"selftest_engine.h\"\n#include \"selftest_engine_heartbeat.h\"\n#include \"selftests/igt_atomic.h\"\n#include \"selftests/igt_flush_test.h\"\n#include \"selftests/igt_spinner.h\"\n\n#define COUNT 5\n\nstatic int cmp_u64(const void *A, const void *B)\n{\n\tconst u64 *a = A, *b = B;\n\n\treturn *a - *b;\n}\n\nstatic u64 trifilter(u64 *a)\n{\n\tsort(a, COUNT, sizeof(*a), cmp_u64, NULL);\n\treturn (a[1] + 2 * a[2] + a[3]) >> 2;\n}\n\nstatic u32 *emit_wait(u32 *cs, u32 offset, int op, u32 value)\n{\n\t*cs++ = MI_SEMAPHORE_WAIT |\n\t\tMI_SEMAPHORE_GLOBAL_GTT |\n\t\tMI_SEMAPHORE_POLL |\n\t\top;\n\t*cs++ = value;\n\t*cs++ = offset;\n\t*cs++ = 0;\n\n\treturn cs;\n}\n\nstatic u32 *emit_store(u32 *cs, u32 offset, u32 value)\n{\n\t*cs++ = MI_STORE_DWORD_IMM_GEN4 | MI_USE_GGTT;\n\t*cs++ = offset;\n\t*cs++ = 0;\n\t*cs++ = value;\n\n\treturn cs;\n}\n\nstatic u32 *emit_srm(u32 *cs, i915_reg_t reg, u32 offset)\n{\n\t*cs++ = MI_STORE_REGISTER_MEM_GEN8 | MI_USE_GGTT;\n\t*cs++ = i915_mmio_reg_offset(reg);\n\t*cs++ = offset;\n\t*cs++ = 0;\n\n\treturn cs;\n}\n\nstatic void write_semaphore(u32 *x, u32 value)\n{\n\tWRITE_ONCE(*x, value);\n\twmb();\n}\n\nstatic int __measure_timestamps(struct intel_context *ce,\n\t\t\t\tu64 *dt, u64 *d_ring, u64 *d_ctx)\n{\n\tstruct intel_engine_cs *engine = ce->engine;\n\tu32 *sema = memset32(engine->status_page.addr + 1000, 0, 5);\n\tu32 offset = i915_ggtt_offset(engine->status_page.vma);\n\tstruct i915_request *rq;\n\tu32 *cs;\n\n\trq = intel_context_create_request(ce);\n\tif (IS_ERR(rq))\n\t\treturn PTR_ERR(rq);\n\n\tcs = intel_ring_begin(rq, 28);\n\tif (IS_ERR(cs)) {\n\t\ti915_request_add(rq);\n\t\treturn PTR_ERR(cs);\n\t}\n\n\t \n\tcs = emit_store(cs, offset + 4008, 1);\n\tcs = emit_wait(cs, offset + 4008, MI_SEMAPHORE_SAD_NEQ_SDD, 1);\n\n\tcs = emit_srm(cs, RING_TIMESTAMP(engine->mmio_base), offset + 4000);\n\tcs = emit_srm(cs, RING_CTX_TIMESTAMP(engine->mmio_base), offset + 4004);\n\n\t \n\tcs = emit_wait(cs, offset + 4008, MI_SEMAPHORE_SAD_EQ_SDD, 1);\n\n\tcs = emit_srm(cs, RING_TIMESTAMP(engine->mmio_base), offset + 4016);\n\tcs = emit_srm(cs, RING_CTX_TIMESTAMP(engine->mmio_base), offset + 4012);\n\n\tintel_ring_advance(rq, cs);\n\ti915_request_get(rq);\n\ti915_request_add(rq);\n\tintel_engine_flush_submission(engine);\n\n\t \n\twhile (READ_ONCE(sema[2]) == 0)\n\t\tcpu_relax();\n\n\t \n\tlocal_irq_disable();\n\twrite_semaphore(&sema[2], 0);\n\twhile (READ_ONCE(sema[1]) == 0)  \n\t\tcpu_relax();\n\t*dt = local_clock();\n\tudelay(100);\n\t*dt = local_clock() - *dt;\n\twrite_semaphore(&sema[2], 1);\n\tlocal_irq_enable();\n\n\tif (i915_request_wait(rq, 0, HZ / 2) < 0) {\n\t\ti915_request_put(rq);\n\t\treturn -ETIME;\n\t}\n\ti915_request_put(rq);\n\n\tpr_debug(\"%s CTX_TIMESTAMP: [%x, %x], RING_TIMESTAMP: [%x, %x]\\n\",\n\t\t engine->name, sema[1], sema[3], sema[0], sema[4]);\n\n\t*d_ctx = sema[3] - sema[1];\n\t*d_ring = sema[4] - sema[0];\n\treturn 0;\n}\n\nstatic int __live_engine_timestamps(struct intel_engine_cs *engine)\n{\n\tu64 s_ring[COUNT], s_ctx[COUNT], st[COUNT], d_ring, d_ctx, dt;\n\tstruct intel_context *ce;\n\tint i, err = 0;\n\n\tce = intel_context_create(engine);\n\tif (IS_ERR(ce))\n\t\treturn PTR_ERR(ce);\n\n\tfor (i = 0; i < COUNT; i++) {\n\t\terr = __measure_timestamps(ce, &st[i], &s_ring[i], &s_ctx[i]);\n\t\tif (err)\n\t\t\tbreak;\n\t}\n\tintel_context_put(ce);\n\tif (err)\n\t\treturn err;\n\n\tdt = trifilter(st);\n\td_ring = trifilter(s_ring);\n\td_ctx = trifilter(s_ctx);\n\n\tpr_info(\"%s elapsed:%lldns, CTX_TIMESTAMP:%lldns, RING_TIMESTAMP:%lldns\\n\",\n\t\tengine->name, dt,\n\t\tintel_gt_clock_interval_to_ns(engine->gt, d_ctx),\n\t\tintel_gt_clock_interval_to_ns(engine->gt, d_ring));\n\n\td_ring = intel_gt_clock_interval_to_ns(engine->gt, d_ring);\n\tif (3 * dt > 4 * d_ring || 4 * dt < 3 * d_ring) {\n\t\tpr_err(\"%s Mismatch between ring timestamp and walltime!\\n\",\n\t\t       engine->name);\n\t\treturn -EINVAL;\n\t}\n\n\td_ring = trifilter(s_ring);\n\td_ctx = trifilter(s_ctx);\n\n\td_ctx *= engine->gt->clock_frequency;\n\tif (GRAPHICS_VER(engine->i915) == 11)\n\t\td_ring *= 12500000;  \n\telse\n\t\td_ring *= engine->gt->clock_frequency;\n\n\tif (3 * d_ctx > 4 * d_ring || 4 * d_ctx < 3 * d_ring) {\n\t\tpr_err(\"%s Mismatch between ring and context timestamps!\\n\",\n\t\t       engine->name);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int live_engine_timestamps(void *arg)\n{\n\tstruct intel_gt *gt = arg;\n\tstruct intel_engine_cs *engine;\n\tenum intel_engine_id id;\n\n\t \n\n\tif (GRAPHICS_VER(gt->i915) < 8)\n\t\treturn 0;\n\n\tfor_each_engine(engine, gt, id) {\n\t\tint err;\n\n\t\tst_engine_heartbeat_disable(engine);\n\t\terr = __live_engine_timestamps(engine);\n\t\tst_engine_heartbeat_enable(engine);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\nstatic int __spin_until_busier(struct intel_engine_cs *engine, ktime_t busyness)\n{\n\tktime_t start, unused, dt;\n\n\tif (!intel_engine_uses_guc(engine))\n\t\treturn 0;\n\n\t \n\tstart = ktime_get();\n\twhile (intel_engine_get_busy_time(engine, &unused) == busyness) {\n\t\tdt = ktime_get() - start;\n\t\tif (dt > 10000000) {\n\t\t\tpr_err(\"active wait timed out %lld\\n\", dt);\n\t\t\tENGINE_TRACE(engine, \"active wait time out %lld\\n\", dt);\n\t\t\treturn -ETIME;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int live_engine_busy_stats(void *arg)\n{\n\tstruct intel_gt *gt = arg;\n\tstruct intel_engine_cs *engine;\n\tenum intel_engine_id id;\n\tstruct igt_spinner spin;\n\tint err = 0;\n\n\t \n\n\tif (igt_spinner_init(&spin, gt))\n\t\treturn -ENOMEM;\n\n\tGEM_BUG_ON(intel_gt_pm_is_awake(gt));\n\tfor_each_engine(engine, gt, id) {\n\t\tstruct i915_request *rq;\n\t\tktime_t busyness, dummy;\n\t\tktime_t de, dt;\n\t\tktime_t t[2];\n\n\t\tif (!intel_engine_supports_stats(engine))\n\t\t\tcontinue;\n\n\t\tif (!intel_engine_can_store_dword(engine))\n\t\t\tcontinue;\n\n\t\tif (intel_gt_pm_wait_for_idle(gt)) {\n\t\t\terr = -EBUSY;\n\t\t\tbreak;\n\t\t}\n\n\t\tst_engine_heartbeat_disable(engine);\n\n\t\tENGINE_TRACE(engine, \"measuring idle time\\n\");\n\t\tpreempt_disable();\n\t\tde = intel_engine_get_busy_time(engine, &t[0]);\n\t\tudelay(100);\n\t\tde = ktime_sub(intel_engine_get_busy_time(engine, &t[1]), de);\n\t\tpreempt_enable();\n\t\tdt = ktime_sub(t[1], t[0]);\n\t\tif (de < 0 || de > 10) {\n\t\t\tpr_err(\"%s: reported %lldns [%d%%] busyness while sleeping [for %lldns]\\n\",\n\t\t\t       engine->name,\n\t\t\t       de, (int)div64_u64(100 * de, dt), dt);\n\t\t\tGEM_TRACE_DUMP();\n\t\t\terr = -EINVAL;\n\t\t\tgoto end;\n\t\t}\n\n\t\t \n\t\trq = igt_spinner_create_request(&spin,\n\t\t\t\t\t\tengine->kernel_context,\n\t\t\t\t\t\tMI_NOOP);\n\t\tif (IS_ERR(rq)) {\n\t\t\terr = PTR_ERR(rq);\n\t\t\tgoto end;\n\t\t}\n\t\ti915_request_add(rq);\n\n\t\tbusyness = intel_engine_get_busy_time(engine, &dummy);\n\t\tif (!igt_wait_for_spinner(&spin, rq)) {\n\t\t\tintel_gt_set_wedged(engine->gt);\n\t\t\terr = -ETIME;\n\t\t\tgoto end;\n\t\t}\n\n\t\terr = __spin_until_busier(engine, busyness);\n\t\tif (err) {\n\t\t\tGEM_TRACE_DUMP();\n\t\t\tgoto end;\n\t\t}\n\n\t\tENGINE_TRACE(engine, \"measuring busy time\\n\");\n\t\tpreempt_disable();\n\t\tde = intel_engine_get_busy_time(engine, &t[0]);\n\t\tmdelay(100);\n\t\tde = ktime_sub(intel_engine_get_busy_time(engine, &t[1]), de);\n\t\tpreempt_enable();\n\t\tdt = ktime_sub(t[1], t[0]);\n\t\tif (100 * de < 95 * dt || 95 * de > 100 * dt) {\n\t\t\tpr_err(\"%s: reported %lldns [%d%%] busyness while spinning [for %lldns]\\n\",\n\t\t\t       engine->name,\n\t\t\t       de, (int)div64_u64(100 * de, dt), dt);\n\t\t\tGEM_TRACE_DUMP();\n\t\t\terr = -EINVAL;\n\t\t\tgoto end;\n\t\t}\n\nend:\n\t\tst_engine_heartbeat_enable(engine);\n\t\tigt_spinner_end(&spin);\n\t\tif (igt_flush_test(gt->i915))\n\t\t\terr = -EIO;\n\t\tif (err)\n\t\t\tbreak;\n\t}\n\n\tigt_spinner_fini(&spin);\n\tif (igt_flush_test(gt->i915))\n\t\terr = -EIO;\n\treturn err;\n}\n\nstatic int live_engine_pm(void *arg)\n{\n\tstruct intel_gt *gt = arg;\n\tstruct intel_engine_cs *engine;\n\tenum intel_engine_id id;\n\n\t \n\tif (intel_gt_pm_wait_for_idle(gt)) {\n\t\tpr_err(\"Unable to flush GT pm before test\\n\");\n\t\treturn -EBUSY;\n\t}\n\n\tGEM_BUG_ON(intel_gt_pm_is_awake(gt));\n\tfor_each_engine(engine, gt, id) {\n\t\tconst typeof(*igt_atomic_phases) *p;\n\n\t\tfor (p = igt_atomic_phases; p->name; p++) {\n\t\t\t \n\t\t\tGEM_BUG_ON(intel_engine_pm_is_awake(engine));\n\t\t\tintel_engine_pm_get(engine);\n\n\t\t\tp->critical_section_begin();\n\t\t\tif (!intel_engine_pm_get_if_awake(engine))\n\t\t\t\tpr_err(\"intel_engine_pm_get_if_awake(%s) failed under %s\\n\",\n\t\t\t\t       engine->name, p->name);\n\t\t\telse\n\t\t\t\tintel_engine_pm_put_async(engine);\n\t\t\tintel_engine_pm_put_async(engine);\n\t\t\tp->critical_section_end();\n\n\t\t\tintel_engine_pm_flush(engine);\n\n\t\t\tif (intel_engine_pm_is_awake(engine)) {\n\t\t\t\tpr_err(\"%s is still awake after flushing pm\\n\",\n\t\t\t\t       engine->name);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\n\t\t\t \n\t\t\tif (intel_gt_pm_wait_for_idle(gt)) {\n\t\t\t\tgt_err(gt, \"GT failed to idle\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nint live_engine_pm_selftests(struct intel_gt *gt)\n{\n\tstatic const struct i915_subtest tests[] = {\n\t\tSUBTEST(live_engine_timestamps),\n\t\tSUBTEST(live_engine_busy_stats),\n\t\tSUBTEST(live_engine_pm),\n\t};\n\n\treturn intel_gt_live_subtests(tests, gt);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}