{
  "module_name": "selftest_rps.c",
  "hash_id": "5769792c827958cf369de7c6d7ee93386e931dcefc67aba1e28f9b086fb85ddb",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/i915/gt/selftest_rps.c",
  "human_readable_source": "\n \n\n#include <linux/pm_qos.h>\n#include <linux/sort.h>\n\n#include \"gem/i915_gem_internal.h\"\n\n#include \"i915_reg.h\"\n#include \"intel_engine_heartbeat.h\"\n#include \"intel_engine_pm.h\"\n#include \"intel_engine_regs.h\"\n#include \"intel_gpu_commands.h\"\n#include \"intel_gt_clock_utils.h\"\n#include \"intel_gt_pm.h\"\n#include \"intel_rc6.h\"\n#include \"selftest_engine_heartbeat.h\"\n#include \"selftest_rps.h\"\n#include \"selftests/igt_flush_test.h\"\n#include \"selftests/igt_spinner.h\"\n#include \"selftests/librapl.h\"\n\n \n#define CPU_LATENCY 0  \n\nstatic void dummy_rps_work(struct work_struct *wrk)\n{\n}\n\nstatic int cmp_u64(const void *A, const void *B)\n{\n\tconst u64 *a = A, *b = B;\n\n\tif (*a < *b)\n\t\treturn -1;\n\telse if (*a > *b)\n\t\treturn 1;\n\telse\n\t\treturn 0;\n}\n\nstatic int cmp_u32(const void *A, const void *B)\n{\n\tconst u32 *a = A, *b = B;\n\n\tif (*a < *b)\n\t\treturn -1;\n\telse if (*a > *b)\n\t\treturn 1;\n\telse\n\t\treturn 0;\n}\n\nstatic struct i915_vma *\ncreate_spin_counter(struct intel_engine_cs *engine,\n\t\t    struct i915_address_space *vm,\n\t\t    bool srm,\n\t\t    u32 **cancel,\n\t\t    u32 **counter)\n{\n\tenum {\n\t\tCOUNT,\n\t\tINC,\n\t\t__NGPR__,\n\t};\n#define CS_GPR(x) GEN8_RING_CS_GPR(engine->mmio_base, x)\n\tstruct drm_i915_gem_object *obj;\n\tstruct i915_vma *vma;\n\tunsigned long end;\n\tu32 *base, *cs;\n\tint loop, i;\n\tint err;\n\n\tobj = i915_gem_object_create_internal(vm->i915, 64 << 10);\n\tif (IS_ERR(obj))\n\t\treturn ERR_CAST(obj);\n\n\tend = obj->base.size / sizeof(u32) - 1;\n\n\tvma = i915_vma_instance(obj, vm, NULL);\n\tif (IS_ERR(vma)) {\n\t\terr = PTR_ERR(vma);\n\t\tgoto err_put;\n\t}\n\n\terr = i915_vma_pin(vma, 0, 0, PIN_USER);\n\tif (err)\n\t\tgoto err_unlock;\n\n\ti915_vma_lock(vma);\n\n\tbase = i915_gem_object_pin_map(obj, I915_MAP_WC);\n\tif (IS_ERR(base)) {\n\t\terr = PTR_ERR(base);\n\t\tgoto err_unpin;\n\t}\n\tcs = base;\n\n\t*cs++ = MI_LOAD_REGISTER_IMM(__NGPR__ * 2);\n\tfor (i = 0; i < __NGPR__; i++) {\n\t\t*cs++ = i915_mmio_reg_offset(CS_GPR(i));\n\t\t*cs++ = 0;\n\t\t*cs++ = i915_mmio_reg_offset(CS_GPR(i)) + 4;\n\t\t*cs++ = 0;\n\t}\n\n\t*cs++ = MI_LOAD_REGISTER_IMM(1);\n\t*cs++ = i915_mmio_reg_offset(CS_GPR(INC));\n\t*cs++ = 1;\n\n\tloop = cs - base;\n\n\t \n\tfor (i = 0; i < 1024; i++) {\n\t\t*cs++ = MI_MATH(4);\n\t\t*cs++ = MI_MATH_LOAD(MI_MATH_REG_SRCA, MI_MATH_REG(COUNT));\n\t\t*cs++ = MI_MATH_LOAD(MI_MATH_REG_SRCB, MI_MATH_REG(INC));\n\t\t*cs++ = MI_MATH_ADD;\n\t\t*cs++ = MI_MATH_STORE(MI_MATH_REG(COUNT), MI_MATH_REG_ACCU);\n\n\t\tif (srm) {\n\t\t\t*cs++ = MI_STORE_REGISTER_MEM_GEN8;\n\t\t\t*cs++ = i915_mmio_reg_offset(CS_GPR(COUNT));\n\t\t\t*cs++ = lower_32_bits(i915_vma_offset(vma) + end * sizeof(*cs));\n\t\t\t*cs++ = upper_32_bits(i915_vma_offset(vma) + end * sizeof(*cs));\n\t\t}\n\t}\n\n\t*cs++ = MI_BATCH_BUFFER_START_GEN8;\n\t*cs++ = lower_32_bits(i915_vma_offset(vma) + loop * sizeof(*cs));\n\t*cs++ = upper_32_bits(i915_vma_offset(vma) + loop * sizeof(*cs));\n\tGEM_BUG_ON(cs - base > end);\n\n\ti915_gem_object_flush_map(obj);\n\n\t*cancel = base + loop;\n\t*counter = srm ? memset32(base + end, 0, 1) : NULL;\n\treturn vma;\n\nerr_unpin:\n\ti915_vma_unpin(vma);\nerr_unlock:\n\ti915_vma_unlock(vma);\nerr_put:\n\ti915_gem_object_put(obj);\n\treturn ERR_PTR(err);\n}\n\nstatic u8 wait_for_freq(struct intel_rps *rps, u8 freq, int timeout_ms)\n{\n\tu8 history[64], i;\n\tunsigned long end;\n\tint sleep;\n\n\ti = 0;\n\tmemset(history, freq, sizeof(history));\n\tsleep = 20;\n\n\t \n\tend = jiffies + msecs_to_jiffies(timeout_ms);\n\tdo {\n\t\tu8 act;\n\n\t\tact = read_cagf(rps);\n\t\tif (time_after(jiffies, end))\n\t\t\treturn act;\n\n\t\t \n\t\tif (act == freq)\n\t\t\treturn act;\n\n\t\t \n\t\tif (!memchr_inv(history, act, sizeof(history)))\n\t\t\treturn act;\n\n\t\thistory[i] = act;\n\t\ti = (i + 1) % ARRAY_SIZE(history);\n\n\t\tusleep_range(sleep, 2 * sleep);\n\t\tsleep *= 2;\n\t\tif (sleep > timeout_ms * 20)\n\t\t\tsleep = timeout_ms * 20;\n\t} while (1);\n}\n\nstatic u8 rps_set_check(struct intel_rps *rps, u8 freq)\n{\n\tmutex_lock(&rps->lock);\n\tGEM_BUG_ON(!intel_rps_is_active(rps));\n\tif (wait_for(!intel_rps_set(rps, freq), 50)) {\n\t\tmutex_unlock(&rps->lock);\n\t\treturn 0;\n\t}\n\tGEM_BUG_ON(rps->last_freq != freq);\n\tmutex_unlock(&rps->lock);\n\n\treturn wait_for_freq(rps, freq, 50);\n}\n\nstatic void show_pstate_limits(struct intel_rps *rps)\n{\n\tstruct drm_i915_private *i915 = rps_to_i915(rps);\n\n\tif (IS_BROXTON(i915)) {\n\t\tpr_info(\"P_STATE_CAP[%x]: 0x%08x\\n\",\n\t\t\ti915_mmio_reg_offset(BXT_RP_STATE_CAP),\n\t\t\tintel_uncore_read(rps_to_uncore(rps),\n\t\t\t\t\t  BXT_RP_STATE_CAP));\n\t} else if (GRAPHICS_VER(i915) == 9) {\n\t\tpr_info(\"P_STATE_LIMITS[%x]: 0x%08x\\n\",\n\t\t\ti915_mmio_reg_offset(GEN9_RP_STATE_LIMITS),\n\t\t\tintel_uncore_read(rps_to_uncore(rps),\n\t\t\t\t\t  GEN9_RP_STATE_LIMITS));\n\t}\n}\n\nint live_rps_clock_interval(void *arg)\n{\n\tstruct intel_gt *gt = arg;\n\tstruct intel_rps *rps = &gt->rps;\n\tvoid (*saved_work)(struct work_struct *wrk);\n\tstruct intel_engine_cs *engine;\n\tenum intel_engine_id id;\n\tstruct igt_spinner spin;\n\tint err = 0;\n\n\tif (!intel_rps_is_enabled(rps) || GRAPHICS_VER(gt->i915) < 6)\n\t\treturn 0;\n\n\tif (igt_spinner_init(&spin, gt))\n\t\treturn -ENOMEM;\n\n\tintel_gt_pm_wait_for_idle(gt);\n\tsaved_work = rps->work.func;\n\trps->work.func = dummy_rps_work;\n\n\tintel_gt_pm_get(gt);\n\tintel_rps_disable(&gt->rps);\n\n\tintel_gt_check_clock_frequency(gt);\n\n\tfor_each_engine(engine, gt, id) {\n\t\tstruct i915_request *rq;\n\t\tu32 cycles;\n\t\tu64 dt;\n\n\t\tif (!intel_engine_can_store_dword(engine))\n\t\t\tcontinue;\n\n\t\tst_engine_heartbeat_disable(engine);\n\n\t\trq = igt_spinner_create_request(&spin,\n\t\t\t\t\t\tengine->kernel_context,\n\t\t\t\t\t\tMI_NOOP);\n\t\tif (IS_ERR(rq)) {\n\t\t\tst_engine_heartbeat_enable(engine);\n\t\t\terr = PTR_ERR(rq);\n\t\t\tbreak;\n\t\t}\n\n\t\ti915_request_add(rq);\n\n\t\tif (!igt_wait_for_spinner(&spin, rq)) {\n\t\t\tpr_err(\"%s: RPS spinner did not start\\n\",\n\t\t\t       engine->name);\n\t\t\tigt_spinner_end(&spin);\n\t\t\tst_engine_heartbeat_enable(engine);\n\t\t\tintel_gt_set_wedged(engine->gt);\n\t\t\terr = -EIO;\n\t\t\tbreak;\n\t\t}\n\n\t\tintel_uncore_forcewake_get(gt->uncore, FORCEWAKE_ALL);\n\n\t\tintel_uncore_write_fw(gt->uncore, GEN6_RP_CUR_UP_EI, 0);\n\n\t\t \n\t\tintel_uncore_write_fw(gt->uncore,\n\t\t\t\t      GEN6_RP_UP_EI, 0xffffffff);\n\t\tintel_uncore_write_fw(gt->uncore,\n\t\t\t\t      GEN6_RP_UP_THRESHOLD, 0xffffffff);\n\n\t\tintel_uncore_write_fw(gt->uncore, GEN6_RP_CONTROL,\n\t\t\t\t      GEN6_RP_ENABLE | GEN6_RP_UP_BUSY_AVG);\n\n\t\tif (wait_for(intel_uncore_read_fw(gt->uncore,\n\t\t\t\t\t\t  GEN6_RP_CUR_UP_EI),\n\t\t\t     10)) {\n\t\t\t \n\t\t\tpr_notice(\"%s: rps evaluation interval not ticking\\n\",\n\t\t\t\t  engine->name);\n\t\t\terr = -ENODEV;\n\t\t} else {\n\t\t\tktime_t dt_[5];\n\t\t\tu32 cycles_[5];\n\t\t\tint i;\n\n\t\t\tfor (i = 0; i < 5; i++) {\n\t\t\t\tpreempt_disable();\n\n\t\t\t\tcycles_[i] = -intel_uncore_read_fw(gt->uncore, GEN6_RP_CUR_UP_EI);\n\t\t\t\tdt_[i] = ktime_get();\n\n\t\t\t\tudelay(1000);\n\n\t\t\t\tcycles_[i] += intel_uncore_read_fw(gt->uncore, GEN6_RP_CUR_UP_EI);\n\t\t\t\tdt_[i] = ktime_sub(ktime_get(), dt_[i]);\n\n\t\t\t\tpreempt_enable();\n\t\t\t}\n\n\t\t\t \n\t\t\tsort(cycles_, 5, sizeof(*cycles_), cmp_u32, NULL);\n\t\t\tcycles = (cycles_[1] + 2 * cycles_[2] + cycles_[3]) / 4;\n\t\t\tsort(dt_, 5, sizeof(*dt_), cmp_u64, NULL);\n\t\t\tdt = div_u64(dt_[1] + 2 * dt_[2] + dt_[3], 4);\n\t\t}\n\n\t\tintel_uncore_write_fw(gt->uncore, GEN6_RP_CONTROL, 0);\n\t\tintel_uncore_forcewake_put(gt->uncore, FORCEWAKE_ALL);\n\n\t\tigt_spinner_end(&spin);\n\t\tst_engine_heartbeat_enable(engine);\n\n\t\tif (err == 0) {\n\t\t\tu64 time = intel_gt_pm_interval_to_ns(gt, cycles);\n\t\t\tu32 expected =\n\t\t\t\tintel_gt_ns_to_pm_interval(gt, dt);\n\n\t\t\tpr_info(\"%s: rps counted %d C0 cycles [%lldns] in %lldns [%d cycles], using GT clock frequency of %uKHz\\n\",\n\t\t\t\tengine->name, cycles, time, dt, expected,\n\t\t\t\tgt->clock_frequency / 1000);\n\n\t\t\tif (10 * time < 8 * dt ||\n\t\t\t    8 * time > 10 * dt) {\n\t\t\t\tpr_err(\"%s: rps clock time does not match walltime!\\n\",\n\t\t\t\t       engine->name);\n\t\t\t\terr = -EINVAL;\n\t\t\t}\n\n\t\t\tif (10 * expected < 8 * cycles ||\n\t\t\t    8 * expected > 10 * cycles) {\n\t\t\t\tpr_err(\"%s: walltime does not match rps clock ticks!\\n\",\n\t\t\t\t       engine->name);\n\t\t\t\terr = -EINVAL;\n\t\t\t}\n\t\t}\n\n\t\tif (igt_flush_test(gt->i915))\n\t\t\terr = -EIO;\n\n\t\tbreak;  \n\t}\n\n\tintel_rps_enable(&gt->rps);\n\tintel_gt_pm_put(gt);\n\n\tigt_spinner_fini(&spin);\n\n\tintel_gt_pm_wait_for_idle(gt);\n\trps->work.func = saved_work;\n\n\tif (err == -ENODEV)  \n\t\terr = 0;\n\n\treturn err;\n}\n\nint live_rps_control(void *arg)\n{\n\tstruct intel_gt *gt = arg;\n\tstruct intel_rps *rps = &gt->rps;\n\tvoid (*saved_work)(struct work_struct *wrk);\n\tstruct intel_engine_cs *engine;\n\tenum intel_engine_id id;\n\tstruct igt_spinner spin;\n\tint err = 0;\n\n\t \n\n\tif (!intel_rps_is_enabled(rps))\n\t\treturn 0;\n\n\tif (IS_CHERRYVIEW(gt->i915))  \n\t\treturn 0;\n\n\tif (igt_spinner_init(&spin, gt))\n\t\treturn -ENOMEM;\n\n\tintel_gt_pm_wait_for_idle(gt);\n\tsaved_work = rps->work.func;\n\trps->work.func = dummy_rps_work;\n\n\tintel_gt_pm_get(gt);\n\tfor_each_engine(engine, gt, id) {\n\t\tstruct i915_request *rq;\n\t\tktime_t min_dt, max_dt;\n\t\tint f, limit;\n\t\tint min, max;\n\n\t\tif (!intel_engine_can_store_dword(engine))\n\t\t\tcontinue;\n\n\t\tst_engine_heartbeat_disable(engine);\n\n\t\trq = igt_spinner_create_request(&spin,\n\t\t\t\t\t\tengine->kernel_context,\n\t\t\t\t\t\tMI_NOOP);\n\t\tif (IS_ERR(rq)) {\n\t\t\terr = PTR_ERR(rq);\n\t\t\tbreak;\n\t\t}\n\n\t\ti915_request_add(rq);\n\n\t\tif (!igt_wait_for_spinner(&spin, rq)) {\n\t\t\tpr_err(\"%s: RPS spinner did not start\\n\",\n\t\t\t       engine->name);\n\t\t\tigt_spinner_end(&spin);\n\t\t\tst_engine_heartbeat_enable(engine);\n\t\t\tintel_gt_set_wedged(engine->gt);\n\t\t\terr = -EIO;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (rps_set_check(rps, rps->min_freq) != rps->min_freq) {\n\t\t\tpr_err(\"%s: could not set minimum frequency [%x], only %x!\\n\",\n\t\t\t       engine->name, rps->min_freq, read_cagf(rps));\n\t\t\tigt_spinner_end(&spin);\n\t\t\tst_engine_heartbeat_enable(engine);\n\t\t\tshow_pstate_limits(rps);\n\t\t\terr = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\tfor (f = rps->min_freq + 1; f < rps->max_freq; f++) {\n\t\t\tif (rps_set_check(rps, f) < f)\n\t\t\t\tbreak;\n\t\t}\n\n\t\tlimit = rps_set_check(rps, f);\n\n\t\tif (rps_set_check(rps, rps->min_freq) != rps->min_freq) {\n\t\t\tpr_err(\"%s: could not restore minimum frequency [%x], only %x!\\n\",\n\t\t\t       engine->name, rps->min_freq, read_cagf(rps));\n\t\t\tigt_spinner_end(&spin);\n\t\t\tst_engine_heartbeat_enable(engine);\n\t\t\tshow_pstate_limits(rps);\n\t\t\terr = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\tmax_dt = ktime_get();\n\t\tmax = rps_set_check(rps, limit);\n\t\tmax_dt = ktime_sub(ktime_get(), max_dt);\n\n\t\tmin_dt = ktime_get();\n\t\tmin = rps_set_check(rps, rps->min_freq);\n\t\tmin_dt = ktime_sub(ktime_get(), min_dt);\n\n\t\tigt_spinner_end(&spin);\n\t\tst_engine_heartbeat_enable(engine);\n\n\t\tpr_info(\"%s: range:[%x:%uMHz, %x:%uMHz] limit:[%x:%uMHz], %x:%x response %lluns:%lluns\\n\",\n\t\t\tengine->name,\n\t\t\trps->min_freq, intel_gpu_freq(rps, rps->min_freq),\n\t\t\trps->max_freq, intel_gpu_freq(rps, rps->max_freq),\n\t\t\tlimit, intel_gpu_freq(rps, limit),\n\t\t\tmin, max, ktime_to_ns(min_dt), ktime_to_ns(max_dt));\n\n\t\tif (limit == rps->min_freq) {\n\t\t\tpr_err(\"%s: GPU throttled to minimum!\\n\",\n\t\t\t       engine->name);\n\t\t\tshow_pstate_limits(rps);\n\t\t\terr = -ENODEV;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (igt_flush_test(gt->i915)) {\n\t\t\terr = -EIO;\n\t\t\tbreak;\n\t\t}\n\t}\n\tintel_gt_pm_put(gt);\n\n\tigt_spinner_fini(&spin);\n\n\tintel_gt_pm_wait_for_idle(gt);\n\trps->work.func = saved_work;\n\n\treturn err;\n}\n\nstatic void show_pcu_config(struct intel_rps *rps)\n{\n\tstruct drm_i915_private *i915 = rps_to_i915(rps);\n\tunsigned int max_gpu_freq, min_gpu_freq;\n\tintel_wakeref_t wakeref;\n\tint gpu_freq;\n\n\tif (!HAS_LLC(i915))\n\t\treturn;\n\n\tmin_gpu_freq = rps->min_freq;\n\tmax_gpu_freq = rps->max_freq;\n\tif (GRAPHICS_VER(i915) >= 9) {\n\t\t \n\t\tmin_gpu_freq /= GEN9_FREQ_SCALER;\n\t\tmax_gpu_freq /= GEN9_FREQ_SCALER;\n\t}\n\n\twakeref = intel_runtime_pm_get(rps_to_uncore(rps)->rpm);\n\n\tpr_info(\"%5s  %5s  %5s\\n\", \"GPU\", \"eCPU\", \"eRing\");\n\tfor (gpu_freq = min_gpu_freq; gpu_freq <= max_gpu_freq; gpu_freq++) {\n\t\tint ia_freq = gpu_freq;\n\n\t\tsnb_pcode_read(rps_to_gt(rps)->uncore, GEN6_PCODE_READ_MIN_FREQ_TABLE,\n\t\t\t       &ia_freq, NULL);\n\n\t\tpr_info(\"%5d  %5d  %5d\\n\",\n\t\t\tgpu_freq * 50,\n\t\t\t((ia_freq >> 0) & 0xff) * 100,\n\t\t\t((ia_freq >> 8) & 0xff) * 100);\n\t}\n\n\tintel_runtime_pm_put(rps_to_uncore(rps)->rpm, wakeref);\n}\n\nstatic u64 __measure_frequency(u32 *cntr, int duration_ms)\n{\n\tu64 dc, dt;\n\n\tdc = READ_ONCE(*cntr);\n\tdt = ktime_get();\n\tusleep_range(1000 * duration_ms, 2000 * duration_ms);\n\tdc = READ_ONCE(*cntr) - dc;\n\tdt = ktime_get() - dt;\n\n\treturn div64_u64(1000 * 1000 * dc, dt);\n}\n\nstatic u64 measure_frequency_at(struct intel_rps *rps, u32 *cntr, int *freq)\n{\n\tu64 x[5];\n\tint i;\n\n\t*freq = rps_set_check(rps, *freq);\n\tfor (i = 0; i < 5; i++)\n\t\tx[i] = __measure_frequency(cntr, 2);\n\t*freq = (*freq + read_cagf(rps)) / 2;\n\n\t \n\tsort(x, 5, sizeof(*x), cmp_u64, NULL);\n\treturn div_u64(x[1] + 2 * x[2] + x[3], 4);\n}\n\nstatic u64 __measure_cs_frequency(struct intel_engine_cs *engine,\n\t\t\t\t  int duration_ms)\n{\n\tu64 dc, dt;\n\n\tdc = intel_uncore_read_fw(engine->uncore, CS_GPR(0));\n\tdt = ktime_get();\n\tusleep_range(1000 * duration_ms, 2000 * duration_ms);\n\tdc = intel_uncore_read_fw(engine->uncore, CS_GPR(0)) - dc;\n\tdt = ktime_get() - dt;\n\n\treturn div64_u64(1000 * 1000 * dc, dt);\n}\n\nstatic u64 measure_cs_frequency_at(struct intel_rps *rps,\n\t\t\t\t   struct intel_engine_cs *engine,\n\t\t\t\t   int *freq)\n{\n\tu64 x[5];\n\tint i;\n\n\t*freq = rps_set_check(rps, *freq);\n\tfor (i = 0; i < 5; i++)\n\t\tx[i] = __measure_cs_frequency(engine, 2);\n\t*freq = (*freq + read_cagf(rps)) / 2;\n\n\t \n\tsort(x, 5, sizeof(*x), cmp_u64, NULL);\n\treturn div_u64(x[1] + 2 * x[2] + x[3], 4);\n}\n\nstatic bool scaled_within(u64 x, u64 y, u32 f_n, u32 f_d)\n{\n\treturn f_d * x > f_n * y && f_n * x < f_d * y;\n}\n\nint live_rps_frequency_cs(void *arg)\n{\n\tvoid (*saved_work)(struct work_struct *wrk);\n\tstruct intel_gt *gt = arg;\n\tstruct intel_rps *rps = &gt->rps;\n\tstruct intel_engine_cs *engine;\n\tstruct pm_qos_request qos;\n\tenum intel_engine_id id;\n\tint err = 0;\n\n\t \n\n\tif (!intel_rps_is_enabled(rps))\n\t\treturn 0;\n\n\tif (GRAPHICS_VER(gt->i915) < 8)  \n\t\treturn 0;\n\n\tif (CPU_LATENCY >= 0)\n\t\tcpu_latency_qos_add_request(&qos, CPU_LATENCY);\n\n\tintel_gt_pm_wait_for_idle(gt);\n\tsaved_work = rps->work.func;\n\trps->work.func = dummy_rps_work;\n\n\tfor_each_engine(engine, gt, id) {\n\t\tstruct i915_request *rq;\n\t\tstruct i915_vma *vma;\n\t\tu32 *cancel, *cntr;\n\t\tstruct {\n\t\t\tu64 count;\n\t\t\tint freq;\n\t\t} min, max;\n\n\t\tst_engine_heartbeat_disable(engine);\n\n\t\tvma = create_spin_counter(engine,\n\t\t\t\t\t  engine->kernel_context->vm, false,\n\t\t\t\t\t  &cancel, &cntr);\n\t\tif (IS_ERR(vma)) {\n\t\t\terr = PTR_ERR(vma);\n\t\t\tst_engine_heartbeat_enable(engine);\n\t\t\tbreak;\n\t\t}\n\n\t\trq = intel_engine_create_kernel_request(engine);\n\t\tif (IS_ERR(rq)) {\n\t\t\terr = PTR_ERR(rq);\n\t\t\tgoto err_vma;\n\t\t}\n\n\t\terr = i915_vma_move_to_active(vma, rq, 0);\n\t\tif (!err)\n\t\t\terr = rq->engine->emit_bb_start(rq,\n\t\t\t\t\t\t\ti915_vma_offset(vma),\n\t\t\t\t\t\t\tPAGE_SIZE, 0);\n\t\ti915_request_add(rq);\n\t\tif (err)\n\t\t\tgoto err_vma;\n\n\t\tif (wait_for(intel_uncore_read(engine->uncore, CS_GPR(0)),\n\t\t\t     10)) {\n\t\t\tpr_err(\"%s: timed loop did not start\\n\",\n\t\t\t       engine->name);\n\t\t\tgoto err_vma;\n\t\t}\n\n\t\tmin.freq = rps->min_freq;\n\t\tmin.count = measure_cs_frequency_at(rps, engine, &min.freq);\n\n\t\tmax.freq = rps->max_freq;\n\t\tmax.count = measure_cs_frequency_at(rps, engine, &max.freq);\n\n\t\tpr_info(\"%s: min:%lluKHz @ %uMHz, max:%lluKHz @ %uMHz [%d%%]\\n\",\n\t\t\tengine->name,\n\t\t\tmin.count, intel_gpu_freq(rps, min.freq),\n\t\t\tmax.count, intel_gpu_freq(rps, max.freq),\n\t\t\t(int)DIV64_U64_ROUND_CLOSEST(100 * min.freq * max.count,\n\t\t\t\t\t\t     max.freq * min.count));\n\n\t\tif (!scaled_within(max.freq * min.count,\n\t\t\t\t   min.freq * max.count,\n\t\t\t\t   2, 3)) {\n\t\t\tint f;\n\n\t\t\tpr_err(\"%s: CS did not scale with frequency! scaled min:%llu, max:%llu\\n\",\n\t\t\t       engine->name,\n\t\t\t       max.freq * min.count,\n\t\t\t       min.freq * max.count);\n\t\t\tshow_pcu_config(rps);\n\n\t\t\tfor (f = min.freq + 1; f <= rps->max_freq; f++) {\n\t\t\t\tint act = f;\n\t\t\t\tu64 count;\n\n\t\t\t\tcount = measure_cs_frequency_at(rps, engine, &act);\n\t\t\t\tif (act < f)\n\t\t\t\t\tbreak;\n\n\t\t\t\tpr_info(\"%s: %x:%uMHz: %lluKHz [%d%%]\\n\",\n\t\t\t\t\tengine->name,\n\t\t\t\t\tact, intel_gpu_freq(rps, act), count,\n\t\t\t\t\t(int)DIV64_U64_ROUND_CLOSEST(100 * min.freq * count,\n\t\t\t\t\t\t\t\t     act * min.count));\n\n\t\t\t\tf = act;  \n\t\t\t}\n\n\t\t\terr = -EINTR;  \n\t\t}\n\nerr_vma:\n\t\t*cancel = MI_BATCH_BUFFER_END;\n\t\ti915_gem_object_flush_map(vma->obj);\n\t\ti915_gem_object_unpin_map(vma->obj);\n\t\ti915_vma_unpin(vma);\n\t\ti915_vma_unlock(vma);\n\t\ti915_vma_put(vma);\n\n\t\tst_engine_heartbeat_enable(engine);\n\t\tif (igt_flush_test(gt->i915))\n\t\t\terr = -EIO;\n\t\tif (err)\n\t\t\tbreak;\n\t}\n\n\tintel_gt_pm_wait_for_idle(gt);\n\trps->work.func = saved_work;\n\n\tif (CPU_LATENCY >= 0)\n\t\tcpu_latency_qos_remove_request(&qos);\n\n\treturn err;\n}\n\nint live_rps_frequency_srm(void *arg)\n{\n\tvoid (*saved_work)(struct work_struct *wrk);\n\tstruct intel_gt *gt = arg;\n\tstruct intel_rps *rps = &gt->rps;\n\tstruct intel_engine_cs *engine;\n\tstruct pm_qos_request qos;\n\tenum intel_engine_id id;\n\tint err = 0;\n\n\t \n\n\tif (!intel_rps_is_enabled(rps))\n\t\treturn 0;\n\n\tif (GRAPHICS_VER(gt->i915) < 8)  \n\t\treturn 0;\n\n\tif (CPU_LATENCY >= 0)\n\t\tcpu_latency_qos_add_request(&qos, CPU_LATENCY);\n\n\tintel_gt_pm_wait_for_idle(gt);\n\tsaved_work = rps->work.func;\n\trps->work.func = dummy_rps_work;\n\n\tfor_each_engine(engine, gt, id) {\n\t\tstruct i915_request *rq;\n\t\tstruct i915_vma *vma;\n\t\tu32 *cancel, *cntr;\n\t\tstruct {\n\t\t\tu64 count;\n\t\t\tint freq;\n\t\t} min, max;\n\n\t\tst_engine_heartbeat_disable(engine);\n\n\t\tvma = create_spin_counter(engine,\n\t\t\t\t\t  engine->kernel_context->vm, true,\n\t\t\t\t\t  &cancel, &cntr);\n\t\tif (IS_ERR(vma)) {\n\t\t\terr = PTR_ERR(vma);\n\t\t\tst_engine_heartbeat_enable(engine);\n\t\t\tbreak;\n\t\t}\n\n\t\trq = intel_engine_create_kernel_request(engine);\n\t\tif (IS_ERR(rq)) {\n\t\t\terr = PTR_ERR(rq);\n\t\t\tgoto err_vma;\n\t\t}\n\n\t\terr = i915_vma_move_to_active(vma, rq, 0);\n\t\tif (!err)\n\t\t\terr = rq->engine->emit_bb_start(rq,\n\t\t\t\t\t\t\ti915_vma_offset(vma),\n\t\t\t\t\t\t\tPAGE_SIZE, 0);\n\t\ti915_request_add(rq);\n\t\tif (err)\n\t\t\tgoto err_vma;\n\n\t\tif (wait_for(READ_ONCE(*cntr), 10)) {\n\t\t\tpr_err(\"%s: timed loop did not start\\n\",\n\t\t\t       engine->name);\n\t\t\tgoto err_vma;\n\t\t}\n\n\t\tmin.freq = rps->min_freq;\n\t\tmin.count = measure_frequency_at(rps, cntr, &min.freq);\n\n\t\tmax.freq = rps->max_freq;\n\t\tmax.count = measure_frequency_at(rps, cntr, &max.freq);\n\n\t\tpr_info(\"%s: min:%lluKHz @ %uMHz, max:%lluKHz @ %uMHz [%d%%]\\n\",\n\t\t\tengine->name,\n\t\t\tmin.count, intel_gpu_freq(rps, min.freq),\n\t\t\tmax.count, intel_gpu_freq(rps, max.freq),\n\t\t\t(int)DIV64_U64_ROUND_CLOSEST(100 * min.freq * max.count,\n\t\t\t\t\t\t     max.freq * min.count));\n\n\t\tif (!scaled_within(max.freq * min.count,\n\t\t\t\t   min.freq * max.count,\n\t\t\t\t   1, 2)) {\n\t\t\tint f;\n\n\t\t\tpr_err(\"%s: CS did not scale with frequency! scaled min:%llu, max:%llu\\n\",\n\t\t\t       engine->name,\n\t\t\t       max.freq * min.count,\n\t\t\t       min.freq * max.count);\n\t\t\tshow_pcu_config(rps);\n\n\t\t\tfor (f = min.freq + 1; f <= rps->max_freq; f++) {\n\t\t\t\tint act = f;\n\t\t\t\tu64 count;\n\n\t\t\t\tcount = measure_frequency_at(rps, cntr, &act);\n\t\t\t\tif (act < f)\n\t\t\t\t\tbreak;\n\n\t\t\t\tpr_info(\"%s: %x:%uMHz: %lluKHz [%d%%]\\n\",\n\t\t\t\t\tengine->name,\n\t\t\t\t\tact, intel_gpu_freq(rps, act), count,\n\t\t\t\t\t(int)DIV64_U64_ROUND_CLOSEST(100 * min.freq * count,\n\t\t\t\t\t\t\t\t     act * min.count));\n\n\t\t\t\tf = act;  \n\t\t\t}\n\n\t\t\terr = -EINTR;  \n\t\t}\n\nerr_vma:\n\t\t*cancel = MI_BATCH_BUFFER_END;\n\t\ti915_gem_object_flush_map(vma->obj);\n\t\ti915_gem_object_unpin_map(vma->obj);\n\t\ti915_vma_unpin(vma);\n\t\ti915_vma_unlock(vma);\n\t\ti915_vma_put(vma);\n\n\t\tst_engine_heartbeat_enable(engine);\n\t\tif (igt_flush_test(gt->i915))\n\t\t\terr = -EIO;\n\t\tif (err)\n\t\t\tbreak;\n\t}\n\n\tintel_gt_pm_wait_for_idle(gt);\n\trps->work.func = saved_work;\n\n\tif (CPU_LATENCY >= 0)\n\t\tcpu_latency_qos_remove_request(&qos);\n\n\treturn err;\n}\n\nstatic void sleep_for_ei(struct intel_rps *rps, int timeout_us)\n{\n\t \n\tusleep_range(timeout_us, 2 * timeout_us);\n\n\t \n\trps_disable_interrupts(rps);\n\tGEM_BUG_ON(rps->pm_iir);\n\trps_enable_interrupts(rps);\n\n\t \n\tusleep_range(2 * timeout_us, 3 * timeout_us);\n}\n\nstatic int __rps_up_interrupt(struct intel_rps *rps,\n\t\t\t      struct intel_engine_cs *engine,\n\t\t\t      struct igt_spinner *spin)\n{\n\tstruct intel_uncore *uncore = engine->uncore;\n\tstruct i915_request *rq;\n\tu32 timeout;\n\n\tif (!intel_engine_can_store_dword(engine))\n\t\treturn 0;\n\n\trps_set_check(rps, rps->min_freq);\n\n\trq = igt_spinner_create_request(spin, engine->kernel_context, MI_NOOP);\n\tif (IS_ERR(rq))\n\t\treturn PTR_ERR(rq);\n\n\ti915_request_get(rq);\n\ti915_request_add(rq);\n\n\tif (!igt_wait_for_spinner(spin, rq)) {\n\t\tpr_err(\"%s: RPS spinner did not start\\n\",\n\t\t       engine->name);\n\t\ti915_request_put(rq);\n\t\tintel_gt_set_wedged(engine->gt);\n\t\treturn -EIO;\n\t}\n\n\tif (!intel_rps_is_active(rps)) {\n\t\tpr_err(\"%s: RPS not enabled on starting spinner\\n\",\n\t\t       engine->name);\n\t\tigt_spinner_end(spin);\n\t\ti915_request_put(rq);\n\t\treturn -EINVAL;\n\t}\n\n\tif (!(rps->pm_events & GEN6_PM_RP_UP_THRESHOLD)) {\n\t\tpr_err(\"%s: RPS did not register UP interrupt\\n\",\n\t\t       engine->name);\n\t\ti915_request_put(rq);\n\t\treturn -EINVAL;\n\t}\n\n\tif (rps->last_freq != rps->min_freq) {\n\t\tpr_err(\"%s: RPS did not program min frequency\\n\",\n\t\t       engine->name);\n\t\ti915_request_put(rq);\n\t\treturn -EINVAL;\n\t}\n\n\ttimeout = intel_uncore_read(uncore, GEN6_RP_UP_EI);\n\ttimeout = intel_gt_pm_interval_to_ns(engine->gt, timeout);\n\ttimeout = DIV_ROUND_UP(timeout, 1000);\n\n\tsleep_for_ei(rps, timeout);\n\tGEM_BUG_ON(i915_request_completed(rq));\n\n\tigt_spinner_end(spin);\n\ti915_request_put(rq);\n\n\tif (rps->cur_freq != rps->min_freq) {\n\t\tpr_err(\"%s: Frequency unexpectedly changed [up], now %d!\\n\",\n\t\t       engine->name, intel_rps_read_actual_frequency(rps));\n\t\treturn -EINVAL;\n\t}\n\n\tif (!(rps->pm_iir & GEN6_PM_RP_UP_THRESHOLD)) {\n\t\tpr_err(\"%s: UP interrupt not recorded for spinner, pm_iir:%x, prev_up:%x, up_threshold:%x, up_ei:%x\\n\",\n\t\t       engine->name, rps->pm_iir,\n\t\t       intel_uncore_read(uncore, GEN6_RP_PREV_UP),\n\t\t       intel_uncore_read(uncore, GEN6_RP_UP_THRESHOLD),\n\t\t       intel_uncore_read(uncore, GEN6_RP_UP_EI));\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int __rps_down_interrupt(struct intel_rps *rps,\n\t\t\t\tstruct intel_engine_cs *engine)\n{\n\tstruct intel_uncore *uncore = engine->uncore;\n\tu32 timeout;\n\n\trps_set_check(rps, rps->max_freq);\n\n\tif (!(rps->pm_events & GEN6_PM_RP_DOWN_THRESHOLD)) {\n\t\tpr_err(\"%s: RPS did not register DOWN interrupt\\n\",\n\t\t       engine->name);\n\t\treturn -EINVAL;\n\t}\n\n\tif (rps->last_freq != rps->max_freq) {\n\t\tpr_err(\"%s: RPS did not program max frequency\\n\",\n\t\t       engine->name);\n\t\treturn -EINVAL;\n\t}\n\n\ttimeout = intel_uncore_read(uncore, GEN6_RP_DOWN_EI);\n\ttimeout = intel_gt_pm_interval_to_ns(engine->gt, timeout);\n\ttimeout = DIV_ROUND_UP(timeout, 1000);\n\n\tsleep_for_ei(rps, timeout);\n\n\tif (rps->cur_freq != rps->max_freq) {\n\t\tpr_err(\"%s: Frequency unexpectedly changed [down], now %d!\\n\",\n\t\t       engine->name,\n\t\t       intel_rps_read_actual_frequency(rps));\n\t\treturn -EINVAL;\n\t}\n\n\tif (!(rps->pm_iir & (GEN6_PM_RP_DOWN_THRESHOLD | GEN6_PM_RP_DOWN_TIMEOUT))) {\n\t\tpr_err(\"%s: DOWN interrupt not recorded for idle, pm_iir:%x, prev_down:%x, down_threshold:%x, down_ei:%x [prev_up:%x, up_threshold:%x, up_ei:%x]\\n\",\n\t\t       engine->name, rps->pm_iir,\n\t\t       intel_uncore_read(uncore, GEN6_RP_PREV_DOWN),\n\t\t       intel_uncore_read(uncore, GEN6_RP_DOWN_THRESHOLD),\n\t\t       intel_uncore_read(uncore, GEN6_RP_DOWN_EI),\n\t\t       intel_uncore_read(uncore, GEN6_RP_PREV_UP),\n\t\t       intel_uncore_read(uncore, GEN6_RP_UP_THRESHOLD),\n\t\t       intel_uncore_read(uncore, GEN6_RP_UP_EI));\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nint live_rps_interrupt(void *arg)\n{\n\tstruct intel_gt *gt = arg;\n\tstruct intel_rps *rps = &gt->rps;\n\tvoid (*saved_work)(struct work_struct *wrk);\n\tstruct intel_engine_cs *engine;\n\tenum intel_engine_id id;\n\tstruct igt_spinner spin;\n\tu32 pm_events;\n\tint err = 0;\n\n\t \n\n\tif (!intel_rps_has_interrupts(rps) || GRAPHICS_VER(gt->i915) < 6)\n\t\treturn 0;\n\n\tintel_gt_pm_get(gt);\n\tpm_events = rps->pm_events;\n\tintel_gt_pm_put(gt);\n\tif (!pm_events) {\n\t\tpr_err(\"No RPS PM events registered, but RPS is enabled?\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tif (igt_spinner_init(&spin, gt))\n\t\treturn -ENOMEM;\n\n\tintel_gt_pm_wait_for_idle(gt);\n\tsaved_work = rps->work.func;\n\trps->work.func = dummy_rps_work;\n\n\tfor_each_engine(engine, gt, id) {\n\t\t \n\t\tif (pm_events & GEN6_PM_RP_UP_THRESHOLD) {\n\t\t\tintel_gt_pm_wait_for_idle(engine->gt);\n\t\t\tGEM_BUG_ON(intel_rps_is_active(rps));\n\n\t\t\tst_engine_heartbeat_disable(engine);\n\n\t\t\terr = __rps_up_interrupt(rps, engine, &spin);\n\n\t\t\tst_engine_heartbeat_enable(engine);\n\t\t\tif (err)\n\t\t\t\tgoto out;\n\n\t\t\tintel_gt_pm_wait_for_idle(engine->gt);\n\t\t}\n\n\t\t \n\t\tif (pm_events & GEN6_PM_RP_DOWN_THRESHOLD) {\n\t\t\tst_engine_heartbeat_disable(engine);\n\t\t\tintel_rc6_disable(&gt->rc6);\n\n\t\t\terr = __rps_down_interrupt(rps, engine);\n\n\t\t\tintel_rc6_enable(&gt->rc6);\n\t\t\tst_engine_heartbeat_enable(engine);\n\t\t\tif (err)\n\t\t\t\tgoto out;\n\t\t}\n\t}\n\nout:\n\tif (igt_flush_test(gt->i915))\n\t\terr = -EIO;\n\n\tigt_spinner_fini(&spin);\n\n\tintel_gt_pm_wait_for_idle(gt);\n\trps->work.func = saved_work;\n\n\treturn err;\n}\n\nstatic u64 __measure_power(int duration_ms)\n{\n\tu64 dE, dt;\n\n\tdE = librapl_energy_uJ();\n\tdt = ktime_get();\n\tusleep_range(1000 * duration_ms, 2000 * duration_ms);\n\tdE = librapl_energy_uJ() - dE;\n\tdt = ktime_get() - dt;\n\n\treturn div64_u64(1000 * 1000 * dE, dt);\n}\n\nstatic u64 measure_power(struct intel_rps *rps, int *freq)\n{\n\tu64 x[5];\n\tint i;\n\n\tfor (i = 0; i < 5; i++)\n\t\tx[i] = __measure_power(5);\n\n\t*freq = (*freq + intel_rps_read_actual_frequency(rps)) / 2;\n\n\t \n\tsort(x, 5, sizeof(*x), cmp_u64, NULL);\n\treturn div_u64(x[1] + 2 * x[2] + x[3], 4);\n}\n\nstatic u64 measure_power_at(struct intel_rps *rps, int *freq)\n{\n\t*freq = rps_set_check(rps, *freq);\n\treturn measure_power(rps, freq);\n}\n\nint live_rps_power(void *arg)\n{\n\tstruct intel_gt *gt = arg;\n\tstruct intel_rps *rps = &gt->rps;\n\tvoid (*saved_work)(struct work_struct *wrk);\n\tstruct intel_engine_cs *engine;\n\tenum intel_engine_id id;\n\tstruct igt_spinner spin;\n\tint err = 0;\n\n\t \n\n\tif (!intel_rps_is_enabled(rps) || GRAPHICS_VER(gt->i915) < 6)\n\t\treturn 0;\n\n\tif (!librapl_supported(gt->i915))\n\t\treturn 0;\n\n\tif (igt_spinner_init(&spin, gt))\n\t\treturn -ENOMEM;\n\n\tintel_gt_pm_wait_for_idle(gt);\n\tsaved_work = rps->work.func;\n\trps->work.func = dummy_rps_work;\n\n\tfor_each_engine(engine, gt, id) {\n\t\tstruct i915_request *rq;\n\t\tstruct {\n\t\t\tu64 power;\n\t\t\tint freq;\n\t\t} min, max;\n\n\t\tif (!intel_engine_can_store_dword(engine))\n\t\t\tcontinue;\n\n\t\tst_engine_heartbeat_disable(engine);\n\n\t\trq = igt_spinner_create_request(&spin,\n\t\t\t\t\t\tengine->kernel_context,\n\t\t\t\t\t\tMI_NOOP);\n\t\tif (IS_ERR(rq)) {\n\t\t\tst_engine_heartbeat_enable(engine);\n\t\t\terr = PTR_ERR(rq);\n\t\t\tbreak;\n\t\t}\n\n\t\ti915_request_add(rq);\n\n\t\tif (!igt_wait_for_spinner(&spin, rq)) {\n\t\t\tpr_err(\"%s: RPS spinner did not start\\n\",\n\t\t\t       engine->name);\n\t\t\tigt_spinner_end(&spin);\n\t\t\tst_engine_heartbeat_enable(engine);\n\t\t\tintel_gt_set_wedged(engine->gt);\n\t\t\terr = -EIO;\n\t\t\tbreak;\n\t\t}\n\n\t\tmax.freq = rps->max_freq;\n\t\tmax.power = measure_power_at(rps, &max.freq);\n\n\t\tmin.freq = rps->min_freq;\n\t\tmin.power = measure_power_at(rps, &min.freq);\n\n\t\tigt_spinner_end(&spin);\n\t\tst_engine_heartbeat_enable(engine);\n\n\t\tpr_info(\"%s: min:%llumW @ %uMHz, max:%llumW @ %uMHz\\n\",\n\t\t\tengine->name,\n\t\t\tmin.power, intel_gpu_freq(rps, min.freq),\n\t\t\tmax.power, intel_gpu_freq(rps, max.freq));\n\n\t\tif (10 * min.freq >= 9 * max.freq) {\n\t\t\tpr_notice(\"Could not control frequency, ran at [%d:%uMHz, %d:%uMhz]\\n\",\n\t\t\t\t  min.freq, intel_gpu_freq(rps, min.freq),\n\t\t\t\t  max.freq, intel_gpu_freq(rps, max.freq));\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (11 * min.power > 10 * max.power) {\n\t\t\tpr_err(\"%s: did not conserve power when setting lower frequency!\\n\",\n\t\t\t       engine->name);\n\t\t\terr = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (igt_flush_test(gt->i915)) {\n\t\t\terr = -EIO;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tigt_spinner_fini(&spin);\n\n\tintel_gt_pm_wait_for_idle(gt);\n\trps->work.func = saved_work;\n\n\treturn err;\n}\n\nint live_rps_dynamic(void *arg)\n{\n\tstruct intel_gt *gt = arg;\n\tstruct intel_rps *rps = &gt->rps;\n\tstruct intel_engine_cs *engine;\n\tenum intel_engine_id id;\n\tstruct igt_spinner spin;\n\tint err = 0;\n\n\t \n\n\tif (!intel_rps_is_enabled(rps) || GRAPHICS_VER(gt->i915) < 6)\n\t\treturn 0;\n\n\tif (igt_spinner_init(&spin, gt))\n\t\treturn -ENOMEM;\n\n\tif (intel_rps_has_interrupts(rps))\n\t\tpr_info(\"RPS has interrupt support\\n\");\n\tif (intel_rps_uses_timer(rps))\n\t\tpr_info(\"RPS has timer support\\n\");\n\n\tfor_each_engine(engine, gt, id) {\n\t\tstruct i915_request *rq;\n\t\tstruct {\n\t\t\tktime_t dt;\n\t\t\tu8 freq;\n\t\t} min, max;\n\n\t\tif (!intel_engine_can_store_dword(engine))\n\t\t\tcontinue;\n\n\t\tintel_gt_pm_wait_for_idle(gt);\n\t\tGEM_BUG_ON(intel_rps_is_active(rps));\n\t\trps->cur_freq = rps->min_freq;\n\n\t\tintel_engine_pm_get(engine);\n\t\tintel_rc6_disable(&gt->rc6);\n\t\tGEM_BUG_ON(rps->last_freq != rps->min_freq);\n\n\t\trq = igt_spinner_create_request(&spin,\n\t\t\t\t\t\tengine->kernel_context,\n\t\t\t\t\t\tMI_NOOP);\n\t\tif (IS_ERR(rq)) {\n\t\t\terr = PTR_ERR(rq);\n\t\t\tgoto err;\n\t\t}\n\n\t\ti915_request_add(rq);\n\n\t\tmax.dt = ktime_get();\n\t\tmax.freq = wait_for_freq(rps, rps->max_freq, 500);\n\t\tmax.dt = ktime_sub(ktime_get(), max.dt);\n\n\t\tigt_spinner_end(&spin);\n\n\t\tmin.dt = ktime_get();\n\t\tmin.freq = wait_for_freq(rps, rps->min_freq, 2000);\n\t\tmin.dt = ktime_sub(ktime_get(), min.dt);\n\n\t\tpr_info(\"%s: dynamically reclocked to %u:%uMHz while busy in %lluns, and %u:%uMHz while idle in %lluns\\n\",\n\t\t\tengine->name,\n\t\t\tmax.freq, intel_gpu_freq(rps, max.freq),\n\t\t\tktime_to_ns(max.dt),\n\t\t\tmin.freq, intel_gpu_freq(rps, min.freq),\n\t\t\tktime_to_ns(min.dt));\n\t\tif (min.freq >= max.freq) {\n\t\t\tpr_err(\"%s: dynamic reclocking of spinner failed\\n!\",\n\t\t\t       engine->name);\n\t\t\terr = -EINVAL;\n\t\t}\n\nerr:\n\t\tintel_rc6_enable(&gt->rc6);\n\t\tintel_engine_pm_put(engine);\n\n\t\tif (igt_flush_test(gt->i915))\n\t\t\terr = -EIO;\n\t\tif (err)\n\t\t\tbreak;\n\t}\n\n\tigt_spinner_fini(&spin);\n\n\treturn err;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}