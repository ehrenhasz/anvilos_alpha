{
  "module_name": "intel_engine_user.c",
  "hash_id": "829ebf6fe995c09db792255111ecfe0abdcfec25c821472bc9c4373c8fa15f87",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/i915/gt/intel_engine_user.c",
  "human_readable_source": "\n \n\n#include <linux/list.h>\n#include <linux/list_sort.h>\n#include <linux/llist.h>\n\n#include \"i915_drv.h\"\n#include \"intel_engine.h\"\n#include \"intel_engine_user.h\"\n#include \"intel_gt.h\"\n#include \"uc/intel_guc_submission.h\"\n\nstruct intel_engine_cs *\nintel_engine_lookup_user(struct drm_i915_private *i915, u8 class, u8 instance)\n{\n\tstruct rb_node *p = i915->uabi_engines.rb_node;\n\n\twhile (p) {\n\t\tstruct intel_engine_cs *it =\n\t\t\trb_entry(p, typeof(*it), uabi_node);\n\n\t\tif (class < it->uabi_class)\n\t\t\tp = p->rb_left;\n\t\telse if (class > it->uabi_class ||\n\t\t\t instance > it->uabi_instance)\n\t\t\tp = p->rb_right;\n\t\telse if (instance < it->uabi_instance)\n\t\t\tp = p->rb_left;\n\t\telse\n\t\t\treturn it;\n\t}\n\n\treturn NULL;\n}\n\nvoid intel_engine_add_user(struct intel_engine_cs *engine)\n{\n\tllist_add((struct llist_node *)&engine->uabi_node,\n\t\t  (struct llist_head *)&engine->i915->uabi_engines);\n}\n\n#define I915_NO_UABI_CLASS ((u16)(-1))\n\nstatic const u16 uabi_classes[] = {\n\t[RENDER_CLASS] = I915_ENGINE_CLASS_RENDER,\n\t[COPY_ENGINE_CLASS] = I915_ENGINE_CLASS_COPY,\n\t[VIDEO_DECODE_CLASS] = I915_ENGINE_CLASS_VIDEO,\n\t[VIDEO_ENHANCEMENT_CLASS] = I915_ENGINE_CLASS_VIDEO_ENHANCE,\n\t[COMPUTE_CLASS] = I915_ENGINE_CLASS_COMPUTE,\n\t[OTHER_CLASS] = I915_NO_UABI_CLASS,  \n};\n\nstatic int engine_cmp(void *priv, const struct list_head *A,\n\t\t      const struct list_head *B)\n{\n\tconst struct intel_engine_cs *a =\n\t\tcontainer_of((struct rb_node *)A, typeof(*a), uabi_node);\n\tconst struct intel_engine_cs *b =\n\t\tcontainer_of((struct rb_node *)B, typeof(*b), uabi_node);\n\n\tif (uabi_classes[a->class] < uabi_classes[b->class])\n\t\treturn -1;\n\tif (uabi_classes[a->class] > uabi_classes[b->class])\n\t\treturn 1;\n\n\tif (a->instance < b->instance)\n\t\treturn -1;\n\tif (a->instance > b->instance)\n\t\treturn 1;\n\n\treturn 0;\n}\n\nstatic struct llist_node *get_engines(struct drm_i915_private *i915)\n{\n\treturn llist_del_all((struct llist_head *)&i915->uabi_engines);\n}\n\nstatic void sort_engines(struct drm_i915_private *i915,\n\t\t\t struct list_head *engines)\n{\n\tstruct llist_node *pos, *next;\n\n\tllist_for_each_safe(pos, next, get_engines(i915)) {\n\t\tstruct intel_engine_cs *engine =\n\t\t\tcontainer_of((struct rb_node *)pos, typeof(*engine),\n\t\t\t\t     uabi_node);\n\t\tlist_add((struct list_head *)&engine->uabi_node, engines);\n\t}\n\tlist_sort(NULL, engines, engine_cmp);\n}\n\nstatic void set_scheduler_caps(struct drm_i915_private *i915)\n{\n\tstatic const struct {\n\t\tu8 engine;\n\t\tu8 sched;\n\t} map[] = {\n#define MAP(x, y) { ilog2(I915_ENGINE_##x), ilog2(I915_SCHEDULER_CAP_##y) }\n\t\tMAP(HAS_PREEMPTION, PREEMPTION),\n\t\tMAP(HAS_SEMAPHORES, SEMAPHORES),\n\t\tMAP(SUPPORTS_STATS, ENGINE_BUSY_STATS),\n#undef MAP\n\t};\n\tstruct intel_engine_cs *engine;\n\tu32 enabled, disabled;\n\n\tenabled = 0;\n\tdisabled = 0;\n\tfor_each_uabi_engine(engine, i915) {  \n\t\tint i;\n\n\t\tif (engine->sched_engine->schedule)\n\t\t\tenabled |= (I915_SCHEDULER_CAP_ENABLED |\n\t\t\t\t    I915_SCHEDULER_CAP_PRIORITY);\n\t\telse\n\t\t\tdisabled |= (I915_SCHEDULER_CAP_ENABLED |\n\t\t\t\t     I915_SCHEDULER_CAP_PRIORITY);\n\n\t\tif (intel_uc_uses_guc_submission(&engine->gt->uc))\n\t\t\tenabled |= I915_SCHEDULER_CAP_STATIC_PRIORITY_MAP;\n\n\t\tfor (i = 0; i < ARRAY_SIZE(map); i++) {\n\t\t\tif (engine->flags & BIT(map[i].engine))\n\t\t\t\tenabled |= BIT(map[i].sched);\n\t\t\telse\n\t\t\t\tdisabled |= BIT(map[i].sched);\n\t\t}\n\t}\n\n\ti915->caps.scheduler = enabled & ~disabled;\n\tif (!(i915->caps.scheduler & I915_SCHEDULER_CAP_ENABLED))\n\t\ti915->caps.scheduler = 0;\n}\n\nconst char *intel_engine_class_repr(u8 class)\n{\n\tstatic const char * const uabi_names[] = {\n\t\t[RENDER_CLASS] = \"rcs\",\n\t\t[COPY_ENGINE_CLASS] = \"bcs\",\n\t\t[VIDEO_DECODE_CLASS] = \"vcs\",\n\t\t[VIDEO_ENHANCEMENT_CLASS] = \"vecs\",\n\t\t[OTHER_CLASS] = \"other\",\n\t\t[COMPUTE_CLASS] = \"ccs\",\n\t};\n\n\tif (class >= ARRAY_SIZE(uabi_names) || !uabi_names[class])\n\t\treturn \"xxx\";\n\n\treturn uabi_names[class];\n}\n\nstruct legacy_ring {\n\tstruct intel_gt *gt;\n\tu8 class;\n\tu8 instance;\n};\n\nstatic int legacy_ring_idx(const struct legacy_ring *ring)\n{\n\tstatic const struct {\n\t\tu8 base, max;\n\t} map[] = {\n\t\t[RENDER_CLASS] = { RCS0, 1 },\n\t\t[COPY_ENGINE_CLASS] = { BCS0, 1 },\n\t\t[VIDEO_DECODE_CLASS] = { VCS0, I915_MAX_VCS },\n\t\t[VIDEO_ENHANCEMENT_CLASS] = { VECS0, I915_MAX_VECS },\n\t\t[COMPUTE_CLASS] = { CCS0, I915_MAX_CCS },\n\t};\n\n\tif (GEM_DEBUG_WARN_ON(ring->class >= ARRAY_SIZE(map)))\n\t\treturn INVALID_ENGINE;\n\n\tif (GEM_DEBUG_WARN_ON(ring->instance >= map[ring->class].max))\n\t\treturn INVALID_ENGINE;\n\n\treturn map[ring->class].base + ring->instance;\n}\n\nstatic void add_legacy_ring(struct legacy_ring *ring,\n\t\t\t    struct intel_engine_cs *engine)\n{\n\tif (engine->gt != ring->gt || engine->class != ring->class) {\n\t\tring->gt = engine->gt;\n\t\tring->class = engine->class;\n\t\tring->instance = 0;\n\t}\n\n\tengine->legacy_idx = legacy_ring_idx(ring);\n\tif (engine->legacy_idx != INVALID_ENGINE)\n\t\tring->instance++;\n}\n\nstatic void engine_rename(struct intel_engine_cs *engine, const char *name, u16 instance)\n{\n\tchar old[sizeof(engine->name)];\n\n\tmemcpy(old, engine->name, sizeof(engine->name));\n\tscnprintf(engine->name, sizeof(engine->name), \"%s%u\", name, instance);\n\tdrm_dbg(&engine->i915->drm, \"renamed %s to %s\\n\", old, engine->name);\n}\n\nvoid intel_engines_driver_register(struct drm_i915_private *i915)\n{\n\tu16 name_instance, other_instance = 0;\n\tstruct legacy_ring ring = {};\n\tstruct list_head *it, *next;\n\tstruct rb_node **p, *prev;\n\tLIST_HEAD(engines);\n\n\tsort_engines(i915, &engines);\n\n\tprev = NULL;\n\tp = &i915->uabi_engines.rb_node;\n\tlist_for_each_safe(it, next, &engines) {\n\t\tstruct intel_engine_cs *engine =\n\t\t\tcontainer_of((struct rb_node *)it, typeof(*engine),\n\t\t\t\t     uabi_node);\n\n\t\tif (intel_gt_has_unrecoverable_error(engine->gt))\n\t\t\tcontinue;  \n\n\t\tGEM_BUG_ON(engine->class >= ARRAY_SIZE(uabi_classes));\n\t\tengine->uabi_class = uabi_classes[engine->class];\n\t\tif (engine->uabi_class == I915_NO_UABI_CLASS) {\n\t\t\tname_instance = other_instance++;\n\t\t} else {\n\t\t\tGEM_BUG_ON(engine->uabi_class >=\n\t\t\t\t   ARRAY_SIZE(i915->engine_uabi_class_count));\n\t\t\tname_instance =\n\t\t\t\ti915->engine_uabi_class_count[engine->uabi_class]++;\n\t\t}\n\t\tengine->uabi_instance = name_instance;\n\n\t\t \n\t\tengine_rename(engine,\n\t\t\t      intel_engine_class_repr(engine->class),\n\t\t\t      name_instance);\n\n\t\tif (engine->uabi_class == I915_NO_UABI_CLASS)\n\t\t\tcontinue;\n\n\t\trb_link_node(&engine->uabi_node, prev, p);\n\t\trb_insert_color(&engine->uabi_node, &i915->uabi_engines);\n\n\t\tGEM_BUG_ON(intel_engine_lookup_user(i915,\n\t\t\t\t\t\t    engine->uabi_class,\n\t\t\t\t\t\t    engine->uabi_instance) != engine);\n\n\t\t \n\t\tadd_legacy_ring(&ring, engine);\n\n\t\tprev = &engine->uabi_node;\n\t\tp = &prev->rb_right;\n\t}\n\n\tif (IS_ENABLED(CONFIG_DRM_I915_SELFTESTS) &&\n\t    IS_ENABLED(CONFIG_DRM_I915_DEBUG_GEM)) {\n\t\tstruct intel_engine_cs *engine;\n\t\tunsigned int isolation;\n\t\tint class, inst;\n\t\tint errors = 0;\n\n\t\tfor (class = 0; class < ARRAY_SIZE(i915->engine_uabi_class_count); class++) {\n\t\t\tfor (inst = 0; inst < i915->engine_uabi_class_count[class]; inst++) {\n\t\t\t\tengine = intel_engine_lookup_user(i915,\n\t\t\t\t\t\t\t\t  class, inst);\n\t\t\t\tif (!engine) {\n\t\t\t\t\tpr_err(\"UABI engine not found for { class:%d, instance:%d }\\n\",\n\t\t\t\t\t       class, inst);\n\t\t\t\t\terrors++;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tif (engine->uabi_class != class ||\n\t\t\t\t    engine->uabi_instance != inst) {\n\t\t\t\t\tpr_err(\"Wrong UABI engine:%s { class:%d, instance:%d } found for { class:%d, instance:%d }\\n\",\n\t\t\t\t\t       engine->name,\n\t\t\t\t\t       engine->uabi_class,\n\t\t\t\t\t       engine->uabi_instance,\n\t\t\t\t\t       class, inst);\n\t\t\t\t\terrors++;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t \n\t\tisolation = intel_engines_has_context_isolation(i915);\n\t\tfor_each_uabi_engine(engine, i915) {\n\t\t\tunsigned int bit = BIT(engine->uabi_class);\n\t\t\tunsigned int expected = engine->default_state ? bit : 0;\n\n\t\t\tif ((isolation & bit) != expected) {\n\t\t\t\tpr_err(\"mismatching default context state for class %d on engine %s\\n\",\n\t\t\t\t       engine->uabi_class, engine->name);\n\t\t\t\terrors++;\n\t\t\t}\n\t\t}\n\n\t\tif (drm_WARN(&i915->drm, errors,\n\t\t\t     \"Invalid UABI engine mapping found\"))\n\t\t\ti915->uabi_engines = RB_ROOT;\n\t}\n\n\tset_scheduler_caps(i915);\n}\n\nunsigned int intel_engines_has_context_isolation(struct drm_i915_private *i915)\n{\n\tstruct intel_engine_cs *engine;\n\tunsigned int which;\n\n\twhich = 0;\n\tfor_each_uabi_engine(engine, i915)\n\t\tif (engine->default_state)\n\t\t\twhich |= BIT(engine->uabi_class);\n\n\treturn which;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}