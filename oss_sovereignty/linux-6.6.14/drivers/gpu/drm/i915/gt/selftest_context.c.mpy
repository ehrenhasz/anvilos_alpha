{
  "module_name": "selftest_context.c",
  "hash_id": "52322583c72acd6510f54ff32d3e824484a1489b07838e2bebbfc178cd458b39",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/i915/gt/selftest_context.c",
  "human_readable_source": "\n \n\n#include \"i915_selftest.h\"\n#include \"intel_engine_heartbeat.h\"\n#include \"intel_engine_pm.h\"\n#include \"intel_gt.h\"\n\n#include \"gem/selftests/mock_context.h\"\n#include \"selftests/igt_flush_test.h\"\n#include \"selftests/mock_drm.h\"\n\nstatic int request_sync(struct i915_request *rq)\n{\n\tstruct intel_timeline *tl = i915_request_timeline(rq);\n\tlong timeout;\n\tint err = 0;\n\n\tintel_timeline_get(tl);\n\ti915_request_get(rq);\n\n\t \n\t__i915_request_commit(rq);\n\trq->sched.attr.priority = I915_PRIORITY_BARRIER;\n\t__i915_request_queue_bh(rq);\n\n\ttimeout = i915_request_wait(rq, 0, HZ / 10);\n\tif (timeout < 0)\n\t\terr = timeout;\n\telse\n\t\ti915_request_retire_upto(rq);\n\n\tlockdep_unpin_lock(&tl->mutex, rq->cookie);\n\tmutex_unlock(&tl->mutex);\n\n\ti915_request_put(rq);\n\tintel_timeline_put(tl);\n\n\treturn err;\n}\n\nstatic int context_sync(struct intel_context *ce)\n{\n\tstruct intel_timeline *tl = ce->timeline;\n\tint err = 0;\n\n\tmutex_lock(&tl->mutex);\n\tdo {\n\t\tstruct i915_request *rq;\n\t\tlong timeout;\n\n\t\tif (list_empty(&tl->requests))\n\t\t\tbreak;\n\n\t\trq = list_last_entry(&tl->requests, typeof(*rq), link);\n\t\ti915_request_get(rq);\n\n\t\ttimeout = i915_request_wait(rq, 0, HZ / 10);\n\t\tif (timeout < 0)\n\t\t\terr = timeout;\n\t\telse\n\t\t\ti915_request_retire_upto(rq);\n\n\t\ti915_request_put(rq);\n\t} while (!err);\n\tmutex_unlock(&tl->mutex);\n\n\t \n\ti915_active_unlock_wait(&ce->active);\n\treturn err;\n}\n\nstatic int __live_context_size(struct intel_engine_cs *engine)\n{\n\tstruct intel_context *ce;\n\tstruct i915_request *rq;\n\tvoid *vaddr;\n\tint err;\n\n\tce = intel_context_create(engine);\n\tif (IS_ERR(ce))\n\t\treturn PTR_ERR(ce);\n\n\terr = intel_context_pin(ce);\n\tif (err)\n\t\tgoto err;\n\n\tvaddr = i915_gem_object_pin_map_unlocked(ce->state->obj,\n\t\t\t\t\t\t intel_gt_coherent_map_type(engine->gt,\n\t\t\t\t\t\t\t\t\t    ce->state->obj,\n\t\t\t\t\t\t\t\t\t    false));\n\tif (IS_ERR(vaddr)) {\n\t\terr = PTR_ERR(vaddr);\n\t\tintel_context_unpin(ce);\n\t\tgoto err;\n\t}\n\n\t \n\tvaddr += engine->context_size - I915_GTT_PAGE_SIZE;\n\tmemset(vaddr, POISON_INUSE, I915_GTT_PAGE_SIZE);\n\n\trq = intel_context_create_request(ce);\n\tintel_context_unpin(ce);\n\tif (IS_ERR(rq)) {\n\t\terr = PTR_ERR(rq);\n\t\tgoto err_unpin;\n\t}\n\n\terr = request_sync(rq);\n\tif (err)\n\t\tgoto err_unpin;\n\n\t \n\trq = intel_engine_create_kernel_request(engine);\n\tif (IS_ERR(rq)) {\n\t\terr = PTR_ERR(rq);\n\t\tgoto err_unpin;\n\t}\n\terr = request_sync(rq);\n\tif (err)\n\t\tgoto err_unpin;\n\n\tif (memchr_inv(vaddr, POISON_INUSE, I915_GTT_PAGE_SIZE)) {\n\t\tpr_err(\"%s context overwrote trailing red-zone!\", engine->name);\n\t\terr = -EINVAL;\n\t}\n\nerr_unpin:\n\ti915_gem_object_unpin_map(ce->state->obj);\nerr:\n\tintel_context_put(ce);\n\treturn err;\n}\n\nstatic int live_context_size(void *arg)\n{\n\tstruct intel_gt *gt = arg;\n\tstruct intel_engine_cs *engine;\n\tenum intel_engine_id id;\n\tint err = 0;\n\n\t \n\n\tfor_each_engine(engine, gt, id) {\n\t\tstruct file *saved;\n\n\t\tif (!engine->context_size)\n\t\t\tcontinue;\n\n\t\tintel_engine_pm_get(engine);\n\n\t\t \n\t\tsaved = fetch_and_zero(&engine->default_state);\n\n\t\t \n\t\tengine->context_size += I915_GTT_PAGE_SIZE;\n\n\t\terr = __live_context_size(engine);\n\n\t\tengine->context_size -= I915_GTT_PAGE_SIZE;\n\n\t\tengine->default_state = saved;\n\n\t\tintel_engine_pm_put(engine);\n\n\t\tif (err)\n\t\t\tbreak;\n\t}\n\n\treturn err;\n}\n\nstatic int __live_active_context(struct intel_engine_cs *engine)\n{\n\tunsigned long saved_heartbeat;\n\tstruct intel_context *ce;\n\tint pass;\n\tint err;\n\n\t \n\tif (intel_engine_uses_guc(engine))\n\t\treturn 0;\n\n\tif (intel_engine_pm_is_awake(engine)) {\n\t\tpr_err(\"%s is awake before starting %s!\\n\",\n\t\t       engine->name, __func__);\n\t\treturn -EINVAL;\n\t}\n\n\tce = intel_context_create(engine);\n\tif (IS_ERR(ce))\n\t\treturn PTR_ERR(ce);\n\n\tsaved_heartbeat = engine->props.heartbeat_interval_ms;\n\tengine->props.heartbeat_interval_ms = 0;\n\n\tfor (pass = 0; pass <= 2; pass++) {\n\t\tstruct i915_request *rq;\n\n\t\tintel_engine_pm_get(engine);\n\n\t\trq = intel_context_create_request(ce);\n\t\tif (IS_ERR(rq)) {\n\t\t\terr = PTR_ERR(rq);\n\t\t\tgoto out_engine;\n\t\t}\n\n\t\terr = request_sync(rq);\n\t\tif (err)\n\t\t\tgoto out_engine;\n\n\t\t \n\t\tif (i915_active_is_idle(&ce->active)) {\n\t\t\tpr_err(\"context is not active; expected idle-barrier (%s pass %d)\\n\",\n\t\t\t       engine->name, pass);\n\t\t\terr = -EINVAL;\n\t\t\tgoto out_engine;\n\t\t}\n\n\t\tif (!intel_engine_pm_is_awake(engine)) {\n\t\t\tpr_err(\"%s is asleep before idle-barrier\\n\",\n\t\t\t       engine->name);\n\t\t\terr = -EINVAL;\n\t\t\tgoto out_engine;\n\t\t}\n\nout_engine:\n\t\tintel_engine_pm_put(engine);\n\t\tif (err)\n\t\t\tgoto err;\n\t}\n\n\t \n\terr = intel_engine_flush_barriers(engine);\n\tif (err)\n\t\tgoto err;\n\n\t \n\terr = context_sync(engine->kernel_context);\n\tif (err)\n\t\tgoto err;\n\n\tif (!i915_active_is_idle(&ce->active)) {\n\t\tpr_err(\"context is still active!\");\n\t\terr = -EINVAL;\n\t}\n\n\tintel_engine_pm_flush(engine);\n\n\tif (intel_engine_pm_is_awake(engine)) {\n\t\tstruct drm_printer p = drm_debug_printer(__func__);\n\n\t\tintel_engine_dump(engine, &p,\n\t\t\t\t  \"%s is still awake:%d after idle-barriers\\n\",\n\t\t\t\t  engine->name,\n\t\t\t\t  atomic_read(&engine->wakeref.count));\n\t\tGEM_TRACE_DUMP();\n\n\t\terr = -EINVAL;\n\t\tgoto err;\n\t}\n\nerr:\n\tengine->props.heartbeat_interval_ms = saved_heartbeat;\n\tintel_context_put(ce);\n\treturn err;\n}\n\nstatic int live_active_context(void *arg)\n{\n\tstruct intel_gt *gt = arg;\n\tstruct intel_engine_cs *engine;\n\tenum intel_engine_id id;\n\tint err = 0;\n\n\tfor_each_engine(engine, gt, id) {\n\t\terr = __live_active_context(engine);\n\t\tif (err)\n\t\t\tbreak;\n\n\t\terr = igt_flush_test(gt->i915);\n\t\tif (err)\n\t\t\tbreak;\n\t}\n\n\treturn err;\n}\n\nstatic int __remote_sync(struct intel_context *ce, struct intel_context *remote)\n{\n\tstruct i915_request *rq;\n\tint err;\n\n\terr = intel_context_pin(remote);\n\tif (err)\n\t\treturn err;\n\n\trq = intel_context_create_request(ce);\n\tif (IS_ERR(rq)) {\n\t\terr = PTR_ERR(rq);\n\t\tgoto unpin;\n\t}\n\n\terr = intel_context_prepare_remote_request(remote, rq);\n\tif (err) {\n\t\ti915_request_add(rq);\n\t\tgoto unpin;\n\t}\n\n\terr = request_sync(rq);\n\nunpin:\n\tintel_context_unpin(remote);\n\treturn err;\n}\n\nstatic int __live_remote_context(struct intel_engine_cs *engine)\n{\n\tstruct intel_context *local, *remote;\n\tunsigned long saved_heartbeat;\n\tint pass;\n\tint err;\n\n\t \n\tif (intel_engine_uses_guc(engine))\n\t\treturn 0;\n\n\tif (intel_engine_pm_is_awake(engine)) {\n\t\tpr_err(\"%s is awake before starting %s!\\n\",\n\t\t       engine->name, __func__);\n\t\treturn -EINVAL;\n\t}\n\n\tremote = intel_context_create(engine);\n\tif (IS_ERR(remote))\n\t\treturn PTR_ERR(remote);\n\n\tlocal = intel_context_create(engine);\n\tif (IS_ERR(local)) {\n\t\terr = PTR_ERR(local);\n\t\tgoto err_remote;\n\t}\n\n\tsaved_heartbeat = engine->props.heartbeat_interval_ms;\n\tengine->props.heartbeat_interval_ms = 0;\n\tintel_engine_pm_get(engine);\n\n\tfor (pass = 0; pass <= 2; pass++) {\n\t\terr = __remote_sync(local, remote);\n\t\tif (err)\n\t\t\tbreak;\n\n\t\terr = __remote_sync(engine->kernel_context, remote);\n\t\tif (err)\n\t\t\tbreak;\n\n\t\tif (i915_active_is_idle(&remote->active)) {\n\t\t\tpr_err(\"remote context is not active; expected idle-barrier (%s pass %d)\\n\",\n\t\t\t       engine->name, pass);\n\t\t\terr = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tintel_engine_pm_put(engine);\n\tengine->props.heartbeat_interval_ms = saved_heartbeat;\n\n\tintel_context_put(local);\nerr_remote:\n\tintel_context_put(remote);\n\treturn err;\n}\n\nstatic int live_remote_context(void *arg)\n{\n\tstruct intel_gt *gt = arg;\n\tstruct intel_engine_cs *engine;\n\tenum intel_engine_id id;\n\tint err = 0;\n\n\tfor_each_engine(engine, gt, id) {\n\t\terr = __live_remote_context(engine);\n\t\tif (err)\n\t\t\tbreak;\n\n\t\terr = igt_flush_test(gt->i915);\n\t\tif (err)\n\t\t\tbreak;\n\t}\n\n\treturn err;\n}\n\nint intel_context_live_selftests(struct drm_i915_private *i915)\n{\n\tstatic const struct i915_subtest tests[] = {\n\t\tSUBTEST(live_context_size),\n\t\tSUBTEST(live_active_context),\n\t\tSUBTEST(live_remote_context),\n\t};\n\tstruct intel_gt *gt = to_gt(i915);\n\n\tif (intel_gt_is_wedged(gt))\n\t\treturn 0;\n\n\treturn intel_gt_live_subtests(tests, gt);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}