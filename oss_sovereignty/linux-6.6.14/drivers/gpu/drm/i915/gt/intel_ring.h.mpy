{
  "module_name": "intel_ring.h",
  "hash_id": "483e4dfa1cdd1c0a5442e540a4c9902f29a3535d55e2de63f702a5e7e55c0f46",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/i915/gt/intel_ring.h",
  "human_readable_source": " \n \n\n#ifndef INTEL_RING_H\n#define INTEL_RING_H\n\n#include \"i915_gem.h\"  \n#include \"i915_request.h\"\n#include \"intel_ring_types.h\"\n\nstruct intel_engine_cs;\n\nstruct intel_ring *\nintel_engine_create_ring(struct intel_engine_cs *engine, int size);\n\nu32 *intel_ring_begin(struct i915_request *rq, unsigned int num_dwords);\nint intel_ring_cacheline_align(struct i915_request *rq);\n\nunsigned int intel_ring_update_space(struct intel_ring *ring);\n\nvoid __intel_ring_pin(struct intel_ring *ring);\nint intel_ring_pin(struct intel_ring *ring, struct i915_gem_ww_ctx *ww);\nvoid intel_ring_unpin(struct intel_ring *ring);\nvoid intel_ring_reset(struct intel_ring *ring, u32 tail);\n\nvoid intel_ring_free(struct kref *ref);\n\nstatic inline struct intel_ring *intel_ring_get(struct intel_ring *ring)\n{\n\tkref_get(&ring->ref);\n\treturn ring;\n}\n\nstatic inline void intel_ring_put(struct intel_ring *ring)\n{\n\tkref_put(&ring->ref, intel_ring_free);\n}\n\nstatic inline void intel_ring_advance(struct i915_request *rq, u32 *cs)\n{\n\t \n\tGEM_BUG_ON((rq->ring->vaddr + rq->ring->emit) != cs);\n\tGEM_BUG_ON(!IS_ALIGNED(rq->ring->emit, 8));  \n}\n\nstatic inline u32 intel_ring_wrap(const struct intel_ring *ring, u32 pos)\n{\n\treturn pos & (ring->size - 1);\n}\n\nstatic inline int intel_ring_direction(const struct intel_ring *ring,\n\t\t\t\t       u32 next, u32 prev)\n{\n\ttypecheck(typeof(ring->size), next);\n\ttypecheck(typeof(ring->size), prev);\n\treturn (next - prev) << ring->wrap;\n}\n\nstatic inline bool\nintel_ring_offset_valid(const struct intel_ring *ring,\n\t\t\tunsigned int pos)\n{\n\tif (pos & -ring->size)  \n\t\treturn false;\n\n\tif (!IS_ALIGNED(pos, 8))  \n\t\treturn false;\n\n\treturn true;\n}\n\nstatic inline u32 intel_ring_offset(const struct i915_request *rq, void *addr)\n{\n\t \n\tu32 offset = addr - rq->ring->vaddr;\n\n\tGEM_BUG_ON(offset > rq->ring->size);\n\treturn intel_ring_wrap(rq->ring, offset);\n}\n\nstatic inline void\nassert_ring_tail_valid(const struct intel_ring *ring, unsigned int tail)\n{\n\tunsigned int head = READ_ONCE(ring->head);\n\n\tGEM_BUG_ON(!intel_ring_offset_valid(ring, tail));\n\n\t \n#define cacheline(a) round_down(a, CACHELINE_BYTES)\n\tGEM_BUG_ON(cacheline(tail) == cacheline(head) && tail < head);\n#undef cacheline\n}\n\nstatic inline unsigned int\nintel_ring_set_tail(struct intel_ring *ring, unsigned int tail)\n{\n\t \n\tassert_ring_tail_valid(ring, tail);\n\tring->tail = tail;\n\treturn tail;\n}\n\nstatic inline unsigned int\n__intel_ring_space(unsigned int head, unsigned int tail, unsigned int size)\n{\n\t \n\tGEM_BUG_ON(!is_power_of_2(size));\n\treturn (head - tail - CACHELINE_BYTES) & (size - 1);\n}\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}