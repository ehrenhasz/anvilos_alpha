{
  "module_name": "intel_wopcm.c",
  "hash_id": "88edf19f9ae4f392675a2d11dec6abc0bfcdcc27ae1aacf8422f6ac0907b0eb3",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/i915/gt/intel_wopcm.c",
  "human_readable_source": "\n \n\n#include \"intel_wopcm.h\"\n#include \"i915_drv.h\"\n\n \n\n \n#define GEN11_WOPCM_SIZE\t\tSZ_2M\n#define GEN9_WOPCM_SIZE\t\t\tSZ_1M\n#define MAX_WOPCM_SIZE\t\t\tSZ_8M\n \n#define WOPCM_RESERVED_SIZE\t\tSZ_16K\n\n \n#define GUC_WOPCM_RESERVED\t\tSZ_16K\n \n#define GUC_WOPCM_STACK_RESERVED\tSZ_8K\n\n \n#define GUC_WOPCM_OFFSET_ALIGNMENT\t(1UL << GUC_WOPCM_OFFSET_SHIFT)\n\n \n#define BXT_WOPCM_RC6_CTX_RESERVED\t(SZ_16K + SZ_8K)\n \n#define ICL_WOPCM_HW_CTX_RESERVED\t(SZ_32K + SZ_4K)\n\n \n#define GEN9_GUC_FW_RESERVED\tSZ_128K\n#define GEN9_GUC_WOPCM_OFFSET\t(GUC_WOPCM_RESERVED + GEN9_GUC_FW_RESERVED)\n\nstatic inline struct intel_gt *wopcm_to_gt(struct intel_wopcm *wopcm)\n{\n\treturn container_of(wopcm, struct intel_gt, wopcm);\n}\n\n \nvoid intel_wopcm_init_early(struct intel_wopcm *wopcm)\n{\n\tstruct intel_gt *gt = wopcm_to_gt(wopcm);\n\tstruct drm_i915_private *i915 = gt->i915;\n\n\tif (!HAS_GT_UC(i915))\n\t\treturn;\n\n\tif (GRAPHICS_VER(i915) >= 11)\n\t\twopcm->size = GEN11_WOPCM_SIZE;\n\telse\n\t\twopcm->size = GEN9_WOPCM_SIZE;\n\n\tdrm_dbg(&i915->drm, \"WOPCM: %uK\\n\", wopcm->size / 1024);\n}\n\nstatic u32 context_reserved_size(struct drm_i915_private *i915)\n{\n\tif (IS_GEN9_LP(i915))\n\t\treturn BXT_WOPCM_RC6_CTX_RESERVED;\n\telse if (GRAPHICS_VER(i915) >= 11)\n\t\treturn ICL_WOPCM_HW_CTX_RESERVED;\n\telse\n\t\treturn 0;\n}\n\nstatic bool gen9_check_dword_gap(struct drm_i915_private *i915,\n\t\t\t\t u32 guc_wopcm_base, u32 guc_wopcm_size)\n{\n\tu32 offset;\n\n\t \n\toffset = guc_wopcm_base + GEN9_GUC_WOPCM_OFFSET;\n\tif (offset > guc_wopcm_size ||\n\t    (guc_wopcm_size - offset) < sizeof(u32)) {\n\t\tdrm_err(&i915->drm,\n\t\t\t\"WOPCM: invalid GuC region size: %uK < %uK\\n\",\n\t\t\tguc_wopcm_size / SZ_1K,\n\t\t\t(u32)(offset + sizeof(u32)) / SZ_1K);\n\t\treturn false;\n\t}\n\n\treturn true;\n}\n\nstatic bool gen9_check_huc_fw_fits(struct drm_i915_private *i915,\n\t\t\t\t   u32 guc_wopcm_size, u32 huc_fw_size)\n{\n\t \n\tif (huc_fw_size > guc_wopcm_size - GUC_WOPCM_RESERVED) {\n\t\tdrm_err(&i915->drm, \"WOPCM: no space for %s: %uK < %uK\\n\",\n\t\t\tintel_uc_fw_type_repr(INTEL_UC_FW_TYPE_HUC),\n\t\t\t(guc_wopcm_size - GUC_WOPCM_RESERVED) / SZ_1K,\n\t\t\thuc_fw_size / 1024);\n\t\treturn false;\n\t}\n\n\treturn true;\n}\n\nstatic bool check_hw_restrictions(struct drm_i915_private *i915,\n\t\t\t\t  u32 guc_wopcm_base, u32 guc_wopcm_size,\n\t\t\t\t  u32 huc_fw_size)\n{\n\tif (GRAPHICS_VER(i915) == 9 && !gen9_check_dword_gap(i915, guc_wopcm_base,\n\t\t\t\t\t\t\t     guc_wopcm_size))\n\t\treturn false;\n\n\tif (GRAPHICS_VER(i915) == 9 &&\n\t    !gen9_check_huc_fw_fits(i915, guc_wopcm_size, huc_fw_size))\n\t\treturn false;\n\n\treturn true;\n}\n\nstatic bool __check_layout(struct intel_gt *gt, u32 wopcm_size,\n\t\t\t   u32 guc_wopcm_base, u32 guc_wopcm_size,\n\t\t\t   u32 guc_fw_size, u32 huc_fw_size)\n{\n\tstruct drm_i915_private *i915 = gt->i915;\n\tconst u32 ctx_rsvd = context_reserved_size(i915);\n\tu32 size;\n\n\tsize = wopcm_size - ctx_rsvd;\n\tif (unlikely(range_overflows(guc_wopcm_base, guc_wopcm_size, size))) {\n\t\tdrm_err(&i915->drm,\n\t\t\t\"WOPCM: invalid GuC region layout: %uK + %uK > %uK\\n\",\n\t\t\tguc_wopcm_base / SZ_1K, guc_wopcm_size / SZ_1K,\n\t\t\tsize / SZ_1K);\n\t\treturn false;\n\t}\n\n\tsize = guc_fw_size + GUC_WOPCM_RESERVED + GUC_WOPCM_STACK_RESERVED;\n\tif (unlikely(guc_wopcm_size < size)) {\n\t\tdrm_err(&i915->drm, \"WOPCM: no space for %s: %uK < %uK\\n\",\n\t\t\tintel_uc_fw_type_repr(INTEL_UC_FW_TYPE_GUC),\n\t\t\tguc_wopcm_size / SZ_1K, size / SZ_1K);\n\t\treturn false;\n\t}\n\n\tif (intel_uc_supports_huc(&gt->uc)) {\n\t\tsize = huc_fw_size + WOPCM_RESERVED_SIZE;\n\t\tif (unlikely(guc_wopcm_base < size)) {\n\t\t\tdrm_err(&i915->drm, \"WOPCM: no space for %s: %uK < %uK\\n\",\n\t\t\t\tintel_uc_fw_type_repr(INTEL_UC_FW_TYPE_HUC),\n\t\t\t\tguc_wopcm_base / SZ_1K, size / SZ_1K);\n\t\t\treturn false;\n\t\t}\n\t}\n\n\treturn check_hw_restrictions(i915, guc_wopcm_base, guc_wopcm_size,\n\t\t\t\t     huc_fw_size);\n}\n\nstatic bool __wopcm_regs_locked(struct intel_uncore *uncore,\n\t\t\t\tu32 *guc_wopcm_base, u32 *guc_wopcm_size)\n{\n\tu32 reg_base = intel_uncore_read(uncore, DMA_GUC_WOPCM_OFFSET);\n\tu32 reg_size = intel_uncore_read(uncore, GUC_WOPCM_SIZE);\n\n\tif (!(reg_size & GUC_WOPCM_SIZE_LOCKED) ||\n\t    !(reg_base & GUC_WOPCM_OFFSET_VALID))\n\t\treturn false;\n\n\t*guc_wopcm_base = reg_base & GUC_WOPCM_OFFSET_MASK;\n\t*guc_wopcm_size = reg_size & GUC_WOPCM_SIZE_MASK;\n\treturn true;\n}\n\nstatic bool __wopcm_regs_writable(struct intel_uncore *uncore)\n{\n\tif (!HAS_GUC_DEPRIVILEGE(uncore->i915))\n\t\treturn true;\n\n\treturn intel_uncore_read(uncore, GUC_SHIM_CONTROL2) & GUC_IS_PRIVILEGED;\n}\n\n \nvoid intel_wopcm_init(struct intel_wopcm *wopcm)\n{\n\tstruct intel_gt *gt = wopcm_to_gt(wopcm);\n\tstruct drm_i915_private *i915 = gt->i915;\n\tu32 guc_fw_size = intel_uc_fw_get_upload_size(&gt->uc.guc.fw);\n\tu32 huc_fw_size = intel_uc_fw_get_upload_size(&gt->uc.huc.fw);\n\tu32 ctx_rsvd = context_reserved_size(i915);\n\tu32 wopcm_size = wopcm->size;\n\tu32 guc_wopcm_base;\n\tu32 guc_wopcm_size;\n\n\tif (!guc_fw_size)\n\t\treturn;\n\n\tGEM_BUG_ON(!wopcm_size);\n\tGEM_BUG_ON(wopcm->guc.base);\n\tGEM_BUG_ON(wopcm->guc.size);\n\tGEM_BUG_ON(guc_fw_size >= wopcm_size);\n\tGEM_BUG_ON(huc_fw_size >= wopcm_size);\n\tGEM_BUG_ON(ctx_rsvd + WOPCM_RESERVED_SIZE >= wopcm_size);\n\n\tif (i915_inject_probe_failure(i915))\n\t\treturn;\n\n\tif (__wopcm_regs_locked(gt->uncore, &guc_wopcm_base, &guc_wopcm_size)) {\n\t\tdrm_dbg(&i915->drm, \"GuC WOPCM is already locked [%uK, %uK)\\n\",\n\t\t\tguc_wopcm_base / SZ_1K, guc_wopcm_size / SZ_1K);\n\t\t \n\t\tif (!__wopcm_regs_writable(gt->uncore))\n\t\t\twopcm_size = MAX_WOPCM_SIZE;\n\n\t\tgoto check;\n\t}\n\n\t \n\tif (unlikely(i915->media_gt)) {\n\t\tdrm_err(&i915->drm, \"Unlocked WOPCM regs with media GT\\n\");\n\t\treturn;\n\t}\n\n\t \n\tguc_wopcm_base = huc_fw_size + WOPCM_RESERVED_SIZE;\n\tguc_wopcm_base = ALIGN(guc_wopcm_base, GUC_WOPCM_OFFSET_ALIGNMENT);\n\n\t \n\tguc_wopcm_base = min(guc_wopcm_base, wopcm_size - ctx_rsvd);\n\n\t \n\tguc_wopcm_size = wopcm_size - ctx_rsvd - guc_wopcm_base;\n\tguc_wopcm_size &= GUC_WOPCM_SIZE_MASK;\n\n\tdrm_dbg(&i915->drm, \"Calculated GuC WOPCM [%uK, %uK)\\n\",\n\t\tguc_wopcm_base / SZ_1K, guc_wopcm_size / SZ_1K);\n\ncheck:\n\tif (__check_layout(gt, wopcm_size, guc_wopcm_base, guc_wopcm_size,\n\t\t\t   guc_fw_size, huc_fw_size)) {\n\t\twopcm->guc.base = guc_wopcm_base;\n\t\twopcm->guc.size = guc_wopcm_size;\n\t\tGEM_BUG_ON(!wopcm->guc.base);\n\t\tGEM_BUG_ON(!wopcm->guc.size);\n\t}\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}