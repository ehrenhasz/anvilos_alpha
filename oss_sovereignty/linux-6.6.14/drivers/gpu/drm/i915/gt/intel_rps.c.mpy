{
  "module_name": "intel_rps.c",
  "hash_id": "73ebce60e205f89a469385500bec5563a78c37b75d73ff72cf0af73c2127f066",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/i915/gt/intel_rps.c",
  "human_readable_source": "\n \n\n#include <linux/string_helpers.h>\n\n#include <drm/i915_drm.h>\n\n#include \"display/intel_display.h\"\n#include \"display/intel_display_irq.h\"\n#include \"i915_drv.h\"\n#include \"i915_irq.h\"\n#include \"i915_reg.h\"\n#include \"intel_breadcrumbs.h\"\n#include \"intel_gt.h\"\n#include \"intel_gt_clock_utils.h\"\n#include \"intel_gt_irq.h\"\n#include \"intel_gt_pm.h\"\n#include \"intel_gt_pm_irq.h\"\n#include \"intel_gt_print.h\"\n#include \"intel_gt_regs.h\"\n#include \"intel_mchbar_regs.h\"\n#include \"intel_pcode.h\"\n#include \"intel_rps.h\"\n#include \"vlv_sideband.h\"\n#include \"../../../platform/x86/intel_ips.h\"\n\n#define BUSY_MAX_EI\t20u  \n\n \nstatic DEFINE_SPINLOCK(mchdev_lock);\n\nstatic struct intel_gt *rps_to_gt(struct intel_rps *rps)\n{\n\treturn container_of(rps, struct intel_gt, rps);\n}\n\nstatic struct drm_i915_private *rps_to_i915(struct intel_rps *rps)\n{\n\treturn rps_to_gt(rps)->i915;\n}\n\nstatic struct intel_uncore *rps_to_uncore(struct intel_rps *rps)\n{\n\treturn rps_to_gt(rps)->uncore;\n}\n\nstatic struct intel_guc_slpc *rps_to_slpc(struct intel_rps *rps)\n{\n\tstruct intel_gt *gt = rps_to_gt(rps);\n\n\treturn &gt->uc.guc.slpc;\n}\n\nstatic bool rps_uses_slpc(struct intel_rps *rps)\n{\n\tstruct intel_gt *gt = rps_to_gt(rps);\n\n\treturn intel_uc_uses_guc_slpc(&gt->uc);\n}\n\nstatic u32 rps_pm_sanitize_mask(struct intel_rps *rps, u32 mask)\n{\n\treturn mask & ~rps->pm_intrmsk_mbz;\n}\n\nstatic void set(struct intel_uncore *uncore, i915_reg_t reg, u32 val)\n{\n\tintel_uncore_write_fw(uncore, reg, val);\n}\n\nstatic void rps_timer(struct timer_list *t)\n{\n\tstruct intel_rps *rps = from_timer(rps, t, timer);\n\tstruct intel_gt *gt = rps_to_gt(rps);\n\tstruct intel_engine_cs *engine;\n\tktime_t dt, last, timestamp;\n\tenum intel_engine_id id;\n\ts64 max_busy[3] = {};\n\n\ttimestamp = 0;\n\tfor_each_engine(engine, gt, id) {\n\t\ts64 busy;\n\t\tint i;\n\n\t\tdt = intel_engine_get_busy_time(engine, &timestamp);\n\t\tlast = engine->stats.rps;\n\t\tengine->stats.rps = dt;\n\n\t\tbusy = ktime_to_ns(ktime_sub(dt, last));\n\t\tfor (i = 0; i < ARRAY_SIZE(max_busy); i++) {\n\t\t\tif (busy > max_busy[i])\n\t\t\t\tswap(busy, max_busy[i]);\n\t\t}\n\t}\n\tlast = rps->pm_timestamp;\n\trps->pm_timestamp = timestamp;\n\n\tif (intel_rps_is_active(rps)) {\n\t\ts64 busy;\n\t\tint i;\n\n\t\tdt = ktime_sub(timestamp, last);\n\n\t\t \n\t\tbusy = max_busy[0];\n\t\tfor (i = 1; i < ARRAY_SIZE(max_busy); i++) {\n\t\t\tif (!max_busy[i])\n\t\t\t\tbreak;\n\n\t\t\tbusy += div_u64(max_busy[i], 1 << i);\n\t\t}\n\t\tGT_TRACE(gt,\n\t\t\t \"busy:%lld [%d%%], max:[%lld, %lld, %lld], interval:%d\\n\",\n\t\t\t busy, (int)div64_u64(100 * busy, dt),\n\t\t\t max_busy[0], max_busy[1], max_busy[2],\n\t\t\t rps->pm_interval);\n\n\t\tif (100 * busy > rps->power.up_threshold * dt &&\n\t\t    rps->cur_freq < rps->max_freq_softlimit) {\n\t\t\trps->pm_iir |= GEN6_PM_RP_UP_THRESHOLD;\n\t\t\trps->pm_interval = 1;\n\t\t\tqueue_work(gt->i915->unordered_wq, &rps->work);\n\t\t} else if (100 * busy < rps->power.down_threshold * dt &&\n\t\t\t   rps->cur_freq > rps->min_freq_softlimit) {\n\t\t\trps->pm_iir |= GEN6_PM_RP_DOWN_THRESHOLD;\n\t\t\trps->pm_interval = 1;\n\t\t\tqueue_work(gt->i915->unordered_wq, &rps->work);\n\t\t} else {\n\t\t\trps->last_adj = 0;\n\t\t}\n\n\t\tmod_timer(&rps->timer,\n\t\t\t  jiffies + msecs_to_jiffies(rps->pm_interval));\n\t\trps->pm_interval = min(rps->pm_interval * 2, BUSY_MAX_EI);\n\t}\n}\n\nstatic void rps_start_timer(struct intel_rps *rps)\n{\n\trps->pm_timestamp = ktime_sub(ktime_get(), rps->pm_timestamp);\n\trps->pm_interval = 1;\n\tmod_timer(&rps->timer, jiffies + 1);\n}\n\nstatic void rps_stop_timer(struct intel_rps *rps)\n{\n\tdel_timer_sync(&rps->timer);\n\trps->pm_timestamp = ktime_sub(ktime_get(), rps->pm_timestamp);\n\tcancel_work_sync(&rps->work);\n}\n\nstatic u32 rps_pm_mask(struct intel_rps *rps, u8 val)\n{\n\tu32 mask = 0;\n\n\t \n\tif (val > rps->min_freq_softlimit)\n\t\tmask |= (GEN6_PM_RP_UP_EI_EXPIRED |\n\t\t\t GEN6_PM_RP_DOWN_THRESHOLD |\n\t\t\t GEN6_PM_RP_DOWN_TIMEOUT);\n\n\tif (val < rps->max_freq_softlimit)\n\t\tmask |= GEN6_PM_RP_UP_EI_EXPIRED | GEN6_PM_RP_UP_THRESHOLD;\n\n\tmask &= rps->pm_events;\n\n\treturn rps_pm_sanitize_mask(rps, ~mask);\n}\n\nstatic void rps_reset_ei(struct intel_rps *rps)\n{\n\tmemset(&rps->ei, 0, sizeof(rps->ei));\n}\n\nstatic void rps_enable_interrupts(struct intel_rps *rps)\n{\n\tstruct intel_gt *gt = rps_to_gt(rps);\n\n\tGEM_BUG_ON(rps_uses_slpc(rps));\n\n\tGT_TRACE(gt, \"interrupts:on rps->pm_events: %x, rps_pm_mask:%x\\n\",\n\t\t rps->pm_events, rps_pm_mask(rps, rps->last_freq));\n\n\trps_reset_ei(rps);\n\n\tspin_lock_irq(gt->irq_lock);\n\tgen6_gt_pm_enable_irq(gt, rps->pm_events);\n\tspin_unlock_irq(gt->irq_lock);\n\n\tintel_uncore_write(gt->uncore,\n\t\t\t   GEN6_PMINTRMSK, rps_pm_mask(rps, rps->last_freq));\n}\n\nstatic void gen6_rps_reset_interrupts(struct intel_rps *rps)\n{\n\tgen6_gt_pm_reset_iir(rps_to_gt(rps), GEN6_PM_RPS_EVENTS);\n}\n\nstatic void gen11_rps_reset_interrupts(struct intel_rps *rps)\n{\n\twhile (gen11_gt_reset_one_iir(rps_to_gt(rps), 0, GEN11_GTPM))\n\t\t;\n}\n\nstatic void rps_reset_interrupts(struct intel_rps *rps)\n{\n\tstruct intel_gt *gt = rps_to_gt(rps);\n\n\tspin_lock_irq(gt->irq_lock);\n\tif (GRAPHICS_VER(gt->i915) >= 11)\n\t\tgen11_rps_reset_interrupts(rps);\n\telse\n\t\tgen6_rps_reset_interrupts(rps);\n\n\trps->pm_iir = 0;\n\tspin_unlock_irq(gt->irq_lock);\n}\n\nstatic void rps_disable_interrupts(struct intel_rps *rps)\n{\n\tstruct intel_gt *gt = rps_to_gt(rps);\n\n\tintel_uncore_write(gt->uncore,\n\t\t\t   GEN6_PMINTRMSK, rps_pm_sanitize_mask(rps, ~0u));\n\n\tspin_lock_irq(gt->irq_lock);\n\tgen6_gt_pm_disable_irq(gt, GEN6_PM_RPS_EVENTS);\n\tspin_unlock_irq(gt->irq_lock);\n\n\tintel_synchronize_irq(gt->i915);\n\n\t \n\tcancel_work_sync(&rps->work);\n\n\trps_reset_interrupts(rps);\n\tGT_TRACE(gt, \"interrupts:off\\n\");\n}\n\nstatic const struct cparams {\n\tu16 i;\n\tu16 t;\n\tu16 m;\n\tu16 c;\n} cparams[] = {\n\t{ 1, 1333, 301, 28664 },\n\t{ 1, 1066, 294, 24460 },\n\t{ 1, 800, 294, 25192 },\n\t{ 0, 1333, 276, 27605 },\n\t{ 0, 1066, 276, 27605 },\n\t{ 0, 800, 231, 23784 },\n};\n\nstatic void gen5_rps_init(struct intel_rps *rps)\n{\n\tstruct drm_i915_private *i915 = rps_to_i915(rps);\n\tstruct intel_uncore *uncore = rps_to_uncore(rps);\n\tu8 fmax, fmin, fstart;\n\tu32 rgvmodectl;\n\tint c_m, i;\n\n\tif (i915->fsb_freq <= 3200)\n\t\tc_m = 0;\n\telse if (i915->fsb_freq <= 4800)\n\t\tc_m = 1;\n\telse\n\t\tc_m = 2;\n\n\tfor (i = 0; i < ARRAY_SIZE(cparams); i++) {\n\t\tif (cparams[i].i == c_m && cparams[i].t == i915->mem_freq) {\n\t\t\trps->ips.m = cparams[i].m;\n\t\t\trps->ips.c = cparams[i].c;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\trgvmodectl = intel_uncore_read(uncore, MEMMODECTL);\n\n\t \n\tfmax = (rgvmodectl & MEMMODE_FMAX_MASK) >> MEMMODE_FMAX_SHIFT;\n\tfmin = (rgvmodectl & MEMMODE_FMIN_MASK);\n\tfstart = (rgvmodectl & MEMMODE_FSTART_MASK) >>\n\t\tMEMMODE_FSTART_SHIFT;\n\tdrm_dbg(&i915->drm, \"fmax: %d, fmin: %d, fstart: %d\\n\",\n\t\tfmax, fmin, fstart);\n\n\trps->min_freq = fmax;\n\trps->efficient_freq = fstart;\n\trps->max_freq = fmin;\n}\n\nstatic unsigned long\n__ips_chipset_val(struct intel_ips *ips)\n{\n\tstruct intel_uncore *uncore =\n\t\trps_to_uncore(container_of(ips, struct intel_rps, ips));\n\tunsigned long now = jiffies_to_msecs(jiffies), dt;\n\tunsigned long result;\n\tu64 total, delta;\n\n\tlockdep_assert_held(&mchdev_lock);\n\n\t \n\tdt = now - ips->last_time1;\n\tif (dt <= 10)\n\t\treturn ips->chipset_power;\n\n\t \n\ttotal = intel_uncore_read(uncore, DMIEC);\n\ttotal += intel_uncore_read(uncore, DDREC);\n\ttotal += intel_uncore_read(uncore, CSIEC);\n\n\tdelta = total - ips->last_count1;\n\n\tresult = div_u64(div_u64(ips->m * delta, dt) + ips->c, 10);\n\n\tips->last_count1 = total;\n\tips->last_time1 = now;\n\n\tips->chipset_power = result;\n\n\treturn result;\n}\n\nstatic unsigned long ips_mch_val(struct intel_uncore *uncore)\n{\n\tunsigned int m, x, b;\n\tu32 tsfs;\n\n\ttsfs = intel_uncore_read(uncore, TSFS);\n\tx = intel_uncore_read8(uncore, TR1);\n\n\tb = tsfs & TSFS_INTR_MASK;\n\tm = (tsfs & TSFS_SLOPE_MASK) >> TSFS_SLOPE_SHIFT;\n\n\treturn m * x / 127 - b;\n}\n\nstatic int _pxvid_to_vd(u8 pxvid)\n{\n\tif (pxvid == 0)\n\t\treturn 0;\n\n\tif (pxvid >= 8 && pxvid < 31)\n\t\tpxvid = 31;\n\n\treturn (pxvid + 2) * 125;\n}\n\nstatic u32 pvid_to_extvid(struct drm_i915_private *i915, u8 pxvid)\n{\n\tconst int vd = _pxvid_to_vd(pxvid);\n\n\tif (INTEL_INFO(i915)->is_mobile)\n\t\treturn max(vd - 1125, 0);\n\n\treturn vd;\n}\n\nstatic void __gen5_ips_update(struct intel_ips *ips)\n{\n\tstruct intel_uncore *uncore =\n\t\trps_to_uncore(container_of(ips, struct intel_rps, ips));\n\tu64 now, delta, dt;\n\tu32 count;\n\n\tlockdep_assert_held(&mchdev_lock);\n\n\tnow = ktime_get_raw_ns();\n\tdt = now - ips->last_time2;\n\tdo_div(dt, NSEC_PER_MSEC);\n\n\t \n\tif (dt <= 10)\n\t\treturn;\n\n\tcount = intel_uncore_read(uncore, GFXEC);\n\tdelta = count - ips->last_count2;\n\n\tips->last_count2 = count;\n\tips->last_time2 = now;\n\n\t \n\tips->gfx_power = div_u64(delta * 1181, dt * 10);\n}\n\nstatic void gen5_rps_update(struct intel_rps *rps)\n{\n\tspin_lock_irq(&mchdev_lock);\n\t__gen5_ips_update(&rps->ips);\n\tspin_unlock_irq(&mchdev_lock);\n}\n\nstatic unsigned int gen5_invert_freq(struct intel_rps *rps,\n\t\t\t\t     unsigned int val)\n{\n\t \n\tval = rps->max_freq - val;\n\tval = rps->min_freq + val;\n\n\treturn val;\n}\n\nstatic int __gen5_rps_set(struct intel_rps *rps, u8 val)\n{\n\tstruct intel_uncore *uncore = rps_to_uncore(rps);\n\tu16 rgvswctl;\n\n\tlockdep_assert_held(&mchdev_lock);\n\n\trgvswctl = intel_uncore_read16(uncore, MEMSWCTL);\n\tif (rgvswctl & MEMCTL_CMD_STS) {\n\t\tdrm_dbg(&rps_to_i915(rps)->drm,\n\t\t\t\"gpu busy, RCS change rejected\\n\");\n\t\treturn -EBUSY;  \n\t}\n\n\t \n\tval = gen5_invert_freq(rps, val);\n\n\trgvswctl =\n\t\t(MEMCTL_CMD_CHFREQ << MEMCTL_CMD_SHIFT) |\n\t\t(val << MEMCTL_FREQ_SHIFT) |\n\t\tMEMCTL_SFCAVM;\n\tintel_uncore_write16(uncore, MEMSWCTL, rgvswctl);\n\tintel_uncore_posting_read16(uncore, MEMSWCTL);\n\n\trgvswctl |= MEMCTL_CMD_STS;\n\tintel_uncore_write16(uncore, MEMSWCTL, rgvswctl);\n\n\treturn 0;\n}\n\nstatic int gen5_rps_set(struct intel_rps *rps, u8 val)\n{\n\tint err;\n\n\tspin_lock_irq(&mchdev_lock);\n\terr = __gen5_rps_set(rps, val);\n\tspin_unlock_irq(&mchdev_lock);\n\n\treturn err;\n}\n\nstatic unsigned long intel_pxfreq(u32 vidfreq)\n{\n\tint div = (vidfreq & 0x3f0000) >> 16;\n\tint post = (vidfreq & 0x3000) >> 12;\n\tint pre = (vidfreq & 0x7);\n\n\tif (!pre)\n\t\treturn 0;\n\n\treturn div * 133333 / (pre << post);\n}\n\nstatic unsigned int init_emon(struct intel_uncore *uncore)\n{\n\tu8 pxw[16];\n\tint i;\n\n\t \n\tintel_uncore_write(uncore, ECR, 0);\n\tintel_uncore_posting_read(uncore, ECR);\n\n\t \n\tintel_uncore_write(uncore, SDEW, 0x15040d00);\n\tintel_uncore_write(uncore, CSIEW0, 0x007f0000);\n\tintel_uncore_write(uncore, CSIEW1, 0x1e220004);\n\tintel_uncore_write(uncore, CSIEW2, 0x04000004);\n\n\tfor (i = 0; i < 5; i++)\n\t\tintel_uncore_write(uncore, PEW(i), 0);\n\tfor (i = 0; i < 3; i++)\n\t\tintel_uncore_write(uncore, DEW(i), 0);\n\n\t \n\tfor (i = 0; i < 16; i++) {\n\t\tu32 pxvidfreq = intel_uncore_read(uncore, PXVFREQ(i));\n\t\tunsigned int freq = intel_pxfreq(pxvidfreq);\n\t\tunsigned int vid =\n\t\t\t(pxvidfreq & PXVFREQ_PX_MASK) >> PXVFREQ_PX_SHIFT;\n\t\tunsigned int val;\n\n\t\tval = vid * vid * freq / 1000 * 255;\n\t\tval /= 127 * 127 * 900;\n\n\t\tpxw[i] = val;\n\t}\n\t \n\tpxw[14] = 0;\n\tpxw[15] = 0;\n\n\tfor (i = 0; i < 4; i++) {\n\t\tintel_uncore_write(uncore, PXW(i),\n\t\t\t\t   pxw[i * 4 + 0] << 24 |\n\t\t\t\t   pxw[i * 4 + 1] << 16 |\n\t\t\t\t   pxw[i * 4 + 2] <<  8 |\n\t\t\t\t   pxw[i * 4 + 3] <<  0);\n\t}\n\n\t \n\tintel_uncore_write(uncore, OGW0, 0);\n\tintel_uncore_write(uncore, OGW1, 0);\n\tintel_uncore_write(uncore, EG0, 0x00007f00);\n\tintel_uncore_write(uncore, EG1, 0x0000000e);\n\tintel_uncore_write(uncore, EG2, 0x000e0000);\n\tintel_uncore_write(uncore, EG3, 0x68000300);\n\tintel_uncore_write(uncore, EG4, 0x42000000);\n\tintel_uncore_write(uncore, EG5, 0x00140031);\n\tintel_uncore_write(uncore, EG6, 0);\n\tintel_uncore_write(uncore, EG7, 0);\n\n\tfor (i = 0; i < 8; i++)\n\t\tintel_uncore_write(uncore, PXWL(i), 0);\n\n\t \n\tintel_uncore_write(uncore, ECR, 0x80000019);\n\n\treturn intel_uncore_read(uncore, LCFUSE02) & LCFUSE_HIV_MASK;\n}\n\nstatic bool gen5_rps_enable(struct intel_rps *rps)\n{\n\tstruct drm_i915_private *i915 = rps_to_i915(rps);\n\tstruct intel_uncore *uncore = rps_to_uncore(rps);\n\tu8 fstart, vstart;\n\tu32 rgvmodectl;\n\n\tspin_lock_irq(&mchdev_lock);\n\n\trgvmodectl = intel_uncore_read(uncore, MEMMODECTL);\n\n\t \n\tintel_uncore_write16(uncore, PMMISC,\n\t\t\t     intel_uncore_read16(uncore, PMMISC) | MCPPCE_EN);\n\tintel_uncore_write16(uncore, TSC1,\n\t\t\t     intel_uncore_read16(uncore, TSC1) | TSE);\n\n\t \n\tintel_uncore_write(uncore, RCUPEI, 100000);\n\tintel_uncore_write(uncore, RCDNEI, 100000);\n\n\t \n\tintel_uncore_write(uncore, RCBMAXAVG, 90000);\n\tintel_uncore_write(uncore, RCBMINAVG, 80000);\n\n\tintel_uncore_write(uncore, MEMIHYST, 1);\n\n\t \n\tfstart = (rgvmodectl & MEMMODE_FSTART_MASK) >>\n\t\tMEMMODE_FSTART_SHIFT;\n\n\tvstart = (intel_uncore_read(uncore, PXVFREQ(fstart)) &\n\t\t  PXVFREQ_PX_MASK) >> PXVFREQ_PX_SHIFT;\n\n\tintel_uncore_write(uncore,\n\t\t\t   MEMINTREN,\n\t\t\t   MEMINT_CX_SUPR_EN | MEMINT_EVAL_CHG_EN);\n\n\tintel_uncore_write(uncore, VIDSTART, vstart);\n\tintel_uncore_posting_read(uncore, VIDSTART);\n\n\trgvmodectl |= MEMMODE_SWMODE_EN;\n\tintel_uncore_write(uncore, MEMMODECTL, rgvmodectl);\n\n\tif (wait_for_atomic((intel_uncore_read(uncore, MEMSWCTL) &\n\t\t\t     MEMCTL_CMD_STS) == 0, 10))\n\t\tdrm_err(&uncore->i915->drm,\n\t\t\t\"stuck trying to change perf mode\\n\");\n\tmdelay(1);\n\n\t__gen5_rps_set(rps, rps->cur_freq);\n\n\trps->ips.last_count1 = intel_uncore_read(uncore, DMIEC);\n\trps->ips.last_count1 += intel_uncore_read(uncore, DDREC);\n\trps->ips.last_count1 += intel_uncore_read(uncore, CSIEC);\n\trps->ips.last_time1 = jiffies_to_msecs(jiffies);\n\n\trps->ips.last_count2 = intel_uncore_read(uncore, GFXEC);\n\trps->ips.last_time2 = ktime_get_raw_ns();\n\n\tspin_lock(&i915->irq_lock);\n\tilk_enable_display_irq(i915, DE_PCU_EVENT);\n\tspin_unlock(&i915->irq_lock);\n\n\tspin_unlock_irq(&mchdev_lock);\n\n\trps->ips.corr = init_emon(uncore);\n\n\treturn true;\n}\n\nstatic void gen5_rps_disable(struct intel_rps *rps)\n{\n\tstruct drm_i915_private *i915 = rps_to_i915(rps);\n\tstruct intel_uncore *uncore = rps_to_uncore(rps);\n\tu16 rgvswctl;\n\n\tspin_lock_irq(&mchdev_lock);\n\n\tspin_lock(&i915->irq_lock);\n\tilk_disable_display_irq(i915, DE_PCU_EVENT);\n\tspin_unlock(&i915->irq_lock);\n\n\trgvswctl = intel_uncore_read16(uncore, MEMSWCTL);\n\n\t \n\tintel_uncore_rmw(uncore, MEMINTREN, MEMINT_EVAL_CHG_EN, 0);\n\tintel_uncore_write(uncore, MEMINTRSTS, MEMINT_EVAL_CHG);\n\n\t \n\t__gen5_rps_set(rps, rps->idle_freq);\n\tmdelay(1);\n\trgvswctl |= MEMCTL_CMD_STS;\n\tintel_uncore_write(uncore, MEMSWCTL, rgvswctl);\n\tmdelay(1);\n\n\tspin_unlock_irq(&mchdev_lock);\n}\n\nstatic u32 rps_limits(struct intel_rps *rps, u8 val)\n{\n\tu32 limits;\n\n\t \n\tif (GRAPHICS_VER(rps_to_i915(rps)) >= 9) {\n\t\tlimits = rps->max_freq_softlimit << 23;\n\t\tif (val <= rps->min_freq_softlimit)\n\t\t\tlimits |= rps->min_freq_softlimit << 14;\n\t} else {\n\t\tlimits = rps->max_freq_softlimit << 24;\n\t\tif (val <= rps->min_freq_softlimit)\n\t\t\tlimits |= rps->min_freq_softlimit << 16;\n\t}\n\n\treturn limits;\n}\n\nstatic void rps_set_power(struct intel_rps *rps, int new_power)\n{\n\tstruct intel_gt *gt = rps_to_gt(rps);\n\tstruct intel_uncore *uncore = gt->uncore;\n\tu32 ei_up = 0, ei_down = 0;\n\n\tlockdep_assert_held(&rps->power.mutex);\n\n\tif (new_power == rps->power.mode)\n\t\treturn;\n\n\t \n\tswitch (new_power) {\n\tcase LOW_POWER:\n\t\tei_up = 16000;\n\t\tei_down = 32000;\n\t\tbreak;\n\n\tcase BETWEEN:\n\t\tei_up = 13000;\n\t\tei_down = 32000;\n\t\tbreak;\n\n\tcase HIGH_POWER:\n\t\tei_up = 10000;\n\t\tei_down = 32000;\n\t\tbreak;\n\t}\n\n\t \n\tif (IS_VALLEYVIEW(gt->i915))\n\t\tgoto skip_hw_write;\n\n\tGT_TRACE(gt,\n\t\t \"changing power mode [%d], up %d%% @ %dus, down %d%% @ %dus\\n\",\n\t\t new_power,\n\t\t rps->power.up_threshold, ei_up,\n\t\t rps->power.down_threshold, ei_down);\n\n\tset(uncore, GEN6_RP_UP_EI,\n\t    intel_gt_ns_to_pm_interval(gt, ei_up * 1000));\n\tset(uncore, GEN6_RP_UP_THRESHOLD,\n\t    intel_gt_ns_to_pm_interval(gt,\n\t\t\t\t       ei_up * rps->power.up_threshold * 10));\n\n\tset(uncore, GEN6_RP_DOWN_EI,\n\t    intel_gt_ns_to_pm_interval(gt, ei_down * 1000));\n\tset(uncore, GEN6_RP_DOWN_THRESHOLD,\n\t    intel_gt_ns_to_pm_interval(gt,\n\t\t\t\t       ei_down *\n\t\t\t\t       rps->power.down_threshold * 10));\n\n\tset(uncore, GEN6_RP_CONTROL,\n\t    (GRAPHICS_VER(gt->i915) > 9 ? 0 : GEN6_RP_MEDIA_TURBO) |\n\t    GEN6_RP_MEDIA_HW_NORMAL_MODE |\n\t    GEN6_RP_MEDIA_IS_GFX |\n\t    GEN6_RP_ENABLE |\n\t    GEN6_RP_UP_BUSY_AVG |\n\t    GEN6_RP_DOWN_IDLE_AVG);\n\nskip_hw_write:\n\trps->power.mode = new_power;\n}\n\nstatic void gen6_rps_set_thresholds(struct intel_rps *rps, u8 val)\n{\n\tint new_power;\n\n\tnew_power = rps->power.mode;\n\tswitch (rps->power.mode) {\n\tcase LOW_POWER:\n\t\tif (val > rps->efficient_freq + 1 &&\n\t\t    val > rps->cur_freq)\n\t\t\tnew_power = BETWEEN;\n\t\tbreak;\n\n\tcase BETWEEN:\n\t\tif (val <= rps->efficient_freq &&\n\t\t    val < rps->cur_freq)\n\t\t\tnew_power = LOW_POWER;\n\t\telse if (val >= rps->rp0_freq &&\n\t\t\t val > rps->cur_freq)\n\t\t\tnew_power = HIGH_POWER;\n\t\tbreak;\n\n\tcase HIGH_POWER:\n\t\tif (val < (rps->rp1_freq + rps->rp0_freq) >> 1 &&\n\t\t    val < rps->cur_freq)\n\t\t\tnew_power = BETWEEN;\n\t\tbreak;\n\t}\n\t \n\tif (val <= rps->min_freq_softlimit)\n\t\tnew_power = LOW_POWER;\n\tif (val >= rps->max_freq_softlimit)\n\t\tnew_power = HIGH_POWER;\n\n\tmutex_lock(&rps->power.mutex);\n\tif (rps->power.interactive)\n\t\tnew_power = HIGH_POWER;\n\trps_set_power(rps, new_power);\n\tmutex_unlock(&rps->power.mutex);\n}\n\nvoid intel_rps_mark_interactive(struct intel_rps *rps, bool interactive)\n{\n\tGT_TRACE(rps_to_gt(rps), \"mark interactive: %s\\n\",\n\t\t str_yes_no(interactive));\n\n\tmutex_lock(&rps->power.mutex);\n\tif (interactive) {\n\t\tif (!rps->power.interactive++ && intel_rps_is_active(rps))\n\t\t\trps_set_power(rps, HIGH_POWER);\n\t} else {\n\t\tGEM_BUG_ON(!rps->power.interactive);\n\t\trps->power.interactive--;\n\t}\n\tmutex_unlock(&rps->power.mutex);\n}\n\nstatic int gen6_rps_set(struct intel_rps *rps, u8 val)\n{\n\tstruct intel_uncore *uncore = rps_to_uncore(rps);\n\tstruct drm_i915_private *i915 = rps_to_i915(rps);\n\tu32 swreq;\n\n\tGEM_BUG_ON(rps_uses_slpc(rps));\n\n\tif (GRAPHICS_VER(i915) >= 9)\n\t\tswreq = GEN9_FREQUENCY(val);\n\telse if (IS_HASWELL(i915) || IS_BROADWELL(i915))\n\t\tswreq = HSW_FREQUENCY(val);\n\telse\n\t\tswreq = (GEN6_FREQUENCY(val) |\n\t\t\t GEN6_OFFSET(0) |\n\t\t\t GEN6_AGGRESSIVE_TURBO);\n\tset(uncore, GEN6_RPNSWREQ, swreq);\n\n\tGT_TRACE(rps_to_gt(rps), \"set val:%x, freq:%d, swreq:%x\\n\",\n\t\t val, intel_gpu_freq(rps, val), swreq);\n\n\treturn 0;\n}\n\nstatic int vlv_rps_set(struct intel_rps *rps, u8 val)\n{\n\tstruct drm_i915_private *i915 = rps_to_i915(rps);\n\tint err;\n\n\tvlv_punit_get(i915);\n\terr = vlv_punit_write(i915, PUNIT_REG_GPU_FREQ_REQ, val);\n\tvlv_punit_put(i915);\n\n\tGT_TRACE(rps_to_gt(rps), \"set val:%x, freq:%d\\n\",\n\t\t val, intel_gpu_freq(rps, val));\n\n\treturn err;\n}\n\nstatic int rps_set(struct intel_rps *rps, u8 val, bool update)\n{\n\tstruct drm_i915_private *i915 = rps_to_i915(rps);\n\tint err;\n\n\tif (val == rps->last_freq)\n\t\treturn 0;\n\n\tif (IS_VALLEYVIEW(i915) || IS_CHERRYVIEW(i915))\n\t\terr = vlv_rps_set(rps, val);\n\telse if (GRAPHICS_VER(i915) >= 6)\n\t\terr = gen6_rps_set(rps, val);\n\telse\n\t\terr = gen5_rps_set(rps, val);\n\tif (err)\n\t\treturn err;\n\n\tif (update && GRAPHICS_VER(i915) >= 6)\n\t\tgen6_rps_set_thresholds(rps, val);\n\trps->last_freq = val;\n\n\treturn 0;\n}\n\nvoid intel_rps_unpark(struct intel_rps *rps)\n{\n\tif (!intel_rps_is_enabled(rps))\n\t\treturn;\n\n\tGT_TRACE(rps_to_gt(rps), \"unpark:%x\\n\", rps->cur_freq);\n\n\t \n\tmutex_lock(&rps->lock);\n\n\tintel_rps_set_active(rps);\n\tintel_rps_set(rps,\n\t\t      clamp(rps->cur_freq,\n\t\t\t    rps->min_freq_softlimit,\n\t\t\t    rps->max_freq_softlimit));\n\n\tmutex_unlock(&rps->lock);\n\n\trps->pm_iir = 0;\n\tif (intel_rps_has_interrupts(rps))\n\t\trps_enable_interrupts(rps);\n\tif (intel_rps_uses_timer(rps))\n\t\trps_start_timer(rps);\n\n\tif (GRAPHICS_VER(rps_to_i915(rps)) == 5)\n\t\tgen5_rps_update(rps);\n}\n\nvoid intel_rps_park(struct intel_rps *rps)\n{\n\tint adj;\n\n\tif (!intel_rps_is_enabled(rps))\n\t\treturn;\n\n\tif (!intel_rps_clear_active(rps))\n\t\treturn;\n\n\tif (intel_rps_uses_timer(rps))\n\t\trps_stop_timer(rps);\n\tif (intel_rps_has_interrupts(rps))\n\t\trps_disable_interrupts(rps);\n\n\tif (rps->last_freq <= rps->idle_freq)\n\t\treturn;\n\n\t \n\tintel_uncore_forcewake_get(rps_to_uncore(rps), FORCEWAKE_MEDIA);\n\trps_set(rps, rps->idle_freq, false);\n\tintel_uncore_forcewake_put(rps_to_uncore(rps), FORCEWAKE_MEDIA);\n\n\t \n\tadj = rps->last_adj;\n\tif (adj < 0)\n\t\tadj *= 2;\n\telse  \n\t\tadj = -2;\n\trps->last_adj = adj;\n\trps->cur_freq = max_t(int, rps->cur_freq + adj, rps->min_freq);\n\tif (rps->cur_freq < rps->efficient_freq) {\n\t\trps->cur_freq = rps->efficient_freq;\n\t\trps->last_adj = 0;\n\t}\n\n\tGT_TRACE(rps_to_gt(rps), \"park:%x\\n\", rps->cur_freq);\n}\n\nu32 intel_rps_get_boost_frequency(struct intel_rps *rps)\n{\n\tstruct intel_guc_slpc *slpc;\n\n\tif (rps_uses_slpc(rps)) {\n\t\tslpc = rps_to_slpc(rps);\n\n\t\treturn slpc->boost_freq;\n\t} else {\n\t\treturn intel_gpu_freq(rps, rps->boost_freq);\n\t}\n}\n\nstatic int rps_set_boost_freq(struct intel_rps *rps, u32 val)\n{\n\tbool boost = false;\n\n\t \n\tval = intel_freq_opcode(rps, val);\n\tif (val < rps->min_freq || val > rps->max_freq)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&rps->lock);\n\tif (val != rps->boost_freq) {\n\t\trps->boost_freq = val;\n\t\tboost = atomic_read(&rps->num_waiters);\n\t}\n\tmutex_unlock(&rps->lock);\n\tif (boost)\n\t\tqueue_work(rps_to_gt(rps)->i915->unordered_wq, &rps->work);\n\n\treturn 0;\n}\n\nint intel_rps_set_boost_frequency(struct intel_rps *rps, u32 freq)\n{\n\tstruct intel_guc_slpc *slpc;\n\n\tif (rps_uses_slpc(rps)) {\n\t\tslpc = rps_to_slpc(rps);\n\n\t\treturn intel_guc_slpc_set_boost_freq(slpc, freq);\n\t} else {\n\t\treturn rps_set_boost_freq(rps, freq);\n\t}\n}\n\nvoid intel_rps_dec_waiters(struct intel_rps *rps)\n{\n\tstruct intel_guc_slpc *slpc;\n\n\tif (rps_uses_slpc(rps)) {\n\t\tslpc = rps_to_slpc(rps);\n\n\t\tintel_guc_slpc_dec_waiters(slpc);\n\t} else {\n\t\tatomic_dec(&rps->num_waiters);\n\t}\n}\n\nvoid intel_rps_boost(struct i915_request *rq)\n{\n\tstruct intel_guc_slpc *slpc;\n\n\tif (i915_request_signaled(rq) || i915_request_has_waitboost(rq))\n\t\treturn;\n\n\t \n\tif (!test_and_set_bit(I915_FENCE_FLAG_BOOST, &rq->fence.flags)) {\n\t\tstruct intel_rps *rps = &READ_ONCE(rq->engine)->gt->rps;\n\n\t\tif (rps_uses_slpc(rps)) {\n\t\t\tslpc = rps_to_slpc(rps);\n\n\t\t\tif (slpc->min_freq_softlimit >= slpc->boost_freq)\n\t\t\t\treturn;\n\n\t\t\t \n\t\t\tif (!atomic_fetch_inc(&slpc->num_waiters)) {\n\t\t\t\tGT_TRACE(rps_to_gt(rps), \"boost fence:%llx:%llx\\n\",\n\t\t\t\t\t rq->fence.context, rq->fence.seqno);\n\t\t\t\tqueue_work(rps_to_gt(rps)->i915->unordered_wq,\n\t\t\t\t\t   &slpc->boost_work);\n\t\t\t}\n\n\t\t\treturn;\n\t\t}\n\n\t\tif (atomic_fetch_inc(&rps->num_waiters))\n\t\t\treturn;\n\n\t\tif (!intel_rps_is_active(rps))\n\t\t\treturn;\n\n\t\tGT_TRACE(rps_to_gt(rps), \"boost fence:%llx:%llx\\n\",\n\t\t\t rq->fence.context, rq->fence.seqno);\n\n\t\tif (READ_ONCE(rps->cur_freq) < rps->boost_freq)\n\t\t\tqueue_work(rps_to_gt(rps)->i915->unordered_wq, &rps->work);\n\n\t\tWRITE_ONCE(rps->boosts, rps->boosts + 1);  \n\t}\n}\n\nint intel_rps_set(struct intel_rps *rps, u8 val)\n{\n\tint err;\n\n\tlockdep_assert_held(&rps->lock);\n\tGEM_BUG_ON(val > rps->max_freq);\n\tGEM_BUG_ON(val < rps->min_freq);\n\n\tif (intel_rps_is_active(rps)) {\n\t\terr = rps_set(rps, val, true);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\t \n\t\tif (intel_rps_has_interrupts(rps)) {\n\t\t\tstruct intel_uncore *uncore = rps_to_uncore(rps);\n\n\t\t\tset(uncore,\n\t\t\t    GEN6_RP_INTERRUPT_LIMITS, rps_limits(rps, val));\n\n\t\t\tset(uncore, GEN6_PMINTRMSK, rps_pm_mask(rps, val));\n\t\t}\n\t}\n\n\trps->cur_freq = val;\n\treturn 0;\n}\n\nstatic u32 intel_rps_read_state_cap(struct intel_rps *rps)\n{\n\tstruct drm_i915_private *i915 = rps_to_i915(rps);\n\tstruct intel_uncore *uncore = rps_to_uncore(rps);\n\n\tif (IS_PONTEVECCHIO(i915))\n\t\treturn intel_uncore_read(uncore, PVC_RP_STATE_CAP);\n\telse if (IS_XEHPSDV(i915))\n\t\treturn intel_uncore_read(uncore, XEHPSDV_RP_STATE_CAP);\n\telse if (IS_GEN9_LP(i915))\n\t\treturn intel_uncore_read(uncore, BXT_RP_STATE_CAP);\n\telse\n\t\treturn intel_uncore_read(uncore, GEN6_RP_STATE_CAP);\n}\n\nstatic void\nmtl_get_freq_caps(struct intel_rps *rps, struct intel_rps_freq_caps *caps)\n{\n\tstruct intel_uncore *uncore = rps_to_uncore(rps);\n\tu32 rp_state_cap = rps_to_gt(rps)->type == GT_MEDIA ?\n\t\t\t\tintel_uncore_read(uncore, MTL_MEDIAP_STATE_CAP) :\n\t\t\t\tintel_uncore_read(uncore, MTL_RP_STATE_CAP);\n\tu32 rpe = rps_to_gt(rps)->type == GT_MEDIA ?\n\t\t\tintel_uncore_read(uncore, MTL_MPE_FREQUENCY) :\n\t\t\tintel_uncore_read(uncore, MTL_GT_RPE_FREQUENCY);\n\n\t \n\tcaps->rp0_freq = REG_FIELD_GET(MTL_RP0_CAP_MASK, rp_state_cap);\n\tcaps->min_freq = REG_FIELD_GET(MTL_RPN_CAP_MASK, rp_state_cap);\n\tcaps->rp1_freq = REG_FIELD_GET(MTL_RPE_MASK, rpe);\n}\n\nstatic void\n__gen6_rps_get_freq_caps(struct intel_rps *rps, struct intel_rps_freq_caps *caps)\n{\n\tstruct drm_i915_private *i915 = rps_to_i915(rps);\n\tu32 rp_state_cap;\n\n\trp_state_cap = intel_rps_read_state_cap(rps);\n\n\t \n\tif (IS_GEN9_LP(i915)) {\n\t\tcaps->rp0_freq = (rp_state_cap >> 16) & 0xff;\n\t\tcaps->rp1_freq = (rp_state_cap >>  8) & 0xff;\n\t\tcaps->min_freq = (rp_state_cap >>  0) & 0xff;\n\t} else {\n\t\tcaps->rp0_freq = (rp_state_cap >>  0) & 0xff;\n\t\tif (GRAPHICS_VER(i915) >= 10)\n\t\t\tcaps->rp1_freq = REG_FIELD_GET(RPE_MASK,\n\t\t\t\t\t\t       intel_uncore_read(to_gt(i915)->uncore,\n\t\t\t\t\t\t       GEN10_FREQ_INFO_REC));\n\t\telse\n\t\t\tcaps->rp1_freq = (rp_state_cap >>  8) & 0xff;\n\t\tcaps->min_freq = (rp_state_cap >> 16) & 0xff;\n\t}\n\n\tif (IS_GEN9_BC(i915) || GRAPHICS_VER(i915) >= 11) {\n\t\t \n\t\tcaps->rp0_freq *= GEN9_FREQ_SCALER;\n\t\tcaps->rp1_freq *= GEN9_FREQ_SCALER;\n\t\tcaps->min_freq *= GEN9_FREQ_SCALER;\n\t}\n}\n\n \nvoid gen6_rps_get_freq_caps(struct intel_rps *rps, struct intel_rps_freq_caps *caps)\n{\n\tstruct drm_i915_private *i915 = rps_to_i915(rps);\n\n\tif (IS_METEORLAKE(i915))\n\t\treturn mtl_get_freq_caps(rps, caps);\n\telse\n\t\treturn __gen6_rps_get_freq_caps(rps, caps);\n}\n\nstatic void gen6_rps_init(struct intel_rps *rps)\n{\n\tstruct drm_i915_private *i915 = rps_to_i915(rps);\n\tstruct intel_rps_freq_caps caps;\n\n\tgen6_rps_get_freq_caps(rps, &caps);\n\trps->rp0_freq = caps.rp0_freq;\n\trps->rp1_freq = caps.rp1_freq;\n\trps->min_freq = caps.min_freq;\n\n\t \n\trps->max_freq = rps->rp0_freq;\n\n\trps->efficient_freq = rps->rp1_freq;\n\tif (IS_HASWELL(i915) || IS_BROADWELL(i915) ||\n\t    IS_GEN9_BC(i915) || GRAPHICS_VER(i915) >= 11) {\n\t\tu32 ddcc_status = 0;\n\t\tu32 mult = 1;\n\n\t\tif (IS_GEN9_BC(i915) || GRAPHICS_VER(i915) >= 11)\n\t\t\tmult = GEN9_FREQ_SCALER;\n\t\tif (snb_pcode_read(rps_to_gt(rps)->uncore,\n\t\t\t\t   HSW_PCODE_DYNAMIC_DUTY_CYCLE_CONTROL,\n\t\t\t\t   &ddcc_status, NULL) == 0)\n\t\t\trps->efficient_freq =\n\t\t\t\tclamp_t(u32,\n\t\t\t\t\t((ddcc_status >> 8) & 0xff) * mult,\n\t\t\t\t\trps->min_freq,\n\t\t\t\t\trps->max_freq);\n\t}\n}\n\nstatic bool rps_reset(struct intel_rps *rps)\n{\n\tstruct drm_i915_private *i915 = rps_to_i915(rps);\n\n\t \n\trps->power.mode = -1;\n\trps->last_freq = -1;\n\n\tif (rps_set(rps, rps->min_freq, true)) {\n\t\tdrm_err(&i915->drm, \"Failed to reset RPS to initial values\\n\");\n\t\treturn false;\n\t}\n\n\trps->cur_freq = rps->min_freq;\n\treturn true;\n}\n\n \nstatic bool gen9_rps_enable(struct intel_rps *rps)\n{\n\tstruct intel_gt *gt = rps_to_gt(rps);\n\tstruct intel_uncore *uncore = gt->uncore;\n\n\t \n\tif (GRAPHICS_VER(gt->i915) == 9)\n\t\tintel_uncore_write_fw(uncore, GEN6_RC_VIDEO_FREQ,\n\t\t\t\t      GEN9_FREQUENCY(rps->rp1_freq));\n\n\tintel_uncore_write_fw(uncore, GEN6_RP_IDLE_HYSTERSIS, 0xa);\n\n\trps->pm_events = GEN6_PM_RP_UP_THRESHOLD | GEN6_PM_RP_DOWN_THRESHOLD;\n\n\treturn rps_reset(rps);\n}\n\nstatic bool gen8_rps_enable(struct intel_rps *rps)\n{\n\tstruct intel_uncore *uncore = rps_to_uncore(rps);\n\n\tintel_uncore_write_fw(uncore, GEN6_RC_VIDEO_FREQ,\n\t\t\t      HSW_FREQUENCY(rps->rp1_freq));\n\n\tintel_uncore_write_fw(uncore, GEN6_RP_IDLE_HYSTERSIS, 10);\n\n\trps->pm_events = GEN6_PM_RP_UP_THRESHOLD | GEN6_PM_RP_DOWN_THRESHOLD;\n\n\treturn rps_reset(rps);\n}\n\nstatic bool gen6_rps_enable(struct intel_rps *rps)\n{\n\tstruct intel_uncore *uncore = rps_to_uncore(rps);\n\n\t \n\tintel_uncore_write_fw(uncore, GEN6_RP_DOWN_TIMEOUT, 50000);\n\tintel_uncore_write_fw(uncore, GEN6_RP_IDLE_HYSTERSIS, 10);\n\n\trps->pm_events = (GEN6_PM_RP_UP_THRESHOLD |\n\t\t\t  GEN6_PM_RP_DOWN_THRESHOLD |\n\t\t\t  GEN6_PM_RP_DOWN_TIMEOUT);\n\n\treturn rps_reset(rps);\n}\n\nstatic int chv_rps_max_freq(struct intel_rps *rps)\n{\n\tstruct drm_i915_private *i915 = rps_to_i915(rps);\n\tstruct intel_gt *gt = rps_to_gt(rps);\n\tu32 val;\n\n\tval = vlv_punit_read(i915, FB_GFX_FMAX_AT_VMAX_FUSE);\n\n\tswitch (gt->info.sseu.eu_total) {\n\tcase 8:\n\t\t \n\t\tval >>= FB_GFX_FMAX_AT_VMAX_2SS4EU_FUSE_SHIFT;\n\t\tbreak;\n\tcase 12:\n\t\t \n\t\tval >>= FB_GFX_FMAX_AT_VMAX_2SS6EU_FUSE_SHIFT;\n\t\tbreak;\n\tcase 16:\n\t\t \n\tdefault:\n\t\t \n\t\tval >>= FB_GFX_FMAX_AT_VMAX_2SS8EU_FUSE_SHIFT;\n\t\tbreak;\n\t}\n\n\treturn val & FB_GFX_FREQ_FUSE_MASK;\n}\n\nstatic int chv_rps_rpe_freq(struct intel_rps *rps)\n{\n\tstruct drm_i915_private *i915 = rps_to_i915(rps);\n\tu32 val;\n\n\tval = vlv_punit_read(i915, PUNIT_GPU_DUTYCYCLE_REG);\n\tval >>= PUNIT_GPU_DUTYCYCLE_RPE_FREQ_SHIFT;\n\n\treturn val & PUNIT_GPU_DUTYCYCLE_RPE_FREQ_MASK;\n}\n\nstatic int chv_rps_guar_freq(struct intel_rps *rps)\n{\n\tstruct drm_i915_private *i915 = rps_to_i915(rps);\n\tu32 val;\n\n\tval = vlv_punit_read(i915, FB_GFX_FMAX_AT_VMAX_FUSE);\n\n\treturn val & FB_GFX_FREQ_FUSE_MASK;\n}\n\nstatic u32 chv_rps_min_freq(struct intel_rps *rps)\n{\n\tstruct drm_i915_private *i915 = rps_to_i915(rps);\n\tu32 val;\n\n\tval = vlv_punit_read(i915, FB_GFX_FMIN_AT_VMIN_FUSE);\n\tval >>= FB_GFX_FMIN_AT_VMIN_FUSE_SHIFT;\n\n\treturn val & FB_GFX_FREQ_FUSE_MASK;\n}\n\nstatic bool chv_rps_enable(struct intel_rps *rps)\n{\n\tstruct intel_uncore *uncore = rps_to_uncore(rps);\n\tstruct drm_i915_private *i915 = rps_to_i915(rps);\n\tu32 val;\n\n\t \n\tintel_uncore_write_fw(uncore, GEN6_RP_DOWN_TIMEOUT, 1000000);\n\tintel_uncore_write_fw(uncore, GEN6_RP_UP_THRESHOLD, 59400);\n\tintel_uncore_write_fw(uncore, GEN6_RP_DOWN_THRESHOLD, 245000);\n\tintel_uncore_write_fw(uncore, GEN6_RP_UP_EI, 66000);\n\tintel_uncore_write_fw(uncore, GEN6_RP_DOWN_EI, 350000);\n\n\tintel_uncore_write_fw(uncore, GEN6_RP_IDLE_HYSTERSIS, 10);\n\n\t \n\tintel_uncore_write_fw(uncore, GEN6_RP_CONTROL,\n\t\t\t      GEN6_RP_MEDIA_HW_NORMAL_MODE |\n\t\t\t      GEN6_RP_MEDIA_IS_GFX |\n\t\t\t      GEN6_RP_ENABLE |\n\t\t\t      GEN6_RP_UP_BUSY_AVG |\n\t\t\t      GEN6_RP_DOWN_IDLE_AVG);\n\n\trps->pm_events = (GEN6_PM_RP_UP_THRESHOLD |\n\t\t\t  GEN6_PM_RP_DOWN_THRESHOLD |\n\t\t\t  GEN6_PM_RP_DOWN_TIMEOUT);\n\n\t \n\tvlv_punit_get(i915);\n\n\tval = VLV_OVERRIDE_EN | VLV_SOC_TDP_EN | CHV_BIAS_CPU_50_SOC_50;\n\tvlv_punit_write(i915, VLV_TURBO_SOC_OVERRIDE, val);\n\n\tval = vlv_punit_read(i915, PUNIT_REG_GPU_FREQ_STS);\n\n\tvlv_punit_put(i915);\n\n\t \n\tdrm_WARN_ONCE(&i915->drm, (val & GPLLENABLE) == 0,\n\t\t      \"GPLL not enabled\\n\");\n\n\tdrm_dbg(&i915->drm, \"GPLL enabled? %s\\n\",\n\t\tstr_yes_no(val & GPLLENABLE));\n\tdrm_dbg(&i915->drm, \"GPU status: 0x%08x\\n\", val);\n\n\treturn rps_reset(rps);\n}\n\nstatic int vlv_rps_guar_freq(struct intel_rps *rps)\n{\n\tstruct drm_i915_private *i915 = rps_to_i915(rps);\n\tu32 val, rp1;\n\n\tval = vlv_nc_read(i915, IOSF_NC_FB_GFX_FREQ_FUSE);\n\n\trp1 = val & FB_GFX_FGUARANTEED_FREQ_FUSE_MASK;\n\trp1 >>= FB_GFX_FGUARANTEED_FREQ_FUSE_SHIFT;\n\n\treturn rp1;\n}\n\nstatic int vlv_rps_max_freq(struct intel_rps *rps)\n{\n\tstruct drm_i915_private *i915 = rps_to_i915(rps);\n\tu32 val, rp0;\n\n\tval = vlv_nc_read(i915, IOSF_NC_FB_GFX_FREQ_FUSE);\n\n\trp0 = (val & FB_GFX_MAX_FREQ_FUSE_MASK) >> FB_GFX_MAX_FREQ_FUSE_SHIFT;\n\t \n\trp0 = min_t(u32, rp0, 0xea);\n\n\treturn rp0;\n}\n\nstatic int vlv_rps_rpe_freq(struct intel_rps *rps)\n{\n\tstruct drm_i915_private *i915 = rps_to_i915(rps);\n\tu32 val, rpe;\n\n\tval = vlv_nc_read(i915, IOSF_NC_FB_GFX_FMAX_FUSE_LO);\n\trpe = (val & FB_FMAX_VMIN_FREQ_LO_MASK) >> FB_FMAX_VMIN_FREQ_LO_SHIFT;\n\tval = vlv_nc_read(i915, IOSF_NC_FB_GFX_FMAX_FUSE_HI);\n\trpe |= (val & FB_FMAX_VMIN_FREQ_HI_MASK) << 5;\n\n\treturn rpe;\n}\n\nstatic int vlv_rps_min_freq(struct intel_rps *rps)\n{\n\tstruct drm_i915_private *i915 = rps_to_i915(rps);\n\tu32 val;\n\n\tval = vlv_punit_read(i915, PUNIT_REG_GPU_LFM) & 0xff;\n\t \n\treturn max_t(u32, val, 0xc0);\n}\n\nstatic bool vlv_rps_enable(struct intel_rps *rps)\n{\n\tstruct intel_uncore *uncore = rps_to_uncore(rps);\n\tstruct drm_i915_private *i915 = rps_to_i915(rps);\n\tu32 val;\n\n\tintel_uncore_write_fw(uncore, GEN6_RP_DOWN_TIMEOUT, 1000000);\n\tintel_uncore_write_fw(uncore, GEN6_RP_UP_THRESHOLD, 59400);\n\tintel_uncore_write_fw(uncore, GEN6_RP_DOWN_THRESHOLD, 245000);\n\tintel_uncore_write_fw(uncore, GEN6_RP_UP_EI, 66000);\n\tintel_uncore_write_fw(uncore, GEN6_RP_DOWN_EI, 350000);\n\n\tintel_uncore_write_fw(uncore, GEN6_RP_IDLE_HYSTERSIS, 10);\n\n\tintel_uncore_write_fw(uncore, GEN6_RP_CONTROL,\n\t\t\t      GEN6_RP_MEDIA_TURBO |\n\t\t\t      GEN6_RP_MEDIA_HW_NORMAL_MODE |\n\t\t\t      GEN6_RP_MEDIA_IS_GFX |\n\t\t\t      GEN6_RP_ENABLE |\n\t\t\t      GEN6_RP_UP_BUSY_AVG |\n\t\t\t      GEN6_RP_DOWN_IDLE_CONT);\n\n\t \n\trps->pm_events = GEN6_PM_RP_UP_EI_EXPIRED;\n\n\tvlv_punit_get(i915);\n\n\t \n\tval = VLV_OVERRIDE_EN | VLV_SOC_TDP_EN | VLV_BIAS_CPU_125_SOC_875;\n\tvlv_punit_write(i915, VLV_TURBO_SOC_OVERRIDE, val);\n\n\tval = vlv_punit_read(i915, PUNIT_REG_GPU_FREQ_STS);\n\n\tvlv_punit_put(i915);\n\n\t \n\tdrm_WARN_ONCE(&i915->drm, (val & GPLLENABLE) == 0,\n\t\t      \"GPLL not enabled\\n\");\n\n\tdrm_dbg(&i915->drm, \"GPLL enabled? %s\\n\",\n\t\tstr_yes_no(val & GPLLENABLE));\n\tdrm_dbg(&i915->drm, \"GPU status: 0x%08x\\n\", val);\n\n\treturn rps_reset(rps);\n}\n\nstatic unsigned long __ips_gfx_val(struct intel_ips *ips)\n{\n\tstruct intel_rps *rps = container_of(ips, typeof(*rps), ips);\n\tstruct intel_uncore *uncore = rps_to_uncore(rps);\n\tunsigned int t, state1, state2;\n\tu32 pxvid, ext_v;\n\tu64 corr, corr2;\n\n\tlockdep_assert_held(&mchdev_lock);\n\n\tpxvid = intel_uncore_read(uncore, PXVFREQ(rps->cur_freq));\n\tpxvid = (pxvid >> 24) & 0x7f;\n\text_v = pvid_to_extvid(rps_to_i915(rps), pxvid);\n\n\tstate1 = ext_v;\n\n\t \n\n\t \n\tt = ips_mch_val(uncore);\n\tif (t > 80)\n\t\tcorr = t * 2349 + 135940;\n\telse if (t >= 50)\n\t\tcorr = t * 964 + 29317;\n\telse  \n\t\tcorr = t * 301 + 1004;\n\n\tcorr = div_u64(corr * 150142 * state1, 10000) - 78642;\n\tcorr2 = div_u64(corr, 100000) * ips->corr;\n\n\tstate2 = div_u64(corr2 * state1, 10000);\n\tstate2 /= 100;  \n\n\t__gen5_ips_update(ips);\n\n\treturn ips->gfx_power + state2;\n}\n\nstatic bool has_busy_stats(struct intel_rps *rps)\n{\n\tstruct intel_engine_cs *engine;\n\tenum intel_engine_id id;\n\n\tfor_each_engine(engine, rps_to_gt(rps), id) {\n\t\tif (!intel_engine_supports_stats(engine))\n\t\t\treturn false;\n\t}\n\n\treturn true;\n}\n\nvoid intel_rps_enable(struct intel_rps *rps)\n{\n\tstruct drm_i915_private *i915 = rps_to_i915(rps);\n\tstruct intel_uncore *uncore = rps_to_uncore(rps);\n\tbool enabled = false;\n\n\tif (!HAS_RPS(i915))\n\t\treturn;\n\n\tif (rps_uses_slpc(rps))\n\t\treturn;\n\n\tintel_gt_check_clock_frequency(rps_to_gt(rps));\n\n\tintel_uncore_forcewake_get(uncore, FORCEWAKE_ALL);\n\tif (rps->max_freq <= rps->min_freq)\n\t\t ;\n\telse if (IS_CHERRYVIEW(i915))\n\t\tenabled = chv_rps_enable(rps);\n\telse if (IS_VALLEYVIEW(i915))\n\t\tenabled = vlv_rps_enable(rps);\n\telse if (GRAPHICS_VER(i915) >= 9)\n\t\tenabled = gen9_rps_enable(rps);\n\telse if (GRAPHICS_VER(i915) >= 8)\n\t\tenabled = gen8_rps_enable(rps);\n\telse if (GRAPHICS_VER(i915) >= 6)\n\t\tenabled = gen6_rps_enable(rps);\n\telse if (IS_IRONLAKE_M(i915))\n\t\tenabled = gen5_rps_enable(rps);\n\telse\n\t\tMISSING_CASE(GRAPHICS_VER(i915));\n\tintel_uncore_forcewake_put(uncore, FORCEWAKE_ALL);\n\tif (!enabled)\n\t\treturn;\n\n\tGT_TRACE(rps_to_gt(rps),\n\t\t \"min:%x, max:%x, freq:[%d, %d], thresholds:[%u, %u]\\n\",\n\t\t rps->min_freq, rps->max_freq,\n\t\t intel_gpu_freq(rps, rps->min_freq),\n\t\t intel_gpu_freq(rps, rps->max_freq),\n\t\t rps->power.up_threshold,\n\t\t rps->power.down_threshold);\n\n\tGEM_BUG_ON(rps->max_freq < rps->min_freq);\n\tGEM_BUG_ON(rps->idle_freq > rps->max_freq);\n\n\tGEM_BUG_ON(rps->efficient_freq < rps->min_freq);\n\tGEM_BUG_ON(rps->efficient_freq > rps->max_freq);\n\n\tif (has_busy_stats(rps))\n\t\tintel_rps_set_timer(rps);\n\telse if (GRAPHICS_VER(i915) >= 6 && GRAPHICS_VER(i915) <= 11)\n\t\tintel_rps_set_interrupts(rps);\n\telse\n\t\t  {}\n\n\tintel_rps_set_enabled(rps);\n}\n\nstatic void gen6_rps_disable(struct intel_rps *rps)\n{\n\tset(rps_to_uncore(rps), GEN6_RP_CONTROL, 0);\n}\n\nvoid intel_rps_disable(struct intel_rps *rps)\n{\n\tstruct drm_i915_private *i915 = rps_to_i915(rps);\n\n\tif (!intel_rps_is_enabled(rps))\n\t\treturn;\n\n\tintel_rps_clear_enabled(rps);\n\tintel_rps_clear_interrupts(rps);\n\tintel_rps_clear_timer(rps);\n\n\tif (GRAPHICS_VER(i915) >= 6)\n\t\tgen6_rps_disable(rps);\n\telse if (IS_IRONLAKE_M(i915))\n\t\tgen5_rps_disable(rps);\n}\n\nstatic int byt_gpu_freq(struct intel_rps *rps, int val)\n{\n\t \n\treturn DIV_ROUND_CLOSEST(rps->gpll_ref_freq * (val - 0xb7), 1000);\n}\n\nstatic int byt_freq_opcode(struct intel_rps *rps, int val)\n{\n\treturn DIV_ROUND_CLOSEST(1000 * val, rps->gpll_ref_freq) + 0xb7;\n}\n\nstatic int chv_gpu_freq(struct intel_rps *rps, int val)\n{\n\t \n\treturn DIV_ROUND_CLOSEST(rps->gpll_ref_freq * val, 2 * 2 * 1000);\n}\n\nstatic int chv_freq_opcode(struct intel_rps *rps, int val)\n{\n\t \n\treturn DIV_ROUND_CLOSEST(2 * 1000 * val, rps->gpll_ref_freq) * 2;\n}\n\nint intel_gpu_freq(struct intel_rps *rps, int val)\n{\n\tstruct drm_i915_private *i915 = rps_to_i915(rps);\n\n\tif (GRAPHICS_VER(i915) >= 9)\n\t\treturn DIV_ROUND_CLOSEST(val * GT_FREQUENCY_MULTIPLIER,\n\t\t\t\t\t GEN9_FREQ_SCALER);\n\telse if (IS_CHERRYVIEW(i915))\n\t\treturn chv_gpu_freq(rps, val);\n\telse if (IS_VALLEYVIEW(i915))\n\t\treturn byt_gpu_freq(rps, val);\n\telse if (GRAPHICS_VER(i915) >= 6)\n\t\treturn val * GT_FREQUENCY_MULTIPLIER;\n\telse\n\t\treturn val;\n}\n\nint intel_freq_opcode(struct intel_rps *rps, int val)\n{\n\tstruct drm_i915_private *i915 = rps_to_i915(rps);\n\n\tif (GRAPHICS_VER(i915) >= 9)\n\t\treturn DIV_ROUND_CLOSEST(val * GEN9_FREQ_SCALER,\n\t\t\t\t\t GT_FREQUENCY_MULTIPLIER);\n\telse if (IS_CHERRYVIEW(i915))\n\t\treturn chv_freq_opcode(rps, val);\n\telse if (IS_VALLEYVIEW(i915))\n\t\treturn byt_freq_opcode(rps, val);\n\telse if (GRAPHICS_VER(i915) >= 6)\n\t\treturn DIV_ROUND_CLOSEST(val, GT_FREQUENCY_MULTIPLIER);\n\telse\n\t\treturn val;\n}\n\nstatic void vlv_init_gpll_ref_freq(struct intel_rps *rps)\n{\n\tstruct drm_i915_private *i915 = rps_to_i915(rps);\n\n\trps->gpll_ref_freq =\n\t\tvlv_get_cck_clock(i915, \"GPLL ref\",\n\t\t\t\t  CCK_GPLL_CLOCK_CONTROL,\n\t\t\t\t  i915->czclk_freq);\n\n\tdrm_dbg(&i915->drm, \"GPLL reference freq: %d kHz\\n\",\n\t\trps->gpll_ref_freq);\n}\n\nstatic void vlv_rps_init(struct intel_rps *rps)\n{\n\tstruct drm_i915_private *i915 = rps_to_i915(rps);\n\n\tvlv_iosf_sb_get(i915,\n\t\t\tBIT(VLV_IOSF_SB_PUNIT) |\n\t\t\tBIT(VLV_IOSF_SB_NC) |\n\t\t\tBIT(VLV_IOSF_SB_CCK));\n\n\tvlv_init_gpll_ref_freq(rps);\n\n\trps->max_freq = vlv_rps_max_freq(rps);\n\trps->rp0_freq = rps->max_freq;\n\tdrm_dbg(&i915->drm, \"max GPU freq: %d MHz (%u)\\n\",\n\t\tintel_gpu_freq(rps, rps->max_freq), rps->max_freq);\n\n\trps->efficient_freq = vlv_rps_rpe_freq(rps);\n\tdrm_dbg(&i915->drm, \"RPe GPU freq: %d MHz (%u)\\n\",\n\t\tintel_gpu_freq(rps, rps->efficient_freq), rps->efficient_freq);\n\n\trps->rp1_freq = vlv_rps_guar_freq(rps);\n\tdrm_dbg(&i915->drm, \"RP1(Guar Freq) GPU freq: %d MHz (%u)\\n\",\n\t\tintel_gpu_freq(rps, rps->rp1_freq), rps->rp1_freq);\n\n\trps->min_freq = vlv_rps_min_freq(rps);\n\tdrm_dbg(&i915->drm, \"min GPU freq: %d MHz (%u)\\n\",\n\t\tintel_gpu_freq(rps, rps->min_freq), rps->min_freq);\n\n\tvlv_iosf_sb_put(i915,\n\t\t\tBIT(VLV_IOSF_SB_PUNIT) |\n\t\t\tBIT(VLV_IOSF_SB_NC) |\n\t\t\tBIT(VLV_IOSF_SB_CCK));\n}\n\nstatic void chv_rps_init(struct intel_rps *rps)\n{\n\tstruct drm_i915_private *i915 = rps_to_i915(rps);\n\n\tvlv_iosf_sb_get(i915,\n\t\t\tBIT(VLV_IOSF_SB_PUNIT) |\n\t\t\tBIT(VLV_IOSF_SB_NC) |\n\t\t\tBIT(VLV_IOSF_SB_CCK));\n\n\tvlv_init_gpll_ref_freq(rps);\n\n\trps->max_freq = chv_rps_max_freq(rps);\n\trps->rp0_freq = rps->max_freq;\n\tdrm_dbg(&i915->drm, \"max GPU freq: %d MHz (%u)\\n\",\n\t\tintel_gpu_freq(rps, rps->max_freq), rps->max_freq);\n\n\trps->efficient_freq = chv_rps_rpe_freq(rps);\n\tdrm_dbg(&i915->drm, \"RPe GPU freq: %d MHz (%u)\\n\",\n\t\tintel_gpu_freq(rps, rps->efficient_freq), rps->efficient_freq);\n\n\trps->rp1_freq = chv_rps_guar_freq(rps);\n\tdrm_dbg(&i915->drm, \"RP1(Guar) GPU freq: %d MHz (%u)\\n\",\n\t\tintel_gpu_freq(rps, rps->rp1_freq), rps->rp1_freq);\n\n\trps->min_freq = chv_rps_min_freq(rps);\n\tdrm_dbg(&i915->drm, \"min GPU freq: %d MHz (%u)\\n\",\n\t\tintel_gpu_freq(rps, rps->min_freq), rps->min_freq);\n\n\tvlv_iosf_sb_put(i915,\n\t\t\tBIT(VLV_IOSF_SB_PUNIT) |\n\t\t\tBIT(VLV_IOSF_SB_NC) |\n\t\t\tBIT(VLV_IOSF_SB_CCK));\n\n\tdrm_WARN_ONCE(&i915->drm, (rps->max_freq | rps->efficient_freq |\n\t\t\t\t   rps->rp1_freq | rps->min_freq) & 1,\n\t\t      \"Odd GPU freq values\\n\");\n}\n\nstatic void vlv_c0_read(struct intel_uncore *uncore, struct intel_rps_ei *ei)\n{\n\tei->ktime = ktime_get_raw();\n\tei->render_c0 = intel_uncore_read(uncore, VLV_RENDER_C0_COUNT);\n\tei->media_c0 = intel_uncore_read(uncore, VLV_MEDIA_C0_COUNT);\n}\n\nstatic u32 vlv_wa_c0_ei(struct intel_rps *rps, u32 pm_iir)\n{\n\tstruct intel_uncore *uncore = rps_to_uncore(rps);\n\tconst struct intel_rps_ei *prev = &rps->ei;\n\tstruct intel_rps_ei now;\n\tu32 events = 0;\n\n\tif ((pm_iir & GEN6_PM_RP_UP_EI_EXPIRED) == 0)\n\t\treturn 0;\n\n\tvlv_c0_read(uncore, &now);\n\n\tif (prev->ktime) {\n\t\tu64 time, c0;\n\t\tu32 render, media;\n\n\t\ttime = ktime_us_delta(now.ktime, prev->ktime);\n\n\t\ttime *= rps_to_i915(rps)->czclk_freq;\n\n\t\t \n\t\trender = now.render_c0 - prev->render_c0;\n\t\tmedia = now.media_c0 - prev->media_c0;\n\t\tc0 = max(render, media);\n\t\tc0 *= 1000 * 100 << 8;  \n\n\t\tif (c0 > time * rps->power.up_threshold)\n\t\t\tevents = GEN6_PM_RP_UP_THRESHOLD;\n\t\telse if (c0 < time * rps->power.down_threshold)\n\t\t\tevents = GEN6_PM_RP_DOWN_THRESHOLD;\n\t}\n\n\trps->ei = now;\n\treturn events;\n}\n\nstatic void rps_work(struct work_struct *work)\n{\n\tstruct intel_rps *rps = container_of(work, typeof(*rps), work);\n\tstruct intel_gt *gt = rps_to_gt(rps);\n\tstruct drm_i915_private *i915 = rps_to_i915(rps);\n\tbool client_boost = false;\n\tint new_freq, adj, min, max;\n\tu32 pm_iir = 0;\n\n\tspin_lock_irq(gt->irq_lock);\n\tpm_iir = fetch_and_zero(&rps->pm_iir) & rps->pm_events;\n\tclient_boost = atomic_read(&rps->num_waiters);\n\tspin_unlock_irq(gt->irq_lock);\n\n\t \n\tif (!pm_iir && !client_boost)\n\t\tgoto out;\n\n\tmutex_lock(&rps->lock);\n\tif (!intel_rps_is_active(rps)) {\n\t\tmutex_unlock(&rps->lock);\n\t\treturn;\n\t}\n\n\tpm_iir |= vlv_wa_c0_ei(rps, pm_iir);\n\n\tadj = rps->last_adj;\n\tnew_freq = rps->cur_freq;\n\tmin = rps->min_freq_softlimit;\n\tmax = rps->max_freq_softlimit;\n\tif (client_boost)\n\t\tmax = rps->max_freq;\n\n\tGT_TRACE(gt,\n\t\t \"pm_iir:%x, client_boost:%s, last:%d, cur:%x, min:%x, max:%x\\n\",\n\t\t pm_iir, str_yes_no(client_boost),\n\t\t adj, new_freq, min, max);\n\n\tif (client_boost && new_freq < rps->boost_freq) {\n\t\tnew_freq = rps->boost_freq;\n\t\tadj = 0;\n\t} else if (pm_iir & GEN6_PM_RP_UP_THRESHOLD) {\n\t\tif (adj > 0)\n\t\t\tadj *= 2;\n\t\telse  \n\t\t\tadj = IS_CHERRYVIEW(gt->i915) ? 2 : 1;\n\n\t\tif (new_freq >= rps->max_freq_softlimit)\n\t\t\tadj = 0;\n\t} else if (client_boost) {\n\t\tadj = 0;\n\t} else if (pm_iir & GEN6_PM_RP_DOWN_TIMEOUT) {\n\t\tif (rps->cur_freq > rps->efficient_freq)\n\t\t\tnew_freq = rps->efficient_freq;\n\t\telse if (rps->cur_freq > rps->min_freq_softlimit)\n\t\t\tnew_freq = rps->min_freq_softlimit;\n\t\tadj = 0;\n\t} else if (pm_iir & GEN6_PM_RP_DOWN_THRESHOLD) {\n\t\tif (adj < 0)\n\t\t\tadj *= 2;\n\t\telse  \n\t\t\tadj = IS_CHERRYVIEW(gt->i915) ? -2 : -1;\n\n\t\tif (new_freq <= rps->min_freq_softlimit)\n\t\t\tadj = 0;\n\t} else {  \n\t\tadj = 0;\n\t}\n\n\t \n\tnew_freq += adj;\n\tnew_freq = clamp_t(int, new_freq, min, max);\n\n\tif (intel_rps_set(rps, new_freq)) {\n\t\tdrm_dbg(&i915->drm, \"Failed to set new GPU frequency\\n\");\n\t\tadj = 0;\n\t}\n\trps->last_adj = adj;\n\n\tmutex_unlock(&rps->lock);\n\nout:\n\tspin_lock_irq(gt->irq_lock);\n\tgen6_gt_pm_unmask_irq(gt, rps->pm_events);\n\tspin_unlock_irq(gt->irq_lock);\n}\n\nvoid gen11_rps_irq_handler(struct intel_rps *rps, u32 pm_iir)\n{\n\tstruct intel_gt *gt = rps_to_gt(rps);\n\tconst u32 events = rps->pm_events & pm_iir;\n\n\tlockdep_assert_held(gt->irq_lock);\n\n\tif (unlikely(!events))\n\t\treturn;\n\n\tGT_TRACE(gt, \"irq events:%x\\n\", events);\n\n\tgen6_gt_pm_mask_irq(gt, events);\n\n\trps->pm_iir |= events;\n\tqueue_work(gt->i915->unordered_wq, &rps->work);\n}\n\nvoid gen6_rps_irq_handler(struct intel_rps *rps, u32 pm_iir)\n{\n\tstruct intel_gt *gt = rps_to_gt(rps);\n\tu32 events;\n\n\tevents = pm_iir & rps->pm_events;\n\tif (events) {\n\t\tspin_lock(gt->irq_lock);\n\n\t\tGT_TRACE(gt, \"irq events:%x\\n\", events);\n\n\t\tgen6_gt_pm_mask_irq(gt, events);\n\t\trps->pm_iir |= events;\n\n\t\tqueue_work(gt->i915->unordered_wq, &rps->work);\n\t\tspin_unlock(gt->irq_lock);\n\t}\n\n\tif (GRAPHICS_VER(gt->i915) >= 8)\n\t\treturn;\n\n\tif (pm_iir & PM_VEBOX_USER_INTERRUPT)\n\t\tintel_engine_cs_irq(gt->engine[VECS0], pm_iir >> 10);\n\n\tif (pm_iir & PM_VEBOX_CS_ERROR_INTERRUPT)\n\t\tdrm_dbg(&rps_to_i915(rps)->drm,\n\t\t\t\"Command parser error, pm_iir 0x%08x\\n\", pm_iir);\n}\n\nvoid gen5_rps_irq_handler(struct intel_rps *rps)\n{\n\tstruct intel_uncore *uncore = rps_to_uncore(rps);\n\tu32 busy_up, busy_down, max_avg, min_avg;\n\tu8 new_freq;\n\n\tspin_lock(&mchdev_lock);\n\n\tintel_uncore_write16(uncore,\n\t\t\t     MEMINTRSTS,\n\t\t\t     intel_uncore_read(uncore, MEMINTRSTS));\n\n\tintel_uncore_write16(uncore, MEMINTRSTS, MEMINT_EVAL_CHG);\n\tbusy_up = intel_uncore_read(uncore, RCPREVBSYTUPAVG);\n\tbusy_down = intel_uncore_read(uncore, RCPREVBSYTDNAVG);\n\tmax_avg = intel_uncore_read(uncore, RCBMAXAVG);\n\tmin_avg = intel_uncore_read(uncore, RCBMINAVG);\n\n\t \n\tnew_freq = rps->cur_freq;\n\tif (busy_up > max_avg)\n\t\tnew_freq++;\n\telse if (busy_down < min_avg)\n\t\tnew_freq--;\n\tnew_freq = clamp(new_freq,\n\t\t\t rps->min_freq_softlimit,\n\t\t\t rps->max_freq_softlimit);\n\n\tif (new_freq != rps->cur_freq && !__gen5_rps_set(rps, new_freq))\n\t\trps->cur_freq = new_freq;\n\n\tspin_unlock(&mchdev_lock);\n}\n\nvoid intel_rps_init_early(struct intel_rps *rps)\n{\n\tmutex_init(&rps->lock);\n\tmutex_init(&rps->power.mutex);\n\n\tINIT_WORK(&rps->work, rps_work);\n\ttimer_setup(&rps->timer, rps_timer, 0);\n\n\tatomic_set(&rps->num_waiters, 0);\n}\n\nvoid intel_rps_init(struct intel_rps *rps)\n{\n\tstruct drm_i915_private *i915 = rps_to_i915(rps);\n\n\tif (rps_uses_slpc(rps))\n\t\treturn;\n\n\tif (IS_CHERRYVIEW(i915))\n\t\tchv_rps_init(rps);\n\telse if (IS_VALLEYVIEW(i915))\n\t\tvlv_rps_init(rps);\n\telse if (GRAPHICS_VER(i915) >= 6)\n\t\tgen6_rps_init(rps);\n\telse if (IS_IRONLAKE_M(i915))\n\t\tgen5_rps_init(rps);\n\n\t \n\trps->max_freq_softlimit = rps->max_freq;\n\trps_to_gt(rps)->defaults.max_freq = rps->max_freq_softlimit;\n\trps->min_freq_softlimit = rps->min_freq;\n\trps_to_gt(rps)->defaults.min_freq = rps->min_freq_softlimit;\n\n\t \n\tif (GRAPHICS_VER(i915) == 6 || IS_IVYBRIDGE(i915) || IS_HASWELL(i915)) {\n\t\tu32 params = 0;\n\n\t\tsnb_pcode_read(rps_to_gt(rps)->uncore, GEN6_READ_OC_PARAMS, &params, NULL);\n\t\tif (params & BIT(31)) {  \n\t\t\tdrm_dbg(&i915->drm,\n\t\t\t\t\"Overclocking supported, max: %dMHz, overclock: %dMHz\\n\",\n\t\t\t\t(rps->max_freq & 0xff) * 50,\n\t\t\t\t(params & 0xff) * 50);\n\t\t\trps->max_freq = params & 0xff;\n\t\t}\n\t}\n\n\t \n\trps->power.up_threshold = 95;\n\trps_to_gt(rps)->defaults.rps_up_threshold = rps->power.up_threshold;\n\trps->power.down_threshold = 85;\n\trps_to_gt(rps)->defaults.rps_down_threshold = rps->power.down_threshold;\n\n\t \n\trps->boost_freq = rps->max_freq;\n\trps->idle_freq = rps->min_freq;\n\n\t \n\trps->cur_freq = rps->efficient_freq;\n\n\trps->pm_intrmsk_mbz = 0;\n\n\t \n\tif (GRAPHICS_VER(i915) <= 7)\n\t\trps->pm_intrmsk_mbz |= GEN6_PM_RP_UP_EI_EXPIRED;\n\n\tif (GRAPHICS_VER(i915) >= 8 && GRAPHICS_VER(i915) < 11)\n\t\trps->pm_intrmsk_mbz |= GEN8_PMINTR_DISABLE_REDIRECT_TO_GUC;\n\n\t \n\tif (intel_uc_uses_guc_submission(&rps_to_gt(rps)->uc))\n\t\trps->pm_intrmsk_mbz |= ARAT_EXPIRED_INTRMSK;\n}\n\nvoid intel_rps_sanitize(struct intel_rps *rps)\n{\n\tif (rps_uses_slpc(rps))\n\t\treturn;\n\n\tif (GRAPHICS_VER(rps_to_i915(rps)) >= 6)\n\t\trps_disable_interrupts(rps);\n}\n\nu32 intel_rps_read_rpstat(struct intel_rps *rps)\n{\n\tstruct drm_i915_private *i915 = rps_to_i915(rps);\n\ti915_reg_t rpstat;\n\n\trpstat = (GRAPHICS_VER(i915) >= 12) ? GEN12_RPSTAT1 : GEN6_RPSTAT1;\n\n\treturn intel_uncore_read(rps_to_gt(rps)->uncore, rpstat);\n}\n\nstatic u32 intel_rps_get_cagf(struct intel_rps *rps, u32 rpstat)\n{\n\tstruct drm_i915_private *i915 = rps_to_i915(rps);\n\tu32 cagf;\n\n\tif (GRAPHICS_VER_FULL(i915) >= IP_VER(12, 70))\n\t\tcagf = REG_FIELD_GET(MTL_CAGF_MASK, rpstat);\n\telse if (GRAPHICS_VER(i915) >= 12)\n\t\tcagf = REG_FIELD_GET(GEN12_CAGF_MASK, rpstat);\n\telse if (IS_VALLEYVIEW(i915) || IS_CHERRYVIEW(i915))\n\t\tcagf = REG_FIELD_GET(RPE_MASK, rpstat);\n\telse if (GRAPHICS_VER(i915) >= 9)\n\t\tcagf = REG_FIELD_GET(GEN9_CAGF_MASK, rpstat);\n\telse if (IS_HASWELL(i915) || IS_BROADWELL(i915))\n\t\tcagf = REG_FIELD_GET(HSW_CAGF_MASK, rpstat);\n\telse if (GRAPHICS_VER(i915) >= 6)\n\t\tcagf = REG_FIELD_GET(GEN6_CAGF_MASK, rpstat);\n\telse\n\t\tcagf = gen5_invert_freq(rps, REG_FIELD_GET(MEMSTAT_PSTATE_MASK, rpstat));\n\n\treturn cagf;\n}\n\nstatic u32 __read_cagf(struct intel_rps *rps, bool take_fw)\n{\n\tstruct drm_i915_private *i915 = rps_to_i915(rps);\n\tstruct intel_uncore *uncore = rps_to_uncore(rps);\n\ti915_reg_t r = INVALID_MMIO_REG;\n\tu32 freq;\n\n\t \n\tif (GRAPHICS_VER_FULL(i915) >= IP_VER(12, 70)) {\n\t\tr = MTL_MIRROR_TARGET_WP1;\n\t} else if (GRAPHICS_VER(i915) >= 12) {\n\t\tr = GEN12_RPSTAT1;\n\t} else if (IS_VALLEYVIEW(i915) || IS_CHERRYVIEW(i915)) {\n\t\tvlv_punit_get(i915);\n\t\tfreq = vlv_punit_read(i915, PUNIT_REG_GPU_FREQ_STS);\n\t\tvlv_punit_put(i915);\n\t} else if (GRAPHICS_VER(i915) >= 6) {\n\t\tr = GEN6_RPSTAT1;\n\t} else {\n\t\tr = MEMSTAT_ILK;\n\t}\n\n\tif (i915_mmio_reg_valid(r))\n\t\tfreq = take_fw ? intel_uncore_read(uncore, r) : intel_uncore_read_fw(uncore, r);\n\n\treturn intel_rps_get_cagf(rps, freq);\n}\n\nstatic u32 read_cagf(struct intel_rps *rps)\n{\n\treturn __read_cagf(rps, true);\n}\n\nu32 intel_rps_read_actual_frequency(struct intel_rps *rps)\n{\n\tstruct intel_runtime_pm *rpm = rps_to_uncore(rps)->rpm;\n\tintel_wakeref_t wakeref;\n\tu32 freq = 0;\n\n\twith_intel_runtime_pm_if_in_use(rpm, wakeref)\n\t\tfreq = intel_gpu_freq(rps, read_cagf(rps));\n\n\treturn freq;\n}\n\nu32 intel_rps_read_actual_frequency_fw(struct intel_rps *rps)\n{\n\treturn intel_gpu_freq(rps, __read_cagf(rps, false));\n}\n\nstatic u32 intel_rps_read_punit_req(struct intel_rps *rps)\n{\n\tstruct intel_uncore *uncore = rps_to_uncore(rps);\n\tstruct intel_runtime_pm *rpm = rps_to_uncore(rps)->rpm;\n\tintel_wakeref_t wakeref;\n\tu32 freq = 0;\n\n\twith_intel_runtime_pm_if_in_use(rpm, wakeref)\n\t\tfreq = intel_uncore_read(uncore, GEN6_RPNSWREQ);\n\n\treturn freq;\n}\n\nstatic u32 intel_rps_get_req(u32 pureq)\n{\n\tu32 req = pureq >> GEN9_SW_REQ_UNSLICE_RATIO_SHIFT;\n\n\treturn req;\n}\n\nu32 intel_rps_read_punit_req_frequency(struct intel_rps *rps)\n{\n\tu32 freq = intel_rps_get_req(intel_rps_read_punit_req(rps));\n\n\treturn intel_gpu_freq(rps, freq);\n}\n\nu32 intel_rps_get_requested_frequency(struct intel_rps *rps)\n{\n\tif (rps_uses_slpc(rps))\n\t\treturn intel_rps_read_punit_req_frequency(rps);\n\telse\n\t\treturn intel_gpu_freq(rps, rps->cur_freq);\n}\n\nu32 intel_rps_get_max_frequency(struct intel_rps *rps)\n{\n\tstruct intel_guc_slpc *slpc = rps_to_slpc(rps);\n\n\tif (rps_uses_slpc(rps))\n\t\treturn slpc->max_freq_softlimit;\n\telse\n\t\treturn intel_gpu_freq(rps, rps->max_freq_softlimit);\n}\n\n \nu32 intel_rps_get_max_raw_freq(struct intel_rps *rps)\n{\n\tstruct intel_guc_slpc *slpc = rps_to_slpc(rps);\n\tu32 freq;\n\n\tif (rps_uses_slpc(rps)) {\n\t\treturn DIV_ROUND_CLOSEST(slpc->rp0_freq,\n\t\t\t\t\t GT_FREQUENCY_MULTIPLIER);\n\t} else {\n\t\tfreq = rps->max_freq;\n\t\tif (GRAPHICS_VER(rps_to_i915(rps)) >= 9) {\n\t\t\t \n\t\t\tfreq /= GEN9_FREQ_SCALER;\n\t\t}\n\t\treturn freq;\n\t}\n}\n\nu32 intel_rps_get_rp0_frequency(struct intel_rps *rps)\n{\n\tstruct intel_guc_slpc *slpc = rps_to_slpc(rps);\n\n\tif (rps_uses_slpc(rps))\n\t\treturn slpc->rp0_freq;\n\telse\n\t\treturn intel_gpu_freq(rps, rps->rp0_freq);\n}\n\nu32 intel_rps_get_rp1_frequency(struct intel_rps *rps)\n{\n\tstruct intel_guc_slpc *slpc = rps_to_slpc(rps);\n\n\tif (rps_uses_slpc(rps))\n\t\treturn slpc->rp1_freq;\n\telse\n\t\treturn intel_gpu_freq(rps, rps->rp1_freq);\n}\n\nu32 intel_rps_get_rpn_frequency(struct intel_rps *rps)\n{\n\tstruct intel_guc_slpc *slpc = rps_to_slpc(rps);\n\n\tif (rps_uses_slpc(rps))\n\t\treturn slpc->min_freq;\n\telse\n\t\treturn intel_gpu_freq(rps, rps->min_freq);\n}\n\nstatic void rps_frequency_dump(struct intel_rps *rps, struct drm_printer *p)\n{\n\tstruct intel_gt *gt = rps_to_gt(rps);\n\tstruct drm_i915_private *i915 = gt->i915;\n\tstruct intel_uncore *uncore = gt->uncore;\n\tstruct intel_rps_freq_caps caps;\n\tu32 rp_state_limits;\n\tu32 gt_perf_status;\n\tu32 rpmodectl, rpinclimit, rpdeclimit;\n\tu32 rpstat, cagf, reqf;\n\tu32 rpcurupei, rpcurup, rpprevup;\n\tu32 rpcurdownei, rpcurdown, rpprevdown;\n\tu32 rpupei, rpupt, rpdownei, rpdownt;\n\tu32 pm_ier, pm_imr, pm_isr, pm_iir, pm_mask;\n\n\trp_state_limits = intel_uncore_read(uncore, GEN6_RP_STATE_LIMITS);\n\tgen6_rps_get_freq_caps(rps, &caps);\n\tif (IS_GEN9_LP(i915))\n\t\tgt_perf_status = intel_uncore_read(uncore, BXT_GT_PERF_STATUS);\n\telse\n\t\tgt_perf_status = intel_uncore_read(uncore, GEN6_GT_PERF_STATUS);\n\n\t \n\tintel_uncore_forcewake_get(uncore, FORCEWAKE_ALL);\n\n\treqf = intel_uncore_read(uncore, GEN6_RPNSWREQ);\n\tif (GRAPHICS_VER(i915) >= 9) {\n\t\treqf >>= 23;\n\t} else {\n\t\treqf &= ~GEN6_TURBO_DISABLE;\n\t\tif (IS_HASWELL(i915) || IS_BROADWELL(i915))\n\t\t\treqf >>= 24;\n\t\telse\n\t\t\treqf >>= 25;\n\t}\n\treqf = intel_gpu_freq(rps, reqf);\n\n\trpmodectl = intel_uncore_read(uncore, GEN6_RP_CONTROL);\n\trpinclimit = intel_uncore_read(uncore, GEN6_RP_UP_THRESHOLD);\n\trpdeclimit = intel_uncore_read(uncore, GEN6_RP_DOWN_THRESHOLD);\n\n\trpstat = intel_rps_read_rpstat(rps);\n\trpcurupei = intel_uncore_read(uncore, GEN6_RP_CUR_UP_EI) & GEN6_CURICONT_MASK;\n\trpcurup = intel_uncore_read(uncore, GEN6_RP_CUR_UP) & GEN6_CURBSYTAVG_MASK;\n\trpprevup = intel_uncore_read(uncore, GEN6_RP_PREV_UP) & GEN6_CURBSYTAVG_MASK;\n\trpcurdownei = intel_uncore_read(uncore, GEN6_RP_CUR_DOWN_EI) & GEN6_CURIAVG_MASK;\n\trpcurdown = intel_uncore_read(uncore, GEN6_RP_CUR_DOWN) & GEN6_CURBSYTAVG_MASK;\n\trpprevdown = intel_uncore_read(uncore, GEN6_RP_PREV_DOWN) & GEN6_CURBSYTAVG_MASK;\n\n\trpupei = intel_uncore_read(uncore, GEN6_RP_UP_EI);\n\trpupt = intel_uncore_read(uncore, GEN6_RP_UP_THRESHOLD);\n\n\trpdownei = intel_uncore_read(uncore, GEN6_RP_DOWN_EI);\n\trpdownt = intel_uncore_read(uncore, GEN6_RP_DOWN_THRESHOLD);\n\n\tcagf = intel_rps_read_actual_frequency(rps);\n\n\tintel_uncore_forcewake_put(uncore, FORCEWAKE_ALL);\n\n\tif (GRAPHICS_VER(i915) >= 11) {\n\t\tpm_ier = intel_uncore_read(uncore, GEN11_GPM_WGBOXPERF_INTR_ENABLE);\n\t\tpm_imr = intel_uncore_read(uncore, GEN11_GPM_WGBOXPERF_INTR_MASK);\n\t\t \n\t\tpm_isr = 0;\n\t\tpm_iir = 0;\n\t} else if (GRAPHICS_VER(i915) >= 8) {\n\t\tpm_ier = intel_uncore_read(uncore, GEN8_GT_IER(2));\n\t\tpm_imr = intel_uncore_read(uncore, GEN8_GT_IMR(2));\n\t\tpm_isr = intel_uncore_read(uncore, GEN8_GT_ISR(2));\n\t\tpm_iir = intel_uncore_read(uncore, GEN8_GT_IIR(2));\n\t} else {\n\t\tpm_ier = intel_uncore_read(uncore, GEN6_PMIER);\n\t\tpm_imr = intel_uncore_read(uncore, GEN6_PMIMR);\n\t\tpm_isr = intel_uncore_read(uncore, GEN6_PMISR);\n\t\tpm_iir = intel_uncore_read(uncore, GEN6_PMIIR);\n\t}\n\tpm_mask = intel_uncore_read(uncore, GEN6_PMINTRMSK);\n\n\tdrm_printf(p, \"Video Turbo Mode: %s\\n\",\n\t\t   str_yes_no(rpmodectl & GEN6_RP_MEDIA_TURBO));\n\tdrm_printf(p, \"HW control enabled: %s\\n\",\n\t\t   str_yes_no(rpmodectl & GEN6_RP_ENABLE));\n\tdrm_printf(p, \"SW control enabled: %s\\n\",\n\t\t   str_yes_no((rpmodectl & GEN6_RP_MEDIA_MODE_MASK) == GEN6_RP_MEDIA_SW_MODE));\n\n\tdrm_printf(p, \"PM IER=0x%08x IMR=0x%08x, MASK=0x%08x\\n\",\n\t\t   pm_ier, pm_imr, pm_mask);\n\tif (GRAPHICS_VER(i915) <= 10)\n\t\tdrm_printf(p, \"PM ISR=0x%08x IIR=0x%08x\\n\",\n\t\t\t   pm_isr, pm_iir);\n\tdrm_printf(p, \"pm_intrmsk_mbz: 0x%08x\\n\",\n\t\t   rps->pm_intrmsk_mbz);\n\tdrm_printf(p, \"GT_PERF_STATUS: 0x%08x\\n\", gt_perf_status);\n\tdrm_printf(p, \"Render p-state ratio: %d\\n\",\n\t\t   (gt_perf_status & (GRAPHICS_VER(i915) >= 9 ? 0x1ff00 : 0xff00)) >> 8);\n\tdrm_printf(p, \"Render p-state VID: %d\\n\",\n\t\t   gt_perf_status & 0xff);\n\tdrm_printf(p, \"Render p-state limit: %d\\n\",\n\t\t   rp_state_limits & 0xff);\n\tdrm_printf(p, \"RPSTAT1: 0x%08x\\n\", rpstat);\n\tdrm_printf(p, \"RPMODECTL: 0x%08x\\n\", rpmodectl);\n\tdrm_printf(p, \"RPINCLIMIT: 0x%08x\\n\", rpinclimit);\n\tdrm_printf(p, \"RPDECLIMIT: 0x%08x\\n\", rpdeclimit);\n\tdrm_printf(p, \"RPNSWREQ: %dMHz\\n\", reqf);\n\tdrm_printf(p, \"CAGF: %dMHz\\n\", cagf);\n\tdrm_printf(p, \"RP CUR UP EI: %d (%lldns)\\n\",\n\t\t   rpcurupei,\n\t\t   intel_gt_pm_interval_to_ns(gt, rpcurupei));\n\tdrm_printf(p, \"RP CUR UP: %d (%lldns)\\n\",\n\t\t   rpcurup, intel_gt_pm_interval_to_ns(gt, rpcurup));\n\tdrm_printf(p, \"RP PREV UP: %d (%lldns)\\n\",\n\t\t   rpprevup, intel_gt_pm_interval_to_ns(gt, rpprevup));\n\tdrm_printf(p, \"Up threshold: %d%%\\n\",\n\t\t   rps->power.up_threshold);\n\tdrm_printf(p, \"RP UP EI: %d (%lldns)\\n\",\n\t\t   rpupei, intel_gt_pm_interval_to_ns(gt, rpupei));\n\tdrm_printf(p, \"RP UP THRESHOLD: %d (%lldns)\\n\",\n\t\t   rpupt, intel_gt_pm_interval_to_ns(gt, rpupt));\n\n\tdrm_printf(p, \"RP CUR DOWN EI: %d (%lldns)\\n\",\n\t\t   rpcurdownei,\n\t\t   intel_gt_pm_interval_to_ns(gt, rpcurdownei));\n\tdrm_printf(p, \"RP CUR DOWN: %d (%lldns)\\n\",\n\t\t   rpcurdown,\n\t\t   intel_gt_pm_interval_to_ns(gt, rpcurdown));\n\tdrm_printf(p, \"RP PREV DOWN: %d (%lldns)\\n\",\n\t\t   rpprevdown,\n\t\t   intel_gt_pm_interval_to_ns(gt, rpprevdown));\n\tdrm_printf(p, \"Down threshold: %d%%\\n\",\n\t\t   rps->power.down_threshold);\n\tdrm_printf(p, \"RP DOWN EI: %d (%lldns)\\n\",\n\t\t   rpdownei, intel_gt_pm_interval_to_ns(gt, rpdownei));\n\tdrm_printf(p, \"RP DOWN THRESHOLD: %d (%lldns)\\n\",\n\t\t   rpdownt, intel_gt_pm_interval_to_ns(gt, rpdownt));\n\n\tdrm_printf(p, \"Lowest (RPN) frequency: %dMHz\\n\",\n\t\t   intel_gpu_freq(rps, caps.min_freq));\n\tdrm_printf(p, \"Nominal (RP1) frequency: %dMHz\\n\",\n\t\t   intel_gpu_freq(rps, caps.rp1_freq));\n\tdrm_printf(p, \"Max non-overclocked (RP0) frequency: %dMHz\\n\",\n\t\t   intel_gpu_freq(rps, caps.rp0_freq));\n\tdrm_printf(p, \"Max overclocked frequency: %dMHz\\n\",\n\t\t   intel_gpu_freq(rps, rps->max_freq));\n\n\tdrm_printf(p, \"Current freq: %d MHz\\n\",\n\t\t   intel_gpu_freq(rps, rps->cur_freq));\n\tdrm_printf(p, \"Actual freq: %d MHz\\n\", cagf);\n\tdrm_printf(p, \"Idle freq: %d MHz\\n\",\n\t\t   intel_gpu_freq(rps, rps->idle_freq));\n\tdrm_printf(p, \"Min freq: %d MHz\\n\",\n\t\t   intel_gpu_freq(rps, rps->min_freq));\n\tdrm_printf(p, \"Boost freq: %d MHz\\n\",\n\t\t   intel_gpu_freq(rps, rps->boost_freq));\n\tdrm_printf(p, \"Max freq: %d MHz\\n\",\n\t\t   intel_gpu_freq(rps, rps->max_freq));\n\tdrm_printf(p,\n\t\t   \"efficient (RPe) frequency: %d MHz\\n\",\n\t\t   intel_gpu_freq(rps, rps->efficient_freq));\n}\n\nstatic void slpc_frequency_dump(struct intel_rps *rps, struct drm_printer *p)\n{\n\tstruct intel_gt *gt = rps_to_gt(rps);\n\tstruct intel_uncore *uncore = gt->uncore;\n\tstruct intel_rps_freq_caps caps;\n\tu32 pm_mask;\n\n\tgen6_rps_get_freq_caps(rps, &caps);\n\tpm_mask = intel_uncore_read(uncore, GEN6_PMINTRMSK);\n\n\tdrm_printf(p, \"PM MASK=0x%08x\\n\", pm_mask);\n\tdrm_printf(p, \"pm_intrmsk_mbz: 0x%08x\\n\",\n\t\t   rps->pm_intrmsk_mbz);\n\tdrm_printf(p, \"RPSTAT1: 0x%08x\\n\", intel_rps_read_rpstat(rps));\n\tdrm_printf(p, \"RPNSWREQ: %dMHz\\n\", intel_rps_get_requested_frequency(rps));\n\tdrm_printf(p, \"Lowest (RPN) frequency: %dMHz\\n\",\n\t\t   intel_gpu_freq(rps, caps.min_freq));\n\tdrm_printf(p, \"Nominal (RP1) frequency: %dMHz\\n\",\n\t\t   intel_gpu_freq(rps, caps.rp1_freq));\n\tdrm_printf(p, \"Max non-overclocked (RP0) frequency: %dMHz\\n\",\n\t\t   intel_gpu_freq(rps, caps.rp0_freq));\n\tdrm_printf(p, \"Current freq: %d MHz\\n\",\n\t\t   intel_rps_get_requested_frequency(rps));\n\tdrm_printf(p, \"Actual freq: %d MHz\\n\",\n\t\t   intel_rps_read_actual_frequency(rps));\n\tdrm_printf(p, \"Min freq: %d MHz\\n\",\n\t\t   intel_rps_get_min_frequency(rps));\n\tdrm_printf(p, \"Boost freq: %d MHz\\n\",\n\t\t   intel_rps_get_boost_frequency(rps));\n\tdrm_printf(p, \"Max freq: %d MHz\\n\",\n\t\t   intel_rps_get_max_frequency(rps));\n\tdrm_printf(p,\n\t\t   \"efficient (RPe) frequency: %d MHz\\n\",\n\t\t   intel_gpu_freq(rps, caps.rp1_freq));\n}\n\nvoid gen6_rps_frequency_dump(struct intel_rps *rps, struct drm_printer *p)\n{\n\tif (rps_uses_slpc(rps))\n\t\treturn slpc_frequency_dump(rps, p);\n\telse\n\t\treturn rps_frequency_dump(rps, p);\n}\n\nstatic int set_max_freq(struct intel_rps *rps, u32 val)\n{\n\tstruct drm_i915_private *i915 = rps_to_i915(rps);\n\tint ret = 0;\n\n\tmutex_lock(&rps->lock);\n\n\tval = intel_freq_opcode(rps, val);\n\tif (val < rps->min_freq ||\n\t    val > rps->max_freq ||\n\t    val < rps->min_freq_softlimit) {\n\t\tret = -EINVAL;\n\t\tgoto unlock;\n\t}\n\n\tif (val > rps->rp0_freq)\n\t\tdrm_dbg(&i915->drm, \"User requested overclocking to %d\\n\",\n\t\t\tintel_gpu_freq(rps, val));\n\n\trps->max_freq_softlimit = val;\n\n\tval = clamp_t(int, rps->cur_freq,\n\t\t      rps->min_freq_softlimit,\n\t\t      rps->max_freq_softlimit);\n\n\t \n\tintel_rps_set(rps, val);\n\nunlock:\n\tmutex_unlock(&rps->lock);\n\n\treturn ret;\n}\n\nint intel_rps_set_max_frequency(struct intel_rps *rps, u32 val)\n{\n\tstruct intel_guc_slpc *slpc = rps_to_slpc(rps);\n\n\tif (rps_uses_slpc(rps))\n\t\treturn intel_guc_slpc_set_max_freq(slpc, val);\n\telse\n\t\treturn set_max_freq(rps, val);\n}\n\nu32 intel_rps_get_min_frequency(struct intel_rps *rps)\n{\n\tstruct intel_guc_slpc *slpc = rps_to_slpc(rps);\n\n\tif (rps_uses_slpc(rps))\n\t\treturn slpc->min_freq_softlimit;\n\telse\n\t\treturn intel_gpu_freq(rps, rps->min_freq_softlimit);\n}\n\n \nu32 intel_rps_get_min_raw_freq(struct intel_rps *rps)\n{\n\tstruct intel_guc_slpc *slpc = rps_to_slpc(rps);\n\tu32 freq;\n\n\tif (rps_uses_slpc(rps)) {\n\t\treturn DIV_ROUND_CLOSEST(slpc->min_freq,\n\t\t\t\t\t GT_FREQUENCY_MULTIPLIER);\n\t} else {\n\t\tfreq = rps->min_freq;\n\t\tif (GRAPHICS_VER(rps_to_i915(rps)) >= 9) {\n\t\t\t \n\t\t\tfreq /= GEN9_FREQ_SCALER;\n\t\t}\n\t\treturn freq;\n\t}\n}\n\nstatic int set_min_freq(struct intel_rps *rps, u32 val)\n{\n\tint ret = 0;\n\n\tmutex_lock(&rps->lock);\n\n\tval = intel_freq_opcode(rps, val);\n\tif (val < rps->min_freq ||\n\t    val > rps->max_freq ||\n\t    val > rps->max_freq_softlimit) {\n\t\tret = -EINVAL;\n\t\tgoto unlock;\n\t}\n\n\trps->min_freq_softlimit = val;\n\n\tval = clamp_t(int, rps->cur_freq,\n\t\t      rps->min_freq_softlimit,\n\t\t      rps->max_freq_softlimit);\n\n\t \n\tintel_rps_set(rps, val);\n\nunlock:\n\tmutex_unlock(&rps->lock);\n\n\treturn ret;\n}\n\nint intel_rps_set_min_frequency(struct intel_rps *rps, u32 val)\n{\n\tstruct intel_guc_slpc *slpc = rps_to_slpc(rps);\n\n\tif (rps_uses_slpc(rps))\n\t\treturn intel_guc_slpc_set_min_freq(slpc, val);\n\telse\n\t\treturn set_min_freq(rps, val);\n}\n\nu8 intel_rps_get_up_threshold(struct intel_rps *rps)\n{\n\treturn rps->power.up_threshold;\n}\n\nstatic int rps_set_threshold(struct intel_rps *rps, u8 *threshold, u8 val)\n{\n\tint ret;\n\n\tif (val > 100)\n\t\treturn -EINVAL;\n\n\tret = mutex_lock_interruptible(&rps->lock);\n\tif (ret)\n\t\treturn ret;\n\n\tif (*threshold == val)\n\t\tgoto out_unlock;\n\n\t*threshold = val;\n\n\t \n\trps->last_freq = -1;\n\tmutex_lock(&rps->power.mutex);\n\trps->power.mode = -1;\n\tmutex_unlock(&rps->power.mutex);\n\n\tintel_rps_set(rps, clamp(rps->cur_freq,\n\t\t\t\t rps->min_freq_softlimit,\n\t\t\t\t rps->max_freq_softlimit));\n\nout_unlock:\n\tmutex_unlock(&rps->lock);\n\n\treturn ret;\n}\n\nint intel_rps_set_up_threshold(struct intel_rps *rps, u8 threshold)\n{\n\treturn rps_set_threshold(rps, &rps->power.up_threshold, threshold);\n}\n\nu8 intel_rps_get_down_threshold(struct intel_rps *rps)\n{\n\treturn rps->power.down_threshold;\n}\n\nint intel_rps_set_down_threshold(struct intel_rps *rps, u8 threshold)\n{\n\treturn rps_set_threshold(rps, &rps->power.down_threshold, threshold);\n}\n\nstatic void intel_rps_set_manual(struct intel_rps *rps, bool enable)\n{\n\tstruct intel_uncore *uncore = rps_to_uncore(rps);\n\tu32 state = enable ? GEN9_RPSWCTL_ENABLE : GEN9_RPSWCTL_DISABLE;\n\n\t \n\tintel_uncore_write(uncore, GEN6_RP_CONTROL, state);\n}\n\nvoid intel_rps_raise_unslice(struct intel_rps *rps)\n{\n\tstruct intel_uncore *uncore = rps_to_uncore(rps);\n\n\tmutex_lock(&rps->lock);\n\n\tif (rps_uses_slpc(rps)) {\n\t\t \n\t\tstruct intel_rps_freq_caps caps;\n\n\t\tgen6_rps_get_freq_caps(rps, &caps);\n\n\t\tintel_rps_set_manual(rps, true);\n\t\tintel_uncore_write(uncore, GEN6_RPNSWREQ,\n\t\t\t\t   ((caps.rp0_freq <<\n\t\t\t\t   GEN9_SW_REQ_UNSLICE_RATIO_SHIFT) |\n\t\t\t\t   GEN9_IGNORE_SLICE_RATIO));\n\t\tintel_rps_set_manual(rps, false);\n\t} else {\n\t\tintel_rps_set(rps, rps->rp0_freq);\n\t}\n\n\tmutex_unlock(&rps->lock);\n}\n\nvoid intel_rps_lower_unslice(struct intel_rps *rps)\n{\n\tstruct intel_uncore *uncore = rps_to_uncore(rps);\n\n\tmutex_lock(&rps->lock);\n\n\tif (rps_uses_slpc(rps)) {\n\t\t \n\t\tstruct intel_rps_freq_caps caps;\n\n\t\tgen6_rps_get_freq_caps(rps, &caps);\n\n\t\tintel_rps_set_manual(rps, true);\n\t\tintel_uncore_write(uncore, GEN6_RPNSWREQ,\n\t\t\t\t   ((caps.min_freq <<\n\t\t\t\t   GEN9_SW_REQ_UNSLICE_RATIO_SHIFT) |\n\t\t\t\t   GEN9_IGNORE_SLICE_RATIO));\n\t\tintel_rps_set_manual(rps, false);\n\t} else {\n\t\tintel_rps_set(rps, rps->min_freq);\n\t}\n\n\tmutex_unlock(&rps->lock);\n}\n\nstatic u32 rps_read_mmio(struct intel_rps *rps, i915_reg_t reg32)\n{\n\tstruct intel_gt *gt = rps_to_gt(rps);\n\tintel_wakeref_t wakeref;\n\tu32 val;\n\n\twith_intel_runtime_pm(gt->uncore->rpm, wakeref)\n\t\tval = intel_uncore_read(gt->uncore, reg32);\n\n\treturn val;\n}\n\nbool rps_read_mask_mmio(struct intel_rps *rps,\n\t\t\ti915_reg_t reg32, u32 mask)\n{\n\treturn rps_read_mmio(rps, reg32) & mask;\n}\n\n \n\nstatic struct drm_i915_private __rcu *ips_mchdev;\n\n \nstatic void\nips_ping_for_i915_load(void)\n{\n\tvoid (*link)(void);\n\n\tlink = symbol_get(ips_link_to_i915_driver);\n\tif (link) {\n\t\tlink();\n\t\tsymbol_put(ips_link_to_i915_driver);\n\t}\n}\n\nvoid intel_rps_driver_register(struct intel_rps *rps)\n{\n\tstruct intel_gt *gt = rps_to_gt(rps);\n\n\t \n\tif (GRAPHICS_VER(gt->i915) == 5) {\n\t\tGEM_BUG_ON(ips_mchdev);\n\t\trcu_assign_pointer(ips_mchdev, gt->i915);\n\t\tips_ping_for_i915_load();\n\t}\n}\n\nvoid intel_rps_driver_unregister(struct intel_rps *rps)\n{\n\tif (rcu_access_pointer(ips_mchdev) == rps_to_i915(rps))\n\t\trcu_assign_pointer(ips_mchdev, NULL);\n}\n\nstatic struct drm_i915_private *mchdev_get(void)\n{\n\tstruct drm_i915_private *i915;\n\n\trcu_read_lock();\n\ti915 = rcu_dereference(ips_mchdev);\n\tif (i915 && !kref_get_unless_zero(&i915->drm.ref))\n\t\ti915 = NULL;\n\trcu_read_unlock();\n\n\treturn i915;\n}\n\n \nunsigned long i915_read_mch_val(void)\n{\n\tstruct drm_i915_private *i915;\n\tunsigned long chipset_val = 0;\n\tunsigned long graphics_val = 0;\n\tintel_wakeref_t wakeref;\n\n\ti915 = mchdev_get();\n\tif (!i915)\n\t\treturn 0;\n\n\twith_intel_runtime_pm(&i915->runtime_pm, wakeref) {\n\t\tstruct intel_ips *ips = &to_gt(i915)->rps.ips;\n\n\t\tspin_lock_irq(&mchdev_lock);\n\t\tchipset_val = __ips_chipset_val(ips);\n\t\tgraphics_val = __ips_gfx_val(ips);\n\t\tspin_unlock_irq(&mchdev_lock);\n\t}\n\n\tdrm_dev_put(&i915->drm);\n\treturn chipset_val + graphics_val;\n}\nEXPORT_SYMBOL_GPL(i915_read_mch_val);\n\n \nbool i915_gpu_raise(void)\n{\n\tstruct drm_i915_private *i915;\n\tstruct intel_rps *rps;\n\n\ti915 = mchdev_get();\n\tif (!i915)\n\t\treturn false;\n\n\trps = &to_gt(i915)->rps;\n\n\tspin_lock_irq(&mchdev_lock);\n\tif (rps->max_freq_softlimit < rps->max_freq)\n\t\trps->max_freq_softlimit++;\n\tspin_unlock_irq(&mchdev_lock);\n\n\tdrm_dev_put(&i915->drm);\n\treturn true;\n}\nEXPORT_SYMBOL_GPL(i915_gpu_raise);\n\n \nbool i915_gpu_lower(void)\n{\n\tstruct drm_i915_private *i915;\n\tstruct intel_rps *rps;\n\n\ti915 = mchdev_get();\n\tif (!i915)\n\t\treturn false;\n\n\trps = &to_gt(i915)->rps;\n\n\tspin_lock_irq(&mchdev_lock);\n\tif (rps->max_freq_softlimit > rps->min_freq)\n\t\trps->max_freq_softlimit--;\n\tspin_unlock_irq(&mchdev_lock);\n\n\tdrm_dev_put(&i915->drm);\n\treturn true;\n}\nEXPORT_SYMBOL_GPL(i915_gpu_lower);\n\n \nbool i915_gpu_busy(void)\n{\n\tstruct drm_i915_private *i915;\n\tbool ret;\n\n\ti915 = mchdev_get();\n\tif (!i915)\n\t\treturn false;\n\n\tret = to_gt(i915)->awake;\n\n\tdrm_dev_put(&i915->drm);\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(i915_gpu_busy);\n\n \nbool i915_gpu_turbo_disable(void)\n{\n\tstruct drm_i915_private *i915;\n\tstruct intel_rps *rps;\n\tbool ret;\n\n\ti915 = mchdev_get();\n\tif (!i915)\n\t\treturn false;\n\n\trps = &to_gt(i915)->rps;\n\n\tspin_lock_irq(&mchdev_lock);\n\trps->max_freq_softlimit = rps->min_freq;\n\tret = !__gen5_rps_set(&to_gt(i915)->rps, rps->min_freq);\n\tspin_unlock_irq(&mchdev_lock);\n\n\tdrm_dev_put(&i915->drm);\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(i915_gpu_turbo_disable);\n\n#if IS_ENABLED(CONFIG_DRM_I915_SELFTEST)\n#include \"selftest_rps.c\"\n#include \"selftest_slpc.c\"\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}