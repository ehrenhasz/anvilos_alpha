{
  "module_name": "intel_renderstate.c",
  "hash_id": "8e42de4cd47b9d55c9487b843c8e3d277c6b5bc3117a42b709c79b24a03639a0",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/i915/gt/intel_renderstate.c",
  "human_readable_source": "\n \n\n#include \"gem/i915_gem_internal.h\"\n\n#include \"i915_drv.h\"\n#include \"intel_renderstate.h\"\n#include \"intel_context.h\"\n#include \"intel_gpu_commands.h\"\n#include \"intel_ring.h\"\n\nstatic const struct intel_renderstate_rodata *\nrender_state_get_rodata(const struct intel_engine_cs *engine)\n{\n\tif (engine->class != RENDER_CLASS)\n\t\treturn NULL;\n\n\tswitch (GRAPHICS_VER(engine->i915)) {\n\tcase 6:\n\t\treturn &gen6_null_state;\n\tcase 7:\n\t\treturn &gen7_null_state;\n\tcase 8:\n\t\treturn &gen8_null_state;\n\tcase 9:\n\t\treturn &gen9_null_state;\n\t}\n\n\treturn NULL;\n}\n\n \n#define OUT_BATCH(batch, i, val)\t\t\t\t\\\n\tdo {\t\t\t\t\t\t\t\\\n\t\tif ((i) >= PAGE_SIZE / sizeof(u32))\t\t\\\n\t\t\tgoto out;\t\t\t\t\\\n\t\t(batch)[(i)++] = (val);\t\t\t\t\\\n\t} while (0)\n\nstatic int render_state_setup(struct intel_renderstate *so,\n\t\t\t      struct drm_i915_private *i915)\n{\n\tconst struct intel_renderstate_rodata *rodata = so->rodata;\n\tunsigned int i = 0, reloc_index = 0;\n\tint ret = -EINVAL;\n\tu32 *d;\n\n\td = i915_gem_object_pin_map(so->vma->obj, I915_MAP_WB);\n\tif (IS_ERR(d))\n\t\treturn PTR_ERR(d);\n\n\twhile (i < rodata->batch_items) {\n\t\tu32 s = rodata->batch[i];\n\n\t\tif (i * 4  == rodata->reloc[reloc_index]) {\n\t\t\tu64 r = s + i915_vma_offset(so->vma);\n\n\t\t\ts = lower_32_bits(r);\n\t\t\tif (HAS_64BIT_RELOC(i915)) {\n\t\t\t\tif (i + 1 >= rodata->batch_items ||\n\t\t\t\t    rodata->batch[i + 1] != 0)\n\t\t\t\t\tgoto out;\n\n\t\t\t\td[i++] = s;\n\t\t\t\ts = upper_32_bits(r);\n\t\t\t}\n\n\t\t\treloc_index++;\n\t\t}\n\n\t\td[i++] = s;\n\t}\n\n\tif (rodata->reloc[reloc_index] != -1) {\n\t\tdrm_err(&i915->drm, \"only %d relocs resolved\\n\", reloc_index);\n\t\tgoto out;\n\t}\n\n\tso->batch_offset = i915_ggtt_offset(so->vma);\n\tso->batch_size = rodata->batch_items * sizeof(u32);\n\n\twhile (i % CACHELINE_DWORDS)\n\t\tOUT_BATCH(d, i, MI_NOOP);\n\n\tso->aux_offset = i * sizeof(u32);\n\n\tif (HAS_POOLED_EU(i915)) {\n\t\t \n\t\tu32 eu_pool_config = 0x00777000;\n\n\t\tOUT_BATCH(d, i, GEN9_MEDIA_POOL_STATE);\n\t\tOUT_BATCH(d, i, GEN9_MEDIA_POOL_ENABLE);\n\t\tOUT_BATCH(d, i, eu_pool_config);\n\t\tOUT_BATCH(d, i, 0);\n\t\tOUT_BATCH(d, i, 0);\n\t\tOUT_BATCH(d, i, 0);\n\t}\n\n\tOUT_BATCH(d, i, MI_BATCH_BUFFER_END);\n\tso->aux_size = i * sizeof(u32) - so->aux_offset;\n\tso->aux_offset += so->batch_offset;\n\t \n\tso->aux_size = ALIGN(so->aux_size, 8);\n\n\tret = 0;\nout:\n\t__i915_gem_object_flush_map(so->vma->obj, 0, i * sizeof(u32));\n\t__i915_gem_object_release_map(so->vma->obj);\n\treturn ret;\n}\n\n#undef OUT_BATCH\n\nint intel_renderstate_init(struct intel_renderstate *so,\n\t\t\t   struct intel_context *ce)\n{\n\tstruct intel_engine_cs *engine = ce->engine;\n\tstruct drm_i915_gem_object *obj = NULL;\n\tint err;\n\n\tmemset(so, 0, sizeof(*so));\n\n\tso->rodata = render_state_get_rodata(engine);\n\tif (so->rodata) {\n\t\tif (so->rodata->batch_items * 4 > PAGE_SIZE)\n\t\t\treturn -EINVAL;\n\n\t\tobj = i915_gem_object_create_internal(engine->i915, PAGE_SIZE);\n\t\tif (IS_ERR(obj))\n\t\t\treturn PTR_ERR(obj);\n\n\t\tso->vma = i915_vma_instance(obj, &engine->gt->ggtt->vm, NULL);\n\t\tif (IS_ERR(so->vma)) {\n\t\t\terr = PTR_ERR(so->vma);\n\t\t\tgoto err_obj;\n\t\t}\n\t}\n\n\ti915_gem_ww_ctx_init(&so->ww, true);\nretry:\n\terr = intel_context_pin_ww(ce, &so->ww);\n\tif (err)\n\t\tgoto err_fini;\n\n\t \n\tif (!err && !so->rodata)\n\t\treturn 0;\n\n\terr = i915_gem_object_lock(so->vma->obj, &so->ww);\n\tif (err)\n\t\tgoto err_context;\n\n\terr = i915_vma_pin_ww(so->vma, &so->ww, 0, 0, PIN_GLOBAL | PIN_HIGH);\n\tif (err)\n\t\tgoto err_context;\n\n\terr = render_state_setup(so, engine->i915);\n\tif (err)\n\t\tgoto err_unpin;\n\n\treturn 0;\n\nerr_unpin:\n\ti915_vma_unpin(so->vma);\nerr_context:\n\tintel_context_unpin(ce);\nerr_fini:\n\tif (err == -EDEADLK) {\n\t\terr = i915_gem_ww_ctx_backoff(&so->ww);\n\t\tif (!err)\n\t\t\tgoto retry;\n\t}\n\ti915_gem_ww_ctx_fini(&so->ww);\nerr_obj:\n\tif (obj)\n\t\ti915_gem_object_put(obj);\n\tso->vma = NULL;\n\treturn err;\n}\n\nint intel_renderstate_emit(struct intel_renderstate *so,\n\t\t\t   struct i915_request *rq)\n{\n\tstruct intel_engine_cs *engine = rq->engine;\n\tint err;\n\n\tif (!so->vma)\n\t\treturn 0;\n\n\terr = i915_vma_move_to_active(so->vma, rq, 0);\n\tif (err)\n\t\treturn err;\n\n\terr = engine->emit_bb_start(rq,\n\t\t\t\t    so->batch_offset, so->batch_size,\n\t\t\t\t    I915_DISPATCH_SECURE);\n\tif (err)\n\t\treturn err;\n\n\tif (so->aux_size > 8) {\n\t\terr = engine->emit_bb_start(rq,\n\t\t\t\t\t    so->aux_offset, so->aux_size,\n\t\t\t\t\t    I915_DISPATCH_SECURE);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\nvoid intel_renderstate_fini(struct intel_renderstate *so,\n\t\t\t    struct intel_context *ce)\n{\n\tif (so->vma) {\n\t\ti915_vma_unpin(so->vma);\n\t\ti915_vma_close(so->vma);\n\t}\n\n\tintel_context_unpin(ce);\n\ti915_gem_ww_ctx_fini(&so->ww);\n\n\tif (so->vma)\n\t\ti915_gem_object_put(so->vma->obj);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}