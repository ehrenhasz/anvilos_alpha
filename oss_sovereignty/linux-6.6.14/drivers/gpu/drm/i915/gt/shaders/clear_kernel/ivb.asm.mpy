{
  "module_name": "ivb.asm",
  "hash_id": "fd15ce7e0060c4b309291b327f7320e740f6b796f7f6dac7d0a72bb48451e3fe",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/i915/gt/shaders/clear_kernel/ivb.asm",
  "human_readable_source": "// SPDX-License-Identifier: MIT\n/*\n * Copyright \u00a9 2020 Intel Corporation\n */\n\n/*\n * Kernel for PAVP buffer clear.\n *\n *\t1. Clear all 64 GRF registers assigned to the kernel with designated value;\n *\t2. Write 32x16 block of all \"0\" to render target buffer which indirectly clears\n *\t   512 bytes of Render Cache.\n */\n\n/* Store designated \"clear GRF\" value */\nmov(1)          f0.1<1>UW       g1.2<0,1,0>UW                   { align1 1N };\n\n/**\n * Curbe Format\n *\n * DW 1.0 - Block Offset to write Render Cache\n * DW 1.1 [15:0] - Clear Word\n * DW 1.2 - Delay iterations\n * DW 1.3 - Enable Instrumentation (only for debug)\n * DW 1.4 - Rsvd (intended for context ID)\n * DW 1.5 - [31:16]:SliceCount, [15:0]:SubSlicePerSliceCount\n * DW 1.6 - Rsvd MBZ (intended for Enable Wait on Total Thread Count)\n * DW 1.7 - Rsvd MBZ (inteded for Total Thread Count)\n *\n * Binding Table\n *\n * BTI 0: 2D Surface to help clear L3 (Render/Data Cache)\n * BTI 1: Wait/Instrumentation Buffer\n *  Size : (SliceCount * SubSliceCount  * 16 EUs/SubSlice) rows * (16 threads/EU) cols (Format R32_UINT)\n *         Expected to be initialized to 0 by driver/another kernel\n *  Layout :\n *           RowN: Histogram for EU-N: (SliceID*SubSlicePerSliceCount + SSID)*16 + EUID [assume max 16 EUs / SS]\n *           Col-k[DW-k]: Threads Executed on ThreadID-k for EU-N\n */\nadd(1)          g1.2<1>UD       g1.2<0,1,0>UD   0x00000001UD    { align1 1N }; /* Loop count to delay kernel: Init to (g1.2 + 1) */\ncmp.z.f0.0(1)   null<1>UD       g1.3<0,1,0>UD   0x00000000UD    { align1 1N };\n(+f0.0) jmpi(1) 44D                                             { align1 WE_all 1N };\n\n/**\n * State Register has info on where this thread is running\n *\tIVB: sr0.0 :: [15:13]: MBZ, 12: HSID (Half-Slice ID), [11:8]EUID, [2:0] ThreadSlotID\n *\tHSW: sr0.0 :: 15: MBZ, [14:13]: SliceID, 12: HSID (Half-Slice ID), [11:8]EUID, [2:0] ThreadSlotID\n */\nmov(8)          g3<1>UD         0x00000000UD                    { align1 1Q };\nshr(1)          g3<1>D          sr0<0,1,0>D     12D             { align1 1N };\nand(1)          g3<1>D          g3<0,1,0>D      1D              { align1 1N }; /* g3 has HSID */\nshr(1)          g3.1<1>D        sr0<0,1,0>D     13D             { align1 1N };\nand(1)          g3.1<1>D        g3.1<0,1,0>D    3D              { align1 1N }; /* g3.1 has sliceID */\nmul(1)          g3.5<1>D        g3.1<0,1,0>D    g1.10<0,1,0>UW  { align1 1N };\nadd(1)          g3<1>D          g3<0,1,0>D      g3.5<0,1,0>D    { align1 1N }; /* g3 = sliceID * SubSlicePerSliceCount + HSID */\nshr(1)          g3.2<1>D        sr0<0,1,0>D     8D              { align1 1N };\nand(1)          g3.2<1>D        g3.2<0,1,0>D    15D             { align1 1N }; /* g3.2 = EUID */\nmul(1)          g3.4<1>D        g3<0,1,0>D      16D             { align1 1N };\nadd(1)          g3.2<1>D        g3.2<0,1,0>D    g3.4<0,1,0>D    { align1 1N }; /* g3.2 now points to EU row number (Y-pixel = V address )  in instrumentation surf */\n\nmov(8)          g5<1>UD         0x00000000UD                    { align1 1Q };\nand(1)          g3.3<1>D        sr0<0,1,0>D     7D              { align1 1N };\nmul(1)          g3.3<1>D        g3.3<0,1,0>D    4D              { align1 1N };\n\nmov(8)          g4<1>UD         g0<8,8,1>UD                     { align1 1Q }; /* Initialize message header with g0 */\nmov(1)          g4<1>UD         g3.3<0,1,0>UD                   { align1 1N }; /* Block offset */\nmov(1)          g4.1<1>UD       g3.2<0,1,0>UD                   { align1 1N }; /* Block offset */\nmov(1)          g4.2<1>UD       0x00000003UD                    { align1 1N }; /* Block size (1 row x 4 bytes) */\nand(1)          g4.3<1>UD       g4.3<0,1,0>UW   0xffffffffUD    { align1 1N };\n\n/* Media block read to fetch current value at specified location in instrumentation buffer */\nsendc(8)        g5<1>UD         g4<8,8,1>F      0x02190001\n                            render MsgDesc: media block read MsgCtrl = 0x0 Surface = 1 mlen 1 rlen 1 { align1 1Q };\nadd(1)          g5<1>D          g5<0,1,0>D      1D              { align1 1N };\n\n/* Media block write for updated value at specified location in instrumentation buffer */\nsendc(8)        g5<1>UD         g4<8,8,1>F      0x040a8001\n                            render MsgDesc: media block write MsgCtrl = 0x0 Surface = 1 mlen 2 rlen 0 { align1 1Q };\n/* Delay thread for specified parameter */\nadd.nz.f0.0(1)  g1.2<1>UD       g1.2<0,1,0>UD   -1D             { align1 1N };\n(+f0.0) jmpi(1) -4D                                             { align1 WE_all 1N };\n\n/* Store designated \"clear GRF\" value */\nmov(1)          f0.1<1>UW       g1.2<0,1,0>UW                   { align1 1N };\n\n/* Initialize looping parameters */\nmov(1)          a0<1>D          0D                              { align1 1N }; /* Initialize a0.0:w=0 */\nmov(1)          a0.4<1>W        127W                            { align1 1N }; /* Loop count. Each loop contains 16 GRF's */\n\n/* Write 32x16 all \"0\" block */\nmov(8)          g2<1>UD         g0<8,8,1>UD                     { align1 1Q };\nmov(8)          g127<1>UD       g0<8,8,1>UD                     { align1 1Q };\nmov(2)          g2<1>UD         g1<2,2,1>UW                     { align1 1N };\nmov(1)          g2.2<1>UD       0x000f000fUD                    { align1 1N }; /* Block size (16x16) */\nand(1)          g2.3<1>UD       g2.3<0,1,0>UW   0xffffffefUD    { align1 1N };\nmov(16)         g3<1>UD         0x00000000UD                    { align1 1H };\nmov(16)         g4<1>UD         0x00000000UD                    { align1 1H };\nmov(16)         g5<1>UD         0x00000000UD                    { align1 1H };\nmov(16)         g6<1>UD         0x00000000UD                    { align1 1H };\nmov(16)         g7<1>UD         0x00000000UD                    { align1 1H };\nmov(16)         g8<1>UD         0x00000000UD                    { align1 1H };\nmov(16)         g9<1>UD         0x00000000UD                    { align1 1H };\nmov(16)         g10<1>UD        0x00000000UD                    { align1 1H };\nsendc(8)        null<1>UD       g2<8,8,1>F      0x120a8000\n                            render MsgDesc: media block write MsgCtrl = 0x0 Surface = 0 mlen 9 rlen 0 { align1 1Q };\nadd(1)          g2<1>UD         g1<0,1,0>UW     0x0010UW        { align1 1N };\nsendc(8)        null<1>UD       g2<8,8,1>F      0x120a8000\n                            render MsgDesc: media block write MsgCtrl = 0x0 Surface = 0 mlen 9 rlen 0 { align1 1Q };\n\n/* Now, clear all GRF registers */\nadd.nz.f0.0(1)  a0.4<1>W        a0.4<0,1,0>W    -1W             { align1 1N };\nmov(16)         g[a0]<1>UW      f0.1<0,1,0>UW                   { align1 1H };\nadd(1)          a0<1>D          a0<0,1,0>D      32D             { align1 1N };\n(+f0.0) jmpi(1) -8D                                             { align1 WE_all 1N };\n\n/* Terminante the thread */\nsendc(8)        null<1>UD       g127<8,8,1>F    0x82000010\n                            thread_spawner MsgDesc: mlen 1 rlen 0           { align1 1Q EOT };\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}