{
  "module_name": "intel_lrc.c",
  "hash_id": "bbf0d0f1886b93e16a51dab715c59d0ed03b2265a36c4841875bdeac0731f884",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/i915/gt/intel_lrc.c",
  "human_readable_source": "\n \n\n#include \"gem/i915_gem_lmem.h\"\n\n#include \"gen8_engine_cs.h\"\n#include \"i915_drv.h\"\n#include \"i915_perf.h\"\n#include \"i915_reg.h\"\n#include \"intel_context.h\"\n#include \"intel_engine.h\"\n#include \"intel_engine_regs.h\"\n#include \"intel_gpu_commands.h\"\n#include \"intel_gt.h\"\n#include \"intel_gt_regs.h\"\n#include \"intel_lrc.h\"\n#include \"intel_lrc_reg.h\"\n#include \"intel_ring.h\"\n#include \"shmem_utils.h\"\n\n \nstatic void set_offsets(u32 *regs,\n\t\t\tconst u8 *data,\n\t\t\tconst struct intel_engine_cs *engine,\n\t\t\tbool close)\n#define NOP(x) (BIT(7) | (x))\n#define LRI(count, flags) ((flags) << 6 | (count) | BUILD_BUG_ON_ZERO(count >= BIT(6)))\n#define POSTED BIT(0)\n#define REG(x) (((x) >> 2) | BUILD_BUG_ON_ZERO(x >= 0x200))\n#define REG16(x) \\\n\t(((x) >> 9) | BIT(7) | BUILD_BUG_ON_ZERO(x >= 0x10000)), \\\n\t(((x) >> 2) & 0x7f)\n#define END 0\n{\n\tconst u32 base = engine->mmio_base;\n\n\twhile (*data) {\n\t\tu8 count, flags;\n\n\t\tif (*data & BIT(7)) {  \n\t\t\tcount = *data++ & ~BIT(7);\n\t\t\tregs += count;\n\t\t\tcontinue;\n\t\t}\n\n\t\tcount = *data & 0x3f;\n\t\tflags = *data >> 6;\n\t\tdata++;\n\n\t\t*regs = MI_LOAD_REGISTER_IMM(count);\n\t\tif (flags & POSTED)\n\t\t\t*regs |= MI_LRI_FORCE_POSTED;\n\t\tif (GRAPHICS_VER(engine->i915) >= 11)\n\t\t\t*regs |= MI_LRI_LRM_CS_MMIO;\n\t\tregs++;\n\n\t\tGEM_BUG_ON(!count);\n\t\tdo {\n\t\t\tu32 offset = 0;\n\t\t\tu8 v;\n\n\t\t\tdo {\n\t\t\t\tv = *data++;\n\t\t\t\toffset <<= 7;\n\t\t\t\toffset |= v & ~BIT(7);\n\t\t\t} while (v & BIT(7));\n\n\t\t\tregs[0] = base + (offset << 2);\n\t\t\tregs += 2;\n\t\t} while (--count);\n\t}\n\n\tif (close) {\n\t\t \n\t\t*regs = MI_BATCH_BUFFER_END;\n\t\tif (GRAPHICS_VER(engine->i915) >= 11)\n\t\t\t*regs |= BIT(0);\n\t}\n}\n\nstatic const u8 gen8_xcs_offsets[] = {\n\tNOP(1),\n\tLRI(11, 0),\n\tREG16(0x244),\n\tREG(0x034),\n\tREG(0x030),\n\tREG(0x038),\n\tREG(0x03c),\n\tREG(0x168),\n\tREG(0x140),\n\tREG(0x110),\n\tREG(0x11c),\n\tREG(0x114),\n\tREG(0x118),\n\n\tNOP(9),\n\tLRI(9, 0),\n\tREG16(0x3a8),\n\tREG16(0x28c),\n\tREG16(0x288),\n\tREG16(0x284),\n\tREG16(0x280),\n\tREG16(0x27c),\n\tREG16(0x278),\n\tREG16(0x274),\n\tREG16(0x270),\n\n\tNOP(13),\n\tLRI(2, 0),\n\tREG16(0x200),\n\tREG(0x028),\n\n\tEND\n};\n\nstatic const u8 gen9_xcs_offsets[] = {\n\tNOP(1),\n\tLRI(14, POSTED),\n\tREG16(0x244),\n\tREG(0x034),\n\tREG(0x030),\n\tREG(0x038),\n\tREG(0x03c),\n\tREG(0x168),\n\tREG(0x140),\n\tREG(0x110),\n\tREG(0x11c),\n\tREG(0x114),\n\tREG(0x118),\n\tREG(0x1c0),\n\tREG(0x1c4),\n\tREG(0x1c8),\n\n\tNOP(3),\n\tLRI(9, POSTED),\n\tREG16(0x3a8),\n\tREG16(0x28c),\n\tREG16(0x288),\n\tREG16(0x284),\n\tREG16(0x280),\n\tREG16(0x27c),\n\tREG16(0x278),\n\tREG16(0x274),\n\tREG16(0x270),\n\n\tNOP(13),\n\tLRI(1, POSTED),\n\tREG16(0x200),\n\n\tNOP(13),\n\tLRI(44, POSTED),\n\tREG(0x028),\n\tREG(0x09c),\n\tREG(0x0c0),\n\tREG(0x178),\n\tREG(0x17c),\n\tREG16(0x358),\n\tREG(0x170),\n\tREG(0x150),\n\tREG(0x154),\n\tREG(0x158),\n\tREG16(0x41c),\n\tREG16(0x600),\n\tREG16(0x604),\n\tREG16(0x608),\n\tREG16(0x60c),\n\tREG16(0x610),\n\tREG16(0x614),\n\tREG16(0x618),\n\tREG16(0x61c),\n\tREG16(0x620),\n\tREG16(0x624),\n\tREG16(0x628),\n\tREG16(0x62c),\n\tREG16(0x630),\n\tREG16(0x634),\n\tREG16(0x638),\n\tREG16(0x63c),\n\tREG16(0x640),\n\tREG16(0x644),\n\tREG16(0x648),\n\tREG16(0x64c),\n\tREG16(0x650),\n\tREG16(0x654),\n\tREG16(0x658),\n\tREG16(0x65c),\n\tREG16(0x660),\n\tREG16(0x664),\n\tREG16(0x668),\n\tREG16(0x66c),\n\tREG16(0x670),\n\tREG16(0x674),\n\tREG16(0x678),\n\tREG16(0x67c),\n\tREG(0x068),\n\n\tEND\n};\n\nstatic const u8 gen12_xcs_offsets[] = {\n\tNOP(1),\n\tLRI(13, POSTED),\n\tREG16(0x244),\n\tREG(0x034),\n\tREG(0x030),\n\tREG(0x038),\n\tREG(0x03c),\n\tREG(0x168),\n\tREG(0x140),\n\tREG(0x110),\n\tREG(0x1c0),\n\tREG(0x1c4),\n\tREG(0x1c8),\n\tREG(0x180),\n\tREG16(0x2b4),\n\n\tNOP(5),\n\tLRI(9, POSTED),\n\tREG16(0x3a8),\n\tREG16(0x28c),\n\tREG16(0x288),\n\tREG16(0x284),\n\tREG16(0x280),\n\tREG16(0x27c),\n\tREG16(0x278),\n\tREG16(0x274),\n\tREG16(0x270),\n\n\tEND\n};\n\nstatic const u8 dg2_xcs_offsets[] = {\n\tNOP(1),\n\tLRI(15, POSTED),\n\tREG16(0x244),\n\tREG(0x034),\n\tREG(0x030),\n\tREG(0x038),\n\tREG(0x03c),\n\tREG(0x168),\n\tREG(0x140),\n\tREG(0x110),\n\tREG(0x1c0),\n\tREG(0x1c4),\n\tREG(0x1c8),\n\tREG(0x180),\n\tREG16(0x2b4),\n\tREG(0x120),\n\tREG(0x124),\n\n\tNOP(1),\n\tLRI(9, POSTED),\n\tREG16(0x3a8),\n\tREG16(0x28c),\n\tREG16(0x288),\n\tREG16(0x284),\n\tREG16(0x280),\n\tREG16(0x27c),\n\tREG16(0x278),\n\tREG16(0x274),\n\tREG16(0x270),\n\n\tEND\n};\n\nstatic const u8 gen8_rcs_offsets[] = {\n\tNOP(1),\n\tLRI(14, POSTED),\n\tREG16(0x244),\n\tREG(0x034),\n\tREG(0x030),\n\tREG(0x038),\n\tREG(0x03c),\n\tREG(0x168),\n\tREG(0x140),\n\tREG(0x110),\n\tREG(0x11c),\n\tREG(0x114),\n\tREG(0x118),\n\tREG(0x1c0),\n\tREG(0x1c4),\n\tREG(0x1c8),\n\n\tNOP(3),\n\tLRI(9, POSTED),\n\tREG16(0x3a8),\n\tREG16(0x28c),\n\tREG16(0x288),\n\tREG16(0x284),\n\tREG16(0x280),\n\tREG16(0x27c),\n\tREG16(0x278),\n\tREG16(0x274),\n\tREG16(0x270),\n\n\tNOP(13),\n\tLRI(1, 0),\n\tREG(0x0c8),\n\n\tEND\n};\n\nstatic const u8 gen9_rcs_offsets[] = {\n\tNOP(1),\n\tLRI(14, POSTED),\n\tREG16(0x244),\n\tREG(0x34),\n\tREG(0x30),\n\tREG(0x38),\n\tREG(0x3c),\n\tREG(0x168),\n\tREG(0x140),\n\tREG(0x110),\n\tREG(0x11c),\n\tREG(0x114),\n\tREG(0x118),\n\tREG(0x1c0),\n\tREG(0x1c4),\n\tREG(0x1c8),\n\n\tNOP(3),\n\tLRI(9, POSTED),\n\tREG16(0x3a8),\n\tREG16(0x28c),\n\tREG16(0x288),\n\tREG16(0x284),\n\tREG16(0x280),\n\tREG16(0x27c),\n\tREG16(0x278),\n\tREG16(0x274),\n\tREG16(0x270),\n\n\tNOP(13),\n\tLRI(1, 0),\n\tREG(0xc8),\n\n\tNOP(13),\n\tLRI(44, POSTED),\n\tREG(0x28),\n\tREG(0x9c),\n\tREG(0xc0),\n\tREG(0x178),\n\tREG(0x17c),\n\tREG16(0x358),\n\tREG(0x170),\n\tREG(0x150),\n\tREG(0x154),\n\tREG(0x158),\n\tREG16(0x41c),\n\tREG16(0x600),\n\tREG16(0x604),\n\tREG16(0x608),\n\tREG16(0x60c),\n\tREG16(0x610),\n\tREG16(0x614),\n\tREG16(0x618),\n\tREG16(0x61c),\n\tREG16(0x620),\n\tREG16(0x624),\n\tREG16(0x628),\n\tREG16(0x62c),\n\tREG16(0x630),\n\tREG16(0x634),\n\tREG16(0x638),\n\tREG16(0x63c),\n\tREG16(0x640),\n\tREG16(0x644),\n\tREG16(0x648),\n\tREG16(0x64c),\n\tREG16(0x650),\n\tREG16(0x654),\n\tREG16(0x658),\n\tREG16(0x65c),\n\tREG16(0x660),\n\tREG16(0x664),\n\tREG16(0x668),\n\tREG16(0x66c),\n\tREG16(0x670),\n\tREG16(0x674),\n\tREG16(0x678),\n\tREG16(0x67c),\n\tREG(0x68),\n\n\tEND\n};\n\nstatic const u8 gen11_rcs_offsets[] = {\n\tNOP(1),\n\tLRI(15, POSTED),\n\tREG16(0x244),\n\tREG(0x034),\n\tREG(0x030),\n\tREG(0x038),\n\tREG(0x03c),\n\tREG(0x168),\n\tREG(0x140),\n\tREG(0x110),\n\tREG(0x11c),\n\tREG(0x114),\n\tREG(0x118),\n\tREG(0x1c0),\n\tREG(0x1c4),\n\tREG(0x1c8),\n\tREG(0x180),\n\n\tNOP(1),\n\tLRI(9, POSTED),\n\tREG16(0x3a8),\n\tREG16(0x28c),\n\tREG16(0x288),\n\tREG16(0x284),\n\tREG16(0x280),\n\tREG16(0x27c),\n\tREG16(0x278),\n\tREG16(0x274),\n\tREG16(0x270),\n\n\tLRI(1, POSTED),\n\tREG(0x1b0),\n\n\tNOP(10),\n\tLRI(1, 0),\n\tREG(0x0c8),\n\n\tEND\n};\n\nstatic const u8 gen12_rcs_offsets[] = {\n\tNOP(1),\n\tLRI(13, POSTED),\n\tREG16(0x244),\n\tREG(0x034),\n\tREG(0x030),\n\tREG(0x038),\n\tREG(0x03c),\n\tREG(0x168),\n\tREG(0x140),\n\tREG(0x110),\n\tREG(0x1c0),\n\tREG(0x1c4),\n\tREG(0x1c8),\n\tREG(0x180),\n\tREG16(0x2b4),\n\n\tNOP(5),\n\tLRI(9, POSTED),\n\tREG16(0x3a8),\n\tREG16(0x28c),\n\tREG16(0x288),\n\tREG16(0x284),\n\tREG16(0x280),\n\tREG16(0x27c),\n\tREG16(0x278),\n\tREG16(0x274),\n\tREG16(0x270),\n\n\tLRI(3, POSTED),\n\tREG(0x1b0),\n\tREG16(0x5a8),\n\tREG16(0x5ac),\n\n\tNOP(6),\n\tLRI(1, 0),\n\tREG(0x0c8),\n\tNOP(3 + 9 + 1),\n\n\tLRI(51, POSTED),\n\tREG16(0x588),\n\tREG16(0x588),\n\tREG16(0x588),\n\tREG16(0x588),\n\tREG16(0x588),\n\tREG16(0x588),\n\tREG(0x028),\n\tREG(0x09c),\n\tREG(0x0c0),\n\tREG(0x178),\n\tREG(0x17c),\n\tREG16(0x358),\n\tREG(0x170),\n\tREG(0x150),\n\tREG(0x154),\n\tREG(0x158),\n\tREG16(0x41c),\n\tREG16(0x600),\n\tREG16(0x604),\n\tREG16(0x608),\n\tREG16(0x60c),\n\tREG16(0x610),\n\tREG16(0x614),\n\tREG16(0x618),\n\tREG16(0x61c),\n\tREG16(0x620),\n\tREG16(0x624),\n\tREG16(0x628),\n\tREG16(0x62c),\n\tREG16(0x630),\n\tREG16(0x634),\n\tREG16(0x638),\n\tREG16(0x63c),\n\tREG16(0x640),\n\tREG16(0x644),\n\tREG16(0x648),\n\tREG16(0x64c),\n\tREG16(0x650),\n\tREG16(0x654),\n\tREG16(0x658),\n\tREG16(0x65c),\n\tREG16(0x660),\n\tREG16(0x664),\n\tREG16(0x668),\n\tREG16(0x66c),\n\tREG16(0x670),\n\tREG16(0x674),\n\tREG16(0x678),\n\tREG16(0x67c),\n\tREG(0x068),\n\tREG(0x084),\n\tNOP(1),\n\n\tEND\n};\n\nstatic const u8 xehp_rcs_offsets[] = {\n\tNOP(1),\n\tLRI(13, POSTED),\n\tREG16(0x244),\n\tREG(0x034),\n\tREG(0x030),\n\tREG(0x038),\n\tREG(0x03c),\n\tREG(0x168),\n\tREG(0x140),\n\tREG(0x110),\n\tREG(0x1c0),\n\tREG(0x1c4),\n\tREG(0x1c8),\n\tREG(0x180),\n\tREG16(0x2b4),\n\n\tNOP(5),\n\tLRI(9, POSTED),\n\tREG16(0x3a8),\n\tREG16(0x28c),\n\tREG16(0x288),\n\tREG16(0x284),\n\tREG16(0x280),\n\tREG16(0x27c),\n\tREG16(0x278),\n\tREG16(0x274),\n\tREG16(0x270),\n\n\tLRI(3, POSTED),\n\tREG(0x1b0),\n\tREG16(0x5a8),\n\tREG16(0x5ac),\n\n\tNOP(6),\n\tLRI(1, 0),\n\tREG(0x0c8),\n\n\tEND\n};\n\nstatic const u8 dg2_rcs_offsets[] = {\n\tNOP(1),\n\tLRI(15, POSTED),\n\tREG16(0x244),\n\tREG(0x034),\n\tREG(0x030),\n\tREG(0x038),\n\tREG(0x03c),\n\tREG(0x168),\n\tREG(0x140),\n\tREG(0x110),\n\tREG(0x1c0),\n\tREG(0x1c4),\n\tREG(0x1c8),\n\tREG(0x180),\n\tREG16(0x2b4),\n\tREG(0x120),\n\tREG(0x124),\n\n\tNOP(1),\n\tLRI(9, POSTED),\n\tREG16(0x3a8),\n\tREG16(0x28c),\n\tREG16(0x288),\n\tREG16(0x284),\n\tREG16(0x280),\n\tREG16(0x27c),\n\tREG16(0x278),\n\tREG16(0x274),\n\tREG16(0x270),\n\n\tLRI(3, POSTED),\n\tREG(0x1b0),\n\tREG16(0x5a8),\n\tREG16(0x5ac),\n\n\tNOP(6),\n\tLRI(1, 0),\n\tREG(0x0c8),\n\n\tEND\n};\n\nstatic const u8 mtl_rcs_offsets[] = {\n\tNOP(1),\n\tLRI(15, POSTED),\n\tREG16(0x244),\n\tREG(0x034),\n\tREG(0x030),\n\tREG(0x038),\n\tREG(0x03c),\n\tREG(0x168),\n\tREG(0x140),\n\tREG(0x110),\n\tREG(0x1c0),\n\tREG(0x1c4),\n\tREG(0x1c8),\n\tREG(0x180),\n\tREG16(0x2b4),\n\tREG(0x120),\n\tREG(0x124),\n\n\tNOP(1),\n\tLRI(9, POSTED),\n\tREG16(0x3a8),\n\tREG16(0x28c),\n\tREG16(0x288),\n\tREG16(0x284),\n\tREG16(0x280),\n\tREG16(0x27c),\n\tREG16(0x278),\n\tREG16(0x274),\n\tREG16(0x270),\n\n\tNOP(2),\n\tLRI(2, POSTED),\n\tREG16(0x5a8),\n\tREG16(0x5ac),\n\n\tNOP(6),\n\tLRI(1, 0),\n\tREG(0x0c8),\n\n\tEND\n};\n\n#undef END\n#undef REG16\n#undef REG\n#undef LRI\n#undef NOP\n\nstatic const u8 *reg_offsets(const struct intel_engine_cs *engine)\n{\n\t \n\tGEM_BUG_ON(GRAPHICS_VER(engine->i915) >= 12 &&\n\t\t   !intel_engine_has_relative_mmio(engine));\n\n\tif (engine->flags & I915_ENGINE_HAS_RCS_REG_STATE) {\n\t\tif (GRAPHICS_VER_FULL(engine->i915) >= IP_VER(12, 70))\n\t\t\treturn mtl_rcs_offsets;\n\t\telse if (GRAPHICS_VER_FULL(engine->i915) >= IP_VER(12, 55))\n\t\t\treturn dg2_rcs_offsets;\n\t\telse if (GRAPHICS_VER_FULL(engine->i915) >= IP_VER(12, 50))\n\t\t\treturn xehp_rcs_offsets;\n\t\telse if (GRAPHICS_VER(engine->i915) >= 12)\n\t\t\treturn gen12_rcs_offsets;\n\t\telse if (GRAPHICS_VER(engine->i915) >= 11)\n\t\t\treturn gen11_rcs_offsets;\n\t\telse if (GRAPHICS_VER(engine->i915) >= 9)\n\t\t\treturn gen9_rcs_offsets;\n\t\telse\n\t\t\treturn gen8_rcs_offsets;\n\t} else {\n\t\tif (GRAPHICS_VER_FULL(engine->i915) >= IP_VER(12, 55))\n\t\t\treturn dg2_xcs_offsets;\n\t\telse if (GRAPHICS_VER(engine->i915) >= 12)\n\t\t\treturn gen12_xcs_offsets;\n\t\telse if (GRAPHICS_VER(engine->i915) >= 9)\n\t\t\treturn gen9_xcs_offsets;\n\t\telse\n\t\t\treturn gen8_xcs_offsets;\n\t}\n}\n\nstatic int lrc_ring_mi_mode(const struct intel_engine_cs *engine)\n{\n\tif (GRAPHICS_VER_FULL(engine->i915) >= IP_VER(12, 50))\n\t\treturn 0x70;\n\telse if (GRAPHICS_VER(engine->i915) >= 12)\n\t\treturn 0x60;\n\telse if (GRAPHICS_VER(engine->i915) >= 9)\n\t\treturn 0x54;\n\telse if (engine->class == RENDER_CLASS)\n\t\treturn 0x58;\n\telse\n\t\treturn -1;\n}\n\nstatic int lrc_ring_bb_offset(const struct intel_engine_cs *engine)\n{\n\tif (GRAPHICS_VER_FULL(engine->i915) >= IP_VER(12, 50))\n\t\treturn 0x80;\n\telse if (GRAPHICS_VER(engine->i915) >= 12)\n\t\treturn 0x70;\n\telse if (GRAPHICS_VER(engine->i915) >= 9)\n\t\treturn 0x64;\n\telse if (GRAPHICS_VER(engine->i915) >= 8 &&\n\t\t engine->class == RENDER_CLASS)\n\t\treturn 0xc4;\n\telse\n\t\treturn -1;\n}\n\nstatic int lrc_ring_gpr0(const struct intel_engine_cs *engine)\n{\n\tif (GRAPHICS_VER_FULL(engine->i915) >= IP_VER(12, 50))\n\t\treturn 0x84;\n\telse if (GRAPHICS_VER(engine->i915) >= 12)\n\t\treturn 0x74;\n\telse if (GRAPHICS_VER(engine->i915) >= 9)\n\t\treturn 0x68;\n\telse if (engine->class == RENDER_CLASS)\n\t\treturn 0xd8;\n\telse\n\t\treturn -1;\n}\n\nstatic int lrc_ring_wa_bb_per_ctx(const struct intel_engine_cs *engine)\n{\n\tif (GRAPHICS_VER(engine->i915) >= 12)\n\t\treturn 0x12;\n\telse if (GRAPHICS_VER(engine->i915) >= 9 || engine->class == RENDER_CLASS)\n\t\treturn 0x18;\n\telse\n\t\treturn -1;\n}\n\nstatic int lrc_ring_indirect_ptr(const struct intel_engine_cs *engine)\n{\n\tint x;\n\n\tx = lrc_ring_wa_bb_per_ctx(engine);\n\tif (x < 0)\n\t\treturn x;\n\n\treturn x + 2;\n}\n\nstatic int lrc_ring_indirect_offset(const struct intel_engine_cs *engine)\n{\n\tint x;\n\n\tx = lrc_ring_indirect_ptr(engine);\n\tif (x < 0)\n\t\treturn x;\n\n\treturn x + 2;\n}\n\nstatic int lrc_ring_cmd_buf_cctl(const struct intel_engine_cs *engine)\n{\n\n\tif (GRAPHICS_VER_FULL(engine->i915) >= IP_VER(12, 50))\n\t\t \n\t\treturn 0xc6;\n\telse if (engine->class != RENDER_CLASS)\n\t\treturn -1;\n\telse if (GRAPHICS_VER(engine->i915) >= 12)\n\t\treturn 0xb6;\n\telse if (GRAPHICS_VER(engine->i915) >= 11)\n\t\treturn 0xaa;\n\telse\n\t\treturn -1;\n}\n\nstatic u32\nlrc_ring_indirect_offset_default(const struct intel_engine_cs *engine)\n{\n\tif (GRAPHICS_VER(engine->i915) >= 12)\n\t\treturn GEN12_CTX_RCS_INDIRECT_CTX_OFFSET_DEFAULT;\n\telse if (GRAPHICS_VER(engine->i915) >= 11)\n\t\treturn GEN11_CTX_RCS_INDIRECT_CTX_OFFSET_DEFAULT;\n\telse if (GRAPHICS_VER(engine->i915) >= 9)\n\t\treturn GEN9_CTX_RCS_INDIRECT_CTX_OFFSET_DEFAULT;\n\telse if (GRAPHICS_VER(engine->i915) >= 8)\n\t\treturn GEN8_CTX_RCS_INDIRECT_CTX_OFFSET_DEFAULT;\n\n\tGEM_BUG_ON(GRAPHICS_VER(engine->i915) < 8);\n\n\treturn 0;\n}\n\nstatic void\nlrc_setup_indirect_ctx(u32 *regs,\n\t\t       const struct intel_engine_cs *engine,\n\t\t       u32 ctx_bb_ggtt_addr,\n\t\t       u32 size)\n{\n\tGEM_BUG_ON(!size);\n\tGEM_BUG_ON(!IS_ALIGNED(size, CACHELINE_BYTES));\n\tGEM_BUG_ON(lrc_ring_indirect_ptr(engine) == -1);\n\tregs[lrc_ring_indirect_ptr(engine) + 1] =\n\t\tctx_bb_ggtt_addr | (size / CACHELINE_BYTES);\n\n\tGEM_BUG_ON(lrc_ring_indirect_offset(engine) == -1);\n\tregs[lrc_ring_indirect_offset(engine) + 1] =\n\t\tlrc_ring_indirect_offset_default(engine) << 6;\n}\n\nstatic void init_common_regs(u32 * const regs,\n\t\t\t     const struct intel_context *ce,\n\t\t\t     const struct intel_engine_cs *engine,\n\t\t\t     bool inhibit)\n{\n\tu32 ctl;\n\tint loc;\n\n\tctl = _MASKED_BIT_ENABLE(CTX_CTRL_INHIBIT_SYN_CTX_SWITCH);\n\tctl |= _MASKED_BIT_DISABLE(CTX_CTRL_ENGINE_CTX_RESTORE_INHIBIT);\n\tif (inhibit)\n\t\tctl |= CTX_CTRL_ENGINE_CTX_RESTORE_INHIBIT;\n\tif (GRAPHICS_VER(engine->i915) < 11)\n\t\tctl |= _MASKED_BIT_DISABLE(CTX_CTRL_ENGINE_CTX_SAVE_INHIBIT |\n\t\t\t\t\t   CTX_CTRL_RS_CTX_ENABLE);\n\tregs[CTX_CONTEXT_CONTROL] = ctl;\n\n\tregs[CTX_TIMESTAMP] = ce->stats.runtime.last;\n\n\tloc = lrc_ring_bb_offset(engine);\n\tif (loc != -1)\n\t\tregs[loc + 1] = 0;\n}\n\nstatic void init_wa_bb_regs(u32 * const regs,\n\t\t\t    const struct intel_engine_cs *engine)\n{\n\tconst struct i915_ctx_workarounds * const wa_ctx = &engine->wa_ctx;\n\n\tif (wa_ctx->per_ctx.size) {\n\t\tconst u32 ggtt_offset = i915_ggtt_offset(wa_ctx->vma);\n\n\t\tGEM_BUG_ON(lrc_ring_wa_bb_per_ctx(engine) == -1);\n\t\tregs[lrc_ring_wa_bb_per_ctx(engine) + 1] =\n\t\t\t(ggtt_offset + wa_ctx->per_ctx.offset) | 0x01;\n\t}\n\n\tif (wa_ctx->indirect_ctx.size) {\n\t\tlrc_setup_indirect_ctx(regs, engine,\n\t\t\t\t       i915_ggtt_offset(wa_ctx->vma) +\n\t\t\t\t       wa_ctx->indirect_ctx.offset,\n\t\t\t\t       wa_ctx->indirect_ctx.size);\n\t}\n}\n\nstatic void init_ppgtt_regs(u32 *regs, const struct i915_ppgtt *ppgtt)\n{\n\tif (i915_vm_is_4lvl(&ppgtt->vm)) {\n\t\t \n\t\tASSIGN_CTX_PML4(ppgtt, regs);\n\t} else {\n\t\tASSIGN_CTX_PDP(ppgtt, regs, 3);\n\t\tASSIGN_CTX_PDP(ppgtt, regs, 2);\n\t\tASSIGN_CTX_PDP(ppgtt, regs, 1);\n\t\tASSIGN_CTX_PDP(ppgtt, regs, 0);\n\t}\n}\n\nstatic struct i915_ppgtt *vm_alias(struct i915_address_space *vm)\n{\n\tif (i915_is_ggtt(vm))\n\t\treturn i915_vm_to_ggtt(vm)->alias;\n\telse\n\t\treturn i915_vm_to_ppgtt(vm);\n}\n\nstatic void __reset_stop_ring(u32 *regs, const struct intel_engine_cs *engine)\n{\n\tint x;\n\n\tx = lrc_ring_mi_mode(engine);\n\tif (x != -1) {\n\t\tregs[x + 1] &= ~STOP_RING;\n\t\tregs[x + 1] |= STOP_RING << 16;\n\t}\n}\n\nstatic void __lrc_init_regs(u32 *regs,\n\t\t\t    const struct intel_context *ce,\n\t\t\t    const struct intel_engine_cs *engine,\n\t\t\t    bool inhibit)\n{\n\t \n\n\tif (inhibit)\n\t\tmemset(regs, 0, PAGE_SIZE);\n\n\tset_offsets(regs, reg_offsets(engine), engine, inhibit);\n\n\tinit_common_regs(regs, ce, engine, inhibit);\n\tinit_ppgtt_regs(regs, vm_alias(ce->vm));\n\n\tinit_wa_bb_regs(regs, engine);\n\n\t__reset_stop_ring(regs, engine);\n}\n\nvoid lrc_init_regs(const struct intel_context *ce,\n\t\t   const struct intel_engine_cs *engine,\n\t\t   bool inhibit)\n{\n\t__lrc_init_regs(ce->lrc_reg_state, ce, engine, inhibit);\n}\n\nvoid lrc_reset_regs(const struct intel_context *ce,\n\t\t    const struct intel_engine_cs *engine)\n{\n\t__reset_stop_ring(ce->lrc_reg_state, engine);\n}\n\nstatic void\nset_redzone(void *vaddr, const struct intel_engine_cs *engine)\n{\n\tif (!IS_ENABLED(CONFIG_DRM_I915_DEBUG_GEM))\n\t\treturn;\n\n\tvaddr += engine->context_size;\n\n\tmemset(vaddr, CONTEXT_REDZONE, I915_GTT_PAGE_SIZE);\n}\n\nstatic void\ncheck_redzone(const void *vaddr, const struct intel_engine_cs *engine)\n{\n\tif (!IS_ENABLED(CONFIG_DRM_I915_DEBUG_GEM))\n\t\treturn;\n\n\tvaddr += engine->context_size;\n\n\tif (memchr_inv(vaddr, CONTEXT_REDZONE, I915_GTT_PAGE_SIZE))\n\t\tdrm_err_once(&engine->i915->drm,\n\t\t\t     \"%s context redzone overwritten!\\n\",\n\t\t\t     engine->name);\n}\n\nstatic u32 context_wa_bb_offset(const struct intel_context *ce)\n{\n\treturn PAGE_SIZE * ce->wa_bb_page;\n}\n\nstatic u32 *context_indirect_bb(const struct intel_context *ce)\n{\n\tvoid *ptr;\n\n\tGEM_BUG_ON(!ce->wa_bb_page);\n\n\tptr = ce->lrc_reg_state;\n\tptr -= LRC_STATE_OFFSET;  \n\tptr += context_wa_bb_offset(ce);\n\n\treturn ptr;\n}\n\nvoid lrc_init_state(struct intel_context *ce,\n\t\t    struct intel_engine_cs *engine,\n\t\t    void *state)\n{\n\tbool inhibit = true;\n\n\tset_redzone(state, engine);\n\n\tif (engine->default_state) {\n\t\tshmem_read(engine->default_state, 0,\n\t\t\t   state, engine->context_size);\n\t\t__set_bit(CONTEXT_VALID_BIT, &ce->flags);\n\t\tinhibit = false;\n\t}\n\n\t \n\tmemset(state, 0, PAGE_SIZE);\n\n\t \n\tif (ce->wa_bb_page)\n\t\tmemset(state + context_wa_bb_offset(ce), 0, PAGE_SIZE);\n\n\t \n\t__lrc_init_regs(state + LRC_STATE_OFFSET, ce, engine, inhibit);\n}\n\nu32 lrc_indirect_bb(const struct intel_context *ce)\n{\n\treturn i915_ggtt_offset(ce->state) + context_wa_bb_offset(ce);\n}\n\nstatic u32 *setup_predicate_disable_wa(const struct intel_context *ce, u32 *cs)\n{\n\t \n\t*cs++ = MI_STORE_DWORD_IMM_GEN4 | MI_USE_GGTT | (4 - 2);\n\t*cs++ = lrc_indirect_bb(ce) + DG2_PREDICATE_RESULT_WA;\n\t*cs++ = 0;\n\t*cs++ = 0;  \n\n\t \n\t*cs++ = MI_BATCH_BUFFER_END | BIT(15);\n\t*cs++ = MI_SET_PREDICATE | MI_SET_PREDICATE_DISABLE;\n\n\t \n\t*cs++ = MI_STORE_DWORD_IMM_GEN4 | MI_USE_GGTT | (4 - 2);\n\t*cs++ = lrc_indirect_bb(ce) + DG2_PREDICATE_RESULT_WA;\n\t*cs++ = 0;\n\t*cs++ = 1;  \n\n\t*cs++ = MI_BATCH_BUFFER_END;\n\tGEM_BUG_ON(offset_in_page(cs) > DG2_PREDICATE_RESULT_WA);\n\n\treturn cs;\n}\n\nstatic struct i915_vma *\n__lrc_alloc_state(struct intel_context *ce, struct intel_engine_cs *engine)\n{\n\tstruct drm_i915_gem_object *obj;\n\tstruct i915_vma *vma;\n\tu32 context_size;\n\n\tcontext_size = round_up(engine->context_size, I915_GTT_PAGE_SIZE);\n\n\tif (IS_ENABLED(CONFIG_DRM_I915_DEBUG_GEM))\n\t\tcontext_size += I915_GTT_PAGE_SIZE;  \n\n\tif (GRAPHICS_VER(engine->i915) >= 12) {\n\t\tce->wa_bb_page = context_size / PAGE_SIZE;\n\t\tcontext_size += PAGE_SIZE;\n\t}\n\n\tif (intel_context_is_parent(ce) && intel_engine_uses_guc(engine)) {\n\t\tce->parallel.guc.parent_page = context_size / PAGE_SIZE;\n\t\tcontext_size += PARENT_SCRATCH_SIZE;\n\t}\n\n\tobj = i915_gem_object_create_lmem(engine->i915, context_size,\n\t\t\t\t\t  I915_BO_ALLOC_PM_VOLATILE);\n\tif (IS_ERR(obj)) {\n\t\tobj = i915_gem_object_create_shmem(engine->i915, context_size);\n\t\tif (IS_ERR(obj))\n\t\t\treturn ERR_CAST(obj);\n\n\t\t \n\t\tif (intel_gt_needs_wa_22016122933(engine->gt))\n\t\t\ti915_gem_object_set_cache_coherency(obj, I915_CACHE_NONE);\n\t}\n\n\tvma = i915_vma_instance(obj, &engine->gt->ggtt->vm, NULL);\n\tif (IS_ERR(vma)) {\n\t\ti915_gem_object_put(obj);\n\t\treturn vma;\n\t}\n\n\treturn vma;\n}\n\nstatic struct intel_timeline *\npinned_timeline(struct intel_context *ce, struct intel_engine_cs *engine)\n{\n\tstruct intel_timeline *tl = fetch_and_zero(&ce->timeline);\n\n\treturn intel_timeline_create_from_engine(engine, page_unmask_bits(tl));\n}\n\nint lrc_alloc(struct intel_context *ce, struct intel_engine_cs *engine)\n{\n\tstruct intel_ring *ring;\n\tstruct i915_vma *vma;\n\tint err;\n\n\tGEM_BUG_ON(ce->state);\n\n\tvma = __lrc_alloc_state(ce, engine);\n\tif (IS_ERR(vma))\n\t\treturn PTR_ERR(vma);\n\n\tring = intel_engine_create_ring(engine, ce->ring_size);\n\tif (IS_ERR(ring)) {\n\t\terr = PTR_ERR(ring);\n\t\tgoto err_vma;\n\t}\n\n\tif (!page_mask_bits(ce->timeline)) {\n\t\tstruct intel_timeline *tl;\n\n\t\t \n\t\tif (unlikely(ce->timeline))\n\t\t\ttl = pinned_timeline(ce, engine);\n\t\telse\n\t\t\ttl = intel_timeline_create(engine->gt);\n\t\tif (IS_ERR(tl)) {\n\t\t\terr = PTR_ERR(tl);\n\t\t\tgoto err_ring;\n\t\t}\n\n\t\tce->timeline = tl;\n\t}\n\n\tce->ring = ring;\n\tce->state = vma;\n\n\treturn 0;\n\nerr_ring:\n\tintel_ring_put(ring);\nerr_vma:\n\ti915_vma_put(vma);\n\treturn err;\n}\n\nvoid lrc_reset(struct intel_context *ce)\n{\n\tGEM_BUG_ON(!intel_context_is_pinned(ce));\n\n\tintel_ring_reset(ce->ring, ce->ring->emit);\n\n\t \n\tlrc_init_regs(ce, ce->engine, true);\n\tce->lrc.lrca = lrc_update_regs(ce, ce->engine, ce->ring->tail);\n}\n\nint\nlrc_pre_pin(struct intel_context *ce,\n\t    struct intel_engine_cs *engine,\n\t    struct i915_gem_ww_ctx *ww,\n\t    void **vaddr)\n{\n\tGEM_BUG_ON(!ce->state);\n\tGEM_BUG_ON(!i915_vma_is_pinned(ce->state));\n\n\t*vaddr = i915_gem_object_pin_map(ce->state->obj,\n\t\t\t\t\t intel_gt_coherent_map_type(ce->engine->gt,\n\t\t\t\t\t\t\t\t    ce->state->obj,\n\t\t\t\t\t\t\t\t    false) |\n\t\t\t\t\t I915_MAP_OVERRIDE);\n\n\treturn PTR_ERR_OR_ZERO(*vaddr);\n}\n\nint\nlrc_pin(struct intel_context *ce,\n\tstruct intel_engine_cs *engine,\n\tvoid *vaddr)\n{\n\tce->lrc_reg_state = vaddr + LRC_STATE_OFFSET;\n\n\tif (!__test_and_set_bit(CONTEXT_INIT_BIT, &ce->flags))\n\t\tlrc_init_state(ce, engine, vaddr);\n\n\tce->lrc.lrca = lrc_update_regs(ce, engine, ce->ring->tail);\n\treturn 0;\n}\n\nvoid lrc_unpin(struct intel_context *ce)\n{\n\tif (unlikely(ce->parallel.last_rq)) {\n\t\ti915_request_put(ce->parallel.last_rq);\n\t\tce->parallel.last_rq = NULL;\n\t}\n\tcheck_redzone((void *)ce->lrc_reg_state - LRC_STATE_OFFSET,\n\t\t      ce->engine);\n}\n\nvoid lrc_post_unpin(struct intel_context *ce)\n{\n\ti915_gem_object_unpin_map(ce->state->obj);\n}\n\nvoid lrc_fini(struct intel_context *ce)\n{\n\tif (!ce->state)\n\t\treturn;\n\n\tintel_ring_put(fetch_and_zero(&ce->ring));\n\ti915_vma_put(fetch_and_zero(&ce->state));\n}\n\nvoid lrc_destroy(struct kref *kref)\n{\n\tstruct intel_context *ce = container_of(kref, typeof(*ce), ref);\n\n\tGEM_BUG_ON(!i915_active_is_idle(&ce->active));\n\tGEM_BUG_ON(intel_context_is_pinned(ce));\n\n\tlrc_fini(ce);\n\n\tintel_context_fini(ce);\n\tintel_context_free(ce);\n}\n\nstatic u32 *\ngen12_emit_timestamp_wa(const struct intel_context *ce, u32 *cs)\n{\n\t*cs++ = MI_LOAD_REGISTER_MEM_GEN8 |\n\t\tMI_SRM_LRM_GLOBAL_GTT |\n\t\tMI_LRI_LRM_CS_MMIO;\n\t*cs++ = i915_mmio_reg_offset(GEN8_RING_CS_GPR(0, 0));\n\t*cs++ = i915_ggtt_offset(ce->state) + LRC_STATE_OFFSET +\n\t\tCTX_TIMESTAMP * sizeof(u32);\n\t*cs++ = 0;\n\n\t*cs++ = MI_LOAD_REGISTER_REG |\n\t\tMI_LRR_SOURCE_CS_MMIO |\n\t\tMI_LRI_LRM_CS_MMIO;\n\t*cs++ = i915_mmio_reg_offset(GEN8_RING_CS_GPR(0, 0));\n\t*cs++ = i915_mmio_reg_offset(RING_CTX_TIMESTAMP(0));\n\n\t*cs++ = MI_LOAD_REGISTER_REG |\n\t\tMI_LRR_SOURCE_CS_MMIO |\n\t\tMI_LRI_LRM_CS_MMIO;\n\t*cs++ = i915_mmio_reg_offset(GEN8_RING_CS_GPR(0, 0));\n\t*cs++ = i915_mmio_reg_offset(RING_CTX_TIMESTAMP(0));\n\n\treturn cs;\n}\n\nstatic u32 *\ngen12_emit_restore_scratch(const struct intel_context *ce, u32 *cs)\n{\n\tGEM_BUG_ON(lrc_ring_gpr0(ce->engine) == -1);\n\n\t*cs++ = MI_LOAD_REGISTER_MEM_GEN8 |\n\t\tMI_SRM_LRM_GLOBAL_GTT |\n\t\tMI_LRI_LRM_CS_MMIO;\n\t*cs++ = i915_mmio_reg_offset(GEN8_RING_CS_GPR(0, 0));\n\t*cs++ = i915_ggtt_offset(ce->state) + LRC_STATE_OFFSET +\n\t\t(lrc_ring_gpr0(ce->engine) + 1) * sizeof(u32);\n\t*cs++ = 0;\n\n\treturn cs;\n}\n\nstatic u32 *\ngen12_emit_cmd_buf_wa(const struct intel_context *ce, u32 *cs)\n{\n\tGEM_BUG_ON(lrc_ring_cmd_buf_cctl(ce->engine) == -1);\n\n\t*cs++ = MI_LOAD_REGISTER_MEM_GEN8 |\n\t\tMI_SRM_LRM_GLOBAL_GTT |\n\t\tMI_LRI_LRM_CS_MMIO;\n\t*cs++ = i915_mmio_reg_offset(GEN8_RING_CS_GPR(0, 0));\n\t*cs++ = i915_ggtt_offset(ce->state) + LRC_STATE_OFFSET +\n\t\t(lrc_ring_cmd_buf_cctl(ce->engine) + 1) * sizeof(u32);\n\t*cs++ = 0;\n\n\t*cs++ = MI_LOAD_REGISTER_REG |\n\t\tMI_LRR_SOURCE_CS_MMIO |\n\t\tMI_LRI_LRM_CS_MMIO;\n\t*cs++ = i915_mmio_reg_offset(GEN8_RING_CS_GPR(0, 0));\n\t*cs++ = i915_mmio_reg_offset(RING_CMD_BUF_CCTL(0));\n\n\treturn cs;\n}\n\n \nstatic u32 *\ndg2_emit_rcs_hang_wabb(const struct intel_context *ce, u32 *cs)\n{\n\t*cs++ = MI_LOAD_REGISTER_IMM(1);\n\t*cs++ = i915_mmio_reg_offset(GEN12_STATE_ACK_DEBUG(ce->engine->mmio_base));\n\t*cs++ = 0x21;\n\n\t*cs++ = MI_LOAD_REGISTER_REG;\n\t*cs++ = i915_mmio_reg_offset(RING_NOPID(ce->engine->mmio_base));\n\t*cs++ = i915_mmio_reg_offset(XEHP_CULLBIT1);\n\n\t*cs++ = MI_LOAD_REGISTER_REG;\n\t*cs++ = i915_mmio_reg_offset(RING_NOPID(ce->engine->mmio_base));\n\t*cs++ = i915_mmio_reg_offset(XEHP_CULLBIT2);\n\n\treturn cs;\n}\n\n \nstatic u32 *\ndg2_emit_draw_watermark_setting(u32 *cs)\n{\n\t*cs++ = MI_LOAD_REGISTER_IMM(1);\n\t*cs++ = i915_mmio_reg_offset(DRAW_WATERMARK);\n\t*cs++ = REG_FIELD_PREP(VERT_WM_VAL, 0x3FF);\n\n\treturn cs;\n}\n\nstatic u32 *\ngen12_emit_indirect_ctx_rcs(const struct intel_context *ce, u32 *cs)\n{\n\tcs = gen12_emit_timestamp_wa(ce, cs);\n\tcs = gen12_emit_cmd_buf_wa(ce, cs);\n\tcs = gen12_emit_restore_scratch(ce, cs);\n\n\t \n\tif (IS_DG2_GRAPHICS_STEP(ce->engine->i915, G10, STEP_A0, STEP_B0) ||\n\t    IS_DG2_GRAPHICS_STEP(ce->engine->i915, G11, STEP_A0, STEP_B0))\n\t\tcs = dg2_emit_rcs_hang_wabb(ce, cs);\n\n\t \n\tif (IS_DG2_GRAPHICS_STEP(ce->engine->i915, G10, STEP_B0, STEP_C0) ||\n\t    IS_DG2_G11(ce->engine->i915))\n\t\tcs = gen8_emit_pipe_control(cs, PIPE_CONTROL_INSTRUCTION_CACHE_INVALIDATE, 0);\n\n\tcs = gen12_emit_aux_table_inv(ce->engine, cs);\n\n\t \n\tif (IS_MTL_GRAPHICS_STEP(ce->engine->i915, M, STEP_A0, STEP_B0) ||\n\t    IS_MTL_GRAPHICS_STEP(ce->engine->i915, P, STEP_A0, STEP_B0) ||\n\t    IS_DG2(ce->engine->i915))\n\t\tcs = dg2_emit_draw_watermark_setting(cs);\n\n\treturn cs;\n}\n\nstatic u32 *\ngen12_emit_indirect_ctx_xcs(const struct intel_context *ce, u32 *cs)\n{\n\tcs = gen12_emit_timestamp_wa(ce, cs);\n\tcs = gen12_emit_restore_scratch(ce, cs);\n\n\t \n\tif (IS_DG2_GRAPHICS_STEP(ce->engine->i915, G10, STEP_B0, STEP_C0) ||\n\t    IS_DG2_G11(ce->engine->i915))\n\t\tif (ce->engine->class == COMPUTE_CLASS)\n\t\t\tcs = gen8_emit_pipe_control(cs,\n\t\t\t\t\t\t    PIPE_CONTROL_INSTRUCTION_CACHE_INVALIDATE,\n\t\t\t\t\t\t    0);\n\n\treturn gen12_emit_aux_table_inv(ce->engine, cs);\n}\n\nstatic void\nsetup_indirect_ctx_bb(const struct intel_context *ce,\n\t\t      const struct intel_engine_cs *engine,\n\t\t      u32 *(*emit)(const struct intel_context *, u32 *))\n{\n\tu32 * const start = context_indirect_bb(ce);\n\tu32 *cs;\n\n\tcs = emit(ce, start);\n\tGEM_BUG_ON(cs - start > I915_GTT_PAGE_SIZE / sizeof(*cs));\n\twhile ((unsigned long)cs % CACHELINE_BYTES)\n\t\t*cs++ = MI_NOOP;\n\n\tGEM_BUG_ON(cs - start > DG2_PREDICATE_RESULT_BB / sizeof(*start));\n\tsetup_predicate_disable_wa(ce, start + DG2_PREDICATE_RESULT_BB / sizeof(*start));\n\n\tlrc_setup_indirect_ctx(ce->lrc_reg_state, engine,\n\t\t\t       lrc_indirect_bb(ce),\n\t\t\t       (cs - start) * sizeof(*cs));\n}\n\n \nstatic u32 lrc_descriptor(const struct intel_context *ce)\n{\n\tu32 desc;\n\n\tdesc = INTEL_LEGACY_32B_CONTEXT;\n\tif (i915_vm_is_4lvl(ce->vm))\n\t\tdesc = INTEL_LEGACY_64B_CONTEXT;\n\tdesc <<= GEN8_CTX_ADDRESSING_MODE_SHIFT;\n\n\tdesc |= GEN8_CTX_VALID | GEN8_CTX_PRIVILEGE;\n\tif (GRAPHICS_VER(ce->vm->i915) == 8)\n\t\tdesc |= GEN8_CTX_L3LLC_COHERENT;\n\n\treturn i915_ggtt_offset(ce->state) | desc;\n}\n\nu32 lrc_update_regs(const struct intel_context *ce,\n\t\t    const struct intel_engine_cs *engine,\n\t\t    u32 head)\n{\n\tstruct intel_ring *ring = ce->ring;\n\tu32 *regs = ce->lrc_reg_state;\n\n\tGEM_BUG_ON(!intel_ring_offset_valid(ring, head));\n\tGEM_BUG_ON(!intel_ring_offset_valid(ring, ring->tail));\n\n\tregs[CTX_RING_START] = i915_ggtt_offset(ring->vma);\n\tregs[CTX_RING_HEAD] = head;\n\tregs[CTX_RING_TAIL] = ring->tail;\n\tregs[CTX_RING_CTL] = RING_CTL_SIZE(ring->size) | RING_VALID;\n\n\t \n\tif (engine->class == RENDER_CLASS) {\n\t\tregs[CTX_R_PWR_CLK_STATE] =\n\t\t\tintel_sseu_make_rpcs(engine->gt, &ce->sseu);\n\n\t\ti915_oa_init_reg_state(ce, engine);\n\t}\n\n\tif (ce->wa_bb_page) {\n\t\tu32 *(*fn)(const struct intel_context *ce, u32 *cs);\n\n\t\tfn = gen12_emit_indirect_ctx_xcs;\n\t\tif (ce->engine->class == RENDER_CLASS)\n\t\t\tfn = gen12_emit_indirect_ctx_rcs;\n\n\t\t \n\t\tGEM_BUG_ON(engine->wa_ctx.indirect_ctx.size);\n\t\tsetup_indirect_ctx_bb(ce, engine, fn);\n\t}\n\n\treturn lrc_descriptor(ce) | CTX_DESC_FORCE_RESTORE;\n}\n\nvoid lrc_update_offsets(struct intel_context *ce,\n\t\t\tstruct intel_engine_cs *engine)\n{\n\tset_offsets(ce->lrc_reg_state, reg_offsets(engine), engine, false);\n}\n\nvoid lrc_check_regs(const struct intel_context *ce,\n\t\t    const struct intel_engine_cs *engine,\n\t\t    const char *when)\n{\n\tconst struct intel_ring *ring = ce->ring;\n\tu32 *regs = ce->lrc_reg_state;\n\tbool valid = true;\n\tint x;\n\n\tif (regs[CTX_RING_START] != i915_ggtt_offset(ring->vma)) {\n\t\tpr_err(\"%s: context submitted with incorrect RING_START [%08x], expected %08x\\n\",\n\t\t       engine->name,\n\t\t       regs[CTX_RING_START],\n\t\t       i915_ggtt_offset(ring->vma));\n\t\tregs[CTX_RING_START] = i915_ggtt_offset(ring->vma);\n\t\tvalid = false;\n\t}\n\n\tif ((regs[CTX_RING_CTL] & ~(RING_WAIT | RING_WAIT_SEMAPHORE)) !=\n\t    (RING_CTL_SIZE(ring->size) | RING_VALID)) {\n\t\tpr_err(\"%s: context submitted with incorrect RING_CTL [%08x], expected %08x\\n\",\n\t\t       engine->name,\n\t\t       regs[CTX_RING_CTL],\n\t\t       (u32)(RING_CTL_SIZE(ring->size) | RING_VALID));\n\t\tregs[CTX_RING_CTL] = RING_CTL_SIZE(ring->size) | RING_VALID;\n\t\tvalid = false;\n\t}\n\n\tx = lrc_ring_mi_mode(engine);\n\tif (x != -1 && regs[x + 1] & (regs[x + 1] >> 16) & STOP_RING) {\n\t\tpr_err(\"%s: context submitted with STOP_RING [%08x] in RING_MI_MODE\\n\",\n\t\t       engine->name, regs[x + 1]);\n\t\tregs[x + 1] &= ~STOP_RING;\n\t\tregs[x + 1] |= STOP_RING << 16;\n\t\tvalid = false;\n\t}\n\n\tWARN_ONCE(!valid, \"Invalid lrc state found %s submission\\n\", when);\n}\n\n \nstatic u32 *\ngen8_emit_flush_coherentl3_wa(struct intel_engine_cs *engine, u32 *batch)\n{\n\t \n\t*batch++ = MI_STORE_REGISTER_MEM_GEN8 | MI_SRM_LRM_GLOBAL_GTT;\n\t*batch++ = i915_mmio_reg_offset(GEN8_L3SQCREG4);\n\t*batch++ = intel_gt_scratch_offset(engine->gt,\n\t\t\t\t\t   INTEL_GT_SCRATCH_FIELD_COHERENTL3_WA);\n\t*batch++ = 0;\n\n\t*batch++ = MI_LOAD_REGISTER_IMM(1);\n\t*batch++ = i915_mmio_reg_offset(GEN8_L3SQCREG4);\n\t*batch++ = 0x40400000 | GEN8_LQSC_FLUSH_COHERENT_LINES;\n\n\tbatch = gen8_emit_pipe_control(batch,\n\t\t\t\t       PIPE_CONTROL_CS_STALL |\n\t\t\t\t       PIPE_CONTROL_DC_FLUSH_ENABLE,\n\t\t\t\t       0);\n\n\t*batch++ = MI_LOAD_REGISTER_MEM_GEN8 | MI_SRM_LRM_GLOBAL_GTT;\n\t*batch++ = i915_mmio_reg_offset(GEN8_L3SQCREG4);\n\t*batch++ = intel_gt_scratch_offset(engine->gt,\n\t\t\t\t\t   INTEL_GT_SCRATCH_FIELD_COHERENTL3_WA);\n\t*batch++ = 0;\n\n\treturn batch;\n}\n\n \nstatic u32 *gen8_init_indirectctx_bb(struct intel_engine_cs *engine, u32 *batch)\n{\n\t \n\t*batch++ = MI_ARB_ON_OFF | MI_ARB_DISABLE;\n\n\t \n\tif (IS_BROADWELL(engine->i915))\n\t\tbatch = gen8_emit_flush_coherentl3_wa(engine, batch);\n\n\t \n\t \n\tbatch = gen8_emit_pipe_control(batch,\n\t\t\t\t       PIPE_CONTROL_FLUSH_L3 |\n\t\t\t\t       PIPE_CONTROL_STORE_DATA_INDEX |\n\t\t\t\t       PIPE_CONTROL_CS_STALL |\n\t\t\t\t       PIPE_CONTROL_QW_WRITE,\n\t\t\t\t       LRC_PPHWSP_SCRATCH_ADDR);\n\n\t*batch++ = MI_ARB_ON_OFF | MI_ARB_ENABLE;\n\n\t \n\twhile ((unsigned long)batch % CACHELINE_BYTES)\n\t\t*batch++ = MI_NOOP;\n\n\t \n\n\treturn batch;\n}\n\nstruct lri {\n\ti915_reg_t reg;\n\tu32 value;\n};\n\nstatic u32 *emit_lri(u32 *batch, const struct lri *lri, unsigned int count)\n{\n\tGEM_BUG_ON(!count || count > 63);\n\n\t*batch++ = MI_LOAD_REGISTER_IMM(count);\n\tdo {\n\t\t*batch++ = i915_mmio_reg_offset(lri->reg);\n\t\t*batch++ = lri->value;\n\t} while (lri++, --count);\n\t*batch++ = MI_NOOP;\n\n\treturn batch;\n}\n\nstatic u32 *gen9_init_indirectctx_bb(struct intel_engine_cs *engine, u32 *batch)\n{\n\tstatic const struct lri lri[] = {\n\t\t \n\t\t{\n\t\t\tCOMMON_SLICE_CHICKEN2,\n\t\t\t__MASKED_FIELD(GEN9_DISABLE_GATHER_AT_SET_SHADER_COMMON_SLICE,\n\t\t\t\t       0),\n\t\t},\n\n\t\t \n\t\t{\n\t\t\tFF_SLICE_CHICKEN,\n\t\t\t__MASKED_FIELD(FF_SLICE_CHICKEN_CL_PROVOKING_VERTEX_FIX,\n\t\t\t\t       FF_SLICE_CHICKEN_CL_PROVOKING_VERTEX_FIX),\n\t\t},\n\n\t\t \n\t\t{\n\t\t\t_3D_CHICKEN3,\n\t\t\t__MASKED_FIELD(_3D_CHICKEN_SF_PROVOKING_VERTEX_FIX,\n\t\t\t\t       _3D_CHICKEN_SF_PROVOKING_VERTEX_FIX),\n\t\t}\n\t};\n\n\t*batch++ = MI_ARB_ON_OFF | MI_ARB_DISABLE;\n\n\t \n\tbatch = gen8_emit_flush_coherentl3_wa(engine, batch);\n\n\t \n\tbatch = gen8_emit_pipe_control(batch,\n\t\t\t\t       PIPE_CONTROL_FLUSH_L3 |\n\t\t\t\t       PIPE_CONTROL_STORE_DATA_INDEX |\n\t\t\t\t       PIPE_CONTROL_CS_STALL |\n\t\t\t\t       PIPE_CONTROL_QW_WRITE,\n\t\t\t\t       LRC_PPHWSP_SCRATCH_ADDR);\n\n\tbatch = emit_lri(batch, lri, ARRAY_SIZE(lri));\n\n\t \n\tif (HAS_POOLED_EU(engine->i915)) {\n\t\t \n\t\t*batch++ = GEN9_MEDIA_POOL_STATE;\n\t\t*batch++ = GEN9_MEDIA_POOL_ENABLE;\n\t\t*batch++ = 0x00777000;\n\t\t*batch++ = 0;\n\t\t*batch++ = 0;\n\t\t*batch++ = 0;\n\t}\n\n\t*batch++ = MI_ARB_ON_OFF | MI_ARB_ENABLE;\n\n\t \n\twhile ((unsigned long)batch % CACHELINE_BYTES)\n\t\t*batch++ = MI_NOOP;\n\n\treturn batch;\n}\n\n#define CTX_WA_BB_SIZE (PAGE_SIZE)\n\nstatic int lrc_create_wa_ctx(struct intel_engine_cs *engine)\n{\n\tstruct drm_i915_gem_object *obj;\n\tstruct i915_vma *vma;\n\tint err;\n\n\tobj = i915_gem_object_create_shmem(engine->i915, CTX_WA_BB_SIZE);\n\tif (IS_ERR(obj))\n\t\treturn PTR_ERR(obj);\n\n\tvma = i915_vma_instance(obj, &engine->gt->ggtt->vm, NULL);\n\tif (IS_ERR(vma)) {\n\t\terr = PTR_ERR(vma);\n\t\tgoto err;\n\t}\n\n\tengine->wa_ctx.vma = vma;\n\treturn 0;\n\nerr:\n\ti915_gem_object_put(obj);\n\treturn err;\n}\n\nvoid lrc_fini_wa_ctx(struct intel_engine_cs *engine)\n{\n\ti915_vma_unpin_and_release(&engine->wa_ctx.vma, 0);\n}\n\ntypedef u32 *(*wa_bb_func_t)(struct intel_engine_cs *engine, u32 *batch);\n\nvoid lrc_init_wa_ctx(struct intel_engine_cs *engine)\n{\n\tstruct i915_ctx_workarounds *wa_ctx = &engine->wa_ctx;\n\tstruct i915_wa_ctx_bb *wa_bb[] = {\n\t\t&wa_ctx->indirect_ctx, &wa_ctx->per_ctx\n\t};\n\twa_bb_func_t wa_bb_fn[ARRAY_SIZE(wa_bb)];\n\tstruct i915_gem_ww_ctx ww;\n\tvoid *batch, *batch_ptr;\n\tunsigned int i;\n\tint err;\n\n\tif (GRAPHICS_VER(engine->i915) >= 11 ||\n\t    !(engine->flags & I915_ENGINE_HAS_RCS_REG_STATE))\n\t\treturn;\n\n\tif (GRAPHICS_VER(engine->i915) == 9) {\n\t\twa_bb_fn[0] = gen9_init_indirectctx_bb;\n\t\twa_bb_fn[1] = NULL;\n\t} else if (GRAPHICS_VER(engine->i915) == 8) {\n\t\twa_bb_fn[0] = gen8_init_indirectctx_bb;\n\t\twa_bb_fn[1] = NULL;\n\t}\n\n\terr = lrc_create_wa_ctx(engine);\n\tif (err) {\n\t\t \n\t\tdrm_err(&engine->i915->drm,\n\t\t\t\"Ignoring context switch w/a allocation error:%d\\n\",\n\t\t\terr);\n\t\treturn;\n\t}\n\n\tif (!engine->wa_ctx.vma)\n\t\treturn;\n\n\ti915_gem_ww_ctx_init(&ww, true);\nretry:\n\terr = i915_gem_object_lock(wa_ctx->vma->obj, &ww);\n\tif (!err)\n\t\terr = i915_ggtt_pin(wa_ctx->vma, &ww, 0, PIN_HIGH);\n\tif (err)\n\t\tgoto err;\n\n\tbatch = i915_gem_object_pin_map(wa_ctx->vma->obj, I915_MAP_WB);\n\tif (IS_ERR(batch)) {\n\t\terr = PTR_ERR(batch);\n\t\tgoto err_unpin;\n\t}\n\n\t \n\tbatch_ptr = batch;\n\tfor (i = 0; i < ARRAY_SIZE(wa_bb_fn); i++) {\n\t\twa_bb[i]->offset = batch_ptr - batch;\n\t\tif (GEM_DEBUG_WARN_ON(!IS_ALIGNED(wa_bb[i]->offset,\n\t\t\t\t\t\t  CACHELINE_BYTES))) {\n\t\t\terr = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\t\tif (wa_bb_fn[i])\n\t\t\tbatch_ptr = wa_bb_fn[i](engine, batch_ptr);\n\t\twa_bb[i]->size = batch_ptr - (batch + wa_bb[i]->offset);\n\t}\n\tGEM_BUG_ON(batch_ptr - batch > CTX_WA_BB_SIZE);\n\n\t__i915_gem_object_flush_map(wa_ctx->vma->obj, 0, batch_ptr - batch);\n\t__i915_gem_object_release_map(wa_ctx->vma->obj);\n\n\t \n\tif (!err)\n\t\terr = i915_inject_probe_error(engine->i915, -ENODEV);\n\nerr_unpin:\n\tif (err)\n\t\ti915_vma_unpin(wa_ctx->vma);\nerr:\n\tif (err == -EDEADLK) {\n\t\terr = i915_gem_ww_ctx_backoff(&ww);\n\t\tif (!err)\n\t\t\tgoto retry;\n\t}\n\ti915_gem_ww_ctx_fini(&ww);\n\n\tif (err) {\n\t\ti915_vma_put(engine->wa_ctx.vma);\n\n\t\t \n\t\tmemset(wa_ctx, 0, sizeof(*wa_ctx));\n\t}\n}\n\nstatic void st_runtime_underflow(struct intel_context_stats *stats, s32 dt)\n{\n#if IS_ENABLED(CONFIG_DRM_I915_SELFTEST)\n\tstats->runtime.num_underflow++;\n\tstats->runtime.max_underflow =\n\t\tmax_t(u32, stats->runtime.max_underflow, -dt);\n#endif\n}\n\nstatic u32 lrc_get_runtime(const struct intel_context *ce)\n{\n\t \n\treturn READ_ONCE(ce->lrc_reg_state[CTX_TIMESTAMP]);\n}\n\nvoid lrc_update_runtime(struct intel_context *ce)\n{\n\tstruct intel_context_stats *stats = &ce->stats;\n\tu32 old;\n\ts32 dt;\n\n\told = stats->runtime.last;\n\tstats->runtime.last = lrc_get_runtime(ce);\n\tdt = stats->runtime.last - old;\n\tif (!dt)\n\t\treturn;\n\n\tif (unlikely(dt < 0)) {\n\t\tCE_TRACE(ce, \"runtime underflow: last=%u, new=%u, delta=%d\\n\",\n\t\t\t old, stats->runtime.last, dt);\n\t\tst_runtime_underflow(stats, dt);\n\t\treturn;\n\t}\n\n\tewma_runtime_add(&stats->runtime.avg, dt);\n\tstats->runtime.total += dt;\n}\n\n#if IS_ENABLED(CONFIG_DRM_I915_SELFTEST)\n#include \"selftest_lrc.c\"\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}