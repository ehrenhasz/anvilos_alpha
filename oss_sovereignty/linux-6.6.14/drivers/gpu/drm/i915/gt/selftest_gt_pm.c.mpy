{
  "module_name": "selftest_gt_pm.c",
  "hash_id": "e804734aae04a30c760c36b63e4d4b0de768b82f6c5579e3f3652e8f02b028f0",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/i915/gt/selftest_gt_pm.c",
  "human_readable_source": "\n \n\n#include <linux/sort.h>\n\n#include \"intel_engine_regs.h\"\n#include \"intel_gt_clock_utils.h\"\n\n#include \"selftest_llc.h\"\n#include \"selftest_rc6.h\"\n#include \"selftest_rps.h\"\n\nstatic int cmp_u64(const void *A, const void *B)\n{\n\tconst u64 *a = A, *b = B;\n\n\tif (a < b)\n\t\treturn -1;\n\telse if (a > b)\n\t\treturn 1;\n\telse\n\t\treturn 0;\n}\n\nstatic int cmp_u32(const void *A, const void *B)\n{\n\tconst u32 *a = A, *b = B;\n\n\tif (a < b)\n\t\treturn -1;\n\telse if (a > b)\n\t\treturn 1;\n\telse\n\t\treturn 0;\n}\n\nstatic u32 read_timestamp(struct intel_engine_cs *engine)\n{\n\tstruct drm_i915_private *i915 = engine->i915;\n\n\t \n\tENGINE_READ_FW(engine, RING_TIMESTAMP);\n\n\tif (GRAPHICS_VER(i915) == 5 || IS_G4X(i915))\n\t\treturn ENGINE_READ_FW(engine, RING_TIMESTAMP_UDW);\n\telse\n\t\treturn ENGINE_READ_FW(engine, RING_TIMESTAMP);\n}\n\nstatic void measure_clocks(struct intel_engine_cs *engine,\n\t\t\t   u32 *out_cycles, ktime_t *out_dt)\n{\n\tktime_t dt[5];\n\tu32 cycles[5];\n\tint i;\n\n\tfor (i = 0; i < 5; i++) {\n\t\tlocal_irq_disable();\n\t\tcycles[i] = -read_timestamp(engine);\n\t\tdt[i] = ktime_get();\n\n\t\tudelay(1000);\n\n\t\tcycles[i] += read_timestamp(engine);\n\t\tdt[i] = ktime_sub(ktime_get(), dt[i]);\n\t\tlocal_irq_enable();\n\t}\n\n\t \n\tsort(cycles, 5, sizeof(*cycles), cmp_u32, NULL);\n\t*out_cycles = (cycles[1] + 2 * cycles[2] + cycles[3]) / 4;\n\n\tsort(dt, 5, sizeof(*dt), cmp_u64, NULL);\n\t*out_dt = div_u64(dt[1] + 2 * dt[2] + dt[3], 4);\n}\n\nstatic int live_gt_clocks(void *arg)\n{\n\tstruct intel_gt *gt = arg;\n\tstruct intel_engine_cs *engine;\n\tenum intel_engine_id id;\n\tint err = 0;\n\n\tif (!gt->clock_frequency) {  \n\t\tpr_info(\"CS_TIMESTAMP frequency unknown\\n\");\n\t\treturn 0;\n\t}\n\n\tif (GRAPHICS_VER(gt->i915) < 4)  \n\t\treturn 0;\n\n\tintel_gt_pm_get(gt);\n\tintel_uncore_forcewake_get(gt->uncore, FORCEWAKE_ALL);\n\n\tfor_each_engine(engine, gt, id) {\n\t\tu32 cycles;\n\t\tu32 expected;\n\t\tu64 time;\n\t\tu64 dt;\n\n\t\tif (GRAPHICS_VER(engine->i915) < 7 && engine->id != RCS0)\n\t\t\tcontinue;\n\n\t\tmeasure_clocks(engine, &cycles, &dt);\n\n\t\ttime = intel_gt_clock_interval_to_ns(engine->gt, cycles);\n\t\texpected = intel_gt_ns_to_clock_interval(engine->gt, dt);\n\n\t\tpr_info(\"%s: TIMESTAMP %d cycles [%lldns] in %lldns [%d cycles], using CS clock frequency of %uKHz\\n\",\n\t\t\tengine->name, cycles, time, dt, expected,\n\t\t\tengine->gt->clock_frequency / 1000);\n\n\t\tif (9 * time < 8 * dt || 8 * time > 9 * dt) {\n\t\t\tpr_err(\"%s: CS ticks did not match walltime!\\n\",\n\t\t\t       engine->name);\n\t\t\terr = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (9 * expected < 8 * cycles || 8 * expected > 9 * cycles) {\n\t\t\tpr_err(\"%s: walltime did not match CS ticks!\\n\",\n\t\t\t       engine->name);\n\t\t\terr = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tintel_uncore_forcewake_put(gt->uncore, FORCEWAKE_ALL);\n\tintel_gt_pm_put(gt);\n\n\treturn err;\n}\n\nstatic int live_gt_resume(void *arg)\n{\n\tstruct intel_gt *gt = arg;\n\tIGT_TIMEOUT(end_time);\n\tint err;\n\n\t \n\tdo {\n\t\tintel_gt_suspend_prepare(gt);\n\t\tintel_gt_suspend_late(gt);\n\n\t\tif (gt->rc6.enabled) {\n\t\t\tpr_err(\"rc6 still enabled after suspend!\\n\");\n\t\t\tintel_gt_set_wedged_on_init(gt);\n\t\t\terr = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\terr = intel_gt_resume(gt);\n\t\tif (err)\n\t\t\tbreak;\n\n\t\tif (gt->rc6.supported && !gt->rc6.enabled) {\n\t\t\tpr_err(\"rc6 not enabled upon resume!\\n\");\n\t\t\tintel_gt_set_wedged_on_init(gt);\n\t\t\terr = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\terr = st_llc_verify(&gt->llc);\n\t\tif (err) {\n\t\t\tpr_err(\"llc state not restored upon resume!\\n\");\n\t\t\tintel_gt_set_wedged_on_init(gt);\n\t\t\tbreak;\n\t\t}\n\t} while (!__igt_timeout(end_time, NULL));\n\n\treturn err;\n}\n\nint intel_gt_pm_live_selftests(struct drm_i915_private *i915)\n{\n\tstatic const struct i915_subtest tests[] = {\n\t\tSUBTEST(live_gt_clocks),\n\t\tSUBTEST(live_rc6_manual),\n\t\tSUBTEST(live_rps_clock_interval),\n\t\tSUBTEST(live_rps_control),\n\t\tSUBTEST(live_rps_frequency_cs),\n\t\tSUBTEST(live_rps_frequency_srm),\n\t\tSUBTEST(live_rps_power),\n\t\tSUBTEST(live_rps_interrupt),\n\t\tSUBTEST(live_rps_dynamic),\n\t\tSUBTEST(live_gt_resume),\n\t};\n\n\tif (intel_gt_is_wedged(to_gt(i915)))\n\t\treturn 0;\n\n\treturn intel_gt_live_subtests(tests, to_gt(i915));\n}\n\nint intel_gt_pm_late_selftests(struct drm_i915_private *i915)\n{\n\tstatic const struct i915_subtest tests[] = {\n\t\t \n\t\tSUBTEST(live_rc6_ctx_wa),\n\t};\n\n\tif (intel_gt_is_wedged(to_gt(i915)))\n\t\treturn 0;\n\n\treturn intel_gt_live_subtests(tests, to_gt(i915));\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}