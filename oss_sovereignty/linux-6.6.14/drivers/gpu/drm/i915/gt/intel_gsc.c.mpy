{
  "module_name": "intel_gsc.c",
  "hash_id": "28124625587404e55b697ce3eb3e9962310d384a68f5ec90a8d85de51c3714ae",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/i915/gt/intel_gsc.c",
  "human_readable_source": "\n \n\n#include <linux/irq.h>\n#include <linux/mei_aux.h>\n#include \"i915_drv.h\"\n#include \"i915_reg.h\"\n#include \"gem/i915_gem_lmem.h\"\n#include \"gem/i915_gem_region.h\"\n#include \"gt/intel_gsc.h\"\n#include \"gt/intel_gt.h\"\n\n#define GSC_BAR_LENGTH  0x00000FFC\n\nstatic void gsc_irq_mask(struct irq_data *d)\n{\n\t \n}\n\nstatic void gsc_irq_unmask(struct irq_data *d)\n{\n\t \n}\n\nstatic struct irq_chip gsc_irq_chip = {\n\t.name = \"gsc_irq_chip\",\n\t.irq_mask = gsc_irq_mask,\n\t.irq_unmask = gsc_irq_unmask,\n};\n\nstatic int gsc_irq_init(int irq)\n{\n\tirq_set_chip_and_handler_name(irq, &gsc_irq_chip,\n\t\t\t\t      handle_simple_irq, \"gsc_irq_handler\");\n\n\treturn irq_set_chip_data(irq, NULL);\n}\n\nstatic int\ngsc_ext_om_alloc(struct intel_gsc *gsc, struct intel_gsc_intf *intf, size_t size)\n{\n\tstruct intel_gt *gt = gsc_to_gt(gsc);\n\tstruct drm_i915_gem_object *obj;\n\tint err;\n\n\tobj = i915_gem_object_create_lmem(gt->i915, size,\n\t\t\t\t\t  I915_BO_ALLOC_CONTIGUOUS |\n\t\t\t\t\t  I915_BO_ALLOC_CPU_CLEAR);\n\tif (IS_ERR(obj)) {\n\t\tdrm_err(&gt->i915->drm, \"Failed to allocate gsc memory\\n\");\n\t\treturn PTR_ERR(obj);\n\t}\n\n\terr = i915_gem_object_pin_pages_unlocked(obj);\n\tif (err) {\n\t\tdrm_err(&gt->i915->drm, \"Failed to pin pages for gsc memory\\n\");\n\t\tgoto out_put;\n\t}\n\n\tintf->gem_obj = obj;\n\n\treturn 0;\n\nout_put:\n\ti915_gem_object_put(obj);\n\treturn err;\n}\n\nstatic void gsc_ext_om_destroy(struct intel_gsc_intf *intf)\n{\n\tstruct drm_i915_gem_object *obj = fetch_and_zero(&intf->gem_obj);\n\n\tif (!obj)\n\t\treturn;\n\n\tif (i915_gem_object_has_pinned_pages(obj))\n\t\ti915_gem_object_unpin_pages(obj);\n\n\ti915_gem_object_put(obj);\n}\n\nstruct gsc_def {\n\tconst char *name;\n\tunsigned long bar;\n\tsize_t bar_size;\n\tbool use_polling;\n\tbool slow_firmware;\n\tsize_t lmem_size;\n};\n\n \nstatic const struct gsc_def gsc_def_dg1[] = {\n\t{\n\t\t \n\t},\n\t{\n\t\t.name = \"mei-gscfi\",\n\t\t.bar = DG1_GSC_HECI2_BASE,\n\t\t.bar_size = GSC_BAR_LENGTH,\n\t}\n};\n\nstatic const struct gsc_def gsc_def_xehpsdv[] = {\n\t{\n\t\t \n\t},\n\t{\n\t\t.name = \"mei-gscfi\",\n\t\t.bar = DG1_GSC_HECI2_BASE,\n\t\t.bar_size = GSC_BAR_LENGTH,\n\t\t.use_polling = true,\n\t\t.slow_firmware = true,\n\t}\n};\n\nstatic const struct gsc_def gsc_def_dg2[] = {\n\t{\n\t\t.name = \"mei-gsc\",\n\t\t.bar = DG2_GSC_HECI1_BASE,\n\t\t.bar_size = GSC_BAR_LENGTH,\n\t\t.lmem_size = SZ_4M,\n\t},\n\t{\n\t\t.name = \"mei-gscfi\",\n\t\t.bar = DG2_GSC_HECI2_BASE,\n\t\t.bar_size = GSC_BAR_LENGTH,\n\t}\n};\n\nstatic void gsc_release_dev(struct device *dev)\n{\n\tstruct auxiliary_device *aux_dev = to_auxiliary_dev(dev);\n\tstruct mei_aux_device *adev = auxiliary_dev_to_mei_aux_dev(aux_dev);\n\n\tkfree(adev);\n}\n\nstatic void gsc_destroy_one(struct drm_i915_private *i915,\n\t\t\t    struct intel_gsc *gsc, unsigned int intf_id)\n{\n\tstruct intel_gsc_intf *intf = &gsc->intf[intf_id];\n\n\tif (intf->adev) {\n\t\tstruct auxiliary_device *aux_dev = &intf->adev->aux_dev;\n\n\t\tif (intf_id == 0)\n\t\t\tintel_huc_unregister_gsc_notifier(&gsc_to_gt(gsc)->uc.huc,\n\t\t\t\t\t\t\t  aux_dev->dev.bus);\n\n\t\tauxiliary_device_delete(aux_dev);\n\t\tauxiliary_device_uninit(aux_dev);\n\t\tintf->adev = NULL;\n\t}\n\n\tif (intf->irq >= 0)\n\t\tirq_free_desc(intf->irq);\n\tintf->irq = -1;\n\n\tgsc_ext_om_destroy(intf);\n}\n\nstatic void gsc_init_one(struct drm_i915_private *i915, struct intel_gsc *gsc,\n\t\t\t unsigned int intf_id)\n{\n\tstruct pci_dev *pdev = to_pci_dev(i915->drm.dev);\n\tstruct mei_aux_device *adev;\n\tstruct auxiliary_device *aux_dev;\n\tconst struct gsc_def *def;\n\tstruct intel_gsc_intf *intf = &gsc->intf[intf_id];\n\tint ret;\n\n\tintf->irq = -1;\n\tintf->id = intf_id;\n\n\t \n\tif (gsc_to_gt(gsc)->info.id != 0) {\n\t\tdrm_dbg(&i915->drm, \"Not initializing gsc for remote tiles\\n\");\n\t\treturn;\n\t}\n\n\tif (intf_id == 0 && !HAS_HECI_PXP(i915))\n\t\treturn;\n\n\tif (IS_DG1(i915)) {\n\t\tdef = &gsc_def_dg1[intf_id];\n\t} else if (IS_XEHPSDV(i915)) {\n\t\tdef = &gsc_def_xehpsdv[intf_id];\n\t} else if (IS_DG2(i915)) {\n\t\tdef = &gsc_def_dg2[intf_id];\n\t} else {\n\t\tdrm_warn_once(&i915->drm, \"Unknown platform\\n\");\n\t\treturn;\n\t}\n\n\tif (!def->name) {\n\t\tdrm_warn_once(&i915->drm, \"HECI%d is not implemented!\\n\", intf_id + 1);\n\t\treturn;\n\t}\n\n\t \n\tif (def->use_polling)\n\t\tgoto add_device;\n\n\tintf->irq = irq_alloc_desc(0);\n\tif (intf->irq < 0) {\n\t\tdrm_err(&i915->drm, \"gsc irq error %d\\n\", intf->irq);\n\t\tgoto fail;\n\t}\n\n\tret = gsc_irq_init(intf->irq);\n\tif (ret < 0) {\n\t\tdrm_err(&i915->drm, \"gsc irq init failed %d\\n\", ret);\n\t\tgoto fail;\n\t}\n\nadd_device:\n\tadev = kzalloc(sizeof(*adev), GFP_KERNEL);\n\tif (!adev)\n\t\tgoto fail;\n\n\tif (def->lmem_size) {\n\t\tdrm_dbg(&i915->drm, \"setting up GSC lmem\\n\");\n\n\t\tif (gsc_ext_om_alloc(gsc, intf, def->lmem_size)) {\n\t\t\tdrm_err(&i915->drm, \"setting up gsc extended operational memory failed\\n\");\n\t\t\tkfree(adev);\n\t\t\tgoto fail;\n\t\t}\n\n\t\tadev->ext_op_mem.start = i915_gem_object_get_dma_address(intf->gem_obj, 0);\n\t\tadev->ext_op_mem.end = adev->ext_op_mem.start + def->lmem_size;\n\t}\n\n\tadev->irq = intf->irq;\n\tadev->bar.parent = &pdev->resource[0];\n\tadev->bar.start = def->bar + pdev->resource[0].start;\n\tadev->bar.end = adev->bar.start + def->bar_size - 1;\n\tadev->bar.flags = IORESOURCE_MEM;\n\tadev->bar.desc = IORES_DESC_NONE;\n\tadev->slow_firmware = def->slow_firmware;\n\n\taux_dev = &adev->aux_dev;\n\taux_dev->name = def->name;\n\taux_dev->id = (pci_domain_nr(pdev->bus) << 16) |\n\t\t      PCI_DEVID(pdev->bus->number, pdev->devfn);\n\taux_dev->dev.parent = &pdev->dev;\n\taux_dev->dev.release = gsc_release_dev;\n\n\tret = auxiliary_device_init(aux_dev);\n\tif (ret < 0) {\n\t\tdrm_err(&i915->drm, \"gsc aux init failed %d\\n\", ret);\n\t\tkfree(adev);\n\t\tgoto fail;\n\t}\n\n\tintf->adev = adev;  \n\n\tif (intf_id == 0)\n\t\tintel_huc_register_gsc_notifier(&gsc_to_gt(gsc)->uc.huc,\n\t\t\t\t\t\taux_dev->dev.bus);\n\n\tret = auxiliary_device_add(aux_dev);\n\tif (ret < 0) {\n\t\tdrm_err(&i915->drm, \"gsc aux add failed %d\\n\", ret);\n\t\tif (intf_id == 0)\n\t\t\tintel_huc_unregister_gsc_notifier(&gsc_to_gt(gsc)->uc.huc,\n\t\t\t\t\t\t\t  aux_dev->dev.bus);\n\t\tintf->adev = NULL;\n\n\t\t \n\t\tauxiliary_device_uninit(aux_dev);\n\t\tgoto fail;\n\t}\n\n\treturn;\nfail:\n\tgsc_destroy_one(i915, gsc, intf->id);\n}\n\nstatic void gsc_irq_handler(struct intel_gt *gt, unsigned int intf_id)\n{\n\tint ret;\n\n\tif (intf_id >= INTEL_GSC_NUM_INTERFACES) {\n\t\tdrm_warn_once(&gt->i915->drm, \"GSC irq: intf_id %d is out of range\", intf_id);\n\t\treturn;\n\t}\n\n\tif (!HAS_HECI_GSC(gt->i915)) {\n\t\tdrm_warn_once(&gt->i915->drm, \"GSC irq: not supported\");\n\t\treturn;\n\t}\n\n\tif (gt->gsc.intf[intf_id].irq < 0)\n\t\treturn;\n\n\tret = generic_handle_irq(gt->gsc.intf[intf_id].irq);\n\tif (ret)\n\t\tdrm_err_ratelimited(&gt->i915->drm, \"error handling GSC irq: %d\\n\", ret);\n}\n\nvoid intel_gsc_irq_handler(struct intel_gt *gt, u32 iir)\n{\n\tif (iir & GSC_IRQ_INTF(0))\n\t\tgsc_irq_handler(gt, 0);\n\tif (iir & GSC_IRQ_INTF(1))\n\t\tgsc_irq_handler(gt, 1);\n}\n\nvoid intel_gsc_init(struct intel_gsc *gsc, struct drm_i915_private *i915)\n{\n\tunsigned int i;\n\n\tif (!HAS_HECI_GSC(i915))\n\t\treturn;\n\n\tfor (i = 0; i < INTEL_GSC_NUM_INTERFACES; i++)\n\t\tgsc_init_one(i915, gsc, i);\n}\n\nvoid intel_gsc_fini(struct intel_gsc *gsc)\n{\n\tstruct intel_gt *gt = gsc_to_gt(gsc);\n\tunsigned int i;\n\n\tif (!HAS_HECI_GSC(gt->i915))\n\t\treturn;\n\n\tfor (i = 0; i < INTEL_GSC_NUM_INTERFACES; i++)\n\t\tgsc_destroy_one(gt->i915, gsc, i);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}