{
  "module_name": "selftest_hangcheck.c",
  "hash_id": "6a570189ad6193b8a877c0195c7e8370a970e1ff9e81a984064bb640ae524d14",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/i915/gt/selftest_hangcheck.c",
  "human_readable_source": "\n \n\n#include <linux/kthread.h>\n\n#include \"gem/i915_gem_context.h\"\n#include \"gem/i915_gem_internal.h\"\n\n#include \"i915_gem_evict.h\"\n#include \"intel_gt.h\"\n#include \"intel_engine_heartbeat.h\"\n#include \"intel_engine_pm.h\"\n#include \"selftest_engine_heartbeat.h\"\n\n#include \"i915_selftest.h\"\n#include \"selftests/i915_random.h\"\n#include \"selftests/igt_flush_test.h\"\n#include \"selftests/igt_reset.h\"\n#include \"selftests/igt_atomic.h\"\n#include \"selftests/igt_spinner.h\"\n#include \"selftests/intel_scheduler_helpers.h\"\n\n#include \"selftests/mock_drm.h\"\n\n#include \"gem/selftests/mock_context.h\"\n#include \"gem/selftests/igt_gem_utils.h\"\n\n#define IGT_IDLE_TIMEOUT 50  \n\nstruct hang {\n\tstruct intel_gt *gt;\n\tstruct drm_i915_gem_object *hws;\n\tstruct drm_i915_gem_object *obj;\n\tstruct i915_gem_context *ctx;\n\tu32 *seqno;\n\tu32 *batch;\n};\n\nstatic int hang_init(struct hang *h, struct intel_gt *gt)\n{\n\tvoid *vaddr;\n\tint err;\n\n\tmemset(h, 0, sizeof(*h));\n\th->gt = gt;\n\n\th->ctx = kernel_context(gt->i915, NULL);\n\tif (IS_ERR(h->ctx))\n\t\treturn PTR_ERR(h->ctx);\n\n\tGEM_BUG_ON(i915_gem_context_is_bannable(h->ctx));\n\n\th->hws = i915_gem_object_create_internal(gt->i915, PAGE_SIZE);\n\tif (IS_ERR(h->hws)) {\n\t\terr = PTR_ERR(h->hws);\n\t\tgoto err_ctx;\n\t}\n\n\th->obj = i915_gem_object_create_internal(gt->i915, PAGE_SIZE);\n\tif (IS_ERR(h->obj)) {\n\t\terr = PTR_ERR(h->obj);\n\t\tgoto err_hws;\n\t}\n\n\ti915_gem_object_set_cache_coherency(h->hws, I915_CACHE_LLC);\n\tvaddr = i915_gem_object_pin_map_unlocked(h->hws, I915_MAP_WB);\n\tif (IS_ERR(vaddr)) {\n\t\terr = PTR_ERR(vaddr);\n\t\tgoto err_obj;\n\t}\n\th->seqno = memset(vaddr, 0xff, PAGE_SIZE);\n\n\tvaddr = i915_gem_object_pin_map_unlocked(h->obj,\n\t\t\t\t\t\t intel_gt_coherent_map_type(gt, h->obj, false));\n\tif (IS_ERR(vaddr)) {\n\t\terr = PTR_ERR(vaddr);\n\t\tgoto err_unpin_hws;\n\t}\n\th->batch = vaddr;\n\n\treturn 0;\n\nerr_unpin_hws:\n\ti915_gem_object_unpin_map(h->hws);\nerr_obj:\n\ti915_gem_object_put(h->obj);\nerr_hws:\n\ti915_gem_object_put(h->hws);\nerr_ctx:\n\tkernel_context_close(h->ctx);\n\treturn err;\n}\n\nstatic u64 hws_address(const struct i915_vma *hws,\n\t\t       const struct i915_request *rq)\n{\n\treturn i915_vma_offset(hws) +\n\t       offset_in_page(sizeof(u32) * rq->fence.context);\n}\n\nstatic struct i915_request *\nhang_create_request(struct hang *h, struct intel_engine_cs *engine)\n{\n\tstruct intel_gt *gt = h->gt;\n\tstruct i915_address_space *vm = i915_gem_context_get_eb_vm(h->ctx);\n\tstruct drm_i915_gem_object *obj;\n\tstruct i915_request *rq = NULL;\n\tstruct i915_vma *hws, *vma;\n\tunsigned int flags;\n\tvoid *vaddr;\n\tu32 *batch;\n\tint err;\n\n\tobj = i915_gem_object_create_internal(gt->i915, PAGE_SIZE);\n\tif (IS_ERR(obj)) {\n\t\ti915_vm_put(vm);\n\t\treturn ERR_CAST(obj);\n\t}\n\n\tvaddr = i915_gem_object_pin_map_unlocked(obj, intel_gt_coherent_map_type(gt, obj, false));\n\tif (IS_ERR(vaddr)) {\n\t\ti915_gem_object_put(obj);\n\t\ti915_vm_put(vm);\n\t\treturn ERR_CAST(vaddr);\n\t}\n\n\ti915_gem_object_unpin_map(h->obj);\n\ti915_gem_object_put(h->obj);\n\n\th->obj = obj;\n\th->batch = vaddr;\n\n\tvma = i915_vma_instance(h->obj, vm, NULL);\n\tif (IS_ERR(vma)) {\n\t\ti915_vm_put(vm);\n\t\treturn ERR_CAST(vma);\n\t}\n\n\thws = i915_vma_instance(h->hws, vm, NULL);\n\tif (IS_ERR(hws)) {\n\t\ti915_vm_put(vm);\n\t\treturn ERR_CAST(hws);\n\t}\n\n\terr = i915_vma_pin(vma, 0, 0, PIN_USER);\n\tif (err) {\n\t\ti915_vm_put(vm);\n\t\treturn ERR_PTR(err);\n\t}\n\n\terr = i915_vma_pin(hws, 0, 0, PIN_USER);\n\tif (err)\n\t\tgoto unpin_vma;\n\n\trq = igt_request_alloc(h->ctx, engine);\n\tif (IS_ERR(rq)) {\n\t\terr = PTR_ERR(rq);\n\t\tgoto unpin_hws;\n\t}\n\n\terr = igt_vma_move_to_active_unlocked(vma, rq, 0);\n\tif (err)\n\t\tgoto cancel_rq;\n\n\terr = igt_vma_move_to_active_unlocked(hws, rq, 0);\n\tif (err)\n\t\tgoto cancel_rq;\n\n\tbatch = h->batch;\n\tif (GRAPHICS_VER(gt->i915) >= 8) {\n\t\t*batch++ = MI_STORE_DWORD_IMM_GEN4;\n\t\t*batch++ = lower_32_bits(hws_address(hws, rq));\n\t\t*batch++ = upper_32_bits(hws_address(hws, rq));\n\t\t*batch++ = rq->fence.seqno;\n\t\t*batch++ = MI_NOOP;\n\n\t\tmemset(batch, 0, 1024);\n\t\tbatch += 1024 / sizeof(*batch);\n\n\t\t*batch++ = MI_NOOP;\n\t\t*batch++ = MI_BATCH_BUFFER_START | 1 << 8 | 1;\n\t\t*batch++ = lower_32_bits(i915_vma_offset(vma));\n\t\t*batch++ = upper_32_bits(i915_vma_offset(vma));\n\t} else if (GRAPHICS_VER(gt->i915) >= 6) {\n\t\t*batch++ = MI_STORE_DWORD_IMM_GEN4;\n\t\t*batch++ = 0;\n\t\t*batch++ = lower_32_bits(hws_address(hws, rq));\n\t\t*batch++ = rq->fence.seqno;\n\t\t*batch++ = MI_NOOP;\n\n\t\tmemset(batch, 0, 1024);\n\t\tbatch += 1024 / sizeof(*batch);\n\n\t\t*batch++ = MI_NOOP;\n\t\t*batch++ = MI_BATCH_BUFFER_START | 1 << 8;\n\t\t*batch++ = lower_32_bits(i915_vma_offset(vma));\n\t} else if (GRAPHICS_VER(gt->i915) >= 4) {\n\t\t*batch++ = MI_STORE_DWORD_IMM_GEN4 | MI_USE_GGTT;\n\t\t*batch++ = 0;\n\t\t*batch++ = lower_32_bits(hws_address(hws, rq));\n\t\t*batch++ = rq->fence.seqno;\n\t\t*batch++ = MI_NOOP;\n\n\t\tmemset(batch, 0, 1024);\n\t\tbatch += 1024 / sizeof(*batch);\n\n\t\t*batch++ = MI_NOOP;\n\t\t*batch++ = MI_BATCH_BUFFER_START | 2 << 6;\n\t\t*batch++ = lower_32_bits(i915_vma_offset(vma));\n\t} else {\n\t\t*batch++ = MI_STORE_DWORD_IMM | MI_MEM_VIRTUAL;\n\t\t*batch++ = lower_32_bits(hws_address(hws, rq));\n\t\t*batch++ = rq->fence.seqno;\n\t\t*batch++ = MI_NOOP;\n\n\t\tmemset(batch, 0, 1024);\n\t\tbatch += 1024 / sizeof(*batch);\n\n\t\t*batch++ = MI_NOOP;\n\t\t*batch++ = MI_BATCH_BUFFER_START | 2 << 6;\n\t\t*batch++ = lower_32_bits(i915_vma_offset(vma));\n\t}\n\t*batch++ = MI_BATCH_BUFFER_END;  \n\tintel_gt_chipset_flush(engine->gt);\n\n\tif (rq->engine->emit_init_breadcrumb) {\n\t\terr = rq->engine->emit_init_breadcrumb(rq);\n\t\tif (err)\n\t\t\tgoto cancel_rq;\n\t}\n\n\tflags = 0;\n\tif (GRAPHICS_VER(gt->i915) <= 5)\n\t\tflags |= I915_DISPATCH_SECURE;\n\n\terr = rq->engine->emit_bb_start(rq, i915_vma_offset(vma), PAGE_SIZE, flags);\n\ncancel_rq:\n\tif (err) {\n\t\ti915_request_set_error_once(rq, err);\n\t\ti915_request_add(rq);\n\t}\nunpin_hws:\n\ti915_vma_unpin(hws);\nunpin_vma:\n\ti915_vma_unpin(vma);\n\ti915_vm_put(vm);\n\treturn err ? ERR_PTR(err) : rq;\n}\n\nstatic u32 hws_seqno(const struct hang *h, const struct i915_request *rq)\n{\n\treturn READ_ONCE(h->seqno[rq->fence.context % (PAGE_SIZE/sizeof(u32))]);\n}\n\nstatic void hang_fini(struct hang *h)\n{\n\t*h->batch = MI_BATCH_BUFFER_END;\n\tintel_gt_chipset_flush(h->gt);\n\n\ti915_gem_object_unpin_map(h->obj);\n\ti915_gem_object_put(h->obj);\n\n\ti915_gem_object_unpin_map(h->hws);\n\ti915_gem_object_put(h->hws);\n\n\tkernel_context_close(h->ctx);\n\n\tigt_flush_test(h->gt->i915);\n}\n\nstatic bool wait_until_running(struct hang *h, struct i915_request *rq)\n{\n\treturn !(wait_for_us(i915_seqno_passed(hws_seqno(h, rq),\n\t\t\t\t\t       rq->fence.seqno),\n\t\t\t     10) &&\n\t\t wait_for(i915_seqno_passed(hws_seqno(h, rq),\n\t\t\t\t\t    rq->fence.seqno),\n\t\t\t  1000));\n}\n\nstatic int igt_hang_sanitycheck(void *arg)\n{\n\tstruct intel_gt *gt = arg;\n\tstruct i915_request *rq;\n\tstruct intel_engine_cs *engine;\n\tenum intel_engine_id id;\n\tstruct hang h;\n\tint err;\n\n\t \n\n\terr = hang_init(&h, gt);\n\tif (err)\n\t\treturn err;\n\n\tfor_each_engine(engine, gt, id) {\n\t\tstruct intel_wedge_me w;\n\t\tlong timeout;\n\n\t\tif (!intel_engine_can_store_dword(engine))\n\t\t\tcontinue;\n\n\t\trq = hang_create_request(&h, engine);\n\t\tif (IS_ERR(rq)) {\n\t\t\terr = PTR_ERR(rq);\n\t\t\tpr_err(\"Failed to create request for %s, err=%d\\n\",\n\t\t\t       engine->name, err);\n\t\t\tgoto fini;\n\t\t}\n\n\t\ti915_request_get(rq);\n\n\t\t*h.batch = MI_BATCH_BUFFER_END;\n\t\tintel_gt_chipset_flush(engine->gt);\n\n\t\ti915_request_add(rq);\n\n\t\ttimeout = 0;\n\t\tintel_wedge_on_timeout(&w, gt, HZ / 10  )\n\t\t\ttimeout = i915_request_wait(rq, 0,\n\t\t\t\t\t\t    MAX_SCHEDULE_TIMEOUT);\n\t\tif (intel_gt_is_wedged(gt))\n\t\t\ttimeout = -EIO;\n\n\t\ti915_request_put(rq);\n\n\t\tif (timeout < 0) {\n\t\t\terr = timeout;\n\t\t\tpr_err(\"Wait for request failed on %s, err=%d\\n\",\n\t\t\t       engine->name, err);\n\t\t\tgoto fini;\n\t\t}\n\t}\n\nfini:\n\thang_fini(&h);\n\treturn err;\n}\n\nstatic bool wait_for_idle(struct intel_engine_cs *engine)\n{\n\treturn wait_for(intel_engine_is_idle(engine), IGT_IDLE_TIMEOUT) == 0;\n}\n\nstatic int igt_reset_nop(void *arg)\n{\n\tstruct intel_gt *gt = arg;\n\tstruct i915_gpu_error *global = &gt->i915->gpu_error;\n\tstruct intel_engine_cs *engine;\n\tunsigned int reset_count, count;\n\tenum intel_engine_id id;\n\tIGT_TIMEOUT(end_time);\n\tint err = 0;\n\n\t \n\n\treset_count = i915_reset_count(global);\n\tcount = 0;\n\tdo {\n\t\tfor_each_engine(engine, gt, id) {\n\t\t\tstruct intel_context *ce;\n\t\t\tint i;\n\n\t\t\tce = intel_context_create(engine);\n\t\t\tif (IS_ERR(ce)) {\n\t\t\t\terr = PTR_ERR(ce);\n\t\t\t\tpr_err(\"[%s] Create context failed: %d!\\n\", engine->name, err);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tfor (i = 0; i < 16; i++) {\n\t\t\t\tstruct i915_request *rq;\n\n\t\t\t\trq = intel_context_create_request(ce);\n\t\t\t\tif (IS_ERR(rq)) {\n\t\t\t\t\terr = PTR_ERR(rq);\n\t\t\t\t\tpr_err(\"[%s] Create request failed: %d!\\n\",\n\t\t\t\t\t       engine->name, err);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\ti915_request_add(rq);\n\t\t\t}\n\n\t\t\tintel_context_put(ce);\n\t\t}\n\n\t\tigt_global_reset_lock(gt);\n\t\tintel_gt_reset(gt, ALL_ENGINES, NULL);\n\t\tigt_global_reset_unlock(gt);\n\n\t\tif (intel_gt_is_wedged(gt)) {\n\t\t\tpr_err(\"[%s] GT is wedged!\\n\", engine->name);\n\t\t\terr = -EIO;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (i915_reset_count(global) != reset_count + ++count) {\n\t\t\tpr_err(\"[%s] Reset not recorded: %d vs %d + %d!\\n\",\n\t\t\t       engine->name, i915_reset_count(global), reset_count, count);\n\t\t\terr = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\terr = igt_flush_test(gt->i915);\n\t\tif (err) {\n\t\t\tpr_err(\"[%s] Flush failed: %d!\\n\", engine->name, err);\n\t\t\tbreak;\n\t\t}\n\t} while (time_before(jiffies, end_time));\n\tpr_info(\"%s: %d resets\\n\", __func__, count);\n\n\tif (igt_flush_test(gt->i915)) {\n\t\tpr_err(\"Post flush failed: %d!\\n\", err);\n\t\terr = -EIO;\n\t}\n\n\treturn err;\n}\n\nstatic int igt_reset_nop_engine(void *arg)\n{\n\tstruct intel_gt *gt = arg;\n\tstruct i915_gpu_error *global = &gt->i915->gpu_error;\n\tstruct intel_engine_cs *engine;\n\tenum intel_engine_id id;\n\n\t \n\n\tif (!intel_has_reset_engine(gt))\n\t\treturn 0;\n\n\tfor_each_engine(engine, gt, id) {\n\t\tunsigned int reset_count, reset_engine_count, count;\n\t\tstruct intel_context *ce;\n\t\tIGT_TIMEOUT(end_time);\n\t\tint err;\n\n\t\tif (intel_engine_uses_guc(engine)) {\n\t\t\t \n\t\t\tcontinue;\n\t\t}\n\n\t\tce = intel_context_create(engine);\n\t\tif (IS_ERR(ce)) {\n\t\t\tpr_err(\"[%s] Create context failed: %pe!\\n\", engine->name, ce);\n\t\t\treturn PTR_ERR(ce);\n\t\t}\n\n\t\treset_count = i915_reset_count(global);\n\t\treset_engine_count = i915_reset_engine_count(global, engine);\n\t\tcount = 0;\n\n\t\tst_engine_heartbeat_disable(engine);\n\t\tGEM_BUG_ON(test_and_set_bit(I915_RESET_ENGINE + id,\n\t\t\t\t\t    &gt->reset.flags));\n\t\tdo {\n\t\t\tint i;\n\n\t\t\tif (!wait_for_idle(engine)) {\n\t\t\t\tpr_err(\"%s failed to idle before reset\\n\",\n\t\t\t\t       engine->name);\n\t\t\t\terr = -EIO;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tfor (i = 0; i < 16; i++) {\n\t\t\t\tstruct i915_request *rq;\n\n\t\t\t\trq = intel_context_create_request(ce);\n\t\t\t\tif (IS_ERR(rq)) {\n\t\t\t\t\tstruct drm_printer p =\n\t\t\t\t\t\tdrm_info_printer(gt->i915->drm.dev);\n\t\t\t\t\tintel_engine_dump(engine, &p,\n\t\t\t\t\t\t\t  \"%s(%s): failed to submit request\\n\",\n\t\t\t\t\t\t\t  __func__,\n\t\t\t\t\t\t\t  engine->name);\n\n\t\t\t\t\tGEM_TRACE(\"%s(%s): failed to submit request\\n\",\n\t\t\t\t\t\t  __func__,\n\t\t\t\t\t\t  engine->name);\n\t\t\t\t\tGEM_TRACE_DUMP();\n\n\t\t\t\t\tintel_gt_set_wedged(gt);\n\n\t\t\t\t\terr = PTR_ERR(rq);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\ti915_request_add(rq);\n\t\t\t}\n\t\t\terr = intel_engine_reset(engine, NULL);\n\t\t\tif (err) {\n\t\t\t\tpr_err(\"intel_engine_reset(%s) failed, err:%d\\n\",\n\t\t\t\t       engine->name, err);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (i915_reset_count(global) != reset_count) {\n\t\t\t\tpr_err(\"Full GPU reset recorded! (engine reset expected)\\n\");\n\t\t\t\terr = -EINVAL;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (i915_reset_engine_count(global, engine) !=\n\t\t\t    reset_engine_count + ++count) {\n\t\t\t\tpr_err(\"%s engine reset not recorded!\\n\",\n\t\t\t\t       engine->name);\n\t\t\t\terr = -EINVAL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} while (time_before(jiffies, end_time));\n\t\tclear_and_wake_up_bit(I915_RESET_ENGINE + id, &gt->reset.flags);\n\t\tst_engine_heartbeat_enable(engine);\n\n\t\tpr_info(\"%s(%s): %d resets\\n\", __func__, engine->name, count);\n\n\t\tintel_context_put(ce);\n\t\tif (igt_flush_test(gt->i915))\n\t\t\terr = -EIO;\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\nstatic void force_reset_timeout(struct intel_engine_cs *engine)\n{\n\tengine->reset_timeout.probability = 999;\n\tatomic_set(&engine->reset_timeout.times, -1);\n}\n\nstatic void cancel_reset_timeout(struct intel_engine_cs *engine)\n{\n\tmemset(&engine->reset_timeout, 0, sizeof(engine->reset_timeout));\n}\n\nstatic int igt_reset_fail_engine(void *arg)\n{\n\tstruct intel_gt *gt = arg;\n\tstruct intel_engine_cs *engine;\n\tenum intel_engine_id id;\n\n\t \n\n\tif (!intel_has_reset_engine(gt))\n\t\treturn 0;\n\n\tfor_each_engine(engine, gt, id) {\n\t\tunsigned int count;\n\t\tstruct intel_context *ce;\n\t\tIGT_TIMEOUT(end_time);\n\t\tint err;\n\n\t\t \n\t\tif (intel_engine_uses_guc(engine))\n\t\t\tcontinue;\n\n\t\tce = intel_context_create(engine);\n\t\tif (IS_ERR(ce)) {\n\t\t\tpr_err(\"[%s] Create context failed: %pe!\\n\", engine->name, ce);\n\t\t\treturn PTR_ERR(ce);\n\t\t}\n\n\t\tst_engine_heartbeat_disable(engine);\n\t\tGEM_BUG_ON(test_and_set_bit(I915_RESET_ENGINE + id,\n\t\t\t\t\t    &gt->reset.flags));\n\n\t\tforce_reset_timeout(engine);\n\t\terr = intel_engine_reset(engine, NULL);\n\t\tcancel_reset_timeout(engine);\n\t\tif (err == 0)  \n\t\t\tgoto skip;\n\n\t\tcount = 0;\n\t\tdo {\n\t\t\tstruct i915_request *last = NULL;\n\t\t\tint i;\n\n\t\t\tif (!wait_for_idle(engine)) {\n\t\t\t\tpr_err(\"%s failed to idle before reset\\n\",\n\t\t\t\t       engine->name);\n\t\t\t\terr = -EIO;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tfor (i = 0; i < count % 15; i++) {\n\t\t\t\tstruct i915_request *rq;\n\n\t\t\t\trq = intel_context_create_request(ce);\n\t\t\t\tif (IS_ERR(rq)) {\n\t\t\t\t\tstruct drm_printer p =\n\t\t\t\t\t\tdrm_info_printer(gt->i915->drm.dev);\n\t\t\t\t\tintel_engine_dump(engine, &p,\n\t\t\t\t\t\t\t  \"%s(%s): failed to submit request\\n\",\n\t\t\t\t\t\t\t  __func__,\n\t\t\t\t\t\t\t  engine->name);\n\n\t\t\t\t\tGEM_TRACE(\"%s(%s): failed to submit request\\n\",\n\t\t\t\t\t\t  __func__,\n\t\t\t\t\t\t  engine->name);\n\t\t\t\t\tGEM_TRACE_DUMP();\n\n\t\t\t\t\tintel_gt_set_wedged(gt);\n\t\t\t\t\tif (last)\n\t\t\t\t\t\ti915_request_put(last);\n\n\t\t\t\t\terr = PTR_ERR(rq);\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\n\t\t\t\tif (last)\n\t\t\t\t\ti915_request_put(last);\n\t\t\t\tlast = i915_request_get(rq);\n\t\t\t\ti915_request_add(rq);\n\t\t\t}\n\n\t\t\tif (count & 1) {\n\t\t\t\terr = intel_engine_reset(engine, NULL);\n\t\t\t\tif (err) {\n\t\t\t\t\tGEM_TRACE_ERR(\"intel_engine_reset(%s) failed, err:%d\\n\",\n\t\t\t\t\t\t      engine->name, err);\n\t\t\t\t\tGEM_TRACE_DUMP();\n\t\t\t\t\ti915_request_put(last);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tforce_reset_timeout(engine);\n\t\t\t\terr = intel_engine_reset(engine, NULL);\n\t\t\t\tcancel_reset_timeout(engine);\n\t\t\t\tif (err != -ETIMEDOUT) {\n\t\t\t\t\tpr_err(\"intel_engine_reset(%s) did not fail, err:%d\\n\",\n\t\t\t\t\t       engine->name, err);\n\t\t\t\t\ti915_request_put(last);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\terr = 0;\n\t\t\tif (last) {\n\t\t\t\tif (i915_request_wait(last, 0, HZ / 2) < 0) {\n\t\t\t\t\tstruct drm_printer p =\n\t\t\t\t\t\tdrm_info_printer(gt->i915->drm.dev);\n\n\t\t\t\t\tintel_engine_dump(engine, &p,\n\t\t\t\t\t\t\t  \"%s(%s): failed to complete request\\n\",\n\t\t\t\t\t\t\t  __func__,\n\t\t\t\t\t\t\t  engine->name);\n\n\t\t\t\t\tGEM_TRACE(\"%s(%s): failed to complete request\\n\",\n\t\t\t\t\t\t  __func__,\n\t\t\t\t\t\t  engine->name);\n\t\t\t\t\tGEM_TRACE_DUMP();\n\n\t\t\t\t\terr = -EIO;\n\t\t\t\t}\n\t\t\t\ti915_request_put(last);\n\t\t\t}\n\t\t\tcount++;\n\t\t} while (err == 0 && time_before(jiffies, end_time));\nout:\n\t\tpr_info(\"%s(%s): %d resets\\n\", __func__, engine->name, count);\nskip:\n\t\tclear_and_wake_up_bit(I915_RESET_ENGINE + id, &gt->reset.flags);\n\t\tst_engine_heartbeat_enable(engine);\n\t\tintel_context_put(ce);\n\n\t\tif (igt_flush_test(gt->i915))\n\t\t\terr = -EIO;\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\nstatic int __igt_reset_engine(struct intel_gt *gt, bool active)\n{\n\tstruct i915_gpu_error *global = &gt->i915->gpu_error;\n\tstruct intel_engine_cs *engine;\n\tenum intel_engine_id id;\n\tstruct hang h;\n\tint err = 0;\n\n\t \n\n\tif (!intel_has_reset_engine(gt))\n\t\treturn 0;\n\n\tif (active) {\n\t\terr = hang_init(&h, gt);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tfor_each_engine(engine, gt, id) {\n\t\tunsigned int reset_count, reset_engine_count;\n\t\tunsigned long count;\n\t\tbool using_guc = intel_engine_uses_guc(engine);\n\t\tIGT_TIMEOUT(end_time);\n\n\t\tif (using_guc && !active)\n\t\t\tcontinue;\n\n\t\tif (active && !intel_engine_can_store_dword(engine))\n\t\t\tcontinue;\n\n\t\tif (!wait_for_idle(engine)) {\n\t\t\tpr_err(\"%s failed to idle before reset\\n\",\n\t\t\t       engine->name);\n\t\t\terr = -EIO;\n\t\t\tbreak;\n\t\t}\n\n\t\treset_count = i915_reset_count(global);\n\t\treset_engine_count = i915_reset_engine_count(global, engine);\n\n\t\tst_engine_heartbeat_disable(engine);\n\t\tGEM_BUG_ON(test_and_set_bit(I915_RESET_ENGINE + id,\n\t\t\t\t\t    &gt->reset.flags));\n\t\tcount = 0;\n\t\tdo {\n\t\t\tstruct i915_request *rq = NULL;\n\t\t\tstruct intel_selftest_saved_policy saved;\n\t\t\tint err2;\n\n\t\t\terr = intel_selftest_modify_policy(engine, &saved,\n\t\t\t\t\t\t\t   SELFTEST_SCHEDULER_MODIFY_FAST_RESET);\n\t\t\tif (err) {\n\t\t\t\tpr_err(\"[%s] Modify policy failed: %d!\\n\", engine->name, err);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (active) {\n\t\t\t\trq = hang_create_request(&h, engine);\n\t\t\t\tif (IS_ERR(rq)) {\n\t\t\t\t\terr = PTR_ERR(rq);\n\t\t\t\t\tpr_err(\"[%s] Create hang request failed: %d!\\n\",\n\t\t\t\t\t       engine->name, err);\n\t\t\t\t\tgoto restore;\n\t\t\t\t}\n\n\t\t\t\ti915_request_get(rq);\n\t\t\t\ti915_request_add(rq);\n\n\t\t\t\tif (!wait_until_running(&h, rq)) {\n\t\t\t\t\tstruct drm_printer p = drm_info_printer(gt->i915->drm.dev);\n\n\t\t\t\t\tpr_err(\"%s: Failed to start request %llx, at %x\\n\",\n\t\t\t\t\t       __func__, rq->fence.seqno, hws_seqno(&h, rq));\n\t\t\t\t\tintel_engine_dump(engine, &p,\n\t\t\t\t\t\t\t  \"%s\\n\", engine->name);\n\n\t\t\t\t\ti915_request_put(rq);\n\t\t\t\t\terr = -EIO;\n\t\t\t\t\tgoto restore;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (!using_guc) {\n\t\t\t\terr = intel_engine_reset(engine, NULL);\n\t\t\t\tif (err) {\n\t\t\t\t\tpr_err(\"intel_engine_reset(%s) failed, err:%d\\n\",\n\t\t\t\t\t       engine->name, err);\n\t\t\t\t\tgoto skip;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (rq) {\n\t\t\t\t \n\t\t\t\terr = intel_selftest_wait_for_rq(rq);\n\t\t\t\tif (err)\n\t\t\t\t\tpr_err(\"[%s] Wait for request %lld:%lld [0x%04X] failed: %d!\\n\",\n\t\t\t\t\t       engine->name, rq->fence.context,\n\t\t\t\t\t       rq->fence.seqno, rq->context->guc_id.id, err);\n\t\t\t}\n\nskip:\n\t\t\tif (rq)\n\t\t\t\ti915_request_put(rq);\n\n\t\t\tif (i915_reset_count(global) != reset_count) {\n\t\t\t\tpr_err(\"Full GPU reset recorded! (engine reset expected)\\n\");\n\t\t\t\terr = -EINVAL;\n\t\t\t\tgoto restore;\n\t\t\t}\n\n\t\t\t \n\t\t\tif (!using_guc) {\n\t\t\t\tif (i915_reset_engine_count(global, engine) !=\n\t\t\t\t    ++reset_engine_count) {\n\t\t\t\t\tpr_err(\"%s engine reset not recorded!\\n\",\n\t\t\t\t\t       engine->name);\n\t\t\t\t\terr = -EINVAL;\n\t\t\t\t\tgoto restore;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tcount++;\n\nrestore:\n\t\t\terr2 = intel_selftest_restore_policy(engine, &saved);\n\t\t\tif (err2)\n\t\t\t\tpr_err(\"[%s] Restore policy failed: %d!\\n\", engine->name, err);\n\t\t\tif (err == 0)\n\t\t\t\terr = err2;\n\t\t\tif (err)\n\t\t\t\tbreak;\n\t\t} while (time_before(jiffies, end_time));\n\t\tclear_and_wake_up_bit(I915_RESET_ENGINE + id, &gt->reset.flags);\n\t\tst_engine_heartbeat_enable(engine);\n\t\tpr_info(\"%s: Completed %lu %s resets\\n\",\n\t\t\tengine->name, count, active ? \"active\" : \"idle\");\n\n\t\tif (err)\n\t\t\tbreak;\n\n\t\terr = igt_flush_test(gt->i915);\n\t\tif (err) {\n\t\t\tpr_err(\"[%s] Flush failed: %d!\\n\", engine->name, err);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (intel_gt_is_wedged(gt)) {\n\t\tpr_err(\"GT is wedged!\\n\");\n\t\terr = -EIO;\n\t}\n\n\tif (active)\n\t\thang_fini(&h);\n\n\treturn err;\n}\n\nstatic int igt_reset_idle_engine(void *arg)\n{\n\treturn __igt_reset_engine(arg, false);\n}\n\nstatic int igt_reset_active_engine(void *arg)\n{\n\treturn __igt_reset_engine(arg, true);\n}\n\nstruct active_engine {\n\tstruct kthread_worker *worker;\n\tstruct kthread_work work;\n\tstruct intel_engine_cs *engine;\n\tunsigned long resets;\n\tunsigned int flags;\n\tbool stop;\n\tint result;\n};\n\n#define TEST_ACTIVE\tBIT(0)\n#define TEST_OTHERS\tBIT(1)\n#define TEST_SELF\tBIT(2)\n#define TEST_PRIORITY\tBIT(3)\n\nstatic int active_request_put(struct i915_request *rq)\n{\n\tint err = 0;\n\n\tif (!rq)\n\t\treturn 0;\n\n\tif (i915_request_wait(rq, 0, 10 * HZ) < 0) {\n\t\tGEM_TRACE(\"%s timed out waiting for completion of fence %llx:%lld\\n\",\n\t\t\t  rq->engine->name,\n\t\t\t  rq->fence.context,\n\t\t\t  rq->fence.seqno);\n\t\tGEM_TRACE_DUMP();\n\n\t\tintel_gt_set_wedged(rq->engine->gt);\n\t\terr = -EIO;\n\t}\n\n\ti915_request_put(rq);\n\n\treturn err;\n}\n\nstatic void active_engine(struct kthread_work *work)\n{\n\tI915_RND_STATE(prng);\n\tstruct active_engine *arg = container_of(work, typeof(*arg), work);\n\tstruct intel_engine_cs *engine = arg->engine;\n\tstruct i915_request *rq[8] = {};\n\tstruct intel_context *ce[ARRAY_SIZE(rq)];\n\tunsigned long count;\n\tint err = 0;\n\n\tfor (count = 0; count < ARRAY_SIZE(ce); count++) {\n\t\tce[count] = intel_context_create(engine);\n\t\tif (IS_ERR(ce[count])) {\n\t\t\targ->result = PTR_ERR(ce[count]);\n\t\t\tpr_err(\"[%s] Create context #%ld failed: %d!\\n\",\n\t\t\t       engine->name, count, arg->result);\n\t\t\twhile (--count)\n\t\t\t\tintel_context_put(ce[count]);\n\t\t\treturn;\n\t\t}\n\t}\n\n\tcount = 0;\n\twhile (!READ_ONCE(arg->stop)) {\n\t\tunsigned int idx = count++ & (ARRAY_SIZE(rq) - 1);\n\t\tstruct i915_request *old = rq[idx];\n\t\tstruct i915_request *new;\n\n\t\tnew = intel_context_create_request(ce[idx]);\n\t\tif (IS_ERR(new)) {\n\t\t\terr = PTR_ERR(new);\n\t\t\tpr_err(\"[%s] Create request #%d failed: %d!\\n\", engine->name, idx, err);\n\t\t\tbreak;\n\t\t}\n\n\t\trq[idx] = i915_request_get(new);\n\t\ti915_request_add(new);\n\n\t\tif (engine->sched_engine->schedule && arg->flags & TEST_PRIORITY) {\n\t\t\tstruct i915_sched_attr attr = {\n\t\t\t\t.priority =\n\t\t\t\t\ti915_prandom_u32_max_state(512, &prng),\n\t\t\t};\n\t\t\tengine->sched_engine->schedule(rq[idx], &attr);\n\t\t}\n\n\t\terr = active_request_put(old);\n\t\tif (err) {\n\t\t\tpr_err(\"[%s] Request put failed: %d!\\n\", engine->name, err);\n\t\t\tbreak;\n\t\t}\n\n\t\tcond_resched();\n\t}\n\n\tfor (count = 0; count < ARRAY_SIZE(rq); count++) {\n\t\tint err__ = active_request_put(rq[count]);\n\n\t\tif (err)\n\t\t\tpr_err(\"[%s] Request put #%ld failed: %d!\\n\", engine->name, count, err);\n\n\t\t \n\t\tif (!err)\n\t\t\terr = err__;\n\n\t\tintel_context_put(ce[count]);\n\t}\n\n\targ->result = err;\n}\n\nstatic int __igt_reset_engines(struct intel_gt *gt,\n\t\t\t       const char *test_name,\n\t\t\t       unsigned int flags)\n{\n\tstruct i915_gpu_error *global = &gt->i915->gpu_error;\n\tstruct intel_engine_cs *engine, *other;\n\tstruct active_engine *threads;\n\tenum intel_engine_id id, tmp;\n\tstruct hang h;\n\tint err = 0;\n\n\t \n\n\tif (!intel_has_reset_engine(gt))\n\t\treturn 0;\n\n\tif (flags & TEST_ACTIVE) {\n\t\terr = hang_init(&h, gt);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\tif (flags & TEST_PRIORITY)\n\t\t\th.ctx->sched.priority = 1024;\n\t}\n\n\tthreads = kmalloc_array(I915_NUM_ENGINES, sizeof(*threads), GFP_KERNEL);\n\tif (!threads)\n\t\treturn -ENOMEM;\n\n\tfor_each_engine(engine, gt, id) {\n\t\tunsigned long device = i915_reset_count(global);\n\t\tunsigned long count = 0, reported;\n\t\tbool using_guc = intel_engine_uses_guc(engine);\n\t\tIGT_TIMEOUT(end_time);\n\n\t\tif (flags & TEST_ACTIVE) {\n\t\t\tif (!intel_engine_can_store_dword(engine))\n\t\t\t\tcontinue;\n\t\t} else if (using_guc)\n\t\t\tcontinue;\n\n\t\tif (!wait_for_idle(engine)) {\n\t\t\tpr_err(\"i915_reset_engine(%s:%s): failed to idle before reset\\n\",\n\t\t\t       engine->name, test_name);\n\t\t\terr = -EIO;\n\t\t\tbreak;\n\t\t}\n\n\t\tmemset(threads, 0, sizeof(*threads) * I915_NUM_ENGINES);\n\t\tfor_each_engine(other, gt, tmp) {\n\t\t\tstruct kthread_worker *worker;\n\n\t\t\tthreads[tmp].resets =\n\t\t\t\ti915_reset_engine_count(global, other);\n\n\t\t\tif (other == engine && !(flags & TEST_SELF))\n\t\t\t\tcontinue;\n\n\t\t\tif (other != engine && !(flags & TEST_OTHERS))\n\t\t\t\tcontinue;\n\n\t\t\tthreads[tmp].engine = other;\n\t\t\tthreads[tmp].flags = flags;\n\n\t\t\tworker = kthread_create_worker(0, \"igt/%s\",\n\t\t\t\t\t\t       other->name);\n\t\t\tif (IS_ERR(worker)) {\n\t\t\t\terr = PTR_ERR(worker);\n\t\t\t\tpr_err(\"[%s] Worker create failed: %d!\\n\",\n\t\t\t\t       engine->name, err);\n\t\t\t\tgoto unwind;\n\t\t\t}\n\n\t\t\tthreads[tmp].worker = worker;\n\n\t\t\tkthread_init_work(&threads[tmp].work, active_engine);\n\t\t\tkthread_queue_work(threads[tmp].worker,\n\t\t\t\t\t   &threads[tmp].work);\n\t\t}\n\n\t\tst_engine_heartbeat_disable_no_pm(engine);\n\t\tGEM_BUG_ON(test_and_set_bit(I915_RESET_ENGINE + id,\n\t\t\t\t\t    &gt->reset.flags));\n\t\tdo {\n\t\t\tstruct i915_request *rq = NULL;\n\t\t\tstruct intel_selftest_saved_policy saved;\n\t\t\tint err2;\n\n\t\t\terr = intel_selftest_modify_policy(engine, &saved,\n\t\t\t\t\t\t\t   SELFTEST_SCHEDULER_MODIFY_FAST_RESET);\n\t\t\tif (err) {\n\t\t\t\tpr_err(\"[%s] Modify policy failed: %d!\\n\", engine->name, err);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (flags & TEST_ACTIVE) {\n\t\t\t\trq = hang_create_request(&h, engine);\n\t\t\t\tif (IS_ERR(rq)) {\n\t\t\t\t\terr = PTR_ERR(rq);\n\t\t\t\t\tpr_err(\"[%s] Create hang request failed: %d!\\n\",\n\t\t\t\t\t       engine->name, err);\n\t\t\t\t\tgoto restore;\n\t\t\t\t}\n\n\t\t\t\ti915_request_get(rq);\n\t\t\t\ti915_request_add(rq);\n\n\t\t\t\tif (!wait_until_running(&h, rq)) {\n\t\t\t\t\tstruct drm_printer p = drm_info_printer(gt->i915->drm.dev);\n\n\t\t\t\t\tpr_err(\"%s: Failed to start request %llx, at %x\\n\",\n\t\t\t\t\t       __func__, rq->fence.seqno, hws_seqno(&h, rq));\n\t\t\t\t\tintel_engine_dump(engine, &p,\n\t\t\t\t\t\t\t  \"%s\\n\", engine->name);\n\n\t\t\t\t\ti915_request_put(rq);\n\t\t\t\t\terr = -EIO;\n\t\t\t\t\tgoto restore;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tintel_engine_pm_get(engine);\n\t\t\t}\n\n\t\t\tif (!using_guc) {\n\t\t\t\terr = intel_engine_reset(engine, NULL);\n\t\t\t\tif (err) {\n\t\t\t\t\tpr_err(\"i915_reset_engine(%s:%s): failed, err=%d\\n\",\n\t\t\t\t\t       engine->name, test_name, err);\n\t\t\t\t\tgoto restore;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (rq) {\n\t\t\t\t \n\t\t\t\terr = intel_selftest_wait_for_rq(rq);\n\t\t\t\tif (err)\n\t\t\t\t\tpr_err(\"[%s] Wait for request %lld:%lld [0x%04X] failed: %d!\\n\",\n\t\t\t\t\t       engine->name, rq->fence.context,\n\t\t\t\t\t       rq->fence.seqno, rq->context->guc_id.id, err);\n\t\t\t}\n\n\t\t\tcount++;\n\n\t\t\tif (rq) {\n\t\t\t\tif (rq->fence.error != -EIO) {\n\t\t\t\t\tpr_err(\"i915_reset_engine(%s:%s): failed to reset request %lld:%lld [0x%04X]\\n\",\n\t\t\t\t\t       engine->name, test_name,\n\t\t\t\t\t       rq->fence.context,\n\t\t\t\t\t       rq->fence.seqno, rq->context->guc_id.id);\n\t\t\t\t\ti915_request_put(rq);\n\n\t\t\t\t\tGEM_TRACE_DUMP();\n\t\t\t\t\tintel_gt_set_wedged(gt);\n\t\t\t\t\terr = -EIO;\n\t\t\t\t\tgoto restore;\n\t\t\t\t}\n\n\t\t\t\tif (i915_request_wait(rq, 0, HZ / 5) < 0) {\n\t\t\t\t\tstruct drm_printer p =\n\t\t\t\t\t\tdrm_info_printer(gt->i915->drm.dev);\n\n\t\t\t\t\tpr_err(\"i915_reset_engine(%s:%s):\"\n\t\t\t\t\t       \" failed to complete request %llx:%lld after reset\\n\",\n\t\t\t\t\t       engine->name, test_name,\n\t\t\t\t\t       rq->fence.context,\n\t\t\t\t\t       rq->fence.seqno);\n\t\t\t\t\tintel_engine_dump(engine, &p,\n\t\t\t\t\t\t\t  \"%s\\n\", engine->name);\n\t\t\t\t\ti915_request_put(rq);\n\n\t\t\t\t\tGEM_TRACE_DUMP();\n\t\t\t\t\tintel_gt_set_wedged(gt);\n\t\t\t\t\terr = -EIO;\n\t\t\t\t\tgoto restore;\n\t\t\t\t}\n\n\t\t\t\ti915_request_put(rq);\n\t\t\t}\n\n\t\t\tif (!(flags & TEST_ACTIVE))\n\t\t\t\tintel_engine_pm_put(engine);\n\n\t\t\tif (!(flags & TEST_SELF) && !wait_for_idle(engine)) {\n\t\t\t\tstruct drm_printer p =\n\t\t\t\t\tdrm_info_printer(gt->i915->drm.dev);\n\n\t\t\t\tpr_err(\"i915_reset_engine(%s:%s):\"\n\t\t\t\t       \" failed to idle after reset\\n\",\n\t\t\t\t       engine->name, test_name);\n\t\t\t\tintel_engine_dump(engine, &p,\n\t\t\t\t\t\t  \"%s\\n\", engine->name);\n\n\t\t\t\terr = -EIO;\n\t\t\t\tgoto restore;\n\t\t\t}\n\nrestore:\n\t\t\terr2 = intel_selftest_restore_policy(engine, &saved);\n\t\t\tif (err2)\n\t\t\t\tpr_err(\"[%s] Restore policy failed: %d!\\n\", engine->name, err2);\n\t\t\tif (err == 0)\n\t\t\t\terr = err2;\n\t\t\tif (err)\n\t\t\t\tbreak;\n\t\t} while (time_before(jiffies, end_time));\n\t\tclear_and_wake_up_bit(I915_RESET_ENGINE + id, &gt->reset.flags);\n\t\tst_engine_heartbeat_enable_no_pm(engine);\n\n\t\tpr_info(\"i915_reset_engine(%s:%s): %lu resets\\n\",\n\t\t\tengine->name, test_name, count);\n\n\t\t \n\t\tif (!using_guc) {\n\t\t\treported = i915_reset_engine_count(global, engine);\n\t\t\treported -= threads[engine->id].resets;\n\t\t\tif (reported != count) {\n\t\t\t\tpr_err(\"i915_reset_engine(%s:%s): reset %lu times, but reported %lu\\n\",\n\t\t\t\t       engine->name, test_name, count, reported);\n\t\t\t\tif (!err)\n\t\t\t\t\terr = -EINVAL;\n\t\t\t}\n\t\t}\n\nunwind:\n\t\tfor_each_engine(other, gt, tmp) {\n\t\t\tint ret;\n\n\t\t\tif (!threads[tmp].worker)\n\t\t\t\tcontinue;\n\n\t\t\tWRITE_ONCE(threads[tmp].stop, true);\n\t\t\tkthread_flush_work(&threads[tmp].work);\n\t\t\tret = READ_ONCE(threads[tmp].result);\n\t\t\tif (ret) {\n\t\t\t\tpr_err(\"kthread for other engine %s failed, err=%d\\n\",\n\t\t\t\t       other->name, ret);\n\t\t\t\tif (!err)\n\t\t\t\t\terr = ret;\n\t\t\t}\n\n\t\t\tkthread_destroy_worker(threads[tmp].worker);\n\n\t\t\t \n\t\t\tif (!using_guc) {\n\t\t\t\tif (other->uabi_class != engine->uabi_class &&\n\t\t\t\t    threads[tmp].resets !=\n\t\t\t\t    i915_reset_engine_count(global, other)) {\n\t\t\t\t\tpr_err(\"Innocent engine %s was reset (count=%ld)\\n\",\n\t\t\t\t\t       other->name,\n\t\t\t\t\t       i915_reset_engine_count(global, other) -\n\t\t\t\t\t       threads[tmp].resets);\n\t\t\t\t\tif (!err)\n\t\t\t\t\t\terr = -EINVAL;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (device != i915_reset_count(global)) {\n\t\t\tpr_err(\"Global reset (count=%ld)!\\n\",\n\t\t\t       i915_reset_count(global) - device);\n\t\t\tif (!err)\n\t\t\t\terr = -EINVAL;\n\t\t}\n\n\t\tif (err)\n\t\t\tbreak;\n\n\t\terr = igt_flush_test(gt->i915);\n\t\tif (err) {\n\t\t\tpr_err(\"[%s] Flush failed: %d!\\n\", engine->name, err);\n\t\t\tbreak;\n\t\t}\n\t}\n\tkfree(threads);\n\n\tif (intel_gt_is_wedged(gt))\n\t\terr = -EIO;\n\n\tif (flags & TEST_ACTIVE)\n\t\thang_fini(&h);\n\n\treturn err;\n}\n\nstatic int igt_reset_engines(void *arg)\n{\n\tstatic const struct {\n\t\tconst char *name;\n\t\tunsigned int flags;\n\t} phases[] = {\n\t\t{ \"idle\", 0 },\n\t\t{ \"active\", TEST_ACTIVE },\n\t\t{ \"others-idle\", TEST_OTHERS },\n\t\t{ \"others-active\", TEST_OTHERS | TEST_ACTIVE },\n\t\t{\n\t\t\t\"others-priority\",\n\t\t\tTEST_OTHERS | TEST_ACTIVE | TEST_PRIORITY\n\t\t},\n\t\t{\n\t\t\t\"self-priority\",\n\t\t\tTEST_ACTIVE | TEST_PRIORITY | TEST_SELF,\n\t\t},\n\t\t{ }\n\t};\n\tstruct intel_gt *gt = arg;\n\ttypeof(*phases) *p;\n\tint err;\n\n\tfor (p = phases; p->name; p++) {\n\t\tif (p->flags & TEST_PRIORITY) {\n\t\t\tif (!(gt->i915->caps.scheduler & I915_SCHEDULER_CAP_PRIORITY))\n\t\t\t\tcontinue;\n\t\t}\n\n\t\terr = __igt_reset_engines(arg, p->name, p->flags);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\nstatic u32 fake_hangcheck(struct intel_gt *gt, intel_engine_mask_t mask)\n{\n\tu32 count = i915_reset_count(&gt->i915->gpu_error);\n\n\tintel_gt_reset(gt, mask, NULL);\n\n\treturn count;\n}\n\nstatic int igt_reset_wait(void *arg)\n{\n\tstruct intel_gt *gt = arg;\n\tstruct i915_gpu_error *global = &gt->i915->gpu_error;\n\tstruct intel_engine_cs *engine;\n\tstruct i915_request *rq;\n\tunsigned int reset_count;\n\tstruct hang h;\n\tlong timeout;\n\tint err;\n\n\tengine = intel_selftest_find_any_engine(gt);\n\n\tif (!engine || !intel_engine_can_store_dword(engine))\n\t\treturn 0;\n\n\t \n\n\tigt_global_reset_lock(gt);\n\n\terr = hang_init(&h, gt);\n\tif (err) {\n\t\tpr_err(\"[%s] Hang init failed: %d!\\n\", engine->name, err);\n\t\tgoto unlock;\n\t}\n\n\trq = hang_create_request(&h, engine);\n\tif (IS_ERR(rq)) {\n\t\terr = PTR_ERR(rq);\n\t\tpr_err(\"[%s] Create hang request failed: %d!\\n\", engine->name, err);\n\t\tgoto fini;\n\t}\n\n\ti915_request_get(rq);\n\ti915_request_add(rq);\n\n\tif (!wait_until_running(&h, rq)) {\n\t\tstruct drm_printer p = drm_info_printer(gt->i915->drm.dev);\n\n\t\tpr_err(\"%s: Failed to start request %llx, at %x\\n\",\n\t\t       __func__, rq->fence.seqno, hws_seqno(&h, rq));\n\t\tintel_engine_dump(rq->engine, &p, \"%s\\n\", rq->engine->name);\n\n\t\tintel_gt_set_wedged(gt);\n\n\t\terr = -EIO;\n\t\tgoto out_rq;\n\t}\n\n\treset_count = fake_hangcheck(gt, ALL_ENGINES);\n\n\ttimeout = i915_request_wait(rq, 0, 10);\n\tif (timeout < 0) {\n\t\tpr_err(\"i915_request_wait failed on a stuck request: err=%ld\\n\",\n\t\t       timeout);\n\t\terr = timeout;\n\t\tgoto out_rq;\n\t}\n\n\tif (i915_reset_count(global) == reset_count) {\n\t\tpr_err(\"No GPU reset recorded!\\n\");\n\t\terr = -EINVAL;\n\t\tgoto out_rq;\n\t}\n\nout_rq:\n\ti915_request_put(rq);\nfini:\n\thang_fini(&h);\nunlock:\n\tigt_global_reset_unlock(gt);\n\n\tif (intel_gt_is_wedged(gt))\n\t\treturn -EIO;\n\n\treturn err;\n}\n\nstruct evict_vma {\n\tstruct completion completion;\n\tstruct i915_vma *vma;\n};\n\nstatic int evict_vma(void *data)\n{\n\tstruct evict_vma *arg = data;\n\tstruct i915_address_space *vm = arg->vma->vm;\n\tstruct drm_mm_node evict = arg->vma->node;\n\tint err;\n\n\tcomplete(&arg->completion);\n\n\tmutex_lock(&vm->mutex);\n\terr = i915_gem_evict_for_node(vm, NULL, &evict, 0);\n\tmutex_unlock(&vm->mutex);\n\n\treturn err;\n}\n\nstatic int evict_fence(void *data)\n{\n\tstruct evict_vma *arg = data;\n\tint err;\n\n\tcomplete(&arg->completion);\n\n\t \n\terr = i915_gem_object_set_tiling(arg->vma->obj, I915_TILING_Y, 512);\n\tif (err) {\n\t\tpr_err(\"Invalid Y-tiling settings; err:%d\\n\", err);\n\t\treturn err;\n\t}\n\n\terr = i915_vma_pin(arg->vma, 0, 0, PIN_GLOBAL | PIN_MAPPABLE);\n\tif (err) {\n\t\tpr_err(\"Unable to pin vma for Y-tiled fence; err:%d\\n\", err);\n\t\treturn err;\n\t}\n\n\terr = i915_vma_pin_fence(arg->vma);\n\ti915_vma_unpin(arg->vma);\n\tif (err) {\n\t\tpr_err(\"Unable to pin Y-tiled fence; err:%d\\n\", err);\n\t\treturn err;\n\t}\n\n\ti915_vma_unpin_fence(arg->vma);\n\n\treturn 0;\n}\n\nstatic int __igt_reset_evict_vma(struct intel_gt *gt,\n\t\t\t\t struct i915_address_space *vm,\n\t\t\t\t int (*fn)(void *),\n\t\t\t\t unsigned int flags)\n{\n\tstruct intel_engine_cs *engine;\n\tstruct drm_i915_gem_object *obj;\n\tstruct task_struct *tsk = NULL;\n\tstruct i915_request *rq;\n\tstruct evict_vma arg;\n\tstruct hang h;\n\tunsigned int pin_flags;\n\tint err;\n\n\tif (!gt->ggtt->num_fences && flags & EXEC_OBJECT_NEEDS_FENCE)\n\t\treturn 0;\n\n\tengine = intel_selftest_find_any_engine(gt);\n\n\tif (!engine || !intel_engine_can_store_dword(engine))\n\t\treturn 0;\n\n\t \n\n\terr = hang_init(&h, gt);\n\tif (err) {\n\t\tpr_err(\"[%s] Hang init failed: %d!\\n\", engine->name, err);\n\t\treturn err;\n\t}\n\n\tobj = i915_gem_object_create_internal(gt->i915, SZ_1M);\n\tif (IS_ERR(obj)) {\n\t\terr = PTR_ERR(obj);\n\t\tpr_err(\"[%s] Create object failed: %d!\\n\", engine->name, err);\n\t\tgoto fini;\n\t}\n\n\tif (flags & EXEC_OBJECT_NEEDS_FENCE) {\n\t\terr = i915_gem_object_set_tiling(obj, I915_TILING_X, 512);\n\t\tif (err) {\n\t\t\tpr_err(\"Invalid X-tiling settings; err:%d\\n\", err);\n\t\t\tgoto out_obj;\n\t\t}\n\t}\n\n\targ.vma = i915_vma_instance(obj, vm, NULL);\n\tif (IS_ERR(arg.vma)) {\n\t\terr = PTR_ERR(arg.vma);\n\t\tpr_err(\"[%s] VMA instance failed: %d!\\n\", engine->name, err);\n\t\tgoto out_obj;\n\t}\n\n\trq = hang_create_request(&h, engine);\n\tif (IS_ERR(rq)) {\n\t\terr = PTR_ERR(rq);\n\t\tpr_err(\"[%s] Create hang request failed: %d!\\n\", engine->name, err);\n\t\tgoto out_obj;\n\t}\n\n\tpin_flags = i915_vma_is_ggtt(arg.vma) ? PIN_GLOBAL : PIN_USER;\n\n\tif (flags & EXEC_OBJECT_NEEDS_FENCE)\n\t\tpin_flags |= PIN_MAPPABLE;\n\n\terr = i915_vma_pin(arg.vma, 0, 0, pin_flags);\n\tif (err) {\n\t\ti915_request_add(rq);\n\t\tpr_err(\"[%s] VMA pin failed: %d!\\n\", engine->name, err);\n\t\tgoto out_obj;\n\t}\n\n\tif (flags & EXEC_OBJECT_NEEDS_FENCE) {\n\t\terr = i915_vma_pin_fence(arg.vma);\n\t\tif (err) {\n\t\t\tpr_err(\"Unable to pin X-tiled fence; err:%d\\n\", err);\n\t\t\ti915_vma_unpin(arg.vma);\n\t\t\ti915_request_add(rq);\n\t\t\tgoto out_obj;\n\t\t}\n\t}\n\n\terr = igt_vma_move_to_active_unlocked(arg.vma, rq, flags);\n\tif (err)\n\t\tpr_err(\"[%s] Move to active failed: %d!\\n\", engine->name, err);\n\n\tif (flags & EXEC_OBJECT_NEEDS_FENCE)\n\t\ti915_vma_unpin_fence(arg.vma);\n\ti915_vma_unpin(arg.vma);\n\n\ti915_request_get(rq);\n\ti915_request_add(rq);\n\tif (err)\n\t\tgoto out_rq;\n\n\tif (!wait_until_running(&h, rq)) {\n\t\tstruct drm_printer p = drm_info_printer(gt->i915->drm.dev);\n\n\t\tpr_err(\"%s: Failed to start request %llx, at %x\\n\",\n\t\t       __func__, rq->fence.seqno, hws_seqno(&h, rq));\n\t\tintel_engine_dump(rq->engine, &p, \"%s\\n\", rq->engine->name);\n\n\t\tintel_gt_set_wedged(gt);\n\t\tgoto out_reset;\n\t}\n\n\tinit_completion(&arg.completion);\n\n\ttsk = kthread_run(fn, &arg, \"igt/evict_vma\");\n\tif (IS_ERR(tsk)) {\n\t\terr = PTR_ERR(tsk);\n\t\tpr_err(\"[%s] Thread spawn failed: %d!\\n\", engine->name, err);\n\t\ttsk = NULL;\n\t\tgoto out_reset;\n\t}\n\tget_task_struct(tsk);\n\n\twait_for_completion(&arg.completion);\n\n\tif (wait_for(!list_empty(&rq->fence.cb_list), 10)) {\n\t\tstruct drm_printer p = drm_info_printer(gt->i915->drm.dev);\n\n\t\tpr_err(\"igt/evict_vma kthread did not wait\\n\");\n\t\tintel_engine_dump(rq->engine, &p, \"%s\\n\", rq->engine->name);\n\n\t\tintel_gt_set_wedged(gt);\n\t\tgoto out_reset;\n\t}\n\nout_reset:\n\tigt_global_reset_lock(gt);\n\tfake_hangcheck(gt, rq->engine->mask);\n\tigt_global_reset_unlock(gt);\n\n\tif (tsk) {\n\t\tstruct intel_wedge_me w;\n\n\t\t \n\t\tintel_wedge_on_timeout(&w, gt, HZ / 10  )\n\t\t\terr = kthread_stop(tsk);\n\n\t\tput_task_struct(tsk);\n\t}\n\nout_rq:\n\ti915_request_put(rq);\nout_obj:\n\ti915_gem_object_put(obj);\nfini:\n\thang_fini(&h);\n\tif (intel_gt_is_wedged(gt))\n\t\treturn -EIO;\n\n\treturn err;\n}\n\nstatic int igt_reset_evict_ggtt(void *arg)\n{\n\tstruct intel_gt *gt = arg;\n\n\treturn __igt_reset_evict_vma(gt, &gt->ggtt->vm,\n\t\t\t\t     evict_vma, EXEC_OBJECT_WRITE);\n}\n\nstatic int igt_reset_evict_ppgtt(void *arg)\n{\n\tstruct intel_gt *gt = arg;\n\tstruct i915_ppgtt *ppgtt;\n\tint err;\n\n\t \n\tif (INTEL_PPGTT(gt->i915) < INTEL_PPGTT_FULL)\n\t\treturn 0;\n\n\tppgtt = i915_ppgtt_create(gt, 0);\n\tif (IS_ERR(ppgtt))\n\t\treturn PTR_ERR(ppgtt);\n\n\terr = __igt_reset_evict_vma(gt, &ppgtt->vm,\n\t\t\t\t    evict_vma, EXEC_OBJECT_WRITE);\n\ti915_vm_put(&ppgtt->vm);\n\n\treturn err;\n}\n\nstatic int igt_reset_evict_fence(void *arg)\n{\n\tstruct intel_gt *gt = arg;\n\n\treturn __igt_reset_evict_vma(gt, &gt->ggtt->vm,\n\t\t\t\t     evict_fence, EXEC_OBJECT_NEEDS_FENCE);\n}\n\nstatic int wait_for_others(struct intel_gt *gt,\n\t\t\t   struct intel_engine_cs *exclude)\n{\n\tstruct intel_engine_cs *engine;\n\tenum intel_engine_id id;\n\n\tfor_each_engine(engine, gt, id) {\n\t\tif (engine == exclude)\n\t\t\tcontinue;\n\n\t\tif (!wait_for_idle(engine))\n\t\t\treturn -EIO;\n\t}\n\n\treturn 0;\n}\n\nstatic int igt_reset_queue(void *arg)\n{\n\tstruct intel_gt *gt = arg;\n\tstruct i915_gpu_error *global = &gt->i915->gpu_error;\n\tstruct intel_engine_cs *engine;\n\tenum intel_engine_id id;\n\tstruct hang h;\n\tint err;\n\n\t \n\n\tigt_global_reset_lock(gt);\n\n\terr = hang_init(&h, gt);\n\tif (err)\n\t\tgoto unlock;\n\n\tfor_each_engine(engine, gt, id) {\n\t\tstruct intel_selftest_saved_policy saved;\n\t\tstruct i915_request *prev;\n\t\tIGT_TIMEOUT(end_time);\n\t\tunsigned int count;\n\t\tbool using_guc = intel_engine_uses_guc(engine);\n\n\t\tif (!intel_engine_can_store_dword(engine))\n\t\t\tcontinue;\n\n\t\tif (using_guc) {\n\t\t\terr = intel_selftest_modify_policy(engine, &saved,\n\t\t\t\t\t\t\t   SELFTEST_SCHEDULER_MODIFY_NO_HANGCHECK);\n\t\t\tif (err) {\n\t\t\t\tpr_err(\"[%s] Modify policy failed: %d!\\n\", engine->name, err);\n\t\t\t\tgoto fini;\n\t\t\t}\n\t\t}\n\n\t\tprev = hang_create_request(&h, engine);\n\t\tif (IS_ERR(prev)) {\n\t\t\terr = PTR_ERR(prev);\n\t\t\tpr_err(\"[%s] Create 'prev' hang request failed: %d!\\n\", engine->name, err);\n\t\t\tgoto restore;\n\t\t}\n\n\t\ti915_request_get(prev);\n\t\ti915_request_add(prev);\n\n\t\tcount = 0;\n\t\tdo {\n\t\t\tstruct i915_request *rq;\n\t\t\tunsigned int reset_count;\n\n\t\t\trq = hang_create_request(&h, engine);\n\t\t\tif (IS_ERR(rq)) {\n\t\t\t\terr = PTR_ERR(rq);\n\t\t\t\tpr_err(\"[%s] Create hang request failed: %d!\\n\", engine->name, err);\n\t\t\t\tgoto restore;\n\t\t\t}\n\n\t\t\ti915_request_get(rq);\n\t\t\ti915_request_add(rq);\n\n\t\t\t \n\t\t\terr = wait_for_others(gt, engine);\n\t\t\tif (err) {\n\t\t\t\tpr_err(\"%s(%s): Failed to idle other inactive engines after device reset\\n\",\n\t\t\t\t       __func__, engine->name);\n\t\t\t\ti915_request_put(rq);\n\t\t\t\ti915_request_put(prev);\n\n\t\t\t\tGEM_TRACE_DUMP();\n\t\t\t\tintel_gt_set_wedged(gt);\n\t\t\t\tgoto restore;\n\t\t\t}\n\n\t\t\tif (!wait_until_running(&h, prev)) {\n\t\t\t\tstruct drm_printer p = drm_info_printer(gt->i915->drm.dev);\n\n\t\t\t\tpr_err(\"%s(%s): Failed to start request %llx, at %x\\n\",\n\t\t\t\t       __func__, engine->name,\n\t\t\t\t       prev->fence.seqno, hws_seqno(&h, prev));\n\t\t\t\tintel_engine_dump(engine, &p,\n\t\t\t\t\t\t  \"%s\\n\", engine->name);\n\n\t\t\t\ti915_request_put(rq);\n\t\t\t\ti915_request_put(prev);\n\n\t\t\t\tintel_gt_set_wedged(gt);\n\n\t\t\t\terr = -EIO;\n\t\t\t\tgoto restore;\n\t\t\t}\n\n\t\t\treset_count = fake_hangcheck(gt, BIT(id));\n\n\t\t\tif (prev->fence.error != -EIO) {\n\t\t\t\tpr_err(\"GPU reset not recorded on hanging request [fence.error=%d]!\\n\",\n\t\t\t\t       prev->fence.error);\n\t\t\t\ti915_request_put(rq);\n\t\t\t\ti915_request_put(prev);\n\t\t\t\terr = -EINVAL;\n\t\t\t\tgoto restore;\n\t\t\t}\n\n\t\t\tif (rq->fence.error) {\n\t\t\t\tpr_err(\"Fence error status not zero [%d] after unrelated reset\\n\",\n\t\t\t\t       rq->fence.error);\n\t\t\t\ti915_request_put(rq);\n\t\t\t\ti915_request_put(prev);\n\t\t\t\terr = -EINVAL;\n\t\t\t\tgoto restore;\n\t\t\t}\n\n\t\t\tif (i915_reset_count(global) == reset_count) {\n\t\t\t\tpr_err(\"No GPU reset recorded!\\n\");\n\t\t\t\ti915_request_put(rq);\n\t\t\t\ti915_request_put(prev);\n\t\t\t\terr = -EINVAL;\n\t\t\t\tgoto restore;\n\t\t\t}\n\n\t\t\ti915_request_put(prev);\n\t\t\tprev = rq;\n\t\t\tcount++;\n\t\t} while (time_before(jiffies, end_time));\n\t\tpr_info(\"%s: Completed %d queued resets\\n\",\n\t\t\tengine->name, count);\n\n\t\t*h.batch = MI_BATCH_BUFFER_END;\n\t\tintel_gt_chipset_flush(engine->gt);\n\n\t\ti915_request_put(prev);\n\nrestore:\n\t\tif (using_guc) {\n\t\t\tint err2 = intel_selftest_restore_policy(engine, &saved);\n\n\t\t\tif (err2)\n\t\t\t\tpr_err(\"%s:%d> [%s] Restore policy failed: %d!\\n\",\n\t\t\t\t       __func__, __LINE__, engine->name, err2);\n\t\t\tif (err == 0)\n\t\t\t\terr = err2;\n\t\t}\n\t\tif (err)\n\t\t\tgoto fini;\n\n\t\terr = igt_flush_test(gt->i915);\n\t\tif (err) {\n\t\t\tpr_err(\"[%s] Flush failed: %d!\\n\", engine->name, err);\n\t\t\tbreak;\n\t\t}\n\t}\n\nfini:\n\thang_fini(&h);\nunlock:\n\tigt_global_reset_unlock(gt);\n\n\tif (intel_gt_is_wedged(gt))\n\t\treturn -EIO;\n\n\treturn err;\n}\n\nstatic int igt_handle_error(void *arg)\n{\n\tstruct intel_gt *gt = arg;\n\tstruct i915_gpu_error *global = &gt->i915->gpu_error;\n\tstruct intel_engine_cs *engine;\n\tstruct hang h;\n\tstruct i915_request *rq;\n\tstruct i915_gpu_coredump *error;\n\tint err;\n\n\tengine = intel_selftest_find_any_engine(gt);\n\n\t \n\n\tif (!intel_has_reset_engine(gt))\n\t\treturn 0;\n\n\tif (!engine || !intel_engine_can_store_dword(engine))\n\t\treturn 0;\n\n\terr = hang_init(&h, gt);\n\tif (err) {\n\t\tpr_err(\"[%s] Hang init failed: %d!\\n\", engine->name, err);\n\t\treturn err;\n\t}\n\n\trq = hang_create_request(&h, engine);\n\tif (IS_ERR(rq)) {\n\t\terr = PTR_ERR(rq);\n\t\tpr_err(\"[%s] Create hang request failed: %d!\\n\", engine->name, err);\n\t\tgoto err_fini;\n\t}\n\n\ti915_request_get(rq);\n\ti915_request_add(rq);\n\n\tif (!wait_until_running(&h, rq)) {\n\t\tstruct drm_printer p = drm_info_printer(gt->i915->drm.dev);\n\n\t\tpr_err(\"%s: Failed to start request %llx, at %x\\n\",\n\t\t       __func__, rq->fence.seqno, hws_seqno(&h, rq));\n\t\tintel_engine_dump(rq->engine, &p, \"%s\\n\", rq->engine->name);\n\n\t\tintel_gt_set_wedged(gt);\n\n\t\terr = -EIO;\n\t\tgoto err_request;\n\t}\n\n\t \n\terror = xchg(&global->first_error, (void *)-1);\n\n\tintel_gt_handle_error(gt, engine->mask, 0, NULL);\n\n\txchg(&global->first_error, error);\n\n\tif (rq->fence.error != -EIO) {\n\t\tpr_err(\"Guilty request not identified!\\n\");\n\t\terr = -EINVAL;\n\t\tgoto err_request;\n\t}\n\nerr_request:\n\ti915_request_put(rq);\nerr_fini:\n\thang_fini(&h);\n\treturn err;\n}\n\nstatic int __igt_atomic_reset_engine(struct intel_engine_cs *engine,\n\t\t\t\t     const struct igt_atomic_section *p,\n\t\t\t\t     const char *mode)\n{\n\tstruct tasklet_struct * const t = &engine->sched_engine->tasklet;\n\tint err;\n\n\tGEM_TRACE(\"i915_reset_engine(%s:%s) under %s\\n\",\n\t\t  engine->name, mode, p->name);\n\n\tif (t->func)\n\t\ttasklet_disable(t);\n\tif (strcmp(p->name, \"softirq\"))\n\t\tlocal_bh_disable();\n\tp->critical_section_begin();\n\n\terr = __intel_engine_reset_bh(engine, NULL);\n\n\tp->critical_section_end();\n\tif (strcmp(p->name, \"softirq\"))\n\t\tlocal_bh_enable();\n\tif (t->func) {\n\t\ttasklet_enable(t);\n\t\ttasklet_hi_schedule(t);\n\t}\n\n\tif (err)\n\t\tpr_err(\"i915_reset_engine(%s:%s) failed under %s\\n\",\n\t\t       engine->name, mode, p->name);\n\n\treturn err;\n}\n\nstatic int igt_atomic_reset_engine(struct intel_engine_cs *engine,\n\t\t\t\t   const struct igt_atomic_section *p)\n{\n\tstruct i915_request *rq;\n\tstruct hang h;\n\tint err;\n\n\terr = __igt_atomic_reset_engine(engine, p, \"idle\");\n\tif (err)\n\t\treturn err;\n\n\terr = hang_init(&h, engine->gt);\n\tif (err) {\n\t\tpr_err(\"[%s] Hang init failed: %d!\\n\", engine->name, err);\n\t\treturn err;\n\t}\n\n\trq = hang_create_request(&h, engine);\n\tif (IS_ERR(rq)) {\n\t\terr = PTR_ERR(rq);\n\t\tpr_err(\"[%s] Create hang request failed: %d!\\n\", engine->name, err);\n\t\tgoto out;\n\t}\n\n\ti915_request_get(rq);\n\ti915_request_add(rq);\n\n\tif (wait_until_running(&h, rq)) {\n\t\terr = __igt_atomic_reset_engine(engine, p, \"active\");\n\t} else {\n\t\tpr_err(\"%s(%s): Failed to start request %llx, at %x\\n\",\n\t\t       __func__, engine->name,\n\t\t       rq->fence.seqno, hws_seqno(&h, rq));\n\t\tintel_gt_set_wedged(engine->gt);\n\t\terr = -EIO;\n\t}\n\n\tif (err == 0) {\n\t\tstruct intel_wedge_me w;\n\n\t\tintel_wedge_on_timeout(&w, engine->gt, HZ / 20  )\n\t\t\ti915_request_wait(rq, 0, MAX_SCHEDULE_TIMEOUT);\n\t\tif (intel_gt_is_wedged(engine->gt))\n\t\t\terr = -EIO;\n\t}\n\n\ti915_request_put(rq);\nout:\n\thang_fini(&h);\n\treturn err;\n}\n\nstatic int igt_reset_engines_atomic(void *arg)\n{\n\tstruct intel_gt *gt = arg;\n\tconst typeof(*igt_atomic_phases) *p;\n\tint err = 0;\n\n\t \n\n\tif (!intel_has_reset_engine(gt))\n\t\treturn 0;\n\n\tif (intel_uc_uses_guc_submission(&gt->uc))\n\t\treturn 0;\n\n\tigt_global_reset_lock(gt);\n\n\t \n\tif (!igt_force_reset(gt))\n\t\tgoto unlock;\n\n\tfor (p = igt_atomic_phases; p->name; p++) {\n\t\tstruct intel_engine_cs *engine;\n\t\tenum intel_engine_id id;\n\n\t\tfor_each_engine(engine, gt, id) {\n\t\t\terr = igt_atomic_reset_engine(engine, p);\n\t\t\tif (err)\n\t\t\t\tgoto out;\n\t\t}\n\t}\n\nout:\n\t \n\tigt_force_reset(gt);\nunlock:\n\tigt_global_reset_unlock(gt);\n\n\treturn err;\n}\n\nint intel_hangcheck_live_selftests(struct drm_i915_private *i915)\n{\n\tstatic const struct i915_subtest tests[] = {\n\t\tSUBTEST(igt_hang_sanitycheck),\n\t\tSUBTEST(igt_reset_nop),\n\t\tSUBTEST(igt_reset_nop_engine),\n\t\tSUBTEST(igt_reset_idle_engine),\n\t\tSUBTEST(igt_reset_active_engine),\n\t\tSUBTEST(igt_reset_fail_engine),\n\t\tSUBTEST(igt_reset_engines),\n\t\tSUBTEST(igt_reset_engines_atomic),\n\t\tSUBTEST(igt_reset_queue),\n\t\tSUBTEST(igt_reset_wait),\n\t\tSUBTEST(igt_reset_evict_ggtt),\n\t\tSUBTEST(igt_reset_evict_ppgtt),\n\t\tSUBTEST(igt_reset_evict_fence),\n\t\tSUBTEST(igt_handle_error),\n\t};\n\tstruct intel_gt *gt = to_gt(i915);\n\tintel_wakeref_t wakeref;\n\tint err;\n\n\tif (!intel_has_gpu_reset(gt))\n\t\treturn 0;\n\n\tif (intel_gt_is_wedged(gt))\n\t\treturn -EIO;  \n\n\twakeref = intel_runtime_pm_get(gt->uncore->rpm);\n\n\terr = intel_gt_live_subtests(tests, gt);\n\n\tintel_runtime_pm_put(gt->uncore->rpm, wakeref);\n\n\treturn err;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}