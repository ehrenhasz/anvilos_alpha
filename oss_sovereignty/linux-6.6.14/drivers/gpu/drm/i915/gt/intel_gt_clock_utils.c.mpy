{
  "module_name": "intel_gt_clock_utils.c",
  "hash_id": "06dbc5482dc5de120f019e8d6189ea2b549c799c94afea0ec4c133f192d238cd",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/i915/gt/intel_gt_clock_utils.c",
  "human_readable_source": "\n \n\n#include \"i915_drv.h\"\n#include \"i915_reg.h\"\n#include \"intel_gt.h\"\n#include \"intel_gt_clock_utils.h\"\n#include \"intel_gt_print.h\"\n#include \"intel_gt_regs.h\"\n\nstatic u32 read_reference_ts_freq(struct intel_uncore *uncore)\n{\n\tu32 ts_override = intel_uncore_read(uncore, GEN9_TIMESTAMP_OVERRIDE);\n\tu32 base_freq, frac_freq;\n\n\tbase_freq = ((ts_override & GEN9_TIMESTAMP_OVERRIDE_US_COUNTER_DIVIDER_MASK) >>\n\t\t     GEN9_TIMESTAMP_OVERRIDE_US_COUNTER_DIVIDER_SHIFT) + 1;\n\tbase_freq *= 1000000;\n\n\tfrac_freq = ((ts_override &\n\t\t      GEN9_TIMESTAMP_OVERRIDE_US_COUNTER_DENOMINATOR_MASK) >>\n\t\t     GEN9_TIMESTAMP_OVERRIDE_US_COUNTER_DENOMINATOR_SHIFT);\n\tfrac_freq = 1000000 / (frac_freq + 1);\n\n\treturn base_freq + frac_freq;\n}\n\nstatic u32 gen11_get_crystal_clock_freq(struct intel_uncore *uncore,\n\t\t\t\t\tu32 rpm_config_reg)\n{\n\tu32 f19_2_mhz = 19200000;\n\tu32 f24_mhz = 24000000;\n\tu32 f25_mhz = 25000000;\n\tu32 f38_4_mhz = 38400000;\n\tu32 crystal_clock =\n\t\t(rpm_config_reg & GEN11_RPM_CONFIG0_CRYSTAL_CLOCK_FREQ_MASK) >>\n\t\tGEN11_RPM_CONFIG0_CRYSTAL_CLOCK_FREQ_SHIFT;\n\n\tswitch (crystal_clock) {\n\tcase GEN11_RPM_CONFIG0_CRYSTAL_CLOCK_FREQ_24_MHZ:\n\t\treturn f24_mhz;\n\tcase GEN11_RPM_CONFIG0_CRYSTAL_CLOCK_FREQ_19_2_MHZ:\n\t\treturn f19_2_mhz;\n\tcase GEN11_RPM_CONFIG0_CRYSTAL_CLOCK_FREQ_38_4_MHZ:\n\t\treturn f38_4_mhz;\n\tcase GEN11_RPM_CONFIG0_CRYSTAL_CLOCK_FREQ_25_MHZ:\n\t\treturn f25_mhz;\n\tdefault:\n\t\tMISSING_CASE(crystal_clock);\n\t\treturn 0;\n\t}\n}\n\nstatic u32 gen11_read_clock_frequency(struct intel_uncore *uncore)\n{\n\tu32 ctc_reg = intel_uncore_read(uncore, CTC_MODE);\n\tu32 freq = 0;\n\n\t \n\tif ((ctc_reg & CTC_SOURCE_PARAMETER_MASK) == CTC_SOURCE_DIVIDE_LOGIC) {\n\t\tfreq = read_reference_ts_freq(uncore);\n\t} else {\n\t\tu32 c0 = intel_uncore_read(uncore, RPM_CONFIG0);\n\n\t\tfreq = gen11_get_crystal_clock_freq(uncore, c0);\n\n\t\t \n\t\tfreq >>= 3 - ((c0 & GEN10_RPM_CONFIG0_CTC_SHIFT_PARAMETER_MASK) >>\n\t\t\t      GEN10_RPM_CONFIG0_CTC_SHIFT_PARAMETER_SHIFT);\n\t}\n\n\treturn freq;\n}\n\nstatic u32 gen9_read_clock_frequency(struct intel_uncore *uncore)\n{\n\tu32 ctc_reg = intel_uncore_read(uncore, CTC_MODE);\n\tu32 freq = 0;\n\n\tif ((ctc_reg & CTC_SOURCE_PARAMETER_MASK) == CTC_SOURCE_DIVIDE_LOGIC) {\n\t\tfreq = read_reference_ts_freq(uncore);\n\t} else {\n\t\tfreq = IS_GEN9_LP(uncore->i915) ? 19200000 : 24000000;\n\n\t\t \n\t\tfreq >>= 3 - ((ctc_reg & CTC_SHIFT_PARAMETER_MASK) >>\n\t\t\t      CTC_SHIFT_PARAMETER_SHIFT);\n\t}\n\n\treturn freq;\n}\n\nstatic u32 gen6_read_clock_frequency(struct intel_uncore *uncore)\n{\n\t \n\treturn 12500000;\n}\n\nstatic u32 gen5_read_clock_frequency(struct intel_uncore *uncore)\n{\n\t \n\treturn 1000000000 / 1000;\n}\n\nstatic u32 g4x_read_clock_frequency(struct intel_uncore *uncore)\n{\n\t \n\treturn 1000000000 / 1024;\n}\n\nstatic u32 gen4_read_clock_frequency(struct intel_uncore *uncore)\n{\n\t \n\treturn RUNTIME_INFO(uncore->i915)->rawclk_freq * 1000;\n}\n\nstatic u32 read_clock_frequency(struct intel_uncore *uncore)\n{\n\tif (GRAPHICS_VER(uncore->i915) >= 11)\n\t\treturn gen11_read_clock_frequency(uncore);\n\telse if (GRAPHICS_VER(uncore->i915) >= 9)\n\t\treturn gen9_read_clock_frequency(uncore);\n\telse if (GRAPHICS_VER(uncore->i915) >= 6)\n\t\treturn gen6_read_clock_frequency(uncore);\n\telse if (GRAPHICS_VER(uncore->i915) == 5)\n\t\treturn gen5_read_clock_frequency(uncore);\n\telse if (IS_G4X(uncore->i915))\n\t\treturn g4x_read_clock_frequency(uncore);\n\telse if (GRAPHICS_VER(uncore->i915) == 4)\n\t\treturn gen4_read_clock_frequency(uncore);\n\telse\n\t\treturn 0;\n}\n\nvoid intel_gt_init_clock_frequency(struct intel_gt *gt)\n{\n\tgt->clock_frequency = read_clock_frequency(gt->uncore);\n\n\t \n\tif (GRAPHICS_VER(gt->i915) == 11)\n\t\tgt->clock_period_ns = NSEC_PER_SEC / 13750000;\n\telse if (gt->clock_frequency)\n\t\tgt->clock_period_ns = intel_gt_clock_interval_to_ns(gt, 1);\n\n\tGT_TRACE(gt,\n\t\t \"Using clock frequency: %dkHz, period: %dns, wrap: %lldms\\n\",\n\t\t gt->clock_frequency / 1000,\n\t\t gt->clock_period_ns,\n\t\t div_u64(mul_u32_u32(gt->clock_period_ns, S32_MAX),\n\t\t\t USEC_PER_SEC));\n}\n\n#if IS_ENABLED(CONFIG_DRM_I915_DEBUG_GEM)\nvoid intel_gt_check_clock_frequency(const struct intel_gt *gt)\n{\n\tif (gt->clock_frequency != read_clock_frequency(gt->uncore)) {\n\t\tgt_err(gt, \"GT clock frequency changed, was %uHz, now %uHz!\\n\",\n\t\t       gt->clock_frequency,\n\t\t       read_clock_frequency(gt->uncore));\n\t}\n}\n#endif\n\nstatic u64 div_u64_roundup(u64 nom, u32 den)\n{\n\treturn div_u64(nom + den - 1, den);\n}\n\nu64 intel_gt_clock_interval_to_ns(const struct intel_gt *gt, u64 count)\n{\n\treturn div_u64_roundup(count * NSEC_PER_SEC, gt->clock_frequency);\n}\n\nu64 intel_gt_pm_interval_to_ns(const struct intel_gt *gt, u64 count)\n{\n\treturn intel_gt_clock_interval_to_ns(gt, 16 * count);\n}\n\nu64 intel_gt_ns_to_clock_interval(const struct intel_gt *gt, u64 ns)\n{\n\treturn div_u64_roundup(gt->clock_frequency * ns, NSEC_PER_SEC);\n}\n\nu64 intel_gt_ns_to_pm_interval(const struct intel_gt *gt, u64 ns)\n{\n\tu64 val;\n\n\t \n\tval = div_u64_roundup(intel_gt_ns_to_clock_interval(gt, ns), 16);\n\tif (GRAPHICS_VER(gt->i915) == 6)\n\t\tval = div_u64_roundup(val, 25) * 25;\n\n\treturn val;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}