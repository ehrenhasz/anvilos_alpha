{
  "module_name": "intel_gt.h",
  "hash_id": "dfc46d128797794811fe37435f35acd87ad3920a41b2be24daf108b4062b9474",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/i915/gt/intel_gt.h",
  "human_readable_source": " \n \n\n#ifndef __INTEL_GT__\n#define __INTEL_GT__\n\n#include \"i915_drv.h\"\n#include \"intel_engine_types.h\"\n#include \"intel_gt_types.h\"\n#include \"intel_reset.h\"\n\nstruct drm_i915_private;\nstruct drm_printer;\n\n#define GT_TRACE(gt, fmt, ...) do {\t\t\t\t\t\\\n\tconst struct intel_gt *gt__ __maybe_unused = (gt);\t\t\\\n\tGEM_TRACE(\"%s \" fmt, dev_name(gt__->i915->drm.dev),\t\t\\\n\t\t  ##__VA_ARGS__);\t\t\t\t\t\\\n} while (0)\n\nstatic inline bool gt_is_root(struct intel_gt *gt)\n{\n\treturn !gt->info.id;\n}\n\nstatic inline bool intel_gt_needs_wa_22016122933(struct intel_gt *gt)\n{\n\treturn MEDIA_VER_FULL(gt->i915) == IP_VER(13, 0) && gt->type == GT_MEDIA;\n}\n\nstatic inline struct intel_gt *uc_to_gt(struct intel_uc *uc)\n{\n\treturn container_of(uc, struct intel_gt, uc);\n}\n\nstatic inline struct intel_gt *guc_to_gt(struct intel_guc *guc)\n{\n\treturn container_of(guc, struct intel_gt, uc.guc);\n}\n\nstatic inline struct intel_gt *huc_to_gt(struct intel_huc *huc)\n{\n\treturn container_of(huc, struct intel_gt, uc.huc);\n}\n\nstatic inline struct intel_gt *gsc_uc_to_gt(struct intel_gsc_uc *gsc_uc)\n{\n\treturn container_of(gsc_uc, struct intel_gt, uc.gsc);\n}\n\nstatic inline struct intel_gt *gsc_to_gt(struct intel_gsc *gsc)\n{\n\treturn container_of(gsc, struct intel_gt, gsc);\n}\n\nvoid intel_gt_common_init_early(struct intel_gt *gt);\nint intel_root_gt_init_early(struct drm_i915_private *i915);\nint intel_gt_assign_ggtt(struct intel_gt *gt);\nint intel_gt_init_mmio(struct intel_gt *gt);\nint __must_check intel_gt_init_hw(struct intel_gt *gt);\nint intel_gt_init(struct intel_gt *gt);\nvoid intel_gt_driver_register(struct intel_gt *gt);\n\nvoid intel_gt_driver_unregister(struct intel_gt *gt);\nvoid intel_gt_driver_remove(struct intel_gt *gt);\nvoid intel_gt_driver_release(struct intel_gt *gt);\nvoid intel_gt_driver_late_release_all(struct drm_i915_private *i915);\n\nint intel_gt_wait_for_idle(struct intel_gt *gt, long timeout);\n\nvoid intel_gt_check_and_clear_faults(struct intel_gt *gt);\ni915_reg_t intel_gt_perf_limit_reasons_reg(struct intel_gt *gt);\nvoid intel_gt_clear_error_registers(struct intel_gt *gt,\n\t\t\t\t    intel_engine_mask_t engine_mask);\n\nvoid intel_gt_flush_ggtt_writes(struct intel_gt *gt);\nvoid intel_gt_chipset_flush(struct intel_gt *gt);\n\nstatic inline u32 intel_gt_scratch_offset(const struct intel_gt *gt,\n\t\t\t\t\t  enum intel_gt_scratch_field field)\n{\n\treturn i915_ggtt_offset(gt->scratch) + field;\n}\n\nstatic inline bool intel_gt_has_unrecoverable_error(const struct intel_gt *gt)\n{\n\treturn test_bit(I915_WEDGED_ON_INIT, &gt->reset.flags) ||\n\t       test_bit(I915_WEDGED_ON_FINI, &gt->reset.flags);\n}\n\nstatic inline bool intel_gt_is_wedged(const struct intel_gt *gt)\n{\n\tGEM_BUG_ON(intel_gt_has_unrecoverable_error(gt) &&\n\t\t   !test_bit(I915_WEDGED, &gt->reset.flags));\n\n\treturn unlikely(test_bit(I915_WEDGED, &gt->reset.flags));\n}\n\nint intel_gt_probe_all(struct drm_i915_private *i915);\nint intel_gt_tiles_init(struct drm_i915_private *i915);\nvoid intel_gt_release_all(struct drm_i915_private *i915);\n\n#define for_each_gt(gt__, i915__, id__) \\\n\tfor ((id__) = 0; \\\n\t     (id__) < I915_MAX_GT; \\\n\t     (id__)++) \\\n\t\tfor_each_if(((gt__) = (i915__)->gt[(id__)]))\n\nvoid intel_gt_info_print(const struct intel_gt_info *info,\n\t\t\t struct drm_printer *p);\n\nvoid intel_gt_watchdog_work(struct work_struct *work);\n\nenum i915_map_type intel_gt_coherent_map_type(struct intel_gt *gt,\n\t\t\t\t\t      struct drm_i915_gem_object *obj,\n\t\t\t\t\t      bool always_coherent);\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}