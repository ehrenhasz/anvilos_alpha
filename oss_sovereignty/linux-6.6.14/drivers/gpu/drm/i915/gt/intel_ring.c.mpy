{
  "module_name": "intel_ring.c",
  "hash_id": "11828903a530e7006538a62613763cc9e20770fef4b461412fd6877c05049420",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/i915/gt/intel_ring.c",
  "human_readable_source": "\n \n\n#include \"gem/i915_gem_internal.h\"\n#include \"gem/i915_gem_lmem.h\"\n#include \"gem/i915_gem_object.h\"\n\n#include \"i915_drv.h\"\n#include \"i915_vma.h\"\n#include \"intel_engine.h\"\n#include \"intel_engine_regs.h\"\n#include \"intel_gpu_commands.h\"\n#include \"intel_ring.h\"\n#include \"intel_gt.h\"\n#include \"intel_timeline.h\"\n\nunsigned int intel_ring_update_space(struct intel_ring *ring)\n{\n\tunsigned int space;\n\n\tspace = __intel_ring_space(ring->head, ring->emit, ring->size);\n\n\tring->space = space;\n\treturn space;\n}\n\nvoid __intel_ring_pin(struct intel_ring *ring)\n{\n\tGEM_BUG_ON(!atomic_read(&ring->pin_count));\n\tatomic_inc(&ring->pin_count);\n}\n\nint intel_ring_pin(struct intel_ring *ring, struct i915_gem_ww_ctx *ww)\n{\n\tstruct i915_vma *vma = ring->vma;\n\tunsigned int flags;\n\tvoid *addr;\n\tint ret;\n\n\tif (atomic_fetch_inc(&ring->pin_count))\n\t\treturn 0;\n\n\t \n\tflags = PIN_OFFSET_BIAS | i915_ggtt_pin_bias(vma);\n\n\tif (i915_gem_object_is_stolen(vma->obj))\n\t\tflags |= PIN_MAPPABLE;\n\telse\n\t\tflags |= PIN_HIGH;\n\n\tret = i915_ggtt_pin(vma, ww, 0, flags);\n\tif (unlikely(ret))\n\t\tgoto err_unpin;\n\n\tif (i915_vma_is_map_and_fenceable(vma) && !HAS_LLC(vma->vm->i915)) {\n\t\taddr = (void __force *)i915_vma_pin_iomap(vma);\n\t} else {\n\t\tint type = intel_gt_coherent_map_type(vma->vm->gt, vma->obj, false);\n\n\t\taddr = i915_gem_object_pin_map(vma->obj, type);\n\t}\n\n\tif (IS_ERR(addr)) {\n\t\tret = PTR_ERR(addr);\n\t\tgoto err_ring;\n\t}\n\n\ti915_vma_make_unshrinkable(vma);\n\n\t \n\tintel_ring_reset(ring, ring->emit);\n\n\tring->vaddr = addr;\n\treturn 0;\n\nerr_ring:\n\ti915_vma_unpin(vma);\nerr_unpin:\n\tatomic_dec(&ring->pin_count);\n\treturn ret;\n}\n\nvoid intel_ring_reset(struct intel_ring *ring, u32 tail)\n{\n\ttail = intel_ring_wrap(ring, tail);\n\tring->tail = tail;\n\tring->head = tail;\n\tring->emit = tail;\n\tintel_ring_update_space(ring);\n}\n\nvoid intel_ring_unpin(struct intel_ring *ring)\n{\n\tstruct i915_vma *vma = ring->vma;\n\n\tif (!atomic_dec_and_test(&ring->pin_count))\n\t\treturn;\n\n\ti915_vma_unset_ggtt_write(vma);\n\tif (i915_vma_is_map_and_fenceable(vma) && !HAS_LLC(vma->vm->i915))\n\t\ti915_vma_unpin_iomap(vma);\n\telse\n\t\ti915_gem_object_unpin_map(vma->obj);\n\n\ti915_vma_make_purgeable(vma);\n\ti915_vma_unpin(vma);\n}\n\nstatic struct i915_vma *create_ring_vma(struct i915_ggtt *ggtt, int size)\n{\n\tstruct i915_address_space *vm = &ggtt->vm;\n\tstruct drm_i915_private *i915 = vm->i915;\n\tstruct drm_i915_gem_object *obj;\n\tstruct i915_vma *vma;\n\n\tobj = i915_gem_object_create_lmem(i915, size, I915_BO_ALLOC_VOLATILE |\n\t\t\t\t\t  I915_BO_ALLOC_PM_VOLATILE);\n\tif (IS_ERR(obj) && i915_ggtt_has_aperture(ggtt) && !HAS_LLC(i915))\n\t\tobj = i915_gem_object_create_stolen(i915, size);\n\tif (IS_ERR(obj))\n\t\tobj = i915_gem_object_create_internal(i915, size);\n\tif (IS_ERR(obj))\n\t\treturn ERR_CAST(obj);\n\n\t \n\tif (vm->has_read_only)\n\t\ti915_gem_object_set_readonly(obj);\n\n\tvma = i915_vma_instance(obj, vm, NULL);\n\tif (IS_ERR(vma))\n\t\tgoto err;\n\n\treturn vma;\n\nerr:\n\ti915_gem_object_put(obj);\n\treturn vma;\n}\n\nstruct intel_ring *\nintel_engine_create_ring(struct intel_engine_cs *engine, int size)\n{\n\tstruct drm_i915_private *i915 = engine->i915;\n\tstruct intel_ring *ring;\n\tstruct i915_vma *vma;\n\n\tGEM_BUG_ON(!is_power_of_2(size));\n\tGEM_BUG_ON(RING_CTL_SIZE(size) & ~RING_NR_PAGES);\n\n\tring = kzalloc(sizeof(*ring), GFP_KERNEL);\n\tif (!ring)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tkref_init(&ring->ref);\n\tring->size = size;\n\tring->wrap = BITS_PER_TYPE(ring->size) - ilog2(size);\n\n\t \n\tring->effective_size = size;\n\tif (IS_I830(i915) || IS_I845G(i915))\n\t\tring->effective_size -= 2 * CACHELINE_BYTES;\n\n\tintel_ring_update_space(ring);\n\n\tvma = create_ring_vma(engine->gt->ggtt, size);\n\tif (IS_ERR(vma)) {\n\t\tkfree(ring);\n\t\treturn ERR_CAST(vma);\n\t}\n\tring->vma = vma;\n\n\treturn ring;\n}\n\nvoid intel_ring_free(struct kref *ref)\n{\n\tstruct intel_ring *ring = container_of(ref, typeof(*ring), ref);\n\n\ti915_vma_put(ring->vma);\n\tkfree(ring);\n}\n\nstatic noinline int\nwait_for_space(struct intel_ring *ring,\n\t       struct intel_timeline *tl,\n\t       unsigned int bytes)\n{\n\tstruct i915_request *target;\n\tlong timeout;\n\n\tif (intel_ring_update_space(ring) >= bytes)\n\t\treturn 0;\n\n\tGEM_BUG_ON(list_empty(&tl->requests));\n\tlist_for_each_entry(target, &tl->requests, link) {\n\t\tif (target->ring != ring)\n\t\t\tcontinue;\n\n\t\t \n\t\tif (bytes <= __intel_ring_space(target->postfix,\n\t\t\t\t\t\tring->emit, ring->size))\n\t\t\tbreak;\n\t}\n\n\tif (GEM_WARN_ON(&target->link == &tl->requests))\n\t\treturn -ENOSPC;\n\n\ttimeout = i915_request_wait(target,\n\t\t\t\t    I915_WAIT_INTERRUPTIBLE,\n\t\t\t\t    MAX_SCHEDULE_TIMEOUT);\n\tif (timeout < 0)\n\t\treturn timeout;\n\n\ti915_request_retire_upto(target);\n\n\tintel_ring_update_space(ring);\n\tGEM_BUG_ON(ring->space < bytes);\n\treturn 0;\n}\n\nu32 *intel_ring_begin(struct i915_request *rq, unsigned int num_dwords)\n{\n\tstruct intel_ring *ring = rq->ring;\n\tconst unsigned int remain_usable = ring->effective_size - ring->emit;\n\tconst unsigned int bytes = num_dwords * sizeof(u32);\n\tunsigned int need_wrap = 0;\n\tunsigned int total_bytes;\n\tu32 *cs;\n\n\t \n\tGEM_BUG_ON(num_dwords & 1);\n\n\ttotal_bytes = bytes + rq->reserved_space;\n\tGEM_BUG_ON(total_bytes > ring->effective_size);\n\n\tif (unlikely(total_bytes > remain_usable)) {\n\t\tconst int remain_actual = ring->size - ring->emit;\n\n\t\tif (bytes > remain_usable) {\n\t\t\t \n\t\t\ttotal_bytes += remain_actual;\n\t\t\tneed_wrap = remain_actual | 1;\n\t\t} else  {\n\t\t\t \n\t\t\ttotal_bytes = rq->reserved_space + remain_actual;\n\t\t}\n\t}\n\n\tif (unlikely(total_bytes > ring->space)) {\n\t\tint ret;\n\n\t\t \n\t\tGEM_BUG_ON(!rq->reserved_space);\n\n\t\tret = wait_for_space(ring,\n\t\t\t\t     i915_request_timeline(rq),\n\t\t\t\t     total_bytes);\n\t\tif (unlikely(ret))\n\t\t\treturn ERR_PTR(ret);\n\t}\n\n\tif (unlikely(need_wrap)) {\n\t\tneed_wrap &= ~1;\n\t\tGEM_BUG_ON(need_wrap > ring->space);\n\t\tGEM_BUG_ON(ring->emit + need_wrap > ring->size);\n\t\tGEM_BUG_ON(!IS_ALIGNED(need_wrap, sizeof(u64)));\n\n\t\t \n\t\tmemset64(ring->vaddr + ring->emit, 0, need_wrap / sizeof(u64));\n\t\tring->space -= need_wrap;\n\t\tring->emit = 0;\n\t}\n\n\tGEM_BUG_ON(ring->emit > ring->size - bytes);\n\tGEM_BUG_ON(ring->space < bytes);\n\tcs = ring->vaddr + ring->emit;\n\tif (IS_ENABLED(CONFIG_DRM_I915_DEBUG_GEM))\n\t\tmemset32(cs, POISON_INUSE, bytes / sizeof(*cs));\n\tring->emit += bytes;\n\tring->space -= bytes;\n\n\treturn cs;\n}\n\n \nint intel_ring_cacheline_align(struct i915_request *rq)\n{\n\tint num_dwords;\n\tvoid *cs;\n\n\tnum_dwords = (rq->ring->emit & (CACHELINE_BYTES - 1)) / sizeof(u32);\n\tif (num_dwords == 0)\n\t\treturn 0;\n\n\tnum_dwords = CACHELINE_DWORDS - num_dwords;\n\tGEM_BUG_ON(num_dwords & 1);\n\n\tcs = intel_ring_begin(rq, num_dwords);\n\tif (IS_ERR(cs))\n\t\treturn PTR_ERR(cs);\n\n\tmemset64(cs, (u64)MI_NOOP << 32 | MI_NOOP, num_dwords / 2);\n\tintel_ring_advance(rq, cs + num_dwords);\n\n\tGEM_BUG_ON(rq->ring->emit & (CACHELINE_BYTES - 1));\n\treturn 0;\n}\n\n#if IS_ENABLED(CONFIG_DRM_I915_SELFTEST)\n#include \"selftest_ring.c\"\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}