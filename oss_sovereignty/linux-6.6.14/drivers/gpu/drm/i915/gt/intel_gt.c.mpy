{
  "module_name": "intel_gt.c",
  "hash_id": "c83ea05fa96df392d63fd8d0696e0bdf84073afeaf15902fd7fdabee9b3115cd",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/i915/gt/intel_gt.c",
  "human_readable_source": "\n \n\n#include <drm/drm_managed.h>\n#include <drm/intel-gtt.h>\n\n#include \"gem/i915_gem_internal.h\"\n#include \"gem/i915_gem_lmem.h\"\n\n#include \"i915_drv.h\"\n#include \"i915_perf_oa_regs.h\"\n#include \"i915_reg.h\"\n#include \"intel_context.h\"\n#include \"intel_engine_pm.h\"\n#include \"intel_engine_regs.h\"\n#include \"intel_ggtt_gmch.h\"\n#include \"intel_gt.h\"\n#include \"intel_gt_buffer_pool.h\"\n#include \"intel_gt_clock_utils.h\"\n#include \"intel_gt_debugfs.h\"\n#include \"intel_gt_mcr.h\"\n#include \"intel_gt_pm.h\"\n#include \"intel_gt_print.h\"\n#include \"intel_gt_regs.h\"\n#include \"intel_gt_requests.h\"\n#include \"intel_migrate.h\"\n#include \"intel_mocs.h\"\n#include \"intel_pci_config.h\"\n#include \"intel_rc6.h\"\n#include \"intel_renderstate.h\"\n#include \"intel_rps.h\"\n#include \"intel_sa_media.h\"\n#include \"intel_gt_sysfs.h\"\n#include \"intel_tlb.h\"\n#include \"intel_uncore.h\"\n#include \"shmem_utils.h\"\n\nvoid intel_gt_common_init_early(struct intel_gt *gt)\n{\n\tspin_lock_init(gt->irq_lock);\n\n\tINIT_LIST_HEAD(&gt->closed_vma);\n\tspin_lock_init(&gt->closed_lock);\n\n\tinit_llist_head(&gt->watchdog.list);\n\tINIT_WORK(&gt->watchdog.work, intel_gt_watchdog_work);\n\n\tintel_gt_init_buffer_pool(gt);\n\tintel_gt_init_reset(gt);\n\tintel_gt_init_requests(gt);\n\tintel_gt_init_timelines(gt);\n\tintel_gt_init_tlb(gt);\n\tintel_gt_pm_init_early(gt);\n\n\tintel_wopcm_init_early(&gt->wopcm);\n\tintel_uc_init_early(&gt->uc);\n\tintel_rps_init_early(&gt->rps);\n}\n\n \nint intel_root_gt_init_early(struct drm_i915_private *i915)\n{\n\tstruct intel_gt *gt = to_gt(i915);\n\n\tgt->i915 = i915;\n\tgt->uncore = &i915->uncore;\n\tgt->irq_lock = drmm_kzalloc(&i915->drm, sizeof(*gt->irq_lock), GFP_KERNEL);\n\tif (!gt->irq_lock)\n\t\treturn -ENOMEM;\n\n\tintel_gt_common_init_early(gt);\n\n\treturn 0;\n}\n\nstatic int intel_gt_probe_lmem(struct intel_gt *gt)\n{\n\tstruct drm_i915_private *i915 = gt->i915;\n\tunsigned int instance = gt->info.id;\n\tint id = INTEL_REGION_LMEM_0 + instance;\n\tstruct intel_memory_region *mem;\n\tint err;\n\n\tmem = intel_gt_setup_lmem(gt);\n\tif (IS_ERR(mem)) {\n\t\terr = PTR_ERR(mem);\n\t\tif (err == -ENODEV)\n\t\t\treturn 0;\n\n\t\tgt_err(gt, \"Failed to setup region(%d) type=%d\\n\",\n\t\t       err, INTEL_MEMORY_LOCAL);\n\t\treturn err;\n\t}\n\n\tmem->id = id;\n\tmem->instance = instance;\n\n\tintel_memory_region_set_name(mem, \"local%u\", mem->instance);\n\n\tGEM_BUG_ON(!HAS_REGION(i915, id));\n\tGEM_BUG_ON(i915->mm.regions[id]);\n\ti915->mm.regions[id] = mem;\n\n\treturn 0;\n}\n\nint intel_gt_assign_ggtt(struct intel_gt *gt)\n{\n\t \n\tif (gt->type == GT_MEDIA) {\n\t\tgt->ggtt = to_gt(gt->i915)->ggtt;\n\t} else {\n\t\tgt->ggtt = i915_ggtt_create(gt->i915);\n\t\tif (IS_ERR(gt->ggtt))\n\t\t\treturn PTR_ERR(gt->ggtt);\n\t}\n\n\tlist_add_tail(&gt->ggtt_link, &gt->ggtt->gt_list);\n\n\treturn 0;\n}\n\nint intel_gt_init_mmio(struct intel_gt *gt)\n{\n\tintel_gt_init_clock_frequency(gt);\n\n\tintel_uc_init_mmio(&gt->uc);\n\tintel_sseu_info_init(gt);\n\tintel_gt_mcr_init(gt);\n\n\treturn intel_engines_init_mmio(gt);\n}\n\nstatic void init_unused_ring(struct intel_gt *gt, u32 base)\n{\n\tstruct intel_uncore *uncore = gt->uncore;\n\n\tintel_uncore_write(uncore, RING_CTL(base), 0);\n\tintel_uncore_write(uncore, RING_HEAD(base), 0);\n\tintel_uncore_write(uncore, RING_TAIL(base), 0);\n\tintel_uncore_write(uncore, RING_START(base), 0);\n}\n\nstatic void init_unused_rings(struct intel_gt *gt)\n{\n\tstruct drm_i915_private *i915 = gt->i915;\n\n\tif (IS_I830(i915)) {\n\t\tinit_unused_ring(gt, PRB1_BASE);\n\t\tinit_unused_ring(gt, SRB0_BASE);\n\t\tinit_unused_ring(gt, SRB1_BASE);\n\t\tinit_unused_ring(gt, SRB2_BASE);\n\t\tinit_unused_ring(gt, SRB3_BASE);\n\t} else if (GRAPHICS_VER(i915) == 2) {\n\t\tinit_unused_ring(gt, SRB0_BASE);\n\t\tinit_unused_ring(gt, SRB1_BASE);\n\t} else if (GRAPHICS_VER(i915) == 3) {\n\t\tinit_unused_ring(gt, PRB1_BASE);\n\t\tinit_unused_ring(gt, PRB2_BASE);\n\t}\n}\n\nint intel_gt_init_hw(struct intel_gt *gt)\n{\n\tstruct drm_i915_private *i915 = gt->i915;\n\tstruct intel_uncore *uncore = gt->uncore;\n\tint ret;\n\n\tgt->last_init_time = ktime_get();\n\n\t \n\tintel_uncore_forcewake_get(uncore, FORCEWAKE_ALL);\n\n\tif (HAS_EDRAM(i915) && GRAPHICS_VER(i915) < 9)\n\t\tintel_uncore_rmw(uncore, HSW_IDICR, 0, IDIHASHMSK(0xf));\n\n\tif (IS_HASWELL(i915))\n\t\tintel_uncore_write(uncore,\n\t\t\t\t   HSW_MI_PREDICATE_RESULT_2,\n\t\t\t\t   IS_HASWELL_GT3(i915) ?\n\t\t\t\t   LOWER_SLICE_ENABLED : LOWER_SLICE_DISABLED);\n\n\t \n\tintel_gt_apply_workarounds(gt);\n\t \n\tintel_gt_verify_workarounds(gt, \"init\");\n\n\tintel_gt_init_swizzling(gt);\n\n\t \n\tinit_unused_rings(gt);\n\n\tret = i915_ppgtt_init_hw(gt);\n\tif (ret) {\n\t\tgt_err(gt, \"Enabling PPGTT failed (%d)\\n\", ret);\n\t\tgoto out;\n\t}\n\n\t \n\tret = intel_uc_init_hw(&gt->uc);\n\tif (ret) {\n\t\tgt_probe_error(gt, \"Enabling uc failed (%d)\\n\", ret);\n\t\tgoto out;\n\t}\n\n\tintel_mocs_init(gt);\n\nout:\n\tintel_uncore_forcewake_put(uncore, FORCEWAKE_ALL);\n\treturn ret;\n}\n\nstatic void gen6_clear_engine_error_register(struct intel_engine_cs *engine)\n{\n\tGEN6_RING_FAULT_REG_RMW(engine, RING_FAULT_VALID, 0);\n\tGEN6_RING_FAULT_REG_POSTING_READ(engine);\n}\n\ni915_reg_t intel_gt_perf_limit_reasons_reg(struct intel_gt *gt)\n{\n\t \n\tif (GRAPHICS_VER(gt->i915) < 11)\n\t\treturn INVALID_MMIO_REG;\n\n\treturn gt->type == GT_MEDIA ?\n\t\tMTL_MEDIA_PERF_LIMIT_REASONS : GT0_PERF_LIMIT_REASONS;\n}\n\nvoid\nintel_gt_clear_error_registers(struct intel_gt *gt,\n\t\t\t       intel_engine_mask_t engine_mask)\n{\n\tstruct drm_i915_private *i915 = gt->i915;\n\tstruct intel_uncore *uncore = gt->uncore;\n\tu32 eir;\n\n\tif (GRAPHICS_VER(i915) != 2)\n\t\tintel_uncore_write(uncore, PGTBL_ER, 0);\n\n\tif (GRAPHICS_VER(i915) < 4)\n\t\tintel_uncore_write(uncore, IPEIR(RENDER_RING_BASE), 0);\n\telse\n\t\tintel_uncore_write(uncore, IPEIR_I965, 0);\n\n\tintel_uncore_write(uncore, EIR, 0);\n\teir = intel_uncore_read(uncore, EIR);\n\tif (eir) {\n\t\t \n\t\tgt_dbg(gt, \"EIR stuck: 0x%08x, masking\\n\", eir);\n\t\tintel_uncore_rmw(uncore, EMR, 0, eir);\n\t\tintel_uncore_write(uncore, GEN2_IIR,\n\t\t\t\t   I915_MASTER_ERROR_INTERRUPT);\n\t}\n\n\tif (GRAPHICS_VER_FULL(i915) >= IP_VER(12, 50)) {\n\t\tintel_gt_mcr_multicast_rmw(gt, XEHP_RING_FAULT_REG,\n\t\t\t\t\t   RING_FAULT_VALID, 0);\n\t\tintel_gt_mcr_read_any(gt, XEHP_RING_FAULT_REG);\n\t} else if (GRAPHICS_VER(i915) >= 12) {\n\t\tintel_uncore_rmw(uncore, GEN12_RING_FAULT_REG, RING_FAULT_VALID, 0);\n\t\tintel_uncore_posting_read(uncore, GEN12_RING_FAULT_REG);\n\t} else if (GRAPHICS_VER(i915) >= 8) {\n\t\tintel_uncore_rmw(uncore, GEN8_RING_FAULT_REG, RING_FAULT_VALID, 0);\n\t\tintel_uncore_posting_read(uncore, GEN8_RING_FAULT_REG);\n\t} else if (GRAPHICS_VER(i915) >= 6) {\n\t\tstruct intel_engine_cs *engine;\n\t\tenum intel_engine_id id;\n\n\t\tfor_each_engine_masked(engine, gt, engine_mask, id)\n\t\t\tgen6_clear_engine_error_register(engine);\n\t}\n}\n\nstatic void gen6_check_faults(struct intel_gt *gt)\n{\n\tstruct intel_engine_cs *engine;\n\tenum intel_engine_id id;\n\tu32 fault;\n\n\tfor_each_engine(engine, gt, id) {\n\t\tfault = GEN6_RING_FAULT_REG_READ(engine);\n\t\tif (fault & RING_FAULT_VALID) {\n\t\t\tgt_dbg(gt, \"Unexpected fault\\n\"\n\t\t\t       \"\\tAddr: 0x%08lx\\n\"\n\t\t\t       \"\\tAddress space: %s\\n\"\n\t\t\t       \"\\tSource ID: %d\\n\"\n\t\t\t       \"\\tType: %d\\n\",\n\t\t\t       fault & PAGE_MASK,\n\t\t\t       fault & RING_FAULT_GTTSEL_MASK ?\n\t\t\t       \"GGTT\" : \"PPGTT\",\n\t\t\t       RING_FAULT_SRCID(fault),\n\t\t\t       RING_FAULT_FAULT_TYPE(fault));\n\t\t}\n\t}\n}\n\nstatic void xehp_check_faults(struct intel_gt *gt)\n{\n\tu32 fault;\n\n\t \n\tfault = intel_gt_mcr_read_any(gt, XEHP_RING_FAULT_REG);\n\tif (fault & RING_FAULT_VALID) {\n\t\tu32 fault_data0, fault_data1;\n\t\tu64 fault_addr;\n\n\t\tfault_data0 = intel_gt_mcr_read_any(gt, XEHP_FAULT_TLB_DATA0);\n\t\tfault_data1 = intel_gt_mcr_read_any(gt, XEHP_FAULT_TLB_DATA1);\n\n\t\tfault_addr = ((u64)(fault_data1 & FAULT_VA_HIGH_BITS) << 44) |\n\t\t\t     ((u64)fault_data0 << 12);\n\n\t\tgt_dbg(gt, \"Unexpected fault\\n\"\n\t\t       \"\\tAddr: 0x%08x_%08x\\n\"\n\t\t       \"\\tAddress space: %s\\n\"\n\t\t       \"\\tEngine ID: %d\\n\"\n\t\t       \"\\tSource ID: %d\\n\"\n\t\t       \"\\tType: %d\\n\",\n\t\t       upper_32_bits(fault_addr), lower_32_bits(fault_addr),\n\t\t       fault_data1 & FAULT_GTT_SEL ? \"GGTT\" : \"PPGTT\",\n\t\t       GEN8_RING_FAULT_ENGINE_ID(fault),\n\t\t       RING_FAULT_SRCID(fault),\n\t\t       RING_FAULT_FAULT_TYPE(fault));\n\t}\n}\n\nstatic void gen8_check_faults(struct intel_gt *gt)\n{\n\tstruct intel_uncore *uncore = gt->uncore;\n\ti915_reg_t fault_reg, fault_data0_reg, fault_data1_reg;\n\tu32 fault;\n\n\tif (GRAPHICS_VER(gt->i915) >= 12) {\n\t\tfault_reg = GEN12_RING_FAULT_REG;\n\t\tfault_data0_reg = GEN12_FAULT_TLB_DATA0;\n\t\tfault_data1_reg = GEN12_FAULT_TLB_DATA1;\n\t} else {\n\t\tfault_reg = GEN8_RING_FAULT_REG;\n\t\tfault_data0_reg = GEN8_FAULT_TLB_DATA0;\n\t\tfault_data1_reg = GEN8_FAULT_TLB_DATA1;\n\t}\n\n\tfault = intel_uncore_read(uncore, fault_reg);\n\tif (fault & RING_FAULT_VALID) {\n\t\tu32 fault_data0, fault_data1;\n\t\tu64 fault_addr;\n\n\t\tfault_data0 = intel_uncore_read(uncore, fault_data0_reg);\n\t\tfault_data1 = intel_uncore_read(uncore, fault_data1_reg);\n\n\t\tfault_addr = ((u64)(fault_data1 & FAULT_VA_HIGH_BITS) << 44) |\n\t\t\t     ((u64)fault_data0 << 12);\n\n\t\tgt_dbg(gt, \"Unexpected fault\\n\"\n\t\t       \"\\tAddr: 0x%08x_%08x\\n\"\n\t\t       \"\\tAddress space: %s\\n\"\n\t\t       \"\\tEngine ID: %d\\n\"\n\t\t       \"\\tSource ID: %d\\n\"\n\t\t       \"\\tType: %d\\n\",\n\t\t       upper_32_bits(fault_addr), lower_32_bits(fault_addr),\n\t\t       fault_data1 & FAULT_GTT_SEL ? \"GGTT\" : \"PPGTT\",\n\t\t       GEN8_RING_FAULT_ENGINE_ID(fault),\n\t\t       RING_FAULT_SRCID(fault),\n\t\t       RING_FAULT_FAULT_TYPE(fault));\n\t}\n}\n\nvoid intel_gt_check_and_clear_faults(struct intel_gt *gt)\n{\n\tstruct drm_i915_private *i915 = gt->i915;\n\n\t \n\tif (GRAPHICS_VER_FULL(i915) >= IP_VER(12, 50))\n\t\txehp_check_faults(gt);\n\telse if (GRAPHICS_VER(i915) >= 8)\n\t\tgen8_check_faults(gt);\n\telse if (GRAPHICS_VER(i915) >= 6)\n\t\tgen6_check_faults(gt);\n\telse\n\t\treturn;\n\n\tintel_gt_clear_error_registers(gt, ALL_ENGINES);\n}\n\nvoid intel_gt_flush_ggtt_writes(struct intel_gt *gt)\n{\n\tstruct intel_uncore *uncore = gt->uncore;\n\tintel_wakeref_t wakeref;\n\n\t \n\n\twmb();\n\n\tif (INTEL_INFO(gt->i915)->has_coherent_ggtt)\n\t\treturn;\n\n\tintel_gt_chipset_flush(gt);\n\n\twith_intel_runtime_pm_if_in_use(uncore->rpm, wakeref) {\n\t\tunsigned long flags;\n\n\t\tspin_lock_irqsave(&uncore->lock, flags);\n\t\tintel_uncore_posting_read_fw(uncore,\n\t\t\t\t\t     RING_HEAD(RENDER_RING_BASE));\n\t\tspin_unlock_irqrestore(&uncore->lock, flags);\n\t}\n}\n\nvoid intel_gt_chipset_flush(struct intel_gt *gt)\n{\n\twmb();\n\tif (GRAPHICS_VER(gt->i915) < 6)\n\t\tintel_ggtt_gmch_flush();\n}\n\nvoid intel_gt_driver_register(struct intel_gt *gt)\n{\n\tintel_gsc_init(&gt->gsc, gt->i915);\n\n\tintel_rps_driver_register(&gt->rps);\n\n\tintel_gt_debugfs_register(gt);\n\tintel_gt_sysfs_register(gt);\n}\n\nstatic int intel_gt_init_scratch(struct intel_gt *gt, unsigned int size)\n{\n\tstruct drm_i915_private *i915 = gt->i915;\n\tstruct drm_i915_gem_object *obj;\n\tstruct i915_vma *vma;\n\tint ret;\n\n\tobj = i915_gem_object_create_lmem(i915, size,\n\t\t\t\t\t  I915_BO_ALLOC_VOLATILE |\n\t\t\t\t\t  I915_BO_ALLOC_GPU_ONLY);\n\tif (IS_ERR(obj) && !IS_METEORLAKE(i915))  \n\t\tobj = i915_gem_object_create_stolen(i915, size);\n\tif (IS_ERR(obj))\n\t\tobj = i915_gem_object_create_internal(i915, size);\n\tif (IS_ERR(obj)) {\n\t\tgt_err(gt, \"Failed to allocate scratch page\\n\");\n\t\treturn PTR_ERR(obj);\n\t}\n\n\tvma = i915_vma_instance(obj, &gt->ggtt->vm, NULL);\n\tif (IS_ERR(vma)) {\n\t\tret = PTR_ERR(vma);\n\t\tgoto err_unref;\n\t}\n\n\tret = i915_ggtt_pin(vma, NULL, 0, PIN_HIGH);\n\tif (ret)\n\t\tgoto err_unref;\n\n\tgt->scratch = i915_vma_make_unshrinkable(vma);\n\n\treturn 0;\n\nerr_unref:\n\ti915_gem_object_put(obj);\n\treturn ret;\n}\n\nstatic void intel_gt_fini_scratch(struct intel_gt *gt)\n{\n\ti915_vma_unpin_and_release(&gt->scratch, 0);\n}\n\nstatic struct i915_address_space *kernel_vm(struct intel_gt *gt)\n{\n\tif (INTEL_PPGTT(gt->i915) > INTEL_PPGTT_ALIASING)\n\t\treturn &i915_ppgtt_create(gt, I915_BO_ALLOC_PM_EARLY)->vm;\n\telse\n\t\treturn i915_vm_get(&gt->ggtt->vm);\n}\n\nstatic int __engines_record_defaults(struct intel_gt *gt)\n{\n\tstruct i915_request *requests[I915_NUM_ENGINES] = {};\n\tstruct intel_engine_cs *engine;\n\tenum intel_engine_id id;\n\tint err = 0;\n\n\t \n\n\tfor_each_engine(engine, gt, id) {\n\t\tstruct intel_renderstate so;\n\t\tstruct intel_context *ce;\n\t\tstruct i915_request *rq;\n\n\t\t \n\t\tGEM_BUG_ON(!engine->kernel_context);\n\n\t\tce = intel_context_create(engine);\n\t\tif (IS_ERR(ce)) {\n\t\t\terr = PTR_ERR(ce);\n\t\t\tgoto out;\n\t\t}\n\n\t\terr = intel_renderstate_init(&so, ce);\n\t\tif (err)\n\t\t\tgoto err;\n\n\t\trq = i915_request_create(ce);\n\t\tif (IS_ERR(rq)) {\n\t\t\terr = PTR_ERR(rq);\n\t\t\tgoto err_fini;\n\t\t}\n\n\t\terr = intel_engine_emit_ctx_wa(rq);\n\t\tif (err)\n\t\t\tgoto err_rq;\n\n\t\terr = intel_renderstate_emit(&so, rq);\n\t\tif (err)\n\t\t\tgoto err_rq;\n\nerr_rq:\n\t\trequests[id] = i915_request_get(rq);\n\t\ti915_request_add(rq);\nerr_fini:\n\t\tintel_renderstate_fini(&so, ce);\nerr:\n\t\tif (err) {\n\t\t\tintel_context_put(ce);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\t \n\tif (intel_gt_wait_for_idle(gt, I915_GEM_IDLE_TIMEOUT) == -ETIME) {\n\t\terr = -EIO;\n\t\tgoto out;\n\t}\n\n\tfor (id = 0; id < ARRAY_SIZE(requests); id++) {\n\t\tstruct i915_request *rq;\n\t\tstruct file *state;\n\n\t\trq = requests[id];\n\t\tif (!rq)\n\t\t\tcontinue;\n\n\t\tif (rq->fence.error) {\n\t\t\terr = -EIO;\n\t\t\tgoto out;\n\t\t}\n\n\t\tGEM_BUG_ON(!test_bit(CONTEXT_ALLOC_BIT, &rq->context->flags));\n\t\tif (!rq->context->state)\n\t\t\tcontinue;\n\n\t\t \n\t\tstate = shmem_create_from_object(rq->context->state->obj);\n\t\tif (IS_ERR(state)) {\n\t\t\terr = PTR_ERR(state);\n\t\t\tgoto out;\n\t\t}\n\t\trq->engine->default_state = state;\n\t}\n\nout:\n\t \n\tif (err)\n\t\tintel_gt_set_wedged(gt);\n\n\tfor (id = 0; id < ARRAY_SIZE(requests); id++) {\n\t\tstruct intel_context *ce;\n\t\tstruct i915_request *rq;\n\n\t\trq = requests[id];\n\t\tif (!rq)\n\t\t\tcontinue;\n\n\t\tce = rq->context;\n\t\ti915_request_put(rq);\n\t\tintel_context_put(ce);\n\t}\n\treturn err;\n}\n\nstatic int __engines_verify_workarounds(struct intel_gt *gt)\n{\n\tstruct intel_engine_cs *engine;\n\tenum intel_engine_id id;\n\tint err = 0;\n\n\tif (!IS_ENABLED(CONFIG_DRM_I915_DEBUG_GEM))\n\t\treturn 0;\n\n\tfor_each_engine(engine, gt, id) {\n\t\tif (intel_engine_verify_workarounds(engine, \"load\"))\n\t\t\terr = -EIO;\n\t}\n\n\t \n\tif (intel_gt_wait_for_idle(gt, I915_GEM_IDLE_TIMEOUT) == -ETIME)\n\t\terr = -EIO;\n\n\treturn err;\n}\n\nstatic void __intel_gt_disable(struct intel_gt *gt)\n{\n\tintel_gt_set_wedged_on_fini(gt);\n\n\tintel_gt_suspend_prepare(gt);\n\tintel_gt_suspend_late(gt);\n\n\tGEM_BUG_ON(intel_gt_pm_is_awake(gt));\n}\n\nint intel_gt_wait_for_idle(struct intel_gt *gt, long timeout)\n{\n\tlong remaining_timeout;\n\n\t \n\tif (!intel_gt_pm_is_awake(gt))\n\t\treturn 0;\n\n\twhile ((timeout = intel_gt_retire_requests_timeout(gt, timeout,\n\t\t\t\t\t\t\t   &remaining_timeout)) > 0) {\n\t\tcond_resched();\n\t\tif (signal_pending(current))\n\t\t\treturn -EINTR;\n\t}\n\n\tif (timeout)\n\t\treturn timeout;\n\n\tif (remaining_timeout < 0)\n\t\tremaining_timeout = 0;\n\n\treturn intel_uc_wait_for_idle(&gt->uc, remaining_timeout);\n}\n\nint intel_gt_init(struct intel_gt *gt)\n{\n\tint err;\n\n\terr = i915_inject_probe_error(gt->i915, -ENODEV);\n\tif (err)\n\t\treturn err;\n\n\tintel_gt_init_workarounds(gt);\n\n\t \n\tintel_uncore_forcewake_get(gt->uncore, FORCEWAKE_ALL);\n\n\terr = intel_gt_init_scratch(gt,\n\t\t\t\t    GRAPHICS_VER(gt->i915) == 2 ? SZ_256K : SZ_4K);\n\tif (err)\n\t\tgoto out_fw;\n\n\tintel_gt_pm_init(gt);\n\n\tgt->vm = kernel_vm(gt);\n\tif (!gt->vm) {\n\t\terr = -ENOMEM;\n\t\tgoto err_pm;\n\t}\n\n\tintel_set_mocs_index(gt);\n\n\terr = intel_engines_init(gt);\n\tif (err)\n\t\tgoto err_engines;\n\n\terr = intel_uc_init(&gt->uc);\n\tif (err)\n\t\tgoto err_engines;\n\n\terr = intel_gt_resume(gt);\n\tif (err)\n\t\tgoto err_uc_init;\n\n\terr = intel_gt_init_hwconfig(gt);\n\tif (err)\n\t\tgt_err(gt, \"Failed to retrieve hwconfig table: %pe\\n\", ERR_PTR(err));\n\n\terr = __engines_record_defaults(gt);\n\tif (err)\n\t\tgoto err_gt;\n\n\terr = __engines_verify_workarounds(gt);\n\tif (err)\n\t\tgoto err_gt;\n\n\terr = i915_inject_probe_error(gt->i915, -EIO);\n\tif (err)\n\t\tgoto err_gt;\n\n\tintel_uc_init_late(&gt->uc);\n\n\tintel_migrate_init(&gt->migrate, gt);\n\n\tgoto out_fw;\nerr_gt:\n\t__intel_gt_disable(gt);\n\tintel_uc_fini_hw(&gt->uc);\nerr_uc_init:\n\tintel_uc_fini(&gt->uc);\nerr_engines:\n\tintel_engines_release(gt);\n\ti915_vm_put(fetch_and_zero(&gt->vm));\nerr_pm:\n\tintel_gt_pm_fini(gt);\n\tintel_gt_fini_scratch(gt);\nout_fw:\n\tif (err)\n\t\tintel_gt_set_wedged_on_init(gt);\n\tintel_uncore_forcewake_put(gt->uncore, FORCEWAKE_ALL);\n\treturn err;\n}\n\nvoid intel_gt_driver_remove(struct intel_gt *gt)\n{\n\t__intel_gt_disable(gt);\n\n\tintel_migrate_fini(&gt->migrate);\n\tintel_uc_driver_remove(&gt->uc);\n\n\tintel_engines_release(gt);\n\n\tintel_gt_flush_buffer_pool(gt);\n}\n\nvoid intel_gt_driver_unregister(struct intel_gt *gt)\n{\n\tintel_wakeref_t wakeref;\n\n\tintel_gt_sysfs_unregister(gt);\n\tintel_rps_driver_unregister(&gt->rps);\n\tintel_gsc_fini(&gt->gsc);\n\n\t \n\tintel_gsc_uc_flush_work(&gt->uc.gsc);\n\n\t \n\tintel_gt_set_wedged_on_fini(gt);\n\n\t \n\twith_intel_runtime_pm(gt->uncore->rpm, wakeref)\n\t\t__intel_gt_reset(gt, ALL_ENGINES);\n}\n\nvoid intel_gt_driver_release(struct intel_gt *gt)\n{\n\tstruct i915_address_space *vm;\n\n\tvm = fetch_and_zero(&gt->vm);\n\tif (vm)  \n\t\ti915_vm_put(vm);\n\n\tintel_wa_list_free(&gt->wa_list);\n\tintel_gt_pm_fini(gt);\n\tintel_gt_fini_scratch(gt);\n\tintel_gt_fini_buffer_pool(gt);\n\tintel_gt_fini_hwconfig(gt);\n}\n\nvoid intel_gt_driver_late_release_all(struct drm_i915_private *i915)\n{\n\tstruct intel_gt *gt;\n\tunsigned int id;\n\n\t \n\trcu_barrier();\n\n\tfor_each_gt(gt, i915, id) {\n\t\tintel_uc_driver_late_release(&gt->uc);\n\t\tintel_gt_fini_requests(gt);\n\t\tintel_gt_fini_reset(gt);\n\t\tintel_gt_fini_timelines(gt);\n\t\tintel_gt_fini_tlb(gt);\n\t\tintel_engines_free(gt);\n\t}\n}\n\nstatic int intel_gt_tile_setup(struct intel_gt *gt, phys_addr_t phys_addr)\n{\n\tint ret;\n\n\tif (!gt_is_root(gt)) {\n\t\tstruct intel_uncore *uncore;\n\t\tspinlock_t *irq_lock;\n\n\t\tuncore = drmm_kzalloc(&gt->i915->drm, sizeof(*uncore), GFP_KERNEL);\n\t\tif (!uncore)\n\t\t\treturn -ENOMEM;\n\n\t\tirq_lock = drmm_kzalloc(&gt->i915->drm, sizeof(*irq_lock), GFP_KERNEL);\n\t\tif (!irq_lock)\n\t\t\treturn -ENOMEM;\n\n\t\tgt->uncore = uncore;\n\t\tgt->irq_lock = irq_lock;\n\n\t\tintel_gt_common_init_early(gt);\n\t}\n\n\tintel_uncore_init_early(gt->uncore, gt);\n\n\tret = intel_uncore_setup_mmio(gt->uncore, phys_addr);\n\tif (ret)\n\t\treturn ret;\n\n\tgt->phys_addr = phys_addr;\n\n\treturn 0;\n}\n\nint intel_gt_probe_all(struct drm_i915_private *i915)\n{\n\tstruct pci_dev *pdev = to_pci_dev(i915->drm.dev);\n\tstruct intel_gt *gt = to_gt(i915);\n\tconst struct intel_gt_definition *gtdef;\n\tphys_addr_t phys_addr;\n\tunsigned int mmio_bar;\n\tunsigned int i;\n\tint ret;\n\n\tmmio_bar = intel_mmio_bar(GRAPHICS_VER(i915));\n\tphys_addr = pci_resource_start(pdev, mmio_bar);\n\n\t \n\tgt->i915 = i915;\n\tgt->name = \"Primary GT\";\n\tgt->info.engine_mask = INTEL_INFO(i915)->platform_engine_mask;\n\n\tgt_dbg(gt, \"Setting up %s\\n\", gt->name);\n\tret = intel_gt_tile_setup(gt, phys_addr);\n\tif (ret)\n\t\treturn ret;\n\n\ti915->gt[0] = gt;\n\n\tif (!HAS_EXTRA_GT_LIST(i915))\n\t\treturn 0;\n\n\tfor (i = 1, gtdef = &INTEL_INFO(i915)->extra_gt_list[i - 1];\n\t     gtdef->name != NULL;\n\t     i++, gtdef = &INTEL_INFO(i915)->extra_gt_list[i - 1]) {\n\t\tgt = drmm_kzalloc(&i915->drm, sizeof(*gt), GFP_KERNEL);\n\t\tif (!gt) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto err;\n\t\t}\n\n\t\tgt->i915 = i915;\n\t\tgt->name = gtdef->name;\n\t\tgt->type = gtdef->type;\n\t\tgt->info.engine_mask = gtdef->engine_mask;\n\t\tgt->info.id = i;\n\n\t\tgt_dbg(gt, \"Setting up %s\\n\", gt->name);\n\t\tif (GEM_WARN_ON(range_overflows_t(resource_size_t,\n\t\t\t\t\t\t  gtdef->mapping_base,\n\t\t\t\t\t\t  SZ_16M,\n\t\t\t\t\t\t  pci_resource_len(pdev, mmio_bar)))) {\n\t\t\tret = -ENODEV;\n\t\t\tgoto err;\n\t\t}\n\n\t\tswitch (gtdef->type) {\n\t\tcase GT_TILE:\n\t\t\tret = intel_gt_tile_setup(gt, phys_addr + gtdef->mapping_base);\n\t\t\tbreak;\n\n\t\tcase GT_MEDIA:\n\t\t\tret = intel_sa_mediagt_setup(gt, phys_addr + gtdef->mapping_base,\n\t\t\t\t\t\t     gtdef->gsi_offset);\n\t\t\tbreak;\n\n\t\tcase GT_PRIMARY:\n\t\t\t \n\t\tdefault:\n\t\t\tMISSING_CASE(gtdef->type);\n\t\t\tret = -ENODEV;\n\t\t}\n\n\t\tif (ret)\n\t\t\tgoto err;\n\n\t\ti915->gt[i] = gt;\n\t}\n\n\treturn 0;\n\nerr:\n\ti915_probe_error(i915, \"Failed to initialize %s! (%d)\\n\", gtdef->name, ret);\n\treturn ret;\n}\n\nint intel_gt_tiles_init(struct drm_i915_private *i915)\n{\n\tstruct intel_gt *gt;\n\tunsigned int id;\n\tint ret;\n\n\tfor_each_gt(gt, i915, id) {\n\t\tret = intel_gt_probe_lmem(gt);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nvoid intel_gt_info_print(const struct intel_gt_info *info,\n\t\t\t struct drm_printer *p)\n{\n\tdrm_printf(p, \"available engines: %x\\n\", info->engine_mask);\n\n\tintel_sseu_dump(&info->sseu, p);\n}\n\nenum i915_map_type intel_gt_coherent_map_type(struct intel_gt *gt,\n\t\t\t\t\t      struct drm_i915_gem_object *obj,\n\t\t\t\t\t      bool always_coherent)\n{\n\t \n\tif (i915_gem_object_is_lmem(obj) || intel_gt_needs_wa_22016122933(gt))\n\t\treturn I915_MAP_WC;\n\tif (HAS_LLC(gt->i915) || always_coherent)\n\t\treturn I915_MAP_WB;\n\telse\n\t\treturn I915_MAP_WC;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}