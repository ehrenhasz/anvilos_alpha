{
  "module_name": "intel_ppgtt.c",
  "hash_id": "64c3ff7ad2aafaee3ce72b5d9497e6b3caf9c961ac678dce2809ca25b0d19101",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/i915/gt/intel_ppgtt.c",
  "human_readable_source": "\n \n\n#include <linux/slab.h>\n\n#include \"gem/i915_gem_lmem.h\"\n\n#include \"i915_trace.h\"\n#include \"intel_gt.h\"\n#include \"intel_gtt.h\"\n#include \"gen6_ppgtt.h\"\n#include \"gen8_ppgtt.h\"\n\nstruct i915_page_table *alloc_pt(struct i915_address_space *vm, int sz)\n{\n\tstruct i915_page_table *pt;\n\n\tpt = kmalloc(sizeof(*pt), I915_GFP_ALLOW_FAIL);\n\tif (unlikely(!pt))\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tpt->base = vm->alloc_pt_dma(vm, sz);\n\tif (IS_ERR(pt->base)) {\n\t\tkfree(pt);\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\n\tpt->is_compact = false;\n\tatomic_set(&pt->used, 0);\n\treturn pt;\n}\n\nstruct i915_page_directory *__alloc_pd(int count)\n{\n\tstruct i915_page_directory *pd;\n\n\tpd = kzalloc(sizeof(*pd), I915_GFP_ALLOW_FAIL);\n\tif (unlikely(!pd))\n\t\treturn NULL;\n\n\tpd->entry = kcalloc(count, sizeof(*pd->entry), I915_GFP_ALLOW_FAIL);\n\tif (unlikely(!pd->entry)) {\n\t\tkfree(pd);\n\t\treturn NULL;\n\t}\n\n\tspin_lock_init(&pd->lock);\n\treturn pd;\n}\n\nstruct i915_page_directory *alloc_pd(struct i915_address_space *vm)\n{\n\tstruct i915_page_directory *pd;\n\n\tpd = __alloc_pd(I915_PDES);\n\tif (unlikely(!pd))\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tpd->pt.base = vm->alloc_pt_dma(vm, I915_GTT_PAGE_SIZE_4K);\n\tif (IS_ERR(pd->pt.base)) {\n\t\tkfree(pd->entry);\n\t\tkfree(pd);\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\n\treturn pd;\n}\n\nvoid free_px(struct i915_address_space *vm, struct i915_page_table *pt, int lvl)\n{\n\tBUILD_BUG_ON(offsetof(struct i915_page_directory, pt));\n\n\tif (lvl) {\n\t\tstruct i915_page_directory *pd =\n\t\t\tcontainer_of(pt, typeof(*pd), pt);\n\t\tkfree(pd->entry);\n\t}\n\n\tif (pt->base)\n\t\ti915_gem_object_put(pt->base);\n\n\tkfree(pt);\n}\n\nstatic void\nwrite_dma_entry(struct drm_i915_gem_object * const pdma,\n\t\tconst unsigned short idx,\n\t\tconst u64 encoded_entry)\n{\n\tu64 * const vaddr = __px_vaddr(pdma);\n\n\tvaddr[idx] = encoded_entry;\n\tdrm_clflush_virt_range(&vaddr[idx], sizeof(u64));\n}\n\nvoid\n__set_pd_entry(struct i915_page_directory * const pd,\n\t       const unsigned short idx,\n\t       struct i915_page_table * const to,\n\t       u64 (*encode)(const dma_addr_t, const enum i915_cache_level))\n{\n\t \n\tGEM_BUG_ON(atomic_read(px_used(pd)) > NALLOC * I915_PDES);\n\n\tatomic_inc(px_used(pd));\n\tpd->entry[idx] = to;\n\twrite_dma_entry(px_base(pd), idx, encode(px_dma(to), I915_CACHE_LLC));\n}\n\nvoid\nclear_pd_entry(struct i915_page_directory * const pd,\n\t       const unsigned short idx,\n\t       const struct drm_i915_gem_object * const scratch)\n{\n\tGEM_BUG_ON(atomic_read(px_used(pd)) == 0);\n\n\twrite_dma_entry(px_base(pd), idx, scratch->encode);\n\tpd->entry[idx] = NULL;\n\tatomic_dec(px_used(pd));\n}\n\nbool\nrelease_pd_entry(struct i915_page_directory * const pd,\n\t\t const unsigned short idx,\n\t\t struct i915_page_table * const pt,\n\t\t const struct drm_i915_gem_object * const scratch)\n{\n\tbool free = false;\n\n\tif (atomic_add_unless(&pt->used, -1, 1))\n\t\treturn false;\n\n\tspin_lock(&pd->lock);\n\tif (atomic_dec_and_test(&pt->used)) {\n\t\tclear_pd_entry(pd, idx, scratch);\n\t\tfree = true;\n\t}\n\tspin_unlock(&pd->lock);\n\n\treturn free;\n}\n\nint i915_ppgtt_init_hw(struct intel_gt *gt)\n{\n\tstruct drm_i915_private *i915 = gt->i915;\n\n\tgtt_write_workarounds(gt);\n\n\tif (GRAPHICS_VER(i915) == 6)\n\t\tgen6_ppgtt_enable(gt);\n\telse if (GRAPHICS_VER(i915) == 7)\n\t\tgen7_ppgtt_enable(gt);\n\n\treturn 0;\n}\n\nstatic struct i915_ppgtt *\n__ppgtt_create(struct intel_gt *gt, unsigned long lmem_pt_obj_flags)\n{\n\tif (GRAPHICS_VER(gt->i915) < 8)\n\t\treturn gen6_ppgtt_create(gt);\n\telse\n\t\treturn gen8_ppgtt_create(gt, lmem_pt_obj_flags);\n}\n\nstruct i915_ppgtt *i915_ppgtt_create(struct intel_gt *gt,\n\t\t\t\t     unsigned long lmem_pt_obj_flags)\n{\n\tstruct i915_ppgtt *ppgtt;\n\n\tppgtt = __ppgtt_create(gt, lmem_pt_obj_flags);\n\tif (IS_ERR(ppgtt))\n\t\treturn ppgtt;\n\n\ttrace_i915_ppgtt_create(&ppgtt->vm);\n\n\treturn ppgtt;\n}\n\nvoid ppgtt_bind_vma(struct i915_address_space *vm,\n\t\t    struct i915_vm_pt_stash *stash,\n\t\t    struct i915_vma_resource *vma_res,\n\t\t    unsigned int pat_index,\n\t\t    u32 flags)\n{\n\tu32 pte_flags;\n\n\tif (!vma_res->allocated) {\n\t\tvm->allocate_va_range(vm, stash, vma_res->start,\n\t\t\t\t      vma_res->vma_size);\n\t\tvma_res->allocated = true;\n\t}\n\n\t \n\tpte_flags = 0;\n\tif (vma_res->bi.readonly)\n\t\tpte_flags |= PTE_READ_ONLY;\n\tif (vma_res->bi.lmem)\n\t\tpte_flags |= PTE_LM;\n\n\tvm->insert_entries(vm, vma_res, pat_index, pte_flags);\n\twmb();\n}\n\nvoid ppgtt_unbind_vma(struct i915_address_space *vm,\n\t\t      struct i915_vma_resource *vma_res)\n{\n\tif (!vma_res->allocated)\n\t\treturn;\n\n\tvm->clear_range(vm, vma_res->start, vma_res->vma_size);\n\tvma_invalidate_tlb(vm, vma_res->tlb);\n}\n\nstatic unsigned long pd_count(u64 size, int shift)\n{\n\t \n\treturn (size + 2 * (BIT_ULL(shift) - 1)) >> shift;\n}\n\nint i915_vm_alloc_pt_stash(struct i915_address_space *vm,\n\t\t\t   struct i915_vm_pt_stash *stash,\n\t\t\t   u64 size)\n{\n\tunsigned long count;\n\tint shift, n, pt_sz;\n\n\tshift = vm->pd_shift;\n\tif (!shift)\n\t\treturn 0;\n\n\tpt_sz = stash->pt_sz;\n\tif (!pt_sz)\n\t\tpt_sz = I915_GTT_PAGE_SIZE_4K;\n\telse\n\t\tGEM_BUG_ON(!IS_DGFX(vm->i915));\n\n\tGEM_BUG_ON(!is_power_of_2(pt_sz));\n\n\tcount = pd_count(size, shift);\n\twhile (count--) {\n\t\tstruct i915_page_table *pt;\n\n\t\tpt = alloc_pt(vm, pt_sz);\n\t\tif (IS_ERR(pt)) {\n\t\t\ti915_vm_free_pt_stash(vm, stash);\n\t\t\treturn PTR_ERR(pt);\n\t\t}\n\n\t\tpt->stash = stash->pt[0];\n\t\tstash->pt[0] = pt;\n\t}\n\n\tfor (n = 1; n < vm->top; n++) {\n\t\tshift += ilog2(I915_PDES);  \n\t\tcount = pd_count(size, shift);\n\t\twhile (count--) {\n\t\t\tstruct i915_page_directory *pd;\n\n\t\t\tpd = alloc_pd(vm);\n\t\t\tif (IS_ERR(pd)) {\n\t\t\t\ti915_vm_free_pt_stash(vm, stash);\n\t\t\t\treturn PTR_ERR(pd);\n\t\t\t}\n\n\t\t\tpd->pt.stash = stash->pt[1];\n\t\t\tstash->pt[1] = &pd->pt;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nint i915_vm_map_pt_stash(struct i915_address_space *vm,\n\t\t\t struct i915_vm_pt_stash *stash)\n{\n\tstruct i915_page_table *pt;\n\tint n, err;\n\n\tfor (n = 0; n < ARRAY_SIZE(stash->pt); n++) {\n\t\tfor (pt = stash->pt[n]; pt; pt = pt->stash) {\n\t\t\terr = map_pt_dma_locked(vm, pt->base);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nvoid i915_vm_free_pt_stash(struct i915_address_space *vm,\n\t\t\t   struct i915_vm_pt_stash *stash)\n{\n\tstruct i915_page_table *pt;\n\tint n;\n\n\tfor (n = 0; n < ARRAY_SIZE(stash->pt); n++) {\n\t\twhile ((pt = stash->pt[n])) {\n\t\t\tstash->pt[n] = pt->stash;\n\t\t\tfree_px(vm, pt, n);\n\t\t}\n\t}\n}\n\nvoid ppgtt_init(struct i915_ppgtt *ppgtt, struct intel_gt *gt,\n\t\tunsigned long lmem_pt_obj_flags)\n{\n\tstruct drm_i915_private *i915 = gt->i915;\n\n\tppgtt->vm.gt = gt;\n\tppgtt->vm.i915 = i915;\n\tppgtt->vm.dma = i915->drm.dev;\n\tppgtt->vm.total = BIT_ULL(RUNTIME_INFO(i915)->ppgtt_size);\n\tppgtt->vm.lmem_pt_obj_flags = lmem_pt_obj_flags;\n\n\tdma_resv_init(&ppgtt->vm._resv);\n\ti915_address_space_init(&ppgtt->vm, VM_CLASS_PPGTT);\n\n\tppgtt->vm.vma_ops.bind_vma    = ppgtt_bind_vma;\n\tppgtt->vm.vma_ops.unbind_vma  = ppgtt_unbind_vma;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}