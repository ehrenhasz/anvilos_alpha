{
  "module_name": "selftest_rc6.c",
  "hash_id": "53aa5465eabd92c5a039a154a6f28bab08f6961d9ec0dea6e6e43dcf68e3bc7c",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/i915/gt/selftest_rc6.c",
  "human_readable_source": "\n \n\n#include \"intel_context.h\"\n#include \"intel_engine_pm.h\"\n#include \"intel_gpu_commands.h\"\n#include \"intel_gt_requests.h\"\n#include \"intel_ring.h\"\n#include \"selftest_rc6.h\"\n\n#include \"selftests/i915_random.h\"\n#include \"selftests/librapl.h\"\n\nstatic u64 rc6_residency(struct intel_rc6 *rc6)\n{\n\tu64 result;\n\n\t \n\n\tresult = intel_rc6_residency_ns(rc6, INTEL_RC6_RES_RC6);\n\tif (HAS_RC6p(rc6_to_i915(rc6)))\n\t\tresult += intel_rc6_residency_ns(rc6, INTEL_RC6_RES_RC6p);\n\tif (HAS_RC6pp(rc6_to_i915(rc6)))\n\t\tresult += intel_rc6_residency_ns(rc6, INTEL_RC6_RES_RC6pp);\n\n\treturn result;\n}\n\nint live_rc6_manual(void *arg)\n{\n\tstruct intel_gt *gt = arg;\n\tstruct intel_rc6 *rc6 = &gt->rc6;\n\tu64 rc0_power, rc6_power;\n\tintel_wakeref_t wakeref;\n\tbool has_power;\n\tktime_t dt;\n\tu64 res[2];\n\tint err = 0;\n\n\t \n\n\tif (!rc6->enabled)\n\t\treturn 0;\n\n\t \n\tif (IS_VALLEYVIEW(gt->i915) || IS_CHERRYVIEW(gt->i915))\n\t\treturn 0;\n\n\thas_power = librapl_supported(gt->i915);\n\twakeref = intel_runtime_pm_get(gt->uncore->rpm);\n\n\t \n\t__intel_rc6_disable(rc6);\n\tmsleep(1);  \n\n\tres[0] = rc6_residency(rc6);\n\n\tdt = ktime_get();\n\trc0_power = librapl_energy_uJ();\n\tmsleep(250);\n\trc0_power = librapl_energy_uJ() - rc0_power;\n\tdt = ktime_sub(ktime_get(), dt);\n\tres[1] = rc6_residency(rc6);\n\tif ((res[1] - res[0]) >> 10) {\n\t\tpr_err(\"RC6 residency increased by %lldus while disabled for 250ms!\\n\",\n\t\t       (res[1] - res[0]) >> 10);\n\t\terr = -EINVAL;\n\t\tgoto out_unlock;\n\t}\n\n\tif (has_power) {\n\t\trc0_power = div64_u64(NSEC_PER_SEC * rc0_power,\n\t\t\t\t      ktime_to_ns(dt));\n\t\tif (!rc0_power) {\n\t\t\tpr_err(\"No power measured while in RC0\\n\");\n\t\t\terr = -EINVAL;\n\t\t\tgoto out_unlock;\n\t\t}\n\t}\n\n\t \n\tintel_rc6_park(rc6);\n\n\tres[0] = rc6_residency(rc6);\n\tintel_uncore_forcewake_flush(rc6_to_uncore(rc6), FORCEWAKE_ALL);\n\tdt = ktime_get();\n\trc6_power = librapl_energy_uJ();\n\tmsleep(100);\n\trc6_power = librapl_energy_uJ() - rc6_power;\n\tdt = ktime_sub(ktime_get(), dt);\n\tres[1] = rc6_residency(rc6);\n\tif (res[1] == res[0]) {\n\t\tpr_err(\"Did not enter RC6! RC6_STATE=%08x, RC6_CONTROL=%08x, residency=%lld\\n\",\n\t\t       intel_uncore_read_fw(gt->uncore, GEN6_RC_STATE),\n\t\t       intel_uncore_read_fw(gt->uncore, GEN6_RC_CONTROL),\n\t\t       res[0]);\n\t\terr = -EINVAL;\n\t}\n\n\tif (has_power) {\n\t\trc6_power = div64_u64(NSEC_PER_SEC * rc6_power,\n\t\t\t\t      ktime_to_ns(dt));\n\t\tpr_info(\"GPU consumed %llduW in RC0 and %llduW in RC6\\n\",\n\t\t\trc0_power, rc6_power);\n\t\tif (2 * rc6_power > rc0_power) {\n\t\t\tpr_err(\"GPU leaked energy while in RC6!\\n\");\n\t\t\terr = -EINVAL;\n\t\t\tgoto out_unlock;\n\t\t}\n\t}\n\n\t \n\tintel_rc6_unpark(rc6);\n\nout_unlock:\n\tintel_runtime_pm_put(gt->uncore->rpm, wakeref);\n\treturn err;\n}\n\nstatic const u32 *__live_rc6_ctx(struct intel_context *ce)\n{\n\tstruct i915_request *rq;\n\tconst u32 *result;\n\tu32 cmd;\n\tu32 *cs;\n\n\trq = intel_context_create_request(ce);\n\tif (IS_ERR(rq))\n\t\treturn ERR_CAST(rq);\n\n\tcs = intel_ring_begin(rq, 4);\n\tif (IS_ERR(cs)) {\n\t\ti915_request_add(rq);\n\t\treturn cs;\n\t}\n\n\tcmd = MI_STORE_REGISTER_MEM | MI_USE_GGTT;\n\tif (GRAPHICS_VER(rq->i915) >= 8)\n\t\tcmd++;\n\n\t*cs++ = cmd;\n\t*cs++ = i915_mmio_reg_offset(GEN8_RC6_CTX_INFO);\n\t*cs++ = ce->timeline->hwsp_offset + 8;\n\t*cs++ = 0;\n\tintel_ring_advance(rq, cs);\n\n\tresult = rq->hwsp_seqno + 2;\n\ti915_request_add(rq);\n\n\treturn result;\n}\n\nstatic struct intel_engine_cs **\nrandomised_engines(struct intel_gt *gt,\n\t\t   struct rnd_state *prng,\n\t\t   unsigned int *count)\n{\n\tstruct intel_engine_cs *engine, **engines;\n\tenum intel_engine_id id;\n\tint n;\n\n\tn = 0;\n\tfor_each_engine(engine, gt, id)\n\t\tn++;\n\tif (!n)\n\t\treturn NULL;\n\n\tengines = kmalloc_array(n, sizeof(*engines), GFP_KERNEL);\n\tif (!engines)\n\t\treturn NULL;\n\n\tn = 0;\n\tfor_each_engine(engine, gt, id)\n\t\tengines[n++] = engine;\n\n\ti915_prandom_shuffle(engines, sizeof(*engines), n, prng);\n\n\t*count = n;\n\treturn engines;\n}\n\nint live_rc6_ctx_wa(void *arg)\n{\n\tstruct intel_gt *gt = arg;\n\tstruct intel_engine_cs **engines;\n\tunsigned int n, count;\n\tI915_RND_STATE(prng);\n\tint err = 0;\n\n\t \n\tif (GRAPHICS_VER(gt->i915) < 8)\n\t\treturn 0;\n\n\tengines = randomised_engines(gt, &prng, &count);\n\tif (!engines)\n\t\treturn 0;\n\n\tfor (n = 0; n < count; n++) {\n\t\tstruct intel_engine_cs *engine = engines[n];\n\t\tint pass;\n\n\t\tfor (pass = 0; pass < 2; pass++) {\n\t\t\tstruct i915_gpu_error *error = &gt->i915->gpu_error;\n\t\t\tstruct intel_context *ce;\n\t\t\tunsigned int resets =\n\t\t\t\ti915_reset_engine_count(error, engine);\n\t\t\tconst u32 *res;\n\n\t\t\t \n\t\t\tce = intel_context_create(engine);\n\t\t\tif (IS_ERR(ce)) {\n\t\t\t\terr = PTR_ERR(ce);\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tintel_engine_pm_get(engine);\n\t\t\tres = __live_rc6_ctx(ce);\n\t\t\tintel_engine_pm_put(engine);\n\t\t\tintel_context_put(ce);\n\t\t\tif (IS_ERR(res)) {\n\t\t\t\terr = PTR_ERR(res);\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tif (intel_gt_wait_for_idle(gt, HZ / 5) == -ETIME) {\n\t\t\t\tintel_gt_set_wedged(gt);\n\t\t\t\terr = -ETIME;\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tintel_gt_pm_wait_for_idle(gt);\n\t\t\tpr_debug(\"%s: CTX_INFO=%0x\\n\",\n\t\t\t\t engine->name, READ_ONCE(*res));\n\n\t\t\tif (resets !=\n\t\t\t    i915_reset_engine_count(error, engine)) {\n\t\t\t\tpr_err(\"%s: GPU reset required\\n\",\n\t\t\t\t       engine->name);\n\t\t\t\tadd_taint_for_CI(gt->i915, TAINT_WARN);\n\t\t\t\terr = -EIO;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t}\n\nout:\n\tkfree(engines);\n\treturn err;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}