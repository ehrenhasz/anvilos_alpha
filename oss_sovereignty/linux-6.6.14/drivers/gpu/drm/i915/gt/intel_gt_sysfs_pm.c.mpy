{
  "module_name": "intel_gt_sysfs_pm.c",
  "hash_id": "29830e9e5f79675e2ab762a83657b920af9940d27f308dbb614b8e9b40059d86",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/i915/gt/intel_gt_sysfs_pm.c",
  "human_readable_source": "\n \n\n#include <drm/drm_device.h>\n#include <linux/sysfs.h>\n#include <linux/printk.h>\n\n#include \"i915_drv.h\"\n#include \"i915_reg.h\"\n#include \"i915_sysfs.h\"\n#include \"intel_gt.h\"\n#include \"intel_gt_print.h\"\n#include \"intel_gt_regs.h\"\n#include \"intel_gt_sysfs.h\"\n#include \"intel_gt_sysfs_pm.h\"\n#include \"intel_pcode.h\"\n#include \"intel_rc6.h\"\n#include \"intel_rps.h\"\n\nenum intel_gt_sysfs_op {\n\tINTEL_GT_SYSFS_MIN = 0,\n\tINTEL_GT_SYSFS_MAX,\n};\n\nstatic int\nsysfs_gt_attribute_w_func(struct kobject *kobj, struct attribute *attr,\n\t\t\t  int (func)(struct intel_gt *gt, u32 val), u32 val)\n{\n\tstruct intel_gt *gt;\n\tint ret;\n\n\tif (!is_object_gt(kobj)) {\n\t\tint i;\n\t\tstruct device *dev = kobj_to_dev(kobj);\n\t\tstruct drm_i915_private *i915 = kdev_minor_to_i915(dev);\n\n\t\tfor_each_gt(gt, i915, i) {\n\t\t\tret = func(gt, val);\n\t\t\tif (ret)\n\t\t\t\tbreak;\n\t\t}\n\t} else {\n\t\tgt = intel_gt_sysfs_get_drvdata(kobj, attr->name);\n\t\tret = func(gt, val);\n\t}\n\n\treturn ret;\n}\n\nstatic u32\nsysfs_gt_attribute_r_func(struct kobject *kobj, struct attribute *attr,\n\t\t\t  u32 (func)(struct intel_gt *gt),\n\t\t\t  enum intel_gt_sysfs_op op)\n{\n\tstruct intel_gt *gt;\n\tu32 ret;\n\n\tret = (op == INTEL_GT_SYSFS_MAX) ? 0 : (u32) -1;\n\n\tif (!is_object_gt(kobj)) {\n\t\tint i;\n\t\tstruct device *dev = kobj_to_dev(kobj);\n\t\tstruct drm_i915_private *i915 = kdev_minor_to_i915(dev);\n\n\t\tfor_each_gt(gt, i915, i) {\n\t\t\tu32 val = func(gt);\n\n\t\t\tswitch (op) {\n\t\t\tcase INTEL_GT_SYSFS_MIN:\n\t\t\t\tif (val < ret)\n\t\t\t\t\tret = val;\n\t\t\t\tbreak;\n\n\t\t\tcase INTEL_GT_SYSFS_MAX:\n\t\t\t\tif (val > ret)\n\t\t\t\t\tret = val;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tgt = intel_gt_sysfs_get_drvdata(kobj, attr->name);\n\t\tret = func(gt);\n\t}\n\n\treturn ret;\n}\n\n \n#define sysfs_gt_attribute_r_min_func(d, a, f) \\\n\t\tsysfs_gt_attribute_r_func(d, a, f, INTEL_GT_SYSFS_MIN)\n\n \n#define sysfs_gt_attribute_r_max_func(d, a, f) \\\n\t\tsysfs_gt_attribute_r_func(d, a, f, INTEL_GT_SYSFS_MAX)\n\n#define INTEL_GT_SYSFS_SHOW(_name, _attr_type)\t\t\t\t\t\t\t\\\n\tstatic ssize_t _name##_show_common(struct kobject *kobj,\t\t\t\t\\\n\t\t\t\t\t   struct attribute *attr, char *buff)\t\t\t\\\n\t{\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tu32 val = sysfs_gt_attribute_r_##_attr_type##_func(kobj, attr,\t\t\t\\\n\t\t\t\t\t\t\t\t   __##_name##_show);\t\t\\\n\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\treturn sysfs_emit(buff, \"%u\\n\", val);\t\t\t\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\t\t\t\\\n\tstatic ssize_t _name##_show(struct kobject *kobj,\t\t\t\t\t\\\n\t\t\t\t    struct kobj_attribute *attr, char *buff)\t\t\t\\\n\t{\t\t\t\t\t\t\t\t\t\t\t\\\n\t\treturn _name ##_show_common(kobj, &attr->attr, buff);\t\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\t\t\t\\\n\tstatic ssize_t _name##_dev_show(struct device *dev,\t\t\t\t\t\\\n\t\t\t\t\tstruct device_attribute *attr, char *buff)\t\t\\\n\t{\t\t\t\t\t\t\t\t\t\t\t\\\n\t\treturn _name##_show_common(&dev->kobj, &attr->attr, buff);\t\t\t\\\n\t}\n\n#define INTEL_GT_SYSFS_STORE(_name, _func)\t\t\t\t\t\t\\\n\tstatic ssize_t _name##_store_common(struct kobject *kobj,\t\t\t\\\n\t\t\t\t\t    struct attribute *attr,\t\t\t\\\n\t\t\t\t\t    const char *buff, size_t count)\t\t\\\n\t{\t\t\t\t\t\t\t\t\t\t\\\n\t\tint ret;\t\t\t\t\t\t\t\t\\\n\t\tu32 val;\t\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tret = kstrtou32(buff, 0, &val);\t\t\t\t\t\t\\\n\t\tif (ret)\t\t\t\t\t\t\t\t\\\n\t\t\treturn ret;\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tret = sysfs_gt_attribute_w_func(kobj, attr, _func, val);\t\t\\\n\t\t\t\t\t\t\t\t\t\t\t\\\n\t\treturn ret ?: count;\t\t\t\t\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\t\t\\\n\tstatic ssize_t _name##_store(struct kobject *kobj,\t\t\t\t\\\n\t\t\t\t     struct kobj_attribute *attr, const char *buff,\t\\\n\t\t\t\t     size_t count)\t\t\t\t\t\\\n\t{\t\t\t\t\t\t\t\t\t\t\\\n\t\treturn _name##_store_common(kobj, &attr->attr, buff, count);\t\t\\\n\t}\t\t\t\t\t\t\t\t\t\t\\\n\tstatic ssize_t _name##_dev_store(struct device *dev,\t\t\t\t\\\n\t\t\t\t\t struct device_attribute *attr,\t\t\t\\\n\t\t\t\t\t const char *buff, size_t count)\t\t\\\n\t{\t\t\t\t\t\t\t\t\t\t\\\n\t\treturn _name##_store_common(&dev->kobj, &attr->attr, buff, count);\t\\\n\t}\n\n#define INTEL_GT_SYSFS_SHOW_MAX(_name) INTEL_GT_SYSFS_SHOW(_name, max)\n#define INTEL_GT_SYSFS_SHOW_MIN(_name) INTEL_GT_SYSFS_SHOW(_name, min)\n\n#define INTEL_GT_ATTR_RW(_name) \\\n\tstatic struct kobj_attribute attr_##_name = __ATTR_RW(_name)\n\n#define INTEL_GT_ATTR_RO(_name) \\\n\tstatic struct kobj_attribute attr_##_name = __ATTR_RO(_name)\n\n#define INTEL_GT_DUAL_ATTR_RW(_name) \\\n\tstatic struct device_attribute dev_attr_##_name = __ATTR(_name, 0644,\t\t\\\n\t\t\t\t\t\t\t\t _name##_dev_show,\t\\\n\t\t\t\t\t\t\t\t _name##_dev_store);\t\\\n\tINTEL_GT_ATTR_RW(_name)\n\n#define INTEL_GT_DUAL_ATTR_RO(_name) \\\n\tstatic struct device_attribute dev_attr_##_name = __ATTR(_name, 0444,\t\t\\\n\t\t\t\t\t\t\t\t _name##_dev_show,\t\\\n\t\t\t\t\t\t\t\t NULL);\t\t\t\\\n\tINTEL_GT_ATTR_RO(_name)\n\nstatic u32 get_residency(struct intel_gt *gt, enum intel_rc6_res_type id)\n{\n\tintel_wakeref_t wakeref;\n\tu64 res = 0;\n\n\twith_intel_runtime_pm(gt->uncore->rpm, wakeref)\n\t\tres = intel_rc6_residency_us(&gt->rc6, id);\n\n\treturn DIV_ROUND_CLOSEST_ULL(res, 1000);\n}\n\nstatic u8 get_rc6_mask(struct intel_gt *gt)\n{\n\tu8 mask = 0;\n\n\tif (HAS_RC6(gt->i915))\n\t\tmask |= BIT(0);\n\tif (HAS_RC6p(gt->i915))\n\t\tmask |= BIT(1);\n\tif (HAS_RC6pp(gt->i915))\n\t\tmask |= BIT(2);\n\n\treturn mask;\n}\n\nstatic ssize_t rc6_enable_show(struct kobject *kobj,\n\t\t\t       struct kobj_attribute *attr,\n\t\t\t       char *buff)\n{\n\tstruct intel_gt *gt = intel_gt_sysfs_get_drvdata(kobj, attr->attr.name);\n\n\treturn sysfs_emit(buff, \"%x\\n\", get_rc6_mask(gt));\n}\n\nstatic ssize_t rc6_enable_dev_show(struct device *dev,\n\t\t\t\t   struct device_attribute *attr,\n\t\t\t\t   char *buff)\n{\n\tstruct intel_gt *gt = intel_gt_sysfs_get_drvdata(&dev->kobj, attr->attr.name);\n\n\treturn sysfs_emit(buff, \"%x\\n\", get_rc6_mask(gt));\n}\n\nstatic u32 __rc6_residency_ms_show(struct intel_gt *gt)\n{\n\treturn get_residency(gt, INTEL_RC6_RES_RC6);\n}\n\nstatic u32 __rc6p_residency_ms_show(struct intel_gt *gt)\n{\n\treturn get_residency(gt, INTEL_RC6_RES_RC6p);\n}\n\nstatic u32 __rc6pp_residency_ms_show(struct intel_gt *gt)\n{\n\treturn get_residency(gt, INTEL_RC6_RES_RC6pp);\n}\n\nstatic u32 __media_rc6_residency_ms_show(struct intel_gt *gt)\n{\n\treturn get_residency(gt, INTEL_RC6_RES_VLV_MEDIA);\n}\n\nINTEL_GT_SYSFS_SHOW_MIN(rc6_residency_ms);\nINTEL_GT_SYSFS_SHOW_MIN(rc6p_residency_ms);\nINTEL_GT_SYSFS_SHOW_MIN(rc6pp_residency_ms);\nINTEL_GT_SYSFS_SHOW_MIN(media_rc6_residency_ms);\n\nINTEL_GT_DUAL_ATTR_RO(rc6_enable);\nINTEL_GT_DUAL_ATTR_RO(rc6_residency_ms);\nINTEL_GT_DUAL_ATTR_RO(rc6p_residency_ms);\nINTEL_GT_DUAL_ATTR_RO(rc6pp_residency_ms);\nINTEL_GT_DUAL_ATTR_RO(media_rc6_residency_ms);\n\nstatic struct attribute *rc6_attrs[] = {\n\t&attr_rc6_enable.attr,\n\t&attr_rc6_residency_ms.attr,\n\tNULL\n};\n\nstatic struct attribute *rc6p_attrs[] = {\n\t&attr_rc6p_residency_ms.attr,\n\t&attr_rc6pp_residency_ms.attr,\n\tNULL\n};\n\nstatic struct attribute *media_rc6_attrs[] = {\n\t&attr_media_rc6_residency_ms.attr,\n\tNULL\n};\n\nstatic struct attribute *rc6_dev_attrs[] = {\n\t&dev_attr_rc6_enable.attr,\n\t&dev_attr_rc6_residency_ms.attr,\n\tNULL\n};\n\nstatic struct attribute *rc6p_dev_attrs[] = {\n\t&dev_attr_rc6p_residency_ms.attr,\n\t&dev_attr_rc6pp_residency_ms.attr,\n\tNULL\n};\n\nstatic struct attribute *media_rc6_dev_attrs[] = {\n\t&dev_attr_media_rc6_residency_ms.attr,\n\tNULL\n};\n\nstatic const struct attribute_group rc6_attr_group[] = {\n\t{ .attrs = rc6_attrs, },\n\t{ .name = power_group_name, .attrs = rc6_dev_attrs, },\n};\n\nstatic const struct attribute_group rc6p_attr_group[] = {\n\t{ .attrs = rc6p_attrs, },\n\t{ .name = power_group_name, .attrs = rc6p_dev_attrs, },\n};\n\nstatic const struct attribute_group media_rc6_attr_group[] = {\n\t{ .attrs = media_rc6_attrs, },\n\t{ .name = power_group_name, .attrs = media_rc6_dev_attrs, },\n};\n\nstatic int __intel_gt_sysfs_create_group(struct kobject *kobj,\n\t\t\t\t\t const struct attribute_group *grp)\n{\n\treturn is_object_gt(kobj) ?\n\t       sysfs_create_group(kobj, &grp[0]) :\n\t       sysfs_merge_group(kobj, &grp[1]);\n}\n\nstatic void intel_sysfs_rc6_init(struct intel_gt *gt, struct kobject *kobj)\n{\n\tint ret;\n\n\tif (!IS_ENABLED(CONFIG_PM) || !HAS_RC6(gt->i915))\n\t\treturn;\n\n\tret = __intel_gt_sysfs_create_group(kobj, rc6_attr_group);\n\tif (ret)\n\t\tgt_warn(gt, \"failed to create RC6 sysfs files (%pe)\\n\", ERR_PTR(ret));\n\n\t \n\tif (HAS_RC6p(gt->i915)) {\n\t\tret = __intel_gt_sysfs_create_group(kobj, rc6p_attr_group);\n\t\tif (ret)\n\t\t\tgt_warn(gt, \"failed to create RC6p sysfs files (%pe)\\n\", ERR_PTR(ret));\n\t}\n\n\tif (IS_VALLEYVIEW(gt->i915) || IS_CHERRYVIEW(gt->i915)) {\n\t\tret = __intel_gt_sysfs_create_group(kobj, media_rc6_attr_group);\n\t\tif (ret)\n\t\t\tgt_warn(gt, \"failed to create media RC6 sysfs files (%pe)\\n\", ERR_PTR(ret));\n\t}\n}\n\nstatic u32 __act_freq_mhz_show(struct intel_gt *gt)\n{\n\treturn intel_rps_read_actual_frequency(&gt->rps);\n}\n\nstatic u32 __cur_freq_mhz_show(struct intel_gt *gt)\n{\n\treturn intel_rps_get_requested_frequency(&gt->rps);\n}\n\nstatic u32 __boost_freq_mhz_show(struct intel_gt *gt)\n{\n\treturn intel_rps_get_boost_frequency(&gt->rps);\n}\n\nstatic int __boost_freq_mhz_store(struct intel_gt *gt, u32 val)\n{\n\treturn intel_rps_set_boost_frequency(&gt->rps, val);\n}\n\nstatic u32 __RP0_freq_mhz_show(struct intel_gt *gt)\n{\n\treturn intel_rps_get_rp0_frequency(&gt->rps);\n}\n\nstatic u32 __RPn_freq_mhz_show(struct intel_gt *gt)\n{\n\treturn intel_rps_get_rpn_frequency(&gt->rps);\n}\n\nstatic u32 __RP1_freq_mhz_show(struct intel_gt *gt)\n{\n\treturn intel_rps_get_rp1_frequency(&gt->rps);\n}\n\nstatic u32 __max_freq_mhz_show(struct intel_gt *gt)\n{\n\treturn intel_rps_get_max_frequency(&gt->rps);\n}\n\nstatic int __set_max_freq(struct intel_gt *gt, u32 val)\n{\n\treturn intel_rps_set_max_frequency(&gt->rps, val);\n}\n\nstatic u32 __min_freq_mhz_show(struct intel_gt *gt)\n{\n\treturn intel_rps_get_min_frequency(&gt->rps);\n}\n\nstatic int __set_min_freq(struct intel_gt *gt, u32 val)\n{\n\treturn intel_rps_set_min_frequency(&gt->rps, val);\n}\n\nstatic u32 __vlv_rpe_freq_mhz_show(struct intel_gt *gt)\n{\n\tstruct intel_rps *rps = &gt->rps;\n\n\treturn intel_gpu_freq(rps, rps->efficient_freq);\n}\n\nINTEL_GT_SYSFS_SHOW_MAX(act_freq_mhz);\nINTEL_GT_SYSFS_SHOW_MAX(boost_freq_mhz);\nINTEL_GT_SYSFS_SHOW_MAX(cur_freq_mhz);\nINTEL_GT_SYSFS_SHOW_MAX(RP0_freq_mhz);\nINTEL_GT_SYSFS_SHOW_MAX(RP1_freq_mhz);\nINTEL_GT_SYSFS_SHOW_MAX(RPn_freq_mhz);\nINTEL_GT_SYSFS_SHOW_MAX(max_freq_mhz);\nINTEL_GT_SYSFS_SHOW_MIN(min_freq_mhz);\nINTEL_GT_SYSFS_SHOW_MAX(vlv_rpe_freq_mhz);\nINTEL_GT_SYSFS_STORE(boost_freq_mhz, __boost_freq_mhz_store);\nINTEL_GT_SYSFS_STORE(max_freq_mhz, __set_max_freq);\nINTEL_GT_SYSFS_STORE(min_freq_mhz, __set_min_freq);\n\n#define INTEL_GT_RPS_SYSFS_ATTR(_name, _mode, _show, _store, _show_dev, _store_dev)\t\t\\\n\tstatic struct device_attribute dev_attr_gt_##_name = __ATTR(gt_##_name, _mode,\t\t\\\n\t\t\t\t\t\t\t\t    _show_dev, _store_dev);\t\\\n\tstatic struct kobj_attribute attr_rps_##_name = __ATTR(rps_##_name, _mode,\t\t\\\n\t\t\t\t\t\t\t       _show, _store)\n\n#define INTEL_GT_RPS_SYSFS_ATTR_RO(_name)\t\t\t\t\t\t\\\n\t\tINTEL_GT_RPS_SYSFS_ATTR(_name, 0444, _name##_show, NULL,\t\t\\\n\t\t\t\t\t_name##_dev_show, NULL)\n#define INTEL_GT_RPS_SYSFS_ATTR_RW(_name)\t\t\t\t\t\t\\\n\t\tINTEL_GT_RPS_SYSFS_ATTR(_name, 0644, _name##_show, _name##_store,\t\\\n\t\t\t\t\t_name##_dev_show, _name##_dev_store)\n\n \nINTEL_GT_RPS_SYSFS_ATTR_RO(act_freq_mhz);\nINTEL_GT_RPS_SYSFS_ATTR_RO(cur_freq_mhz);\nINTEL_GT_RPS_SYSFS_ATTR_RW(boost_freq_mhz);\nINTEL_GT_RPS_SYSFS_ATTR_RO(RP0_freq_mhz);\nINTEL_GT_RPS_SYSFS_ATTR_RO(RP1_freq_mhz);\nINTEL_GT_RPS_SYSFS_ATTR_RO(RPn_freq_mhz);\nINTEL_GT_RPS_SYSFS_ATTR_RW(max_freq_mhz);\nINTEL_GT_RPS_SYSFS_ATTR_RW(min_freq_mhz);\nINTEL_GT_RPS_SYSFS_ATTR_RO(vlv_rpe_freq_mhz);\n\n#define GEN6_ATTR(p, s) { \\\n\t\t&p##attr_##s##_act_freq_mhz.attr, \\\n\t\t&p##attr_##s##_cur_freq_mhz.attr, \\\n\t\t&p##attr_##s##_boost_freq_mhz.attr, \\\n\t\t&p##attr_##s##_max_freq_mhz.attr, \\\n\t\t&p##attr_##s##_min_freq_mhz.attr, \\\n\t\t&p##attr_##s##_RP0_freq_mhz.attr, \\\n\t\t&p##attr_##s##_RP1_freq_mhz.attr, \\\n\t\t&p##attr_##s##_RPn_freq_mhz.attr, \\\n\t\tNULL, \\\n\t}\n\n#define GEN6_RPS_ATTR GEN6_ATTR(, rps)\n#define GEN6_GT_ATTR  GEN6_ATTR(dev_, gt)\n\nstatic const struct attribute * const gen6_rps_attrs[] = GEN6_RPS_ATTR;\nstatic const struct attribute * const gen6_gt_attrs[]  = GEN6_GT_ATTR;\n\nstatic ssize_t punit_req_freq_mhz_show(struct kobject *kobj,\n\t\t\t\t       struct kobj_attribute *attr,\n\t\t\t\t       char *buff)\n{\n\tstruct intel_gt *gt = intel_gt_sysfs_get_drvdata(kobj, attr->attr.name);\n\tu32 preq = intel_rps_read_punit_req_frequency(&gt->rps);\n\n\treturn sysfs_emit(buff, \"%u\\n\", preq);\n}\n\nstatic ssize_t slpc_ignore_eff_freq_show(struct kobject *kobj,\n\t\t\t\t\t struct kobj_attribute *attr,\n\t\t\t\t\t char *buff)\n{\n\tstruct intel_gt *gt = intel_gt_sysfs_get_drvdata(kobj, attr->attr.name);\n\tstruct intel_guc_slpc *slpc = &gt->uc.guc.slpc;\n\n\treturn sysfs_emit(buff, \"%u\\n\", slpc->ignore_eff_freq);\n}\n\nstatic ssize_t slpc_ignore_eff_freq_store(struct kobject *kobj,\n\t\t\t\t\t  struct kobj_attribute *attr,\n\t\t\t\t\t  const char *buff, size_t count)\n{\n\tstruct intel_gt *gt = intel_gt_sysfs_get_drvdata(kobj, attr->attr.name);\n\tstruct intel_guc_slpc *slpc = &gt->uc.guc.slpc;\n\tint err;\n\tu32 val;\n\n\terr = kstrtou32(buff, 0, &val);\n\tif (err)\n\t\treturn err;\n\n\terr = intel_guc_slpc_set_ignore_eff_freq(slpc, val);\n\treturn err ?: count;\n}\n\nstruct intel_gt_bool_throttle_attr {\n\tstruct attribute attr;\n\tssize_t (*show)(struct kobject *kobj, struct kobj_attribute *attr,\n\t\t\tchar *buf);\n\ti915_reg_t (*reg32)(struct intel_gt *gt);\n\tu32 mask;\n};\n\nstatic ssize_t throttle_reason_bool_show(struct kobject *kobj,\n\t\t\t\t\t struct kobj_attribute *attr,\n\t\t\t\t\t char *buff)\n{\n\tstruct intel_gt *gt = intel_gt_sysfs_get_drvdata(kobj, attr->attr.name);\n\tstruct intel_gt_bool_throttle_attr *t_attr =\n\t\t\t\t(struct intel_gt_bool_throttle_attr *) attr;\n\tbool val = rps_read_mask_mmio(&gt->rps, t_attr->reg32(gt), t_attr->mask);\n\n\treturn sysfs_emit(buff, \"%u\\n\", val);\n}\n\n#define INTEL_GT_RPS_BOOL_ATTR_RO(sysfs_func__, mask__) \\\nstruct intel_gt_bool_throttle_attr attr_##sysfs_func__ = { \\\n\t.attr = { .name = __stringify(sysfs_func__), .mode = 0444 }, \\\n\t.show = throttle_reason_bool_show, \\\n\t.reg32 = intel_gt_perf_limit_reasons_reg, \\\n\t.mask = mask__, \\\n}\n\nINTEL_GT_ATTR_RO(punit_req_freq_mhz);\nstatic INTEL_GT_RPS_BOOL_ATTR_RO(throttle_reason_status, GT0_PERF_LIMIT_REASONS_MASK);\nstatic INTEL_GT_RPS_BOOL_ATTR_RO(throttle_reason_pl1, POWER_LIMIT_1_MASK);\nstatic INTEL_GT_RPS_BOOL_ATTR_RO(throttle_reason_pl2, POWER_LIMIT_2_MASK);\nstatic INTEL_GT_RPS_BOOL_ATTR_RO(throttle_reason_pl4, POWER_LIMIT_4_MASK);\nstatic INTEL_GT_RPS_BOOL_ATTR_RO(throttle_reason_thermal, THERMAL_LIMIT_MASK);\nstatic INTEL_GT_RPS_BOOL_ATTR_RO(throttle_reason_prochot, PROCHOT_MASK);\nstatic INTEL_GT_RPS_BOOL_ATTR_RO(throttle_reason_ratl, RATL_MASK);\nstatic INTEL_GT_RPS_BOOL_ATTR_RO(throttle_reason_vr_thermalert, VR_THERMALERT_MASK);\nstatic INTEL_GT_RPS_BOOL_ATTR_RO(throttle_reason_vr_tdc, VR_TDC_MASK);\n\nstatic const struct attribute *throttle_reason_attrs[] = {\n\t&attr_throttle_reason_status.attr,\n\t&attr_throttle_reason_pl1.attr,\n\t&attr_throttle_reason_pl2.attr,\n\t&attr_throttle_reason_pl4.attr,\n\t&attr_throttle_reason_thermal.attr,\n\t&attr_throttle_reason_prochot.attr,\n\t&attr_throttle_reason_ratl.attr,\n\t&attr_throttle_reason_vr_thermalert.attr,\n\t&attr_throttle_reason_vr_tdc.attr,\n\tNULL\n};\n\n \n\n#define U8_8_VAL_MASK           0xffff\n#define U8_8_SCALE_TO_VALUE     \"0.00390625\"\n\nstatic ssize_t freq_factor_scale_show(struct kobject *kobj,\n\t\t\t\t      struct kobj_attribute *attr,\n\t\t\t\t      char *buff)\n{\n\treturn sysfs_emit(buff, \"%s\\n\", U8_8_SCALE_TO_VALUE);\n}\n\nstatic u32 media_ratio_mode_to_factor(u32 mode)\n{\n\t \n\treturn !mode ? mode : 256 / mode;\n}\n\nstatic ssize_t media_freq_factor_show(struct kobject *kobj,\n\t\t\t\t      struct kobj_attribute *attr,\n\t\t\t\t      char *buff)\n{\n\tstruct intel_gt *gt = intel_gt_sysfs_get_drvdata(kobj, attr->attr.name);\n\tstruct intel_guc_slpc *slpc = &gt->uc.guc.slpc;\n\tintel_wakeref_t wakeref;\n\tu32 mode;\n\n\t \n\tif (IS_XEHPSDV(gt->i915) &&\n\t    slpc->media_ratio_mode == SLPC_MEDIA_RATIO_MODE_DYNAMIC_CONTROL) {\n\t\t \n\t\tmode = slpc->media_ratio_mode;\n\t} else {\n\t\twith_intel_runtime_pm(gt->uncore->rpm, wakeref)\n\t\t\tmode = intel_uncore_read(gt->uncore, GEN6_RPNSWREQ);\n\t\tmode = REG_FIELD_GET(GEN12_MEDIA_FREQ_RATIO, mode) ?\n\t\t\tSLPC_MEDIA_RATIO_MODE_FIXED_ONE_TO_ONE :\n\t\t\tSLPC_MEDIA_RATIO_MODE_FIXED_ONE_TO_TWO;\n\t}\n\n\treturn sysfs_emit(buff, \"%u\\n\", media_ratio_mode_to_factor(mode));\n}\n\nstatic ssize_t media_freq_factor_store(struct kobject *kobj,\n\t\t\t\t       struct kobj_attribute *attr,\n\t\t\t\t       const char *buff, size_t count)\n{\n\tstruct intel_gt *gt = intel_gt_sysfs_get_drvdata(kobj, attr->attr.name);\n\tstruct intel_guc_slpc *slpc = &gt->uc.guc.slpc;\n\tu32 factor, mode;\n\tint err;\n\n\terr = kstrtou32(buff, 0, &factor);\n\tif (err)\n\t\treturn err;\n\n\tfor (mode = SLPC_MEDIA_RATIO_MODE_DYNAMIC_CONTROL;\n\t     mode <= SLPC_MEDIA_RATIO_MODE_FIXED_ONE_TO_TWO; mode++)\n\t\tif (factor == media_ratio_mode_to_factor(mode))\n\t\t\tbreak;\n\n\tif (mode > SLPC_MEDIA_RATIO_MODE_FIXED_ONE_TO_TWO)\n\t\treturn -EINVAL;\n\n\terr = intel_guc_slpc_set_media_ratio_mode(slpc, mode);\n\tif (!err) {\n\t\tslpc->media_ratio_mode = mode;\n\t\tDRM_DEBUG(\"Set slpc->media_ratio_mode to %d\", mode);\n\t}\n\treturn err ?: count;\n}\n\nstatic ssize_t media_RP0_freq_mhz_show(struct kobject *kobj,\n\t\t\t\t       struct kobj_attribute *attr,\n\t\t\t\t       char *buff)\n{\n\tstruct intel_gt *gt = intel_gt_sysfs_get_drvdata(kobj, attr->attr.name);\n\tu32 val;\n\tint err;\n\n\terr = snb_pcode_read_p(gt->uncore, XEHP_PCODE_FREQUENCY_CONFIG,\n\t\t\t       PCODE_MBOX_FC_SC_READ_FUSED_P0,\n\t\t\t       PCODE_MBOX_DOMAIN_MEDIAFF, &val);\n\n\tif (err)\n\t\treturn err;\n\n\t \n\tval *= GT_FREQUENCY_MULTIPLIER;\n\n\treturn sysfs_emit(buff, \"%u\\n\", val);\n}\n\nstatic ssize_t media_RPn_freq_mhz_show(struct kobject *kobj,\n\t\t\t\t       struct kobj_attribute *attr,\n\t\t\t\t       char *buff)\n{\n\tstruct intel_gt *gt = intel_gt_sysfs_get_drvdata(kobj, attr->attr.name);\n\tu32 val;\n\tint err;\n\n\terr = snb_pcode_read_p(gt->uncore, XEHP_PCODE_FREQUENCY_CONFIG,\n\t\t\t       PCODE_MBOX_FC_SC_READ_FUSED_PN,\n\t\t\t       PCODE_MBOX_DOMAIN_MEDIAFF, &val);\n\n\tif (err)\n\t\treturn err;\n\n\t \n\tval *= GT_FREQUENCY_MULTIPLIER;\n\n\treturn sysfs_emit(buff, \"%u\\n\", val);\n}\n\nINTEL_GT_ATTR_RW(media_freq_factor);\nstatic struct kobj_attribute attr_media_freq_factor_scale =\n\t__ATTR(media_freq_factor.scale, 0444, freq_factor_scale_show, NULL);\nINTEL_GT_ATTR_RO(media_RP0_freq_mhz);\nINTEL_GT_ATTR_RO(media_RPn_freq_mhz);\n\nINTEL_GT_ATTR_RW(slpc_ignore_eff_freq);\n\nstatic const struct attribute *media_perf_power_attrs[] = {\n\t&attr_media_freq_factor.attr,\n\t&attr_media_freq_factor_scale.attr,\n\t&attr_media_RP0_freq_mhz.attr,\n\t&attr_media_RPn_freq_mhz.attr,\n\tNULL\n};\n\nstatic ssize_t\nrps_up_threshold_pct_show(struct kobject *kobj, struct kobj_attribute *attr,\n\t\t\t  char *buf)\n{\n\tstruct intel_gt *gt = intel_gt_sysfs_get_drvdata(kobj, attr->attr.name);\n\tstruct intel_rps *rps = &gt->rps;\n\n\treturn sysfs_emit(buf, \"%u\\n\", intel_rps_get_up_threshold(rps));\n}\n\nstatic ssize_t\nrps_up_threshold_pct_store(struct kobject *kobj, struct kobj_attribute *attr,\n\t\t\t   const char *buf, size_t count)\n{\n\tstruct intel_gt *gt = intel_gt_sysfs_get_drvdata(kobj, attr->attr.name);\n\tstruct intel_rps *rps = &gt->rps;\n\tint ret;\n\tu8 val;\n\n\tret = kstrtou8(buf, 10, &val);\n\tif (ret)\n\t\treturn ret;\n\n\tret = intel_rps_set_up_threshold(rps, val);\n\n\treturn ret == 0 ? count : ret;\n}\n\nstatic struct kobj_attribute rps_up_threshold_pct =\n\t__ATTR(rps_up_threshold_pct,\n\t       0664,\n\t       rps_up_threshold_pct_show,\n\t       rps_up_threshold_pct_store);\n\nstatic ssize_t\nrps_down_threshold_pct_show(struct kobject *kobj, struct kobj_attribute *attr,\n\t\t\t    char *buf)\n{\n\tstruct intel_gt *gt = intel_gt_sysfs_get_drvdata(kobj, attr->attr.name);\n\tstruct intel_rps *rps = &gt->rps;\n\n\treturn sysfs_emit(buf, \"%u\\n\", intel_rps_get_down_threshold(rps));\n}\n\nstatic ssize_t\nrps_down_threshold_pct_store(struct kobject *kobj, struct kobj_attribute *attr,\n\t\t\t     const char *buf, size_t count)\n{\n\tstruct intel_gt *gt = intel_gt_sysfs_get_drvdata(kobj, attr->attr.name);\n\tstruct intel_rps *rps = &gt->rps;\n\tint ret;\n\tu8 val;\n\n\tret = kstrtou8(buf, 10, &val);\n\tif (ret)\n\t\treturn ret;\n\n\tret = intel_rps_set_down_threshold(rps, val);\n\n\treturn ret == 0 ? count : ret;\n}\n\nstatic struct kobj_attribute rps_down_threshold_pct =\n\t__ATTR(rps_down_threshold_pct,\n\t       0664,\n\t       rps_down_threshold_pct_show,\n\t       rps_down_threshold_pct_store);\n\nstatic const struct attribute * const gen6_gt_rps_attrs[] = {\n\t&rps_up_threshold_pct.attr,\n\t&rps_down_threshold_pct.attr,\n\tNULL\n};\n\nstatic ssize_t\ndefault_min_freq_mhz_show(struct kobject *kobj, struct kobj_attribute *attr, char *buf)\n{\n\tstruct intel_gt *gt = kobj_to_gt(kobj->parent);\n\n\treturn sysfs_emit(buf, \"%u\\n\", gt->defaults.min_freq);\n}\n\nstatic struct kobj_attribute default_min_freq_mhz =\n__ATTR(rps_min_freq_mhz, 0444, default_min_freq_mhz_show, NULL);\n\nstatic ssize_t\ndefault_max_freq_mhz_show(struct kobject *kobj, struct kobj_attribute *attr, char *buf)\n{\n\tstruct intel_gt *gt = kobj_to_gt(kobj->parent);\n\n\treturn sysfs_emit(buf, \"%u\\n\", gt->defaults.max_freq);\n}\n\nstatic struct kobj_attribute default_max_freq_mhz =\n__ATTR(rps_max_freq_mhz, 0444, default_max_freq_mhz_show, NULL);\n\nstatic ssize_t\ndefault_rps_up_threshold_pct_show(struct kobject *kobj,\n\t\t\t\t  struct kobj_attribute *attr,\n\t\t\t\t  char *buf)\n{\n\tstruct intel_gt *gt = kobj_to_gt(kobj->parent);\n\n\treturn sysfs_emit(buf, \"%u\\n\", gt->defaults.rps_up_threshold);\n}\n\nstatic struct kobj_attribute default_rps_up_threshold_pct =\n__ATTR(rps_up_threshold_pct, 0444, default_rps_up_threshold_pct_show, NULL);\n\nstatic ssize_t\ndefault_rps_down_threshold_pct_show(struct kobject *kobj,\n\t\t\t\t    struct kobj_attribute *attr,\n\t\t\t\t    char *buf)\n{\n\tstruct intel_gt *gt = kobj_to_gt(kobj->parent);\n\n\treturn sysfs_emit(buf, \"%u\\n\", gt->defaults.rps_down_threshold);\n}\n\nstatic struct kobj_attribute default_rps_down_threshold_pct =\n__ATTR(rps_down_threshold_pct, 0444, default_rps_down_threshold_pct_show, NULL);\n\nstatic const struct attribute * const rps_defaults_attrs[] = {\n\t&default_min_freq_mhz.attr,\n\t&default_max_freq_mhz.attr,\n\t&default_rps_up_threshold_pct.attr,\n\t&default_rps_down_threshold_pct.attr,\n\tNULL\n};\n\nstatic int intel_sysfs_rps_init(struct intel_gt *gt, struct kobject *kobj)\n{\n\tconst struct attribute * const *attrs;\n\tstruct attribute *vlv_attr;\n\tint ret;\n\n\tif (GRAPHICS_VER(gt->i915) < 6)\n\t\treturn 0;\n\n\tif (is_object_gt(kobj)) {\n\t\tattrs = gen6_rps_attrs;\n\t\tvlv_attr = &attr_rps_vlv_rpe_freq_mhz.attr;\n\t} else {\n\t\tattrs = gen6_gt_attrs;\n\t\tvlv_attr = &dev_attr_gt_vlv_rpe_freq_mhz.attr;\n\t}\n\n\tret = sysfs_create_files(kobj, attrs);\n\tif (ret)\n\t\treturn ret;\n\n\tif (IS_VALLEYVIEW(gt->i915) || IS_CHERRYVIEW(gt->i915))\n\t\tret = sysfs_create_file(kobj, vlv_attr);\n\n\tif (is_object_gt(kobj) && !intel_uc_uses_guc_slpc(&gt->uc)) {\n\t\tret = sysfs_create_files(kobj, gen6_gt_rps_attrs);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn ret;\n}\n\nvoid intel_gt_sysfs_pm_init(struct intel_gt *gt, struct kobject *kobj)\n{\n\tint ret;\n\n\tintel_sysfs_rc6_init(gt, kobj);\n\n\tret = intel_sysfs_rps_init(gt, kobj);\n\tif (ret)\n\t\tgt_warn(gt, \"failed to create RPS sysfs files (%pe)\", ERR_PTR(ret));\n\n\t \n\tif (!is_object_gt(kobj))\n\t\treturn;\n\n\tret = sysfs_create_file(kobj, &attr_punit_req_freq_mhz.attr);\n\tif (ret)\n\t\tgt_warn(gt, \"failed to create punit_req_freq_mhz sysfs (%pe)\", ERR_PTR(ret));\n\n\tif (intel_uc_uses_guc_slpc(&gt->uc)) {\n\t\tret = sysfs_create_file(kobj, &attr_slpc_ignore_eff_freq.attr);\n\t\tif (ret)\n\t\t\tgt_warn(gt, \"failed to create ignore_eff_freq sysfs (%pe)\", ERR_PTR(ret));\n\t}\n\n\tif (i915_mmio_reg_valid(intel_gt_perf_limit_reasons_reg(gt))) {\n\t\tret = sysfs_create_files(kobj, throttle_reason_attrs);\n\t\tif (ret)\n\t\t\tgt_warn(gt, \"failed to create throttle sysfs files (%pe)\", ERR_PTR(ret));\n\t}\n\n\tif (HAS_MEDIA_RATIO_MODE(gt->i915) && intel_uc_uses_guc_slpc(&gt->uc)) {\n\t\tret = sysfs_create_files(kobj, media_perf_power_attrs);\n\t\tif (ret)\n\t\t\tgt_warn(gt, \"failed to create media_perf_power_attrs sysfs (%pe)\\n\",\n\t\t\t\tERR_PTR(ret));\n\t}\n\n\tret = sysfs_create_files(gt->sysfs_defaults, rps_defaults_attrs);\n\tif (ret)\n\t\tgt_warn(gt, \"failed to add rps defaults (%pe)\\n\", ERR_PTR(ret));\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}