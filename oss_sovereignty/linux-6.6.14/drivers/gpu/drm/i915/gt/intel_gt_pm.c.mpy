{
  "module_name": "intel_gt_pm.c",
  "hash_id": "b1ad16310dc54b8d29916a81caa179a8e5a88795a3c4ed524a869bd172a1e4d4",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/i915/gt/intel_gt_pm.c",
  "human_readable_source": "\n \n\n#include <linux/string_helpers.h>\n#include <linux/suspend.h>\n\n#include \"i915_drv.h\"\n#include \"i915_irq.h\"\n#include \"i915_params.h\"\n#include \"intel_context.h\"\n#include \"intel_engine_pm.h\"\n#include \"intel_gt.h\"\n#include \"intel_gt_clock_utils.h\"\n#include \"intel_gt_pm.h\"\n#include \"intel_gt_print.h\"\n#include \"intel_gt_requests.h\"\n#include \"intel_llc.h\"\n#include \"intel_rc6.h\"\n#include \"intel_rps.h\"\n#include \"intel_wakeref.h\"\n#include \"pxp/intel_pxp_pm.h\"\n\n#define I915_GT_SUSPEND_IDLE_TIMEOUT (HZ / 2)\n\nstatic void user_forcewake(struct intel_gt *gt, bool suspend)\n{\n\tint count = atomic_read(&gt->user_wakeref);\n\n\t \n\tif (likely(!count))\n\t\treturn;\n\n\tintel_gt_pm_get(gt);\n\tif (suspend) {\n\t\tGEM_BUG_ON(count > atomic_read(&gt->wakeref.count));\n\t\tatomic_sub(count, &gt->wakeref.count);\n\t} else {\n\t\tatomic_add(count, &gt->wakeref.count);\n\t}\n\tintel_gt_pm_put(gt);\n}\n\nstatic void runtime_begin(struct intel_gt *gt)\n{\n\tlocal_irq_disable();\n\twrite_seqcount_begin(&gt->stats.lock);\n\tgt->stats.start = ktime_get();\n\tgt->stats.active = true;\n\twrite_seqcount_end(&gt->stats.lock);\n\tlocal_irq_enable();\n}\n\nstatic void runtime_end(struct intel_gt *gt)\n{\n\tlocal_irq_disable();\n\twrite_seqcount_begin(&gt->stats.lock);\n\tgt->stats.active = false;\n\tgt->stats.total =\n\t\tktime_add(gt->stats.total,\n\t\t\t  ktime_sub(ktime_get(), gt->stats.start));\n\twrite_seqcount_end(&gt->stats.lock);\n\tlocal_irq_enable();\n}\n\nstatic int __gt_unpark(struct intel_wakeref *wf)\n{\n\tstruct intel_gt *gt = container_of(wf, typeof(*gt), wakeref);\n\tstruct drm_i915_private *i915 = gt->i915;\n\n\tGT_TRACE(gt, \"\\n\");\n\n\t \n\tgt->awake = intel_display_power_get(i915, POWER_DOMAIN_GT_IRQ);\n\tGEM_BUG_ON(!gt->awake);\n\n\tintel_rc6_unpark(&gt->rc6);\n\tintel_rps_unpark(&gt->rps);\n\ti915_pmu_gt_unparked(gt);\n\tintel_guc_busyness_unpark(gt);\n\n\tintel_gt_unpark_requests(gt);\n\truntime_begin(gt);\n\n\treturn 0;\n}\n\nstatic int __gt_park(struct intel_wakeref *wf)\n{\n\tstruct intel_gt *gt = container_of(wf, typeof(*gt), wakeref);\n\tintel_wakeref_t wakeref = fetch_and_zero(&gt->awake);\n\tstruct drm_i915_private *i915 = gt->i915;\n\n\tGT_TRACE(gt, \"\\n\");\n\n\truntime_end(gt);\n\tintel_gt_park_requests(gt);\n\n\tintel_guc_busyness_park(gt);\n\ti915_vma_parked(gt);\n\ti915_pmu_gt_parked(gt);\n\tintel_rps_park(&gt->rps);\n\tintel_rc6_park(&gt->rc6);\n\n\t \n\tintel_synchronize_irq(i915);\n\n\t \n\tGEM_BUG_ON(!wakeref);\n\tintel_display_power_put_async(i915, POWER_DOMAIN_GT_IRQ, wakeref);\n\n\treturn 0;\n}\n\nstatic const struct intel_wakeref_ops wf_ops = {\n\t.get = __gt_unpark,\n\t.put = __gt_park,\n};\n\nvoid intel_gt_pm_init_early(struct intel_gt *gt)\n{\n\t \n\tintel_wakeref_init(&gt->wakeref, gt->i915, &wf_ops);\n\tseqcount_mutex_init(&gt->stats.lock, &gt->wakeref.mutex);\n}\n\nvoid intel_gt_pm_init(struct intel_gt *gt)\n{\n\t \n\tintel_rc6_init(&gt->rc6);\n\tintel_rps_init(&gt->rps);\n}\n\nstatic bool reset_engines(struct intel_gt *gt)\n{\n\tif (INTEL_INFO(gt->i915)->gpu_reset_clobbers_display)\n\t\treturn false;\n\n\treturn __intel_gt_reset(gt, ALL_ENGINES) == 0;\n}\n\nstatic void gt_sanitize(struct intel_gt *gt, bool force)\n{\n\tstruct intel_engine_cs *engine;\n\tenum intel_engine_id id;\n\tintel_wakeref_t wakeref;\n\n\tGT_TRACE(gt, \"force:%s\", str_yes_no(force));\n\n\t \n\twakeref = intel_runtime_pm_get(gt->uncore->rpm);\n\tintel_uncore_forcewake_get(gt->uncore, FORCEWAKE_ALL);\n\n\tintel_gt_check_clock_frequency(gt);\n\n\t \n\tif (intel_gt_is_wedged(gt))\n\t\tintel_gt_unset_wedged(gt);\n\n\t \n\tintel_uc_reset_prepare(&gt->uc);\n\n\tfor_each_engine(engine, gt, id) {\n\t\tif (engine->reset.prepare)\n\t\t\tengine->reset.prepare(engine);\n\n\t\tif (engine->sanitize)\n\t\t\tengine->sanitize(engine);\n\t}\n\n\tif (reset_engines(gt) || force) {\n\t\tfor_each_engine(engine, gt, id)\n\t\t\t__intel_engine_reset(engine, false);\n\t}\n\n\tintel_uc_reset(&gt->uc, false);\n\n\tfor_each_engine(engine, gt, id)\n\t\tif (engine->reset.finish)\n\t\t\tengine->reset.finish(engine);\n\n\tintel_rps_sanitize(&gt->rps);\n\n\tintel_uncore_forcewake_put(gt->uncore, FORCEWAKE_ALL);\n\tintel_runtime_pm_put(gt->uncore->rpm, wakeref);\n}\n\nvoid intel_gt_pm_fini(struct intel_gt *gt)\n{\n\tintel_rc6_fini(&gt->rc6);\n}\n\nint intel_gt_resume(struct intel_gt *gt)\n{\n\tstruct intel_engine_cs *engine;\n\tenum intel_engine_id id;\n\tint err;\n\n\terr = intel_gt_has_unrecoverable_error(gt);\n\tif (err)\n\t\treturn err;\n\n\tGT_TRACE(gt, \"\\n\");\n\n\t \n\tgt_sanitize(gt, true);\n\n\tintel_gt_pm_get(gt);\n\n\tintel_uncore_forcewake_get(gt->uncore, FORCEWAKE_ALL);\n\tintel_rc6_sanitize(&gt->rc6);\n\tif (intel_gt_is_wedged(gt)) {\n\t\terr = -EIO;\n\t\tgoto out_fw;\n\t}\n\n\t \n\terr = intel_gt_init_hw(gt);\n\tif (err) {\n\t\tgt_probe_error(gt, \"Failed to initialize GPU, declaring it wedged!\\n\");\n\t\tgoto err_wedged;\n\t}\n\n\tintel_uc_reset_finish(&gt->uc);\n\n\tintel_rps_enable(&gt->rps);\n\tintel_llc_enable(&gt->llc);\n\n\tfor_each_engine(engine, gt, id) {\n\t\tintel_engine_pm_get(engine);\n\n\t\tengine->serial++;  \n\t\terr = intel_engine_resume(engine);\n\n\t\tintel_engine_pm_put(engine);\n\t\tif (err) {\n\t\t\tgt_err(gt, \"Failed to restart %s (%d)\\n\",\n\t\t\t       engine->name, err);\n\t\t\tgoto err_wedged;\n\t\t}\n\t}\n\n\tintel_rc6_enable(&gt->rc6);\n\n\tintel_uc_resume(&gt->uc);\n\n\tuser_forcewake(gt, false);\n\nout_fw:\n\tintel_uncore_forcewake_put(gt->uncore, FORCEWAKE_ALL);\n\tintel_gt_pm_put(gt);\n\treturn err;\n\nerr_wedged:\n\tintel_gt_set_wedged(gt);\n\tgoto out_fw;\n}\n\nstatic void wait_for_suspend(struct intel_gt *gt)\n{\n\tif (!intel_gt_pm_is_awake(gt))\n\t\treturn;\n\n\tif (intel_gt_wait_for_idle(gt, I915_GT_SUSPEND_IDLE_TIMEOUT) == -ETIME) {\n\t\t \n\t\tintel_gt_set_wedged(gt);\n\t\tintel_gt_retire_requests(gt);\n\t}\n\n\tintel_gt_pm_wait_for_idle(gt);\n}\n\nvoid intel_gt_suspend_prepare(struct intel_gt *gt)\n{\n\tuser_forcewake(gt, true);\n\twait_for_suspend(gt);\n}\n\nstatic suspend_state_t pm_suspend_target(void)\n{\n#if IS_ENABLED(CONFIG_SUSPEND) && IS_ENABLED(CONFIG_PM_SLEEP)\n\treturn pm_suspend_target_state;\n#else\n\treturn PM_SUSPEND_TO_IDLE;\n#endif\n}\n\nvoid intel_gt_suspend_late(struct intel_gt *gt)\n{\n\tintel_wakeref_t wakeref;\n\n\t \n\twait_for_suspend(gt);\n\n\tif (is_mock_gt(gt))\n\t\treturn;\n\n\tGEM_BUG_ON(gt->awake);\n\n\tintel_uc_suspend(&gt->uc);\n\n\t \n\tif (pm_suspend_target() == PM_SUSPEND_TO_IDLE)\n\t\treturn;\n\n\twith_intel_runtime_pm(gt->uncore->rpm, wakeref) {\n\t\tintel_rps_disable(&gt->rps);\n\t\tintel_rc6_disable(&gt->rc6);\n\t\tintel_llc_disable(&gt->llc);\n\t}\n\n\tgt_sanitize(gt, false);\n\n\tGT_TRACE(gt, \"\\n\");\n}\n\nvoid intel_gt_runtime_suspend(struct intel_gt *gt)\n{\n\tintel_uc_runtime_suspend(&gt->uc);\n\n\tGT_TRACE(gt, \"\\n\");\n}\n\nint intel_gt_runtime_resume(struct intel_gt *gt)\n{\n\tint ret;\n\n\tGT_TRACE(gt, \"\\n\");\n\tintel_gt_init_swizzling(gt);\n\tintel_ggtt_restore_fences(gt->ggtt);\n\n\tret = intel_uc_runtime_resume(&gt->uc);\n\tif (ret)\n\t\treturn ret;\n\n\treturn 0;\n}\n\nstatic ktime_t __intel_gt_get_awake_time(const struct intel_gt *gt)\n{\n\tktime_t total = gt->stats.total;\n\n\tif (gt->stats.active)\n\t\ttotal = ktime_add(total,\n\t\t\t\t  ktime_sub(ktime_get(), gt->stats.start));\n\n\treturn total;\n}\n\nktime_t intel_gt_get_awake_time(const struct intel_gt *gt)\n{\n\tunsigned int seq;\n\tktime_t total;\n\n\tdo {\n\t\tseq = read_seqcount_begin(&gt->stats.lock);\n\t\ttotal = __intel_gt_get_awake_time(gt);\n\t} while (read_seqcount_retry(&gt->stats.lock, seq));\n\n\treturn total;\n}\n\n#if IS_ENABLED(CONFIG_DRM_I915_SELFTEST)\n#include \"selftest_gt_pm.c\"\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}