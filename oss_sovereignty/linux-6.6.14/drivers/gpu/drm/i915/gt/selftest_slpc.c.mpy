{
  "module_name": "selftest_slpc.c",
  "hash_id": "deebc45e2aae3ce652457b7a69d25ace734030b34879921cb0beca2bb7bb5be6",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/i915/gt/selftest_slpc.c",
  "human_readable_source": "\n \n\n#define NUM_STEPS 5\n#define H2G_DELAY 50000\n#define delay_for_h2g() usleep_range(H2G_DELAY, H2G_DELAY + 10000)\n#define FREQUENCY_REQ_UNIT\tDIV_ROUND_CLOSEST(GT_FREQUENCY_MULTIPLIER, \\\n\t\t\t\t\t\t  GEN9_FREQ_SCALER)\nenum test_type {\n\tVARY_MIN,\n\tVARY_MAX,\n\tMAX_GRANTED,\n\tSLPC_POWER,\n\tTILE_INTERACTION,\n};\n\nstruct slpc_thread {\n\tstruct kthread_worker *worker;\n\tstruct kthread_work work;\n\tstruct intel_gt *gt;\n\tint result;\n};\n\nstatic int slpc_set_min_freq(struct intel_guc_slpc *slpc, u32 freq)\n{\n\tint ret;\n\n\tret = intel_guc_slpc_set_min_freq(slpc, freq);\n\tif (ret)\n\t\tpr_err(\"Could not set min frequency to [%u]\\n\", freq);\n\telse  \n\t\tdelay_for_h2g();\n\n\treturn ret;\n}\n\nstatic int slpc_set_max_freq(struct intel_guc_slpc *slpc, u32 freq)\n{\n\tint ret;\n\n\tret = intel_guc_slpc_set_max_freq(slpc, freq);\n\tif (ret)\n\t\tpr_err(\"Could not set maximum frequency [%u]\\n\",\n\t\t       freq);\n\telse  \n\t\tdelay_for_h2g();\n\n\treturn ret;\n}\n\nstatic int slpc_set_freq(struct intel_gt *gt, u32 freq)\n{\n\tint err;\n\tstruct intel_guc_slpc *slpc = &gt->uc.guc.slpc;\n\n\terr = slpc_set_max_freq(slpc, freq);\n\tif (err) {\n\t\tpr_err(\"Unable to update max freq\");\n\t\treturn err;\n\t}\n\n\terr = slpc_set_min_freq(slpc, freq);\n\tif (err) {\n\t\tpr_err(\"Unable to update min freq\");\n\t\treturn err;\n\t}\n\n\treturn err;\n}\n\nstatic int slpc_restore_freq(struct intel_guc_slpc *slpc, u32 min, u32 max)\n{\n\tint err;\n\n\terr = slpc_set_max_freq(slpc, max);\n\tif (err) {\n\t\tpr_err(\"Unable to restore max freq\");\n\t\treturn err;\n\t}\n\n\terr = slpc_set_min_freq(slpc, min);\n\tif (err) {\n\t\tpr_err(\"Unable to restore min freq\");\n\t\treturn err;\n\t}\n\n\terr = intel_guc_slpc_set_ignore_eff_freq(slpc, false);\n\tif (err) {\n\t\tpr_err(\"Unable to restore efficient freq\");\n\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\nstatic u64 measure_power_at_freq(struct intel_gt *gt, int *freq, u64 *power)\n{\n\tint err = 0;\n\n\terr = slpc_set_freq(gt, *freq);\n\tif (err)\n\t\treturn err;\n\t*freq = intel_rps_read_actual_frequency(&gt->rps);\n\t*power = measure_power(&gt->rps, freq);\n\n\treturn err;\n}\n\nstatic int vary_max_freq(struct intel_guc_slpc *slpc, struct intel_rps *rps,\n\t\t\t u32 *max_act_freq)\n{\n\tu32 step, max_freq, req_freq;\n\tu32 act_freq;\n\tint err = 0;\n\n\t \n\tstep = (slpc->rp0_freq - slpc->min_freq) / NUM_STEPS;\n\t*max_act_freq = slpc->min_freq;\n\tfor (max_freq = slpc->rp0_freq; max_freq > slpc->min_freq;\n\t\t\t\tmax_freq -= step) {\n\t\terr = slpc_set_max_freq(slpc, max_freq);\n\t\tif (err)\n\t\t\tbreak;\n\n\t\treq_freq = intel_rps_read_punit_req_frequency(rps);\n\n\t\t \n\t\tif (req_freq > (max_freq + FREQUENCY_REQ_UNIT)) {\n\t\t\tpr_err(\"SWReq is %d, should be at most %d\\n\", req_freq,\n\t\t\t       max_freq + FREQUENCY_REQ_UNIT);\n\t\t\terr = -EINVAL;\n\t\t}\n\n\t\tact_freq =  intel_rps_read_actual_frequency(rps);\n\t\tif (act_freq > *max_act_freq)\n\t\t\t*max_act_freq = act_freq;\n\n\t\tif (err)\n\t\t\tbreak;\n\t}\n\n\treturn err;\n}\n\nstatic int vary_min_freq(struct intel_guc_slpc *slpc, struct intel_rps *rps,\n\t\t\t u32 *max_act_freq)\n{\n\tu32 step, min_freq, req_freq;\n\tu32 act_freq;\n\tint err = 0;\n\n\t \n\tstep = (slpc->rp0_freq - slpc->min_freq) / NUM_STEPS;\n\t*max_act_freq = slpc->min_freq;\n\tfor (min_freq = slpc->min_freq; min_freq < slpc->rp0_freq;\n\t\t\t\tmin_freq += step) {\n\t\terr = slpc_set_min_freq(slpc, min_freq);\n\t\tif (err)\n\t\t\tbreak;\n\n\t\treq_freq = intel_rps_read_punit_req_frequency(rps);\n\n\t\t \n\t\tif (req_freq < (min_freq - FREQUENCY_REQ_UNIT)) {\n\t\t\tpr_err(\"SWReq is %d, should be at least %d\\n\", req_freq,\n\t\t\t       min_freq - FREQUENCY_REQ_UNIT);\n\t\t\terr = -EINVAL;\n\t\t}\n\n\t\tact_freq =  intel_rps_read_actual_frequency(rps);\n\t\tif (act_freq > *max_act_freq)\n\t\t\t*max_act_freq = act_freq;\n\n\t\tif (err)\n\t\t\tbreak;\n\t}\n\n\treturn err;\n}\n\nstatic int slpc_power(struct intel_gt *gt, struct intel_engine_cs *engine)\n{\n\tstruct intel_guc_slpc *slpc = &gt->uc.guc.slpc;\n\tstruct {\n\t\tu64 power;\n\t\tint freq;\n\t} min, max;\n\tint err = 0;\n\n\t \n\tif (!librapl_supported(gt->i915))\n\t\treturn 0;\n\n\tmin.freq = slpc->min_freq;\n\terr = measure_power_at_freq(gt, &min.freq, &min.power);\n\n\tif (err)\n\t\treturn err;\n\n\tmax.freq = slpc->rp0_freq;\n\terr = measure_power_at_freq(gt, &max.freq, &max.power);\n\n\tif (err)\n\t\treturn err;\n\n\tpr_info(\"%s: min:%llumW @ %uMHz, max:%llumW @ %uMHz\\n\",\n\t\tengine->name,\n\t\tmin.power, min.freq,\n\t\tmax.power, max.freq);\n\n\tif (10 * min.freq >= 9 * max.freq) {\n\t\tpr_notice(\"Could not control frequency, ran at [%uMHz, %uMhz]\\n\",\n\t\t\t  min.freq, max.freq);\n\t}\n\n\tif (11 * min.power > 10 * max.power) {\n\t\tpr_err(\"%s: did not conserve power when setting lower frequency!\\n\",\n\t\t       engine->name);\n\t\terr = -EINVAL;\n\t}\n\n\t \n\tslpc_set_max_freq(slpc, slpc->rp0_freq);\n\tslpc_set_min_freq(slpc, slpc->min_freq);\n\n\treturn err;\n}\n\nstatic int max_granted_freq(struct intel_guc_slpc *slpc, struct intel_rps *rps, u32 *max_act_freq)\n{\n\tstruct intel_gt *gt = rps_to_gt(rps);\n\tu32 perf_limit_reasons;\n\tint err = 0;\n\n\terr = slpc_set_min_freq(slpc, slpc->rp0_freq);\n\tif (err)\n\t\treturn err;\n\n\t*max_act_freq =  intel_rps_read_actual_frequency(rps);\n\tif (*max_act_freq != slpc->rp0_freq) {\n\t\t \n\t\tperf_limit_reasons = intel_uncore_read(gt->uncore,\n\t\t\t\t\t\t       intel_gt_perf_limit_reasons_reg(gt));\n\n\t\t \n\t\tif (!(perf_limit_reasons & GT0_PERF_LIMIT_REASONS_MASK)) {\n\t\t\tpr_err(\"Pcode did not grant max freq\\n\");\n\t\t\terr = -EINVAL;\n\t\t} else {\n\t\t\tpr_info(\"Pcode throttled frequency 0x%x\\n\", perf_limit_reasons);\n\t\t}\n\t}\n\n\treturn err;\n}\n\nstatic int run_test(struct intel_gt *gt, int test_type)\n{\n\tstruct intel_guc_slpc *slpc = &gt->uc.guc.slpc;\n\tstruct intel_rps *rps = &gt->rps;\n\tstruct intel_engine_cs *engine;\n\tenum intel_engine_id id;\n\tstruct igt_spinner spin;\n\tu32 slpc_min_freq, slpc_max_freq;\n\tint err = 0;\n\n\tif (!intel_uc_uses_guc_slpc(&gt->uc))\n\t\treturn 0;\n\n\tif (slpc->min_freq == slpc->rp0_freq) {\n\t\tpr_err(\"Min/Max are fused to the same value\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (igt_spinner_init(&spin, gt))\n\t\treturn -ENOMEM;\n\n\tif (intel_guc_slpc_get_max_freq(slpc, &slpc_max_freq)) {\n\t\tpr_err(\"Could not get SLPC max freq\\n\");\n\t\treturn -EIO;\n\t}\n\n\tif (intel_guc_slpc_get_min_freq(slpc, &slpc_min_freq)) {\n\t\tpr_err(\"Could not get SLPC min freq\\n\");\n\t\treturn -EIO;\n\t}\n\n\t \n\terr = slpc_set_min_freq(slpc, slpc->min_freq);\n\tif (err) {\n\t\tpr_err(\"Unable to update min freq!\");\n\t\treturn err;\n\t}\n\n\t \n\terr = intel_guc_slpc_set_ignore_eff_freq(slpc, true);\n\tif (err) {\n\t\tpr_err(\"Unable to turn off efficient freq!\");\n\t\treturn err;\n\t}\n\n\tintel_gt_pm_wait_for_idle(gt);\n\tintel_gt_pm_get(gt);\n\tfor_each_engine(engine, gt, id) {\n\t\tstruct i915_request *rq;\n\t\tu32 max_act_freq;\n\n\t\tif (!intel_engine_can_store_dword(engine))\n\t\t\tcontinue;\n\n\t\tst_engine_heartbeat_disable(engine);\n\n\t\trq = igt_spinner_create_request(&spin,\n\t\t\t\t\t\tengine->kernel_context,\n\t\t\t\t\t\tMI_NOOP);\n\t\tif (IS_ERR(rq)) {\n\t\t\terr = PTR_ERR(rq);\n\t\t\tst_engine_heartbeat_enable(engine);\n\t\t\tbreak;\n\t\t}\n\n\t\ti915_request_add(rq);\n\n\t\tif (!igt_wait_for_spinner(&spin, rq)) {\n\t\t\tpr_err(\"%s: Spinner did not start\\n\",\n\t\t\t       engine->name);\n\t\t\tigt_spinner_end(&spin);\n\t\t\tst_engine_heartbeat_enable(engine);\n\t\t\tintel_gt_set_wedged(engine->gt);\n\t\t\terr = -EIO;\n\t\t\tbreak;\n\t\t}\n\n\t\tswitch (test_type) {\n\t\tcase VARY_MIN:\n\t\t\terr = vary_min_freq(slpc, rps, &max_act_freq);\n\t\t\tbreak;\n\n\t\tcase VARY_MAX:\n\t\t\terr = vary_max_freq(slpc, rps, &max_act_freq);\n\t\t\tbreak;\n\n\t\tcase MAX_GRANTED:\n\t\tcase TILE_INTERACTION:\n\t\t\t \n\t\t\tif (gt->type != GT_MEDIA && (engine->class == VIDEO_DECODE_CLASS ||\n\t\t\t\t\t\t     engine->class == VIDEO_ENHANCEMENT_CLASS)) {\n\t\t\t\tigt_spinner_end(&spin);\n\t\t\t\tst_engine_heartbeat_enable(engine);\n\t\t\t\terr = 0;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\terr = max_granted_freq(slpc, rps, &max_act_freq);\n\t\t\tbreak;\n\n\t\tcase SLPC_POWER:\n\t\t\terr = slpc_power(gt, engine);\n\t\t\tbreak;\n\t\t}\n\n\t\tif (test_type != SLPC_POWER) {\n\t\t\tpr_info(\"Max actual frequency for %s was %d\\n\",\n\t\t\t\tengine->name, max_act_freq);\n\n\t\t\t \n\t\t\tif (max_act_freq <= slpc->min_freq) {\n\t\t\t\tpr_err(\"Actual freq did not rise above min\\n\");\n\t\t\t\tpr_err(\"Perf Limit Reasons: 0x%x\\n\",\n\t\t\t\t       intel_uncore_read(gt->uncore,\n\t\t\t\t\t\t\t intel_gt_perf_limit_reasons_reg(gt)));\n\t\t\t\terr = -EINVAL;\n\t\t\t}\n\t\t}\n\n\t\tigt_spinner_end(&spin);\n\t\tst_engine_heartbeat_enable(engine);\n\n\t\tif (err)\n\t\t\tbreak;\n\t}\n\n\t \n\terr = slpc_restore_freq(slpc, slpc_min_freq, slpc_max_freq);\n\n\tif (igt_flush_test(gt->i915))\n\t\terr = -EIO;\n\n\tintel_gt_pm_put(gt);\n\tigt_spinner_fini(&spin);\n\tintel_gt_pm_wait_for_idle(gt);\n\n\treturn err;\n}\n\nstatic int live_slpc_vary_min(void *arg)\n{\n\tstruct drm_i915_private *i915 = arg;\n\tstruct intel_gt *gt;\n\tunsigned int i;\n\tint ret;\n\n\tfor_each_gt(gt, i915, i) {\n\t\tret = run_test(gt, VARY_MIN);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn ret;\n}\n\nstatic int live_slpc_vary_max(void *arg)\n{\n\tstruct drm_i915_private *i915 = arg;\n\tstruct intel_gt *gt;\n\tunsigned int i;\n\tint ret;\n\n\tfor_each_gt(gt, i915, i) {\n\t\tret = run_test(gt, VARY_MAX);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn ret;\n}\n\n \nstatic int live_slpc_max_granted(void *arg)\n{\n\tstruct drm_i915_private *i915 = arg;\n\tstruct intel_gt *gt;\n\tunsigned int i;\n\tint ret;\n\n\tfor_each_gt(gt, i915, i) {\n\t\tret = run_test(gt, MAX_GRANTED);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn ret;\n}\n\nstatic int live_slpc_power(void *arg)\n{\n\tstruct drm_i915_private *i915 = arg;\n\tstruct intel_gt *gt;\n\tunsigned int i;\n\tint ret;\n\n\tfor_each_gt(gt, i915, i) {\n\t\tret = run_test(gt, SLPC_POWER);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn ret;\n}\n\nstatic void slpc_spinner_thread(struct kthread_work *work)\n{\n\tstruct slpc_thread *thread = container_of(work, typeof(*thread), work);\n\n\tthread->result = run_test(thread->gt, TILE_INTERACTION);\n}\n\nstatic int live_slpc_tile_interaction(void *arg)\n{\n\tstruct drm_i915_private *i915 = arg;\n\tstruct intel_gt *gt;\n\tstruct slpc_thread *threads;\n\tint i = 0, ret = 0;\n\n\tthreads = kcalloc(I915_MAX_GT, sizeof(*threads), GFP_KERNEL);\n\tif (!threads)\n\t\treturn -ENOMEM;\n\n\tfor_each_gt(gt, i915, i) {\n\t\tthreads[i].worker = kthread_create_worker(0, \"igt/slpc_parallel:%d\", gt->info.id);\n\n\t\tif (IS_ERR(threads[i].worker)) {\n\t\t\tret = PTR_ERR(threads[i].worker);\n\t\t\tbreak;\n\t\t}\n\n\t\tthreads[i].gt = gt;\n\t\tkthread_init_work(&threads[i].work, slpc_spinner_thread);\n\t\tkthread_queue_work(threads[i].worker, &threads[i].work);\n\t}\n\n\tfor_each_gt(gt, i915, i) {\n\t\tint status;\n\n\t\tif (IS_ERR_OR_NULL(threads[i].worker))\n\t\t\tcontinue;\n\n\t\tkthread_flush_work(&threads[i].work);\n\t\tstatus = READ_ONCE(threads[i].result);\n\t\tif (status && !ret) {\n\t\t\tpr_err(\"%s GT %d failed \", __func__, gt->info.id);\n\t\t\tret = status;\n\t\t}\n\t\tkthread_destroy_worker(threads[i].worker);\n\t}\n\n\tkfree(threads);\n\treturn ret;\n}\n\nint intel_slpc_live_selftests(struct drm_i915_private *i915)\n{\n\tstatic const struct i915_subtest tests[] = {\n\t\tSUBTEST(live_slpc_vary_max),\n\t\tSUBTEST(live_slpc_vary_min),\n\t\tSUBTEST(live_slpc_max_granted),\n\t\tSUBTEST(live_slpc_power),\n\t\tSUBTEST(live_slpc_tile_interaction),\n\t};\n\n\tstruct intel_gt *gt;\n\tunsigned int i;\n\n\tfor_each_gt(gt, i915, i) {\n\t\tif (intel_gt_is_wedged(gt))\n\t\t\treturn 0;\n\t}\n\n\treturn i915_live_subtests(tests, i915);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}