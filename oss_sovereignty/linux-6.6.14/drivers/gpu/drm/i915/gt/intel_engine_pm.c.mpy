{
  "module_name": "intel_engine_pm.c",
  "hash_id": "2d04f84253bbec5bb16c923a7e542bedaf26920ac5ed0b3c78bb3f8c18cea7b1",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/i915/gt/intel_engine_pm.c",
  "human_readable_source": "\n \n\n#include \"i915_drv.h\"\n\n#include \"intel_breadcrumbs.h\"\n#include \"intel_context.h\"\n#include \"intel_engine.h\"\n#include \"intel_engine_heartbeat.h\"\n#include \"intel_engine_pm.h\"\n#include \"intel_gt.h\"\n#include \"intel_gt_pm.h\"\n#include \"intel_rc6.h\"\n#include \"intel_ring.h\"\n#include \"shmem_utils.h\"\n#include \"intel_gt_regs.h\"\n\nstatic void intel_gsc_idle_msg_enable(struct intel_engine_cs *engine)\n{\n\tstruct drm_i915_private *i915 = engine->i915;\n\n\tif (IS_METEORLAKE(i915) && engine->id == GSC0) {\n\t\tintel_uncore_write(engine->gt->uncore,\n\t\t\t\t   RC_PSMI_CTRL_GSCCS,\n\t\t\t\t   _MASKED_BIT_DISABLE(IDLE_MSG_DISABLE));\n\t\t \n\t\tintel_uncore_write(engine->gt->uncore,\n\t\t\t\t   PWRCTX_MAXCNT_GSCCS,\n\t\t\t\t   0xA);\n\t}\n}\n\nstatic void dbg_poison_ce(struct intel_context *ce)\n{\n\tif (!IS_ENABLED(CONFIG_DRM_I915_DEBUG_GEM))\n\t\treturn;\n\n\tif (ce->state) {\n\t\tstruct drm_i915_gem_object *obj = ce->state->obj;\n\t\tint type = intel_gt_coherent_map_type(ce->engine->gt, obj, true);\n\t\tvoid *map;\n\n\t\tif (!i915_gem_object_trylock(obj, NULL))\n\t\t\treturn;\n\n\t\tmap = i915_gem_object_pin_map(obj, type);\n\t\tif (!IS_ERR(map)) {\n\t\t\tmemset(map, CONTEXT_REDZONE, obj->base.size);\n\t\t\ti915_gem_object_flush_map(obj);\n\t\t\ti915_gem_object_unpin_map(obj);\n\t\t}\n\t\ti915_gem_object_unlock(obj);\n\t}\n}\n\nstatic int __engine_unpark(struct intel_wakeref *wf)\n{\n\tstruct intel_engine_cs *engine =\n\t\tcontainer_of(wf, typeof(*engine), wakeref);\n\tstruct intel_context *ce;\n\n\tENGINE_TRACE(engine, \"\\n\");\n\n\tintel_gt_pm_get(engine->gt);\n\n\t \n\tce = engine->kernel_context;\n\tif (ce) {\n\t\tGEM_BUG_ON(test_bit(CONTEXT_VALID_BIT, &ce->flags));\n\n\t\t \n\t\twhile (unlikely(intel_context_inflight(ce)))\n\t\t\tintel_engine_flush_submission(engine);\n\n\t\t \n\t\tdbg_poison_ce(ce);\n\n\t\t \n\t\tce->ops->reset(ce);\n\n\t\tCE_TRACE(ce, \"reset { seqno:%x, *hwsp:%x, ring:%x }\\n\",\n\t\t\t ce->timeline->seqno,\n\t\t\t READ_ONCE(*ce->timeline->hwsp_seqno),\n\t\t\t ce->ring->emit);\n\t\tGEM_BUG_ON(ce->timeline->seqno !=\n\t\t\t   READ_ONCE(*ce->timeline->hwsp_seqno));\n\t}\n\n\tif (engine->unpark)\n\t\tengine->unpark(engine);\n\n\tintel_breadcrumbs_unpark(engine->breadcrumbs);\n\tintel_engine_unpark_heartbeat(engine);\n\treturn 0;\n}\n\nstatic void duration(struct dma_fence *fence, struct dma_fence_cb *cb)\n{\n\tstruct i915_request *rq = to_request(fence);\n\n\tewma__engine_latency_add(&rq->engine->latency,\n\t\t\t\t ktime_us_delta(rq->fence.timestamp,\n\t\t\t\t\t\trq->duration.emitted));\n}\n\nstatic void\n__queue_and_release_pm(struct i915_request *rq,\n\t\t       struct intel_timeline *tl,\n\t\t       struct intel_engine_cs *engine)\n{\n\tstruct intel_gt_timelines *timelines = &engine->gt->timelines;\n\n\tENGINE_TRACE(engine, \"parking\\n\");\n\n\t \n\tGEM_BUG_ON(rq->context->active_count != 1);\n\t__intel_gt_pm_get(engine->gt);\n\n\t \n\tspin_lock(&timelines->lock);\n\n\t \n\tif (!atomic_fetch_inc(&tl->active_count))\n\t\tlist_add_tail(&tl->link, &timelines->active_list);\n\n\t \n\t__i915_request_queue_bh(rq);\n\n\t \n\t__intel_wakeref_defer_park(&engine->wakeref);\n\n\tspin_unlock(&timelines->lock);\n}\n\nstatic bool switch_to_kernel_context(struct intel_engine_cs *engine)\n{\n\tstruct intel_context *ce = engine->kernel_context;\n\tstruct i915_request *rq;\n\tbool result = true;\n\n\t \n\tif (intel_engine_uses_guc(engine))\n\t\treturn true;\n\n\t \n\tif (intel_gt_is_wedged(engine->gt))\n\t\treturn true;\n\n\tGEM_BUG_ON(!intel_context_is_barrier(ce));\n\tGEM_BUG_ON(ce->timeline->hwsp_ggtt != engine->status_page.vma);\n\n\t \n\tif (engine->wakeref_serial == engine->serial)\n\t\treturn true;\n\n\t \n\tset_bit(CONTEXT_IS_PARKING, &ce->flags);\n\tGEM_BUG_ON(atomic_read(&ce->timeline->active_count) < 0);\n\n\trq = __i915_request_create(ce, GFP_NOWAIT);\n\tif (IS_ERR(rq))\n\t\t \n\t\tgoto out_unlock;\n\n\t \n\tengine->wakeref_serial = engine->serial + 1;\n\ti915_request_add_active_barriers(rq);\n\n\t \n\trq->sched.attr.priority = I915_PRIORITY_BARRIER;\n\tif (likely(!__i915_request_commit(rq))) {  \n\t\t \n\t\tBUILD_BUG_ON(sizeof(rq->duration) > sizeof(rq->submitq));\n\t\tdma_fence_add_callback(&rq->fence, &rq->duration.cb, duration);\n\t\trq->duration.emitted = ktime_get();\n\t}\n\n\t \n\t__queue_and_release_pm(rq, ce->timeline, engine);\n\n\tresult = false;\nout_unlock:\n\tclear_bit(CONTEXT_IS_PARKING, &ce->flags);\n\treturn result;\n}\n\nstatic void call_idle_barriers(struct intel_engine_cs *engine)\n{\n\tstruct llist_node *node, *next;\n\n\tllist_for_each_safe(node, next, llist_del_all(&engine->barrier_tasks)) {\n\t\tstruct dma_fence_cb *cb =\n\t\t\tcontainer_of((struct list_head *)node,\n\t\t\t\t     typeof(*cb), node);\n\n\t\tcb->func(ERR_PTR(-EAGAIN), cb);\n\t}\n}\n\nstatic int __engine_park(struct intel_wakeref *wf)\n{\n\tstruct intel_engine_cs *engine =\n\t\tcontainer_of(wf, typeof(*engine), wakeref);\n\n\tengine->saturated = 0;\n\n\t \n\tif (!switch_to_kernel_context(engine))\n\t\treturn -EBUSY;\n\n\tENGINE_TRACE(engine, \"parked\\n\");\n\n\tcall_idle_barriers(engine);  \n\n\tintel_engine_park_heartbeat(engine);\n\tintel_breadcrumbs_park(engine->breadcrumbs);\n\n\t \n\tGEM_BUG_ON(engine->sched_engine->queue_priority_hint != INT_MIN);\n\n\tif (engine->park)\n\t\tengine->park(engine);\n\n\t \n\tintel_gt_pm_put_async(engine->gt);\n\treturn 0;\n}\n\nstatic const struct intel_wakeref_ops wf_ops = {\n\t.get = __engine_unpark,\n\t.put = __engine_park,\n};\n\nvoid intel_engine_init__pm(struct intel_engine_cs *engine)\n{\n\tintel_wakeref_init(&engine->wakeref, engine->i915, &wf_ops);\n\tintel_engine_init_heartbeat(engine);\n\n\tintel_gsc_idle_msg_enable(engine);\n}\n\n \nvoid intel_engine_reset_pinned_contexts(struct intel_engine_cs *engine)\n{\n\tstruct intel_context *ce;\n\n\tlist_for_each_entry(ce, &engine->pinned_contexts_list,\n\t\t\t    pinned_contexts_link) {\n\t\t \n\t\tif (ce == engine->kernel_context)\n\t\t\tcontinue;\n\n\t\tdbg_poison_ce(ce);\n\t\tce->ops->reset(ce);\n\t}\n}\n\n#if IS_ENABLED(CONFIG_DRM_I915_SELFTEST)\n#include \"selftest_engine_pm.c\"\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}