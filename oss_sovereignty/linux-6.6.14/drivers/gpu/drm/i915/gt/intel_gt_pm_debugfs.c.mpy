{
  "module_name": "intel_gt_pm_debugfs.c",
  "hash_id": "62edf4a7e0dd3bfac632ff18f3a0b7d26b84a500e6e567d16f7347d3c9631684",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/i915/gt/intel_gt_pm_debugfs.c",
  "human_readable_source": "\n\n \n\n#include <linux/seq_file.h>\n#include <linux/string_helpers.h>\n\n#include \"i915_drv.h\"\n#include \"i915_reg.h\"\n#include \"intel_gt.h\"\n#include \"intel_gt_clock_utils.h\"\n#include \"intel_gt_debugfs.h\"\n#include \"intel_gt_pm.h\"\n#include \"intel_gt_pm_debugfs.h\"\n#include \"intel_gt_regs.h\"\n#include \"intel_llc.h\"\n#include \"intel_mchbar_regs.h\"\n#include \"intel_pcode.h\"\n#include \"intel_rc6.h\"\n#include \"intel_rps.h\"\n#include \"intel_runtime_pm.h\"\n#include \"intel_uncore.h\"\n#include \"vlv_sideband.h\"\n\nvoid intel_gt_pm_debugfs_forcewake_user_open(struct intel_gt *gt)\n{\n\tatomic_inc(&gt->user_wakeref);\n\tintel_gt_pm_get(gt);\n\tif (GRAPHICS_VER(gt->i915) >= 6)\n\t\tintel_uncore_forcewake_user_get(gt->uncore);\n}\n\nvoid intel_gt_pm_debugfs_forcewake_user_release(struct intel_gt *gt)\n{\n\tif (GRAPHICS_VER(gt->i915) >= 6)\n\t\tintel_uncore_forcewake_user_put(gt->uncore);\n\tintel_gt_pm_put(gt);\n\tatomic_dec(&gt->user_wakeref);\n}\n\nstatic int forcewake_user_open(struct inode *inode, struct file *file)\n{\n\tstruct intel_gt *gt = inode->i_private;\n\n\tintel_gt_pm_debugfs_forcewake_user_open(gt);\n\n\treturn 0;\n}\n\nstatic int forcewake_user_release(struct inode *inode, struct file *file)\n{\n\tstruct intel_gt *gt = inode->i_private;\n\n\tintel_gt_pm_debugfs_forcewake_user_release(gt);\n\n\treturn 0;\n}\n\nstatic const struct file_operations forcewake_user_fops = {\n\t.owner = THIS_MODULE,\n\t.open = forcewake_user_open,\n\t.release = forcewake_user_release,\n};\n\nstatic int fw_domains_show(struct seq_file *m, void *data)\n{\n\tstruct intel_gt *gt = m->private;\n\tstruct intel_uncore *uncore = gt->uncore;\n\tstruct intel_uncore_forcewake_domain *fw_domain;\n\tunsigned int tmp;\n\n\tseq_printf(m, \"user.bypass_count = %u\\n\",\n\t\t   uncore->user_forcewake_count);\n\n\tfor_each_fw_domain(fw_domain, uncore, tmp)\n\t\tseq_printf(m, \"%s.wake_count = %u\\n\",\n\t\t\t   intel_uncore_forcewake_domain_to_str(fw_domain->id),\n\t\t\t   READ_ONCE(fw_domain->wake_count));\n\n\treturn 0;\n}\nDEFINE_INTEL_GT_DEBUGFS_ATTRIBUTE(fw_domains);\n\nstatic int vlv_drpc(struct seq_file *m)\n{\n\tstruct intel_gt *gt = m->private;\n\tstruct intel_uncore *uncore = gt->uncore;\n\tu32 rcctl1, pw_status, mt_fwake_req;\n\n\tmt_fwake_req = intel_uncore_read_fw(uncore, FORCEWAKE_MT);\n\tpw_status = intel_uncore_read(uncore, VLV_GTLC_PW_STATUS);\n\trcctl1 = intel_uncore_read(uncore, GEN6_RC_CONTROL);\n\n\tseq_printf(m, \"RC6 Enabled: %s\\n\",\n\t\t   str_yes_no(rcctl1 & (GEN7_RC_CTL_TO_MODE |\n\t\t\t\t\tGEN6_RC_CTL_EI_MODE(1))));\n\tseq_printf(m, \"Multi-threaded Forcewake Request: 0x%x\\n\", mt_fwake_req);\n\tseq_printf(m, \"Render Power Well: %s\\n\",\n\t\t   (pw_status & VLV_GTLC_PW_RENDER_STATUS_MASK) ? \"Up\" : \"Down\");\n\tseq_printf(m, \"Media Power Well: %s\\n\",\n\t\t   (pw_status & VLV_GTLC_PW_MEDIA_STATUS_MASK) ? \"Up\" : \"Down\");\n\n\tintel_rc6_print_residency(m, \"Render RC6 residency since boot:\", INTEL_RC6_RES_RC6);\n\tintel_rc6_print_residency(m, \"Media RC6 residency since boot:\", INTEL_RC6_RES_VLV_MEDIA);\n\n\treturn fw_domains_show(m, NULL);\n}\n\nstatic int gen6_drpc(struct seq_file *m)\n{\n\tstruct intel_gt *gt = m->private;\n\tstruct drm_i915_private *i915 = gt->i915;\n\tstruct intel_uncore *uncore = gt->uncore;\n\tu32 gt_core_status, mt_fwake_req, rcctl1, rc6vids = 0;\n\tu32 gen9_powergate_enable = 0, gen9_powergate_status = 0;\n\n\tmt_fwake_req = intel_uncore_read_fw(uncore, FORCEWAKE_MT);\n\tgt_core_status = intel_uncore_read_fw(uncore, GEN6_GT_CORE_STATUS);\n\n\trcctl1 = intel_uncore_read(uncore, GEN6_RC_CONTROL);\n\tif (GRAPHICS_VER(i915) >= 9) {\n\t\tgen9_powergate_enable =\n\t\t\tintel_uncore_read(uncore, GEN9_PG_ENABLE);\n\t\tgen9_powergate_status =\n\t\t\tintel_uncore_read(uncore, GEN9_PWRGT_DOMAIN_STATUS);\n\t}\n\n\tif (GRAPHICS_VER(i915) <= 7)\n\t\tsnb_pcode_read(gt->uncore, GEN6_PCODE_READ_RC6VIDS, &rc6vids, NULL);\n\n\tseq_printf(m, \"RC1e Enabled: %s\\n\",\n\t\t   str_yes_no(rcctl1 & GEN6_RC_CTL_RC1e_ENABLE));\n\tseq_printf(m, \"RC6 Enabled: %s\\n\",\n\t\t   str_yes_no(rcctl1 & GEN6_RC_CTL_RC6_ENABLE));\n\tif (GRAPHICS_VER(i915) >= 9) {\n\t\tseq_printf(m, \"Render Well Gating Enabled: %s\\n\",\n\t\t\t   str_yes_no(gen9_powergate_enable & GEN9_RENDER_PG_ENABLE));\n\t\tseq_printf(m, \"Media Well Gating Enabled: %s\\n\",\n\t\t\t   str_yes_no(gen9_powergate_enable & GEN9_MEDIA_PG_ENABLE));\n\t}\n\tseq_printf(m, \"Deep RC6 Enabled: %s\\n\",\n\t\t   str_yes_no(rcctl1 & GEN6_RC_CTL_RC6p_ENABLE));\n\tseq_printf(m, \"Deepest RC6 Enabled: %s\\n\",\n\t\t   str_yes_no(rcctl1 & GEN6_RC_CTL_RC6pp_ENABLE));\n\tseq_puts(m, \"Current RC state: \");\n\tswitch (gt_core_status & GEN6_RCn_MASK) {\n\tcase GEN6_RC0:\n\t\tif (gt_core_status & GEN6_CORE_CPD_STATE_MASK)\n\t\t\tseq_puts(m, \"Core Power Down\\n\");\n\t\telse\n\t\t\tseq_puts(m, \"on\\n\");\n\t\tbreak;\n\tcase GEN6_RC3:\n\t\tseq_puts(m, \"RC3\\n\");\n\t\tbreak;\n\tcase GEN6_RC6:\n\t\tseq_puts(m, \"RC6\\n\");\n\t\tbreak;\n\tcase GEN6_RC7:\n\t\tseq_puts(m, \"RC7\\n\");\n\t\tbreak;\n\tdefault:\n\t\tseq_puts(m, \"Unknown\\n\");\n\t\tbreak;\n\t}\n\n\tseq_printf(m, \"Core Power Down: %s\\n\",\n\t\t   str_yes_no(gt_core_status & GEN6_CORE_CPD_STATE_MASK));\n\tseq_printf(m, \"Multi-threaded Forcewake Request: 0x%x\\n\", mt_fwake_req);\n\tif (GRAPHICS_VER(i915) >= 9) {\n\t\tseq_printf(m, \"Render Power Well: %s\\n\",\n\t\t\t   (gen9_powergate_status &\n\t\t\t    GEN9_PWRGT_RENDER_STATUS_MASK) ? \"Up\" : \"Down\");\n\t\tseq_printf(m, \"Media Power Well: %s\\n\",\n\t\t\t   (gen9_powergate_status &\n\t\t\t    GEN9_PWRGT_MEDIA_STATUS_MASK) ? \"Up\" : \"Down\");\n\t}\n\n\t \n\tintel_rc6_print_residency(m, \"RC6 \\\"Locked to RPn\\\" residency since boot:\",\n\t\t\t\t  INTEL_RC6_RES_RC6_LOCKED);\n\tintel_rc6_print_residency(m, \"RC6 residency since boot:\", INTEL_RC6_RES_RC6);\n\tintel_rc6_print_residency(m, \"RC6+ residency since boot:\", INTEL_RC6_RES_RC6p);\n\tintel_rc6_print_residency(m, \"RC6++ residency since boot:\", INTEL_RC6_RES_RC6pp);\n\n\tif (GRAPHICS_VER(i915) <= 7) {\n\t\tseq_printf(m, \"RC6   voltage: %dmV\\n\",\n\t\t\t   GEN6_DECODE_RC6_VID(((rc6vids >> 0) & 0xff)));\n\t\tseq_printf(m, \"RC6+  voltage: %dmV\\n\",\n\t\t\t   GEN6_DECODE_RC6_VID(((rc6vids >> 8) & 0xff)));\n\t\tseq_printf(m, \"RC6++ voltage: %dmV\\n\",\n\t\t\t   GEN6_DECODE_RC6_VID(((rc6vids >> 16) & 0xff)));\n\t}\n\n\treturn fw_domains_show(m, NULL);\n}\n\nstatic int ilk_drpc(struct seq_file *m)\n{\n\tstruct intel_gt *gt = m->private;\n\tstruct intel_uncore *uncore = gt->uncore;\n\tu32 rgvmodectl, rstdbyctl;\n\tu16 crstandvid;\n\n\trgvmodectl = intel_uncore_read(uncore, MEMMODECTL);\n\trstdbyctl = intel_uncore_read(uncore, RSTDBYCTL);\n\tcrstandvid = intel_uncore_read16(uncore, CRSTANDVID);\n\n\tseq_printf(m, \"HD boost: %s\\n\",\n\t\t   str_yes_no(rgvmodectl & MEMMODE_BOOST_EN));\n\tseq_printf(m, \"Boost freq: %d\\n\",\n\t\t   (rgvmodectl & MEMMODE_BOOST_FREQ_MASK) >>\n\t\t   MEMMODE_BOOST_FREQ_SHIFT);\n\tseq_printf(m, \"HW control enabled: %s\\n\",\n\t\t   str_yes_no(rgvmodectl & MEMMODE_HWIDLE_EN));\n\tseq_printf(m, \"SW control enabled: %s\\n\",\n\t\t   str_yes_no(rgvmodectl & MEMMODE_SWMODE_EN));\n\tseq_printf(m, \"Gated voltage change: %s\\n\",\n\t\t   str_yes_no(rgvmodectl & MEMMODE_RCLK_GATE));\n\tseq_printf(m, \"Starting frequency: P%d\\n\",\n\t\t   (rgvmodectl & MEMMODE_FSTART_MASK) >> MEMMODE_FSTART_SHIFT);\n\tseq_printf(m, \"Max P-state: P%d\\n\",\n\t\t   (rgvmodectl & MEMMODE_FMAX_MASK) >> MEMMODE_FMAX_SHIFT);\n\tseq_printf(m, \"Min P-state: P%d\\n\", (rgvmodectl & MEMMODE_FMIN_MASK));\n\tseq_printf(m, \"RS1 VID: %d\\n\", (crstandvid & 0x3f));\n\tseq_printf(m, \"RS2 VID: %d\\n\", ((crstandvid >> 8) & 0x3f));\n\tseq_printf(m, \"Render standby enabled: %s\\n\",\n\t\t   str_yes_no(!(rstdbyctl & RCX_SW_EXIT)));\n\tseq_puts(m, \"Current RS state: \");\n\tswitch (rstdbyctl & RSX_STATUS_MASK) {\n\tcase RSX_STATUS_ON:\n\t\tseq_puts(m, \"on\\n\");\n\t\tbreak;\n\tcase RSX_STATUS_RC1:\n\t\tseq_puts(m, \"RC1\\n\");\n\t\tbreak;\n\tcase RSX_STATUS_RC1E:\n\t\tseq_puts(m, \"RC1E\\n\");\n\t\tbreak;\n\tcase RSX_STATUS_RS1:\n\t\tseq_puts(m, \"RS1\\n\");\n\t\tbreak;\n\tcase RSX_STATUS_RS2:\n\t\tseq_puts(m, \"RS2 (RC6)\\n\");\n\t\tbreak;\n\tcase RSX_STATUS_RS3:\n\t\tseq_puts(m, \"RC3 (RC6+)\\n\");\n\t\tbreak;\n\tdefault:\n\t\tseq_puts(m, \"unknown\\n\");\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic int mtl_drpc(struct seq_file *m)\n{\n\tstruct intel_gt *gt = m->private;\n\tstruct intel_uncore *uncore = gt->uncore;\n\tu32 gt_core_status, rcctl1, mt_fwake_req;\n\tu32 mtl_powergate_enable = 0, mtl_powergate_status = 0;\n\n\tmt_fwake_req = intel_uncore_read_fw(uncore, FORCEWAKE_MT);\n\tgt_core_status = intel_uncore_read(uncore, MTL_MIRROR_TARGET_WP1);\n\n\trcctl1 = intel_uncore_read(uncore, GEN6_RC_CONTROL);\n\tmtl_powergate_enable = intel_uncore_read(uncore, GEN9_PG_ENABLE);\n\tmtl_powergate_status = intel_uncore_read(uncore,\n\t\t\t\t\t\t GEN9_PWRGT_DOMAIN_STATUS);\n\n\tseq_printf(m, \"RC6 Enabled: %s\\n\",\n\t\t   str_yes_no(rcctl1 & GEN6_RC_CTL_RC6_ENABLE));\n\tif (gt->type == GT_MEDIA) {\n\t\tseq_printf(m, \"Media Well Gating Enabled: %s\\n\",\n\t\t\t   str_yes_no(mtl_powergate_enable & GEN9_MEDIA_PG_ENABLE));\n\t} else {\n\t\tseq_printf(m, \"Render Well Gating Enabled: %s\\n\",\n\t\t\t   str_yes_no(mtl_powergate_enable & GEN9_RENDER_PG_ENABLE));\n\t}\n\n\tseq_puts(m, \"Current RC state: \");\n\tswitch (REG_FIELD_GET(MTL_CC_MASK, gt_core_status)) {\n\tcase MTL_CC0:\n\t\tseq_puts(m, \"RC0\\n\");\n\t\tbreak;\n\tcase MTL_CC6:\n\t\tseq_puts(m, \"RC6\\n\");\n\t\tbreak;\n\tdefault:\n\t\tMISSING_CASE(REG_FIELD_GET(MTL_CC_MASK, gt_core_status));\n\t\tseq_puts(m, \"Unknown\\n\");\n\t\tbreak;\n\t}\n\n\tseq_printf(m, \"Multi-threaded Forcewake Request: 0x%x\\n\", mt_fwake_req);\n\tif (gt->type == GT_MEDIA)\n\t\tseq_printf(m, \"Media Power Well: %s\\n\",\n\t\t\t   (mtl_powergate_status &\n\t\t\t    GEN9_PWRGT_MEDIA_STATUS_MASK) ? \"Up\" : \"Down\");\n\telse\n\t\tseq_printf(m, \"Render Power Well: %s\\n\",\n\t\t\t   (mtl_powergate_status &\n\t\t\t    GEN9_PWRGT_RENDER_STATUS_MASK) ? \"Up\" : \"Down\");\n\n\t \n\tintel_rc6_print_residency(m, \"RC6 residency since boot:\", INTEL_RC6_RES_RC6);\n\n\treturn fw_domains_show(m, NULL);\n}\n\nstatic int drpc_show(struct seq_file *m, void *unused)\n{\n\tstruct intel_gt *gt = m->private;\n\tstruct drm_i915_private *i915 = gt->i915;\n\tintel_wakeref_t wakeref;\n\tint err = -ENODEV;\n\n\twith_intel_runtime_pm(gt->uncore->rpm, wakeref) {\n\t\tif (GRAPHICS_VER_FULL(i915) >= IP_VER(12, 70))\n\t\t\terr = mtl_drpc(m);\n\t\telse if (IS_VALLEYVIEW(i915) || IS_CHERRYVIEW(i915))\n\t\t\terr = vlv_drpc(m);\n\t\telse if (GRAPHICS_VER(i915) >= 6)\n\t\t\terr = gen6_drpc(m);\n\t\telse\n\t\t\terr = ilk_drpc(m);\n\t}\n\n\treturn err;\n}\nDEFINE_INTEL_GT_DEBUGFS_ATTRIBUTE(drpc);\n\nvoid intel_gt_pm_frequency_dump(struct intel_gt *gt, struct drm_printer *p)\n{\n\tstruct drm_i915_private *i915 = gt->i915;\n\tstruct intel_uncore *uncore = gt->uncore;\n\tstruct intel_rps *rps = &gt->rps;\n\tintel_wakeref_t wakeref;\n\n\twakeref = intel_runtime_pm_get(uncore->rpm);\n\n\tif (GRAPHICS_VER(i915) == 5) {\n\t\tu16 rgvswctl = intel_uncore_read16(uncore, MEMSWCTL);\n\t\tu16 rgvstat = intel_uncore_read16(uncore, MEMSTAT_ILK);\n\n\t\tdrm_printf(p, \"Requested P-state: %d\\n\", (rgvswctl >> 8) & 0xf);\n\t\tdrm_printf(p, \"Requested VID: %d\\n\", rgvswctl & 0x3f);\n\t\tdrm_printf(p, \"Current VID: %d\\n\", (rgvstat & MEMSTAT_VID_MASK) >>\n\t\t\t   MEMSTAT_VID_SHIFT);\n\t\tdrm_printf(p, \"Current P-state: %d\\n\",\n\t\t\t   REG_FIELD_GET(MEMSTAT_PSTATE_MASK, rgvstat));\n\t} else if (IS_VALLEYVIEW(i915) || IS_CHERRYVIEW(i915)) {\n\t\tu32 rpmodectl, freq_sts;\n\n\t\trpmodectl = intel_uncore_read(uncore, GEN6_RP_CONTROL);\n\t\tdrm_printf(p, \"Video Turbo Mode: %s\\n\",\n\t\t\t   str_yes_no(rpmodectl & GEN6_RP_MEDIA_TURBO));\n\t\tdrm_printf(p, \"HW control enabled: %s\\n\",\n\t\t\t   str_yes_no(rpmodectl & GEN6_RP_ENABLE));\n\t\tdrm_printf(p, \"SW control enabled: %s\\n\",\n\t\t\t   str_yes_no((rpmodectl & GEN6_RP_MEDIA_MODE_MASK) == GEN6_RP_MEDIA_SW_MODE));\n\n\t\tvlv_punit_get(i915);\n\t\tfreq_sts = vlv_punit_read(i915, PUNIT_REG_GPU_FREQ_STS);\n\t\tvlv_punit_put(i915);\n\n\t\tdrm_printf(p, \"PUNIT_REG_GPU_FREQ_STS: 0x%08x\\n\", freq_sts);\n\t\tdrm_printf(p, \"DDR freq: %d MHz\\n\", i915->mem_freq);\n\n\t\tdrm_printf(p, \"actual GPU freq: %d MHz\\n\",\n\t\t\t   intel_gpu_freq(rps, (freq_sts >> 8) & 0xff));\n\n\t\tdrm_printf(p, \"current GPU freq: %d MHz\\n\",\n\t\t\t   intel_gpu_freq(rps, rps->cur_freq));\n\n\t\tdrm_printf(p, \"max GPU freq: %d MHz\\n\",\n\t\t\t   intel_gpu_freq(rps, rps->max_freq));\n\n\t\tdrm_printf(p, \"min GPU freq: %d MHz\\n\",\n\t\t\t   intel_gpu_freq(rps, rps->min_freq));\n\n\t\tdrm_printf(p, \"idle GPU freq: %d MHz\\n\",\n\t\t\t   intel_gpu_freq(rps, rps->idle_freq));\n\n\t\tdrm_printf(p, \"efficient (RPe) frequency: %d MHz\\n\",\n\t\t\t   intel_gpu_freq(rps, rps->efficient_freq));\n\t} else if (GRAPHICS_VER(i915) >= 6) {\n\t\tgen6_rps_frequency_dump(rps, p);\n\t} else {\n\t\tdrm_puts(p, \"no P-state info available\\n\");\n\t}\n\n\tdrm_printf(p, \"Current CD clock frequency: %d kHz\\n\", i915->display.cdclk.hw.cdclk);\n\tdrm_printf(p, \"Max CD clock frequency: %d kHz\\n\", i915->display.cdclk.max_cdclk_freq);\n\tdrm_printf(p, \"Max pixel clock frequency: %d kHz\\n\", i915->max_dotclk_freq);\n\n\tintel_runtime_pm_put(uncore->rpm, wakeref);\n}\n\nstatic int frequency_show(struct seq_file *m, void *unused)\n{\n\tstruct intel_gt *gt = m->private;\n\tstruct drm_printer p = drm_seq_file_printer(m);\n\n\tintel_gt_pm_frequency_dump(gt, &p);\n\n\treturn 0;\n}\nDEFINE_INTEL_GT_DEBUGFS_ATTRIBUTE(frequency);\n\nstatic int llc_show(struct seq_file *m, void *data)\n{\n\tstruct intel_gt *gt = m->private;\n\tstruct drm_i915_private *i915 = gt->i915;\n\tconst bool edram = GRAPHICS_VER(i915) > 8;\n\tstruct intel_rps *rps = &gt->rps;\n\tunsigned int max_gpu_freq, min_gpu_freq;\n\tintel_wakeref_t wakeref;\n\tint gpu_freq, ia_freq;\n\n\tseq_printf(m, \"LLC: %s\\n\", str_yes_no(HAS_LLC(i915)));\n\tseq_printf(m, \"%s: %uMB\\n\", edram ? \"eDRAM\" : \"eLLC\",\n\t\t   i915->edram_size_mb);\n\n\tmin_gpu_freq = rps->min_freq;\n\tmax_gpu_freq = rps->max_freq;\n\tif (IS_GEN9_BC(i915) || GRAPHICS_VER(i915) >= 11) {\n\t\t \n\t\tmin_gpu_freq /= GEN9_FREQ_SCALER;\n\t\tmax_gpu_freq /= GEN9_FREQ_SCALER;\n\t}\n\n\tseq_puts(m, \"GPU freq (MHz)\\tEffective CPU freq (MHz)\\tEffective Ring freq (MHz)\\n\");\n\n\twakeref = intel_runtime_pm_get(gt->uncore->rpm);\n\tfor (gpu_freq = min_gpu_freq; gpu_freq <= max_gpu_freq; gpu_freq++) {\n\t\tia_freq = gpu_freq;\n\t\tsnb_pcode_read(gt->uncore, GEN6_PCODE_READ_MIN_FREQ_TABLE,\n\t\t\t       &ia_freq, NULL);\n\t\tseq_printf(m, \"%d\\t\\t%d\\t\\t\\t\\t%d\\n\",\n\t\t\t   intel_gpu_freq(rps,\n\t\t\t\t\t  (gpu_freq *\n\t\t\t\t\t   (IS_GEN9_BC(i915) ||\n\t\t\t\t\t    GRAPHICS_VER(i915) >= 11 ?\n\t\t\t\t\t    GEN9_FREQ_SCALER : 1))),\n\t\t\t   ((ia_freq >> 0) & 0xff) * 100,\n\t\t\t   ((ia_freq >> 8) & 0xff) * 100);\n\t}\n\tintel_runtime_pm_put(gt->uncore->rpm, wakeref);\n\n\treturn 0;\n}\n\nstatic bool llc_eval(void *data)\n{\n\tstruct intel_gt *gt = data;\n\n\treturn HAS_LLC(gt->i915);\n}\n\nDEFINE_INTEL_GT_DEBUGFS_ATTRIBUTE(llc);\n\nstatic const char *rps_power_to_str(unsigned int power)\n{\n\tstatic const char * const strings[] = {\n\t\t[LOW_POWER] = \"low power\",\n\t\t[BETWEEN] = \"mixed\",\n\t\t[HIGH_POWER] = \"high power\",\n\t};\n\n\tif (power >= ARRAY_SIZE(strings) || !strings[power])\n\t\treturn \"unknown\";\n\n\treturn strings[power];\n}\n\nstatic int rps_boost_show(struct seq_file *m, void *data)\n{\n\tstruct intel_gt *gt = m->private;\n\tstruct drm_i915_private *i915 = gt->i915;\n\tstruct intel_rps *rps = &gt->rps;\n\n\tseq_printf(m, \"RPS enabled? %s\\n\",\n\t\t   str_yes_no(intel_rps_is_enabled(rps)));\n\tseq_printf(m, \"RPS active? %s\\n\",\n\t\t   str_yes_no(intel_rps_is_active(rps)));\n\tseq_printf(m, \"GPU busy? %s, %llums\\n\",\n\t\t   str_yes_no(gt->awake),\n\t\t   ktime_to_ms(intel_gt_get_awake_time(gt)));\n\tseq_printf(m, \"Boosts outstanding? %d\\n\",\n\t\t   atomic_read(&rps->num_waiters));\n\tseq_printf(m, \"Interactive? %d\\n\", READ_ONCE(rps->power.interactive));\n\tseq_printf(m, \"Frequency requested %d, actual %d\\n\",\n\t\t   intel_gpu_freq(rps, rps->cur_freq),\n\t\t   intel_rps_read_actual_frequency(rps));\n\tseq_printf(m, \"  min hard:%d, soft:%d; max soft:%d, hard:%d\\n\",\n\t\t   intel_gpu_freq(rps, rps->min_freq),\n\t\t   intel_gpu_freq(rps, rps->min_freq_softlimit),\n\t\t   intel_gpu_freq(rps, rps->max_freq_softlimit),\n\t\t   intel_gpu_freq(rps, rps->max_freq));\n\tseq_printf(m, \"  idle:%d, efficient:%d, boost:%d\\n\",\n\t\t   intel_gpu_freq(rps, rps->idle_freq),\n\t\t   intel_gpu_freq(rps, rps->efficient_freq),\n\t\t   intel_gpu_freq(rps, rps->boost_freq));\n\n\tseq_printf(m, \"Wait boosts: %d\\n\", READ_ONCE(rps->boosts));\n\n\tif (GRAPHICS_VER(i915) >= 6 && intel_rps_is_active(rps)) {\n\t\tstruct intel_uncore *uncore = gt->uncore;\n\t\tu32 rpup, rpupei;\n\t\tu32 rpdown, rpdownei;\n\n\t\tintel_uncore_forcewake_get(uncore, FORCEWAKE_ALL);\n\t\trpup = intel_uncore_read_fw(uncore, GEN6_RP_CUR_UP) & GEN6_RP_EI_MASK;\n\t\trpupei = intel_uncore_read_fw(uncore, GEN6_RP_CUR_UP_EI) & GEN6_RP_EI_MASK;\n\t\trpdown = intel_uncore_read_fw(uncore, GEN6_RP_CUR_DOWN) & GEN6_RP_EI_MASK;\n\t\trpdownei = intel_uncore_read_fw(uncore, GEN6_RP_CUR_DOWN_EI) & GEN6_RP_EI_MASK;\n\t\tintel_uncore_forcewake_put(uncore, FORCEWAKE_ALL);\n\n\t\tseq_printf(m, \"\\nRPS Autotuning (current \\\"%s\\\" window):\\n\",\n\t\t\t   rps_power_to_str(rps->power.mode));\n\t\tseq_printf(m, \"  Avg. up: %d%% [above threshold? %d%%]\\n\",\n\t\t\t   rpup && rpupei ? 100 * rpup / rpupei : 0,\n\t\t\t   rps->power.up_threshold);\n\t\tseq_printf(m, \"  Avg. down: %d%% [below threshold? %d%%]\\n\",\n\t\t\t   rpdown && rpdownei ? 100 * rpdown / rpdownei : 0,\n\t\t\t   rps->power.down_threshold);\n\t} else {\n\t\tseq_puts(m, \"\\nRPS Autotuning inactive\\n\");\n\t}\n\n\treturn 0;\n}\n\nstatic bool rps_eval(void *data)\n{\n\tstruct intel_gt *gt = data;\n\n\tif (intel_guc_slpc_is_used(&gt->uc.guc))\n\t\treturn false;\n\telse\n\t\treturn HAS_RPS(gt->i915);\n}\n\nDEFINE_INTEL_GT_DEBUGFS_ATTRIBUTE(rps_boost);\n\nstatic int perf_limit_reasons_get(void *data, u64 *val)\n{\n\tstruct intel_gt *gt = data;\n\tintel_wakeref_t wakeref;\n\n\twith_intel_runtime_pm(gt->uncore->rpm, wakeref)\n\t\t*val = intel_uncore_read(gt->uncore, intel_gt_perf_limit_reasons_reg(gt));\n\n\treturn 0;\n}\n\nstatic int perf_limit_reasons_clear(void *data, u64 val)\n{\n\tstruct intel_gt *gt = data;\n\tintel_wakeref_t wakeref;\n\n\t \n\twith_intel_runtime_pm(gt->uncore->rpm, wakeref)\n\t\tintel_uncore_rmw(gt->uncore, intel_gt_perf_limit_reasons_reg(gt),\n\t\t\t\t GT0_PERF_LIMIT_REASONS_LOG_MASK, 0);\n\n\treturn 0;\n}\n\nstatic bool perf_limit_reasons_eval(void *data)\n{\n\tstruct intel_gt *gt = data;\n\n\treturn i915_mmio_reg_valid(intel_gt_perf_limit_reasons_reg(gt));\n}\n\nDEFINE_SIMPLE_ATTRIBUTE(perf_limit_reasons_fops, perf_limit_reasons_get,\n\t\t\tperf_limit_reasons_clear, \"0x%llx\\n\");\n\nvoid intel_gt_pm_debugfs_register(struct intel_gt *gt, struct dentry *root)\n{\n\tstatic const struct intel_gt_debugfs_file files[] = {\n\t\t{ \"drpc\", &drpc_fops, NULL },\n\t\t{ \"frequency\", &frequency_fops, NULL },\n\t\t{ \"forcewake\", &fw_domains_fops, NULL },\n\t\t{ \"forcewake_user\", &forcewake_user_fops, NULL},\n\t\t{ \"llc\", &llc_fops, llc_eval },\n\t\t{ \"rps_boost\", &rps_boost_fops, rps_eval },\n\t\t{ \"perf_limit_reasons\", &perf_limit_reasons_fops, perf_limit_reasons_eval },\n\t};\n\n\tintel_gt_debugfs_register_files(root, files, ARRAY_SIZE(files), gt);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}