{
  "module_name": "selftest_guc_multi_lrc.c",
  "hash_id": "2915fb781ee01a8e75174371e8c2e754fdf7988b0ef3bec3b41946236f42ee29",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/i915/gt/uc/selftest_guc_multi_lrc.c",
  "human_readable_source": "\n \n\n#include \"gt/intel_gt_print.h\"\n#include \"selftests/igt_spinner.h\"\n#include \"selftests/igt_reset.h\"\n#include \"selftests/intel_scheduler_helpers.h\"\n#include \"gt/intel_engine_heartbeat.h\"\n#include \"gem/selftests/mock_context.h\"\n\nstatic void logical_sort(struct intel_engine_cs **engines, int num_engines)\n{\n\tstruct intel_engine_cs *sorted[MAX_ENGINE_INSTANCE + 1];\n\tint i, j;\n\n\tfor (i = 0; i < num_engines; ++i)\n\t\tfor (j = 0; j < MAX_ENGINE_INSTANCE + 1; ++j) {\n\t\t\tif (engines[j]->logical_mask & BIT(i)) {\n\t\t\t\tsorted[i] = engines[j];\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\tmemcpy(*engines, *sorted,\n\t       sizeof(struct intel_engine_cs *) * num_engines);\n}\n\nstatic struct intel_context *\nmulti_lrc_create_parent(struct intel_gt *gt, u8 class,\n\t\t\tunsigned long flags)\n{\n\tstruct intel_engine_cs *siblings[MAX_ENGINE_INSTANCE + 1];\n\tstruct intel_engine_cs *engine;\n\tenum intel_engine_id id;\n\tint i = 0;\n\n\tfor_each_engine(engine, gt, id) {\n\t\tif (engine->class != class)\n\t\t\tcontinue;\n\n\t\tsiblings[i++] = engine;\n\t}\n\n\tif (i <= 1)\n\t\treturn ERR_PTR(0);\n\n\tlogical_sort(siblings, i);\n\n\treturn intel_engine_create_parallel(siblings, 1, i);\n}\n\nstatic void multi_lrc_context_unpin(struct intel_context *ce)\n{\n\tstruct intel_context *child;\n\n\tGEM_BUG_ON(!intel_context_is_parent(ce));\n\n\tfor_each_child(ce, child)\n\t\tintel_context_unpin(child);\n\tintel_context_unpin(ce);\n}\n\nstatic void multi_lrc_context_put(struct intel_context *ce)\n{\n\tGEM_BUG_ON(!intel_context_is_parent(ce));\n\n\t \n\tintel_context_put(ce);\n}\n\nstatic struct i915_request *\nmulti_lrc_nop_request(struct intel_context *ce)\n{\n\tstruct intel_context *child;\n\tstruct i915_request *rq, *child_rq;\n\tint i = 0;\n\n\tGEM_BUG_ON(!intel_context_is_parent(ce));\n\n\trq = intel_context_create_request(ce);\n\tif (IS_ERR(rq))\n\t\treturn rq;\n\n\ti915_request_get(rq);\n\ti915_request_add(rq);\n\n\tfor_each_child(ce, child) {\n\t\tchild_rq = intel_context_create_request(child);\n\t\tif (IS_ERR(child_rq))\n\t\t\tgoto child_error;\n\n\t\tif (++i == ce->parallel.number_children)\n\t\t\tset_bit(I915_FENCE_FLAG_SUBMIT_PARALLEL,\n\t\t\t\t&child_rq->fence.flags);\n\t\ti915_request_add(child_rq);\n\t}\n\n\treturn rq;\n\nchild_error:\n\ti915_request_put(rq);\n\n\treturn ERR_PTR(-ENOMEM);\n}\n\nstatic int __intel_guc_multi_lrc_basic(struct intel_gt *gt, unsigned int class)\n{\n\tstruct intel_context *parent;\n\tstruct i915_request *rq;\n\tint ret;\n\n\tparent = multi_lrc_create_parent(gt, class, 0);\n\tif (IS_ERR(parent)) {\n\t\tgt_err(gt, \"Failed creating contexts: %pe\\n\", parent);\n\t\treturn PTR_ERR(parent);\n\t} else if (!parent) {\n\t\tgt_dbg(gt, \"Not enough engines in class: %d\\n\", class);\n\t\treturn 0;\n\t}\n\n\trq = multi_lrc_nop_request(parent);\n\tif (IS_ERR(rq)) {\n\t\tret = PTR_ERR(rq);\n\t\tgt_err(gt, \"Failed creating requests: %pe\\n\", rq);\n\t\tgoto out;\n\t}\n\n\tret = intel_selftest_wait_for_rq(rq);\n\tif (ret)\n\t\tgt_err(gt, \"Failed waiting on request: %pe\\n\", ERR_PTR(ret));\n\n\ti915_request_put(rq);\n\n\tif (ret >= 0) {\n\t\tret = intel_gt_wait_for_idle(gt, HZ * 5);\n\t\tif (ret < 0)\n\t\t\tgt_err(gt, \"GT failed to idle: %pe\\n\", ERR_PTR(ret));\n\t}\n\nout:\n\tmulti_lrc_context_unpin(parent);\n\tmulti_lrc_context_put(parent);\n\treturn ret;\n}\n\nstatic int intel_guc_multi_lrc_basic(void *arg)\n{\n\tstruct intel_gt *gt = arg;\n\tunsigned int class;\n\tint ret;\n\n\tfor (class = 0; class < MAX_ENGINE_CLASS + 1; ++class) {\n\t\t \n\t\tif (class == COMPUTE_CLASS || class == RENDER_CLASS)\n\t\t\tcontinue;\n\n\t\tret = __intel_guc_multi_lrc_basic(gt, class);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nint intel_guc_multi_lrc_live_selftests(struct drm_i915_private *i915)\n{\n\tstatic const struct i915_subtest tests[] = {\n\t\tSUBTEST(intel_guc_multi_lrc_basic),\n\t};\n\tstruct intel_gt *gt = to_gt(i915);\n\n\tif (intel_gt_is_wedged(gt))\n\t\treturn 0;\n\n\tif (!intel_uc_uses_guc_submission(&gt->uc))\n\t\treturn 0;\n\n\treturn intel_gt_live_subtests(tests, gt);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}