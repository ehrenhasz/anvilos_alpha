{
  "module_name": "selftest_guc.c",
  "hash_id": "1fc26a549ba3cd24c4c941774c43f5672eea125f94ec248b46c1736b613e4b49",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/i915/gt/uc/selftest_guc.c",
  "human_readable_source": "\n \n\n#include \"gt/intel_gt_print.h\"\n#include \"intel_guc_print.h\"\n#include \"selftests/igt_spinner.h\"\n#include \"selftests/intel_scheduler_helpers.h\"\n\nstatic int request_add_spin(struct i915_request *rq, struct igt_spinner *spin)\n{\n\tint err = 0;\n\n\ti915_request_get(rq);\n\ti915_request_add(rq);\n\tif (spin && !igt_wait_for_spinner(spin, rq))\n\t\terr = -ETIMEDOUT;\n\n\treturn err;\n}\n\nstatic struct i915_request *nop_user_request(struct intel_context *ce,\n\t\t\t\t\t     struct i915_request *from)\n{\n\tstruct i915_request *rq;\n\tint ret;\n\n\trq = intel_context_create_request(ce);\n\tif (IS_ERR(rq))\n\t\treturn rq;\n\n\tif (from) {\n\t\tret = i915_sw_fence_await_dma_fence(&rq->submit,\n\t\t\t\t\t\t    &from->fence, 0,\n\t\t\t\t\t\t    I915_FENCE_GFP);\n\t\tif (ret < 0) {\n\t\t\ti915_request_put(rq);\n\t\t\treturn ERR_PTR(ret);\n\t\t}\n\t}\n\n\ti915_request_get(rq);\n\ti915_request_add(rq);\n\n\treturn rq;\n}\n\nstatic int intel_guc_scrub_ctbs(void *arg)\n{\n\tstruct intel_gt *gt = arg;\n\tint ret = 0;\n\tint i;\n\tstruct i915_request *last[3] = {NULL, NULL, NULL}, *rq;\n\tintel_wakeref_t wakeref;\n\tstruct intel_engine_cs *engine;\n\tstruct intel_context *ce;\n\n\tif (!intel_has_gpu_reset(gt))\n\t\treturn 0;\n\n\twakeref = intel_runtime_pm_get(gt->uncore->rpm);\n\tengine = intel_selftest_find_any_engine(gt);\n\n\t \n\tfor (i = 0; i < 3; ++i) {\n\t\tce = intel_context_create(engine);\n\t\tif (IS_ERR(ce)) {\n\t\t\tret = PTR_ERR(ce);\n\t\t\tgt_err(gt, \"Failed to create context %d: %pe\\n\", i, ce);\n\t\t\tgoto err;\n\t\t}\n\n\t\tswitch (i) {\n\t\tcase 0:\n\t\t\tce->drop_schedule_enable = true;\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tce->drop_schedule_disable = true;\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tce->drop_deregister = true;\n\t\t\tbreak;\n\t\t}\n\n\t\trq = nop_user_request(ce, NULL);\n\t\tintel_context_put(ce);\n\n\t\tif (IS_ERR(rq)) {\n\t\t\tret = PTR_ERR(rq);\n\t\t\tgt_err(gt, \"Failed to create request %d: %pe\\n\", i, rq);\n\t\t\tgoto err;\n\t\t}\n\n\t\tlast[i] = rq;\n\t}\n\n\tfor (i = 0; i < 3; ++i) {\n\t\tret = i915_request_wait(last[i], 0, HZ);\n\t\tif (ret < 0) {\n\t\t\tgt_err(gt, \"Last request failed to complete: %pe\\n\", ERR_PTR(ret));\n\t\t\tgoto err;\n\t\t}\n\t\ti915_request_put(last[i]);\n\t\tlast[i] = NULL;\n\t}\n\n\t \n\tintel_gt_retire_requests(gt);\n\tmsleep(500);\n\n\t \n\tintel_gt_handle_error(engine->gt, -1, 0, \"selftest reset\");\n\n\t \n\tret = intel_gt_wait_for_idle(gt, HZ);\n\tif (ret < 0) {\n\t\tgt_err(gt, \"GT failed to idle: %pe\\n\", ERR_PTR(ret));\n\t\tgoto err;\n\t}\n\nerr:\n\tfor (i = 0; i < 3; ++i)\n\t\tif (last[i])\n\t\t\ti915_request_put(last[i]);\n\tintel_runtime_pm_put(gt->uncore->rpm, wakeref);\n\n\treturn ret;\n}\n\n \nstatic int intel_guc_steal_guc_ids(void *arg)\n{\n\tstruct intel_gt *gt = arg;\n\tstruct intel_guc *guc = &gt->uc.guc;\n\tint ret, sv, context_index = 0;\n\tintel_wakeref_t wakeref;\n\tstruct intel_engine_cs *engine;\n\tstruct intel_context **ce;\n\tstruct igt_spinner spin;\n\tstruct i915_request *spin_rq = NULL, *rq, *last = NULL;\n\tint number_guc_id_stolen = guc->number_guc_id_stolen;\n\n\tce = kcalloc(GUC_MAX_CONTEXT_ID, sizeof(*ce), GFP_KERNEL);\n\tif (!ce) {\n\t\tguc_err(guc, \"Context array allocation failed\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\twakeref = intel_runtime_pm_get(gt->uncore->rpm);\n\tengine = intel_selftest_find_any_engine(gt);\n\tsv = guc->submission_state.num_guc_ids;\n\tguc->submission_state.num_guc_ids = 512;\n\n\t \n\tce[context_index] = intel_context_create(engine);\n\tif (IS_ERR(ce[context_index])) {\n\t\tret = PTR_ERR(ce[context_index]);\n\t\tguc_err(guc, \"Failed to create context: %pe\\n\", ce[context_index]);\n\t\tce[context_index] = NULL;\n\t\tgoto err_wakeref;\n\t}\n\tret = igt_spinner_init(&spin, engine->gt);\n\tif (ret) {\n\t\tguc_err(guc, \"Failed to create spinner: %pe\\n\", ERR_PTR(ret));\n\t\tgoto err_contexts;\n\t}\n\tspin_rq = igt_spinner_create_request(&spin, ce[context_index],\n\t\t\t\t\t     MI_ARB_CHECK);\n\tif (IS_ERR(spin_rq)) {\n\t\tret = PTR_ERR(spin_rq);\n\t\tguc_err(guc, \"Failed to create spinner request: %pe\\n\", spin_rq);\n\t\tgoto err_contexts;\n\t}\n\tret = request_add_spin(spin_rq, &spin);\n\tif (ret) {\n\t\tguc_err(guc, \"Failed to add Spinner request: %pe\\n\", ERR_PTR(ret));\n\t\tgoto err_spin_rq;\n\t}\n\n\t \n\twhile (ret != -EAGAIN) {\n\t\tce[++context_index] = intel_context_create(engine);\n\t\tif (IS_ERR(ce[context_index])) {\n\t\t\tret = PTR_ERR(ce[context_index]);\n\t\t\tguc_err(guc, \"Failed to create context: %pe\\n\", ce[context_index]);\n\t\t\tce[context_index--] = NULL;\n\t\t\tgoto err_spin_rq;\n\t\t}\n\n\t\trq = nop_user_request(ce[context_index], spin_rq);\n\t\tif (IS_ERR(rq)) {\n\t\t\tret = PTR_ERR(rq);\n\t\t\trq = NULL;\n\t\t\tif ((ret != -EAGAIN) || !last) {\n\t\t\t\tguc_err(guc, \"Failed to create %srequest %d: %pe\\n\",\n\t\t\t\t\tlast ? \"\" : \"first \", context_index, ERR_PTR(ret));\n\t\t\t\tgoto err_spin_rq;\n\t\t\t}\n\t\t} else {\n\t\t\tif (last)\n\t\t\t\ti915_request_put(last);\n\t\t\tlast = rq;\n\t\t}\n\t}\n\n\t \n\tigt_spinner_end(&spin);\n\tret = intel_selftest_wait_for_rq(spin_rq);\n\tif (ret) {\n\t\tguc_err(guc, \"Spin request failed to complete: %pe\\n\", ERR_PTR(ret));\n\t\ti915_request_put(last);\n\t\tgoto err_spin_rq;\n\t}\n\ti915_request_put(spin_rq);\n\tigt_spinner_fini(&spin);\n\tspin_rq = NULL;\n\n\t \n\tret = i915_request_wait(last, 0, HZ * 30);\n\ti915_request_put(last);\n\tif (ret < 0) {\n\t\tguc_err(guc, \"Last request failed to complete: %pe\\n\", ERR_PTR(ret));\n\t\tgoto err_spin_rq;\n\t}\n\n\t \n\trq = nop_user_request(ce[context_index], NULL);\n\tif (IS_ERR(rq)) {\n\t\tret = PTR_ERR(rq);\n\t\tguc_err(guc, \"Failed to steal guc_id %d: %pe\\n\", context_index, rq);\n\t\tgoto err_spin_rq;\n\t}\n\n\t \n\tret = i915_request_wait(rq, 0, HZ);\n\ti915_request_put(rq);\n\tif (ret < 0) {\n\t\tguc_err(guc, \"Request with stolen guc_id failed to complete: %pe\\n\", ERR_PTR(ret));\n\t\tgoto err_spin_rq;\n\t}\n\n\t \n\tret = intel_gt_wait_for_idle(gt, HZ * 30);\n\tif (ret < 0) {\n\t\tguc_err(guc, \"GT failed to idle: %pe\\n\", ERR_PTR(ret));\n\t\tgoto err_spin_rq;\n\t}\n\n\t \n\tif (guc->number_guc_id_stolen == number_guc_id_stolen) {\n\t\tguc_err(guc, \"No guc_id was stolen\");\n\t\tret = -EINVAL;\n\t} else {\n\t\tret = 0;\n\t}\n\nerr_spin_rq:\n\tif (spin_rq) {\n\t\tigt_spinner_end(&spin);\n\t\tintel_selftest_wait_for_rq(spin_rq);\n\t\ti915_request_put(spin_rq);\n\t\tigt_spinner_fini(&spin);\n\t\tintel_gt_wait_for_idle(gt, HZ * 30);\n\t}\nerr_contexts:\n\tfor (; context_index >= 0 && ce[context_index]; --context_index)\n\t\tintel_context_put(ce[context_index]);\nerr_wakeref:\n\tintel_runtime_pm_put(gt->uncore->rpm, wakeref);\n\tkfree(ce);\n\tguc->submission_state.num_guc_ids = sv;\n\n\treturn ret;\n}\n\nint intel_guc_live_selftests(struct drm_i915_private *i915)\n{\n\tstatic const struct i915_subtest tests[] = {\n\t\tSUBTEST(intel_guc_scrub_ctbs),\n\t\tSUBTEST(intel_guc_steal_guc_ids),\n\t};\n\tstruct intel_gt *gt = to_gt(i915);\n\n\tif (intel_gt_is_wedged(gt))\n\t\treturn 0;\n\n\tif (!intel_uc_uses_guc_submission(&gt->uc))\n\t\treturn 0;\n\n\treturn intel_gt_live_subtests(tests, gt);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}