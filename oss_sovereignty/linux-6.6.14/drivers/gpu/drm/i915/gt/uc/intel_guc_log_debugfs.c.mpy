{
  "module_name": "intel_guc_log_debugfs.c",
  "hash_id": "3b22dc528d3e62cdf06fc41569e59e35b1d200ab98a5d8354b1f6c98bc24d451",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/i915/gt/uc/intel_guc_log_debugfs.c",
  "human_readable_source": "\n \n\n#include <linux/fs.h>\n#include <drm/drm_print.h>\n\n#include \"gt/intel_gt_debugfs.h\"\n#include \"intel_guc.h\"\n#include \"intel_guc_log.h\"\n#include \"intel_guc_log_debugfs.h\"\n#include \"intel_uc.h\"\n\nstatic u32 obj_to_guc_log_dump_size(struct drm_i915_gem_object *obj)\n{\n\tu32 size;\n\n\tif (!obj)\n\t\treturn PAGE_SIZE;\n\n\t \n\tsize = ((obj->base.size * 11) + 3) / 4;\n\n\t \n\tsize = PAGE_ALIGN(size + PAGE_SIZE);\n\n\treturn size;\n}\n\nstatic u32 guc_log_dump_size(struct intel_guc_log *log)\n{\n\tstruct intel_guc *guc = log_to_guc(log);\n\n\tif (!intel_guc_is_supported(guc))\n\t\treturn PAGE_SIZE;\n\n\tif (!log->vma)\n\t\treturn PAGE_SIZE;\n\n\treturn obj_to_guc_log_dump_size(log->vma->obj);\n}\n\nstatic int guc_log_dump_show(struct seq_file *m, void *data)\n{\n\tstruct drm_printer p = drm_seq_file_printer(m);\n\tint ret;\n\n\tret = intel_guc_log_dump(m->private, &p, false);\n\n\tif (IS_ENABLED(CONFIG_DRM_I915_DEBUG_GEM) && seq_has_overflowed(m))\n\t\tpr_warn_once(\"preallocated size:%zx for %s exceeded\\n\",\n\t\t\t     m->size, __func__);\n\n\treturn ret;\n}\nDEFINE_INTEL_GT_DEBUGFS_ATTRIBUTE_WITH_SIZE(guc_log_dump, guc_log_dump_size);\n\nstatic u32 guc_load_err_dump_size(struct intel_guc_log *log)\n{\n\tstruct intel_guc *guc = log_to_guc(log);\n\tstruct intel_uc *uc = container_of(guc, struct intel_uc, guc);\n\n\tif (!intel_guc_is_supported(guc))\n\t\treturn PAGE_SIZE;\n\n\treturn obj_to_guc_log_dump_size(uc->load_err_log);\n}\n\nstatic int guc_load_err_log_dump_show(struct seq_file *m, void *data)\n{\n\tstruct drm_printer p = drm_seq_file_printer(m);\n\n\tif (IS_ENABLED(CONFIG_DRM_I915_DEBUG_GEM) && seq_has_overflowed(m))\n\t\tpr_warn_once(\"preallocated size:%zx for %s exceeded\\n\",\n\t\t\t     m->size, __func__);\n\n\treturn intel_guc_log_dump(m->private, &p, true);\n}\nDEFINE_INTEL_GT_DEBUGFS_ATTRIBUTE_WITH_SIZE(guc_load_err_log_dump, guc_load_err_dump_size);\n\nstatic int guc_log_level_get(void *data, u64 *val)\n{\n\tstruct intel_guc_log *log = data;\n\n\tif (!log->vma)\n\t\treturn -ENODEV;\n\n\t*val = intel_guc_log_get_level(log);\n\n\treturn 0;\n}\n\nstatic int guc_log_level_set(void *data, u64 val)\n{\n\tstruct intel_guc_log *log = data;\n\n\tif (!log->vma)\n\t\treturn -ENODEV;\n\n\treturn intel_guc_log_set_level(log, val);\n}\n\nDEFINE_SIMPLE_ATTRIBUTE(guc_log_level_fops,\n\t\t\tguc_log_level_get, guc_log_level_set,\n\t\t\t\"%lld\\n\");\n\nstatic int guc_log_relay_open(struct inode *inode, struct file *file)\n{\n\tstruct intel_guc_log *log = inode->i_private;\n\n\tif (!intel_guc_is_ready(log_to_guc(log)))\n\t\treturn -ENODEV;\n\n\tfile->private_data = log;\n\n\treturn intel_guc_log_relay_open(log);\n}\n\nstatic ssize_t\nguc_log_relay_write(struct file *filp,\n\t\t    const char __user *ubuf,\n\t\t    size_t cnt,\n\t\t    loff_t *ppos)\n{\n\tstruct intel_guc_log *log = filp->private_data;\n\tint val;\n\tint ret;\n\n\tret = kstrtoint_from_user(ubuf, cnt, 0, &val);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tif (val == 1)\n\t\tret = intel_guc_log_relay_start(log);\n\telse\n\t\tintel_guc_log_relay_flush(log);\n\n\treturn ret ?: cnt;\n}\n\nstatic int guc_log_relay_release(struct inode *inode, struct file *file)\n{\n\tstruct intel_guc_log *log = inode->i_private;\n\n\tintel_guc_log_relay_close(log);\n\treturn 0;\n}\n\nstatic const struct file_operations guc_log_relay_fops = {\n\t.owner = THIS_MODULE,\n\t.open = guc_log_relay_open,\n\t.write = guc_log_relay_write,\n\t.release = guc_log_relay_release,\n};\n\nvoid intel_guc_log_debugfs_register(struct intel_guc_log *log,\n\t\t\t\t    struct dentry *root)\n{\n\tstatic const struct intel_gt_debugfs_file files[] = {\n\t\t{ \"guc_log_dump\", &guc_log_dump_fops, NULL },\n\t\t{ \"guc_load_err_log_dump\", &guc_load_err_log_dump_fops, NULL },\n\t\t{ \"guc_log_level\", &guc_log_level_fops, NULL },\n\t\t{ \"guc_log_relay\", &guc_log_relay_fops, NULL },\n\t};\n\n\tif (!intel_guc_is_supported(log_to_guc(log)))\n\t\treturn;\n\n\tintel_gt_debugfs_register_files(root, files, ARRAY_SIZE(files), log);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}