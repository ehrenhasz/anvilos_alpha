{
  "module_name": "intel_uc_fw.c",
  "hash_id": "d62b0d6b3c3b487985628522987f868b50cc65efcf99c1beb42b761ccb24f48c",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/i915/gt/uc/intel_uc_fw.c",
  "human_readable_source": "\n \n\n#include <linux/bitfield.h>\n#include <linux/firmware.h>\n#include <linux/highmem.h>\n\n#include <drm/drm_cache.h>\n#include <drm/drm_print.h>\n\n#include \"gem/i915_gem_lmem.h\"\n#include \"gt/intel_gt.h\"\n#include \"gt/intel_gt_print.h\"\n#include \"intel_gsc_binary_headers.h\"\n#include \"intel_gsc_fw.h\"\n#include \"intel_uc_fw.h\"\n#include \"intel_uc_fw_abi.h\"\n#include \"i915_drv.h\"\n#include \"i915_reg.h\"\n\n#if IS_ENABLED(CONFIG_DRM_I915_DEBUG_GEM)\n#define UNEXPECTED\tgt_probe_error\n#else\n#define UNEXPECTED\tgt_notice\n#endif\n\nstatic inline struct intel_gt *\n____uc_fw_to_gt(struct intel_uc_fw *uc_fw, enum intel_uc_fw_type type)\n{\n\tGEM_BUG_ON(type >= INTEL_UC_FW_NUM_TYPES);\n\n\tswitch (type) {\n\tcase INTEL_UC_FW_TYPE_GUC:\n\t\treturn container_of(uc_fw, struct intel_gt, uc.guc.fw);\n\tcase INTEL_UC_FW_TYPE_HUC:\n\t\treturn container_of(uc_fw, struct intel_gt, uc.huc.fw);\n\tcase INTEL_UC_FW_TYPE_GSC:\n\t\treturn container_of(uc_fw, struct intel_gt, uc.gsc.fw);\n\t}\n\n\treturn NULL;\n}\n\nstatic inline struct intel_gt *__uc_fw_to_gt(struct intel_uc_fw *uc_fw)\n{\n\tGEM_BUG_ON(uc_fw->status == INTEL_UC_FIRMWARE_UNINITIALIZED);\n\treturn ____uc_fw_to_gt(uc_fw, uc_fw->type);\n}\n\n#ifdef CONFIG_DRM_I915_DEBUG_GUC\nvoid intel_uc_fw_change_status(struct intel_uc_fw *uc_fw,\n\t\t\t       enum intel_uc_fw_status status)\n{\n\tuc_fw->__status =  status;\n\tgt_dbg(__uc_fw_to_gt(uc_fw), \"%s firmware -> %s\\n\",\n\t       intel_uc_fw_type_repr(uc_fw->type),\n\t       status == INTEL_UC_FIRMWARE_SELECTED ?\n\t       uc_fw->file_selected.path : intel_uc_fw_status_repr(status));\n}\n#endif\n\n \n#define INTEL_GUC_FIRMWARE_DEFS(fw_def, guc_maj, guc_mmp) \\\n\tfw_def(METEORLAKE,   0, guc_maj(mtl,  70, 6, 6)) \\\n\tfw_def(DG2,          0, guc_maj(dg2,  70, 5, 1)) \\\n\tfw_def(ALDERLAKE_P,  0, guc_maj(adlp, 70, 5, 1)) \\\n\tfw_def(ALDERLAKE_P,  0, guc_mmp(adlp, 70, 1, 1)) \\\n\tfw_def(ALDERLAKE_P,  0, guc_mmp(adlp, 69, 0, 3)) \\\n\tfw_def(ALDERLAKE_S,  0, guc_maj(tgl,  70, 5, 1)) \\\n\tfw_def(ALDERLAKE_S,  0, guc_mmp(tgl,  70, 1, 1)) \\\n\tfw_def(ALDERLAKE_S,  0, guc_mmp(tgl,  69, 0, 3)) \\\n\tfw_def(DG1,          0, guc_maj(dg1,  70, 5, 1)) \\\n\tfw_def(ROCKETLAKE,   0, guc_mmp(tgl,  70, 1, 1)) \\\n\tfw_def(TIGERLAKE,    0, guc_mmp(tgl,  70, 1, 1)) \\\n\tfw_def(JASPERLAKE,   0, guc_mmp(ehl,  70, 1, 1)) \\\n\tfw_def(ELKHARTLAKE,  0, guc_mmp(ehl,  70, 1, 1)) \\\n\tfw_def(ICELAKE,      0, guc_mmp(icl,  70, 1, 1)) \\\n\tfw_def(COMETLAKE,    5, guc_mmp(cml,  70, 1, 1)) \\\n\tfw_def(COMETLAKE,    0, guc_mmp(kbl,  70, 1, 1)) \\\n\tfw_def(COFFEELAKE,   0, guc_mmp(kbl,  70, 1, 1)) \\\n\tfw_def(GEMINILAKE,   0, guc_mmp(glk,  70, 1, 1)) \\\n\tfw_def(KABYLAKE,     0, guc_mmp(kbl,  70, 1, 1)) \\\n\tfw_def(BROXTON,      0, guc_mmp(bxt,  70, 1, 1)) \\\n\tfw_def(SKYLAKE,      0, guc_mmp(skl,  70, 1, 1))\n\n#define INTEL_HUC_FIRMWARE_DEFS(fw_def, huc_raw, huc_mmp, huc_gsc) \\\n\tfw_def(METEORLAKE,   0, huc_gsc(mtl)) \\\n\tfw_def(DG2,          0, huc_gsc(dg2)) \\\n\tfw_def(ALDERLAKE_P,  0, huc_raw(tgl)) \\\n\tfw_def(ALDERLAKE_P,  0, huc_mmp(tgl,  7, 9, 3)) \\\n\tfw_def(ALDERLAKE_S,  0, huc_raw(tgl)) \\\n\tfw_def(ALDERLAKE_S,  0, huc_mmp(tgl,  7, 9, 3)) \\\n\tfw_def(DG1,          0, huc_raw(dg1)) \\\n\tfw_def(ROCKETLAKE,   0, huc_mmp(tgl,  7, 9, 3)) \\\n\tfw_def(TIGERLAKE,    0, huc_mmp(tgl,  7, 9, 3)) \\\n\tfw_def(JASPERLAKE,   0, huc_mmp(ehl,  9, 0, 0)) \\\n\tfw_def(ELKHARTLAKE,  0, huc_mmp(ehl,  9, 0, 0)) \\\n\tfw_def(ICELAKE,      0, huc_mmp(icl,  9, 0, 0)) \\\n\tfw_def(COMETLAKE,    5, huc_mmp(cml,  4, 0, 0)) \\\n\tfw_def(COMETLAKE,    0, huc_mmp(kbl,  4, 0, 0)) \\\n\tfw_def(COFFEELAKE,   0, huc_mmp(kbl,  4, 0, 0)) \\\n\tfw_def(GEMINILAKE,   0, huc_mmp(glk,  4, 0, 0)) \\\n\tfw_def(KABYLAKE,     0, huc_mmp(kbl,  4, 0, 0)) \\\n\tfw_def(BROXTON,      0, huc_mmp(bxt,  2, 0, 0)) \\\n\tfw_def(SKYLAKE,      0, huc_mmp(skl,  2, 0, 0))\n\n \n#define __MAKE_UC_FW_PATH_BLANK(prefix_, name_) \\\n\t\"i915/\" \\\n\t__stringify(prefix_) \"_\" name_ \".bin\"\n\n#define __MAKE_UC_FW_PATH_MAJOR(prefix_, name_, major_) \\\n\t\"i915/\" \\\n\t__stringify(prefix_) \"_\" name_ \"_\" \\\n\t__stringify(major_) \".bin\"\n\n#define __MAKE_UC_FW_PATH_MMP(prefix_, name_, major_, minor_, patch_) \\\n\t\"i915/\" \\\n\t__stringify(prefix_) \"_\" name_  \"_\" \\\n\t__stringify(major_) \".\" \\\n\t__stringify(minor_) \".\" \\\n\t__stringify(patch_) \".bin\"\n\n \n#define MAKE_GUC_FW_PATH_MAJOR(prefix_, major_, minor_, patch_) \\\n\t__MAKE_UC_FW_PATH_MAJOR(prefix_, \"guc\", major_)\n\n#define MAKE_GUC_FW_PATH_MMP(prefix_, major_, minor_, patch_) \\\n\t__MAKE_UC_FW_PATH_MMP(prefix_, \"guc\", major_, minor_, patch_)\n\n#define MAKE_HUC_FW_PATH_BLANK(prefix_) \\\n\t__MAKE_UC_FW_PATH_BLANK(prefix_, \"huc\")\n\n#define MAKE_HUC_FW_PATH_GSC(prefix_) \\\n\t__MAKE_UC_FW_PATH_BLANK(prefix_, \"huc_gsc\")\n\n#define MAKE_HUC_FW_PATH_MMP(prefix_, major_, minor_, patch_) \\\n\t__MAKE_UC_FW_PATH_MMP(prefix_, \"huc\", major_, minor_, patch_)\n\n \n#define INTEL_UC_MODULE_FW(platform_, revid_, uc_) \\\n\tMODULE_FIRMWARE(uc_);\n\nINTEL_GUC_FIRMWARE_DEFS(INTEL_UC_MODULE_FW, MAKE_GUC_FW_PATH_MAJOR, MAKE_GUC_FW_PATH_MMP)\nINTEL_HUC_FIRMWARE_DEFS(INTEL_UC_MODULE_FW, MAKE_HUC_FW_PATH_BLANK, MAKE_HUC_FW_PATH_MMP, MAKE_HUC_FW_PATH_GSC)\n\n \nstruct __packed uc_fw_blob {\n\tconst char *path;\n\tbool legacy;\n\tu8 major;\n\tu8 minor;\n\tu8 patch;\n\tbool has_gsc_headers;\n};\n\n#define UC_FW_BLOB_BASE(major_, minor_, patch_, path_) \\\n\t.major = major_, \\\n\t.minor = minor_, \\\n\t.patch = patch_, \\\n\t.path = path_,\n\n#define UC_FW_BLOB_NEW(major_, minor_, patch_, gsc_, path_) \\\n\t{ UC_FW_BLOB_BASE(major_, minor_, patch_, path_) \\\n\t  .legacy = false, .has_gsc_headers = gsc_ }\n\n#define UC_FW_BLOB_OLD(major_, minor_, patch_, path_) \\\n\t{ UC_FW_BLOB_BASE(major_, minor_, patch_, path_) \\\n\t  .legacy = true }\n\n#define GUC_FW_BLOB(prefix_, major_, minor_, patch_) \\\n\tUC_FW_BLOB_NEW(major_, minor_, patch_, false, \\\n\t\t       MAKE_GUC_FW_PATH_MAJOR(prefix_, major_, minor_, patch_))\n\n#define GUC_FW_BLOB_MMP(prefix_, major_, minor_, patch_) \\\n\tUC_FW_BLOB_OLD(major_, minor_, patch_, \\\n\t\t       MAKE_GUC_FW_PATH_MMP(prefix_, major_, minor_, patch_))\n\n#define HUC_FW_BLOB(prefix_) \\\n\tUC_FW_BLOB_NEW(0, 0, 0, false, MAKE_HUC_FW_PATH_BLANK(prefix_))\n\n#define HUC_FW_BLOB_MMP(prefix_, major_, minor_, patch_) \\\n\tUC_FW_BLOB_OLD(major_, minor_, patch_, \\\n\t\t       MAKE_HUC_FW_PATH_MMP(prefix_, major_, minor_, patch_))\n\n#define HUC_FW_BLOB_GSC(prefix_) \\\n\tUC_FW_BLOB_NEW(0, 0, 0, true, MAKE_HUC_FW_PATH_GSC(prefix_))\n\nstruct __packed uc_fw_platform_requirement {\n\tenum intel_platform p;\n\tu8 rev;  \n\tconst struct uc_fw_blob blob;\n};\n\n#define MAKE_FW_LIST(platform_, revid_, uc_) \\\n{ \\\n\t.p = INTEL_##platform_, \\\n\t.rev = revid_, \\\n\t.blob = uc_, \\\n},\n\nstruct fw_blobs_by_type {\n\tconst struct uc_fw_platform_requirement *blobs;\n\tu32 count;\n};\n\nstatic const struct uc_fw_platform_requirement blobs_guc[] = {\n\tINTEL_GUC_FIRMWARE_DEFS(MAKE_FW_LIST, GUC_FW_BLOB, GUC_FW_BLOB_MMP)\n};\n\nstatic const struct uc_fw_platform_requirement blobs_huc[] = {\n\tINTEL_HUC_FIRMWARE_DEFS(MAKE_FW_LIST, HUC_FW_BLOB, HUC_FW_BLOB_MMP, HUC_FW_BLOB_GSC)\n};\n\nstatic const struct fw_blobs_by_type blobs_all[INTEL_UC_FW_NUM_TYPES] = {\n\t[INTEL_UC_FW_TYPE_GUC] = { blobs_guc, ARRAY_SIZE(blobs_guc) },\n\t[INTEL_UC_FW_TYPE_HUC] = { blobs_huc, ARRAY_SIZE(blobs_huc) },\n};\n\nstatic void\n__uc_fw_auto_select(struct drm_i915_private *i915, struct intel_uc_fw *uc_fw)\n{\n\tconst struct uc_fw_platform_requirement *fw_blobs;\n\tenum intel_platform p = INTEL_INFO(i915)->platform;\n\tu32 fw_count;\n\tu8 rev = INTEL_REVID(i915);\n\tint i;\n\tbool found;\n\n\t \n\tif (uc_fw->type == INTEL_UC_FW_TYPE_GSC)\n\t\treturn;\n\n\t \n\tif (IS_ALDERLAKE_P_N(i915))\n\t\tp = INTEL_ALDERLAKE_S;\n\n\tGEM_BUG_ON(uc_fw->type >= ARRAY_SIZE(blobs_all));\n\tfw_blobs = blobs_all[uc_fw->type].blobs;\n\tfw_count = blobs_all[uc_fw->type].count;\n\n\tfound = false;\n\tfor (i = 0; i < fw_count && p <= fw_blobs[i].p; i++) {\n\t\tconst struct uc_fw_blob *blob = &fw_blobs[i].blob;\n\n\t\tif (p != fw_blobs[i].p)\n\t\t\tcontinue;\n\n\t\tif (rev < fw_blobs[i].rev)\n\t\t\tcontinue;\n\n\t\tif (uc_fw->file_selected.path) {\n\t\t\t \n\t\t\tif (uc_fw->file_selected.path == blob->path)\n\t\t\t\tuc_fw->file_selected.path = NULL;\n\n\t\t\tcontinue;\n\t\t}\n\n\t\tuc_fw->file_selected.path = blob->path;\n\t\tuc_fw->file_wanted.path = blob->path;\n\t\tuc_fw->file_wanted.ver.major = blob->major;\n\t\tuc_fw->file_wanted.ver.minor = blob->minor;\n\t\tuc_fw->file_wanted.ver.patch = blob->patch;\n\t\tuc_fw->has_gsc_headers = blob->has_gsc_headers;\n\t\tfound = true;\n\t\tbreak;\n\t}\n\n\tif (!found && uc_fw->file_selected.path) {\n\t\t \n\t\tuc_fw->file_selected.path = NULL;\n\t}\n}\n\nstatic bool validate_fw_table_type(struct drm_i915_private *i915, enum intel_uc_fw_type type)\n{\n\tconst struct uc_fw_platform_requirement *fw_blobs;\n\tu32 fw_count;\n\tint i, j;\n\n\tif (type >= ARRAY_SIZE(blobs_all)) {\n\t\tdrm_err(&i915->drm, \"No blob array for %s\\n\", intel_uc_fw_type_repr(type));\n\t\treturn false;\n\t}\n\n\tfw_blobs = blobs_all[type].blobs;\n\tfw_count = blobs_all[type].count;\n\n\tif (!fw_count)\n\t\treturn true;\n\n\t \n\tfor (i = 1; i < fw_count; i++) {\n\t\t \n\t\tfor (j = i + 1; j < fw_count; j++) {\n\t\t\t \n\t\t\tif (fw_blobs[i].p != fw_blobs[j].p)\n\t\t\t\tcontinue;\n\n\t\t\tif (fw_blobs[i].blob.path != fw_blobs[j].blob.path)\n\t\t\t\tcontinue;\n\n\t\t\tdrm_err(&i915->drm, \"Duplicate %s blobs: %s r%u %s%d.%d.%d [%s] matches %s%d.%d.%d [%s]\\n\",\n\t\t\t\tintel_uc_fw_type_repr(type),\n\t\t\t\tintel_platform_name(fw_blobs[j].p), fw_blobs[j].rev,\n\t\t\t\tfw_blobs[j].blob.legacy ? \"L\" : \"v\",\n\t\t\t\tfw_blobs[j].blob.major, fw_blobs[j].blob.minor,\n\t\t\t\tfw_blobs[j].blob.patch, fw_blobs[j].blob.path,\n\t\t\t\tfw_blobs[i].blob.legacy ? \"L\" : \"v\",\n\t\t\t\tfw_blobs[i].blob.major, fw_blobs[i].blob.minor,\n\t\t\t\tfw_blobs[i].blob.patch, fw_blobs[i].blob.path);\n\t\t}\n\n\t\t \n\t\tif (fw_blobs[i].p < fw_blobs[i - 1].p)\n\t\t\tcontinue;\n\n\t\t \n\t\tif (fw_blobs[i].p == fw_blobs[i - 1].p &&\n\t\t    fw_blobs[i].rev < fw_blobs[i - 1].rev)\n\t\t\tcontinue;\n\n\t\t \n\t\tif (fw_blobs[i].p != fw_blobs[i - 1].p ||\n\t\t    fw_blobs[i].rev != fw_blobs[i - 1].rev)\n\t\t\tgoto bad;\n\n\t\t \n\t\tif (fw_blobs[i].blob.major < fw_blobs[i - 1].blob.major)\n\t\t\tcontinue;\n\n\t\t \n\t\tif (!fw_blobs[i].blob.legacy && fw_blobs[i - 1].blob.legacy)\n\t\t\tgoto bad;\n\n\t\t \n\t\tif (fw_blobs[i].blob.legacy && !fw_blobs[i - 1].blob.legacy) {\n\t\t\tif (!fw_blobs[i - 1].blob.major)\n\t\t\t\tcontinue;\n\n\t\t\tif (fw_blobs[i].blob.major == fw_blobs[i - 1].blob.major)\n\t\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\tif (fw_blobs[i].blob.major != fw_blobs[i - 1].blob.major)\n\t\t\tgoto bad;\n\n\t\t \n\t\tif (fw_blobs[i].blob.minor < fw_blobs[i - 1].blob.minor)\n\t\t\tcontinue;\n\n\t\t \n\t\tif (fw_blobs[i].blob.minor != fw_blobs[i - 1].blob.minor)\n\t\t\tgoto bad;\n\n\t\t \n\t\tif (fw_blobs[i].blob.patch < fw_blobs[i - 1].blob.patch)\n\t\t\tcontinue;\n\nbad:\n\t\tdrm_err(&i915->drm, \"Invalid %s blob order: %s r%u %s%d.%d.%d comes before %s r%u %s%d.%d.%d\\n\",\n\t\t\tintel_uc_fw_type_repr(type),\n\t\t\tintel_platform_name(fw_blobs[i - 1].p), fw_blobs[i - 1].rev,\n\t\t\tfw_blobs[i - 1].blob.legacy ? \"L\" : \"v\",\n\t\t\tfw_blobs[i - 1].blob.major,\n\t\t\tfw_blobs[i - 1].blob.minor,\n\t\t\tfw_blobs[i - 1].blob.patch,\n\t\t\tintel_platform_name(fw_blobs[i].p), fw_blobs[i].rev,\n\t\t\tfw_blobs[i].blob.legacy ? \"L\" : \"v\",\n\t\t\tfw_blobs[i].blob.major,\n\t\t\tfw_blobs[i].blob.minor,\n\t\t\tfw_blobs[i].blob.patch);\n\t\treturn false;\n\t}\n\n\treturn true;\n}\n\nstatic const char *__override_guc_firmware_path(struct drm_i915_private *i915)\n{\n\tif (i915->params.enable_guc & ENABLE_GUC_MASK)\n\t\treturn i915->params.guc_firmware_path;\n\treturn \"\";\n}\n\nstatic const char *__override_huc_firmware_path(struct drm_i915_private *i915)\n{\n\tif (i915->params.enable_guc & ENABLE_GUC_LOAD_HUC)\n\t\treturn i915->params.huc_firmware_path;\n\treturn \"\";\n}\n\nstatic const char *__override_gsc_firmware_path(struct drm_i915_private *i915)\n{\n\treturn i915->params.gsc_firmware_path;\n}\n\nstatic void __uc_fw_user_override(struct drm_i915_private *i915, struct intel_uc_fw *uc_fw)\n{\n\tconst char *path = NULL;\n\n\tswitch (uc_fw->type) {\n\tcase INTEL_UC_FW_TYPE_GUC:\n\t\tpath = __override_guc_firmware_path(i915);\n\t\tbreak;\n\tcase INTEL_UC_FW_TYPE_HUC:\n\t\tpath = __override_huc_firmware_path(i915);\n\t\tbreak;\n\tcase INTEL_UC_FW_TYPE_GSC:\n\t\tpath = __override_gsc_firmware_path(i915);\n\t\tbreak;\n\t}\n\n\tif (unlikely(path)) {\n\t\tuc_fw->file_selected.path = path;\n\t\tuc_fw->user_overridden = true;\n\t}\n}\n\nvoid intel_uc_fw_version_from_gsc_manifest(struct intel_uc_fw_ver *ver,\n\t\t\t\t\t   const void *data)\n{\n\tconst struct intel_gsc_manifest_header *manifest = data;\n\n\tver->major = manifest->fw_version.major;\n\tver->minor = manifest->fw_version.minor;\n\tver->patch = manifest->fw_version.hotfix;\n\tver->build = manifest->fw_version.build;\n}\n\n \nvoid intel_uc_fw_init_early(struct intel_uc_fw *uc_fw,\n\t\t\t    enum intel_uc_fw_type type,\n\t\t\t    bool needs_ggtt_mapping)\n{\n\tstruct intel_gt *gt = ____uc_fw_to_gt(uc_fw, type);\n\tstruct drm_i915_private *i915 = gt->i915;\n\n\t \n\tBUILD_BUG_ON(INTEL_UC_FIRMWARE_UNINITIALIZED);\n\tGEM_BUG_ON(uc_fw->status);\n\tGEM_BUG_ON(uc_fw->file_selected.path);\n\n\tuc_fw->type = type;\n\tuc_fw->needs_ggtt_mapping = needs_ggtt_mapping;\n\n\tif (HAS_GT_UC(i915)) {\n\t\tif (!validate_fw_table_type(i915, type)) {\n\t\t\tgt->uc.fw_table_invalid = true;\n\t\t\tintel_uc_fw_change_status(uc_fw, INTEL_UC_FIRMWARE_NOT_SUPPORTED);\n\t\t\treturn;\n\t\t}\n\n\t\t__uc_fw_auto_select(i915, uc_fw);\n\t\t__uc_fw_user_override(i915, uc_fw);\n\t}\n\n\tintel_uc_fw_change_status(uc_fw, uc_fw->file_selected.path ? *uc_fw->file_selected.path ?\n\t\t\t\t  INTEL_UC_FIRMWARE_SELECTED :\n\t\t\t\t  INTEL_UC_FIRMWARE_DISABLED :\n\t\t\t\t  INTEL_UC_FIRMWARE_NOT_SUPPORTED);\n}\n\nstatic void __force_fw_fetch_failures(struct intel_uc_fw *uc_fw, int e)\n{\n\tstruct drm_i915_private *i915 = __uc_fw_to_gt(uc_fw)->i915;\n\tbool user = e == -EINVAL;\n\n\tif (i915_inject_probe_error(i915, e)) {\n\t\t \n\t\tuc_fw->file_selected.path = \"<invalid>\";\n\t\tuc_fw->user_overridden = user;\n\t} else if (i915_inject_probe_error(i915, e)) {\n\t\t \n\t\tuc_fw->file_wanted.ver.major += 1;\n\t\tuc_fw->file_wanted.ver.minor = 0;\n\t\tuc_fw->user_overridden = user;\n\t} else if (i915_inject_probe_error(i915, e)) {\n\t\t \n\t\tuc_fw->file_wanted.ver.minor += 1;\n\t\tuc_fw->user_overridden = user;\n\t} else if (uc_fw->file_wanted.ver.major &&\n\t\t   i915_inject_probe_error(i915, e)) {\n\t\t \n\t\tuc_fw->file_wanted.ver.major -= 1;\n\t\tuc_fw->file_wanted.ver.minor = 0;\n\t\tuc_fw->user_overridden = user;\n\t} else if (uc_fw->file_wanted.ver.minor &&\n\t\t   i915_inject_probe_error(i915, e)) {\n\t\t \n\t\tuc_fw->file_wanted.ver.minor -= 1;\n\t\tuc_fw->user_overridden = user;\n\t} else if (user && i915_inject_probe_error(i915, e)) {\n\t\t \n\t\tuc_fw->file_wanted.ver.major = 0;\n\t\tuc_fw->file_wanted.ver.minor = 0;\n\t\tuc_fw->user_overridden = true;\n\t}\n}\n\nstatic void uc_unpack_css_version(struct intel_uc_fw_ver *ver, u32 css_value)\n{\n\t \n\tver->major = FIELD_GET(CSS_SW_VERSION_UC_MAJOR, css_value);\n\tver->minor = FIELD_GET(CSS_SW_VERSION_UC_MINOR, css_value);\n\tver->patch = FIELD_GET(CSS_SW_VERSION_UC_PATCH, css_value);\n}\n\nstatic void guc_read_css_info(struct intel_uc_fw *uc_fw, struct uc_css_header *css)\n{\n\tstruct intel_guc *guc = container_of(uc_fw, struct intel_guc, fw);\n\n\t \n\tif (uc_fw->file_selected.ver.major >= 70) {\n\t\tif (uc_fw->file_selected.ver.minor >= 6) {\n\t\t\t \n\t\t\tuc_unpack_css_version(&guc->submission_version, css->vf_version);\n\t\t} else if (uc_fw->file_selected.ver.minor >= 3) {\n\t\t\t \n\t\t\tguc->submission_version.major = 1;\n\t\t\tguc->submission_version.minor = 1;\n\t\t\tguc->submission_version.patch = 0;\n\t\t} else {\n\t\t\t \n\t\t\tguc->submission_version.major = 1;\n\t\t\tguc->submission_version.minor = 0;\n\t\t\tguc->submission_version.patch = 0;\n\t\t}\n\t} else if (uc_fw->file_selected.ver.major >= 69) {\n\t\t \n\t\tguc->submission_version.major = 0;\n\t\tguc->submission_version.minor = 10;\n\t\tguc->submission_version.patch = 0;\n\t} else {\n\t\t \n\t\tguc->submission_version.major = 0;\n\t\tguc->submission_version.minor = 1;\n\t\tguc->submission_version.patch = 0;\n\t}\n\n\tuc_fw->private_data_size = css->private_data_size;\n}\n\nstatic int __check_ccs_header(struct intel_gt *gt,\n\t\t\t      const void *fw_data, size_t fw_size,\n\t\t\t      struct intel_uc_fw *uc_fw)\n{\n\tstruct uc_css_header *css;\n\tsize_t size;\n\n\t \n\tif (unlikely(fw_size < sizeof(struct uc_css_header))) {\n\t\tgt_warn(gt, \"%s firmware %s: invalid size: %zu < %zu\\n\",\n\t\t\tintel_uc_fw_type_repr(uc_fw->type), uc_fw->file_selected.path,\n\t\t\tfw_size, sizeof(struct uc_css_header));\n\t\treturn -ENODATA;\n\t}\n\n\tcss = (struct uc_css_header *)fw_data;\n\n\t \n\tsize = (css->header_size_dw - css->key_size_dw - css->modulus_size_dw -\n\t\tcss->exponent_size_dw) * sizeof(u32);\n\tif (unlikely(size != sizeof(struct uc_css_header))) {\n\t\tgt_warn(gt, \"%s firmware %s: unexpected header size: %zu != %zu\\n\",\n\t\t\tintel_uc_fw_type_repr(uc_fw->type), uc_fw->file_selected.path,\n\t\t\tfw_size, sizeof(struct uc_css_header));\n\t\treturn -EPROTO;\n\t}\n\n\t \n\tuc_fw->ucode_size = (css->size_dw - css->header_size_dw) * sizeof(u32);\n\n\t \n\tuc_fw->rsa_size = css->key_size_dw * sizeof(u32);\n\n\t \n\tsize = sizeof(struct uc_css_header) + uc_fw->ucode_size + uc_fw->rsa_size;\n\tif (unlikely(fw_size < size)) {\n\t\tgt_warn(gt, \"%s firmware %s: invalid size: %zu < %zu\\n\",\n\t\t\tintel_uc_fw_type_repr(uc_fw->type), uc_fw->file_selected.path,\n\t\t\tfw_size, size);\n\t\treturn -ENOEXEC;\n\t}\n\n\t \n\tsize = __intel_uc_fw_get_upload_size(uc_fw);\n\tif (unlikely(size >= gt->wopcm.size)) {\n\t\tgt_warn(gt, \"%s firmware %s: invalid size: %zu > %zu\\n\",\n\t\t\tintel_uc_fw_type_repr(uc_fw->type), uc_fw->file_selected.path,\n\t\t\tsize, (size_t)gt->wopcm.size);\n\t\treturn -E2BIG;\n\t}\n\n\tuc_unpack_css_version(&uc_fw->file_selected.ver, css->sw_version);\n\n\tif (uc_fw->type == INTEL_UC_FW_TYPE_GUC)\n\t\tguc_read_css_info(uc_fw, css);\n\n\treturn 0;\n}\n\nstatic int check_gsc_manifest(struct intel_gt *gt,\n\t\t\t      const struct firmware *fw,\n\t\t\t      struct intel_uc_fw *uc_fw)\n{\n\tswitch (uc_fw->type) {\n\tcase INTEL_UC_FW_TYPE_HUC:\n\t\tintel_huc_fw_get_binary_info(uc_fw, fw->data, fw->size);\n\t\tbreak;\n\tcase INTEL_UC_FW_TYPE_GSC:\n\t\tintel_gsc_fw_get_binary_info(uc_fw, fw->data, fw->size);\n\t\tbreak;\n\tdefault:\n\t\tMISSING_CASE(uc_fw->type);\n\t\treturn -EINVAL;\n\t}\n\n\tif (uc_fw->dma_start_offset) {\n\t\tu32 delta = uc_fw->dma_start_offset;\n\n\t\t__check_ccs_header(gt, fw->data + delta, fw->size - delta, uc_fw);\n\t}\n\n\treturn 0;\n}\n\nstatic int check_ccs_header(struct intel_gt *gt,\n\t\t\t    const struct firmware *fw,\n\t\t\t    struct intel_uc_fw *uc_fw)\n{\n\treturn __check_ccs_header(gt, fw->data, fw->size, uc_fw);\n}\n\nstatic bool is_ver_8bit(struct intel_uc_fw_ver *ver)\n{\n\treturn ver->major < 0xFF && ver->minor < 0xFF && ver->patch < 0xFF;\n}\n\nstatic int guc_check_version_range(struct intel_uc_fw *uc_fw)\n{\n\tstruct intel_guc *guc = container_of(uc_fw, struct intel_guc, fw);\n\tstruct intel_gt *gt = __uc_fw_to_gt(uc_fw);\n\n\t \n\n\tif (!is_ver_8bit(&uc_fw->file_selected.ver)) {\n\t\tgt_warn(gt, \"%s firmware: invalid file version: 0x%02X:%02X:%02X\\n\",\n\t\t\tintel_uc_fw_type_repr(uc_fw->type),\n\t\t\tuc_fw->file_selected.ver.major,\n\t\t\tuc_fw->file_selected.ver.minor,\n\t\t\tuc_fw->file_selected.ver.patch);\n\t\treturn -EINVAL;\n\t}\n\n\tif (!is_ver_8bit(&guc->submission_version)) {\n\t\tgt_warn(gt, \"%s firmware: invalid submit version: 0x%02X:%02X:%02X\\n\",\n\t\t\tintel_uc_fw_type_repr(uc_fw->type),\n\t\t\tguc->submission_version.major,\n\t\t\tguc->submission_version.minor,\n\t\t\tguc->submission_version.patch);\n\t\treturn -EINVAL;\n\t}\n\n\treturn i915_inject_probe_error(gt->i915, -EINVAL);\n}\n\nstatic int check_fw_header(struct intel_gt *gt,\n\t\t\t   const struct firmware *fw,\n\t\t\t   struct intel_uc_fw *uc_fw)\n{\n\tint err = 0;\n\n\tif (uc_fw->has_gsc_headers)\n\t\terr = check_gsc_manifest(gt, fw, uc_fw);\n\telse\n\t\terr = check_ccs_header(gt, fw, uc_fw);\n\tif (err)\n\t\treturn err;\n\n\treturn 0;\n}\n\nstatic int try_firmware_load(struct intel_uc_fw *uc_fw, const struct firmware **fw)\n{\n\tstruct intel_gt *gt = __uc_fw_to_gt(uc_fw);\n\tstruct device *dev = gt->i915->drm.dev;\n\tint err;\n\n\terr = firmware_request_nowarn(fw, uc_fw->file_selected.path, dev);\n\n\tif (err)\n\t\treturn err;\n\n\tif (uc_fw->needs_ggtt_mapping && (*fw)->size > INTEL_UC_RSVD_GGTT_PER_FW) {\n\t\tgt_err(gt, \"%s firmware %s: size (%zuKB) exceeds max supported size (%uKB)\\n\",\n\t\t       intel_uc_fw_type_repr(uc_fw->type), uc_fw->file_selected.path,\n\t\t       (*fw)->size / SZ_1K, INTEL_UC_RSVD_GGTT_PER_FW / SZ_1K);\n\n\t\t \n\t\trelease_firmware(*fw);\n\t\t*fw = NULL;\n\t\treturn -ENOENT;\n\t}\n\n\treturn 0;\n}\n\nstatic int check_mtl_huc_guc_compatibility(struct intel_gt *gt,\n\t\t\t\t\t   struct intel_uc_fw_file *huc_selected)\n{\n\tstruct intel_uc_fw_file *guc_selected = &gt->uc.guc.fw.file_selected;\n\tstruct intel_uc_fw_ver *huc_ver = &huc_selected->ver;\n\tstruct intel_uc_fw_ver *guc_ver = &guc_selected->ver;\n\tbool new_huc, new_guc;\n\n\t \n\tGEM_BUG_ON(!huc_selected->path || !guc_selected->path);\n\n\t \n\tnew_huc = huc_ver->major > 8 ||\n\t\t  (huc_ver->major == 8 && huc_ver->minor > 5) ||\n\t\t  (huc_ver->major == 8 && huc_ver->minor == 5 && huc_ver->patch >= 1);\n\n\tnew_guc = guc_ver->major > 70 ||\n\t\t  (guc_ver->major == 70 && guc_ver->minor >= 7);\n\n\tif (new_huc != new_guc) {\n\t\tUNEXPECTED(gt, \"HuC %u.%u.%u is incompatible with GuC %u.%u.%u\\n\",\n\t\t\t   huc_ver->major, huc_ver->minor, huc_ver->patch,\n\t\t\t   guc_ver->major, guc_ver->minor, guc_ver->patch);\n\t\tgt_info(gt, \"MTL GuC 70.7.0+ and HuC 8.5.1+ don't work with older releases\\n\");\n\t\treturn -ENOEXEC;\n\t}\n\n\treturn 0;\n}\n\nint intel_uc_check_file_version(struct intel_uc_fw *uc_fw, bool *old_ver)\n{\n\tstruct intel_gt *gt = __uc_fw_to_gt(uc_fw);\n\tstruct intel_uc_fw_file *wanted = &uc_fw->file_wanted;\n\tstruct intel_uc_fw_file *selected = &uc_fw->file_selected;\n\tint ret;\n\n\t \n\tif (IS_METEORLAKE(gt->i915) && uc_fw->type == INTEL_UC_FW_TYPE_HUC) {\n\t\tret = check_mtl_huc_guc_compatibility(gt, selected);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tif (!wanted->ver.major || !selected->ver.major)\n\t\treturn 0;\n\n\t \n\tif (selected->ver.major != wanted->ver.major) {\n\t\tUNEXPECTED(gt, \"%s firmware %s: unexpected version: %u.%u != %u.%u\\n\",\n\t\t\t   intel_uc_fw_type_repr(uc_fw->type), selected->path,\n\t\t\t   selected->ver.major, selected->ver.minor,\n\t\t\t   wanted->ver.major, wanted->ver.minor);\n\t\tif (!intel_uc_fw_is_overridden(uc_fw))\n\t\t\treturn -ENOEXEC;\n\t} else if (old_ver) {\n\t\tif (selected->ver.minor < wanted->ver.minor)\n\t\t\t*old_ver = true;\n\t\telse if ((selected->ver.minor == wanted->ver.minor) &&\n\t\t\t (selected->ver.patch < wanted->ver.patch))\n\t\t\t*old_ver = true;\n\t}\n\n\treturn 0;\n}\n\n \nint intel_uc_fw_fetch(struct intel_uc_fw *uc_fw)\n{\n\tstruct intel_gt *gt = __uc_fw_to_gt(uc_fw);\n\tstruct drm_i915_private *i915 = gt->i915;\n\tstruct intel_uc_fw_file file_ideal;\n\tstruct drm_i915_gem_object *obj;\n\tconst struct firmware *fw = NULL;\n\tbool old_ver = false;\n\tint err;\n\n\tGEM_BUG_ON(!gt->wopcm.size);\n\tGEM_BUG_ON(!intel_uc_fw_is_enabled(uc_fw));\n\n\terr = i915_inject_probe_error(i915, -ENXIO);\n\tif (err)\n\t\tgoto fail;\n\n\t__force_fw_fetch_failures(uc_fw, -EINVAL);\n\t__force_fw_fetch_failures(uc_fw, -ESTALE);\n\n\terr = try_firmware_load(uc_fw, &fw);\n\tmemcpy(&file_ideal, &uc_fw->file_wanted, sizeof(file_ideal));\n\n\t \n\tif (err && intel_uc_fw_is_overridden(uc_fw))\n\t\tgoto fail;\n\n\twhile (err == -ENOENT) {\n\t\told_ver = true;\n\n\t\t__uc_fw_auto_select(i915, uc_fw);\n\t\tif (!uc_fw->file_selected.path) {\n\t\t\t \n\t\t\tuc_fw->file_selected.path = file_ideal.path;\n\n\t\t\t \n\t\t\tmemcpy(&uc_fw->file_wanted, &file_ideal, sizeof(uc_fw->file_wanted));\n\t\t\tbreak;\n\t\t}\n\n\t\terr = try_firmware_load(uc_fw, &fw);\n\t}\n\n\tif (err)\n\t\tgoto fail;\n\n\terr = check_fw_header(gt, fw, uc_fw);\n\tif (err)\n\t\tgoto fail;\n\n\tif (uc_fw->type == INTEL_UC_FW_TYPE_GUC) {\n\t\terr = guc_check_version_range(uc_fw);\n\t\tif (err)\n\t\t\tgoto fail;\n\t}\n\n\terr = intel_uc_check_file_version(uc_fw, &old_ver);\n\tif (err)\n\t\tgoto fail;\n\n\tif (old_ver && uc_fw->file_selected.ver.major) {\n\t\t \n\t\tmemcpy(&uc_fw->file_wanted, &file_ideal, sizeof(uc_fw->file_wanted));\n\n\t\tUNEXPECTED(gt, \"%s firmware %s (%d.%d.%d) is recommended, but only %s (%d.%d.%d) was found\\n\",\n\t\t\t   intel_uc_fw_type_repr(uc_fw->type),\n\t\t\t   uc_fw->file_wanted.path,\n\t\t\t   uc_fw->file_wanted.ver.major,\n\t\t\t   uc_fw->file_wanted.ver.minor,\n\t\t\t   uc_fw->file_wanted.ver.patch,\n\t\t\t   uc_fw->file_selected.path,\n\t\t\t   uc_fw->file_selected.ver.major,\n\t\t\t   uc_fw->file_selected.ver.minor,\n\t\t\t   uc_fw->file_selected.ver.patch);\n\t\tgt_info(gt, \"Consider updating your linux-firmware pkg or downloading from %s\\n\",\n\t\t\tINTEL_UC_FIRMWARE_URL);\n\t}\n\n\tif (HAS_LMEM(i915)) {\n\t\tobj = i915_gem_object_create_lmem_from_data(i915, fw->data, fw->size);\n\t\tif (!IS_ERR(obj))\n\t\t\tobj->flags |= I915_BO_ALLOC_PM_EARLY;\n\t} else {\n\t\tobj = i915_gem_object_create_shmem_from_data(i915, fw->data, fw->size);\n\t}\n\n\tif (IS_ERR(obj)) {\n\t\terr = PTR_ERR(obj);\n\t\tgoto fail;\n\t}\n\n\tuc_fw->obj = obj;\n\tuc_fw->size = fw->size;\n\tintel_uc_fw_change_status(uc_fw, INTEL_UC_FIRMWARE_AVAILABLE);\n\n\trelease_firmware(fw);\n\treturn 0;\n\nfail:\n\tintel_uc_fw_change_status(uc_fw, err == -ENOENT ?\n\t\t\t\t  INTEL_UC_FIRMWARE_MISSING :\n\t\t\t\t  INTEL_UC_FIRMWARE_ERROR);\n\n\tgt_probe_error(gt, \"%s firmware %s: fetch failed %pe\\n\",\n\t\t       intel_uc_fw_type_repr(uc_fw->type), uc_fw->file_selected.path, ERR_PTR(err));\n\tgt_info(gt, \"%s firmware(s) can be downloaded from %s\\n\",\n\t\tintel_uc_fw_type_repr(uc_fw->type), INTEL_UC_FIRMWARE_URL);\n\n\trelease_firmware(fw);\t\t \n\treturn err;\n}\n\nstatic u32 uc_fw_ggtt_offset(struct intel_uc_fw *uc_fw)\n{\n\tstruct intel_gt *gt = __uc_fw_to_gt(uc_fw);\n\tstruct i915_ggtt *ggtt = gt->ggtt;\n\tstruct drm_mm_node *node = &ggtt->uc_fw;\n\tu32 offset = uc_fw->type * INTEL_UC_RSVD_GGTT_PER_FW;\n\n\t \n\tBUILD_BUG_ON(INTEL_UC_FW_NUM_TYPES * INTEL_UC_RSVD_GGTT_PER_FW > SZ_8M);\n\tGEM_BUG_ON(gt->type == GT_MEDIA && gt->info.id > 1);\n\tif (gt->type == GT_MEDIA)\n\t\toffset += SZ_8M;\n\n\tGEM_BUG_ON(!drm_mm_node_allocated(node));\n\tGEM_BUG_ON(upper_32_bits(node->start));\n\tGEM_BUG_ON(upper_32_bits(node->start + node->size - 1));\n\tGEM_BUG_ON(offset + uc_fw->obj->base.size > node->size);\n\tGEM_BUG_ON(uc_fw->obj->base.size > INTEL_UC_RSVD_GGTT_PER_FW);\n\n\treturn lower_32_bits(node->start + offset);\n}\n\nstatic void uc_fw_bind_ggtt(struct intel_uc_fw *uc_fw)\n{\n\tstruct drm_i915_gem_object *obj = uc_fw->obj;\n\tstruct i915_ggtt *ggtt = __uc_fw_to_gt(uc_fw)->ggtt;\n\tstruct i915_vma_resource *vma_res = &uc_fw->vma_res;\n\tu32 pte_flags = 0;\n\n\tif (!uc_fw->needs_ggtt_mapping)\n\t\treturn;\n\n\tvma_res->start = uc_fw_ggtt_offset(uc_fw);\n\tvma_res->node_size = obj->base.size;\n\tvma_res->bi.pages = obj->mm.pages;\n\n\tGEM_BUG_ON(!i915_gem_object_has_pinned_pages(obj));\n\n\t \n\tif (i915_gem_object_has_struct_page(obj))\n\t\tdrm_clflush_sg(vma_res->bi.pages);\n\n\tif (i915_gem_object_is_lmem(obj))\n\t\tpte_flags |= PTE_LM;\n\n\tif (ggtt->vm.raw_insert_entries)\n\t\tggtt->vm.raw_insert_entries(&ggtt->vm, vma_res,\n\t\t\t\t\t    i915_gem_get_pat_index(ggtt->vm.i915,\n\t\t\t\t\t\t\t\t   I915_CACHE_NONE),\n\t\t\t\t\t    pte_flags);\n\telse\n\t\tggtt->vm.insert_entries(&ggtt->vm, vma_res,\n\t\t\t\t\ti915_gem_get_pat_index(ggtt->vm.i915,\n\t\t\t\t\t\t\t       I915_CACHE_NONE),\n\t\t\t\t\tpte_flags);\n}\n\nstatic void uc_fw_unbind_ggtt(struct intel_uc_fw *uc_fw)\n{\n\tstruct i915_ggtt *ggtt = __uc_fw_to_gt(uc_fw)->ggtt;\n\tstruct i915_vma_resource *vma_res = &uc_fw->vma_res;\n\n\tif (!vma_res->node_size)\n\t\treturn;\n\n\tggtt->vm.clear_range(&ggtt->vm, vma_res->start, vma_res->node_size);\n}\n\nstatic int uc_fw_xfer(struct intel_uc_fw *uc_fw, u32 dst_offset, u32 dma_flags)\n{\n\tstruct intel_gt *gt = __uc_fw_to_gt(uc_fw);\n\tstruct intel_uncore *uncore = gt->uncore;\n\tu64 offset;\n\tint ret;\n\n\tret = i915_inject_probe_error(gt->i915, -ETIMEDOUT);\n\tif (ret)\n\t\treturn ret;\n\n\tintel_uncore_forcewake_get(uncore, FORCEWAKE_ALL);\n\n\t \n\toffset = uc_fw->vma_res.start + uc_fw->dma_start_offset;\n\tGEM_BUG_ON(upper_32_bits(offset) & 0xFFFF0000);\n\tintel_uncore_write_fw(uncore, DMA_ADDR_0_LOW, lower_32_bits(offset));\n\tintel_uncore_write_fw(uncore, DMA_ADDR_0_HIGH, upper_32_bits(offset));\n\n\t \n\tintel_uncore_write_fw(uncore, DMA_ADDR_1_LOW, dst_offset);\n\tintel_uncore_write_fw(uncore, DMA_ADDR_1_HIGH, DMA_ADDRESS_SPACE_WOPCM);\n\n\t \n\tintel_uncore_write_fw(uncore, DMA_COPY_SIZE,\n\t\t\t      sizeof(struct uc_css_header) + uc_fw->ucode_size);\n\n\t \n\tintel_uncore_write_fw(uncore, DMA_CTRL,\n\t\t\t      _MASKED_BIT_ENABLE(dma_flags | START_DMA));\n\n\t \n\tret = intel_wait_for_register_fw(uncore, DMA_CTRL, START_DMA, 0, 100);\n\tif (ret)\n\t\tgt_err(gt, \"DMA for %s fw failed, DMA_CTRL=%u\\n\",\n\t\t       intel_uc_fw_type_repr(uc_fw->type),\n\t\t       intel_uncore_read_fw(uncore, DMA_CTRL));\n\n\t \n\tintel_uncore_write_fw(uncore, DMA_CTRL, _MASKED_BIT_DISABLE(dma_flags));\n\n\tintel_uncore_forcewake_put(uncore, FORCEWAKE_ALL);\n\n\treturn ret;\n}\n\nint intel_uc_fw_mark_load_failed(struct intel_uc_fw *uc_fw, int err)\n{\n\tstruct intel_gt *gt = __uc_fw_to_gt(uc_fw);\n\n\tGEM_BUG_ON(!intel_uc_fw_is_loadable(uc_fw));\n\n\tgt_probe_error(gt, \"Failed to load %s firmware %s %pe\\n\",\n\t\t       intel_uc_fw_type_repr(uc_fw->type), uc_fw->file_selected.path, ERR_PTR(err));\n\tintel_uc_fw_change_status(uc_fw, INTEL_UC_FIRMWARE_LOAD_FAIL);\n\n\treturn err;\n}\n\n \nint intel_uc_fw_upload(struct intel_uc_fw *uc_fw, u32 dst_offset, u32 dma_flags)\n{\n\tstruct intel_gt *gt = __uc_fw_to_gt(uc_fw);\n\tint err;\n\n\t \n\tGEM_BUG_ON(intel_uc_fw_is_loaded(uc_fw));\n\n\terr = i915_inject_probe_error(gt->i915, -ENOEXEC);\n\tif (err)\n\t\treturn err;\n\n\tif (!intel_uc_fw_is_loadable(uc_fw))\n\t\treturn -ENOEXEC;\n\n\t \n\terr = uc_fw_xfer(uc_fw, dst_offset, dma_flags);\n\tif (err)\n\t\tgoto fail;\n\n\tintel_uc_fw_change_status(uc_fw, INTEL_UC_FIRMWARE_TRANSFERRED);\n\treturn 0;\n\nfail:\n\treturn intel_uc_fw_mark_load_failed(uc_fw, err);\n}\n\nstatic inline bool uc_fw_need_rsa_in_memory(struct intel_uc_fw *uc_fw)\n{\n\t \n\treturn uc_fw->type == INTEL_UC_FW_TYPE_HUC || uc_fw->rsa_size > 256;\n}\n\nstatic int uc_fw_rsa_data_create(struct intel_uc_fw *uc_fw)\n{\n\tstruct intel_gt *gt = __uc_fw_to_gt(uc_fw);\n\tstruct i915_vma *vma;\n\tsize_t copied;\n\tvoid *vaddr;\n\tint err;\n\n\terr = i915_inject_probe_error(gt->i915, -ENXIO);\n\tif (err)\n\t\treturn err;\n\n\tif (!uc_fw_need_rsa_in_memory(uc_fw))\n\t\treturn 0;\n\n\t \n\tGEM_BUG_ON(uc_fw->rsa_size > PAGE_SIZE);\n\tvma = intel_guc_allocate_vma(&gt->uc.guc, PAGE_SIZE);\n\tif (IS_ERR(vma))\n\t\treturn PTR_ERR(vma);\n\n\tvaddr = i915_gem_object_pin_map_unlocked(vma->obj,\n\t\t\t\t\t\t intel_gt_coherent_map_type(gt, vma->obj, true));\n\tif (IS_ERR(vaddr)) {\n\t\ti915_vma_unpin_and_release(&vma, 0);\n\t\terr = PTR_ERR(vaddr);\n\t\tgoto unpin_out;\n\t}\n\n\tcopied = intel_uc_fw_copy_rsa(uc_fw, vaddr, vma->size);\n\ti915_gem_object_unpin_map(vma->obj);\n\n\tif (copied < uc_fw->rsa_size) {\n\t\terr = -ENOMEM;\n\t\tgoto unpin_out;\n\t}\n\n\tuc_fw->rsa_data = vma;\n\n\treturn 0;\n\nunpin_out:\n\ti915_vma_unpin_and_release(&vma, 0);\n\treturn err;\n}\n\nstatic void uc_fw_rsa_data_destroy(struct intel_uc_fw *uc_fw)\n{\n\ti915_vma_unpin_and_release(&uc_fw->rsa_data, 0);\n}\n\nint intel_uc_fw_init(struct intel_uc_fw *uc_fw)\n{\n\tint err;\n\n\t \n\tGEM_BUG_ON(intel_uc_fw_is_loaded(uc_fw));\n\n\tif (!intel_uc_fw_is_available(uc_fw))\n\t\treturn -ENOEXEC;\n\n\terr = i915_gem_object_pin_pages_unlocked(uc_fw->obj);\n\tif (err) {\n\t\tgt_dbg(__uc_fw_to_gt(uc_fw), \"%s fw pin-pages failed %pe\\n\",\n\t\t       intel_uc_fw_type_repr(uc_fw->type), ERR_PTR(err));\n\t\tgoto out;\n\t}\n\n\terr = uc_fw_rsa_data_create(uc_fw);\n\tif (err) {\n\t\tgt_dbg(__uc_fw_to_gt(uc_fw), \"%s fw rsa data creation failed %pe\\n\",\n\t\t       intel_uc_fw_type_repr(uc_fw->type), ERR_PTR(err));\n\t\tgoto out_unpin;\n\t}\n\n\tuc_fw_bind_ggtt(uc_fw);\n\n\treturn 0;\n\nout_unpin:\n\ti915_gem_object_unpin_pages(uc_fw->obj);\nout:\n\treturn err;\n}\n\nvoid intel_uc_fw_fini(struct intel_uc_fw *uc_fw)\n{\n\tuc_fw_unbind_ggtt(uc_fw);\n\tuc_fw_rsa_data_destroy(uc_fw);\n\n\tif (i915_gem_object_has_pinned_pages(uc_fw->obj))\n\t\ti915_gem_object_unpin_pages(uc_fw->obj);\n\n\tintel_uc_fw_change_status(uc_fw, INTEL_UC_FIRMWARE_AVAILABLE);\n}\n\nvoid intel_uc_fw_resume_mapping(struct intel_uc_fw *uc_fw)\n{\n\tif (!intel_uc_fw_is_available(uc_fw))\n\t\treturn;\n\n\tif (!i915_gem_object_has_pinned_pages(uc_fw->obj))\n\t\treturn;\n\n\tuc_fw_bind_ggtt(uc_fw);\n}\n\n \nvoid intel_uc_fw_cleanup_fetch(struct intel_uc_fw *uc_fw)\n{\n\tif (!intel_uc_fw_is_available(uc_fw))\n\t\treturn;\n\n\ti915_gem_object_put(fetch_and_zero(&uc_fw->obj));\n\n\tintel_uc_fw_change_status(uc_fw, INTEL_UC_FIRMWARE_SELECTED);\n}\n\n \nsize_t intel_uc_fw_copy_rsa(struct intel_uc_fw *uc_fw, void *dst, u32 max_len)\n{\n\tstruct intel_memory_region *mr = uc_fw->obj->mm.region;\n\tu32 size = min_t(u32, uc_fw->rsa_size, max_len);\n\tu32 offset = uc_fw->dma_start_offset + sizeof(struct uc_css_header) + uc_fw->ucode_size;\n\tstruct sgt_iter iter;\n\tsize_t count = 0;\n\tint idx;\n\n\t \n\tGEM_BUG_ON(!intel_uc_fw_is_available(uc_fw));\n\n\tidx = offset >> PAGE_SHIFT;\n\toffset = offset_in_page(offset);\n\tif (i915_gem_object_has_struct_page(uc_fw->obj)) {\n\t\tstruct page *page;\n\n\t\tfor_each_sgt_page(page, iter, uc_fw->obj->mm.pages) {\n\t\t\tu32 len = min_t(u32, size, PAGE_SIZE - offset);\n\t\t\tvoid *vaddr;\n\n\t\t\tif (idx > 0) {\n\t\t\t\tidx--;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tvaddr = kmap_atomic(page);\n\t\t\tmemcpy(dst, vaddr + offset, len);\n\t\t\tkunmap_atomic(vaddr);\n\n\t\t\toffset = 0;\n\t\t\tdst += len;\n\t\t\tsize -= len;\n\t\t\tcount += len;\n\t\t\tif (!size)\n\t\t\t\tbreak;\n\t\t}\n\t} else {\n\t\tdma_addr_t addr;\n\n\t\tfor_each_sgt_daddr(addr, iter, uc_fw->obj->mm.pages) {\n\t\t\tu32 len = min_t(u32, size, PAGE_SIZE - offset);\n\t\t\tvoid __iomem *vaddr;\n\n\t\t\tif (idx > 0) {\n\t\t\t\tidx--;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tvaddr = io_mapping_map_atomic_wc(&mr->iomap,\n\t\t\t\t\t\t\t addr - mr->region.start);\n\t\t\tmemcpy_fromio(dst, vaddr + offset, len);\n\t\t\tio_mapping_unmap_atomic(vaddr);\n\n\t\t\toffset = 0;\n\t\t\tdst += len;\n\t\t\tsize -= len;\n\t\t\tcount += len;\n\t\t\tif (!size)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn count;\n}\n\n \nvoid intel_uc_fw_dump(const struct intel_uc_fw *uc_fw, struct drm_printer *p)\n{\n\tbool got_wanted;\n\n\tdrm_printf(p, \"%s firmware: %s\\n\",\n\t\t   intel_uc_fw_type_repr(uc_fw->type), uc_fw->file_selected.path);\n\tif (uc_fw->file_selected.path != uc_fw->file_wanted.path)\n\t\tdrm_printf(p, \"%s firmware wanted: %s\\n\",\n\t\t\t   intel_uc_fw_type_repr(uc_fw->type), uc_fw->file_wanted.path);\n\tdrm_printf(p, \"\\tstatus: %s\\n\",\n\t\t   intel_uc_fw_status_repr(uc_fw->status));\n\n\tif (uc_fw->file_selected.ver.major < uc_fw->file_wanted.ver.major)\n\t\tgot_wanted = false;\n\telse if ((uc_fw->file_selected.ver.major == uc_fw->file_wanted.ver.major) &&\n\t\t (uc_fw->file_selected.ver.minor < uc_fw->file_wanted.ver.minor))\n\t\tgot_wanted = false;\n\telse if ((uc_fw->file_selected.ver.major == uc_fw->file_wanted.ver.major) &&\n\t\t (uc_fw->file_selected.ver.minor == uc_fw->file_wanted.ver.minor) &&\n\t\t (uc_fw->file_selected.ver.patch < uc_fw->file_wanted.ver.patch))\n\t\tgot_wanted = false;\n\telse\n\t\tgot_wanted = true;\n\n\tif (!got_wanted)\n\t\tdrm_printf(p, \"\\tversion: wanted %u.%u.%u, found %u.%u.%u\\n\",\n\t\t\t   uc_fw->file_wanted.ver.major,\n\t\t\t   uc_fw->file_wanted.ver.minor,\n\t\t\t   uc_fw->file_wanted.ver.patch,\n\t\t\t   uc_fw->file_selected.ver.major,\n\t\t\t   uc_fw->file_selected.ver.minor,\n\t\t\t   uc_fw->file_selected.ver.patch);\n\telse\n\t\tdrm_printf(p, \"\\tversion: found %u.%u.%u\\n\",\n\t\t\t   uc_fw->file_selected.ver.major,\n\t\t\t   uc_fw->file_selected.ver.minor,\n\t\t\t   uc_fw->file_selected.ver.patch);\n\tdrm_printf(p, \"\\tuCode: %u bytes\\n\", uc_fw->ucode_size);\n\tdrm_printf(p, \"\\tRSA: %u bytes\\n\", uc_fw->rsa_size);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}