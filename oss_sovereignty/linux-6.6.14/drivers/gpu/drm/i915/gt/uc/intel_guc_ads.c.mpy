{
  "module_name": "intel_guc_ads.c",
  "hash_id": "d69df4923281e18095f4b12767299a6f13eb986c1282c983c0b605226b60b5f4",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/i915/gt/uc/intel_guc_ads.c",
  "human_readable_source": "\n \n\n#include <linux/bsearch.h>\n\n#include \"gem/i915_gem_lmem.h\"\n#include \"gt/intel_engine_regs.h\"\n#include \"gt/intel_gt.h\"\n#include \"gt/intel_gt_mcr.h\"\n#include \"gt/intel_gt_regs.h\"\n#include \"gt/intel_lrc.h\"\n#include \"gt/shmem_utils.h\"\n#include \"intel_guc_ads.h\"\n#include \"intel_guc_capture.h\"\n#include \"intel_guc_fwif.h\"\n#include \"intel_guc_print.h\"\n#include \"intel_uc.h\"\n#include \"i915_drv.h\"\n\n \nstruct __guc_ads_blob {\n\tstruct guc_ads ads;\n\tstruct guc_policies policies;\n\tstruct guc_gt_system_info system_info;\n\tstruct guc_engine_usage engine_usage;\n\t \n\tstruct guc_mmio_reg regset[];\n} __packed;\n\n#define ads_blob_read(guc_, field_)\t\t\t\t\t\\\n\tiosys_map_rd_field(&(guc_)->ads_map, 0, struct __guc_ads_blob, field_)\n\n#define ads_blob_write(guc_, field_, val_)\t\t\t\t\\\n\tiosys_map_wr_field(&(guc_)->ads_map, 0, struct __guc_ads_blob,\t\\\n\t\t\t   field_, val_)\n\n#define info_map_write(map_, field_, val_) \\\n\tiosys_map_wr_field(map_, 0, struct guc_gt_system_info, field_, val_)\n\n#define info_map_read(map_, field_) \\\n\tiosys_map_rd_field(map_, 0, struct guc_gt_system_info, field_)\n\nstatic u32 guc_ads_regset_size(struct intel_guc *guc)\n{\n\tGEM_BUG_ON(!guc->ads_regset_size);\n\treturn guc->ads_regset_size;\n}\n\nstatic u32 guc_ads_golden_ctxt_size(struct intel_guc *guc)\n{\n\treturn PAGE_ALIGN(guc->ads_golden_ctxt_size);\n}\n\nstatic u32 guc_ads_capture_size(struct intel_guc *guc)\n{\n\treturn PAGE_ALIGN(guc->ads_capture_size);\n}\n\nstatic u32 guc_ads_private_data_size(struct intel_guc *guc)\n{\n\treturn PAGE_ALIGN(guc->fw.private_data_size);\n}\n\nstatic u32 guc_ads_regset_offset(struct intel_guc *guc)\n{\n\treturn offsetof(struct __guc_ads_blob, regset);\n}\n\nstatic u32 guc_ads_golden_ctxt_offset(struct intel_guc *guc)\n{\n\tu32 offset;\n\n\toffset = guc_ads_regset_offset(guc) +\n\t\t guc_ads_regset_size(guc);\n\n\treturn PAGE_ALIGN(offset);\n}\n\nstatic u32 guc_ads_capture_offset(struct intel_guc *guc)\n{\n\tu32 offset;\n\n\toffset = guc_ads_golden_ctxt_offset(guc) +\n\t\t guc_ads_golden_ctxt_size(guc);\n\n\treturn PAGE_ALIGN(offset);\n}\n\nstatic u32 guc_ads_private_data_offset(struct intel_guc *guc)\n{\n\tu32 offset;\n\n\toffset = guc_ads_capture_offset(guc) +\n\t\t guc_ads_capture_size(guc);\n\n\treturn PAGE_ALIGN(offset);\n}\n\nstatic u32 guc_ads_blob_size(struct intel_guc *guc)\n{\n\treturn guc_ads_private_data_offset(guc) +\n\t       guc_ads_private_data_size(guc);\n}\n\nstatic void guc_policies_init(struct intel_guc *guc)\n{\n\tstruct intel_gt *gt = guc_to_gt(guc);\n\tstruct drm_i915_private *i915 = gt->i915;\n\tu32 global_flags = 0;\n\n\tads_blob_write(guc, policies.dpc_promote_time,\n\t\t       GLOBAL_POLICY_DEFAULT_DPC_PROMOTE_TIME_US);\n\tads_blob_write(guc, policies.max_num_work_items,\n\t\t       GLOBAL_POLICY_MAX_NUM_WI);\n\n\tif (i915->params.reset < 2)\n\t\tglobal_flags |= GLOBAL_POLICY_DISABLE_ENGINE_RESET;\n\n\tads_blob_write(guc, policies.global_flags, global_flags);\n\tads_blob_write(guc, policies.is_valid, 1);\n}\n\nvoid intel_guc_ads_print_policy_info(struct intel_guc *guc,\n\t\t\t\t     struct drm_printer *dp)\n{\n\tif (unlikely(iosys_map_is_null(&guc->ads_map)))\n\t\treturn;\n\n\tdrm_printf(dp, \"Global scheduling policies:\\n\");\n\tdrm_printf(dp, \"  DPC promote time   = %u\\n\",\n\t\t   ads_blob_read(guc, policies.dpc_promote_time));\n\tdrm_printf(dp, \"  Max num work items = %u\\n\",\n\t\t   ads_blob_read(guc, policies.max_num_work_items));\n\tdrm_printf(dp, \"  Flags              = %u\\n\",\n\t\t   ads_blob_read(guc, policies.global_flags));\n}\n\nstatic int guc_action_policies_update(struct intel_guc *guc, u32 policy_offset)\n{\n\tu32 action[] = {\n\t\tINTEL_GUC_ACTION_GLOBAL_SCHED_POLICY_CHANGE,\n\t\tpolicy_offset\n\t};\n\n\treturn intel_guc_send_busy_loop(guc, action, ARRAY_SIZE(action), 0, true);\n}\n\nint intel_guc_global_policies_update(struct intel_guc *guc)\n{\n\tstruct intel_gt *gt = guc_to_gt(guc);\n\tu32 scheduler_policies;\n\tintel_wakeref_t wakeref;\n\tint ret;\n\n\tif (iosys_map_is_null(&guc->ads_map))\n\t\treturn -EOPNOTSUPP;\n\n\tscheduler_policies = ads_blob_read(guc, ads.scheduler_policies);\n\tGEM_BUG_ON(!scheduler_policies);\n\n\tguc_policies_init(guc);\n\n\tif (!intel_guc_is_ready(guc))\n\t\treturn 0;\n\n\twith_intel_runtime_pm(&gt->i915->runtime_pm, wakeref)\n\t\tret = guc_action_policies_update(guc, scheduler_policies);\n\n\treturn ret;\n}\n\nstatic void guc_mapping_table_init(struct intel_gt *gt,\n\t\t\t\t   struct iosys_map *info_map)\n{\n\tunsigned int i, j;\n\tstruct intel_engine_cs *engine;\n\tenum intel_engine_id id;\n\n\t \n\tfor (i = 0; i < GUC_MAX_ENGINE_CLASSES; ++i)\n\t\tfor (j = 0; j < GUC_MAX_INSTANCES_PER_CLASS; ++j)\n\t\t\tinfo_map_write(info_map, mapping_table[i][j],\n\t\t\t\t       GUC_MAX_INSTANCES_PER_CLASS);\n\n\tfor_each_engine(engine, gt, id) {\n\t\tu8 guc_class = engine_class_to_guc_class(engine->class);\n\n\t\tinfo_map_write(info_map, mapping_table[guc_class][ilog2(engine->logical_mask)],\n\t\t\t       engine->instance);\n\t}\n}\n\n \nstruct temp_regset {\n\t \n\tstruct guc_mmio_reg *registers;\n\t \n\tstruct guc_mmio_reg *storage;\n\tu32 storage_used;\n\tu32 storage_max;\n};\n\nstatic int guc_mmio_reg_cmp(const void *a, const void *b)\n{\n\tconst struct guc_mmio_reg *ra = a;\n\tconst struct guc_mmio_reg *rb = b;\n\n\treturn (int)ra->offset - (int)rb->offset;\n}\n\nstatic struct guc_mmio_reg * __must_check\n__mmio_reg_add(struct temp_regset *regset, struct guc_mmio_reg *reg)\n{\n\tu32 pos = regset->storage_used;\n\tstruct guc_mmio_reg *slot;\n\n\tif (pos >= regset->storage_max) {\n\t\tsize_t size = ALIGN((pos + 1) * sizeof(*slot), PAGE_SIZE);\n\t\tstruct guc_mmio_reg *r = krealloc(regset->storage,\n\t\t\t\t\t\t  size, GFP_KERNEL);\n\t\tif (!r) {\n\t\t\tWARN_ONCE(1, \"Incomplete regset list: can't add register (%d)\\n\",\n\t\t\t\t  -ENOMEM);\n\t\t\treturn ERR_PTR(-ENOMEM);\n\t\t}\n\n\t\tregset->registers = r + (regset->registers - regset->storage);\n\t\tregset->storage = r;\n\t\tregset->storage_max = size / sizeof(*slot);\n\t}\n\n\tslot = &regset->storage[pos];\n\tregset->storage_used++;\n\t*slot = *reg;\n\n\treturn slot;\n}\n\nstatic long __must_check guc_mmio_reg_add(struct intel_gt *gt,\n\t\t\t\t\t  struct temp_regset *regset,\n\t\t\t\t\t  u32 offset, u32 flags)\n{\n\tu32 count = regset->storage_used - (regset->registers - regset->storage);\n\tstruct guc_mmio_reg entry = {\n\t\t.offset = offset,\n\t\t.flags = flags,\n\t};\n\tstruct guc_mmio_reg *slot;\n\n\t \n\tif (bsearch(&entry, regset->registers, count,\n\t\t    sizeof(entry), guc_mmio_reg_cmp))\n\t\treturn 0;\n\n\tslot = __mmio_reg_add(regset, &entry);\n\tif (IS_ERR(slot))\n\t\treturn PTR_ERR(slot);\n\n\twhile (slot-- > regset->registers) {\n\t\tGEM_BUG_ON(slot[0].offset == slot[1].offset);\n\t\tif (slot[1].offset > slot[0].offset)\n\t\t\tbreak;\n\n\t\tswap(slot[1], slot[0]);\n\t}\n\n\treturn 0;\n}\n\n#define GUC_MMIO_REG_ADD(gt, regset, reg, masked) \\\n\tguc_mmio_reg_add(gt, \\\n\t\t\t regset, \\\n\t\t\t i915_mmio_reg_offset(reg), \\\n\t\t\t (masked) ? GUC_REGSET_MASKED : 0)\n\n#define GUC_REGSET_STEERING(group, instance) ( \\\n\tFIELD_PREP(GUC_REGSET_STEERING_GROUP, (group)) | \\\n\tFIELD_PREP(GUC_REGSET_STEERING_INSTANCE, (instance)) | \\\n\tGUC_REGSET_NEEDS_STEERING \\\n)\n\nstatic long __must_check guc_mcr_reg_add(struct intel_gt *gt,\n\t\t\t\t\t struct temp_regset *regset,\n\t\t\t\t\t i915_mcr_reg_t reg, u32 flags)\n{\n\tu8 group, inst;\n\n\t \n\tintel_gt_mcr_get_nonterminated_steering(gt, reg, &group, &inst);\n\tflags |= GUC_REGSET_STEERING(group, inst);\n\n\treturn guc_mmio_reg_add(gt, regset, i915_mmio_reg_offset(reg), flags);\n}\n\n#define GUC_MCR_REG_ADD(gt, regset, reg, masked) \\\n\tguc_mcr_reg_add(gt, \\\n\t\t\t regset, \\\n\t\t\t (reg), \\\n\t\t\t (masked) ? GUC_REGSET_MASKED : 0)\n\nstatic int guc_mmio_regset_init(struct temp_regset *regset,\n\t\t\t\tstruct intel_engine_cs *engine)\n{\n\tstruct intel_gt *gt = engine->gt;\n\tconst u32 base = engine->mmio_base;\n\tstruct i915_wa_list *wal = &engine->wa_list;\n\tstruct i915_wa *wa;\n\tunsigned int i;\n\tint ret = 0;\n\n\t \n\tregset->registers = regset->storage + regset->storage_used;\n\n\tret |= GUC_MMIO_REG_ADD(gt, regset, RING_MODE_GEN7(base), true);\n\tret |= GUC_MMIO_REG_ADD(gt, regset, RING_HWS_PGA(base), false);\n\tret |= GUC_MMIO_REG_ADD(gt, regset, RING_IMR(base), false);\n\n\tif ((engine->flags & I915_ENGINE_FIRST_RENDER_COMPUTE) &&\n\t    CCS_MASK(engine->gt))\n\t\tret |= GUC_MMIO_REG_ADD(gt, regset, GEN12_RCU_MODE, true);\n\n\tfor (i = 0, wa = wal->list; i < wal->count; i++, wa++)\n\t\tret |= GUC_MMIO_REG_ADD(gt, regset, wa->reg, wa->masked_reg);\n\n\t \n\tfor (i = 0; i < RING_MAX_NONPRIV_SLOTS; i++)\n\t\tret |= GUC_MMIO_REG_ADD(gt, regset,\n\t\t\t\t\tRING_FORCE_TO_NONPRIV(base, i),\n\t\t\t\t\tfalse);\n\n\t \n\tfor (i = 0; i < LNCFCMOCS_REG_COUNT; i++)\n\t\tif (GRAPHICS_VER_FULL(engine->i915) >= IP_VER(12, 50))\n\t\t\tret |= GUC_MCR_REG_ADD(gt, regset, XEHP_LNCFCMOCS(i), false);\n\t\telse\n\t\t\tret |= GUC_MMIO_REG_ADD(gt, regset, GEN9_LNCFCMOCS(i), false);\n\n\tif (GRAPHICS_VER(engine->i915) >= 12) {\n\t\tret |= GUC_MMIO_REG_ADD(gt, regset, EU_PERF_CNTL0, false);\n\t\tret |= GUC_MMIO_REG_ADD(gt, regset, EU_PERF_CNTL1, false);\n\t\tret |= GUC_MMIO_REG_ADD(gt, regset, EU_PERF_CNTL2, false);\n\t\tret |= GUC_MMIO_REG_ADD(gt, regset, EU_PERF_CNTL3, false);\n\t\tret |= GUC_MMIO_REG_ADD(gt, regset, EU_PERF_CNTL4, false);\n\t\tret |= GUC_MMIO_REG_ADD(gt, regset, EU_PERF_CNTL5, false);\n\t\tret |= GUC_MMIO_REG_ADD(gt, regset, EU_PERF_CNTL6, false);\n\t}\n\n\treturn ret ? -1 : 0;\n}\n\nstatic long guc_mmio_reg_state_create(struct intel_guc *guc)\n{\n\tstruct intel_gt *gt = guc_to_gt(guc);\n\tstruct intel_engine_cs *engine;\n\tenum intel_engine_id id;\n\tstruct temp_regset temp_set = {};\n\tlong total = 0;\n\tlong ret;\n\n\tfor_each_engine(engine, gt, id) {\n\t\tu32 used = temp_set.storage_used;\n\n\t\tret = guc_mmio_regset_init(&temp_set, engine);\n\t\tif (ret < 0)\n\t\t\tgoto fail_regset_init;\n\n\t\tguc->ads_regset_count[id] = temp_set.storage_used - used;\n\t\ttotal += guc->ads_regset_count[id];\n\t}\n\n\tguc->ads_regset = temp_set.storage;\n\n\tguc_dbg(guc, \"Used %zu KB for temporary ADS regset\\n\",\n\t\t(temp_set.storage_max * sizeof(struct guc_mmio_reg)) >> 10);\n\n\treturn total * sizeof(struct guc_mmio_reg);\n\nfail_regset_init:\n\tkfree(temp_set.storage);\n\treturn ret;\n}\n\nstatic void guc_mmio_reg_state_init(struct intel_guc *guc)\n{\n\tstruct intel_gt *gt = guc_to_gt(guc);\n\tstruct intel_engine_cs *engine;\n\tenum intel_engine_id id;\n\tu32 addr_ggtt, offset;\n\n\toffset = guc_ads_regset_offset(guc);\n\taddr_ggtt = intel_guc_ggtt_offset(guc, guc->ads_vma) + offset;\n\n\tiosys_map_memcpy_to(&guc->ads_map, offset, guc->ads_regset,\n\t\t\t    guc->ads_regset_size);\n\n\tfor_each_engine(engine, gt, id) {\n\t\tu32 count = guc->ads_regset_count[id];\n\t\tu8 guc_class;\n\n\t\t \n\t\tGEM_BUG_ON(engine->instance >= GUC_MAX_INSTANCES_PER_CLASS);\n\n\t\tguc_class = engine_class_to_guc_class(engine->class);\n\n\t\tif (!count) {\n\t\t\tads_blob_write(guc,\n\t\t\t\t       ads.reg_state_list[guc_class][engine->instance].address,\n\t\t\t\t       0);\n\t\t\tads_blob_write(guc,\n\t\t\t\t       ads.reg_state_list[guc_class][engine->instance].count,\n\t\t\t\t       0);\n\t\t\tcontinue;\n\t\t}\n\n\t\tads_blob_write(guc,\n\t\t\t       ads.reg_state_list[guc_class][engine->instance].address,\n\t\t\t       addr_ggtt);\n\t\tads_blob_write(guc,\n\t\t\t       ads.reg_state_list[guc_class][engine->instance].count,\n\t\t\t       count);\n\n\t\taddr_ggtt += count * sizeof(struct guc_mmio_reg);\n\t}\n}\n\nstatic void fill_engine_enable_masks(struct intel_gt *gt,\n\t\t\t\t     struct iosys_map *info_map)\n{\n\tinfo_map_write(info_map, engine_enabled_masks[GUC_RENDER_CLASS], RCS_MASK(gt));\n\tinfo_map_write(info_map, engine_enabled_masks[GUC_COMPUTE_CLASS], CCS_MASK(gt));\n\tinfo_map_write(info_map, engine_enabled_masks[GUC_BLITTER_CLASS], BCS_MASK(gt));\n\tinfo_map_write(info_map, engine_enabled_masks[GUC_VIDEO_CLASS], VDBOX_MASK(gt));\n\tinfo_map_write(info_map, engine_enabled_masks[GUC_VIDEOENHANCE_CLASS], VEBOX_MASK(gt));\n\n\t \n\tif (gt->engine[GSC0])\n\t\tinfo_map_write(info_map, engine_enabled_masks[GUC_GSC_OTHER_CLASS],\n\t\t\t       BIT(gt->engine[GSC0]->instance));\n}\n\n#define LR_HW_CONTEXT_SIZE (80 * sizeof(u32))\n#define XEHP_LR_HW_CONTEXT_SIZE (96 * sizeof(u32))\n#define LR_HW_CONTEXT_SZ(i915) (GRAPHICS_VER_FULL(i915) >= IP_VER(12, 50) ? \\\n\t\t\t\t    XEHP_LR_HW_CONTEXT_SIZE : \\\n\t\t\t\t    LR_HW_CONTEXT_SIZE)\n#define LRC_SKIP_SIZE(i915) (LRC_PPHWSP_SZ * PAGE_SIZE + LR_HW_CONTEXT_SZ(i915))\nstatic int guc_prep_golden_context(struct intel_guc *guc)\n{\n\tstruct intel_gt *gt = guc_to_gt(guc);\n\tu32 addr_ggtt, offset;\n\tu32 total_size = 0, alloc_size, real_size;\n\tu8 engine_class, guc_class;\n\tstruct guc_gt_system_info local_info;\n\tstruct iosys_map info_map;\n\n\t \n\tif (!iosys_map_is_null(&guc->ads_map)) {\n\t\toffset = guc_ads_golden_ctxt_offset(guc);\n\t\taddr_ggtt = intel_guc_ggtt_offset(guc, guc->ads_vma) + offset;\n\t\tinfo_map = IOSYS_MAP_INIT_OFFSET(&guc->ads_map,\n\t\t\t\t\t\t offsetof(struct __guc_ads_blob, system_info));\n\t} else {\n\t\tmemset(&local_info, 0, sizeof(local_info));\n\t\tiosys_map_set_vaddr(&info_map, &local_info);\n\t\tfill_engine_enable_masks(gt, &info_map);\n\t}\n\n\tfor (engine_class = 0; engine_class <= MAX_ENGINE_CLASS; ++engine_class) {\n\t\tguc_class = engine_class_to_guc_class(engine_class);\n\n\t\tif (!info_map_read(&info_map, engine_enabled_masks[guc_class]))\n\t\t\tcontinue;\n\n\t\treal_size = intel_engine_context_size(gt, engine_class);\n\t\talloc_size = PAGE_ALIGN(real_size);\n\t\ttotal_size += alloc_size;\n\n\t\tif (iosys_map_is_null(&guc->ads_map))\n\t\t\tcontinue;\n\n\t\t \n\t\tads_blob_write(guc, ads.eng_state_size[guc_class],\n\t\t\t       real_size - LRC_SKIP_SIZE(gt->i915));\n\t\tads_blob_write(guc, ads.golden_context_lrca[guc_class],\n\t\t\t       addr_ggtt);\n\n\t\taddr_ggtt += alloc_size;\n\t}\n\n\t \n\tif (guc->ads_golden_ctxt_size)\n\t\tGEM_BUG_ON(guc->ads_golden_ctxt_size != total_size);\n\n\treturn total_size;\n}\n\nstatic struct intel_engine_cs *find_engine_state(struct intel_gt *gt, u8 engine_class)\n{\n\tstruct intel_engine_cs *engine;\n\tenum intel_engine_id id;\n\n\tfor_each_engine(engine, gt, id) {\n\t\tif (engine->class != engine_class)\n\t\t\tcontinue;\n\n\t\tif (!engine->default_state)\n\t\t\tcontinue;\n\n\t\treturn engine;\n\t}\n\n\treturn NULL;\n}\n\nstatic void guc_init_golden_context(struct intel_guc *guc)\n{\n\tstruct intel_engine_cs *engine;\n\tstruct intel_gt *gt = guc_to_gt(guc);\n\tunsigned long offset;\n\tu32 addr_ggtt, total_size = 0, alloc_size, real_size;\n\tu8 engine_class, guc_class;\n\n\tif (!intel_uc_uses_guc_submission(&gt->uc))\n\t\treturn;\n\n\tGEM_BUG_ON(iosys_map_is_null(&guc->ads_map));\n\n\t \n\toffset = guc_ads_golden_ctxt_offset(guc);\n\taddr_ggtt = intel_guc_ggtt_offset(guc, guc->ads_vma) + offset;\n\n\tfor (engine_class = 0; engine_class <= MAX_ENGINE_CLASS; ++engine_class) {\n\t\tguc_class = engine_class_to_guc_class(engine_class);\n\t\tif (!ads_blob_read(guc, system_info.engine_enabled_masks[guc_class]))\n\t\t\tcontinue;\n\n\t\treal_size = intel_engine_context_size(gt, engine_class);\n\t\talloc_size = PAGE_ALIGN(real_size);\n\t\ttotal_size += alloc_size;\n\n\t\tengine = find_engine_state(gt, engine_class);\n\t\tif (!engine) {\n\t\t\tguc_err(guc, \"No engine state recorded for class %d!\\n\",\n\t\t\t\tengine_class);\n\t\t\tads_blob_write(guc, ads.eng_state_size[guc_class], 0);\n\t\t\tads_blob_write(guc, ads.golden_context_lrca[guc_class], 0);\n\t\t\tcontinue;\n\t\t}\n\n\t\tGEM_BUG_ON(ads_blob_read(guc, ads.eng_state_size[guc_class]) !=\n\t\t\t   real_size - LRC_SKIP_SIZE(gt->i915));\n\t\tGEM_BUG_ON(ads_blob_read(guc, ads.golden_context_lrca[guc_class]) != addr_ggtt);\n\n\t\taddr_ggtt += alloc_size;\n\n\t\tshmem_read_to_iosys_map(engine->default_state, 0, &guc->ads_map,\n\t\t\t\t\toffset, real_size);\n\t\toffset += alloc_size;\n\t}\n\n\tGEM_BUG_ON(guc->ads_golden_ctxt_size != total_size);\n}\n\nstatic u32 guc_get_capture_engine_mask(struct iosys_map *info_map, u32 capture_class)\n{\n\tu32 mask;\n\n\tswitch (capture_class) {\n\tcase GUC_CAPTURE_LIST_CLASS_RENDER_COMPUTE:\n\t\tmask = info_map_read(info_map, engine_enabled_masks[GUC_RENDER_CLASS]);\n\t\tmask |= info_map_read(info_map, engine_enabled_masks[GUC_COMPUTE_CLASS]);\n\t\tbreak;\n\n\tcase GUC_CAPTURE_LIST_CLASS_VIDEO:\n\t\tmask = info_map_read(info_map, engine_enabled_masks[GUC_VIDEO_CLASS]);\n\t\tbreak;\n\n\tcase GUC_CAPTURE_LIST_CLASS_VIDEOENHANCE:\n\t\tmask = info_map_read(info_map, engine_enabled_masks[GUC_VIDEOENHANCE_CLASS]);\n\t\tbreak;\n\n\tcase GUC_CAPTURE_LIST_CLASS_BLITTER:\n\t\tmask = info_map_read(info_map, engine_enabled_masks[GUC_BLITTER_CLASS]);\n\t\tbreak;\n\n\tcase GUC_CAPTURE_LIST_CLASS_GSC_OTHER:\n\t\tmask = info_map_read(info_map, engine_enabled_masks[GUC_GSC_OTHER_CLASS]);\n\t\tbreak;\n\n\tdefault:\n\t\tmask = 0;\n\t}\n\n\treturn mask;\n}\n\nstatic int\nguc_capture_prep_lists(struct intel_guc *guc)\n{\n\tstruct intel_gt *gt = guc_to_gt(guc);\n\tu32 ads_ggtt, capture_offset, null_ggtt, total_size = 0;\n\tstruct guc_gt_system_info local_info;\n\tstruct iosys_map info_map;\n\tbool ads_is_mapped;\n\tsize_t size = 0;\n\tvoid *ptr;\n\tint i, j;\n\n\tads_is_mapped = !iosys_map_is_null(&guc->ads_map);\n\tif (ads_is_mapped) {\n\t\tcapture_offset = guc_ads_capture_offset(guc);\n\t\tads_ggtt = intel_guc_ggtt_offset(guc, guc->ads_vma);\n\t\tinfo_map = IOSYS_MAP_INIT_OFFSET(&guc->ads_map,\n\t\t\t\t\t\t offsetof(struct __guc_ads_blob, system_info));\n\t} else {\n\t\tmemset(&local_info, 0, sizeof(local_info));\n\t\tiosys_map_set_vaddr(&info_map, &local_info);\n\t\tfill_engine_enable_masks(gt, &info_map);\n\t}\n\n\t \n\ttotal_size = PAGE_SIZE;\n\tif (ads_is_mapped) {\n\t\tif (!intel_guc_capture_getnullheader(guc, &ptr, &size))\n\t\t\tiosys_map_memcpy_to(&guc->ads_map, capture_offset, ptr, size);\n\t\tnull_ggtt = ads_ggtt + capture_offset;\n\t\tcapture_offset += PAGE_SIZE;\n\t}\n\n\tfor (i = 0; i < GUC_CAPTURE_LIST_INDEX_MAX; i++) {\n\t\tfor (j = 0; j < GUC_MAX_ENGINE_CLASSES; j++) {\n\t\t\tu32 engine_mask = guc_get_capture_engine_mask(&info_map, j);\n\n\t\t\t \n\t\t\tif (!engine_mask) {\n\t\t\t\tif (ads_is_mapped) {\n\t\t\t\t\tads_blob_write(guc, ads.capture_class[i][j], null_ggtt);\n\t\t\t\t\tads_blob_write(guc, ads.capture_instance[i][j], null_ggtt);\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (intel_guc_capture_getlistsize(guc, i,\n\t\t\t\t\t\t\t  GUC_CAPTURE_LIST_TYPE_ENGINE_CLASS,\n\t\t\t\t\t\t\t  j, &size)) {\n\t\t\t\tif (ads_is_mapped)\n\t\t\t\t\tads_blob_write(guc, ads.capture_class[i][j], null_ggtt);\n\t\t\t\tgoto engine_instance_list;\n\t\t\t}\n\t\t\ttotal_size += size;\n\t\t\tif (ads_is_mapped) {\n\t\t\t\tif (total_size > guc->ads_capture_size ||\n\t\t\t\t    intel_guc_capture_getlist(guc, i,\n\t\t\t\t\t\t\t      GUC_CAPTURE_LIST_TYPE_ENGINE_CLASS,\n\t\t\t\t\t\t\t      j, &ptr)) {\n\t\t\t\t\tads_blob_write(guc, ads.capture_class[i][j], null_ggtt);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tads_blob_write(guc, ads.capture_class[i][j], ads_ggtt +\n\t\t\t\t\t       capture_offset);\n\t\t\t\tiosys_map_memcpy_to(&guc->ads_map, capture_offset, ptr, size);\n\t\t\t\tcapture_offset += size;\n\t\t\t}\nengine_instance_list:\n\t\t\tif (intel_guc_capture_getlistsize(guc, i,\n\t\t\t\t\t\t\t  GUC_CAPTURE_LIST_TYPE_ENGINE_INSTANCE,\n\t\t\t\t\t\t\t  j, &size)) {\n\t\t\t\tif (ads_is_mapped)\n\t\t\t\t\tads_blob_write(guc, ads.capture_instance[i][j], null_ggtt);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\ttotal_size += size;\n\t\t\tif (ads_is_mapped) {\n\t\t\t\tif (total_size > guc->ads_capture_size ||\n\t\t\t\t    intel_guc_capture_getlist(guc, i,\n\t\t\t\t\t\t\t      GUC_CAPTURE_LIST_TYPE_ENGINE_INSTANCE,\n\t\t\t\t\t\t\t      j, &ptr)) {\n\t\t\t\t\tads_blob_write(guc, ads.capture_instance[i][j], null_ggtt);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tads_blob_write(guc, ads.capture_instance[i][j], ads_ggtt +\n\t\t\t\t\t       capture_offset);\n\t\t\t\tiosys_map_memcpy_to(&guc->ads_map, capture_offset, ptr, size);\n\t\t\t\tcapture_offset += size;\n\t\t\t}\n\t\t}\n\t\tif (intel_guc_capture_getlistsize(guc, i, GUC_CAPTURE_LIST_TYPE_GLOBAL, 0, &size)) {\n\t\t\tif (ads_is_mapped)\n\t\t\t\tads_blob_write(guc, ads.capture_global[i], null_ggtt);\n\t\t\tcontinue;\n\t\t}\n\t\ttotal_size += size;\n\t\tif (ads_is_mapped) {\n\t\t\tif (total_size > guc->ads_capture_size ||\n\t\t\t    intel_guc_capture_getlist(guc, i, GUC_CAPTURE_LIST_TYPE_GLOBAL, 0,\n\t\t\t\t\t\t      &ptr)) {\n\t\t\t\tads_blob_write(guc, ads.capture_global[i], null_ggtt);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tads_blob_write(guc, ads.capture_global[i], ads_ggtt + capture_offset);\n\t\t\tiosys_map_memcpy_to(&guc->ads_map, capture_offset, ptr, size);\n\t\t\tcapture_offset += size;\n\t\t}\n\t}\n\n\tif (guc->ads_capture_size && guc->ads_capture_size != PAGE_ALIGN(total_size))\n\t\tguc_warn(guc, \"ADS capture alloc size changed from %d to %d\\n\",\n\t\t\t guc->ads_capture_size, PAGE_ALIGN(total_size));\n\n\treturn PAGE_ALIGN(total_size);\n}\n\nstatic void __guc_ads_init(struct intel_guc *guc)\n{\n\tstruct intel_gt *gt = guc_to_gt(guc);\n\tstruct drm_i915_private *i915 = gt->i915;\n\tstruct iosys_map info_map = IOSYS_MAP_INIT_OFFSET(&guc->ads_map,\n\t\t\toffsetof(struct __guc_ads_blob, system_info));\n\tu32 base;\n\n\t \n\tguc_policies_init(guc);\n\n\t \n\tfill_engine_enable_masks(gt, &info_map);\n\n\tads_blob_write(guc, system_info.generic_gt_sysinfo[GUC_GENERIC_GT_SYSINFO_SLICE_ENABLED],\n\t\t       hweight8(gt->info.sseu.slice_mask));\n\tads_blob_write(guc, system_info.generic_gt_sysinfo[GUC_GENERIC_GT_SYSINFO_VDBOX_SFC_SUPPORT_MASK],\n\t\t       gt->info.vdbox_sfc_access);\n\n\tif (GRAPHICS_VER(i915) >= 12 && !IS_DGFX(i915)) {\n\t\tu32 distdbreg = intel_uncore_read(gt->uncore,\n\t\t\t\t\t\t  GEN12_DIST_DBS_POPULATED);\n\t\tads_blob_write(guc,\n\t\t\t       system_info.generic_gt_sysinfo[GUC_GENERIC_GT_SYSINFO_DOORBELL_COUNT_PER_SQIDI],\n\t\t\t       ((distdbreg >> GEN12_DOORBELLS_PER_SQIDI_SHIFT)\n\t\t\t\t& GEN12_DOORBELLS_PER_SQIDI) + 1);\n\t}\n\n\t \n\tguc_prep_golden_context(guc);\n\n\tguc_mapping_table_init(guc_to_gt(guc), &info_map);\n\n\tbase = intel_guc_ggtt_offset(guc, guc->ads_vma);\n\n\t \n\tguc_capture_prep_lists(guc);\n\n\t \n\tads_blob_write(guc, ads.scheduler_policies, base +\n\t\t       offsetof(struct __guc_ads_blob, policies));\n\tads_blob_write(guc, ads.gt_system_info, base +\n\t\t       offsetof(struct __guc_ads_blob, system_info));\n\n\t \n\tguc_mmio_reg_state_init(guc);\n\n\t \n\tads_blob_write(guc, ads.private_data, base +\n\t\t       guc_ads_private_data_offset(guc));\n\n\ti915_gem_object_flush_map(guc->ads_vma->obj);\n}\n\n \nint intel_guc_ads_create(struct intel_guc *guc)\n{\n\tvoid *ads_blob;\n\tu32 size;\n\tint ret;\n\n\tGEM_BUG_ON(guc->ads_vma);\n\n\t \n\tret = guc_mmio_reg_state_create(guc);\n\tif (ret < 0)\n\t\treturn ret;\n\tguc->ads_regset_size = ret;\n\n\t \n\tret = guc_prep_golden_context(guc);\n\tif (ret < 0)\n\t\treturn ret;\n\tguc->ads_golden_ctxt_size = ret;\n\n\t \n\tret = guc_capture_prep_lists(guc);\n\tif (ret < 0)\n\t\treturn ret;\n\tguc->ads_capture_size = ret;\n\n\t \n\tsize = guc_ads_blob_size(guc);\n\n\tret = intel_guc_allocate_and_map_vma(guc, size, &guc->ads_vma,\n\t\t\t\t\t     &ads_blob);\n\tif (ret)\n\t\treturn ret;\n\n\tif (i915_gem_object_is_lmem(guc->ads_vma->obj))\n\t\tiosys_map_set_vaddr_iomem(&guc->ads_map, (void __iomem *)ads_blob);\n\telse\n\t\tiosys_map_set_vaddr(&guc->ads_map, ads_blob);\n\n\t__guc_ads_init(guc);\n\n\treturn 0;\n}\n\nvoid intel_guc_ads_init_late(struct intel_guc *guc)\n{\n\t \n\tguc_init_golden_context(guc);\n}\n\nvoid intel_guc_ads_destroy(struct intel_guc *guc)\n{\n\ti915_vma_unpin_and_release(&guc->ads_vma, I915_VMA_RELEASE_MAP);\n\tiosys_map_clear(&guc->ads_map);\n\tkfree(guc->ads_regset);\n}\n\nstatic void guc_ads_private_data_reset(struct intel_guc *guc)\n{\n\tu32 size;\n\n\tsize = guc_ads_private_data_size(guc);\n\tif (!size)\n\t\treturn;\n\n\tiosys_map_memset(&guc->ads_map, guc_ads_private_data_offset(guc),\n\t\t\t 0, size);\n}\n\n \nvoid intel_guc_ads_reset(struct intel_guc *guc)\n{\n\tif (!guc->ads_vma)\n\t\treturn;\n\n\t__guc_ads_init(guc);\n\n\tguc_ads_private_data_reset(guc);\n}\n\nu32 intel_guc_engine_usage_offset(struct intel_guc *guc)\n{\n\treturn intel_guc_ggtt_offset(guc, guc->ads_vma) +\n\t\toffsetof(struct __guc_ads_blob, engine_usage);\n}\n\nstruct iosys_map intel_guc_engine_usage_record_map(struct intel_engine_cs *engine)\n{\n\tstruct intel_guc *guc = &engine->gt->uc.guc;\n\tu8 guc_class = engine_class_to_guc_class(engine->class);\n\tsize_t offset = offsetof(struct __guc_ads_blob,\n\t\t\t\t engine_usage.engines[guc_class][ilog2(engine->logical_mask)]);\n\n\treturn IOSYS_MAP_INIT_OFFSET(&guc->ads_map, offset);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}