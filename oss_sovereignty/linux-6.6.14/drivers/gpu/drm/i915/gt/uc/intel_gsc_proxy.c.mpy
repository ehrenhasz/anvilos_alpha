{
  "module_name": "intel_gsc_proxy.c",
  "hash_id": "30d6473e73e3cd7bcf2978a9f8025307bbeb8d42d4e629e134bc193d8160e3e1",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/i915/gt/uc/intel_gsc_proxy.c",
  "human_readable_source": "\n \n\n#include <linux/component.h>\n\n#include <drm/i915_component.h>\n#include <drm/i915_gsc_proxy_mei_interface.h>\n\n#include \"gt/intel_gt.h\"\n#include \"gt/intel_gt_print.h\"\n#include \"intel_gsc_proxy.h\"\n#include \"intel_gsc_uc.h\"\n#include \"intel_gsc_uc_heci_cmd_submit.h\"\n#include \"i915_drv.h\"\n#include \"i915_reg.h\"\n\n \n\n \n#define GSC_PROXY_INIT_TIMEOUT_MS 20000\n\n \n#define GSC_PROXY_BUFFER_SIZE SZ_32K\n#define GSC_PROXY_CHANNEL_SIZE (GSC_PROXY_BUFFER_SIZE * 2)\n#define GSC_PROXY_MAX_MSG_SIZE (GSC_PROXY_BUFFER_SIZE - sizeof(struct intel_gsc_mtl_header))\n\n \nstruct intel_gsc_proxy_header {\n\t \n\tu32 hdr;\n#define GSC_PROXY_TYPE\t\t GENMASK(7, 0)\n#define GSC_PROXY_PAYLOAD_LENGTH GENMASK(31, 16)\n\n\tu32 source;\t\t \n\tu32 destination;\t \n#define GSC_PROXY_ADDRESSING_KMD  0x10000\n#define GSC_PROXY_ADDRESSING_GSC  0x20000\n#define GSC_PROXY_ADDRESSING_CSME 0x30000\n\n\tu32 status;\t\t \n} __packed;\n\n \nenum intel_gsc_proxy_type {\n\tGSC_PROXY_MSG_TYPE_PROXY_INVALID = 0,\n\tGSC_PROXY_MSG_TYPE_PROXY_QUERY = 1,\n\tGSC_PROXY_MSG_TYPE_PROXY_PAYLOAD = 2,\n\tGSC_PROXY_MSG_TYPE_PROXY_END = 3,\n\tGSC_PROXY_MSG_TYPE_PROXY_NOTIFICATION = 4,\n};\n\nstruct gsc_proxy_msg {\n\tstruct intel_gsc_mtl_header header;\n\tstruct intel_gsc_proxy_header proxy_header;\n} __packed;\n\nstatic int proxy_send_to_csme(struct intel_gsc_uc *gsc)\n{\n\tstruct intel_gt *gt = gsc_uc_to_gt(gsc);\n\tstruct i915_gsc_proxy_component *comp = gsc->proxy.component;\n\tstruct intel_gsc_mtl_header *hdr;\n\tvoid *in = gsc->proxy.to_csme;\n\tvoid *out = gsc->proxy.to_gsc;\n\tu32 in_size;\n\tint ret;\n\n\t \n\thdr = in;\n\tin += sizeof(struct intel_gsc_mtl_header);\n\tout += sizeof(struct intel_gsc_mtl_header);\n\n\tin_size = hdr->message_size - sizeof(struct intel_gsc_mtl_header);\n\n\t \n\tif (in_size < sizeof(struct intel_gsc_proxy_header) ||\n\t    in_size > GSC_PROXY_MAX_MSG_SIZE) {\n\t\tgt_err(gt, \"Invalid CSME message size: %u\\n\", in_size);\n\t\treturn -EINVAL;\n\t}\n\n\tret = comp->ops->send(comp->mei_dev, in, in_size);\n\tif (ret < 0) {\n\t\tgt_err(gt, \"Failed to send CSME message\\n\");\n\t\treturn ret;\n\t}\n\n\tret = comp->ops->recv(comp->mei_dev, out, GSC_PROXY_MAX_MSG_SIZE);\n\tif (ret < 0) {\n\t\tgt_err(gt, \"Failed to receive CSME message\\n\");\n\t\treturn ret;\n\t}\n\n\treturn ret;\n}\n\nstatic int proxy_send_to_gsc(struct intel_gsc_uc *gsc)\n{\n\tstruct intel_gt *gt = gsc_uc_to_gt(gsc);\n\tu32 *marker = gsc->proxy.to_csme;  \n\tu64 addr_in = i915_ggtt_offset(gsc->proxy.vma);\n\tu64 addr_out = addr_in + GSC_PROXY_BUFFER_SIZE;\n\tu32 size = ((struct gsc_proxy_msg *)gsc->proxy.to_gsc)->header.message_size;\n\tint err;\n\n\t \n\tif (size < sizeof(struct gsc_proxy_msg) || size > GSC_PROXY_BUFFER_SIZE) {\n\t\tgt_err(gt, \"Invalid GSC proxy message size: %u\\n\", size);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\t*marker = 0;\n\n\t \n\twmb();\n\n\t \n\terr = intel_gsc_uc_heci_cmd_submit_packet(gsc, addr_in, size,\n\t\t\t\t\t\t  addr_out, GSC_PROXY_BUFFER_SIZE);\n\n\tif (!err) {\n\t\t \n\t\terr = wait_for(*marker != 0, 300);\n\t\tif (err)\n\t\t\tgt_err(gt, \"Failed to get a proxy reply from gsc\\n\");\n\t}\n\n\treturn err;\n}\n\nstatic int validate_proxy_header(struct intel_gsc_proxy_header *header,\n\t\t\t\t u32 source, u32 dest)\n{\n\tu32 type = FIELD_GET(GSC_PROXY_TYPE, header->hdr);\n\tu32 length = FIELD_GET(GSC_PROXY_PAYLOAD_LENGTH, header->hdr);\n\tint ret = 0;\n\n\tif (header->destination != dest || header->source != source) {\n\t\tret = -ENOEXEC;\n\t\tgoto fail;\n\t}\n\n\tswitch (type) {\n\tcase GSC_PROXY_MSG_TYPE_PROXY_PAYLOAD:\n\t\tif (length > 0)\n\t\t\tbreak;\n\t\tfallthrough;\n\tcase GSC_PROXY_MSG_TYPE_PROXY_INVALID:\n\t\tret = -EIO;\n\t\tgoto fail;\n\tdefault:\n\t\tbreak;\n\t}\n\nfail:\n\treturn ret;\n}\n\nstatic int proxy_query(struct intel_gsc_uc *gsc)\n{\n\tstruct intel_gt *gt = gsc_uc_to_gt(gsc);\n\tstruct gsc_proxy_msg *to_gsc = gsc->proxy.to_gsc;\n\tstruct gsc_proxy_msg *to_csme = gsc->proxy.to_csme;\n\tint ret;\n\n\tintel_gsc_uc_heci_cmd_emit_mtl_header(&to_gsc->header,\n\t\t\t\t\t      HECI_MEADDRESS_PROXY,\n\t\t\t\t\t      sizeof(struct gsc_proxy_msg),\n\t\t\t\t\t      0);\n\n\tto_gsc->proxy_header.hdr =\n\t\tFIELD_PREP(GSC_PROXY_TYPE, GSC_PROXY_MSG_TYPE_PROXY_QUERY) |\n\t\tFIELD_PREP(GSC_PROXY_PAYLOAD_LENGTH, 0);\n\n\tto_gsc->proxy_header.source = GSC_PROXY_ADDRESSING_KMD;\n\tto_gsc->proxy_header.destination = GSC_PROXY_ADDRESSING_GSC;\n\tto_gsc->proxy_header.status = 0;\n\n\twhile (1) {\n\t\t \n\t\tmemset(gsc->proxy.to_csme, 0, sizeof(struct gsc_proxy_msg));\n\n\t\t \n\t\tret = proxy_send_to_gsc(gsc);\n\t\tif (ret) {\n\t\t\tgt_err(gt, \"failed to send proxy message to GSC! %d\\n\", ret);\n\t\t\tgoto proxy_error;\n\t\t}\n\n\t\t \n\t\tif (FIELD_GET(GSC_PROXY_TYPE, to_csme->proxy_header.hdr) ==\n\t\t\t\tGSC_PROXY_MSG_TYPE_PROXY_END)\n\t\t\tbreak;\n\n\t\t \n\t\tret = validate_proxy_header(&to_csme->proxy_header,\n\t\t\t\t\t    GSC_PROXY_ADDRESSING_GSC,\n\t\t\t\t\t    GSC_PROXY_ADDRESSING_CSME);\n\t\tif (ret) {\n\t\t\tgt_err(gt, \"invalid GSC to CSME proxy header! %d\\n\", ret);\n\t\t\tgoto proxy_error;\n\t\t}\n\n\t\t \n\t\tret = proxy_send_to_csme(gsc);\n\t\tif (ret < 0) {\n\t\t\tgt_err(gt, \"failed to send proxy message to CSME! %d\\n\", ret);\n\t\t\tgoto proxy_error;\n\t\t}\n\n\t\t \n\t\tto_gsc->header.message_size = ret + sizeof(struct intel_gsc_mtl_header);\n\n\t\t \n\t\tret = validate_proxy_header(&to_gsc->proxy_header,\n\t\t\t\t\t    GSC_PROXY_ADDRESSING_CSME,\n\t\t\t\t\t    GSC_PROXY_ADDRESSING_GSC);\n\t\tif (ret) {\n\t\t\tgt_err(gt, \"invalid CSME to GSC proxy header! %d\\n\", ret);\n\t\t\tgoto proxy_error;\n\t\t}\n\t}\n\nproxy_error:\n\treturn ret < 0 ? ret : 0;\n}\n\nint intel_gsc_proxy_request_handler(struct intel_gsc_uc *gsc)\n{\n\tstruct intel_gt *gt = gsc_uc_to_gt(gsc);\n\tint err;\n\n\tif (!gsc->proxy.component_added)\n\t\treturn -ENODEV;\n\n\tassert_rpm_wakelock_held(gt->uncore->rpm);\n\n\t \n\terr = wait_for(gsc->proxy.component, GSC_PROXY_INIT_TIMEOUT_MS);\n\tif (err) {\n\t\tgt_err(gt, \"GSC proxy component didn't bind within the expected timeout\\n\");\n\t\treturn -EIO;\n\t}\n\n\tmutex_lock(&gsc->proxy.mutex);\n\tif (!gsc->proxy.component) {\n\t\tgt_err(gt, \"GSC proxy worker called without the component being bound!\\n\");\n\t\terr = -EIO;\n\t} else {\n\t\t \n\t\tintel_uncore_rmw(gt->uncore, HECI_H_CSR(MTL_GSC_HECI2_BASE),\n\t\t\t\t HECI_H_CSR_RST, HECI_H_CSR_IS);\n\t\terr = proxy_query(gsc);\n\t}\n\tmutex_unlock(&gsc->proxy.mutex);\n\treturn err;\n}\n\nvoid intel_gsc_proxy_irq_handler(struct intel_gsc_uc *gsc, u32 iir)\n{\n\tstruct intel_gt *gt = gsc_uc_to_gt(gsc);\n\n\tif (unlikely(!iir))\n\t\treturn;\n\n\tlockdep_assert_held(gt->irq_lock);\n\n\tif (!gsc->proxy.component) {\n\t\tgt_err(gt, \"GSC proxy irq received without the component being bound!\\n\");\n\t\treturn;\n\t}\n\n\tgsc->gsc_work_actions |= GSC_ACTION_SW_PROXY;\n\tqueue_work(gsc->wq, &gsc->work);\n}\n\nstatic int i915_gsc_proxy_component_bind(struct device *i915_kdev,\n\t\t\t\t\t struct device *mei_kdev, void *data)\n{\n\tstruct drm_i915_private *i915 = kdev_to_i915(i915_kdev);\n\tstruct intel_gt *gt = i915->media_gt;\n\tstruct intel_gsc_uc *gsc = &gt->uc.gsc;\n\tintel_wakeref_t wakeref;\n\n\t \n\twith_intel_runtime_pm(&i915->runtime_pm, wakeref)\n\t\tintel_uncore_rmw(gt->uncore, HECI_H_CSR(MTL_GSC_HECI2_BASE),\n\t\t\t\t HECI_H_CSR_RST, HECI_H_CSR_IE);\n\n\tmutex_lock(&gsc->proxy.mutex);\n\tgsc->proxy.component = data;\n\tgsc->proxy.component->mei_dev = mei_kdev;\n\tmutex_unlock(&gsc->proxy.mutex);\n\n\treturn 0;\n}\n\nstatic void i915_gsc_proxy_component_unbind(struct device *i915_kdev,\n\t\t\t\t\t    struct device *mei_kdev, void *data)\n{\n\tstruct drm_i915_private *i915 = kdev_to_i915(i915_kdev);\n\tstruct intel_gt *gt = i915->media_gt;\n\tstruct intel_gsc_uc *gsc = &gt->uc.gsc;\n\tintel_wakeref_t wakeref;\n\n\tmutex_lock(&gsc->proxy.mutex);\n\tgsc->proxy.component = NULL;\n\tmutex_unlock(&gsc->proxy.mutex);\n\n\t \n\twith_intel_runtime_pm(&i915->runtime_pm, wakeref)\n\t\tintel_uncore_rmw(gt->uncore, HECI_H_CSR(MTL_GSC_HECI2_BASE),\n\t\t\t\t HECI_H_CSR_IE | HECI_H_CSR_RST, 0);\n}\n\nstatic const struct component_ops i915_gsc_proxy_component_ops = {\n\t.bind   = i915_gsc_proxy_component_bind,\n\t.unbind = i915_gsc_proxy_component_unbind,\n};\n\nstatic int proxy_channel_alloc(struct intel_gsc_uc *gsc)\n{\n\tstruct intel_gt *gt = gsc_uc_to_gt(gsc);\n\tstruct i915_vma *vma;\n\tvoid *vaddr;\n\tint err;\n\n\terr = intel_guc_allocate_and_map_vma(&gt->uc.guc, GSC_PROXY_CHANNEL_SIZE,\n\t\t\t\t\t     &vma, &vaddr);\n\tif (err)\n\t\treturn err;\n\n\tgsc->proxy.vma = vma;\n\tgsc->proxy.to_gsc = vaddr;\n\tgsc->proxy.to_csme = vaddr + GSC_PROXY_BUFFER_SIZE;\n\n\treturn 0;\n}\n\nstatic void proxy_channel_free(struct intel_gsc_uc *gsc)\n{\n\tif (!gsc->proxy.vma)\n\t\treturn;\n\n\tgsc->proxy.to_gsc = NULL;\n\tgsc->proxy.to_csme = NULL;\n\ti915_vma_unpin_and_release(&gsc->proxy.vma, I915_VMA_RELEASE_MAP);\n}\n\nvoid intel_gsc_proxy_fini(struct intel_gsc_uc *gsc)\n{\n\tstruct intel_gt *gt = gsc_uc_to_gt(gsc);\n\tstruct drm_i915_private *i915 = gt->i915;\n\n\tif (fetch_and_zero(&gsc->proxy.component_added))\n\t\tcomponent_del(i915->drm.dev, &i915_gsc_proxy_component_ops);\n\n\tproxy_channel_free(gsc);\n}\n\nint intel_gsc_proxy_init(struct intel_gsc_uc *gsc)\n{\n\tint err;\n\tstruct intel_gt *gt = gsc_uc_to_gt(gsc);\n\tstruct drm_i915_private *i915 = gt->i915;\n\n\tmutex_init(&gsc->proxy.mutex);\n\n\tif (!IS_ENABLED(CONFIG_INTEL_MEI_GSC_PROXY)) {\n\t\tgt_info(gt, \"can't init GSC proxy due to missing mei component\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\terr = proxy_channel_alloc(gsc);\n\tif (err)\n\t\treturn err;\n\n\terr = component_add_typed(i915->drm.dev, &i915_gsc_proxy_component_ops,\n\t\t\t\t  I915_COMPONENT_GSC_PROXY);\n\tif (err < 0) {\n\t\tgt_err(gt, \"Failed to add GSC_PROXY component (%d)\\n\", err);\n\t\tgoto out_free;\n\t}\n\n\tgsc->proxy.component_added = true;\n\n\treturn 0;\n\nout_free:\n\tproxy_channel_free(gsc);\n\treturn err;\n}\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}