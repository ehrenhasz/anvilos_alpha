{
  "module_name": "intel_gsc_fw.c",
  "hash_id": "cde670101df3f9a6a02521824a6fb89df08559bff68088d5874adb90a0c69157",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/i915/gt/uc/intel_gsc_fw.c",
  "human_readable_source": "\n \n\n#include \"gem/i915_gem_lmem.h\"\n#include \"gt/intel_engine_pm.h\"\n#include \"gt/intel_gpu_commands.h\"\n#include \"gt/intel_gt.h\"\n#include \"gt/intel_gt_print.h\"\n#include \"gt/intel_ring.h\"\n#include \"intel_gsc_binary_headers.h\"\n#include \"intel_gsc_fw.h\"\n#include \"intel_gsc_uc_heci_cmd_submit.h\"\n#include \"i915_reg.h\"\n\nstatic bool gsc_is_in_reset(struct intel_uncore *uncore)\n{\n\tu32 fw_status = intel_uncore_read(uncore, HECI_FWSTS(MTL_GSC_HECI1_BASE, 1));\n\n\treturn REG_FIELD_GET(HECI1_FWSTS1_CURRENT_STATE, fw_status) ==\n\t\t\tHECI1_FWSTS1_CURRENT_STATE_RESET;\n}\n\nstatic u32 gsc_uc_get_fw_status(struct intel_uncore *uncore, bool needs_wakeref)\n{\n\tintel_wakeref_t wakeref;\n\tu32 fw_status = 0;\n\n\tif (needs_wakeref)\n\t\twakeref = intel_runtime_pm_get(uncore->rpm);\n\n\tfw_status = intel_uncore_read(uncore, HECI_FWSTS(MTL_GSC_HECI1_BASE, 1));\n\n\tif (needs_wakeref)\n\t\tintel_runtime_pm_put(uncore->rpm, wakeref);\n\treturn fw_status;\n}\n\nbool intel_gsc_uc_fw_proxy_init_done(struct intel_gsc_uc *gsc, bool needs_wakeref)\n{\n\treturn REG_FIELD_GET(HECI1_FWSTS1_CURRENT_STATE,\n\t\t\t     gsc_uc_get_fw_status(gsc_uc_to_gt(gsc)->uncore,\n\t\t\t\t\t\t  needs_wakeref)) ==\n\t       HECI1_FWSTS1_PROXY_STATE_NORMAL;\n}\n\nint intel_gsc_uc_fw_proxy_get_status(struct intel_gsc_uc *gsc)\n{\n\tif (!(IS_ENABLED(CONFIG_INTEL_MEI_GSC_PROXY)))\n\t\treturn -ENODEV;\n\tif (!intel_uc_fw_is_loadable(&gsc->fw))\n\t\treturn -ENODEV;\n\tif (__intel_uc_fw_status(&gsc->fw) == INTEL_UC_FIRMWARE_LOAD_FAIL)\n\t\treturn -ENOLINK;\n\tif (!intel_gsc_uc_fw_proxy_init_done(gsc, true))\n\t\treturn -EAGAIN;\n\n\treturn 0;\n}\n\nbool intel_gsc_uc_fw_init_done(struct intel_gsc_uc *gsc)\n{\n\treturn gsc_uc_get_fw_status(gsc_uc_to_gt(gsc)->uncore, false) &\n\t       HECI1_FWSTS1_INIT_COMPLETE;\n}\n\nstatic inline u32 cpd_entry_offset(const struct intel_gsc_cpd_entry *entry)\n{\n\treturn entry->offset & INTEL_GSC_CPD_ENTRY_OFFSET_MASK;\n}\n\nint intel_gsc_fw_get_binary_info(struct intel_uc_fw *gsc_fw, const void *data, size_t size)\n{\n\tstruct intel_gsc_uc *gsc = container_of(gsc_fw, struct intel_gsc_uc, fw);\n\tstruct intel_gt *gt = gsc_uc_to_gt(gsc);\n\tconst struct intel_gsc_layout_pointers *layout = data;\n\tconst struct intel_gsc_bpdt_header *bpdt_header = NULL;\n\tconst struct intel_gsc_bpdt_entry *bpdt_entry = NULL;\n\tconst struct intel_gsc_cpd_header_v2 *cpd_header = NULL;\n\tconst struct intel_gsc_cpd_entry *cpd_entry = NULL;\n\tconst struct intel_gsc_manifest_header *manifest;\n\tsize_t min_size = sizeof(*layout);\n\tint i;\n\n\tif (size < min_size) {\n\t\tgt_err(gt, \"GSC FW too small! %zu < %zu\\n\", size, min_size);\n\t\treturn -ENODATA;\n\t}\n\n\t \n\n\tmin_size = layout->boot1.offset + layout->boot1.size;\n\tif (size < min_size) {\n\t\tgt_err(gt, \"GSC FW too small for boot section! %zu < %zu\\n\",\n\t\t       size, min_size);\n\t\treturn -ENODATA;\n\t}\n\n\tmin_size = sizeof(*bpdt_header);\n\tif (layout->boot1.size < min_size) {\n\t\tgt_err(gt, \"GSC FW boot section too small for BPDT header: %u < %zu\\n\",\n\t\t       layout->boot1.size, min_size);\n\t\treturn -ENODATA;\n\t}\n\n\tbpdt_header = data + layout->boot1.offset;\n\tif (bpdt_header->signature != INTEL_GSC_BPDT_HEADER_SIGNATURE) {\n\t\tgt_err(gt, \"invalid signature for BPDT header: 0x%08x!\\n\",\n\t\t       bpdt_header->signature);\n\t\treturn -EINVAL;\n\t}\n\n\tmin_size += sizeof(*bpdt_entry) * bpdt_header->descriptor_count;\n\tif (layout->boot1.size < min_size) {\n\t\tgt_err(gt, \"GSC FW boot section too small for BPDT entries: %u < %zu\\n\",\n\t\t       layout->boot1.size, min_size);\n\t\treturn -ENODATA;\n\t}\n\n\tbpdt_entry = (void *)bpdt_header + sizeof(*bpdt_header);\n\tfor (i = 0; i < bpdt_header->descriptor_count; i++, bpdt_entry++) {\n\t\tif ((bpdt_entry->type & INTEL_GSC_BPDT_ENTRY_TYPE_MASK) !=\n\t\t    INTEL_GSC_BPDT_ENTRY_TYPE_GSC_RBE)\n\t\t\tcontinue;\n\n\t\tcpd_header = (void *)bpdt_header + bpdt_entry->sub_partition_offset;\n\t\tmin_size = bpdt_entry->sub_partition_offset + sizeof(*cpd_header);\n\t\tbreak;\n\t}\n\n\tif (!cpd_header) {\n\t\tgt_err(gt, \"couldn't find CPD header in GSC binary!\\n\");\n\t\treturn -ENODATA;\n\t}\n\n\tif (layout->boot1.size < min_size) {\n\t\tgt_err(gt, \"GSC FW boot section too small for CPD header: %u < %zu\\n\",\n\t\t       layout->boot1.size, min_size);\n\t\treturn -ENODATA;\n\t}\n\n\tif (cpd_header->header_marker != INTEL_GSC_CPD_HEADER_MARKER) {\n\t\tgt_err(gt, \"invalid marker for CPD header in GSC bin: 0x%08x!\\n\",\n\t\t       cpd_header->header_marker);\n\t\treturn -EINVAL;\n\t}\n\n\tmin_size += sizeof(*cpd_entry) * cpd_header->num_of_entries;\n\tif (layout->boot1.size < min_size) {\n\t\tgt_err(gt, \"GSC FW boot section too small for CPD entries: %u < %zu\\n\",\n\t\t       layout->boot1.size, min_size);\n\t\treturn -ENODATA;\n\t}\n\n\tcpd_entry = (void *)cpd_header + cpd_header->header_length;\n\tfor (i = 0; i < cpd_header->num_of_entries; i++, cpd_entry++) {\n\t\tif (strcmp(cpd_entry->name, \"RBEP.man\") == 0) {\n\t\t\tmanifest = (void *)cpd_header + cpd_entry_offset(cpd_entry);\n\t\t\tintel_uc_fw_version_from_gsc_manifest(&gsc->release,\n\t\t\t\t\t\t\t      manifest);\n\t\t\tgsc->security_version = manifest->security_version;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int emit_gsc_fw_load(struct i915_request *rq, struct intel_gsc_uc *gsc)\n{\n\tu32 offset = i915_ggtt_offset(gsc->local);\n\tu32 *cs;\n\n\tcs = intel_ring_begin(rq, 4);\n\tif (IS_ERR(cs))\n\t\treturn PTR_ERR(cs);\n\n\t*cs++ = GSC_FW_LOAD;\n\t*cs++ = lower_32_bits(offset);\n\t*cs++ = upper_32_bits(offset);\n\t*cs++ = (gsc->local->size / SZ_4K) | HECI1_FW_LIMIT_VALID;\n\n\tintel_ring_advance(rq, cs);\n\n\treturn 0;\n}\n\nstatic int gsc_fw_load(struct intel_gsc_uc *gsc)\n{\n\tstruct intel_context *ce = gsc->ce;\n\tstruct i915_request *rq;\n\tint err;\n\n\tif (!ce)\n\t\treturn -ENODEV;\n\n\trq = i915_request_create(ce);\n\tif (IS_ERR(rq))\n\t\treturn PTR_ERR(rq);\n\n\tif (ce->engine->emit_init_breadcrumb) {\n\t\terr = ce->engine->emit_init_breadcrumb(rq);\n\t\tif (err)\n\t\t\tgoto out_rq;\n\t}\n\n\terr = emit_gsc_fw_load(rq, gsc);\n\tif (err)\n\t\tgoto out_rq;\n\n\terr = ce->engine->emit_flush(rq, 0);\n\nout_rq:\n\ti915_request_get(rq);\n\n\tif (unlikely(err))\n\t\ti915_request_set_error_once(rq, err);\n\n\ti915_request_add(rq);\n\n\tif (!err && i915_request_wait(rq, 0, msecs_to_jiffies(500)) < 0)\n\t\terr = -ETIME;\n\n\ti915_request_put(rq);\n\n\tif (err)\n\t\tgt_err(gsc_uc_to_gt(gsc), \"Request submission for GSC load failed %pe\\n\",\n\t\t       ERR_PTR(err));\n\n\treturn err;\n}\n\nstatic int gsc_fw_load_prepare(struct intel_gsc_uc *gsc)\n{\n\tstruct intel_gt *gt = gsc_uc_to_gt(gsc);\n\tvoid *src;\n\n\tif (!gsc->local)\n\t\treturn -ENODEV;\n\n\tif (gsc->local->size < gsc->fw.size)\n\t\treturn -ENOSPC;\n\n\tsrc = i915_gem_object_pin_map_unlocked(gsc->fw.obj,\n\t\t\t\t\t       intel_gt_coherent_map_type(gt, gsc->fw.obj, true));\n\tif (IS_ERR(src))\n\t\treturn PTR_ERR(src);\n\n\tmemcpy_toio(gsc->local_vaddr, src, gsc->fw.size);\n\tmemset_io(gsc->local_vaddr + gsc->fw.size, 0, gsc->local->size - gsc->fw.size);\n\n\tintel_guc_write_barrier(&gt->uc.guc);\n\n\ti915_gem_object_unpin_map(gsc->fw.obj);\n\n\treturn 0;\n}\n\nstatic int gsc_fw_wait(struct intel_gt *gt)\n{\n\treturn intel_wait_for_register(gt->uncore,\n\t\t\t\t       HECI_FWSTS(MTL_GSC_HECI1_BASE, 1),\n\t\t\t\t       HECI1_FWSTS1_INIT_COMPLETE,\n\t\t\t\t       HECI1_FWSTS1_INIT_COMPLETE,\n\t\t\t\t       500);\n}\n\nstruct intel_gsc_mkhi_header {\n\tu8  group_id;\n#define MKHI_GROUP_ID_GFX_SRV 0x30\n\n\tu8  command;\n#define MKHI_GFX_SRV_GET_HOST_COMPATIBILITY_VERSION (0x42)\n\n\tu8  reserved;\n\tu8  result;\n} __packed;\n\nstruct mtl_gsc_ver_msg_in {\n\tstruct intel_gsc_mtl_header header;\n\tstruct intel_gsc_mkhi_header mkhi;\n} __packed;\n\nstruct mtl_gsc_ver_msg_out {\n\tstruct intel_gsc_mtl_header header;\n\tstruct intel_gsc_mkhi_header mkhi;\n\tu16 proj_major;\n\tu16 compat_major;\n\tu16 compat_minor;\n\tu16 reserved[5];\n} __packed;\n\n#define GSC_VER_PKT_SZ SZ_4K\n\nstatic int gsc_fw_query_compatibility_version(struct intel_gsc_uc *gsc)\n{\n\tstruct intel_gt *gt = gsc_uc_to_gt(gsc);\n\tstruct mtl_gsc_ver_msg_in *msg_in;\n\tstruct mtl_gsc_ver_msg_out *msg_out;\n\tstruct i915_vma *vma;\n\tu64 offset;\n\tvoid *vaddr;\n\tint err;\n\n\terr = intel_guc_allocate_and_map_vma(&gt->uc.guc, GSC_VER_PKT_SZ * 2,\n\t\t\t\t\t     &vma, &vaddr);\n\tif (err) {\n\t\tgt_err(gt, \"failed to allocate vma for GSC version query\\n\");\n\t\treturn err;\n\t}\n\n\toffset = i915_ggtt_offset(vma);\n\tmsg_in = vaddr;\n\tmsg_out = vaddr + GSC_VER_PKT_SZ;\n\n\tintel_gsc_uc_heci_cmd_emit_mtl_header(&msg_in->header,\n\t\t\t\t\t      HECI_MEADDRESS_MKHI,\n\t\t\t\t\t      sizeof(*msg_in), 0);\n\tmsg_in->mkhi.group_id = MKHI_GROUP_ID_GFX_SRV;\n\tmsg_in->mkhi.command = MKHI_GFX_SRV_GET_HOST_COMPATIBILITY_VERSION;\n\n\terr = intel_gsc_uc_heci_cmd_submit_packet(&gt->uc.gsc,\n\t\t\t\t\t\t  offset,\n\t\t\t\t\t\t  sizeof(*msg_in),\n\t\t\t\t\t\t  offset + GSC_VER_PKT_SZ,\n\t\t\t\t\t\t  GSC_VER_PKT_SZ);\n\tif (err) {\n\t\tgt_err(gt,\n\t\t       \"failed to submit GSC request for compatibility version: %d\\n\",\n\t\t       err);\n\t\tgoto out_vma;\n\t}\n\n\tif (msg_out->header.message_size != sizeof(*msg_out)) {\n\t\tgt_err(gt, \"invalid GSC reply length %u [expected %zu], s=0x%x, f=0x%x, r=0x%x\\n\",\n\t\t       msg_out->header.message_size, sizeof(*msg_out),\n\t\t       msg_out->header.status, msg_out->header.flags, msg_out->mkhi.result);\n\t\terr = -EPROTO;\n\t\tgoto out_vma;\n\t}\n\n\tgsc->fw.file_selected.ver.major = msg_out->compat_major;\n\tgsc->fw.file_selected.ver.minor = msg_out->compat_minor;\n\nout_vma:\n\ti915_vma_unpin_and_release(&vma, I915_VMA_RELEASE_MAP);\n\treturn err;\n}\n\nint intel_gsc_uc_fw_upload(struct intel_gsc_uc *gsc)\n{\n\tstruct intel_gt *gt = gsc_uc_to_gt(gsc);\n\tstruct intel_uc_fw *gsc_fw = &gsc->fw;\n\tint err;\n\n\t \n\tif (intel_gsc_uc_fw_init_done(gsc)) {\n\t\tif (GEM_WARN_ON(!intel_uc_fw_is_loaded(gsc_fw)))\n\t\t\tintel_uc_fw_change_status(gsc_fw, INTEL_UC_FIRMWARE_TRANSFERRED);\n\t\treturn -EEXIST;\n\t}\n\n\tif (!intel_uc_fw_is_loadable(gsc_fw))\n\t\treturn -ENOEXEC;\n\n\t \n\tintel_uc_fw_sanitize(&gsc->fw);\n\n\tif (!gsc_is_in_reset(gt->uncore))\n\t\treturn -EIO;\n\n\terr = gsc_fw_load_prepare(gsc);\n\tif (err)\n\t\tgoto fail;\n\n\t \n\tintel_uncore_set_flr_on_fini(&gt->i915->uncore);\n\n\terr = gsc_fw_load(gsc);\n\tif (err)\n\t\tgoto fail;\n\n\terr = gsc_fw_wait(gt);\n\tif (err)\n\t\tgoto fail;\n\n\terr = gsc_fw_query_compatibility_version(gsc);\n\tif (err)\n\t\tgoto fail;\n\n\t \n\terr = intel_uc_check_file_version(gsc_fw, NULL);\n\tif (err)\n\t\tgoto fail;\n\n\t \n\tintel_uc_fw_change_status(gsc_fw, INTEL_UC_FIRMWARE_TRANSFERRED);\n\n\tgt_info(gt, \"Loaded GSC firmware %s (cv%u.%u, r%u.%u.%u.%u, svn %u)\\n\",\n\t\tgsc_fw->file_selected.path,\n\t\tgsc_fw->file_selected.ver.major, gsc_fw->file_selected.ver.minor,\n\t\tgsc->release.major, gsc->release.minor,\n\t\tgsc->release.patch, gsc->release.build,\n\t\tgsc->security_version);\n\n\treturn 0;\n\nfail:\n\treturn intel_uc_fw_mark_load_failed(gsc_fw, err);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}