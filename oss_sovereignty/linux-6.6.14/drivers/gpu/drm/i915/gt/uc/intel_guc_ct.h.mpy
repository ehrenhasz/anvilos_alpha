{
  "module_name": "intel_guc_ct.h",
  "hash_id": "62076effc7bc040c2ea427ff976cc75a5cfd0cc4a9d011570ffea5937c12e65e",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/i915/gt/uc/intel_guc_ct.h",
  "human_readable_source": " \n \n\n#ifndef _INTEL_GUC_CT_H_\n#define _INTEL_GUC_CT_H_\n\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/stackdepot.h>\n#include <linux/workqueue.h>\n#include <linux/ktime.h>\n#include <linux/wait.h>\n\n#include \"intel_guc_fwif.h\"\n\nstruct i915_vma;\nstruct intel_guc;\nstruct drm_printer;\n\n \n\n \nstruct intel_guc_ct_buffer {\n\tspinlock_t lock;\n\tstruct guc_ct_buffer_desc *desc;\n\tu32 *cmds;\n\tu32 size;\n\tu32 resv_space;\n\tu32 tail;\n\tu32 head;\n\tatomic_t space;\n\tbool broken;\n};\n\n \nstruct intel_guc_ct {\n\tstruct i915_vma *vma;\n\tbool enabled;\n\n\t \n\tstruct {\n\t\tstruct intel_guc_ct_buffer send;\n\t\tstruct intel_guc_ct_buffer recv;\n\t} ctbs;\n\n\tstruct tasklet_struct receive_tasklet;\n\n\t \n\twait_queue_head_t wq;\n\n\tstruct {\n\t\tu16 last_fence;  \n\n\t\tspinlock_t lock;  \n\t\tstruct list_head pending;  \n\n\t\tstruct list_head incoming;  \n\t\tstruct work_struct worker;  \n\n#if IS_ENABLED(CONFIG_DRM_I915_DEBUG_GEM)\n\t\tstruct {\n\t\t\tu16 fence;\n\t\t\tu16 action;\n#if IS_ENABLED(CONFIG_DRM_I915_DEBUG_GUC)\n\t\t\tdepot_stack_handle_t stack;\n#endif\n\t\t} lost_and_found[SZ_16];\n#endif\n\t} requests;\n\n\t \n\tktime_t stall_time;\n\n#if IS_ENABLED(CONFIG_DRM_I915_DEBUG_GUC)\n\tint dead_ct_reason;\n\tbool dead_ct_reported;\n\tstruct work_struct dead_ct_worker;\n#endif\n};\n\nvoid intel_guc_ct_init_early(struct intel_guc_ct *ct);\nint intel_guc_ct_init(struct intel_guc_ct *ct);\nvoid intel_guc_ct_fini(struct intel_guc_ct *ct);\nint intel_guc_ct_enable(struct intel_guc_ct *ct);\nvoid intel_guc_ct_disable(struct intel_guc_ct *ct);\n\nstatic inline void intel_guc_ct_sanitize(struct intel_guc_ct *ct)\n{\n\tct->enabled = false;\n}\n\nstatic inline bool intel_guc_ct_enabled(struct intel_guc_ct *ct)\n{\n\treturn ct->enabled;\n}\n\n#define INTEL_GUC_CT_SEND_NB\t\tBIT(31)\n#define INTEL_GUC_CT_SEND_G2H_DW_SHIFT\t0\n#define INTEL_GUC_CT_SEND_G2H_DW_MASK\t(0xff << INTEL_GUC_CT_SEND_G2H_DW_SHIFT)\n#define MAKE_SEND_FLAGS(len) ({ \\\n\ttypeof(len) len_ = (len); \\\n\tGEM_BUG_ON(!FIELD_FIT(INTEL_GUC_CT_SEND_G2H_DW_MASK, len_)); \\\n\t(FIELD_PREP(INTEL_GUC_CT_SEND_G2H_DW_MASK, len_) | INTEL_GUC_CT_SEND_NB); \\\n})\nint intel_guc_ct_send(struct intel_guc_ct *ct, const u32 *action, u32 len,\n\t\t      u32 *response_buf, u32 response_buf_size, u32 flags);\nvoid intel_guc_ct_event_handler(struct intel_guc_ct *ct);\n\nvoid intel_guc_ct_print_info(struct intel_guc_ct *ct, struct drm_printer *p);\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}