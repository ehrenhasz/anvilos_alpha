{
  "module_name": "intel_guc_log.c",
  "hash_id": "ba41b5ec1081c9f1f67c8b87737038ac86146f41b6f1dfd6de73ef2445bc021e",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/i915/gt/uc/intel_guc_log.c",
  "human_readable_source": "\n \n\n#include <linux/debugfs.h>\n#include <linux/string_helpers.h>\n\n#include \"gt/intel_gt.h\"\n#include \"i915_drv.h\"\n#include \"i915_irq.h\"\n#include \"i915_memcpy.h\"\n#include \"intel_guc_capture.h\"\n#include \"intel_guc_log.h\"\n#include \"intel_guc_print.h\"\n\n#if defined(CONFIG_DRM_I915_DEBUG_GUC)\n#define GUC_LOG_DEFAULT_CRASH_BUFFER_SIZE\tSZ_2M\n#define GUC_LOG_DEFAULT_DEBUG_BUFFER_SIZE\tSZ_16M\n#define GUC_LOG_DEFAULT_CAPTURE_BUFFER_SIZE\tSZ_1M\n#elif defined(CONFIG_DRM_I915_DEBUG_GEM)\n#define GUC_LOG_DEFAULT_CRASH_BUFFER_SIZE\tSZ_1M\n#define GUC_LOG_DEFAULT_DEBUG_BUFFER_SIZE\tSZ_2M\n#define GUC_LOG_DEFAULT_CAPTURE_BUFFER_SIZE\tSZ_1M\n#else\n#define GUC_LOG_DEFAULT_CRASH_BUFFER_SIZE\tSZ_8K\n#define GUC_LOG_DEFAULT_DEBUG_BUFFER_SIZE\tSZ_64K\n#define GUC_LOG_DEFAULT_CAPTURE_BUFFER_SIZE\tSZ_1M\n#endif\n\nstatic void guc_log_copy_debuglogs_for_relay(struct intel_guc_log *log);\n\nstruct guc_log_section {\n\tu32 max;\n\tu32 flag;\n\tu32 default_val;\n\tconst char *name;\n};\n\nstatic void _guc_log_init_sizes(struct intel_guc_log *log)\n{\n\tstruct intel_guc *guc = log_to_guc(log);\n\tstatic const struct guc_log_section sections[GUC_LOG_SECTIONS_LIMIT] = {\n\t\t{\n\t\t\tGUC_LOG_CRASH_MASK >> GUC_LOG_CRASH_SHIFT,\n\t\t\tGUC_LOG_LOG_ALLOC_UNITS,\n\t\t\tGUC_LOG_DEFAULT_CRASH_BUFFER_SIZE,\n\t\t\t\"crash dump\"\n\t\t},\n\t\t{\n\t\t\tGUC_LOG_DEBUG_MASK >> GUC_LOG_DEBUG_SHIFT,\n\t\t\tGUC_LOG_LOG_ALLOC_UNITS,\n\t\t\tGUC_LOG_DEFAULT_DEBUG_BUFFER_SIZE,\n\t\t\t\"debug\",\n\t\t},\n\t\t{\n\t\t\tGUC_LOG_CAPTURE_MASK >> GUC_LOG_CAPTURE_SHIFT,\n\t\t\tGUC_LOG_CAPTURE_ALLOC_UNITS,\n\t\t\tGUC_LOG_DEFAULT_CAPTURE_BUFFER_SIZE,\n\t\t\t\"capture\",\n\t\t}\n\t};\n\tint i;\n\n\tfor (i = 0; i < GUC_LOG_SECTIONS_LIMIT; i++)\n\t\tlog->sizes[i].bytes = sections[i].default_val;\n\n\t \n\tif (log->sizes[GUC_LOG_SECTIONS_DEBUG].bytes >= SZ_1M &&\n\t    GUC_LOG_DEFAULT_CRASH_BUFFER_SIZE < SZ_1M)\n\t\tlog->sizes[GUC_LOG_SECTIONS_CRASH].bytes = SZ_1M;\n\n\t \n\tfor (i = 0; i < GUC_LOG_SECTIONS_LIMIT; i++) {\n\t\t \n\t\tif ((log->sizes[i].bytes % SZ_1M) == 0) {\n\t\t\tlog->sizes[i].units = SZ_1M;\n\t\t\tlog->sizes[i].flag = sections[i].flag;\n\t\t} else {\n\t\t\tlog->sizes[i].units = SZ_4K;\n\t\t\tlog->sizes[i].flag = 0;\n\t\t}\n\n\t\tif (!IS_ALIGNED(log->sizes[i].bytes, log->sizes[i].units))\n\t\t\tguc_err(guc, \"Mis-aligned log %s size: 0x%X vs 0x%X!\\n\",\n\t\t\t\tsections[i].name, log->sizes[i].bytes, log->sizes[i].units);\n\t\tlog->sizes[i].count = log->sizes[i].bytes / log->sizes[i].units;\n\n\t\tif (!log->sizes[i].count) {\n\t\t\tguc_err(guc, \"Zero log %s size!\\n\", sections[i].name);\n\t\t} else {\n\t\t\t \n\t\t\tlog->sizes[i].count--;\n\t\t}\n\n\t\t \n\t\tif (log->sizes[i].count > sections[i].max) {\n\t\t\tguc_err(guc, \"log %s size too large: %d vs %d!\\n\",\n\t\t\t\tsections[i].name, log->sizes[i].count + 1, sections[i].max + 1);\n\t\t\tlog->sizes[i].count = sections[i].max;\n\t\t}\n\t}\n\n\tif (log->sizes[GUC_LOG_SECTIONS_CRASH].units != log->sizes[GUC_LOG_SECTIONS_DEBUG].units) {\n\t\tguc_err(guc, \"Unit mismatch for crash and debug sections: %d vs %d!\\n\",\n\t\t\tlog->sizes[GUC_LOG_SECTIONS_CRASH].units,\n\t\t\tlog->sizes[GUC_LOG_SECTIONS_DEBUG].units);\n\t\tlog->sizes[GUC_LOG_SECTIONS_CRASH].units = log->sizes[GUC_LOG_SECTIONS_DEBUG].units;\n\t\tlog->sizes[GUC_LOG_SECTIONS_CRASH].count = 0;\n\t}\n\n\tlog->sizes_initialised = true;\n}\n\nstatic void guc_log_init_sizes(struct intel_guc_log *log)\n{\n\tif (log->sizes_initialised)\n\t\treturn;\n\n\t_guc_log_init_sizes(log);\n}\n\nstatic u32 intel_guc_log_section_size_crash(struct intel_guc_log *log)\n{\n\tguc_log_init_sizes(log);\n\n\treturn log->sizes[GUC_LOG_SECTIONS_CRASH].bytes;\n}\n\nstatic u32 intel_guc_log_section_size_debug(struct intel_guc_log *log)\n{\n\tguc_log_init_sizes(log);\n\n\treturn log->sizes[GUC_LOG_SECTIONS_DEBUG].bytes;\n}\n\nu32 intel_guc_log_section_size_capture(struct intel_guc_log *log)\n{\n\tguc_log_init_sizes(log);\n\n\treturn log->sizes[GUC_LOG_SECTIONS_CAPTURE].bytes;\n}\n\nstatic u32 intel_guc_log_size(struct intel_guc_log *log)\n{\n\t \n\treturn PAGE_SIZE +\n\t\tintel_guc_log_section_size_crash(log) +\n\t\tintel_guc_log_section_size_debug(log) +\n\t\tintel_guc_log_section_size_capture(log);\n}\n\n \n\nstatic int guc_action_flush_log_complete(struct intel_guc *guc)\n{\n\tu32 action[] = {\n\t\tINTEL_GUC_ACTION_LOG_BUFFER_FILE_FLUSH_COMPLETE,\n\t\tGUC_DEBUG_LOG_BUFFER\n\t};\n\n\treturn intel_guc_send_nb(guc, action, ARRAY_SIZE(action), 0);\n}\n\nstatic int guc_action_flush_log(struct intel_guc *guc)\n{\n\tu32 action[] = {\n\t\tINTEL_GUC_ACTION_FORCE_LOG_BUFFER_FLUSH,\n\t\t0\n\t};\n\n\treturn intel_guc_send(guc, action, ARRAY_SIZE(action));\n}\n\nstatic int guc_action_control_log(struct intel_guc *guc, bool enable,\n\t\t\t\t  bool default_logging, u32 verbosity)\n{\n\tu32 action[] = {\n\t\tINTEL_GUC_ACTION_UK_LOG_ENABLE_LOGGING,\n\t\t(enable ? GUC_LOG_CONTROL_LOGGING_ENABLED : 0) |\n\t\t(verbosity << GUC_LOG_CONTROL_VERBOSITY_SHIFT) |\n\t\t(default_logging ? GUC_LOG_CONTROL_DEFAULT_LOGGING : 0)\n\t};\n\n\tGEM_BUG_ON(verbosity > GUC_LOG_VERBOSITY_MAX);\n\n\treturn intel_guc_send(guc, action, ARRAY_SIZE(action));\n}\n\n \nstatic int subbuf_start_callback(struct rchan_buf *buf,\n\t\t\t\t void *subbuf,\n\t\t\t\t void *prev_subbuf,\n\t\t\t\t size_t prev_padding)\n{\n\t \n\tif (relay_buf_full(buf))\n\t\treturn 0;\n\n\treturn 1;\n}\n\n \nstatic struct dentry *create_buf_file_callback(const char *filename,\n\t\t\t\t\t       struct dentry *parent,\n\t\t\t\t\t       umode_t mode,\n\t\t\t\t\t       struct rchan_buf *buf,\n\t\t\t\t\t       int *is_global)\n{\n\tstruct dentry *buf_file;\n\n\t \n\t*is_global = 1;\n\n\tif (!parent)\n\t\treturn NULL;\n\n\tbuf_file = debugfs_create_file(filename, mode,\n\t\t\t\t       parent, buf, &relay_file_operations);\n\tif (IS_ERR(buf_file))\n\t\treturn NULL;\n\n\treturn buf_file;\n}\n\n \nstatic int remove_buf_file_callback(struct dentry *dentry)\n{\n\tdebugfs_remove(dentry);\n\treturn 0;\n}\n\n \nstatic const struct rchan_callbacks relay_callbacks = {\n\t.subbuf_start = subbuf_start_callback,\n\t.create_buf_file = create_buf_file_callback,\n\t.remove_buf_file = remove_buf_file_callback,\n};\n\nstatic void guc_move_to_next_buf(struct intel_guc_log *log)\n{\n\t \n\tsmp_wmb();\n\n\t \n\trelay_reserve(log->relay.channel, log->vma->obj->base.size -\n\t\t\t\t\t  intel_guc_log_section_size_capture(log));\n\n\t \n\trelay_flush(log->relay.channel);\n}\n\nstatic void *guc_get_write_buffer(struct intel_guc_log *log)\n{\n\t \n\treturn relay_reserve(log->relay.channel, 0);\n}\n\nbool intel_guc_check_log_buf_overflow(struct intel_guc_log *log,\n\t\t\t\t      enum guc_log_buffer_type type,\n\t\t\t\t      unsigned int full_cnt)\n{\n\tunsigned int prev_full_cnt = log->stats[type].sampled_overflow;\n\tbool overflow = false;\n\n\tif (full_cnt != prev_full_cnt) {\n\t\toverflow = true;\n\n\t\tlog->stats[type].overflow = full_cnt;\n\t\tlog->stats[type].sampled_overflow += full_cnt - prev_full_cnt;\n\n\t\tif (full_cnt < prev_full_cnt) {\n\t\t\t \n\t\t\tlog->stats[type].sampled_overflow += 16;\n\t\t}\n\n\t\tguc_notice_ratelimited(log_to_guc(log), \"log buffer overflow\\n\");\n\t}\n\n\treturn overflow;\n}\n\nunsigned int intel_guc_get_log_buffer_size(struct intel_guc_log *log,\n\t\t\t\t\t   enum guc_log_buffer_type type)\n{\n\tswitch (type) {\n\tcase GUC_DEBUG_LOG_BUFFER:\n\t\treturn intel_guc_log_section_size_debug(log);\n\tcase GUC_CRASH_DUMP_LOG_BUFFER:\n\t\treturn intel_guc_log_section_size_crash(log);\n\tcase GUC_CAPTURE_LOG_BUFFER:\n\t\treturn intel_guc_log_section_size_capture(log);\n\tdefault:\n\t\tMISSING_CASE(type);\n\t}\n\n\treturn 0;\n}\n\nsize_t intel_guc_get_log_buffer_offset(struct intel_guc_log *log,\n\t\t\t\t       enum guc_log_buffer_type type)\n{\n\tenum guc_log_buffer_type i;\n\tsize_t offset = PAGE_SIZE; \n\n\tfor (i = GUC_DEBUG_LOG_BUFFER; i < GUC_MAX_LOG_BUFFER; ++i) {\n\t\tif (i == type)\n\t\t\tbreak;\n\t\toffset += intel_guc_get_log_buffer_size(log, i);\n\t}\n\n\treturn offset;\n}\n\nstatic void _guc_log_copy_debuglogs_for_relay(struct intel_guc_log *log)\n{\n\tstruct intel_guc *guc = log_to_guc(log);\n\tunsigned int buffer_size, read_offset, write_offset, bytes_to_copy, full_cnt;\n\tstruct guc_log_buffer_state *log_buf_state, *log_buf_snapshot_state;\n\tstruct guc_log_buffer_state log_buf_state_local;\n\tenum guc_log_buffer_type type;\n\tvoid *src_data, *dst_data;\n\tbool new_overflow;\n\n\tmutex_lock(&log->relay.lock);\n\n\tif (guc_WARN_ON(guc, !intel_guc_log_relay_created(log)))\n\t\tgoto out_unlock;\n\n\t \n\tsrc_data = log->buf_addr;\n\tlog_buf_state = src_data;\n\n\t \n\tlog_buf_snapshot_state = dst_data = guc_get_write_buffer(log);\n\n\tif (unlikely(!log_buf_snapshot_state)) {\n\t\t \n\t\tguc_err_ratelimited(guc, \"no sub-buffer to copy general logs\\n\");\n\t\tlog->relay.full_count++;\n\n\t\tgoto out_unlock;\n\t}\n\n\t \n\tsrc_data += PAGE_SIZE;\n\tdst_data += PAGE_SIZE;\n\n\t \n\tfor (type = GUC_DEBUG_LOG_BUFFER; type <= GUC_CRASH_DUMP_LOG_BUFFER; type++) {\n\t\t \n\t\tmemcpy(&log_buf_state_local, log_buf_state,\n\t\t       sizeof(struct guc_log_buffer_state));\n\t\tbuffer_size = intel_guc_get_log_buffer_size(log, type);\n\t\tread_offset = log_buf_state_local.read_ptr;\n\t\twrite_offset = log_buf_state_local.sampled_write_ptr;\n\t\tfull_cnt = log_buf_state_local.buffer_full_cnt;\n\n\t\t \n\t\tlog->stats[type].flush += log_buf_state_local.flush_to_file;\n\t\tnew_overflow = intel_guc_check_log_buf_overflow(log, type, full_cnt);\n\n\t\t \n\t\tlog_buf_state->read_ptr = write_offset;\n\t\tlog_buf_state->flush_to_file = 0;\n\t\tlog_buf_state++;\n\n\t\t \n\t\tmemcpy(log_buf_snapshot_state, &log_buf_state_local,\n\t\t       sizeof(struct guc_log_buffer_state));\n\n\t\t \n\t\tlog_buf_snapshot_state->write_ptr = write_offset;\n\t\tlog_buf_snapshot_state++;\n\n\t\t \n\t\tif (unlikely(new_overflow)) {\n\t\t\t \n\t\t\tread_offset = 0;\n\t\t\twrite_offset = buffer_size;\n\t\t} else if (unlikely((read_offset > buffer_size) ||\n\t\t\t\t    (write_offset > buffer_size))) {\n\t\t\tguc_err(guc, \"invalid log buffer state\\n\");\n\t\t\t \n\t\t\tread_offset = 0;\n\t\t\twrite_offset = buffer_size;\n\t\t}\n\n\t\t \n\t\tif (read_offset > write_offset) {\n\t\t\ti915_memcpy_from_wc(dst_data, src_data, write_offset);\n\t\t\tbytes_to_copy = buffer_size - read_offset;\n\t\t} else {\n\t\t\tbytes_to_copy = write_offset - read_offset;\n\t\t}\n\t\ti915_memcpy_from_wc(dst_data + read_offset,\n\t\t\t\t    src_data + read_offset, bytes_to_copy);\n\n\t\tsrc_data += buffer_size;\n\t\tdst_data += buffer_size;\n\t}\n\n\tguc_move_to_next_buf(log);\n\nout_unlock:\n\tmutex_unlock(&log->relay.lock);\n}\n\nstatic void copy_debug_logs_work(struct work_struct *work)\n{\n\tstruct intel_guc_log *log =\n\t\tcontainer_of(work, struct intel_guc_log, relay.flush_work);\n\n\tguc_log_copy_debuglogs_for_relay(log);\n}\n\nstatic int guc_log_relay_map(struct intel_guc_log *log)\n{\n\tlockdep_assert_held(&log->relay.lock);\n\n\tif (!log->vma || !log->buf_addr)\n\t\treturn -ENODEV;\n\n\t \n\ti915_gem_object_get(log->vma->obj);\n\tlog->relay.buf_in_use = true;\n\n\treturn 0;\n}\n\nstatic void guc_log_relay_unmap(struct intel_guc_log *log)\n{\n\tlockdep_assert_held(&log->relay.lock);\n\n\ti915_gem_object_put(log->vma->obj);\n\tlog->relay.buf_in_use = false;\n}\n\nvoid intel_guc_log_init_early(struct intel_guc_log *log)\n{\n\tmutex_init(&log->relay.lock);\n\tINIT_WORK(&log->relay.flush_work, copy_debug_logs_work);\n\tlog->relay.started = false;\n}\n\nstatic int guc_log_relay_create(struct intel_guc_log *log)\n{\n\tstruct intel_guc *guc = log_to_guc(log);\n\tstruct drm_i915_private *i915 = guc_to_gt(guc)->i915;\n\tstruct rchan *guc_log_relay_chan;\n\tsize_t n_subbufs, subbuf_size;\n\tint ret;\n\n\tlockdep_assert_held(&log->relay.lock);\n\tGEM_BUG_ON(!log->vma);\n\n\t  \n\tsubbuf_size = log->vma->size - intel_guc_log_section_size_capture(log);\n\n\t \n\tn_subbufs = 8;\n\n\tif (!guc->dbgfs_node)\n\t\treturn -ENOENT;\n\n\tguc_log_relay_chan = relay_open(\"guc_log\",\n\t\t\t\t\tguc->dbgfs_node,\n\t\t\t\t\tsubbuf_size, n_subbufs,\n\t\t\t\t\t&relay_callbacks, i915);\n\tif (!guc_log_relay_chan) {\n\t\tguc_err(guc, \"Couldn't create relay channel for logging\\n\");\n\n\t\tret = -ENOMEM;\n\t\treturn ret;\n\t}\n\n\tGEM_BUG_ON(guc_log_relay_chan->subbuf_size < subbuf_size);\n\tlog->relay.channel = guc_log_relay_chan;\n\n\treturn 0;\n}\n\nstatic void guc_log_relay_destroy(struct intel_guc_log *log)\n{\n\tlockdep_assert_held(&log->relay.lock);\n\n\trelay_close(log->relay.channel);\n\tlog->relay.channel = NULL;\n}\n\nstatic void guc_log_copy_debuglogs_for_relay(struct intel_guc_log *log)\n{\n\tstruct intel_guc *guc = log_to_guc(log);\n\tstruct drm_i915_private *i915 = guc_to_gt(guc)->i915;\n\tintel_wakeref_t wakeref;\n\n\t_guc_log_copy_debuglogs_for_relay(log);\n\n\t \n\twith_intel_runtime_pm(&i915->runtime_pm, wakeref)\n\t\tguc_action_flush_log_complete(guc);\n}\n\nstatic u32 __get_default_log_level(struct intel_guc_log *log)\n{\n\tstruct intel_guc *guc = log_to_guc(log);\n\tstruct drm_i915_private *i915 = guc_to_gt(guc)->i915;\n\n\t \n\tif (i915->params.guc_log_level < 0) {\n\t\treturn (IS_ENABLED(CONFIG_DRM_I915_DEBUG) ||\n\t\t\tIS_ENABLED(CONFIG_DRM_I915_DEBUG_GEM)) ?\n\t\t\tGUC_LOG_LEVEL_MAX : GUC_LOG_LEVEL_NON_VERBOSE;\n\t}\n\n\tif (i915->params.guc_log_level > GUC_LOG_LEVEL_MAX) {\n\t\tguc_warn(guc, \"Log verbosity param out of range: %d > %d!\\n\",\n\t\t\t i915->params.guc_log_level, GUC_LOG_LEVEL_MAX);\n\t\treturn (IS_ENABLED(CONFIG_DRM_I915_DEBUG) ||\n\t\t\tIS_ENABLED(CONFIG_DRM_I915_DEBUG_GEM)) ?\n\t\t\tGUC_LOG_LEVEL_MAX : GUC_LOG_LEVEL_DISABLED;\n\t}\n\n\tGEM_BUG_ON(i915->params.guc_log_level < GUC_LOG_LEVEL_DISABLED);\n\tGEM_BUG_ON(i915->params.guc_log_level > GUC_LOG_LEVEL_MAX);\n\treturn i915->params.guc_log_level;\n}\n\nint intel_guc_log_create(struct intel_guc_log *log)\n{\n\tstruct intel_guc *guc = log_to_guc(log);\n\tstruct i915_vma *vma;\n\tvoid *vaddr;\n\tu32 guc_log_size;\n\tint ret;\n\n\tGEM_BUG_ON(log->vma);\n\n\tguc_log_size = intel_guc_log_size(log);\n\n\tvma = intel_guc_allocate_vma(guc, guc_log_size);\n\tif (IS_ERR(vma)) {\n\t\tret = PTR_ERR(vma);\n\t\tgoto err;\n\t}\n\n\tlog->vma = vma;\n\t \n\tvaddr = i915_gem_object_pin_map_unlocked(log->vma->obj, I915_MAP_WC);\n\tif (IS_ERR(vaddr)) {\n\t\tret = PTR_ERR(vaddr);\n\t\ti915_vma_unpin_and_release(&log->vma, 0);\n\t\tgoto err;\n\t}\n\tlog->buf_addr = vaddr;\n\n\tlog->level = __get_default_log_level(log);\n\tguc_dbg(guc, \"guc_log_level=%d (%s, verbose:%s, verbosity:%d)\\n\",\n\t\tlog->level, str_enabled_disabled(log->level),\n\t\tstr_yes_no(GUC_LOG_LEVEL_IS_VERBOSE(log->level)),\n\t\tGUC_LOG_LEVEL_TO_VERBOSITY(log->level));\n\n\treturn 0;\n\nerr:\n\tguc_err(guc, \"Failed to allocate or map log buffer %pe\\n\", ERR_PTR(ret));\n\treturn ret;\n}\n\nvoid intel_guc_log_destroy(struct intel_guc_log *log)\n{\n\tlog->buf_addr = NULL;\n\ti915_vma_unpin_and_release(&log->vma, I915_VMA_RELEASE_MAP);\n}\n\nint intel_guc_log_set_level(struct intel_guc_log *log, u32 level)\n{\n\tstruct intel_guc *guc = log_to_guc(log);\n\tstruct drm_i915_private *i915 = guc_to_gt(guc)->i915;\n\tintel_wakeref_t wakeref;\n\tint ret = 0;\n\n\tBUILD_BUG_ON(GUC_LOG_VERBOSITY_MIN != 0);\n\tGEM_BUG_ON(!log->vma);\n\n\t \n\tif (level < GUC_LOG_LEVEL_DISABLED || level > GUC_LOG_LEVEL_MAX)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&i915->drm.struct_mutex);\n\n\tif (log->level == level)\n\t\tgoto out_unlock;\n\n\twith_intel_runtime_pm(&i915->runtime_pm, wakeref)\n\t\tret = guc_action_control_log(guc,\n\t\t\t\t\t     GUC_LOG_LEVEL_IS_VERBOSE(level),\n\t\t\t\t\t     GUC_LOG_LEVEL_IS_ENABLED(level),\n\t\t\t\t\t     GUC_LOG_LEVEL_TO_VERBOSITY(level));\n\tif (ret) {\n\t\tguc_dbg(guc, \"guc_log_control action failed %pe\\n\", ERR_PTR(ret));\n\t\tgoto out_unlock;\n\t}\n\n\tlog->level = level;\n\nout_unlock:\n\tmutex_unlock(&i915->drm.struct_mutex);\n\n\treturn ret;\n}\n\nbool intel_guc_log_relay_created(const struct intel_guc_log *log)\n{\n\treturn log->buf_addr;\n}\n\nint intel_guc_log_relay_open(struct intel_guc_log *log)\n{\n\tint ret;\n\n\tif (!log->vma)\n\t\treturn -ENODEV;\n\n\tmutex_lock(&log->relay.lock);\n\n\tif (intel_guc_log_relay_created(log)) {\n\t\tret = -EEXIST;\n\t\tgoto out_unlock;\n\t}\n\n\t \n\tif (!i915_has_memcpy_from_wc()) {\n\t\tret = -ENXIO;\n\t\tgoto out_unlock;\n\t}\n\n\tret = guc_log_relay_create(log);\n\tif (ret)\n\t\tgoto out_unlock;\n\n\tret = guc_log_relay_map(log);\n\tif (ret)\n\t\tgoto out_relay;\n\n\tmutex_unlock(&log->relay.lock);\n\n\treturn 0;\n\nout_relay:\n\tguc_log_relay_destroy(log);\nout_unlock:\n\tmutex_unlock(&log->relay.lock);\n\n\treturn ret;\n}\n\nint intel_guc_log_relay_start(struct intel_guc_log *log)\n{\n\tif (log->relay.started)\n\t\treturn -EEXIST;\n\n\t \n\tqueue_work(system_highpri_wq, &log->relay.flush_work);\n\n\tlog->relay.started = true;\n\n\treturn 0;\n}\n\nvoid intel_guc_log_relay_flush(struct intel_guc_log *log)\n{\n\tstruct intel_guc *guc = log_to_guc(log);\n\tintel_wakeref_t wakeref;\n\n\tif (!log->relay.started)\n\t\treturn;\n\n\t \n\tflush_work(&log->relay.flush_work);\n\n\twith_intel_runtime_pm(guc_to_gt(guc)->uncore->rpm, wakeref)\n\t\tguc_action_flush_log(guc);\n\n\t \n\tguc_log_copy_debuglogs_for_relay(log);\n}\n\n \nstatic void guc_log_relay_stop(struct intel_guc_log *log)\n{\n\tstruct intel_guc *guc = log_to_guc(log);\n\tstruct drm_i915_private *i915 = guc_to_gt(guc)->i915;\n\n\tif (!log->relay.started)\n\t\treturn;\n\n\tintel_synchronize_irq(i915);\n\n\tflush_work(&log->relay.flush_work);\n\n\tlog->relay.started = false;\n}\n\nvoid intel_guc_log_relay_close(struct intel_guc_log *log)\n{\n\tguc_log_relay_stop(log);\n\n\tmutex_lock(&log->relay.lock);\n\tGEM_BUG_ON(!intel_guc_log_relay_created(log));\n\tguc_log_relay_unmap(log);\n\tguc_log_relay_destroy(log);\n\tmutex_unlock(&log->relay.lock);\n}\n\nvoid intel_guc_log_handle_flush_event(struct intel_guc_log *log)\n{\n\tif (log->relay.started)\n\t\tqueue_work(system_highpri_wq, &log->relay.flush_work);\n}\n\nstatic const char *\nstringify_guc_log_type(enum guc_log_buffer_type type)\n{\n\tswitch (type) {\n\tcase GUC_DEBUG_LOG_BUFFER:\n\t\treturn \"DEBUG\";\n\tcase GUC_CRASH_DUMP_LOG_BUFFER:\n\t\treturn \"CRASH\";\n\tcase GUC_CAPTURE_LOG_BUFFER:\n\t\treturn \"CAPTURE\";\n\tdefault:\n\t\tMISSING_CASE(type);\n\t}\n\n\treturn \"\";\n}\n\n \nvoid intel_guc_log_info(struct intel_guc_log *log, struct drm_printer *p)\n{\n\tenum guc_log_buffer_type type;\n\n\tif (!intel_guc_log_relay_created(log)) {\n\t\tdrm_puts(p, \"GuC log relay not created\\n\");\n\t\treturn;\n\t}\n\n\tdrm_puts(p, \"GuC logging stats:\\n\");\n\n\tdrm_printf(p, \"\\tRelay full count: %u\\n\", log->relay.full_count);\n\n\tfor (type = GUC_DEBUG_LOG_BUFFER; type < GUC_MAX_LOG_BUFFER; type++) {\n\t\tdrm_printf(p, \"\\t%s:\\tflush count %10u, overflow count %10u\\n\",\n\t\t\t   stringify_guc_log_type(type),\n\t\t\t   log->stats[type].flush,\n\t\t\t   log->stats[type].sampled_overflow);\n\t}\n}\n\n \nint intel_guc_log_dump(struct intel_guc_log *log, struct drm_printer *p,\n\t\t       bool dump_load_err)\n{\n\tstruct intel_guc *guc = log_to_guc(log);\n\tstruct intel_uc *uc = container_of(guc, struct intel_uc, guc);\n\tstruct drm_i915_gem_object *obj = NULL;\n\tvoid *map;\n\tu32 *page;\n\tint i, j;\n\n\tif (!intel_guc_is_supported(guc))\n\t\treturn -ENODEV;\n\n\tif (dump_load_err)\n\t\tobj = uc->load_err_log;\n\telse if (guc->log.vma)\n\t\tobj = guc->log.vma->obj;\n\n\tif (!obj)\n\t\treturn 0;\n\n\tpage = (u32 *)__get_free_page(GFP_KERNEL);\n\tif (!page)\n\t\treturn -ENOMEM;\n\n\tintel_guc_dump_time_info(guc, p);\n\n\tmap = i915_gem_object_pin_map_unlocked(obj, I915_MAP_WC);\n\tif (IS_ERR(map)) {\n\t\tguc_dbg(guc, \"Failed to pin log object: %pe\\n\", map);\n\t\tdrm_puts(p, \"(log data unaccessible)\\n\");\n\t\tfree_page((unsigned long)page);\n\t\treturn PTR_ERR(map);\n\t}\n\n\tfor (i = 0; i < obj->base.size; i += PAGE_SIZE) {\n\t\tif (!i915_memcpy_from_wc(page, map + i, PAGE_SIZE))\n\t\t\tmemcpy(page, map + i, PAGE_SIZE);\n\n\t\tfor (j = 0; j < PAGE_SIZE / sizeof(u32); j += 4)\n\t\t\tdrm_printf(p, \"0x%08x 0x%08x 0x%08x 0x%08x\\n\",\n\t\t\t\t   *(page + j + 0), *(page + j + 1),\n\t\t\t\t   *(page + j + 2), *(page + j + 3));\n\t}\n\n\tdrm_puts(p, \"\\n\");\n\n\ti915_gem_object_unpin_map(obj);\n\tfree_page((unsigned long)page);\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}