{
  "module_name": "intel_gsc_uc.c",
  "hash_id": "4e9e7a4f9e5cf17cd27846a5ac14eb86af891353c4e8d42ca688bcb2e9ff72cd",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/i915/gt/uc/intel_gsc_uc.c",
  "human_readable_source": "\n \n\n#include <linux/types.h>\n\n#include \"gt/intel_gt.h\"\n#include \"gt/intel_gt_print.h\"\n#include \"intel_gsc_fw.h\"\n#include \"intel_gsc_proxy.h\"\n#include \"intel_gsc_uc.h\"\n#include \"i915_drv.h\"\n#include \"i915_reg.h\"\n\nstatic void gsc_work(struct work_struct *work)\n{\n\tstruct intel_gsc_uc *gsc = container_of(work, typeof(*gsc), work);\n\tstruct intel_gt *gt = gsc_uc_to_gt(gsc);\n\tintel_wakeref_t wakeref;\n\tu32 actions;\n\tint ret;\n\n\twakeref = intel_runtime_pm_get(gt->uncore->rpm);\n\n\tspin_lock_irq(gt->irq_lock);\n\tactions = gsc->gsc_work_actions;\n\tgsc->gsc_work_actions = 0;\n\tspin_unlock_irq(gt->irq_lock);\n\n\tif (actions & GSC_ACTION_FW_LOAD) {\n\t\tret = intel_gsc_uc_fw_upload(gsc);\n\t\tif (!ret)\n\t\t\t \n\t\t\tactions |= GSC_ACTION_SW_PROXY;\n\t\telse if (ret != -EEXIST)\n\t\t\tgoto out_put;\n\n\t\t \n\t\tif (intel_uc_uses_huc(&gt->uc) &&\n\t\t    intel_huc_is_authenticated(&gt->uc.huc, INTEL_HUC_AUTH_BY_GUC))\n\t\t\tintel_huc_auth(&gt->uc.huc, INTEL_HUC_AUTH_BY_GSC);\n\t}\n\n\tif (actions & GSC_ACTION_SW_PROXY) {\n\t\tif (!intel_gsc_uc_fw_init_done(gsc)) {\n\t\t\tgt_err(gt, \"Proxy request received with GSC not loaded!\\n\");\n\t\t\tgoto out_put;\n\t\t}\n\n\t\tret = intel_gsc_proxy_request_handler(gsc);\n\t\tif (ret) {\n\t\t\tif (actions & GSC_ACTION_FW_LOAD) {\n\t\t\t\t \n\t\t\t\tdrm_err(&gt->i915->drm,\n\t\t\t\t\t\"GSC proxy handler failed to init\\n\");\n\t\t\t\tintel_uc_fw_change_status(&gsc->fw, INTEL_UC_FIRMWARE_LOAD_FAIL);\n\t\t\t}\n\t\t\tgoto out_put;\n\t\t}\n\n\t\t \n\t\tif (actions & GSC_ACTION_FW_LOAD) {\n\t\t\t \n\t\t\tif (intel_gsc_uc_fw_proxy_init_done(gsc, false)) {\n\t\t\t\tdrm_dbg(&gt->i915->drm, \"GSC Proxy initialized\\n\");\n\t\t\t\tintel_uc_fw_change_status(&gsc->fw, INTEL_UC_FIRMWARE_RUNNING);\n\t\t\t} else {\n\t\t\t\tdrm_err(&gt->i915->drm,\n\t\t\t\t\t\"GSC status reports proxy init not complete\\n\");\n\t\t\t\tintel_uc_fw_change_status(&gsc->fw, INTEL_UC_FIRMWARE_LOAD_FAIL);\n\t\t\t}\n\t\t}\n\t}\n\nout_put:\n\tintel_runtime_pm_put(gt->uncore->rpm, wakeref);\n}\n\nstatic bool gsc_engine_supported(struct intel_gt *gt)\n{\n\tintel_engine_mask_t mask;\n\n\t \n\tGEM_BUG_ON(!gt_is_root(gt) && !gt->info.engine_mask);\n\n\tif (gt_is_root(gt))\n\t\tmask = INTEL_INFO(gt->i915)->platform_engine_mask;\n\telse\n\t\tmask = gt->info.engine_mask;\n\n\treturn __HAS_ENGINE(mask, GSC0);\n}\n\nvoid intel_gsc_uc_init_early(struct intel_gsc_uc *gsc)\n{\n\tstruct intel_gt *gt = gsc_uc_to_gt(gsc);\n\n\t \n\tintel_uc_fw_init_early(&gsc->fw, INTEL_UC_FW_TYPE_GSC, false);\n\tINIT_WORK(&gsc->work, gsc_work);\n\n\t \n\tif (!gsc_engine_supported(gt)) {\n\t\tintel_uc_fw_change_status(&gsc->fw, INTEL_UC_FIRMWARE_NOT_SUPPORTED);\n\t\treturn;\n\t}\n\n\tgsc->wq = alloc_ordered_workqueue(\"i915_gsc\", 0);\n\tif (!gsc->wq) {\n\t\tgt_err(gt, \"failed to allocate WQ for GSC, disabling FW\\n\");\n\t\tintel_uc_fw_change_status(&gsc->fw, INTEL_UC_FIRMWARE_NOT_SUPPORTED);\n\t}\n}\n\nstatic int gsc_allocate_and_map_vma(struct intel_gsc_uc *gsc, u32 size)\n{\n\tstruct intel_gt *gt = gsc_uc_to_gt(gsc);\n\tstruct drm_i915_gem_object *obj;\n\tstruct i915_vma *vma;\n\tvoid __iomem *vaddr;\n\tint ret = 0;\n\n\t \n\tobj = i915_gem_object_create_stolen(gt->i915, size);\n\tif (IS_ERR(obj))\n\t\treturn PTR_ERR(obj);\n\n\tvma = i915_gem_object_ggtt_pin(obj, NULL, 0, 0, 0);\n\tif (IS_ERR(vma)) {\n\t\tret = PTR_ERR(vma);\n\t\tgoto err;\n\t}\n\n\tvaddr = i915_vma_pin_iomap(vma);\n\ti915_vma_unpin(vma);\n\tif (IS_ERR(vaddr)) {\n\t\tret = PTR_ERR(vaddr);\n\t\tgoto err;\n\t}\n\n\ti915_vma_make_unshrinkable(vma);\n\n\tgsc->local = vma;\n\tgsc->local_vaddr = vaddr;\n\n\treturn 0;\n\nerr:\n\ti915_gem_object_put(obj);\n\treturn ret;\n}\n\nstatic void gsc_unmap_and_free_vma(struct intel_gsc_uc *gsc)\n{\n\tstruct i915_vma *vma = fetch_and_zero(&gsc->local);\n\n\tif (!vma)\n\t\treturn;\n\n\tgsc->local_vaddr = NULL;\n\ti915_vma_unpin_iomap(vma);\n\ti915_gem_object_put(vma->obj);\n}\n\nint intel_gsc_uc_init(struct intel_gsc_uc *gsc)\n{\n\tstatic struct lock_class_key gsc_lock;\n\tstruct intel_gt *gt = gsc_uc_to_gt(gsc);\n\tstruct intel_engine_cs *engine = gt->engine[GSC0];\n\tstruct intel_context *ce;\n\tint err;\n\n\terr = intel_uc_fw_init(&gsc->fw);\n\tif (err)\n\t\tgoto out;\n\n\terr = gsc_allocate_and_map_vma(gsc, SZ_4M);\n\tif (err)\n\t\tgoto out_fw;\n\n\tce = intel_engine_create_pinned_context(engine, engine->gt->vm, SZ_4K,\n\t\t\t\t\t\tI915_GEM_HWS_GSC_ADDR,\n\t\t\t\t\t\t&gsc_lock, \"gsc_context\");\n\tif (IS_ERR(ce)) {\n\t\tgt_err(gt, \"failed to create GSC CS ctx for FW communication\\n\");\n\t\terr =  PTR_ERR(ce);\n\t\tgoto out_vma;\n\t}\n\n\tgsc->ce = ce;\n\n\t \n\tintel_gsc_proxy_init(gsc);\n\n\tintel_uc_fw_change_status(&gsc->fw, INTEL_UC_FIRMWARE_LOADABLE);\n\n\treturn 0;\n\nout_vma:\n\tgsc_unmap_and_free_vma(gsc);\nout_fw:\n\tintel_uc_fw_fini(&gsc->fw);\nout:\n\tgt_probe_error(gt, \"GSC init failed %pe\\n\", ERR_PTR(err));\n\treturn err;\n}\n\nvoid intel_gsc_uc_fini(struct intel_gsc_uc *gsc)\n{\n\tif (!intel_uc_fw_is_loadable(&gsc->fw))\n\t\treturn;\n\n\tflush_work(&gsc->work);\n\tif (gsc->wq) {\n\t\tdestroy_workqueue(gsc->wq);\n\t\tgsc->wq = NULL;\n\t}\n\n\tintel_gsc_proxy_fini(gsc);\n\n\tif (gsc->ce)\n\t\tintel_engine_destroy_pinned_context(fetch_and_zero(&gsc->ce));\n\n\tgsc_unmap_and_free_vma(gsc);\n\n\tintel_uc_fw_fini(&gsc->fw);\n}\n\nvoid intel_gsc_uc_flush_work(struct intel_gsc_uc *gsc)\n{\n\tif (!intel_uc_fw_is_loadable(&gsc->fw))\n\t\treturn;\n\n\tflush_work(&gsc->work);\n}\n\nvoid intel_gsc_uc_resume(struct intel_gsc_uc *gsc)\n{\n\tif (!intel_uc_fw_is_loadable(&gsc->fw))\n\t\treturn;\n\n\t \n\tif (!gsc_uc_to_gt(gsc)->engine[GSC0]->default_state)\n\t\treturn;\n\n\tintel_gsc_uc_load_start(gsc);\n}\n\nvoid intel_gsc_uc_load_start(struct intel_gsc_uc *gsc)\n{\n\tstruct intel_gt *gt = gsc_uc_to_gt(gsc);\n\n\tif (!intel_uc_fw_is_loadable(&gsc->fw))\n\t\treturn;\n\n\tif (intel_gsc_uc_fw_init_done(gsc))\n\t\treturn;\n\n\tspin_lock_irq(gt->irq_lock);\n\tgsc->gsc_work_actions |= GSC_ACTION_FW_LOAD;\n\tspin_unlock_irq(gt->irq_lock);\n\n\tqueue_work(gsc->wq, &gsc->work);\n}\n\nvoid intel_gsc_uc_load_status(struct intel_gsc_uc *gsc, struct drm_printer *p)\n{\n\tstruct intel_gt *gt = gsc_uc_to_gt(gsc);\n\tstruct intel_uncore *uncore = gt->uncore;\n\tintel_wakeref_t wakeref;\n\n\tif (!intel_gsc_uc_is_supported(gsc)) {\n\t\tdrm_printf(p, \"GSC not supported\\n\");\n\t\treturn;\n\t}\n\n\tif (!intel_gsc_uc_is_wanted(gsc)) {\n\t\tdrm_printf(p, \"GSC disabled\\n\");\n\t\treturn;\n\t}\n\n\tdrm_printf(p, \"GSC firmware: %s\\n\", gsc->fw.file_selected.path);\n\tif (gsc->fw.file_selected.path != gsc->fw.file_wanted.path)\n\t\tdrm_printf(p, \"GSC firmware wanted: %s\\n\", gsc->fw.file_wanted.path);\n\tdrm_printf(p, \"\\tstatus: %s\\n\", intel_uc_fw_status_repr(gsc->fw.status));\n\n\tdrm_printf(p, \"Release: %u.%u.%u.%u\\n\",\n\t\t   gsc->release.major, gsc->release.minor,\n\t\t   gsc->release.patch, gsc->release.build);\n\n\tdrm_printf(p, \"Compatibility Version: %u.%u [min expected %u.%u]\\n\",\n\t\t   gsc->fw.file_selected.ver.major, gsc->fw.file_selected.ver.minor,\n\t\t   gsc->fw.file_wanted.ver.major, gsc->fw.file_wanted.ver.minor);\n\n\tdrm_printf(p, \"SVN: %u\\n\", gsc->security_version);\n\n\twith_intel_runtime_pm(uncore->rpm, wakeref) {\n\t\tu32 i;\n\n\t\tfor (i = 1; i <= 6; i++) {\n\t\t\tu32 status = intel_uncore_read(uncore,\n\t\t\t\t\t\t       HECI_FWSTS(MTL_GSC_HECI1_BASE, i));\n\t\t\tdrm_printf(p, \"HECI1 FWSTST%u = 0x%08x\\n\", i, status);\n\t\t}\n\t}\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}