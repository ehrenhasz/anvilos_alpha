{
  "module_name": "intel_guc_fw.c",
  "hash_id": "d540e7fc99184ef225a8ee76b9524207af7768ed000b434bc2bff896cfec8a1c",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/i915/gt/uc/intel_guc_fw.c",
  "human_readable_source": "\n \n\n#include \"gt/intel_gt.h\"\n#include \"gt/intel_gt_mcr.h\"\n#include \"gt/intel_gt_regs.h\"\n#include \"gt/intel_rps.h\"\n#include \"intel_guc_fw.h\"\n#include \"intel_guc_print.h\"\n#include \"i915_drv.h\"\n\nstatic void guc_prepare_xfer(struct intel_gt *gt)\n{\n\tstruct intel_uncore *uncore = gt->uncore;\n\n\tu32 shim_flags = GUC_ENABLE_READ_CACHE_LOGIC |\n\t\t\t GUC_ENABLE_READ_CACHE_FOR_SRAM_DATA |\n\t\t\t GUC_ENABLE_READ_CACHE_FOR_WOPCM_DATA |\n\t\t\t GUC_ENABLE_MIA_CLOCK_GATING;\n\n\tif (GRAPHICS_VER_FULL(uncore->i915) < IP_VER(12, 50))\n\t\tshim_flags |= GUC_DISABLE_SRAM_INIT_TO_ZEROES |\n\t\t\t      GUC_ENABLE_MIA_CACHING;\n\n\t \n\tintel_uncore_write(uncore, GUC_SHIM_CONTROL, shim_flags);\n\n\tif (IS_GEN9_LP(uncore->i915))\n\t\tintel_uncore_write(uncore, GEN9LP_GT_PM_CONFIG, GT_DOORBELL_ENABLE);\n\telse\n\t\tintel_uncore_write(uncore, GEN9_GT_PM_CONFIG, GT_DOORBELL_ENABLE);\n\n\tif (GRAPHICS_VER(uncore->i915) == 9) {\n\t\t \n\t\tintel_uncore_rmw(uncore, GEN7_MISCCPCTL, 0,\n\t\t\t\t GEN8_DOP_CLOCK_GATE_GUC_ENABLE);\n\n\t\t \n\t\tintel_uncore_write(uncore, GUC_ARAT_C6DIS, 0x1FF);\n\t}\n}\n\nstatic int guc_xfer_rsa_mmio(struct intel_uc_fw *guc_fw,\n\t\t\t     struct intel_uncore *uncore)\n{\n\tu32 rsa[UOS_RSA_SCRATCH_COUNT];\n\tsize_t copied;\n\tint i;\n\n\tcopied = intel_uc_fw_copy_rsa(guc_fw, rsa, sizeof(rsa));\n\tif (copied < sizeof(rsa))\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < UOS_RSA_SCRATCH_COUNT; i++)\n\t\tintel_uncore_write(uncore, UOS_RSA_SCRATCH(i), rsa[i]);\n\n\treturn 0;\n}\n\nstatic int guc_xfer_rsa_vma(struct intel_uc_fw *guc_fw,\n\t\t\t    struct intel_uncore *uncore)\n{\n\tstruct intel_guc *guc = container_of(guc_fw, struct intel_guc, fw);\n\n\tintel_uncore_write(uncore, UOS_RSA_SCRATCH(0),\n\t\t\t   intel_guc_ggtt_offset(guc, guc_fw->rsa_data));\n\n\treturn 0;\n}\n\n \nstatic int guc_xfer_rsa(struct intel_uc_fw *guc_fw,\n\t\t\tstruct intel_uncore *uncore)\n{\n\tif (guc_fw->rsa_data)\n\t\treturn guc_xfer_rsa_vma(guc_fw, uncore);\n\telse\n\t\treturn guc_xfer_rsa_mmio(guc_fw, uncore);\n}\n\n \nstatic inline bool guc_load_done(struct intel_uncore *uncore, u32 *status, bool *success)\n{\n\tu32 val = intel_uncore_read(uncore, GUC_STATUS);\n\tu32 uk_val = REG_FIELD_GET(GS_UKERNEL_MASK, val);\n\tu32 br_val = REG_FIELD_GET(GS_BOOTROM_MASK, val);\n\n\t*status = val;\n\tswitch (uk_val) {\n\tcase INTEL_GUC_LOAD_STATUS_READY:\n\t\t*success = true;\n\t\treturn true;\n\n\tcase INTEL_GUC_LOAD_STATUS_ERROR_DEVID_BUILD_MISMATCH:\n\tcase INTEL_GUC_LOAD_STATUS_GUC_PREPROD_BUILD_MISMATCH:\n\tcase INTEL_GUC_LOAD_STATUS_ERROR_DEVID_INVALID_GUCTYPE:\n\tcase INTEL_GUC_LOAD_STATUS_HWCONFIG_ERROR:\n\tcase INTEL_GUC_LOAD_STATUS_DPC_ERROR:\n\tcase INTEL_GUC_LOAD_STATUS_EXCEPTION:\n\tcase INTEL_GUC_LOAD_STATUS_INIT_DATA_INVALID:\n\tcase INTEL_GUC_LOAD_STATUS_MPU_DATA_INVALID:\n\tcase INTEL_GUC_LOAD_STATUS_INIT_MMIO_SAVE_RESTORE_INVALID:\n\t\t*success = false;\n\t\treturn true;\n\t}\n\n\tswitch (br_val) {\n\tcase INTEL_BOOTROM_STATUS_NO_KEY_FOUND:\n\tcase INTEL_BOOTROM_STATUS_RSA_FAILED:\n\tcase INTEL_BOOTROM_STATUS_PAVPC_FAILED:\n\tcase INTEL_BOOTROM_STATUS_WOPCM_FAILED:\n\tcase INTEL_BOOTROM_STATUS_LOADLOC_FAILED:\n\tcase INTEL_BOOTROM_STATUS_JUMP_FAILED:\n\tcase INTEL_BOOTROM_STATUS_RC6CTXCONFIG_FAILED:\n\tcase INTEL_BOOTROM_STATUS_MPUMAP_INCORRECT:\n\tcase INTEL_BOOTROM_STATUS_EXCEPTION:\n\tcase INTEL_BOOTROM_STATUS_PROD_KEY_CHECK_FAILURE:\n\t\t*success = false;\n\t\treturn true;\n\t}\n\n\treturn false;\n}\n\n \n#if defined(CONFIG_DRM_I915_DEBUG_GEM)\n#define GUC_LOAD_RETRY_LIMIT\t20\n#else\n#define GUC_LOAD_RETRY_LIMIT\t3\n#endif\n\nstatic int guc_wait_ucode(struct intel_guc *guc)\n{\n\tstruct intel_gt *gt = guc_to_gt(guc);\n\tstruct intel_uncore *uncore = gt->uncore;\n\tktime_t before, after, delta;\n\tbool success;\n\tu32 status;\n\tint ret, count;\n\tu64 delta_ms;\n\tu32 before_freq;\n\n\t \n\tbefore_freq = intel_rps_read_actual_frequency(&uncore->gt->rps);\n\tbefore = ktime_get();\n\tfor (count = 0; count < GUC_LOAD_RETRY_LIMIT; count++) {\n\t\tret = wait_for(guc_load_done(uncore, &status, &success), 1000);\n\t\tif (!ret || !success)\n\t\t\tbreak;\n\n\t\tguc_dbg(guc, \"load still in progress, count = %d, freq = %dMHz, status = 0x%08X [0x%02X/%02X]\\n\",\n\t\t\tcount, intel_rps_read_actual_frequency(&uncore->gt->rps), status,\n\t\t\tREG_FIELD_GET(GS_BOOTROM_MASK, status),\n\t\t\tREG_FIELD_GET(GS_UKERNEL_MASK, status));\n\t}\n\tafter = ktime_get();\n\tdelta = ktime_sub(after, before);\n\tdelta_ms = ktime_to_ms(delta);\n\tif (ret || !success) {\n\t\tu32 ukernel = REG_FIELD_GET(GS_UKERNEL_MASK, status);\n\t\tu32 bootrom = REG_FIELD_GET(GS_BOOTROM_MASK, status);\n\n\t\tguc_info(guc, \"load failed: status = 0x%08X, time = %lldms, freq = %dMHz, ret = %d\\n\",\n\t\t\t status, delta_ms, intel_rps_read_actual_frequency(&uncore->gt->rps), ret);\n\t\tguc_info(guc, \"load failed: status: Reset = %d, BootROM = 0x%02X, UKernel = 0x%02X, MIA = 0x%02X, Auth = 0x%02X\\n\",\n\t\t\t REG_FIELD_GET(GS_MIA_IN_RESET, status),\n\t\t\t bootrom, ukernel,\n\t\t\t REG_FIELD_GET(GS_MIA_MASK, status),\n\t\t\t REG_FIELD_GET(GS_AUTH_STATUS_MASK, status));\n\n\t\tswitch (bootrom) {\n\t\tcase INTEL_BOOTROM_STATUS_NO_KEY_FOUND:\n\t\t\tguc_info(guc, \"invalid key requested, header = 0x%08X\\n\",\n\t\t\t\t intel_uncore_read(uncore, GUC_HEADER_INFO));\n\t\t\tret = -ENOEXEC;\n\t\t\tbreak;\n\n\t\tcase INTEL_BOOTROM_STATUS_RSA_FAILED:\n\t\t\tguc_info(guc, \"firmware signature verification failed\\n\");\n\t\t\tret = -ENOEXEC;\n\t\t\tbreak;\n\n\t\tcase INTEL_BOOTROM_STATUS_PROD_KEY_CHECK_FAILURE:\n\t\t\tguc_info(guc, \"firmware production part check failure\\n\");\n\t\t\tret = -ENOEXEC;\n\t\t\tbreak;\n\t\t}\n\n\t\tswitch (ukernel) {\n\t\tcase INTEL_GUC_LOAD_STATUS_EXCEPTION:\n\t\t\tguc_info(guc, \"firmware exception. EIP: %#x\\n\",\n\t\t\t\t intel_uncore_read(uncore, SOFT_SCRATCH(13)));\n\t\t\tret = -ENXIO;\n\t\t\tbreak;\n\n\t\tcase INTEL_GUC_LOAD_STATUS_INIT_MMIO_SAVE_RESTORE_INVALID:\n\t\t\tguc_info(guc, \"illegal register in save/restore workaround list\\n\");\n\t\t\tret = -EPERM;\n\t\t\tbreak;\n\n\t\tcase INTEL_GUC_LOAD_STATUS_HWCONFIG_START:\n\t\t\tguc_info(guc, \"still extracting hwconfig table.\\n\");\n\t\t\tret = -ETIMEDOUT;\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\tif (ret == 0)\n\t\t\tret = -ENXIO;\n\t} else if (delta_ms > 200) {\n\t\tguc_warn(guc, \"excessive init time: %lldms! [status = 0x%08X, count = %d, ret = %d]\\n\",\n\t\t\t delta_ms, status, count, ret);\n\t\tguc_warn(guc, \"excessive init time: [freq = %dMHz, before = %dMHz, perf_limit_reasons = 0x%08X]\\n\",\n\t\t\t intel_rps_read_actual_frequency(&uncore->gt->rps), before_freq,\n\t\t\t intel_uncore_read(uncore, intel_gt_perf_limit_reasons_reg(gt)));\n\t} else {\n\t\tguc_dbg(guc, \"init took %lldms, freq = %dMHz, before = %dMHz, status = 0x%08X, count = %d, ret = %d\\n\",\n\t\t\tdelta_ms, intel_rps_read_actual_frequency(&uncore->gt->rps),\n\t\t\tbefore_freq, status, count, ret);\n\t}\n\n\treturn ret;\n}\n\n \nint intel_guc_fw_upload(struct intel_guc *guc)\n{\n\tstruct intel_gt *gt = guc_to_gt(guc);\n\tstruct intel_uncore *uncore = gt->uncore;\n\tint ret;\n\n\tguc_prepare_xfer(gt);\n\n\t \n\tret = guc_xfer_rsa(&guc->fw, uncore);\n\tif (ret)\n\t\tgoto out;\n\n\t \n\tret = intel_uc_fw_upload(&guc->fw, 0x2000, UOS_MOVE);\n\tif (ret)\n\t\tgoto out;\n\n\tret = guc_wait_ucode(guc);\n\tif (ret)\n\t\tgoto out;\n\n\tintel_uc_fw_change_status(&guc->fw, INTEL_UC_FIRMWARE_RUNNING);\n\treturn 0;\n\nout:\n\tintel_uc_fw_change_status(&guc->fw, INTEL_UC_FIRMWARE_LOAD_FAIL);\n\treturn ret;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}