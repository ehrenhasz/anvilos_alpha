{
  "module_name": "intel_guc_slpc.c",
  "hash_id": "a33b92fd85fc7368b860d550c52438dd3de87d12647d541f76adea551c6c5ce7",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/i915/gt/uc/intel_guc_slpc.c",
  "human_readable_source": "\n \n\n#include <drm/drm_cache.h>\n#include <linux/string_helpers.h>\n\n#include \"i915_drv.h\"\n#include \"i915_reg.h\"\n#include \"intel_guc_slpc.h\"\n#include \"intel_guc_print.h\"\n#include \"intel_mchbar_regs.h\"\n#include \"gt/intel_gt.h\"\n#include \"gt/intel_gt_regs.h\"\n#include \"gt/intel_rps.h\"\n\nstatic inline struct intel_guc *slpc_to_guc(struct intel_guc_slpc *slpc)\n{\n\treturn container_of(slpc, struct intel_guc, slpc);\n}\n\nstatic inline struct intel_gt *slpc_to_gt(struct intel_guc_slpc *slpc)\n{\n\treturn guc_to_gt(slpc_to_guc(slpc));\n}\n\nstatic inline struct drm_i915_private *slpc_to_i915(struct intel_guc_slpc *slpc)\n{\n\treturn slpc_to_gt(slpc)->i915;\n}\n\nstatic bool __detect_slpc_supported(struct intel_guc *guc)\n{\n\t \n\treturn guc->submission_supported &&\n\t\tGRAPHICS_VER(guc_to_gt(guc)->i915) >= 12;\n}\n\nstatic bool __guc_slpc_selected(struct intel_guc *guc)\n{\n\tif (!intel_guc_slpc_is_supported(guc))\n\t\treturn false;\n\n\treturn guc->submission_selected;\n}\n\nvoid intel_guc_slpc_init_early(struct intel_guc_slpc *slpc)\n{\n\tstruct intel_guc *guc = slpc_to_guc(slpc);\n\n\tslpc->supported = __detect_slpc_supported(guc);\n\tslpc->selected = __guc_slpc_selected(guc);\n}\n\nstatic void slpc_mem_set_param(struct slpc_shared_data *data,\n\t\t\t       u32 id, u32 value)\n{\n\tGEM_BUG_ON(id >= SLPC_MAX_OVERRIDE_PARAMETERS);\n\t \n\tdata->override_params.bits[id >> 5] |= (1 << (id % 32));\n\tdata->override_params.values[id] = value;\n}\n\nstatic void slpc_mem_set_enabled(struct slpc_shared_data *data,\n\t\t\t\t u8 enable_id, u8 disable_id)\n{\n\t \n\tslpc_mem_set_param(data, enable_id, 1);\n\tslpc_mem_set_param(data, disable_id, 0);\n}\n\nstatic void slpc_mem_set_disabled(struct slpc_shared_data *data,\n\t\t\t\t  u8 enable_id, u8 disable_id)\n{\n\t \n\tslpc_mem_set_param(data, disable_id, 1);\n\tslpc_mem_set_param(data, enable_id, 0);\n}\n\nstatic u32 slpc_get_state(struct intel_guc_slpc *slpc)\n{\n\tstruct slpc_shared_data *data;\n\n\tGEM_BUG_ON(!slpc->vma);\n\n\tdrm_clflush_virt_range(slpc->vaddr, sizeof(u32));\n\tdata = slpc->vaddr;\n\n\treturn data->header.global_state;\n}\n\nstatic int guc_action_slpc_set_param_nb(struct intel_guc *guc, u8 id, u32 value)\n{\n\tu32 request[] = {\n\t\tGUC_ACTION_HOST2GUC_PC_SLPC_REQUEST,\n\t\tSLPC_EVENT(SLPC_EVENT_PARAMETER_SET, 2),\n\t\tid,\n\t\tvalue,\n\t};\n\tint ret;\n\n\tret = intel_guc_send_nb(guc, request, ARRAY_SIZE(request), 0);\n\n\treturn ret > 0 ? -EPROTO : ret;\n}\n\nstatic int slpc_set_param_nb(struct intel_guc_slpc *slpc, u8 id, u32 value)\n{\n\tstruct intel_guc *guc = slpc_to_guc(slpc);\n\n\tGEM_BUG_ON(id >= SLPC_MAX_PARAM);\n\n\treturn guc_action_slpc_set_param_nb(guc, id, value);\n}\n\nstatic int guc_action_slpc_set_param(struct intel_guc *guc, u8 id, u32 value)\n{\n\tu32 request[] = {\n\t\tGUC_ACTION_HOST2GUC_PC_SLPC_REQUEST,\n\t\tSLPC_EVENT(SLPC_EVENT_PARAMETER_SET, 2),\n\t\tid,\n\t\tvalue,\n\t};\n\tint ret;\n\n\tret = intel_guc_send(guc, request, ARRAY_SIZE(request));\n\n\treturn ret > 0 ? -EPROTO : ret;\n}\n\nstatic int guc_action_slpc_unset_param(struct intel_guc *guc, u8 id)\n{\n\tu32 request[] = {\n\t\tGUC_ACTION_HOST2GUC_PC_SLPC_REQUEST,\n\t\tSLPC_EVENT(SLPC_EVENT_PARAMETER_UNSET, 1),\n\t\tid,\n\t};\n\n\treturn intel_guc_send(guc, request, ARRAY_SIZE(request));\n}\n\nstatic bool slpc_is_running(struct intel_guc_slpc *slpc)\n{\n\treturn slpc_get_state(slpc) == SLPC_GLOBAL_STATE_RUNNING;\n}\n\nstatic int guc_action_slpc_query(struct intel_guc *guc, u32 offset)\n{\n\tu32 request[] = {\n\t\tGUC_ACTION_HOST2GUC_PC_SLPC_REQUEST,\n\t\tSLPC_EVENT(SLPC_EVENT_QUERY_TASK_STATE, 2),\n\t\toffset,\n\t\t0,\n\t};\n\tint ret;\n\n\tret = intel_guc_send(guc, request, ARRAY_SIZE(request));\n\n\treturn ret > 0 ? -EPROTO : ret;\n}\n\nstatic int slpc_query_task_state(struct intel_guc_slpc *slpc)\n{\n\tstruct intel_guc *guc = slpc_to_guc(slpc);\n\tu32 offset = intel_guc_ggtt_offset(guc, slpc->vma);\n\tint ret;\n\n\tret = guc_action_slpc_query(guc, offset);\n\tif (unlikely(ret))\n\t\tguc_probe_error(guc, \"Failed to query task state: %pe\\n\", ERR_PTR(ret));\n\n\tdrm_clflush_virt_range(slpc->vaddr, SLPC_PAGE_SIZE_BYTES);\n\n\treturn ret;\n}\n\nstatic int slpc_set_param(struct intel_guc_slpc *slpc, u8 id, u32 value)\n{\n\tstruct intel_guc *guc = slpc_to_guc(slpc);\n\tint ret;\n\n\tGEM_BUG_ON(id >= SLPC_MAX_PARAM);\n\n\tret = guc_action_slpc_set_param(guc, id, value);\n\tif (ret)\n\t\tguc_probe_error(guc, \"Failed to set param %d to %u: %pe\\n\",\n\t\t\t\tid, value, ERR_PTR(ret));\n\n\treturn ret;\n}\n\nstatic int slpc_unset_param(struct intel_guc_slpc *slpc, u8 id)\n{\n\tstruct intel_guc *guc = slpc_to_guc(slpc);\n\n\tGEM_BUG_ON(id >= SLPC_MAX_PARAM);\n\n\treturn guc_action_slpc_unset_param(guc, id);\n}\n\nstatic int slpc_force_min_freq(struct intel_guc_slpc *slpc, u32 freq)\n{\n\tstruct intel_guc *guc = slpc_to_guc(slpc);\n\tstruct drm_i915_private *i915 = slpc_to_i915(slpc);\n\tintel_wakeref_t wakeref;\n\tint ret = 0;\n\n\tlockdep_assert_held(&slpc->lock);\n\n\tif (!intel_guc_is_ready(guc))\n\t\treturn -ENODEV;\n\n\t \n\n\twith_intel_runtime_pm(&i915->runtime_pm, wakeref) {\n\t\t \n\t\tret = slpc_set_param_nb(slpc,\n\t\t\t\t\tSLPC_PARAM_GLOBAL_MIN_GT_UNSLICE_FREQ_MHZ,\n\t\t\t\t\tfreq);\n\t\tif (ret)\n\t\t\tguc_notice(guc, \"Failed to send set_param for min freq(%d): %pe\\n\",\n\t\t\t\t   freq, ERR_PTR(ret));\n\t}\n\n\treturn ret;\n}\n\nstatic void slpc_boost_work(struct work_struct *work)\n{\n\tstruct intel_guc_slpc *slpc = container_of(work, typeof(*slpc), boost_work);\n\tint err;\n\n\t \n\tmutex_lock(&slpc->lock);\n\tif (atomic_read(&slpc->num_waiters)) {\n\t\terr = slpc_force_min_freq(slpc, slpc->boost_freq);\n\t\tif (!err)\n\t\t\tslpc->num_boosts++;\n\t}\n\tmutex_unlock(&slpc->lock);\n}\n\nint intel_guc_slpc_init(struct intel_guc_slpc *slpc)\n{\n\tstruct intel_guc *guc = slpc_to_guc(slpc);\n\tu32 size = PAGE_ALIGN(sizeof(struct slpc_shared_data));\n\tint err;\n\n\tGEM_BUG_ON(slpc->vma);\n\n\terr = intel_guc_allocate_and_map_vma(guc, size, &slpc->vma, (void **)&slpc->vaddr);\n\tif (unlikely(err)) {\n\t\tguc_probe_error(guc, \"Failed to allocate SLPC struct: %pe\\n\", ERR_PTR(err));\n\t\treturn err;\n\t}\n\n\tslpc->max_freq_softlimit = 0;\n\tslpc->min_freq_softlimit = 0;\n\tslpc->ignore_eff_freq = false;\n\tslpc->min_is_rpmax = false;\n\n\tslpc->boost_freq = 0;\n\tatomic_set(&slpc->num_waiters, 0);\n\tslpc->num_boosts = 0;\n\tslpc->media_ratio_mode = SLPC_MEDIA_RATIO_MODE_DYNAMIC_CONTROL;\n\n\tmutex_init(&slpc->lock);\n\tINIT_WORK(&slpc->boost_work, slpc_boost_work);\n\n\treturn err;\n}\n\nstatic const char *slpc_global_state_to_string(enum slpc_global_state state)\n{\n\tswitch (state) {\n\tcase SLPC_GLOBAL_STATE_NOT_RUNNING:\n\t\treturn \"not running\";\n\tcase SLPC_GLOBAL_STATE_INITIALIZING:\n\t\treturn \"initializing\";\n\tcase SLPC_GLOBAL_STATE_RESETTING:\n\t\treturn \"resetting\";\n\tcase SLPC_GLOBAL_STATE_RUNNING:\n\t\treturn \"running\";\n\tcase SLPC_GLOBAL_STATE_SHUTTING_DOWN:\n\t\treturn \"shutting down\";\n\tcase SLPC_GLOBAL_STATE_ERROR:\n\t\treturn \"error\";\n\tdefault:\n\t\treturn \"unknown\";\n\t}\n}\n\nstatic const char *slpc_get_state_string(struct intel_guc_slpc *slpc)\n{\n\treturn slpc_global_state_to_string(slpc_get_state(slpc));\n}\n\nstatic int guc_action_slpc_reset(struct intel_guc *guc, u32 offset)\n{\n\tu32 request[] = {\n\t\tGUC_ACTION_HOST2GUC_PC_SLPC_REQUEST,\n\t\tSLPC_EVENT(SLPC_EVENT_RESET, 2),\n\t\toffset,\n\t\t0,\n\t};\n\tint ret;\n\n\tret = intel_guc_send(guc, request, ARRAY_SIZE(request));\n\n\treturn ret > 0 ? -EPROTO : ret;\n}\n\nstatic int slpc_reset(struct intel_guc_slpc *slpc)\n{\n\tstruct intel_guc *guc = slpc_to_guc(slpc);\n\tu32 offset = intel_guc_ggtt_offset(guc, slpc->vma);\n\tint ret;\n\n\tret = guc_action_slpc_reset(guc, offset);\n\n\tif (unlikely(ret < 0)) {\n\t\tguc_probe_error(guc, \"SLPC reset action failed: %pe\\n\", ERR_PTR(ret));\n\t\treturn ret;\n\t}\n\n\tif (!ret) {\n\t\tif (wait_for(slpc_is_running(slpc), SLPC_RESET_TIMEOUT_MS)) {\n\t\t\tguc_probe_error(guc, \"SLPC not enabled! State = %s\\n\",\n\t\t\t\t\tslpc_get_state_string(slpc));\n\t\t\treturn -EIO;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic u32 slpc_decode_min_freq(struct intel_guc_slpc *slpc)\n{\n\tstruct slpc_shared_data *data = slpc->vaddr;\n\n\tGEM_BUG_ON(!slpc->vma);\n\n\treturn\tDIV_ROUND_CLOSEST(REG_FIELD_GET(SLPC_MIN_UNSLICE_FREQ_MASK,\n\t\t\t\t  data->task_state_data.freq) *\n\t\t\t\t  GT_FREQUENCY_MULTIPLIER, GEN9_FREQ_SCALER);\n}\n\nstatic u32 slpc_decode_max_freq(struct intel_guc_slpc *slpc)\n{\n\tstruct slpc_shared_data *data = slpc->vaddr;\n\n\tGEM_BUG_ON(!slpc->vma);\n\n\treturn\tDIV_ROUND_CLOSEST(REG_FIELD_GET(SLPC_MAX_UNSLICE_FREQ_MASK,\n\t\t\t\t  data->task_state_data.freq) *\n\t\t\t\t  GT_FREQUENCY_MULTIPLIER, GEN9_FREQ_SCALER);\n}\n\nstatic void slpc_shared_data_reset(struct slpc_shared_data *data)\n{\n\tmemset(data, 0, sizeof(struct slpc_shared_data));\n\n\tdata->header.size = sizeof(struct slpc_shared_data);\n\n\t \n\tslpc_mem_set_enabled(data, SLPC_PARAM_TASK_ENABLE_GTPERF,\n\t\t\t     SLPC_PARAM_TASK_DISABLE_GTPERF);\n\n\tslpc_mem_set_disabled(data, SLPC_PARAM_TASK_ENABLE_BALANCER,\n\t\t\t      SLPC_PARAM_TASK_DISABLE_BALANCER);\n\n\tslpc_mem_set_disabled(data, SLPC_PARAM_TASK_ENABLE_DCC,\n\t\t\t      SLPC_PARAM_TASK_DISABLE_DCC);\n}\n\n \nint intel_guc_slpc_set_max_freq(struct intel_guc_slpc *slpc, u32 val)\n{\n\tstruct drm_i915_private *i915 = slpc_to_i915(slpc);\n\tintel_wakeref_t wakeref;\n\tint ret;\n\n\tif (val < slpc->min_freq ||\n\t    val > slpc->rp0_freq ||\n\t    val < slpc->min_freq_softlimit)\n\t\treturn -EINVAL;\n\n\twith_intel_runtime_pm(&i915->runtime_pm, wakeref) {\n\t\tret = slpc_set_param(slpc,\n\t\t\t\t     SLPC_PARAM_GLOBAL_MAX_GT_UNSLICE_FREQ_MHZ,\n\t\t\t\t     val);\n\n\t\t \n\t\tif (ret)\n\t\t\tret = -EIO;\n\t}\n\n\tif (!ret)\n\t\tslpc->max_freq_softlimit = val;\n\n\treturn ret;\n}\n\n \nint intel_guc_slpc_get_max_freq(struct intel_guc_slpc *slpc, u32 *val)\n{\n\tstruct drm_i915_private *i915 = slpc_to_i915(slpc);\n\tintel_wakeref_t wakeref;\n\tint ret = 0;\n\n\twith_intel_runtime_pm(&i915->runtime_pm, wakeref) {\n\t\t \n\t\tret = slpc_query_task_state(slpc);\n\n\t\tif (!ret)\n\t\t\t*val = slpc_decode_max_freq(slpc);\n\t}\n\n\treturn ret;\n}\n\nint intel_guc_slpc_set_ignore_eff_freq(struct intel_guc_slpc *slpc, bool val)\n{\n\tstruct drm_i915_private *i915 = slpc_to_i915(slpc);\n\tintel_wakeref_t wakeref;\n\tint ret;\n\n\tmutex_lock(&slpc->lock);\n\twakeref = intel_runtime_pm_get(&i915->runtime_pm);\n\n\tret = slpc_set_param(slpc,\n\t\t\t     SLPC_PARAM_IGNORE_EFFICIENT_FREQUENCY,\n\t\t\t     val);\n\tif (ret) {\n\t\tguc_probe_error(slpc_to_guc(slpc), \"Failed to set efficient freq(%d): %pe\\n\",\n\t\t\t\tval, ERR_PTR(ret));\n\t} else {\n\t\tslpc->ignore_eff_freq = val;\n\n\t\t \n\t\tif (val)\n\t\t\tret = slpc_set_param(slpc,\n\t\t\t\t\t     SLPC_PARAM_GLOBAL_MIN_GT_UNSLICE_FREQ_MHZ,\n\t\t\t\t\t     slpc->min_freq);\n\t}\n\n\tintel_runtime_pm_put(&i915->runtime_pm, wakeref);\n\tmutex_unlock(&slpc->lock);\n\treturn ret;\n}\n\n \nint intel_guc_slpc_set_min_freq(struct intel_guc_slpc *slpc, u32 val)\n{\n\tstruct drm_i915_private *i915 = slpc_to_i915(slpc);\n\tintel_wakeref_t wakeref;\n\tint ret;\n\n\tif (val < slpc->min_freq ||\n\t    val > slpc->rp0_freq ||\n\t    val > slpc->max_freq_softlimit)\n\t\treturn -EINVAL;\n\n\t \n\tmutex_lock(&slpc->lock);\n\twakeref = intel_runtime_pm_get(&i915->runtime_pm);\n\n\tret = slpc_set_param(slpc,\n\t\t\t     SLPC_PARAM_GLOBAL_MIN_GT_UNSLICE_FREQ_MHZ,\n\t\t\t     val);\n\n\tif (!ret)\n\t\tslpc->min_freq_softlimit = val;\n\n\tintel_runtime_pm_put(&i915->runtime_pm, wakeref);\n\tmutex_unlock(&slpc->lock);\n\n\t \n\tif (ret)\n\t\tret = -EIO;\n\n\treturn ret;\n}\n\n \nint intel_guc_slpc_get_min_freq(struct intel_guc_slpc *slpc, u32 *val)\n{\n\tstruct drm_i915_private *i915 = slpc_to_i915(slpc);\n\tintel_wakeref_t wakeref;\n\tint ret = 0;\n\n\twith_intel_runtime_pm(&i915->runtime_pm, wakeref) {\n\t\t \n\t\tret = slpc_query_task_state(slpc);\n\n\t\tif (!ret)\n\t\t\t*val = slpc_decode_min_freq(slpc);\n\t}\n\n\treturn ret;\n}\n\nint intel_guc_slpc_set_media_ratio_mode(struct intel_guc_slpc *slpc, u32 val)\n{\n\tstruct drm_i915_private *i915 = slpc_to_i915(slpc);\n\tintel_wakeref_t wakeref;\n\tint ret = 0;\n\n\tif (!HAS_MEDIA_RATIO_MODE(i915))\n\t\treturn -ENODEV;\n\n\twith_intel_runtime_pm(&i915->runtime_pm, wakeref)\n\t\tret = slpc_set_param(slpc,\n\t\t\t\t     SLPC_PARAM_MEDIA_FF_RATIO_MODE,\n\t\t\t\t     val);\n\treturn ret;\n}\n\nvoid intel_guc_pm_intrmsk_enable(struct intel_gt *gt)\n{\n\tu32 pm_intrmsk_mbz = 0;\n\n\t \n\tpm_intrmsk_mbz |= ARAT_EXPIRED_INTRMSK;\n\n\tintel_uncore_rmw(gt->uncore,\n\t\t\t GEN6_PMINTRMSK, pm_intrmsk_mbz, 0);\n}\n\nstatic int slpc_set_softlimits(struct intel_guc_slpc *slpc)\n{\n\tint ret = 0;\n\n\t \n\tif (!slpc->max_freq_softlimit) {\n\t\tslpc->max_freq_softlimit = slpc->rp0_freq;\n\t\tslpc_to_gt(slpc)->defaults.max_freq = slpc->max_freq_softlimit;\n\t} else if (slpc->max_freq_softlimit != slpc->rp0_freq) {\n\t\tret = intel_guc_slpc_set_max_freq(slpc,\n\t\t\t\t\t\t  slpc->max_freq_softlimit);\n\t}\n\n\tif (unlikely(ret))\n\t\treturn ret;\n\n\tif (!slpc->min_freq_softlimit) {\n\t\t \n\t\tslpc->min_freq_softlimit = slpc->min_freq;\n\t\tslpc_to_gt(slpc)->defaults.min_freq = slpc->min_freq_softlimit;\n\t} else {\n\t\treturn intel_guc_slpc_set_min_freq(slpc,\n\t\t\t\t\t\t   slpc->min_freq_softlimit);\n\t}\n\n\treturn 0;\n}\n\nstatic bool is_slpc_min_freq_rpmax(struct intel_guc_slpc *slpc)\n{\n\tint slpc_min_freq;\n\tint ret;\n\n\tret = intel_guc_slpc_get_min_freq(slpc, &slpc_min_freq);\n\tif (ret) {\n\t\tguc_err(slpc_to_guc(slpc), \"Failed to get min freq: %pe\\n\", ERR_PTR(ret));\n\t\treturn false;\n\t}\n\n\tif (slpc_min_freq == SLPC_MAX_FREQ_MHZ)\n\t\treturn true;\n\telse\n\t\treturn false;\n}\n\nstatic void update_server_min_softlimit(struct intel_guc_slpc *slpc)\n{\n\t \n\tif (!slpc->min_freq_softlimit &&\n\t    is_slpc_min_freq_rpmax(slpc)) {\n\t\tslpc->min_is_rpmax = true;\n\t\tslpc->min_freq_softlimit = slpc->rp0_freq;\n\t\t(slpc_to_gt(slpc))->defaults.min_freq = slpc->min_freq_softlimit;\n\t}\n}\n\nstatic int slpc_use_fused_rp0(struct intel_guc_slpc *slpc)\n{\n\t \n\treturn slpc_set_param(slpc,\n\t\t\t      SLPC_PARAM_GLOBAL_MAX_GT_UNSLICE_FREQ_MHZ,\n\t\t\t      slpc->rp0_freq);\n}\n\nstatic void slpc_get_rp_values(struct intel_guc_slpc *slpc)\n{\n\tstruct intel_rps *rps = &slpc_to_gt(slpc)->rps;\n\tstruct intel_rps_freq_caps caps;\n\n\tgen6_rps_get_freq_caps(rps, &caps);\n\tslpc->rp0_freq = intel_gpu_freq(rps, caps.rp0_freq);\n\tslpc->rp1_freq = intel_gpu_freq(rps, caps.rp1_freq);\n\tslpc->min_freq = intel_gpu_freq(rps, caps.min_freq);\n\n\tif (!slpc->boost_freq)\n\t\tslpc->boost_freq = slpc->rp0_freq;\n}\n\n \nint intel_guc_slpc_override_gucrc_mode(struct intel_guc_slpc *slpc, u32 mode)\n{\n\tint ret;\n\tstruct drm_i915_private *i915 = slpc_to_i915(slpc);\n\tintel_wakeref_t wakeref;\n\n\tif (mode >= SLPC_GUCRC_MODE_MAX)\n\t\treturn -EINVAL;\n\n\twith_intel_runtime_pm(&i915->runtime_pm, wakeref) {\n\t\tret = slpc_set_param(slpc, SLPC_PARAM_PWRGATE_RC_MODE, mode);\n\t\tif (ret)\n\t\t\tguc_err(slpc_to_guc(slpc), \"Override RC mode %d failed: %pe\\n\",\n\t\t\t\tmode, ERR_PTR(ret));\n\t}\n\n\treturn ret;\n}\n\nint intel_guc_slpc_unset_gucrc_mode(struct intel_guc_slpc *slpc)\n{\n\tstruct drm_i915_private *i915 = slpc_to_i915(slpc);\n\tintel_wakeref_t wakeref;\n\tint ret = 0;\n\n\twith_intel_runtime_pm(&i915->runtime_pm, wakeref) {\n\t\tret = slpc_unset_param(slpc, SLPC_PARAM_PWRGATE_RC_MODE);\n\t\tif (ret)\n\t\t\tguc_err(slpc_to_guc(slpc), \"Unsetting RC mode failed: %pe\\n\", ERR_PTR(ret));\n\t}\n\n\treturn ret;\n}\n\n \nint intel_guc_slpc_enable(struct intel_guc_slpc *slpc)\n{\n\tstruct intel_guc *guc = slpc_to_guc(slpc);\n\tint ret;\n\n\tGEM_BUG_ON(!slpc->vma);\n\n\tslpc_shared_data_reset(slpc->vaddr);\n\n\tret = slpc_reset(slpc);\n\tif (unlikely(ret < 0)) {\n\t\tguc_probe_error(guc, \"SLPC Reset event returned: %pe\\n\", ERR_PTR(ret));\n\t\treturn ret;\n\t}\n\n\tret = slpc_query_task_state(slpc);\n\tif (unlikely(ret < 0))\n\t\treturn ret;\n\n\tintel_guc_pm_intrmsk_enable(slpc_to_gt(slpc));\n\n\tslpc_get_rp_values(slpc);\n\n\t \n\tupdate_server_min_softlimit(slpc);\n\n\t \n\tret = slpc_use_fused_rp0(slpc);\n\tif (unlikely(ret)) {\n\t\tguc_probe_error(guc, \"Failed to set SLPC max to RP0: %pe\\n\", ERR_PTR(ret));\n\t\treturn ret;\n\t}\n\n\t \n\tintel_guc_slpc_set_ignore_eff_freq(slpc, slpc->ignore_eff_freq);\n\n\t \n\tret = slpc_set_softlimits(slpc);\n\tif (unlikely(ret)) {\n\t\tguc_probe_error(guc, \"Failed to set SLPC softlimits: %pe\\n\", ERR_PTR(ret));\n\t\treturn ret;\n\t}\n\n\t \n\tintel_guc_slpc_set_media_ratio_mode(slpc, slpc->media_ratio_mode);\n\n\treturn 0;\n}\n\nint intel_guc_slpc_set_boost_freq(struct intel_guc_slpc *slpc, u32 val)\n{\n\tint ret = 0;\n\n\tif (val < slpc->min_freq || val > slpc->rp0_freq)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&slpc->lock);\n\n\tif (slpc->boost_freq != val) {\n\t\t \n\t\tif (atomic_read(&slpc->num_waiters)) {\n\t\t\tret = slpc_force_min_freq(slpc, val);\n\t\t\tif (ret) {\n\t\t\t\tret = -EIO;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t}\n\n\t\tslpc->boost_freq = val;\n\t}\n\ndone:\n\tmutex_unlock(&slpc->lock);\n\treturn ret;\n}\n\nvoid intel_guc_slpc_dec_waiters(struct intel_guc_slpc *slpc)\n{\n\t \n\tmutex_lock(&slpc->lock);\n\tif (atomic_dec_and_test(&slpc->num_waiters))\n\t\tslpc_force_min_freq(slpc, slpc->min_freq_softlimit);\n\tmutex_unlock(&slpc->lock);\n}\n\nint intel_guc_slpc_print_info(struct intel_guc_slpc *slpc, struct drm_printer *p)\n{\n\tstruct drm_i915_private *i915 = slpc_to_i915(slpc);\n\tstruct slpc_shared_data *data = slpc->vaddr;\n\tstruct slpc_task_state_data *slpc_tasks;\n\tintel_wakeref_t wakeref;\n\tint ret = 0;\n\n\tGEM_BUG_ON(!slpc->vma);\n\n\twith_intel_runtime_pm(&i915->runtime_pm, wakeref) {\n\t\tret = slpc_query_task_state(slpc);\n\n\t\tif (!ret) {\n\t\t\tslpc_tasks = &data->task_state_data;\n\n\t\t\tdrm_printf(p, \"\\tSLPC state: %s\\n\", slpc_get_state_string(slpc));\n\t\t\tdrm_printf(p, \"\\tGTPERF task active: %s\\n\",\n\t\t\t\t   str_yes_no(slpc_tasks->status & SLPC_GTPERF_TASK_ENABLED));\n\t\t\tdrm_printf(p, \"\\tMax freq: %u MHz\\n\",\n\t\t\t\t   slpc_decode_max_freq(slpc));\n\t\t\tdrm_printf(p, \"\\tMin freq: %u MHz\\n\",\n\t\t\t\t   slpc_decode_min_freq(slpc));\n\t\t\tdrm_printf(p, \"\\twaitboosts: %u\\n\",\n\t\t\t\t   slpc->num_boosts);\n\t\t\tdrm_printf(p, \"\\tBoosts outstanding: %u\\n\",\n\t\t\t\t   atomic_read(&slpc->num_waiters));\n\t\t}\n\t}\n\n\treturn ret;\n}\n\nvoid intel_guc_slpc_fini(struct intel_guc_slpc *slpc)\n{\n\tif (!slpc->vma)\n\t\treturn;\n\n\ti915_vma_unpin_and_release(&slpc->vma, I915_VMA_RELEASE_MAP);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}