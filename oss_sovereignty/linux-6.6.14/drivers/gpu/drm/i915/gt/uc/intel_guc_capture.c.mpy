{
  "module_name": "intel_guc_capture.c",
  "hash_id": "681366b86658f5251a5665a626e4263743078dea5ed87750fa9b116ab7f4eca8",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/i915/gt/uc/intel_guc_capture.c",
  "human_readable_source": "\n \n\n#include <linux/types.h>\n\n#include <drm/drm_print.h>\n\n#include \"gt/intel_engine_regs.h\"\n#include \"gt/intel_gt.h\"\n#include \"gt/intel_gt_mcr.h\"\n#include \"gt/intel_gt_regs.h\"\n#include \"gt/intel_lrc.h\"\n#include \"guc_capture_fwif.h\"\n#include \"intel_guc_capture.h\"\n#include \"intel_guc_fwif.h\"\n#include \"intel_guc_print.h\"\n#include \"i915_drv.h\"\n#include \"i915_gpu_error.h\"\n#include \"i915_irq.h\"\n#include \"i915_memcpy.h\"\n#include \"i915_reg.h\"\n\n \n#define COMMON_BASE_GLOBAL \\\n\t{ FORCEWAKE_MT,             0,      0, \"FORCEWAKE\" }\n\n#define COMMON_GEN8BASE_GLOBAL \\\n\t{ ERROR_GEN6,               0,      0, \"ERROR_GEN6\" }, \\\n\t{ DONE_REG,                 0,      0, \"DONE_REG\" }, \\\n\t{ HSW_GTT_CACHE_EN,         0,      0, \"HSW_GTT_CACHE_EN\" }\n\n#define GEN8_GLOBAL \\\n\t{ GEN8_FAULT_TLB_DATA0,     0,      0, \"GEN8_FAULT_TLB_DATA0\" }, \\\n\t{ GEN8_FAULT_TLB_DATA1,     0,      0, \"GEN8_FAULT_TLB_DATA1\" }\n\n#define COMMON_GEN12BASE_GLOBAL \\\n\t{ GEN12_FAULT_TLB_DATA0,    0,      0, \"GEN12_FAULT_TLB_DATA0\" }, \\\n\t{ GEN12_FAULT_TLB_DATA1,    0,      0, \"GEN12_FAULT_TLB_DATA1\" }, \\\n\t{ GEN12_AUX_ERR_DBG,        0,      0, \"AUX_ERR_DBG\" }, \\\n\t{ GEN12_GAM_DONE,           0,      0, \"GAM_DONE\" }, \\\n\t{ GEN12_RING_FAULT_REG,     0,      0, \"FAULT_REG\" }\n\n#define COMMON_BASE_ENGINE_INSTANCE \\\n\t{ RING_PSMI_CTL(0),         0,      0, \"RC PSMI\" }, \\\n\t{ RING_ESR(0),              0,      0, \"ESR\" }, \\\n\t{ RING_DMA_FADD(0),         0,      0, \"RING_DMA_FADD_LDW\" }, \\\n\t{ RING_DMA_FADD_UDW(0),     0,      0, \"RING_DMA_FADD_UDW\" }, \\\n\t{ RING_IPEIR(0),            0,      0, \"IPEIR\" }, \\\n\t{ RING_IPEHR(0),            0,      0, \"IPEHR\" }, \\\n\t{ RING_INSTPS(0),           0,      0, \"INSTPS\" }, \\\n\t{ RING_BBADDR(0),           0,      0, \"RING_BBADDR_LOW32\" }, \\\n\t{ RING_BBADDR_UDW(0),       0,      0, \"RING_BBADDR_UP32\" }, \\\n\t{ RING_BBSTATE(0),          0,      0, \"BB_STATE\" }, \\\n\t{ CCID(0),                  0,      0, \"CCID\" }, \\\n\t{ RING_ACTHD(0),            0,      0, \"ACTHD_LDW\" }, \\\n\t{ RING_ACTHD_UDW(0),        0,      0, \"ACTHD_UDW\" }, \\\n\t{ RING_INSTPM(0),           0,      0, \"INSTPM\" }, \\\n\t{ RING_INSTDONE(0),         0,      0, \"INSTDONE\" }, \\\n\t{ RING_NOPID(0),            0,      0, \"RING_NOPID\" }, \\\n\t{ RING_START(0),            0,      0, \"START\" }, \\\n\t{ RING_HEAD(0),             0,      0, \"HEAD\" }, \\\n\t{ RING_TAIL(0),             0,      0, \"TAIL\" }, \\\n\t{ RING_CTL(0),              0,      0, \"CTL\" }, \\\n\t{ RING_MI_MODE(0),          0,      0, \"MODE\" }, \\\n\t{ RING_CONTEXT_CONTROL(0),  0,      0, \"RING_CONTEXT_CONTROL\" }, \\\n\t{ RING_HWS_PGA(0),          0,      0, \"HWS\" }, \\\n\t{ RING_MODE_GEN7(0),        0,      0, \"GFX_MODE\" }, \\\n\t{ GEN8_RING_PDP_LDW(0, 0),  0,      0, \"PDP0_LDW\" }, \\\n\t{ GEN8_RING_PDP_UDW(0, 0),  0,      0, \"PDP0_UDW\" }, \\\n\t{ GEN8_RING_PDP_LDW(0, 1),  0,      0, \"PDP1_LDW\" }, \\\n\t{ GEN8_RING_PDP_UDW(0, 1),  0,      0, \"PDP1_UDW\" }, \\\n\t{ GEN8_RING_PDP_LDW(0, 2),  0,      0, \"PDP2_LDW\" }, \\\n\t{ GEN8_RING_PDP_UDW(0, 2),  0,      0, \"PDP2_UDW\" }, \\\n\t{ GEN8_RING_PDP_LDW(0, 3),  0,      0, \"PDP3_LDW\" }, \\\n\t{ GEN8_RING_PDP_UDW(0, 3),  0,      0, \"PDP3_UDW\" }\n\n#define COMMON_BASE_HAS_EU \\\n\t{ EIR,                      0,      0, \"EIR\" }\n\n#define COMMON_BASE_RENDER \\\n\t{ GEN7_SC_INSTDONE,         0,      0, \"GEN7_SC_INSTDONE\" }\n\n#define COMMON_GEN12BASE_RENDER \\\n\t{ GEN12_SC_INSTDONE_EXTRA,  0,      0, \"GEN12_SC_INSTDONE_EXTRA\" }, \\\n\t{ GEN12_SC_INSTDONE_EXTRA2, 0,      0, \"GEN12_SC_INSTDONE_EXTRA2\" }\n\n#define COMMON_GEN12BASE_VEC \\\n\t{ GEN12_SFC_DONE(0),        0,      0, \"SFC_DONE[0]\" }, \\\n\t{ GEN12_SFC_DONE(1),        0,      0, \"SFC_DONE[1]\" }, \\\n\t{ GEN12_SFC_DONE(2),        0,      0, \"SFC_DONE[2]\" }, \\\n\t{ GEN12_SFC_DONE(3),        0,      0, \"SFC_DONE[3]\" }\n\n \nstatic const struct __guc_mmio_reg_descr xe_lp_global_regs[] = {\n\tCOMMON_BASE_GLOBAL,\n\tCOMMON_GEN8BASE_GLOBAL,\n\tCOMMON_GEN12BASE_GLOBAL,\n};\n\n \nstatic const struct __guc_mmio_reg_descr xe_lp_rc_class_regs[] = {\n\tCOMMON_BASE_HAS_EU,\n\tCOMMON_BASE_RENDER,\n\tCOMMON_GEN12BASE_RENDER,\n};\n\n \nstatic const struct __guc_mmio_reg_descr gen8_rc_inst_regs[] = {\n\tCOMMON_BASE_ENGINE_INSTANCE,\n};\n\n \nstatic const struct __guc_mmio_reg_descr gen8_vd_inst_regs[] = {\n\tCOMMON_BASE_ENGINE_INSTANCE,\n};\n\n \nstatic const struct __guc_mmio_reg_descr xe_lp_vec_class_regs[] = {\n\tCOMMON_GEN12BASE_VEC,\n};\n\n \nstatic const struct __guc_mmio_reg_descr gen8_vec_inst_regs[] = {\n\tCOMMON_BASE_ENGINE_INSTANCE,\n};\n\n \nstatic const struct __guc_mmio_reg_descr gen8_blt_inst_regs[] = {\n\tCOMMON_BASE_ENGINE_INSTANCE,\n};\n\n \nstatic const struct __guc_mmio_reg_descr xe_lp_gsc_inst_regs[] = {\n\tCOMMON_BASE_ENGINE_INSTANCE,\n};\n\n \nstatic const struct __guc_mmio_reg_descr gen8_global_regs[] = {\n\tCOMMON_BASE_GLOBAL,\n\tCOMMON_GEN8BASE_GLOBAL,\n\tGEN8_GLOBAL,\n};\n\nstatic const struct __guc_mmio_reg_descr gen8_rc_class_regs[] = {\n\tCOMMON_BASE_HAS_EU,\n\tCOMMON_BASE_RENDER,\n};\n\n \nstatic const struct __guc_mmio_reg_descr empty_regs_list[] = {\n};\n\n#define TO_GCAP_DEF_OWNER(x) (GUC_CAPTURE_LIST_INDEX_##x)\n#define TO_GCAP_DEF_TYPE(x) (GUC_CAPTURE_LIST_TYPE_##x)\n#define MAKE_REGLIST(regslist, regsowner, regstype, class) \\\n\t{ \\\n\t\tregslist, \\\n\t\tARRAY_SIZE(regslist), \\\n\t\tTO_GCAP_DEF_OWNER(regsowner), \\\n\t\tTO_GCAP_DEF_TYPE(regstype), \\\n\t\tclass, \\\n\t\tNULL, \\\n\t}\n\n \nstatic const struct __guc_mmio_reg_descr_group gen8_lists[] = {\n\tMAKE_REGLIST(gen8_global_regs, PF, GLOBAL, 0),\n\tMAKE_REGLIST(gen8_rc_class_regs, PF, ENGINE_CLASS, GUC_CAPTURE_LIST_CLASS_RENDER_COMPUTE),\n\tMAKE_REGLIST(gen8_rc_inst_regs, PF, ENGINE_INSTANCE, GUC_CAPTURE_LIST_CLASS_RENDER_COMPUTE),\n\tMAKE_REGLIST(empty_regs_list, PF, ENGINE_CLASS, GUC_CAPTURE_LIST_CLASS_VIDEO),\n\tMAKE_REGLIST(gen8_vd_inst_regs, PF, ENGINE_INSTANCE, GUC_CAPTURE_LIST_CLASS_VIDEO),\n\tMAKE_REGLIST(empty_regs_list, PF, ENGINE_CLASS, GUC_CAPTURE_LIST_CLASS_VIDEOENHANCE),\n\tMAKE_REGLIST(gen8_vec_inst_regs, PF, ENGINE_INSTANCE, GUC_CAPTURE_LIST_CLASS_VIDEOENHANCE),\n\tMAKE_REGLIST(empty_regs_list, PF, ENGINE_CLASS, GUC_CAPTURE_LIST_CLASS_BLITTER),\n\tMAKE_REGLIST(gen8_blt_inst_regs, PF, ENGINE_INSTANCE, GUC_CAPTURE_LIST_CLASS_BLITTER),\n\tMAKE_REGLIST(empty_regs_list, PF, ENGINE_CLASS, GUC_CAPTURE_LIST_CLASS_GSC_OTHER),\n\tMAKE_REGLIST(empty_regs_list, PF, ENGINE_INSTANCE, GUC_CAPTURE_LIST_CLASS_GSC_OTHER),\n\t{}\n};\n\nstatic const struct __guc_mmio_reg_descr_group xe_lp_lists[] = {\n\tMAKE_REGLIST(xe_lp_global_regs, PF, GLOBAL, 0),\n\tMAKE_REGLIST(xe_lp_rc_class_regs, PF, ENGINE_CLASS, GUC_CAPTURE_LIST_CLASS_RENDER_COMPUTE),\n\tMAKE_REGLIST(gen8_rc_inst_regs, PF, ENGINE_INSTANCE, GUC_CAPTURE_LIST_CLASS_RENDER_COMPUTE),\n\tMAKE_REGLIST(empty_regs_list, PF, ENGINE_CLASS, GUC_CAPTURE_LIST_CLASS_VIDEO),\n\tMAKE_REGLIST(gen8_vd_inst_regs, PF, ENGINE_INSTANCE, GUC_CAPTURE_LIST_CLASS_VIDEO),\n\tMAKE_REGLIST(xe_lp_vec_class_regs, PF, ENGINE_CLASS, GUC_CAPTURE_LIST_CLASS_VIDEOENHANCE),\n\tMAKE_REGLIST(gen8_vec_inst_regs, PF, ENGINE_INSTANCE, GUC_CAPTURE_LIST_CLASS_VIDEOENHANCE),\n\tMAKE_REGLIST(empty_regs_list, PF, ENGINE_CLASS, GUC_CAPTURE_LIST_CLASS_BLITTER),\n\tMAKE_REGLIST(gen8_blt_inst_regs, PF, ENGINE_INSTANCE, GUC_CAPTURE_LIST_CLASS_BLITTER),\n\tMAKE_REGLIST(empty_regs_list, PF, ENGINE_CLASS, GUC_CAPTURE_LIST_CLASS_GSC_OTHER),\n\tMAKE_REGLIST(xe_lp_gsc_inst_regs, PF, ENGINE_INSTANCE, GUC_CAPTURE_LIST_CLASS_GSC_OTHER),\n\t{}\n};\n\nstatic const struct __guc_mmio_reg_descr_group *\nguc_capture_get_one_list(const struct __guc_mmio_reg_descr_group *reglists,\n\t\t\t u32 owner, u32 type, u32 id)\n{\n\tint i;\n\n\tif (!reglists)\n\t\treturn NULL;\n\n\tfor (i = 0; reglists[i].list; ++i) {\n\t\tif (reglists[i].owner == owner && reglists[i].type == type &&\n\t\t    (reglists[i].engine == id || reglists[i].type == GUC_CAPTURE_LIST_TYPE_GLOBAL))\n\t\t\treturn &reglists[i];\n\t}\n\n\treturn NULL;\n}\n\nstatic struct __guc_mmio_reg_descr_group *\nguc_capture_get_one_ext_list(struct __guc_mmio_reg_descr_group *reglists,\n\t\t\t     u32 owner, u32 type, u32 id)\n{\n\tint i;\n\n\tif (!reglists)\n\t\treturn NULL;\n\n\tfor (i = 0; reglists[i].extlist; ++i) {\n\t\tif (reglists[i].owner == owner && reglists[i].type == type &&\n\t\t    (reglists[i].engine == id || reglists[i].type == GUC_CAPTURE_LIST_TYPE_GLOBAL))\n\t\t\treturn &reglists[i];\n\t}\n\n\treturn NULL;\n}\n\nstatic void guc_capture_free_extlists(struct __guc_mmio_reg_descr_group *reglists)\n{\n\tint i = 0;\n\n\tif (!reglists)\n\t\treturn;\n\n\twhile (reglists[i].extlist)\n\t\tkfree(reglists[i++].extlist);\n}\n\nstruct __ext_steer_reg {\n\tconst char *name;\n\ti915_mcr_reg_t reg;\n};\n\nstatic const struct __ext_steer_reg gen8_extregs[] = {\n\t{\"GEN8_SAMPLER_INSTDONE\", GEN8_SAMPLER_INSTDONE},\n\t{\"GEN8_ROW_INSTDONE\", GEN8_ROW_INSTDONE}\n};\n\nstatic const struct __ext_steer_reg xehpg_extregs[] = {\n\t{\"XEHPG_INSTDONE_GEOM_SVG\", XEHPG_INSTDONE_GEOM_SVG}\n};\n\nstatic void __fill_ext_reg(struct __guc_mmio_reg_descr *ext,\n\t\t\t   const struct __ext_steer_reg *extlist,\n\t\t\t   int slice_id, int subslice_id)\n{\n\text->reg = _MMIO(i915_mmio_reg_offset(extlist->reg));\n\text->flags = FIELD_PREP(GUC_REGSET_STEERING_GROUP, slice_id);\n\text->flags |= FIELD_PREP(GUC_REGSET_STEERING_INSTANCE, subslice_id);\n\text->regname = extlist->name;\n}\n\nstatic int\n__alloc_ext_regs(struct __guc_mmio_reg_descr_group *newlist,\n\t\t const struct __guc_mmio_reg_descr_group *rootlist, int num_regs)\n{\n\tstruct __guc_mmio_reg_descr *list;\n\n\tlist = kcalloc(num_regs, sizeof(struct __guc_mmio_reg_descr), GFP_KERNEL);\n\tif (!list)\n\t\treturn -ENOMEM;\n\n\tnewlist->extlist = list;\n\tnewlist->num_regs = num_regs;\n\tnewlist->owner = rootlist->owner;\n\tnewlist->engine = rootlist->engine;\n\tnewlist->type = rootlist->type;\n\n\treturn 0;\n}\n\nstatic void\nguc_capture_alloc_steered_lists(struct intel_guc *guc,\n\t\t\t\tconst struct __guc_mmio_reg_descr_group *lists)\n{\n\tstruct intel_gt *gt = guc_to_gt(guc);\n\tint slice, subslice, iter, i, num_steer_regs, num_tot_regs = 0;\n\tconst struct __guc_mmio_reg_descr_group *list;\n\tstruct __guc_mmio_reg_descr_group *extlists;\n\tstruct __guc_mmio_reg_descr *extarray;\n\tbool has_xehpg_extregs;\n\n\t \n\tlist = guc_capture_get_one_list(lists, GUC_CAPTURE_LIST_INDEX_PF,\n\t\t\t\t\tGUC_CAPTURE_LIST_TYPE_ENGINE_CLASS,\n\t\t\t\t\tGUC_CAPTURE_LIST_CLASS_RENDER_COMPUTE);\n\t \n\tif (!list || guc->capture->extlists)\n\t\treturn;\n\n\thas_xehpg_extregs = GRAPHICS_VER_FULL(gt->i915) >= IP_VER(12, 55);\n\n\tnum_steer_regs = ARRAY_SIZE(gen8_extregs);\n\tif (has_xehpg_extregs)\n\t\tnum_steer_regs += ARRAY_SIZE(xehpg_extregs);\n\n\tfor_each_ss_steering(iter, gt, slice, subslice)\n\t\tnum_tot_regs += num_steer_regs;\n\n\tif (!num_tot_regs)\n\t\treturn;\n\n\t \n\textlists = kcalloc(2, sizeof(struct __guc_mmio_reg_descr_group), GFP_KERNEL);\n\tif (!extlists)\n\t\treturn;\n\n\tif (__alloc_ext_regs(&extlists[0], list, num_tot_regs)) {\n\t\tkfree(extlists);\n\t\treturn;\n\t}\n\n\textarray = extlists[0].extlist;\n\tfor_each_ss_steering(iter, gt, slice, subslice) {\n\t\tfor (i = 0; i < ARRAY_SIZE(gen8_extregs); ++i) {\n\t\t\t__fill_ext_reg(extarray, &gen8_extregs[i], slice, subslice);\n\t\t\t++extarray;\n\t\t}\n\n\t\tif (has_xehpg_extregs) {\n\t\t\tfor (i = 0; i < ARRAY_SIZE(xehpg_extregs); ++i) {\n\t\t\t\t__fill_ext_reg(extarray, &xehpg_extregs[i], slice, subslice);\n\t\t\t\t++extarray;\n\t\t\t}\n\t\t}\n\t}\n\n\tguc_dbg(guc, \"capture found %d ext-regs.\\n\", num_tot_regs);\n\tguc->capture->extlists = extlists;\n}\n\nstatic const struct __guc_mmio_reg_descr_group *\nguc_capture_get_device_reglist(struct intel_guc *guc)\n{\n\tstruct drm_i915_private *i915 = guc_to_gt(guc)->i915;\n\tconst struct __guc_mmio_reg_descr_group *lists;\n\n\tif (GRAPHICS_VER(i915) >= 12)\n\t\tlists = xe_lp_lists;\n\telse\n\t\tlists = gen8_lists;\n\n\t \n\tguc_capture_alloc_steered_lists(guc, lists);\n\n\treturn lists;\n}\n\nstatic const char *\n__stringify_type(u32 type)\n{\n\tswitch (type) {\n\tcase GUC_CAPTURE_LIST_TYPE_GLOBAL:\n\t\treturn \"Global\";\n\tcase GUC_CAPTURE_LIST_TYPE_ENGINE_CLASS:\n\t\treturn \"Class\";\n\tcase GUC_CAPTURE_LIST_TYPE_ENGINE_INSTANCE:\n\t\treturn \"Instance\";\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn \"unknown\";\n}\n\nstatic const char *\n__stringify_engclass(u32 class)\n{\n\tswitch (class) {\n\tcase GUC_CAPTURE_LIST_CLASS_RENDER_COMPUTE:\n\t\treturn \"Render/Compute\";\n\tcase GUC_CAPTURE_LIST_CLASS_VIDEO:\n\t\treturn \"Video\";\n\tcase GUC_CAPTURE_LIST_CLASS_VIDEOENHANCE:\n\t\treturn \"VideoEnhance\";\n\tcase GUC_CAPTURE_LIST_CLASS_BLITTER:\n\t\treturn \"Blitter\";\n\tcase GUC_CAPTURE_LIST_CLASS_GSC_OTHER:\n\t\treturn \"GSC-Other\";\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn \"unknown\";\n}\n\nstatic int\nguc_capture_list_init(struct intel_guc *guc, u32 owner, u32 type, u32 classid,\n\t\t      struct guc_mmio_reg *ptr, u16 num_entries)\n{\n\tu32 i = 0, j = 0;\n\tconst struct __guc_mmio_reg_descr_group *reglists = guc->capture->reglists;\n\tstruct __guc_mmio_reg_descr_group *extlists = guc->capture->extlists;\n\tconst struct __guc_mmio_reg_descr_group *match;\n\tstruct __guc_mmio_reg_descr_group *matchext;\n\n\tif (!reglists)\n\t\treturn -ENODEV;\n\n\tmatch = guc_capture_get_one_list(reglists, owner, type, classid);\n\tif (!match)\n\t\treturn -ENODATA;\n\n\tfor (i = 0; i < num_entries && i < match->num_regs; ++i) {\n\t\tptr[i].offset = match->list[i].reg.reg;\n\t\tptr[i].value = 0xDEADF00D;\n\t\tptr[i].flags = match->list[i].flags;\n\t\tptr[i].mask = match->list[i].mask;\n\t}\n\n\tmatchext = guc_capture_get_one_ext_list(extlists, owner, type, classid);\n\tif (matchext) {\n\t\tfor (i = match->num_regs, j = 0; i < num_entries &&\n\t\t     i < (match->num_regs + matchext->num_regs) &&\n\t\t\tj < matchext->num_regs; ++i, ++j) {\n\t\t\tptr[i].offset = matchext->extlist[j].reg.reg;\n\t\t\tptr[i].value = 0xDEADF00D;\n\t\t\tptr[i].flags = matchext->extlist[j].flags;\n\t\t\tptr[i].mask = matchext->extlist[j].mask;\n\t\t}\n\t}\n\tif (i < num_entries)\n\t\tguc_dbg(guc, \"Got short capture reglist init: %d out %d.\\n\", i, num_entries);\n\n\treturn 0;\n}\n\nstatic int\nguc_cap_list_num_regs(struct intel_guc_state_capture *gc, u32 owner, u32 type, u32 classid)\n{\n\tconst struct __guc_mmio_reg_descr_group *match;\n\tstruct __guc_mmio_reg_descr_group *matchext;\n\tint num_regs;\n\n\tmatch = guc_capture_get_one_list(gc->reglists, owner, type, classid);\n\tif (!match)\n\t\treturn 0;\n\n\tnum_regs = match->num_regs;\n\n\tmatchext = guc_capture_get_one_ext_list(gc->extlists, owner, type, classid);\n\tif (matchext)\n\t\tnum_regs += matchext->num_regs;\n\n\treturn num_regs;\n}\n\nstatic int\nguc_capture_getlistsize(struct intel_guc *guc, u32 owner, u32 type, u32 classid,\n\t\t\tsize_t *size, bool is_purpose_est)\n{\n\tstruct intel_guc_state_capture *gc = guc->capture;\n\tstruct __guc_capture_ads_cache *cache = &gc->ads_cache[owner][type][classid];\n\tint num_regs;\n\n\tif (!gc->reglists) {\n\t\tguc_warn(guc, \"No capture reglist for this device\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tif (cache->is_valid) {\n\t\t*size = cache->size;\n\t\treturn cache->status;\n\t}\n\n\tif (!is_purpose_est && owner == GUC_CAPTURE_LIST_INDEX_PF &&\n\t    !guc_capture_get_one_list(gc->reglists, owner, type, classid)) {\n\t\tif (type == GUC_CAPTURE_LIST_TYPE_GLOBAL)\n\t\t\tguc_warn(guc, \"Missing capture reglist: global!\\n\");\n\t\telse\n\t\t\tguc_warn(guc, \"Missing capture reglist: %s(%u):%s(%u)!\\n\",\n\t\t\t\t __stringify_type(type), type,\n\t\t\t\t __stringify_engclass(classid), classid);\n\t\treturn -ENODATA;\n\t}\n\n\tnum_regs = guc_cap_list_num_regs(gc, owner, type, classid);\n\t \n\tif (!num_regs)\n\t\treturn -ENODATA;\n\n\tif (size)\n\t\t*size = PAGE_ALIGN((sizeof(struct guc_debug_capture_list)) +\n\t\t\t\t   (num_regs * sizeof(struct guc_mmio_reg)));\n\n\treturn 0;\n}\n\nint\nintel_guc_capture_getlistsize(struct intel_guc *guc, u32 owner, u32 type, u32 classid,\n\t\t\t      size_t *size)\n{\n\treturn guc_capture_getlistsize(guc, owner, type, classid, size, false);\n}\n\nstatic void guc_capture_create_prealloc_nodes(struct intel_guc *guc);\n\nint\nintel_guc_capture_getlist(struct intel_guc *guc, u32 owner, u32 type, u32 classid,\n\t\t\t  void **outptr)\n{\n\tstruct intel_guc_state_capture *gc = guc->capture;\n\tstruct __guc_capture_ads_cache *cache = &gc->ads_cache[owner][type][classid];\n\tstruct guc_debug_capture_list *listnode;\n\tint ret, num_regs;\n\tu8 *caplist, *tmp;\n\tsize_t size = 0;\n\n\tif (!gc->reglists)\n\t\treturn -ENODEV;\n\n\tif (cache->is_valid) {\n\t\t*outptr = cache->ptr;\n\t\treturn cache->status;\n\t}\n\n\t \n\tguc_capture_create_prealloc_nodes(guc);\n\n\tret = intel_guc_capture_getlistsize(guc, owner, type, classid, &size);\n\tif (ret) {\n\t\tcache->is_valid = true;\n\t\tcache->ptr = NULL;\n\t\tcache->size = 0;\n\t\tcache->status = ret;\n\t\treturn ret;\n\t}\n\n\tcaplist = kzalloc(size, GFP_KERNEL);\n\tif (!caplist) {\n\t\tguc_dbg(guc, \"Failed to alloc cached register capture list\");\n\t\treturn -ENOMEM;\n\t}\n\n\t \n\ttmp = caplist;\n\tnum_regs = guc_cap_list_num_regs(guc->capture, owner, type, classid);\n\tlistnode = (struct guc_debug_capture_list *)tmp;\n\tlistnode->header.info = FIELD_PREP(GUC_CAPTURELISTHDR_NUMDESCR, (u32)num_regs);\n\n\t \n\ttmp += sizeof(struct guc_debug_capture_list);\n\tguc_capture_list_init(guc, owner, type, classid, (struct guc_mmio_reg *)tmp, num_regs);\n\n\t \n\tcache->is_valid = true;\n\tcache->ptr = caplist;\n\tcache->size = size;\n\tcache->status = 0;\n\n\t*outptr = caplist;\n\n\treturn 0;\n}\n\nint\nintel_guc_capture_getnullheader(struct intel_guc *guc,\n\t\t\t\tvoid **outptr, size_t *size)\n{\n\tstruct intel_guc_state_capture *gc = guc->capture;\n\tint tmp = sizeof(u32) * 4;\n\tvoid *null_header;\n\n\tif (gc->ads_null_cache) {\n\t\t*outptr = gc->ads_null_cache;\n\t\t*size = tmp;\n\t\treturn 0;\n\t}\n\n\tnull_header = kzalloc(tmp, GFP_KERNEL);\n\tif (!null_header) {\n\t\tguc_dbg(guc, \"Failed to alloc cached register capture null list\");\n\t\treturn -ENOMEM;\n\t}\n\n\tgc->ads_null_cache = null_header;\n\t*outptr = null_header;\n\t*size = tmp;\n\n\treturn 0;\n}\n\nstatic int\nguc_capture_output_min_size_est(struct intel_guc *guc)\n{\n\tstruct intel_gt *gt = guc_to_gt(guc);\n\tstruct intel_engine_cs *engine;\n\tenum intel_engine_id id;\n\tint worst_min_size = 0;\n\tsize_t tmp = 0;\n\n\tif (!guc->capture)\n\t\treturn -ENODEV;\n\n\t \n\tfor_each_engine(engine, gt, id) {\n\t\tworst_min_size += sizeof(struct guc_state_capture_group_header_t) +\n\t\t\t\t\t (3 * sizeof(struct guc_state_capture_header_t));\n\n\t\tif (!guc_capture_getlistsize(guc, 0, GUC_CAPTURE_LIST_TYPE_GLOBAL, 0, &tmp, true))\n\t\t\tworst_min_size += tmp;\n\n\t\tif (!guc_capture_getlistsize(guc, 0, GUC_CAPTURE_LIST_TYPE_ENGINE_CLASS,\n\t\t\t\t\t     engine->class, &tmp, true)) {\n\t\t\tworst_min_size += tmp;\n\t\t}\n\t\tif (!guc_capture_getlistsize(guc, 0, GUC_CAPTURE_LIST_TYPE_ENGINE_INSTANCE,\n\t\t\t\t\t     engine->class, &tmp, true)) {\n\t\t\tworst_min_size += tmp;\n\t\t}\n\t}\n\n\treturn worst_min_size;\n}\n\n \n#define GUC_CAPTURE_OVERBUFFER_MULTIPLIER 3\n\nstatic void check_guc_capture_size(struct intel_guc *guc)\n{\n\tint min_size = guc_capture_output_min_size_est(guc);\n\tint spare_size = min_size * GUC_CAPTURE_OVERBUFFER_MULTIPLIER;\n\tu32 buffer_size = intel_guc_log_section_size_capture(&guc->log);\n\n\t \n\tif (min_size < 0)\n\t\tguc_warn(guc, \"Failed to calculate error state capture buffer minimum size: %d!\\n\",\n\t\t\t min_size);\n\telse if (min_size > buffer_size)\n\t\tguc_warn(guc, \"Error state capture buffer maybe small: %d < %d\\n\",\n\t\t\t buffer_size, min_size);\n\telse if (spare_size > buffer_size)\n\t\tguc_dbg(guc, \"Error state capture buffer lacks spare size: %d < %d (min = %d)\\n\",\n\t\t\tbuffer_size, spare_size, min_size);\n}\n\n \n\nstatic int guc_capture_buf_cnt(struct __guc_capture_bufstate *buf)\n{\n\tif (buf->wr >= buf->rd)\n\t\treturn (buf->wr - buf->rd);\n\treturn (buf->size - buf->rd) + buf->wr;\n}\n\nstatic int guc_capture_buf_cnt_to_end(struct __guc_capture_bufstate *buf)\n{\n\tif (buf->rd > buf->wr)\n\t\treturn (buf->size - buf->rd);\n\treturn (buf->wr - buf->rd);\n}\n\n \nstatic int\nguc_capture_log_remove_dw(struct intel_guc *guc, struct __guc_capture_bufstate *buf,\n\t\t\t  u32 *dw)\n{\n\tint tries = 2;\n\tint avail = 0;\n\tu32 *src_data;\n\n\tif (!guc_capture_buf_cnt(buf))\n\t\treturn 0;\n\n\twhile (tries--) {\n\t\tavail = guc_capture_buf_cnt_to_end(buf);\n\t\tif (avail >= sizeof(u32)) {\n\t\t\tsrc_data = (u32 *)(buf->data + buf->rd);\n\t\t\t*dw = *src_data;\n\t\t\tbuf->rd += 4;\n\t\t\treturn 4;\n\t\t}\n\t\tif (avail)\n\t\t\tguc_dbg(guc, \"Register capture log not dword aligned, skipping.\\n\");\n\t\tbuf->rd = 0;\n\t}\n\n\treturn 0;\n}\n\nstatic bool\nguc_capture_data_extracted(struct __guc_capture_bufstate *b,\n\t\t\t   int size, void *dest)\n{\n\tif (guc_capture_buf_cnt_to_end(b) >= size) {\n\t\tmemcpy(dest, (b->data + b->rd), size);\n\t\tb->rd += size;\n\t\treturn true;\n\t}\n\treturn false;\n}\n\nstatic int\nguc_capture_log_get_group_hdr(struct intel_guc *guc, struct __guc_capture_bufstate *buf,\n\t\t\t      struct guc_state_capture_group_header_t *ghdr)\n{\n\tint read = 0;\n\tint fullsize = sizeof(struct guc_state_capture_group_header_t);\n\n\tif (fullsize > guc_capture_buf_cnt(buf))\n\t\treturn -1;\n\n\tif (guc_capture_data_extracted(buf, fullsize, (void *)ghdr))\n\t\treturn 0;\n\n\tread += guc_capture_log_remove_dw(guc, buf, &ghdr->owner);\n\tread += guc_capture_log_remove_dw(guc, buf, &ghdr->info);\n\tif (read != fullsize)\n\t\treturn -1;\n\n\treturn 0;\n}\n\nstatic int\nguc_capture_log_get_data_hdr(struct intel_guc *guc, struct __guc_capture_bufstate *buf,\n\t\t\t     struct guc_state_capture_header_t *hdr)\n{\n\tint read = 0;\n\tint fullsize = sizeof(struct guc_state_capture_header_t);\n\n\tif (fullsize > guc_capture_buf_cnt(buf))\n\t\treturn -1;\n\n\tif (guc_capture_data_extracted(buf, fullsize, (void *)hdr))\n\t\treturn 0;\n\n\tread += guc_capture_log_remove_dw(guc, buf, &hdr->owner);\n\tread += guc_capture_log_remove_dw(guc, buf, &hdr->info);\n\tread += guc_capture_log_remove_dw(guc, buf, &hdr->lrca);\n\tread += guc_capture_log_remove_dw(guc, buf, &hdr->guc_id);\n\tread += guc_capture_log_remove_dw(guc, buf, &hdr->num_mmios);\n\tif (read != fullsize)\n\t\treturn -1;\n\n\treturn 0;\n}\n\nstatic int\nguc_capture_log_get_register(struct intel_guc *guc, struct __guc_capture_bufstate *buf,\n\t\t\t     struct guc_mmio_reg *reg)\n{\n\tint read = 0;\n\tint fullsize = sizeof(struct guc_mmio_reg);\n\n\tif (fullsize > guc_capture_buf_cnt(buf))\n\t\treturn -1;\n\n\tif (guc_capture_data_extracted(buf, fullsize, (void *)reg))\n\t\treturn 0;\n\n\tread += guc_capture_log_remove_dw(guc, buf, &reg->offset);\n\tread += guc_capture_log_remove_dw(guc, buf, &reg->value);\n\tread += guc_capture_log_remove_dw(guc, buf, &reg->flags);\n\tread += guc_capture_log_remove_dw(guc, buf, &reg->mask);\n\tif (read != fullsize)\n\t\treturn -1;\n\n\treturn 0;\n}\n\nstatic void\nguc_capture_delete_one_node(struct intel_guc *guc, struct __guc_capture_parsed_output *node)\n{\n\tint i;\n\n\tfor (i = 0; i < GUC_CAPTURE_LIST_TYPE_MAX; ++i)\n\t\tkfree(node->reginfo[i].regs);\n\tlist_del(&node->link);\n\tkfree(node);\n}\n\nstatic void\nguc_capture_delete_prealloc_nodes(struct intel_guc *guc)\n{\n\tstruct __guc_capture_parsed_output *n, *ntmp;\n\n\t \n\tlist_for_each_entry_safe(n, ntmp, &guc->capture->outlist, link)\n\t\tguc_capture_delete_one_node(guc, n);\n\n\tlist_for_each_entry_safe(n, ntmp, &guc->capture->cachelist, link)\n\t\tguc_capture_delete_one_node(guc, n);\n}\n\nstatic void\nguc_capture_add_node_to_list(struct __guc_capture_parsed_output *node,\n\t\t\t     struct list_head *list)\n{\n\tlist_add_tail(&node->link, list);\n}\n\nstatic void\nguc_capture_add_node_to_outlist(struct intel_guc_state_capture *gc,\n\t\t\t\tstruct __guc_capture_parsed_output *node)\n{\n\tguc_capture_add_node_to_list(node, &gc->outlist);\n}\n\nstatic void\nguc_capture_add_node_to_cachelist(struct intel_guc_state_capture *gc,\n\t\t\t\t  struct __guc_capture_parsed_output *node)\n{\n\tguc_capture_add_node_to_list(node, &gc->cachelist);\n}\n\nstatic void\nguc_capture_init_node(struct intel_guc *guc, struct __guc_capture_parsed_output *node)\n{\n\tstruct guc_mmio_reg *tmp[GUC_CAPTURE_LIST_TYPE_MAX];\n\tint i;\n\n\tfor (i = 0; i < GUC_CAPTURE_LIST_TYPE_MAX; ++i) {\n\t\ttmp[i] = node->reginfo[i].regs;\n\t\tmemset(tmp[i], 0, sizeof(struct guc_mmio_reg) *\n\t\t       guc->capture->max_mmio_per_node);\n\t}\n\tmemset(node, 0, sizeof(*node));\n\tfor (i = 0; i < GUC_CAPTURE_LIST_TYPE_MAX; ++i)\n\t\tnode->reginfo[i].regs = tmp[i];\n\n\tINIT_LIST_HEAD(&node->link);\n}\n\nstatic struct __guc_capture_parsed_output *\nguc_capture_get_prealloc_node(struct intel_guc *guc)\n{\n\tstruct __guc_capture_parsed_output *found = NULL;\n\n\tif (!list_empty(&guc->capture->cachelist)) {\n\t\tstruct __guc_capture_parsed_output *n, *ntmp;\n\n\t\t \n\t\tlist_for_each_entry_safe(n, ntmp, &guc->capture->cachelist, link) {\n\t\t\tfound = n;\n\t\t\tlist_del(&n->link);\n\t\t\tbreak;\n\t\t}\n\t} else {\n\t\tstruct __guc_capture_parsed_output *n, *ntmp;\n\n\t\t \n\t\tlist_for_each_entry_safe(n, ntmp, &guc->capture->outlist, link) {\n\t\t\tfound = n;\n\t\t}\n\t\tif (found)\n\t\t\tlist_del(&found->link);\n\t}\n\tif (found)\n\t\tguc_capture_init_node(guc, found);\n\n\treturn found;\n}\n\nstatic struct __guc_capture_parsed_output *\nguc_capture_alloc_one_node(struct intel_guc *guc)\n{\n\tstruct __guc_capture_parsed_output *new;\n\tint i;\n\n\tnew = kzalloc(sizeof(*new), GFP_KERNEL);\n\tif (!new)\n\t\treturn NULL;\n\n\tfor (i = 0; i < GUC_CAPTURE_LIST_TYPE_MAX; ++i) {\n\t\tnew->reginfo[i].regs = kcalloc(guc->capture->max_mmio_per_node,\n\t\t\t\t\t       sizeof(struct guc_mmio_reg), GFP_KERNEL);\n\t\tif (!new->reginfo[i].regs) {\n\t\t\twhile (i)\n\t\t\t\tkfree(new->reginfo[--i].regs);\n\t\t\tkfree(new);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\tguc_capture_init_node(guc, new);\n\n\treturn new;\n}\n\nstatic struct __guc_capture_parsed_output *\nguc_capture_clone_node(struct intel_guc *guc, struct __guc_capture_parsed_output *original,\n\t\t       u32 keep_reglist_mask)\n{\n\tstruct __guc_capture_parsed_output *new;\n\tint i;\n\n\tnew = guc_capture_get_prealloc_node(guc);\n\tif (!new)\n\t\treturn NULL;\n\tif (!original)\n\t\treturn new;\n\n\tnew->is_partial = original->is_partial;\n\n\t \n\tfor (i = 0; i < GUC_CAPTURE_LIST_TYPE_MAX; ++i) {\n\t\tif (keep_reglist_mask & BIT(i)) {\n\t\t\tGEM_BUG_ON(original->reginfo[i].num_regs  >\n\t\t\t\t   guc->capture->max_mmio_per_node);\n\n\t\t\tmemcpy(new->reginfo[i].regs, original->reginfo[i].regs,\n\t\t\t       original->reginfo[i].num_regs * sizeof(struct guc_mmio_reg));\n\n\t\t\tnew->reginfo[i].num_regs = original->reginfo[i].num_regs;\n\t\t\tnew->reginfo[i].vfid  = original->reginfo[i].vfid;\n\n\t\t\tif (i == GUC_CAPTURE_LIST_TYPE_ENGINE_CLASS) {\n\t\t\t\tnew->eng_class = original->eng_class;\n\t\t\t} else if (i == GUC_CAPTURE_LIST_TYPE_ENGINE_INSTANCE) {\n\t\t\t\tnew->eng_inst = original->eng_inst;\n\t\t\t\tnew->guc_id = original->guc_id;\n\t\t\t\tnew->lrca = original->lrca;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn new;\n}\n\nstatic void\n__guc_capture_create_prealloc_nodes(struct intel_guc *guc)\n{\n\tstruct __guc_capture_parsed_output *node = NULL;\n\tint i;\n\n\tfor (i = 0; i < PREALLOC_NODES_MAX_COUNT; ++i) {\n\t\tnode = guc_capture_alloc_one_node(guc);\n\t\tif (!node) {\n\t\t\tguc_warn(guc, \"Register capture pre-alloc-cache failure\\n\");\n\t\t\t \n\t\t\treturn;\n\t\t}\n\t\tguc_capture_add_node_to_cachelist(guc->capture, node);\n\t}\n}\n\nstatic int\nguc_get_max_reglist_count(struct intel_guc *guc)\n{\n\tint i, j, k, tmp, maxregcount = 0;\n\n\tfor (i = 0; i < GUC_CAPTURE_LIST_INDEX_MAX; ++i) {\n\t\tfor (j = 0; j < GUC_CAPTURE_LIST_TYPE_MAX; ++j) {\n\t\t\tfor (k = 0; k < GUC_MAX_ENGINE_CLASSES; ++k) {\n\t\t\t\tif (j == GUC_CAPTURE_LIST_TYPE_GLOBAL && k > 0)\n\t\t\t\t\tcontinue;\n\n\t\t\t\ttmp = guc_cap_list_num_regs(guc->capture, i, j, k);\n\t\t\t\tif (tmp > maxregcount)\n\t\t\t\t\tmaxregcount = tmp;\n\t\t\t}\n\t\t}\n\t}\n\tif (!maxregcount)\n\t\tmaxregcount = PREALLOC_NODES_DEFAULT_NUMREGS;\n\n\treturn maxregcount;\n}\n\nstatic void\nguc_capture_create_prealloc_nodes(struct intel_guc *guc)\n{\n\t \n\tif (guc->capture->max_mmio_per_node)\n\t\treturn;\n\n\tguc->capture->max_mmio_per_node = guc_get_max_reglist_count(guc);\n\t__guc_capture_create_prealloc_nodes(guc);\n}\n\nstatic int\nguc_capture_extract_reglists(struct intel_guc *guc, struct __guc_capture_bufstate *buf)\n{\n\tstruct guc_state_capture_group_header_t ghdr = {0};\n\tstruct guc_state_capture_header_t hdr = {0};\n\tstruct __guc_capture_parsed_output *node = NULL;\n\tstruct guc_mmio_reg *regs = NULL;\n\tint i, numlists, numregs, ret = 0;\n\tenum guc_capture_type datatype;\n\tstruct guc_mmio_reg tmp;\n\tbool is_partial = false;\n\n\ti = guc_capture_buf_cnt(buf);\n\tif (!i)\n\t\treturn -ENODATA;\n\tif (i % sizeof(u32)) {\n\t\tguc_warn(guc, \"Got mis-aligned register capture entries\\n\");\n\t\tret = -EIO;\n\t\tgoto bailout;\n\t}\n\n\t \n\tif (guc_capture_log_get_group_hdr(guc, buf, &ghdr)) {\n\t\tret = -EIO;\n\t\tgoto bailout;\n\t}\n\t \n\tis_partial = FIELD_GET(CAP_GRP_HDR_CAPTURE_TYPE, ghdr.info);\n\tnumlists = FIELD_GET(CAP_GRP_HDR_NUM_CAPTURES, ghdr.info);\n\n\twhile (numlists--) {\n\t\tif (guc_capture_log_get_data_hdr(guc, buf, &hdr)) {\n\t\t\tret = -EIO;\n\t\t\tbreak;\n\t\t}\n\n\t\tdatatype = FIELD_GET(CAP_HDR_CAPTURE_TYPE, hdr.info);\n\t\tif (datatype > GUC_CAPTURE_LIST_TYPE_ENGINE_INSTANCE) {\n\t\t\t \n\t\t\tnumregs = FIELD_GET(CAP_HDR_NUM_MMIOS, hdr.num_mmios);\n\t\t\twhile (numregs--) {\n\t\t\t\tif (guc_capture_log_get_register(guc, buf, &tmp)) {\n\t\t\t\t\tret = -EIO;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcontinue;\n\t\t} else if (node) {\n\t\t\t \n\t\t\tif (datatype == GUC_CAPTURE_LIST_TYPE_GLOBAL) {\n\t\t\t\tguc_capture_add_node_to_outlist(guc->capture, node);\n\t\t\t\tnode = NULL;\n\t\t\t} else if (datatype == GUC_CAPTURE_LIST_TYPE_ENGINE_CLASS &&\n\t\t\t\t   node->reginfo[GUC_CAPTURE_LIST_TYPE_ENGINE_CLASS].num_regs) {\n\t\t\t\t \n\t\t\t\tguc_capture_add_node_to_outlist(guc->capture, node);\n\t\t\t\tnode = guc_capture_clone_node(guc, node,\n\t\t\t\t\t\t\t      GCAP_PARSED_REGLIST_INDEX_GLOBAL);\n\t\t\t} else if (datatype == GUC_CAPTURE_LIST_TYPE_ENGINE_INSTANCE &&\n\t\t\t\t   node->reginfo[GUC_CAPTURE_LIST_TYPE_ENGINE_INSTANCE].num_regs) {\n\t\t\t\t \n\t\t\t\tguc_capture_add_node_to_outlist(guc->capture, node);\n\t\t\t\tnode = guc_capture_clone_node(guc, node,\n\t\t\t\t\t\t\t      (GCAP_PARSED_REGLIST_INDEX_GLOBAL |\n\t\t\t\t\t\t\t      GCAP_PARSED_REGLIST_INDEX_ENGCLASS));\n\t\t\t}\n\t\t}\n\n\t\tif (!node) {\n\t\t\tnode = guc_capture_get_prealloc_node(guc);\n\t\t\tif (!node) {\n\t\t\t\tret = -ENOMEM;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (datatype != GUC_CAPTURE_LIST_TYPE_GLOBAL)\n\t\t\t\tguc_dbg(guc, \"Register capture missing global dump: %08x!\\n\",\n\t\t\t\t\tdatatype);\n\t\t}\n\t\tnode->is_partial = is_partial;\n\t\tnode->reginfo[datatype].vfid = FIELD_GET(CAP_HDR_CAPTURE_VFID, hdr.owner);\n\t\tswitch (datatype) {\n\t\tcase GUC_CAPTURE_LIST_TYPE_ENGINE_INSTANCE:\n\t\t\tnode->eng_class = FIELD_GET(CAP_HDR_ENGINE_CLASS, hdr.info);\n\t\t\tnode->eng_inst = FIELD_GET(CAP_HDR_ENGINE_INSTANCE, hdr.info);\n\t\t\tnode->lrca = hdr.lrca;\n\t\t\tnode->guc_id = hdr.guc_id;\n\t\t\tbreak;\n\t\tcase GUC_CAPTURE_LIST_TYPE_ENGINE_CLASS:\n\t\t\tnode->eng_class = FIELD_GET(CAP_HDR_ENGINE_CLASS, hdr.info);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\n\t\tnumregs = FIELD_GET(CAP_HDR_NUM_MMIOS, hdr.num_mmios);\n\t\tif (numregs > guc->capture->max_mmio_per_node) {\n\t\t\tguc_dbg(guc, \"Register capture list extraction clipped by prealloc!\\n\");\n\t\t\tnumregs = guc->capture->max_mmio_per_node;\n\t\t}\n\t\tnode->reginfo[datatype].num_regs = numregs;\n\t\tregs = node->reginfo[datatype].regs;\n\t\ti = 0;\n\t\twhile (numregs--) {\n\t\t\tif (guc_capture_log_get_register(guc, buf, &regs[i++])) {\n\t\t\t\tret = -EIO;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\nbailout:\n\tif (node) {\n\t\t \n\t\tfor (i = GUC_CAPTURE_LIST_TYPE_GLOBAL; i < GUC_CAPTURE_LIST_TYPE_MAX; ++i) {\n\t\t\tif (node->reginfo[i].regs) {\n\t\t\t\tguc_capture_add_node_to_outlist(guc->capture, node);\n\t\t\t\tnode = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (node)  \n\t\t\tguc_capture_add_node_to_cachelist(guc->capture, node);\n\t}\n\treturn ret;\n}\n\nstatic int __guc_capture_flushlog_complete(struct intel_guc *guc)\n{\n\tu32 action[] = {\n\t\tINTEL_GUC_ACTION_LOG_BUFFER_FILE_FLUSH_COMPLETE,\n\t\tGUC_CAPTURE_LOG_BUFFER\n\t};\n\n\treturn intel_guc_send_nb(guc, action, ARRAY_SIZE(action), 0);\n\n}\n\nstatic void __guc_capture_process_output(struct intel_guc *guc)\n{\n\tunsigned int buffer_size, read_offset, write_offset, full_count;\n\tstruct intel_uc *uc = container_of(guc, typeof(*uc), guc);\n\tstruct guc_log_buffer_state log_buf_state_local;\n\tstruct guc_log_buffer_state *log_buf_state;\n\tstruct __guc_capture_bufstate buf;\n\tvoid *src_data = NULL;\n\tbool new_overflow;\n\tint ret;\n\n\tlog_buf_state = guc->log.buf_addr +\n\t\t\t(sizeof(struct guc_log_buffer_state) * GUC_CAPTURE_LOG_BUFFER);\n\tsrc_data = guc->log.buf_addr +\n\t\t   intel_guc_get_log_buffer_offset(&guc->log, GUC_CAPTURE_LOG_BUFFER);\n\n\t \n\tmemcpy(&log_buf_state_local, log_buf_state, sizeof(struct guc_log_buffer_state));\n\tbuffer_size = intel_guc_get_log_buffer_size(&guc->log, GUC_CAPTURE_LOG_BUFFER);\n\tread_offset = log_buf_state_local.read_ptr;\n\twrite_offset = log_buf_state_local.sampled_write_ptr;\n\tfull_count = log_buf_state_local.buffer_full_cnt;\n\n\t \n\tguc->log.stats[GUC_CAPTURE_LOG_BUFFER].flush += log_buf_state_local.flush_to_file;\n\tnew_overflow = intel_guc_check_log_buf_overflow(&guc->log, GUC_CAPTURE_LOG_BUFFER,\n\t\t\t\t\t\t\tfull_count);\n\n\t \n\tif (unlikely(new_overflow)) {\n\t\t \n\t\tread_offset = 0;\n\t\twrite_offset = buffer_size;\n\t} else if (unlikely((read_offset > buffer_size) ||\n\t\t\t(write_offset > buffer_size))) {\n\t\tguc_err(guc, \"Register capture buffer in invalid state: read = 0x%X, size = 0x%X!\\n\",\n\t\t\tread_offset, buffer_size);\n\t\t \n\t\tread_offset = 0;\n\t\twrite_offset = buffer_size;\n\t}\n\n\tbuf.size = buffer_size;\n\tbuf.rd = read_offset;\n\tbuf.wr = write_offset;\n\tbuf.data = src_data;\n\n\tif (!uc->reset_in_progress) {\n\t\tdo {\n\t\t\tret = guc_capture_extract_reglists(guc, &buf);\n\t\t} while (ret >= 0);\n\t}\n\n\t \n\tlog_buf_state->read_ptr = write_offset;\n\tlog_buf_state->flush_to_file = 0;\n\t__guc_capture_flushlog_complete(guc);\n}\n\n#if IS_ENABLED(CONFIG_DRM_I915_CAPTURE_ERROR)\n\nstatic const char *\nguc_capture_reg_to_str(const struct intel_guc *guc, u32 owner, u32 type,\n\t\t       u32 class, u32 id, u32 offset, u32 *is_ext)\n{\n\tconst struct __guc_mmio_reg_descr_group *reglists = guc->capture->reglists;\n\tstruct __guc_mmio_reg_descr_group *extlists = guc->capture->extlists;\n\tconst struct __guc_mmio_reg_descr_group *match;\n\tstruct __guc_mmio_reg_descr_group *matchext;\n\tint j;\n\n\t*is_ext = 0;\n\tif (!reglists)\n\t\treturn NULL;\n\n\tmatch = guc_capture_get_one_list(reglists, owner, type, id);\n\tif (!match)\n\t\treturn NULL;\n\n\tfor (j = 0; j < match->num_regs; ++j) {\n\t\tif (offset == match->list[j].reg.reg)\n\t\t\treturn match->list[j].regname;\n\t}\n\tif (extlists) {\n\t\tmatchext = guc_capture_get_one_ext_list(extlists, owner, type, id);\n\t\tif (!matchext)\n\t\t\treturn NULL;\n\t\tfor (j = 0; j < matchext->num_regs; ++j) {\n\t\t\tif (offset == matchext->extlist[j].reg.reg) {\n\t\t\t\t*is_ext = 1;\n\t\t\t\treturn matchext->extlist[j].regname;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn NULL;\n}\n\n#define GCAP_PRINT_INTEL_ENG_INFO(ebuf, eng) \\\n\tdo { \\\n\t\ti915_error_printf(ebuf, \"    i915-Eng-Name: %s command stream\\n\", \\\n\t\t\t\t  (eng)->name); \\\n\t\ti915_error_printf(ebuf, \"    i915-Eng-Inst-Class: 0x%02x\\n\", (eng)->class); \\\n\t\ti915_error_printf(ebuf, \"    i915-Eng-Inst-Id: 0x%02x\\n\", (eng)->instance); \\\n\t\ti915_error_printf(ebuf, \"    i915-Eng-LogicalMask: 0x%08x\\n\", \\\n\t\t\t\t  (eng)->logical_mask); \\\n\t} while (0)\n\n#define GCAP_PRINT_GUC_INST_INFO(ebuf, node) \\\n\tdo { \\\n\t\ti915_error_printf(ebuf, \"    GuC-Engine-Inst-Id: 0x%08x\\n\", \\\n\t\t\t\t  (node)->eng_inst); \\\n\t\ti915_error_printf(ebuf, \"    GuC-Context-Id: 0x%08x\\n\", (node)->guc_id); \\\n\t\ti915_error_printf(ebuf, \"    LRCA: 0x%08x\\n\", (node)->lrca); \\\n\t} while (0)\n\nint intel_guc_capture_print_engine_node(struct drm_i915_error_state_buf *ebuf,\n\t\t\t\t\tconst struct intel_engine_coredump *ee)\n{\n\tconst char *grptype[GUC_STATE_CAPTURE_GROUP_TYPE_MAX] = {\n\t\t\"full-capture\",\n\t\t\"partial-capture\"\n\t};\n\tconst char *datatype[GUC_CAPTURE_LIST_TYPE_MAX] = {\n\t\t\"Global\",\n\t\t\"Engine-Class\",\n\t\t\"Engine-Instance\"\n\t};\n\tstruct intel_guc_state_capture *cap;\n\tstruct __guc_capture_parsed_output *node;\n\tstruct intel_engine_cs *eng;\n\tstruct guc_mmio_reg *regs;\n\tstruct intel_guc *guc;\n\tconst char *str;\n\tint numregs, i, j;\n\tu32 is_ext;\n\n\tif (!ebuf || !ee)\n\t\treturn -EINVAL;\n\tcap = ee->guc_capture;\n\tif (!cap || !ee->engine)\n\t\treturn -ENODEV;\n\n\tguc = &ee->engine->gt->uc.guc;\n\n\ti915_error_printf(ebuf, \"global --- GuC Error Capture on %s command stream:\\n\",\n\t\t\t  ee->engine->name);\n\n\tnode = ee->guc_capture_node;\n\tif (!node) {\n\t\ti915_error_printf(ebuf, \"  No matching ee-node\\n\");\n\t\treturn 0;\n\t}\n\n\ti915_error_printf(ebuf, \"Coverage:  %s\\n\", grptype[node->is_partial]);\n\n\tfor (i = GUC_CAPTURE_LIST_TYPE_GLOBAL; i < GUC_CAPTURE_LIST_TYPE_MAX; ++i) {\n\t\ti915_error_printf(ebuf, \"  RegListType: %s\\n\",\n\t\t\t\t  datatype[i % GUC_CAPTURE_LIST_TYPE_MAX]);\n\t\ti915_error_printf(ebuf, \"    Owner-Id: %d\\n\", node->reginfo[i].vfid);\n\n\t\tswitch (i) {\n\t\tcase GUC_CAPTURE_LIST_TYPE_GLOBAL:\n\t\tdefault:\n\t\t\tbreak;\n\t\tcase GUC_CAPTURE_LIST_TYPE_ENGINE_CLASS:\n\t\t\ti915_error_printf(ebuf, \"    GuC-Eng-Class: %d\\n\", node->eng_class);\n\t\t\ti915_error_printf(ebuf, \"    i915-Eng-Class: %d\\n\",\n\t\t\t\t\t  guc_class_to_engine_class(node->eng_class));\n\t\t\tbreak;\n\t\tcase GUC_CAPTURE_LIST_TYPE_ENGINE_INSTANCE:\n\t\t\teng = intel_guc_lookup_engine(guc, node->eng_class, node->eng_inst);\n\t\t\tif (eng)\n\t\t\t\tGCAP_PRINT_INTEL_ENG_INFO(ebuf, eng);\n\t\t\telse\n\t\t\t\ti915_error_printf(ebuf, \"    i915-Eng-Lookup Fail!\\n\");\n\t\t\tGCAP_PRINT_GUC_INST_INFO(ebuf, node);\n\t\t\tbreak;\n\t\t}\n\n\t\tnumregs = node->reginfo[i].num_regs;\n\t\ti915_error_printf(ebuf, \"    NumRegs: %d\\n\", numregs);\n\t\tj = 0;\n\t\twhile (numregs--) {\n\t\t\tregs = node->reginfo[i].regs;\n\t\t\tstr = guc_capture_reg_to_str(guc, GUC_CAPTURE_LIST_INDEX_PF, i,\n\t\t\t\t\t\t     node->eng_class, 0, regs[j].offset, &is_ext);\n\t\t\tif (!str)\n\t\t\t\ti915_error_printf(ebuf, \"      REG-0x%08x\", regs[j].offset);\n\t\t\telse\n\t\t\t\ti915_error_printf(ebuf, \"      %s\", str);\n\t\t\tif (is_ext)\n\t\t\t\ti915_error_printf(ebuf, \"[%ld][%ld]\",\n\t\t\t\t\tFIELD_GET(GUC_REGSET_STEERING_GROUP, regs[j].flags),\n\t\t\t\t\tFIELD_GET(GUC_REGSET_STEERING_INSTANCE, regs[j].flags));\n\t\t\ti915_error_printf(ebuf, \":  0x%08x\\n\", regs[j].value);\n\t\t\t++j;\n\t\t}\n\t}\n\treturn 0;\n}\n\n#endif \n\nstatic void guc_capture_find_ecode(struct intel_engine_coredump *ee)\n{\n\tstruct gcap_reg_list_info *reginfo;\n\tstruct guc_mmio_reg *regs;\n\ti915_reg_t reg_ipehr = RING_IPEHR(0);\n\ti915_reg_t reg_instdone = RING_INSTDONE(0);\n\tint i;\n\n\tif (!ee->guc_capture_node)\n\t\treturn;\n\n\treginfo = ee->guc_capture_node->reginfo + GUC_CAPTURE_LIST_TYPE_ENGINE_INSTANCE;\n\tregs = reginfo->regs;\n\tfor (i = 0; i < reginfo->num_regs; i++) {\n\t\tif (regs[i].offset == reg_ipehr.reg)\n\t\t\tee->ipehr = regs[i].value;\n\t\telse if (regs[i].offset == reg_instdone.reg)\n\t\t\tee->instdone.instdone = regs[i].value;\n\t}\n}\n\nvoid intel_guc_capture_free_node(struct intel_engine_coredump *ee)\n{\n\tif (!ee || !ee->guc_capture_node)\n\t\treturn;\n\n\tguc_capture_add_node_to_cachelist(ee->guc_capture, ee->guc_capture_node);\n\tee->guc_capture = NULL;\n\tee->guc_capture_node = NULL;\n}\n\nbool intel_guc_capture_is_matching_engine(struct intel_gt *gt,\n\t\t\t\t\t  struct intel_context *ce,\n\t\t\t\t\t  struct intel_engine_cs *engine)\n{\n\tstruct __guc_capture_parsed_output *n;\n\tstruct intel_guc *guc;\n\n\tif (!gt || !ce || !engine)\n\t\treturn false;\n\n\tguc = &gt->uc.guc;\n\tif (!guc->capture)\n\t\treturn false;\n\n\t \n\tlist_for_each_entry(n, &guc->capture->outlist, link) {\n\t\tif (n->eng_inst == GUC_ID_TO_ENGINE_INSTANCE(engine->guc_id) &&\n\t\t    n->eng_class == GUC_ID_TO_ENGINE_CLASS(engine->guc_id) &&\n\t\t    n->guc_id == ce->guc_id.id &&\n\t\t    (n->lrca & CTX_GTT_ADDRESS_MASK) == (ce->lrc.lrca & CTX_GTT_ADDRESS_MASK))\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}\n\nvoid intel_guc_capture_get_matching_node(struct intel_gt *gt,\n\t\t\t\t\t struct intel_engine_coredump *ee,\n\t\t\t\t\t struct intel_context *ce)\n{\n\tstruct __guc_capture_parsed_output *n, *ntmp;\n\tstruct intel_guc *guc;\n\n\tif (!gt || !ee || !ce)\n\t\treturn;\n\n\tguc = &gt->uc.guc;\n\tif (!guc->capture)\n\t\treturn;\n\n\tGEM_BUG_ON(ee->guc_capture_node);\n\n\t \n\tlist_for_each_entry_safe(n, ntmp, &guc->capture->outlist, link) {\n\t\tif (n->eng_inst == GUC_ID_TO_ENGINE_INSTANCE(ee->engine->guc_id) &&\n\t\t    n->eng_class == GUC_ID_TO_ENGINE_CLASS(ee->engine->guc_id) &&\n\t\t    n->guc_id == ce->guc_id.id &&\n\t\t    (n->lrca & CTX_GTT_ADDRESS_MASK) == (ce->lrc.lrca & CTX_GTT_ADDRESS_MASK)) {\n\t\t\tlist_del(&n->link);\n\t\t\tee->guc_capture_node = n;\n\t\t\tee->guc_capture = guc->capture;\n\t\t\tguc_capture_find_ecode(ee);\n\t\t\treturn;\n\t\t}\n\t}\n\n\tguc_warn(guc, \"No register capture node found for 0x%04X / 0x%08X\\n\",\n\t\t ce->guc_id.id, ce->lrc.lrca);\n}\n\nvoid intel_guc_capture_process(struct intel_guc *guc)\n{\n\tif (guc->capture)\n\t\t__guc_capture_process_output(guc);\n}\n\nstatic void\nguc_capture_free_ads_cache(struct intel_guc_state_capture *gc)\n{\n\tint i, j, k;\n\tstruct __guc_capture_ads_cache *cache;\n\n\tfor (i = 0; i < GUC_CAPTURE_LIST_INDEX_MAX; ++i) {\n\t\tfor (j = 0; j < GUC_CAPTURE_LIST_TYPE_MAX; ++j) {\n\t\t\tfor (k = 0; k < GUC_MAX_ENGINE_CLASSES; ++k) {\n\t\t\t\tcache = &gc->ads_cache[i][j][k];\n\t\t\t\tif (cache->is_valid)\n\t\t\t\t\tkfree(cache->ptr);\n\t\t\t}\n\t\t}\n\t}\n\tkfree(gc->ads_null_cache);\n}\n\nvoid intel_guc_capture_destroy(struct intel_guc *guc)\n{\n\tif (!guc->capture)\n\t\treturn;\n\n\tguc_capture_free_ads_cache(guc->capture);\n\n\tguc_capture_delete_prealloc_nodes(guc);\n\n\tguc_capture_free_extlists(guc->capture->extlists);\n\tkfree(guc->capture->extlists);\n\n\tkfree(guc->capture);\n\tguc->capture = NULL;\n}\n\nint intel_guc_capture_init(struct intel_guc *guc)\n{\n\tguc->capture = kzalloc(sizeof(*guc->capture), GFP_KERNEL);\n\tif (!guc->capture)\n\t\treturn -ENOMEM;\n\n\tguc->capture->reglists = guc_capture_get_device_reglist(guc);\n\n\tINIT_LIST_HEAD(&guc->capture->outlist);\n\tINIT_LIST_HEAD(&guc->capture->cachelist);\n\n\tcheck_guc_capture_size(guc);\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}