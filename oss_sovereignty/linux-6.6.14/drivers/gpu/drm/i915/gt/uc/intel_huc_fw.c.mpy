{
  "module_name": "intel_huc_fw.c",
  "hash_id": "8eeb557b526d28220f938e68e176b6ea7f8bc214521f19137739bde6a7312fc4",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/i915/gt/uc/intel_huc_fw.c",
  "human_readable_source": "\n \n\n#include \"gt/intel_gsc.h\"\n#include \"gt/intel_gt.h\"\n#include \"intel_gsc_binary_headers.h\"\n#include \"intel_gsc_uc_heci_cmd_submit.h\"\n#include \"intel_huc.h\"\n#include \"intel_huc_fw.h\"\n#include \"intel_huc_print.h\"\n#include \"i915_drv.h\"\n#include \"pxp/intel_pxp_huc.h\"\n#include \"pxp/intel_pxp_cmd_interface_43.h\"\n\nstruct mtl_huc_auth_msg_in {\n\tstruct intel_gsc_mtl_header header;\n\tstruct pxp43_new_huc_auth_in huc_in;\n} __packed;\n\nstruct mtl_huc_auth_msg_out {\n\tstruct intel_gsc_mtl_header header;\n\tstruct pxp43_huc_auth_out huc_out;\n} __packed;\n\nint intel_huc_fw_auth_via_gsccs(struct intel_huc *huc)\n{\n\tstruct intel_gt *gt = huc_to_gt(huc);\n\tstruct drm_i915_gem_object *obj;\n\tstruct mtl_huc_auth_msg_in *msg_in;\n\tstruct mtl_huc_auth_msg_out *msg_out;\n\tvoid *pkt_vaddr;\n\tu64 pkt_offset;\n\tint retry = 5;\n\tint err = 0;\n\n\tif (!huc->heci_pkt)\n\t\treturn -ENODEV;\n\n\tobj = huc->heci_pkt->obj;\n\tpkt_offset = i915_ggtt_offset(huc->heci_pkt);\n\n\tpkt_vaddr = i915_gem_object_pin_map_unlocked(obj,\n\t\t\t\t\t\t     intel_gt_coherent_map_type(gt, obj, true));\n\tif (IS_ERR(pkt_vaddr))\n\t\treturn PTR_ERR(pkt_vaddr);\n\n\tmsg_in = pkt_vaddr;\n\tmsg_out = pkt_vaddr + PXP43_HUC_AUTH_INOUT_SIZE;\n\n\tintel_gsc_uc_heci_cmd_emit_mtl_header(&msg_in->header,\n\t\t\t\t\t      HECI_MEADDRESS_PXP,\n\t\t\t\t\t      sizeof(*msg_in), 0);\n\n\tmsg_in->huc_in.header.api_version = PXP_APIVER(4, 3);\n\tmsg_in->huc_in.header.command_id = PXP43_CMDID_NEW_HUC_AUTH;\n\tmsg_in->huc_in.header.status = 0;\n\tmsg_in->huc_in.header.buffer_len = sizeof(msg_in->huc_in) -\n\t\t\t\t\t   sizeof(msg_in->huc_in.header);\n\tmsg_in->huc_in.huc_base_address = huc->fw.vma_res.start;\n\tmsg_in->huc_in.huc_size = huc->fw.obj->base.size;\n\n\tdo {\n\t\terr = intel_gsc_uc_heci_cmd_submit_packet(&gt->uc.gsc,\n\t\t\t\t\t\t\t  pkt_offset, sizeof(*msg_in),\n\t\t\t\t\t\t\t  pkt_offset + PXP43_HUC_AUTH_INOUT_SIZE,\n\t\t\t\t\t\t\t  PXP43_HUC_AUTH_INOUT_SIZE);\n\t\tif (err) {\n\t\t\thuc_err(huc, \"failed to submit GSC request to auth: %d\\n\", err);\n\t\t\tgoto out_unpin;\n\t\t}\n\n\t\tif (msg_out->header.flags & GSC_OUTFLAG_MSG_PENDING) {\n\t\t\tmsg_in->header.gsc_message_handle = msg_out->header.gsc_message_handle;\n\t\t\terr = -EBUSY;\n\t\t\tmsleep(50);\n\t\t}\n\t} while (--retry && err == -EBUSY);\n\n\tif (err)\n\t\tgoto out_unpin;\n\n\tif (msg_out->header.message_size != sizeof(*msg_out)) {\n\t\thuc_err(huc, \"invalid GSC reply length %u [expected %zu]\\n\",\n\t\t\tmsg_out->header.message_size, sizeof(*msg_out));\n\t\terr = -EPROTO;\n\t\tgoto out_unpin;\n\t}\n\n\t \n\tif (msg_out->huc_out.header.status != PXP_STATUS_SUCCESS &&\n\t    msg_out->huc_out.header.status != PXP_STATUS_OP_NOT_PERMITTED) {\n\t\thuc_err(huc, \"auth failed with GSC error = 0x%x\\n\",\n\t\t\tmsg_out->huc_out.header.status);\n\t\terr = -EIO;\n\t\tgoto out_unpin;\n\t}\n\nout_unpin:\n\ti915_gem_object_unpin_map(obj);\n\treturn err;\n}\n\nstatic bool css_valid(const void *data, size_t size)\n{\n\tconst struct uc_css_header *css = data;\n\n\tif (unlikely(size < sizeof(struct uc_css_header)))\n\t\treturn false;\n\n\tif (css->module_type != 0x6)\n\t\treturn false;\n\n\tif (css->module_vendor != PCI_VENDOR_ID_INTEL)\n\t\treturn false;\n\n\treturn true;\n}\n\nstatic inline u32 entry_offset(const struct intel_gsc_cpd_entry *entry)\n{\n\treturn entry->offset & INTEL_GSC_CPD_ENTRY_OFFSET_MASK;\n}\n\nint intel_huc_fw_get_binary_info(struct intel_uc_fw *huc_fw, const void *data, size_t size)\n{\n\tstruct intel_huc *huc = container_of(huc_fw, struct intel_huc, fw);\n\tconst struct intel_gsc_cpd_header_v2 *header = data;\n\tconst struct intel_gsc_cpd_entry *entry;\n\tsize_t min_size = sizeof(*header);\n\tint i;\n\n\tif (!huc_fw->has_gsc_headers) {\n\t\thuc_err(huc, \"Invalid FW type for GSC header parsing!\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (size < sizeof(*header)) {\n\t\thuc_err(huc, \"FW too small! %zu < %zu\\n\", size, min_size);\n\t\treturn -ENODATA;\n\t}\n\n\t \n\n\tif (header->header_marker != INTEL_GSC_CPD_HEADER_MARKER) {\n\t\thuc_err(huc, \"invalid marker for CPD header: 0x%08x!\\n\",\n\t\t\theader->header_marker);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (header->header_version != 2 || header->entry_version != 1) {\n\t\thuc_err(huc, \"invalid CPD header/entry version %u:%u!\\n\",\n\t\t\theader->header_version, header->entry_version);\n\t\treturn -EINVAL;\n\t}\n\n\tif (header->header_length < sizeof(struct intel_gsc_cpd_header_v2)) {\n\t\thuc_err(huc, \"invalid CPD header length %u!\\n\",\n\t\t\theader->header_length);\n\t\treturn -EINVAL;\n\t}\n\n\tmin_size = header->header_length + sizeof(*entry) * header->num_of_entries;\n\tif (size < min_size) {\n\t\thuc_err(huc, \"FW too small! %zu < %zu\\n\", size, min_size);\n\t\treturn -ENODATA;\n\t}\n\n\tentry = data + header->header_length;\n\n\tfor (i = 0; i < header->num_of_entries; i++, entry++) {\n\t\tif (strcmp(entry->name, \"HUCP.man\") == 0)\n\t\t\tintel_uc_fw_version_from_gsc_manifest(&huc_fw->file_selected.ver,\n\t\t\t\t\t\t\t      data + entry_offset(entry));\n\n\t\tif (strcmp(entry->name, \"huc_fw\") == 0) {\n\t\t\tu32 offset = entry_offset(entry);\n\n\t\t\tif (offset < size && css_valid(data + offset, size - offset))\n\t\t\t\thuc_fw->dma_start_offset = offset;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nint intel_huc_fw_load_and_auth_via_gsc(struct intel_huc *huc)\n{\n\tint ret;\n\n\tif (!intel_huc_is_loaded_by_gsc(huc))\n\t\treturn -ENODEV;\n\n\tif (!intel_uc_fw_is_loadable(&huc->fw))\n\t\treturn -ENOEXEC;\n\n\t \n\tif (intel_huc_is_authenticated(huc, INTEL_HUC_AUTH_BY_GSC)) {\n\t\tintel_uc_fw_change_status(&huc->fw, INTEL_UC_FIRMWARE_RUNNING);\n\t\treturn 0;\n\t}\n\n\tGEM_WARN_ON(intel_uc_fw_is_loaded(&huc->fw));\n\n\tret = intel_pxp_huc_load_and_auth(huc_to_gt(huc)->i915->pxp);\n\tif (ret)\n\t\treturn ret;\n\n\tintel_uc_fw_change_status(&huc->fw, INTEL_UC_FIRMWARE_TRANSFERRED);\n\n\treturn intel_huc_wait_for_auth_complete(huc, INTEL_HUC_AUTH_BY_GSC);\n}\n\n \nint intel_huc_fw_upload(struct intel_huc *huc)\n{\n\tif (intel_huc_is_loaded_by_gsc(huc))\n\t\treturn -ENODEV;\n\n\t \n\treturn intel_uc_fw_upload(&huc->fw, 0, HUC_UKERNEL);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}