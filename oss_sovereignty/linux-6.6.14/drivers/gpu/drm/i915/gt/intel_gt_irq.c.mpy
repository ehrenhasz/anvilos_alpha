{
  "module_name": "intel_gt_irq.c",
  "hash_id": "05e1a55aba873c3b27d7d1fa949106e8f63a6e6ee466f351f0789be9e43cf932",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/i915/gt/intel_gt_irq.c",
  "human_readable_source": "\n \n\n#include <linux/sched/clock.h>\n\n#include \"i915_drv.h\"\n#include \"i915_irq.h\"\n#include \"i915_reg.h\"\n#include \"intel_breadcrumbs.h\"\n#include \"intel_gt.h\"\n#include \"intel_gt_irq.h\"\n#include \"intel_gt_print.h\"\n#include \"intel_gt_regs.h\"\n#include \"intel_uncore.h\"\n#include \"intel_rps.h\"\n#include \"pxp/intel_pxp_irq.h\"\n#include \"uc/intel_gsc_proxy.h\"\n\nstatic void guc_irq_handler(struct intel_guc *guc, u16 iir)\n{\n\tif (unlikely(!guc->interrupts.enabled))\n\t\treturn;\n\n\tif (iir & GUC_INTR_GUC2HOST)\n\t\tintel_guc_to_host_event_handler(guc);\n}\n\nstatic u32\ngen11_gt_engine_identity(struct intel_gt *gt,\n\t\t\t const unsigned int bank, const unsigned int bit)\n{\n\tvoid __iomem * const regs = intel_uncore_regs(gt->uncore);\n\tu32 timeout_ts;\n\tu32 ident;\n\n\tlockdep_assert_held(gt->irq_lock);\n\n\traw_reg_write(regs, GEN11_IIR_REG_SELECTOR(bank), BIT(bit));\n\n\t \n\ttimeout_ts = (local_clock() >> 10) + 100;\n\tdo {\n\t\tident = raw_reg_read(regs, GEN11_INTR_IDENTITY_REG(bank));\n\t} while (!(ident & GEN11_INTR_DATA_VALID) &&\n\t\t !time_after32(local_clock() >> 10, timeout_ts));\n\n\tif (unlikely(!(ident & GEN11_INTR_DATA_VALID))) {\n\t\tgt_err(gt, \"INTR_IDENTITY_REG%u:%u 0x%08x not valid!\\n\",\n\t\t       bank, bit, ident);\n\t\treturn 0;\n\t}\n\n\traw_reg_write(regs, GEN11_INTR_IDENTITY_REG(bank),\n\t\t      GEN11_INTR_DATA_VALID);\n\n\treturn ident;\n}\n\nstatic void\ngen11_other_irq_handler(struct intel_gt *gt, const u8 instance,\n\t\t\tconst u16 iir)\n{\n\tstruct intel_gt *media_gt = gt->i915->media_gt;\n\n\tif (instance == OTHER_GUC_INSTANCE)\n\t\treturn guc_irq_handler(&gt->uc.guc, iir);\n\tif (instance == OTHER_MEDIA_GUC_INSTANCE && media_gt)\n\t\treturn guc_irq_handler(&media_gt->uc.guc, iir);\n\n\tif (instance == OTHER_GTPM_INSTANCE)\n\t\treturn gen11_rps_irq_handler(&gt->rps, iir);\n\tif (instance == OTHER_MEDIA_GTPM_INSTANCE && media_gt)\n\t\treturn gen11_rps_irq_handler(&media_gt->rps, iir);\n\n\tif (instance == OTHER_KCR_INSTANCE)\n\t\treturn intel_pxp_irq_handler(gt->i915->pxp, iir);\n\n\tif (instance == OTHER_GSC_INSTANCE)\n\t\treturn intel_gsc_irq_handler(gt, iir);\n\n\tif (instance == OTHER_GSC_HECI_2_INSTANCE)\n\t\treturn intel_gsc_proxy_irq_handler(&gt->uc.gsc, iir);\n\n\tWARN_ONCE(1, \"unhandled other interrupt instance=0x%x, iir=0x%x\\n\",\n\t\t  instance, iir);\n}\n\nstatic struct intel_gt *pick_gt(struct intel_gt *gt, u8 class, u8 instance)\n{\n\tstruct intel_gt *media_gt = gt->i915->media_gt;\n\n\t \n\tGEM_BUG_ON(gt == media_gt);\n\n\tif (!media_gt)\n\t\treturn gt;\n\n\tswitch (class) {\n\tcase VIDEO_DECODE_CLASS:\n\tcase VIDEO_ENHANCEMENT_CLASS:\n\t\treturn media_gt;\n\tcase OTHER_CLASS:\n\t\tif (instance == OTHER_GSC_HECI_2_INSTANCE)\n\t\t\treturn media_gt;\n\t\tif ((instance == OTHER_GSC_INSTANCE || instance == OTHER_KCR_INSTANCE) &&\n\t\t    HAS_ENGINE(media_gt, GSC0))\n\t\t\treturn media_gt;\n\t\tfallthrough;\n\tdefault:\n\t\treturn gt;\n\t}\n}\n\nstatic void\ngen11_gt_identity_handler(struct intel_gt *gt, const u32 identity)\n{\n\tconst u8 class = GEN11_INTR_ENGINE_CLASS(identity);\n\tconst u8 instance = GEN11_INTR_ENGINE_INSTANCE(identity);\n\tconst u16 intr = GEN11_INTR_ENGINE_INTR(identity);\n\n\tif (unlikely(!intr))\n\t\treturn;\n\n\t \n\tgt = pick_gt(gt, class, instance);\n\n\tif (class <= MAX_ENGINE_CLASS && instance <= MAX_ENGINE_INSTANCE) {\n\t\tstruct intel_engine_cs *engine = gt->engine_class[class][instance];\n\t\tif (engine)\n\t\t\treturn intel_engine_cs_irq(engine, intr);\n\t}\n\n\tif (class == OTHER_CLASS)\n\t\treturn gen11_other_irq_handler(gt, instance, intr);\n\n\tWARN_ONCE(1, \"unknown interrupt class=0x%x, instance=0x%x, intr=0x%x\\n\",\n\t\t  class, instance, intr);\n}\n\nstatic void\ngen11_gt_bank_handler(struct intel_gt *gt, const unsigned int bank)\n{\n\tvoid __iomem * const regs = intel_uncore_regs(gt->uncore);\n\tunsigned long intr_dw;\n\tunsigned int bit;\n\n\tlockdep_assert_held(gt->irq_lock);\n\n\tintr_dw = raw_reg_read(regs, GEN11_GT_INTR_DW(bank));\n\n\tfor_each_set_bit(bit, &intr_dw, 32) {\n\t\tconst u32 ident = gen11_gt_engine_identity(gt, bank, bit);\n\n\t\tgen11_gt_identity_handler(gt, ident);\n\t}\n\n\t \n\traw_reg_write(regs, GEN11_GT_INTR_DW(bank), intr_dw);\n}\n\nvoid gen11_gt_irq_handler(struct intel_gt *gt, const u32 master_ctl)\n{\n\tunsigned int bank;\n\n\tspin_lock(gt->irq_lock);\n\n\tfor (bank = 0; bank < 2; bank++) {\n\t\tif (master_ctl & GEN11_GT_DW_IRQ(bank))\n\t\t\tgen11_gt_bank_handler(gt, bank);\n\t}\n\n\tspin_unlock(gt->irq_lock);\n}\n\nbool gen11_gt_reset_one_iir(struct intel_gt *gt,\n\t\t\t    const unsigned int bank, const unsigned int bit)\n{\n\tvoid __iomem * const regs = intel_uncore_regs(gt->uncore);\n\tu32 dw;\n\n\tlockdep_assert_held(gt->irq_lock);\n\n\tdw = raw_reg_read(regs, GEN11_GT_INTR_DW(bank));\n\tif (dw & BIT(bit)) {\n\t\t \n\t\tgen11_gt_engine_identity(gt, bank, bit);\n\n\t\t \n\t\traw_reg_write(regs, GEN11_GT_INTR_DW(bank), BIT(bit));\n\n\t\treturn true;\n\t}\n\n\treturn false;\n}\n\nvoid gen11_gt_irq_reset(struct intel_gt *gt)\n{\n\tstruct intel_uncore *uncore = gt->uncore;\n\n\t \n\tintel_uncore_write(uncore, GEN11_RENDER_COPY_INTR_ENABLE, 0);\n\tintel_uncore_write(uncore, GEN11_VCS_VECS_INTR_ENABLE,\t  0);\n\tif (CCS_MASK(gt))\n\t\tintel_uncore_write(uncore, GEN12_CCS_RSVD_INTR_ENABLE, 0);\n\tif (HAS_HECI_GSC(gt->i915) || HAS_ENGINE(gt, GSC0))\n\t\tintel_uncore_write(uncore, GEN11_GUNIT_CSME_INTR_ENABLE, 0);\n\n\t \n\tintel_uncore_write(uncore, GEN11_RCS0_RSVD_INTR_MASK,\t~0);\n\tintel_uncore_write(uncore, GEN11_BCS_RSVD_INTR_MASK,\t~0);\n\tif (HAS_ENGINE(gt, BCS1) || HAS_ENGINE(gt, BCS2))\n\t\tintel_uncore_write(uncore, XEHPC_BCS1_BCS2_INTR_MASK, ~0);\n\tif (HAS_ENGINE(gt, BCS3) || HAS_ENGINE(gt, BCS4))\n\t\tintel_uncore_write(uncore, XEHPC_BCS3_BCS4_INTR_MASK, ~0);\n\tif (HAS_ENGINE(gt, BCS5) || HAS_ENGINE(gt, BCS6))\n\t\tintel_uncore_write(uncore, XEHPC_BCS5_BCS6_INTR_MASK, ~0);\n\tif (HAS_ENGINE(gt, BCS7) || HAS_ENGINE(gt, BCS8))\n\t\tintel_uncore_write(uncore, XEHPC_BCS7_BCS8_INTR_MASK, ~0);\n\tintel_uncore_write(uncore, GEN11_VCS0_VCS1_INTR_MASK,\t~0);\n\tintel_uncore_write(uncore, GEN11_VCS2_VCS3_INTR_MASK,\t~0);\n\tif (HAS_ENGINE(gt, VCS4) || HAS_ENGINE(gt, VCS5))\n\t\tintel_uncore_write(uncore, GEN12_VCS4_VCS5_INTR_MASK,   ~0);\n\tif (HAS_ENGINE(gt, VCS6) || HAS_ENGINE(gt, VCS7))\n\t\tintel_uncore_write(uncore, GEN12_VCS6_VCS7_INTR_MASK,   ~0);\n\tintel_uncore_write(uncore, GEN11_VECS0_VECS1_INTR_MASK,\t~0);\n\tif (HAS_ENGINE(gt, VECS2) || HAS_ENGINE(gt, VECS3))\n\t\tintel_uncore_write(uncore, GEN12_VECS2_VECS3_INTR_MASK, ~0);\n\tif (HAS_ENGINE(gt, CCS0) || HAS_ENGINE(gt, CCS1))\n\t\tintel_uncore_write(uncore, GEN12_CCS0_CCS1_INTR_MASK, ~0);\n\tif (HAS_ENGINE(gt, CCS2) || HAS_ENGINE(gt, CCS3))\n\t\tintel_uncore_write(uncore, GEN12_CCS2_CCS3_INTR_MASK, ~0);\n\tif (HAS_HECI_GSC(gt->i915) || HAS_ENGINE(gt, GSC0))\n\t\tintel_uncore_write(uncore, GEN11_GUNIT_CSME_INTR_MASK, ~0);\n\n\tintel_uncore_write(uncore, GEN11_GPM_WGBOXPERF_INTR_ENABLE, 0);\n\tintel_uncore_write(uncore, GEN11_GPM_WGBOXPERF_INTR_MASK,  ~0);\n\tintel_uncore_write(uncore, GEN11_GUC_SG_INTR_ENABLE, 0);\n\tintel_uncore_write(uncore, GEN11_GUC_SG_INTR_MASK,  ~0);\n\n\tintel_uncore_write(uncore, GEN11_CRYPTO_RSVD_INTR_ENABLE, 0);\n\tintel_uncore_write(uncore, GEN11_CRYPTO_RSVD_INTR_MASK,  ~0);\n}\n\nvoid gen11_gt_irq_postinstall(struct intel_gt *gt)\n{\n\tstruct intel_uncore *uncore = gt->uncore;\n\tu32 irqs = GT_RENDER_USER_INTERRUPT;\n\tu32 guc_mask = intel_uc_wants_guc(&gt->uc) ? GUC_INTR_GUC2HOST : 0;\n\tu32 gsc_mask = 0;\n\tu32 heci_mask = 0;\n\tu32 dmask;\n\tu32 smask;\n\n\tif (!intel_uc_wants_guc_submission(&gt->uc))\n\t\tirqs |= GT_CS_MASTER_ERROR_INTERRUPT |\n\t\t\tGT_CONTEXT_SWITCH_INTERRUPT |\n\t\t\tGT_WAIT_SEMAPHORE_INTERRUPT;\n\n\tdmask = irqs << 16 | irqs;\n\tsmask = irqs << 16;\n\n\tif (HAS_ENGINE(gt, GSC0)) {\n\t\t \n\t\tgsc_mask = irqs;\n\t\theci_mask = GSC_IRQ_INTF(1);  \n\t} else if (HAS_HECI_GSC(gt->i915)) {\n\t\tgsc_mask = GSC_IRQ_INTF(0) | GSC_IRQ_INTF(1);\n\t}\n\n\tBUILD_BUG_ON(irqs & 0xffff0000);\n\n\t \n\tintel_uncore_write(uncore, GEN11_RENDER_COPY_INTR_ENABLE, dmask);\n\tintel_uncore_write(uncore, GEN11_VCS_VECS_INTR_ENABLE, dmask);\n\tif (CCS_MASK(gt))\n\t\tintel_uncore_write(uncore, GEN12_CCS_RSVD_INTR_ENABLE, smask);\n\tif (gsc_mask)\n\t\tintel_uncore_write(uncore, GEN11_GUNIT_CSME_INTR_ENABLE, gsc_mask | heci_mask);\n\n\t \n\tintel_uncore_write(uncore, GEN11_RCS0_RSVD_INTR_MASK, ~smask);\n\tintel_uncore_write(uncore, GEN11_BCS_RSVD_INTR_MASK, ~smask);\n\tif (HAS_ENGINE(gt, BCS1) || HAS_ENGINE(gt, BCS2))\n\t\tintel_uncore_write(uncore, XEHPC_BCS1_BCS2_INTR_MASK, ~dmask);\n\tif (HAS_ENGINE(gt, BCS3) || HAS_ENGINE(gt, BCS4))\n\t\tintel_uncore_write(uncore, XEHPC_BCS3_BCS4_INTR_MASK, ~dmask);\n\tif (HAS_ENGINE(gt, BCS5) || HAS_ENGINE(gt, BCS6))\n\t\tintel_uncore_write(uncore, XEHPC_BCS5_BCS6_INTR_MASK, ~dmask);\n\tif (HAS_ENGINE(gt, BCS7) || HAS_ENGINE(gt, BCS8))\n\t\tintel_uncore_write(uncore, XEHPC_BCS7_BCS8_INTR_MASK, ~dmask);\n\tintel_uncore_write(uncore, GEN11_VCS0_VCS1_INTR_MASK, ~dmask);\n\tintel_uncore_write(uncore, GEN11_VCS2_VCS3_INTR_MASK, ~dmask);\n\tif (HAS_ENGINE(gt, VCS4) || HAS_ENGINE(gt, VCS5))\n\t\tintel_uncore_write(uncore, GEN12_VCS4_VCS5_INTR_MASK, ~dmask);\n\tif (HAS_ENGINE(gt, VCS6) || HAS_ENGINE(gt, VCS7))\n\t\tintel_uncore_write(uncore, GEN12_VCS6_VCS7_INTR_MASK, ~dmask);\n\tintel_uncore_write(uncore, GEN11_VECS0_VECS1_INTR_MASK, ~dmask);\n\tif (HAS_ENGINE(gt, VECS2) || HAS_ENGINE(gt, VECS3))\n\t\tintel_uncore_write(uncore, GEN12_VECS2_VECS3_INTR_MASK, ~dmask);\n\tif (HAS_ENGINE(gt, CCS0) || HAS_ENGINE(gt, CCS1))\n\t\tintel_uncore_write(uncore, GEN12_CCS0_CCS1_INTR_MASK, ~dmask);\n\tif (HAS_ENGINE(gt, CCS2) || HAS_ENGINE(gt, CCS3))\n\t\tintel_uncore_write(uncore, GEN12_CCS2_CCS3_INTR_MASK, ~dmask);\n\tif (gsc_mask)\n\t\tintel_uncore_write(uncore, GEN11_GUNIT_CSME_INTR_MASK, ~gsc_mask);\n\tif (heci_mask)\n\t\tintel_uncore_write(uncore, GEN12_HECI2_RSVD_INTR_MASK,\n\t\t\t\t   ~REG_FIELD_PREP(ENGINE1_MASK, heci_mask));\n\n\tif (guc_mask) {\n\t\t \n\t\tu32 mask = gt->type == GT_MEDIA ?\n\t\t\tREG_FIELD_PREP(ENGINE0_MASK, guc_mask) :\n\t\t\tREG_FIELD_PREP(ENGINE1_MASK, guc_mask);\n\n\t\tintel_uncore_write(uncore, GEN11_GUC_SG_INTR_ENABLE,\n\t\t\t\t   REG_FIELD_PREP(ENGINE1_MASK, guc_mask));\n\n\t\t \n\t\tintel_uncore_rmw(uncore, MTL_GUC_MGUC_INTR_MASK, mask, 0);\n\t}\n\n\t \n\tgt->pm_ier = 0x0;\n\tgt->pm_imr = ~gt->pm_ier;\n\tintel_uncore_write(uncore, GEN11_GPM_WGBOXPERF_INTR_ENABLE, 0);\n\tintel_uncore_write(uncore, GEN11_GPM_WGBOXPERF_INTR_MASK,  ~0);\n}\n\nvoid gen5_gt_irq_handler(struct intel_gt *gt, u32 gt_iir)\n{\n\tif (gt_iir & GT_RENDER_USER_INTERRUPT)\n\t\tintel_engine_cs_irq(gt->engine_class[RENDER_CLASS][0],\n\t\t\t\t    gt_iir);\n\n\tif (gt_iir & ILK_BSD_USER_INTERRUPT)\n\t\tintel_engine_cs_irq(gt->engine_class[VIDEO_DECODE_CLASS][0],\n\t\t\t\t    gt_iir);\n}\n\nstatic void gen7_parity_error_irq_handler(struct intel_gt *gt, u32 iir)\n{\n\tif (!HAS_L3_DPF(gt->i915))\n\t\treturn;\n\n\tspin_lock(gt->irq_lock);\n\tgen5_gt_disable_irq(gt, GT_PARITY_ERROR(gt->i915));\n\tspin_unlock(gt->irq_lock);\n\n\tif (iir & GT_RENDER_L3_PARITY_ERROR_INTERRUPT_S1)\n\t\tgt->i915->l3_parity.which_slice |= 1 << 1;\n\n\tif (iir & GT_RENDER_L3_PARITY_ERROR_INTERRUPT)\n\t\tgt->i915->l3_parity.which_slice |= 1 << 0;\n\n\tqueue_work(gt->i915->unordered_wq, &gt->i915->l3_parity.error_work);\n}\n\nvoid gen6_gt_irq_handler(struct intel_gt *gt, u32 gt_iir)\n{\n\tif (gt_iir & GT_RENDER_USER_INTERRUPT)\n\t\tintel_engine_cs_irq(gt->engine_class[RENDER_CLASS][0],\n\t\t\t\t    gt_iir);\n\n\tif (gt_iir & GT_BSD_USER_INTERRUPT)\n\t\tintel_engine_cs_irq(gt->engine_class[VIDEO_DECODE_CLASS][0],\n\t\t\t\t    gt_iir >> 12);\n\n\tif (gt_iir & GT_BLT_USER_INTERRUPT)\n\t\tintel_engine_cs_irq(gt->engine_class[COPY_ENGINE_CLASS][0],\n\t\t\t\t    gt_iir >> 22);\n\n\tif (gt_iir & (GT_BLT_CS_ERROR_INTERRUPT |\n\t\t      GT_BSD_CS_ERROR_INTERRUPT |\n\t\t      GT_CS_MASTER_ERROR_INTERRUPT))\n\t\tgt_dbg(gt, \"Command parser error, gt_iir 0x%08x\\n\", gt_iir);\n\n\tif (gt_iir & GT_PARITY_ERROR(gt->i915))\n\t\tgen7_parity_error_irq_handler(gt, gt_iir);\n}\n\nvoid gen8_gt_irq_handler(struct intel_gt *gt, u32 master_ctl)\n{\n\tvoid __iomem * const regs = intel_uncore_regs(gt->uncore);\n\tu32 iir;\n\n\tif (master_ctl & (GEN8_GT_RCS_IRQ | GEN8_GT_BCS_IRQ)) {\n\t\tiir = raw_reg_read(regs, GEN8_GT_IIR(0));\n\t\tif (likely(iir)) {\n\t\t\tintel_engine_cs_irq(gt->engine_class[RENDER_CLASS][0],\n\t\t\t\t\t    iir >> GEN8_RCS_IRQ_SHIFT);\n\t\t\tintel_engine_cs_irq(gt->engine_class[COPY_ENGINE_CLASS][0],\n\t\t\t\t\t    iir >> GEN8_BCS_IRQ_SHIFT);\n\t\t\traw_reg_write(regs, GEN8_GT_IIR(0), iir);\n\t\t}\n\t}\n\n\tif (master_ctl & (GEN8_GT_VCS0_IRQ | GEN8_GT_VCS1_IRQ)) {\n\t\tiir = raw_reg_read(regs, GEN8_GT_IIR(1));\n\t\tif (likely(iir)) {\n\t\t\tintel_engine_cs_irq(gt->engine_class[VIDEO_DECODE_CLASS][0],\n\t\t\t\t\t    iir >> GEN8_VCS0_IRQ_SHIFT);\n\t\t\tintel_engine_cs_irq(gt->engine_class[VIDEO_DECODE_CLASS][1],\n\t\t\t\t\t    iir >> GEN8_VCS1_IRQ_SHIFT);\n\t\t\traw_reg_write(regs, GEN8_GT_IIR(1), iir);\n\t\t}\n\t}\n\n\tif (master_ctl & GEN8_GT_VECS_IRQ) {\n\t\tiir = raw_reg_read(regs, GEN8_GT_IIR(3));\n\t\tif (likely(iir)) {\n\t\t\tintel_engine_cs_irq(gt->engine_class[VIDEO_ENHANCEMENT_CLASS][0],\n\t\t\t\t\t    iir >> GEN8_VECS_IRQ_SHIFT);\n\t\t\traw_reg_write(regs, GEN8_GT_IIR(3), iir);\n\t\t}\n\t}\n\n\tif (master_ctl & (GEN8_GT_PM_IRQ | GEN8_GT_GUC_IRQ)) {\n\t\tiir = raw_reg_read(regs, GEN8_GT_IIR(2));\n\t\tif (likely(iir)) {\n\t\t\tgen6_rps_irq_handler(&gt->rps, iir);\n\t\t\tguc_irq_handler(&gt->uc.guc, iir >> 16);\n\t\t\traw_reg_write(regs, GEN8_GT_IIR(2), iir);\n\t\t}\n\t}\n}\n\nvoid gen8_gt_irq_reset(struct intel_gt *gt)\n{\n\tstruct intel_uncore *uncore = gt->uncore;\n\n\tGEN8_IRQ_RESET_NDX(uncore, GT, 0);\n\tGEN8_IRQ_RESET_NDX(uncore, GT, 1);\n\tGEN8_IRQ_RESET_NDX(uncore, GT, 2);\n\tGEN8_IRQ_RESET_NDX(uncore, GT, 3);\n}\n\nvoid gen8_gt_irq_postinstall(struct intel_gt *gt)\n{\n\t \n\tconst u32 irqs =\n\t\tGT_CS_MASTER_ERROR_INTERRUPT |\n\t\tGT_RENDER_USER_INTERRUPT |\n\t\tGT_CONTEXT_SWITCH_INTERRUPT |\n\t\tGT_WAIT_SEMAPHORE_INTERRUPT;\n\tconst u32 gt_interrupts[] = {\n\t\tirqs << GEN8_RCS_IRQ_SHIFT | irqs << GEN8_BCS_IRQ_SHIFT,\n\t\tirqs << GEN8_VCS0_IRQ_SHIFT | irqs << GEN8_VCS1_IRQ_SHIFT,\n\t\t0,\n\t\tirqs << GEN8_VECS_IRQ_SHIFT,\n\t};\n\tstruct intel_uncore *uncore = gt->uncore;\n\n\tgt->pm_ier = 0x0;\n\tgt->pm_imr = ~gt->pm_ier;\n\tGEN8_IRQ_INIT_NDX(uncore, GT, 0, ~gt_interrupts[0], gt_interrupts[0]);\n\tGEN8_IRQ_INIT_NDX(uncore, GT, 1, ~gt_interrupts[1], gt_interrupts[1]);\n\t \n\tGEN8_IRQ_INIT_NDX(uncore, GT, 2, gt->pm_imr, gt->pm_ier);\n\tGEN8_IRQ_INIT_NDX(uncore, GT, 3, ~gt_interrupts[3], gt_interrupts[3]);\n}\n\nstatic void gen5_gt_update_irq(struct intel_gt *gt,\n\t\t\t       u32 interrupt_mask,\n\t\t\t       u32 enabled_irq_mask)\n{\n\tlockdep_assert_held(gt->irq_lock);\n\n\tGEM_BUG_ON(enabled_irq_mask & ~interrupt_mask);\n\n\tgt->gt_imr &= ~interrupt_mask;\n\tgt->gt_imr |= (~enabled_irq_mask & interrupt_mask);\n\tintel_uncore_write(gt->uncore, GTIMR, gt->gt_imr);\n}\n\nvoid gen5_gt_enable_irq(struct intel_gt *gt, u32 mask)\n{\n\tgen5_gt_update_irq(gt, mask, mask);\n\tintel_uncore_posting_read_fw(gt->uncore, GTIMR);\n}\n\nvoid gen5_gt_disable_irq(struct intel_gt *gt, u32 mask)\n{\n\tgen5_gt_update_irq(gt, mask, 0);\n}\n\nvoid gen5_gt_irq_reset(struct intel_gt *gt)\n{\n\tstruct intel_uncore *uncore = gt->uncore;\n\n\tGEN3_IRQ_RESET(uncore, GT);\n\tif (GRAPHICS_VER(gt->i915) >= 6)\n\t\tGEN3_IRQ_RESET(uncore, GEN6_PM);\n}\n\nvoid gen5_gt_irq_postinstall(struct intel_gt *gt)\n{\n\tstruct intel_uncore *uncore = gt->uncore;\n\tu32 pm_irqs = 0;\n\tu32 gt_irqs = 0;\n\n\tgt->gt_imr = ~0;\n\tif (HAS_L3_DPF(gt->i915)) {\n\t\t \n\t\tgt->gt_imr = ~GT_PARITY_ERROR(gt->i915);\n\t\tgt_irqs |= GT_PARITY_ERROR(gt->i915);\n\t}\n\n\tgt_irqs |= GT_RENDER_USER_INTERRUPT;\n\tif (GRAPHICS_VER(gt->i915) == 5)\n\t\tgt_irqs |= ILK_BSD_USER_INTERRUPT;\n\telse\n\t\tgt_irqs |= GT_BLT_USER_INTERRUPT | GT_BSD_USER_INTERRUPT;\n\n\tGEN3_IRQ_INIT(uncore, GT, gt->gt_imr, gt_irqs);\n\n\tif (GRAPHICS_VER(gt->i915) >= 6) {\n\t\t \n\t\tif (HAS_ENGINE(gt, VECS0)) {\n\t\t\tpm_irqs |= PM_VEBOX_USER_INTERRUPT;\n\t\t\tgt->pm_ier |= PM_VEBOX_USER_INTERRUPT;\n\t\t}\n\n\t\tgt->pm_imr = 0xffffffff;\n\t\tGEN3_IRQ_INIT(uncore, GEN6_PM, gt->pm_imr, pm_irqs);\n\t}\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}