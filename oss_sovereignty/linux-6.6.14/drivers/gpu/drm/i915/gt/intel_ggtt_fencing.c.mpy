{
  "module_name": "intel_ggtt_fencing.c",
  "hash_id": "58af6469fb032c7606a3b3b19fe129e3730551a199f8995857a14008e764d46c",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/i915/gt/intel_ggtt_fencing.c",
  "human_readable_source": "\n \n\n#include <linux/highmem.h>\n\n#include \"display/intel_display.h\"\n#include \"i915_drv.h\"\n#include \"i915_reg.h\"\n#include \"i915_scatterlist.h\"\n#include \"i915_pvinfo.h\"\n#include \"i915_vgpu.h\"\n#include \"intel_gt_regs.h\"\n#include \"intel_mchbar_regs.h\"\n\n \n\n#define pipelined 0\n\nstatic struct drm_i915_private *fence_to_i915(struct i915_fence_reg *fence)\n{\n\treturn fence->ggtt->vm.i915;\n}\n\nstatic struct intel_uncore *fence_to_uncore(struct i915_fence_reg *fence)\n{\n\treturn fence->ggtt->vm.gt->uncore;\n}\n\nstatic void i965_write_fence_reg(struct i915_fence_reg *fence)\n{\n\ti915_reg_t fence_reg_lo, fence_reg_hi;\n\tint fence_pitch_shift;\n\tu64 val;\n\n\tif (GRAPHICS_VER(fence_to_i915(fence)) >= 6) {\n\t\tfence_reg_lo = FENCE_REG_GEN6_LO(fence->id);\n\t\tfence_reg_hi = FENCE_REG_GEN6_HI(fence->id);\n\t\tfence_pitch_shift = GEN6_FENCE_PITCH_SHIFT;\n\n\t} else {\n\t\tfence_reg_lo = FENCE_REG_965_LO(fence->id);\n\t\tfence_reg_hi = FENCE_REG_965_HI(fence->id);\n\t\tfence_pitch_shift = I965_FENCE_PITCH_SHIFT;\n\t}\n\n\tval = 0;\n\tif (fence->tiling) {\n\t\tunsigned int stride = fence->stride;\n\n\t\tGEM_BUG_ON(!IS_ALIGNED(stride, 128));\n\n\t\tval = fence->start + fence->size - I965_FENCE_PAGE;\n\t\tval <<= 32;\n\t\tval |= fence->start;\n\t\tval |= (u64)((stride / 128) - 1) << fence_pitch_shift;\n\t\tif (fence->tiling == I915_TILING_Y)\n\t\t\tval |= BIT(I965_FENCE_TILING_Y_SHIFT);\n\t\tval |= I965_FENCE_REG_VALID;\n\t}\n\n\tif (!pipelined) {\n\t\tstruct intel_uncore *uncore = fence_to_uncore(fence);\n\n\t\t \n\t\tintel_uncore_write_fw(uncore, fence_reg_lo, 0);\n\t\tintel_uncore_posting_read_fw(uncore, fence_reg_lo);\n\n\t\tintel_uncore_write_fw(uncore, fence_reg_hi, upper_32_bits(val));\n\t\tintel_uncore_write_fw(uncore, fence_reg_lo, lower_32_bits(val));\n\t\tintel_uncore_posting_read_fw(uncore, fence_reg_lo);\n\t}\n}\n\nstatic void i915_write_fence_reg(struct i915_fence_reg *fence)\n{\n\tu32 val;\n\n\tval = 0;\n\tif (fence->tiling) {\n\t\tunsigned int stride = fence->stride;\n\t\tunsigned int tiling = fence->tiling;\n\t\tbool is_y_tiled = tiling == I915_TILING_Y;\n\n\t\tif (is_y_tiled && HAS_128_BYTE_Y_TILING(fence_to_i915(fence)))\n\t\t\tstride /= 128;\n\t\telse\n\t\t\tstride /= 512;\n\t\tGEM_BUG_ON(!is_power_of_2(stride));\n\n\t\tval = fence->start;\n\t\tif (is_y_tiled)\n\t\t\tval |= BIT(I830_FENCE_TILING_Y_SHIFT);\n\t\tval |= I915_FENCE_SIZE_BITS(fence->size);\n\t\tval |= ilog2(stride) << I830_FENCE_PITCH_SHIFT;\n\n\t\tval |= I830_FENCE_REG_VALID;\n\t}\n\n\tif (!pipelined) {\n\t\tstruct intel_uncore *uncore = fence_to_uncore(fence);\n\t\ti915_reg_t reg = FENCE_REG(fence->id);\n\n\t\tintel_uncore_write_fw(uncore, reg, val);\n\t\tintel_uncore_posting_read_fw(uncore, reg);\n\t}\n}\n\nstatic void i830_write_fence_reg(struct i915_fence_reg *fence)\n{\n\tu32 val;\n\n\tval = 0;\n\tif (fence->tiling) {\n\t\tunsigned int stride = fence->stride;\n\n\t\tval = fence->start;\n\t\tif (fence->tiling == I915_TILING_Y)\n\t\t\tval |= BIT(I830_FENCE_TILING_Y_SHIFT);\n\t\tval |= I830_FENCE_SIZE_BITS(fence->size);\n\t\tval |= ilog2(stride / 128) << I830_FENCE_PITCH_SHIFT;\n\t\tval |= I830_FENCE_REG_VALID;\n\t}\n\n\tif (!pipelined) {\n\t\tstruct intel_uncore *uncore = fence_to_uncore(fence);\n\t\ti915_reg_t reg = FENCE_REG(fence->id);\n\n\t\tintel_uncore_write_fw(uncore, reg, val);\n\t\tintel_uncore_posting_read_fw(uncore, reg);\n\t}\n}\n\nstatic void fence_write(struct i915_fence_reg *fence)\n{\n\tstruct drm_i915_private *i915 = fence_to_i915(fence);\n\n\t \n\n\tif (GRAPHICS_VER(i915) == 2)\n\t\ti830_write_fence_reg(fence);\n\telse if (GRAPHICS_VER(i915) == 3)\n\t\ti915_write_fence_reg(fence);\n\telse\n\t\ti965_write_fence_reg(fence);\n\n\t \n}\n\nstatic bool gpu_uses_fence_registers(struct i915_fence_reg *fence)\n{\n\treturn GRAPHICS_VER(fence_to_i915(fence)) < 4;\n}\n\nstatic int fence_update(struct i915_fence_reg *fence,\n\t\t\tstruct i915_vma *vma)\n{\n\tstruct i915_ggtt *ggtt = fence->ggtt;\n\tstruct intel_uncore *uncore = fence_to_uncore(fence);\n\tintel_wakeref_t wakeref;\n\tstruct i915_vma *old;\n\tint ret;\n\n\tfence->tiling = 0;\n\tif (vma) {\n\t\tGEM_BUG_ON(!i915_gem_object_get_stride(vma->obj) ||\n\t\t\t   !i915_gem_object_get_tiling(vma->obj));\n\n\t\tif (!i915_vma_is_map_and_fenceable(vma))\n\t\t\treturn -EINVAL;\n\n\t\tif (gpu_uses_fence_registers(fence)) {\n\t\t\t \n\t\t\tret = i915_vma_sync(vma);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t}\n\n\t\tGEM_BUG_ON(vma->fence_size > i915_vma_size(vma));\n\t\tfence->start = i915_ggtt_offset(vma);\n\t\tfence->size = vma->fence_size;\n\t\tfence->stride = i915_gem_object_get_stride(vma->obj);\n\t\tfence->tiling = i915_gem_object_get_tiling(vma->obj);\n\t}\n\tWRITE_ONCE(fence->dirty, false);\n\n\told = xchg(&fence->vma, NULL);\n\tif (old) {\n\t\t \n\t\tret = i915_active_wait(&fence->active);\n\t\tif (ret) {\n\t\t\tfence->vma = old;\n\t\t\treturn ret;\n\t\t}\n\n\t\ti915_vma_flush_writes(old);\n\n\t\t \n\t\tif (old != vma) {\n\t\t\tGEM_BUG_ON(old->fence != fence);\n\t\t\ti915_vma_revoke_mmap(old);\n\t\t\told->fence = NULL;\n\t\t}\n\n\t\tlist_move(&fence->link, &ggtt->fence_list);\n\t}\n\n\t \n\twakeref = intel_runtime_pm_get_if_in_use(uncore->rpm);\n\tif (!wakeref) {\n\t\tGEM_BUG_ON(vma);\n\t\treturn 0;\n\t}\n\n\tWRITE_ONCE(fence->vma, vma);\n\tfence_write(fence);\n\n\tif (vma) {\n\t\tvma->fence = fence;\n\t\tlist_move_tail(&fence->link, &ggtt->fence_list);\n\t}\n\n\tintel_runtime_pm_put(uncore->rpm, wakeref);\n\treturn 0;\n}\n\n \nvoid i915_vma_revoke_fence(struct i915_vma *vma)\n{\n\tstruct i915_fence_reg *fence = vma->fence;\n\tintel_wakeref_t wakeref;\n\n\tlockdep_assert_held(&vma->vm->mutex);\n\tif (!fence)\n\t\treturn;\n\n\tGEM_BUG_ON(fence->vma != vma);\n\tGEM_BUG_ON(!i915_active_is_idle(&fence->active));\n\tGEM_BUG_ON(atomic_read(&fence->pin_count));\n\n\tfence->tiling = 0;\n\tWRITE_ONCE(fence->vma, NULL);\n\tvma->fence = NULL;\n\n\t \n\twith_intel_runtime_pm_if_active(fence_to_uncore(fence)->rpm, wakeref)\n\t\tfence_write(fence);\n}\n\nstatic bool fence_is_active(const struct i915_fence_reg *fence)\n{\n\treturn fence->vma && i915_vma_is_active(fence->vma);\n}\n\nstatic struct i915_fence_reg *fence_find(struct i915_ggtt *ggtt)\n{\n\tstruct i915_fence_reg *active = NULL;\n\tstruct i915_fence_reg *fence, *fn;\n\n\tlist_for_each_entry_safe(fence, fn, &ggtt->fence_list, link) {\n\t\tGEM_BUG_ON(fence->vma && fence->vma->fence != fence);\n\n\t\tif (fence == active)  \n\t\t\tactive = ERR_PTR(-EAGAIN);\n\n\t\t \n\t\tif (active != ERR_PTR(-EAGAIN) && fence_is_active(fence)) {\n\t\t\tif (!active)\n\t\t\t\tactive = fence;\n\n\t\t\tlist_move_tail(&fence->link, &ggtt->fence_list);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (atomic_read(&fence->pin_count))\n\t\t\tcontinue;\n\n\t\treturn fence;\n\t}\n\n\t \n\tif (intel_has_pending_fb_unpin(ggtt->vm.i915))\n\t\treturn ERR_PTR(-EAGAIN);\n\n\treturn ERR_PTR(-ENOBUFS);\n}\n\nint __i915_vma_pin_fence(struct i915_vma *vma)\n{\n\tstruct i915_ggtt *ggtt = i915_vm_to_ggtt(vma->vm);\n\tstruct i915_fence_reg *fence;\n\tstruct i915_vma *set = i915_gem_object_is_tiled(vma->obj) ? vma : NULL;\n\tint err;\n\n\tlockdep_assert_held(&vma->vm->mutex);\n\n\t \n\tif (vma->fence) {\n\t\tfence = vma->fence;\n\t\tGEM_BUG_ON(fence->vma != vma);\n\t\tatomic_inc(&fence->pin_count);\n\t\tif (!fence->dirty) {\n\t\t\tlist_move_tail(&fence->link, &ggtt->fence_list);\n\t\t\treturn 0;\n\t\t}\n\t} else if (set) {\n\t\tfence = fence_find(ggtt);\n\t\tif (IS_ERR(fence))\n\t\t\treturn PTR_ERR(fence);\n\n\t\tGEM_BUG_ON(atomic_read(&fence->pin_count));\n\t\tatomic_inc(&fence->pin_count);\n\t} else {\n\t\treturn 0;\n\t}\n\n\terr = fence_update(fence, set);\n\tif (err)\n\t\tgoto out_unpin;\n\n\tGEM_BUG_ON(fence->vma != set);\n\tGEM_BUG_ON(vma->fence != (set ? fence : NULL));\n\n\tif (set)\n\t\treturn 0;\n\nout_unpin:\n\tatomic_dec(&fence->pin_count);\n\treturn err;\n}\n\n \nint i915_vma_pin_fence(struct i915_vma *vma)\n{\n\tint err;\n\n\tif (!vma->fence && !i915_gem_object_is_tiled(vma->obj))\n\t\treturn 0;\n\n\t \n\tassert_rpm_wakelock_held(vma->vm->gt->uncore->rpm);\n\tGEM_BUG_ON(!i915_vma_is_ggtt(vma));\n\n\terr = mutex_lock_interruptible(&vma->vm->mutex);\n\tif (err)\n\t\treturn err;\n\n\terr = __i915_vma_pin_fence(vma);\n\tmutex_unlock(&vma->vm->mutex);\n\n\treturn err;\n}\n\n \nstruct i915_fence_reg *i915_reserve_fence(struct i915_ggtt *ggtt)\n{\n\tstruct i915_fence_reg *fence;\n\tint count;\n\tint ret;\n\n\tlockdep_assert_held(&ggtt->vm.mutex);\n\n\t \n\tcount = 0;\n\tlist_for_each_entry(fence, &ggtt->fence_list, link)\n\t\tcount += !atomic_read(&fence->pin_count);\n\tif (count <= 1)\n\t\treturn ERR_PTR(-ENOSPC);\n\n\tfence = fence_find(ggtt);\n\tif (IS_ERR(fence))\n\t\treturn fence;\n\n\tif (fence->vma) {\n\t\t \n\t\tret = fence_update(fence, NULL);\n\t\tif (ret)\n\t\t\treturn ERR_PTR(ret);\n\t}\n\n\tlist_del(&fence->link);\n\n\treturn fence;\n}\n\n \nvoid i915_unreserve_fence(struct i915_fence_reg *fence)\n{\n\tstruct i915_ggtt *ggtt = fence->ggtt;\n\n\tlockdep_assert_held(&ggtt->vm.mutex);\n\n\tlist_add(&fence->link, &ggtt->fence_list);\n}\n\n \nvoid intel_ggtt_restore_fences(struct i915_ggtt *ggtt)\n{\n\tint i;\n\n\tfor (i = 0; i < ggtt->num_fences; i++)\n\t\tfence_write(&ggtt->fence_regs[i]);\n}\n\n \n\n \nstatic void detect_bit_6_swizzle(struct i915_ggtt *ggtt)\n{\n\tstruct intel_uncore *uncore = ggtt->vm.gt->uncore;\n\tstruct drm_i915_private *i915 = ggtt->vm.i915;\n\tu32 swizzle_x = I915_BIT_6_SWIZZLE_UNKNOWN;\n\tu32 swizzle_y = I915_BIT_6_SWIZZLE_UNKNOWN;\n\n\tif (GRAPHICS_VER(i915) >= 8 || IS_VALLEYVIEW(i915)) {\n\t\t \n\t\tswizzle_x = I915_BIT_6_SWIZZLE_NONE;\n\t\tswizzle_y = I915_BIT_6_SWIZZLE_NONE;\n\t} else if (GRAPHICS_VER(i915) >= 6) {\n\t\tif (i915->preserve_bios_swizzle) {\n\t\t\tif (intel_uncore_read(uncore, DISP_ARB_CTL) &\n\t\t\t    DISP_TILE_SURFACE_SWIZZLING) {\n\t\t\t\tswizzle_x = I915_BIT_6_SWIZZLE_9_10;\n\t\t\t\tswizzle_y = I915_BIT_6_SWIZZLE_9;\n\t\t\t} else {\n\t\t\t\tswizzle_x = I915_BIT_6_SWIZZLE_NONE;\n\t\t\t\tswizzle_y = I915_BIT_6_SWIZZLE_NONE;\n\t\t\t}\n\t\t} else {\n\t\t\tu32 dimm_c0, dimm_c1;\n\n\t\t\tdimm_c0 = intel_uncore_read(uncore, MAD_DIMM_C0);\n\t\t\tdimm_c1 = intel_uncore_read(uncore, MAD_DIMM_C1);\n\t\t\tdimm_c0 &= MAD_DIMM_A_SIZE_MASK | MAD_DIMM_B_SIZE_MASK;\n\t\t\tdimm_c1 &= MAD_DIMM_A_SIZE_MASK | MAD_DIMM_B_SIZE_MASK;\n\t\t\t \n\t\t\tif (dimm_c0 == dimm_c1) {\n\t\t\t\tswizzle_x = I915_BIT_6_SWIZZLE_9_10;\n\t\t\t\tswizzle_y = I915_BIT_6_SWIZZLE_9;\n\t\t\t} else {\n\t\t\t\tswizzle_x = I915_BIT_6_SWIZZLE_NONE;\n\t\t\t\tswizzle_y = I915_BIT_6_SWIZZLE_NONE;\n\t\t\t}\n\t\t}\n\t} else if (GRAPHICS_VER(i915) == 5) {\n\t\t \n\t\tswizzle_x = I915_BIT_6_SWIZZLE_9_10;\n\t\tswizzle_y = I915_BIT_6_SWIZZLE_9;\n\t} else if (GRAPHICS_VER(i915) == 2) {\n\t\t \n\t\tswizzle_x = I915_BIT_6_SWIZZLE_NONE;\n\t\tswizzle_y = I915_BIT_6_SWIZZLE_NONE;\n\t} else if (IS_G45(i915) || IS_I965G(i915) || IS_G33(i915)) {\n\t\t \n\t\tif (intel_uncore_read16(uncore, C0DRB3_BW) ==\n\t\t    intel_uncore_read16(uncore, C1DRB3_BW)) {\n\t\t\tswizzle_x = I915_BIT_6_SWIZZLE_9_10;\n\t\t\tswizzle_y = I915_BIT_6_SWIZZLE_9;\n\t\t}\n\t} else {\n\t\tu32 dcc = intel_uncore_read(uncore, DCC);\n\n\t\t \n\t\tswitch (dcc & DCC_ADDRESSING_MODE_MASK) {\n\t\tcase DCC_ADDRESSING_MODE_SINGLE_CHANNEL:\n\t\tcase DCC_ADDRESSING_MODE_DUAL_CHANNEL_ASYMMETRIC:\n\t\t\tswizzle_x = I915_BIT_6_SWIZZLE_NONE;\n\t\t\tswizzle_y = I915_BIT_6_SWIZZLE_NONE;\n\t\t\tbreak;\n\t\tcase DCC_ADDRESSING_MODE_DUAL_CHANNEL_INTERLEAVED:\n\t\t\tif (dcc & DCC_CHANNEL_XOR_DISABLE) {\n\t\t\t\t \n\t\t\t\tswizzle_x = I915_BIT_6_SWIZZLE_9_10;\n\t\t\t\tswizzle_y = I915_BIT_6_SWIZZLE_9;\n\t\t\t} else if ((dcc & DCC_CHANNEL_XOR_BIT_17) == 0) {\n\t\t\t\t \n\t\t\t\tswizzle_x = I915_BIT_6_SWIZZLE_9_10_11;\n\t\t\t\tswizzle_y = I915_BIT_6_SWIZZLE_9_11;\n\t\t\t} else {\n\t\t\t\t \n\t\t\t\tswizzle_x = I915_BIT_6_SWIZZLE_9_10_17;\n\t\t\t\tswizzle_y = I915_BIT_6_SWIZZLE_9_17;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\tif (GRAPHICS_VER(i915) == 4 &&\n\t\t    !(intel_uncore_read(uncore, DCC2) & DCC2_MODIFIED_ENHANCED_DISABLE)) {\n\t\t\tswizzle_x = I915_BIT_6_SWIZZLE_UNKNOWN;\n\t\t\tswizzle_y = I915_BIT_6_SWIZZLE_UNKNOWN;\n\t\t}\n\n\t\tif (dcc == 0xffffffff) {\n\t\t\tdrm_err(&i915->drm, \"Couldn't read from MCHBAR.  \"\n\t\t\t\t  \"Disabling tiling.\\n\");\n\t\t\tswizzle_x = I915_BIT_6_SWIZZLE_UNKNOWN;\n\t\t\tswizzle_y = I915_BIT_6_SWIZZLE_UNKNOWN;\n\t\t}\n\t}\n\n\tif (swizzle_x == I915_BIT_6_SWIZZLE_UNKNOWN ||\n\t    swizzle_y == I915_BIT_6_SWIZZLE_UNKNOWN) {\n\t\t \n\t\ti915->gem_quirks |= GEM_QUIRK_PIN_SWIZZLED_PAGES;\n\t\tswizzle_x = I915_BIT_6_SWIZZLE_NONE;\n\t\tswizzle_y = I915_BIT_6_SWIZZLE_NONE;\n\t}\n\n\tto_gt(i915)->ggtt->bit_6_swizzle_x = swizzle_x;\n\tto_gt(i915)->ggtt->bit_6_swizzle_y = swizzle_y;\n}\n\n \nstatic void swizzle_page(struct page *page)\n{\n\tchar temp[64];\n\tchar *vaddr;\n\tint i;\n\n\tvaddr = kmap(page);\n\n\tfor (i = 0; i < PAGE_SIZE; i += 128) {\n\t\tmemcpy(temp, &vaddr[i], 64);\n\t\tmemcpy(&vaddr[i], &vaddr[i + 64], 64);\n\t\tmemcpy(&vaddr[i + 64], temp, 64);\n\t}\n\n\tkunmap(page);\n}\n\n \nvoid\ni915_gem_object_do_bit_17_swizzle(struct drm_i915_gem_object *obj,\n\t\t\t\t  struct sg_table *pages)\n{\n\tstruct sgt_iter sgt_iter;\n\tstruct page *page;\n\tint i;\n\n\tif (obj->bit_17 == NULL)\n\t\treturn;\n\n\ti = 0;\n\tfor_each_sgt_page(page, sgt_iter, pages) {\n\t\tchar new_bit_17 = page_to_phys(page) >> 17;\n\n\t\tif ((new_bit_17 & 0x1) != (test_bit(i, obj->bit_17) != 0)) {\n\t\t\tswizzle_page(page);\n\t\t\tset_page_dirty(page);\n\t\t}\n\n\t\ti++;\n\t}\n}\n\n \nvoid\ni915_gem_object_save_bit_17_swizzle(struct drm_i915_gem_object *obj,\n\t\t\t\t    struct sg_table *pages)\n{\n\tconst unsigned int page_count = obj->base.size >> PAGE_SHIFT;\n\tstruct sgt_iter sgt_iter;\n\tstruct page *page;\n\tint i;\n\n\tif (obj->bit_17 == NULL) {\n\t\tobj->bit_17 = bitmap_zalloc(page_count, GFP_KERNEL);\n\t\tif (obj->bit_17 == NULL) {\n\t\t\tdrm_err(obj->base.dev,\n\t\t\t\t\"Failed to allocate memory for bit 17 record\\n\");\n\t\t\treturn;\n\t\t}\n\t}\n\n\ti = 0;\n\n\tfor_each_sgt_page(page, sgt_iter, pages) {\n\t\tif (page_to_phys(page) & (1 << 17))\n\t\t\t__set_bit(i, obj->bit_17);\n\t\telse\n\t\t\t__clear_bit(i, obj->bit_17);\n\t\ti++;\n\t}\n}\n\nvoid intel_ggtt_init_fences(struct i915_ggtt *ggtt)\n{\n\tstruct drm_i915_private *i915 = ggtt->vm.i915;\n\tstruct intel_uncore *uncore = ggtt->vm.gt->uncore;\n\tint num_fences;\n\tint i;\n\n\tINIT_LIST_HEAD(&ggtt->fence_list);\n\tINIT_LIST_HEAD(&ggtt->userfault_list);\n\n\tdetect_bit_6_swizzle(ggtt);\n\n\tif (!i915_ggtt_has_aperture(ggtt))\n\t\tnum_fences = 0;\n\telse if (GRAPHICS_VER(i915) >= 7 &&\n\t\t !(IS_VALLEYVIEW(i915) || IS_CHERRYVIEW(i915)))\n\t\tnum_fences = 32;\n\telse if (GRAPHICS_VER(i915) >= 4 ||\n\t\t IS_I945G(i915) || IS_I945GM(i915) ||\n\t\t IS_G33(i915) || IS_PINEVIEW(i915))\n\t\tnum_fences = 16;\n\telse\n\t\tnum_fences = 8;\n\n\tif (intel_vgpu_active(i915))\n\t\tnum_fences = intel_uncore_read(uncore,\n\t\t\t\t\t       vgtif_reg(avail_rs.fence_num));\n\tggtt->fence_regs = kcalloc(num_fences,\n\t\t\t\t   sizeof(*ggtt->fence_regs),\n\t\t\t\t   GFP_KERNEL);\n\tif (!ggtt->fence_regs)\n\t\tnum_fences = 0;\n\n\t \n\tfor (i = 0; i < num_fences; i++) {\n\t\tstruct i915_fence_reg *fence = &ggtt->fence_regs[i];\n\n\t\ti915_active_init(&fence->active, NULL, NULL, 0);\n\t\tfence->ggtt = ggtt;\n\t\tfence->id = i;\n\t\tlist_add_tail(&fence->link, &ggtt->fence_list);\n\t}\n\tggtt->num_fences = num_fences;\n\n\tintel_ggtt_restore_fences(ggtt);\n}\n\nvoid intel_ggtt_fini_fences(struct i915_ggtt *ggtt)\n{\n\tint i;\n\n\tfor (i = 0; i < ggtt->num_fences; i++) {\n\t\tstruct i915_fence_reg *fence = &ggtt->fence_regs[i];\n\n\t\ti915_active_fini(&fence->active);\n\t}\n\n\tkfree(ggtt->fence_regs);\n}\n\nvoid intel_gt_init_swizzling(struct intel_gt *gt)\n{\n\tstruct drm_i915_private *i915 = gt->i915;\n\tstruct intel_uncore *uncore = gt->uncore;\n\n\tif (GRAPHICS_VER(i915) < 5 ||\n\t    to_gt(i915)->ggtt->bit_6_swizzle_x == I915_BIT_6_SWIZZLE_NONE)\n\t\treturn;\n\n\tintel_uncore_rmw(uncore, DISP_ARB_CTL, 0, DISP_TILE_SURFACE_SWIZZLING);\n\n\tif (GRAPHICS_VER(i915) == 5)\n\t\treturn;\n\n\tintel_uncore_rmw(uncore, TILECTL, 0, TILECTL_SWZCTL);\n\n\tif (GRAPHICS_VER(i915) == 6)\n\t\tintel_uncore_write(uncore,\n\t\t\t\t   ARB_MODE,\n\t\t\t\t   _MASKED_BIT_ENABLE(ARB_MODE_SWIZZLE_SNB));\n\telse if (GRAPHICS_VER(i915) == 7)\n\t\tintel_uncore_write(uncore,\n\t\t\t\t   ARB_MODE,\n\t\t\t\t   _MASKED_BIT_ENABLE(ARB_MODE_SWIZZLE_IVB));\n\telse if (GRAPHICS_VER(i915) == 8)\n\t\tintel_uncore_write(uncore,\n\t\t\t\t   GAMTARBMODE,\n\t\t\t\t   _MASKED_BIT_ENABLE(ARB_MODE_SWIZZLE_BDW));\n\telse\n\t\tMISSING_CASE(GRAPHICS_VER(i915));\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}