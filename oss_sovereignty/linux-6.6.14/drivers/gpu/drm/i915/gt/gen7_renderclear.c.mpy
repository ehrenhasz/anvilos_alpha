{
  "module_name": "gen7_renderclear.c",
  "hash_id": "8de89ad2bf2ed913d47f89c85d51fe6ab541478eddc807046956c998b68c1ab4",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/i915/gt/gen7_renderclear.c",
  "human_readable_source": "\n \n\n#include \"gen7_renderclear.h\"\n#include \"i915_drv.h\"\n#include \"intel_gpu_commands.h\"\n#include \"intel_gt_regs.h\"\n\n#define GT3_INLINE_DATA_DELAYS 0x1E00\n#define batch_advance(Y, CS) GEM_BUG_ON((Y)->end != (CS))\n\nstruct cb_kernel {\n\tconst void *data;\n\tu32 size;\n};\n\n#define CB_KERNEL(name) { .data = (name), .size = sizeof(name) }\n\n#include \"ivb_clear_kernel.c\"\nstatic const struct cb_kernel cb_kernel_ivb = CB_KERNEL(ivb_clear_kernel);\n\n#include \"hsw_clear_kernel.c\"\nstatic const struct cb_kernel cb_kernel_hsw = CB_KERNEL(hsw_clear_kernel);\n\nstruct batch_chunk {\n\tstruct i915_vma *vma;\n\tu32 offset;\n\tu32 *start;\n\tu32 *end;\n\tu32 max_items;\n};\n\nstruct batch_vals {\n\tu32 max_threads;\n\tu32 state_start;\n\tu32 surface_start;\n\tu32 surface_height;\n\tu32 surface_width;\n\tu32 size;\n};\n\nstatic int num_primitives(const struct batch_vals *bv)\n{\n\t \n\treturn bv->max_threads;\n}\n\nstatic void\nbatch_get_defaults(struct drm_i915_private *i915, struct batch_vals *bv)\n{\n\tif (IS_HASWELL(i915)) {\n\t\tswitch (INTEL_INFO(i915)->gt) {\n\t\tdefault:\n\t\tcase 1:\n\t\t\tbv->max_threads = 70;\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tbv->max_threads = 140;\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tbv->max_threads = 280;\n\t\t\tbreak;\n\t\t}\n\t\tbv->surface_height = 16 * 16;\n\t\tbv->surface_width = 32 * 2 * 16;\n\t} else {\n\t\tswitch (INTEL_INFO(i915)->gt) {\n\t\tdefault:\n\t\tcase 1:  \n\t\t\tbv->max_threads = 36;\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tbv->max_threads = 128;\n\t\t\tbreak;\n\t\t}\n\t\tbv->surface_height = 16 * 8;\n\t\tbv->surface_width = 32 * 16;\n\t}\n\tbv->state_start = round_up(SZ_1K + num_primitives(bv) * 64, SZ_4K);\n\tbv->surface_start = bv->state_start + SZ_4K;\n\tbv->size = bv->surface_start + bv->surface_height * bv->surface_width;\n}\n\nstatic void batch_init(struct batch_chunk *bc,\n\t\t       struct i915_vma *vma,\n\t\t       u32 *start, u32 offset, u32 max_bytes)\n{\n\tbc->vma = vma;\n\tbc->offset = offset;\n\tbc->start = start + bc->offset / sizeof(*bc->start);\n\tbc->end = bc->start;\n\tbc->max_items = max_bytes / sizeof(*bc->start);\n}\n\nstatic u32 batch_offset(const struct batch_chunk *bc, u32 *cs)\n{\n\treturn (cs - bc->start) * sizeof(*bc->start) + bc->offset;\n}\n\nstatic u32 batch_addr(const struct batch_chunk *bc)\n{\n\treturn i915_vma_offset(bc->vma);\n}\n\nstatic void batch_add(struct batch_chunk *bc, const u32 d)\n{\n\tGEM_BUG_ON((bc->end - bc->start) >= bc->max_items);\n\t*bc->end++ = d;\n}\n\nstatic u32 *batch_alloc_items(struct batch_chunk *bc, u32 align, u32 items)\n{\n\tu32 *map;\n\n\tif (align) {\n\t\tu32 *end = PTR_ALIGN(bc->end, align);\n\n\t\tmemset32(bc->end, 0, end - bc->end);\n\t\tbc->end = end;\n\t}\n\n\tmap = bc->end;\n\tbc->end += items;\n\n\treturn map;\n}\n\nstatic u32 *batch_alloc_bytes(struct batch_chunk *bc, u32 align, u32 bytes)\n{\n\tGEM_BUG_ON(!IS_ALIGNED(bytes, sizeof(*bc->start)));\n\treturn batch_alloc_items(bc, align, bytes / sizeof(*bc->start));\n}\n\nstatic u32\ngen7_fill_surface_state(struct batch_chunk *state,\n\t\t\tconst u32 dst_offset,\n\t\t\tconst struct batch_vals *bv)\n{\n\tu32 surface_h = bv->surface_height;\n\tu32 surface_w = bv->surface_width;\n\tu32 *cs = batch_alloc_items(state, 32, 8);\n\tu32 offset = batch_offset(state, cs);\n\n#define SURFACE_2D 1\n#define SURFACEFORMAT_B8G8R8A8_UNORM 0x0C0\n#define RENDER_CACHE_READ_WRITE 1\n\n\t*cs++ = SURFACE_2D << 29 |\n\t\t(SURFACEFORMAT_B8G8R8A8_UNORM << 18) |\n\t\t(RENDER_CACHE_READ_WRITE << 8);\n\n\t*cs++ = batch_addr(state) + dst_offset;\n\n\t*cs++ = ((surface_h / 4 - 1) << 16) | (surface_w / 4 - 1);\n\t*cs++ = surface_w;\n\t*cs++ = 0;\n\t*cs++ = 0;\n\t*cs++ = 0;\n#define SHADER_CHANNELS(r, g, b, a) \\\n\t(((r) << 25) | ((g) << 22) | ((b) << 19) | ((a) << 16))\n\t*cs++ = SHADER_CHANNELS(4, 5, 6, 7);\n\tbatch_advance(state, cs);\n\n\treturn offset;\n}\n\nstatic u32\ngen7_fill_binding_table(struct batch_chunk *state,\n\t\t\tconst struct batch_vals *bv)\n{\n\tu32 surface_start =\n\t\tgen7_fill_surface_state(state, bv->surface_start, bv);\n\tu32 *cs = batch_alloc_items(state, 32, 8);\n\tu32 offset = batch_offset(state, cs);\n\n\t*cs++ = surface_start - state->offset;\n\t*cs++ = 0;\n\t*cs++ = 0;\n\t*cs++ = 0;\n\t*cs++ = 0;\n\t*cs++ = 0;\n\t*cs++ = 0;\n\t*cs++ = 0;\n\tbatch_advance(state, cs);\n\n\treturn offset;\n}\n\nstatic u32\ngen7_fill_kernel_data(struct batch_chunk *state,\n\t\t      const u32 *data,\n\t\t      const u32 size)\n{\n\treturn batch_offset(state,\n\t\t\t    memcpy(batch_alloc_bytes(state, 64, size),\n\t\t\t\t   data, size));\n}\n\nstatic u32\ngen7_fill_interface_descriptor(struct batch_chunk *state,\n\t\t\t       const struct batch_vals *bv,\n\t\t\t       const struct cb_kernel *kernel,\n\t\t\t       unsigned int count)\n{\n\tu32 kernel_offset =\n\t\tgen7_fill_kernel_data(state, kernel->data, kernel->size);\n\tu32 binding_table = gen7_fill_binding_table(state, bv);\n\tu32 *cs = batch_alloc_items(state, 32, 8 * count);\n\tu32 offset = batch_offset(state, cs);\n\n\t*cs++ = kernel_offset;\n\t*cs++ = (1 << 7) | (1 << 13);\n\t*cs++ = 0;\n\t*cs++ = (binding_table - state->offset) | 1;\n\t*cs++ = 0;\n\t*cs++ = 0;\n\t*cs++ = 0;\n\t*cs++ = 0;\n\n\t \n\tmemset32(cs, 0x00, (count - 1) * 8);\n\tbatch_advance(state, cs + (count - 1) * 8);\n\n\treturn offset;\n}\n\nstatic void\ngen7_emit_state_base_address(struct batch_chunk *batch,\n\t\t\t     u32 surface_state_base)\n{\n\tu32 *cs = batch_alloc_items(batch, 0, 10);\n\n\t*cs++ = STATE_BASE_ADDRESS | (10 - 2);\n\t \n\t*cs++ = batch_addr(batch) | BASE_ADDRESS_MODIFY;\n\t \n\t*cs++ = (batch_addr(batch) + surface_state_base) | BASE_ADDRESS_MODIFY;\n\t \n\t*cs++ = batch_addr(batch) | BASE_ADDRESS_MODIFY;\n\t \n\t*cs++ = batch_addr(batch) | BASE_ADDRESS_MODIFY;\n\t \n\t*cs++ = batch_addr(batch) | BASE_ADDRESS_MODIFY;\n\n\t \n\t*cs++ = 0;\n\t*cs++ = BASE_ADDRESS_MODIFY;\n\t*cs++ = 0;\n\t*cs++ = BASE_ADDRESS_MODIFY;\n\tbatch_advance(batch, cs);\n}\n\nstatic void\ngen7_emit_vfe_state(struct batch_chunk *batch,\n\t\t    const struct batch_vals *bv,\n\t\t    u32 urb_size, u32 curbe_size,\n\t\t    u32 mode)\n{\n\tu32 threads = bv->max_threads - 1;\n\tu32 *cs = batch_alloc_items(batch, 32, 8);\n\n\t*cs++ = MEDIA_VFE_STATE | (8 - 2);\n\n\t \n\t*cs++ = 0;\n\n\t \n\t*cs++ = threads << 16 | 1 << 8 | mode << 2;\n\n\t*cs++ = 0;\n\n\t \n\t*cs++ = urb_size << 16 | curbe_size;\n\n\t \n\t*cs++ = 0;\n\t*cs++ = 0;\n\t*cs++ = 0;\n\tbatch_advance(batch, cs);\n}\n\nstatic void\ngen7_emit_interface_descriptor_load(struct batch_chunk *batch,\n\t\t\t\t    const u32 interface_descriptor,\n\t\t\t\t    unsigned int count)\n{\n\tu32 *cs = batch_alloc_items(batch, 8, 4);\n\n\t*cs++ = MEDIA_INTERFACE_DESCRIPTOR_LOAD | (4 - 2);\n\t*cs++ = 0;\n\t*cs++ = count * 8 * sizeof(*cs);\n\n\t \n\t*cs++ = interface_descriptor;\n\tbatch_advance(batch, cs);\n}\n\nstatic void\ngen7_emit_media_object(struct batch_chunk *batch,\n\t\t       unsigned int media_object_index)\n{\n\tunsigned int x_offset = (media_object_index % 16) * 64;\n\tunsigned int y_offset = (media_object_index / 16) * 16;\n\tunsigned int pkt = 6 + 3;\n\tu32 *cs;\n\n\tcs = batch_alloc_items(batch, 8, pkt);\n\n\t*cs++ = MEDIA_OBJECT | (pkt - 2);\n\n\t \n\t*cs++ = 0;\n\n\t \n\t*cs++ = 0;\n\t*cs++ = 0;\n\n\t \n\t*cs++ = 0;\n\t*cs++ = 0;\n\n\t \n\t*cs++ = y_offset << 16 | x_offset;\n\t*cs++ = 0;\n\t*cs++ = GT3_INLINE_DATA_DELAYS;\n\n\tbatch_advance(batch, cs);\n}\n\nstatic void gen7_emit_pipeline_flush(struct batch_chunk *batch)\n{\n\tu32 *cs = batch_alloc_items(batch, 0, 4);\n\n\t*cs++ = GFX_OP_PIPE_CONTROL(4);\n\t*cs++ = PIPE_CONTROL_RENDER_TARGET_CACHE_FLUSH |\n\t\tPIPE_CONTROL_DEPTH_CACHE_FLUSH |\n\t\tPIPE_CONTROL_DC_FLUSH_ENABLE |\n\t\tPIPE_CONTROL_CS_STALL;\n\t*cs++ = 0;\n\t*cs++ = 0;\n\n\tbatch_advance(batch, cs);\n}\n\nstatic void gen7_emit_pipeline_invalidate(struct batch_chunk *batch)\n{\n\tu32 *cs = batch_alloc_items(batch, 0, 10);\n\n\t \n\t*cs++ = GFX_OP_PIPE_CONTROL(5);\n\t*cs++ = PIPE_CONTROL_STALL_AT_SCOREBOARD |\n\t\tPIPE_CONTROL_CS_STALL;\n\t*cs++ = 0;\n\t*cs++ = 0;\n\t*cs++ = 0;\n\n\t*cs++ = GFX_OP_PIPE_CONTROL(5);\n\t*cs++ = PIPE_CONTROL_STATE_CACHE_INVALIDATE;\n\t*cs++ = 0;\n\t*cs++ = 0;\n\t*cs++ = 0;\n\n\tbatch_advance(batch, cs);\n}\n\nstatic void emit_batch(struct i915_vma * const vma,\n\t\t       u32 *start,\n\t\t       const struct batch_vals *bv)\n{\n\tstruct drm_i915_private *i915 = vma->vm->i915;\n\tconst unsigned int desc_count = 1;\n\tconst unsigned int urb_size = 1;\n\tstruct batch_chunk cmds, state;\n\tu32 descriptors;\n\tunsigned int i;\n\n\tbatch_init(&cmds, vma, start, 0, bv->state_start);\n\tbatch_init(&state, vma, start, bv->state_start, SZ_4K);\n\n\tdescriptors = gen7_fill_interface_descriptor(&state, bv,\n\t\t\t\t\t\t     IS_HASWELL(i915) ?\n\t\t\t\t\t\t     &cb_kernel_hsw :\n\t\t\t\t\t\t     &cb_kernel_ivb,\n\t\t\t\t\t\t     desc_count);\n\n\t \n\tgen7_emit_pipeline_flush(&cmds);\n\tgen7_emit_pipeline_invalidate(&cmds);\n\tbatch_add(&cmds, MI_LOAD_REGISTER_IMM(2));\n\tbatch_add(&cmds, i915_mmio_reg_offset(CACHE_MODE_0_GEN7));\n\tbatch_add(&cmds, 0xffff0000 |\n\t\t\t((IS_IVB_GT1(i915) || IS_VALLEYVIEW(i915)) ?\n\t\t\t HIZ_RAW_STALL_OPT_DISABLE :\n\t\t\t 0));\n\tbatch_add(&cmds, i915_mmio_reg_offset(CACHE_MODE_1));\n\tbatch_add(&cmds, 0xffff0000 | PIXEL_SUBSPAN_COLLECT_OPT_DISABLE);\n\tgen7_emit_pipeline_invalidate(&cmds);\n\tgen7_emit_pipeline_flush(&cmds);\n\n\t \n\tgen7_emit_pipeline_invalidate(&cmds);\n\tbatch_add(&cmds, PIPELINE_SELECT | PIPELINE_SELECT_MEDIA);\n\tbatch_add(&cmds, MI_NOOP);\n\tgen7_emit_pipeline_invalidate(&cmds);\n\n\tgen7_emit_pipeline_flush(&cmds);\n\tgen7_emit_state_base_address(&cmds, descriptors);\n\tgen7_emit_pipeline_invalidate(&cmds);\n\n\t \n\tgen7_emit_vfe_state(&cmds, bv, urb_size - 1, 0, 0);\n\tgen7_emit_interface_descriptor_load(&cmds, descriptors, desc_count);\n\n\t \n\tfor (i = 0; i < num_primitives(bv); i++)\n\t\tgen7_emit_media_object(&cmds, i);\n\n\tbatch_add(&cmds, MI_BATCH_BUFFER_END);\n}\n\nint gen7_setup_clear_gpr_bb(struct intel_engine_cs * const engine,\n\t\t\t    struct i915_vma * const vma)\n{\n\tstruct batch_vals bv;\n\tu32 *batch;\n\n\tbatch_get_defaults(engine->i915, &bv);\n\tif (!vma)\n\t\treturn bv.size;\n\n\tGEM_BUG_ON(vma->obj->base.size < bv.size);\n\n\tbatch = i915_gem_object_pin_map(vma->obj, I915_MAP_WC);\n\tif (IS_ERR(batch))\n\t\treturn PTR_ERR(batch);\n\n\temit_batch(vma, memset(batch, 0, bv.size), &bv);\n\n\ti915_gem_object_flush_map(vma->obj);\n\t__i915_gem_object_release_map(vma->obj);\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}