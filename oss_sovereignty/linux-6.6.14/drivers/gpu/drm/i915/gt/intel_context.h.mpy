{
  "module_name": "intel_context.h",
  "hash_id": "8bb56d822f334cdd166d3f75f86d71faff015c86111b479f188972cf2ea9a2a4",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/i915/gt/intel_context.h",
  "human_readable_source": " \n \n\n#ifndef __INTEL_CONTEXT_H__\n#define __INTEL_CONTEXT_H__\n\n#include <linux/bitops.h>\n#include <linux/lockdep.h>\n#include <linux/types.h>\n\n#include \"i915_active.h\"\n#include \"i915_drv.h\"\n#include \"intel_context_types.h\"\n#include \"intel_engine_types.h\"\n#include \"intel_gt_pm.h\"\n#include \"intel_ring_types.h\"\n#include \"intel_timeline_types.h\"\n#include \"i915_trace.h\"\n\n#define CE_TRACE(ce, fmt, ...) do {\t\t\t\t\t\\\n\tconst struct intel_context *ce__ = (ce);\t\t\t\\\n\tENGINE_TRACE(ce__->engine, \"context:%llx \" fmt,\t\t\t\\\n\t\t     ce__->timeline->fence_context,\t\t\t\\\n\t\t     ##__VA_ARGS__);\t\t\t\t\t\\\n} while (0)\n\n#define INTEL_CONTEXT_BANNED_PREEMPT_TIMEOUT_MS (1)\n\nstruct i915_gem_ww_ctx;\n\nvoid intel_context_init(struct intel_context *ce,\n\t\t\tstruct intel_engine_cs *engine);\nvoid intel_context_fini(struct intel_context *ce);\n\nvoid i915_context_module_exit(void);\nint i915_context_module_init(void);\n\nstruct intel_context *\nintel_context_create(struct intel_engine_cs *engine);\n\nint intel_context_alloc_state(struct intel_context *ce);\n\nvoid intel_context_free(struct intel_context *ce);\n\nint intel_context_reconfigure_sseu(struct intel_context *ce,\n\t\t\t\t   const struct intel_sseu sseu);\n\n#define PARENT_SCRATCH_SIZE\tPAGE_SIZE\n\nstatic inline bool intel_context_is_child(struct intel_context *ce)\n{\n\treturn !!ce->parallel.parent;\n}\n\nstatic inline bool intel_context_is_parent(struct intel_context *ce)\n{\n\treturn !!ce->parallel.number_children;\n}\n\nstatic inline bool intel_context_is_pinned(struct intel_context *ce);\n\nstatic inline struct intel_context *\nintel_context_to_parent(struct intel_context *ce)\n{\n\tif (intel_context_is_child(ce)) {\n\t\t \n\t\tGEM_BUG_ON(!intel_context_is_pinned(ce->parallel.parent));\n\n\t\treturn ce->parallel.parent;\n\t} else {\n\t\treturn ce;\n\t}\n}\n\nstatic inline bool intel_context_is_parallel(struct intel_context *ce)\n{\n\treturn intel_context_is_child(ce) || intel_context_is_parent(ce);\n}\n\nvoid intel_context_bind_parent_child(struct intel_context *parent,\n\t\t\t\t     struct intel_context *child);\n\n#define for_each_child(parent, ce)\\\n\tlist_for_each_entry(ce, &(parent)->parallel.child_list,\\\n\t\t\t    parallel.child_link)\n#define for_each_child_safe(parent, ce, cn)\\\n\tlist_for_each_entry_safe(ce, cn, &(parent)->parallel.child_list,\\\n\t\t\t\t parallel.child_link)\n\n \nstatic inline int intel_context_lock_pinned(struct intel_context *ce)\n\t__acquires(ce->pin_mutex)\n{\n\treturn mutex_lock_interruptible(&ce->pin_mutex);\n}\n\n \nstatic inline bool\nintel_context_is_pinned(struct intel_context *ce)\n{\n\treturn atomic_read(&ce->pin_count);\n}\n\nstatic inline void intel_context_cancel_request(struct intel_context *ce,\n\t\t\t\t\t\tstruct i915_request *rq)\n{\n\tGEM_BUG_ON(!ce->ops->cancel_request);\n\treturn ce->ops->cancel_request(ce, rq);\n}\n\n \nstatic inline void intel_context_unlock_pinned(struct intel_context *ce)\n\t__releases(ce->pin_mutex)\n{\n\tmutex_unlock(&ce->pin_mutex);\n}\n\nint __intel_context_do_pin(struct intel_context *ce);\nint __intel_context_do_pin_ww(struct intel_context *ce,\n\t\t\t      struct i915_gem_ww_ctx *ww);\n\nstatic inline bool intel_context_pin_if_active(struct intel_context *ce)\n{\n\treturn atomic_inc_not_zero(&ce->pin_count);\n}\n\nstatic inline int intel_context_pin(struct intel_context *ce)\n{\n\tif (likely(intel_context_pin_if_active(ce)))\n\t\treturn 0;\n\n\treturn __intel_context_do_pin(ce);\n}\n\nstatic inline int intel_context_pin_ww(struct intel_context *ce,\n\t\t\t\t       struct i915_gem_ww_ctx *ww)\n{\n\tif (likely(intel_context_pin_if_active(ce)))\n\t\treturn 0;\n\n\treturn __intel_context_do_pin_ww(ce, ww);\n}\n\nstatic inline void __intel_context_pin(struct intel_context *ce)\n{\n\tGEM_BUG_ON(!intel_context_is_pinned(ce));\n\tatomic_inc(&ce->pin_count);\n}\n\nvoid __intel_context_do_unpin(struct intel_context *ce, int sub);\n\nstatic inline void intel_context_sched_disable_unpin(struct intel_context *ce)\n{\n\t__intel_context_do_unpin(ce, 2);\n}\n\nstatic inline void intel_context_unpin(struct intel_context *ce)\n{\n\tif (!ce->ops->sched_disable) {\n\t\t__intel_context_do_unpin(ce, 1);\n\t} else {\n\t\t \n\t\twhile (!atomic_add_unless(&ce->pin_count, -1, 1)) {\n\t\t\tif (atomic_cmpxchg(&ce->pin_count, 1, 2) == 1) {\n\t\t\t\tce->ops->sched_disable(ce);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid intel_context_enter_engine(struct intel_context *ce);\nvoid intel_context_exit_engine(struct intel_context *ce);\n\nstatic inline void intel_context_enter(struct intel_context *ce)\n{\n\tlockdep_assert_held(&ce->timeline->mutex);\n\tif (ce->active_count++)\n\t\treturn;\n\n\tce->ops->enter(ce);\n\tintel_gt_pm_get(ce->vm->gt);\n}\n\nstatic inline void intel_context_mark_active(struct intel_context *ce)\n{\n\tlockdep_assert(lockdep_is_held(&ce->timeline->mutex) ||\n\t\t       test_bit(CONTEXT_IS_PARKING, &ce->flags));\n\t++ce->active_count;\n}\n\nstatic inline void intel_context_exit(struct intel_context *ce)\n{\n\tlockdep_assert_held(&ce->timeline->mutex);\n\tGEM_BUG_ON(!ce->active_count);\n\tif (--ce->active_count)\n\t\treturn;\n\n\tintel_gt_pm_put_async(ce->vm->gt);\n\tce->ops->exit(ce);\n}\n\nstatic inline struct intel_context *intel_context_get(struct intel_context *ce)\n{\n\tkref_get(&ce->ref);\n\treturn ce;\n}\n\nstatic inline void intel_context_put(struct intel_context *ce)\n{\n\tkref_put(&ce->ref, ce->ops->destroy);\n}\n\nstatic inline struct intel_timeline *__must_check\nintel_context_timeline_lock(struct intel_context *ce)\n\t__acquires(&ce->timeline->mutex)\n{\n\tstruct intel_timeline *tl = ce->timeline;\n\tint err;\n\n\tif (intel_context_is_parent(ce))\n\t\terr = mutex_lock_interruptible_nested(&tl->mutex, 0);\n\telse if (intel_context_is_child(ce))\n\t\terr = mutex_lock_interruptible_nested(&tl->mutex,\n\t\t\t\t\t\t      ce->parallel.child_index + 1);\n\telse\n\t\terr = mutex_lock_interruptible(&tl->mutex);\n\tif (err)\n\t\treturn ERR_PTR(err);\n\n\treturn tl;\n}\n\nstatic inline void intel_context_timeline_unlock(struct intel_timeline *tl)\n\t__releases(&tl->mutex)\n{\n\tmutex_unlock(&tl->mutex);\n}\n\nint intel_context_prepare_remote_request(struct intel_context *ce,\n\t\t\t\t\t struct i915_request *rq);\n\nstruct i915_request *intel_context_create_request(struct intel_context *ce);\n\nstruct i915_request *intel_context_get_active_request(struct intel_context *ce);\n\nstatic inline bool intel_context_is_barrier(const struct intel_context *ce)\n{\n\treturn test_bit(CONTEXT_BARRIER_BIT, &ce->flags);\n}\n\nstatic inline void intel_context_close(struct intel_context *ce)\n{\n\tset_bit(CONTEXT_CLOSED_BIT, &ce->flags);\n\n\tif (ce->ops->close)\n\t\tce->ops->close(ce);\n}\n\nstatic inline bool intel_context_is_closed(const struct intel_context *ce)\n{\n\treturn test_bit(CONTEXT_CLOSED_BIT, &ce->flags);\n}\n\nstatic inline bool intel_context_has_inflight(const struct intel_context *ce)\n{\n\treturn test_bit(COPS_HAS_INFLIGHT_BIT, &ce->ops->flags);\n}\n\nstatic inline bool intel_context_use_semaphores(const struct intel_context *ce)\n{\n\treturn test_bit(CONTEXT_USE_SEMAPHORES, &ce->flags);\n}\n\nstatic inline void intel_context_set_use_semaphores(struct intel_context *ce)\n{\n\tset_bit(CONTEXT_USE_SEMAPHORES, &ce->flags);\n}\n\nstatic inline void intel_context_clear_use_semaphores(struct intel_context *ce)\n{\n\tclear_bit(CONTEXT_USE_SEMAPHORES, &ce->flags);\n}\n\nstatic inline bool intel_context_is_banned(const struct intel_context *ce)\n{\n\treturn test_bit(CONTEXT_BANNED, &ce->flags);\n}\n\nstatic inline bool intel_context_set_banned(struct intel_context *ce)\n{\n\treturn test_and_set_bit(CONTEXT_BANNED, &ce->flags);\n}\n\nbool intel_context_ban(struct intel_context *ce, struct i915_request *rq);\n\nstatic inline bool intel_context_is_schedulable(const struct intel_context *ce)\n{\n\treturn !test_bit(CONTEXT_EXITING, &ce->flags) &&\n\t       !test_bit(CONTEXT_BANNED, &ce->flags);\n}\n\nstatic inline bool intel_context_is_exiting(const struct intel_context *ce)\n{\n\treturn test_bit(CONTEXT_EXITING, &ce->flags);\n}\n\nstatic inline bool intel_context_set_exiting(struct intel_context *ce)\n{\n\treturn test_and_set_bit(CONTEXT_EXITING, &ce->flags);\n}\n\nbool intel_context_revoke(struct intel_context *ce);\n\nstatic inline bool\nintel_context_force_single_submission(const struct intel_context *ce)\n{\n\treturn test_bit(CONTEXT_FORCE_SINGLE_SUBMISSION, &ce->flags);\n}\n\nstatic inline void\nintel_context_set_single_submission(struct intel_context *ce)\n{\n\t__set_bit(CONTEXT_FORCE_SINGLE_SUBMISSION, &ce->flags);\n}\n\nstatic inline bool\nintel_context_nopreempt(const struct intel_context *ce)\n{\n\treturn test_bit(CONTEXT_NOPREEMPT, &ce->flags);\n}\n\nstatic inline void\nintel_context_set_nopreempt(struct intel_context *ce)\n{\n\tset_bit(CONTEXT_NOPREEMPT, &ce->flags);\n}\n\nstatic inline void\nintel_context_clear_nopreempt(struct intel_context *ce)\n{\n\tclear_bit(CONTEXT_NOPREEMPT, &ce->flags);\n}\n\nu64 intel_context_get_total_runtime_ns(struct intel_context *ce);\nu64 intel_context_get_avg_runtime_ns(struct intel_context *ce);\n\nstatic inline u64 intel_context_clock(void)\n{\n\t \n\treturn ktime_get_raw_fast_ns();\n}\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}