{
  "module_name": "sysfs_engines.c",
  "hash_id": "9222b06a00b7ed22741a00abb1ea601c82fa2b9b832b1c2195c1df989521f197",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/i915/gt/sysfs_engines.c",
  "human_readable_source": "\n \n\n#include <linux/kobject.h>\n#include <linux/sysfs.h>\n\n#include \"i915_drv.h\"\n#include \"intel_engine.h\"\n#include \"intel_engine_heartbeat.h\"\n#include \"sysfs_engines.h\"\n\nstruct kobj_engine {\n\tstruct kobject base;\n\tstruct intel_engine_cs *engine;\n};\n\nstatic struct intel_engine_cs *kobj_to_engine(struct kobject *kobj)\n{\n\treturn container_of(kobj, struct kobj_engine, base)->engine;\n}\n\nstatic ssize_t\nname_show(struct kobject *kobj, struct kobj_attribute *attr, char *buf)\n{\n\treturn sysfs_emit(buf, \"%s\\n\", kobj_to_engine(kobj)->name);\n}\n\nstatic const struct kobj_attribute name_attr =\n__ATTR(name, 0444, name_show, NULL);\n\nstatic ssize_t\nclass_show(struct kobject *kobj, struct kobj_attribute *attr, char *buf)\n{\n\treturn sysfs_emit(buf, \"%d\\n\", kobj_to_engine(kobj)->uabi_class);\n}\n\nstatic const struct kobj_attribute class_attr =\n__ATTR(class, 0444, class_show, NULL);\n\nstatic ssize_t\ninst_show(struct kobject *kobj, struct kobj_attribute *attr, char *buf)\n{\n\treturn sysfs_emit(buf, \"%d\\n\", kobj_to_engine(kobj)->uabi_instance);\n}\n\nstatic const struct kobj_attribute inst_attr =\n__ATTR(instance, 0444, inst_show, NULL);\n\nstatic ssize_t\nmmio_show(struct kobject *kobj, struct kobj_attribute *attr, char *buf)\n{\n\treturn sysfs_emit(buf, \"0x%x\\n\", kobj_to_engine(kobj)->mmio_base);\n}\n\nstatic const struct kobj_attribute mmio_attr =\n__ATTR(mmio_base, 0444, mmio_show, NULL);\n\nstatic const char * const vcs_caps[] = {\n\t[ilog2(I915_VIDEO_CLASS_CAPABILITY_HEVC)] = \"hevc\",\n\t[ilog2(I915_VIDEO_AND_ENHANCE_CLASS_CAPABILITY_SFC)] = \"sfc\",\n};\n\nstatic const char * const vecs_caps[] = {\n\t[ilog2(I915_VIDEO_AND_ENHANCE_CLASS_CAPABILITY_SFC)] = \"sfc\",\n};\n\nstatic ssize_t repr_trim(char *buf, ssize_t len)\n{\n\t \n\tif (len > PAGE_SIZE)\n\t\tlen = PAGE_SIZE;\n\tif (len > 0)\n\t\tbuf[len - 1] = '\\n';\n\n\treturn len;\n}\n\nstatic ssize_t\n__caps_show(struct intel_engine_cs *engine,\n\t    unsigned long caps, char *buf, bool show_unknown)\n{\n\tconst char * const *repr;\n\tint count, n;\n\tssize_t len;\n\n\tswitch (engine->class) {\n\tcase VIDEO_DECODE_CLASS:\n\t\trepr = vcs_caps;\n\t\tcount = ARRAY_SIZE(vcs_caps);\n\t\tbreak;\n\n\tcase VIDEO_ENHANCEMENT_CLASS:\n\t\trepr = vecs_caps;\n\t\tcount = ARRAY_SIZE(vecs_caps);\n\t\tbreak;\n\n\tdefault:\n\t\trepr = NULL;\n\t\tcount = 0;\n\t\tbreak;\n\t}\n\tGEM_BUG_ON(count > BITS_PER_LONG);\n\n\tlen = 0;\n\tfor_each_set_bit(n, &caps, show_unknown ? BITS_PER_LONG : count) {\n\t\tif (n >= count || !repr[n]) {\n\t\t\tif (GEM_WARN_ON(show_unknown))\n\t\t\t\tlen += sysfs_emit_at(buf, len, \"[%x] \", n);\n\t\t} else {\n\t\t\tlen += sysfs_emit_at(buf, len, \"%s \", repr[n]);\n\t\t}\n\t\tif (GEM_WARN_ON(len >= PAGE_SIZE))\n\t\t\tbreak;\n\t}\n\treturn repr_trim(buf, len);\n}\n\nstatic ssize_t\ncaps_show(struct kobject *kobj, struct kobj_attribute *attr, char *buf)\n{\n\tstruct intel_engine_cs *engine = kobj_to_engine(kobj);\n\n\treturn __caps_show(engine, engine->uabi_capabilities, buf, true);\n}\n\nstatic const struct kobj_attribute caps_attr =\n__ATTR(capabilities, 0444, caps_show, NULL);\n\nstatic ssize_t\nall_caps_show(struct kobject *kobj, struct kobj_attribute *attr, char *buf)\n{\n\treturn __caps_show(kobj_to_engine(kobj), -1, buf, false);\n}\n\nstatic const struct kobj_attribute all_caps_attr =\n__ATTR(known_capabilities, 0444, all_caps_show, NULL);\n\nstatic ssize_t\nmax_spin_store(struct kobject *kobj, struct kobj_attribute *attr,\n\t       const char *buf, size_t count)\n{\n\tstruct intel_engine_cs *engine = kobj_to_engine(kobj);\n\tunsigned long long duration, clamped;\n\tint err;\n\n\t \n\n\terr = kstrtoull(buf, 0, &duration);\n\tif (err)\n\t\treturn err;\n\n\tclamped = intel_clamp_max_busywait_duration_ns(engine, duration);\n\tif (duration != clamped)\n\t\treturn -EINVAL;\n\n\tWRITE_ONCE(engine->props.max_busywait_duration_ns, duration);\n\n\treturn count;\n}\n\nstatic ssize_t\nmax_spin_show(struct kobject *kobj, struct kobj_attribute *attr, char *buf)\n{\n\tstruct intel_engine_cs *engine = kobj_to_engine(kobj);\n\n\treturn sysfs_emit(buf, \"%lu\\n\", engine->props.max_busywait_duration_ns);\n}\n\nstatic const struct kobj_attribute max_spin_attr =\n__ATTR(max_busywait_duration_ns, 0644, max_spin_show, max_spin_store);\n\nstatic ssize_t\nmax_spin_default(struct kobject *kobj, struct kobj_attribute *attr, char *buf)\n{\n\tstruct intel_engine_cs *engine = kobj_to_engine(kobj);\n\n\treturn sysfs_emit(buf, \"%lu\\n\", engine->defaults.max_busywait_duration_ns);\n}\n\nstatic const struct kobj_attribute max_spin_def =\n__ATTR(max_busywait_duration_ns, 0444, max_spin_default, NULL);\n\nstatic ssize_t\ntimeslice_store(struct kobject *kobj, struct kobj_attribute *attr,\n\t\tconst char *buf, size_t count)\n{\n\tstruct intel_engine_cs *engine = kobj_to_engine(kobj);\n\tunsigned long long duration, clamped;\n\tint err;\n\n\t \n\n\terr = kstrtoull(buf, 0, &duration);\n\tif (err)\n\t\treturn err;\n\n\tclamped = intel_clamp_timeslice_duration_ms(engine, duration);\n\tif (duration != clamped)\n\t\treturn -EINVAL;\n\n\tWRITE_ONCE(engine->props.timeslice_duration_ms, duration);\n\n\tif (execlists_active(&engine->execlists))\n\t\tset_timer_ms(&engine->execlists.timer, duration);\n\n\treturn count;\n}\n\nstatic ssize_t\ntimeslice_show(struct kobject *kobj, struct kobj_attribute *attr, char *buf)\n{\n\tstruct intel_engine_cs *engine = kobj_to_engine(kobj);\n\n\treturn sysfs_emit(buf, \"%lu\\n\", engine->props.timeslice_duration_ms);\n}\n\nstatic const struct kobj_attribute timeslice_duration_attr =\n__ATTR(timeslice_duration_ms, 0644, timeslice_show, timeslice_store);\n\nstatic ssize_t\ntimeslice_default(struct kobject *kobj, struct kobj_attribute *attr, char *buf)\n{\n\tstruct intel_engine_cs *engine = kobj_to_engine(kobj);\n\n\treturn sysfs_emit(buf, \"%lu\\n\", engine->defaults.timeslice_duration_ms);\n}\n\nstatic const struct kobj_attribute timeslice_duration_def =\n__ATTR(timeslice_duration_ms, 0444, timeslice_default, NULL);\n\nstatic ssize_t\nstop_store(struct kobject *kobj, struct kobj_attribute *attr,\n\t   const char *buf, size_t count)\n{\n\tstruct intel_engine_cs *engine = kobj_to_engine(kobj);\n\tunsigned long long duration, clamped;\n\tint err;\n\n\t \n\n\terr = kstrtoull(buf, 0, &duration);\n\tif (err)\n\t\treturn err;\n\n\tclamped = intel_clamp_stop_timeout_ms(engine, duration);\n\tif (duration != clamped)\n\t\treturn -EINVAL;\n\n\tWRITE_ONCE(engine->props.stop_timeout_ms, duration);\n\treturn count;\n}\n\nstatic ssize_t\nstop_show(struct kobject *kobj, struct kobj_attribute *attr, char *buf)\n{\n\tstruct intel_engine_cs *engine = kobj_to_engine(kobj);\n\n\treturn sysfs_emit(buf, \"%lu\\n\", engine->props.stop_timeout_ms);\n}\n\nstatic const struct kobj_attribute stop_timeout_attr =\n__ATTR(stop_timeout_ms, 0644, stop_show, stop_store);\n\nstatic ssize_t\nstop_default(struct kobject *kobj, struct kobj_attribute *attr, char *buf)\n{\n\tstruct intel_engine_cs *engine = kobj_to_engine(kobj);\n\n\treturn sysfs_emit(buf, \"%lu\\n\", engine->defaults.stop_timeout_ms);\n}\n\nstatic const struct kobj_attribute stop_timeout_def =\n__ATTR(stop_timeout_ms, 0444, stop_default, NULL);\n\nstatic ssize_t\npreempt_timeout_store(struct kobject *kobj, struct kobj_attribute *attr,\n\t\t      const char *buf, size_t count)\n{\n\tstruct intel_engine_cs *engine = kobj_to_engine(kobj);\n\tunsigned long long timeout, clamped;\n\tint err;\n\n\t \n\n\terr = kstrtoull(buf, 0, &timeout);\n\tif (err)\n\t\treturn err;\n\n\tclamped = intel_clamp_preempt_timeout_ms(engine, timeout);\n\tif (timeout != clamped)\n\t\treturn -EINVAL;\n\n\tWRITE_ONCE(engine->props.preempt_timeout_ms, timeout);\n\n\tif (READ_ONCE(engine->execlists.pending[0]))\n\t\tset_timer_ms(&engine->execlists.preempt, timeout);\n\n\treturn count;\n}\n\nstatic ssize_t\npreempt_timeout_show(struct kobject *kobj, struct kobj_attribute *attr,\n\t\t     char *buf)\n{\n\tstruct intel_engine_cs *engine = kobj_to_engine(kobj);\n\n\treturn sysfs_emit(buf, \"%lu\\n\", engine->props.preempt_timeout_ms);\n}\n\nstatic const struct kobj_attribute preempt_timeout_attr =\n__ATTR(preempt_timeout_ms, 0644, preempt_timeout_show, preempt_timeout_store);\n\nstatic ssize_t\npreempt_timeout_default(struct kobject *kobj, struct kobj_attribute *attr,\n\t\t\tchar *buf)\n{\n\tstruct intel_engine_cs *engine = kobj_to_engine(kobj);\n\n\treturn sysfs_emit(buf, \"%lu\\n\", engine->defaults.preempt_timeout_ms);\n}\n\nstatic const struct kobj_attribute preempt_timeout_def =\n__ATTR(preempt_timeout_ms, 0444, preempt_timeout_default, NULL);\n\nstatic ssize_t\nheartbeat_store(struct kobject *kobj, struct kobj_attribute *attr,\n\t\tconst char *buf, size_t count)\n{\n\tstruct intel_engine_cs *engine = kobj_to_engine(kobj);\n\tunsigned long long delay, clamped;\n\tint err;\n\n\t \n\n\terr = kstrtoull(buf, 0, &delay);\n\tif (err)\n\t\treturn err;\n\n\tclamped = intel_clamp_heartbeat_interval_ms(engine, delay);\n\tif (delay != clamped)\n\t\treturn -EINVAL;\n\n\terr = intel_engine_set_heartbeat(engine, delay);\n\tif (err)\n\t\treturn err;\n\n\treturn count;\n}\n\nstatic ssize_t\nheartbeat_show(struct kobject *kobj, struct kobj_attribute *attr, char *buf)\n{\n\tstruct intel_engine_cs *engine = kobj_to_engine(kobj);\n\n\treturn sysfs_emit(buf, \"%lu\\n\", engine->props.heartbeat_interval_ms);\n}\n\nstatic const struct kobj_attribute heartbeat_interval_attr =\n__ATTR(heartbeat_interval_ms, 0644, heartbeat_show, heartbeat_store);\n\nstatic ssize_t\nheartbeat_default(struct kobject *kobj, struct kobj_attribute *attr, char *buf)\n{\n\tstruct intel_engine_cs *engine = kobj_to_engine(kobj);\n\n\treturn sysfs_emit(buf, \"%lu\\n\", engine->defaults.heartbeat_interval_ms);\n}\n\nstatic const struct kobj_attribute heartbeat_interval_def =\n__ATTR(heartbeat_interval_ms, 0444, heartbeat_default, NULL);\n\nstatic void kobj_engine_release(struct kobject *kobj)\n{\n\tkfree(kobj);\n}\n\nstatic const struct kobj_type kobj_engine_type = {\n\t.release = kobj_engine_release,\n\t.sysfs_ops = &kobj_sysfs_ops\n};\n\nstatic struct kobject *\nkobj_engine(struct kobject *dir, struct intel_engine_cs *engine)\n{\n\tstruct kobj_engine *ke;\n\n\tke = kzalloc(sizeof(*ke), GFP_KERNEL);\n\tif (!ke)\n\t\treturn NULL;\n\n\tkobject_init(&ke->base, &kobj_engine_type);\n\tke->engine = engine;\n\n\tif (kobject_add(&ke->base, dir, \"%s\", engine->name)) {\n\t\tkobject_put(&ke->base);\n\t\treturn NULL;\n\t}\n\n\t \n\treturn &ke->base;\n}\n\nstatic void add_defaults(struct kobj_engine *parent)\n{\n\tstatic const struct attribute * const files[] = {\n\t\t&max_spin_def.attr,\n\t\t&stop_timeout_def.attr,\n#if CONFIG_DRM_I915_HEARTBEAT_INTERVAL\n\t\t&heartbeat_interval_def.attr,\n#endif\n\t\tNULL\n\t};\n\tstruct kobj_engine *ke;\n\n\tke = kzalloc(sizeof(*ke), GFP_KERNEL);\n\tif (!ke)\n\t\treturn;\n\n\tkobject_init(&ke->base, &kobj_engine_type);\n\tke->engine = parent->engine;\n\n\tif (kobject_add(&ke->base, &parent->base, \"%s\", \".defaults\")) {\n\t\tkobject_put(&ke->base);\n\t\treturn;\n\t}\n\n\tif (sysfs_create_files(&ke->base, files))\n\t\treturn;\n\n\tif (intel_engine_has_timeslices(ke->engine) &&\n\t    sysfs_create_file(&ke->base, &timeslice_duration_def.attr))\n\t\treturn;\n\n\tif (intel_engine_has_preempt_reset(ke->engine) &&\n\t    sysfs_create_file(&ke->base, &preempt_timeout_def.attr))\n\t\treturn;\n}\n\nvoid intel_engines_add_sysfs(struct drm_i915_private *i915)\n{\n\tstatic const struct attribute * const files[] = {\n\t\t&name_attr.attr,\n\t\t&class_attr.attr,\n\t\t&inst_attr.attr,\n\t\t&mmio_attr.attr,\n\t\t&caps_attr.attr,\n\t\t&all_caps_attr.attr,\n\t\t&max_spin_attr.attr,\n\t\t&stop_timeout_attr.attr,\n#if CONFIG_DRM_I915_HEARTBEAT_INTERVAL\n\t\t&heartbeat_interval_attr.attr,\n#endif\n\t\tNULL\n\t};\n\n\tstruct device *kdev = i915->drm.primary->kdev;\n\tstruct intel_engine_cs *engine;\n\tstruct kobject *dir;\n\n\tdir = kobject_create_and_add(\"engine\", &kdev->kobj);\n\tif (!dir)\n\t\treturn;\n\n\tfor_each_uabi_engine(engine, i915) {\n\t\tstruct kobject *kobj;\n\n\t\tkobj = kobj_engine(dir, engine);\n\t\tif (!kobj)\n\t\t\tgoto err_engine;\n\n\t\tif (sysfs_create_files(kobj, files))\n\t\t\tgoto err_object;\n\n\t\tif (intel_engine_has_timeslices(engine) &&\n\t\t    sysfs_create_file(kobj, &timeslice_duration_attr.attr))\n\t\t\tgoto err_engine;\n\n\t\tif (intel_engine_has_preempt_reset(engine) &&\n\t\t    sysfs_create_file(kobj, &preempt_timeout_attr.attr))\n\t\t\tgoto err_engine;\n\n\t\tadd_defaults(container_of(kobj, struct kobj_engine, base));\n\n\t\tif (0) {\nerr_object:\n\t\t\tkobject_put(kobj);\nerr_engine:\n\t\t\tdev_err(kdev, \"Failed to add sysfs engine '%s'\\n\",\n\t\t\t\tengine->name);\n\t\t\tbreak;\n\t\t}\n\t}\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}