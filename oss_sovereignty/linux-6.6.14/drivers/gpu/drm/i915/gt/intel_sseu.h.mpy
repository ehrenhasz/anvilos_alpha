{
  "module_name": "intel_sseu.h",
  "hash_id": "ff964826df9f308e6734091f843672e8d06d078afe8d00bc469139153263430a",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/i915/gt/intel_sseu.h",
  "human_readable_source": " \n \n\n#ifndef __INTEL_SSEU_H__\n#define __INTEL_SSEU_H__\n\n#include <linux/types.h>\n#include <linux/kernel.h>\n\n#include \"i915_gem.h\"\n\nstruct drm_i915_private;\nstruct intel_gt;\nstruct drm_printer;\n\n \n#define GEN_MAX_HSW_SLICES\t\t3\n\n \n#define GEN_MAX_SS_PER_HSW_SLICE\t8\n\n \n#define I915_MAX_SS_FUSE_REGS\t2\n#define I915_MAX_SS_FUSE_BITS\t(I915_MAX_SS_FUSE_REGS * 32)\n\n \n#define GEN_MAX_EUS_PER_SS\t\t16\n\n#define SSEU_MAX(a, b)\t\t\t((a) > (b) ? (a) : (b))\n\n \n#define GEN_SS_MASK_SIZE\t\tSSEU_MAX(I915_MAX_SS_FUSE_BITS, \\\n\t\t\t\t\t\t GEN_MAX_HSW_SLICES * GEN_MAX_SS_PER_HSW_SLICE)\n\n#define GEN_SSEU_STRIDE(max_entries)\tDIV_ROUND_UP(max_entries, BITS_PER_BYTE)\n#define GEN_MAX_SUBSLICE_STRIDE\t\tGEN_SSEU_STRIDE(GEN_SS_MASK_SIZE)\n#define GEN_MAX_EU_STRIDE\t\tGEN_SSEU_STRIDE(GEN_MAX_EUS_PER_SS)\n\n#define GEN_DSS_PER_GSLICE\t4\n#define GEN_DSS_PER_CSLICE\t8\n#define GEN_DSS_PER_MSLICE\t8\n\n#define GEN_MAX_GSLICES\t\t(I915_MAX_SS_FUSE_BITS / GEN_DSS_PER_GSLICE)\n#define GEN_MAX_CSLICES\t\t(I915_MAX_SS_FUSE_BITS / GEN_DSS_PER_CSLICE)\n\ntypedef union {\n\tu8 hsw[GEN_MAX_HSW_SLICES];\n\n\t \n\tunsigned long xehp[BITS_TO_LONGS(I915_MAX_SS_FUSE_BITS)];\n} intel_sseu_ss_mask_t;\n\n#define XEHP_BITMAP_BITS(mask)\t((int)BITS_PER_TYPE(typeof(mask.xehp)))\n\nstruct sseu_dev_info {\n\tu8 slice_mask;\n\tintel_sseu_ss_mask_t subslice_mask;\n\tintel_sseu_ss_mask_t geometry_subslice_mask;\n\tintel_sseu_ss_mask_t compute_subslice_mask;\n\tunion {\n\t\tu16 hsw[GEN_MAX_HSW_SLICES][GEN_MAX_SS_PER_HSW_SLICE];\n\t\tu16 xehp[I915_MAX_SS_FUSE_BITS];\n\t} eu_mask;\n\n\tu16 eu_total;\n\tu8 eu_per_subslice;\n\tu8 min_eu_in_pool;\n\t \n\tu8 subslice_7eu[3];\n\tu8 has_slice_pg:1;\n\tu8 has_subslice_pg:1;\n\tu8 has_eu_pg:1;\n\t \n\tu8 has_xehp_dss:1;\n\n\t \n\tu8 max_slices;\n\tu8 max_subslices;\n\tu8 max_eus_per_subslice;\n};\n\n \nstruct intel_sseu {\n\tu8 slice_mask;\n\tu8 subslice_mask;\n\tu8 min_eus_per_subslice;\n\tu8 max_eus_per_subslice;\n};\n\nstatic inline struct intel_sseu\nintel_sseu_from_device_info(const struct sseu_dev_info *sseu)\n{\n\tstruct intel_sseu value = {\n\t\t.slice_mask = sseu->slice_mask,\n\t\t.subslice_mask = sseu->subslice_mask.hsw[0],\n\t\t.min_eus_per_subslice = sseu->max_eus_per_subslice,\n\t\t.max_eus_per_subslice = sseu->max_eus_per_subslice,\n\t};\n\n\treturn value;\n}\n\nstatic inline bool\nintel_sseu_has_subslice(const struct sseu_dev_info *sseu, int slice,\n\t\t\tint subslice)\n{\n\tif (slice >= sseu->max_slices ||\n\t    subslice >= sseu->max_subslices)\n\t\treturn false;\n\n\tif (sseu->has_xehp_dss)\n\t\treturn test_bit(subslice, sseu->subslice_mask.xehp);\n\telse\n\t\treturn sseu->subslice_mask.hsw[slice] & BIT(subslice);\n}\n\n \nstatic inline unsigned int\nintel_sseu_find_first_xehp_dss(const struct sseu_dev_info *sseu, int groupsize,\n\t\t\t       int groupnum)\n{\n\treturn find_next_bit(sseu->subslice_mask.xehp,\n\t\t\t     XEHP_BITMAP_BITS(sseu->subslice_mask),\n\t\t\t     groupnum * groupsize);\n}\n\nvoid intel_sseu_set_info(struct sseu_dev_info *sseu, u8 max_slices,\n\t\t\t u8 max_subslices, u8 max_eus_per_subslice);\n\nunsigned int\nintel_sseu_subslice_total(const struct sseu_dev_info *sseu);\n\nunsigned int\nintel_sseu_get_hsw_subslices(const struct sseu_dev_info *sseu, u8 slice);\n\nintel_sseu_ss_mask_t\nintel_sseu_get_compute_subslices(const struct sseu_dev_info *sseu);\n\nvoid intel_sseu_info_init(struct intel_gt *gt);\n\nu32 intel_sseu_make_rpcs(struct intel_gt *gt,\n\t\t\t const struct intel_sseu *req_sseu);\n\nvoid intel_sseu_dump(const struct sseu_dev_info *sseu, struct drm_printer *p);\nvoid intel_sseu_print_topology(struct drm_i915_private *i915,\n\t\t\t       const struct sseu_dev_info *sseu,\n\t\t\t       struct drm_printer *p);\n\nu16 intel_slicemask_from_xehp_dssmask(intel_sseu_ss_mask_t dss_mask, int dss_per_slice);\n\nint intel_sseu_copy_eumask_to_user(void __user *to,\n\t\t\t\t   const struct sseu_dev_info *sseu);\nint intel_sseu_copy_ssmask_to_user(void __user *to,\n\t\t\t\t   const struct sseu_dev_info *sseu);\n\nvoid intel_sseu_print_ss_info(const char *type,\n\t\t\t      const struct sseu_dev_info *sseu,\n\t\t\t      struct seq_file *m);\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}