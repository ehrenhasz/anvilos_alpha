{
  "module_name": "intel_gt_mcr.c",
  "hash_id": "51002dd648760e2b39d520258c64c10b3fb7d62984e19505ac815c686a24198d",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/i915/gt/intel_gt_mcr.c",
  "human_readable_source": "\n \n\n#include \"i915_drv.h\"\n\n#include \"intel_gt_mcr.h\"\n#include \"intel_gt_print.h\"\n#include \"intel_gt_regs.h\"\n\n \n\n#define HAS_MSLICE_STEERING(i915)\t(INTEL_INFO(i915)->has_mslice_steering)\n\nstatic const char * const intel_steering_types[] = {\n\t\"L3BANK\",\n\t\"MSLICE\",\n\t\"LNCF\",\n\t\"GAM\",\n\t\"DSS\",\n\t\"OADDRM\",\n\t\"INSTANCE 0\",\n};\n\nstatic const struct intel_mmio_range icl_l3bank_steering_table[] = {\n\t{ 0x00B100, 0x00B3FF },\n\t{},\n};\n\n \nstatic const struct intel_mmio_range xehpsdv_mslice_steering_table[] = {\n\t{ 0x00DD00, 0x00DDFF },\n\t{ 0x00E900, 0x00FFFF },  \n\t{},\n};\n\nstatic const struct intel_mmio_range xehpsdv_gam_steering_table[] = {\n\t{ 0x004000, 0x004AFF },\n\t{ 0x00C800, 0x00CFFF },\n\t{},\n};\n\nstatic const struct intel_mmio_range xehpsdv_lncf_steering_table[] = {\n\t{ 0x00B000, 0x00B0FF },\n\t{ 0x00D800, 0x00D8FF },\n\t{},\n};\n\nstatic const struct intel_mmio_range dg2_lncf_steering_table[] = {\n\t{ 0x00B000, 0x00B0FF },\n\t{ 0x00D880, 0x00D8FF },\n\t{},\n};\n\n \nstatic const struct intel_mmio_range pvc_instance0_steering_table[] = {\n\t{ 0x004000, 0x004AFF },\t\t \n\t{ 0x008800, 0x00887F },\t\t \n\t{ 0x008A80, 0x008AFF },\t\t \n\t{ 0x00B000, 0x00B0FF },\t\t \n\t{ 0x00B100, 0x00B3FF },\t\t \n\t{ 0x00C800, 0x00CFFF },\t\t \n\t{ 0x00D800, 0x00D8FF },\t\t \n\t{ 0x00DD00, 0x00DDFF },\t\t \n\t{ 0x00E900, 0x00E9FF },\t\t \n\t{ 0x00EC00, 0x00EEFF },\t\t \n\t{ 0x00F000, 0x00FFFF },\t\t \n\t{ 0x024180, 0x0241FF },\t\t \n\t{},\n};\n\nstatic const struct intel_mmio_range xelpg_instance0_steering_table[] = {\n\t{ 0x000B00, 0x000BFF },          \n\t{ 0x001000, 0x001FFF },          \n\t{ 0x004000, 0x0048FF },          \n\t{ 0x008700, 0x0087FF },          \n\t{ 0x00B000, 0x00B0FF },          \n\t{ 0x00C800, 0x00CFFF },          \n\t{ 0x00D880, 0x00D8FF },          \n\t{ 0x00DD00, 0x00DDFF },          \n\t{},\n};\n\nstatic const struct intel_mmio_range xelpg_l3bank_steering_table[] = {\n\t{ 0x00B100, 0x00B3FF },\n\t{},\n};\n\n \nstatic const struct intel_mmio_range xelpg_dss_steering_table[] = {\n\t{ 0x005200, 0x0052FF },\t\t \n\t{ 0x005500, 0x007FFF },\t\t \n\t{ 0x008140, 0x00815F },\t\t \n\t{ 0x0094D0, 0x00955F },\t\t \n\t{ 0x009680, 0x0096FF },\t\t \n\t{ 0x00D800, 0x00D87F },\t\t \n\t{ 0x00DC00, 0x00DCFF },\t\t \n\t{ 0x00DE80, 0x00E8FF },\t\t \n\t{},\n};\n\nstatic const struct intel_mmio_range xelpmp_oaddrm_steering_table[] = {\n\t{ 0x393200, 0x39323F },\n\t{ 0x393400, 0x3934FF },\n\t{},\n};\n\nvoid intel_gt_mcr_init(struct intel_gt *gt)\n{\n\tstruct drm_i915_private *i915 = gt->i915;\n\tunsigned long fuse;\n\tint i;\n\n\tspin_lock_init(&gt->mcr_lock);\n\n\t \n\tif (HAS_MSLICE_STEERING(i915)) {\n\t\tgt->info.mslice_mask =\n\t\t\tintel_slicemask_from_xehp_dssmask(gt->info.sseu.subslice_mask,\n\t\t\t\t\t\t\t  GEN_DSS_PER_MSLICE);\n\t\tgt->info.mslice_mask |=\n\t\t\t(intel_uncore_read(gt->uncore, GEN10_MIRROR_FUSE3) &\n\t\t\t GEN12_MEML3_EN_MASK);\n\n\t\tif (!gt->info.mslice_mask)  \n\t\t\tgt_warn(gt, \"mslice mask all zero!\\n\");\n\t}\n\n\tif (MEDIA_VER(i915) >= 13 && gt->type == GT_MEDIA) {\n\t\tgt->steering_table[OADDRM] = xelpmp_oaddrm_steering_table;\n\t} else if (GRAPHICS_VER_FULL(i915) >= IP_VER(12, 70)) {\n\t\t \n\t\tif (IS_MTL_GRAPHICS_STEP(i915, M, STEP_A0, STEP_B0) ||\n\t\t    IS_MTL_GRAPHICS_STEP(i915, P, STEP_A0, STEP_B0))\n\t\t\tfuse = REG_FIELD_GET(MTL_GT_L3_EXC_MASK,\n\t\t\t\t\t     intel_uncore_read(gt->uncore,\n\t\t\t\t\t\t\t       MTL_GT_ACTIVITY_FACTOR));\n\t\telse\n\t\t\tfuse = REG_FIELD_GET(GT_L3_EXC_MASK,\n\t\t\t\t\t     intel_uncore_read(gt->uncore, XEHP_FUSE4));\n\n\t\t \n\t\tfor_each_set_bit(i, &fuse, 3)\n\t\t\tgt->info.l3bank_mask |= 0x3 << 2 * i;\n\n\t\tgt->steering_table[INSTANCE0] = xelpg_instance0_steering_table;\n\t\tgt->steering_table[L3BANK] = xelpg_l3bank_steering_table;\n\t\tgt->steering_table[DSS] = xelpg_dss_steering_table;\n\t} else if (IS_PONTEVECCHIO(i915)) {\n\t\tgt->steering_table[INSTANCE0] = pvc_instance0_steering_table;\n\t} else if (IS_DG2(i915)) {\n\t\tgt->steering_table[MSLICE] = xehpsdv_mslice_steering_table;\n\t\tgt->steering_table[LNCF] = dg2_lncf_steering_table;\n\t\t \n\t} else if (IS_XEHPSDV(i915)) {\n\t\tgt->steering_table[MSLICE] = xehpsdv_mslice_steering_table;\n\t\tgt->steering_table[LNCF] = xehpsdv_lncf_steering_table;\n\t\tgt->steering_table[GAM] = xehpsdv_gam_steering_table;\n\t} else if (GRAPHICS_VER(i915) >= 11 &&\n\t\t   GRAPHICS_VER_FULL(i915) < IP_VER(12, 50)) {\n\t\tgt->steering_table[L3BANK] = icl_l3bank_steering_table;\n\t\tgt->info.l3bank_mask =\n\t\t\t~intel_uncore_read(gt->uncore, GEN10_MIRROR_FUSE3) &\n\t\t\tGEN10_L3BANK_MASK;\n\t\tif (!gt->info.l3bank_mask)  \n\t\t\tgt_warn(gt, \"L3 bank mask is all zero!\\n\");\n\t} else if (GRAPHICS_VER(i915) >= 11) {\n\t\t \n\t\tMISSING_CASE(INTEL_INFO(i915)->platform);\n\t}\n}\n\n \nstatic i915_reg_t mcr_reg_cast(const i915_mcr_reg_t mcr)\n{\n\ti915_reg_t r = { .reg = mcr.reg };\n\n\treturn r;\n}\n\n \nstatic u32 rw_with_mcr_steering_fw(struct intel_gt *gt,\n\t\t\t\t   i915_mcr_reg_t reg, u8 rw_flag,\n\t\t\t\t   int group, int instance, u32 value)\n{\n\tstruct intel_uncore *uncore = gt->uncore;\n\tu32 mcr_mask, mcr_ss, mcr, old_mcr, val = 0;\n\n\tlockdep_assert_held(&gt->mcr_lock);\n\n\tif (GRAPHICS_VER_FULL(uncore->i915) >= IP_VER(12, 70)) {\n\t\t \n\t\tintel_uncore_write_fw(uncore, MTL_MCR_SELECTOR,\n\t\t\t\t      REG_FIELD_PREP(MTL_MCR_GROUPID, group) |\n\t\t\t\t      REG_FIELD_PREP(MTL_MCR_INSTANCEID, instance) |\n\t\t\t\t      (rw_flag == FW_REG_READ ? GEN11_MCR_MULTICAST : 0));\n\t} else if (GRAPHICS_VER(uncore->i915) >= 11) {\n\t\tmcr_mask = GEN11_MCR_SLICE_MASK | GEN11_MCR_SUBSLICE_MASK;\n\t\tmcr_ss = GEN11_MCR_SLICE(group) | GEN11_MCR_SUBSLICE(instance);\n\n\t\t \n\t\tif (rw_flag == FW_REG_WRITE)\n\t\t\tmcr_mask |= GEN11_MCR_MULTICAST;\n\n\t\tmcr = intel_uncore_read_fw(uncore, GEN8_MCR_SELECTOR);\n\t\told_mcr = mcr;\n\n\t\tmcr &= ~mcr_mask;\n\t\tmcr |= mcr_ss;\n\t\tintel_uncore_write_fw(uncore, GEN8_MCR_SELECTOR, mcr);\n\t} else {\n\t\tmcr_mask = GEN8_MCR_SLICE_MASK | GEN8_MCR_SUBSLICE_MASK;\n\t\tmcr_ss = GEN8_MCR_SLICE(group) | GEN8_MCR_SUBSLICE(instance);\n\n\t\tmcr = intel_uncore_read_fw(uncore, GEN8_MCR_SELECTOR);\n\t\told_mcr = mcr;\n\n\t\tmcr &= ~mcr_mask;\n\t\tmcr |= mcr_ss;\n\t\tintel_uncore_write_fw(uncore, GEN8_MCR_SELECTOR, mcr);\n\t}\n\n\tif (rw_flag == FW_REG_READ)\n\t\tval = intel_uncore_read_fw(uncore, mcr_reg_cast(reg));\n\telse\n\t\tintel_uncore_write_fw(uncore, mcr_reg_cast(reg), value);\n\n\t \n\tif (GRAPHICS_VER_FULL(uncore->i915) >= IP_VER(12, 70) && rw_flag == FW_REG_WRITE)\n\t\tintel_uncore_write_fw(uncore, MTL_MCR_SELECTOR, GEN11_MCR_MULTICAST);\n\telse if (GRAPHICS_VER_FULL(uncore->i915) < IP_VER(12, 70))\n\t\tintel_uncore_write_fw(uncore, GEN8_MCR_SELECTOR, old_mcr);\n\n\treturn val;\n}\n\nstatic u32 rw_with_mcr_steering(struct intel_gt *gt,\n\t\t\t\ti915_mcr_reg_t reg, u8 rw_flag,\n\t\t\t\tint group, int instance,\n\t\t\t\tu32 value)\n{\n\tstruct intel_uncore *uncore = gt->uncore;\n\tenum forcewake_domains fw_domains;\n\tunsigned long flags;\n\tu32 val;\n\n\tfw_domains = intel_uncore_forcewake_for_reg(uncore, mcr_reg_cast(reg),\n\t\t\t\t\t\t    rw_flag);\n\tfw_domains |= intel_uncore_forcewake_for_reg(uncore,\n\t\t\t\t\t\t     GEN8_MCR_SELECTOR,\n\t\t\t\t\t\t     FW_REG_READ | FW_REG_WRITE);\n\n\tintel_gt_mcr_lock(gt, &flags);\n\tspin_lock(&uncore->lock);\n\tintel_uncore_forcewake_get__locked(uncore, fw_domains);\n\n\tval = rw_with_mcr_steering_fw(gt, reg, rw_flag, group, instance, value);\n\n\tintel_uncore_forcewake_put__locked(uncore, fw_domains);\n\tspin_unlock(&uncore->lock);\n\tintel_gt_mcr_unlock(gt, flags);\n\n\treturn val;\n}\n\n \nvoid intel_gt_mcr_lock(struct intel_gt *gt, unsigned long *flags)\n\t__acquires(&gt->mcr_lock)\n{\n\tunsigned long __flags;\n\tint err = 0;\n\n\tlockdep_assert_not_held(&gt->uncore->lock);\n\n\t \n\tif (GRAPHICS_VER_FULL(gt->i915) >= IP_VER(12, 70)) {\n\t\t \n\t\tintel_uncore_forcewake_get(gt->uncore, FORCEWAKE_GT);\n\n\t\terr = wait_for(intel_uncore_read_fw(gt->uncore,\n\t\t\t\t\t\t    MTL_STEER_SEMAPHORE) == 0x1, 100);\n\t}\n\n\t \n\tspin_lock_irqsave(&gt->mcr_lock, __flags);\n\n\t*flags = __flags;\n\n\t \n\tif (err == -ETIMEDOUT) {\n\t\tgt_err_ratelimited(gt, \"hardware MCR steering semaphore timed out\");\n\t\tadd_taint_for_CI(gt->i915, TAINT_WARN);   \n\t}\n}\n\n \nvoid intel_gt_mcr_unlock(struct intel_gt *gt, unsigned long flags)\n\t__releases(&gt->mcr_lock)\n{\n\tspin_unlock_irqrestore(&gt->mcr_lock, flags);\n\n\tif (GRAPHICS_VER_FULL(gt->i915) >= IP_VER(12, 70)) {\n\t\tintel_uncore_write_fw(gt->uncore, MTL_STEER_SEMAPHORE, 0x1);\n\n\t\tintel_uncore_forcewake_put(gt->uncore, FORCEWAKE_GT);\n\t}\n}\n\n \nu32 intel_gt_mcr_read(struct intel_gt *gt,\n\t\t      i915_mcr_reg_t reg,\n\t\t      int group, int instance)\n{\n\treturn rw_with_mcr_steering(gt, reg, FW_REG_READ, group, instance, 0);\n}\n\n \nvoid intel_gt_mcr_unicast_write(struct intel_gt *gt, i915_mcr_reg_t reg, u32 value,\n\t\t\t\tint group, int instance)\n{\n\trw_with_mcr_steering(gt, reg, FW_REG_WRITE, group, instance, value);\n}\n\n \nvoid intel_gt_mcr_multicast_write(struct intel_gt *gt,\n\t\t\t\t  i915_mcr_reg_t reg, u32 value)\n{\n\tunsigned long flags;\n\n\tintel_gt_mcr_lock(gt, &flags);\n\n\t \n\tif (GRAPHICS_VER_FULL(gt->i915) >= IP_VER(12, 70))\n\t\tintel_uncore_write_fw(gt->uncore, MTL_MCR_SELECTOR, GEN11_MCR_MULTICAST);\n\n\tintel_uncore_write(gt->uncore, mcr_reg_cast(reg), value);\n\n\tintel_gt_mcr_unlock(gt, flags);\n}\n\n \nvoid intel_gt_mcr_multicast_write_fw(struct intel_gt *gt, i915_mcr_reg_t reg, u32 value)\n{\n\tlockdep_assert_held(&gt->mcr_lock);\n\n\t \n\tif (GRAPHICS_VER_FULL(gt->i915) >= IP_VER(12, 70))\n\t\tintel_uncore_write_fw(gt->uncore, MTL_MCR_SELECTOR, GEN11_MCR_MULTICAST);\n\n\tintel_uncore_write_fw(gt->uncore, mcr_reg_cast(reg), value);\n}\n\n \nu32 intel_gt_mcr_multicast_rmw(struct intel_gt *gt, i915_mcr_reg_t reg,\n\t\t\t       u32 clear, u32 set)\n{\n\tu32 val = intel_gt_mcr_read_any(gt, reg);\n\n\tintel_gt_mcr_multicast_write(gt, reg, (val & ~clear) | set);\n\n\treturn val;\n}\n\n \nstatic bool reg_needs_read_steering(struct intel_gt *gt,\n\t\t\t\t    i915_mcr_reg_t reg,\n\t\t\t\t    enum intel_steering_type type)\n{\n\tu32 offset = i915_mmio_reg_offset(reg);\n\tconst struct intel_mmio_range *entry;\n\n\tif (likely(!gt->steering_table[type]))\n\t\treturn false;\n\n\tif (IS_GSI_REG(offset))\n\t\toffset += gt->uncore->gsi_offset;\n\n\tfor (entry = gt->steering_table[type]; entry->end; entry++) {\n\t\tif (offset >= entry->start && offset <= entry->end)\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}\n\n \nstatic void get_nonterminated_steering(struct intel_gt *gt,\n\t\t\t\t       enum intel_steering_type type,\n\t\t\t\t       u8 *group, u8 *instance)\n{\n\tu32 dss;\n\n\tswitch (type) {\n\tcase L3BANK:\n\t\t*group = 0;\t\t \n\t\t*instance = __ffs(gt->info.l3bank_mask);\n\t\tbreak;\n\tcase MSLICE:\n\t\tGEM_WARN_ON(!HAS_MSLICE_STEERING(gt->i915));\n\t\t*group = __ffs(gt->info.mslice_mask);\n\t\t*instance = 0;\t \n\t\tbreak;\n\tcase LNCF:\n\t\t \n\t\tGEM_WARN_ON(!HAS_MSLICE_STEERING(gt->i915));\n\t\t*group = __ffs(gt->info.mslice_mask) << 1;\n\t\t*instance = 0;\t \n\t\tbreak;\n\tcase GAM:\n\t\t*group = IS_DG2(gt->i915) ? 1 : 0;\n\t\t*instance = 0;\n\t\tbreak;\n\tcase DSS:\n\t\tdss = intel_sseu_find_first_xehp_dss(&gt->info.sseu, 0, 0);\n\t\t*group = dss / GEN_DSS_PER_GSLICE;\n\t\t*instance = dss % GEN_DSS_PER_GSLICE;\n\t\tbreak;\n\tcase INSTANCE0:\n\t\t \n\t\t*group = 0;\n\t\t*instance = 0;\n\t\tbreak;\n\tcase OADDRM:\n\t\tif ((VDBOX_MASK(gt) | VEBOX_MASK(gt) | gt->info.sfc_mask) & BIT(0))\n\t\t\t*group = 0;\n\t\telse\n\t\t\t*group = 1;\n\t\t*instance = 0;\n\t\tbreak;\n\tdefault:\n\t\tMISSING_CASE(type);\n\t\t*group = 0;\n\t\t*instance = 0;\n\t}\n}\n\n \nvoid intel_gt_mcr_get_nonterminated_steering(struct intel_gt *gt,\n\t\t\t\t\t     i915_mcr_reg_t reg,\n\t\t\t\t\t     u8 *group, u8 *instance)\n{\n\tint type;\n\n\tfor (type = 0; type < NUM_STEERING_TYPES; type++) {\n\t\tif (reg_needs_read_steering(gt, reg, type)) {\n\t\t\tget_nonterminated_steering(gt, type, group, instance);\n\t\t\treturn;\n\t\t}\n\t}\n\n\t*group = gt->default_steering.groupid;\n\t*instance = gt->default_steering.instanceid;\n}\n\n \nu32 intel_gt_mcr_read_any_fw(struct intel_gt *gt, i915_mcr_reg_t reg)\n{\n\tint type;\n\tu8 group, instance;\n\n\tlockdep_assert_held(&gt->mcr_lock);\n\n\tfor (type = 0; type < NUM_STEERING_TYPES; type++) {\n\t\tif (reg_needs_read_steering(gt, reg, type)) {\n\t\t\tget_nonterminated_steering(gt, type, &group, &instance);\n\t\t\treturn rw_with_mcr_steering_fw(gt, reg,\n\t\t\t\t\t\t       FW_REG_READ,\n\t\t\t\t\t\t       group, instance, 0);\n\t\t}\n\t}\n\n\treturn intel_uncore_read_fw(gt->uncore, mcr_reg_cast(reg));\n}\n\n \nu32 intel_gt_mcr_read_any(struct intel_gt *gt, i915_mcr_reg_t reg)\n{\n\tint type;\n\tu8 group, instance;\n\n\tfor (type = 0; type < NUM_STEERING_TYPES; type++) {\n\t\tif (reg_needs_read_steering(gt, reg, type)) {\n\t\t\tget_nonterminated_steering(gt, type, &group, &instance);\n\t\t\treturn rw_with_mcr_steering(gt, reg,\n\t\t\t\t\t\t    FW_REG_READ,\n\t\t\t\t\t\t    group, instance, 0);\n\t\t}\n\t}\n\n\treturn intel_uncore_read(gt->uncore, mcr_reg_cast(reg));\n}\n\nstatic void report_steering_type(struct drm_printer *p,\n\t\t\t\t struct intel_gt *gt,\n\t\t\t\t enum intel_steering_type type,\n\t\t\t\t bool dump_table)\n{\n\tconst struct intel_mmio_range *entry;\n\tu8 group, instance;\n\n\tBUILD_BUG_ON(ARRAY_SIZE(intel_steering_types) != NUM_STEERING_TYPES);\n\n\tif (!gt->steering_table[type]) {\n\t\tdrm_printf(p, \"%s steering: uses default steering\\n\",\n\t\t\t   intel_steering_types[type]);\n\t\treturn;\n\t}\n\n\tget_nonterminated_steering(gt, type, &group, &instance);\n\tdrm_printf(p, \"%s steering: group=0x%x, instance=0x%x\\n\",\n\t\t   intel_steering_types[type], group, instance);\n\n\tif (!dump_table)\n\t\treturn;\n\n\tfor (entry = gt->steering_table[type]; entry->end; entry++)\n\t\tdrm_printf(p, \"\\t0x%06x - 0x%06x\\n\", entry->start, entry->end);\n}\n\nvoid intel_gt_mcr_report_steering(struct drm_printer *p, struct intel_gt *gt,\n\t\t\t\t  bool dump_table)\n{\n\t \n\tif (GRAPHICS_VER_FULL(gt->i915) < IP_VER(12, 70))\n\t\tdrm_printf(p, \"Default steering: group=0x%x, instance=0x%x\\n\",\n\t\t\t   gt->default_steering.groupid,\n\t\t\t   gt->default_steering.instanceid);\n\n\tif (GRAPHICS_VER_FULL(gt->i915) >= IP_VER(12, 70)) {\n\t\tfor (int i = 0; i < NUM_STEERING_TYPES; i++)\n\t\t\tif (gt->steering_table[i])\n\t\t\t\treport_steering_type(p, gt, i, dump_table);\n\t} else if (IS_PONTEVECCHIO(gt->i915)) {\n\t\treport_steering_type(p, gt, INSTANCE0, dump_table);\n\t} else if (HAS_MSLICE_STEERING(gt->i915)) {\n\t\treport_steering_type(p, gt, MSLICE, dump_table);\n\t\treport_steering_type(p, gt, LNCF, dump_table);\n\t}\n}\n\n \nvoid intel_gt_mcr_get_ss_steering(struct intel_gt *gt, unsigned int dss,\n\t\t\t\t   unsigned int *group, unsigned int *instance)\n{\n\tif (IS_PONTEVECCHIO(gt->i915)) {\n\t\t*group = dss / GEN_DSS_PER_CSLICE;\n\t\t*instance = dss % GEN_DSS_PER_CSLICE;\n\t} else if (GRAPHICS_VER_FULL(gt->i915) >= IP_VER(12, 50)) {\n\t\t*group = dss / GEN_DSS_PER_GSLICE;\n\t\t*instance = dss % GEN_DSS_PER_GSLICE;\n\t} else {\n\t\t*group = dss / GEN_MAX_SS_PER_HSW_SLICE;\n\t\t*instance = dss % GEN_MAX_SS_PER_HSW_SLICE;\n\t\treturn;\n\t}\n}\n\n \nint intel_gt_mcr_wait_for_reg(struct intel_gt *gt,\n\t\t\t      i915_mcr_reg_t reg,\n\t\t\t      u32 mask,\n\t\t\t      u32 value,\n\t\t\t      unsigned int fast_timeout_us,\n\t\t\t      unsigned int slow_timeout_ms)\n{\n\tint ret;\n\n\tlockdep_assert_not_held(&gt->mcr_lock);\n\n#define done ((intel_gt_mcr_read_any(gt, reg) & mask) == value)\n\n\t \n\tmight_sleep_if(slow_timeout_ms);\n\tGEM_BUG_ON(fast_timeout_us > 20000);\n\tGEM_BUG_ON(!fast_timeout_us && !slow_timeout_ms);\n\n\tret = -ETIMEDOUT;\n\tif (fast_timeout_us && fast_timeout_us <= 20000)\n\t\tret = _wait_for_atomic(done, fast_timeout_us, 0);\n\tif (ret && slow_timeout_ms)\n\t\tret = wait_for(done, slow_timeout_ms);\n\n\treturn ret;\n#undef done\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}