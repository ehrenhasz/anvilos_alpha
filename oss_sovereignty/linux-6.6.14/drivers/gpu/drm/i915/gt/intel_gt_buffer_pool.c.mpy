{
  "module_name": "intel_gt_buffer_pool.c",
  "hash_id": "9a34db1efa49b1d70f2e9aac58e8076be5735b32d1a3b3278bd0e3c59a88a61d",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/i915/gt/intel_gt_buffer_pool.c",
  "human_readable_source": "\n \n\n#include \"gem/i915_gem_internal.h\"\n#include \"gem/i915_gem_object.h\"\n\n#include \"i915_drv.h\"\n#include \"intel_engine_pm.h\"\n#include \"intel_gt_buffer_pool.h\"\n\nstatic struct list_head *\nbucket_for_size(struct intel_gt_buffer_pool *pool, size_t sz)\n{\n\tint n;\n\n\t \n\tn = fls(sz >> PAGE_SHIFT) - 1;\n\tif (n >= ARRAY_SIZE(pool->cache_list))\n\t\tn = ARRAY_SIZE(pool->cache_list) - 1;\n\n\treturn &pool->cache_list[n];\n}\n\nstatic void node_free(struct intel_gt_buffer_pool_node *node)\n{\n\ti915_gem_object_put(node->obj);\n\ti915_active_fini(&node->active);\n\tkfree_rcu(node, rcu);\n}\n\nstatic bool pool_free_older_than(struct intel_gt_buffer_pool *pool, long keep)\n{\n\tstruct intel_gt_buffer_pool_node *node, *stale = NULL;\n\tbool active = false;\n\tint n;\n\n\t \n\tfor (n = 0; n < ARRAY_SIZE(pool->cache_list); n++) {\n\t\tstruct list_head *list = &pool->cache_list[n];\n\n\t\tif (list_empty(list))\n\t\t\tcontinue;\n\n\t\tif (spin_trylock_irq(&pool->lock)) {\n\t\t\tstruct list_head *pos;\n\n\t\t\t \n\t\t\tlist_for_each_prev(pos, list) {\n\t\t\t\tunsigned long age;\n\n\t\t\t\tnode = list_entry(pos, typeof(*node), link);\n\n\t\t\t\tage = READ_ONCE(node->age);\n\t\t\t\tif (!age || jiffies - age < keep)\n\t\t\t\t\tbreak;\n\n\t\t\t\t \n\t\t\t\tif (!xchg(&node->age, 0))\n\t\t\t\t\tbreak;\n\n\t\t\t\tnode->free = stale;\n\t\t\t\tstale = node;\n\t\t\t}\n\t\t\tif (!list_is_last(pos, list))\n\t\t\t\t__list_del_many(pos, list);\n\n\t\t\tspin_unlock_irq(&pool->lock);\n\t\t}\n\n\t\tactive |= !list_empty(list);\n\t}\n\n\twhile ((node = stale)) {\n\t\tstale = stale->free;\n\t\tnode_free(node);\n\t}\n\n\treturn active;\n}\n\nstatic void pool_free_work(struct work_struct *wrk)\n{\n\tstruct intel_gt_buffer_pool *pool =\n\t\tcontainer_of(wrk, typeof(*pool), work.work);\n\tstruct intel_gt *gt = container_of(pool, struct intel_gt, buffer_pool);\n\n\tif (pool_free_older_than(pool, HZ))\n\t\tqueue_delayed_work(gt->i915->unordered_wq, &pool->work,\n\t\t\t\t   round_jiffies_up_relative(HZ));\n}\n\nstatic void pool_retire(struct i915_active *ref)\n{\n\tstruct intel_gt_buffer_pool_node *node =\n\t\tcontainer_of(ref, typeof(*node), active);\n\tstruct intel_gt_buffer_pool *pool = node->pool;\n\tstruct intel_gt *gt = container_of(pool, struct intel_gt, buffer_pool);\n\tstruct list_head *list = bucket_for_size(pool, node->obj->base.size);\n\tunsigned long flags;\n\n\tif (node->pinned) {\n\t\ti915_gem_object_unpin_pages(node->obj);\n\n\t\t \n\t\ti915_gem_object_make_purgeable(node->obj);\n\t\tnode->pinned = false;\n\t}\n\n\tGEM_BUG_ON(node->age);\n\tspin_lock_irqsave(&pool->lock, flags);\n\tlist_add_rcu(&node->link, list);\n\tWRITE_ONCE(node->age, jiffies ?: 1);  \n\tspin_unlock_irqrestore(&pool->lock, flags);\n\n\tqueue_delayed_work(gt->i915->unordered_wq, &pool->work,\n\t\t\t   round_jiffies_up_relative(HZ));\n}\n\nvoid intel_gt_buffer_pool_mark_used(struct intel_gt_buffer_pool_node *node)\n{\n\tassert_object_held(node->obj);\n\n\tif (node->pinned)\n\t\treturn;\n\n\t__i915_gem_object_pin_pages(node->obj);\n\t \n\ti915_gem_object_make_unshrinkable(node->obj);\n\tnode->pinned = true;\n}\n\nstatic struct intel_gt_buffer_pool_node *\nnode_create(struct intel_gt_buffer_pool *pool, size_t sz,\n\t    enum i915_map_type type)\n{\n\tstruct intel_gt *gt = container_of(pool, struct intel_gt, buffer_pool);\n\tstruct intel_gt_buffer_pool_node *node;\n\tstruct drm_i915_gem_object *obj;\n\n\tnode = kmalloc(sizeof(*node),\n\t\t       GFP_KERNEL | __GFP_RETRY_MAYFAIL | __GFP_NOWARN);\n\tif (!node)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tnode->age = 0;\n\tnode->pool = pool;\n\tnode->pinned = false;\n\ti915_active_init(&node->active, NULL, pool_retire, 0);\n\n\tobj = i915_gem_object_create_internal(gt->i915, sz);\n\tif (IS_ERR(obj)) {\n\t\ti915_active_fini(&node->active);\n\t\tkfree(node);\n\t\treturn ERR_CAST(obj);\n\t}\n\n\ti915_gem_object_set_readonly(obj);\n\n\tnode->type = type;\n\tnode->obj = obj;\n\treturn node;\n}\n\nstruct intel_gt_buffer_pool_node *\nintel_gt_get_buffer_pool(struct intel_gt *gt, size_t size,\n\t\t\t enum i915_map_type type)\n{\n\tstruct intel_gt_buffer_pool *pool = &gt->buffer_pool;\n\tstruct intel_gt_buffer_pool_node *node;\n\tstruct list_head *list;\n\tint ret;\n\n\tsize = PAGE_ALIGN(size);\n\tlist = bucket_for_size(pool, size);\n\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(node, list, link) {\n\t\tunsigned long age;\n\n\t\tif (node->obj->base.size < size)\n\t\t\tcontinue;\n\n\t\tif (node->type != type)\n\t\t\tcontinue;\n\n\t\tage = READ_ONCE(node->age);\n\t\tif (!age)\n\t\t\tcontinue;\n\n\t\tif (cmpxchg(&node->age, age, 0) == age) {\n\t\t\tspin_lock_irq(&pool->lock);\n\t\t\tlist_del_rcu(&node->link);\n\t\t\tspin_unlock_irq(&pool->lock);\n\t\t\tbreak;\n\t\t}\n\t}\n\trcu_read_unlock();\n\n\tif (&node->link == list) {\n\t\tnode = node_create(pool, size, type);\n\t\tif (IS_ERR(node))\n\t\t\treturn node;\n\t}\n\n\tret = i915_active_acquire(&node->active);\n\tif (ret) {\n\t\tnode_free(node);\n\t\treturn ERR_PTR(ret);\n\t}\n\n\treturn node;\n}\n\nvoid intel_gt_init_buffer_pool(struct intel_gt *gt)\n{\n\tstruct intel_gt_buffer_pool *pool = &gt->buffer_pool;\n\tint n;\n\n\tspin_lock_init(&pool->lock);\n\tfor (n = 0; n < ARRAY_SIZE(pool->cache_list); n++)\n\t\tINIT_LIST_HEAD(&pool->cache_list[n]);\n\tINIT_DELAYED_WORK(&pool->work, pool_free_work);\n}\n\nvoid intel_gt_flush_buffer_pool(struct intel_gt *gt)\n{\n\tstruct intel_gt_buffer_pool *pool = &gt->buffer_pool;\n\n\tdo {\n\t\twhile (pool_free_older_than(pool, 0))\n\t\t\t;\n\t} while (cancel_delayed_work_sync(&pool->work));\n}\n\nvoid intel_gt_fini_buffer_pool(struct intel_gt *gt)\n{\n\tstruct intel_gt_buffer_pool *pool = &gt->buffer_pool;\n\tint n;\n\n\tfor (n = 0; n < ARRAY_SIZE(pool->cache_list); n++)\n\t\tGEM_BUG_ON(!list_empty(&pool->cache_list[n]));\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}