{
  "module_name": "intel_sseu_debugfs.c",
  "hash_id": "de86a63bf307052c2b56cf3b4e76b751e4e54b090ab46dc6d17e88df67ceeb57",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/i915/gt/intel_sseu_debugfs.c",
  "human_readable_source": "\n\n \n\n#include <linux/bitmap.h>\n#include <linux/string_helpers.h>\n\n#include \"i915_drv.h\"\n#include \"intel_gt_debugfs.h\"\n#include \"intel_gt_regs.h\"\n#include \"intel_sseu_debugfs.h\"\n\nstatic void cherryview_sseu_device_status(struct intel_gt *gt,\n\t\t\t\t\t  struct sseu_dev_info *sseu)\n{\n#define SS_MAX 2\n\tstruct intel_uncore *uncore = gt->uncore;\n\tconst int ss_max = SS_MAX;\n\tu32 sig1[SS_MAX], sig2[SS_MAX];\n\tint ss;\n\n\tsig1[0] = intel_uncore_read(uncore, CHV_POWER_SS0_SIG1);\n\tsig1[1] = intel_uncore_read(uncore, CHV_POWER_SS1_SIG1);\n\tsig2[0] = intel_uncore_read(uncore, CHV_POWER_SS0_SIG2);\n\tsig2[1] = intel_uncore_read(uncore, CHV_POWER_SS1_SIG2);\n\n\tfor (ss = 0; ss < ss_max; ss++) {\n\t\tunsigned int eu_cnt;\n\n\t\tif (sig1[ss] & CHV_SS_PG_ENABLE)\n\t\t\t \n\t\t\tcontinue;\n\n\t\tsseu->slice_mask = BIT(0);\n\t\tsseu->subslice_mask.hsw[0] |= BIT(ss);\n\t\teu_cnt = ((sig1[ss] & CHV_EU08_PG_ENABLE) ? 0 : 2) +\n\t\t\t ((sig1[ss] & CHV_EU19_PG_ENABLE) ? 0 : 2) +\n\t\t\t ((sig1[ss] & CHV_EU210_PG_ENABLE) ? 0 : 2) +\n\t\t\t ((sig2[ss] & CHV_EU311_PG_ENABLE) ? 0 : 2);\n\t\tsseu->eu_total += eu_cnt;\n\t\tsseu->eu_per_subslice = max_t(unsigned int,\n\t\t\t\t\t      sseu->eu_per_subslice, eu_cnt);\n\t}\n#undef SS_MAX\n}\n\nstatic void gen11_sseu_device_status(struct intel_gt *gt,\n\t\t\t\t     struct sseu_dev_info *sseu)\n{\n#define SS_MAX 8\n\tstruct intel_uncore *uncore = gt->uncore;\n\tconst struct intel_gt_info *info = &gt->info;\n\tu32 s_reg[SS_MAX], eu_reg[2 * SS_MAX], eu_mask[2];\n\tint s, ss;\n\n\tfor (s = 0; s < info->sseu.max_slices; s++) {\n\t\t \n\t\ts_reg[s] = intel_uncore_read(uncore, GEN10_SLICE_PGCTL_ACK(s)) &\n\t\t\tGEN10_PGCTL_VALID_SS_MASK(s);\n\t\teu_reg[2 * s] = intel_uncore_read(uncore,\n\t\t\t\t\t\t  GEN10_SS01_EU_PGCTL_ACK(s));\n\t\teu_reg[2 * s + 1] = intel_uncore_read(uncore,\n\t\t\t\t\t\t      GEN10_SS23_EU_PGCTL_ACK(s));\n\t}\n\n\teu_mask[0] = GEN9_PGCTL_SSA_EU08_ACK |\n\t\t     GEN9_PGCTL_SSA_EU19_ACK |\n\t\t     GEN9_PGCTL_SSA_EU210_ACK |\n\t\t     GEN9_PGCTL_SSA_EU311_ACK;\n\teu_mask[1] = GEN9_PGCTL_SSB_EU08_ACK |\n\t\t     GEN9_PGCTL_SSB_EU19_ACK |\n\t\t     GEN9_PGCTL_SSB_EU210_ACK |\n\t\t     GEN9_PGCTL_SSB_EU311_ACK;\n\n\tfor (s = 0; s < info->sseu.max_slices; s++) {\n\t\tif ((s_reg[s] & GEN9_PGCTL_SLICE_ACK) == 0)\n\t\t\t \n\t\t\tcontinue;\n\n\t\tsseu->slice_mask |= BIT(s);\n\t\tsseu->subslice_mask.hsw[s] = info->sseu.subslice_mask.hsw[s];\n\n\t\tfor (ss = 0; ss < info->sseu.max_subslices; ss++) {\n\t\t\tunsigned int eu_cnt;\n\n\t\t\tif (info->sseu.has_subslice_pg &&\n\t\t\t    !(s_reg[s] & (GEN9_PGCTL_SS_ACK(ss))))\n\t\t\t\t \n\t\t\t\tcontinue;\n\n\t\t\teu_cnt = 2 * hweight32(eu_reg[2 * s + ss / 2] &\n\t\t\t\t\t       eu_mask[ss % 2]);\n\t\t\tsseu->eu_total += eu_cnt;\n\t\t\tsseu->eu_per_subslice = max_t(unsigned int,\n\t\t\t\t\t\t      sseu->eu_per_subslice,\n\t\t\t\t\t\t      eu_cnt);\n\t\t}\n\t}\n#undef SS_MAX\n}\n\nstatic void gen9_sseu_device_status(struct intel_gt *gt,\n\t\t\t\t    struct sseu_dev_info *sseu)\n{\n#define SS_MAX 3\n\tstruct intel_uncore *uncore = gt->uncore;\n\tconst struct intel_gt_info *info = &gt->info;\n\tu32 s_reg[SS_MAX], eu_reg[2 * SS_MAX], eu_mask[2];\n\tint s, ss;\n\n\tfor (s = 0; s < info->sseu.max_slices; s++) {\n\t\ts_reg[s] = intel_uncore_read(uncore, GEN9_SLICE_PGCTL_ACK(s));\n\t\teu_reg[2 * s] =\n\t\t\tintel_uncore_read(uncore, GEN9_SS01_EU_PGCTL_ACK(s));\n\t\teu_reg[2 * s + 1] =\n\t\t\tintel_uncore_read(uncore, GEN9_SS23_EU_PGCTL_ACK(s));\n\t}\n\n\teu_mask[0] = GEN9_PGCTL_SSA_EU08_ACK |\n\t\t     GEN9_PGCTL_SSA_EU19_ACK |\n\t\t     GEN9_PGCTL_SSA_EU210_ACK |\n\t\t     GEN9_PGCTL_SSA_EU311_ACK;\n\teu_mask[1] = GEN9_PGCTL_SSB_EU08_ACK |\n\t\t     GEN9_PGCTL_SSB_EU19_ACK |\n\t\t     GEN9_PGCTL_SSB_EU210_ACK |\n\t\t     GEN9_PGCTL_SSB_EU311_ACK;\n\n\tfor (s = 0; s < info->sseu.max_slices; s++) {\n\t\tif ((s_reg[s] & GEN9_PGCTL_SLICE_ACK) == 0)\n\t\t\t \n\t\t\tcontinue;\n\n\t\tsseu->slice_mask |= BIT(s);\n\n\t\tif (IS_GEN9_BC(gt->i915))\n\t\t\tsseu->subslice_mask.hsw[s] = info->sseu.subslice_mask.hsw[s];\n\n\t\tfor (ss = 0; ss < info->sseu.max_subslices; ss++) {\n\t\t\tunsigned int eu_cnt;\n\n\t\t\tif (IS_GEN9_LP(gt->i915)) {\n\t\t\t\tif (!(s_reg[s] & (GEN9_PGCTL_SS_ACK(ss))))\n\t\t\t\t\t \n\t\t\t\t\tcontinue;\n\n\t\t\t\tsseu->subslice_mask.hsw[s] |= BIT(ss);\n\t\t\t}\n\n\t\t\teu_cnt = eu_reg[2 * s + ss / 2] & eu_mask[ss % 2];\n\t\t\teu_cnt = 2 * hweight32(eu_cnt);\n\n\t\t\tsseu->eu_total += eu_cnt;\n\t\t\tsseu->eu_per_subslice = max_t(unsigned int,\n\t\t\t\t\t\t      sseu->eu_per_subslice,\n\t\t\t\t\t\t      eu_cnt);\n\t\t}\n\t}\n#undef SS_MAX\n}\n\nstatic void bdw_sseu_device_status(struct intel_gt *gt,\n\t\t\t\t   struct sseu_dev_info *sseu)\n{\n\tconst struct intel_gt_info *info = &gt->info;\n\tu32 slice_info = intel_uncore_read(gt->uncore, GEN8_GT_SLICE_INFO);\n\tint s;\n\n\tsseu->slice_mask = slice_info & GEN8_LSLICESTAT_MASK;\n\n\tif (sseu->slice_mask) {\n\t\tsseu->eu_per_subslice = info->sseu.eu_per_subslice;\n\t\tfor (s = 0; s < fls(sseu->slice_mask); s++)\n\t\t\tsseu->subslice_mask.hsw[s] = info->sseu.subslice_mask.hsw[s];\n\t\tsseu->eu_total = sseu->eu_per_subslice *\n\t\t\t\t intel_sseu_subslice_total(sseu);\n\n\t\t \n\t\tfor (s = 0; s < fls(sseu->slice_mask); s++) {\n\t\t\tu8 subslice_7eu = info->sseu.subslice_7eu[s];\n\n\t\t\tsseu->eu_total -= hweight8(subslice_7eu);\n\t\t}\n\t}\n}\n\nstatic void i915_print_sseu_info(struct seq_file *m,\n\t\t\t\t bool is_available_info,\n\t\t\t\t bool has_pooled_eu,\n\t\t\t\t const struct sseu_dev_info *sseu)\n{\n\tconst char *type = is_available_info ? \"Available\" : \"Enabled\";\n\n\tseq_printf(m, \"  %s Slice Mask: %04x\\n\", type,\n\t\t   sseu->slice_mask);\n\tseq_printf(m, \"  %s Slice Total: %u\\n\", type,\n\t\t   hweight8(sseu->slice_mask));\n\tseq_printf(m, \"  %s Subslice Total: %u\\n\", type,\n\t\t   intel_sseu_subslice_total(sseu));\n\tintel_sseu_print_ss_info(type, sseu, m);\n\tseq_printf(m, \"  %s EU Total: %u\\n\", type,\n\t\t   sseu->eu_total);\n\tseq_printf(m, \"  %s EU Per Subslice: %u\\n\", type,\n\t\t   sseu->eu_per_subslice);\n\n\tif (!is_available_info)\n\t\treturn;\n\n\tseq_printf(m, \"  Has Pooled EU: %s\\n\", str_yes_no(has_pooled_eu));\n\tif (has_pooled_eu)\n\t\tseq_printf(m, \"  Min EU in pool: %u\\n\", sseu->min_eu_in_pool);\n\n\tseq_printf(m, \"  Has Slice Power Gating: %s\\n\",\n\t\t   str_yes_no(sseu->has_slice_pg));\n\tseq_printf(m, \"  Has Subslice Power Gating: %s\\n\",\n\t\t   str_yes_no(sseu->has_subslice_pg));\n\tseq_printf(m, \"  Has EU Power Gating: %s\\n\",\n\t\t   str_yes_no(sseu->has_eu_pg));\n}\n\n \nint intel_sseu_status(struct seq_file *m, struct intel_gt *gt)\n{\n\tstruct drm_i915_private *i915 = gt->i915;\n\tconst struct intel_gt_info *info = &gt->info;\n\tstruct sseu_dev_info *sseu;\n\tintel_wakeref_t wakeref;\n\n\tif (GRAPHICS_VER(i915) < 8)\n\t\treturn -ENODEV;\n\n\tseq_puts(m, \"SSEU Device Info\\n\");\n\ti915_print_sseu_info(m, true, HAS_POOLED_EU(i915), &info->sseu);\n\n\tseq_puts(m, \"SSEU Device Status\\n\");\n\n\tsseu = kzalloc(sizeof(*sseu), GFP_KERNEL);\n\tif (!sseu)\n\t\treturn -ENOMEM;\n\n\tintel_sseu_set_info(sseu, info->sseu.max_slices,\n\t\t\t    info->sseu.max_subslices,\n\t\t\t    info->sseu.max_eus_per_subslice);\n\n\twith_intel_runtime_pm(&i915->runtime_pm, wakeref) {\n\t\tif (IS_CHERRYVIEW(i915))\n\t\t\tcherryview_sseu_device_status(gt, sseu);\n\t\telse if (IS_BROADWELL(i915))\n\t\t\tbdw_sseu_device_status(gt, sseu);\n\t\telse if (GRAPHICS_VER(i915) == 9)\n\t\t\tgen9_sseu_device_status(gt, sseu);\n\t\telse if (GRAPHICS_VER(i915) >= 11)\n\t\t\tgen11_sseu_device_status(gt, sseu);\n\t}\n\n\ti915_print_sseu_info(m, false, HAS_POOLED_EU(i915), sseu);\n\n\tkfree(sseu);\n\n\treturn 0;\n}\n\nstatic int sseu_status_show(struct seq_file *m, void *unused)\n{\n\tstruct intel_gt *gt = m->private;\n\n\treturn intel_sseu_status(m, gt);\n}\nDEFINE_INTEL_GT_DEBUGFS_ATTRIBUTE(sseu_status);\n\nstatic int sseu_topology_show(struct seq_file *m, void *unused)\n{\n\tstruct intel_gt *gt = m->private;\n\tstruct drm_printer p = drm_seq_file_printer(m);\n\n\tintel_sseu_print_topology(gt->i915, &gt->info.sseu, &p);\n\n\treturn 0;\n}\nDEFINE_INTEL_GT_DEBUGFS_ATTRIBUTE(sseu_topology);\n\nvoid intel_sseu_debugfs_register(struct intel_gt *gt, struct dentry *root)\n{\n\tstatic const struct intel_gt_debugfs_file files[] = {\n\t\t{ \"sseu_status\", &sseu_status_fops, NULL },\n\t\t{ \"sseu_topology\", &sseu_topology_fops, NULL },\n\t};\n\n\tintel_gt_debugfs_register_files(root, files, ARRAY_SIZE(files), gt);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}