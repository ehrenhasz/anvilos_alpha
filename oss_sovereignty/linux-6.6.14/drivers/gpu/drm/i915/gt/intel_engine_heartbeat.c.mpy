{
  "module_name": "intel_engine_heartbeat.c",
  "hash_id": "9e24880cccdca719b27a18edaa87562842f8b5b17e2530250419de041fd833e4",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/i915/gt/intel_engine_heartbeat.c",
  "human_readable_source": "\n \n\n#include \"i915_drv.h\"\n#include \"i915_request.h\"\n\n#include \"intel_context.h\"\n#include \"intel_engine_heartbeat.h\"\n#include \"intel_engine_pm.h\"\n#include \"intel_engine.h\"\n#include \"intel_gt.h\"\n#include \"intel_reset.h\"\n\n \n\nstatic bool next_heartbeat(struct intel_engine_cs *engine)\n{\n\tstruct i915_request *rq;\n\tlong delay;\n\n\tdelay = READ_ONCE(engine->props.heartbeat_interval_ms);\n\n\trq = engine->heartbeat.systole;\n\n\t \n\tif (rq && rq->sched.attr.priority >= I915_PRIORITY_BARRIER &&\n\t    delay == engine->defaults.heartbeat_interval_ms) {\n\t\tlong longer;\n\n\t\t \n\t\tlonger = READ_ONCE(engine->props.preempt_timeout_ms) * 2;\n\t\tlonger = intel_clamp_heartbeat_interval_ms(engine, longer);\n\t\tif (longer > delay)\n\t\t\tdelay = longer;\n\t}\n\n\tif (!delay)\n\t\treturn false;\n\n\tdelay = msecs_to_jiffies_timeout(delay);\n\tif (delay >= HZ)\n\t\tdelay = round_jiffies_up_relative(delay);\n\tmod_delayed_work(system_highpri_wq, &engine->heartbeat.work, delay + 1);\n\n\treturn true;\n}\n\nstatic struct i915_request *\nheartbeat_create(struct intel_context *ce, gfp_t gfp)\n{\n\tstruct i915_request *rq;\n\n\tintel_context_enter(ce);\n\trq = __i915_request_create(ce, gfp);\n\tintel_context_exit(ce);\n\n\treturn rq;\n}\n\nstatic void idle_pulse(struct intel_engine_cs *engine, struct i915_request *rq)\n{\n\tengine->wakeref_serial = READ_ONCE(engine->serial) + 1;\n\ti915_request_add_active_barriers(rq);\n\tif (!engine->heartbeat.systole && intel_engine_has_heartbeat(engine))\n\t\tengine->heartbeat.systole = i915_request_get(rq);\n}\n\nstatic void heartbeat_commit(struct i915_request *rq,\n\t\t\t     const struct i915_sched_attr *attr)\n{\n\tidle_pulse(rq->engine, rq);\n\n\t__i915_request_commit(rq);\n\t__i915_request_queue(rq, attr);\n}\n\nstatic void show_heartbeat(const struct i915_request *rq,\n\t\t\t   struct intel_engine_cs *engine)\n{\n\tstruct drm_printer p = drm_debug_printer(\"heartbeat\");\n\n\tif (!rq) {\n\t\tintel_engine_dump(engine, &p,\n\t\t\t\t  \"%s heartbeat not ticking\\n\",\n\t\t\t\t  engine->name);\n\t} else {\n\t\tintel_engine_dump(engine, &p,\n\t\t\t\t  \"%s heartbeat {seqno:%llx:%lld, prio:%d} not ticking\\n\",\n\t\t\t\t  engine->name,\n\t\t\t\t  rq->fence.context,\n\t\t\t\t  rq->fence.seqno,\n\t\t\t\t  rq->sched.attr.priority);\n\t}\n}\n\nstatic void\nreset_engine(struct intel_engine_cs *engine, struct i915_request *rq)\n{\n\tif (IS_ENABLED(CONFIG_DRM_I915_DEBUG_GEM))\n\t\tshow_heartbeat(rq, engine);\n\n\tif (intel_engine_uses_guc(engine))\n\t\t \n\t\tintel_guc_find_hung_context(engine);\n\n\tintel_gt_handle_error(engine->gt, engine->mask,\n\t\t\t      I915_ERROR_CAPTURE,\n\t\t\t      \"stopped heartbeat on %s\",\n\t\t\t      engine->name);\n}\n\nstatic void heartbeat(struct work_struct *wrk)\n{\n\tstruct i915_sched_attr attr = { .priority = I915_PRIORITY_MIN };\n\tstruct intel_engine_cs *engine =\n\t\tcontainer_of(wrk, typeof(*engine), heartbeat.work.work);\n\tstruct intel_context *ce = engine->kernel_context;\n\tstruct i915_request *rq;\n\tunsigned long serial;\n\n\t \n\tintel_engine_flush_submission(engine);\n\n\trq = engine->heartbeat.systole;\n\tif (rq && i915_request_completed(rq)) {\n\t\ti915_request_put(rq);\n\t\tengine->heartbeat.systole = NULL;\n\t}\n\n\tif (!intel_engine_pm_get_if_awake(engine))\n\t\treturn;\n\n\tif (intel_gt_is_wedged(engine->gt))\n\t\tgoto out;\n\n\tif (i915_sched_engine_disabled(engine->sched_engine)) {\n\t\treset_engine(engine, engine->heartbeat.systole);\n\t\tgoto out;\n\t}\n\n\tif (engine->heartbeat.systole) {\n\t\tlong delay = READ_ONCE(engine->props.heartbeat_interval_ms);\n\n\t\t \n\t\tif (!time_after(jiffies,\n\t\t\t\trq->emitted_jiffies + msecs_to_jiffies(delay)))\n\t\t\tgoto out;\n\n\t\tif (!i915_sw_fence_signaled(&rq->submit)) {\n\t\t\t \n\t\t} else if (engine->sched_engine->schedule &&\n\t\t\t   rq->sched.attr.priority < I915_PRIORITY_BARRIER) {\n\t\t\t \n\t\t\tattr.priority = 0;\n\t\t\tif (rq->sched.attr.priority >= attr.priority)\n\t\t\t\tattr.priority = I915_PRIORITY_HEARTBEAT;\n\t\t\tif (rq->sched.attr.priority >= attr.priority)\n\t\t\t\tattr.priority = I915_PRIORITY_BARRIER;\n\n\t\t\tlocal_bh_disable();\n\t\t\tengine->sched_engine->schedule(rq, &attr);\n\t\t\tlocal_bh_enable();\n\t\t} else {\n\t\t\treset_engine(engine, rq);\n\t\t}\n\n\t\trq->emitted_jiffies = jiffies;\n\t\tgoto out;\n\t}\n\n\tserial = READ_ONCE(engine->serial);\n\tif (engine->wakeref_serial == serial)\n\t\tgoto out;\n\n\tif (!mutex_trylock(&ce->timeline->mutex)) {\n\t\t \n\t\tif (xchg(&engine->heartbeat.blocked, serial) == serial)\n\t\t\tintel_gt_handle_error(engine->gt, engine->mask,\n\t\t\t\t\t      I915_ERROR_CAPTURE,\n\t\t\t\t\t      \"no heartbeat on %s\",\n\t\t\t\t\t      engine->name);\n\t\tgoto out;\n\t}\n\n\trq = heartbeat_create(ce, GFP_NOWAIT | __GFP_NOWARN);\n\tif (IS_ERR(rq))\n\t\tgoto unlock;\n\n\theartbeat_commit(rq, &attr);\n\nunlock:\n\tmutex_unlock(&ce->timeline->mutex);\nout:\n\tif (!engine->i915->params.enable_hangcheck || !next_heartbeat(engine))\n\t\ti915_request_put(fetch_and_zero(&engine->heartbeat.systole));\n\tintel_engine_pm_put(engine);\n}\n\nvoid intel_engine_unpark_heartbeat(struct intel_engine_cs *engine)\n{\n\tif (!CONFIG_DRM_I915_HEARTBEAT_INTERVAL)\n\t\treturn;\n\n\tnext_heartbeat(engine);\n}\n\nvoid intel_engine_park_heartbeat(struct intel_engine_cs *engine)\n{\n\tif (cancel_delayed_work(&engine->heartbeat.work))\n\t\ti915_request_put(fetch_and_zero(&engine->heartbeat.systole));\n}\n\nvoid intel_gt_unpark_heartbeats(struct intel_gt *gt)\n{\n\tstruct intel_engine_cs *engine;\n\tenum intel_engine_id id;\n\n\tfor_each_engine(engine, gt, id)\n\t\tif (intel_engine_pm_is_awake(engine))\n\t\t\tintel_engine_unpark_heartbeat(engine);\n}\n\nvoid intel_gt_park_heartbeats(struct intel_gt *gt)\n{\n\tstruct intel_engine_cs *engine;\n\tenum intel_engine_id id;\n\n\tfor_each_engine(engine, gt, id)\n\t\tintel_engine_park_heartbeat(engine);\n}\n\nvoid intel_engine_init_heartbeat(struct intel_engine_cs *engine)\n{\n\tINIT_DELAYED_WORK(&engine->heartbeat.work, heartbeat);\n}\n\nstatic int __intel_engine_pulse(struct intel_engine_cs *engine)\n{\n\tstruct i915_sched_attr attr = { .priority = I915_PRIORITY_BARRIER };\n\tstruct intel_context *ce = engine->kernel_context;\n\tstruct i915_request *rq;\n\n\tlockdep_assert_held(&ce->timeline->mutex);\n\tGEM_BUG_ON(!intel_engine_has_preemption(engine));\n\tGEM_BUG_ON(!intel_engine_pm_is_awake(engine));\n\n\trq = heartbeat_create(ce, GFP_NOWAIT | __GFP_NOWARN);\n\tif (IS_ERR(rq))\n\t\treturn PTR_ERR(rq);\n\n\t__set_bit(I915_FENCE_FLAG_SENTINEL, &rq->fence.flags);\n\n\theartbeat_commit(rq, &attr);\n\tGEM_BUG_ON(rq->sched.attr.priority < I915_PRIORITY_BARRIER);\n\n\treturn 0;\n}\n\nstatic unsigned long set_heartbeat(struct intel_engine_cs *engine,\n\t\t\t\t   unsigned long delay)\n{\n\tunsigned long old;\n\n\told = xchg(&engine->props.heartbeat_interval_ms, delay);\n\tif (delay)\n\t\tintel_engine_unpark_heartbeat(engine);\n\telse\n\t\tintel_engine_park_heartbeat(engine);\n\n\treturn old;\n}\n\nint intel_engine_set_heartbeat(struct intel_engine_cs *engine,\n\t\t\t       unsigned long delay)\n{\n\tstruct intel_context *ce = engine->kernel_context;\n\tint err = 0;\n\n\tif (!delay && !intel_engine_has_preempt_reset(engine))\n\t\treturn -ENODEV;\n\n\t \n\tif (delay != engine->defaults.heartbeat_interval_ms &&\n\t    delay < 2 * engine->props.preempt_timeout_ms) {\n\t\tif (intel_engine_uses_guc(engine))\n\t\t\tdrm_notice(&engine->i915->drm, \"%s heartbeat interval adjusted to a non-default value which may downgrade individual engine resets to full GPU resets!\\n\",\n\t\t\t\t   engine->name);\n\t\telse\n\t\t\tdrm_notice(&engine->i915->drm, \"%s heartbeat interval adjusted to a non-default value which may cause engine resets to target innocent contexts!\\n\",\n\t\t\t\t   engine->name);\n\t}\n\n\tintel_engine_pm_get(engine);\n\n\terr = mutex_lock_interruptible(&ce->timeline->mutex);\n\tif (err)\n\t\tgoto out_rpm;\n\n\tif (delay != engine->props.heartbeat_interval_ms) {\n\t\tunsigned long saved = set_heartbeat(engine, delay);\n\n\t\t \n\t\tif (intel_engine_has_preemption(engine)) {\n\t\t\terr = __intel_engine_pulse(engine);\n\t\t\tif (err)\n\t\t\t\tset_heartbeat(engine, saved);\n\t\t}\n\t}\n\n\tmutex_unlock(&ce->timeline->mutex);\n\nout_rpm:\n\tintel_engine_pm_put(engine);\n\treturn err;\n}\n\nint intel_engine_pulse(struct intel_engine_cs *engine)\n{\n\tstruct intel_context *ce = engine->kernel_context;\n\tint err;\n\n\tif (!intel_engine_has_preemption(engine))\n\t\treturn -ENODEV;\n\n\tif (!intel_engine_pm_get_if_awake(engine))\n\t\treturn 0;\n\n\terr = -EINTR;\n\tif (!mutex_lock_interruptible(&ce->timeline->mutex)) {\n\t\terr = __intel_engine_pulse(engine);\n\t\tmutex_unlock(&ce->timeline->mutex);\n\t}\n\n\tintel_engine_flush_submission(engine);\n\tintel_engine_pm_put(engine);\n\treturn err;\n}\n\nint intel_engine_flush_barriers(struct intel_engine_cs *engine)\n{\n\tstruct i915_sched_attr attr = { .priority = I915_PRIORITY_MIN };\n\tstruct intel_context *ce = engine->kernel_context;\n\tstruct i915_request *rq;\n\tint err;\n\n\tif (llist_empty(&engine->barrier_tasks))\n\t\treturn 0;\n\n\tif (!intel_engine_pm_get_if_awake(engine))\n\t\treturn 0;\n\n\tif (mutex_lock_interruptible(&ce->timeline->mutex)) {\n\t\terr = -EINTR;\n\t\tgoto out_rpm;\n\t}\n\n\trq = heartbeat_create(ce, GFP_KERNEL);\n\tif (IS_ERR(rq)) {\n\t\terr = PTR_ERR(rq);\n\t\tgoto out_unlock;\n\t}\n\n\theartbeat_commit(rq, &attr);\n\n\terr = 0;\nout_unlock:\n\tmutex_unlock(&ce->timeline->mutex);\nout_rpm:\n\tintel_engine_pm_put(engine);\n\treturn err;\n}\n\n#if IS_ENABLED(CONFIG_DRM_I915_SELFTEST)\n#include \"selftest_engine_heartbeat.c\"\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}