{
  "module_name": "selftest_engine_heartbeat.c",
  "hash_id": "fd51a3a6ec1321ad587d6a531f4cb8786ca0f24e7763cdf8d680ccb8ee60addc",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/i915/gt/selftest_engine_heartbeat.c",
  "human_readable_source": "\n \n\n#include <linux/sort.h>\n\n#include \"i915_drv.h\"\n\n#include \"intel_gt_requests.h\"\n#include \"i915_selftest.h\"\n#include \"selftest_engine_heartbeat.h\"\n\nstatic void reset_heartbeat(struct intel_engine_cs *engine)\n{\n\tintel_engine_set_heartbeat(engine,\n\t\t\t\t   engine->defaults.heartbeat_interval_ms);\n}\n\nstatic int timeline_sync(struct intel_timeline *tl)\n{\n\tstruct dma_fence *fence;\n\tlong timeout;\n\n\tfence = i915_active_fence_get(&tl->last_request);\n\tif (!fence)\n\t\treturn 0;\n\n\ttimeout = dma_fence_wait_timeout(fence, true, HZ / 2);\n\tdma_fence_put(fence);\n\tif (timeout < 0)\n\t\treturn timeout;\n\n\treturn 0;\n}\n\nstatic int engine_sync_barrier(struct intel_engine_cs *engine)\n{\n\treturn timeline_sync(engine->kernel_context->timeline);\n}\n\nstruct pulse {\n\tstruct i915_active active;\n\tstruct kref kref;\n};\n\nstatic int pulse_active(struct i915_active *active)\n{\n\tkref_get(&container_of(active, struct pulse, active)->kref);\n\treturn 0;\n}\n\nstatic void pulse_free(struct kref *kref)\n{\n\tstruct pulse *p = container_of(kref, typeof(*p), kref);\n\n\ti915_active_fini(&p->active);\n\tkfree(p);\n}\n\nstatic void pulse_put(struct pulse *p)\n{\n\tkref_put(&p->kref, pulse_free);\n}\n\nstatic void pulse_retire(struct i915_active *active)\n{\n\tpulse_put(container_of(active, struct pulse, active));\n}\n\nstatic struct pulse *pulse_create(void)\n{\n\tstruct pulse *p;\n\n\tp = kmalloc(sizeof(*p), GFP_KERNEL);\n\tif (!p)\n\t\treturn p;\n\n\tkref_init(&p->kref);\n\ti915_active_init(&p->active, pulse_active, pulse_retire, 0);\n\n\treturn p;\n}\n\nstatic void pulse_unlock_wait(struct pulse *p)\n{\n\ti915_active_unlock_wait(&p->active);\n}\n\nstatic int __live_idle_pulse(struct intel_engine_cs *engine,\n\t\t\t     int (*fn)(struct intel_engine_cs *cs))\n{\n\tstruct pulse *p;\n\tint err;\n\n\tGEM_BUG_ON(!intel_engine_pm_is_awake(engine));\n\n\tp = pulse_create();\n\tif (!p)\n\t\treturn -ENOMEM;\n\n\terr = i915_active_acquire(&p->active);\n\tif (err)\n\t\tgoto out;\n\n\terr = i915_active_acquire_preallocate_barrier(&p->active, engine);\n\tif (err) {\n\t\ti915_active_release(&p->active);\n\t\tgoto out;\n\t}\n\n\ti915_active_acquire_barrier(&p->active);\n\ti915_active_release(&p->active);\n\n\tGEM_BUG_ON(i915_active_is_idle(&p->active));\n\tGEM_BUG_ON(llist_empty(&engine->barrier_tasks));\n\n\terr = fn(engine);\n\tif (err)\n\t\tgoto out;\n\n\tGEM_BUG_ON(!llist_empty(&engine->barrier_tasks));\n\n\tif (engine_sync_barrier(engine)) {\n\t\tstruct drm_printer m = drm_err_printer(\"pulse\");\n\n\t\tpr_err(\"%s: no heartbeat pulse?\\n\", engine->name);\n\t\tintel_engine_dump(engine, &m, \"%s\", engine->name);\n\n\t\terr = -ETIME;\n\t\tgoto out;\n\t}\n\n\tGEM_BUG_ON(READ_ONCE(engine->serial) != engine->wakeref_serial);\n\n\tpulse_unlock_wait(p);  \n\n\tif (!i915_active_is_idle(&p->active)) {\n\t\tstruct drm_printer m = drm_err_printer(\"pulse\");\n\n\t\tpr_err(\"%s: heartbeat pulse did not flush idle tasks\\n\",\n\t\t       engine->name);\n\t\ti915_active_print(&p->active, &m);\n\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\nout:\n\tpulse_put(p);\n\treturn err;\n}\n\nstatic int live_idle_flush(void *arg)\n{\n\tstruct intel_gt *gt = arg;\n\tstruct intel_engine_cs *engine;\n\tenum intel_engine_id id;\n\tint err = 0;\n\n\t \n\n\tfor_each_engine(engine, gt, id) {\n\t\tst_engine_heartbeat_disable(engine);\n\t\terr = __live_idle_pulse(engine, intel_engine_flush_barriers);\n\t\tst_engine_heartbeat_enable(engine);\n\t\tif (err)\n\t\t\tbreak;\n\t}\n\n\treturn err;\n}\n\nstatic int live_idle_pulse(void *arg)\n{\n\tstruct intel_gt *gt = arg;\n\tstruct intel_engine_cs *engine;\n\tenum intel_engine_id id;\n\tint err = 0;\n\n\t \n\n\tfor_each_engine(engine, gt, id) {\n\t\tst_engine_heartbeat_disable(engine);\n\t\terr = __live_idle_pulse(engine, intel_engine_pulse);\n\t\tst_engine_heartbeat_enable(engine);\n\t\tif (err && err != -ENODEV)\n\t\t\tbreak;\n\n\t\terr = 0;\n\t}\n\n\treturn err;\n}\n\nstatic int cmp_u32(const void *_a, const void *_b)\n{\n\tconst u32 *a = _a, *b = _b;\n\n\treturn *a - *b;\n}\n\nstatic int __live_heartbeat_fast(struct intel_engine_cs *engine)\n{\n\tconst unsigned int error_threshold = max(20000u, jiffies_to_usecs(6));\n\tstruct intel_context *ce;\n\tstruct i915_request *rq;\n\tktime_t t0, t1;\n\tu32 times[5];\n\tint err;\n\tint i;\n\n\tce = intel_context_create(engine);\n\tif (IS_ERR(ce))\n\t\treturn PTR_ERR(ce);\n\n\tintel_engine_pm_get(engine);\n\n\terr = intel_engine_set_heartbeat(engine, 1);\n\tif (err)\n\t\tgoto err_pm;\n\n\tfor (i = 0; i < ARRAY_SIZE(times); i++) {\n\t\tdo {\n\t\t\t \n\t\t\tintel_engine_park_heartbeat(engine);\n\t\t\tGEM_BUG_ON(engine->heartbeat.systole);\n\t\t\tengine->serial++;  \n\t\t\tintel_engine_unpark_heartbeat(engine);\n\n\t\t\tflush_delayed_work(&engine->heartbeat.work);\n\t\t\tif (!delayed_work_pending(&engine->heartbeat.work)) {\n\t\t\t\tpr_err(\"%s: heartbeat %d did not start\\n\",\n\t\t\t\t       engine->name, i);\n\t\t\t\terr = -EINVAL;\n\t\t\t\tgoto err_pm;\n\t\t\t}\n\n\t\t\trcu_read_lock();\n\t\t\trq = READ_ONCE(engine->heartbeat.systole);\n\t\t\tif (rq)\n\t\t\t\trq = i915_request_get_rcu(rq);\n\t\t\trcu_read_unlock();\n\t\t} while (!rq);\n\n\t\tt0 = ktime_get();\n\t\twhile (rq == READ_ONCE(engine->heartbeat.systole))\n\t\t\tyield();  \n\t\tt1 = ktime_get();\n\n\t\ti915_request_put(rq);\n\t\ttimes[i] = ktime_us_delta(t1, t0);\n\t}\n\n\tsort(times, ARRAY_SIZE(times), sizeof(times[0]), cmp_u32, NULL);\n\n\tpr_info(\"%s: Heartbeat delay: %uus [%u, %u]\\n\",\n\t\tengine->name,\n\t\ttimes[ARRAY_SIZE(times) / 2],\n\t\ttimes[0],\n\t\ttimes[ARRAY_SIZE(times) - 1]);\n\n\t \n\tif (times[ARRAY_SIZE(times) / 2] > error_threshold) {\n\t\tpr_err(\"%s: Heartbeat delay was %uus, expected less than %dus\\n\",\n\t\t       engine->name,\n\t\t       times[ARRAY_SIZE(times) / 2],\n\t\t       error_threshold);\n\t\terr = -EINVAL;\n\t}\n\n\treset_heartbeat(engine);\nerr_pm:\n\tintel_engine_pm_put(engine);\n\tintel_context_put(ce);\n\treturn err;\n}\n\nstatic int live_heartbeat_fast(void *arg)\n{\n\tstruct intel_gt *gt = arg;\n\tstruct intel_engine_cs *engine;\n\tenum intel_engine_id id;\n\tint err = 0;\n\n\t \n\tif (!CONFIG_DRM_I915_HEARTBEAT_INTERVAL)\n\t\treturn 0;\n\n\tfor_each_engine(engine, gt, id) {\n\t\terr = __live_heartbeat_fast(engine);\n\t\tif (err)\n\t\t\tbreak;\n\t}\n\n\treturn err;\n}\n\nstatic int __live_heartbeat_off(struct intel_engine_cs *engine)\n{\n\tint err;\n\n\tintel_engine_pm_get(engine);\n\n\tengine->serial++;\n\tflush_delayed_work(&engine->heartbeat.work);\n\tif (!delayed_work_pending(&engine->heartbeat.work)) {\n\t\tpr_err(\"%s: heartbeat not running\\n\",\n\t\t       engine->name);\n\t\terr = -EINVAL;\n\t\tgoto err_pm;\n\t}\n\n\terr = intel_engine_set_heartbeat(engine, 0);\n\tif (err)\n\t\tgoto err_pm;\n\n\tengine->serial++;\n\tflush_delayed_work(&engine->heartbeat.work);\n\tif (delayed_work_pending(&engine->heartbeat.work)) {\n\t\tpr_err(\"%s: heartbeat still running\\n\",\n\t\t       engine->name);\n\t\terr = -EINVAL;\n\t\tgoto err_beat;\n\t}\n\n\tif (READ_ONCE(engine->heartbeat.systole)) {\n\t\tpr_err(\"%s: heartbeat still allocated\\n\",\n\t\t       engine->name);\n\t\terr = -EINVAL;\n\t\tgoto err_beat;\n\t}\n\nerr_beat:\n\treset_heartbeat(engine);\nerr_pm:\n\tintel_engine_pm_put(engine);\n\treturn err;\n}\n\nstatic int live_heartbeat_off(void *arg)\n{\n\tstruct intel_gt *gt = arg;\n\tstruct intel_engine_cs *engine;\n\tenum intel_engine_id id;\n\tint err = 0;\n\n\t \n\tif (!CONFIG_DRM_I915_HEARTBEAT_INTERVAL)\n\t\treturn 0;\n\n\tfor_each_engine(engine, gt, id) {\n\t\tif (!intel_engine_has_preemption(engine))\n\t\t\tcontinue;\n\n\t\terr = __live_heartbeat_off(engine);\n\t\tif (err)\n\t\t\tbreak;\n\t}\n\n\treturn err;\n}\n\nint intel_heartbeat_live_selftests(struct drm_i915_private *i915)\n{\n\tstatic const struct i915_subtest tests[] = {\n\t\tSUBTEST(live_idle_flush),\n\t\tSUBTEST(live_idle_pulse),\n\t\tSUBTEST(live_heartbeat_fast),\n\t\tSUBTEST(live_heartbeat_off),\n\t};\n\tint saved_hangcheck;\n\tint err;\n\n\tif (intel_gt_is_wedged(to_gt(i915)))\n\t\treturn 0;\n\n\tsaved_hangcheck = i915->params.enable_hangcheck;\n\ti915->params.enable_hangcheck = INT_MAX;\n\n\terr = intel_gt_live_subtests(tests, to_gt(i915));\n\n\ti915->params.enable_hangcheck = saved_hangcheck;\n\treturn err;\n}\n\nvoid st_engine_heartbeat_disable(struct intel_engine_cs *engine)\n{\n\tengine->props.heartbeat_interval_ms = 0;\n\n\tintel_engine_pm_get(engine);\n\tintel_engine_park_heartbeat(engine);\n}\n\nvoid st_engine_heartbeat_enable(struct intel_engine_cs *engine)\n{\n\tintel_engine_pm_put(engine);\n\n\tengine->props.heartbeat_interval_ms =\n\t\tengine->defaults.heartbeat_interval_ms;\n}\n\nvoid st_engine_heartbeat_disable_no_pm(struct intel_engine_cs *engine)\n{\n\tengine->props.heartbeat_interval_ms = 0;\n\n\t \n\tif (intel_engine_pm_get_if_awake(engine)) {\n\t\tintel_engine_park_heartbeat(engine);\n\t\tintel_engine_pm_put(engine);\n\t}\n}\n\nvoid st_engine_heartbeat_enable_no_pm(struct intel_engine_cs *engine)\n{\n\tengine->props.heartbeat_interval_ms =\n\t\tengine->defaults.heartbeat_interval_ms;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}