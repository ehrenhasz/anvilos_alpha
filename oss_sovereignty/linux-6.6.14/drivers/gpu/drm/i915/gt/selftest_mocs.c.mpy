{
  "module_name": "selftest_mocs.c",
  "hash_id": "d6d3bf9fa9e90fbe382c2bfaf76513ecb525baa15ef181aa02020f67928af52a",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/i915/gt/selftest_mocs.c",
  "human_readable_source": "\n \n\n#include \"gt/intel_engine_pm.h\"\n#include \"gt/intel_gpu_commands.h\"\n#include \"i915_selftest.h\"\n\n#include \"gem/selftests/igt_gem_utils.h\"\n#include \"gem/selftests/mock_context.h\"\n#include \"selftests/igt_reset.h\"\n#include \"selftests/igt_spinner.h\"\n#include \"selftests/intel_scheduler_helpers.h\"\n\nstruct live_mocs {\n\tstruct drm_i915_mocs_table table;\n\tstruct drm_i915_mocs_table *mocs;\n\tstruct drm_i915_mocs_table *l3cc;\n\tstruct i915_vma *scratch;\n\tvoid *vaddr;\n};\n\nstatic struct intel_context *mocs_context_create(struct intel_engine_cs *engine)\n{\n\tstruct intel_context *ce;\n\n\tce = intel_context_create(engine);\n\tif (IS_ERR(ce))\n\t\treturn ce;\n\n\t \n\tce->ring_size = SZ_16K;\n\n\treturn ce;\n}\n\nstatic int request_add_sync(struct i915_request *rq, int err)\n{\n\ti915_request_get(rq);\n\ti915_request_add(rq);\n\tif (i915_request_wait(rq, 0, HZ / 5) < 0)\n\t\terr = -ETIME;\n\ti915_request_put(rq);\n\n\treturn err;\n}\n\nstatic int request_add_spin(struct i915_request *rq, struct igt_spinner *spin)\n{\n\tint err = 0;\n\n\ti915_request_get(rq);\n\ti915_request_add(rq);\n\tif (spin && !igt_wait_for_spinner(spin, rq))\n\t\terr = -ETIME;\n\ti915_request_put(rq);\n\n\treturn err;\n}\n\nstatic int live_mocs_init(struct live_mocs *arg, struct intel_gt *gt)\n{\n\tunsigned int flags;\n\tint err;\n\n\tmemset(arg, 0, sizeof(*arg));\n\n\tflags = get_mocs_settings(gt->i915, &arg->table);\n\tif (!flags)\n\t\treturn -EINVAL;\n\n\tif (flags & HAS_RENDER_L3CC)\n\t\targ->l3cc = &arg->table;\n\n\tif (flags & (HAS_GLOBAL_MOCS | HAS_ENGINE_MOCS))\n\t\targ->mocs = &arg->table;\n\n\targ->scratch =\n\t\t__vm_create_scratch_for_read_pinned(&gt->ggtt->vm, PAGE_SIZE);\n\tif (IS_ERR(arg->scratch))\n\t\treturn PTR_ERR(arg->scratch);\n\n\targ->vaddr = i915_gem_object_pin_map_unlocked(arg->scratch->obj, I915_MAP_WB);\n\tif (IS_ERR(arg->vaddr)) {\n\t\terr = PTR_ERR(arg->vaddr);\n\t\tgoto err_scratch;\n\t}\n\n\treturn 0;\n\nerr_scratch:\n\ti915_vma_unpin_and_release(&arg->scratch, 0);\n\treturn err;\n}\n\nstatic void live_mocs_fini(struct live_mocs *arg)\n{\n\ti915_vma_unpin_and_release(&arg->scratch, I915_VMA_RELEASE_MAP);\n}\n\nstatic int read_regs(struct i915_request *rq,\n\t\t     u32 addr, unsigned int count,\n\t\t     u32 *offset)\n{\n\tunsigned int i;\n\tu32 *cs;\n\n\tGEM_BUG_ON(!IS_ALIGNED(*offset, sizeof(u32)));\n\n\tcs = intel_ring_begin(rq, 4 * count);\n\tif (IS_ERR(cs))\n\t\treturn PTR_ERR(cs);\n\n\tfor (i = 0; i < count; i++) {\n\t\t*cs++ = MI_STORE_REGISTER_MEM_GEN8 | MI_USE_GGTT;\n\t\t*cs++ = addr;\n\t\t*cs++ = *offset;\n\t\t*cs++ = 0;\n\n\t\taddr += sizeof(u32);\n\t\t*offset += sizeof(u32);\n\t}\n\n\tintel_ring_advance(rq, cs);\n\n\treturn 0;\n}\n\nstatic int read_mocs_table(struct i915_request *rq,\n\t\t\t   const struct drm_i915_mocs_table *table,\n\t\t\t   u32 *offset)\n{\n\tstruct intel_gt *gt = rq->engine->gt;\n\tu32 addr;\n\n\tif (!table)\n\t\treturn 0;\n\n\tif (HAS_GLOBAL_MOCS_REGISTERS(rq->i915))\n\t\taddr = global_mocs_offset() + gt->uncore->gsi_offset;\n\telse\n\t\taddr = mocs_offset(rq->engine);\n\n\treturn read_regs(rq, addr, table->n_entries, offset);\n}\n\nstatic int read_l3cc_table(struct i915_request *rq,\n\t\t\t   const struct drm_i915_mocs_table *table,\n\t\t\t   u32 *offset)\n{\n\tu32 addr = i915_mmio_reg_offset(GEN9_LNCFCMOCS(0));\n\n\tif (!table)\n\t\treturn 0;\n\n\treturn read_regs(rq, addr, (table->n_entries + 1) / 2, offset);\n}\n\nstatic int check_mocs_table(struct intel_engine_cs *engine,\n\t\t\t    const struct drm_i915_mocs_table *table,\n\t\t\t    u32 **vaddr)\n{\n\tunsigned int i;\n\tu32 expect;\n\n\tif (!table)\n\t\treturn 0;\n\n\tfor_each_mocs(expect, table, i) {\n\t\tif (**vaddr != expect) {\n\t\t\tpr_err(\"%s: Invalid MOCS[%d] entry, found %08x, expected %08x\\n\",\n\t\t\t       engine->name, i, **vaddr, expect);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\t++*vaddr;\n\t}\n\n\treturn 0;\n}\n\nstatic bool mcr_range(struct drm_i915_private *i915, u32 offset)\n{\n\t \n\treturn GRAPHICS_VER(i915) >= 8 && offset >= 0xb000 && offset <= 0xb4ff;\n}\n\nstatic int check_l3cc_table(struct intel_engine_cs *engine,\n\t\t\t    const struct drm_i915_mocs_table *table,\n\t\t\t    u32 **vaddr)\n{\n\t \n\tu32 reg = i915_mmio_reg_offset(GEN9_LNCFCMOCS(0));\n\tunsigned int i;\n\tu32 expect;\n\n\tif (!table)\n\t\treturn 0;\n\n\tfor_each_l3cc(expect, table, i) {\n\t\tif (!mcr_range(engine->i915, reg) && **vaddr != expect) {\n\t\t\tpr_err(\"%s: Invalid L3CC[%d] entry, found %08x, expected %08x\\n\",\n\t\t\t       engine->name, i, **vaddr, expect);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\t++*vaddr;\n\t\treg += 4;\n\t}\n\n\treturn 0;\n}\n\nstatic int check_mocs_engine(struct live_mocs *arg,\n\t\t\t     struct intel_context *ce)\n{\n\tstruct i915_vma *vma = arg->scratch;\n\tstruct i915_request *rq;\n\tu32 offset;\n\tu32 *vaddr;\n\tint err;\n\n\tmemset32(arg->vaddr, STACK_MAGIC, PAGE_SIZE / sizeof(u32));\n\n\trq = intel_context_create_request(ce);\n\tif (IS_ERR(rq))\n\t\treturn PTR_ERR(rq);\n\n\terr = igt_vma_move_to_active_unlocked(vma, rq, EXEC_OBJECT_WRITE);\n\n\t \n\toffset = i915_ggtt_offset(vma);\n\tif (!err)\n\t\terr = read_mocs_table(rq, arg->mocs, &offset);\n\tif (!err && ce->engine->class == RENDER_CLASS)\n\t\terr = read_l3cc_table(rq, arg->l3cc, &offset);\n\toffset -= i915_ggtt_offset(vma);\n\tGEM_BUG_ON(offset > PAGE_SIZE);\n\n\terr = request_add_sync(rq, err);\n\tif (err)\n\t\treturn err;\n\n\t \n\tvaddr = arg->vaddr;\n\tif (!err)\n\t\terr = check_mocs_table(ce->engine, arg->mocs, &vaddr);\n\tif (!err && ce->engine->class == RENDER_CLASS)\n\t\terr = check_l3cc_table(ce->engine, arg->l3cc, &vaddr);\n\tif (err)\n\t\treturn err;\n\n\tGEM_BUG_ON(arg->vaddr + offset != vaddr);\n\treturn 0;\n}\n\nstatic int live_mocs_kernel(void *arg)\n{\n\tstruct intel_gt *gt = arg;\n\tstruct intel_engine_cs *engine;\n\tenum intel_engine_id id;\n\tstruct live_mocs mocs;\n\tint err;\n\n\t \n\n\terr = live_mocs_init(&mocs, gt);\n\tif (err)\n\t\treturn err;\n\n\tfor_each_engine(engine, gt, id) {\n\t\tintel_engine_pm_get(engine);\n\t\terr = check_mocs_engine(&mocs, engine->kernel_context);\n\t\tintel_engine_pm_put(engine);\n\t\tif (err)\n\t\t\tbreak;\n\t}\n\n\tlive_mocs_fini(&mocs);\n\treturn err;\n}\n\nstatic int live_mocs_clean(void *arg)\n{\n\tstruct intel_gt *gt = arg;\n\tstruct intel_engine_cs *engine;\n\tenum intel_engine_id id;\n\tstruct live_mocs mocs;\n\tint err;\n\n\t \n\n\terr = live_mocs_init(&mocs, gt);\n\tif (err)\n\t\treturn err;\n\n\tfor_each_engine(engine, gt, id) {\n\t\tstruct intel_context *ce;\n\n\t\tce = mocs_context_create(engine);\n\t\tif (IS_ERR(ce)) {\n\t\t\terr = PTR_ERR(ce);\n\t\t\tbreak;\n\t\t}\n\n\t\terr = check_mocs_engine(&mocs, ce);\n\t\tintel_context_put(ce);\n\t\tif (err)\n\t\t\tbreak;\n\t}\n\n\tlive_mocs_fini(&mocs);\n\treturn err;\n}\n\nstatic int active_engine_reset(struct intel_context *ce,\n\t\t\t       const char *reason,\n\t\t\t       bool using_guc)\n{\n\tstruct igt_spinner spin;\n\tstruct i915_request *rq;\n\tint err;\n\n\terr = igt_spinner_init(&spin, ce->engine->gt);\n\tif (err)\n\t\treturn err;\n\n\trq = igt_spinner_create_request(&spin, ce, MI_NOOP);\n\tif (IS_ERR(rq)) {\n\t\tigt_spinner_fini(&spin);\n\t\treturn PTR_ERR(rq);\n\t}\n\n\terr = request_add_spin(rq, &spin);\n\tif (err == 0 && !using_guc)\n\t\terr = intel_engine_reset(ce->engine, reason);\n\n\t \n\tif (err == 0)\n\t\terr = intel_selftest_wait_for_rq(rq);\n\n\tigt_spinner_end(&spin);\n\tigt_spinner_fini(&spin);\n\n\treturn err;\n}\n\nstatic int __live_mocs_reset(struct live_mocs *mocs,\n\t\t\t     struct intel_context *ce, bool using_guc)\n{\n\tstruct intel_gt *gt = ce->engine->gt;\n\tint err;\n\n\tif (intel_has_reset_engine(gt)) {\n\t\tif (!using_guc) {\n\t\t\terr = intel_engine_reset(ce->engine, \"mocs\");\n\t\t\tif (err)\n\t\t\t\treturn err;\n\n\t\t\terr = check_mocs_engine(mocs, ce);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t}\n\n\t\terr = active_engine_reset(ce, \"mocs\", using_guc);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\terr = check_mocs_engine(mocs, ce);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tif (intel_has_gpu_reset(gt)) {\n\t\tintel_gt_reset(gt, ce->engine->mask, \"mocs\");\n\n\t\terr = check_mocs_engine(mocs, ce);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\nstatic int live_mocs_reset(void *arg)\n{\n\tstruct intel_gt *gt = arg;\n\tstruct intel_engine_cs *engine;\n\tenum intel_engine_id id;\n\tstruct live_mocs mocs;\n\tint err = 0;\n\n\t \n\n\terr = live_mocs_init(&mocs, gt);\n\tif (err)\n\t\treturn err;\n\n\tigt_global_reset_lock(gt);\n\tfor_each_engine(engine, gt, id) {\n\t\tbool using_guc = intel_engine_uses_guc(engine);\n\t\tstruct intel_selftest_saved_policy saved;\n\t\tstruct intel_context *ce;\n\t\tint err2;\n\n\t\terr = intel_selftest_modify_policy(engine, &saved,\n\t\t\t\t\t\t   SELFTEST_SCHEDULER_MODIFY_FAST_RESET);\n\t\tif (err)\n\t\t\tbreak;\n\n\t\tce = mocs_context_create(engine);\n\t\tif (IS_ERR(ce)) {\n\t\t\terr = PTR_ERR(ce);\n\t\t\tgoto restore;\n\t\t}\n\n\t\tintel_engine_pm_get(engine);\n\n\t\terr = __live_mocs_reset(&mocs, ce, using_guc);\n\n\t\tintel_engine_pm_put(engine);\n\t\tintel_context_put(ce);\n\nrestore:\n\t\terr2 = intel_selftest_restore_policy(engine, &saved);\n\t\tif (err == 0)\n\t\t\terr = err2;\n\t\tif (err)\n\t\t\tbreak;\n\t}\n\tigt_global_reset_unlock(gt);\n\n\tlive_mocs_fini(&mocs);\n\treturn err;\n}\n\nint intel_mocs_live_selftests(struct drm_i915_private *i915)\n{\n\tstatic const struct i915_subtest tests[] = {\n\t\tSUBTEST(live_mocs_kernel),\n\t\tSUBTEST(live_mocs_clean),\n\t\tSUBTEST(live_mocs_reset),\n\t};\n\tstruct drm_i915_mocs_table table;\n\n\tif (!get_mocs_settings(i915, &table))\n\t\treturn 0;\n\n\treturn intel_gt_live_subtests(tests, to_gt(i915));\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}