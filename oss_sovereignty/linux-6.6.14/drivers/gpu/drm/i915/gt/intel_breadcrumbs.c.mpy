{
  "module_name": "intel_breadcrumbs.c",
  "hash_id": "e8d44743174cb68d9a5f2312c3135aefba7618a45e0dcd1d4bfbe549aed3bc16",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/i915/gt/intel_breadcrumbs.c",
  "human_readable_source": "\n \n\n#include <linux/kthread.h>\n#include <linux/string_helpers.h>\n#include <trace/events/dma_fence.h>\n#include <uapi/linux/sched/types.h>\n\n#include \"i915_drv.h\"\n#include \"i915_trace.h\"\n#include \"intel_breadcrumbs.h\"\n#include \"intel_context.h\"\n#include \"intel_engine_pm.h\"\n#include \"intel_gt_pm.h\"\n#include \"intel_gt_requests.h\"\n\nstatic bool irq_enable(struct intel_breadcrumbs *b)\n{\n\treturn intel_engine_irq_enable(b->irq_engine);\n}\n\nstatic void irq_disable(struct intel_breadcrumbs *b)\n{\n\tintel_engine_irq_disable(b->irq_engine);\n}\n\nstatic void __intel_breadcrumbs_arm_irq(struct intel_breadcrumbs *b)\n{\n\t \n\tif (GEM_WARN_ON(!intel_gt_pm_get_if_awake(b->irq_engine->gt)))\n\t\treturn;\n\n\t \n\tWRITE_ONCE(b->irq_armed, true);\n\n\t \n\tif (!b->irq_enabled++ && b->irq_enable(b))\n\t\tirq_work_queue(&b->irq_work);\n}\n\nstatic void intel_breadcrumbs_arm_irq(struct intel_breadcrumbs *b)\n{\n\tif (!b->irq_engine)\n\t\treturn;\n\n\tspin_lock(&b->irq_lock);\n\tif (!b->irq_armed)\n\t\t__intel_breadcrumbs_arm_irq(b);\n\tspin_unlock(&b->irq_lock);\n}\n\nstatic void __intel_breadcrumbs_disarm_irq(struct intel_breadcrumbs *b)\n{\n\tGEM_BUG_ON(!b->irq_enabled);\n\tif (!--b->irq_enabled)\n\t\tb->irq_disable(b);\n\n\tWRITE_ONCE(b->irq_armed, false);\n\tintel_gt_pm_put_async(b->irq_engine->gt);\n}\n\nstatic void intel_breadcrumbs_disarm_irq(struct intel_breadcrumbs *b)\n{\n\tspin_lock(&b->irq_lock);\n\tif (b->irq_armed)\n\t\t__intel_breadcrumbs_disarm_irq(b);\n\tspin_unlock(&b->irq_lock);\n}\n\nstatic void add_signaling_context(struct intel_breadcrumbs *b,\n\t\t\t\t  struct intel_context *ce)\n{\n\tlockdep_assert_held(&ce->signal_lock);\n\n\tspin_lock(&b->signalers_lock);\n\tlist_add_rcu(&ce->signal_link, &b->signalers);\n\tspin_unlock(&b->signalers_lock);\n}\n\nstatic bool remove_signaling_context(struct intel_breadcrumbs *b,\n\t\t\t\t     struct intel_context *ce)\n{\n\tlockdep_assert_held(&ce->signal_lock);\n\n\tif (!list_empty(&ce->signals))\n\t\treturn false;\n\n\tspin_lock(&b->signalers_lock);\n\tlist_del_rcu(&ce->signal_link);\n\tspin_unlock(&b->signalers_lock);\n\n\treturn true;\n}\n\n__maybe_unused static bool\ncheck_signal_order(struct intel_context *ce, struct i915_request *rq)\n{\n\tif (rq->context != ce)\n\t\treturn false;\n\n\tif (!list_is_last(&rq->signal_link, &ce->signals) &&\n\t    i915_seqno_passed(rq->fence.seqno,\n\t\t\t      list_next_entry(rq, signal_link)->fence.seqno))\n\t\treturn false;\n\n\tif (!list_is_first(&rq->signal_link, &ce->signals) &&\n\t    i915_seqno_passed(list_prev_entry(rq, signal_link)->fence.seqno,\n\t\t\t      rq->fence.seqno))\n\t\treturn false;\n\n\treturn true;\n}\n\nstatic bool\n__dma_fence_signal(struct dma_fence *fence)\n{\n\treturn !test_and_set_bit(DMA_FENCE_FLAG_SIGNALED_BIT, &fence->flags);\n}\n\nstatic void\n__dma_fence_signal__timestamp(struct dma_fence *fence, ktime_t timestamp)\n{\n\tfence->timestamp = timestamp;\n\tset_bit(DMA_FENCE_FLAG_TIMESTAMP_BIT, &fence->flags);\n\ttrace_dma_fence_signaled(fence);\n}\n\nstatic void\n__dma_fence_signal__notify(struct dma_fence *fence,\n\t\t\t   const struct list_head *list)\n{\n\tstruct dma_fence_cb *cur, *tmp;\n\n\tlockdep_assert_held(fence->lock);\n\n\tlist_for_each_entry_safe(cur, tmp, list, node) {\n\t\tINIT_LIST_HEAD(&cur->node);\n\t\tcur->func(fence, cur);\n\t}\n}\n\nstatic void add_retire(struct intel_breadcrumbs *b, struct intel_timeline *tl)\n{\n\tif (b->irq_engine)\n\t\tintel_engine_add_retire(b->irq_engine, tl);\n}\n\nstatic struct llist_node *\nslist_add(struct llist_node *node, struct llist_node *head)\n{\n\tnode->next = head;\n\treturn node;\n}\n\nstatic void signal_irq_work(struct irq_work *work)\n{\n\tstruct intel_breadcrumbs *b = container_of(work, typeof(*b), irq_work);\n\tconst ktime_t timestamp = ktime_get();\n\tstruct llist_node *signal, *sn;\n\tstruct intel_context *ce;\n\n\tsignal = NULL;\n\tif (unlikely(!llist_empty(&b->signaled_requests)))\n\t\tsignal = llist_del_all(&b->signaled_requests);\n\n\t \n\tif (!signal && READ_ONCE(b->irq_armed) && list_empty(&b->signalers))\n\t\tintel_breadcrumbs_disarm_irq(b);\n\n\trcu_read_lock();\n\tatomic_inc(&b->signaler_active);\n\tlist_for_each_entry_rcu(ce, &b->signalers, signal_link) {\n\t\tstruct i915_request *rq;\n\n\t\tlist_for_each_entry_rcu(rq, &ce->signals, signal_link) {\n\t\t\tbool release;\n\n\t\t\tif (!__i915_request_is_complete(rq))\n\t\t\t\tbreak;\n\n\t\t\tif (!test_and_clear_bit(I915_FENCE_FLAG_SIGNAL,\n\t\t\t\t\t\t&rq->fence.flags))\n\t\t\t\tbreak;\n\n\t\t\t \n\t\t\tspin_lock(&ce->signal_lock);\n\t\t\tlist_del_rcu(&rq->signal_link);\n\t\t\trelease = remove_signaling_context(b, ce);\n\t\t\tspin_unlock(&ce->signal_lock);\n\t\t\tif (release) {\n\t\t\t\tif (intel_timeline_is_last(ce->timeline, rq))\n\t\t\t\t\tadd_retire(b, ce->timeline);\n\t\t\t\tintel_context_put(ce);\n\t\t\t}\n\n\t\t\tif (__dma_fence_signal(&rq->fence))\n\t\t\t\t \n\t\t\t\tsignal = slist_add(&rq->signal_node, signal);\n\t\t\telse\n\t\t\t\ti915_request_put(rq);\n\t\t}\n\t}\n\tatomic_dec(&b->signaler_active);\n\trcu_read_unlock();\n\n\tllist_for_each_safe(signal, sn, signal) {\n\t\tstruct i915_request *rq =\n\t\t\tllist_entry(signal, typeof(*rq), signal_node);\n\t\tstruct list_head cb_list;\n\n\t\tif (rq->engine->sched_engine->retire_inflight_request_prio)\n\t\t\trq->engine->sched_engine->retire_inflight_request_prio(rq);\n\n\t\tspin_lock(&rq->lock);\n\t\tlist_replace(&rq->fence.cb_list, &cb_list);\n\t\t__dma_fence_signal__timestamp(&rq->fence, timestamp);\n\t\t__dma_fence_signal__notify(&rq->fence, &cb_list);\n\t\tspin_unlock(&rq->lock);\n\n\t\ti915_request_put(rq);\n\t}\n\n\tif (!READ_ONCE(b->irq_armed) && !list_empty(&b->signalers))\n\t\tintel_breadcrumbs_arm_irq(b);\n}\n\nstruct intel_breadcrumbs *\nintel_breadcrumbs_create(struct intel_engine_cs *irq_engine)\n{\n\tstruct intel_breadcrumbs *b;\n\n\tb = kzalloc(sizeof(*b), GFP_KERNEL);\n\tif (!b)\n\t\treturn NULL;\n\n\tkref_init(&b->ref);\n\n\tspin_lock_init(&b->signalers_lock);\n\tINIT_LIST_HEAD(&b->signalers);\n\tinit_llist_head(&b->signaled_requests);\n\n\tspin_lock_init(&b->irq_lock);\n\tinit_irq_work(&b->irq_work, signal_irq_work);\n\n\tb->irq_engine = irq_engine;\n\tb->irq_enable = irq_enable;\n\tb->irq_disable = irq_disable;\n\n\treturn b;\n}\n\nvoid intel_breadcrumbs_reset(struct intel_breadcrumbs *b)\n{\n\tunsigned long flags;\n\n\tif (!b->irq_engine)\n\t\treturn;\n\n\tspin_lock_irqsave(&b->irq_lock, flags);\n\n\tif (b->irq_enabled)\n\t\tb->irq_enable(b);\n\telse\n\t\tb->irq_disable(b);\n\n\tspin_unlock_irqrestore(&b->irq_lock, flags);\n}\n\nvoid __intel_breadcrumbs_park(struct intel_breadcrumbs *b)\n{\n\tif (!READ_ONCE(b->irq_armed))\n\t\treturn;\n\n\t \n\tirq_work_sync(&b->irq_work);\n\twhile (READ_ONCE(b->irq_armed) && !atomic_read(&b->active)) {\n\t\tlocal_irq_disable();\n\t\tsignal_irq_work(&b->irq_work);\n\t\tlocal_irq_enable();\n\t\tcond_resched();\n\t}\n}\n\nvoid intel_breadcrumbs_free(struct kref *kref)\n{\n\tstruct intel_breadcrumbs *b = container_of(kref, typeof(*b), ref);\n\n\tirq_work_sync(&b->irq_work);\n\tGEM_BUG_ON(!list_empty(&b->signalers));\n\tGEM_BUG_ON(b->irq_armed);\n\n\tkfree(b);\n}\n\nstatic void irq_signal_request(struct i915_request *rq,\n\t\t\t       struct intel_breadcrumbs *b)\n{\n\tif (!__dma_fence_signal(&rq->fence))\n\t\treturn;\n\n\ti915_request_get(rq);\n\tif (llist_add(&rq->signal_node, &b->signaled_requests))\n\t\tirq_work_queue(&b->irq_work);\n}\n\nstatic void insert_breadcrumb(struct i915_request *rq)\n{\n\tstruct intel_breadcrumbs *b = READ_ONCE(rq->engine)->breadcrumbs;\n\tstruct intel_context *ce = rq->context;\n\tstruct list_head *pos;\n\n\tif (test_bit(I915_FENCE_FLAG_SIGNAL, &rq->fence.flags))\n\t\treturn;\n\n\t \n\tif (__i915_request_is_complete(rq)) {\n\t\tirq_signal_request(rq, b);\n\t\treturn;\n\t}\n\n\tif (list_empty(&ce->signals)) {\n\t\tintel_context_get(ce);\n\t\tadd_signaling_context(b, ce);\n\t\tpos = &ce->signals;\n\t} else {\n\t\t \n\t\tlist_for_each_prev(pos, &ce->signals) {\n\t\t\tstruct i915_request *it =\n\t\t\t\tlist_entry(pos, typeof(*it), signal_link);\n\n\t\t\tif (i915_seqno_passed(rq->fence.seqno, it->fence.seqno))\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\ti915_request_get(rq);\n\tlist_add_rcu(&rq->signal_link, pos);\n\tGEM_BUG_ON(!check_signal_order(ce, rq));\n\tGEM_BUG_ON(test_bit(DMA_FENCE_FLAG_SIGNALED_BIT, &rq->fence.flags));\n\tset_bit(I915_FENCE_FLAG_SIGNAL, &rq->fence.flags);\n\n\t \n\tif (!b->irq_armed || __i915_request_is_complete(rq))\n\t\tirq_work_queue(&b->irq_work);\n}\n\nbool i915_request_enable_breadcrumb(struct i915_request *rq)\n{\n\tstruct intel_context *ce = rq->context;\n\n\t \n\tif (test_bit(DMA_FENCE_FLAG_SIGNALED_BIT, &rq->fence.flags))\n\t\treturn true;\n\n\t \n\tif (!test_bit(I915_FENCE_FLAG_ACTIVE, &rq->fence.flags))\n\t\treturn true;\n\n\tspin_lock(&ce->signal_lock);\n\tif (test_bit(I915_FENCE_FLAG_ACTIVE, &rq->fence.flags))\n\t\tinsert_breadcrumb(rq);\n\tspin_unlock(&ce->signal_lock);\n\n\treturn true;\n}\n\nvoid i915_request_cancel_breadcrumb(struct i915_request *rq)\n{\n\tstruct intel_breadcrumbs *b = READ_ONCE(rq->engine)->breadcrumbs;\n\tstruct intel_context *ce = rq->context;\n\tbool release;\n\n\tspin_lock(&ce->signal_lock);\n\tif (!test_and_clear_bit(I915_FENCE_FLAG_SIGNAL, &rq->fence.flags)) {\n\t\tspin_unlock(&ce->signal_lock);\n\t\treturn;\n\t}\n\n\tlist_del_rcu(&rq->signal_link);\n\trelease = remove_signaling_context(b, ce);\n\tspin_unlock(&ce->signal_lock);\n\tif (release)\n\t\tintel_context_put(ce);\n\n\tif (__i915_request_is_complete(rq))\n\t\tirq_signal_request(rq, b);\n\n\ti915_request_put(rq);\n}\n\nvoid intel_context_remove_breadcrumbs(struct intel_context *ce,\n\t\t\t\t      struct intel_breadcrumbs *b)\n{\n\tstruct i915_request *rq, *rn;\n\tbool release = false;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&ce->signal_lock, flags);\n\n\tif (list_empty(&ce->signals))\n\t\tgoto unlock;\n\n\tlist_for_each_entry_safe(rq, rn, &ce->signals, signal_link) {\n\t\tGEM_BUG_ON(!__i915_request_is_complete(rq));\n\t\tif (!test_and_clear_bit(I915_FENCE_FLAG_SIGNAL,\n\t\t\t\t\t&rq->fence.flags))\n\t\t\tcontinue;\n\n\t\tlist_del_rcu(&rq->signal_link);\n\t\tirq_signal_request(rq, b);\n\t\ti915_request_put(rq);\n\t}\n\trelease = remove_signaling_context(b, ce);\n\nunlock:\n\tspin_unlock_irqrestore(&ce->signal_lock, flags);\n\tif (release)\n\t\tintel_context_put(ce);\n\n\twhile (atomic_read(&b->signaler_active))\n\t\tcpu_relax();\n}\n\nstatic void print_signals(struct intel_breadcrumbs *b, struct drm_printer *p)\n{\n\tstruct intel_context *ce;\n\tstruct i915_request *rq;\n\n\tdrm_printf(p, \"Signals:\\n\");\n\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(ce, &b->signalers, signal_link) {\n\t\tlist_for_each_entry_rcu(rq, &ce->signals, signal_link)\n\t\t\tdrm_printf(p, \"\\t[%llx:%llx%s] @ %dms\\n\",\n\t\t\t\t   rq->fence.context, rq->fence.seqno,\n\t\t\t\t   __i915_request_is_complete(rq) ? \"!\" :\n\t\t\t\t   __i915_request_has_started(rq) ? \"*\" :\n\t\t\t\t   \"\",\n\t\t\t\t   jiffies_to_msecs(jiffies - rq->emitted_jiffies));\n\t}\n\trcu_read_unlock();\n}\n\nvoid intel_engine_print_breadcrumbs(struct intel_engine_cs *engine,\n\t\t\t\t    struct drm_printer *p)\n{\n\tstruct intel_breadcrumbs *b;\n\n\tb = engine->breadcrumbs;\n\tif (!b)\n\t\treturn;\n\n\tdrm_printf(p, \"IRQ: %s\\n\", str_enabled_disabled(b->irq_armed));\n\tif (!list_empty(&b->signalers))\n\t\tprint_signals(b, p);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}