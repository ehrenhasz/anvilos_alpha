{
  "module_name": "intel_tlb.c",
  "hash_id": "862b51a330683353f3855251806e12118b8ae078ee2daf1a11b224620a5047dd",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/i915/gt/intel_tlb.c",
  "human_readable_source": "\n \n\n#include \"i915_drv.h\"\n#include \"i915_perf_oa_regs.h\"\n#include \"intel_engine_pm.h\"\n#include \"intel_gt.h\"\n#include \"intel_gt_mcr.h\"\n#include \"intel_gt_pm.h\"\n#include \"intel_gt_print.h\"\n#include \"intel_gt_regs.h\"\n#include \"intel_tlb.h\"\n\n \n#define TLB_INVAL_TIMEOUT_US 100\n#define TLB_INVAL_TIMEOUT_MS 4\n\n \nstatic int wait_for_invalidate(struct intel_engine_cs *engine)\n{\n\tif (engine->tlb_inv.mcr)\n\t\treturn intel_gt_mcr_wait_for_reg(engine->gt,\n\t\t\t\t\t\t engine->tlb_inv.reg.mcr_reg,\n\t\t\t\t\t\t engine->tlb_inv.done,\n\t\t\t\t\t\t 0,\n\t\t\t\t\t\t TLB_INVAL_TIMEOUT_US,\n\t\t\t\t\t\t TLB_INVAL_TIMEOUT_MS);\n\telse\n\t\treturn __intel_wait_for_register_fw(engine->gt->uncore,\n\t\t\t\t\t\t    engine->tlb_inv.reg.reg,\n\t\t\t\t\t\t    engine->tlb_inv.done,\n\t\t\t\t\t\t    0,\n\t\t\t\t\t\t    TLB_INVAL_TIMEOUT_US,\n\t\t\t\t\t\t    TLB_INVAL_TIMEOUT_MS,\n\t\t\t\t\t\t    NULL);\n}\n\nstatic void mmio_invalidate_full(struct intel_gt *gt)\n{\n\tstruct drm_i915_private *i915 = gt->i915;\n\tstruct intel_uncore *uncore = gt->uncore;\n\tstruct intel_engine_cs *engine;\n\tintel_engine_mask_t awake, tmp;\n\tenum intel_engine_id id;\n\tunsigned long flags;\n\n\tif (GRAPHICS_VER(i915) < 8)\n\t\treturn;\n\n\tintel_uncore_forcewake_get(uncore, FORCEWAKE_ALL);\n\n\tintel_gt_mcr_lock(gt, &flags);\n\tspin_lock(&uncore->lock);  \n\n\tawake = 0;\n\tfor_each_engine(engine, gt, id) {\n\t\tif (!intel_engine_pm_is_awake(engine))\n\t\t\tcontinue;\n\n\t\tif (engine->tlb_inv.mcr)\n\t\t\tintel_gt_mcr_multicast_write_fw(gt,\n\t\t\t\t\t\t\tengine->tlb_inv.reg.mcr_reg,\n\t\t\t\t\t\t\tengine->tlb_inv.request);\n\t\telse\n\t\t\tintel_uncore_write_fw(uncore,\n\t\t\t\t\t      engine->tlb_inv.reg.reg,\n\t\t\t\t\t      engine->tlb_inv.request);\n\n\t\tawake |= engine->mask;\n\t}\n\n\tGT_TRACE(gt, \"invalidated engines %08x\\n\", awake);\n\n\t \n\tif (awake &&\n\t    (IS_TIGERLAKE(i915) ||\n\t     IS_DG1(i915) ||\n\t     IS_ROCKETLAKE(i915) ||\n\t     IS_ALDERLAKE_S(i915) ||\n\t     IS_ALDERLAKE_P(i915)))\n\t\tintel_uncore_write_fw(uncore, GEN12_OA_TLB_INV_CR, 1);\n\n\tspin_unlock(&uncore->lock);\n\tintel_gt_mcr_unlock(gt, flags);\n\n\tfor_each_engine_masked(engine, gt, awake, tmp) {\n\t\tif (wait_for_invalidate(engine))\n\t\t\tgt_err_ratelimited(gt,\n\t\t\t\t\t   \"%s TLB invalidation did not complete in %ums!\\n\",\n\t\t\t\t\t   engine->name, TLB_INVAL_TIMEOUT_MS);\n\t}\n\n\t \n\tintel_uncore_forcewake_put_delayed(uncore, FORCEWAKE_ALL);\n}\n\nstatic bool tlb_seqno_passed(const struct intel_gt *gt, u32 seqno)\n{\n\tu32 cur = intel_gt_tlb_seqno(gt);\n\n\t \n\treturn (s32)(cur - ALIGN(seqno, 2)) > 0;\n}\n\nvoid intel_gt_invalidate_tlb_full(struct intel_gt *gt, u32 seqno)\n{\n\tintel_wakeref_t wakeref;\n\n\tif (I915_SELFTEST_ONLY(gt->awake == -ENODEV))\n\t\treturn;\n\n\tif (intel_gt_is_wedged(gt))\n\t\treturn;\n\n\tif (tlb_seqno_passed(gt, seqno))\n\t\treturn;\n\n\twith_intel_gt_pm_if_awake(gt, wakeref) {\n\t\tmutex_lock(&gt->tlb.invalidate_lock);\n\t\tif (tlb_seqno_passed(gt, seqno))\n\t\t\tgoto unlock;\n\n\t\tmmio_invalidate_full(gt);\n\n\t\twrite_seqcount_invalidate(&gt->tlb.seqno);\nunlock:\n\t\tmutex_unlock(&gt->tlb.invalidate_lock);\n\t}\n}\n\nvoid intel_gt_init_tlb(struct intel_gt *gt)\n{\n\tmutex_init(&gt->tlb.invalidate_lock);\n\tseqcount_mutex_init(&gt->tlb.seqno, &gt->tlb.invalidate_lock);\n}\n\nvoid intel_gt_fini_tlb(struct intel_gt *gt)\n{\n\tmutex_destroy(&gt->tlb.invalidate_lock);\n}\n\n#if IS_ENABLED(CONFIG_DRM_I915_SELFTEST)\n#include \"selftest_tlb.c\"\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}