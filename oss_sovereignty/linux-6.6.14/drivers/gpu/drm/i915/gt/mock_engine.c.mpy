{
  "module_name": "mock_engine.c",
  "hash_id": "2b8d3059084881ad7c11bf5d9a57f6cc23224adc6e6d0cd48e0b4b6a761cff6b",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/i915/gt/mock_engine.c",
  "human_readable_source": "\n \n\n#include \"gem/i915_gem_context.h\"\n#include \"gt/intel_ring.h\"\n\n#include \"i915_drv.h\"\n#include \"intel_context.h\"\n#include \"intel_engine_pm.h\"\n\n#include \"mock_engine.h\"\n#include \"selftests/mock_request.h\"\n\nstatic int mock_timeline_pin(struct intel_timeline *tl)\n{\n\tint err;\n\n\tif (WARN_ON(!i915_gem_object_trylock(tl->hwsp_ggtt->obj, NULL)))\n\t\treturn -EBUSY;\n\n\terr = intel_timeline_pin_map(tl);\n\ti915_gem_object_unlock(tl->hwsp_ggtt->obj);\n\tif (err)\n\t\treturn err;\n\n\tatomic_inc(&tl->pin_count);\n\treturn 0;\n}\n\nstatic void mock_timeline_unpin(struct intel_timeline *tl)\n{\n\tGEM_BUG_ON(!atomic_read(&tl->pin_count));\n\tatomic_dec(&tl->pin_count);\n}\n\nstatic struct i915_vma *create_ring_vma(struct i915_ggtt *ggtt, int size)\n{\n\tstruct i915_address_space *vm = &ggtt->vm;\n\tstruct drm_i915_private *i915 = vm->i915;\n\tstruct drm_i915_gem_object *obj;\n\tstruct i915_vma *vma;\n\n\tobj = i915_gem_object_create_internal(i915, size);\n\tif (IS_ERR(obj))\n\t\treturn ERR_CAST(obj);\n\n\tvma = i915_vma_instance(obj, vm, NULL);\n\tif (IS_ERR(vma))\n\t\tgoto err;\n\n\treturn vma;\n\nerr:\n\ti915_gem_object_put(obj);\n\treturn vma;\n}\n\nstatic struct intel_ring *mock_ring(struct intel_engine_cs *engine)\n{\n\tconst unsigned long sz = PAGE_SIZE;\n\tstruct intel_ring *ring;\n\n\tring = kzalloc(sizeof(*ring) + sz, GFP_KERNEL);\n\tif (!ring)\n\t\treturn NULL;\n\n\tkref_init(&ring->ref);\n\tring->size = sz;\n\tring->effective_size = sz;\n\tring->vaddr = (void *)(ring + 1);\n\tatomic_set(&ring->pin_count, 1);\n\n\tring->vma = create_ring_vma(engine->gt->ggtt, PAGE_SIZE);\n\tif (IS_ERR(ring->vma)) {\n\t\tkfree(ring);\n\t\treturn NULL;\n\t}\n\n\tintel_ring_update_space(ring);\n\n\treturn ring;\n}\n\nstatic void mock_ring_free(struct intel_ring *ring)\n{\n\ti915_vma_put(ring->vma);\n\n\tkfree(ring);\n}\n\nstatic struct i915_request *first_request(struct mock_engine *engine)\n{\n\treturn list_first_entry_or_null(&engine->hw_queue,\n\t\t\t\t\tstruct i915_request,\n\t\t\t\t\tmock.link);\n}\n\nstatic void advance(struct i915_request *request)\n{\n\tlist_del_init(&request->mock.link);\n\ti915_request_mark_complete(request);\n\tGEM_BUG_ON(!i915_request_completed(request));\n\n\tintel_engine_signal_breadcrumbs(request->engine);\n}\n\nstatic void hw_delay_complete(struct timer_list *t)\n{\n\tstruct mock_engine *engine = from_timer(engine, t, hw_delay);\n\tstruct i915_request *request;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&engine->hw_lock, flags);\n\n\t \n\trequest = first_request(engine);\n\tif (request)\n\t\tadvance(request);\n\n\t \n\twhile ((request = first_request(engine))) {\n\t\tif (request->mock.delay) {\n\t\t\tmod_timer(&engine->hw_delay,\n\t\t\t\t  jiffies + request->mock.delay);\n\t\t\tbreak;\n\t\t}\n\n\t\tadvance(request);\n\t}\n\n\tspin_unlock_irqrestore(&engine->hw_lock, flags);\n}\n\nstatic void mock_context_unpin(struct intel_context *ce)\n{\n}\n\nstatic void mock_context_post_unpin(struct intel_context *ce)\n{\n\ti915_vma_unpin(ce->ring->vma);\n}\n\nstatic void mock_context_destroy(struct kref *ref)\n{\n\tstruct intel_context *ce = container_of(ref, typeof(*ce), ref);\n\n\tGEM_BUG_ON(intel_context_is_pinned(ce));\n\n\tif (test_bit(CONTEXT_ALLOC_BIT, &ce->flags)) {\n\t\tmock_ring_free(ce->ring);\n\t\tmock_timeline_unpin(ce->timeline);\n\t}\n\n\tintel_context_fini(ce);\n\tintel_context_free(ce);\n}\n\nstatic int mock_context_alloc(struct intel_context *ce)\n{\n\tint err;\n\n\tce->ring = mock_ring(ce->engine);\n\tif (!ce->ring)\n\t\treturn -ENOMEM;\n\n\tce->timeline = intel_timeline_create(ce->engine->gt);\n\tif (IS_ERR(ce->timeline)) {\n\t\tkfree(ce->engine);\n\t\treturn PTR_ERR(ce->timeline);\n\t}\n\n\terr = mock_timeline_pin(ce->timeline);\n\tif (err) {\n\t\tintel_timeline_put(ce->timeline);\n\t\tce->timeline = NULL;\n\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\nstatic int mock_context_pre_pin(struct intel_context *ce,\n\t\t\t\tstruct i915_gem_ww_ctx *ww, void **unused)\n{\n\treturn i915_vma_pin_ww(ce->ring->vma, ww, 0, 0, PIN_GLOBAL | PIN_HIGH);\n}\n\nstatic int mock_context_pin(struct intel_context *ce, void *unused)\n{\n\treturn 0;\n}\n\nstatic void mock_context_reset(struct intel_context *ce)\n{\n}\n\nstatic const struct intel_context_ops mock_context_ops = {\n\t.alloc = mock_context_alloc,\n\n\t.pre_pin = mock_context_pre_pin,\n\t.pin = mock_context_pin,\n\t.unpin = mock_context_unpin,\n\t.post_unpin = mock_context_post_unpin,\n\n\t.enter = intel_context_enter_engine,\n\t.exit = intel_context_exit_engine,\n\n\t.reset = mock_context_reset,\n\t.destroy = mock_context_destroy,\n};\n\nstatic int mock_request_alloc(struct i915_request *request)\n{\n\tINIT_LIST_HEAD(&request->mock.link);\n\trequest->mock.delay = 0;\n\n\treturn 0;\n}\n\nstatic int mock_emit_flush(struct i915_request *request,\n\t\t\t   unsigned int flags)\n{\n\treturn 0;\n}\n\nstatic u32 *mock_emit_breadcrumb(struct i915_request *request, u32 *cs)\n{\n\treturn cs;\n}\n\nstatic void mock_submit_request(struct i915_request *request)\n{\n\tstruct mock_engine *engine =\n\t\tcontainer_of(request->engine, typeof(*engine), base);\n\tunsigned long flags;\n\n\ti915_request_submit(request);\n\n\tspin_lock_irqsave(&engine->hw_lock, flags);\n\tlist_add_tail(&request->mock.link, &engine->hw_queue);\n\tif (list_is_first(&request->mock.link, &engine->hw_queue)) {\n\t\tif (request->mock.delay)\n\t\t\tmod_timer(&engine->hw_delay,\n\t\t\t\t  jiffies + request->mock.delay);\n\t\telse\n\t\t\tadvance(request);\n\t}\n\tspin_unlock_irqrestore(&engine->hw_lock, flags);\n}\n\nstatic void mock_add_to_engine(struct i915_request *rq)\n{\n\tlockdep_assert_held(&rq->engine->sched_engine->lock);\n\tlist_move_tail(&rq->sched.link, &rq->engine->sched_engine->requests);\n}\n\nstatic void mock_remove_from_engine(struct i915_request *rq)\n{\n\tstruct intel_engine_cs *engine, *locked;\n\n\t \n\n\tlocked = READ_ONCE(rq->engine);\n\tspin_lock_irq(&locked->sched_engine->lock);\n\twhile (unlikely(locked != (engine = READ_ONCE(rq->engine)))) {\n\t\tspin_unlock(&locked->sched_engine->lock);\n\t\tspin_lock(&engine->sched_engine->lock);\n\t\tlocked = engine;\n\t}\n\tlist_del_init(&rq->sched.link);\n\tspin_unlock_irq(&locked->sched_engine->lock);\n}\n\nstatic void mock_reset_prepare(struct intel_engine_cs *engine)\n{\n}\n\nstatic void mock_reset_rewind(struct intel_engine_cs *engine, bool stalled)\n{\n\tGEM_BUG_ON(stalled);\n}\n\nstatic void mock_reset_cancel(struct intel_engine_cs *engine)\n{\n\tstruct mock_engine *mock =\n\t\tcontainer_of(engine, typeof(*mock), base);\n\tstruct i915_request *rq;\n\tunsigned long flags;\n\n\tdel_timer_sync(&mock->hw_delay);\n\n\tspin_lock_irqsave(&engine->sched_engine->lock, flags);\n\n\t \n\tlist_for_each_entry(rq, &engine->sched_engine->requests, sched.link)\n\t\ti915_request_put(i915_request_mark_eio(rq));\n\tintel_engine_signal_breadcrumbs(engine);\n\n\t \n\tlist_for_each_entry(rq, &mock->hw_queue, mock.link) {\n\t\tif (i915_request_mark_eio(rq)) {\n\t\t\t__i915_request_submit(rq);\n\t\t\ti915_request_put(rq);\n\t\t}\n\t}\n\tINIT_LIST_HEAD(&mock->hw_queue);\n\n\tspin_unlock_irqrestore(&engine->sched_engine->lock, flags);\n}\n\nstatic void mock_reset_finish(struct intel_engine_cs *engine)\n{\n}\n\nstatic void mock_engine_release(struct intel_engine_cs *engine)\n{\n\tstruct mock_engine *mock =\n\t\tcontainer_of(engine, typeof(*mock), base);\n\n\tGEM_BUG_ON(timer_pending(&mock->hw_delay));\n\n\ti915_sched_engine_put(engine->sched_engine);\n\tintel_breadcrumbs_put(engine->breadcrumbs);\n\n\tintel_context_unpin(engine->kernel_context);\n\tintel_context_put(engine->kernel_context);\n\n\tintel_engine_fini_retire(engine);\n}\n\nstruct intel_engine_cs *mock_engine(struct drm_i915_private *i915,\n\t\t\t\t    const char *name,\n\t\t\t\t    int id)\n{\n\tstruct mock_engine *engine;\n\n\tGEM_BUG_ON(id >= I915_NUM_ENGINES);\n\tGEM_BUG_ON(!to_gt(i915)->uncore);\n\n\tengine = kzalloc(sizeof(*engine) + PAGE_SIZE, GFP_KERNEL);\n\tif (!engine)\n\t\treturn NULL;\n\n\t \n\tengine->base.i915 = i915;\n\tengine->base.gt = to_gt(i915);\n\tengine->base.uncore = to_gt(i915)->uncore;\n\tsnprintf(engine->base.name, sizeof(engine->base.name), \"%s\", name);\n\tengine->base.id = id;\n\tengine->base.mask = BIT(id);\n\tengine->base.legacy_idx = INVALID_ENGINE;\n\tengine->base.instance = id;\n\tengine->base.status_page.addr = (void *)(engine + 1);\n\n\tengine->base.cops = &mock_context_ops;\n\tengine->base.request_alloc = mock_request_alloc;\n\tengine->base.emit_flush = mock_emit_flush;\n\tengine->base.emit_fini_breadcrumb = mock_emit_breadcrumb;\n\tengine->base.submit_request = mock_submit_request;\n\tengine->base.add_active_request = mock_add_to_engine;\n\tengine->base.remove_active_request = mock_remove_from_engine;\n\n\tengine->base.reset.prepare = mock_reset_prepare;\n\tengine->base.reset.rewind = mock_reset_rewind;\n\tengine->base.reset.cancel = mock_reset_cancel;\n\tengine->base.reset.finish = mock_reset_finish;\n\n\tengine->base.release = mock_engine_release;\n\n\tto_gt(i915)->engine[id] = &engine->base;\n\tto_gt(i915)->engine_class[0][id] = &engine->base;\n\n\t \n\tspin_lock_init(&engine->hw_lock);\n\ttimer_setup(&engine->hw_delay, hw_delay_complete, 0);\n\tINIT_LIST_HEAD(&engine->hw_queue);\n\n\tintel_engine_add_user(&engine->base);\n\n\treturn &engine->base;\n}\n\nint mock_engine_init(struct intel_engine_cs *engine)\n{\n\tstruct intel_context *ce;\n\n\tINIT_LIST_HEAD(&engine->pinned_contexts_list);\n\n\tengine->sched_engine = i915_sched_engine_create(ENGINE_MOCK);\n\tif (!engine->sched_engine)\n\t\treturn -ENOMEM;\n\tengine->sched_engine->private_data = engine;\n\n\tintel_engine_init_execlists(engine);\n\tintel_engine_init__pm(engine);\n\tintel_engine_init_retire(engine);\n\n\tengine->breadcrumbs = intel_breadcrumbs_create(NULL);\n\tif (!engine->breadcrumbs)\n\t\tgoto err_schedule;\n\n\tce = create_kernel_context(engine);\n\tif (IS_ERR(ce))\n\t\tgoto err_breadcrumbs;\n\n\t \n\tengine->status_page.vma = ce->timeline->hwsp_ggtt;\n\n\tengine->kernel_context = ce;\n\treturn 0;\n\nerr_breadcrumbs:\n\tintel_breadcrumbs_put(engine->breadcrumbs);\nerr_schedule:\n\ti915_sched_engine_put(engine->sched_engine);\n\treturn -ENOMEM;\n}\n\nvoid mock_engine_flush(struct intel_engine_cs *engine)\n{\n\tstruct mock_engine *mock =\n\t\tcontainer_of(engine, typeof(*mock), base);\n\tstruct i915_request *request, *rn;\n\n\tdel_timer_sync(&mock->hw_delay);\n\n\tspin_lock_irq(&mock->hw_lock);\n\tlist_for_each_entry_safe(request, rn, &mock->hw_queue, mock.link)\n\t\tadvance(request);\n\tspin_unlock_irq(&mock->hw_lock);\n}\n\nvoid mock_engine_reset(struct intel_engine_cs *engine)\n{\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}