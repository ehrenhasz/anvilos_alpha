{
  "module_name": "intel_sseu.c",
  "hash_id": "41add94d7c6bd4eb6cf6554d6ee6d4a915aa7bec04575dc536a169ab0bde5412",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/i915/gt/intel_sseu.c",
  "human_readable_source": "\n \n\n#include <linux/string_helpers.h>\n\n#include \"i915_drv.h\"\n#include \"i915_perf_types.h\"\n#include \"intel_engine_regs.h\"\n#include \"intel_gt_regs.h\"\n#include \"intel_sseu.h\"\n\nvoid intel_sseu_set_info(struct sseu_dev_info *sseu, u8 max_slices,\n\t\t\t u8 max_subslices, u8 max_eus_per_subslice)\n{\n\tsseu->max_slices = max_slices;\n\tsseu->max_subslices = max_subslices;\n\tsseu->max_eus_per_subslice = max_eus_per_subslice;\n}\n\nunsigned int\nintel_sseu_subslice_total(const struct sseu_dev_info *sseu)\n{\n\tunsigned int i, total = 0;\n\n\tif (sseu->has_xehp_dss)\n\t\treturn bitmap_weight(sseu->subslice_mask.xehp,\n\t\t\t\t     XEHP_BITMAP_BITS(sseu->subslice_mask));\n\n\tfor (i = 0; i < ARRAY_SIZE(sseu->subslice_mask.hsw); i++)\n\t\ttotal += hweight8(sseu->subslice_mask.hsw[i]);\n\n\treturn total;\n}\n\nunsigned int\nintel_sseu_get_hsw_subslices(const struct sseu_dev_info *sseu, u8 slice)\n{\n\tWARN_ON(sseu->has_xehp_dss);\n\tif (WARN_ON(slice >= sseu->max_slices))\n\t\treturn 0;\n\n\treturn sseu->subslice_mask.hsw[slice];\n}\n\nstatic u16 sseu_get_eus(const struct sseu_dev_info *sseu, int slice,\n\t\t\tint subslice)\n{\n\tif (sseu->has_xehp_dss) {\n\t\tWARN_ON(slice > 0);\n\t\treturn sseu->eu_mask.xehp[subslice];\n\t} else {\n\t\treturn sseu->eu_mask.hsw[slice][subslice];\n\t}\n}\n\nstatic void sseu_set_eus(struct sseu_dev_info *sseu, int slice, int subslice,\n\t\t\t u16 eu_mask)\n{\n\tGEM_WARN_ON(eu_mask && __fls(eu_mask) >= sseu->max_eus_per_subslice);\n\tif (sseu->has_xehp_dss) {\n\t\tGEM_WARN_ON(slice > 0);\n\t\tsseu->eu_mask.xehp[subslice] = eu_mask;\n\t} else {\n\t\tsseu->eu_mask.hsw[slice][subslice] = eu_mask;\n\t}\n}\n\nstatic u16 compute_eu_total(const struct sseu_dev_info *sseu)\n{\n\tint s, ss, total = 0;\n\n\tfor (s = 0; s < sseu->max_slices; s++)\n\t\tfor (ss = 0; ss < sseu->max_subslices; ss++)\n\t\t\tif (sseu->has_xehp_dss)\n\t\t\t\ttotal += hweight16(sseu->eu_mask.xehp[ss]);\n\t\t\telse\n\t\t\t\ttotal += hweight16(sseu->eu_mask.hsw[s][ss]);\n\n\treturn total;\n}\n\n \nint intel_sseu_copy_eumask_to_user(void __user *to,\n\t\t\t\t   const struct sseu_dev_info *sseu)\n{\n\tu8 eu_mask[GEN_SS_MASK_SIZE * GEN_MAX_EU_STRIDE] = {};\n\tint eu_stride = GEN_SSEU_STRIDE(sseu->max_eus_per_subslice);\n\tint len = sseu->max_slices * sseu->max_subslices * eu_stride;\n\tint s, ss, i;\n\n\tfor (s = 0; s < sseu->max_slices; s++) {\n\t\tfor (ss = 0; ss < sseu->max_subslices; ss++) {\n\t\t\tint uapi_offset =\n\t\t\t\ts * sseu->max_subslices * eu_stride +\n\t\t\t\tss * eu_stride;\n\t\t\tu16 mask = sseu_get_eus(sseu, s, ss);\n\n\t\t\tfor (i = 0; i < eu_stride; i++)\n\t\t\t\teu_mask[uapi_offset + i] =\n\t\t\t\t\t(mask >> (BITS_PER_BYTE * i)) & 0xff;\n\t\t}\n\t}\n\n\treturn copy_to_user(to, eu_mask, len);\n}\n\n \nint intel_sseu_copy_ssmask_to_user(void __user *to,\n\t\t\t\t   const struct sseu_dev_info *sseu)\n{\n\tu8 ss_mask[GEN_SS_MASK_SIZE] = {};\n\tint ss_stride = GEN_SSEU_STRIDE(sseu->max_subslices);\n\tint len = sseu->max_slices * ss_stride;\n\tint s, ss, i;\n\n\tfor (s = 0; s < sseu->max_slices; s++) {\n\t\tfor (ss = 0; ss < sseu->max_subslices; ss++) {\n\t\t\ti = s * ss_stride * BITS_PER_BYTE + ss;\n\n\t\t\tif (!intel_sseu_has_subslice(sseu, s, ss))\n\t\t\t\tcontinue;\n\n\t\t\tss_mask[i / BITS_PER_BYTE] |= BIT(i % BITS_PER_BYTE);\n\t\t}\n\t}\n\n\treturn copy_to_user(to, ss_mask, len);\n}\n\nstatic void gen11_compute_sseu_info(struct sseu_dev_info *sseu,\n\t\t\t\t    u32 ss_en, u16 eu_en)\n{\n\tu32 valid_ss_mask = GENMASK(sseu->max_subslices - 1, 0);\n\tint ss;\n\n\tsseu->slice_mask |= BIT(0);\n\tsseu->subslice_mask.hsw[0] = ss_en & valid_ss_mask;\n\n\tfor (ss = 0; ss < sseu->max_subslices; ss++)\n\t\tif (intel_sseu_has_subslice(sseu, 0, ss))\n\t\t\tsseu_set_eus(sseu, 0, ss, eu_en);\n\n\tsseu->eu_per_subslice = hweight16(eu_en);\n\tsseu->eu_total = compute_eu_total(sseu);\n}\n\nstatic void xehp_compute_sseu_info(struct sseu_dev_info *sseu,\n\t\t\t\t   u16 eu_en)\n{\n\tint ss;\n\n\tsseu->slice_mask |= BIT(0);\n\n\tbitmap_or(sseu->subslice_mask.xehp,\n\t\t  sseu->compute_subslice_mask.xehp,\n\t\t  sseu->geometry_subslice_mask.xehp,\n\t\t  XEHP_BITMAP_BITS(sseu->subslice_mask));\n\n\tfor (ss = 0; ss < sseu->max_subslices; ss++)\n\t\tif (intel_sseu_has_subslice(sseu, 0, ss))\n\t\t\tsseu_set_eus(sseu, 0, ss, eu_en);\n\n\tsseu->eu_per_subslice = hweight16(eu_en);\n\tsseu->eu_total = compute_eu_total(sseu);\n}\n\nstatic void\nxehp_load_dss_mask(struct intel_uncore *uncore,\n\t\t   intel_sseu_ss_mask_t *ssmask,\n\t\t   int numregs,\n\t\t   ...)\n{\n\tva_list argp;\n\tu32 fuse_val[I915_MAX_SS_FUSE_REGS] = {};\n\tint i;\n\n\tif (WARN_ON(numregs > I915_MAX_SS_FUSE_REGS))\n\t\tnumregs = I915_MAX_SS_FUSE_REGS;\n\n\tva_start(argp, numregs);\n\tfor (i = 0; i < numregs; i++)\n\t\tfuse_val[i] = intel_uncore_read(uncore, va_arg(argp, i915_reg_t));\n\tva_end(argp);\n\n\tbitmap_from_arr32(ssmask->xehp, fuse_val, numregs * 32);\n}\n\nstatic void xehp_sseu_info_init(struct intel_gt *gt)\n{\n\tstruct sseu_dev_info *sseu = &gt->info.sseu;\n\tstruct intel_uncore *uncore = gt->uncore;\n\tu16 eu_en = 0;\n\tu8 eu_en_fuse;\n\tint num_compute_regs, num_geometry_regs;\n\tint eu;\n\n\tif (IS_PONTEVECCHIO(gt->i915)) {\n\t\tnum_geometry_regs = 0;\n\t\tnum_compute_regs = 2;\n\t} else {\n\t\tnum_geometry_regs = 1;\n\t\tnum_compute_regs = 1;\n\t}\n\n\t \n\tintel_sseu_set_info(sseu, 1,\n\t\t\t    32 * max(num_geometry_regs, num_compute_regs),\n\t\t\t    HAS_ONE_EU_PER_FUSE_BIT(gt->i915) ? 8 : 16);\n\tsseu->has_xehp_dss = 1;\n\n\txehp_load_dss_mask(uncore, &sseu->geometry_subslice_mask,\n\t\t\t   num_geometry_regs,\n\t\t\t   GEN12_GT_GEOMETRY_DSS_ENABLE);\n\txehp_load_dss_mask(uncore, &sseu->compute_subslice_mask,\n\t\t\t   num_compute_regs,\n\t\t\t   GEN12_GT_COMPUTE_DSS_ENABLE,\n\t\t\t   XEHPC_GT_COMPUTE_DSS_ENABLE_EXT);\n\n\teu_en_fuse = intel_uncore_read(uncore, XEHP_EU_ENABLE) & XEHP_EU_ENA_MASK;\n\n\tif (HAS_ONE_EU_PER_FUSE_BIT(gt->i915))\n\t\teu_en = eu_en_fuse;\n\telse\n\t\tfor (eu = 0; eu < sseu->max_eus_per_subslice / 2; eu++)\n\t\t\tif (eu_en_fuse & BIT(eu))\n\t\t\t\teu_en |= BIT(eu * 2) | BIT(eu * 2 + 1);\n\n\txehp_compute_sseu_info(sseu, eu_en);\n}\n\nstatic void gen12_sseu_info_init(struct intel_gt *gt)\n{\n\tstruct sseu_dev_info *sseu = &gt->info.sseu;\n\tstruct intel_uncore *uncore = gt->uncore;\n\tu32 g_dss_en;\n\tu16 eu_en = 0;\n\tu8 eu_en_fuse;\n\tu8 s_en;\n\tint eu;\n\n\t \n\tintel_sseu_set_info(sseu, 1, 6, 16);\n\n\t \n\ts_en = intel_uncore_read(uncore, GEN11_GT_SLICE_ENABLE) &\n\t\tGEN11_GT_S_ENA_MASK;\n\tdrm_WARN_ON(&gt->i915->drm, s_en != 0x1);\n\n\tg_dss_en = intel_uncore_read(uncore, GEN12_GT_GEOMETRY_DSS_ENABLE);\n\n\t \n\teu_en_fuse = ~(intel_uncore_read(uncore, GEN11_EU_DISABLE) &\n\t\t       GEN11_EU_DIS_MASK);\n\n\tfor (eu = 0; eu < sseu->max_eus_per_subslice / 2; eu++)\n\t\tif (eu_en_fuse & BIT(eu))\n\t\t\teu_en |= BIT(eu * 2) | BIT(eu * 2 + 1);\n\n\tgen11_compute_sseu_info(sseu, g_dss_en, eu_en);\n\n\t \n\tsseu->has_slice_pg = 1;\n}\n\nstatic void gen11_sseu_info_init(struct intel_gt *gt)\n{\n\tstruct sseu_dev_info *sseu = &gt->info.sseu;\n\tstruct intel_uncore *uncore = gt->uncore;\n\tu32 ss_en;\n\tu8 eu_en;\n\tu8 s_en;\n\n\tif (IS_JASPERLAKE(gt->i915) || IS_ELKHARTLAKE(gt->i915))\n\t\tintel_sseu_set_info(sseu, 1, 4, 8);\n\telse\n\t\tintel_sseu_set_info(sseu, 1, 8, 8);\n\n\t \n\ts_en = intel_uncore_read(uncore, GEN11_GT_SLICE_ENABLE) &\n\t\tGEN11_GT_S_ENA_MASK;\n\tdrm_WARN_ON(&gt->i915->drm, s_en != 0x1);\n\n\tss_en = ~intel_uncore_read(uncore, GEN11_GT_SUBSLICE_DISABLE);\n\n\teu_en = ~(intel_uncore_read(uncore, GEN11_EU_DISABLE) &\n\t\t  GEN11_EU_DIS_MASK);\n\n\tgen11_compute_sseu_info(sseu, ss_en, eu_en);\n\n\t \n\tsseu->has_slice_pg = 1;\n\tsseu->has_subslice_pg = 1;\n\tsseu->has_eu_pg = 1;\n}\n\nstatic void cherryview_sseu_info_init(struct intel_gt *gt)\n{\n\tstruct sseu_dev_info *sseu = &gt->info.sseu;\n\tu32 fuse;\n\n\tfuse = intel_uncore_read(gt->uncore, CHV_FUSE_GT);\n\n\tsseu->slice_mask = BIT(0);\n\tintel_sseu_set_info(sseu, 1, 2, 8);\n\n\tif (!(fuse & CHV_FGT_DISABLE_SS0)) {\n\t\tu8 disabled_mask =\n\t\t\t((fuse & CHV_FGT_EU_DIS_SS0_R0_MASK) >>\n\t\t\t CHV_FGT_EU_DIS_SS0_R0_SHIFT) |\n\t\t\t(((fuse & CHV_FGT_EU_DIS_SS0_R1_MASK) >>\n\t\t\t  CHV_FGT_EU_DIS_SS0_R1_SHIFT) << 4);\n\n\t\tsseu->subslice_mask.hsw[0] |= BIT(0);\n\t\tsseu_set_eus(sseu, 0, 0, ~disabled_mask & 0xFF);\n\t}\n\n\tif (!(fuse & CHV_FGT_DISABLE_SS1)) {\n\t\tu8 disabled_mask =\n\t\t\t((fuse & CHV_FGT_EU_DIS_SS1_R0_MASK) >>\n\t\t\t CHV_FGT_EU_DIS_SS1_R0_SHIFT) |\n\t\t\t(((fuse & CHV_FGT_EU_DIS_SS1_R1_MASK) >>\n\t\t\t  CHV_FGT_EU_DIS_SS1_R1_SHIFT) << 4);\n\n\t\tsseu->subslice_mask.hsw[0] |= BIT(1);\n\t\tsseu_set_eus(sseu, 0, 1, ~disabled_mask & 0xFF);\n\t}\n\n\tsseu->eu_total = compute_eu_total(sseu);\n\n\t \n\tsseu->eu_per_subslice = intel_sseu_subslice_total(sseu) ?\n\t\tsseu->eu_total /\n\t\tintel_sseu_subslice_total(sseu) :\n\t\t0;\n\t \n\tsseu->has_slice_pg = 0;\n\tsseu->has_subslice_pg = intel_sseu_subslice_total(sseu) > 1;\n\tsseu->has_eu_pg = (sseu->eu_per_subslice > 2);\n}\n\nstatic void gen9_sseu_info_init(struct intel_gt *gt)\n{\n\tstruct drm_i915_private *i915 = gt->i915;\n\tstruct sseu_dev_info *sseu = &gt->info.sseu;\n\tstruct intel_uncore *uncore = gt->uncore;\n\tu32 fuse2, eu_disable, subslice_mask;\n\tconst u8 eu_mask = 0xff;\n\tint s, ss;\n\n\tfuse2 = intel_uncore_read(uncore, GEN8_FUSE2);\n\tsseu->slice_mask = (fuse2 & GEN8_F2_S_ENA_MASK) >> GEN8_F2_S_ENA_SHIFT;\n\n\t \n\tintel_sseu_set_info(sseu, IS_GEN9_LP(i915) ? 1 : 3,\n\t\t\t    IS_GEN9_LP(i915) ? 3 : 4, 8);\n\n\t \n\tsubslice_mask = (1 << sseu->max_subslices) - 1;\n\tsubslice_mask &= ~((fuse2 & GEN9_F2_SS_DIS_MASK) >>\n\t\t\t   GEN9_F2_SS_DIS_SHIFT);\n\n\t \n\tfor (s = 0; s < sseu->max_slices; s++) {\n\t\tif (!(sseu->slice_mask & BIT(s)))\n\t\t\t \n\t\t\tcontinue;\n\n\t\tsseu->subslice_mask.hsw[s] = subslice_mask;\n\n\t\teu_disable = intel_uncore_read(uncore, GEN9_EU_DISABLE(s));\n\t\tfor (ss = 0; ss < sseu->max_subslices; ss++) {\n\t\t\tint eu_per_ss;\n\t\t\tu8 eu_disabled_mask;\n\n\t\t\tif (!intel_sseu_has_subslice(sseu, s, ss))\n\t\t\t\t \n\t\t\t\tcontinue;\n\n\t\t\teu_disabled_mask = (eu_disable >> (ss * 8)) & eu_mask;\n\n\t\t\tsseu_set_eus(sseu, s, ss, ~eu_disabled_mask & eu_mask);\n\n\t\t\teu_per_ss = sseu->max_eus_per_subslice -\n\t\t\t\thweight8(eu_disabled_mask);\n\n\t\t\t \n\t\t\tif (eu_per_ss == 7)\n\t\t\t\tsseu->subslice_7eu[s] |= BIT(ss);\n\t\t}\n\t}\n\n\tsseu->eu_total = compute_eu_total(sseu);\n\n\t \n\tsseu->eu_per_subslice =\n\t\tintel_sseu_subslice_total(sseu) ?\n\t\tDIV_ROUND_UP(sseu->eu_total, intel_sseu_subslice_total(sseu)) :\n\t\t0;\n\n\t \n\tsseu->has_slice_pg =\n\t\t!IS_GEN9_LP(i915) && hweight8(sseu->slice_mask) > 1;\n\tsseu->has_subslice_pg =\n\t\tIS_GEN9_LP(i915) && intel_sseu_subslice_total(sseu) > 1;\n\tsseu->has_eu_pg = sseu->eu_per_subslice > 2;\n\n\tif (IS_GEN9_LP(i915)) {\n#define IS_SS_DISABLED(ss)\t(!(sseu->subslice_mask.hsw[0] & BIT(ss)))\n\t\tRUNTIME_INFO(i915)->has_pooled_eu = hweight8(sseu->subslice_mask.hsw[0]) == 3;\n\n\t\tsseu->min_eu_in_pool = 0;\n\t\tif (HAS_POOLED_EU(i915)) {\n\t\t\tif (IS_SS_DISABLED(2) || IS_SS_DISABLED(0))\n\t\t\t\tsseu->min_eu_in_pool = 3;\n\t\t\telse if (IS_SS_DISABLED(1))\n\t\t\t\tsseu->min_eu_in_pool = 6;\n\t\t\telse\n\t\t\t\tsseu->min_eu_in_pool = 9;\n\t\t}\n#undef IS_SS_DISABLED\n\t}\n}\n\nstatic void bdw_sseu_info_init(struct intel_gt *gt)\n{\n\tstruct sseu_dev_info *sseu = &gt->info.sseu;\n\tstruct intel_uncore *uncore = gt->uncore;\n\tint s, ss;\n\tu32 fuse2, subslice_mask, eu_disable[3];  \n\tu32 eu_disable0, eu_disable1, eu_disable2;\n\n\tfuse2 = intel_uncore_read(uncore, GEN8_FUSE2);\n\tsseu->slice_mask = (fuse2 & GEN8_F2_S_ENA_MASK) >> GEN8_F2_S_ENA_SHIFT;\n\tintel_sseu_set_info(sseu, 3, 3, 8);\n\n\t \n\tsubslice_mask = GENMASK(sseu->max_subslices - 1, 0);\n\tsubslice_mask &= ~((fuse2 & GEN8_F2_SS_DIS_MASK) >>\n\t\t\t   GEN8_F2_SS_DIS_SHIFT);\n\teu_disable0 = intel_uncore_read(uncore, GEN8_EU_DISABLE0);\n\teu_disable1 = intel_uncore_read(uncore, GEN8_EU_DISABLE1);\n\teu_disable2 = intel_uncore_read(uncore, GEN8_EU_DISABLE2);\n\teu_disable[0] = eu_disable0 & GEN8_EU_DIS0_S0_MASK;\n\teu_disable[1] = (eu_disable0 >> GEN8_EU_DIS0_S1_SHIFT) |\n\t\t((eu_disable1 & GEN8_EU_DIS1_S1_MASK) <<\n\t\t (32 - GEN8_EU_DIS0_S1_SHIFT));\n\teu_disable[2] = (eu_disable1 >> GEN8_EU_DIS1_S2_SHIFT) |\n\t\t((eu_disable2 & GEN8_EU_DIS2_S2_MASK) <<\n\t\t (32 - GEN8_EU_DIS1_S2_SHIFT));\n\n\t \n\tfor (s = 0; s < sseu->max_slices; s++) {\n\t\tif (!(sseu->slice_mask & BIT(s)))\n\t\t\t \n\t\t\tcontinue;\n\n\t\tsseu->subslice_mask.hsw[s] = subslice_mask;\n\n\t\tfor (ss = 0; ss < sseu->max_subslices; ss++) {\n\t\t\tu8 eu_disabled_mask;\n\t\t\tu32 n_disabled;\n\n\t\t\tif (!intel_sseu_has_subslice(sseu, s, ss))\n\t\t\t\t \n\t\t\t\tcontinue;\n\n\t\t\teu_disabled_mask =\n\t\t\t\teu_disable[s] >> (ss * sseu->max_eus_per_subslice);\n\n\t\t\tsseu_set_eus(sseu, s, ss, ~eu_disabled_mask & 0xFF);\n\n\t\t\tn_disabled = hweight8(eu_disabled_mask);\n\n\t\t\t \n\t\t\tif (sseu->max_eus_per_subslice - n_disabled == 7)\n\t\t\t\tsseu->subslice_7eu[s] |= 1 << ss;\n\t\t}\n\t}\n\n\tsseu->eu_total = compute_eu_total(sseu);\n\n\t \n\tsseu->eu_per_subslice =\n\t\tintel_sseu_subslice_total(sseu) ?\n\t\tDIV_ROUND_UP(sseu->eu_total, intel_sseu_subslice_total(sseu)) :\n\t\t0;\n\n\t \n\tsseu->has_slice_pg = hweight8(sseu->slice_mask) > 1;\n\tsseu->has_subslice_pg = 0;\n\tsseu->has_eu_pg = 0;\n}\n\nstatic void hsw_sseu_info_init(struct intel_gt *gt)\n{\n\tstruct drm_i915_private *i915 = gt->i915;\n\tstruct sseu_dev_info *sseu = &gt->info.sseu;\n\tu32 fuse1;\n\tu8 subslice_mask = 0;\n\tint s, ss;\n\n\t \n\tswitch (INTEL_INFO(i915)->gt) {\n\tdefault:\n\t\tMISSING_CASE(INTEL_INFO(i915)->gt);\n\t\tfallthrough;\n\tcase 1:\n\t\tsseu->slice_mask = BIT(0);\n\t\tsubslice_mask = BIT(0);\n\t\tbreak;\n\tcase 2:\n\t\tsseu->slice_mask = BIT(0);\n\t\tsubslice_mask = BIT(0) | BIT(1);\n\t\tbreak;\n\tcase 3:\n\t\tsseu->slice_mask = BIT(0) | BIT(1);\n\t\tsubslice_mask = BIT(0) | BIT(1);\n\t\tbreak;\n\t}\n\n\tfuse1 = intel_uncore_read(gt->uncore, HSW_PAVP_FUSE1);\n\tswitch (REG_FIELD_GET(HSW_F1_EU_DIS_MASK, fuse1)) {\n\tdefault:\n\t\tMISSING_CASE(REG_FIELD_GET(HSW_F1_EU_DIS_MASK, fuse1));\n\t\tfallthrough;\n\tcase HSW_F1_EU_DIS_10EUS:\n\t\tsseu->eu_per_subslice = 10;\n\t\tbreak;\n\tcase HSW_F1_EU_DIS_8EUS:\n\t\tsseu->eu_per_subslice = 8;\n\t\tbreak;\n\tcase HSW_F1_EU_DIS_6EUS:\n\t\tsseu->eu_per_subslice = 6;\n\t\tbreak;\n\t}\n\n\tintel_sseu_set_info(sseu, hweight8(sseu->slice_mask),\n\t\t\t    hweight8(subslice_mask),\n\t\t\t    sseu->eu_per_subslice);\n\n\tfor (s = 0; s < sseu->max_slices; s++) {\n\t\tsseu->subslice_mask.hsw[s] = subslice_mask;\n\n\t\tfor (ss = 0; ss < sseu->max_subslices; ss++) {\n\t\t\tsseu_set_eus(sseu, s, ss,\n\t\t\t\t     (1UL << sseu->eu_per_subslice) - 1);\n\t\t}\n\t}\n\n\tsseu->eu_total = compute_eu_total(sseu);\n\n\t \n\tsseu->has_slice_pg = 0;\n\tsseu->has_subslice_pg = 0;\n\tsseu->has_eu_pg = 0;\n}\n\nvoid intel_sseu_info_init(struct intel_gt *gt)\n{\n\tstruct drm_i915_private *i915 = gt->i915;\n\n\tif (GRAPHICS_VER_FULL(i915) >= IP_VER(12, 50))\n\t\txehp_sseu_info_init(gt);\n\telse if (GRAPHICS_VER(i915) >= 12)\n\t\tgen12_sseu_info_init(gt);\n\telse if (GRAPHICS_VER(i915) >= 11)\n\t\tgen11_sseu_info_init(gt);\n\telse if (GRAPHICS_VER(i915) >= 9)\n\t\tgen9_sseu_info_init(gt);\n\telse if (IS_BROADWELL(i915))\n\t\tbdw_sseu_info_init(gt);\n\telse if (IS_CHERRYVIEW(i915))\n\t\tcherryview_sseu_info_init(gt);\n\telse if (IS_HASWELL(i915))\n\t\thsw_sseu_info_init(gt);\n}\n\nu32 intel_sseu_make_rpcs(struct intel_gt *gt,\n\t\t\t const struct intel_sseu *req_sseu)\n{\n\tstruct drm_i915_private *i915 = gt->i915;\n\tconst struct sseu_dev_info *sseu = &gt->info.sseu;\n\tbool subslice_pg = sseu->has_subslice_pg;\n\tu8 slices, subslices;\n\tu32 rpcs = 0;\n\n\t \n\tif (GRAPHICS_VER(i915) < 9)\n\t\treturn 0;\n\n\t \n\tif (gt->perf.group && gt->perf.group[PERF_GROUP_OAG].exclusive_stream)\n\t\treq_sseu = &gt->perf.sseu;\n\n\tslices = hweight8(req_sseu->slice_mask);\n\tsubslices = hweight8(req_sseu->subslice_mask);\n\n\t \n\tif (GRAPHICS_VER(i915) == 11 &&\n\t    slices == 1 &&\n\t    subslices > min_t(u8, 4, hweight8(sseu->subslice_mask.hsw[0]) / 2)) {\n\t\tGEM_BUG_ON(subslices & 1);\n\n\t\tsubslice_pg = false;\n\t\tslices *= 2;\n\t}\n\n\t \n\tif (sseu->has_slice_pg) {\n\t\tu32 mask, val = slices;\n\n\t\tif (GRAPHICS_VER(i915) >= 11) {\n\t\t\tmask = GEN11_RPCS_S_CNT_MASK;\n\t\t\tval <<= GEN11_RPCS_S_CNT_SHIFT;\n\t\t} else {\n\t\t\tmask = GEN8_RPCS_S_CNT_MASK;\n\t\t\tval <<= GEN8_RPCS_S_CNT_SHIFT;\n\t\t}\n\n\t\tGEM_BUG_ON(val & ~mask);\n\t\tval &= mask;\n\n\t\trpcs |= GEN8_RPCS_ENABLE | GEN8_RPCS_S_CNT_ENABLE | val;\n\t}\n\n\tif (subslice_pg) {\n\t\tu32 val = subslices;\n\n\t\tval <<= GEN8_RPCS_SS_CNT_SHIFT;\n\n\t\tGEM_BUG_ON(val & ~GEN8_RPCS_SS_CNT_MASK);\n\t\tval &= GEN8_RPCS_SS_CNT_MASK;\n\n\t\trpcs |= GEN8_RPCS_ENABLE | GEN8_RPCS_SS_CNT_ENABLE | val;\n\t}\n\n\tif (sseu->has_eu_pg) {\n\t\tu32 val;\n\n\t\tval = req_sseu->min_eus_per_subslice << GEN8_RPCS_EU_MIN_SHIFT;\n\t\tGEM_BUG_ON(val & ~GEN8_RPCS_EU_MIN_MASK);\n\t\tval &= GEN8_RPCS_EU_MIN_MASK;\n\n\t\trpcs |= val;\n\n\t\tval = req_sseu->max_eus_per_subslice << GEN8_RPCS_EU_MAX_SHIFT;\n\t\tGEM_BUG_ON(val & ~GEN8_RPCS_EU_MAX_MASK);\n\t\tval &= GEN8_RPCS_EU_MAX_MASK;\n\n\t\trpcs |= val;\n\n\t\trpcs |= GEN8_RPCS_ENABLE;\n\t}\n\n\treturn rpcs;\n}\n\nvoid intel_sseu_dump(const struct sseu_dev_info *sseu, struct drm_printer *p)\n{\n\tint s;\n\n\tif (sseu->has_xehp_dss) {\n\t\tdrm_printf(p, \"subslice total: %u\\n\",\n\t\t\t   intel_sseu_subslice_total(sseu));\n\t\tdrm_printf(p, \"geometry dss mask=%*pb\\n\",\n\t\t\t   XEHP_BITMAP_BITS(sseu->geometry_subslice_mask),\n\t\t\t   sseu->geometry_subslice_mask.xehp);\n\t\tdrm_printf(p, \"compute dss mask=%*pb\\n\",\n\t\t\t   XEHP_BITMAP_BITS(sseu->compute_subslice_mask),\n\t\t\t   sseu->compute_subslice_mask.xehp);\n\t} else {\n\t\tdrm_printf(p, \"slice total: %u, mask=%04x\\n\",\n\t\t\t   hweight8(sseu->slice_mask), sseu->slice_mask);\n\t\tdrm_printf(p, \"subslice total: %u\\n\",\n\t\t\t   intel_sseu_subslice_total(sseu));\n\n\t\tfor (s = 0; s < sseu->max_slices; s++) {\n\t\t\tu8 ss_mask = sseu->subslice_mask.hsw[s];\n\n\t\t\tdrm_printf(p, \"slice%d: %u subslices, mask=%08x\\n\",\n\t\t\t\t   s, hweight8(ss_mask), ss_mask);\n\t\t}\n\t}\n\n\tdrm_printf(p, \"EU total: %u\\n\", sseu->eu_total);\n\tdrm_printf(p, \"EU per subslice: %u\\n\", sseu->eu_per_subslice);\n\tdrm_printf(p, \"has slice power gating: %s\\n\",\n\t\t   str_yes_no(sseu->has_slice_pg));\n\tdrm_printf(p, \"has subslice power gating: %s\\n\",\n\t\t   str_yes_no(sseu->has_subslice_pg));\n\tdrm_printf(p, \"has EU power gating: %s\\n\",\n\t\t   str_yes_no(sseu->has_eu_pg));\n}\n\nstatic void sseu_print_hsw_topology(const struct sseu_dev_info *sseu,\n\t\t\t\t    struct drm_printer *p)\n{\n\tint s, ss;\n\n\tfor (s = 0; s < sseu->max_slices; s++) {\n\t\tu8 ss_mask = sseu->subslice_mask.hsw[s];\n\n\t\tdrm_printf(p, \"slice%d: %u subslice(s) (0x%08x):\\n\",\n\t\t\t   s, hweight8(ss_mask), ss_mask);\n\n\t\tfor (ss = 0; ss < sseu->max_subslices; ss++) {\n\t\t\tu16 enabled_eus = sseu_get_eus(sseu, s, ss);\n\n\t\t\tdrm_printf(p, \"\\tsubslice%d: %u EUs (0x%hx)\\n\",\n\t\t\t\t   ss, hweight16(enabled_eus), enabled_eus);\n\t\t}\n\t}\n}\n\nstatic void sseu_print_xehp_topology(const struct sseu_dev_info *sseu,\n\t\t\t\t     struct drm_printer *p)\n{\n\tint dss;\n\n\tfor (dss = 0; dss < sseu->max_subslices; dss++) {\n\t\tu16 enabled_eus = sseu_get_eus(sseu, 0, dss);\n\n\t\tdrm_printf(p, \"DSS_%02d: G:%3s C:%3s, %2u EUs (0x%04hx)\\n\", dss,\n\t\t\t   str_yes_no(test_bit(dss, sseu->geometry_subslice_mask.xehp)),\n\t\t\t   str_yes_no(test_bit(dss, sseu->compute_subslice_mask.xehp)),\n\t\t\t   hweight16(enabled_eus), enabled_eus);\n\t}\n}\n\nvoid intel_sseu_print_topology(struct drm_i915_private *i915,\n\t\t\t       const struct sseu_dev_info *sseu,\n\t\t\t       struct drm_printer *p)\n{\n\tif (sseu->max_slices == 0) {\n\t\tdrm_printf(p, \"Unavailable\\n\");\n\t} else if (GRAPHICS_VER_FULL(i915) >= IP_VER(12, 50)) {\n\t\tsseu_print_xehp_topology(sseu, p);\n\t} else {\n\t\tsseu_print_hsw_topology(sseu, p);\n\t}\n}\n\nvoid intel_sseu_print_ss_info(const char *type,\n\t\t\t      const struct sseu_dev_info *sseu,\n\t\t\t      struct seq_file *m)\n{\n\tint s;\n\n\tif (sseu->has_xehp_dss) {\n\t\tseq_printf(m, \"  %s Geometry DSS: %u\\n\", type,\n\t\t\t   bitmap_weight(sseu->geometry_subslice_mask.xehp,\n\t\t\t\t\t XEHP_BITMAP_BITS(sseu->geometry_subslice_mask)));\n\t\tseq_printf(m, \"  %s Compute DSS: %u\\n\", type,\n\t\t\t   bitmap_weight(sseu->compute_subslice_mask.xehp,\n\t\t\t\t\t XEHP_BITMAP_BITS(sseu->compute_subslice_mask)));\n\t} else {\n\t\tfor (s = 0; s < fls(sseu->slice_mask); s++)\n\t\t\tseq_printf(m, \"  %s Slice%i subslices: %u\\n\", type,\n\t\t\t\t   s, hweight8(sseu->subslice_mask.hsw[s]));\n\t}\n}\n\nu16 intel_slicemask_from_xehp_dssmask(intel_sseu_ss_mask_t dss_mask,\n\t\t\t\t      int dss_per_slice)\n{\n\tintel_sseu_ss_mask_t per_slice_mask = {};\n\tunsigned long slice_mask = 0;\n\tint i;\n\n\tWARN_ON(DIV_ROUND_UP(XEHP_BITMAP_BITS(dss_mask), dss_per_slice) >\n\t\t8 * sizeof(slice_mask));\n\n\tbitmap_fill(per_slice_mask.xehp, dss_per_slice);\n\tfor (i = 0; !bitmap_empty(dss_mask.xehp, XEHP_BITMAP_BITS(dss_mask)); i++) {\n\t\tif (bitmap_intersects(dss_mask.xehp, per_slice_mask.xehp, dss_per_slice))\n\t\t\tslice_mask |= BIT(i);\n\n\t\tbitmap_shift_right(dss_mask.xehp, dss_mask.xehp, dss_per_slice,\n\t\t\t\t   XEHP_BITMAP_BITS(dss_mask));\n\t}\n\n\treturn slice_mask;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}