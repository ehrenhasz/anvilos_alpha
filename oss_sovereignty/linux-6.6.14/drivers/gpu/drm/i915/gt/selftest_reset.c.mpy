{
  "module_name": "selftest_reset.c",
  "hash_id": "701754d1ac369d629624946a99ca4d0deed7fdc04661fa311dd9ba578d099085",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/i915/gt/selftest_reset.c",
  "human_readable_source": "\n \n\n#include <linux/crc32.h>\n\n#include \"gem/i915_gem_stolen.h\"\n\n#include \"i915_memcpy.h\"\n#include \"i915_selftest.h\"\n#include \"intel_gpu_commands.h\"\n#include \"selftests/igt_reset.h\"\n#include \"selftests/igt_atomic.h\"\n#include \"selftests/igt_spinner.h\"\n\nstatic int\n__igt_reset_stolen(struct intel_gt *gt,\n\t\t   intel_engine_mask_t mask,\n\t\t   const char *msg)\n{\n\tstruct i915_ggtt *ggtt = gt->ggtt;\n\tconst struct resource *dsm = &gt->i915->dsm.stolen;\n\tresource_size_t num_pages, page;\n\tstruct intel_engine_cs *engine;\n\tintel_wakeref_t wakeref;\n\tenum intel_engine_id id;\n\tstruct igt_spinner spin;\n\tlong max, count;\n\tvoid *tmp;\n\tu32 *crc;\n\tint err;\n\n\tif (!drm_mm_node_allocated(&ggtt->error_capture))\n\t\treturn 0;\n\n\tnum_pages = resource_size(dsm) >> PAGE_SHIFT;\n\tif (!num_pages)\n\t\treturn 0;\n\n\tcrc = kmalloc_array(num_pages, sizeof(u32), GFP_KERNEL);\n\tif (!crc)\n\t\treturn -ENOMEM;\n\n\ttmp = kmalloc(PAGE_SIZE, GFP_KERNEL);\n\tif (!tmp) {\n\t\terr = -ENOMEM;\n\t\tgoto err_crc;\n\t}\n\n\tigt_global_reset_lock(gt);\n\twakeref = intel_runtime_pm_get(gt->uncore->rpm);\n\n\terr = igt_spinner_init(&spin, gt);\n\tif (err)\n\t\tgoto err_lock;\n\n\tfor_each_engine(engine, gt, id) {\n\t\tstruct intel_context *ce;\n\t\tstruct i915_request *rq;\n\n\t\tif (!(mask & engine->mask))\n\t\t\tcontinue;\n\n\t\tif (!intel_engine_can_store_dword(engine))\n\t\t\tcontinue;\n\n\t\tce = intel_context_create(engine);\n\t\tif (IS_ERR(ce)) {\n\t\t\terr = PTR_ERR(ce);\n\t\t\tgoto err_spin;\n\t\t}\n\t\trq = igt_spinner_create_request(&spin, ce, MI_ARB_CHECK);\n\t\tintel_context_put(ce);\n\t\tif (IS_ERR(rq)) {\n\t\t\terr = PTR_ERR(rq);\n\t\t\tgoto err_spin;\n\t\t}\n\t\ti915_request_add(rq);\n\t}\n\n\tfor (page = 0; page < num_pages; page++) {\n\t\tdma_addr_t dma = (dma_addr_t)dsm->start + (page << PAGE_SHIFT);\n\t\tvoid __iomem *s;\n\t\tvoid *in;\n\n\t\tggtt->vm.insert_page(&ggtt->vm, dma,\n\t\t\t\t     ggtt->error_capture.start,\n\t\t\t\t     i915_gem_get_pat_index(gt->i915,\n\t\t\t\t\t\t\t    I915_CACHE_NONE),\n\t\t\t\t     0);\n\t\tmb();\n\n\t\ts = io_mapping_map_wc(&ggtt->iomap,\n\t\t\t\t      ggtt->error_capture.start,\n\t\t\t\t      PAGE_SIZE);\n\n\t\tif (!__drm_mm_interval_first(&gt->i915->mm.stolen,\n\t\t\t\t\t     page << PAGE_SHIFT,\n\t\t\t\t\t     ((page + 1) << PAGE_SHIFT) - 1))\n\t\t\tmemset_io(s, STACK_MAGIC, PAGE_SIZE);\n\n\t\tin = (void __force *)s;\n\t\tif (i915_memcpy_from_wc(tmp, in, PAGE_SIZE))\n\t\t\tin = tmp;\n\t\tcrc[page] = crc32_le(0, in, PAGE_SIZE);\n\n\t\tio_mapping_unmap(s);\n\t}\n\tmb();\n\tggtt->vm.clear_range(&ggtt->vm, ggtt->error_capture.start, PAGE_SIZE);\n\n\tif (mask == ALL_ENGINES) {\n\t\tintel_gt_reset(gt, mask, NULL);\n\t} else {\n\t\tfor_each_engine(engine, gt, id) {\n\t\t\tif (mask & engine->mask)\n\t\t\t\tintel_engine_reset(engine, NULL);\n\t\t}\n\t}\n\n\tmax = -1;\n\tcount = 0;\n\tfor (page = 0; page < num_pages; page++) {\n\t\tdma_addr_t dma = (dma_addr_t)dsm->start + (page << PAGE_SHIFT);\n\t\tvoid __iomem *s;\n\t\tvoid *in;\n\t\tu32 x;\n\n\t\tggtt->vm.insert_page(&ggtt->vm, dma,\n\t\t\t\t     ggtt->error_capture.start,\n\t\t\t\t     i915_gem_get_pat_index(gt->i915,\n\t\t\t\t\t\t\t    I915_CACHE_NONE),\n\t\t\t\t     0);\n\t\tmb();\n\n\t\ts = io_mapping_map_wc(&ggtt->iomap,\n\t\t\t\t      ggtt->error_capture.start,\n\t\t\t\t      PAGE_SIZE);\n\n\t\tin = (void __force *)s;\n\t\tif (i915_memcpy_from_wc(tmp, in, PAGE_SIZE))\n\t\t\tin = tmp;\n\t\tx = crc32_le(0, in, PAGE_SIZE);\n\n\t\tif (x != crc[page] &&\n\t\t    !__drm_mm_interval_first(&gt->i915->mm.stolen,\n\t\t\t\t\t     page << PAGE_SHIFT,\n\t\t\t\t\t     ((page + 1) << PAGE_SHIFT) - 1)) {\n\t\t\tpr_debug(\"unused stolen page %pa modified by GPU reset\\n\",\n\t\t\t\t &page);\n\t\t\tif (count++ == 0)\n\t\t\t\tigt_hexdump(in, PAGE_SIZE);\n\t\t\tmax = page;\n\t\t}\n\n\t\tio_mapping_unmap(s);\n\t}\n\tmb();\n\tggtt->vm.clear_range(&ggtt->vm, ggtt->error_capture.start, PAGE_SIZE);\n\n\tif (count > 0) {\n\t\tpr_info(\"%s reset clobbered %ld pages of stolen, last clobber at page %ld\\n\",\n\t\t\tmsg, count, max);\n\t}\n\tif (max >= I915_GEM_STOLEN_BIAS >> PAGE_SHIFT) {\n\t\tpr_err(\"%s reset clobbered unreserved area [above %x] of stolen; may cause severe faults\\n\",\n\t\t       msg, I915_GEM_STOLEN_BIAS);\n\t\terr = -EINVAL;\n\t}\n\nerr_spin:\n\tigt_spinner_fini(&spin);\n\nerr_lock:\n\tintel_runtime_pm_put(gt->uncore->rpm, wakeref);\n\tigt_global_reset_unlock(gt);\n\n\tkfree(tmp);\nerr_crc:\n\tkfree(crc);\n\treturn err;\n}\n\nstatic int igt_reset_device_stolen(void *arg)\n{\n\treturn __igt_reset_stolen(arg, ALL_ENGINES, \"device\");\n}\n\nstatic int igt_reset_engines_stolen(void *arg)\n{\n\tstruct intel_gt *gt = arg;\n\tstruct intel_engine_cs *engine;\n\tenum intel_engine_id id;\n\tint err;\n\n\tif (!intel_has_reset_engine(gt))\n\t\treturn 0;\n\n\tfor_each_engine(engine, gt, id) {\n\t\terr = __igt_reset_stolen(gt, engine->mask, engine->name);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\nstatic int igt_global_reset(void *arg)\n{\n\tstruct intel_gt *gt = arg;\n\tunsigned int reset_count;\n\tintel_wakeref_t wakeref;\n\tint err = 0;\n\n\t \n\n\tigt_global_reset_lock(gt);\n\twakeref = intel_runtime_pm_get(gt->uncore->rpm);\n\n\treset_count = i915_reset_count(&gt->i915->gpu_error);\n\n\tintel_gt_reset(gt, ALL_ENGINES, NULL);\n\n\tif (i915_reset_count(&gt->i915->gpu_error) == reset_count) {\n\t\tpr_err(\"No GPU reset recorded!\\n\");\n\t\terr = -EINVAL;\n\t}\n\n\tintel_runtime_pm_put(gt->uncore->rpm, wakeref);\n\tigt_global_reset_unlock(gt);\n\n\tif (intel_gt_is_wedged(gt))\n\t\terr = -EIO;\n\n\treturn err;\n}\n\nstatic int igt_wedged_reset(void *arg)\n{\n\tstruct intel_gt *gt = arg;\n\tintel_wakeref_t wakeref;\n\n\t \n\n\tigt_global_reset_lock(gt);\n\twakeref = intel_runtime_pm_get(gt->uncore->rpm);\n\n\tintel_gt_set_wedged(gt);\n\n\tGEM_BUG_ON(!intel_gt_is_wedged(gt));\n\tintel_gt_reset(gt, ALL_ENGINES, NULL);\n\n\tintel_runtime_pm_put(gt->uncore->rpm, wakeref);\n\tigt_global_reset_unlock(gt);\n\n\treturn intel_gt_is_wedged(gt) ? -EIO : 0;\n}\n\nstatic int igt_atomic_reset(void *arg)\n{\n\tstruct intel_gt *gt = arg;\n\tconst typeof(*igt_atomic_phases) *p;\n\tint err = 0;\n\n\t \n\n\tintel_gt_pm_get(gt);\n\tigt_global_reset_lock(gt);\n\n\t \n\tif (!igt_force_reset(gt))\n\t\tgoto unlock;\n\n\tfor (p = igt_atomic_phases; p->name; p++) {\n\t\tintel_engine_mask_t awake;\n\n\t\tGEM_TRACE(\"__intel_gt_reset under %s\\n\", p->name);\n\n\t\tawake = reset_prepare(gt);\n\t\tp->critical_section_begin();\n\n\t\terr = __intel_gt_reset(gt, ALL_ENGINES);\n\n\t\tp->critical_section_end();\n\t\treset_finish(gt, awake);\n\n\t\tif (err) {\n\t\t\tpr_err(\"__intel_gt_reset failed under %s\\n\", p->name);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t \n\tigt_force_reset(gt);\n\nunlock:\n\tigt_global_reset_unlock(gt);\n\tintel_gt_pm_put(gt);\n\n\treturn err;\n}\n\nstatic int igt_atomic_engine_reset(void *arg)\n{\n\tstruct intel_gt *gt = arg;\n\tconst typeof(*igt_atomic_phases) *p;\n\tstruct intel_engine_cs *engine;\n\tenum intel_engine_id id;\n\tint err = 0;\n\n\t \n\n\tif (!intel_has_reset_engine(gt))\n\t\treturn 0;\n\n\tif (intel_uc_uses_guc_submission(&gt->uc))\n\t\treturn 0;\n\n\tintel_gt_pm_get(gt);\n\tigt_global_reset_lock(gt);\n\n\t \n\tif (!igt_force_reset(gt))\n\t\tgoto out_unlock;\n\n\tfor_each_engine(engine, gt, id) {\n\t\tstruct tasklet_struct *t = &engine->sched_engine->tasklet;\n\n\t\tif (t->func)\n\t\t\ttasklet_disable(t);\n\t\tintel_engine_pm_get(engine);\n\n\t\tfor (p = igt_atomic_phases; p->name; p++) {\n\t\t\tGEM_TRACE(\"intel_engine_reset(%s) under %s\\n\",\n\t\t\t\t  engine->name, p->name);\n\t\t\tif (strcmp(p->name, \"softirq\"))\n\t\t\t\tlocal_bh_disable();\n\n\t\t\tp->critical_section_begin();\n\t\t\terr = __intel_engine_reset_bh(engine, NULL);\n\t\t\tp->critical_section_end();\n\n\t\t\tif (strcmp(p->name, \"softirq\"))\n\t\t\t\tlocal_bh_enable();\n\n\t\t\tif (err) {\n\t\t\t\tpr_err(\"intel_engine_reset(%s) failed under %s\\n\",\n\t\t\t\t       engine->name, p->name);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tintel_engine_pm_put(engine);\n\t\tif (t->func) {\n\t\t\ttasklet_enable(t);\n\t\t\ttasklet_hi_schedule(t);\n\t\t}\n\t\tif (err)\n\t\t\tbreak;\n\t}\n\n\t \n\tigt_force_reset(gt);\n\nout_unlock:\n\tigt_global_reset_unlock(gt);\n\tintel_gt_pm_put(gt);\n\n\treturn err;\n}\n\nint intel_reset_live_selftests(struct drm_i915_private *i915)\n{\n\tstatic const struct i915_subtest tests[] = {\n\t\tSUBTEST(igt_global_reset),  \n\t\tSUBTEST(igt_reset_device_stolen),\n\t\tSUBTEST(igt_reset_engines_stolen),\n\t\tSUBTEST(igt_wedged_reset),\n\t\tSUBTEST(igt_atomic_reset),\n\t\tSUBTEST(igt_atomic_engine_reset),\n\t};\n\tstruct intel_gt *gt = to_gt(i915);\n\n\tif (!intel_has_gpu_reset(gt))\n\t\treturn 0;\n\n\tif (intel_gt_is_wedged(gt))\n\t\treturn -EIO;  \n\n\treturn intel_gt_live_subtests(tests, gt);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}