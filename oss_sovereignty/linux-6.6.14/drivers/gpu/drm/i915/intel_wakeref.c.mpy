{
  "module_name": "intel_wakeref.c",
  "hash_id": "94188acb3698f784d85fb47176c8a9daada44a86a5f00b654b482985aafb9f90",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/i915/intel_wakeref.c",
  "human_readable_source": " \n\n#include <linux/wait_bit.h>\n\n#include \"intel_runtime_pm.h\"\n#include \"intel_wakeref.h\"\n#include \"i915_drv.h\"\n\nstatic void rpm_get(struct intel_wakeref *wf)\n{\n\twf->wakeref = intel_runtime_pm_get(&wf->i915->runtime_pm);\n}\n\nstatic void rpm_put(struct intel_wakeref *wf)\n{\n\tintel_wakeref_t wakeref = fetch_and_zero(&wf->wakeref);\n\n\tintel_runtime_pm_put(&wf->i915->runtime_pm, wakeref);\n\tINTEL_WAKEREF_BUG_ON(!wakeref);\n}\n\nint __intel_wakeref_get_first(struct intel_wakeref *wf)\n{\n\t \n\tmutex_lock_nested(&wf->mutex, SINGLE_DEPTH_NESTING);\n\tif (!atomic_read(&wf->count)) {\n\t\tint err;\n\n\t\trpm_get(wf);\n\n\t\terr = wf->ops->get(wf);\n\t\tif (unlikely(err)) {\n\t\t\trpm_put(wf);\n\t\t\tmutex_unlock(&wf->mutex);\n\t\t\treturn err;\n\t\t}\n\n\t\tsmp_mb__before_atomic();  \n\t}\n\tatomic_inc(&wf->count);\n\tmutex_unlock(&wf->mutex);\n\n\tINTEL_WAKEREF_BUG_ON(atomic_read(&wf->count) <= 0);\n\treturn 0;\n}\n\nstatic void ____intel_wakeref_put_last(struct intel_wakeref *wf)\n{\n\tINTEL_WAKEREF_BUG_ON(atomic_read(&wf->count) <= 0);\n\tif (unlikely(!atomic_dec_and_test(&wf->count)))\n\t\tgoto unlock;\n\n\t \n\tif (likely(!wf->ops->put(wf))) {\n\t\trpm_put(wf);\n\t\twake_up_var(&wf->wakeref);\n\t}\n\nunlock:\n\tmutex_unlock(&wf->mutex);\n}\n\nvoid __intel_wakeref_put_last(struct intel_wakeref *wf, unsigned long flags)\n{\n\tINTEL_WAKEREF_BUG_ON(delayed_work_pending(&wf->work));\n\n\t \n\tif (flags & INTEL_WAKEREF_PUT_ASYNC || !mutex_trylock(&wf->mutex)) {\n\t\tmod_delayed_work(wf->i915->unordered_wq, &wf->work,\n\t\t\t\t FIELD_GET(INTEL_WAKEREF_PUT_DELAY, flags));\n\t\treturn;\n\t}\n\n\t____intel_wakeref_put_last(wf);\n}\n\nstatic void __intel_wakeref_put_work(struct work_struct *wrk)\n{\n\tstruct intel_wakeref *wf = container_of(wrk, typeof(*wf), work.work);\n\n\tif (atomic_add_unless(&wf->count, -1, 1))\n\t\treturn;\n\n\tmutex_lock(&wf->mutex);\n\t____intel_wakeref_put_last(wf);\n}\n\nvoid __intel_wakeref_init(struct intel_wakeref *wf,\n\t\t\t  struct drm_i915_private *i915,\n\t\t\t  const struct intel_wakeref_ops *ops,\n\t\t\t  struct intel_wakeref_lockclass *key)\n{\n\twf->i915 = i915;\n\twf->ops = ops;\n\n\t__mutex_init(&wf->mutex, \"wakeref.mutex\", &key->mutex);\n\tatomic_set(&wf->count, 0);\n\twf->wakeref = 0;\n\n\tINIT_DELAYED_WORK(&wf->work, __intel_wakeref_put_work);\n\tlockdep_init_map(&wf->work.work.lockdep_map,\n\t\t\t \"wakeref.work\", &key->work, 0);\n}\n\nint intel_wakeref_wait_for_idle(struct intel_wakeref *wf)\n{\n\tint err;\n\n\tmight_sleep();\n\n\terr = wait_var_event_killable(&wf->wakeref,\n\t\t\t\t      !intel_wakeref_is_active(wf));\n\tif (err)\n\t\treturn err;\n\n\tintel_wakeref_unlock_wait(wf);\n\treturn 0;\n}\n\nstatic void wakeref_auto_timeout(struct timer_list *t)\n{\n\tstruct intel_wakeref_auto *wf = from_timer(wf, t, timer);\n\tintel_wakeref_t wakeref;\n\tunsigned long flags;\n\n\tif (!refcount_dec_and_lock_irqsave(&wf->count, &wf->lock, &flags))\n\t\treturn;\n\n\twakeref = fetch_and_zero(&wf->wakeref);\n\tspin_unlock_irqrestore(&wf->lock, flags);\n\n\tintel_runtime_pm_put(&wf->i915->runtime_pm, wakeref);\n}\n\nvoid intel_wakeref_auto_init(struct intel_wakeref_auto *wf,\n\t\t\t     struct drm_i915_private *i915)\n{\n\tspin_lock_init(&wf->lock);\n\ttimer_setup(&wf->timer, wakeref_auto_timeout, 0);\n\trefcount_set(&wf->count, 0);\n\twf->wakeref = 0;\n\twf->i915 = i915;\n}\n\nvoid intel_wakeref_auto(struct intel_wakeref_auto *wf, unsigned long timeout)\n{\n\tunsigned long flags;\n\n\tif (!timeout) {\n\t\tif (del_timer_sync(&wf->timer))\n\t\t\twakeref_auto_timeout(&wf->timer);\n\t\treturn;\n\t}\n\n\t \n\tassert_rpm_wakelock_held(&wf->i915->runtime_pm);\n\n\tif (!refcount_inc_not_zero(&wf->count)) {\n\t\tspin_lock_irqsave(&wf->lock, flags);\n\t\tif (!refcount_inc_not_zero(&wf->count)) {\n\t\t\tINTEL_WAKEREF_BUG_ON(wf->wakeref);\n\t\t\twf->wakeref =\n\t\t\t\tintel_runtime_pm_get_if_in_use(&wf->i915->runtime_pm);\n\t\t\trefcount_set(&wf->count, 1);\n\t\t}\n\t\tspin_unlock_irqrestore(&wf->lock, flags);\n\t}\n\n\t \n\tif (mod_timer(&wf->timer, jiffies + timeout))\n\t\twakeref_auto_timeout(&wf->timer);\n}\n\nvoid intel_wakeref_auto_fini(struct intel_wakeref_auto *wf)\n{\n\tintel_wakeref_auto(wf, 0);\n\tINTEL_WAKEREF_BUG_ON(wf->wakeref);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}