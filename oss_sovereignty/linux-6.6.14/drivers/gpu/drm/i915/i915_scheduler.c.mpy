{
  "module_name": "i915_scheduler.c",
  "hash_id": "3d99165b7bfe096f752092fdc95b47f83a82c52288f4ecabd0c9821988d86080",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/i915/i915_scheduler.c",
  "human_readable_source": " \n\n#include <linux/mutex.h>\n\n#include \"i915_drv.h\"\n#include \"i915_request.h\"\n#include \"i915_scheduler.h\"\n\nstatic struct kmem_cache *slab_dependencies;\nstatic struct kmem_cache *slab_priorities;\n\nstatic DEFINE_SPINLOCK(schedule_lock);\n\nstatic const struct i915_request *\nnode_to_request(const struct i915_sched_node *node)\n{\n\treturn container_of(node, const struct i915_request, sched);\n}\n\nstatic inline bool node_started(const struct i915_sched_node *node)\n{\n\treturn i915_request_started(node_to_request(node));\n}\n\nstatic inline bool node_signaled(const struct i915_sched_node *node)\n{\n\treturn i915_request_completed(node_to_request(node));\n}\n\nstatic inline struct i915_priolist *to_priolist(struct rb_node *rb)\n{\n\treturn rb_entry(rb, struct i915_priolist, node);\n}\n\nstatic void assert_priolists(struct i915_sched_engine * const sched_engine)\n{\n\tstruct rb_node *rb;\n\tlong last_prio;\n\n\tif (!IS_ENABLED(CONFIG_DRM_I915_DEBUG_GEM))\n\t\treturn;\n\n\tGEM_BUG_ON(rb_first_cached(&sched_engine->queue) !=\n\t\t   rb_first(&sched_engine->queue.rb_root));\n\n\tlast_prio = INT_MAX;\n\tfor (rb = rb_first_cached(&sched_engine->queue); rb; rb = rb_next(rb)) {\n\t\tconst struct i915_priolist *p = to_priolist(rb);\n\n\t\tGEM_BUG_ON(p->priority > last_prio);\n\t\tlast_prio = p->priority;\n\t}\n}\n\nstruct list_head *\ni915_sched_lookup_priolist(struct i915_sched_engine *sched_engine, int prio)\n{\n\tstruct i915_priolist *p;\n\tstruct rb_node **parent, *rb;\n\tbool first = true;\n\n\tlockdep_assert_held(&sched_engine->lock);\n\tassert_priolists(sched_engine);\n\n\tif (unlikely(sched_engine->no_priolist))\n\t\tprio = I915_PRIORITY_NORMAL;\n\nfind_priolist:\n\t \n\trb = NULL;\n\tparent = &sched_engine->queue.rb_root.rb_node;\n\twhile (*parent) {\n\t\trb = *parent;\n\t\tp = to_priolist(rb);\n\t\tif (prio > p->priority) {\n\t\t\tparent = &rb->rb_left;\n\t\t} else if (prio < p->priority) {\n\t\t\tparent = &rb->rb_right;\n\t\t\tfirst = false;\n\t\t} else {\n\t\t\treturn &p->requests;\n\t\t}\n\t}\n\n\tif (prio == I915_PRIORITY_NORMAL) {\n\t\tp = &sched_engine->default_priolist;\n\t} else {\n\t\tp = kmem_cache_alloc(slab_priorities, GFP_ATOMIC);\n\t\t \n\t\tif (unlikely(!p)) {\n\t\t\tprio = I915_PRIORITY_NORMAL;  \n\n\t\t\t \n\t\t\tsched_engine->no_priolist = true;\n\t\t\tgoto find_priolist;\n\t\t}\n\t}\n\n\tp->priority = prio;\n\tINIT_LIST_HEAD(&p->requests);\n\n\trb_link_node(&p->node, rb, parent);\n\trb_insert_color_cached(&p->node, &sched_engine->queue, first);\n\n\treturn &p->requests;\n}\n\nvoid __i915_priolist_free(struct i915_priolist *p)\n{\n\tkmem_cache_free(slab_priorities, p);\n}\n\nstruct sched_cache {\n\tstruct list_head *priolist;\n};\n\nstatic struct i915_sched_engine *\nlock_sched_engine(struct i915_sched_node *node,\n\t\t  struct i915_sched_engine *locked,\n\t\t  struct sched_cache *cache)\n{\n\tconst struct i915_request *rq = node_to_request(node);\n\tstruct i915_sched_engine *sched_engine;\n\n\tGEM_BUG_ON(!locked);\n\n\t \n\twhile (locked != (sched_engine = READ_ONCE(rq->engine)->sched_engine)) {\n\t\tspin_unlock(&locked->lock);\n\t\tmemset(cache, 0, sizeof(*cache));\n\t\tspin_lock(&sched_engine->lock);\n\t\tlocked = sched_engine;\n\t}\n\n\tGEM_BUG_ON(locked != sched_engine);\n\treturn locked;\n}\n\nstatic void __i915_schedule(struct i915_sched_node *node,\n\t\t\t    const struct i915_sched_attr *attr)\n{\n\tconst int prio = max(attr->priority, node->attr.priority);\n\tstruct i915_sched_engine *sched_engine;\n\tstruct i915_dependency *dep, *p;\n\tstruct i915_dependency stack;\n\tstruct sched_cache cache;\n\tLIST_HEAD(dfs);\n\n\t \n\tlockdep_assert_held(&schedule_lock);\n\tGEM_BUG_ON(prio == I915_PRIORITY_INVALID);\n\n\tif (node_signaled(node))\n\t\treturn;\n\n\tstack.signaler = node;\n\tlist_add(&stack.dfs_link, &dfs);\n\n\t \n\tlist_for_each_entry(dep, &dfs, dfs_link) {\n\t\tstruct i915_sched_node *node = dep->signaler;\n\n\t\t \n\t\tif (node_started(node))\n\t\t\tcontinue;\n\n\t\t \n\t\tlist_for_each_entry(p, &node->signalers_list, signal_link) {\n\t\t\tGEM_BUG_ON(p == dep);  \n\n\t\t\tif (node_signaled(p->signaler))\n\t\t\t\tcontinue;\n\n\t\t\tif (prio > READ_ONCE(p->signaler->attr.priority))\n\t\t\t\tlist_move_tail(&p->dfs_link, &dfs);\n\t\t}\n\t}\n\n\t \n\tif (node->attr.priority == I915_PRIORITY_INVALID) {\n\t\tGEM_BUG_ON(!list_empty(&node->link));\n\t\tnode->attr = *attr;\n\n\t\tif (stack.dfs_link.next == stack.dfs_link.prev)\n\t\t\treturn;\n\n\t\t__list_del_entry(&stack.dfs_link);\n\t}\n\n\tmemset(&cache, 0, sizeof(cache));\n\tsched_engine = node_to_request(node)->engine->sched_engine;\n\tspin_lock(&sched_engine->lock);\n\n\t \n\tsched_engine = lock_sched_engine(node, sched_engine, &cache);\n\tlist_for_each_entry_safe_reverse(dep, p, &dfs, dfs_link) {\n\t\tstruct i915_request *from = container_of(dep->signaler,\n\t\t\t\t\t\t\t struct i915_request,\n\t\t\t\t\t\t\t sched);\n\t\tINIT_LIST_HEAD(&dep->dfs_link);\n\n\t\tnode = dep->signaler;\n\t\tsched_engine = lock_sched_engine(node, sched_engine, &cache);\n\t\tlockdep_assert_held(&sched_engine->lock);\n\n\t\t \n\t\tif (prio <= node->attr.priority || node_signaled(node))\n\t\t\tcontinue;\n\n\t\tGEM_BUG_ON(node_to_request(node)->engine->sched_engine !=\n\t\t\t   sched_engine);\n\n\t\t \n\t\tif (sched_engine->bump_inflight_request_prio)\n\t\t\tsched_engine->bump_inflight_request_prio(from, prio);\n\n\t\tWRITE_ONCE(node->attr.priority, prio);\n\n\t\t \n\t\tif (list_empty(&node->link))\n\t\t\tcontinue;\n\n\t\tif (i915_request_in_priority_queue(node_to_request(node))) {\n\t\t\tif (!cache.priolist)\n\t\t\t\tcache.priolist =\n\t\t\t\t\ti915_sched_lookup_priolist(sched_engine,\n\t\t\t\t\t\t\t\t   prio);\n\t\t\tlist_move_tail(&node->link, cache.priolist);\n\t\t}\n\n\t\t \n\t\tif (sched_engine->kick_backend)\n\t\t\tsched_engine->kick_backend(node_to_request(node), prio);\n\t}\n\n\tspin_unlock(&sched_engine->lock);\n}\n\nvoid i915_schedule(struct i915_request *rq, const struct i915_sched_attr *attr)\n{\n\tspin_lock_irq(&schedule_lock);\n\t__i915_schedule(&rq->sched, attr);\n\tspin_unlock_irq(&schedule_lock);\n}\n\nvoid i915_sched_node_init(struct i915_sched_node *node)\n{\n\tINIT_LIST_HEAD(&node->signalers_list);\n\tINIT_LIST_HEAD(&node->waiters_list);\n\tINIT_LIST_HEAD(&node->link);\n\n\ti915_sched_node_reinit(node);\n}\n\nvoid i915_sched_node_reinit(struct i915_sched_node *node)\n{\n\tnode->attr.priority = I915_PRIORITY_INVALID;\n\tnode->semaphores = 0;\n\tnode->flags = 0;\n\n\tGEM_BUG_ON(!list_empty(&node->signalers_list));\n\tGEM_BUG_ON(!list_empty(&node->waiters_list));\n\tGEM_BUG_ON(!list_empty(&node->link));\n}\n\nstatic struct i915_dependency *\ni915_dependency_alloc(void)\n{\n\treturn kmem_cache_alloc(slab_dependencies, GFP_KERNEL);\n}\n\nstatic void\ni915_dependency_free(struct i915_dependency *dep)\n{\n\tkmem_cache_free(slab_dependencies, dep);\n}\n\nbool __i915_sched_node_add_dependency(struct i915_sched_node *node,\n\t\t\t\t      struct i915_sched_node *signal,\n\t\t\t\t      struct i915_dependency *dep,\n\t\t\t\t      unsigned long flags)\n{\n\tbool ret = false;\n\n\tspin_lock_irq(&schedule_lock);\n\n\tif (!node_signaled(signal)) {\n\t\tINIT_LIST_HEAD(&dep->dfs_link);\n\t\tdep->signaler = signal;\n\t\tdep->waiter = node;\n\t\tdep->flags = flags;\n\n\t\t \n\t\tlist_add_rcu(&dep->signal_link, &node->signalers_list);\n\t\tlist_add_rcu(&dep->wait_link, &signal->waiters_list);\n\n\t\t \n\t\tnode->flags |= signal->flags;\n\t\tret = true;\n\t}\n\n\tspin_unlock_irq(&schedule_lock);\n\n\treturn ret;\n}\n\nint i915_sched_node_add_dependency(struct i915_sched_node *node,\n\t\t\t\t   struct i915_sched_node *signal,\n\t\t\t\t   unsigned long flags)\n{\n\tstruct i915_dependency *dep;\n\n\tdep = i915_dependency_alloc();\n\tif (!dep)\n\t\treturn -ENOMEM;\n\n\tif (!__i915_sched_node_add_dependency(node, signal, dep,\n\t\t\t\t\t      flags | I915_DEPENDENCY_ALLOC))\n\t\ti915_dependency_free(dep);\n\n\treturn 0;\n}\n\nvoid i915_sched_node_fini(struct i915_sched_node *node)\n{\n\tstruct i915_dependency *dep, *tmp;\n\n\tspin_lock_irq(&schedule_lock);\n\n\t \n\tlist_for_each_entry_safe(dep, tmp, &node->signalers_list, signal_link) {\n\t\tGEM_BUG_ON(!list_empty(&dep->dfs_link));\n\n\t\tlist_del_rcu(&dep->wait_link);\n\t\tif (dep->flags & I915_DEPENDENCY_ALLOC)\n\t\t\ti915_dependency_free(dep);\n\t}\n\tINIT_LIST_HEAD(&node->signalers_list);\n\n\t \n\tlist_for_each_entry_safe(dep, tmp, &node->waiters_list, wait_link) {\n\t\tGEM_BUG_ON(dep->signaler != node);\n\t\tGEM_BUG_ON(!list_empty(&dep->dfs_link));\n\n\t\tlist_del_rcu(&dep->signal_link);\n\t\tif (dep->flags & I915_DEPENDENCY_ALLOC)\n\t\t\ti915_dependency_free(dep);\n\t}\n\tINIT_LIST_HEAD(&node->waiters_list);\n\n\tspin_unlock_irq(&schedule_lock);\n}\n\nvoid i915_request_show_with_schedule(struct drm_printer *m,\n\t\t\t\t     const struct i915_request *rq,\n\t\t\t\t     const char *prefix,\n\t\t\t\t     int indent)\n{\n\tstruct i915_dependency *dep;\n\n\ti915_request_show(m, rq, prefix, indent);\n\tif (i915_request_completed(rq))\n\t\treturn;\n\n\trcu_read_lock();\n\tfor_each_signaler(dep, rq) {\n\t\tconst struct i915_request *signaler =\n\t\t\tnode_to_request(dep->signaler);\n\n\t\t \n\t\tif (signaler->timeline == rq->timeline)\n\t\t\tcontinue;\n\n\t\tif (__i915_request_is_complete(signaler))\n\t\t\tcontinue;\n\n\t\ti915_request_show(m, signaler, prefix, indent + 2);\n\t}\n\trcu_read_unlock();\n}\n\nstatic void default_destroy(struct kref *kref)\n{\n\tstruct i915_sched_engine *sched_engine =\n\t\tcontainer_of(kref, typeof(*sched_engine), ref);\n\n\ttasklet_kill(&sched_engine->tasklet);  \n\tkfree(sched_engine);\n}\n\nstatic bool default_disabled(struct i915_sched_engine *sched_engine)\n{\n\treturn false;\n}\n\nstruct i915_sched_engine *\ni915_sched_engine_create(unsigned int subclass)\n{\n\tstruct i915_sched_engine *sched_engine;\n\n\tsched_engine = kzalloc(sizeof(*sched_engine), GFP_KERNEL);\n\tif (!sched_engine)\n\t\treturn NULL;\n\n\tkref_init(&sched_engine->ref);\n\n\tsched_engine->queue = RB_ROOT_CACHED;\n\tsched_engine->queue_priority_hint = INT_MIN;\n\tsched_engine->destroy = default_destroy;\n\tsched_engine->disabled = default_disabled;\n\n\tINIT_LIST_HEAD(&sched_engine->requests);\n\tINIT_LIST_HEAD(&sched_engine->hold);\n\n\tspin_lock_init(&sched_engine->lock);\n\tlockdep_set_subclass(&sched_engine->lock, subclass);\n\n\t \n#ifdef CONFIG_DEBUG_LOCK_ALLOC\n\tlocal_irq_disable();\n\tlock_map_acquire(&sched_engine->lock.dep_map);\n\tlock_map_release(&sched_engine->lock.dep_map);\n\tlocal_irq_enable();\n#endif\n\n\treturn sched_engine;\n}\n\nvoid i915_scheduler_module_exit(void)\n{\n\tkmem_cache_destroy(slab_dependencies);\n\tkmem_cache_destroy(slab_priorities);\n}\n\nint __init i915_scheduler_module_init(void)\n{\n\tslab_dependencies = KMEM_CACHE(i915_dependency,\n\t\t\t\t\t      SLAB_HWCACHE_ALIGN |\n\t\t\t\t\t      SLAB_TYPESAFE_BY_RCU);\n\tif (!slab_dependencies)\n\t\treturn -ENOMEM;\n\n\tslab_priorities = KMEM_CACHE(i915_priolist, 0);\n\tif (!slab_priorities)\n\t\tgoto err_priorities;\n\n\treturn 0;\n\nerr_priorities:\n\tkmem_cache_destroy(slab_priorities);\n\treturn -ENOMEM;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}