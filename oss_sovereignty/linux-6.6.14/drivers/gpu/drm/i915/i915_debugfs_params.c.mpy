{
  "module_name": "i915_debugfs_params.c",
  "hash_id": "f8b6540b58f0722198ca97a7480fcd4c078d5a5cc0faab57461a12f20d5c60d3",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/i915/i915_debugfs_params.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n\n#include \"i915_debugfs_params.h\"\n#include \"gt/intel_gt.h\"\n#include \"gt/uc/intel_guc.h\"\n#include \"i915_drv.h\"\n#include \"i915_params.h\"\n\n#define MATCH_DEBUGFS_NODE_NAME(_file, _name) \\\n\t(strcmp((_file)->f_path.dentry->d_name.name, (_name)) == 0)\n\n#define GET_I915(i915, name, ptr)\t\\\n\tdo {\t\\\n\t\tstruct i915_params *params;\t\\\n\t\tparams = container_of(((void *)(ptr)), typeof(*params), name);\t\\\n\t\t(i915) = container_of(params, typeof(*(i915)), params);\t\\\n\t} while (0)\n\n \nstatic int i915_param_int_show(struct seq_file *m, void *data)\n{\n\tint *value = m->private;\n\n\tseq_printf(m, \"%d\\n\", *value);\n\n\treturn 0;\n}\n\nstatic int i915_param_int_open(struct inode *inode, struct file *file)\n{\n\treturn single_open(file, i915_param_int_show, inode->i_private);\n}\n\nstatic int notify_guc(struct drm_i915_private *i915)\n{\n\tint ret = 0;\n\n\tif (intel_uc_uses_guc_submission(&to_gt(i915)->uc))\n\t\tret = intel_guc_global_policies_update(&to_gt(i915)->uc.guc);\n\n\treturn ret;\n}\n\nstatic ssize_t i915_param_int_write(struct file *file,\n\t\t\t\t    const char __user *ubuf, size_t len,\n\t\t\t\t    loff_t *offp)\n{\n\tstruct seq_file *m = file->private_data;\n\tint *value = m->private;\n\tint ret;\n\n\tret = kstrtoint_from_user(ubuf, len, 0, value);\n\tif (ret) {\n\t\t \n\t\tbool b;\n\n\t\tret = kstrtobool_from_user(ubuf, len, &b);\n\t\tif (!ret)\n\t\t\t*value = b;\n\t}\n\n\treturn ret ?: len;\n}\n\nstatic const struct file_operations i915_param_int_fops = {\n\t.owner = THIS_MODULE,\n\t.open = i915_param_int_open,\n\t.read = seq_read,\n\t.write = i915_param_int_write,\n\t.llseek = default_llseek,\n\t.release = single_release,\n};\n\nstatic const struct file_operations i915_param_int_fops_ro = {\n\t.owner = THIS_MODULE,\n\t.open = i915_param_int_open,\n\t.read = seq_read,\n\t.llseek = default_llseek,\n\t.release = single_release,\n};\n\n \nstatic int i915_param_uint_show(struct seq_file *m, void *data)\n{\n\tunsigned int *value = m->private;\n\n\tseq_printf(m, \"%u\\n\", *value);\n\n\treturn 0;\n}\n\nstatic int i915_param_uint_open(struct inode *inode, struct file *file)\n{\n\treturn single_open(file, i915_param_uint_show, inode->i_private);\n}\n\nstatic ssize_t i915_param_uint_write(struct file *file,\n\t\t\t\t     const char __user *ubuf, size_t len,\n\t\t\t\t     loff_t *offp)\n{\n\tstruct drm_i915_private *i915;\n\tstruct seq_file *m = file->private_data;\n\tunsigned int *value = m->private;\n\tunsigned int old = *value;\n\tint ret;\n\n\tret = kstrtouint_from_user(ubuf, len, 0, value);\n\tif (ret) {\n\t\t \n\t\tbool b;\n\n\t\tret = kstrtobool_from_user(ubuf, len, &b);\n\t\tif (!ret)\n\t\t\t*value = b;\n\t}\n\n\tif (!ret && MATCH_DEBUGFS_NODE_NAME(file, \"reset\")) {\n\t\tGET_I915(i915, reset, value);\n\n\t\tret = notify_guc(i915);\n\t\tif (ret)\n\t\t\t*value = old;\n\t}\n\n\treturn ret ?: len;\n}\n\nstatic const struct file_operations i915_param_uint_fops = {\n\t.owner = THIS_MODULE,\n\t.open = i915_param_uint_open,\n\t.read = seq_read,\n\t.write = i915_param_uint_write,\n\t.llseek = default_llseek,\n\t.release = single_release,\n};\n\nstatic const struct file_operations i915_param_uint_fops_ro = {\n\t.owner = THIS_MODULE,\n\t.open = i915_param_uint_open,\n\t.read = seq_read,\n\t.llseek = default_llseek,\n\t.release = single_release,\n};\n\n \nstatic int i915_param_charp_show(struct seq_file *m, void *data)\n{\n\tconst char **s = m->private;\n\n\tseq_printf(m, \"%s\\n\", *s);\n\n\treturn 0;\n}\n\nstatic int i915_param_charp_open(struct inode *inode, struct file *file)\n{\n\treturn single_open(file, i915_param_charp_show, inode->i_private);\n}\n\nstatic ssize_t i915_param_charp_write(struct file *file,\n\t\t\t\t      const char __user *ubuf, size_t len,\n\t\t\t\t      loff_t *offp)\n{\n\tstruct seq_file *m = file->private_data;\n\tchar **s = m->private;\n\tchar *new, *old;\n\n\told = *s;\n\tnew = strndup_user(ubuf, PAGE_SIZE);\n\tif (IS_ERR(new)) {\n\t\tlen = PTR_ERR(new);\n\t\tgoto out;\n\t}\n\n\t*s = new;\n\n\tkfree(old);\nout:\n\treturn len;\n}\n\nstatic const struct file_operations i915_param_charp_fops = {\n\t.owner = THIS_MODULE,\n\t.open = i915_param_charp_open,\n\t.read = seq_read,\n\t.write = i915_param_charp_write,\n\t.llseek = default_llseek,\n\t.release = single_release,\n};\n\nstatic const struct file_operations i915_param_charp_fops_ro = {\n\t.owner = THIS_MODULE,\n\t.open = i915_param_charp_open,\n\t.read = seq_read,\n\t.llseek = default_llseek,\n\t.release = single_release,\n};\n\n#define RO(mode) (((mode) & 0222) == 0)\n\nstatic struct dentry *\ni915_debugfs_create_int(const char *name, umode_t mode,\n\t\t\tstruct dentry *parent, int *value)\n{\n\treturn debugfs_create_file_unsafe(name, mode, parent, value,\n\t\t\t\t\t  RO(mode) ? &i915_param_int_fops_ro :\n\t\t\t\t\t  &i915_param_int_fops);\n}\n\nstatic struct dentry *\ni915_debugfs_create_uint(const char *name, umode_t mode,\n\t\t\t struct dentry *parent, unsigned int *value)\n{\n\treturn debugfs_create_file_unsafe(name, mode, parent, value,\n\t\t\t\t\t  RO(mode) ? &i915_param_uint_fops_ro :\n\t\t\t\t\t  &i915_param_uint_fops);\n}\n\nstatic struct dentry *\ni915_debugfs_create_charp(const char *name, umode_t mode,\n\t\t\t  struct dentry *parent, char **value)\n{\n\treturn debugfs_create_file(name, mode, parent, value,\n\t\t\t\t   RO(mode) ? &i915_param_charp_fops_ro :\n\t\t\t\t   &i915_param_charp_fops);\n}\n\n#define _i915_param_create_file(parent, name, mode, valp)\t\t\\\n\tdo {\t\t\t\t\t\t\t\t\\\n\t\tif (mode)\t\t\t\t\t\t\\\n\t\t\t_Generic(valp,\t\t\t\t\t\\\n\t\t\t\t bool *: debugfs_create_bool,\t\t\\\n\t\t\t\t int *: i915_debugfs_create_int,\t\\\n\t\t\t\t unsigned int *: i915_debugfs_create_uint, \\\n\t\t\t\t unsigned long *: debugfs_create_ulong,\t\\\n\t\t\t\t char **: i915_debugfs_create_charp)(name, mode, parent, valp); \\\n\t} while(0)\n\n \nstruct dentry *i915_debugfs_params(struct drm_i915_private *i915)\n{\n\tstruct drm_minor *minor = i915->drm.primary;\n\tstruct i915_params *params = &i915->params;\n\tstruct dentry *dir;\n\n\tdir = debugfs_create_dir(\"i915_params\", minor->debugfs_root);\n\tif (IS_ERR(dir))\n\t\treturn dir;\n\n\t \n\n#define REGISTER(T, x, unused, mode, ...) _i915_param_create_file(dir, #x, mode, &params->x);\n\tI915_PARAMS_FOR_EACH(REGISTER);\n#undef REGISTER\n\n\treturn dir;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}