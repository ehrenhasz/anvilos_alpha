{
  "module_name": "i915_debugfs.c",
  "hash_id": "a8a0dceb724f2a48d212c693e96ae40b251cacf4b030c25c6c922b699fee0076",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/i915/i915_debugfs.c",
  "human_readable_source": " \n\n#include <linux/sched/mm.h>\n#include <linux/sort.h>\n#include <linux/string_helpers.h>\n\n#include <drm/drm_debugfs.h>\n\n#include \"gem/i915_gem_context.h\"\n#include \"gt/intel_gt.h\"\n#include \"gt/intel_gt_buffer_pool.h\"\n#include \"gt/intel_gt_clock_utils.h\"\n#include \"gt/intel_gt_debugfs.h\"\n#include \"gt/intel_gt_pm.h\"\n#include \"gt/intel_gt_pm_debugfs.h\"\n#include \"gt/intel_gt_regs.h\"\n#include \"gt/intel_gt_requests.h\"\n#include \"gt/intel_rc6.h\"\n#include \"gt/intel_reset.h\"\n#include \"gt/intel_rps.h\"\n#include \"gt/intel_sseu_debugfs.h\"\n\n#include \"i915_debugfs.h\"\n#include \"i915_debugfs_params.h\"\n#include \"i915_driver.h\"\n#include \"i915_irq.h\"\n#include \"i915_reg.h\"\n#include \"i915_scheduler.h\"\n#include \"intel_mchbar_regs.h\"\n\nstatic inline struct drm_i915_private *node_to_i915(struct drm_info_node *node)\n{\n\treturn to_i915(node->minor->dev);\n}\n\nstatic int i915_capabilities(struct seq_file *m, void *data)\n{\n\tstruct drm_i915_private *i915 = node_to_i915(m->private);\n\tstruct drm_printer p = drm_seq_file_printer(m);\n\n\tseq_printf(m, \"pch: %d\\n\", INTEL_PCH_TYPE(i915));\n\n\tintel_device_info_print(INTEL_INFO(i915), RUNTIME_INFO(i915), &p);\n\tintel_display_device_info_print(DISPLAY_INFO(i915), DISPLAY_RUNTIME_INFO(i915), &p);\n\ti915_print_iommu_status(i915, &p);\n\tintel_gt_info_print(&to_gt(i915)->info, &p);\n\tintel_driver_caps_print(&i915->caps, &p);\n\n\tkernel_param_lock(THIS_MODULE);\n\ti915_params_dump(&i915->params, &p);\n\tkernel_param_unlock(THIS_MODULE);\n\n\treturn 0;\n}\n\nstatic char get_tiling_flag(struct drm_i915_gem_object *obj)\n{\n\tswitch (i915_gem_object_get_tiling(obj)) {\n\tdefault:\n\tcase I915_TILING_NONE: return ' ';\n\tcase I915_TILING_X: return 'X';\n\tcase I915_TILING_Y: return 'Y';\n\t}\n}\n\nstatic char get_global_flag(struct drm_i915_gem_object *obj)\n{\n\treturn READ_ONCE(obj->userfault_count) ? 'g' : ' ';\n}\n\nstatic char get_pin_mapped_flag(struct drm_i915_gem_object *obj)\n{\n\treturn obj->mm.mapping ? 'M' : ' ';\n}\n\nstatic const char *\nstringify_page_sizes(unsigned int page_sizes, char *buf, size_t len)\n{\n\tsize_t x = 0;\n\n\tswitch (page_sizes) {\n\tcase 0:\n\t\treturn \"\";\n\tcase I915_GTT_PAGE_SIZE_4K:\n\t\treturn \"4K\";\n\tcase I915_GTT_PAGE_SIZE_64K:\n\t\treturn \"64K\";\n\tcase I915_GTT_PAGE_SIZE_2M:\n\t\treturn \"2M\";\n\tdefault:\n\t\tif (!buf)\n\t\t\treturn \"M\";\n\n\t\tif (page_sizes & I915_GTT_PAGE_SIZE_2M)\n\t\t\tx += snprintf(buf + x, len - x, \"2M, \");\n\t\tif (page_sizes & I915_GTT_PAGE_SIZE_64K)\n\t\t\tx += snprintf(buf + x, len - x, \"64K, \");\n\t\tif (page_sizes & I915_GTT_PAGE_SIZE_4K)\n\t\t\tx += snprintf(buf + x, len - x, \"4K, \");\n\t\tbuf[x-2] = '\\0';\n\n\t\treturn buf;\n\t}\n}\n\nstatic const char *stringify_vma_type(const struct i915_vma *vma)\n{\n\tif (i915_vma_is_ggtt(vma))\n\t\treturn \"ggtt\";\n\n\tif (i915_vma_is_dpt(vma))\n\t\treturn \"dpt\";\n\n\treturn \"ppgtt\";\n}\n\nstatic const char *i915_cache_level_str(struct drm_i915_gem_object *obj)\n{\n\tstruct drm_i915_private *i915 = obj_to_i915(obj);\n\n\tif (IS_METEORLAKE(i915)) {\n\t\tswitch (obj->pat_index) {\n\t\tcase 0: return \" WB\";\n\t\tcase 1: return \" WT\";\n\t\tcase 2: return \" UC\";\n\t\tcase 3: return \" WB (1-Way Coh)\";\n\t\tcase 4: return \" WB (2-Way Coh)\";\n\t\tdefault: return \" not defined\";\n\t\t}\n\t} else if (IS_PONTEVECCHIO(i915)) {\n\t\tswitch (obj->pat_index) {\n\t\tcase 0: return \" UC\";\n\t\tcase 1: return \" WC\";\n\t\tcase 2: return \" WT\";\n\t\tcase 3: return \" WB\";\n\t\tcase 4: return \" WT (CLOS1)\";\n\t\tcase 5: return \" WB (CLOS1)\";\n\t\tcase 6: return \" WT (CLOS2)\";\n\t\tcase 7: return \" WT (CLOS2)\";\n\t\tdefault: return \" not defined\";\n\t\t}\n\t} else if (GRAPHICS_VER(i915) >= 12) {\n\t\tswitch (obj->pat_index) {\n\t\tcase 0: return \" WB\";\n\t\tcase 1: return \" WC\";\n\t\tcase 2: return \" WT\";\n\t\tcase 3: return \" UC\";\n\t\tdefault: return \" not defined\";\n\t\t}\n\t} else {\n\t\tswitch (obj->pat_index) {\n\t\tcase 0: return \" UC\";\n\t\tcase 1: return HAS_LLC(i915) ?\n\t\t\t       \" LLC\" : \" snooped\";\n\t\tcase 2: return \" L3+LLC\";\n\t\tcase 3: return \" WT\";\n\t\tdefault: return \" not defined\";\n\t\t}\n\t}\n}\n\nvoid\ni915_debugfs_describe_obj(struct seq_file *m, struct drm_i915_gem_object *obj)\n{\n\tstruct i915_vma *vma;\n\tint pin_count = 0;\n\n\tseq_printf(m, \"%pK: %c%c%c %8zdKiB %02x %02x %s%s%s\",\n\t\t   &obj->base,\n\t\t   get_tiling_flag(obj),\n\t\t   get_global_flag(obj),\n\t\t   get_pin_mapped_flag(obj),\n\t\t   obj->base.size / 1024,\n\t\t   obj->read_domains,\n\t\t   obj->write_domain,\n\t\t   i915_cache_level_str(obj),\n\t\t   obj->mm.dirty ? \" dirty\" : \"\",\n\t\t   obj->mm.madv == I915_MADV_DONTNEED ? \" purgeable\" : \"\");\n\tif (obj->base.name)\n\t\tseq_printf(m, \" (name: %d)\", obj->base.name);\n\n\tspin_lock(&obj->vma.lock);\n\tlist_for_each_entry(vma, &obj->vma.list, obj_link) {\n\t\tif (!drm_mm_node_allocated(&vma->node))\n\t\t\tcontinue;\n\n\t\tspin_unlock(&obj->vma.lock);\n\n\t\tif (i915_vma_is_pinned(vma))\n\t\t\tpin_count++;\n\n\t\tseq_printf(m, \" (%s offset: %08llx, size: %08llx, pages: %s\",\n\t\t\t   stringify_vma_type(vma),\n\t\t\t   i915_vma_offset(vma), i915_vma_size(vma),\n\t\t\t   stringify_page_sizes(vma->resource->page_sizes_gtt,\n\t\t\t\t\t\tNULL, 0));\n\t\tif (i915_vma_is_ggtt(vma) || i915_vma_is_dpt(vma)) {\n\t\t\tswitch (vma->gtt_view.type) {\n\t\t\tcase I915_GTT_VIEW_NORMAL:\n\t\t\t\tseq_puts(m, \", normal\");\n\t\t\t\tbreak;\n\n\t\t\tcase I915_GTT_VIEW_PARTIAL:\n\t\t\t\tseq_printf(m, \", partial [%08llx+%x]\",\n\t\t\t\t\t   vma->gtt_view.partial.offset << PAGE_SHIFT,\n\t\t\t\t\t   vma->gtt_view.partial.size << PAGE_SHIFT);\n\t\t\t\tbreak;\n\n\t\t\tcase I915_GTT_VIEW_ROTATED:\n\t\t\t\tseq_printf(m, \", rotated [(%ux%u, src_stride=%u, dst_stride=%u, offset=%u), (%ux%u, src_stride=%u, dst_stride=%u, offset=%u)]\",\n\t\t\t\t\t   vma->gtt_view.rotated.plane[0].width,\n\t\t\t\t\t   vma->gtt_view.rotated.plane[0].height,\n\t\t\t\t\t   vma->gtt_view.rotated.plane[0].src_stride,\n\t\t\t\t\t   vma->gtt_view.rotated.plane[0].dst_stride,\n\t\t\t\t\t   vma->gtt_view.rotated.plane[0].offset,\n\t\t\t\t\t   vma->gtt_view.rotated.plane[1].width,\n\t\t\t\t\t   vma->gtt_view.rotated.plane[1].height,\n\t\t\t\t\t   vma->gtt_view.rotated.plane[1].src_stride,\n\t\t\t\t\t   vma->gtt_view.rotated.plane[1].dst_stride,\n\t\t\t\t\t   vma->gtt_view.rotated.plane[1].offset);\n\t\t\t\tbreak;\n\n\t\t\tcase I915_GTT_VIEW_REMAPPED:\n\t\t\t\tseq_printf(m, \", remapped [(%ux%u, src_stride=%u, dst_stride=%u, offset=%u), (%ux%u, src_stride=%u, dst_stride=%u, offset=%u)]\",\n\t\t\t\t\t   vma->gtt_view.remapped.plane[0].width,\n\t\t\t\t\t   vma->gtt_view.remapped.plane[0].height,\n\t\t\t\t\t   vma->gtt_view.remapped.plane[0].src_stride,\n\t\t\t\t\t   vma->gtt_view.remapped.plane[0].dst_stride,\n\t\t\t\t\t   vma->gtt_view.remapped.plane[0].offset,\n\t\t\t\t\t   vma->gtt_view.remapped.plane[1].width,\n\t\t\t\t\t   vma->gtt_view.remapped.plane[1].height,\n\t\t\t\t\t   vma->gtt_view.remapped.plane[1].src_stride,\n\t\t\t\t\t   vma->gtt_view.remapped.plane[1].dst_stride,\n\t\t\t\t\t   vma->gtt_view.remapped.plane[1].offset);\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tMISSING_CASE(vma->gtt_view.type);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (vma->fence)\n\t\t\tseq_printf(m, \" , fence: %d\", vma->fence->id);\n\t\tseq_puts(m, \")\");\n\n\t\tspin_lock(&obj->vma.lock);\n\t}\n\tspin_unlock(&obj->vma.lock);\n\n\tseq_printf(m, \" (pinned x %d)\", pin_count);\n\tif (i915_gem_object_is_stolen(obj))\n\t\tseq_printf(m, \" (stolen: %08llx)\", obj->stolen->start);\n\tif (i915_gem_object_is_framebuffer(obj))\n\t\tseq_printf(m, \" (fb)\");\n}\n\nstatic int i915_gem_object_info(struct seq_file *m, void *data)\n{\n\tstruct drm_i915_private *i915 = node_to_i915(m->private);\n\tstruct drm_printer p = drm_seq_file_printer(m);\n\tstruct intel_memory_region *mr;\n\tenum intel_region_id id;\n\n\tseq_printf(m, \"%u shrinkable [%u free] objects, %llu bytes\\n\",\n\t\t   i915->mm.shrink_count,\n\t\t   atomic_read(&i915->mm.free_count),\n\t\t   i915->mm.shrink_memory);\n\tfor_each_memory_region(mr, i915, id)\n\t\tintel_memory_region_debug(mr, &p);\n\n\treturn 0;\n}\n\n#if IS_ENABLED(CONFIG_DRM_I915_CAPTURE_ERROR)\nstatic ssize_t gpu_state_read(struct file *file, char __user *ubuf,\n\t\t\t      size_t count, loff_t *pos)\n{\n\tstruct i915_gpu_coredump *error;\n\tssize_t ret;\n\tvoid *buf;\n\n\terror = file->private_data;\n\tif (!error)\n\t\treturn 0;\n\n\t \n\tbuf = kmalloc(count, GFP_KERNEL);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\tret = i915_gpu_coredump_copy_to_buffer(error, buf, *pos, count);\n\tif (ret <= 0)\n\t\tgoto out;\n\n\tif (!copy_to_user(ubuf, buf, ret))\n\t\t*pos += ret;\n\telse\n\t\tret = -EFAULT;\n\nout:\n\tkfree(buf);\n\treturn ret;\n}\n\nstatic int gpu_state_release(struct inode *inode, struct file *file)\n{\n\ti915_gpu_coredump_put(file->private_data);\n\treturn 0;\n}\n\nstatic int i915_gpu_info_open(struct inode *inode, struct file *file)\n{\n\tstruct drm_i915_private *i915 = inode->i_private;\n\tstruct i915_gpu_coredump *gpu;\n\tintel_wakeref_t wakeref;\n\n\tgpu = NULL;\n\twith_intel_runtime_pm(&i915->runtime_pm, wakeref)\n\t\tgpu = i915_gpu_coredump(to_gt(i915), ALL_ENGINES, CORE_DUMP_FLAG_NONE);\n\n\tif (IS_ERR(gpu))\n\t\treturn PTR_ERR(gpu);\n\n\tfile->private_data = gpu;\n\treturn 0;\n}\n\nstatic const struct file_operations i915_gpu_info_fops = {\n\t.owner = THIS_MODULE,\n\t.open = i915_gpu_info_open,\n\t.read = gpu_state_read,\n\t.llseek = default_llseek,\n\t.release = gpu_state_release,\n};\n\nstatic ssize_t\ni915_error_state_write(struct file *filp,\n\t\t       const char __user *ubuf,\n\t\t       size_t cnt,\n\t\t       loff_t *ppos)\n{\n\tstruct i915_gpu_coredump *error = filp->private_data;\n\n\tif (!error)\n\t\treturn 0;\n\n\tdrm_dbg(&error->i915->drm, \"Resetting error state\\n\");\n\ti915_reset_error_state(error->i915);\n\n\treturn cnt;\n}\n\nstatic int i915_error_state_open(struct inode *inode, struct file *file)\n{\n\tstruct i915_gpu_coredump *error;\n\n\terror = i915_first_error_state(inode->i_private);\n\tif (IS_ERR(error))\n\t\treturn PTR_ERR(error);\n\n\tfile->private_data  = error;\n\treturn 0;\n}\n\nstatic const struct file_operations i915_error_state_fops = {\n\t.owner = THIS_MODULE,\n\t.open = i915_error_state_open,\n\t.read = gpu_state_read,\n\t.write = i915_error_state_write,\n\t.llseek = default_llseek,\n\t.release = gpu_state_release,\n};\n#endif\n\nstatic int i915_frequency_info(struct seq_file *m, void *unused)\n{\n\tstruct drm_i915_private *i915 = node_to_i915(m->private);\n\tstruct intel_gt *gt = to_gt(i915);\n\tstruct drm_printer p = drm_seq_file_printer(m);\n\n\tintel_gt_pm_frequency_dump(gt, &p);\n\n\treturn 0;\n}\n\nstatic const char *swizzle_string(unsigned swizzle)\n{\n\tswitch (swizzle) {\n\tcase I915_BIT_6_SWIZZLE_NONE:\n\t\treturn \"none\";\n\tcase I915_BIT_6_SWIZZLE_9:\n\t\treturn \"bit9\";\n\tcase I915_BIT_6_SWIZZLE_9_10:\n\t\treturn \"bit9/bit10\";\n\tcase I915_BIT_6_SWIZZLE_9_11:\n\t\treturn \"bit9/bit11\";\n\tcase I915_BIT_6_SWIZZLE_9_10_11:\n\t\treturn \"bit9/bit10/bit11\";\n\tcase I915_BIT_6_SWIZZLE_9_17:\n\t\treturn \"bit9/bit17\";\n\tcase I915_BIT_6_SWIZZLE_9_10_17:\n\t\treturn \"bit9/bit10/bit17\";\n\tcase I915_BIT_6_SWIZZLE_UNKNOWN:\n\t\treturn \"unknown\";\n\t}\n\n\treturn \"bug\";\n}\n\nstatic int i915_swizzle_info(struct seq_file *m, void *data)\n{\n\tstruct drm_i915_private *dev_priv = node_to_i915(m->private);\n\tstruct intel_uncore *uncore = &dev_priv->uncore;\n\tintel_wakeref_t wakeref;\n\n\tseq_printf(m, \"bit6 swizzle for X-tiling = %s\\n\",\n\t\t   swizzle_string(to_gt(dev_priv)->ggtt->bit_6_swizzle_x));\n\tseq_printf(m, \"bit6 swizzle for Y-tiling = %s\\n\",\n\t\t   swizzle_string(to_gt(dev_priv)->ggtt->bit_6_swizzle_y));\n\n\tif (dev_priv->gem_quirks & GEM_QUIRK_PIN_SWIZZLED_PAGES)\n\t\tseq_puts(m, \"L-shaped memory detected\\n\");\n\n\t \n\tif (GRAPHICS_VER(dev_priv) >= 8 || IS_VALLEYVIEW(dev_priv))\n\t\treturn 0;\n\n\twakeref = intel_runtime_pm_get(&dev_priv->runtime_pm);\n\n\tif (IS_GRAPHICS_VER(dev_priv, 3, 4)) {\n\t\tseq_printf(m, \"DDC = 0x%08x\\n\",\n\t\t\t   intel_uncore_read(uncore, DCC));\n\t\tseq_printf(m, \"DDC2 = 0x%08x\\n\",\n\t\t\t   intel_uncore_read(uncore, DCC2));\n\t\tseq_printf(m, \"C0DRB3 = 0x%04x\\n\",\n\t\t\t   intel_uncore_read16(uncore, C0DRB3_BW));\n\t\tseq_printf(m, \"C1DRB3 = 0x%04x\\n\",\n\t\t\t   intel_uncore_read16(uncore, C1DRB3_BW));\n\t} else if (GRAPHICS_VER(dev_priv) >= 6) {\n\t\tseq_printf(m, \"MAD_DIMM_C0 = 0x%08x\\n\",\n\t\t\t   intel_uncore_read(uncore, MAD_DIMM_C0));\n\t\tseq_printf(m, \"MAD_DIMM_C1 = 0x%08x\\n\",\n\t\t\t   intel_uncore_read(uncore, MAD_DIMM_C1));\n\t\tseq_printf(m, \"MAD_DIMM_C2 = 0x%08x\\n\",\n\t\t\t   intel_uncore_read(uncore, MAD_DIMM_C2));\n\t\tseq_printf(m, \"TILECTL = 0x%08x\\n\",\n\t\t\t   intel_uncore_read(uncore, TILECTL));\n\t\tif (GRAPHICS_VER(dev_priv) >= 8)\n\t\t\tseq_printf(m, \"GAMTARBMODE = 0x%08x\\n\",\n\t\t\t\t   intel_uncore_read(uncore, GAMTARBMODE));\n\t\telse\n\t\t\tseq_printf(m, \"ARB_MODE = 0x%08x\\n\",\n\t\t\t\t   intel_uncore_read(uncore, ARB_MODE));\n\t\tseq_printf(m, \"DISP_ARB_CTL = 0x%08x\\n\",\n\t\t\t   intel_uncore_read(uncore, DISP_ARB_CTL));\n\t}\n\n\tintel_runtime_pm_put(&dev_priv->runtime_pm, wakeref);\n\n\treturn 0;\n}\n\nstatic int i915_rps_boost_info(struct seq_file *m, void *data)\n{\n\tstruct drm_i915_private *dev_priv = node_to_i915(m->private);\n\tstruct intel_rps *rps = &to_gt(dev_priv)->rps;\n\n\tseq_printf(m, \"RPS enabled? %s\\n\",\n\t\t   str_yes_no(intel_rps_is_enabled(rps)));\n\tseq_printf(m, \"RPS active? %s\\n\",\n\t\t   str_yes_no(intel_rps_is_active(rps)));\n\tseq_printf(m, \"GPU busy? %s\\n\", str_yes_no(to_gt(dev_priv)->awake));\n\tseq_printf(m, \"Boosts outstanding? %d\\n\",\n\t\t   atomic_read(&rps->num_waiters));\n\tseq_printf(m, \"Interactive? %d\\n\", READ_ONCE(rps->power.interactive));\n\tseq_printf(m, \"Frequency requested %d, actual %d\\n\",\n\t\t   intel_gpu_freq(rps, rps->cur_freq),\n\t\t   intel_rps_read_actual_frequency(rps));\n\tseq_printf(m, \"  min hard:%d, soft:%d; max soft:%d, hard:%d\\n\",\n\t\t   intel_gpu_freq(rps, rps->min_freq),\n\t\t   intel_gpu_freq(rps, rps->min_freq_softlimit),\n\t\t   intel_gpu_freq(rps, rps->max_freq_softlimit),\n\t\t   intel_gpu_freq(rps, rps->max_freq));\n\tseq_printf(m, \"  idle:%d, efficient:%d, boost:%d\\n\",\n\t\t   intel_gpu_freq(rps, rps->idle_freq),\n\t\t   intel_gpu_freq(rps, rps->efficient_freq),\n\t\t   intel_gpu_freq(rps, rps->boost_freq));\n\n\tseq_printf(m, \"Wait boosts: %d\\n\", READ_ONCE(rps->boosts));\n\n\treturn 0;\n}\n\nstatic int i915_runtime_pm_status(struct seq_file *m, void *unused)\n{\n\tstruct drm_i915_private *dev_priv = node_to_i915(m->private);\n\tstruct pci_dev *pdev = to_pci_dev(dev_priv->drm.dev);\n\n\tif (!HAS_RUNTIME_PM(dev_priv))\n\t\tseq_puts(m, \"Runtime power management not supported\\n\");\n\n\tseq_printf(m, \"Runtime power status: %s\\n\",\n\t\t   str_enabled_disabled(!dev_priv->display.power.domains.init_wakeref));\n\n\tseq_printf(m, \"GPU idle: %s\\n\", str_yes_no(!to_gt(dev_priv)->awake));\n\tseq_printf(m, \"IRQs disabled: %s\\n\",\n\t\t   str_yes_no(!intel_irqs_enabled(dev_priv)));\n#ifdef CONFIG_PM\n\tseq_printf(m, \"Usage count: %d\\n\",\n\t\t   atomic_read(&dev_priv->drm.dev->power.usage_count));\n#else\n\tseq_printf(m, \"Device Power Management (CONFIG_PM) disabled\\n\");\n#endif\n\tseq_printf(m, \"PCI device power state: %s [%d]\\n\",\n\t\t   pci_power_name(pdev->current_state),\n\t\t   pdev->current_state);\n\n\tif (IS_ENABLED(CONFIG_DRM_I915_DEBUG_RUNTIME_PM)) {\n\t\tstruct drm_printer p = drm_seq_file_printer(m);\n\n\t\tprint_intel_runtime_pm_wakeref(&dev_priv->runtime_pm, &p);\n\t}\n\n\treturn 0;\n}\n\nstatic int i915_engine_info(struct seq_file *m, void *unused)\n{\n\tstruct drm_i915_private *i915 = node_to_i915(m->private);\n\tstruct intel_engine_cs *engine;\n\tintel_wakeref_t wakeref;\n\tstruct drm_printer p;\n\n\twakeref = intel_runtime_pm_get(&i915->runtime_pm);\n\n\tseq_printf(m, \"GT awake? %s [%d], %llums\\n\",\n\t\t   str_yes_no(to_gt(i915)->awake),\n\t\t   atomic_read(&to_gt(i915)->wakeref.count),\n\t\t   ktime_to_ms(intel_gt_get_awake_time(to_gt(i915))));\n\tseq_printf(m, \"CS timestamp frequency: %u Hz, %d ns\\n\",\n\t\t   to_gt(i915)->clock_frequency,\n\t\t   to_gt(i915)->clock_period_ns);\n\n\tp = drm_seq_file_printer(m);\n\tfor_each_uabi_engine(engine, i915)\n\t\tintel_engine_dump(engine, &p, \"%s\\n\", engine->name);\n\n\tintel_gt_show_timelines(to_gt(i915), &p, i915_request_show_with_schedule);\n\n\tintel_runtime_pm_put(&i915->runtime_pm, wakeref);\n\n\treturn 0;\n}\n\nstatic int i915_wa_registers(struct seq_file *m, void *unused)\n{\n\tstruct drm_i915_private *i915 = node_to_i915(m->private);\n\tstruct intel_engine_cs *engine;\n\n\tfor_each_uabi_engine(engine, i915) {\n\t\tconst struct i915_wa_list *wal = &engine->ctx_wa_list;\n\t\tconst struct i915_wa *wa;\n\t\tunsigned int count;\n\n\t\tcount = wal->count;\n\t\tif (!count)\n\t\t\tcontinue;\n\n\t\tseq_printf(m, \"%s: Workarounds applied: %u\\n\",\n\t\t\t   engine->name, count);\n\n\t\tfor (wa = wal->list; count--; wa++)\n\t\t\tseq_printf(m, \"0x%X: 0x%08X, mask: 0x%08X\\n\",\n\t\t\t\t   i915_mmio_reg_offset(wa->reg),\n\t\t\t\t   wa->set, wa->clr);\n\n\t\tseq_printf(m, \"\\n\");\n\t}\n\n\treturn 0;\n}\n\nstatic int i915_wedged_get(void *data, u64 *val)\n{\n\tstruct drm_i915_private *i915 = data;\n\tstruct intel_gt *gt;\n\tunsigned int i;\n\n\t*val = 0;\n\n\tfor_each_gt(gt, i915, i) {\n\t\tint ret;\n\n\t\tret = intel_gt_debugfs_reset_show(gt, val);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\t \n\t\tif (*val)\n\t\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic int i915_wedged_set(void *data, u64 val)\n{\n\tstruct drm_i915_private *i915 = data;\n\tstruct intel_gt *gt;\n\tunsigned int i;\n\n\tfor_each_gt(gt, i915, i)\n\t\tintel_gt_debugfs_reset_store(gt, val);\n\n\treturn 0;\n}\n\nDEFINE_SIMPLE_ATTRIBUTE(i915_wedged_fops,\n\t\t\ti915_wedged_get, i915_wedged_set,\n\t\t\t\"%llu\\n\");\n\nstatic int\ni915_perf_noa_delay_set(void *data, u64 val)\n{\n\tstruct drm_i915_private *i915 = data;\n\n\t \n\tif (intel_gt_ns_to_clock_interval(to_gt(i915), val) > U32_MAX)\n\t\treturn -EINVAL;\n\n\tatomic64_set(&i915->perf.noa_programming_delay, val);\n\treturn 0;\n}\n\nstatic int\ni915_perf_noa_delay_get(void *data, u64 *val)\n{\n\tstruct drm_i915_private *i915 = data;\n\n\t*val = atomic64_read(&i915->perf.noa_programming_delay);\n\treturn 0;\n}\n\nDEFINE_SIMPLE_ATTRIBUTE(i915_perf_noa_delay_fops,\n\t\t\ti915_perf_noa_delay_get,\n\t\t\ti915_perf_noa_delay_set,\n\t\t\t\"%llu\\n\");\n\n#define DROP_UNBOUND\tBIT(0)\n#define DROP_BOUND\tBIT(1)\n#define DROP_RETIRE\tBIT(2)\n#define DROP_ACTIVE\tBIT(3)\n#define DROP_FREED\tBIT(4)\n#define DROP_SHRINK_ALL\tBIT(5)\n#define DROP_IDLE\tBIT(6)\n#define DROP_RESET_ACTIVE\tBIT(7)\n#define DROP_RESET_SEQNO\tBIT(8)\n#define DROP_RCU\tBIT(9)\n#define DROP_ALL (DROP_UNBOUND\t| \\\n\t\t  DROP_BOUND\t| \\\n\t\t  DROP_RETIRE\t| \\\n\t\t  DROP_ACTIVE\t| \\\n\t\t  DROP_FREED\t| \\\n\t\t  DROP_SHRINK_ALL |\\\n\t\t  DROP_IDLE\t| \\\n\t\t  DROP_RESET_ACTIVE | \\\n\t\t  DROP_RESET_SEQNO | \\\n\t\t  DROP_RCU)\nstatic int\ni915_drop_caches_get(void *data, u64 *val)\n{\n\t*val = DROP_ALL;\n\n\treturn 0;\n}\n\nstatic int\ngt_drop_caches(struct intel_gt *gt, u64 val)\n{\n\tint ret;\n\n\tif (val & DROP_RESET_ACTIVE &&\n\t    wait_for(intel_engines_are_idle(gt), 200))\n\t\tintel_gt_set_wedged(gt);\n\n\tif (val & DROP_RETIRE)\n\t\tintel_gt_retire_requests(gt);\n\n\tif (val & (DROP_IDLE | DROP_ACTIVE)) {\n\t\tret = intel_gt_wait_for_idle(gt, MAX_SCHEDULE_TIMEOUT);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tif (val & DROP_IDLE) {\n\t\tret = intel_gt_pm_wait_for_idle(gt);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tif (val & DROP_RESET_ACTIVE && intel_gt_terminally_wedged(gt))\n\t\tintel_gt_handle_error(gt, ALL_ENGINES, 0, NULL);\n\n\tif (val & DROP_FREED)\n\t\tintel_gt_flush_buffer_pool(gt);\n\n\treturn 0;\n}\n\nstatic int\ni915_drop_caches_set(void *data, u64 val)\n{\n\tstruct drm_i915_private *i915 = data;\n\tunsigned int flags;\n\tint ret;\n\n\tdrm_dbg(&i915->drm, \"Dropping caches: 0x%08llx [0x%08llx]\\n\",\n\t\tval, val & DROP_ALL);\n\n\tret = gt_drop_caches(to_gt(i915), val);\n\tif (ret)\n\t\treturn ret;\n\n\tfs_reclaim_acquire(GFP_KERNEL);\n\tflags = memalloc_noreclaim_save();\n\tif (val & DROP_BOUND)\n\t\ti915_gem_shrink(NULL, i915, LONG_MAX, NULL, I915_SHRINK_BOUND);\n\n\tif (val & DROP_UNBOUND)\n\t\ti915_gem_shrink(NULL, i915, LONG_MAX, NULL, I915_SHRINK_UNBOUND);\n\n\tif (val & DROP_SHRINK_ALL)\n\t\ti915_gem_shrink_all(i915);\n\tmemalloc_noreclaim_restore(flags);\n\tfs_reclaim_release(GFP_KERNEL);\n\n\tif (val & DROP_RCU)\n\t\trcu_barrier();\n\n\tif (val & DROP_FREED)\n\t\ti915_gem_drain_freed_objects(i915);\n\n\treturn 0;\n}\n\nDEFINE_SIMPLE_ATTRIBUTE(i915_drop_caches_fops,\n\t\t\ti915_drop_caches_get, i915_drop_caches_set,\n\t\t\t\"0x%08llx\\n\");\n\nstatic int i915_sseu_status(struct seq_file *m, void *unused)\n{\n\tstruct drm_i915_private *i915 = node_to_i915(m->private);\n\tstruct intel_gt *gt = to_gt(i915);\n\n\treturn intel_sseu_status(m, gt);\n}\n\nstatic int i915_forcewake_open(struct inode *inode, struct file *file)\n{\n\tstruct drm_i915_private *i915 = inode->i_private;\n\tstruct intel_gt *gt;\n\tunsigned int i;\n\n\tfor_each_gt(gt, i915, i)\n\t\tintel_gt_pm_debugfs_forcewake_user_open(gt);\n\n\treturn 0;\n}\n\nstatic int i915_forcewake_release(struct inode *inode, struct file *file)\n{\n\tstruct drm_i915_private *i915 = inode->i_private;\n\tstruct intel_gt *gt;\n\tunsigned int i;\n\n\tfor_each_gt(gt, i915, i)\n\t\tintel_gt_pm_debugfs_forcewake_user_release(gt);\n\n\treturn 0;\n}\n\nstatic const struct file_operations i915_forcewake_fops = {\n\t.owner = THIS_MODULE,\n\t.open = i915_forcewake_open,\n\t.release = i915_forcewake_release,\n};\n\nstatic const struct drm_info_list i915_debugfs_list[] = {\n\t{\"i915_capabilities\", i915_capabilities, 0},\n\t{\"i915_gem_objects\", i915_gem_object_info, 0},\n\t{\"i915_frequency_info\", i915_frequency_info, 0},\n\t{\"i915_swizzle_info\", i915_swizzle_info, 0},\n\t{\"i915_runtime_pm_status\", i915_runtime_pm_status, 0},\n\t{\"i915_engine_info\", i915_engine_info, 0},\n\t{\"i915_wa_registers\", i915_wa_registers, 0},\n\t{\"i915_sseu_status\", i915_sseu_status, 0},\n\t{\"i915_rps_boost_info\", i915_rps_boost_info, 0},\n};\n\nstatic const struct i915_debugfs_files {\n\tconst char *name;\n\tconst struct file_operations *fops;\n} i915_debugfs_files[] = {\n\t{\"i915_perf_noa_delay\", &i915_perf_noa_delay_fops},\n\t{\"i915_wedged\", &i915_wedged_fops},\n\t{\"i915_gem_drop_caches\", &i915_drop_caches_fops},\n#if IS_ENABLED(CONFIG_DRM_I915_CAPTURE_ERROR)\n\t{\"i915_error_state\", &i915_error_state_fops},\n\t{\"i915_gpu_info\", &i915_gpu_info_fops},\n#endif\n};\n\nvoid i915_debugfs_register(struct drm_i915_private *dev_priv)\n{\n\tstruct drm_minor *minor = dev_priv->drm.primary;\n\tint i;\n\n\ti915_debugfs_params(dev_priv);\n\n\tdebugfs_create_file(\"i915_forcewake_user\", S_IRUSR, minor->debugfs_root,\n\t\t\t    to_i915(minor->dev), &i915_forcewake_fops);\n\tfor (i = 0; i < ARRAY_SIZE(i915_debugfs_files); i++) {\n\t\tdebugfs_create_file(i915_debugfs_files[i].name,\n\t\t\t\t    S_IRUGO | S_IWUSR,\n\t\t\t\t    minor->debugfs_root,\n\t\t\t\t    to_i915(minor->dev),\n\t\t\t\t    i915_debugfs_files[i].fops);\n\t}\n\n\tdrm_debugfs_create_files(i915_debugfs_list,\n\t\t\t\t ARRAY_SIZE(i915_debugfs_list),\n\t\t\t\t minor->debugfs_root, minor);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}