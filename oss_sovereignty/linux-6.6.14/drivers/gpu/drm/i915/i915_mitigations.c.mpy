{
  "module_name": "i915_mitigations.c",
  "hash_id": "e8776efc211ddcd781840b08a018359644757db5b22d11868a78c1e631c4845b",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/i915/i915_mitigations.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/moduleparam.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n\n#include \"i915_driver.h\"\n#include \"i915_drv.h\"\n#include \"i915_mitigations.h\"\n\nstatic unsigned long mitigations __read_mostly = ~0UL;\n\nenum {\n\tCLEAR_RESIDUALS = 0,\n};\n\nstatic const char * const names[] = {\n\t[CLEAR_RESIDUALS] = \"residuals\",\n};\n\nbool i915_mitigate_clear_residuals(void)\n{\n\treturn READ_ONCE(mitigations) & BIT(CLEAR_RESIDUALS);\n}\n\nstatic int mitigations_set(const char *val, const struct kernel_param *kp)\n{\n\tunsigned long new = ~0UL;\n\tchar *str, *sep, *tok;\n\tbool first = true;\n\tint err = 0;\n\n\tBUILD_BUG_ON(ARRAY_SIZE(names) >= BITS_PER_TYPE(mitigations));\n\n\tstr = kstrdup(val, GFP_KERNEL);\n\tif (!str)\n\t\treturn -ENOMEM;\n\n\tfor (sep = str; (tok = strsep(&sep, \",\"));) {\n\t\tbool enable = true;\n\t\tint i;\n\n\t\t \n\t\ttok = strim(tok);\n\n\t\tif (first) {\n\t\t\tfirst = false;\n\n\t\t\tif (!strcmp(tok, \"auto\"))\n\t\t\t\tcontinue;\n\n\t\t\tnew = 0;\n\t\t\tif (!strcmp(tok, \"off\"))\n\t\t\t\tcontinue;\n\t\t}\n\n\t\tif (*tok == '!') {\n\t\t\tenable = !enable;\n\t\t\ttok++;\n\t\t}\n\n\t\tif (!strncmp(tok, \"no\", 2)) {\n\t\t\tenable = !enable;\n\t\t\ttok += 2;\n\t\t}\n\n\t\tif (*tok == '\\0')\n\t\t\tcontinue;\n\n\t\tfor (i = 0; i < ARRAY_SIZE(names); i++) {\n\t\t\tif (!strcmp(tok, names[i])) {\n\t\t\t\tif (enable)\n\t\t\t\t\tnew |= BIT(i);\n\t\t\t\telse\n\t\t\t\t\tnew &= ~BIT(i);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (i == ARRAY_SIZE(names)) {\n\t\t\tpr_err(\"Bad \\\"%s.mitigations=%s\\\", '%s' is unknown\\n\",\n\t\t\t       DRIVER_NAME, val, tok);\n\t\t\terr = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\t}\n\tkfree(str);\n\tif (err)\n\t\treturn err;\n\n\tWRITE_ONCE(mitigations, new);\n\treturn 0;\n}\n\nstatic int mitigations_get(char *buffer, const struct kernel_param *kp)\n{\n\tunsigned long local = READ_ONCE(mitigations);\n\tint count, i;\n\tbool enable;\n\n\tif (!local)\n\t\treturn scnprintf(buffer, PAGE_SIZE, \"%s\\n\", \"off\");\n\n\tif (local & BIT(BITS_PER_LONG - 1)) {\n\t\tcount = scnprintf(buffer, PAGE_SIZE, \"%s,\", \"auto\");\n\t\tenable = false;\n\t} else {\n\t\tenable = true;\n\t\tcount = 0;\n\t}\n\n\tfor (i = 0; i < ARRAY_SIZE(names); i++) {\n\t\tif ((local & BIT(i)) != enable)\n\t\t\tcontinue;\n\n\t\tcount += scnprintf(buffer + count, PAGE_SIZE - count,\n\t\t\t\t   \"%s%s,\", enable ? \"\" : \"!\", names[i]);\n\t}\n\n\tbuffer[count - 1] = '\\n';\n\treturn count;\n}\n\nstatic const struct kernel_param_ops ops = {\n\t.set = mitigations_set,\n\t.get = mitigations_get,\n};\n\nmodule_param_cb_unsafe(mitigations, &ops, NULL, 0600);\nMODULE_PARM_DESC(mitigations,\n\"Selectively enable security mitigations for all Intel\u00ae GPUs in the system.\\n\"\n\"\\n\"\n\"  auto -- enables all mitigations required for the platform [default]\\n\"\n\"  off  -- disables all mitigations\\n\"\n\"\\n\"\n\"Individual mitigations can be enabled by passing a comma-separated string,\\n\"\n\"e.g. mitigations=residuals to enable only clearing residuals or\\n\"\n\"mitigations=auto,noresiduals to disable only the clear residual mitigation.\\n\"\n\"Either '!' or 'no' may be used to switch from enabling the mitigation to\\n\"\n\"disabling it.\\n\"\n\"\\n\"\n\"Active mitigations for Ivybridge, Baytrail, Haswell:\\n\"\n\"  residuals -- clear all thread-local registers between contexts\"\n);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}