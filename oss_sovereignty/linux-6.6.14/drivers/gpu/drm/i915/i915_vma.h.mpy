{
  "module_name": "i915_vma.h",
  "hash_id": "e2a0f4b6338b4c14413d9759a490a24f69a8a01223677506f7ace3d7941addaf",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/i915/i915_vma.h",
  "human_readable_source": " \n\n#ifndef __I915_VMA_H__\n#define __I915_VMA_H__\n\n#include <linux/io-mapping.h>\n#include <linux/rbtree.h>\n\n#include <drm/drm_mm.h>\n\n#include \"gt/intel_ggtt_fencing.h\"\n#include \"gem/i915_gem_object.h\"\n\n#include \"i915_gem_gtt.h\"\n\n#include \"i915_active.h\"\n#include \"i915_request.h\"\n#include \"i915_vma_resource.h\"\n#include \"i915_vma_types.h\"\n\nstruct i915_vma *\ni915_vma_instance(struct drm_i915_gem_object *obj,\n\t\t  struct i915_address_space *vm,\n\t\t  const struct i915_gtt_view *view);\n\nvoid i915_vma_unpin_and_release(struct i915_vma **p_vma, unsigned int flags);\n#define I915_VMA_RELEASE_MAP BIT(0)\n\nstatic inline bool i915_vma_is_active(const struct i915_vma *vma)\n{\n\treturn !i915_active_is_idle(&vma->active);\n}\n\n \n#define __EXEC_OBJECT_NO_RESERVE BIT(31)\n#define __EXEC_OBJECT_NO_REQUEST_AWAIT BIT(30)\n\nint __must_check _i915_vma_move_to_active(struct i915_vma *vma,\n\t\t\t\t\t  struct i915_request *rq,\n\t\t\t\t\t  struct dma_fence *fence,\n\t\t\t\t\t  unsigned int flags);\nstatic inline int __must_check\ni915_vma_move_to_active(struct i915_vma *vma, struct i915_request *rq,\n\t\t\tunsigned int flags)\n{\n\treturn _i915_vma_move_to_active(vma, rq, &rq->fence, flags);\n}\n\n#define __i915_vma_flags(v) ((unsigned long *)&(v)->flags.counter)\n\nstatic inline bool i915_vma_is_ggtt(const struct i915_vma *vma)\n{\n\treturn test_bit(I915_VMA_GGTT_BIT, __i915_vma_flags(vma));\n}\n\nstatic inline bool i915_vma_is_dpt(const struct i915_vma *vma)\n{\n\treturn i915_is_dpt(vma->vm);\n}\n\nstatic inline bool i915_vma_has_ggtt_write(const struct i915_vma *vma)\n{\n\treturn test_bit(I915_VMA_GGTT_WRITE_BIT, __i915_vma_flags(vma));\n}\n\nstatic inline void i915_vma_set_ggtt_write(struct i915_vma *vma)\n{\n\tGEM_BUG_ON(!i915_vma_is_ggtt(vma));\n\tset_bit(I915_VMA_GGTT_WRITE_BIT, __i915_vma_flags(vma));\n}\n\nstatic inline bool i915_vma_unset_ggtt_write(struct i915_vma *vma)\n{\n\treturn test_and_clear_bit(I915_VMA_GGTT_WRITE_BIT,\n\t\t\t\t  __i915_vma_flags(vma));\n}\n\nvoid i915_vma_flush_writes(struct i915_vma *vma);\n\nstatic inline bool i915_vma_is_map_and_fenceable(const struct i915_vma *vma)\n{\n\treturn test_bit(I915_VMA_CAN_FENCE_BIT, __i915_vma_flags(vma));\n}\n\nstatic inline bool i915_vma_set_userfault(struct i915_vma *vma)\n{\n\tGEM_BUG_ON(!i915_vma_is_map_and_fenceable(vma));\n\treturn test_and_set_bit(I915_VMA_USERFAULT_BIT, __i915_vma_flags(vma));\n}\n\nstatic inline void i915_vma_unset_userfault(struct i915_vma *vma)\n{\n\treturn clear_bit(I915_VMA_USERFAULT_BIT, __i915_vma_flags(vma));\n}\n\nstatic inline bool i915_vma_has_userfault(const struct i915_vma *vma)\n{\n\treturn test_bit(I915_VMA_USERFAULT_BIT, __i915_vma_flags(vma));\n}\n\nstatic inline bool i915_vma_is_closed(const struct i915_vma *vma)\n{\n\treturn !list_empty(&vma->closed_link);\n}\n\n \nstatic inline u64 __i915_vma_size(const struct i915_vma *vma)\n{\n\treturn vma->node.size - 2 * vma->guard;\n}\n\n \nstatic inline u64 i915_vma_size(const struct i915_vma *vma)\n{\n\tGEM_BUG_ON(!drm_mm_node_allocated(&vma->node));\n\treturn __i915_vma_size(vma);\n}\n\n \nstatic inline u64 __i915_vma_offset(const struct i915_vma *vma)\n{\n\t \n\treturn vma->node.start + vma->guard;\n}\n\n \nstatic inline u64 i915_vma_offset(const struct i915_vma *vma)\n{\n\tGEM_BUG_ON(!drm_mm_node_allocated(&vma->node));\n\treturn __i915_vma_offset(vma);\n}\n\nstatic inline u32 i915_ggtt_offset(const struct i915_vma *vma)\n{\n\tGEM_BUG_ON(!i915_vma_is_ggtt(vma));\n\tGEM_BUG_ON(!drm_mm_node_allocated(&vma->node));\n\tGEM_BUG_ON(upper_32_bits(i915_vma_offset(vma)));\n\tGEM_BUG_ON(upper_32_bits(i915_vma_offset(vma) +\n\t\t\t\t i915_vma_size(vma) - 1));\n\treturn lower_32_bits(i915_vma_offset(vma));\n}\n\nstatic inline u32 i915_ggtt_pin_bias(struct i915_vma *vma)\n{\n\treturn i915_vm_to_ggtt(vma->vm)->pin_bias;\n}\n\nstatic inline struct i915_vma *i915_vma_get(struct i915_vma *vma)\n{\n\ti915_gem_object_get(vma->obj);\n\treturn vma;\n}\n\nstatic inline struct i915_vma *i915_vma_tryget(struct i915_vma *vma)\n{\n\tif (likely(kref_get_unless_zero(&vma->obj->base.refcount)))\n\t\treturn vma;\n\n\treturn NULL;\n}\n\nstatic inline void i915_vma_put(struct i915_vma *vma)\n{\n\ti915_gem_object_put(vma->obj);\n}\n\nstatic inline long\ni915_vma_compare(struct i915_vma *vma,\n\t\t struct i915_address_space *vm,\n\t\t const struct i915_gtt_view *view)\n{\n\tptrdiff_t cmp;\n\n\tGEM_BUG_ON(view && !i915_is_ggtt_or_dpt(vm));\n\n\tcmp = ptrdiff(vma->vm, vm);\n\tif (cmp)\n\t\treturn cmp;\n\n\tBUILD_BUG_ON(I915_GTT_VIEW_NORMAL != 0);\n\tcmp = vma->gtt_view.type;\n\tif (!view)\n\t\treturn cmp;\n\n\tcmp -= view->type;\n\tif (cmp)\n\t\treturn cmp;\n\n\tassert_i915_gem_gtt_types();\n\n\t \n\tBUILD_BUG_ON(I915_GTT_VIEW_NORMAL >= I915_GTT_VIEW_PARTIAL);\n\tBUILD_BUG_ON(I915_GTT_VIEW_PARTIAL >= I915_GTT_VIEW_ROTATED);\n\tBUILD_BUG_ON(I915_GTT_VIEW_ROTATED >= I915_GTT_VIEW_REMAPPED);\n\tBUILD_BUG_ON(offsetof(typeof(*view), rotated) !=\n\t\t     offsetof(typeof(*view), partial));\n\tBUILD_BUG_ON(offsetof(typeof(*view), rotated) !=\n\t\t     offsetof(typeof(*view), remapped));\n\treturn memcmp(&vma->gtt_view.partial, &view->partial, view->type);\n}\n\nstruct i915_vma_work *i915_vma_work(void);\nint i915_vma_bind(struct i915_vma *vma,\n\t\t  unsigned int pat_index,\n\t\t  u32 flags,\n\t\t  struct i915_vma_work *work,\n\t\t  struct i915_vma_resource *vma_res);\n\nbool i915_gem_valid_gtt_space(struct i915_vma *vma, unsigned long color);\nbool i915_vma_misplaced(const struct i915_vma *vma,\n\t\t\tu64 size, u64 alignment, u64 flags);\nvoid __i915_vma_set_map_and_fenceable(struct i915_vma *vma);\nvoid i915_vma_revoke_mmap(struct i915_vma *vma);\nvoid vma_invalidate_tlb(struct i915_address_space *vm, u32 *tlb);\nstruct dma_fence *__i915_vma_evict(struct i915_vma *vma, bool async);\nint __i915_vma_unbind(struct i915_vma *vma);\nint __must_check i915_vma_unbind(struct i915_vma *vma);\nint __must_check i915_vma_unbind_async(struct i915_vma *vma, bool trylock_vm);\nint __must_check i915_vma_unbind_unlocked(struct i915_vma *vma);\nvoid i915_vma_unlink_ctx(struct i915_vma *vma);\nvoid i915_vma_close(struct i915_vma *vma);\nvoid i915_vma_reopen(struct i915_vma *vma);\n\nvoid i915_vma_destroy_locked(struct i915_vma *vma);\nvoid i915_vma_destroy(struct i915_vma *vma);\n\n#define assert_vma_held(vma) dma_resv_assert_held((vma)->obj->base.resv)\n\nstatic inline void i915_vma_lock(struct i915_vma *vma)\n{\n\tdma_resv_lock(vma->obj->base.resv, NULL);\n}\n\nstatic inline void i915_vma_unlock(struct i915_vma *vma)\n{\n\tdma_resv_unlock(vma->obj->base.resv);\n}\n\nint __must_check\ni915_vma_pin_ww(struct i915_vma *vma, struct i915_gem_ww_ctx *ww,\n\t\tu64 size, u64 alignment, u64 flags);\n\nstatic inline int __must_check\ni915_vma_pin(struct i915_vma *vma, u64 size, u64 alignment, u64 flags)\n{\n\tstruct i915_gem_ww_ctx ww;\n\tint err;\n\n\ti915_gem_ww_ctx_init(&ww, true);\nretry:\n\terr = i915_gem_object_lock(vma->obj, &ww);\n\tif (!err)\n\t\terr = i915_vma_pin_ww(vma, &ww, size, alignment, flags);\n\tif (err == -EDEADLK) {\n\t\terr = i915_gem_ww_ctx_backoff(&ww);\n\t\tif (!err)\n\t\t\tgoto retry;\n\t}\n\ti915_gem_ww_ctx_fini(&ww);\n\n\treturn err;\n}\n\nint i915_ggtt_pin(struct i915_vma *vma, struct i915_gem_ww_ctx *ww,\n\t\t  u32 align, unsigned int flags);\n\nstatic inline int i915_vma_pin_count(const struct i915_vma *vma)\n{\n\treturn atomic_read(&vma->flags) & I915_VMA_PIN_MASK;\n}\n\nstatic inline bool i915_vma_is_pinned(const struct i915_vma *vma)\n{\n\treturn i915_vma_pin_count(vma);\n}\n\nstatic inline void __i915_vma_pin(struct i915_vma *vma)\n{\n\tatomic_inc(&vma->flags);\n\tGEM_BUG_ON(!i915_vma_is_pinned(vma));\n}\n\nstatic inline void __i915_vma_unpin(struct i915_vma *vma)\n{\n\tGEM_BUG_ON(!i915_vma_is_pinned(vma));\n\tatomic_dec(&vma->flags);\n}\n\nstatic inline void i915_vma_unpin(struct i915_vma *vma)\n{\n\tGEM_BUG_ON(!drm_mm_node_allocated(&vma->node));\n\t__i915_vma_unpin(vma);\n}\n\nstatic inline bool i915_vma_is_bound(const struct i915_vma *vma,\n\t\t\t\t     unsigned int where)\n{\n\treturn atomic_read(&vma->flags) & where;\n}\n\nstatic inline bool i915_node_color_differs(const struct drm_mm_node *node,\n\t\t\t\t\t   unsigned long color)\n{\n\treturn drm_mm_node_allocated(node) && node->color != color;\n}\n\n \nvoid __iomem *i915_vma_pin_iomap(struct i915_vma *vma);\n\n \nvoid i915_vma_unpin_iomap(struct i915_vma *vma);\n\n \nint __must_check i915_vma_pin_fence(struct i915_vma *vma);\nvoid i915_vma_revoke_fence(struct i915_vma *vma);\n\nint __i915_vma_pin_fence(struct i915_vma *vma);\n\nstatic inline void __i915_vma_unpin_fence(struct i915_vma *vma)\n{\n\tGEM_BUG_ON(atomic_read(&vma->fence->pin_count) <= 0);\n\tatomic_dec(&vma->fence->pin_count);\n}\n\n \nstatic inline void\ni915_vma_unpin_fence(struct i915_vma *vma)\n{\n\tif (vma->fence)\n\t\t__i915_vma_unpin_fence(vma);\n}\n\nstatic inline int i915_vma_fence_id(const struct i915_vma *vma)\n{\n\treturn vma->fence ? vma->fence->id : -1;\n}\n\nvoid i915_vma_parked(struct intel_gt *gt);\n\nstatic inline bool i915_vma_is_scanout(const struct i915_vma *vma)\n{\n\treturn test_bit(I915_VMA_SCANOUT_BIT, __i915_vma_flags(vma));\n}\n\nstatic inline void i915_vma_mark_scanout(struct i915_vma *vma)\n{\n\tset_bit(I915_VMA_SCANOUT_BIT, __i915_vma_flags(vma));\n}\n\nstatic inline void i915_vma_clear_scanout(struct i915_vma *vma)\n{\n\tclear_bit(I915_VMA_SCANOUT_BIT, __i915_vma_flags(vma));\n}\n\nvoid i915_ggtt_clear_scanout(struct drm_i915_gem_object *obj);\n\n#define for_each_until(cond) if (cond) break; else\n\n \n#define for_each_ggtt_vma(V, OBJ) \\\n\tlist_for_each_entry(V, &(OBJ)->vma.list, obj_link)\t\t\\\n\t\tfor_each_until(!i915_vma_is_ggtt(V))\n\nstruct i915_vma *i915_vma_make_unshrinkable(struct i915_vma *vma);\nvoid i915_vma_make_shrinkable(struct i915_vma *vma);\nvoid i915_vma_make_purgeable(struct i915_vma *vma);\n\nint i915_vma_wait_for_bind(struct i915_vma *vma);\n\nstatic inline int i915_vma_sync(struct i915_vma *vma)\n{\n\t \n\treturn i915_active_wait(&vma->active);\n}\n\n \nstatic inline struct i915_vma_resource *\ni915_vma_get_current_resource(struct i915_vma *vma)\n{\n\treturn i915_vma_resource_get(vma->resource);\n}\n\n#if IS_ENABLED(CONFIG_DRM_I915_SELFTEST)\nvoid i915_vma_resource_init_from_vma(struct i915_vma_resource *vma_res,\n\t\t\t\t     struct i915_vma *vma);\n#endif\n\nvoid i915_vma_module_exit(void);\nint i915_vma_module_init(void);\n\nI915_SELFTEST_DECLARE(int i915_vma_get_pages(struct i915_vma *vma));\nI915_SELFTEST_DECLARE(void i915_vma_put_pages(struct i915_vma *vma));\n\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}