{
  "module_name": "intel_device_info.c",
  "hash_id": "bf799bd28a868deeee31485913df8157dc7f6e692e6156214de7b718aa57d1b1",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/i915/intel_device_info.c",
  "human_readable_source": " \n\n#include <linux/string_helpers.h>\n\n#include <drm/drm_print.h>\n#include <drm/i915_pciids.h>\n\n#include \"display/intel_display_device.h\"\n#include \"gt/intel_gt_regs.h\"\n#include \"i915_drv.h\"\n#include \"i915_reg.h\"\n#include \"i915_utils.h\"\n#include \"intel_device_info.h\"\n\n#define PLATFORM_NAME(x) [INTEL_##x] = #x\nstatic const char * const platform_names[] = {\n\tPLATFORM_NAME(I830),\n\tPLATFORM_NAME(I845G),\n\tPLATFORM_NAME(I85X),\n\tPLATFORM_NAME(I865G),\n\tPLATFORM_NAME(I915G),\n\tPLATFORM_NAME(I915GM),\n\tPLATFORM_NAME(I945G),\n\tPLATFORM_NAME(I945GM),\n\tPLATFORM_NAME(G33),\n\tPLATFORM_NAME(PINEVIEW),\n\tPLATFORM_NAME(I965G),\n\tPLATFORM_NAME(I965GM),\n\tPLATFORM_NAME(G45),\n\tPLATFORM_NAME(GM45),\n\tPLATFORM_NAME(IRONLAKE),\n\tPLATFORM_NAME(SANDYBRIDGE),\n\tPLATFORM_NAME(IVYBRIDGE),\n\tPLATFORM_NAME(VALLEYVIEW),\n\tPLATFORM_NAME(HASWELL),\n\tPLATFORM_NAME(BROADWELL),\n\tPLATFORM_NAME(CHERRYVIEW),\n\tPLATFORM_NAME(SKYLAKE),\n\tPLATFORM_NAME(BROXTON),\n\tPLATFORM_NAME(KABYLAKE),\n\tPLATFORM_NAME(GEMINILAKE),\n\tPLATFORM_NAME(COFFEELAKE),\n\tPLATFORM_NAME(COMETLAKE),\n\tPLATFORM_NAME(ICELAKE),\n\tPLATFORM_NAME(ELKHARTLAKE),\n\tPLATFORM_NAME(JASPERLAKE),\n\tPLATFORM_NAME(TIGERLAKE),\n\tPLATFORM_NAME(ROCKETLAKE),\n\tPLATFORM_NAME(DG1),\n\tPLATFORM_NAME(ALDERLAKE_S),\n\tPLATFORM_NAME(ALDERLAKE_P),\n\tPLATFORM_NAME(XEHPSDV),\n\tPLATFORM_NAME(DG2),\n\tPLATFORM_NAME(PONTEVECCHIO),\n\tPLATFORM_NAME(METEORLAKE),\n};\n#undef PLATFORM_NAME\n\nconst char *intel_platform_name(enum intel_platform platform)\n{\n\tBUILD_BUG_ON(ARRAY_SIZE(platform_names) != INTEL_MAX_PLATFORMS);\n\n\tif (WARN_ON_ONCE(platform >= ARRAY_SIZE(platform_names) ||\n\t\t\t platform_names[platform] == NULL))\n\t\treturn \"<unknown>\";\n\n\treturn platform_names[platform];\n}\n\nvoid intel_device_info_print(const struct intel_device_info *info,\n\t\t\t     const struct intel_runtime_info *runtime,\n\t\t\t     struct drm_printer *p)\n{\n\tif (runtime->graphics.ip.rel)\n\t\tdrm_printf(p, \"graphics version: %u.%02u\\n\",\n\t\t\t   runtime->graphics.ip.ver,\n\t\t\t   runtime->graphics.ip.rel);\n\telse\n\t\tdrm_printf(p, \"graphics version: %u\\n\",\n\t\t\t   runtime->graphics.ip.ver);\n\n\tif (runtime->media.ip.rel)\n\t\tdrm_printf(p, \"media version: %u.%02u\\n\",\n\t\t\t   runtime->media.ip.ver,\n\t\t\t   runtime->media.ip.rel);\n\telse\n\t\tdrm_printf(p, \"media version: %u\\n\",\n\t\t\t   runtime->media.ip.ver);\n\n\tdrm_printf(p, \"graphics stepping: %s\\n\", intel_step_name(runtime->step.graphics_step));\n\tdrm_printf(p, \"media stepping: %s\\n\", intel_step_name(runtime->step.media_step));\n\tdrm_printf(p, \"display stepping: %s\\n\", intel_step_name(runtime->step.display_step));\n\tdrm_printf(p, \"base die stepping: %s\\n\", intel_step_name(runtime->step.basedie_step));\n\n\tdrm_printf(p, \"gt: %d\\n\", info->gt);\n\tdrm_printf(p, \"memory-regions: 0x%x\\n\", info->memory_regions);\n\tdrm_printf(p, \"page-sizes: 0x%x\\n\", runtime->page_sizes);\n\tdrm_printf(p, \"platform: %s\\n\", intel_platform_name(info->platform));\n\tdrm_printf(p, \"ppgtt-size: %d\\n\", runtime->ppgtt_size);\n\tdrm_printf(p, \"ppgtt-type: %d\\n\", runtime->ppgtt_type);\n\tdrm_printf(p, \"dma_mask_size: %u\\n\", info->dma_mask_size);\n\n#define PRINT_FLAG(name) drm_printf(p, \"%s: %s\\n\", #name, str_yes_no(info->name))\n\tDEV_INFO_FOR_EACH_FLAG(PRINT_FLAG);\n#undef PRINT_FLAG\n\n\tdrm_printf(p, \"has_pooled_eu: %s\\n\", str_yes_no(runtime->has_pooled_eu));\n\tdrm_printf(p, \"rawclk rate: %u kHz\\n\", runtime->rawclk_freq);\n}\n\n#undef INTEL_VGA_DEVICE\n#define INTEL_VGA_DEVICE(id, info) (id)\n\nstatic const u16 subplatform_ult_ids[] = {\n\tINTEL_HSW_ULT_GT1_IDS(0),\n\tINTEL_HSW_ULT_GT2_IDS(0),\n\tINTEL_HSW_ULT_GT3_IDS(0),\n\tINTEL_BDW_ULT_GT1_IDS(0),\n\tINTEL_BDW_ULT_GT2_IDS(0),\n\tINTEL_BDW_ULT_GT3_IDS(0),\n\tINTEL_BDW_ULT_RSVD_IDS(0),\n\tINTEL_SKL_ULT_GT1_IDS(0),\n\tINTEL_SKL_ULT_GT2_IDS(0),\n\tINTEL_SKL_ULT_GT3_IDS(0),\n\tINTEL_KBL_ULT_GT1_IDS(0),\n\tINTEL_KBL_ULT_GT2_IDS(0),\n\tINTEL_KBL_ULT_GT3_IDS(0),\n\tINTEL_CFL_U_GT2_IDS(0),\n\tINTEL_CFL_U_GT3_IDS(0),\n\tINTEL_WHL_U_GT1_IDS(0),\n\tINTEL_WHL_U_GT2_IDS(0),\n\tINTEL_WHL_U_GT3_IDS(0),\n\tINTEL_CML_U_GT1_IDS(0),\n\tINTEL_CML_U_GT2_IDS(0),\n};\n\nstatic const u16 subplatform_ulx_ids[] = {\n\tINTEL_HSW_ULX_GT1_IDS(0),\n\tINTEL_HSW_ULX_GT2_IDS(0),\n\tINTEL_BDW_ULX_GT1_IDS(0),\n\tINTEL_BDW_ULX_GT2_IDS(0),\n\tINTEL_BDW_ULX_GT3_IDS(0),\n\tINTEL_BDW_ULX_RSVD_IDS(0),\n\tINTEL_SKL_ULX_GT1_IDS(0),\n\tINTEL_SKL_ULX_GT2_IDS(0),\n\tINTEL_KBL_ULX_GT1_IDS(0),\n\tINTEL_KBL_ULX_GT2_IDS(0),\n\tINTEL_AML_KBL_GT2_IDS(0),\n\tINTEL_AML_CFL_GT2_IDS(0),\n};\n\nstatic const u16 subplatform_portf_ids[] = {\n\tINTEL_ICL_PORT_F_IDS(0),\n};\n\nstatic const u16 subplatform_uy_ids[] = {\n\tINTEL_TGL_12_GT2_IDS(0),\n};\n\nstatic const u16 subplatform_n_ids[] = {\n\tINTEL_ADLN_IDS(0),\n};\n\nstatic const u16 subplatform_rpl_ids[] = {\n\tINTEL_RPLS_IDS(0),\n\tINTEL_RPLP_IDS(0),\n};\n\nstatic const u16 subplatform_rplu_ids[] = {\n\tINTEL_RPLU_IDS(0),\n};\n\nstatic const u16 subplatform_g10_ids[] = {\n\tINTEL_DG2_G10_IDS(0),\n\tINTEL_ATS_M150_IDS(0),\n};\n\nstatic const u16 subplatform_g11_ids[] = {\n\tINTEL_DG2_G11_IDS(0),\n\tINTEL_ATS_M75_IDS(0),\n};\n\nstatic const u16 subplatform_g12_ids[] = {\n\tINTEL_DG2_G12_IDS(0),\n};\n\nstatic const u16 subplatform_m_ids[] = {\n\tINTEL_MTL_M_IDS(0),\n};\n\nstatic const u16 subplatform_p_ids[] = {\n\tINTEL_MTL_P_IDS(0),\n};\n\nstatic bool find_devid(u16 id, const u16 *p, unsigned int num)\n{\n\tfor (; num; num--, p++) {\n\t\tif (*p == id)\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}\n\nstatic void intel_device_info_subplatform_init(struct drm_i915_private *i915)\n{\n\tconst struct intel_device_info *info = INTEL_INFO(i915);\n\tconst struct intel_runtime_info *rinfo = RUNTIME_INFO(i915);\n\tconst unsigned int pi = __platform_mask_index(rinfo, info->platform);\n\tconst unsigned int pb = __platform_mask_bit(rinfo, info->platform);\n\tu16 devid = INTEL_DEVID(i915);\n\tu32 mask = 0;\n\n\t \n\tRUNTIME_INFO(i915)->platform_mask[pi] = BIT(pb);\n\n\t \n\tif (find_devid(devid, subplatform_ult_ids,\n\t\t       ARRAY_SIZE(subplatform_ult_ids))) {\n\t\tmask = BIT(INTEL_SUBPLATFORM_ULT);\n\t\tif (IS_HASWELL(i915) || IS_BROADWELL(i915))\n\t\t\tDISPLAY_RUNTIME_INFO(i915)->port_mask &= ~BIT(PORT_D);\n\t} else if (find_devid(devid, subplatform_ulx_ids,\n\t\t\t      ARRAY_SIZE(subplatform_ulx_ids))) {\n\t\tmask = BIT(INTEL_SUBPLATFORM_ULX);\n\t\tif (IS_HASWELL(i915) || IS_BROADWELL(i915)) {\n\t\t\t \n\t\t\tmask |= BIT(INTEL_SUBPLATFORM_ULT);\n\t\t\tDISPLAY_RUNTIME_INFO(i915)->port_mask &= ~BIT(PORT_D);\n\t\t}\n\t} else if (find_devid(devid, subplatform_portf_ids,\n\t\t\t      ARRAY_SIZE(subplatform_portf_ids))) {\n\t\tDISPLAY_RUNTIME_INFO(i915)->port_mask |= BIT(PORT_F);\n\t\tmask = BIT(INTEL_SUBPLATFORM_PORTF);\n\t} else if (find_devid(devid, subplatform_uy_ids,\n\t\t\t   ARRAY_SIZE(subplatform_uy_ids))) {\n\t\tmask = BIT(INTEL_SUBPLATFORM_UY);\n\t} else if (find_devid(devid, subplatform_n_ids,\n\t\t\t\tARRAY_SIZE(subplatform_n_ids))) {\n\t\tmask = BIT(INTEL_SUBPLATFORM_N);\n\t} else if (find_devid(devid, subplatform_rpl_ids,\n\t\t\t      ARRAY_SIZE(subplatform_rpl_ids))) {\n\t\tmask = BIT(INTEL_SUBPLATFORM_RPL);\n\t\tif (find_devid(devid, subplatform_rplu_ids,\n\t\t\t       ARRAY_SIZE(subplatform_rplu_ids)))\n\t\t\tmask |= BIT(INTEL_SUBPLATFORM_RPLU);\n\t} else if (find_devid(devid, subplatform_g10_ids,\n\t\t\t      ARRAY_SIZE(subplatform_g10_ids))) {\n\t\tmask = BIT(INTEL_SUBPLATFORM_G10);\n\t} else if (find_devid(devid, subplatform_g11_ids,\n\t\t\t      ARRAY_SIZE(subplatform_g11_ids))) {\n\t\tmask = BIT(INTEL_SUBPLATFORM_G11);\n\t} else if (find_devid(devid, subplatform_g12_ids,\n\t\t\t      ARRAY_SIZE(subplatform_g12_ids))) {\n\t\tmask = BIT(INTEL_SUBPLATFORM_G12);\n\t} else if (find_devid(devid, subplatform_m_ids,\n\t\t\t      ARRAY_SIZE(subplatform_m_ids))) {\n\t\tmask = BIT(INTEL_SUBPLATFORM_M);\n\t} else if (find_devid(devid, subplatform_p_ids,\n\t\t\t      ARRAY_SIZE(subplatform_p_ids))) {\n\t\tmask = BIT(INTEL_SUBPLATFORM_P);\n\t}\n\n\tGEM_BUG_ON(mask & ~INTEL_SUBPLATFORM_MASK);\n\n\tRUNTIME_INFO(i915)->platform_mask[pi] |= mask;\n}\n\nstatic void ip_ver_read(struct drm_i915_private *i915, u32 offset, struct intel_ip_version *ip)\n{\n\tstruct pci_dev *pdev = to_pci_dev(i915->drm.dev);\n\tvoid __iomem *addr;\n\tu32 val;\n\tu8 expected_ver = ip->ver;\n\tu8 expected_rel = ip->rel;\n\n\taddr = pci_iomap_range(pdev, 0, offset, sizeof(u32));\n\tif (drm_WARN_ON(&i915->drm, !addr))\n\t\treturn;\n\n\tval = ioread32(addr);\n\tpci_iounmap(pdev, addr);\n\n\tip->ver = REG_FIELD_GET(GMD_ID_ARCH_MASK, val);\n\tip->rel = REG_FIELD_GET(GMD_ID_RELEASE_MASK, val);\n\tip->step = REG_FIELD_GET(GMD_ID_STEP, val);\n\n\t \n\tif (IP_VER(ip->ver, ip->rel) < IP_VER(expected_ver, expected_rel))\n\t\tdrm_dbg(&i915->drm,\n\t\t\t\"Hardware reports GMD IP version %u.%u (REG[0x%x] = 0x%08x) but minimum expected is %u.%u\\n\",\n\t\t\tip->ver, ip->rel, offset, val, expected_ver, expected_rel);\n}\n\n \nstatic void intel_ipver_early_init(struct drm_i915_private *i915)\n{\n\tstruct intel_runtime_info *runtime = RUNTIME_INFO(i915);\n\n\tif (!HAS_GMD_ID(i915)) {\n\t\tdrm_WARN_ON(&i915->drm, RUNTIME_INFO(i915)->graphics.ip.ver > 12);\n\t\t \n\t\tRUNTIME_INFO(i915)->media.ip =\n\t\t\tRUNTIME_INFO(i915)->graphics.ip;\n\t\treturn;\n\t}\n\n\tip_ver_read(i915, i915_mmio_reg_offset(GMD_ID_GRAPHICS),\n\t\t    &runtime->graphics.ip);\n\t \n\tif (runtime->graphics.ip.ver == 0x0 &&\n\t    INTEL_INFO(i915)->platform == INTEL_METEORLAKE) {\n\t\tRUNTIME_INFO(i915)->graphics.ip.ver = 12;\n\t\tRUNTIME_INFO(i915)->graphics.ip.rel = 70;\n\t}\n\tip_ver_read(i915, i915_mmio_reg_offset(GMD_ID_MEDIA),\n\t\t    &runtime->media.ip);\n}\n\n \nvoid intel_device_info_runtime_init_early(struct drm_i915_private *i915)\n{\n\tintel_ipver_early_init(i915);\n\tintel_device_info_subplatform_init(i915);\n}\n\nstatic const struct intel_display_device_info no_display = {};\n\n \nvoid intel_device_info_runtime_init(struct drm_i915_private *dev_priv)\n{\n\tstruct intel_runtime_info *runtime = RUNTIME_INFO(dev_priv);\n\n\tif (HAS_DISPLAY(dev_priv))\n\t\tintel_display_device_info_runtime_init(dev_priv);\n\n\t \n\tif (!HAS_DISPLAY(dev_priv)) {\n\t\tdev_priv->drm.driver_features &= ~(DRIVER_MODESET |\n\t\t\t\t\t\t   DRIVER_ATOMIC);\n\t\tdev_priv->display.info.__device_info = &no_display;\n\t}\n\n\t \n\tif (!dev_priv->params.nuclear_pageflip &&\n\t    DISPLAY_VER(dev_priv) < 5 && !IS_G4X(dev_priv))\n\t\tdev_priv->drm.driver_features &= ~DRIVER_ATOMIC;\n\n\tBUILD_BUG_ON(BITS_PER_TYPE(intel_engine_mask_t) < I915_NUM_ENGINES);\n\n\tif (GRAPHICS_VER(dev_priv) == 6 && i915_vtd_active(dev_priv)) {\n\t\tdrm_info(&dev_priv->drm,\n\t\t\t \"Disabling ppGTT for VT-d support\\n\");\n\t\truntime->ppgtt_type = INTEL_PPGTT_NONE;\n\t}\n\n\truntime->rawclk_freq = intel_read_rawclk(dev_priv);\n\tdrm_dbg(&dev_priv->drm, \"rawclk rate: %d kHz\\n\", runtime->rawclk_freq);\n\n}\n\n \nvoid intel_device_info_driver_create(struct drm_i915_private *i915,\n\t\t\t\t     u16 device_id,\n\t\t\t\t     const struct intel_device_info *match_info)\n{\n\tstruct intel_runtime_info *runtime;\n\tu16 ver, rel, step;\n\n\t \n\ti915->__info = match_info;\n\n\t \n\truntime = RUNTIME_INFO(i915);\n\tmemcpy(runtime, &INTEL_INFO(i915)->__runtime, sizeof(*runtime));\n\n\t \n\ti915->display.info.__device_info = intel_display_device_probe(i915, HAS_GMD_ID(i915),\n\t\t\t\t\t\t\t\t      &ver, &rel, &step);\n\tmemcpy(DISPLAY_RUNTIME_INFO(i915),\n\t       &DISPLAY_INFO(i915)->__runtime_defaults,\n\t       sizeof(*DISPLAY_RUNTIME_INFO(i915)));\n\n\tif (HAS_GMD_ID(i915)) {\n\t\tDISPLAY_RUNTIME_INFO(i915)->ip.ver = ver;\n\t\tDISPLAY_RUNTIME_INFO(i915)->ip.rel = rel;\n\t\tDISPLAY_RUNTIME_INFO(i915)->ip.step = step;\n\t}\n\n\truntime->device_id = device_id;\n}\n\nvoid intel_driver_caps_print(const struct intel_driver_caps *caps,\n\t\t\t     struct drm_printer *p)\n{\n\tdrm_printf(p, \"Has logical contexts? %s\\n\",\n\t\t   str_yes_no(caps->has_logical_contexts));\n\tdrm_printf(p, \"scheduler: 0x%x\\n\", caps->scheduler);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}