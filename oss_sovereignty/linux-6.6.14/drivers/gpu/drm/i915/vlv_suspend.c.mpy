{
  "module_name": "vlv_suspend.c",
  "hash_id": "7f718a709236167de109b3815e6ae12f8ab13ef636b6c3c3d6318d7918c9d640",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/i915/vlv_suspend.c",
  "human_readable_source": "\n \n\n#include <linux/string_helpers.h>\n#include <linux/kernel.h>\n\n#include <drm/drm_print.h>\n\n#include \"i915_drv.h\"\n#include \"i915_reg.h\"\n#include \"i915_trace.h\"\n#include \"i915_utils.h\"\n#include \"intel_clock_gating.h\"\n#include \"vlv_suspend.h\"\n\n#include \"gt/intel_gt_regs.h\"\n\nstruct vlv_s0ix_state {\n\t \n\tu32 wr_watermark;\n\tu32 gfx_prio_ctrl;\n\tu32 arb_mode;\n\tu32 gfx_pend_tlb0;\n\tu32 gfx_pend_tlb1;\n\tu32 lra_limits[GEN7_LRA_LIMITS_REG_NUM];\n\tu32 media_max_req_count;\n\tu32 gfx_max_req_count;\n\tu32 render_hwsp;\n\tu32 ecochk;\n\tu32 bsd_hwsp;\n\tu32 blt_hwsp;\n\tu32 tlb_rd_addr;\n\n\t \n\tu32 g3dctl;\n\tu32 gsckgctl;\n\tu32 mbctl;\n\n\t \n\tu32 ucgctl1;\n\tu32 ucgctl3;\n\tu32 rcgctl1;\n\tu32 rcgctl2;\n\tu32 rstctl;\n\tu32 misccpctl;\n\n\t \n\tu32 gfxpause;\n\tu32 rpdeuhwtc;\n\tu32 rpdeuc;\n\tu32 ecobus;\n\tu32 pwrdwnupctl;\n\tu32 rp_down_timeout;\n\tu32 rp_deucsw;\n\tu32 rcubmabdtmr;\n\tu32 rcedata;\n\tu32 spare2gh;\n\n\t \n\tu32 gt_imr;\n\tu32 gt_ier;\n\tu32 pm_imr;\n\tu32 pm_ier;\n\tu32 gt_scratch[GEN7_GT_SCRATCH_REG_NUM];\n\n\t \n\tu32 tilectl;\n\tu32 gt_fifoctl;\n\tu32 gtlc_wake_ctrl;\n\tu32 gtlc_survive;\n\tu32 pmwgicz;\n\n\t \n\tu32 gu_ctl0;\n\tu32 gu_ctl1;\n\tu32 pcbr;\n\tu32 clock_gate_dis2;\n};\n\n \nstatic void vlv_save_gunit_s0ix_state(struct drm_i915_private *i915)\n{\n\tstruct vlv_s0ix_state *s = i915->vlv_s0ix_state;\n\tstruct intel_uncore *uncore = &i915->uncore;\n\tint i;\n\n\tif (!s)\n\t\treturn;\n\n\t \n\ts->wr_watermark = intel_uncore_read(uncore, GEN7_WR_WATERMARK);\n\ts->gfx_prio_ctrl = intel_uncore_read(uncore, GEN7_GFX_PRIO_CTRL);\n\ts->arb_mode = intel_uncore_read(uncore, ARB_MODE);\n\ts->gfx_pend_tlb0 = intel_uncore_read(uncore, GEN7_GFX_PEND_TLB0);\n\ts->gfx_pend_tlb1 = intel_uncore_read(uncore, GEN7_GFX_PEND_TLB1);\n\n\tfor (i = 0; i < ARRAY_SIZE(s->lra_limits); i++)\n\t\ts->lra_limits[i] = intel_uncore_read(uncore, GEN7_LRA_LIMITS(i));\n\n\ts->media_max_req_count = intel_uncore_read(uncore, GEN7_MEDIA_MAX_REQ_COUNT);\n\ts->gfx_max_req_count = intel_uncore_read(uncore, GEN7_GFX_MAX_REQ_COUNT);\n\n\ts->render_hwsp = intel_uncore_read(uncore, RENDER_HWS_PGA_GEN7);\n\ts->ecochk = intel_uncore_read(uncore, GAM_ECOCHK);\n\ts->bsd_hwsp = intel_uncore_read(uncore, BSD_HWS_PGA_GEN7);\n\ts->blt_hwsp = intel_uncore_read(uncore, BLT_HWS_PGA_GEN7);\n\n\ts->tlb_rd_addr = intel_uncore_read(uncore, GEN7_TLB_RD_ADDR);\n\n\t \n\ts->g3dctl = intel_uncore_read(uncore, VLV_G3DCTL);\n\ts->gsckgctl = intel_uncore_read(uncore, VLV_GSCKGCTL);\n\ts->mbctl = intel_uncore_read(uncore, GEN6_MBCTL);\n\n\t \n\ts->ucgctl1 = intel_uncore_read(uncore, GEN6_UCGCTL1);\n\ts->ucgctl3 = intel_uncore_read(uncore, GEN6_UCGCTL3);\n\ts->rcgctl1 = intel_uncore_read(uncore, GEN6_RCGCTL1);\n\ts->rcgctl2 = intel_uncore_read(uncore, GEN6_RCGCTL2);\n\ts->rstctl = intel_uncore_read(uncore, GEN6_RSTCTL);\n\ts->misccpctl = intel_uncore_read(uncore, GEN7_MISCCPCTL);\n\n\t \n\ts->gfxpause = intel_uncore_read(uncore, GEN6_GFXPAUSE);\n\ts->rpdeuhwtc = intel_uncore_read(uncore, GEN6_RPDEUHWTC);\n\ts->rpdeuc = intel_uncore_read(uncore, GEN6_RPDEUC);\n\ts->ecobus = intel_uncore_read(uncore, ECOBUS);\n\ts->pwrdwnupctl = intel_uncore_read(uncore, VLV_PWRDWNUPCTL);\n\ts->rp_down_timeout = intel_uncore_read(uncore, GEN6_RP_DOWN_TIMEOUT);\n\ts->rp_deucsw = intel_uncore_read(uncore, GEN6_RPDEUCSW);\n\ts->rcubmabdtmr = intel_uncore_read(uncore, GEN6_RCUBMABDTMR);\n\ts->rcedata = intel_uncore_read(uncore, VLV_RCEDATA);\n\ts->spare2gh = intel_uncore_read(uncore, VLV_SPAREG2H);\n\n\t \n\ts->gt_imr = intel_uncore_read(uncore, GTIMR);\n\ts->gt_ier = intel_uncore_read(uncore, GTIER);\n\ts->pm_imr = intel_uncore_read(uncore, GEN6_PMIMR);\n\ts->pm_ier = intel_uncore_read(uncore, GEN6_PMIER);\n\n\tfor (i = 0; i < ARRAY_SIZE(s->gt_scratch); i++)\n\t\ts->gt_scratch[i] = intel_uncore_read(uncore, GEN7_GT_SCRATCH(i));\n\n\t \n\ts->tilectl = intel_uncore_read(uncore, TILECTL);\n\ts->gt_fifoctl = intel_uncore_read(uncore, GTFIFOCTL);\n\ts->gtlc_wake_ctrl = intel_uncore_read(uncore, VLV_GTLC_WAKE_CTRL);\n\ts->gtlc_survive = intel_uncore_read(uncore, VLV_GTLC_SURVIVABILITY_REG);\n\ts->pmwgicz = intel_uncore_read(uncore, VLV_PMWGICZ);\n\n\t \n\ts->gu_ctl0 = intel_uncore_read(uncore, VLV_GU_CTL0);\n\ts->gu_ctl1 = intel_uncore_read(uncore, VLV_GU_CTL1);\n\ts->pcbr = intel_uncore_read(uncore, VLV_PCBR);\n\ts->clock_gate_dis2 = intel_uncore_read(uncore, VLV_GUNIT_CLOCK_GATE2);\n\n\t \n}\n\nstatic void vlv_restore_gunit_s0ix_state(struct drm_i915_private *i915)\n{\n\tstruct vlv_s0ix_state *s = i915->vlv_s0ix_state;\n\tstruct intel_uncore *uncore = &i915->uncore;\n\tint i;\n\n\tif (!s)\n\t\treturn;\n\n\t \n\tintel_uncore_write(uncore, GEN7_WR_WATERMARK, s->wr_watermark);\n\tintel_uncore_write(uncore, GEN7_GFX_PRIO_CTRL, s->gfx_prio_ctrl);\n\tintel_uncore_write(uncore, ARB_MODE, s->arb_mode | (0xffff << 16));\n\tintel_uncore_write(uncore, GEN7_GFX_PEND_TLB0, s->gfx_pend_tlb0);\n\tintel_uncore_write(uncore, GEN7_GFX_PEND_TLB1, s->gfx_pend_tlb1);\n\n\tfor (i = 0; i < ARRAY_SIZE(s->lra_limits); i++)\n\t\tintel_uncore_write(uncore, GEN7_LRA_LIMITS(i), s->lra_limits[i]);\n\n\tintel_uncore_write(uncore, GEN7_MEDIA_MAX_REQ_COUNT, s->media_max_req_count);\n\tintel_uncore_write(uncore, GEN7_GFX_MAX_REQ_COUNT, s->gfx_max_req_count);\n\n\tintel_uncore_write(uncore, RENDER_HWS_PGA_GEN7, s->render_hwsp);\n\tintel_uncore_write(uncore, GAM_ECOCHK, s->ecochk);\n\tintel_uncore_write(uncore, BSD_HWS_PGA_GEN7, s->bsd_hwsp);\n\tintel_uncore_write(uncore, BLT_HWS_PGA_GEN7, s->blt_hwsp);\n\n\tintel_uncore_write(uncore, GEN7_TLB_RD_ADDR, s->tlb_rd_addr);\n\n\t \n\tintel_uncore_write(uncore, VLV_G3DCTL, s->g3dctl);\n\tintel_uncore_write(uncore, VLV_GSCKGCTL, s->gsckgctl);\n\tintel_uncore_write(uncore, GEN6_MBCTL, s->mbctl);\n\n\t \n\tintel_uncore_write(uncore, GEN6_UCGCTL1, s->ucgctl1);\n\tintel_uncore_write(uncore, GEN6_UCGCTL3, s->ucgctl3);\n\tintel_uncore_write(uncore, GEN6_RCGCTL1, s->rcgctl1);\n\tintel_uncore_write(uncore, GEN6_RCGCTL2, s->rcgctl2);\n\tintel_uncore_write(uncore, GEN6_RSTCTL, s->rstctl);\n\tintel_uncore_write(uncore, GEN7_MISCCPCTL, s->misccpctl);\n\n\t \n\tintel_uncore_write(uncore, GEN6_GFXPAUSE, s->gfxpause);\n\tintel_uncore_write(uncore, GEN6_RPDEUHWTC, s->rpdeuhwtc);\n\tintel_uncore_write(uncore, GEN6_RPDEUC, s->rpdeuc);\n\tintel_uncore_write(uncore, ECOBUS, s->ecobus);\n\tintel_uncore_write(uncore, VLV_PWRDWNUPCTL, s->pwrdwnupctl);\n\tintel_uncore_write(uncore, GEN6_RP_DOWN_TIMEOUT, s->rp_down_timeout);\n\tintel_uncore_write(uncore, GEN6_RPDEUCSW, s->rp_deucsw);\n\tintel_uncore_write(uncore, GEN6_RCUBMABDTMR, s->rcubmabdtmr);\n\tintel_uncore_write(uncore, VLV_RCEDATA, s->rcedata);\n\tintel_uncore_write(uncore, VLV_SPAREG2H, s->spare2gh);\n\n\t \n\tintel_uncore_write(uncore, GTIMR, s->gt_imr);\n\tintel_uncore_write(uncore, GTIER, s->gt_ier);\n\tintel_uncore_write(uncore, GEN6_PMIMR, s->pm_imr);\n\tintel_uncore_write(uncore, GEN6_PMIER, s->pm_ier);\n\n\tfor (i = 0; i < ARRAY_SIZE(s->gt_scratch); i++)\n\t\tintel_uncore_write(uncore, GEN7_GT_SCRATCH(i), s->gt_scratch[i]);\n\n\t \n\tintel_uncore_write(uncore, TILECTL, s->tilectl);\n\tintel_uncore_write(uncore, GTFIFOCTL, s->gt_fifoctl);\n\t \n\tintel_uncore_rmw(uncore, VLV_GTLC_WAKE_CTRL, ~VLV_GTLC_ALLOWWAKEREQ,\n\t\t\t s->gtlc_wake_ctrl & ~VLV_GTLC_ALLOWWAKEREQ);\n\n\tintel_uncore_rmw(uncore, VLV_GTLC_SURVIVABILITY_REG, ~VLV_GFX_CLK_FORCE_ON_BIT,\n\t\t\t s->gtlc_survive & ~VLV_GFX_CLK_FORCE_ON_BIT);\n\n\tintel_uncore_write(uncore, VLV_PMWGICZ, s->pmwgicz);\n\n\t \n\tintel_uncore_write(uncore, VLV_GU_CTL0, s->gu_ctl0);\n\tintel_uncore_write(uncore, VLV_GU_CTL1, s->gu_ctl1);\n\tintel_uncore_write(uncore, VLV_PCBR, s->pcbr);\n\tintel_uncore_write(uncore, VLV_GUNIT_CLOCK_GATE2, s->clock_gate_dis2);\n}\n\nstatic int vlv_wait_for_pw_status(struct drm_i915_private *i915,\n\t\t\t\t  u32 mask, u32 val)\n{\n\ti915_reg_t reg = VLV_GTLC_PW_STATUS;\n\tu32 reg_value;\n\tint ret;\n\n\t \n\tret = wait_for(((reg_value =\n\t\t\t intel_uncore_read_notrace(&i915->uncore, reg)) & mask)\n\t\t       == val, 3);\n\n\t \n\ttrace_i915_reg_rw(false, reg, reg_value, sizeof(reg_value), true);\n\n\treturn ret;\n}\n\nstatic int vlv_force_gfx_clock(struct drm_i915_private *i915, bool force_on)\n{\n\tstruct intel_uncore *uncore = &i915->uncore;\n\tint err;\n\n\tintel_uncore_rmw(uncore, VLV_GTLC_SURVIVABILITY_REG, VLV_GFX_CLK_FORCE_ON_BIT,\n\t\t\t force_on ? VLV_GFX_CLK_FORCE_ON_BIT : 0);\n\n\tif (!force_on)\n\t\treturn 0;\n\n\terr = intel_wait_for_register(uncore,\n\t\t\t\t      VLV_GTLC_SURVIVABILITY_REG,\n\t\t\t\t      VLV_GFX_CLK_STATUS_BIT,\n\t\t\t\t      VLV_GFX_CLK_STATUS_BIT,\n\t\t\t\t      20);\n\tif (err)\n\t\tdrm_err(&i915->drm,\n\t\t\t\"timeout waiting for GFX clock force-on (%08x)\\n\",\n\t\t\tintel_uncore_read(uncore, VLV_GTLC_SURVIVABILITY_REG));\n\n\treturn err;\n}\n\nstatic int vlv_allow_gt_wake(struct drm_i915_private *i915, bool allow)\n{\n\tstruct intel_uncore *uncore = &i915->uncore;\n\tu32 mask;\n\tu32 val;\n\tint err;\n\n\tintel_uncore_rmw(uncore, VLV_GTLC_WAKE_CTRL, VLV_GTLC_ALLOWWAKEREQ,\n\t\t\t allow ? VLV_GTLC_ALLOWWAKEREQ : 0);\n\tintel_uncore_posting_read(uncore, VLV_GTLC_WAKE_CTRL);\n\n\tmask = VLV_GTLC_ALLOWWAKEACK;\n\tval = allow ? mask : 0;\n\n\terr = vlv_wait_for_pw_status(i915, mask, val);\n\tif (err)\n\t\tdrm_err(&i915->drm, \"timeout disabling GT waking\\n\");\n\n\treturn err;\n}\n\nstatic void vlv_wait_for_gt_wells(struct drm_i915_private *dev_priv,\n\t\t\t\t  bool wait_for_on)\n{\n\tu32 mask;\n\tu32 val;\n\n\tmask = VLV_GTLC_PW_MEDIA_STATUS_MASK | VLV_GTLC_PW_RENDER_STATUS_MASK;\n\tval = wait_for_on ? mask : 0;\n\n\t \n\tif (vlv_wait_for_pw_status(dev_priv, mask, val))\n\t\tdrm_dbg(&dev_priv->drm,\n\t\t\t\"timeout waiting for GT wells to go %s\\n\",\n\t\t\tstr_on_off(wait_for_on));\n}\n\nstatic void vlv_check_no_gt_access(struct drm_i915_private *i915)\n{\n\tstruct intel_uncore *uncore = &i915->uncore;\n\n\tif (!(intel_uncore_read(uncore, VLV_GTLC_PW_STATUS) & VLV_GTLC_ALLOWWAKEERR))\n\t\treturn;\n\n\tdrm_dbg(&i915->drm, \"GT register access while GT waking disabled\\n\");\n\tintel_uncore_write(uncore, VLV_GTLC_PW_STATUS, VLV_GTLC_ALLOWWAKEERR);\n}\n\nint vlv_suspend_complete(struct drm_i915_private *dev_priv)\n{\n\tu32 mask;\n\tint err;\n\n\tif (!IS_VALLEYVIEW(dev_priv) && !IS_CHERRYVIEW(dev_priv))\n\t\treturn 0;\n\n\t \n\tvlv_wait_for_gt_wells(dev_priv, false);\n\n\tmask = VLV_GTLC_RENDER_CTX_EXISTS | VLV_GTLC_MEDIA_CTX_EXISTS;\n\tdrm_WARN_ON(&dev_priv->drm,\n\t\t    (intel_uncore_read(&dev_priv->uncore, VLV_GTLC_WAKE_CTRL) & mask) != mask);\n\n\tvlv_check_no_gt_access(dev_priv);\n\n\terr = vlv_force_gfx_clock(dev_priv, true);\n\tif (err)\n\t\tgoto err1;\n\n\terr = vlv_allow_gt_wake(dev_priv, false);\n\tif (err)\n\t\tgoto err2;\n\n\tvlv_save_gunit_s0ix_state(dev_priv);\n\n\terr = vlv_force_gfx_clock(dev_priv, false);\n\tif (err)\n\t\tgoto err2;\n\n\treturn 0;\n\nerr2:\n\t \n\tvlv_allow_gt_wake(dev_priv, true);\nerr1:\n\tvlv_force_gfx_clock(dev_priv, false);\n\n\treturn err;\n}\n\nint vlv_resume_prepare(struct drm_i915_private *dev_priv, bool rpm_resume)\n{\n\tint err;\n\tint ret;\n\n\tif (!IS_VALLEYVIEW(dev_priv) && !IS_CHERRYVIEW(dev_priv))\n\t\treturn 0;\n\n\t \n\tret = vlv_force_gfx_clock(dev_priv, true);\n\n\tvlv_restore_gunit_s0ix_state(dev_priv);\n\n\terr = vlv_allow_gt_wake(dev_priv, true);\n\tif (!ret)\n\t\tret = err;\n\n\terr = vlv_force_gfx_clock(dev_priv, false);\n\tif (!ret)\n\t\tret = err;\n\n\tvlv_check_no_gt_access(dev_priv);\n\n\tif (rpm_resume)\n\t\tintel_clock_gating_init(dev_priv);\n\n\treturn ret;\n}\n\nint vlv_suspend_init(struct drm_i915_private *i915)\n{\n\tif (!IS_VALLEYVIEW(i915))\n\t\treturn 0;\n\n\t \n\ti915->vlv_s0ix_state = kmalloc(sizeof(*i915->vlv_s0ix_state),\n\t\t\t\t       GFP_KERNEL);\n\tif (!i915->vlv_s0ix_state)\n\t\treturn -ENOMEM;\n\n\treturn 0;\n}\n\nvoid vlv_suspend_cleanup(struct drm_i915_private *i915)\n{\n\tif (!i915->vlv_s0ix_state)\n\t\treturn;\n\n\tkfree(i915->vlv_s0ix_state);\n\ti915->vlv_s0ix_state = NULL;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}