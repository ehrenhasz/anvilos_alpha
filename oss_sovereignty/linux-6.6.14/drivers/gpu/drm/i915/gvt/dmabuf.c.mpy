{
  "module_name": "dmabuf.c",
  "hash_id": "1d3adfb0b94a081c9a5956fadd12c0a42b522abad3c4f453621ea7601b1847d2",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/i915/gvt/dmabuf.c",
  "human_readable_source": " \n\n#include <linux/dma-buf.h>\n#include <linux/mdev.h>\n\n#include <drm/drm_fourcc.h>\n#include <drm/drm_plane.h>\n\n#include \"gem/i915_gem_dmabuf.h\"\n\n#include \"i915_drv.h\"\n#include \"i915_reg.h\"\n#include \"gvt.h\"\n\n#define GEN8_DECODE_PTE(pte) (pte & GENMASK_ULL(63, 12))\n\nstatic int vgpu_gem_get_pages(struct drm_i915_gem_object *obj)\n{\n\tstruct drm_i915_private *dev_priv = to_i915(obj->base.dev);\n\tstruct intel_vgpu *vgpu;\n\tstruct sg_table *st;\n\tstruct scatterlist *sg;\n\tint i, j, ret;\n\tgen8_pte_t __iomem *gtt_entries;\n\tstruct intel_vgpu_fb_info *fb_info;\n\tunsigned int page_num;  \n\n\tif (overflows_type(obj->base.size >> PAGE_SHIFT, page_num))\n\t\treturn -E2BIG;\n\n\tpage_num = obj->base.size >> PAGE_SHIFT;\n\tfb_info = (struct intel_vgpu_fb_info *)obj->gvt_info;\n\tif (drm_WARN_ON(&dev_priv->drm, !fb_info))\n\t\treturn -ENODEV;\n\n\tvgpu = fb_info->obj->vgpu;\n\tif (drm_WARN_ON(&dev_priv->drm, !vgpu))\n\t\treturn -ENODEV;\n\n\tst = kmalloc(sizeof(*st), GFP_KERNEL);\n\tif (unlikely(!st))\n\t\treturn -ENOMEM;\n\n\tret = sg_alloc_table(st, page_num, GFP_KERNEL);\n\tif (ret) {\n\t\tkfree(st);\n\t\treturn ret;\n\t}\n\tgtt_entries = (gen8_pte_t __iomem *)to_gt(dev_priv)->ggtt->gsm +\n\t\t(fb_info->start >> PAGE_SHIFT);\n\tfor_each_sg(st->sgl, sg, page_num, i) {\n\t\tdma_addr_t dma_addr =\n\t\t\tGEN8_DECODE_PTE(readq(&gtt_entries[i]));\n\t\tif (intel_gvt_dma_pin_guest_page(vgpu, dma_addr)) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t\tsg->offset = 0;\n\t\tsg->length = PAGE_SIZE;\n\t\tsg_dma_len(sg) = PAGE_SIZE;\n\t\tsg_dma_address(sg) = dma_addr;\n\t}\n\n\t__i915_gem_object_set_pages(obj, st);\nout:\n\tif (ret) {\n\t\tdma_addr_t dma_addr;\n\n\t\tfor_each_sg(st->sgl, sg, i, j) {\n\t\t\tdma_addr = sg_dma_address(sg);\n\t\t\tif (dma_addr)\n\t\t\t\tintel_gvt_dma_unmap_guest_page(vgpu, dma_addr);\n\t\t}\n\t\tsg_free_table(st);\n\t\tkfree(st);\n\t}\n\n\treturn ret;\n\n}\n\nstatic void vgpu_gem_put_pages(struct drm_i915_gem_object *obj,\n\t\tstruct sg_table *pages)\n{\n\tstruct scatterlist *sg;\n\n\tif (obj->base.dma_buf) {\n\t\tstruct intel_vgpu_fb_info *fb_info = obj->gvt_info;\n\t\tstruct intel_vgpu_dmabuf_obj *obj = fb_info->obj;\n\t\tstruct intel_vgpu *vgpu = obj->vgpu;\n\t\tint i;\n\n\t\tfor_each_sg(pages->sgl, sg, fb_info->size, i)\n\t\t\tintel_gvt_dma_unmap_guest_page(vgpu,\n\t\t\t\t\t       sg_dma_address(sg));\n\t}\n\n\tsg_free_table(pages);\n\tkfree(pages);\n}\n\nstatic void dmabuf_gem_object_free(struct kref *kref)\n{\n\tstruct intel_vgpu_dmabuf_obj *obj =\n\t\tcontainer_of(kref, struct intel_vgpu_dmabuf_obj, kref);\n\tstruct intel_vgpu *vgpu = obj->vgpu;\n\tstruct list_head *pos;\n\tstruct intel_vgpu_dmabuf_obj *dmabuf_obj;\n\n\tif (vgpu && test_bit(INTEL_VGPU_STATUS_ACTIVE, vgpu->status) &&\n\t    !list_empty(&vgpu->dmabuf_obj_list_head)) {\n\t\tlist_for_each(pos, &vgpu->dmabuf_obj_list_head) {\n\t\t\tdmabuf_obj = list_entry(pos, struct intel_vgpu_dmabuf_obj, list);\n\t\t\tif (dmabuf_obj == obj) {\n\t\t\t\tlist_del(pos);\n\t\t\t\tidr_remove(&vgpu->object_idr,\n\t\t\t\t\t   dmabuf_obj->dmabuf_id);\n\t\t\t\tkfree(dmabuf_obj->info);\n\t\t\t\tkfree(dmabuf_obj);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t} else {\n\t\t \n\t\tkfree(obj->info);\n\t\tkfree(obj);\n\t}\n}\n\n\nstatic inline void dmabuf_obj_get(struct intel_vgpu_dmabuf_obj *obj)\n{\n\tkref_get(&obj->kref);\n}\n\nstatic inline void dmabuf_obj_put(struct intel_vgpu_dmabuf_obj *obj)\n{\n\tkref_put(&obj->kref, dmabuf_gem_object_free);\n}\n\nstatic void vgpu_gem_release(struct drm_i915_gem_object *gem_obj)\n{\n\n\tstruct intel_vgpu_fb_info *fb_info = gem_obj->gvt_info;\n\tstruct intel_vgpu_dmabuf_obj *obj = fb_info->obj;\n\tstruct intel_vgpu *vgpu = obj->vgpu;\n\n\tif (vgpu) {\n\t\tmutex_lock(&vgpu->dmabuf_lock);\n\t\tgem_obj->base.dma_buf = NULL;\n\t\tdmabuf_obj_put(obj);\n\t\tmutex_unlock(&vgpu->dmabuf_lock);\n\t} else {\n\t\t \n\t\tgem_obj->base.dma_buf = NULL;\n\t\tdmabuf_obj_put(obj);\n\t}\n}\n\nstatic const struct drm_i915_gem_object_ops intel_vgpu_gem_ops = {\n\t.name = \"i915_gem_object_vgpu\",\n\t.flags = I915_GEM_OBJECT_IS_PROXY,\n\t.get_pages = vgpu_gem_get_pages,\n\t.put_pages = vgpu_gem_put_pages,\n\t.release = vgpu_gem_release,\n};\n\nstatic struct drm_i915_gem_object *vgpu_create_gem(struct drm_device *dev,\n\t\tstruct intel_vgpu_fb_info *info)\n{\n\tstatic struct lock_class_key lock_class;\n\tstruct drm_i915_private *dev_priv = to_i915(dev);\n\tstruct drm_i915_gem_object *obj;\n\n\tobj = i915_gem_object_alloc();\n\tif (obj == NULL)\n\t\treturn NULL;\n\n\tdrm_gem_private_object_init(dev, &obj->base,\n\t\troundup(info->size, PAGE_SIZE));\n\ti915_gem_object_init(obj, &intel_vgpu_gem_ops, &lock_class, 0);\n\ti915_gem_object_set_readonly(obj);\n\n\tobj->read_domains = I915_GEM_DOMAIN_GTT;\n\tobj->write_domain = 0;\n\tif (GRAPHICS_VER(dev_priv) >= 9) {\n\t\tunsigned int tiling_mode = 0;\n\t\tunsigned int stride = 0;\n\n\t\tswitch (info->drm_format_mod) {\n\t\tcase DRM_FORMAT_MOD_LINEAR:\n\t\t\ttiling_mode = I915_TILING_NONE;\n\t\t\tbreak;\n\t\tcase I915_FORMAT_MOD_X_TILED:\n\t\t\ttiling_mode = I915_TILING_X;\n\t\t\tstride = info->stride;\n\t\t\tbreak;\n\t\tcase I915_FORMAT_MOD_Y_TILED:\n\t\tcase I915_FORMAT_MOD_Yf_TILED:\n\t\t\ttiling_mode = I915_TILING_Y;\n\t\t\tstride = info->stride;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tgvt_dbg_core(\"invalid drm_format_mod %llx for tiling\\n\",\n\t\t\t\t     info->drm_format_mod);\n\t\t}\n\t\tobj->tiling_and_stride = tiling_mode | stride;\n\t} else {\n\t\tobj->tiling_and_stride = info->drm_format_mod ?\n\t\t\t\t\tI915_TILING_X : 0;\n\t}\n\n\treturn obj;\n}\n\nstatic bool validate_hotspot(struct intel_vgpu_cursor_plane_format *c)\n{\n\tif (c && c->x_hot <= c->width && c->y_hot <= c->height)\n\t\treturn true;\n\telse\n\t\treturn false;\n}\n\nstatic int vgpu_get_plane_info(struct drm_device *dev,\n\t\tstruct intel_vgpu *vgpu,\n\t\tstruct intel_vgpu_fb_info *info,\n\t\tint plane_id)\n{\n\tstruct intel_vgpu_primary_plane_format p;\n\tstruct intel_vgpu_cursor_plane_format c;\n\tint ret, tile_height = 1;\n\n\tmemset(info, 0, sizeof(*info));\n\n\tif (plane_id == DRM_PLANE_TYPE_PRIMARY) {\n\t\tret = intel_vgpu_decode_primary_plane(vgpu, &p);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tinfo->start = p.base;\n\t\tinfo->start_gpa = p.base_gpa;\n\t\tinfo->width = p.width;\n\t\tinfo->height = p.height;\n\t\tinfo->stride = p.stride;\n\t\tinfo->drm_format = p.drm_format;\n\n\t\tswitch (p.tiled) {\n\t\tcase PLANE_CTL_TILED_LINEAR:\n\t\t\tinfo->drm_format_mod = DRM_FORMAT_MOD_LINEAR;\n\t\t\tbreak;\n\t\tcase PLANE_CTL_TILED_X:\n\t\t\tinfo->drm_format_mod = I915_FORMAT_MOD_X_TILED;\n\t\t\ttile_height = 8;\n\t\t\tbreak;\n\t\tcase PLANE_CTL_TILED_Y:\n\t\t\tinfo->drm_format_mod = I915_FORMAT_MOD_Y_TILED;\n\t\t\ttile_height = 32;\n\t\t\tbreak;\n\t\tcase PLANE_CTL_TILED_YF:\n\t\t\tinfo->drm_format_mod = I915_FORMAT_MOD_Yf_TILED;\n\t\t\ttile_height = 32;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tgvt_vgpu_err(\"invalid tiling mode: %x\\n\", p.tiled);\n\t\t}\n\t} else if (plane_id == DRM_PLANE_TYPE_CURSOR) {\n\t\tret = intel_vgpu_decode_cursor_plane(vgpu, &c);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tinfo->start = c.base;\n\t\tinfo->start_gpa = c.base_gpa;\n\t\tinfo->width = c.width;\n\t\tinfo->height = c.height;\n\t\tinfo->stride = c.width * (c.bpp / 8);\n\t\tinfo->drm_format = c.drm_format;\n\t\tinfo->drm_format_mod = 0;\n\t\tinfo->x_pos = c.x_pos;\n\t\tinfo->y_pos = c.y_pos;\n\n\t\tif (validate_hotspot(&c)) {\n\t\t\tinfo->x_hot = c.x_hot;\n\t\t\tinfo->y_hot = c.y_hot;\n\t\t} else {\n\t\t\tinfo->x_hot = UINT_MAX;\n\t\t\tinfo->y_hot = UINT_MAX;\n\t\t}\n\t} else {\n\t\tgvt_vgpu_err(\"invalid plane id:%d\\n\", plane_id);\n\t\treturn -EINVAL;\n\t}\n\n\tinfo->size = info->stride * roundup(info->height, tile_height);\n\tif (info->size == 0) {\n\t\tgvt_vgpu_err(\"fb size is zero\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (info->start & (PAGE_SIZE - 1)) {\n\t\tgvt_vgpu_err(\"Not aligned fb address:0x%llx\\n\", info->start);\n\t\treturn -EFAULT;\n\t}\n\n\tif (!intel_gvt_ggtt_validate_range(vgpu, info->start, info->size)) {\n\t\tgvt_vgpu_err(\"invalid gma addr\\n\");\n\t\treturn -EFAULT;\n\t}\n\n\treturn 0;\n}\n\nstatic struct intel_vgpu_dmabuf_obj *\npick_dmabuf_by_info(struct intel_vgpu *vgpu,\n\t\t    struct intel_vgpu_fb_info *latest_info)\n{\n\tstruct list_head *pos;\n\tstruct intel_vgpu_fb_info *fb_info;\n\tstruct intel_vgpu_dmabuf_obj *dmabuf_obj = NULL;\n\tstruct intel_vgpu_dmabuf_obj *ret = NULL;\n\n\tlist_for_each(pos, &vgpu->dmabuf_obj_list_head) {\n\t\tdmabuf_obj = list_entry(pos, struct intel_vgpu_dmabuf_obj, list);\n\t\tif (!dmabuf_obj->info)\n\t\t\tcontinue;\n\n\t\tfb_info = (struct intel_vgpu_fb_info *)dmabuf_obj->info;\n\t\tif ((fb_info->start == latest_info->start) &&\n\t\t    (fb_info->start_gpa == latest_info->start_gpa) &&\n\t\t    (fb_info->size == latest_info->size) &&\n\t\t    (fb_info->drm_format_mod == latest_info->drm_format_mod) &&\n\t\t    (fb_info->drm_format == latest_info->drm_format) &&\n\t\t    (fb_info->width == latest_info->width) &&\n\t\t    (fb_info->height == latest_info->height)) {\n\t\t\tret = dmabuf_obj;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn ret;\n}\n\nstatic struct intel_vgpu_dmabuf_obj *\npick_dmabuf_by_num(struct intel_vgpu *vgpu, u32 id)\n{\n\tstruct list_head *pos;\n\tstruct intel_vgpu_dmabuf_obj *dmabuf_obj = NULL;\n\tstruct intel_vgpu_dmabuf_obj *ret = NULL;\n\n\tlist_for_each(pos, &vgpu->dmabuf_obj_list_head) {\n\t\tdmabuf_obj = list_entry(pos, struct intel_vgpu_dmabuf_obj, list);\n\t\tif (dmabuf_obj->dmabuf_id == id) {\n\t\t\tret = dmabuf_obj;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn ret;\n}\n\nstatic void update_fb_info(struct vfio_device_gfx_plane_info *gvt_dmabuf,\n\t\t      struct intel_vgpu_fb_info *fb_info)\n{\n\tgvt_dmabuf->drm_format = fb_info->drm_format;\n\tgvt_dmabuf->drm_format_mod = fb_info->drm_format_mod;\n\tgvt_dmabuf->width = fb_info->width;\n\tgvt_dmabuf->height = fb_info->height;\n\tgvt_dmabuf->stride = fb_info->stride;\n\tgvt_dmabuf->size = fb_info->size;\n\tgvt_dmabuf->x_pos = fb_info->x_pos;\n\tgvt_dmabuf->y_pos = fb_info->y_pos;\n\tgvt_dmabuf->x_hot = fb_info->x_hot;\n\tgvt_dmabuf->y_hot = fb_info->y_hot;\n}\n\nint intel_vgpu_query_plane(struct intel_vgpu *vgpu, void *args)\n{\n\tstruct drm_device *dev = &vgpu->gvt->gt->i915->drm;\n\tstruct vfio_device_gfx_plane_info *gfx_plane_info = args;\n\tstruct intel_vgpu_dmabuf_obj *dmabuf_obj;\n\tstruct intel_vgpu_fb_info fb_info;\n\tint ret = 0;\n\n\tif (gfx_plane_info->flags == (VFIO_GFX_PLANE_TYPE_DMABUF |\n\t\t\t\t       VFIO_GFX_PLANE_TYPE_PROBE))\n\t\treturn ret;\n\telse if ((gfx_plane_info->flags & ~VFIO_GFX_PLANE_TYPE_DMABUF) ||\n\t\t\t(!gfx_plane_info->flags))\n\t\treturn -EINVAL;\n\n\tret = vgpu_get_plane_info(dev, vgpu, &fb_info,\n\t\t\t\t\tgfx_plane_info->drm_plane_type);\n\tif (ret != 0)\n\t\tgoto out;\n\n\tmutex_lock(&vgpu->dmabuf_lock);\n\t \n\tdmabuf_obj = pick_dmabuf_by_info(vgpu, &fb_info);\n\tif (dmabuf_obj) {\n\t\tupdate_fb_info(gfx_plane_info, &fb_info);\n\t\tgfx_plane_info->dmabuf_id = dmabuf_obj->dmabuf_id;\n\n\t\t \n\t\tif (!dmabuf_obj->initref) {\n\t\t\tdmabuf_obj->initref = true;\n\t\t\tdmabuf_obj_get(dmabuf_obj);\n\t\t}\n\t\tret = 0;\n\t\tgvt_dbg_dpy(\"vgpu%d: re-use dmabuf_obj ref %d, id %d\\n\",\n\t\t\t    vgpu->id, kref_read(&dmabuf_obj->kref),\n\t\t\t    gfx_plane_info->dmabuf_id);\n\t\tmutex_unlock(&vgpu->dmabuf_lock);\n\t\tgoto out;\n\t}\n\n\tmutex_unlock(&vgpu->dmabuf_lock);\n\n\t \n\tdmabuf_obj = kmalloc(sizeof(struct intel_vgpu_dmabuf_obj), GFP_KERNEL);\n\tif (unlikely(!dmabuf_obj)) {\n\t\tgvt_vgpu_err(\"alloc dmabuf_obj failed\\n\");\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tdmabuf_obj->info = kmalloc(sizeof(struct intel_vgpu_fb_info),\n\t\t\t\t   GFP_KERNEL);\n\tif (unlikely(!dmabuf_obj->info)) {\n\t\tgvt_vgpu_err(\"allocate intel vgpu fb info failed\\n\");\n\t\tret = -ENOMEM;\n\t\tgoto out_free_dmabuf;\n\t}\n\tmemcpy(dmabuf_obj->info, &fb_info, sizeof(struct intel_vgpu_fb_info));\n\n\t((struct intel_vgpu_fb_info *)dmabuf_obj->info)->obj = dmabuf_obj;\n\n\tdmabuf_obj->vgpu = vgpu;\n\n\tret = idr_alloc(&vgpu->object_idr, dmabuf_obj, 1, 0, GFP_NOWAIT);\n\tif (ret < 0)\n\t\tgoto out_free_info;\n\tgfx_plane_info->dmabuf_id = ret;\n\tdmabuf_obj->dmabuf_id = ret;\n\n\tdmabuf_obj->initref = true;\n\n\tkref_init(&dmabuf_obj->kref);\n\n\tupdate_fb_info(gfx_plane_info, &fb_info);\n\n\tINIT_LIST_HEAD(&dmabuf_obj->list);\n\tmutex_lock(&vgpu->dmabuf_lock);\n\tlist_add_tail(&dmabuf_obj->list, &vgpu->dmabuf_obj_list_head);\n\tmutex_unlock(&vgpu->dmabuf_lock);\n\n\tgvt_dbg_dpy(\"vgpu%d: %s new dmabuf_obj ref %d, id %d\\n\", vgpu->id,\n\t\t    __func__, kref_read(&dmabuf_obj->kref), ret);\n\n\treturn 0;\n\nout_free_info:\n\tkfree(dmabuf_obj->info);\nout_free_dmabuf:\n\tkfree(dmabuf_obj);\nout:\n\t \n\treturn (ret == -ENODEV) ? 0 : ret;\n}\n\n \nint intel_vgpu_get_dmabuf(struct intel_vgpu *vgpu, unsigned int dmabuf_id)\n{\n\tstruct drm_device *dev = &vgpu->gvt->gt->i915->drm;\n\tstruct intel_vgpu_dmabuf_obj *dmabuf_obj;\n\tstruct drm_i915_gem_object *obj;\n\tstruct dma_buf *dmabuf;\n\tint dmabuf_fd;\n\tint ret = 0;\n\n\tmutex_lock(&vgpu->dmabuf_lock);\n\n\tdmabuf_obj = pick_dmabuf_by_num(vgpu, dmabuf_id);\n\tif (dmabuf_obj == NULL) {\n\t\tgvt_vgpu_err(\"invalid dmabuf id:%d\\n\", dmabuf_id);\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tobj = vgpu_create_gem(dev, dmabuf_obj->info);\n\tif (obj == NULL) {\n\t\tgvt_vgpu_err(\"create gvt gem obj failed\\n\");\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tobj->gvt_info = dmabuf_obj->info;\n\n\tdmabuf = i915_gem_prime_export(&obj->base, DRM_CLOEXEC | DRM_RDWR);\n\tif (IS_ERR(dmabuf)) {\n\t\tgvt_vgpu_err(\"export dma-buf failed\\n\");\n\t\tret = PTR_ERR(dmabuf);\n\t\tgoto out_free_gem;\n\t}\n\n\tret = dma_buf_fd(dmabuf, DRM_CLOEXEC | DRM_RDWR);\n\tif (ret < 0) {\n\t\tgvt_vgpu_err(\"create dma-buf fd failed ret:%d\\n\", ret);\n\t\tgoto out_free_dmabuf;\n\t}\n\tdmabuf_fd = ret;\n\n\tdmabuf_obj_get(dmabuf_obj);\n\n\tif (dmabuf_obj->initref) {\n\t\tdmabuf_obj->initref = false;\n\t\tdmabuf_obj_put(dmabuf_obj);\n\t}\n\n\tmutex_unlock(&vgpu->dmabuf_lock);\n\n\tgvt_dbg_dpy(\"vgpu%d: dmabuf:%d, dmabuf ref %d, fd:%d\\n\"\n\t\t    \"        file count: %ld, GEM ref: %d\\n\",\n\t\t    vgpu->id, dmabuf_obj->dmabuf_id,\n\t\t    kref_read(&dmabuf_obj->kref),\n\t\t    dmabuf_fd,\n\t\t    file_count(dmabuf->file),\n\t\t    kref_read(&obj->base.refcount));\n\n\ti915_gem_object_put(obj);\n\n\treturn dmabuf_fd;\n\nout_free_dmabuf:\n\tdma_buf_put(dmabuf);\nout_free_gem:\n\ti915_gem_object_put(obj);\nout:\n\tmutex_unlock(&vgpu->dmabuf_lock);\n\treturn ret;\n}\n\nvoid intel_vgpu_dmabuf_cleanup(struct intel_vgpu *vgpu)\n{\n\tstruct list_head *pos, *n;\n\tstruct intel_vgpu_dmabuf_obj *dmabuf_obj;\n\n\tmutex_lock(&vgpu->dmabuf_lock);\n\tlist_for_each_safe(pos, n, &vgpu->dmabuf_obj_list_head) {\n\t\tdmabuf_obj = list_entry(pos, struct intel_vgpu_dmabuf_obj, list);\n\t\tdmabuf_obj->vgpu = NULL;\n\n\t\tidr_remove(&vgpu->object_idr, dmabuf_obj->dmabuf_id);\n\t\tlist_del(pos);\n\n\t\t \n\t\tif (dmabuf_obj->initref) {\n\t\t\tdmabuf_obj->initref = false;\n\t\t\tdmabuf_obj_put(dmabuf_obj);\n\t\t}\n\n\t}\n\tmutex_unlock(&vgpu->dmabuf_lock);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}