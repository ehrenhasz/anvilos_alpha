{
  "module_name": "firmware.c",
  "hash_id": "4049a1de7d459959ebaa364cde0961af91c8222af26db7e52ac19b288772ffec",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/i915/gvt/firmware.c",
  "human_readable_source": " \n\n#include <linux/firmware.h>\n#include <linux/crc32.h>\n\n#include \"i915_drv.h\"\n#include \"gvt.h\"\n#include \"i915_pvinfo.h\"\n\n#define FIRMWARE_VERSION (0x0)\n\nstruct gvt_firmware_header {\n\tu64 magic;\n\tu32 crc32;\t\t \n\tu32 version;\n\tu64 cfg_space_size;\n\tu64 cfg_space_offset;\t \n\tu64 mmio_size;\n\tu64 mmio_offset;\t \n\tunsigned char data[];\n};\n\n#define dev_to_drm_minor(d) dev_get_drvdata((d))\n\nstatic ssize_t\ngvt_firmware_read(struct file *filp, struct kobject *kobj,\n\t     struct bin_attribute *attr, char *buf,\n\t     loff_t offset, size_t count)\n{\n\tmemcpy(buf, attr->private + offset, count);\n\treturn count;\n}\n\nstatic struct bin_attribute firmware_attr = {\n\t.attr = {.name = \"gvt_firmware\", .mode = (S_IRUSR)},\n\t.read = gvt_firmware_read,\n\t.write = NULL,\n\t.mmap = NULL,\n};\n\nstatic int expose_firmware_sysfs(struct intel_gvt *gvt)\n{\n\tstruct intel_gvt_device_info *info = &gvt->device_info;\n\tstruct drm_i915_private *i915 = gvt->gt->i915;\n\tstruct pci_dev *pdev = to_pci_dev(i915->drm.dev);\n\tstruct gvt_firmware_header *h;\n\tvoid *firmware;\n\tvoid *p;\n\tunsigned long size, crc32_start;\n\tint ret;\n\n\tsize = offsetof(struct gvt_firmware_header, data) + info->mmio_size + info->cfg_space_size;\n\tfirmware = vzalloc(size);\n\tif (!firmware)\n\t\treturn -ENOMEM;\n\n\th = firmware;\n\n\th->magic = VGT_MAGIC;\n\th->version = FIRMWARE_VERSION;\n\th->cfg_space_size = info->cfg_space_size;\n\th->cfg_space_offset = offsetof(struct gvt_firmware_header, data);\n\th->mmio_size = info->mmio_size;\n\th->mmio_offset = h->cfg_space_offset + h->cfg_space_size;\n\n\tp = firmware + h->cfg_space_offset;\n\n\tmemcpy(gvt->firmware.cfg_space, i915->vgpu.initial_cfg_space,\n\t       info->cfg_space_size);\n\tmemcpy(p, gvt->firmware.cfg_space, info->cfg_space_size);\n\n\tp = firmware + h->mmio_offset;\n\n\tmemcpy(gvt->firmware.mmio, i915->vgpu.initial_mmio,\n\t       info->mmio_size);\n\n\tmemcpy(p, gvt->firmware.mmio, info->mmio_size);\n\n\tcrc32_start = offsetof(struct gvt_firmware_header, version);\n\th->crc32 = crc32_le(0, firmware + crc32_start, size - crc32_start);\n\n\tfirmware_attr.size = size;\n\tfirmware_attr.private = firmware;\n\n\tret = device_create_bin_file(&pdev->dev, &firmware_attr);\n\tif (ret) {\n\t\tvfree(firmware);\n\t\treturn ret;\n\t}\n\treturn 0;\n}\n\nstatic void clean_firmware_sysfs(struct intel_gvt *gvt)\n{\n\tstruct pci_dev *pdev = to_pci_dev(gvt->gt->i915->drm.dev);\n\n\tdevice_remove_bin_file(&pdev->dev, &firmware_attr);\n\tvfree(firmware_attr.private);\n}\n\n \nvoid intel_gvt_free_firmware(struct intel_gvt *gvt)\n{\n\tif (!gvt->firmware.firmware_loaded)\n\t\tclean_firmware_sysfs(gvt);\n\n\tkfree(gvt->firmware.cfg_space);\n\tvfree(gvt->firmware.mmio);\n}\n\nstatic int verify_firmware(struct intel_gvt *gvt,\n\t\t\t   const struct firmware *fw)\n{\n\tstruct intel_gvt_device_info *info = &gvt->device_info;\n\tstruct pci_dev *pdev = to_pci_dev(gvt->gt->i915->drm.dev);\n\tstruct gvt_firmware_header *h;\n\tunsigned long id, crc32_start;\n\tconst void *mem;\n\tconst char *item;\n\tu64 file, request;\n\n\th = (struct gvt_firmware_header *)fw->data;\n\n\tcrc32_start = offsetofend(struct gvt_firmware_header, crc32);\n\tmem = fw->data + crc32_start;\n\n#define VERIFY(s, a, b) do { \\\n\titem = (s); file = (u64)(a); request = (u64)(b); \\\n\tif ((a) != (b)) \\\n\t\tgoto invalid_firmware; \\\n} while (0)\n\n\tVERIFY(\"magic number\", h->magic, VGT_MAGIC);\n\tVERIFY(\"version\", h->version, FIRMWARE_VERSION);\n\tVERIFY(\"crc32\", h->crc32, crc32_le(0, mem, fw->size - crc32_start));\n\tVERIFY(\"cfg space size\", h->cfg_space_size, info->cfg_space_size);\n\tVERIFY(\"mmio size\", h->mmio_size, info->mmio_size);\n\n\tmem = (fw->data + h->cfg_space_offset);\n\n\tid = *(u16 *)(mem + PCI_VENDOR_ID);\n\tVERIFY(\"vendor id\", id, pdev->vendor);\n\n\tid = *(u16 *)(mem + PCI_DEVICE_ID);\n\tVERIFY(\"device id\", id, pdev->device);\n\n\tid = *(u8 *)(mem + PCI_REVISION_ID);\n\tVERIFY(\"revision id\", id, pdev->revision);\n\n#undef VERIFY\n\treturn 0;\n\ninvalid_firmware:\n\tgvt_dbg_core(\"Invalid firmware: %s [file] 0x%llx [request] 0x%llx\\n\",\n\t\t     item, file, request);\n\treturn -EINVAL;\n}\n\n#define GVT_FIRMWARE_PATH \"i915/gvt\"\n\n \nint intel_gvt_load_firmware(struct intel_gvt *gvt)\n{\n\tstruct intel_gvt_device_info *info = &gvt->device_info;\n\tstruct pci_dev *pdev = to_pci_dev(gvt->gt->i915->drm.dev);\n\tstruct intel_gvt_firmware *firmware = &gvt->firmware;\n\tstruct gvt_firmware_header *h;\n\tconst struct firmware *fw;\n\tchar *path;\n\tvoid *mem;\n\tint ret;\n\n\tpath = kmalloc(PATH_MAX, GFP_KERNEL);\n\tif (!path)\n\t\treturn -ENOMEM;\n\n\tmem = kmalloc(info->cfg_space_size, GFP_KERNEL);\n\tif (!mem) {\n\t\tkfree(path);\n\t\treturn -ENOMEM;\n\t}\n\n\tfirmware->cfg_space = mem;\n\n\tmem = vmalloc(info->mmio_size);\n\tif (!mem) {\n\t\tkfree(path);\n\t\tkfree(firmware->cfg_space);\n\t\treturn -ENOMEM;\n\t}\n\n\tfirmware->mmio = mem;\n\n\tsprintf(path, \"%s/vid_0x%04x_did_0x%04x_rid_0x%02x.golden_hw_state\",\n\t\t GVT_FIRMWARE_PATH, pdev->vendor, pdev->device,\n\t\t pdev->revision);\n\n\tgvt_dbg_core(\"request hw state firmware %s...\\n\", path);\n\n\tret = request_firmware(&fw, path, gvt->gt->i915->drm.dev);\n\tkfree(path);\n\n\tif (ret)\n\t\tgoto expose_firmware;\n\n\tgvt_dbg_core(\"success.\\n\");\n\n\tret = verify_firmware(gvt, fw);\n\tif (ret)\n\t\tgoto out_free_fw;\n\n\tgvt_dbg_core(\"verified.\\n\");\n\n\th = (struct gvt_firmware_header *)fw->data;\n\n\tmemcpy(firmware->cfg_space, fw->data + h->cfg_space_offset,\n\t       h->cfg_space_size);\n\tmemcpy(firmware->mmio, fw->data + h->mmio_offset,\n\t       h->mmio_size);\n\n\trelease_firmware(fw);\n\tfirmware->firmware_loaded = true;\n\treturn 0;\n\nout_free_fw:\n\trelease_firmware(fw);\nexpose_firmware:\n\texpose_firmware_sysfs(gvt);\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}