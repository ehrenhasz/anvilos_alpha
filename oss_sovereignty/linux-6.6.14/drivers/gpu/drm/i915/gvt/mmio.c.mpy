{
  "module_name": "mmio.c",
  "hash_id": "c51714a42b269128744bf8ff742cdcf9039729163085a82304445c6f192cbef6",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/i915/gvt/mmio.c",
  "human_readable_source": " \n\n#include \"i915_drv.h\"\n#include \"i915_reg.h\"\n#include \"gvt.h\"\n\n#include \"display/intel_dpio_phy.h\"\n#include \"gt/intel_gt_regs.h\"\n\n \nint intel_vgpu_gpa_to_mmio_offset(struct intel_vgpu *vgpu, u64 gpa)\n{\n\tu64 gttmmio_gpa = intel_vgpu_get_bar_gpa(vgpu, PCI_BASE_ADDRESS_0);\n\treturn gpa - gttmmio_gpa;\n}\n\n#define reg_is_mmio(gvt, reg)  \\\n\t(reg >= 0 && reg < gvt->device_info.mmio_size)\n\n#define reg_is_gtt(gvt, reg)   \\\n\t(reg >= gvt->device_info.gtt_start_offset \\\n\t && reg < gvt->device_info.gtt_start_offset + gvt_ggtt_sz(gvt))\n\nstatic void failsafe_emulate_mmio_rw(struct intel_vgpu *vgpu, u64 pa,\n\t\tvoid *p_data, unsigned int bytes, bool read)\n{\n\tstruct intel_gvt *gvt = NULL;\n\tvoid *pt = NULL;\n\tunsigned int offset = 0;\n\n\tif (!vgpu || !p_data)\n\t\treturn;\n\n\tgvt = vgpu->gvt;\n\tmutex_lock(&vgpu->vgpu_lock);\n\toffset = intel_vgpu_gpa_to_mmio_offset(vgpu, pa);\n\tif (reg_is_mmio(gvt, offset)) {\n\t\tif (read)\n\t\t\tintel_vgpu_default_mmio_read(vgpu, offset, p_data,\n\t\t\t\t\tbytes);\n\t\telse\n\t\t\tintel_vgpu_default_mmio_write(vgpu, offset, p_data,\n\t\t\t\t\tbytes);\n\t} else if (reg_is_gtt(gvt, offset)) {\n\t\toffset -= gvt->device_info.gtt_start_offset;\n\t\tpt = vgpu->gtt.ggtt_mm->ggtt_mm.virtual_ggtt + offset;\n\t\tif (read)\n\t\t\tmemcpy(p_data, pt, bytes);\n\t\telse\n\t\t\tmemcpy(pt, p_data, bytes);\n\n\t}\n\tmutex_unlock(&vgpu->vgpu_lock);\n}\n\n \nint intel_vgpu_emulate_mmio_read(struct intel_vgpu *vgpu, u64 pa,\n\t\tvoid *p_data, unsigned int bytes)\n{\n\tstruct intel_gvt *gvt = vgpu->gvt;\n\tstruct drm_i915_private *i915 = gvt->gt->i915;\n\tunsigned int offset = 0;\n\tint ret = -EINVAL;\n\n\tif (vgpu->failsafe) {\n\t\tfailsafe_emulate_mmio_rw(vgpu, pa, p_data, bytes, true);\n\t\treturn 0;\n\t}\n\tmutex_lock(&vgpu->vgpu_lock);\n\n\toffset = intel_vgpu_gpa_to_mmio_offset(vgpu, pa);\n\n\tif (drm_WARN_ON(&i915->drm, bytes > 8))\n\t\tgoto err;\n\n\tif (reg_is_gtt(gvt, offset)) {\n\t\tif (drm_WARN_ON(&i915->drm, !IS_ALIGNED(offset, 4) &&\n\t\t\t\t!IS_ALIGNED(offset, 8)))\n\t\t\tgoto err;\n\t\tif (drm_WARN_ON(&i915->drm, bytes != 4 && bytes != 8))\n\t\t\tgoto err;\n\t\tif (drm_WARN_ON(&i915->drm,\n\t\t\t\t!reg_is_gtt(gvt, offset + bytes - 1)))\n\t\t\tgoto err;\n\n\t\tret = intel_vgpu_emulate_ggtt_mmio_read(vgpu, offset,\n\t\t\t\tp_data, bytes);\n\t\tif (ret)\n\t\t\tgoto err;\n\t\tgoto out;\n\t}\n\n\tif (drm_WARN_ON_ONCE(&i915->drm, !reg_is_mmio(gvt, offset))) {\n\t\tret = intel_gvt_read_gpa(vgpu, pa, p_data, bytes);\n\t\tgoto out;\n\t}\n\n\tif (drm_WARN_ON(&i915->drm, !reg_is_mmio(gvt, offset + bytes - 1)))\n\t\tgoto err;\n\n\tif (!intel_gvt_mmio_is_unalign(gvt, offset)) {\n\t\tif (drm_WARN_ON(&i915->drm, !IS_ALIGNED(offset, bytes)))\n\t\t\tgoto err;\n\t}\n\n\tret = intel_vgpu_mmio_reg_rw(vgpu, offset, p_data, bytes, true);\n\tif (ret < 0)\n\t\tgoto err;\n\n\tintel_gvt_mmio_set_accessed(gvt, offset);\n\tret = 0;\n\tgoto out;\n\nerr:\n\tgvt_vgpu_err(\"fail to emulate MMIO read %08x len %d\\n\",\n\t\t\toffset, bytes);\nout:\n\tmutex_unlock(&vgpu->vgpu_lock);\n\treturn ret;\n}\n\n \nint intel_vgpu_emulate_mmio_write(struct intel_vgpu *vgpu, u64 pa,\n\t\tvoid *p_data, unsigned int bytes)\n{\n\tstruct intel_gvt *gvt = vgpu->gvt;\n\tstruct drm_i915_private *i915 = gvt->gt->i915;\n\tunsigned int offset = 0;\n\tint ret = -EINVAL;\n\n\tif (vgpu->failsafe) {\n\t\tfailsafe_emulate_mmio_rw(vgpu, pa, p_data, bytes, false);\n\t\treturn 0;\n\t}\n\n\tmutex_lock(&vgpu->vgpu_lock);\n\n\toffset = intel_vgpu_gpa_to_mmio_offset(vgpu, pa);\n\n\tif (drm_WARN_ON(&i915->drm, bytes > 8))\n\t\tgoto err;\n\n\tif (reg_is_gtt(gvt, offset)) {\n\t\tif (drm_WARN_ON(&i915->drm, !IS_ALIGNED(offset, 4) &&\n\t\t\t\t!IS_ALIGNED(offset, 8)))\n\t\t\tgoto err;\n\t\tif (drm_WARN_ON(&i915->drm, bytes != 4 && bytes != 8))\n\t\t\tgoto err;\n\t\tif (drm_WARN_ON(&i915->drm,\n\t\t\t\t!reg_is_gtt(gvt, offset + bytes - 1)))\n\t\t\tgoto err;\n\n\t\tret = intel_vgpu_emulate_ggtt_mmio_write(vgpu, offset,\n\t\t\t\tp_data, bytes);\n\t\tif (ret)\n\t\t\tgoto err;\n\t\tgoto out;\n\t}\n\n\tif (drm_WARN_ON_ONCE(&i915->drm, !reg_is_mmio(gvt, offset))) {\n\t\tret = intel_gvt_write_gpa(vgpu, pa, p_data, bytes);\n\t\tgoto out;\n\t}\n\n\tret = intel_vgpu_mmio_reg_rw(vgpu, offset, p_data, bytes, false);\n\tif (ret < 0)\n\t\tgoto err;\n\n\tintel_gvt_mmio_set_accessed(gvt, offset);\n\tret = 0;\n\tgoto out;\nerr:\n\tgvt_vgpu_err(\"fail to emulate MMIO write %08x len %d\\n\", offset,\n\t\t     bytes);\nout:\n\tmutex_unlock(&vgpu->vgpu_lock);\n\treturn ret;\n}\n\n\n \nvoid intel_vgpu_reset_mmio(struct intel_vgpu *vgpu, bool dmlr)\n{\n\tstruct intel_gvt *gvt = vgpu->gvt;\n\tconst struct intel_gvt_device_info *info = &gvt->device_info;\n\tvoid  *mmio = gvt->firmware.mmio;\n\n\tif (dmlr) {\n\t\tmemcpy(vgpu->mmio.vreg, mmio, info->mmio_size);\n\n\t\tvgpu_vreg_t(vgpu, GEN6_GT_THREAD_STATUS_REG) = 0;\n\n\t\t \n\t\tvgpu_vreg_t(vgpu, GEN6_GT_CORE_STATUS) = 0;\n\n\t\t \n\t\tvgpu_vreg_t(vgpu, GUC_STATUS) |= GS_MIA_IN_RESET;\n\n\t\tif (IS_BROXTON(vgpu->gvt->gt->i915)) {\n\t\t\tvgpu_vreg_t(vgpu, BXT_P_CR_GT_DISP_PWRON) &=\n\t\t\t\t    ~(BIT(0) | BIT(1));\n\t\t\tvgpu_vreg_t(vgpu, BXT_PORT_CL1CM_DW0(DPIO_PHY0)) &=\n\t\t\t\t    ~PHY_POWER_GOOD;\n\t\t\tvgpu_vreg_t(vgpu, BXT_PORT_CL1CM_DW0(DPIO_PHY1)) &=\n\t\t\t\t    ~PHY_POWER_GOOD;\n\t\t\tvgpu_vreg_t(vgpu, BXT_PHY_CTL_FAMILY(DPIO_PHY0)) &=\n\t\t\t\t    ~BIT(30);\n\t\t\tvgpu_vreg_t(vgpu, BXT_PHY_CTL_FAMILY(DPIO_PHY1)) &=\n\t\t\t\t    ~BIT(30);\n\t\t\tvgpu_vreg_t(vgpu, BXT_PHY_CTL(PORT_A)) &=\n\t\t\t\t    ~BXT_PHY_LANE_ENABLED;\n\t\t\tvgpu_vreg_t(vgpu, BXT_PHY_CTL(PORT_A)) |=\n\t\t\t\t    BXT_PHY_CMNLANE_POWERDOWN_ACK |\n\t\t\t\t    BXT_PHY_LANE_POWERDOWN_ACK;\n\t\t\tvgpu_vreg_t(vgpu, BXT_PHY_CTL(PORT_B)) &=\n\t\t\t\t    ~BXT_PHY_LANE_ENABLED;\n\t\t\tvgpu_vreg_t(vgpu, BXT_PHY_CTL(PORT_B)) |=\n\t\t\t\t    BXT_PHY_CMNLANE_POWERDOWN_ACK |\n\t\t\t\t    BXT_PHY_LANE_POWERDOWN_ACK;\n\t\t\tvgpu_vreg_t(vgpu, BXT_PHY_CTL(PORT_C)) &=\n\t\t\t\t    ~BXT_PHY_LANE_ENABLED;\n\t\t\tvgpu_vreg_t(vgpu, BXT_PHY_CTL(PORT_C)) |=\n\t\t\t\t    BXT_PHY_CMNLANE_POWERDOWN_ACK |\n\t\t\t\t    BXT_PHY_LANE_POWERDOWN_ACK;\n\t\t\tvgpu_vreg_t(vgpu, SKL_FUSE_STATUS) |=\n\t\t\t\tSKL_FUSE_DOWNLOAD_STATUS |\n\t\t\t\tSKL_FUSE_PG_DIST_STATUS(SKL_PG0) |\n\t\t\t\tSKL_FUSE_PG_DIST_STATUS(SKL_PG1) |\n\t\t\t\tSKL_FUSE_PG_DIST_STATUS(SKL_PG2);\n\t\t}\n\t} else {\n#define GVT_GEN8_MMIO_RESET_OFFSET\t\t(0x44200)\n\t\t \n\t\tmemcpy(vgpu->mmio.vreg, mmio, GVT_GEN8_MMIO_RESET_OFFSET);\n\t}\n\n}\n\n \nint intel_vgpu_init_mmio(struct intel_vgpu *vgpu)\n{\n\tconst struct intel_gvt_device_info *info = &vgpu->gvt->device_info;\n\n\tvgpu->mmio.vreg = vzalloc(info->mmio_size);\n\tif (!vgpu->mmio.vreg)\n\t\treturn -ENOMEM;\n\n\tintel_vgpu_reset_mmio(vgpu, true);\n\n\treturn 0;\n}\n\n \nvoid intel_vgpu_clean_mmio(struct intel_vgpu *vgpu)\n{\n\tvfree(vgpu->mmio.vreg);\n\tvgpu->mmio.vreg = NULL;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}