{
  "module_name": "edid.c",
  "hash_id": "9a938e28dcd55b1192712a58179df05569e1fe035d3535d4e23a96bd0a0fb33e",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/i915/gvt/edid.c",
  "human_readable_source": " \n\n#include \"display/intel_dp_aux_regs.h\"\n#include \"display/intel_gmbus_regs.h\"\n#include \"gvt.h\"\n#include \"i915_drv.h\"\n#include \"i915_reg.h\"\n\n#define GMBUS1_TOTAL_BYTES_SHIFT 16\n#define GMBUS1_TOTAL_BYTES_MASK 0x1ff\n#define gmbus1_total_byte_count(v) (((v) >> \\\n\tGMBUS1_TOTAL_BYTES_SHIFT) & GMBUS1_TOTAL_BYTES_MASK)\n#define gmbus1_slave_addr(v) (((v) & 0xff) >> 1)\n#define gmbus1_slave_index(v) (((v) >> 8) & 0xff)\n#define gmbus1_bus_cycle(v) (((v) >> 25) & 0x7)\n\n \n#define _GMBUS_PIN_SEL_MASK     (0x7)\n\nstatic unsigned char edid_get_byte(struct intel_vgpu *vgpu)\n{\n\tstruct intel_vgpu_i2c_edid *edid = &vgpu->display.i2c_edid;\n\tunsigned char chr = 0;\n\n\tif (edid->state == I2C_NOT_SPECIFIED || !edid->slave_selected) {\n\t\tgvt_vgpu_err(\"Driver tries to read EDID without proper sequence!\\n\");\n\t\treturn 0;\n\t}\n\tif (edid->current_edid_read >= EDID_SIZE) {\n\t\tgvt_vgpu_err(\"edid_get_byte() exceeds the size of EDID!\\n\");\n\t\treturn 0;\n\t}\n\n\tif (!edid->edid_available) {\n\t\tgvt_vgpu_err(\"Reading EDID but EDID is not available!\\n\");\n\t\treturn 0;\n\t}\n\n\tif (intel_vgpu_has_monitor_on_port(vgpu, edid->port)) {\n\t\tstruct intel_vgpu_edid_data *edid_data =\n\t\t\tintel_vgpu_port(vgpu, edid->port)->edid;\n\n\t\tchr = edid_data->edid_block[edid->current_edid_read];\n\t\tedid->current_edid_read++;\n\t} else {\n\t\tgvt_vgpu_err(\"No EDID available during the reading?\\n\");\n\t}\n\treturn chr;\n}\n\nstatic inline int cnp_get_port_from_gmbus0(u32 gmbus0)\n{\n\tint port_select = gmbus0 & _GMBUS_PIN_SEL_MASK;\n\tint port = -EINVAL;\n\n\tif (port_select == GMBUS_PIN_1_BXT)\n\t\tport = PORT_B;\n\telse if (port_select == GMBUS_PIN_2_BXT)\n\t\tport = PORT_C;\n\telse if (port_select == GMBUS_PIN_3_BXT)\n\t\tport = PORT_D;\n\telse if (port_select == GMBUS_PIN_4_CNP)\n\t\tport = PORT_E;\n\treturn port;\n}\n\nstatic inline int bxt_get_port_from_gmbus0(u32 gmbus0)\n{\n\tint port_select = gmbus0 & _GMBUS_PIN_SEL_MASK;\n\tint port = -EINVAL;\n\n\tif (port_select == GMBUS_PIN_1_BXT)\n\t\tport = PORT_B;\n\telse if (port_select == GMBUS_PIN_2_BXT)\n\t\tport = PORT_C;\n\telse if (port_select == GMBUS_PIN_3_BXT)\n\t\tport = PORT_D;\n\treturn port;\n}\n\nstatic inline int get_port_from_gmbus0(u32 gmbus0)\n{\n\tint port_select = gmbus0 & _GMBUS_PIN_SEL_MASK;\n\tint port = -EINVAL;\n\n\tif (port_select == GMBUS_PIN_VGADDC)\n\t\tport = PORT_E;\n\telse if (port_select == GMBUS_PIN_DPC)\n\t\tport = PORT_C;\n\telse if (port_select == GMBUS_PIN_DPB)\n\t\tport = PORT_B;\n\telse if (port_select == GMBUS_PIN_DPD)\n\t\tport = PORT_D;\n\treturn port;\n}\n\nstatic void reset_gmbus_controller(struct intel_vgpu *vgpu)\n{\n\tvgpu_vreg_t(vgpu, PCH_GMBUS2) = GMBUS_HW_RDY;\n\tif (!vgpu->display.i2c_edid.edid_available)\n\t\tvgpu_vreg_t(vgpu, PCH_GMBUS2) |= GMBUS_SATOER;\n\tvgpu->display.i2c_edid.gmbus.phase = GMBUS_IDLE_PHASE;\n}\n\n \nstatic int gmbus0_mmio_write(struct intel_vgpu *vgpu,\n\t\t\tunsigned int offset, void *p_data, unsigned int bytes)\n{\n\tstruct drm_i915_private *i915 = vgpu->gvt->gt->i915;\n\tint port, pin_select;\n\n\tmemcpy(&vgpu_vreg(vgpu, offset), p_data, bytes);\n\n\tpin_select = vgpu_vreg(vgpu, offset) & _GMBUS_PIN_SEL_MASK;\n\n\tintel_vgpu_init_i2c_edid(vgpu);\n\n\tif (pin_select == 0)\n\t\treturn 0;\n\n\tif (IS_BROXTON(i915))\n\t\tport = bxt_get_port_from_gmbus0(pin_select);\n\telse if (IS_COFFEELAKE(i915) || IS_COMETLAKE(i915))\n\t\tport = cnp_get_port_from_gmbus0(pin_select);\n\telse\n\t\tport = get_port_from_gmbus0(pin_select);\n\tif (drm_WARN_ON(&i915->drm, port < 0))\n\t\treturn 0;\n\n\tvgpu->display.i2c_edid.state = I2C_GMBUS;\n\tvgpu->display.i2c_edid.gmbus.phase = GMBUS_IDLE_PHASE;\n\n\tvgpu_vreg_t(vgpu, PCH_GMBUS2) &= ~GMBUS_ACTIVE;\n\tvgpu_vreg_t(vgpu, PCH_GMBUS2) |= GMBUS_HW_RDY | GMBUS_HW_WAIT_PHASE;\n\n\tif (intel_vgpu_has_monitor_on_port(vgpu, port) &&\n\t\t\t!intel_vgpu_port_is_dp(vgpu, port)) {\n\t\tvgpu->display.i2c_edid.port = port;\n\t\tvgpu->display.i2c_edid.edid_available = true;\n\t\tvgpu_vreg_t(vgpu, PCH_GMBUS2) &= ~GMBUS_SATOER;\n\t} else\n\t\tvgpu_vreg_t(vgpu, PCH_GMBUS2) |= GMBUS_SATOER;\n\treturn 0;\n}\n\nstatic int gmbus1_mmio_write(struct intel_vgpu *vgpu, unsigned int offset,\n\t\tvoid *p_data, unsigned int bytes)\n{\n\tstruct intel_vgpu_i2c_edid *i2c_edid = &vgpu->display.i2c_edid;\n\tu32 slave_addr;\n\tu32 wvalue = *(u32 *)p_data;\n\n\tif (vgpu_vreg(vgpu, offset) & GMBUS_SW_CLR_INT) {\n\t\tif (!(wvalue & GMBUS_SW_CLR_INT)) {\n\t\t\tvgpu_vreg(vgpu, offset) &= ~GMBUS_SW_CLR_INT;\n\t\t\treset_gmbus_controller(vgpu);\n\t\t}\n\t\t \n\t} else {\n\t\t \n\t\tif (wvalue & GMBUS_SW_CLR_INT) {\n\t\t\tvgpu_vreg_t(vgpu, PCH_GMBUS2) &= ~GMBUS_INT;\n\t\t\tvgpu_vreg_t(vgpu, PCH_GMBUS2) |= GMBUS_HW_RDY;\n\t\t}\n\n\t\t \n\t\tif (wvalue & GMBUS_SW_RDY)\n\t\t\twvalue &= ~GMBUS_SW_RDY;\n\n\t\ti2c_edid->gmbus.total_byte_count =\n\t\t\tgmbus1_total_byte_count(wvalue);\n\t\tslave_addr = gmbus1_slave_addr(wvalue);\n\n\t\t \n\t\tif (slave_addr == EDID_ADDR) {\n\t\t\ti2c_edid->slave_selected = true;\n\t\t} else if (slave_addr != 0) {\n\t\t\tgvt_dbg_dpy(\n\t\t\t\t\"vgpu%d: unsupported gmbus slave addr(0x%x)\\n\"\n\t\t\t\t\"\tgmbus operations will be ignored.\\n\",\n\t\t\t\t\tvgpu->id, slave_addr);\n\t\t}\n\n\t\tif (wvalue & GMBUS_CYCLE_INDEX)\n\t\t\ti2c_edid->current_edid_read =\n\t\t\t\tgmbus1_slave_index(wvalue);\n\n\t\ti2c_edid->gmbus.cycle_type = gmbus1_bus_cycle(wvalue);\n\t\tswitch (gmbus1_bus_cycle(wvalue)) {\n\t\tcase GMBUS_NOCYCLE:\n\t\t\tbreak;\n\t\tcase GMBUS_STOP:\n\t\t\t \n\t\t\tif (gmbus1_bus_cycle(vgpu_vreg(vgpu, offset))\n\t\t\t\t!= GMBUS_NOCYCLE) {\n\t\t\t\tintel_vgpu_init_i2c_edid(vgpu);\n\t\t\t\t \n\t\t\t\ti2c_edid->gmbus.phase = GMBUS_IDLE_PHASE;\n\t\t\t\tvgpu_vreg_t(vgpu, PCH_GMBUS2) &= ~GMBUS_ACTIVE;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase NIDX_NS_W:\n\t\tcase IDX_NS_W:\n\t\tcase NIDX_STOP:\n\t\tcase IDX_STOP:\n\t\t\t \n\t\t\ti2c_edid->gmbus.phase = GMBUS_DATA_PHASE;\n\t\t\tvgpu_vreg_t(vgpu, PCH_GMBUS2) |= GMBUS_ACTIVE;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tgvt_vgpu_err(\"Unknown/reserved GMBUS cycle detected!\\n\");\n\t\t\tbreak;\n\t\t}\n\t\t \n\t\tvgpu_vreg(vgpu, offset) = wvalue;\n\t}\n\treturn 0;\n}\n\nstatic int gmbus3_mmio_write(struct intel_vgpu *vgpu, unsigned int offset,\n\tvoid *p_data, unsigned int bytes)\n{\n\tstruct drm_i915_private *i915 = vgpu->gvt->gt->i915;\n\n\tdrm_WARN_ON(&i915->drm, 1);\n\treturn 0;\n}\n\nstatic int gmbus3_mmio_read(struct intel_vgpu *vgpu, unsigned int offset,\n\t\tvoid *p_data, unsigned int bytes)\n{\n\tint i;\n\tunsigned char byte_data;\n\tstruct intel_vgpu_i2c_edid *i2c_edid = &vgpu->display.i2c_edid;\n\tint byte_left = i2c_edid->gmbus.total_byte_count -\n\t\t\t\ti2c_edid->current_edid_read;\n\tint byte_count = byte_left;\n\tu32 reg_data = 0;\n\n\t \n\tif (vgpu_vreg_t(vgpu, PCH_GMBUS1) & GMBUS_SLAVE_READ) {\n\t\tif (byte_left <= 0) {\n\t\t\tmemcpy(p_data, &vgpu_vreg(vgpu, offset), bytes);\n\t\t\treturn 0;\n\t\t}\n\n\t\tif (byte_count > 4)\n\t\t\tbyte_count = 4;\n\t\tfor (i = 0; i < byte_count; i++) {\n\t\t\tbyte_data = edid_get_byte(vgpu);\n\t\t\treg_data |= (byte_data << (i << 3));\n\t\t}\n\n\t\tmemcpy(&vgpu_vreg(vgpu, offset), &reg_data, byte_count);\n\t\tmemcpy(p_data, &vgpu_vreg(vgpu, offset), bytes);\n\n\t\tif (byte_left <= 4) {\n\t\t\tswitch (i2c_edid->gmbus.cycle_type) {\n\t\t\tcase NIDX_STOP:\n\t\t\tcase IDX_STOP:\n\t\t\t\ti2c_edid->gmbus.phase = GMBUS_IDLE_PHASE;\n\t\t\t\tbreak;\n\t\t\tcase NIDX_NS_W:\n\t\t\tcase IDX_NS_W:\n\t\t\tdefault:\n\t\t\t\ti2c_edid->gmbus.phase = GMBUS_WAIT_PHASE;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tintel_vgpu_init_i2c_edid(vgpu);\n\t\t}\n\t\t \n\t} else {\n\t\tmemcpy(p_data, &vgpu_vreg(vgpu, offset), bytes);\n\t\tgvt_vgpu_err(\"warning: gmbus3 read with nothing returned\\n\");\n\t}\n\treturn 0;\n}\n\nstatic int gmbus2_mmio_read(struct intel_vgpu *vgpu, unsigned int offset,\n\t\tvoid *p_data, unsigned int bytes)\n{\n\tu32 value = vgpu_vreg(vgpu, offset);\n\n\tif (!(vgpu_vreg(vgpu, offset) & GMBUS_INUSE))\n\t\tvgpu_vreg(vgpu, offset) |= GMBUS_INUSE;\n\tmemcpy(p_data, (void *)&value, bytes);\n\treturn 0;\n}\n\nstatic int gmbus2_mmio_write(struct intel_vgpu *vgpu, unsigned int offset,\n\t\tvoid *p_data, unsigned int bytes)\n{\n\tu32 wvalue = *(u32 *)p_data;\n\n\tif (wvalue & GMBUS_INUSE)\n\t\tvgpu_vreg(vgpu, offset) &= ~GMBUS_INUSE;\n\t \n\treturn 0;\n}\n\n \nint intel_gvt_i2c_handle_gmbus_read(struct intel_vgpu *vgpu,\n\tunsigned int offset, void *p_data, unsigned int bytes)\n{\n\tstruct drm_i915_private *i915 = vgpu->gvt->gt->i915;\n\n\tif (drm_WARN_ON(&i915->drm, bytes > 8 && (offset & (bytes - 1))))\n\t\treturn -EINVAL;\n\n\tif (offset == i915_mmio_reg_offset(PCH_GMBUS2))\n\t\treturn gmbus2_mmio_read(vgpu, offset, p_data, bytes);\n\telse if (offset == i915_mmio_reg_offset(PCH_GMBUS3))\n\t\treturn gmbus3_mmio_read(vgpu, offset, p_data, bytes);\n\n\tmemcpy(p_data, &vgpu_vreg(vgpu, offset), bytes);\n\treturn 0;\n}\n\n \nint intel_gvt_i2c_handle_gmbus_write(struct intel_vgpu *vgpu,\n\t\tunsigned int offset, void *p_data, unsigned int bytes)\n{\n\tstruct drm_i915_private *i915 = vgpu->gvt->gt->i915;\n\n\tif (drm_WARN_ON(&i915->drm, bytes > 8 && (offset & (bytes - 1))))\n\t\treturn -EINVAL;\n\n\tif (offset == i915_mmio_reg_offset(PCH_GMBUS0))\n\t\treturn gmbus0_mmio_write(vgpu, offset, p_data, bytes);\n\telse if (offset == i915_mmio_reg_offset(PCH_GMBUS1))\n\t\treturn gmbus1_mmio_write(vgpu, offset, p_data, bytes);\n\telse if (offset == i915_mmio_reg_offset(PCH_GMBUS2))\n\t\treturn gmbus2_mmio_write(vgpu, offset, p_data, bytes);\n\telse if (offset == i915_mmio_reg_offset(PCH_GMBUS3))\n\t\treturn gmbus3_mmio_write(vgpu, offset, p_data, bytes);\n\n\tmemcpy(&vgpu_vreg(vgpu, offset), p_data, bytes);\n\treturn 0;\n}\n\nenum {\n\tAUX_CH_CTL = 0,\n\tAUX_CH_DATA1,\n\tAUX_CH_DATA2,\n\tAUX_CH_DATA3,\n\tAUX_CH_DATA4,\n\tAUX_CH_DATA5\n};\n\nstatic inline int get_aux_ch_reg(unsigned int offset)\n{\n\tint reg;\n\n\tswitch (offset & 0xff) {\n\tcase 0x10:\n\t\treg = AUX_CH_CTL;\n\t\tbreak;\n\tcase 0x14:\n\t\treg = AUX_CH_DATA1;\n\t\tbreak;\n\tcase 0x18:\n\t\treg = AUX_CH_DATA2;\n\t\tbreak;\n\tcase 0x1c:\n\t\treg = AUX_CH_DATA3;\n\t\tbreak;\n\tcase 0x20:\n\t\treg = AUX_CH_DATA4;\n\t\tbreak;\n\tcase 0x24:\n\t\treg = AUX_CH_DATA5;\n\t\tbreak;\n\tdefault:\n\t\treg = -1;\n\t\tbreak;\n\t}\n\treturn reg;\n}\n\n \nvoid intel_gvt_i2c_handle_aux_ch_write(struct intel_vgpu *vgpu,\n\t\t\t\tint port_idx,\n\t\t\t\tunsigned int offset,\n\t\t\t\tvoid *p_data)\n{\n\tstruct drm_i915_private *i915 = vgpu->gvt->gt->i915;\n\tstruct intel_vgpu_i2c_edid *i2c_edid = &vgpu->display.i2c_edid;\n\tint msg_length, ret_msg_size;\n\tint msg, addr, ctrl, op;\n\tu32 value = *(u32 *)p_data;\n\tint aux_data_for_write = 0;\n\tint reg = get_aux_ch_reg(offset);\n\n\tif (reg != AUX_CH_CTL) {\n\t\tvgpu_vreg(vgpu, offset) = value;\n\t\treturn;\n\t}\n\n\tmsg_length = REG_FIELD_GET(DP_AUX_CH_CTL_MESSAGE_SIZE_MASK, value);\n\n\t\n\tmsg = vgpu_vreg(vgpu, offset + 4);\n\taddr = (msg >> 8) & 0xffff;\n\tctrl = (msg >> 24) & 0xff;\n\top = ctrl >> 4;\n\tif (!(value & DP_AUX_CH_CTL_SEND_BUSY)) {\n\t\t \n\t\treturn;\n\t}\n\n\t \n\tret_msg_size = (((op & 0x1) == GVT_AUX_I2C_READ) ? 2 : 1);\n\tvgpu_vreg(vgpu, offset) =\n\t\tDP_AUX_CH_CTL_DONE |\n\t\tDP_AUX_CH_CTL_MESSAGE_SIZE(ret_msg_size);\n\n\tif (msg_length == 3) {\n\t\tif (!(op & GVT_AUX_I2C_MOT)) {\n\t\t\t \n\t\t\tintel_vgpu_init_i2c_edid(vgpu);\n\t\t} else {\n\t\t\t \n\t\t\ti2c_edid->aux_ch.i2c_over_aux_ch = true;\n\t\t\ti2c_edid->aux_ch.aux_ch_mot = true;\n\t\t\tif (addr == 0) {\n\t\t\t\t \n\t\t\t\tintel_vgpu_init_i2c_edid(vgpu);\n\t\t\t} else if (addr == EDID_ADDR) {\n\t\t\t\ti2c_edid->state = I2C_AUX_CH;\n\t\t\t\ti2c_edid->port = port_idx;\n\t\t\t\ti2c_edid->slave_selected = true;\n\t\t\t\tif (intel_vgpu_has_monitor_on_port(vgpu,\n\t\t\t\t\tport_idx) &&\n\t\t\t\t\tintel_vgpu_port_is_dp(vgpu, port_idx))\n\t\t\t\t\ti2c_edid->edid_available = true;\n\t\t\t}\n\t\t}\n\t} else if ((op & 0x1) == GVT_AUX_I2C_WRITE) {\n\t\t \n\t} else {\n\t\tif (drm_WARN_ON(&i915->drm, (op & 0x1) != GVT_AUX_I2C_READ))\n\t\t\treturn;\n\t\tif (drm_WARN_ON(&i915->drm, msg_length != 4))\n\t\t\treturn;\n\t\tif (i2c_edid->edid_available && i2c_edid->slave_selected) {\n\t\t\tunsigned char val = edid_get_byte(vgpu);\n\n\t\t\taux_data_for_write = (val << 16);\n\t\t} else\n\t\t\taux_data_for_write = (0xff << 16);\n\t}\n\t \n\taux_data_for_write |= GVT_AUX_I2C_REPLY_ACK << 24;\n\tvgpu_vreg(vgpu, offset + 4) = aux_data_for_write;\n}\n\n \nvoid intel_vgpu_init_i2c_edid(struct intel_vgpu *vgpu)\n{\n\tstruct intel_vgpu_i2c_edid *edid = &vgpu->display.i2c_edid;\n\n\tedid->state = I2C_NOT_SPECIFIED;\n\n\tedid->port = -1;\n\tedid->slave_selected = false;\n\tedid->edid_available = false;\n\tedid->current_edid_read = 0;\n\n\tmemset(&edid->gmbus, 0, sizeof(struct intel_vgpu_i2c_gmbus));\n\n\tedid->aux_ch.i2c_over_aux_ch = false;\n\tedid->aux_ch.aux_ch_mot = false;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}