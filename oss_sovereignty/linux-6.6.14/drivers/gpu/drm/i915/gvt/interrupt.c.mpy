{
  "module_name": "interrupt.c",
  "hash_id": "3627d4543bd54391023572adf495d15c6354eb9bb8915e5b10aa3ba3668b254a",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/i915/gvt/interrupt.c",
  "human_readable_source": " \n\n#include <linux/eventfd.h>\n\n#include \"i915_drv.h\"\n#include \"i915_reg.h\"\n#include \"gvt.h\"\n#include \"trace.h\"\n\n \n#define regbase_to_isr(base)\t(base)\n#define regbase_to_imr(base)\t(base + 0x4)\n#define regbase_to_iir(base)\t(base + 0x8)\n#define regbase_to_ier(base)\t(base + 0xC)\n\n#define iir_to_regbase(iir)    (iir - 0x8)\n#define ier_to_regbase(ier)    (ier - 0xC)\n\n#define get_event_virt_handler(irq, e)\t(irq->events[e].v_handler)\n#define get_irq_info(irq, e)\t\t(irq->events[e].info)\n\n#define irq_to_gvt(irq) \\\n\tcontainer_of(irq, struct intel_gvt, irq)\n\nstatic void update_upstream_irq(struct intel_vgpu *vgpu,\n\t\tstruct intel_gvt_irq_info *info);\n\nstatic const char * const irq_name[INTEL_GVT_EVENT_MAX] = {\n\t[RCS_MI_USER_INTERRUPT] = \"Render CS MI USER INTERRUPT\",\n\t[RCS_DEBUG] = \"Render EU debug from SVG\",\n\t[RCS_MMIO_SYNC_FLUSH] = \"Render MMIO sync flush status\",\n\t[RCS_CMD_STREAMER_ERR] = \"Render CS error interrupt\",\n\t[RCS_PIPE_CONTROL] = \"Render PIPE CONTROL notify\",\n\t[RCS_WATCHDOG_EXCEEDED] = \"Render CS Watchdog counter exceeded\",\n\t[RCS_PAGE_DIRECTORY_FAULT] = \"Render page directory faults\",\n\t[RCS_AS_CONTEXT_SWITCH] = \"Render AS Context Switch Interrupt\",\n\n\t[VCS_MI_USER_INTERRUPT] = \"Video CS MI USER INTERRUPT\",\n\t[VCS_MMIO_SYNC_FLUSH] = \"Video MMIO sync flush status\",\n\t[VCS_CMD_STREAMER_ERR] = \"Video CS error interrupt\",\n\t[VCS_MI_FLUSH_DW] = \"Video MI FLUSH DW notify\",\n\t[VCS_WATCHDOG_EXCEEDED] = \"Video CS Watchdog counter exceeded\",\n\t[VCS_PAGE_DIRECTORY_FAULT] = \"Video page directory faults\",\n\t[VCS_AS_CONTEXT_SWITCH] = \"Video AS Context Switch Interrupt\",\n\t[VCS2_MI_USER_INTERRUPT] = \"VCS2 Video CS MI USER INTERRUPT\",\n\t[VCS2_MI_FLUSH_DW] = \"VCS2 Video MI FLUSH DW notify\",\n\t[VCS2_AS_CONTEXT_SWITCH] = \"VCS2 Context Switch Interrupt\",\n\n\t[BCS_MI_USER_INTERRUPT] = \"Blitter CS MI USER INTERRUPT\",\n\t[BCS_MMIO_SYNC_FLUSH] = \"Billter MMIO sync flush status\",\n\t[BCS_CMD_STREAMER_ERR] = \"Blitter CS error interrupt\",\n\t[BCS_MI_FLUSH_DW] = \"Blitter MI FLUSH DW notify\",\n\t[BCS_PAGE_DIRECTORY_FAULT] = \"Blitter page directory faults\",\n\t[BCS_AS_CONTEXT_SWITCH] = \"Blitter AS Context Switch Interrupt\",\n\n\t[VECS_MI_FLUSH_DW] = \"Video Enhanced Streamer MI FLUSH DW notify\",\n\t[VECS_AS_CONTEXT_SWITCH] = \"VECS Context Switch Interrupt\",\n\n\t[PIPE_A_FIFO_UNDERRUN] = \"Pipe A FIFO underrun\",\n\t[PIPE_A_CRC_ERR] = \"Pipe A CRC error\",\n\t[PIPE_A_CRC_DONE] = \"Pipe A CRC done\",\n\t[PIPE_A_VSYNC] = \"Pipe A vsync\",\n\t[PIPE_A_LINE_COMPARE] = \"Pipe A line compare\",\n\t[PIPE_A_ODD_FIELD] = \"Pipe A odd field\",\n\t[PIPE_A_EVEN_FIELD] = \"Pipe A even field\",\n\t[PIPE_A_VBLANK] = \"Pipe A vblank\",\n\t[PIPE_B_FIFO_UNDERRUN] = \"Pipe B FIFO underrun\",\n\t[PIPE_B_CRC_ERR] = \"Pipe B CRC error\",\n\t[PIPE_B_CRC_DONE] = \"Pipe B CRC done\",\n\t[PIPE_B_VSYNC] = \"Pipe B vsync\",\n\t[PIPE_B_LINE_COMPARE] = \"Pipe B line compare\",\n\t[PIPE_B_ODD_FIELD] = \"Pipe B odd field\",\n\t[PIPE_B_EVEN_FIELD] = \"Pipe B even field\",\n\t[PIPE_B_VBLANK] = \"Pipe B vblank\",\n\t[PIPE_C_VBLANK] = \"Pipe C vblank\",\n\t[DPST_PHASE_IN] = \"DPST phase in event\",\n\t[DPST_HISTOGRAM] = \"DPST histogram event\",\n\t[GSE] = \"GSE\",\n\t[DP_A_HOTPLUG] = \"DP A Hotplug\",\n\t[AUX_CHANNEL_A] = \"AUX Channel A\",\n\t[PERF_COUNTER] = \"Performance counter\",\n\t[POISON] = \"Poison\",\n\t[GTT_FAULT] = \"GTT fault\",\n\t[PRIMARY_A_FLIP_DONE] = \"Primary Plane A flip done\",\n\t[PRIMARY_B_FLIP_DONE] = \"Primary Plane B flip done\",\n\t[PRIMARY_C_FLIP_DONE] = \"Primary Plane C flip done\",\n\t[SPRITE_A_FLIP_DONE] = \"Sprite Plane A flip done\",\n\t[SPRITE_B_FLIP_DONE] = \"Sprite Plane B flip done\",\n\t[SPRITE_C_FLIP_DONE] = \"Sprite Plane C flip done\",\n\n\t[PCU_THERMAL] = \"PCU Thermal Event\",\n\t[PCU_PCODE2DRIVER_MAILBOX] = \"PCU pcode2driver mailbox event\",\n\n\t[FDI_RX_INTERRUPTS_TRANSCODER_A] = \"FDI RX Interrupts Combined A\",\n\t[AUDIO_CP_CHANGE_TRANSCODER_A] = \"Audio CP Change Transcoder A\",\n\t[AUDIO_CP_REQUEST_TRANSCODER_A] = \"Audio CP Request Transcoder A\",\n\t[FDI_RX_INTERRUPTS_TRANSCODER_B] = \"FDI RX Interrupts Combined B\",\n\t[AUDIO_CP_CHANGE_TRANSCODER_B] = \"Audio CP Change Transcoder B\",\n\t[AUDIO_CP_REQUEST_TRANSCODER_B] = \"Audio CP Request Transcoder B\",\n\t[FDI_RX_INTERRUPTS_TRANSCODER_C] = \"FDI RX Interrupts Combined C\",\n\t[AUDIO_CP_CHANGE_TRANSCODER_C] = \"Audio CP Change Transcoder C\",\n\t[AUDIO_CP_REQUEST_TRANSCODER_C] = \"Audio CP Request Transcoder C\",\n\t[ERR_AND_DBG] = \"South Error and Debug Interrupts Combined\",\n\t[GMBUS] = \"Gmbus\",\n\t[SDVO_B_HOTPLUG] = \"SDVO B hotplug\",\n\t[CRT_HOTPLUG] = \"CRT Hotplug\",\n\t[DP_B_HOTPLUG] = \"DisplayPort/HDMI/DVI B Hotplug\",\n\t[DP_C_HOTPLUG] = \"DisplayPort/HDMI/DVI C Hotplug\",\n\t[DP_D_HOTPLUG] = \"DisplayPort/HDMI/DVI D Hotplug\",\n\t[AUX_CHANNEL_B] = \"AUX Channel B\",\n\t[AUX_CHANNEL_C] = \"AUX Channel C\",\n\t[AUX_CHANNEL_D] = \"AUX Channel D\",\n\t[AUDIO_POWER_STATE_CHANGE_B] = \"Audio Power State change Port B\",\n\t[AUDIO_POWER_STATE_CHANGE_C] = \"Audio Power State change Port C\",\n\t[AUDIO_POWER_STATE_CHANGE_D] = \"Audio Power State change Port D\",\n\n\t[INTEL_GVT_EVENT_RESERVED] = \"RESERVED EVENTS!!!\",\n};\n\nstatic inline struct intel_gvt_irq_info *regbase_to_irq_info(\n\t\tstruct intel_gvt *gvt,\n\t\tunsigned int reg)\n{\n\tstruct intel_gvt_irq *irq = &gvt->irq;\n\tint i;\n\n\tfor_each_set_bit(i, irq->irq_info_bitmap, INTEL_GVT_IRQ_INFO_MAX) {\n\t\tif (i915_mmio_reg_offset(irq->info[i]->reg_base) == reg)\n\t\t\treturn irq->info[i];\n\t}\n\n\treturn NULL;\n}\n\n \nint intel_vgpu_reg_imr_handler(struct intel_vgpu *vgpu,\n\tunsigned int reg, void *p_data, unsigned int bytes)\n{\n\tstruct intel_gvt *gvt = vgpu->gvt;\n\tconst struct intel_gvt_irq_ops *ops = gvt->irq.ops;\n\tu32 imr = *(u32 *)p_data;\n\n\ttrace_write_ir(vgpu->id, \"IMR\", reg, imr, vgpu_vreg(vgpu, reg),\n\t\t       (vgpu_vreg(vgpu, reg) ^ imr));\n\n\tvgpu_vreg(vgpu, reg) = imr;\n\n\tops->check_pending_irq(vgpu);\n\n\treturn 0;\n}\n\n \nint intel_vgpu_reg_master_irq_handler(struct intel_vgpu *vgpu,\n\tunsigned int reg, void *p_data, unsigned int bytes)\n{\n\tstruct intel_gvt *gvt = vgpu->gvt;\n\tconst struct intel_gvt_irq_ops *ops = gvt->irq.ops;\n\tu32 ier = *(u32 *)p_data;\n\tu32 virtual_ier = vgpu_vreg(vgpu, reg);\n\n\ttrace_write_ir(vgpu->id, \"MASTER_IRQ\", reg, ier, virtual_ier,\n\t\t       (virtual_ier ^ ier));\n\n\t \n\tier &= GEN8_MASTER_IRQ_CONTROL;\n\tvirtual_ier &= GEN8_MASTER_IRQ_CONTROL;\n\tvgpu_vreg(vgpu, reg) &= ~GEN8_MASTER_IRQ_CONTROL;\n\tvgpu_vreg(vgpu, reg) |= ier;\n\n\tops->check_pending_irq(vgpu);\n\n\treturn 0;\n}\n\n \nint intel_vgpu_reg_ier_handler(struct intel_vgpu *vgpu,\n\tunsigned int reg, void *p_data, unsigned int bytes)\n{\n\tstruct intel_gvt *gvt = vgpu->gvt;\n\tstruct drm_i915_private *i915 = gvt->gt->i915;\n\tconst struct intel_gvt_irq_ops *ops = gvt->irq.ops;\n\tstruct intel_gvt_irq_info *info;\n\tu32 ier = *(u32 *)p_data;\n\n\ttrace_write_ir(vgpu->id, \"IER\", reg, ier, vgpu_vreg(vgpu, reg),\n\t\t       (vgpu_vreg(vgpu, reg) ^ ier));\n\n\tvgpu_vreg(vgpu, reg) = ier;\n\n\tinfo = regbase_to_irq_info(gvt, ier_to_regbase(reg));\n\tif (drm_WARN_ON(&i915->drm, !info))\n\t\treturn -EINVAL;\n\n\tif (info->has_upstream_irq)\n\t\tupdate_upstream_irq(vgpu, info);\n\n\tops->check_pending_irq(vgpu);\n\n\treturn 0;\n}\n\n \nint intel_vgpu_reg_iir_handler(struct intel_vgpu *vgpu, unsigned int reg,\n\tvoid *p_data, unsigned int bytes)\n{\n\tstruct drm_i915_private *i915 = vgpu->gvt->gt->i915;\n\tstruct intel_gvt_irq_info *info = regbase_to_irq_info(vgpu->gvt,\n\t\tiir_to_regbase(reg));\n\tu32 iir = *(u32 *)p_data;\n\n\ttrace_write_ir(vgpu->id, \"IIR\", reg, iir, vgpu_vreg(vgpu, reg),\n\t\t       (vgpu_vreg(vgpu, reg) ^ iir));\n\n\tif (drm_WARN_ON(&i915->drm, !info))\n\t\treturn -EINVAL;\n\n\tvgpu_vreg(vgpu, reg) &= ~iir;\n\n\tif (info->has_upstream_irq)\n\t\tupdate_upstream_irq(vgpu, info);\n\treturn 0;\n}\n\nstatic struct intel_gvt_irq_map gen8_irq_map[] = {\n\t{ INTEL_GVT_IRQ_INFO_MASTER, 0, INTEL_GVT_IRQ_INFO_GT0, 0xffff },\n\t{ INTEL_GVT_IRQ_INFO_MASTER, 1, INTEL_GVT_IRQ_INFO_GT0, 0xffff0000 },\n\t{ INTEL_GVT_IRQ_INFO_MASTER, 2, INTEL_GVT_IRQ_INFO_GT1, 0xffff },\n\t{ INTEL_GVT_IRQ_INFO_MASTER, 3, INTEL_GVT_IRQ_INFO_GT1, 0xffff0000 },\n\t{ INTEL_GVT_IRQ_INFO_MASTER, 4, INTEL_GVT_IRQ_INFO_GT2, 0xffff },\n\t{ INTEL_GVT_IRQ_INFO_MASTER, 6, INTEL_GVT_IRQ_INFO_GT3, 0xffff },\n\t{ INTEL_GVT_IRQ_INFO_MASTER, 16, INTEL_GVT_IRQ_INFO_DE_PIPE_A, ~0 },\n\t{ INTEL_GVT_IRQ_INFO_MASTER, 17, INTEL_GVT_IRQ_INFO_DE_PIPE_B, ~0 },\n\t{ INTEL_GVT_IRQ_INFO_MASTER, 18, INTEL_GVT_IRQ_INFO_DE_PIPE_C, ~0 },\n\t{ INTEL_GVT_IRQ_INFO_MASTER, 20, INTEL_GVT_IRQ_INFO_DE_PORT, ~0 },\n\t{ INTEL_GVT_IRQ_INFO_MASTER, 22, INTEL_GVT_IRQ_INFO_DE_MISC, ~0 },\n\t{ INTEL_GVT_IRQ_INFO_MASTER, 23, INTEL_GVT_IRQ_INFO_PCH, ~0 },\n\t{ INTEL_GVT_IRQ_INFO_MASTER, 30, INTEL_GVT_IRQ_INFO_PCU, ~0 },\n\t{ -1, -1, ~0 },\n};\n\nstatic void update_upstream_irq(struct intel_vgpu *vgpu,\n\t\tstruct intel_gvt_irq_info *info)\n{\n\tstruct drm_i915_private *i915 = vgpu->gvt->gt->i915;\n\tstruct intel_gvt_irq *irq = &vgpu->gvt->irq;\n\tstruct intel_gvt_irq_map *map = irq->irq_map;\n\tstruct intel_gvt_irq_info *up_irq_info = NULL;\n\tu32 set_bits = 0;\n\tu32 clear_bits = 0;\n\tint bit;\n\tu32 val = vgpu_vreg(vgpu,\n\t\t\tregbase_to_iir(i915_mmio_reg_offset(info->reg_base)))\n\t\t& vgpu_vreg(vgpu,\n\t\t\tregbase_to_ier(i915_mmio_reg_offset(info->reg_base)));\n\n\tif (!info->has_upstream_irq)\n\t\treturn;\n\n\tfor (map = irq->irq_map; map->up_irq_bit != -1; map++) {\n\t\tif (info->group != map->down_irq_group)\n\t\t\tcontinue;\n\n\t\tif (!up_irq_info)\n\t\t\tup_irq_info = irq->info[map->up_irq_group];\n\t\telse\n\t\t\tdrm_WARN_ON(&i915->drm, up_irq_info !=\n\t\t\t\t    irq->info[map->up_irq_group]);\n\n\t\tbit = map->up_irq_bit;\n\n\t\tif (val & map->down_irq_bitmask)\n\t\t\tset_bits |= (1 << bit);\n\t\telse\n\t\t\tclear_bits |= (1 << bit);\n\t}\n\n\tif (drm_WARN_ON(&i915->drm, !up_irq_info))\n\t\treturn;\n\n\tif (up_irq_info->group == INTEL_GVT_IRQ_INFO_MASTER) {\n\t\tu32 isr = i915_mmio_reg_offset(up_irq_info->reg_base);\n\n\t\tvgpu_vreg(vgpu, isr) &= ~clear_bits;\n\t\tvgpu_vreg(vgpu, isr) |= set_bits;\n\t} else {\n\t\tu32 iir = regbase_to_iir(\n\t\t\ti915_mmio_reg_offset(up_irq_info->reg_base));\n\t\tu32 imr = regbase_to_imr(\n\t\t\ti915_mmio_reg_offset(up_irq_info->reg_base));\n\n\t\tvgpu_vreg(vgpu, iir) |= (set_bits & ~vgpu_vreg(vgpu, imr));\n\t}\n\n\tif (up_irq_info->has_upstream_irq)\n\t\tupdate_upstream_irq(vgpu, up_irq_info);\n}\n\nstatic void init_irq_map(struct intel_gvt_irq *irq)\n{\n\tstruct intel_gvt_irq_map *map;\n\tstruct intel_gvt_irq_info *up_info, *down_info;\n\tint up_bit;\n\n\tfor (map = irq->irq_map; map->up_irq_bit != -1; map++) {\n\t\tup_info = irq->info[map->up_irq_group];\n\t\tup_bit = map->up_irq_bit;\n\t\tdown_info = irq->info[map->down_irq_group];\n\n\t\tset_bit(up_bit, up_info->downstream_irq_bitmap);\n\t\tdown_info->has_upstream_irq = true;\n\n\t\tgvt_dbg_irq(\"[up] grp %d bit %d -> [down] grp %d bitmask %x\\n\",\n\t\t\tup_info->group, up_bit,\n\t\t\tdown_info->group, map->down_irq_bitmask);\n\t}\n}\n\n \n\n#define MSI_CAP_CONTROL(offset) (offset + 2)\n#define MSI_CAP_ADDRESS(offset) (offset + 4)\n#define MSI_CAP_DATA(offset) (offset + 8)\n#define MSI_CAP_EN 0x1\n\nstatic int inject_virtual_interrupt(struct intel_vgpu *vgpu)\n{\n\tunsigned long offset = vgpu->gvt->device_info.msi_cap_offset;\n\tu16 control, data;\n\tu32 addr;\n\n\tcontrol = *(u16 *)(vgpu_cfg_space(vgpu) + MSI_CAP_CONTROL(offset));\n\taddr = *(u32 *)(vgpu_cfg_space(vgpu) + MSI_CAP_ADDRESS(offset));\n\tdata = *(u16 *)(vgpu_cfg_space(vgpu) + MSI_CAP_DATA(offset));\n\n\t \n\tif (!(control & MSI_CAP_EN))\n\t\treturn 0;\n\n\tif (WARN(control & GENMASK(15, 1), \"only support one MSI format\\n\"))\n\t\treturn -EINVAL;\n\n\ttrace_inject_msi(vgpu->id, addr, data);\n\n\t \n\tif (!test_bit(INTEL_VGPU_STATUS_ATTACHED, vgpu->status))\n\t\treturn -ESRCH;\n\tif (vgpu->msi_trigger && eventfd_signal(vgpu->msi_trigger, 1) != 1)\n\t\treturn -EFAULT;\n\treturn 0;\n}\n\nstatic void propagate_event(struct intel_gvt_irq *irq,\n\tenum intel_gvt_event_type event, struct intel_vgpu *vgpu)\n{\n\tstruct intel_gvt_irq_info *info;\n\tunsigned int reg_base;\n\tint bit;\n\n\tinfo = get_irq_info(irq, event);\n\tif (WARN_ON(!info))\n\t\treturn;\n\n\treg_base = i915_mmio_reg_offset(info->reg_base);\n\tbit = irq->events[event].bit;\n\n\tif (!test_bit(bit, (void *)&vgpu_vreg(vgpu,\n\t\t\t\t\tregbase_to_imr(reg_base)))) {\n\t\ttrace_propagate_event(vgpu->id, irq_name[event], bit);\n\t\tset_bit(bit, (void *)&vgpu_vreg(vgpu,\n\t\t\t\t\tregbase_to_iir(reg_base)));\n\t}\n}\n\n \nstatic void handle_default_event_virt(struct intel_gvt_irq *irq,\n\tenum intel_gvt_event_type event, struct intel_vgpu *vgpu)\n{\n\tif (!vgpu->irq.irq_warn_once[event]) {\n\t\tgvt_dbg_core(\"vgpu%d: IRQ receive event %d (%s)\\n\",\n\t\t\tvgpu->id, event, irq_name[event]);\n\t\tvgpu->irq.irq_warn_once[event] = true;\n\t}\n\tpropagate_event(irq, event, vgpu);\n}\n\n \n \n\n#define DEFINE_GVT_GEN8_INTEL_GVT_IRQ_INFO(regname, regbase) \\\nstatic struct intel_gvt_irq_info gen8_##regname##_info = { \\\n\t.name = #regname\"-IRQ\", \\\n\t.reg_base = (regbase), \\\n\t.bit_to_event = {[0 ... INTEL_GVT_IRQ_BITWIDTH-1] = \\\n\t\tINTEL_GVT_EVENT_RESERVED}, \\\n}\n\nDEFINE_GVT_GEN8_INTEL_GVT_IRQ_INFO(gt0, GEN8_GT_ISR(0));\nDEFINE_GVT_GEN8_INTEL_GVT_IRQ_INFO(gt1, GEN8_GT_ISR(1));\nDEFINE_GVT_GEN8_INTEL_GVT_IRQ_INFO(gt2, GEN8_GT_ISR(2));\nDEFINE_GVT_GEN8_INTEL_GVT_IRQ_INFO(gt3, GEN8_GT_ISR(3));\nDEFINE_GVT_GEN8_INTEL_GVT_IRQ_INFO(de_pipe_a, GEN8_DE_PIPE_ISR(PIPE_A));\nDEFINE_GVT_GEN8_INTEL_GVT_IRQ_INFO(de_pipe_b, GEN8_DE_PIPE_ISR(PIPE_B));\nDEFINE_GVT_GEN8_INTEL_GVT_IRQ_INFO(de_pipe_c, GEN8_DE_PIPE_ISR(PIPE_C));\nDEFINE_GVT_GEN8_INTEL_GVT_IRQ_INFO(de_port, GEN8_DE_PORT_ISR);\nDEFINE_GVT_GEN8_INTEL_GVT_IRQ_INFO(de_misc, GEN8_DE_MISC_ISR);\nDEFINE_GVT_GEN8_INTEL_GVT_IRQ_INFO(pcu, GEN8_PCU_ISR);\nDEFINE_GVT_GEN8_INTEL_GVT_IRQ_INFO(master, GEN8_MASTER_IRQ);\n\nstatic struct intel_gvt_irq_info gvt_base_pch_info = {\n\t.name = \"PCH-IRQ\",\n\t.reg_base = SDEISR,\n\t.bit_to_event = {[0 ... INTEL_GVT_IRQ_BITWIDTH-1] =\n\t\tINTEL_GVT_EVENT_RESERVED},\n};\n\nstatic void gen8_check_pending_irq(struct intel_vgpu *vgpu)\n{\n\tstruct intel_gvt_irq *irq = &vgpu->gvt->irq;\n\tint i;\n\n\tif (!(vgpu_vreg(vgpu, i915_mmio_reg_offset(GEN8_MASTER_IRQ)) &\n\t\t\t\tGEN8_MASTER_IRQ_CONTROL))\n\t\treturn;\n\n\tfor_each_set_bit(i, irq->irq_info_bitmap, INTEL_GVT_IRQ_INFO_MAX) {\n\t\tstruct intel_gvt_irq_info *info = irq->info[i];\n\t\tu32 reg_base;\n\n\t\tif (!info->has_upstream_irq)\n\t\t\tcontinue;\n\n\t\treg_base = i915_mmio_reg_offset(info->reg_base);\n\t\tif ((vgpu_vreg(vgpu, regbase_to_iir(reg_base))\n\t\t\t\t& vgpu_vreg(vgpu, regbase_to_ier(reg_base))))\n\t\t\tupdate_upstream_irq(vgpu, info);\n\t}\n\n\tif (vgpu_vreg(vgpu, i915_mmio_reg_offset(GEN8_MASTER_IRQ))\n\t\t\t& ~GEN8_MASTER_IRQ_CONTROL)\n\t\tinject_virtual_interrupt(vgpu);\n}\n\nstatic void gen8_init_irq(\n\t\tstruct intel_gvt_irq *irq)\n{\n\tstruct intel_gvt *gvt = irq_to_gvt(irq);\n\n#define SET_BIT_INFO(s, b, e, i)\t\t\\\n\tdo {\t\t\t\t\t\\\n\t\ts->events[e].bit = b;\t\t\\\n\t\ts->events[e].info = s->info[i];\t\\\n\t\ts->info[i]->bit_to_event[b] = e;\\\n\t} while (0)\n\n#define SET_IRQ_GROUP(s, g, i) \\\n\tdo { \\\n\t\ts->info[g] = i; \\\n\t\t(i)->group = g; \\\n\t\tset_bit(g, s->irq_info_bitmap); \\\n\t} while (0)\n\n\tSET_IRQ_GROUP(irq, INTEL_GVT_IRQ_INFO_MASTER, &gen8_master_info);\n\tSET_IRQ_GROUP(irq, INTEL_GVT_IRQ_INFO_GT0, &gen8_gt0_info);\n\tSET_IRQ_GROUP(irq, INTEL_GVT_IRQ_INFO_GT1, &gen8_gt1_info);\n\tSET_IRQ_GROUP(irq, INTEL_GVT_IRQ_INFO_GT2, &gen8_gt2_info);\n\tSET_IRQ_GROUP(irq, INTEL_GVT_IRQ_INFO_GT3, &gen8_gt3_info);\n\tSET_IRQ_GROUP(irq, INTEL_GVT_IRQ_INFO_DE_PIPE_A, &gen8_de_pipe_a_info);\n\tSET_IRQ_GROUP(irq, INTEL_GVT_IRQ_INFO_DE_PIPE_B, &gen8_de_pipe_b_info);\n\tSET_IRQ_GROUP(irq, INTEL_GVT_IRQ_INFO_DE_PIPE_C, &gen8_de_pipe_c_info);\n\tSET_IRQ_GROUP(irq, INTEL_GVT_IRQ_INFO_DE_PORT, &gen8_de_port_info);\n\tSET_IRQ_GROUP(irq, INTEL_GVT_IRQ_INFO_DE_MISC, &gen8_de_misc_info);\n\tSET_IRQ_GROUP(irq, INTEL_GVT_IRQ_INFO_PCU, &gen8_pcu_info);\n\tSET_IRQ_GROUP(irq, INTEL_GVT_IRQ_INFO_PCH, &gvt_base_pch_info);\n\n\t \n\n\t \n\tSET_BIT_INFO(irq, 0, RCS_MI_USER_INTERRUPT, INTEL_GVT_IRQ_INFO_GT0);\n\tSET_BIT_INFO(irq, 4, RCS_PIPE_CONTROL, INTEL_GVT_IRQ_INFO_GT0);\n\tSET_BIT_INFO(irq, 8, RCS_AS_CONTEXT_SWITCH, INTEL_GVT_IRQ_INFO_GT0);\n\n\tSET_BIT_INFO(irq, 16, BCS_MI_USER_INTERRUPT, INTEL_GVT_IRQ_INFO_GT0);\n\tSET_BIT_INFO(irq, 20, BCS_MI_FLUSH_DW, INTEL_GVT_IRQ_INFO_GT0);\n\tSET_BIT_INFO(irq, 24, BCS_AS_CONTEXT_SWITCH, INTEL_GVT_IRQ_INFO_GT0);\n\n\t \n\tSET_BIT_INFO(irq, 0, VCS_MI_USER_INTERRUPT, INTEL_GVT_IRQ_INFO_GT1);\n\tSET_BIT_INFO(irq, 4, VCS_MI_FLUSH_DW, INTEL_GVT_IRQ_INFO_GT1);\n\tSET_BIT_INFO(irq, 8, VCS_AS_CONTEXT_SWITCH, INTEL_GVT_IRQ_INFO_GT1);\n\n\tif (HAS_ENGINE(gvt->gt, VCS1)) {\n\t\tSET_BIT_INFO(irq, 16, VCS2_MI_USER_INTERRUPT,\n\t\t\tINTEL_GVT_IRQ_INFO_GT1);\n\t\tSET_BIT_INFO(irq, 20, VCS2_MI_FLUSH_DW,\n\t\t\tINTEL_GVT_IRQ_INFO_GT1);\n\t\tSET_BIT_INFO(irq, 24, VCS2_AS_CONTEXT_SWITCH,\n\t\t\tINTEL_GVT_IRQ_INFO_GT1);\n\t}\n\n\t \n\tSET_BIT_INFO(irq, 0, VECS_MI_USER_INTERRUPT, INTEL_GVT_IRQ_INFO_GT3);\n\tSET_BIT_INFO(irq, 4, VECS_MI_FLUSH_DW, INTEL_GVT_IRQ_INFO_GT3);\n\tSET_BIT_INFO(irq, 8, VECS_AS_CONTEXT_SWITCH, INTEL_GVT_IRQ_INFO_GT3);\n\n\tSET_BIT_INFO(irq, 0, PIPE_A_VBLANK, INTEL_GVT_IRQ_INFO_DE_PIPE_A);\n\tSET_BIT_INFO(irq, 0, PIPE_B_VBLANK, INTEL_GVT_IRQ_INFO_DE_PIPE_B);\n\tSET_BIT_INFO(irq, 0, PIPE_C_VBLANK, INTEL_GVT_IRQ_INFO_DE_PIPE_C);\n\n\t \n\tSET_BIT_INFO(irq, 0, AUX_CHANNEL_A, INTEL_GVT_IRQ_INFO_DE_PORT);\n\tSET_BIT_INFO(irq, 3, DP_A_HOTPLUG, INTEL_GVT_IRQ_INFO_DE_PORT);\n\n\t \n\tSET_BIT_INFO(irq, 0, GSE, INTEL_GVT_IRQ_INFO_DE_MISC);\n\n\t \n\tSET_BIT_INFO(irq, 17, GMBUS, INTEL_GVT_IRQ_INFO_PCH);\n\tSET_BIT_INFO(irq, 19, CRT_HOTPLUG, INTEL_GVT_IRQ_INFO_PCH);\n\tSET_BIT_INFO(irq, 21, DP_B_HOTPLUG, INTEL_GVT_IRQ_INFO_PCH);\n\tSET_BIT_INFO(irq, 22, DP_C_HOTPLUG, INTEL_GVT_IRQ_INFO_PCH);\n\tSET_BIT_INFO(irq, 23, DP_D_HOTPLUG, INTEL_GVT_IRQ_INFO_PCH);\n\n\tif (IS_BROADWELL(gvt->gt->i915)) {\n\t\tSET_BIT_INFO(irq, 25, AUX_CHANNEL_B, INTEL_GVT_IRQ_INFO_PCH);\n\t\tSET_BIT_INFO(irq, 26, AUX_CHANNEL_C, INTEL_GVT_IRQ_INFO_PCH);\n\t\tSET_BIT_INFO(irq, 27, AUX_CHANNEL_D, INTEL_GVT_IRQ_INFO_PCH);\n\n\t\tSET_BIT_INFO(irq, 4, PRIMARY_A_FLIP_DONE, INTEL_GVT_IRQ_INFO_DE_PIPE_A);\n\t\tSET_BIT_INFO(irq, 5, SPRITE_A_FLIP_DONE, INTEL_GVT_IRQ_INFO_DE_PIPE_A);\n\n\t\tSET_BIT_INFO(irq, 4, PRIMARY_B_FLIP_DONE, INTEL_GVT_IRQ_INFO_DE_PIPE_B);\n\t\tSET_BIT_INFO(irq, 5, SPRITE_B_FLIP_DONE, INTEL_GVT_IRQ_INFO_DE_PIPE_B);\n\n\t\tSET_BIT_INFO(irq, 4, PRIMARY_C_FLIP_DONE, INTEL_GVT_IRQ_INFO_DE_PIPE_C);\n\t\tSET_BIT_INFO(irq, 5, SPRITE_C_FLIP_DONE, INTEL_GVT_IRQ_INFO_DE_PIPE_C);\n\t} else if (GRAPHICS_VER(gvt->gt->i915) >= 9) {\n\t\tSET_BIT_INFO(irq, 25, AUX_CHANNEL_B, INTEL_GVT_IRQ_INFO_DE_PORT);\n\t\tSET_BIT_INFO(irq, 26, AUX_CHANNEL_C, INTEL_GVT_IRQ_INFO_DE_PORT);\n\t\tSET_BIT_INFO(irq, 27, AUX_CHANNEL_D, INTEL_GVT_IRQ_INFO_DE_PORT);\n\n\t\tSET_BIT_INFO(irq, 3, PRIMARY_A_FLIP_DONE, INTEL_GVT_IRQ_INFO_DE_PIPE_A);\n\t\tSET_BIT_INFO(irq, 3, PRIMARY_B_FLIP_DONE, INTEL_GVT_IRQ_INFO_DE_PIPE_B);\n\t\tSET_BIT_INFO(irq, 3, PRIMARY_C_FLIP_DONE, INTEL_GVT_IRQ_INFO_DE_PIPE_C);\n\n\t\tSET_BIT_INFO(irq, 4, SPRITE_A_FLIP_DONE, INTEL_GVT_IRQ_INFO_DE_PIPE_A);\n\t\tSET_BIT_INFO(irq, 4, SPRITE_B_FLIP_DONE, INTEL_GVT_IRQ_INFO_DE_PIPE_B);\n\t\tSET_BIT_INFO(irq, 4, SPRITE_C_FLIP_DONE, INTEL_GVT_IRQ_INFO_DE_PIPE_C);\n\t}\n\n\t \n\tSET_BIT_INFO(irq, 24, PCU_THERMAL, INTEL_GVT_IRQ_INFO_PCU);\n\tSET_BIT_INFO(irq, 25, PCU_PCODE2DRIVER_MAILBOX, INTEL_GVT_IRQ_INFO_PCU);\n}\n\nstatic const struct intel_gvt_irq_ops gen8_irq_ops = {\n\t.init_irq = gen8_init_irq,\n\t.check_pending_irq = gen8_check_pending_irq,\n};\n\n \nvoid intel_vgpu_trigger_virtual_event(struct intel_vgpu *vgpu,\n\tenum intel_gvt_event_type event)\n{\n\tstruct drm_i915_private *i915 = vgpu->gvt->gt->i915;\n\tstruct intel_gvt *gvt = vgpu->gvt;\n\tstruct intel_gvt_irq *irq = &gvt->irq;\n\tgvt_event_virt_handler_t handler;\n\tconst struct intel_gvt_irq_ops *ops = gvt->irq.ops;\n\n\thandler = get_event_virt_handler(irq, event);\n\tdrm_WARN_ON(&i915->drm, !handler);\n\n\thandler(irq, event, vgpu);\n\n\tops->check_pending_irq(vgpu);\n}\n\nstatic void init_events(\n\tstruct intel_gvt_irq *irq)\n{\n\tint i;\n\n\tfor (i = 0; i < INTEL_GVT_EVENT_MAX; i++) {\n\t\tirq->events[i].info = NULL;\n\t\tirq->events[i].v_handler = handle_default_event_virt;\n\t}\n}\n\n \nint intel_gvt_init_irq(struct intel_gvt *gvt)\n{\n\tstruct intel_gvt_irq *irq = &gvt->irq;\n\n\tgvt_dbg_core(\"init irq framework\\n\");\n\n\tirq->ops = &gen8_irq_ops;\n\tirq->irq_map = gen8_irq_map;\n\n\t \n\tinit_events(irq);\n\n\t \n\tirq->ops->init_irq(irq);\n\n\tinit_irq_map(irq);\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}