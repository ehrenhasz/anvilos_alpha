{
  "module_name": "aperture_gm.c",
  "hash_id": "63caf4b39e9ffaa87635e2648d9609751a7f96d1cb03e1b667063517c0008553",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/i915/gvt/aperture_gm.c",
  "human_readable_source": " \n\n#include \"i915_drv.h\"\n#include \"i915_reg.h\"\n#include \"gt/intel_ggtt_fencing.h\"\n#include \"gvt.h\"\n\nstatic int alloc_gm(struct intel_vgpu *vgpu, bool high_gm)\n{\n\tstruct intel_gvt *gvt = vgpu->gvt;\n\tstruct intel_gt *gt = gvt->gt;\n\tunsigned int flags;\n\tu64 start, end, size;\n\tstruct drm_mm_node *node;\n\tint ret;\n\n\tif (high_gm) {\n\t\tnode = &vgpu->gm.high_gm_node;\n\t\tsize = vgpu_hidden_sz(vgpu);\n\t\tstart = ALIGN(gvt_hidden_gmadr_base(gvt), I915_GTT_PAGE_SIZE);\n\t\tend = ALIGN(gvt_hidden_gmadr_end(gvt), I915_GTT_PAGE_SIZE);\n\t\tflags = PIN_HIGH;\n\t} else {\n\t\tnode = &vgpu->gm.low_gm_node;\n\t\tsize = vgpu_aperture_sz(vgpu);\n\t\tstart = ALIGN(gvt_aperture_gmadr_base(gvt), I915_GTT_PAGE_SIZE);\n\t\tend = ALIGN(gvt_aperture_gmadr_end(gvt), I915_GTT_PAGE_SIZE);\n\t\tflags = PIN_MAPPABLE;\n\t}\n\n\tmutex_lock(&gt->ggtt->vm.mutex);\n\tmmio_hw_access_pre(gt);\n\tret = i915_gem_gtt_insert(&gt->ggtt->vm, NULL, node,\n\t\t\t\t  size, I915_GTT_PAGE_SIZE,\n\t\t\t\t  I915_COLOR_UNEVICTABLE,\n\t\t\t\t  start, end, flags);\n\tmmio_hw_access_post(gt);\n\tmutex_unlock(&gt->ggtt->vm.mutex);\n\tif (ret)\n\t\tgvt_err(\"fail to alloc %s gm space from host\\n\",\n\t\t\thigh_gm ? \"high\" : \"low\");\n\n\treturn ret;\n}\n\nstatic int alloc_vgpu_gm(struct intel_vgpu *vgpu)\n{\n\tstruct intel_gvt *gvt = vgpu->gvt;\n\tstruct intel_gt *gt = gvt->gt;\n\tint ret;\n\n\tret = alloc_gm(vgpu, false);\n\tif (ret)\n\t\treturn ret;\n\n\tret = alloc_gm(vgpu, true);\n\tif (ret)\n\t\tgoto out_free_aperture;\n\n\tgvt_dbg_core(\"vgpu%d: alloc low GM start %llx size %llx\\n\", vgpu->id,\n\t\t     vgpu_aperture_offset(vgpu), vgpu_aperture_sz(vgpu));\n\n\tgvt_dbg_core(\"vgpu%d: alloc high GM start %llx size %llx\\n\", vgpu->id,\n\t\t     vgpu_hidden_offset(vgpu), vgpu_hidden_sz(vgpu));\n\n\treturn 0;\nout_free_aperture:\n\tmutex_lock(&gt->ggtt->vm.mutex);\n\tdrm_mm_remove_node(&vgpu->gm.low_gm_node);\n\tmutex_unlock(&gt->ggtt->vm.mutex);\n\treturn ret;\n}\n\nstatic void free_vgpu_gm(struct intel_vgpu *vgpu)\n{\n\tstruct intel_gvt *gvt = vgpu->gvt;\n\tstruct intel_gt *gt = gvt->gt;\n\n\tmutex_lock(&gt->ggtt->vm.mutex);\n\tdrm_mm_remove_node(&vgpu->gm.low_gm_node);\n\tdrm_mm_remove_node(&vgpu->gm.high_gm_node);\n\tmutex_unlock(&gt->ggtt->vm.mutex);\n}\n\n \nvoid intel_vgpu_write_fence(struct intel_vgpu *vgpu,\n\t\tu32 fence, u64 value)\n{\n\tstruct intel_gvt *gvt = vgpu->gvt;\n\tstruct drm_i915_private *i915 = gvt->gt->i915;\n\tstruct intel_uncore *uncore = gvt->gt->uncore;\n\tstruct i915_fence_reg *reg;\n\ti915_reg_t fence_reg_lo, fence_reg_hi;\n\n\tassert_rpm_wakelock_held(uncore->rpm);\n\n\tif (drm_WARN_ON(&i915->drm, fence >= vgpu_fence_sz(vgpu)))\n\t\treturn;\n\n\treg = vgpu->fence.regs[fence];\n\tif (drm_WARN_ON(&i915->drm, !reg))\n\t\treturn;\n\n\tfence_reg_lo = FENCE_REG_GEN6_LO(reg->id);\n\tfence_reg_hi = FENCE_REG_GEN6_HI(reg->id);\n\n\tintel_uncore_write(uncore, fence_reg_lo, 0);\n\tintel_uncore_posting_read(uncore, fence_reg_lo);\n\n\tintel_uncore_write(uncore, fence_reg_hi, upper_32_bits(value));\n\tintel_uncore_write(uncore, fence_reg_lo, lower_32_bits(value));\n\tintel_uncore_posting_read(uncore, fence_reg_lo);\n}\n\nstatic void _clear_vgpu_fence(struct intel_vgpu *vgpu)\n{\n\tint i;\n\n\tfor (i = 0; i < vgpu_fence_sz(vgpu); i++)\n\t\tintel_vgpu_write_fence(vgpu, i, 0);\n}\n\nstatic void free_vgpu_fence(struct intel_vgpu *vgpu)\n{\n\tstruct intel_gvt *gvt = vgpu->gvt;\n\tstruct intel_uncore *uncore = gvt->gt->uncore;\n\tstruct i915_fence_reg *reg;\n\tintel_wakeref_t wakeref;\n\tu32 i;\n\n\tif (drm_WARN_ON(&gvt->gt->i915->drm, !vgpu_fence_sz(vgpu)))\n\t\treturn;\n\n\twakeref = intel_runtime_pm_get(uncore->rpm);\n\n\tmutex_lock(&gvt->gt->ggtt->vm.mutex);\n\t_clear_vgpu_fence(vgpu);\n\tfor (i = 0; i < vgpu_fence_sz(vgpu); i++) {\n\t\treg = vgpu->fence.regs[i];\n\t\ti915_unreserve_fence(reg);\n\t\tvgpu->fence.regs[i] = NULL;\n\t}\n\tmutex_unlock(&gvt->gt->ggtt->vm.mutex);\n\n\tintel_runtime_pm_put(uncore->rpm, wakeref);\n}\n\nstatic int alloc_vgpu_fence(struct intel_vgpu *vgpu)\n{\n\tstruct intel_gvt *gvt = vgpu->gvt;\n\tstruct intel_uncore *uncore = gvt->gt->uncore;\n\tstruct i915_fence_reg *reg;\n\tintel_wakeref_t wakeref;\n\tint i;\n\n\twakeref = intel_runtime_pm_get(uncore->rpm);\n\n\t \n\tmutex_lock(&gvt->gt->ggtt->vm.mutex);\n\n\tfor (i = 0; i < vgpu_fence_sz(vgpu); i++) {\n\t\treg = i915_reserve_fence(gvt->gt->ggtt);\n\t\tif (IS_ERR(reg))\n\t\t\tgoto out_free_fence;\n\n\t\tvgpu->fence.regs[i] = reg;\n\t}\n\n\t_clear_vgpu_fence(vgpu);\n\n\tmutex_unlock(&gvt->gt->ggtt->vm.mutex);\n\tintel_runtime_pm_put(uncore->rpm, wakeref);\n\treturn 0;\n\nout_free_fence:\n\tgvt_vgpu_err(\"Failed to alloc fences\\n\");\n\t \n\tfor (i = 0; i < vgpu_fence_sz(vgpu); i++) {\n\t\treg = vgpu->fence.regs[i];\n\t\tif (!reg)\n\t\t\tcontinue;\n\t\ti915_unreserve_fence(reg);\n\t\tvgpu->fence.regs[i] = NULL;\n\t}\n\tmutex_unlock(&gvt->gt->ggtt->vm.mutex);\n\tintel_runtime_pm_put_unchecked(uncore->rpm);\n\treturn -ENOSPC;\n}\n\nstatic void free_resource(struct intel_vgpu *vgpu)\n{\n\tstruct intel_gvt *gvt = vgpu->gvt;\n\n\tgvt->gm.vgpu_allocated_low_gm_size -= vgpu_aperture_sz(vgpu);\n\tgvt->gm.vgpu_allocated_high_gm_size -= vgpu_hidden_sz(vgpu);\n\tgvt->fence.vgpu_allocated_fence_num -= vgpu_fence_sz(vgpu);\n}\n\nstatic int alloc_resource(struct intel_vgpu *vgpu,\n\t\tconst struct intel_vgpu_config *conf)\n{\n\tstruct intel_gvt *gvt = vgpu->gvt;\n\tunsigned long request, avail, max, taken;\n\tconst char *item;\n\n\tif (!conf->low_mm || !conf->high_mm || !conf->fence) {\n\t\tgvt_vgpu_err(\"Invalid vGPU creation params\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\titem = \"low GM space\";\n\tmax = gvt_aperture_sz(gvt) - HOST_LOW_GM_SIZE;\n\ttaken = gvt->gm.vgpu_allocated_low_gm_size;\n\tavail = max - taken;\n\trequest = conf->low_mm;\n\n\tif (request > avail)\n\t\tgoto no_enough_resource;\n\n\tvgpu_aperture_sz(vgpu) = ALIGN(request, I915_GTT_PAGE_SIZE);\n\n\titem = \"high GM space\";\n\tmax = gvt_hidden_sz(gvt) - HOST_HIGH_GM_SIZE;\n\ttaken = gvt->gm.vgpu_allocated_high_gm_size;\n\tavail = max - taken;\n\trequest = conf->high_mm;\n\n\tif (request > avail)\n\t\tgoto no_enough_resource;\n\n\tvgpu_hidden_sz(vgpu) = ALIGN(request, I915_GTT_PAGE_SIZE);\n\n\titem = \"fence\";\n\tmax = gvt_fence_sz(gvt) - HOST_FENCE;\n\ttaken = gvt->fence.vgpu_allocated_fence_num;\n\tavail = max - taken;\n\trequest = conf->fence;\n\n\tif (request > avail)\n\t\tgoto no_enough_resource;\n\n\tvgpu_fence_sz(vgpu) = request;\n\n\tgvt->gm.vgpu_allocated_low_gm_size += conf->low_mm;\n\tgvt->gm.vgpu_allocated_high_gm_size += conf->high_mm;\n\tgvt->fence.vgpu_allocated_fence_num += conf->fence;\n\treturn 0;\n\nno_enough_resource:\n\tgvt_err(\"fail to allocate resource %s\\n\", item);\n\tgvt_err(\"request %luMB avail %luMB max %luMB taken %luMB\\n\",\n\t\tBYTES_TO_MB(request), BYTES_TO_MB(avail),\n\t\tBYTES_TO_MB(max), BYTES_TO_MB(taken));\n\treturn -ENOSPC;\n}\n\n \nvoid intel_vgpu_free_resource(struct intel_vgpu *vgpu)\n{\n\tfree_vgpu_gm(vgpu);\n\tfree_vgpu_fence(vgpu);\n\tfree_resource(vgpu);\n}\n\n \nvoid intel_vgpu_reset_resource(struct intel_vgpu *vgpu)\n{\n\tstruct intel_gvt *gvt = vgpu->gvt;\n\tintel_wakeref_t wakeref;\n\n\twith_intel_runtime_pm(gvt->gt->uncore->rpm, wakeref)\n\t\t_clear_vgpu_fence(vgpu);\n}\n\n \nint intel_vgpu_alloc_resource(struct intel_vgpu *vgpu,\n\t\tconst struct intel_vgpu_config *conf)\n{\n\tint ret;\n\n\tret = alloc_resource(vgpu, conf);\n\tif (ret)\n\t\treturn ret;\n\n\tret = alloc_vgpu_gm(vgpu);\n\tif (ret)\n\t\tgoto out_free_resource;\n\n\tret = alloc_vgpu_fence(vgpu);\n\tif (ret)\n\t\tgoto out_free_vgpu_gm;\n\n\treturn 0;\n\nout_free_vgpu_gm:\n\tfree_vgpu_gm(vgpu);\nout_free_resource:\n\tfree_resource(vgpu);\n\treturn ret;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}