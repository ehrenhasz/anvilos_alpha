{
  "module_name": "mmio_context.c",
  "hash_id": "e25e43021366bbb1c4d7f112b680fd456674cd9742215736a46f8e4bbe3f11e4",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/i915/gvt/mmio_context.c",
  "human_readable_source": " \n\n#include \"i915_drv.h\"\n#include \"i915_reg.h\"\n#include \"gt/intel_context.h\"\n#include \"gt/intel_engine_regs.h\"\n#include \"gt/intel_gpu_commands.h\"\n#include \"gt/intel_gt_regs.h\"\n#include \"gt/intel_ring.h\"\n#include \"gvt.h\"\n#include \"trace.h\"\n\n#define GEN9_MOCS_SIZE\t\t64\n\n \nstatic struct engine_mmio gen8_engine_mmio_list[] __cacheline_aligned = {\n\t{RCS0, RING_MODE_GEN7(RENDER_RING_BASE), 0xffff, false},  \n\t{RCS0, GEN9_CTX_PREEMPT_REG, 0x0, false},  \n\t{RCS0, HWSTAM, 0x0, false},  \n\t{RCS0, INSTPM, 0xffff, true},  \n\t{RCS0, RING_FORCE_TO_NONPRIV(RENDER_RING_BASE, 0), 0, false},  \n\t{RCS0, RING_FORCE_TO_NONPRIV(RENDER_RING_BASE, 1), 0, false},  \n\t{RCS0, RING_FORCE_TO_NONPRIV(RENDER_RING_BASE, 2), 0, false},  \n\t{RCS0, RING_FORCE_TO_NONPRIV(RENDER_RING_BASE, 3), 0, false},  \n\t{RCS0, RING_FORCE_TO_NONPRIV(RENDER_RING_BASE, 4), 0, false},  \n\t{RCS0, RING_FORCE_TO_NONPRIV(RENDER_RING_BASE, 5), 0, false},  \n\t{RCS0, RING_FORCE_TO_NONPRIV(RENDER_RING_BASE, 6), 0, false},  \n\t{RCS0, RING_FORCE_TO_NONPRIV(RENDER_RING_BASE, 7), 0, false},  \n\t{RCS0, RING_FORCE_TO_NONPRIV(RENDER_RING_BASE, 8), 0, false},  \n\t{RCS0, RING_FORCE_TO_NONPRIV(RENDER_RING_BASE, 9), 0, false},  \n\t{RCS0, RING_FORCE_TO_NONPRIV(RENDER_RING_BASE, 10), 0, false},  \n\t{RCS0, RING_FORCE_TO_NONPRIV(RENDER_RING_BASE, 11), 0, false},  \n\t{RCS0, CACHE_MODE_1, 0xffff, true},  \n\t{RCS0, GEN7_GT_MODE, 0xffff, true},  \n\t{RCS0, CACHE_MODE_0_GEN7, 0xffff, true},  \n\t{RCS0, GEN7_COMMON_SLICE_CHICKEN1, 0xffff, true},  \n\t{RCS0, HDC_CHICKEN0, 0xffff, true},  \n\t{RCS0, VF_GUARDBAND, 0xffff, true},  \n\n\t{BCS0, RING_GFX_MODE(BLT_RING_BASE), 0xffff, false},  \n\t{BCS0, RING_MI_MODE(BLT_RING_BASE), 0xffff, false},  \n\t{BCS0, RING_INSTPM(BLT_RING_BASE), 0xffff, false},  \n\t{BCS0, RING_HWSTAM(BLT_RING_BASE), 0x0, false},  \n\t{BCS0, RING_EXCC(BLT_RING_BASE), 0xffff, false},  \n\t{RCS0, INVALID_MMIO_REG, 0, false }  \n};\n\nstatic struct engine_mmio gen9_engine_mmio_list[] __cacheline_aligned = {\n\t{RCS0, RING_MODE_GEN7(RENDER_RING_BASE), 0xffff, false},  \n\t{RCS0, GEN9_CTX_PREEMPT_REG, 0x0, false},  \n\t{RCS0, HWSTAM, 0x0, false},  \n\t{RCS0, INSTPM, 0xffff, true},  \n\t{RCS0, RING_FORCE_TO_NONPRIV(RENDER_RING_BASE, 0), 0, false},  \n\t{RCS0, RING_FORCE_TO_NONPRIV(RENDER_RING_BASE, 1), 0, false},  \n\t{RCS0, RING_FORCE_TO_NONPRIV(RENDER_RING_BASE, 2), 0, false},  \n\t{RCS0, RING_FORCE_TO_NONPRIV(RENDER_RING_BASE, 3), 0, false},  \n\t{RCS0, RING_FORCE_TO_NONPRIV(RENDER_RING_BASE, 4), 0, false},  \n\t{RCS0, RING_FORCE_TO_NONPRIV(RENDER_RING_BASE, 5), 0, false},  \n\t{RCS0, RING_FORCE_TO_NONPRIV(RENDER_RING_BASE, 6), 0, false},  \n\t{RCS0, RING_FORCE_TO_NONPRIV(RENDER_RING_BASE, 7), 0, false},  \n\t{RCS0, RING_FORCE_TO_NONPRIV(RENDER_RING_BASE, 8), 0, false},  \n\t{RCS0, RING_FORCE_TO_NONPRIV(RENDER_RING_BASE, 9), 0, false},  \n\t{RCS0, RING_FORCE_TO_NONPRIV(RENDER_RING_BASE, 10), 0, false},  \n\t{RCS0, RING_FORCE_TO_NONPRIV(RENDER_RING_BASE, 11), 0, false},  \n\t{RCS0, CACHE_MODE_1, 0xffff, true},  \n\t{RCS0, GEN7_GT_MODE, 0xffff, true},  \n\t{RCS0, CACHE_MODE_0_GEN7, 0xffff, true},  \n\t{RCS0, GEN7_COMMON_SLICE_CHICKEN1, 0xffff, true},  \n\t{RCS0, HDC_CHICKEN0, 0xffff, true},  \n\t{RCS0, VF_GUARDBAND, 0xffff, true},  \n\n\t{RCS0, GEN8_PRIVATE_PAT_LO, 0, false},  \n\t{RCS0, GEN8_PRIVATE_PAT_HI, 0, false},  \n\t{RCS0, GEN8_CS_CHICKEN1, 0xffff, true},  \n\t{RCS0, COMMON_SLICE_CHICKEN2, 0xffff, true},  \n\t{RCS0, GEN9_CS_DEBUG_MODE1, 0xffff, false},  \n\t{RCS0, _MMIO(0xb118), 0, false},  \n\t{RCS0, _MMIO(0xb11c), 0, false},  \n\t{RCS0, GEN9_SCRATCH_LNCF1, 0, false},  \n\t{RCS0, GEN7_HALF_SLICE_CHICKEN1, 0xffff, true},  \n\t{RCS0, _MMIO(0xe180), 0xffff, true},  \n\t{RCS0, _MMIO(0xe184), 0xffff, true},  \n\t{RCS0, _MMIO(0xe188), 0xffff, true},  \n\t{RCS0, _MMIO(0xe194), 0xffff, true},  \n\t{RCS0, _MMIO(0xe4f0), 0xffff, true},  \n\t{RCS0, TRVATTL3PTRDW(0), 0, true},  \n\t{RCS0, TRVATTL3PTRDW(1), 0, true},  \n\t{RCS0, TRNULLDETCT, 0, true},  \n\t{RCS0, TRINVTILEDETCT, 0, true},  \n\t{RCS0, TRVADR, 0, true},  \n\t{RCS0, TRTTE, 0, true},  \n\t{RCS0, _MMIO(0x4dfc), 0, true},\n\n\t{BCS0, RING_GFX_MODE(BLT_RING_BASE), 0xffff, false},  \n\t{BCS0, RING_MI_MODE(BLT_RING_BASE), 0xffff, false},  \n\t{BCS0, RING_INSTPM(BLT_RING_BASE), 0xffff, false},  \n\t{BCS0, RING_HWSTAM(BLT_RING_BASE), 0x0, false},  \n\t{BCS0, RING_EXCC(BLT_RING_BASE), 0xffff, false},  \n\n\t{VCS1, RING_EXCC(GEN8_BSD2_RING_BASE), 0xffff, false},  \n\n\t{VECS0, RING_EXCC(VEBOX_RING_BASE), 0xffff, false},  \n\n\t{RCS0, GEN8_HDC_CHICKEN1, 0xffff, true},  \n\t{RCS0, GEN9_CTX_PREEMPT_REG, 0x0, false},  \n\t{RCS0, GEN7_UCGCTL4, 0x0, false},  \n\t{RCS0, GAMT_CHKN_BIT_REG, 0x0, false},  \n\n\t{RCS0, GEN9_GAMT_ECO_REG_RW_IA, 0x0, false},  \n\t{RCS0, GEN9_CSFE_CHICKEN1_RCS, 0xffff, false},  \n\t{RCS0, _MMIO(0x20D8), 0xffff, true},  \n\n\t{RCS0, GEN8_GARBCNTL, 0x0, false},  \n\t{RCS0, GEN7_FF_THREAD_MODE, 0x0, false},  \n\t{RCS0, FF_SLICE_CS_CHICKEN2, 0xffff, false},  \n\t{RCS0, INVALID_MMIO_REG, 0, false }  \n};\n\nstatic struct {\n\tbool initialized;\n\tu32 control_table[I915_NUM_ENGINES][GEN9_MOCS_SIZE];\n\tu32 l3cc_table[GEN9_MOCS_SIZE / 2];\n} gen9_render_mocs;\n\nstatic u32 gen9_mocs_mmio_offset_list[] = {\n\t[RCS0]  = 0xc800,\n\t[VCS0]  = 0xc900,\n\t[VCS1]  = 0xca00,\n\t[BCS0]  = 0xcc00,\n\t[VECS0] = 0xcb00,\n};\n\nstatic void load_render_mocs(const struct intel_engine_cs *engine)\n{\n\tstruct intel_gvt *gvt = engine->i915->gvt;\n\tstruct intel_uncore *uncore = engine->uncore;\n\tu32 cnt = gvt->engine_mmio_list.mocs_mmio_offset_list_cnt;\n\tu32 *regs = gvt->engine_mmio_list.mocs_mmio_offset_list;\n\ti915_reg_t offset;\n\tint ring_id, i;\n\n\t \n\tif (!regs)\n\t\treturn;\n\n\tfor (ring_id = 0; ring_id < cnt; ring_id++) {\n\t\tif (!HAS_ENGINE(engine->gt, ring_id))\n\t\t\tcontinue;\n\n\t\toffset.reg = regs[ring_id];\n\t\tfor (i = 0; i < GEN9_MOCS_SIZE; i++) {\n\t\t\tgen9_render_mocs.control_table[ring_id][i] =\n\t\t\t\tintel_uncore_read_fw(uncore, offset);\n\t\t\toffset.reg += 4;\n\t\t}\n\t}\n\n\toffset.reg = 0xb020;\n\tfor (i = 0; i < GEN9_MOCS_SIZE / 2; i++) {\n\t\tgen9_render_mocs.l3cc_table[i] =\n\t\t\tintel_uncore_read_fw(uncore, offset);\n\t\toffset.reg += 4;\n\t}\n\tgen9_render_mocs.initialized = true;\n}\n\nstatic int\nrestore_context_mmio_for_inhibit(struct intel_vgpu *vgpu,\n\t\t\t\t struct i915_request *req)\n{\n\tu32 *cs;\n\tint ret;\n\tstruct engine_mmio *mmio;\n\tstruct intel_gvt *gvt = vgpu->gvt;\n\tint ring_id = req->engine->id;\n\tint count = gvt->engine_mmio_list.ctx_mmio_count[ring_id];\n\n\tif (count == 0)\n\t\treturn 0;\n\n\tret = req->engine->emit_flush(req, EMIT_BARRIER);\n\tif (ret)\n\t\treturn ret;\n\n\tcs = intel_ring_begin(req, count * 2 + 2);\n\tif (IS_ERR(cs))\n\t\treturn PTR_ERR(cs);\n\n\t*cs++ = MI_LOAD_REGISTER_IMM(count);\n\tfor (mmio = gvt->engine_mmio_list.mmio;\n\t     i915_mmio_reg_valid(mmio->reg); mmio++) {\n\t\tif (mmio->id != ring_id || !mmio->in_context)\n\t\t\tcontinue;\n\n\t\t*cs++ = i915_mmio_reg_offset(mmio->reg);\n\t\t*cs++ = vgpu_vreg_t(vgpu, mmio->reg) | (mmio->mask << 16);\n\t\tgvt_dbg_core(\"add lri reg pair 0x%x:0x%x in inhibit ctx, vgpu:%d, rind_id:%d\\n\",\n\t\t\t      *(cs-2), *(cs-1), vgpu->id, ring_id);\n\t}\n\n\t*cs++ = MI_NOOP;\n\tintel_ring_advance(req, cs);\n\n\tret = req->engine->emit_flush(req, EMIT_BARRIER);\n\tif (ret)\n\t\treturn ret;\n\n\treturn 0;\n}\n\nstatic int\nrestore_render_mocs_control_for_inhibit(struct intel_vgpu *vgpu,\n\t\t\t\t\tstruct i915_request *req)\n{\n\tunsigned int index;\n\tu32 *cs;\n\n\tcs = intel_ring_begin(req, 2 * GEN9_MOCS_SIZE + 2);\n\tif (IS_ERR(cs))\n\t\treturn PTR_ERR(cs);\n\n\t*cs++ = MI_LOAD_REGISTER_IMM(GEN9_MOCS_SIZE);\n\n\tfor (index = 0; index < GEN9_MOCS_SIZE; index++) {\n\t\t*cs++ = i915_mmio_reg_offset(GEN9_GFX_MOCS(index));\n\t\t*cs++ = vgpu_vreg_t(vgpu, GEN9_GFX_MOCS(index));\n\t\tgvt_dbg_core(\"add lri reg pair 0x%x:0x%x in inhibit ctx, vgpu:%d, rind_id:%d\\n\",\n\t\t\t      *(cs-2), *(cs-1), vgpu->id, req->engine->id);\n\n\t}\n\n\t*cs++ = MI_NOOP;\n\tintel_ring_advance(req, cs);\n\n\treturn 0;\n}\n\nstatic int\nrestore_render_mocs_l3cc_for_inhibit(struct intel_vgpu *vgpu,\n\t\t\t\t     struct i915_request *req)\n{\n\tunsigned int index;\n\tu32 *cs;\n\n\tcs = intel_ring_begin(req, 2 * GEN9_MOCS_SIZE / 2 + 2);\n\tif (IS_ERR(cs))\n\t\treturn PTR_ERR(cs);\n\n\t*cs++ = MI_LOAD_REGISTER_IMM(GEN9_MOCS_SIZE / 2);\n\n\tfor (index = 0; index < GEN9_MOCS_SIZE / 2; index++) {\n\t\t*cs++ = i915_mmio_reg_offset(GEN9_LNCFCMOCS(index));\n\t\t*cs++ = vgpu_vreg_t(vgpu, GEN9_LNCFCMOCS(index));\n\t\tgvt_dbg_core(\"add lri reg pair 0x%x:0x%x in inhibit ctx, vgpu:%d, rind_id:%d\\n\",\n\t\t\t      *(cs-2), *(cs-1), vgpu->id, req->engine->id);\n\n\t}\n\n\t*cs++ = MI_NOOP;\n\tintel_ring_advance(req, cs);\n\n\treturn 0;\n}\n\n \nint intel_vgpu_restore_inhibit_context(struct intel_vgpu *vgpu,\n\t\t\t\t       struct i915_request *req)\n{\n\tint ret;\n\tu32 *cs;\n\n\tcs = intel_ring_begin(req, 2);\n\tif (IS_ERR(cs))\n\t\treturn PTR_ERR(cs);\n\n\t*cs++ = MI_ARB_ON_OFF | MI_ARB_DISABLE;\n\t*cs++ = MI_NOOP;\n\tintel_ring_advance(req, cs);\n\n\tret = restore_context_mmio_for_inhibit(vgpu, req);\n\tif (ret)\n\t\tgoto out;\n\n\t \n\tif (req->engine->id != RCS0)\n\t\tgoto out;\n\n\tret = restore_render_mocs_control_for_inhibit(vgpu, req);\n\tif (ret)\n\t\tgoto out;\n\n\tret = restore_render_mocs_l3cc_for_inhibit(vgpu, req);\n\tif (ret)\n\t\tgoto out;\n\nout:\n\tcs = intel_ring_begin(req, 2);\n\tif (IS_ERR(cs))\n\t\treturn PTR_ERR(cs);\n\n\t*cs++ = MI_ARB_ON_OFF | MI_ARB_ENABLE;\n\t*cs++ = MI_NOOP;\n\tintel_ring_advance(req, cs);\n\n\treturn ret;\n}\n\nstatic u32 gen8_tlb_mmio_offset_list[] = {\n\t[RCS0]  = 0x4260,\n\t[VCS0]  = 0x4264,\n\t[VCS1]  = 0x4268,\n\t[BCS0]  = 0x426c,\n\t[VECS0] = 0x4270,\n};\n\nstatic void handle_tlb_pending_event(struct intel_vgpu *vgpu,\n\t\t\t\t     const struct intel_engine_cs *engine)\n{\n\tstruct intel_uncore *uncore = engine->uncore;\n\tstruct intel_vgpu_submission *s = &vgpu->submission;\n\tu32 *regs = vgpu->gvt->engine_mmio_list.tlb_mmio_offset_list;\n\tu32 cnt = vgpu->gvt->engine_mmio_list.tlb_mmio_offset_list_cnt;\n\tenum forcewake_domains fw;\n\ti915_reg_t reg;\n\n\tif (!regs)\n\t\treturn;\n\n\tif (drm_WARN_ON(&engine->i915->drm, engine->id >= cnt))\n\t\treturn;\n\n\tif (!test_and_clear_bit(engine->id, (void *)s->tlb_handle_pending))\n\t\treturn;\n\n\treg = _MMIO(regs[engine->id]);\n\n\t \n\tfw = intel_uncore_forcewake_for_reg(uncore, reg,\n\t\t\t\t\t    FW_REG_READ | FW_REG_WRITE);\n\tif (engine->id == RCS0 && GRAPHICS_VER(engine->i915) >= 9)\n\t\tfw |= FORCEWAKE_RENDER;\n\n\tintel_uncore_forcewake_get(uncore, fw);\n\n\tintel_uncore_write_fw(uncore, reg, 0x1);\n\n\tif (wait_for_atomic(intel_uncore_read_fw(uncore, reg) == 0, 50))\n\t\tgvt_vgpu_err(\"timeout in invalidate ring %s tlb\\n\",\n\t\t\t     engine->name);\n\telse\n\t\tvgpu_vreg_t(vgpu, reg) = 0;\n\n\tintel_uncore_forcewake_put(uncore, fw);\n\n\tgvt_dbg_core(\"invalidate TLB for ring %s\\n\", engine->name);\n}\n\nstatic void switch_mocs(struct intel_vgpu *pre, struct intel_vgpu *next,\n\t\t\tconst struct intel_engine_cs *engine)\n{\n\tu32 regs[] = {\n\t\t[RCS0]  = 0xc800,\n\t\t[VCS0]  = 0xc900,\n\t\t[VCS1]  = 0xca00,\n\t\t[BCS0]  = 0xcc00,\n\t\t[VECS0] = 0xcb00,\n\t};\n\tstruct intel_uncore *uncore = engine->uncore;\n\ti915_reg_t offset, l3_offset;\n\tu32 old_v, new_v;\n\tint i;\n\n\tif (drm_WARN_ON(&engine->i915->drm, engine->id >= ARRAY_SIZE(regs)))\n\t\treturn;\n\n\tif (engine->id == RCS0 && GRAPHICS_VER(engine->i915) == 9)\n\t\treturn;\n\n\tif (!pre && !gen9_render_mocs.initialized)\n\t\tload_render_mocs(engine);\n\n\toffset.reg = regs[engine->id];\n\tfor (i = 0; i < GEN9_MOCS_SIZE; i++) {\n\t\tif (pre)\n\t\t\told_v = vgpu_vreg_t(pre, offset);\n\t\telse\n\t\t\told_v = gen9_render_mocs.control_table[engine->id][i];\n\t\tif (next)\n\t\t\tnew_v = vgpu_vreg_t(next, offset);\n\t\telse\n\t\t\tnew_v = gen9_render_mocs.control_table[engine->id][i];\n\n\t\tif (old_v != new_v)\n\t\t\tintel_uncore_write_fw(uncore, offset, new_v);\n\n\t\toffset.reg += 4;\n\t}\n\n\tif (engine->id == RCS0) {\n\t\tl3_offset.reg = 0xb020;\n\t\tfor (i = 0; i < GEN9_MOCS_SIZE / 2; i++) {\n\t\t\tif (pre)\n\t\t\t\told_v = vgpu_vreg_t(pre, l3_offset);\n\t\t\telse\n\t\t\t\told_v = gen9_render_mocs.l3cc_table[i];\n\t\t\tif (next)\n\t\t\t\tnew_v = vgpu_vreg_t(next, l3_offset);\n\t\t\telse\n\t\t\t\tnew_v = gen9_render_mocs.l3cc_table[i];\n\n\t\t\tif (old_v != new_v)\n\t\t\t\tintel_uncore_write_fw(uncore, l3_offset, new_v);\n\n\t\t\tl3_offset.reg += 4;\n\t\t}\n\t}\n}\n\n#define CTX_CONTEXT_CONTROL_VAL\t0x03\n\nbool is_inhibit_context(struct intel_context *ce)\n{\n\tconst u32 *reg_state = ce->lrc_reg_state;\n\tu32 inhibit_mask =\n\t\t_MASKED_BIT_ENABLE(CTX_CTRL_ENGINE_CTX_RESTORE_INHIBIT);\n\n\treturn inhibit_mask ==\n\t\t(reg_state[CTX_CONTEXT_CONTROL_VAL] & inhibit_mask);\n}\n\n \nstatic void switch_mmio(struct intel_vgpu *pre,\n\t\t\tstruct intel_vgpu *next,\n\t\t\tconst struct intel_engine_cs *engine)\n{\n\tstruct intel_uncore *uncore = engine->uncore;\n\tstruct intel_vgpu_submission *s;\n\tstruct engine_mmio *mmio;\n\tu32 old_v, new_v;\n\n\tif (GRAPHICS_VER(engine->i915) >= 9)\n\t\tswitch_mocs(pre, next, engine);\n\n\tfor (mmio = engine->i915->gvt->engine_mmio_list.mmio;\n\t     i915_mmio_reg_valid(mmio->reg); mmio++) {\n\t\tif (mmio->id != engine->id)\n\t\t\tcontinue;\n\t\t \n\t\tif (GRAPHICS_VER(engine->i915) == 9 && mmio->in_context)\n\t\t\tcontinue;\n\n\t\t\n\t\tif (pre) {\n\t\t\tvgpu_vreg_t(pre, mmio->reg) =\n\t\t\t\tintel_uncore_read_fw(uncore, mmio->reg);\n\t\t\tif (mmio->mask)\n\t\t\t\tvgpu_vreg_t(pre, mmio->reg) &=\n\t\t\t\t\t~(mmio->mask << 16);\n\t\t\told_v = vgpu_vreg_t(pre, mmio->reg);\n\t\t} else {\n\t\t\told_v = mmio->value =\n\t\t\t\tintel_uncore_read_fw(uncore, mmio->reg);\n\t\t}\n\n\t\t\n\t\tif (next) {\n\t\t\ts = &next->submission;\n\t\t\t \n\t\t\tif (mmio->in_context &&\n\t\t\t    !is_inhibit_context(s->shadow[engine->id]))\n\t\t\t\tcontinue;\n\n\t\t\tif (mmio->mask)\n\t\t\t\tnew_v = vgpu_vreg_t(next, mmio->reg) |\n\t\t\t\t\t(mmio->mask << 16);\n\t\t\telse\n\t\t\t\tnew_v = vgpu_vreg_t(next, mmio->reg);\n\t\t} else {\n\t\t\tif (mmio->in_context)\n\t\t\t\tcontinue;\n\t\t\tif (mmio->mask)\n\t\t\t\tnew_v = mmio->value | (mmio->mask << 16);\n\t\t\telse\n\t\t\t\tnew_v = mmio->value;\n\t\t}\n\n\t\tintel_uncore_write_fw(uncore, mmio->reg, new_v);\n\n\t\ttrace_render_mmio(pre ? pre->id : 0,\n\t\t\t\t  next ? next->id : 0,\n\t\t\t\t  \"switch\",\n\t\t\t\t  i915_mmio_reg_offset(mmio->reg),\n\t\t\t\t  old_v, new_v);\n\t}\n\n\tif (next)\n\t\thandle_tlb_pending_event(next, engine);\n}\n\n \nvoid intel_gvt_switch_mmio(struct intel_vgpu *pre,\n\t\t\t   struct intel_vgpu *next,\n\t\t\t   const struct intel_engine_cs *engine)\n{\n\tif (WARN(!pre && !next, \"switch ring %s from host to HOST\\n\",\n\t\t engine->name))\n\t\treturn;\n\n\tgvt_dbg_render(\"switch ring %s from %s to %s\\n\", engine->name,\n\t\t       pre ? \"vGPU\" : \"host\", next ? \"vGPU\" : \"HOST\");\n\n\t \n\tintel_uncore_forcewake_get(engine->uncore, FORCEWAKE_ALL);\n\tswitch_mmio(pre, next, engine);\n\tintel_uncore_forcewake_put(engine->uncore, FORCEWAKE_ALL);\n}\n\n \nvoid intel_gvt_init_engine_mmio_context(struct intel_gvt *gvt)\n{\n\tstruct engine_mmio *mmio;\n\n\tif (GRAPHICS_VER(gvt->gt->i915) >= 9) {\n\t\tgvt->engine_mmio_list.mmio = gen9_engine_mmio_list;\n\t\tgvt->engine_mmio_list.tlb_mmio_offset_list = gen8_tlb_mmio_offset_list;\n\t\tgvt->engine_mmio_list.tlb_mmio_offset_list_cnt = ARRAY_SIZE(gen8_tlb_mmio_offset_list);\n\t\tgvt->engine_mmio_list.mocs_mmio_offset_list = gen9_mocs_mmio_offset_list;\n\t\tgvt->engine_mmio_list.mocs_mmio_offset_list_cnt = ARRAY_SIZE(gen9_mocs_mmio_offset_list);\n\t} else {\n\t\tgvt->engine_mmio_list.mmio = gen8_engine_mmio_list;\n\t\tgvt->engine_mmio_list.tlb_mmio_offset_list = gen8_tlb_mmio_offset_list;\n\t\tgvt->engine_mmio_list.tlb_mmio_offset_list_cnt = ARRAY_SIZE(gen8_tlb_mmio_offset_list);\n\t}\n\n\tfor (mmio = gvt->engine_mmio_list.mmio;\n\t     i915_mmio_reg_valid(mmio->reg); mmio++) {\n\t\tif (mmio->in_context) {\n\t\t\tgvt->engine_mmio_list.ctx_mmio_count[mmio->id]++;\n\t\t\tintel_gvt_mmio_set_sr_in_ctx(gvt, mmio->reg.reg);\n\t\t}\n\t}\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}