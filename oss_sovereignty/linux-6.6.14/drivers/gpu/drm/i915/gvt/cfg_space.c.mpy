{
  "module_name": "cfg_space.c",
  "hash_id": "5704da5432d3ec9d90a3f236b2dc9f00fc5d76d7d21fcdd76220dc2e42d63a10",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/i915/gvt/cfg_space.c",
  "human_readable_source": " \n\n#include \"i915_drv.h\"\n#include \"gvt.h\"\n#include \"intel_pci_config.h\"\n\nenum {\n\tINTEL_GVT_PCI_BAR_GTTMMIO = 0,\n\tINTEL_GVT_PCI_BAR_APERTURE,\n\tINTEL_GVT_PCI_BAR_PIO,\n\tINTEL_GVT_PCI_BAR_MAX,\n};\n\n \nstatic const u8 pci_cfg_space_rw_bmp[PCI_INTERRUPT_LINE + 4] = {\n\t[PCI_COMMAND]\t\t= 0xff, 0x07,\n\t[PCI_STATUS]\t\t= 0x00, 0xf9,  \n\t[PCI_CACHE_LINE_SIZE]\t= 0xff,\n\t[PCI_BASE_ADDRESS_0 ... PCI_CARDBUS_CIS - 1] = 0xff,\n\t[PCI_ROM_ADDRESS]\t= 0x01, 0xf8, 0xff, 0xff,\n\t[PCI_INTERRUPT_LINE]\t= 0xff,\n};\n\n \nstatic void vgpu_pci_cfg_mem_write(struct intel_vgpu *vgpu, unsigned int off,\n\t\t\t\t   u8 *src, unsigned int bytes)\n{\n\tu8 *cfg_base = vgpu_cfg_space(vgpu);\n\tu8 mask, new, old;\n\tpci_power_t pwr;\n\tint i = 0;\n\n\tfor (; i < bytes && (off + i < sizeof(pci_cfg_space_rw_bmp)); i++) {\n\t\tmask = pci_cfg_space_rw_bmp[off + i];\n\t\told = cfg_base[off + i];\n\t\tnew = src[i] & mask;\n\n\t\t \n\t\tif (off + i == PCI_STATUS + 1)\n\t\t\tnew = (~new & old) & mask;\n\n\t\tcfg_base[off + i] = (old & ~mask) | new;\n\t}\n\n\t \n\tif (i < bytes)\n\t\tmemcpy(cfg_base + off + i, src + i, bytes - i);\n\n\tif (off == vgpu->cfg_space.pmcsr_off && vgpu->cfg_space.pmcsr_off) {\n\t\tpwr = (pci_power_t __force)(*(u16*)(&vgpu_cfg_space(vgpu)[off])\n\t\t\t& PCI_PM_CTRL_STATE_MASK);\n\t\tif (pwr == PCI_D3hot)\n\t\t\tvgpu->d3_entered = true;\n\t\tgvt_dbg_core(\"vgpu-%d power status changed to %d\\n\",\n\t\t\t     vgpu->id, pwr);\n\t}\n}\n\n \nint intel_vgpu_emulate_cfg_read(struct intel_vgpu *vgpu, unsigned int offset,\n\tvoid *p_data, unsigned int bytes)\n{\n\tstruct drm_i915_private *i915 = vgpu->gvt->gt->i915;\n\n\tif (drm_WARN_ON(&i915->drm, bytes > 4))\n\t\treturn -EINVAL;\n\n\tif (drm_WARN_ON(&i915->drm,\n\t\t\toffset + bytes > vgpu->gvt->device_info.cfg_space_size))\n\t\treturn -EINVAL;\n\n\tmemcpy(p_data, vgpu_cfg_space(vgpu) + offset, bytes);\n\treturn 0;\n}\n\nstatic void map_aperture(struct intel_vgpu *vgpu, bool map)\n{\n\tif (map != vgpu->cfg_space.bar[INTEL_GVT_PCI_BAR_APERTURE].tracked)\n\t\tvgpu->cfg_space.bar[INTEL_GVT_PCI_BAR_APERTURE].tracked = map;\n}\n\nstatic void trap_gttmmio(struct intel_vgpu *vgpu, bool trap)\n{\n\tif (trap != vgpu->cfg_space.bar[INTEL_GVT_PCI_BAR_GTTMMIO].tracked)\n\t\tvgpu->cfg_space.bar[INTEL_GVT_PCI_BAR_GTTMMIO].tracked = trap;\n}\n\nstatic int emulate_pci_command_write(struct intel_vgpu *vgpu,\n\tunsigned int offset, void *p_data, unsigned int bytes)\n{\n\tu8 old = vgpu_cfg_space(vgpu)[offset];\n\tu8 new = *(u8 *)p_data;\n\tu8 changed = old ^ new;\n\n\tvgpu_pci_cfg_mem_write(vgpu, offset, p_data, bytes);\n\tif (!(changed & PCI_COMMAND_MEMORY))\n\t\treturn 0;\n\n\tif (old & PCI_COMMAND_MEMORY) {\n\t\ttrap_gttmmio(vgpu, false);\n\t\tmap_aperture(vgpu, false);\n\t} else {\n\t\ttrap_gttmmio(vgpu, true);\n\t\tmap_aperture(vgpu, true);\n\t}\n\n\treturn 0;\n}\n\nstatic int emulate_pci_rom_bar_write(struct intel_vgpu *vgpu,\n\tunsigned int offset, void *p_data, unsigned int bytes)\n{\n\tu32 *pval = (u32 *)(vgpu_cfg_space(vgpu) + offset);\n\tu32 new = *(u32 *)(p_data);\n\n\tif ((new & PCI_ROM_ADDRESS_MASK) == PCI_ROM_ADDRESS_MASK)\n\t\t \n\t\t*pval = 0;\n\telse\n\t\tvgpu_pci_cfg_mem_write(vgpu, offset, p_data, bytes);\n\treturn 0;\n}\n\nstatic void emulate_pci_bar_write(struct intel_vgpu *vgpu, unsigned int offset,\n\tvoid *p_data, unsigned int bytes)\n{\n\tu32 new = *(u32 *)(p_data);\n\tbool lo = IS_ALIGNED(offset, 8);\n\tu64 size;\n\tbool mmio_enabled =\n\t\tvgpu_cfg_space(vgpu)[PCI_COMMAND] & PCI_COMMAND_MEMORY;\n\tstruct intel_vgpu_pci_bar *bars = vgpu->cfg_space.bar;\n\n\t \n\tif (new == 0xffffffff) {\n\t\tswitch (offset) {\n\t\tcase PCI_BASE_ADDRESS_0:\n\t\tcase PCI_BASE_ADDRESS_1:\n\t\t\tsize = ~(bars[INTEL_GVT_PCI_BAR_GTTMMIO].size -1);\n\t\t\tintel_vgpu_write_pci_bar(vgpu, offset,\n\t\t\t\t\t\tsize >> (lo ? 0 : 32), lo);\n\t\t\t \n\t\t\ttrap_gttmmio(vgpu, false);\n\t\t\tbreak;\n\t\tcase PCI_BASE_ADDRESS_2:\n\t\tcase PCI_BASE_ADDRESS_3:\n\t\t\tsize = ~(bars[INTEL_GVT_PCI_BAR_APERTURE].size -1);\n\t\t\tintel_vgpu_write_pci_bar(vgpu, offset,\n\t\t\t\t\t\tsize >> (lo ? 0 : 32), lo);\n\t\t\tmap_aperture(vgpu, false);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t \n\t\t\tintel_vgpu_write_pci_bar(vgpu, offset, 0x0, false);\n\t\t}\n\t} else {\n\t\tswitch (offset) {\n\t\tcase PCI_BASE_ADDRESS_0:\n\t\tcase PCI_BASE_ADDRESS_1:\n\t\t\t \n\t\t\ttrap_gttmmio(vgpu, false);\n\t\t\tintel_vgpu_write_pci_bar(vgpu, offset, new, lo);\n\t\t\ttrap_gttmmio(vgpu, mmio_enabled);\n\t\t\tbreak;\n\t\tcase PCI_BASE_ADDRESS_2:\n\t\tcase PCI_BASE_ADDRESS_3:\n\t\t\tmap_aperture(vgpu, false);\n\t\t\tintel_vgpu_write_pci_bar(vgpu, offset, new, lo);\n\t\t\tmap_aperture(vgpu, mmio_enabled);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tintel_vgpu_write_pci_bar(vgpu, offset, new, lo);\n\t\t}\n\t}\n}\n\n \nint intel_vgpu_emulate_cfg_write(struct intel_vgpu *vgpu, unsigned int offset,\n\tvoid *p_data, unsigned int bytes)\n{\n\tstruct drm_i915_private *i915 = vgpu->gvt->gt->i915;\n\tint ret;\n\n\tif (drm_WARN_ON(&i915->drm, bytes > 4))\n\t\treturn -EINVAL;\n\n\tif (drm_WARN_ON(&i915->drm,\n\t\t\toffset + bytes > vgpu->gvt->device_info.cfg_space_size))\n\t\treturn -EINVAL;\n\n\t \n\tif (IS_ALIGNED(offset, 2) && offset == PCI_COMMAND) {\n\t\tif (drm_WARN_ON(&i915->drm, bytes > 2))\n\t\t\treturn -EINVAL;\n\t\treturn emulate_pci_command_write(vgpu, offset, p_data, bytes);\n\t}\n\n\tswitch (rounddown(offset, 4)) {\n\tcase PCI_ROM_ADDRESS:\n\t\tif (drm_WARN_ON(&i915->drm, !IS_ALIGNED(offset, 4)))\n\t\t\treturn -EINVAL;\n\t\treturn emulate_pci_rom_bar_write(vgpu, offset, p_data, bytes);\n\n\tcase PCI_BASE_ADDRESS_0 ... PCI_BASE_ADDRESS_5:\n\t\tif (drm_WARN_ON(&i915->drm, !IS_ALIGNED(offset, 4)))\n\t\t\treturn -EINVAL;\n\t\temulate_pci_bar_write(vgpu, offset, p_data, bytes);\n\t\tbreak;\n\tcase INTEL_GVT_PCI_SWSCI:\n\t\tif (drm_WARN_ON(&i915->drm, !IS_ALIGNED(offset, 4)))\n\t\t\treturn -EINVAL;\n\t\tret = intel_vgpu_emulate_opregion_request(vgpu, *(u32 *)p_data);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tbreak;\n\n\tcase INTEL_GVT_PCI_OPREGION:\n\t\tif (drm_WARN_ON(&i915->drm, !IS_ALIGNED(offset, 4)))\n\t\t\treturn -EINVAL;\n\t\tret = intel_vgpu_opregion_base_write_handler(vgpu,\n\t\t\t\t\t\t   *(u32 *)p_data);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tvgpu_pci_cfg_mem_write(vgpu, offset, p_data, bytes);\n\t\tbreak;\n\tdefault:\n\t\tvgpu_pci_cfg_mem_write(vgpu, offset, p_data, bytes);\n\t\tbreak;\n\t}\n\treturn 0;\n}\n\n \nvoid intel_vgpu_init_cfg_space(struct intel_vgpu *vgpu,\n\t\t\t       bool primary)\n{\n\tstruct intel_gvt *gvt = vgpu->gvt;\n\tstruct pci_dev *pdev = to_pci_dev(gvt->gt->i915->drm.dev);\n\tconst struct intel_gvt_device_info *info = &gvt->device_info;\n\tu16 *gmch_ctl;\n\tu8 next;\n\n\tmemcpy(vgpu_cfg_space(vgpu), gvt->firmware.cfg_space,\n\t       info->cfg_space_size);\n\n\tif (!primary) {\n\t\tvgpu_cfg_space(vgpu)[PCI_CLASS_DEVICE] =\n\t\t\tINTEL_GVT_PCI_CLASS_VGA_OTHER;\n\t\tvgpu_cfg_space(vgpu)[PCI_CLASS_PROG] =\n\t\t\tINTEL_GVT_PCI_CLASS_VGA_OTHER;\n\t}\n\n\t \n\tgmch_ctl = (u16 *)(vgpu_cfg_space(vgpu) + INTEL_GVT_PCI_GMCH_CONTROL);\n\t*gmch_ctl &= ~(BDW_GMCH_GMS_MASK << BDW_GMCH_GMS_SHIFT);\n\n\tintel_vgpu_write_pci_bar(vgpu, PCI_BASE_ADDRESS_2,\n\t\t\t\t gvt_aperture_pa_base(gvt), true);\n\n\tvgpu_cfg_space(vgpu)[PCI_COMMAND] &= ~(PCI_COMMAND_IO\n\t\t\t\t\t     | PCI_COMMAND_MEMORY\n\t\t\t\t\t     | PCI_COMMAND_MASTER);\n\t \n\tmemset(vgpu_cfg_space(vgpu) + PCI_BASE_ADDRESS_1, 0, 4);\n\tmemset(vgpu_cfg_space(vgpu) + PCI_BASE_ADDRESS_3, 0, 4);\n\tmemset(vgpu_cfg_space(vgpu) + PCI_BASE_ADDRESS_4, 0, 8);\n\tmemset(vgpu_cfg_space(vgpu) + INTEL_GVT_PCI_OPREGION, 0, 4);\n\n\tvgpu->cfg_space.bar[INTEL_GVT_PCI_BAR_GTTMMIO].size =\n\t\tpci_resource_len(pdev, GEN4_GTTMMADR_BAR);\n\tvgpu->cfg_space.bar[INTEL_GVT_PCI_BAR_APERTURE].size =\n\t\tpci_resource_len(pdev, GEN4_GMADR_BAR);\n\n\tmemset(vgpu_cfg_space(vgpu) + PCI_ROM_ADDRESS, 0, 4);\n\n\t \n\tvgpu->cfg_space.pmcsr_off = 0;\n\tif (vgpu_cfg_space(vgpu)[PCI_STATUS] & PCI_STATUS_CAP_LIST) {\n\t\tnext = vgpu_cfg_space(vgpu)[PCI_CAPABILITY_LIST];\n\t\tdo {\n\t\t\tif (vgpu_cfg_space(vgpu)[next + PCI_CAP_LIST_ID] == PCI_CAP_ID_PM) {\n\t\t\t\tvgpu->cfg_space.pmcsr_off = next + PCI_PM_CTRL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tnext = vgpu_cfg_space(vgpu)[next + PCI_CAP_LIST_NEXT];\n\t\t} while (next);\n\t}\n}\n\n \nvoid intel_vgpu_reset_cfg_space(struct intel_vgpu *vgpu)\n{\n\tu8 cmd = vgpu_cfg_space(vgpu)[PCI_COMMAND];\n\tbool primary = vgpu_cfg_space(vgpu)[PCI_CLASS_DEVICE] !=\n\t\t\t\tINTEL_GVT_PCI_CLASS_VGA_OTHER;\n\n\tif (cmd & PCI_COMMAND_MEMORY) {\n\t\ttrap_gttmmio(vgpu, false);\n\t\tmap_aperture(vgpu, false);\n\t}\n\n\t \n\tintel_vgpu_init_cfg_space(vgpu, primary);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}