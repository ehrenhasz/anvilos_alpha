{
  "module_name": "debugfs.c",
  "hash_id": "348db3598eb4e35326c19f0c3f49c559488853da17a20691a4281f52c209661b",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/i915/gvt/debugfs.c",
  "human_readable_source": " \n#include <linux/debugfs.h>\n#include <linux/list_sort.h>\n#include \"i915_drv.h\"\n#include \"gvt.h\"\n\nstruct mmio_diff_param {\n\tstruct intel_vgpu *vgpu;\n\tint total;\n\tint diff;\n\tstruct list_head diff_mmio_list;\n};\n\nstruct diff_mmio {\n\tstruct list_head node;\n\tu32 offset;\n\tu32 preg;\n\tu32 vreg;\n};\n\n \nstatic int mmio_offset_compare(void *priv,\n\tconst struct list_head *a, const struct list_head *b)\n{\n\tstruct diff_mmio *ma;\n\tstruct diff_mmio *mb;\n\n\tma = container_of(a, struct diff_mmio, node);\n\tmb = container_of(b, struct diff_mmio, node);\n\tif (ma->offset < mb->offset)\n\t\treturn -1;\n\telse if (ma->offset > mb->offset)\n\t\treturn 1;\n\treturn 0;\n}\n\nstatic inline int mmio_diff_handler(struct intel_gvt *gvt,\n\t\t\t\t    u32 offset, void *data)\n{\n\tstruct mmio_diff_param *param = data;\n\tstruct diff_mmio *node;\n\tu32 preg, vreg;\n\n\tpreg = intel_uncore_read_notrace(gvt->gt->uncore, _MMIO(offset));\n\tvreg = vgpu_vreg(param->vgpu, offset);\n\n\tif (preg != vreg) {\n\t\tnode = kmalloc(sizeof(*node), GFP_ATOMIC);\n\t\tif (!node)\n\t\t\treturn -ENOMEM;\n\n\t\tnode->offset = offset;\n\t\tnode->preg = preg;\n\t\tnode->vreg = vreg;\n\t\tlist_add(&node->node, &param->diff_mmio_list);\n\t\tparam->diff++;\n\t}\n\tparam->total++;\n\treturn 0;\n}\n\n \nstatic int vgpu_mmio_diff_show(struct seq_file *s, void *unused)\n{\n\tstruct intel_vgpu *vgpu = s->private;\n\tstruct intel_gvt *gvt = vgpu->gvt;\n\tstruct mmio_diff_param param = {\n\t\t.vgpu = vgpu,\n\t\t.total = 0,\n\t\t.diff = 0,\n\t};\n\tstruct diff_mmio *node, *next;\n\n\tINIT_LIST_HEAD(&param.diff_mmio_list);\n\n\tmutex_lock(&gvt->lock);\n\tspin_lock_bh(&gvt->scheduler.mmio_context_lock);\n\n\tmmio_hw_access_pre(gvt->gt);\n\t \n\tintel_gvt_for_each_tracked_mmio(gvt, mmio_diff_handler, &param);\n\tmmio_hw_access_post(gvt->gt);\n\n\tspin_unlock_bh(&gvt->scheduler.mmio_context_lock);\n\tmutex_unlock(&gvt->lock);\n\n\t \n\tlist_sort(NULL, &param.diff_mmio_list, mmio_offset_compare);\n\n\tseq_printf(s, \"%-8s %-8s %-8s %-8s\\n\", \"Offset\", \"HW\", \"vGPU\", \"Diff\");\n\tlist_for_each_entry_safe(node, next, &param.diff_mmio_list, node) {\n\t\tu32 diff = node->preg ^ node->vreg;\n\n\t\tseq_printf(s, \"%08x %08x %08x %*pbl\\n\",\n\t\t\t   node->offset, node->preg, node->vreg,\n\t\t\t   32, &diff);\n\t\tlist_del(&node->node);\n\t\tkfree(node);\n\t}\n\tseq_printf(s, \"Total: %d, Diff: %d\\n\", param.total, param.diff);\n\treturn 0;\n}\nDEFINE_SHOW_ATTRIBUTE(vgpu_mmio_diff);\n\nstatic int\nvgpu_scan_nonprivbb_get(void *data, u64 *val)\n{\n\tstruct intel_vgpu *vgpu = (struct intel_vgpu *)data;\n\n\t*val = vgpu->scan_nonprivbb;\n\treturn 0;\n}\n\n \nstatic int\nvgpu_scan_nonprivbb_set(void *data, u64 val)\n{\n\tstruct intel_vgpu *vgpu = (struct intel_vgpu *)data;\n\n\tvgpu->scan_nonprivbb = val;\n\treturn 0;\n}\n\nDEFINE_DEBUGFS_ATTRIBUTE(vgpu_scan_nonprivbb_fops,\n\t\t\t vgpu_scan_nonprivbb_get, vgpu_scan_nonprivbb_set,\n\t\t\t \"0x%llx\\n\");\n\nstatic int vgpu_status_get(void *data, u64 *val)\n{\n\tstruct intel_vgpu *vgpu = (struct intel_vgpu *)data;\n\n\t*val = 0;\n\n\tif (test_bit(INTEL_VGPU_STATUS_ATTACHED, vgpu->status))\n\t\t*val |= (1 << INTEL_VGPU_STATUS_ATTACHED);\n\tif (test_bit(INTEL_VGPU_STATUS_ACTIVE, vgpu->status))\n\t\t*val |= (1 << INTEL_VGPU_STATUS_ACTIVE);\n\n\treturn 0;\n}\n\nDEFINE_DEBUGFS_ATTRIBUTE(vgpu_status_fops, vgpu_status_get, NULL, \"0x%llx\\n\");\n\n \nvoid intel_gvt_debugfs_add_vgpu(struct intel_vgpu *vgpu)\n{\n\tchar name[16] = \"\";\n\n\tsnprintf(name, 16, \"vgpu%d\", vgpu->id);\n\tvgpu->debugfs = debugfs_create_dir(name, vgpu->gvt->debugfs_root);\n\n\tdebugfs_create_file(\"mmio_diff\", 0444, vgpu->debugfs, vgpu,\n\t\t\t    &vgpu_mmio_diff_fops);\n\tdebugfs_create_file_unsafe(\"scan_nonprivbb\", 0644, vgpu->debugfs, vgpu,\n\t\t\t\t   &vgpu_scan_nonprivbb_fops);\n\tdebugfs_create_file_unsafe(\"status\", 0644, vgpu->debugfs, vgpu,\n\t\t\t\t   &vgpu_status_fops);\n}\n\n \nvoid intel_gvt_debugfs_remove_vgpu(struct intel_vgpu *vgpu)\n{\n\tstruct intel_gvt *gvt = vgpu->gvt;\n\tstruct drm_minor *minor = gvt->gt->i915->drm.primary;\n\n\tif (minor->debugfs_root && gvt->debugfs_root) {\n\t\tdebugfs_remove_recursive(vgpu->debugfs);\n\t\tvgpu->debugfs = NULL;\n\t}\n}\n\n \nvoid intel_gvt_debugfs_init(struct intel_gvt *gvt)\n{\n\tstruct drm_minor *minor = gvt->gt->i915->drm.primary;\n\n\tgvt->debugfs_root = debugfs_create_dir(\"gvt\", minor->debugfs_root);\n\n\tdebugfs_create_ulong(\"num_tracked_mmio\", 0444, gvt->debugfs_root,\n\t\t\t     &gvt->mmio.num_tracked_mmio);\n}\n\n \nvoid intel_gvt_debugfs_clean(struct intel_gvt *gvt)\n{\n\tstruct drm_minor *minor = gvt->gt->i915->drm.primary;\n\n\tif (minor->debugfs_root) {\n\t\tdebugfs_remove_recursive(gvt->debugfs_root);\n\t\tgvt->debugfs_root = NULL;\n\t}\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}