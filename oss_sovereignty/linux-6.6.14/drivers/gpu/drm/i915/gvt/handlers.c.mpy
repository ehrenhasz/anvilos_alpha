{
  "module_name": "handlers.c",
  "hash_id": "fce925393315f9e56d323c48413c9954ca93daa4361be8ede11b4c10a00babaa",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/i915/gvt/handlers.c",
  "human_readable_source": " \n\n#include \"i915_drv.h\"\n#include \"i915_reg.h\"\n#include \"gvt.h\"\n#include \"i915_pvinfo.h\"\n#include \"intel_mchbar_regs.h\"\n#include \"display/intel_display_types.h\"\n#include \"display/intel_dmc_regs.h\"\n#include \"display/intel_dp_aux_regs.h\"\n#include \"display/intel_dpio_phy.h\"\n#include \"display/intel_fbc.h\"\n#include \"display/intel_fdi_regs.h\"\n#include \"display/intel_pps_regs.h\"\n#include \"display/intel_psr_regs.h\"\n#include \"display/skl_watermark_regs.h\"\n#include \"display/vlv_dsi_pll_regs.h\"\n#include \"gt/intel_gt_regs.h\"\n\n \n#define PCH_PP_STATUS  _MMIO(0xc7200)\n#define PCH_PP_CONTROL _MMIO(0xc7204)\n#define PCH_PP_ON_DELAYS _MMIO(0xc7208)\n#define PCH_PP_OFF_DELAYS _MMIO(0xc720c)\n#define PCH_PP_DIVISOR _MMIO(0xc7210)\n\nunsigned long intel_gvt_get_device_type(struct intel_gvt *gvt)\n{\n\tstruct drm_i915_private *i915 = gvt->gt->i915;\n\n\tif (IS_BROADWELL(i915))\n\t\treturn D_BDW;\n\telse if (IS_SKYLAKE(i915))\n\t\treturn D_SKL;\n\telse if (IS_KABYLAKE(i915))\n\t\treturn D_KBL;\n\telse if (IS_BROXTON(i915))\n\t\treturn D_BXT;\n\telse if (IS_COFFEELAKE(i915) || IS_COMETLAKE(i915))\n\t\treturn D_CFL;\n\n\treturn 0;\n}\n\nstatic bool intel_gvt_match_device(struct intel_gvt *gvt,\n\t\tunsigned long device)\n{\n\treturn intel_gvt_get_device_type(gvt) & device;\n}\n\nstatic void read_vreg(struct intel_vgpu *vgpu, unsigned int offset,\n\tvoid *p_data, unsigned int bytes)\n{\n\tmemcpy(p_data, &vgpu_vreg(vgpu, offset), bytes);\n}\n\nstatic void write_vreg(struct intel_vgpu *vgpu, unsigned int offset,\n\tvoid *p_data, unsigned int bytes)\n{\n\tmemcpy(&vgpu_vreg(vgpu, offset), p_data, bytes);\n}\n\nstruct intel_gvt_mmio_info *intel_gvt_find_mmio_info(struct intel_gvt *gvt,\n\t\t\t\t\t\t  unsigned int offset)\n{\n\tstruct intel_gvt_mmio_info *e;\n\n\thash_for_each_possible(gvt->mmio.mmio_info_table, e, node, offset) {\n\t\tif (e->offset == offset)\n\t\t\treturn e;\n\t}\n\treturn NULL;\n}\n\nstatic int setup_mmio_info(struct intel_gvt *gvt, u32 offset, u32 size,\n\t\t\t   u16 flags, u32 addr_mask, u32 ro_mask, u32 device,\n\t\t\t   gvt_mmio_func read, gvt_mmio_func write)\n{\n\tstruct intel_gvt_mmio_info *p;\n\tu32 start, end, i;\n\n\tif (!intel_gvt_match_device(gvt, device))\n\t\treturn 0;\n\n\tif (WARN_ON(!IS_ALIGNED(offset, 4)))\n\t\treturn -EINVAL;\n\n\tstart = offset;\n\tend = offset + size;\n\n\tfor (i = start; i < end; i += 4) {\n\t\tp = intel_gvt_find_mmio_info(gvt, i);\n\t\tif (!p) {\n\t\t\tWARN(1, \"assign a handler to a non-tracked mmio %x\\n\",\n\t\t\t\ti);\n\t\t\treturn -ENODEV;\n\t\t}\n\t\tp->ro_mask = ro_mask;\n\t\tgvt->mmio.mmio_attribute[i / 4] = flags;\n\t\tif (read)\n\t\t\tp->read = read;\n\t\tif (write)\n\t\t\tp->write = write;\n\t}\n\treturn 0;\n}\n\n \nconst struct intel_engine_cs *\nintel_gvt_render_mmio_to_engine(struct intel_gvt *gvt, unsigned int offset)\n{\n\tstruct intel_engine_cs *engine;\n\tenum intel_engine_id id;\n\n\toffset &= ~GENMASK(11, 0);\n\tfor_each_engine(engine, gvt->gt, id)\n\t\tif (engine->mmio_base == offset)\n\t\t\treturn engine;\n\n\treturn NULL;\n}\n\n#define offset_to_fence_num(offset) \\\n\t((offset - i915_mmio_reg_offset(FENCE_REG_GEN6_LO(0))) >> 3)\n\n#define fence_num_to_offset(num) \\\n\t(num * 8 + i915_mmio_reg_offset(FENCE_REG_GEN6_LO(0)))\n\n\nvoid enter_failsafe_mode(struct intel_vgpu *vgpu, int reason)\n{\n\tswitch (reason) {\n\tcase GVT_FAILSAFE_UNSUPPORTED_GUEST:\n\t\tpr_err(\"Detected your guest driver doesn't support GVT-g.\\n\");\n\t\tbreak;\n\tcase GVT_FAILSAFE_INSUFFICIENT_RESOURCE:\n\t\tpr_err(\"Graphics resource is not enough for the guest\\n\");\n\t\tbreak;\n\tcase GVT_FAILSAFE_GUEST_ERR:\n\t\tpr_err(\"GVT Internal error  for the guest\\n\");\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\tpr_err(\"Now vgpu %d will enter failsafe mode.\\n\", vgpu->id);\n\tvgpu->failsafe = true;\n}\n\nstatic int sanitize_fence_mmio_access(struct intel_vgpu *vgpu,\n\t\tunsigned int fence_num, void *p_data, unsigned int bytes)\n{\n\tunsigned int max_fence = vgpu_fence_sz(vgpu);\n\n\tif (fence_num >= max_fence) {\n\t\tgvt_vgpu_err(\"access oob fence reg %d/%d\\n\",\n\t\t\t     fence_num, max_fence);\n\n\t\t \n\t\tif (!vgpu->pv_notified)\n\t\t\tenter_failsafe_mode(vgpu,\n\t\t\t\t\tGVT_FAILSAFE_UNSUPPORTED_GUEST);\n\n\t\tmemset(p_data, 0, bytes);\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}\n\nstatic int gamw_echo_dev_rw_ia_write(struct intel_vgpu *vgpu,\n\t\tunsigned int offset, void *p_data, unsigned int bytes)\n{\n\tu32 ips = (*(u32 *)p_data) & GAMW_ECO_ENABLE_64K_IPS_FIELD;\n\n\tif (GRAPHICS_VER(vgpu->gvt->gt->i915) <= 10) {\n\t\tif (ips == GAMW_ECO_ENABLE_64K_IPS_FIELD)\n\t\t\tgvt_dbg_core(\"vgpu%d: ips enabled\\n\", vgpu->id);\n\t\telse if (!ips)\n\t\t\tgvt_dbg_core(\"vgpu%d: ips disabled\\n\", vgpu->id);\n\t\telse {\n\t\t\t \n\t\t\tgvt_vgpu_err(\"Unsupported IPS setting %x, cannot enable 64K gtt.\\n\",\n\t\t\t\t     ips);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\twrite_vreg(vgpu, offset, p_data, bytes);\n\treturn 0;\n}\n\nstatic int fence_mmio_read(struct intel_vgpu *vgpu, unsigned int off,\n\t\tvoid *p_data, unsigned int bytes)\n{\n\tint ret;\n\n\tret = sanitize_fence_mmio_access(vgpu, offset_to_fence_num(off),\n\t\t\tp_data, bytes);\n\tif (ret)\n\t\treturn ret;\n\tread_vreg(vgpu, off, p_data, bytes);\n\treturn 0;\n}\n\nstatic int fence_mmio_write(struct intel_vgpu *vgpu, unsigned int off,\n\t\tvoid *p_data, unsigned int bytes)\n{\n\tstruct intel_gvt *gvt = vgpu->gvt;\n\tunsigned int fence_num = offset_to_fence_num(off);\n\tint ret;\n\n\tret = sanitize_fence_mmio_access(vgpu, fence_num, p_data, bytes);\n\tif (ret)\n\t\treturn ret;\n\twrite_vreg(vgpu, off, p_data, bytes);\n\n\tmmio_hw_access_pre(gvt->gt);\n\tintel_vgpu_write_fence(vgpu, fence_num,\n\t\t\tvgpu_vreg64(vgpu, fence_num_to_offset(fence_num)));\n\tmmio_hw_access_post(gvt->gt);\n\treturn 0;\n}\n\n#define CALC_MODE_MASK_REG(old, new) \\\n\t(((new) & GENMASK(31, 16)) \\\n\t | ((((old) & GENMASK(15, 0)) & ~((new) >> 16)) \\\n\t | ((new) & ((new) >> 16))))\n\nstatic int mul_force_wake_write(struct intel_vgpu *vgpu,\n\t\tunsigned int offset, void *p_data, unsigned int bytes)\n{\n\tu32 old, new;\n\tu32 ack_reg_offset;\n\n\told = vgpu_vreg(vgpu, offset);\n\tnew = CALC_MODE_MASK_REG(old, *(u32 *)p_data);\n\n\tif (GRAPHICS_VER(vgpu->gvt->gt->i915)  >=  9) {\n\t\tswitch (offset) {\n\t\tcase FORCEWAKE_RENDER_GEN9_REG:\n\t\t\tack_reg_offset = FORCEWAKE_ACK_RENDER_GEN9_REG;\n\t\t\tbreak;\n\t\tcase FORCEWAKE_GT_GEN9_REG:\n\t\t\tack_reg_offset = FORCEWAKE_ACK_GT_GEN9_REG;\n\t\t\tbreak;\n\t\tcase FORCEWAKE_MEDIA_GEN9_REG:\n\t\t\tack_reg_offset = FORCEWAKE_ACK_MEDIA_GEN9_REG;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t \n\t\t\tgvt_vgpu_err(\"invalid forcewake offset 0x%x\\n\", offset);\n\t\t\treturn -EINVAL;\n\t\t}\n\t} else {\n\t\tack_reg_offset = FORCEWAKE_ACK_HSW_REG;\n\t}\n\n\tvgpu_vreg(vgpu, offset) = new;\n\tvgpu_vreg(vgpu, ack_reg_offset) = (new & GENMASK(15, 0));\n\treturn 0;\n}\n\nstatic int gdrst_mmio_write(struct intel_vgpu *vgpu, unsigned int offset,\n\t\t\t    void *p_data, unsigned int bytes)\n{\n\tintel_engine_mask_t engine_mask = 0;\n\tu32 data;\n\n\twrite_vreg(vgpu, offset, p_data, bytes);\n\tdata = vgpu_vreg(vgpu, offset);\n\n\tif (data & GEN6_GRDOM_FULL) {\n\t\tgvt_dbg_mmio(\"vgpu%d: request full GPU reset\\n\", vgpu->id);\n\t\tengine_mask = ALL_ENGINES;\n\t} else {\n\t\tif (data & GEN6_GRDOM_RENDER) {\n\t\t\tgvt_dbg_mmio(\"vgpu%d: request RCS reset\\n\", vgpu->id);\n\t\t\tengine_mask |= BIT(RCS0);\n\t\t}\n\t\tif (data & GEN6_GRDOM_MEDIA) {\n\t\t\tgvt_dbg_mmio(\"vgpu%d: request VCS reset\\n\", vgpu->id);\n\t\t\tengine_mask |= BIT(VCS0);\n\t\t}\n\t\tif (data & GEN6_GRDOM_BLT) {\n\t\t\tgvt_dbg_mmio(\"vgpu%d: request BCS Reset\\n\", vgpu->id);\n\t\t\tengine_mask |= BIT(BCS0);\n\t\t}\n\t\tif (data & GEN6_GRDOM_VECS) {\n\t\t\tgvt_dbg_mmio(\"vgpu%d: request VECS Reset\\n\", vgpu->id);\n\t\t\tengine_mask |= BIT(VECS0);\n\t\t}\n\t\tif (data & GEN8_GRDOM_MEDIA2) {\n\t\t\tgvt_dbg_mmio(\"vgpu%d: request VCS2 Reset\\n\", vgpu->id);\n\t\t\tengine_mask |= BIT(VCS1);\n\t\t}\n\t\tif (data & GEN9_GRDOM_GUC) {\n\t\t\tgvt_dbg_mmio(\"vgpu%d: request GUC Reset\\n\", vgpu->id);\n\t\t\tvgpu_vreg_t(vgpu, GUC_STATUS) |= GS_MIA_IN_RESET;\n\t\t}\n\t\tengine_mask &= vgpu->gvt->gt->info.engine_mask;\n\t}\n\n\t \n\tintel_gvt_reset_vgpu_locked(vgpu, false, engine_mask);\n\n\t \n\tvgpu_vreg(vgpu, offset) = 0;\n\n\treturn 0;\n}\n\nstatic int gmbus_mmio_read(struct intel_vgpu *vgpu, unsigned int offset,\n\t\tvoid *p_data, unsigned int bytes)\n{\n\treturn intel_gvt_i2c_handle_gmbus_read(vgpu, offset, p_data, bytes);\n}\n\nstatic int gmbus_mmio_write(struct intel_vgpu *vgpu, unsigned int offset,\n\t\tvoid *p_data, unsigned int bytes)\n{\n\treturn intel_gvt_i2c_handle_gmbus_write(vgpu, offset, p_data, bytes);\n}\n\nstatic int pch_pp_control_mmio_write(struct intel_vgpu *vgpu,\n\t\tunsigned int offset, void *p_data, unsigned int bytes)\n{\n\twrite_vreg(vgpu, offset, p_data, bytes);\n\n\tif (vgpu_vreg(vgpu, offset) & PANEL_POWER_ON) {\n\t\tvgpu_vreg_t(vgpu, PCH_PP_STATUS) |= PP_ON;\n\t\tvgpu_vreg_t(vgpu, PCH_PP_STATUS) |= PP_SEQUENCE_STATE_ON_IDLE;\n\t\tvgpu_vreg_t(vgpu, PCH_PP_STATUS) &= ~PP_SEQUENCE_POWER_DOWN;\n\t\tvgpu_vreg_t(vgpu, PCH_PP_STATUS) &= ~PP_CYCLE_DELAY_ACTIVE;\n\n\t} else\n\t\tvgpu_vreg_t(vgpu, PCH_PP_STATUS) &=\n\t\t\t~(PP_ON | PP_SEQUENCE_POWER_DOWN\n\t\t\t\t\t| PP_CYCLE_DELAY_ACTIVE);\n\treturn 0;\n}\n\nstatic int transconf_mmio_write(struct intel_vgpu *vgpu,\n\t\tunsigned int offset, void *p_data, unsigned int bytes)\n{\n\twrite_vreg(vgpu, offset, p_data, bytes);\n\n\tif (vgpu_vreg(vgpu, offset) & TRANS_ENABLE)\n\t\tvgpu_vreg(vgpu, offset) |= TRANS_STATE_ENABLE;\n\telse\n\t\tvgpu_vreg(vgpu, offset) &= ~TRANS_STATE_ENABLE;\n\treturn 0;\n}\n\nstatic int lcpll_ctl_mmio_write(struct intel_vgpu *vgpu, unsigned int offset,\n\t\tvoid *p_data, unsigned int bytes)\n{\n\twrite_vreg(vgpu, offset, p_data, bytes);\n\n\tif (vgpu_vreg(vgpu, offset) & LCPLL_PLL_DISABLE)\n\t\tvgpu_vreg(vgpu, offset) &= ~LCPLL_PLL_LOCK;\n\telse\n\t\tvgpu_vreg(vgpu, offset) |= LCPLL_PLL_LOCK;\n\n\tif (vgpu_vreg(vgpu, offset) & LCPLL_CD_SOURCE_FCLK)\n\t\tvgpu_vreg(vgpu, offset) |= LCPLL_CD_SOURCE_FCLK_DONE;\n\telse\n\t\tvgpu_vreg(vgpu, offset) &= ~LCPLL_CD_SOURCE_FCLK_DONE;\n\n\treturn 0;\n}\n\nstatic int dpy_reg_mmio_read(struct intel_vgpu *vgpu, unsigned int offset,\n\t\tvoid *p_data, unsigned int bytes)\n{\n\tswitch (offset) {\n\tcase 0xe651c:\n\tcase 0xe661c:\n\tcase 0xe671c:\n\tcase 0xe681c:\n\t\tvgpu_vreg(vgpu, offset) = 1 << 17;\n\t\tbreak;\n\tcase 0xe6c04:\n\t\tvgpu_vreg(vgpu, offset) = 0x3;\n\t\tbreak;\n\tcase 0xe6e1c:\n\t\tvgpu_vreg(vgpu, offset) = 0x2f << 16;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tread_vreg(vgpu, offset, p_data, bytes);\n\treturn 0;\n}\n\n \n\nstatic u32 bdw_vgpu_get_dp_bitrate(struct intel_vgpu *vgpu, enum port port)\n{\n\tu32 dp_br = 0;\n\tu32 ddi_pll_sel = vgpu_vreg_t(vgpu, PORT_CLK_SEL(port));\n\n\tswitch (ddi_pll_sel) {\n\tcase PORT_CLK_SEL_LCPLL_2700:\n\t\tdp_br = 270000 * 2;\n\t\tbreak;\n\tcase PORT_CLK_SEL_LCPLL_1350:\n\t\tdp_br = 135000 * 2;\n\t\tbreak;\n\tcase PORT_CLK_SEL_LCPLL_810:\n\t\tdp_br = 81000 * 2;\n\t\tbreak;\n\tcase PORT_CLK_SEL_SPLL:\n\t{\n\t\tswitch (vgpu_vreg_t(vgpu, SPLL_CTL) & SPLL_FREQ_MASK) {\n\t\tcase SPLL_FREQ_810MHz:\n\t\t\tdp_br = 81000 * 2;\n\t\t\tbreak;\n\t\tcase SPLL_FREQ_1350MHz:\n\t\t\tdp_br = 135000 * 2;\n\t\t\tbreak;\n\t\tcase SPLL_FREQ_2700MHz:\n\t\t\tdp_br = 270000 * 2;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tgvt_dbg_dpy(\"vgpu-%d PORT_%c can't get freq from SPLL 0x%08x\\n\",\n\t\t\t\t    vgpu->id, port_name(port), vgpu_vreg_t(vgpu, SPLL_CTL));\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\t}\n\tcase PORT_CLK_SEL_WRPLL1:\n\tcase PORT_CLK_SEL_WRPLL2:\n\t{\n\t\tu32 wrpll_ctl;\n\t\tint refclk, n, p, r;\n\n\t\tif (ddi_pll_sel == PORT_CLK_SEL_WRPLL1)\n\t\t\twrpll_ctl = vgpu_vreg_t(vgpu, WRPLL_CTL(DPLL_ID_WRPLL1));\n\t\telse\n\t\t\twrpll_ctl = vgpu_vreg_t(vgpu, WRPLL_CTL(DPLL_ID_WRPLL2));\n\n\t\tswitch (wrpll_ctl & WRPLL_REF_MASK) {\n\t\tcase WRPLL_REF_PCH_SSC:\n\t\t\trefclk = vgpu->gvt->gt->i915->display.dpll.ref_clks.ssc;\n\t\t\tbreak;\n\t\tcase WRPLL_REF_LCPLL:\n\t\t\trefclk = 2700000;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tgvt_dbg_dpy(\"vgpu-%d PORT_%c WRPLL can't get refclk 0x%08x\\n\",\n\t\t\t\t    vgpu->id, port_name(port), wrpll_ctl);\n\t\t\tgoto out;\n\t\t}\n\n\t\tr = wrpll_ctl & WRPLL_DIVIDER_REF_MASK;\n\t\tp = (wrpll_ctl & WRPLL_DIVIDER_POST_MASK) >> WRPLL_DIVIDER_POST_SHIFT;\n\t\tn = (wrpll_ctl & WRPLL_DIVIDER_FB_MASK) >> WRPLL_DIVIDER_FB_SHIFT;\n\n\t\tdp_br = (refclk * n / 10) / (p * r) * 2;\n\t\tbreak;\n\t}\n\tdefault:\n\t\tgvt_dbg_dpy(\"vgpu-%d PORT_%c has invalid clock select 0x%08x\\n\",\n\t\t\t    vgpu->id, port_name(port), vgpu_vreg_t(vgpu, PORT_CLK_SEL(port)));\n\t\tbreak;\n\t}\n\nout:\n\treturn dp_br;\n}\n\nstatic u32 bxt_vgpu_get_dp_bitrate(struct intel_vgpu *vgpu, enum port port)\n{\n\tu32 dp_br = 0;\n\tint refclk = vgpu->gvt->gt->i915->display.dpll.ref_clks.nssc;\n\tenum dpio_phy phy = DPIO_PHY0;\n\tenum dpio_channel ch = DPIO_CH0;\n\tstruct dpll clock = {0};\n\tu32 temp;\n\n\t \n\tswitch (port) {\n\tcase PORT_A:\n\t\tphy = DPIO_PHY1;\n\t\tch = DPIO_CH0;\n\t\tbreak;\n\tcase PORT_B:\n\t\tphy = DPIO_PHY0;\n\t\tch = DPIO_CH0;\n\t\tbreak;\n\tcase PORT_C:\n\t\tphy = DPIO_PHY0;\n\t\tch = DPIO_CH1;\n\t\tbreak;\n\tdefault:\n\t\tgvt_dbg_dpy(\"vgpu-%d no PHY for PORT_%c\\n\", vgpu->id, port_name(port));\n\t\tgoto out;\n\t}\n\n\ttemp = vgpu_vreg_t(vgpu, BXT_PORT_PLL_ENABLE(port));\n\tif (!(temp & PORT_PLL_ENABLE) || !(temp & PORT_PLL_LOCK)) {\n\t\tgvt_dbg_dpy(\"vgpu-%d PORT_%c PLL_ENABLE 0x%08x isn't enabled or locked\\n\",\n\t\t\t    vgpu->id, port_name(port), temp);\n\t\tgoto out;\n\t}\n\n\tclock.m1 = 2;\n\tclock.m2 = REG_FIELD_GET(PORT_PLL_M2_INT_MASK,\n\t\t\t\t vgpu_vreg_t(vgpu, BXT_PORT_PLL(phy, ch, 0))) << 22;\n\tif (vgpu_vreg_t(vgpu, BXT_PORT_PLL(phy, ch, 3)) & PORT_PLL_M2_FRAC_ENABLE)\n\t\tclock.m2 |= REG_FIELD_GET(PORT_PLL_M2_FRAC_MASK,\n\t\t\t\t\t  vgpu_vreg_t(vgpu, BXT_PORT_PLL(phy, ch, 2)));\n\tclock.n = REG_FIELD_GET(PORT_PLL_N_MASK,\n\t\t\t\tvgpu_vreg_t(vgpu, BXT_PORT_PLL(phy, ch, 1)));\n\tclock.p1 = REG_FIELD_GET(PORT_PLL_P1_MASK,\n\t\t\t\t vgpu_vreg_t(vgpu, BXT_PORT_PLL_EBB_0(phy, ch)));\n\tclock.p2 = REG_FIELD_GET(PORT_PLL_P2_MASK,\n\t\t\t\t vgpu_vreg_t(vgpu, BXT_PORT_PLL_EBB_0(phy, ch)));\n\tclock.m = clock.m1 * clock.m2;\n\tclock.p = clock.p1 * clock.p2 * 5;\n\n\tif (clock.n == 0 || clock.p == 0) {\n\t\tgvt_dbg_dpy(\"vgpu-%d PORT_%c PLL has invalid divider\\n\", vgpu->id, port_name(port));\n\t\tgoto out;\n\t}\n\n\tclock.vco = DIV_ROUND_CLOSEST_ULL(mul_u32_u32(refclk, clock.m), clock.n << 22);\n\tclock.dot = DIV_ROUND_CLOSEST(clock.vco, clock.p);\n\n\tdp_br = clock.dot;\n\nout:\n\treturn dp_br;\n}\n\nstatic u32 skl_vgpu_get_dp_bitrate(struct intel_vgpu *vgpu, enum port port)\n{\n\tu32 dp_br = 0;\n\tenum intel_dpll_id dpll_id = DPLL_ID_SKL_DPLL0;\n\n\t \n\tif (!(vgpu_vreg_t(vgpu, DPLL_CTRL2) & DPLL_CTRL2_DDI_CLK_OFF(port)) &&\n\t    (vgpu_vreg_t(vgpu, DPLL_CTRL2) & DPLL_CTRL2_DDI_SEL_OVERRIDE(port))) {\n\t\tdpll_id += (vgpu_vreg_t(vgpu, DPLL_CTRL2) &\n\t\t\tDPLL_CTRL2_DDI_CLK_SEL_MASK(port)) >>\n\t\t\tDPLL_CTRL2_DDI_CLK_SEL_SHIFT(port);\n\t} else {\n\t\tgvt_dbg_dpy(\"vgpu-%d DPLL for PORT_%c isn't turned on\\n\",\n\t\t\t    vgpu->id, port_name(port));\n\t\treturn dp_br;\n\t}\n\n\t \n\tswitch ((vgpu_vreg_t(vgpu, DPLL_CTRL1) &\n\t\tDPLL_CTRL1_LINK_RATE_MASK(dpll_id)) >>\n\t\tDPLL_CTRL1_LINK_RATE_SHIFT(dpll_id)) {\n\t\tcase DPLL_CTRL1_LINK_RATE_810:\n\t\t\tdp_br = 81000 * 2;\n\t\t\tbreak;\n\t\tcase DPLL_CTRL1_LINK_RATE_1080:\n\t\t\tdp_br = 108000 * 2;\n\t\t\tbreak;\n\t\tcase DPLL_CTRL1_LINK_RATE_1350:\n\t\t\tdp_br = 135000 * 2;\n\t\t\tbreak;\n\t\tcase DPLL_CTRL1_LINK_RATE_1620:\n\t\t\tdp_br = 162000 * 2;\n\t\t\tbreak;\n\t\tcase DPLL_CTRL1_LINK_RATE_2160:\n\t\t\tdp_br = 216000 * 2;\n\t\t\tbreak;\n\t\tcase DPLL_CTRL1_LINK_RATE_2700:\n\t\t\tdp_br = 270000 * 2;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdp_br = 0;\n\t\t\tgvt_dbg_dpy(\"vgpu-%d PORT_%c fail to get DPLL-%d freq\\n\",\n\t\t\t\t    vgpu->id, port_name(port), dpll_id);\n\t}\n\n\treturn dp_br;\n}\n\nstatic void vgpu_update_refresh_rate(struct intel_vgpu *vgpu)\n{\n\tstruct drm_i915_private *dev_priv = vgpu->gvt->gt->i915;\n\tenum port port;\n\tu32 dp_br, link_m, link_n, htotal, vtotal;\n\n\t \n\tport = (vgpu_vreg_t(vgpu, TRANS_DDI_FUNC_CTL(TRANSCODER_A)) &\n\t\tTRANS_DDI_PORT_MASK) >> TRANS_DDI_PORT_SHIFT;\n\tif (port != PORT_B && port != PORT_D) {\n\t\tgvt_dbg_dpy(\"vgpu-%d unsupported PORT_%c\\n\", vgpu->id, port_name(port));\n\t\treturn;\n\t}\n\n\t \n\tif (IS_BROADWELL(dev_priv))\n\t\tdp_br = bdw_vgpu_get_dp_bitrate(vgpu, port);\n\telse if (IS_BROXTON(dev_priv))\n\t\tdp_br = bxt_vgpu_get_dp_bitrate(vgpu, port);\n\telse\n\t\tdp_br = skl_vgpu_get_dp_bitrate(vgpu, port);\n\n\t \n\tlink_m = vgpu_vreg_t(vgpu, PIPE_LINK_M1(TRANSCODER_A));\n\tlink_n = vgpu_vreg_t(vgpu, PIPE_LINK_N1(TRANSCODER_A));\n\n\t \n\thtotal = (vgpu_vreg_t(vgpu, TRANS_HTOTAL(TRANSCODER_A)) >> TRANS_HTOTAL_SHIFT);\n\tvtotal = (vgpu_vreg_t(vgpu, TRANS_VTOTAL(TRANSCODER_A)) >> TRANS_VTOTAL_SHIFT);\n\n\tif (dp_br && link_n && htotal && vtotal) {\n\t\tu64 pixel_clk = 0;\n\t\tu32 new_rate = 0;\n\t\tu32 *old_rate = &(intel_vgpu_port(vgpu, vgpu->display.port_num)->vrefresh_k);\n\n\t\t \n\t\tpixel_clk = div_u64(mul_u32_u32(link_m, dp_br), link_n);\n\t\tpixel_clk *= MSEC_PER_SEC;\n\n\t\t \n\t\tnew_rate = DIV64_U64_ROUND_CLOSEST(mul_u64_u32_shr(pixel_clk, MSEC_PER_SEC, 0), mul_u32_u32(htotal + 1, vtotal + 1));\n\n\t\tif (*old_rate != new_rate)\n\t\t\t*old_rate = new_rate;\n\n\t\tgvt_dbg_dpy(\"vgpu-%d PIPE_%c refresh rate updated to %d\\n\",\n\t\t\t    vgpu->id, pipe_name(PIPE_A), new_rate);\n\t}\n}\n\nstatic int pipeconf_mmio_write(struct intel_vgpu *vgpu, unsigned int offset,\n\t\tvoid *p_data, unsigned int bytes)\n{\n\tu32 data;\n\n\twrite_vreg(vgpu, offset, p_data, bytes);\n\tdata = vgpu_vreg(vgpu, offset);\n\n\tif (data & TRANSCONF_ENABLE) {\n\t\tvgpu_vreg(vgpu, offset) |= TRANSCONF_STATE_ENABLE;\n\t\tvgpu_update_refresh_rate(vgpu);\n\t\tvgpu_update_vblank_emulation(vgpu, true);\n\t} else {\n\t\tvgpu_vreg(vgpu, offset) &= ~TRANSCONF_STATE_ENABLE;\n\t\tvgpu_update_vblank_emulation(vgpu, false);\n\t}\n\treturn 0;\n}\n\n \nstatic i915_reg_t force_nonpriv_white_list[] = {\n\t_MMIO(0xd80),\n\tGEN9_CS_DEBUG_MODE1, \n\tGEN9_CTX_PREEMPT_REG,\n\tCL_PRIMITIVES_COUNT, \n\tPS_INVOCATION_COUNT, \n\tPS_DEPTH_COUNT, \n\tGEN8_CS_CHICKEN1,\n\t_MMIO(0x2690),\n\t_MMIO(0x2694),\n\t_MMIO(0x2698),\n\t_MMIO(0x2754),\n\t_MMIO(0x28a0),\n\t_MMIO(0x4de0),\n\t_MMIO(0x4de4),\n\t_MMIO(0x4dfc),\n\tGEN7_COMMON_SLICE_CHICKEN1,\n\t_MMIO(0x7014),\n\tHDC_CHICKEN0,\n\tGEN8_HDC_CHICKEN1,\n\t_MMIO(0x7700),\n\t_MMIO(0x7704),\n\t_MMIO(0x7708),\n\t_MMIO(0x770c),\n\t_MMIO(0x83a8),\n\t_MMIO(0xb110),\n\t_MMIO(0xb118),\n\t_MMIO(0xe100),\n\t_MMIO(0xe18c),\n\t_MMIO(0xe48c),\n\t_MMIO(0xe5f4),\n\t_MMIO(0x64844),\n};\n\n \nstatic inline bool in_whitelist(u32 reg)\n{\n\tint left = 0, right = ARRAY_SIZE(force_nonpriv_white_list);\n\ti915_reg_t *array = force_nonpriv_white_list;\n\n\twhile (left < right) {\n\t\tint mid = (left + right)/2;\n\n\t\tif (reg > array[mid].reg)\n\t\t\tleft = mid + 1;\n\t\telse if (reg < array[mid].reg)\n\t\t\tright = mid;\n\t\telse\n\t\t\treturn true;\n\t}\n\treturn false;\n}\n\nstatic int force_nonpriv_write(struct intel_vgpu *vgpu,\n\tunsigned int offset, void *p_data, unsigned int bytes)\n{\n\tu32 reg_nonpriv = (*(u32 *)p_data) & REG_GENMASK(25, 2);\n\tconst struct intel_engine_cs *engine =\n\t\tintel_gvt_render_mmio_to_engine(vgpu->gvt, offset);\n\n\tif (bytes != 4 || !IS_ALIGNED(offset, bytes) || !engine) {\n\t\tgvt_err(\"vgpu(%d) Invalid FORCE_NONPRIV offset %x(%dB)\\n\",\n\t\t\tvgpu->id, offset, bytes);\n\t\treturn -EINVAL;\n\t}\n\n\tif (!in_whitelist(reg_nonpriv) &&\n\t    reg_nonpriv != i915_mmio_reg_offset(RING_NOPID(engine->mmio_base))) {\n\t\tgvt_err(\"vgpu(%d) Invalid FORCE_NONPRIV write %x at offset %x\\n\",\n\t\t\tvgpu->id, reg_nonpriv, offset);\n\t} else\n\t\tintel_vgpu_default_mmio_write(vgpu, offset, p_data, bytes);\n\n\treturn 0;\n}\n\nstatic int ddi_buf_ctl_mmio_write(struct intel_vgpu *vgpu, unsigned int offset,\n\t\tvoid *p_data, unsigned int bytes)\n{\n\twrite_vreg(vgpu, offset, p_data, bytes);\n\n\tif (vgpu_vreg(vgpu, offset) & DDI_BUF_CTL_ENABLE) {\n\t\tvgpu_vreg(vgpu, offset) &= ~DDI_BUF_IS_IDLE;\n\t} else {\n\t\tvgpu_vreg(vgpu, offset) |= DDI_BUF_IS_IDLE;\n\t\tif (offset == i915_mmio_reg_offset(DDI_BUF_CTL(PORT_E)))\n\t\t\tvgpu_vreg_t(vgpu, DP_TP_STATUS(PORT_E))\n\t\t\t\t&= ~DP_TP_STATUS_AUTOTRAIN_DONE;\n\t}\n\treturn 0;\n}\n\nstatic int fdi_rx_iir_mmio_write(struct intel_vgpu *vgpu,\n\t\tunsigned int offset, void *p_data, unsigned int bytes)\n{\n\tvgpu_vreg(vgpu, offset) &= ~*(u32 *)p_data;\n\treturn 0;\n}\n\n#define FDI_LINK_TRAIN_PATTERN1         0\n#define FDI_LINK_TRAIN_PATTERN2         1\n\nstatic int fdi_auto_training_started(struct intel_vgpu *vgpu)\n{\n\tu32 ddi_buf_ctl = vgpu_vreg_t(vgpu, DDI_BUF_CTL(PORT_E));\n\tu32 rx_ctl = vgpu_vreg(vgpu, _FDI_RXA_CTL);\n\tu32 tx_ctl = vgpu_vreg_t(vgpu, DP_TP_CTL(PORT_E));\n\n\tif ((ddi_buf_ctl & DDI_BUF_CTL_ENABLE) &&\n\t\t\t(rx_ctl & FDI_RX_ENABLE) &&\n\t\t\t(rx_ctl & FDI_AUTO_TRAINING) &&\n\t\t\t(tx_ctl & DP_TP_CTL_ENABLE) &&\n\t\t\t(tx_ctl & DP_TP_CTL_FDI_AUTOTRAIN))\n\t\treturn 1;\n\telse\n\t\treturn 0;\n}\n\nstatic int check_fdi_rx_train_status(struct intel_vgpu *vgpu,\n\t\tenum pipe pipe, unsigned int train_pattern)\n{\n\ti915_reg_t fdi_rx_imr, fdi_tx_ctl, fdi_rx_ctl;\n\tunsigned int fdi_rx_check_bits, fdi_tx_check_bits;\n\tunsigned int fdi_rx_train_bits, fdi_tx_train_bits;\n\tunsigned int fdi_iir_check_bits;\n\n\tfdi_rx_imr = FDI_RX_IMR(pipe);\n\tfdi_tx_ctl = FDI_TX_CTL(pipe);\n\tfdi_rx_ctl = FDI_RX_CTL(pipe);\n\n\tif (train_pattern == FDI_LINK_TRAIN_PATTERN1) {\n\t\tfdi_rx_train_bits = FDI_LINK_TRAIN_PATTERN_1_CPT;\n\t\tfdi_tx_train_bits = FDI_LINK_TRAIN_PATTERN_1;\n\t\tfdi_iir_check_bits = FDI_RX_BIT_LOCK;\n\t} else if (train_pattern == FDI_LINK_TRAIN_PATTERN2) {\n\t\tfdi_rx_train_bits = FDI_LINK_TRAIN_PATTERN_2_CPT;\n\t\tfdi_tx_train_bits = FDI_LINK_TRAIN_PATTERN_2;\n\t\tfdi_iir_check_bits = FDI_RX_SYMBOL_LOCK;\n\t} else {\n\t\tgvt_vgpu_err(\"Invalid train pattern %d\\n\", train_pattern);\n\t\treturn -EINVAL;\n\t}\n\n\tfdi_rx_check_bits = FDI_RX_ENABLE | fdi_rx_train_bits;\n\tfdi_tx_check_bits = FDI_TX_ENABLE | fdi_tx_train_bits;\n\n\t \n\tif (vgpu_vreg_t(vgpu, fdi_rx_imr) & fdi_iir_check_bits)\n\t\treturn 0;\n\n\tif (((vgpu_vreg_t(vgpu, fdi_tx_ctl) & fdi_tx_check_bits)\n\t\t\t== fdi_tx_check_bits)\n\t\t&& ((vgpu_vreg_t(vgpu, fdi_rx_ctl) & fdi_rx_check_bits)\n\t\t\t== fdi_rx_check_bits))\n\t\treturn 1;\n\telse\n\t\treturn 0;\n}\n\n#define INVALID_INDEX (~0U)\n\nstatic unsigned int calc_index(unsigned int offset, unsigned int start,\n\tunsigned int next, unsigned int end, i915_reg_t i915_end)\n{\n\tunsigned int range = next - start;\n\n\tif (!end)\n\t\tend = i915_mmio_reg_offset(i915_end);\n\tif (offset < start || offset > end)\n\t\treturn INVALID_INDEX;\n\toffset -= start;\n\treturn offset / range;\n}\n\n#define FDI_RX_CTL_TO_PIPE(offset) \\\n\tcalc_index(offset, _FDI_RXA_CTL, _FDI_RXB_CTL, 0, FDI_RX_CTL(PIPE_C))\n\n#define FDI_TX_CTL_TO_PIPE(offset) \\\n\tcalc_index(offset, _FDI_TXA_CTL, _FDI_TXB_CTL, 0, FDI_TX_CTL(PIPE_C))\n\n#define FDI_RX_IMR_TO_PIPE(offset) \\\n\tcalc_index(offset, _FDI_RXA_IMR, _FDI_RXB_IMR, 0, FDI_RX_IMR(PIPE_C))\n\nstatic int update_fdi_rx_iir_status(struct intel_vgpu *vgpu,\n\t\tunsigned int offset, void *p_data, unsigned int bytes)\n{\n\ti915_reg_t fdi_rx_iir;\n\tunsigned int index;\n\tint ret;\n\n\tif (FDI_RX_CTL_TO_PIPE(offset) != INVALID_INDEX)\n\t\tindex = FDI_RX_CTL_TO_PIPE(offset);\n\telse if (FDI_TX_CTL_TO_PIPE(offset) != INVALID_INDEX)\n\t\tindex = FDI_TX_CTL_TO_PIPE(offset);\n\telse if (FDI_RX_IMR_TO_PIPE(offset) != INVALID_INDEX)\n\t\tindex = FDI_RX_IMR_TO_PIPE(offset);\n\telse {\n\t\tgvt_vgpu_err(\"Unsupported registers %x\\n\", offset);\n\t\treturn -EINVAL;\n\t}\n\n\twrite_vreg(vgpu, offset, p_data, bytes);\n\n\tfdi_rx_iir = FDI_RX_IIR(index);\n\n\tret = check_fdi_rx_train_status(vgpu, index, FDI_LINK_TRAIN_PATTERN1);\n\tif (ret < 0)\n\t\treturn ret;\n\tif (ret)\n\t\tvgpu_vreg_t(vgpu, fdi_rx_iir) |= FDI_RX_BIT_LOCK;\n\n\tret = check_fdi_rx_train_status(vgpu, index, FDI_LINK_TRAIN_PATTERN2);\n\tif (ret < 0)\n\t\treturn ret;\n\tif (ret)\n\t\tvgpu_vreg_t(vgpu, fdi_rx_iir) |= FDI_RX_SYMBOL_LOCK;\n\n\tif (offset == _FDI_RXA_CTL)\n\t\tif (fdi_auto_training_started(vgpu))\n\t\t\tvgpu_vreg_t(vgpu, DP_TP_STATUS(PORT_E)) |=\n\t\t\t\tDP_TP_STATUS_AUTOTRAIN_DONE;\n\treturn 0;\n}\n\n#define DP_TP_CTL_TO_PORT(offset) \\\n\tcalc_index(offset, _DP_TP_CTL_A, _DP_TP_CTL_B, 0, DP_TP_CTL(PORT_E))\n\nstatic int dp_tp_ctl_mmio_write(struct intel_vgpu *vgpu, unsigned int offset,\n\t\tvoid *p_data, unsigned int bytes)\n{\n\ti915_reg_t status_reg;\n\tunsigned int index;\n\tu32 data;\n\n\twrite_vreg(vgpu, offset, p_data, bytes);\n\n\tindex = DP_TP_CTL_TO_PORT(offset);\n\tdata = (vgpu_vreg(vgpu, offset) & GENMASK(10, 8)) >> 8;\n\tif (data == 0x2) {\n\t\tstatus_reg = DP_TP_STATUS(index);\n\t\tvgpu_vreg_t(vgpu, status_reg) |= (1 << 25);\n\t}\n\treturn 0;\n}\n\nstatic int dp_tp_status_mmio_write(struct intel_vgpu *vgpu,\n\t\tunsigned int offset, void *p_data, unsigned int bytes)\n{\n\tu32 reg_val;\n\tu32 sticky_mask;\n\n\treg_val = *((u32 *)p_data);\n\tsticky_mask = GENMASK(27, 26) | (1 << 24);\n\n\tvgpu_vreg(vgpu, offset) = (reg_val & ~sticky_mask) |\n\t\t(vgpu_vreg(vgpu, offset) & sticky_mask);\n\tvgpu_vreg(vgpu, offset) &= ~(reg_val & sticky_mask);\n\treturn 0;\n}\n\nstatic int pch_adpa_mmio_write(struct intel_vgpu *vgpu,\n\t\tunsigned int offset, void *p_data, unsigned int bytes)\n{\n\tu32 data;\n\n\twrite_vreg(vgpu, offset, p_data, bytes);\n\tdata = vgpu_vreg(vgpu, offset);\n\n\tif (data & ADPA_CRT_HOTPLUG_FORCE_TRIGGER)\n\t\tvgpu_vreg(vgpu, offset) &= ~ADPA_CRT_HOTPLUG_FORCE_TRIGGER;\n\treturn 0;\n}\n\nstatic int south_chicken2_mmio_write(struct intel_vgpu *vgpu,\n\t\tunsigned int offset, void *p_data, unsigned int bytes)\n{\n\tu32 data;\n\n\twrite_vreg(vgpu, offset, p_data, bytes);\n\tdata = vgpu_vreg(vgpu, offset);\n\n\tif (data & FDI_MPHY_IOSFSB_RESET_CTL)\n\t\tvgpu_vreg(vgpu, offset) |= FDI_MPHY_IOSFSB_RESET_STATUS;\n\telse\n\t\tvgpu_vreg(vgpu, offset) &= ~FDI_MPHY_IOSFSB_RESET_STATUS;\n\treturn 0;\n}\n\n#define DSPSURF_TO_PIPE(offset) \\\n\tcalc_index(offset, _DSPASURF, _DSPBSURF, 0, DSPSURF(PIPE_C))\n\nstatic int pri_surf_mmio_write(struct intel_vgpu *vgpu, unsigned int offset,\n\t\tvoid *p_data, unsigned int bytes)\n{\n\tstruct drm_i915_private *dev_priv = vgpu->gvt->gt->i915;\n\tu32 pipe = DSPSURF_TO_PIPE(offset);\n\tint event = SKL_FLIP_EVENT(pipe, PLANE_PRIMARY);\n\n\twrite_vreg(vgpu, offset, p_data, bytes);\n\tvgpu_vreg_t(vgpu, DSPSURFLIVE(pipe)) = vgpu_vreg(vgpu, offset);\n\n\tvgpu_vreg_t(vgpu, PIPE_FLIPCOUNT_G4X(pipe))++;\n\n\tif (vgpu_vreg_t(vgpu, DSPCNTR(pipe)) & PLANE_CTL_ASYNC_FLIP)\n\t\tintel_vgpu_trigger_virtual_event(vgpu, event);\n\telse\n\t\tset_bit(event, vgpu->irq.flip_done_event[pipe]);\n\n\treturn 0;\n}\n\n#define SPRSURF_TO_PIPE(offset) \\\n\tcalc_index(offset, _SPRA_SURF, _SPRB_SURF, 0, SPRSURF(PIPE_C))\n\nstatic int spr_surf_mmio_write(struct intel_vgpu *vgpu, unsigned int offset,\n\t\tvoid *p_data, unsigned int bytes)\n{\n\tu32 pipe = SPRSURF_TO_PIPE(offset);\n\tint event = SKL_FLIP_EVENT(pipe, PLANE_SPRITE0);\n\n\twrite_vreg(vgpu, offset, p_data, bytes);\n\tvgpu_vreg_t(vgpu, SPRSURFLIVE(pipe)) = vgpu_vreg(vgpu, offset);\n\n\tif (vgpu_vreg_t(vgpu, SPRCTL(pipe)) & PLANE_CTL_ASYNC_FLIP)\n\t\tintel_vgpu_trigger_virtual_event(vgpu, event);\n\telse\n\t\tset_bit(event, vgpu->irq.flip_done_event[pipe]);\n\n\treturn 0;\n}\n\nstatic int reg50080_mmio_write(struct intel_vgpu *vgpu,\n\t\t\t       unsigned int offset, void *p_data,\n\t\t\t       unsigned int bytes)\n{\n\tstruct drm_i915_private *dev_priv = vgpu->gvt->gt->i915;\n\tenum pipe pipe = REG_50080_TO_PIPE(offset);\n\tenum plane_id plane = REG_50080_TO_PLANE(offset);\n\tint event = SKL_FLIP_EVENT(pipe, plane);\n\n\twrite_vreg(vgpu, offset, p_data, bytes);\n\tif (plane == PLANE_PRIMARY) {\n\t\tvgpu_vreg_t(vgpu, DSPSURFLIVE(pipe)) = vgpu_vreg(vgpu, offset);\n\t\tvgpu_vreg_t(vgpu, PIPE_FLIPCOUNT_G4X(pipe))++;\n\t} else {\n\t\tvgpu_vreg_t(vgpu, SPRSURFLIVE(pipe)) = vgpu_vreg(vgpu, offset);\n\t}\n\n\tif ((vgpu_vreg(vgpu, offset) & REG50080_FLIP_TYPE_MASK) == REG50080_FLIP_TYPE_ASYNC)\n\t\tintel_vgpu_trigger_virtual_event(vgpu, event);\n\telse\n\t\tset_bit(event, vgpu->irq.flip_done_event[pipe]);\n\n\treturn 0;\n}\n\nstatic int trigger_aux_channel_interrupt(struct intel_vgpu *vgpu,\n\t\tunsigned int reg)\n{\n\tstruct drm_i915_private *dev_priv = vgpu->gvt->gt->i915;\n\tenum intel_gvt_event_type event;\n\n\tif (reg == i915_mmio_reg_offset(DP_AUX_CH_CTL(AUX_CH_A)))\n\t\tevent = AUX_CHANNEL_A;\n\telse if (reg == _PCH_DPB_AUX_CH_CTL ||\n\t\t reg == i915_mmio_reg_offset(DP_AUX_CH_CTL(AUX_CH_B)))\n\t\tevent = AUX_CHANNEL_B;\n\telse if (reg == _PCH_DPC_AUX_CH_CTL ||\n\t\t reg == i915_mmio_reg_offset(DP_AUX_CH_CTL(AUX_CH_C)))\n\t\tevent = AUX_CHANNEL_C;\n\telse if (reg == _PCH_DPD_AUX_CH_CTL ||\n\t\t reg == i915_mmio_reg_offset(DP_AUX_CH_CTL(AUX_CH_D)))\n\t\tevent = AUX_CHANNEL_D;\n\telse {\n\t\tdrm_WARN_ON(&dev_priv->drm, true);\n\t\treturn -EINVAL;\n\t}\n\n\tintel_vgpu_trigger_virtual_event(vgpu, event);\n\treturn 0;\n}\n\nstatic int dp_aux_ch_ctl_trans_done(struct intel_vgpu *vgpu, u32 value,\n\t\tunsigned int reg, int len, bool data_valid)\n{\n\t \n\tvalue |= DP_AUX_CH_CTL_DONE;\n\tvalue &= ~DP_AUX_CH_CTL_SEND_BUSY;\n\tvalue &= ~DP_AUX_CH_CTL_RECEIVE_ERROR;\n\n\tif (data_valid)\n\t\tvalue &= ~DP_AUX_CH_CTL_TIME_OUT_ERROR;\n\telse\n\t\tvalue |= DP_AUX_CH_CTL_TIME_OUT_ERROR;\n\n\t \n\tvalue &= ~(0xf << 20);\n\tvalue |= (len << 20);\n\tvgpu_vreg(vgpu, reg) = value;\n\n\tif (value & DP_AUX_CH_CTL_INTERRUPT)\n\t\treturn trigger_aux_channel_interrupt(vgpu, reg);\n\treturn 0;\n}\n\nstatic void dp_aux_ch_ctl_link_training(struct intel_vgpu_dpcd_data *dpcd,\n\t\tu8 t)\n{\n\tif ((t & DPCD_TRAINING_PATTERN_SET_MASK) == DPCD_TRAINING_PATTERN_1) {\n\t\t \n\t\t \n\t\tdpcd->data[DPCD_LANE0_1_STATUS] |= DPCD_LANES_CR_DONE;\n\t\t \n\t\tdpcd->data[DPCD_LANE2_3_STATUS] |= DPCD_LANES_CR_DONE;\n\t} else if ((t & DPCD_TRAINING_PATTERN_SET_MASK) ==\n\t\t\tDPCD_TRAINING_PATTERN_2) {\n\t\t \n\t\t \n\t\tdpcd->data[DPCD_LANE0_1_STATUS] |= DPCD_LANES_EQ_DONE;\n\t\tdpcd->data[DPCD_LANE0_1_STATUS] |= DPCD_SYMBOL_LOCKED;\n\t\t \n\t\tdpcd->data[DPCD_LANE2_3_STATUS] |= DPCD_LANES_EQ_DONE;\n\t\tdpcd->data[DPCD_LANE2_3_STATUS] |= DPCD_SYMBOL_LOCKED;\n\t\t \n\t\tdpcd->data[DPCD_LANE_ALIGN_STATUS_UPDATED] |=\n\t\t\tDPCD_INTERLANE_ALIGN_DONE;\n\t} else if ((t & DPCD_TRAINING_PATTERN_SET_MASK) ==\n\t\t\tDPCD_LINK_TRAINING_DISABLED) {\n\t\t \n\t\t \n\t\tdpcd->data[DPCD_SINK_STATUS] = DPCD_SINK_IN_SYNC;\n\t}\n}\n\n#define _REG_HSW_DP_AUX_CH_CTL(dp) \\\n\t((dp) ? (_PCH_DPB_AUX_CH_CTL + ((dp)-1)*0x100) : 0x64010)\n\n#define _REG_SKL_DP_AUX_CH_CTL(dp) (0x64010 + (dp) * 0x100)\n\n#define OFFSET_TO_DP_AUX_PORT(offset) (((offset) & 0xF00) >> 8)\n\n#define dpy_is_valid_port(port)\t\\\n\t\t(((port) >= PORT_A) && ((port) < I915_MAX_PORTS))\n\nstatic int dp_aux_ch_ctl_mmio_write(struct intel_vgpu *vgpu,\n\t\tunsigned int offset, void *p_data, unsigned int bytes)\n{\n\tstruct intel_vgpu_display *display = &vgpu->display;\n\tint msg, addr, ctrl, op, len;\n\tint port_index = OFFSET_TO_DP_AUX_PORT(offset);\n\tstruct intel_vgpu_dpcd_data *dpcd = NULL;\n\tstruct intel_vgpu_port *port = NULL;\n\tu32 data;\n\n\tif (!dpy_is_valid_port(port_index)) {\n\t\tgvt_vgpu_err(\"Unsupported DP port access!\\n\");\n\t\treturn 0;\n\t}\n\n\twrite_vreg(vgpu, offset, p_data, bytes);\n\tdata = vgpu_vreg(vgpu, offset);\n\n\tif ((GRAPHICS_VER(vgpu->gvt->gt->i915) >= 9)\n\t\t&& offset != _REG_SKL_DP_AUX_CH_CTL(port_index)) {\n\t\t \n\t\treturn 0;\n\t} else if (IS_BROADWELL(vgpu->gvt->gt->i915) &&\n\t\t   offset != _REG_HSW_DP_AUX_CH_CTL(port_index)) {\n\t\t \n\t\treturn 0;\n\t}\n\n\tif (!(data & DP_AUX_CH_CTL_SEND_BUSY)) {\n\t\t \n\t\tvgpu_vreg(vgpu, offset) = 0;\n\t\treturn 0;\n\t}\n\n\tport = &display->ports[port_index];\n\tdpcd = port->dpcd;\n\n\t \n\tmsg = vgpu_vreg(vgpu, offset + 4);\n\taddr = (msg >> 8) & 0xffff;\n\tctrl = (msg >> 24) & 0xff;\n\tlen = msg & 0xff;\n\top = ctrl >> 4;\n\n\tif (op == GVT_AUX_NATIVE_WRITE) {\n\t\tint t;\n\t\tu8 buf[16];\n\n\t\tif ((addr + len + 1) >= DPCD_SIZE) {\n\t\t\t \n\n\t\t\t \n\t\t\tvgpu_vreg(vgpu, offset + 4) = AUX_NATIVE_REPLY_NAK;\n\t\t\tdp_aux_ch_ctl_trans_done(vgpu, data, offset, 2, true);\n\t\t\treturn 0;\n\t\t}\n\n\t\t \n\t\tif ((len + 1 + 4) > AUX_BURST_SIZE) {\n\t\t\tgvt_vgpu_err(\"dp_aux_header: len %d is too large\\n\", len);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\t \n\t\tfor (t = 0; t < 4; t++) {\n\t\t\tu32 r = vgpu_vreg(vgpu, offset + 8 + t * 4);\n\n\t\t\tbuf[t * 4] = (r >> 24) & 0xff;\n\t\t\tbuf[t * 4 + 1] = (r >> 16) & 0xff;\n\t\t\tbuf[t * 4 + 2] = (r >> 8) & 0xff;\n\t\t\tbuf[t * 4 + 3] = r & 0xff;\n\t\t}\n\n\t\t \n\t\tif (dpcd && dpcd->data_valid) {\n\t\t\tfor (t = 0; t <= len; t++) {\n\t\t\t\tint p = addr + t;\n\n\t\t\t\tdpcd->data[p] = buf[t];\n\t\t\t\t \n\t\t\t\tif (p == DPCD_TRAINING_PATTERN_SET)\n\t\t\t\t\tdp_aux_ch_ctl_link_training(dpcd,\n\t\t\t\t\t\t\tbuf[t]);\n\t\t\t}\n\t\t}\n\n\t\t \n\t\tvgpu_vreg(vgpu, offset + 4) = 0;\n\t\tdp_aux_ch_ctl_trans_done(vgpu, data, offset, 1,\n\t\t\t\tdpcd && dpcd->data_valid);\n\t\treturn 0;\n\t}\n\n\tif (op == GVT_AUX_NATIVE_READ) {\n\t\tint idx, i, ret = 0;\n\n\t\tif ((addr + len + 1) >= DPCD_SIZE) {\n\t\t\t \n\n\t\t\t \n\t\t\tvgpu_vreg(vgpu, offset + 4) = 0;\n\t\t\tvgpu_vreg(vgpu, offset + 8) = 0;\n\t\t\tvgpu_vreg(vgpu, offset + 12) = 0;\n\t\t\tvgpu_vreg(vgpu, offset + 16) = 0;\n\t\t\tvgpu_vreg(vgpu, offset + 20) = 0;\n\n\t\t\tdp_aux_ch_ctl_trans_done(vgpu, data, offset, len + 2,\n\t\t\t\t\ttrue);\n\t\t\treturn 0;\n\t\t}\n\n\t\tfor (idx = 1; idx <= 5; idx++) {\n\t\t\t \n\t\t\tvgpu_vreg(vgpu, offset + 4 * idx) = 0;\n\t\t}\n\n\t\t \n\t\tif ((len + 2) > AUX_BURST_SIZE) {\n\t\t\tgvt_vgpu_err(\"dp_aux_header: len %d is too large\\n\", len);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\t \n\t\t \n\t\tif (dpcd && dpcd->data_valid) {\n\t\t\tfor (i = 1; i <= (len + 1); i++) {\n\t\t\t\tint t;\n\n\t\t\t\tt = dpcd->data[addr + i - 1];\n\t\t\t\tt <<= (24 - 8 * (i % 4));\n\t\t\t\tret |= t;\n\n\t\t\t\tif ((i % 4 == 3) || (i == (len + 1))) {\n\t\t\t\t\tvgpu_vreg(vgpu, offset +\n\t\t\t\t\t\t\t(i / 4 + 1) * 4) = ret;\n\t\t\t\t\tret = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tdp_aux_ch_ctl_trans_done(vgpu, data, offset, len + 2,\n\t\t\t\tdpcd && dpcd->data_valid);\n\t\treturn 0;\n\t}\n\n\t \n\tintel_gvt_i2c_handle_aux_ch_write(vgpu, port_index, offset, p_data);\n\n\tif (data & DP_AUX_CH_CTL_INTERRUPT)\n\t\ttrigger_aux_channel_interrupt(vgpu, offset);\n\treturn 0;\n}\n\nstatic int mbctl_write(struct intel_vgpu *vgpu, unsigned int offset,\n\t\tvoid *p_data, unsigned int bytes)\n{\n\t*(u32 *)p_data &= (~GEN6_MBCTL_ENABLE_BOOT_FETCH);\n\twrite_vreg(vgpu, offset, p_data, bytes);\n\treturn 0;\n}\n\nstatic int vga_control_mmio_write(struct intel_vgpu *vgpu, unsigned int offset,\n\t\tvoid *p_data, unsigned int bytes)\n{\n\tbool vga_disable;\n\n\twrite_vreg(vgpu, offset, p_data, bytes);\n\tvga_disable = vgpu_vreg(vgpu, offset) & VGA_DISP_DISABLE;\n\n\tgvt_dbg_core(\"vgpu%d: %s VGA mode\\n\", vgpu->id,\n\t\t\tvga_disable ? \"Disable\" : \"Enable\");\n\treturn 0;\n}\n\nstatic u32 read_virtual_sbi_register(struct intel_vgpu *vgpu,\n\t\tunsigned int sbi_offset)\n{\n\tstruct intel_vgpu_display *display = &vgpu->display;\n\tint num = display->sbi.number;\n\tint i;\n\n\tfor (i = 0; i < num; ++i)\n\t\tif (display->sbi.registers[i].offset == sbi_offset)\n\t\t\tbreak;\n\n\tif (i == num)\n\t\treturn 0;\n\n\treturn display->sbi.registers[i].value;\n}\n\nstatic void write_virtual_sbi_register(struct intel_vgpu *vgpu,\n\t\tunsigned int offset, u32 value)\n{\n\tstruct intel_vgpu_display *display = &vgpu->display;\n\tint num = display->sbi.number;\n\tint i;\n\n\tfor (i = 0; i < num; ++i) {\n\t\tif (display->sbi.registers[i].offset == offset)\n\t\t\tbreak;\n\t}\n\n\tif (i == num) {\n\t\tif (num == SBI_REG_MAX) {\n\t\t\tgvt_vgpu_err(\"SBI caching meets maximum limits\\n\");\n\t\t\treturn;\n\t\t}\n\t\tdisplay->sbi.number++;\n\t}\n\n\tdisplay->sbi.registers[i].offset = offset;\n\tdisplay->sbi.registers[i].value = value;\n}\n\nstatic int sbi_data_mmio_read(struct intel_vgpu *vgpu, unsigned int offset,\n\t\tvoid *p_data, unsigned int bytes)\n{\n\tif (((vgpu_vreg_t(vgpu, SBI_CTL_STAT) & SBI_OPCODE_MASK) >>\n\t\t\t\tSBI_OPCODE_SHIFT) == SBI_CMD_CRRD) {\n\t\tunsigned int sbi_offset = (vgpu_vreg_t(vgpu, SBI_ADDR) &\n\t\t\t\tSBI_ADDR_OFFSET_MASK) >> SBI_ADDR_OFFSET_SHIFT;\n\t\tvgpu_vreg(vgpu, offset) = read_virtual_sbi_register(vgpu,\n\t\t\t\tsbi_offset);\n\t}\n\tread_vreg(vgpu, offset, p_data, bytes);\n\treturn 0;\n}\n\nstatic int sbi_ctl_mmio_write(struct intel_vgpu *vgpu, unsigned int offset,\n\t\tvoid *p_data, unsigned int bytes)\n{\n\tu32 data;\n\n\twrite_vreg(vgpu, offset, p_data, bytes);\n\tdata = vgpu_vreg(vgpu, offset);\n\n\tdata &= ~(SBI_STAT_MASK << SBI_STAT_SHIFT);\n\tdata |= SBI_READY;\n\n\tdata &= ~(SBI_RESPONSE_MASK << SBI_RESPONSE_SHIFT);\n\tdata |= SBI_RESPONSE_SUCCESS;\n\n\tvgpu_vreg(vgpu, offset) = data;\n\n\tif (((vgpu_vreg_t(vgpu, SBI_CTL_STAT) & SBI_OPCODE_MASK) >>\n\t\t\t\tSBI_OPCODE_SHIFT) == SBI_CMD_CRWR) {\n\t\tunsigned int sbi_offset = (vgpu_vreg_t(vgpu, SBI_ADDR) &\n\t\t\t\tSBI_ADDR_OFFSET_MASK) >> SBI_ADDR_OFFSET_SHIFT;\n\n\t\twrite_virtual_sbi_register(vgpu, sbi_offset,\n\t\t\t\t\t   vgpu_vreg_t(vgpu, SBI_DATA));\n\t}\n\treturn 0;\n}\n\n#define _vgtif_reg(x) \\\n\t(VGT_PVINFO_PAGE + offsetof(struct vgt_if, x))\n\nstatic int pvinfo_mmio_read(struct intel_vgpu *vgpu, unsigned int offset,\n\t\tvoid *p_data, unsigned int bytes)\n{\n\tbool invalid_read = false;\n\n\tread_vreg(vgpu, offset, p_data, bytes);\n\n\tswitch (offset) {\n\tcase _vgtif_reg(magic) ... _vgtif_reg(vgt_id):\n\t\tif (offset + bytes > _vgtif_reg(vgt_id) + 4)\n\t\t\tinvalid_read = true;\n\t\tbreak;\n\tcase _vgtif_reg(avail_rs.mappable_gmadr.base) ...\n\t\t_vgtif_reg(avail_rs.fence_num):\n\t\tif (offset + bytes >\n\t\t\t_vgtif_reg(avail_rs.fence_num) + 4)\n\t\t\tinvalid_read = true;\n\t\tbreak;\n\tcase 0x78010:\t \n\tcase 0x7881c:\n\t\tbreak;\n\tdefault:\n\t\tinvalid_read = true;\n\t\tbreak;\n\t}\n\tif (invalid_read)\n\t\tgvt_vgpu_err(\"invalid pvinfo read: [%x:%x] = %x\\n\",\n\t\t\t\toffset, bytes, *(u32 *)p_data);\n\tvgpu->pv_notified = true;\n\treturn 0;\n}\n\nstatic int handle_g2v_notification(struct intel_vgpu *vgpu, int notification)\n{\n\tenum intel_gvt_gtt_type root_entry_type = GTT_TYPE_PPGTT_ROOT_L4_ENTRY;\n\tstruct intel_vgpu_mm *mm;\n\tu64 *pdps;\n\n\tpdps = (u64 *)&vgpu_vreg64_t(vgpu, vgtif_reg(pdp[0]));\n\n\tswitch (notification) {\n\tcase VGT_G2V_PPGTT_L3_PAGE_TABLE_CREATE:\n\t\troot_entry_type = GTT_TYPE_PPGTT_ROOT_L3_ENTRY;\n\t\tfallthrough;\n\tcase VGT_G2V_PPGTT_L4_PAGE_TABLE_CREATE:\n\t\tmm = intel_vgpu_get_ppgtt_mm(vgpu, root_entry_type, pdps);\n\t\treturn PTR_ERR_OR_ZERO(mm);\n\tcase VGT_G2V_PPGTT_L3_PAGE_TABLE_DESTROY:\n\tcase VGT_G2V_PPGTT_L4_PAGE_TABLE_DESTROY:\n\t\treturn intel_vgpu_put_ppgtt_mm(vgpu, pdps);\n\tcase VGT_G2V_EXECLIST_CONTEXT_CREATE:\n\tcase VGT_G2V_EXECLIST_CONTEXT_DESTROY:\n\tcase 1:\t \n\t\tbreak;\n\tdefault:\n\t\tgvt_vgpu_err(\"Invalid PV notification %d\\n\", notification);\n\t}\n\treturn 0;\n}\n\nstatic int send_display_ready_uevent(struct intel_vgpu *vgpu, int ready)\n{\n\tstruct kobject *kobj = &vgpu->gvt->gt->i915->drm.primary->kdev->kobj;\n\tchar *env[3] = {NULL, NULL, NULL};\n\tchar vmid_str[20];\n\tchar display_ready_str[20];\n\n\tsnprintf(display_ready_str, 20, \"GVT_DISPLAY_READY=%d\", ready);\n\tenv[0] = display_ready_str;\n\n\tsnprintf(vmid_str, 20, \"VMID=%d\", vgpu->id);\n\tenv[1] = vmid_str;\n\n\treturn kobject_uevent_env(kobj, KOBJ_ADD, env);\n}\n\nstatic int pvinfo_mmio_write(struct intel_vgpu *vgpu, unsigned int offset,\n\t\tvoid *p_data, unsigned int bytes)\n{\n\tu32 data = *(u32 *)p_data;\n\tbool invalid_write = false;\n\n\tswitch (offset) {\n\tcase _vgtif_reg(display_ready):\n\t\tsend_display_ready_uevent(vgpu, data ? 1 : 0);\n\t\tbreak;\n\tcase _vgtif_reg(g2v_notify):\n\t\thandle_g2v_notification(vgpu, data);\n\t\tbreak;\n\t \n\tcase _vgtif_reg(cursor_x_hot):\n\tcase _vgtif_reg(cursor_y_hot):\n\tcase _vgtif_reg(pdp[0].lo):\n\tcase _vgtif_reg(pdp[0].hi):\n\tcase _vgtif_reg(pdp[1].lo):\n\tcase _vgtif_reg(pdp[1].hi):\n\tcase _vgtif_reg(pdp[2].lo):\n\tcase _vgtif_reg(pdp[2].hi):\n\tcase _vgtif_reg(pdp[3].lo):\n\tcase _vgtif_reg(pdp[3].hi):\n\tcase _vgtif_reg(execlist_context_descriptor_lo):\n\tcase _vgtif_reg(execlist_context_descriptor_hi):\n\t\tbreak;\n\tcase _vgtif_reg(rsv5[0])..._vgtif_reg(rsv5[3]):\n\t\tinvalid_write = true;\n\t\tenter_failsafe_mode(vgpu, GVT_FAILSAFE_INSUFFICIENT_RESOURCE);\n\t\tbreak;\n\tdefault:\n\t\tinvalid_write = true;\n\t\tgvt_vgpu_err(\"invalid pvinfo write offset %x bytes %x data %x\\n\",\n\t\t\t\toffset, bytes, data);\n\t\tbreak;\n\t}\n\n\tif (!invalid_write)\n\t\twrite_vreg(vgpu, offset, p_data, bytes);\n\n\treturn 0;\n}\n\nstatic int pf_write(struct intel_vgpu *vgpu,\n\t\tunsigned int offset, void *p_data, unsigned int bytes)\n{\n\tstruct drm_i915_private *i915 = vgpu->gvt->gt->i915;\n\tu32 val = *(u32 *)p_data;\n\n\tif ((offset == _PS_1A_CTRL || offset == _PS_2A_CTRL ||\n\t   offset == _PS_1B_CTRL || offset == _PS_2B_CTRL ||\n\t   offset == _PS_1C_CTRL) && (val & PS_BINDING_MASK) != PS_BINDING_PIPE) {\n\t\tdrm_WARN_ONCE(&i915->drm, true,\n\t\t\t      \"VM(%d): guest is trying to scaling a plane\\n\",\n\t\t\t      vgpu->id);\n\t\treturn 0;\n\t}\n\n\treturn intel_vgpu_default_mmio_write(vgpu, offset, p_data, bytes);\n}\n\nstatic int power_well_ctl_mmio_write(struct intel_vgpu *vgpu,\n\t\tunsigned int offset, void *p_data, unsigned int bytes)\n{\n\twrite_vreg(vgpu, offset, p_data, bytes);\n\n\tif (vgpu_vreg(vgpu, offset) &\n\t    HSW_PWR_WELL_CTL_REQ(HSW_PW_CTL_IDX_GLOBAL))\n\t\tvgpu_vreg(vgpu, offset) |=\n\t\t\tHSW_PWR_WELL_CTL_STATE(HSW_PW_CTL_IDX_GLOBAL);\n\telse\n\t\tvgpu_vreg(vgpu, offset) &=\n\t\t\t~HSW_PWR_WELL_CTL_STATE(HSW_PW_CTL_IDX_GLOBAL);\n\treturn 0;\n}\n\nstatic int gen9_dbuf_ctl_mmio_write(struct intel_vgpu *vgpu,\n\t\tunsigned int offset, void *p_data, unsigned int bytes)\n{\n\twrite_vreg(vgpu, offset, p_data, bytes);\n\n\tif (vgpu_vreg(vgpu, offset) & DBUF_POWER_REQUEST)\n\t\tvgpu_vreg(vgpu, offset) |= DBUF_POWER_STATE;\n\telse\n\t\tvgpu_vreg(vgpu, offset) &= ~DBUF_POWER_STATE;\n\n\treturn 0;\n}\n\nstatic int fpga_dbg_mmio_write(struct intel_vgpu *vgpu,\n\tunsigned int offset, void *p_data, unsigned int bytes)\n{\n\twrite_vreg(vgpu, offset, p_data, bytes);\n\n\tif (vgpu_vreg(vgpu, offset) & FPGA_DBG_RM_NOCLAIM)\n\t\tvgpu_vreg(vgpu, offset) &= ~FPGA_DBG_RM_NOCLAIM;\n\treturn 0;\n}\n\nstatic int dma_ctrl_write(struct intel_vgpu *vgpu, unsigned int offset,\n\t\tvoid *p_data, unsigned int bytes)\n{\n\tstruct drm_i915_private *i915 = vgpu->gvt->gt->i915;\n\tu32 mode;\n\n\twrite_vreg(vgpu, offset, p_data, bytes);\n\tmode = vgpu_vreg(vgpu, offset);\n\n\tif (GFX_MODE_BIT_SET_IN_MASK(mode, START_DMA)) {\n\t\tdrm_WARN_ONCE(&i915->drm, 1,\n\t\t\t\t\"VM(%d): iGVT-g doesn't support GuC\\n\",\n\t\t\t\tvgpu->id);\n\t\treturn 0;\n\t}\n\n\treturn 0;\n}\n\nstatic int gen9_trtte_write(struct intel_vgpu *vgpu, unsigned int offset,\n\t\tvoid *p_data, unsigned int bytes)\n{\n\tstruct drm_i915_private *i915 = vgpu->gvt->gt->i915;\n\tu32 trtte = *(u32 *)p_data;\n\n\tif ((trtte & 1) && (trtte & (1 << 1)) == 0) {\n\t\tdrm_WARN(&i915->drm, 1,\n\t\t\t\t\"VM(%d): Use physical address for TRTT!\\n\",\n\t\t\t\tvgpu->id);\n\t\treturn -EINVAL;\n\t}\n\twrite_vreg(vgpu, offset, p_data, bytes);\n\n\treturn 0;\n}\n\nstatic int gen9_trtt_chicken_write(struct intel_vgpu *vgpu, unsigned int offset,\n\t\tvoid *p_data, unsigned int bytes)\n{\n\twrite_vreg(vgpu, offset, p_data, bytes);\n\treturn 0;\n}\n\nstatic int dpll_status_read(struct intel_vgpu *vgpu, unsigned int offset,\n\t\tvoid *p_data, unsigned int bytes)\n{\n\tu32 v = 0;\n\n\tif (vgpu_vreg(vgpu, 0x46010) & (1 << 31))\n\t\tv |= (1 << 0);\n\n\tif (vgpu_vreg(vgpu, 0x46014) & (1 << 31))\n\t\tv |= (1 << 8);\n\n\tif (vgpu_vreg(vgpu, 0x46040) & (1 << 31))\n\t\tv |= (1 << 16);\n\n\tif (vgpu_vreg(vgpu, 0x46060) & (1 << 31))\n\t\tv |= (1 << 24);\n\n\tvgpu_vreg(vgpu, offset) = v;\n\n\treturn intel_vgpu_default_mmio_read(vgpu, offset, p_data, bytes);\n}\n\nstatic int mailbox_write(struct intel_vgpu *vgpu, unsigned int offset,\n\t\tvoid *p_data, unsigned int bytes)\n{\n\tu32 value = *(u32 *)p_data;\n\tu32 cmd = value & 0xff;\n\tu32 *data0 = &vgpu_vreg_t(vgpu, GEN6_PCODE_DATA);\n\n\tswitch (cmd) {\n\tcase GEN9_PCODE_READ_MEM_LATENCY:\n\t\tif (IS_SKYLAKE(vgpu->gvt->gt->i915) ||\n\t\t    IS_KABYLAKE(vgpu->gvt->gt->i915) ||\n\t\t    IS_COFFEELAKE(vgpu->gvt->gt->i915) ||\n\t\t    IS_COMETLAKE(vgpu->gvt->gt->i915)) {\n\t\t\t \n\t\t\tif (!*data0)\n\t\t\t\t*data0 = 0x1e1a1100;\n\t\t\telse\n\t\t\t\t*data0 = 0x61514b3d;\n\t\t} else if (IS_BROXTON(vgpu->gvt->gt->i915)) {\n\t\t\t \n\t\t\tif (!*data0)\n\t\t\t\t*data0 = 0x16080707;\n\t\t\telse\n\t\t\t\t*data0 = 0x16161616;\n\t\t}\n\t\tbreak;\n\tcase SKL_PCODE_CDCLK_CONTROL:\n\t\tif (IS_SKYLAKE(vgpu->gvt->gt->i915) ||\n\t\t    IS_KABYLAKE(vgpu->gvt->gt->i915) ||\n\t\t    IS_COFFEELAKE(vgpu->gvt->gt->i915) ||\n\t\t    IS_COMETLAKE(vgpu->gvt->gt->i915))\n\t\t\t*data0 = SKL_CDCLK_READY_FOR_CHANGE;\n\t\tbreak;\n\tcase GEN6_PCODE_READ_RC6VIDS:\n\t\t*data0 |= 0x1;\n\t\tbreak;\n\t}\n\n\tgvt_dbg_core(\"VM(%d) write %x to mailbox, return data0 %x\\n\",\n\t\t     vgpu->id, value, *data0);\n\t \n\tvalue &= ~(GEN6_PCODE_READY | GEN6_PCODE_ERROR_MASK);\n\treturn intel_vgpu_default_mmio_write(vgpu, offset, &value, bytes);\n}\n\nstatic int hws_pga_write(struct intel_vgpu *vgpu, unsigned int offset,\n\t\tvoid *p_data, unsigned int bytes)\n{\n\tu32 value = *(u32 *)p_data;\n\tconst struct intel_engine_cs *engine =\n\t\tintel_gvt_render_mmio_to_engine(vgpu->gvt, offset);\n\n\tif (value != 0 &&\n\t    !intel_gvt_ggtt_validate_range(vgpu, value, I915_GTT_PAGE_SIZE)) {\n\t\tgvt_vgpu_err(\"write invalid HWSP address, reg:0x%x, value:0x%x\\n\",\n\t\t\t      offset, value);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (unlikely(!engine)) {\n\t\tgvt_vgpu_err(\"access unknown hardware status page register:0x%x\\n\",\n\t\t\t     offset);\n\t\treturn -EINVAL;\n\t}\n\tvgpu->hws_pga[engine->id] = value;\n\tgvt_dbg_mmio(\"VM(%d) write: 0x%x to HWSP: 0x%x\\n\",\n\t\t     vgpu->id, value, offset);\n\n\treturn intel_vgpu_default_mmio_write(vgpu, offset, &value, bytes);\n}\n\nstatic int skl_power_well_ctl_write(struct intel_vgpu *vgpu,\n\t\tunsigned int offset, void *p_data, unsigned int bytes)\n{\n\tu32 v = *(u32 *)p_data;\n\n\tif (IS_BROXTON(vgpu->gvt->gt->i915))\n\t\tv &= (1 << 31) | (1 << 29);\n\telse\n\t\tv &= (1 << 31) | (1 << 29) | (1 << 9) |\n\t\t\t(1 << 7) | (1 << 5) | (1 << 3) | (1 << 1);\n\tv |= (v >> 1);\n\n\treturn intel_vgpu_default_mmio_write(vgpu, offset, &v, bytes);\n}\n\nstatic int skl_lcpll_write(struct intel_vgpu *vgpu, unsigned int offset,\n\t\tvoid *p_data, unsigned int bytes)\n{\n\tu32 v = *(u32 *)p_data;\n\n\t \n\tv &= (1 << 31) | (1 << 30);\n\tv & (1 << 31) ? (v |= (1 << 30)) : (v &= ~(1 << 30));\n\n\tvgpu_vreg(vgpu, offset) = v;\n\n\treturn 0;\n}\n\nstatic int bxt_de_pll_enable_write(struct intel_vgpu *vgpu,\n\t\tunsigned int offset, void *p_data, unsigned int bytes)\n{\n\tu32 v = *(u32 *)p_data;\n\n\tif (v & BXT_DE_PLL_PLL_ENABLE)\n\t\tv |= BXT_DE_PLL_LOCK;\n\n\tvgpu_vreg(vgpu, offset) = v;\n\n\treturn 0;\n}\n\nstatic int bxt_port_pll_enable_write(struct intel_vgpu *vgpu,\n\t\tunsigned int offset, void *p_data, unsigned int bytes)\n{\n\tu32 v = *(u32 *)p_data;\n\n\tif (v & PORT_PLL_ENABLE)\n\t\tv |= PORT_PLL_LOCK;\n\n\tvgpu_vreg(vgpu, offset) = v;\n\n\treturn 0;\n}\n\nstatic int bxt_phy_ctl_family_write(struct intel_vgpu *vgpu,\n\t\tunsigned int offset, void *p_data, unsigned int bytes)\n{\n\tu32 v = *(u32 *)p_data;\n\tu32 data = v & COMMON_RESET_DIS ? BXT_PHY_LANE_ENABLED : 0;\n\n\tswitch (offset) {\n\tcase _PHY_CTL_FAMILY_EDP:\n\t\tvgpu_vreg(vgpu, _BXT_PHY_CTL_DDI_A) = data;\n\t\tbreak;\n\tcase _PHY_CTL_FAMILY_DDI:\n\t\tvgpu_vreg(vgpu, _BXT_PHY_CTL_DDI_B) = data;\n\t\tvgpu_vreg(vgpu, _BXT_PHY_CTL_DDI_C) = data;\n\t\tbreak;\n\t}\n\n\tvgpu_vreg(vgpu, offset) = v;\n\n\treturn 0;\n}\n\nstatic int bxt_port_tx_dw3_read(struct intel_vgpu *vgpu,\n\t\tunsigned int offset, void *p_data, unsigned int bytes)\n{\n\tu32 v = vgpu_vreg(vgpu, offset);\n\n\tv &= ~UNIQUE_TRANGE_EN_METHOD;\n\n\tvgpu_vreg(vgpu, offset) = v;\n\n\treturn intel_vgpu_default_mmio_read(vgpu, offset, p_data, bytes);\n}\n\nstatic int bxt_pcs_dw12_grp_write(struct intel_vgpu *vgpu,\n\t\tunsigned int offset, void *p_data, unsigned int bytes)\n{\n\tu32 v = *(u32 *)p_data;\n\n\tif (offset == _PORT_PCS_DW12_GRP_A || offset == _PORT_PCS_DW12_GRP_B) {\n\t\tvgpu_vreg(vgpu, offset - 0x600) = v;\n\t\tvgpu_vreg(vgpu, offset - 0x800) = v;\n\t} else {\n\t\tvgpu_vreg(vgpu, offset - 0x400) = v;\n\t\tvgpu_vreg(vgpu, offset - 0x600) = v;\n\t}\n\n\tvgpu_vreg(vgpu, offset) = v;\n\n\treturn 0;\n}\n\nstatic int bxt_gt_disp_pwron_write(struct intel_vgpu *vgpu,\n\t\tunsigned int offset, void *p_data, unsigned int bytes)\n{\n\tu32 v = *(u32 *)p_data;\n\n\tif (v & BIT(0)) {\n\t\tvgpu_vreg_t(vgpu, BXT_PORT_CL1CM_DW0(DPIO_PHY0)) &=\n\t\t\t~PHY_RESERVED;\n\t\tvgpu_vreg_t(vgpu, BXT_PORT_CL1CM_DW0(DPIO_PHY0)) |=\n\t\t\tPHY_POWER_GOOD;\n\t}\n\n\tif (v & BIT(1)) {\n\t\tvgpu_vreg_t(vgpu, BXT_PORT_CL1CM_DW0(DPIO_PHY1)) &=\n\t\t\t~PHY_RESERVED;\n\t\tvgpu_vreg_t(vgpu, BXT_PORT_CL1CM_DW0(DPIO_PHY1)) |=\n\t\t\tPHY_POWER_GOOD;\n\t}\n\n\n\tvgpu_vreg(vgpu, offset) = v;\n\n\treturn 0;\n}\n\nstatic int edp_psr_imr_iir_write(struct intel_vgpu *vgpu,\n\t\tunsigned int offset, void *p_data, unsigned int bytes)\n{\n\tvgpu_vreg(vgpu, offset) = 0;\n\treturn 0;\n}\n\n \nstatic int bxt_ppat_low_write(struct intel_vgpu *vgpu, unsigned int offset,\n\t\t\t      void *p_data, unsigned int bytes)\n{\n\tu64 pat =\n\t\tGEN8_PPAT(0, CHV_PPAT_SNOOP) |\n\t\tGEN8_PPAT(1, 0) |\n\t\tGEN8_PPAT(2, 0) |\n\t\tGEN8_PPAT(3, CHV_PPAT_SNOOP) |\n\t\tGEN8_PPAT(4, CHV_PPAT_SNOOP) |\n\t\tGEN8_PPAT(5, CHV_PPAT_SNOOP) |\n\t\tGEN8_PPAT(6, CHV_PPAT_SNOOP) |\n\t\tGEN8_PPAT(7, CHV_PPAT_SNOOP);\n\n\tvgpu_vreg(vgpu, offset) = lower_32_bits(pat);\n\n\treturn 0;\n}\n\nstatic int guc_status_read(struct intel_vgpu *vgpu,\n\t\t\t   unsigned int offset, void *p_data,\n\t\t\t   unsigned int bytes)\n{\n\t \n\tread_vreg(vgpu, offset, p_data, bytes);\n\tvgpu_vreg(vgpu, offset) &= ~GS_MIA_IN_RESET;\n\treturn 0;\n}\n\nstatic int mmio_read_from_hw(struct intel_vgpu *vgpu,\n\t\tunsigned int offset, void *p_data, unsigned int bytes)\n{\n\tstruct intel_gvt *gvt = vgpu->gvt;\n\tconst struct intel_engine_cs *engine =\n\t\tintel_gvt_render_mmio_to_engine(gvt, offset);\n\n\t \n\n\tif (!engine ||\n\t    vgpu == gvt->scheduler.engine_owner[engine->id] ||\n\t    offset == i915_mmio_reg_offset(RING_TIMESTAMP(engine->mmio_base)) ||\n\t    offset == i915_mmio_reg_offset(RING_TIMESTAMP_UDW(engine->mmio_base))) {\n\t\tmmio_hw_access_pre(gvt->gt);\n\t\tvgpu_vreg(vgpu, offset) =\n\t\t\tintel_uncore_read(gvt->gt->uncore, _MMIO(offset));\n\t\tmmio_hw_access_post(gvt->gt);\n\t}\n\n\treturn intel_vgpu_default_mmio_read(vgpu, offset, p_data, bytes);\n}\n\nstatic int elsp_mmio_write(struct intel_vgpu *vgpu, unsigned int offset,\n\t\tvoid *p_data, unsigned int bytes)\n{\n\tstruct drm_i915_private *i915 = vgpu->gvt->gt->i915;\n\tconst struct intel_engine_cs *engine = intel_gvt_render_mmio_to_engine(vgpu->gvt, offset);\n\tstruct intel_vgpu_execlist *execlist;\n\tu32 data = *(u32 *)p_data;\n\tint ret = 0;\n\n\tif (drm_WARN_ON(&i915->drm, !engine))\n\t\treturn -EINVAL;\n\n\t \n\tif (vgpu->d3_entered)\n\t\tvgpu->d3_entered = false;\n\n\texeclist = &vgpu->submission.execlist[engine->id];\n\n\texeclist->elsp_dwords.data[3 - execlist->elsp_dwords.index] = data;\n\tif (execlist->elsp_dwords.index == 3) {\n\t\tret = intel_vgpu_submit_execlist(vgpu, engine);\n\t\tif(ret)\n\t\t\tgvt_vgpu_err(\"fail submit workload on ring %s\\n\",\n\t\t\t\t     engine->name);\n\t}\n\n\t++execlist->elsp_dwords.index;\n\texeclist->elsp_dwords.index &= 0x3;\n\treturn ret;\n}\n\nstatic int ring_mode_mmio_write(struct intel_vgpu *vgpu, unsigned int offset,\n\t\tvoid *p_data, unsigned int bytes)\n{\n\tu32 data = *(u32 *)p_data;\n\tconst struct intel_engine_cs *engine =\n\t\tintel_gvt_render_mmio_to_engine(vgpu->gvt, offset);\n\tbool enable_execlist;\n\tint ret;\n\n\t(*(u32 *)p_data) &= ~_MASKED_BIT_ENABLE(1);\n\tif (IS_COFFEELAKE(vgpu->gvt->gt->i915) ||\n\t    IS_COMETLAKE(vgpu->gvt->gt->i915))\n\t\t(*(u32 *)p_data) &= ~_MASKED_BIT_ENABLE(2);\n\twrite_vreg(vgpu, offset, p_data, bytes);\n\n\tif (IS_MASKED_BITS_ENABLED(data, 1)) {\n\t\tenter_failsafe_mode(vgpu, GVT_FAILSAFE_UNSUPPORTED_GUEST);\n\t\treturn 0;\n\t}\n\n\tif ((IS_COFFEELAKE(vgpu->gvt->gt->i915) ||\n\t     IS_COMETLAKE(vgpu->gvt->gt->i915)) &&\n\t    IS_MASKED_BITS_ENABLED(data, 2)) {\n\t\tenter_failsafe_mode(vgpu, GVT_FAILSAFE_UNSUPPORTED_GUEST);\n\t\treturn 0;\n\t}\n\n\t \n\tif ((IS_MASKED_BITS_ENABLED(data, GFX_PPGTT_ENABLE) ||\n\t    IS_MASKED_BITS_ENABLED(data, GFX_RUN_LIST_ENABLE)) &&\n\t    !vgpu->pv_notified) {\n\t\tenter_failsafe_mode(vgpu, GVT_FAILSAFE_UNSUPPORTED_GUEST);\n\t\treturn 0;\n\t}\n\tif (IS_MASKED_BITS_ENABLED(data, GFX_RUN_LIST_ENABLE) ||\n\t    IS_MASKED_BITS_DISABLED(data, GFX_RUN_LIST_ENABLE)) {\n\t\tenable_execlist = !!(data & GFX_RUN_LIST_ENABLE);\n\n\t\tgvt_dbg_core(\"EXECLIST %s on ring %s\\n\",\n\t\t\t     (enable_execlist ? \"enabling\" : \"disabling\"),\n\t\t\t     engine->name);\n\n\t\tif (!enable_execlist)\n\t\t\treturn 0;\n\n\t\tret = intel_vgpu_select_submission_ops(vgpu,\n\t\t\t\t\t\t       engine->mask,\n\t\t\t\t\t\t       INTEL_VGPU_EXECLIST_SUBMISSION);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tintel_vgpu_start_schedule(vgpu);\n\t}\n\treturn 0;\n}\n\nstatic int gvt_reg_tlb_control_handler(struct intel_vgpu *vgpu,\n\t\tunsigned int offset, void *p_data, unsigned int bytes)\n{\n\tunsigned int id = 0;\n\n\twrite_vreg(vgpu, offset, p_data, bytes);\n\tvgpu_vreg(vgpu, offset) = 0;\n\n\tswitch (offset) {\n\tcase 0x4260:\n\t\tid = RCS0;\n\t\tbreak;\n\tcase 0x4264:\n\t\tid = VCS0;\n\t\tbreak;\n\tcase 0x4268:\n\t\tid = VCS1;\n\t\tbreak;\n\tcase 0x426c:\n\t\tid = BCS0;\n\t\tbreak;\n\tcase 0x4270:\n\t\tid = VECS0;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\tset_bit(id, (void *)vgpu->submission.tlb_handle_pending);\n\n\treturn 0;\n}\n\nstatic int ring_reset_ctl_write(struct intel_vgpu *vgpu,\n\tunsigned int offset, void *p_data, unsigned int bytes)\n{\n\tu32 data;\n\n\twrite_vreg(vgpu, offset, p_data, bytes);\n\tdata = vgpu_vreg(vgpu, offset);\n\n\tif (IS_MASKED_BITS_ENABLED(data, RESET_CTL_REQUEST_RESET))\n\t\tdata |= RESET_CTL_READY_TO_RESET;\n\telse if (data & _MASKED_BIT_DISABLE(RESET_CTL_REQUEST_RESET))\n\t\tdata &= ~RESET_CTL_READY_TO_RESET;\n\n\tvgpu_vreg(vgpu, offset) = data;\n\treturn 0;\n}\n\nstatic int csfe_chicken1_mmio_write(struct intel_vgpu *vgpu,\n\t\t\t\t    unsigned int offset, void *p_data,\n\t\t\t\t    unsigned int bytes)\n{\n\tu32 data = *(u32 *)p_data;\n\n\t(*(u32 *)p_data) &= ~_MASKED_BIT_ENABLE(0x18);\n\twrite_vreg(vgpu, offset, p_data, bytes);\n\n\tif (IS_MASKED_BITS_ENABLED(data, 0x10) ||\n\t    IS_MASKED_BITS_ENABLED(data, 0x8))\n\t\tenter_failsafe_mode(vgpu, GVT_FAILSAFE_UNSUPPORTED_GUEST);\n\n\treturn 0;\n}\n\n#define MMIO_F(reg, s, f, am, rm, d, r, w) do { \\\n\tret = setup_mmio_info(gvt, i915_mmio_reg_offset(reg), \\\n\t\ts, f, am, rm, d, r, w); \\\n\tif (ret) \\\n\t\treturn ret; \\\n} while (0)\n\n#define MMIO_DH(reg, d, r, w) \\\n\tMMIO_F(reg, 4, 0, 0, 0, d, r, w)\n\n#define MMIO_DFH(reg, d, f, r, w) \\\n\tMMIO_F(reg, 4, f, 0, 0, d, r, w)\n\n#define MMIO_GM(reg, d, r, w) \\\n\tMMIO_F(reg, 4, F_GMADR, 0xFFFFF000, 0, d, r, w)\n\n#define MMIO_GM_RDR(reg, d, r, w) \\\n\tMMIO_F(reg, 4, F_GMADR | F_CMD_ACCESS, 0xFFFFF000, 0, d, r, w)\n\n#define MMIO_RO(reg, d, f, rm, r, w) \\\n\tMMIO_F(reg, 4, F_RO | f, 0, rm, d, r, w)\n\n#define MMIO_RING_F(prefix, s, f, am, rm, d, r, w) do { \\\n\tMMIO_F(prefix(RENDER_RING_BASE), s, f, am, rm, d, r, w); \\\n\tMMIO_F(prefix(BLT_RING_BASE), s, f, am, rm, d, r, w); \\\n\tMMIO_F(prefix(GEN6_BSD_RING_BASE), s, f, am, rm, d, r, w); \\\n\tMMIO_F(prefix(VEBOX_RING_BASE), s, f, am, rm, d, r, w); \\\n\tif (HAS_ENGINE(gvt->gt, VCS1)) \\\n\t\tMMIO_F(prefix(GEN8_BSD2_RING_BASE), s, f, am, rm, d, r, w); \\\n} while (0)\n\n#define MMIO_RING_DFH(prefix, d, f, r, w) \\\n\tMMIO_RING_F(prefix, 4, f, 0, 0, d, r, w)\n\n#define MMIO_RING_GM(prefix, d, r, w) \\\n\tMMIO_RING_F(prefix, 4, F_GMADR, 0xFFFF0000, 0, d, r, w)\n\n#define MMIO_RING_GM_RDR(prefix, d, r, w) \\\n\tMMIO_RING_F(prefix, 4, F_GMADR | F_CMD_ACCESS, 0xFFFF0000, 0, d, r, w)\n\n#define MMIO_RING_RO(prefix, d, f, rm, r, w) \\\n\tMMIO_RING_F(prefix, 4, F_RO | f, 0, rm, d, r, w)\n\nstatic int init_generic_mmio_info(struct intel_gvt *gvt)\n{\n\tstruct drm_i915_private *dev_priv = gvt->gt->i915;\n\tint ret;\n\n\tMMIO_RING_DFH(RING_IMR, D_ALL, 0, NULL,\n\t\tintel_vgpu_reg_imr_handler);\n\n\tMMIO_DFH(SDEIMR, D_ALL, 0, NULL, intel_vgpu_reg_imr_handler);\n\tMMIO_DFH(SDEIER, D_ALL, 0, NULL, intel_vgpu_reg_ier_handler);\n\tMMIO_DFH(SDEIIR, D_ALL, 0, NULL, intel_vgpu_reg_iir_handler);\n\n\tMMIO_RING_DFH(RING_HWSTAM, D_ALL, 0, NULL, NULL);\n\n\n\tMMIO_DH(GEN8_GAMW_ECO_DEV_RW_IA, D_BDW_PLUS, NULL,\n\t\tgamw_echo_dev_rw_ia_write);\n\n\tMMIO_GM_RDR(BSD_HWS_PGA_GEN7, D_ALL, NULL, NULL);\n\tMMIO_GM_RDR(BLT_HWS_PGA_GEN7, D_ALL, NULL, NULL);\n\tMMIO_GM_RDR(VEBOX_HWS_PGA_GEN7, D_ALL, NULL, NULL);\n\n#define RING_REG(base) _MMIO((base) + 0x28)\n\tMMIO_RING_DFH(RING_REG, D_ALL, F_CMD_ACCESS, NULL, NULL);\n#undef RING_REG\n\n#define RING_REG(base) _MMIO((base) + 0x134)\n\tMMIO_RING_DFH(RING_REG, D_ALL, F_CMD_ACCESS, NULL, NULL);\n#undef RING_REG\n\n#define RING_REG(base) _MMIO((base) + 0x6c)\n\tMMIO_RING_DFH(RING_REG, D_ALL, 0, mmio_read_from_hw, NULL);\n#undef RING_REG\n\tMMIO_DH(GEN7_SC_INSTDONE, D_BDW_PLUS, mmio_read_from_hw, NULL);\n\n\tMMIO_GM_RDR(_MMIO(0x2148), D_ALL, NULL, NULL);\n\tMMIO_GM_RDR(CCID(RENDER_RING_BASE), D_ALL, NULL, NULL);\n\tMMIO_GM_RDR(_MMIO(0x12198), D_ALL, NULL, NULL);\n\n\tMMIO_RING_DFH(RING_TAIL, D_ALL, 0, NULL, NULL);\n\tMMIO_RING_DFH(RING_HEAD, D_ALL, 0, NULL, NULL);\n\tMMIO_RING_DFH(RING_CTL, D_ALL, 0, NULL, NULL);\n\tMMIO_RING_DFH(RING_ACTHD, D_ALL, 0, mmio_read_from_hw, NULL);\n\tMMIO_RING_GM(RING_START, D_ALL, NULL, NULL);\n\n\t \n#define RING_REG(base) _MMIO((base) + 0x29c)\n\tMMIO_RING_DFH(RING_REG, D_ALL,\n\t\tF_MODE_MASK | F_CMD_ACCESS | F_CMD_WRITE_PATCH, NULL,\n\t\tring_mode_mmio_write);\n#undef RING_REG\n\n\tMMIO_RING_DFH(RING_MI_MODE, D_ALL, F_MODE_MASK | F_CMD_ACCESS,\n\t\tNULL, NULL);\n\tMMIO_RING_DFH(RING_INSTPM, D_ALL, F_MODE_MASK | F_CMD_ACCESS,\n\t\t\tNULL, NULL);\n\tMMIO_RING_DFH(RING_TIMESTAMP, D_ALL, F_CMD_ACCESS,\n\t\t\tmmio_read_from_hw, NULL);\n\tMMIO_RING_DFH(RING_TIMESTAMP_UDW, D_ALL, F_CMD_ACCESS,\n\t\t\tmmio_read_from_hw, NULL);\n\n\tMMIO_DFH(GEN7_GT_MODE, D_ALL, F_MODE_MASK | F_CMD_ACCESS, NULL, NULL);\n\tMMIO_DFH(CACHE_MODE_0_GEN7, D_ALL, F_MODE_MASK | F_CMD_ACCESS,\n\t\tNULL, NULL);\n\tMMIO_DFH(CACHE_MODE_1, D_ALL, F_MODE_MASK | F_CMD_ACCESS, NULL, NULL);\n\tMMIO_DFH(CACHE_MODE_0, D_ALL, F_MODE_MASK | F_CMD_ACCESS, NULL, NULL);\n\tMMIO_DFH(_MMIO(0x2124), D_ALL, F_MODE_MASK | F_CMD_ACCESS, NULL, NULL);\n\n\tMMIO_DFH(_MMIO(0x20dc), D_ALL, F_MODE_MASK | F_CMD_ACCESS, NULL, NULL);\n\tMMIO_DFH(_3D_CHICKEN3, D_ALL, F_MODE_MASK | F_CMD_ACCESS, NULL, NULL);\n\tMMIO_DFH(_MMIO(0x2088), D_ALL, F_MODE_MASK | F_CMD_ACCESS, NULL, NULL);\n\tMMIO_DFH(FF_SLICE_CS_CHICKEN2, D_ALL,\n\t\t F_MODE_MASK | F_CMD_ACCESS, NULL, NULL);\n\tMMIO_DFH(_MMIO(0x2470), D_ALL, F_MODE_MASK | F_CMD_ACCESS, NULL, NULL);\n\tMMIO_DFH(GAM_ECOCHK, D_ALL, F_CMD_ACCESS, NULL, NULL);\n\tMMIO_DFH(GEN7_COMMON_SLICE_CHICKEN1, D_ALL, F_MODE_MASK | F_CMD_ACCESS,\n\t\tNULL, NULL);\n\tMMIO_DFH(COMMON_SLICE_CHICKEN2, D_ALL, F_MODE_MASK | F_CMD_ACCESS,\n\t\t NULL, NULL);\n\tMMIO_DFH(_MMIO(0x9030), D_ALL, F_CMD_ACCESS, NULL, NULL);\n\tMMIO_DFH(_MMIO(0x20a0), D_ALL, F_CMD_ACCESS, NULL, NULL);\n\tMMIO_DFH(_MMIO(0x2420), D_ALL, F_CMD_ACCESS, NULL, NULL);\n\tMMIO_DFH(_MMIO(0x2430), D_ALL, F_CMD_ACCESS, NULL, NULL);\n\tMMIO_DFH(_MMIO(0x2434), D_ALL, F_CMD_ACCESS, NULL, NULL);\n\tMMIO_DFH(_MMIO(0x2438), D_ALL, F_CMD_ACCESS, NULL, NULL);\n\tMMIO_DFH(_MMIO(0x243c), D_ALL, F_CMD_ACCESS, NULL, NULL);\n\tMMIO_DFH(_MMIO(0x7018), D_ALL, F_MODE_MASK | F_CMD_ACCESS, NULL, NULL);\n\tMMIO_DFH(HSW_HALF_SLICE_CHICKEN3, D_ALL, F_MODE_MASK | F_CMD_ACCESS, NULL, NULL);\n\tMMIO_DFH(GEN7_HALF_SLICE_CHICKEN1, D_ALL, F_MODE_MASK | F_CMD_ACCESS, NULL, NULL);\n\n\t \n\tMMIO_DH(TRANSCONF(TRANSCODER_A), D_ALL, NULL, pipeconf_mmio_write);\n\tMMIO_DH(TRANSCONF(TRANSCODER_B), D_ALL, NULL, pipeconf_mmio_write);\n\tMMIO_DH(TRANSCONF(TRANSCODER_C), D_ALL, NULL, pipeconf_mmio_write);\n\tMMIO_DH(TRANSCONF(TRANSCODER_EDP), D_ALL, NULL, pipeconf_mmio_write);\n\tMMIO_DH(DSPSURF(PIPE_A), D_ALL, NULL, pri_surf_mmio_write);\n\tMMIO_DH(REG_50080(PIPE_A, PLANE_PRIMARY), D_ALL, NULL,\n\t\treg50080_mmio_write);\n\tMMIO_DH(DSPSURF(PIPE_B), D_ALL, NULL, pri_surf_mmio_write);\n\tMMIO_DH(REG_50080(PIPE_B, PLANE_PRIMARY), D_ALL, NULL,\n\t\treg50080_mmio_write);\n\tMMIO_DH(DSPSURF(PIPE_C), D_ALL, NULL, pri_surf_mmio_write);\n\tMMIO_DH(REG_50080(PIPE_C, PLANE_PRIMARY), D_ALL, NULL,\n\t\treg50080_mmio_write);\n\tMMIO_DH(SPRSURF(PIPE_A), D_ALL, NULL, spr_surf_mmio_write);\n\tMMIO_DH(REG_50080(PIPE_A, PLANE_SPRITE0), D_ALL, NULL,\n\t\treg50080_mmio_write);\n\tMMIO_DH(SPRSURF(PIPE_B), D_ALL, NULL, spr_surf_mmio_write);\n\tMMIO_DH(REG_50080(PIPE_B, PLANE_SPRITE0), D_ALL, NULL,\n\t\treg50080_mmio_write);\n\tMMIO_DH(SPRSURF(PIPE_C), D_ALL, NULL, spr_surf_mmio_write);\n\tMMIO_DH(REG_50080(PIPE_C, PLANE_SPRITE0), D_ALL, NULL,\n\t\treg50080_mmio_write);\n\n\tMMIO_F(PCH_GMBUS0, 4 * 4, 0, 0, 0, D_ALL, gmbus_mmio_read,\n\t\tgmbus_mmio_write);\n\tMMIO_F(PCH_GPIO_BASE, 6 * 4, F_UNALIGN, 0, 0, D_ALL, NULL, NULL);\n\n\tMMIO_F(_MMIO(_PCH_DPB_AUX_CH_CTL), 6 * 4, 0, 0, 0, D_PRE_SKL, NULL,\n\t\tdp_aux_ch_ctl_mmio_write);\n\tMMIO_F(_MMIO(_PCH_DPC_AUX_CH_CTL), 6 * 4, 0, 0, 0, D_PRE_SKL, NULL,\n\t\tdp_aux_ch_ctl_mmio_write);\n\tMMIO_F(_MMIO(_PCH_DPD_AUX_CH_CTL), 6 * 4, 0, 0, 0, D_PRE_SKL, NULL,\n\t\tdp_aux_ch_ctl_mmio_write);\n\n\tMMIO_DH(PCH_ADPA, D_PRE_SKL, NULL, pch_adpa_mmio_write);\n\n\tMMIO_DH(_MMIO(_PCH_TRANSACONF), D_ALL, NULL, transconf_mmio_write);\n\tMMIO_DH(_MMIO(_PCH_TRANSBCONF), D_ALL, NULL, transconf_mmio_write);\n\n\tMMIO_DH(FDI_RX_IIR(PIPE_A), D_ALL, NULL, fdi_rx_iir_mmio_write);\n\tMMIO_DH(FDI_RX_IIR(PIPE_B), D_ALL, NULL, fdi_rx_iir_mmio_write);\n\tMMIO_DH(FDI_RX_IIR(PIPE_C), D_ALL, NULL, fdi_rx_iir_mmio_write);\n\tMMIO_DH(FDI_RX_IMR(PIPE_A), D_ALL, NULL, update_fdi_rx_iir_status);\n\tMMIO_DH(FDI_RX_IMR(PIPE_B), D_ALL, NULL, update_fdi_rx_iir_status);\n\tMMIO_DH(FDI_RX_IMR(PIPE_C), D_ALL, NULL, update_fdi_rx_iir_status);\n\tMMIO_DH(FDI_RX_CTL(PIPE_A), D_ALL, NULL, update_fdi_rx_iir_status);\n\tMMIO_DH(FDI_RX_CTL(PIPE_B), D_ALL, NULL, update_fdi_rx_iir_status);\n\tMMIO_DH(FDI_RX_CTL(PIPE_C), D_ALL, NULL, update_fdi_rx_iir_status);\n\tMMIO_DH(PCH_PP_CONTROL, D_ALL, NULL, pch_pp_control_mmio_write);\n\tMMIO_DH(_MMIO(0xe651c), D_ALL, dpy_reg_mmio_read, NULL);\n\tMMIO_DH(_MMIO(0xe661c), D_ALL, dpy_reg_mmio_read, NULL);\n\tMMIO_DH(_MMIO(0xe671c), D_ALL, dpy_reg_mmio_read, NULL);\n\tMMIO_DH(_MMIO(0xe681c), D_ALL, dpy_reg_mmio_read, NULL);\n\tMMIO_DH(_MMIO(0xe6c04), D_ALL, dpy_reg_mmio_read, NULL);\n\tMMIO_DH(_MMIO(0xe6e1c), D_ALL, dpy_reg_mmio_read, NULL);\n\n\tMMIO_RO(PCH_PORT_HOTPLUG, D_ALL, 0,\n\t\tPORTA_HOTPLUG_STATUS_MASK\n\t\t| PORTB_HOTPLUG_STATUS_MASK\n\t\t| PORTC_HOTPLUG_STATUS_MASK\n\t\t| PORTD_HOTPLUG_STATUS_MASK,\n\t\tNULL, NULL);\n\n\tMMIO_DH(LCPLL_CTL, D_ALL, NULL, lcpll_ctl_mmio_write);\n\tMMIO_DH(SOUTH_CHICKEN2, D_ALL, NULL, south_chicken2_mmio_write);\n\tMMIO_DH(SFUSE_STRAP, D_ALL, NULL, NULL);\n\tMMIO_DH(SBI_DATA, D_ALL, sbi_data_mmio_read, NULL);\n\tMMIO_DH(SBI_CTL_STAT, D_ALL, NULL, sbi_ctl_mmio_write);\n\n\tMMIO_F(_MMIO(_DPA_AUX_CH_CTL), 6 * 4, 0, 0, 0, D_ALL, NULL,\n\t\tdp_aux_ch_ctl_mmio_write);\n\n\tMMIO_DH(DDI_BUF_CTL(PORT_A), D_ALL, NULL, ddi_buf_ctl_mmio_write);\n\tMMIO_DH(DDI_BUF_CTL(PORT_B), D_ALL, NULL, ddi_buf_ctl_mmio_write);\n\tMMIO_DH(DDI_BUF_CTL(PORT_C), D_ALL, NULL, ddi_buf_ctl_mmio_write);\n\tMMIO_DH(DDI_BUF_CTL(PORT_D), D_ALL, NULL, ddi_buf_ctl_mmio_write);\n\tMMIO_DH(DDI_BUF_CTL(PORT_E), D_ALL, NULL, ddi_buf_ctl_mmio_write);\n\n\tMMIO_DH(DP_TP_CTL(PORT_A), D_ALL, NULL, dp_tp_ctl_mmio_write);\n\tMMIO_DH(DP_TP_CTL(PORT_B), D_ALL, NULL, dp_tp_ctl_mmio_write);\n\tMMIO_DH(DP_TP_CTL(PORT_C), D_ALL, NULL, dp_tp_ctl_mmio_write);\n\tMMIO_DH(DP_TP_CTL(PORT_D), D_ALL, NULL, dp_tp_ctl_mmio_write);\n\tMMIO_DH(DP_TP_CTL(PORT_E), D_ALL, NULL, dp_tp_ctl_mmio_write);\n\n\tMMIO_DH(DP_TP_STATUS(PORT_A), D_ALL, NULL, dp_tp_status_mmio_write);\n\tMMIO_DH(DP_TP_STATUS(PORT_B), D_ALL, NULL, dp_tp_status_mmio_write);\n\tMMIO_DH(DP_TP_STATUS(PORT_C), D_ALL, NULL, dp_tp_status_mmio_write);\n\tMMIO_DH(DP_TP_STATUS(PORT_D), D_ALL, NULL, dp_tp_status_mmio_write);\n\tMMIO_DH(DP_TP_STATUS(PORT_E), D_ALL, NULL, NULL);\n\n\tMMIO_DH(_MMIO(_TRANS_DDI_FUNC_CTL_A), D_ALL, NULL, NULL);\n\tMMIO_DH(_MMIO(_TRANS_DDI_FUNC_CTL_B), D_ALL, NULL, NULL);\n\tMMIO_DH(_MMIO(_TRANS_DDI_FUNC_CTL_C), D_ALL, NULL, NULL);\n\tMMIO_DH(_MMIO(_TRANS_DDI_FUNC_CTL_EDP), D_ALL, NULL, NULL);\n\n\tMMIO_DH(FORCEWAKE, D_ALL, NULL, NULL);\n\tMMIO_DFH(GTFIFODBG, D_ALL, F_CMD_ACCESS, NULL, NULL);\n\tMMIO_DFH(GTFIFOCTL, D_ALL, F_CMD_ACCESS, NULL, NULL);\n\tMMIO_DH(FORCEWAKE_MT, D_PRE_SKL, NULL, mul_force_wake_write);\n\tMMIO_DH(FORCEWAKE_ACK_HSW, D_BDW, NULL, NULL);\n\tMMIO_DH(GEN6_RC_CONTROL, D_ALL, NULL, NULL);\n\tMMIO_DH(GEN6_RC_STATE, D_ALL, NULL, NULL);\n\tMMIO_DH(HSW_PWR_WELL_CTL1, D_BDW, NULL, power_well_ctl_mmio_write);\n\tMMIO_DH(HSW_PWR_WELL_CTL2, D_BDW, NULL, power_well_ctl_mmio_write);\n\tMMIO_DH(HSW_PWR_WELL_CTL3, D_BDW, NULL, power_well_ctl_mmio_write);\n\tMMIO_DH(HSW_PWR_WELL_CTL4, D_BDW, NULL, power_well_ctl_mmio_write);\n\tMMIO_DH(HSW_PWR_WELL_CTL5, D_BDW, NULL, power_well_ctl_mmio_write);\n\tMMIO_DH(HSW_PWR_WELL_CTL6, D_BDW, NULL, power_well_ctl_mmio_write);\n\n\tMMIO_DH(GEN6_GDRST, D_ALL, NULL, gdrst_mmio_write);\n\tMMIO_F(FENCE_REG_GEN6_LO(0), 0x80, 0, 0, 0, D_ALL, fence_mmio_read, fence_mmio_write);\n\tMMIO_DH(CPU_VGACNTRL, D_ALL, NULL, vga_control_mmio_write);\n\n\tMMIO_DH(GEN7_ERR_INT, D_ALL, NULL, NULL);\n\tMMIO_DH(GFX_FLSH_CNTL_GEN6, D_ALL, NULL, NULL);\n\n\tMMIO_DH(GEN6_MBCTL, D_ALL, NULL, mbctl_write);\n\tMMIO_DFH(GEN7_UCGCTL4, D_ALL, F_CMD_ACCESS, NULL, NULL);\n\n\tMMIO_DH(FPGA_DBG, D_ALL, NULL, fpga_dbg_mmio_write);\n\tMMIO_DFH(_MMIO(0x215c), D_BDW_PLUS, F_CMD_ACCESS, NULL, NULL);\n\tMMIO_DFH(_MMIO(0x2178), D_ALL, F_CMD_ACCESS, NULL, NULL);\n\tMMIO_DFH(_MMIO(0x217c), D_ALL, F_CMD_ACCESS, NULL, NULL);\n\tMMIO_DFH(_MMIO(0x12178), D_ALL, F_CMD_ACCESS, NULL, NULL);\n\tMMIO_DFH(_MMIO(0x1217c), D_ALL, F_CMD_ACCESS, NULL, NULL);\n\n\tMMIO_F(_MMIO(0x2290), 8, F_CMD_ACCESS, 0, 0, D_BDW_PLUS, NULL, NULL);\n\tMMIO_F(_MMIO(0x5200), 32, F_CMD_ACCESS, 0, 0, D_ALL, NULL, NULL);\n\tMMIO_F(_MMIO(0x5240), 32, F_CMD_ACCESS, 0, 0, D_ALL, NULL, NULL);\n\tMMIO_F(_MMIO(0x5280), 16, F_CMD_ACCESS, 0, 0, D_ALL, NULL, NULL);\n\n\tMMIO_DFH(_MMIO(0x1c17c), D_BDW_PLUS, F_CMD_ACCESS, NULL, NULL);\n\tMMIO_DFH(_MMIO(0x1c178), D_BDW_PLUS, F_CMD_ACCESS, NULL, NULL);\n\tMMIO_DFH(BCS_SWCTRL, D_ALL, F_CMD_ACCESS, NULL, NULL);\n\n\tMMIO_F(HS_INVOCATION_COUNT, 8, F_CMD_ACCESS, 0, 0, D_ALL, NULL, NULL);\n\tMMIO_F(DS_INVOCATION_COUNT, 8, F_CMD_ACCESS, 0, 0, D_ALL, NULL, NULL);\n\tMMIO_F(IA_VERTICES_COUNT, 8, F_CMD_ACCESS, 0, 0, D_ALL, NULL, NULL);\n\tMMIO_F(IA_PRIMITIVES_COUNT, 8, F_CMD_ACCESS, 0, 0, D_ALL, NULL, NULL);\n\tMMIO_F(VS_INVOCATION_COUNT, 8, F_CMD_ACCESS, 0, 0, D_ALL, NULL, NULL);\n\tMMIO_F(GS_INVOCATION_COUNT, 8, F_CMD_ACCESS, 0, 0, D_ALL, NULL, NULL);\n\tMMIO_F(GS_PRIMITIVES_COUNT, 8, F_CMD_ACCESS, 0, 0, D_ALL, NULL, NULL);\n\tMMIO_F(CL_INVOCATION_COUNT, 8, F_CMD_ACCESS, 0, 0, D_ALL, NULL, NULL);\n\tMMIO_F(CL_PRIMITIVES_COUNT, 8, F_CMD_ACCESS, 0, 0, D_ALL, NULL, NULL);\n\tMMIO_F(PS_INVOCATION_COUNT, 8, F_CMD_ACCESS, 0, 0, D_ALL, NULL, NULL);\n\tMMIO_F(PS_DEPTH_COUNT, 8, F_CMD_ACCESS, 0, 0, D_ALL, NULL, NULL);\n\tMMIO_DH(_MMIO(0x4260), D_BDW_PLUS, NULL, gvt_reg_tlb_control_handler);\n\tMMIO_DH(_MMIO(0x4264), D_BDW_PLUS, NULL, gvt_reg_tlb_control_handler);\n\tMMIO_DH(_MMIO(0x4268), D_BDW_PLUS, NULL, gvt_reg_tlb_control_handler);\n\tMMIO_DH(_MMIO(0x426c), D_BDW_PLUS, NULL, gvt_reg_tlb_control_handler);\n\tMMIO_DH(_MMIO(0x4270), D_BDW_PLUS, NULL, gvt_reg_tlb_control_handler);\n\tMMIO_DFH(_MMIO(0x4094), D_BDW_PLUS, F_CMD_ACCESS, NULL, NULL);\n\n\tMMIO_DFH(ARB_MODE, D_ALL, F_MODE_MASK | F_CMD_ACCESS, NULL, NULL);\n\tMMIO_RING_GM(RING_BBADDR, D_ALL, NULL, NULL);\n\tMMIO_DFH(_MMIO(0x2220), D_ALL, F_CMD_ACCESS, NULL, NULL);\n\tMMIO_DFH(_MMIO(0x12220), D_ALL, F_CMD_ACCESS, NULL, NULL);\n\tMMIO_DFH(_MMIO(0x22220), D_ALL, F_CMD_ACCESS, NULL, NULL);\n\tMMIO_RING_DFH(RING_SYNC_1, D_ALL, F_CMD_ACCESS, NULL, NULL);\n\tMMIO_RING_DFH(RING_SYNC_0, D_ALL, F_CMD_ACCESS, NULL, NULL);\n\tMMIO_DFH(_MMIO(0x22178), D_BDW_PLUS, F_CMD_ACCESS, NULL, NULL);\n\tMMIO_DFH(_MMIO(0x1a178), D_BDW_PLUS, F_CMD_ACCESS, NULL, NULL);\n\tMMIO_DFH(_MMIO(0x1a17c), D_BDW_PLUS, F_CMD_ACCESS, NULL, NULL);\n\tMMIO_DFH(_MMIO(0x2217c), D_BDW_PLUS, F_CMD_ACCESS, NULL, NULL);\n\n\tMMIO_DH(EDP_PSR_IMR, D_BDW_PLUS, NULL, edp_psr_imr_iir_write);\n\tMMIO_DH(EDP_PSR_IIR, D_BDW_PLUS, NULL, edp_psr_imr_iir_write);\n\tMMIO_DH(GUC_STATUS, D_ALL, guc_status_read, NULL);\n\n\treturn 0;\n}\n\nstatic int init_bdw_mmio_info(struct intel_gvt *gvt)\n{\n\tint ret;\n\n\tMMIO_DH(GEN8_GT_IMR(0), D_BDW_PLUS, NULL, intel_vgpu_reg_imr_handler);\n\tMMIO_DH(GEN8_GT_IER(0), D_BDW_PLUS, NULL, intel_vgpu_reg_ier_handler);\n\tMMIO_DH(GEN8_GT_IIR(0), D_BDW_PLUS, NULL, intel_vgpu_reg_iir_handler);\n\n\tMMIO_DH(GEN8_GT_IMR(1), D_BDW_PLUS, NULL, intel_vgpu_reg_imr_handler);\n\tMMIO_DH(GEN8_GT_IER(1), D_BDW_PLUS, NULL, intel_vgpu_reg_ier_handler);\n\tMMIO_DH(GEN8_GT_IIR(1), D_BDW_PLUS, NULL, intel_vgpu_reg_iir_handler);\n\n\tMMIO_DH(GEN8_GT_IMR(2), D_BDW_PLUS, NULL, intel_vgpu_reg_imr_handler);\n\tMMIO_DH(GEN8_GT_IER(2), D_BDW_PLUS, NULL, intel_vgpu_reg_ier_handler);\n\tMMIO_DH(GEN8_GT_IIR(2), D_BDW_PLUS, NULL, intel_vgpu_reg_iir_handler);\n\n\tMMIO_DH(GEN8_GT_IMR(3), D_BDW_PLUS, NULL, intel_vgpu_reg_imr_handler);\n\tMMIO_DH(GEN8_GT_IER(3), D_BDW_PLUS, NULL, intel_vgpu_reg_ier_handler);\n\tMMIO_DH(GEN8_GT_IIR(3), D_BDW_PLUS, NULL, intel_vgpu_reg_iir_handler);\n\n\tMMIO_DH(GEN8_DE_PIPE_IMR(PIPE_A), D_BDW_PLUS, NULL,\n\t\tintel_vgpu_reg_imr_handler);\n\tMMIO_DH(GEN8_DE_PIPE_IER(PIPE_A), D_BDW_PLUS, NULL,\n\t\tintel_vgpu_reg_ier_handler);\n\tMMIO_DH(GEN8_DE_PIPE_IIR(PIPE_A), D_BDW_PLUS, NULL,\n\t\tintel_vgpu_reg_iir_handler);\n\n\tMMIO_DH(GEN8_DE_PIPE_IMR(PIPE_B), D_BDW_PLUS, NULL,\n\t\tintel_vgpu_reg_imr_handler);\n\tMMIO_DH(GEN8_DE_PIPE_IER(PIPE_B), D_BDW_PLUS, NULL,\n\t\tintel_vgpu_reg_ier_handler);\n\tMMIO_DH(GEN8_DE_PIPE_IIR(PIPE_B), D_BDW_PLUS, NULL,\n\t\tintel_vgpu_reg_iir_handler);\n\n\tMMIO_DH(GEN8_DE_PIPE_IMR(PIPE_C), D_BDW_PLUS, NULL,\n\t\tintel_vgpu_reg_imr_handler);\n\tMMIO_DH(GEN8_DE_PIPE_IER(PIPE_C), D_BDW_PLUS, NULL,\n\t\tintel_vgpu_reg_ier_handler);\n\tMMIO_DH(GEN8_DE_PIPE_IIR(PIPE_C), D_BDW_PLUS, NULL,\n\t\tintel_vgpu_reg_iir_handler);\n\n\tMMIO_DH(GEN8_DE_PORT_IMR, D_BDW_PLUS, NULL, intel_vgpu_reg_imr_handler);\n\tMMIO_DH(GEN8_DE_PORT_IER, D_BDW_PLUS, NULL, intel_vgpu_reg_ier_handler);\n\tMMIO_DH(GEN8_DE_PORT_IIR, D_BDW_PLUS, NULL, intel_vgpu_reg_iir_handler);\n\n\tMMIO_DH(GEN8_DE_MISC_IMR, D_BDW_PLUS, NULL, intel_vgpu_reg_imr_handler);\n\tMMIO_DH(GEN8_DE_MISC_IER, D_BDW_PLUS, NULL, intel_vgpu_reg_ier_handler);\n\tMMIO_DH(GEN8_DE_MISC_IIR, D_BDW_PLUS, NULL, intel_vgpu_reg_iir_handler);\n\n\tMMIO_DH(GEN8_PCU_IMR, D_BDW_PLUS, NULL, intel_vgpu_reg_imr_handler);\n\tMMIO_DH(GEN8_PCU_IER, D_BDW_PLUS, NULL, intel_vgpu_reg_ier_handler);\n\tMMIO_DH(GEN8_PCU_IIR, D_BDW_PLUS, NULL, intel_vgpu_reg_iir_handler);\n\n\tMMIO_DH(GEN8_MASTER_IRQ, D_BDW_PLUS, NULL,\n\t\tintel_vgpu_reg_master_irq_handler);\n\n\tMMIO_RING_DFH(RING_ACTHD_UDW, D_BDW_PLUS, 0,\n\t\tmmio_read_from_hw, NULL);\n\n#define RING_REG(base) _MMIO((base) + 0xd0)\n\tMMIO_RING_F(RING_REG, 4, F_RO, 0,\n\t\t~_MASKED_BIT_ENABLE(RESET_CTL_REQUEST_RESET), D_BDW_PLUS, NULL,\n\t\tring_reset_ctl_write);\n#undef RING_REG\n\n#define RING_REG(base) _MMIO((base) + 0x230)\n\tMMIO_RING_DFH(RING_REG, D_BDW_PLUS, 0, NULL, elsp_mmio_write);\n#undef RING_REG\n\n#define RING_REG(base) _MMIO((base) + 0x234)\n\tMMIO_RING_F(RING_REG, 8, F_RO, 0, ~0, D_BDW_PLUS,\n\t\tNULL, NULL);\n#undef RING_REG\n\n#define RING_REG(base) _MMIO((base) + 0x244)\n\tMMIO_RING_DFH(RING_REG, D_BDW_PLUS, F_CMD_ACCESS, NULL, NULL);\n#undef RING_REG\n\n#define RING_REG(base) _MMIO((base) + 0x370)\n\tMMIO_RING_F(RING_REG, 48, F_RO, 0, ~0, D_BDW_PLUS, NULL, NULL);\n#undef RING_REG\n\n#define RING_REG(base) _MMIO((base) + 0x3a0)\n\tMMIO_RING_DFH(RING_REG, D_BDW_PLUS, F_MODE_MASK, NULL, NULL);\n#undef RING_REG\n\n\tMMIO_DH(GEN6_PCODE_MAILBOX, D_BDW_PLUS, NULL, mailbox_write);\n\n#define RING_REG(base) _MMIO((base) + 0x270)\n\tMMIO_RING_F(RING_REG, 32, F_CMD_ACCESS, 0, 0, D_BDW_PLUS, NULL, NULL);\n#undef RING_REG\n\n\tMMIO_RING_GM(RING_HWS_PGA, D_BDW_PLUS, NULL, hws_pga_write);\n\n\tMMIO_DFH(HDC_CHICKEN0, D_BDW_PLUS, F_MODE_MASK | F_CMD_ACCESS, NULL, NULL);\n\n\tMMIO_DFH(GEN8_ROW_CHICKEN, D_BDW_PLUS, F_MODE_MASK | F_CMD_ACCESS,\n\t\tNULL, NULL);\n\tMMIO_DFH(GEN7_ROW_CHICKEN2, D_BDW_PLUS, F_MODE_MASK | F_CMD_ACCESS,\n\t\tNULL, NULL);\n\tMMIO_DFH(GEN8_UCGCTL6, D_BDW_PLUS, F_CMD_ACCESS, NULL, NULL);\n\n\tMMIO_DFH(_MMIO(0xb1f0), D_BDW, F_CMD_ACCESS, NULL, NULL);\n\tMMIO_DFH(_MMIO(0xb1c0), D_BDW, F_CMD_ACCESS, NULL, NULL);\n\tMMIO_DFH(GEN8_L3SQCREG4, D_BDW_PLUS, F_CMD_ACCESS, NULL, NULL);\n\tMMIO_DFH(_MMIO(0xb100), D_BDW, F_CMD_ACCESS, NULL, NULL);\n\tMMIO_DFH(_MMIO(0xb10c), D_BDW, F_CMD_ACCESS, NULL, NULL);\n\n\tMMIO_F(_MMIO(0x24d0), 48, F_CMD_ACCESS | F_CMD_WRITE_PATCH, 0, 0,\n\t\tD_BDW_PLUS, NULL, force_nonpriv_write);\n\n\tMMIO_DFH(_MMIO(0x83a4), D_BDW, F_CMD_ACCESS, NULL, NULL);\n\n\tMMIO_DFH(_MMIO(0x8430), D_BDW, F_CMD_ACCESS, NULL, NULL);\n\n\tMMIO_DFH(_MMIO(0xe194), D_BDW_PLUS, F_MODE_MASK | F_CMD_ACCESS, NULL, NULL);\n\tMMIO_DFH(_MMIO(0xe188), D_BDW_PLUS, F_MODE_MASK | F_CMD_ACCESS, NULL, NULL);\n\tMMIO_DFH(HALF_SLICE_CHICKEN2, D_BDW_PLUS, F_MODE_MASK | F_CMD_ACCESS, NULL, NULL);\n\tMMIO_DFH(_MMIO(0x2580), D_BDW_PLUS, F_MODE_MASK | F_CMD_ACCESS, NULL, NULL);\n\n\tMMIO_DFH(_MMIO(0x2248), D_BDW, F_CMD_ACCESS, NULL, NULL);\n\n\tMMIO_DFH(_MMIO(0xe220), D_BDW_PLUS, F_CMD_ACCESS, NULL, NULL);\n\tMMIO_DFH(_MMIO(0xe230), D_BDW_PLUS, F_CMD_ACCESS, NULL, NULL);\n\tMMIO_DFH(_MMIO(0xe240), D_BDW_PLUS, F_CMD_ACCESS, NULL, NULL);\n\tMMIO_DFH(_MMIO(0xe260), D_BDW_PLUS, F_CMD_ACCESS, NULL, NULL);\n\tMMIO_DFH(_MMIO(0xe270), D_BDW_PLUS, F_CMD_ACCESS, NULL, NULL);\n\tMMIO_DFH(_MMIO(0xe280), D_BDW_PLUS, F_CMD_ACCESS, NULL, NULL);\n\tMMIO_DFH(_MMIO(0xe2a0), D_BDW_PLUS, F_CMD_ACCESS, NULL, NULL);\n\tMMIO_DFH(_MMIO(0xe2b0), D_BDW_PLUS, F_CMD_ACCESS, NULL, NULL);\n\tMMIO_DFH(_MMIO(0xe2c0), D_BDW_PLUS, F_CMD_ACCESS, NULL, NULL);\n\tMMIO_DFH(_MMIO(0x21f0), D_BDW_PLUS, F_CMD_ACCESS, NULL, NULL);\n\treturn 0;\n}\n\nstatic int init_skl_mmio_info(struct intel_gvt *gvt)\n{\n\tstruct drm_i915_private *dev_priv = gvt->gt->i915;\n\tint ret;\n\n\tMMIO_DH(FORCEWAKE_RENDER_GEN9, D_SKL_PLUS, NULL, mul_force_wake_write);\n\tMMIO_DH(FORCEWAKE_ACK_RENDER_GEN9, D_SKL_PLUS, NULL, NULL);\n\tMMIO_DH(FORCEWAKE_GT_GEN9, D_SKL_PLUS, NULL, mul_force_wake_write);\n\tMMIO_DH(FORCEWAKE_ACK_GT_GEN9, D_SKL_PLUS, NULL, NULL);\n\tMMIO_DH(FORCEWAKE_MEDIA_GEN9, D_SKL_PLUS, NULL, mul_force_wake_write);\n\tMMIO_DH(FORCEWAKE_ACK_MEDIA_GEN9, D_SKL_PLUS, NULL, NULL);\n\n\tMMIO_F(DP_AUX_CH_CTL(AUX_CH_B), 6 * 4, 0, 0, 0, D_SKL_PLUS, NULL,\n\t\t\t\t\t\tdp_aux_ch_ctl_mmio_write);\n\tMMIO_F(DP_AUX_CH_CTL(AUX_CH_C), 6 * 4, 0, 0, 0, D_SKL_PLUS, NULL,\n\t\t\t\t\t\tdp_aux_ch_ctl_mmio_write);\n\tMMIO_F(DP_AUX_CH_CTL(AUX_CH_D), 6 * 4, 0, 0, 0, D_SKL_PLUS, NULL,\n\t\t\t\t\t\tdp_aux_ch_ctl_mmio_write);\n\n\tMMIO_DH(HSW_PWR_WELL_CTL2, D_SKL_PLUS, NULL, skl_power_well_ctl_write);\n\n\tMMIO_DH(DBUF_CTL_S(0), D_SKL_PLUS, NULL, gen9_dbuf_ctl_mmio_write);\n\n\tMMIO_DFH(GEN9_GAMT_ECO_REG_RW_IA, D_SKL_PLUS, F_CMD_ACCESS, NULL, NULL);\n\tMMIO_DFH(MMCD_MISC_CTRL, D_SKL_PLUS, F_CMD_ACCESS, NULL, NULL);\n\tMMIO_DH(CHICKEN_PAR1_1, D_SKL_PLUS, NULL, NULL);\n\tMMIO_DH(LCPLL1_CTL, D_SKL_PLUS, NULL, skl_lcpll_write);\n\tMMIO_DH(LCPLL2_CTL, D_SKL_PLUS, NULL, skl_lcpll_write);\n\tMMIO_DH(DPLL_STATUS, D_SKL_PLUS, dpll_status_read, NULL);\n\n\tMMIO_DH(SKL_PS_WIN_POS(PIPE_A, 0), D_SKL_PLUS, NULL, pf_write);\n\tMMIO_DH(SKL_PS_WIN_POS(PIPE_A, 1), D_SKL_PLUS, NULL, pf_write);\n\tMMIO_DH(SKL_PS_WIN_POS(PIPE_B, 0), D_SKL_PLUS, NULL, pf_write);\n\tMMIO_DH(SKL_PS_WIN_POS(PIPE_B, 1), D_SKL_PLUS, NULL, pf_write);\n\tMMIO_DH(SKL_PS_WIN_POS(PIPE_C, 0), D_SKL_PLUS, NULL, pf_write);\n\tMMIO_DH(SKL_PS_WIN_POS(PIPE_C, 1), D_SKL_PLUS, NULL, pf_write);\n\n\tMMIO_DH(SKL_PS_WIN_SZ(PIPE_A, 0), D_SKL_PLUS, NULL, pf_write);\n\tMMIO_DH(SKL_PS_WIN_SZ(PIPE_A, 1), D_SKL_PLUS, NULL, pf_write);\n\tMMIO_DH(SKL_PS_WIN_SZ(PIPE_B, 0), D_SKL_PLUS, NULL, pf_write);\n\tMMIO_DH(SKL_PS_WIN_SZ(PIPE_B, 1), D_SKL_PLUS, NULL, pf_write);\n\tMMIO_DH(SKL_PS_WIN_SZ(PIPE_C, 0), D_SKL_PLUS, NULL, pf_write);\n\tMMIO_DH(SKL_PS_WIN_SZ(PIPE_C, 1), D_SKL_PLUS, NULL, pf_write);\n\n\tMMIO_DH(SKL_PS_CTRL(PIPE_A, 0), D_SKL_PLUS, NULL, pf_write);\n\tMMIO_DH(SKL_PS_CTRL(PIPE_A, 1), D_SKL_PLUS, NULL, pf_write);\n\tMMIO_DH(SKL_PS_CTRL(PIPE_B, 0), D_SKL_PLUS, NULL, pf_write);\n\tMMIO_DH(SKL_PS_CTRL(PIPE_B, 1), D_SKL_PLUS, NULL, pf_write);\n\tMMIO_DH(SKL_PS_CTRL(PIPE_C, 0), D_SKL_PLUS, NULL, pf_write);\n\tMMIO_DH(SKL_PS_CTRL(PIPE_C, 1), D_SKL_PLUS, NULL, pf_write);\n\n\tMMIO_DH(PLANE_BUF_CFG(PIPE_A, 0), D_SKL_PLUS, NULL, NULL);\n\tMMIO_DH(PLANE_BUF_CFG(PIPE_A, 1), D_SKL_PLUS, NULL, NULL);\n\tMMIO_DH(PLANE_BUF_CFG(PIPE_A, 2), D_SKL_PLUS, NULL, NULL);\n\tMMIO_DH(PLANE_BUF_CFG(PIPE_A, 3), D_SKL_PLUS, NULL, NULL);\n\n\tMMIO_DH(PLANE_BUF_CFG(PIPE_B, 0), D_SKL_PLUS, NULL, NULL);\n\tMMIO_DH(PLANE_BUF_CFG(PIPE_B, 1), D_SKL_PLUS, NULL, NULL);\n\tMMIO_DH(PLANE_BUF_CFG(PIPE_B, 2), D_SKL_PLUS, NULL, NULL);\n\tMMIO_DH(PLANE_BUF_CFG(PIPE_B, 3), D_SKL_PLUS, NULL, NULL);\n\n\tMMIO_DH(PLANE_BUF_CFG(PIPE_C, 0), D_SKL_PLUS, NULL, NULL);\n\tMMIO_DH(PLANE_BUF_CFG(PIPE_C, 1), D_SKL_PLUS, NULL, NULL);\n\tMMIO_DH(PLANE_BUF_CFG(PIPE_C, 2), D_SKL_PLUS, NULL, NULL);\n\tMMIO_DH(PLANE_BUF_CFG(PIPE_C, 3), D_SKL_PLUS, NULL, NULL);\n\n\tMMIO_DH(CUR_BUF_CFG(PIPE_A), D_SKL_PLUS, NULL, NULL);\n\tMMIO_DH(CUR_BUF_CFG(PIPE_B), D_SKL_PLUS, NULL, NULL);\n\tMMIO_DH(CUR_BUF_CFG(PIPE_C), D_SKL_PLUS, NULL, NULL);\n\n\tMMIO_DH(PLANE_WM_TRANS(PIPE_A, 0), D_SKL_PLUS, NULL, NULL);\n\tMMIO_DH(PLANE_WM_TRANS(PIPE_A, 1), D_SKL_PLUS, NULL, NULL);\n\tMMIO_DH(PLANE_WM_TRANS(PIPE_A, 2), D_SKL_PLUS, NULL, NULL);\n\n\tMMIO_DH(PLANE_WM_TRANS(PIPE_B, 0), D_SKL_PLUS, NULL, NULL);\n\tMMIO_DH(PLANE_WM_TRANS(PIPE_B, 1), D_SKL_PLUS, NULL, NULL);\n\tMMIO_DH(PLANE_WM_TRANS(PIPE_B, 2), D_SKL_PLUS, NULL, NULL);\n\n\tMMIO_DH(PLANE_WM_TRANS(PIPE_C, 0), D_SKL_PLUS, NULL, NULL);\n\tMMIO_DH(PLANE_WM_TRANS(PIPE_C, 1), D_SKL_PLUS, NULL, NULL);\n\tMMIO_DH(PLANE_WM_TRANS(PIPE_C, 2), D_SKL_PLUS, NULL, NULL);\n\n\tMMIO_DH(CUR_WM_TRANS(PIPE_A), D_SKL_PLUS, NULL, NULL);\n\tMMIO_DH(CUR_WM_TRANS(PIPE_B), D_SKL_PLUS, NULL, NULL);\n\tMMIO_DH(CUR_WM_TRANS(PIPE_C), D_SKL_PLUS, NULL, NULL);\n\n\tMMIO_DH(PLANE_NV12_BUF_CFG(PIPE_A, 0), D_SKL_PLUS, NULL, NULL);\n\tMMIO_DH(PLANE_NV12_BUF_CFG(PIPE_A, 1), D_SKL_PLUS, NULL, NULL);\n\tMMIO_DH(PLANE_NV12_BUF_CFG(PIPE_A, 2), D_SKL_PLUS, NULL, NULL);\n\tMMIO_DH(PLANE_NV12_BUF_CFG(PIPE_A, 3), D_SKL_PLUS, NULL, NULL);\n\n\tMMIO_DH(PLANE_NV12_BUF_CFG(PIPE_B, 0), D_SKL_PLUS, NULL, NULL);\n\tMMIO_DH(PLANE_NV12_BUF_CFG(PIPE_B, 1), D_SKL_PLUS, NULL, NULL);\n\tMMIO_DH(PLANE_NV12_BUF_CFG(PIPE_B, 2), D_SKL_PLUS, NULL, NULL);\n\tMMIO_DH(PLANE_NV12_BUF_CFG(PIPE_B, 3), D_SKL_PLUS, NULL, NULL);\n\n\tMMIO_DH(PLANE_NV12_BUF_CFG(PIPE_C, 0), D_SKL_PLUS, NULL, NULL);\n\tMMIO_DH(PLANE_NV12_BUF_CFG(PIPE_C, 1), D_SKL_PLUS, NULL, NULL);\n\tMMIO_DH(PLANE_NV12_BUF_CFG(PIPE_C, 2), D_SKL_PLUS, NULL, NULL);\n\tMMIO_DH(PLANE_NV12_BUF_CFG(PIPE_C, 3), D_SKL_PLUS, NULL, NULL);\n\n\tMMIO_DH(_MMIO(_REG_701C0(PIPE_A, 1)), D_SKL_PLUS, NULL, NULL);\n\tMMIO_DH(_MMIO(_REG_701C0(PIPE_A, 2)), D_SKL_PLUS, NULL, NULL);\n\tMMIO_DH(_MMIO(_REG_701C0(PIPE_A, 3)), D_SKL_PLUS, NULL, NULL);\n\tMMIO_DH(_MMIO(_REG_701C0(PIPE_A, 4)), D_SKL_PLUS, NULL, NULL);\n\n\tMMIO_DH(_MMIO(_REG_701C0(PIPE_B, 1)), D_SKL_PLUS, NULL, NULL);\n\tMMIO_DH(_MMIO(_REG_701C0(PIPE_B, 2)), D_SKL_PLUS, NULL, NULL);\n\tMMIO_DH(_MMIO(_REG_701C0(PIPE_B, 3)), D_SKL_PLUS, NULL, NULL);\n\tMMIO_DH(_MMIO(_REG_701C0(PIPE_B, 4)), D_SKL_PLUS, NULL, NULL);\n\n\tMMIO_DH(_MMIO(_REG_701C0(PIPE_C, 1)), D_SKL_PLUS, NULL, NULL);\n\tMMIO_DH(_MMIO(_REG_701C0(PIPE_C, 2)), D_SKL_PLUS, NULL, NULL);\n\tMMIO_DH(_MMIO(_REG_701C0(PIPE_C, 3)), D_SKL_PLUS, NULL, NULL);\n\tMMIO_DH(_MMIO(_REG_701C0(PIPE_C, 4)), D_SKL_PLUS, NULL, NULL);\n\n\tMMIO_DH(_MMIO(_REG_701C4(PIPE_A, 1)), D_SKL_PLUS, NULL, NULL);\n\tMMIO_DH(_MMIO(_REG_701C4(PIPE_A, 2)), D_SKL_PLUS, NULL, NULL);\n\tMMIO_DH(_MMIO(_REG_701C4(PIPE_A, 3)), D_SKL_PLUS, NULL, NULL);\n\tMMIO_DH(_MMIO(_REG_701C4(PIPE_A, 4)), D_SKL_PLUS, NULL, NULL);\n\n\tMMIO_DH(_MMIO(_REG_701C4(PIPE_B, 1)), D_SKL_PLUS, NULL, NULL);\n\tMMIO_DH(_MMIO(_REG_701C4(PIPE_B, 2)), D_SKL_PLUS, NULL, NULL);\n\tMMIO_DH(_MMIO(_REG_701C4(PIPE_B, 3)), D_SKL_PLUS, NULL, NULL);\n\tMMIO_DH(_MMIO(_REG_701C4(PIPE_B, 4)), D_SKL_PLUS, NULL, NULL);\n\n\tMMIO_DH(_MMIO(_REG_701C4(PIPE_C, 1)), D_SKL_PLUS, NULL, NULL);\n\tMMIO_DH(_MMIO(_REG_701C4(PIPE_C, 2)), D_SKL_PLUS, NULL, NULL);\n\tMMIO_DH(_MMIO(_REG_701C4(PIPE_C, 3)), D_SKL_PLUS, NULL, NULL);\n\tMMIO_DH(_MMIO(_REG_701C4(PIPE_C, 4)), D_SKL_PLUS, NULL, NULL);\n\n\tMMIO_DFH(BDW_SCRATCH1, D_SKL_PLUS, F_CMD_ACCESS, NULL, NULL);\n\n\tMMIO_F(GEN9_GFX_MOCS(0), 0x7f8, F_CMD_ACCESS, 0, 0, D_SKL_PLUS,\n\t\tNULL, NULL);\n\tMMIO_F(GEN7_L3CNTLREG2, 0x80, F_CMD_ACCESS, 0, 0, D_SKL_PLUS,\n\t\tNULL, NULL);\n\n\tMMIO_DFH(GEN7_FF_SLICE_CS_CHICKEN1, D_SKL_PLUS,\n\t\t F_MODE_MASK | F_CMD_ACCESS, NULL, NULL);\n\tMMIO_DFH(GEN9_CS_DEBUG_MODE1, D_SKL_PLUS, F_MODE_MASK | F_CMD_ACCESS,\n\t\tNULL, NULL);\n\n\t \n\tMMIO_DFH(TRVATTL3PTRDW(0), D_SKL_PLUS, F_CMD_ACCESS, NULL, NULL);\n\tMMIO_DFH(TRVATTL3PTRDW(1), D_SKL_PLUS, F_CMD_ACCESS, NULL, NULL);\n\tMMIO_DFH(TRVATTL3PTRDW(2), D_SKL_PLUS, F_CMD_ACCESS, NULL, NULL);\n\tMMIO_DFH(TRVATTL3PTRDW(3), D_SKL_PLUS, F_CMD_ACCESS, NULL, NULL);\n\tMMIO_DFH(TRVADR, D_SKL_PLUS, F_CMD_ACCESS, NULL, NULL);\n\tMMIO_DFH(TRTTE, D_SKL_PLUS, F_CMD_ACCESS | F_PM_SAVE,\n\t\t NULL, gen9_trtte_write);\n\tMMIO_DFH(_MMIO(0x4dfc), D_SKL_PLUS, F_PM_SAVE,\n\t\t NULL, gen9_trtt_chicken_write);\n\n\tMMIO_DFH(GEN8_GARBCNTL, D_SKL_PLUS, F_CMD_ACCESS, NULL, NULL);\n\tMMIO_DH(DMA_CTRL, D_SKL_PLUS, NULL, dma_ctrl_write);\n\n#define CSFE_CHICKEN1_REG(base) _MMIO((base) + 0xD4)\n\tMMIO_RING_DFH(CSFE_CHICKEN1_REG, D_SKL_PLUS, F_MODE_MASK | F_CMD_ACCESS,\n\t\t      NULL, csfe_chicken1_mmio_write);\n#undef CSFE_CHICKEN1_REG\n\tMMIO_DFH(GEN8_HDC_CHICKEN1, D_SKL_PLUS, F_MODE_MASK | F_CMD_ACCESS,\n\t\t NULL, NULL);\n\tMMIO_DFH(GEN9_WM_CHICKEN3, D_SKL_PLUS, F_MODE_MASK | F_CMD_ACCESS,\n\t\t NULL, NULL);\n\n\tMMIO_DFH(GAMT_CHKN_BIT_REG, D_KBL | D_CFL, F_CMD_ACCESS, NULL, NULL);\n\tMMIO_DFH(_MMIO(0xe4cc), D_BDW_PLUS, F_CMD_ACCESS, NULL, NULL);\n\n\treturn 0;\n}\n\nstatic int init_bxt_mmio_info(struct intel_gvt *gvt)\n{\n\tint ret;\n\n\tMMIO_DH(BXT_P_CR_GT_DISP_PWRON, D_BXT, NULL, bxt_gt_disp_pwron_write);\n\tMMIO_DH(BXT_PHY_CTL_FAMILY(DPIO_PHY0), D_BXT,\n\t\tNULL, bxt_phy_ctl_family_write);\n\tMMIO_DH(BXT_PHY_CTL_FAMILY(DPIO_PHY1), D_BXT,\n\t\tNULL, bxt_phy_ctl_family_write);\n\tMMIO_DH(BXT_PORT_PLL_ENABLE(PORT_A), D_BXT,\n\t\tNULL, bxt_port_pll_enable_write);\n\tMMIO_DH(BXT_PORT_PLL_ENABLE(PORT_B), D_BXT,\n\t\tNULL, bxt_port_pll_enable_write);\n\tMMIO_DH(BXT_PORT_PLL_ENABLE(PORT_C), D_BXT, NULL,\n\t\tbxt_port_pll_enable_write);\n\n\tMMIO_DH(BXT_PORT_PCS_DW12_GRP(DPIO_PHY0, DPIO_CH0), D_BXT,\n\t\tNULL, bxt_pcs_dw12_grp_write);\n\tMMIO_DH(BXT_PORT_TX_DW3_LN0(DPIO_PHY0, DPIO_CH0), D_BXT,\n\t\tbxt_port_tx_dw3_read, NULL);\n\tMMIO_DH(BXT_PORT_PCS_DW12_GRP(DPIO_PHY0, DPIO_CH1), D_BXT,\n\t\tNULL, bxt_pcs_dw12_grp_write);\n\tMMIO_DH(BXT_PORT_TX_DW3_LN0(DPIO_PHY0, DPIO_CH1), D_BXT,\n\t\tbxt_port_tx_dw3_read, NULL);\n\tMMIO_DH(BXT_PORT_PCS_DW12_GRP(DPIO_PHY1, DPIO_CH0), D_BXT,\n\t\tNULL, bxt_pcs_dw12_grp_write);\n\tMMIO_DH(BXT_PORT_TX_DW3_LN0(DPIO_PHY1, DPIO_CH0), D_BXT,\n\t\tbxt_port_tx_dw3_read, NULL);\n\tMMIO_DH(BXT_DE_PLL_ENABLE, D_BXT, NULL, bxt_de_pll_enable_write);\n\tMMIO_DFH(GEN8_L3SQCREG1, D_BXT, F_CMD_ACCESS, NULL, NULL);\n\tMMIO_DFH(GEN8_L3CNTLREG, D_BXT, F_CMD_ACCESS, NULL, NULL);\n\tMMIO_DFH(_MMIO(0x20D8), D_BXT, F_CMD_ACCESS, NULL, NULL);\n\tMMIO_F(GEN8_RING_CS_GPR(RENDER_RING_BASE, 0), 0x40, F_CMD_ACCESS,\n\t       0, 0, D_BXT, NULL, NULL);\n\tMMIO_F(GEN8_RING_CS_GPR(GEN6_BSD_RING_BASE, 0), 0x40, F_CMD_ACCESS,\n\t       0, 0, D_BXT, NULL, NULL);\n\tMMIO_F(GEN8_RING_CS_GPR(BLT_RING_BASE, 0), 0x40, F_CMD_ACCESS,\n\t       0, 0, D_BXT, NULL, NULL);\n\tMMIO_F(GEN8_RING_CS_GPR(VEBOX_RING_BASE, 0), 0x40, F_CMD_ACCESS,\n\t       0, 0, D_BXT, NULL, NULL);\n\n\tMMIO_DFH(GEN9_CTX_PREEMPT_REG, D_BXT, F_CMD_ACCESS, NULL, NULL);\n\n\tMMIO_DH(GEN8_PRIVATE_PAT_LO, D_BXT, NULL, bxt_ppat_low_write);\n\n\treturn 0;\n}\n\nstatic struct gvt_mmio_block *find_mmio_block(struct intel_gvt *gvt,\n\t\t\t\t\t      unsigned int offset)\n{\n\tstruct gvt_mmio_block *block = gvt->mmio.mmio_block;\n\tint num = gvt->mmio.num_mmio_block;\n\tint i;\n\n\tfor (i = 0; i < num; i++, block++) {\n\t\tif (offset >= i915_mmio_reg_offset(block->offset) &&\n\t\t    offset < i915_mmio_reg_offset(block->offset) + block->size)\n\t\t\treturn block;\n\t}\n\treturn NULL;\n}\n\n \nvoid intel_gvt_clean_mmio_info(struct intel_gvt *gvt)\n{\n\tstruct hlist_node *tmp;\n\tstruct intel_gvt_mmio_info *e;\n\tint i;\n\n\thash_for_each_safe(gvt->mmio.mmio_info_table, i, tmp, e, node)\n\t\tkfree(e);\n\n\tkfree(gvt->mmio.mmio_block);\n\tgvt->mmio.mmio_block = NULL;\n\tgvt->mmio.num_mmio_block = 0;\n\n\tvfree(gvt->mmio.mmio_attribute);\n\tgvt->mmio.mmio_attribute = NULL;\n}\n\nstatic int handle_mmio(struct intel_gvt_mmio_table_iter *iter, u32 offset,\n\t\t       u32 size)\n{\n\tstruct intel_gvt *gvt = iter->data;\n\tstruct intel_gvt_mmio_info *info, *p;\n\tu32 start, end, i;\n\n\tif (WARN_ON(!IS_ALIGNED(offset, 4)))\n\t\treturn -EINVAL;\n\n\tstart = offset;\n\tend = offset + size;\n\n\tfor (i = start; i < end; i += 4) {\n\t\tp = intel_gvt_find_mmio_info(gvt, i);\n\t\tif (p) {\n\t\t\tWARN(1, \"dup mmio definition offset %x\\n\",\n\t\t\t\tinfo->offset);\n\n\t\t\t \n\t\t\treturn -EEXIST;\n\t\t}\n\n\t\tinfo = kzalloc(sizeof(*info), GFP_KERNEL);\n\t\tif (!info)\n\t\t\treturn -ENOMEM;\n\n\t\tinfo->offset = i;\n\t\tinfo->read = intel_vgpu_default_mmio_read;\n\t\tinfo->write = intel_vgpu_default_mmio_write;\n\t\tINIT_HLIST_NODE(&info->node);\n\t\thash_add(gvt->mmio.mmio_info_table, &info->node, info->offset);\n\t\tgvt->mmio.num_tracked_mmio++;\n\t}\n\treturn 0;\n}\n\nstatic int handle_mmio_block(struct intel_gvt_mmio_table_iter *iter,\n\t\t\t     u32 offset, u32 size)\n{\n\tstruct intel_gvt *gvt = iter->data;\n\tstruct gvt_mmio_block *block = gvt->mmio.mmio_block;\n\tvoid *ret;\n\n\tret = krealloc(block,\n\t\t\t (gvt->mmio.num_mmio_block + 1) * sizeof(*block),\n\t\t\t GFP_KERNEL);\n\tif (!ret)\n\t\treturn -ENOMEM;\n\n\tgvt->mmio.mmio_block = block = ret;\n\n\tblock += gvt->mmio.num_mmio_block;\n\n\tmemset(block, 0, sizeof(*block));\n\n\tblock->offset = _MMIO(offset);\n\tblock->size = size;\n\n\tgvt->mmio.num_mmio_block++;\n\n\treturn 0;\n}\n\nstatic int handle_mmio_cb(struct intel_gvt_mmio_table_iter *iter, u32 offset,\n\t\t\t  u32 size)\n{\n\tif (size < 1024 || offset == i915_mmio_reg_offset(GEN9_GFX_MOCS(0)))\n\t\treturn handle_mmio(iter, offset, size);\n\telse\n\t\treturn handle_mmio_block(iter, offset, size);\n}\n\nstatic int init_mmio_info(struct intel_gvt *gvt)\n{\n\tstruct intel_gvt_mmio_table_iter iter = {\n\t\t.i915 = gvt->gt->i915,\n\t\t.data = gvt,\n\t\t.handle_mmio_cb = handle_mmio_cb,\n\t};\n\n\treturn intel_gvt_iterate_mmio_table(&iter);\n}\n\nstatic int init_mmio_block_handlers(struct intel_gvt *gvt)\n{\n\tstruct gvt_mmio_block *block;\n\n\tblock = find_mmio_block(gvt, VGT_PVINFO_PAGE);\n\tif (!block) {\n\t\tWARN(1, \"fail to assign handlers to mmio block %x\\n\",\n\t\t     i915_mmio_reg_offset(gvt->mmio.mmio_block->offset));\n\t\treturn -ENODEV;\n\t}\n\n\tblock->read = pvinfo_mmio_read;\n\tblock->write = pvinfo_mmio_write;\n\n\treturn 0;\n}\n\n \nint intel_gvt_setup_mmio_info(struct intel_gvt *gvt)\n{\n\tstruct intel_gvt_device_info *info = &gvt->device_info;\n\tstruct drm_i915_private *i915 = gvt->gt->i915;\n\tint size = info->mmio_size / 4 * sizeof(*gvt->mmio.mmio_attribute);\n\tint ret;\n\n\tgvt->mmio.mmio_attribute = vzalloc(size);\n\tif (!gvt->mmio.mmio_attribute)\n\t\treturn -ENOMEM;\n\n\tret = init_mmio_info(gvt);\n\tif (ret)\n\t\tgoto err;\n\n\tret = init_mmio_block_handlers(gvt);\n\tif (ret)\n\t\tgoto err;\n\n\tret = init_generic_mmio_info(gvt);\n\tif (ret)\n\t\tgoto err;\n\n\tif (IS_BROADWELL(i915)) {\n\t\tret = init_bdw_mmio_info(gvt);\n\t\tif (ret)\n\t\t\tgoto err;\n\t} else if (IS_SKYLAKE(i915) ||\n\t\t   IS_KABYLAKE(i915) ||\n\t\t   IS_COFFEELAKE(i915) ||\n\t\t   IS_COMETLAKE(i915)) {\n\t\tret = init_bdw_mmio_info(gvt);\n\t\tif (ret)\n\t\t\tgoto err;\n\t\tret = init_skl_mmio_info(gvt);\n\t\tif (ret)\n\t\t\tgoto err;\n\t} else if (IS_BROXTON(i915)) {\n\t\tret = init_bdw_mmio_info(gvt);\n\t\tif (ret)\n\t\t\tgoto err;\n\t\tret = init_skl_mmio_info(gvt);\n\t\tif (ret)\n\t\t\tgoto err;\n\t\tret = init_bxt_mmio_info(gvt);\n\t\tif (ret)\n\t\t\tgoto err;\n\t}\n\n\treturn 0;\nerr:\n\tintel_gvt_clean_mmio_info(gvt);\n\treturn ret;\n}\n\n \nint intel_gvt_for_each_tracked_mmio(struct intel_gvt *gvt,\n\tint (*handler)(struct intel_gvt *gvt, u32 offset, void *data),\n\tvoid *data)\n{\n\tstruct gvt_mmio_block *block = gvt->mmio.mmio_block;\n\tstruct intel_gvt_mmio_info *e;\n\tint i, j, ret;\n\n\thash_for_each(gvt->mmio.mmio_info_table, i, e, node) {\n\t\tret = handler(gvt, e->offset, data);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tfor (i = 0; i < gvt->mmio.num_mmio_block; i++, block++) {\n\t\t \n\t\tif (i915_mmio_reg_offset(block->offset) == VGT_PVINFO_PAGE)\n\t\t\tcontinue;\n\n\t\tfor (j = 0; j < block->size; j += 4) {\n\t\t\tret = handler(gvt, i915_mmio_reg_offset(block->offset) + j, data);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t}\n\t}\n\treturn 0;\n}\n\n \nint intel_vgpu_default_mmio_read(struct intel_vgpu *vgpu, unsigned int offset,\n\t\tvoid *p_data, unsigned int bytes)\n{\n\tread_vreg(vgpu, offset, p_data, bytes);\n\treturn 0;\n}\n\n \nint intel_vgpu_default_mmio_write(struct intel_vgpu *vgpu, unsigned int offset,\n\t\tvoid *p_data, unsigned int bytes)\n{\n\twrite_vreg(vgpu, offset, p_data, bytes);\n\treturn 0;\n}\n\n \nint intel_vgpu_mask_mmio_write(struct intel_vgpu *vgpu, unsigned int offset,\n\t\tvoid *p_data, unsigned int bytes)\n{\n\tu32 mask, old_vreg;\n\n\told_vreg = vgpu_vreg(vgpu, offset);\n\twrite_vreg(vgpu, offset, p_data, bytes);\n\tmask = vgpu_vreg(vgpu, offset) >> 16;\n\tvgpu_vreg(vgpu, offset) = (old_vreg & ~mask) |\n\t\t\t\t(vgpu_vreg(vgpu, offset) & mask);\n\n\treturn 0;\n}\n\n \nbool intel_gvt_in_force_nonpriv_whitelist(struct intel_gvt *gvt,\n\t\t\t\t\t  unsigned int offset)\n{\n\treturn in_whitelist(offset);\n}\n\n \nint intel_vgpu_mmio_reg_rw(struct intel_vgpu *vgpu, unsigned int offset,\n\t\t\t   void *pdata, unsigned int bytes, bool is_read)\n{\n\tstruct drm_i915_private *i915 = vgpu->gvt->gt->i915;\n\tstruct intel_gvt *gvt = vgpu->gvt;\n\tstruct intel_gvt_mmio_info *mmio_info;\n\tstruct gvt_mmio_block *mmio_block;\n\tgvt_mmio_func func;\n\tint ret;\n\n\tif (drm_WARN_ON(&i915->drm, bytes > 8))\n\t\treturn -EINVAL;\n\n\t \n\tmmio_block = find_mmio_block(gvt, offset);\n\tif (mmio_block) {\n\t\tfunc = is_read ? mmio_block->read : mmio_block->write;\n\t\tif (func)\n\t\t\treturn func(vgpu, offset, pdata, bytes);\n\t\tgoto default_rw;\n\t}\n\n\t \n\tmmio_info = intel_gvt_find_mmio_info(gvt, offset);\n\tif (!mmio_info) {\n\t\tgvt_dbg_mmio(\"untracked MMIO %08x len %d\\n\", offset, bytes);\n\t\tgoto default_rw;\n\t}\n\n\tif (is_read)\n\t\treturn mmio_info->read(vgpu, offset, pdata, bytes);\n\telse {\n\t\tu64 ro_mask = mmio_info->ro_mask;\n\t\tu32 old_vreg = 0;\n\t\tu64 data = 0;\n\n\t\tif (intel_gvt_mmio_has_mode_mask(gvt, mmio_info->offset)) {\n\t\t\told_vreg = vgpu_vreg(vgpu, offset);\n\t\t}\n\n\t\tif (likely(!ro_mask))\n\t\t\tret = mmio_info->write(vgpu, offset, pdata, bytes);\n\t\telse if (!~ro_mask) {\n\t\t\tgvt_vgpu_err(\"try to write RO reg %x\\n\", offset);\n\t\t\treturn 0;\n\t\t} else {\n\t\t\t \n\t\t\tmemcpy(&data, pdata, bytes);\n\t\t\tdata &= ~ro_mask;\n\t\t\tdata |= vgpu_vreg(vgpu, offset) & ro_mask;\n\t\t\tret = mmio_info->write(vgpu, offset, &data, bytes);\n\t\t}\n\n\t\t \n\t\tif (intel_gvt_mmio_has_mode_mask(gvt, mmio_info->offset)) {\n\t\t\tu32 mask = vgpu_vreg(vgpu, offset) >> 16;\n\n\t\t\tvgpu_vreg(vgpu, offset) = (old_vreg & ~mask)\n\t\t\t\t\t| (vgpu_vreg(vgpu, offset) & mask);\n\t\t}\n\t}\n\n\treturn ret;\n\ndefault_rw:\n\treturn is_read ?\n\t\tintel_vgpu_default_mmio_read(vgpu, offset, pdata, bytes) :\n\t\tintel_vgpu_default_mmio_write(vgpu, offset, pdata, bytes);\n}\n\nvoid intel_gvt_restore_fence(struct intel_gvt *gvt)\n{\n\tstruct intel_vgpu *vgpu;\n\tint i, id;\n\n\tidr_for_each_entry(&(gvt)->vgpu_idr, vgpu, id) {\n\t\tmmio_hw_access_pre(gvt->gt);\n\t\tfor (i = 0; i < vgpu_fence_sz(vgpu); i++)\n\t\t\tintel_vgpu_write_fence(vgpu, i, vgpu_vreg64(vgpu, fence_num_to_offset(i)));\n\t\tmmio_hw_access_post(gvt->gt);\n\t}\n}\n\nstatic int mmio_pm_restore_handler(struct intel_gvt *gvt, u32 offset, void *data)\n{\n\tstruct intel_vgpu *vgpu = data;\n\tstruct drm_i915_private *dev_priv = gvt->gt->i915;\n\n\tif (gvt->mmio.mmio_attribute[offset >> 2] & F_PM_SAVE)\n\t\tintel_uncore_write(&dev_priv->uncore, _MMIO(offset), vgpu_vreg(vgpu, offset));\n\n\treturn 0;\n}\n\nvoid intel_gvt_restore_mmio(struct intel_gvt *gvt)\n{\n\tstruct intel_vgpu *vgpu;\n\tint id;\n\n\tidr_for_each_entry(&(gvt)->vgpu_idr, vgpu, id) {\n\t\tmmio_hw_access_pre(gvt->gt);\n\t\tintel_gvt_for_each_tracked_mmio(gvt, mmio_pm_restore_handler, vgpu);\n\t\tmmio_hw_access_post(gvt->gt);\n\t}\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}