{
  "module_name": "opregion.c",
  "hash_id": "10113d611f9578672eaae60b89bda7251f82fb9accc71501abf6cebbfbb3d35a",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/i915/gvt/opregion.c",
  "human_readable_source": " \n\n#include <linux/acpi.h>\n#include \"i915_drv.h\"\n#include \"gvt.h\"\n\n \n#define _INTEL_BIOS_PRIVATE\n#include \"display/intel_vbt_defs.h\"\n\n#define OPREGION_SIGNATURE \"IntelGraphicsMem\"\n#define MBOX_VBT      (1<<3)\n\n \n#define DEVICE_TYPE_CRT    0x01\n#define DEVICE_TYPE_EFP1   0x04\n#define DEVICE_TYPE_EFP2   0x40\n#define DEVICE_TYPE_EFP3   0x20\n#define DEVICE_TYPE_EFP4   0x10\n\nstruct opregion_header {\n\tu8 signature[16];\n\tu32 size;\n\tu32 opregion_ver;\n\tu8 bios_ver[32];\n\tu8 vbios_ver[16];\n\tu8 driver_ver[16];\n\tu32 mboxes;\n\tu32 driver_model;\n\tu32 pcon;\n\tu8 dver[32];\n\tu8 rsvd[124];\n} __packed;\n\nstruct bdb_data_header {\n\tu8 id;\n\tu16 size;  \n} __packed;\n\n \nstruct efp_child_device_config {\n\tu16 handle;\n\tu16 device_type;\n\tu16 device_class;\n\tu8 i2c_speed;\n\tu8 dp_onboard_redriver;  \n\tu8 dp_ondock_redriver;  \n\tu8 hdmi_level_shifter_value:4;  \n\tu8 hdmi_max_data_rate:4;  \n\tu16 dtd_buf_ptr;  \n\tu8 edidless_efp:1;  \n\tu8 compression_enable:1;  \n\tu8 compression_method:1;  \n\tu8 ganged_edp:1;  \n\tu8 skip0:4;\n\tu8 compression_structure_index:4;  \n\tu8 skip1:4;\n\tu8 slave_port;  \n\tu8 skip2;\n\tu8 dvo_port;\n\tu8 i2c_pin;  \n\tu8 slave_addr;  \n\tu8 ddc_pin;\n\tu16 edid_ptr;\n\tu8 dvo_config;\n\tu8 efp_docked_port:1;  \n\tu8 lane_reversal:1;  \n\tu8 onboard_lspcon:1;  \n\tu8 iboost_enable:1;  \n\tu8 hpd_invert:1;  \n\tu8 slip3:3;\n\tu8 hdmi_compat:1;\n\tu8 dp_compat:1;\n\tu8 tmds_compat:1;\n\tu8 skip4:5;\n\tu8 aux_channel;\n\tu8 dongle_detect;\n\tu8 pipe_cap:2;\n\tu8 sdvo_stall:1;  \n\tu8 hpd_status:2;\n\tu8 integrated_encoder:1;\n\tu8 skip5:2;\n\tu8 dvo_wiring;\n\tu8 mipi_bridge_type;  \n\tu16 device_class_ext;\n\tu8 dvo_function;\n} __packed;\n\nstruct vbt {\n\t \n\tstruct vbt_header header;\n\tstruct bdb_header bdb_header;\n\n\tstruct bdb_data_header general_features_header;\n\tstruct bdb_general_features general_features;\n\n\tstruct bdb_data_header general_definitions_header;\n\tstruct bdb_general_definitions general_definitions;\n\n\tstruct efp_child_device_config child0;\n\tstruct efp_child_device_config child1;\n\tstruct efp_child_device_config child2;\n\tstruct efp_child_device_config child3;\n\n\tstruct bdb_data_header driver_features_header;\n\tstruct bdb_driver_features driver_features;\n};\n\nstatic void virt_vbt_generation(struct vbt *v)\n{\n\tint num_child;\n\n\tmemset(v, 0, sizeof(struct vbt));\n\n\tv->header.signature[0] = '$';\n\tv->header.signature[1] = 'V';\n\tv->header.signature[2] = 'B';\n\tv->header.signature[3] = 'T';\n\n\t \n\tv->header.version = 155;\n\tv->header.header_size = sizeof(v->header);\n\tv->header.vbt_size = sizeof(struct vbt);\n\tv->header.bdb_offset = offsetof(struct vbt, bdb_header);\n\n\tstrcpy(&v->bdb_header.signature[0], \"BIOS_DATA_BLOCK\");\n\tv->bdb_header.version = 186;  \n\tv->bdb_header.header_size = sizeof(v->bdb_header);\n\n\tv->bdb_header.bdb_size = sizeof(struct vbt) - sizeof(struct vbt_header);\n\n\t \n\tv->general_features_header.id = BDB_GENERAL_FEATURES;\n\tv->general_features_header.size = sizeof(struct bdb_general_features);\n\tv->general_features.int_crt_support = 0;\n\tv->general_features.int_tv_support = 0;\n\n\t \n\tnum_child = 4;  \n\tv->general_definitions.child_dev_size =\n\t\tsizeof(struct efp_child_device_config);\n\tv->general_definitions_header.id = BDB_GENERAL_DEFINITIONS;\n\t \n\tv->general_definitions_header.size =\n\t\tsizeof(struct bdb_general_definitions) +\n\t\t\tnum_child * v->general_definitions.child_dev_size;\n\n\t \n\tv->child0.handle = DEVICE_TYPE_EFP1;\n\tv->child0.device_type = DEVICE_TYPE_DP;\n\tv->child0.dvo_port = DVO_PORT_DPA;\n\tv->child0.aux_channel = DP_AUX_A;\n\tv->child0.dp_compat = true;\n\tv->child0.integrated_encoder = true;\n\n\t \n\tv->child1.handle = DEVICE_TYPE_EFP2;\n\tv->child1.device_type = DEVICE_TYPE_DP;\n\tv->child1.dvo_port = DVO_PORT_DPB;\n\tv->child1.aux_channel = DP_AUX_B;\n\tv->child1.dp_compat = true;\n\tv->child1.integrated_encoder = true;\n\n\t \n\tv->child2.handle = DEVICE_TYPE_EFP3;\n\tv->child2.device_type = DEVICE_TYPE_DP;\n\tv->child2.dvo_port = DVO_PORT_DPC;\n\tv->child2.aux_channel = DP_AUX_C;\n\tv->child2.dp_compat = true;\n\tv->child2.integrated_encoder = true;\n\n\t \n\tv->child3.handle = DEVICE_TYPE_EFP4;\n\tv->child3.device_type = DEVICE_TYPE_DP;\n\tv->child3.dvo_port = DVO_PORT_DPD;\n\tv->child3.aux_channel = DP_AUX_D;\n\tv->child3.dp_compat = true;\n\tv->child3.integrated_encoder = true;\n\n\t \n\tv->driver_features_header.id = BDB_DRIVER_FEATURES;\n\tv->driver_features_header.size = sizeof(struct bdb_driver_features);\n\tv->driver_features.lvds_config = BDB_DRIVER_FEATURE_NO_LVDS;\n}\n\n \nint intel_vgpu_init_opregion(struct intel_vgpu *vgpu)\n{\n\tu8 *buf;\n\tstruct opregion_header *header;\n\tstruct vbt v;\n\tconst char opregion_signature[16] = OPREGION_SIGNATURE;\n\n\tgvt_dbg_core(\"init vgpu%d opregion\\n\", vgpu->id);\n\tvgpu_opregion(vgpu)->va = (void *)__get_free_pages(GFP_KERNEL |\n\t\t\t__GFP_ZERO,\n\t\t\tget_order(INTEL_GVT_OPREGION_SIZE));\n\tif (!vgpu_opregion(vgpu)->va) {\n\t\tgvt_err(\"fail to get memory for vgpu virt opregion\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\t \n\tbuf = (u8 *)vgpu_opregion(vgpu)->va;\n\theader = (struct opregion_header *)buf;\n\tmemcpy(header->signature, opregion_signature,\n\t       sizeof(opregion_signature));\n\theader->size = 0x8;\n\theader->opregion_ver = 0x02000000;\n\theader->mboxes = MBOX_VBT;\n\n\t \n\tbuf[INTEL_GVT_OPREGION_CLID] = 0x3;\n\n\t \n\tvirt_vbt_generation(&v);\n\tmemcpy(buf + INTEL_GVT_OPREGION_VBT_OFFSET, &v, sizeof(struct vbt));\n\n\treturn 0;\n}\n\n \nint intel_vgpu_opregion_base_write_handler(struct intel_vgpu *vgpu, u32 gpa)\n{\n\n\tint i;\n\n\tgvt_dbg_core(\"emulate opregion from kernel\\n\");\n\n\tfor (i = 0; i < INTEL_GVT_OPREGION_PAGES; i++)\n\t\tvgpu_opregion(vgpu)->gfn[i] = (gpa >> PAGE_SHIFT) + i;\n\treturn 0;\n}\n\n \nvoid intel_vgpu_clean_opregion(struct intel_vgpu *vgpu)\n{\n\tgvt_dbg_core(\"vgpu%d: clean vgpu opregion\\n\", vgpu->id);\n\n\tif (!vgpu_opregion(vgpu)->va)\n\t\treturn;\n\n\t \n\tfree_pages((unsigned long)vgpu_opregion(vgpu)->va,\n\t\t   get_order(INTEL_GVT_OPREGION_SIZE));\n\n\tvgpu_opregion(vgpu)->va = NULL;\n\n}\n\n\n#define GVT_OPREGION_FUNC(scic)\t\t\t\t\t\\\n\t({\t\t\t\t\t\t\t\\\n\t u32 __ret;\t\t\t\t\t\t\\\n\t __ret = (scic & OPREGION_SCIC_FUNC_MASK) >>\t\t\\\n\t OPREGION_SCIC_FUNC_SHIFT;\t\t\t\t\\\n\t __ret;\t\t\t\t\t\t\t\\\n\t })\n\n#define GVT_OPREGION_SUBFUNC(scic)\t\t\t\t\\\n\t({\t\t\t\t\t\t\t\\\n\t u32 __ret;\t\t\t\t\t\t\\\n\t __ret = (scic & OPREGION_SCIC_SUBFUNC_MASK) >>\t\t\\\n\t OPREGION_SCIC_SUBFUNC_SHIFT;\t\t\t\t\\\n\t __ret;\t\t\t\t\t\t\t\\\n\t })\n\nstatic const char *opregion_func_name(u32 func)\n{\n\tconst char *name = NULL;\n\n\tswitch (func) {\n\tcase 0 ... 3:\n\tcase 5:\n\tcase 7 ... 15:\n\t\tname = \"Reserved\";\n\t\tbreak;\n\n\tcase 4:\n\t\tname = \"Get BIOS Data\";\n\t\tbreak;\n\n\tcase 6:\n\t\tname = \"System BIOS Callbacks\";\n\t\tbreak;\n\n\tdefault:\n\t\tname = \"Unknown\";\n\t\tbreak;\n\t}\n\treturn name;\n}\n\nstatic const char *opregion_subfunc_name(u32 subfunc)\n{\n\tconst char *name = NULL;\n\n\tswitch (subfunc) {\n\tcase 0:\n\t\tname = \"Supported Calls\";\n\t\tbreak;\n\n\tcase 1:\n\t\tname = \"Requested Callbacks\";\n\t\tbreak;\n\n\tcase 2 ... 3:\n\tcase 8 ... 9:\n\t\tname = \"Reserved\";\n\t\tbreak;\n\n\tcase 5:\n\t\tname = \"Boot Display\";\n\t\tbreak;\n\n\tcase 6:\n\t\tname = \"TV-Standard/Video-Connector\";\n\t\tbreak;\n\n\tcase 7:\n\t\tname = \"Internal Graphics\";\n\t\tbreak;\n\n\tcase 10:\n\t\tname = \"Spread Spectrum Clocks\";\n\t\tbreak;\n\n\tcase 11:\n\t\tname = \"Get AKSV\";\n\t\tbreak;\n\n\tdefault:\n\t\tname = \"Unknown\";\n\t\tbreak;\n\t}\n\treturn name;\n};\n\nstatic bool querying_capabilities(u32 scic)\n{\n\tu32 func, subfunc;\n\n\tfunc = GVT_OPREGION_FUNC(scic);\n\tsubfunc = GVT_OPREGION_SUBFUNC(scic);\n\n\tif ((func == INTEL_GVT_OPREGION_SCIC_F_GETBIOSDATA &&\n\t\tsubfunc == INTEL_GVT_OPREGION_SCIC_SF_SUPPRTEDCALLS)\n\t\t|| (func == INTEL_GVT_OPREGION_SCIC_F_GETBIOSDATA &&\n\t\t subfunc == INTEL_GVT_OPREGION_SCIC_SF_REQEUSTEDCALLBACKS)\n\t\t|| (func == INTEL_GVT_OPREGION_SCIC_F_GETBIOSCALLBACKS &&\n\t\t subfunc == INTEL_GVT_OPREGION_SCIC_SF_SUPPRTEDCALLS)) {\n\t\treturn true;\n\t}\n\treturn false;\n}\n\n \nint intel_vgpu_emulate_opregion_request(struct intel_vgpu *vgpu, u32 swsci)\n{\n\tu32 scic, parm;\n\tu32 func, subfunc;\n\tu64 scic_pa = 0, parm_pa = 0;\n\tint ret;\n\n\tscic_pa = (vgpu_opregion(vgpu)->gfn[0] << PAGE_SHIFT) +\n\t\t\t\tINTEL_GVT_OPREGION_SCIC;\n\tparm_pa = (vgpu_opregion(vgpu)->gfn[0] << PAGE_SHIFT) +\n\t\t\t\tINTEL_GVT_OPREGION_PARM;\n\tret = intel_gvt_read_gpa(vgpu, scic_pa, &scic, sizeof(scic));\n\tif (ret) {\n\t\tgvt_vgpu_err(\"guest opregion read error %d, gpa 0x%llx, len %lu\\n\",\n\t\t\tret, scic_pa, sizeof(scic));\n\t\treturn ret;\n\t}\n\n\tret = intel_gvt_read_gpa(vgpu, parm_pa, &parm, sizeof(parm));\n\tif (ret) {\n\t\tgvt_vgpu_err(\"guest opregion read error %d, gpa 0x%llx, len %lu\\n\",\n\t\t\tret, scic_pa, sizeof(scic));\n\t\treturn ret;\n\t}\n\n\tif (!(swsci & SWSCI_SCI_SELECT)) {\n\t\tgvt_vgpu_err(\"requesting SMI service\\n\");\n\t\treturn 0;\n\t}\n\t \n\tif ((vgpu_cfg_space(vgpu)[INTEL_GVT_PCI_SWSCI]\n\t\t\t\t& SWSCI_SCI_TRIGGER) ||\n\t\t\t!(swsci & SWSCI_SCI_TRIGGER)) {\n\t\treturn 0;\n\t}\n\n\tfunc = GVT_OPREGION_FUNC(scic);\n\tsubfunc = GVT_OPREGION_SUBFUNC(scic);\n\tif (!querying_capabilities(scic)) {\n\t\tgvt_vgpu_err(\"requesting runtime service: func \\\"%s\\\",\"\n\t\t\t\t\" subfunc \\\"%s\\\"\\n\",\n\t\t\t\topregion_func_name(func),\n\t\t\t\topregion_subfunc_name(subfunc));\n\t\t \n\t\tscic &= ~OPREGION_SCIC_EXIT_MASK;\n\t\tgoto out;\n\t}\n\n\tscic = 0;\n\tparm = 0;\n\nout:\n\tret = intel_gvt_write_gpa(vgpu, scic_pa, &scic, sizeof(scic));\n\tif (ret) {\n\t\tgvt_vgpu_err(\"guest opregion write error %d, gpa 0x%llx, len %lu\\n\",\n\t\t\tret, scic_pa, sizeof(scic));\n\t\treturn ret;\n\t}\n\n\tret = intel_gvt_write_gpa(vgpu, parm_pa, &parm, sizeof(parm));\n\tif (ret) {\n\t\tgvt_vgpu_err(\"guest opregion write error %d, gpa 0x%llx, len %lu\\n\",\n\t\t\tret, scic_pa, sizeof(scic));\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}