{
  "module_name": "fb_decoder.c",
  "hash_id": "ce9b6d74a27e28da42d8b92c89fbfba05d8059b3b8a608ef013302f9a96932dd",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/i915/gvt/fb_decoder.c",
  "human_readable_source": " \n\n#include <uapi/drm/drm_fourcc.h>\n#include \"i915_drv.h\"\n#include \"gvt.h\"\n#include \"i915_pvinfo.h\"\n#include \"i915_reg.h\"\n\n#define PRIMARY_FORMAT_NUM\t16\nstruct pixel_format {\n\tint drm_format;\t \n\tint bpp;  \n\tconst char *desc;  \n};\n\nstatic const struct pixel_format bdw_pixel_formats[] = {\n\t{DRM_FORMAT_C8, 8, \"8-bit Indexed\"},\n\t{DRM_FORMAT_RGB565, 16, \"16-bit BGRX (5:6:5 MSB-R:G:B)\"},\n\t{DRM_FORMAT_XRGB8888, 32, \"32-bit BGRX (8:8:8:8 MSB-X:R:G:B)\"},\n\t{DRM_FORMAT_XBGR2101010, 32, \"32-bit RGBX (2:10:10:10 MSB-X:B:G:R)\"},\n\n\t{DRM_FORMAT_XRGB2101010, 32, \"32-bit BGRX (2:10:10:10 MSB-X:R:G:B)\"},\n\t{DRM_FORMAT_XBGR8888, 32, \"32-bit RGBX (8:8:8:8 MSB-X:B:G:R)\"},\n\n\t \n\t{0, 0, NULL},\n};\n\nstatic const struct pixel_format skl_pixel_formats[] = {\n\t{DRM_FORMAT_YUYV, 16, \"16-bit packed YUYV (8:8:8:8 MSB-V:Y2:U:Y1)\"},\n\t{DRM_FORMAT_UYVY, 16, \"16-bit packed UYVY (8:8:8:8 MSB-Y2:V:Y1:U)\"},\n\t{DRM_FORMAT_YVYU, 16, \"16-bit packed YVYU (8:8:8:8 MSB-U:Y2:V:Y1)\"},\n\t{DRM_FORMAT_VYUY, 16, \"16-bit packed VYUY (8:8:8:8 MSB-Y2:U:Y1:V)\"},\n\n\t{DRM_FORMAT_C8, 8, \"8-bit Indexed\"},\n\t{DRM_FORMAT_RGB565, 16, \"16-bit BGRX (5:6:5 MSB-R:G:B)\"},\n\t{DRM_FORMAT_ABGR8888, 32, \"32-bit RGBA (8:8:8:8 MSB-A:B:G:R)\"},\n\t{DRM_FORMAT_XBGR8888, 32, \"32-bit RGBX (8:8:8:8 MSB-X:B:G:R)\"},\n\n\t{DRM_FORMAT_ARGB8888, 32, \"32-bit BGRA (8:8:8:8 MSB-A:R:G:B)\"},\n\t{DRM_FORMAT_XRGB8888, 32, \"32-bit BGRX (8:8:8:8 MSB-X:R:G:B)\"},\n\t{DRM_FORMAT_XBGR2101010, 32, \"32-bit RGBX (2:10:10:10 MSB-X:B:G:R)\"},\n\t{DRM_FORMAT_XRGB2101010, 32, \"32-bit BGRX (2:10:10:10 MSB-X:R:G:B)\"},\n\n\t \n\t{0, 0, NULL},\n};\n\nstatic int bdw_format_to_drm(int format)\n{\n\tint bdw_pixel_formats_index = 6;\n\n\tswitch (format) {\n\tcase DISP_FORMAT_8BPP:\n\t\tbdw_pixel_formats_index = 0;\n\t\tbreak;\n\tcase DISP_FORMAT_BGRX565:\n\t\tbdw_pixel_formats_index = 1;\n\t\tbreak;\n\tcase DISP_FORMAT_BGRX888:\n\t\tbdw_pixel_formats_index = 2;\n\t\tbreak;\n\tcase DISP_FORMAT_RGBX101010:\n\t\tbdw_pixel_formats_index = 3;\n\t\tbreak;\n\tcase DISP_FORMAT_BGRX101010:\n\t\tbdw_pixel_formats_index = 4;\n\t\tbreak;\n\tcase DISP_FORMAT_RGBX888:\n\t\tbdw_pixel_formats_index = 5;\n\t\tbreak;\n\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn bdw_pixel_formats_index;\n}\n\nstatic int skl_format_to_drm(int format, bool rgb_order, bool alpha,\n\tint yuv_order)\n{\n\tint skl_pixel_formats_index = 12;\n\n\tswitch (format) {\n\tcase PLANE_CTL_FORMAT_INDEXED:\n\t\tskl_pixel_formats_index = 4;\n\t\tbreak;\n\tcase PLANE_CTL_FORMAT_RGB_565:\n\t\tskl_pixel_formats_index = 5;\n\t\tbreak;\n\tcase PLANE_CTL_FORMAT_XRGB_8888:\n\t\tif (rgb_order)\n\t\t\tskl_pixel_formats_index = alpha ? 6 : 7;\n\t\telse\n\t\t\tskl_pixel_formats_index = alpha ? 8 : 9;\n\t\tbreak;\n\tcase PLANE_CTL_FORMAT_XRGB_2101010:\n\t\tskl_pixel_formats_index = rgb_order ? 10 : 11;\n\t\tbreak;\n\tcase PLANE_CTL_FORMAT_YUV422:\n\t\tskl_pixel_formats_index = yuv_order >> 16;\n\t\tif (skl_pixel_formats_index > 3)\n\t\t\treturn -EINVAL;\n\t\tbreak;\n\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn skl_pixel_formats_index;\n}\n\nstatic u32 intel_vgpu_get_stride(struct intel_vgpu *vgpu, int pipe,\n\tu32 tiled, int stride_mask, int bpp)\n{\n\tstruct drm_i915_private *dev_priv = vgpu->gvt->gt->i915;\n\n\tu32 stride_reg = vgpu_vreg_t(vgpu, DSPSTRIDE(pipe)) & stride_mask;\n\tu32 stride = stride_reg;\n\n\tif (GRAPHICS_VER(dev_priv) >= 9) {\n\t\tswitch (tiled) {\n\t\tcase PLANE_CTL_TILED_LINEAR:\n\t\t\tstride = stride_reg * 64;\n\t\t\tbreak;\n\t\tcase PLANE_CTL_TILED_X:\n\t\t\tstride = stride_reg * 512;\n\t\t\tbreak;\n\t\tcase PLANE_CTL_TILED_Y:\n\t\t\tstride = stride_reg * 128;\n\t\t\tbreak;\n\t\tcase PLANE_CTL_TILED_YF:\n\t\t\tif (bpp == 8)\n\t\t\t\tstride = stride_reg * 64;\n\t\t\telse if (bpp == 16 || bpp == 32 || bpp == 64)\n\t\t\t\tstride = stride_reg * 128;\n\t\t\telse\n\t\t\t\tgvt_dbg_core(\"skl: unsupported bpp:%d\\n\", bpp);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tgvt_dbg_core(\"skl: unsupported tile format:%x\\n\",\n\t\t\t\ttiled);\n\t\t}\n\t}\n\n\treturn stride;\n}\n\nstatic int get_active_pipe(struct intel_vgpu *vgpu)\n{\n\tint i;\n\n\tfor (i = 0; i < I915_MAX_PIPES; i++)\n\t\tif (pipe_is_enabled(vgpu, i))\n\t\t\tbreak;\n\n\treturn i;\n}\n\n \nint intel_vgpu_decode_primary_plane(struct intel_vgpu *vgpu,\n\tstruct intel_vgpu_primary_plane_format *plane)\n{\n\tstruct drm_i915_private *dev_priv = vgpu->gvt->gt->i915;\n\tu32 val, fmt;\n\tint pipe;\n\n\tpipe = get_active_pipe(vgpu);\n\tif (pipe >= I915_MAX_PIPES)\n\t\treturn -ENODEV;\n\n\tval = vgpu_vreg_t(vgpu, DSPCNTR(pipe));\n\tplane->enabled = !!(val & DISP_ENABLE);\n\tif (!plane->enabled)\n\t\treturn -ENODEV;\n\n\tif (GRAPHICS_VER(dev_priv) >= 9) {\n\t\tplane->tiled = val & PLANE_CTL_TILED_MASK;\n\t\tfmt = skl_format_to_drm(\n\t\t\tval & PLANE_CTL_FORMAT_MASK_SKL,\n\t\t\tval & PLANE_CTL_ORDER_RGBX,\n\t\t\tval & PLANE_CTL_ALPHA_MASK,\n\t\t\tval & PLANE_CTL_YUV422_ORDER_MASK);\n\n\t\tif (fmt >= ARRAY_SIZE(skl_pixel_formats)) {\n\t\t\tgvt_vgpu_err(\"Out-of-bounds pixel format index\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tplane->bpp = skl_pixel_formats[fmt].bpp;\n\t\tplane->drm_format = skl_pixel_formats[fmt].drm_format;\n\t} else {\n\t\tplane->tiled = val & DISP_TILED;\n\t\tfmt = bdw_format_to_drm(val & DISP_FORMAT_MASK);\n\t\tplane->bpp = bdw_pixel_formats[fmt].bpp;\n\t\tplane->drm_format = bdw_pixel_formats[fmt].drm_format;\n\t}\n\n\tif (!plane->bpp) {\n\t\tgvt_vgpu_err(\"Non-supported pixel format (0x%x)\\n\", fmt);\n\t\treturn -EINVAL;\n\t}\n\n\tplane->hw_format = fmt;\n\n\tplane->base = vgpu_vreg_t(vgpu, DSPSURF(pipe)) & I915_GTT_PAGE_MASK;\n\tif (!vgpu_gmadr_is_valid(vgpu, plane->base))\n\t\treturn  -EINVAL;\n\n\tplane->base_gpa = intel_vgpu_gma_to_gpa(vgpu->gtt.ggtt_mm, plane->base);\n\tif (plane->base_gpa == INTEL_GVT_INVALID_ADDR) {\n\t\tgvt_vgpu_err(\"Translate primary plane gma 0x%x to gpa fail\\n\",\n\t\t\t\tplane->base);\n\t\treturn  -EINVAL;\n\t}\n\n\tplane->stride = intel_vgpu_get_stride(vgpu, pipe, plane->tiled,\n\t\t(GRAPHICS_VER(dev_priv) >= 9) ?\n\t\t(_PRI_PLANE_STRIDE_MASK >> 6) :\n\t\t_PRI_PLANE_STRIDE_MASK, plane->bpp);\n\n\tplane->width = (vgpu_vreg_t(vgpu, PIPESRC(pipe)) & _PIPE_H_SRCSZ_MASK) >>\n\t\t_PIPE_H_SRCSZ_SHIFT;\n\tplane->width += 1;\n\tplane->height = (vgpu_vreg_t(vgpu, PIPESRC(pipe)) &\n\t\t\t_PIPE_V_SRCSZ_MASK) >> _PIPE_V_SRCSZ_SHIFT;\n\tplane->height += 1;\t \n\n\tval = vgpu_vreg_t(vgpu, DSPTILEOFF(pipe));\n\tplane->x_offset = (val & _PRI_PLANE_X_OFF_MASK) >>\n\t\t_PRI_PLANE_X_OFF_SHIFT;\n\tplane->y_offset = (val & _PRI_PLANE_Y_OFF_MASK) >>\n\t\t_PRI_PLANE_Y_OFF_SHIFT;\n\n\treturn 0;\n}\n\n#define CURSOR_FORMAT_NUM\t(1 << 6)\nstruct cursor_mode_format {\n\tint drm_format;\t \n\tu8 bpp;  \n\tu32 width;  \n\tu32 height;  \n\tconst char *desc;  \n};\n\nstatic const struct cursor_mode_format cursor_pixel_formats[] = {\n\t{DRM_FORMAT_ARGB8888, 32, 128, 128, \"128x128 32bpp ARGB\"},\n\t{DRM_FORMAT_ARGB8888, 32, 256, 256, \"256x256 32bpp ARGB\"},\n\t{DRM_FORMAT_ARGB8888, 32, 64, 64, \"64x64 32bpp ARGB\"},\n\t{DRM_FORMAT_ARGB8888, 32, 64, 64, \"64x64 32bpp ARGB\"},\n\n\t \n\t{0, 0, 0, 0, NULL},\n};\n\nstatic int cursor_mode_to_drm(int mode)\n{\n\tint cursor_pixel_formats_index = 4;\n\n\tswitch (mode) {\n\tcase MCURSOR_MODE_128_ARGB_AX:\n\t\tcursor_pixel_formats_index = 0;\n\t\tbreak;\n\tcase MCURSOR_MODE_256_ARGB_AX:\n\t\tcursor_pixel_formats_index = 1;\n\t\tbreak;\n\tcase MCURSOR_MODE_64_ARGB_AX:\n\t\tcursor_pixel_formats_index = 2;\n\t\tbreak;\n\tcase MCURSOR_MODE_64_32B_AX:\n\t\tcursor_pixel_formats_index = 3;\n\t\tbreak;\n\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn cursor_pixel_formats_index;\n}\n\n \nint intel_vgpu_decode_cursor_plane(struct intel_vgpu *vgpu,\n\tstruct intel_vgpu_cursor_plane_format *plane)\n{\n\tstruct drm_i915_private *dev_priv = vgpu->gvt->gt->i915;\n\tu32 val, mode, index;\n\tu32 alpha_plane, alpha_force;\n\tint pipe;\n\n\tpipe = get_active_pipe(vgpu);\n\tif (pipe >= I915_MAX_PIPES)\n\t\treturn -ENODEV;\n\n\tval = vgpu_vreg_t(vgpu, CURCNTR(pipe));\n\tmode = val & MCURSOR_MODE_MASK;\n\tplane->enabled = (mode != MCURSOR_MODE_DISABLE);\n\tif (!plane->enabled)\n\t\treturn -ENODEV;\n\n\tindex = cursor_mode_to_drm(mode);\n\n\tif (!cursor_pixel_formats[index].bpp) {\n\t\tgvt_vgpu_err(\"Non-supported cursor mode (0x%x)\\n\", mode);\n\t\treturn -EINVAL;\n\t}\n\tplane->mode = mode;\n\tplane->bpp = cursor_pixel_formats[index].bpp;\n\tplane->drm_format = cursor_pixel_formats[index].drm_format;\n\tplane->width = cursor_pixel_formats[index].width;\n\tplane->height = cursor_pixel_formats[index].height;\n\n\talpha_plane = (val & _CURSOR_ALPHA_PLANE_MASK) >>\n\t\t\t\t_CURSOR_ALPHA_PLANE_SHIFT;\n\talpha_force = (val & _CURSOR_ALPHA_FORCE_MASK) >>\n\t\t\t\t_CURSOR_ALPHA_FORCE_SHIFT;\n\tif (alpha_plane || alpha_force)\n\t\tgvt_dbg_core(\"alpha_plane=0x%x, alpha_force=0x%x\\n\",\n\t\t\talpha_plane, alpha_force);\n\n\tplane->base = vgpu_vreg_t(vgpu, CURBASE(pipe)) & I915_GTT_PAGE_MASK;\n\tif (!vgpu_gmadr_is_valid(vgpu, plane->base))\n\t\treturn  -EINVAL;\n\n\tplane->base_gpa = intel_vgpu_gma_to_gpa(vgpu->gtt.ggtt_mm, plane->base);\n\tif (plane->base_gpa == INTEL_GVT_INVALID_ADDR) {\n\t\tgvt_vgpu_err(\"Translate cursor plane gma 0x%x to gpa fail\\n\",\n\t\t\t\tplane->base);\n\t\treturn  -EINVAL;\n\t}\n\n\tval = vgpu_vreg_t(vgpu, CURPOS(pipe));\n\tplane->x_pos = (val & _CURSOR_POS_X_MASK) >> _CURSOR_POS_X_SHIFT;\n\tplane->x_sign = (val & _CURSOR_SIGN_X_MASK) >> _CURSOR_SIGN_X_SHIFT;\n\tplane->y_pos = (val & _CURSOR_POS_Y_MASK) >> _CURSOR_POS_Y_SHIFT;\n\tplane->y_sign = (val & _CURSOR_SIGN_Y_MASK) >> _CURSOR_SIGN_Y_SHIFT;\n\n\tplane->x_hot = vgpu_vreg_t(vgpu, vgtif_reg(cursor_x_hot));\n\tplane->y_hot = vgpu_vreg_t(vgpu, vgtif_reg(cursor_y_hot));\n\treturn 0;\n}\n\n#define SPRITE_FORMAT_NUM\t(1 << 3)\n\nstatic const struct pixel_format sprite_pixel_formats[SPRITE_FORMAT_NUM] = {\n\t[0x0] = {DRM_FORMAT_YUV422, 16, \"YUV 16-bit 4:2:2 packed\"},\n\t[0x1] = {DRM_FORMAT_XRGB2101010, 32, \"RGB 32-bit 2:10:10:10\"},\n\t[0x2] = {DRM_FORMAT_XRGB8888, 32, \"RGB 32-bit 8:8:8:8\"},\n\t[0x4] = {DRM_FORMAT_AYUV, 32,\n\t\t\"YUV 32-bit 4:4:4 packed (8:8:8:8 MSB-X:Y:U:V)\"},\n};\n\n \nint intel_vgpu_decode_sprite_plane(struct intel_vgpu *vgpu,\n\tstruct intel_vgpu_sprite_plane_format *plane)\n{\n\tu32 val, fmt;\n\tu32 color_order, yuv_order;\n\tint drm_format;\n\tint pipe;\n\n\tpipe = get_active_pipe(vgpu);\n\tif (pipe >= I915_MAX_PIPES)\n\t\treturn -ENODEV;\n\n\tval = vgpu_vreg_t(vgpu, SPRCTL(pipe));\n\tplane->enabled = !!(val & SPRITE_ENABLE);\n\tif (!plane->enabled)\n\t\treturn -ENODEV;\n\n\tplane->tiled = !!(val & SPRITE_TILED);\n\tcolor_order = !!(val & SPRITE_RGB_ORDER_RGBX);\n\tyuv_order = (val & SPRITE_YUV_ORDER_MASK) >>\n\t\t\t\t_SPRITE_YUV_ORDER_SHIFT;\n\n\tfmt = (val & SPRITE_FORMAT_MASK) >> _SPRITE_FMT_SHIFT;\n\tif (!sprite_pixel_formats[fmt].bpp) {\n\t\tgvt_vgpu_err(\"Non-supported pixel format (0x%x)\\n\", fmt);\n\t\treturn -EINVAL;\n\t}\n\tplane->hw_format = fmt;\n\tplane->bpp = sprite_pixel_formats[fmt].bpp;\n\tdrm_format = sprite_pixel_formats[fmt].drm_format;\n\n\t \n\tif (!color_order) {\n\t\tif (drm_format == DRM_FORMAT_XRGB2101010)\n\t\t\tdrm_format = DRM_FORMAT_XBGR2101010;\n\t\telse if (drm_format == DRM_FORMAT_XRGB8888)\n\t\t\tdrm_format = DRM_FORMAT_XBGR8888;\n\t}\n\n\tif (drm_format == DRM_FORMAT_YUV422) {\n\t\tswitch (yuv_order) {\n\t\tcase 0:\n\t\t\tdrm_format = DRM_FORMAT_YUYV;\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tdrm_format = DRM_FORMAT_UYVY;\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tdrm_format = DRM_FORMAT_YVYU;\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tdrm_format = DRM_FORMAT_VYUY;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t \n\t\t\tbreak;\n\t\t}\n\t}\n\n\tplane->drm_format = drm_format;\n\n\tplane->base = vgpu_vreg_t(vgpu, SPRSURF(pipe)) & I915_GTT_PAGE_MASK;\n\tif (!vgpu_gmadr_is_valid(vgpu, plane->base))\n\t\treturn  -EINVAL;\n\n\tplane->base_gpa = intel_vgpu_gma_to_gpa(vgpu->gtt.ggtt_mm, plane->base);\n\tif (plane->base_gpa == INTEL_GVT_INVALID_ADDR) {\n\t\tgvt_vgpu_err(\"Translate sprite plane gma 0x%x to gpa fail\\n\",\n\t\t\t\tplane->base);\n\t\treturn  -EINVAL;\n\t}\n\n\tplane->stride = vgpu_vreg_t(vgpu, SPRSTRIDE(pipe)) &\n\t\t\t\t_SPRITE_STRIDE_MASK;\n\n\tval = vgpu_vreg_t(vgpu, SPRSIZE(pipe));\n\tplane->height = (val & _SPRITE_SIZE_HEIGHT_MASK) >>\n\t\t_SPRITE_SIZE_HEIGHT_SHIFT;\n\tplane->width = (val & _SPRITE_SIZE_WIDTH_MASK) >>\n\t\t_SPRITE_SIZE_WIDTH_SHIFT;\n\tplane->height += 1;\t \n\tplane->width += 1;\t \n\n\tval = vgpu_vreg_t(vgpu, SPRPOS(pipe));\n\tplane->x_pos = (val & _SPRITE_POS_X_MASK) >> _SPRITE_POS_X_SHIFT;\n\tplane->y_pos = (val & _SPRITE_POS_Y_MASK) >> _SPRITE_POS_Y_SHIFT;\n\n\tval = vgpu_vreg_t(vgpu, SPROFFSET(pipe));\n\tplane->x_offset = (val & _SPRITE_OFFSET_START_X_MASK) >>\n\t\t\t   _SPRITE_OFFSET_START_X_SHIFT;\n\tplane->y_offset = (val & _SPRITE_OFFSET_START_Y_MASK) >>\n\t\t\t   _SPRITE_OFFSET_START_Y_SHIFT;\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}