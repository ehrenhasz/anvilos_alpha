{
  "module_name": "i915_active.c",
  "hash_id": "ed0e19784da2d71e8bd4baac23bb0b654ef8097a580c219737dcb704c73e6e95",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/i915/selftests/i915_active.c",
  "human_readable_source": " \n\n#include <linux/kref.h>\n#include <linux/string_helpers.h>\n\n#include \"gem/i915_gem_pm.h\"\n#include \"gt/intel_gt.h\"\n\n#include \"i915_selftest.h\"\n\n#include \"igt_flush_test.h\"\n#include \"lib_sw_fence.h\"\n\nstruct live_active {\n\tstruct i915_active base;\n\tstruct kref ref;\n\tbool retired;\n};\n\nstatic void __live_get(struct live_active *active)\n{\n\tkref_get(&active->ref);\n}\n\nstatic void __live_free(struct live_active *active)\n{\n\ti915_active_fini(&active->base);\n\tkfree(active);\n}\n\nstatic void __live_release(struct kref *ref)\n{\n\tstruct live_active *active = container_of(ref, typeof(*active), ref);\n\n\t__live_free(active);\n}\n\nstatic void __live_put(struct live_active *active)\n{\n\tkref_put(&active->ref, __live_release);\n}\n\nstatic int __live_active(struct i915_active *base)\n{\n\tstruct live_active *active = container_of(base, typeof(*active), base);\n\n\t__live_get(active);\n\treturn 0;\n}\n\nstatic void __live_retire(struct i915_active *base)\n{\n\tstruct live_active *active = container_of(base, typeof(*active), base);\n\n\tactive->retired = true;\n\t__live_put(active);\n}\n\nstatic struct live_active *__live_alloc(struct drm_i915_private *i915)\n{\n\tstruct live_active *active;\n\n\tactive = kzalloc(sizeof(*active), GFP_KERNEL);\n\tif (!active)\n\t\treturn NULL;\n\n\tkref_init(&active->ref);\n\ti915_active_init(&active->base, __live_active, __live_retire, 0);\n\n\treturn active;\n}\n\nstatic struct live_active *\n__live_active_setup(struct drm_i915_private *i915)\n{\n\tstruct intel_engine_cs *engine;\n\tstruct i915_sw_fence *submit;\n\tstruct live_active *active;\n\tunsigned int count = 0;\n\tint err = 0;\n\n\tactive = __live_alloc(i915);\n\tif (!active)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tsubmit = heap_fence_create(GFP_KERNEL);\n\tif (!submit) {\n\t\tkfree(active);\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\n\terr = i915_active_acquire(&active->base);\n\tif (err)\n\t\tgoto out;\n\n\tfor_each_uabi_engine(engine, i915) {\n\t\tstruct i915_request *rq;\n\n\t\trq = intel_engine_create_kernel_request(engine);\n\t\tif (IS_ERR(rq)) {\n\t\t\terr = PTR_ERR(rq);\n\t\t\tbreak;\n\t\t}\n\n\t\terr = i915_sw_fence_await_sw_fence_gfp(&rq->submit,\n\t\t\t\t\t\t       submit,\n\t\t\t\t\t\t       GFP_KERNEL);\n\t\tif (err >= 0)\n\t\t\terr = i915_active_add_request(&active->base, rq);\n\t\ti915_request_add(rq);\n\t\tif (err) {\n\t\t\tpr_err(\"Failed to track active ref!\\n\");\n\t\t\tbreak;\n\t\t}\n\n\t\tcount++;\n\t}\n\n\ti915_active_release(&active->base);\n\tif (READ_ONCE(active->retired) && count) {\n\t\tpr_err(\"i915_active retired before submission!\\n\");\n\t\terr = -EINVAL;\n\t}\n\tif (atomic_read(&active->base.count) != count) {\n\t\tpr_err(\"i915_active not tracking all requests, found %d, expected %d\\n\",\n\t\t       atomic_read(&active->base.count), count);\n\t\terr = -EINVAL;\n\t}\n\nout:\n\ti915_sw_fence_commit(submit);\n\theap_fence_put(submit);\n\tif (err) {\n\t\t__live_put(active);\n\t\tactive = ERR_PTR(err);\n\t}\n\n\treturn active;\n}\n\nstatic int live_active_wait(void *arg)\n{\n\tstruct drm_i915_private *i915 = arg;\n\tstruct live_active *active;\n\tint err = 0;\n\n\t \n\n\tactive = __live_active_setup(i915);\n\tif (IS_ERR(active))\n\t\treturn PTR_ERR(active);\n\n\t__i915_active_wait(&active->base, TASK_UNINTERRUPTIBLE);\n\tif (!READ_ONCE(active->retired)) {\n\t\tstruct drm_printer p = drm_err_printer(__func__);\n\n\t\tpr_err(\"i915_active not retired after waiting!\\n\");\n\t\ti915_active_print(&active->base, &p);\n\n\t\terr = -EINVAL;\n\t}\n\n\t__live_put(active);\n\n\tif (igt_flush_test(i915))\n\t\terr = -EIO;\n\n\treturn err;\n}\n\nstatic int live_active_retire(void *arg)\n{\n\tstruct drm_i915_private *i915 = arg;\n\tstruct live_active *active;\n\tint err = 0;\n\n\t \n\n\tactive = __live_active_setup(i915);\n\tif (IS_ERR(active))\n\t\treturn PTR_ERR(active);\n\n\t \n\tif (igt_flush_test(i915))\n\t\terr = -EIO;\n\n\tif (!READ_ONCE(active->retired)) {\n\t\tstruct drm_printer p = drm_err_printer(__func__);\n\n\t\tpr_err(\"i915_active not retired after flushing!\\n\");\n\t\ti915_active_print(&active->base, &p);\n\n\t\terr = -EINVAL;\n\t}\n\n\t__live_put(active);\n\n\treturn err;\n}\n\nstatic int live_active_barrier(void *arg)\n{\n\tstruct drm_i915_private *i915 = arg;\n\tstruct intel_engine_cs *engine;\n\tstruct live_active *active;\n\tint err = 0;\n\n\t \n\n\tactive = __live_alloc(i915);\n\tif (!active)\n\t\treturn -ENOMEM;\n\n\terr = i915_active_acquire(&active->base);\n\tif (err)\n\t\tgoto out;\n\n\tfor_each_uabi_engine(engine, i915) {\n\t\terr = i915_active_acquire_preallocate_barrier(&active->base,\n\t\t\t\t\t\t\t      engine);\n\t\tif (err)\n\t\t\tbreak;\n\n\t\ti915_active_acquire_barrier(&active->base);\n\t}\n\n\ti915_active_release(&active->base);\n\tif (err)\n\t\tgoto out;\n\n\t__i915_active_wait(&active->base, TASK_UNINTERRUPTIBLE);\n\tif (!READ_ONCE(active->retired)) {\n\t\tpr_err(\"i915_active not retired after flushing barriers!\\n\");\n\t\terr = -EINVAL;\n\t}\n\nout:\n\t__live_put(active);\n\n\tif (igt_flush_test(i915))\n\t\terr = -EIO;\n\n\treturn err;\n}\n\nint i915_active_live_selftests(struct drm_i915_private *i915)\n{\n\tstatic const struct i915_subtest tests[] = {\n\t\tSUBTEST(live_active_wait),\n\t\tSUBTEST(live_active_retire),\n\t\tSUBTEST(live_active_barrier),\n\t};\n\n\tif (intel_gt_is_wedged(to_gt(i915)))\n\t\treturn 0;\n\n\treturn i915_subtests(tests, i915);\n}\n\nstatic struct intel_engine_cs *node_to_barrier(struct active_node *it)\n{\n\tstruct intel_engine_cs *engine;\n\n\tif (!is_barrier(&it->base))\n\t\treturn NULL;\n\n\tengine = __barrier_to_engine(it);\n\tsmp_rmb();  \n\tif (!is_barrier(&it->base))\n\t\treturn NULL;\n\n\treturn engine;\n}\n\nvoid i915_active_print(struct i915_active *ref, struct drm_printer *m)\n{\n\tdrm_printf(m, \"active %ps:%ps\\n\", ref->active, ref->retire);\n\tdrm_printf(m, \"\\tcount: %d\\n\", atomic_read(&ref->count));\n\tdrm_printf(m, \"\\tpreallocated barriers? %s\\n\",\n\t\t   str_yes_no(!llist_empty(&ref->preallocated_barriers)));\n\n\tif (i915_active_acquire_if_busy(ref)) {\n\t\tstruct active_node *it, *n;\n\n\t\trbtree_postorder_for_each_entry_safe(it, n, &ref->tree, node) {\n\t\t\tstruct intel_engine_cs *engine;\n\n\t\t\tengine = node_to_barrier(it);\n\t\t\tif (engine) {\n\t\t\t\tdrm_printf(m, \"\\tbarrier: %s\\n\", engine->name);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (i915_active_fence_isset(&it->base)) {\n\t\t\t\tdrm_printf(m,\n\t\t\t\t\t   \"\\ttimeline: %llx\\n\", it->timeline);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\ti915_active_release(ref);\n\t}\n}\n\nstatic void spin_unlock_wait(spinlock_t *lock)\n{\n\tspin_lock_irq(lock);\n\tspin_unlock_irq(lock);\n}\n\nstatic void active_flush(struct i915_active *ref,\n\t\t\t struct i915_active_fence *active)\n{\n\tstruct dma_fence *fence;\n\n\tfence = xchg(__active_fence_slot(active), NULL);\n\tif (!fence)\n\t\treturn;\n\n\tspin_lock_irq(fence->lock);\n\t__list_del_entry(&active->cb.node);\n\tspin_unlock_irq(fence->lock);  \n\tatomic_dec(&ref->count);\n\n\tGEM_BUG_ON(!test_bit(DMA_FENCE_FLAG_SIGNALED_BIT, &fence->flags));\n}\n\nvoid i915_active_unlock_wait(struct i915_active *ref)\n{\n\tif (i915_active_acquire_if_busy(ref)) {\n\t\tstruct active_node *it, *n;\n\n\t\t \n\t\trcu_read_lock();\n\t\tactive_flush(ref, &ref->excl);\n\t\trbtree_postorder_for_each_entry_safe(it, n, &ref->tree, node)\n\t\t\tactive_flush(ref, &it->base);\n\t\trcu_read_unlock();\n\n\t\ti915_active_release(ref);\n\t}\n\n\t \n\tspin_unlock_wait(&ref->tree_lock);\n\n\t \n\tflush_work(&ref->work);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}