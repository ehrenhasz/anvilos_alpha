{
  "module_name": "intel_memory_region.c",
  "hash_id": "878d5dccf16c4717b2dc9baaf5939be3c457837b5920d5de69cc39b0e2c742c7",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/i915/selftests/intel_memory_region.c",
  "human_readable_source": "\n \n\n#include <linux/prime_numbers.h>\n#include <linux/sort.h>\n\n#include <drm/drm_buddy.h>\n\n#include \"../i915_selftest.h\"\n\n#include \"mock_drm.h\"\n#include \"mock_gem_device.h\"\n#include \"mock_region.h\"\n\n#include \"gem/i915_gem_context.h\"\n#include \"gem/i915_gem_lmem.h\"\n#include \"gem/i915_gem_region.h\"\n#include \"gem/i915_gem_ttm.h\"\n#include \"gem/selftests/igt_gem_utils.h\"\n#include \"gem/selftests/mock_context.h\"\n#include \"gt/intel_engine_pm.h\"\n#include \"gt/intel_engine_user.h\"\n#include \"gt/intel_gt.h\"\n#include \"gt/intel_migrate.h\"\n#include \"i915_memcpy.h\"\n#include \"i915_ttm_buddy_manager.h\"\n#include \"selftests/igt_flush_test.h\"\n#include \"selftests/i915_random.h\"\n\nstatic void close_objects(struct intel_memory_region *mem,\n\t\t\t  struct list_head *objects)\n{\n\tstruct drm_i915_private *i915 = mem->i915;\n\tstruct drm_i915_gem_object *obj, *on;\n\n\tlist_for_each_entry_safe(obj, on, objects, st_link) {\n\t\ti915_gem_object_lock(obj, NULL);\n\t\tif (i915_gem_object_has_pinned_pages(obj))\n\t\t\ti915_gem_object_unpin_pages(obj);\n\t\t \n\t\t__i915_gem_object_put_pages(obj);\n\t\ti915_gem_object_unlock(obj);\n\t\tlist_del(&obj->st_link);\n\t\ti915_gem_object_put(obj);\n\t}\n\n\tcond_resched();\n\n\ti915_gem_drain_freed_objects(i915);\n}\n\nstatic int igt_mock_fill(void *arg)\n{\n\tstruct intel_memory_region *mem = arg;\n\tresource_size_t total = resource_size(&mem->region);\n\tresource_size_t page_size;\n\tresource_size_t rem;\n\tunsigned long max_pages;\n\tunsigned long page_num;\n\tLIST_HEAD(objects);\n\tint err = 0;\n\n\tpage_size = PAGE_SIZE;\n\tmax_pages = div64_u64(total, page_size);\n\trem = total;\n\n\tfor_each_prime_number_from(page_num, 1, max_pages) {\n\t\tresource_size_t size = page_num * page_size;\n\t\tstruct drm_i915_gem_object *obj;\n\n\t\tobj = i915_gem_object_create_region(mem, size, 0, 0);\n\t\tif (IS_ERR(obj)) {\n\t\t\terr = PTR_ERR(obj);\n\t\t\tbreak;\n\t\t}\n\n\t\terr = i915_gem_object_pin_pages_unlocked(obj);\n\t\tif (err) {\n\t\t\ti915_gem_object_put(obj);\n\t\t\tbreak;\n\t\t}\n\n\t\tlist_add(&obj->st_link, &objects);\n\t\trem -= size;\n\t}\n\n\tif (err == -ENOMEM)\n\t\terr = 0;\n\tif (err == -ENXIO) {\n\t\tif (page_num * page_size <= rem) {\n\t\t\tpr_err(\"%s failed, space still left in region\\n\",\n\t\t\t       __func__);\n\t\t\terr = -EINVAL;\n\t\t} else {\n\t\t\terr = 0;\n\t\t}\n\t}\n\n\tclose_objects(mem, &objects);\n\n\treturn err;\n}\n\nstatic struct drm_i915_gem_object *\nigt_object_create(struct intel_memory_region *mem,\n\t\t  struct list_head *objects,\n\t\t  u64 size,\n\t\t  unsigned int flags)\n{\n\tstruct drm_i915_gem_object *obj;\n\tint err;\n\n\tobj = i915_gem_object_create_region(mem, size, 0, flags);\n\tif (IS_ERR(obj))\n\t\treturn obj;\n\n\terr = i915_gem_object_pin_pages_unlocked(obj);\n\tif (err)\n\t\tgoto put;\n\n\tlist_add(&obj->st_link, objects);\n\treturn obj;\n\nput:\n\ti915_gem_object_put(obj);\n\treturn ERR_PTR(err);\n}\n\nstatic void igt_object_release(struct drm_i915_gem_object *obj)\n{\n\ti915_gem_object_lock(obj, NULL);\n\ti915_gem_object_unpin_pages(obj);\n\t__i915_gem_object_put_pages(obj);\n\ti915_gem_object_unlock(obj);\n\tlist_del(&obj->st_link);\n\ti915_gem_object_put(obj);\n}\n\nstatic bool is_contiguous(struct drm_i915_gem_object *obj)\n{\n\tstruct scatterlist *sg;\n\tdma_addr_t addr = -1;\n\n\tfor (sg = obj->mm.pages->sgl; sg; sg = sg_next(sg)) {\n\t\tif (addr != -1 && sg_dma_address(sg) != addr)\n\t\t\treturn false;\n\n\t\taddr = sg_dma_address(sg) + sg_dma_len(sg);\n\t}\n\n\treturn true;\n}\n\nstatic int igt_mock_reserve(void *arg)\n{\n\tstruct intel_memory_region *mem = arg;\n\tstruct drm_i915_private *i915 = mem->i915;\n\tresource_size_t avail = resource_size(&mem->region);\n\tstruct drm_i915_gem_object *obj;\n\tconst u32 chunk_size = SZ_32M;\n\tu32 i, offset, count, *order;\n\tu64 allocated, cur_avail;\n\tI915_RND_STATE(prng);\n\tLIST_HEAD(objects);\n\tint err = 0;\n\n\tcount = avail / chunk_size;\n\torder = i915_random_order(count, &prng);\n\tif (!order)\n\t\treturn 0;\n\n\tmem = mock_region_create(i915, 0, SZ_2G, I915_GTT_PAGE_SIZE_4K, 0, 0);\n\tif (IS_ERR(mem)) {\n\t\tpr_err(\"failed to create memory region\\n\");\n\t\terr = PTR_ERR(mem);\n\t\tgoto out_free_order;\n\t}\n\n\t \n\tfor (i = 0; i < count; ++i) {\n\t\tu64 start = order[i] * chunk_size;\n\t\tu64 size = i915_prandom_u32_max_state(chunk_size, &prng);\n\n\t\t \n\t\tif (!size)\n\t\t\tcontinue;\n\n\t\tsize = round_up(size, PAGE_SIZE);\n\t\toffset = igt_random_offset(&prng, 0, chunk_size, size,\n\t\t\t\t\t   PAGE_SIZE);\n\n\t\terr = intel_memory_region_reserve(mem, start + offset, size);\n\t\tif (err) {\n\t\t\tpr_err(\"%s failed to reserve range\", __func__);\n\t\t\tgoto out_close;\n\t\t}\n\n\t\t \n\t\tavail -= size;\n\t}\n\n\t \n\tallocated = 0;\n\tcur_avail = avail;\n\tdo {\n\t\tu32 size = i915_prandom_u32_max_state(cur_avail, &prng);\n\n\t\tsize = max_t(u32, round_up(size, PAGE_SIZE), PAGE_SIZE);\n\t\tobj = igt_object_create(mem, &objects, size, 0);\n\t\tif (IS_ERR(obj)) {\n\t\t\tif (PTR_ERR(obj) == -ENXIO)\n\t\t\t\tbreak;\n\n\t\t\terr = PTR_ERR(obj);\n\t\t\tgoto out_close;\n\t\t}\n\t\tcur_avail -= size;\n\t\tallocated += size;\n\t} while (1);\n\n\tif (allocated != avail) {\n\t\tpr_err(\"%s mismatch between allocation and free space\", __func__);\n\t\terr = -EINVAL;\n\t}\n\nout_close:\n\tclose_objects(mem, &objects);\n\tintel_memory_region_destroy(mem);\nout_free_order:\n\tkfree(order);\n\treturn err;\n}\n\nstatic int igt_mock_contiguous(void *arg)\n{\n\tstruct intel_memory_region *mem = arg;\n\tstruct drm_i915_gem_object *obj;\n\tunsigned long n_objects;\n\tLIST_HEAD(objects);\n\tLIST_HEAD(holes);\n\tI915_RND_STATE(prng);\n\tresource_size_t total;\n\tresource_size_t min;\n\tu64 target;\n\tint err = 0;\n\n\ttotal = resource_size(&mem->region);\n\n\t \n\tobj = igt_object_create(mem, &objects, PAGE_SIZE,\n\t\t\t\tI915_BO_ALLOC_CONTIGUOUS);\n\tif (IS_ERR(obj))\n\t\treturn PTR_ERR(obj);\n\n\tif (!is_contiguous(obj)) {\n\t\tpr_err(\"%s min object spans disjoint sg entries\\n\", __func__);\n\t\terr = -EINVAL;\n\t\tgoto err_close_objects;\n\t}\n\n\tigt_object_release(obj);\n\n\t \n\tobj = igt_object_create(mem, &objects, total, I915_BO_ALLOC_CONTIGUOUS);\n\tif (IS_ERR(obj))\n\t\treturn PTR_ERR(obj);\n\n\tif (!is_contiguous(obj)) {\n\t\tpr_err(\"%s max object spans disjoint sg entries\\n\", __func__);\n\t\terr = -EINVAL;\n\t\tgoto err_close_objects;\n\t}\n\n\tigt_object_release(obj);\n\n\t \n\ttarget = i915_prandom_u64_state(&prng);\n\tdiv64_u64_rem(target, total, &target);\n\ttarget = round_up(target, PAGE_SIZE);\n\ttarget = max_t(u64, PAGE_SIZE, target);\n\n\tobj = igt_object_create(mem, &objects, target,\n\t\t\t\tI915_BO_ALLOC_CONTIGUOUS);\n\tif (IS_ERR(obj))\n\t\treturn PTR_ERR(obj);\n\n\tif (obj->base.size != target) {\n\t\tpr_err(\"%s obj->base.size(%zx) != target(%llx)\\n\", __func__,\n\t\t       obj->base.size, target);\n\t\terr = -EINVAL;\n\t\tgoto err_close_objects;\n\t}\n\n\tif (!is_contiguous(obj)) {\n\t\tpr_err(\"%s object spans disjoint sg entries\\n\", __func__);\n\t\terr = -EINVAL;\n\t\tgoto err_close_objects;\n\t}\n\n\tigt_object_release(obj);\n\n\t \n\n\ttarget = SZ_64K;\n\tn_objects = div64_u64(total, target);\n\n\twhile (n_objects--) {\n\t\tstruct list_head *list;\n\n\t\tif (n_objects % 2)\n\t\t\tlist = &holes;\n\t\telse\n\t\t\tlist = &objects;\n\n\t\tobj = igt_object_create(mem, list, target,\n\t\t\t\t\tI915_BO_ALLOC_CONTIGUOUS);\n\t\tif (IS_ERR(obj)) {\n\t\t\terr = PTR_ERR(obj);\n\t\t\tgoto err_close_objects;\n\t\t}\n\t}\n\n\tclose_objects(mem, &holes);\n\n\tmin = target;\n\ttarget = total >> 1;\n\n\t \n\tobj = igt_object_create(mem, &objects, target, 0);\n\tif (IS_ERR(obj)) {\n\t\terr = PTR_ERR(obj);\n\t\tgoto err_close_objects;\n\t}\n\n\tigt_object_release(obj);\n\n\t \n\n\tdo {\n\t\tbool should_fail = target > min;\n\n\t\tobj = igt_object_create(mem, &objects, target,\n\t\t\t\t\tI915_BO_ALLOC_CONTIGUOUS);\n\t\tif (should_fail != IS_ERR(obj)) {\n\t\t\tpr_err(\"%s target allocation(%llx) mismatch\\n\",\n\t\t\t       __func__, target);\n\t\t\terr = -EINVAL;\n\t\t\tgoto err_close_objects;\n\t\t}\n\n\t\ttarget >>= 1;\n\t} while (target >= PAGE_SIZE);\n\nerr_close_objects:\n\tlist_splice_tail(&holes, &objects);\n\tclose_objects(mem, &objects);\n\treturn err;\n}\n\nstatic int igt_mock_splintered_region(void *arg)\n{\n\tstruct intel_memory_region *mem = arg;\n\tstruct drm_i915_private *i915 = mem->i915;\n\tstruct i915_ttm_buddy_resource *res;\n\tstruct drm_i915_gem_object *obj;\n\tstruct drm_buddy *mm;\n\tunsigned int expected_order;\n\tLIST_HEAD(objects);\n\tu64 size;\n\tint err = 0;\n\n\t \n\n\tsize = (SZ_4G - 1) & PAGE_MASK;\n\tmem = mock_region_create(i915, 0, size, PAGE_SIZE, 0, 0);\n\tif (IS_ERR(mem))\n\t\treturn PTR_ERR(mem);\n\n\tobj = igt_object_create(mem, &objects, size, 0);\n\tif (IS_ERR(obj)) {\n\t\terr = PTR_ERR(obj);\n\t\tgoto out_close;\n\t}\n\n\tres = to_ttm_buddy_resource(obj->mm.res);\n\tmm = res->mm;\n\tif (mm->size != size) {\n\t\tpr_err(\"%s size mismatch(%llu != %llu)\\n\",\n\t\t       __func__, mm->size, size);\n\t\terr = -EINVAL;\n\t\tgoto out_put;\n\t}\n\n\texpected_order = get_order(rounddown_pow_of_two(size));\n\tif (mm->max_order != expected_order) {\n\t\tpr_err(\"%s order mismatch(%u != %u)\\n\",\n\t\t       __func__, mm->max_order, expected_order);\n\t\terr = -EINVAL;\n\t\tgoto out_put;\n\t}\n\n\tclose_objects(mem, &objects);\n\n\t \n\n\tobj = igt_object_create(mem, &objects, size, I915_BO_ALLOC_CONTIGUOUS);\n\tif (!IS_ERR(obj)) {\n\t\tpr_err(\"%s too large contiguous allocation was not rejected\\n\",\n\t\t       __func__);\n\t\terr = -EINVAL;\n\t\tgoto out_close;\n\t}\n\n\tobj = igt_object_create(mem, &objects, rounddown_pow_of_two(size),\n\t\t\t\tI915_BO_ALLOC_CONTIGUOUS);\n\tif (IS_ERR(obj)) {\n\t\tpr_err(\"%s largest possible contiguous allocation failed\\n\",\n\t\t       __func__);\n\t\terr = PTR_ERR(obj);\n\t\tgoto out_close;\n\t}\n\nout_close:\n\tclose_objects(mem, &objects);\nout_put:\n\tintel_memory_region_destroy(mem);\n\treturn err;\n}\n\n#ifndef SZ_8G\n#define SZ_8G BIT_ULL(33)\n#endif\n\nstatic int igt_mock_max_segment(void *arg)\n{\n\tstruct intel_memory_region *mem = arg;\n\tstruct drm_i915_private *i915 = mem->i915;\n\tstruct i915_ttm_buddy_resource *res;\n\tstruct drm_i915_gem_object *obj;\n\tstruct drm_buddy_block *block;\n\tstruct drm_buddy *mm;\n\tstruct list_head *blocks;\n\tstruct scatterlist *sg;\n\tI915_RND_STATE(prng);\n\tLIST_HEAD(objects);\n\tunsigned int max_segment;\n\tunsigned int ps;\n\tu64 size;\n\tint err = 0;\n\n\t \n\n\tsize = SZ_8G;\n\tps = PAGE_SIZE;\n\tif (i915_prandom_u64_state(&prng) & 1)\n\t\tps = SZ_64K;  \n\n\tmax_segment = round_down(UINT_MAX, ps);\n\n\tmem = mock_region_create(i915, 0, size, ps, 0, 0);\n\tif (IS_ERR(mem))\n\t\treturn PTR_ERR(mem);\n\n\tobj = igt_object_create(mem, &objects, size, 0);\n\tif (IS_ERR(obj)) {\n\t\terr = PTR_ERR(obj);\n\t\tgoto out_put;\n\t}\n\n\tres = to_ttm_buddy_resource(obj->mm.res);\n\tblocks = &res->blocks;\n\tmm = res->mm;\n\tsize = 0;\n\tlist_for_each_entry(block, blocks, link) {\n\t\tif (drm_buddy_block_size(mm, block) > size)\n\t\t\tsize = drm_buddy_block_size(mm, block);\n\t}\n\tif (size < max_segment) {\n\t\tpr_err(\"%s: Failed to create a huge contiguous block [> %u], largest block %lld\\n\",\n\t\t       __func__, max_segment, size);\n\t\terr = -EINVAL;\n\t\tgoto out_close;\n\t}\n\n\tfor (sg = obj->mm.pages->sgl; sg; sg = sg_next(sg)) {\n\t\tdma_addr_t daddr = sg_dma_address(sg);\n\n\t\tif (sg->length > max_segment) {\n\t\t\tpr_err(\"%s: Created an oversized scatterlist entry, %u > %u\\n\",\n\t\t\t       __func__, sg->length, max_segment);\n\t\t\terr = -EINVAL;\n\t\t\tgoto out_close;\n\t\t}\n\n\t\tif (!IS_ALIGNED(daddr, ps)) {\n\t\t\tpr_err(\"%s: Created an unaligned scatterlist entry, addr=%pa, ps=%u\\n\",\n\t\t\t       __func__,  &daddr, ps);\n\t\t\terr = -EINVAL;\n\t\t\tgoto out_close;\n\t\t}\n\t}\n\nout_close:\n\tclose_objects(mem, &objects);\nout_put:\n\tintel_memory_region_destroy(mem);\n\treturn err;\n}\n\nstatic u64 igt_object_mappable_total(struct drm_i915_gem_object *obj)\n{\n\tstruct intel_memory_region *mr = obj->mm.region;\n\tstruct i915_ttm_buddy_resource *bman_res =\n\t\tto_ttm_buddy_resource(obj->mm.res);\n\tstruct drm_buddy *mm = bman_res->mm;\n\tstruct drm_buddy_block *block;\n\tu64 total;\n\n\ttotal = 0;\n\tlist_for_each_entry(block, &bman_res->blocks, link) {\n\t\tu64 start = drm_buddy_block_offset(block);\n\t\tu64 end = start + drm_buddy_block_size(mm, block);\n\n\t\tif (start < mr->io_size)\n\t\t\ttotal += min_t(u64, end, mr->io_size) - start;\n\t}\n\n\treturn total;\n}\n\nstatic int igt_mock_io_size(void *arg)\n{\n\tstruct intel_memory_region *mr = arg;\n\tstruct drm_i915_private *i915 = mr->i915;\n\tstruct drm_i915_gem_object *obj;\n\tu64 mappable_theft_total;\n\tu64 io_size;\n\tu64 total;\n\tu64 ps;\n\tu64 rem;\n\tu64 size;\n\tI915_RND_STATE(prng);\n\tLIST_HEAD(objects);\n\tint err = 0;\n\n\tps = SZ_4K;\n\tif (i915_prandom_u64_state(&prng) & 1)\n\t\tps = SZ_64K;  \n\n\tdiv64_u64_rem(i915_prandom_u64_state(&prng), SZ_8G, &total);\n\ttotal = round_down(total, ps);\n\ttotal = max_t(u64, total, SZ_1G);\n\n\tdiv64_u64_rem(i915_prandom_u64_state(&prng), total - ps, &io_size);\n\tio_size = round_down(io_size, ps);\n\tio_size = max_t(u64, io_size, SZ_256M);  \n\n\tpr_info(\"%s with ps=%llx, io_size=%llx, total=%llx\\n\",\n\t\t__func__, ps, io_size, total);\n\n\tmr = mock_region_create(i915, 0, total, ps, 0, io_size);\n\tif (IS_ERR(mr)) {\n\t\terr = PTR_ERR(mr);\n\t\tgoto out_err;\n\t}\n\n\tmappable_theft_total = 0;\n\trem = total - io_size;\n\tdo {\n\t\tdiv64_u64_rem(i915_prandom_u64_state(&prng), rem, &size);\n\t\tsize = round_down(size, ps);\n\t\tsize = max(size, ps);\n\n\t\tobj = igt_object_create(mr, &objects, size,\n\t\t\t\t\tI915_BO_ALLOC_GPU_ONLY);\n\t\tif (IS_ERR(obj)) {\n\t\t\tpr_err(\"%s TOPDOWN failed with rem=%llx, size=%llx\\n\",\n\t\t\t       __func__, rem, size);\n\t\t\terr = PTR_ERR(obj);\n\t\t\tgoto out_close;\n\t\t}\n\n\t\tmappable_theft_total += igt_object_mappable_total(obj);\n\t\trem -= size;\n\t} while (rem);\n\n\tpr_info(\"%s mappable theft=(%lluMiB/%lluMiB), total=%lluMiB\\n\",\n\t\t__func__,\n\t\t(u64)mappable_theft_total >> 20,\n\t\t(u64)io_size >> 20,\n\t\t(u64)total >> 20);\n\n\t \n\tobj = igt_object_create(mr, &objects, io_size,\n\t\t\t\tI915_BO_ALLOC_GPU_ONLY);\n\tif (IS_ERR(obj)) {\n\t\tpr_err(\"%s allocation unexpectedly failed\\n\", __func__);\n\t\terr = PTR_ERR(obj);\n\t\tgoto out_close;\n\t}\n\n\tclose_objects(mr, &objects);\n\n\trem = io_size;\n\tdo {\n\t\tdiv64_u64_rem(i915_prandom_u64_state(&prng), rem, &size);\n\t\tsize = round_down(size, ps);\n\t\tsize = max(size, ps);\n\n\t\tobj = igt_object_create(mr, &objects, size, 0);\n\t\tif (IS_ERR(obj)) {\n\t\t\tpr_err(\"%s MAPPABLE failed with rem=%llx, size=%llx\\n\",\n\t\t\t       __func__, rem, size);\n\t\t\terr = PTR_ERR(obj);\n\t\t\tgoto out_close;\n\t\t}\n\n\t\tif (igt_object_mappable_total(obj) != size) {\n\t\t\tpr_err(\"%s allocation is not mappable(size=%llx)\\n\",\n\t\t\t       __func__, size);\n\t\t\terr = -EINVAL;\n\t\t\tgoto out_close;\n\t\t}\n\t\trem -= size;\n\t} while (rem);\n\n\t \n\tobj = igt_object_create(mr, &objects, ps, 0);\n\tif (!IS_ERR(obj)) {\n\t\tpr_err(\"%s allocation unexpectedly succeeded\\n\", __func__);\n\t\terr = -EINVAL;\n\t\tgoto out_close;\n\t}\n\nout_close:\n\tclose_objects(mr, &objects);\n\tintel_memory_region_destroy(mr);\nout_err:\n\tif (err == -ENOMEM)\n\t\terr = 0;\n\n\treturn err;\n}\n\nstatic int igt_gpu_write_dw(struct intel_context *ce,\n\t\t\t    struct i915_vma *vma,\n\t\t\t    u32 dword,\n\t\t\t    u32 value)\n{\n\treturn igt_gpu_fill_dw(ce, vma, dword * sizeof(u32),\n\t\t\t       vma->size >> PAGE_SHIFT, value);\n}\n\nstatic int igt_cpu_check(struct drm_i915_gem_object *obj, u32 dword, u32 val)\n{\n\tunsigned long n = obj->base.size >> PAGE_SHIFT;\n\tu32 *ptr;\n\tint err;\n\n\terr = i915_gem_object_wait(obj, 0, MAX_SCHEDULE_TIMEOUT);\n\tif (err)\n\t\treturn err;\n\n\tptr = i915_gem_object_pin_map(obj, I915_MAP_WC);\n\tif (IS_ERR(ptr))\n\t\treturn PTR_ERR(ptr);\n\n\tptr += dword;\n\twhile (n--) {\n\t\tif (*ptr != val) {\n\t\t\tpr_err(\"base[%u]=%08x, val=%08x\\n\",\n\t\t\t       dword, *ptr, val);\n\t\t\terr = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\tptr += PAGE_SIZE / sizeof(*ptr);\n\t}\n\n\ti915_gem_object_unpin_map(obj);\n\treturn err;\n}\n\nstatic int igt_gpu_write(struct i915_gem_context *ctx,\n\t\t\t struct drm_i915_gem_object *obj)\n{\n\tstruct i915_gem_engines *engines;\n\tstruct i915_gem_engines_iter it;\n\tstruct i915_address_space *vm;\n\tstruct intel_context *ce;\n\tI915_RND_STATE(prng);\n\tIGT_TIMEOUT(end_time);\n\tunsigned int count;\n\tstruct i915_vma *vma;\n\tint *order;\n\tint i, n;\n\tint err = 0;\n\n\tGEM_BUG_ON(!i915_gem_object_has_pinned_pages(obj));\n\n\tn = 0;\n\tcount = 0;\n\tfor_each_gem_engine(ce, i915_gem_context_lock_engines(ctx), it) {\n\t\tcount++;\n\t\tif (!intel_engine_can_store_dword(ce->engine))\n\t\t\tcontinue;\n\n\t\tvm = ce->vm;\n\t\tn++;\n\t}\n\ti915_gem_context_unlock_engines(ctx);\n\tif (!n)\n\t\treturn 0;\n\n\torder = i915_random_order(count * count, &prng);\n\tif (!order)\n\t\treturn -ENOMEM;\n\n\tvma = i915_vma_instance(obj, vm, NULL);\n\tif (IS_ERR(vma)) {\n\t\terr = PTR_ERR(vma);\n\t\tgoto out_free;\n\t}\n\n\terr = i915_vma_pin(vma, 0, 0, PIN_USER);\n\tif (err)\n\t\tgoto out_free;\n\n\ti = 0;\n\tengines = i915_gem_context_lock_engines(ctx);\n\tdo {\n\t\tu32 rng = prandom_u32_state(&prng);\n\t\tu32 dword = offset_in_page(rng) / 4;\n\n\t\tce = engines->engines[order[i] % engines->num_engines];\n\t\ti = (i + 1) % (count * count);\n\t\tif (!ce || !intel_engine_can_store_dword(ce->engine))\n\t\t\tcontinue;\n\n\t\terr = igt_gpu_write_dw(ce, vma, dword, rng);\n\t\tif (err)\n\t\t\tbreak;\n\n\t\ti915_gem_object_lock(obj, NULL);\n\t\terr = igt_cpu_check(obj, dword, rng);\n\t\ti915_gem_object_unlock(obj);\n\t\tif (err)\n\t\t\tbreak;\n\t} while (!__igt_timeout(end_time, NULL));\n\ti915_gem_context_unlock_engines(ctx);\n\nout_free:\n\tkfree(order);\n\n\tif (err == -ENOMEM)\n\t\terr = 0;\n\n\treturn err;\n}\n\nstatic int igt_lmem_create(void *arg)\n{\n\tstruct drm_i915_private *i915 = arg;\n\tstruct drm_i915_gem_object *obj;\n\tint err = 0;\n\n\tobj = i915_gem_object_create_lmem(i915, PAGE_SIZE, 0);\n\tif (IS_ERR(obj))\n\t\treturn PTR_ERR(obj);\n\n\terr = i915_gem_object_pin_pages_unlocked(obj);\n\tif (err)\n\t\tgoto out_put;\n\n\ti915_gem_object_unpin_pages(obj);\nout_put:\n\ti915_gem_object_put(obj);\n\n\treturn err;\n}\n\nstatic int igt_lmem_create_with_ps(void *arg)\n{\n\tstruct drm_i915_private *i915 = arg;\n\tint err = 0;\n\tu32 ps;\n\n\tfor (ps = PAGE_SIZE; ps <= SZ_1G; ps <<= 1) {\n\t\tstruct drm_i915_gem_object *obj;\n\t\tdma_addr_t daddr;\n\n\t\tobj = __i915_gem_object_create_lmem_with_ps(i915, ps, ps, 0);\n\t\tif (IS_ERR(obj)) {\n\t\t\terr = PTR_ERR(obj);\n\t\t\tif (err == -ENXIO || err == -E2BIG) {\n\t\t\t\tpr_info(\"%s not enough lmem for ps(%u) err=%d\\n\",\n\t\t\t\t\t__func__, ps, err);\n\t\t\t\terr = 0;\n\t\t\t}\n\n\t\t\tbreak;\n\t\t}\n\n\t\tif (obj->base.size != ps) {\n\t\t\tpr_err(\"%s size(%zu) != ps(%u)\\n\",\n\t\t\t       __func__, obj->base.size, ps);\n\t\t\terr = -EINVAL;\n\t\t\tgoto out_put;\n\t\t}\n\n\t\ti915_gem_object_lock(obj, NULL);\n\t\terr = i915_gem_object_pin_pages(obj);\n\t\tif (err) {\n\t\t\tif (err == -ENXIO || err == -E2BIG || err == -ENOMEM) {\n\t\t\t\tpr_info(\"%s not enough lmem for ps(%u) err=%d\\n\",\n\t\t\t\t\t__func__, ps, err);\n\t\t\t\terr = 0;\n\t\t\t}\n\t\t\tgoto out_put;\n\t\t}\n\n\t\tdaddr = i915_gem_object_get_dma_address(obj, 0);\n\t\tif (!IS_ALIGNED(daddr, ps)) {\n\t\t\tpr_err(\"%s daddr(%pa) not aligned with ps(%u)\\n\",\n\t\t\t       __func__, &daddr, ps);\n\t\t\terr = -EINVAL;\n\t\t\tgoto out_unpin;\n\t\t}\n\nout_unpin:\n\t\ti915_gem_object_unpin_pages(obj);\n\t\t__i915_gem_object_put_pages(obj);\nout_put:\n\t\ti915_gem_object_unlock(obj);\n\t\ti915_gem_object_put(obj);\n\n\t\tif (err)\n\t\t\tbreak;\n\t}\n\n\treturn err;\n}\n\nstatic int igt_lmem_create_cleared_cpu(void *arg)\n{\n\tstruct drm_i915_private *i915 = arg;\n\tI915_RND_STATE(prng);\n\tIGT_TIMEOUT(end_time);\n\tu32 size, i;\n\tint err;\n\n\ti915_gem_drain_freed_objects(i915);\n\n\tsize = max_t(u32, PAGE_SIZE, i915_prandom_u32_max_state(SZ_32M, &prng));\n\tsize = round_up(size, PAGE_SIZE);\n\ti = 0;\n\n\tdo {\n\t\tstruct drm_i915_gem_object *obj;\n\t\tunsigned int flags;\n\t\tu32 dword, val;\n\t\tvoid *vaddr;\n\n\t\t \n\n\t\tflags = I915_BO_ALLOC_CPU_CLEAR;\n\t\tif (i & 1)\n\t\t\tflags = 0;\n\n\t\tobj = i915_gem_object_create_lmem(i915, size, flags);\n\t\tif (IS_ERR(obj))\n\t\t\treturn PTR_ERR(obj);\n\n\t\ti915_gem_object_lock(obj, NULL);\n\t\terr = i915_gem_object_pin_pages(obj);\n\t\tif (err)\n\t\t\tgoto out_put;\n\n\t\tdword = i915_prandom_u32_max_state(PAGE_SIZE / sizeof(u32),\n\t\t\t\t\t\t   &prng);\n\n\t\tif (flags & I915_BO_ALLOC_CPU_CLEAR) {\n\t\t\terr = igt_cpu_check(obj, dword, 0);\n\t\t\tif (err) {\n\t\t\t\tpr_err(\"%s failed with size=%u, flags=%u\\n\",\n\t\t\t\t       __func__, size, flags);\n\t\t\t\tgoto out_unpin;\n\t\t\t}\n\t\t}\n\n\t\tvaddr = i915_gem_object_pin_map(obj, I915_MAP_WC);\n\t\tif (IS_ERR(vaddr)) {\n\t\t\terr = PTR_ERR(vaddr);\n\t\t\tgoto out_unpin;\n\t\t}\n\n\t\tval = prandom_u32_state(&prng);\n\n\t\tmemset32(vaddr, val, obj->base.size / sizeof(u32));\n\n\t\ti915_gem_object_flush_map(obj);\n\t\ti915_gem_object_unpin_map(obj);\nout_unpin:\n\t\ti915_gem_object_unpin_pages(obj);\n\t\t__i915_gem_object_put_pages(obj);\nout_put:\n\t\ti915_gem_object_unlock(obj);\n\t\ti915_gem_object_put(obj);\n\n\t\tif (err)\n\t\t\tbreak;\n\t\t++i;\n\t} while (!__igt_timeout(end_time, NULL));\n\n\tpr_info(\"%s completed (%u) iterations\\n\", __func__, i);\n\n\treturn err;\n}\n\nstatic int igt_lmem_write_gpu(void *arg)\n{\n\tstruct drm_i915_private *i915 = arg;\n\tstruct drm_i915_gem_object *obj;\n\tstruct i915_gem_context *ctx;\n\tstruct file *file;\n\tI915_RND_STATE(prng);\n\tu32 sz;\n\tint err;\n\n\tfile = mock_file(i915);\n\tif (IS_ERR(file))\n\t\treturn PTR_ERR(file);\n\n\tctx = live_context(i915, file);\n\tif (IS_ERR(ctx)) {\n\t\terr = PTR_ERR(ctx);\n\t\tgoto out_file;\n\t}\n\n\tsz = round_up(prandom_u32_state(&prng) % SZ_32M, PAGE_SIZE);\n\n\tobj = i915_gem_object_create_lmem(i915, sz, 0);\n\tif (IS_ERR(obj)) {\n\t\terr = PTR_ERR(obj);\n\t\tgoto out_file;\n\t}\n\n\terr = i915_gem_object_pin_pages_unlocked(obj);\n\tif (err)\n\t\tgoto out_put;\n\n\terr = igt_gpu_write(ctx, obj);\n\tif (err)\n\t\tpr_err(\"igt_gpu_write failed(%d)\\n\", err);\n\n\ti915_gem_object_unpin_pages(obj);\nout_put:\n\ti915_gem_object_put(obj);\nout_file:\n\tfput(file);\n\treturn err;\n}\n\nstatic struct intel_engine_cs *\nrandom_engine_class(struct drm_i915_private *i915,\n\t\t    unsigned int class,\n\t\t    struct rnd_state *prng)\n{\n\tstruct intel_engine_cs *engine;\n\tunsigned int count;\n\n\tcount = 0;\n\tfor (engine = intel_engine_lookup_user(i915, class, 0);\n\t     engine && engine->uabi_class == class;\n\t     engine = rb_entry_safe(rb_next(&engine->uabi_node),\n\t\t\t\t    typeof(*engine), uabi_node))\n\t\tcount++;\n\n\tcount = i915_prandom_u32_max_state(count, prng);\n\treturn intel_engine_lookup_user(i915, class, count);\n}\n\nstatic int igt_lmem_write_cpu(void *arg)\n{\n\tstruct drm_i915_private *i915 = arg;\n\tstruct drm_i915_gem_object *obj;\n\tI915_RND_STATE(prng);\n\tIGT_TIMEOUT(end_time);\n\tu32 bytes[] = {\n\t\t0,  \n\t\tsizeof(u32),\n\t\tsizeof(u64),\n\t\t64,  \n\t\tPAGE_SIZE,\n\t\tPAGE_SIZE - sizeof(u32),\n\t\tPAGE_SIZE - sizeof(u64),\n\t\tPAGE_SIZE - 64,\n\t};\n\tstruct intel_engine_cs *engine;\n\tstruct i915_request *rq;\n\tu32 *vaddr;\n\tu32 sz;\n\tu32 i;\n\tint *order;\n\tint count;\n\tint err;\n\n\tengine = random_engine_class(i915, I915_ENGINE_CLASS_COPY, &prng);\n\tif (!engine)\n\t\treturn 0;\n\n\tpr_info(\"%s: using %s\\n\", __func__, engine->name);\n\n\tsz = round_up(prandom_u32_state(&prng) % SZ_32M, PAGE_SIZE);\n\tsz = max_t(u32, 2 * PAGE_SIZE, sz);\n\n\tobj = i915_gem_object_create_lmem(i915, sz, I915_BO_ALLOC_CONTIGUOUS);\n\tif (IS_ERR(obj))\n\t\treturn PTR_ERR(obj);\n\n\tvaddr = i915_gem_object_pin_map_unlocked(obj, I915_MAP_WC);\n\tif (IS_ERR(vaddr)) {\n\t\terr = PTR_ERR(vaddr);\n\t\tgoto out_put;\n\t}\n\n\ti915_gem_object_lock(obj, NULL);\n\n\terr = dma_resv_reserve_fences(obj->base.resv, 1);\n\tif (err) {\n\t\ti915_gem_object_unlock(obj);\n\t\tgoto out_put;\n\t}\n\n\t \n\tintel_engine_pm_get(engine);\n\terr = intel_context_migrate_clear(engine->gt->migrate.context, NULL,\n\t\t\t\t\t  obj->mm.pages->sgl,\n\t\t\t\t\t  i915_gem_get_pat_index(i915,\n\t\t\t\t\t\t\t\t I915_CACHE_NONE),\n\t\t\t\t\t  true, 0xdeadbeaf, &rq);\n\tif (rq) {\n\t\tdma_resv_add_fence(obj->base.resv, &rq->fence,\n\t\t\t\t   DMA_RESV_USAGE_WRITE);\n\t\ti915_request_put(rq);\n\t}\n\n\tintel_engine_pm_put(engine);\n\tif (!err)\n\t\terr = i915_gem_object_set_to_wc_domain(obj, true);\n\ti915_gem_object_unlock(obj);\n\tif (err)\n\t\tgoto out_unpin;\n\n\tcount = ARRAY_SIZE(bytes);\n\torder = i915_random_order(count * count, &prng);\n\tif (!order) {\n\t\terr = -ENOMEM;\n\t\tgoto out_unpin;\n\t}\n\n\t \n\tbytes[0] = igt_random_offset(&prng, 64, PAGE_SIZE - 64, 0, sizeof(u32));\n\tGEM_BUG_ON(!IS_ALIGNED(bytes[0], sizeof(u32)));\n\n\ti = 0;\n\tdo {\n\t\tu32 offset;\n\t\tu32 align;\n\t\tu32 dword;\n\t\tu32 size;\n\t\tu32 val;\n\n\t\tsize = bytes[order[i] % count];\n\t\ti = (i + 1) % (count * count);\n\n\t\talign = bytes[order[i] % count];\n\t\ti = (i + 1) % (count * count);\n\n\t\talign = max_t(u32, sizeof(u32), rounddown_pow_of_two(align));\n\n\t\toffset = igt_random_offset(&prng, 0, obj->base.size,\n\t\t\t\t\t   size, align);\n\n\t\tval = prandom_u32_state(&prng);\n\t\tmemset32(vaddr + offset / sizeof(u32), val ^ 0xdeadbeaf,\n\t\t\t size / sizeof(u32));\n\n\t\t \n\t\tdword = igt_random_offset(&prng, offset,\n\t\t\t\t\t  offset + size,\n\t\t\t\t\t  sizeof(u32), sizeof(u32));\n\t\tdword /= sizeof(u32);\n\t\tif (vaddr[dword] != (val ^ 0xdeadbeaf)) {\n\t\t\tpr_err(\"%s vaddr[%u]=%u, val=%u, size=%u, align=%u, offset=%u\\n\",\n\t\t\t       __func__, dword, vaddr[dword], val ^ 0xdeadbeaf,\n\t\t\t       size, align, offset);\n\t\t\terr = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\t} while (!__igt_timeout(end_time, NULL));\n\nout_unpin:\n\ti915_gem_object_unpin_map(obj);\nout_put:\n\ti915_gem_object_put(obj);\n\n\treturn err;\n}\n\nstatic const char *repr_type(u32 type)\n{\n\tswitch (type) {\n\tcase I915_MAP_WB:\n\t\treturn \"WB\";\n\tcase I915_MAP_WC:\n\t\treturn \"WC\";\n\t}\n\n\treturn \"\";\n}\n\nstatic struct drm_i915_gem_object *\ncreate_region_for_mapping(struct intel_memory_region *mr, u64 size, u32 type,\n\t\t\t  void **out_addr)\n{\n\tstruct drm_i915_gem_object *obj;\n\tvoid *addr;\n\n\tobj = i915_gem_object_create_region(mr, size, 0, 0);\n\tif (IS_ERR(obj)) {\n\t\tif (PTR_ERR(obj) == -ENOSPC)  \n\t\t\treturn ERR_PTR(-ENODEV);\n\t\treturn obj;\n\t}\n\n\taddr = i915_gem_object_pin_map_unlocked(obj, type);\n\tif (IS_ERR(addr)) {\n\t\ti915_gem_object_put(obj);\n\t\tif (PTR_ERR(addr) == -ENXIO)\n\t\t\treturn ERR_PTR(-ENODEV);\n\t\treturn addr;\n\t}\n\n\t*out_addr = addr;\n\treturn obj;\n}\n\nstatic int wrap_ktime_compare(const void *A, const void *B)\n{\n\tconst ktime_t *a = A, *b = B;\n\n\treturn ktime_compare(*a, *b);\n}\n\nstatic void igt_memcpy_long(void *dst, const void *src, size_t size)\n{\n\tunsigned long *tmp = dst;\n\tconst unsigned long *s = src;\n\n\tsize = size / sizeof(unsigned long);\n\twhile (size--)\n\t\t*tmp++ = *s++;\n}\n\nstatic inline void igt_memcpy(void *dst, const void *src, size_t size)\n{\n\tmemcpy(dst, src, size);\n}\n\nstatic inline void igt_memcpy_from_wc(void *dst, const void *src, size_t size)\n{\n\ti915_memcpy_from_wc(dst, src, size);\n}\n\nstatic int _perf_memcpy(struct intel_memory_region *src_mr,\n\t\t\tstruct intel_memory_region *dst_mr,\n\t\t\tu64 size, u32 src_type, u32 dst_type)\n{\n\tstruct drm_i915_private *i915 = src_mr->i915;\n\tconst struct {\n\t\tconst char *name;\n\t\tvoid (*copy)(void *dst, const void *src, size_t size);\n\t\tbool skip;\n\t} tests[] = {\n\t\t{\n\t\t\t\"memcpy\",\n\t\t\tigt_memcpy,\n\t\t},\n\t\t{\n\t\t\t\"memcpy_long\",\n\t\t\tigt_memcpy_long,\n\t\t},\n\t\t{\n\t\t\t\"memcpy_from_wc\",\n\t\t\tigt_memcpy_from_wc,\n\t\t\t!i915_has_memcpy_from_wc(),\n\t\t},\n\t};\n\tstruct drm_i915_gem_object *src, *dst;\n\tvoid *src_addr, *dst_addr;\n\tint ret = 0;\n\tint i;\n\n\tsrc = create_region_for_mapping(src_mr, size, src_type, &src_addr);\n\tif (IS_ERR(src)) {\n\t\tret = PTR_ERR(src);\n\t\tgoto out;\n\t}\n\n\tdst = create_region_for_mapping(dst_mr, size, dst_type, &dst_addr);\n\tif (IS_ERR(dst)) {\n\t\tret = PTR_ERR(dst);\n\t\tgoto out_unpin_src;\n\t}\n\n\tfor (i = 0; i < ARRAY_SIZE(tests); ++i) {\n\t\tktime_t t[5];\n\t\tint pass;\n\n\t\tif (tests[i].skip)\n\t\t\tcontinue;\n\n\t\tfor (pass = 0; pass < ARRAY_SIZE(t); pass++) {\n\t\t\tktime_t t0, t1;\n\n\t\t\tt0 = ktime_get();\n\n\t\t\ttests[i].copy(dst_addr, src_addr, size);\n\n\t\t\tt1 = ktime_get();\n\t\t\tt[pass] = ktime_sub(t1, t0);\n\t\t}\n\n\t\tsort(t, ARRAY_SIZE(t), sizeof(*t), wrap_ktime_compare, NULL);\n\t\tif (t[0] <= 0) {\n\t\t\t \n\t\t\tpr_debug(\"Skipping %s src(%s, %s) -> dst(%s, %s) %14s %4lluKiB copy, unstable measurement [%lld, %lld]\\n\",\n\t\t\t\t __func__,\n\t\t\t\t src_mr->name, repr_type(src_type),\n\t\t\t\t dst_mr->name, repr_type(dst_type),\n\t\t\t\t tests[i].name, size >> 10,\n\t\t\t\t t[0], t[4]);\n\t\t\tcontinue;\n\t\t}\n\n\t\tpr_info(\"%s src(%s, %s) -> dst(%s, %s) %14s %4llu KiB copy: %5lld MiB/s\\n\",\n\t\t\t__func__,\n\t\t\tsrc_mr->name, repr_type(src_type),\n\t\t\tdst_mr->name, repr_type(dst_type),\n\t\t\ttests[i].name, size >> 10,\n\t\t\tdiv64_u64(mul_u32_u32(4 * size,\n\t\t\t\t\t      1000 * 1000 * 1000),\n\t\t\t\t  t[1] + 2 * t[2] + t[3]) >> 20);\n\n\t\tcond_resched();\n\t}\n\n\ti915_gem_object_unpin_map(dst);\n\ti915_gem_object_put(dst);\nout_unpin_src:\n\ti915_gem_object_unpin_map(src);\n\ti915_gem_object_put(src);\n\n\ti915_gem_drain_freed_objects(i915);\nout:\n\tif (ret == -ENODEV)\n\t\tret = 0;\n\n\treturn ret;\n}\n\nstatic int perf_memcpy(void *arg)\n{\n\tstruct drm_i915_private *i915 = arg;\n\tstatic const u32 types[] = {\n\t\tI915_MAP_WB,\n\t\tI915_MAP_WC,\n\t};\n\tstatic const u32 sizes[] = {\n\t\tSZ_4K,\n\t\tSZ_64K,\n\t\tSZ_4M,\n\t};\n\tstruct intel_memory_region *src_mr, *dst_mr;\n\tint src_id, dst_id;\n\tint i, j, k;\n\tint ret;\n\n\tfor_each_memory_region(src_mr, i915, src_id) {\n\t\tfor_each_memory_region(dst_mr, i915, dst_id) {\n\t\t\tfor (i = 0; i < ARRAY_SIZE(sizes); ++i) {\n\t\t\t\tfor (j = 0; j < ARRAY_SIZE(types); ++j) {\n\t\t\t\t\tfor (k = 0; k < ARRAY_SIZE(types); ++k) {\n\t\t\t\t\t\tret = _perf_memcpy(src_mr,\n\t\t\t\t\t\t\t\t   dst_mr,\n\t\t\t\t\t\t\t\t   sizes[i],\n\t\t\t\t\t\t\t\t   types[j],\n\t\t\t\t\t\t\t\t   types[k]);\n\t\t\t\t\t\tif (ret)\n\t\t\t\t\t\t\treturn ret;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nint intel_memory_region_mock_selftests(void)\n{\n\tstatic const struct i915_subtest tests[] = {\n\t\tSUBTEST(igt_mock_reserve),\n\t\tSUBTEST(igt_mock_fill),\n\t\tSUBTEST(igt_mock_contiguous),\n\t\tSUBTEST(igt_mock_splintered_region),\n\t\tSUBTEST(igt_mock_max_segment),\n\t\tSUBTEST(igt_mock_io_size),\n\t};\n\tstruct intel_memory_region *mem;\n\tstruct drm_i915_private *i915;\n\tint err;\n\n\ti915 = mock_gem_device();\n\tif (!i915)\n\t\treturn -ENOMEM;\n\n\tmem = mock_region_create(i915, 0, SZ_2G, I915_GTT_PAGE_SIZE_4K, 0, 0);\n\tif (IS_ERR(mem)) {\n\t\tpr_err(\"failed to create memory region\\n\");\n\t\terr = PTR_ERR(mem);\n\t\tgoto out_unref;\n\t}\n\n\terr = i915_subtests(tests, mem);\n\n\tintel_memory_region_destroy(mem);\nout_unref:\n\tmock_destroy_device(i915);\n\treturn err;\n}\n\nint intel_memory_region_live_selftests(struct drm_i915_private *i915)\n{\n\tstatic const struct i915_subtest tests[] = {\n\t\tSUBTEST(igt_lmem_create),\n\t\tSUBTEST(igt_lmem_create_with_ps),\n\t\tSUBTEST(igt_lmem_create_cleared_cpu),\n\t\tSUBTEST(igt_lmem_write_cpu),\n\t\tSUBTEST(igt_lmem_write_gpu),\n\t};\n\n\tif (!HAS_LMEM(i915)) {\n\t\tpr_info(\"device lacks LMEM support, skipping\\n\");\n\t\treturn 0;\n\t}\n\n\tif (intel_gt_is_wedged(to_gt(i915)))\n\t\treturn 0;\n\n\treturn i915_live_subtests(tests, i915);\n}\n\nint intel_memory_region_perf_selftests(struct drm_i915_private *i915)\n{\n\tstatic const struct i915_subtest tests[] = {\n\t\tSUBTEST(perf_memcpy),\n\t};\n\n\tif (intel_gt_is_wedged(to_gt(i915)))\n\t\treturn 0;\n\n\treturn i915_live_subtests(tests, i915);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}