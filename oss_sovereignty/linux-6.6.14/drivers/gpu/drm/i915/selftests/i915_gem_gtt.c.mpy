{
  "module_name": "i915_gem_gtt.c",
  "hash_id": "5544d344437c7c74127212346e447dfc0029b2ccb22606c1cbcd9faf3de7789a",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/i915/selftests/i915_gem_gtt.c",
  "human_readable_source": " \n\n#include <linux/list_sort.h>\n#include <linux/prime_numbers.h>\n\n#include \"gem/i915_gem_context.h\"\n#include \"gem/i915_gem_internal.h\"\n#include \"gem/i915_gem_lmem.h\"\n#include \"gem/i915_gem_region.h\"\n#include \"gem/selftests/mock_context.h\"\n#include \"gt/intel_context.h\"\n#include \"gt/intel_gpu_commands.h\"\n#include \"gt/intel_gtt.h\"\n\n#include \"i915_random.h\"\n#include \"i915_selftest.h\"\n#include \"i915_vma_resource.h\"\n\n#include \"mock_drm.h\"\n#include \"mock_gem_device.h\"\n#include \"mock_gtt.h\"\n#include \"igt_flush_test.h\"\n\nstatic void cleanup_freed_objects(struct drm_i915_private *i915)\n{\n\ti915_gem_drain_freed_objects(i915);\n}\n\nstatic void fake_free_pages(struct drm_i915_gem_object *obj,\n\t\t\t    struct sg_table *pages)\n{\n\tsg_free_table(pages);\n\tkfree(pages);\n}\n\nstatic int fake_get_pages(struct drm_i915_gem_object *obj)\n{\n#define GFP (GFP_KERNEL | __GFP_NOWARN | __GFP_NORETRY)\n#define PFN_BIAS 0x1000\n\tstruct sg_table *pages;\n\tstruct scatterlist *sg;\n\ttypeof(obj->base.size) rem;\n\n\tpages = kmalloc(sizeof(*pages), GFP);\n\tif (!pages)\n\t\treturn -ENOMEM;\n\n\trem = round_up(obj->base.size, BIT(31)) >> 31;\n\t \n\tif (overflows_type(rem, unsigned int)) {\n\t\tkfree(pages);\n\t\treturn -E2BIG;\n\t}\n\n\tif (sg_alloc_table(pages, rem, GFP)) {\n\t\tkfree(pages);\n\t\treturn -ENOMEM;\n\t}\n\n\trem = obj->base.size;\n\tfor (sg = pages->sgl; sg; sg = sg_next(sg)) {\n\t\tunsigned long len = min_t(typeof(rem), rem, BIT(31));\n\n\t\tGEM_BUG_ON(!len);\n\t\tsg_set_page(sg, pfn_to_page(PFN_BIAS), len, 0);\n\t\tsg_dma_address(sg) = page_to_phys(sg_page(sg));\n\t\tsg_dma_len(sg) = len;\n\n\t\trem -= len;\n\t}\n\tGEM_BUG_ON(rem);\n\n\t__i915_gem_object_set_pages(obj, pages);\n\n\treturn 0;\n#undef GFP\n}\n\nstatic void fake_put_pages(struct drm_i915_gem_object *obj,\n\t\t\t   struct sg_table *pages)\n{\n\tfake_free_pages(obj, pages);\n\tobj->mm.dirty = false;\n}\n\nstatic const struct drm_i915_gem_object_ops fake_ops = {\n\t.name = \"fake-gem\",\n\t.flags = I915_GEM_OBJECT_IS_SHRINKABLE,\n\t.get_pages = fake_get_pages,\n\t.put_pages = fake_put_pages,\n};\n\nstatic struct drm_i915_gem_object *\nfake_dma_object(struct drm_i915_private *i915, u64 size)\n{\n\tstatic struct lock_class_key lock_class;\n\tstruct drm_i915_gem_object *obj;\n\n\tGEM_BUG_ON(!size);\n\tGEM_BUG_ON(!IS_ALIGNED(size, I915_GTT_PAGE_SIZE));\n\n\tif (overflows_type(size, obj->base.size))\n\t\treturn ERR_PTR(-E2BIG);\n\n\tobj = i915_gem_object_alloc();\n\tif (!obj)\n\t\tgoto err;\n\n\tdrm_gem_private_object_init(&i915->drm, &obj->base, size);\n\ti915_gem_object_init(obj, &fake_ops, &lock_class, 0);\n\n\ti915_gem_object_set_volatile(obj);\n\n\tobj->write_domain = I915_GEM_DOMAIN_CPU;\n\tobj->read_domains = I915_GEM_DOMAIN_CPU;\n\tobj->pat_index = i915_gem_get_pat_index(i915, I915_CACHE_NONE);\n\n\t \n\tif (i915_gem_object_pin_pages_unlocked(obj))\n\t\tgoto err_obj;\n\n\ti915_gem_object_unpin_pages(obj);\n\treturn obj;\n\nerr_obj:\n\ti915_gem_object_put(obj);\nerr:\n\treturn ERR_PTR(-ENOMEM);\n}\n\nstatic int igt_ppgtt_alloc(void *arg)\n{\n\tstruct drm_i915_private *dev_priv = arg;\n\tstruct i915_ppgtt *ppgtt;\n\tstruct i915_gem_ww_ctx ww;\n\tu64 size, last, limit;\n\tint err = 0;\n\n\t \n\n\tif (!HAS_PPGTT(dev_priv))\n\t\treturn 0;\n\n\tppgtt = i915_ppgtt_create(to_gt(dev_priv), 0);\n\tif (IS_ERR(ppgtt))\n\t\treturn PTR_ERR(ppgtt);\n\n\tif (!ppgtt->vm.allocate_va_range)\n\t\tgoto err_ppgtt_cleanup;\n\n\t \n\tlimit = totalram_pages() << PAGE_SHIFT;\n\tlimit = min(ppgtt->vm.total, limit);\n\n\ti915_gem_ww_ctx_init(&ww, false);\nretry:\n\terr = i915_vm_lock_objects(&ppgtt->vm, &ww);\n\tif (err)\n\t\tgoto err_ppgtt_cleanup;\n\n\t \n\tfor (size = 4096; size <= limit; size <<= 2) {\n\t\tstruct i915_vm_pt_stash stash = {};\n\n\t\terr = i915_vm_alloc_pt_stash(&ppgtt->vm, &stash, size);\n\t\tif (err)\n\t\t\tgoto err_ppgtt_cleanup;\n\n\t\terr = i915_vm_map_pt_stash(&ppgtt->vm, &stash);\n\t\tif (err) {\n\t\t\ti915_vm_free_pt_stash(&ppgtt->vm, &stash);\n\t\t\tgoto err_ppgtt_cleanup;\n\t\t}\n\n\t\tppgtt->vm.allocate_va_range(&ppgtt->vm, &stash, 0, size);\n\t\tcond_resched();\n\n\t\tppgtt->vm.clear_range(&ppgtt->vm, 0, size);\n\n\t\ti915_vm_free_pt_stash(&ppgtt->vm, &stash);\n\t}\n\n\t \n\tfor (last = 0, size = 4096; size <= limit; last = size, size <<= 2) {\n\t\tstruct i915_vm_pt_stash stash = {};\n\n\t\terr = i915_vm_alloc_pt_stash(&ppgtt->vm, &stash, size - last);\n\t\tif (err)\n\t\t\tgoto err_ppgtt_cleanup;\n\n\t\terr = i915_vm_map_pt_stash(&ppgtt->vm, &stash);\n\t\tif (err) {\n\t\t\ti915_vm_free_pt_stash(&ppgtt->vm, &stash);\n\t\t\tgoto err_ppgtt_cleanup;\n\t\t}\n\n\t\tppgtt->vm.allocate_va_range(&ppgtt->vm, &stash,\n\t\t\t\t\t    last, size - last);\n\t\tcond_resched();\n\n\t\ti915_vm_free_pt_stash(&ppgtt->vm, &stash);\n\t}\n\nerr_ppgtt_cleanup:\n\tif (err == -EDEADLK) {\n\t\terr = i915_gem_ww_ctx_backoff(&ww);\n\t\tif (!err)\n\t\t\tgoto retry;\n\t}\n\ti915_gem_ww_ctx_fini(&ww);\n\n\ti915_vm_put(&ppgtt->vm);\n\treturn err;\n}\n\nstatic int lowlevel_hole(struct i915_address_space *vm,\n\t\t\t u64 hole_start, u64 hole_end,\n\t\t\t unsigned long end_time)\n{\n\tconst unsigned int min_alignment =\n\t\ti915_vm_min_alignment(vm, INTEL_MEMORY_SYSTEM);\n\tI915_RND_STATE(seed_prng);\n\tstruct i915_vma_resource *mock_vma_res;\n\tunsigned int size;\n\n\tmock_vma_res = kzalloc(sizeof(*mock_vma_res), GFP_KERNEL);\n\tif (!mock_vma_res)\n\t\treturn -ENOMEM;\n\n\t \n\tfor (size = 12; (hole_end - hole_start) >> size; size++) {\n\t\tI915_RND_SUBSTATE(prng, seed_prng);\n\t\tstruct drm_i915_gem_object *obj;\n\t\tunsigned int *order, count, n;\n\t\tu64 hole_size, aligned_size;\n\n\t\taligned_size = max_t(u32, ilog2(min_alignment), size);\n\t\thole_size = (hole_end - hole_start) >> aligned_size;\n\t\tif (hole_size > KMALLOC_MAX_SIZE / sizeof(u32))\n\t\t\thole_size = KMALLOC_MAX_SIZE / sizeof(u32);\n\t\tcount = hole_size >> 1;\n\t\tif (!count) {\n\t\t\tpr_debug(\"%s: hole is too small [%llx - %llx] >> %d: %lld\\n\",\n\t\t\t\t __func__, hole_start, hole_end, size, hole_size);\n\t\t\tbreak;\n\t\t}\n\n\t\tdo {\n\t\t\torder = i915_random_order(count, &prng);\n\t\t\tif (order)\n\t\t\t\tbreak;\n\t\t} while (count >>= 1);\n\t\tif (!count) {\n\t\t\tkfree(mock_vma_res);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tGEM_BUG_ON(!order);\n\n\t\tGEM_BUG_ON(count * BIT_ULL(aligned_size) > vm->total);\n\t\tGEM_BUG_ON(hole_start + count * BIT_ULL(aligned_size) > hole_end);\n\n\t\t \n\n\t\tobj = fake_dma_object(vm->i915, BIT_ULL(size));\n\t\tif (IS_ERR(obj)) {\n\t\t\tkfree(order);\n\t\t\tbreak;\n\t\t}\n\n\t\tGEM_BUG_ON(obj->base.size != BIT_ULL(size));\n\n\t\tif (i915_gem_object_pin_pages_unlocked(obj)) {\n\t\t\ti915_gem_object_put(obj);\n\t\t\tkfree(order);\n\t\t\tbreak;\n\t\t}\n\n\t\tfor (n = 0; n < count; n++) {\n\t\t\tu64 addr = hole_start + order[n] * BIT_ULL(aligned_size);\n\t\t\tintel_wakeref_t wakeref;\n\n\t\t\tGEM_BUG_ON(addr + BIT_ULL(aligned_size) > vm->total);\n\n\t\t\tif (igt_timeout(end_time,\n\t\t\t\t\t\"%s timed out before %d/%d\\n\",\n\t\t\t\t\t__func__, n, count)) {\n\t\t\t\thole_end = hole_start;  \n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (vm->allocate_va_range) {\n\t\t\t\tstruct i915_vm_pt_stash stash = {};\n\t\t\t\tstruct i915_gem_ww_ctx ww;\n\t\t\t\tint err;\n\n\t\t\t\ti915_gem_ww_ctx_init(&ww, false);\nretry:\n\t\t\t\terr = i915_vm_lock_objects(vm, &ww);\n\t\t\t\tif (err)\n\t\t\t\t\tgoto alloc_vm_end;\n\n\t\t\t\terr = -ENOMEM;\n\t\t\t\tif (i915_vm_alloc_pt_stash(vm, &stash,\n\t\t\t\t\t\t\t   BIT_ULL(size)))\n\t\t\t\t\tgoto alloc_vm_end;\n\n\t\t\t\terr = i915_vm_map_pt_stash(vm, &stash);\n\t\t\t\tif (!err)\n\t\t\t\t\tvm->allocate_va_range(vm, &stash,\n\t\t\t\t\t\t\t      addr, BIT_ULL(size));\n\t\t\t\ti915_vm_free_pt_stash(vm, &stash);\nalloc_vm_end:\n\t\t\t\tif (err == -EDEADLK) {\n\t\t\t\t\terr = i915_gem_ww_ctx_backoff(&ww);\n\t\t\t\t\tif (!err)\n\t\t\t\t\t\tgoto retry;\n\t\t\t\t}\n\t\t\t\ti915_gem_ww_ctx_fini(&ww);\n\n\t\t\t\tif (err)\n\t\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tmock_vma_res->bi.pages = obj->mm.pages;\n\t\t\tmock_vma_res->node_size = BIT_ULL(aligned_size);\n\t\t\tmock_vma_res->start = addr;\n\n\t\t\twith_intel_runtime_pm(vm->gt->uncore->rpm, wakeref)\n\t\t\t  vm->insert_entries(vm, mock_vma_res,\n\t\t\t\t\t     i915_gem_get_pat_index(vm->i915,\n\t\t\t\t\t\t\t\t    I915_CACHE_NONE),\n\t\t\t\t\t     0);\n\t\t}\n\t\tcount = n;\n\n\t\ti915_random_reorder(order, count, &prng);\n\t\tfor (n = 0; n < count; n++) {\n\t\t\tu64 addr = hole_start + order[n] * BIT_ULL(aligned_size);\n\t\t\tintel_wakeref_t wakeref;\n\n\t\t\tGEM_BUG_ON(addr + BIT_ULL(size) > vm->total);\n\t\t\twith_intel_runtime_pm(vm->gt->uncore->rpm, wakeref)\n\t\t\t\tvm->clear_range(vm, addr, BIT_ULL(size));\n\t\t}\n\n\t\ti915_gem_object_unpin_pages(obj);\n\t\ti915_gem_object_put(obj);\n\n\t\tkfree(order);\n\n\t\tcleanup_freed_objects(vm->i915);\n\t}\n\n\tkfree(mock_vma_res);\n\treturn 0;\n}\n\nstatic void close_object_list(struct list_head *objects,\n\t\t\t      struct i915_address_space *vm)\n{\n\tstruct drm_i915_gem_object *obj, *on;\n\tint __maybe_unused ignored;\n\n\tlist_for_each_entry_safe(obj, on, objects, st_link) {\n\t\tstruct i915_vma *vma;\n\n\t\tvma = i915_vma_instance(obj, vm, NULL);\n\t\tif (!IS_ERR(vma))\n\t\t\tignored = i915_vma_unbind_unlocked(vma);\n\n\t\tlist_del(&obj->st_link);\n\t\ti915_gem_object_put(obj);\n\t}\n}\n\nstatic int fill_hole(struct i915_address_space *vm,\n\t\t     u64 hole_start, u64 hole_end,\n\t\t     unsigned long end_time)\n{\n\tconst u64 hole_size = hole_end - hole_start;\n\tstruct drm_i915_gem_object *obj;\n\tconst unsigned int min_alignment =\n\t\ti915_vm_min_alignment(vm, INTEL_MEMORY_SYSTEM);\n\tconst unsigned long max_pages =\n\t\tmin_t(u64, ULONG_MAX - 1, (hole_size / 2) >> ilog2(min_alignment));\n\tconst unsigned long max_step = max(int_sqrt(max_pages), 2UL);\n\tunsigned long npages, prime, flags;\n\tstruct i915_vma *vma;\n\tLIST_HEAD(objects);\n\tint err;\n\n\t \n\n\tflags = PIN_OFFSET_FIXED | PIN_USER;\n\tif (i915_is_ggtt(vm))\n\t\tflags |= PIN_GLOBAL;\n\n\tfor_each_prime_number_from(prime, 2, max_step) {\n\t\tfor (npages = 1; npages <= max_pages; npages *= prime) {\n\t\t\tconst u64 full_size = npages << PAGE_SHIFT;\n\t\t\tconst struct {\n\t\t\t\tconst char *name;\n\t\t\t\tu64 offset;\n\t\t\t\tint step;\n\t\t\t} phases[] = {\n\t\t\t\t{ \"top-down\", hole_end, -1, },\n\t\t\t\t{ \"bottom-up\", hole_start, 1, },\n\t\t\t\t{ }\n\t\t\t}, *p;\n\n\t\t\tobj = fake_dma_object(vm->i915, full_size);\n\t\t\tif (IS_ERR(obj))\n\t\t\t\tbreak;\n\n\t\t\tlist_add(&obj->st_link, &objects);\n\n\t\t\t \n\t\t\tfor (p = phases; p->name; p++) {\n\t\t\t\tu64 offset;\n\n\t\t\t\toffset = p->offset;\n\t\t\t\tlist_for_each_entry(obj, &objects, st_link) {\n\t\t\t\t\tu64 aligned_size = round_up(obj->base.size,\n\t\t\t\t\t\t\t\t    min_alignment);\n\n\t\t\t\t\tvma = i915_vma_instance(obj, vm, NULL);\n\t\t\t\t\tif (IS_ERR(vma))\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\tif (p->step < 0) {\n\t\t\t\t\t\tif (offset < hole_start + aligned_size)\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\toffset -= aligned_size;\n\t\t\t\t\t}\n\n\t\t\t\t\terr = i915_vma_pin(vma, 0, 0, offset | flags);\n\t\t\t\t\tif (err) {\n\t\t\t\t\t\tpr_err(\"%s(%s) pin (forward) failed with err=%d on size=%lu pages (prime=%lu), offset=%llx\\n\",\n\t\t\t\t\t\t       __func__, p->name, err, npages, prime, offset);\n\t\t\t\t\t\tgoto err;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (!drm_mm_node_allocated(&vma->node) ||\n\t\t\t\t\t    i915_vma_misplaced(vma, 0, 0, offset | flags)) {\n\t\t\t\t\t\tpr_err(\"%s(%s) (forward) insert failed: vma.node=%llx + %llx [allocated? %d], expected offset %llx\\n\",\n\t\t\t\t\t\t       __func__, p->name, vma->node.start, vma->node.size, drm_mm_node_allocated(&vma->node),\n\t\t\t\t\t\t       offset);\n\t\t\t\t\t\terr = -EINVAL;\n\t\t\t\t\t\tgoto err;\n\t\t\t\t\t}\n\n\t\t\t\t\ti915_vma_unpin(vma);\n\n\t\t\t\t\tif (p->step > 0) {\n\t\t\t\t\t\tif (offset + aligned_size > hole_end)\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\toffset += aligned_size;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\toffset = p->offset;\n\t\t\t\tlist_for_each_entry(obj, &objects, st_link) {\n\t\t\t\t\tu64 aligned_size = round_up(obj->base.size,\n\t\t\t\t\t\t\t\t    min_alignment);\n\n\t\t\t\t\tvma = i915_vma_instance(obj, vm, NULL);\n\t\t\t\t\tif (IS_ERR(vma))\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\tif (p->step < 0) {\n\t\t\t\t\t\tif (offset < hole_start + aligned_size)\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\toffset -= aligned_size;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (!drm_mm_node_allocated(&vma->node) ||\n\t\t\t\t\t    i915_vma_misplaced(vma, 0, 0, offset | flags)) {\n\t\t\t\t\t\tpr_err(\"%s(%s) (forward) moved vma.node=%llx + %llx, expected offset %llx\\n\",\n\t\t\t\t\t\t       __func__, p->name, vma->node.start, vma->node.size,\n\t\t\t\t\t\t       offset);\n\t\t\t\t\t\terr = -EINVAL;\n\t\t\t\t\t\tgoto err;\n\t\t\t\t\t}\n\n\t\t\t\t\terr = i915_vma_unbind_unlocked(vma);\n\t\t\t\t\tif (err) {\n\t\t\t\t\t\tpr_err(\"%s(%s) (forward) unbind of vma.node=%llx + %llx failed with err=%d\\n\",\n\t\t\t\t\t\t       __func__, p->name, vma->node.start, vma->node.size,\n\t\t\t\t\t\t       err);\n\t\t\t\t\t\tgoto err;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (p->step > 0) {\n\t\t\t\t\t\tif (offset + aligned_size > hole_end)\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\toffset += aligned_size;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\toffset = p->offset;\n\t\t\t\tlist_for_each_entry_reverse(obj, &objects, st_link) {\n\t\t\t\t\tu64 aligned_size = round_up(obj->base.size,\n\t\t\t\t\t\t\t\t    min_alignment);\n\n\t\t\t\t\tvma = i915_vma_instance(obj, vm, NULL);\n\t\t\t\t\tif (IS_ERR(vma))\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\tif (p->step < 0) {\n\t\t\t\t\t\tif (offset < hole_start + aligned_size)\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\toffset -= aligned_size;\n\t\t\t\t\t}\n\n\t\t\t\t\terr = i915_vma_pin(vma, 0, 0, offset | flags);\n\t\t\t\t\tif (err) {\n\t\t\t\t\t\tpr_err(\"%s(%s) pin (backward) failed with err=%d on size=%lu pages (prime=%lu), offset=%llx\\n\",\n\t\t\t\t\t\t       __func__, p->name, err, npages, prime, offset);\n\t\t\t\t\t\tgoto err;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (!drm_mm_node_allocated(&vma->node) ||\n\t\t\t\t\t    i915_vma_misplaced(vma, 0, 0, offset | flags)) {\n\t\t\t\t\t\tpr_err(\"%s(%s) (backward) insert failed: vma.node=%llx + %llx [allocated? %d], expected offset %llx\\n\",\n\t\t\t\t\t\t       __func__, p->name, vma->node.start, vma->node.size, drm_mm_node_allocated(&vma->node),\n\t\t\t\t\t\t       offset);\n\t\t\t\t\t\terr = -EINVAL;\n\t\t\t\t\t\tgoto err;\n\t\t\t\t\t}\n\n\t\t\t\t\ti915_vma_unpin(vma);\n\n\t\t\t\t\tif (p->step > 0) {\n\t\t\t\t\t\tif (offset + aligned_size > hole_end)\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\toffset += aligned_size;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\toffset = p->offset;\n\t\t\t\tlist_for_each_entry_reverse(obj, &objects, st_link) {\n\t\t\t\t\tu64 aligned_size = round_up(obj->base.size,\n\t\t\t\t\t\t\t\t    min_alignment);\n\n\t\t\t\t\tvma = i915_vma_instance(obj, vm, NULL);\n\t\t\t\t\tif (IS_ERR(vma))\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\tif (p->step < 0) {\n\t\t\t\t\t\tif (offset < hole_start + aligned_size)\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\toffset -= aligned_size;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (!drm_mm_node_allocated(&vma->node) ||\n\t\t\t\t\t    i915_vma_misplaced(vma, 0, 0, offset | flags)) {\n\t\t\t\t\t\tpr_err(\"%s(%s) (backward) moved vma.node=%llx + %llx [allocated? %d], expected offset %llx\\n\",\n\t\t\t\t\t\t       __func__, p->name, vma->node.start, vma->node.size, drm_mm_node_allocated(&vma->node),\n\t\t\t\t\t\t       offset);\n\t\t\t\t\t\terr = -EINVAL;\n\t\t\t\t\t\tgoto err;\n\t\t\t\t\t}\n\n\t\t\t\t\terr = i915_vma_unbind_unlocked(vma);\n\t\t\t\t\tif (err) {\n\t\t\t\t\t\tpr_err(\"%s(%s) (backward) unbind of vma.node=%llx + %llx failed with err=%d\\n\",\n\t\t\t\t\t\t       __func__, p->name, vma->node.start, vma->node.size,\n\t\t\t\t\t\t       err);\n\t\t\t\t\t\tgoto err;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (p->step > 0) {\n\t\t\t\t\t\tif (offset + aligned_size > hole_end)\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\toffset += aligned_size;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (igt_timeout(end_time, \"%s timed out (npages=%lu, prime=%lu)\\n\",\n\t\t\t\t\t__func__, npages, prime)) {\n\t\t\t\terr = -EINTR;\n\t\t\t\tgoto err;\n\t\t\t}\n\t\t}\n\n\t\tclose_object_list(&objects, vm);\n\t\tcleanup_freed_objects(vm->i915);\n\t}\n\n\treturn 0;\n\nerr:\n\tclose_object_list(&objects, vm);\n\treturn err;\n}\n\nstatic int walk_hole(struct i915_address_space *vm,\n\t\t     u64 hole_start, u64 hole_end,\n\t\t     unsigned long end_time)\n{\n\tconst u64 hole_size = hole_end - hole_start;\n\tconst unsigned long max_pages =\n\t\tmin_t(u64, ULONG_MAX - 1, hole_size >> PAGE_SHIFT);\n\tunsigned long min_alignment;\n\tunsigned long flags;\n\tu64 size;\n\n\t \n\n\tflags = PIN_OFFSET_FIXED | PIN_USER;\n\tif (i915_is_ggtt(vm))\n\t\tflags |= PIN_GLOBAL;\n\n\tmin_alignment = i915_vm_min_alignment(vm, INTEL_MEMORY_SYSTEM);\n\n\tfor_each_prime_number_from(size, 1, max_pages) {\n\t\tstruct drm_i915_gem_object *obj;\n\t\tstruct i915_vma *vma;\n\t\tu64 addr;\n\t\tint err = 0;\n\n\t\tobj = fake_dma_object(vm->i915, size << PAGE_SHIFT);\n\t\tif (IS_ERR(obj))\n\t\t\tbreak;\n\n\t\tvma = i915_vma_instance(obj, vm, NULL);\n\t\tif (IS_ERR(vma)) {\n\t\t\terr = PTR_ERR(vma);\n\t\t\tgoto err_put;\n\t\t}\n\n\t\tfor (addr = hole_start;\n\t\t     addr + obj->base.size < hole_end;\n\t\t     addr += round_up(obj->base.size, min_alignment)) {\n\t\t\terr = i915_vma_pin(vma, 0, 0, addr | flags);\n\t\t\tif (err) {\n\t\t\t\tpr_err(\"%s bind failed at %llx + %llx [hole %llx- %llx] with err=%d\\n\",\n\t\t\t\t       __func__, addr, vma->size,\n\t\t\t\t       hole_start, hole_end, err);\n\t\t\t\tgoto err_put;\n\t\t\t}\n\t\t\ti915_vma_unpin(vma);\n\n\t\t\tif (!drm_mm_node_allocated(&vma->node) ||\n\t\t\t    i915_vma_misplaced(vma, 0, 0, addr | flags)) {\n\t\t\t\tpr_err(\"%s incorrect at %llx + %llx\\n\",\n\t\t\t\t       __func__, addr, vma->size);\n\t\t\t\terr = -EINVAL;\n\t\t\t\tgoto err_put;\n\t\t\t}\n\n\t\t\terr = i915_vma_unbind_unlocked(vma);\n\t\t\tif (err) {\n\t\t\t\tpr_err(\"%s unbind failed at %llx + %llx  with err=%d\\n\",\n\t\t\t\t       __func__, addr, vma->size, err);\n\t\t\t\tgoto err_put;\n\t\t\t}\n\n\t\t\tGEM_BUG_ON(drm_mm_node_allocated(&vma->node));\n\n\t\t\tif (igt_timeout(end_time,\n\t\t\t\t\t\"%s timed out at %llx\\n\",\n\t\t\t\t\t__func__, addr)) {\n\t\t\t\terr = -EINTR;\n\t\t\t\tgoto err_put;\n\t\t\t}\n\t\t}\n\nerr_put:\n\t\ti915_gem_object_put(obj);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\tcleanup_freed_objects(vm->i915);\n\t}\n\n\treturn 0;\n}\n\nstatic int pot_hole(struct i915_address_space *vm,\n\t\t    u64 hole_start, u64 hole_end,\n\t\t    unsigned long end_time)\n{\n\tstruct drm_i915_gem_object *obj;\n\tstruct i915_vma *vma;\n\tunsigned int min_alignment;\n\tunsigned long flags;\n\tunsigned int pot;\n\tint err = 0;\n\n\tflags = PIN_OFFSET_FIXED | PIN_USER;\n\tif (i915_is_ggtt(vm))\n\t\tflags |= PIN_GLOBAL;\n\n\tmin_alignment = i915_vm_min_alignment(vm, INTEL_MEMORY_SYSTEM);\n\n\tobj = i915_gem_object_create_internal(vm->i915, 2 * I915_GTT_PAGE_SIZE);\n\tif (IS_ERR(obj))\n\t\treturn PTR_ERR(obj);\n\n\tvma = i915_vma_instance(obj, vm, NULL);\n\tif (IS_ERR(vma)) {\n\t\terr = PTR_ERR(vma);\n\t\tgoto err_obj;\n\t}\n\n\t \n\tfor (pot = fls64(hole_end - 1) - 1;\n\t     pot > ilog2(2 * min_alignment);\n\t     pot--) {\n\t\tu64 step = BIT_ULL(pot);\n\t\tu64 addr;\n\n\t\tfor (addr = round_up(hole_start + min_alignment, step) - min_alignment;\n\t\t     hole_end > addr && hole_end - addr >= 2 * min_alignment;\n\t\t     addr += step) {\n\t\t\terr = i915_vma_pin(vma, 0, 0, addr | flags);\n\t\t\tif (err) {\n\t\t\t\tpr_err(\"%s failed to pin object at %llx in hole [%llx - %llx], with err=%d\\n\",\n\t\t\t\t       __func__,\n\t\t\t\t       addr,\n\t\t\t\t       hole_start, hole_end,\n\t\t\t\t       err);\n\t\t\t\tgoto err_obj;\n\t\t\t}\n\n\t\t\tif (!drm_mm_node_allocated(&vma->node) ||\n\t\t\t    i915_vma_misplaced(vma, 0, 0, addr | flags)) {\n\t\t\t\tpr_err(\"%s incorrect at %llx + %llx\\n\",\n\t\t\t\t       __func__, addr, vma->size);\n\t\t\t\ti915_vma_unpin(vma);\n\t\t\t\terr = i915_vma_unbind_unlocked(vma);\n\t\t\t\terr = -EINVAL;\n\t\t\t\tgoto err_obj;\n\t\t\t}\n\n\t\t\ti915_vma_unpin(vma);\n\t\t\terr = i915_vma_unbind_unlocked(vma);\n\t\t\tGEM_BUG_ON(err);\n\t\t}\n\n\t\tif (igt_timeout(end_time,\n\t\t\t\t\"%s timed out after %d/%d\\n\",\n\t\t\t\t__func__, pot, fls64(hole_end - 1) - 1)) {\n\t\t\terr = -EINTR;\n\t\t\tgoto err_obj;\n\t\t}\n\t}\n\nerr_obj:\n\ti915_gem_object_put(obj);\n\treturn err;\n}\n\nstatic int drunk_hole(struct i915_address_space *vm,\n\t\t      u64 hole_start, u64 hole_end,\n\t\t      unsigned long end_time)\n{\n\tI915_RND_STATE(prng);\n\tunsigned int min_alignment;\n\tunsigned int size;\n\tunsigned long flags;\n\n\tflags = PIN_OFFSET_FIXED | PIN_USER;\n\tif (i915_is_ggtt(vm))\n\t\tflags |= PIN_GLOBAL;\n\n\tmin_alignment = i915_vm_min_alignment(vm, INTEL_MEMORY_SYSTEM);\n\n\t \n\tfor (size = 12; (hole_end - hole_start) >> size; size++) {\n\t\tstruct drm_i915_gem_object *obj;\n\t\tunsigned int *order, count, n;\n\t\tstruct i915_vma *vma;\n\t\tu64 hole_size, aligned_size;\n\t\tint err = -ENODEV;\n\n\t\taligned_size = max_t(u32, ilog2(min_alignment), size);\n\t\thole_size = (hole_end - hole_start) >> aligned_size;\n\t\tif (hole_size > KMALLOC_MAX_SIZE / sizeof(u32))\n\t\t\thole_size = KMALLOC_MAX_SIZE / sizeof(u32);\n\t\tcount = hole_size >> 1;\n\t\tif (!count) {\n\t\t\tpr_debug(\"%s: hole is too small [%llx - %llx] >> %d: %lld\\n\",\n\t\t\t\t __func__, hole_start, hole_end, size, hole_size);\n\t\t\tbreak;\n\t\t}\n\n\t\tdo {\n\t\t\torder = i915_random_order(count, &prng);\n\t\t\tif (order)\n\t\t\t\tbreak;\n\t\t} while (count >>= 1);\n\t\tif (!count)\n\t\t\treturn -ENOMEM;\n\t\tGEM_BUG_ON(!order);\n\n\t\t \n\n\t\tobj = fake_dma_object(vm->i915, BIT_ULL(size));\n\t\tif (IS_ERR(obj)) {\n\t\t\tkfree(order);\n\t\t\tbreak;\n\t\t}\n\n\t\tvma = i915_vma_instance(obj, vm, NULL);\n\t\tif (IS_ERR(vma)) {\n\t\t\terr = PTR_ERR(vma);\n\t\t\tgoto err_obj;\n\t\t}\n\n\t\tGEM_BUG_ON(vma->size != BIT_ULL(size));\n\n\t\tfor (n = 0; n < count; n++) {\n\t\t\tu64 addr = hole_start + order[n] * BIT_ULL(aligned_size);\n\n\t\t\terr = i915_vma_pin(vma, 0, 0, addr | flags);\n\t\t\tif (err) {\n\t\t\t\tpr_err(\"%s failed to pin object at %llx + %llx in hole [%llx - %llx], with err=%d\\n\",\n\t\t\t\t       __func__,\n\t\t\t\t       addr, BIT_ULL(size),\n\t\t\t\t       hole_start, hole_end,\n\t\t\t\t       err);\n\t\t\t\tgoto err_obj;\n\t\t\t}\n\n\t\t\tif (!drm_mm_node_allocated(&vma->node) ||\n\t\t\t    i915_vma_misplaced(vma, 0, 0, addr | flags)) {\n\t\t\t\tpr_err(\"%s incorrect at %llx + %llx\\n\",\n\t\t\t\t       __func__, addr, BIT_ULL(size));\n\t\t\t\ti915_vma_unpin(vma);\n\t\t\t\terr = i915_vma_unbind_unlocked(vma);\n\t\t\t\terr = -EINVAL;\n\t\t\t\tgoto err_obj;\n\t\t\t}\n\n\t\t\ti915_vma_unpin(vma);\n\t\t\terr = i915_vma_unbind_unlocked(vma);\n\t\t\tGEM_BUG_ON(err);\n\n\t\t\tif (igt_timeout(end_time,\n\t\t\t\t\t\"%s timed out after %d/%d\\n\",\n\t\t\t\t\t__func__, n, count)) {\n\t\t\t\terr = -EINTR;\n\t\t\t\tgoto err_obj;\n\t\t\t}\n\t\t}\n\nerr_obj:\n\t\ti915_gem_object_put(obj);\n\t\tkfree(order);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\tcleanup_freed_objects(vm->i915);\n\t}\n\n\treturn 0;\n}\n\nstatic int __shrink_hole(struct i915_address_space *vm,\n\t\t\t u64 hole_start, u64 hole_end,\n\t\t\t unsigned long end_time)\n{\n\tstruct drm_i915_gem_object *obj;\n\tunsigned long flags = PIN_OFFSET_FIXED | PIN_USER;\n\tunsigned int min_alignment;\n\tunsigned int order = 12;\n\tLIST_HEAD(objects);\n\tint err = 0;\n\tu64 addr;\n\n\tmin_alignment = i915_vm_min_alignment(vm, INTEL_MEMORY_SYSTEM);\n\n\t \n\tfor (addr = hole_start; addr < hole_end; ) {\n\t\tstruct i915_vma *vma;\n\t\tu64 size = BIT_ULL(order++);\n\n\t\tsize = min(size, hole_end - addr);\n\t\tobj = fake_dma_object(vm->i915, size);\n\t\tif (IS_ERR(obj)) {\n\t\t\terr = PTR_ERR(obj);\n\t\t\tbreak;\n\t\t}\n\n\t\tlist_add(&obj->st_link, &objects);\n\n\t\tvma = i915_vma_instance(obj, vm, NULL);\n\t\tif (IS_ERR(vma)) {\n\t\t\terr = PTR_ERR(vma);\n\t\t\tbreak;\n\t\t}\n\n\t\tGEM_BUG_ON(vma->size != size);\n\n\t\terr = i915_vma_pin(vma, 0, 0, addr | flags);\n\t\tif (err) {\n\t\t\tpr_err(\"%s failed to pin object at %llx + %llx in hole [%llx - %llx], with err=%d\\n\",\n\t\t\t       __func__, addr, size, hole_start, hole_end, err);\n\t\t\tbreak;\n\t\t}\n\n\t\tif (!drm_mm_node_allocated(&vma->node) ||\n\t\t    i915_vma_misplaced(vma, 0, 0, addr | flags)) {\n\t\t\tpr_err(\"%s incorrect at %llx + %llx\\n\",\n\t\t\t       __func__, addr, size);\n\t\t\ti915_vma_unpin(vma);\n\t\t\terr = i915_vma_unbind_unlocked(vma);\n\t\t\terr = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\ti915_vma_unpin(vma);\n\t\taddr += round_up(size, min_alignment);\n\n\t\t \n\t\terr = i915_vma_sync(vma);\n\t\tif (err)\n\t\t\tbreak;\n\n\t\tif (igt_timeout(end_time,\n\t\t\t\t\"%s timed out at ofset %llx [%llx - %llx]\\n\",\n\t\t\t\t__func__, addr, hole_start, hole_end)) {\n\t\t\terr = -EINTR;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tclose_object_list(&objects, vm);\n\tcleanup_freed_objects(vm->i915);\n\treturn err;\n}\n\nstatic int shrink_hole(struct i915_address_space *vm,\n\t\t       u64 hole_start, u64 hole_end,\n\t\t       unsigned long end_time)\n{\n\tunsigned long prime;\n\tint err;\n\n\tvm->fault_attr.probability = 999;\n\tatomic_set(&vm->fault_attr.times, -1);\n\n\tfor_each_prime_number_from(prime, 0, ULONG_MAX - 1) {\n\t\tvm->fault_attr.interval = prime;\n\t\terr = __shrink_hole(vm, hole_start, hole_end, end_time);\n\t\tif (err)\n\t\t\tbreak;\n\t}\n\n\tmemset(&vm->fault_attr, 0, sizeof(vm->fault_attr));\n\n\treturn err;\n}\n\nstatic int shrink_boom(struct i915_address_space *vm,\n\t\t       u64 hole_start, u64 hole_end,\n\t\t       unsigned long end_time)\n{\n\tunsigned int sizes[] = { SZ_2M, SZ_1G };\n\tstruct drm_i915_gem_object *purge;\n\tstruct drm_i915_gem_object *explode;\n\tint err;\n\tint i;\n\n\t \n\n\tfor (i = 0; i < ARRAY_SIZE(sizes); ++i) {\n\t\tunsigned int flags = PIN_USER | PIN_OFFSET_FIXED;\n\t\tunsigned int size = sizes[i];\n\t\tstruct i915_vma *vma;\n\n\t\tpurge = fake_dma_object(vm->i915, size);\n\t\tif (IS_ERR(purge))\n\t\t\treturn PTR_ERR(purge);\n\n\t\tvma = i915_vma_instance(purge, vm, NULL);\n\t\tif (IS_ERR(vma)) {\n\t\t\terr = PTR_ERR(vma);\n\t\t\tgoto err_purge;\n\t\t}\n\n\t\terr = i915_vma_pin(vma, 0, 0, flags);\n\t\tif (err)\n\t\t\tgoto err_purge;\n\n\t\t \n\t\ti915_vma_unpin(vma);\n\n\t\texplode = fake_dma_object(vm->i915, size);\n\t\tif (IS_ERR(explode)) {\n\t\t\terr = PTR_ERR(explode);\n\t\t\tgoto err_purge;\n\t\t}\n\n\t\tvm->fault_attr.probability = 100;\n\t\tvm->fault_attr.interval = 1;\n\t\tatomic_set(&vm->fault_attr.times, -1);\n\n\t\tvma = i915_vma_instance(explode, vm, NULL);\n\t\tif (IS_ERR(vma)) {\n\t\t\terr = PTR_ERR(vma);\n\t\t\tgoto err_explode;\n\t\t}\n\n\t\terr = i915_vma_pin(vma, 0, 0, flags | size);\n\t\tif (err)\n\t\t\tgoto err_explode;\n\n\t\ti915_vma_unpin(vma);\n\n\t\ti915_gem_object_put(purge);\n\t\ti915_gem_object_put(explode);\n\n\t\tmemset(&vm->fault_attr, 0, sizeof(vm->fault_attr));\n\t\tcleanup_freed_objects(vm->i915);\n\t}\n\n\treturn 0;\n\nerr_explode:\n\ti915_gem_object_put(explode);\nerr_purge:\n\ti915_gem_object_put(purge);\n\tmemset(&vm->fault_attr, 0, sizeof(vm->fault_attr));\n\treturn err;\n}\n\nstatic int misaligned_case(struct i915_address_space *vm, struct intel_memory_region *mr,\n\t\t\t   u64 addr, u64 size, unsigned long flags)\n{\n\tstruct drm_i915_gem_object *obj;\n\tstruct i915_vma *vma;\n\tint err = 0;\n\tu64 expected_vma_size, expected_node_size;\n\tbool is_stolen = mr->type == INTEL_MEMORY_STOLEN_SYSTEM ||\n\t\t\t mr->type == INTEL_MEMORY_STOLEN_LOCAL;\n\n\tobj = i915_gem_object_create_region(mr, size, 0, I915_BO_ALLOC_GPU_ONLY);\n\tif (IS_ERR(obj)) {\n\t\t \n\t\tif (PTR_ERR(obj) == -ENODEV && is_stolen)\n\t\t\treturn 0;\n\t\treturn PTR_ERR(obj);\n\t}\n\n\tvma = i915_vma_instance(obj, vm, NULL);\n\tif (IS_ERR(vma)) {\n\t\terr = PTR_ERR(vma);\n\t\tgoto err_put;\n\t}\n\n\terr = i915_vma_pin(vma, 0, 0, addr | flags);\n\tif (err)\n\t\tgoto err_put;\n\ti915_vma_unpin(vma);\n\n\tif (!drm_mm_node_allocated(&vma->node)) {\n\t\terr = -EINVAL;\n\t\tgoto err_put;\n\t}\n\n\tif (i915_vma_misplaced(vma, 0, 0, addr | flags)) {\n\t\terr = -EINVAL;\n\t\tgoto err_put;\n\t}\n\n\texpected_vma_size = round_up(size, 1 << (ffs(vma->resource->page_sizes_gtt) - 1));\n\texpected_node_size = expected_vma_size;\n\n\tif (HAS_64K_PAGES(vm->i915) && i915_gem_object_is_lmem(obj)) {\n\t\texpected_vma_size = round_up(size, I915_GTT_PAGE_SIZE_64K);\n\t\texpected_node_size = round_up(size, I915_GTT_PAGE_SIZE_64K);\n\t}\n\n\tif (vma->size != expected_vma_size || vma->node.size != expected_node_size) {\n\t\terr = i915_vma_unbind_unlocked(vma);\n\t\terr = -EBADSLT;\n\t\tgoto err_put;\n\t}\n\n\terr = i915_vma_unbind_unlocked(vma);\n\tif (err)\n\t\tgoto err_put;\n\n\tGEM_BUG_ON(drm_mm_node_allocated(&vma->node));\n\nerr_put:\n\ti915_gem_object_put(obj);\n\tcleanup_freed_objects(vm->i915);\n\treturn err;\n}\n\nstatic int misaligned_pin(struct i915_address_space *vm,\n\t\t\t  u64 hole_start, u64 hole_end,\n\t\t\t  unsigned long end_time)\n{\n\tstruct intel_memory_region *mr;\n\tenum intel_region_id id;\n\tunsigned long flags = PIN_OFFSET_FIXED | PIN_USER;\n\tint err = 0;\n\tu64 hole_size = hole_end - hole_start;\n\n\tif (i915_is_ggtt(vm))\n\t\tflags |= PIN_GLOBAL;\n\n\tfor_each_memory_region(mr, vm->i915, id) {\n\t\tu64 min_alignment = i915_vm_min_alignment(vm, mr->type);\n\t\tu64 size = min_alignment;\n\t\tu64 addr = round_down(hole_start + (hole_size / 2), min_alignment);\n\n\t\t \n\t\tif (hole_size < 3 * min_alignment)\n\t\t\tcontinue;\n\n\t\t \n\t\tif (min_alignment != I915_GTT_PAGE_SIZE_4K) {\n\t\t\terr = misaligned_case(vm, mr, addr + (min_alignment / 2), size, flags);\n\t\t\t \n\t\t\tif (!err)\n\t\t\t\terr = -EBADSLT;\n\t\t\tif (err != -EINVAL)\n\t\t\t\treturn err;\n\t\t}\n\n\t\t \n\t\terr = misaligned_case(vm, mr, addr, PAGE_SIZE, flags);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\t \n\t\terr = misaligned_case(vm, mr, addr, size / 2, flags);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\nstatic int exercise_ppgtt(struct drm_i915_private *dev_priv,\n\t\t\t  int (*func)(struct i915_address_space *vm,\n\t\t\t\t      u64 hole_start, u64 hole_end,\n\t\t\t\t      unsigned long end_time))\n{\n\tstruct i915_ppgtt *ppgtt;\n\tIGT_TIMEOUT(end_time);\n\tstruct file *file;\n\tint err;\n\n\tif (!HAS_FULL_PPGTT(dev_priv))\n\t\treturn 0;\n\n\tfile = mock_file(dev_priv);\n\tif (IS_ERR(file))\n\t\treturn PTR_ERR(file);\n\n\tppgtt = i915_ppgtt_create(to_gt(dev_priv), 0);\n\tif (IS_ERR(ppgtt)) {\n\t\terr = PTR_ERR(ppgtt);\n\t\tgoto out_free;\n\t}\n\tGEM_BUG_ON(offset_in_page(ppgtt->vm.total));\n\tassert_vm_alive(&ppgtt->vm);\n\n\terr = func(&ppgtt->vm, 0, ppgtt->vm.total, end_time);\n\n\ti915_vm_put(&ppgtt->vm);\n\nout_free:\n\tfput(file);\n\treturn err;\n}\n\nstatic int igt_ppgtt_fill(void *arg)\n{\n\treturn exercise_ppgtt(arg, fill_hole);\n}\n\nstatic int igt_ppgtt_walk(void *arg)\n{\n\treturn exercise_ppgtt(arg, walk_hole);\n}\n\nstatic int igt_ppgtt_pot(void *arg)\n{\n\treturn exercise_ppgtt(arg, pot_hole);\n}\n\nstatic int igt_ppgtt_drunk(void *arg)\n{\n\treturn exercise_ppgtt(arg, drunk_hole);\n}\n\nstatic int igt_ppgtt_lowlevel(void *arg)\n{\n\treturn exercise_ppgtt(arg, lowlevel_hole);\n}\n\nstatic int igt_ppgtt_shrink(void *arg)\n{\n\treturn exercise_ppgtt(arg, shrink_hole);\n}\n\nstatic int igt_ppgtt_shrink_boom(void *arg)\n{\n\treturn exercise_ppgtt(arg, shrink_boom);\n}\n\nstatic int igt_ppgtt_misaligned_pin(void *arg)\n{\n\treturn exercise_ppgtt(arg, misaligned_pin);\n}\n\nstatic int sort_holes(void *priv, const struct list_head *A,\n\t\t      const struct list_head *B)\n{\n\tstruct drm_mm_node *a = list_entry(A, typeof(*a), hole_stack);\n\tstruct drm_mm_node *b = list_entry(B, typeof(*b), hole_stack);\n\n\tif (a->start < b->start)\n\t\treturn -1;\n\telse\n\t\treturn 1;\n}\n\nstatic int exercise_ggtt(struct drm_i915_private *i915,\n\t\t\t int (*func)(struct i915_address_space *vm,\n\t\t\t\t     u64 hole_start, u64 hole_end,\n\t\t\t\t     unsigned long end_time))\n{\n\tstruct i915_ggtt *ggtt = to_gt(i915)->ggtt;\n\tu64 hole_start, hole_end, last = 0;\n\tstruct drm_mm_node *node;\n\tIGT_TIMEOUT(end_time);\n\tint err = 0;\n\nrestart:\n\tlist_sort(NULL, &ggtt->vm.mm.hole_stack, sort_holes);\n\tdrm_mm_for_each_hole(node, &ggtt->vm.mm, hole_start, hole_end) {\n\t\tif (hole_start < last)\n\t\t\tcontinue;\n\n\t\tif (ggtt->vm.mm.color_adjust)\n\t\t\tggtt->vm.mm.color_adjust(node, 0,\n\t\t\t\t\t\t &hole_start, &hole_end);\n\t\tif (hole_start >= hole_end)\n\t\t\tcontinue;\n\n\t\terr = func(&ggtt->vm, hole_start, hole_end, end_time);\n\t\tif (err)\n\t\t\tbreak;\n\n\t\t \n\t\tlast = hole_end;\n\t\tgoto restart;\n\t}\n\n\treturn err;\n}\n\nstatic int igt_ggtt_fill(void *arg)\n{\n\treturn exercise_ggtt(arg, fill_hole);\n}\n\nstatic int igt_ggtt_walk(void *arg)\n{\n\treturn exercise_ggtt(arg, walk_hole);\n}\n\nstatic int igt_ggtt_pot(void *arg)\n{\n\treturn exercise_ggtt(arg, pot_hole);\n}\n\nstatic int igt_ggtt_drunk(void *arg)\n{\n\treturn exercise_ggtt(arg, drunk_hole);\n}\n\nstatic int igt_ggtt_lowlevel(void *arg)\n{\n\treturn exercise_ggtt(arg, lowlevel_hole);\n}\n\nstatic int igt_ggtt_misaligned_pin(void *arg)\n{\n\treturn exercise_ggtt(arg, misaligned_pin);\n}\n\nstatic int igt_ggtt_page(void *arg)\n{\n\tconst unsigned int count = PAGE_SIZE/sizeof(u32);\n\tI915_RND_STATE(prng);\n\tstruct drm_i915_private *i915 = arg;\n\tstruct i915_ggtt *ggtt = to_gt(i915)->ggtt;\n\tstruct drm_i915_gem_object *obj;\n\tintel_wakeref_t wakeref;\n\tstruct drm_mm_node tmp;\n\tunsigned int *order, n;\n\tint err;\n\n\tif (!i915_ggtt_has_aperture(ggtt))\n\t\treturn 0;\n\n\tobj = i915_gem_object_create_internal(i915, PAGE_SIZE);\n\tif (IS_ERR(obj))\n\t\treturn PTR_ERR(obj);\n\n\terr = i915_gem_object_pin_pages_unlocked(obj);\n\tif (err)\n\t\tgoto out_free;\n\n\tmemset(&tmp, 0, sizeof(tmp));\n\tmutex_lock(&ggtt->vm.mutex);\n\terr = drm_mm_insert_node_in_range(&ggtt->vm.mm, &tmp,\n\t\t\t\t\t  count * PAGE_SIZE, 0,\n\t\t\t\t\t  I915_COLOR_UNEVICTABLE,\n\t\t\t\t\t  0, ggtt->mappable_end,\n\t\t\t\t\t  DRM_MM_INSERT_LOW);\n\tmutex_unlock(&ggtt->vm.mutex);\n\tif (err)\n\t\tgoto out_unpin;\n\n\twakeref = intel_runtime_pm_get(&i915->runtime_pm);\n\n\tfor (n = 0; n < count; n++) {\n\t\tu64 offset = tmp.start + n * PAGE_SIZE;\n\n\t\tggtt->vm.insert_page(&ggtt->vm,\n\t\t\t\t     i915_gem_object_get_dma_address(obj, 0),\n\t\t\t\t     offset,\n\t\t\t\t     i915_gem_get_pat_index(i915,\n\t\t\t\t\t\t\t    I915_CACHE_NONE),\n\t\t\t\t     0);\n\t}\n\n\torder = i915_random_order(count, &prng);\n\tif (!order) {\n\t\terr = -ENOMEM;\n\t\tgoto out_remove;\n\t}\n\n\tfor (n = 0; n < count; n++) {\n\t\tu64 offset = tmp.start + order[n] * PAGE_SIZE;\n\t\tu32 __iomem *vaddr;\n\n\t\tvaddr = io_mapping_map_atomic_wc(&ggtt->iomap, offset);\n\t\tiowrite32(n, vaddr + n);\n\t\tio_mapping_unmap_atomic(vaddr);\n\t}\n\tintel_gt_flush_ggtt_writes(ggtt->vm.gt);\n\n\ti915_random_reorder(order, count, &prng);\n\tfor (n = 0; n < count; n++) {\n\t\tu64 offset = tmp.start + order[n] * PAGE_SIZE;\n\t\tu32 __iomem *vaddr;\n\t\tu32 val;\n\n\t\tvaddr = io_mapping_map_atomic_wc(&ggtt->iomap, offset);\n\t\tval = ioread32(vaddr + n);\n\t\tio_mapping_unmap_atomic(vaddr);\n\n\t\tif (val != n) {\n\t\t\tpr_err(\"insert page failed: found %d, expected %d\\n\",\n\t\t\t       val, n);\n\t\t\terr = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tkfree(order);\nout_remove:\n\tggtt->vm.clear_range(&ggtt->vm, tmp.start, tmp.size);\n\tintel_runtime_pm_put(&i915->runtime_pm, wakeref);\n\tmutex_lock(&ggtt->vm.mutex);\n\tdrm_mm_remove_node(&tmp);\n\tmutex_unlock(&ggtt->vm.mutex);\nout_unpin:\n\ti915_gem_object_unpin_pages(obj);\nout_free:\n\ti915_gem_object_put(obj);\n\treturn err;\n}\n\nstatic void track_vma_bind(struct i915_vma *vma)\n{\n\tstruct drm_i915_gem_object *obj = vma->obj;\n\n\t__i915_gem_object_pin_pages(obj);\n\n\tGEM_BUG_ON(atomic_read(&vma->pages_count));\n\tatomic_set(&vma->pages_count, I915_VMA_PAGES_ACTIVE);\n\t__i915_gem_object_pin_pages(obj);\n\tvma->pages = obj->mm.pages;\n\tvma->resource->bi.pages = vma->pages;\n\n\tmutex_lock(&vma->vm->mutex);\n\tlist_move_tail(&vma->vm_link, &vma->vm->bound_list);\n\tmutex_unlock(&vma->vm->mutex);\n}\n\nstatic int exercise_mock(struct drm_i915_private *i915,\n\t\t\t int (*func)(struct i915_address_space *vm,\n\t\t\t\t     u64 hole_start, u64 hole_end,\n\t\t\t\t     unsigned long end_time))\n{\n\tconst u64 limit = totalram_pages() << PAGE_SHIFT;\n\tstruct i915_address_space *vm;\n\tstruct i915_gem_context *ctx;\n\tIGT_TIMEOUT(end_time);\n\tint err;\n\n\tctx = mock_context(i915, \"mock\");\n\tif (!ctx)\n\t\treturn -ENOMEM;\n\n\tvm = i915_gem_context_get_eb_vm(ctx);\n\terr = func(vm, 0, min(vm->total, limit), end_time);\n\ti915_vm_put(vm);\n\n\tmock_context_close(ctx);\n\treturn err;\n}\n\nstatic int igt_mock_fill(void *arg)\n{\n\tstruct i915_ggtt *ggtt = arg;\n\n\treturn exercise_mock(ggtt->vm.i915, fill_hole);\n}\n\nstatic int igt_mock_walk(void *arg)\n{\n\tstruct i915_ggtt *ggtt = arg;\n\n\treturn exercise_mock(ggtt->vm.i915, walk_hole);\n}\n\nstatic int igt_mock_pot(void *arg)\n{\n\tstruct i915_ggtt *ggtt = arg;\n\n\treturn exercise_mock(ggtt->vm.i915, pot_hole);\n}\n\nstatic int igt_mock_drunk(void *arg)\n{\n\tstruct i915_ggtt *ggtt = arg;\n\n\treturn exercise_mock(ggtt->vm.i915, drunk_hole);\n}\n\nstatic int reserve_gtt_with_resource(struct i915_vma *vma, u64 offset)\n{\n\tstruct i915_address_space *vm = vma->vm;\n\tstruct i915_vma_resource *vma_res;\n\tstruct drm_i915_gem_object *obj = vma->obj;\n\tint err;\n\n\tvma_res = i915_vma_resource_alloc();\n\tif (IS_ERR(vma_res))\n\t\treturn PTR_ERR(vma_res);\n\n\tmutex_lock(&vm->mutex);\n\terr = i915_gem_gtt_reserve(vm, NULL, &vma->node, obj->base.size,\n\t\t\t\t   offset,\n\t\t\t\t   obj->pat_index,\n\t\t\t\t   0);\n\tif (!err) {\n\t\ti915_vma_resource_init_from_vma(vma_res, vma);\n\t\tvma->resource = vma_res;\n\t} else {\n\t\tkfree(vma_res);\n\t}\n\tmutex_unlock(&vm->mutex);\n\n\treturn err;\n}\n\nstatic int igt_gtt_reserve(void *arg)\n{\n\tstruct i915_ggtt *ggtt = arg;\n\tstruct drm_i915_gem_object *obj, *on;\n\tI915_RND_STATE(prng);\n\tLIST_HEAD(objects);\n\tu64 total;\n\tint err = -ENODEV;\n\n\t \n\n\t \n\tfor (total = 0;\n\t     total + 2 * I915_GTT_PAGE_SIZE <= ggtt->vm.total;\n\t     total += 2 * I915_GTT_PAGE_SIZE) {\n\t\tstruct i915_vma *vma;\n\n\t\tobj = i915_gem_object_create_internal(ggtt->vm.i915,\n\t\t\t\t\t\t      2 * PAGE_SIZE);\n\t\tif (IS_ERR(obj)) {\n\t\t\terr = PTR_ERR(obj);\n\t\t\tgoto out;\n\t\t}\n\n\t\terr = i915_gem_object_pin_pages_unlocked(obj);\n\t\tif (err) {\n\t\t\ti915_gem_object_put(obj);\n\t\t\tgoto out;\n\t\t}\n\n\t\tlist_add(&obj->st_link, &objects);\n\t\tvma = i915_vma_instance(obj, &ggtt->vm, NULL);\n\t\tif (IS_ERR(vma)) {\n\t\t\terr = PTR_ERR(vma);\n\t\t\tgoto out;\n\t\t}\n\n\t\terr = reserve_gtt_with_resource(vma, total);\n\t\tif (err) {\n\t\t\tpr_err(\"i915_gem_gtt_reserve (pass 1) failed at %llu/%llu with err=%d\\n\",\n\t\t\t       total, ggtt->vm.total, err);\n\t\t\tgoto out;\n\t\t}\n\t\ttrack_vma_bind(vma);\n\n\t\tGEM_BUG_ON(!drm_mm_node_allocated(&vma->node));\n\t\tif (vma->node.start != total ||\n\t\t    vma->node.size != 2*I915_GTT_PAGE_SIZE) {\n\t\t\tpr_err(\"i915_gem_gtt_reserve (pass 1) placement failed, found (%llx + %llx), expected (%llx + %llx)\\n\",\n\t\t\t       vma->node.start, vma->node.size,\n\t\t\t       total, 2*I915_GTT_PAGE_SIZE);\n\t\t\terr = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\t \n\tfor (total = I915_GTT_PAGE_SIZE;\n\t     total + 2 * I915_GTT_PAGE_SIZE <= ggtt->vm.total;\n\t     total += 2 * I915_GTT_PAGE_SIZE) {\n\t\tstruct i915_vma *vma;\n\n\t\tobj = i915_gem_object_create_internal(ggtt->vm.i915,\n\t\t\t\t\t\t      2 * PAGE_SIZE);\n\t\tif (IS_ERR(obj)) {\n\t\t\terr = PTR_ERR(obj);\n\t\t\tgoto out;\n\t\t}\n\n\t\terr = i915_gem_object_pin_pages_unlocked(obj);\n\t\tif (err) {\n\t\t\ti915_gem_object_put(obj);\n\t\t\tgoto out;\n\t\t}\n\n\t\tlist_add(&obj->st_link, &objects);\n\n\t\tvma = i915_vma_instance(obj, &ggtt->vm, NULL);\n\t\tif (IS_ERR(vma)) {\n\t\t\terr = PTR_ERR(vma);\n\t\t\tgoto out;\n\t\t}\n\n\t\terr = reserve_gtt_with_resource(vma, total);\n\t\tif (err) {\n\t\t\tpr_err(\"i915_gem_gtt_reserve (pass 2) failed at %llu/%llu with err=%d\\n\",\n\t\t\t       total, ggtt->vm.total, err);\n\t\t\tgoto out;\n\t\t}\n\t\ttrack_vma_bind(vma);\n\n\t\tGEM_BUG_ON(!drm_mm_node_allocated(&vma->node));\n\t\tif (vma->node.start != total ||\n\t\t    vma->node.size != 2*I915_GTT_PAGE_SIZE) {\n\t\t\tpr_err(\"i915_gem_gtt_reserve (pass 2) placement failed, found (%llx + %llx), expected (%llx + %llx)\\n\",\n\t\t\t       vma->node.start, vma->node.size,\n\t\t\t       total, 2*I915_GTT_PAGE_SIZE);\n\t\t\terr = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\t \n\tlist_for_each_entry_safe(obj, on, &objects, st_link) {\n\t\tstruct i915_vma *vma;\n\t\tu64 offset;\n\n\t\tvma = i915_vma_instance(obj, &ggtt->vm, NULL);\n\t\tif (IS_ERR(vma)) {\n\t\t\terr = PTR_ERR(vma);\n\t\t\tgoto out;\n\t\t}\n\n\t\terr = i915_vma_unbind_unlocked(vma);\n\t\tif (err) {\n\t\t\tpr_err(\"i915_vma_unbind failed with err=%d!\\n\", err);\n\t\t\tgoto out;\n\t\t}\n\n\t\toffset = igt_random_offset(&prng,\n\t\t\t\t\t   0, ggtt->vm.total,\n\t\t\t\t\t   2 * I915_GTT_PAGE_SIZE,\n\t\t\t\t\t   I915_GTT_MIN_ALIGNMENT);\n\n\t\terr = reserve_gtt_with_resource(vma, offset);\n\t\tif (err) {\n\t\t\tpr_err(\"i915_gem_gtt_reserve (pass 3) failed at %llu/%llu with err=%d\\n\",\n\t\t\t       total, ggtt->vm.total, err);\n\t\t\tgoto out;\n\t\t}\n\t\ttrack_vma_bind(vma);\n\n\t\tGEM_BUG_ON(!drm_mm_node_allocated(&vma->node));\n\t\tif (vma->node.start != offset ||\n\t\t    vma->node.size != 2*I915_GTT_PAGE_SIZE) {\n\t\t\tpr_err(\"i915_gem_gtt_reserve (pass 3) placement failed, found (%llx + %llx), expected (%llx + %llx)\\n\",\n\t\t\t       vma->node.start, vma->node.size,\n\t\t\t       offset, 2*I915_GTT_PAGE_SIZE);\n\t\t\terr = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t}\n\nout:\n\tlist_for_each_entry_safe(obj, on, &objects, st_link) {\n\t\ti915_gem_object_unpin_pages(obj);\n\t\ti915_gem_object_put(obj);\n\t}\n\treturn err;\n}\n\nstatic int insert_gtt_with_resource(struct i915_vma *vma)\n{\n\tstruct i915_address_space *vm = vma->vm;\n\tstruct i915_vma_resource *vma_res;\n\tstruct drm_i915_gem_object *obj = vma->obj;\n\tint err;\n\n\tvma_res = i915_vma_resource_alloc();\n\tif (IS_ERR(vma_res))\n\t\treturn PTR_ERR(vma_res);\n\n\tmutex_lock(&vm->mutex);\n\terr = i915_gem_gtt_insert(vm, NULL, &vma->node, obj->base.size, 0,\n\t\t\t\t  obj->pat_index, 0, vm->total, 0);\n\tif (!err) {\n\t\ti915_vma_resource_init_from_vma(vma_res, vma);\n\t\tvma->resource = vma_res;\n\t} else {\n\t\tkfree(vma_res);\n\t}\n\tmutex_unlock(&vm->mutex);\n\n\treturn err;\n}\n\nstatic int igt_gtt_insert(void *arg)\n{\n\tstruct i915_ggtt *ggtt = arg;\n\tstruct drm_i915_gem_object *obj, *on;\n\tstruct drm_mm_node tmp = {};\n\tconst struct invalid_insert {\n\t\tu64 size;\n\t\tu64 alignment;\n\t\tu64 start, end;\n\t} invalid_insert[] = {\n\t\t{\n\t\t\tggtt->vm.total + I915_GTT_PAGE_SIZE, 0,\n\t\t\t0, ggtt->vm.total,\n\t\t},\n\t\t{\n\t\t\t2*I915_GTT_PAGE_SIZE, 0,\n\t\t\t0, I915_GTT_PAGE_SIZE,\n\t\t},\n\t\t{\n\t\t\t-(u64)I915_GTT_PAGE_SIZE, 0,\n\t\t\t0, 4*I915_GTT_PAGE_SIZE,\n\t\t},\n\t\t{\n\t\t\t-(u64)2*I915_GTT_PAGE_SIZE, 2*I915_GTT_PAGE_SIZE,\n\t\t\t0, 4*I915_GTT_PAGE_SIZE,\n\t\t},\n\t\t{\n\t\t\tI915_GTT_PAGE_SIZE, I915_GTT_MIN_ALIGNMENT << 1,\n\t\t\tI915_GTT_MIN_ALIGNMENT, I915_GTT_MIN_ALIGNMENT << 1,\n\t\t},\n\t\t{}\n\t}, *ii;\n\tLIST_HEAD(objects);\n\tu64 total;\n\tint err = -ENODEV;\n\n\t \n\n\t \n\tfor (ii = invalid_insert; ii->size; ii++) {\n\t\tmutex_lock(&ggtt->vm.mutex);\n\t\terr = i915_gem_gtt_insert(&ggtt->vm, NULL, &tmp,\n\t\t\t\t\t  ii->size, ii->alignment,\n\t\t\t\t\t  I915_COLOR_UNEVICTABLE,\n\t\t\t\t\t  ii->start, ii->end,\n\t\t\t\t\t  0);\n\t\tmutex_unlock(&ggtt->vm.mutex);\n\t\tif (err != -ENOSPC) {\n\t\t\tpr_err(\"Invalid i915_gem_gtt_insert(.size=%llx, .alignment=%llx, .start=%llx, .end=%llx) succeeded (err=%d)\\n\",\n\t\t\t       ii->size, ii->alignment, ii->start, ii->end,\n\t\t\t       err);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\t \n\tfor (total = 0;\n\t     total + I915_GTT_PAGE_SIZE <= ggtt->vm.total;\n\t     total += I915_GTT_PAGE_SIZE) {\n\t\tstruct i915_vma *vma;\n\n\t\tobj = i915_gem_object_create_internal(ggtt->vm.i915,\n\t\t\t\t\t\t      I915_GTT_PAGE_SIZE);\n\t\tif (IS_ERR(obj)) {\n\t\t\terr = PTR_ERR(obj);\n\t\t\tgoto out;\n\t\t}\n\n\t\terr = i915_gem_object_pin_pages_unlocked(obj);\n\t\tif (err) {\n\t\t\ti915_gem_object_put(obj);\n\t\t\tgoto out;\n\t\t}\n\n\t\tlist_add(&obj->st_link, &objects);\n\n\t\tvma = i915_vma_instance(obj, &ggtt->vm, NULL);\n\t\tif (IS_ERR(vma)) {\n\t\t\terr = PTR_ERR(vma);\n\t\t\tgoto out;\n\t\t}\n\n\t\terr = insert_gtt_with_resource(vma);\n\t\tif (err == -ENOSPC) {\n\t\t\t \n\t\t\ti915_gem_object_put(obj);\n\t\t\tbreak;\n\t\t}\n\t\tif (err) {\n\t\t\tpr_err(\"i915_gem_gtt_insert (pass 1) failed at %llu/%llu with err=%d\\n\",\n\t\t\t       total, ggtt->vm.total, err);\n\t\t\tgoto out;\n\t\t}\n\t\ttrack_vma_bind(vma);\n\t\t__i915_vma_pin(vma);\n\n\t\tGEM_BUG_ON(!drm_mm_node_allocated(&vma->node));\n\t}\n\n\tlist_for_each_entry(obj, &objects, st_link) {\n\t\tstruct i915_vma *vma;\n\n\t\tvma = i915_vma_instance(obj, &ggtt->vm, NULL);\n\t\tif (IS_ERR(vma)) {\n\t\t\terr = PTR_ERR(vma);\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (!drm_mm_node_allocated(&vma->node)) {\n\t\t\tpr_err(\"VMA was unexpectedly evicted!\\n\");\n\t\t\terr = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t\t__i915_vma_unpin(vma);\n\t}\n\n\t \n\tlist_for_each_entry_safe(obj, on, &objects, st_link) {\n\t\tstruct i915_vma *vma;\n\t\tu64 offset;\n\n\t\tvma = i915_vma_instance(obj, &ggtt->vm, NULL);\n\t\tif (IS_ERR(vma)) {\n\t\t\terr = PTR_ERR(vma);\n\t\t\tgoto out;\n\t\t}\n\n\t\tGEM_BUG_ON(!drm_mm_node_allocated(&vma->node));\n\t\toffset = vma->node.start;\n\n\t\terr = i915_vma_unbind_unlocked(vma);\n\t\tif (err) {\n\t\t\tpr_err(\"i915_vma_unbind failed with err=%d!\\n\", err);\n\t\t\tgoto out;\n\t\t}\n\n\t\terr = insert_gtt_with_resource(vma);\n\t\tif (err) {\n\t\t\tpr_err(\"i915_gem_gtt_insert (pass 2) failed at %llu/%llu with err=%d\\n\",\n\t\t\t       total, ggtt->vm.total, err);\n\t\t\tgoto out;\n\t\t}\n\t\ttrack_vma_bind(vma);\n\n\t\tGEM_BUG_ON(!drm_mm_node_allocated(&vma->node));\n\t\tif (vma->node.start != offset) {\n\t\t\tpr_err(\"i915_gem_gtt_insert did not return node to its previous location (the only hole), expected address %llx, found %llx\\n\",\n\t\t\t       offset, vma->node.start);\n\t\t\terr = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\t \n\tfor (total = 0;\n\t     total + 2 * I915_GTT_PAGE_SIZE <= ggtt->vm.total;\n\t     total += 2 * I915_GTT_PAGE_SIZE) {\n\t\tstruct i915_vma *vma;\n\n\t\tobj = i915_gem_object_create_internal(ggtt->vm.i915,\n\t\t\t\t\t\t      2 * I915_GTT_PAGE_SIZE);\n\t\tif (IS_ERR(obj)) {\n\t\t\terr = PTR_ERR(obj);\n\t\t\tgoto out;\n\t\t}\n\n\t\terr = i915_gem_object_pin_pages_unlocked(obj);\n\t\tif (err) {\n\t\t\ti915_gem_object_put(obj);\n\t\t\tgoto out;\n\t\t}\n\n\t\tlist_add(&obj->st_link, &objects);\n\n\t\tvma = i915_vma_instance(obj, &ggtt->vm, NULL);\n\t\tif (IS_ERR(vma)) {\n\t\t\terr = PTR_ERR(vma);\n\t\t\tgoto out;\n\t\t}\n\n\t\terr = insert_gtt_with_resource(vma);\n\t\tif (err) {\n\t\t\tpr_err(\"i915_gem_gtt_insert (pass 3) failed at %llu/%llu with err=%d\\n\",\n\t\t\t       total, ggtt->vm.total, err);\n\t\t\tgoto out;\n\t\t}\n\t\ttrack_vma_bind(vma);\n\n\t\tGEM_BUG_ON(!drm_mm_node_allocated(&vma->node));\n\t}\n\nout:\n\tlist_for_each_entry_safe(obj, on, &objects, st_link) {\n\t\ti915_gem_object_unpin_pages(obj);\n\t\ti915_gem_object_put(obj);\n\t}\n\treturn err;\n}\n\nint i915_gem_gtt_mock_selftests(void)\n{\n\tstatic const struct i915_subtest tests[] = {\n\t\tSUBTEST(igt_mock_drunk),\n\t\tSUBTEST(igt_mock_walk),\n\t\tSUBTEST(igt_mock_pot),\n\t\tSUBTEST(igt_mock_fill),\n\t\tSUBTEST(igt_gtt_reserve),\n\t\tSUBTEST(igt_gtt_insert),\n\t};\n\tstruct drm_i915_private *i915;\n\tstruct intel_gt *gt;\n\tint err;\n\n\ti915 = mock_gem_device();\n\tif (!i915)\n\t\treturn -ENOMEM;\n\n\t \n\terr = intel_gt_assign_ggtt(to_gt(i915));\n\tif (err)\n\t\tgoto out_put;\n\n\tgt = to_gt(i915);\n\n\tmock_init_ggtt(gt);\n\n\terr = i915_subtests(tests, gt->ggtt);\n\n\tmock_device_flush(i915);\n\ti915_gem_drain_freed_objects(i915);\n\tmock_fini_ggtt(gt->ggtt);\n\nout_put:\n\tmock_destroy_device(i915);\n\treturn err;\n}\n\nint i915_gem_gtt_live_selftests(struct drm_i915_private *i915)\n{\n\tstatic const struct i915_subtest tests[] = {\n\t\tSUBTEST(igt_ppgtt_alloc),\n\t\tSUBTEST(igt_ppgtt_lowlevel),\n\t\tSUBTEST(igt_ppgtt_drunk),\n\t\tSUBTEST(igt_ppgtt_walk),\n\t\tSUBTEST(igt_ppgtt_pot),\n\t\tSUBTEST(igt_ppgtt_fill),\n\t\tSUBTEST(igt_ppgtt_shrink),\n\t\tSUBTEST(igt_ppgtt_shrink_boom),\n\t\tSUBTEST(igt_ppgtt_misaligned_pin),\n\t\tSUBTEST(igt_ggtt_lowlevel),\n\t\tSUBTEST(igt_ggtt_drunk),\n\t\tSUBTEST(igt_ggtt_walk),\n\t\tSUBTEST(igt_ggtt_pot),\n\t\tSUBTEST(igt_ggtt_fill),\n\t\tSUBTEST(igt_ggtt_page),\n\t\tSUBTEST(igt_ggtt_misaligned_pin),\n\t};\n\n\tGEM_BUG_ON(offset_in_page(to_gt(i915)->ggtt->vm.total));\n\n\treturn i915_live_subtests(tests, i915);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}