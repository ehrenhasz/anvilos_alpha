{
  "module_name": "i915_sw_fence.c",
  "hash_id": "7d4854487640777929b8217cc0f5ac6a58cfaa1dd00cfb8e97f45a147593d222",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/i915/selftests/i915_sw_fence.c",
  "human_readable_source": " \n\n#include <linux/completion.h>\n#include <linux/delay.h>\n#include <linux/prime_numbers.h>\n\n#include \"../i915_selftest.h\"\n\nstatic int\nfence_notify(struct i915_sw_fence *fence, enum i915_sw_fence_notify state)\n{\n\tswitch (state) {\n\tcase FENCE_COMPLETE:\n\t\tbreak;\n\n\tcase FENCE_FREE:\n\t\t \n\t\tbreak;\n\t}\n\n\treturn NOTIFY_DONE;\n}\n\nstatic struct i915_sw_fence *alloc_fence(void)\n{\n\tstruct i915_sw_fence *fence;\n\n\tfence = kmalloc(sizeof(*fence), GFP_KERNEL);\n\tif (!fence)\n\t\treturn NULL;\n\n\ti915_sw_fence_init(fence, fence_notify);\n\treturn fence;\n}\n\nstatic void free_fence(struct i915_sw_fence *fence)\n{\n\ti915_sw_fence_fini(fence);\n\tkfree(fence);\n}\n\nstatic int __test_self(struct i915_sw_fence *fence)\n{\n\tif (i915_sw_fence_done(fence))\n\t\treturn -EINVAL;\n\n\ti915_sw_fence_commit(fence);\n\tif (!i915_sw_fence_done(fence))\n\t\treturn -EINVAL;\n\n\ti915_sw_fence_wait(fence);\n\tif (!i915_sw_fence_done(fence))\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nstatic int test_self(void *arg)\n{\n\tstruct i915_sw_fence *fence;\n\tint ret;\n\n\t \n\tfence = alloc_fence();\n\tif (!fence)\n\t\treturn -ENOMEM;\n\n\tret = __test_self(fence);\n\n\tfree_fence(fence);\n\treturn ret;\n}\n\nstatic int test_dag(void *arg)\n{\n\tstruct i915_sw_fence *A, *B, *C;\n\tint ret = -EINVAL;\n\n\t \n\tif (!IS_ENABLED(CONFIG_DRM_I915_SW_FENCE_CHECK_DAG))\n\t\treturn 0;\n\n\tA = alloc_fence();\n\tif (!A)\n\t\treturn -ENOMEM;\n\n\tif (i915_sw_fence_await_sw_fence_gfp(A, A, GFP_KERNEL) != -EINVAL) {\n\t\tpr_err(\"recursive cycle not detected (AA)\\n\");\n\t\tgoto err_A;\n\t}\n\n\tB = alloc_fence();\n\tif (!B) {\n\t\tret = -ENOMEM;\n\t\tgoto err_A;\n\t}\n\n\ti915_sw_fence_await_sw_fence_gfp(A, B, GFP_KERNEL);\n\tif (i915_sw_fence_await_sw_fence_gfp(B, A, GFP_KERNEL) != -EINVAL) {\n\t\tpr_err(\"single depth cycle not detected (BAB)\\n\");\n\t\tgoto err_B;\n\t}\n\n\tC = alloc_fence();\n\tif (!C) {\n\t\tret = -ENOMEM;\n\t\tgoto err_B;\n\t}\n\n\tif (i915_sw_fence_await_sw_fence_gfp(B, C, GFP_KERNEL) == -EINVAL) {\n\t\tpr_err(\"invalid cycle detected\\n\");\n\t\tgoto err_C;\n\t}\n\tif (i915_sw_fence_await_sw_fence_gfp(C, B, GFP_KERNEL) != -EINVAL) {\n\t\tpr_err(\"single depth cycle not detected (CBC)\\n\");\n\t\tgoto err_C;\n\t}\n\tif (i915_sw_fence_await_sw_fence_gfp(C, A, GFP_KERNEL) != -EINVAL) {\n\t\tpr_err(\"cycle not detected (BA, CB, AC)\\n\");\n\t\tgoto err_C;\n\t}\n\tif (i915_sw_fence_await_sw_fence_gfp(A, C, GFP_KERNEL) == -EINVAL) {\n\t\tpr_err(\"invalid cycle detected\\n\");\n\t\tgoto err_C;\n\t}\n\n\ti915_sw_fence_commit(A);\n\ti915_sw_fence_commit(B);\n\ti915_sw_fence_commit(C);\n\n\tret = 0;\n\tif (!i915_sw_fence_done(C)) {\n\t\tpr_err(\"fence C not done\\n\");\n\t\tret = -EINVAL;\n\t}\n\tif (!i915_sw_fence_done(B)) {\n\t\tpr_err(\"fence B not done\\n\");\n\t\tret = -EINVAL;\n\t}\n\tif (!i915_sw_fence_done(A)) {\n\t\tpr_err(\"fence A not done\\n\");\n\t\tret = -EINVAL;\n\t}\nerr_C:\n\tfree_fence(C);\nerr_B:\n\tfree_fence(B);\nerr_A:\n\tfree_fence(A);\n\treturn ret;\n}\n\nstatic int test_AB(void *arg)\n{\n\tstruct i915_sw_fence *A, *B;\n\tint ret;\n\n\t \n\tA = alloc_fence();\n\tif (!A)\n\t\treturn -ENOMEM;\n\tB = alloc_fence();\n\tif (!B) {\n\t\tret = -ENOMEM;\n\t\tgoto err_A;\n\t}\n\n\tret = i915_sw_fence_await_sw_fence_gfp(A, B, GFP_KERNEL);\n\tif (ret < 0)\n\t\tgoto err_B;\n\tif (ret == 0) {\n\t\tpr_err(\"Incorrectly reported fence A was complete before await\\n\");\n\t\tret = -EINVAL;\n\t\tgoto err_B;\n\t}\n\n\tret = -EINVAL;\n\ti915_sw_fence_commit(A);\n\tif (i915_sw_fence_done(A))\n\t\tgoto err_B;\n\n\ti915_sw_fence_commit(B);\n\tif (!i915_sw_fence_done(B)) {\n\t\tpr_err(\"Fence B is not done\\n\");\n\t\tgoto err_B;\n\t}\n\n\tif (!i915_sw_fence_done(A)) {\n\t\tpr_err(\"Fence A is not done\\n\");\n\t\tgoto err_B;\n\t}\n\n\tret = 0;\nerr_B:\n\tfree_fence(B);\nerr_A:\n\tfree_fence(A);\n\treturn ret;\n}\n\nstatic int test_ABC(void *arg)\n{\n\tstruct i915_sw_fence *A, *B, *C;\n\tint ret;\n\n\t \n\tA = alloc_fence();\n\tif (!A)\n\t\treturn -ENOMEM;\n\n\tB = alloc_fence();\n\tif (!B) {\n\t\tret = -ENOMEM;\n\t\tgoto err_A;\n\t}\n\n\tC = alloc_fence();\n\tif (!C) {\n\t\tret = -ENOMEM;\n\t\tgoto err_B;\n\t}\n\n\tret = i915_sw_fence_await_sw_fence_gfp(A, B, GFP_KERNEL);\n\tif (ret < 0)\n\t\tgoto err_C;\n\tif (ret == 0) {\n\t\tpr_err(\"Incorrectly reported fence B was complete before await\\n\");\n\t\tgoto err_C;\n\t}\n\n\tret = i915_sw_fence_await_sw_fence_gfp(B, C, GFP_KERNEL);\n\tif (ret < 0)\n\t\tgoto err_C;\n\tif (ret == 0) {\n\t\tpr_err(\"Incorrectly reported fence C was complete before await\\n\");\n\t\tgoto err_C;\n\t}\n\n\tret = -EINVAL;\n\ti915_sw_fence_commit(A);\n\tif (i915_sw_fence_done(A)) {\n\t\tpr_err(\"Fence A completed early\\n\");\n\t\tgoto err_C;\n\t}\n\n\ti915_sw_fence_commit(B);\n\tif (i915_sw_fence_done(B)) {\n\t\tpr_err(\"Fence B completed early\\n\");\n\t\tgoto err_C;\n\t}\n\n\tif (i915_sw_fence_done(A)) {\n\t\tpr_err(\"Fence A completed early (after signaling B)\\n\");\n\t\tgoto err_C;\n\t}\n\n\ti915_sw_fence_commit(C);\n\n\tret = 0;\n\tif (!i915_sw_fence_done(C)) {\n\t\tpr_err(\"Fence C not done\\n\");\n\t\tret = -EINVAL;\n\t}\n\tif (!i915_sw_fence_done(B)) {\n\t\tpr_err(\"Fence B not done\\n\");\n\t\tret = -EINVAL;\n\t}\n\tif (!i915_sw_fence_done(A)) {\n\t\tpr_err(\"Fence A not done\\n\");\n\t\tret = -EINVAL;\n\t}\nerr_C:\n\tfree_fence(C);\nerr_B:\n\tfree_fence(B);\nerr_A:\n\tfree_fence(A);\n\treturn ret;\n}\n\nstatic int test_AB_C(void *arg)\n{\n\tstruct i915_sw_fence *A, *B, *C;\n\tint ret = -EINVAL;\n\n\t \n\tA = alloc_fence();\n\tif (!A)\n\t\treturn -ENOMEM;\n\n\tB = alloc_fence();\n\tif (!B) {\n\t\tret = -ENOMEM;\n\t\tgoto err_A;\n\t}\n\n\tC = alloc_fence();\n\tif (!C) {\n\t\tret = -ENOMEM;\n\t\tgoto err_B;\n\t}\n\n\tret = i915_sw_fence_await_sw_fence_gfp(A, C, GFP_KERNEL);\n\tif (ret < 0)\n\t\tgoto err_C;\n\tif (ret == 0) {\n\t\tret = -EINVAL;\n\t\tgoto err_C;\n\t}\n\n\tret = i915_sw_fence_await_sw_fence_gfp(B, C, GFP_KERNEL);\n\tif (ret < 0)\n\t\tgoto err_C;\n\tif (ret == 0) {\n\t\tret = -EINVAL;\n\t\tgoto err_C;\n\t}\n\n\ti915_sw_fence_commit(A);\n\ti915_sw_fence_commit(B);\n\n\tret = 0;\n\tif (i915_sw_fence_done(A)) {\n\t\tpr_err(\"Fence A completed early\\n\");\n\t\tret = -EINVAL;\n\t}\n\n\tif (i915_sw_fence_done(B)) {\n\t\tpr_err(\"Fence B completed early\\n\");\n\t\tret = -EINVAL;\n\t}\n\n\ti915_sw_fence_commit(C);\n\tif (!i915_sw_fence_done(C)) {\n\t\tpr_err(\"Fence C not done\\n\");\n\t\tret = -EINVAL;\n\t}\n\n\tif (!i915_sw_fence_done(B)) {\n\t\tpr_err(\"Fence B not done\\n\");\n\t\tret = -EINVAL;\n\t}\n\n\tif (!i915_sw_fence_done(A)) {\n\t\tpr_err(\"Fence A not done\\n\");\n\t\tret = -EINVAL;\n\t}\n\nerr_C:\n\tfree_fence(C);\nerr_B:\n\tfree_fence(B);\nerr_A:\n\tfree_fence(A);\n\treturn ret;\n}\n\nstatic int test_C_AB(void *arg)\n{\n\tstruct i915_sw_fence *A, *B, *C;\n\tint ret;\n\n\t \n\tA = alloc_fence();\n\tif (!A)\n\t\treturn -ENOMEM;\n\n\tB = alloc_fence();\n\tif (!B) {\n\t\tret = -ENOMEM;\n\t\tgoto err_A;\n\t}\n\n\tC = alloc_fence();\n\tif (!C) {\n\t\tret = -ENOMEM;\n\t\tgoto err_B;\n\t}\n\n\tret = i915_sw_fence_await_sw_fence_gfp(C, A, GFP_KERNEL);\n\tif (ret < 0)\n\t\tgoto err_C;\n\tif (ret == 0) {\n\t\tret = -EINVAL;\n\t\tgoto err_C;\n\t}\n\n\tret = i915_sw_fence_await_sw_fence_gfp(C, B, GFP_KERNEL);\n\tif (ret < 0)\n\t\tgoto err_C;\n\tif (ret == 0) {\n\t\tret = -EINVAL;\n\t\tgoto err_C;\n\t}\n\n\tret = 0;\n\ti915_sw_fence_commit(C);\n\tif (i915_sw_fence_done(C))\n\t\tret = -EINVAL;\n\n\ti915_sw_fence_commit(A);\n\ti915_sw_fence_commit(B);\n\n\tif (!i915_sw_fence_done(A)) {\n\t\tpr_err(\"Fence A not done\\n\");\n\t\tret = -EINVAL;\n\t}\n\n\tif (!i915_sw_fence_done(B)) {\n\t\tpr_err(\"Fence B not done\\n\");\n\t\tret = -EINVAL;\n\t}\n\n\tif (!i915_sw_fence_done(C)) {\n\t\tpr_err(\"Fence C not done\\n\");\n\t\tret = -EINVAL;\n\t}\n\nerr_C:\n\tfree_fence(C);\nerr_B:\n\tfree_fence(B);\nerr_A:\n\tfree_fence(A);\n\treturn ret;\n}\n\nstatic int test_chain(void *arg)\n{\n\tint nfences = 4096;\n\tstruct i915_sw_fence **fences;\n\tint ret, i;\n\n\t \n\tfences = kmalloc_array(nfences, sizeof(*fences), GFP_KERNEL);\n\tif (!fences)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < nfences; i++) {\n\t\tfences[i] = alloc_fence();\n\t\tif (!fences[i]) {\n\t\t\tnfences = i;\n\t\t\tret = -ENOMEM;\n\t\t\tgoto err;\n\t\t}\n\n\t\tif (i > 0) {\n\t\t\tret = i915_sw_fence_await_sw_fence_gfp(fences[i],\n\t\t\t\t\t\t\t       fences[i - 1],\n\t\t\t\t\t\t\t       GFP_KERNEL);\n\t\t\tif (ret < 0) {\n\t\t\t\tnfences = i + 1;\n\t\t\t\tgoto err;\n\t\t\t}\n\n\t\t\ti915_sw_fence_commit(fences[i]);\n\t\t}\n\t}\n\n\tret = 0;\n\tfor (i = nfences; --i; ) {\n\t\tif (i915_sw_fence_done(fences[i])) {\n\t\t\tif (ret == 0)\n\t\t\t\tpr_err(\"Fence[%d] completed early\\n\", i);\n\t\t\tret = -EINVAL;\n\t\t}\n\t}\n\ti915_sw_fence_commit(fences[0]);\n\tfor (i = 0; ret == 0 && i < nfences; i++) {\n\t\tif (!i915_sw_fence_done(fences[i])) {\n\t\t\tpr_err(\"Fence[%d] is not done\\n\", i);\n\t\t\tret = -EINVAL;\n\t\t}\n\t}\n\nerr:\n\tfor (i = 0; i < nfences; i++)\n\t\tfree_fence(fences[i]);\n\tkfree(fences);\n\treturn ret;\n}\n\nstruct task_ipc {\n\tstruct work_struct work;\n\tstruct completion started;\n\tstruct i915_sw_fence *in, *out;\n\tint value;\n};\n\nstatic void task_ipc(struct work_struct *work)\n{\n\tstruct task_ipc *ipc = container_of(work, typeof(*ipc), work);\n\n\tcomplete(&ipc->started);\n\n\ti915_sw_fence_wait(ipc->in);\n\tsmp_store_mb(ipc->value, 1);\n\ti915_sw_fence_commit(ipc->out);\n}\n\nstatic int test_ipc(void *arg)\n{\n\tstruct task_ipc ipc;\n\tstruct workqueue_struct *wq;\n\tint ret = 0;\n\n\twq = alloc_workqueue(\"i1915-selftest\", 0, 0);\n\tif (wq == NULL)\n\t\treturn -ENOMEM;\n\n\t \n\tipc.in = alloc_fence();\n\tif (!ipc.in) {\n\t\tret = -ENOMEM;\n\t\tgoto err_work;\n\t}\n\tipc.out = alloc_fence();\n\tif (!ipc.out) {\n\t\tret = -ENOMEM;\n\t\tgoto err_in;\n\t}\n\n\t \n\tinit_completion(&ipc.started);\n\n\tipc.value = 0;\n\tINIT_WORK_ONSTACK(&ipc.work, task_ipc);\n\tqueue_work(wq, &ipc.work);\n\n\twait_for_completion(&ipc.started);\n\n\tusleep_range(1000, 2000);\n\tif (READ_ONCE(ipc.value)) {\n\t\tpr_err(\"worker updated value before i915_sw_fence was signaled\\n\");\n\t\tret = -EINVAL;\n\t}\n\n\ti915_sw_fence_commit(ipc.in);\n\ti915_sw_fence_wait(ipc.out);\n\n\tif (!READ_ONCE(ipc.value)) {\n\t\tpr_err(\"worker signaled i915_sw_fence before value was posted\\n\");\n\t\tret = -EINVAL;\n\t}\n\n\tflush_work(&ipc.work);\n\tdestroy_work_on_stack(&ipc.work);\n\tfree_fence(ipc.out);\nerr_in:\n\tfree_fence(ipc.in);\nerr_work:\n\tdestroy_workqueue(wq);\n\n\treturn ret;\n}\n\nstatic int test_timer(void *arg)\n{\n\tunsigned long target, delay;\n\tstruct timed_fence tf;\n\n\tpreempt_disable();\n\ttimed_fence_init(&tf, target = jiffies);\n\tif (!i915_sw_fence_done(&tf.fence)) {\n\t\tpr_err(\"Fence with immediate expiration not signaled\\n\");\n\t\tgoto err;\n\t}\n\tpreempt_enable();\n\ttimed_fence_fini(&tf);\n\n\tfor_each_prime_number(delay, i915_selftest.timeout_jiffies/2) {\n\t\tpreempt_disable();\n\t\ttimed_fence_init(&tf, target = jiffies + delay);\n\t\tif (i915_sw_fence_done(&tf.fence)) {\n\t\t\tpr_err(\"Fence with future expiration (%lu jiffies) already signaled\\n\", delay);\n\t\t\tgoto err;\n\t\t}\n\t\tpreempt_enable();\n\n\t\ti915_sw_fence_wait(&tf.fence);\n\n\t\tpreempt_disable();\n\t\tif (!i915_sw_fence_done(&tf.fence)) {\n\t\t\tpr_err(\"Fence not signaled after wait\\n\");\n\t\t\tgoto err;\n\t\t}\n\t\tif (time_before(jiffies, target)) {\n\t\t\tpr_err(\"Fence signaled too early, target=%lu, now=%lu\\n\",\n\t\t\t       target, jiffies);\n\t\t\tgoto err;\n\t\t}\n\t\tpreempt_enable();\n\t\ttimed_fence_fini(&tf);\n\t}\n\n\treturn 0;\n\nerr:\n\tpreempt_enable();\n\ttimed_fence_fini(&tf);\n\treturn -EINVAL;\n}\n\nstatic const char *mock_name(struct dma_fence *fence)\n{\n\treturn \"mock\";\n}\n\nstatic const struct dma_fence_ops mock_fence_ops = {\n\t.get_driver_name = mock_name,\n\t.get_timeline_name = mock_name,\n};\n\nstatic DEFINE_SPINLOCK(mock_fence_lock);\n\nstatic struct dma_fence *alloc_dma_fence(void)\n{\n\tstruct dma_fence *dma;\n\n\tdma = kmalloc(sizeof(*dma), GFP_KERNEL);\n\tif (dma)\n\t\tdma_fence_init(dma, &mock_fence_ops, &mock_fence_lock, 0, 0);\n\n\treturn dma;\n}\n\nstatic struct i915_sw_fence *\nwrap_dma_fence(struct dma_fence *dma, unsigned long delay)\n{\n\tstruct i915_sw_fence *fence;\n\tint err;\n\n\tfence = alloc_fence();\n\tif (!fence)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\terr = i915_sw_fence_await_dma_fence(fence, dma, delay, GFP_NOWAIT);\n\ti915_sw_fence_commit(fence);\n\tif (err < 0) {\n\t\tfree_fence(fence);\n\t\treturn ERR_PTR(err);\n\t}\n\n\treturn fence;\n}\n\nstatic int test_dma_fence(void *arg)\n{\n\tstruct i915_sw_fence *timeout = NULL, *not = NULL;\n\tunsigned long delay = i915_selftest.timeout_jiffies;\n\tunsigned long end, sleep;\n\tstruct dma_fence *dma;\n\tint err;\n\n\tdma = alloc_dma_fence();\n\tif (!dma)\n\t\treturn -ENOMEM;\n\n\ttimeout = wrap_dma_fence(dma, delay);\n\tif (IS_ERR(timeout)) {\n\t\terr = PTR_ERR(timeout);\n\t\tgoto err;\n\t}\n\n\tnot = wrap_dma_fence(dma, 0);\n\tif (IS_ERR(not)) {\n\t\terr = PTR_ERR(not);\n\t\tgoto err;\n\t}\n\n\terr = -EINVAL;\n\tif (i915_sw_fence_done(timeout) || i915_sw_fence_done(not)) {\n\t\tpr_err(\"Fences immediately signaled\\n\");\n\t\tgoto err;\n\t}\n\n\t \n\tend = round_jiffies_up(jiffies + delay);\n\n\tsleep = jiffies_to_usecs(delay) / 3;\n\tusleep_range(sleep, 2 * sleep);\n\tif (time_after(jiffies, end)) {\n\t\tpr_debug(\"Slept too long, delay=%lu, (target=%lu, now=%lu) skipping\\n\",\n\t\t\t delay, end, jiffies);\n\t\tgoto skip;\n\t}\n\n\tif (i915_sw_fence_done(timeout) || i915_sw_fence_done(not)) {\n\t\tpr_err(\"Fences signaled too early\\n\");\n\t\tgoto err;\n\t}\n\n\tif (!wait_event_timeout(timeout->wait,\n\t\t\t\ti915_sw_fence_done(timeout),\n\t\t\t\t2 * (end - jiffies) + 1)) {\n\t\tpr_err(\"Timeout fence unsignaled!\\n\");\n\t\tgoto err;\n\t}\n\n\tif (i915_sw_fence_done(not)) {\n\t\tpr_err(\"No timeout fence signaled!\\n\");\n\t\tgoto err;\n\t}\n\nskip:\n\tdma_fence_signal(dma);\n\n\tif (!i915_sw_fence_done(timeout) || !i915_sw_fence_done(not)) {\n\t\tpr_err(\"Fences unsignaled\\n\");\n\t\tgoto err;\n\t}\n\n\tfree_fence(not);\n\tfree_fence(timeout);\n\tdma_fence_put(dma);\n\n\treturn 0;\n\nerr:\n\tdma_fence_signal(dma);\n\tif (!IS_ERR_OR_NULL(timeout))\n\t\tfree_fence(timeout);\n\tif (!IS_ERR_OR_NULL(not))\n\t\tfree_fence(not);\n\tdma_fence_put(dma);\n\treturn err;\n}\n\nint i915_sw_fence_mock_selftests(void)\n{\n\tstatic const struct i915_subtest tests[] = {\n\t\tSUBTEST(test_self),\n\t\tSUBTEST(test_dag),\n\t\tSUBTEST(test_AB),\n\t\tSUBTEST(test_ABC),\n\t\tSUBTEST(test_AB_C),\n\t\tSUBTEST(test_C_AB),\n\t\tSUBTEST(test_chain),\n\t\tSUBTEST(test_ipc),\n\t\tSUBTEST(test_timer),\n\t\tSUBTEST(test_dma_fence),\n\t};\n\n\treturn i915_subtests(tests, NULL);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}