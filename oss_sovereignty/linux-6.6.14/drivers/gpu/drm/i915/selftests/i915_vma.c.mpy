{
  "module_name": "i915_vma.c",
  "hash_id": "c236258d6e68a7379f312ebccf9852eaeabe097f0141ee43553274ec86136734",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/i915/selftests/i915_vma.c",
  "human_readable_source": " \n\n#include <linux/prime_numbers.h>\n\n#include \"gem/i915_gem_context.h\"\n#include \"gem/i915_gem_internal.h\"\n#include \"gem/selftests/mock_context.h\"\n\n#include \"i915_scatterlist.h\"\n#include \"i915_selftest.h\"\n\n#include \"mock_gem_device.h\"\n#include \"mock_gtt.h\"\n\nstatic bool assert_vma(struct i915_vma *vma,\n\t\t       struct drm_i915_gem_object *obj,\n\t\t       struct i915_gem_context *ctx)\n{\n\tbool ok = true;\n\n\tif (vma->vm != ctx->vm) {\n\t\tpr_err(\"VMA created with wrong VM\\n\");\n\t\tok = false;\n\t}\n\n\tif (vma->size != obj->base.size) {\n\t\tpr_err(\"VMA created with wrong size, found %llu, expected %zu\\n\",\n\t\t       vma->size, obj->base.size);\n\t\tok = false;\n\t}\n\n\tif (vma->gtt_view.type != I915_GTT_VIEW_NORMAL) {\n\t\tpr_err(\"VMA created with wrong type [%d]\\n\",\n\t\t       vma->gtt_view.type);\n\t\tok = false;\n\t}\n\n\treturn ok;\n}\n\nstatic struct i915_vma *\nchecked_vma_instance(struct drm_i915_gem_object *obj,\n\t\t     struct i915_address_space *vm,\n\t\t     const struct i915_gtt_view *view)\n{\n\tstruct i915_vma *vma;\n\tbool ok = true;\n\n\tvma = i915_vma_instance(obj, vm, view);\n\tif (IS_ERR(vma))\n\t\treturn vma;\n\n\t \n\tif (vma->vm != vm) {\n\t\tpr_err(\"VMA's vm [%p] does not match request [%p]\\n\",\n\t\t       vma->vm, vm);\n\t\tok = false;\n\t}\n\n\tif (i915_is_ggtt(vm) != i915_vma_is_ggtt(vma)) {\n\t\tpr_err(\"VMA ggtt status [%d] does not match parent [%d]\\n\",\n\t\t       i915_vma_is_ggtt(vma), i915_is_ggtt(vm));\n\t\tok = false;\n\t}\n\n\tif (i915_vma_compare(vma, vm, view)) {\n\t\tpr_err(\"i915_vma_compare failed with create parameters!\\n\");\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\tif (i915_vma_compare(vma, vma->vm,\n\t\t\t     i915_vma_is_ggtt(vma) ? &vma->gtt_view : NULL)) {\n\t\tpr_err(\"i915_vma_compare failed with itself\\n\");\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\tif (!ok) {\n\t\tpr_err(\"i915_vma_compare failed to detect the difference!\\n\");\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\treturn vma;\n}\n\nstatic int create_vmas(struct drm_i915_private *i915,\n\t\t       struct list_head *objects,\n\t\t       struct list_head *contexts)\n{\n\tstruct drm_i915_gem_object *obj;\n\tstruct i915_gem_context *ctx;\n\tint pinned;\n\n\tlist_for_each_entry(obj, objects, st_link) {\n\t\tfor (pinned = 0; pinned <= 1; pinned++) {\n\t\t\tlist_for_each_entry(ctx, contexts, link) {\n\t\t\t\tstruct i915_address_space *vm;\n\t\t\t\tstruct i915_vma *vma;\n\t\t\t\tint err;\n\n\t\t\t\tvm = i915_gem_context_get_eb_vm(ctx);\n\t\t\t\tvma = checked_vma_instance(obj, vm, NULL);\n\t\t\t\ti915_vm_put(vm);\n\t\t\t\tif (IS_ERR(vma))\n\t\t\t\t\treturn PTR_ERR(vma);\n\n\t\t\t\tif (!assert_vma(vma, obj, ctx)) {\n\t\t\t\t\tpr_err(\"VMA lookup/create failed\\n\");\n\t\t\t\t\treturn -EINVAL;\n\t\t\t\t}\n\n\t\t\t\tif (!pinned) {\n\t\t\t\t\terr = i915_vma_pin(vma, 0, 0, PIN_USER);\n\t\t\t\t\tif (err) {\n\t\t\t\t\t\tpr_err(\"Failed to pin VMA\\n\");\n\t\t\t\t\t\treturn err;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\ti915_vma_unpin(vma);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int igt_vma_create(void *arg)\n{\n\tstruct i915_ggtt *ggtt = arg;\n\tstruct drm_i915_private *i915 = ggtt->vm.i915;\n\tstruct drm_i915_gem_object *obj, *on;\n\tstruct i915_gem_context *ctx, *cn;\n\tunsigned long num_obj, num_ctx;\n\tunsigned long no, nc;\n\tIGT_TIMEOUT(end_time);\n\tLIST_HEAD(contexts);\n\tLIST_HEAD(objects);\n\tint err = -ENOMEM;\n\n\t \n\n\tno = 0;\n\tfor_each_prime_number(num_obj, ULONG_MAX - 1) {\n\t\tfor (; no < num_obj; no++) {\n\t\t\tobj = i915_gem_object_create_internal(i915, PAGE_SIZE);\n\t\t\tif (IS_ERR(obj))\n\t\t\t\tgoto out;\n\n\t\t\tlist_add(&obj->st_link, &objects);\n\t\t}\n\n\t\tnc = 0;\n\t\tfor_each_prime_number(num_ctx, 2 * BITS_PER_LONG) {\n\t\t\tfor (; nc < num_ctx; nc++) {\n\t\t\t\tctx = mock_context(i915, \"mock\");\n\t\t\t\tif (!ctx)\n\t\t\t\t\tgoto out;\n\n\t\t\t\tlist_move(&ctx->link, &contexts);\n\t\t\t}\n\n\t\t\terr = create_vmas(i915, &objects, &contexts);\n\t\t\tif (err)\n\t\t\t\tgoto out;\n\n\t\t\tif (igt_timeout(end_time,\n\t\t\t\t\t\"%s timed out: after %lu objects in %lu contexts\\n\",\n\t\t\t\t\t__func__, no, nc))\n\t\t\t\tgoto end;\n\t\t}\n\n\t\tlist_for_each_entry_safe(ctx, cn, &contexts, link) {\n\t\t\tlist_del_init(&ctx->link);\n\t\t\tmock_context_close(ctx);\n\t\t}\n\n\t\tcond_resched();\n\t}\n\nend:\n\t \n\terr = create_vmas(i915, &objects, &contexts);\nout:\n\tlist_for_each_entry_safe(ctx, cn, &contexts, link) {\n\t\tlist_del_init(&ctx->link);\n\t\tmock_context_close(ctx);\n\t}\n\n\tlist_for_each_entry_safe(obj, on, &objects, st_link)\n\t\ti915_gem_object_put(obj);\n\treturn err;\n}\n\nstruct pin_mode {\n\tu64 size;\n\tu64 flags;\n\tbool (*assert)(const struct i915_vma *,\n\t\t       const struct pin_mode *mode,\n\t\t       int result);\n\tconst char *string;\n};\n\nstatic bool assert_pin_valid(const struct i915_vma *vma,\n\t\t\t     const struct pin_mode *mode,\n\t\t\t     int result)\n{\n\tif (result)\n\t\treturn false;\n\n\tif (i915_vma_misplaced(vma, mode->size, 0, mode->flags))\n\t\treturn false;\n\n\treturn true;\n}\n\n__maybe_unused\nstatic bool assert_pin_enospc(const struct i915_vma *vma,\n\t\t\t      const struct pin_mode *mode,\n\t\t\t      int result)\n{\n\treturn result == -ENOSPC;\n}\n\n__maybe_unused\nstatic bool assert_pin_einval(const struct i915_vma *vma,\n\t\t\t      const struct pin_mode *mode,\n\t\t\t      int result)\n{\n\treturn result == -EINVAL;\n}\n\nstatic int igt_vma_pin1(void *arg)\n{\n\tstruct i915_ggtt *ggtt = arg;\n\tconst struct pin_mode modes[] = {\n#define VALID(sz, fl) { .size = (sz), .flags = (fl), .assert = assert_pin_valid, .string = #sz \", \" #fl \", (valid) \" }\n#define __INVALID(sz, fl, check, eval) { .size = (sz), .flags = (fl), .assert = (check), .string = #sz \", \" #fl \", (invalid \" #eval \")\" }\n#define INVALID(sz, fl) __INVALID(sz, fl, assert_pin_einval, EINVAL)\n#define NOSPACE(sz, fl) __INVALID(sz, fl, assert_pin_enospc, ENOSPC)\n\t\tVALID(0, PIN_GLOBAL),\n\t\tVALID(0, PIN_GLOBAL | PIN_MAPPABLE),\n\n\t\tVALID(0, PIN_GLOBAL | PIN_OFFSET_BIAS | 4096),\n\t\tVALID(0, PIN_GLOBAL | PIN_OFFSET_BIAS | 8192),\n\t\tVALID(0, PIN_GLOBAL | PIN_OFFSET_BIAS | (ggtt->mappable_end - 4096)),\n\t\tVALID(0, PIN_GLOBAL | PIN_MAPPABLE | PIN_OFFSET_BIAS | (ggtt->mappable_end - 4096)),\n\t\tVALID(0, PIN_GLOBAL | PIN_OFFSET_BIAS | (ggtt->vm.total - 4096)),\n\n\t\tVALID(0, PIN_GLOBAL | PIN_MAPPABLE | PIN_OFFSET_FIXED | (ggtt->mappable_end - 4096)),\n\t\tINVALID(0, PIN_GLOBAL | PIN_MAPPABLE | PIN_OFFSET_FIXED | ggtt->mappable_end),\n\t\tVALID(0, PIN_GLOBAL | PIN_OFFSET_FIXED | (ggtt->vm.total - 4096)),\n\t\tINVALID(0, PIN_GLOBAL | PIN_OFFSET_FIXED | ggtt->vm.total),\n\t\tINVALID(0, PIN_GLOBAL | PIN_OFFSET_FIXED | round_down(U64_MAX, PAGE_SIZE)),\n\n\t\tVALID(4096, PIN_GLOBAL),\n\t\tVALID(8192, PIN_GLOBAL),\n\t\tVALID(ggtt->mappable_end - 4096, PIN_GLOBAL | PIN_MAPPABLE),\n\t\tVALID(ggtt->mappable_end, PIN_GLOBAL | PIN_MAPPABLE),\n\t\tNOSPACE(ggtt->mappable_end + 4096, PIN_GLOBAL | PIN_MAPPABLE),\n\t\tVALID(ggtt->vm.total - 4096, PIN_GLOBAL),\n\t\tVALID(ggtt->vm.total, PIN_GLOBAL),\n\t\tNOSPACE(ggtt->vm.total + 4096, PIN_GLOBAL),\n\t\tNOSPACE(round_down(U64_MAX, PAGE_SIZE), PIN_GLOBAL),\n\t\tINVALID(8192, PIN_GLOBAL | PIN_MAPPABLE | PIN_OFFSET_FIXED | (ggtt->mappable_end - 4096)),\n\t\tINVALID(8192, PIN_GLOBAL | PIN_OFFSET_FIXED | (ggtt->vm.total - 4096)),\n\t\tINVALID(8192, PIN_GLOBAL | PIN_OFFSET_FIXED | (round_down(U64_MAX, PAGE_SIZE) - 4096)),\n\n\t\tVALID(8192, PIN_GLOBAL | PIN_OFFSET_BIAS | (ggtt->mappable_end - 4096)),\n\n#if !IS_ENABLED(CONFIG_DRM_I915_DEBUG_GEM)\n\t\t \n\t\tNOSPACE(0, PIN_GLOBAL | PIN_MAPPABLE | PIN_OFFSET_BIAS | ggtt->mappable_end),\n\t\tNOSPACE(0, PIN_GLOBAL | PIN_OFFSET_BIAS | ggtt->vm.total),\n\t\tNOSPACE(8192, PIN_GLOBAL | PIN_MAPPABLE | PIN_OFFSET_BIAS | (ggtt->mappable_end - 4096)),\n\t\tNOSPACE(8192, PIN_GLOBAL | PIN_OFFSET_BIAS | (ggtt->vm.total - 4096)),\n#endif\n\t\t{ },\n#undef NOSPACE\n#undef INVALID\n#undef __INVALID\n#undef VALID\n\t}, *m;\n\tstruct drm_i915_gem_object *obj;\n\tstruct i915_vma *vma;\n\tint err = -EINVAL;\n\n\t \n\n\tGEM_BUG_ON(!drm_mm_clean(&ggtt->vm.mm));\n\n\tobj = i915_gem_object_create_internal(ggtt->vm.i915, PAGE_SIZE);\n\tif (IS_ERR(obj))\n\t\treturn PTR_ERR(obj);\n\n\tvma = checked_vma_instance(obj, &ggtt->vm, NULL);\n\tif (IS_ERR(vma))\n\t\tgoto out;\n\n\tfor (m = modes; m->assert; m++) {\n\t\terr = i915_vma_pin(vma, m->size, 0, m->flags);\n\t\tif (!m->assert(vma, m, err)) {\n\t\t\tpr_err(\"%s to pin single page into GGTT with mode[%d:%s]: size=%llx flags=%llx, err=%d\\n\",\n\t\t\t       m->assert == assert_pin_valid ? \"Failed\" : \"Unexpectedly succeeded\",\n\t\t\t       (int)(m - modes), m->string, m->size, m->flags,\n\t\t\t       err);\n\t\t\tif (!err)\n\t\t\t\ti915_vma_unpin(vma);\n\t\t\terr = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (!err) {\n\t\t\ti915_vma_unpin(vma);\n\t\t\terr = i915_vma_unbind_unlocked(vma);\n\t\t\tif (err) {\n\t\t\t\tpr_err(\"Failed to unbind single page from GGTT, err=%d\\n\", err);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\n\t\tcond_resched();\n\t}\n\n\terr = 0;\nout:\n\ti915_gem_object_put(obj);\n\treturn err;\n}\n\nstatic unsigned long rotated_index(const struct intel_rotation_info *r,\n\t\t\t\t   unsigned int n,\n\t\t\t\t   unsigned int x,\n\t\t\t\t   unsigned int y)\n{\n\treturn (r->plane[n].src_stride * (r->plane[n].height - y - 1) +\n\t\tr->plane[n].offset + x);\n}\n\nstatic struct scatterlist *\nassert_rotated(struct drm_i915_gem_object *obj,\n\t       const struct intel_rotation_info *r, unsigned int n,\n\t       struct scatterlist *sg)\n{\n\tunsigned int x, y;\n\n\tfor (x = 0; x < r->plane[n].width; x++) {\n\t\tunsigned int left;\n\n\t\tfor (y = 0; y < r->plane[n].height; y++) {\n\t\t\tunsigned long src_idx;\n\t\t\tdma_addr_t src;\n\n\t\t\tif (!sg) {\n\t\t\t\tpr_err(\"Invalid sg table: too short at plane %d, (%d, %d)!\\n\",\n\t\t\t\t       n, x, y);\n\t\t\t\treturn ERR_PTR(-EINVAL);\n\t\t\t}\n\n\t\t\tsrc_idx = rotated_index(r, n, x, y);\n\t\t\tsrc = i915_gem_object_get_dma_address(obj, src_idx);\n\n\t\t\tif (sg_dma_len(sg) != PAGE_SIZE) {\n\t\t\t\tpr_err(\"Invalid sg.length, found %d, expected %lu for rotated page (%d, %d) [src index %lu]\\n\",\n\t\t\t\t       sg_dma_len(sg), PAGE_SIZE,\n\t\t\t\t       x, y, src_idx);\n\t\t\t\treturn ERR_PTR(-EINVAL);\n\t\t\t}\n\n\t\t\tif (sg_dma_address(sg) != src) {\n\t\t\t\tpr_err(\"Invalid address for rotated page (%d, %d) [src index %lu]\\n\",\n\t\t\t\t       x, y, src_idx);\n\t\t\t\treturn ERR_PTR(-EINVAL);\n\t\t\t}\n\n\t\t\tsg = sg_next(sg);\n\t\t}\n\n\t\tleft = (r->plane[n].dst_stride - y) * PAGE_SIZE;\n\n\t\tif (!left)\n\t\t\tcontinue;\n\n\t\tif (!sg) {\n\t\t\tpr_err(\"Invalid sg table: too short at plane %d, (%d, %d)!\\n\",\n\t\t\t       n, x, y);\n\t\t\treturn ERR_PTR(-EINVAL);\n\t\t}\n\n\t\tif (sg_dma_len(sg) != left) {\n\t\t\tpr_err(\"Invalid sg.length, found %d, expected %u for rotated page (%d, %d)\\n\",\n\t\t\t       sg_dma_len(sg), left, x, y);\n\t\t\treturn ERR_PTR(-EINVAL);\n\t\t}\n\n\t\tif (sg_dma_address(sg) != 0) {\n\t\t\tpr_err(\"Invalid address, found %pad, expected 0 for remapped page (%d, %d)\\n\",\n\t\t\t       &sg_dma_address(sg), x, y);\n\t\t\treturn ERR_PTR(-EINVAL);\n\t\t}\n\n\t\tsg = sg_next(sg);\n\t}\n\n\treturn sg;\n}\n\nstatic unsigned long remapped_index(const struct intel_remapped_info *r,\n\t\t\t\t    unsigned int n,\n\t\t\t\t    unsigned int x,\n\t\t\t\t    unsigned int y)\n{\n\treturn (r->plane[n].src_stride * y +\n\t\tr->plane[n].offset + x);\n}\n\nstatic struct scatterlist *\nassert_remapped(struct drm_i915_gem_object *obj,\n\t\tconst struct intel_remapped_info *r, unsigned int n,\n\t\tstruct scatterlist *sg)\n{\n\tunsigned int x, y;\n\tunsigned int left = 0;\n\tunsigned int offset;\n\n\tfor (y = 0; y < r->plane[n].height; y++) {\n\t\tfor (x = 0; x < r->plane[n].width; x++) {\n\t\t\tunsigned long src_idx;\n\t\t\tdma_addr_t src;\n\n\t\t\tif (!sg) {\n\t\t\t\tpr_err(\"Invalid sg table: too short at plane %d, (%d, %d)!\\n\",\n\t\t\t\t       n, x, y);\n\t\t\t\treturn ERR_PTR(-EINVAL);\n\t\t\t}\n\t\t\tif (!left) {\n\t\t\t\toffset = 0;\n\t\t\t\tleft = sg_dma_len(sg);\n\t\t\t}\n\n\t\t\tsrc_idx = remapped_index(r, n, x, y);\n\t\t\tsrc = i915_gem_object_get_dma_address(obj, src_idx);\n\n\t\t\tif (left < PAGE_SIZE || left & (PAGE_SIZE-1)) {\n\t\t\t\tpr_err(\"Invalid sg.length, found %d, expected %lu for remapped page (%d, %d) [src index %lu]\\n\",\n\t\t\t\t       sg_dma_len(sg), PAGE_SIZE,\n\t\t\t\t       x, y, src_idx);\n\t\t\t\treturn ERR_PTR(-EINVAL);\n\t\t\t}\n\n\t\t\tif (sg_dma_address(sg) + offset != src) {\n\t\t\t\tpr_err(\"Invalid address for remapped page (%d, %d) [src index %lu]\\n\",\n\t\t\t\t       x, y, src_idx);\n\t\t\t\treturn ERR_PTR(-EINVAL);\n\t\t\t}\n\n\t\t\tleft -= PAGE_SIZE;\n\t\t\toffset += PAGE_SIZE;\n\n\n\t\t\tif (!left)\n\t\t\t\tsg = sg_next(sg);\n\t\t}\n\n\t\tif (left) {\n\t\t\tpr_err(\"Unexpected sg tail with %d size for remapped page (%d, %d)\\n\",\n\t\t\t       left,\n\t\t\t       x, y);\n\t\t\treturn ERR_PTR(-EINVAL);\n\t\t}\n\n\t\tleft = (r->plane[n].dst_stride - r->plane[n].width) * PAGE_SIZE;\n\n\t\tif (!left)\n\t\t\tcontinue;\n\n\t\tif (!sg) {\n\t\t\tpr_err(\"Invalid sg table: too short at plane %d, (%d, %d)!\\n\",\n\t\t\t       n, x, y);\n\t\t\treturn ERR_PTR(-EINVAL);\n\t\t}\n\n\t\tif (sg_dma_len(sg) != left) {\n\t\t\tpr_err(\"Invalid sg.length, found %u, expected %u for remapped page (%d, %d)\\n\",\n\t\t\t       sg_dma_len(sg), left,\n\t\t\t       x, y);\n\t\t\treturn ERR_PTR(-EINVAL);\n\t\t}\n\n\t\tif (sg_dma_address(sg) != 0) {\n\t\t\tpr_err(\"Invalid address, found %pad, expected 0 for remapped page (%d, %d)\\n\",\n\t\t\t       &sg_dma_address(sg),\n\t\t\t       x, y);\n\t\t\treturn ERR_PTR(-EINVAL);\n\t\t}\n\n\t\tsg = sg_next(sg);\n\t\tleft = 0;\n\t}\n\n\treturn sg;\n}\n\nstatic unsigned int remapped_size(enum i915_gtt_view_type view_type,\n\t\t\t\t  const struct intel_remapped_plane_info *a,\n\t\t\t\t  const struct intel_remapped_plane_info *b)\n{\n\n\tif (view_type == I915_GTT_VIEW_ROTATED)\n\t\treturn a->dst_stride * a->width + b->dst_stride * b->width;\n\telse\n\t\treturn a->dst_stride * a->height + b->dst_stride * b->height;\n}\n\nstatic int igt_vma_rotate_remap(void *arg)\n{\n\tstruct i915_ggtt *ggtt = arg;\n\tstruct i915_address_space *vm = &ggtt->vm;\n\tstruct drm_i915_gem_object *obj;\n\tconst struct intel_remapped_plane_info planes[] = {\n\t\t{ .width = 1, .height = 1, .src_stride = 1 },\n\t\t{ .width = 2, .height = 2, .src_stride = 2 },\n\t\t{ .width = 4, .height = 4, .src_stride = 4 },\n\t\t{ .width = 8, .height = 8, .src_stride = 8 },\n\n\t\t{ .width = 3, .height = 5, .src_stride = 3 },\n\t\t{ .width = 3, .height = 5, .src_stride = 4 },\n\t\t{ .width = 3, .height = 5, .src_stride = 5 },\n\n\t\t{ .width = 5, .height = 3, .src_stride = 5 },\n\t\t{ .width = 5, .height = 3, .src_stride = 7 },\n\t\t{ .width = 5, .height = 3, .src_stride = 9 },\n\n\t\t{ .width = 4, .height = 6, .src_stride = 6 },\n\t\t{ .width = 6, .height = 4, .src_stride = 6 },\n\n\t\t{ .width = 2, .height = 2, .src_stride = 2, .dst_stride = 2 },\n\t\t{ .width = 3, .height = 3, .src_stride = 3, .dst_stride = 4 },\n\t\t{ .width = 5, .height = 6, .src_stride = 7, .dst_stride = 8 },\n\n\t\t{ }\n\t}, *a, *b;\n\tenum i915_gtt_view_type types[] = {\n\t\tI915_GTT_VIEW_ROTATED,\n\t\tI915_GTT_VIEW_REMAPPED,\n\t\t0,\n\t}, *t;\n\tconst unsigned int max_pages = 64;\n\tint err = -ENOMEM;\n\n\t \n\n\tobj = i915_gem_object_create_internal(vm->i915, max_pages * PAGE_SIZE);\n\tif (IS_ERR(obj))\n\t\tgoto out;\n\n\tfor (t = types; *t; t++) {\n\tfor (a = planes; a->width; a++) {\n\t\tfor (b = planes + ARRAY_SIZE(planes); b-- != planes; ) {\n\t\t\tstruct i915_gtt_view view = {\n\t\t\t\t.type = *t,\n\t\t\t\t.remapped.plane[0] = *a,\n\t\t\t\t.remapped.plane[1] = *b,\n\t\t\t};\n\t\t\tstruct intel_remapped_plane_info *plane_info = view.remapped.plane;\n\t\t\tunsigned int n, max_offset;\n\n\t\t\tmax_offset = max(plane_info[0].src_stride * plane_info[0].height,\n\t\t\t\t\t plane_info[1].src_stride * plane_info[1].height);\n\t\t\tGEM_BUG_ON(max_offset > max_pages);\n\t\t\tmax_offset = max_pages - max_offset;\n\n\t\t\tif (!plane_info[0].dst_stride)\n\t\t\t\tplane_info[0].dst_stride = view.type == I915_GTT_VIEW_ROTATED ?\n\t\t\t\t\t\t\t\t\tplane_info[0].height :\n\t\t\t\t\t\t\t\t\tplane_info[0].width;\n\t\t\tif (!plane_info[1].dst_stride)\n\t\t\t\tplane_info[1].dst_stride = view.type == I915_GTT_VIEW_ROTATED ?\n\t\t\t\t\t\t\t\t\tplane_info[1].height :\n\t\t\t\t\t\t\t\t\tplane_info[1].width;\n\n\t\t\tfor_each_prime_number_from(plane_info[0].offset, 0, max_offset) {\n\t\t\t\tfor_each_prime_number_from(plane_info[1].offset, 0, max_offset) {\n\t\t\t\t\tstruct scatterlist *sg;\n\t\t\t\t\tstruct i915_vma *vma;\n\t\t\t\t\tunsigned int expected_pages;\n\n\t\t\t\t\tvma = checked_vma_instance(obj, vm, &view);\n\t\t\t\t\tif (IS_ERR(vma)) {\n\t\t\t\t\t\terr = PTR_ERR(vma);\n\t\t\t\t\t\tgoto out_object;\n\t\t\t\t\t}\n\n\t\t\t\t\terr = i915_vma_pin(vma, 0, 0, PIN_GLOBAL);\n\t\t\t\t\tif (err) {\n\t\t\t\t\t\tpr_err(\"Failed to pin VMA, err=%d\\n\", err);\n\t\t\t\t\t\tgoto out_object;\n\t\t\t\t\t}\n\n\t\t\t\t\texpected_pages = remapped_size(view.type, &plane_info[0], &plane_info[1]);\n\n\t\t\t\t\tif (view.type == I915_GTT_VIEW_ROTATED &&\n\t\t\t\t\t    vma->size != expected_pages * PAGE_SIZE) {\n\t\t\t\t\t\tpr_err(\"VMA is wrong size, expected %lu, found %llu\\n\",\n\t\t\t\t\t\t       PAGE_SIZE * expected_pages, vma->size);\n\t\t\t\t\t\terr = -EINVAL;\n\t\t\t\t\t\tgoto out_object;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (view.type == I915_GTT_VIEW_REMAPPED &&\n\t\t\t\t\t    vma->size > expected_pages * PAGE_SIZE) {\n\t\t\t\t\t\tpr_err(\"VMA is wrong size, expected %lu, found %llu\\n\",\n\t\t\t\t\t\t       PAGE_SIZE * expected_pages, vma->size);\n\t\t\t\t\t\terr = -EINVAL;\n\t\t\t\t\t\tgoto out_object;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (vma->pages->nents > expected_pages) {\n\t\t\t\t\t\tpr_err(\"sg table is wrong sizeo, expected %u, found %u nents\\n\",\n\t\t\t\t\t\t       expected_pages, vma->pages->nents);\n\t\t\t\t\t\terr = -EINVAL;\n\t\t\t\t\t\tgoto out_object;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (vma->node.size < vma->size) {\n\t\t\t\t\t\tpr_err(\"VMA binding too small, expected %llu, found %llu\\n\",\n\t\t\t\t\t\t       vma->size, vma->node.size);\n\t\t\t\t\t\terr = -EINVAL;\n\t\t\t\t\t\tgoto out_object;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (vma->pages == obj->mm.pages) {\n\t\t\t\t\t\tpr_err(\"VMA using unrotated object pages!\\n\");\n\t\t\t\t\t\terr = -EINVAL;\n\t\t\t\t\t\tgoto out_object;\n\t\t\t\t\t}\n\n\t\t\t\t\tsg = vma->pages->sgl;\n\t\t\t\t\tfor (n = 0; n < ARRAY_SIZE(view.rotated.plane); n++) {\n\t\t\t\t\t\tif (view.type == I915_GTT_VIEW_ROTATED)\n\t\t\t\t\t\t\tsg = assert_rotated(obj, &view.rotated, n, sg);\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tsg = assert_remapped(obj, &view.remapped, n, sg);\n\t\t\t\t\t\tif (IS_ERR(sg)) {\n\t\t\t\t\t\t\tpr_err(\"Inconsistent %s VMA pages for plane %d: [(%d, %d, %d, %d, %d), (%d, %d, %d, %d, %d)]\\n\",\n\t\t\t\t\t\t\t       view.type == I915_GTT_VIEW_ROTATED ?\n\t\t\t\t\t\t\t       \"rotated\" : \"remapped\", n,\n\t\t\t\t\t\t\t       plane_info[0].width,\n\t\t\t\t\t\t\t       plane_info[0].height,\n\t\t\t\t\t\t\t       plane_info[0].src_stride,\n\t\t\t\t\t\t\t       plane_info[0].dst_stride,\n\t\t\t\t\t\t\t       plane_info[0].offset,\n\t\t\t\t\t\t\t       plane_info[1].width,\n\t\t\t\t\t\t\t       plane_info[1].height,\n\t\t\t\t\t\t\t       plane_info[1].src_stride,\n\t\t\t\t\t\t\t       plane_info[1].dst_stride,\n\t\t\t\t\t\t\t       plane_info[1].offset);\n\t\t\t\t\t\t\terr = -EINVAL;\n\t\t\t\t\t\t\tgoto out_object;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\ti915_vma_unpin(vma);\n\t\t\t\t\terr = i915_vma_unbind_unlocked(vma);\n\t\t\t\t\tif (err) {\n\t\t\t\t\t\tpr_err(\"Unbinding returned %i\\n\", err);\n\t\t\t\t\t\tgoto out_object;\n\t\t\t\t\t}\n\t\t\t\t\tcond_resched();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t}\n\nout_object:\n\ti915_gem_object_put(obj);\nout:\n\treturn err;\n}\n\nstatic bool assert_partial(struct drm_i915_gem_object *obj,\n\t\t\t   struct i915_vma *vma,\n\t\t\t   unsigned long offset,\n\t\t\t   unsigned long size)\n{\n\tstruct sgt_iter sgt;\n\tdma_addr_t dma;\n\n\tfor_each_sgt_daddr(dma, sgt, vma->pages) {\n\t\tdma_addr_t src;\n\n\t\tif (!size) {\n\t\t\tpr_err(\"Partial scattergather list too long\\n\");\n\t\t\treturn false;\n\t\t}\n\n\t\tsrc = i915_gem_object_get_dma_address(obj, offset);\n\t\tif (src != dma) {\n\t\t\tpr_err(\"DMA mismatch for partial page offset %lu\\n\",\n\t\t\t       offset);\n\t\t\treturn false;\n\t\t}\n\n\t\toffset++;\n\t\tsize--;\n\t}\n\n\treturn true;\n}\n\nstatic bool assert_pin(struct i915_vma *vma,\n\t\t       struct i915_gtt_view *view,\n\t\t       u64 size,\n\t\t       const char *name)\n{\n\tbool ok = true;\n\n\tif (vma->size != size) {\n\t\tpr_err(\"(%s) VMA is wrong size, expected %llu, found %llu\\n\",\n\t\t       name, size, vma->size);\n\t\tok = false;\n\t}\n\n\tif (vma->node.size < vma->size) {\n\t\tpr_err(\"(%s) VMA binding too small, expected %llu, found %llu\\n\",\n\t\t       name, vma->size, vma->node.size);\n\t\tok = false;\n\t}\n\n\tif (view && view->type != I915_GTT_VIEW_NORMAL) {\n\t\tif (memcmp(&vma->gtt_view, view, sizeof(*view))) {\n\t\t\tpr_err(\"(%s) VMA mismatch upon creation!\\n\",\n\t\t\t       name);\n\t\t\tok = false;\n\t\t}\n\n\t\tif (vma->pages == vma->obj->mm.pages) {\n\t\t\tpr_err(\"(%s) VMA using original object pages!\\n\",\n\t\t\t       name);\n\t\t\tok = false;\n\t\t}\n\t} else {\n\t\tif (vma->gtt_view.type != I915_GTT_VIEW_NORMAL) {\n\t\t\tpr_err(\"Not the normal ggtt view! Found %d\\n\",\n\t\t\t       vma->gtt_view.type);\n\t\t\tok = false;\n\t\t}\n\n\t\tif (vma->pages != vma->obj->mm.pages) {\n\t\t\tpr_err(\"VMA not using object pages!\\n\");\n\t\t\tok = false;\n\t\t}\n\t}\n\n\treturn ok;\n}\n\nstatic int igt_vma_partial(void *arg)\n{\n\tstruct i915_ggtt *ggtt = arg;\n\tstruct i915_address_space *vm = &ggtt->vm;\n\tconst unsigned int npages = 1021;  \n\tstruct drm_i915_gem_object *obj;\n\tconst struct phase {\n\t\tconst char *name;\n\t} phases[] = {\n\t\t{ \"create\" },\n\t\t{ \"lookup\" },\n\t\t{ },\n\t}, *p;\n\tunsigned int sz, offset;\n\tstruct i915_vma *vma;\n\tint err = -ENOMEM;\n\n\t \n\n\tobj = i915_gem_object_create_internal(vm->i915, npages * PAGE_SIZE);\n\tif (IS_ERR(obj))\n\t\tgoto out;\n\n\tfor (p = phases; p->name; p++) {  \n\t\tunsigned int count, nvma;\n\n\t\tnvma = 0;\n\t\tfor_each_prime_number_from(sz, 1, npages) {\n\t\t\tfor_each_prime_number_from(offset, 0, npages - sz) {\n\t\t\t\tstruct i915_gtt_view view;\n\n\t\t\t\tview.type = I915_GTT_VIEW_PARTIAL;\n\t\t\t\tview.partial.offset = offset;\n\t\t\t\tview.partial.size = sz;\n\n\t\t\t\tif (sz == npages)\n\t\t\t\t\tview.type = I915_GTT_VIEW_NORMAL;\n\n\t\t\t\tvma = checked_vma_instance(obj, vm, &view);\n\t\t\t\tif (IS_ERR(vma)) {\n\t\t\t\t\terr = PTR_ERR(vma);\n\t\t\t\t\tgoto out_object;\n\t\t\t\t}\n\n\t\t\t\terr = i915_vma_pin(vma, 0, 0, PIN_GLOBAL);\n\t\t\t\tif (err)\n\t\t\t\t\tgoto out_object;\n\n\t\t\t\tif (!assert_pin(vma, &view, sz*PAGE_SIZE, p->name)) {\n\t\t\t\t\tpr_err(\"(%s) Inconsistent partial pinning for (offset=%d, size=%d)\\n\",\n\t\t\t\t\t       p->name, offset, sz);\n\t\t\t\t\terr = -EINVAL;\n\t\t\t\t\tgoto out_object;\n\t\t\t\t}\n\n\t\t\t\tif (!assert_partial(obj, vma, offset, sz)) {\n\t\t\t\t\tpr_err(\"(%s) Inconsistent partial pages for (offset=%d, size=%d)\\n\",\n\t\t\t\t\t       p->name, offset, sz);\n\t\t\t\t\terr = -EINVAL;\n\t\t\t\t\tgoto out_object;\n\t\t\t\t}\n\n\t\t\t\ti915_vma_unpin(vma);\n\t\t\t\tnvma++;\n\t\t\t\terr = i915_vma_unbind_unlocked(vma);\n\t\t\t\tif (err) {\n\t\t\t\t\tpr_err(\"Unbinding returned %i\\n\", err);\n\t\t\t\t\tgoto out_object;\n\t\t\t\t}\n\n\t\t\t\tcond_resched();\n\t\t\t}\n\t\t}\n\n\t\tcount = 0;\n\t\tlist_for_each_entry(vma, &obj->vma.list, obj_link)\n\t\t\tcount++;\n\t\tif (count != nvma) {\n\t\t\tpr_err(\"(%s) All partial vma were not recorded on the obj->vma_list: found %u, expected %u\\n\",\n\t\t\t       p->name, count, nvma);\n\t\t\terr = -EINVAL;\n\t\t\tgoto out_object;\n\t\t}\n\n\t\t \n\t\tvma = checked_vma_instance(obj, vm, NULL);\n\t\tif (IS_ERR(vma)) {\n\t\t\terr = PTR_ERR(vma);\n\t\t\tgoto out_object;\n\t\t}\n\n\t\terr = i915_vma_pin(vma, 0, 0, PIN_GLOBAL);\n\t\tif (err)\n\t\t\tgoto out_object;\n\n\t\tif (!assert_pin(vma, NULL, obj->base.size, p->name)) {\n\t\t\tpr_err(\"(%s) inconsistent full pin\\n\", p->name);\n\t\t\terr = -EINVAL;\n\t\t\tgoto out_object;\n\t\t}\n\n\t\ti915_vma_unpin(vma);\n\n\t\terr = i915_vma_unbind_unlocked(vma);\n\t\tif (err) {\n\t\t\tpr_err(\"Unbinding returned %i\\n\", err);\n\t\t\tgoto out_object;\n\t\t}\n\n\t\tcount = 0;\n\t\tlist_for_each_entry(vma, &obj->vma.list, obj_link)\n\t\t\tcount++;\n\t\tif (count != nvma) {\n\t\t\tpr_err(\"(%s) allocated an extra full vma!\\n\", p->name);\n\t\t\terr = -EINVAL;\n\t\t\tgoto out_object;\n\t\t}\n\t}\n\nout_object:\n\ti915_gem_object_put(obj);\nout:\n\treturn err;\n}\n\nint i915_vma_mock_selftests(void)\n{\n\tstatic const struct i915_subtest tests[] = {\n\t\tSUBTEST(igt_vma_create),\n\t\tSUBTEST(igt_vma_pin1),\n\t\tSUBTEST(igt_vma_rotate_remap),\n\t\tSUBTEST(igt_vma_partial),\n\t};\n\tstruct drm_i915_private *i915;\n\tstruct intel_gt *gt;\n\tint err;\n\n\ti915 = mock_gem_device();\n\tif (!i915)\n\t\treturn -ENOMEM;\n\n\t \n\terr = intel_gt_assign_ggtt(to_gt(i915));\n\tif (err)\n\t\tgoto out_put;\n\n\tgt = to_gt(i915);\n\n\tmock_init_ggtt(gt);\n\n\terr = i915_subtests(tests, gt->ggtt);\n\n\tmock_device_flush(i915);\n\ti915_gem_drain_freed_objects(i915);\n\tmock_fini_ggtt(gt->ggtt);\n\nout_put:\n\tmock_destroy_device(i915);\n\treturn err;\n}\n\nstatic int igt_vma_remapped_gtt(void *arg)\n{\n\tstruct drm_i915_private *i915 = arg;\n\tconst struct intel_remapped_plane_info planes[] = {\n\t\t{ .width = 1, .height = 1, .src_stride = 1 },\n\t\t{ .width = 2, .height = 2, .src_stride = 2 },\n\t\t{ .width = 4, .height = 4, .src_stride = 4 },\n\t\t{ .width = 8, .height = 8, .src_stride = 8 },\n\n\t\t{ .width = 3, .height = 5, .src_stride = 3 },\n\t\t{ .width = 3, .height = 5, .src_stride = 4 },\n\t\t{ .width = 3, .height = 5, .src_stride = 5 },\n\n\t\t{ .width = 5, .height = 3, .src_stride = 5 },\n\t\t{ .width = 5, .height = 3, .src_stride = 7 },\n\t\t{ .width = 5, .height = 3, .src_stride = 9 },\n\n\t\t{ .width = 4, .height = 6, .src_stride = 6 },\n\t\t{ .width = 6, .height = 4, .src_stride = 6 },\n\n\t\t{ .width = 2, .height = 2, .src_stride = 2, .dst_stride = 2 },\n\t\t{ .width = 3, .height = 3, .src_stride = 3, .dst_stride = 4 },\n\t\t{ .width = 5, .height = 6, .src_stride = 7, .dst_stride = 8 },\n\n\t\t{ }\n\t}, *p;\n\tenum i915_gtt_view_type types[] = {\n\t\tI915_GTT_VIEW_ROTATED,\n\t\tI915_GTT_VIEW_REMAPPED,\n\t\t0,\n\t}, *t;\n\tstruct drm_i915_gem_object *obj;\n\tintel_wakeref_t wakeref;\n\tint err = 0;\n\n\tif (!i915_ggtt_has_aperture(to_gt(i915)->ggtt))\n\t\treturn 0;\n\n\tobj = i915_gem_object_create_internal(i915, 10 * 10 * PAGE_SIZE);\n\tif (IS_ERR(obj))\n\t\treturn PTR_ERR(obj);\n\n\twakeref = intel_runtime_pm_get(&i915->runtime_pm);\n\n\tfor (t = types; *t; t++) {\n\t\tfor (p = planes; p->width; p++) {\n\t\t\tstruct i915_gtt_view view = {\n\t\t\t\t.type = *t,\n\t\t\t\t.rotated.plane[0] = *p,\n\t\t\t};\n\t\t\tstruct intel_remapped_plane_info *plane_info = view.rotated.plane;\n\t\t\tstruct i915_vma *vma;\n\t\t\tu32 __iomem *map;\n\t\t\tunsigned int x, y;\n\n\t\t\ti915_gem_object_lock(obj, NULL);\n\t\t\terr = i915_gem_object_set_to_gtt_domain(obj, true);\n\t\t\ti915_gem_object_unlock(obj);\n\t\t\tif (err)\n\t\t\t\tgoto out;\n\n\t\t\tif (!plane_info[0].dst_stride)\n\t\t\t\tplane_info[0].dst_stride = *t == I915_GTT_VIEW_ROTATED ?\n\t\t\t\t\t\t\t\t p->height : p->width;\n\n\t\t\tvma = i915_gem_object_ggtt_pin(obj, &view, 0, 0, PIN_MAPPABLE);\n\t\t\tif (IS_ERR(vma)) {\n\t\t\t\terr = PTR_ERR(vma);\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tGEM_BUG_ON(vma->gtt_view.type != *t);\n\n\t\t\tmap = i915_vma_pin_iomap(vma);\n\t\t\ti915_vma_unpin(vma);\n\t\t\tif (IS_ERR(map)) {\n\t\t\t\terr = PTR_ERR(map);\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tfor (y = 0 ; y < plane_info[0].height; y++) {\n\t\t\t\tfor (x = 0 ; x < plane_info[0].width; x++) {\n\t\t\t\t\tunsigned int offset;\n\t\t\t\t\tu32 val = y << 16 | x;\n\n\t\t\t\t\tif (*t == I915_GTT_VIEW_ROTATED)\n\t\t\t\t\t\toffset = (x * plane_info[0].dst_stride + y) * PAGE_SIZE;\n\t\t\t\t\telse\n\t\t\t\t\t\toffset = (y * plane_info[0].dst_stride + x) * PAGE_SIZE;\n\n\t\t\t\t\tiowrite32(val, &map[offset / sizeof(*map)]);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\ti915_vma_unpin_iomap(vma);\n\n\t\t\tvma = i915_gem_object_ggtt_pin(obj, NULL, 0, 0, PIN_MAPPABLE);\n\t\t\tif (IS_ERR(vma)) {\n\t\t\t\terr = PTR_ERR(vma);\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tGEM_BUG_ON(vma->gtt_view.type != I915_GTT_VIEW_NORMAL);\n\n\t\t\tmap = i915_vma_pin_iomap(vma);\n\t\t\ti915_vma_unpin(vma);\n\t\t\tif (IS_ERR(map)) {\n\t\t\t\terr = PTR_ERR(map);\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tfor (y = 0 ; y < plane_info[0].height; y++) {\n\t\t\t\tfor (x = 0 ; x < plane_info[0].width; x++) {\n\t\t\t\t\tunsigned int offset, src_idx;\n\t\t\t\t\tu32 exp = y << 16 | x;\n\t\t\t\t\tu32 val;\n\n\t\t\t\t\tif (*t == I915_GTT_VIEW_ROTATED)\n\t\t\t\t\t\tsrc_idx = rotated_index(&view.rotated, 0, x, y);\n\t\t\t\t\telse\n\t\t\t\t\t\tsrc_idx = remapped_index(&view.remapped, 0, x, y);\n\t\t\t\t\toffset = src_idx * PAGE_SIZE;\n\n\t\t\t\t\tval = ioread32(&map[offset / sizeof(*map)]);\n\t\t\t\t\tif (val != exp) {\n\t\t\t\t\t\tpr_err(\"%s VMA write test failed, expected 0x%x, found 0x%x\\n\",\n\t\t\t\t\t\t       *t == I915_GTT_VIEW_ROTATED ? \"Rotated\" : \"Remapped\",\n\t\t\t\t\t\t       exp, val);\n\t\t\t\t\t\ti915_vma_unpin_iomap(vma);\n\t\t\t\t\t\terr = -EINVAL;\n\t\t\t\t\t\tgoto out;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\ti915_vma_unpin_iomap(vma);\n\n\t\t\tcond_resched();\n\t\t}\n\t}\n\nout:\n\tintel_runtime_pm_put(&i915->runtime_pm, wakeref);\n\ti915_gem_object_put(obj);\n\n\treturn err;\n}\n\nint i915_vma_live_selftests(struct drm_i915_private *i915)\n{\n\tstatic const struct i915_subtest tests[] = {\n\t\tSUBTEST(igt_vma_remapped_gtt),\n\t};\n\n\treturn i915_live_subtests(tests, i915);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}