{
  "module_name": "i915_gem.c",
  "hash_id": "7074a0c90e193abf30fdd69cbd457121d72039cef001fcd378733127d2e7090b",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/i915/selftests/i915_gem.c",
  "human_readable_source": " \n\n#include <linux/random.h>\n\n#include \"gem/i915_gem_internal.h\"\n#include \"gem/i915_gem_pm.h\"\n#include \"gem/selftests/igt_gem_utils.h\"\n#include \"gem/selftests/mock_context.h\"\n#include \"gt/intel_gt.h\"\n#include \"gt/intel_gt_pm.h\"\n\n#include \"i915_selftest.h\"\n\n#include \"igt_flush_test.h\"\n#include \"mock_drm.h\"\n\nstatic int switch_to_context(struct i915_gem_context *ctx)\n{\n\tstruct i915_gem_engines_iter it;\n\tstruct intel_context *ce;\n\tint err = 0;\n\n\tfor_each_gem_engine(ce, i915_gem_context_lock_engines(ctx), it) {\n\t\tstruct i915_request *rq;\n\n\t\trq = intel_context_create_request(ce);\n\t\tif (IS_ERR(rq)) {\n\t\t\terr = PTR_ERR(rq);\n\t\t\tbreak;\n\t\t}\n\n\t\ti915_request_add(rq);\n\t}\n\ti915_gem_context_unlock_engines(ctx);\n\n\treturn err;\n}\n\nstatic void trash_stolen(struct drm_i915_private *i915)\n{\n\tstruct i915_ggtt *ggtt = to_gt(i915)->ggtt;\n\tconst u64 slot = ggtt->error_capture.start;\n\tconst resource_size_t size = resource_size(&i915->dsm.stolen);\n\tunsigned long page;\n\tu32 prng = 0x12345678;\n\n\t \n\tif (!i915_ggtt_has_aperture(ggtt))\n\t\treturn;\n\n\tfor (page = 0; page < size; page += PAGE_SIZE) {\n\t\tconst dma_addr_t dma = i915->dsm.stolen.start + page;\n\t\tu32 __iomem *s;\n\t\tint x;\n\n\t\tggtt->vm.insert_page(&ggtt->vm, dma, slot,\n\t\t\t\t     i915_gem_get_pat_index(i915,\n\t\t\t\t\t\t\t    I915_CACHE_NONE),\n\t\t\t\t     0);\n\n\t\ts = io_mapping_map_atomic_wc(&ggtt->iomap, slot);\n\t\tfor (x = 0; x < PAGE_SIZE / sizeof(u32); x++) {\n\t\t\tprng = next_pseudo_random32(prng);\n\t\t\tiowrite32(prng, &s[x]);\n\t\t}\n\t\tio_mapping_unmap_atomic(s);\n\t}\n\n\tggtt->vm.clear_range(&ggtt->vm, slot, PAGE_SIZE);\n}\n\nstatic void simulate_hibernate(struct drm_i915_private *i915)\n{\n\tintel_wakeref_t wakeref;\n\n\twakeref = intel_runtime_pm_get(&i915->runtime_pm);\n\n\t \n\ttrash_stolen(i915);\n\n\tintel_runtime_pm_put(&i915->runtime_pm, wakeref);\n}\n\nstatic int igt_pm_prepare(struct drm_i915_private *i915)\n{\n\ti915_gem_suspend(i915);\n\n\treturn 0;\n}\n\nstatic void igt_pm_suspend(struct drm_i915_private *i915)\n{\n\tintel_wakeref_t wakeref;\n\n\twith_intel_runtime_pm(&i915->runtime_pm, wakeref) {\n\t\ti915_ggtt_suspend(to_gt(i915)->ggtt);\n\t\ti915_gem_suspend_late(i915);\n\t}\n}\n\nstatic void igt_pm_hibernate(struct drm_i915_private *i915)\n{\n\tintel_wakeref_t wakeref;\n\n\twith_intel_runtime_pm(&i915->runtime_pm, wakeref) {\n\t\ti915_ggtt_suspend(to_gt(i915)->ggtt);\n\n\t\ti915_gem_freeze(i915);\n\t\ti915_gem_freeze_late(i915);\n\t}\n}\n\nstatic void igt_pm_resume(struct drm_i915_private *i915)\n{\n\tintel_wakeref_t wakeref;\n\n\t \n\twith_intel_runtime_pm(&i915->runtime_pm, wakeref) {\n\t\ti915_ggtt_resume(to_gt(i915)->ggtt);\n\t\tif (GRAPHICS_VER(i915) >= 8)\n\t\t\tsetup_private_pat(to_gt(i915));\n\t\ti915_gem_resume(i915);\n\t}\n}\n\nstatic int igt_gem_suspend(void *arg)\n{\n\tstruct drm_i915_private *i915 = arg;\n\tstruct i915_gem_context *ctx;\n\tstruct file *file;\n\tint err;\n\n\tfile = mock_file(i915);\n\tif (IS_ERR(file))\n\t\treturn PTR_ERR(file);\n\n\terr = -ENOMEM;\n\tctx = live_context(i915, file);\n\tif (!IS_ERR(ctx))\n\t\terr = switch_to_context(ctx);\n\tif (err)\n\t\tgoto out;\n\n\terr = igt_pm_prepare(i915);\n\tif (err)\n\t\tgoto out;\n\n\tigt_pm_suspend(i915);\n\n\t \n\tsimulate_hibernate(i915);\n\n\tigt_pm_resume(i915);\n\n\terr = switch_to_context(ctx);\nout:\n\tfput(file);\n\treturn err;\n}\n\nstatic int igt_gem_hibernate(void *arg)\n{\n\tstruct drm_i915_private *i915 = arg;\n\tstruct i915_gem_context *ctx;\n\tstruct file *file;\n\tint err;\n\n\tfile = mock_file(i915);\n\tif (IS_ERR(file))\n\t\treturn PTR_ERR(file);\n\n\terr = -ENOMEM;\n\tctx = live_context(i915, file);\n\tif (!IS_ERR(ctx))\n\t\terr = switch_to_context(ctx);\n\tif (err)\n\t\tgoto out;\n\n\terr = igt_pm_prepare(i915);\n\tif (err)\n\t\tgoto out;\n\n\tigt_pm_hibernate(i915);\n\n\t \n\tsimulate_hibernate(i915);\n\n\tigt_pm_resume(i915);\n\n\terr = switch_to_context(ctx);\nout:\n\tfput(file);\n\treturn err;\n}\n\nstatic int igt_gem_ww_ctx(void *arg)\n{\n\tstruct drm_i915_private *i915 = arg;\n\tstruct drm_i915_gem_object *obj, *obj2;\n\tstruct i915_gem_ww_ctx ww;\n\tint err = 0;\n\n\tobj = i915_gem_object_create_internal(i915, PAGE_SIZE);\n\tif (IS_ERR(obj))\n\t\treturn PTR_ERR(obj);\n\n\tobj2 = i915_gem_object_create_internal(i915, PAGE_SIZE);\n\tif (IS_ERR(obj2)) {\n\t\terr = PTR_ERR(obj2);\n\t\tgoto put1;\n\t}\n\n\ti915_gem_ww_ctx_init(&ww, true);\nretry:\n\t \n\terr = i915_gem_object_lock(obj, &ww);\n\tif (!err)\n\t\terr = i915_gem_object_lock_interruptible(obj, &ww);\n\tif (!err)\n\t\terr = i915_gem_object_lock_interruptible(obj2, &ww);\n\tif (!err)\n\t\terr = i915_gem_object_lock(obj2, &ww);\n\n\tif (err == -EDEADLK) {\n\t\terr = i915_gem_ww_ctx_backoff(&ww);\n\t\tif (!err)\n\t\t\tgoto retry;\n\t}\n\ti915_gem_ww_ctx_fini(&ww);\n\ti915_gem_object_put(obj2);\nput1:\n\ti915_gem_object_put(obj);\n\treturn err;\n}\n\nint i915_gem_live_selftests(struct drm_i915_private *i915)\n{\n\tstatic const struct i915_subtest tests[] = {\n\t\tSUBTEST(igt_gem_suspend),\n\t\tSUBTEST(igt_gem_hibernate),\n\t\tSUBTEST(igt_gem_ww_ctx),\n\t};\n\n\tif (intel_gt_is_wedged(to_gt(i915)))\n\t\treturn 0;\n\n\treturn i915_live_subtests(tests, i915);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}