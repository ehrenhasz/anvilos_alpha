{
  "module_name": "i915_random.c",
  "hash_id": "ef19b07ac397407b0acdad57f32ea5cb24dc247b6b8bd799a0199299abee6a20",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/i915/selftests/i915_random.c",
  "human_readable_source": " \n\n#include <linux/bitops.h>\n#include <linux/kernel.h>\n#include <linux/random.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\n#include \"i915_random.h\"\n#include \"i915_utils.h\"\n\nu64 i915_prandom_u64_state(struct rnd_state *rnd)\n{\n\tu64 x;\n\n\tx = prandom_u32_state(rnd);\n\tx <<= 32;\n\tx |= prandom_u32_state(rnd);\n\n\treturn x;\n}\n\nvoid i915_prandom_shuffle(void *arr, size_t elsz, size_t count,\n\t\t\t  struct rnd_state *state)\n{\n\tchar stack[128];\n\n\tif (WARN_ON(elsz > sizeof(stack) || count > U32_MAX))\n\t\treturn;\n\n\tif (!elsz || !count)\n\t\treturn;\n\n\t \n\twhile (--count) {\n\t\tsize_t swp;\n\n\t\tswp = i915_prandom_u32_max_state(count + 1, state);\n\t\tif (swp == count)\n\t\t\tcontinue;\n\n\t\tmemcpy(stack, arr + count * elsz, elsz);\n\t\tmemcpy(arr + count * elsz, arr + swp * elsz, elsz);\n\t\tmemcpy(arr + swp * elsz, stack, elsz);\n\t}\n}\n\nvoid i915_random_reorder(unsigned int *order, unsigned int count,\n\t\t\t struct rnd_state *state)\n{\n\ti915_prandom_shuffle(order, sizeof(*order), count, state);\n}\n\nunsigned int *i915_random_order(unsigned int count, struct rnd_state *state)\n{\n\tunsigned int *order, i;\n\n\torder = kmalloc_array(count, sizeof(*order),\n\t\t\t      GFP_KERNEL | __GFP_RETRY_MAYFAIL | __GFP_NOWARN);\n\tif (!order)\n\t\treturn order;\n\n\tfor (i = 0; i < count; i++)\n\t\torder[i] = i;\n\n\ti915_random_reorder(order, count, state);\n\treturn order;\n}\n\nu64 igt_random_offset(struct rnd_state *state,\n\t\t      u64 start, u64 end,\n\t\t      u64 len, u64 align)\n{\n\tu64 range, addr;\n\n\tBUG_ON(range_overflows(start, len, end));\n\tBUG_ON(round_up(start, align) > round_down(end - len, align));\n\n\trange = round_down(end - len, align) - round_up(start, align);\n\tif (range) {\n\t\taddr = i915_prandom_u64_state(state);\n\t\tdiv64_u64_rem(addr, range, &addr);\n\t\tstart += addr;\n\t}\n\n\treturn round_up(start, align);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}