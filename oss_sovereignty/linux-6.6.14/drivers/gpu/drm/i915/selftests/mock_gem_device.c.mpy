{
  "module_name": "mock_gem_device.c",
  "hash_id": "e87f39e359c9f9d68804acdcb1b202042b0be745d21f43fb52bef43791af3221",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/i915/selftests/mock_gem_device.c",
  "human_readable_source": " \n\n#include <linux/pm_domain.h>\n#include <linux/pm_runtime.h>\n#include <linux/iommu.h>\n\n#include <drm/drm_managed.h>\n\n#include \"gt/intel_gt.h\"\n#include \"gt/intel_gt_requests.h\"\n#include \"gt/mock_engine.h\"\n#include \"intel_memory_region.h\"\n#include \"intel_region_ttm.h\"\n\n#include \"mock_request.h\"\n#include \"mock_gem_device.h\"\n#include \"mock_gtt.h\"\n#include \"mock_uncore.h\"\n#include \"mock_region.h\"\n\n#include \"gem/selftests/mock_context.h\"\n#include \"gem/selftests/mock_gem_object.h\"\n\nvoid mock_device_flush(struct drm_i915_private *i915)\n{\n\tstruct intel_gt *gt = to_gt(i915);\n\tstruct intel_engine_cs *engine;\n\tenum intel_engine_id id;\n\n\tdo {\n\t\tfor_each_engine(engine, gt, id)\n\t\t\tmock_engine_flush(engine);\n\t} while (intel_gt_retire_requests_timeout(gt, MAX_SCHEDULE_TIMEOUT,\n\t\t\t\t\t\t  NULL));\n}\n\nstatic void mock_device_release(struct drm_device *dev)\n{\n\tstruct drm_i915_private *i915 = to_i915(dev);\n\n\tif (!i915->do_release)\n\t\tgoto out;\n\n\tmock_device_flush(i915);\n\tintel_gt_driver_remove(to_gt(i915));\n\n\ti915_gem_drain_workqueue(i915);\n\n\tmock_fini_ggtt(to_gt(i915)->ggtt);\n\tdestroy_workqueue(i915->unordered_wq);\n\tdestroy_workqueue(i915->wq);\n\n\tintel_region_ttm_device_fini(i915);\n\tintel_gt_driver_late_release_all(i915);\n\tintel_memory_regions_driver_release(i915);\n\n\tdrm_mode_config_cleanup(&i915->drm);\n\nout:\n\ti915_params_free(&i915->params);\n}\n\nstatic const struct drm_driver mock_driver = {\n\t.name = \"mock\",\n\t.driver_features = DRIVER_GEM,\n\t.release = mock_device_release,\n};\n\nstatic void release_dev(struct device *dev)\n{\n\tstruct pci_dev *pdev = to_pci_dev(dev);\n\n\tkfree(pdev);\n}\n\nstatic int pm_domain_resume(struct device *dev)\n{\n\treturn pm_generic_runtime_resume(dev);\n}\n\nstatic int pm_domain_suspend(struct device *dev)\n{\n\treturn pm_generic_runtime_suspend(dev);\n}\n\nstatic struct dev_pm_domain pm_domain = {\n\t.ops = {\n\t\t.runtime_suspend = pm_domain_suspend,\n\t\t.runtime_resume = pm_domain_resume,\n\t},\n};\n\nstatic void mock_gt_probe(struct drm_i915_private *i915)\n{\n\ti915->gt[0] = to_gt(i915);\n\ti915->gt[0]->name = \"Mock GT\";\n}\n\nstatic const struct intel_device_info mock_info = {\n\t.__runtime.graphics.ip.ver = -1,\n\t.__runtime.page_sizes = (I915_GTT_PAGE_SIZE_4K |\n\t\t\t\t I915_GTT_PAGE_SIZE_64K |\n\t\t\t\t I915_GTT_PAGE_SIZE_2M),\n\t.memory_regions = REGION_SMEM,\n\t.platform_engine_mask = BIT(0),\n\n\t \n\t.max_pat_index = 3,\n\t.cachelevel_to_pat = {\n\t\t[I915_CACHE_NONE]   = 0,\n\t\t[I915_CACHE_LLC]    = 1,\n\t\t[I915_CACHE_L3_LLC] = 2,\n\t\t[I915_CACHE_WT]     = 3,\n\t},\n};\n\nstruct drm_i915_private *mock_gem_device(void)\n{\n#if IS_ENABLED(CONFIG_IOMMU_API) && defined(CONFIG_INTEL_IOMMU)\n\tstatic struct dev_iommu fake_iommu = { .priv = (void *)-1 };\n#endif\n\tstruct drm_i915_private *i915;\n\tstruct pci_dev *pdev;\n\tint ret;\n\n\tpdev = kzalloc(sizeof(*pdev), GFP_KERNEL);\n\tif (!pdev)\n\t\treturn NULL;\n\tdevice_initialize(&pdev->dev);\n\tpdev->class = PCI_BASE_CLASS_DISPLAY << 16;\n\tpdev->dev.release = release_dev;\n\tdev_set_name(&pdev->dev, \"mock\");\n\tdma_coerce_mask_and_coherent(&pdev->dev, DMA_BIT_MASK(64));\n\n#if IS_ENABLED(CONFIG_IOMMU_API) && defined(CONFIG_INTEL_IOMMU)\n\t \n\tpdev->dev.iommu = &fake_iommu;\n#endif\n\tif (!devres_open_group(&pdev->dev, NULL, GFP_KERNEL)) {\n\t\tput_device(&pdev->dev);\n\t\treturn NULL;\n\t}\n\n\ti915 = devm_drm_dev_alloc(&pdev->dev, &mock_driver,\n\t\t\t\t  struct drm_i915_private, drm);\n\tif (IS_ERR(i915)) {\n\t\tpr_err(\"Failed to allocate mock GEM device: err=%ld\\n\", PTR_ERR(i915));\n\t\tdevres_release_group(&pdev->dev, NULL);\n\t\tput_device(&pdev->dev);\n\n\t\treturn NULL;\n\t}\n\n\tpci_set_drvdata(pdev, i915);\n\n\t \n\ti915_params_copy(&i915->params, &i915_modparams);\n\n\t \n\tintel_device_info_driver_create(i915, pdev->device, &mock_info);\n\n\tdev_pm_domain_set(&pdev->dev, &pm_domain);\n\tpm_runtime_enable(&pdev->dev);\n\tpm_runtime_dont_use_autosuspend(&pdev->dev);\n\tif (pm_runtime_enabled(&pdev->dev))\n\t\tWARN_ON(pm_runtime_get_sync(&pdev->dev));\n\n\tintel_runtime_pm_init_early(&i915->runtime_pm);\n\t \n\ti915->runtime_pm.no_wakeref_tracking = true;\n\n\t \n\tdrm_mode_config_init(&i915->drm);\n\n\tintel_memory_regions_hw_probe(i915);\n\n\tspin_lock_init(&i915->gpu_error.lock);\n\n\ti915_gem_init__mm(i915);\n\tintel_root_gt_init_early(i915);\n\tmock_uncore_init(&i915->uncore, i915);\n\tatomic_inc(&to_gt(i915)->wakeref.count);  \n\tto_gt(i915)->awake = -ENODEV;\n\tmock_gt_probe(i915);\n\n\tret = intel_region_ttm_device_init(i915);\n\tif (ret)\n\t\tgoto err_ttm;\n\n\ti915->wq = alloc_ordered_workqueue(\"mock\", 0);\n\tif (!i915->wq)\n\t\tgoto err_drv;\n\n\ti915->unordered_wq = alloc_workqueue(\"mock-unordered\", 0, 0);\n\tif (!i915->unordered_wq)\n\t\tgoto err_wq;\n\n\tmock_init_contexts(i915);\n\n\t \n\tret = intel_gt_assign_ggtt(to_gt(i915));\n\tif (ret)\n\t\tgoto err_unlock;\n\n\tmock_init_ggtt(to_gt(i915));\n\tto_gt(i915)->vm = i915_vm_get(&to_gt(i915)->ggtt->vm);\n\n\tto_gt(i915)->info.engine_mask = BIT(0);\n\n\tto_gt(i915)->engine[RCS0] = mock_engine(i915, \"mock\", RCS0);\n\tif (!to_gt(i915)->engine[RCS0])\n\t\tgoto err_unlock;\n\n\tif (mock_engine_init(to_gt(i915)->engine[RCS0]))\n\t\tgoto err_context;\n\n\t__clear_bit(I915_WEDGED, &to_gt(i915)->reset.flags);\n\tintel_engines_driver_register(i915);\n\n\ti915->do_release = true;\n\tida_init(&i915->selftest.mock_region_instances);\n\n\treturn i915;\n\nerr_context:\n\tintel_gt_driver_remove(to_gt(i915));\nerr_unlock:\n\tdestroy_workqueue(i915->unordered_wq);\nerr_wq:\n\tdestroy_workqueue(i915->wq);\nerr_drv:\n\tintel_region_ttm_device_fini(i915);\nerr_ttm:\n\tintel_gt_driver_late_release_all(i915);\n\tintel_memory_regions_driver_release(i915);\n\tdrm_mode_config_cleanup(&i915->drm);\n\tmock_destroy_device(i915);\n\n\treturn NULL;\n}\n\nvoid mock_destroy_device(struct drm_i915_private *i915)\n{\n\tstruct device *dev = i915->drm.dev;\n\n\tdevres_release_group(dev, NULL);\n\tput_device(dev);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}