{
  "module_name": "intel_uncore.c",
  "hash_id": "38f1b1d2a251b95cc279aae68ec7d047ef4b6bc1631a925633431c090e664bed",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/i915/selftests/intel_uncore.c",
  "human_readable_source": " \n\n#include \"../i915_selftest.h\"\n\nstatic int intel_fw_table_check(const struct intel_forcewake_range *ranges,\n\t\t\t\tunsigned int num_ranges,\n\t\t\t\tbool is_watertight)\n{\n\tunsigned int i;\n\ts32 prev;\n\n\tfor (i = 0, prev = -1; i < num_ranges; i++, ranges++) {\n\t\t \n\t\tif (is_watertight && (prev + 1) != (s32)ranges->start) {\n\t\t\tpr_err(\"%s: entry[%d]:(%x, %x) is not watertight to previous (%x)\\n\",\n\t\t\t       __func__, i, ranges->start, ranges->end, prev);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\t \n\t\tif (prev >= (s32)ranges->start) {\n\t\t\tpr_err(\"%s: entry[%d]:(%x, %x) is less than the previous (%x)\\n\",\n\t\t\t       __func__, i, ranges->start, ranges->end, prev);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\t \n\t\tif (ranges->start >= ranges->end) {\n\t\t\tpr_err(\"%s: entry[%d]:(%x, %x) has negative length\\n\",\n\t\t\t       __func__, i, ranges->start, ranges->end);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tprev = ranges->end;\n\t}\n\n\treturn 0;\n}\n\nstatic int intel_shadow_table_check(void)\n{\n\tstruct {\n\t\tconst struct i915_range *regs;\n\t\tunsigned int size;\n\t} range_lists[] = {\n\t\t{ gen8_shadowed_regs, ARRAY_SIZE(gen8_shadowed_regs) },\n\t\t{ gen11_shadowed_regs, ARRAY_SIZE(gen11_shadowed_regs) },\n\t\t{ gen12_shadowed_regs, ARRAY_SIZE(gen12_shadowed_regs) },\n\t\t{ dg2_shadowed_regs, ARRAY_SIZE(dg2_shadowed_regs) },\n\t\t{ pvc_shadowed_regs, ARRAY_SIZE(pvc_shadowed_regs) },\n\t\t{ mtl_shadowed_regs, ARRAY_SIZE(mtl_shadowed_regs) },\n\t\t{ xelpmp_shadowed_regs, ARRAY_SIZE(xelpmp_shadowed_regs) },\n\t};\n\tconst struct i915_range *range;\n\tunsigned int i, j;\n\ts32 prev;\n\n\tfor (j = 0; j < ARRAY_SIZE(range_lists); ++j) {\n\t\trange = range_lists[j].regs;\n\t\tfor (i = 0, prev = -1; i < range_lists[j].size; i++, range++) {\n\t\t\tif (range->end < range->start) {\n\t\t\t\tpr_err(\"%s: range[%d]:(%06x-%06x) has end before start\\n\",\n\t\t\t\t       __func__, i, range->start, range->end);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\n\t\t\tif (prev >= (s32)range->start) {\n\t\t\t\tpr_err(\"%s: range[%d]:(%06x-%06x) is before end of previous (%06x)\\n\",\n\t\t\t\t       __func__, i, range->start, range->end, prev);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\n\t\t\tif (range->start % 4) {\n\t\t\t\tpr_err(\"%s: range[%d]:(%06x-%06x) has non-dword-aligned start\\n\",\n\t\t\t\t       __func__, i, range->start, range->end);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\n\t\t\tprev = range->end;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nint intel_uncore_mock_selftests(void)\n{\n\tstruct {\n\t\tconst struct intel_forcewake_range *ranges;\n\t\tunsigned int num_ranges;\n\t\tbool is_watertight;\n\t} fw[] = {\n\t\t{ __vlv_fw_ranges, ARRAY_SIZE(__vlv_fw_ranges), false },\n\t\t{ __chv_fw_ranges, ARRAY_SIZE(__chv_fw_ranges), false },\n\t\t{ __gen9_fw_ranges, ARRAY_SIZE(__gen9_fw_ranges), true },\n\t\t{ __gen11_fw_ranges, ARRAY_SIZE(__gen11_fw_ranges), true },\n\t\t{ __gen12_fw_ranges, ARRAY_SIZE(__gen12_fw_ranges), true },\n\t\t{ __xehp_fw_ranges, ARRAY_SIZE(__xehp_fw_ranges), true },\n\t\t{ __pvc_fw_ranges, ARRAY_SIZE(__pvc_fw_ranges), true },\n\t\t{ __mtl_fw_ranges, ARRAY_SIZE(__mtl_fw_ranges), true },\n\t\t{ __xelpmp_fw_ranges, ARRAY_SIZE(__xelpmp_fw_ranges), true },\n\t};\n\tint err, i;\n\n\tfor (i = 0; i < ARRAY_SIZE(fw); i++) {\n\t\terr = intel_fw_table_check(fw[i].ranges,\n\t\t\t\t\t   fw[i].num_ranges,\n\t\t\t\t\t   fw[i].is_watertight);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\terr = intel_shadow_table_check();\n\tif (err)\n\t\treturn err;\n\n\treturn 0;\n}\n\nstatic int live_forcewake_ops(void *arg)\n{\n\tstatic const struct reg {\n\t\tconst char *name;\n\t\tu8 min_graphics_ver;\n\t\tu8 max_graphics_ver;\n\t\tunsigned long platforms;\n\t\tunsigned int offset;\n\t} registers[] = {\n\t\t{\n\t\t\t\"RING_START\",\n\t\t\t6, 7,\n\t\t\t0x38,\n\t\t},\n\t\t{\n\t\t\t\"RING_MI_MODE\",\n\t\t\t8, U8_MAX,\n\t\t\t0x9c,\n\t\t}\n\t};\n\tconst struct reg *r;\n\tstruct intel_gt *gt = arg;\n\tstruct intel_uncore_forcewake_domain *domain;\n\tstruct intel_uncore *uncore = gt->uncore;\n\tstruct intel_engine_cs *engine;\n\tenum intel_engine_id id;\n\tintel_wakeref_t wakeref;\n\tunsigned int tmp;\n\tint err = 0;\n\n\tGEM_BUG_ON(gt->awake);\n\n\t \n\tif (IS_VALLEYVIEW(gt->i915) || IS_CHERRYVIEW(gt->i915)) {\n\t\tpr_debug(\"PCU fakes forcewake badly; skipping\\n\");\n\t\treturn 0;\n\t}\n\n\t \n\tif (!IS_ENABLED(CONFIG_DRM_I915_SELFTEST_BROKEN))\n\t\treturn 0;\n\n\t \n\tfor (r = registers; r->name; r++)\n\t\tif (IS_GRAPHICS_VER(gt->i915, r->min_graphics_ver, r->max_graphics_ver))\n\t\t\tbreak;\n\tif (!r->name) {\n\t\tpr_debug(\"Forcewaked register not known for %s; skipping\\n\",\n\t\t\t intel_platform_name(INTEL_INFO(gt->i915)->platform));\n\t\treturn 0;\n\t}\n\n\twakeref = intel_runtime_pm_get(uncore->rpm);\n\n\tfor_each_fw_domain(domain, uncore, tmp) {\n\t\tsmp_store_mb(domain->active, false);\n\t\tif (!hrtimer_cancel(&domain->timer))\n\t\t\tcontinue;\n\n\t\tintel_uncore_fw_release_timer(&domain->timer);\n\t}\n\n\tfor_each_engine(engine, gt, id) {\n\t\ti915_reg_t mmio = _MMIO(engine->mmio_base + r->offset);\n\t\tu32 __iomem *reg = intel_uncore_regs(uncore) + engine->mmio_base + r->offset;\n\t\tenum forcewake_domains fw_domains;\n\t\tu32 val;\n\n\t\tif (!engine->default_state)\n\t\t\tcontinue;\n\n\t\tfw_domains = intel_uncore_forcewake_for_reg(uncore, mmio,\n\t\t\t\t\t\t\t    FW_REG_READ);\n\t\tif (!fw_domains)\n\t\t\tcontinue;\n\n\t\tfor_each_fw_domain_masked(domain, fw_domains, uncore, tmp) {\n\t\t\tif (!domain->wake_count)\n\t\t\t\tcontinue;\n\n\t\t\tpr_err(\"fw_domain %s still active, aborting test!\\n\",\n\t\t\t       intel_uncore_forcewake_domain_to_str(domain->id));\n\t\t\terr = -EINVAL;\n\t\t\tgoto out_rpm;\n\t\t}\n\n\t\tintel_uncore_forcewake_get(uncore, fw_domains);\n\t\tval = readl(reg);\n\t\tintel_uncore_forcewake_put(uncore, fw_domains);\n\n\t\t \n\t\tfor_each_fw_domain_masked(domain, fw_domains, uncore, tmp) {\n\t\t\tsmp_store_mb(domain->active, false);\n\t\t\tif (hrtimer_cancel(&domain->timer))\n\t\t\t\tintel_uncore_fw_release_timer(&domain->timer);\n\n\t\t\tpreempt_disable();\n\t\t\terr = wait_ack_clear(domain, FORCEWAKE_KERNEL);\n\t\t\tpreempt_enable();\n\t\t\tif (err) {\n\t\t\t\tpr_err(\"Failed to clear fw_domain %s\\n\",\n\t\t\t\t       intel_uncore_forcewake_domain_to_str(domain->id));\n\t\t\t\tgoto out_rpm;\n\t\t\t}\n\t\t}\n\n\t\tif (!val) {\n\t\t\tpr_err(\"%s:%s was zero while fw was held!\\n\",\n\t\t\t       engine->name, r->name);\n\t\t\terr = -EINVAL;\n\t\t\tgoto out_rpm;\n\t\t}\n\n\t\t \n\t\tif (wait_for(readl(reg) == 0, 100)) {\n\t\t\tpr_err(\"%s:%s=%0x, fw_domains 0x%x still up after 100ms!\\n\",\n\t\t\t       engine->name, r->name, readl(reg), fw_domains);\n\t\t\terr = -ETIMEDOUT;\n\t\t\tgoto out_rpm;\n\t\t}\n\t}\n\nout_rpm:\n\tintel_runtime_pm_put(uncore->rpm, wakeref);\n\treturn err;\n}\n\nstatic int live_forcewake_domains(void *arg)\n{\n#define FW_RANGE 0x40000\n\tstruct intel_gt *gt = arg;\n\tstruct intel_uncore *uncore = gt->uncore;\n\tunsigned long *valid;\n\tu32 offset;\n\tint err;\n\n\tif (!HAS_FPGA_DBG_UNCLAIMED(gt->i915) &&\n\t    !IS_VALLEYVIEW(gt->i915) &&\n\t    !IS_CHERRYVIEW(gt->i915))\n\t\treturn 0;\n\n\t \n\tif (!IS_ENABLED(CONFIG_DRM_I915_SELFTEST_BROKEN))\n\t\treturn 0;\n\n\tvalid = bitmap_zalloc(FW_RANGE, GFP_KERNEL);\n\tif (!valid)\n\t\treturn -ENOMEM;\n\n\tintel_uncore_forcewake_get(uncore, FORCEWAKE_ALL);\n\n\tcheck_for_unclaimed_mmio(uncore);\n\tfor (offset = 0; offset < FW_RANGE; offset += 4) {\n\t\ti915_reg_t reg = { offset };\n\n\t\tintel_uncore_posting_read_fw(uncore, reg);\n\t\tif (!check_for_unclaimed_mmio(uncore))\n\t\t\tset_bit(offset, valid);\n\t}\n\n\tintel_uncore_forcewake_put(uncore, FORCEWAKE_ALL);\n\n\terr = 0;\n\tfor_each_set_bit(offset, valid, FW_RANGE) {\n\t\ti915_reg_t reg = { offset };\n\n\t\tiosf_mbi_punit_acquire();\n\t\tintel_uncore_forcewake_reset(uncore);\n\t\tiosf_mbi_punit_release();\n\n\t\tcheck_for_unclaimed_mmio(uncore);\n\n\t\tintel_uncore_posting_read_fw(uncore, reg);\n\t\tif (check_for_unclaimed_mmio(uncore)) {\n\t\t\tpr_err(\"Unclaimed mmio read to register 0x%04x\\n\",\n\t\t\t       offset);\n\t\t\terr = -EINVAL;\n\t\t}\n\t}\n\n\tbitmap_free(valid);\n\treturn err;\n}\n\nstatic int live_fw_table(void *arg)\n{\n\tstruct intel_gt *gt = arg;\n\n\t \n\treturn intel_fw_table_check(gt->uncore->fw_domains_table,\n\t\t\t\t    gt->uncore->fw_domains_table_entries,\n\t\t\t\t    GRAPHICS_VER(gt->i915) >= 9);\n}\n\nint intel_uncore_live_selftests(struct drm_i915_private *i915)\n{\n\tstatic const struct i915_subtest tests[] = {\n\t\tSUBTEST(live_fw_table),\n\t\tSUBTEST(live_forcewake_ops),\n\t\tSUBTEST(live_forcewake_domains),\n\t};\n\n\treturn intel_gt_live_subtests(tests, to_gt(i915));\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}