{
  "module_name": "i915_gem_evict.c",
  "hash_id": "9b541c4f25048d536cb0da692d87208b02c56225d580e347d5ebe0d63c3a07b7",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/i915/selftests/i915_gem_evict.c",
  "human_readable_source": " \n\n#include \"gem/i915_gem_internal.h\"\n#include \"gem/i915_gem_pm.h\"\n#include \"gem/selftests/igt_gem_utils.h\"\n#include \"gem/selftests/mock_context.h\"\n#include \"gt/intel_gt.h\"\n#include \"gt/intel_gt_print.h\"\n\n#include \"i915_selftest.h\"\n\n#include \"igt_flush_test.h\"\n#include \"lib_sw_fence.h\"\n#include \"mock_drm.h\"\n#include \"mock_gem_device.h\"\n\nstatic void quirk_add(struct drm_i915_gem_object *obj,\n\t\t      struct list_head *objects)\n{\n\t \n\tGEM_BUG_ON(i915_gem_object_has_tiling_quirk(obj));\n\ti915_gem_object_set_tiling_quirk(obj);\n\tlist_add(&obj->st_link, objects);\n}\n\nstatic int populate_ggtt(struct i915_ggtt *ggtt, struct list_head *objects)\n{\n\tstruct drm_i915_gem_object *obj;\n\tunsigned long count;\n\n\tcount = 0;\n\tdo {\n\t\tstruct i915_vma *vma;\n\n\t\tobj = i915_gem_object_create_internal(ggtt->vm.i915,\n\t\t\t\t\t\t      I915_GTT_PAGE_SIZE);\n\t\tif (IS_ERR(obj))\n\t\t\treturn PTR_ERR(obj);\n\n\t\tvma = i915_gem_object_ggtt_pin(obj, NULL, 0, 0, 0);\n\t\tif (IS_ERR(vma)) {\n\t\t\ti915_gem_object_put(obj);\n\t\t\tif (vma == ERR_PTR(-ENOSPC))\n\t\t\t\tbreak;\n\n\t\t\treturn PTR_ERR(vma);\n\t\t}\n\n\t\tquirk_add(obj, objects);\n\t\tcount++;\n\t} while (1);\n\tpr_debug(\"Filled GGTT with %lu pages [%llu total]\\n\",\n\t\t count, ggtt->vm.total / PAGE_SIZE);\n\n\tif (list_empty(&ggtt->vm.bound_list)) {\n\t\tpr_err(\"No objects on the GGTT inactive list!\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic void unpin_ggtt(struct i915_ggtt *ggtt)\n{\n\tstruct i915_vma *vma;\n\n\tlist_for_each_entry(vma, &ggtt->vm.bound_list, vm_link)\n\t\tif (i915_gem_object_has_tiling_quirk(vma->obj))\n\t\t\ti915_vma_unpin(vma);\n}\n\nstatic void cleanup_objects(struct i915_ggtt *ggtt, struct list_head *list)\n{\n\tstruct drm_i915_gem_object *obj, *on;\n\n\tlist_for_each_entry_safe(obj, on, list, st_link) {\n\t\tGEM_BUG_ON(!i915_gem_object_has_tiling_quirk(obj));\n\t\ti915_gem_object_set_tiling_quirk(obj);\n\t\ti915_gem_object_put(obj);\n\t}\n\n\ti915_gem_drain_freed_objects(ggtt->vm.i915);\n}\n\nstatic int igt_evict_something(void *arg)\n{\n\tstruct intel_gt *gt = arg;\n\tstruct i915_ggtt *ggtt = gt->ggtt;\n\tLIST_HEAD(objects);\n\tint err;\n\n\t \n\n\terr = populate_ggtt(ggtt, &objects);\n\tif (err)\n\t\tgoto cleanup;\n\n\t \n\tmutex_lock(&ggtt->vm.mutex);\n\terr = i915_gem_evict_something(&ggtt->vm, NULL,\n\t\t\t\t       I915_GTT_PAGE_SIZE, 0, 0,\n\t\t\t\t       0, U64_MAX,\n\t\t\t\t       0);\n\tmutex_unlock(&ggtt->vm.mutex);\n\tif (err != -ENOSPC) {\n\t\tpr_err(\"i915_gem_evict_something failed on a full GGTT with err=%d\\n\",\n\t\t       err);\n\t\tgoto cleanup;\n\t}\n\n\tunpin_ggtt(ggtt);\n\n\t \n\tmutex_lock(&ggtt->vm.mutex);\n\terr = i915_gem_evict_something(&ggtt->vm, NULL,\n\t\t\t\t       I915_GTT_PAGE_SIZE, 0, 0,\n\t\t\t\t       0, U64_MAX,\n\t\t\t\t       0);\n\tmutex_unlock(&ggtt->vm.mutex);\n\tif (err) {\n\t\tpr_err(\"i915_gem_evict_something failed on a full GGTT with err=%d\\n\",\n\t\t       err);\n\t\tgoto cleanup;\n\t}\n\ncleanup:\n\tcleanup_objects(ggtt, &objects);\n\treturn err;\n}\n\nstatic int igt_overcommit(void *arg)\n{\n\tstruct intel_gt *gt = arg;\n\tstruct i915_ggtt *ggtt = gt->ggtt;\n\tstruct drm_i915_gem_object *obj;\n\tstruct i915_vma *vma;\n\tLIST_HEAD(objects);\n\tint err;\n\n\t \n\n\terr = populate_ggtt(ggtt, &objects);\n\tif (err)\n\t\tgoto cleanup;\n\n\tobj = i915_gem_object_create_internal(gt->i915, I915_GTT_PAGE_SIZE);\n\tif (IS_ERR(obj)) {\n\t\terr = PTR_ERR(obj);\n\t\tgoto cleanup;\n\t}\n\n\tquirk_add(obj, &objects);\n\n\tvma = i915_gem_object_ggtt_pin(obj, NULL, 0, 0, 0);\n\tif (vma != ERR_PTR(-ENOSPC)) {\n\t\tpr_err(\"Failed to evict+insert, i915_gem_object_ggtt_pin returned err=%d\\n\", (int)PTR_ERR_OR_ZERO(vma));\n\t\terr = -EINVAL;\n\t\tgoto cleanup;\n\t}\n\ncleanup:\n\tcleanup_objects(ggtt, &objects);\n\treturn err;\n}\n\nstatic int igt_evict_for_vma(void *arg)\n{\n\tstruct intel_gt *gt = arg;\n\tstruct i915_ggtt *ggtt = gt->ggtt;\n\tstruct drm_mm_node target = {\n\t\t.start = 0,\n\t\t.size = 4096,\n\t};\n\tLIST_HEAD(objects);\n\tint err;\n\n\t \n\n\terr = populate_ggtt(ggtt, &objects);\n\tif (err)\n\t\tgoto cleanup;\n\n\t \n\tmutex_lock(&ggtt->vm.mutex);\n\terr = i915_gem_evict_for_node(&ggtt->vm, NULL, &target, 0);\n\tmutex_unlock(&ggtt->vm.mutex);\n\tif (err != -ENOSPC) {\n\t\tpr_err(\"i915_gem_evict_for_node on a full GGTT returned err=%d\\n\",\n\t\t       err);\n\t\tgoto cleanup;\n\t}\n\n\tunpin_ggtt(ggtt);\n\n\t \n\tmutex_lock(&ggtt->vm.mutex);\n\terr = i915_gem_evict_for_node(&ggtt->vm, NULL, &target, 0);\n\tmutex_unlock(&ggtt->vm.mutex);\n\tif (err) {\n\t\tpr_err(\"i915_gem_evict_for_node returned err=%d\\n\",\n\t\t       err);\n\t\tgoto cleanup;\n\t}\n\ncleanup:\n\tcleanup_objects(ggtt, &objects);\n\treturn err;\n}\n\nstatic void mock_color_adjust(const struct drm_mm_node *node,\n\t\t\t      unsigned long color,\n\t\t\t      u64 *start,\n\t\t\t      u64 *end)\n{\n}\n\nstatic int igt_evict_for_cache_color(void *arg)\n{\n\tstruct intel_gt *gt = arg;\n\tstruct i915_ggtt *ggtt = gt->ggtt;\n\tconst unsigned long flags = PIN_OFFSET_FIXED;\n\tstruct drm_mm_node target = {\n\t\t.start = I915_GTT_PAGE_SIZE * 2,\n\t\t.size = I915_GTT_PAGE_SIZE,\n\t\t.color = i915_gem_get_pat_index(gt->i915, I915_CACHE_LLC),\n\t};\n\tstruct drm_i915_gem_object *obj;\n\tstruct i915_vma *vma;\n\tLIST_HEAD(objects);\n\tint err;\n\n\t \n\tggtt->vm.mm.color_adjust = mock_color_adjust;\n\tGEM_BUG_ON(!i915_vm_has_cache_coloring(&ggtt->vm));\n\n\tobj = i915_gem_object_create_internal(gt->i915, I915_GTT_PAGE_SIZE);\n\tif (IS_ERR(obj)) {\n\t\terr = PTR_ERR(obj);\n\t\tgoto cleanup;\n\t}\n\ti915_gem_object_set_cache_coherency(obj, I915_CACHE_LLC);\n\tquirk_add(obj, &objects);\n\n\tvma = i915_gem_object_ggtt_pin(obj, NULL, 0, 0,\n\t\t\t\t       I915_GTT_PAGE_SIZE | flags);\n\tif (IS_ERR(vma)) {\n\t\tpr_err(\"[0]i915_gem_object_ggtt_pin failed\\n\");\n\t\terr = PTR_ERR(vma);\n\t\tgoto cleanup;\n\t}\n\n\tobj = i915_gem_object_create_internal(gt->i915, I915_GTT_PAGE_SIZE);\n\tif (IS_ERR(obj)) {\n\t\terr = PTR_ERR(obj);\n\t\tgoto cleanup;\n\t}\n\ti915_gem_object_set_cache_coherency(obj, I915_CACHE_LLC);\n\tquirk_add(obj, &objects);\n\n\t \n\tvma = i915_gem_object_ggtt_pin(obj, NULL, 0, 0,\n\t\t\t\t       (I915_GTT_PAGE_SIZE * 2) | flags);\n\tif (IS_ERR(vma)) {\n\t\tpr_err(\"[1]i915_gem_object_ggtt_pin failed\\n\");\n\t\terr = PTR_ERR(vma);\n\t\tgoto cleanup;\n\t}\n\n\ti915_vma_unpin(vma);\n\n\t \n\tmutex_lock(&ggtt->vm.mutex);\n\terr = i915_gem_evict_for_node(&ggtt->vm, NULL, &target, 0);\n\tmutex_unlock(&ggtt->vm.mutex);\n\tif (err) {\n\t\tpr_err(\"[0]i915_gem_evict_for_node returned err=%d\\n\", err);\n\t\tgoto cleanup;\n\t}\n\n\t \n\ttarget.color = i915_gem_get_pat_index(gt->i915, I915_CACHE_L3_LLC);\n\n\tmutex_lock(&ggtt->vm.mutex);\n\terr = i915_gem_evict_for_node(&ggtt->vm, NULL, &target, 0);\n\tmutex_unlock(&ggtt->vm.mutex);\n\tif (!err) {\n\t\tpr_err(\"[1]i915_gem_evict_for_node returned err=%d\\n\", err);\n\t\terr = -EINVAL;\n\t\tgoto cleanup;\n\t}\n\n\terr = 0;\n\ncleanup:\n\tunpin_ggtt(ggtt);\n\tcleanup_objects(ggtt, &objects);\n\tggtt->vm.mm.color_adjust = NULL;\n\treturn err;\n}\n\nstatic int igt_evict_vm(void *arg)\n{\n\tstruct intel_gt *gt = arg;\n\tstruct i915_ggtt *ggtt = gt->ggtt;\n\tstruct i915_gem_ww_ctx ww;\n\tLIST_HEAD(objects);\n\tint err;\n\n\t \n\n\terr = populate_ggtt(ggtt, &objects);\n\tif (err)\n\t\tgoto cleanup;\n\n\t \n\tmutex_lock(&ggtt->vm.mutex);\n\terr = i915_gem_evict_vm(&ggtt->vm, NULL, NULL);\n\tmutex_unlock(&ggtt->vm.mutex);\n\tif (err) {\n\t\tpr_err(\"i915_gem_evict_vm on a full GGTT returned err=%d]\\n\",\n\t\t       err);\n\t\tgoto cleanup;\n\t}\n\n\tunpin_ggtt(ggtt);\n\n\tfor_i915_gem_ww(&ww, err, false) {\n\t\tmutex_lock(&ggtt->vm.mutex);\n\t\terr = i915_gem_evict_vm(&ggtt->vm, &ww, NULL);\n\t\tmutex_unlock(&ggtt->vm.mutex);\n\t}\n\n\tif (err) {\n\t\tpr_err(\"i915_gem_evict_vm on a full GGTT returned err=%d]\\n\",\n\t\t       err);\n\t\tgoto cleanup;\n\t}\n\ncleanup:\n\tcleanup_objects(ggtt, &objects);\n\treturn err;\n}\n\nstatic int igt_evict_contexts(void *arg)\n{\n\tconst u64 PRETEND_GGTT_SIZE = 16ull << 20;\n\tstruct intel_gt *gt = arg;\n\tstruct i915_ggtt *ggtt = gt->ggtt;\n\tstruct drm_i915_private *i915 = gt->i915;\n\tstruct intel_engine_cs *engine;\n\tenum intel_engine_id id;\n\tstruct reserved {\n\t\tstruct drm_mm_node node;\n\t\tstruct reserved *next;\n\t} *reserved = NULL;\n\tintel_wakeref_t wakeref;\n\tstruct drm_mm_node hole;\n\tunsigned long count;\n\tint err;\n\n\t \n\tif (!HAS_FULL_PPGTT(i915))\n\t\treturn 0;\n\n\twakeref = intel_runtime_pm_get(&i915->runtime_pm);\n\n\t \n\tmemset(&hole, 0, sizeof(hole));\n\tmutex_lock(&ggtt->vm.mutex);\n\terr = i915_gem_gtt_insert(&ggtt->vm, NULL, &hole,\n\t\t\t\t  PRETEND_GGTT_SIZE, 0, I915_COLOR_UNEVICTABLE,\n\t\t\t\t  0, ggtt->vm.total,\n\t\t\t\t  PIN_NOEVICT);\n\tif (err)\n\t\tgoto out_locked;\n\n\t \n\tcount = 0;\n\tdo {\n\t\tstruct reserved *r;\n\n\t\tmutex_unlock(&ggtt->vm.mutex);\n\t\tr = kcalloc(1, sizeof(*r), GFP_KERNEL);\n\t\tmutex_lock(&ggtt->vm.mutex);\n\t\tif (!r) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto out_locked;\n\t\t}\n\n\t\tif (i915_gem_gtt_insert(&ggtt->vm, NULL, &r->node,\n\t\t\t\t\t1ul << 20, 0, I915_COLOR_UNEVICTABLE,\n\t\t\t\t\t0, ggtt->vm.total,\n\t\t\t\t\tPIN_NOEVICT)) {\n\t\t\tkfree(r);\n\t\t\tbreak;\n\t\t}\n\n\t\tr->next = reserved;\n\t\treserved = r;\n\n\t\tcount++;\n\t} while (1);\n\tdrm_mm_remove_node(&hole);\n\tmutex_unlock(&ggtt->vm.mutex);\n\tpr_info(\"Filled GGTT with %lu 1MiB nodes\\n\", count);\n\n\t \n\tfor_each_engine(engine, gt, id) {\n\t\tstruct i915_sw_fence fence;\n\t\tstruct i915_request *last = NULL;\n\n\t\tcount = 0;\n\t\tonstack_fence_init(&fence);\n\t\tdo {\n\t\t\tstruct intel_context *ce;\n\t\t\tstruct i915_request *rq;\n\n\t\t\tce = intel_context_create(engine);\n\t\t\tif (IS_ERR(ce))\n\t\t\t\tbreak;\n\n\t\t\t \n\t\t\tigt_evict_ctl.fail_if_busy = true;\n\t\t\trq = intel_context_create_request(ce);\n\t\t\tigt_evict_ctl.fail_if_busy = false;\n\t\t\tintel_context_put(ce);\n\n\t\t\tif (IS_ERR(rq)) {\n\t\t\t\t \n\t\t\t\tif (PTR_ERR(rq) != -EBUSY) {\n\t\t\t\t\tpr_err(\"Unexpected error from request alloc (on %s): %d\\n\",\n\t\t\t\t\t       engine->name,\n\t\t\t\t\t       (int)PTR_ERR(rq));\n\t\t\t\t\terr = PTR_ERR(rq);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t \n\t\t\terr = i915_sw_fence_await_sw_fence_gfp(&rq->submit,\n\t\t\t\t\t\t\t       &fence,\n\t\t\t\t\t\t\t       GFP_KERNEL);\n\t\t\tif (err < 0)\n\t\t\t\tbreak;\n\n\t\t\ti915_request_add(rq);\n\t\t\tcount++;\n\t\t\tif (last)\n\t\t\t\ti915_request_put(last);\n\t\t\tlast = i915_request_get(rq);\n\t\t\terr = 0;\n\t\t} while(1);\n\t\tonstack_fence_fini(&fence);\n\t\tpr_info(\"Submitted %lu contexts/requests on %s\\n\",\n\t\t\tcount, engine->name);\n\t\tif (err)\n\t\t\tbreak;\n\t\tif (last) {\n\t\t\tif (i915_request_wait(last, 0, HZ) < 0) {\n\t\t\t\terr = -EIO;\n\t\t\t\ti915_request_put(last);\n\t\t\t\tpr_err(\"Failed waiting for last request (on %s)\",\n\t\t\t\t       engine->name);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\ti915_request_put(last);\n\t\t}\n\t\terr = intel_gt_wait_for_idle(engine->gt, HZ * 3);\n\t\tif (err) {\n\t\t\tgt_err(engine->gt, \"Failed to idle GT (on %s)\",\n\t\t\t       engine->name);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tmutex_lock(&ggtt->vm.mutex);\nout_locked:\n\tif (igt_flush_test(i915))\n\t\terr = -EIO;\n\twhile (reserved) {\n\t\tstruct reserved *next = reserved->next;\n\n\t\tdrm_mm_remove_node(&reserved->node);\n\t\tkfree(reserved);\n\n\t\treserved = next;\n\t}\n\tif (drm_mm_node_allocated(&hole))\n\t\tdrm_mm_remove_node(&hole);\n\tmutex_unlock(&ggtt->vm.mutex);\n\tintel_runtime_pm_put(&i915->runtime_pm, wakeref);\n\n\treturn err;\n}\n\nint i915_gem_evict_mock_selftests(void)\n{\n\tstatic const struct i915_subtest tests[] = {\n\t\tSUBTEST(igt_evict_something),\n\t\tSUBTEST(igt_evict_for_vma),\n\t\tSUBTEST(igt_evict_for_cache_color),\n\t\tSUBTEST(igt_evict_vm),\n\t\tSUBTEST(igt_overcommit),\n\t};\n\tstruct drm_i915_private *i915;\n\tintel_wakeref_t wakeref;\n\tint err = 0;\n\n\ti915 = mock_gem_device();\n\tif (!i915)\n\t\treturn -ENOMEM;\n\n\twith_intel_runtime_pm(&i915->runtime_pm, wakeref)\n\t\terr = i915_subtests(tests, to_gt(i915));\n\n\tmock_destroy_device(i915);\n\treturn err;\n}\n\nint i915_gem_evict_live_selftests(struct drm_i915_private *i915)\n{\n\tstatic const struct i915_subtest tests[] = {\n\t\tSUBTEST(igt_evict_contexts),\n\t};\n\n\tif (intel_gt_is_wedged(to_gt(i915)))\n\t\treturn 0;\n\n\treturn intel_gt_live_subtests(tests, to_gt(i915));\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}