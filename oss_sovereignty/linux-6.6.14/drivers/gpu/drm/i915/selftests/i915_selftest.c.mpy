{
  "module_name": "i915_selftest.c",
  "hash_id": "8c8632dc1419ef98e467072ee96b98fb24a7fc8162bfeebe22ad728dee2c3581",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/i915/selftests/i915_selftest.c",
  "human_readable_source": " \n\n#include <linux/random.h>\n\n#include \"gt/intel_gt_pm.h\"\n#include \"gt/uc/intel_gsc_fw.h\"\n\n#include \"i915_driver.h\"\n#include \"i915_drv.h\"\n#include \"i915_selftest.h\"\n\n#include \"igt_flush_test.h\"\n\nstruct i915_selftest i915_selftest __read_mostly = {\n\t.timeout_ms = 500,\n};\n\nint i915_mock_sanitycheck(void)\n{\n\tpr_info(DRIVER_NAME \": %s() - ok!\\n\", __func__);\n\treturn 0;\n}\n\nint i915_live_sanitycheck(struct drm_i915_private *i915)\n{\n\tpr_info(\"%s: %s() - ok!\\n\", i915->drm.driver->name, __func__);\n\treturn 0;\n}\n\nenum {\n#define selftest(name, func) mock_##name,\n#include \"i915_mock_selftests.h\"\n#undef selftest\n};\n\nenum {\n#define selftest(name, func) live_##name,\n#include \"i915_live_selftests.h\"\n#undef selftest\n};\n\nenum {\n#define selftest(name, func) perf_##name,\n#include \"i915_perf_selftests.h\"\n#undef selftest\n};\n\nstruct selftest {\n\tbool enabled;\n\tconst char *name;\n\tunion {\n\t\tint (*mock)(void);\n\t\tint (*live)(struct drm_i915_private *);\n\t};\n};\n\n#define selftest(n, f) [mock_##n] = { .name = #n, { .mock = f } },\nstatic struct selftest mock_selftests[] = {\n#include \"i915_mock_selftests.h\"\n};\n#undef selftest\n\n#define selftest(n, f) [live_##n] = { .name = #n, { .live = f } },\nstatic struct selftest live_selftests[] = {\n#include \"i915_live_selftests.h\"\n};\n#undef selftest\n\n#define selftest(n, f) [perf_##n] = { .name = #n, { .live = f } },\nstatic struct selftest perf_selftests[] = {\n#include \"i915_perf_selftests.h\"\n};\n#undef selftest\n\n \n#define selftest(n, func) selftest_0(n, func, param(n))\n#define param(n) __PASTE(igt__, __PASTE(__LINE__, __mock_##n))\n#define selftest_0(n, func, id) \\\nmodule_param_named(id, mock_selftests[mock_##n].enabled, bool, 0400);\n#include \"i915_mock_selftests.h\"\n#undef selftest_0\n#undef param\n\n#define param(n) __PASTE(igt__, __PASTE(__LINE__, __live_##n))\n#define selftest_0(n, func, id) \\\nmodule_param_named(id, live_selftests[live_##n].enabled, bool, 0400);\n#include \"i915_live_selftests.h\"\n#undef selftest_0\n#undef param\n\n#define param(n) __PASTE(igt__, __PASTE(__LINE__, __perf_##n))\n#define selftest_0(n, func, id) \\\nmodule_param_named(id, perf_selftests[perf_##n].enabled, bool, 0400);\n#include \"i915_perf_selftests.h\"\n#undef selftest_0\n#undef param\n#undef selftest\n\nstatic void set_default_test_all(struct selftest *st, unsigned int count)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < count; i++)\n\t\tif (st[i].enabled)\n\t\t\treturn;\n\n\tfor (i = 0; i < count; i++)\n\t\tst[i].enabled = true;\n}\n\nstatic bool\n__gsc_proxy_init_progressing(struct intel_gsc_uc *gsc)\n{\n\treturn intel_gsc_uc_fw_proxy_get_status(gsc) == -EAGAIN;\n}\n\nstatic void\n__wait_gsc_proxy_completed(struct drm_i915_private *i915)\n{\n\tbool need_to_wait = (IS_ENABLED(CONFIG_INTEL_MEI_GSC_PROXY) &&\n\t\t\t     i915->media_gt &&\n\t\t\t     HAS_ENGINE(i915->media_gt, GSC0) &&\n\t\t\t     intel_uc_fw_is_loadable(&i915->media_gt->uc.gsc.fw));\n\t \n\tunsigned long timeout_ms = 8000;\n\n\tif (need_to_wait && wait_for(!__gsc_proxy_init_progressing(&i915->media_gt->uc.gsc),\n\t\t\t\t     timeout_ms))\n\t\tpr_warn(DRIVER_NAME \"Timed out waiting for gsc_proxy_completion!\\n\");\n}\n\nstatic int __run_selftests(const char *name,\n\t\t\t   struct selftest *st,\n\t\t\t   unsigned int count,\n\t\t\t   void *data)\n{\n\tint err = 0;\n\n\twhile (!i915_selftest.random_seed)\n\t\ti915_selftest.random_seed = get_random_u32();\n\n\ti915_selftest.timeout_jiffies =\n\t\ti915_selftest.timeout_ms ?\n\t\tmsecs_to_jiffies_timeout(i915_selftest.timeout_ms) :\n\t\tMAX_SCHEDULE_TIMEOUT;\n\n\tset_default_test_all(st, count);\n\n\tpr_info(DRIVER_NAME \": Performing %s selftests with st_random_seed=0x%x st_timeout=%u\\n\",\n\t\tname, i915_selftest.random_seed, i915_selftest.timeout_ms);\n\n\t \n\tfor (; count--; st++) {\n\t\tif (!st->enabled)\n\t\t\tcontinue;\n\n\t\tcond_resched();\n\t\tif (signal_pending(current))\n\t\t\treturn -EINTR;\n\n\t\tpr_info(DRIVER_NAME \": Running %s\\n\", st->name);\n\t\tif (data)\n\t\t\terr = st->live(data);\n\t\telse\n\t\t\terr = st->mock();\n\t\tif (err == -EINTR && !signal_pending(current))\n\t\t\terr = 0;\n\t\tif (err)\n\t\t\tbreak;\n\t}\n\n\tif (WARN(err > 0 || err == -ENOTTY,\n\t\t \"%s returned %d, conflicting with selftest's magic values!\\n\",\n\t\t st->name, err))\n\t\terr = -1;\n\n\treturn err;\n}\n\n#define run_selftests(x, data) \\\n\t__run_selftests(#x, x##_selftests, ARRAY_SIZE(x##_selftests), data)\n\nint i915_mock_selftests(void)\n{\n\tint err;\n\n\tif (!i915_selftest.mock)\n\t\treturn 0;\n\n\terr = run_selftests(mock, NULL);\n\tif (err) {\n\t\ti915_selftest.mock = err;\n\t\treturn 1;\n\t}\n\n\tif (i915_selftest.mock < 0) {\n\t\ti915_selftest.mock = -ENOTTY;\n\t\treturn 1;\n\t}\n\n\treturn 0;\n}\n\nint i915_live_selftests(struct pci_dev *pdev)\n{\n\tint err;\n\n\tif (!i915_selftest.live)\n\t\treturn 0;\n\n\t__wait_gsc_proxy_completed(pdev_to_i915(pdev));\n\n\terr = run_selftests(live, pdev_to_i915(pdev));\n\tif (err) {\n\t\ti915_selftest.live = err;\n\t\treturn err;\n\t}\n\n\tif (i915_selftest.live < 0) {\n\t\ti915_selftest.live = -ENOTTY;\n\t\treturn 1;\n\t}\n\n\treturn 0;\n}\n\nint i915_perf_selftests(struct pci_dev *pdev)\n{\n\tint err;\n\n\tif (!i915_selftest.perf)\n\t\treturn 0;\n\n\t__wait_gsc_proxy_completed(pdev_to_i915(pdev));\n\n\terr = run_selftests(perf, pdev_to_i915(pdev));\n\tif (err) {\n\t\ti915_selftest.perf = err;\n\t\treturn err;\n\t}\n\n\tif (i915_selftest.perf < 0) {\n\t\ti915_selftest.perf = -ENOTTY;\n\t\treturn 1;\n\t}\n\n\treturn 0;\n}\n\nstatic bool apply_subtest_filter(const char *caller, const char *name)\n{\n\tchar *filter, *sep, *tok;\n\tbool result = true;\n\n\tfilter = kstrdup(i915_selftest.filter, GFP_KERNEL);\n\tfor (sep = filter; (tok = strsep(&sep, \",\"));) {\n\t\tbool allow = true;\n\t\tchar *sl;\n\n\t\tif (*tok == '!') {\n\t\t\tallow = false;\n\t\t\ttok++;\n\t\t}\n\n\t\tif (*tok == '\\0')\n\t\t\tcontinue;\n\n\t\tsl = strchr(tok, '/');\n\t\tif (sl) {\n\t\t\t*sl++ = '\\0';\n\t\t\tif (strcmp(tok, caller)) {\n\t\t\t\tif (allow)\n\t\t\t\t\tresult = false;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\ttok = sl;\n\t\t}\n\n\t\tif (strcmp(tok, name)) {\n\t\t\tif (allow)\n\t\t\t\tresult = false;\n\t\t\tcontinue;\n\t\t}\n\n\t\tresult = allow;\n\t\tbreak;\n\t}\n\tkfree(filter);\n\n\treturn result;\n}\n\nint __i915_nop_setup(void *data)\n{\n\treturn 0;\n}\n\nint __i915_nop_teardown(int err, void *data)\n{\n\treturn err;\n}\n\nint __i915_live_setup(void *data)\n{\n\tstruct drm_i915_private *i915 = data;\n\n\t \n\tif (intel_gt_pm_wait_for_idle(to_gt(i915)))\n\t\treturn -EIO;\n\n\treturn intel_gt_terminally_wedged(to_gt(i915));\n}\n\nint __i915_live_teardown(int err, void *data)\n{\n\tstruct drm_i915_private *i915 = data;\n\n\tif (igt_flush_test(i915))\n\t\terr = -EIO;\n\n\ti915_gem_drain_freed_objects(i915);\n\n\treturn err;\n}\n\nint __intel_gt_live_setup(void *data)\n{\n\tstruct intel_gt *gt = data;\n\n\t \n\tif (intel_gt_pm_wait_for_idle(gt))\n\t\treturn -EIO;\n\n\treturn intel_gt_terminally_wedged(gt);\n}\n\nint __intel_gt_live_teardown(int err, void *data)\n{\n\tstruct intel_gt *gt = data;\n\n\tif (igt_flush_test(gt->i915))\n\t\terr = -EIO;\n\n\ti915_gem_drain_freed_objects(gt->i915);\n\n\treturn err;\n}\n\nint __i915_subtests(const char *caller,\n\t\t    int (*setup)(void *data),\n\t\t    int (*teardown)(int err, void *data),\n\t\t    const struct i915_subtest *st,\n\t\t    unsigned int count,\n\t\t    void *data)\n{\n\tint err;\n\n\tfor (; count--; st++) {\n\t\tcond_resched();\n\t\tif (signal_pending(current))\n\t\t\treturn -EINTR;\n\n\t\tif (!apply_subtest_filter(caller, st->name))\n\t\t\tcontinue;\n\n\t\terr = setup(data);\n\t\tif (err) {\n\t\t\tpr_err(DRIVER_NAME \"/%s: setup failed for %s\\n\",\n\t\t\t       caller, st->name);\n\t\t\treturn err;\n\t\t}\n\n\t\tpr_info(DRIVER_NAME \": Running %s/%s\\n\", caller, st->name);\n\t\tGEM_TRACE(\"Running %s/%s\\n\", caller, st->name);\n\n\t\terr = teardown(st->func(data), data);\n\t\tif (err && err != -EINTR) {\n\t\t\tpr_err(DRIVER_NAME \"/%s: %s failed with error %d\\n\",\n\t\t\t       caller, st->name, err);\n\t\t\treturn err;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nbool __igt_timeout(unsigned long timeout, const char *fmt, ...)\n{\n\tva_list va;\n\n\tif (!signal_pending(current)) {\n\t\tcond_resched();\n\t\tif (time_before(jiffies, timeout))\n\t\t\treturn false;\n\t}\n\n\tif (fmt) {\n\t\tva_start(va, fmt);\n\t\tvprintk(fmt, va);\n\t\tva_end(va);\n\t}\n\n\treturn true;\n}\n\nvoid igt_hexdump(const void *buf, size_t len)\n{\n\tconst size_t rowsize = 8 * sizeof(u32);\n\tconst void *prev = NULL;\n\tbool skip = false;\n\tsize_t pos;\n\n\tfor (pos = 0; pos < len; pos += rowsize) {\n\t\tchar line[128];\n\n\t\tif (prev && !memcmp(prev, buf + pos, rowsize)) {\n\t\t\tif (!skip) {\n\t\t\t\tpr_info(\"*\\n\");\n\t\t\t\tskip = true;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\n\t\tWARN_ON_ONCE(hex_dump_to_buffer(buf + pos, len - pos,\n\t\t\t\t\t\trowsize, sizeof(u32),\n\t\t\t\t\t\tline, sizeof(line),\n\t\t\t\t\t\tfalse) >= sizeof(line));\n\t\tpr_info(\"[%04zx] %s\\n\", pos, line);\n\n\t\tprev = buf + pos;\n\t\tskip = false;\n\t}\n}\n\nmodule_param_named(st_random_seed, i915_selftest.random_seed, uint, 0400);\nmodule_param_named(st_timeout, i915_selftest.timeout_ms, uint, 0400);\nmodule_param_named(st_filter, i915_selftest.filter, charp, 0400);\n\nmodule_param_named_unsafe(mock_selftests, i915_selftest.mock, int, 0400);\nMODULE_PARM_DESC(mock_selftests, \"Run selftests before loading, using mock hardware (0:disabled [default], 1:run tests then load driver, -1:run tests then leave dummy module)\");\n\nmodule_param_named_unsafe(live_selftests, i915_selftest.live, int, 0400);\nMODULE_PARM_DESC(live_selftests, \"Run selftests after driver initialisation on the live system (0:disabled [default], 1:run tests then continue, -1:run tests then exit module)\");\n\nmodule_param_named_unsafe(perf_selftests, i915_selftest.perf, int, 0400);\nMODULE_PARM_DESC(perf_selftests, \"Run performance orientated selftests after driver initialisation on the live system (0:disabled [default], 1:run tests then continue, -1:run tests then exit module)\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}