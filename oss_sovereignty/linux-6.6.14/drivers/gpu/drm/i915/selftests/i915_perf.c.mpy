{
  "module_name": "i915_perf.c",
  "hash_id": "5d5ede850ab7c59cda14267c15c3a316a8d69d108d03513c62d0d1a00e077335",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/i915/selftests/i915_perf.c",
  "human_readable_source": " \n\n#include <linux/kref.h>\n\n#include \"gem/i915_gem_pm.h\"\n#include \"gt/intel_gt.h\"\n\n#include \"i915_selftest.h\"\n\n#include \"igt_flush_test.h\"\n#include \"lib_sw_fence.h\"\n\n#define TEST_OA_CONFIG_UUID \"12345678-1234-1234-1234-1234567890ab\"\n\nstatic int\nalloc_empty_config(struct i915_perf *perf)\n{\n\tstruct i915_oa_config *oa_config;\n\n\toa_config = kzalloc(sizeof(*oa_config), GFP_KERNEL);\n\tif (!oa_config)\n\t\treturn -ENOMEM;\n\n\toa_config->perf = perf;\n\tkref_init(&oa_config->ref);\n\n\tstrscpy(oa_config->uuid, TEST_OA_CONFIG_UUID, sizeof(oa_config->uuid));\n\n\tmutex_lock(&perf->metrics_lock);\n\n\toa_config->id = idr_alloc(&perf->metrics_idr, oa_config, 2, 0, GFP_KERNEL);\n\tif (oa_config->id < 0)  {\n\t\tmutex_unlock(&perf->metrics_lock);\n\t\ti915_oa_config_put(oa_config);\n\t\treturn -ENOMEM;\n\t}\n\n\tmutex_unlock(&perf->metrics_lock);\n\n\treturn 0;\n}\n\nstatic void\ndestroy_empty_config(struct i915_perf *perf)\n{\n\tstruct i915_oa_config *oa_config = NULL, *tmp;\n\tint id;\n\n\tmutex_lock(&perf->metrics_lock);\n\n\tidr_for_each_entry(&perf->metrics_idr, tmp, id) {\n\t\tif (!strcmp(tmp->uuid, TEST_OA_CONFIG_UUID)) {\n\t\t\toa_config = tmp;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (oa_config)\n\t\tidr_remove(&perf->metrics_idr, oa_config->id);\n\n\tmutex_unlock(&perf->metrics_lock);\n\n\tif (oa_config)\n\t\ti915_oa_config_put(oa_config);\n}\n\nstatic struct i915_oa_config *\nget_empty_config(struct i915_perf *perf)\n{\n\tstruct i915_oa_config *oa_config = NULL, *tmp;\n\tint id;\n\n\tmutex_lock(&perf->metrics_lock);\n\n\tidr_for_each_entry(&perf->metrics_idr, tmp, id) {\n\t\tif (!strcmp(tmp->uuid, TEST_OA_CONFIG_UUID)) {\n\t\t\toa_config = i915_oa_config_get(tmp);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tmutex_unlock(&perf->metrics_lock);\n\n\treturn oa_config;\n}\n\nstatic struct i915_perf_stream *\ntest_stream(struct i915_perf *perf)\n{\n\tstruct drm_i915_perf_open_param param = {};\n\tstruct i915_oa_config *oa_config = get_empty_config(perf);\n\tstruct perf_open_properties props = {\n\t\t.engine = intel_engine_lookup_user(perf->i915,\n\t\t\t\t\t\t   I915_ENGINE_CLASS_RENDER,\n\t\t\t\t\t\t   0),\n\t\t.sample_flags = SAMPLE_OA_REPORT,\n\t\t.oa_format = GRAPHICS_VER(perf->i915) == 12 ?\n\t\tI915_OA_FORMAT_A32u40_A4u32_B8_C8 : I915_OA_FORMAT_C4_B8,\n\t};\n\tstruct i915_perf_stream *stream;\n\tstruct intel_gt *gt;\n\n\tif (!props.engine)\n\t\treturn NULL;\n\n\tgt = props.engine->gt;\n\n\tif (!oa_config)\n\t\treturn NULL;\n\n\tprops.metrics_set = oa_config->id;\n\n\tstream = kzalloc(sizeof(*stream), GFP_KERNEL);\n\tif (!stream) {\n\t\ti915_oa_config_put(oa_config);\n\t\treturn NULL;\n\t}\n\n\tstream->perf = perf;\n\n\tmutex_lock(&gt->perf.lock);\n\tif (i915_oa_stream_init(stream, &param, &props)) {\n\t\tkfree(stream);\n\t\tstream =  NULL;\n\t}\n\tmutex_unlock(&gt->perf.lock);\n\n\ti915_oa_config_put(oa_config);\n\n\treturn stream;\n}\n\nstatic void stream_destroy(struct i915_perf_stream *stream)\n{\n\tstruct intel_gt *gt = stream->engine->gt;\n\n\tmutex_lock(&gt->perf.lock);\n\ti915_perf_destroy_locked(stream);\n\tmutex_unlock(&gt->perf.lock);\n}\n\nstatic int live_sanitycheck(void *arg)\n{\n\tstruct drm_i915_private *i915 = arg;\n\tstruct i915_perf_stream *stream;\n\n\t \n\n\tstream = test_stream(&i915->perf);\n\tif (!stream)\n\t\treturn -EINVAL;\n\n\tstream_destroy(stream);\n\treturn 0;\n}\n\nstatic int write_timestamp(struct i915_request *rq, int slot)\n{\n\tu32 *cs;\n\tint len;\n\n\tcs = intel_ring_begin(rq, 6);\n\tif (IS_ERR(cs))\n\t\treturn PTR_ERR(cs);\n\n\tlen = 5;\n\tif (GRAPHICS_VER(rq->i915) >= 8)\n\t\tlen++;\n\n\t*cs++ = GFX_OP_PIPE_CONTROL(len);\n\t*cs++ = PIPE_CONTROL_GLOBAL_GTT_IVB |\n\t\tPIPE_CONTROL_STORE_DATA_INDEX |\n\t\tPIPE_CONTROL_WRITE_TIMESTAMP;\n\t*cs++ = slot * sizeof(u32);\n\t*cs++ = 0;\n\t*cs++ = 0;\n\t*cs++ = 0;\n\n\tintel_ring_advance(rq, cs);\n\n\treturn 0;\n}\n\nstatic ktime_t poll_status(struct i915_request *rq, int slot)\n{\n\twhile (!intel_read_status_page(rq->engine, slot) &&\n\t       !i915_request_completed(rq))\n\t\tcpu_relax();\n\n\treturn ktime_get();\n}\n\nstatic int live_noa_delay(void *arg)\n{\n\tstruct drm_i915_private *i915 = arg;\n\tstruct i915_perf_stream *stream;\n\tstruct i915_request *rq;\n\tktime_t t0, t1;\n\tu64 expected;\n\tu32 delay;\n\tint err;\n\tint i;\n\n\t \n\n\tstream = test_stream(&i915->perf);\n\tif (!stream)\n\t\treturn -ENOMEM;\n\n\texpected = atomic64_read(&stream->perf->noa_programming_delay);\n\n\tif (stream->engine->class != RENDER_CLASS) {\n\t\terr = -ENODEV;\n\t\tgoto out;\n\t}\n\n\tfor (i = 0; i < 4; i++)\n\t\tintel_write_status_page(stream->engine, 0x100 + i, 0);\n\n\trq = intel_engine_create_kernel_request(stream->engine);\n\tif (IS_ERR(rq)) {\n\t\terr = PTR_ERR(rq);\n\t\tgoto out;\n\t}\n\n\tif (rq->engine->emit_init_breadcrumb) {\n\t\terr = rq->engine->emit_init_breadcrumb(rq);\n\t\tif (err) {\n\t\t\ti915_request_add(rq);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\terr = write_timestamp(rq, 0x100);\n\tif (err) {\n\t\ti915_request_add(rq);\n\t\tgoto out;\n\t}\n\n\terr = rq->engine->emit_bb_start(rq,\n\t\t\t\t\ti915_ggtt_offset(stream->noa_wait), 0,\n\t\t\t\t\tI915_DISPATCH_SECURE);\n\tif (err) {\n\t\ti915_request_add(rq);\n\t\tgoto out;\n\t}\n\n\terr = write_timestamp(rq, 0x102);\n\tif (err) {\n\t\ti915_request_add(rq);\n\t\tgoto out;\n\t}\n\n\ti915_request_get(rq);\n\ti915_request_add(rq);\n\n\tpreempt_disable();\n\tt0 = poll_status(rq, 0x100);\n\tt1 = poll_status(rq, 0x102);\n\tpreempt_enable();\n\n\tpr_info(\"CPU delay: %lluns, expected %lluns\\n\",\n\t\tktime_sub(t1, t0), expected);\n\n\tdelay = intel_read_status_page(stream->engine, 0x102);\n\tdelay -= intel_read_status_page(stream->engine, 0x100);\n\tdelay = intel_gt_clock_interval_to_ns(stream->engine->gt, delay);\n\tpr_info(\"GPU delay: %uns, expected %lluns\\n\",\n\t\tdelay, expected);\n\n\tif (4 * delay < 3 * expected || 2 * delay > 3 * expected) {\n\t\tpr_err(\"GPU delay [%uus] outside of expected threshold! [%lluus, %lluus]\\n\",\n\t\t       delay / 1000,\n\t\t       div_u64(3 * expected, 4000),\n\t\t       div_u64(3 * expected, 2000));\n\t\terr = -EINVAL;\n\t}\n\n\ti915_request_put(rq);\nout:\n\tstream_destroy(stream);\n\treturn err;\n}\n\nstatic int live_noa_gpr(void *arg)\n{\n\tstruct drm_i915_private *i915 = arg;\n\tstruct i915_perf_stream *stream;\n\tstruct intel_context *ce;\n\tstruct i915_request *rq;\n\tu32 *cs, *store;\n\tvoid *scratch;\n\tu32 gpr0;\n\tint err;\n\tint i;\n\n\t \n\n\tstream = test_stream(&i915->perf);\n\tif (!stream)\n\t\treturn -ENOMEM;\n\n\tgpr0 = i915_mmio_reg_offset(GEN8_RING_CS_GPR(stream->engine->mmio_base, 0));\n\n\tce = intel_context_create(stream->engine);\n\tif (IS_ERR(ce)) {\n\t\terr = PTR_ERR(ce);\n\t\tgoto out;\n\t}\n\n\t \n\tscratch = __px_vaddr(ce->vm->scratch[0]);\n\tmemset(scratch, POISON_FREE, PAGE_SIZE);\n\n\trq = intel_context_create_request(ce);\n\tif (IS_ERR(rq)) {\n\t\terr = PTR_ERR(rq);\n\t\tgoto out_ce;\n\t}\n\ti915_request_get(rq);\n\n\tif (rq->engine->emit_init_breadcrumb) {\n\t\terr = rq->engine->emit_init_breadcrumb(rq);\n\t\tif (err) {\n\t\t\ti915_request_add(rq);\n\t\t\tgoto out_rq;\n\t\t}\n\t}\n\n\t \n\tcs = intel_ring_begin(rq, 2 * 32 + 2);\n\tif (IS_ERR(cs)) {\n\t\terr = PTR_ERR(cs);\n\t\ti915_request_add(rq);\n\t\tgoto out_rq;\n\t}\n\n\t*cs++ = MI_LOAD_REGISTER_IMM(32);\n\tfor (i = 0; i < 32; i++) {\n\t\t*cs++ = gpr0 + i * sizeof(u32);\n\t\t*cs++ = STACK_MAGIC;\n\t}\n\t*cs++ = MI_NOOP;\n\tintel_ring_advance(rq, cs);\n\n\t \n\terr = rq->engine->emit_bb_start(rq,\n\t\t\t\t\ti915_ggtt_offset(stream->noa_wait), 0,\n\t\t\t\t\tI915_DISPATCH_SECURE);\n\tif (err) {\n\t\ti915_request_add(rq);\n\t\tgoto out_rq;\n\t}\n\n\t \n\tstore = memset32(rq->engine->status_page.addr + 512, 0, 32);\n\tfor (i = 0; i < 32; i++) {\n\t\tu32 cmd;\n\n\t\tcs = intel_ring_begin(rq, 4);\n\t\tif (IS_ERR(cs)) {\n\t\t\terr = PTR_ERR(cs);\n\t\t\ti915_request_add(rq);\n\t\t\tgoto out_rq;\n\t\t}\n\n\t\tcmd = MI_STORE_REGISTER_MEM;\n\t\tif (GRAPHICS_VER(i915) >= 8)\n\t\t\tcmd++;\n\t\tcmd |= MI_USE_GGTT;\n\n\t\t*cs++ = cmd;\n\t\t*cs++ = gpr0 + i * sizeof(u32);\n\t\t*cs++ = i915_ggtt_offset(rq->engine->status_page.vma) +\n\t\t\toffset_in_page(store) +\n\t\t\ti * sizeof(u32);\n\t\t*cs++ = 0;\n\t\tintel_ring_advance(rq, cs);\n\t}\n\n\ti915_request_add(rq);\n\n\tif (i915_request_wait(rq, I915_WAIT_INTERRUPTIBLE, HZ / 2) < 0) {\n\t\tpr_err(\"noa_wait timed out\\n\");\n\t\tintel_gt_set_wedged(stream->engine->gt);\n\t\terr = -EIO;\n\t\tgoto out_rq;\n\t}\n\n\t \n\tfor (i = 0; i < 32; i++) {\n\t\tif (store[i] == STACK_MAGIC)\n\t\t\tcontinue;\n\n\t\tpr_err(\"GPR[%d] lost, found:%08x, expected:%08x!\\n\",\n\t\t       i, store[i], STACK_MAGIC);\n\t\terr = -EINVAL;\n\t}\n\n\t \n\tif (memchr_inv(scratch, POISON_FREE, PAGE_SIZE)) {\n\t\tpr_err(\"Scratch page overwritten!\\n\");\n\t\tigt_hexdump(scratch, 4096);\n\t\terr = -EINVAL;\n\t}\n\nout_rq:\n\ti915_request_put(rq);\nout_ce:\n\tintel_context_put(ce);\nout:\n\tstream_destroy(stream);\n\treturn err;\n}\n\nint i915_perf_live_selftests(struct drm_i915_private *i915)\n{\n\tstatic const struct i915_subtest tests[] = {\n\t\tSUBTEST(live_sanitycheck),\n\t\tSUBTEST(live_noa_delay),\n\t\tSUBTEST(live_noa_gpr),\n\t};\n\tstruct i915_perf *perf = &i915->perf;\n\tint err;\n\n\tif (!perf->metrics_kobj || !perf->ops.enable_metric_set)\n\t\treturn 0;\n\n\tif (intel_gt_is_wedged(to_gt(i915)))\n\t\treturn 0;\n\n\terr = alloc_empty_config(&i915->perf);\n\tif (err)\n\t\treturn err;\n\n\terr = i915_live_subtests(tests, i915);\n\n\tdestroy_empty_config(&i915->perf);\n\n\treturn err;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}