{
  "module_name": "scatterlist.c",
  "hash_id": "742ea074ecbcee5438d2b0352cab2141614f00da85a7a23e01abb1fcfd136e01",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/i915/selftests/scatterlist.c",
  "human_readable_source": " \n\n#include <linux/prime_numbers.h>\n#include <linux/random.h>\n\n#include \"i915_selftest.h\"\n#include \"i915_utils.h\"\n\n#define PFN_BIAS (1 << 10)\n\nstruct pfn_table {\n\tstruct sg_table st;\n\tunsigned long start, end;\n};\n\ntypedef unsigned int (*npages_fn_t)(unsigned long n,\n\t\t\t\t    unsigned long count,\n\t\t\t\t    struct rnd_state *rnd);\n\nstatic noinline int expect_pfn_sg(struct pfn_table *pt,\n\t\t\t\t  npages_fn_t npages_fn,\n\t\t\t\t  struct rnd_state *rnd,\n\t\t\t\t  const char *who,\n\t\t\t\t  unsigned long timeout)\n{\n\tstruct scatterlist *sg;\n\tunsigned long pfn, n;\n\n\tpfn = pt->start;\n\tfor_each_sg(pt->st.sgl, sg, pt->st.nents, n) {\n\t\tstruct page *page = sg_page(sg);\n\t\tunsigned int npages = npages_fn(n, pt->st.nents, rnd);\n\n\t\tif (page_to_pfn(page) != pfn) {\n\t\t\tpr_err(\"%s: %s left pages out of order, expected pfn %lu, found pfn %lu (using for_each_sg)\\n\",\n\t\t\t       __func__, who, pfn, page_to_pfn(page));\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (sg->length != npages * PAGE_SIZE) {\n\t\t\tpr_err(\"%s: %s copied wrong sg length, expected size %lu, found %u (using for_each_sg)\\n\",\n\t\t\t       __func__, who, npages * PAGE_SIZE, sg->length);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (igt_timeout(timeout, \"%s timed out\\n\", who))\n\t\t\treturn -EINTR;\n\n\t\tpfn += npages;\n\t}\n\tif (pfn != pt->end) {\n\t\tpr_err(\"%s: %s finished on wrong pfn, expected %lu, found %lu\\n\",\n\t\t       __func__, who, pt->end, pfn);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic noinline int expect_pfn_sg_page_iter(struct pfn_table *pt,\n\t\t\t\t\t    const char *who,\n\t\t\t\t\t    unsigned long timeout)\n{\n\tstruct sg_page_iter sgiter;\n\tunsigned long pfn;\n\n\tpfn = pt->start;\n\tfor_each_sg_page(pt->st.sgl, &sgiter, pt->st.nents, 0) {\n\t\tstruct page *page = sg_page_iter_page(&sgiter);\n\n\t\tif (page != pfn_to_page(pfn)) {\n\t\t\tpr_err(\"%s: %s left pages out of order, expected pfn %lu, found pfn %lu (using for_each_sg_page)\\n\",\n\t\t\t       __func__, who, pfn, page_to_pfn(page));\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (igt_timeout(timeout, \"%s timed out\\n\", who))\n\t\t\treturn -EINTR;\n\n\t\tpfn++;\n\t}\n\tif (pfn != pt->end) {\n\t\tpr_err(\"%s: %s finished on wrong pfn, expected %lu, found %lu\\n\",\n\t\t       __func__, who, pt->end, pfn);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic noinline int expect_pfn_sgtiter(struct pfn_table *pt,\n\t\t\t\t       const char *who,\n\t\t\t\t       unsigned long timeout)\n{\n\tstruct sgt_iter sgt;\n\tstruct page *page;\n\tunsigned long pfn;\n\n\tpfn = pt->start;\n\tfor_each_sgt_page(page, sgt, &pt->st) {\n\t\tif (page != pfn_to_page(pfn)) {\n\t\t\tpr_err(\"%s: %s left pages out of order, expected pfn %lu, found pfn %lu (using for_each_sgt_page)\\n\",\n\t\t\t       __func__, who, pfn, page_to_pfn(page));\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (igt_timeout(timeout, \"%s timed out\\n\", who))\n\t\t\treturn -EINTR;\n\n\t\tpfn++;\n\t}\n\tif (pfn != pt->end) {\n\t\tpr_err(\"%s: %s finished on wrong pfn, expected %lu, found %lu\\n\",\n\t\t       __func__, who, pt->end, pfn);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int expect_pfn_sgtable(struct pfn_table *pt,\n\t\t\t      npages_fn_t npages_fn,\n\t\t\t      struct rnd_state *rnd,\n\t\t\t      const char *who,\n\t\t\t      unsigned long timeout)\n{\n\tint err;\n\n\terr = expect_pfn_sg(pt, npages_fn, rnd, who, timeout);\n\tif (err)\n\t\treturn err;\n\n\terr = expect_pfn_sg_page_iter(pt, who, timeout);\n\tif (err)\n\t\treturn err;\n\n\terr = expect_pfn_sgtiter(pt, who, timeout);\n\tif (err)\n\t\treturn err;\n\n\treturn 0;\n}\n\nstatic unsigned int one(unsigned long n,\n\t\t\tunsigned long count,\n\t\t\tstruct rnd_state *rnd)\n{\n\treturn 1;\n}\n\nstatic unsigned int grow(unsigned long n,\n\t\t\t unsigned long count,\n\t\t\t struct rnd_state *rnd)\n{\n\treturn n + 1;\n}\n\nstatic unsigned int shrink(unsigned long n,\n\t\t\t   unsigned long count,\n\t\t\t   struct rnd_state *rnd)\n{\n\treturn count - n;\n}\n\nstatic unsigned int random(unsigned long n,\n\t\t\t   unsigned long count,\n\t\t\t   struct rnd_state *rnd)\n{\n\treturn 1 + (prandom_u32_state(rnd) % 1024);\n}\n\nstatic unsigned int random_page_size_pages(unsigned long n,\n\t\t\t\t\t   unsigned long count,\n\t\t\t\t\t   struct rnd_state *rnd)\n{\n\t \n\tstatic unsigned int page_count[] = {\n\t\tBIT(12) >> PAGE_SHIFT,\n\t\tBIT(16) >> PAGE_SHIFT,\n\t\tBIT(21) >> PAGE_SHIFT,\n\t};\n\n\treturn page_count[(prandom_u32_state(rnd) % 3)];\n}\n\nstatic inline bool page_contiguous(struct page *first,\n\t\t\t\t   struct page *last,\n\t\t\t\t   unsigned long npages)\n{\n\treturn first + npages == last;\n}\n\nstatic int alloc_table(struct pfn_table *pt,\n\t\t       unsigned long count, unsigned long max,\n\t\t       npages_fn_t npages_fn,\n\t\t       struct rnd_state *rnd,\n\t\t       int alloc_error)\n{\n\tstruct scatterlist *sg;\n\tunsigned long n, pfn;\n\n\t \n\tif (overflows_type(max, unsigned int))\n\t\treturn -E2BIG;\n\n\tif (sg_alloc_table(&pt->st, max,\n\t\t\t   GFP_KERNEL | __GFP_NORETRY | __GFP_NOWARN))\n\t\treturn alloc_error;\n\n\t \n\tGEM_BUG_ON(overflows_type(count * PAGE_SIZE, sg->length));\n\n\t \n\tpt->start = PFN_BIAS;\n\tpfn = pt->start;\n\tsg = pt->st.sgl;\n\tfor (n = 0; n < count; n++) {\n\t\tunsigned long npages = npages_fn(n, count, rnd);\n\n\t\t \n\t\tif (!page_contiguous(pfn_to_page(pfn),\n\t\t\t\t     pfn_to_page(pfn + npages),\n\t\t\t\t     npages)) {\n\t\t\tsg_free_table(&pt->st);\n\t\t\treturn -ENOSPC;\n\t\t}\n\n\t\tif (n)\n\t\t\tsg = sg_next(sg);\n\t\tsg_set_page(sg, pfn_to_page(pfn), npages * PAGE_SIZE, 0);\n\n\t\tGEM_BUG_ON(page_to_pfn(sg_page(sg)) != pfn);\n\t\tGEM_BUG_ON(sg->length != npages * PAGE_SIZE);\n\t\tGEM_BUG_ON(sg->offset != 0);\n\n\t\tpfn += npages;\n\t}\n\tsg_mark_end(sg);\n\tpt->st.nents = n;\n\tpt->end = pfn;\n\n\treturn 0;\n}\n\nstatic const npages_fn_t npages_funcs[] = {\n\tone,\n\tgrow,\n\tshrink,\n\trandom,\n\trandom_page_size_pages,\n\tNULL,\n};\n\nstatic int igt_sg_alloc(void *ignored)\n{\n\tIGT_TIMEOUT(end_time);\n\tconst unsigned long max_order = 20;  \n\tstruct rnd_state prng;\n\tunsigned long prime;\n\tint alloc_error = -ENOMEM;\n\n\tfor_each_prime_number(prime, max_order) {\n\t\tunsigned long size = BIT(prime);\n\t\tint offset;\n\n\t\tfor (offset = -1; offset <= 1; offset++) {\n\t\t\tunsigned long sz = size + offset;\n\t\t\tconst npages_fn_t *npages;\n\t\t\tstruct pfn_table pt;\n\t\t\tint err;\n\n\t\t\tfor (npages = npages_funcs; *npages; npages++) {\n\t\t\t\tprandom_seed_state(&prng,\n\t\t\t\t\t\t   i915_selftest.random_seed);\n\t\t\t\terr = alloc_table(&pt, sz, sz, *npages, &prng,\n\t\t\t\t\t\t  alloc_error);\n\t\t\t\tif (err == -ENOSPC)\n\t\t\t\t\tbreak;\n\t\t\t\tif (err)\n\t\t\t\t\treturn err;\n\n\t\t\t\tprandom_seed_state(&prng,\n\t\t\t\t\t\t   i915_selftest.random_seed);\n\t\t\t\terr = expect_pfn_sgtable(&pt, *npages, &prng,\n\t\t\t\t\t\t\t \"sg_alloc_table\",\n\t\t\t\t\t\t\t end_time);\n\t\t\t\tsg_free_table(&pt.st);\n\t\t\t\tif (err)\n\t\t\t\t\treturn err;\n\t\t\t}\n\t\t}\n\n\t\t \n\t\tif (size > SG_MAX_SINGLE_ALLOC)\n\t\t\talloc_error = -ENOSPC;\n\t}\n\n\treturn 0;\n}\n\nstatic int igt_sg_trim(void *ignored)\n{\n\tIGT_TIMEOUT(end_time);\n\tconst unsigned long max = PAGE_SIZE;  \n\tstruct pfn_table pt;\n\tunsigned long prime;\n\tint alloc_error = -ENOMEM;\n\n\tfor_each_prime_number(prime, max) {\n\t\tconst npages_fn_t *npages;\n\t\tint err;\n\n\t\tfor (npages = npages_funcs; *npages; npages++) {\n\t\t\tstruct rnd_state prng;\n\n\t\t\tprandom_seed_state(&prng, i915_selftest.random_seed);\n\t\t\terr = alloc_table(&pt, prime, max, *npages, &prng,\n\t\t\t\t\t  alloc_error);\n\t\t\tif (err == -ENOSPC)\n\t\t\t\tbreak;\n\t\t\tif (err)\n\t\t\t\treturn err;\n\n\t\t\tif (i915_sg_trim(&pt.st)) {\n\t\t\t\tif (pt.st.orig_nents != prime ||\n\t\t\t\t    pt.st.nents != prime) {\n\t\t\t\t\tpr_err(\"i915_sg_trim failed (nents %u, orig_nents %u), expected %lu\\n\",\n\t\t\t\t\t       pt.st.nents, pt.st.orig_nents, prime);\n\t\t\t\t\terr = -EINVAL;\n\t\t\t\t} else {\n\t\t\t\t\tprandom_seed_state(&prng,\n\t\t\t\t\t\t\t   i915_selftest.random_seed);\n\t\t\t\t\terr = expect_pfn_sgtable(&pt,\n\t\t\t\t\t\t\t\t *npages, &prng,\n\t\t\t\t\t\t\t\t \"i915_sg_trim\",\n\t\t\t\t\t\t\t\t end_time);\n\t\t\t\t}\n\t\t\t}\n\t\t\tsg_free_table(&pt.st);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t}\n\n\t\t \n\t\tif (prime > SG_MAX_SINGLE_ALLOC)\n\t\t\talloc_error = -ENOSPC;\n\t}\n\n\treturn 0;\n}\n\nint scatterlist_mock_selftests(void)\n{\n\tstatic const struct i915_subtest tests[] = {\n\t\tSUBTEST(igt_sg_alloc),\n\t\tSUBTEST(igt_sg_trim),\n\t};\n\n\treturn i915_subtests(tests, NULL);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}