{
  "module_name": "lib_sw_fence.c",
  "hash_id": "0f896e81298747f8f11790c2c4f38567ef8b735a038f5504e5d782125c5ad902",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/i915/selftests/lib_sw_fence.c",
  "human_readable_source": " \n\n#include \"lib_sw_fence.h\"\n\n \n\nstatic int\nnop_fence_notify(struct i915_sw_fence *fence, enum i915_sw_fence_notify state)\n{\n\treturn NOTIFY_DONE;\n}\n\nvoid __onstack_fence_init(struct i915_sw_fence *fence,\n\t\t\t  const char *name,\n\t\t\t  struct lock_class_key *key)\n{\n\tdebug_fence_init_onstack(fence);\n\n\t__init_waitqueue_head(&fence->wait, name, key);\n\tatomic_set(&fence->pending, 1);\n\tfence->error = 0;\n\tfence->fn = nop_fence_notify;\n}\n\nvoid onstack_fence_fini(struct i915_sw_fence *fence)\n{\n\tif (!fence->fn)\n\t\treturn;\n\n\ti915_sw_fence_commit(fence);\n\ti915_sw_fence_fini(fence);\n}\n\nstatic void timed_fence_wake(struct timer_list *t)\n{\n\tstruct timed_fence *tf = from_timer(tf, t, timer);\n\n\ti915_sw_fence_commit(&tf->fence);\n}\n\nvoid timed_fence_init(struct timed_fence *tf, unsigned long expires)\n{\n\tonstack_fence_init(&tf->fence);\n\n\ttimer_setup_on_stack(&tf->timer, timed_fence_wake, 0);\n\n\tif (time_after(expires, jiffies))\n\t\tmod_timer(&tf->timer, expires);\n\telse\n\t\ti915_sw_fence_commit(&tf->fence);\n}\n\nvoid timed_fence_fini(struct timed_fence *tf)\n{\n\tif (del_timer_sync(&tf->timer))\n\t\ti915_sw_fence_commit(&tf->fence);\n\n\tdestroy_timer_on_stack(&tf->timer);\n\ti915_sw_fence_fini(&tf->fence);\n}\n\nstruct heap_fence {\n\tstruct i915_sw_fence fence;\n\tunion {\n\t\tstruct kref ref;\n\t\tstruct rcu_head rcu;\n\t};\n};\n\nstatic int\nheap_fence_notify(struct i915_sw_fence *fence, enum i915_sw_fence_notify state)\n{\n\tstruct heap_fence *h = container_of(fence, typeof(*h), fence);\n\n\tswitch (state) {\n\tcase FENCE_COMPLETE:\n\t\tbreak;\n\n\tcase FENCE_FREE:\n\t\theap_fence_put(&h->fence);\n\t}\n\n\treturn NOTIFY_DONE;\n}\n\nstruct i915_sw_fence *heap_fence_create(gfp_t gfp)\n{\n\tstruct heap_fence *h;\n\n\th = kmalloc(sizeof(*h), gfp);\n\tif (!h)\n\t\treturn NULL;\n\n\ti915_sw_fence_init(&h->fence, heap_fence_notify);\n\trefcount_set(&h->ref.refcount, 2);\n\n\treturn &h->fence;\n}\n\nstatic void heap_fence_release(struct kref *ref)\n{\n\tstruct heap_fence *h = container_of(ref, typeof(*h), ref);\n\n\ti915_sw_fence_fini(&h->fence);\n\n\tkfree_rcu(h, rcu);\n}\n\nvoid heap_fence_put(struct i915_sw_fence *fence)\n{\n\tstruct heap_fence *h = container_of(fence, typeof(*h), fence);\n\n\tkref_put(&h->ref, heap_fence_release);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}