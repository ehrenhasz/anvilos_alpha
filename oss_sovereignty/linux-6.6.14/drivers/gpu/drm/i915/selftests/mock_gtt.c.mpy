{
  "module_name": "mock_gtt.c",
  "hash_id": "874b0cbe25ef473fc644194c646e0604cea6ebe4c9532ed135f661e868027466",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/i915/selftests/mock_gtt.c",
  "human_readable_source": " \n\n#include \"mock_gtt.h\"\n\nstatic void mock_insert_page(struct i915_address_space *vm,\n\t\t\t     dma_addr_t addr,\n\t\t\t     u64 offset,\n\t\t\t     unsigned int pat_index,\n\t\t\t     u32 flags)\n{\n}\n\nstatic void mock_insert_entries(struct i915_address_space *vm,\n\t\t\t\tstruct i915_vma_resource *vma_res,\n\t\t\t\tunsigned int pat_index, u32 flags)\n{\n}\n\nstatic void mock_bind_ppgtt(struct i915_address_space *vm,\n\t\t\t    struct i915_vm_pt_stash *stash,\n\t\t\t    struct i915_vma_resource *vma_res,\n\t\t\t    unsigned int pat_index,\n\t\t\t    u32 flags)\n{\n\tGEM_BUG_ON(flags & I915_VMA_GLOBAL_BIND);\n\tvma_res->bound_flags |= flags;\n}\n\nstatic void mock_unbind_ppgtt(struct i915_address_space *vm,\n\t\t\t      struct i915_vma_resource *vma_res)\n{\n}\n\nstatic void mock_cleanup(struct i915_address_space *vm)\n{\n}\n\nstatic void mock_clear_range(struct i915_address_space *vm,\n\t\t\t     u64 start, u64 length)\n{\n}\n\nstruct i915_ppgtt *mock_ppgtt(struct drm_i915_private *i915, const char *name)\n{\n\tstruct i915_ppgtt *ppgtt;\n\n\tppgtt = kzalloc(sizeof(*ppgtt), GFP_KERNEL);\n\tif (!ppgtt)\n\t\treturn NULL;\n\n\tppgtt->vm.gt = to_gt(i915);\n\tppgtt->vm.i915 = i915;\n\tppgtt->vm.total = round_down(U64_MAX, PAGE_SIZE);\n\tppgtt->vm.dma = i915->drm.dev;\n\n\ti915_address_space_init(&ppgtt->vm, VM_CLASS_PPGTT);\n\n\tppgtt->vm.alloc_pt_dma = alloc_pt_dma;\n\tppgtt->vm.alloc_scratch_dma = alloc_pt_dma;\n\n\tppgtt->vm.clear_range = mock_clear_range;\n\tppgtt->vm.insert_page = mock_insert_page;\n\tppgtt->vm.insert_entries = mock_insert_entries;\n\tppgtt->vm.cleanup = mock_cleanup;\n\n\tppgtt->vm.vma_ops.bind_vma    = mock_bind_ppgtt;\n\tppgtt->vm.vma_ops.unbind_vma  = mock_unbind_ppgtt;\n\n\treturn ppgtt;\n}\n\nstatic void mock_bind_ggtt(struct i915_address_space *vm,\n\t\t\t   struct i915_vm_pt_stash *stash,\n\t\t\t   struct i915_vma_resource *vma_res,\n\t\t\t   unsigned int pat_index,\n\t\t\t   u32 flags)\n{\n}\n\nstatic void mock_unbind_ggtt(struct i915_address_space *vm,\n\t\t\t     struct i915_vma_resource *vma_res)\n{\n}\n\nvoid mock_init_ggtt(struct intel_gt *gt)\n{\n\tstruct i915_ggtt *ggtt = gt->ggtt;\n\n\tggtt->vm.gt = gt;\n\tggtt->vm.i915 = gt->i915;\n\tggtt->vm.is_ggtt = true;\n\n\tggtt->gmadr = DEFINE_RES_MEM(0, 2048 * PAGE_SIZE);\n\tggtt->mappable_end = resource_size(&ggtt->gmadr);\n\tggtt->vm.total = 4096 * PAGE_SIZE;\n\n\tggtt->vm.alloc_pt_dma = alloc_pt_dma;\n\tggtt->vm.alloc_scratch_dma = alloc_pt_dma;\n\n\tggtt->vm.clear_range = mock_clear_range;\n\tggtt->vm.insert_page = mock_insert_page;\n\tggtt->vm.insert_entries = mock_insert_entries;\n\tggtt->vm.cleanup = mock_cleanup;\n\n\tggtt->vm.vma_ops.bind_vma    = mock_bind_ggtt;\n\tggtt->vm.vma_ops.unbind_vma  = mock_unbind_ggtt;\n\n\ti915_address_space_init(&ggtt->vm, VM_CLASS_GGTT);\n}\n\nvoid mock_fini_ggtt(struct i915_ggtt *ggtt)\n{\n\ti915_address_space_fini(&ggtt->vm);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}