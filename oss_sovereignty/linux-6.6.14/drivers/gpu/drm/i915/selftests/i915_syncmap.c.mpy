{
  "module_name": "i915_syncmap.c",
  "hash_id": "05ad69820e0a3876c973388ec345ef016110ea98d146b937322c4a50a66971dd",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/i915/selftests/i915_syncmap.c",
  "human_readable_source": " \n\n#include \"../i915_selftest.h\"\n#include \"i915_random.h\"\n\nstatic char *\n__sync_print(struct i915_syncmap *p,\n\t     char *buf, unsigned long *sz,\n\t     unsigned int depth,\n\t     unsigned int last,\n\t     unsigned int idx)\n{\n\tunsigned long len;\n\tunsigned int i, X;\n\n\tif (depth) {\n\t\tunsigned int d;\n\n\t\tfor (d = 0; d < depth - 1; d++) {\n\t\t\tif (last & BIT(depth - d - 1))\n\t\t\t\tlen = scnprintf(buf, *sz, \"|   \");\n\t\t\telse\n\t\t\t\tlen = scnprintf(buf, *sz, \"    \");\n\t\t\tbuf += len;\n\t\t\t*sz -= len;\n\t\t}\n\t\tlen = scnprintf(buf, *sz, \"%x-> \", idx);\n\t\tbuf += len;\n\t\t*sz -= len;\n\t}\n\n\t \n\tlen = scnprintf(buf, *sz, \"0x%016llx\", p->prefix << p->height << SHIFT);\n\tbuf += len;\n\t*sz -= len;\n\tX = (p->height + SHIFT) / 4;\n\tscnprintf(buf - X, *sz + X, \"%*s\", X, \"XXXXXXXXXXXXXXXXX\");\n\n\tif (!p->height) {\n\t\tfor_each_set_bit(i, (unsigned long *)&p->bitmap, KSYNCMAP) {\n\t\t\tlen = scnprintf(buf, *sz, \" %x:%x,\",\n\t\t\t\t\ti, __sync_seqno(p)[i]);\n\t\t\tbuf += len;\n\t\t\t*sz -= len;\n\t\t}\n\t\tbuf -= 1;\n\t\t*sz += 1;\n\t}\n\n\tlen = scnprintf(buf, *sz, \"\\n\");\n\tbuf += len;\n\t*sz -= len;\n\n\tif (p->height) {\n\t\tfor_each_set_bit(i, (unsigned long *)&p->bitmap, KSYNCMAP) {\n\t\t\tbuf = __sync_print(__sync_child(p)[i], buf, sz,\n\t\t\t\t\t   depth + 1,\n\t\t\t\t\t   last << 1 | !!(p->bitmap >> (i + 1)),\n\t\t\t\t\t   i);\n\t\t}\n\t}\n\n\treturn buf;\n}\n\nstatic bool\ni915_syncmap_print_to_buf(struct i915_syncmap *p, char *buf, unsigned long sz)\n{\n\tif (!p)\n\t\treturn false;\n\n\twhile (p->parent)\n\t\tp = p->parent;\n\n\t__sync_print(p, buf, &sz, 0, 1, 0);\n\treturn true;\n}\n\nstatic int check_syncmap_free(struct i915_syncmap **sync)\n{\n\ti915_syncmap_free(sync);\n\tif (*sync) {\n\t\tpr_err(\"sync not cleared after free\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int dump_syncmap(struct i915_syncmap *sync, int err)\n{\n\tchar *buf;\n\n\tif (!err)\n\t\treturn check_syncmap_free(&sync);\n\n\tbuf = kmalloc(PAGE_SIZE, GFP_KERNEL);\n\tif (!buf)\n\t\tgoto skip;\n\n\tif (i915_syncmap_print_to_buf(sync, buf, PAGE_SIZE))\n\t\tpr_err(\"%s\", buf);\n\n\tkfree(buf);\n\nskip:\n\ti915_syncmap_free(&sync);\n\treturn err;\n}\n\nstatic int igt_syncmap_init(void *arg)\n{\n\tstruct i915_syncmap *sync = (void *)~0ul;\n\n\t \n\n\ti915_syncmap_init(&sync);\n\treturn check_syncmap_free(&sync);\n}\n\nstatic int check_seqno(struct i915_syncmap *leaf, unsigned int idx, u32 seqno)\n{\n\tif (leaf->height) {\n\t\tpr_err(\"%s: not a leaf, height is %d\\n\",\n\t\t       __func__, leaf->height);\n\t\treturn -EINVAL;\n\t}\n\n\tif (__sync_seqno(leaf)[idx] != seqno) {\n\t\tpr_err(\"%s: seqno[%d], found %x, expected %x\\n\",\n\t\t       __func__, idx, __sync_seqno(leaf)[idx], seqno);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int check_one(struct i915_syncmap **sync, u64 context, u32 seqno)\n{\n\tint err;\n\n\terr = i915_syncmap_set(sync, context, seqno);\n\tif (err)\n\t\treturn err;\n\n\tif ((*sync)->height) {\n\t\tpr_err(\"Inserting first context=%llx did not return leaf (height=%d, prefix=%llx\\n\",\n\t\t       context, (*sync)->height, (*sync)->prefix);\n\t\treturn -EINVAL;\n\t}\n\n\tif ((*sync)->parent) {\n\t\tpr_err(\"Inserting first context=%llx created branches!\\n\",\n\t\t       context);\n\t\treturn -EINVAL;\n\t}\n\n\tif (hweight32((*sync)->bitmap) != 1) {\n\t\tpr_err(\"First bitmap does not contain a single entry, found %x (count=%d)!\\n\",\n\t\t       (*sync)->bitmap, hweight32((*sync)->bitmap));\n\t\treturn -EINVAL;\n\t}\n\n\terr = check_seqno((*sync), ilog2((*sync)->bitmap), seqno);\n\tif (err)\n\t\treturn err;\n\n\tif (!i915_syncmap_is_later(sync, context, seqno)) {\n\t\tpr_err(\"Lookup of first context=%llx/seqno=%x failed!\\n\",\n\t\t       context, seqno);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int igt_syncmap_one(void *arg)\n{\n\tI915_RND_STATE(prng);\n\tIGT_TIMEOUT(end_time);\n\tstruct i915_syncmap *sync;\n\tunsigned long max = 1;\n\tint err;\n\n\t \n\n\ti915_syncmap_init(&sync);\n\n\tdo {\n\t\tu64 context = i915_prandom_u64_state(&prng);\n\t\tunsigned long loop;\n\n\t\terr = check_syncmap_free(&sync);\n\t\tif (err)\n\t\t\tgoto out;\n\n\t\tfor (loop = 0; loop <= max; loop++) {\n\t\t\terr = check_one(&sync, context,\n\t\t\t\t\tprandom_u32_state(&prng));\n\t\t\tif (err)\n\t\t\t\tgoto out;\n\t\t}\n\t\tmax++;\n\t} while (!__igt_timeout(end_time, NULL));\n\tpr_debug(\"%s: Completed %lu single insertions\\n\",\n\t\t __func__, max * (max - 1) / 2);\nout:\n\treturn dump_syncmap(sync, err);\n}\n\nstatic int check_leaf(struct i915_syncmap **sync, u64 context, u32 seqno)\n{\n\tint err;\n\n\terr = i915_syncmap_set(sync, context, seqno);\n\tif (err)\n\t\treturn err;\n\n\tif ((*sync)->height) {\n\t\tpr_err(\"Inserting context=%llx did not return leaf (height=%d, prefix=%llx\\n\",\n\t\t       context, (*sync)->height, (*sync)->prefix);\n\t\treturn -EINVAL;\n\t}\n\n\tif (hweight32((*sync)->bitmap) != 1) {\n\t\tpr_err(\"First entry into leaf (context=%llx) does not contain a single entry, found %x (count=%d)!\\n\",\n\t\t       context, (*sync)->bitmap, hweight32((*sync)->bitmap));\n\t\treturn -EINVAL;\n\t}\n\n\terr = check_seqno((*sync), ilog2((*sync)->bitmap), seqno);\n\tif (err)\n\t\treturn err;\n\n\tif (!i915_syncmap_is_later(sync, context, seqno)) {\n\t\tpr_err(\"Lookup of first entry context=%llx/seqno=%x failed!\\n\",\n\t\t       context, seqno);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int igt_syncmap_join_above(void *arg)\n{\n\tstruct i915_syncmap *sync;\n\tunsigned int pass, order;\n\tint err;\n\n\ti915_syncmap_init(&sync);\n\n\t \n\tfor (pass = 0; pass < 3; pass++) {\n\t\tfor (order = 0; order < 64; order += SHIFT) {\n\t\t\tu64 context = BIT_ULL(order);\n\t\t\tstruct i915_syncmap *join;\n\n\t\t\terr = check_leaf(&sync, context, 0);\n\t\t\tif (err)\n\t\t\t\tgoto out;\n\n\t\t\tjoin = sync->parent;\n\t\t\tif (!join)  \n\t\t\t\tcontinue;\n\n\t\t\tif (!join->height) {\n\t\t\t\tpr_err(\"Parent with no height!\\n\");\n\t\t\t\terr = -EINVAL;\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tif (hweight32(join->bitmap) != 2) {\n\t\t\t\tpr_err(\"Join does not have 2 children: %x (%d)\\n\",\n\t\t\t\t       join->bitmap, hweight32(join->bitmap));\n\t\t\t\terr = -EINVAL;\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tif (__sync_child(join)[__sync_branch_idx(join, context)] != sync) {\n\t\t\t\tpr_err(\"Leaf misplaced in parent!\\n\");\n\t\t\t\terr = -EINVAL;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t}\nout:\n\treturn dump_syncmap(sync, err);\n}\n\nstatic int igt_syncmap_join_below(void *arg)\n{\n\tstruct i915_syncmap *sync;\n\tunsigned int step, order, idx;\n\tint err = -ENODEV;\n\n\ti915_syncmap_init(&sync);\n\n\t \n\tfor (step = 0; step < KSYNCMAP; step++) {\n\t\tfor (order = 64 - SHIFT; order > 0; order -= SHIFT) {\n\t\t\tu64 context = step * BIT_ULL(order);\n\n\t\t\terr = i915_syncmap_set(&sync, context, 0);\n\t\t\tif (err)\n\t\t\t\tgoto out;\n\n\t\t\tif (sync->height) {\n\t\t\t\tpr_err(\"Inserting context=%llx (order=%d, step=%d) did not return leaf (height=%d, prefix=%llx\\n\",\n\t\t\t\t       context, order, step, sync->height, sync->prefix);\n\t\t\t\terr = -EINVAL;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (step = 0; step < KSYNCMAP; step++) {\n\t\tfor (order = SHIFT; order < 64; order += SHIFT) {\n\t\t\tu64 context = step * BIT_ULL(order);\n\n\t\t\tif (!i915_syncmap_is_later(&sync, context, 0)) {\n\t\t\t\tpr_err(\"1: context %llx (order=%d, step=%d) not found\\n\",\n\t\t\t\t       context, order, step);\n\t\t\t\terr = -EINVAL;\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tfor (idx = 1; idx < KSYNCMAP; idx++) {\n\t\t\t\tif (i915_syncmap_is_later(&sync, context + idx, 0)) {\n\t\t\t\t\tpr_err(\"1: context %llx (order=%d, step=%d) should not exist\\n\",\n\t\t\t\t\t       context + idx, order, step);\n\t\t\t\t\terr = -EINVAL;\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (order = SHIFT; order < 64; order += SHIFT) {\n\t\tfor (step = 0; step < KSYNCMAP; step++) {\n\t\t\tu64 context = step * BIT_ULL(order);\n\n\t\t\tif (!i915_syncmap_is_later(&sync, context, 0)) {\n\t\t\t\tpr_err(\"2: context %llx (order=%d, step=%d) not found\\n\",\n\t\t\t\t       context, order, step);\n\t\t\t\terr = -EINVAL;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t}\n\nout:\n\treturn dump_syncmap(sync, err);\n}\n\nstatic int igt_syncmap_neighbours(void *arg)\n{\n\tI915_RND_STATE(prng);\n\tIGT_TIMEOUT(end_time);\n\tstruct i915_syncmap *sync;\n\tint err = -ENODEV;\n\n\t \n\n\ti915_syncmap_init(&sync);\n\tdo {\n\t\tu64 context = i915_prandom_u64_state(&prng) & ~MASK;\n\t\tunsigned int idx;\n\n\t\tif (i915_syncmap_is_later(&sync, context, 0))  \n\t\t\tcontinue;\n\n\t\tfor (idx = 0; idx < KSYNCMAP; idx++) {\n\t\t\terr = i915_syncmap_set(&sync, context + idx, 0);\n\t\t\tif (err)\n\t\t\t\tgoto out;\n\n\t\t\tif (sync->height) {\n\t\t\t\tpr_err(\"Inserting context=%llx did not return leaf (height=%d, prefix=%llx\\n\",\n\t\t\t\t       context, sync->height, sync->prefix);\n\t\t\t\terr = -EINVAL;\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tif (sync->bitmap != BIT(idx + 1) - 1) {\n\t\t\t\tpr_err(\"Inserting neighbouring context=0x%llx+%d, did not fit into the same leaf bitmap=%x (%d), expected %lx (%d)\\n\",\n\t\t\t\t       context, idx,\n\t\t\t\t       sync->bitmap, hweight32(sync->bitmap),\n\t\t\t\t       BIT(idx + 1) - 1, idx + 1);\n\t\t\t\terr = -EINVAL;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t} while (!__igt_timeout(end_time, NULL));\nout:\n\treturn dump_syncmap(sync, err);\n}\n\nstatic int igt_syncmap_compact(void *arg)\n{\n\tstruct i915_syncmap *sync;\n\tunsigned int idx, order;\n\tint err = -ENODEV;\n\n\ti915_syncmap_init(&sync);\n\n\t \n\tfor (order = SHIFT; order < 64; order += SHIFT) {\n\t\terr = check_syncmap_free(&sync);\n\t\tif (err)\n\t\t\tgoto out;\n\n\t\t \n\t\tfor (idx = 0; idx < KSYNCMAP; idx++) {\n\t\t\tu64 context = idx * BIT_ULL(order) + idx;\n\n\t\t\terr = i915_syncmap_set(&sync, context, 0);\n\t\t\tif (err)\n\t\t\t\tgoto out;\n\n\t\t\tif (sync->height) {\n\t\t\t\tpr_err(\"Inserting context=%llx (order=%d, idx=%d) did not return leaf (height=%d, prefix=%llx\\n\",\n\t\t\t\t       context, order, idx,\n\t\t\t\t       sync->height, sync->prefix);\n\t\t\t\terr = -EINVAL;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\n\t\tsync = sync->parent;\n\t\tif (sync->parent) {\n\t\t\tpr_err(\"Parent (join) of last leaf was not the sync!\\n\");\n\t\t\terr = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (sync->height != order) {\n\t\t\tpr_err(\"Join does not have the expected height, found %d, expected %d\\n\",\n\t\t\t       sync->height, order);\n\t\t\terr = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (sync->bitmap != BIT(KSYNCMAP) - 1) {\n\t\t\tpr_err(\"Join is not full!, found %x (%d) expected %lx (%d)\\n\",\n\t\t\t       sync->bitmap, hweight32(sync->bitmap),\n\t\t\t       BIT(KSYNCMAP) - 1, KSYNCMAP);\n\t\t\terr = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t\t \n\t\tfor (idx = 0; idx < KSYNCMAP; idx++) {\n\t\t\tstruct i915_syncmap *leaf = __sync_child(sync)[idx];\n\n\t\t\tif (leaf->height) {\n\t\t\t\tpr_err(\"Child %d is a not leaf!\\n\", idx);\n\t\t\t\terr = -EINVAL;\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tif (leaf->parent != sync) {\n\t\t\t\tpr_err(\"Child %d is not attached to us!\\n\",\n\t\t\t\t       idx);\n\t\t\t\terr = -EINVAL;\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tif (!is_power_of_2(leaf->bitmap)) {\n\t\t\t\tpr_err(\"Child %d holds more than one id, found %x (%d)\\n\",\n\t\t\t\t       idx, leaf->bitmap, hweight32(leaf->bitmap));\n\t\t\t\terr = -EINVAL;\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tif (leaf->bitmap != BIT(idx)) {\n\t\t\t\tpr_err(\"Child %d has wrong seqno idx, found %d, expected %d\\n\",\n\t\t\t\t       idx, ilog2(leaf->bitmap), idx);\n\t\t\t\terr = -EINVAL;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t}\nout:\n\treturn dump_syncmap(sync, err);\n}\n\nstatic int igt_syncmap_random(void *arg)\n{\n\tI915_RND_STATE(prng);\n\tIGT_TIMEOUT(end_time);\n\tstruct i915_syncmap *sync;\n\tunsigned long count, phase, i;\n\tu32 seqno;\n\tint err;\n\n\ti915_syncmap_init(&sync);\n\n\t \n\n\tcount = 0;\n\tphase = jiffies + HZ/100 + 1;\n\tdo {\n\t\tu64 context = i915_prandom_u64_state(&prng);\n\n\t\terr = i915_syncmap_set(&sync, context, 0);\n\t\tif (err)\n\t\t\tgoto out;\n\n\t\tcount++;\n\t} while (!time_after(jiffies, phase));\n\tseqno = 0;\n\n\tphase = 0;\n\tdo {\n\t\tI915_RND_STATE(ctx);\n\t\tu32 last_seqno = seqno;\n\t\tbool expect;\n\n\t\tseqno = prandom_u32_state(&prng);\n\t\texpect = seqno_later(last_seqno, seqno);\n\n\t\tfor (i = 0; i < count; i++) {\n\t\t\tu64 context = i915_prandom_u64_state(&ctx);\n\n\t\t\tif (i915_syncmap_is_later(&sync, context, seqno) != expect) {\n\t\t\t\tpr_err(\"context=%llu, last=%u this=%u did not match expectation (%d)\\n\",\n\t\t\t\t       context, last_seqno, seqno, expect);\n\t\t\t\terr = -EINVAL;\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\terr = i915_syncmap_set(&sync, context, seqno);\n\t\t\tif (err)\n\t\t\t\tgoto out;\n\t\t}\n\n\t\tphase++;\n\t} while (!__igt_timeout(end_time, NULL));\n\tpr_debug(\"Completed %lu passes, each of %lu contexts\\n\", phase, count);\nout:\n\treturn dump_syncmap(sync, err);\n}\n\nint i915_syncmap_mock_selftests(void)\n{\n\tstatic const struct i915_subtest tests[] = {\n\t\tSUBTEST(igt_syncmap_init),\n\t\tSUBTEST(igt_syncmap_one),\n\t\tSUBTEST(igt_syncmap_join_above),\n\t\tSUBTEST(igt_syncmap_join_below),\n\t\tSUBTEST(igt_syncmap_neighbours),\n\t\tSUBTEST(igt_syncmap_compact),\n\t\tSUBTEST(igt_syncmap_random),\n\t};\n\n\treturn i915_subtests(tests, NULL);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}