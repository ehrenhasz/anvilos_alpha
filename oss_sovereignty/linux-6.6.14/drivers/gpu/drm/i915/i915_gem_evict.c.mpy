{
  "module_name": "i915_gem_evict.c",
  "hash_id": "0036db09b4fa934ee43941968ece94e039bcb9eb38b4c50ba82cb90f080c8446",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/i915/i915_gem_evict.c",
  "human_readable_source": " \n\n#include \"gem/i915_gem_context.h\"\n#include \"gt/intel_gt.h\"\n#include \"gt/intel_gt_requests.h\"\n\n#include \"i915_drv.h\"\n#include \"i915_gem_evict.h\"\n#include \"i915_trace.h\"\n\nI915_SELFTEST_DECLARE(static struct igt_evict_ctl {\n\tbool fail_if_busy:1;\n} igt_evict_ctl;)\n\nstatic bool dying_vma(struct i915_vma *vma)\n{\n\treturn !kref_read(&vma->obj->base.refcount);\n}\n\nstatic int ggtt_flush(struct i915_address_space *vm)\n{\n\tstruct i915_ggtt *ggtt = i915_vm_to_ggtt(vm);\n\tstruct intel_gt *gt;\n\tint ret = 0;\n\n\tlist_for_each_entry(gt, &ggtt->gt_list, ggtt_link) {\n\t\t \n\t\tret = intel_gt_wait_for_idle(gt, MAX_SCHEDULE_TIMEOUT);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\treturn ret;\n}\n\nstatic bool grab_vma(struct i915_vma *vma, struct i915_gem_ww_ctx *ww)\n{\n\t \n\tif (i915_gem_object_get_rcu(vma->obj)) {\n\t\tif (!i915_gem_object_trylock(vma->obj, ww)) {\n\t\t\ti915_gem_object_put(vma->obj);\n\t\t\treturn false;\n\t\t}\n\t} else {\n\t\t \n\t\tatomic_and(~I915_VMA_PIN_MASK, &vma->flags);\n\t}\n\n\treturn true;\n}\n\nstatic void ungrab_vma(struct i915_vma *vma)\n{\n\tif (dying_vma(vma))\n\t\treturn;\n\n\ti915_gem_object_unlock(vma->obj);\n\ti915_gem_object_put(vma->obj);\n}\n\nstatic bool\nmark_free(struct drm_mm_scan *scan,\n\t  struct i915_gem_ww_ctx *ww,\n\t  struct i915_vma *vma,\n\t  unsigned int flags,\n\t  struct list_head *unwind)\n{\n\tif (i915_vma_is_pinned(vma))\n\t\treturn false;\n\n\tif (!grab_vma(vma, ww))\n\t\treturn false;\n\n\tlist_add(&vma->evict_link, unwind);\n\treturn drm_mm_scan_add_block(scan, &vma->node);\n}\n\nstatic bool defer_evict(struct i915_vma *vma)\n{\n\tif (i915_vma_is_active(vma))\n\t\treturn true;\n\n\tif (i915_vma_is_scanout(vma))\n\t\treturn true;\n\n\treturn false;\n}\n\n \nint\ni915_gem_evict_something(struct i915_address_space *vm,\n\t\t\t struct i915_gem_ww_ctx *ww,\n\t\t\t u64 min_size, u64 alignment,\n\t\t\t unsigned long color,\n\t\t\t u64 start, u64 end,\n\t\t\t unsigned flags)\n{\n\tstruct drm_mm_scan scan;\n\tstruct list_head eviction_list;\n\tstruct i915_vma *vma, *next;\n\tstruct drm_mm_node *node;\n\tenum drm_mm_insert_mode mode;\n\tstruct i915_vma *active;\n\tstruct intel_gt *gt;\n\tint ret;\n\n\tlockdep_assert_held(&vm->mutex);\n\ttrace_i915_gem_evict(vm, min_size, alignment, flags);\n\n\t \n\tmode = DRM_MM_INSERT_BEST;\n\tif (flags & PIN_HIGH)\n\t\tmode = DRM_MM_INSERT_HIGH;\n\tif (flags & PIN_MAPPABLE)\n\t\tmode = DRM_MM_INSERT_LOW;\n\tdrm_mm_scan_init_with_range(&scan, &vm->mm,\n\t\t\t\t    min_size, alignment, color,\n\t\t\t\t    start, end, mode);\n\n\tif (i915_is_ggtt(vm)) {\n\t\tstruct i915_ggtt *ggtt = i915_vm_to_ggtt(vm);\n\n\t\tlist_for_each_entry(gt, &ggtt->gt_list, ggtt_link)\n\t\t\tintel_gt_retire_requests(gt);\n\t} else {\n\t\tintel_gt_retire_requests(vm->gt);\n\t}\n\nsearch_again:\n\tactive = NULL;\n\tINIT_LIST_HEAD(&eviction_list);\n\tlist_for_each_entry_safe(vma, next, &vm->bound_list, vm_link) {\n\t\tif (vma == active) {  \n\t\t\tif (flags & PIN_NONBLOCK)\n\t\t\t\tbreak;\n\n\t\t\tactive = ERR_PTR(-EAGAIN);\n\t\t}\n\n\t\t \n\t\tif (active != ERR_PTR(-EAGAIN) && defer_evict(vma)) {\n\t\t\tif (!active)\n\t\t\t\tactive = vma;\n\n\t\t\tlist_move_tail(&vma->vm_link, &vm->bound_list);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (mark_free(&scan, ww, vma, flags, &eviction_list))\n\t\t\tgoto found;\n\t}\n\n\t \n\tlist_for_each_entry_safe(vma, next, &eviction_list, evict_link) {\n\t\tret = drm_mm_scan_remove_block(&scan, &vma->node);\n\t\tBUG_ON(ret);\n\t\tungrab_vma(vma);\n\t}\n\n\t \n\tif (!i915_is_ggtt(vm) || flags & PIN_NONBLOCK)\n\t\treturn -ENOSPC;\n\n\t \n\tif (I915_SELFTEST_ONLY(igt_evict_ctl.fail_if_busy))\n\t\treturn -EBUSY;\n\n\tret = ggtt_flush(vm);\n\tif (ret)\n\t\treturn ret;\n\n\tcond_resched();\n\n\tflags |= PIN_NONBLOCK;\n\tgoto search_again;\n\nfound:\n\t \n\tlist_for_each_entry_safe(vma, next, &eviction_list, evict_link) {\n\t\tif (drm_mm_scan_remove_block(&scan, &vma->node)) {\n\t\t\t__i915_vma_pin(vma);\n\t\t} else {\n\t\t\tlist_del(&vma->evict_link);\n\t\t\tungrab_vma(vma);\n\t\t}\n\t}\n\n\t \n\tret = 0;\n\tlist_for_each_entry_safe(vma, next, &eviction_list, evict_link) {\n\t\t__i915_vma_unpin(vma);\n\t\tif (ret == 0)\n\t\t\tret = __i915_vma_unbind(vma);\n\t\tungrab_vma(vma);\n\t}\n\n\twhile (ret == 0 && (node = drm_mm_scan_color_evict(&scan))) {\n\t\tvma = container_of(node, struct i915_vma, node);\n\n\t\t \n\t\tif (vma->node.color != I915_COLOR_UNEVICTABLE &&\n\t\t    grab_vma(vma, ww)) {\n\t\t\tret = __i915_vma_unbind(vma);\n\t\t\tungrab_vma(vma);\n\t\t} else {\n\t\t\tret = -ENOSPC;\n\t\t}\n\t}\n\n\treturn ret;\n}\n\n \nint i915_gem_evict_for_node(struct i915_address_space *vm,\n\t\t\t    struct i915_gem_ww_ctx *ww,\n\t\t\t    struct drm_mm_node *target,\n\t\t\t    unsigned int flags)\n{\n\tLIST_HEAD(eviction_list);\n\tstruct drm_mm_node *node;\n\tu64 start = target->start;\n\tu64 end = start + target->size;\n\tstruct i915_vma *vma, *next;\n\tint ret = 0;\n\n\tlockdep_assert_held(&vm->mutex);\n\tGEM_BUG_ON(!IS_ALIGNED(start, I915_GTT_PAGE_SIZE));\n\tGEM_BUG_ON(!IS_ALIGNED(end, I915_GTT_PAGE_SIZE));\n\n\ttrace_i915_gem_evict_node(vm, target, flags);\n\n\t \n\tif (i915_is_ggtt(vm)) {\n\t\tstruct i915_ggtt *ggtt = i915_vm_to_ggtt(vm);\n\t\tstruct intel_gt *gt;\n\n\t\tlist_for_each_entry(gt, &ggtt->gt_list, ggtt_link)\n\t\t\tintel_gt_retire_requests(gt);\n\t} else {\n\t\tintel_gt_retire_requests(vm->gt);\n\t}\n\n\tif (i915_vm_has_cache_coloring(vm)) {\n\t\t \n\t\tif (start)\n\t\t\tstart -= I915_GTT_PAGE_SIZE;\n\n\t\t \n\t\tend += I915_GTT_PAGE_SIZE;\n\t}\n\tGEM_BUG_ON(start >= end);\n\n\tdrm_mm_for_each_node_in_range(node, &vm->mm, start, end) {\n\t\t \n\t\tif (node->color == I915_COLOR_UNEVICTABLE) {\n\t\t\tret = -ENOSPC;\n\t\t\tbreak;\n\t\t}\n\n\t\tGEM_BUG_ON(!drm_mm_node_allocated(node));\n\t\tvma = container_of(node, typeof(*vma), node);\n\n\t\t \n\t\tif (i915_vm_has_cache_coloring(vm)) {\n\t\t\tif (node->start + node->size == target->start) {\n\t\t\t\tif (node->color == target->color)\n\t\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (node->start == target->start + target->size) {\n\t\t\t\tif (node->color == target->color)\n\t\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\tif (i915_vma_is_pinned(vma)) {\n\t\t\tret = -ENOSPC;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (flags & PIN_NONBLOCK && i915_vma_is_active(vma)) {\n\t\t\tret = -ENOSPC;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (!grab_vma(vma, ww)) {\n\t\t\tret = -ENOSPC;\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\t__i915_vma_pin(vma);\n\t\tlist_add(&vma->evict_link, &eviction_list);\n\t}\n\n\tlist_for_each_entry_safe(vma, next, &eviction_list, evict_link) {\n\t\t__i915_vma_unpin(vma);\n\t\tif (ret == 0)\n\t\t\tret = __i915_vma_unbind(vma);\n\n\t\tungrab_vma(vma);\n\t}\n\n\treturn ret;\n}\n\n \nint i915_gem_evict_vm(struct i915_address_space *vm, struct i915_gem_ww_ctx *ww,\n\t\t      struct drm_i915_gem_object **busy_bo)\n{\n\tint ret = 0;\n\n\tlockdep_assert_held(&vm->mutex);\n\ttrace_i915_gem_evict_vm(vm);\n\n\t \n\tif (i915_is_ggtt(vm)) {\n\t\tret = ggtt_flush(vm);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tdo {\n\t\tstruct i915_vma *vma, *vn;\n\t\tLIST_HEAD(eviction_list);\n\t\tLIST_HEAD(locked_eviction_list);\n\n\t\tlist_for_each_entry(vma, &vm->bound_list, vm_link) {\n\t\t\tif (i915_vma_is_pinned(vma))\n\t\t\t\tcontinue;\n\n\t\t\t \n\t\t\tif (!i915_gem_object_get_rcu(vma->obj) ||\n\t\t\t    (ww && (dma_resv_locking_ctx(vma->obj->base.resv) == &ww->ctx))) {\n\t\t\t\t__i915_vma_pin(vma);\n\t\t\t\tlist_add(&vma->evict_link, &locked_eviction_list);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (!i915_gem_object_trylock(vma->obj, ww)) {\n\t\t\t\tif (busy_bo) {\n\t\t\t\t\t*busy_bo = vma->obj;  \n\t\t\t\t\tret = -EBUSY;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\ti915_gem_object_put(vma->obj);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t__i915_vma_pin(vma);\n\t\t\tlist_add(&vma->evict_link, &eviction_list);\n\t\t}\n\t\tif (list_empty(&eviction_list) && list_empty(&locked_eviction_list))\n\t\t\tbreak;\n\n\t\t \n\t\tlist_for_each_entry_safe(vma, vn, &locked_eviction_list, evict_link) {\n\t\t\t__i915_vma_unpin(vma);\n\n\t\t\tif (ret == 0) {\n\t\t\t\tret = __i915_vma_unbind(vma);\n\t\t\t\tif (ret != -EINTR)  \n\t\t\t\t\tret = 0;\n\t\t\t}\n\t\t\tif (!dying_vma(vma))\n\t\t\t\ti915_gem_object_put(vma->obj);\n\t\t}\n\n\t\tlist_for_each_entry_safe(vma, vn, &eviction_list, evict_link) {\n\t\t\t__i915_vma_unpin(vma);\n\t\t\tif (ret == 0) {\n\t\t\t\tret = __i915_vma_unbind(vma);\n\t\t\t\tif (ret != -EINTR)  \n\t\t\t\t\tret = 0;\n\t\t\t}\n\n\t\t\ti915_gem_object_unlock(vma->obj);\n\t\t\ti915_gem_object_put(vma->obj);\n\t\t}\n\t} while (ret == 0);\n\n\treturn ret;\n}\n\n#if IS_ENABLED(CONFIG_DRM_I915_SELFTEST)\n#include \"selftests/i915_gem_evict.c\"\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}