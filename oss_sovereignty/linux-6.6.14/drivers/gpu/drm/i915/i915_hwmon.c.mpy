{
  "module_name": "i915_hwmon.c",
  "hash_id": "02c7a74a804632e81c5e8692e3a504d81e78caf3c9098e586262150a79f1b270",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/i915/i915_hwmon.c",
  "human_readable_source": "\n \n\n#include <linux/hwmon.h>\n#include <linux/hwmon-sysfs.h>\n#include <linux/types.h>\n\n#include \"i915_drv.h\"\n#include \"i915_hwmon.h\"\n#include \"i915_reg.h\"\n#include \"intel_mchbar_regs.h\"\n#include \"intel_pcode.h\"\n#include \"gt/intel_gt.h\"\n#include \"gt/intel_gt_regs.h\"\n\n \n#define SF_VOLTAGE\t1000\n#define SF_POWER\t1000000\n#define SF_CURR\t\t1000\n#define SF_ENERGY\t1000000\n#define SF_TIME\t\t1000\n\nstruct hwm_reg {\n\ti915_reg_t gt_perf_status;\n\ti915_reg_t pkg_power_sku_unit;\n\ti915_reg_t pkg_power_sku;\n\ti915_reg_t pkg_rapl_limit;\n\ti915_reg_t energy_status_all;\n\ti915_reg_t energy_status_tile;\n};\n\nstruct hwm_energy_info {\n\tu32 reg_val_prev;\n\tlong accum_energy;\t\t\t \n};\n\nstruct hwm_drvdata {\n\tstruct i915_hwmon *hwmon;\n\tstruct intel_uncore *uncore;\n\tstruct device *hwmon_dev;\n\tstruct hwm_energy_info ei;\t\t \n\tchar name[12];\n\tint gt_n;\n\tbool reset_in_progress;\n\twait_queue_head_t waitq;\n};\n\nstruct i915_hwmon {\n\tstruct hwm_drvdata ddat;\n\tstruct hwm_drvdata ddat_gt[I915_MAX_GT];\n\tstruct mutex hwmon_lock;\t\t \n\tstruct hwm_reg rg;\n\tint scl_shift_power;\n\tint scl_shift_energy;\n\tint scl_shift_time;\n};\n\nstatic void\nhwm_locked_with_pm_intel_uncore_rmw(struct hwm_drvdata *ddat,\n\t\t\t\t    i915_reg_t reg, u32 clear, u32 set)\n{\n\tstruct i915_hwmon *hwmon = ddat->hwmon;\n\tstruct intel_uncore *uncore = ddat->uncore;\n\tintel_wakeref_t wakeref;\n\n\tmutex_lock(&hwmon->hwmon_lock);\n\n\twith_intel_runtime_pm(uncore->rpm, wakeref)\n\t\tintel_uncore_rmw(uncore, reg, clear, set);\n\n\tmutex_unlock(&hwmon->hwmon_lock);\n}\n\n \nstatic u64\nhwm_field_read_and_scale(struct hwm_drvdata *ddat, i915_reg_t rgadr,\n\t\t\t u32 field_msk, int nshift, u32 scale_factor)\n{\n\tstruct intel_uncore *uncore = ddat->uncore;\n\tintel_wakeref_t wakeref;\n\tu32 reg_value;\n\n\twith_intel_runtime_pm(uncore->rpm, wakeref)\n\t\treg_value = intel_uncore_read(uncore, rgadr);\n\n\treg_value = REG_FIELD_GET(field_msk, reg_value);\n\n\treturn mul_u64_u32_shr(reg_value, scale_factor, nshift);\n}\n\n \nstatic void\nhwm_energy(struct hwm_drvdata *ddat, long *energy)\n{\n\tstruct intel_uncore *uncore = ddat->uncore;\n\tstruct i915_hwmon *hwmon = ddat->hwmon;\n\tstruct hwm_energy_info *ei = &ddat->ei;\n\tintel_wakeref_t wakeref;\n\ti915_reg_t rgaddr;\n\tu32 reg_val;\n\n\tif (ddat->gt_n >= 0)\n\t\trgaddr = hwmon->rg.energy_status_tile;\n\telse\n\t\trgaddr = hwmon->rg.energy_status_all;\n\n\tmutex_lock(&hwmon->hwmon_lock);\n\n\twith_intel_runtime_pm(uncore->rpm, wakeref)\n\t\treg_val = intel_uncore_read(uncore, rgaddr);\n\n\tif (reg_val >= ei->reg_val_prev)\n\t\tei->accum_energy += reg_val - ei->reg_val_prev;\n\telse\n\t\tei->accum_energy += UINT_MAX - ei->reg_val_prev + reg_val;\n\tei->reg_val_prev = reg_val;\n\n\t*energy = mul_u64_u32_shr(ei->accum_energy, SF_ENERGY,\n\t\t\t\t  hwmon->scl_shift_energy);\n\tmutex_unlock(&hwmon->hwmon_lock);\n}\n\nstatic ssize_t\nhwm_power1_max_interval_show(struct device *dev, struct device_attribute *attr,\n\t\t\t     char *buf)\n{\n\tstruct hwm_drvdata *ddat = dev_get_drvdata(dev);\n\tstruct i915_hwmon *hwmon = ddat->hwmon;\n\tintel_wakeref_t wakeref;\n\tu32 r, x, y, x_w = 2;  \n\tu64 tau4, out;\n\n\twith_intel_runtime_pm(ddat->uncore->rpm, wakeref)\n\t\tr = intel_uncore_read(ddat->uncore, hwmon->rg.pkg_rapl_limit);\n\n\tx = REG_FIELD_GET(PKG_PWR_LIM_1_TIME_X, r);\n\ty = REG_FIELD_GET(PKG_PWR_LIM_1_TIME_Y, r);\n\t \n\ttau4 = (u64)((1 << x_w) | x) << y;\n\t \n\tout = mul_u64_u32_shr(tau4, SF_TIME, hwmon->scl_shift_time + x_w);\n\n\treturn sysfs_emit(buf, \"%llu\\n\", out);\n}\n\nstatic ssize_t\nhwm_power1_max_interval_store(struct device *dev,\n\t\t\t      struct device_attribute *attr,\n\t\t\t      const char *buf, size_t count)\n{\n\tstruct hwm_drvdata *ddat = dev_get_drvdata(dev);\n\tstruct i915_hwmon *hwmon = ddat->hwmon;\n\tu32 x, y, rxy, x_w = 2;  \n\tu64 tau4, r, max_win;\n\tunsigned long val;\n\tint ret;\n\n\tret = kstrtoul(buf, 0, &val);\n\tif (ret)\n\t\treturn ret;\n\n\t \n#define PKG_MAX_WIN_DEFAULT 0x12ull\n\n\t \n\tr = FIELD_PREP(PKG_MAX_WIN, PKG_MAX_WIN_DEFAULT);\n\tx = REG_FIELD_GET(PKG_MAX_WIN_X, r);\n\ty = REG_FIELD_GET(PKG_MAX_WIN_Y, r);\n\ttau4 = (u64)((1 << x_w) | x) << y;\n\tmax_win = mul_u64_u32_shr(tau4, SF_TIME, hwmon->scl_shift_time + x_w);\n\n\tif (val > max_win)\n\t\treturn -EINVAL;\n\n\t \n\tval = DIV_ROUND_CLOSEST_ULL((u64)val << hwmon->scl_shift_time, SF_TIME);\n\t \n\tif (!val) {\n\t\t \n\t\ty = 0;\n\t\tx = 0;\n\t} else {\n\t\ty = ilog2(val);\n\t\t \n\t\tx = (val - (1ul << y)) << x_w >> y;\n\t}\n\n\trxy = REG_FIELD_PREP(PKG_PWR_LIM_1_TIME_X, x) | REG_FIELD_PREP(PKG_PWR_LIM_1_TIME_Y, y);\n\n\thwm_locked_with_pm_intel_uncore_rmw(ddat, hwmon->rg.pkg_rapl_limit,\n\t\t\t\t\t    PKG_PWR_LIM_1_TIME, rxy);\n\treturn count;\n}\n\nstatic SENSOR_DEVICE_ATTR(power1_max_interval, 0664,\n\t\t\t  hwm_power1_max_interval_show,\n\t\t\t  hwm_power1_max_interval_store, 0);\n\nstatic struct attribute *hwm_attributes[] = {\n\t&sensor_dev_attr_power1_max_interval.dev_attr.attr,\n\tNULL\n};\n\nstatic umode_t hwm_attributes_visible(struct kobject *kobj,\n\t\t\t\t      struct attribute *attr, int index)\n{\n\tstruct device *dev = kobj_to_dev(kobj);\n\tstruct hwm_drvdata *ddat = dev_get_drvdata(dev);\n\tstruct i915_hwmon *hwmon = ddat->hwmon;\n\n\tif (attr == &sensor_dev_attr_power1_max_interval.dev_attr.attr)\n\t\treturn i915_mmio_reg_valid(hwmon->rg.pkg_rapl_limit) ? attr->mode : 0;\n\n\treturn 0;\n}\n\nstatic const struct attribute_group hwm_attrgroup = {\n\t.attrs = hwm_attributes,\n\t.is_visible = hwm_attributes_visible,\n};\n\nstatic const struct attribute_group *hwm_groups[] = {\n\t&hwm_attrgroup,\n\tNULL\n};\n\nstatic const struct hwmon_channel_info * const hwm_info[] = {\n\tHWMON_CHANNEL_INFO(in, HWMON_I_INPUT),\n\tHWMON_CHANNEL_INFO(power, HWMON_P_MAX | HWMON_P_RATED_MAX | HWMON_P_CRIT),\n\tHWMON_CHANNEL_INFO(energy, HWMON_E_INPUT),\n\tHWMON_CHANNEL_INFO(curr, HWMON_C_CRIT),\n\tNULL\n};\n\nstatic const struct hwmon_channel_info * const hwm_gt_info[] = {\n\tHWMON_CHANNEL_INFO(energy, HWMON_E_INPUT),\n\tNULL\n};\n\n \nstatic int hwm_pcode_read_i1(struct drm_i915_private *i915, u32 *uval)\n{\n\t \n\tif (IS_DG1(i915) || IS_DG2(i915))\n\t\treturn -ENXIO;\n\n\treturn snb_pcode_read_p(&i915->uncore, PCODE_POWER_SETUP,\n\t\t\t\tPOWER_SETUP_SUBCOMMAND_READ_I1, 0, uval);\n}\n\nstatic int hwm_pcode_write_i1(struct drm_i915_private *i915, u32 uval)\n{\n\treturn  snb_pcode_write_p(&i915->uncore, PCODE_POWER_SETUP,\n\t\t\t\t  POWER_SETUP_SUBCOMMAND_WRITE_I1, 0, uval);\n}\n\nstatic umode_t\nhwm_in_is_visible(const struct hwm_drvdata *ddat, u32 attr)\n{\n\tstruct drm_i915_private *i915 = ddat->uncore->i915;\n\n\tswitch (attr) {\n\tcase hwmon_in_input:\n\t\treturn IS_DG1(i915) || IS_DG2(i915) ? 0444 : 0;\n\tdefault:\n\t\treturn 0;\n\t}\n}\n\nstatic int\nhwm_in_read(struct hwm_drvdata *ddat, u32 attr, long *val)\n{\n\tstruct i915_hwmon *hwmon = ddat->hwmon;\n\tintel_wakeref_t wakeref;\n\tu32 reg_value;\n\n\tswitch (attr) {\n\tcase hwmon_in_input:\n\t\twith_intel_runtime_pm(ddat->uncore->rpm, wakeref)\n\t\t\treg_value = intel_uncore_read(ddat->uncore, hwmon->rg.gt_perf_status);\n\t\t \n\t\t*val = DIV_ROUND_CLOSEST(REG_FIELD_GET(GEN12_VOLTAGE_MASK, reg_value) * 25, 10);\n\t\treturn 0;\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n}\n\nstatic umode_t\nhwm_power_is_visible(const struct hwm_drvdata *ddat, u32 attr, int chan)\n{\n\tstruct drm_i915_private *i915 = ddat->uncore->i915;\n\tstruct i915_hwmon *hwmon = ddat->hwmon;\n\tu32 uval;\n\n\tswitch (attr) {\n\tcase hwmon_power_max:\n\t\treturn i915_mmio_reg_valid(hwmon->rg.pkg_rapl_limit) ? 0664 : 0;\n\tcase hwmon_power_rated_max:\n\t\treturn i915_mmio_reg_valid(hwmon->rg.pkg_power_sku) ? 0444 : 0;\n\tcase hwmon_power_crit:\n\t\treturn (hwm_pcode_read_i1(i915, &uval) ||\n\t\t\t!(uval & POWER_SETUP_I1_WATTS)) ? 0 : 0644;\n\tdefault:\n\t\treturn 0;\n\t}\n}\n\n#define PL1_DISABLE 0\n\n \nstatic int\nhwm_power_max_read(struct hwm_drvdata *ddat, long *val)\n{\n\tstruct i915_hwmon *hwmon = ddat->hwmon;\n\tintel_wakeref_t wakeref;\n\tu64 r, min, max;\n\n\t \n\twith_intel_runtime_pm(ddat->uncore->rpm, wakeref)\n\t\tr = intel_uncore_read(ddat->uncore, hwmon->rg.pkg_rapl_limit);\n\tif (!(r & PKG_PWR_LIM_1_EN)) {\n\t\t*val = PL1_DISABLE;\n\t\treturn 0;\n\t}\n\n\t*val = hwm_field_read_and_scale(ddat,\n\t\t\t\t\thwmon->rg.pkg_rapl_limit,\n\t\t\t\t\tPKG_PWR_LIM_1,\n\t\t\t\t\thwmon->scl_shift_power,\n\t\t\t\t\tSF_POWER);\n\n\twith_intel_runtime_pm(ddat->uncore->rpm, wakeref)\n\t\tr = intel_uncore_read64(ddat->uncore, hwmon->rg.pkg_power_sku);\n\tmin = REG_FIELD_GET(PKG_MIN_PWR, r);\n\tmin = mul_u64_u32_shr(min, SF_POWER, hwmon->scl_shift_power);\n\tmax = REG_FIELD_GET(PKG_MAX_PWR, r);\n\tmax = mul_u64_u32_shr(max, SF_POWER, hwmon->scl_shift_power);\n\n\tif (min && max)\n\t\t*val = clamp_t(u64, *val, min, max);\n\n\treturn 0;\n}\n\nstatic int\nhwm_power_max_write(struct hwm_drvdata *ddat, long val)\n{\n\tstruct i915_hwmon *hwmon = ddat->hwmon;\n\tintel_wakeref_t wakeref;\n\tDEFINE_WAIT(wait);\n\tint ret = 0;\n\tu32 nval;\n\n\t \n\tfor (;;) {\n\t\tmutex_lock(&hwmon->hwmon_lock);\n\n\t\tprepare_to_wait(&ddat->waitq, &wait, TASK_INTERRUPTIBLE);\n\n\t\tif (!hwmon->ddat.reset_in_progress)\n\t\t\tbreak;\n\n\t\tif (signal_pending(current)) {\n\t\t\tret = -EINTR;\n\t\t\tbreak;\n\t\t}\n\n\t\tmutex_unlock(&hwmon->hwmon_lock);\n\n\t\tschedule();\n\t}\n\tfinish_wait(&ddat->waitq, &wait);\n\tif (ret)\n\t\tgoto unlock;\n\n\twakeref = intel_runtime_pm_get(ddat->uncore->rpm);\n\n\t \n\tif (val == PL1_DISABLE) {\n\t\tintel_uncore_rmw(ddat->uncore, hwmon->rg.pkg_rapl_limit,\n\t\t\t\t PKG_PWR_LIM_1_EN, 0);\n\t\tnval = intel_uncore_read(ddat->uncore, hwmon->rg.pkg_rapl_limit);\n\n\t\tif (nval & PKG_PWR_LIM_1_EN)\n\t\t\tret = -ENODEV;\n\t\tgoto exit;\n\t}\n\n\t \n\tnval = DIV_ROUND_CLOSEST_ULL((u64)val << hwmon->scl_shift_power, SF_POWER);\n\tnval = PKG_PWR_LIM_1_EN | REG_FIELD_PREP(PKG_PWR_LIM_1, nval);\n\n\tintel_uncore_rmw(ddat->uncore, hwmon->rg.pkg_rapl_limit,\n\t\t\t PKG_PWR_LIM_1_EN | PKG_PWR_LIM_1, nval);\nexit:\n\tintel_runtime_pm_put(ddat->uncore->rpm, wakeref);\nunlock:\n\tmutex_unlock(&hwmon->hwmon_lock);\n\treturn ret;\n}\n\nstatic int\nhwm_power_read(struct hwm_drvdata *ddat, u32 attr, int chan, long *val)\n{\n\tstruct i915_hwmon *hwmon = ddat->hwmon;\n\tint ret;\n\tu32 uval;\n\n\tswitch (attr) {\n\tcase hwmon_power_max:\n\t\treturn hwm_power_max_read(ddat, val);\n\tcase hwmon_power_rated_max:\n\t\t*val = hwm_field_read_and_scale(ddat,\n\t\t\t\t\t\thwmon->rg.pkg_power_sku,\n\t\t\t\t\t\tPKG_PKG_TDP,\n\t\t\t\t\t\thwmon->scl_shift_power,\n\t\t\t\t\t\tSF_POWER);\n\t\treturn 0;\n\tcase hwmon_power_crit:\n\t\tret = hwm_pcode_read_i1(ddat->uncore->i915, &uval);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tif (!(uval & POWER_SETUP_I1_WATTS))\n\t\t\treturn -ENODEV;\n\t\t*val = mul_u64_u32_shr(REG_FIELD_GET(POWER_SETUP_I1_DATA_MASK, uval),\n\t\t\t\t       SF_POWER, POWER_SETUP_I1_SHIFT);\n\t\treturn 0;\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n}\n\nstatic int\nhwm_power_write(struct hwm_drvdata *ddat, u32 attr, int chan, long val)\n{\n\tu32 uval;\n\n\tswitch (attr) {\n\tcase hwmon_power_max:\n\t\treturn hwm_power_max_write(ddat, val);\n\tcase hwmon_power_crit:\n\t\tuval = DIV_ROUND_CLOSEST_ULL(val << POWER_SETUP_I1_SHIFT, SF_POWER);\n\t\treturn hwm_pcode_write_i1(ddat->uncore->i915, uval);\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n}\n\nvoid i915_hwmon_power_max_disable(struct drm_i915_private *i915, bool *old)\n{\n\tstruct i915_hwmon *hwmon = i915->hwmon;\n\tu32 r;\n\n\tif (!hwmon || !i915_mmio_reg_valid(hwmon->rg.pkg_rapl_limit))\n\t\treturn;\n\n\tmutex_lock(&hwmon->hwmon_lock);\n\n\thwmon->ddat.reset_in_progress = true;\n\tr = intel_uncore_rmw(hwmon->ddat.uncore, hwmon->rg.pkg_rapl_limit,\n\t\t\t     PKG_PWR_LIM_1_EN, 0);\n\t*old = !!(r & PKG_PWR_LIM_1_EN);\n\n\tmutex_unlock(&hwmon->hwmon_lock);\n}\n\nvoid i915_hwmon_power_max_restore(struct drm_i915_private *i915, bool old)\n{\n\tstruct i915_hwmon *hwmon = i915->hwmon;\n\n\tif (!hwmon || !i915_mmio_reg_valid(hwmon->rg.pkg_rapl_limit))\n\t\treturn;\n\n\tmutex_lock(&hwmon->hwmon_lock);\n\n\tintel_uncore_rmw(hwmon->ddat.uncore, hwmon->rg.pkg_rapl_limit,\n\t\t\t PKG_PWR_LIM_1_EN, old ? PKG_PWR_LIM_1_EN : 0);\n\thwmon->ddat.reset_in_progress = false;\n\twake_up_all(&hwmon->ddat.waitq);\n\n\tmutex_unlock(&hwmon->hwmon_lock);\n}\n\nstatic umode_t\nhwm_energy_is_visible(const struct hwm_drvdata *ddat, u32 attr)\n{\n\tstruct i915_hwmon *hwmon = ddat->hwmon;\n\ti915_reg_t rgaddr;\n\n\tswitch (attr) {\n\tcase hwmon_energy_input:\n\t\tif (ddat->gt_n >= 0)\n\t\t\trgaddr = hwmon->rg.energy_status_tile;\n\t\telse\n\t\t\trgaddr = hwmon->rg.energy_status_all;\n\t\treturn i915_mmio_reg_valid(rgaddr) ? 0444 : 0;\n\tdefault:\n\t\treturn 0;\n\t}\n}\n\nstatic int\nhwm_energy_read(struct hwm_drvdata *ddat, u32 attr, long *val)\n{\n\tswitch (attr) {\n\tcase hwmon_energy_input:\n\t\thwm_energy(ddat, val);\n\t\treturn 0;\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n}\n\nstatic umode_t\nhwm_curr_is_visible(const struct hwm_drvdata *ddat, u32 attr)\n{\n\tstruct drm_i915_private *i915 = ddat->uncore->i915;\n\tu32 uval;\n\n\tswitch (attr) {\n\tcase hwmon_curr_crit:\n\t\treturn (hwm_pcode_read_i1(i915, &uval) ||\n\t\t\t(uval & POWER_SETUP_I1_WATTS)) ? 0 : 0644;\n\tdefault:\n\t\treturn 0;\n\t}\n}\n\nstatic int\nhwm_curr_read(struct hwm_drvdata *ddat, u32 attr, long *val)\n{\n\tint ret;\n\tu32 uval;\n\n\tswitch (attr) {\n\tcase hwmon_curr_crit:\n\t\tret = hwm_pcode_read_i1(ddat->uncore->i915, &uval);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tif (uval & POWER_SETUP_I1_WATTS)\n\t\t\treturn -ENODEV;\n\t\t*val = mul_u64_u32_shr(REG_FIELD_GET(POWER_SETUP_I1_DATA_MASK, uval),\n\t\t\t\t       SF_CURR, POWER_SETUP_I1_SHIFT);\n\t\treturn 0;\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n}\n\nstatic int\nhwm_curr_write(struct hwm_drvdata *ddat, u32 attr, long val)\n{\n\tu32 uval;\n\n\tswitch (attr) {\n\tcase hwmon_curr_crit:\n\t\tuval = DIV_ROUND_CLOSEST_ULL(val << POWER_SETUP_I1_SHIFT, SF_CURR);\n\t\treturn hwm_pcode_write_i1(ddat->uncore->i915, uval);\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n}\n\nstatic umode_t\nhwm_is_visible(const void *drvdata, enum hwmon_sensor_types type,\n\t       u32 attr, int channel)\n{\n\tstruct hwm_drvdata *ddat = (struct hwm_drvdata *)drvdata;\n\n\tswitch (type) {\n\tcase hwmon_in:\n\t\treturn hwm_in_is_visible(ddat, attr);\n\tcase hwmon_power:\n\t\treturn hwm_power_is_visible(ddat, attr, channel);\n\tcase hwmon_energy:\n\t\treturn hwm_energy_is_visible(ddat, attr);\n\tcase hwmon_curr:\n\t\treturn hwm_curr_is_visible(ddat, attr);\n\tdefault:\n\t\treturn 0;\n\t}\n}\n\nstatic int\nhwm_read(struct device *dev, enum hwmon_sensor_types type, u32 attr,\n\t int channel, long *val)\n{\n\tstruct hwm_drvdata *ddat = dev_get_drvdata(dev);\n\n\tswitch (type) {\n\tcase hwmon_in:\n\t\treturn hwm_in_read(ddat, attr, val);\n\tcase hwmon_power:\n\t\treturn hwm_power_read(ddat, attr, channel, val);\n\tcase hwmon_energy:\n\t\treturn hwm_energy_read(ddat, attr, val);\n\tcase hwmon_curr:\n\t\treturn hwm_curr_read(ddat, attr, val);\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n}\n\nstatic int\nhwm_write(struct device *dev, enum hwmon_sensor_types type, u32 attr,\n\t  int channel, long val)\n{\n\tstruct hwm_drvdata *ddat = dev_get_drvdata(dev);\n\n\tswitch (type) {\n\tcase hwmon_power:\n\t\treturn hwm_power_write(ddat, attr, channel, val);\n\tcase hwmon_curr:\n\t\treturn hwm_curr_write(ddat, attr, val);\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n}\n\nstatic const struct hwmon_ops hwm_ops = {\n\t.is_visible = hwm_is_visible,\n\t.read = hwm_read,\n\t.write = hwm_write,\n};\n\nstatic const struct hwmon_chip_info hwm_chip_info = {\n\t.ops = &hwm_ops,\n\t.info = hwm_info,\n};\n\nstatic umode_t\nhwm_gt_is_visible(const void *drvdata, enum hwmon_sensor_types type,\n\t\t  u32 attr, int channel)\n{\n\tstruct hwm_drvdata *ddat = (struct hwm_drvdata *)drvdata;\n\n\tswitch (type) {\n\tcase hwmon_energy:\n\t\treturn hwm_energy_is_visible(ddat, attr);\n\tdefault:\n\t\treturn 0;\n\t}\n}\n\nstatic int\nhwm_gt_read(struct device *dev, enum hwmon_sensor_types type, u32 attr,\n\t    int channel, long *val)\n{\n\tstruct hwm_drvdata *ddat = dev_get_drvdata(dev);\n\n\tswitch (type) {\n\tcase hwmon_energy:\n\t\treturn hwm_energy_read(ddat, attr, val);\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n}\n\nstatic const struct hwmon_ops hwm_gt_ops = {\n\t.is_visible = hwm_gt_is_visible,\n\t.read = hwm_gt_read,\n};\n\nstatic const struct hwmon_chip_info hwm_gt_chip_info = {\n\t.ops = &hwm_gt_ops,\n\t.info = hwm_gt_info,\n};\n\nstatic void\nhwm_get_preregistration_info(struct drm_i915_private *i915)\n{\n\tstruct i915_hwmon *hwmon = i915->hwmon;\n\tstruct intel_uncore *uncore = &i915->uncore;\n\tstruct hwm_drvdata *ddat = &hwmon->ddat;\n\tintel_wakeref_t wakeref;\n\tu32 val_sku_unit = 0;\n\tstruct intel_gt *gt;\n\tlong energy;\n\tint i;\n\n\t \n\thwmon->rg.gt_perf_status = GEN12_RPSTAT1;\n\n\tif (IS_DG1(i915) || IS_DG2(i915)) {\n\t\thwmon->rg.pkg_power_sku_unit = PCU_PACKAGE_POWER_SKU_UNIT;\n\t\thwmon->rg.pkg_power_sku = PCU_PACKAGE_POWER_SKU;\n\t\thwmon->rg.pkg_rapl_limit = PCU_PACKAGE_RAPL_LIMIT;\n\t\thwmon->rg.energy_status_all = PCU_PACKAGE_ENERGY_STATUS;\n\t\thwmon->rg.energy_status_tile = INVALID_MMIO_REG;\n\t} else if (IS_XEHPSDV(i915)) {\n\t\thwmon->rg.pkg_power_sku_unit = GT0_PACKAGE_POWER_SKU_UNIT;\n\t\thwmon->rg.pkg_power_sku = INVALID_MMIO_REG;\n\t\thwmon->rg.pkg_rapl_limit = GT0_PACKAGE_RAPL_LIMIT;\n\t\thwmon->rg.energy_status_all = GT0_PLATFORM_ENERGY_STATUS;\n\t\thwmon->rg.energy_status_tile = GT0_PACKAGE_ENERGY_STATUS;\n\t} else {\n\t\thwmon->rg.pkg_power_sku_unit = INVALID_MMIO_REG;\n\t\thwmon->rg.pkg_power_sku = INVALID_MMIO_REG;\n\t\thwmon->rg.pkg_rapl_limit = INVALID_MMIO_REG;\n\t\thwmon->rg.energy_status_all = INVALID_MMIO_REG;\n\t\thwmon->rg.energy_status_tile = INVALID_MMIO_REG;\n\t}\n\n\twith_intel_runtime_pm(uncore->rpm, wakeref) {\n\t\t \n\t\tif (i915_mmio_reg_valid(hwmon->rg.pkg_power_sku_unit))\n\t\t\tval_sku_unit = intel_uncore_read(uncore,\n\t\t\t\t\t\t\t hwmon->rg.pkg_power_sku_unit);\n\t}\n\n\thwmon->scl_shift_power = REG_FIELD_GET(PKG_PWR_UNIT, val_sku_unit);\n\thwmon->scl_shift_energy = REG_FIELD_GET(PKG_ENERGY_UNIT, val_sku_unit);\n\thwmon->scl_shift_time = REG_FIELD_GET(PKG_TIME_UNIT, val_sku_unit);\n\n\t \n\tif (i915_mmio_reg_valid(hwmon->rg.energy_status_all))\n\t\thwm_energy(ddat, &energy);\n\tif (i915_mmio_reg_valid(hwmon->rg.energy_status_tile)) {\n\t\tfor_each_gt(gt, i915, i)\n\t\t\thwm_energy(&hwmon->ddat_gt[i], &energy);\n\t}\n}\n\nvoid i915_hwmon_register(struct drm_i915_private *i915)\n{\n\tstruct device *dev = i915->drm.dev;\n\tstruct i915_hwmon *hwmon;\n\tstruct device *hwmon_dev;\n\tstruct hwm_drvdata *ddat;\n\tstruct hwm_drvdata *ddat_gt;\n\tstruct intel_gt *gt;\n\tint i;\n\n\t \n\tif (!IS_DGFX(i915))\n\t\treturn;\n\n\thwmon = devm_kzalloc(dev, sizeof(*hwmon), GFP_KERNEL);\n\tif (!hwmon)\n\t\treturn;\n\n\ti915->hwmon = hwmon;\n\tmutex_init(&hwmon->hwmon_lock);\n\tddat = &hwmon->ddat;\n\n\tddat->hwmon = hwmon;\n\tddat->uncore = &i915->uncore;\n\tsnprintf(ddat->name, sizeof(ddat->name), \"i915\");\n\tddat->gt_n = -1;\n\tinit_waitqueue_head(&ddat->waitq);\n\n\tfor_each_gt(gt, i915, i) {\n\t\tddat_gt = hwmon->ddat_gt + i;\n\n\t\tddat_gt->hwmon = hwmon;\n\t\tddat_gt->uncore = gt->uncore;\n\t\tsnprintf(ddat_gt->name, sizeof(ddat_gt->name), \"i915_gt%u\", i);\n\t\tddat_gt->gt_n = i;\n\t}\n\n\thwm_get_preregistration_info(i915);\n\n\t \n\thwmon_dev = devm_hwmon_device_register_with_info(dev, ddat->name,\n\t\t\t\t\t\t\t ddat,\n\t\t\t\t\t\t\t &hwm_chip_info,\n\t\t\t\t\t\t\t hwm_groups);\n\tif (IS_ERR(hwmon_dev)) {\n\t\ti915->hwmon = NULL;\n\t\treturn;\n\t}\n\n\tddat->hwmon_dev = hwmon_dev;\n\n\tfor_each_gt(gt, i915, i) {\n\t\tddat_gt = hwmon->ddat_gt + i;\n\t\t \n\t\tif (!hwm_gt_is_visible(ddat_gt, hwmon_energy, hwmon_energy_input, 0))\n\t\t\tcontinue;\n\n\t\thwmon_dev = devm_hwmon_device_register_with_info(dev, ddat_gt->name,\n\t\t\t\t\t\t\t\t ddat_gt,\n\t\t\t\t\t\t\t\t &hwm_gt_chip_info,\n\t\t\t\t\t\t\t\t NULL);\n\t\tif (!IS_ERR(hwmon_dev))\n\t\t\tddat_gt->hwmon_dev = hwmon_dev;\n\t}\n}\n\nvoid i915_hwmon_unregister(struct drm_i915_private *i915)\n{\n\tfetch_and_zero(&i915->hwmon);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}