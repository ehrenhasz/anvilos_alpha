{
  "module_name": "intel_pxp_tee.c",
  "hash_id": "6e56245cb230176ccb3e1a9d2cf3df7b25a77cc163235bf6942f59884a404667",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/i915/pxp/intel_pxp_tee.c",
  "human_readable_source": "\n \n\n#include <linux/component.h>\n\n#include <drm/i915_pxp_tee_interface.h>\n#include <drm/i915_component.h>\n\n#include \"gem/i915_gem_lmem.h\"\n\n#include \"i915_drv.h\"\n#include \"gt/intel_gt.h\"\n\n#include \"intel_pxp.h\"\n#include \"intel_pxp_cmd_interface_42.h\"\n#include \"intel_pxp_huc.h\"\n#include \"intel_pxp_session.h\"\n#include \"intel_pxp_tee.h\"\n#include \"intel_pxp_types.h\"\n\nstatic bool\nis_fw_err_platform_config(u32 type)\n{\n\tswitch (type) {\n\tcase PXP_STATUS_ERROR_API_VERSION:\n\tcase PXP_STATUS_PLATFCONFIG_KF1_NOVERIF:\n\tcase PXP_STATUS_PLATFCONFIG_KF1_BAD:\n\t\treturn true;\n\tdefault:\n\t\tbreak;\n\t}\n\treturn false;\n}\n\nstatic const char *\nfw_err_to_string(u32 type)\n{\n\tswitch (type) {\n\tcase PXP_STATUS_ERROR_API_VERSION:\n\t\treturn \"ERR_API_VERSION\";\n\tcase PXP_STATUS_NOT_READY:\n\t\treturn \"ERR_NOT_READY\";\n\tcase PXP_STATUS_PLATFCONFIG_KF1_NOVERIF:\n\tcase PXP_STATUS_PLATFCONFIG_KF1_BAD:\n\t\treturn \"ERR_PLATFORM_CONFIG\";\n\tdefault:\n\t\tbreak;\n\t}\n\treturn NULL;\n}\n\nstatic int intel_pxp_tee_io_message(struct intel_pxp *pxp,\n\t\t\t\t    void *msg_in, u32 msg_in_size,\n\t\t\t\t    void *msg_out, u32 msg_out_max_size,\n\t\t\t\t    u32 *msg_out_rcv_size)\n{\n\tstruct drm_i915_private *i915 = pxp->ctrl_gt->i915;\n\tstruct i915_pxp_component *pxp_component = pxp->pxp_component;\n\tint ret = 0;\n\n\tmutex_lock(&pxp->tee_mutex);\n\n\t \n\tif (!pxp_component) {\n\t\tret = -ENODEV;\n\t\tgoto unlock;\n\t}\n\n\tret = pxp_component->ops->send(pxp_component->tee_dev, msg_in, msg_in_size);\n\tif (ret) {\n\t\tdrm_err(&i915->drm, \"Failed to send PXP TEE message\\n\");\n\t\tgoto unlock;\n\t}\n\n\tret = pxp_component->ops->recv(pxp_component->tee_dev, msg_out, msg_out_max_size);\n\tif (ret < 0) {\n\t\tdrm_err(&i915->drm, \"Failed to receive PXP TEE message\\n\");\n\t\tgoto unlock;\n\t}\n\n\tif (ret > msg_out_max_size) {\n\t\tdrm_err(&i915->drm,\n\t\t\t\"Failed to receive PXP TEE message due to unexpected output size\\n\");\n\t\tret = -ENOSPC;\n\t\tgoto unlock;\n\t}\n\n\tif (msg_out_rcv_size)\n\t\t*msg_out_rcv_size = ret;\n\n\tret = 0;\nunlock:\n\tmutex_unlock(&pxp->tee_mutex);\n\treturn ret;\n}\n\nint intel_pxp_tee_stream_message(struct intel_pxp *pxp,\n\t\t\t\t u8 client_id, u32 fence_id,\n\t\t\t\t void *msg_in, size_t msg_in_len,\n\t\t\t\t void *msg_out, size_t msg_out_len)\n{\n\t \n\tconst size_t max_msg_size = PAGE_SIZE;\n\tstruct drm_i915_private *i915 = pxp->ctrl_gt->i915;\n\tstruct i915_pxp_component *pxp_component = pxp->pxp_component;\n\tunsigned int offset = 0;\n\tstruct scatterlist *sg;\n\tint ret;\n\n\tif (msg_in_len > max_msg_size || msg_out_len > max_msg_size)\n\t\treturn -ENOSPC;\n\n\tmutex_lock(&pxp->tee_mutex);\n\n\tif (unlikely(!pxp_component || !pxp_component->ops->gsc_command)) {\n\t\tret = -ENODEV;\n\t\tgoto unlock;\n\t}\n\n\tGEM_BUG_ON(!pxp->stream_cmd.obj);\n\n\tsg = i915_gem_object_get_sg_dma(pxp->stream_cmd.obj, 0, &offset);\n\n\tmemcpy(pxp->stream_cmd.vaddr, msg_in, msg_in_len);\n\n\tret = pxp_component->ops->gsc_command(pxp_component->tee_dev, client_id,\n\t\t\t\t\t      fence_id, sg, msg_in_len, sg);\n\tif (ret < 0)\n\t\tdrm_err(&i915->drm, \"Failed to send PXP TEE gsc command\\n\");\n\telse\n\t\tmemcpy(msg_out, pxp->stream_cmd.vaddr, msg_out_len);\n\nunlock:\n\tmutex_unlock(&pxp->tee_mutex);\n\treturn ret;\n}\n\n \nstatic int i915_pxp_tee_component_bind(struct device *i915_kdev,\n\t\t\t\t       struct device *tee_kdev, void *data)\n{\n\tstruct drm_i915_private *i915 = kdev_to_i915(i915_kdev);\n\tstruct intel_pxp *pxp = i915->pxp;\n\tstruct intel_uc *uc = &pxp->ctrl_gt->uc;\n\tintel_wakeref_t wakeref;\n\tint ret = 0;\n\n\tif (!HAS_HECI_PXP(i915)) {\n\t\tpxp->dev_link = device_link_add(i915_kdev, tee_kdev, DL_FLAG_STATELESS);\n\t\tif (drm_WARN_ON(&i915->drm, !pxp->dev_link))\n\t\t\treturn -ENODEV;\n\t}\n\n\tmutex_lock(&pxp->tee_mutex);\n\tpxp->pxp_component = data;\n\tpxp->pxp_component->tee_dev = tee_kdev;\n\tmutex_unlock(&pxp->tee_mutex);\n\n\tif (intel_uc_uses_huc(uc) && intel_huc_is_loaded_by_gsc(&uc->huc)) {\n\t\twith_intel_runtime_pm(&i915->runtime_pm, wakeref) {\n\t\t\t \n\t\t\tret = intel_huc_fw_load_and_auth_via_gsc(&uc->huc);\n\t\t\tif (ret < 0)\n\t\t\t\tdrm_err(&i915->drm, \"failed to load huc via gsc %d\\n\", ret);\n\t\t}\n\t}\n\n\t \n\twakeref = intel_runtime_pm_get_if_in_use(&i915->runtime_pm);\n\tif (!wakeref)\n\t\treturn 0;\n\n\t \n\tif (intel_pxp_is_enabled(pxp))\n\t\tintel_pxp_init_hw(pxp);\n\n\tintel_runtime_pm_put(&i915->runtime_pm, wakeref);\n\n\treturn ret;\n}\n\nstatic void i915_pxp_tee_component_unbind(struct device *i915_kdev,\n\t\t\t\t\t  struct device *tee_kdev, void *data)\n{\n\tstruct drm_i915_private *i915 = kdev_to_i915(i915_kdev);\n\tstruct intel_pxp *pxp = i915->pxp;\n\tintel_wakeref_t wakeref;\n\n\tif (intel_pxp_is_enabled(pxp))\n\t\twith_intel_runtime_pm_if_in_use(&i915->runtime_pm, wakeref)\n\t\t\tintel_pxp_fini_hw(pxp);\n\n\tmutex_lock(&pxp->tee_mutex);\n\tpxp->pxp_component = NULL;\n\tmutex_unlock(&pxp->tee_mutex);\n\n\tif (pxp->dev_link) {\n\t\tdevice_link_del(pxp->dev_link);\n\t\tpxp->dev_link = NULL;\n\t}\n}\n\nstatic const struct component_ops i915_pxp_tee_component_ops = {\n\t.bind   = i915_pxp_tee_component_bind,\n\t.unbind = i915_pxp_tee_component_unbind,\n};\n\nstatic int alloc_streaming_command(struct intel_pxp *pxp)\n{\n\tstruct drm_i915_private *i915 = pxp->ctrl_gt->i915;\n\tstruct drm_i915_gem_object *obj = NULL;\n\tvoid *cmd;\n\tint err;\n\n\tpxp->stream_cmd.obj = NULL;\n\tpxp->stream_cmd.vaddr = NULL;\n\n\tif (!IS_DGFX(i915))\n\t\treturn 0;\n\n\t \n\tobj = i915_gem_object_create_lmem(i915, PAGE_SIZE, I915_BO_ALLOC_CONTIGUOUS);\n\tif (IS_ERR(obj)) {\n\t\tdrm_err(&i915->drm, \"Failed to allocate pxp streaming command!\\n\");\n\t\treturn PTR_ERR(obj);\n\t}\n\n\terr = i915_gem_object_pin_pages_unlocked(obj);\n\tif (err) {\n\t\tdrm_err(&i915->drm, \"Failed to pin gsc message page!\\n\");\n\t\tgoto out_put;\n\t}\n\n\t \n\tcmd = i915_gem_object_pin_map_unlocked(obj,\n\t\t\t\t\t       intel_gt_coherent_map_type(pxp->ctrl_gt,\n\t\t\t\t\t\t\t\t\t  obj, true));\n\tif (IS_ERR(cmd)) {\n\t\tdrm_err(&i915->drm, \"Failed to map gsc message page!\\n\");\n\t\terr = PTR_ERR(cmd);\n\t\tgoto out_unpin;\n\t}\n\n\tmemset(cmd, 0, obj->base.size);\n\n\tpxp->stream_cmd.obj = obj;\n\tpxp->stream_cmd.vaddr = cmd;\n\n\treturn 0;\n\nout_unpin:\n\ti915_gem_object_unpin_pages(obj);\nout_put:\n\ti915_gem_object_put(obj);\n\treturn err;\n}\n\nstatic void free_streaming_command(struct intel_pxp *pxp)\n{\n\tstruct drm_i915_gem_object *obj = fetch_and_zero(&pxp->stream_cmd.obj);\n\n\tif (!obj)\n\t\treturn;\n\n\ti915_gem_object_unpin_map(obj);\n\ti915_gem_object_unpin_pages(obj);\n\ti915_gem_object_put(obj);\n}\n\nint intel_pxp_tee_component_init(struct intel_pxp *pxp)\n{\n\tint ret;\n\tstruct intel_gt *gt = pxp->ctrl_gt;\n\tstruct drm_i915_private *i915 = gt->i915;\n\n\tret = alloc_streaming_command(pxp);\n\tif (ret)\n\t\treturn ret;\n\n\tret = component_add_typed(i915->drm.dev, &i915_pxp_tee_component_ops,\n\t\t\t\t  I915_COMPONENT_PXP);\n\tif (ret < 0) {\n\t\tdrm_err(&i915->drm, \"Failed to add PXP component (%d)\\n\", ret);\n\t\tgoto out_free;\n\t}\n\n\tpxp->pxp_component_added = true;\n\n\treturn 0;\n\nout_free:\n\tfree_streaming_command(pxp);\n\treturn ret;\n}\n\nvoid intel_pxp_tee_component_fini(struct intel_pxp *pxp)\n{\n\tstruct drm_i915_private *i915 = pxp->ctrl_gt->i915;\n\n\tif (!pxp->pxp_component_added)\n\t\treturn;\n\n\tcomponent_del(i915->drm.dev, &i915_pxp_tee_component_ops);\n\tpxp->pxp_component_added = false;\n\n\tfree_streaming_command(pxp);\n}\n\nint intel_pxp_tee_cmd_create_arb_session(struct intel_pxp *pxp,\n\t\t\t\t\t int arb_session_id)\n{\n\tstruct drm_i915_private *i915 = pxp->ctrl_gt->i915;\n\tstruct pxp42_create_arb_in msg_in = {0};\n\tstruct pxp42_create_arb_out msg_out = {0};\n\tint ret;\n\n\tmsg_in.header.api_version = PXP_APIVER(4, 2);\n\tmsg_in.header.command_id = PXP42_CMDID_INIT_SESSION;\n\tmsg_in.header.buffer_len = sizeof(msg_in) - sizeof(msg_in.header);\n\tmsg_in.protection_mode = PXP42_ARB_SESSION_MODE_HEAVY;\n\tmsg_in.session_id = arb_session_id;\n\n\tret = intel_pxp_tee_io_message(pxp,\n\t\t\t\t       &msg_in, sizeof(msg_in),\n\t\t\t\t       &msg_out, sizeof(msg_out),\n\t\t\t\t       NULL);\n\n\tif (ret) {\n\t\tdrm_err(&i915->drm, \"Failed to send tee msg init arb session, ret=[%d]\\n\", ret);\n\t} else if (msg_out.header.status != 0) {\n\t\tif (is_fw_err_platform_config(msg_out.header.status)) {\n\t\t\tdrm_info_once(&i915->drm,\n\t\t\t\t      \"PXP init-arb-session-%d failed due to BIOS/SOC:0x%08x:%s\\n\",\n\t\t\t\t      arb_session_id, msg_out.header.status,\n\t\t\t\t      fw_err_to_string(msg_out.header.status));\n\t\t} else {\n\t\t\tdrm_dbg(&i915->drm, \"PXP init-arb-session--%d failed 0x%08x:%st:\\n\",\n\t\t\t\tarb_session_id, msg_out.header.status,\n\t\t\t\tfw_err_to_string(msg_out.header.status));\n\t\t\tdrm_dbg(&i915->drm, \"     cmd-detail: ID=[0x%08x],API-Ver-[0x%08x]\\n\",\n\t\t\t\tmsg_in.header.command_id, msg_in.header.api_version);\n\t\t}\n\t}\n\n\treturn ret;\n}\n\nvoid intel_pxp_tee_end_arb_fw_session(struct intel_pxp *pxp, u32 session_id)\n{\n\tstruct drm_i915_private *i915 = pxp->ctrl_gt->i915;\n\tstruct pxp42_inv_stream_key_in msg_in = {0};\n\tstruct pxp42_inv_stream_key_out msg_out = {0};\n\tint ret, trials = 0;\n\ntry_again:\n\tmemset(&msg_in, 0, sizeof(msg_in));\n\tmemset(&msg_out, 0, sizeof(msg_out));\n\tmsg_in.header.api_version = PXP_APIVER(4, 2);\n\tmsg_in.header.command_id = PXP42_CMDID_INVALIDATE_STREAM_KEY;\n\tmsg_in.header.buffer_len = sizeof(msg_in) - sizeof(msg_in.header);\n\n\tmsg_in.header.stream_id = FIELD_PREP(PXP_CMDHDR_EXTDATA_SESSION_VALID, 1);\n\tmsg_in.header.stream_id |= FIELD_PREP(PXP_CMDHDR_EXTDATA_APP_TYPE, 0);\n\tmsg_in.header.stream_id |= FIELD_PREP(PXP_CMDHDR_EXTDATA_SESSION_ID, session_id);\n\n\tret = intel_pxp_tee_io_message(pxp,\n\t\t\t\t       &msg_in, sizeof(msg_in),\n\t\t\t\t       &msg_out, sizeof(msg_out),\n\t\t\t\t       NULL);\n\n\t \n\tif ((ret || msg_out.header.status != 0x0) && ++trials < 3)\n\t\tgoto try_again;\n\n\tif (ret) {\n\t\tdrm_err(&i915->drm, \"Failed to send tee msg for inv-stream-key-%u, ret=[%d]\\n\",\n\t\t\tsession_id, ret);\n\t} else if (msg_out.header.status != 0) {\n\t\tif (is_fw_err_platform_config(msg_out.header.status)) {\n\t\t\tdrm_info_once(&i915->drm,\n\t\t\t\t      \"PXP inv-stream-key-%u failed due to BIOS/SOC :0x%08x:%s\\n\",\n\t\t\t\t      session_id, msg_out.header.status,\n\t\t\t\t      fw_err_to_string(msg_out.header.status));\n\t\t} else {\n\t\t\tdrm_dbg(&i915->drm, \"PXP inv-stream-key-%u failed 0x%08x:%s:\\n\",\n\t\t\t\tsession_id, msg_out.header.status,\n\t\t\t\tfw_err_to_string(msg_out.header.status));\n\t\t\tdrm_dbg(&i915->drm, \"     cmd-detail: ID=[0x%08x],API-Ver-[0x%08x]\\n\",\n\t\t\t\tmsg_in.header.command_id, msg_in.header.api_version);\n\t\t}\n\t}\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}