{
  "module_name": "intel_pxp_session.c",
  "hash_id": "9f086a901ca3d16c4e0f14f6d718723a420fabe6fd0e6682cd1bbacd4dd48529",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/i915/pxp/intel_pxp_session.c",
  "human_readable_source": "\n \n\n#include \"i915_drv.h\"\n\n#include \"intel_pxp.h\"\n#include \"intel_pxp_cmd.h\"\n#include \"intel_pxp_gsccs.h\"\n#include \"intel_pxp_session.h\"\n#include \"intel_pxp_tee.h\"\n#include \"intel_pxp_types.h\"\n#include \"intel_pxp_regs.h\"\n\n#define ARB_SESSION I915_PROTECTED_CONTENT_DEFAULT_SESSION  \n\nstatic bool intel_pxp_session_is_in_play(struct intel_pxp *pxp, u32 id)\n{\n\tstruct intel_uncore *uncore = pxp->ctrl_gt->uncore;\n\tintel_wakeref_t wakeref;\n\tu32 sip = 0;\n\n\t \n\twith_intel_runtime_pm_if_in_use(uncore->rpm, wakeref)\n\t\tsip = intel_uncore_read(uncore, KCR_SIP(pxp->kcr_base));\n\n\treturn sip & BIT(id);\n}\n\nstatic int pxp_wait_for_session_state(struct intel_pxp *pxp, u32 id, bool in_play)\n{\n\tstruct intel_uncore *uncore = pxp->ctrl_gt->uncore;\n\tintel_wakeref_t wakeref;\n\tu32 mask = BIT(id);\n\tint ret;\n\n\t \n\twakeref = intel_runtime_pm_get_if_in_use(uncore->rpm);\n\tif (!wakeref)\n\t\treturn in_play ? -ENODEV : 0;\n\n\tret = intel_wait_for_register(uncore,\n\t\t\t\t      KCR_SIP(pxp->kcr_base),\n\t\t\t\t      mask,\n\t\t\t\t      in_play ? mask : 0,\n\t\t\t\t      250);\n\n\tintel_runtime_pm_put(uncore->rpm, wakeref);\n\n\treturn ret;\n}\n\nstatic int pxp_create_arb_session(struct intel_pxp *pxp)\n{\n\tstruct intel_gt *gt = pxp->ctrl_gt;\n\tint ret;\n\n\tpxp->arb_is_valid = false;\n\n\tif (intel_pxp_session_is_in_play(pxp, ARB_SESSION)) {\n\t\tdrm_err(&gt->i915->drm, \"arb session already in play at creation time\\n\");\n\t\treturn -EEXIST;\n\t}\n\n\tif (HAS_ENGINE(pxp->ctrl_gt, GSC0))\n\t\tret = intel_pxp_gsccs_create_session(pxp, ARB_SESSION);\n\telse\n\t\tret = intel_pxp_tee_cmd_create_arb_session(pxp, ARB_SESSION);\n\tif (ret) {\n\t\tdrm_err(&gt->i915->drm, \"tee cmd for arb session creation failed\\n\");\n\t\treturn ret;\n\t}\n\n\tret = pxp_wait_for_session_state(pxp, ARB_SESSION, true);\n\tif (ret) {\n\t\tdrm_dbg(&gt->i915->drm, \"arb session failed to go in play\\n\");\n\t\treturn ret;\n\t}\n\tdrm_dbg(&gt->i915->drm, \"PXP ARB session is alive\\n\");\n\n\tif (!++pxp->key_instance)\n\t\t++pxp->key_instance;\n\n\tpxp->arb_is_valid = true;\n\n\treturn 0;\n}\n\nstatic int pxp_terminate_arb_session_and_global(struct intel_pxp *pxp)\n{\n\tint ret;\n\tstruct intel_gt *gt = pxp->ctrl_gt;\n\n\t \n\tGEM_WARN_ON(pxp->arb_is_valid);\n\n\t \n\tret = intel_pxp_terminate_session(pxp, ARB_SESSION);\n\tif (ret) {\n\t\tdrm_err(&gt->i915->drm, \"Failed to submit session termination\\n\");\n\t\treturn ret;\n\t}\n\n\tret = pxp_wait_for_session_state(pxp, ARB_SESSION, false);\n\tif (ret) {\n\t\tdrm_err(&gt->i915->drm, \"Session state did not clear\\n\");\n\t\treturn ret;\n\t}\n\n\tintel_uncore_write(gt->uncore, KCR_GLOBAL_TERMINATE(pxp->kcr_base), 1);\n\n\tif (HAS_ENGINE(gt, GSC0))\n\t\tintel_pxp_gsccs_end_arb_fw_session(pxp, ARB_SESSION);\n\telse\n\t\tintel_pxp_tee_end_arb_fw_session(pxp, ARB_SESSION);\n\n\treturn ret;\n}\n\nvoid intel_pxp_terminate(struct intel_pxp *pxp, bool post_invalidation_needs_restart)\n{\n\tint ret;\n\n\tpxp->hw_state_invalidated = post_invalidation_needs_restart;\n\n\t \n\tret = pxp_terminate_arb_session_and_global(pxp);\n\tif (ret)\n\t\tcomplete_all(&pxp->termination);\n}\n\nstatic void pxp_terminate_complete(struct intel_pxp *pxp)\n{\n\t \n\tif (fetch_and_zero(&pxp->hw_state_invalidated))\n\t\tpxp_create_arb_session(pxp);\n\n\tcomplete_all(&pxp->termination);\n}\n\nstatic void pxp_session_work(struct work_struct *work)\n{\n\tstruct intel_pxp *pxp = container_of(work, typeof(*pxp), session_work);\n\tstruct intel_gt *gt = pxp->ctrl_gt;\n\tintel_wakeref_t wakeref;\n\tu32 events = 0;\n\n\tspin_lock_irq(gt->irq_lock);\n\tevents = fetch_and_zero(&pxp->session_events);\n\tspin_unlock_irq(gt->irq_lock);\n\n\tif (!events)\n\t\treturn;\n\n\tif (events & PXP_INVAL_REQUIRED)\n\t\tintel_pxp_invalidate(pxp);\n\n\t \n\twakeref = intel_runtime_pm_get_if_in_use(gt->uncore->rpm);\n\tif (!wakeref)\n\t\treturn;\n\n\tif (events & PXP_TERMINATION_REQUEST) {\n\t\tevents &= ~PXP_TERMINATION_COMPLETE;\n\t\tintel_pxp_terminate(pxp, true);\n\t}\n\n\tif (events & PXP_TERMINATION_COMPLETE)\n\t\tpxp_terminate_complete(pxp);\n\n\tintel_runtime_pm_put(gt->uncore->rpm, wakeref);\n}\n\nvoid intel_pxp_session_management_init(struct intel_pxp *pxp)\n{\n\tmutex_init(&pxp->arb_mutex);\n\tINIT_WORK(&pxp->session_work, pxp_session_work);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}