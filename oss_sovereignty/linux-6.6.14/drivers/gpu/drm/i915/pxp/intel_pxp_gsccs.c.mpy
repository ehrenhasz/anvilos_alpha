{
  "module_name": "intel_pxp_gsccs.c",
  "hash_id": "d5341685295c0216371958c68b96a1f0df34de59660ddbb1d66b1d11d39b76f4",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/i915/pxp/intel_pxp_gsccs.c",
  "human_readable_source": "\n \n\n#include \"gem/i915_gem_internal.h\"\n\n#include \"gt/intel_context.h\"\n#include \"gt/intel_gt.h\"\n#include \"gt/uc/intel_gsc_fw.h\"\n#include \"gt/uc/intel_gsc_uc_heci_cmd_submit.h\"\n\n#include \"i915_drv.h\"\n#include \"intel_pxp.h\"\n#include \"intel_pxp_cmd_interface_42.h\"\n#include \"intel_pxp_cmd_interface_43.h\"\n#include \"intel_pxp_gsccs.h\"\n#include \"intel_pxp_types.h\"\n\nstatic bool\nis_fw_err_platform_config(u32 type)\n{\n\tswitch (type) {\n\tcase PXP_STATUS_ERROR_API_VERSION:\n\tcase PXP_STATUS_PLATFCONFIG_KF1_NOVERIF:\n\tcase PXP_STATUS_PLATFCONFIG_KF1_BAD:\n\t\treturn true;\n\tdefault:\n\t\tbreak;\n\t}\n\treturn false;\n}\n\nstatic const char *\nfw_err_to_string(u32 type)\n{\n\tswitch (type) {\n\tcase PXP_STATUS_ERROR_API_VERSION:\n\t\treturn \"ERR_API_VERSION\";\n\tcase PXP_STATUS_NOT_READY:\n\t\treturn \"ERR_NOT_READY\";\n\tcase PXP_STATUS_PLATFCONFIG_KF1_NOVERIF:\n\tcase PXP_STATUS_PLATFCONFIG_KF1_BAD:\n\t\treturn \"ERR_PLATFORM_CONFIG\";\n\tdefault:\n\t\tbreak;\n\t}\n\treturn NULL;\n}\n\nstatic int\ngsccs_send_message(struct intel_pxp *pxp,\n\t\t   void *msg_in, size_t msg_in_size,\n\t\t   void *msg_out, size_t msg_out_size_max,\n\t\t   size_t *msg_out_len,\n\t\t   u64 *gsc_msg_handle_retry)\n{\n\tstruct intel_gt *gt = pxp->ctrl_gt;\n\tstruct drm_i915_private *i915 = gt->i915;\n\tstruct gsccs_session_resources *exec_res =  &pxp->gsccs_res;\n\tstruct intel_gsc_mtl_header *header = exec_res->pkt_vaddr;\n\tstruct intel_gsc_heci_non_priv_pkt pkt;\n\tsize_t max_msg_size;\n\tu32 reply_size;\n\tint ret;\n\n\tif (!exec_res->ce)\n\t\treturn -ENODEV;\n\n\tmax_msg_size = PXP43_MAX_HECI_INOUT_SIZE - sizeof(*header);\n\n\tif (msg_in_size > max_msg_size || msg_out_size_max > max_msg_size)\n\t\treturn -ENOSPC;\n\n\tif (!exec_res->pkt_vma || !exec_res->bb_vma)\n\t\treturn -ENOENT;\n\n\tGEM_BUG_ON(exec_res->pkt_vma->size < (2 * PXP43_MAX_HECI_INOUT_SIZE));\n\n\tmutex_lock(&pxp->tee_mutex);\n\n\tmemset(header, 0, sizeof(*header));\n\tintel_gsc_uc_heci_cmd_emit_mtl_header(header, HECI_MEADDRESS_PXP,\n\t\t\t\t\t      msg_in_size + sizeof(*header),\n\t\t\t\t\t      exec_res->host_session_handle);\n\n\t \n\tif (!msg_in && !msg_out)\n\t\theader->flags |= GSC_INFLAG_MSG_CLEANUP;\n\n\t \n\theader->gsc_message_handle = *gsc_msg_handle_retry;\n\n\t \n\tif (msg_in && msg_in_size)\n\t\tmemcpy(exec_res->pkt_vaddr + sizeof(*header), msg_in, msg_in_size);\n\n\tpkt.addr_in = i915_vma_offset(exec_res->pkt_vma);\n\tpkt.size_in = header->message_size;\n\tpkt.addr_out = pkt.addr_in + PXP43_MAX_HECI_INOUT_SIZE;\n\tpkt.size_out = msg_out_size_max + sizeof(*header);\n\tpkt.heci_pkt_vma = exec_res->pkt_vma;\n\tpkt.bb_vma = exec_res->bb_vma;\n\n\t \n\theader = exec_res->pkt_vaddr + PXP43_MAX_HECI_INOUT_SIZE;\n\theader->validity_marker = 0;\n\n\tret = intel_gsc_uc_heci_cmd_submit_nonpriv(&gt->uc.gsc,\n\t\t\t\t\t\t   exec_res->ce, &pkt, exec_res->bb_vaddr,\n\t\t\t\t\t\t   GSC_REPLY_LATENCY_MS);\n\tif (ret) {\n\t\tdrm_err(&i915->drm, \"failed to send gsc PXP msg (%d)\\n\", ret);\n\t\tgoto unlock;\n\t}\n\n\t \n\tif (header->validity_marker != GSC_HECI_VALIDITY_MARKER) {\n\t\tdrm_err(&i915->drm, \"gsc PXP reply with invalid validity marker\\n\");\n\t\tret = -EINVAL;\n\t\tgoto unlock;\n\t}\n\tif (header->status != 0) {\n\t\tdrm_dbg(&i915->drm, \"gsc PXP reply status has error = 0x%08x\\n\",\n\t\t\theader->status);\n\t\tret = -EINVAL;\n\t\tgoto unlock;\n\t}\n\tif (header->flags & GSC_OUTFLAG_MSG_PENDING) {\n\t\tdrm_dbg(&i915->drm, \"gsc PXP reply is busy\\n\");\n\t\t \n\t\t*gsc_msg_handle_retry = header->gsc_message_handle;\n\t\tret = -EAGAIN;\n\t\tgoto unlock;\n\t}\n\n\treply_size = header->message_size - sizeof(*header);\n\tif (reply_size > msg_out_size_max) {\n\t\tdrm_warn(&i915->drm, \"caller with insufficient PXP reply size %u (%zu)\\n\",\n\t\t\t reply_size, msg_out_size_max);\n\t\treply_size = msg_out_size_max;\n\t}\n\n\tif (msg_out)\n\t\tmemcpy(msg_out, exec_res->pkt_vaddr + PXP43_MAX_HECI_INOUT_SIZE + sizeof(*header),\n\t\t       reply_size);\n\tif (msg_out_len)\n\t\t*msg_out_len = reply_size;\n\nunlock:\n\tmutex_unlock(&pxp->tee_mutex);\n\treturn ret;\n}\n\nstatic int\ngsccs_send_message_retry_complete(struct intel_pxp *pxp,\n\t\t\t\t  void *msg_in, size_t msg_in_size,\n\t\t\t\t  void *msg_out, size_t msg_out_size_max,\n\t\t\t\t  size_t *msg_out_len)\n{\n\tu64 gsc_session_retry = 0;\n\tint ret, tries = 0;\n\n\t \n\tdo {\n\t\tret = gsccs_send_message(pxp, msg_in, msg_in_size, msg_out, msg_out_size_max,\n\t\t\t\t\t msg_out_len, &gsc_session_retry);\n\t\t \n\t\tif (ret != -EAGAIN)\n\t\t\tbreak;\n\n\t\tmsleep(GSC_PENDING_RETRY_PAUSE_MS);\n\t} while (++tries < GSC_PENDING_RETRY_MAXCOUNT);\n\n\treturn ret;\n}\n\nbool intel_pxp_gsccs_is_ready_for_sessions(struct intel_pxp *pxp)\n{\n\t \n\tif (intel_huc_is_authenticated(&pxp->ctrl_gt->uc.huc, INTEL_HUC_AUTH_BY_GSC) &&\n\t    intel_gsc_uc_fw_proxy_init_done(&pxp->ctrl_gt->uc.gsc, true))\n\t\treturn true;\n\n\treturn false;\n}\n\nint intel_pxp_gsccs_create_session(struct intel_pxp *pxp,\n\t\t\t\t   int arb_session_id)\n{\n\tstruct drm_i915_private *i915 = pxp->ctrl_gt->i915;\n\tstruct pxp43_create_arb_in msg_in = {0};\n\tstruct pxp43_create_arb_out msg_out = {0};\n\tint ret;\n\n\tmsg_in.header.api_version = PXP_APIVER(4, 3);\n\tmsg_in.header.command_id = PXP43_CMDID_INIT_SESSION;\n\tmsg_in.header.stream_id = (FIELD_PREP(PXP43_INIT_SESSION_APPID, arb_session_id) |\n\t\t\t\t   FIELD_PREP(PXP43_INIT_SESSION_VALID, 1) |\n\t\t\t\t   FIELD_PREP(PXP43_INIT_SESSION_APPTYPE, 0));\n\tmsg_in.header.buffer_len = sizeof(msg_in) - sizeof(msg_in.header);\n\tmsg_in.protection_mode = PXP43_INIT_SESSION_PROTECTION_ARB;\n\n\tret = gsccs_send_message_retry_complete(pxp,\n\t\t\t\t\t\t&msg_in, sizeof(msg_in),\n\t\t\t\t\t\t&msg_out, sizeof(msg_out), NULL);\n\tif (ret) {\n\t\tdrm_err(&i915->drm, \"Failed to init session %d, ret=[%d]\\n\", arb_session_id, ret);\n\t} else if (msg_out.header.status != 0) {\n\t\tif (is_fw_err_platform_config(msg_out.header.status)) {\n\t\t\tdrm_info_once(&i915->drm,\n\t\t\t\t      \"PXP init-session-%d failed due to BIOS/SOC:0x%08x:%s\\n\",\n\t\t\t\t      arb_session_id, msg_out.header.status,\n\t\t\t\t      fw_err_to_string(msg_out.header.status));\n\t\t} else {\n\t\t\tdrm_dbg(&i915->drm, \"PXP init-session-%d failed 0x%08x:%st:\\n\",\n\t\t\t\tarb_session_id, msg_out.header.status,\n\t\t\t\tfw_err_to_string(msg_out.header.status));\n\t\t\tdrm_dbg(&i915->drm, \"     cmd-detail: ID=[0x%08x],API-Ver-[0x%08x]\\n\",\n\t\t\t\tmsg_in.header.command_id, msg_in.header.api_version);\n\t\t}\n\t}\n\n\treturn ret;\n}\n\nvoid intel_pxp_gsccs_end_arb_fw_session(struct intel_pxp *pxp, u32 session_id)\n{\n\tstruct drm_i915_private *i915 = pxp->ctrl_gt->i915;\n\tstruct pxp42_inv_stream_key_in msg_in = {0};\n\tstruct pxp42_inv_stream_key_out msg_out = {0};\n\tint ret = 0;\n\n\t \n\tmsg_in.header.api_version = PXP_APIVER(4, 3);\n\tmsg_in.header.command_id = PXP42_CMDID_INVALIDATE_STREAM_KEY;\n\tmsg_in.header.buffer_len = sizeof(msg_in) - sizeof(msg_in.header);\n\n\tmsg_in.header.stream_id = FIELD_PREP(PXP_CMDHDR_EXTDATA_SESSION_VALID, 1);\n\tmsg_in.header.stream_id |= FIELD_PREP(PXP_CMDHDR_EXTDATA_APP_TYPE, 0);\n\tmsg_in.header.stream_id |= FIELD_PREP(PXP_CMDHDR_EXTDATA_SESSION_ID, session_id);\n\n\tret = gsccs_send_message_retry_complete(pxp,\n\t\t\t\t\t\t&msg_in, sizeof(msg_in),\n\t\t\t\t\t\t&msg_out, sizeof(msg_out), NULL);\n\tif (ret) {\n\t\tdrm_err(&i915->drm, \"Failed to inv-stream-key-%u, ret=[%d]\\n\",\n\t\t\tsession_id, ret);\n\t} else if (msg_out.header.status != 0) {\n\t\tif (is_fw_err_platform_config(msg_out.header.status)) {\n\t\t\tdrm_info_once(&i915->drm,\n\t\t\t\t      \"PXP inv-stream-key-%u failed due to BIOS/SOC :0x%08x:%s\\n\",\n\t\t\t\t      session_id, msg_out.header.status,\n\t\t\t\t      fw_err_to_string(msg_out.header.status));\n\t\t} else {\n\t\t\tdrm_dbg(&i915->drm, \"PXP inv-stream-key-%u failed 0x%08x:%s:\\n\",\n\t\t\t\tsession_id, msg_out.header.status,\n\t\t\t\tfw_err_to_string(msg_out.header.status));\n\t\t\tdrm_dbg(&i915->drm, \"     cmd-detail: ID=[0x%08x],API-Ver-[0x%08x]\\n\",\n\t\t\t\tmsg_in.header.command_id, msg_in.header.api_version);\n\t\t}\n\t}\n}\n\nstatic void\ngsccs_cleanup_fw_host_session_handle(struct intel_pxp *pxp)\n{\n\tstruct drm_i915_private *i915 = pxp->ctrl_gt->i915;\n\tint ret;\n\n\tret = gsccs_send_message_retry_complete(pxp, NULL, 0, NULL, 0, NULL);\n\tif (ret)\n\t\tdrm_dbg(&i915->drm, \"Failed to send gsccs msg host-session-cleanup: ret=[%d]\\n\",\n\t\t\tret);\n}\n\nstatic void\ngsccs_destroy_execution_resource(struct intel_pxp *pxp)\n{\n\tstruct gsccs_session_resources *exec_res = &pxp->gsccs_res;\n\n\tif (exec_res->host_session_handle)\n\t\tgsccs_cleanup_fw_host_session_handle(pxp);\n\tif (exec_res->ce)\n\t\tintel_context_put(exec_res->ce);\n\tif (exec_res->bb_vma)\n\t\ti915_vma_unpin_and_release(&exec_res->bb_vma, I915_VMA_RELEASE_MAP);\n\tif (exec_res->pkt_vma)\n\t\ti915_vma_unpin_and_release(&exec_res->pkt_vma, I915_VMA_RELEASE_MAP);\n\n\tmemset(exec_res, 0, sizeof(*exec_res));\n}\n\nstatic int\ngsccs_create_buffer(struct intel_gt *gt,\n\t\t    const char *bufname, size_t size,\n\t\t    struct i915_vma **vma, void **map)\n{\n\tstruct drm_i915_private *i915 = gt->i915;\n\tstruct drm_i915_gem_object *obj;\n\tint err = 0;\n\n\tobj = i915_gem_object_create_internal(i915, size);\n\tif (IS_ERR(obj)) {\n\t\tdrm_err(&i915->drm, \"Failed to allocate gsccs backend %s.\\n\", bufname);\n\t\terr = PTR_ERR(obj);\n\t\tgoto out_none;\n\t}\n\n\t*vma = i915_vma_instance(obj, gt->vm, NULL);\n\tif (IS_ERR(*vma)) {\n\t\tdrm_err(&i915->drm, \"Failed to vma-instance gsccs backend %s.\\n\", bufname);\n\t\terr = PTR_ERR(*vma);\n\t\tgoto out_put;\n\t}\n\n\t \n\t*map = i915_gem_object_pin_map_unlocked(obj, intel_gt_coherent_map_type(gt, obj, true));\n\tif (IS_ERR(*map)) {\n\t\tdrm_err(&i915->drm, \"Failed to map gsccs backend %s.\\n\", bufname);\n\t\terr = PTR_ERR(*map);\n\t\tgoto out_put;\n\t}\n\n\t \n\terr = i915_vma_pin(*vma, 0, 0, PIN_USER);\n\tif (err) {\n\t\tdrm_err(&i915->drm, \"Failed to vma-pin gsccs backend %s.\\n\", bufname);\n\t\tgoto out_unmap;\n\t}\n\n\treturn 0;\n\nout_unmap:\n\ti915_gem_object_unpin_map(obj);\nout_put:\n\ti915_gem_object_put(obj);\nout_none:\n\t*vma = NULL;\n\t*map = NULL;\n\n\treturn err;\n}\n\nstatic int\ngsccs_allocate_execution_resource(struct intel_pxp *pxp)\n{\n\tstruct intel_gt *gt = pxp->ctrl_gt;\n\tstruct gsccs_session_resources *exec_res = &pxp->gsccs_res;\n\tstruct intel_engine_cs *engine = gt->engine[GSC0];\n\tstruct intel_context *ce;\n\tint err = 0;\n\n\t \n\tif (!engine)\n\t\treturn -ENODEV;\n\n\t \n\terr = gsccs_create_buffer(pxp->ctrl_gt, \"Heci Packet\",\n\t\t\t\t  2 * PXP43_MAX_HECI_INOUT_SIZE,\n\t\t\t\t  &exec_res->pkt_vma, &exec_res->pkt_vaddr);\n\tif (err)\n\t\treturn err;\n\n\terr = gsccs_create_buffer(pxp->ctrl_gt, \"Batch Buffer\", PAGE_SIZE,\n\t\t\t\t  &exec_res->bb_vma, &exec_res->bb_vaddr);\n\tif (err)\n\t\tgoto free_pkt;\n\n\t \n\tce = intel_context_create(engine);\n\tif (IS_ERR(ce)) {\n\t\tdrm_err(&gt->i915->drm, \"Failed creating gsccs backend ctx\\n\");\n\t\terr = PTR_ERR(ce);\n\t\tgoto free_batch;\n\t}\n\n\ti915_vm_put(ce->vm);\n\tce->vm = i915_vm_get(pxp->ctrl_gt->vm);\n\texec_res->ce = ce;\n\n\t \n\tget_random_bytes(&exec_res->host_session_handle, sizeof(exec_res->host_session_handle));\n\n\treturn 0;\n\nfree_batch:\n\ti915_vma_unpin_and_release(&exec_res->bb_vma, I915_VMA_RELEASE_MAP);\nfree_pkt:\n\ti915_vma_unpin_and_release(&exec_res->pkt_vma, I915_VMA_RELEASE_MAP);\n\tmemset(exec_res, 0, sizeof(*exec_res));\n\n\treturn err;\n}\n\nvoid intel_pxp_gsccs_fini(struct intel_pxp *pxp)\n{\n\tintel_wakeref_t wakeref;\n\n\tgsccs_destroy_execution_resource(pxp);\n\twith_intel_runtime_pm(&pxp->ctrl_gt->i915->runtime_pm, wakeref)\n\t\tintel_pxp_fini_hw(pxp);\n}\n\nint intel_pxp_gsccs_init(struct intel_pxp *pxp)\n{\n\tint ret;\n\tintel_wakeref_t wakeref;\n\n\tret = gsccs_allocate_execution_resource(pxp);\n\tif (!ret) {\n\t\twith_intel_runtime_pm(&pxp->ctrl_gt->i915->runtime_pm, wakeref)\n\t\t\tintel_pxp_init_hw(pxp);\n\t}\n\treturn ret;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}