{
  "module_name": "intel_pxp_cmd.c",
  "hash_id": "74e645da6ba3219c8ea99c9aabf667a6404aaf8d840eaaff42d0c55eb16a6531",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/i915/pxp/intel_pxp_cmd.c",
  "human_readable_source": "\n \n\n#include \"gt/intel_context.h\"\n#include \"gt/intel_engine_pm.h\"\n#include \"gt/intel_gpu_commands.h\"\n#include \"gt/intel_ring.h\"\n\n#include \"i915_trace.h\"\n\n#include \"intel_pxp.h\"\n#include \"intel_pxp_cmd.h\"\n#include \"intel_pxp_session.h\"\n#include \"intel_pxp_types.h\"\n\n \n#define MFX_WAIT_PXP (MFX_WAIT | \\\n\t\t      MFX_WAIT_DW0_PXP_SYNC_CONTROL_FLAG | \\\n\t\t      MFX_WAIT_DW0_MFX_SYNC_CONTROL_FLAG)\n\nstatic u32 *pxp_emit_session_selection(u32 *cs, u32 idx)\n{\n\t*cs++ = MFX_WAIT_PXP;\n\n\t \n\t*cs++ = MI_FLUSH_DW;\n\t*cs++ = 0;\n\t*cs++ = 0;\n\n\t \n\t*cs++ = MI_SET_APPID | MI_SET_APPID_SESSION_ID(idx);\n\n\t*cs++ = MFX_WAIT_PXP;\n\n\t \n\t*cs++ = MI_FLUSH_DW | MI_FLUSH_DW_PROTECTED_MEM_EN |\n\t\tMI_FLUSH_DW_OP_STOREDW | MI_FLUSH_DW_STORE_INDEX;\n\t*cs++ = I915_GEM_HWS_PXP_ADDR | MI_FLUSH_DW_USE_GTT;\n\t*cs++ = 0;\n\n\t*cs++ = MFX_WAIT_PXP;\n\n\treturn cs;\n}\n\nstatic u32 *pxp_emit_inline_termination(u32 *cs)\n{\n\t \n\t*cs++ = CRYPTO_KEY_EXCHANGE;\n\t*cs++ = 0;\n\n\treturn cs;\n}\n\nstatic u32 *pxp_emit_session_termination(u32 *cs, u32 idx)\n{\n\tcs = pxp_emit_session_selection(cs, idx);\n\tcs = pxp_emit_inline_termination(cs);\n\n\treturn cs;\n}\n\nstatic u32 *pxp_emit_wait(u32 *cs)\n{\n\t \n\t*cs++ = MFX_WAIT_PXP;\n\t*cs++ = 0;\n\n\treturn cs;\n}\n\n \n#define SELECTION_LEN 10\n#define TERMINATION_LEN 2\n#define SESSION_TERMINATION_LEN(x) ((SELECTION_LEN + TERMINATION_LEN) * (x))\n#define WAIT_LEN 2\n\nstatic void pxp_request_commit(struct i915_request *rq)\n{\n\tstruct i915_sched_attr attr = { .priority = I915_PRIORITY_MAX };\n\tstruct intel_timeline * const tl = i915_request_timeline(rq);\n\n\tlockdep_unpin_lock(&tl->mutex, rq->cookie);\n\n\ttrace_i915_request_add(rq);\n\t__i915_request_commit(rq);\n\t__i915_request_queue(rq, &attr);\n\n\tmutex_unlock(&tl->mutex);\n}\n\nint intel_pxp_terminate_session(struct intel_pxp *pxp, u32 id)\n{\n\tstruct i915_request *rq;\n\tstruct intel_context *ce = pxp->ce;\n\tu32 *cs;\n\tint err = 0;\n\n\tif (!intel_pxp_is_enabled(pxp))\n\t\treturn 0;\n\n\trq = i915_request_create(ce);\n\tif (IS_ERR(rq))\n\t\treturn PTR_ERR(rq);\n\n\tif (ce->engine->emit_init_breadcrumb) {\n\t\terr = ce->engine->emit_init_breadcrumb(rq);\n\t\tif (err)\n\t\t\tgoto out_rq;\n\t}\n\n\tcs = intel_ring_begin(rq, SESSION_TERMINATION_LEN(1) + WAIT_LEN);\n\tif (IS_ERR(cs)) {\n\t\terr = PTR_ERR(cs);\n\t\tgoto out_rq;\n\t}\n\n\tcs = pxp_emit_session_termination(cs, id);\n\tcs = pxp_emit_wait(cs);\n\n\tintel_ring_advance(rq, cs);\n\nout_rq:\n\ti915_request_get(rq);\n\n\tif (unlikely(err))\n\t\ti915_request_set_error_once(rq, err);\n\n\tpxp_request_commit(rq);\n\n\tif (!err && i915_request_wait(rq, 0, HZ / 5) < 0)\n\t\terr = -ETIME;\n\n\ti915_request_put(rq);\n\n\treturn err;\n}\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}