{
  "module_name": "intel_pxp_irq.c",
  "hash_id": "c67dc9534fad02dd0fcb1f52913e54e0b462a30c0cc17993763162d629b75e65",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/i915/pxp/intel_pxp_irq.c",
  "human_readable_source": "\n \n#include <linux/workqueue.h>\n\n#include \"gt/intel_gt_irq.h\"\n#include \"gt/intel_gt_regs.h\"\n#include \"gt/intel_gt_types.h\"\n\n#include \"i915_irq.h\"\n#include \"i915_reg.h\"\n\n#include \"intel_pxp.h\"\n#include \"intel_pxp_irq.h\"\n#include \"intel_pxp_session.h\"\n#include \"intel_pxp_types.h\"\n#include \"intel_runtime_pm.h\"\n\n \nvoid intel_pxp_irq_handler(struct intel_pxp *pxp, u16 iir)\n{\n\tstruct intel_gt *gt;\n\n\tif (GEM_WARN_ON(!intel_pxp_is_enabled(pxp)))\n\t\treturn;\n\n\tgt = pxp->ctrl_gt;\n\n\tlockdep_assert_held(gt->irq_lock);\n\n\tif (unlikely(!iir))\n\t\treturn;\n\n\tif (iir & (GEN12_DISPLAY_PXP_STATE_TERMINATED_INTERRUPT |\n\t\t   GEN12_DISPLAY_APP_TERMINATED_PER_FW_REQ_INTERRUPT)) {\n\t\t \n\t\tintel_pxp_mark_termination_in_progress(pxp);\n\t\tpxp->session_events |= PXP_TERMINATION_REQUEST | PXP_INVAL_REQUIRED;\n\t}\n\n\tif (iir & GEN12_DISPLAY_STATE_RESET_COMPLETE_INTERRUPT)\n\t\tpxp->session_events |= PXP_TERMINATION_COMPLETE;\n\n\tif (pxp->session_events)\n\t\tqueue_work(system_unbound_wq, &pxp->session_work);\n}\n\nstatic inline void __pxp_set_interrupts(struct intel_gt *gt, u32 interrupts)\n{\n\tstruct intel_uncore *uncore = gt->uncore;\n\tconst u32 mask = interrupts << 16;\n\n\tintel_uncore_write(uncore, GEN11_CRYPTO_RSVD_INTR_ENABLE, mask);\n\tintel_uncore_write(uncore, GEN11_CRYPTO_RSVD_INTR_MASK,  ~mask);\n}\n\nstatic inline void pxp_irq_reset(struct intel_gt *gt)\n{\n\tspin_lock_irq(gt->irq_lock);\n\tgen11_gt_reset_one_iir(gt, 0, GEN11_KCR);\n\tspin_unlock_irq(gt->irq_lock);\n}\n\nvoid intel_pxp_irq_enable(struct intel_pxp *pxp)\n{\n\tstruct intel_gt *gt = pxp->ctrl_gt;\n\n\tspin_lock_irq(gt->irq_lock);\n\n\tif (!pxp->irq_enabled)\n\t\tWARN_ON_ONCE(gen11_gt_reset_one_iir(gt, 0, GEN11_KCR));\n\n\t__pxp_set_interrupts(gt, GEN12_PXP_INTERRUPTS);\n\tpxp->irq_enabled = true;\n\n\tspin_unlock_irq(gt->irq_lock);\n}\n\nvoid intel_pxp_irq_disable(struct intel_pxp *pxp)\n{\n\tstruct intel_gt *gt = pxp->ctrl_gt;\n\n\t \n\tGEM_WARN_ON(intel_pxp_is_active(pxp));\n\n\tspin_lock_irq(gt->irq_lock);\n\n\tpxp->irq_enabled = false;\n\t__pxp_set_interrupts(gt, 0);\n\n\tspin_unlock_irq(gt->irq_lock);\n\tintel_synchronize_irq(gt->i915);\n\n\tpxp_irq_reset(gt);\n\n\tflush_work(&pxp->session_work);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}