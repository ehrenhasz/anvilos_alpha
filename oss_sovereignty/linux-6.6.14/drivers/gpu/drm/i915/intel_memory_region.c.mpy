{
  "module_name": "intel_memory_region.c",
  "hash_id": "5fcab80a0f674809e258b89b456ccfbe8501c90d98bcb5e3cc16d1844c1b9e3e",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/i915/intel_memory_region.c",
  "human_readable_source": "\n \n\n#include <linux/prandom.h>\n\n#include <uapi/drm/i915_drm.h>\n\n#include \"intel_memory_region.h\"\n#include \"i915_drv.h\"\n#include \"i915_ttm_buddy_manager.h\"\n\nstatic const struct {\n\tu16 class;\n\tu16 instance;\n} intel_region_map[] = {\n\t[INTEL_REGION_SMEM] = {\n\t\t.class = INTEL_MEMORY_SYSTEM,\n\t\t.instance = 0,\n\t},\n\t[INTEL_REGION_LMEM_0] = {\n\t\t.class = INTEL_MEMORY_LOCAL,\n\t\t.instance = 0,\n\t},\n\t[INTEL_REGION_STOLEN_SMEM] = {\n\t\t.class = INTEL_MEMORY_STOLEN_SYSTEM,\n\t\t.instance = 0,\n\t},\n\t[INTEL_REGION_STOLEN_LMEM] = {\n\t\t.class = INTEL_MEMORY_STOLEN_LOCAL,\n\t\t.instance = 0,\n\t},\n};\n\nstatic int __iopagetest(struct intel_memory_region *mem,\n\t\t\tu8 __iomem *va, int pagesize,\n\t\t\tu8 value, resource_size_t offset,\n\t\t\tconst void *caller)\n{\n\tint byte = get_random_u32_below(pagesize);\n\tu8 result[3];\n\n\tmemset_io(va, value, pagesize);  \n\twmb();\n\n\tresult[0] = ioread8(va);\n\tresult[1] = ioread8(va + byte);\n\tresult[2] = ioread8(va + pagesize - 1);\n\tif (memchr_inv(result, value, sizeof(result))) {\n\t\tdev_err(mem->i915->drm.dev,\n\t\t\t\"Failed to read back from memory region:%pR at [%pa + %pa] for %ps; wrote %x, read (%x, %x, %x)\\n\",\n\t\t\t&mem->region, &mem->io_start, &offset, caller,\n\t\t\tvalue, result[0], result[1], result[2]);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int iopagetest(struct intel_memory_region *mem,\n\t\t      resource_size_t offset,\n\t\t      const void *caller)\n{\n\tconst u8 val[] = { 0x0, 0xa5, 0xc3, 0xf0 };\n\tvoid __iomem *va;\n\tint err;\n\tint i;\n\n\tva = ioremap_wc(mem->io_start + offset, PAGE_SIZE);\n\tif (!va) {\n\t\tdev_err(mem->i915->drm.dev,\n\t\t\t\"Failed to ioremap memory region [%pa + %pa] for %ps\\n\",\n\t\t\t&mem->io_start, &offset, caller);\n\t\treturn -EFAULT;\n\t}\n\n\tfor (i = 0; i < ARRAY_SIZE(val); i++) {\n\t\terr = __iopagetest(mem, va, PAGE_SIZE, val[i], offset, caller);\n\t\tif (err)\n\t\t\tbreak;\n\n\t\terr = __iopagetest(mem, va, PAGE_SIZE, ~val[i], offset, caller);\n\t\tif (err)\n\t\t\tbreak;\n\t}\n\n\tiounmap(va);\n\treturn err;\n}\n\nstatic resource_size_t random_page(resource_size_t last)\n{\n\t \n\treturn get_random_u32_below(last >> PAGE_SHIFT) << PAGE_SHIFT;\n}\n\nstatic int iomemtest(struct intel_memory_region *mem,\n\t\t     bool test_all,\n\t\t     const void *caller)\n{\n\tresource_size_t last, page;\n\tint err;\n\n\tif (mem->io_size < PAGE_SIZE)\n\t\treturn 0;\n\n\tlast = mem->io_size - PAGE_SIZE;\n\n\t \n\n\tif (test_all) {\n\t\tfor (page = 0; page <= last; page += PAGE_SIZE) {\n\t\t\terr = iopagetest(mem, page, caller);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t}\n\t} else {\n\t\terr = iopagetest(mem, 0, caller);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\terr = iopagetest(mem, last, caller);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\terr = iopagetest(mem, random_page(last), caller);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\nstruct intel_memory_region *\nintel_memory_region_lookup(struct drm_i915_private *i915,\n\t\t\t   u16 class, u16 instance)\n{\n\tstruct intel_memory_region *mr;\n\tint id;\n\n\t \n\tfor_each_memory_region(mr, i915, id) {\n\t\tif (mr->type == class && mr->instance == instance)\n\t\t\treturn mr;\n\t}\n\n\treturn NULL;\n}\n\nstruct intel_memory_region *\nintel_memory_region_by_type(struct drm_i915_private *i915,\n\t\t\t    enum intel_memory_type mem_type)\n{\n\tstruct intel_memory_region *mr;\n\tint id;\n\n\tfor_each_memory_region(mr, i915, id)\n\t\tif (mr->type == mem_type)\n\t\t\treturn mr;\n\n\treturn NULL;\n}\n\n \nint intel_memory_region_reserve(struct intel_memory_region *mem,\n\t\t\t\tresource_size_t offset,\n\t\t\t\tresource_size_t size)\n{\n\tstruct ttm_resource_manager *man = mem->region_private;\n\n\tGEM_BUG_ON(mem->is_range_manager);\n\n\treturn i915_ttm_buddy_man_reserve(man, offset, size);\n}\n\nvoid intel_memory_region_debug(struct intel_memory_region *mr,\n\t\t\t       struct drm_printer *printer)\n{\n\tdrm_printf(printer, \"%s: \", mr->name);\n\n\tif (mr->region_private)\n\t\tttm_resource_manager_debug(mr->region_private, printer);\n\telse\n\t\tdrm_printf(printer, \"total:%pa bytes\\n\", &mr->total);\n}\n\nstatic int intel_memory_region_memtest(struct intel_memory_region *mem,\n\t\t\t\t       void *caller)\n{\n\tstruct drm_i915_private *i915 = mem->i915;\n\tint err = 0;\n\n\tif (!mem->io_start)\n\t\treturn 0;\n\n\tif (IS_ENABLED(CONFIG_DRM_I915_DEBUG_GEM) || i915->params.memtest)\n\t\terr = iomemtest(mem, i915->params.memtest, caller);\n\n\treturn err;\n}\n\nstruct intel_memory_region *\nintel_memory_region_create(struct drm_i915_private *i915,\n\t\t\t   resource_size_t start,\n\t\t\t   resource_size_t size,\n\t\t\t   resource_size_t min_page_size,\n\t\t\t   resource_size_t io_start,\n\t\t\t   resource_size_t io_size,\n\t\t\t   u16 type,\n\t\t\t   u16 instance,\n\t\t\t   const struct intel_memory_region_ops *ops)\n{\n\tstruct intel_memory_region *mem;\n\tint err;\n\n\tmem = kzalloc(sizeof(*mem), GFP_KERNEL);\n\tif (!mem)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tmem->i915 = i915;\n\tmem->region = DEFINE_RES_MEM(start, size);\n\tmem->io_start = io_start;\n\tmem->io_size = io_size;\n\tmem->min_page_size = min_page_size;\n\tmem->ops = ops;\n\tmem->total = size;\n\tmem->type = type;\n\tmem->instance = instance;\n\n\tmutex_init(&mem->objects.lock);\n\tINIT_LIST_HEAD(&mem->objects.list);\n\n\tif (ops->init) {\n\t\terr = ops->init(mem);\n\t\tif (err)\n\t\t\tgoto err_free;\n\t}\n\n\terr = intel_memory_region_memtest(mem, (void *)_RET_IP_);\n\tif (err)\n\t\tgoto err_release;\n\n\treturn mem;\n\nerr_release:\n\tif (mem->ops->release)\n\t\tmem->ops->release(mem);\nerr_free:\n\tkfree(mem);\n\treturn ERR_PTR(err);\n}\n\nvoid intel_memory_region_set_name(struct intel_memory_region *mem,\n\t\t\t\t  const char *fmt, ...)\n{\n\tva_list ap;\n\n\tva_start(ap, fmt);\n\tvsnprintf(mem->name, sizeof(mem->name), fmt, ap);\n\tva_end(ap);\n}\n\nvoid intel_memory_region_avail(struct intel_memory_region *mr,\n\t\t\t       u64 *avail, u64 *visible_avail)\n{\n\tif (mr->type == INTEL_MEMORY_LOCAL) {\n\t\ti915_ttm_buddy_man_avail(mr->region_private,\n\t\t\t\t\t avail, visible_avail);\n\t\t*avail <<= PAGE_SHIFT;\n\t\t*visible_avail <<= PAGE_SHIFT;\n\t} else {\n\t\t*avail = mr->total;\n\t\t*visible_avail = mr->total;\n\t}\n}\n\nvoid intel_memory_region_destroy(struct intel_memory_region *mem)\n{\n\tint ret = 0;\n\n\tif (mem->ops->release)\n\t\tret = mem->ops->release(mem);\n\n\tGEM_WARN_ON(!list_empty_careful(&mem->objects.list));\n\tmutex_destroy(&mem->objects.lock);\n\tif (!ret)\n\t\tkfree(mem);\n}\n\n \n\nint intel_memory_regions_hw_probe(struct drm_i915_private *i915)\n{\n\tint err, i;\n\n\tfor (i = 0; i < ARRAY_SIZE(i915->mm.regions); i++) {\n\t\tstruct intel_memory_region *mem = ERR_PTR(-ENODEV);\n\t\tu16 type, instance;\n\n\t\tif (!HAS_REGION(i915, BIT(i)))\n\t\t\tcontinue;\n\n\t\ttype = intel_region_map[i].class;\n\t\tinstance = intel_region_map[i].instance;\n\t\tswitch (type) {\n\t\tcase INTEL_MEMORY_SYSTEM:\n\t\t\tif (IS_DGFX(i915))\n\t\t\t\tmem = i915_gem_ttm_system_setup(i915, type,\n\t\t\t\t\t\t\t\tinstance);\n\t\t\telse\n\t\t\t\tmem = i915_gem_shmem_setup(i915, type,\n\t\t\t\t\t\t\t   instance);\n\t\t\tbreak;\n\t\tcase INTEL_MEMORY_STOLEN_LOCAL:\n\t\t\tmem = i915_gem_stolen_lmem_setup(i915, type, instance);\n\t\t\tif (!IS_ERR(mem))\n\t\t\t\ti915->mm.stolen_region = mem;\n\t\t\tbreak;\n\t\tcase INTEL_MEMORY_STOLEN_SYSTEM:\n\t\t\tmem = i915_gem_stolen_smem_setup(i915, type, instance);\n\t\t\tif (!IS_ERR(mem))\n\t\t\t\ti915->mm.stolen_region = mem;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (IS_ERR(mem)) {\n\t\t\terr = PTR_ERR(mem);\n\t\t\tdrm_err(&i915->drm,\n\t\t\t\t\"Failed to setup region(%d) type=%d\\n\",\n\t\t\t\terr, type);\n\t\t\tgoto out_cleanup;\n\t\t}\n\n\t\tmem->id = i;\n\t\ti915->mm.regions[i] = mem;\n\t}\n\n\treturn 0;\n\nout_cleanup:\n\tintel_memory_regions_driver_release(i915);\n\treturn err;\n}\n\nvoid intel_memory_regions_driver_release(struct drm_i915_private *i915)\n{\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(i915->mm.regions); i++) {\n\t\tstruct intel_memory_region *region =\n\t\t\tfetch_and_zero(&i915->mm.regions[i]);\n\n\t\tif (region)\n\t\t\tintel_memory_region_destroy(region);\n\t}\n}\n\n#if IS_ENABLED(CONFIG_DRM_I915_SELFTEST)\n#include \"selftests/intel_memory_region.c\"\n#include \"selftests/mock_region.c\"\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}