{
  "module_name": "i915_vgpu.c",
  "hash_id": "4b035fe84d92533b74e2494a38379692120a1c342eeeee8209d0a758f8951f43",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/i915/i915_vgpu.c",
  "human_readable_source": " \n\n#include \"i915_drv.h\"\n#include \"i915_pvinfo.h\"\n#include \"i915_vgpu.h\"\n\n \n\n \nvoid intel_vgpu_detect(struct drm_i915_private *dev_priv)\n{\n\tstruct pci_dev *pdev = to_pci_dev(dev_priv->drm.dev);\n\tu64 magic;\n\tu16 version_major;\n\tvoid __iomem *shared_area;\n\n\tBUILD_BUG_ON(sizeof(struct vgt_if) != VGT_PVINFO_SIZE);\n\n\t \n\tif (GRAPHICS_VER(dev_priv) < 6)\n\t\treturn;\n\n\tshared_area = pci_iomap_range(pdev, 0, VGT_PVINFO_PAGE, VGT_PVINFO_SIZE);\n\tif (!shared_area) {\n\t\tdrm_err(&dev_priv->drm,\n\t\t\t\"failed to map MMIO bar to check for VGT\\n\");\n\t\treturn;\n\t}\n\n\tmagic = readq(shared_area + vgtif_offset(magic));\n\tif (magic != VGT_MAGIC)\n\t\tgoto out;\n\n\tversion_major = readw(shared_area + vgtif_offset(version_major));\n\tif (version_major < VGT_VERSION_MAJOR) {\n\t\tdrm_info(&dev_priv->drm, \"VGT interface version mismatch!\\n\");\n\t\tgoto out;\n\t}\n\n\tdev_priv->vgpu.caps = readl(shared_area + vgtif_offset(vgt_caps));\n\n\tdev_priv->vgpu.active = true;\n\tmutex_init(&dev_priv->vgpu.lock);\n\tdrm_info(&dev_priv->drm, \"Virtual GPU for Intel GVT-g detected.\\n\");\n\nout:\n\tpci_iounmap(pdev, shared_area);\n}\n\nvoid intel_vgpu_register(struct drm_i915_private *i915)\n{\n\t \n\tif (intel_vgpu_active(i915))\n\t\tintel_uncore_write(&i915->uncore, vgtif_reg(display_ready),\n\t\t\t\t   VGT_DRV_DISPLAY_READY);\n}\n\nbool intel_vgpu_active(struct drm_i915_private *dev_priv)\n{\n\treturn dev_priv->vgpu.active;\n}\n\nbool intel_vgpu_has_full_ppgtt(struct drm_i915_private *dev_priv)\n{\n\treturn dev_priv->vgpu.caps & VGT_CAPS_FULL_PPGTT;\n}\n\nbool intel_vgpu_has_hwsp_emulation(struct drm_i915_private *dev_priv)\n{\n\treturn dev_priv->vgpu.caps & VGT_CAPS_HWSP_EMULATION;\n}\n\nbool intel_vgpu_has_huge_gtt(struct drm_i915_private *dev_priv)\n{\n\treturn dev_priv->vgpu.caps & VGT_CAPS_HUGE_GTT;\n}\n\nstruct _balloon_info_ {\n\t \n\tstruct drm_mm_node space[4];\n};\n\nstatic struct _balloon_info_ bl_info;\n\nstatic void vgt_deballoon_space(struct i915_ggtt *ggtt,\n\t\t\t\tstruct drm_mm_node *node)\n{\n\tstruct drm_i915_private *dev_priv = ggtt->vm.i915;\n\tif (!drm_mm_node_allocated(node))\n\t\treturn;\n\n\tdrm_dbg(&dev_priv->drm,\n\t\t\"deballoon space: range [0x%llx - 0x%llx] %llu KiB.\\n\",\n\t\tnode->start,\n\t\tnode->start + node->size,\n\t\tnode->size / 1024);\n\n\tggtt->vm.reserved -= node->size;\n\tdrm_mm_remove_node(node);\n}\n\n \nvoid intel_vgt_deballoon(struct i915_ggtt *ggtt)\n{\n\tstruct drm_i915_private *dev_priv = ggtt->vm.i915;\n\tint i;\n\n\tif (!intel_vgpu_active(ggtt->vm.i915))\n\t\treturn;\n\n\tdrm_dbg(&dev_priv->drm, \"VGT deballoon.\\n\");\n\n\tfor (i = 0; i < 4; i++)\n\t\tvgt_deballoon_space(ggtt, &bl_info.space[i]);\n}\n\nstatic int vgt_balloon_space(struct i915_ggtt *ggtt,\n\t\t\t     struct drm_mm_node *node,\n\t\t\t     unsigned long start, unsigned long end)\n{\n\tstruct drm_i915_private *dev_priv = ggtt->vm.i915;\n\tunsigned long size = end - start;\n\tint ret;\n\n\tif (start >= end)\n\t\treturn -EINVAL;\n\n\tdrm_info(&dev_priv->drm,\n\t\t \"balloon space: range [ 0x%lx - 0x%lx ] %lu KiB.\\n\",\n\t\t start, end, size / 1024);\n\tret = i915_gem_gtt_reserve(&ggtt->vm, NULL, node,\n\t\t\t\t   size, start, I915_COLOR_UNEVICTABLE,\n\t\t\t\t   0);\n\tif (!ret)\n\t\tggtt->vm.reserved += size;\n\n\treturn ret;\n}\n\n \nint intel_vgt_balloon(struct i915_ggtt *ggtt)\n{\n\tstruct drm_i915_private *dev_priv = ggtt->vm.i915;\n\tstruct intel_uncore *uncore = &dev_priv->uncore;\n\tunsigned long ggtt_end = ggtt->vm.total;\n\n\tunsigned long mappable_base, mappable_size, mappable_end;\n\tunsigned long unmappable_base, unmappable_size, unmappable_end;\n\tint ret;\n\n\tif (!intel_vgpu_active(ggtt->vm.i915))\n\t\treturn 0;\n\n\tmappable_base =\n\t  intel_uncore_read(uncore, vgtif_reg(avail_rs.mappable_gmadr.base));\n\tmappable_size =\n\t  intel_uncore_read(uncore, vgtif_reg(avail_rs.mappable_gmadr.size));\n\tunmappable_base =\n\t  intel_uncore_read(uncore, vgtif_reg(avail_rs.nonmappable_gmadr.base));\n\tunmappable_size =\n\t  intel_uncore_read(uncore, vgtif_reg(avail_rs.nonmappable_gmadr.size));\n\n\tmappable_end = mappable_base + mappable_size;\n\tunmappable_end = unmappable_base + unmappable_size;\n\n\tdrm_info(&dev_priv->drm, \"VGT ballooning configuration:\\n\");\n\tdrm_info(&dev_priv->drm,\n\t\t \"Mappable graphic memory: base 0x%lx size %ldKiB\\n\",\n\t\t mappable_base, mappable_size / 1024);\n\tdrm_info(&dev_priv->drm,\n\t\t \"Unmappable graphic memory: base 0x%lx size %ldKiB\\n\",\n\t\t unmappable_base, unmappable_size / 1024);\n\n\tif (mappable_end > ggtt->mappable_end ||\n\t    unmappable_base < ggtt->mappable_end ||\n\t    unmappable_end > ggtt_end) {\n\t\tdrm_err(&dev_priv->drm, \"Invalid ballooning configuration!\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (unmappable_base > ggtt->mappable_end) {\n\t\tret = vgt_balloon_space(ggtt, &bl_info.space[2],\n\t\t\t\t\tggtt->mappable_end, unmappable_base);\n\n\t\tif (ret)\n\t\t\tgoto err;\n\t}\n\n\tif (unmappable_end < ggtt_end) {\n\t\tret = vgt_balloon_space(ggtt, &bl_info.space[3],\n\t\t\t\t\tunmappable_end, ggtt_end);\n\t\tif (ret)\n\t\t\tgoto err_upon_mappable;\n\t}\n\n\t \n\tif (mappable_base) {\n\t\tret = vgt_balloon_space(ggtt, &bl_info.space[0],\n\t\t\t\t\t0, mappable_base);\n\n\t\tif (ret)\n\t\t\tgoto err_upon_unmappable;\n\t}\n\n\tif (mappable_end < ggtt->mappable_end) {\n\t\tret = vgt_balloon_space(ggtt, &bl_info.space[1],\n\t\t\t\t\tmappable_end, ggtt->mappable_end);\n\n\t\tif (ret)\n\t\t\tgoto err_below_mappable;\n\t}\n\n\tdrm_info(&dev_priv->drm, \"VGT balloon successfully\\n\");\n\treturn 0;\n\nerr_below_mappable:\n\tvgt_deballoon_space(ggtt, &bl_info.space[0]);\nerr_upon_unmappable:\n\tvgt_deballoon_space(ggtt, &bl_info.space[3]);\nerr_upon_mappable:\n\tvgt_deballoon_space(ggtt, &bl_info.space[2]);\nerr:\n\tdrm_err(&dev_priv->drm, \"VGT balloon fail\\n\");\n\treturn ret;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}