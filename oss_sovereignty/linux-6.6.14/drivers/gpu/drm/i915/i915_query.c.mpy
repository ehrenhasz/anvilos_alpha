{
  "module_name": "i915_query.c",
  "hash_id": "7a453621feb68618123eac75a206bdf4c1c5779398f9f6992a8f31c311638575",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/i915/i915_query.c",
  "human_readable_source": " \n\n#include <linux/nospec.h>\n\n#include \"i915_drv.h\"\n#include \"i915_perf.h\"\n#include \"i915_query.h\"\n#include \"gt/intel_engine_user.h\"\n#include <uapi/drm/i915_drm.h>\n\nstatic int copy_query_item(void *query_hdr, size_t query_sz,\n\t\t\t   u32 total_length,\n\t\t\t   struct drm_i915_query_item *query_item)\n{\n\tif (query_item->length == 0)\n\t\treturn total_length;\n\n\tif (query_item->length < total_length)\n\t\treturn -EINVAL;\n\n\tif (copy_from_user(query_hdr, u64_to_user_ptr(query_item->data_ptr),\n\t\t\t   query_sz))\n\t\treturn -EFAULT;\n\n\treturn 0;\n}\n\nstatic int fill_topology_info(const struct sseu_dev_info *sseu,\n\t\t\t      struct drm_i915_query_item *query_item,\n\t\t\t      intel_sseu_ss_mask_t subslice_mask)\n{\n\tstruct drm_i915_query_topology_info topo;\n\tu32 slice_length, subslice_length, eu_length, total_length;\n\tint ss_stride = GEN_SSEU_STRIDE(sseu->max_subslices);\n\tint eu_stride = GEN_SSEU_STRIDE(sseu->max_eus_per_subslice);\n\tint ret;\n\n\tBUILD_BUG_ON(sizeof(u8) != sizeof(sseu->slice_mask));\n\n\tif (sseu->max_slices == 0)\n\t\treturn -ENODEV;\n\n\tslice_length = sizeof(sseu->slice_mask);\n\tsubslice_length = sseu->max_slices * ss_stride;\n\teu_length = sseu->max_slices * sseu->max_subslices * eu_stride;\n\ttotal_length = sizeof(topo) + slice_length + subslice_length +\n\t\t       eu_length;\n\n\tret = copy_query_item(&topo, sizeof(topo), total_length, query_item);\n\n\tif (ret != 0)\n\t\treturn ret;\n\n\tmemset(&topo, 0, sizeof(topo));\n\ttopo.max_slices = sseu->max_slices;\n\ttopo.max_subslices = sseu->max_subslices;\n\ttopo.max_eus_per_subslice = sseu->max_eus_per_subslice;\n\n\ttopo.subslice_offset = slice_length;\n\ttopo.subslice_stride = ss_stride;\n\ttopo.eu_offset = slice_length + subslice_length;\n\ttopo.eu_stride = eu_stride;\n\n\tif (copy_to_user(u64_to_user_ptr(query_item->data_ptr),\n\t\t\t &topo, sizeof(topo)))\n\t\treturn -EFAULT;\n\n\tif (copy_to_user(u64_to_user_ptr(query_item->data_ptr + sizeof(topo)),\n\t\t\t &sseu->slice_mask, slice_length))\n\t\treturn -EFAULT;\n\n\tif (intel_sseu_copy_ssmask_to_user(u64_to_user_ptr(query_item->data_ptr +\n\t\t\t\t\t\t\t   sizeof(topo) + slice_length),\n\t\t\t\t\t   sseu))\n\t\treturn -EFAULT;\n\n\tif (intel_sseu_copy_eumask_to_user(u64_to_user_ptr(query_item->data_ptr +\n\t\t\t\t\t\t\t   sizeof(topo) +\n\t\t\t\t\t\t\t   slice_length + subslice_length),\n\t\t\t\t\t   sseu))\n\t\treturn -EFAULT;\n\n\treturn total_length;\n}\n\nstatic int query_topology_info(struct drm_i915_private *dev_priv,\n\t\t\t       struct drm_i915_query_item *query_item)\n{\n\tconst struct sseu_dev_info *sseu = &to_gt(dev_priv)->info.sseu;\n\n\tif (query_item->flags != 0)\n\t\treturn -EINVAL;\n\n\treturn fill_topology_info(sseu, query_item, sseu->subslice_mask);\n}\n\nstatic int query_geometry_subslices(struct drm_i915_private *i915,\n\t\t\t\t    struct drm_i915_query_item *query_item)\n{\n\tconst struct sseu_dev_info *sseu;\n\tstruct intel_engine_cs *engine;\n\tstruct i915_engine_class_instance classinstance;\n\n\tif (GRAPHICS_VER_FULL(i915) < IP_VER(12, 50))\n\t\treturn -ENODEV;\n\n\tclassinstance = *((struct i915_engine_class_instance *)&query_item->flags);\n\n\tengine = intel_engine_lookup_user(i915, (u8)classinstance.engine_class,\n\t\t\t\t\t  (u8)classinstance.engine_instance);\n\n\tif (!engine)\n\t\treturn -EINVAL;\n\n\tif (engine->class != RENDER_CLASS)\n\t\treturn -EINVAL;\n\n\tsseu = &engine->gt->info.sseu;\n\n\treturn fill_topology_info(sseu, query_item, sseu->geometry_subslice_mask);\n}\n\nstatic int\nquery_engine_info(struct drm_i915_private *i915,\n\t\t  struct drm_i915_query_item *query_item)\n{\n\tstruct drm_i915_query_engine_info __user *query_ptr =\n\t\t\t\tu64_to_user_ptr(query_item->data_ptr);\n\tstruct drm_i915_engine_info __user *info_ptr;\n\tstruct drm_i915_query_engine_info query;\n\tstruct drm_i915_engine_info info = { };\n\tunsigned int num_uabi_engines = 0;\n\tstruct intel_engine_cs *engine;\n\tint len, ret;\n\n\tif (query_item->flags)\n\t\treturn -EINVAL;\n\n\tfor_each_uabi_engine(engine, i915)\n\t\tnum_uabi_engines++;\n\n\tlen = struct_size(query_ptr, engines, num_uabi_engines);\n\n\tret = copy_query_item(&query, sizeof(query), len, query_item);\n\tif (ret != 0)\n\t\treturn ret;\n\n\tif (query.num_engines || query.rsvd[0] || query.rsvd[1] ||\n\t    query.rsvd[2])\n\t\treturn -EINVAL;\n\n\tinfo_ptr = &query_ptr->engines[0];\n\n\tfor_each_uabi_engine(engine, i915) {\n\t\tinfo.engine.engine_class = engine->uabi_class;\n\t\tinfo.engine.engine_instance = engine->uabi_instance;\n\t\tinfo.flags = I915_ENGINE_INFO_HAS_LOGICAL_INSTANCE;\n\t\tinfo.capabilities = engine->uabi_capabilities;\n\t\tinfo.logical_instance = ilog2(engine->logical_mask);\n\n\t\tif (copy_to_user(info_ptr, &info, sizeof(info)))\n\t\t\treturn -EFAULT;\n\n\t\tquery.num_engines++;\n\t\tinfo_ptr++;\n\t}\n\n\tif (copy_to_user(query_ptr, &query, sizeof(query)))\n\t\treturn -EFAULT;\n\n\treturn len;\n}\n\nstatic int can_copy_perf_config_registers_or_number(u32 user_n_regs,\n\t\t\t\t\t\t    u64 user_regs_ptr,\n\t\t\t\t\t\t    u32 kernel_n_regs)\n{\n\t \n\tif (user_n_regs == 0)\n\t\treturn 0;\n\n\tif (user_n_regs < kernel_n_regs)\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nstatic int copy_perf_config_registers_or_number(const struct i915_oa_reg *kernel_regs,\n\t\t\t\t\t\tu32 kernel_n_regs,\n\t\t\t\t\t\tu64 user_regs_ptr,\n\t\t\t\t\t\tu32 *user_n_regs)\n{\n\tu32 __user *p = u64_to_user_ptr(user_regs_ptr);\n\tu32 r;\n\n\tif (*user_n_regs == 0) {\n\t\t*user_n_regs = kernel_n_regs;\n\t\treturn 0;\n\t}\n\n\t*user_n_regs = kernel_n_regs;\n\n\tif (!user_write_access_begin(p, 2 * sizeof(u32) * kernel_n_regs))\n\t\treturn -EFAULT;\n\n\tfor (r = 0; r < kernel_n_regs; r++, p += 2) {\n\t\tunsafe_put_user(i915_mmio_reg_offset(kernel_regs[r].addr),\n\t\t\t\tp, Efault);\n\t\tunsafe_put_user(kernel_regs[r].value, p + 1, Efault);\n\t}\n\tuser_write_access_end();\n\treturn 0;\nEfault:\n\tuser_write_access_end();\n\treturn -EFAULT;\n}\n\nstatic int query_perf_config_data(struct drm_i915_private *i915,\n\t\t\t\t  struct drm_i915_query_item *query_item,\n\t\t\t\t  bool use_uuid)\n{\n\tstruct drm_i915_query_perf_config __user *user_query_config_ptr =\n\t\tu64_to_user_ptr(query_item->data_ptr);\n\tstruct drm_i915_perf_oa_config __user *user_config_ptr =\n\t\tu64_to_user_ptr(query_item->data_ptr +\n\t\t\t\tsizeof(struct drm_i915_query_perf_config));\n\tstruct drm_i915_perf_oa_config user_config;\n\tstruct i915_perf *perf = &i915->perf;\n\tstruct i915_oa_config *oa_config;\n\tchar uuid[UUID_STRING_LEN + 1];\n\tu64 config_id;\n\tu32 flags, total_size;\n\tint ret;\n\n\tif (!perf->i915)\n\t\treturn -ENODEV;\n\n\ttotal_size =\n\t\tsizeof(struct drm_i915_query_perf_config) +\n\t\tsizeof(struct drm_i915_perf_oa_config);\n\n\tif (query_item->length == 0)\n\t\treturn total_size;\n\n\tif (query_item->length < total_size) {\n\t\tdrm_dbg(&i915->drm,\n\t\t\t\"Invalid query config data item size=%u expected=%u\\n\",\n\t\t\tquery_item->length, total_size);\n\t\treturn -EINVAL;\n\t}\n\n\tif (get_user(flags, &user_query_config_ptr->flags))\n\t\treturn -EFAULT;\n\n\tif (flags != 0)\n\t\treturn -EINVAL;\n\n\tif (use_uuid) {\n\t\tstruct i915_oa_config *tmp;\n\t\tint id;\n\n\t\tBUILD_BUG_ON(sizeof(user_query_config_ptr->uuid) >= sizeof(uuid));\n\n\t\tmemset(&uuid, 0, sizeof(uuid));\n\t\tif (copy_from_user(uuid, user_query_config_ptr->uuid,\n\t\t\t\t     sizeof(user_query_config_ptr->uuid)))\n\t\t\treturn -EFAULT;\n\n\t\toa_config = NULL;\n\t\trcu_read_lock();\n\t\tidr_for_each_entry(&perf->metrics_idr, tmp, id) {\n\t\t\tif (!strcmp(tmp->uuid, uuid)) {\n\t\t\t\toa_config = i915_oa_config_get(tmp);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\trcu_read_unlock();\n\t} else {\n\t\tif (get_user(config_id, &user_query_config_ptr->config))\n\t\t\treturn -EFAULT;\n\n\t\toa_config = i915_perf_get_oa_config(perf, config_id);\n\t}\n\tif (!oa_config)\n\t\treturn -ENOENT;\n\n\tif (copy_from_user(&user_config, user_config_ptr, sizeof(user_config))) {\n\t\tret = -EFAULT;\n\t\tgoto out;\n\t}\n\n\tret = can_copy_perf_config_registers_or_number(user_config.n_boolean_regs,\n\t\t\t\t\t\t       user_config.boolean_regs_ptr,\n\t\t\t\t\t\t       oa_config->b_counter_regs_len);\n\tif (ret)\n\t\tgoto out;\n\n\tret = can_copy_perf_config_registers_or_number(user_config.n_flex_regs,\n\t\t\t\t\t\t       user_config.flex_regs_ptr,\n\t\t\t\t\t\t       oa_config->flex_regs_len);\n\tif (ret)\n\t\tgoto out;\n\n\tret = can_copy_perf_config_registers_or_number(user_config.n_mux_regs,\n\t\t\t\t\t\t       user_config.mux_regs_ptr,\n\t\t\t\t\t\t       oa_config->mux_regs_len);\n\tif (ret)\n\t\tgoto out;\n\n\tret = copy_perf_config_registers_or_number(oa_config->b_counter_regs,\n\t\t\t\t\t\t   oa_config->b_counter_regs_len,\n\t\t\t\t\t\t   user_config.boolean_regs_ptr,\n\t\t\t\t\t\t   &user_config.n_boolean_regs);\n\tif (ret)\n\t\tgoto out;\n\n\tret = copy_perf_config_registers_or_number(oa_config->flex_regs,\n\t\t\t\t\t\t   oa_config->flex_regs_len,\n\t\t\t\t\t\t   user_config.flex_regs_ptr,\n\t\t\t\t\t\t   &user_config.n_flex_regs);\n\tif (ret)\n\t\tgoto out;\n\n\tret = copy_perf_config_registers_or_number(oa_config->mux_regs,\n\t\t\t\t\t\t   oa_config->mux_regs_len,\n\t\t\t\t\t\t   user_config.mux_regs_ptr,\n\t\t\t\t\t\t   &user_config.n_mux_regs);\n\tif (ret)\n\t\tgoto out;\n\n\tmemcpy(user_config.uuid, oa_config->uuid, sizeof(user_config.uuid));\n\n\tif (copy_to_user(user_config_ptr, &user_config, sizeof(user_config))) {\n\t\tret = -EFAULT;\n\t\tgoto out;\n\t}\n\n\tret = total_size;\n\nout:\n\ti915_oa_config_put(oa_config);\n\treturn ret;\n}\n\nstatic size_t sizeof_perf_config_list(size_t count)\n{\n\treturn sizeof(struct drm_i915_query_perf_config) + sizeof(u64) * count;\n}\n\nstatic size_t sizeof_perf_metrics(struct i915_perf *perf)\n{\n\tstruct i915_oa_config *tmp;\n\tsize_t i;\n\tint id;\n\n\ti = 1;\n\trcu_read_lock();\n\tidr_for_each_entry(&perf->metrics_idr, tmp, id)\n\t\ti++;\n\trcu_read_unlock();\n\n\treturn sizeof_perf_config_list(i);\n}\n\nstatic int query_perf_config_list(struct drm_i915_private *i915,\n\t\t\t\t  struct drm_i915_query_item *query_item)\n{\n\tstruct drm_i915_query_perf_config __user *user_query_config_ptr =\n\t\tu64_to_user_ptr(query_item->data_ptr);\n\tstruct i915_perf *perf = &i915->perf;\n\tu64 *oa_config_ids = NULL;\n\tint alloc, n_configs;\n\tu32 flags;\n\tint ret;\n\n\tif (!perf->i915)\n\t\treturn -ENODEV;\n\n\tif (query_item->length == 0)\n\t\treturn sizeof_perf_metrics(perf);\n\n\tif (get_user(flags, &user_query_config_ptr->flags))\n\t\treturn -EFAULT;\n\n\tif (flags != 0)\n\t\treturn -EINVAL;\n\n\tn_configs = 1;\n\tdo {\n\t\tstruct i915_oa_config *tmp;\n\t\tu64 *ids;\n\t\tint id;\n\n\t\tids = krealloc(oa_config_ids,\n\t\t\t       n_configs * sizeof(*oa_config_ids),\n\t\t\t       GFP_KERNEL);\n\t\tif (!ids)\n\t\t\treturn -ENOMEM;\n\n\t\talloc = fetch_and_zero(&n_configs);\n\n\t\tids[n_configs++] = 1ull;  \n\t\trcu_read_lock();\n\t\tidr_for_each_entry(&perf->metrics_idr, tmp, id) {\n\t\t\tif (n_configs < alloc)\n\t\t\t\tids[n_configs] = id;\n\t\t\tn_configs++;\n\t\t}\n\t\trcu_read_unlock();\n\n\t\toa_config_ids = ids;\n\t} while (n_configs > alloc);\n\n\tif (query_item->length < sizeof_perf_config_list(n_configs)) {\n\t\tdrm_dbg(&i915->drm,\n\t\t\t\"Invalid query config list item size=%u expected=%zu\\n\",\n\t\t\tquery_item->length,\n\t\t\tsizeof_perf_config_list(n_configs));\n\t\tkfree(oa_config_ids);\n\t\treturn -EINVAL;\n\t}\n\n\tif (put_user(n_configs, &user_query_config_ptr->config)) {\n\t\tkfree(oa_config_ids);\n\t\treturn -EFAULT;\n\t}\n\n\tret = copy_to_user(user_query_config_ptr + 1,\n\t\t\t   oa_config_ids,\n\t\t\t   n_configs * sizeof(*oa_config_ids));\n\tkfree(oa_config_ids);\n\tif (ret)\n\t\treturn -EFAULT;\n\n\treturn sizeof_perf_config_list(n_configs);\n}\n\nstatic int query_perf_config(struct drm_i915_private *i915,\n\t\t\t     struct drm_i915_query_item *query_item)\n{\n\tswitch (query_item->flags) {\n\tcase DRM_I915_QUERY_PERF_CONFIG_LIST:\n\t\treturn query_perf_config_list(i915, query_item);\n\tcase DRM_I915_QUERY_PERF_CONFIG_DATA_FOR_UUID:\n\t\treturn query_perf_config_data(i915, query_item, true);\n\tcase DRM_I915_QUERY_PERF_CONFIG_DATA_FOR_ID:\n\t\treturn query_perf_config_data(i915, query_item, false);\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic int query_memregion_info(struct drm_i915_private *i915,\n\t\t\t\tstruct drm_i915_query_item *query_item)\n{\n\tstruct drm_i915_query_memory_regions __user *query_ptr =\n\t\tu64_to_user_ptr(query_item->data_ptr);\n\tstruct drm_i915_memory_region_info __user *info_ptr =\n\t\t&query_ptr->regions[0];\n\tstruct drm_i915_memory_region_info info = { };\n\tstruct drm_i915_query_memory_regions query;\n\tstruct intel_memory_region *mr;\n\tu32 total_length;\n\tint ret, id, i;\n\n\tif (query_item->flags != 0)\n\t\treturn -EINVAL;\n\n\ttotal_length = sizeof(query);\n\tfor_each_memory_region(mr, i915, id) {\n\t\tif (mr->private)\n\t\t\tcontinue;\n\n\t\ttotal_length += sizeof(info);\n\t}\n\n\tret = copy_query_item(&query, sizeof(query), total_length, query_item);\n\tif (ret != 0)\n\t\treturn ret;\n\n\tif (query.num_regions)\n\t\treturn -EINVAL;\n\n\tfor (i = 0; i < ARRAY_SIZE(query.rsvd); i++) {\n\t\tif (query.rsvd[i])\n\t\t\treturn -EINVAL;\n\t}\n\n\tfor_each_memory_region(mr, i915, id) {\n\t\tif (mr->private)\n\t\t\tcontinue;\n\n\t\tinfo.region.memory_class = mr->type;\n\t\tinfo.region.memory_instance = mr->instance;\n\t\tinfo.probed_size = mr->total;\n\n\t\tif (mr->type == INTEL_MEMORY_LOCAL)\n\t\t\tinfo.probed_cpu_visible_size = mr->io_size;\n\t\telse\n\t\t\tinfo.probed_cpu_visible_size = mr->total;\n\n\t\tif (perfmon_capable()) {\n\t\t\tintel_memory_region_avail(mr,\n\t\t\t\t\t\t  &info.unallocated_size,\n\t\t\t\t\t\t  &info.unallocated_cpu_visible_size);\n\t\t} else {\n\t\t\tinfo.unallocated_size = info.probed_size;\n\t\t\tinfo.unallocated_cpu_visible_size =\n\t\t\t\tinfo.probed_cpu_visible_size;\n\t\t}\n\n\t\tif (__copy_to_user(info_ptr, &info, sizeof(info)))\n\t\t\treturn -EFAULT;\n\n\t\tquery.num_regions++;\n\t\tinfo_ptr++;\n\t}\n\n\tif (__copy_to_user(query_ptr, &query, sizeof(query)))\n\t\treturn -EFAULT;\n\n\treturn total_length;\n}\n\nstatic int query_hwconfig_blob(struct drm_i915_private *i915,\n\t\t\t       struct drm_i915_query_item *query_item)\n{\n\tstruct intel_gt *gt = to_gt(i915);\n\tstruct intel_hwconfig *hwconfig = &gt->info.hwconfig;\n\n\tif (!hwconfig->size || !hwconfig->ptr)\n\t\treturn -ENODEV;\n\n\tif (query_item->length == 0)\n\t\treturn hwconfig->size;\n\n\tif (query_item->length < hwconfig->size)\n\t\treturn -EINVAL;\n\n\tif (copy_to_user(u64_to_user_ptr(query_item->data_ptr),\n\t\t\t hwconfig->ptr, hwconfig->size))\n\t\treturn -EFAULT;\n\n\treturn hwconfig->size;\n}\n\nstatic int (* const i915_query_funcs[])(struct drm_i915_private *dev_priv,\n\t\t\t\t\tstruct drm_i915_query_item *query_item) = {\n\tquery_topology_info,\n\tquery_engine_info,\n\tquery_perf_config,\n\tquery_memregion_info,\n\tquery_hwconfig_blob,\n\tquery_geometry_subslices,\n};\n\nint i915_query_ioctl(struct drm_device *dev, void *data, struct drm_file *file)\n{\n\tstruct drm_i915_private *dev_priv = to_i915(dev);\n\tstruct drm_i915_query *args = data;\n\tstruct drm_i915_query_item __user *user_item_ptr =\n\t\tu64_to_user_ptr(args->items_ptr);\n\tu32 i;\n\n\tif (args->flags != 0)\n\t\treturn -EINVAL;\n\n\tfor (i = 0; i < args->num_items; i++, user_item_ptr++) {\n\t\tstruct drm_i915_query_item item;\n\t\tunsigned long func_idx;\n\t\tint ret;\n\n\t\tif (copy_from_user(&item, user_item_ptr, sizeof(item)))\n\t\t\treturn -EFAULT;\n\n\t\tif (item.query_id == 0)\n\t\t\treturn -EINVAL;\n\n\t\tif (overflows_type(item.query_id - 1, unsigned long))\n\t\t\treturn -EINVAL;\n\n\t\tfunc_idx = item.query_id - 1;\n\n\t\tret = -EINVAL;\n\t\tif (func_idx < ARRAY_SIZE(i915_query_funcs)) {\n\t\t\tfunc_idx = array_index_nospec(func_idx,\n\t\t\t\t\t\t      ARRAY_SIZE(i915_query_funcs));\n\t\t\tret = i915_query_funcs[func_idx](dev_priv, &item);\n\t\t}\n\n\t\t \n\t\tif (ret != item.length && put_user(ret, &user_item_ptr->length))\n\t\t\treturn -EFAULT;\n\t}\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}