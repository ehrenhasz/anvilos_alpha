{
  "module_name": "intel_dram.c",
  "hash_id": "f4da7f1015e4a5d6b579e1c029f2929d39a1febc196d799951710a0495569a87",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/i915/soc/intel_dram.c",
  "human_readable_source": "\n \n\n#include <linux/string_helpers.h>\n\n#include \"i915_drv.h\"\n#include \"i915_reg.h\"\n#include \"intel_dram.h\"\n#include \"intel_mchbar_regs.h\"\n#include \"intel_pcode.h\"\n#include \"vlv_sideband.h\"\n\nstruct dram_dimm_info {\n\tu16 size;\n\tu8 width, ranks;\n};\n\nstruct dram_channel_info {\n\tstruct dram_dimm_info dimm_l, dimm_s;\n\tu8 ranks;\n\tbool is_16gb_dimm;\n};\n\n#define DRAM_TYPE_STR(type) [INTEL_DRAM_ ## type] = #type\n\nstatic const char *intel_dram_type_str(enum intel_dram_type type)\n{\n\tstatic const char * const str[] = {\n\t\tDRAM_TYPE_STR(UNKNOWN),\n\t\tDRAM_TYPE_STR(DDR3),\n\t\tDRAM_TYPE_STR(DDR4),\n\t\tDRAM_TYPE_STR(LPDDR3),\n\t\tDRAM_TYPE_STR(LPDDR4),\n\t};\n\n\tif (type >= ARRAY_SIZE(str))\n\t\ttype = INTEL_DRAM_UNKNOWN;\n\n\treturn str[type];\n}\n\n#undef DRAM_TYPE_STR\n\nstatic void pnv_detect_mem_freq(struct drm_i915_private *dev_priv)\n{\n\tu32 tmp;\n\n\ttmp = intel_uncore_read(&dev_priv->uncore, CLKCFG);\n\n\tswitch (tmp & CLKCFG_FSB_MASK) {\n\tcase CLKCFG_FSB_533:\n\t\tdev_priv->fsb_freq = 533;  \n\t\tbreak;\n\tcase CLKCFG_FSB_800:\n\t\tdev_priv->fsb_freq = 800;  \n\t\tbreak;\n\tcase CLKCFG_FSB_667:\n\t\tdev_priv->fsb_freq =  667;  \n\t\tbreak;\n\tcase CLKCFG_FSB_400:\n\t\tdev_priv->fsb_freq = 400;  \n\t\tbreak;\n\t}\n\n\tswitch (tmp & CLKCFG_MEM_MASK) {\n\tcase CLKCFG_MEM_533:\n\t\tdev_priv->mem_freq = 533;\n\t\tbreak;\n\tcase CLKCFG_MEM_667:\n\t\tdev_priv->mem_freq = 667;\n\t\tbreak;\n\tcase CLKCFG_MEM_800:\n\t\tdev_priv->mem_freq = 800;\n\t\tbreak;\n\t}\n\n\t \n\ttmp = intel_uncore_read(&dev_priv->uncore, CSHRDDR3CTL);\n\tdev_priv->is_ddr3 = (tmp & CSHRDDR3CTL_DDR3) ? 1 : 0;\n}\n\nstatic void ilk_detect_mem_freq(struct drm_i915_private *dev_priv)\n{\n\tu16 ddrpll, csipll;\n\n\tddrpll = intel_uncore_read16(&dev_priv->uncore, DDRMPLL1);\n\tswitch (ddrpll & 0xff) {\n\tcase 0xc:\n\t\tdev_priv->mem_freq = 800;\n\t\tbreak;\n\tcase 0x10:\n\t\tdev_priv->mem_freq = 1066;\n\t\tbreak;\n\tcase 0x14:\n\t\tdev_priv->mem_freq = 1333;\n\t\tbreak;\n\tcase 0x18:\n\t\tdev_priv->mem_freq = 1600;\n\t\tbreak;\n\tdefault:\n\t\tdrm_dbg(&dev_priv->drm, \"unknown memory frequency 0x%02x\\n\",\n\t\t\tddrpll & 0xff);\n\t\tdev_priv->mem_freq = 0;\n\t\tbreak;\n\t}\n\n\tcsipll = intel_uncore_read16(&dev_priv->uncore, CSIPLL0);\n\tswitch (csipll & 0x3ff) {\n\tcase 0x00c:\n\t\tdev_priv->fsb_freq = 3200;\n\t\tbreak;\n\tcase 0x00e:\n\t\tdev_priv->fsb_freq = 3733;\n\t\tbreak;\n\tcase 0x010:\n\t\tdev_priv->fsb_freq = 4266;\n\t\tbreak;\n\tcase 0x012:\n\t\tdev_priv->fsb_freq = 4800;\n\t\tbreak;\n\tcase 0x014:\n\t\tdev_priv->fsb_freq = 5333;\n\t\tbreak;\n\tcase 0x016:\n\t\tdev_priv->fsb_freq = 5866;\n\t\tbreak;\n\tcase 0x018:\n\t\tdev_priv->fsb_freq = 6400;\n\t\tbreak;\n\tdefault:\n\t\tdrm_dbg(&dev_priv->drm, \"unknown fsb frequency 0x%04x\\n\",\n\t\t\tcsipll & 0x3ff);\n\t\tdev_priv->fsb_freq = 0;\n\t\tbreak;\n\t}\n}\n\nstatic void chv_detect_mem_freq(struct drm_i915_private *i915)\n{\n\tu32 val;\n\n\tvlv_iosf_sb_get(i915, BIT(VLV_IOSF_SB_CCK));\n\tval = vlv_cck_read(i915, CCK_FUSE_REG);\n\tvlv_iosf_sb_put(i915, BIT(VLV_IOSF_SB_CCK));\n\n\tswitch ((val >> 2) & 0x7) {\n\tcase 3:\n\t\ti915->mem_freq = 2000;\n\t\tbreak;\n\tdefault:\n\t\ti915->mem_freq = 1600;\n\t\tbreak;\n\t}\n}\n\nstatic void vlv_detect_mem_freq(struct drm_i915_private *i915)\n{\n\tu32 val;\n\n\tvlv_iosf_sb_get(i915, BIT(VLV_IOSF_SB_PUNIT));\n\tval = vlv_punit_read(i915, PUNIT_REG_GPU_FREQ_STS);\n\tvlv_iosf_sb_put(i915, BIT(VLV_IOSF_SB_PUNIT));\n\n\tswitch ((val >> 6) & 3) {\n\tcase 0:\n\tcase 1:\n\t\ti915->mem_freq = 800;\n\t\tbreak;\n\tcase 2:\n\t\ti915->mem_freq = 1066;\n\t\tbreak;\n\tcase 3:\n\t\ti915->mem_freq = 1333;\n\t\tbreak;\n\t}\n}\n\nstatic void detect_mem_freq(struct drm_i915_private *i915)\n{\n\tif (IS_PINEVIEW(i915))\n\t\tpnv_detect_mem_freq(i915);\n\telse if (GRAPHICS_VER(i915) == 5)\n\t\tilk_detect_mem_freq(i915);\n\telse if (IS_CHERRYVIEW(i915))\n\t\tchv_detect_mem_freq(i915);\n\telse if (IS_VALLEYVIEW(i915))\n\t\tvlv_detect_mem_freq(i915);\n\n\tif (i915->mem_freq)\n\t\tdrm_dbg(&i915->drm, \"DDR speed: %d MHz\\n\", i915->mem_freq);\n}\n\nstatic int intel_dimm_num_devices(const struct dram_dimm_info *dimm)\n{\n\treturn dimm->ranks * 64 / (dimm->width ?: 1);\n}\n\n \nstatic int skl_get_dimm_size(u16 val)\n{\n\treturn (val & SKL_DRAM_SIZE_MASK) * 8;\n}\n\nstatic int skl_get_dimm_width(u16 val)\n{\n\tif (skl_get_dimm_size(val) == 0)\n\t\treturn 0;\n\n\tswitch (val & SKL_DRAM_WIDTH_MASK) {\n\tcase SKL_DRAM_WIDTH_X8:\n\tcase SKL_DRAM_WIDTH_X16:\n\tcase SKL_DRAM_WIDTH_X32:\n\t\tval = (val & SKL_DRAM_WIDTH_MASK) >> SKL_DRAM_WIDTH_SHIFT;\n\t\treturn 8 << val;\n\tdefault:\n\t\tMISSING_CASE(val);\n\t\treturn 0;\n\t}\n}\n\nstatic int skl_get_dimm_ranks(u16 val)\n{\n\tif (skl_get_dimm_size(val) == 0)\n\t\treturn 0;\n\n\tval = (val & SKL_DRAM_RANK_MASK) >> SKL_DRAM_RANK_SHIFT;\n\n\treturn val + 1;\n}\n\n \nstatic int icl_get_dimm_size(u16 val)\n{\n\treturn (val & ICL_DRAM_SIZE_MASK) * 8 / 2;\n}\n\nstatic int icl_get_dimm_width(u16 val)\n{\n\tif (icl_get_dimm_size(val) == 0)\n\t\treturn 0;\n\n\tswitch (val & ICL_DRAM_WIDTH_MASK) {\n\tcase ICL_DRAM_WIDTH_X8:\n\tcase ICL_DRAM_WIDTH_X16:\n\tcase ICL_DRAM_WIDTH_X32:\n\t\tval = (val & ICL_DRAM_WIDTH_MASK) >> ICL_DRAM_WIDTH_SHIFT;\n\t\treturn 8 << val;\n\tdefault:\n\t\tMISSING_CASE(val);\n\t\treturn 0;\n\t}\n}\n\nstatic int icl_get_dimm_ranks(u16 val)\n{\n\tif (icl_get_dimm_size(val) == 0)\n\t\treturn 0;\n\n\tval = (val & ICL_DRAM_RANK_MASK) >> ICL_DRAM_RANK_SHIFT;\n\n\treturn val + 1;\n}\n\nstatic bool\nskl_is_16gb_dimm(const struct dram_dimm_info *dimm)\n{\n\t \n\treturn dimm->size / (intel_dimm_num_devices(dimm) ?: 1) == 16;\n}\n\nstatic void\nskl_dram_get_dimm_info(struct drm_i915_private *i915,\n\t\t       struct dram_dimm_info *dimm,\n\t\t       int channel, char dimm_name, u16 val)\n{\n\tif (GRAPHICS_VER(i915) >= 11) {\n\t\tdimm->size = icl_get_dimm_size(val);\n\t\tdimm->width = icl_get_dimm_width(val);\n\t\tdimm->ranks = icl_get_dimm_ranks(val);\n\t} else {\n\t\tdimm->size = skl_get_dimm_size(val);\n\t\tdimm->width = skl_get_dimm_width(val);\n\t\tdimm->ranks = skl_get_dimm_ranks(val);\n\t}\n\n\tdrm_dbg_kms(&i915->drm,\n\t\t    \"CH%u DIMM %c size: %u Gb, width: X%u, ranks: %u, 16Gb DIMMs: %s\\n\",\n\t\t    channel, dimm_name, dimm->size, dimm->width, dimm->ranks,\n\t\t    str_yes_no(skl_is_16gb_dimm(dimm)));\n}\n\nstatic int\nskl_dram_get_channel_info(struct drm_i915_private *i915,\n\t\t\t  struct dram_channel_info *ch,\n\t\t\t  int channel, u32 val)\n{\n\tskl_dram_get_dimm_info(i915, &ch->dimm_l,\n\t\t\t       channel, 'L', val & 0xffff);\n\tskl_dram_get_dimm_info(i915, &ch->dimm_s,\n\t\t\t       channel, 'S', val >> 16);\n\n\tif (ch->dimm_l.size == 0 && ch->dimm_s.size == 0) {\n\t\tdrm_dbg_kms(&i915->drm, \"CH%u not populated\\n\", channel);\n\t\treturn -EINVAL;\n\t}\n\n\tif (ch->dimm_l.ranks == 2 || ch->dimm_s.ranks == 2)\n\t\tch->ranks = 2;\n\telse if (ch->dimm_l.ranks == 1 && ch->dimm_s.ranks == 1)\n\t\tch->ranks = 2;\n\telse\n\t\tch->ranks = 1;\n\n\tch->is_16gb_dimm = skl_is_16gb_dimm(&ch->dimm_l) ||\n\t\tskl_is_16gb_dimm(&ch->dimm_s);\n\n\tdrm_dbg_kms(&i915->drm, \"CH%u ranks: %u, 16Gb DIMMs: %s\\n\",\n\t\t    channel, ch->ranks, str_yes_no(ch->is_16gb_dimm));\n\n\treturn 0;\n}\n\nstatic bool\nintel_is_dram_symmetric(const struct dram_channel_info *ch0,\n\t\t\tconst struct dram_channel_info *ch1)\n{\n\treturn !memcmp(ch0, ch1, sizeof(*ch0)) &&\n\t\t(ch0->dimm_s.size == 0 ||\n\t\t !memcmp(&ch0->dimm_l, &ch0->dimm_s, sizeof(ch0->dimm_l)));\n}\n\nstatic int\nskl_dram_get_channels_info(struct drm_i915_private *i915)\n{\n\tstruct dram_info *dram_info = &i915->dram_info;\n\tstruct dram_channel_info ch0 = {}, ch1 = {};\n\tu32 val;\n\tint ret;\n\n\tval = intel_uncore_read(&i915->uncore,\n\t\t\t\tSKL_MAD_DIMM_CH0_0_0_0_MCHBAR_MCMAIN);\n\tret = skl_dram_get_channel_info(i915, &ch0, 0, val);\n\tif (ret == 0)\n\t\tdram_info->num_channels++;\n\n\tval = intel_uncore_read(&i915->uncore,\n\t\t\t\tSKL_MAD_DIMM_CH1_0_0_0_MCHBAR_MCMAIN);\n\tret = skl_dram_get_channel_info(i915, &ch1, 1, val);\n\tif (ret == 0)\n\t\tdram_info->num_channels++;\n\n\tif (dram_info->num_channels == 0) {\n\t\tdrm_info(&i915->drm, \"Number of memory channels is zero\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (ch0.ranks == 0 && ch1.ranks == 0) {\n\t\tdrm_info(&i915->drm, \"couldn't get memory rank information\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tdram_info->wm_lv_0_adjust_needed = ch0.is_16gb_dimm || ch1.is_16gb_dimm;\n\n\tdram_info->symmetric_memory = intel_is_dram_symmetric(&ch0, &ch1);\n\n\tdrm_dbg_kms(&i915->drm, \"Memory configuration is symmetric? %s\\n\",\n\t\t    str_yes_no(dram_info->symmetric_memory));\n\n\treturn 0;\n}\n\nstatic enum intel_dram_type\nskl_get_dram_type(struct drm_i915_private *i915)\n{\n\tu32 val;\n\n\tval = intel_uncore_read(&i915->uncore,\n\t\t\t\tSKL_MAD_INTER_CHANNEL_0_0_0_MCHBAR_MCMAIN);\n\n\tswitch (val & SKL_DRAM_DDR_TYPE_MASK) {\n\tcase SKL_DRAM_DDR_TYPE_DDR3:\n\t\treturn INTEL_DRAM_DDR3;\n\tcase SKL_DRAM_DDR_TYPE_DDR4:\n\t\treturn INTEL_DRAM_DDR4;\n\tcase SKL_DRAM_DDR_TYPE_LPDDR3:\n\t\treturn INTEL_DRAM_LPDDR3;\n\tcase SKL_DRAM_DDR_TYPE_LPDDR4:\n\t\treturn INTEL_DRAM_LPDDR4;\n\tdefault:\n\t\tMISSING_CASE(val);\n\t\treturn INTEL_DRAM_UNKNOWN;\n\t}\n}\n\nstatic int\nskl_get_dram_info(struct drm_i915_private *i915)\n{\n\tstruct dram_info *dram_info = &i915->dram_info;\n\tint ret;\n\n\tdram_info->type = skl_get_dram_type(i915);\n\tdrm_dbg_kms(&i915->drm, \"DRAM type: %s\\n\",\n\t\t    intel_dram_type_str(dram_info->type));\n\n\tret = skl_dram_get_channels_info(i915);\n\tif (ret)\n\t\treturn ret;\n\n\treturn 0;\n}\n\n \nstatic int bxt_get_dimm_size(u32 val)\n{\n\tswitch (val & BXT_DRAM_SIZE_MASK) {\n\tcase BXT_DRAM_SIZE_4GBIT:\n\t\treturn 4;\n\tcase BXT_DRAM_SIZE_6GBIT:\n\t\treturn 6;\n\tcase BXT_DRAM_SIZE_8GBIT:\n\t\treturn 8;\n\tcase BXT_DRAM_SIZE_12GBIT:\n\t\treturn 12;\n\tcase BXT_DRAM_SIZE_16GBIT:\n\t\treturn 16;\n\tdefault:\n\t\tMISSING_CASE(val);\n\t\treturn 0;\n\t}\n}\n\nstatic int bxt_get_dimm_width(u32 val)\n{\n\tif (!bxt_get_dimm_size(val))\n\t\treturn 0;\n\n\tval = (val & BXT_DRAM_WIDTH_MASK) >> BXT_DRAM_WIDTH_SHIFT;\n\n\treturn 8 << val;\n}\n\nstatic int bxt_get_dimm_ranks(u32 val)\n{\n\tif (!bxt_get_dimm_size(val))\n\t\treturn 0;\n\n\tswitch (val & BXT_DRAM_RANK_MASK) {\n\tcase BXT_DRAM_RANK_SINGLE:\n\t\treturn 1;\n\tcase BXT_DRAM_RANK_DUAL:\n\t\treturn 2;\n\tdefault:\n\t\tMISSING_CASE(val);\n\t\treturn 0;\n\t}\n}\n\nstatic enum intel_dram_type bxt_get_dimm_type(u32 val)\n{\n\tif (!bxt_get_dimm_size(val))\n\t\treturn INTEL_DRAM_UNKNOWN;\n\n\tswitch (val & BXT_DRAM_TYPE_MASK) {\n\tcase BXT_DRAM_TYPE_DDR3:\n\t\treturn INTEL_DRAM_DDR3;\n\tcase BXT_DRAM_TYPE_LPDDR3:\n\t\treturn INTEL_DRAM_LPDDR3;\n\tcase BXT_DRAM_TYPE_DDR4:\n\t\treturn INTEL_DRAM_DDR4;\n\tcase BXT_DRAM_TYPE_LPDDR4:\n\t\treturn INTEL_DRAM_LPDDR4;\n\tdefault:\n\t\tMISSING_CASE(val);\n\t\treturn INTEL_DRAM_UNKNOWN;\n\t}\n}\n\nstatic void bxt_get_dimm_info(struct dram_dimm_info *dimm, u32 val)\n{\n\tdimm->width = bxt_get_dimm_width(val);\n\tdimm->ranks = bxt_get_dimm_ranks(val);\n\n\t \n\tdimm->size = bxt_get_dimm_size(val) * intel_dimm_num_devices(dimm);\n}\n\nstatic int bxt_get_dram_info(struct drm_i915_private *i915)\n{\n\tstruct dram_info *dram_info = &i915->dram_info;\n\tu32 val;\n\tu8 valid_ranks = 0;\n\tint i;\n\n\t \n\tfor (i = BXT_D_CR_DRP0_DUNIT_START; i <= BXT_D_CR_DRP0_DUNIT_END; i++) {\n\t\tstruct dram_dimm_info dimm;\n\t\tenum intel_dram_type type;\n\n\t\tval = intel_uncore_read(&i915->uncore, BXT_D_CR_DRP0_DUNIT(i));\n\t\tif (val == 0xFFFFFFFF)\n\t\t\tcontinue;\n\n\t\tdram_info->num_channels++;\n\n\t\tbxt_get_dimm_info(&dimm, val);\n\t\ttype = bxt_get_dimm_type(val);\n\n\t\tdrm_WARN_ON(&i915->drm, type != INTEL_DRAM_UNKNOWN &&\n\t\t\t    dram_info->type != INTEL_DRAM_UNKNOWN &&\n\t\t\t    dram_info->type != type);\n\n\t\tdrm_dbg_kms(&i915->drm,\n\t\t\t    \"CH%u DIMM size: %u Gb, width: X%u, ranks: %u, type: %s\\n\",\n\t\t\t    i - BXT_D_CR_DRP0_DUNIT_START,\n\t\t\t    dimm.size, dimm.width, dimm.ranks,\n\t\t\t    intel_dram_type_str(type));\n\n\t\tif (valid_ranks == 0)\n\t\t\tvalid_ranks = dimm.ranks;\n\n\t\tif (type != INTEL_DRAM_UNKNOWN)\n\t\t\tdram_info->type = type;\n\t}\n\n\tif (dram_info->type == INTEL_DRAM_UNKNOWN || valid_ranks == 0) {\n\t\tdrm_info(&i915->drm, \"couldn't get memory information\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int icl_pcode_read_mem_global_info(struct drm_i915_private *dev_priv)\n{\n\tstruct dram_info *dram_info = &dev_priv->dram_info;\n\tu32 val = 0;\n\tint ret;\n\n\tret = snb_pcode_read(&dev_priv->uncore, ICL_PCODE_MEM_SUBSYSYSTEM_INFO |\n\t\t\t     ICL_PCODE_MEM_SS_READ_GLOBAL_INFO, &val, NULL);\n\tif (ret)\n\t\treturn ret;\n\n\tif (GRAPHICS_VER(dev_priv) == 12) {\n\t\tswitch (val & 0xf) {\n\t\tcase 0:\n\t\t\tdram_info->type = INTEL_DRAM_DDR4;\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tdram_info->type = INTEL_DRAM_DDR5;\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tdram_info->type = INTEL_DRAM_LPDDR5;\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tdram_info->type = INTEL_DRAM_LPDDR4;\n\t\t\tbreak;\n\t\tcase 4:\n\t\t\tdram_info->type = INTEL_DRAM_DDR3;\n\t\t\tbreak;\n\t\tcase 5:\n\t\t\tdram_info->type = INTEL_DRAM_LPDDR3;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tMISSING_CASE(val & 0xf);\n\t\t\treturn -EINVAL;\n\t\t}\n\t} else {\n\t\tswitch (val & 0xf) {\n\t\tcase 0:\n\t\t\tdram_info->type = INTEL_DRAM_DDR4;\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tdram_info->type = INTEL_DRAM_DDR3;\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tdram_info->type = INTEL_DRAM_LPDDR3;\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tdram_info->type = INTEL_DRAM_LPDDR4;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tMISSING_CASE(val & 0xf);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tdram_info->num_channels = (val & 0xf0) >> 4;\n\tdram_info->num_qgv_points = (val & 0xf00) >> 8;\n\tdram_info->num_psf_gv_points = (val & 0x3000) >> 12;\n\n\treturn 0;\n}\n\nstatic int gen11_get_dram_info(struct drm_i915_private *i915)\n{\n\tint ret = skl_get_dram_info(i915);\n\n\tif (ret)\n\t\treturn ret;\n\n\treturn icl_pcode_read_mem_global_info(i915);\n}\n\nstatic int gen12_get_dram_info(struct drm_i915_private *i915)\n{\n\ti915->dram_info.wm_lv_0_adjust_needed = false;\n\n\treturn icl_pcode_read_mem_global_info(i915);\n}\n\nstatic int xelpdp_get_dram_info(struct drm_i915_private *i915)\n{\n\tu32 val = intel_uncore_read(&i915->uncore, MTL_MEM_SS_INFO_GLOBAL);\n\tstruct dram_info *dram_info = &i915->dram_info;\n\n\tswitch (REG_FIELD_GET(MTL_DDR_TYPE_MASK, val)) {\n\tcase 0:\n\t\tdram_info->type = INTEL_DRAM_DDR4;\n\t\tbreak;\n\tcase 1:\n\t\tdram_info->type = INTEL_DRAM_DDR5;\n\t\tbreak;\n\tcase 2:\n\t\tdram_info->type = INTEL_DRAM_LPDDR5;\n\t\tbreak;\n\tcase 3:\n\t\tdram_info->type = INTEL_DRAM_LPDDR4;\n\t\tbreak;\n\tcase 4:\n\t\tdram_info->type = INTEL_DRAM_DDR3;\n\t\tbreak;\n\tcase 5:\n\t\tdram_info->type = INTEL_DRAM_LPDDR3;\n\t\tbreak;\n\tdefault:\n\t\tMISSING_CASE(val);\n\t\treturn -EINVAL;\n\t}\n\n\tdram_info->num_channels = REG_FIELD_GET(MTL_N_OF_POPULATED_CH_MASK, val);\n\tdram_info->num_qgv_points = REG_FIELD_GET(MTL_N_OF_ENABLED_QGV_POINTS_MASK, val);\n\t \n\n\treturn 0;\n}\n\nvoid intel_dram_detect(struct drm_i915_private *i915)\n{\n\tstruct dram_info *dram_info = &i915->dram_info;\n\tint ret;\n\n\tdetect_mem_freq(i915);\n\n\tif (GRAPHICS_VER(i915) < 9 || IS_DG2(i915) || !HAS_DISPLAY(i915))\n\t\treturn;\n\n\t \n\tdram_info->wm_lv_0_adjust_needed = !IS_GEN9_LP(i915);\n\n\tif (DISPLAY_VER(i915) >= 14)\n\t\tret = xelpdp_get_dram_info(i915);\n\telse if (GRAPHICS_VER(i915) >= 12)\n\t\tret = gen12_get_dram_info(i915);\n\telse if (GRAPHICS_VER(i915) >= 11)\n\t\tret = gen11_get_dram_info(i915);\n\telse if (IS_GEN9_LP(i915))\n\t\tret = bxt_get_dram_info(i915);\n\telse\n\t\tret = skl_get_dram_info(i915);\n\tif (ret)\n\t\treturn;\n\n\tdrm_dbg_kms(&i915->drm, \"DRAM channels: %u\\n\", dram_info->num_channels);\n\n\tdrm_dbg_kms(&i915->drm, \"Watermark level 0 adjustment needed: %s\\n\",\n\t\t    str_yes_no(dram_info->wm_lv_0_adjust_needed));\n}\n\nstatic u32 gen9_edram_size_mb(struct drm_i915_private *i915, u32 cap)\n{\n\tstatic const u8 ways[8] = { 4, 8, 12, 16, 16, 16, 16, 16 };\n\tstatic const u8 sets[4] = { 1, 1, 2, 2 };\n\n\treturn EDRAM_NUM_BANKS(cap) *\n\t\tways[EDRAM_WAYS_IDX(cap)] *\n\t\tsets[EDRAM_SETS_IDX(cap)];\n}\n\nvoid intel_dram_edram_detect(struct drm_i915_private *i915)\n{\n\tu32 edram_cap = 0;\n\n\tif (!(IS_HASWELL(i915) || IS_BROADWELL(i915) || GRAPHICS_VER(i915) >= 9))\n\t\treturn;\n\n\tedram_cap = intel_uncore_read_fw(&i915->uncore, HSW_EDRAM_CAP);\n\n\t \n\n\tif (!(edram_cap & EDRAM_ENABLED))\n\t\treturn;\n\n\t \n\tif (GRAPHICS_VER(i915) < 9)\n\t\ti915->edram_size_mb = 128;\n\telse\n\t\ti915->edram_size_mb = gen9_edram_size_mb(i915, edram_cap);\n\n\tdrm_info(&i915->drm, \"Found %uMB of eDRAM\\n\", i915->edram_size_mb);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}