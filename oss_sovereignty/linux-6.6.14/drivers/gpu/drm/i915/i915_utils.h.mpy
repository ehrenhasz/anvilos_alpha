{
  "module_name": "i915_utils.h",
  "hash_id": "f21922203d9d354e95993a6accf0e83066fe6ae5fe4469c4184ca40f09acb5cf",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/i915/i915_utils.h",
  "human_readable_source": " \n\n#ifndef __I915_UTILS_H\n#define __I915_UTILS_H\n\n#include <linux/list.h>\n#include <linux/overflow.h>\n#include <linux/sched.h>\n#include <linux/string_helpers.h>\n#include <linux/types.h>\n#include <linux/workqueue.h>\n#include <linux/sched/clock.h>\n\n#ifdef CONFIG_X86\n#include <asm/hypervisor.h>\n#endif\n\nstruct drm_i915_private;\nstruct timer_list;\n\n#define FDO_BUG_URL \"https://gitlab.freedesktop.org/drm/intel/-/wikis/How-to-file-i915-bugs\"\n\n#define MISSING_CASE(x) WARN(1, \"Missing case (%s == %ld)\\n\", \\\n\t\t\t     __stringify(x), (long)(x))\n\nvoid __printf(3, 4)\n__i915_printk(struct drm_i915_private *dev_priv, const char *level,\n\t      const char *fmt, ...);\n\n#define i915_report_error(dev_priv, fmt, ...)\t\t\t\t   \\\n\t__i915_printk(dev_priv, KERN_ERR, fmt, ##__VA_ARGS__)\n\n#if IS_ENABLED(CONFIG_DRM_I915_DEBUG)\n\nint __i915_inject_probe_error(struct drm_i915_private *i915, int err,\n\t\t\t      const char *func, int line);\n#define i915_inject_probe_error(_i915, _err) \\\n\t__i915_inject_probe_error((_i915), (_err), __func__, __LINE__)\nbool i915_error_injected(void);\n\n#else\n\n#define i915_inject_probe_error(i915, e) ({ BUILD_BUG_ON_INVALID(i915); 0; })\n#define i915_error_injected() false\n\n#endif\n\n#define i915_inject_probe_failure(i915) i915_inject_probe_error((i915), -ENODEV)\n\n#define i915_probe_error(i915, fmt, ...)\t\t\t\t   \\\n\t__i915_printk(i915, i915_error_injected() ? KERN_DEBUG : KERN_ERR, \\\n\t\t      fmt, ##__VA_ARGS__)\n\n#if defined(GCC_VERSION) && GCC_VERSION >= 70000\n#define add_overflows_t(T, A, B) \\\n\t__builtin_add_overflow_p((A), (B), (T)0)\n#else\n#define add_overflows_t(T, A, B) ({ \\\n\ttypeof(A) a = (A); \\\n\ttypeof(B) b = (B); \\\n\t(T)(a + b) < a; \\\n})\n#endif\n\n#define add_overflows(A, B) \\\n\tadd_overflows_t(typeof((A) + (B)), (A), (B))\n\n#define range_overflows(start, size, max) ({ \\\n\ttypeof(start) start__ = (start); \\\n\ttypeof(size) size__ = (size); \\\n\ttypeof(max) max__ = (max); \\\n\t(void)(&start__ == &size__); \\\n\t(void)(&start__ == &max__); \\\n\tstart__ >= max__ || size__ > max__ - start__; \\\n})\n\n#define range_overflows_t(type, start, size, max) \\\n\trange_overflows((type)(start), (type)(size), (type)(max))\n\n#define range_overflows_end(start, size, max) ({ \\\n\ttypeof(start) start__ = (start); \\\n\ttypeof(size) size__ = (size); \\\n\ttypeof(max) max__ = (max); \\\n\t(void)(&start__ == &size__); \\\n\t(void)(&start__ == &max__); \\\n\tstart__ > max__ || size__ > max__ - start__; \\\n})\n\n#define range_overflows_end_t(type, start, size, max) \\\n\trange_overflows_end((type)(start), (type)(size), (type)(max))\n\n#define ptr_mask_bits(ptr, n) ({\t\t\t\t\t\\\n\tunsigned long __v = (unsigned long)(ptr);\t\t\t\\\n\t(typeof(ptr))(__v & -BIT(n));\t\t\t\t\t\\\n})\n\n#define ptr_unmask_bits(ptr, n) ((unsigned long)(ptr) & (BIT(n) - 1))\n\n#define ptr_unpack_bits(ptr, bits, n) ({\t\t\t\t\\\n\tunsigned long __v = (unsigned long)(ptr);\t\t\t\\\n\t*(bits) = __v & (BIT(n) - 1);\t\t\t\t\t\\\n\t(typeof(ptr))(__v & -BIT(n));\t\t\t\t\t\\\n})\n\n#define ptr_pack_bits(ptr, bits, n) ({\t\t\t\t\t\\\n\tunsigned long __bits = (bits);\t\t\t\t\t\\\n\tGEM_BUG_ON(__bits & -BIT(n));\t\t\t\t\t\\\n\t((typeof(ptr))((unsigned long)(ptr) | __bits));\t\t\t\\\n})\n\n#define ptr_dec(ptr) ({\t\t\t\t\t\t\t\\\n\tunsigned long __v = (unsigned long)(ptr);\t\t\t\\\n\t(typeof(ptr))(__v - 1);\t\t\t\t\t\t\\\n})\n\n#define ptr_inc(ptr) ({\t\t\t\t\t\t\t\\\n\tunsigned long __v = (unsigned long)(ptr);\t\t\t\\\n\t(typeof(ptr))(__v + 1);\t\t\t\t\t\t\\\n})\n\n#define page_mask_bits(ptr) ptr_mask_bits(ptr, PAGE_SHIFT)\n#define page_unmask_bits(ptr) ptr_unmask_bits(ptr, PAGE_SHIFT)\n#define page_pack_bits(ptr, bits) ptr_pack_bits(ptr, bits, PAGE_SHIFT)\n#define page_unpack_bits(ptr, bits) ptr_unpack_bits(ptr, bits, PAGE_SHIFT)\n\n#define fetch_and_zero(ptr) ({\t\t\t\t\t\t\\\n\ttypeof(*ptr) __T = *(ptr);\t\t\t\t\t\\\n\t*(ptr) = (typeof(*ptr))0;\t\t\t\t\t\\\n\t__T;\t\t\t\t\t\t\t\t\\\n})\n\nstatic __always_inline ptrdiff_t ptrdiff(const void *a, const void *b)\n{\n\treturn a - b;\n}\n\n \n#define container_of_user(ptr, type, member) ({\t\t\t\t\\\n\tvoid __user *__mptr = (void __user *)(ptr);\t\t\t\\\n\tBUILD_BUG_ON_MSG(!__same_type(*(ptr), typeof_member(type, member)) && \\\n\t\t\t !__same_type(*(ptr), void),\t\t\t\\\n\t\t\t \"pointer type mismatch in container_of()\");\t\\\n\t((type __user *)(__mptr - offsetof(type, member))); })\n\n \n#define check_user_mbz(U) ({\t\t\t\t\t\t\\\n\ttypeof(*(U)) mbz__;\t\t\t\t\t\t\\\n\tget_user(mbz__, (U)) ? -EFAULT : mbz__ ? -EINVAL : 0;\t\t\\\n})\n\n#define u64_to_ptr(T, x) ({\t\t\t\t\t\t\\\n\ttypecheck(u64, x);\t\t\t\t\t\t\\\n\t(T *)(uintptr_t)(x);\t\t\t\t\t\t\\\n})\n\n#define __mask_next_bit(mask) ({\t\t\t\t\t\\\n\tint __idx = ffs(mask) - 1;\t\t\t\t\t\\\n\tmask &= ~BIT(__idx);\t\t\t\t\t\t\\\n\t__idx;\t\t\t\t\t\t\t\t\\\n})\n\nstatic inline bool is_power_of_2_u64(u64 n)\n{\n\treturn (n != 0 && ((n & (n - 1)) == 0));\n}\n\nstatic inline void __list_del_many(struct list_head *head,\n\t\t\t\t   struct list_head *first)\n{\n\tfirst->prev = head;\n\tWRITE_ONCE(head->next, first);\n}\n\nstatic inline int list_is_last_rcu(const struct list_head *list,\n\t\t\t\t   const struct list_head *head)\n{\n\treturn READ_ONCE(list->next) == head;\n}\n\nstatic inline unsigned long msecs_to_jiffies_timeout(const unsigned int m)\n{\n\tunsigned long j = msecs_to_jiffies(m);\n\n\treturn min_t(unsigned long, MAX_JIFFY_OFFSET, j + 1);\n}\n\n \nstatic inline void\nwait_remaining_ms_from_jiffies(unsigned long timestamp_jiffies, int to_wait_ms)\n{\n\tunsigned long target_jiffies, tmp_jiffies, remaining_jiffies;\n\n\t \n\ttmp_jiffies = jiffies;\n\ttarget_jiffies = timestamp_jiffies +\n\t\t\t msecs_to_jiffies_timeout(to_wait_ms);\n\n\tif (time_after(target_jiffies, tmp_jiffies)) {\n\t\tremaining_jiffies = target_jiffies - tmp_jiffies;\n\t\twhile (remaining_jiffies)\n\t\t\tremaining_jiffies =\n\t\t\t    schedule_timeout_uninterruptible(remaining_jiffies);\n\t}\n}\n\n \n#define __wait_for(OP, COND, US, Wmin, Wmax) ({ \\\n\tconst ktime_t end__ = ktime_add_ns(ktime_get_raw(), 1000ll * (US)); \\\n\tlong wait__ = (Wmin);  \t\\\n\tint ret__;\t\t\t\t\t\t\t\\\n\tmight_sleep();\t\t\t\t\t\t\t\\\n\tfor (;;) {\t\t\t\t\t\t\t\\\n\t\tconst bool expired__ = ktime_after(ktime_get_raw(), end__); \\\n\t\tOP;\t\t\t\t\t\t\t\\\n\t\t \t\t\\\n\t\tbarrier();\t\t\t\t\t\t\\\n\t\tif (COND) {\t\t\t\t\t\t\\\n\t\t\tret__ = 0;\t\t\t\t\t\\\n\t\t\tbreak;\t\t\t\t\t\t\\\n\t\t}\t\t\t\t\t\t\t\\\n\t\tif (expired__) {\t\t\t\t\t\\\n\t\t\tret__ = -ETIMEDOUT;\t\t\t\t\\\n\t\t\tbreak;\t\t\t\t\t\t\\\n\t\t}\t\t\t\t\t\t\t\\\n\t\tusleep_range(wait__, wait__ * 2);\t\t\t\\\n\t\tif (wait__ < (Wmax))\t\t\t\t\t\\\n\t\t\twait__ <<= 1;\t\t\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\\\n\tret__;\t\t\t\t\t\t\t\t\\\n})\n\n#define _wait_for(COND, US, Wmin, Wmax)\t__wait_for(, (COND), (US), (Wmin), \\\n\t\t\t\t\t\t   (Wmax))\n#define wait_for(COND, MS)\t\t_wait_for((COND), (MS) * 1000, 10, 1000)\n\n \n#if defined(CONFIG_DRM_I915_DEBUG) && defined(CONFIG_PREEMPT_COUNT)\n# define _WAIT_FOR_ATOMIC_CHECK(ATOMIC) WARN_ON_ONCE((ATOMIC) && !in_atomic())\n#else\n# define _WAIT_FOR_ATOMIC_CHECK(ATOMIC) do { } while (0)\n#endif\n\n#define _wait_for_atomic(COND, US, ATOMIC) \\\n({ \\\n\tint cpu, ret, timeout = (US) * 1000; \\\n\tu64 base; \\\n\t_WAIT_FOR_ATOMIC_CHECK(ATOMIC); \\\n\tif (!(ATOMIC)) { \\\n\t\tpreempt_disable(); \\\n\t\tcpu = smp_processor_id(); \\\n\t} \\\n\tbase = local_clock(); \\\n\tfor (;;) { \\\n\t\tu64 now = local_clock(); \\\n\t\tif (!(ATOMIC)) \\\n\t\t\tpreempt_enable(); \\\n\t\t  \\\n\t\tbarrier(); \\\n\t\tif (COND) { \\\n\t\t\tret = 0; \\\n\t\t\tbreak; \\\n\t\t} \\\n\t\tif (now - base >= timeout) { \\\n\t\t\tret = -ETIMEDOUT; \\\n\t\t\tbreak; \\\n\t\t} \\\n\t\tcpu_relax(); \\\n\t\tif (!(ATOMIC)) { \\\n\t\t\tpreempt_disable(); \\\n\t\t\tif (unlikely(cpu != smp_processor_id())) { \\\n\t\t\t\ttimeout -= now - base; \\\n\t\t\t\tcpu = smp_processor_id(); \\\n\t\t\t\tbase = local_clock(); \\\n\t\t\t} \\\n\t\t} \\\n\t} \\\n\tret; \\\n})\n\n#define wait_for_us(COND, US) \\\n({ \\\n\tint ret__; \\\n\tBUILD_BUG_ON(!__builtin_constant_p(US)); \\\n\tif ((US) > 10) \\\n\t\tret__ = _wait_for((COND), (US), 10, 10); \\\n\telse \\\n\t\tret__ = _wait_for_atomic((COND), (US), 0); \\\n\tret__; \\\n})\n\n#define wait_for_atomic_us(COND, US) \\\n({ \\\n\tBUILD_BUG_ON(!__builtin_constant_p(US)); \\\n\tBUILD_BUG_ON((US) > 50000); \\\n\t_wait_for_atomic((COND), (US), 1); \\\n})\n\n#define wait_for_atomic(COND, MS) wait_for_atomic_us((COND), (MS) * 1000)\n\n#define KHz(x) (1000 * (x))\n#define MHz(x) KHz(1000 * (x))\n\nvoid add_taint_for_CI(struct drm_i915_private *i915, unsigned int taint);\nstatic inline void __add_taint_for_CI(unsigned int taint)\n{\n\t \n\tadd_taint(taint, LOCKDEP_STILL_OK);\n}\n\nvoid cancel_timer(struct timer_list *t);\nvoid set_timer_ms(struct timer_list *t, unsigned long timeout);\n\nstatic inline bool timer_active(const struct timer_list *t)\n{\n\treturn READ_ONCE(t->expires);\n}\n\nstatic inline bool timer_expired(const struct timer_list *t)\n{\n\treturn timer_active(t) && !timer_pending(t);\n}\n\nstatic inline bool i915_run_as_guest(void)\n{\n#if IS_ENABLED(CONFIG_X86)\n\treturn !hypervisor_is_type(X86_HYPER_NATIVE);\n#else\n\t \n\treturn false;\n#endif\n}\n\nbool i915_vtd_active(struct drm_i915_private *i915);\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}