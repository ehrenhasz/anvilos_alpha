{
  "module_name": "i915_irq.c",
  "hash_id": "cfa900644792397910dac0f95e16c6fefbbcf8f6854d9f3f62ffec4f9b7290a4",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/i915/i915_irq.c",
  "human_readable_source": " \n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/slab.h>\n#include <linux/sysrq.h>\n\n#include <drm/drm_drv.h>\n\n#include \"display/intel_display_irq.h\"\n#include \"display/intel_display_types.h\"\n#include \"display/intel_hotplug.h\"\n#include \"display/intel_hotplug_irq.h\"\n#include \"display/intel_lpe_audio.h\"\n#include \"display/intel_psr_regs.h\"\n\n#include \"gt/intel_breadcrumbs.h\"\n#include \"gt/intel_gt.h\"\n#include \"gt/intel_gt_irq.h\"\n#include \"gt/intel_gt_pm_irq.h\"\n#include \"gt/intel_gt_regs.h\"\n#include \"gt/intel_rps.h\"\n\n#include \"i915_driver.h\"\n#include \"i915_drv.h\"\n#include \"i915_irq.h\"\n#include \"i915_reg.h\"\n\n \n\n \nstatic inline void pmu_irq_stats(struct drm_i915_private *i915,\n\t\t\t\t irqreturn_t res)\n{\n\tif (unlikely(res != IRQ_HANDLED))\n\t\treturn;\n\n\t \n\tWRITE_ONCE(i915->pmu.irq_count, i915->pmu.irq_count + 1);\n}\n\nvoid gen3_irq_reset(struct intel_uncore *uncore, i915_reg_t imr,\n\t\t    i915_reg_t iir, i915_reg_t ier)\n{\n\tintel_uncore_write(uncore, imr, 0xffffffff);\n\tintel_uncore_posting_read(uncore, imr);\n\n\tintel_uncore_write(uncore, ier, 0);\n\n\t \n\tintel_uncore_write(uncore, iir, 0xffffffff);\n\tintel_uncore_posting_read(uncore, iir);\n\tintel_uncore_write(uncore, iir, 0xffffffff);\n\tintel_uncore_posting_read(uncore, iir);\n}\n\nstatic void gen2_irq_reset(struct intel_uncore *uncore)\n{\n\tintel_uncore_write16(uncore, GEN2_IMR, 0xffff);\n\tintel_uncore_posting_read16(uncore, GEN2_IMR);\n\n\tintel_uncore_write16(uncore, GEN2_IER, 0);\n\n\t \n\tintel_uncore_write16(uncore, GEN2_IIR, 0xffff);\n\tintel_uncore_posting_read16(uncore, GEN2_IIR);\n\tintel_uncore_write16(uncore, GEN2_IIR, 0xffff);\n\tintel_uncore_posting_read16(uncore, GEN2_IIR);\n}\n\n \nvoid gen3_assert_iir_is_zero(struct intel_uncore *uncore, i915_reg_t reg)\n{\n\tu32 val = intel_uncore_read(uncore, reg);\n\n\tif (val == 0)\n\t\treturn;\n\n\tdrm_WARN(&uncore->i915->drm, 1,\n\t\t \"Interrupt register 0x%x is not zero: 0x%08x\\n\",\n\t\t i915_mmio_reg_offset(reg), val);\n\tintel_uncore_write(uncore, reg, 0xffffffff);\n\tintel_uncore_posting_read(uncore, reg);\n\tintel_uncore_write(uncore, reg, 0xffffffff);\n\tintel_uncore_posting_read(uncore, reg);\n}\n\nstatic void gen2_assert_iir_is_zero(struct intel_uncore *uncore)\n{\n\tu16 val = intel_uncore_read16(uncore, GEN2_IIR);\n\n\tif (val == 0)\n\t\treturn;\n\n\tdrm_WARN(&uncore->i915->drm, 1,\n\t\t \"Interrupt register 0x%x is not zero: 0x%08x\\n\",\n\t\t i915_mmio_reg_offset(GEN2_IIR), val);\n\tintel_uncore_write16(uncore, GEN2_IIR, 0xffff);\n\tintel_uncore_posting_read16(uncore, GEN2_IIR);\n\tintel_uncore_write16(uncore, GEN2_IIR, 0xffff);\n\tintel_uncore_posting_read16(uncore, GEN2_IIR);\n}\n\nvoid gen3_irq_init(struct intel_uncore *uncore,\n\t\t   i915_reg_t imr, u32 imr_val,\n\t\t   i915_reg_t ier, u32 ier_val,\n\t\t   i915_reg_t iir)\n{\n\tgen3_assert_iir_is_zero(uncore, iir);\n\n\tintel_uncore_write(uncore, ier, ier_val);\n\tintel_uncore_write(uncore, imr, imr_val);\n\tintel_uncore_posting_read(uncore, imr);\n}\n\nstatic void gen2_irq_init(struct intel_uncore *uncore,\n\t\t\t  u32 imr_val, u32 ier_val)\n{\n\tgen2_assert_iir_is_zero(uncore);\n\n\tintel_uncore_write16(uncore, GEN2_IER, ier_val);\n\tintel_uncore_write16(uncore, GEN2_IMR, imr_val);\n\tintel_uncore_posting_read16(uncore, GEN2_IMR);\n}\n\n \nstatic void ivb_parity_work(struct work_struct *work)\n{\n\tstruct drm_i915_private *dev_priv =\n\t\tcontainer_of(work, typeof(*dev_priv), l3_parity.error_work);\n\tstruct intel_gt *gt = to_gt(dev_priv);\n\tu32 error_status, row, bank, subbank;\n\tchar *parity_event[6];\n\tu32 misccpctl;\n\tu8 slice = 0;\n\n\t \n\tmutex_lock(&dev_priv->drm.struct_mutex);\n\n\t \n\tif (drm_WARN_ON(&dev_priv->drm, !dev_priv->l3_parity.which_slice))\n\t\tgoto out;\n\n\tmisccpctl = intel_uncore_rmw(&dev_priv->uncore, GEN7_MISCCPCTL,\n\t\t\t\t     GEN7_DOP_CLOCK_GATE_ENABLE, 0);\n\tintel_uncore_posting_read(&dev_priv->uncore, GEN7_MISCCPCTL);\n\n\twhile ((slice = ffs(dev_priv->l3_parity.which_slice)) != 0) {\n\t\ti915_reg_t reg;\n\n\t\tslice--;\n\t\tif (drm_WARN_ON_ONCE(&dev_priv->drm,\n\t\t\t\t     slice >= NUM_L3_SLICES(dev_priv)))\n\t\t\tbreak;\n\n\t\tdev_priv->l3_parity.which_slice &= ~(1<<slice);\n\n\t\treg = GEN7_L3CDERRST1(slice);\n\n\t\terror_status = intel_uncore_read(&dev_priv->uncore, reg);\n\t\trow = GEN7_PARITY_ERROR_ROW(error_status);\n\t\tbank = GEN7_PARITY_ERROR_BANK(error_status);\n\t\tsubbank = GEN7_PARITY_ERROR_SUBBANK(error_status);\n\n\t\tintel_uncore_write(&dev_priv->uncore, reg, GEN7_PARITY_ERROR_VALID | GEN7_L3CDERRST1_ENABLE);\n\t\tintel_uncore_posting_read(&dev_priv->uncore, reg);\n\n\t\tparity_event[0] = I915_L3_PARITY_UEVENT \"=1\";\n\t\tparity_event[1] = kasprintf(GFP_KERNEL, \"ROW=%d\", row);\n\t\tparity_event[2] = kasprintf(GFP_KERNEL, \"BANK=%d\", bank);\n\t\tparity_event[3] = kasprintf(GFP_KERNEL, \"SUBBANK=%d\", subbank);\n\t\tparity_event[4] = kasprintf(GFP_KERNEL, \"SLICE=%d\", slice);\n\t\tparity_event[5] = NULL;\n\n\t\tkobject_uevent_env(&dev_priv->drm.primary->kdev->kobj,\n\t\t\t\t   KOBJ_CHANGE, parity_event);\n\n\t\tdrm_dbg(&dev_priv->drm,\n\t\t\t\"Parity error: Slice = %d, Row = %d, Bank = %d, Sub bank = %d.\\n\",\n\t\t\tslice, row, bank, subbank);\n\n\t\tkfree(parity_event[4]);\n\t\tkfree(parity_event[3]);\n\t\tkfree(parity_event[2]);\n\t\tkfree(parity_event[1]);\n\t}\n\n\tintel_uncore_write(&dev_priv->uncore, GEN7_MISCCPCTL, misccpctl);\n\nout:\n\tdrm_WARN_ON(&dev_priv->drm, dev_priv->l3_parity.which_slice);\n\tspin_lock_irq(gt->irq_lock);\n\tgen5_gt_enable_irq(gt, GT_PARITY_ERROR(dev_priv));\n\tspin_unlock_irq(gt->irq_lock);\n\n\tmutex_unlock(&dev_priv->drm.struct_mutex);\n}\n\nstatic irqreturn_t valleyview_irq_handler(int irq, void *arg)\n{\n\tstruct drm_i915_private *dev_priv = arg;\n\tirqreturn_t ret = IRQ_NONE;\n\n\tif (!intel_irqs_enabled(dev_priv))\n\t\treturn IRQ_NONE;\n\n\t \n\tdisable_rpm_wakeref_asserts(&dev_priv->runtime_pm);\n\n\tdo {\n\t\tu32 iir, gt_iir, pm_iir;\n\t\tu32 pipe_stats[I915_MAX_PIPES] = {};\n\t\tu32 hotplug_status = 0;\n\t\tu32 ier = 0;\n\n\t\tgt_iir = intel_uncore_read(&dev_priv->uncore, GTIIR);\n\t\tpm_iir = intel_uncore_read(&dev_priv->uncore, GEN6_PMIIR);\n\t\tiir = intel_uncore_read(&dev_priv->uncore, VLV_IIR);\n\n\t\tif (gt_iir == 0 && pm_iir == 0 && iir == 0)\n\t\t\tbreak;\n\n\t\tret = IRQ_HANDLED;\n\n\t\t \n\t\tintel_uncore_write(&dev_priv->uncore, VLV_MASTER_IER, 0);\n\t\tier = intel_uncore_rmw(&dev_priv->uncore, VLV_IER, ~0, 0);\n\n\t\tif (gt_iir)\n\t\t\tintel_uncore_write(&dev_priv->uncore, GTIIR, gt_iir);\n\t\tif (pm_iir)\n\t\t\tintel_uncore_write(&dev_priv->uncore, GEN6_PMIIR, pm_iir);\n\n\t\tif (iir & I915_DISPLAY_PORT_INTERRUPT)\n\t\t\thotplug_status = i9xx_hpd_irq_ack(dev_priv);\n\n\t\t \n\t\ti9xx_pipestat_irq_ack(dev_priv, iir, pipe_stats);\n\n\t\tif (iir & (I915_LPE_PIPE_A_INTERRUPT |\n\t\t\t   I915_LPE_PIPE_B_INTERRUPT))\n\t\t\tintel_lpe_audio_irq_handler(dev_priv);\n\n\t\t \n\t\tif (iir)\n\t\t\tintel_uncore_write(&dev_priv->uncore, VLV_IIR, iir);\n\n\t\tintel_uncore_write(&dev_priv->uncore, VLV_IER, ier);\n\t\tintel_uncore_write(&dev_priv->uncore, VLV_MASTER_IER, MASTER_INTERRUPT_ENABLE);\n\n\t\tif (gt_iir)\n\t\t\tgen6_gt_irq_handler(to_gt(dev_priv), gt_iir);\n\t\tif (pm_iir)\n\t\t\tgen6_rps_irq_handler(&to_gt(dev_priv)->rps, pm_iir);\n\n\t\tif (hotplug_status)\n\t\t\ti9xx_hpd_irq_handler(dev_priv, hotplug_status);\n\n\t\tvalleyview_pipestat_irq_handler(dev_priv, pipe_stats);\n\t} while (0);\n\n\tpmu_irq_stats(dev_priv, ret);\n\n\tenable_rpm_wakeref_asserts(&dev_priv->runtime_pm);\n\n\treturn ret;\n}\n\nstatic irqreturn_t cherryview_irq_handler(int irq, void *arg)\n{\n\tstruct drm_i915_private *dev_priv = arg;\n\tirqreturn_t ret = IRQ_NONE;\n\n\tif (!intel_irqs_enabled(dev_priv))\n\t\treturn IRQ_NONE;\n\n\t \n\tdisable_rpm_wakeref_asserts(&dev_priv->runtime_pm);\n\n\tdo {\n\t\tu32 master_ctl, iir;\n\t\tu32 pipe_stats[I915_MAX_PIPES] = {};\n\t\tu32 hotplug_status = 0;\n\t\tu32 ier = 0;\n\n\t\tmaster_ctl = intel_uncore_read(&dev_priv->uncore, GEN8_MASTER_IRQ) & ~GEN8_MASTER_IRQ_CONTROL;\n\t\tiir = intel_uncore_read(&dev_priv->uncore, VLV_IIR);\n\n\t\tif (master_ctl == 0 && iir == 0)\n\t\t\tbreak;\n\n\t\tret = IRQ_HANDLED;\n\n\t\t \n\t\tintel_uncore_write(&dev_priv->uncore, GEN8_MASTER_IRQ, 0);\n\t\tier = intel_uncore_rmw(&dev_priv->uncore, VLV_IER, ~0, 0);\n\n\t\tgen8_gt_irq_handler(to_gt(dev_priv), master_ctl);\n\n\t\tif (iir & I915_DISPLAY_PORT_INTERRUPT)\n\t\t\thotplug_status = i9xx_hpd_irq_ack(dev_priv);\n\n\t\t \n\t\ti9xx_pipestat_irq_ack(dev_priv, iir, pipe_stats);\n\n\t\tif (iir & (I915_LPE_PIPE_A_INTERRUPT |\n\t\t\t   I915_LPE_PIPE_B_INTERRUPT |\n\t\t\t   I915_LPE_PIPE_C_INTERRUPT))\n\t\t\tintel_lpe_audio_irq_handler(dev_priv);\n\n\t\t \n\t\tif (iir)\n\t\t\tintel_uncore_write(&dev_priv->uncore, VLV_IIR, iir);\n\n\t\tintel_uncore_write(&dev_priv->uncore, VLV_IER, ier);\n\t\tintel_uncore_write(&dev_priv->uncore, GEN8_MASTER_IRQ, GEN8_MASTER_IRQ_CONTROL);\n\n\t\tif (hotplug_status)\n\t\t\ti9xx_hpd_irq_handler(dev_priv, hotplug_status);\n\n\t\tvalleyview_pipestat_irq_handler(dev_priv, pipe_stats);\n\t} while (0);\n\n\tpmu_irq_stats(dev_priv, ret);\n\n\tenable_rpm_wakeref_asserts(&dev_priv->runtime_pm);\n\n\treturn ret;\n}\n\n \nstatic irqreturn_t ilk_irq_handler(int irq, void *arg)\n{\n\tstruct drm_i915_private *i915 = arg;\n\tvoid __iomem * const regs = intel_uncore_regs(&i915->uncore);\n\tu32 de_iir, gt_iir, de_ier, sde_ier = 0;\n\tirqreturn_t ret = IRQ_NONE;\n\n\tif (unlikely(!intel_irqs_enabled(i915)))\n\t\treturn IRQ_NONE;\n\n\t \n\tdisable_rpm_wakeref_asserts(&i915->runtime_pm);\n\n\t \n\tde_ier = raw_reg_read(regs, DEIER);\n\traw_reg_write(regs, DEIER, de_ier & ~DE_MASTER_IRQ_CONTROL);\n\n\t \n\tif (!HAS_PCH_NOP(i915)) {\n\t\tsde_ier = raw_reg_read(regs, SDEIER);\n\t\traw_reg_write(regs, SDEIER, 0);\n\t}\n\n\t \n\n\tgt_iir = raw_reg_read(regs, GTIIR);\n\tif (gt_iir) {\n\t\traw_reg_write(regs, GTIIR, gt_iir);\n\t\tif (GRAPHICS_VER(i915) >= 6)\n\t\t\tgen6_gt_irq_handler(to_gt(i915), gt_iir);\n\t\telse\n\t\t\tgen5_gt_irq_handler(to_gt(i915), gt_iir);\n\t\tret = IRQ_HANDLED;\n\t}\n\n\tde_iir = raw_reg_read(regs, DEIIR);\n\tif (de_iir) {\n\t\traw_reg_write(regs, DEIIR, de_iir);\n\t\tif (DISPLAY_VER(i915) >= 7)\n\t\t\tivb_display_irq_handler(i915, de_iir);\n\t\telse\n\t\t\tilk_display_irq_handler(i915, de_iir);\n\t\tret = IRQ_HANDLED;\n\t}\n\n\tif (GRAPHICS_VER(i915) >= 6) {\n\t\tu32 pm_iir = raw_reg_read(regs, GEN6_PMIIR);\n\t\tif (pm_iir) {\n\t\t\traw_reg_write(regs, GEN6_PMIIR, pm_iir);\n\t\t\tgen6_rps_irq_handler(&to_gt(i915)->rps, pm_iir);\n\t\t\tret = IRQ_HANDLED;\n\t\t}\n\t}\n\n\traw_reg_write(regs, DEIER, de_ier);\n\tif (sde_ier)\n\t\traw_reg_write(regs, SDEIER, sde_ier);\n\n\tpmu_irq_stats(i915, ret);\n\n\t \n\tenable_rpm_wakeref_asserts(&i915->runtime_pm);\n\n\treturn ret;\n}\n\nstatic inline u32 gen8_master_intr_disable(void __iomem * const regs)\n{\n\traw_reg_write(regs, GEN8_MASTER_IRQ, 0);\n\n\t \n\treturn raw_reg_read(regs, GEN8_MASTER_IRQ);\n}\n\nstatic inline void gen8_master_intr_enable(void __iomem * const regs)\n{\n\traw_reg_write(regs, GEN8_MASTER_IRQ, GEN8_MASTER_IRQ_CONTROL);\n}\n\nstatic irqreturn_t gen8_irq_handler(int irq, void *arg)\n{\n\tstruct drm_i915_private *dev_priv = arg;\n\tvoid __iomem * const regs = intel_uncore_regs(&dev_priv->uncore);\n\tu32 master_ctl;\n\n\tif (!intel_irqs_enabled(dev_priv))\n\t\treturn IRQ_NONE;\n\n\tmaster_ctl = gen8_master_intr_disable(regs);\n\tif (!master_ctl) {\n\t\tgen8_master_intr_enable(regs);\n\t\treturn IRQ_NONE;\n\t}\n\n\t \n\tgen8_gt_irq_handler(to_gt(dev_priv), master_ctl);\n\n\t \n\tif (master_ctl & ~GEN8_GT_IRQS) {\n\t\tdisable_rpm_wakeref_asserts(&dev_priv->runtime_pm);\n\t\tgen8_de_irq_handler(dev_priv, master_ctl);\n\t\tenable_rpm_wakeref_asserts(&dev_priv->runtime_pm);\n\t}\n\n\tgen8_master_intr_enable(regs);\n\n\tpmu_irq_stats(dev_priv, IRQ_HANDLED);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic inline u32 gen11_master_intr_disable(void __iomem * const regs)\n{\n\traw_reg_write(regs, GEN11_GFX_MSTR_IRQ, 0);\n\n\t \n\treturn raw_reg_read(regs, GEN11_GFX_MSTR_IRQ);\n}\n\nstatic inline void gen11_master_intr_enable(void __iomem * const regs)\n{\n\traw_reg_write(regs, GEN11_GFX_MSTR_IRQ, GEN11_MASTER_IRQ);\n}\n\nstatic irqreturn_t gen11_irq_handler(int irq, void *arg)\n{\n\tstruct drm_i915_private *i915 = arg;\n\tvoid __iomem * const regs = intel_uncore_regs(&i915->uncore);\n\tstruct intel_gt *gt = to_gt(i915);\n\tu32 master_ctl;\n\tu32 gu_misc_iir;\n\n\tif (!intel_irqs_enabled(i915))\n\t\treturn IRQ_NONE;\n\n\tmaster_ctl = gen11_master_intr_disable(regs);\n\tif (!master_ctl) {\n\t\tgen11_master_intr_enable(regs);\n\t\treturn IRQ_NONE;\n\t}\n\n\t \n\tgen11_gt_irq_handler(gt, master_ctl);\n\n\t \n\tif (master_ctl & GEN11_DISPLAY_IRQ)\n\t\tgen11_display_irq_handler(i915);\n\n\tgu_misc_iir = gen11_gu_misc_irq_ack(i915, master_ctl);\n\n\tgen11_master_intr_enable(regs);\n\n\tgen11_gu_misc_irq_handler(i915, gu_misc_iir);\n\n\tpmu_irq_stats(i915, IRQ_HANDLED);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic inline u32 dg1_master_intr_disable(void __iomem * const regs)\n{\n\tu32 val;\n\n\t \n\traw_reg_write(regs, DG1_MSTR_TILE_INTR, 0);\n\n\t \n\tval = raw_reg_read(regs, DG1_MSTR_TILE_INTR);\n\tif (unlikely(!val))\n\t\treturn 0;\n\n\traw_reg_write(regs, DG1_MSTR_TILE_INTR, val);\n\n\treturn val;\n}\n\nstatic inline void dg1_master_intr_enable(void __iomem * const regs)\n{\n\traw_reg_write(regs, DG1_MSTR_TILE_INTR, DG1_MSTR_IRQ);\n}\n\nstatic irqreturn_t dg1_irq_handler(int irq, void *arg)\n{\n\tstruct drm_i915_private * const i915 = arg;\n\tstruct intel_gt *gt = to_gt(i915);\n\tvoid __iomem * const regs = intel_uncore_regs(gt->uncore);\n\tu32 master_tile_ctl, master_ctl;\n\tu32 gu_misc_iir;\n\n\tif (!intel_irqs_enabled(i915))\n\t\treturn IRQ_NONE;\n\n\tmaster_tile_ctl = dg1_master_intr_disable(regs);\n\tif (!master_tile_ctl) {\n\t\tdg1_master_intr_enable(regs);\n\t\treturn IRQ_NONE;\n\t}\n\n\t \n\tif (master_tile_ctl & DG1_MSTR_TILE(0)) {\n\t\tmaster_ctl = raw_reg_read(regs, GEN11_GFX_MSTR_IRQ);\n\t\traw_reg_write(regs, GEN11_GFX_MSTR_IRQ, master_ctl);\n\t} else {\n\t\tdrm_err(&i915->drm, \"Tile not supported: 0x%08x\\n\",\n\t\t\tmaster_tile_ctl);\n\t\tdg1_master_intr_enable(regs);\n\t\treturn IRQ_NONE;\n\t}\n\n\tgen11_gt_irq_handler(gt, master_ctl);\n\n\tif (master_ctl & GEN11_DISPLAY_IRQ)\n\t\tgen11_display_irq_handler(i915);\n\n\tgu_misc_iir = gen11_gu_misc_irq_ack(i915, master_ctl);\n\n\tdg1_master_intr_enable(regs);\n\n\tgen11_gu_misc_irq_handler(i915, gu_misc_iir);\n\n\tpmu_irq_stats(i915, IRQ_HANDLED);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic void ibx_irq_reset(struct drm_i915_private *dev_priv)\n{\n\tstruct intel_uncore *uncore = &dev_priv->uncore;\n\n\tif (HAS_PCH_NOP(dev_priv))\n\t\treturn;\n\n\tGEN3_IRQ_RESET(uncore, SDE);\n\n\tif (HAS_PCH_CPT(dev_priv) || HAS_PCH_LPT(dev_priv))\n\t\tintel_uncore_write(&dev_priv->uncore, SERR_INT, 0xffffffff);\n}\n\n \nstatic void ilk_irq_reset(struct drm_i915_private *dev_priv)\n{\n\tstruct intel_uncore *uncore = &dev_priv->uncore;\n\n\tGEN3_IRQ_RESET(uncore, DE);\n\tdev_priv->irq_mask = ~0u;\n\n\tif (GRAPHICS_VER(dev_priv) == 7)\n\t\tintel_uncore_write(uncore, GEN7_ERR_INT, 0xffffffff);\n\n\tif (IS_HASWELL(dev_priv)) {\n\t\tintel_uncore_write(uncore, EDP_PSR_IMR, 0xffffffff);\n\t\tintel_uncore_write(uncore, EDP_PSR_IIR, 0xffffffff);\n\t}\n\n\tgen5_gt_irq_reset(to_gt(dev_priv));\n\n\tibx_irq_reset(dev_priv);\n}\n\nstatic void valleyview_irq_reset(struct drm_i915_private *dev_priv)\n{\n\tintel_uncore_write(&dev_priv->uncore, VLV_MASTER_IER, 0);\n\tintel_uncore_posting_read(&dev_priv->uncore, VLV_MASTER_IER);\n\n\tgen5_gt_irq_reset(to_gt(dev_priv));\n\n\tspin_lock_irq(&dev_priv->irq_lock);\n\tif (dev_priv->display_irqs_enabled)\n\t\tvlv_display_irq_reset(dev_priv);\n\tspin_unlock_irq(&dev_priv->irq_lock);\n}\n\nstatic void gen8_irq_reset(struct drm_i915_private *dev_priv)\n{\n\tstruct intel_uncore *uncore = &dev_priv->uncore;\n\n\tgen8_master_intr_disable(intel_uncore_regs(uncore));\n\n\tgen8_gt_irq_reset(to_gt(dev_priv));\n\tgen8_display_irq_reset(dev_priv);\n\tGEN3_IRQ_RESET(uncore, GEN8_PCU_);\n\n\tif (HAS_PCH_SPLIT(dev_priv))\n\t\tibx_irq_reset(dev_priv);\n\n}\n\nstatic void gen11_irq_reset(struct drm_i915_private *dev_priv)\n{\n\tstruct intel_gt *gt = to_gt(dev_priv);\n\tstruct intel_uncore *uncore = gt->uncore;\n\n\tgen11_master_intr_disable(intel_uncore_regs(&dev_priv->uncore));\n\n\tgen11_gt_irq_reset(gt);\n\tgen11_display_irq_reset(dev_priv);\n\n\tGEN3_IRQ_RESET(uncore, GEN11_GU_MISC_);\n\tGEN3_IRQ_RESET(uncore, GEN8_PCU_);\n}\n\nstatic void dg1_irq_reset(struct drm_i915_private *dev_priv)\n{\n\tstruct intel_uncore *uncore = &dev_priv->uncore;\n\tstruct intel_gt *gt;\n\tunsigned int i;\n\n\tdg1_master_intr_disable(intel_uncore_regs(&dev_priv->uncore));\n\n\tfor_each_gt(gt, dev_priv, i)\n\t\tgen11_gt_irq_reset(gt);\n\n\tgen11_display_irq_reset(dev_priv);\n\n\tGEN3_IRQ_RESET(uncore, GEN11_GU_MISC_);\n\tGEN3_IRQ_RESET(uncore, GEN8_PCU_);\n}\n\nstatic void cherryview_irq_reset(struct drm_i915_private *dev_priv)\n{\n\tstruct intel_uncore *uncore = &dev_priv->uncore;\n\n\tintel_uncore_write(uncore, GEN8_MASTER_IRQ, 0);\n\tintel_uncore_posting_read(&dev_priv->uncore, GEN8_MASTER_IRQ);\n\n\tgen8_gt_irq_reset(to_gt(dev_priv));\n\n\tGEN3_IRQ_RESET(uncore, GEN8_PCU_);\n\n\tspin_lock_irq(&dev_priv->irq_lock);\n\tif (dev_priv->display_irqs_enabled)\n\t\tvlv_display_irq_reset(dev_priv);\n\tspin_unlock_irq(&dev_priv->irq_lock);\n}\n\nstatic void ilk_irq_postinstall(struct drm_i915_private *dev_priv)\n{\n\tgen5_gt_irq_postinstall(to_gt(dev_priv));\n\n\tilk_de_irq_postinstall(dev_priv);\n}\n\nstatic void valleyview_irq_postinstall(struct drm_i915_private *dev_priv)\n{\n\tgen5_gt_irq_postinstall(to_gt(dev_priv));\n\n\tspin_lock_irq(&dev_priv->irq_lock);\n\tif (dev_priv->display_irqs_enabled)\n\t\tvlv_display_irq_postinstall(dev_priv);\n\tspin_unlock_irq(&dev_priv->irq_lock);\n\n\tintel_uncore_write(&dev_priv->uncore, VLV_MASTER_IER, MASTER_INTERRUPT_ENABLE);\n\tintel_uncore_posting_read(&dev_priv->uncore, VLV_MASTER_IER);\n}\n\nstatic void gen8_irq_postinstall(struct drm_i915_private *dev_priv)\n{\n\tgen8_gt_irq_postinstall(to_gt(dev_priv));\n\tgen8_de_irq_postinstall(dev_priv);\n\n\tgen8_master_intr_enable(intel_uncore_regs(&dev_priv->uncore));\n}\n\nstatic void gen11_irq_postinstall(struct drm_i915_private *dev_priv)\n{\n\tstruct intel_gt *gt = to_gt(dev_priv);\n\tstruct intel_uncore *uncore = gt->uncore;\n\tu32 gu_misc_masked = GEN11_GU_MISC_GSE;\n\n\tgen11_gt_irq_postinstall(gt);\n\tgen11_de_irq_postinstall(dev_priv);\n\n\tGEN3_IRQ_INIT(uncore, GEN11_GU_MISC_, ~gu_misc_masked, gu_misc_masked);\n\n\tgen11_master_intr_enable(intel_uncore_regs(uncore));\n\tintel_uncore_posting_read(&dev_priv->uncore, GEN11_GFX_MSTR_IRQ);\n}\n\nstatic void dg1_irq_postinstall(struct drm_i915_private *dev_priv)\n{\n\tstruct intel_uncore *uncore = &dev_priv->uncore;\n\tu32 gu_misc_masked = GEN11_GU_MISC_GSE;\n\tstruct intel_gt *gt;\n\tunsigned int i;\n\n\tfor_each_gt(gt, dev_priv, i)\n\t\tgen11_gt_irq_postinstall(gt);\n\n\tGEN3_IRQ_INIT(uncore, GEN11_GU_MISC_, ~gu_misc_masked, gu_misc_masked);\n\n\tdg1_de_irq_postinstall(dev_priv);\n\n\tdg1_master_intr_enable(intel_uncore_regs(uncore));\n\tintel_uncore_posting_read(uncore, DG1_MSTR_TILE_INTR);\n}\n\nstatic void cherryview_irq_postinstall(struct drm_i915_private *dev_priv)\n{\n\tgen8_gt_irq_postinstall(to_gt(dev_priv));\n\n\tspin_lock_irq(&dev_priv->irq_lock);\n\tif (dev_priv->display_irqs_enabled)\n\t\tvlv_display_irq_postinstall(dev_priv);\n\tspin_unlock_irq(&dev_priv->irq_lock);\n\n\tintel_uncore_write(&dev_priv->uncore, GEN8_MASTER_IRQ, GEN8_MASTER_IRQ_CONTROL);\n\tintel_uncore_posting_read(&dev_priv->uncore, GEN8_MASTER_IRQ);\n}\n\nstatic void i8xx_irq_reset(struct drm_i915_private *dev_priv)\n{\n\tstruct intel_uncore *uncore = &dev_priv->uncore;\n\n\ti9xx_pipestat_irq_reset(dev_priv);\n\n\tgen2_irq_reset(uncore);\n\tdev_priv->irq_mask = ~0u;\n}\n\nstatic u32 i9xx_error_mask(struct drm_i915_private *i915)\n{\n\t \n\tif (HAS_FBC(i915))\n\t\treturn ~I915_ERROR_MEMORY_REFRESH;\n\telse\n\t\treturn ~(I915_ERROR_PAGE_TABLE |\n\t\t\t I915_ERROR_MEMORY_REFRESH);\n}\n\nstatic void i8xx_irq_postinstall(struct drm_i915_private *dev_priv)\n{\n\tstruct intel_uncore *uncore = &dev_priv->uncore;\n\tu16 enable_mask;\n\n\tintel_uncore_write16(uncore, EMR, i9xx_error_mask(dev_priv));\n\n\t \n\tdev_priv->irq_mask =\n\t\t~(I915_DISPLAY_PIPE_A_EVENT_INTERRUPT |\n\t\t  I915_DISPLAY_PIPE_B_EVENT_INTERRUPT |\n\t\t  I915_MASTER_ERROR_INTERRUPT);\n\n\tenable_mask =\n\t\tI915_DISPLAY_PIPE_A_EVENT_INTERRUPT |\n\t\tI915_DISPLAY_PIPE_B_EVENT_INTERRUPT |\n\t\tI915_MASTER_ERROR_INTERRUPT |\n\t\tI915_USER_INTERRUPT;\n\n\tgen2_irq_init(uncore, dev_priv->irq_mask, enable_mask);\n\n\t \n\tspin_lock_irq(&dev_priv->irq_lock);\n\ti915_enable_pipestat(dev_priv, PIPE_A, PIPE_CRC_DONE_INTERRUPT_STATUS);\n\ti915_enable_pipestat(dev_priv, PIPE_B, PIPE_CRC_DONE_INTERRUPT_STATUS);\n\tspin_unlock_irq(&dev_priv->irq_lock);\n}\n\nstatic void i8xx_error_irq_ack(struct drm_i915_private *i915,\n\t\t\t       u16 *eir, u16 *eir_stuck)\n{\n\tstruct intel_uncore *uncore = &i915->uncore;\n\tu16 emr;\n\n\t*eir = intel_uncore_read16(uncore, EIR);\n\tintel_uncore_write16(uncore, EIR, *eir);\n\n\t*eir_stuck = intel_uncore_read16(uncore, EIR);\n\tif (*eir_stuck == 0)\n\t\treturn;\n\n\t \n\temr = intel_uncore_read16(uncore, EMR);\n\tintel_uncore_write16(uncore, EMR, 0xffff);\n\tintel_uncore_write16(uncore, EMR, emr | *eir_stuck);\n}\n\nstatic void i8xx_error_irq_handler(struct drm_i915_private *dev_priv,\n\t\t\t\t   u16 eir, u16 eir_stuck)\n{\n\tdrm_dbg(&dev_priv->drm, \"Master Error: EIR 0x%04x\\n\", eir);\n\n\tif (eir_stuck)\n\t\tdrm_dbg(&dev_priv->drm, \"EIR stuck: 0x%04x, masked\\n\",\n\t\t\teir_stuck);\n\n\tdrm_dbg(&dev_priv->drm, \"PGTBL_ER: 0x%08x\\n\",\n\t\tintel_uncore_read(&dev_priv->uncore, PGTBL_ER));\n}\n\nstatic void i9xx_error_irq_ack(struct drm_i915_private *dev_priv,\n\t\t\t       u32 *eir, u32 *eir_stuck)\n{\n\tu32 emr;\n\n\t*eir = intel_uncore_read(&dev_priv->uncore, EIR);\n\tintel_uncore_write(&dev_priv->uncore, EIR, *eir);\n\n\t*eir_stuck = intel_uncore_read(&dev_priv->uncore, EIR);\n\tif (*eir_stuck == 0)\n\t\treturn;\n\n\t \n\temr = intel_uncore_read(&dev_priv->uncore, EMR);\n\tintel_uncore_write(&dev_priv->uncore, EMR, 0xffffffff);\n\tintel_uncore_write(&dev_priv->uncore, EMR, emr | *eir_stuck);\n}\n\nstatic void i9xx_error_irq_handler(struct drm_i915_private *dev_priv,\n\t\t\t\t   u32 eir, u32 eir_stuck)\n{\n\tdrm_dbg(&dev_priv->drm, \"Master Error, EIR 0x%08x\\n\", eir);\n\n\tif (eir_stuck)\n\t\tdrm_dbg(&dev_priv->drm, \"EIR stuck: 0x%08x, masked\\n\",\n\t\t\teir_stuck);\n\n\tdrm_dbg(&dev_priv->drm, \"PGTBL_ER: 0x%08x\\n\",\n\t\tintel_uncore_read(&dev_priv->uncore, PGTBL_ER));\n}\n\nstatic irqreturn_t i8xx_irq_handler(int irq, void *arg)\n{\n\tstruct drm_i915_private *dev_priv = arg;\n\tirqreturn_t ret = IRQ_NONE;\n\n\tif (!intel_irqs_enabled(dev_priv))\n\t\treturn IRQ_NONE;\n\n\t \n\tdisable_rpm_wakeref_asserts(&dev_priv->runtime_pm);\n\n\tdo {\n\t\tu32 pipe_stats[I915_MAX_PIPES] = {};\n\t\tu16 eir = 0, eir_stuck = 0;\n\t\tu16 iir;\n\n\t\tiir = intel_uncore_read16(&dev_priv->uncore, GEN2_IIR);\n\t\tif (iir == 0)\n\t\t\tbreak;\n\n\t\tret = IRQ_HANDLED;\n\n\t\t \n\t\ti9xx_pipestat_irq_ack(dev_priv, iir, pipe_stats);\n\n\t\tif (iir & I915_MASTER_ERROR_INTERRUPT)\n\t\t\ti8xx_error_irq_ack(dev_priv, &eir, &eir_stuck);\n\n\t\tintel_uncore_write16(&dev_priv->uncore, GEN2_IIR, iir);\n\n\t\tif (iir & I915_USER_INTERRUPT)\n\t\t\tintel_engine_cs_irq(to_gt(dev_priv)->engine[RCS0], iir);\n\n\t\tif (iir & I915_MASTER_ERROR_INTERRUPT)\n\t\t\ti8xx_error_irq_handler(dev_priv, eir, eir_stuck);\n\n\t\ti8xx_pipestat_irq_handler(dev_priv, iir, pipe_stats);\n\t} while (0);\n\n\tpmu_irq_stats(dev_priv, ret);\n\n\tenable_rpm_wakeref_asserts(&dev_priv->runtime_pm);\n\n\treturn ret;\n}\n\nstatic void i915_irq_reset(struct drm_i915_private *dev_priv)\n{\n\tstruct intel_uncore *uncore = &dev_priv->uncore;\n\n\tif (I915_HAS_HOTPLUG(dev_priv)) {\n\t\ti915_hotplug_interrupt_update(dev_priv, 0xffffffff, 0);\n\t\tintel_uncore_rmw(&dev_priv->uncore, PORT_HOTPLUG_STAT, 0, 0);\n\t}\n\n\ti9xx_pipestat_irq_reset(dev_priv);\n\n\tGEN3_IRQ_RESET(uncore, GEN2_);\n\tdev_priv->irq_mask = ~0u;\n}\n\nstatic void i915_irq_postinstall(struct drm_i915_private *dev_priv)\n{\n\tstruct intel_uncore *uncore = &dev_priv->uncore;\n\tu32 enable_mask;\n\n\tintel_uncore_write(uncore, EMR, i9xx_error_mask(dev_priv));\n\n\t \n\tdev_priv->irq_mask =\n\t\t~(I915_ASLE_INTERRUPT |\n\t\t  I915_DISPLAY_PIPE_A_EVENT_INTERRUPT |\n\t\t  I915_DISPLAY_PIPE_B_EVENT_INTERRUPT |\n\t\t  I915_MASTER_ERROR_INTERRUPT);\n\n\tenable_mask =\n\t\tI915_ASLE_INTERRUPT |\n\t\tI915_DISPLAY_PIPE_A_EVENT_INTERRUPT |\n\t\tI915_DISPLAY_PIPE_B_EVENT_INTERRUPT |\n\t\tI915_MASTER_ERROR_INTERRUPT |\n\t\tI915_USER_INTERRUPT;\n\n\tif (I915_HAS_HOTPLUG(dev_priv)) {\n\t\t \n\t\tenable_mask |= I915_DISPLAY_PORT_INTERRUPT;\n\t\t \n\t\tdev_priv->irq_mask &= ~I915_DISPLAY_PORT_INTERRUPT;\n\t}\n\n\tGEN3_IRQ_INIT(uncore, GEN2_, dev_priv->irq_mask, enable_mask);\n\n\t \n\tspin_lock_irq(&dev_priv->irq_lock);\n\ti915_enable_pipestat(dev_priv, PIPE_A, PIPE_CRC_DONE_INTERRUPT_STATUS);\n\ti915_enable_pipestat(dev_priv, PIPE_B, PIPE_CRC_DONE_INTERRUPT_STATUS);\n\tspin_unlock_irq(&dev_priv->irq_lock);\n\n\ti915_enable_asle_pipestat(dev_priv);\n}\n\nstatic irqreturn_t i915_irq_handler(int irq, void *arg)\n{\n\tstruct drm_i915_private *dev_priv = arg;\n\tirqreturn_t ret = IRQ_NONE;\n\n\tif (!intel_irqs_enabled(dev_priv))\n\t\treturn IRQ_NONE;\n\n\t \n\tdisable_rpm_wakeref_asserts(&dev_priv->runtime_pm);\n\n\tdo {\n\t\tu32 pipe_stats[I915_MAX_PIPES] = {};\n\t\tu32 eir = 0, eir_stuck = 0;\n\t\tu32 hotplug_status = 0;\n\t\tu32 iir;\n\n\t\tiir = intel_uncore_read(&dev_priv->uncore, GEN2_IIR);\n\t\tif (iir == 0)\n\t\t\tbreak;\n\n\t\tret = IRQ_HANDLED;\n\n\t\tif (I915_HAS_HOTPLUG(dev_priv) &&\n\t\t    iir & I915_DISPLAY_PORT_INTERRUPT)\n\t\t\thotplug_status = i9xx_hpd_irq_ack(dev_priv);\n\n\t\t \n\t\ti9xx_pipestat_irq_ack(dev_priv, iir, pipe_stats);\n\n\t\tif (iir & I915_MASTER_ERROR_INTERRUPT)\n\t\t\ti9xx_error_irq_ack(dev_priv, &eir, &eir_stuck);\n\n\t\tintel_uncore_write(&dev_priv->uncore, GEN2_IIR, iir);\n\n\t\tif (iir & I915_USER_INTERRUPT)\n\t\t\tintel_engine_cs_irq(to_gt(dev_priv)->engine[RCS0], iir);\n\n\t\tif (iir & I915_MASTER_ERROR_INTERRUPT)\n\t\t\ti9xx_error_irq_handler(dev_priv, eir, eir_stuck);\n\n\t\tif (hotplug_status)\n\t\t\ti9xx_hpd_irq_handler(dev_priv, hotplug_status);\n\n\t\ti915_pipestat_irq_handler(dev_priv, iir, pipe_stats);\n\t} while (0);\n\n\tpmu_irq_stats(dev_priv, ret);\n\n\tenable_rpm_wakeref_asserts(&dev_priv->runtime_pm);\n\n\treturn ret;\n}\n\nstatic void i965_irq_reset(struct drm_i915_private *dev_priv)\n{\n\tstruct intel_uncore *uncore = &dev_priv->uncore;\n\n\ti915_hotplug_interrupt_update(dev_priv, 0xffffffff, 0);\n\tintel_uncore_rmw(uncore, PORT_HOTPLUG_STAT, 0, 0);\n\n\ti9xx_pipestat_irq_reset(dev_priv);\n\n\tGEN3_IRQ_RESET(uncore, GEN2_);\n\tdev_priv->irq_mask = ~0u;\n}\n\nstatic u32 i965_error_mask(struct drm_i915_private *i915)\n{\n\t \n\tif (IS_G4X(i915))\n\t\treturn ~(GM45_ERROR_PAGE_TABLE |\n\t\t\t GM45_ERROR_MEM_PRIV |\n\t\t\t GM45_ERROR_CP_PRIV |\n\t\t\t I915_ERROR_MEMORY_REFRESH);\n\telse\n\t\treturn ~(I915_ERROR_PAGE_TABLE |\n\t\t\t I915_ERROR_MEMORY_REFRESH);\n}\n\nstatic void i965_irq_postinstall(struct drm_i915_private *dev_priv)\n{\n\tstruct intel_uncore *uncore = &dev_priv->uncore;\n\tu32 enable_mask;\n\n\tintel_uncore_write(uncore, EMR, i965_error_mask(dev_priv));\n\n\t \n\tdev_priv->irq_mask =\n\t\t~(I915_ASLE_INTERRUPT |\n\t\t  I915_DISPLAY_PORT_INTERRUPT |\n\t\t  I915_DISPLAY_PIPE_A_EVENT_INTERRUPT |\n\t\t  I915_DISPLAY_PIPE_B_EVENT_INTERRUPT |\n\t\t  I915_MASTER_ERROR_INTERRUPT);\n\n\tenable_mask =\n\t\tI915_ASLE_INTERRUPT |\n\t\tI915_DISPLAY_PORT_INTERRUPT |\n\t\tI915_DISPLAY_PIPE_A_EVENT_INTERRUPT |\n\t\tI915_DISPLAY_PIPE_B_EVENT_INTERRUPT |\n\t\tI915_MASTER_ERROR_INTERRUPT |\n\t\tI915_USER_INTERRUPT;\n\n\tif (IS_G4X(dev_priv))\n\t\tenable_mask |= I915_BSD_USER_INTERRUPT;\n\n\tGEN3_IRQ_INIT(uncore, GEN2_, dev_priv->irq_mask, enable_mask);\n\n\t \n\tspin_lock_irq(&dev_priv->irq_lock);\n\ti915_enable_pipestat(dev_priv, PIPE_A, PIPE_GMBUS_INTERRUPT_STATUS);\n\ti915_enable_pipestat(dev_priv, PIPE_A, PIPE_CRC_DONE_INTERRUPT_STATUS);\n\ti915_enable_pipestat(dev_priv, PIPE_B, PIPE_CRC_DONE_INTERRUPT_STATUS);\n\tspin_unlock_irq(&dev_priv->irq_lock);\n\n\ti915_enable_asle_pipestat(dev_priv);\n}\n\nstatic irqreturn_t i965_irq_handler(int irq, void *arg)\n{\n\tstruct drm_i915_private *dev_priv = arg;\n\tirqreturn_t ret = IRQ_NONE;\n\n\tif (!intel_irqs_enabled(dev_priv))\n\t\treturn IRQ_NONE;\n\n\t \n\tdisable_rpm_wakeref_asserts(&dev_priv->runtime_pm);\n\n\tdo {\n\t\tu32 pipe_stats[I915_MAX_PIPES] = {};\n\t\tu32 eir = 0, eir_stuck = 0;\n\t\tu32 hotplug_status = 0;\n\t\tu32 iir;\n\n\t\tiir = intel_uncore_read(&dev_priv->uncore, GEN2_IIR);\n\t\tif (iir == 0)\n\t\t\tbreak;\n\n\t\tret = IRQ_HANDLED;\n\n\t\tif (iir & I915_DISPLAY_PORT_INTERRUPT)\n\t\t\thotplug_status = i9xx_hpd_irq_ack(dev_priv);\n\n\t\t \n\t\ti9xx_pipestat_irq_ack(dev_priv, iir, pipe_stats);\n\n\t\tif (iir & I915_MASTER_ERROR_INTERRUPT)\n\t\t\ti9xx_error_irq_ack(dev_priv, &eir, &eir_stuck);\n\n\t\tintel_uncore_write(&dev_priv->uncore, GEN2_IIR, iir);\n\n\t\tif (iir & I915_USER_INTERRUPT)\n\t\t\tintel_engine_cs_irq(to_gt(dev_priv)->engine[RCS0],\n\t\t\t\t\t    iir);\n\n\t\tif (iir & I915_BSD_USER_INTERRUPT)\n\t\t\tintel_engine_cs_irq(to_gt(dev_priv)->engine[VCS0],\n\t\t\t\t\t    iir >> 25);\n\n\t\tif (iir & I915_MASTER_ERROR_INTERRUPT)\n\t\t\ti9xx_error_irq_handler(dev_priv, eir, eir_stuck);\n\n\t\tif (hotplug_status)\n\t\t\ti9xx_hpd_irq_handler(dev_priv, hotplug_status);\n\n\t\ti965_pipestat_irq_handler(dev_priv, iir, pipe_stats);\n\t} while (0);\n\n\tpmu_irq_stats(dev_priv, IRQ_HANDLED);\n\n\tenable_rpm_wakeref_asserts(&dev_priv->runtime_pm);\n\n\treturn ret;\n}\n\n \nvoid intel_irq_init(struct drm_i915_private *dev_priv)\n{\n\tint i;\n\n\tINIT_WORK(&dev_priv->l3_parity.error_work, ivb_parity_work);\n\tfor (i = 0; i < MAX_L3_SLICES; ++i)\n\t\tdev_priv->l3_parity.remap_info[i] = NULL;\n\n\t \n\tif (HAS_GT_UC(dev_priv) && GRAPHICS_VER(dev_priv) < 11)\n\t\tto_gt(dev_priv)->pm_guc_events = GUC_INTR_GUC2HOST << 16;\n}\n\n \nvoid intel_irq_fini(struct drm_i915_private *i915)\n{\n\tint i;\n\n\tfor (i = 0; i < MAX_L3_SLICES; ++i)\n\t\tkfree(i915->l3_parity.remap_info[i]);\n}\n\nstatic irq_handler_t intel_irq_handler(struct drm_i915_private *dev_priv)\n{\n\tif (HAS_GMCH(dev_priv)) {\n\t\tif (IS_CHERRYVIEW(dev_priv))\n\t\t\treturn cherryview_irq_handler;\n\t\telse if (IS_VALLEYVIEW(dev_priv))\n\t\t\treturn valleyview_irq_handler;\n\t\telse if (GRAPHICS_VER(dev_priv) == 4)\n\t\t\treturn i965_irq_handler;\n\t\telse if (GRAPHICS_VER(dev_priv) == 3)\n\t\t\treturn i915_irq_handler;\n\t\telse\n\t\t\treturn i8xx_irq_handler;\n\t} else {\n\t\tif (GRAPHICS_VER_FULL(dev_priv) >= IP_VER(12, 10))\n\t\t\treturn dg1_irq_handler;\n\t\telse if (GRAPHICS_VER(dev_priv) >= 11)\n\t\t\treturn gen11_irq_handler;\n\t\telse if (GRAPHICS_VER(dev_priv) >= 8)\n\t\t\treturn gen8_irq_handler;\n\t\telse\n\t\t\treturn ilk_irq_handler;\n\t}\n}\n\nstatic void intel_irq_reset(struct drm_i915_private *dev_priv)\n{\n\tif (HAS_GMCH(dev_priv)) {\n\t\tif (IS_CHERRYVIEW(dev_priv))\n\t\t\tcherryview_irq_reset(dev_priv);\n\t\telse if (IS_VALLEYVIEW(dev_priv))\n\t\t\tvalleyview_irq_reset(dev_priv);\n\t\telse if (GRAPHICS_VER(dev_priv) == 4)\n\t\t\ti965_irq_reset(dev_priv);\n\t\telse if (GRAPHICS_VER(dev_priv) == 3)\n\t\t\ti915_irq_reset(dev_priv);\n\t\telse\n\t\t\ti8xx_irq_reset(dev_priv);\n\t} else {\n\t\tif (GRAPHICS_VER_FULL(dev_priv) >= IP_VER(12, 10))\n\t\t\tdg1_irq_reset(dev_priv);\n\t\telse if (GRAPHICS_VER(dev_priv) >= 11)\n\t\t\tgen11_irq_reset(dev_priv);\n\t\telse if (GRAPHICS_VER(dev_priv) >= 8)\n\t\t\tgen8_irq_reset(dev_priv);\n\t\telse\n\t\t\tilk_irq_reset(dev_priv);\n\t}\n}\n\nstatic void intel_irq_postinstall(struct drm_i915_private *dev_priv)\n{\n\tif (HAS_GMCH(dev_priv)) {\n\t\tif (IS_CHERRYVIEW(dev_priv))\n\t\t\tcherryview_irq_postinstall(dev_priv);\n\t\telse if (IS_VALLEYVIEW(dev_priv))\n\t\t\tvalleyview_irq_postinstall(dev_priv);\n\t\telse if (GRAPHICS_VER(dev_priv) == 4)\n\t\t\ti965_irq_postinstall(dev_priv);\n\t\telse if (GRAPHICS_VER(dev_priv) == 3)\n\t\t\ti915_irq_postinstall(dev_priv);\n\t\telse\n\t\t\ti8xx_irq_postinstall(dev_priv);\n\t} else {\n\t\tif (GRAPHICS_VER_FULL(dev_priv) >= IP_VER(12, 10))\n\t\t\tdg1_irq_postinstall(dev_priv);\n\t\telse if (GRAPHICS_VER(dev_priv) >= 11)\n\t\t\tgen11_irq_postinstall(dev_priv);\n\t\telse if (GRAPHICS_VER(dev_priv) >= 8)\n\t\t\tgen8_irq_postinstall(dev_priv);\n\t\telse\n\t\t\tilk_irq_postinstall(dev_priv);\n\t}\n}\n\n \nint intel_irq_install(struct drm_i915_private *dev_priv)\n{\n\tint irq = to_pci_dev(dev_priv->drm.dev)->irq;\n\tint ret;\n\n\t \n\tdev_priv->runtime_pm.irqs_enabled = true;\n\n\tdev_priv->irq_enabled = true;\n\n\tintel_irq_reset(dev_priv);\n\n\tret = request_irq(irq, intel_irq_handler(dev_priv),\n\t\t\t  IRQF_SHARED, DRIVER_NAME, dev_priv);\n\tif (ret < 0) {\n\t\tdev_priv->irq_enabled = false;\n\t\treturn ret;\n\t}\n\n\tintel_irq_postinstall(dev_priv);\n\n\treturn ret;\n}\n\n \nvoid intel_irq_uninstall(struct drm_i915_private *dev_priv)\n{\n\tint irq = to_pci_dev(dev_priv->drm.dev)->irq;\n\n\t \n\tif (!dev_priv->irq_enabled)\n\t\treturn;\n\n\tdev_priv->irq_enabled = false;\n\n\tintel_irq_reset(dev_priv);\n\n\tfree_irq(irq, dev_priv);\n\n\tintel_hpd_cancel_work(dev_priv);\n\tdev_priv->runtime_pm.irqs_enabled = false;\n}\n\n \nvoid intel_runtime_pm_disable_interrupts(struct drm_i915_private *dev_priv)\n{\n\tintel_irq_reset(dev_priv);\n\tdev_priv->runtime_pm.irqs_enabled = false;\n\tintel_synchronize_irq(dev_priv);\n}\n\n \nvoid intel_runtime_pm_enable_interrupts(struct drm_i915_private *dev_priv)\n{\n\tdev_priv->runtime_pm.irqs_enabled = true;\n\tintel_irq_reset(dev_priv);\n\tintel_irq_postinstall(dev_priv);\n}\n\nbool intel_irqs_enabled(struct drm_i915_private *dev_priv)\n{\n\treturn dev_priv->runtime_pm.irqs_enabled;\n}\n\nvoid intel_synchronize_irq(struct drm_i915_private *i915)\n{\n\tsynchronize_irq(to_pci_dev(i915->drm.dev)->irq);\n}\n\nvoid intel_synchronize_hardirq(struct drm_i915_private *i915)\n{\n\tsynchronize_hardirq(to_pci_dev(i915->drm.dev)->irq);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}