{
  "module_name": "vga_switcheroo.c",
  "hash_id": "591c72848eb25eb9e6272f9cafa95e9a562cba3a18479ec55e1a9b0946c48988",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/vga/vga_switcheroo.c",
  "human_readable_source": " \n\n#define pr_fmt(fmt) \"vga_switcheroo: \" fmt\n\n#include <linux/apple-gmux.h>\n#include <linux/console.h>\n#include <linux/debugfs.h>\n#include <linux/fb.h>\n#include <linux/fs.h>\n#include <linux/fbcon.h>\n#include <linux/module.h>\n#include <linux/pci.h>\n#include <linux/pm_domain.h>\n#include <linux/pm_runtime.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n#include <linux/vgaarb.h>\n#include <linux/vga_switcheroo.h>\n\n \n\n \nstruct vga_switcheroo_client {\n\tstruct pci_dev *pdev;\n\tstruct fb_info *fb_info;\n\tenum vga_switcheroo_state pwr_state;\n\tconst struct vga_switcheroo_client_ops *ops;\n\tenum vga_switcheroo_client_id id;\n\tbool active;\n\tbool driver_power_control;\n\tstruct list_head list;\n\tstruct pci_dev *vga_dev;\n};\n\n \nstatic DEFINE_MUTEX(vgasr_mutex);\n\n \nstruct vgasr_priv {\n\tbool active;\n\tbool delayed_switch_active;\n\tenum vga_switcheroo_client_id delayed_client_id;\n\n\tstruct dentry *debugfs_root;\n\n\tint registered_clients;\n\tstruct list_head clients;\n\n\tconst struct vga_switcheroo_handler *handler;\n\tenum vga_switcheroo_handler_flags_t handler_flags;\n\tstruct mutex mux_hw_lock;\n\tint old_ddc_owner;\n};\n\n#define ID_BIT_AUDIO\t\t0x100\n#define client_is_audio(c)\t\t((c)->id & ID_BIT_AUDIO)\n#define client_is_vga(c)\t\t(!client_is_audio(c))\n#define client_id(c)\t\t((c)->id & ~ID_BIT_AUDIO)\n\nstatic void vga_switcheroo_debugfs_init(struct vgasr_priv *priv);\nstatic void vga_switcheroo_debugfs_fini(struct vgasr_priv *priv);\n\n \nstatic struct vgasr_priv vgasr_priv = {\n\t.clients = LIST_HEAD_INIT(vgasr_priv.clients),\n\t.mux_hw_lock = __MUTEX_INITIALIZER(vgasr_priv.mux_hw_lock),\n};\n\nstatic bool vga_switcheroo_ready(void)\n{\n\t \n\treturn !vgasr_priv.active &&\n\t       vgasr_priv.registered_clients == 2 && vgasr_priv.handler;\n}\n\nstatic void vga_switcheroo_enable(void)\n{\n\tint ret;\n\tstruct vga_switcheroo_client *client;\n\n\t \n\tif (vgasr_priv.handler->init)\n\t\tvgasr_priv.handler->init();\n\n\tlist_for_each_entry(client, &vgasr_priv.clients, list) {\n\t\tif (!client_is_vga(client) ||\n\t\t     client_id(client) != VGA_SWITCHEROO_UNKNOWN_ID)\n\t\t\tcontinue;\n\n\t\tret = vgasr_priv.handler->get_client_id(client->pdev);\n\t\tif (ret < 0)\n\t\t\treturn;\n\n\t\tclient->id = ret;\n\t}\n\n\tlist_for_each_entry(client, &vgasr_priv.clients, list) {\n\t\tif (!client_is_audio(client) ||\n\t\t     client_id(client) != VGA_SWITCHEROO_UNKNOWN_ID)\n\t\t\tcontinue;\n\n\t\tret = vgasr_priv.handler->get_client_id(client->vga_dev);\n\t\tif (ret < 0)\n\t\t\treturn;\n\n\t\tclient->id = ret | ID_BIT_AUDIO;\n\t\tif (client->ops->gpu_bound)\n\t\t\tclient->ops->gpu_bound(client->pdev, ret);\n\t}\n\n\tvga_switcheroo_debugfs_init(&vgasr_priv);\n\tvgasr_priv.active = true;\n}\n\n \nint vga_switcheroo_register_handler(\n\t\t\t  const struct vga_switcheroo_handler *handler,\n\t\t\t  enum vga_switcheroo_handler_flags_t handler_flags)\n{\n\tmutex_lock(&vgasr_mutex);\n\tif (vgasr_priv.handler) {\n\t\tmutex_unlock(&vgasr_mutex);\n\t\treturn -EINVAL;\n\t}\n\n\tvgasr_priv.handler = handler;\n\tvgasr_priv.handler_flags = handler_flags;\n\tif (vga_switcheroo_ready()) {\n\t\tpr_info(\"enabled\\n\");\n\t\tvga_switcheroo_enable();\n\t}\n\tmutex_unlock(&vgasr_mutex);\n\treturn 0;\n}\nEXPORT_SYMBOL(vga_switcheroo_register_handler);\n\n \nvoid vga_switcheroo_unregister_handler(void)\n{\n\tmutex_lock(&vgasr_mutex);\n\tmutex_lock(&vgasr_priv.mux_hw_lock);\n\tvgasr_priv.handler_flags = 0;\n\tvgasr_priv.handler = NULL;\n\tif (vgasr_priv.active) {\n\t\tpr_info(\"disabled\\n\");\n\t\tvga_switcheroo_debugfs_fini(&vgasr_priv);\n\t\tvgasr_priv.active = false;\n\t}\n\tmutex_unlock(&vgasr_priv.mux_hw_lock);\n\tmutex_unlock(&vgasr_mutex);\n}\nEXPORT_SYMBOL(vga_switcheroo_unregister_handler);\n\n \nenum vga_switcheroo_handler_flags_t vga_switcheroo_handler_flags(void)\n{\n\treturn vgasr_priv.handler_flags;\n}\nEXPORT_SYMBOL(vga_switcheroo_handler_flags);\n\nstatic int register_client(struct pci_dev *pdev,\n\t\t\t   const struct vga_switcheroo_client_ops *ops,\n\t\t\t   enum vga_switcheroo_client_id id,\n\t\t\t   struct pci_dev *vga_dev,\n\t\t\t   bool active,\n\t\t\t   bool driver_power_control)\n{\n\tstruct vga_switcheroo_client *client;\n\n\tclient = kzalloc(sizeof(*client), GFP_KERNEL);\n\tif (!client)\n\t\treturn -ENOMEM;\n\n\tclient->pwr_state = VGA_SWITCHEROO_ON;\n\tclient->pdev = pdev;\n\tclient->ops = ops;\n\tclient->id = id;\n\tclient->active = active;\n\tclient->driver_power_control = driver_power_control;\n\tclient->vga_dev = vga_dev;\n\n\tmutex_lock(&vgasr_mutex);\n\tlist_add_tail(&client->list, &vgasr_priv.clients);\n\tif (client_is_vga(client))\n\t\tvgasr_priv.registered_clients++;\n\n\tif (vga_switcheroo_ready()) {\n\t\tpr_info(\"enabled\\n\");\n\t\tvga_switcheroo_enable();\n\t}\n\tmutex_unlock(&vgasr_mutex);\n\treturn 0;\n}\n\n \nint vga_switcheroo_register_client(struct pci_dev *pdev,\n\t\t\t\t   const struct vga_switcheroo_client_ops *ops,\n\t\t\t\t   bool driver_power_control)\n{\n\treturn register_client(pdev, ops, VGA_SWITCHEROO_UNKNOWN_ID, NULL,\n\t\t\t       pdev == vga_default_device(),\n\t\t\t       driver_power_control);\n}\nEXPORT_SYMBOL(vga_switcheroo_register_client);\n\n \nint vga_switcheroo_register_audio_client(struct pci_dev *pdev,\n\t\t\tconst struct vga_switcheroo_client_ops *ops,\n\t\t\tstruct pci_dev *vga_dev)\n{\n\tenum vga_switcheroo_client_id id = VGA_SWITCHEROO_UNKNOWN_ID;\n\n\t \n\tmutex_lock(&vgasr_mutex);\n\tif (vgasr_priv.active) {\n\t\tid = vgasr_priv.handler->get_client_id(vga_dev);\n\t\tif (id < 0) {\n\t\t\tmutex_unlock(&vgasr_mutex);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\t \n\t\tif (ops->gpu_bound)\n\t\t\tops->gpu_bound(pdev, id);\n\t}\n\tmutex_unlock(&vgasr_mutex);\n\n\treturn register_client(pdev, ops, id | ID_BIT_AUDIO, vga_dev,\n\t\t\t       false, true);\n}\nEXPORT_SYMBOL(vga_switcheroo_register_audio_client);\n\nstatic struct vga_switcheroo_client *\nfind_client_from_pci(struct list_head *head, struct pci_dev *pdev)\n{\n\tstruct vga_switcheroo_client *client;\n\n\tlist_for_each_entry(client, head, list)\n\t\tif (client->pdev == pdev)\n\t\t\treturn client;\n\treturn NULL;\n}\n\nstatic struct vga_switcheroo_client *\nfind_client_from_id(struct list_head *head,\n\t\t    enum vga_switcheroo_client_id client_id)\n{\n\tstruct vga_switcheroo_client *client;\n\n\tlist_for_each_entry(client, head, list)\n\t\tif (client->id == client_id)\n\t\t\treturn client;\n\treturn NULL;\n}\n\nstatic struct vga_switcheroo_client *\nfind_active_client(struct list_head *head)\n{\n\tstruct vga_switcheroo_client *client;\n\n\tlist_for_each_entry(client, head, list)\n\t\tif (client->active)\n\t\t\treturn client;\n\treturn NULL;\n}\n\n \nbool vga_switcheroo_client_probe_defer(struct pci_dev *pdev)\n{\n\tif ((pdev->class >> 16) == PCI_BASE_CLASS_DISPLAY) {\n\t\t \n\t\tif (apple_gmux_present() && pdev != vga_default_device() &&\n\t\t    !vgasr_priv.handler_flags)\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}\nEXPORT_SYMBOL(vga_switcheroo_client_probe_defer);\n\nstatic enum vga_switcheroo_state\nvga_switcheroo_pwr_state(struct vga_switcheroo_client *client)\n{\n\tif (client->driver_power_control)\n\t\tif (pm_runtime_enabled(&client->pdev->dev) &&\n\t\t    pm_runtime_active(&client->pdev->dev))\n\t\t\treturn VGA_SWITCHEROO_ON;\n\t\telse\n\t\t\treturn VGA_SWITCHEROO_OFF;\n\telse\n\t\treturn client->pwr_state;\n}\n\n \nenum vga_switcheroo_state vga_switcheroo_get_client_state(struct pci_dev *pdev)\n{\n\tstruct vga_switcheroo_client *client;\n\tenum vga_switcheroo_state ret;\n\n\tmutex_lock(&vgasr_mutex);\n\tclient = find_client_from_pci(&vgasr_priv.clients, pdev);\n\tif (!client)\n\t\tret = VGA_SWITCHEROO_NOT_FOUND;\n\telse\n\t\tret = vga_switcheroo_pwr_state(client);\n\tmutex_unlock(&vgasr_mutex);\n\treturn ret;\n}\nEXPORT_SYMBOL(vga_switcheroo_get_client_state);\n\n \nvoid vga_switcheroo_unregister_client(struct pci_dev *pdev)\n{\n\tstruct vga_switcheroo_client *client;\n\n\tmutex_lock(&vgasr_mutex);\n\tclient = find_client_from_pci(&vgasr_priv.clients, pdev);\n\tif (client) {\n\t\tif (client_is_vga(client))\n\t\t\tvgasr_priv.registered_clients--;\n\t\tlist_del(&client->list);\n\t\tkfree(client);\n\t}\n\tif (vgasr_priv.active && vgasr_priv.registered_clients < 2) {\n\t\tpr_info(\"disabled\\n\");\n\t\tvga_switcheroo_debugfs_fini(&vgasr_priv);\n\t\tvgasr_priv.active = false;\n\t}\n\tmutex_unlock(&vgasr_mutex);\n}\nEXPORT_SYMBOL(vga_switcheroo_unregister_client);\n\n \nvoid vga_switcheroo_client_fb_set(struct pci_dev *pdev,\n\t\t\t\t struct fb_info *info)\n{\n\tstruct vga_switcheroo_client *client;\n\n\tmutex_lock(&vgasr_mutex);\n\tclient = find_client_from_pci(&vgasr_priv.clients, pdev);\n\tif (client)\n\t\tclient->fb_info = info;\n\tmutex_unlock(&vgasr_mutex);\n}\nEXPORT_SYMBOL(vga_switcheroo_client_fb_set);\n\n \nint vga_switcheroo_lock_ddc(struct pci_dev *pdev)\n{\n\tenum vga_switcheroo_client_id id;\n\n\tmutex_lock(&vgasr_priv.mux_hw_lock);\n\tif (!vgasr_priv.handler || !vgasr_priv.handler->switch_ddc) {\n\t\tvgasr_priv.old_ddc_owner = -ENODEV;\n\t\treturn -ENODEV;\n\t}\n\n\tid = vgasr_priv.handler->get_client_id(pdev);\n\tvgasr_priv.old_ddc_owner = vgasr_priv.handler->switch_ddc(id);\n\treturn vgasr_priv.old_ddc_owner;\n}\nEXPORT_SYMBOL(vga_switcheroo_lock_ddc);\n\n \nint vga_switcheroo_unlock_ddc(struct pci_dev *pdev)\n{\n\tenum vga_switcheroo_client_id id;\n\tint ret = vgasr_priv.old_ddc_owner;\n\n\tif (WARN_ON_ONCE(!mutex_is_locked(&vgasr_priv.mux_hw_lock)))\n\t\treturn -EINVAL;\n\n\tif (vgasr_priv.old_ddc_owner >= 0) {\n\t\tid = vgasr_priv.handler->get_client_id(pdev);\n\t\tif (vgasr_priv.old_ddc_owner != id)\n\t\t\tret = vgasr_priv.handler->switch_ddc(\n\t\t\t\t\t\t     vgasr_priv.old_ddc_owner);\n\t}\n\tmutex_unlock(&vgasr_priv.mux_hw_lock);\n\treturn ret;\n}\nEXPORT_SYMBOL(vga_switcheroo_unlock_ddc);\n\n \n\nstatic int vga_switcheroo_show(struct seq_file *m, void *v)\n{\n\tstruct vga_switcheroo_client *client;\n\tint i = 0;\n\n\tmutex_lock(&vgasr_mutex);\n\tlist_for_each_entry(client, &vgasr_priv.clients, list) {\n\t\tseq_printf(m, \"%d:%s%s:%c:%s%s:%s\\n\", i,\n\t\t\t   client_id(client) == VGA_SWITCHEROO_DIS ? \"DIS\" :\n\t\t\t\t\t\t\t\t     \"IGD\",\n\t\t\t   client_is_vga(client) ? \"\" : \"-Audio\",\n\t\t\t   client->active ? '+' : ' ',\n\t\t\t   client->driver_power_control ? \"Dyn\" : \"\",\n\t\t\t   vga_switcheroo_pwr_state(client) ? \"Pwr\" : \"Off\",\n\t\t\t   pci_name(client->pdev));\n\t\ti++;\n\t}\n\tmutex_unlock(&vgasr_mutex);\n\treturn 0;\n}\n\nstatic int vga_switcheroo_debugfs_open(struct inode *inode, struct file *file)\n{\n\treturn single_open(file, vga_switcheroo_show, NULL);\n}\n\nstatic int vga_switchon(struct vga_switcheroo_client *client)\n{\n\tif (client->driver_power_control)\n\t\treturn 0;\n\tif (vgasr_priv.handler->power_state)\n\t\tvgasr_priv.handler->power_state(client->id, VGA_SWITCHEROO_ON);\n\t \n\tclient->ops->set_gpu_state(client->pdev, VGA_SWITCHEROO_ON);\n\tclient->pwr_state = VGA_SWITCHEROO_ON;\n\treturn 0;\n}\n\nstatic int vga_switchoff(struct vga_switcheroo_client *client)\n{\n\tif (client->driver_power_control)\n\t\treturn 0;\n\t \n\tclient->ops->set_gpu_state(client->pdev, VGA_SWITCHEROO_OFF);\n\tif (vgasr_priv.handler->power_state)\n\t\tvgasr_priv.handler->power_state(client->id, VGA_SWITCHEROO_OFF);\n\tclient->pwr_state = VGA_SWITCHEROO_OFF;\n\treturn 0;\n}\n\nstatic void set_audio_state(enum vga_switcheroo_client_id id,\n\t\t\t    enum vga_switcheroo_state state)\n{\n\tstruct vga_switcheroo_client *client;\n\n\tclient = find_client_from_id(&vgasr_priv.clients, id | ID_BIT_AUDIO);\n\tif (client)\n\t\tclient->ops->set_gpu_state(client->pdev, state);\n}\n\n \nstatic int vga_switchto_stage1(struct vga_switcheroo_client *new_client)\n{\n\tstruct vga_switcheroo_client *active;\n\n\tactive = find_active_client(&vgasr_priv.clients);\n\tif (!active)\n\t\treturn 0;\n\n\tif (vga_switcheroo_pwr_state(new_client) == VGA_SWITCHEROO_OFF)\n\t\tvga_switchon(new_client);\n\n\tvga_set_default_device(new_client->pdev);\n\treturn 0;\n}\n\n \nstatic int vga_switchto_stage2(struct vga_switcheroo_client *new_client)\n{\n\tint ret;\n\tstruct vga_switcheroo_client *active;\n\n\tactive = find_active_client(&vgasr_priv.clients);\n\tif (!active)\n\t\treturn 0;\n\n\tactive->active = false;\n\n\t \n\tif (!active->driver_power_control)\n\t\tset_audio_state(active->id, VGA_SWITCHEROO_OFF);\n\n\tif (new_client->fb_info)\n\t\tfbcon_remap_all(new_client->fb_info);\n\n\tmutex_lock(&vgasr_priv.mux_hw_lock);\n\tret = vgasr_priv.handler->switchto(new_client->id);\n\tmutex_unlock(&vgasr_priv.mux_hw_lock);\n\tif (ret)\n\t\treturn ret;\n\n\tif (new_client->ops->reprobe)\n\t\tnew_client->ops->reprobe(new_client->pdev);\n\n\tif (vga_switcheroo_pwr_state(active) == VGA_SWITCHEROO_ON)\n\t\tvga_switchoff(active);\n\n\t \n\tif (!new_client->driver_power_control)\n\t\tset_audio_state(new_client->id, VGA_SWITCHEROO_ON);\n\n\tnew_client->active = true;\n\treturn 0;\n}\n\nstatic bool check_can_switch(void)\n{\n\tstruct vga_switcheroo_client *client;\n\n\tlist_for_each_entry(client, &vgasr_priv.clients, list) {\n\t\tif (!client->ops->can_switch(client->pdev)) {\n\t\t\tpr_err(\"client %x refused switch\\n\", client->id);\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\n\nstatic ssize_t\nvga_switcheroo_debugfs_write(struct file *filp, const char __user *ubuf,\n\t\t\t     size_t cnt, loff_t *ppos)\n{\n\tchar usercmd[64];\n\tint ret;\n\tbool delay = false, can_switch;\n\tbool just_mux = false;\n\tenum vga_switcheroo_client_id client_id = VGA_SWITCHEROO_UNKNOWN_ID;\n\tstruct vga_switcheroo_client *client = NULL;\n\n\tif (cnt > 63)\n\t\tcnt = 63;\n\n\tif (copy_from_user(usercmd, ubuf, cnt))\n\t\treturn -EFAULT;\n\n\tmutex_lock(&vgasr_mutex);\n\n\tif (!vgasr_priv.active) {\n\t\tcnt = -EINVAL;\n\t\tgoto out;\n\t}\n\n\t \n\tif (strncmp(usercmd, \"OFF\", 3) == 0) {\n\t\tlist_for_each_entry(client, &vgasr_priv.clients, list) {\n\t\t\tif (client->active || client_is_audio(client))\n\t\t\t\tcontinue;\n\t\t\tif (client->driver_power_control)\n\t\t\t\tcontinue;\n\t\t\tset_audio_state(client->id, VGA_SWITCHEROO_OFF);\n\t\t\tif (client->pwr_state == VGA_SWITCHEROO_ON)\n\t\t\t\tvga_switchoff(client);\n\t\t}\n\t\tgoto out;\n\t}\n\t \n\tif (strncmp(usercmd, \"ON\", 2) == 0) {\n\t\tlist_for_each_entry(client, &vgasr_priv.clients, list) {\n\t\t\tif (client->active || client_is_audio(client))\n\t\t\t\tcontinue;\n\t\t\tif (client->driver_power_control)\n\t\t\t\tcontinue;\n\t\t\tif (client->pwr_state == VGA_SWITCHEROO_OFF)\n\t\t\t\tvga_switchon(client);\n\t\t\tset_audio_state(client->id, VGA_SWITCHEROO_ON);\n\t\t}\n\t\tgoto out;\n\t}\n\n\t \n\tif (strncmp(usercmd, \"DIGD\", 4) == 0) {\n\t\tclient_id = VGA_SWITCHEROO_IGD;\n\t\tdelay = true;\n\t}\n\n\tif (strncmp(usercmd, \"DDIS\", 4) == 0) {\n\t\tclient_id = VGA_SWITCHEROO_DIS;\n\t\tdelay = true;\n\t}\n\n\tif (strncmp(usercmd, \"IGD\", 3) == 0)\n\t\tclient_id = VGA_SWITCHEROO_IGD;\n\n\tif (strncmp(usercmd, \"DIS\", 3) == 0)\n\t\tclient_id = VGA_SWITCHEROO_DIS;\n\n\tif (strncmp(usercmd, \"MIGD\", 4) == 0) {\n\t\tjust_mux = true;\n\t\tclient_id = VGA_SWITCHEROO_IGD;\n\t}\n\tif (strncmp(usercmd, \"MDIS\", 4) == 0) {\n\t\tjust_mux = true;\n\t\tclient_id = VGA_SWITCHEROO_DIS;\n\t}\n\n\tif (client_id == VGA_SWITCHEROO_UNKNOWN_ID)\n\t\tgoto out;\n\tclient = find_client_from_id(&vgasr_priv.clients, client_id);\n\tif (!client)\n\t\tgoto out;\n\n\tvgasr_priv.delayed_switch_active = false;\n\n\tif (just_mux) {\n\t\tmutex_lock(&vgasr_priv.mux_hw_lock);\n\t\tret = vgasr_priv.handler->switchto(client_id);\n\t\tmutex_unlock(&vgasr_priv.mux_hw_lock);\n\t\tgoto out;\n\t}\n\n\tif (client->active)\n\t\tgoto out;\n\n\t \n\tcan_switch = check_can_switch();\n\n\tif (can_switch == false && delay == false)\n\t\tgoto out;\n\n\tif (can_switch) {\n\t\tret = vga_switchto_stage1(client);\n\t\tif (ret)\n\t\t\tpr_err(\"switching failed stage 1 %d\\n\", ret);\n\n\t\tret = vga_switchto_stage2(client);\n\t\tif (ret)\n\t\t\tpr_err(\"switching failed stage 2 %d\\n\", ret);\n\n\t} else {\n\t\tpr_info(\"setting delayed switch to client %d\\n\", client->id);\n\t\tvgasr_priv.delayed_switch_active = true;\n\t\tvgasr_priv.delayed_client_id = client_id;\n\n\t\tret = vga_switchto_stage1(client);\n\t\tif (ret)\n\t\t\tpr_err(\"delayed switching stage 1 failed %d\\n\", ret);\n\t}\n\nout:\n\tmutex_unlock(&vgasr_mutex);\n\treturn cnt;\n}\n\nstatic const struct file_operations vga_switcheroo_debugfs_fops = {\n\t.owner = THIS_MODULE,\n\t.open = vga_switcheroo_debugfs_open,\n\t.write = vga_switcheroo_debugfs_write,\n\t.read = seq_read,\n\t.llseek = seq_lseek,\n\t.release = single_release,\n};\n\nstatic void vga_switcheroo_debugfs_fini(struct vgasr_priv *priv)\n{\n\tdebugfs_remove_recursive(priv->debugfs_root);\n\tpriv->debugfs_root = NULL;\n}\n\nstatic void vga_switcheroo_debugfs_init(struct vgasr_priv *priv)\n{\n\t \n\tif (priv->debugfs_root)\n\t\treturn;\n\n\tpriv->debugfs_root = debugfs_create_dir(\"vgaswitcheroo\", NULL);\n\n\tdebugfs_create_file(\"switch\", 0644, priv->debugfs_root, NULL,\n\t\t\t    &vga_switcheroo_debugfs_fops);\n}\n\n \nint vga_switcheroo_process_delayed_switch(void)\n{\n\tstruct vga_switcheroo_client *client;\n\tint ret;\n\tint err = -EINVAL;\n\n\tmutex_lock(&vgasr_mutex);\n\tif (!vgasr_priv.delayed_switch_active)\n\t\tgoto err;\n\n\tpr_info(\"processing delayed switch to %d\\n\",\n\t\tvgasr_priv.delayed_client_id);\n\n\tclient = find_client_from_id(&vgasr_priv.clients,\n\t\t\t\t     vgasr_priv.delayed_client_id);\n\tif (!client || !check_can_switch())\n\t\tgoto err;\n\n\tret = vga_switchto_stage2(client);\n\tif (ret)\n\t\tpr_err(\"delayed switching failed stage 2 %d\\n\", ret);\n\n\tvgasr_priv.delayed_switch_active = false;\n\terr = 0;\nerr:\n\tmutex_unlock(&vgasr_mutex);\n\treturn err;\n}\nEXPORT_SYMBOL(vga_switcheroo_process_delayed_switch);\n\n \n\nstatic void vga_switcheroo_power_switch(struct pci_dev *pdev,\n\t\t\t\t\tenum vga_switcheroo_state state)\n{\n\tstruct vga_switcheroo_client *client;\n\n\tif (!vgasr_priv.handler->power_state)\n\t\treturn;\n\n\tclient = find_client_from_pci(&vgasr_priv.clients, pdev);\n\tif (!client)\n\t\treturn;\n\n\tif (!client->driver_power_control)\n\t\treturn;\n\n\tvgasr_priv.handler->power_state(client->id, state);\n}\n\n \nstatic int vga_switcheroo_runtime_suspend(struct device *dev)\n{\n\tstruct pci_dev *pdev = to_pci_dev(dev);\n\tint ret;\n\n\tret = dev->bus->pm->runtime_suspend(dev);\n\tif (ret)\n\t\treturn ret;\n\tmutex_lock(&vgasr_mutex);\n\tif (vgasr_priv.handler->switchto) {\n\t\tmutex_lock(&vgasr_priv.mux_hw_lock);\n\t\tvgasr_priv.handler->switchto(VGA_SWITCHEROO_IGD);\n\t\tmutex_unlock(&vgasr_priv.mux_hw_lock);\n\t}\n\tpci_bus_set_current_state(pdev->bus, PCI_D3cold);\n\tvga_switcheroo_power_switch(pdev, VGA_SWITCHEROO_OFF);\n\tmutex_unlock(&vgasr_mutex);\n\treturn 0;\n}\n\nstatic int vga_switcheroo_runtime_resume(struct device *dev)\n{\n\tstruct pci_dev *pdev = to_pci_dev(dev);\n\n\tmutex_lock(&vgasr_mutex);\n\tvga_switcheroo_power_switch(pdev, VGA_SWITCHEROO_ON);\n\tmutex_unlock(&vgasr_mutex);\n\tpci_resume_bus(pdev->bus);\n\treturn dev->bus->pm->runtime_resume(dev);\n}\n\n \nint vga_switcheroo_init_domain_pm_ops(struct device *dev,\n\t\t\t\t      struct dev_pm_domain *domain)\n{\n\t \n\tif (dev->bus && dev->bus->pm) {\n\t\tdomain->ops = *dev->bus->pm;\n\t\tdomain->ops.runtime_suspend = vga_switcheroo_runtime_suspend;\n\t\tdomain->ops.runtime_resume = vga_switcheroo_runtime_resume;\n\n\t\tdev_pm_domain_set(dev, domain);\n\t\treturn 0;\n\t}\n\tdev_pm_domain_set(dev, NULL);\n\treturn -EINVAL;\n}\nEXPORT_SYMBOL(vga_switcheroo_init_domain_pm_ops);\n\nvoid vga_switcheroo_fini_domain_pm_ops(struct device *dev)\n{\n\tdev_pm_domain_set(dev, NULL);\n}\nEXPORT_SYMBOL(vga_switcheroo_fini_domain_pm_ops);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}