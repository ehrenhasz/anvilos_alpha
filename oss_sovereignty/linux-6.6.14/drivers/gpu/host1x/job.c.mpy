{
  "module_name": "job.c",
  "hash_id": "9f76568dcc5b4faffbc3667ad24494c753ddec8f6294dc693b30f672da33031f",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/host1x/job.c",
  "human_readable_source": "\n \n\n#include <linux/dma-mapping.h>\n#include <linux/err.h>\n#include <linux/host1x.h>\n#include <linux/iommu.h>\n#include <linux/kref.h>\n#include <linux/module.h>\n#include <linux/scatterlist.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <trace/events/host1x.h>\n\n#include \"channel.h\"\n#include \"dev.h\"\n#include \"job.h\"\n#include \"syncpt.h\"\n\n#define HOST1X_WAIT_SYNCPT_OFFSET 0x8\n\nstruct host1x_job *host1x_job_alloc(struct host1x_channel *ch,\n\t\t\t\t    u32 num_cmdbufs, u32 num_relocs,\n\t\t\t\t    bool skip_firewall)\n{\n\tstruct host1x_job *job = NULL;\n\tunsigned int num_unpins = num_relocs;\n\tbool enable_firewall;\n\tu64 total;\n\tvoid *mem;\n\n\tenable_firewall = IS_ENABLED(CONFIG_TEGRA_HOST1X_FIREWALL) && !skip_firewall;\n\n\tif (!enable_firewall)\n\t\tnum_unpins += num_cmdbufs;\n\n\t \n\ttotal = sizeof(struct host1x_job) +\n\t\t(u64)num_relocs * sizeof(struct host1x_reloc) +\n\t\t(u64)num_unpins * sizeof(struct host1x_job_unpin_data) +\n\t\t(u64)num_cmdbufs * sizeof(struct host1x_job_cmd) +\n\t\t(u64)num_unpins * sizeof(dma_addr_t) +\n\t\t(u64)num_unpins * sizeof(u32 *);\n\tif (total > ULONG_MAX)\n\t\treturn NULL;\n\n\tmem = job = kzalloc(total, GFP_KERNEL);\n\tif (!job)\n\t\treturn NULL;\n\n\tjob->enable_firewall = enable_firewall;\n\n\tkref_init(&job->ref);\n\tjob->channel = ch;\n\n\t \n\tmem += sizeof(struct host1x_job);\n\tjob->relocs = num_relocs ? mem : NULL;\n\tmem += num_relocs * sizeof(struct host1x_reloc);\n\tjob->unpins = num_unpins ? mem : NULL;\n\tmem += num_unpins * sizeof(struct host1x_job_unpin_data);\n\tjob->cmds = num_cmdbufs ? mem : NULL;\n\tmem += num_cmdbufs * sizeof(struct host1x_job_cmd);\n\tjob->addr_phys = num_unpins ? mem : NULL;\n\n\tjob->reloc_addr_phys = job->addr_phys;\n\tjob->gather_addr_phys = &job->addr_phys[num_relocs];\n\n\treturn job;\n}\nEXPORT_SYMBOL(host1x_job_alloc);\n\nstruct host1x_job *host1x_job_get(struct host1x_job *job)\n{\n\tkref_get(&job->ref);\n\treturn job;\n}\nEXPORT_SYMBOL(host1x_job_get);\n\nstatic void job_free(struct kref *ref)\n{\n\tstruct host1x_job *job = container_of(ref, struct host1x_job, ref);\n\n\tif (job->release)\n\t\tjob->release(job);\n\n\tif (job->fence) {\n\t\t \n\t\tdma_fence_remove_callback(job->fence, &job->fence_cb);\n\t\tdma_fence_put(job->fence);\n\t}\n\n\tif (job->syncpt)\n\t\thost1x_syncpt_put(job->syncpt);\n\n\tkfree(job);\n}\n\nvoid host1x_job_put(struct host1x_job *job)\n{\n\tkref_put(&job->ref, job_free);\n}\nEXPORT_SYMBOL(host1x_job_put);\n\nvoid host1x_job_add_gather(struct host1x_job *job, struct host1x_bo *bo,\n\t\t\t   unsigned int words, unsigned int offset)\n{\n\tstruct host1x_job_gather *gather = &job->cmds[job->num_cmds].gather;\n\n\tgather->words = words;\n\tgather->bo = bo;\n\tgather->offset = offset;\n\n\tjob->num_cmds++;\n}\nEXPORT_SYMBOL(host1x_job_add_gather);\n\nvoid host1x_job_add_wait(struct host1x_job *job, u32 id, u32 thresh,\n\t\t\t bool relative, u32 next_class)\n{\n\tstruct host1x_job_cmd *cmd = &job->cmds[job->num_cmds];\n\n\tcmd->is_wait = true;\n\tcmd->wait.id = id;\n\tcmd->wait.threshold = thresh;\n\tcmd->wait.next_class = next_class;\n\tcmd->wait.relative = relative;\n\n\tjob->num_cmds++;\n}\nEXPORT_SYMBOL(host1x_job_add_wait);\n\nstatic unsigned int pin_job(struct host1x *host, struct host1x_job *job)\n{\n\tunsigned long mask = HOST1X_RELOC_READ | HOST1X_RELOC_WRITE;\n\tstruct host1x_client *client = job->client;\n\tstruct device *dev = client->dev;\n\tstruct host1x_job_gather *g;\n\tunsigned int i;\n\tint err;\n\n\tjob->num_unpins = 0;\n\n\tfor (i = 0; i < job->num_relocs; i++) {\n\t\tstruct host1x_reloc *reloc = &job->relocs[i];\n\t\tenum dma_data_direction direction;\n\t\tstruct host1x_bo_mapping *map;\n\t\tstruct host1x_bo *bo;\n\n\t\treloc->target.bo = host1x_bo_get(reloc->target.bo);\n\t\tif (!reloc->target.bo) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto unpin;\n\t\t}\n\n\t\tbo = reloc->target.bo;\n\n\t\tswitch (reloc->flags & mask) {\n\t\tcase HOST1X_RELOC_READ:\n\t\t\tdirection = DMA_TO_DEVICE;\n\t\t\tbreak;\n\n\t\tcase HOST1X_RELOC_WRITE:\n\t\t\tdirection = DMA_FROM_DEVICE;\n\t\t\tbreak;\n\n\t\tcase HOST1X_RELOC_READ | HOST1X_RELOC_WRITE:\n\t\t\tdirection = DMA_BIDIRECTIONAL;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\terr = -EINVAL;\n\t\t\tgoto unpin;\n\t\t}\n\n\t\tmap = host1x_bo_pin(dev, bo, direction, NULL);\n\t\tif (IS_ERR(map)) {\n\t\t\terr = PTR_ERR(map);\n\t\t\tgoto unpin;\n\t\t}\n\n\t\t \n\t\tif (map->chunks > 1) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto unpin;\n\t\t}\n\n\t\tjob->addr_phys[job->num_unpins] = map->phys;\n\t\tjob->unpins[job->num_unpins].map = map;\n\t\tjob->num_unpins++;\n\t}\n\n\t \n\tif (job->enable_firewall)\n\t\treturn 0;\n\n\tfor (i = 0; i < job->num_cmds; i++) {\n\t\tstruct host1x_bo_mapping *map;\n\t\tsize_t gather_size = 0;\n\t\tstruct scatterlist *sg;\n\t\tunsigned long shift;\n\t\tstruct iova *alloc;\n\t\tunsigned int j;\n\n\t\tif (job->cmds[i].is_wait)\n\t\t\tcontinue;\n\n\t\tg = &job->cmds[i].gather;\n\n\t\tg->bo = host1x_bo_get(g->bo);\n\t\tif (!g->bo) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto unpin;\n\t\t}\n\n\t\tmap = host1x_bo_pin(host->dev, g->bo, DMA_TO_DEVICE, NULL);\n\t\tif (IS_ERR(map)) {\n\t\t\terr = PTR_ERR(map);\n\t\t\tgoto unpin;\n\t\t}\n\n\t\tif (host->domain) {\n\t\t\tfor_each_sgtable_sg(map->sgt, sg, j)\n\t\t\t\tgather_size += sg->length;\n\n\t\t\tgather_size = iova_align(&host->iova, gather_size);\n\n\t\t\tshift = iova_shift(&host->iova);\n\t\t\talloc = alloc_iova(&host->iova, gather_size >> shift,\n\t\t\t\t\t   host->iova_end >> shift, true);\n\t\t\tif (!alloc) {\n\t\t\t\terr = -ENOMEM;\n\t\t\t\tgoto put;\n\t\t\t}\n\n\t\t\terr = iommu_map_sgtable(host->domain, iova_dma_addr(&host->iova, alloc),\n\t\t\t\t\t\tmap->sgt, IOMMU_READ);\n\t\t\tif (err == 0) {\n\t\t\t\t__free_iova(&host->iova, alloc);\n\t\t\t\terr = -EINVAL;\n\t\t\t\tgoto put;\n\t\t\t}\n\n\t\t\tmap->phys = iova_dma_addr(&host->iova, alloc);\n\t\t\tmap->size = gather_size;\n\t\t}\n\n\t\tjob->addr_phys[job->num_unpins] = map->phys;\n\t\tjob->unpins[job->num_unpins].map = map;\n\t\tjob->num_unpins++;\n\n\t\tjob->gather_addr_phys[i] = map->phys;\n\t}\n\n\treturn 0;\n\nput:\n\thost1x_bo_put(g->bo);\nunpin:\n\thost1x_job_unpin(job);\n\treturn err;\n}\n\nstatic int do_relocs(struct host1x_job *job, struct host1x_job_gather *g)\n{\n\tvoid *cmdbuf_addr = NULL;\n\tstruct host1x_bo *cmdbuf = g->bo;\n\tunsigned int i;\n\n\t \n\tfor (i = 0; i < job->num_relocs; i++) {\n\t\tstruct host1x_reloc *reloc = &job->relocs[i];\n\t\tu32 reloc_addr = (job->reloc_addr_phys[i] +\n\t\t\t\t  reloc->target.offset) >> reloc->shift;\n\t\tu32 *target;\n\n\t\t \n\t\tif (cmdbuf != reloc->cmdbuf.bo)\n\t\t\tcontinue;\n\n\t\tif (job->enable_firewall) {\n\t\t\ttarget = (u32 *)job->gather_copy_mapped +\n\t\t\t\t\treloc->cmdbuf.offset / sizeof(u32) +\n\t\t\t\t\t\tg->offset / sizeof(u32);\n\t\t\tgoto patch_reloc;\n\t\t}\n\n\t\tif (!cmdbuf_addr) {\n\t\t\tcmdbuf_addr = host1x_bo_mmap(cmdbuf);\n\n\t\t\tif (unlikely(!cmdbuf_addr)) {\n\t\t\t\tpr_err(\"Could not map cmdbuf for relocation\\n\");\n\t\t\t\treturn -ENOMEM;\n\t\t\t}\n\t\t}\n\n\t\ttarget = cmdbuf_addr + reloc->cmdbuf.offset;\npatch_reloc:\n\t\t*target = reloc_addr;\n\t}\n\n\tif (cmdbuf_addr)\n\t\thost1x_bo_munmap(cmdbuf, cmdbuf_addr);\n\n\treturn 0;\n}\n\nstatic bool check_reloc(struct host1x_reloc *reloc, struct host1x_bo *cmdbuf,\n\t\t\tunsigned int offset)\n{\n\toffset *= sizeof(u32);\n\n\tif (reloc->cmdbuf.bo != cmdbuf || reloc->cmdbuf.offset != offset)\n\t\treturn false;\n\n\t \n\tif (reloc->shift)\n\t\treturn false;\n\n\treturn true;\n}\n\nstruct host1x_firewall {\n\tstruct host1x_job *job;\n\tstruct device *dev;\n\n\tunsigned int num_relocs;\n\tstruct host1x_reloc *reloc;\n\n\tstruct host1x_bo *cmdbuf;\n\tunsigned int offset;\n\n\tu32 words;\n\tu32 class;\n\tu32 reg;\n\tu32 mask;\n\tu32 count;\n};\n\nstatic int check_register(struct host1x_firewall *fw, unsigned long offset)\n{\n\tif (!fw->job->is_addr_reg)\n\t\treturn 0;\n\n\tif (fw->job->is_addr_reg(fw->dev, fw->class, offset)) {\n\t\tif (!fw->num_relocs)\n\t\t\treturn -EINVAL;\n\n\t\tif (!check_reloc(fw->reloc, fw->cmdbuf, fw->offset))\n\t\t\treturn -EINVAL;\n\n\t\tfw->num_relocs--;\n\t\tfw->reloc++;\n\t}\n\n\treturn 0;\n}\n\nstatic int check_class(struct host1x_firewall *fw, u32 class)\n{\n\tif (!fw->job->is_valid_class) {\n\t\tif (fw->class != class)\n\t\t\treturn -EINVAL;\n\t} else {\n\t\tif (!fw->job->is_valid_class(fw->class))\n\t\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int check_mask(struct host1x_firewall *fw)\n{\n\tu32 mask = fw->mask;\n\tu32 reg = fw->reg;\n\tint ret;\n\n\twhile (mask) {\n\t\tif (fw->words == 0)\n\t\t\treturn -EINVAL;\n\n\t\tif (mask & 1) {\n\t\t\tret = check_register(fw, reg);\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\n\t\t\tfw->words--;\n\t\t\tfw->offset++;\n\t\t}\n\t\tmask >>= 1;\n\t\treg++;\n\t}\n\n\treturn 0;\n}\n\nstatic int check_incr(struct host1x_firewall *fw)\n{\n\tu32 count = fw->count;\n\tu32 reg = fw->reg;\n\tint ret;\n\n\twhile (count) {\n\t\tif (fw->words == 0)\n\t\t\treturn -EINVAL;\n\n\t\tret = check_register(fw, reg);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\treg++;\n\t\tfw->words--;\n\t\tfw->offset++;\n\t\tcount--;\n\t}\n\n\treturn 0;\n}\n\nstatic int check_nonincr(struct host1x_firewall *fw)\n{\n\tu32 count = fw->count;\n\tint ret;\n\n\twhile (count) {\n\t\tif (fw->words == 0)\n\t\t\treturn -EINVAL;\n\n\t\tret = check_register(fw, fw->reg);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tfw->words--;\n\t\tfw->offset++;\n\t\tcount--;\n\t}\n\n\treturn 0;\n}\n\nstatic int validate(struct host1x_firewall *fw, struct host1x_job_gather *g)\n{\n\tu32 *cmdbuf_base = (u32 *)fw->job->gather_copy_mapped +\n\t\t(g->offset / sizeof(u32));\n\tu32 job_class = fw->class;\n\tint err = 0;\n\n\tfw->words = g->words;\n\tfw->cmdbuf = g->bo;\n\tfw->offset = 0;\n\n\twhile (fw->words && !err) {\n\t\tu32 word = cmdbuf_base[fw->offset];\n\t\tu32 opcode = (word & 0xf0000000) >> 28;\n\n\t\tfw->mask = 0;\n\t\tfw->reg = 0;\n\t\tfw->count = 0;\n\t\tfw->words--;\n\t\tfw->offset++;\n\n\t\tswitch (opcode) {\n\t\tcase 0:\n\t\t\tfw->class = word >> 6 & 0x3ff;\n\t\t\tfw->mask = word & 0x3f;\n\t\t\tfw->reg = word >> 16 & 0xfff;\n\t\t\terr = check_class(fw, job_class);\n\t\t\tif (!err)\n\t\t\t\terr = check_mask(fw);\n\t\t\tif (err)\n\t\t\t\tgoto out;\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tfw->reg = word >> 16 & 0xfff;\n\t\t\tfw->count = word & 0xffff;\n\t\t\terr = check_incr(fw);\n\t\t\tif (err)\n\t\t\t\tgoto out;\n\t\t\tbreak;\n\n\t\tcase 2:\n\t\t\tfw->reg = word >> 16 & 0xfff;\n\t\t\tfw->count = word & 0xffff;\n\t\t\terr = check_nonincr(fw);\n\t\t\tif (err)\n\t\t\t\tgoto out;\n\t\t\tbreak;\n\n\t\tcase 3:\n\t\t\tfw->mask = word & 0xffff;\n\t\t\tfw->reg = word >> 16 & 0xfff;\n\t\t\terr = check_mask(fw);\n\t\t\tif (err)\n\t\t\t\tgoto out;\n\t\t\tbreak;\n\t\tcase 4:\n\t\tcase 14:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\terr = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\t}\n\nout:\n\treturn err;\n}\n\nstatic inline int copy_gathers(struct device *host, struct host1x_job *job,\n\t\t\t       struct device *dev)\n{\n\tstruct host1x_firewall fw;\n\tsize_t size = 0;\n\tsize_t offset = 0;\n\tunsigned int i;\n\n\tfw.job = job;\n\tfw.dev = dev;\n\tfw.reloc = job->relocs;\n\tfw.num_relocs = job->num_relocs;\n\tfw.class = job->class;\n\n\tfor (i = 0; i < job->num_cmds; i++) {\n\t\tstruct host1x_job_gather *g;\n\n\t\tif (job->cmds[i].is_wait)\n\t\t\tcontinue;\n\n\t\tg = &job->cmds[i].gather;\n\n\t\tsize += g->words * sizeof(u32);\n\t}\n\n\t \n\tjob->gather_copy_mapped = dma_alloc_wc(host, size, &job->gather_copy,\n\t\t\t\t\t       GFP_NOWAIT);\n\n\t \n\tif (!job->gather_copy_mapped)\n\t\tjob->gather_copy_mapped = dma_alloc_wc(host, size,\n\t\t\t\t\t\t       &job->gather_copy,\n\t\t\t\t\t\t       GFP_KERNEL);\n\tif (!job->gather_copy_mapped)\n\t\treturn -ENOMEM;\n\n\tjob->gather_copy_size = size;\n\n\tfor (i = 0; i < job->num_cmds; i++) {\n\t\tstruct host1x_job_gather *g;\n\t\tvoid *gather;\n\n\t\tif (job->cmds[i].is_wait)\n\t\t\tcontinue;\n\t\tg = &job->cmds[i].gather;\n\n\t\t \n\t\tgather = host1x_bo_mmap(g->bo);\n\t\tmemcpy(job->gather_copy_mapped + offset, gather + g->offset,\n\t\t       g->words * sizeof(u32));\n\t\thost1x_bo_munmap(g->bo, gather);\n\n\t\t \n\t\tg->base = job->gather_copy;\n\t\tg->offset = offset;\n\n\t\t \n\t\tif (validate(&fw, g))\n\t\t\treturn -EINVAL;\n\n\t\toffset += g->words * sizeof(u32);\n\t}\n\n\t \n\tif (fw.num_relocs)\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nint host1x_job_pin(struct host1x_job *job, struct device *dev)\n{\n\tint err;\n\tunsigned int i, j;\n\tstruct host1x *host = dev_get_drvdata(dev->parent);\n\n\t \n\terr = pin_job(host, job);\n\tif (err)\n\t\tgoto out;\n\n\tif (job->enable_firewall) {\n\t\terr = copy_gathers(host->dev, job, dev);\n\t\tif (err)\n\t\t\tgoto out;\n\t}\n\n\t \n\tfor (i = 0; i < job->num_cmds; i++) {\n\t\tstruct host1x_job_gather *g;\n\n\t\tif (job->cmds[i].is_wait)\n\t\t\tcontinue;\n\t\tg = &job->cmds[i].gather;\n\n\t\t \n\t\tif (g->handled)\n\t\t\tcontinue;\n\n\t\t \n\t\tif (!job->enable_firewall)\n\t\t\tg->base = job->gather_addr_phys[i];\n\n\t\tfor (j = i + 1; j < job->num_cmds; j++) {\n\t\t\tif (!job->cmds[j].is_wait &&\n\t\t\t    job->cmds[j].gather.bo == g->bo) {\n\t\t\t\tjob->cmds[j].gather.handled = true;\n\t\t\t\tjob->cmds[j].gather.base = g->base;\n\t\t\t}\n\t\t}\n\n\t\terr = do_relocs(job, g);\n\t\tif (err)\n\t\t\tbreak;\n\t}\n\nout:\n\tif (err)\n\t\thost1x_job_unpin(job);\n\twmb();\n\n\treturn err;\n}\nEXPORT_SYMBOL(host1x_job_pin);\n\nvoid host1x_job_unpin(struct host1x_job *job)\n{\n\tstruct host1x *host = dev_get_drvdata(job->channel->dev->parent);\n\tunsigned int i;\n\n\tfor (i = 0; i < job->num_unpins; i++) {\n\t\tstruct host1x_bo_mapping *map = job->unpins[i].map;\n\t\tstruct host1x_bo *bo = map->bo;\n\n\t\tif (!job->enable_firewall && map->size && host->domain) {\n\t\t\tiommu_unmap(host->domain, job->addr_phys[i], map->size);\n\t\t\tfree_iova(&host->iova, iova_pfn(&host->iova, job->addr_phys[i]));\n\t\t}\n\n\t\thost1x_bo_unpin(map);\n\t\thost1x_bo_put(bo);\n\t}\n\n\tjob->num_unpins = 0;\n\n\tif (job->gather_copy_size)\n\t\tdma_free_wc(host->dev, job->gather_copy_size,\n\t\t\t    job->gather_copy_mapped, job->gather_copy);\n}\nEXPORT_SYMBOL(host1x_job_unpin);\n\n \nvoid host1x_job_dump(struct device *dev, struct host1x_job *job)\n{\n\tdev_dbg(dev, \"    SYNCPT_ID   %d\\n\", job->syncpt->id);\n\tdev_dbg(dev, \"    SYNCPT_VAL  %d\\n\", job->syncpt_end);\n\tdev_dbg(dev, \"    FIRST_GET   0x%x\\n\", job->first_get);\n\tdev_dbg(dev, \"    TIMEOUT     %d\\n\", job->timeout);\n\tdev_dbg(dev, \"    NUM_SLOTS   %d\\n\", job->num_slots);\n\tdev_dbg(dev, \"    NUM_HANDLES %d\\n\", job->num_unpins);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}