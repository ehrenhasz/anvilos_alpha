{
  "module_name": "channel.c",
  "hash_id": "9d96acd481c0809af07cc9a32e6cf1374a6f14834eb75ec0492a85d26adb1d53",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/host1x/channel.c",
  "human_readable_source": "\n \n\n#include <linux/slab.h>\n#include <linux/module.h>\n\n#include \"channel.h\"\n#include \"dev.h\"\n#include \"job.h\"\n\n \nint host1x_channel_list_init(struct host1x_channel_list *chlist,\n\t\t\t     unsigned int num_channels)\n{\n\tchlist->channels = kcalloc(num_channels, sizeof(struct host1x_channel),\n\t\t\t\t   GFP_KERNEL);\n\tif (!chlist->channels)\n\t\treturn -ENOMEM;\n\n\tchlist->allocated_channels = bitmap_zalloc(num_channels, GFP_KERNEL);\n\tif (!chlist->allocated_channels) {\n\t\tkfree(chlist->channels);\n\t\treturn -ENOMEM;\n\t}\n\n\treturn 0;\n}\n\nvoid host1x_channel_list_free(struct host1x_channel_list *chlist)\n{\n\tbitmap_free(chlist->allocated_channels);\n\tkfree(chlist->channels);\n}\n\nint host1x_job_submit(struct host1x_job *job)\n{\n\tstruct host1x *host = dev_get_drvdata(job->channel->dev->parent);\n\n\treturn host1x_hw_channel_submit(host, job);\n}\nEXPORT_SYMBOL(host1x_job_submit);\n\nstruct host1x_channel *host1x_channel_get(struct host1x_channel *channel)\n{\n\tkref_get(&channel->refcount);\n\n\treturn channel;\n}\nEXPORT_SYMBOL(host1x_channel_get);\n\n \nstruct host1x_channel *host1x_channel_get_index(struct host1x *host,\n\t\t\t\t\t\tunsigned int index)\n{\n\tstruct host1x_channel *ch = &host->channel_list.channels[index];\n\n\tif (!kref_get_unless_zero(&ch->refcount))\n\t\treturn NULL;\n\n\treturn ch;\n}\n\nvoid host1x_channel_stop(struct host1x_channel *channel)\n{\n\tstruct host1x *host = dev_get_drvdata(channel->dev->parent);\n\n\thost1x_hw_cdma_stop(host, &channel->cdma);\n}\nEXPORT_SYMBOL(host1x_channel_stop);\n\nstatic void release_channel(struct kref *kref)\n{\n\tstruct host1x_channel *channel =\n\t\tcontainer_of(kref, struct host1x_channel, refcount);\n\tstruct host1x *host = dev_get_drvdata(channel->dev->parent);\n\tstruct host1x_channel_list *chlist = &host->channel_list;\n\n\thost1x_hw_cdma_stop(host, &channel->cdma);\n\thost1x_cdma_deinit(&channel->cdma);\n\n\tclear_bit(channel->id, chlist->allocated_channels);\n}\n\nvoid host1x_channel_put(struct host1x_channel *channel)\n{\n\tkref_put(&channel->refcount, release_channel);\n}\nEXPORT_SYMBOL(host1x_channel_put);\n\nstatic struct host1x_channel *acquire_unused_channel(struct host1x *host)\n{\n\tstruct host1x_channel_list *chlist = &host->channel_list;\n\tunsigned int max_channels = host->info->nb_channels;\n\tunsigned int index;\n\n\tindex = find_first_zero_bit(chlist->allocated_channels, max_channels);\n\tif (index >= max_channels) {\n\t\tdev_err(host->dev, \"failed to find free channel\\n\");\n\t\treturn NULL;\n\t}\n\n\tchlist->channels[index].id = index;\n\n\tset_bit(index, chlist->allocated_channels);\n\n\treturn &chlist->channels[index];\n}\n\n \nstruct host1x_channel *host1x_channel_request(struct host1x_client *client)\n{\n\tstruct host1x *host = dev_get_drvdata(client->dev->parent);\n\tstruct host1x_channel_list *chlist = &host->channel_list;\n\tstruct host1x_channel *channel;\n\tint err;\n\n\tchannel = acquire_unused_channel(host);\n\tif (!channel)\n\t\treturn NULL;\n\n\tkref_init(&channel->refcount);\n\tmutex_init(&channel->submitlock);\n\tchannel->client = client;\n\tchannel->dev = client->dev;\n\n\terr = host1x_hw_channel_init(host, channel, channel->id);\n\tif (err < 0)\n\t\tgoto fail;\n\n\terr = host1x_cdma_init(&channel->cdma);\n\tif (err < 0)\n\t\tgoto fail;\n\n\treturn channel;\n\nfail:\n\tclear_bit(channel->id, chlist->allocated_channels);\n\n\tdev_err(client->dev, \"failed to initialize channel\\n\");\n\n\treturn NULL;\n}\nEXPORT_SYMBOL(host1x_channel_request);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}