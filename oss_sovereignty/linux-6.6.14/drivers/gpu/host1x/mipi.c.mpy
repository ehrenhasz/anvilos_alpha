{
  "module_name": "mipi.c",
  "hash_id": "32695060b04d2f7613d1c17d9f0a6b47f7b1446c973cefdf4ee1fc2a1fbdd856",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/host1x/mipi.c",
  "human_readable_source": " \n\n#include <linux/clk.h>\n#include <linux/host1x.h>\n#include <linux/io.h>\n#include <linux/iopoll.h>\n#include <linux/of_platform.h>\n#include <linux/platform_device.h>\n#include <linux/slab.h>\n\n#include \"dev.h\"\n\n#define MIPI_CAL_CTRL\t\t\t0x00\n#define MIPI_CAL_CTRL_NOISE_FILTER(x)\t(((x) & 0xf) << 26)\n#define MIPI_CAL_CTRL_PRESCALE(x)\t(((x) & 0x3) << 24)\n#define MIPI_CAL_CTRL_CLKEN_OVR\t\t(1 << 4)\n#define MIPI_CAL_CTRL_START\t\t(1 << 0)\n\n#define MIPI_CAL_AUTOCAL_CTRL\t\t0x01\n\n#define MIPI_CAL_STATUS\t\t\t0x02\n#define MIPI_CAL_STATUS_DONE\t\t(1 << 16)\n#define MIPI_CAL_STATUS_ACTIVE\t\t(1 <<  0)\n\n#define MIPI_CAL_CONFIG_CSIA\t\t0x05\n#define MIPI_CAL_CONFIG_CSIB\t\t0x06\n#define MIPI_CAL_CONFIG_CSIC\t\t0x07\n#define MIPI_CAL_CONFIG_CSID\t\t0x08\n#define MIPI_CAL_CONFIG_CSIE\t\t0x09\n#define MIPI_CAL_CONFIG_CSIF\t\t0x0a\n#define MIPI_CAL_CONFIG_DSIA\t\t0x0e\n#define MIPI_CAL_CONFIG_DSIB\t\t0x0f\n#define MIPI_CAL_CONFIG_DSIC\t\t0x10\n#define MIPI_CAL_CONFIG_DSID\t\t0x11\n\n#define MIPI_CAL_CONFIG_DSIA_CLK\t0x19\n#define MIPI_CAL_CONFIG_DSIB_CLK\t0x1a\n#define MIPI_CAL_CONFIG_CSIAB_CLK\t0x1b\n#define MIPI_CAL_CONFIG_DSIC_CLK\t0x1c\n#define MIPI_CAL_CONFIG_CSICD_CLK\t0x1c\n#define MIPI_CAL_CONFIG_DSID_CLK\t0x1d\n#define MIPI_CAL_CONFIG_CSIE_CLK\t0x1d\n\n \n#define MIPI_CAL_CONFIG_SELECT\t\t(1 << 21)\n\n \n#define MIPI_CAL_CONFIG_HSPDOS(x)\t(((x) & 0x1f) << 16)\n#define MIPI_CAL_CONFIG_HSPUOS(x)\t(((x) & 0x1f) <<  8)\n#define MIPI_CAL_CONFIG_TERMOS(x)\t(((x) & 0x1f) <<  0)\n\n \n#define MIPI_CAL_CONFIG_HSCLKPDOSD(x)\t(((x) & 0x1f) <<  8)\n#define MIPI_CAL_CONFIG_HSCLKPUOSD(x)\t(((x) & 0x1f) <<  0)\n\n#define MIPI_CAL_BIAS_PAD_CFG0\t\t0x16\n#define MIPI_CAL_BIAS_PAD_PDVCLAMP\t(1 << 1)\n#define MIPI_CAL_BIAS_PAD_E_VCLAMP_REF\t(1 << 0)\n\n#define MIPI_CAL_BIAS_PAD_CFG1\t\t0x17\n#define MIPI_CAL_BIAS_PAD_DRV_DN_REF(x) (((x) & 0x7) << 16)\n#define MIPI_CAL_BIAS_PAD_DRV_UP_REF(x) (((x) & 0x7) << 8)\n\n#define MIPI_CAL_BIAS_PAD_CFG2\t\t0x18\n#define MIPI_CAL_BIAS_PAD_VCLAMP(x)\t(((x) & 0x7) << 16)\n#define MIPI_CAL_BIAS_PAD_VAUXP(x)\t(((x) & 0x7) << 4)\n#define MIPI_CAL_BIAS_PAD_PDVREG\t(1 << 1)\n\nstruct tegra_mipi_pad {\n\tunsigned long data;\n\tunsigned long clk;\n};\n\nstruct tegra_mipi_soc {\n\tbool has_clk_lane;\n\tconst struct tegra_mipi_pad *pads;\n\tunsigned int num_pads;\n\n\tbool clock_enable_override;\n\tbool needs_vclamp_ref;\n\n\t \n\tu8 pad_drive_down_ref;\n\tu8 pad_drive_up_ref;\n\n\tu8 pad_vclamp_level;\n\tu8 pad_vauxp_level;\n\n\t \n\tu8 hspdos;\n\tu8 hspuos;\n\tu8 termos;\n\n\t \n\tu8 hsclkpdos;\n\tu8 hsclkpuos;\n};\n\nstruct tegra_mipi {\n\tconst struct tegra_mipi_soc *soc;\n\tstruct device *dev;\n\tvoid __iomem *regs;\n\tstruct mutex lock;\n\tstruct clk *clk;\n\n\tunsigned long usage_count;\n};\n\nstruct tegra_mipi_device {\n\tstruct platform_device *pdev;\n\tstruct tegra_mipi *mipi;\n\tstruct device *device;\n\tunsigned long pads;\n};\n\nstatic inline u32 tegra_mipi_readl(struct tegra_mipi *mipi,\n\t\t\t\t   unsigned long offset)\n{\n\treturn readl(mipi->regs + (offset << 2));\n}\n\nstatic inline void tegra_mipi_writel(struct tegra_mipi *mipi, u32 value,\n\t\t\t\t     unsigned long offset)\n{\n\twritel(value, mipi->regs + (offset << 2));\n}\n\nstatic int tegra_mipi_power_up(struct tegra_mipi *mipi)\n{\n\tu32 value;\n\tint err;\n\n\terr = clk_enable(mipi->clk);\n\tif (err < 0)\n\t\treturn err;\n\n\tvalue = tegra_mipi_readl(mipi, MIPI_CAL_BIAS_PAD_CFG0);\n\tvalue &= ~MIPI_CAL_BIAS_PAD_PDVCLAMP;\n\n\tif (mipi->soc->needs_vclamp_ref)\n\t\tvalue |= MIPI_CAL_BIAS_PAD_E_VCLAMP_REF;\n\n\ttegra_mipi_writel(mipi, value, MIPI_CAL_BIAS_PAD_CFG0);\n\n\tvalue = tegra_mipi_readl(mipi, MIPI_CAL_BIAS_PAD_CFG2);\n\tvalue &= ~MIPI_CAL_BIAS_PAD_PDVREG;\n\ttegra_mipi_writel(mipi, value, MIPI_CAL_BIAS_PAD_CFG2);\n\n\tclk_disable(mipi->clk);\n\n\treturn 0;\n}\n\nstatic int tegra_mipi_power_down(struct tegra_mipi *mipi)\n{\n\tu32 value;\n\tint err;\n\n\terr = clk_enable(mipi->clk);\n\tif (err < 0)\n\t\treturn err;\n\n\t \n\tvalue = tegra_mipi_readl(mipi, MIPI_CAL_BIAS_PAD_CFG2);\n\tvalue |= MIPI_CAL_BIAS_PAD_PDVREG;\n\ttegra_mipi_writel(mipi, value, MIPI_CAL_BIAS_PAD_CFG2);\n\n\t \n\tvalue = tegra_mipi_readl(mipi, MIPI_CAL_BIAS_PAD_CFG0);\n\n\tif (mipi->soc->needs_vclamp_ref)\n\t\tvalue &= ~MIPI_CAL_BIAS_PAD_E_VCLAMP_REF;\n\n\tvalue |= MIPI_CAL_BIAS_PAD_PDVCLAMP;\n\ttegra_mipi_writel(mipi, value, MIPI_CAL_BIAS_PAD_CFG0);\n\n\treturn 0;\n}\n\nstruct tegra_mipi_device *tegra_mipi_request(struct device *device,\n\t\t\t\t\t     struct device_node *np)\n{\n\tstruct tegra_mipi_device *dev;\n\tstruct of_phandle_args args;\n\tint err;\n\n\terr = of_parse_phandle_with_args(np, \"nvidia,mipi-calibrate\",\n\t\t\t\t\t \"#nvidia,mipi-calibrate-cells\", 0,\n\t\t\t\t\t &args);\n\tif (err < 0)\n\t\treturn ERR_PTR(err);\n\n\tdev = kzalloc(sizeof(*dev), GFP_KERNEL);\n\tif (!dev) {\n\t\terr = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tdev->pdev = of_find_device_by_node(args.np);\n\tif (!dev->pdev) {\n\t\terr = -ENODEV;\n\t\tgoto free;\n\t}\n\n\tdev->mipi = platform_get_drvdata(dev->pdev);\n\tif (!dev->mipi) {\n\t\terr = -EPROBE_DEFER;\n\t\tgoto put;\n\t}\n\n\tof_node_put(args.np);\n\n\tdev->pads = args.args[0];\n\tdev->device = device;\n\n\treturn dev;\n\nput:\n\tplatform_device_put(dev->pdev);\nfree:\n\tkfree(dev);\nout:\n\tof_node_put(args.np);\n\treturn ERR_PTR(err);\n}\nEXPORT_SYMBOL(tegra_mipi_request);\n\nvoid tegra_mipi_free(struct tegra_mipi_device *device)\n{\n\tplatform_device_put(device->pdev);\n\tkfree(device);\n}\nEXPORT_SYMBOL(tegra_mipi_free);\n\nint tegra_mipi_enable(struct tegra_mipi_device *dev)\n{\n\tint err = 0;\n\n\tmutex_lock(&dev->mipi->lock);\n\n\tif (dev->mipi->usage_count++ == 0)\n\t\terr = tegra_mipi_power_up(dev->mipi);\n\n\tmutex_unlock(&dev->mipi->lock);\n\n\treturn err;\n\n}\nEXPORT_SYMBOL(tegra_mipi_enable);\n\nint tegra_mipi_disable(struct tegra_mipi_device *dev)\n{\n\tint err = 0;\n\n\tmutex_lock(&dev->mipi->lock);\n\n\tif (--dev->mipi->usage_count == 0)\n\t\terr = tegra_mipi_power_down(dev->mipi);\n\n\tmutex_unlock(&dev->mipi->lock);\n\n\treturn err;\n\n}\nEXPORT_SYMBOL(tegra_mipi_disable);\n\nint tegra_mipi_finish_calibration(struct tegra_mipi_device *device)\n{\n\tstruct tegra_mipi *mipi = device->mipi;\n\tvoid __iomem *status_reg = mipi->regs + (MIPI_CAL_STATUS << 2);\n\tu32 value;\n\tint err;\n\n\terr = readl_relaxed_poll_timeout(status_reg, value,\n\t\t\t\t\t !(value & MIPI_CAL_STATUS_ACTIVE) &&\n\t\t\t\t\t (value & MIPI_CAL_STATUS_DONE), 50,\n\t\t\t\t\t 250000);\n\tmutex_unlock(&device->mipi->lock);\n\tclk_disable(device->mipi->clk);\n\n\treturn err;\n}\nEXPORT_SYMBOL(tegra_mipi_finish_calibration);\n\nint tegra_mipi_start_calibration(struct tegra_mipi_device *device)\n{\n\tconst struct tegra_mipi_soc *soc = device->mipi->soc;\n\tunsigned int i;\n\tu32 value;\n\tint err;\n\n\terr = clk_enable(device->mipi->clk);\n\tif (err < 0)\n\t\treturn err;\n\n\tmutex_lock(&device->mipi->lock);\n\n\tvalue = MIPI_CAL_BIAS_PAD_DRV_DN_REF(soc->pad_drive_down_ref) |\n\t\tMIPI_CAL_BIAS_PAD_DRV_UP_REF(soc->pad_drive_up_ref);\n\ttegra_mipi_writel(device->mipi, value, MIPI_CAL_BIAS_PAD_CFG1);\n\n\tvalue = tegra_mipi_readl(device->mipi, MIPI_CAL_BIAS_PAD_CFG2);\n\tvalue &= ~MIPI_CAL_BIAS_PAD_VCLAMP(0x7);\n\tvalue &= ~MIPI_CAL_BIAS_PAD_VAUXP(0x7);\n\tvalue |= MIPI_CAL_BIAS_PAD_VCLAMP(soc->pad_vclamp_level);\n\tvalue |= MIPI_CAL_BIAS_PAD_VAUXP(soc->pad_vauxp_level);\n\ttegra_mipi_writel(device->mipi, value, MIPI_CAL_BIAS_PAD_CFG2);\n\n\tfor (i = 0; i < soc->num_pads; i++) {\n\t\tu32 clk = 0, data = 0;\n\n\t\tif (device->pads & BIT(i)) {\n\t\t\tdata = MIPI_CAL_CONFIG_SELECT |\n\t\t\t       MIPI_CAL_CONFIG_HSPDOS(soc->hspdos) |\n\t\t\t       MIPI_CAL_CONFIG_HSPUOS(soc->hspuos) |\n\t\t\t       MIPI_CAL_CONFIG_TERMOS(soc->termos);\n\t\t\tclk = MIPI_CAL_CONFIG_SELECT |\n\t\t\t      MIPI_CAL_CONFIG_HSCLKPDOSD(soc->hsclkpdos) |\n\t\t\t      MIPI_CAL_CONFIG_HSCLKPUOSD(soc->hsclkpuos);\n\t\t}\n\n\t\ttegra_mipi_writel(device->mipi, data, soc->pads[i].data);\n\n\t\tif (soc->has_clk_lane && soc->pads[i].clk != 0)\n\t\t\ttegra_mipi_writel(device->mipi, clk, soc->pads[i].clk);\n\t}\n\n\tvalue = tegra_mipi_readl(device->mipi, MIPI_CAL_CTRL);\n\tvalue &= ~MIPI_CAL_CTRL_NOISE_FILTER(0xf);\n\tvalue &= ~MIPI_CAL_CTRL_PRESCALE(0x3);\n\tvalue |= MIPI_CAL_CTRL_NOISE_FILTER(0xa);\n\tvalue |= MIPI_CAL_CTRL_PRESCALE(0x2);\n\n\tif (!soc->clock_enable_override)\n\t\tvalue &= ~MIPI_CAL_CTRL_CLKEN_OVR;\n\telse\n\t\tvalue |= MIPI_CAL_CTRL_CLKEN_OVR;\n\n\ttegra_mipi_writel(device->mipi, value, MIPI_CAL_CTRL);\n\n\t \n\tvalue = tegra_mipi_readl(device->mipi, MIPI_CAL_STATUS);\n\ttegra_mipi_writel(device->mipi, value, MIPI_CAL_STATUS);\n\n\tvalue = tegra_mipi_readl(device->mipi, MIPI_CAL_CTRL);\n\tvalue |= MIPI_CAL_CTRL_START;\n\ttegra_mipi_writel(device->mipi, value, MIPI_CAL_CTRL);\n\n\t \n\tusleep_range(75, 80);\n\n\treturn 0;\n}\nEXPORT_SYMBOL(tegra_mipi_start_calibration);\n\nstatic const struct tegra_mipi_pad tegra114_mipi_pads[] = {\n\t{ .data = MIPI_CAL_CONFIG_CSIA },\n\t{ .data = MIPI_CAL_CONFIG_CSIB },\n\t{ .data = MIPI_CAL_CONFIG_CSIC },\n\t{ .data = MIPI_CAL_CONFIG_CSID },\n\t{ .data = MIPI_CAL_CONFIG_CSIE },\n\t{ .data = MIPI_CAL_CONFIG_DSIA },\n\t{ .data = MIPI_CAL_CONFIG_DSIB },\n\t{ .data = MIPI_CAL_CONFIG_DSIC },\n\t{ .data = MIPI_CAL_CONFIG_DSID },\n};\n\nstatic const struct tegra_mipi_soc tegra114_mipi_soc = {\n\t.has_clk_lane = false,\n\t.pads = tegra114_mipi_pads,\n\t.num_pads = ARRAY_SIZE(tegra114_mipi_pads),\n\t.clock_enable_override = true,\n\t.needs_vclamp_ref = true,\n\t.pad_drive_down_ref = 0x2,\n\t.pad_drive_up_ref = 0x0,\n\t.pad_vclamp_level = 0x0,\n\t.pad_vauxp_level = 0x0,\n\t.hspdos = 0x0,\n\t.hspuos = 0x4,\n\t.termos = 0x5,\n\t.hsclkpdos = 0x0,\n\t.hsclkpuos = 0x4,\n};\n\nstatic const struct tegra_mipi_pad tegra124_mipi_pads[] = {\n\t{ .data = MIPI_CAL_CONFIG_CSIA, .clk = MIPI_CAL_CONFIG_CSIAB_CLK },\n\t{ .data = MIPI_CAL_CONFIG_CSIB, .clk = MIPI_CAL_CONFIG_CSIAB_CLK },\n\t{ .data = MIPI_CAL_CONFIG_CSIC, .clk = MIPI_CAL_CONFIG_CSICD_CLK },\n\t{ .data = MIPI_CAL_CONFIG_CSID, .clk = MIPI_CAL_CONFIG_CSICD_CLK },\n\t{ .data = MIPI_CAL_CONFIG_CSIE, .clk = MIPI_CAL_CONFIG_CSIE_CLK  },\n\t{ .data = MIPI_CAL_CONFIG_DSIA, .clk = MIPI_CAL_CONFIG_DSIA_CLK  },\n\t{ .data = MIPI_CAL_CONFIG_DSIB, .clk = MIPI_CAL_CONFIG_DSIB_CLK  },\n};\n\nstatic const struct tegra_mipi_soc tegra124_mipi_soc = {\n\t.has_clk_lane = true,\n\t.pads = tegra124_mipi_pads,\n\t.num_pads = ARRAY_SIZE(tegra124_mipi_pads),\n\t.clock_enable_override = true,\n\t.needs_vclamp_ref = true,\n\t.pad_drive_down_ref = 0x2,\n\t.pad_drive_up_ref = 0x0,\n\t.pad_vclamp_level = 0x0,\n\t.pad_vauxp_level = 0x0,\n\t.hspdos = 0x0,\n\t.hspuos = 0x0,\n\t.termos = 0x0,\n\t.hsclkpdos = 0x1,\n\t.hsclkpuos = 0x2,\n};\n\nstatic const struct tegra_mipi_soc tegra132_mipi_soc = {\n\t.has_clk_lane = true,\n\t.pads = tegra124_mipi_pads,\n\t.num_pads = ARRAY_SIZE(tegra124_mipi_pads),\n\t.clock_enable_override = false,\n\t.needs_vclamp_ref = false,\n\t.pad_drive_down_ref = 0x0,\n\t.pad_drive_up_ref = 0x3,\n\t.pad_vclamp_level = 0x0,\n\t.pad_vauxp_level = 0x0,\n\t.hspdos = 0x0,\n\t.hspuos = 0x0,\n\t.termos = 0x0,\n\t.hsclkpdos = 0x3,\n\t.hsclkpuos = 0x2,\n};\n\nstatic const struct tegra_mipi_pad tegra210_mipi_pads[] = {\n\t{ .data = MIPI_CAL_CONFIG_CSIA, .clk = 0 },\n\t{ .data = MIPI_CAL_CONFIG_CSIB, .clk = 0 },\n\t{ .data = MIPI_CAL_CONFIG_CSIC, .clk = 0 },\n\t{ .data = MIPI_CAL_CONFIG_CSID, .clk = 0 },\n\t{ .data = MIPI_CAL_CONFIG_CSIE, .clk = 0 },\n\t{ .data = MIPI_CAL_CONFIG_CSIF, .clk = 0 },\n\t{ .data = MIPI_CAL_CONFIG_DSIA, .clk = MIPI_CAL_CONFIG_DSIA_CLK },\n\t{ .data = MIPI_CAL_CONFIG_DSIB, .clk = MIPI_CAL_CONFIG_DSIB_CLK },\n\t{ .data = MIPI_CAL_CONFIG_DSIC, .clk = MIPI_CAL_CONFIG_DSIC_CLK },\n\t{ .data = MIPI_CAL_CONFIG_DSID, .clk = MIPI_CAL_CONFIG_DSID_CLK },\n};\n\nstatic const struct tegra_mipi_soc tegra210_mipi_soc = {\n\t.has_clk_lane = true,\n\t.pads = tegra210_mipi_pads,\n\t.num_pads = ARRAY_SIZE(tegra210_mipi_pads),\n\t.clock_enable_override = true,\n\t.needs_vclamp_ref = false,\n\t.pad_drive_down_ref = 0x0,\n\t.pad_drive_up_ref = 0x3,\n\t.pad_vclamp_level = 0x1,\n\t.pad_vauxp_level = 0x1,\n\t.hspdos = 0x0,\n\t.hspuos = 0x2,\n\t.termos = 0x0,\n\t.hsclkpdos = 0x0,\n\t.hsclkpuos = 0x2,\n};\n\nstatic const struct of_device_id tegra_mipi_of_match[] = {\n\t{ .compatible = \"nvidia,tegra114-mipi\", .data = &tegra114_mipi_soc },\n\t{ .compatible = \"nvidia,tegra124-mipi\", .data = &tegra124_mipi_soc },\n\t{ .compatible = \"nvidia,tegra132-mipi\", .data = &tegra132_mipi_soc },\n\t{ .compatible = \"nvidia,tegra210-mipi\", .data = &tegra210_mipi_soc },\n\t{ },\n};\n\nstatic int tegra_mipi_probe(struct platform_device *pdev)\n{\n\tconst struct of_device_id *match;\n\tstruct tegra_mipi *mipi;\n\tint err;\n\n\tmatch = of_match_node(tegra_mipi_of_match, pdev->dev.of_node);\n\tif (!match)\n\t\treturn -ENODEV;\n\n\tmipi = devm_kzalloc(&pdev->dev, sizeof(*mipi), GFP_KERNEL);\n\tif (!mipi)\n\t\treturn -ENOMEM;\n\n\tmipi->soc = match->data;\n\tmipi->dev = &pdev->dev;\n\n\tmipi->regs = devm_platform_get_and_ioremap_resource(pdev, 0, NULL);\n\tif (IS_ERR(mipi->regs))\n\t\treturn PTR_ERR(mipi->regs);\n\n\tmutex_init(&mipi->lock);\n\n\tmipi->clk = devm_clk_get(&pdev->dev, NULL);\n\tif (IS_ERR(mipi->clk)) {\n\t\tdev_err(&pdev->dev, \"failed to get clock\\n\");\n\t\treturn PTR_ERR(mipi->clk);\n\t}\n\n\terr = clk_prepare(mipi->clk);\n\tif (err < 0)\n\t\treturn err;\n\n\tplatform_set_drvdata(pdev, mipi);\n\n\treturn 0;\n}\n\nstatic int tegra_mipi_remove(struct platform_device *pdev)\n{\n\tstruct tegra_mipi *mipi = platform_get_drvdata(pdev);\n\n\tclk_unprepare(mipi->clk);\n\n\treturn 0;\n}\n\nstruct platform_driver tegra_mipi_driver = {\n\t.driver = {\n\t\t.name = \"tegra-mipi\",\n\t\t.of_match_table = tegra_mipi_of_match,\n\t},\n\t.probe = tegra_mipi_probe,\n\t.remove = tegra_mipi_remove,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}