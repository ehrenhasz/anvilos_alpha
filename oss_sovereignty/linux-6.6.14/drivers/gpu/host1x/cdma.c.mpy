{
  "module_name": "cdma.c",
  "hash_id": "9071ca56f67a4fee39bbd619317bec76c7028aff8b74bfdbfe6f897568176003",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/host1x/cdma.c",
  "human_readable_source": "\n \n\n\n#include <asm/cacheflush.h>\n#include <linux/device.h>\n#include <linux/dma-mapping.h>\n#include <linux/host1x.h>\n#include <linux/interrupt.h>\n#include <linux/kernel.h>\n#include <linux/kfifo.h>\n#include <linux/slab.h>\n#include <trace/events/host1x.h>\n\n#include \"cdma.h\"\n#include \"channel.h\"\n#include \"dev.h\"\n#include \"debug.h\"\n#include \"job.h\"\n\n \n\n \n#define HOST1X_PUSHBUFFER_SLOTS\t511\n\n \nstatic void host1x_pushbuffer_destroy(struct push_buffer *pb)\n{\n\tstruct host1x_cdma *cdma = pb_to_cdma(pb);\n\tstruct host1x *host1x = cdma_to_host1x(cdma);\n\n\tif (!pb->mapped)\n\t\treturn;\n\n\tif (host1x->domain) {\n\t\tiommu_unmap(host1x->domain, pb->dma, pb->alloc_size);\n\t\tfree_iova(&host1x->iova, iova_pfn(&host1x->iova, pb->dma));\n\t}\n\n\tdma_free_wc(host1x->dev, pb->alloc_size, pb->mapped, pb->phys);\n\n\tpb->mapped = NULL;\n\tpb->phys = 0;\n}\n\n \nstatic int host1x_pushbuffer_init(struct push_buffer *pb)\n{\n\tstruct host1x_cdma *cdma = pb_to_cdma(pb);\n\tstruct host1x *host1x = cdma_to_host1x(cdma);\n\tstruct iova *alloc;\n\tu32 size;\n\tint err;\n\n\tpb->mapped = NULL;\n\tpb->phys = 0;\n\tpb->size = HOST1X_PUSHBUFFER_SLOTS * 8;\n\n\tsize = pb->size + 4;\n\n\t \n\tpb->fence = pb->size - 8;\n\tpb->pos = 0;\n\n\tif (host1x->domain) {\n\t\tunsigned long shift;\n\n\t\tsize = iova_align(&host1x->iova, size);\n\n\t\tpb->mapped = dma_alloc_wc(host1x->dev, size, &pb->phys,\n\t\t\t\t\t  GFP_KERNEL);\n\t\tif (!pb->mapped)\n\t\t\treturn -ENOMEM;\n\n\t\tshift = iova_shift(&host1x->iova);\n\t\talloc = alloc_iova(&host1x->iova, size >> shift,\n\t\t\t\t   host1x->iova_end >> shift, true);\n\t\tif (!alloc) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto iommu_free_mem;\n\t\t}\n\n\t\tpb->dma = iova_dma_addr(&host1x->iova, alloc);\n\t\terr = iommu_map(host1x->domain, pb->dma, pb->phys, size,\n\t\t\t\tIOMMU_READ, GFP_KERNEL);\n\t\tif (err)\n\t\t\tgoto iommu_free_iova;\n\t} else {\n\t\tpb->mapped = dma_alloc_wc(host1x->dev, size, &pb->phys,\n\t\t\t\t\t  GFP_KERNEL);\n\t\tif (!pb->mapped)\n\t\t\treturn -ENOMEM;\n\n\t\tpb->dma = pb->phys;\n\t}\n\n\tpb->alloc_size = size;\n\n\thost1x_hw_pushbuffer_init(host1x, pb);\n\n\treturn 0;\n\niommu_free_iova:\n\t__free_iova(&host1x->iova, alloc);\niommu_free_mem:\n\tdma_free_wc(host1x->dev, size, pb->mapped, pb->phys);\n\n\treturn err;\n}\n\n \nstatic void host1x_pushbuffer_push(struct push_buffer *pb, u32 op1, u32 op2)\n{\n\tu32 *p = (u32 *)((void *)pb->mapped + pb->pos);\n\n\tWARN_ON(pb->pos == pb->fence);\n\t*(p++) = op1;\n\t*(p++) = op2;\n\tpb->pos += 8;\n\n\tif (pb->pos >= pb->size)\n\t\tpb->pos -= pb->size;\n}\n\n \nstatic void host1x_pushbuffer_pop(struct push_buffer *pb, unsigned int slots)\n{\n\t \n\tpb->fence += slots * 8;\n\n\tif (pb->fence >= pb->size)\n\t\tpb->fence -= pb->size;\n}\n\n \nstatic u32 host1x_pushbuffer_space(struct push_buffer *pb)\n{\n\tunsigned int fence = pb->fence;\n\n\tif (pb->fence < pb->pos)\n\t\tfence += pb->size;\n\n\treturn (fence - pb->pos) / 8;\n}\n\n \nunsigned int host1x_cdma_wait_locked(struct host1x_cdma *cdma,\n\t\t\t\t     enum cdma_event event)\n{\n\tfor (;;) {\n\t\tstruct push_buffer *pb = &cdma->push_buffer;\n\t\tunsigned int space;\n\n\t\tswitch (event) {\n\t\tcase CDMA_EVENT_SYNC_QUEUE_EMPTY:\n\t\t\tspace = list_empty(&cdma->sync_queue) ? 1 : 0;\n\t\t\tbreak;\n\n\t\tcase CDMA_EVENT_PUSH_BUFFER_SPACE:\n\t\t\tspace = host1x_pushbuffer_space(pb);\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tWARN_ON(1);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (space)\n\t\t\treturn space;\n\n\t\ttrace_host1x_wait_cdma(dev_name(cdma_to_channel(cdma)->dev),\n\t\t\t\t       event);\n\n\t\t \n\t\tif (cdma->event != CDMA_EVENT_NONE) {\n\t\t\tmutex_unlock(&cdma->lock);\n\t\t\tschedule();\n\t\t\tmutex_lock(&cdma->lock);\n\t\t\tcontinue;\n\t\t}\n\n\t\tcdma->event = event;\n\n\t\tmutex_unlock(&cdma->lock);\n\t\twait_for_completion(&cdma->complete);\n\t\tmutex_lock(&cdma->lock);\n\t}\n\n\treturn 0;\n}\n\n \nstatic int host1x_cdma_wait_pushbuffer_space(struct host1x *host1x,\n\t\t\t\t\t     struct host1x_cdma *cdma,\n\t\t\t\t\t     unsigned int needed)\n{\n\twhile (true) {\n\t\tstruct push_buffer *pb = &cdma->push_buffer;\n\t\tunsigned int space;\n\n\t\tspace = host1x_pushbuffer_space(pb);\n\t\tif (space >= needed)\n\t\t\tbreak;\n\n\t\ttrace_host1x_wait_cdma(dev_name(cdma_to_channel(cdma)->dev),\n\t\t\t\t       CDMA_EVENT_PUSH_BUFFER_SPACE);\n\n\t\thost1x_hw_cdma_flush(host1x, cdma);\n\n\t\t \n\t\tif (cdma->event != CDMA_EVENT_NONE) {\n\t\t\tmutex_unlock(&cdma->lock);\n\t\t\tschedule();\n\t\t\tmutex_lock(&cdma->lock);\n\t\t\tcontinue;\n\t\t}\n\n\t\tcdma->event = CDMA_EVENT_PUSH_BUFFER_SPACE;\n\n\t\tmutex_unlock(&cdma->lock);\n\t\twait_for_completion(&cdma->complete);\n\t\tmutex_lock(&cdma->lock);\n\t}\n\n\treturn 0;\n}\n \nstatic void cdma_start_timer_locked(struct host1x_cdma *cdma,\n\t\t\t\t    struct host1x_job *job)\n{\n\tif (cdma->timeout.client) {\n\t\t \n\t\treturn;\n\t}\n\n\tcdma->timeout.client = job->client;\n\tcdma->timeout.syncpt = job->syncpt;\n\tcdma->timeout.syncpt_val = job->syncpt_end;\n\tcdma->timeout.start_ktime = ktime_get();\n\n\tschedule_delayed_work(&cdma->timeout.wq,\n\t\t\t      msecs_to_jiffies(job->timeout));\n}\n\n \nstatic void stop_cdma_timer_locked(struct host1x_cdma *cdma)\n{\n\tcancel_delayed_work(&cdma->timeout.wq);\n\tcdma->timeout.client = NULL;\n}\n\n \nstatic void update_cdma_locked(struct host1x_cdma *cdma)\n{\n\tbool signal = false;\n\tstruct host1x_job *job, *n;\n\n\t \n\tlist_for_each_entry_safe(job, n, &cdma->sync_queue, list) {\n\t\tstruct host1x_syncpt *sp = job->syncpt;\n\n\t\t \n\t\tif (!host1x_syncpt_is_expired(sp, job->syncpt_end) &&\n\t\t    !job->cancelled) {\n\t\t\t \n\t\t\tif (job->timeout)\n\t\t\t\tcdma_start_timer_locked(cdma, job);\n\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\tif (cdma->timeout.client)\n\t\t\tstop_cdma_timer_locked(cdma);\n\n\t\t \n\t\thost1x_job_unpin(job);\n\n\t\t \n\t\tif (job->num_slots) {\n\t\t\tstruct push_buffer *pb = &cdma->push_buffer;\n\n\t\t\thost1x_pushbuffer_pop(pb, job->num_slots);\n\n\t\t\tif (cdma->event == CDMA_EVENT_PUSH_BUFFER_SPACE)\n\t\t\t\tsignal = true;\n\t\t}\n\n\t\tlist_del(&job->list);\n\t\thost1x_job_put(job);\n\t}\n\n\tif (cdma->event == CDMA_EVENT_SYNC_QUEUE_EMPTY &&\n\t    list_empty(&cdma->sync_queue))\n\t\tsignal = true;\n\n\tif (signal) {\n\t\tcdma->event = CDMA_EVENT_NONE;\n\t\tcomplete(&cdma->complete);\n\t}\n}\n\nvoid host1x_cdma_update_sync_queue(struct host1x_cdma *cdma,\n\t\t\t\t   struct device *dev)\n{\n\tstruct host1x *host1x = cdma_to_host1x(cdma);\n\tu32 restart_addr, syncpt_incrs, syncpt_val;\n\tstruct host1x_job *job, *next_job = NULL;\n\n\tsyncpt_val = host1x_syncpt_load(cdma->timeout.syncpt);\n\n\tdev_dbg(dev, \"%s: starting cleanup (thresh %d)\\n\",\n\t\t__func__, syncpt_val);\n\n\t \n\n\tdev_dbg(dev, \"%s: skip completed buffers still in sync_queue\\n\",\n\t\t__func__);\n\n\tlist_for_each_entry(job, &cdma->sync_queue, list) {\n\t\tif (syncpt_val < job->syncpt_end) {\n\n\t\t\tif (!list_is_last(&job->list, &cdma->sync_queue))\n\t\t\t\tnext_job = list_next_entry(job, list);\n\n\t\t\tgoto syncpt_incr;\n\t\t}\n\n\t\thost1x_job_dump(dev, job);\n\t}\n\n\t \n\tjob = NULL;\n\nsyncpt_incr:\n\n\t \n\tif (next_job)\n\t\trestart_addr = next_job->first_get;\n\telse\n\t\trestart_addr = cdma->last_pos;\n\n\tif (!job)\n\t\tgoto resume;\n\n\t \n\tif (job->syncpt_recovery) {\n\t\tdev_dbg(dev, \"%s: perform CPU incr on pending buffers\\n\",\n\t\t\t__func__);\n\n\t\t \n\t\tjob->timeout = 0;\n\n\t\tsyncpt_incrs = job->syncpt_end - syncpt_val;\n\t\tdev_dbg(dev, \"%s: CPU incr (%d)\\n\", __func__, syncpt_incrs);\n\n\t\thost1x_job_dump(dev, job);\n\n\t\t \n\t\thost1x_hw_cdma_timeout_cpu_incr(host1x, cdma, job->first_get,\n\t\t\t\t\t\tsyncpt_incrs, job->syncpt_end,\n\t\t\t\t\t\tjob->num_slots);\n\n\t\tdev_dbg(dev, \"%s: finished sync_queue modification\\n\",\n\t\t\t__func__);\n\t} else {\n\t\tstruct host1x_job *failed_job = job;\n\n\t\thost1x_job_dump(dev, job);\n\n\t\thost1x_syncpt_set_locked(job->syncpt);\n\t\tfailed_job->cancelled = true;\n\n\t\tlist_for_each_entry_continue(job, &cdma->sync_queue, list) {\n\t\t\tunsigned int i;\n\n\t\t\tif (job->syncpt != failed_job->syncpt)\n\t\t\t\tcontinue;\n\n\t\t\tfor (i = 0; i < job->num_slots; i++) {\n\t\t\t\tunsigned int slot = (job->first_get/8 + i) %\n\t\t\t\t\t\t    HOST1X_PUSHBUFFER_SLOTS;\n\t\t\t\tu32 *mapped = cdma->push_buffer.mapped;\n\n\t\t\t\t \n\t\t\t\tif (i == 0 && host1x->info->has_wide_gather) {\n\t\t\t\t\tunsigned int next_job = (job->first_get/8 + job->num_slots)\n\t\t\t\t\t\t% HOST1X_PUSHBUFFER_SLOTS;\n\t\t\t\t\tmapped[2*slot+0] = (0xd << 28) | (next_job * 2);\n\t\t\t\t\tmapped[2*slot+1] = 0x0;\n\t\t\t\t} else {\n\t\t\t\t\tmapped[2*slot+0] = 0x1bad0000;\n\t\t\t\t\tmapped[2*slot+1] = 0x1bad0000;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tjob->cancelled = true;\n\t\t}\n\n\t\twmb();\n\n\t\tupdate_cdma_locked(cdma);\n\t}\n\nresume:\n\t \n\thost1x_hw_cdma_resume(host1x, cdma, restart_addr);\n}\n\nstatic void cdma_update_work(struct work_struct *work)\n{\n\tstruct host1x_cdma *cdma = container_of(work, struct host1x_cdma, update_work);\n\n\tmutex_lock(&cdma->lock);\n\tupdate_cdma_locked(cdma);\n\tmutex_unlock(&cdma->lock);\n}\n\n \nint host1x_cdma_init(struct host1x_cdma *cdma)\n{\n\tint err;\n\n\tmutex_init(&cdma->lock);\n\tinit_completion(&cdma->complete);\n\tINIT_WORK(&cdma->update_work, cdma_update_work);\n\n\tINIT_LIST_HEAD(&cdma->sync_queue);\n\n\tcdma->event = CDMA_EVENT_NONE;\n\tcdma->running = false;\n\tcdma->torndown = false;\n\n\terr = host1x_pushbuffer_init(&cdma->push_buffer);\n\tif (err)\n\t\treturn err;\n\n\treturn 0;\n}\n\n \nint host1x_cdma_deinit(struct host1x_cdma *cdma)\n{\n\tstruct push_buffer *pb = &cdma->push_buffer;\n\tstruct host1x *host1x = cdma_to_host1x(cdma);\n\n\tif (cdma->running) {\n\t\tpr_warn(\"%s: CDMA still running\\n\", __func__);\n\t\treturn -EBUSY;\n\t}\n\n\thost1x_pushbuffer_destroy(pb);\n\thost1x_hw_cdma_timeout_destroy(host1x, cdma);\n\n\treturn 0;\n}\n\n \nint host1x_cdma_begin(struct host1x_cdma *cdma, struct host1x_job *job)\n{\n\tstruct host1x *host1x = cdma_to_host1x(cdma);\n\n\tmutex_lock(&cdma->lock);\n\n\t \n\tif (job->syncpt->locked) {\n\t\tmutex_unlock(&cdma->lock);\n\t\treturn -EPERM;\n\t}\n\n\tif (job->timeout) {\n\t\t \n\t\tif (!cdma->timeout.initialized) {\n\t\t\tint err;\n\n\t\t\terr = host1x_hw_cdma_timeout_init(host1x, cdma);\n\t\t\tif (err) {\n\t\t\t\tmutex_unlock(&cdma->lock);\n\t\t\t\treturn err;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (!cdma->running)\n\t\thost1x_hw_cdma_start(host1x, cdma);\n\n\tcdma->slots_free = 0;\n\tcdma->slots_used = 0;\n\tcdma->first_get = cdma->push_buffer.pos;\n\n\ttrace_host1x_cdma_begin(dev_name(job->channel->dev));\n\treturn 0;\n}\n\n \nvoid host1x_cdma_push(struct host1x_cdma *cdma, u32 op1, u32 op2)\n{\n\tstruct host1x *host1x = cdma_to_host1x(cdma);\n\tstruct push_buffer *pb = &cdma->push_buffer;\n\tu32 slots_free = cdma->slots_free;\n\n\tif (host1x_debug_trace_cmdbuf)\n\t\ttrace_host1x_cdma_push(dev_name(cdma_to_channel(cdma)->dev),\n\t\t\t\t       op1, op2);\n\n\tif (slots_free == 0) {\n\t\thost1x_hw_cdma_flush(host1x, cdma);\n\t\tslots_free = host1x_cdma_wait_locked(cdma,\n\t\t\t\t\t\tCDMA_EVENT_PUSH_BUFFER_SPACE);\n\t}\n\n\tcdma->slots_free = slots_free - 1;\n\tcdma->slots_used++;\n\thost1x_pushbuffer_push(pb, op1, op2);\n}\n\n \nvoid host1x_cdma_push_wide(struct host1x_cdma *cdma, u32 op1, u32 op2,\n\t\t\t   u32 op3, u32 op4)\n{\n\tstruct host1x_channel *channel = cdma_to_channel(cdma);\n\tstruct host1x *host1x = cdma_to_host1x(cdma);\n\tstruct push_buffer *pb = &cdma->push_buffer;\n\tunsigned int space = cdma->slots_free;\n\tunsigned int needed = 2, extra = 0;\n\n\tif (host1x_debug_trace_cmdbuf)\n\t\ttrace_host1x_cdma_push_wide(dev_name(channel->dev), op1, op2,\n\t\t\t\t\t    op3, op4);\n\n\t \n\tif (pb->pos + 16 > pb->size) {\n\t\textra = (pb->size - pb->pos) / 8;\n\t\tneeded += extra;\n\t}\n\n\thost1x_cdma_wait_pushbuffer_space(host1x, cdma, needed);\n\tspace = host1x_pushbuffer_space(pb);\n\n\tcdma->slots_free = space - needed;\n\tcdma->slots_used += needed;\n\n\tif (extra > 0) {\n\t\t \n\t\thost1x_pushbuffer_push(pb, (0x5 << 28), 0xdead0000);\n\t}\n\n\thost1x_pushbuffer_push(pb, op1, op2);\n\thost1x_pushbuffer_push(pb, op3, op4);\n}\n\n \nvoid host1x_cdma_end(struct host1x_cdma *cdma,\n\t\t     struct host1x_job *job)\n{\n\tstruct host1x *host1x = cdma_to_host1x(cdma);\n\tbool idle = list_empty(&cdma->sync_queue);\n\n\thost1x_hw_cdma_flush(host1x, cdma);\n\n\tjob->first_get = cdma->first_get;\n\tjob->num_slots = cdma->slots_used;\n\thost1x_job_get(job);\n\tlist_add_tail(&job->list, &cdma->sync_queue);\n\n\t \n\tif (job->timeout && idle)\n\t\tcdma_start_timer_locked(cdma, job);\n\n\ttrace_host1x_cdma_end(dev_name(job->channel->dev));\n\tmutex_unlock(&cdma->lock);\n}\n\n \nvoid host1x_cdma_update(struct host1x_cdma *cdma)\n{\n\tschedule_work(&cdma->update_work);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}