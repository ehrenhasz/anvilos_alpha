{
  "module_name": "syncpt.c",
  "hash_id": "11a105aa0dbd6c9e02acd6153da03973df161841c2e820a33b7b39ea7ff98c74",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/host1x/syncpt.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/device.h>\n#include <linux/dma-fence.h>\n#include <linux/slab.h>\n\n#include <trace/events/host1x.h>\n\n#include \"syncpt.h\"\n#include \"dev.h\"\n#include \"intr.h\"\n#include \"debug.h\"\n\n#define SYNCPT_CHECK_PERIOD (2 * HZ)\n#define MAX_STUCK_CHECK_COUNT 15\n\nstatic struct host1x_syncpt_base *\nhost1x_syncpt_base_request(struct host1x *host)\n{\n\tstruct host1x_syncpt_base *bases = host->bases;\n\tunsigned int i;\n\n\tfor (i = 0; i < host->info->nb_bases; i++)\n\t\tif (!bases[i].requested)\n\t\t\tbreak;\n\n\tif (i >= host->info->nb_bases)\n\t\treturn NULL;\n\n\tbases[i].requested = true;\n\treturn &bases[i];\n}\n\nstatic void host1x_syncpt_base_free(struct host1x_syncpt_base *base)\n{\n\tif (base)\n\t\tbase->requested = false;\n}\n\n \nstruct host1x_syncpt *host1x_syncpt_alloc(struct host1x *host,\n\t\t\t\t\t  unsigned long flags,\n\t\t\t\t\t  const char *name)\n{\n\tstruct host1x_syncpt *sp = host->syncpt;\n\tchar *full_name;\n\tunsigned int i;\n\n\tif (!name)\n\t\treturn NULL;\n\n\tmutex_lock(&host->syncpt_mutex);\n\n\tfor (i = 0; i < host->info->nb_pts && kref_read(&sp->ref); i++, sp++)\n\t\t;\n\n\tif (i >= host->info->nb_pts)\n\t\tgoto unlock;\n\n\tif (flags & HOST1X_SYNCPT_HAS_BASE) {\n\t\tsp->base = host1x_syncpt_base_request(host);\n\t\tif (!sp->base)\n\t\t\tgoto unlock;\n\t}\n\n\tfull_name = kasprintf(GFP_KERNEL, \"%u-%s\", sp->id, name);\n\tif (!full_name)\n\t\tgoto free_base;\n\n\tsp->name = full_name;\n\n\tif (flags & HOST1X_SYNCPT_CLIENT_MANAGED)\n\t\tsp->client_managed = true;\n\telse\n\t\tsp->client_managed = false;\n\n\tkref_init(&sp->ref);\n\n\tmutex_unlock(&host->syncpt_mutex);\n\treturn sp;\n\nfree_base:\n\thost1x_syncpt_base_free(sp->base);\n\tsp->base = NULL;\nunlock:\n\tmutex_unlock(&host->syncpt_mutex);\n\treturn NULL;\n}\nEXPORT_SYMBOL(host1x_syncpt_alloc);\n\n \nu32 host1x_syncpt_id(struct host1x_syncpt *sp)\n{\n\treturn sp->id;\n}\nEXPORT_SYMBOL(host1x_syncpt_id);\n\n \nu32 host1x_syncpt_incr_max(struct host1x_syncpt *sp, u32 incrs)\n{\n\treturn (u32)atomic_add_return(incrs, &sp->max_val);\n}\nEXPORT_SYMBOL(host1x_syncpt_incr_max);\n\n  \nvoid host1x_syncpt_restore(struct host1x *host)\n{\n\tstruct host1x_syncpt *sp_base = host->syncpt;\n\tunsigned int i;\n\n\tfor (i = 0; i < host1x_syncpt_nb_pts(host); i++) {\n\t\t \n\t\thost1x_hw_syncpt_assign_to_channel(host, sp_base + i, NULL);\n\t\thost1x_hw_syncpt_restore(host, sp_base + i);\n\t}\n\n\tfor (i = 0; i < host1x_syncpt_nb_bases(host); i++)\n\t\thost1x_hw_syncpt_restore_wait_base(host, sp_base + i);\n\n\thost1x_hw_syncpt_enable_protection(host);\n\n\twmb();\n}\n\n \nvoid host1x_syncpt_save(struct host1x *host)\n{\n\tstruct host1x_syncpt *sp_base = host->syncpt;\n\tunsigned int i;\n\n\tfor (i = 0; i < host1x_syncpt_nb_pts(host); i++) {\n\t\tif (host1x_syncpt_client_managed(sp_base + i))\n\t\t\thost1x_hw_syncpt_load(host, sp_base + i);\n\t\telse\n\t\t\tWARN_ON(!host1x_syncpt_idle(sp_base + i));\n\t}\n\n\tfor (i = 0; i < host1x_syncpt_nb_bases(host); i++)\n\t\thost1x_hw_syncpt_load_wait_base(host, sp_base + i);\n}\n\n \nu32 host1x_syncpt_load(struct host1x_syncpt *sp)\n{\n\tu32 val;\n\n\tval = host1x_hw_syncpt_load(sp->host, sp);\n\ttrace_host1x_syncpt_load_min(sp->id, val);\n\n\treturn val;\n}\n\n \nu32 host1x_syncpt_load_wait_base(struct host1x_syncpt *sp)\n{\n\thost1x_hw_syncpt_load_wait_base(sp->host, sp);\n\n\treturn sp->base_val;\n}\n\n \nint host1x_syncpt_incr(struct host1x_syncpt *sp)\n{\n\treturn host1x_hw_syncpt_cpu_incr(sp->host, sp);\n}\nEXPORT_SYMBOL(host1x_syncpt_incr);\n\n \nint host1x_syncpt_wait(struct host1x_syncpt *sp, u32 thresh, long timeout,\n\t\t       u32 *value)\n{\n\tstruct dma_fence *fence;\n\tlong wait_err;\n\n\thost1x_hw_syncpt_load(sp->host, sp);\n\n\tif (value)\n\t\t*value = host1x_syncpt_load(sp);\n\n\tif (host1x_syncpt_is_expired(sp, thresh))\n\t\treturn 0;\n\n\tif (timeout < 0)\n\t\ttimeout = LONG_MAX;\n\telse if (timeout == 0)\n\t\treturn -EAGAIN;\n\n\tfence = host1x_fence_create(sp, thresh, false);\n\tif (IS_ERR(fence))\n\t\treturn PTR_ERR(fence);\n\n\twait_err = dma_fence_wait_timeout(fence, true, timeout);\n\tif (wait_err == 0)\n\t\thost1x_fence_cancel(fence);\n\tdma_fence_put(fence);\n\n\tif (value)\n\t\t*value = host1x_syncpt_load(sp);\n\n\t \n\thost1x_hw_syncpt_load(sp->host, sp);\n\tif (wait_err == 0 && !host1x_syncpt_is_expired(sp, thresh))\n\t\treturn -EAGAIN;\n\telse if (wait_err < 0)\n\t\treturn wait_err;\n\telse\n\t\treturn 0;\n}\nEXPORT_SYMBOL(host1x_syncpt_wait);\n\n \nbool host1x_syncpt_is_expired(struct host1x_syncpt *sp, u32 thresh)\n{\n\tu32 current_val;\n\n\tsmp_rmb();\n\n\tcurrent_val = (u32)atomic_read(&sp->min_val);\n\n\treturn ((current_val - thresh) & 0x80000000U) == 0U;\n}\n\nint host1x_syncpt_init(struct host1x *host)\n{\n\tstruct host1x_syncpt_base *bases;\n\tstruct host1x_syncpt *syncpt;\n\tunsigned int i;\n\n\tsyncpt = devm_kcalloc(host->dev, host->info->nb_pts, sizeof(*syncpt),\n\t\t\t      GFP_KERNEL);\n\tif (!syncpt)\n\t\treturn -ENOMEM;\n\n\tbases = devm_kcalloc(host->dev, host->info->nb_bases, sizeof(*bases),\n\t\t\t     GFP_KERNEL);\n\tif (!bases)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < host->info->nb_pts; i++) {\n\t\tsyncpt[i].id = i;\n\t\tsyncpt[i].host = host;\n\t}\n\n\tfor (i = 0; i < host->info->nb_bases; i++)\n\t\tbases[i].id = i;\n\n\tmutex_init(&host->syncpt_mutex);\n\thost->syncpt = syncpt;\n\thost->bases = bases;\n\n\t \n\thost->nop_sp = host1x_syncpt_alloc(host, 0, \"reserved-nop\");\n\tif (!host->nop_sp)\n\t\treturn -ENOMEM;\n\n\tif (host->info->reserve_vblank_syncpts) {\n\t\tkref_init(&host->syncpt[26].ref);\n\t\tkref_init(&host->syncpt[27].ref);\n\t}\n\n\treturn 0;\n}\n\n \nstruct host1x_syncpt *host1x_syncpt_request(struct host1x_client *client,\n\t\t\t\t\t    unsigned long flags)\n{\n\tstruct host1x *host = dev_get_drvdata(client->host->parent);\n\n\treturn host1x_syncpt_alloc(host, flags, dev_name(client->dev));\n}\nEXPORT_SYMBOL(host1x_syncpt_request);\n\nstatic void syncpt_release(struct kref *ref)\n{\n\tstruct host1x_syncpt *sp = container_of(ref, struct host1x_syncpt, ref);\n\n\tatomic_set(&sp->max_val, host1x_syncpt_read(sp));\n\n\tsp->locked = false;\n\n\tmutex_lock(&sp->host->syncpt_mutex);\n\n\thost1x_syncpt_base_free(sp->base);\n\tkfree(sp->name);\n\tsp->base = NULL;\n\tsp->name = NULL;\n\tsp->client_managed = false;\n\n\tmutex_unlock(&sp->host->syncpt_mutex);\n}\n\n \nvoid host1x_syncpt_put(struct host1x_syncpt *sp)\n{\n\tif (!sp)\n\t\treturn;\n\n\tkref_put(&sp->ref, syncpt_release);\n}\nEXPORT_SYMBOL(host1x_syncpt_put);\n\nvoid host1x_syncpt_deinit(struct host1x *host)\n{\n\tstruct host1x_syncpt *sp = host->syncpt;\n\tunsigned int i;\n\n\tfor (i = 0; i < host->info->nb_pts; i++, sp++)\n\t\tkfree(sp->name);\n}\n\n \nu32 host1x_syncpt_read_max(struct host1x_syncpt *sp)\n{\n\tsmp_rmb();\n\n\treturn (u32)atomic_read(&sp->max_val);\n}\nEXPORT_SYMBOL(host1x_syncpt_read_max);\n\n \nu32 host1x_syncpt_read_min(struct host1x_syncpt *sp)\n{\n\tsmp_rmb();\n\n\treturn (u32)atomic_read(&sp->min_val);\n}\nEXPORT_SYMBOL(host1x_syncpt_read_min);\n\n \nu32 host1x_syncpt_read(struct host1x_syncpt *sp)\n{\n\treturn host1x_syncpt_load(sp);\n}\nEXPORT_SYMBOL(host1x_syncpt_read);\n\nunsigned int host1x_syncpt_nb_pts(struct host1x *host)\n{\n\treturn host->info->nb_pts;\n}\n\nunsigned int host1x_syncpt_nb_bases(struct host1x *host)\n{\n\treturn host->info->nb_bases;\n}\n\nunsigned int host1x_syncpt_nb_mlocks(struct host1x *host)\n{\n\treturn host->info->nb_mlocks;\n}\n\n \nstruct host1x_syncpt *host1x_syncpt_get_by_id(struct host1x *host,\n\t\t\t\t\t      unsigned int id)\n{\n\tif (id >= host->info->nb_pts)\n\t\treturn NULL;\n\n\tif (kref_get_unless_zero(&host->syncpt[id].ref))\n\t\treturn &host->syncpt[id];\n\telse\n\t\treturn NULL;\n}\nEXPORT_SYMBOL(host1x_syncpt_get_by_id);\n\n \nstruct host1x_syncpt *host1x_syncpt_get_by_id_noref(struct host1x *host,\n\t\t\t\t\t\t    unsigned int id)\n{\n\tif (id >= host->info->nb_pts)\n\t\treturn NULL;\n\n\treturn &host->syncpt[id];\n}\nEXPORT_SYMBOL(host1x_syncpt_get_by_id_noref);\n\n \nstruct host1x_syncpt *host1x_syncpt_get(struct host1x_syncpt *sp)\n{\n\tkref_get(&sp->ref);\n\n\treturn sp;\n}\nEXPORT_SYMBOL(host1x_syncpt_get);\n\n \nstruct host1x_syncpt_base *host1x_syncpt_get_base(struct host1x_syncpt *sp)\n{\n\treturn sp ? sp->base : NULL;\n}\nEXPORT_SYMBOL(host1x_syncpt_get_base);\n\n \nu32 host1x_syncpt_base_id(struct host1x_syncpt_base *base)\n{\n\treturn base->id;\n}\nEXPORT_SYMBOL(host1x_syncpt_base_id);\n\nstatic void do_nothing(struct kref *ref)\n{\n}\n\n \nvoid host1x_syncpt_release_vblank_reservation(struct host1x_client *client,\n\t\t\t\t\t      u32 syncpt_id)\n{\n\tstruct host1x *host = dev_get_drvdata(client->host->parent);\n\n\tif (!host->info->reserve_vblank_syncpts)\n\t\treturn;\n\n\tkref_put(&host->syncpt[syncpt_id].ref, do_nothing);\n}\nEXPORT_SYMBOL(host1x_syncpt_release_vblank_reservation);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}