{
  "module_name": "context.c",
  "hash_id": "6dea565915b56cdaf1293d093a6b42d324b7f9b4039574ad8f8788022088418f",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/host1x/context.c",
  "human_readable_source": "\n \n\n#include <linux/device.h>\n#include <linux/kref.h>\n#include <linux/of.h>\n#include <linux/of_device.h>\n#include <linux/pid.h>\n#include <linux/slab.h>\n\n#include \"context.h\"\n#include \"dev.h\"\n\nstatic void host1x_memory_context_release(struct device *dev)\n{\n\t \n}\n\nint host1x_memory_context_list_init(struct host1x *host1x)\n{\n\tstruct host1x_memory_context_list *cdl = &host1x->context_list;\n\tstruct device_node *node = host1x->dev->of_node;\n\tstruct host1x_memory_context *ctx;\n\tunsigned int i;\n\tint err;\n\n\tcdl->devs = NULL;\n\tcdl->len = 0;\n\tmutex_init(&cdl->lock);\n\n\terr = of_property_count_u32_elems(node, \"iommu-map\");\n\tif (err < 0)\n\t\treturn 0;\n\n\tcdl->len = err / 4;\n\tcdl->devs = kcalloc(cdl->len, sizeof(*cdl->devs), GFP_KERNEL);\n\tif (!cdl->devs)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < cdl->len; i++) {\n\t\tctx = &cdl->devs[i];\n\n\t\tctx->host = host1x;\n\n\t\tdevice_initialize(&ctx->dev);\n\n\t\t \n\t\tctx->dma_mask = DMA_BIT_MASK(38);\n\t\tctx->dev.dma_mask = &ctx->dma_mask;\n\t\tctx->dev.coherent_dma_mask = ctx->dma_mask;\n\t\tdev_set_name(&ctx->dev, \"host1x-ctx.%d\", i);\n\t\tctx->dev.bus = &host1x_context_device_bus_type;\n\t\tctx->dev.parent = host1x->dev;\n\t\tctx->dev.release = host1x_memory_context_release;\n\n\t\tdma_set_max_seg_size(&ctx->dev, UINT_MAX);\n\n\t\terr = device_add(&ctx->dev);\n\t\tif (err) {\n\t\t\tdev_err(host1x->dev, \"could not add context device %d: %d\\n\", i, err);\n\t\t\tput_device(&ctx->dev);\n\t\t\tgoto unreg_devices;\n\t\t}\n\n\t\terr = of_dma_configure_id(&ctx->dev, node, true, &i);\n\t\tif (err) {\n\t\t\tdev_err(host1x->dev, \"IOMMU configuration failed for context device %d: %d\\n\",\n\t\t\t\ti, err);\n\t\t\tdevice_unregister(&ctx->dev);\n\t\t\tgoto unreg_devices;\n\t\t}\n\n\t\tif (!tegra_dev_iommu_get_stream_id(&ctx->dev, &ctx->stream_id) ||\n\t\t    !device_iommu_mapped(&ctx->dev)) {\n\t\t\tdev_err(host1x->dev, \"Context device %d has no IOMMU!\\n\", i);\n\t\t\tdevice_unregister(&ctx->dev);\n\n\t\t\t \n\t\t\terr = -EINVAL;\n\n\t\t\tgoto unreg_devices;\n\t\t}\n\t}\n\n\treturn 0;\n\nunreg_devices:\n\twhile (i--)\n\t\tdevice_unregister(&cdl->devs[i].dev);\n\n\tkfree(cdl->devs);\n\tcdl->devs = NULL;\n\tcdl->len = 0;\n\n\treturn err;\n}\n\nvoid host1x_memory_context_list_free(struct host1x_memory_context_list *cdl)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < cdl->len; i++)\n\t\tdevice_unregister(&cdl->devs[i].dev);\n\n\tkfree(cdl->devs);\n\tcdl->len = 0;\n}\n\nstruct host1x_memory_context *host1x_memory_context_alloc(struct host1x *host1x,\n\t\t\t\t\t\t\t  struct device *dev,\n\t\t\t\t\t\t\t  struct pid *pid)\n{\n\tstruct host1x_memory_context_list *cdl = &host1x->context_list;\n\tstruct host1x_memory_context *free = NULL;\n\tint i;\n\n\tif (!cdl->len)\n\t\treturn ERR_PTR(-EOPNOTSUPP);\n\n\tmutex_lock(&cdl->lock);\n\n\tfor (i = 0; i < cdl->len; i++) {\n\t\tstruct host1x_memory_context *cd = &cdl->devs[i];\n\n\t\tif (cd->dev.iommu->iommu_dev != dev->iommu->iommu_dev)\n\t\t\tcontinue;\n\n\t\tif (cd->owner == pid) {\n\t\t\trefcount_inc(&cd->ref);\n\t\t\tmutex_unlock(&cdl->lock);\n\t\t\treturn cd;\n\t\t} else if (!cd->owner && !free) {\n\t\t\tfree = cd;\n\t\t}\n\t}\n\n\tif (!free) {\n\t\tmutex_unlock(&cdl->lock);\n\t\treturn ERR_PTR(-EBUSY);\n\t}\n\n\trefcount_set(&free->ref, 1);\n\tfree->owner = get_pid(pid);\n\n\tmutex_unlock(&cdl->lock);\n\n\treturn free;\n}\nEXPORT_SYMBOL_GPL(host1x_memory_context_alloc);\n\nvoid host1x_memory_context_get(struct host1x_memory_context *cd)\n{\n\trefcount_inc(&cd->ref);\n}\nEXPORT_SYMBOL_GPL(host1x_memory_context_get);\n\nvoid host1x_memory_context_put(struct host1x_memory_context *cd)\n{\n\tstruct host1x_memory_context_list *cdl = &cd->host->context_list;\n\n\tif (refcount_dec_and_mutex_lock(&cd->ref, &cdl->lock)) {\n\t\tput_pid(cd->owner);\n\t\tcd->owner = NULL;\n\t\tmutex_unlock(&cdl->lock);\n\t}\n}\nEXPORT_SYMBOL_GPL(host1x_memory_context_put);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}