{
  "module_name": "fence.c",
  "hash_id": "e4f78d60539d90e9e76ebc8a48160a300080fed5edef0b75f4faf6bdf112cfe8",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/host1x/fence.c",
  "human_readable_source": "\n \n\n#include <linux/dma-fence.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/sync_file.h>\n\n#include \"fence.h\"\n#include \"intr.h\"\n#include \"syncpt.h\"\n\nstatic const char *host1x_syncpt_fence_get_driver_name(struct dma_fence *f)\n{\n\treturn \"host1x\";\n}\n\nstatic const char *host1x_syncpt_fence_get_timeline_name(struct dma_fence *f)\n{\n\treturn \"syncpoint\";\n}\n\nstatic struct host1x_syncpt_fence *to_host1x_fence(struct dma_fence *f)\n{\n\treturn container_of(f, struct host1x_syncpt_fence, base);\n}\n\nstatic bool host1x_syncpt_fence_enable_signaling(struct dma_fence *f)\n{\n\tstruct host1x_syncpt_fence *sf = to_host1x_fence(f);\n\n\tif (host1x_syncpt_is_expired(sf->sp, sf->threshold))\n\t\treturn false;\n\n\t \n\tdma_fence_get(f);\n\n\t \n\tif (sf->timeout) {\n\t\t \n\t\tdma_fence_get(f);\n\t\tschedule_delayed_work(&sf->timeout_work, msecs_to_jiffies(30000));\n\t}\n\n\thost1x_intr_add_fence_locked(sf->sp->host, sf);\n\n\t \n\n\treturn true;\n}\n\nstatic const struct dma_fence_ops host1x_syncpt_fence_ops = {\n\t.get_driver_name = host1x_syncpt_fence_get_driver_name,\n\t.get_timeline_name = host1x_syncpt_fence_get_timeline_name,\n\t.enable_signaling = host1x_syncpt_fence_enable_signaling,\n};\n\nvoid host1x_fence_signal(struct host1x_syncpt_fence *f)\n{\n\tif (atomic_xchg(&f->signaling, 1)) {\n\t\t \n\t\tdma_fence_put(&f->base);\n\t\treturn;\n\t}\n\n\tif (f->timeout && cancel_delayed_work(&f->timeout_work)) {\n\t\t \n\t\tdma_fence_put(&f->base);\n\t}\n\n\tdma_fence_signal_locked(&f->base);\n\tdma_fence_put(&f->base);\n}\n\nstatic void do_fence_timeout(struct work_struct *work)\n{\n\tstruct delayed_work *dwork = (struct delayed_work *)work;\n\tstruct host1x_syncpt_fence *f =\n\t\tcontainer_of(dwork, struct host1x_syncpt_fence, timeout_work);\n\n\tif (atomic_xchg(&f->signaling, 1)) {\n\t\t \n\t\tif (f->timeout)\n\t\t\tdma_fence_put(&f->base);\n\t\treturn;\n\t}\n\n\tif (host1x_intr_remove_fence(f->sp->host, f)) {\n\t\t \n\t\tdma_fence_put(&f->base);\n\t}\n\n\tdma_fence_set_error(&f->base, -ETIMEDOUT);\n\tdma_fence_signal(&f->base);\n\tif (f->timeout)\n\t\tdma_fence_put(&f->base);\n}\n\nstruct dma_fence *host1x_fence_create(struct host1x_syncpt *sp, u32 threshold,\n\t\t\t\t      bool timeout)\n{\n\tstruct host1x_syncpt_fence *fence;\n\n\tfence = kzalloc(sizeof(*fence), GFP_KERNEL);\n\tif (!fence)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tfence->sp = sp;\n\tfence->threshold = threshold;\n\tfence->timeout = timeout;\n\n\tdma_fence_init(&fence->base, &host1x_syncpt_fence_ops, &sp->fences.lock,\n\t\t       dma_fence_context_alloc(1), 0);\n\n\tINIT_DELAYED_WORK(&fence->timeout_work, do_fence_timeout);\n\n\treturn &fence->base;\n}\nEXPORT_SYMBOL(host1x_fence_create);\n\nvoid host1x_fence_cancel(struct dma_fence *f)\n{\n\tstruct host1x_syncpt_fence *sf = to_host1x_fence(f);\n\n\tschedule_delayed_work(&sf->timeout_work, 0);\n\tflush_delayed_work(&sf->timeout_work);\n}\nEXPORT_SYMBOL(host1x_fence_cancel);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}