{
  "module_name": "intr.c",
  "hash_id": "92f450cffe0e5c843ee0d003713a002f4740e0fbaa559c2459f4d12e11e210a4",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/host1x/intr.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n\n#include \"dev.h\"\n#include \"fence.h\"\n#include \"intr.h\"\n\nstatic void host1x_intr_add_fence_to_list(struct host1x_fence_list *list,\n\t\t\t\t\t  struct host1x_syncpt_fence *fence)\n{\n\tstruct host1x_syncpt_fence *fence_in_list;\n\n\tlist_for_each_entry_reverse(fence_in_list, &list->list, list) {\n\t\tif ((s32)(fence_in_list->threshold - fence->threshold) <= 0) {\n\t\t\t \n\t\t\tlist_add(&fence->list, &fence_in_list->list);\n\t\t\treturn;\n\t\t}\n\t}\n\n\t \n\tlist_add(&fence->list, &list->list);\n}\n\nstatic void host1x_intr_update_hw_state(struct host1x *host, struct host1x_syncpt *sp)\n{\n\tstruct host1x_syncpt_fence *fence;\n\n\tif (!list_empty(&sp->fences.list)) {\n\t\tfence = list_first_entry(&sp->fences.list, struct host1x_syncpt_fence, list);\n\n\t\thost1x_hw_intr_set_syncpt_threshold(host, sp->id, fence->threshold);\n\t\thost1x_hw_intr_enable_syncpt_intr(host, sp->id);\n\t} else {\n\t\thost1x_hw_intr_disable_syncpt_intr(host, sp->id);\n\t}\n}\n\nvoid host1x_intr_add_fence_locked(struct host1x *host, struct host1x_syncpt_fence *fence)\n{\n\tstruct host1x_fence_list *fence_list = &fence->sp->fences;\n\n\tINIT_LIST_HEAD(&fence->list);\n\n\thost1x_intr_add_fence_to_list(fence_list, fence);\n\thost1x_intr_update_hw_state(host, fence->sp);\n}\n\nbool host1x_intr_remove_fence(struct host1x *host, struct host1x_syncpt_fence *fence)\n{\n\tstruct host1x_fence_list *fence_list = &fence->sp->fences;\n\tunsigned long irqflags;\n\n\tspin_lock_irqsave(&fence_list->lock, irqflags);\n\n\tif (list_empty(&fence->list)) {\n\t\tspin_unlock_irqrestore(&fence_list->lock, irqflags);\n\t\treturn false;\n\t}\n\n\tlist_del_init(&fence->list);\n\thost1x_intr_update_hw_state(host, fence->sp);\n\n\tspin_unlock_irqrestore(&fence_list->lock, irqflags);\n\n\treturn true;\n}\n\nvoid host1x_intr_handle_interrupt(struct host1x *host, unsigned int id)\n{\n\tstruct host1x_syncpt *sp = &host->syncpt[id];\n\tstruct host1x_syncpt_fence *fence, *tmp;\n\tunsigned int value;\n\n\tvalue = host1x_syncpt_load(sp);\n\n\tspin_lock(&sp->fences.lock);\n\n\tlist_for_each_entry_safe(fence, tmp, &sp->fences.list, list) {\n\t\tif (((value - fence->threshold) & 0x80000000U) != 0U) {\n\t\t\t \n\t\t\tbreak;\n\t\t}\n\n\t\tlist_del_init(&fence->list);\n\t\thost1x_fence_signal(fence);\n\t}\n\n\t \n\thost1x_intr_update_hw_state(host, sp);\n\n\tspin_unlock(&sp->fences.lock);\n}\n\nint host1x_intr_init(struct host1x *host)\n{\n\tunsigned int id;\n\n\tmutex_init(&host->intr_mutex);\n\n\tfor (id = 0; id < host1x_syncpt_nb_pts(host); ++id) {\n\t\tstruct host1x_syncpt *syncpt = &host->syncpt[id];\n\n\t\tspin_lock_init(&syncpt->fences.lock);\n\t\tINIT_LIST_HEAD(&syncpt->fences.list);\n\t}\n\n\treturn 0;\n}\n\nvoid host1x_intr_deinit(struct host1x *host)\n{\n}\n\nvoid host1x_intr_start(struct host1x *host)\n{\n\tu32 hz = clk_get_rate(host->clk);\n\tint err;\n\n\tmutex_lock(&host->intr_mutex);\n\terr = host1x_hw_intr_init_host_sync(host, DIV_ROUND_UP(hz, 1000000));\n\tif (err) {\n\t\tmutex_unlock(&host->intr_mutex);\n\t\treturn;\n\t}\n\tmutex_unlock(&host->intr_mutex);\n}\n\nvoid host1x_intr_stop(struct host1x *host)\n{\n\thost1x_hw_intr_disable_all_syncpt_intrs(host);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}