{
  "module_name": "debug_hw_1x06.c",
  "hash_id": "6e8ae1084cdea11529b6b587a9ba1747aa22faa7e084bf1334f13ffd2e775ef4",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/host1x/hw/debug_hw_1x06.c",
  "human_readable_source": "\n \n\n#include \"../dev.h\"\n#include \"../debug.h\"\n#include \"../cdma.h\"\n#include \"../channel.h\"\n\nstatic void host1x_debug_show_channel_cdma(struct host1x *host,\n\t\t\t\t\t   struct host1x_channel *ch,\n\t\t\t\t\t   struct output *o)\n{\n\tstruct host1x_cdma *cdma = &ch->cdma;\n\tdma_addr_t dmastart = 0, dmaend = 0;\n\tu32 dmaput, dmaget, dmactrl;\n\tu32 offset, class;\n\tu32 ch_stat;\n\n#if defined(CONFIG_ARCH_DMA_ADDR_T_64BIT) && HOST1X_HW >= 6\n\tdmastart = host1x_ch_readl(ch, HOST1X_CHANNEL_DMASTART_HI);\n\tdmastart <<= 32;\n#endif\n\tdmastart |= host1x_ch_readl(ch, HOST1X_CHANNEL_DMASTART);\n\n#if defined(CONFIG_ARCH_DMA_ADDR_T_64BIT) && HOST1X_HW >= 6\n\tdmaend = host1x_ch_readl(ch, HOST1X_CHANNEL_DMAEND_HI);\n\tdmaend <<= 32;\n#endif\n\tdmaend |= host1x_ch_readl(ch, HOST1X_CHANNEL_DMAEND);\n\n\tdmaput = host1x_ch_readl(ch, HOST1X_CHANNEL_DMAPUT);\n\tdmaget = host1x_ch_readl(ch, HOST1X_CHANNEL_DMAGET);\n\tdmactrl = host1x_ch_readl(ch, HOST1X_CHANNEL_DMACTRL);\n\toffset = host1x_ch_readl(ch, HOST1X_CHANNEL_CMDP_OFFSET);\n\tclass = host1x_ch_readl(ch, HOST1X_CHANNEL_CMDP_CLASS);\n\tch_stat = host1x_ch_readl(ch, HOST1X_CHANNEL_CHANNELSTAT);\n\n\thost1x_debug_output(o, \"%u-%s: \", ch->id, dev_name(ch->dev));\n\n\tif (dmactrl & HOST1X_CHANNEL_DMACTRL_DMASTOP ||\n\t    !ch->cdma.push_buffer.mapped) {\n\t\thost1x_debug_output(o, \"inactive\\n\\n\");\n\t\treturn;\n\t}\n\n\tif (class == HOST1X_CLASS_HOST1X && offset == HOST1X_UCLASS_WAIT_SYNCPT)\n\t\thost1x_debug_output(o, \"waiting on syncpt\\n\");\n\telse\n\t\thost1x_debug_output(o, \"active class %02x, offset %04x\\n\",\n\t\t\t\t    class, offset);\n\n\thost1x_debug_output(o, \"DMASTART %pad, DMAEND %pad\\n\", &dmastart, &dmaend);\n\thost1x_debug_output(o, \"DMAPUT %08x DMAGET %08x DMACTL %08x\\n\",\n\t\t\t    dmaput, dmaget, dmactrl);\n\thost1x_debug_output(o, \"CHANNELSTAT %02x\\n\", ch_stat);\n\n\tshow_channel_gathers(o, cdma);\n\thost1x_debug_output(o, \"\\n\");\n}\n\nstatic void host1x_debug_show_channel_fifo(struct host1x *host,\n\t\t\t\t\t   struct host1x_channel *ch,\n\t\t\t\t\t   struct output *o)\n{\n#if HOST1X_HW <= 6\n\tu32 rd_ptr, wr_ptr, start, end;\n\tu32 payload = INVALID_PAYLOAD;\n\tunsigned int data_count = 0;\n#endif\n\tu32 val;\n\n\thost1x_debug_output(o, \"%u: fifo:\\n\", ch->id);\n\n\tval = host1x_ch_readl(ch, HOST1X_CHANNEL_CMDFIFO_STAT);\n\thost1x_debug_output(o, \"CMDFIFO_STAT %08x\\n\", val);\n\tif (val & HOST1X_CHANNEL_CMDFIFO_STAT_EMPTY) {\n\t\thost1x_debug_output(o, \"[empty]\\n\");\n\t\treturn;\n\t}\n\n\tval = host1x_ch_readl(ch, HOST1X_CHANNEL_CMDFIFO_RDATA);\n\thost1x_debug_output(o, \"CMDFIFO_RDATA %08x\\n\", val);\n\n#if HOST1X_HW <= 6\n\t \n\thost1x_hypervisor_writel(host, 0x1, HOST1X_HV_ICG_EN_OVERRIDE);\n\n\tval = 0;\n\tval |= HOST1X_HV_CMDFIFO_PEEK_CTRL_ENABLE;\n\tval |= HOST1X_HV_CMDFIFO_PEEK_CTRL_CHANNEL(ch->id);\n\thost1x_hypervisor_writel(host, val, HOST1X_HV_CMDFIFO_PEEK_CTRL);\n\n\tval = host1x_hypervisor_readl(host, HOST1X_HV_CMDFIFO_PEEK_PTRS);\n\trd_ptr = HOST1X_HV_CMDFIFO_PEEK_PTRS_RD_PTR_V(val);\n\twr_ptr = HOST1X_HV_CMDFIFO_PEEK_PTRS_WR_PTR_V(val);\n\n\tval = host1x_hypervisor_readl(host, HOST1X_HV_CMDFIFO_SETUP(ch->id));\n\tstart = HOST1X_HV_CMDFIFO_SETUP_BASE_V(val);\n\tend = HOST1X_HV_CMDFIFO_SETUP_LIMIT_V(val);\n\n\tdo {\n\t\tval = 0;\n\t\tval |= HOST1X_HV_CMDFIFO_PEEK_CTRL_ENABLE;\n\t\tval |= HOST1X_HV_CMDFIFO_PEEK_CTRL_CHANNEL(ch->id);\n\t\tval |= HOST1X_HV_CMDFIFO_PEEK_CTRL_ADDR(rd_ptr);\n\t\thost1x_hypervisor_writel(host, val,\n\t\t\t\t\t HOST1X_HV_CMDFIFO_PEEK_CTRL);\n\n\t\tval = host1x_hypervisor_readl(host,\n\t\t\t\t\t      HOST1X_HV_CMDFIFO_PEEK_READ);\n\n\t\tif (!data_count) {\n\t\t\thost1x_debug_output(o, \"%03x 0x%08x: \",\n\t\t\t\t\t    rd_ptr - start, val);\n\t\t\tdata_count = show_channel_command(o, val, &payload);\n\t\t} else {\n\t\t\thost1x_debug_cont(o, \"%08x%s\", val,\n\t\t\t\t\t  data_count > 1 ? \", \" : \"])\\n\");\n\t\t\tdata_count--;\n\t\t}\n\n\t\tif (rd_ptr == end)\n\t\t\trd_ptr = start;\n\t\telse\n\t\t\trd_ptr++;\n\t} while (rd_ptr != wr_ptr);\n\n\tif (data_count)\n\t\thost1x_debug_cont(o, \", ...])\\n\");\n\thost1x_debug_output(o, \"\\n\");\n\n\thost1x_hypervisor_writel(host, 0x0, HOST1X_HV_CMDFIFO_PEEK_CTRL);\n\thost1x_hypervisor_writel(host, 0x0, HOST1X_HV_ICG_EN_OVERRIDE);\n#endif\n}\n\nstatic void host1x_debug_show_mlocks(struct host1x *host, struct output *o)\n{\n\t \n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}