{
  "module_name": "cdma_hw.c",
  "hash_id": "4caad86b854539f629d35846a1b1d11dd6573fb67f8b4bd39b61e9f172d415a5",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/host1x/hw/cdma_hw.c",
  "human_readable_source": "\n \n\n#include <linux/slab.h>\n#include <linux/scatterlist.h>\n#include <linux/dma-mapping.h>\n\n#include \"../cdma.h\"\n#include \"../channel.h\"\n#include \"../dev.h\"\n#include \"../debug.h\"\n\n \nstatic void push_buffer_init(struct push_buffer *pb)\n{\n\t*(u32 *)(pb->mapped + pb->size) = host1x_opcode_restart(0);\n}\n\n \nstatic void cdma_timeout_cpu_incr(struct host1x_cdma *cdma, u32 getptr,\n\t\t\t\tu32 syncpt_incrs, u32 syncval, u32 nr_slots)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < syncpt_incrs; i++)\n\t\thost1x_syncpt_incr(cdma->timeout.syncpt);\n\n\t \n\thost1x_syncpt_load(cdma->timeout.syncpt);\n}\n\n \nstatic void cdma_start(struct host1x_cdma *cdma)\n{\n\tstruct host1x_channel *ch = cdma_to_channel(cdma);\n\tu64 start, end;\n\n\tif (cdma->running)\n\t\treturn;\n\n\tcdma->last_pos = cdma->push_buffer.pos;\n\tstart = cdma->push_buffer.dma;\n\tend = cdma->push_buffer.size + 4;\n\n\thost1x_ch_writel(ch, HOST1X_CHANNEL_DMACTRL_DMASTOP,\n\t\t\t HOST1X_CHANNEL_DMACTRL);\n\n\t \n\thost1x_ch_writel(ch, lower_32_bits(start), HOST1X_CHANNEL_DMASTART);\n#if HOST1X_HW >= 6\n\thost1x_ch_writel(ch, upper_32_bits(start), HOST1X_CHANNEL_DMASTART_HI);\n#endif\n\thost1x_ch_writel(ch, cdma->push_buffer.pos, HOST1X_CHANNEL_DMAPUT);\n#if HOST1X_HW >= 6\n\thost1x_ch_writel(ch, 0, HOST1X_CHANNEL_DMAPUT_HI);\n#endif\n\thost1x_ch_writel(ch, lower_32_bits(end), HOST1X_CHANNEL_DMAEND);\n#if HOST1X_HW >= 6\n\thost1x_ch_writel(ch, upper_32_bits(end), HOST1X_CHANNEL_DMAEND_HI);\n#endif\n\n\t \n\thost1x_ch_writel(ch, HOST1X_CHANNEL_DMACTRL_DMASTOP |\n\t\t\t HOST1X_CHANNEL_DMACTRL_DMAGETRST |\n\t\t\t HOST1X_CHANNEL_DMACTRL_DMAINITGET,\n\t\t\t HOST1X_CHANNEL_DMACTRL);\n\n\t \n\thost1x_ch_writel(ch, 0, HOST1X_CHANNEL_DMACTRL);\n\n\tcdma->running = true;\n}\n\n \nstatic void cdma_timeout_restart(struct host1x_cdma *cdma, u32 getptr)\n{\n\tstruct host1x *host1x = cdma_to_host1x(cdma);\n\tstruct host1x_channel *ch = cdma_to_channel(cdma);\n\tu64 start, end;\n\n\tif (cdma->running)\n\t\treturn;\n\n\tcdma->last_pos = cdma->push_buffer.pos;\n\n\thost1x_ch_writel(ch, HOST1X_CHANNEL_DMACTRL_DMASTOP,\n\t\t\t HOST1X_CHANNEL_DMACTRL);\n\n\tstart = cdma->push_buffer.dma;\n\tend = cdma->push_buffer.size + 4;\n\n\t \n\thost1x_ch_writel(ch, lower_32_bits(start), HOST1X_CHANNEL_DMASTART);\n#if HOST1X_HW >= 6\n\thost1x_ch_writel(ch, upper_32_bits(start), HOST1X_CHANNEL_DMASTART_HI);\n#endif\n\thost1x_ch_writel(ch, lower_32_bits(end), HOST1X_CHANNEL_DMAEND);\n#if HOST1X_HW >= 6\n\thost1x_ch_writel(ch, upper_32_bits(end), HOST1X_CHANNEL_DMAEND_HI);\n#endif\n\n\t \n\thost1x_ch_writel(ch, getptr, HOST1X_CHANNEL_DMAPUT);\n\thost1x_ch_writel(ch, HOST1X_CHANNEL_DMACTRL_DMASTOP |\n\t\t\t HOST1X_CHANNEL_DMACTRL_DMAGETRST |\n\t\t\t HOST1X_CHANNEL_DMACTRL_DMAINITGET,\n\t\t\t HOST1X_CHANNEL_DMACTRL);\n\n\tdev_dbg(host1x->dev,\n\t\t\"%s: DMA GET 0x%x, PUT HW 0x%x / shadow 0x%x\\n\", __func__,\n\t\thost1x_ch_readl(ch, HOST1X_CHANNEL_DMAGET),\n\t\thost1x_ch_readl(ch, HOST1X_CHANNEL_DMAPUT),\n\t\tcdma->last_pos);\n\n\t \n\thost1x_ch_writel(ch, HOST1X_CHANNEL_DMACTRL_DMASTOP,\n\t\t\t HOST1X_CHANNEL_DMACTRL);\n\thost1x_ch_writel(ch, cdma->push_buffer.pos, HOST1X_CHANNEL_DMAPUT);\n\n\t \n\thost1x_ch_writel(ch, 0, HOST1X_CHANNEL_DMACTRL);\n\n\tcdma->running = true;\n}\n\n \nstatic void cdma_flush(struct host1x_cdma *cdma)\n{\n\tstruct host1x_channel *ch = cdma_to_channel(cdma);\n\n\tif (cdma->push_buffer.pos != cdma->last_pos) {\n\t\thost1x_ch_writel(ch, cdma->push_buffer.pos,\n\t\t\t\t HOST1X_CHANNEL_DMAPUT);\n\t\tcdma->last_pos = cdma->push_buffer.pos;\n\t}\n}\n\nstatic void cdma_stop(struct host1x_cdma *cdma)\n{\n\tstruct host1x_channel *ch = cdma_to_channel(cdma);\n\n\tmutex_lock(&cdma->lock);\n\n\tif (cdma->running) {\n\t\thost1x_cdma_wait_locked(cdma, CDMA_EVENT_SYNC_QUEUE_EMPTY);\n\t\thost1x_ch_writel(ch, HOST1X_CHANNEL_DMACTRL_DMASTOP,\n\t\t\t\t HOST1X_CHANNEL_DMACTRL);\n\t\tcdma->running = false;\n\t}\n\n\tmutex_unlock(&cdma->lock);\n}\n\nstatic void cdma_hw_cmdproc_stop(struct host1x *host, struct host1x_channel *ch,\n\t\t\t\t bool stop)\n{\n#if HOST1X_HW >= 6\n\thost1x_ch_writel(ch, stop ? 0x1 : 0x0, HOST1X_CHANNEL_CMDPROC_STOP);\n#else\n\tu32 cmdproc_stop = host1x_sync_readl(host, HOST1X_SYNC_CMDPROC_STOP);\n\tif (stop)\n\t\tcmdproc_stop |= BIT(ch->id);\n\telse\n\t\tcmdproc_stop &= ~BIT(ch->id);\n\thost1x_sync_writel(host, cmdproc_stop, HOST1X_SYNC_CMDPROC_STOP);\n#endif\n}\n\nstatic void cdma_hw_teardown(struct host1x *host, struct host1x_channel *ch)\n{\n#if HOST1X_HW >= 6\n\thost1x_ch_writel(ch, 0x1, HOST1X_CHANNEL_TEARDOWN);\n#else\n\thost1x_sync_writel(host, BIT(ch->id), HOST1X_SYNC_CH_TEARDOWN);\n#endif\n}\n\n \nstatic void cdma_freeze(struct host1x_cdma *cdma)\n{\n\tstruct host1x *host = cdma_to_host1x(cdma);\n\tstruct host1x_channel *ch = cdma_to_channel(cdma);\n\n\tif (cdma->torndown && !cdma->running) {\n\t\tdev_warn(host->dev, \"Already torn down\\n\");\n\t\treturn;\n\t}\n\n\tdev_dbg(host->dev, \"freezing channel (id %d)\\n\", ch->id);\n\n\tcdma_hw_cmdproc_stop(host, ch, true);\n\n\tdev_dbg(host->dev, \"%s: DMA GET 0x%x, PUT HW 0x%x / shadow 0x%x\\n\",\n\t\t__func__, host1x_ch_readl(ch, HOST1X_CHANNEL_DMAGET),\n\t\thost1x_ch_readl(ch, HOST1X_CHANNEL_DMAPUT),\n\t\tcdma->last_pos);\n\n\thost1x_ch_writel(ch, HOST1X_CHANNEL_DMACTRL_DMASTOP,\n\t\t\t HOST1X_CHANNEL_DMACTRL);\n\n\tcdma_hw_teardown(host, ch);\n\n\tcdma->running = false;\n\tcdma->torndown = true;\n}\n\nstatic void cdma_resume(struct host1x_cdma *cdma, u32 getptr)\n{\n\tstruct host1x *host1x = cdma_to_host1x(cdma);\n\tstruct host1x_channel *ch = cdma_to_channel(cdma);\n\n\tdev_dbg(host1x->dev,\n\t\t\"resuming channel (id %u, DMAGET restart = 0x%x)\\n\",\n\t\tch->id, getptr);\n\n\tcdma_hw_cmdproc_stop(host1x, ch, false);\n\n\tcdma->torndown = false;\n\tcdma_timeout_restart(cdma, getptr);\n}\n\nstatic void timeout_release_mlock(struct host1x_cdma *cdma)\n{\n#if HOST1X_HW >= 8\n\t \n\tstruct host1x_channel *ch = cdma_to_channel(cdma);\n\tstruct host1x *host1x = cdma_to_host1x(cdma);\n\tu32 offset;\n\n\tswitch (ch->client->class) {\n\tcase HOST1X_CLASS_VIC:\n\t\toffset = HOST1X_COMMON_VIC_MLOCK;\n\t\tbreak;\n\tcase HOST1X_CLASS_NVDEC:\n\t\toffset = HOST1X_COMMON_NVDEC_MLOCK;\n\t\tbreak;\n\tdefault:\n\t\tWARN(1, \"%s was not updated for class %u\", __func__, ch->client->class);\n\t\treturn;\n\t}\n\n\thost1x_common_writel(host1x, 0x0, offset);\n#endif\n}\n\n \nstatic void cdma_timeout_handler(struct work_struct *work)\n{\n\tu32 syncpt_val;\n\tstruct host1x_cdma *cdma;\n\tstruct host1x *host1x;\n\tstruct host1x_channel *ch;\n\n\tcdma = container_of(to_delayed_work(work), struct host1x_cdma,\n\t\t\t    timeout.wq);\n\thost1x = cdma_to_host1x(cdma);\n\tch = cdma_to_channel(cdma);\n\n\thost1x_debug_dump(cdma_to_host1x(cdma));\n\n\tmutex_lock(&cdma->lock);\n\n\tif (!cdma->timeout.client) {\n\t\tdev_dbg(host1x->dev,\n\t\t\t\"cdma_timeout: expired, but has no clientid\\n\");\n\t\tmutex_unlock(&cdma->lock);\n\t\treturn;\n\t}\n\n\t \n\tcdma_hw_cmdproc_stop(host1x, ch, true);\n\n\tsyncpt_val = host1x_syncpt_load(cdma->timeout.syncpt);\n\n\t \n\tif ((s32)(syncpt_val - cdma->timeout.syncpt_val) >= 0) {\n\t\tdev_dbg(host1x->dev,\n\t\t\t\"cdma_timeout: expired, but buffer had completed\\n\");\n\t\t \n\t\tcdma_hw_cmdproc_stop(host1x, ch, false);\n\t\tmutex_unlock(&cdma->lock);\n\t\treturn;\n\t}\n\n\tdev_warn(host1x->dev, \"%s: timeout: %u (%s), HW thresh %d, done %d\\n\",\n\t\t __func__, cdma->timeout.syncpt->id, cdma->timeout.syncpt->name,\n\t\t syncpt_val, cdma->timeout.syncpt_val);\n\n\t \n\thost1x_hw_cdma_freeze(host1x, cdma);\n\n\t \n\ttimeout_release_mlock(cdma);\n\n\thost1x_cdma_update_sync_queue(cdma, ch->dev);\n\tmutex_unlock(&cdma->lock);\n}\n\n \nstatic int cdma_timeout_init(struct host1x_cdma *cdma)\n{\n\tINIT_DELAYED_WORK(&cdma->timeout.wq, cdma_timeout_handler);\n\tcdma->timeout.initialized = true;\n\n\treturn 0;\n}\n\n \nstatic void cdma_timeout_destroy(struct host1x_cdma *cdma)\n{\n\tif (cdma->timeout.initialized)\n\t\tcancel_delayed_work(&cdma->timeout.wq);\n\n\tcdma->timeout.initialized = false;\n}\n\nstatic const struct host1x_cdma_ops host1x_cdma_ops = {\n\t.start = cdma_start,\n\t.stop = cdma_stop,\n\t.flush = cdma_flush,\n\n\t.timeout_init = cdma_timeout_init,\n\t.timeout_destroy = cdma_timeout_destroy,\n\t.freeze = cdma_freeze,\n\t.resume = cdma_resume,\n\t.timeout_cpu_incr = cdma_timeout_cpu_incr,\n};\n\nstatic const struct host1x_pushbuffer_ops host1x_pushbuffer_ops = {\n\t.init = push_buffer_init,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}