{
  "module_name": "intr_hw.c",
  "hash_id": "01af167db41467787c125121e982faf43fed5b1e258e200b3599183e617f44df",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/host1x/hw/intr_hw.c",
  "human_readable_source": "\n \n\n#include <linux/interrupt.h>\n#include <linux/irq.h>\n#include <linux/io.h>\n\n#include \"../intr.h\"\n#include \"../dev.h\"\n\nstatic irqreturn_t syncpt_thresh_isr(int irq, void *dev_id)\n{\n\tstruct host1x *host = dev_id;\n\tunsigned long reg;\n\tunsigned int i, id;\n\n\tfor (i = 0; i < DIV_ROUND_UP(host->info->nb_pts, 32); i++) {\n\t\treg = host1x_sync_readl(host,\n\t\t\tHOST1X_SYNC_SYNCPT_THRESH_CPU0_INT_STATUS(i));\n\n\t\thost1x_sync_writel(host, reg,\n\t\t\tHOST1X_SYNC_SYNCPT_THRESH_INT_DISABLE(i));\n\t\thost1x_sync_writel(host, reg,\n\t\t\tHOST1X_SYNC_SYNCPT_THRESH_CPU0_INT_STATUS(i));\n\n\t\tfor_each_set_bit(id, &reg, 32)\n\t\t\thost1x_intr_handle_interrupt(host, i * 32 + id);\n\t}\n\n\treturn IRQ_HANDLED;\n}\n\nstatic void host1x_intr_disable_all_syncpt_intrs(struct host1x *host)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < DIV_ROUND_UP(host->info->nb_pts, 32); ++i) {\n\t\thost1x_sync_writel(host, 0xffffffffu,\n\t\t\tHOST1X_SYNC_SYNCPT_THRESH_INT_DISABLE(i));\n\t\thost1x_sync_writel(host, 0xffffffffu,\n\t\t\tHOST1X_SYNC_SYNCPT_THRESH_CPU0_INT_STATUS(i));\n\t}\n}\n\nstatic void intr_hw_init(struct host1x *host, u32 cpm)\n{\n#if HOST1X_HW < 6\n\t \n\thost1x_sync_writel(host, 0, HOST1X_SYNC_IP_BUSY_TIMEOUT);\n\n\t \n\thost1x_sync_writel(host, 0xff, HOST1X_SYNC_CTXSW_TIMEOUT_CFG);\n\n\t \n\thost1x_sync_writel(host, cpm, HOST1X_SYNC_USEC_CLK);\n#endif\n#if HOST1X_HW >= 8\n\tu32 id;\n\n\t \n\tfor (id = 0; id < host->info->nb_pts; id++)\n\t\thost1x_sync_writel(host, 0, HOST1X_SYNC_SYNCPT_INTR_DEST(id));\n#endif\n}\n\nstatic int\nhost1x_intr_init_host_sync(struct host1x *host, u32 cpm)\n{\n\tint err;\n\n\thost1x_hw_intr_disable_all_syncpt_intrs(host);\n\n\terr = devm_request_irq(host->dev, host->syncpt_irq,\n\t\t\t       syncpt_thresh_isr, IRQF_SHARED,\n\t\t\t       \"host1x_syncpt\", host);\n\tif (err < 0)\n\t\treturn err;\n\n\tintr_hw_init(host, cpm);\n\n\treturn 0;\n}\n\nstatic void host1x_intr_set_syncpt_threshold(struct host1x *host,\n\t\t\t\t\t      unsigned int id,\n\t\t\t\t\t      u32 thresh)\n{\n\thost1x_sync_writel(host, thresh, HOST1X_SYNC_SYNCPT_INT_THRESH(id));\n}\n\nstatic void host1x_intr_enable_syncpt_intr(struct host1x *host,\n\t\t\t\t\t    unsigned int id)\n{\n\thost1x_sync_writel(host, BIT(id % 32),\n\t\tHOST1X_SYNC_SYNCPT_THRESH_INT_ENABLE_CPU0(id / 32));\n}\n\nstatic void host1x_intr_disable_syncpt_intr(struct host1x *host,\n\t\t\t\t\t     unsigned int id)\n{\n\thost1x_sync_writel(host, BIT(id % 32),\n\t\tHOST1X_SYNC_SYNCPT_THRESH_INT_DISABLE(id / 32));\n\thost1x_sync_writel(host, BIT(id % 32),\n\t\tHOST1X_SYNC_SYNCPT_THRESH_CPU0_INT_STATUS(id / 32));\n}\n\nstatic const struct host1x_intr_ops host1x_intr_ops = {\n\t.init_host_sync = host1x_intr_init_host_sync,\n\t.set_syncpt_threshold = host1x_intr_set_syncpt_threshold,\n\t.enable_syncpt_intr = host1x_intr_enable_syncpt_intr,\n\t.disable_syncpt_intr = host1x_intr_disable_syncpt_intr,\n\t.disable_all_syncpt_intrs = host1x_intr_disable_all_syncpt_intrs,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}