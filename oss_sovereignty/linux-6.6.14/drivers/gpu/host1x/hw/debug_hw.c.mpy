{
  "module_name": "debug_hw.c",
  "hash_id": "69dc88f14e7e37cbe16a6c9ee2d59bb2d314004690d9c1459d4b7303d5664a76",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/host1x/hw/debug_hw.c",
  "human_readable_source": "\n \n\n#include \"../dev.h\"\n#include \"../debug.h\"\n#include \"../cdma.h\"\n#include \"../channel.h\"\n\n#define HOST1X_DEBUG_MAX_PAGE_OFFSET 102400\n\nenum {\n\tHOST1X_OPCODE_SETCLASS\t= 0x00,\n\tHOST1X_OPCODE_INCR\t= 0x01,\n\tHOST1X_OPCODE_NONINCR\t= 0x02,\n\tHOST1X_OPCODE_MASK\t= 0x03,\n\tHOST1X_OPCODE_IMM\t= 0x04,\n\tHOST1X_OPCODE_RESTART\t= 0x05,\n\tHOST1X_OPCODE_GATHER\t= 0x06,\n\tHOST1X_OPCODE_SETSTRMID = 0x07,\n\tHOST1X_OPCODE_SETAPPID  = 0x08,\n\tHOST1X_OPCODE_SETPYLD   = 0x09,\n\tHOST1X_OPCODE_INCR_W    = 0x0a,\n\tHOST1X_OPCODE_NONINCR_W = 0x0b,\n\tHOST1X_OPCODE_GATHER_W  = 0x0c,\n\tHOST1X_OPCODE_RESTART_W = 0x0d,\n\tHOST1X_OPCODE_EXTEND\t= 0x0e,\n};\n\nenum {\n\tHOST1X_OPCODE_EXTEND_ACQUIRE_MLOCK\t= 0x00,\n\tHOST1X_OPCODE_EXTEND_RELEASE_MLOCK\t= 0x01,\n};\n\n#define INVALID_PAYLOAD\t\t\t\t0xffffffff\n\nstatic unsigned int show_channel_command(struct output *o, u32 val,\n\t\t\t\t\t u32 *payload)\n{\n\tunsigned int mask, subop, num, opcode;\n\n\topcode = val >> 28;\n\n\tswitch (opcode) {\n\tcase HOST1X_OPCODE_SETCLASS:\n\t\tmask = val & 0x3f;\n\t\tif (mask) {\n\t\t\thost1x_debug_cont(o, \"SETCL(class=%03x, offset=%03x, mask=%02x, [\",\n\t\t\t\t\t    val >> 6 & 0x3ff,\n\t\t\t\t\t    val >> 16 & 0xfff, mask);\n\t\t\treturn hweight8(mask);\n\t\t}\n\n\t\thost1x_debug_cont(o, \"SETCL(class=%03x)\\n\", val >> 6 & 0x3ff);\n\t\treturn 0;\n\n\tcase HOST1X_OPCODE_INCR:\n\t\tnum = val & 0xffff;\n\t\thost1x_debug_cont(o, \"INCR(offset=%03x, [\",\n\t\t\t\t    val >> 16 & 0xfff);\n\t\tif (!num)\n\t\t\thost1x_debug_cont(o, \"])\\n\");\n\n\t\treturn num;\n\n\tcase HOST1X_OPCODE_NONINCR:\n\t\tnum = val & 0xffff;\n\t\thost1x_debug_cont(o, \"NONINCR(offset=%03x, [\",\n\t\t\t\t    val >> 16 & 0xfff);\n\t\tif (!num)\n\t\t\thost1x_debug_cont(o, \"])\\n\");\n\n\t\treturn num;\n\n\tcase HOST1X_OPCODE_MASK:\n\t\tmask = val & 0xffff;\n\t\thost1x_debug_cont(o, \"MASK(offset=%03x, mask=%03x, [\",\n\t\t\t\t    val >> 16 & 0xfff, mask);\n\t\tif (!mask)\n\t\t\thost1x_debug_cont(o, \"])\\n\");\n\n\t\treturn hweight16(mask);\n\n\tcase HOST1X_OPCODE_IMM:\n\t\thost1x_debug_cont(o, \"IMM(offset=%03x, data=%03x)\\n\",\n\t\t\t\t    val >> 16 & 0xfff, val & 0xffff);\n\t\treturn 0;\n\n\tcase HOST1X_OPCODE_RESTART:\n\t\thost1x_debug_cont(o, \"RESTART(offset=%08x)\\n\", val << 4);\n\t\treturn 0;\n\n\tcase HOST1X_OPCODE_GATHER:\n\t\thost1x_debug_cont(o, \"GATHER(offset=%03x, insert=%d, type=%d, count=%04x, addr=[\",\n\t\t\t\t    val >> 16 & 0xfff, val >> 15 & 0x1,\n\t\t\t\t    val >> 14 & 0x1, val & 0x3fff);\n\t\treturn 1;\n\n#if HOST1X_HW >= 6\n\tcase HOST1X_OPCODE_SETSTRMID:\n\t\thost1x_debug_cont(o, \"SETSTRMID(offset=%06x)\\n\",\n\t\t\t\t  val & 0x3fffff);\n\t\treturn 0;\n\n\tcase HOST1X_OPCODE_SETAPPID:\n\t\thost1x_debug_cont(o, \"SETAPPID(appid=%02x)\\n\", val & 0xff);\n\t\treturn 0;\n\n\tcase HOST1X_OPCODE_SETPYLD:\n\t\t*payload = val & 0xffff;\n\t\thost1x_debug_cont(o, \"SETPYLD(data=%04x)\\n\", *payload);\n\t\treturn 0;\n\n\tcase HOST1X_OPCODE_INCR_W:\n\tcase HOST1X_OPCODE_NONINCR_W:\n\t\thost1x_debug_cont(o, \"%s(offset=%06x, \",\n\t\t\t\t  opcode == HOST1X_OPCODE_INCR_W ?\n\t\t\t\t\t\"INCR_W\" : \"NONINCR_W\",\n\t\t\t\t  val & 0x3fffff);\n\t\tif (*payload == 0) {\n\t\t\thost1x_debug_cont(o, \"[])\\n\");\n\t\t\treturn 0;\n\t\t} else if (*payload == INVALID_PAYLOAD) {\n\t\t\thost1x_debug_cont(o, \"unknown)\\n\");\n\t\t\treturn 0;\n\t\t} else {\n\t\t\thost1x_debug_cont(o, \"[\");\n\t\t\treturn *payload;\n\t\t}\n\n\tcase HOST1X_OPCODE_GATHER_W:\n\t\thost1x_debug_cont(o, \"GATHER_W(count=%04x, addr=[\",\n\t\t\t\t  val & 0x3fff);\n\t\treturn 2;\n#endif\n\n\tcase HOST1X_OPCODE_EXTEND:\n\t\tsubop = val >> 24 & 0xf;\n\t\tif (subop == HOST1X_OPCODE_EXTEND_ACQUIRE_MLOCK)\n\t\t\thost1x_debug_cont(o, \"ACQUIRE_MLOCK(index=%d)\\n\",\n\t\t\t\t\t    val & 0xff);\n\t\telse if (subop == HOST1X_OPCODE_EXTEND_RELEASE_MLOCK)\n\t\t\thost1x_debug_cont(o, \"RELEASE_MLOCK(index=%d)\\n\",\n\t\t\t\t\t    val & 0xff);\n\t\telse\n\t\t\thost1x_debug_cont(o, \"EXTEND_UNKNOWN(%08x)\\n\", val);\n\t\treturn 0;\n\n\tdefault:\n\t\thost1x_debug_cont(o, \"UNKNOWN\\n\");\n\t\treturn 0;\n\t}\n}\n\nstatic void show_gather(struct output *o, dma_addr_t phys_addr,\n\t\t\tunsigned int words, struct host1x_cdma *cdma,\n\t\t\tdma_addr_t pin_addr, u32 *map_addr)\n{\n\t \n\tu32 offset = phys_addr - pin_addr;\n\tunsigned int data_count = 0, i;\n\tu32 payload = INVALID_PAYLOAD;\n\n\t \n\tif (offset > HOST1X_DEBUG_MAX_PAGE_OFFSET) {\n\t\thost1x_debug_output(o, \"[address mismatch]\\n\");\n\t\treturn;\n\t}\n\n\tfor (i = 0; i < words; i++) {\n\t\tdma_addr_t addr = phys_addr + i * 4;\n\t\tu32 val = *(map_addr + offset / 4 + i);\n\n\t\tif (!data_count) {\n\t\t\thost1x_debug_output(o, \"    %pad: %08x: \", &addr, val);\n\t\t\tdata_count = show_channel_command(o, val, &payload);\n\t\t} else {\n\t\t\thost1x_debug_cont(o, \"%08x%s\", val,\n\t\t\t\t\t    data_count > 1 ? \", \" : \"])\\n\");\n\t\t\tdata_count--;\n\t\t}\n\t}\n}\n\nstatic void show_channel_gathers(struct output *o, struct host1x_cdma *cdma)\n{\n\tstruct push_buffer *pb = &cdma->push_buffer;\n\tstruct host1x_job *job;\n\n\tlist_for_each_entry(job, &cdma->sync_queue, list) {\n\t\tunsigned int i;\n\n\t\thost1x_debug_output(o, \"JOB, syncpt %u: %u timeout: %u num_slots: %u num_handles: %u\\n\",\n\t\t\t\t    job->syncpt->id, job->syncpt_end, job->timeout,\n\t\t\t\t    job->num_slots, job->num_unpins);\n\n\t\tshow_gather(o, pb->dma + job->first_get, job->num_slots * 2, cdma,\n\t\t\t    pb->dma + job->first_get, pb->mapped + job->first_get);\n\n\t\tfor (i = 0; i < job->num_cmds; i++) {\n\t\t\tstruct host1x_job_gather *g;\n\t\t\tu32 *mapped;\n\n\t\t\tif (job->cmds[i].is_wait)\n\t\t\t\tcontinue;\n\n\t\t\tg = &job->cmds[i].gather;\n\n\t\t\tif (job->gather_copy_mapped)\n\t\t\t\tmapped = (u32 *)job->gather_copy_mapped;\n\t\t\telse\n\t\t\t\tmapped = host1x_bo_mmap(g->bo);\n\n\t\t\tif (!mapped) {\n\t\t\t\thost1x_debug_output(o, \"[could not mmap]\\n\");\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\thost1x_debug_output(o, \"  GATHER at %pad+%#x, %d words\\n\",\n\t\t\t\t\t    &g->base, g->offset, g->words);\n\n\t\t\tshow_gather(o, g->base + g->offset, g->words, cdma,\n\t\t\t\t    g->base, mapped);\n\n\t\t\tif (!job->gather_copy_mapped)\n\t\t\t\thost1x_bo_munmap(g->bo, mapped);\n\t\t}\n\t}\n}\n\n#if HOST1X_HW >= 6\n#include \"debug_hw_1x06.c\"\n#else\n#include \"debug_hw_1x01.c\"\n#endif\n\nstatic const struct host1x_debug_ops host1x_debug_ops = {\n\t.show_channel_cdma = host1x_debug_show_channel_cdma,\n\t.show_channel_fifo = host1x_debug_show_channel_fifo,\n\t.show_mlocks = host1x_debug_show_mlocks,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}