{
  "module_name": "debug_hw_1x01.c",
  "hash_id": "8e86fc58a0e66d42da95ff7246db004a0ef6186167915c9250689aba6aba5ab6",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/host1x/hw/debug_hw_1x01.c",
  "human_readable_source": "\n \n\n#include \"../dev.h\"\n#include \"../debug.h\"\n#include \"../cdma.h\"\n#include \"../channel.h\"\n\nstatic void host1x_debug_show_channel_cdma(struct host1x *host,\n\t\t\t\t\t   struct host1x_channel *ch,\n\t\t\t\t\t   struct output *o)\n{\n\tstruct host1x_cdma *cdma = &ch->cdma;\n\tdma_addr_t dmastart, dmaend;\n\tu32 dmaput, dmaget, dmactrl;\n\tu32 cbstat, cbread;\n\tu32 val, base, baseval;\n\n\tdmastart = host1x_ch_readl(ch, HOST1X_CHANNEL_DMASTART);\n\tdmaend = host1x_ch_readl(ch, HOST1X_CHANNEL_DMAEND);\n\tdmaput = host1x_ch_readl(ch, HOST1X_CHANNEL_DMAPUT);\n\tdmaget = host1x_ch_readl(ch, HOST1X_CHANNEL_DMAGET);\n\tdmactrl = host1x_ch_readl(ch, HOST1X_CHANNEL_DMACTRL);\n\tcbread = host1x_sync_readl(host, HOST1X_SYNC_CBREAD(ch->id));\n\tcbstat = host1x_sync_readl(host, HOST1X_SYNC_CBSTAT(ch->id));\n\n\thost1x_debug_output(o, \"%u-%s: \", ch->id, dev_name(ch->dev));\n\n\tif (HOST1X_CHANNEL_DMACTRL_DMASTOP_V(dmactrl) ||\n\t    !ch->cdma.push_buffer.mapped) {\n\t\thost1x_debug_output(o, \"inactive\\n\\n\");\n\t\treturn;\n\t}\n\n\tif (HOST1X_SYNC_CBSTAT_CBCLASS_V(cbstat) == HOST1X_CLASS_HOST1X &&\n\t    HOST1X_SYNC_CBSTAT_CBOFFSET_V(cbstat) ==\n\t\t\tHOST1X_UCLASS_WAIT_SYNCPT)\n\t\thost1x_debug_output(o, \"waiting on syncpt %d val %d\\n\",\n\t\t\t\t    cbread >> 24, cbread & 0xffffff);\n\telse if (HOST1X_SYNC_CBSTAT_CBCLASS_V(cbstat) ==\n\t\t\t\tHOST1X_CLASS_HOST1X &&\n\t\t HOST1X_SYNC_CBSTAT_CBOFFSET_V(cbstat) ==\n\t\t\t\tHOST1X_UCLASS_WAIT_SYNCPT_BASE) {\n\t\tbase = (cbread >> 16) & 0xff;\n\t\tbaseval =\n\t\t\thost1x_sync_readl(host, HOST1X_SYNC_SYNCPT_BASE(base));\n\t\tval = cbread & 0xffff;\n\t\thost1x_debug_output(o, \"waiting on syncpt %d val %d (base %d = %d; offset = %d)\\n\",\n\t\t\t\t    cbread >> 24, baseval + val, base,\n\t\t\t\t    baseval, val);\n\t} else\n\t\thost1x_debug_output(o, \"active class %02x, offset %04x, val %08x\\n\",\n\t\t\t\t    HOST1X_SYNC_CBSTAT_CBCLASS_V(cbstat),\n\t\t\t\t    HOST1X_SYNC_CBSTAT_CBOFFSET_V(cbstat),\n\t\t\t\t    cbread);\n\n\thost1x_debug_output(o, \"DMASTART %pad, DMAEND %pad\\n\", &dmastart, &dmaend);\n\thost1x_debug_output(o, \"DMAPUT %08x DMAGET %08x DMACTL %08x\\n\",\n\t\t\t    dmaput, dmaget, dmactrl);\n\thost1x_debug_output(o, \"CBREAD %08x CBSTAT %08x\\n\", cbread, cbstat);\n\n\tshow_channel_gathers(o, cdma);\n\thost1x_debug_output(o, \"\\n\");\n}\n\nstatic void host1x_debug_show_channel_fifo(struct host1x *host,\n\t\t\t\t\t   struct host1x_channel *ch,\n\t\t\t\t\t   struct output *o)\n{\n\tu32 val, rd_ptr, wr_ptr, start, end;\n\tunsigned int data_count = 0;\n\n\thost1x_debug_output(o, \"%u: fifo:\\n\", ch->id);\n\n\tval = host1x_ch_readl(ch, HOST1X_CHANNEL_FIFOSTAT);\n\thost1x_debug_output(o, \"FIFOSTAT %08x\\n\", val);\n\tif (HOST1X_CHANNEL_FIFOSTAT_CFEMPTY_V(val)) {\n\t\thost1x_debug_output(o, \"[empty]\\n\");\n\t\treturn;\n\t}\n\n\thost1x_sync_writel(host, 0x0, HOST1X_SYNC_CFPEEK_CTRL);\n\thost1x_sync_writel(host, HOST1X_SYNC_CFPEEK_CTRL_ENA_F(1) |\n\t\t\t   HOST1X_SYNC_CFPEEK_CTRL_CHANNR_F(ch->id),\n\t\t\t   HOST1X_SYNC_CFPEEK_CTRL);\n\n\tval = host1x_sync_readl(host, HOST1X_SYNC_CFPEEK_PTRS);\n\trd_ptr = HOST1X_SYNC_CFPEEK_PTRS_CF_RD_PTR_V(val);\n\twr_ptr = HOST1X_SYNC_CFPEEK_PTRS_CF_WR_PTR_V(val);\n\n\tval = host1x_sync_readl(host, HOST1X_SYNC_CF_SETUP(ch->id));\n\tstart = HOST1X_SYNC_CF_SETUP_BASE_V(val);\n\tend = HOST1X_SYNC_CF_SETUP_LIMIT_V(val);\n\n\tdo {\n\t\thost1x_sync_writel(host, 0x0, HOST1X_SYNC_CFPEEK_CTRL);\n\t\thost1x_sync_writel(host, HOST1X_SYNC_CFPEEK_CTRL_ENA_F(1) |\n\t\t\t\t   HOST1X_SYNC_CFPEEK_CTRL_CHANNR_F(ch->id) |\n\t\t\t\t   HOST1X_SYNC_CFPEEK_CTRL_ADDR_F(rd_ptr),\n\t\t\t\t   HOST1X_SYNC_CFPEEK_CTRL);\n\t\tval = host1x_sync_readl(host, HOST1X_SYNC_CFPEEK_READ);\n\n\t\tif (!data_count) {\n\t\t\thost1x_debug_output(o, \"%08x: \", val);\n\t\t\tdata_count = show_channel_command(o, val, NULL);\n\t\t} else {\n\t\t\thost1x_debug_cont(o, \"%08x%s\", val,\n\t\t\t\t\t  data_count > 1 ? \", \" : \"])\\n\");\n\t\t\tdata_count--;\n\t\t}\n\n\t\tif (rd_ptr == end)\n\t\t\trd_ptr = start;\n\t\telse\n\t\t\trd_ptr++;\n\t} while (rd_ptr != wr_ptr);\n\n\tif (data_count)\n\t\thost1x_debug_cont(o, \", ...])\\n\");\n\thost1x_debug_output(o, \"\\n\");\n\n\thost1x_sync_writel(host, 0x0, HOST1X_SYNC_CFPEEK_CTRL);\n}\n\nstatic void host1x_debug_show_mlocks(struct host1x *host, struct output *o)\n{\n\tunsigned int i;\n\n\thost1x_debug_output(o, \"---- mlocks ----\\n\");\n\n\tfor (i = 0; i < host1x_syncpt_nb_mlocks(host); i++) {\n\t\tu32 owner =\n\t\t\thost1x_sync_readl(host, HOST1X_SYNC_MLOCK_OWNER(i));\n\t\tif (HOST1X_SYNC_MLOCK_OWNER_CH_OWNS_V(owner))\n\t\t\thost1x_debug_output(o, \"%u: locked by channel %u\\n\",\n\t\t\t\ti, HOST1X_SYNC_MLOCK_OWNER_CHID_V(owner));\n\t\telse if (HOST1X_SYNC_MLOCK_OWNER_CPU_OWNS_V(owner))\n\t\t\thost1x_debug_output(o, \"%u: locked by cpu\\n\", i);\n\t\telse\n\t\t\thost1x_debug_output(o, \"%u: unlocked\\n\", i);\n\t}\n\n\thost1x_debug_output(o, \"\\n\");\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}