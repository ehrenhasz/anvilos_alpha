{
  "module_name": "channel_hw.c",
  "hash_id": "d004abae9e67d66da7087f99507bad611b726891ff65953fca1d01f1c1f4aaef",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/host1x/hw/channel_hw.c",
  "human_readable_source": "\n \n\n#include <linux/host1x.h>\n#include <linux/iommu.h>\n#include <linux/slab.h>\n\n#include <trace/events/host1x.h>\n\n#include \"../channel.h\"\n#include \"../dev.h\"\n#include \"../intr.h\"\n#include \"../job.h\"\n\n#define TRACE_MAX_LENGTH 128U\n\nstatic void trace_write_gather(struct host1x_cdma *cdma, struct host1x_bo *bo,\n\t\t\t       u32 offset, u32 words)\n{\n\tstruct device *dev = cdma_to_channel(cdma)->dev;\n\tvoid *mem = NULL;\n\n\tif (host1x_debug_trace_cmdbuf)\n\t\tmem = host1x_bo_mmap(bo);\n\n\tif (mem) {\n\t\tu32 i;\n\t\t \n\t\tfor (i = 0; i < words; i += TRACE_MAX_LENGTH) {\n\t\t\tu32 num_words = min(words - i, TRACE_MAX_LENGTH);\n\n\t\t\toffset += i * sizeof(u32);\n\n\t\t\ttrace_host1x_cdma_push_gather(dev_name(dev), bo,\n\t\t\t\t\t\t      num_words, offset,\n\t\t\t\t\t\t      mem);\n\t\t}\n\n\t\thost1x_bo_munmap(bo, mem);\n\t}\n}\n\nstatic void submit_wait(struct host1x_job *job, u32 id, u32 threshold,\n\t\t\tu32 next_class)\n{\n\tstruct host1x_cdma *cdma = &job->channel->cdma;\n\n#if HOST1X_HW >= 6\n\tu32 stream_id;\n\n\t \n\tif (job->memory_context)\n\t\tstream_id = job->memory_context->stream_id;\n\telse\n\t\tstream_id = job->engine_fallback_streamid;\n\n\thost1x_cdma_push_wide(cdma,\n\t\thost1x_opcode_setclass(\n\t\t\tHOST1X_CLASS_HOST1X,\n\t\t\tHOST1X_UCLASS_LOAD_SYNCPT_PAYLOAD_32,\n\t\t\t \n\t\t\tBIT(0) | BIT(2)\n\t\t),\n\t\tthreshold,\n\t\tid,\n\t\tHOST1X_OPCODE_NOP\n\t);\n\thost1x_cdma_push_wide(&job->channel->cdma,\n\t\thost1x_opcode_setclass(job->class, 0, 0),\n\t\thost1x_opcode_setpayload(stream_id),\n\t\thost1x_opcode_setstreamid(job->engine_streamid_offset / 4),\n\t\tHOST1X_OPCODE_NOP);\n#elif HOST1X_HW >= 2\n\thost1x_cdma_push_wide(cdma,\n\t\thost1x_opcode_setclass(\n\t\t\tHOST1X_CLASS_HOST1X,\n\t\t\tHOST1X_UCLASS_LOAD_SYNCPT_PAYLOAD_32,\n\t\t\t \n\t\t\tBIT(0) | BIT(2)\n\t\t),\n\t\tthreshold,\n\t\tid,\n\t\thost1x_opcode_setclass(next_class, 0, 0)\n\t);\n#else\n\t \n\thost1x_cdma_push(cdma,\n\t\thost1x_opcode_setclass(\n\t\t\tHOST1X_CLASS_HOST1X,\n\t\t\thost1x_uclass_wait_syncpt_r(),\n\t\t\tBIT(0)\n\t\t),\n\t\thost1x_class_host_wait_syncpt(id, threshold)\n\t);\n\thost1x_cdma_push(cdma,\n\t\thost1x_opcode_setclass(next_class, 0, 0),\n\t\tHOST1X_OPCODE_NOP\n\t);\n#endif\n}\n\nstatic void submit_gathers(struct host1x_job *job, u32 job_syncpt_base)\n{\n\tstruct host1x_cdma *cdma = &job->channel->cdma;\n#if HOST1X_HW < 6\n\tstruct device *dev = job->channel->dev;\n#endif\n\tunsigned int i;\n\tu32 threshold;\n\n\tfor (i = 0; i < job->num_cmds; i++) {\n\t\tstruct host1x_job_cmd *cmd = &job->cmds[i];\n\n\t\tif (cmd->is_wait) {\n\t\t\tif (cmd->wait.relative)\n\t\t\t\tthreshold = job_syncpt_base + cmd->wait.threshold;\n\t\t\telse\n\t\t\t\tthreshold = cmd->wait.threshold;\n\n\t\t\tsubmit_wait(job, cmd->wait.id, threshold, cmd->wait.next_class);\n\t\t} else {\n\t\t\tstruct host1x_job_gather *g = &cmd->gather;\n\n\t\t\tdma_addr_t addr = g->base + g->offset;\n\t\t\tu32 op2, op3;\n\n\t\t\top2 = lower_32_bits(addr);\n\t\t\top3 = upper_32_bits(addr);\n\n\t\t\ttrace_write_gather(cdma, g->bo, g->offset, g->words);\n\n\t\t\tif (op3 != 0) {\n#if HOST1X_HW >= 6\n\t\t\t\tu32 op1 = host1x_opcode_gather_wide(g->words);\n\t\t\t\tu32 op4 = HOST1X_OPCODE_NOP;\n\n\t\t\t\thost1x_cdma_push_wide(cdma, op1, op2, op3, op4);\n#else\n\t\t\t\tdev_err(dev, \"invalid gather for push buffer %pad\\n\",\n\t\t\t\t\t&addr);\n\t\t\t\tcontinue;\n#endif\n\t\t\t} else {\n\t\t\t\tu32 op1 = host1x_opcode_gather(g->words);\n\n\t\t\t\thost1x_cdma_push(cdma, op1, op2);\n\t\t\t}\n\t\t}\n\t}\n}\n\nstatic inline void synchronize_syncpt_base(struct host1x_job *job)\n{\n\tstruct host1x_syncpt *sp = job->syncpt;\n\tunsigned int id;\n\tu32 value;\n\n\tvalue = host1x_syncpt_read_max(sp);\n\tid = sp->base->id;\n\n\thost1x_cdma_push(&job->channel->cdma,\n\t\t\t host1x_opcode_setclass(HOST1X_CLASS_HOST1X,\n\t\t\t\tHOST1X_UCLASS_LOAD_SYNCPT_BASE, 1),\n\t\t\t HOST1X_UCLASS_LOAD_SYNCPT_BASE_BASE_INDX_F(id) |\n\t\t\t HOST1X_UCLASS_LOAD_SYNCPT_BASE_VALUE_F(value));\n}\n\nstatic void host1x_channel_set_streamid(struct host1x_channel *channel)\n{\n#if HOST1X_HW >= 6\n\tu32 stream_id;\n\n\tif (!tegra_dev_iommu_get_stream_id(channel->dev->parent, &stream_id))\n\t\tstream_id = TEGRA_STREAM_ID_BYPASS;\n\n\thost1x_ch_writel(channel, stream_id, HOST1X_CHANNEL_SMMU_STREAMID);\n#endif\n}\n\nstatic void host1x_enable_gather_filter(struct host1x_channel *ch)\n{\n#if HOST1X_HW >= 6\n\tstruct host1x *host = dev_get_drvdata(ch->dev->parent);\n\tu32 val;\n\n\tif (!host->hv_regs)\n\t\treturn;\n\n\tval = host1x_hypervisor_readl(\n\t\thost, HOST1X_HV_CH_KERNEL_FILTER_GBUFFER(ch->id / 32));\n\tval |= BIT(ch->id % 32);\n\thost1x_hypervisor_writel(\n\t\thost, val, HOST1X_HV_CH_KERNEL_FILTER_GBUFFER(ch->id / 32));\n#elif HOST1X_HW >= 4\n\thost1x_ch_writel(ch,\n\t\t\t HOST1X_CHANNEL_CHANNELCTRL_KERNEL_FILTER_GBUFFER(1),\n\t\t\t HOST1X_CHANNEL_CHANNELCTRL);\n#endif\n}\n\nstatic void channel_program_cdma(struct host1x_job *job)\n{\n\tstruct host1x_cdma *cdma = &job->channel->cdma;\n\tstruct host1x_syncpt *sp = job->syncpt;\n\n#if HOST1X_HW >= 6\n\tu32 fence;\n\n\t \n\thost1x_cdma_push_wide(cdma,\n\t\thost1x_opcode_acquire_mlock(job->class),\n\t\thost1x_opcode_setclass(job->class, 0, 0),\n\t\thost1x_opcode_setpayload(0),\n\t\thost1x_opcode_setstreamid(job->engine_streamid_offset / 4));\n\n\t \n\tfence = host1x_syncpt_incr_max(sp, 1);\n\thost1x_cdma_push(&job->channel->cdma,\n\t\thost1x_opcode_nonincr(HOST1X_UCLASS_INCR_SYNCPT, 1),\n\t\tHOST1X_UCLASS_INCR_SYNCPT_INDX_F(job->syncpt->id) |\n\t\t\tHOST1X_UCLASS_INCR_SYNCPT_COND_F(4));\n\tsubmit_wait(job, job->syncpt->id, fence, job->class);\n\n\t \n\tjob->syncpt_end = host1x_syncpt_incr_max(sp, job->syncpt_incrs);\n\tsubmit_gathers(job, job->syncpt_end - job->syncpt_incrs);\n\n\t \n\tfence = host1x_syncpt_incr_max(sp, 1);\n\thost1x_cdma_push(&job->channel->cdma,\n\t\thost1x_opcode_nonincr(HOST1X_UCLASS_INCR_SYNCPT, 1),\n\t\tHOST1X_UCLASS_INCR_SYNCPT_INDX_F(job->syncpt->id) |\n\t\t\tHOST1X_UCLASS_INCR_SYNCPT_COND_F(4));\n\tsubmit_wait(job, job->syncpt->id, fence, job->class);\n\n\t \n\thost1x_cdma_push(cdma,\n\t\tHOST1X_OPCODE_NOP, host1x_opcode_release_mlock(job->class));\n#else\n\tif (job->serialize) {\n\t\t \n\t\thost1x_cdma_push(cdma,\n\t\t\t\t host1x_opcode_setclass(HOST1X_CLASS_HOST1X,\n\t\t\t\t\thost1x_uclass_wait_syncpt_r(), 1),\n\t\t\t\t host1x_class_host_wait_syncpt(job->syncpt->id,\n\t\t\t\t\thost1x_syncpt_read_max(sp)));\n\t}\n\n\t \n\tif (sp->base)\n\t\tsynchronize_syncpt_base(job);\n\n\t \n\tif (job->class)\n\t\thost1x_cdma_push(cdma,\n\t\t\t\t host1x_opcode_setclass(job->class, 0, 0),\n\t\t\t\t HOST1X_OPCODE_NOP);\n\n\tjob->syncpt_end = host1x_syncpt_incr_max(sp, job->syncpt_incrs);\n\n\tsubmit_gathers(job, job->syncpt_end - job->syncpt_incrs);\n#endif\n}\n\nstatic void job_complete_callback(struct dma_fence *fence, struct dma_fence_cb *cb)\n{\n\tstruct host1x_job *job = container_of(cb, struct host1x_job, fence_cb);\n\n\t \n\thost1x_cdma_update(&job->channel->cdma);\n}\n\nstatic int channel_submit(struct host1x_job *job)\n{\n\tstruct host1x_channel *ch = job->channel;\n\tstruct host1x_syncpt *sp = job->syncpt;\n\tu32 prev_max = 0;\n\tu32 syncval;\n\tint err;\n\tstruct host1x *host = dev_get_drvdata(ch->dev->parent);\n\n\ttrace_host1x_channel_submit(dev_name(ch->dev),\n\t\t\t\t    job->num_cmds, job->num_relocs,\n\t\t\t\t    job->syncpt->id, job->syncpt_incrs);\n\n\t \n\tprev_max = job->syncpt_end = host1x_syncpt_read_max(sp);\n\n\t \n\terr = mutex_lock_interruptible(&ch->submitlock);\n\tif (err)\n\t\treturn err;\n\n\thost1x_channel_set_streamid(ch);\n\thost1x_enable_gather_filter(ch);\n\thost1x_hw_syncpt_assign_to_channel(host, sp, ch);\n\n\t \n\terr = host1x_cdma_begin(&ch->cdma, job);\n\tif (err) {\n\t\tmutex_unlock(&ch->submitlock);\n\t\treturn err;\n\t}\n\n\tchannel_program_cdma(job);\n\tsyncval = host1x_syncpt_read_max(sp);\n\n\t \n\tjob->fence = host1x_fence_create(sp, syncval, true);\n\tif (WARN(IS_ERR(job->fence), \"Failed to create submit complete fence\")) {\n\t\tjob->fence = NULL;\n\t} else {\n\t\terr = dma_fence_add_callback(job->fence, &job->fence_cb,\n\t\t\t\t\t     job_complete_callback);\n\t}\n\n\t \n\thost1x_cdma_end(&ch->cdma, job);\n\n\ttrace_host1x_channel_submitted(dev_name(ch->dev), prev_max, syncval);\n\n\tmutex_unlock(&ch->submitlock);\n\n\tif (err == -ENOENT)\n\t\thost1x_cdma_update(&ch->cdma);\n\telse\n\t\tWARN(err, \"Failed to set submit complete interrupt\");\n\n\treturn 0;\n}\n\nstatic int host1x_channel_init(struct host1x_channel *ch, struct host1x *dev,\n\t\t\t       unsigned int index)\n{\n#if HOST1X_HW < 6\n\tch->regs = dev->regs + index * 0x4000;\n#else\n\tch->regs = dev->regs + index * 0x100;\n#endif\n\treturn 0;\n}\n\nstatic const struct host1x_channel_ops host1x_channel_ops = {\n\t.init = host1x_channel_init,\n\t.submit = channel_submit,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}