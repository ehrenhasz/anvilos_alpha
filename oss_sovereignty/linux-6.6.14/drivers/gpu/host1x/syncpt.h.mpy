{
  "module_name": "syncpt.h",
  "hash_id": "a8bba84b034ecee2e4783128f8326c433c04daf304657ba30f4ad0dccc728f44",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/host1x/syncpt.h",
  "human_readable_source": " \n \n\n#ifndef __HOST1X_SYNCPT_H\n#define __HOST1X_SYNCPT_H\n\n#include <linux/atomic.h>\n#include <linux/host1x.h>\n#include <linux/kernel.h>\n#include <linux/kref.h>\n#include <linux/sched.h>\n\n#include \"fence.h\"\n#include \"intr.h\"\n\nstruct host1x;\n\n \n#define HOST1X_SYNCPT_RESERVED\t\t\t0\n\nstruct host1x_syncpt_base {\n\tunsigned int id;\n\tbool requested;\n};\n\nstruct host1x_syncpt {\n\tstruct kref ref;\n\n\tunsigned int id;\n\tatomic_t min_val;\n\tatomic_t max_val;\n\tu32 base_val;\n\tconst char *name;\n\tbool client_managed;\n\tstruct host1x *host;\n\tstruct host1x_syncpt_base *base;\n\n\t \n\tstruct host1x_fence_list fences;\n\n\t \n\tbool locked;\n};\n\n \nint host1x_syncpt_init(struct host1x *host);\n\n \nvoid host1x_syncpt_deinit(struct host1x *host);\n\n \nunsigned int host1x_syncpt_nb_pts(struct host1x *host);\n\n \nunsigned int host1x_syncpt_nb_bases(struct host1x *host);\n\n \nunsigned int host1x_syncpt_nb_mlocks(struct host1x *host);\n\n \nstatic inline bool host1x_syncpt_check_max(struct host1x_syncpt *sp, u32 real)\n{\n\tu32 max;\n\tif (sp->client_managed)\n\t\treturn true;\n\tmax = host1x_syncpt_read_max(sp);\n\treturn (s32)(max - real) >= 0;\n}\n\n \nstatic inline bool host1x_syncpt_client_managed(struct host1x_syncpt *sp)\n{\n\treturn sp->client_managed;\n}\n\n \nstatic inline bool host1x_syncpt_idle(struct host1x_syncpt *sp)\n{\n\tint min, max;\n\tsmp_rmb();\n\tmin = atomic_read(&sp->min_val);\n\tmax = atomic_read(&sp->max_val);\n\treturn (min == max);\n}\n\n \nu32 host1x_syncpt_load(struct host1x_syncpt *sp);\n\n \nbool host1x_syncpt_is_expired(struct host1x_syncpt *sp, u32 thresh);\n\n \nvoid host1x_syncpt_save(struct host1x *host);\n\n \nvoid host1x_syncpt_restore(struct host1x *host);\n\n \nu32 host1x_syncpt_load_wait_base(struct host1x_syncpt *sp);\n\n \nu32 host1x_syncpt_incr_max(struct host1x_syncpt *sp, u32 incrs);\n\n \nstatic inline int host1x_syncpt_is_valid(struct host1x_syncpt *sp)\n{\n\treturn sp->id < host1x_syncpt_nb_pts(sp->host);\n}\n\nstatic inline void host1x_syncpt_set_locked(struct host1x_syncpt *sp)\n{\n\tsp->locked = true;\n}\n\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}