{
  "module_name": "debug.c",
  "hash_id": "31418c4fd4e1a7d076e2e9346e867b62925a1bc30124d33dd7e9c6cb2fd66ac6",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/host1x/debug.c",
  "human_readable_source": "\n \n\n#include <linux/debugfs.h>\n#include <linux/pm_runtime.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\n#include <linux/io.h>\n\n#include \"dev.h\"\n#include \"debug.h\"\n#include \"channel.h\"\n\nstatic DEFINE_MUTEX(debug_lock);\n\nunsigned int host1x_debug_trace_cmdbuf;\n\nstatic pid_t host1x_debug_force_timeout_pid;\nstatic u32 host1x_debug_force_timeout_val;\nstatic u32 host1x_debug_force_timeout_channel;\n\nvoid host1x_debug_output(struct output *o, const char *fmt, ...)\n{\n\tva_list args;\n\tint len;\n\n\tva_start(args, fmt);\n\tlen = vsnprintf(o->buf, sizeof(o->buf), fmt, args);\n\tva_end(args);\n\n\to->fn(o->ctx, o->buf, len, false);\n}\n\nvoid host1x_debug_cont(struct output *o, const char *fmt, ...)\n{\n\tva_list args;\n\tint len;\n\n\tva_start(args, fmt);\n\tlen = vsnprintf(o->buf, sizeof(o->buf), fmt, args);\n\tva_end(args);\n\n\to->fn(o->ctx, o->buf, len, true);\n}\n\nstatic int show_channel(struct host1x_channel *ch, void *data, bool show_fifo)\n{\n\tstruct host1x *m = dev_get_drvdata(ch->dev->parent);\n\tstruct output *o = data;\n\tint err;\n\n\terr = pm_runtime_resume_and_get(m->dev);\n\tif (err < 0)\n\t\treturn err;\n\n\tmutex_lock(&ch->cdma.lock);\n\tmutex_lock(&debug_lock);\n\n\tif (show_fifo)\n\t\thost1x_hw_show_channel_fifo(m, ch, o);\n\n\thost1x_hw_show_channel_cdma(m, ch, o);\n\n\tmutex_unlock(&debug_lock);\n\tmutex_unlock(&ch->cdma.lock);\n\n\tpm_runtime_put(m->dev);\n\n\treturn 0;\n}\n\nstatic void show_syncpts(struct host1x *m, struct output *o, bool show_all)\n{\n\tunsigned long irqflags;\n\tstruct list_head *pos;\n\tunsigned int i;\n\tint err;\n\n\thost1x_debug_output(o, \"---- syncpts ----\\n\");\n\n\terr = pm_runtime_resume_and_get(m->dev);\n\tif (err < 0)\n\t\treturn;\n\n\tfor (i = 0; i < host1x_syncpt_nb_pts(m); i++) {\n\t\tu32 max = host1x_syncpt_read_max(m->syncpt + i);\n\t\tu32 min = host1x_syncpt_load(m->syncpt + i);\n\t\tunsigned int waiters = 0;\n\n\t\tspin_lock_irqsave(&m->syncpt[i].fences.lock, irqflags);\n\t\tlist_for_each(pos, &m->syncpt[i].fences.list)\n\t\t\twaiters++;\n\t\tspin_unlock_irqrestore(&m->syncpt[i].fences.lock, irqflags);\n\n\t\tif (!kref_read(&m->syncpt[i].ref))\n\t\t\tcontinue;\n\n\t\tif (!show_all && !min && !max && !waiters)\n\t\t\tcontinue;\n\n\t\thost1x_debug_output(o,\n\t\t\t\t    \"id %u (%s) min %d max %d (%d waiters)\\n\",\n\t\t\t\t    i, m->syncpt[i].name, min, max, waiters);\n\t}\n\n\tfor (i = 0; i < host1x_syncpt_nb_bases(m); i++) {\n\t\tu32 base_val;\n\n\t\tbase_val = host1x_syncpt_load_wait_base(m->syncpt + i);\n\t\tif (base_val)\n\t\t\thost1x_debug_output(o, \"waitbase id %u val %d\\n\", i,\n\t\t\t\t\t    base_val);\n\t}\n\n\tpm_runtime_put(m->dev);\n\n\thost1x_debug_output(o, \"\\n\");\n}\n\nstatic void show_all(struct host1x *m, struct output *o, bool show_fifo)\n{\n\tunsigned int i;\n\n\thost1x_hw_show_mlocks(m, o);\n\tshow_syncpts(m, o, true);\n\thost1x_debug_output(o, \"---- channels ----\\n\");\n\n\tfor (i = 0; i < m->info->nb_channels; ++i) {\n\t\tstruct host1x_channel *ch = host1x_channel_get_index(m, i);\n\n\t\tif (ch) {\n\t\t\tshow_channel(ch, o, show_fifo);\n\t\t\thost1x_channel_put(ch);\n\t\t}\n\t}\n}\n\nstatic int host1x_debug_all_show(struct seq_file *s, void *unused)\n{\n\tstruct output o = {\n\t\t.fn = write_to_seqfile,\n\t\t.ctx = s\n\t};\n\n\tshow_all(s->private, &o, true);\n\n\treturn 0;\n}\nDEFINE_SHOW_ATTRIBUTE(host1x_debug_all);\n\nstatic int host1x_debug_show(struct seq_file *s, void *unused)\n{\n\tstruct output o = {\n\t\t.fn = write_to_seqfile,\n\t\t.ctx = s\n\t};\n\n\tshow_all(s->private, &o, false);\n\n\treturn 0;\n}\nDEFINE_SHOW_ATTRIBUTE(host1x_debug);\n\nstatic void host1x_debugfs_init(struct host1x *host1x)\n{\n\tstruct dentry *de = debugfs_create_dir(\"tegra-host1x\", NULL);\n\n\t \n\thost1x->debugfs = de;\n\n\tdebugfs_create_file(\"status\", S_IRUGO, de, host1x, &host1x_debug_fops);\n\tdebugfs_create_file(\"status_all\", S_IRUGO, de, host1x,\n\t\t\t    &host1x_debug_all_fops);\n\n\tdebugfs_create_u32(\"trace_cmdbuf\", S_IRUGO|S_IWUSR, de,\n\t\t\t   &host1x_debug_trace_cmdbuf);\n\n\thost1x_hw_debug_init(host1x, de);\n\n\tdebugfs_create_u32(\"force_timeout_pid\", S_IRUGO|S_IWUSR, de,\n\t\t\t   &host1x_debug_force_timeout_pid);\n\tdebugfs_create_u32(\"force_timeout_val\", S_IRUGO|S_IWUSR, de,\n\t\t\t   &host1x_debug_force_timeout_val);\n\tdebugfs_create_u32(\"force_timeout_channel\", S_IRUGO|S_IWUSR, de,\n\t\t\t   &host1x_debug_force_timeout_channel);\n}\n\nstatic void host1x_debugfs_exit(struct host1x *host1x)\n{\n\tdebugfs_remove_recursive(host1x->debugfs);\n}\n\nvoid host1x_debug_init(struct host1x *host1x)\n{\n\tif (IS_ENABLED(CONFIG_DEBUG_FS))\n\t\thost1x_debugfs_init(host1x);\n}\n\nvoid host1x_debug_deinit(struct host1x *host1x)\n{\n\tif (IS_ENABLED(CONFIG_DEBUG_FS))\n\t\thost1x_debugfs_exit(host1x);\n}\n\nvoid host1x_debug_dump(struct host1x *host1x)\n{\n\tstruct output o = {\n\t\t.fn = write_to_printk\n\t};\n\n\tshow_all(host1x, &o, true);\n}\n\nvoid host1x_debug_dump_syncpts(struct host1x *host1x)\n{\n\tstruct output o = {\n\t\t.fn = write_to_printk\n\t};\n\n\tshow_syncpts(host1x, &o, false);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}