{
  "module_name": "ipu-vdi.c",
  "hash_id": "79b7b8397be8f1f8d0c0714c0f19bae7da6e41ff8e65c8693c2651402d8bc715",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/ipu-v3/ipu-vdi.c",
  "human_readable_source": "\n \n#include <linux/io.h>\n#include \"ipu-prv.h\"\n\nstruct ipu_vdi {\n\tvoid __iomem *base;\n\tu32 module;\n\tspinlock_t lock;\n\tint use_count;\n\tstruct ipu_soc *ipu;\n};\n\n\n \n#define VDI_FSIZE 0x0000\n#define VDI_C     0x0004\n\n \n#define VDI_C_CH_420             (0 << 1)\n#define VDI_C_CH_422             (1 << 1)\n#define VDI_C_MOT_SEL_MASK       (0x3 << 2)\n#define VDI_C_MOT_SEL_FULL       (2 << 2)\n#define VDI_C_MOT_SEL_LOW        (1 << 2)\n#define VDI_C_MOT_SEL_MED        (0 << 2)\n#define VDI_C_BURST_SIZE1_4      (3 << 4)\n#define VDI_C_BURST_SIZE2_4      (3 << 8)\n#define VDI_C_BURST_SIZE3_4      (3 << 12)\n#define VDI_C_BURST_SIZE_MASK    0xF\n#define VDI_C_BURST_SIZE1_OFFSET 4\n#define VDI_C_BURST_SIZE2_OFFSET 8\n#define VDI_C_BURST_SIZE3_OFFSET 12\n#define VDI_C_VWM1_SET_1         (0 << 16)\n#define VDI_C_VWM1_SET_2         (1 << 16)\n#define VDI_C_VWM1_CLR_2         (1 << 19)\n#define VDI_C_VWM3_SET_1         (0 << 22)\n#define VDI_C_VWM3_SET_2         (1 << 22)\n#define VDI_C_VWM3_CLR_2         (1 << 25)\n#define VDI_C_TOP_FIELD_MAN_1    (1 << 30)\n#define VDI_C_TOP_FIELD_AUTO_1   (1 << 31)\n\nstatic inline u32 ipu_vdi_read(struct ipu_vdi *vdi, unsigned int offset)\n{\n\treturn readl(vdi->base + offset);\n}\n\nstatic inline void ipu_vdi_write(struct ipu_vdi *vdi, u32 value,\n\t\t\t\t unsigned int offset)\n{\n\twritel(value, vdi->base + offset);\n}\n\nvoid ipu_vdi_set_field_order(struct ipu_vdi *vdi, v4l2_std_id std, u32 field)\n{\n\tbool top_field_0 = false;\n\tunsigned long flags;\n\tu32 reg;\n\n\tswitch (field) {\n\tcase V4L2_FIELD_INTERLACED_TB:\n\tcase V4L2_FIELD_SEQ_TB:\n\tcase V4L2_FIELD_TOP:\n\t\ttop_field_0 = true;\n\t\tbreak;\n\tcase V4L2_FIELD_INTERLACED_BT:\n\tcase V4L2_FIELD_SEQ_BT:\n\tcase V4L2_FIELD_BOTTOM:\n\t\ttop_field_0 = false;\n\t\tbreak;\n\tdefault:\n\t\ttop_field_0 = (std & V4L2_STD_525_60) ? true : false;\n\t\tbreak;\n\t}\n\n\tspin_lock_irqsave(&vdi->lock, flags);\n\n\treg = ipu_vdi_read(vdi, VDI_C);\n\tif (top_field_0)\n\t\treg &= ~(VDI_C_TOP_FIELD_MAN_1 | VDI_C_TOP_FIELD_AUTO_1);\n\telse\n\t\treg |= VDI_C_TOP_FIELD_MAN_1 | VDI_C_TOP_FIELD_AUTO_1;\n\tipu_vdi_write(vdi, reg, VDI_C);\n\n\tspin_unlock_irqrestore(&vdi->lock, flags);\n}\nEXPORT_SYMBOL_GPL(ipu_vdi_set_field_order);\n\nvoid ipu_vdi_set_motion(struct ipu_vdi *vdi, enum ipu_motion_sel motion_sel)\n{\n\tunsigned long flags;\n\tu32 reg;\n\n\tspin_lock_irqsave(&vdi->lock, flags);\n\n\treg = ipu_vdi_read(vdi, VDI_C);\n\n\treg &= ~VDI_C_MOT_SEL_MASK;\n\n\tswitch (motion_sel) {\n\tcase MED_MOTION:\n\t\treg |= VDI_C_MOT_SEL_MED;\n\t\tbreak;\n\tcase HIGH_MOTION:\n\t\treg |= VDI_C_MOT_SEL_FULL;\n\t\tbreak;\n\tdefault:\n\t\treg |= VDI_C_MOT_SEL_LOW;\n\t\tbreak;\n\t}\n\n\tipu_vdi_write(vdi, reg, VDI_C);\n\n\tspin_unlock_irqrestore(&vdi->lock, flags);\n}\nEXPORT_SYMBOL_GPL(ipu_vdi_set_motion);\n\nvoid ipu_vdi_setup(struct ipu_vdi *vdi, u32 code, int xres, int yres)\n{\n\tunsigned long flags;\n\tu32 pixel_fmt, reg;\n\n\tspin_lock_irqsave(&vdi->lock, flags);\n\n\treg = ((yres - 1) << 16) | (xres - 1);\n\tipu_vdi_write(vdi, reg, VDI_FSIZE);\n\n\t \n\tif (code == MEDIA_BUS_FMT_UYVY8_2X8 ||\n\t    code == MEDIA_BUS_FMT_UYVY8_1X16 ||\n\t    code == MEDIA_BUS_FMT_YUYV8_2X8 ||\n\t    code == MEDIA_BUS_FMT_YUYV8_1X16)\n\t\tpixel_fmt = VDI_C_CH_422;\n\telse\n\t\tpixel_fmt = VDI_C_CH_420;\n\n\treg = ipu_vdi_read(vdi, VDI_C);\n\treg |= pixel_fmt;\n\treg |= VDI_C_BURST_SIZE2_4;\n\treg |= VDI_C_BURST_SIZE1_4 | VDI_C_VWM1_CLR_2;\n\treg |= VDI_C_BURST_SIZE3_4 | VDI_C_VWM3_CLR_2;\n\tipu_vdi_write(vdi, reg, VDI_C);\n\n\tspin_unlock_irqrestore(&vdi->lock, flags);\n}\nEXPORT_SYMBOL_GPL(ipu_vdi_setup);\n\nvoid ipu_vdi_unsetup(struct ipu_vdi *vdi)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&vdi->lock, flags);\n\tipu_vdi_write(vdi, 0, VDI_FSIZE);\n\tipu_vdi_write(vdi, 0, VDI_C);\n\tspin_unlock_irqrestore(&vdi->lock, flags);\n}\nEXPORT_SYMBOL_GPL(ipu_vdi_unsetup);\n\nint ipu_vdi_enable(struct ipu_vdi *vdi)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&vdi->lock, flags);\n\n\tif (!vdi->use_count)\n\t\tipu_module_enable(vdi->ipu, vdi->module);\n\n\tvdi->use_count++;\n\n\tspin_unlock_irqrestore(&vdi->lock, flags);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(ipu_vdi_enable);\n\nint ipu_vdi_disable(struct ipu_vdi *vdi)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&vdi->lock, flags);\n\n\tif (vdi->use_count) {\n\t\tif (!--vdi->use_count)\n\t\t\tipu_module_disable(vdi->ipu, vdi->module);\n\t}\n\n\tspin_unlock_irqrestore(&vdi->lock, flags);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(ipu_vdi_disable);\n\nstruct ipu_vdi *ipu_vdi_get(struct ipu_soc *ipu)\n{\n\treturn ipu->vdi_priv;\n}\nEXPORT_SYMBOL_GPL(ipu_vdi_get);\n\nvoid ipu_vdi_put(struct ipu_vdi *vdi)\n{\n}\nEXPORT_SYMBOL_GPL(ipu_vdi_put);\n\nint ipu_vdi_init(struct ipu_soc *ipu, struct device *dev,\n\t\t unsigned long base, u32 module)\n{\n\tstruct ipu_vdi *vdi;\n\n\tvdi = devm_kzalloc(dev, sizeof(*vdi), GFP_KERNEL);\n\tif (!vdi)\n\t\treturn -ENOMEM;\n\n\tipu->vdi_priv = vdi;\n\n\tspin_lock_init(&vdi->lock);\n\tvdi->module = module;\n\tvdi->base = devm_ioremap(dev, base, PAGE_SIZE);\n\tif (!vdi->base)\n\t\treturn -ENOMEM;\n\n\tdev_dbg(dev, \"VDI base: 0x%08lx remapped to %p\\n\", base, vdi->base);\n\tvdi->ipu = ipu;\n\n\treturn 0;\n}\n\nvoid ipu_vdi_exit(struct ipu_soc *ipu)\n{\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}