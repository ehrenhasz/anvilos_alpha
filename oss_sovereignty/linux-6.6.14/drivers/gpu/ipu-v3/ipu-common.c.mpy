{
  "module_name": "ipu-common.c",
  "hash_id": "bb83a939188ab0cffe55bbb4f735484916efeefe2fed6be58a7f8900b6a73db3",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/ipu-v3/ipu-common.c",
  "human_readable_source": "\n \n#include <linux/module.h>\n#include <linux/export.h>\n#include <linux/types.h>\n#include <linux/reset.h>\n#include <linux/platform_device.h>\n#include <linux/err.h>\n#include <linux/spinlock.h>\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/io.h>\n#include <linux/clk.h>\n#include <linux/list.h>\n#include <linux/irq.h>\n#include <linux/irqchip/chained_irq.h>\n#include <linux/irqdomain.h>\n#include <linux/of.h>\n#include <linux/of_graph.h>\n\n#include <drm/drm_fourcc.h>\n\n#include <video/imx-ipu-v3.h>\n#include \"ipu-prv.h\"\n\nstatic inline u32 ipu_cm_read(struct ipu_soc *ipu, unsigned offset)\n{\n\treturn readl(ipu->cm_reg + offset);\n}\n\nstatic inline void ipu_cm_write(struct ipu_soc *ipu, u32 value, unsigned offset)\n{\n\twritel(value, ipu->cm_reg + offset);\n}\n\nint ipu_get_num(struct ipu_soc *ipu)\n{\n\treturn ipu->id;\n}\nEXPORT_SYMBOL_GPL(ipu_get_num);\n\nvoid ipu_srm_dp_update(struct ipu_soc *ipu, bool sync)\n{\n\tu32 val;\n\n\tval = ipu_cm_read(ipu, IPU_SRM_PRI2);\n\tval &= ~DP_S_SRM_MODE_MASK;\n\tval |= sync ? DP_S_SRM_MODE_NEXT_FRAME :\n\t\t      DP_S_SRM_MODE_NOW;\n\tipu_cm_write(ipu, val, IPU_SRM_PRI2);\n}\nEXPORT_SYMBOL_GPL(ipu_srm_dp_update);\n\nenum ipu_color_space ipu_drm_fourcc_to_colorspace(u32 drm_fourcc)\n{\n\tswitch (drm_fourcc) {\n\tcase DRM_FORMAT_ARGB1555:\n\tcase DRM_FORMAT_ABGR1555:\n\tcase DRM_FORMAT_RGBA5551:\n\tcase DRM_FORMAT_BGRA5551:\n\tcase DRM_FORMAT_RGB565:\n\tcase DRM_FORMAT_BGR565:\n\tcase DRM_FORMAT_RGB888:\n\tcase DRM_FORMAT_BGR888:\n\tcase DRM_FORMAT_ARGB4444:\n\tcase DRM_FORMAT_XRGB8888:\n\tcase DRM_FORMAT_XBGR8888:\n\tcase DRM_FORMAT_RGBX8888:\n\tcase DRM_FORMAT_BGRX8888:\n\tcase DRM_FORMAT_ARGB8888:\n\tcase DRM_FORMAT_ABGR8888:\n\tcase DRM_FORMAT_RGBA8888:\n\tcase DRM_FORMAT_BGRA8888:\n\tcase DRM_FORMAT_RGB565_A8:\n\tcase DRM_FORMAT_BGR565_A8:\n\tcase DRM_FORMAT_RGB888_A8:\n\tcase DRM_FORMAT_BGR888_A8:\n\tcase DRM_FORMAT_RGBX8888_A8:\n\tcase DRM_FORMAT_BGRX8888_A8:\n\t\treturn IPUV3_COLORSPACE_RGB;\n\tcase DRM_FORMAT_YUYV:\n\tcase DRM_FORMAT_UYVY:\n\tcase DRM_FORMAT_YUV420:\n\tcase DRM_FORMAT_YVU420:\n\tcase DRM_FORMAT_YUV422:\n\tcase DRM_FORMAT_YVU422:\n\tcase DRM_FORMAT_YUV444:\n\tcase DRM_FORMAT_YVU444:\n\tcase DRM_FORMAT_NV12:\n\tcase DRM_FORMAT_NV21:\n\tcase DRM_FORMAT_NV16:\n\tcase DRM_FORMAT_NV61:\n\t\treturn IPUV3_COLORSPACE_YUV;\n\tdefault:\n\t\treturn IPUV3_COLORSPACE_UNKNOWN;\n\t}\n}\nEXPORT_SYMBOL_GPL(ipu_drm_fourcc_to_colorspace);\n\nenum ipu_color_space ipu_pixelformat_to_colorspace(u32 pixelformat)\n{\n\tswitch (pixelformat) {\n\tcase V4L2_PIX_FMT_YUV420:\n\tcase V4L2_PIX_FMT_YVU420:\n\tcase V4L2_PIX_FMT_YUV422P:\n\tcase V4L2_PIX_FMT_UYVY:\n\tcase V4L2_PIX_FMT_YUYV:\n\tcase V4L2_PIX_FMT_NV12:\n\tcase V4L2_PIX_FMT_NV21:\n\tcase V4L2_PIX_FMT_NV16:\n\tcase V4L2_PIX_FMT_NV61:\n\t\treturn IPUV3_COLORSPACE_YUV;\n\tcase V4L2_PIX_FMT_RGB565:\n\tcase V4L2_PIX_FMT_BGR24:\n\tcase V4L2_PIX_FMT_RGB24:\n\tcase V4L2_PIX_FMT_ABGR32:\n\tcase V4L2_PIX_FMT_XBGR32:\n\tcase V4L2_PIX_FMT_BGRA32:\n\tcase V4L2_PIX_FMT_BGRX32:\n\tcase V4L2_PIX_FMT_RGBA32:\n\tcase V4L2_PIX_FMT_RGBX32:\n\tcase V4L2_PIX_FMT_ARGB32:\n\tcase V4L2_PIX_FMT_XRGB32:\n\tcase V4L2_PIX_FMT_RGB32:\n\tcase V4L2_PIX_FMT_BGR32:\n\t\treturn IPUV3_COLORSPACE_RGB;\n\tdefault:\n\t\treturn IPUV3_COLORSPACE_UNKNOWN;\n\t}\n}\nEXPORT_SYMBOL_GPL(ipu_pixelformat_to_colorspace);\n\nint ipu_degrees_to_rot_mode(enum ipu_rotate_mode *mode, int degrees,\n\t\t\t    bool hflip, bool vflip)\n{\n\tu32 r90, vf, hf;\n\n\tswitch (degrees) {\n\tcase 0:\n\t\tvf = hf = r90 = 0;\n\t\tbreak;\n\tcase 90:\n\t\tvf = hf = 0;\n\t\tr90 = 1;\n\t\tbreak;\n\tcase 180:\n\t\tvf = hf = 1;\n\t\tr90 = 0;\n\t\tbreak;\n\tcase 270:\n\t\tvf = hf = r90 = 1;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\thf ^= (u32)hflip;\n\tvf ^= (u32)vflip;\n\n\t*mode = (enum ipu_rotate_mode)((r90 << 2) | (hf << 1) | vf);\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(ipu_degrees_to_rot_mode);\n\nint ipu_rot_mode_to_degrees(int *degrees, enum ipu_rotate_mode mode,\n\t\t\t    bool hflip, bool vflip)\n{\n\tu32 r90, vf, hf;\n\n\tr90 = ((u32)mode >> 2) & 0x1;\n\thf = ((u32)mode >> 1) & 0x1;\n\tvf = ((u32)mode >> 0) & 0x1;\n\thf ^= (u32)hflip;\n\tvf ^= (u32)vflip;\n\n\tswitch ((enum ipu_rotate_mode)((r90 << 2) | (hf << 1) | vf)) {\n\tcase IPU_ROTATE_NONE:\n\t\t*degrees = 0;\n\t\tbreak;\n\tcase IPU_ROTATE_90_RIGHT:\n\t\t*degrees = 90;\n\t\tbreak;\n\tcase IPU_ROTATE_180:\n\t\t*degrees = 180;\n\t\tbreak;\n\tcase IPU_ROTATE_90_LEFT:\n\t\t*degrees = 270;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(ipu_rot_mode_to_degrees);\n\nstruct ipuv3_channel *ipu_idmac_get(struct ipu_soc *ipu, unsigned num)\n{\n\tstruct ipuv3_channel *channel;\n\n\tdev_dbg(ipu->dev, \"%s %d\\n\", __func__, num);\n\n\tif (num > 63)\n\t\treturn ERR_PTR(-ENODEV);\n\n\tmutex_lock(&ipu->channel_lock);\n\n\tlist_for_each_entry(channel, &ipu->channels, list) {\n\t\tif (channel->num == num) {\n\t\t\tchannel = ERR_PTR(-EBUSY);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tchannel = kzalloc(sizeof(*channel), GFP_KERNEL);\n\tif (!channel) {\n\t\tchannel = ERR_PTR(-ENOMEM);\n\t\tgoto out;\n\t}\n\n\tchannel->num = num;\n\tchannel->ipu = ipu;\n\tlist_add(&channel->list, &ipu->channels);\n\nout:\n\tmutex_unlock(&ipu->channel_lock);\n\n\treturn channel;\n}\nEXPORT_SYMBOL_GPL(ipu_idmac_get);\n\nvoid ipu_idmac_put(struct ipuv3_channel *channel)\n{\n\tstruct ipu_soc *ipu = channel->ipu;\n\n\tdev_dbg(ipu->dev, \"%s %d\\n\", __func__, channel->num);\n\n\tmutex_lock(&ipu->channel_lock);\n\n\tlist_del(&channel->list);\n\tkfree(channel);\n\n\tmutex_unlock(&ipu->channel_lock);\n}\nEXPORT_SYMBOL_GPL(ipu_idmac_put);\n\n#define idma_mask(ch)\t\t\t(1 << ((ch) & 0x1f))\n\n \nstatic void __ipu_idmac_reset_current_buffer(struct ipuv3_channel *channel)\n{\n\tstruct ipu_soc *ipu = channel->ipu;\n\tunsigned int chno = channel->num;\n\n\tipu_cm_write(ipu, idma_mask(chno), IPU_CHA_CUR_BUF(chno));\n}\n\nvoid ipu_idmac_set_double_buffer(struct ipuv3_channel *channel,\n\t\tbool doublebuffer)\n{\n\tstruct ipu_soc *ipu = channel->ipu;\n\tunsigned long flags;\n\tu32 reg;\n\n\tspin_lock_irqsave(&ipu->lock, flags);\n\n\treg = ipu_cm_read(ipu, IPU_CHA_DB_MODE_SEL(channel->num));\n\tif (doublebuffer)\n\t\treg |= idma_mask(channel->num);\n\telse\n\t\treg &= ~idma_mask(channel->num);\n\tipu_cm_write(ipu, reg, IPU_CHA_DB_MODE_SEL(channel->num));\n\n\t__ipu_idmac_reset_current_buffer(channel);\n\n\tspin_unlock_irqrestore(&ipu->lock, flags);\n}\nEXPORT_SYMBOL_GPL(ipu_idmac_set_double_buffer);\n\nstatic const struct {\n\tint chnum;\n\tu32 reg;\n\tint shift;\n} idmac_lock_en_info[] = {\n\t{ .chnum =  5, .reg = IDMAC_CH_LOCK_EN_1, .shift =  0, },\n\t{ .chnum = 11, .reg = IDMAC_CH_LOCK_EN_1, .shift =  2, },\n\t{ .chnum = 12, .reg = IDMAC_CH_LOCK_EN_1, .shift =  4, },\n\t{ .chnum = 14, .reg = IDMAC_CH_LOCK_EN_1, .shift =  6, },\n\t{ .chnum = 15, .reg = IDMAC_CH_LOCK_EN_1, .shift =  8, },\n\t{ .chnum = 20, .reg = IDMAC_CH_LOCK_EN_1, .shift = 10, },\n\t{ .chnum = 21, .reg = IDMAC_CH_LOCK_EN_1, .shift = 12, },\n\t{ .chnum = 22, .reg = IDMAC_CH_LOCK_EN_1, .shift = 14, },\n\t{ .chnum = 23, .reg = IDMAC_CH_LOCK_EN_1, .shift = 16, },\n\t{ .chnum = 27, .reg = IDMAC_CH_LOCK_EN_1, .shift = 18, },\n\t{ .chnum = 28, .reg = IDMAC_CH_LOCK_EN_1, .shift = 20, },\n\t{ .chnum = 45, .reg = IDMAC_CH_LOCK_EN_2, .shift =  0, },\n\t{ .chnum = 46, .reg = IDMAC_CH_LOCK_EN_2, .shift =  2, },\n\t{ .chnum = 47, .reg = IDMAC_CH_LOCK_EN_2, .shift =  4, },\n\t{ .chnum = 48, .reg = IDMAC_CH_LOCK_EN_2, .shift =  6, },\n\t{ .chnum = 49, .reg = IDMAC_CH_LOCK_EN_2, .shift =  8, },\n\t{ .chnum = 50, .reg = IDMAC_CH_LOCK_EN_2, .shift = 10, },\n};\n\nint ipu_idmac_lock_enable(struct ipuv3_channel *channel, int num_bursts)\n{\n\tstruct ipu_soc *ipu = channel->ipu;\n\tunsigned long flags;\n\tu32 bursts, regval;\n\tint i;\n\n\tswitch (num_bursts) {\n\tcase 0:\n\tcase 1:\n\t\tbursts = 0x00;  \n\t\tbreak;\n\tcase 2:\n\t\tbursts = 0x01;\n\t\tbreak;\n\tcase 4:\n\t\tbursts = 0x02;\n\t\tbreak;\n\tcase 8:\n\t\tbursts = 0x03;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (bursts && ipu->ipu_type != IPUV3H)\n\t\treturn -EINVAL;\n\n\tfor (i = 0; i < ARRAY_SIZE(idmac_lock_en_info); i++) {\n\t\tif (channel->num == idmac_lock_en_info[i].chnum)\n\t\t\tbreak;\n\t}\n\tif (i >= ARRAY_SIZE(idmac_lock_en_info))\n\t\treturn -EINVAL;\n\n\tspin_lock_irqsave(&ipu->lock, flags);\n\n\tregval = ipu_idmac_read(ipu, idmac_lock_en_info[i].reg);\n\tregval &= ~(0x03 << idmac_lock_en_info[i].shift);\n\tregval |= (bursts << idmac_lock_en_info[i].shift);\n\tipu_idmac_write(ipu, regval, idmac_lock_en_info[i].reg);\n\n\tspin_unlock_irqrestore(&ipu->lock, flags);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(ipu_idmac_lock_enable);\n\nint ipu_module_enable(struct ipu_soc *ipu, u32 mask)\n{\n\tunsigned long lock_flags;\n\tu32 val;\n\n\tspin_lock_irqsave(&ipu->lock, lock_flags);\n\n\tval = ipu_cm_read(ipu, IPU_DISP_GEN);\n\n\tif (mask & IPU_CONF_DI0_EN)\n\t\tval |= IPU_DI0_COUNTER_RELEASE;\n\tif (mask & IPU_CONF_DI1_EN)\n\t\tval |= IPU_DI1_COUNTER_RELEASE;\n\n\tipu_cm_write(ipu, val, IPU_DISP_GEN);\n\n\tval = ipu_cm_read(ipu, IPU_CONF);\n\tval |= mask;\n\tipu_cm_write(ipu, val, IPU_CONF);\n\n\tspin_unlock_irqrestore(&ipu->lock, lock_flags);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(ipu_module_enable);\n\nint ipu_module_disable(struct ipu_soc *ipu, u32 mask)\n{\n\tunsigned long lock_flags;\n\tu32 val;\n\n\tspin_lock_irqsave(&ipu->lock, lock_flags);\n\n\tval = ipu_cm_read(ipu, IPU_CONF);\n\tval &= ~mask;\n\tipu_cm_write(ipu, val, IPU_CONF);\n\n\tval = ipu_cm_read(ipu, IPU_DISP_GEN);\n\n\tif (mask & IPU_CONF_DI0_EN)\n\t\tval &= ~IPU_DI0_COUNTER_RELEASE;\n\tif (mask & IPU_CONF_DI1_EN)\n\t\tval &= ~IPU_DI1_COUNTER_RELEASE;\n\n\tipu_cm_write(ipu, val, IPU_DISP_GEN);\n\n\tspin_unlock_irqrestore(&ipu->lock, lock_flags);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(ipu_module_disable);\n\nint ipu_idmac_get_current_buffer(struct ipuv3_channel *channel)\n{\n\tstruct ipu_soc *ipu = channel->ipu;\n\tunsigned int chno = channel->num;\n\n\treturn (ipu_cm_read(ipu, IPU_CHA_CUR_BUF(chno)) & idma_mask(chno)) ? 1 : 0;\n}\nEXPORT_SYMBOL_GPL(ipu_idmac_get_current_buffer);\n\nbool ipu_idmac_buffer_is_ready(struct ipuv3_channel *channel, u32 buf_num)\n{\n\tstruct ipu_soc *ipu = channel->ipu;\n\tunsigned long flags;\n\tu32 reg = 0;\n\n\tspin_lock_irqsave(&ipu->lock, flags);\n\tswitch (buf_num) {\n\tcase 0:\n\t\treg = ipu_cm_read(ipu, IPU_CHA_BUF0_RDY(channel->num));\n\t\tbreak;\n\tcase 1:\n\t\treg = ipu_cm_read(ipu, IPU_CHA_BUF1_RDY(channel->num));\n\t\tbreak;\n\tcase 2:\n\t\treg = ipu_cm_read(ipu, IPU_CHA_BUF2_RDY(channel->num));\n\t\tbreak;\n\t}\n\tspin_unlock_irqrestore(&ipu->lock, flags);\n\n\treturn ((reg & idma_mask(channel->num)) != 0);\n}\nEXPORT_SYMBOL_GPL(ipu_idmac_buffer_is_ready);\n\nvoid ipu_idmac_select_buffer(struct ipuv3_channel *channel, u32 buf_num)\n{\n\tstruct ipu_soc *ipu = channel->ipu;\n\tunsigned int chno = channel->num;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&ipu->lock, flags);\n\n\t \n\tif (buf_num == 0)\n\t\tipu_cm_write(ipu, idma_mask(chno), IPU_CHA_BUF0_RDY(chno));\n\telse\n\t\tipu_cm_write(ipu, idma_mask(chno), IPU_CHA_BUF1_RDY(chno));\n\n\tspin_unlock_irqrestore(&ipu->lock, flags);\n}\nEXPORT_SYMBOL_GPL(ipu_idmac_select_buffer);\n\nvoid ipu_idmac_clear_buffer(struct ipuv3_channel *channel, u32 buf_num)\n{\n\tstruct ipu_soc *ipu = channel->ipu;\n\tunsigned int chno = channel->num;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&ipu->lock, flags);\n\n\tipu_cm_write(ipu, 0xF0300000, IPU_GPR);  \n\tswitch (buf_num) {\n\tcase 0:\n\t\tipu_cm_write(ipu, idma_mask(chno), IPU_CHA_BUF0_RDY(chno));\n\t\tbreak;\n\tcase 1:\n\t\tipu_cm_write(ipu, idma_mask(chno), IPU_CHA_BUF1_RDY(chno));\n\t\tbreak;\n\tcase 2:\n\t\tipu_cm_write(ipu, idma_mask(chno), IPU_CHA_BUF2_RDY(chno));\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\tipu_cm_write(ipu, 0x0, IPU_GPR);  \n\n\tspin_unlock_irqrestore(&ipu->lock, flags);\n}\nEXPORT_SYMBOL_GPL(ipu_idmac_clear_buffer);\n\nint ipu_idmac_enable_channel(struct ipuv3_channel *channel)\n{\n\tstruct ipu_soc *ipu = channel->ipu;\n\tu32 val;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&ipu->lock, flags);\n\n\tval = ipu_idmac_read(ipu, IDMAC_CHA_EN(channel->num));\n\tval |= idma_mask(channel->num);\n\tipu_idmac_write(ipu, val, IDMAC_CHA_EN(channel->num));\n\n\tspin_unlock_irqrestore(&ipu->lock, flags);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(ipu_idmac_enable_channel);\n\nbool ipu_idmac_channel_busy(struct ipu_soc *ipu, unsigned int chno)\n{\n\treturn (ipu_idmac_read(ipu, IDMAC_CHA_BUSY(chno)) & idma_mask(chno));\n}\nEXPORT_SYMBOL_GPL(ipu_idmac_channel_busy);\n\nint ipu_idmac_wait_busy(struct ipuv3_channel *channel, int ms)\n{\n\tstruct ipu_soc *ipu = channel->ipu;\n\tunsigned long timeout;\n\n\ttimeout = jiffies + msecs_to_jiffies(ms);\n\twhile (ipu_idmac_read(ipu, IDMAC_CHA_BUSY(channel->num)) &\n\t\t\tidma_mask(channel->num)) {\n\t\tif (time_after(jiffies, timeout))\n\t\t\treturn -ETIMEDOUT;\n\t\tcpu_relax();\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(ipu_idmac_wait_busy);\n\nint ipu_idmac_disable_channel(struct ipuv3_channel *channel)\n{\n\tstruct ipu_soc *ipu = channel->ipu;\n\tu32 val;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&ipu->lock, flags);\n\n\t \n\tval = ipu_idmac_read(ipu, IDMAC_CHA_EN(channel->num));\n\tval &= ~idma_mask(channel->num);\n\tipu_idmac_write(ipu, val, IDMAC_CHA_EN(channel->num));\n\n\t__ipu_idmac_reset_current_buffer(channel);\n\n\t \n\tipu_cm_write(ipu, 0xf0000000, IPU_GPR);  \n\n\tif (ipu_cm_read(ipu, IPU_CHA_BUF0_RDY(channel->num)) &\n\t\t\tidma_mask(channel->num)) {\n\t\tipu_cm_write(ipu, idma_mask(channel->num),\n\t\t\t     IPU_CHA_BUF0_RDY(channel->num));\n\t}\n\n\tif (ipu_cm_read(ipu, IPU_CHA_BUF1_RDY(channel->num)) &\n\t\t\tidma_mask(channel->num)) {\n\t\tipu_cm_write(ipu, idma_mask(channel->num),\n\t\t\t     IPU_CHA_BUF1_RDY(channel->num));\n\t}\n\n\tipu_cm_write(ipu, 0x0, IPU_GPR);  \n\n\t \n\tval = ipu_cm_read(ipu, IPU_CHA_DB_MODE_SEL(channel->num));\n\tval &= ~idma_mask(channel->num);\n\tipu_cm_write(ipu, val, IPU_CHA_DB_MODE_SEL(channel->num));\n\n\tspin_unlock_irqrestore(&ipu->lock, flags);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(ipu_idmac_disable_channel);\n\n \nvoid ipu_idmac_enable_watermark(struct ipuv3_channel *channel, bool enable)\n{\n\tstruct ipu_soc *ipu = channel->ipu;\n\tunsigned long flags;\n\tu32 val;\n\n\tspin_lock_irqsave(&ipu->lock, flags);\n\n\tval = ipu_idmac_read(ipu, IDMAC_WM_EN(channel->num));\n\tif (enable)\n\t\tval |= 1 << (channel->num % 32);\n\telse\n\t\tval &= ~(1 << (channel->num % 32));\n\tipu_idmac_write(ipu, val, IDMAC_WM_EN(channel->num));\n\n\tspin_unlock_irqrestore(&ipu->lock, flags);\n}\nEXPORT_SYMBOL_GPL(ipu_idmac_enable_watermark);\n\nstatic int ipu_memory_reset(struct ipu_soc *ipu)\n{\n\tunsigned long timeout;\n\n\tipu_cm_write(ipu, 0x807FFFFF, IPU_MEM_RST);\n\n\ttimeout = jiffies + msecs_to_jiffies(1000);\n\twhile (ipu_cm_read(ipu, IPU_MEM_RST) & 0x80000000) {\n\t\tif (time_after(jiffies, timeout))\n\t\t\treturn -ETIME;\n\t\tcpu_relax();\n\t}\n\n\treturn 0;\n}\n\n \nvoid ipu_set_csi_src_mux(struct ipu_soc *ipu, int csi_id, bool mipi_csi2)\n{\n\tunsigned long flags;\n\tu32 val, mask;\n\n\tmask = (csi_id == 1) ? IPU_CONF_CSI1_DATA_SOURCE :\n\t\tIPU_CONF_CSI0_DATA_SOURCE;\n\n\tspin_lock_irqsave(&ipu->lock, flags);\n\n\tval = ipu_cm_read(ipu, IPU_CONF);\n\tif (mipi_csi2)\n\t\tval |= mask;\n\telse\n\t\tval &= ~mask;\n\tipu_cm_write(ipu, val, IPU_CONF);\n\n\tspin_unlock_irqrestore(&ipu->lock, flags);\n}\nEXPORT_SYMBOL_GPL(ipu_set_csi_src_mux);\n\n \nvoid ipu_set_ic_src_mux(struct ipu_soc *ipu, int csi_id, bool vdi)\n{\n\tunsigned long flags;\n\tu32 val;\n\n\tspin_lock_irqsave(&ipu->lock, flags);\n\n\tval = ipu_cm_read(ipu, IPU_CONF);\n\tif (vdi)\n\t\tval |= IPU_CONF_IC_INPUT;\n\telse\n\t\tval &= ~IPU_CONF_IC_INPUT;\n\n\tif (csi_id == 1)\n\t\tval |= IPU_CONF_CSI_SEL;\n\telse\n\t\tval &= ~IPU_CONF_CSI_SEL;\n\n\tipu_cm_write(ipu, val, IPU_CONF);\n\n\tspin_unlock_irqrestore(&ipu->lock, flags);\n}\nEXPORT_SYMBOL_GPL(ipu_set_ic_src_mux);\n\n\n \n\nstruct fsu_link_reg_info {\n\tint chno;\n\tu32 reg;\n\tu32 mask;\n\tu32 val;\n};\n\nstruct fsu_link_info {\n\tstruct fsu_link_reg_info src;\n\tstruct fsu_link_reg_info sink;\n};\n\nstatic const struct fsu_link_info fsu_link_info[] = {\n\t{\n\t\t.src  = { IPUV3_CHANNEL_IC_PRP_ENC_MEM, IPU_FS_PROC_FLOW2,\n\t\t\t  FS_PRP_ENC_DEST_SEL_MASK, FS_PRP_ENC_DEST_SEL_IRT_ENC },\n\t\t.sink = { IPUV3_CHANNEL_MEM_ROT_ENC, IPU_FS_PROC_FLOW1,\n\t\t\t  FS_PRPENC_ROT_SRC_SEL_MASK, FS_PRPENC_ROT_SRC_SEL_ENC },\n\t}, {\n\t\t.src =  { IPUV3_CHANNEL_IC_PRP_VF_MEM, IPU_FS_PROC_FLOW2,\n\t\t\t  FS_PRPVF_DEST_SEL_MASK, FS_PRPVF_DEST_SEL_IRT_VF },\n\t\t.sink = { IPUV3_CHANNEL_MEM_ROT_VF, IPU_FS_PROC_FLOW1,\n\t\t\t  FS_PRPVF_ROT_SRC_SEL_MASK, FS_PRPVF_ROT_SRC_SEL_VF },\n\t}, {\n\t\t.src =  { IPUV3_CHANNEL_IC_PP_MEM, IPU_FS_PROC_FLOW2,\n\t\t\t  FS_PP_DEST_SEL_MASK, FS_PP_DEST_SEL_IRT_PP },\n\t\t.sink = { IPUV3_CHANNEL_MEM_ROT_PP, IPU_FS_PROC_FLOW1,\n\t\t\t  FS_PP_ROT_SRC_SEL_MASK, FS_PP_ROT_SRC_SEL_PP },\n\t}, {\n\t\t.src =  { IPUV3_CHANNEL_CSI_DIRECT, 0 },\n\t\t.sink = { IPUV3_CHANNEL_CSI_VDI_PREV, IPU_FS_PROC_FLOW1,\n\t\t\t  FS_VDI_SRC_SEL_MASK, FS_VDI_SRC_SEL_CSI_DIRECT },\n\t},\n};\n\nstatic const struct fsu_link_info *find_fsu_link_info(int src, int sink)\n{\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(fsu_link_info); i++) {\n\t\tif (src == fsu_link_info[i].src.chno &&\n\t\t    sink == fsu_link_info[i].sink.chno)\n\t\t\treturn &fsu_link_info[i];\n\t}\n\n\treturn NULL;\n}\n\n \nint ipu_fsu_link(struct ipu_soc *ipu, int src_ch, int sink_ch)\n{\n\tconst struct fsu_link_info *link;\n\tu32 src_reg, sink_reg;\n\tunsigned long flags;\n\n\tlink = find_fsu_link_info(src_ch, sink_ch);\n\tif (!link)\n\t\treturn -EINVAL;\n\n\tspin_lock_irqsave(&ipu->lock, flags);\n\n\tif (link->src.mask) {\n\t\tsrc_reg = ipu_cm_read(ipu, link->src.reg);\n\t\tsrc_reg &= ~link->src.mask;\n\t\tsrc_reg |= link->src.val;\n\t\tipu_cm_write(ipu, src_reg, link->src.reg);\n\t}\n\n\tif (link->sink.mask) {\n\t\tsink_reg = ipu_cm_read(ipu, link->sink.reg);\n\t\tsink_reg &= ~link->sink.mask;\n\t\tsink_reg |= link->sink.val;\n\t\tipu_cm_write(ipu, sink_reg, link->sink.reg);\n\t}\n\n\tspin_unlock_irqrestore(&ipu->lock, flags);\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(ipu_fsu_link);\n\n \nint ipu_fsu_unlink(struct ipu_soc *ipu, int src_ch, int sink_ch)\n{\n\tconst struct fsu_link_info *link;\n\tu32 src_reg, sink_reg;\n\tunsigned long flags;\n\n\tlink = find_fsu_link_info(src_ch, sink_ch);\n\tif (!link)\n\t\treturn -EINVAL;\n\n\tspin_lock_irqsave(&ipu->lock, flags);\n\n\tif (link->src.mask) {\n\t\tsrc_reg = ipu_cm_read(ipu, link->src.reg);\n\t\tsrc_reg &= ~link->src.mask;\n\t\tipu_cm_write(ipu, src_reg, link->src.reg);\n\t}\n\n\tif (link->sink.mask) {\n\t\tsink_reg = ipu_cm_read(ipu, link->sink.reg);\n\t\tsink_reg &= ~link->sink.mask;\n\t\tipu_cm_write(ipu, sink_reg, link->sink.reg);\n\t}\n\n\tspin_unlock_irqrestore(&ipu->lock, flags);\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(ipu_fsu_unlink);\n\n \nint ipu_idmac_link(struct ipuv3_channel *src, struct ipuv3_channel *sink)\n{\n\treturn ipu_fsu_link(src->ipu, src->num, sink->num);\n}\nEXPORT_SYMBOL_GPL(ipu_idmac_link);\n\n \nint ipu_idmac_unlink(struct ipuv3_channel *src, struct ipuv3_channel *sink)\n{\n\treturn ipu_fsu_unlink(src->ipu, src->num, sink->num);\n}\nEXPORT_SYMBOL_GPL(ipu_idmac_unlink);\n\nstruct ipu_devtype {\n\tconst char *name;\n\tunsigned long cm_ofs;\n\tunsigned long cpmem_ofs;\n\tunsigned long srm_ofs;\n\tunsigned long tpm_ofs;\n\tunsigned long csi0_ofs;\n\tunsigned long csi1_ofs;\n\tunsigned long ic_ofs;\n\tunsigned long disp0_ofs;\n\tunsigned long disp1_ofs;\n\tunsigned long dc_tmpl_ofs;\n\tunsigned long vdi_ofs;\n\tenum ipuv3_type type;\n};\n\nstatic struct ipu_devtype ipu_type_imx51 = {\n\t.name = \"IPUv3EX\",\n\t.cm_ofs = 0x1e000000,\n\t.cpmem_ofs = 0x1f000000,\n\t.srm_ofs = 0x1f040000,\n\t.tpm_ofs = 0x1f060000,\n\t.csi0_ofs = 0x1e030000,\n\t.csi1_ofs = 0x1e038000,\n\t.ic_ofs = 0x1e020000,\n\t.disp0_ofs = 0x1e040000,\n\t.disp1_ofs = 0x1e048000,\n\t.dc_tmpl_ofs = 0x1f080000,\n\t.vdi_ofs = 0x1e068000,\n\t.type = IPUV3EX,\n};\n\nstatic struct ipu_devtype ipu_type_imx53 = {\n\t.name = \"IPUv3M\",\n\t.cm_ofs = 0x06000000,\n\t.cpmem_ofs = 0x07000000,\n\t.srm_ofs = 0x07040000,\n\t.tpm_ofs = 0x07060000,\n\t.csi0_ofs = 0x06030000,\n\t.csi1_ofs = 0x06038000,\n\t.ic_ofs = 0x06020000,\n\t.disp0_ofs = 0x06040000,\n\t.disp1_ofs = 0x06048000,\n\t.dc_tmpl_ofs = 0x07080000,\n\t.vdi_ofs = 0x06068000,\n\t.type = IPUV3M,\n};\n\nstatic struct ipu_devtype ipu_type_imx6q = {\n\t.name = \"IPUv3H\",\n\t.cm_ofs = 0x00200000,\n\t.cpmem_ofs = 0x00300000,\n\t.srm_ofs = 0x00340000,\n\t.tpm_ofs = 0x00360000,\n\t.csi0_ofs = 0x00230000,\n\t.csi1_ofs = 0x00238000,\n\t.ic_ofs = 0x00220000,\n\t.disp0_ofs = 0x00240000,\n\t.disp1_ofs = 0x00248000,\n\t.dc_tmpl_ofs = 0x00380000,\n\t.vdi_ofs = 0x00268000,\n\t.type = IPUV3H,\n};\n\nstatic const struct of_device_id imx_ipu_dt_ids[] = {\n\t{ .compatible = \"fsl,imx51-ipu\", .data = &ipu_type_imx51, },\n\t{ .compatible = \"fsl,imx53-ipu\", .data = &ipu_type_imx53, },\n\t{ .compatible = \"fsl,imx6q-ipu\", .data = &ipu_type_imx6q, },\n\t{ .compatible = \"fsl,imx6qp-ipu\", .data = &ipu_type_imx6q, },\n\t{   }\n};\nMODULE_DEVICE_TABLE(of, imx_ipu_dt_ids);\n\nstatic int ipu_submodules_init(struct ipu_soc *ipu,\n\t\tstruct platform_device *pdev, unsigned long ipu_base,\n\t\tstruct clk *ipu_clk)\n{\n\tchar *unit;\n\tint ret;\n\tstruct device *dev = &pdev->dev;\n\tconst struct ipu_devtype *devtype = ipu->devtype;\n\n\tret = ipu_cpmem_init(ipu, dev, ipu_base + devtype->cpmem_ofs);\n\tif (ret) {\n\t\tunit = \"cpmem\";\n\t\tgoto err_cpmem;\n\t}\n\n\tret = ipu_csi_init(ipu, dev, 0, ipu_base + devtype->csi0_ofs,\n\t\t\t   IPU_CONF_CSI0_EN, ipu_clk);\n\tif (ret) {\n\t\tunit = \"csi0\";\n\t\tgoto err_csi_0;\n\t}\n\n\tret = ipu_csi_init(ipu, dev, 1, ipu_base + devtype->csi1_ofs,\n\t\t\t   IPU_CONF_CSI1_EN, ipu_clk);\n\tif (ret) {\n\t\tunit = \"csi1\";\n\t\tgoto err_csi_1;\n\t}\n\n\tret = ipu_ic_init(ipu, dev,\n\t\t\t  ipu_base + devtype->ic_ofs,\n\t\t\t  ipu_base + devtype->tpm_ofs);\n\tif (ret) {\n\t\tunit = \"ic\";\n\t\tgoto err_ic;\n\t}\n\n\tret = ipu_vdi_init(ipu, dev, ipu_base + devtype->vdi_ofs,\n\t\t\t   IPU_CONF_VDI_EN | IPU_CONF_ISP_EN |\n\t\t\t   IPU_CONF_IC_INPUT);\n\tif (ret) {\n\t\tunit = \"vdi\";\n\t\tgoto err_vdi;\n\t}\n\n\tret = ipu_image_convert_init(ipu, dev);\n\tif (ret) {\n\t\tunit = \"image_convert\";\n\t\tgoto err_image_convert;\n\t}\n\n\tret = ipu_di_init(ipu, dev, 0, ipu_base + devtype->disp0_ofs,\n\t\t\t  IPU_CONF_DI0_EN, ipu_clk);\n\tif (ret) {\n\t\tunit = \"di0\";\n\t\tgoto err_di_0;\n\t}\n\n\tret = ipu_di_init(ipu, dev, 1, ipu_base + devtype->disp1_ofs,\n\t\t\tIPU_CONF_DI1_EN, ipu_clk);\n\tif (ret) {\n\t\tunit = \"di1\";\n\t\tgoto err_di_1;\n\t}\n\n\tret = ipu_dc_init(ipu, dev, ipu_base + devtype->cm_ofs +\n\t\t\tIPU_CM_DC_REG_OFS, ipu_base + devtype->dc_tmpl_ofs);\n\tif (ret) {\n\t\tunit = \"dc_template\";\n\t\tgoto err_dc;\n\t}\n\n\tret = ipu_dmfc_init(ipu, dev, ipu_base +\n\t\t\tdevtype->cm_ofs + IPU_CM_DMFC_REG_OFS, ipu_clk);\n\tif (ret) {\n\t\tunit = \"dmfc\";\n\t\tgoto err_dmfc;\n\t}\n\n\tret = ipu_dp_init(ipu, dev, ipu_base + devtype->srm_ofs);\n\tif (ret) {\n\t\tunit = \"dp\";\n\t\tgoto err_dp;\n\t}\n\n\tret = ipu_smfc_init(ipu, dev, ipu_base +\n\t\t\tdevtype->cm_ofs + IPU_CM_SMFC_REG_OFS);\n\tif (ret) {\n\t\tunit = \"smfc\";\n\t\tgoto err_smfc;\n\t}\n\n\treturn 0;\n\nerr_smfc:\n\tipu_dp_exit(ipu);\nerr_dp:\n\tipu_dmfc_exit(ipu);\nerr_dmfc:\n\tipu_dc_exit(ipu);\nerr_dc:\n\tipu_di_exit(ipu, 1);\nerr_di_1:\n\tipu_di_exit(ipu, 0);\nerr_di_0:\n\tipu_image_convert_exit(ipu);\nerr_image_convert:\n\tipu_vdi_exit(ipu);\nerr_vdi:\n\tipu_ic_exit(ipu);\nerr_ic:\n\tipu_csi_exit(ipu, 1);\nerr_csi_1:\n\tipu_csi_exit(ipu, 0);\nerr_csi_0:\n\tipu_cpmem_exit(ipu);\nerr_cpmem:\n\tdev_err(&pdev->dev, \"init %s failed with %d\\n\", unit, ret);\n\treturn ret;\n}\n\nstatic void ipu_irq_handle(struct ipu_soc *ipu, const int *regs, int num_regs)\n{\n\tunsigned long status;\n\tint i, bit;\n\n\tfor (i = 0; i < num_regs; i++) {\n\n\t\tstatus = ipu_cm_read(ipu, IPU_INT_STAT(regs[i]));\n\t\tstatus &= ipu_cm_read(ipu, IPU_INT_CTRL(regs[i]));\n\n\t\tfor_each_set_bit(bit, &status, 32)\n\t\t\tgeneric_handle_domain_irq(ipu->domain,\n\t\t\t\t\t\t  regs[i] * 32 + bit);\n\t}\n}\n\nstatic void ipu_irq_handler(struct irq_desc *desc)\n{\n\tstruct ipu_soc *ipu = irq_desc_get_handler_data(desc);\n\tstruct irq_chip *chip = irq_desc_get_chip(desc);\n\tstatic const int int_reg[] = { 0, 1, 2, 3, 10, 11, 12, 13, 14};\n\n\tchained_irq_enter(chip, desc);\n\n\tipu_irq_handle(ipu, int_reg, ARRAY_SIZE(int_reg));\n\n\tchained_irq_exit(chip, desc);\n}\n\nstatic void ipu_err_irq_handler(struct irq_desc *desc)\n{\n\tstruct ipu_soc *ipu = irq_desc_get_handler_data(desc);\n\tstruct irq_chip *chip = irq_desc_get_chip(desc);\n\tstatic const int int_reg[] = { 4, 5, 8, 9};\n\n\tchained_irq_enter(chip, desc);\n\n\tipu_irq_handle(ipu, int_reg, ARRAY_SIZE(int_reg));\n\n\tchained_irq_exit(chip, desc);\n}\n\nint ipu_map_irq(struct ipu_soc *ipu, int irq)\n{\n\tint virq;\n\n\tvirq = irq_linear_revmap(ipu->domain, irq);\n\tif (!virq)\n\t\tvirq = irq_create_mapping(ipu->domain, irq);\n\n\treturn virq;\n}\nEXPORT_SYMBOL_GPL(ipu_map_irq);\n\nint ipu_idmac_channel_irq(struct ipu_soc *ipu, struct ipuv3_channel *channel,\n\t\tenum ipu_channel_irq irq_type)\n{\n\treturn ipu_map_irq(ipu, irq_type + channel->num);\n}\nEXPORT_SYMBOL_GPL(ipu_idmac_channel_irq);\n\nstatic void ipu_submodules_exit(struct ipu_soc *ipu)\n{\n\tipu_smfc_exit(ipu);\n\tipu_dp_exit(ipu);\n\tipu_dmfc_exit(ipu);\n\tipu_dc_exit(ipu);\n\tipu_di_exit(ipu, 1);\n\tipu_di_exit(ipu, 0);\n\tipu_image_convert_exit(ipu);\n\tipu_vdi_exit(ipu);\n\tipu_ic_exit(ipu);\n\tipu_csi_exit(ipu, 1);\n\tipu_csi_exit(ipu, 0);\n\tipu_cpmem_exit(ipu);\n}\n\nstatic int platform_remove_devices_fn(struct device *dev, void *unused)\n{\n\tstruct platform_device *pdev = to_platform_device(dev);\n\n\tplatform_device_unregister(pdev);\n\n\treturn 0;\n}\n\nstatic void platform_device_unregister_children(struct platform_device *pdev)\n{\n\tdevice_for_each_child(&pdev->dev, NULL, platform_remove_devices_fn);\n}\n\nstruct ipu_platform_reg {\n\tstruct ipu_client_platformdata pdata;\n\tconst char *name;\n};\n\n \nstatic struct ipu_platform_reg client_reg[] = {\n\t{\n\t\t.pdata = {\n\t\t\t.csi = 0,\n\t\t\t.dma[0] = IPUV3_CHANNEL_CSI0,\n\t\t\t.dma[1] = -EINVAL,\n\t\t},\n\t\t.name = \"imx-ipuv3-csi\",\n\t}, {\n\t\t.pdata = {\n\t\t\t.csi = 1,\n\t\t\t.dma[0] = IPUV3_CHANNEL_CSI1,\n\t\t\t.dma[1] = -EINVAL,\n\t\t},\n\t\t.name = \"imx-ipuv3-csi\",\n\t}, {\n\t\t.pdata = {\n\t\t\t.di = 0,\n\t\t\t.dc = 5,\n\t\t\t.dp = IPU_DP_FLOW_SYNC_BG,\n\t\t\t.dma[0] = IPUV3_CHANNEL_MEM_BG_SYNC,\n\t\t\t.dma[1] = IPUV3_CHANNEL_MEM_FG_SYNC,\n\t\t},\n\t\t.name = \"imx-ipuv3-crtc\",\n\t}, {\n\t\t.pdata = {\n\t\t\t.di = 1,\n\t\t\t.dc = 1,\n\t\t\t.dp = -EINVAL,\n\t\t\t.dma[0] = IPUV3_CHANNEL_MEM_DC_SYNC,\n\t\t\t.dma[1] = -EINVAL,\n\t\t},\n\t\t.name = \"imx-ipuv3-crtc\",\n\t},\n};\n\nstatic DEFINE_MUTEX(ipu_client_id_mutex);\nstatic int ipu_client_id;\n\nstatic int ipu_add_client_devices(struct ipu_soc *ipu, unsigned long ipu_base)\n{\n\tstruct device *dev = ipu->dev;\n\tunsigned i;\n\tint id, ret;\n\n\tmutex_lock(&ipu_client_id_mutex);\n\tid = ipu_client_id;\n\tipu_client_id += ARRAY_SIZE(client_reg);\n\tmutex_unlock(&ipu_client_id_mutex);\n\n\tfor (i = 0; i < ARRAY_SIZE(client_reg); i++) {\n\t\tstruct ipu_platform_reg *reg = &client_reg[i];\n\t\tstruct platform_device *pdev;\n\t\tstruct device_node *of_node;\n\n\t\t \n\t\tof_node = of_graph_get_port_by_id(dev->of_node, i);\n\t\tif (!of_node) {\n\t\t\tdev_info(dev,\n\t\t\t\t \"no port@%d node in %pOF, not using %s%d\\n\",\n\t\t\t\t i, dev->of_node,\n\t\t\t\t (i / 2) ? \"DI\" : \"CSI\", i % 2);\n\t\t\tcontinue;\n\t\t}\n\n\t\tpdev = platform_device_alloc(reg->name, id++);\n\t\tif (!pdev) {\n\t\t\tret = -ENOMEM;\n\t\t\tof_node_put(of_node);\n\t\t\tgoto err_register;\n\t\t}\n\n\t\tpdev->dev.parent = dev;\n\n\t\treg->pdata.of_node = of_node;\n\t\tret = platform_device_add_data(pdev, &reg->pdata,\n\t\t\t\t\t       sizeof(reg->pdata));\n\t\tif (!ret)\n\t\t\tret = platform_device_add(pdev);\n\t\tif (ret) {\n\t\t\tplatform_device_put(pdev);\n\t\t\tgoto err_register;\n\t\t}\n\t}\n\n\treturn 0;\n\nerr_register:\n\tplatform_device_unregister_children(to_platform_device(dev));\n\n\treturn ret;\n}\n\n\nstatic int ipu_irq_init(struct ipu_soc *ipu)\n{\n\tstruct irq_chip_generic *gc;\n\tstruct irq_chip_type *ct;\n\tunsigned long unused[IPU_NUM_IRQS / 32] = {\n\t\t0x400100d0, 0xffe000fd,\n\t\t0x400100d0, 0xffe000fd,\n\t\t0x400100d0, 0xffe000fd,\n\t\t0x4077ffff, 0xffe7e1fd,\n\t\t0x23fffffe, 0x8880fff0,\n\t\t0xf98fe7d0, 0xfff81fff,\n\t\t0x400100d0, 0xffe000fd,\n\t\t0x00000000,\n\t};\n\tint ret, i;\n\n\tipu->domain = irq_domain_add_linear(ipu->dev->of_node, IPU_NUM_IRQS,\n\t\t\t\t\t    &irq_generic_chip_ops, ipu);\n\tif (!ipu->domain) {\n\t\tdev_err(ipu->dev, \"failed to add irq domain\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tret = irq_alloc_domain_generic_chips(ipu->domain, 32, 1, \"IPU\",\n\t\t\t\t\t     handle_level_irq, 0, 0, 0);\n\tif (ret < 0) {\n\t\tdev_err(ipu->dev, \"failed to alloc generic irq chips\\n\");\n\t\tirq_domain_remove(ipu->domain);\n\t\treturn ret;\n\t}\n\n\t \n\tfor (i = 0; i < IPU_NUM_IRQS; i += 32) {\n\t\tipu_cm_write(ipu, 0, IPU_INT_CTRL(i / 32));\n\t\tipu_cm_write(ipu, ~unused[i / 32], IPU_INT_STAT(i / 32));\n\t}\n\n\tfor (i = 0; i < IPU_NUM_IRQS; i += 32) {\n\t\tgc = irq_get_domain_generic_chip(ipu->domain, i);\n\t\tgc->reg_base = ipu->cm_reg;\n\t\tgc->unused = unused[i / 32];\n\t\tct = gc->chip_types;\n\t\tct->chip.irq_ack = irq_gc_ack_set_bit;\n\t\tct->chip.irq_mask = irq_gc_mask_clr_bit;\n\t\tct->chip.irq_unmask = irq_gc_mask_set_bit;\n\t\tct->regs.ack = IPU_INT_STAT(i / 32);\n\t\tct->regs.mask = IPU_INT_CTRL(i / 32);\n\t}\n\n\tirq_set_chained_handler_and_data(ipu->irq_sync, ipu_irq_handler, ipu);\n\tirq_set_chained_handler_and_data(ipu->irq_err, ipu_err_irq_handler,\n\t\t\t\t\t ipu);\n\n\treturn 0;\n}\n\nstatic void ipu_irq_exit(struct ipu_soc *ipu)\n{\n\tint i, irq;\n\n\tirq_set_chained_handler_and_data(ipu->irq_err, NULL, NULL);\n\tirq_set_chained_handler_and_data(ipu->irq_sync, NULL, NULL);\n\n\t \n\n\tfor (i = 0; i < IPU_NUM_IRQS; i++) {\n\t\tirq = irq_linear_revmap(ipu->domain, i);\n\t\tif (irq)\n\t\t\tirq_dispose_mapping(irq);\n\t}\n\n\tirq_domain_remove(ipu->domain);\n}\n\nvoid ipu_dump(struct ipu_soc *ipu)\n{\n\tint i;\n\n\tdev_dbg(ipu->dev, \"IPU_CONF = \\t0x%08X\\n\",\n\t\tipu_cm_read(ipu, IPU_CONF));\n\tdev_dbg(ipu->dev, \"IDMAC_CONF = \\t0x%08X\\n\",\n\t\tipu_idmac_read(ipu, IDMAC_CONF));\n\tdev_dbg(ipu->dev, \"IDMAC_CHA_EN1 = \\t0x%08X\\n\",\n\t\tipu_idmac_read(ipu, IDMAC_CHA_EN(0)));\n\tdev_dbg(ipu->dev, \"IDMAC_CHA_EN2 = \\t0x%08X\\n\",\n\t\tipu_idmac_read(ipu, IDMAC_CHA_EN(32)));\n\tdev_dbg(ipu->dev, \"IDMAC_CHA_PRI1 = \\t0x%08X\\n\",\n\t\tipu_idmac_read(ipu, IDMAC_CHA_PRI(0)));\n\tdev_dbg(ipu->dev, \"IDMAC_CHA_PRI2 = \\t0x%08X\\n\",\n\t\tipu_idmac_read(ipu, IDMAC_CHA_PRI(32)));\n\tdev_dbg(ipu->dev, \"IDMAC_BAND_EN1 = \\t0x%08X\\n\",\n\t\tipu_idmac_read(ipu, IDMAC_BAND_EN(0)));\n\tdev_dbg(ipu->dev, \"IDMAC_BAND_EN2 = \\t0x%08X\\n\",\n\t\tipu_idmac_read(ipu, IDMAC_BAND_EN(32)));\n\tdev_dbg(ipu->dev, \"IPU_CHA_DB_MODE_SEL0 = \\t0x%08X\\n\",\n\t\tipu_cm_read(ipu, IPU_CHA_DB_MODE_SEL(0)));\n\tdev_dbg(ipu->dev, \"IPU_CHA_DB_MODE_SEL1 = \\t0x%08X\\n\",\n\t\tipu_cm_read(ipu, IPU_CHA_DB_MODE_SEL(32)));\n\tdev_dbg(ipu->dev, \"IPU_FS_PROC_FLOW1 = \\t0x%08X\\n\",\n\t\tipu_cm_read(ipu, IPU_FS_PROC_FLOW1));\n\tdev_dbg(ipu->dev, \"IPU_FS_PROC_FLOW2 = \\t0x%08X\\n\",\n\t\tipu_cm_read(ipu, IPU_FS_PROC_FLOW2));\n\tdev_dbg(ipu->dev, \"IPU_FS_PROC_FLOW3 = \\t0x%08X\\n\",\n\t\tipu_cm_read(ipu, IPU_FS_PROC_FLOW3));\n\tdev_dbg(ipu->dev, \"IPU_FS_DISP_FLOW1 = \\t0x%08X\\n\",\n\t\tipu_cm_read(ipu, IPU_FS_DISP_FLOW1));\n\tfor (i = 0; i < 15; i++)\n\t\tdev_dbg(ipu->dev, \"IPU_INT_CTRL(%d) = \\t%08X\\n\", i,\n\t\t\tipu_cm_read(ipu, IPU_INT_CTRL(i)));\n}\nEXPORT_SYMBOL_GPL(ipu_dump);\n\nstatic int ipu_probe(struct platform_device *pdev)\n{\n\tstruct device_node *np = pdev->dev.of_node;\n\tstruct ipu_soc *ipu;\n\tstruct resource *res;\n\tunsigned long ipu_base;\n\tint ret, irq_sync, irq_err;\n\tconst struct ipu_devtype *devtype;\n\n\tdevtype = of_device_get_match_data(&pdev->dev);\n\tif (!devtype)\n\t\treturn -EINVAL;\n\n\tirq_sync = platform_get_irq(pdev, 0);\n\tirq_err = platform_get_irq(pdev, 1);\n\tres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\n\n\tdev_dbg(&pdev->dev, \"irq_sync: %d irq_err: %d\\n\",\n\t\t\tirq_sync, irq_err);\n\n\tif (!res || irq_sync < 0 || irq_err < 0)\n\t\treturn -ENODEV;\n\n\tipu_base = res->start;\n\n\tipu = devm_kzalloc(&pdev->dev, sizeof(*ipu), GFP_KERNEL);\n\tif (!ipu)\n\t\treturn -ENODEV;\n\n\tipu->id = of_alias_get_id(np, \"ipu\");\n\tif (ipu->id < 0)\n\t\tipu->id = 0;\n\n\tif (of_device_is_compatible(np, \"fsl,imx6qp-ipu\") &&\n\t    IS_ENABLED(CONFIG_DRM)) {\n\t\tipu->prg_priv = ipu_prg_lookup_by_phandle(&pdev->dev,\n\t\t\t\t\t\t\t  \"fsl,prg\", ipu->id);\n\t\tif (!ipu->prg_priv)\n\t\t\treturn -EPROBE_DEFER;\n\t}\n\n\tipu->devtype = devtype;\n\tipu->ipu_type = devtype->type;\n\n\tspin_lock_init(&ipu->lock);\n\tmutex_init(&ipu->channel_lock);\n\tINIT_LIST_HEAD(&ipu->channels);\n\n\tdev_dbg(&pdev->dev, \"cm_reg:   0x%08lx\\n\",\n\t\t\tipu_base + devtype->cm_ofs);\n\tdev_dbg(&pdev->dev, \"idmac:    0x%08lx\\n\",\n\t\t\tipu_base + devtype->cm_ofs + IPU_CM_IDMAC_REG_OFS);\n\tdev_dbg(&pdev->dev, \"cpmem:    0x%08lx\\n\",\n\t\t\tipu_base + devtype->cpmem_ofs);\n\tdev_dbg(&pdev->dev, \"csi0:    0x%08lx\\n\",\n\t\t\tipu_base + devtype->csi0_ofs);\n\tdev_dbg(&pdev->dev, \"csi1:    0x%08lx\\n\",\n\t\t\tipu_base + devtype->csi1_ofs);\n\tdev_dbg(&pdev->dev, \"ic:      0x%08lx\\n\",\n\t\t\tipu_base + devtype->ic_ofs);\n\tdev_dbg(&pdev->dev, \"disp0:    0x%08lx\\n\",\n\t\t\tipu_base + devtype->disp0_ofs);\n\tdev_dbg(&pdev->dev, \"disp1:    0x%08lx\\n\",\n\t\t\tipu_base + devtype->disp1_ofs);\n\tdev_dbg(&pdev->dev, \"srm:      0x%08lx\\n\",\n\t\t\tipu_base + devtype->srm_ofs);\n\tdev_dbg(&pdev->dev, \"tpm:      0x%08lx\\n\",\n\t\t\tipu_base + devtype->tpm_ofs);\n\tdev_dbg(&pdev->dev, \"dc:       0x%08lx\\n\",\n\t\t\tipu_base + devtype->cm_ofs + IPU_CM_DC_REG_OFS);\n\tdev_dbg(&pdev->dev, \"ic:       0x%08lx\\n\",\n\t\t\tipu_base + devtype->cm_ofs + IPU_CM_IC_REG_OFS);\n\tdev_dbg(&pdev->dev, \"dmfc:     0x%08lx\\n\",\n\t\t\tipu_base + devtype->cm_ofs + IPU_CM_DMFC_REG_OFS);\n\tdev_dbg(&pdev->dev, \"vdi:      0x%08lx\\n\",\n\t\t\tipu_base + devtype->vdi_ofs);\n\n\tipu->cm_reg = devm_ioremap(&pdev->dev,\n\t\t\tipu_base + devtype->cm_ofs, PAGE_SIZE);\n\tipu->idmac_reg = devm_ioremap(&pdev->dev,\n\t\t\tipu_base + devtype->cm_ofs + IPU_CM_IDMAC_REG_OFS,\n\t\t\tPAGE_SIZE);\n\n\tif (!ipu->cm_reg || !ipu->idmac_reg)\n\t\treturn -ENOMEM;\n\n\tipu->clk = devm_clk_get(&pdev->dev, \"bus\");\n\tif (IS_ERR(ipu->clk)) {\n\t\tret = PTR_ERR(ipu->clk);\n\t\tdev_err(&pdev->dev, \"clk_get failed with %d\", ret);\n\t\treturn ret;\n\t}\n\n\tplatform_set_drvdata(pdev, ipu);\n\n\tret = clk_prepare_enable(ipu->clk);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"clk_prepare_enable failed: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tipu->dev = &pdev->dev;\n\tipu->irq_sync = irq_sync;\n\tipu->irq_err = irq_err;\n\n\tret = device_reset(&pdev->dev);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"failed to reset: %d\\n\", ret);\n\t\tgoto out_failed_reset;\n\t}\n\tret = ipu_memory_reset(ipu);\n\tif (ret)\n\t\tgoto out_failed_reset;\n\n\tret = ipu_irq_init(ipu);\n\tif (ret)\n\t\tgoto out_failed_irq;\n\n\t \n\tipu_cm_write(ipu, 0x00400000L | (IPU_MCU_T_DEFAULT << 18),\n\t\t\tIPU_DISP_GEN);\n\n\tret = ipu_submodules_init(ipu, pdev, ipu_base, ipu->clk);\n\tif (ret)\n\t\tgoto failed_submodules_init;\n\n\tret = ipu_add_client_devices(ipu, ipu_base);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"adding client devices failed with %d\\n\",\n\t\t\t\tret);\n\t\tgoto failed_add_clients;\n\t}\n\n\tdev_info(&pdev->dev, \"%s probed\\n\", devtype->name);\n\n\treturn 0;\n\nfailed_add_clients:\n\tipu_submodules_exit(ipu);\nfailed_submodules_init:\n\tipu_irq_exit(ipu);\nout_failed_irq:\nout_failed_reset:\n\tclk_disable_unprepare(ipu->clk);\n\treturn ret;\n}\n\nstatic int ipu_remove(struct platform_device *pdev)\n{\n\tstruct ipu_soc *ipu = platform_get_drvdata(pdev);\n\n\tplatform_device_unregister_children(pdev);\n\tipu_submodules_exit(ipu);\n\tipu_irq_exit(ipu);\n\n\tclk_disable_unprepare(ipu->clk);\n\n\treturn 0;\n}\n\nstatic struct platform_driver imx_ipu_driver = {\n\t.driver = {\n\t\t.name = \"imx-ipuv3\",\n\t\t.of_match_table = imx_ipu_dt_ids,\n\t},\n\t.probe = ipu_probe,\n\t.remove = ipu_remove,\n};\n\nstatic struct platform_driver * const drivers[] = {\n#if IS_ENABLED(CONFIG_DRM)\n\t&ipu_pre_drv,\n\t&ipu_prg_drv,\n#endif\n\t&imx_ipu_driver,\n};\n\nstatic int __init imx_ipu_init(void)\n{\n\treturn platform_register_drivers(drivers, ARRAY_SIZE(drivers));\n}\nmodule_init(imx_ipu_init);\n\nstatic void __exit imx_ipu_exit(void)\n{\n\tplatform_unregister_drivers(drivers, ARRAY_SIZE(drivers));\n}\nmodule_exit(imx_ipu_exit);\n\nMODULE_ALIAS(\"platform:imx-ipuv3\");\nMODULE_DESCRIPTION(\"i.MX IPU v3 driver\");\nMODULE_AUTHOR(\"Sascha Hauer <s.hauer@pengutronix.de>\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}