{
  "module_name": "ipu-dc.c",
  "hash_id": "9fc76a7b1fce57413374d88f19193aaaa351fbee64cc8ab05039ded392024374",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/ipu-v3/ipu-dc.c",
  "human_readable_source": "\n \n\n#include <linux/export.h>\n#include <linux/module.h>\n#include <linux/types.h>\n#include <linux/errno.h>\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/io.h>\n\n#include <video/imx-ipu-v3.h>\n#include \"ipu-prv.h\"\n\n#define DC_MAP_CONF_PTR(n)\t(0x108 + ((n) & ~0x1) * 2)\n#define DC_MAP_CONF_VAL(n)\t(0x144 + ((n) & ~0x1) * 2)\n\n#define DC_EVT_NF\t\t0\n#define DC_EVT_NL\t\t1\n#define DC_EVT_EOF\t\t2\n#define DC_EVT_NFIELD\t\t3\n#define DC_EVT_EOL\t\t4\n#define DC_EVT_EOFIELD\t\t5\n#define DC_EVT_NEW_ADDR\t\t6\n#define DC_EVT_NEW_CHAN\t\t7\n#define DC_EVT_NEW_DATA\t\t8\n\n#define DC_EVT_NEW_ADDR_W_0\t0\n#define DC_EVT_NEW_ADDR_W_1\t1\n#define DC_EVT_NEW_CHAN_W_0\t2\n#define DC_EVT_NEW_CHAN_W_1\t3\n#define DC_EVT_NEW_DATA_W_0\t4\n#define DC_EVT_NEW_DATA_W_1\t5\n#define DC_EVT_NEW_ADDR_R_0\t6\n#define DC_EVT_NEW_ADDR_R_1\t7\n#define DC_EVT_NEW_CHAN_R_0\t8\n#define DC_EVT_NEW_CHAN_R_1\t9\n#define DC_EVT_NEW_DATA_R_0\t10\n#define DC_EVT_NEW_DATA_R_1\t11\n\n#define DC_WR_CH_CONF\t\t0x0\n#define DC_WR_CH_ADDR\t\t0x4\n#define DC_RL_CH(evt)\t\t(8 + ((evt) & ~0x1) * 2)\n\n#define DC_GEN\t\t\t0xd4\n#define DC_DISP_CONF1(disp)\t(0xd8 + (disp) * 4)\n#define DC_DISP_CONF2(disp)\t(0xe8 + (disp) * 4)\n#define DC_STAT\t\t\t0x1c8\n\n#define WROD(lf)\t\t(0x18 | ((lf) << 1))\n#define WRG\t\t\t0x01\n#define WCLK\t\t\t0xc9\n\n#define SYNC_WAVE 0\n#define NULL_WAVE (-1)\n\n#define DC_GEN_SYNC_1_6_SYNC\t(2 << 1)\n#define DC_GEN_SYNC_PRIORITY_1\t(1 << 7)\n\n#define DC_WR_CH_CONF_WORD_SIZE_8\t\t(0 << 0)\n#define DC_WR_CH_CONF_WORD_SIZE_16\t\t(1 << 0)\n#define DC_WR_CH_CONF_WORD_SIZE_24\t\t(2 << 0)\n#define DC_WR_CH_CONF_WORD_SIZE_32\t\t(3 << 0)\n#define DC_WR_CH_CONF_DISP_ID_PARALLEL(i)\t(((i) & 0x1) << 3)\n#define DC_WR_CH_CONF_DISP_ID_SERIAL\t\t(2 << 3)\n#define DC_WR_CH_CONF_DISP_ID_ASYNC\t\t(3 << 4)\n#define DC_WR_CH_CONF_FIELD_MODE\t\t(1 << 9)\n#define DC_WR_CH_CONF_PROG_TYPE_NORMAL\t\t(4 << 5)\n#define DC_WR_CH_CONF_PROG_TYPE_MASK\t\t(7 << 5)\n#define DC_WR_CH_CONF_PROG_DI_ID\t\t(1 << 2)\n#define DC_WR_CH_CONF_PROG_DISP_ID(i)\t\t(((i) & 0x1) << 3)\n\n#define IPU_DC_NUM_CHANNELS\t10\n\nstruct ipu_dc_priv;\n\nenum ipu_dc_map {\n\tIPU_DC_MAP_RGB24,\n\tIPU_DC_MAP_RGB565,\n\tIPU_DC_MAP_GBR24,  \n\tIPU_DC_MAP_BGR666,\n\tIPU_DC_MAP_LVDS666,\n\tIPU_DC_MAP_BGR24,\n};\n\nstruct ipu_dc {\n\t \n\tunsigned int\t\tdi;\n\tvoid __iomem\t\t*base;\n\tstruct ipu_dc_priv\t*priv;\n\tint\t\t\tchno;\n\tbool\t\t\tin_use;\n};\n\nstruct ipu_dc_priv {\n\tvoid __iomem\t\t*dc_reg;\n\tvoid __iomem\t\t*dc_tmpl_reg;\n\tstruct ipu_soc\t\t*ipu;\n\tstruct device\t\t*dev;\n\tstruct ipu_dc\t\tchannels[IPU_DC_NUM_CHANNELS];\n\tstruct mutex\t\tmutex;\n\tstruct completion\tcomp;\n\tint\t\t\tuse_count;\n};\n\nstatic void dc_link_event(struct ipu_dc *dc, int event, int addr, int priority)\n{\n\tu32 reg;\n\n\treg = readl(dc->base + DC_RL_CH(event));\n\treg &= ~(0xffff << (16 * (event & 0x1)));\n\treg |= ((addr << 8) | priority) << (16 * (event & 0x1));\n\twritel(reg, dc->base + DC_RL_CH(event));\n}\n\nstatic void dc_write_tmpl(struct ipu_dc *dc, int word, u32 opcode, u32 operand,\n\t\tint map, int wave, int glue, int sync, int stop)\n{\n\tstruct ipu_dc_priv *priv = dc->priv;\n\tu32 reg1, reg2;\n\n\tif (opcode == WCLK) {\n\t\treg1 = (operand << 20) & 0xfff00000;\n\t\treg2 = operand >> 12 | opcode << 1 | stop << 9;\n\t} else if (opcode == WRG) {\n\t\treg1 = sync | glue << 4 | ++wave << 11 | ((operand << 15) & 0xffff8000);\n\t\treg2 = operand >> 17 | opcode << 7 | stop << 9;\n\t} else {\n\t\treg1 = sync | glue << 4 | ++wave << 11 | ++map << 15 | ((operand << 20) & 0xfff00000);\n\t\treg2 = operand >> 12 | opcode << 4 | stop << 9;\n\t}\n\twritel(reg1, priv->dc_tmpl_reg + word * 8);\n\twritel(reg2, priv->dc_tmpl_reg + word * 8 + 4);\n}\n\nstatic int ipu_bus_format_to_map(u32 fmt)\n{\n\tswitch (fmt) {\n\tdefault:\n\t\tWARN_ON(1);\n\t\tfallthrough;\n\tcase MEDIA_BUS_FMT_RGB888_1X24:\n\t\treturn IPU_DC_MAP_RGB24;\n\tcase MEDIA_BUS_FMT_RGB565_1X16:\n\t\treturn IPU_DC_MAP_RGB565;\n\tcase MEDIA_BUS_FMT_GBR888_1X24:\n\t\treturn IPU_DC_MAP_GBR24;\n\tcase MEDIA_BUS_FMT_RGB666_1X18:\n\t\treturn IPU_DC_MAP_BGR666;\n\tcase MEDIA_BUS_FMT_RGB666_1X24_CPADHI:\n\t\treturn IPU_DC_MAP_LVDS666;\n\tcase MEDIA_BUS_FMT_BGR888_1X24:\n\t\treturn IPU_DC_MAP_BGR24;\n\t}\n}\n\nint ipu_dc_init_sync(struct ipu_dc *dc, struct ipu_di *di, bool interlaced,\n\t\tu32 bus_format, u32 width)\n{\n\tstruct ipu_dc_priv *priv = dc->priv;\n\tint addr, sync;\n\tu32 reg = 0;\n\tint map;\n\n\tdc->di = ipu_di_get_num(di);\n\n\tif (!IS_ALIGNED(width, 8)) {\n\t\tdev_warn(priv->dev,\n\t\t\t \"%s: hactive does not align to 8 byte\\n\", __func__);\n\t}\n\n\tmap = ipu_bus_format_to_map(bus_format);\n\n\t \n\tsync = interlaced ? 6 : 5;\n\n\t \n\tif (dc->di)\n\t\taddr = 5;\n\telse\n\t\taddr = 0;\n\n\tif (interlaced) {\n\t\tdc_link_event(dc, DC_EVT_NL, addr, 3);\n\t\tdc_link_event(dc, DC_EVT_EOL, addr, 2);\n\t\tdc_link_event(dc, DC_EVT_NEW_DATA, addr, 1);\n\n\t\t \n\t\tdc_write_tmpl(dc, addr, WROD(0), 0, map, SYNC_WAVE, 0, sync, 1);\n\t} else {\n\t\tdc_link_event(dc, DC_EVT_NL, addr + 2, 3);\n\t\tdc_link_event(dc, DC_EVT_EOL, addr + 3, 2);\n\t\tdc_link_event(dc, DC_EVT_NEW_DATA, addr + 1, 1);\n\n\t\t \n\t\tdc_write_tmpl(dc, addr + 2, WROD(0), 0, map, SYNC_WAVE, 8, sync, 1);\n\t\tdc_write_tmpl(dc, addr + 3, WROD(0), 0, map, SYNC_WAVE, 4, sync, 0);\n\t\tdc_write_tmpl(dc, addr + 4, WRG, 0, map, NULL_WAVE, 0, 0, 1);\n\t\tdc_write_tmpl(dc, addr + 1, WROD(0), 0, map, SYNC_WAVE, 0, sync, 1);\n\t}\n\n\tdc_link_event(dc, DC_EVT_NF, 0, 0);\n\tdc_link_event(dc, DC_EVT_NFIELD, 0, 0);\n\tdc_link_event(dc, DC_EVT_EOF, 0, 0);\n\tdc_link_event(dc, DC_EVT_EOFIELD, 0, 0);\n\tdc_link_event(dc, DC_EVT_NEW_CHAN, 0, 0);\n\tdc_link_event(dc, DC_EVT_NEW_ADDR, 0, 0);\n\n\treg = readl(dc->base + DC_WR_CH_CONF);\n\tif (interlaced)\n\t\treg |= DC_WR_CH_CONF_FIELD_MODE;\n\telse\n\t\treg &= ~DC_WR_CH_CONF_FIELD_MODE;\n\twritel(reg, dc->base + DC_WR_CH_CONF);\n\n\twritel(0x0, dc->base + DC_WR_CH_ADDR);\n\twritel(width, priv->dc_reg + DC_DISP_CONF2(dc->di));\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(ipu_dc_init_sync);\n\nvoid ipu_dc_enable(struct ipu_soc *ipu)\n{\n\tstruct ipu_dc_priv *priv = ipu->dc_priv;\n\n\tmutex_lock(&priv->mutex);\n\n\tif (!priv->use_count)\n\t\tipu_module_enable(priv->ipu, IPU_CONF_DC_EN);\n\n\tpriv->use_count++;\n\n\tmutex_unlock(&priv->mutex);\n}\nEXPORT_SYMBOL_GPL(ipu_dc_enable);\n\nvoid ipu_dc_enable_channel(struct ipu_dc *dc)\n{\n\tu32 reg;\n\n\treg = readl(dc->base + DC_WR_CH_CONF);\n\treg |= DC_WR_CH_CONF_PROG_TYPE_NORMAL;\n\twritel(reg, dc->base + DC_WR_CH_CONF);\n}\nEXPORT_SYMBOL_GPL(ipu_dc_enable_channel);\n\nvoid ipu_dc_disable_channel(struct ipu_dc *dc)\n{\n\tu32 val;\n\n\tval = readl(dc->base + DC_WR_CH_CONF);\n\tval &= ~DC_WR_CH_CONF_PROG_TYPE_MASK;\n\twritel(val, dc->base + DC_WR_CH_CONF);\n}\nEXPORT_SYMBOL_GPL(ipu_dc_disable_channel);\n\nvoid ipu_dc_disable(struct ipu_soc *ipu)\n{\n\tstruct ipu_dc_priv *priv = ipu->dc_priv;\n\n\tmutex_lock(&priv->mutex);\n\n\tpriv->use_count--;\n\tif (!priv->use_count)\n\t\tipu_module_disable(priv->ipu, IPU_CONF_DC_EN);\n\n\tif (priv->use_count < 0)\n\t\tpriv->use_count = 0;\n\n\tmutex_unlock(&priv->mutex);\n}\nEXPORT_SYMBOL_GPL(ipu_dc_disable);\n\nstatic void ipu_dc_map_config(struct ipu_dc_priv *priv, enum ipu_dc_map map,\n\t\tint byte_num, int offset, int mask)\n{\n\tint ptr = map * 3 + byte_num;\n\tu32 reg;\n\n\treg = readl(priv->dc_reg + DC_MAP_CONF_VAL(ptr));\n\treg &= ~(0xffff << (16 * (ptr & 0x1)));\n\treg |= ((offset << 8) | mask) << (16 * (ptr & 0x1));\n\twritel(reg, priv->dc_reg + DC_MAP_CONF_VAL(ptr));\n\n\treg = readl(priv->dc_reg + DC_MAP_CONF_PTR(map));\n\treg &= ~(0x1f << ((16 * (map & 0x1)) + (5 * byte_num)));\n\treg |= ptr << ((16 * (map & 0x1)) + (5 * byte_num));\n\twritel(reg, priv->dc_reg + DC_MAP_CONF_PTR(map));\n}\n\nstatic void ipu_dc_map_clear(struct ipu_dc_priv *priv, int map)\n{\n\tu32 reg = readl(priv->dc_reg + DC_MAP_CONF_PTR(map));\n\n\twritel(reg & ~(0xffff << (16 * (map & 0x1))),\n\t\t     priv->dc_reg + DC_MAP_CONF_PTR(map));\n}\n\nstruct ipu_dc *ipu_dc_get(struct ipu_soc *ipu, int channel)\n{\n\tstruct ipu_dc_priv *priv = ipu->dc_priv;\n\tstruct ipu_dc *dc;\n\n\tif (channel >= IPU_DC_NUM_CHANNELS)\n\t\treturn ERR_PTR(-ENODEV);\n\n\tdc = &priv->channels[channel];\n\n\tmutex_lock(&priv->mutex);\n\n\tif (dc->in_use) {\n\t\tmutex_unlock(&priv->mutex);\n\t\treturn ERR_PTR(-EBUSY);\n\t}\n\n\tdc->in_use = true;\n\n\tmutex_unlock(&priv->mutex);\n\n\treturn dc;\n}\nEXPORT_SYMBOL_GPL(ipu_dc_get);\n\nvoid ipu_dc_put(struct ipu_dc *dc)\n{\n\tstruct ipu_dc_priv *priv = dc->priv;\n\n\tmutex_lock(&priv->mutex);\n\tdc->in_use = false;\n\tmutex_unlock(&priv->mutex);\n}\nEXPORT_SYMBOL_GPL(ipu_dc_put);\n\nint ipu_dc_init(struct ipu_soc *ipu, struct device *dev,\n\t\tunsigned long base, unsigned long template_base)\n{\n\tstruct ipu_dc_priv *priv;\n\tstatic const int channel_offsets[] = {\n\t\t0, 0x1c, 0x38, 0x54, 0x58, 0x5c, 0x78, 0, 0x94, 0xb4\n\t};\n\tint i;\n\n\tpriv = devm_kzalloc(dev, sizeof(*priv), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\n\tmutex_init(&priv->mutex);\n\n\tpriv->dev = dev;\n\tpriv->ipu = ipu;\n\tpriv->dc_reg = devm_ioremap(dev, base, PAGE_SIZE);\n\tpriv->dc_tmpl_reg = devm_ioremap(dev, template_base, PAGE_SIZE);\n\tif (!priv->dc_reg || !priv->dc_tmpl_reg)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < IPU_DC_NUM_CHANNELS; i++) {\n\t\tpriv->channels[i].chno = i;\n\t\tpriv->channels[i].priv = priv;\n\t\tpriv->channels[i].base = priv->dc_reg + channel_offsets[i];\n\t}\n\n\twritel(DC_WR_CH_CONF_WORD_SIZE_24 | DC_WR_CH_CONF_DISP_ID_PARALLEL(1) |\n\t\t\tDC_WR_CH_CONF_PROG_DI_ID,\n\t\t\tpriv->channels[1].base + DC_WR_CH_CONF);\n\twritel(DC_WR_CH_CONF_WORD_SIZE_24 | DC_WR_CH_CONF_DISP_ID_PARALLEL(0),\n\t\t\tpriv->channels[5].base + DC_WR_CH_CONF);\n\n\twritel(DC_GEN_SYNC_1_6_SYNC | DC_GEN_SYNC_PRIORITY_1,\n\t\tpriv->dc_reg + DC_GEN);\n\n\tipu->dc_priv = priv;\n\n\tdev_dbg(dev, \"DC base: 0x%08lx template base: 0x%08lx\\n\",\n\t\t\tbase, template_base);\n\n\t \n\tipu_dc_map_clear(priv, IPU_DC_MAP_RGB24);\n\tipu_dc_map_config(priv, IPU_DC_MAP_RGB24, 0, 7, 0xff);  \n\tipu_dc_map_config(priv, IPU_DC_MAP_RGB24, 1, 15, 0xff);  \n\tipu_dc_map_config(priv, IPU_DC_MAP_RGB24, 2, 23, 0xff);  \n\n\t \n\tipu_dc_map_clear(priv, IPU_DC_MAP_RGB565);\n\tipu_dc_map_config(priv, IPU_DC_MAP_RGB565, 0, 4, 0xf8);  \n\tipu_dc_map_config(priv, IPU_DC_MAP_RGB565, 1, 10, 0xfc);  \n\tipu_dc_map_config(priv, IPU_DC_MAP_RGB565, 2, 15, 0xf8);  \n\n\t \n\tipu_dc_map_clear(priv, IPU_DC_MAP_GBR24);\n\tipu_dc_map_config(priv, IPU_DC_MAP_GBR24, 2, 15, 0xff);  \n\tipu_dc_map_config(priv, IPU_DC_MAP_GBR24, 1, 7, 0xff);  \n\tipu_dc_map_config(priv, IPU_DC_MAP_GBR24, 0, 23, 0xff);  \n\n\t \n\tipu_dc_map_clear(priv, IPU_DC_MAP_BGR666);\n\tipu_dc_map_config(priv, IPU_DC_MAP_BGR666, 0, 5, 0xfc);  \n\tipu_dc_map_config(priv, IPU_DC_MAP_BGR666, 1, 11, 0xfc);  \n\tipu_dc_map_config(priv, IPU_DC_MAP_BGR666, 2, 17, 0xfc);  \n\n\t \n\tipu_dc_map_clear(priv, IPU_DC_MAP_LVDS666);\n\tipu_dc_map_config(priv, IPU_DC_MAP_LVDS666, 0, 5, 0xfc);  \n\tipu_dc_map_config(priv, IPU_DC_MAP_LVDS666, 1, 13, 0xfc);  \n\tipu_dc_map_config(priv, IPU_DC_MAP_LVDS666, 2, 21, 0xfc);  \n\n\t \n\tipu_dc_map_clear(priv, IPU_DC_MAP_BGR24);\n\tipu_dc_map_config(priv, IPU_DC_MAP_BGR24, 2, 7, 0xff);  \n\tipu_dc_map_config(priv, IPU_DC_MAP_BGR24, 1, 15, 0xff);  \n\tipu_dc_map_config(priv, IPU_DC_MAP_BGR24, 0, 23, 0xff);  \n\n\treturn 0;\n}\n\nvoid ipu_dc_exit(struct ipu_soc *ipu)\n{\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}