{
  "module_name": "ipu-smfc.c",
  "hash_id": "b37bb553848ff699de882ea7fd536d62219597277bbe83147995226b5aebffac",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/ipu-v3/ipu-smfc.c",
  "human_readable_source": "\n \n#include <linux/export.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/io.h>\n#include <linux/errno.h>\n#include <linux/spinlock.h>\n#include <linux/delay.h>\n#include <linux/clk.h>\n#include <video/imx-ipu-v3.h>\n\n#include \"ipu-prv.h\"\n\nstruct ipu_smfc {\n\tstruct ipu_smfc_priv *priv;\n\tint chno;\n\tbool inuse;\n};\n\nstruct ipu_smfc_priv {\n\tvoid __iomem *base;\n\tspinlock_t lock;\n\tstruct ipu_soc *ipu;\n\tstruct ipu_smfc channel[4];\n\tint use_count;\n};\n\n \n#define SMFC_MAP\t0x0000\n#define SMFC_WMC\t0x0004\n#define SMFC_BS\t\t0x0008\n\nint ipu_smfc_set_burstsize(struct ipu_smfc *smfc, int burstsize)\n{\n\tstruct ipu_smfc_priv *priv = smfc->priv;\n\tunsigned long flags;\n\tu32 val, shift;\n\n\tspin_lock_irqsave(&priv->lock, flags);\n\n\tshift = smfc->chno * 4;\n\tval = readl(priv->base + SMFC_BS);\n\tval &= ~(0xf << shift);\n\tval |= burstsize << shift;\n\twritel(val, priv->base + SMFC_BS);\n\n\tspin_unlock_irqrestore(&priv->lock, flags);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(ipu_smfc_set_burstsize);\n\nint ipu_smfc_map_channel(struct ipu_smfc *smfc, int csi_id, int mipi_id)\n{\n\tstruct ipu_smfc_priv *priv = smfc->priv;\n\tunsigned long flags;\n\tu32 val, shift;\n\n\tspin_lock_irqsave(&priv->lock, flags);\n\n\tshift = smfc->chno * 3;\n\tval = readl(priv->base + SMFC_MAP);\n\tval &= ~(0x7 << shift);\n\tval |= ((csi_id << 2) | mipi_id) << shift;\n\twritel(val, priv->base + SMFC_MAP);\n\n\tspin_unlock_irqrestore(&priv->lock, flags);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(ipu_smfc_map_channel);\n\nint ipu_smfc_set_watermark(struct ipu_smfc *smfc, u32 set_level, u32 clr_level)\n{\n\tstruct ipu_smfc_priv *priv = smfc->priv;\n\tunsigned long flags;\n\tu32 val, shift;\n\n\tspin_lock_irqsave(&priv->lock, flags);\n\n\tshift = smfc->chno * 6 + (smfc->chno > 1 ? 4 : 0);\n\tval = readl(priv->base + SMFC_WMC);\n\tval &= ~(0x3f << shift);\n\tval |= ((clr_level << 3) | set_level) << shift;\n\twritel(val, priv->base + SMFC_WMC);\n\n\tspin_unlock_irqrestore(&priv->lock, flags);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(ipu_smfc_set_watermark);\n\nint ipu_smfc_enable(struct ipu_smfc *smfc)\n{\n\tstruct ipu_smfc_priv *priv = smfc->priv;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&priv->lock, flags);\n\n\tif (!priv->use_count)\n\t\tipu_module_enable(priv->ipu, IPU_CONF_SMFC_EN);\n\n\tpriv->use_count++;\n\n\tspin_unlock_irqrestore(&priv->lock, flags);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(ipu_smfc_enable);\n\nint ipu_smfc_disable(struct ipu_smfc *smfc)\n{\n\tstruct ipu_smfc_priv *priv = smfc->priv;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&priv->lock, flags);\n\n\tpriv->use_count--;\n\n\tif (!priv->use_count)\n\t\tipu_module_disable(priv->ipu, IPU_CONF_SMFC_EN);\n\n\tif (priv->use_count < 0)\n\t\tpriv->use_count = 0;\n\n\tspin_unlock_irqrestore(&priv->lock, flags);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(ipu_smfc_disable);\n\nstruct ipu_smfc *ipu_smfc_get(struct ipu_soc *ipu, unsigned int chno)\n{\n\tstruct ipu_smfc_priv *priv = ipu->smfc_priv;\n\tstruct ipu_smfc *smfc, *ret;\n\tunsigned long flags;\n\n\tif (chno >= 4)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tsmfc = &priv->channel[chno];\n\tret = smfc;\n\n\tspin_lock_irqsave(&priv->lock, flags);\n\n\tif (smfc->inuse) {\n\t\tret = ERR_PTR(-EBUSY);\n\t\tgoto unlock;\n\t}\n\n\tsmfc->inuse = true;\nunlock:\n\tspin_unlock_irqrestore(&priv->lock, flags);\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(ipu_smfc_get);\n\nvoid ipu_smfc_put(struct ipu_smfc *smfc)\n{\n\tstruct ipu_smfc_priv *priv = smfc->priv;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&priv->lock, flags);\n\tsmfc->inuse = false;\n\tspin_unlock_irqrestore(&priv->lock, flags);\n}\nEXPORT_SYMBOL_GPL(ipu_smfc_put);\n\nint ipu_smfc_init(struct ipu_soc *ipu, struct device *dev,\n\t\t  unsigned long base)\n{\n\tstruct ipu_smfc_priv *priv;\n\tint i;\n\n\tpriv = devm_kzalloc(dev, sizeof(*priv), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\n\tipu->smfc_priv = priv;\n\tspin_lock_init(&priv->lock);\n\tpriv->ipu = ipu;\n\n\tpriv->base = devm_ioremap(dev, base, PAGE_SIZE);\n\tif (!priv->base)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < 4; i++) {\n\t\tpriv->channel[i].priv = priv;\n\t\tpriv->channel[i].chno = i;\n\t}\n\n\tpr_debug(\"%s: ioremap 0x%08lx -> %p\\n\", __func__, base, priv->base);\n\n\treturn 0;\n}\n\nvoid ipu_smfc_exit(struct ipu_soc *ipu)\n{\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}