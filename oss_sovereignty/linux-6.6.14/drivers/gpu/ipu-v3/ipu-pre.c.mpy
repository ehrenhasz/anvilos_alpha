{
  "module_name": "ipu-pre.c",
  "hash_id": "78a4695ab26604d92782feb0db3a632492db1cde81ed9299f8d209e794507640",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/ipu-v3/ipu-pre.c",
  "human_readable_source": "\n \n\n#include <drm/drm_fourcc.h>\n#include <linux/clk.h>\n#include <linux/err.h>\n#include <linux/genalloc.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <video/imx-ipu-v3.h>\n\n#include \"ipu-prv.h\"\n\n#define IPU_PRE_MAX_WIDTH\t2048\n#define IPU_PRE_NUM_SCANLINES\t8\n\n#define IPU_PRE_CTRL\t\t\t\t\t0x000\n#define IPU_PRE_CTRL_SET\t\t\t\t0x004\n#define  IPU_PRE_CTRL_ENABLE\t\t\t\t(1 << 0)\n#define  IPU_PRE_CTRL_BLOCK_EN\t\t\t\t(1 << 1)\n#define  IPU_PRE_CTRL_BLOCK_16\t\t\t\t(1 << 2)\n#define  IPU_PRE_CTRL_SDW_UPDATE\t\t\t(1 << 4)\n#define  IPU_PRE_CTRL_VFLIP\t\t\t\t(1 << 5)\n#define  IPU_PRE_CTRL_SO\t\t\t\t(1 << 6)\n#define  IPU_PRE_CTRL_INTERLACED_FIELD\t\t\t(1 << 7)\n#define  IPU_PRE_CTRL_HANDSHAKE_EN\t\t\t(1 << 8)\n#define  IPU_PRE_CTRL_HANDSHAKE_LINE_NUM(v)\t\t((v & 0x3) << 9)\n#define  IPU_PRE_CTRL_HANDSHAKE_ABORT_SKIP_EN\t\t(1 << 11)\n#define  IPU_PRE_CTRL_EN_REPEAT\t\t\t\t(1 << 28)\n#define  IPU_PRE_CTRL_TPR_REST_SEL\t\t\t(1 << 29)\n#define  IPU_PRE_CTRL_CLKGATE\t\t\t\t(1 << 30)\n#define  IPU_PRE_CTRL_SFTRST\t\t\t\t(1 << 31)\n\n#define IPU_PRE_CUR_BUF\t\t\t\t\t0x030\n\n#define IPU_PRE_NEXT_BUF\t\t\t\t0x040\n\n#define IPU_PRE_TPR_CTRL\t\t\t\t0x070\n#define  IPU_PRE_TPR_CTRL_TILE_FORMAT(v)\t\t((v & 0xff) << 0)\n#define  IPU_PRE_TPR_CTRL_TILE_FORMAT_MASK\t\t0xff\n#define  IPU_PRE_TPR_CTRL_TILE_FORMAT_16_BIT\t\t(1 << 0)\n#define  IPU_PRE_TPR_CTRL_TILE_FORMAT_SPLIT_BUF\t\t(1 << 4)\n#define  IPU_PRE_TPR_CTRL_TILE_FORMAT_SINGLE_BUF\t(1 << 5)\n#define  IPU_PRE_TPR_CTRL_TILE_FORMAT_SUPER_TILED\t(1 << 6)\n\n#define IPU_PRE_PREFETCH_ENG_CTRL\t\t\t0x080\n#define  IPU_PRE_PREF_ENG_CTRL_PREFETCH_EN\t\t(1 << 0)\n#define  IPU_PRE_PREF_ENG_CTRL_RD_NUM_BYTES(v)\t\t((v & 0x7) << 1)\n#define  IPU_PRE_PREF_ENG_CTRL_INPUT_ACTIVE_BPP(v)\t((v & 0x3) << 4)\n#define  IPU_PRE_PREF_ENG_CTRL_INPUT_PIXEL_FORMAT(v)\t((v & 0x7) << 8)\n#define  IPU_PRE_PREF_ENG_CTRL_SHIFT_BYPASS\t\t(1 << 11)\n#define  IPU_PRE_PREF_ENG_CTRL_FIELD_INVERSE\t\t(1 << 12)\n#define  IPU_PRE_PREF_ENG_CTRL_PARTIAL_UV_SWAP\t\t(1 << 14)\n#define  IPU_PRE_PREF_ENG_CTRL_TPR_COOR_OFFSET_EN\t(1 << 15)\n\n#define IPU_PRE_PREFETCH_ENG_INPUT_SIZE\t\t\t0x0a0\n#define  IPU_PRE_PREFETCH_ENG_INPUT_SIZE_WIDTH(v)\t((v & 0xffff) << 0)\n#define  IPU_PRE_PREFETCH_ENG_INPUT_SIZE_HEIGHT(v)\t((v & 0xffff) << 16)\n\n#define IPU_PRE_PREFETCH_ENG_PITCH\t\t\t0x0d0\n#define  IPU_PRE_PREFETCH_ENG_PITCH_Y(v)\t\t((v & 0xffff) << 0)\n#define  IPU_PRE_PREFETCH_ENG_PITCH_UV(v)\t\t((v & 0xffff) << 16)\n\n#define IPU_PRE_STORE_ENG_CTRL\t\t\t\t0x110\n#define  IPU_PRE_STORE_ENG_CTRL_STORE_EN\t\t(1 << 0)\n#define  IPU_PRE_STORE_ENG_CTRL_WR_NUM_BYTES(v)\t\t((v & 0x7) << 1)\n#define  IPU_PRE_STORE_ENG_CTRL_OUTPUT_ACTIVE_BPP(v)\t((v & 0x3) << 4)\n\n#define IPU_PRE_STORE_ENG_STATUS\t\t\t0x120\n#define  IPU_PRE_STORE_ENG_STATUS_STORE_BLOCK_X_MASK\t0xffff\n#define  IPU_PRE_STORE_ENG_STATUS_STORE_BLOCK_X_SHIFT\t0\n#define  IPU_PRE_STORE_ENG_STATUS_STORE_BLOCK_Y_MASK\t0x3fff\n#define  IPU_PRE_STORE_ENG_STATUS_STORE_BLOCK_Y_SHIFT\t16\n#define  IPU_PRE_STORE_ENG_STATUS_STORE_FIFO_FULL\t(1 << 30)\n#define  IPU_PRE_STORE_ENG_STATUS_STORE_FIELD\t\t(1 << 31)\n\n#define IPU_PRE_STORE_ENG_SIZE\t\t\t\t0x130\n#define  IPU_PRE_STORE_ENG_SIZE_INPUT_WIDTH(v)\t\t((v & 0xffff) << 0)\n#define  IPU_PRE_STORE_ENG_SIZE_INPUT_HEIGHT(v)\t\t((v & 0xffff) << 16)\n\n#define IPU_PRE_STORE_ENG_PITCH\t\t\t\t0x140\n#define  IPU_PRE_STORE_ENG_PITCH_OUT_PITCH(v)\t\t((v & 0xffff) << 0)\n\n#define IPU_PRE_STORE_ENG_ADDR\t\t\t\t0x150\n\nstruct ipu_pre {\n\tstruct list_head\tlist;\n\tstruct device\t\t*dev;\n\n\tvoid __iomem\t\t*regs;\n\tstruct clk\t\t*clk_axi;\n\tstruct gen_pool\t\t*iram;\n\n\tdma_addr_t\t\tbuffer_paddr;\n\tvoid\t\t\t*buffer_virt;\n\tbool\t\t\tin_use;\n\tunsigned int\t\tsafe_window_end;\n\tunsigned int\t\tlast_bufaddr;\n};\n\nstatic DEFINE_MUTEX(ipu_pre_list_mutex);\nstatic LIST_HEAD(ipu_pre_list);\nstatic int available_pres;\n\nint ipu_pre_get_available_count(void)\n{\n\treturn available_pres;\n}\n\nstruct ipu_pre *\nipu_pre_lookup_by_phandle(struct device *dev, const char *name, int index)\n{\n\tstruct device_node *pre_node = of_parse_phandle(dev->of_node,\n\t\t\t\t\t\t\tname, index);\n\tstruct ipu_pre *pre;\n\n\tmutex_lock(&ipu_pre_list_mutex);\n\tlist_for_each_entry(pre, &ipu_pre_list, list) {\n\t\tif (pre_node == pre->dev->of_node) {\n\t\t\tmutex_unlock(&ipu_pre_list_mutex);\n\t\t\tdevice_link_add(dev, pre->dev,\n\t\t\t\t\tDL_FLAG_AUTOREMOVE_CONSUMER);\n\t\t\tof_node_put(pre_node);\n\t\t\treturn pre;\n\t\t}\n\t}\n\tmutex_unlock(&ipu_pre_list_mutex);\n\n\tof_node_put(pre_node);\n\n\treturn NULL;\n}\n\nint ipu_pre_get(struct ipu_pre *pre)\n{\n\tu32 val;\n\n\tif (pre->in_use)\n\t\treturn -EBUSY;\n\n\t \n\twritel(0, pre->regs + IPU_PRE_CTRL);\n\n\t \n\tval = IPU_PRE_CTRL_HANDSHAKE_ABORT_SKIP_EN |\n\t      IPU_PRE_CTRL_HANDSHAKE_EN |\n\t      IPU_PRE_CTRL_TPR_REST_SEL |\n\t      IPU_PRE_CTRL_SDW_UPDATE;\n\twritel(val, pre->regs + IPU_PRE_CTRL);\n\n\tpre->in_use = true;\n\treturn 0;\n}\n\nvoid ipu_pre_put(struct ipu_pre *pre)\n{\n\twritel(IPU_PRE_CTRL_SFTRST, pre->regs + IPU_PRE_CTRL);\n\n\tpre->in_use = false;\n}\n\nvoid ipu_pre_configure(struct ipu_pre *pre, unsigned int width,\n\t\t       unsigned int height, unsigned int stride, u32 format,\n\t\t       uint64_t modifier, unsigned int bufaddr)\n{\n\tconst struct drm_format_info *info = drm_format_info(format);\n\tu32 active_bpp = info->cpp[0] >> 1;\n\tu32 val;\n\n\t \n\tif (modifier == DRM_FORMAT_MOD_LINEAR)\n\t\tpre->safe_window_end = height - 2;\n\telse\n\t\tpre->safe_window_end = DIV_ROUND_UP(height, 4) - 1;\n\n\twritel(bufaddr, pre->regs + IPU_PRE_CUR_BUF);\n\twritel(bufaddr, pre->regs + IPU_PRE_NEXT_BUF);\n\tpre->last_bufaddr = bufaddr;\n\n\tval = IPU_PRE_PREF_ENG_CTRL_INPUT_PIXEL_FORMAT(0) |\n\t      IPU_PRE_PREF_ENG_CTRL_INPUT_ACTIVE_BPP(active_bpp) |\n\t      IPU_PRE_PREF_ENG_CTRL_RD_NUM_BYTES(4) |\n\t      IPU_PRE_PREF_ENG_CTRL_SHIFT_BYPASS |\n\t      IPU_PRE_PREF_ENG_CTRL_PREFETCH_EN;\n\twritel(val, pre->regs + IPU_PRE_PREFETCH_ENG_CTRL);\n\n\tval = IPU_PRE_PREFETCH_ENG_INPUT_SIZE_WIDTH(width) |\n\t      IPU_PRE_PREFETCH_ENG_INPUT_SIZE_HEIGHT(height);\n\twritel(val, pre->regs + IPU_PRE_PREFETCH_ENG_INPUT_SIZE);\n\n\tval = IPU_PRE_PREFETCH_ENG_PITCH_Y(stride);\n\twritel(val, pre->regs + IPU_PRE_PREFETCH_ENG_PITCH);\n\n\tval = IPU_PRE_STORE_ENG_CTRL_OUTPUT_ACTIVE_BPP(active_bpp) |\n\t      IPU_PRE_STORE_ENG_CTRL_WR_NUM_BYTES(4) |\n\t      IPU_PRE_STORE_ENG_CTRL_STORE_EN;\n\twritel(val, pre->regs + IPU_PRE_STORE_ENG_CTRL);\n\n\tval = IPU_PRE_STORE_ENG_SIZE_INPUT_WIDTH(width) |\n\t      IPU_PRE_STORE_ENG_SIZE_INPUT_HEIGHT(height);\n\twritel(val, pre->regs + IPU_PRE_STORE_ENG_SIZE);\n\n\tval = IPU_PRE_STORE_ENG_PITCH_OUT_PITCH(stride);\n\twritel(val, pre->regs + IPU_PRE_STORE_ENG_PITCH);\n\n\twritel(pre->buffer_paddr, pre->regs + IPU_PRE_STORE_ENG_ADDR);\n\n\tval = readl(pre->regs + IPU_PRE_TPR_CTRL);\n\tval &= ~IPU_PRE_TPR_CTRL_TILE_FORMAT_MASK;\n\tif (modifier != DRM_FORMAT_MOD_LINEAR) {\n\t\t \n\t\tval |= IPU_PRE_TPR_CTRL_TILE_FORMAT_SINGLE_BUF;\n\t\tif (modifier == DRM_FORMAT_MOD_VIVANTE_SUPER_TILED)\n\t\t\tval |= IPU_PRE_TPR_CTRL_TILE_FORMAT_SUPER_TILED;\n\t\tif (info->cpp[0] == 2)\n\t\t\tval |= IPU_PRE_TPR_CTRL_TILE_FORMAT_16_BIT;\n\t}\n\twritel(val, pre->regs + IPU_PRE_TPR_CTRL);\n\n\tval = readl(pre->regs + IPU_PRE_CTRL);\n\tval |= IPU_PRE_CTRL_EN_REPEAT | IPU_PRE_CTRL_ENABLE |\n\t       IPU_PRE_CTRL_SDW_UPDATE;\n\tif (modifier == DRM_FORMAT_MOD_LINEAR)\n\t\tval &= ~IPU_PRE_CTRL_BLOCK_EN;\n\telse\n\t\tval |= IPU_PRE_CTRL_BLOCK_EN;\n\twritel(val, pre->regs + IPU_PRE_CTRL);\n}\n\nvoid ipu_pre_update(struct ipu_pre *pre, unsigned int bufaddr)\n{\n\tunsigned long timeout = jiffies + msecs_to_jiffies(5);\n\tunsigned short current_yblock;\n\tu32 val;\n\n\tif (bufaddr == pre->last_bufaddr)\n\t\treturn;\n\n\twritel(bufaddr, pre->regs + IPU_PRE_NEXT_BUF);\n\tpre->last_bufaddr = bufaddr;\n\n\tdo {\n\t\tif (time_after(jiffies, timeout)) {\n\t\t\tdev_warn(pre->dev, \"timeout waiting for PRE safe window\\n\");\n\t\t\treturn;\n\t\t}\n\n\t\tval = readl(pre->regs + IPU_PRE_STORE_ENG_STATUS);\n\t\tcurrent_yblock =\n\t\t\t(val >> IPU_PRE_STORE_ENG_STATUS_STORE_BLOCK_Y_SHIFT) &\n\t\t\tIPU_PRE_STORE_ENG_STATUS_STORE_BLOCK_Y_MASK;\n\t} while (current_yblock == 0 || current_yblock >= pre->safe_window_end);\n\n\twritel(IPU_PRE_CTRL_SDW_UPDATE, pre->regs + IPU_PRE_CTRL_SET);\n}\n\nbool ipu_pre_update_pending(struct ipu_pre *pre)\n{\n\treturn !!(readl_relaxed(pre->regs + IPU_PRE_CTRL) &\n\t\t  IPU_PRE_CTRL_SDW_UPDATE);\n}\n\nu32 ipu_pre_get_baddr(struct ipu_pre *pre)\n{\n\treturn (u32)pre->buffer_paddr;\n}\n\nstatic int ipu_pre_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct ipu_pre *pre;\n\n\tpre = devm_kzalloc(dev, sizeof(*pre), GFP_KERNEL);\n\tif (!pre)\n\t\treturn -ENOMEM;\n\n\tpre->regs = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(pre->regs))\n\t\treturn PTR_ERR(pre->regs);\n\n\tpre->clk_axi = devm_clk_get(dev, \"axi\");\n\tif (IS_ERR(pre->clk_axi))\n\t\treturn PTR_ERR(pre->clk_axi);\n\n\tpre->iram = of_gen_pool_get(dev->of_node, \"fsl,iram\", 0);\n\tif (!pre->iram)\n\t\treturn -EPROBE_DEFER;\n\n\t \n\tpre->buffer_virt = gen_pool_dma_alloc(pre->iram, IPU_PRE_MAX_WIDTH *\n\t\t\t\t\t      IPU_PRE_NUM_SCANLINES * 4,\n\t\t\t\t\t      &pre->buffer_paddr);\n\tif (!pre->buffer_virt)\n\t\treturn -ENOMEM;\n\n\tclk_prepare_enable(pre->clk_axi);\n\n\tpre->dev = dev;\n\tplatform_set_drvdata(pdev, pre);\n\tmutex_lock(&ipu_pre_list_mutex);\n\tlist_add(&pre->list, &ipu_pre_list);\n\tavailable_pres++;\n\tmutex_unlock(&ipu_pre_list_mutex);\n\n\treturn 0;\n}\n\nstatic int ipu_pre_remove(struct platform_device *pdev)\n{\n\tstruct ipu_pre *pre = platform_get_drvdata(pdev);\n\n\tmutex_lock(&ipu_pre_list_mutex);\n\tlist_del(&pre->list);\n\tavailable_pres--;\n\tmutex_unlock(&ipu_pre_list_mutex);\n\n\tclk_disable_unprepare(pre->clk_axi);\n\n\tif (pre->buffer_virt)\n\t\tgen_pool_free(pre->iram, (unsigned long)pre->buffer_virt,\n\t\t\t      IPU_PRE_MAX_WIDTH * IPU_PRE_NUM_SCANLINES * 4);\n\treturn 0;\n}\n\nstatic const struct of_device_id ipu_pre_dt_ids[] = {\n\t{ .compatible = \"fsl,imx6qp-pre\", },\n\t{   },\n};\n\nstruct platform_driver ipu_pre_drv = {\n\t.probe\t\t= ipu_pre_probe,\n\t.remove\t\t= ipu_pre_remove,\n\t.driver\t\t= {\n\t\t.name\t= \"imx-ipu-pre\",\n\t\t.of_match_table = ipu_pre_dt_ids,\n\t},\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}