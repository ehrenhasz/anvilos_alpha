{
  "module_name": "ipu-csi.c",
  "hash_id": "536fe85ad8a316c47fefb2f68eefdb29d376638e963689a5ca224e907a6064b9",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/ipu-v3/ipu-csi.c",
  "human_readable_source": "\n \n#include <linux/export.h>\n#include <linux/module.h>\n#include <linux/types.h>\n#include <linux/errno.h>\n#include <linux/delay.h>\n#include <linux/io.h>\n#include <linux/err.h>\n#include <linux/platform_device.h>\n#include <linux/videodev2.h>\n#include <uapi/linux/v4l2-mediabus.h>\n#include <linux/clk.h>\n#include <linux/clk-provider.h>\n#include <linux/clkdev.h>\n\n#include \"ipu-prv.h\"\n\nstruct ipu_csi {\n\tvoid __iomem *base;\n\tint id;\n\tu32 module;\n\tstruct clk *clk_ipu;\t \n\tspinlock_t lock;\n\tbool inuse;\n\tstruct ipu_soc *ipu;\n};\n\n \n#define CSI_SENS_CONF\t\t0x0000\n#define CSI_SENS_FRM_SIZE\t0x0004\n#define CSI_ACT_FRM_SIZE\t0x0008\n#define CSI_OUT_FRM_CTRL\t0x000c\n#define CSI_TST_CTRL\t\t0x0010\n#define CSI_CCIR_CODE_1\t\t0x0014\n#define CSI_CCIR_CODE_2\t\t0x0018\n#define CSI_CCIR_CODE_3\t\t0x001c\n#define CSI_MIPI_DI\t\t0x0020\n#define CSI_SKIP\t\t0x0024\n#define CSI_CPD_CTRL\t\t0x0028\n#define CSI_CPD_RC(n)\t\t(0x002c + ((n)*4))\n#define CSI_CPD_RS(n)\t\t(0x004c + ((n)*4))\n#define CSI_CPD_GRC(n)\t\t(0x005c + ((n)*4))\n#define CSI_CPD_GRS(n)\t\t(0x007c + ((n)*4))\n#define CSI_CPD_GBC(n)\t\t(0x008c + ((n)*4))\n#define CSI_CPD_GBS(n)\t\t(0x00Ac + ((n)*4))\n#define CSI_CPD_BC(n)\t\t(0x00Bc + ((n)*4))\n#define CSI_CPD_BS(n)\t\t(0x00Dc + ((n)*4))\n#define CSI_CPD_OFFSET1\t\t0x00ec\n#define CSI_CPD_OFFSET2\t\t0x00f0\n\n \n#define CSI_SENS_CONF_DATA_FMT_SHIFT\t\t8\n#define CSI_SENS_CONF_DATA_FMT_MASK\t\t0x00000700\n#define CSI_SENS_CONF_DATA_FMT_RGB_YUV444\t0L\n#define CSI_SENS_CONF_DATA_FMT_YUV422_YUYV\t1L\n#define CSI_SENS_CONF_DATA_FMT_YUV422_UYVY\t2L\n#define CSI_SENS_CONF_DATA_FMT_BAYER\t\t3L\n#define CSI_SENS_CONF_DATA_FMT_RGB565\t\t4L\n#define CSI_SENS_CONF_DATA_FMT_RGB555\t\t5L\n#define CSI_SENS_CONF_DATA_FMT_RGB444\t\t6L\n#define CSI_SENS_CONF_DATA_FMT_JPEG\t\t7L\n\n#define CSI_SENS_CONF_VSYNC_POL_SHIFT\t\t0\n#define CSI_SENS_CONF_HSYNC_POL_SHIFT\t\t1\n#define CSI_SENS_CONF_DATA_POL_SHIFT\t\t2\n#define CSI_SENS_CONF_PIX_CLK_POL_SHIFT\t\t3\n#define CSI_SENS_CONF_SENS_PRTCL_MASK\t\t0x00000070\n#define CSI_SENS_CONF_SENS_PRTCL_SHIFT\t\t4\n#define CSI_SENS_CONF_PACK_TIGHT_SHIFT\t\t7\n#define CSI_SENS_CONF_DATA_WIDTH_SHIFT\t\t11\n#define CSI_SENS_CONF_EXT_VSYNC_SHIFT\t\t15\n#define CSI_SENS_CONF_DIVRATIO_SHIFT\t\t16\n\n#define CSI_SENS_CONF_DIVRATIO_MASK\t\t0x00ff0000\n#define CSI_SENS_CONF_DATA_DEST_SHIFT\t\t24\n#define CSI_SENS_CONF_DATA_DEST_MASK\t\t0x07000000\n#define CSI_SENS_CONF_JPEG8_EN_SHIFT\t\t27\n#define CSI_SENS_CONF_JPEG_EN_SHIFT\t\t28\n#define CSI_SENS_CONF_FORCE_EOF_SHIFT\t\t29\n#define CSI_SENS_CONF_DATA_EN_POL_SHIFT\t\t31\n\n#define CSI_DATA_DEST_IC\t\t\t2\n#define CSI_DATA_DEST_IDMAC\t\t\t4\n\n#define CSI_CCIR_ERR_DET_EN\t\t\t0x01000000\n#define CSI_HORI_DOWNSIZE_EN\t\t\t0x80000000\n#define CSI_VERT_DOWNSIZE_EN\t\t\t0x40000000\n#define CSI_TEST_GEN_MODE_EN\t\t\t0x01000000\n\n#define CSI_HSC_MASK\t\t\t\t0x1fff0000\n#define CSI_HSC_SHIFT\t\t\t\t16\n#define CSI_VSC_MASK\t\t\t\t0x00000fff\n#define CSI_VSC_SHIFT\t\t\t\t0\n\n#define CSI_TEST_GEN_R_MASK\t\t\t0x000000ff\n#define CSI_TEST_GEN_R_SHIFT\t\t\t0\n#define CSI_TEST_GEN_G_MASK\t\t\t0x0000ff00\n#define CSI_TEST_GEN_G_SHIFT\t\t\t8\n#define CSI_TEST_GEN_B_MASK\t\t\t0x00ff0000\n#define CSI_TEST_GEN_B_SHIFT\t\t\t16\n\n#define CSI_MAX_RATIO_SKIP_SMFC_MASK\t\t0x00000007\n#define CSI_MAX_RATIO_SKIP_SMFC_SHIFT\t\t0\n#define CSI_SKIP_SMFC_MASK\t\t\t0x000000f8\n#define CSI_SKIP_SMFC_SHIFT\t\t\t3\n#define CSI_ID_2_SKIP_MASK\t\t\t0x00000300\n#define CSI_ID_2_SKIP_SHIFT\t\t\t8\n\n#define CSI_COLOR_FIRST_ROW_MASK\t\t0x00000002\n#define CSI_COLOR_FIRST_COMP_MASK\t\t0x00000001\n\n \n#define MIPI_DT_YUV420\t\t0x18  \n#define MIPI_DT_YUV420_LEGACY\t0x1a  \n#define MIPI_DT_YUV422\t\t0x1e  \n#define MIPI_DT_RGB444\t\t0x20\n#define MIPI_DT_RGB555\t\t0x21\n#define MIPI_DT_RGB565\t\t0x22\n#define MIPI_DT_RGB666\t\t0x23\n#define MIPI_DT_RGB888\t\t0x24\n#define MIPI_DT_RAW6\t\t0x28\n#define MIPI_DT_RAW7\t\t0x29\n#define MIPI_DT_RAW8\t\t0x2a\n#define MIPI_DT_RAW10\t\t0x2b\n#define MIPI_DT_RAW12\t\t0x2c\n#define MIPI_DT_RAW14\t\t0x2d\n\n \nstruct ipu_csi_bus_config {\n\tunsigned data_width:4;\n\tunsigned clk_mode:3;\n\tunsigned ext_vsync:1;\n\tunsigned vsync_pol:1;\n\tunsigned hsync_pol:1;\n\tunsigned pixclk_pol:1;\n\tunsigned data_pol:1;\n\tunsigned sens_clksrc:1;\n\tunsigned pack_tight:1;\n\tunsigned force_eof:1;\n\tunsigned data_en_pol:1;\n\n\tunsigned data_fmt;\n\tunsigned mipi_dt;\n};\n\n \nenum ipu_csi_data_width {\n\tIPU_CSI_DATA_WIDTH_4   = 0,\n\tIPU_CSI_DATA_WIDTH_8   = 1,\n\tIPU_CSI_DATA_WIDTH_10  = 3,\n\tIPU_CSI_DATA_WIDTH_12  = 5,\n\tIPU_CSI_DATA_WIDTH_16  = 9,\n};\n\n \nenum ipu_csi_clk_mode {\n\tIPU_CSI_CLK_MODE_GATED_CLK,\n\tIPU_CSI_CLK_MODE_NONGATED_CLK,\n\tIPU_CSI_CLK_MODE_CCIR656_PROGRESSIVE,\n\tIPU_CSI_CLK_MODE_CCIR656_INTERLACED,\n\tIPU_CSI_CLK_MODE_CCIR1120_PROGRESSIVE_DDR,\n\tIPU_CSI_CLK_MODE_CCIR1120_PROGRESSIVE_SDR,\n\tIPU_CSI_CLK_MODE_CCIR1120_INTERLACED_DDR,\n\tIPU_CSI_CLK_MODE_CCIR1120_INTERLACED_SDR,\n};\n\nstatic inline u32 ipu_csi_read(struct ipu_csi *csi, unsigned offset)\n{\n\treturn readl(csi->base + offset);\n}\n\nstatic inline void ipu_csi_write(struct ipu_csi *csi, u32 value,\n\t\t\t\t unsigned offset)\n{\n\twritel(value, csi->base + offset);\n}\n\n \nstatic int ipu_csi_set_testgen_mclk(struct ipu_csi *csi, u32 pixel_clk,\n\t\t\t\t\tu32 ipu_clk)\n{\n\tu32 temp;\n\tint div_ratio;\n\n\tdiv_ratio = (ipu_clk / pixel_clk) - 1;\n\n\tif (div_ratio > 0xFF || div_ratio < 0) {\n\t\tdev_err(csi->ipu->dev,\n\t\t\t\"value of pixel_clk extends normal range\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\ttemp = ipu_csi_read(csi, CSI_SENS_CONF);\n\ttemp &= ~CSI_SENS_CONF_DIVRATIO_MASK;\n\tipu_csi_write(csi, temp | (div_ratio << CSI_SENS_CONF_DIVRATIO_SHIFT),\n\t\t\t  CSI_SENS_CONF);\n\n\treturn 0;\n}\n\n \nstatic int mbus_code_to_bus_cfg(struct ipu_csi_bus_config *cfg, u32 mbus_code,\n\t\t\t\tenum v4l2_mbus_type mbus_type)\n{\n\tswitch (mbus_code) {\n\tcase MEDIA_BUS_FMT_BGR565_2X8_BE:\n\tcase MEDIA_BUS_FMT_BGR565_2X8_LE:\n\tcase MEDIA_BUS_FMT_RGB565_2X8_BE:\n\tcase MEDIA_BUS_FMT_RGB565_2X8_LE:\n\t\tif (mbus_type == V4L2_MBUS_CSI2_DPHY)\n\t\t\tcfg->data_fmt = CSI_SENS_CONF_DATA_FMT_RGB565;\n\t\telse\n\t\t\tcfg->data_fmt = CSI_SENS_CONF_DATA_FMT_BAYER;\n\t\tcfg->mipi_dt = MIPI_DT_RGB565;\n\t\tcfg->data_width = IPU_CSI_DATA_WIDTH_8;\n\t\tbreak;\n\tcase MEDIA_BUS_FMT_RGB444_2X8_PADHI_BE:\n\tcase MEDIA_BUS_FMT_RGB444_2X8_PADHI_LE:\n\t\tcfg->data_fmt = CSI_SENS_CONF_DATA_FMT_RGB444;\n\t\tcfg->mipi_dt = MIPI_DT_RGB444;\n\t\tcfg->data_width = IPU_CSI_DATA_WIDTH_8;\n\t\tbreak;\n\tcase MEDIA_BUS_FMT_RGB555_2X8_PADHI_BE:\n\tcase MEDIA_BUS_FMT_RGB555_2X8_PADHI_LE:\n\t\tcfg->data_fmt = CSI_SENS_CONF_DATA_FMT_RGB555;\n\t\tcfg->mipi_dt = MIPI_DT_RGB555;\n\t\tcfg->data_width = IPU_CSI_DATA_WIDTH_8;\n\t\tbreak;\n\tcase MEDIA_BUS_FMT_RGB888_1X24:\n\tcase MEDIA_BUS_FMT_BGR888_1X24:\n\t\tcfg->data_fmt = CSI_SENS_CONF_DATA_FMT_RGB_YUV444;\n\t\tcfg->mipi_dt = MIPI_DT_RGB888;\n\t\tcfg->data_width = IPU_CSI_DATA_WIDTH_8;\n\t\tbreak;\n\tcase MEDIA_BUS_FMT_UYVY8_2X8:\n\t\tcfg->data_fmt = CSI_SENS_CONF_DATA_FMT_YUV422_UYVY;\n\t\tcfg->mipi_dt = MIPI_DT_YUV422;\n\t\tcfg->data_width = IPU_CSI_DATA_WIDTH_8;\n\t\tbreak;\n\tcase MEDIA_BUS_FMT_YUYV8_2X8:\n\t\tcfg->data_fmt = CSI_SENS_CONF_DATA_FMT_YUV422_YUYV;\n\t\tcfg->mipi_dt = MIPI_DT_YUV422;\n\t\tcfg->data_width = IPU_CSI_DATA_WIDTH_8;\n\t\tbreak;\n\tcase MEDIA_BUS_FMT_UYVY8_1X16:\n\t\tif (mbus_type == V4L2_MBUS_BT656) {\n\t\t\tcfg->data_fmt = CSI_SENS_CONF_DATA_FMT_YUV422_UYVY;\n\t\t\tcfg->data_width = IPU_CSI_DATA_WIDTH_8;\n\t\t} else {\n\t\t\tcfg->data_fmt = CSI_SENS_CONF_DATA_FMT_BAYER;\n\t\t\tcfg->data_width = IPU_CSI_DATA_WIDTH_16;\n\t\t}\n\t\tcfg->mipi_dt = MIPI_DT_YUV422;\n\t\tbreak;\n\tcase MEDIA_BUS_FMT_YUYV8_1X16:\n\t\tif (mbus_type == V4L2_MBUS_BT656) {\n\t\t\tcfg->data_fmt = CSI_SENS_CONF_DATA_FMT_YUV422_YUYV;\n\t\t\tcfg->data_width = IPU_CSI_DATA_WIDTH_8;\n\t\t} else {\n\t\t\tcfg->data_fmt = CSI_SENS_CONF_DATA_FMT_BAYER;\n\t\t\tcfg->data_width = IPU_CSI_DATA_WIDTH_16;\n\t\t}\n\t\tcfg->mipi_dt = MIPI_DT_YUV422;\n\t\tbreak;\n\tcase MEDIA_BUS_FMT_SBGGR8_1X8:\n\tcase MEDIA_BUS_FMT_SGBRG8_1X8:\n\tcase MEDIA_BUS_FMT_SGRBG8_1X8:\n\tcase MEDIA_BUS_FMT_SRGGB8_1X8:\n\tcase MEDIA_BUS_FMT_Y8_1X8:\n\t\tcfg->data_fmt = CSI_SENS_CONF_DATA_FMT_BAYER;\n\t\tcfg->mipi_dt = MIPI_DT_RAW8;\n\t\tcfg->data_width = IPU_CSI_DATA_WIDTH_8;\n\t\tbreak;\n\tcase MEDIA_BUS_FMT_SBGGR10_DPCM8_1X8:\n\tcase MEDIA_BUS_FMT_SGBRG10_DPCM8_1X8:\n\tcase MEDIA_BUS_FMT_SGRBG10_DPCM8_1X8:\n\tcase MEDIA_BUS_FMT_SRGGB10_DPCM8_1X8:\n\tcase MEDIA_BUS_FMT_SBGGR10_2X8_PADHI_BE:\n\tcase MEDIA_BUS_FMT_SBGGR10_2X8_PADHI_LE:\n\tcase MEDIA_BUS_FMT_SBGGR10_2X8_PADLO_BE:\n\tcase MEDIA_BUS_FMT_SBGGR10_2X8_PADLO_LE:\n\t\tcfg->data_fmt = CSI_SENS_CONF_DATA_FMT_BAYER;\n\t\tcfg->mipi_dt = MIPI_DT_RAW10;\n\t\tcfg->data_width = IPU_CSI_DATA_WIDTH_8;\n\t\tbreak;\n\tcase MEDIA_BUS_FMT_SBGGR10_1X10:\n\tcase MEDIA_BUS_FMT_SGBRG10_1X10:\n\tcase MEDIA_BUS_FMT_SGRBG10_1X10:\n\tcase MEDIA_BUS_FMT_SRGGB10_1X10:\n\tcase MEDIA_BUS_FMT_Y10_1X10:\n\t\tcfg->data_fmt = CSI_SENS_CONF_DATA_FMT_BAYER;\n\t\tcfg->mipi_dt = MIPI_DT_RAW10;\n\t\tcfg->data_width = IPU_CSI_DATA_WIDTH_10;\n\t\tbreak;\n\tcase MEDIA_BUS_FMT_SBGGR12_1X12:\n\tcase MEDIA_BUS_FMT_SGBRG12_1X12:\n\tcase MEDIA_BUS_FMT_SGRBG12_1X12:\n\tcase MEDIA_BUS_FMT_SRGGB12_1X12:\n\tcase MEDIA_BUS_FMT_Y12_1X12:\n\t\tcfg->data_fmt = CSI_SENS_CONF_DATA_FMT_BAYER;\n\t\tcfg->mipi_dt = MIPI_DT_RAW12;\n\t\tcfg->data_width = IPU_CSI_DATA_WIDTH_12;\n\t\tbreak;\n\tcase MEDIA_BUS_FMT_JPEG_1X8:\n\t\t \n\t\tcfg->data_fmt = CSI_SENS_CONF_DATA_FMT_JPEG;\n\t\tcfg->mipi_dt = MIPI_DT_RAW8;\n\t\tcfg->data_width = IPU_CSI_DATA_WIDTH_8;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\n \nstatic inline enum v4l2_field\nipu_csi_translate_field(enum v4l2_field field, v4l2_std_id std)\n{\n\treturn (field != V4L2_FIELD_ALTERNATE) ? field :\n\t\t((std & V4L2_STD_525_60) ?\n\t\t V4L2_FIELD_SEQ_BT : V4L2_FIELD_SEQ_TB);\n}\n\n \nstatic int fill_csi_bus_cfg(struct ipu_csi_bus_config *csicfg,\n\t\t\t    const struct v4l2_mbus_config *mbus_cfg,\n\t\t\t    const struct v4l2_mbus_framefmt *mbus_fmt)\n{\n\tint ret, is_bt1120;\n\n\tmemset(csicfg, 0, sizeof(*csicfg));\n\n\tret = mbus_code_to_bus_cfg(csicfg, mbus_fmt->code, mbus_cfg->type);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tswitch (mbus_cfg->type) {\n\tcase V4L2_MBUS_PARALLEL:\n\t\tcsicfg->ext_vsync = 1;\n\t\tcsicfg->vsync_pol = (mbus_cfg->bus.parallel.flags &\n\t\t\t\t     V4L2_MBUS_VSYNC_ACTIVE_LOW) ? 1 : 0;\n\t\tcsicfg->hsync_pol = (mbus_cfg->bus.parallel.flags &\n\t\t\t\t     V4L2_MBUS_HSYNC_ACTIVE_LOW) ? 1 : 0;\n\t\tcsicfg->pixclk_pol = (mbus_cfg->bus.parallel.flags &\n\t\t\t\t      V4L2_MBUS_PCLK_SAMPLE_FALLING) ? 1 : 0;\n\t\tcsicfg->clk_mode = IPU_CSI_CLK_MODE_GATED_CLK;\n\t\tbreak;\n\tcase V4L2_MBUS_BT656:\n\t\tcsicfg->ext_vsync = 0;\n\t\t \n\t\tis_bt1120 = mbus_fmt->code == MEDIA_BUS_FMT_UYVY8_1X16 ||\n\t\t\t    mbus_fmt->code == MEDIA_BUS_FMT_YUYV8_1X16;\n\t\tif (V4L2_FIELD_HAS_BOTH(mbus_fmt->field) ||\n\t\t    mbus_fmt->field == V4L2_FIELD_ALTERNATE)\n\t\t\tcsicfg->clk_mode = is_bt1120 ?\n\t\t\t\tIPU_CSI_CLK_MODE_CCIR1120_INTERLACED_SDR :\n\t\t\t\tIPU_CSI_CLK_MODE_CCIR656_INTERLACED;\n\t\telse\n\t\t\tcsicfg->clk_mode = is_bt1120 ?\n\t\t\t\tIPU_CSI_CLK_MODE_CCIR1120_PROGRESSIVE_SDR :\n\t\t\t\tIPU_CSI_CLK_MODE_CCIR656_PROGRESSIVE;\n\t\tbreak;\n\tcase V4L2_MBUS_CSI2_DPHY:\n\t\t \n\t\tcsicfg->clk_mode = IPU_CSI_CLK_MODE_NONGATED_CLK;\n\t\tbreak;\n\tdefault:\n\t\t \n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic int\nipu_csi_set_bt_interlaced_codes(struct ipu_csi *csi,\n\t\t\t\tconst struct v4l2_mbus_framefmt *infmt,\n\t\t\t\tconst struct v4l2_mbus_framefmt *outfmt,\n\t\t\t\tv4l2_std_id std)\n{\n\tenum v4l2_field infield, outfield;\n\tbool swap_fields;\n\n\t \n\tinfield = ipu_csi_translate_field(infmt->field, std);\n\toutfield = ipu_csi_translate_field(outfmt->field, std);\n\n\t \n\tswap_fields = (V4L2_FIELD_IS_SEQUENTIAL(infield) &&\n\t\t       V4L2_FIELD_IS_SEQUENTIAL(outfield) &&\n\t\t       infield != outfield);\n\n\tif (!swap_fields) {\n\t\t \n\t\tipu_csi_write(csi, 0x40596 | CSI_CCIR_ERR_DET_EN,\n\t\t\t      CSI_CCIR_CODE_1);\n\t\tipu_csi_write(csi, 0xD07DF, CSI_CCIR_CODE_2);\n\t} else {\n\t\tdev_dbg(csi->ipu->dev, \"capture field swap\\n\");\n\n\t\t \n\t\tipu_csi_write(csi, 0xD07DF | CSI_CCIR_ERR_DET_EN,\n\t\t\t      CSI_CCIR_CODE_1);\n\t\tipu_csi_write(csi, 0x40596, CSI_CCIR_CODE_2);\n\t}\n\n\tipu_csi_write(csi, 0xFF0000, CSI_CCIR_CODE_3);\n\n\treturn 0;\n}\n\n\nint ipu_csi_init_interface(struct ipu_csi *csi,\n\t\t\t   const struct v4l2_mbus_config *mbus_cfg,\n\t\t\t   const struct v4l2_mbus_framefmt *infmt,\n\t\t\t   const struct v4l2_mbus_framefmt *outfmt)\n{\n\tstruct ipu_csi_bus_config cfg;\n\tunsigned long flags;\n\tu32 width, height, data = 0;\n\tv4l2_std_id std;\n\tint ret;\n\n\tret = fill_csi_bus_cfg(&cfg, mbus_cfg, infmt);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\twidth = infmt->width;\n\theight = infmt->height;\n\tif (infmt->field == V4L2_FIELD_ALTERNATE)\n\t\theight *= 2;\n\n\t \n\tdata |= cfg.data_width << CSI_SENS_CONF_DATA_WIDTH_SHIFT |\n\t\tcfg.data_fmt << CSI_SENS_CONF_DATA_FMT_SHIFT |\n\t\tcfg.data_pol << CSI_SENS_CONF_DATA_POL_SHIFT |\n\t\tcfg.vsync_pol << CSI_SENS_CONF_VSYNC_POL_SHIFT |\n\t\tcfg.hsync_pol << CSI_SENS_CONF_HSYNC_POL_SHIFT |\n\t\tcfg.pixclk_pol << CSI_SENS_CONF_PIX_CLK_POL_SHIFT |\n\t\tcfg.ext_vsync << CSI_SENS_CONF_EXT_VSYNC_SHIFT |\n\t\tcfg.clk_mode << CSI_SENS_CONF_SENS_PRTCL_SHIFT |\n\t\tcfg.pack_tight << CSI_SENS_CONF_PACK_TIGHT_SHIFT |\n\t\tcfg.force_eof << CSI_SENS_CONF_FORCE_EOF_SHIFT |\n\t\tcfg.data_en_pol << CSI_SENS_CONF_DATA_EN_POL_SHIFT;\n\n\tspin_lock_irqsave(&csi->lock, flags);\n\n\tipu_csi_write(csi, data, CSI_SENS_CONF);\n\n\t \n\n\tswitch (cfg.clk_mode) {\n\tcase IPU_CSI_CLK_MODE_CCIR656_PROGRESSIVE:\n\t\tipu_csi_write(csi, 0x40030, CSI_CCIR_CODE_1);\n\t\tipu_csi_write(csi, 0xFF0000, CSI_CCIR_CODE_3);\n\t\tbreak;\n\tcase IPU_CSI_CLK_MODE_CCIR656_INTERLACED:\n\t\tif (width == 720 && height == 480) {\n\t\t\tstd = V4L2_STD_NTSC;\n\t\t\theight = 525;\n\t\t} else if (width == 720 && height == 576) {\n\t\t\tstd = V4L2_STD_PAL;\n\t\t\theight = 625;\n\t\t} else {\n\t\t\tdev_err(csi->ipu->dev,\n\t\t\t\t\"Unsupported interlaced video mode\\n\");\n\t\t\tret = -EINVAL;\n\t\t\tgoto out_unlock;\n\t\t}\n\n\t\tret = ipu_csi_set_bt_interlaced_codes(csi, infmt, outfmt, std);\n\t\tif (ret)\n\t\t\tgoto out_unlock;\n\t\tbreak;\n\tcase IPU_CSI_CLK_MODE_CCIR1120_PROGRESSIVE_DDR:\n\tcase IPU_CSI_CLK_MODE_CCIR1120_PROGRESSIVE_SDR:\n\tcase IPU_CSI_CLK_MODE_CCIR1120_INTERLACED_DDR:\n\tcase IPU_CSI_CLK_MODE_CCIR1120_INTERLACED_SDR:\n\t\tipu_csi_write(csi, 0x40030 | CSI_CCIR_ERR_DET_EN,\n\t\t\t\t   CSI_CCIR_CODE_1);\n\t\tipu_csi_write(csi, 0xFF0000, CSI_CCIR_CODE_3);\n\t\tbreak;\n\tcase IPU_CSI_CLK_MODE_GATED_CLK:\n\tcase IPU_CSI_CLK_MODE_NONGATED_CLK:\n\t\tipu_csi_write(csi, 0, CSI_CCIR_CODE_1);\n\t\tbreak;\n\t}\n\n\t \n\tipu_csi_write(csi, (width - 1) | ((height - 1) << 16),\n\t\t      CSI_SENS_FRM_SIZE);\n\n\tdev_dbg(csi->ipu->dev, \"CSI_SENS_CONF = 0x%08X\\n\",\n\t\tipu_csi_read(csi, CSI_SENS_CONF));\n\tdev_dbg(csi->ipu->dev, \"CSI_ACT_FRM_SIZE = 0x%08X\\n\",\n\t\tipu_csi_read(csi, CSI_ACT_FRM_SIZE));\n\nout_unlock:\n\tspin_unlock_irqrestore(&csi->lock, flags);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(ipu_csi_init_interface);\n\nbool ipu_csi_is_interlaced(struct ipu_csi *csi)\n{\n\tunsigned long flags;\n\tu32 sensor_protocol;\n\n\tspin_lock_irqsave(&csi->lock, flags);\n\tsensor_protocol =\n\t\t(ipu_csi_read(csi, CSI_SENS_CONF) &\n\t\t CSI_SENS_CONF_SENS_PRTCL_MASK) >>\n\t\tCSI_SENS_CONF_SENS_PRTCL_SHIFT;\n\tspin_unlock_irqrestore(&csi->lock, flags);\n\n\tswitch (sensor_protocol) {\n\tcase IPU_CSI_CLK_MODE_GATED_CLK:\n\tcase IPU_CSI_CLK_MODE_NONGATED_CLK:\n\tcase IPU_CSI_CLK_MODE_CCIR656_PROGRESSIVE:\n\tcase IPU_CSI_CLK_MODE_CCIR1120_PROGRESSIVE_DDR:\n\tcase IPU_CSI_CLK_MODE_CCIR1120_PROGRESSIVE_SDR:\n\t\treturn false;\n\tcase IPU_CSI_CLK_MODE_CCIR656_INTERLACED:\n\tcase IPU_CSI_CLK_MODE_CCIR1120_INTERLACED_DDR:\n\tcase IPU_CSI_CLK_MODE_CCIR1120_INTERLACED_SDR:\n\t\treturn true;\n\tdefault:\n\t\tdev_err(csi->ipu->dev,\n\t\t\t\"CSI %d sensor protocol unsupported\\n\", csi->id);\n\t\treturn false;\n\t}\n}\nEXPORT_SYMBOL_GPL(ipu_csi_is_interlaced);\n\nvoid ipu_csi_get_window(struct ipu_csi *csi, struct v4l2_rect *w)\n{\n\tunsigned long flags;\n\tu32 reg;\n\n\tspin_lock_irqsave(&csi->lock, flags);\n\n\treg = ipu_csi_read(csi, CSI_ACT_FRM_SIZE);\n\tw->width = (reg & 0xFFFF) + 1;\n\tw->height = (reg >> 16 & 0xFFFF) + 1;\n\n\treg = ipu_csi_read(csi, CSI_OUT_FRM_CTRL);\n\tw->left = (reg & CSI_HSC_MASK) >> CSI_HSC_SHIFT;\n\tw->top = (reg & CSI_VSC_MASK) >> CSI_VSC_SHIFT;\n\n\tspin_unlock_irqrestore(&csi->lock, flags);\n}\nEXPORT_SYMBOL_GPL(ipu_csi_get_window);\n\nvoid ipu_csi_set_window(struct ipu_csi *csi, struct v4l2_rect *w)\n{\n\tunsigned long flags;\n\tu32 reg;\n\n\tspin_lock_irqsave(&csi->lock, flags);\n\n\tipu_csi_write(csi, (w->width - 1) | ((w->height - 1) << 16),\n\t\t\t  CSI_ACT_FRM_SIZE);\n\n\treg = ipu_csi_read(csi, CSI_OUT_FRM_CTRL);\n\treg &= ~(CSI_HSC_MASK | CSI_VSC_MASK);\n\treg |= ((w->top << CSI_VSC_SHIFT) | (w->left << CSI_HSC_SHIFT));\n\tipu_csi_write(csi, reg, CSI_OUT_FRM_CTRL);\n\n\tspin_unlock_irqrestore(&csi->lock, flags);\n}\nEXPORT_SYMBOL_GPL(ipu_csi_set_window);\n\nvoid ipu_csi_set_downsize(struct ipu_csi *csi, bool horiz, bool vert)\n{\n\tunsigned long flags;\n\tu32 reg;\n\n\tspin_lock_irqsave(&csi->lock, flags);\n\n\treg = ipu_csi_read(csi, CSI_OUT_FRM_CTRL);\n\treg &= ~(CSI_HORI_DOWNSIZE_EN | CSI_VERT_DOWNSIZE_EN);\n\treg |= (horiz ? CSI_HORI_DOWNSIZE_EN : 0) |\n\t       (vert ? CSI_VERT_DOWNSIZE_EN : 0);\n\tipu_csi_write(csi, reg, CSI_OUT_FRM_CTRL);\n\n\tspin_unlock_irqrestore(&csi->lock, flags);\n}\nEXPORT_SYMBOL_GPL(ipu_csi_set_downsize);\n\nvoid ipu_csi_set_test_generator(struct ipu_csi *csi, bool active,\n\t\t\t\tu32 r_value, u32 g_value, u32 b_value,\n\t\t\t\tu32 pix_clk)\n{\n\tunsigned long flags;\n\tu32 ipu_clk = clk_get_rate(csi->clk_ipu);\n\tu32 temp;\n\n\tspin_lock_irqsave(&csi->lock, flags);\n\n\ttemp = ipu_csi_read(csi, CSI_TST_CTRL);\n\n\tif (!active) {\n\t\ttemp &= ~CSI_TEST_GEN_MODE_EN;\n\t\tipu_csi_write(csi, temp, CSI_TST_CTRL);\n\t} else {\n\t\t \n\t\tipu_csi_set_testgen_mclk(csi, pix_clk, ipu_clk);\n\n\t\ttemp &= ~(CSI_TEST_GEN_R_MASK | CSI_TEST_GEN_G_MASK |\n\t\t\t  CSI_TEST_GEN_B_MASK);\n\t\ttemp |= CSI_TEST_GEN_MODE_EN;\n\t\ttemp |= (r_value << CSI_TEST_GEN_R_SHIFT) |\n\t\t\t(g_value << CSI_TEST_GEN_G_SHIFT) |\n\t\t\t(b_value << CSI_TEST_GEN_B_SHIFT);\n\t\tipu_csi_write(csi, temp, CSI_TST_CTRL);\n\t}\n\n\tspin_unlock_irqrestore(&csi->lock, flags);\n}\nEXPORT_SYMBOL_GPL(ipu_csi_set_test_generator);\n\nint ipu_csi_set_mipi_datatype(struct ipu_csi *csi, u32 vc,\n\t\t\t      struct v4l2_mbus_framefmt *mbus_fmt)\n{\n\tstruct ipu_csi_bus_config cfg;\n\tunsigned long flags;\n\tu32 temp;\n\tint ret;\n\n\tif (vc > 3)\n\t\treturn -EINVAL;\n\n\tret = mbus_code_to_bus_cfg(&cfg, mbus_fmt->code, V4L2_MBUS_CSI2_DPHY);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tspin_lock_irqsave(&csi->lock, flags);\n\n\ttemp = ipu_csi_read(csi, CSI_MIPI_DI);\n\ttemp &= ~(0xff << (vc * 8));\n\ttemp |= (cfg.mipi_dt << (vc * 8));\n\tipu_csi_write(csi, temp, CSI_MIPI_DI);\n\n\tspin_unlock_irqrestore(&csi->lock, flags);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(ipu_csi_set_mipi_datatype);\n\nint ipu_csi_set_skip_smfc(struct ipu_csi *csi, u32 skip,\n\t\t\t  u32 max_ratio, u32 id)\n{\n\tunsigned long flags;\n\tu32 temp;\n\n\tif (max_ratio > 5 || id > 3)\n\t\treturn -EINVAL;\n\n\tspin_lock_irqsave(&csi->lock, flags);\n\n\ttemp = ipu_csi_read(csi, CSI_SKIP);\n\ttemp &= ~(CSI_MAX_RATIO_SKIP_SMFC_MASK | CSI_ID_2_SKIP_MASK |\n\t\t  CSI_SKIP_SMFC_MASK);\n\ttemp |= (max_ratio << CSI_MAX_RATIO_SKIP_SMFC_SHIFT) |\n\t\t(id << CSI_ID_2_SKIP_SHIFT) |\n\t\t(skip << CSI_SKIP_SMFC_SHIFT);\n\tipu_csi_write(csi, temp, CSI_SKIP);\n\n\tspin_unlock_irqrestore(&csi->lock, flags);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(ipu_csi_set_skip_smfc);\n\nint ipu_csi_set_dest(struct ipu_csi *csi, enum ipu_csi_dest csi_dest)\n{\n\tunsigned long flags;\n\tu32 csi_sens_conf, dest;\n\n\tif (csi_dest == IPU_CSI_DEST_IDMAC)\n\t\tdest = CSI_DATA_DEST_IDMAC;\n\telse\n\t\tdest = CSI_DATA_DEST_IC;  \n\n\tspin_lock_irqsave(&csi->lock, flags);\n\n\tcsi_sens_conf = ipu_csi_read(csi, CSI_SENS_CONF);\n\tcsi_sens_conf &= ~CSI_SENS_CONF_DATA_DEST_MASK;\n\tcsi_sens_conf |= (dest << CSI_SENS_CONF_DATA_DEST_SHIFT);\n\tipu_csi_write(csi, csi_sens_conf, CSI_SENS_CONF);\n\n\tspin_unlock_irqrestore(&csi->lock, flags);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(ipu_csi_set_dest);\n\nint ipu_csi_enable(struct ipu_csi *csi)\n{\n\tipu_module_enable(csi->ipu, csi->module);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(ipu_csi_enable);\n\nint ipu_csi_disable(struct ipu_csi *csi)\n{\n\tipu_module_disable(csi->ipu, csi->module);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(ipu_csi_disable);\n\nstruct ipu_csi *ipu_csi_get(struct ipu_soc *ipu, int id)\n{\n\tunsigned long flags;\n\tstruct ipu_csi *csi, *ret;\n\n\tif (id > 1)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tcsi = ipu->csi_priv[id];\n\tret = csi;\n\n\tspin_lock_irqsave(&csi->lock, flags);\n\n\tif (csi->inuse) {\n\t\tret = ERR_PTR(-EBUSY);\n\t\tgoto unlock;\n\t}\n\n\tcsi->inuse = true;\nunlock:\n\tspin_unlock_irqrestore(&csi->lock, flags);\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(ipu_csi_get);\n\nvoid ipu_csi_put(struct ipu_csi *csi)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&csi->lock, flags);\n\tcsi->inuse = false;\n\tspin_unlock_irqrestore(&csi->lock, flags);\n}\nEXPORT_SYMBOL_GPL(ipu_csi_put);\n\nint ipu_csi_init(struct ipu_soc *ipu, struct device *dev, int id,\n\t\t unsigned long base, u32 module, struct clk *clk_ipu)\n{\n\tstruct ipu_csi *csi;\n\n\tif (id > 1)\n\t\treturn -ENODEV;\n\n\tcsi = devm_kzalloc(dev, sizeof(*csi), GFP_KERNEL);\n\tif (!csi)\n\t\treturn -ENOMEM;\n\n\tipu->csi_priv[id] = csi;\n\n\tspin_lock_init(&csi->lock);\n\tcsi->module = module;\n\tcsi->id = id;\n\tcsi->clk_ipu = clk_ipu;\n\tcsi->base = devm_ioremap(dev, base, PAGE_SIZE);\n\tif (!csi->base)\n\t\treturn -ENOMEM;\n\n\tdev_dbg(dev, \"CSI%d base: 0x%08lx remapped to %p\\n\",\n\t\tid, base, csi->base);\n\tcsi->ipu = ipu;\n\n\treturn 0;\n}\n\nvoid ipu_csi_exit(struct ipu_soc *ipu, int id)\n{\n}\n\nvoid ipu_csi_dump(struct ipu_csi *csi)\n{\n\tdev_dbg(csi->ipu->dev, \"CSI_SENS_CONF:     %08x\\n\",\n\t\tipu_csi_read(csi, CSI_SENS_CONF));\n\tdev_dbg(csi->ipu->dev, \"CSI_SENS_FRM_SIZE: %08x\\n\",\n\t\tipu_csi_read(csi, CSI_SENS_FRM_SIZE));\n\tdev_dbg(csi->ipu->dev, \"CSI_ACT_FRM_SIZE:  %08x\\n\",\n\t\tipu_csi_read(csi, CSI_ACT_FRM_SIZE));\n\tdev_dbg(csi->ipu->dev, \"CSI_OUT_FRM_CTRL:  %08x\\n\",\n\t\tipu_csi_read(csi, CSI_OUT_FRM_CTRL));\n\tdev_dbg(csi->ipu->dev, \"CSI_TST_CTRL:      %08x\\n\",\n\t\tipu_csi_read(csi, CSI_TST_CTRL));\n\tdev_dbg(csi->ipu->dev, \"CSI_CCIR_CODE_1:   %08x\\n\",\n\t\tipu_csi_read(csi, CSI_CCIR_CODE_1));\n\tdev_dbg(csi->ipu->dev, \"CSI_CCIR_CODE_2:   %08x\\n\",\n\t\tipu_csi_read(csi, CSI_CCIR_CODE_2));\n\tdev_dbg(csi->ipu->dev, \"CSI_CCIR_CODE_3:   %08x\\n\",\n\t\tipu_csi_read(csi, CSI_CCIR_CODE_3));\n\tdev_dbg(csi->ipu->dev, \"CSI_MIPI_DI:       %08x\\n\",\n\t\tipu_csi_read(csi, CSI_MIPI_DI));\n\tdev_dbg(csi->ipu->dev, \"CSI_SKIP:          %08x\\n\",\n\t\tipu_csi_read(csi, CSI_SKIP));\n}\nEXPORT_SYMBOL_GPL(ipu_csi_dump);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}