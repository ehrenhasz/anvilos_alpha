{
  "module_name": "ipu-prg.c",
  "hash_id": "aded5a7bc1da03326b821f88e59d5482f70949f3a25a2d22778627260aa67254",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/ipu-v3/ipu-prg.c",
  "human_readable_source": "\n \n\n#include <drm/drm_fourcc.h>\n#include <linux/clk.h>\n#include <linux/err.h>\n#include <linux/iopoll.h>\n#include <linux/mfd/syscon.h>\n#include <linux/mfd/syscon/imx6q-iomuxc-gpr.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/pm_runtime.h>\n#include <linux/regmap.h>\n#include <video/imx-ipu-v3.h>\n\n#include \"ipu-prv.h\"\n\n#define IPU_PRG_CTL\t\t\t\t0x00\n#define  IPU_PRG_CTL_BYPASS(i)\t\t\t(1 << (0 + i))\n#define  IPU_PRG_CTL_SOFT_ARID_MASK\t\t0x3\n#define  IPU_PRG_CTL_SOFT_ARID_SHIFT(i)\t\t(8 + i * 2)\n#define  IPU_PRG_CTL_SOFT_ARID(i, v)\t\t((v & 0x3) << (8 + 2 * i))\n#define  IPU_PRG_CTL_SO(i)\t\t\t(1 << (16 + i))\n#define  IPU_PRG_CTL_VFLIP(i)\t\t\t(1 << (19 + i))\n#define  IPU_PRG_CTL_BLOCK_MODE(i)\t\t(1 << (22 + i))\n#define  IPU_PRG_CTL_CNT_LOAD_EN(i)\t\t(1 << (25 + i))\n#define  IPU_PRG_CTL_SOFTRST\t\t\t(1 << 30)\n#define  IPU_PRG_CTL_SHADOW_EN\t\t\t(1 << 31)\n\n#define IPU_PRG_STATUS\t\t\t\t0x04\n#define  IPU_PRG_STATUS_BUFFER0_READY(i)\t(1 << (0 + i * 2))\n#define  IPU_PRG_STATUS_BUFFER1_READY(i)\t(1 << (1 + i * 2))\n\n#define IPU_PRG_QOS\t\t\t\t0x08\n#define  IPU_PRG_QOS_ARID_MASK\t\t\t0xf\n#define  IPU_PRG_QOS_ARID_SHIFT(i)\t\t(0 + i * 4)\n\n#define IPU_PRG_REG_UPDATE\t\t\t0x0c\n#define  IPU_PRG_REG_UPDATE_REG_UPDATE\t\t(1 << 0)\n\n#define IPU_PRG_STRIDE(i)\t\t\t(0x10 + i * 0x4)\n#define  IPU_PRG_STRIDE_STRIDE_MASK\t\t0x3fff\n\n#define IPU_PRG_CROP_LINE\t\t\t0x1c\n\n#define IPU_PRG_THD\t\t\t\t0x20\n\n#define IPU_PRG_BADDR(i)\t\t\t(0x24 + i * 0x4)\n\n#define IPU_PRG_OFFSET(i)\t\t\t(0x30 + i * 0x4)\n\n#define IPU_PRG_ILO(i)\t\t\t\t(0x3c + i * 0x4)\n\n#define IPU_PRG_HEIGHT(i)\t\t\t(0x48 + i * 0x4)\n#define  IPU_PRG_HEIGHT_PRE_HEIGHT_MASK\t\t0xfff\n#define  IPU_PRG_HEIGHT_PRE_HEIGHT_SHIFT\t0\n#define  IPU_PRG_HEIGHT_IPU_HEIGHT_MASK\t\t0xfff\n#define  IPU_PRG_HEIGHT_IPU_HEIGHT_SHIFT\t16\n\nstruct ipu_prg_channel {\n\tbool\t\t\tenabled;\n\tint\t\t\tused_pre;\n};\n\nstruct ipu_prg {\n\tstruct list_head\tlist;\n\tstruct device\t\t*dev;\n\tint\t\t\tid;\n\n\tvoid __iomem\t\t*regs;\n\tstruct clk\t\t*clk_ipg, *clk_axi;\n\tstruct regmap\t\t*iomuxc_gpr;\n\tstruct ipu_pre\t\t*pres[3];\n\n\tstruct ipu_prg_channel\tchan[3];\n};\n\nstatic DEFINE_MUTEX(ipu_prg_list_mutex);\nstatic LIST_HEAD(ipu_prg_list);\n\nstruct ipu_prg *\nipu_prg_lookup_by_phandle(struct device *dev, const char *name, int ipu_id)\n{\n\tstruct device_node *prg_node = of_parse_phandle(dev->of_node,\n\t\t\t\t\t\t\tname, 0);\n\tstruct ipu_prg *prg;\n\n\tmutex_lock(&ipu_prg_list_mutex);\n\tlist_for_each_entry(prg, &ipu_prg_list, list) {\n\t\tif (prg_node == prg->dev->of_node) {\n\t\t\tmutex_unlock(&ipu_prg_list_mutex);\n\t\t\tdevice_link_add(dev, prg->dev,\n\t\t\t\t\tDL_FLAG_AUTOREMOVE_CONSUMER);\n\t\t\tprg->id = ipu_id;\n\t\t\tof_node_put(prg_node);\n\t\t\treturn prg;\n\t\t}\n\t}\n\tmutex_unlock(&ipu_prg_list_mutex);\n\n\tof_node_put(prg_node);\n\n\treturn NULL;\n}\n\nint ipu_prg_max_active_channels(void)\n{\n\treturn ipu_pre_get_available_count();\n}\nEXPORT_SYMBOL_GPL(ipu_prg_max_active_channels);\n\nbool ipu_prg_present(struct ipu_soc *ipu)\n{\n\tif (ipu->prg_priv)\n\t\treturn true;\n\n\treturn false;\n}\nEXPORT_SYMBOL_GPL(ipu_prg_present);\n\nbool ipu_prg_format_supported(struct ipu_soc *ipu, uint32_t format,\n\t\t\t      uint64_t modifier)\n{\n\tconst struct drm_format_info *info = drm_format_info(format);\n\n\tif (info->num_planes != 1)\n\t\treturn false;\n\n\tswitch (modifier) {\n\tcase DRM_FORMAT_MOD_LINEAR:\n\tcase DRM_FORMAT_MOD_VIVANTE_TILED:\n\tcase DRM_FORMAT_MOD_VIVANTE_SUPER_TILED:\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}\nEXPORT_SYMBOL_GPL(ipu_prg_format_supported);\n\nint ipu_prg_enable(struct ipu_soc *ipu)\n{\n\tstruct ipu_prg *prg = ipu->prg_priv;\n\n\tif (!prg)\n\t\treturn 0;\n\n\treturn pm_runtime_get_sync(prg->dev);\n}\nEXPORT_SYMBOL_GPL(ipu_prg_enable);\n\nvoid ipu_prg_disable(struct ipu_soc *ipu)\n{\n\tstruct ipu_prg *prg = ipu->prg_priv;\n\n\tif (!prg)\n\t\treturn;\n\n\tpm_runtime_put(prg->dev);\n}\nEXPORT_SYMBOL_GPL(ipu_prg_disable);\n\n \nstatic int ipu_prg_ipu_to_prg_chan(int ipu_chan)\n{\n\t \n\tswitch (ipu_chan) {\n\tcase IPUV3_CHANNEL_MEM_BG_SYNC:\n\t\treturn 0;\n\tcase IPUV3_CHANNEL_MEM_FG_SYNC:\n\t\treturn 1;\n\tcase IPUV3_CHANNEL_MEM_DC_SYNC:\n\t\treturn 2;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic int ipu_prg_get_pre(struct ipu_prg *prg, int prg_chan)\n{\n\tint i, ret;\n\n\t \n\tif (prg_chan == 0) {\n\t\tret = ipu_pre_get(prg->pres[0]);\n\t\tif (ret)\n\t\t\tgoto fail;\n\t\tprg->chan[prg_chan].used_pre = 0;\n\t\treturn 0;\n\t}\n\n\tfor (i = 1; i < 3; i++) {\n\t\tret = ipu_pre_get(prg->pres[i]);\n\t\tif (!ret) {\n\t\t\tu32 val, mux;\n\t\t\tint shift;\n\n\t\t\tprg->chan[prg_chan].used_pre = i;\n\n\t\t\t \n\t\t\tshift = (i == 1) ? 12 : 14;\n\t\t\tmux = (prg->id << 1) | (prg_chan - 1);\n\t\t\tregmap_update_bits(prg->iomuxc_gpr, IOMUXC_GPR5,\n\t\t\t\t\t   0x3 << shift, mux << shift);\n\n\t\t\t \n\t\t\tshift = (i == 1) ? 14 : 12;\n\t\t\tregmap_read(prg->iomuxc_gpr, IOMUXC_GPR5, &val);\n\t\t\tif (((val >> shift) & 0x3) == mux) {\n\t\t\t\tregmap_update_bits(prg->iomuxc_gpr, IOMUXC_GPR5,\n\t\t\t\t\t\t   0x3 << shift,\n\t\t\t\t\t\t   (mux ^ 0x1) << shift);\n\t\t\t}\n\n\t\t\treturn 0;\n\t\t}\n\t}\n\nfail:\n\tdev_err(prg->dev, \"could not get PRE for PRG chan %d\", prg_chan);\n\treturn ret;\n}\n\nstatic void ipu_prg_put_pre(struct ipu_prg *prg, int prg_chan)\n{\n\tstruct ipu_prg_channel *chan = &prg->chan[prg_chan];\n\n\tipu_pre_put(prg->pres[chan->used_pre]);\n\tchan->used_pre = -1;\n}\n\nvoid ipu_prg_channel_disable(struct ipuv3_channel *ipu_chan)\n{\n\tint prg_chan = ipu_prg_ipu_to_prg_chan(ipu_chan->num);\n\tstruct ipu_prg *prg = ipu_chan->ipu->prg_priv;\n\tstruct ipu_prg_channel *chan;\n\tu32 val;\n\n\tif (prg_chan < 0)\n\t\treturn;\n\n\tchan = &prg->chan[prg_chan];\n\tif (!chan->enabled)\n\t\treturn;\n\n\tpm_runtime_get_sync(prg->dev);\n\n\tval = readl(prg->regs + IPU_PRG_CTL);\n\tval |= IPU_PRG_CTL_BYPASS(prg_chan);\n\twritel(val, prg->regs + IPU_PRG_CTL);\n\n\tval = IPU_PRG_REG_UPDATE_REG_UPDATE;\n\twritel(val, prg->regs + IPU_PRG_REG_UPDATE);\n\n\tpm_runtime_put(prg->dev);\n\n\tipu_prg_put_pre(prg, prg_chan);\n\n\tchan->enabled = false;\n}\nEXPORT_SYMBOL_GPL(ipu_prg_channel_disable);\n\nint ipu_prg_channel_configure(struct ipuv3_channel *ipu_chan,\n\t\t\t      unsigned int axi_id, unsigned int width,\n\t\t\t      unsigned int height, unsigned int stride,\n\t\t\t      u32 format, uint64_t modifier, unsigned long *eba)\n{\n\tint prg_chan = ipu_prg_ipu_to_prg_chan(ipu_chan->num);\n\tstruct ipu_prg *prg = ipu_chan->ipu->prg_priv;\n\tstruct ipu_prg_channel *chan;\n\tu32 val;\n\tint ret;\n\n\tif (prg_chan < 0)\n\t\treturn prg_chan;\n\n\tchan = &prg->chan[prg_chan];\n\n\tif (chan->enabled) {\n\t\tipu_pre_update(prg->pres[chan->used_pre], *eba);\n\t\treturn 0;\n\t}\n\n\tret = ipu_prg_get_pre(prg, prg_chan);\n\tif (ret)\n\t\treturn ret;\n\n\tipu_pre_configure(prg->pres[chan->used_pre],\n\t\t\t  width, height, stride, format, modifier, *eba);\n\n\n\tpm_runtime_get_sync(prg->dev);\n\n\tval = (stride - 1) & IPU_PRG_STRIDE_STRIDE_MASK;\n\twritel(val, prg->regs + IPU_PRG_STRIDE(prg_chan));\n\n\tval = ((height & IPU_PRG_HEIGHT_PRE_HEIGHT_MASK) <<\n\t       IPU_PRG_HEIGHT_PRE_HEIGHT_SHIFT) |\n\t      ((height & IPU_PRG_HEIGHT_IPU_HEIGHT_MASK) <<\n\t       IPU_PRG_HEIGHT_IPU_HEIGHT_SHIFT);\n\twritel(val, prg->regs + IPU_PRG_HEIGHT(prg_chan));\n\n\tval = ipu_pre_get_baddr(prg->pres[chan->used_pre]);\n\t*eba = val;\n\twritel(val, prg->regs + IPU_PRG_BADDR(prg_chan));\n\n\tval = readl(prg->regs + IPU_PRG_CTL);\n\t \n\tval &= ~(IPU_PRG_CTL_SOFT_ARID_MASK <<\n\t\t IPU_PRG_CTL_SOFT_ARID_SHIFT(prg_chan));\n\tval |= IPU_PRG_CTL_SOFT_ARID(prg_chan, axi_id);\n\t \n\tval &= ~IPU_PRG_CTL_BYPASS(prg_chan);\n\twritel(val, prg->regs + IPU_PRG_CTL);\n\n\tval = IPU_PRG_REG_UPDATE_REG_UPDATE;\n\twritel(val, prg->regs + IPU_PRG_REG_UPDATE);\n\n\t \n\treadl_poll_timeout(prg->regs + IPU_PRG_STATUS, val,\n\t\t\t   (val & IPU_PRG_STATUS_BUFFER0_READY(prg_chan)) &&\n\t\t\t   (val & IPU_PRG_STATUS_BUFFER1_READY(prg_chan)),\n\t\t\t   5, 1000);\n\n\tpm_runtime_put(prg->dev);\n\n\tchan->enabled = true;\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(ipu_prg_channel_configure);\n\nbool ipu_prg_channel_configure_pending(struct ipuv3_channel *ipu_chan)\n{\n\tint prg_chan = ipu_prg_ipu_to_prg_chan(ipu_chan->num);\n\tstruct ipu_prg *prg = ipu_chan->ipu->prg_priv;\n\tstruct ipu_prg_channel *chan;\n\n\tif (prg_chan < 0)\n\t\treturn false;\n\n\tchan = &prg->chan[prg_chan];\n\tWARN_ON(!chan->enabled);\n\n\treturn ipu_pre_update_pending(prg->pres[chan->used_pre]);\n}\nEXPORT_SYMBOL_GPL(ipu_prg_channel_configure_pending);\n\nstatic int ipu_prg_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct ipu_prg *prg;\n\tu32 val;\n\tint i, ret;\n\n\tprg = devm_kzalloc(dev, sizeof(*prg), GFP_KERNEL);\n\tif (!prg)\n\t\treturn -ENOMEM;\n\n\tprg->regs = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(prg->regs))\n\t\treturn PTR_ERR(prg->regs);\n\n\tprg->clk_ipg = devm_clk_get(dev, \"ipg\");\n\tif (IS_ERR(prg->clk_ipg))\n\t\treturn PTR_ERR(prg->clk_ipg);\n\n\tprg->clk_axi = devm_clk_get(dev, \"axi\");\n\tif (IS_ERR(prg->clk_axi))\n\t\treturn PTR_ERR(prg->clk_axi);\n\n\tprg->iomuxc_gpr =\n\t\tsyscon_regmap_lookup_by_compatible(\"fsl,imx6q-iomuxc-gpr\");\n\tif (IS_ERR(prg->iomuxc_gpr))\n\t\treturn PTR_ERR(prg->iomuxc_gpr);\n\n\tfor (i = 0; i < 3; i++) {\n\t\tprg->pres[i] = ipu_pre_lookup_by_phandle(dev, \"fsl,pres\", i);\n\t\tif (!prg->pres[i])\n\t\t\treturn -EPROBE_DEFER;\n\t}\n\n\tret = clk_prepare_enable(prg->clk_ipg);\n\tif (ret)\n\t\treturn ret;\n\n\tret = clk_prepare_enable(prg->clk_axi);\n\tif (ret) {\n\t\tclk_disable_unprepare(prg->clk_ipg);\n\t\treturn ret;\n\t}\n\n\t \n\tval = readl(prg->regs + IPU_PRG_CTL);\n\tval |= IPU_PRG_CTL_SHADOW_EN;\n\twritel(val, prg->regs + IPU_PRG_CTL);\n\n\t \n\twritel(0xffffffff, prg->regs + IPU_PRG_THD);\n\n\tpm_runtime_set_active(dev);\n\tpm_runtime_enable(dev);\n\n\tprg->dev = dev;\n\tplatform_set_drvdata(pdev, prg);\n\tmutex_lock(&ipu_prg_list_mutex);\n\tlist_add(&prg->list, &ipu_prg_list);\n\tmutex_unlock(&ipu_prg_list_mutex);\n\n\treturn 0;\n}\n\nstatic int ipu_prg_remove(struct platform_device *pdev)\n{\n\tstruct ipu_prg *prg = platform_get_drvdata(pdev);\n\n\tmutex_lock(&ipu_prg_list_mutex);\n\tlist_del(&prg->list);\n\tmutex_unlock(&ipu_prg_list_mutex);\n\n\treturn 0;\n}\n\n#ifdef CONFIG_PM\nstatic int prg_suspend(struct device *dev)\n{\n\tstruct ipu_prg *prg = dev_get_drvdata(dev);\n\n\tclk_disable_unprepare(prg->clk_axi);\n\tclk_disable_unprepare(prg->clk_ipg);\n\n\treturn 0;\n}\n\nstatic int prg_resume(struct device *dev)\n{\n\tstruct ipu_prg *prg = dev_get_drvdata(dev);\n\tint ret;\n\n\tret = clk_prepare_enable(prg->clk_ipg);\n\tif (ret)\n\t\treturn ret;\n\n\tret = clk_prepare_enable(prg->clk_axi);\n\tif (ret) {\n\t\tclk_disable_unprepare(prg->clk_ipg);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n#endif\n\nstatic const struct dev_pm_ops prg_pm_ops = {\n\tSET_RUNTIME_PM_OPS(prg_suspend, prg_resume, NULL)\n};\n\nstatic const struct of_device_id ipu_prg_dt_ids[] = {\n\t{ .compatible = \"fsl,imx6qp-prg\", },\n\t{   },\n};\n\nstruct platform_driver ipu_prg_drv = {\n\t.probe\t\t= ipu_prg_probe,\n\t.remove\t\t= ipu_prg_remove,\n\t.driver\t\t= {\n\t\t.name\t= \"imx-ipu-prg\",\n\t\t.pm\t= &prg_pm_ops,\n\t\t.of_match_table = ipu_prg_dt_ids,\n\t},\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}