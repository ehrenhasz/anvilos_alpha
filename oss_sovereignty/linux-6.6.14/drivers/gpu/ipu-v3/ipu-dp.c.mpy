{
  "module_name": "ipu-dp.c",
  "hash_id": "fde3157eb1e821bd9f863d617e22c683072609329af36d4c9cb54735bae74d77",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/ipu-v3/ipu-dp.c",
  "human_readable_source": "\n \n#include <linux/export.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n#include <linux/errno.h>\n#include <linux/io.h>\n#include <linux/err.h>\n\n#include <drm/drm_color_mgmt.h>\n#include <video/imx-ipu-v3.h>\n#include \"ipu-prv.h\"\n\n#define DP_SYNC 0\n#define DP_ASYNC0 0x60\n#define DP_ASYNC1 0xBC\n\n#define DP_COM_CONF\t\t0x0\n#define DP_GRAPH_WIND_CTRL\t0x0004\n#define DP_FG_POS\t\t0x0008\n#define DP_CSC_A_0\t\t0x0044\n#define DP_CSC_A_1\t\t0x0048\n#define DP_CSC_A_2\t\t0x004C\n#define DP_CSC_A_3\t\t0x0050\n#define DP_CSC_0\t\t0x0054\n#define DP_CSC_1\t\t0x0058\n\n#define DP_COM_CONF_FG_EN\t\t(1 << 0)\n#define DP_COM_CONF_GWSEL\t\t(1 << 1)\n#define DP_COM_CONF_GWAM\t\t(1 << 2)\n#define DP_COM_CONF_GWCKE\t\t(1 << 3)\n#define DP_COM_CONF_CSC_DEF_MASK\t(3 << 8)\n#define DP_COM_CONF_CSC_DEF_OFFSET\t8\n#define DP_COM_CONF_CSC_DEF_FG\t\t(3 << 8)\n#define DP_COM_CONF_CSC_DEF_BG\t\t(2 << 8)\n#define DP_COM_CONF_CSC_DEF_BOTH\t(1 << 8)\n\n#define IPUV3_NUM_FLOWS\t\t3\n\nstruct ipu_dp_priv;\n\nstruct ipu_dp {\n\tu32 flow;\n\tbool in_use;\n\tbool foreground;\n\tenum ipu_color_space in_cs;\n};\n\nstruct ipu_flow {\n\tstruct ipu_dp foreground;\n\tstruct ipu_dp background;\n\tenum ipu_color_space out_cs;\n\tvoid __iomem *base;\n\tstruct ipu_dp_priv *priv;\n};\n\nstruct ipu_dp_priv {\n\tstruct ipu_soc *ipu;\n\tstruct device *dev;\n\tvoid __iomem *base;\n\tstruct ipu_flow flow[IPUV3_NUM_FLOWS];\n\tstruct mutex mutex;\n\tint use_count;\n};\n\nstatic u32 ipu_dp_flow_base[] = {DP_SYNC, DP_ASYNC0, DP_ASYNC1};\n\nstatic inline struct ipu_flow *to_flow(struct ipu_dp *dp)\n{\n\tif (dp->foreground)\n\t\treturn container_of(dp, struct ipu_flow, foreground);\n\telse\n\t\treturn container_of(dp, struct ipu_flow, background);\n}\n\nint ipu_dp_set_global_alpha(struct ipu_dp *dp, bool enable,\n\t\tu8 alpha, bool bg_chan)\n{\n\tstruct ipu_flow *flow = to_flow(dp);\n\tstruct ipu_dp_priv *priv = flow->priv;\n\tu32 reg;\n\n\tmutex_lock(&priv->mutex);\n\n\treg = readl(flow->base + DP_COM_CONF);\n\tif (bg_chan)\n\t\treg &= ~DP_COM_CONF_GWSEL;\n\telse\n\t\treg |= DP_COM_CONF_GWSEL;\n\twritel(reg, flow->base + DP_COM_CONF);\n\n\tif (enable) {\n\t\treg = readl(flow->base + DP_GRAPH_WIND_CTRL) & 0x00FFFFFFL;\n\t\twritel(reg | ((u32) alpha << 24),\n\t\t\t     flow->base + DP_GRAPH_WIND_CTRL);\n\n\t\treg = readl(flow->base + DP_COM_CONF);\n\t\twritel(reg | DP_COM_CONF_GWAM, flow->base + DP_COM_CONF);\n\t} else {\n\t\treg = readl(flow->base + DP_COM_CONF);\n\t\twritel(reg & ~DP_COM_CONF_GWAM, flow->base + DP_COM_CONF);\n\t}\n\n\tipu_srm_dp_update(priv->ipu, true);\n\n\tmutex_unlock(&priv->mutex);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(ipu_dp_set_global_alpha);\n\nint ipu_dp_set_window_pos(struct ipu_dp *dp, u16 x_pos, u16 y_pos)\n{\n\tstruct ipu_flow *flow = to_flow(dp);\n\tstruct ipu_dp_priv *priv = flow->priv;\n\n\twritel((x_pos << 16) | y_pos, flow->base + DP_FG_POS);\n\n\tipu_srm_dp_update(priv->ipu, true);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(ipu_dp_set_window_pos);\n\nstatic void ipu_dp_csc_init(struct ipu_flow *flow,\n\t\tenum drm_color_encoding ycbcr_enc,\n\t\tenum drm_color_range range,\n\t\tenum ipu_color_space in,\n\t\tenum ipu_color_space out,\n\t\tu32 place)\n{\n\tu32 reg;\n\n\treg = readl(flow->base + DP_COM_CONF);\n\treg &= ~DP_COM_CONF_CSC_DEF_MASK;\n\n\tif (in == out) {\n\t\twritel(reg, flow->base + DP_COM_CONF);\n\t\treturn;\n\t}\n\n\tif (in == IPUV3_COLORSPACE_RGB && out == IPUV3_COLORSPACE_YUV) {\n\t\twritel(0x099 | (0x12d << 16), flow->base + DP_CSC_A_0);\n\t\twritel(0x03a | (0x3a9 << 16), flow->base + DP_CSC_A_1);\n\t\twritel(0x356 | (0x100 << 16), flow->base + DP_CSC_A_2);\n\t\twritel(0x100 | (0x329 << 16), flow->base + DP_CSC_A_3);\n\t\twritel(0x3d6 | (0x0000 << 16) | (2 << 30),\n\t\t\t\tflow->base + DP_CSC_0);\n\t\twritel(0x200 | (2 << 14) | (0x200 << 16) | (2 << 30),\n\t\t\t\tflow->base + DP_CSC_1);\n\t} else if (ycbcr_enc == DRM_COLOR_YCBCR_BT709) {\n\t\t \n\t\twritel(0x095 | (0x000 << 16), flow->base + DP_CSC_A_0);\n\t\twritel(0x0e5 | (0x095 << 16), flow->base + DP_CSC_A_1);\n\t\twritel(0x3e5 | (0x3bc << 16), flow->base + DP_CSC_A_2);\n\t\twritel(0x095 | (0x10e << 16), flow->base + DP_CSC_A_3);\n\t\twritel(0x000 | (0x3e10 << 16) | (1 << 30),\n\t\t\t\tflow->base + DP_CSC_0);\n\t\twritel(0x09a | (1 << 14) | (0x3dbe << 16) | (1 << 30),\n\t\t\t\tflow->base + DP_CSC_1);\n\t} else {\n\t\t \n\t\twritel(0x095 | (0x000 << 16), flow->base + DP_CSC_A_0);\n\t\twritel(0x0cc | (0x095 << 16), flow->base + DP_CSC_A_1);\n\t\twritel(0x3ce | (0x398 << 16), flow->base + DP_CSC_A_2);\n\t\twritel(0x095 | (0x0ff << 16), flow->base + DP_CSC_A_3);\n\t\twritel(0x000 | (0x3e42 << 16) | (1 << 30),\n\t\t\t\tflow->base + DP_CSC_0);\n\t\twritel(0x10a | (1 << 14) | (0x3dd6 << 16) | (1 << 30),\n\t\t\t\tflow->base + DP_CSC_1);\n\t}\n\n\treg |= place;\n\n\twritel(reg, flow->base + DP_COM_CONF);\n}\n\nint ipu_dp_setup_channel(struct ipu_dp *dp,\n\t\tenum drm_color_encoding ycbcr_enc,\n\t\tenum drm_color_range range,\n\t\tenum ipu_color_space in,\n\t\tenum ipu_color_space out)\n{\n\tstruct ipu_flow *flow = to_flow(dp);\n\tstruct ipu_dp_priv *priv = flow->priv;\n\n\tmutex_lock(&priv->mutex);\n\n\tdp->in_cs = in;\n\n\tif (!dp->foreground)\n\t\tflow->out_cs = out;\n\n\tif (flow->foreground.in_cs == flow->background.in_cs) {\n\t\t \n\t\tipu_dp_csc_init(flow, ycbcr_enc, range,\n\t\t\t\tflow->foreground.in_cs, flow->out_cs,\n\t\t\t\tDP_COM_CONF_CSC_DEF_BOTH);\n\t} else {\n\t\tif (flow->foreground.in_cs == IPUV3_COLORSPACE_UNKNOWN ||\n\t\t    flow->foreground.in_cs == flow->out_cs)\n\t\t\t \n\t\t\tipu_dp_csc_init(flow, ycbcr_enc, range,\n\t\t\t\t\tflow->background.in_cs,\n\t\t\t\t\tflow->out_cs, DP_COM_CONF_CSC_DEF_BG);\n\t\telse\n\t\t\tipu_dp_csc_init(flow, ycbcr_enc, range,\n\t\t\t\t\tflow->foreground.in_cs,\n\t\t\t\t\tflow->out_cs, DP_COM_CONF_CSC_DEF_FG);\n\t}\n\n\tipu_srm_dp_update(priv->ipu, true);\n\n\tmutex_unlock(&priv->mutex);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(ipu_dp_setup_channel);\n\nint ipu_dp_enable(struct ipu_soc *ipu)\n{\n\tstruct ipu_dp_priv *priv = ipu->dp_priv;\n\n\tmutex_lock(&priv->mutex);\n\n\tif (!priv->use_count)\n\t\tipu_module_enable(priv->ipu, IPU_CONF_DP_EN);\n\n\tpriv->use_count++;\n\n\tmutex_unlock(&priv->mutex);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(ipu_dp_enable);\n\nint ipu_dp_enable_channel(struct ipu_dp *dp)\n{\n\tstruct ipu_flow *flow = to_flow(dp);\n\tstruct ipu_dp_priv *priv = flow->priv;\n\tu32 reg;\n\n\tif (!dp->foreground)\n\t\treturn 0;\n\n\tmutex_lock(&priv->mutex);\n\n\treg = readl(flow->base + DP_COM_CONF);\n\treg |= DP_COM_CONF_FG_EN;\n\twritel(reg, flow->base + DP_COM_CONF);\n\n\tipu_srm_dp_update(priv->ipu, true);\n\n\tmutex_unlock(&priv->mutex);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(ipu_dp_enable_channel);\n\nvoid ipu_dp_disable_channel(struct ipu_dp *dp, bool sync)\n{\n\tstruct ipu_flow *flow = to_flow(dp);\n\tstruct ipu_dp_priv *priv = flow->priv;\n\tu32 reg, csc;\n\n\tdp->in_cs = IPUV3_COLORSPACE_UNKNOWN;\n\n\tif (!dp->foreground)\n\t\treturn;\n\n\tmutex_lock(&priv->mutex);\n\n\treg = readl(flow->base + DP_COM_CONF);\n\tcsc = reg & DP_COM_CONF_CSC_DEF_MASK;\n\treg &= ~DP_COM_CONF_CSC_DEF_MASK;\n\tif (csc == DP_COM_CONF_CSC_DEF_BOTH || csc == DP_COM_CONF_CSC_DEF_BG)\n\t\treg |= DP_COM_CONF_CSC_DEF_BG;\n\n\treg &= ~DP_COM_CONF_FG_EN;\n\twritel(reg, flow->base + DP_COM_CONF);\n\n\twritel(0, flow->base + DP_FG_POS);\n\tipu_srm_dp_update(priv->ipu, sync);\n\n\tmutex_unlock(&priv->mutex);\n}\nEXPORT_SYMBOL_GPL(ipu_dp_disable_channel);\n\nvoid ipu_dp_disable(struct ipu_soc *ipu)\n{\n\tstruct ipu_dp_priv *priv = ipu->dp_priv;\n\n\tmutex_lock(&priv->mutex);\n\n\tpriv->use_count--;\n\n\tif (!priv->use_count)\n\t\tipu_module_disable(priv->ipu, IPU_CONF_DP_EN);\n\n\tif (priv->use_count < 0)\n\t\tpriv->use_count = 0;\n\n\tmutex_unlock(&priv->mutex);\n}\nEXPORT_SYMBOL_GPL(ipu_dp_disable);\n\nstruct ipu_dp *ipu_dp_get(struct ipu_soc *ipu, unsigned int flow)\n{\n\tstruct ipu_dp_priv *priv = ipu->dp_priv;\n\tstruct ipu_dp *dp;\n\n\tif ((flow >> 1) >= IPUV3_NUM_FLOWS)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tif (flow & 1)\n\t\tdp = &priv->flow[flow >> 1].foreground;\n\telse\n\t\tdp = &priv->flow[flow >> 1].background;\n\n\tif (dp->in_use)\n\t\treturn ERR_PTR(-EBUSY);\n\n\tdp->in_use = true;\n\n\treturn dp;\n}\nEXPORT_SYMBOL_GPL(ipu_dp_get);\n\nvoid ipu_dp_put(struct ipu_dp *dp)\n{\n\tdp->in_use = false;\n}\nEXPORT_SYMBOL_GPL(ipu_dp_put);\n\nint ipu_dp_init(struct ipu_soc *ipu, struct device *dev, unsigned long base)\n{\n\tstruct ipu_dp_priv *priv;\n\tint i;\n\n\tpriv = devm_kzalloc(dev, sizeof(*priv), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\tpriv->dev = dev;\n\tpriv->ipu = ipu;\n\n\tipu->dp_priv = priv;\n\n\tpriv->base = devm_ioremap(dev, base, PAGE_SIZE);\n\tif (!priv->base)\n\t\treturn -ENOMEM;\n\n\tmutex_init(&priv->mutex);\n\n\tfor (i = 0; i < IPUV3_NUM_FLOWS; i++) {\n\t\tpriv->flow[i].background.in_cs = IPUV3_COLORSPACE_UNKNOWN;\n\t\tpriv->flow[i].foreground.in_cs = IPUV3_COLORSPACE_UNKNOWN;\n\t\tpriv->flow[i].foreground.foreground = true;\n\t\tpriv->flow[i].base = priv->base + ipu_dp_flow_base[i];\n\t\tpriv->flow[i].priv = priv;\n\t}\n\n\treturn 0;\n}\n\nvoid ipu_dp_exit(struct ipu_soc *ipu)\n{\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}