{
  "module_name": "ipu-ic.c",
  "hash_id": "3f0299a33c352f6b35c06775eee75db73e9bdc3788890ec5eba8b2f28ac14e75",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/ipu-v3/ipu-ic.c",
  "human_readable_source": "\n \n\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/errno.h>\n#include <linux/spinlock.h>\n#include <linux/bitrev.h>\n#include <linux/io.h>\n#include <linux/err.h>\n#include <linux/sizes.h>\n#include \"ipu-prv.h\"\n\n \n#define IC_CONF                 0x0000\n#define IC_PRP_ENC_RSC          0x0004\n#define IC_PRP_VF_RSC           0x0008\n#define IC_PP_RSC               0x000C\n#define IC_CMBP_1               0x0010\n#define IC_CMBP_2               0x0014\n#define IC_IDMAC_1              0x0018\n#define IC_IDMAC_2              0x001C\n#define IC_IDMAC_3              0x0020\n#define IC_IDMAC_4              0x0024\n\n \n#define IC_CONF_PRPENC_EN       (1 << 0)\n#define IC_CONF_PRPENC_CSC1     (1 << 1)\n#define IC_CONF_PRPENC_ROT_EN   (1 << 2)\n#define IC_CONF_PRPVF_EN        (1 << 8)\n#define IC_CONF_PRPVF_CSC1      (1 << 9)\n#define IC_CONF_PRPVF_CSC2      (1 << 10)\n#define IC_CONF_PRPVF_CMB       (1 << 11)\n#define IC_CONF_PRPVF_ROT_EN    (1 << 12)\n#define IC_CONF_PP_EN           (1 << 16)\n#define IC_CONF_PP_CSC1         (1 << 17)\n#define IC_CONF_PP_CSC2         (1 << 18)\n#define IC_CONF_PP_CMB          (1 << 19)\n#define IC_CONF_PP_ROT_EN       (1 << 20)\n#define IC_CONF_IC_GLB_LOC_A    (1 << 28)\n#define IC_CONF_KEY_COLOR_EN    (1 << 29)\n#define IC_CONF_RWS_EN          (1 << 30)\n#define IC_CONF_CSI_MEM_WR_EN   (1 << 31)\n\n#define IC_IDMAC_1_CB0_BURST_16         (1 << 0)\n#define IC_IDMAC_1_CB1_BURST_16         (1 << 1)\n#define IC_IDMAC_1_CB2_BURST_16         (1 << 2)\n#define IC_IDMAC_1_CB3_BURST_16         (1 << 3)\n#define IC_IDMAC_1_CB4_BURST_16         (1 << 4)\n#define IC_IDMAC_1_CB5_BURST_16         (1 << 5)\n#define IC_IDMAC_1_CB6_BURST_16         (1 << 6)\n#define IC_IDMAC_1_CB7_BURST_16         (1 << 7)\n#define IC_IDMAC_1_PRPENC_ROT_MASK      (0x7 << 11)\n#define IC_IDMAC_1_PRPENC_ROT_OFFSET    11\n#define IC_IDMAC_1_PRPVF_ROT_MASK       (0x7 << 14)\n#define IC_IDMAC_1_PRPVF_ROT_OFFSET     14\n#define IC_IDMAC_1_PP_ROT_MASK          (0x7 << 17)\n#define IC_IDMAC_1_PP_ROT_OFFSET        17\n#define IC_IDMAC_1_PP_FLIP_RS           (1 << 22)\n#define IC_IDMAC_1_PRPVF_FLIP_RS        (1 << 21)\n#define IC_IDMAC_1_PRPENC_FLIP_RS       (1 << 20)\n\n#define IC_IDMAC_2_PRPENC_HEIGHT_MASK   (0x3ff << 0)\n#define IC_IDMAC_2_PRPENC_HEIGHT_OFFSET 0\n#define IC_IDMAC_2_PRPVF_HEIGHT_MASK    (0x3ff << 10)\n#define IC_IDMAC_2_PRPVF_HEIGHT_OFFSET  10\n#define IC_IDMAC_2_PP_HEIGHT_MASK       (0x3ff << 20)\n#define IC_IDMAC_2_PP_HEIGHT_OFFSET     20\n\n#define IC_IDMAC_3_PRPENC_WIDTH_MASK    (0x3ff << 0)\n#define IC_IDMAC_3_PRPENC_WIDTH_OFFSET  0\n#define IC_IDMAC_3_PRPVF_WIDTH_MASK     (0x3ff << 10)\n#define IC_IDMAC_3_PRPVF_WIDTH_OFFSET   10\n#define IC_IDMAC_3_PP_WIDTH_MASK        (0x3ff << 20)\n#define IC_IDMAC_3_PP_WIDTH_OFFSET      20\n\nstruct ic_task_regoffs {\n\tu32 rsc;\n\tu32 tpmem_csc[2];\n};\n\nstruct ic_task_bitfields {\n\tu32 ic_conf_en;\n\tu32 ic_conf_rot_en;\n\tu32 ic_conf_cmb_en;\n\tu32 ic_conf_csc1_en;\n\tu32 ic_conf_csc2_en;\n\tu32 ic_cmb_galpha_bit;\n};\n\nstatic const struct ic_task_regoffs ic_task_reg[IC_NUM_TASKS] = {\n\t[IC_TASK_ENCODER] = {\n\t\t.rsc = IC_PRP_ENC_RSC,\n\t\t.tpmem_csc = {0x2008, 0},\n\t},\n\t[IC_TASK_VIEWFINDER] = {\n\t\t.rsc = IC_PRP_VF_RSC,\n\t\t.tpmem_csc = {0x4028, 0x4040},\n\t},\n\t[IC_TASK_POST_PROCESSOR] = {\n\t\t.rsc = IC_PP_RSC,\n\t\t.tpmem_csc = {0x6060, 0x6078},\n\t},\n};\n\nstatic const struct ic_task_bitfields ic_task_bit[IC_NUM_TASKS] = {\n\t[IC_TASK_ENCODER] = {\n\t\t.ic_conf_en = IC_CONF_PRPENC_EN,\n\t\t.ic_conf_rot_en = IC_CONF_PRPENC_ROT_EN,\n\t\t.ic_conf_cmb_en = 0,     \n\t\t.ic_conf_csc1_en = IC_CONF_PRPENC_CSC1,\n\t\t.ic_conf_csc2_en = 0,    \n\t\t.ic_cmb_galpha_bit = 0,  \n\t},\n\t[IC_TASK_VIEWFINDER] = {\n\t\t.ic_conf_en = IC_CONF_PRPVF_EN,\n\t\t.ic_conf_rot_en = IC_CONF_PRPVF_ROT_EN,\n\t\t.ic_conf_cmb_en = IC_CONF_PRPVF_CMB,\n\t\t.ic_conf_csc1_en = IC_CONF_PRPVF_CSC1,\n\t\t.ic_conf_csc2_en = IC_CONF_PRPVF_CSC2,\n\t\t.ic_cmb_galpha_bit = 0,\n\t},\n\t[IC_TASK_POST_PROCESSOR] = {\n\t\t.ic_conf_en = IC_CONF_PP_EN,\n\t\t.ic_conf_rot_en = IC_CONF_PP_ROT_EN,\n\t\t.ic_conf_cmb_en = IC_CONF_PP_CMB,\n\t\t.ic_conf_csc1_en = IC_CONF_PP_CSC1,\n\t\t.ic_conf_csc2_en = IC_CONF_PP_CSC2,\n\t\t.ic_cmb_galpha_bit = 8,\n\t},\n};\n\nstruct ipu_ic_priv;\n\nstruct ipu_ic {\n\tenum ipu_ic_task task;\n\tconst struct ic_task_regoffs *reg;\n\tconst struct ic_task_bitfields *bit;\n\n\tstruct ipu_ic_colorspace in_cs;\n\tstruct ipu_ic_colorspace g_in_cs;\n\tstruct ipu_ic_colorspace out_cs;\n\n\tbool graphics;\n\tbool rotation;\n\tbool in_use;\n\n\tstruct ipu_ic_priv *priv;\n};\n\nstruct ipu_ic_priv {\n\tvoid __iomem *base;\n\tvoid __iomem *tpmem_base;\n\tspinlock_t lock;\n\tstruct ipu_soc *ipu;\n\tint use_count;\n\tint irt_use_count;\n\tstruct ipu_ic task[IC_NUM_TASKS];\n};\n\nstatic inline u32 ipu_ic_read(struct ipu_ic *ic, unsigned offset)\n{\n\treturn readl(ic->priv->base + offset);\n}\n\nstatic inline void ipu_ic_write(struct ipu_ic *ic, u32 value, unsigned offset)\n{\n\twritel(value, ic->priv->base + offset);\n}\n\nstatic int init_csc(struct ipu_ic *ic,\n\t\t    const struct ipu_ic_csc *csc,\n\t\t    int csc_index)\n{\n\tstruct ipu_ic_priv *priv = ic->priv;\n\tu32 __iomem *base;\n\tconst u16 (*c)[3];\n\tconst u16 *a;\n\tu32 param;\n\n\tbase = (u32 __iomem *)\n\t\t(priv->tpmem_base + ic->reg->tpmem_csc[csc_index]);\n\n\t \n\tc = (const u16 (*)[3])csc->params.coeff;\n\ta = (const u16 *)csc->params.offset;\n\n\tparam = ((a[0] & 0x1f) << 27) | ((c[0][0] & 0x1ff) << 18) |\n\t\t((c[1][1] & 0x1ff) << 9) | (c[2][2] & 0x1ff);\n\twritel(param, base++);\n\n\tparam = ((a[0] & 0x1fe0) >> 5) | (csc->params.scale << 8) |\n\t\t(csc->params.sat << 10);\n\twritel(param, base++);\n\n\tparam = ((a[1] & 0x1f) << 27) | ((c[0][1] & 0x1ff) << 18) |\n\t\t((c[1][0] & 0x1ff) << 9) | (c[2][0] & 0x1ff);\n\twritel(param, base++);\n\n\tparam = ((a[1] & 0x1fe0) >> 5);\n\twritel(param, base++);\n\n\tparam = ((a[2] & 0x1f) << 27) | ((c[0][2] & 0x1ff) << 18) |\n\t\t((c[1][2] & 0x1ff) << 9) | (c[2][1] & 0x1ff);\n\twritel(param, base++);\n\n\tparam = ((a[2] & 0x1fe0) >> 5);\n\twritel(param, base++);\n\n\treturn 0;\n}\n\nstatic int calc_resize_coeffs(struct ipu_ic *ic,\n\t\t\t      u32 in_size, u32 out_size,\n\t\t\t      u32 *resize_coeff,\n\t\t\t      u32 *downsize_coeff)\n{\n\tstruct ipu_ic_priv *priv = ic->priv;\n\tstruct ipu_soc *ipu = priv->ipu;\n\tu32 temp_size, temp_downsize;\n\n\t \n\tif (in_size > 4096) {\n\t\tdev_err(ipu->dev, \"Unsupported resize (in_size > 4096)\\n\");\n\t\treturn -EINVAL;\n\t}\n\tif (out_size > 1024) {\n\t\tdev_err(ipu->dev, \"Unsupported resize (out_size > 1024)\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif ((out_size << 2) < in_size) {\n\t\tdev_err(ipu->dev, \"Unsupported downsize\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\ttemp_downsize = 0;\n\ttemp_size = in_size;\n\twhile (((temp_size > 1024) || (temp_size >= out_size * 2)) &&\n\t       (temp_downsize < 2)) {\n\t\ttemp_size >>= 1;\n\t\ttemp_downsize++;\n\t}\n\t*downsize_coeff = temp_downsize;\n\n\t \n\t*resize_coeff = (8192L * (temp_size - 1)) / (out_size - 1);\n\tif (*resize_coeff >= 16384L) {\n\t\tdev_err(ipu->dev, \"Warning! Overflow on resize coeff.\\n\");\n\t\t*resize_coeff = 0x3FFF;\n\t}\n\n\treturn 0;\n}\n\nvoid ipu_ic_task_enable(struct ipu_ic *ic)\n{\n\tstruct ipu_ic_priv *priv = ic->priv;\n\tunsigned long flags;\n\tu32 ic_conf;\n\n\tspin_lock_irqsave(&priv->lock, flags);\n\n\tic_conf = ipu_ic_read(ic, IC_CONF);\n\n\tic_conf |= ic->bit->ic_conf_en;\n\n\tif (ic->rotation)\n\t\tic_conf |= ic->bit->ic_conf_rot_en;\n\n\tif (ic->in_cs.cs != ic->out_cs.cs)\n\t\tic_conf |= ic->bit->ic_conf_csc1_en;\n\n\tif (ic->graphics) {\n\t\tic_conf |= ic->bit->ic_conf_cmb_en;\n\t\tic_conf |= ic->bit->ic_conf_csc1_en;\n\n\t\tif (ic->g_in_cs.cs != ic->out_cs.cs)\n\t\t\tic_conf |= ic->bit->ic_conf_csc2_en;\n\t}\n\n\tipu_ic_write(ic, ic_conf, IC_CONF);\n\n\tspin_unlock_irqrestore(&priv->lock, flags);\n}\nEXPORT_SYMBOL_GPL(ipu_ic_task_enable);\n\nvoid ipu_ic_task_disable(struct ipu_ic *ic)\n{\n\tstruct ipu_ic_priv *priv = ic->priv;\n\tunsigned long flags;\n\tu32 ic_conf;\n\n\tspin_lock_irqsave(&priv->lock, flags);\n\n\tic_conf = ipu_ic_read(ic, IC_CONF);\n\n\tic_conf &= ~(ic->bit->ic_conf_en |\n\t\t     ic->bit->ic_conf_csc1_en |\n\t\t     ic->bit->ic_conf_rot_en);\n\tif (ic->bit->ic_conf_csc2_en)\n\t\tic_conf &= ~ic->bit->ic_conf_csc2_en;\n\tif (ic->bit->ic_conf_cmb_en)\n\t\tic_conf &= ~ic->bit->ic_conf_cmb_en;\n\n\tipu_ic_write(ic, ic_conf, IC_CONF);\n\n\tspin_unlock_irqrestore(&priv->lock, flags);\n}\nEXPORT_SYMBOL_GPL(ipu_ic_task_disable);\n\nint ipu_ic_task_graphics_init(struct ipu_ic *ic,\n\t\t\t      const struct ipu_ic_colorspace *g_in_cs,\n\t\t\t      bool galpha_en, u32 galpha,\n\t\t\t      bool colorkey_en, u32 colorkey)\n{\n\tstruct ipu_ic_priv *priv = ic->priv;\n\tstruct ipu_ic_csc csc2;\n\tunsigned long flags;\n\tu32 reg, ic_conf;\n\tint ret = 0;\n\n\tif (ic->task == IC_TASK_ENCODER)\n\t\treturn -EINVAL;\n\n\tspin_lock_irqsave(&priv->lock, flags);\n\n\tic_conf = ipu_ic_read(ic, IC_CONF);\n\n\tif (!(ic_conf & ic->bit->ic_conf_csc1_en)) {\n\t\tstruct ipu_ic_csc csc1;\n\n\t\tret = ipu_ic_calc_csc(&csc1,\n\t\t\t\t      V4L2_YCBCR_ENC_601,\n\t\t\t\t      V4L2_QUANTIZATION_FULL_RANGE,\n\t\t\t\t      IPUV3_COLORSPACE_RGB,\n\t\t\t\t      V4L2_YCBCR_ENC_601,\n\t\t\t\t      V4L2_QUANTIZATION_FULL_RANGE,\n\t\t\t\t      IPUV3_COLORSPACE_RGB);\n\t\tif (ret)\n\t\t\tgoto unlock;\n\n\t\t \n\t\tret = init_csc(ic, &csc1, 0);\n\t\tif (ret)\n\t\t\tgoto unlock;\n\t}\n\n\tic->g_in_cs = *g_in_cs;\n\tcsc2.in_cs = ic->g_in_cs;\n\tcsc2.out_cs = ic->out_cs;\n\n\tret = __ipu_ic_calc_csc(&csc2);\n\tif (ret)\n\t\tgoto unlock;\n\n\tret = init_csc(ic, &csc2, 1);\n\tif (ret)\n\t\tgoto unlock;\n\n\tif (galpha_en) {\n\t\tic_conf |= IC_CONF_IC_GLB_LOC_A;\n\t\treg = ipu_ic_read(ic, IC_CMBP_1);\n\t\treg &= ~(0xff << ic->bit->ic_cmb_galpha_bit);\n\t\treg |= (galpha << ic->bit->ic_cmb_galpha_bit);\n\t\tipu_ic_write(ic, reg, IC_CMBP_1);\n\t} else\n\t\tic_conf &= ~IC_CONF_IC_GLB_LOC_A;\n\n\tif (colorkey_en) {\n\t\tic_conf |= IC_CONF_KEY_COLOR_EN;\n\t\tipu_ic_write(ic, colorkey, IC_CMBP_2);\n\t} else\n\t\tic_conf &= ~IC_CONF_KEY_COLOR_EN;\n\n\tipu_ic_write(ic, ic_conf, IC_CONF);\n\n\tic->graphics = true;\nunlock:\n\tspin_unlock_irqrestore(&priv->lock, flags);\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(ipu_ic_task_graphics_init);\n\nint ipu_ic_task_init_rsc(struct ipu_ic *ic,\n\t\t\t const struct ipu_ic_csc *csc,\n\t\t\t int in_width, int in_height,\n\t\t\t int out_width, int out_height,\n\t\t\t u32 rsc)\n{\n\tstruct ipu_ic_priv *priv = ic->priv;\n\tu32 downsize_coeff, resize_coeff;\n\tunsigned long flags;\n\tint ret = 0;\n\n\tif (!rsc) {\n\t\t \n\n\t\tret = calc_resize_coeffs(ic, in_height, out_height,\n\t\t\t\t\t &resize_coeff, &downsize_coeff);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\trsc = (downsize_coeff << 30) | (resize_coeff << 16);\n\n\t\t \n\t\tret = calc_resize_coeffs(ic, in_width, out_width,\n\t\t\t\t\t &resize_coeff, &downsize_coeff);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\trsc |= (downsize_coeff << 14) | resize_coeff;\n\t}\n\n\tspin_lock_irqsave(&priv->lock, flags);\n\n\tipu_ic_write(ic, rsc, ic->reg->rsc);\n\n\t \n\tic->in_cs = csc->in_cs;\n\tic->out_cs = csc->out_cs;\n\n\tret = init_csc(ic, csc, 0);\n\n\tspin_unlock_irqrestore(&priv->lock, flags);\n\treturn ret;\n}\n\nint ipu_ic_task_init(struct ipu_ic *ic,\n\t\t     const struct ipu_ic_csc *csc,\n\t\t     int in_width, int in_height,\n\t\t     int out_width, int out_height)\n{\n\treturn ipu_ic_task_init_rsc(ic, csc,\n\t\t\t\t    in_width, in_height,\n\t\t\t\t    out_width, out_height, 0);\n}\nEXPORT_SYMBOL_GPL(ipu_ic_task_init);\n\nint ipu_ic_task_idma_init(struct ipu_ic *ic, struct ipuv3_channel *channel,\n\t\t\t  u32 width, u32 height, int burst_size,\n\t\t\t  enum ipu_rotate_mode rot)\n{\n\tstruct ipu_ic_priv *priv = ic->priv;\n\tstruct ipu_soc *ipu = priv->ipu;\n\tu32 ic_idmac_1, ic_idmac_2, ic_idmac_3;\n\tu32 temp_rot = bitrev8(rot) >> 5;\n\tbool need_hor_flip = false;\n\tunsigned long flags;\n\tint ret = 0;\n\n\tif ((burst_size != 8) && (burst_size != 16)) {\n\t\tdev_err(ipu->dev, \"Illegal burst length for IC\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\twidth--;\n\theight--;\n\n\tif (temp_rot & 0x2)\t \n\t\tneed_hor_flip = true;\n\n\tspin_lock_irqsave(&priv->lock, flags);\n\n\tic_idmac_1 = ipu_ic_read(ic, IC_IDMAC_1);\n\tic_idmac_2 = ipu_ic_read(ic, IC_IDMAC_2);\n\tic_idmac_3 = ipu_ic_read(ic, IC_IDMAC_3);\n\n\tswitch (channel->num) {\n\tcase IPUV3_CHANNEL_IC_PP_MEM:\n\t\tif (burst_size == 16)\n\t\t\tic_idmac_1 |= IC_IDMAC_1_CB2_BURST_16;\n\t\telse\n\t\t\tic_idmac_1 &= ~IC_IDMAC_1_CB2_BURST_16;\n\n\t\tif (need_hor_flip)\n\t\t\tic_idmac_1 |= IC_IDMAC_1_PP_FLIP_RS;\n\t\telse\n\t\t\tic_idmac_1 &= ~IC_IDMAC_1_PP_FLIP_RS;\n\n\t\tic_idmac_2 &= ~IC_IDMAC_2_PP_HEIGHT_MASK;\n\t\tic_idmac_2 |= height << IC_IDMAC_2_PP_HEIGHT_OFFSET;\n\n\t\tic_idmac_3 &= ~IC_IDMAC_3_PP_WIDTH_MASK;\n\t\tic_idmac_3 |= width << IC_IDMAC_3_PP_WIDTH_OFFSET;\n\t\tbreak;\n\tcase IPUV3_CHANNEL_MEM_IC_PP:\n\t\tif (burst_size == 16)\n\t\t\tic_idmac_1 |= IC_IDMAC_1_CB5_BURST_16;\n\t\telse\n\t\t\tic_idmac_1 &= ~IC_IDMAC_1_CB5_BURST_16;\n\t\tbreak;\n\tcase IPUV3_CHANNEL_MEM_ROT_PP:\n\t\tic_idmac_1 &= ~IC_IDMAC_1_PP_ROT_MASK;\n\t\tic_idmac_1 |= temp_rot << IC_IDMAC_1_PP_ROT_OFFSET;\n\t\tbreak;\n\tcase IPUV3_CHANNEL_MEM_IC_PRP_VF:\n\t\tif (burst_size == 16)\n\t\t\tic_idmac_1 |= IC_IDMAC_1_CB6_BURST_16;\n\t\telse\n\t\t\tic_idmac_1 &= ~IC_IDMAC_1_CB6_BURST_16;\n\t\tbreak;\n\tcase IPUV3_CHANNEL_IC_PRP_ENC_MEM:\n\t\tif (burst_size == 16)\n\t\t\tic_idmac_1 |= IC_IDMAC_1_CB0_BURST_16;\n\t\telse\n\t\t\tic_idmac_1 &= ~IC_IDMAC_1_CB0_BURST_16;\n\n\t\tif (need_hor_flip)\n\t\t\tic_idmac_1 |= IC_IDMAC_1_PRPENC_FLIP_RS;\n\t\telse\n\t\t\tic_idmac_1 &= ~IC_IDMAC_1_PRPENC_FLIP_RS;\n\n\t\tic_idmac_2 &= ~IC_IDMAC_2_PRPENC_HEIGHT_MASK;\n\t\tic_idmac_2 |= height << IC_IDMAC_2_PRPENC_HEIGHT_OFFSET;\n\n\t\tic_idmac_3 &= ~IC_IDMAC_3_PRPENC_WIDTH_MASK;\n\t\tic_idmac_3 |= width << IC_IDMAC_3_PRPENC_WIDTH_OFFSET;\n\t\tbreak;\n\tcase IPUV3_CHANNEL_MEM_ROT_ENC:\n\t\tic_idmac_1 &= ~IC_IDMAC_1_PRPENC_ROT_MASK;\n\t\tic_idmac_1 |= temp_rot << IC_IDMAC_1_PRPENC_ROT_OFFSET;\n\t\tbreak;\n\tcase IPUV3_CHANNEL_IC_PRP_VF_MEM:\n\t\tif (burst_size == 16)\n\t\t\tic_idmac_1 |= IC_IDMAC_1_CB1_BURST_16;\n\t\telse\n\t\t\tic_idmac_1 &= ~IC_IDMAC_1_CB1_BURST_16;\n\n\t\tif (need_hor_flip)\n\t\t\tic_idmac_1 |= IC_IDMAC_1_PRPVF_FLIP_RS;\n\t\telse\n\t\t\tic_idmac_1 &= ~IC_IDMAC_1_PRPVF_FLIP_RS;\n\n\t\tic_idmac_2 &= ~IC_IDMAC_2_PRPVF_HEIGHT_MASK;\n\t\tic_idmac_2 |= height << IC_IDMAC_2_PRPVF_HEIGHT_OFFSET;\n\n\t\tic_idmac_3 &= ~IC_IDMAC_3_PRPVF_WIDTH_MASK;\n\t\tic_idmac_3 |= width << IC_IDMAC_3_PRPVF_WIDTH_OFFSET;\n\t\tbreak;\n\tcase IPUV3_CHANNEL_MEM_ROT_VF:\n\t\tic_idmac_1 &= ~IC_IDMAC_1_PRPVF_ROT_MASK;\n\t\tic_idmac_1 |= temp_rot << IC_IDMAC_1_PRPVF_ROT_OFFSET;\n\t\tbreak;\n\tcase IPUV3_CHANNEL_G_MEM_IC_PRP_VF:\n\t\tif (burst_size == 16)\n\t\t\tic_idmac_1 |= IC_IDMAC_1_CB3_BURST_16;\n\t\telse\n\t\t\tic_idmac_1 &= ~IC_IDMAC_1_CB3_BURST_16;\n\t\tbreak;\n\tcase IPUV3_CHANNEL_G_MEM_IC_PP:\n\t\tif (burst_size == 16)\n\t\t\tic_idmac_1 |= IC_IDMAC_1_CB4_BURST_16;\n\t\telse\n\t\t\tic_idmac_1 &= ~IC_IDMAC_1_CB4_BURST_16;\n\t\tbreak;\n\tcase IPUV3_CHANNEL_VDI_MEM_IC_VF:\n\t\tif (burst_size == 16)\n\t\t\tic_idmac_1 |= IC_IDMAC_1_CB7_BURST_16;\n\t\telse\n\t\t\tic_idmac_1 &= ~IC_IDMAC_1_CB7_BURST_16;\n\t\tbreak;\n\tdefault:\n\t\tgoto unlock;\n\t}\n\n\tipu_ic_write(ic, ic_idmac_1, IC_IDMAC_1);\n\tipu_ic_write(ic, ic_idmac_2, IC_IDMAC_2);\n\tipu_ic_write(ic, ic_idmac_3, IC_IDMAC_3);\n\n\tif (ipu_rot_mode_is_irt(rot))\n\t\tic->rotation = true;\n\nunlock:\n\tspin_unlock_irqrestore(&priv->lock, flags);\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(ipu_ic_task_idma_init);\n\nstatic void ipu_irt_enable(struct ipu_ic *ic)\n{\n\tstruct ipu_ic_priv *priv = ic->priv;\n\n\tif (!priv->irt_use_count)\n\t\tipu_module_enable(priv->ipu, IPU_CONF_ROT_EN);\n\n\tpriv->irt_use_count++;\n}\n\nstatic void ipu_irt_disable(struct ipu_ic *ic)\n{\n\tstruct ipu_ic_priv *priv = ic->priv;\n\n\tif (priv->irt_use_count) {\n\t\tif (!--priv->irt_use_count)\n\t\t\tipu_module_disable(priv->ipu, IPU_CONF_ROT_EN);\n\t}\n}\n\nint ipu_ic_enable(struct ipu_ic *ic)\n{\n\tstruct ipu_ic_priv *priv = ic->priv;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&priv->lock, flags);\n\n\tif (!priv->use_count)\n\t\tipu_module_enable(priv->ipu, IPU_CONF_IC_EN);\n\n\tpriv->use_count++;\n\n\tif (ic->rotation)\n\t\tipu_irt_enable(ic);\n\n\tspin_unlock_irqrestore(&priv->lock, flags);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(ipu_ic_enable);\n\nint ipu_ic_disable(struct ipu_ic *ic)\n{\n\tstruct ipu_ic_priv *priv = ic->priv;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&priv->lock, flags);\n\n\tpriv->use_count--;\n\n\tif (!priv->use_count)\n\t\tipu_module_disable(priv->ipu, IPU_CONF_IC_EN);\n\n\tif (priv->use_count < 0)\n\t\tpriv->use_count = 0;\n\n\tif (ic->rotation)\n\t\tipu_irt_disable(ic);\n\n\tic->rotation = ic->graphics = false;\n\n\tspin_unlock_irqrestore(&priv->lock, flags);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(ipu_ic_disable);\n\nstruct ipu_ic *ipu_ic_get(struct ipu_soc *ipu, enum ipu_ic_task task)\n{\n\tstruct ipu_ic_priv *priv = ipu->ic_priv;\n\tunsigned long flags;\n\tstruct ipu_ic *ic, *ret;\n\n\tif (task >= IC_NUM_TASKS)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tic = &priv->task[task];\n\n\tspin_lock_irqsave(&priv->lock, flags);\n\n\tif (ic->in_use) {\n\t\tret = ERR_PTR(-EBUSY);\n\t\tgoto unlock;\n\t}\n\n\tic->in_use = true;\n\tret = ic;\n\nunlock:\n\tspin_unlock_irqrestore(&priv->lock, flags);\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(ipu_ic_get);\n\nvoid ipu_ic_put(struct ipu_ic *ic)\n{\n\tstruct ipu_ic_priv *priv = ic->priv;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&priv->lock, flags);\n\tic->in_use = false;\n\tspin_unlock_irqrestore(&priv->lock, flags);\n}\nEXPORT_SYMBOL_GPL(ipu_ic_put);\n\nint ipu_ic_init(struct ipu_soc *ipu, struct device *dev,\n\t\tunsigned long base, unsigned long tpmem_base)\n{\n\tstruct ipu_ic_priv *priv;\n\tint i;\n\n\tpriv = devm_kzalloc(dev, sizeof(*priv), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\n\tipu->ic_priv = priv;\n\n\tspin_lock_init(&priv->lock);\n\tpriv->base = devm_ioremap(dev, base, PAGE_SIZE);\n\tif (!priv->base)\n\t\treturn -ENOMEM;\n\tpriv->tpmem_base = devm_ioremap(dev, tpmem_base, SZ_64K);\n\tif (!priv->tpmem_base)\n\t\treturn -ENOMEM;\n\n\tdev_dbg(dev, \"IC base: 0x%08lx remapped to %p\\n\", base, priv->base);\n\n\tpriv->ipu = ipu;\n\n\tfor (i = 0; i < IC_NUM_TASKS; i++) {\n\t\tpriv->task[i].task = i;\n\t\tpriv->task[i].priv = priv;\n\t\tpriv->task[i].reg = &ic_task_reg[i];\n\t\tpriv->task[i].bit = &ic_task_bit[i];\n\t}\n\n\treturn 0;\n}\n\nvoid ipu_ic_exit(struct ipu_soc *ipu)\n{\n}\n\nvoid ipu_ic_dump(struct ipu_ic *ic)\n{\n\tstruct ipu_ic_priv *priv = ic->priv;\n\tstruct ipu_soc *ipu = priv->ipu;\n\n\tdev_dbg(ipu->dev, \"IC_CONF = \\t0x%08X\\n\",\n\t\tipu_ic_read(ic, IC_CONF));\n\tdev_dbg(ipu->dev, \"IC_PRP_ENC_RSC = \\t0x%08X\\n\",\n\t\tipu_ic_read(ic, IC_PRP_ENC_RSC));\n\tdev_dbg(ipu->dev, \"IC_PRP_VF_RSC = \\t0x%08X\\n\",\n\t\tipu_ic_read(ic, IC_PRP_VF_RSC));\n\tdev_dbg(ipu->dev, \"IC_PP_RSC = \\t0x%08X\\n\",\n\t\tipu_ic_read(ic, IC_PP_RSC));\n\tdev_dbg(ipu->dev, \"IC_CMBP_1 = \\t0x%08X\\n\",\n\t\tipu_ic_read(ic, IC_CMBP_1));\n\tdev_dbg(ipu->dev, \"IC_CMBP_2 = \\t0x%08X\\n\",\n\t\tipu_ic_read(ic, IC_CMBP_2));\n\tdev_dbg(ipu->dev, \"IC_IDMAC_1 = \\t0x%08X\\n\",\n\t\tipu_ic_read(ic, IC_IDMAC_1));\n\tdev_dbg(ipu->dev, \"IC_IDMAC_2 = \\t0x%08X\\n\",\n\t\tipu_ic_read(ic, IC_IDMAC_2));\n\tdev_dbg(ipu->dev, \"IC_IDMAC_3 = \\t0x%08X\\n\",\n\t\tipu_ic_read(ic, IC_IDMAC_3));\n\tdev_dbg(ipu->dev, \"IC_IDMAC_4 = \\t0x%08X\\n\",\n\t\tipu_ic_read(ic, IC_IDMAC_4));\n}\nEXPORT_SYMBOL_GPL(ipu_ic_dump);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}