{
  "module_name": "ipu-image-convert.c",
  "hash_id": "a3e0b6157e0e8a35cc2d0d763e0382ea711044cc37a1700cbb858f2ed48a5fd6",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/ipu-v3/ipu-image-convert.c",
  "human_readable_source": "\n \n\n#include <linux/interrupt.h>\n#include <linux/dma-mapping.h>\n#include <linux/math.h>\n\n#include <video/imx-ipu-image-convert.h>\n\n#include \"ipu-prv.h\"\n\n \n\n#define MAX_STRIPES_W    4\n#define MAX_STRIPES_H    4\n#define MAX_TILES (MAX_STRIPES_W * MAX_STRIPES_H)\n\n#define MIN_W     16\n#define MIN_H     8\n#define MAX_W     4096\n#define MAX_H     4096\n\nenum ipu_image_convert_type {\n\tIMAGE_CONVERT_IN = 0,\n\tIMAGE_CONVERT_OUT,\n};\n\nstruct ipu_image_convert_dma_buf {\n\tvoid          *virt;\n\tdma_addr_t    phys;\n\tunsigned long len;\n};\n\nstruct ipu_image_convert_dma_chan {\n\tint in;\n\tint out;\n\tint rot_in;\n\tint rot_out;\n\tint vdi_in_p;\n\tint vdi_in;\n\tint vdi_in_n;\n};\n\n \nstruct ipu_image_tile {\n\tu32 width;\n\tu32 height;\n\tu32 left;\n\tu32 top;\n\t \n\tu32 size;\n\tu32 stride;\n\tu32 rot_stride;\n\t \n\tu32 offset;\n\t \n\tu32 u_off;\n\t \n\tu32 v_off;\n};\n\nstruct ipu_image_convert_image {\n\tstruct ipu_image base;\n\tenum ipu_image_convert_type type;\n\n\tconst struct ipu_image_pixfmt *fmt;\n\tunsigned int stride;\n\n\t \n\tunsigned int num_rows;\n\t \n\tunsigned int num_cols;\n\n\tstruct ipu_image_tile tile[MAX_TILES];\n};\n\nstruct ipu_image_pixfmt {\n\tu32\tfourcc;         \n\tint     bpp;            \n\tint     uv_width_dec;   \n\tint     uv_height_dec;  \n\tbool    planar;         \n\tbool    uv_swapped;     \n\tbool    uv_packed;      \n};\n\nstruct ipu_image_convert_ctx;\nstruct ipu_image_convert_chan;\nstruct ipu_image_convert_priv;\n\nenum eof_irq_mask {\n\tEOF_IRQ_IN      = BIT(0),\n\tEOF_IRQ_ROT_IN  = BIT(1),\n\tEOF_IRQ_OUT     = BIT(2),\n\tEOF_IRQ_ROT_OUT = BIT(3),\n};\n\n#define EOF_IRQ_COMPLETE (EOF_IRQ_IN | EOF_IRQ_OUT)\n#define EOF_IRQ_ROT_COMPLETE (EOF_IRQ_IN | EOF_IRQ_OUT |\t\\\n\t\t\t      EOF_IRQ_ROT_IN | EOF_IRQ_ROT_OUT)\n\nstruct ipu_image_convert_ctx {\n\tstruct ipu_image_convert_chan *chan;\n\n\tipu_image_convert_cb_t complete;\n\tvoid *complete_context;\n\n\t \n\tstruct ipu_image_convert_image in;\n\tstruct ipu_image_convert_image out;\n\tstruct ipu_ic_csc csc;\n\tenum ipu_rotate_mode rot_mode;\n\tu32 downsize_coeff_h;\n\tu32 downsize_coeff_v;\n\tu32 image_resize_coeff_h;\n\tu32 image_resize_coeff_v;\n\tu32 resize_coeffs_h[MAX_STRIPES_W];\n\tu32 resize_coeffs_v[MAX_STRIPES_H];\n\n\t \n\tstruct ipu_image_convert_dma_buf rot_intermediate[2];\n\n\t \n\tint cur_buf_num;\n\n\tbool aborting;\n\tstruct completion aborted;\n\n\t \n\tbool double_buffering;\n\t \n\tunsigned int num_tiles;\n\t \n\tunsigned int next_tile;\n\t \n\tunsigned int out_tile_map[MAX_TILES];\n\n\t \n\tenum eof_irq_mask eof_mask;\n\n\tstruct list_head list;\n};\n\nstruct ipu_image_convert_chan {\n\tstruct ipu_image_convert_priv *priv;\n\n\tenum ipu_ic_task ic_task;\n\tconst struct ipu_image_convert_dma_chan *dma_ch;\n\n\tstruct ipu_ic *ic;\n\tstruct ipuv3_channel *in_chan;\n\tstruct ipuv3_channel *out_chan;\n\tstruct ipuv3_channel *rotation_in_chan;\n\tstruct ipuv3_channel *rotation_out_chan;\n\n\t \n\tint in_eof_irq;\n\tint rot_in_eof_irq;\n\tint out_eof_irq;\n\tint rot_out_eof_irq;\n\n\tspinlock_t irqlock;\n\n\t \n\tstruct list_head ctx_list;\n\t \n\tstruct list_head pending_q;\n\t \n\tstruct list_head done_q;\n\n\t \n\tstruct ipu_image_convert_run *current_run;\n};\n\nstruct ipu_image_convert_priv {\n\tstruct ipu_image_convert_chan chan[IC_NUM_TASKS];\n\tstruct ipu_soc *ipu;\n};\n\nstatic const struct ipu_image_convert_dma_chan\nimage_convert_dma_chan[IC_NUM_TASKS] = {\n\t[IC_TASK_VIEWFINDER] = {\n\t\t.in = IPUV3_CHANNEL_MEM_IC_PRP_VF,\n\t\t.out = IPUV3_CHANNEL_IC_PRP_VF_MEM,\n\t\t.rot_in = IPUV3_CHANNEL_MEM_ROT_VF,\n\t\t.rot_out = IPUV3_CHANNEL_ROT_VF_MEM,\n\t\t.vdi_in_p = IPUV3_CHANNEL_MEM_VDI_PREV,\n\t\t.vdi_in = IPUV3_CHANNEL_MEM_VDI_CUR,\n\t\t.vdi_in_n = IPUV3_CHANNEL_MEM_VDI_NEXT,\n\t},\n\t[IC_TASK_POST_PROCESSOR] = {\n\t\t.in = IPUV3_CHANNEL_MEM_IC_PP,\n\t\t.out = IPUV3_CHANNEL_IC_PP_MEM,\n\t\t.rot_in = IPUV3_CHANNEL_MEM_ROT_PP,\n\t\t.rot_out = IPUV3_CHANNEL_ROT_PP_MEM,\n\t},\n};\n\nstatic const struct ipu_image_pixfmt image_convert_formats[] = {\n\t{\n\t\t.fourcc\t= V4L2_PIX_FMT_RGB565,\n\t\t.bpp    = 16,\n\t}, {\n\t\t.fourcc\t= V4L2_PIX_FMT_RGB24,\n\t\t.bpp    = 24,\n\t}, {\n\t\t.fourcc\t= V4L2_PIX_FMT_BGR24,\n\t\t.bpp    = 24,\n\t}, {\n\t\t.fourcc\t= V4L2_PIX_FMT_RGB32,\n\t\t.bpp    = 32,\n\t}, {\n\t\t.fourcc\t= V4L2_PIX_FMT_BGR32,\n\t\t.bpp    = 32,\n\t}, {\n\t\t.fourcc\t= V4L2_PIX_FMT_XRGB32,\n\t\t.bpp    = 32,\n\t}, {\n\t\t.fourcc\t= V4L2_PIX_FMT_XBGR32,\n\t\t.bpp    = 32,\n\t}, {\n\t\t.fourcc\t= V4L2_PIX_FMT_BGRX32,\n\t\t.bpp    = 32,\n\t}, {\n\t\t.fourcc\t= V4L2_PIX_FMT_RGBX32,\n\t\t.bpp    = 32,\n\t}, {\n\t\t.fourcc\t= V4L2_PIX_FMT_YUYV,\n\t\t.bpp    = 16,\n\t\t.uv_width_dec = 2,\n\t\t.uv_height_dec = 1,\n\t}, {\n\t\t.fourcc\t= V4L2_PIX_FMT_UYVY,\n\t\t.bpp    = 16,\n\t\t.uv_width_dec = 2,\n\t\t.uv_height_dec = 1,\n\t}, {\n\t\t.fourcc\t= V4L2_PIX_FMT_YUV420,\n\t\t.bpp    = 12,\n\t\t.planar = true,\n\t\t.uv_width_dec = 2,\n\t\t.uv_height_dec = 2,\n\t}, {\n\t\t.fourcc\t= V4L2_PIX_FMT_YVU420,\n\t\t.bpp    = 12,\n\t\t.planar = true,\n\t\t.uv_width_dec = 2,\n\t\t.uv_height_dec = 2,\n\t\t.uv_swapped = true,\n\t}, {\n\t\t.fourcc = V4L2_PIX_FMT_NV12,\n\t\t.bpp    = 12,\n\t\t.planar = true,\n\t\t.uv_width_dec = 2,\n\t\t.uv_height_dec = 2,\n\t\t.uv_packed = true,\n\t}, {\n\t\t.fourcc = V4L2_PIX_FMT_YUV422P,\n\t\t.bpp    = 16,\n\t\t.planar = true,\n\t\t.uv_width_dec = 2,\n\t\t.uv_height_dec = 1,\n\t}, {\n\t\t.fourcc = V4L2_PIX_FMT_NV16,\n\t\t.bpp    = 16,\n\t\t.planar = true,\n\t\t.uv_width_dec = 2,\n\t\t.uv_height_dec = 1,\n\t\t.uv_packed = true,\n\t},\n};\n\nstatic const struct ipu_image_pixfmt *get_format(u32 fourcc)\n{\n\tconst struct ipu_image_pixfmt *ret = NULL;\n\tunsigned int i;\n\n\tfor (i = 0; i < ARRAY_SIZE(image_convert_formats); i++) {\n\t\tif (image_convert_formats[i].fourcc == fourcc) {\n\t\t\tret = &image_convert_formats[i];\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn ret;\n}\n\nstatic void dump_format(struct ipu_image_convert_ctx *ctx,\n\t\t\tstruct ipu_image_convert_image *ic_image)\n{\n\tstruct ipu_image_convert_chan *chan = ctx->chan;\n\tstruct ipu_image_convert_priv *priv = chan->priv;\n\n\tdev_dbg(priv->ipu->dev,\n\t\t\"task %u: ctx %p: %s format: %dx%d (%dx%d tiles), %c%c%c%c\\n\",\n\t\tchan->ic_task, ctx,\n\t\tic_image->type == IMAGE_CONVERT_OUT ? \"Output\" : \"Input\",\n\t\tic_image->base.pix.width, ic_image->base.pix.height,\n\t\tic_image->num_cols, ic_image->num_rows,\n\t\tic_image->fmt->fourcc & 0xff,\n\t\t(ic_image->fmt->fourcc >> 8) & 0xff,\n\t\t(ic_image->fmt->fourcc >> 16) & 0xff,\n\t\t(ic_image->fmt->fourcc >> 24) & 0xff);\n}\n\nint ipu_image_convert_enum_format(int index, u32 *fourcc)\n{\n\tconst struct ipu_image_pixfmt *fmt;\n\n\tif (index >= (int)ARRAY_SIZE(image_convert_formats))\n\t\treturn -EINVAL;\n\n\t \n\tfmt = &image_convert_formats[index];\n\t*fourcc = fmt->fourcc;\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(ipu_image_convert_enum_format);\n\nstatic void free_dma_buf(struct ipu_image_convert_priv *priv,\n\t\t\t struct ipu_image_convert_dma_buf *buf)\n{\n\tif (buf->virt)\n\t\tdma_free_coherent(priv->ipu->dev,\n\t\t\t\t  buf->len, buf->virt, buf->phys);\n\tbuf->virt = NULL;\n\tbuf->phys = 0;\n}\n\nstatic int alloc_dma_buf(struct ipu_image_convert_priv *priv,\n\t\t\t struct ipu_image_convert_dma_buf *buf,\n\t\t\t int size)\n{\n\tbuf->len = PAGE_ALIGN(size);\n\tbuf->virt = dma_alloc_coherent(priv->ipu->dev, buf->len, &buf->phys,\n\t\t\t\t       GFP_DMA | GFP_KERNEL);\n\tif (!buf->virt) {\n\t\tdev_err(priv->ipu->dev, \"failed to alloc dma buffer\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\treturn 0;\n}\n\nstatic inline int num_stripes(int dim)\n{\n\treturn (dim - 1) / 1024 + 1;\n}\n\n \nstatic int calc_image_resize_coefficients(struct ipu_image_convert_ctx *ctx,\n\t\t\t\t\t  struct ipu_image *in,\n\t\t\t\t\t  struct ipu_image *out)\n{\n\tu32 downsized_width = in->rect.width;\n\tu32 downsized_height = in->rect.height;\n\tu32 downsize_coeff_v = 0;\n\tu32 downsize_coeff_h = 0;\n\tu32 resized_width = out->rect.width;\n\tu32 resized_height = out->rect.height;\n\tu32 resize_coeff_h;\n\tu32 resize_coeff_v;\n\tu32 cols;\n\tu32 rows;\n\n\tif (ipu_rot_mode_is_irt(ctx->rot_mode)) {\n\t\tresized_width = out->rect.height;\n\t\tresized_height = out->rect.width;\n\t}\n\n\t \n\tif (WARN_ON(resized_width == 0 || resized_height == 0))\n\t\treturn -EINVAL;\n\n\twhile (downsized_width >= resized_width * 2) {\n\t\tdownsized_width >>= 1;\n\t\tdownsize_coeff_h++;\n\t}\n\n\twhile (downsized_height >= resized_height * 2) {\n\t\tdownsized_height >>= 1;\n\t\tdownsize_coeff_v++;\n\t}\n\n\t \n\tresize_coeff_h = 8192 * (downsized_width - 1) / (resized_width - 1);\n\tresize_coeff_v = 8192 * (downsized_height - 1) / (resized_height - 1);\n\n\t \n\tcols = num_stripes(max_t(u32, downsized_width, resized_width));\n\trows = num_stripes(max_t(u32, downsized_height, resized_height));\n\n\tdev_dbg(ctx->chan->priv->ipu->dev,\n\t\t\"%s: hscale: >>%u, *8192/%u vscale: >>%u, *8192/%u, %ux%u tiles\\n\",\n\t\t__func__, downsize_coeff_h, resize_coeff_h, downsize_coeff_v,\n\t\tresize_coeff_v, cols, rows);\n\n\tif (downsize_coeff_h > 2 || downsize_coeff_v  > 2 ||\n\t    resize_coeff_h > 0x3fff || resize_coeff_v > 0x3fff)\n\t\treturn -EINVAL;\n\n\tctx->downsize_coeff_h = downsize_coeff_h;\n\tctx->downsize_coeff_v = downsize_coeff_v;\n\tctx->image_resize_coeff_h = resize_coeff_h;\n\tctx->image_resize_coeff_v = resize_coeff_v;\n\tctx->in.num_cols = cols;\n\tctx->in.num_rows = rows;\n\n\treturn 0;\n}\n\n#define round_closest(x, y) round_down((x) + (y)/2, (y))\n\n \nstatic void find_best_seam(struct ipu_image_convert_ctx *ctx,\n\t\t\t   unsigned int index,\n\t\t\t   unsigned int in_edge,\n\t\t\t   unsigned int out_edge,\n\t\t\t   unsigned int in_align,\n\t\t\t   unsigned int out_align,\n\t\t\t   unsigned int in_burst,\n\t\t\t   unsigned int out_burst,\n\t\t\t   unsigned int downsize_coeff,\n\t\t\t   unsigned int resize_coeff,\n\t\t\t   u32 *_in_seam,\n\t\t\t   u32 *_out_seam)\n{\n\tstruct device *dev = ctx->chan->priv->ipu->dev;\n\tunsigned int out_pos;\n\t \n\tunsigned int out_seam = 0;\n\tunsigned int in_seam = 0;\n\tunsigned int min_diff = UINT_MAX;\n\tunsigned int out_start;\n\tunsigned int out_end;\n\tunsigned int in_start;\n\tunsigned int in_end;\n\n\t \n\tout_start = max_t(int, index * out_align, out_edge - 1024);\n\t \n\tout_end = min_t(unsigned int, out_edge, index * 1024 + 1);\n\n\t \n\tin_start = max_t(int, index * in_align,\n\t\t\t in_edge - (1024 << downsize_coeff));\n\tin_end = min_t(unsigned int, in_edge,\n\t\t       index * (1024 << downsize_coeff) + 1);\n\n\t \n\tout_start = round_up(out_start, out_align);\n\tfor (out_pos = out_start; out_pos < out_end; out_pos += out_align) {\n\t\tunsigned int in_pos;\n\t\tunsigned int in_pos_aligned;\n\t\tunsigned int in_pos_rounded;\n\t\tunsigned int diff;\n\n\t\t \n\t\tif ((out_burst > 1) && (out_edge - out_pos) % out_burst)\n\t\t\tcontinue;\n\n\t\t \n\t\tin_pos = (out_pos * resize_coeff) << downsize_coeff;\n\t\t \n\t\tin_pos_aligned = round_closest(in_pos, 8192U * in_align);\n\t\t \n\t\tin_pos_rounded = in_pos_aligned / 8192U;\n\n\t\tif (in_pos_rounded < in_start)\n\t\t\tcontinue;\n\t\tif (in_pos_rounded >= in_end)\n\t\t\tbreak;\n\n\t\tif ((in_burst > 1) &&\n\t\t    (in_edge - in_pos_rounded) % in_burst)\n\t\t\tcontinue;\n\n\t\tdiff = abs_diff(in_pos, in_pos_aligned);\n\t\tif (diff < min_diff) {\n\t\t\tin_seam = in_pos_rounded;\n\t\t\tout_seam = out_pos;\n\t\t\tmin_diff = diff;\n\t\t}\n\t}\n\n\t*_out_seam = out_seam;\n\t*_in_seam = in_seam;\n\n\tdev_dbg(dev, \"%s: out_seam %u(%u) in [%u, %u], in_seam %u(%u) in [%u, %u] diff %u.%03u\\n\",\n\t\t__func__, out_seam, out_align, out_start, out_end,\n\t\tin_seam, in_align, in_start, in_end, min_diff / 8192,\n\t\tDIV_ROUND_CLOSEST(min_diff % 8192 * 1000, 8192));\n}\n\n \nstatic inline u32 tile_left_align(const struct ipu_image_pixfmt *fmt)\n{\n\tif (fmt->planar)\n\t\treturn fmt->uv_packed ? 8 : 8 * fmt->uv_width_dec;\n\telse\n\t\treturn fmt->bpp == 32 ? 2 : fmt->bpp == 16 ? 4 : 8;\n}\n\n \nstatic inline u32 tile_top_align(const struct ipu_image_pixfmt *fmt)\n{\n\treturn fmt->uv_height_dec > 1 ? 2 : 1;\n}\n\nstatic inline u32 tile_width_align(enum ipu_image_convert_type type,\n\t\t\t\t   const struct ipu_image_pixfmt *fmt,\n\t\t\t\t   enum ipu_rotate_mode rot_mode)\n{\n\tif (type == IMAGE_CONVERT_IN) {\n\t\t \n\t\treturn (!ipu_rot_mode_is_irt(rot_mode) &&\n\t\t\t(rot_mode & IPU_ROT_BIT_HFLIP)) ? 8 : 2;\n\t}\n\n\t \n\treturn (ipu_rot_mode_is_irt(rot_mode) &&\n\t\tfmt->planar && !fmt->uv_packed) ?\n\t\t8 * fmt->uv_width_dec : 8;\n}\n\nstatic inline u32 tile_height_align(enum ipu_image_convert_type type,\n\t\t\t\t    const struct ipu_image_pixfmt *fmt,\n\t\t\t\t    enum ipu_rotate_mode rot_mode)\n{\n\tif (type == IMAGE_CONVERT_IN || !ipu_rot_mode_is_irt(rot_mode))\n\t\treturn 2;\n\n\t \n\treturn (fmt->planar && !fmt->uv_packed) ? 8 * fmt->uv_width_dec : 8;\n}\n\n \nstatic void fill_tile_column(struct ipu_image_convert_ctx *ctx,\n\t\t\t     unsigned int col,\n\t\t\t     struct ipu_image_convert_image *in,\n\t\t\t     unsigned int in_left, unsigned int in_width,\n\t\t\t     struct ipu_image_convert_image *out,\n\t\t\t     unsigned int out_left, unsigned int out_width)\n{\n\tunsigned int row, tile_idx;\n\tstruct ipu_image_tile *in_tile, *out_tile;\n\n\tfor (row = 0; row < in->num_rows; row++) {\n\t\ttile_idx = in->num_cols * row + col;\n\t\tin_tile = &in->tile[tile_idx];\n\t\tout_tile = &out->tile[ctx->out_tile_map[tile_idx]];\n\n\t\tin_tile->left = in_left;\n\t\tin_tile->width = in_width;\n\n\t\tif (ipu_rot_mode_is_irt(ctx->rot_mode)) {\n\t\t\tout_tile->top = out_left;\n\t\t\tout_tile->height = out_width;\n\t\t} else {\n\t\t\tout_tile->left = out_left;\n\t\t\tout_tile->width = out_width;\n\t\t}\n\t}\n}\n\n \nstatic void fill_tile_row(struct ipu_image_convert_ctx *ctx, unsigned int row,\n\t\t\t  struct ipu_image_convert_image *in,\n\t\t\t  unsigned int in_top, unsigned int in_height,\n\t\t\t  struct ipu_image_convert_image *out,\n\t\t\t  unsigned int out_top, unsigned int out_height)\n{\n\tunsigned int col, tile_idx;\n\tstruct ipu_image_tile *in_tile, *out_tile;\n\n\tfor (col = 0; col < in->num_cols; col++) {\n\t\ttile_idx = in->num_cols * row + col;\n\t\tin_tile = &in->tile[tile_idx];\n\t\tout_tile = &out->tile[ctx->out_tile_map[tile_idx]];\n\n\t\tin_tile->top = in_top;\n\t\tin_tile->height = in_height;\n\n\t\tif (ipu_rot_mode_is_irt(ctx->rot_mode)) {\n\t\t\tout_tile->left = out_top;\n\t\t\tout_tile->width = out_height;\n\t\t} else {\n\t\t\tout_tile->top = out_top;\n\t\t\tout_tile->height = out_height;\n\t\t}\n\t}\n}\n\n \nstatic void find_seams(struct ipu_image_convert_ctx *ctx,\n\t\t       struct ipu_image_convert_image *in,\n\t\t       struct ipu_image_convert_image *out)\n{\n\tstruct device *dev = ctx->chan->priv->ipu->dev;\n\tunsigned int resized_width = out->base.rect.width;\n\tunsigned int resized_height = out->base.rect.height;\n\tunsigned int col;\n\tunsigned int row;\n\tunsigned int in_left_align = tile_left_align(in->fmt);\n\tunsigned int in_top_align = tile_top_align(in->fmt);\n\tunsigned int out_left_align = tile_left_align(out->fmt);\n\tunsigned int out_top_align = tile_top_align(out->fmt);\n\tunsigned int out_width_align = tile_width_align(out->type, out->fmt,\n\t\t\t\t\t\t\tctx->rot_mode);\n\tunsigned int out_height_align = tile_height_align(out->type, out->fmt,\n\t\t\t\t\t\t\t  ctx->rot_mode);\n\tunsigned int in_right = in->base.rect.width;\n\tunsigned int in_bottom = in->base.rect.height;\n\tunsigned int out_right = out->base.rect.width;\n\tunsigned int out_bottom = out->base.rect.height;\n\tunsigned int flipped_out_left;\n\tunsigned int flipped_out_top;\n\n\tif (ipu_rot_mode_is_irt(ctx->rot_mode)) {\n\t\t \n\t\tresized_width = out->base.rect.height;\n\t\tresized_height = out->base.rect.width;\n\t\tout_left_align = out_height_align;\n\t\tout_top_align = out_width_align;\n\t\tout_width_align = out_left_align;\n\t\tout_height_align = out_top_align;\n\t\tout_right = out->base.rect.height;\n\t\tout_bottom = out->base.rect.width;\n\t}\n\n\tfor (col = in->num_cols - 1; col > 0; col--) {\n\t\tbool allow_in_overshoot = ipu_rot_mode_is_irt(ctx->rot_mode) ||\n\t\t\t\t\t  !(ctx->rot_mode & IPU_ROT_BIT_HFLIP);\n\t\tbool allow_out_overshoot = (col < in->num_cols - 1) &&\n\t\t\t\t\t   !(ctx->rot_mode & IPU_ROT_BIT_HFLIP);\n\t\tunsigned int in_left;\n\t\tunsigned int out_left;\n\n\t\t \n\n\t\tfind_best_seam(ctx, col,\n\t\t\t       in_right, out_right,\n\t\t\t       in_left_align, out_left_align,\n\t\t\t       allow_in_overshoot ? 1 : 8  ,\n\t\t\t       allow_out_overshoot ? 1 : out_width_align,\n\t\t\t       ctx->downsize_coeff_h, ctx->image_resize_coeff_h,\n\t\t\t       &in_left, &out_left);\n\n\t\tif (ctx->rot_mode & IPU_ROT_BIT_HFLIP)\n\t\t\tflipped_out_left = resized_width - out_right;\n\t\telse\n\t\t\tflipped_out_left = out_left;\n\n\t\tfill_tile_column(ctx, col, in, in_left, in_right - in_left,\n\t\t\t\t out, flipped_out_left, out_right - out_left);\n\n\t\tdev_dbg(dev, \"%s: col %u: %u, %u -> %u, %u\\n\", __func__, col,\n\t\t\tin_left, in_right - in_left,\n\t\t\tflipped_out_left, out_right - out_left);\n\n\t\tin_right = in_left;\n\t\tout_right = out_left;\n\t}\n\n\tflipped_out_left = (ctx->rot_mode & IPU_ROT_BIT_HFLIP) ?\n\t\t\t   resized_width - out_right : 0;\n\n\tfill_tile_column(ctx, 0, in, 0, in_right,\n\t\t\t out, flipped_out_left, out_right);\n\n\tdev_dbg(dev, \"%s: col 0: 0, %u -> %u, %u\\n\", __func__,\n\t\tin_right, flipped_out_left, out_right);\n\n\tfor (row = in->num_rows - 1; row > 0; row--) {\n\t\tbool allow_overshoot = row < in->num_rows - 1;\n\t\tunsigned int in_top;\n\t\tunsigned int out_top;\n\n\t\tfind_best_seam(ctx, row,\n\t\t\t       in_bottom, out_bottom,\n\t\t\t       in_top_align, out_top_align,\n\t\t\t       1, allow_overshoot ? 1 : out_height_align,\n\t\t\t       ctx->downsize_coeff_v, ctx->image_resize_coeff_v,\n\t\t\t       &in_top, &out_top);\n\n\t\tif ((ctx->rot_mode & IPU_ROT_BIT_VFLIP) ^\n\t\t    ipu_rot_mode_is_irt(ctx->rot_mode))\n\t\t\tflipped_out_top = resized_height - out_bottom;\n\t\telse\n\t\t\tflipped_out_top = out_top;\n\n\t\tfill_tile_row(ctx, row, in, in_top, in_bottom - in_top,\n\t\t\t      out, flipped_out_top, out_bottom - out_top);\n\n\t\tdev_dbg(dev, \"%s: row %u: %u, %u -> %u, %u\\n\", __func__, row,\n\t\t\tin_top, in_bottom - in_top,\n\t\t\tflipped_out_top, out_bottom - out_top);\n\n\t\tin_bottom = in_top;\n\t\tout_bottom = out_top;\n\t}\n\n\tif ((ctx->rot_mode & IPU_ROT_BIT_VFLIP) ^\n\t    ipu_rot_mode_is_irt(ctx->rot_mode))\n\t\tflipped_out_top = resized_height - out_bottom;\n\telse\n\t\tflipped_out_top = 0;\n\n\tfill_tile_row(ctx, 0, in, 0, in_bottom,\n\t\t      out, flipped_out_top, out_bottom);\n\n\tdev_dbg(dev, \"%s: row 0: 0, %u -> %u, %u\\n\", __func__,\n\t\tin_bottom, flipped_out_top, out_bottom);\n}\n\nstatic int calc_tile_dimensions(struct ipu_image_convert_ctx *ctx,\n\t\t\t\tstruct ipu_image_convert_image *image)\n{\n\tstruct ipu_image_convert_chan *chan = ctx->chan;\n\tstruct ipu_image_convert_priv *priv = chan->priv;\n\tunsigned int max_width = 1024;\n\tunsigned int max_height = 1024;\n\tunsigned int i;\n\n\tif (image->type == IMAGE_CONVERT_IN) {\n\t\t \n\t\tmax_width <<= ctx->downsize_coeff_h;\n\t\tmax_height <<= ctx->downsize_coeff_v;\n\t}\n\n\tfor (i = 0; i < ctx->num_tiles; i++) {\n\t\tstruct ipu_image_tile *tile;\n\t\tconst unsigned int row = i / image->num_cols;\n\t\tconst unsigned int col = i % image->num_cols;\n\n\t\tif (image->type == IMAGE_CONVERT_OUT)\n\t\t\ttile = &image->tile[ctx->out_tile_map[i]];\n\t\telse\n\t\t\ttile = &image->tile[i];\n\n\t\ttile->size = ((tile->height * image->fmt->bpp) >> 3) *\n\t\t\ttile->width;\n\n\t\tif (image->fmt->planar) {\n\t\t\ttile->stride = tile->width;\n\t\t\ttile->rot_stride = tile->height;\n\t\t} else {\n\t\t\ttile->stride =\n\t\t\t\t(image->fmt->bpp * tile->width) >> 3;\n\t\t\ttile->rot_stride =\n\t\t\t\t(image->fmt->bpp * tile->height) >> 3;\n\t\t}\n\n\t\tdev_dbg(priv->ipu->dev,\n\t\t\t\"task %u: ctx %p: %s@[%u,%u]: %ux%u@%u,%u\\n\",\n\t\t\tchan->ic_task, ctx,\n\t\t\timage->type == IMAGE_CONVERT_IN ? \"Input\" : \"Output\",\n\t\t\trow, col,\n\t\t\ttile->width, tile->height, tile->left, tile->top);\n\n\t\tif (!tile->width || tile->width > max_width ||\n\t\t    !tile->height || tile->height > max_height) {\n\t\t\tdev_err(priv->ipu->dev, \"invalid %s tile size: %ux%u\\n\",\n\t\t\t\timage->type == IMAGE_CONVERT_IN ? \"input\" :\n\t\t\t\t\"output\", tile->width, tile->height);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n \nstatic int transform_tile_index(struct ipu_image_convert_ctx *ctx,\n\t\t\t\tint src_row, int src_col)\n{\n\tstruct ipu_image_convert_chan *chan = ctx->chan;\n\tstruct ipu_image_convert_priv *priv = chan->priv;\n\tstruct ipu_image_convert_image *s_image = &ctx->in;\n\tstruct ipu_image_convert_image *d_image = &ctx->out;\n\tint dst_row, dst_col;\n\n\t \n\tif (ctx->rot_mode == IPU_ROTATE_NONE)\n\t\treturn src_row * s_image->num_cols + src_col;\n\n\t \n\tsrc_row = src_row * 2 - (s_image->num_rows - 1);\n\tsrc_col = src_col * 2 - (s_image->num_cols - 1);\n\n\t \n\tif (ctx->rot_mode & IPU_ROT_BIT_90) {\n\t\tdst_col = -src_row;\n\t\tdst_row = src_col;\n\t} else {\n\t\tdst_col = src_col;\n\t\tdst_row = src_row;\n\t}\n\n\t \n\tif (ctx->rot_mode & IPU_ROT_BIT_HFLIP)\n\t\tdst_col = -dst_col;\n\tif (ctx->rot_mode & IPU_ROT_BIT_VFLIP)\n\t\tdst_row = -dst_row;\n\n\tdev_dbg(priv->ipu->dev, \"task %u: ctx %p: [%d,%d] --> [%d,%d]\\n\",\n\t\tchan->ic_task, ctx, src_col, src_row, dst_col, dst_row);\n\n\t \n\tdst_row += d_image->num_rows - 1;\n\tdst_col += d_image->num_cols - 1;\n\tdst_row /= 2;\n\tdst_col /= 2;\n\n\treturn dst_row * d_image->num_cols + dst_col;\n}\n\n \nstatic void calc_out_tile_map(struct ipu_image_convert_ctx *ctx)\n{\n\tstruct ipu_image_convert_image *s_image = &ctx->in;\n\tunsigned int row, col, tile = 0;\n\n\tfor (row = 0; row < s_image->num_rows; row++) {\n\t\tfor (col = 0; col < s_image->num_cols; col++) {\n\t\t\tctx->out_tile_map[tile] =\n\t\t\t\ttransform_tile_index(ctx, row, col);\n\t\t\ttile++;\n\t\t}\n\t}\n}\n\nstatic int calc_tile_offsets_planar(struct ipu_image_convert_ctx *ctx,\n\t\t\t\t    struct ipu_image_convert_image *image)\n{\n\tstruct ipu_image_convert_chan *chan = ctx->chan;\n\tstruct ipu_image_convert_priv *priv = chan->priv;\n\tconst struct ipu_image_pixfmt *fmt = image->fmt;\n\tunsigned int row, col, tile = 0;\n\tu32 H, top, y_stride, uv_stride;\n\tu32 uv_row_off, uv_col_off, uv_off, u_off, v_off;\n\tu32 y_row_off, y_col_off, y_off;\n\tu32 y_size, uv_size;\n\n\t \n\tH = image->base.pix.height;\n\n\ty_stride = image->stride;\n\tuv_stride = y_stride / fmt->uv_width_dec;\n\tif (fmt->uv_packed)\n\t\tuv_stride *= 2;\n\n\ty_size = H * y_stride;\n\tuv_size = y_size / (fmt->uv_width_dec * fmt->uv_height_dec);\n\n\tfor (row = 0; row < image->num_rows; row++) {\n\t\ttop = image->tile[tile].top;\n\t\ty_row_off = top * y_stride;\n\t\tuv_row_off = (top * uv_stride) / fmt->uv_height_dec;\n\n\t\tfor (col = 0; col < image->num_cols; col++) {\n\t\t\ty_col_off = image->tile[tile].left;\n\t\t\tuv_col_off = y_col_off / fmt->uv_width_dec;\n\t\t\tif (fmt->uv_packed)\n\t\t\t\tuv_col_off *= 2;\n\n\t\t\ty_off = y_row_off + y_col_off;\n\t\t\tuv_off = uv_row_off + uv_col_off;\n\n\t\t\tu_off = y_size - y_off + uv_off;\n\t\t\tv_off = (fmt->uv_packed) ? 0 : u_off + uv_size;\n\t\t\tif (fmt->uv_swapped)\n\t\t\t\tswap(u_off, v_off);\n\n\t\t\timage->tile[tile].offset = y_off;\n\t\t\timage->tile[tile].u_off = u_off;\n\t\t\timage->tile[tile++].v_off = v_off;\n\n\t\t\tif ((y_off & 0x7) || (u_off & 0x7) || (v_off & 0x7)) {\n\t\t\t\tdev_err(priv->ipu->dev,\n\t\t\t\t\t\"task %u: ctx %p: %s@[%d,%d]: \"\n\t\t\t\t\t\"y_off %08x, u_off %08x, v_off %08x\\n\",\n\t\t\t\t\tchan->ic_task, ctx,\n\t\t\t\t\timage->type == IMAGE_CONVERT_IN ?\n\t\t\t\t\t\"Input\" : \"Output\", row, col,\n\t\t\t\t\ty_off, u_off, v_off);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int calc_tile_offsets_packed(struct ipu_image_convert_ctx *ctx,\n\t\t\t\t    struct ipu_image_convert_image *image)\n{\n\tstruct ipu_image_convert_chan *chan = ctx->chan;\n\tstruct ipu_image_convert_priv *priv = chan->priv;\n\tconst struct ipu_image_pixfmt *fmt = image->fmt;\n\tunsigned int row, col, tile = 0;\n\tu32 bpp, stride, offset;\n\tu32 row_off, col_off;\n\n\t \n\tstride = image->stride;\n\tbpp = fmt->bpp;\n\n\tfor (row = 0; row < image->num_rows; row++) {\n\t\trow_off = image->tile[tile].top * stride;\n\n\t\tfor (col = 0; col < image->num_cols; col++) {\n\t\t\tcol_off = (image->tile[tile].left * bpp) >> 3;\n\n\t\t\toffset = row_off + col_off;\n\n\t\t\timage->tile[tile].offset = offset;\n\t\t\timage->tile[tile].u_off = 0;\n\t\t\timage->tile[tile++].v_off = 0;\n\n\t\t\tif (offset & 0x7) {\n\t\t\t\tdev_err(priv->ipu->dev,\n\t\t\t\t\t\"task %u: ctx %p: %s@[%d,%d]: \"\n\t\t\t\t\t\"phys %08x\\n\",\n\t\t\t\t\tchan->ic_task, ctx,\n\t\t\t\t\timage->type == IMAGE_CONVERT_IN ?\n\t\t\t\t\t\"Input\" : \"Output\", row, col,\n\t\t\t\t\trow_off + col_off);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int calc_tile_offsets(struct ipu_image_convert_ctx *ctx,\n\t\t\t      struct ipu_image_convert_image *image)\n{\n\tif (image->fmt->planar)\n\t\treturn calc_tile_offsets_planar(ctx, image);\n\n\treturn calc_tile_offsets_packed(ctx, image);\n}\n\n \nstatic u32 calc_resize_coeff(u32 input_size, u32 downsize_coeff,\n\t\t\t     u32 output_size, bool allow_overshoot)\n{\n\tu32 downsized = input_size >> downsize_coeff;\n\n\tif (allow_overshoot)\n\t\treturn DIV_ROUND_CLOSEST(8192 * downsized, output_size);\n\telse\n\t\treturn 8192 * (downsized - 1) / (output_size - 1);\n}\n\n \nstatic void calc_tile_resize_coefficients(struct ipu_image_convert_ctx *ctx)\n{\n\tstruct ipu_image_convert_chan *chan = ctx->chan;\n\tstruct ipu_image_convert_priv *priv = chan->priv;\n\tstruct ipu_image_tile *in_tile, *out_tile;\n\tunsigned int col, row, tile_idx;\n\tunsigned int last_output;\n\n\tfor (col = 0; col < ctx->in.num_cols; col++) {\n\t\tbool closest = (col < ctx->in.num_cols - 1) &&\n\t\t\t       !(ctx->rot_mode & IPU_ROT_BIT_HFLIP);\n\t\tu32 resized_width;\n\t\tu32 resize_coeff_h;\n\t\tu32 in_width;\n\n\t\ttile_idx = col;\n\t\tin_tile = &ctx->in.tile[tile_idx];\n\t\tout_tile = &ctx->out.tile[ctx->out_tile_map[tile_idx]];\n\n\t\tif (ipu_rot_mode_is_irt(ctx->rot_mode))\n\t\t\tresized_width = out_tile->height;\n\t\telse\n\t\t\tresized_width = out_tile->width;\n\n\t\tresize_coeff_h = calc_resize_coeff(in_tile->width,\n\t\t\t\t\t\t   ctx->downsize_coeff_h,\n\t\t\t\t\t\t   resized_width, closest);\n\n\t\tdev_dbg(priv->ipu->dev, \"%s: column %u hscale: *8192/%u\\n\",\n\t\t\t__func__, col, resize_coeff_h);\n\n\t\t \n\t\tresized_width = round_up(resized_width, 8);\n\n\t\t \n\t\tlast_output = resized_width - 1;\n\t\tif (closest && ((last_output * resize_coeff_h) % 8192))\n\t\t\tlast_output++;\n\t\tin_width = round_up(\n\t\t\t(DIV_ROUND_UP(last_output * resize_coeff_h, 8192) + 1)\n\t\t\t<< ctx->downsize_coeff_h, 8);\n\n\t\tfor (row = 0; row < ctx->in.num_rows; row++) {\n\t\t\ttile_idx = row * ctx->in.num_cols + col;\n\t\t\tin_tile = &ctx->in.tile[tile_idx];\n\t\t\tout_tile = &ctx->out.tile[ctx->out_tile_map[tile_idx]];\n\n\t\t\tif (ipu_rot_mode_is_irt(ctx->rot_mode))\n\t\t\t\tout_tile->height = resized_width;\n\t\t\telse\n\t\t\t\tout_tile->width = resized_width;\n\n\t\t\tin_tile->width = in_width;\n\t\t}\n\n\t\tctx->resize_coeffs_h[col] = resize_coeff_h;\n\t}\n\n\tfor (row = 0; row < ctx->in.num_rows; row++) {\n\t\tbool closest = (row < ctx->in.num_rows - 1) &&\n\t\t\t       !(ctx->rot_mode & IPU_ROT_BIT_VFLIP);\n\t\tu32 resized_height;\n\t\tu32 resize_coeff_v;\n\t\tu32 in_height;\n\n\t\ttile_idx = row * ctx->in.num_cols;\n\t\tin_tile = &ctx->in.tile[tile_idx];\n\t\tout_tile = &ctx->out.tile[ctx->out_tile_map[tile_idx]];\n\n\t\tif (ipu_rot_mode_is_irt(ctx->rot_mode))\n\t\t\tresized_height = out_tile->width;\n\t\telse\n\t\t\tresized_height = out_tile->height;\n\n\t\tresize_coeff_v = calc_resize_coeff(in_tile->height,\n\t\t\t\t\t\t   ctx->downsize_coeff_v,\n\t\t\t\t\t\t   resized_height, closest);\n\n\t\tdev_dbg(priv->ipu->dev, \"%s: row %u vscale: *8192/%u\\n\",\n\t\t\t__func__, row, resize_coeff_v);\n\n\t\t \n\t\tresized_height = round_up(resized_height, 2);\n\n\t\t \n\t\tlast_output = resized_height - 1;\n\t\tif (closest && ((last_output * resize_coeff_v) % 8192))\n\t\t\tlast_output++;\n\t\tin_height = round_up(\n\t\t\t(DIV_ROUND_UP(last_output * resize_coeff_v, 8192) + 1)\n\t\t\t<< ctx->downsize_coeff_v, 2);\n\n\t\tfor (col = 0; col < ctx->in.num_cols; col++) {\n\t\t\ttile_idx = row * ctx->in.num_cols + col;\n\t\t\tin_tile = &ctx->in.tile[tile_idx];\n\t\t\tout_tile = &ctx->out.tile[ctx->out_tile_map[tile_idx]];\n\n\t\t\tif (ipu_rot_mode_is_irt(ctx->rot_mode))\n\t\t\t\tout_tile->width = resized_height;\n\t\t\telse\n\t\t\t\tout_tile->height = resized_height;\n\n\t\t\tin_tile->height = in_height;\n\t\t}\n\n\t\tctx->resize_coeffs_v[row] = resize_coeff_v;\n\t}\n}\n\n \nstatic int get_run_count(struct ipu_image_convert_ctx *ctx,\n\t\t\t struct list_head *q)\n{\n\tstruct ipu_image_convert_run *run;\n\tint count = 0;\n\n\tlockdep_assert_held(&ctx->chan->irqlock);\n\n\tlist_for_each_entry(run, q, list) {\n\t\tif (run->ctx == ctx)\n\t\t\tcount++;\n\t}\n\n\treturn count;\n}\n\nstatic void convert_stop(struct ipu_image_convert_run *run)\n{\n\tstruct ipu_image_convert_ctx *ctx = run->ctx;\n\tstruct ipu_image_convert_chan *chan = ctx->chan;\n\tstruct ipu_image_convert_priv *priv = chan->priv;\n\n\tdev_dbg(priv->ipu->dev, \"%s: task %u: stopping ctx %p run %p\\n\",\n\t\t__func__, chan->ic_task, ctx, run);\n\n\t \n\tipu_ic_task_disable(chan->ic);\n\tipu_idmac_disable_channel(chan->in_chan);\n\tipu_idmac_disable_channel(chan->out_chan);\n\n\tif (ipu_rot_mode_is_irt(ctx->rot_mode)) {\n\t\tipu_idmac_disable_channel(chan->rotation_in_chan);\n\t\tipu_idmac_disable_channel(chan->rotation_out_chan);\n\t\tipu_idmac_unlink(chan->out_chan, chan->rotation_in_chan);\n\t}\n\n\tipu_ic_disable(chan->ic);\n}\n\nstatic void init_idmac_channel(struct ipu_image_convert_ctx *ctx,\n\t\t\t       struct ipuv3_channel *channel,\n\t\t\t       struct ipu_image_convert_image *image,\n\t\t\t       enum ipu_rotate_mode rot_mode,\n\t\t\t       bool rot_swap_width_height,\n\t\t\t       unsigned int tile)\n{\n\tstruct ipu_image_convert_chan *chan = ctx->chan;\n\tunsigned int burst_size;\n\tu32 width, height, stride;\n\tdma_addr_t addr0, addr1 = 0;\n\tstruct ipu_image tile_image;\n\tunsigned int tile_idx[2];\n\n\tif (image->type == IMAGE_CONVERT_OUT) {\n\t\ttile_idx[0] = ctx->out_tile_map[tile];\n\t\ttile_idx[1] = ctx->out_tile_map[1];\n\t} else {\n\t\ttile_idx[0] = tile;\n\t\ttile_idx[1] = 1;\n\t}\n\n\tif (rot_swap_width_height) {\n\t\twidth = image->tile[tile_idx[0]].height;\n\t\theight = image->tile[tile_idx[0]].width;\n\t\tstride = image->tile[tile_idx[0]].rot_stride;\n\t\taddr0 = ctx->rot_intermediate[0].phys;\n\t\tif (ctx->double_buffering)\n\t\t\taddr1 = ctx->rot_intermediate[1].phys;\n\t} else {\n\t\twidth = image->tile[tile_idx[0]].width;\n\t\theight = image->tile[tile_idx[0]].height;\n\t\tstride = image->stride;\n\t\taddr0 = image->base.phys0 +\n\t\t\timage->tile[tile_idx[0]].offset;\n\t\tif (ctx->double_buffering)\n\t\t\taddr1 = image->base.phys0 +\n\t\t\t\timage->tile[tile_idx[1]].offset;\n\t}\n\n\tipu_cpmem_zero(channel);\n\n\tmemset(&tile_image, 0, sizeof(tile_image));\n\ttile_image.pix.width = tile_image.rect.width = width;\n\ttile_image.pix.height = tile_image.rect.height = height;\n\ttile_image.pix.bytesperline = stride;\n\ttile_image.pix.pixelformat =  image->fmt->fourcc;\n\ttile_image.phys0 = addr0;\n\ttile_image.phys1 = addr1;\n\tif (image->fmt->planar && !rot_swap_width_height) {\n\t\ttile_image.u_offset = image->tile[tile_idx[0]].u_off;\n\t\ttile_image.v_offset = image->tile[tile_idx[0]].v_off;\n\t}\n\n\tipu_cpmem_set_image(channel, &tile_image);\n\n\tif (rot_mode)\n\t\tipu_cpmem_set_rotation(channel, rot_mode);\n\n\t \n\tif ((channel == chan->out_chan ||\n\t     channel == chan->rotation_out_chan) &&\n\t    image->fmt->planar && image->fmt->uv_height_dec == 2)\n\t\tipu_cpmem_skip_odd_chroma_rows(channel);\n\n\tif (channel == chan->rotation_in_chan ||\n\t    channel == chan->rotation_out_chan) {\n\t\tburst_size = 8;\n\t\tipu_cpmem_set_block_mode(channel);\n\t} else\n\t\tburst_size = (width % 16) ? 8 : 16;\n\n\tipu_cpmem_set_burstsize(channel, burst_size);\n\n\tipu_ic_task_idma_init(chan->ic, channel, width, height,\n\t\t\t      burst_size, rot_mode);\n\n\t \n\tif (!channel->ipu->prg_priv)\n\t\tipu_cpmem_set_axi_id(channel, 1);\n\n\tipu_idmac_set_double_buffer(channel, ctx->double_buffering);\n}\n\nstatic int convert_start(struct ipu_image_convert_run *run, unsigned int tile)\n{\n\tstruct ipu_image_convert_ctx *ctx = run->ctx;\n\tstruct ipu_image_convert_chan *chan = ctx->chan;\n\tstruct ipu_image_convert_priv *priv = chan->priv;\n\tstruct ipu_image_convert_image *s_image = &ctx->in;\n\tstruct ipu_image_convert_image *d_image = &ctx->out;\n\tunsigned int dst_tile = ctx->out_tile_map[tile];\n\tunsigned int dest_width, dest_height;\n\tunsigned int col, row;\n\tu32 rsc;\n\tint ret;\n\n\tdev_dbg(priv->ipu->dev, \"%s: task %u: starting ctx %p run %p tile %u -> %u\\n\",\n\t\t__func__, chan->ic_task, ctx, run, tile, dst_tile);\n\n\t \n\tctx->eof_mask = 0;\n\n\tif (ipu_rot_mode_is_irt(ctx->rot_mode)) {\n\t\t \n\t\tdest_width = d_image->tile[dst_tile].height;\n\t\tdest_height = d_image->tile[dst_tile].width;\n\t} else {\n\t\tdest_width = d_image->tile[dst_tile].width;\n\t\tdest_height = d_image->tile[dst_tile].height;\n\t}\n\n\trow = tile / s_image->num_cols;\n\tcol = tile % s_image->num_cols;\n\n\trsc =  (ctx->downsize_coeff_v << 30) |\n\t       (ctx->resize_coeffs_v[row] << 16) |\n\t       (ctx->downsize_coeff_h << 14) |\n\t       (ctx->resize_coeffs_h[col]);\n\n\tdev_dbg(priv->ipu->dev, \"%s: %ux%u -> %ux%u (rsc = 0x%x)\\n\",\n\t\t__func__, s_image->tile[tile].width,\n\t\ts_image->tile[tile].height, dest_width, dest_height, rsc);\n\n\t \n\tret = ipu_ic_task_init_rsc(chan->ic, &ctx->csc,\n\t\t\t\t   s_image->tile[tile].width,\n\t\t\t\t   s_image->tile[tile].height,\n\t\t\t\t   dest_width,\n\t\t\t\t   dest_height,\n\t\t\t\t   rsc);\n\tif (ret) {\n\t\tdev_err(priv->ipu->dev, \"ipu_ic_task_init failed, %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\t \n\tinit_idmac_channel(ctx, chan->in_chan, s_image,\n\t\t\t   IPU_ROTATE_NONE, false, tile);\n\n\tif (ipu_rot_mode_is_irt(ctx->rot_mode)) {\n\t\t \n\t\tinit_idmac_channel(ctx, chan->out_chan, d_image,\n\t\t\t\t   IPU_ROTATE_NONE, true, tile);\n\n\t\t \n\t\tinit_idmac_channel(ctx, chan->rotation_in_chan, d_image,\n\t\t\t\t   ctx->rot_mode, true, tile);\n\n\t\t \n\t\tinit_idmac_channel(ctx, chan->rotation_out_chan, d_image,\n\t\t\t\t   IPU_ROTATE_NONE, false, tile);\n\n\t\t \n\t\tipu_idmac_link(chan->out_chan, chan->rotation_in_chan);\n\t} else {\n\t\t \n\t\tinit_idmac_channel(ctx, chan->out_chan, d_image,\n\t\t\t\t   ctx->rot_mode, false, tile);\n\t}\n\n\t \n\tipu_ic_enable(chan->ic);\n\n\t \n\tipu_idmac_select_buffer(chan->in_chan, 0);\n\tipu_idmac_select_buffer(chan->out_chan, 0);\n\tif (ipu_rot_mode_is_irt(ctx->rot_mode))\n\t\tipu_idmac_select_buffer(chan->rotation_out_chan, 0);\n\tif (ctx->double_buffering) {\n\t\tipu_idmac_select_buffer(chan->in_chan, 1);\n\t\tipu_idmac_select_buffer(chan->out_chan, 1);\n\t\tif (ipu_rot_mode_is_irt(ctx->rot_mode))\n\t\t\tipu_idmac_select_buffer(chan->rotation_out_chan, 1);\n\t}\n\n\t \n\tipu_idmac_enable_channel(chan->in_chan);\n\tipu_idmac_enable_channel(chan->out_chan);\n\tif (ipu_rot_mode_is_irt(ctx->rot_mode)) {\n\t\tipu_idmac_enable_channel(chan->rotation_in_chan);\n\t\tipu_idmac_enable_channel(chan->rotation_out_chan);\n\t}\n\n\tipu_ic_task_enable(chan->ic);\n\n\tipu_cpmem_dump(chan->in_chan);\n\tipu_cpmem_dump(chan->out_chan);\n\tif (ipu_rot_mode_is_irt(ctx->rot_mode)) {\n\t\tipu_cpmem_dump(chan->rotation_in_chan);\n\t\tipu_cpmem_dump(chan->rotation_out_chan);\n\t}\n\n\tipu_dump(priv->ipu);\n\n\treturn 0;\n}\n\n \nstatic int do_run(struct ipu_image_convert_run *run)\n{\n\tstruct ipu_image_convert_ctx *ctx = run->ctx;\n\tstruct ipu_image_convert_chan *chan = ctx->chan;\n\n\tlockdep_assert_held(&chan->irqlock);\n\n\tctx->in.base.phys0 = run->in_phys;\n\tctx->out.base.phys0 = run->out_phys;\n\n\tctx->cur_buf_num = 0;\n\tctx->next_tile = 1;\n\n\t \n\tlist_del(&run->list);\n\tchan->current_run = run;\n\n\treturn convert_start(run, 0);\n}\n\n \nstatic void run_next(struct ipu_image_convert_chan *chan)\n{\n\tstruct ipu_image_convert_priv *priv = chan->priv;\n\tstruct ipu_image_convert_run *run, *tmp;\n\tint ret;\n\n\tlockdep_assert_held(&chan->irqlock);\n\n\tlist_for_each_entry_safe(run, tmp, &chan->pending_q, list) {\n\t\t \n\t\tif (run->ctx->aborting) {\n\t\t\tdev_dbg(priv->ipu->dev,\n\t\t\t\t\"%s: task %u: skipping aborting ctx %p run %p\\n\",\n\t\t\t\t__func__, chan->ic_task, run->ctx, run);\n\t\t\tcontinue;\n\t\t}\n\n\t\tret = do_run(run);\n\t\tif (!ret)\n\t\t\tbreak;\n\n\t\t \n\t\trun->status = ret;\n\t\tlist_add_tail(&run->list, &chan->done_q);\n\t\tchan->current_run = NULL;\n\t}\n}\n\nstatic void empty_done_q(struct ipu_image_convert_chan *chan)\n{\n\tstruct ipu_image_convert_priv *priv = chan->priv;\n\tstruct ipu_image_convert_run *run;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&chan->irqlock, flags);\n\n\twhile (!list_empty(&chan->done_q)) {\n\t\trun = list_entry(chan->done_q.next,\n\t\t\t\t struct ipu_image_convert_run,\n\t\t\t\t list);\n\n\t\tlist_del(&run->list);\n\n\t\tdev_dbg(priv->ipu->dev,\n\t\t\t\"%s: task %u: completing ctx %p run %p with %d\\n\",\n\t\t\t__func__, chan->ic_task, run->ctx, run, run->status);\n\n\t\t \n\t\tspin_unlock_irqrestore(&chan->irqlock, flags);\n\t\trun->ctx->complete(run, run->ctx->complete_context);\n\t\tspin_lock_irqsave(&chan->irqlock, flags);\n\t}\n\n\tspin_unlock_irqrestore(&chan->irqlock, flags);\n}\n\n \nstatic irqreturn_t do_bh(int irq, void *dev_id)\n{\n\tstruct ipu_image_convert_chan *chan = dev_id;\n\tstruct ipu_image_convert_priv *priv = chan->priv;\n\tstruct ipu_image_convert_ctx *ctx;\n\tunsigned long flags;\n\n\tdev_dbg(priv->ipu->dev, \"%s: task %u: enter\\n\", __func__,\n\t\tchan->ic_task);\n\n\tempty_done_q(chan);\n\n\tspin_lock_irqsave(&chan->irqlock, flags);\n\n\t \n\tlist_for_each_entry(ctx, &chan->ctx_list, list) {\n\t\tif (ctx->aborting) {\n\t\t\tdev_dbg(priv->ipu->dev,\n\t\t\t\t\"%s: task %u: signaling abort for ctx %p\\n\",\n\t\t\t\t__func__, chan->ic_task, ctx);\n\t\t\tcomplete_all(&ctx->aborted);\n\t\t}\n\t}\n\n\tspin_unlock_irqrestore(&chan->irqlock, flags);\n\n\tdev_dbg(priv->ipu->dev, \"%s: task %u: exit\\n\", __func__,\n\t\tchan->ic_task);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic bool ic_settings_changed(struct ipu_image_convert_ctx *ctx)\n{\n\tunsigned int cur_tile = ctx->next_tile - 1;\n\tunsigned int next_tile = ctx->next_tile;\n\n\tif (ctx->resize_coeffs_h[cur_tile % ctx->in.num_cols] !=\n\t    ctx->resize_coeffs_h[next_tile % ctx->in.num_cols] ||\n\t    ctx->resize_coeffs_v[cur_tile / ctx->in.num_cols] !=\n\t    ctx->resize_coeffs_v[next_tile / ctx->in.num_cols] ||\n\t    ctx->in.tile[cur_tile].width != ctx->in.tile[next_tile].width ||\n\t    ctx->in.tile[cur_tile].height != ctx->in.tile[next_tile].height ||\n\t    ctx->out.tile[cur_tile].width != ctx->out.tile[next_tile].width ||\n\t    ctx->out.tile[cur_tile].height != ctx->out.tile[next_tile].height)\n\t\treturn true;\n\n\treturn false;\n}\n\n \nstatic irqreturn_t do_tile_complete(struct ipu_image_convert_run *run)\n{\n\tstruct ipu_image_convert_ctx *ctx = run->ctx;\n\tstruct ipu_image_convert_chan *chan = ctx->chan;\n\tstruct ipu_image_tile *src_tile, *dst_tile;\n\tstruct ipu_image_convert_image *s_image = &ctx->in;\n\tstruct ipu_image_convert_image *d_image = &ctx->out;\n\tstruct ipuv3_channel *outch;\n\tunsigned int dst_idx;\n\n\tlockdep_assert_held(&chan->irqlock);\n\n\toutch = ipu_rot_mode_is_irt(ctx->rot_mode) ?\n\t\tchan->rotation_out_chan : chan->out_chan;\n\n\t \n\tif (ctx->aborting && !ctx->double_buffering) {\n\t\tconvert_stop(run);\n\t\trun->status = -EIO;\n\t\tgoto done;\n\t}\n\n\tif (ctx->next_tile == ctx->num_tiles) {\n\t\t \n\t\tconvert_stop(run);\n\t\trun->status = 0;\n\t\tgoto done;\n\t}\n\n\t \n\tif (!ctx->double_buffering) {\n\t\tif (ic_settings_changed(ctx)) {\n\t\t\tconvert_stop(run);\n\t\t\tconvert_start(run, ctx->next_tile);\n\t\t} else {\n\t\t\tsrc_tile = &s_image->tile[ctx->next_tile];\n\t\t\tdst_idx = ctx->out_tile_map[ctx->next_tile];\n\t\t\tdst_tile = &d_image->tile[dst_idx];\n\n\t\t\tipu_cpmem_set_buffer(chan->in_chan, 0,\n\t\t\t\t\t     s_image->base.phys0 +\n\t\t\t\t\t     src_tile->offset);\n\t\t\tipu_cpmem_set_buffer(outch, 0,\n\t\t\t\t\t     d_image->base.phys0 +\n\t\t\t\t\t     dst_tile->offset);\n\t\t\tif (s_image->fmt->planar)\n\t\t\t\tipu_cpmem_set_uv_offset(chan->in_chan,\n\t\t\t\t\t\t\tsrc_tile->u_off,\n\t\t\t\t\t\t\tsrc_tile->v_off);\n\t\t\tif (d_image->fmt->planar)\n\t\t\t\tipu_cpmem_set_uv_offset(outch,\n\t\t\t\t\t\t\tdst_tile->u_off,\n\t\t\t\t\t\t\tdst_tile->v_off);\n\n\t\t\tipu_idmac_select_buffer(chan->in_chan, 0);\n\t\t\tipu_idmac_select_buffer(outch, 0);\n\t\t}\n\t} else if (ctx->next_tile < ctx->num_tiles - 1) {\n\n\t\tsrc_tile = &s_image->tile[ctx->next_tile + 1];\n\t\tdst_idx = ctx->out_tile_map[ctx->next_tile + 1];\n\t\tdst_tile = &d_image->tile[dst_idx];\n\n\t\tipu_cpmem_set_buffer(chan->in_chan, ctx->cur_buf_num,\n\t\t\t\t     s_image->base.phys0 + src_tile->offset);\n\t\tipu_cpmem_set_buffer(outch, ctx->cur_buf_num,\n\t\t\t\t     d_image->base.phys0 + dst_tile->offset);\n\n\t\tipu_idmac_select_buffer(chan->in_chan, ctx->cur_buf_num);\n\t\tipu_idmac_select_buffer(outch, ctx->cur_buf_num);\n\n\t\tctx->cur_buf_num ^= 1;\n\t}\n\n\tctx->eof_mask = 0;  \n\tctx->next_tile++;\n\treturn IRQ_HANDLED;\ndone:\n\tlist_add_tail(&run->list, &chan->done_q);\n\tchan->current_run = NULL;\n\trun_next(chan);\n\treturn IRQ_WAKE_THREAD;\n}\n\nstatic irqreturn_t eof_irq(int irq, void *data)\n{\n\tstruct ipu_image_convert_chan *chan = data;\n\tstruct ipu_image_convert_priv *priv = chan->priv;\n\tstruct ipu_image_convert_ctx *ctx;\n\tstruct ipu_image_convert_run *run;\n\tirqreturn_t ret = IRQ_HANDLED;\n\tbool tile_complete = false;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&chan->irqlock, flags);\n\n\t \n\trun = chan->current_run;\n\tif (!run) {\n\t\tret = IRQ_NONE;\n\t\tgoto out;\n\t}\n\n\tctx = run->ctx;\n\n\tif (irq == chan->in_eof_irq) {\n\t\tctx->eof_mask |= EOF_IRQ_IN;\n\t} else if (irq == chan->out_eof_irq) {\n\t\tctx->eof_mask |= EOF_IRQ_OUT;\n\t} else if (irq == chan->rot_in_eof_irq ||\n\t\t   irq == chan->rot_out_eof_irq) {\n\t\tif (!ipu_rot_mode_is_irt(ctx->rot_mode)) {\n\t\t\t \n\t\t\tdev_err(priv->ipu->dev,\n\t\t\t\t\"Unexpected rotation interrupt\\n\");\n\t\t\tgoto out;\n\t\t}\n\t\tctx->eof_mask |= (irq == chan->rot_in_eof_irq) ?\n\t\t\tEOF_IRQ_ROT_IN : EOF_IRQ_ROT_OUT;\n\t} else {\n\t\tdev_err(priv->ipu->dev, \"Received unknown irq %d\\n\", irq);\n\t\tret = IRQ_NONE;\n\t\tgoto out;\n\t}\n\n\tif (ipu_rot_mode_is_irt(ctx->rot_mode))\n\t\ttile_complete =\t(ctx->eof_mask == EOF_IRQ_ROT_COMPLETE);\n\telse\n\t\ttile_complete = (ctx->eof_mask == EOF_IRQ_COMPLETE);\n\n\tif (tile_complete)\n\t\tret = do_tile_complete(run);\nout:\n\tspin_unlock_irqrestore(&chan->irqlock, flags);\n\treturn ret;\n}\n\n \nstatic void force_abort(struct ipu_image_convert_ctx *ctx)\n{\n\tstruct ipu_image_convert_chan *chan = ctx->chan;\n\tstruct ipu_image_convert_run *run;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&chan->irqlock, flags);\n\n\trun = chan->current_run;\n\tif (run && run->ctx == ctx) {\n\t\tconvert_stop(run);\n\t\trun->status = -EIO;\n\t\tlist_add_tail(&run->list, &chan->done_q);\n\t\tchan->current_run = NULL;\n\t\trun_next(chan);\n\t}\n\n\tspin_unlock_irqrestore(&chan->irqlock, flags);\n\n\tempty_done_q(chan);\n}\n\nstatic void release_ipu_resources(struct ipu_image_convert_chan *chan)\n{\n\tif (chan->in_eof_irq >= 0)\n\t\tfree_irq(chan->in_eof_irq, chan);\n\tif (chan->rot_in_eof_irq >= 0)\n\t\tfree_irq(chan->rot_in_eof_irq, chan);\n\tif (chan->out_eof_irq >= 0)\n\t\tfree_irq(chan->out_eof_irq, chan);\n\tif (chan->rot_out_eof_irq >= 0)\n\t\tfree_irq(chan->rot_out_eof_irq, chan);\n\n\tif (!IS_ERR_OR_NULL(chan->in_chan))\n\t\tipu_idmac_put(chan->in_chan);\n\tif (!IS_ERR_OR_NULL(chan->out_chan))\n\t\tipu_idmac_put(chan->out_chan);\n\tif (!IS_ERR_OR_NULL(chan->rotation_in_chan))\n\t\tipu_idmac_put(chan->rotation_in_chan);\n\tif (!IS_ERR_OR_NULL(chan->rotation_out_chan))\n\t\tipu_idmac_put(chan->rotation_out_chan);\n\tif (!IS_ERR_OR_NULL(chan->ic))\n\t\tipu_ic_put(chan->ic);\n\n\tchan->in_chan = chan->out_chan = chan->rotation_in_chan =\n\t\tchan->rotation_out_chan = NULL;\n\tchan->in_eof_irq = -1;\n\tchan->rot_in_eof_irq = -1;\n\tchan->out_eof_irq = -1;\n\tchan->rot_out_eof_irq = -1;\n}\n\nstatic int get_eof_irq(struct ipu_image_convert_chan *chan,\n\t\t       struct ipuv3_channel *channel)\n{\n\tstruct ipu_image_convert_priv *priv = chan->priv;\n\tint ret, irq;\n\n\tirq = ipu_idmac_channel_irq(priv->ipu, channel, IPU_IRQ_EOF);\n\n\tret = request_threaded_irq(irq, eof_irq, do_bh, 0, \"ipu-ic\", chan);\n\tif (ret < 0) {\n\t\tdev_err(priv->ipu->dev, \"could not acquire irq %d\\n\", irq);\n\t\treturn ret;\n\t}\n\n\treturn irq;\n}\n\nstatic int get_ipu_resources(struct ipu_image_convert_chan *chan)\n{\n\tconst struct ipu_image_convert_dma_chan *dma = chan->dma_ch;\n\tstruct ipu_image_convert_priv *priv = chan->priv;\n\tint ret;\n\n\t \n\tchan->ic = ipu_ic_get(priv->ipu, chan->ic_task);\n\tif (IS_ERR(chan->ic)) {\n\t\tdev_err(priv->ipu->dev, \"could not acquire IC\\n\");\n\t\tret = PTR_ERR(chan->ic);\n\t\tgoto err;\n\t}\n\n\t \n\tchan->in_chan = ipu_idmac_get(priv->ipu, dma->in);\n\tchan->out_chan = ipu_idmac_get(priv->ipu, dma->out);\n\tif (IS_ERR(chan->in_chan) || IS_ERR(chan->out_chan)) {\n\t\tdev_err(priv->ipu->dev, \"could not acquire idmac channels\\n\");\n\t\tret = -EBUSY;\n\t\tgoto err;\n\t}\n\n\tchan->rotation_in_chan = ipu_idmac_get(priv->ipu, dma->rot_in);\n\tchan->rotation_out_chan = ipu_idmac_get(priv->ipu, dma->rot_out);\n\tif (IS_ERR(chan->rotation_in_chan) || IS_ERR(chan->rotation_out_chan)) {\n\t\tdev_err(priv->ipu->dev,\n\t\t\t\"could not acquire idmac rotation channels\\n\");\n\t\tret = -EBUSY;\n\t\tgoto err;\n\t}\n\n\t \n\tret = get_eof_irq(chan, chan->in_chan);\n\tif (ret < 0) {\n\t\tchan->in_eof_irq = -1;\n\t\tgoto err;\n\t}\n\tchan->in_eof_irq = ret;\n\n\tret = get_eof_irq(chan, chan->rotation_in_chan);\n\tif (ret < 0) {\n\t\tchan->rot_in_eof_irq = -1;\n\t\tgoto err;\n\t}\n\tchan->rot_in_eof_irq = ret;\n\n\tret = get_eof_irq(chan, chan->out_chan);\n\tif (ret < 0) {\n\t\tchan->out_eof_irq = -1;\n\t\tgoto err;\n\t}\n\tchan->out_eof_irq = ret;\n\n\tret = get_eof_irq(chan, chan->rotation_out_chan);\n\tif (ret < 0) {\n\t\tchan->rot_out_eof_irq = -1;\n\t\tgoto err;\n\t}\n\tchan->rot_out_eof_irq = ret;\n\n\treturn 0;\nerr:\n\trelease_ipu_resources(chan);\n\treturn ret;\n}\n\nstatic int fill_image(struct ipu_image_convert_ctx *ctx,\n\t\t      struct ipu_image_convert_image *ic_image,\n\t\t      struct ipu_image *image,\n\t\t      enum ipu_image_convert_type type)\n{\n\tstruct ipu_image_convert_priv *priv = ctx->chan->priv;\n\n\tic_image->base = *image;\n\tic_image->type = type;\n\n\tic_image->fmt = get_format(image->pix.pixelformat);\n\tif (!ic_image->fmt) {\n\t\tdev_err(priv->ipu->dev, \"pixelformat not supported for %s\\n\",\n\t\t\ttype == IMAGE_CONVERT_OUT ? \"Output\" : \"Input\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (ic_image->fmt->planar)\n\t\tic_image->stride = ic_image->base.pix.width;\n\telse\n\t\tic_image->stride  = ic_image->base.pix.bytesperline;\n\n\treturn 0;\n}\n\n \nstatic unsigned int clamp_align(unsigned int x, unsigned int min,\n\t\t\t\tunsigned int max, unsigned int align)\n{\n\t \n\tunsigned int mask = ~((1 << align) - 1);\n\n\t \n\tx = clamp(x, (min + ~mask) & mask, max & mask);\n\n\t \n\tif (align)\n\t\tx = (x + (1 << (align - 1))) & mask;\n\n\treturn x;\n}\n\n \nvoid ipu_image_convert_adjust(struct ipu_image *in, struct ipu_image *out,\n\t\t\t      enum ipu_rotate_mode rot_mode)\n{\n\tconst struct ipu_image_pixfmt *infmt, *outfmt;\n\tu32 w_align_out, h_align_out;\n\tu32 w_align_in, h_align_in;\n\n\tinfmt = get_format(in->pix.pixelformat);\n\toutfmt = get_format(out->pix.pixelformat);\n\n\t \n\tif (!infmt) {\n\t\tin->pix.pixelformat = V4L2_PIX_FMT_RGB24;\n\t\tinfmt = get_format(V4L2_PIX_FMT_RGB24);\n\t}\n\tif (!outfmt) {\n\t\tout->pix.pixelformat = V4L2_PIX_FMT_RGB24;\n\t\toutfmt = get_format(V4L2_PIX_FMT_RGB24);\n\t}\n\n\t \n\tin->pix.field = out->pix.field = V4L2_FIELD_NONE;\n\n\t \n\tif (ipu_rot_mode_is_irt(rot_mode)) {\n\t\tout->pix.height = max_t(__u32, out->pix.height,\n\t\t\t\t\tin->pix.width / 4);\n\t\tout->pix.width = max_t(__u32, out->pix.width,\n\t\t\t\t       in->pix.height / 4);\n\t} else {\n\t\tout->pix.width = max_t(__u32, out->pix.width,\n\t\t\t\t       in->pix.width / 4);\n\t\tout->pix.height = max_t(__u32, out->pix.height,\n\t\t\t\t\tin->pix.height / 4);\n\t}\n\n\t \n\tw_align_in = ilog2(tile_width_align(IMAGE_CONVERT_IN, infmt,\n\t\t\t\t\t    rot_mode));\n\th_align_in = ilog2(tile_height_align(IMAGE_CONVERT_IN, infmt,\n\t\t\t\t\t     rot_mode));\n\tin->pix.width = clamp_align(in->pix.width, MIN_W, MAX_W,\n\t\t\t\t    w_align_in);\n\tin->pix.height = clamp_align(in->pix.height, MIN_H, MAX_H,\n\t\t\t\t     h_align_in);\n\n\t \n\tw_align_out = ilog2(tile_width_align(IMAGE_CONVERT_OUT, outfmt,\n\t\t\t\t\t     rot_mode));\n\th_align_out = ilog2(tile_height_align(IMAGE_CONVERT_OUT, outfmt,\n\t\t\t\t\t      rot_mode));\n\tout->pix.width = clamp_align(out->pix.width, MIN_W, MAX_W,\n\t\t\t\t     w_align_out);\n\tout->pix.height = clamp_align(out->pix.height, MIN_H, MAX_H,\n\t\t\t\t      h_align_out);\n\n\t \n\tin->pix.bytesperline = infmt->planar ?\n\t\tclamp_align(in->pix.width, 2 << w_align_in, MAX_W,\n\t\t\t    w_align_in) :\n\t\tclamp_align((in->pix.width * infmt->bpp) >> 3,\n\t\t\t    ((2 << w_align_in) * infmt->bpp) >> 3,\n\t\t\t    (MAX_W * infmt->bpp) >> 3,\n\t\t\t    w_align_in);\n\tin->pix.sizeimage = infmt->planar ?\n\t\t(in->pix.height * in->pix.bytesperline * infmt->bpp) >> 3 :\n\t\tin->pix.height * in->pix.bytesperline;\n\tout->pix.bytesperline = outfmt->planar ? out->pix.width :\n\t\t(out->pix.width * outfmt->bpp) >> 3;\n\tout->pix.sizeimage = outfmt->planar ?\n\t\t(out->pix.height * out->pix.bytesperline * outfmt->bpp) >> 3 :\n\t\tout->pix.height * out->pix.bytesperline;\n}\nEXPORT_SYMBOL_GPL(ipu_image_convert_adjust);\n\n \nint ipu_image_convert_verify(struct ipu_image *in, struct ipu_image *out,\n\t\t\t     enum ipu_rotate_mode rot_mode)\n{\n\tstruct ipu_image testin, testout;\n\n\ttestin = *in;\n\ttestout = *out;\n\n\tipu_image_convert_adjust(&testin, &testout, rot_mode);\n\n\tif (testin.pix.width != in->pix.width ||\n\t    testin.pix.height != in->pix.height ||\n\t    testout.pix.width != out->pix.width ||\n\t    testout.pix.height != out->pix.height)\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(ipu_image_convert_verify);\n\n \nstruct ipu_image_convert_ctx *\nipu_image_convert_prepare(struct ipu_soc *ipu, enum ipu_ic_task ic_task,\n\t\t\t  struct ipu_image *in, struct ipu_image *out,\n\t\t\t  enum ipu_rotate_mode rot_mode,\n\t\t\t  ipu_image_convert_cb_t complete,\n\t\t\t  void *complete_context)\n{\n\tstruct ipu_image_convert_priv *priv = ipu->image_convert_priv;\n\tstruct ipu_image_convert_image *s_image, *d_image;\n\tstruct ipu_image_convert_chan *chan;\n\tstruct ipu_image_convert_ctx *ctx;\n\tunsigned long flags;\n\tunsigned int i;\n\tbool get_res;\n\tint ret;\n\n\tif (!in || !out || !complete ||\n\t    (ic_task != IC_TASK_VIEWFINDER &&\n\t     ic_task != IC_TASK_POST_PROCESSOR))\n\t\treturn ERR_PTR(-EINVAL);\n\n\t \n\tret = ipu_image_convert_verify(in, out, rot_mode);\n\tif (ret) {\n\t\tdev_err(priv->ipu->dev, \"%s: in/out formats invalid\\n\",\n\t\t\t__func__);\n\t\treturn ERR_PTR(ret);\n\t}\n\n\tchan = &priv->chan[ic_task];\n\n\tctx = kzalloc(sizeof(*ctx), GFP_KERNEL);\n\tif (!ctx)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tdev_dbg(priv->ipu->dev, \"%s: task %u: ctx %p\\n\", __func__,\n\t\tchan->ic_task, ctx);\n\n\tctx->chan = chan;\n\tinit_completion(&ctx->aborted);\n\n\tctx->rot_mode = rot_mode;\n\n\t \n\tret = calc_image_resize_coefficients(ctx, in, out);\n\tif (ret)\n\t\tgoto out_free;\n\n\ts_image = &ctx->in;\n\td_image = &ctx->out;\n\n\t \n\tif (ipu_rot_mode_is_irt(rot_mode)) {\n\t\td_image->num_rows = s_image->num_cols;\n\t\td_image->num_cols = s_image->num_rows;\n\t} else {\n\t\td_image->num_rows = s_image->num_rows;\n\t\td_image->num_cols = s_image->num_cols;\n\t}\n\n\tctx->num_tiles = d_image->num_cols * d_image->num_rows;\n\n\tret = fill_image(ctx, s_image, in, IMAGE_CONVERT_IN);\n\tif (ret)\n\t\tgoto out_free;\n\tret = fill_image(ctx, d_image, out, IMAGE_CONVERT_OUT);\n\tif (ret)\n\t\tgoto out_free;\n\n\tcalc_out_tile_map(ctx);\n\n\tfind_seams(ctx, s_image, d_image);\n\n\tret = calc_tile_dimensions(ctx, s_image);\n\tif (ret)\n\t\tgoto out_free;\n\n\tret = calc_tile_offsets(ctx, s_image);\n\tif (ret)\n\t\tgoto out_free;\n\n\tcalc_tile_dimensions(ctx, d_image);\n\tret = calc_tile_offsets(ctx, d_image);\n\tif (ret)\n\t\tgoto out_free;\n\n\tcalc_tile_resize_coefficients(ctx);\n\n\tret = ipu_ic_calc_csc(&ctx->csc,\n\t\t\ts_image->base.pix.ycbcr_enc,\n\t\t\ts_image->base.pix.quantization,\n\t\t\tipu_pixelformat_to_colorspace(s_image->fmt->fourcc),\n\t\t\td_image->base.pix.ycbcr_enc,\n\t\t\td_image->base.pix.quantization,\n\t\t\tipu_pixelformat_to_colorspace(d_image->fmt->fourcc));\n\tif (ret)\n\t\tgoto out_free;\n\n\tdump_format(ctx, s_image);\n\tdump_format(ctx, d_image);\n\n\tctx->complete = complete;\n\tctx->complete_context = complete_context;\n\n\t \n\tctx->double_buffering = (ctx->num_tiles > 1 &&\n\t\t\t\t !s_image->fmt->planar &&\n\t\t\t\t !d_image->fmt->planar);\n\tfor (i = 1; i < ctx->num_tiles; i++) {\n\t\tif (ctx->in.tile[i].width != ctx->in.tile[0].width ||\n\t\t    ctx->in.tile[i].height != ctx->in.tile[0].height ||\n\t\t    ctx->out.tile[i].width != ctx->out.tile[0].width ||\n\t\t    ctx->out.tile[i].height != ctx->out.tile[0].height) {\n\t\t\tctx->double_buffering = false;\n\t\t\tbreak;\n\t\t}\n\t}\n\tfor (i = 1; i < ctx->in.num_cols; i++) {\n\t\tif (ctx->resize_coeffs_h[i] != ctx->resize_coeffs_h[0]) {\n\t\t\tctx->double_buffering = false;\n\t\t\tbreak;\n\t\t}\n\t}\n\tfor (i = 1; i < ctx->in.num_rows; i++) {\n\t\tif (ctx->resize_coeffs_v[i] != ctx->resize_coeffs_v[0]) {\n\t\t\tctx->double_buffering = false;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (ipu_rot_mode_is_irt(ctx->rot_mode)) {\n\t\tunsigned long intermediate_size = d_image->tile[0].size;\n\n\t\tfor (i = 1; i < ctx->num_tiles; i++) {\n\t\t\tif (d_image->tile[i].size > intermediate_size)\n\t\t\t\tintermediate_size = d_image->tile[i].size;\n\t\t}\n\n\t\tret = alloc_dma_buf(priv, &ctx->rot_intermediate[0],\n\t\t\t\t    intermediate_size);\n\t\tif (ret)\n\t\t\tgoto out_free;\n\t\tif (ctx->double_buffering) {\n\t\t\tret = alloc_dma_buf(priv,\n\t\t\t\t\t    &ctx->rot_intermediate[1],\n\t\t\t\t\t    intermediate_size);\n\t\t\tif (ret)\n\t\t\t\tgoto out_free_dmabuf0;\n\t\t}\n\t}\n\n\tspin_lock_irqsave(&chan->irqlock, flags);\n\n\tget_res = list_empty(&chan->ctx_list);\n\n\tlist_add_tail(&ctx->list, &chan->ctx_list);\n\n\tspin_unlock_irqrestore(&chan->irqlock, flags);\n\n\tif (get_res) {\n\t\tret = get_ipu_resources(chan);\n\t\tif (ret)\n\t\t\tgoto out_free_dmabuf1;\n\t}\n\n\treturn ctx;\n\nout_free_dmabuf1:\n\tfree_dma_buf(priv, &ctx->rot_intermediate[1]);\n\tspin_lock_irqsave(&chan->irqlock, flags);\n\tlist_del(&ctx->list);\n\tspin_unlock_irqrestore(&chan->irqlock, flags);\nout_free_dmabuf0:\n\tfree_dma_buf(priv, &ctx->rot_intermediate[0]);\nout_free:\n\tkfree(ctx);\n\treturn ERR_PTR(ret);\n}\nEXPORT_SYMBOL_GPL(ipu_image_convert_prepare);\n\n \nint ipu_image_convert_queue(struct ipu_image_convert_run *run)\n{\n\tstruct ipu_image_convert_chan *chan;\n\tstruct ipu_image_convert_priv *priv;\n\tstruct ipu_image_convert_ctx *ctx;\n\tunsigned long flags;\n\tint ret = 0;\n\n\tif (!run || !run->ctx || !run->in_phys || !run->out_phys)\n\t\treturn -EINVAL;\n\n\tctx = run->ctx;\n\tchan = ctx->chan;\n\tpriv = chan->priv;\n\n\tdev_dbg(priv->ipu->dev, \"%s: task %u: ctx %p run %p\\n\", __func__,\n\t\tchan->ic_task, ctx, run);\n\n\tINIT_LIST_HEAD(&run->list);\n\n\tspin_lock_irqsave(&chan->irqlock, flags);\n\n\tif (ctx->aborting) {\n\t\tret = -EIO;\n\t\tgoto unlock;\n\t}\n\n\tlist_add_tail(&run->list, &chan->pending_q);\n\n\tif (!chan->current_run) {\n\t\tret = do_run(run);\n\t\tif (ret)\n\t\t\tchan->current_run = NULL;\n\t}\nunlock:\n\tspin_unlock_irqrestore(&chan->irqlock, flags);\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(ipu_image_convert_queue);\n\n \nstatic void __ipu_image_convert_abort(struct ipu_image_convert_ctx *ctx)\n{\n\tstruct ipu_image_convert_chan *chan = ctx->chan;\n\tstruct ipu_image_convert_priv *priv = chan->priv;\n\tstruct ipu_image_convert_run *run, *active_run, *tmp;\n\tunsigned long flags;\n\tint run_count, ret;\n\n\tspin_lock_irqsave(&chan->irqlock, flags);\n\n\t \n\tlist_for_each_entry_safe(run, tmp, &chan->pending_q, list) {\n\t\tif (run->ctx != ctx)\n\t\t\tcontinue;\n\t\trun->status = -EIO;\n\t\tlist_move_tail(&run->list, &chan->done_q);\n\t}\n\n\trun_count = get_run_count(ctx, &chan->done_q);\n\tactive_run = (chan->current_run && chan->current_run->ctx == ctx) ?\n\t\tchan->current_run : NULL;\n\n\tif (active_run)\n\t\treinit_completion(&ctx->aborted);\n\n\tctx->aborting = true;\n\n\tspin_unlock_irqrestore(&chan->irqlock, flags);\n\n\tif (!run_count && !active_run) {\n\t\tdev_dbg(priv->ipu->dev,\n\t\t\t\"%s: task %u: no abort needed for ctx %p\\n\",\n\t\t\t__func__, chan->ic_task, ctx);\n\t\treturn;\n\t}\n\n\tif (!active_run) {\n\t\tempty_done_q(chan);\n\t\treturn;\n\t}\n\n\tdev_dbg(priv->ipu->dev,\n\t\t\"%s: task %u: wait for completion: %d runs\\n\",\n\t\t__func__, chan->ic_task, run_count);\n\n\tret = wait_for_completion_timeout(&ctx->aborted,\n\t\t\t\t\t  msecs_to_jiffies(10000));\n\tif (ret == 0) {\n\t\tdev_warn(priv->ipu->dev, \"%s: timeout\\n\", __func__);\n\t\tforce_abort(ctx);\n\t}\n}\n\nvoid ipu_image_convert_abort(struct ipu_image_convert_ctx *ctx)\n{\n\t__ipu_image_convert_abort(ctx);\n\tctx->aborting = false;\n}\nEXPORT_SYMBOL_GPL(ipu_image_convert_abort);\n\n \nvoid ipu_image_convert_unprepare(struct ipu_image_convert_ctx *ctx)\n{\n\tstruct ipu_image_convert_chan *chan = ctx->chan;\n\tstruct ipu_image_convert_priv *priv = chan->priv;\n\tunsigned long flags;\n\tbool put_res;\n\n\t \n\t__ipu_image_convert_abort(ctx);\n\n\tdev_dbg(priv->ipu->dev, \"%s: task %u: removing ctx %p\\n\", __func__,\n\t\tchan->ic_task, ctx);\n\n\tspin_lock_irqsave(&chan->irqlock, flags);\n\n\tlist_del(&ctx->list);\n\n\tput_res = list_empty(&chan->ctx_list);\n\n\tspin_unlock_irqrestore(&chan->irqlock, flags);\n\n\tif (put_res)\n\t\trelease_ipu_resources(chan);\n\n\tfree_dma_buf(priv, &ctx->rot_intermediate[1]);\n\tfree_dma_buf(priv, &ctx->rot_intermediate[0]);\n\n\tkfree(ctx);\n}\nEXPORT_SYMBOL_GPL(ipu_image_convert_unprepare);\n\n \nstruct ipu_image_convert_run *\nipu_image_convert(struct ipu_soc *ipu, enum ipu_ic_task ic_task,\n\t\t  struct ipu_image *in, struct ipu_image *out,\n\t\t  enum ipu_rotate_mode rot_mode,\n\t\t  ipu_image_convert_cb_t complete,\n\t\t  void *complete_context)\n{\n\tstruct ipu_image_convert_ctx *ctx;\n\tstruct ipu_image_convert_run *run;\n\tint ret;\n\n\tctx = ipu_image_convert_prepare(ipu, ic_task, in, out, rot_mode,\n\t\t\t\t\tcomplete, complete_context);\n\tif (IS_ERR(ctx))\n\t\treturn ERR_CAST(ctx);\n\n\trun = kzalloc(sizeof(*run), GFP_KERNEL);\n\tif (!run) {\n\t\tipu_image_convert_unprepare(ctx);\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\n\trun->ctx = ctx;\n\trun->in_phys = in->phys0;\n\trun->out_phys = out->phys0;\n\n\tret = ipu_image_convert_queue(run);\n\tif (ret) {\n\t\tipu_image_convert_unprepare(ctx);\n\t\tkfree(run);\n\t\treturn ERR_PTR(ret);\n\t}\n\n\treturn run;\n}\nEXPORT_SYMBOL_GPL(ipu_image_convert);\n\n \nstatic void image_convert_sync_complete(struct ipu_image_convert_run *run,\n\t\t\t\t\tvoid *data)\n{\n\tstruct completion *comp = data;\n\n\tcomplete(comp);\n}\n\nint ipu_image_convert_sync(struct ipu_soc *ipu, enum ipu_ic_task ic_task,\n\t\t\t   struct ipu_image *in, struct ipu_image *out,\n\t\t\t   enum ipu_rotate_mode rot_mode)\n{\n\tstruct ipu_image_convert_run *run;\n\tstruct completion comp;\n\tint ret;\n\n\tinit_completion(&comp);\n\n\trun = ipu_image_convert(ipu, ic_task, in, out, rot_mode,\n\t\t\t\timage_convert_sync_complete, &comp);\n\tif (IS_ERR(run))\n\t\treturn PTR_ERR(run);\n\n\tret = wait_for_completion_timeout(&comp, msecs_to_jiffies(10000));\n\tret = (ret == 0) ? -ETIMEDOUT : 0;\n\n\tipu_image_convert_unprepare(run->ctx);\n\tkfree(run);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(ipu_image_convert_sync);\n\nint ipu_image_convert_init(struct ipu_soc *ipu, struct device *dev)\n{\n\tstruct ipu_image_convert_priv *priv;\n\tint i;\n\n\tpriv = devm_kzalloc(dev, sizeof(*priv), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\n\tipu->image_convert_priv = priv;\n\tpriv->ipu = ipu;\n\n\tfor (i = 0; i < IC_NUM_TASKS; i++) {\n\t\tstruct ipu_image_convert_chan *chan = &priv->chan[i];\n\n\t\tchan->ic_task = i;\n\t\tchan->priv = priv;\n\t\tchan->dma_ch = &image_convert_dma_chan[i];\n\t\tchan->in_eof_irq = -1;\n\t\tchan->rot_in_eof_irq = -1;\n\t\tchan->out_eof_irq = -1;\n\t\tchan->rot_out_eof_irq = -1;\n\n\t\tspin_lock_init(&chan->irqlock);\n\t\tINIT_LIST_HEAD(&chan->ctx_list);\n\t\tINIT_LIST_HEAD(&chan->pending_q);\n\t\tINIT_LIST_HEAD(&chan->done_q);\n\t}\n\n\treturn 0;\n}\n\nvoid ipu_image_convert_exit(struct ipu_soc *ipu)\n{\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}