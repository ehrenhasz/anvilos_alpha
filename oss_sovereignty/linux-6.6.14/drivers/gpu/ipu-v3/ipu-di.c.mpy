{
  "module_name": "ipu-di.c",
  "hash_id": "6b5b9c9545520b542e2f7da56b609e288ac08c07bc7c0e6a27b804d6d711afe7",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/ipu-v3/ipu-di.c",
  "human_readable_source": "\n \n#include <linux/export.h>\n#include <linux/module.h>\n#include <linux/types.h>\n#include <linux/errno.h>\n#include <linux/io.h>\n#include <linux/err.h>\n#include <linux/platform_device.h>\n\n#include <video/imx-ipu-v3.h>\n#include \"ipu-prv.h\"\n\nstruct ipu_di {\n\tvoid __iomem *base;\n\tint id;\n\tu32 module;\n\tstruct clk *clk_di;\t \n\tstruct clk *clk_ipu;\t \n\tstruct clk *clk_di_pixel;  \n\tbool inuse;\n\tstruct ipu_soc *ipu;\n};\n\nstatic DEFINE_MUTEX(di_mutex);\n\nstruct di_sync_config {\n\tint run_count;\n\tint run_src;\n\tint offset_count;\n\tint offset_src;\n\tint repeat_count;\n\tint cnt_clr_src;\n\tint cnt_polarity_gen_en;\n\tint cnt_polarity_clr_src;\n\tint cnt_polarity_trigger_src;\n\tint cnt_up;\n\tint cnt_down;\n};\n\nenum di_pins {\n\tDI_PIN11 = 0,\n\tDI_PIN12 = 1,\n\tDI_PIN13 = 2,\n\tDI_PIN14 = 3,\n\tDI_PIN15 = 4,\n\tDI_PIN16 = 5,\n\tDI_PIN17 = 6,\n\tDI_PIN_CS = 7,\n\n\tDI_PIN_SER_CLK = 0,\n\tDI_PIN_SER_RS = 1,\n};\n\nenum di_sync_wave {\n\tDI_SYNC_NONE = 0,\n\tDI_SYNC_CLK = 1,\n\tDI_SYNC_INT_HSYNC = 2,\n\tDI_SYNC_HSYNC = 3,\n\tDI_SYNC_VSYNC = 4,\n\tDI_SYNC_DE = 6,\n\n\tDI_SYNC_CNT1 = 2,\t \n\tDI_SYNC_CNT4 = 5,\t \n\tDI_SYNC_CNT5 = 6,\t \n};\n\n#define SYNC_WAVE 0\n\n#define DI_GENERAL\t\t0x0000\n#define DI_BS_CLKGEN0\t\t0x0004\n#define DI_BS_CLKGEN1\t\t0x0008\n#define DI_SW_GEN0(gen)\t\t(0x000c + 4 * ((gen) - 1))\n#define DI_SW_GEN1(gen)\t\t(0x0030 + 4 * ((gen) - 1))\n#define DI_STP_REP(gen)\t\t(0x0148 + 4 * (((gen) - 1)/2))\n#define DI_SYNC_AS_GEN\t\t0x0054\n#define DI_DW_GEN(gen)\t\t(0x0058 + 4 * (gen))\n#define DI_DW_SET(gen, set)\t(0x0088 + 4 * ((gen) + 0xc * (set)))\n#define DI_SER_CONF\t\t0x015c\n#define DI_SSC\t\t\t0x0160\n#define DI_POL\t\t\t0x0164\n#define DI_AW0\t\t\t0x0168\n#define DI_AW1\t\t\t0x016c\n#define DI_SCR_CONF\t\t0x0170\n#define DI_STAT\t\t\t0x0174\n\n#define DI_SW_GEN0_RUN_COUNT(x)\t\t\t((x) << 19)\n#define DI_SW_GEN0_RUN_SRC(x)\t\t\t((x) << 16)\n#define DI_SW_GEN0_OFFSET_COUNT(x)\t\t((x) << 3)\n#define DI_SW_GEN0_OFFSET_SRC(x)\t\t((x) << 0)\n\n#define DI_SW_GEN1_CNT_POL_GEN_EN(x)\t\t((x) << 29)\n#define DI_SW_GEN1_CNT_CLR_SRC(x)\t\t((x) << 25)\n#define DI_SW_GEN1_CNT_POL_TRIGGER_SRC(x)\t((x) << 12)\n#define DI_SW_GEN1_CNT_POL_CLR_SRC(x)\t\t((x) << 9)\n#define DI_SW_GEN1_CNT_DOWN(x)\t\t\t((x) << 16)\n#define DI_SW_GEN1_CNT_UP(x)\t\t\t(x)\n#define DI_SW_GEN1_AUTO_RELOAD\t\t\t(0x10000000)\n\n#define DI_DW_GEN_ACCESS_SIZE_OFFSET\t\t24\n#define DI_DW_GEN_COMPONENT_SIZE_OFFSET\t\t16\n\n#define DI_GEN_POLARITY_1\t\t\t(1 << 0)\n#define DI_GEN_POLARITY_2\t\t\t(1 << 1)\n#define DI_GEN_POLARITY_3\t\t\t(1 << 2)\n#define DI_GEN_POLARITY_4\t\t\t(1 << 3)\n#define DI_GEN_POLARITY_5\t\t\t(1 << 4)\n#define DI_GEN_POLARITY_6\t\t\t(1 << 5)\n#define DI_GEN_POLARITY_7\t\t\t(1 << 6)\n#define DI_GEN_POLARITY_8\t\t\t(1 << 7)\n#define DI_GEN_POLARITY_DISP_CLK\t\t(1 << 17)\n#define DI_GEN_DI_CLK_EXT\t\t\t(1 << 20)\n#define DI_GEN_DI_VSYNC_EXT\t\t\t(1 << 21)\n\n#define DI_POL_DRDY_DATA_POLARITY\t\t(1 << 7)\n#define DI_POL_DRDY_POLARITY_15\t\t\t(1 << 4)\n\n#define DI_VSYNC_SEL_OFFSET\t\t\t13\n\nstatic inline u32 ipu_di_read(struct ipu_di *di, unsigned offset)\n{\n\treturn readl(di->base + offset);\n}\n\nstatic inline void ipu_di_write(struct ipu_di *di, u32 value, unsigned offset)\n{\n\twritel(value, di->base + offset);\n}\n\nstatic void ipu_di_data_wave_config(struct ipu_di *di,\n\t\t\t\t     int wave_gen,\n\t\t\t\t     int access_size, int component_size)\n{\n\tu32 reg;\n\treg = (access_size << DI_DW_GEN_ACCESS_SIZE_OFFSET) |\n\t    (component_size << DI_DW_GEN_COMPONENT_SIZE_OFFSET);\n\tipu_di_write(di, reg, DI_DW_GEN(wave_gen));\n}\n\nstatic void ipu_di_data_pin_config(struct ipu_di *di, int wave_gen, int di_pin,\n\t\tint set, int up, int down)\n{\n\tu32 reg;\n\n\treg = ipu_di_read(di, DI_DW_GEN(wave_gen));\n\treg &= ~(0x3 << (di_pin * 2));\n\treg |= set << (di_pin * 2);\n\tipu_di_write(di, reg, DI_DW_GEN(wave_gen));\n\n\tipu_di_write(di, (down << 16) | up, DI_DW_SET(wave_gen, set));\n}\n\nstatic void ipu_di_sync_config(struct ipu_di *di, struct di_sync_config *config,\n\t\tint start, int count)\n{\n\tu32 reg;\n\tint i;\n\n\tfor (i = 0; i < count; i++) {\n\t\tstruct di_sync_config *c = &config[i];\n\t\tint wave_gen = start + i + 1;\n\n\t\tif ((c->run_count >= 0x1000) || (c->offset_count >= 0x1000) ||\n\t\t\t\t(c->repeat_count >= 0x1000) ||\n\t\t\t\t(c->cnt_up >= 0x400) ||\n\t\t\t\t(c->cnt_down >= 0x400)) {\n\t\t\tdev_err(di->ipu->dev, \"DI%d counters out of range.\\n\",\n\t\t\t\t\tdi->id);\n\t\t\treturn;\n\t\t}\n\n\t\treg = DI_SW_GEN0_RUN_COUNT(c->run_count) |\n\t\t\tDI_SW_GEN0_RUN_SRC(c->run_src) |\n\t\t\tDI_SW_GEN0_OFFSET_COUNT(c->offset_count) |\n\t\t\tDI_SW_GEN0_OFFSET_SRC(c->offset_src);\n\t\tipu_di_write(di, reg, DI_SW_GEN0(wave_gen));\n\n\t\treg = DI_SW_GEN1_CNT_POL_GEN_EN(c->cnt_polarity_gen_en) |\n\t\t\tDI_SW_GEN1_CNT_CLR_SRC(c->cnt_clr_src) |\n\t\t\tDI_SW_GEN1_CNT_POL_TRIGGER_SRC(\n\t\t\t\t\tc->cnt_polarity_trigger_src) |\n\t\t\tDI_SW_GEN1_CNT_POL_CLR_SRC(c->cnt_polarity_clr_src) |\n\t\t\tDI_SW_GEN1_CNT_DOWN(c->cnt_down) |\n\t\t\tDI_SW_GEN1_CNT_UP(c->cnt_up);\n\n\t\t \n\t\tif (c->repeat_count == 0)\n\t\t\treg |= DI_SW_GEN1_AUTO_RELOAD;\n\n\t\tipu_di_write(di, reg, DI_SW_GEN1(wave_gen));\n\n\t\treg = ipu_di_read(di, DI_STP_REP(wave_gen));\n\t\treg &= ~(0xffff << (16 * ((wave_gen - 1) & 0x1)));\n\t\treg |= c->repeat_count << (16 * ((wave_gen - 1) & 0x1));\n\t\tipu_di_write(di, reg, DI_STP_REP(wave_gen));\n\t}\n}\n\nstatic void ipu_di_sync_config_interlaced(struct ipu_di *di,\n\t\tstruct ipu_di_signal_cfg *sig)\n{\n\tu32 h_total = sig->mode.hactive + sig->mode.hsync_len +\n\t\tsig->mode.hback_porch + sig->mode.hfront_porch;\n\tu32 v_total = sig->mode.vactive + sig->mode.vsync_len +\n\t\tsig->mode.vback_porch + sig->mode.vfront_porch;\n\tstruct di_sync_config cfg[] = {\n\t\t{\n\t\t\t \n\t\t\t.run_count = v_total * 2 - 1,\n\t\t\t.run_src = 3,\t\t\t \n\t\t}, {\n\t\t\t \n\t\t\t.run_count = h_total - 1,\n\t\t\t.run_src = DI_SYNC_CLK,\n\t\t\t.cnt_polarity_gen_en = 1,\n\t\t\t.cnt_polarity_trigger_src = DI_SYNC_CLK,\n\t\t\t.cnt_down = sig->mode.hsync_len * 2,\n\t\t}, {\n\t\t\t \n\t\t\t.run_count = v_total - 1,\n\t\t\t.run_src = 4,\t\t\t \n\t\t\t.cnt_polarity_gen_en = 1,\n\t\t\t.cnt_polarity_trigger_src = 4,\t \n\t\t\t.cnt_down = sig->mode.vsync_len * 2,\n\t\t\t.cnt_clr_src = DI_SYNC_CNT1,\n\t\t}, {\n\t\t\t \n\t\t\t.run_count = v_total / 2,\n\t\t\t.run_src = DI_SYNC_HSYNC,\n\t\t\t.offset_count = h_total / 2,\n\t\t\t.offset_src = DI_SYNC_CLK,\n\t\t\t.repeat_count = 2,\n\t\t\t.cnt_clr_src = DI_SYNC_CNT1,\n\t\t}, {\n\t\t\t \n\t\t\t.run_src = DI_SYNC_HSYNC,\n\t\t\t.offset_count = (sig->mode.vsync_len +\n\t\t\t\t\t sig->mode.vback_porch) / 2,\n\t\t\t.offset_src = DI_SYNC_HSYNC,\n\t\t\t.repeat_count = sig->mode.vactive / 2,\n\t\t\t.cnt_clr_src = DI_SYNC_CNT4,\n\t\t}, {\n\t\t\t \n\t\t\t.run_src = DI_SYNC_CLK,\n\t\t\t.offset_count = sig->mode.hsync_len +\n\t\t\t\t\tsig->mode.hback_porch,\n\t\t\t.offset_src = DI_SYNC_CLK,\n\t\t\t.repeat_count = sig->mode.hactive,\n\t\t\t.cnt_clr_src = DI_SYNC_CNT5,\n\t\t}, {\n\t\t\t \n\t\t\t.run_count = h_total / 2 - 1,\n\t\t\t.run_src = DI_SYNC_CLK,\n\t\t}\n\t};\n\n\tipu_di_sync_config(di, cfg, 0, ARRAY_SIZE(cfg));\n\n\tipu_di_write(di, v_total / 2 - 1, DI_SCR_CONF);\n}\n\nstatic void ipu_di_sync_config_noninterlaced(struct ipu_di *di,\n\t\tstruct ipu_di_signal_cfg *sig, int div)\n{\n\tu32 h_total = sig->mode.hactive + sig->mode.hsync_len +\n\t\tsig->mode.hback_porch + sig->mode.hfront_porch;\n\tu32 v_total = sig->mode.vactive + sig->mode.vsync_len +\n\t\tsig->mode.vback_porch + sig->mode.vfront_porch;\n\tstruct di_sync_config cfg[] = {\n\t\t{\n\t\t\t \n\t\t\t.run_count = h_total - 1,\n\t\t\t.run_src = DI_SYNC_CLK,\n\t\t} , {\n\t\t\t \n\t\t\t.run_count = h_total - 1,\n\t\t\t.run_src = DI_SYNC_CLK,\n\t\t\t.offset_count = div * sig->v_to_h_sync,\n\t\t\t.offset_src = DI_SYNC_CLK,\n\t\t\t.cnt_polarity_gen_en = 1,\n\t\t\t.cnt_polarity_trigger_src = DI_SYNC_CLK,\n\t\t\t.cnt_down = sig->mode.hsync_len * 2,\n\t\t} , {\n\t\t\t \n\t\t\t.run_count = v_total - 1,\n\t\t\t.run_src = DI_SYNC_INT_HSYNC,\n\t\t\t.cnt_polarity_gen_en = 1,\n\t\t\t.cnt_polarity_trigger_src = DI_SYNC_INT_HSYNC,\n\t\t\t.cnt_down = sig->mode.vsync_len * 2,\n\t\t} , {\n\t\t\t \n\t\t\t.run_src = DI_SYNC_HSYNC,\n\t\t\t.offset_count = sig->mode.vsync_len +\n\t\t\t\t\tsig->mode.vback_porch,\n\t\t\t.offset_src = DI_SYNC_HSYNC,\n\t\t\t.repeat_count = sig->mode.vactive,\n\t\t\t.cnt_clr_src = DI_SYNC_VSYNC,\n\t\t} , {\n\t\t\t \n\t\t\t.run_src = DI_SYNC_CLK,\n\t\t\t.offset_count = sig->mode.hsync_len +\n\t\t\t\t\tsig->mode.hback_porch,\n\t\t\t.offset_src = DI_SYNC_CLK,\n\t\t\t.repeat_count = sig->mode.hactive,\n\t\t\t.cnt_clr_src = 5,  \n\t\t} , {\n\t\t\t \n\t\t} , {\n\t\t\t \n\t\t},\n\t};\n\t \n\tstruct di_sync_config cfg_vga[] = {\n\t\t{\n\t\t\t \n\t\t\t.run_count = h_total - 1,\n\t\t\t.run_src = DI_SYNC_CLK,\n\t\t} , {\n\t\t\t \n\t\t\t.run_count = v_total - 1,\n\t\t\t.run_src = DI_SYNC_INT_HSYNC,\n\t\t} , {\n\t\t\t \n\t\t\t.run_src = DI_SYNC_INT_HSYNC,\n\t\t\t.offset_count = sig->mode.vsync_len +\n\t\t\t\t\tsig->mode.vback_porch,\n\t\t\t.offset_src = DI_SYNC_INT_HSYNC,\n\t\t\t.repeat_count = sig->mode.vactive,\n\t\t\t.cnt_clr_src = 3  ,\n\t\t} , {\n\t\t\t \n\t\t\t.run_count = h_total - 1,\n\t\t\t.run_src = DI_SYNC_CLK,\n\t\t\t.offset_count = div * sig->v_to_h_sync + 18,  \n\t\t\t.offset_src = DI_SYNC_CLK,\n\t\t\t.cnt_polarity_gen_en = 1,\n\t\t\t.cnt_polarity_trigger_src = DI_SYNC_CLK,\n\t\t\t.cnt_down = sig->mode.hsync_len * 2,\n\t\t} , {\n\t\t\t \n\t\t\t.run_src = DI_SYNC_CLK,\n\t\t\t.offset_count = sig->mode.hsync_len +\n\t\t\t\t\tsig->mode.hback_porch,\n\t\t\t.offset_src = DI_SYNC_CLK,\n\t\t\t.repeat_count = sig->mode.hactive,\n\t\t\t.cnt_clr_src = 4,  \n\t\t} , {\n\t\t\t \n\t\t\t.run_count = v_total - 1,\n\t\t\t.run_src = DI_SYNC_INT_HSYNC,\n\t\t\t.offset_count = 1,  \n\t\t\t.offset_src = DI_SYNC_INT_HSYNC,\n\t\t\t.cnt_polarity_gen_en = 1,\n\t\t\t.cnt_polarity_trigger_src = DI_SYNC_INT_HSYNC,\n\t\t\t.cnt_down = sig->mode.vsync_len * 2,\n\t\t} , {\n\t\t\t \n\t\t\t.run_count = h_total - 1,\n\t\t\t.run_src = DI_SYNC_CLK,\n\t\t\t.offset_count = div * sig->v_to_h_sync + 18,  \n\t\t\t.offset_src = DI_SYNC_CLK,\n\t\t\t.cnt_polarity_gen_en = 1,\n\t\t\t.cnt_polarity_trigger_src = DI_SYNC_CLK,\n\t\t\t.cnt_down = sig->mode.hsync_len * 2,\n\t\t} , {\n\t\t\t \n\t\t\t.run_count = v_total - 1,\n\t\t\t.run_src = DI_SYNC_INT_HSYNC,\n\t\t\t.offset_count = 1,  \n\t\t\t.offset_src = DI_SYNC_INT_HSYNC,\n\t\t\t.cnt_polarity_gen_en = 1,\n\t\t\t.cnt_polarity_trigger_src = DI_SYNC_INT_HSYNC,\n\t\t\t.cnt_down = sig->mode.vsync_len * 2,\n\t\t} , {\n\t\t\t \n\t\t},\n\t};\n\n\tipu_di_write(di, v_total - 1, DI_SCR_CONF);\n\tif (sig->hsync_pin == 2 && sig->vsync_pin == 3)\n\t\tipu_di_sync_config(di, cfg, 0, ARRAY_SIZE(cfg));\n\telse\n\t\tipu_di_sync_config(di, cfg_vga, 0, ARRAY_SIZE(cfg_vga));\n}\n\nstatic void ipu_di_config_clock(struct ipu_di *di,\n\tconst struct ipu_di_signal_cfg *sig)\n{\n\tstruct clk *clk;\n\tunsigned clkgen0;\n\tuint32_t val;\n\n\tif (sig->clkflags & IPU_DI_CLKMODE_EXT) {\n\t\t \n\t\tclk = di->clk_di;\n\n\t\tif (sig->clkflags & IPU_DI_CLKMODE_SYNC) {\n\t\t\t \n\t\t\tclkgen0 = 1 << 4;\n\t\t} else {\n\t\t\t \n\t\t\tunsigned long in_rate;\n\t\t\tunsigned div;\n\n\t\t\tclk_set_rate(clk, sig->mode.pixelclock);\n\n\t\t\tin_rate = clk_get_rate(clk);\n\t\t\tdiv = DIV_ROUND_CLOSEST(in_rate, sig->mode.pixelclock);\n\t\t\tdiv = clamp(div, 1U, 255U);\n\n\t\t\tclkgen0 = div << 4;\n\t\t}\n\t} else {\n\t\t \n\t\tunsigned long rate, clkrate;\n\t\tunsigned div, error;\n\n\t\tclkrate = clk_get_rate(di->clk_ipu);\n\t\tdiv = DIV_ROUND_CLOSEST(clkrate, sig->mode.pixelclock);\n\t\tdiv = clamp(div, 1U, 255U);\n\t\trate = clkrate / div;\n\n\t\terror = rate / (sig->mode.pixelclock / 1000);\n\n\t\tdev_dbg(di->ipu->dev, \"  IPU clock can give %lu with divider %u, error %c%d.%d%%\\n\",\n\t\t\trate, div, error < 1000 ? '-' : '+',\n\t\t\tabs(error - 1000) / 10, abs(error - 1000) % 10);\n\n\t\t \n\t\tif (error < 1010 && error >= 990) {\n\t\t\tclk = di->clk_ipu;\n\n\t\t\tclkgen0 = div << 4;\n\t\t} else {\n\t\t\tunsigned long in_rate;\n\t\t\tunsigned div;\n\n\t\t\tclk = di->clk_di;\n\n\t\t\tclk_set_rate(clk, sig->mode.pixelclock);\n\n\t\t\tin_rate = clk_get_rate(clk);\n\t\t\tdiv = DIV_ROUND_CLOSEST(in_rate, sig->mode.pixelclock);\n\t\t\tdiv = clamp(div, 1U, 255U);\n\n\t\t\tclkgen0 = div << 4;\n\t\t}\n\t}\n\n\tdi->clk_di_pixel = clk;\n\n\t \n\tipu_di_write(di, clkgen0, DI_BS_CLKGEN0);\n\n\t \n\tipu_di_write(di, (clkgen0 >> 4) << 16, DI_BS_CLKGEN1);\n\n\t \n\tval = ipu_di_read(di, DI_GENERAL) & ~DI_GEN_DI_CLK_EXT;\n\tif (clk == di->clk_di)\n\t\tval |= DI_GEN_DI_CLK_EXT;\n\tipu_di_write(di, val, DI_GENERAL);\n\n\tdev_dbg(di->ipu->dev, \"Want %luHz IPU %luHz DI %luHz using %s, %luHz\\n\",\n\t\tsig->mode.pixelclock,\n\t\tclk_get_rate(di->clk_ipu),\n\t\tclk_get_rate(di->clk_di),\n\t\tclk == di->clk_di ? \"DI\" : \"IPU\",\n\t\tclk_get_rate(di->clk_di_pixel) / (clkgen0 >> 4));\n}\n\n \nint ipu_di_adjust_videomode(struct ipu_di *di, struct videomode *mode)\n{\n\tu32 diff;\n\n\tif (!IS_ALIGNED(mode->hactive, 8) &&\n\t    mode->hfront_porch < ALIGN(mode->hactive, 8) - mode->hactive) {\n\t\tdev_err(di->ipu->dev, \"hactive %d is not aligned to 8 and front porch is too small to compensate\\n\",\n\t\t\tmode->hactive);\n\t\treturn -EINVAL;\n\t}\n\n\tif (mode->vfront_porch >= 2)\n\t\treturn 0;\n\n\tdiff = 2 - mode->vfront_porch;\n\n\tif (mode->vback_porch >= diff) {\n\t\tmode->vfront_porch = 2;\n\t\tmode->vback_porch -= diff;\n\t} else if (mode->vsync_len > diff) {\n\t\tmode->vfront_porch = 2;\n\t\tmode->vsync_len = mode->vsync_len - diff;\n\t} else {\n\t\tdev_warn(di->ipu->dev, \"failed to adjust videomode\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tdev_dbg(di->ipu->dev, \"videomode adapted for IPU restrictions\\n\");\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(ipu_di_adjust_videomode);\n\nstatic u32 ipu_di_gen_polarity(int pin)\n{\n\tswitch (pin) {\n\tcase 1:\n\t\treturn DI_GEN_POLARITY_1;\n\tcase 2:\n\t\treturn DI_GEN_POLARITY_2;\n\tcase 3:\n\t\treturn DI_GEN_POLARITY_3;\n\tcase 4:\n\t\treturn DI_GEN_POLARITY_4;\n\tcase 5:\n\t\treturn DI_GEN_POLARITY_5;\n\tcase 6:\n\t\treturn DI_GEN_POLARITY_6;\n\tcase 7:\n\t\treturn DI_GEN_POLARITY_7;\n\tcase 8:\n\t\treturn DI_GEN_POLARITY_8;\n\t}\n\treturn 0;\n}\n\nint ipu_di_init_sync_panel(struct ipu_di *di, struct ipu_di_signal_cfg *sig)\n{\n\tu32 reg;\n\tu32 di_gen, vsync_cnt;\n\tu32 div;\n\n\tdev_dbg(di->ipu->dev, \"disp %d: panel size = %d x %d\\n\",\n\t\tdi->id, sig->mode.hactive, sig->mode.vactive);\n\n\tdev_dbg(di->ipu->dev, \"Clocks: IPU %luHz DI %luHz Needed %luHz\\n\",\n\t\tclk_get_rate(di->clk_ipu),\n\t\tclk_get_rate(di->clk_di),\n\t\tsig->mode.pixelclock);\n\n\tmutex_lock(&di_mutex);\n\n\tipu_di_config_clock(di, sig);\n\n\tdiv = ipu_di_read(di, DI_BS_CLKGEN0) & 0xfff;\n\tdiv = div / 16;\t\t \n\n\t \n\t \n\tipu_di_write(di, (div << 16), DI_BS_CLKGEN1);\n\n\tipu_di_data_wave_config(di, SYNC_WAVE, div - 1, div - 1);\n\tipu_di_data_pin_config(di, SYNC_WAVE, DI_PIN15, 3, 0, div * 2);\n\n\tdi_gen = ipu_di_read(di, DI_GENERAL) & DI_GEN_DI_CLK_EXT;\n\tdi_gen |= DI_GEN_DI_VSYNC_EXT;\n\n\tif (sig->mode.flags & DISPLAY_FLAGS_INTERLACED) {\n\t\tipu_di_sync_config_interlaced(di, sig);\n\n\t\t \n\t\tdi_gen |= 0x10000000;\n\n\t\tvsync_cnt = 3;\n\t} else {\n\t\tipu_di_sync_config_noninterlaced(di, sig, div);\n\n\t\tvsync_cnt = 3;\n\t\tif (di->id == 1)\n\t\t\t \n\t\t\tif (!(sig->hsync_pin == 2 && sig->vsync_pin == 3))\n\t\t\t\tvsync_cnt = 6;\n\t}\n\n\tif (sig->mode.flags & DISPLAY_FLAGS_HSYNC_HIGH)\n\t\tdi_gen |= ipu_di_gen_polarity(sig->hsync_pin);\n\tif (sig->mode.flags & DISPLAY_FLAGS_VSYNC_HIGH)\n\t\tdi_gen |= ipu_di_gen_polarity(sig->vsync_pin);\n\n\tif (sig->clk_pol)\n\t\tdi_gen |= DI_GEN_POLARITY_DISP_CLK;\n\n\tipu_di_write(di, di_gen, DI_GENERAL);\n\n\tipu_di_write(di, (--vsync_cnt << DI_VSYNC_SEL_OFFSET) | 0x00000002,\n\t\t     DI_SYNC_AS_GEN);\n\n\treg = ipu_di_read(di, DI_POL);\n\treg &= ~(DI_POL_DRDY_DATA_POLARITY | DI_POL_DRDY_POLARITY_15);\n\n\tif (sig->enable_pol)\n\t\treg |= DI_POL_DRDY_POLARITY_15;\n\tif (sig->data_pol)\n\t\treg |= DI_POL_DRDY_DATA_POLARITY;\n\n\tipu_di_write(di, reg, DI_POL);\n\n\tmutex_unlock(&di_mutex);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(ipu_di_init_sync_panel);\n\nint ipu_di_enable(struct ipu_di *di)\n{\n\tint ret;\n\n\tWARN_ON(IS_ERR(di->clk_di_pixel));\n\n\tret = clk_prepare_enable(di->clk_di_pixel);\n\tif (ret)\n\t\treturn ret;\n\n\tipu_module_enable(di->ipu, di->module);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(ipu_di_enable);\n\nint ipu_di_disable(struct ipu_di *di)\n{\n\tWARN_ON(IS_ERR(di->clk_di_pixel));\n\n\tipu_module_disable(di->ipu, di->module);\n\n\tclk_disable_unprepare(di->clk_di_pixel);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(ipu_di_disable);\n\nint ipu_di_get_num(struct ipu_di *di)\n{\n\treturn di->id;\n}\nEXPORT_SYMBOL_GPL(ipu_di_get_num);\n\nstatic DEFINE_MUTEX(ipu_di_lock);\n\nstruct ipu_di *ipu_di_get(struct ipu_soc *ipu, int disp)\n{\n\tstruct ipu_di *di;\n\n\tif (disp > 1)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tdi = ipu->di_priv[disp];\n\n\tmutex_lock(&ipu_di_lock);\n\n\tif (di->inuse) {\n\t\tdi = ERR_PTR(-EBUSY);\n\t\tgoto out;\n\t}\n\n\tdi->inuse = true;\nout:\n\tmutex_unlock(&ipu_di_lock);\n\n\treturn di;\n}\nEXPORT_SYMBOL_GPL(ipu_di_get);\n\nvoid ipu_di_put(struct ipu_di *di)\n{\n\tmutex_lock(&ipu_di_lock);\n\n\tdi->inuse = false;\n\n\tmutex_unlock(&ipu_di_lock);\n}\nEXPORT_SYMBOL_GPL(ipu_di_put);\n\nint ipu_di_init(struct ipu_soc *ipu, struct device *dev, int id,\n\t\tunsigned long base,\n\t\tu32 module, struct clk *clk_ipu)\n{\n\tstruct ipu_di *di;\n\n\tif (id > 1)\n\t\treturn -ENODEV;\n\n\tdi = devm_kzalloc(dev, sizeof(*di), GFP_KERNEL);\n\tif (!di)\n\t\treturn -ENOMEM;\n\n\tipu->di_priv[id] = di;\n\n\tdi->clk_di = devm_clk_get(dev, id ? \"di1\" : \"di0\");\n\tif (IS_ERR(di->clk_di))\n\t\treturn PTR_ERR(di->clk_di);\n\n\tdi->module = module;\n\tdi->id = id;\n\tdi->clk_ipu = clk_ipu;\n\tdi->base = devm_ioremap(dev, base, PAGE_SIZE);\n\tif (!di->base)\n\t\treturn -ENOMEM;\n\n\tipu_di_write(di, 0x10, DI_BS_CLKGEN0);\n\n\tdev_dbg(dev, \"DI%d base: 0x%08lx remapped to %p\\n\",\n\t\t\tid, base, di->base);\n\tdi->inuse = false;\n\tdi->ipu = ipu;\n\n\treturn 0;\n}\n\nvoid ipu_di_exit(struct ipu_soc *ipu, int id)\n{\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}