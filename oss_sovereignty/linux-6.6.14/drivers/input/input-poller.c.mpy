{
  "module_name": "input-poller.c",
  "hash_id": "70ca632ff6d0afd196d50ae8ed66d144bd8c2189e4a2c24df3c41c51088a3e5c",
  "original_prompt": "Ingested from linux-6.6.14/drivers/input/input-poller.c",
  "human_readable_source": "\n \n\n#include <linux/device.h>\n#include <linux/input.h>\n#include <linux/jiffies.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/workqueue.h>\n#include \"input-poller.h\"\n\nstruct input_dev_poller {\n\tvoid (*poll)(struct input_dev *dev);\n\n\tunsigned int poll_interval;  \n\tunsigned int poll_interval_max;  \n\tunsigned int poll_interval_min;  \n\n\tstruct input_dev *input;\n\tstruct delayed_work work;\n};\n\nstatic void input_dev_poller_queue_work(struct input_dev_poller *poller)\n{\n\tunsigned long delay;\n\n\tdelay = msecs_to_jiffies(poller->poll_interval);\n\tif (delay >= HZ)\n\t\tdelay = round_jiffies_relative(delay);\n\n\tqueue_delayed_work(system_freezable_wq, &poller->work, delay);\n}\n\nstatic void input_dev_poller_work(struct work_struct *work)\n{\n\tstruct input_dev_poller *poller =\n\t\tcontainer_of(work, struct input_dev_poller, work.work);\n\n\tpoller->poll(poller->input);\n\tinput_dev_poller_queue_work(poller);\n}\n\nvoid input_dev_poller_finalize(struct input_dev_poller *poller)\n{\n\tif (!poller->poll_interval)\n\t\tpoller->poll_interval = 500;\n\tif (!poller->poll_interval_max)\n\t\tpoller->poll_interval_max = poller->poll_interval;\n}\n\nvoid input_dev_poller_start(struct input_dev_poller *poller)\n{\n\t \n\tif (poller->poll_interval > 0) {\n\t\tpoller->poll(poller->input);\n\t\tinput_dev_poller_queue_work(poller);\n\t}\n}\n\nvoid input_dev_poller_stop(struct input_dev_poller *poller)\n{\n\tcancel_delayed_work_sync(&poller->work);\n}\n\nint input_setup_polling(struct input_dev *dev,\n\t\t\tvoid (*poll_fn)(struct input_dev *dev))\n{\n\tstruct input_dev_poller *poller;\n\n\tpoller = kzalloc(sizeof(*poller), GFP_KERNEL);\n\tif (!poller) {\n\t\t \n\t\tdev_err(dev->dev.parent ?: &dev->dev,\n\t\t\t\"%s: unable to allocate poller structure\\n\", __func__);\n\t\treturn -ENOMEM;\n\t}\n\n\tINIT_DELAYED_WORK(&poller->work, input_dev_poller_work);\n\tpoller->input = dev;\n\tpoller->poll = poll_fn;\n\n\tdev->poller = poller;\n\treturn 0;\n}\nEXPORT_SYMBOL(input_setup_polling);\n\nstatic bool input_dev_ensure_poller(struct input_dev *dev)\n{\n\tif (!dev->poller) {\n\t\tdev_err(dev->dev.parent ?: &dev->dev,\n\t\t\t\"poller structure has not been set up\\n\");\n\t\treturn false;\n\t}\n\n\treturn true;\n}\n\nvoid input_set_poll_interval(struct input_dev *dev, unsigned int interval)\n{\n\tif (input_dev_ensure_poller(dev))\n\t\tdev->poller->poll_interval = interval;\n}\nEXPORT_SYMBOL(input_set_poll_interval);\n\nvoid input_set_min_poll_interval(struct input_dev *dev, unsigned int interval)\n{\n\tif (input_dev_ensure_poller(dev))\n\t\tdev->poller->poll_interval_min = interval;\n}\nEXPORT_SYMBOL(input_set_min_poll_interval);\n\nvoid input_set_max_poll_interval(struct input_dev *dev, unsigned int interval)\n{\n\tif (input_dev_ensure_poller(dev))\n\t\tdev->poller->poll_interval_max = interval;\n}\nEXPORT_SYMBOL(input_set_max_poll_interval);\n\nint input_get_poll_interval(struct input_dev *dev)\n{\n\tif (!dev->poller)\n\t\treturn -EINVAL;\n\n\treturn dev->poller->poll_interval;\n}\nEXPORT_SYMBOL(input_get_poll_interval);\n\n \n\nstatic ssize_t input_dev_get_poll_interval(struct device *dev,\n\t\t\t\t\t   struct device_attribute *attr,\n\t\t\t\t\t   char *buf)\n{\n\tstruct input_dev *input = to_input_dev(dev);\n\n\treturn sprintf(buf, \"%d\\n\", input->poller->poll_interval);\n}\n\nstatic ssize_t input_dev_set_poll_interval(struct device *dev,\n\t\t\t\t\t   struct device_attribute *attr,\n\t\t\t\t\t   const char *buf, size_t count)\n{\n\tstruct input_dev *input = to_input_dev(dev);\n\tstruct input_dev_poller *poller = input->poller;\n\tunsigned int interval;\n\tint err;\n\n\terr = kstrtouint(buf, 0, &interval);\n\tif (err)\n\t\treturn err;\n\n\tif (interval < poller->poll_interval_min)\n\t\treturn -EINVAL;\n\n\tif (interval > poller->poll_interval_max)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&input->mutex);\n\n\tpoller->poll_interval = interval;\n\n\tif (input_device_enabled(input)) {\n\t\tcancel_delayed_work_sync(&poller->work);\n\t\tif (poller->poll_interval > 0)\n\t\t\tinput_dev_poller_queue_work(poller);\n\t}\n\n\tmutex_unlock(&input->mutex);\n\n\treturn count;\n}\n\nstatic DEVICE_ATTR(poll, 0644,\n\t\t   input_dev_get_poll_interval, input_dev_set_poll_interval);\n\nstatic ssize_t input_dev_get_poll_max(struct device *dev,\n\t\t\t\t      struct device_attribute *attr, char *buf)\n{\n\tstruct input_dev *input = to_input_dev(dev);\n\n\treturn sprintf(buf, \"%d\\n\", input->poller->poll_interval_max);\n}\n\nstatic DEVICE_ATTR(max, 0444, input_dev_get_poll_max, NULL);\n\nstatic ssize_t input_dev_get_poll_min(struct device *dev,\n\t\t\t\t     struct device_attribute *attr, char *buf)\n{\n\tstruct input_dev *input = to_input_dev(dev);\n\n\treturn sprintf(buf, \"%d\\n\", input->poller->poll_interval_min);\n}\n\nstatic DEVICE_ATTR(min, 0444, input_dev_get_poll_min, NULL);\n\nstatic umode_t input_poller_attrs_visible(struct kobject *kobj,\n\t\t\t\t\t  struct attribute *attr, int n)\n{\n\tstruct device *dev = kobj_to_dev(kobj);\n\tstruct input_dev *input = to_input_dev(dev);\n\n\treturn input->poller ? attr->mode : 0;\n}\n\nstatic struct attribute *input_poller_attrs[] = {\n\t&dev_attr_poll.attr,\n\t&dev_attr_max.attr,\n\t&dev_attr_min.attr,\n\tNULL\n};\n\nstruct attribute_group input_poller_attribute_group = {\n\t.is_visible\t= input_poller_attrs_visible,\n\t.attrs\t\t= input_poller_attrs,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}