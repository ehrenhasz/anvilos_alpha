{
  "module_name": "input-leds.c",
  "hash_id": "075b319d97abecee26ffa8e52c7c1803a51b4c1ea3fdcf590176a7e8d51b9dcd",
  "original_prompt": "Ingested from linux-6.6.14/drivers/input/input-leds.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/leds.h>\n#include <linux/input.h>\n\n#if IS_ENABLED(CONFIG_VT)\n#define VT_TRIGGER(_name)\t.trigger = _name\n#else\n#define VT_TRIGGER(_name)\t.trigger = NULL\n#endif\n\nstatic const struct {\n\tconst char *name;\n\tconst char *trigger;\n} input_led_info[LED_CNT] = {\n\t[LED_NUML]\t= { \"numlock\", VT_TRIGGER(\"kbd-numlock\") },\n\t[LED_CAPSL]\t= { \"capslock\", VT_TRIGGER(\"kbd-capslock\") },\n\t[LED_SCROLLL]\t= { \"scrolllock\", VT_TRIGGER(\"kbd-scrolllock\") },\n\t[LED_COMPOSE]\t= { \"compose\" },\n\t[LED_KANA]\t= { \"kana\", VT_TRIGGER(\"kbd-kanalock\") },\n\t[LED_SLEEP]\t= { \"sleep\" } ,\n\t[LED_SUSPEND]\t= { \"suspend\" },\n\t[LED_MUTE]\t= { \"mute\" },\n\t[LED_MISC]\t= { \"misc\" },\n\t[LED_MAIL]\t= { \"mail\" },\n\t[LED_CHARGING]\t= { \"charging\" },\n};\n\nstruct input_led {\n\tstruct led_classdev cdev;\n\tstruct input_handle *handle;\n\tunsigned int code;  \n};\n\nstruct input_leds {\n\tstruct input_handle handle;\n\tunsigned int num_leds;\n\tstruct input_led leds[];\n};\n\nstatic enum led_brightness input_leds_brightness_get(struct led_classdev *cdev)\n{\n\tstruct input_led *led = container_of(cdev, struct input_led, cdev);\n\tstruct input_dev *input = led->handle->dev;\n\n\treturn test_bit(led->code, input->led) ? cdev->max_brightness : 0;\n}\n\nstatic void input_leds_brightness_set(struct led_classdev *cdev,\n\t\t\t\t      enum led_brightness brightness)\n{\n\tstruct input_led *led = container_of(cdev, struct input_led, cdev);\n\n\tinput_inject_event(led->handle, EV_LED, led->code, !!brightness);\n}\n\nstatic void input_leds_event(struct input_handle *handle, unsigned int type,\n\t\t\t     unsigned int code, int value)\n{\n}\n\nstatic int input_leds_get_count(struct input_dev *dev)\n{\n\tunsigned int led_code;\n\tint count = 0;\n\n\tfor_each_set_bit(led_code, dev->ledbit, LED_CNT)\n\t\tif (input_led_info[led_code].name)\n\t\t\tcount++;\n\n\treturn count;\n}\n\nstatic int input_leds_connect(struct input_handler *handler,\n\t\t\t      struct input_dev *dev,\n\t\t\t      const struct input_device_id *id)\n{\n\tstruct input_leds *leds;\n\tstruct input_led *led;\n\tunsigned int num_leds;\n\tunsigned int led_code;\n\tint led_no;\n\tint error;\n\n\tnum_leds = input_leds_get_count(dev);\n\tif (!num_leds)\n\t\treturn -ENXIO;\n\n\tleds = kzalloc(struct_size(leds, leds, num_leds), GFP_KERNEL);\n\tif (!leds)\n\t\treturn -ENOMEM;\n\n\tleds->num_leds = num_leds;\n\n\tleds->handle.dev = dev;\n\tleds->handle.handler = handler;\n\tleds->handle.name = \"leds\";\n\tleds->handle.private = leds;\n\n\terror = input_register_handle(&leds->handle);\n\tif (error)\n\t\tgoto err_free_mem;\n\n\terror = input_open_device(&leds->handle);\n\tif (error)\n\t\tgoto err_unregister_handle;\n\n\tled_no = 0;\n\tfor_each_set_bit(led_code, dev->ledbit, LED_CNT) {\n\t\tif (!input_led_info[led_code].name)\n\t\t\tcontinue;\n\n\t\tled = &leds->leds[led_no];\n\t\tled->handle = &leds->handle;\n\t\tled->code = led_code;\n\n\t\tled->cdev.name = kasprintf(GFP_KERNEL, \"%s::%s\",\n\t\t\t\t\t   dev_name(&dev->dev),\n\t\t\t\t\t   input_led_info[led_code].name);\n\t\tif (!led->cdev.name) {\n\t\t\terror = -ENOMEM;\n\t\t\tgoto err_unregister_leds;\n\t\t}\n\n\t\tled->cdev.max_brightness = 1;\n\t\tled->cdev.brightness_get = input_leds_brightness_get;\n\t\tled->cdev.brightness_set = input_leds_brightness_set;\n\t\tled->cdev.default_trigger = input_led_info[led_code].trigger;\n\n\t\terror = led_classdev_register(&dev->dev, &led->cdev);\n\t\tif (error) {\n\t\t\tdev_err(&dev->dev, \"failed to register LED %s: %d\\n\",\n\t\t\t\tled->cdev.name, error);\n\t\t\tkfree(led->cdev.name);\n\t\t\tgoto err_unregister_leds;\n\t\t}\n\n\t\tled_no++;\n\t}\n\n\treturn 0;\n\nerr_unregister_leds:\n\twhile (--led_no >= 0) {\n\t\tstruct input_led *led = &leds->leds[led_no];\n\n\t\tled_classdev_unregister(&led->cdev);\n\t\tkfree(led->cdev.name);\n\t}\n\n\tinput_close_device(&leds->handle);\n\nerr_unregister_handle:\n\tinput_unregister_handle(&leds->handle);\n\nerr_free_mem:\n\tkfree(leds);\n\treturn error;\n}\n\nstatic void input_leds_disconnect(struct input_handle *handle)\n{\n\tstruct input_leds *leds = handle->private;\n\tint i;\n\n\tfor (i = 0; i < leds->num_leds; i++) {\n\t\tstruct input_led *led = &leds->leds[i];\n\n\t\tled_classdev_unregister(&led->cdev);\n\t\tkfree(led->cdev.name);\n\t}\n\n\tinput_close_device(handle);\n\tinput_unregister_handle(handle);\n\n\tkfree(leds);\n}\n\nstatic const struct input_device_id input_leds_ids[] = {\n\t{\n\t\t.flags = INPUT_DEVICE_ID_MATCH_EVBIT,\n\t\t.evbit = { BIT_MASK(EV_LED) },\n\t},\n\t{ },\n};\nMODULE_DEVICE_TABLE(input, input_leds_ids);\n\nstatic struct input_handler input_leds_handler = {\n\t.event =\tinput_leds_event,\n\t.connect =\tinput_leds_connect,\n\t.disconnect =\tinput_leds_disconnect,\n\t.name =\t\t\"leds\",\n\t.id_table =\tinput_leds_ids,\n};\n\nstatic int __init input_leds_init(void)\n{\n\treturn input_register_handler(&input_leds_handler);\n}\nmodule_init(input_leds_init);\n\nstatic void __exit input_leds_exit(void)\n{\n\tinput_unregister_handler(&input_leds_handler);\n}\nmodule_exit(input_leds_exit);\n\nMODULE_AUTHOR(\"Samuel Thibault <samuel.thibault@ens-lyon.org>\");\nMODULE_AUTHOR(\"Dmitry Torokhov <dmitry.torokhov@gmail.com>\");\nMODULE_DESCRIPTION(\"Input -> LEDs Bridge\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}