{
  "module_name": "ff-core.c",
  "hash_id": "b455bd6516dabe847b9c043e42235ff5a832f9b4e10184b1abca39f8c0170dad",
  "original_prompt": "Ingested from linux-6.6.14/drivers/input/ff-core.c",
  "human_readable_source": "\n \n\n \n\n#include <linux/input.h>\n#include <linux/module.h>\n#include <linux/mutex.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n\n \nstatic int check_effect_access(struct ff_device *ff, int effect_id,\n\t\t\t\tstruct file *file)\n{\n\tif (effect_id < 0 || effect_id >= ff->max_effects ||\n\t    !ff->effect_owners[effect_id])\n\t\treturn -EINVAL;\n\n\tif (file && ff->effect_owners[effect_id] != file)\n\t\treturn -EACCES;\n\n\treturn 0;\n}\n\n \nstatic inline int check_effects_compatible(struct ff_effect *e1,\n\t\t\t\t\t   struct ff_effect *e2)\n{\n\treturn e1->type == e2->type &&\n\t       (e1->type != FF_PERIODIC ||\n\t\te1->u.periodic.waveform == e2->u.periodic.waveform);\n}\n\n \nstatic int compat_effect(struct ff_device *ff, struct ff_effect *effect)\n{\n\tint magnitude;\n\n\tswitch (effect->type) {\n\tcase FF_RUMBLE:\n\t\tif (!test_bit(FF_PERIODIC, ff->ffbit))\n\t\t\treturn -EINVAL;\n\n\t\t \n\t\tmagnitude = effect->u.rumble.strong_magnitude / 3 +\n\t\t\t    effect->u.rumble.weak_magnitude / 6;\n\n\t\teffect->type = FF_PERIODIC;\n\t\teffect->u.periodic.waveform = FF_SINE;\n\t\teffect->u.periodic.period = 50;\n\t\teffect->u.periodic.magnitude = magnitude;\n\t\teffect->u.periodic.offset = 0;\n\t\teffect->u.periodic.phase = 0;\n\t\teffect->u.periodic.envelope.attack_length = 0;\n\t\teffect->u.periodic.envelope.attack_level = 0;\n\t\teffect->u.periodic.envelope.fade_length = 0;\n\t\teffect->u.periodic.envelope.fade_level = 0;\n\n\t\treturn 0;\n\n\tdefault:\n\t\t \n\t\treturn 0;\n\t}\n}\n\n \nint input_ff_upload(struct input_dev *dev, struct ff_effect *effect,\n\t\t    struct file *file)\n{\n\tstruct ff_device *ff = dev->ff;\n\tstruct ff_effect *old;\n\tint ret = 0;\n\tint id;\n\n\tif (!test_bit(EV_FF, dev->evbit))\n\t\treturn -ENOSYS;\n\n\tif (effect->type < FF_EFFECT_MIN || effect->type > FF_EFFECT_MAX ||\n\t    !test_bit(effect->type, dev->ffbit)) {\n\t\tdev_dbg(&dev->dev, \"invalid or not supported effect type in upload\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (effect->type == FF_PERIODIC &&\n\t    (effect->u.periodic.waveform < FF_WAVEFORM_MIN ||\n\t     effect->u.periodic.waveform > FF_WAVEFORM_MAX ||\n\t     !test_bit(effect->u.periodic.waveform, dev->ffbit))) {\n\t\tdev_dbg(&dev->dev, \"invalid or not supported wave form in upload\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (!test_bit(effect->type, ff->ffbit)) {\n\t\tret = compat_effect(ff, effect);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tmutex_lock(&ff->mutex);\n\n\tif (effect->id == -1) {\n\t\tfor (id = 0; id < ff->max_effects; id++)\n\t\t\tif (!ff->effect_owners[id])\n\t\t\t\tbreak;\n\n\t\tif (id >= ff->max_effects) {\n\t\t\tret = -ENOSPC;\n\t\t\tgoto out;\n\t\t}\n\n\t\teffect->id = id;\n\t\told = NULL;\n\n\t} else {\n\t\tid = effect->id;\n\n\t\tret = check_effect_access(ff, id, file);\n\t\tif (ret)\n\t\t\tgoto out;\n\n\t\told = &ff->effects[id];\n\n\t\tif (!check_effects_compatible(effect, old)) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tret = ff->upload(dev, effect, old);\n\tif (ret)\n\t\tgoto out;\n\n\tspin_lock_irq(&dev->event_lock);\n\tff->effects[id] = *effect;\n\tff->effect_owners[id] = file;\n\tspin_unlock_irq(&dev->event_lock);\n\n out:\n\tmutex_unlock(&ff->mutex);\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(input_ff_upload);\n\n \nstatic int erase_effect(struct input_dev *dev, int effect_id,\n\t\t\tstruct file *file)\n{\n\tstruct ff_device *ff = dev->ff;\n\tint error;\n\n\terror = check_effect_access(ff, effect_id, file);\n\tif (error)\n\t\treturn error;\n\n\tspin_lock_irq(&dev->event_lock);\n\tff->playback(dev, effect_id, 0);\n\tff->effect_owners[effect_id] = NULL;\n\tspin_unlock_irq(&dev->event_lock);\n\n\tif (ff->erase) {\n\t\terror = ff->erase(dev, effect_id);\n\t\tif (error) {\n\t\t\tspin_lock_irq(&dev->event_lock);\n\t\t\tff->effect_owners[effect_id] = file;\n\t\t\tspin_unlock_irq(&dev->event_lock);\n\n\t\t\treturn error;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n \nint input_ff_erase(struct input_dev *dev, int effect_id, struct file *file)\n{\n\tstruct ff_device *ff = dev->ff;\n\tint ret;\n\n\tif (!test_bit(EV_FF, dev->evbit))\n\t\treturn -ENOSYS;\n\n\tmutex_lock(&ff->mutex);\n\tret = erase_effect(dev, effect_id, file);\n\tmutex_unlock(&ff->mutex);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(input_ff_erase);\n\n \nint input_ff_flush(struct input_dev *dev, struct file *file)\n{\n\tstruct ff_device *ff = dev->ff;\n\tint i;\n\n\tdev_dbg(&dev->dev, \"flushing now\\n\");\n\n\tmutex_lock(&ff->mutex);\n\n\tfor (i = 0; i < ff->max_effects; i++)\n\t\terase_effect(dev, i, file);\n\n\tmutex_unlock(&ff->mutex);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(input_ff_flush);\n\n \nint input_ff_event(struct input_dev *dev, unsigned int type,\n\t\t   unsigned int code, int value)\n{\n\tstruct ff_device *ff = dev->ff;\n\n\tif (type != EV_FF)\n\t\treturn 0;\n\n\tswitch (code) {\n\tcase FF_GAIN:\n\t\tif (!test_bit(FF_GAIN, dev->ffbit) || value > 0xffffU)\n\t\t\tbreak;\n\n\t\tff->set_gain(dev, value);\n\t\tbreak;\n\n\tcase FF_AUTOCENTER:\n\t\tif (!test_bit(FF_AUTOCENTER, dev->ffbit) || value > 0xffffU)\n\t\t\tbreak;\n\n\t\tff->set_autocenter(dev, value);\n\t\tbreak;\n\n\tdefault:\n\t\tif (check_effect_access(ff, code, NULL) == 0)\n\t\t\tff->playback(dev, code, value);\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(input_ff_event);\n\n \nint input_ff_create(struct input_dev *dev, unsigned int max_effects)\n{\n\tstruct ff_device *ff;\n\tsize_t ff_dev_size;\n\tint i;\n\n\tif (!max_effects) {\n\t\tdev_err(&dev->dev, \"cannot allocate device without any effects\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (max_effects > FF_MAX_EFFECTS) {\n\t\tdev_err(&dev->dev, \"cannot allocate more than FF_MAX_EFFECTS effects\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tff_dev_size = sizeof(struct ff_device) +\n\t\t\t\tmax_effects * sizeof(struct file *);\n\tif (ff_dev_size < max_effects)  \n\t\treturn -EINVAL;\n\n\tff = kzalloc(ff_dev_size, GFP_KERNEL);\n\tif (!ff)\n\t\treturn -ENOMEM;\n\n\tff->effects = kcalloc(max_effects, sizeof(struct ff_effect),\n\t\t\t      GFP_KERNEL);\n\tif (!ff->effects) {\n\t\tkfree(ff);\n\t\treturn -ENOMEM;\n\t}\n\n\tff->max_effects = max_effects;\n\tmutex_init(&ff->mutex);\n\n\tdev->ff = ff;\n\tdev->flush = input_ff_flush;\n\tdev->event = input_ff_event;\n\t__set_bit(EV_FF, dev->evbit);\n\n\t \n\tfor_each_set_bit(i, dev->ffbit, FF_CNT)\n\t\t__set_bit(i, ff->ffbit);\n\n\t \n\tif (test_bit(FF_PERIODIC, ff->ffbit))\n\t\t__set_bit(FF_RUMBLE, dev->ffbit);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(input_ff_create);\n\n \nvoid input_ff_destroy(struct input_dev *dev)\n{\n\tstruct ff_device *ff = dev->ff;\n\n\t__clear_bit(EV_FF, dev->evbit);\n\tif (ff) {\n\t\tif (ff->destroy)\n\t\t\tff->destroy(ff);\n\t\tkfree(ff->private);\n\t\tkfree(ff->effects);\n\t\tkfree(ff);\n\t\tdev->ff = NULL;\n\t}\n}\nEXPORT_SYMBOL_GPL(input_ff_destroy);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}