{
  "module_name": "lightning.c",
  "hash_id": "e2237aff4f8e1cad16517a05a4f1f45d1463c1ae5f79420827caa8bc1b2a7857",
  "original_prompt": "Ingested from linux-6.6.14/drivers/input/gameport/lightning.c",
  "human_readable_source": "\n \n\n \n\n#include <asm/io.h>\n#include <linux/delay.h>\n#include <linux/errno.h>\n#include <linux/ioport.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/gameport.h>\n\n#define L4_PORT\t\t\t0x201\n#define L4_SELECT_ANALOG\t0xa4\n#define L4_SELECT_DIGITAL\t0xa5\n#define L4_SELECT_SECONDARY\t0xa6\n#define L4_CMD_ID\t\t0x80\n#define L4_CMD_GETCAL\t\t0x92\n#define L4_CMD_SETCAL\t\t0x93\n#define L4_ID\t\t\t0x04\n#define L4_BUSY\t\t\t0x01\n#define L4_TIMEOUT\t\t80\t \n\nMODULE_AUTHOR(\"Vojtech Pavlik <vojtech@ucw.cz>\");\nMODULE_DESCRIPTION(\"PDPI Lightning 4 gamecard driver\");\nMODULE_LICENSE(\"GPL\");\n\nstruct l4 {\n\tstruct gameport *gameport;\n\tunsigned char port;\n};\n\nstatic struct l4 l4_ports[8];\n\n \n\nstatic int l4_wait_ready(void)\n{\n\tunsigned int t = L4_TIMEOUT;\n\n\twhile ((inb(L4_PORT) & L4_BUSY) && t > 0) t--;\n\treturn -(t <= 0);\n}\n\n \n\nstatic int l4_cooked_read(struct gameport *gameport, int *axes, int *buttons)\n{\n\tstruct l4 *l4 = gameport->port_data;\n\tunsigned char status;\n\tint i, result = -1;\n\n\toutb(L4_SELECT_ANALOG, L4_PORT);\n\toutb(L4_SELECT_DIGITAL + (l4->port >> 2), L4_PORT);\n\n\tif (inb(L4_PORT) & L4_BUSY) goto fail;\n\toutb(l4->port & 3, L4_PORT);\n\n\tif (l4_wait_ready()) goto fail;\n\tstatus = inb(L4_PORT);\n\n\tfor (i = 0; i < 4; i++)\n\t\tif (status & (1 << i)) {\n\t\t\tif (l4_wait_ready()) goto fail;\n\t\t\taxes[i] = inb(L4_PORT);\n\t\t\tif (axes[i] > 252) axes[i] = -1;\n\t\t}\n\n\tif (status & 0x10) {\n\t\tif (l4_wait_ready()) goto fail;\n\t\t*buttons = inb(L4_PORT) & 0x0f;\n\t}\n\n\tresult = 0;\n\nfail:\toutb(L4_SELECT_ANALOG, L4_PORT);\n\treturn result;\n}\n\nstatic int l4_open(struct gameport *gameport, int mode)\n{\n\tstruct l4 *l4 = gameport->port_data;\n\n        if (l4->port != 0 && mode != GAMEPORT_MODE_COOKED)\n\t\treturn -1;\n\toutb(L4_SELECT_ANALOG, L4_PORT);\n\treturn 0;\n}\n\n \n\nstatic int l4_getcal(int port, int *cal)\n{\n\tint i, result = -1;\n\n\toutb(L4_SELECT_ANALOG, L4_PORT);\n\toutb(L4_SELECT_DIGITAL + (port >> 2), L4_PORT);\n\tif (inb(L4_PORT) & L4_BUSY)\n\t\tgoto out;\n\n\toutb(L4_CMD_GETCAL, L4_PORT);\n\tif (l4_wait_ready())\n\t\tgoto out;\n\n\tif (inb(L4_PORT) != L4_SELECT_DIGITAL + (port >> 2))\n\t\tgoto out;\n\n\tif (l4_wait_ready())\n\t\tgoto out;\n        outb(port & 3, L4_PORT);\n\n\tfor (i = 0; i < 4; i++) {\n\t\tif (l4_wait_ready())\n\t\t\tgoto out;\n\t\tcal[i] = inb(L4_PORT);\n\t}\n\n\tresult = 0;\n\nout:\toutb(L4_SELECT_ANALOG, L4_PORT);\n\treturn result;\n}\n\n \n\nstatic int l4_setcal(int port, int *cal)\n{\n\tint i, result = -1;\n\n\toutb(L4_SELECT_ANALOG, L4_PORT);\n\toutb(L4_SELECT_DIGITAL + (port >> 2), L4_PORT);\n\tif (inb(L4_PORT) & L4_BUSY)\n\t\tgoto out;\n\n\toutb(L4_CMD_SETCAL, L4_PORT);\n\tif (l4_wait_ready())\n\t\tgoto out;\n\n\tif (inb(L4_PORT) != L4_SELECT_DIGITAL + (port >> 2))\n\t\tgoto out;\n\n\tif (l4_wait_ready())\n\t\tgoto out;\n        outb(port & 3, L4_PORT);\n\n\tfor (i = 0; i < 4; i++) {\n\t\tif (l4_wait_ready())\n\t\t\tgoto out;\n\t\toutb(cal[i], L4_PORT);\n\t}\n\n\tresult = 0;\n\nout:\toutb(L4_SELECT_ANALOG, L4_PORT);\n\treturn result;\n}\n\n \n\nstatic int l4_calibrate(struct gameport *gameport, int *axes, int *max)\n{\n\tint i, t;\n\tint cal[4];\n\tstruct l4 *l4 = gameport->port_data;\n\n\tif (l4_getcal(l4->port, cal))\n\t\treturn -1;\n\n\tfor (i = 0; i < 4; i++) {\n\t\tt = (max[i] * cal[i]) / 200;\n\t\tt = (t < 1) ? 1 : ((t > 255) ? 255 : t);\n\t\taxes[i] = (axes[i] < 0) ? -1 : (axes[i] * cal[i]) / t;\n\t\taxes[i] = (axes[i] > 252) ? 252 : axes[i];\n\t\tcal[i] = t;\n\t}\n\n\tif (l4_setcal(l4->port, cal))\n\t\treturn -1;\n\n\treturn 0;\n}\n\nstatic int __init l4_create_ports(int card_no)\n{\n\tstruct l4 *l4;\n\tstruct gameport *port;\n\tint i, idx;\n\n\tfor (i = 0; i < 4; i++) {\n\n\t\tidx = card_no * 4 + i;\n\t\tl4 = &l4_ports[idx];\n\n\t\tif (!(l4->gameport = port = gameport_allocate_port())) {\n\t\t\tprintk(KERN_ERR \"lightning: Memory allocation failed\\n\");\n\t\t\twhile (--i >= 0) {\n\t\t\t\tgameport_free_port(l4->gameport);\n\t\t\t\tl4->gameport = NULL;\n\t\t\t}\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tl4->port = idx;\n\n\t\tport->port_data = l4;\n\t\tport->open = l4_open;\n\t\tport->cooked_read = l4_cooked_read;\n\t\tport->calibrate = l4_calibrate;\n\n\t\tgameport_set_name(port, \"PDPI Lightning 4\");\n\t\tgameport_set_phys(port, \"isa%04x/gameport%d\", L4_PORT, idx);\n\n\t\tif (idx == 0)\n\t\t\tport->io = L4_PORT;\n\t}\n\n\treturn 0;\n}\n\nstatic int __init l4_add_card(int card_no)\n{\n\tint cal[4] = { 255, 255, 255, 255 };\n\tint i, rev, result;\n\tstruct l4 *l4;\n\n\toutb(L4_SELECT_ANALOG, L4_PORT);\n\toutb(L4_SELECT_DIGITAL + card_no, L4_PORT);\n\n\tif (inb(L4_PORT) & L4_BUSY)\n\t\treturn -1;\n\toutb(L4_CMD_ID, L4_PORT);\n\n\tif (l4_wait_ready())\n\t\treturn -1;\n\n\tif (inb(L4_PORT) != L4_SELECT_DIGITAL + card_no)\n\t\treturn -1;\n\n\tif (l4_wait_ready())\n\t\treturn -1;\n\tif (inb(L4_PORT) != L4_ID)\n\t\treturn -1;\n\n\tif (l4_wait_ready())\n\t\treturn -1;\n\trev = inb(L4_PORT);\n\n\tif (!rev)\n\t\treturn -1;\n\n\tresult = l4_create_ports(card_no);\n\tif (result)\n\t\treturn result;\n\n\tprintk(KERN_INFO \"gameport: PDPI Lightning 4 %s card v%d.%d at %#x\\n\",\n\t\tcard_no ? \"secondary\" : \"primary\", rev >> 4, rev, L4_PORT);\n\n\tfor (i = 0; i < 4; i++) {\n\t\tl4 = &l4_ports[card_no * 4 + i];\n\n\t\tif (rev > 0x28)\t\t \n\t\t\tl4_setcal(l4->port, cal);\n\t\tgameport_register_port(l4->gameport);\n\t}\n\n\treturn 0;\n}\n\nstatic int __init l4_init(void)\n{\n\tint i, cards = 0;\n\n\tif (!request_region(L4_PORT, 1, \"lightning\"))\n\t\treturn -EBUSY;\n\n\tfor (i = 0; i < 2; i++)\n\t\tif (l4_add_card(i) == 0)\n\t\t\tcards++;\n\n\toutb(L4_SELECT_ANALOG, L4_PORT);\n\n\tif (!cards) {\n\t\trelease_region(L4_PORT, 1);\n\t\treturn -ENODEV;\n\t}\n\n\treturn 0;\n}\n\nstatic void __exit l4_exit(void)\n{\n\tint i;\n\tint cal[4] = { 59, 59, 59, 59 };\n\n\tfor (i = 0; i < 8; i++)\n\t\tif (l4_ports[i].gameport) {\n\t\t\tl4_setcal(l4_ports[i].port, cal);\n\t\t\tgameport_unregister_port(l4_ports[i].gameport);\n\t\t}\n\n\toutb(L4_SELECT_ANALOG, L4_PORT);\n\trelease_region(L4_PORT, 1);\n}\n\nmodule_init(l4_init);\nmodule_exit(l4_exit);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}