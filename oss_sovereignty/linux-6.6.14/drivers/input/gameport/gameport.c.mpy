{
  "module_name": "gameport.c",
  "hash_id": "2645a4791380c70bd3ce206d7c5eb8007b49fe336e3192fd513c908926058a7f",
  "original_prompt": "Ingested from linux-6.6.14/drivers/input/gameport/gameport.c",
  "human_readable_source": "\n \n\n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/stddef.h>\n#include <linux/module.h>\n#include <linux/io.h>\n#include <linux/ioport.h>\n#include <linux/init.h>\n#include <linux/gameport.h>\n#include <linux/slab.h>\n#include <linux/delay.h>\n#include <linux/workqueue.h>\n#include <linux/sched.h>\t \n#include <linux/mutex.h>\n#include <linux/timekeeping.h>\n\nMODULE_AUTHOR(\"Vojtech Pavlik <vojtech@ucw.cz>\");\nMODULE_DESCRIPTION(\"Generic gameport layer\");\nMODULE_LICENSE(\"GPL\");\n\nstatic bool use_ktime = true;\nmodule_param(use_ktime, bool, 0400);\nMODULE_PARM_DESC(use_ktime, \"Use ktime for measuring I/O speed\");\n\n \nstatic DEFINE_MUTEX(gameport_mutex);\n\nstatic LIST_HEAD(gameport_list);\n\nstatic struct bus_type gameport_bus;\n\nstatic void gameport_add_port(struct gameport *gameport);\nstatic void gameport_attach_driver(struct gameport_driver *drv);\nstatic void gameport_reconnect_port(struct gameport *gameport);\nstatic void gameport_disconnect_port(struct gameport *gameport);\n\n#if defined(__i386__)\n\n#include <linux/i8253.h>\n\n#define DELTA(x,y)      ((y)-(x)+((y)<(x)?1193182/HZ:0))\n#define GET_TIME(x)     do { x = get_time_pit(); } while (0)\n\nstatic unsigned int get_time_pit(void)\n{\n\tunsigned long flags;\n\tunsigned int count;\n\n\traw_spin_lock_irqsave(&i8253_lock, flags);\n\toutb_p(0x00, 0x43);\n\tcount = inb_p(0x40);\n\tcount |= inb_p(0x40) << 8;\n\traw_spin_unlock_irqrestore(&i8253_lock, flags);\n\n\treturn count;\n}\n\n#endif\n\n\n\n \n\nstatic int gameport_measure_speed(struct gameport *gameport)\n{\n\tunsigned int i, t, tx;\n\tu64 t1, t2, t3;\n\tunsigned long flags;\n\n\tif (gameport_open(gameport, NULL, GAMEPORT_MODE_RAW))\n\t\treturn 0;\n\n\ttx = ~0;\n\n\tfor (i = 0; i < 50; i++) {\n\t\tlocal_irq_save(flags);\n\t\tt1 = ktime_get_ns();\n\t\tfor (t = 0; t < 50; t++)\n\t\t\tgameport_read(gameport);\n\t\tt2 = ktime_get_ns();\n\t\tt3 = ktime_get_ns();\n\t\tlocal_irq_restore(flags);\n\t\tudelay(i * 10);\n\t\tt = (t2 - t1) - (t3 - t2);\n\t\tif (t < tx)\n\t\t\ttx = t;\n\t}\n\n\tgameport_close(gameport);\n\tt = 1000000 * 50;\n\tif (tx)\n\t\tt /= tx;\n\treturn t;\n}\n\nstatic int old_gameport_measure_speed(struct gameport *gameport)\n{\n#if defined(__i386__)\n\n\tunsigned int i, t, t1, t2, t3, tx;\n\tunsigned long flags;\n\n\tif (gameport_open(gameport, NULL, GAMEPORT_MODE_RAW))\n\t\treturn 0;\n\n\ttx = 1 << 30;\n\n\tfor(i = 0; i < 50; i++) {\n\t\tlocal_irq_save(flags);\n\t\tGET_TIME(t1);\n\t\tfor (t = 0; t < 50; t++) gameport_read(gameport);\n\t\tGET_TIME(t2);\n\t\tGET_TIME(t3);\n\t\tlocal_irq_restore(flags);\n\t\tudelay(i * 10);\n\t\tif ((t = DELTA(t2,t1) - DELTA(t3,t2)) < tx) tx = t;\n\t}\n\n\tgameport_close(gameport);\n\treturn 59659 / (tx < 1 ? 1 : tx);\n\n#elif defined (__x86_64__)\n\n\tunsigned int i, t;\n\tunsigned long tx, t1, t2, flags;\n\n\tif (gameport_open(gameport, NULL, GAMEPORT_MODE_RAW))\n\t\treturn 0;\n\n\ttx = 1 << 30;\n\n\tfor(i = 0; i < 50; i++) {\n\t\tlocal_irq_save(flags);\n\t\tt1 = rdtsc();\n\t\tfor (t = 0; t < 50; t++) gameport_read(gameport);\n\t\tt2 = rdtsc();\n\t\tlocal_irq_restore(flags);\n\t\tudelay(i * 10);\n\t\tif (t2 - t1 < tx) tx = t2 - t1;\n\t}\n\n\tgameport_close(gameport);\n\treturn (this_cpu_read(cpu_info.loops_per_jiffy) *\n\t\t(unsigned long)HZ / (1000 / 50)) / (tx < 1 ? 1 : tx);\n\n#else\n\n\tunsigned int j, t = 0;\n\n\tif (gameport_open(gameport, NULL, GAMEPORT_MODE_RAW))\n\t\treturn 0;\n\n\tj = jiffies; while (j == jiffies);\n\tj = jiffies; while (j == jiffies) { t++; gameport_read(gameport); }\n\n\tgameport_close(gameport);\n\treturn t * HZ / 1000;\n\n#endif\n}\n\nvoid gameport_start_polling(struct gameport *gameport)\n{\n\tspin_lock(&gameport->timer_lock);\n\n\tif (!gameport->poll_cnt++) {\n\t\tBUG_ON(!gameport->poll_handler);\n\t\tBUG_ON(!gameport->poll_interval);\n\t\tmod_timer(&gameport->poll_timer, jiffies + msecs_to_jiffies(gameport->poll_interval));\n\t}\n\n\tspin_unlock(&gameport->timer_lock);\n}\nEXPORT_SYMBOL(gameport_start_polling);\n\nvoid gameport_stop_polling(struct gameport *gameport)\n{\n\tspin_lock(&gameport->timer_lock);\n\n\tif (!--gameport->poll_cnt)\n\t\tdel_timer(&gameport->poll_timer);\n\n\tspin_unlock(&gameport->timer_lock);\n}\nEXPORT_SYMBOL(gameport_stop_polling);\n\nstatic void gameport_run_poll_handler(struct timer_list *t)\n{\n\tstruct gameport *gameport = from_timer(gameport, t, poll_timer);\n\n\tgameport->poll_handler(gameport);\n\tif (gameport->poll_cnt)\n\t\tmod_timer(&gameport->poll_timer, jiffies + msecs_to_jiffies(gameport->poll_interval));\n}\n\n \n\nstatic int gameport_bind_driver(struct gameport *gameport, struct gameport_driver *drv)\n{\n\tint error;\n\n\tgameport->dev.driver = &drv->driver;\n\tif (drv->connect(gameport, drv)) {\n\t\tgameport->dev.driver = NULL;\n\t\treturn -ENODEV;\n\t}\n\n\terror = device_bind_driver(&gameport->dev);\n\tif (error) {\n\t\tdev_warn(&gameport->dev,\n\t\t\t \"device_bind_driver() failed for %s (%s) and %s, error: %d\\n\",\n\t\t\tgameport->phys, gameport->name,\n\t\t\tdrv->description, error);\n\t\tdrv->disconnect(gameport);\n\t\tgameport->dev.driver = NULL;\n\t\treturn error;\n\t}\n\n\treturn 0;\n}\n\nstatic void gameport_find_driver(struct gameport *gameport)\n{\n\tint error;\n\n\terror = device_attach(&gameport->dev);\n\tif (error < 0)\n\t\tdev_warn(&gameport->dev,\n\t\t\t \"device_attach() failed for %s (%s), error: %d\\n\",\n\t\t\t gameport->phys, gameport->name, error);\n}\n\n\n \n\nenum gameport_event_type {\n\tGAMEPORT_REGISTER_PORT,\n\tGAMEPORT_ATTACH_DRIVER,\n};\n\nstruct gameport_event {\n\tenum gameport_event_type type;\n\tvoid *object;\n\tstruct module *owner;\n\tstruct list_head node;\n};\n\nstatic DEFINE_SPINLOCK(gameport_event_lock);\t \nstatic LIST_HEAD(gameport_event_list);\n\nstatic struct gameport_event *gameport_get_event(void)\n{\n\tstruct gameport_event *event = NULL;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&gameport_event_lock, flags);\n\n\tif (!list_empty(&gameport_event_list)) {\n\t\tevent = list_first_entry(&gameport_event_list,\n\t\t\t\t\t struct gameport_event, node);\n\t\tlist_del_init(&event->node);\n\t}\n\n\tspin_unlock_irqrestore(&gameport_event_lock, flags);\n\treturn event;\n}\n\nstatic void gameport_free_event(struct gameport_event *event)\n{\n\tmodule_put(event->owner);\n\tkfree(event);\n}\n\nstatic void gameport_remove_duplicate_events(struct gameport_event *event)\n{\n\tstruct gameport_event *e, *next;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&gameport_event_lock, flags);\n\n\tlist_for_each_entry_safe(e, next, &gameport_event_list, node) {\n\t\tif (event->object == e->object) {\n\t\t\t \n\t\t\tif (event->type != e->type)\n\t\t\t\tbreak;\n\n\t\t\tlist_del_init(&e->node);\n\t\t\tgameport_free_event(e);\n\t\t}\n\t}\n\n\tspin_unlock_irqrestore(&gameport_event_lock, flags);\n}\n\n\nstatic void gameport_handle_events(struct work_struct *work)\n{\n\tstruct gameport_event *event;\n\n\tmutex_lock(&gameport_mutex);\n\n\t \n\tif ((event = gameport_get_event())) {\n\n\t\tswitch (event->type) {\n\n\t\tcase GAMEPORT_REGISTER_PORT:\n\t\t\tgameport_add_port(event->object);\n\t\t\tbreak;\n\n\t\tcase GAMEPORT_ATTACH_DRIVER:\n\t\t\tgameport_attach_driver(event->object);\n\t\t\tbreak;\n\t\t}\n\n\t\tgameport_remove_duplicate_events(event);\n\t\tgameport_free_event(event);\n\t}\n\n\tmutex_unlock(&gameport_mutex);\n}\n\nstatic DECLARE_WORK(gameport_event_work, gameport_handle_events);\n\nstatic int gameport_queue_event(void *object, struct module *owner,\n\t\t\t\tenum gameport_event_type event_type)\n{\n\tunsigned long flags;\n\tstruct gameport_event *event;\n\tint retval = 0;\n\n\tspin_lock_irqsave(&gameport_event_lock, flags);\n\n\t \n\tlist_for_each_entry_reverse(event, &gameport_event_list, node) {\n\t\tif (event->object == object) {\n\t\t\tif (event->type == event_type)\n\t\t\t\tgoto out;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tevent = kmalloc(sizeof(struct gameport_event), GFP_ATOMIC);\n\tif (!event) {\n\t\tpr_err(\"Not enough memory to queue event %d\\n\", event_type);\n\t\tretval = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tif (!try_module_get(owner)) {\n\t\tpr_warn(\"Can't get module reference, dropping event %d\\n\",\n\t\t\tevent_type);\n\t\tkfree(event);\n\t\tretval = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tevent->type = event_type;\n\tevent->object = object;\n\tevent->owner = owner;\n\n\tlist_add_tail(&event->node, &gameport_event_list);\n\tqueue_work(system_long_wq, &gameport_event_work);\n\nout:\n\tspin_unlock_irqrestore(&gameport_event_lock, flags);\n\treturn retval;\n}\n\n \nstatic void gameport_remove_pending_events(void *object)\n{\n\tstruct gameport_event *event, *next;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&gameport_event_lock, flags);\n\n\tlist_for_each_entry_safe(event, next, &gameport_event_list, node) {\n\t\tif (event->object == object) {\n\t\t\tlist_del_init(&event->node);\n\t\t\tgameport_free_event(event);\n\t\t}\n\t}\n\n\tspin_unlock_irqrestore(&gameport_event_lock, flags);\n}\n\n \nstatic struct gameport *gameport_get_pending_child(struct gameport *parent)\n{\n\tstruct gameport_event *event;\n\tstruct gameport *gameport, *child = NULL;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&gameport_event_lock, flags);\n\n\tlist_for_each_entry(event, &gameport_event_list, node) {\n\t\tif (event->type == GAMEPORT_REGISTER_PORT) {\n\t\t\tgameport = event->object;\n\t\t\tif (gameport->parent == parent) {\n\t\t\t\tchild = gameport;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tspin_unlock_irqrestore(&gameport_event_lock, flags);\n\treturn child;\n}\n\n \n\nstatic ssize_t gameport_description_show(struct device *dev, struct device_attribute *attr, char *buf)\n{\n\tstruct gameport *gameport = to_gameport_port(dev);\n\n\treturn sprintf(buf, \"%s\\n\", gameport->name);\n}\nstatic DEVICE_ATTR(description, S_IRUGO, gameport_description_show, NULL);\n\nstatic ssize_t drvctl_store(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)\n{\n\tstruct gameport *gameport = to_gameport_port(dev);\n\tstruct device_driver *drv;\n\tint error;\n\n\terror = mutex_lock_interruptible(&gameport_mutex);\n\tif (error)\n\t\treturn error;\n\n\tif (!strncmp(buf, \"none\", count)) {\n\t\tgameport_disconnect_port(gameport);\n\t} else if (!strncmp(buf, \"reconnect\", count)) {\n\t\tgameport_reconnect_port(gameport);\n\t} else if (!strncmp(buf, \"rescan\", count)) {\n\t\tgameport_disconnect_port(gameport);\n\t\tgameport_find_driver(gameport);\n\t} else if ((drv = driver_find(buf, &gameport_bus)) != NULL) {\n\t\tgameport_disconnect_port(gameport);\n\t\terror = gameport_bind_driver(gameport, to_gameport_driver(drv));\n\t} else {\n\t\terror = -EINVAL;\n\t}\n\n\tmutex_unlock(&gameport_mutex);\n\n\treturn error ? error : count;\n}\nstatic DEVICE_ATTR_WO(drvctl);\n\nstatic struct attribute *gameport_device_attrs[] = {\n\t&dev_attr_description.attr,\n\t&dev_attr_drvctl.attr,\n\tNULL,\n};\nATTRIBUTE_GROUPS(gameport_device);\n\nstatic void gameport_release_port(struct device *dev)\n{\n\tstruct gameport *gameport = to_gameport_port(dev);\n\n\tkfree(gameport);\n\tmodule_put(THIS_MODULE);\n}\n\nvoid gameport_set_phys(struct gameport *gameport, const char *fmt, ...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tvsnprintf(gameport->phys, sizeof(gameport->phys), fmt, args);\n\tva_end(args);\n}\nEXPORT_SYMBOL(gameport_set_phys);\n\nstatic void gameport_default_trigger(struct gameport *gameport)\n{\n#ifdef CONFIG_HAS_IOPORT\n\toutb(0xff, gameport->io);\n#endif\n}\n\nstatic unsigned char gameport_default_read(struct gameport *gameport)\n{\n#ifdef CONFIG_HAS_IOPORT\n\treturn inb(gameport->io);\n#else\n\treturn 0xff;\n#endif\n}\n\nstatic void gameport_setup_default_handlers(struct gameport *gameport)\n{\n\tif ((!gameport->trigger || !gameport->read) &&\n\t    !IS_ENABLED(CONFIG_HAS_IOPORT))\n\t\tdev_err(&gameport->dev,\n\t\t\t\"I/O port access is required for %s (%s) but is not available\\n\",\n\t\t\tgameport->phys, gameport->name);\n\n\tif (!gameport->trigger)\n\t\tgameport->trigger = gameport_default_trigger;\n\tif (!gameport->read)\n\t\tgameport->read = gameport_default_read;\n}\n\n \nstatic void gameport_init_port(struct gameport *gameport)\n{\n\tstatic atomic_t gameport_no = ATOMIC_INIT(-1);\n\n\t__module_get(THIS_MODULE);\n\n\tmutex_init(&gameport->drv_mutex);\n\tdevice_initialize(&gameport->dev);\n\tdev_set_name(&gameport->dev, \"gameport%lu\",\n\t\t\t(unsigned long)atomic_inc_return(&gameport_no));\n\tgameport->dev.bus = &gameport_bus;\n\tgameport->dev.release = gameport_release_port;\n\tif (gameport->parent)\n\t\tgameport->dev.parent = &gameport->parent->dev;\n\n\tgameport_setup_default_handlers(gameport);\n\tINIT_LIST_HEAD(&gameport->node);\n\tspin_lock_init(&gameport->timer_lock);\n\ttimer_setup(&gameport->poll_timer, gameport_run_poll_handler, 0);\n}\n\n \nstatic void gameport_add_port(struct gameport *gameport)\n{\n\tint error;\n\n\tif (gameport->parent)\n\t\tgameport->parent->child = gameport;\n\n\tgameport->speed = use_ktime ?\n\t\tgameport_measure_speed(gameport) :\n\t\told_gameport_measure_speed(gameport);\n\n\tlist_add_tail(&gameport->node, &gameport_list);\n\n\tif (gameport->io)\n\t\tdev_info(&gameport->dev, \"%s is %s, io %#x, speed %dkHz\\n\",\n\t\t\t gameport->name, gameport->phys, gameport->io, gameport->speed);\n\telse\n\t\tdev_info(&gameport->dev, \"%s is %s, speed %dkHz\\n\",\n\t\t\tgameport->name, gameport->phys, gameport->speed);\n\n\terror = device_add(&gameport->dev);\n\tif (error)\n\t\tdev_err(&gameport->dev,\n\t\t\t\"device_add() failed for %s (%s), error: %d\\n\",\n\t\t\tgameport->phys, gameport->name, error);\n}\n\n \nstatic void gameport_destroy_port(struct gameport *gameport)\n{\n\tstruct gameport *child;\n\n\tchild = gameport_get_pending_child(gameport);\n\tif (child) {\n\t\tgameport_remove_pending_events(child);\n\t\tput_device(&child->dev);\n\t}\n\n\tif (gameport->parent) {\n\t\tgameport->parent->child = NULL;\n\t\tgameport->parent = NULL;\n\t}\n\n\tif (device_is_registered(&gameport->dev))\n\t\tdevice_del(&gameport->dev);\n\n\tlist_del_init(&gameport->node);\n\n\tgameport_remove_pending_events(gameport);\n\tput_device(&gameport->dev);\n}\n\n \nstatic void gameport_reconnect_port(struct gameport *gameport)\n{\n\tdo {\n\t\tif (!gameport->drv || !gameport->drv->reconnect || gameport->drv->reconnect(gameport)) {\n\t\t\tgameport_disconnect_port(gameport);\n\t\t\tgameport_find_driver(gameport);\n\t\t\t \n\t\t\tbreak;\n\t\t}\n\t\tgameport = gameport->child;\n\t} while (gameport);\n}\n\n \nstatic void gameport_disconnect_port(struct gameport *gameport)\n{\n\tstruct gameport *s, *parent;\n\n\tif (gameport->child) {\n\t\t \n\t\tfor (s = gameport; s->child; s = s->child)\n\t\t\t ;\n\n\t\tdo {\n\t\t\tparent = s->parent;\n\n\t\t\tdevice_release_driver(&s->dev);\n\t\t\tgameport_destroy_port(s);\n\t\t} while ((s = parent) != gameport);\n\t}\n\n\t \n\tdevice_release_driver(&gameport->dev);\n}\n\n \nvoid __gameport_register_port(struct gameport *gameport, struct module *owner)\n{\n\tgameport_init_port(gameport);\n\tgameport_queue_event(gameport, owner, GAMEPORT_REGISTER_PORT);\n}\nEXPORT_SYMBOL(__gameport_register_port);\n\n \nvoid gameport_unregister_port(struct gameport *gameport)\n{\n\tmutex_lock(&gameport_mutex);\n\tgameport_disconnect_port(gameport);\n\tgameport_destroy_port(gameport);\n\tmutex_unlock(&gameport_mutex);\n}\nEXPORT_SYMBOL(gameport_unregister_port);\n\n\n \n\nstatic ssize_t description_show(struct device_driver *drv, char *buf)\n{\n\tstruct gameport_driver *driver = to_gameport_driver(drv);\n\treturn sprintf(buf, \"%s\\n\", driver->description ? driver->description : \"(none)\");\n}\nstatic DRIVER_ATTR_RO(description);\n\nstatic struct attribute *gameport_driver_attrs[] = {\n\t&driver_attr_description.attr,\n\tNULL\n};\nATTRIBUTE_GROUPS(gameport_driver);\n\nstatic int gameport_driver_probe(struct device *dev)\n{\n\tstruct gameport *gameport = to_gameport_port(dev);\n\tstruct gameport_driver *drv = to_gameport_driver(dev->driver);\n\n\tdrv->connect(gameport, drv);\n\treturn gameport->drv ? 0 : -ENODEV;\n}\n\nstatic void gameport_driver_remove(struct device *dev)\n{\n\tstruct gameport *gameport = to_gameport_port(dev);\n\tstruct gameport_driver *drv = to_gameport_driver(dev->driver);\n\n\tdrv->disconnect(gameport);\n}\n\nstatic void gameport_attach_driver(struct gameport_driver *drv)\n{\n\tint error;\n\n\terror = driver_attach(&drv->driver);\n\tif (error)\n\t\tpr_err(\"driver_attach() failed for %s, error: %d\\n\",\n\t\t\tdrv->driver.name, error);\n}\n\nint __gameport_register_driver(struct gameport_driver *drv, struct module *owner,\n\t\t\t\tconst char *mod_name)\n{\n\tint error;\n\n\tdrv->driver.bus = &gameport_bus;\n\tdrv->driver.owner = owner;\n\tdrv->driver.mod_name = mod_name;\n\n\t \n\tdrv->ignore = true;\n\n\terror = driver_register(&drv->driver);\n\tif (error) {\n\t\tpr_err(\"driver_register() failed for %s, error: %d\\n\",\n\t\t\tdrv->driver.name, error);\n\t\treturn error;\n\t}\n\n\t \n\tdrv->ignore = false;\n\terror = gameport_queue_event(drv, NULL, GAMEPORT_ATTACH_DRIVER);\n\tif (error) {\n\t\tdriver_unregister(&drv->driver);\n\t\treturn error;\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL(__gameport_register_driver);\n\nvoid gameport_unregister_driver(struct gameport_driver *drv)\n{\n\tstruct gameport *gameport;\n\n\tmutex_lock(&gameport_mutex);\n\n\tdrv->ignore = true;\t \n\tgameport_remove_pending_events(drv);\n\nstart_over:\n\tlist_for_each_entry(gameport, &gameport_list, node) {\n\t\tif (gameport->drv == drv) {\n\t\t\tgameport_disconnect_port(gameport);\n\t\t\tgameport_find_driver(gameport);\n\t\t\t \n\t\t\tgoto start_over;\n\t\t}\n\t}\n\n\tdriver_unregister(&drv->driver);\n\n\tmutex_unlock(&gameport_mutex);\n}\nEXPORT_SYMBOL(gameport_unregister_driver);\n\nstatic int gameport_bus_match(struct device *dev, struct device_driver *drv)\n{\n\tstruct gameport_driver *gameport_drv = to_gameport_driver(drv);\n\n\treturn !gameport_drv->ignore;\n}\n\nstatic struct bus_type gameport_bus = {\n\t.name\t\t= \"gameport\",\n\t.dev_groups\t= gameport_device_groups,\n\t.drv_groups\t= gameport_driver_groups,\n\t.match\t\t= gameport_bus_match,\n\t.probe\t\t= gameport_driver_probe,\n\t.remove\t\t= gameport_driver_remove,\n};\n\nstatic void gameport_set_drv(struct gameport *gameport, struct gameport_driver *drv)\n{\n\tmutex_lock(&gameport->drv_mutex);\n\tgameport->drv = drv;\n\tmutex_unlock(&gameport->drv_mutex);\n}\n\nint gameport_open(struct gameport *gameport, struct gameport_driver *drv, int mode)\n{\n\tif (gameport->open) {\n\t\tif (gameport->open(gameport, mode)) {\n\t\t\treturn -1;\n\t\t}\n\t} else {\n\t\tif (mode != GAMEPORT_MODE_RAW)\n\t\t\treturn -1;\n\t}\n\n\tgameport_set_drv(gameport, drv);\n\treturn 0;\n}\nEXPORT_SYMBOL(gameport_open);\n\nvoid gameport_close(struct gameport *gameport)\n{\n\tdel_timer_sync(&gameport->poll_timer);\n\tgameport->poll_handler = NULL;\n\tgameport->poll_interval = 0;\n\tgameport_set_drv(gameport, NULL);\n\tif (gameport->close)\n\t\tgameport->close(gameport);\n}\nEXPORT_SYMBOL(gameport_close);\n\nstatic int __init gameport_init(void)\n{\n\tint error;\n\n\terror = bus_register(&gameport_bus);\n\tif (error) {\n\t\tpr_err(\"failed to register gameport bus, error: %d\\n\", error);\n\t\treturn error;\n\t}\n\n\n\treturn 0;\n}\n\nstatic void __exit gameport_exit(void)\n{\n\tbus_unregister(&gameport_bus);\n\n\t \n\tcancel_work_sync(&gameport_event_work);\n}\n\nsubsys_initcall(gameport_init);\nmodule_exit(gameport_exit);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}