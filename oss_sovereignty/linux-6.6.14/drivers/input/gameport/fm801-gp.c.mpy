{
  "module_name": "fm801-gp.c",
  "hash_id": "b7d91ba9887b969e60590122bc062b0346f09e9dfb0ce148497020ac67e12f66",
  "original_prompt": "Ingested from linux-6.6.14/drivers/input/gameport/fm801-gp.c",
  "human_readable_source": "\n \n\n#include <asm/io.h>\n#include <linux/delay.h>\n#include <linux/errno.h>\n#include <linux/ioport.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/pci.h>\n#include <linux/slab.h>\n#include <linux/gameport.h>\n\n#define PCI_VENDOR_ID_FORTEMEDIA\t0x1319\n#define PCI_DEVICE_ID_FM801_GP\t0x0802\n\n#define HAVE_COOKED\n\nstruct fm801_gp {\n\tstruct gameport *gameport;\n\tstruct resource *res_port;\n};\n\n#ifdef HAVE_COOKED\nstatic int fm801_gp_cooked_read(struct gameport *gameport, int *axes, int *buttons)\n{\n\tunsigned short w;\n\n\tw = inw(gameport->io + 2);\n\t*buttons = (~w >> 14) & 0x03;\n\taxes[0] = (w == 0xffff) ? -1 : ((w & 0x1fff) << 5);\n\tw = inw(gameport->io + 4);\n\taxes[1] = (w == 0xffff) ? -1 : ((w & 0x1fff) << 5);\n\tw = inw(gameport->io + 6);\n\t*buttons |= ((~w >> 14) & 0x03) << 2;\n\taxes[2] = (w == 0xffff) ? -1 : ((w & 0x1fff) << 5);\n\tw = inw(gameport->io + 8);\n\taxes[3] = (w == 0xffff) ? -1 : ((w & 0x1fff) << 5);\n\toutw(0xff, gameport->io);  \n\n        return 0;\n}\n#endif\n\nstatic int fm801_gp_open(struct gameport *gameport, int mode)\n{\n\tswitch (mode) {\n#ifdef HAVE_COOKED\n\tcase GAMEPORT_MODE_COOKED:\n\t\treturn 0;\n#endif\n\tcase GAMEPORT_MODE_RAW:\n\t\treturn 0;\n\tdefault:\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}\n\nstatic int fm801_gp_probe(struct pci_dev *pci, const struct pci_device_id *id)\n{\n\tstruct fm801_gp *gp;\n\tstruct gameport *port;\n\tint error;\n\n\tgp = kzalloc(sizeof(struct fm801_gp), GFP_KERNEL);\n\tport = gameport_allocate_port();\n\tif (!gp || !port) {\n\t\tprintk(KERN_ERR \"fm801-gp: Memory allocation failed\\n\");\n\t\terror = -ENOMEM;\n\t\tgoto err_out_free;\n\t}\n\n\terror = pci_enable_device(pci);\n\tif (error)\n\t\tgoto err_out_free;\n\n\tport->open = fm801_gp_open;\n#ifdef HAVE_COOKED\n\tport->cooked_read = fm801_gp_cooked_read;\n#endif\n\tgameport_set_name(port, \"FM801\");\n\tgameport_set_phys(port, \"pci%s/gameport0\", pci_name(pci));\n\tport->dev.parent = &pci->dev;\n\tport->io = pci_resource_start(pci, 0);\n\n\tgp->gameport = port;\n\tgp->res_port = request_region(port->io, 0x10, \"FM801 GP\");\n\tif (!gp->res_port) {\n\t\tprintk(KERN_DEBUG \"fm801-gp: unable to grab region 0x%x-0x%x\\n\",\n\t\t\tport->io, port->io + 0x0f);\n\t\terror = -EBUSY;\n\t\tgoto err_out_disable_dev;\n\t}\n\n\tpci_set_drvdata(pci, gp);\n\n\toutb(0x60, port->io + 0x0d);  \n\tgameport_register_port(port);\n\n\treturn 0;\n\n err_out_disable_dev:\n\tpci_disable_device(pci);\n err_out_free:\n\tgameport_free_port(port);\n\tkfree(gp);\n\treturn error;\n}\n\nstatic void fm801_gp_remove(struct pci_dev *pci)\n{\n\tstruct fm801_gp *gp = pci_get_drvdata(pci);\n\n\tgameport_unregister_port(gp->gameport);\n\trelease_resource(gp->res_port);\n\tkfree(gp);\n\n\tpci_disable_device(pci);\n}\n\nstatic const struct pci_device_id fm801_gp_id_table[] = {\n\t{ PCI_VENDOR_ID_FORTEMEDIA, PCI_DEVICE_ID_FM801_GP, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0  },\n\t{ 0 }\n};\nMODULE_DEVICE_TABLE(pci, fm801_gp_id_table);\n\nstatic struct pci_driver fm801_gp_driver = {\n\t.name =\t\t\"FM801_gameport\",\n\t.id_table =\tfm801_gp_id_table,\n\t.probe =\tfm801_gp_probe,\n\t.remove =\tfm801_gp_remove,\n};\n\nmodule_pci_driver(fm801_gp_driver);\n\nMODULE_DESCRIPTION(\"FM801 gameport driver\");\nMODULE_AUTHOR(\"Takashi Iwai <tiwai@suse.de>\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}