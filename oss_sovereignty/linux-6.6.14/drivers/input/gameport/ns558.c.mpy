{
  "module_name": "ns558.c",
  "hash_id": "2d9f4a6ed1b468a3a9dc571cbfb2046837c1f6c5a8203dfcccad3e67608c232f",
  "original_prompt": "Ingested from linux-6.6.14/drivers/input/gameport/ns558.c",
  "human_readable_source": "\n \n\n \n\n#include <asm/io.h>\n\n#include <linux/module.h>\n#include <linux/ioport.h>\n#include <linux/init.h>\n#include <linux/delay.h>\n#include <linux/gameport.h>\n#include <linux/slab.h>\n#include <linux/pnp.h>\n\nMODULE_AUTHOR(\"Vojtech Pavlik <vojtech@ucw.cz>\");\nMODULE_DESCRIPTION(\"Classic gameport (ISA/PnP) driver\");\nMODULE_LICENSE(\"GPL\");\n\nstatic int ns558_isa_portlist[] = { 0x201, 0x200, 0x202, 0x203, 0x204, 0x205, 0x207, 0x209,\n\t\t\t\t    0x20b, 0x20c, 0x20e, 0x20f, 0x211, 0x219, 0x101, 0 };\n\nstruct ns558 {\n\tint type;\n\tint io;\n\tint size;\n\tstruct pnp_dev *dev;\n\tstruct gameport *gameport;\n\tstruct list_head node;\n};\n\nstatic LIST_HEAD(ns558_list);\n\n \n\nstatic int ns558_isa_probe(int io)\n{\n\tint i, j, b;\n\tunsigned char c, u, v;\n\tstruct ns558 *ns558;\n\tstruct gameport *port;\n\n \n\n\tif (!request_region(io, 1, \"ns558-isa\"))\n\t\treturn -EBUSY;\n\n \n\n\tc = inb(io);\n\toutb(~c & ~3, io);\n\tif (~(u = v = inb(io)) & 3) {\n\t\toutb(c, io);\n\t\trelease_region(io, 1);\n\t\treturn -ENODEV;\n\t}\n \n\n\tfor (i = 0; i < 1000; i++) v &= inb(io);\n\n\tif (u == v) {\n\t\toutb(c, io);\n\t\trelease_region(io, 1);\n\t\treturn -ENODEV;\n\t}\n\tmsleep(3);\n \n\n\tu = inb(io);\n\tfor (i = 0; i < 1000; i++)\n\t\tif ((u ^ inb(io)) & 0xf) {\n\t\t\toutb(c, io);\n\t\t\trelease_region(io, 1);\n\t\t\treturn -ENODEV;\n\t\t}\n \n\n\tfor (i = 1; i < 5; i++) {\n\n\t\trelease_region(io & (-1 << (i - 1)), (1 << (i - 1)));\n\n\t\tif (!request_region(io & (-1 << i), (1 << i), \"ns558-isa\"))\n\t\t\tbreak;\t\t\t\t \n\n\t\toutb(0xff, io & (-1 << i));\n\t\tfor (j = b = 0; j < 1000; j++)\n\t\t\tif (inb(io & (-1 << i)) != inb((io & (-1 << i)) + (1 << i) - 1)) b++;\n\t\tmsleep(3);\n\n\t\tif (b > 300) {\t\t\t\t \n\t\t\trelease_region(io & (-1 << i), (1 << i));\n\t\t\tbreak;\n\t\t}\n\t}\n\n\ti--;\n\n\tif (i != 4) {\n\t\tif (!request_region(io & (-1 << i), (1 << i), \"ns558-isa\"))\n\t\t\treturn -EBUSY;\n\t}\n\n\tns558 = kzalloc(sizeof(struct ns558), GFP_KERNEL);\n\tport = gameport_allocate_port();\n\tif (!ns558 || !port) {\n\t\tprintk(KERN_ERR \"ns558: Memory allocation failed.\\n\");\n\t\trelease_region(io & (-1 << i), (1 << i));\n\t\tkfree(ns558);\n\t\tgameport_free_port(port);\n\t\treturn -ENOMEM;\n\t}\n\n\tns558->io = io;\n\tns558->size = 1 << i;\n\tns558->gameport = port;\n\n\tport->io = io;\n\tgameport_set_name(port, \"NS558 ISA Gameport\");\n\tgameport_set_phys(port, \"isa%04x/gameport0\", io & (-1 << i));\n\n\tgameport_register_port(port);\n\n\tlist_add(&ns558->node, &ns558_list);\n\n\treturn 0;\n}\n\n#ifdef CONFIG_PNP\n\nstatic const struct pnp_device_id pnp_devids[] = {\n\t{ .id = \"@P@0001\", .driver_data = 0 },  \n\t{ .id = \"@P@0020\", .driver_data = 0 },  \n\t{ .id = \"@P@1001\", .driver_data = 0 },  \n\t{ .id = \"@P@2001\", .driver_data = 0 },  \n\t{ .id = \"ASB16fd\", .driver_data = 0 },  \n\t{ .id = \"AZT3001\", .driver_data = 0 },  \n\t{ .id = \"CDC0001\", .driver_data = 0 },  \n\t{ .id = \"CSC0001\", .driver_data = 0 },  \n\t{ .id = \"CSC000f\", .driver_data = 0 },  \n\t{ .id = \"CSC0101\", .driver_data = 0 },  \n\t{ .id = \"CTL7001\", .driver_data = 0 },  \n\t{ .id = \"CTL7002\", .driver_data = 0 },  \n\t{ .id = \"CTL7005\", .driver_data = 0 },  \n\t{ .id = \"ENS2020\", .driver_data = 0 },  \n\t{ .id = \"ESS0001\", .driver_data = 0 },  \n\t{ .id = \"ESS0005\", .driver_data = 0 },  \n\t{ .id = \"ESS6880\", .driver_data = 0 },  \n\t{ .id = \"IBM0012\", .driver_data = 0 },  \n\t{ .id = \"OPT0001\", .driver_data = 0 },  \n\t{ .id = \"YMH0006\", .driver_data = 0 },  \n\t{ .id = \"YMH0022\", .driver_data = 0 },  \n\t{ .id = \"PNPb02f\", .driver_data = 0 },  \n\t{ .id = \"\", },\n};\n\nMODULE_DEVICE_TABLE(pnp, pnp_devids);\n\nstatic int ns558_pnp_probe(struct pnp_dev *dev, const struct pnp_device_id *did)\n{\n\tint ioport, iolen;\n\tstruct ns558 *ns558;\n\tstruct gameport *port;\n\n\tif (!pnp_port_valid(dev, 0)) {\n\t\tprintk(KERN_WARNING \"ns558: No i/o ports on a gameport? Weird\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tioport = pnp_port_start(dev, 0);\n\tiolen = pnp_port_len(dev, 0);\n\n\tif (!request_region(ioport, iolen, \"ns558-pnp\"))\n\t\treturn -EBUSY;\n\n\tns558 = kzalloc(sizeof(struct ns558), GFP_KERNEL);\n\tport = gameport_allocate_port();\n\tif (!ns558 || !port) {\n\t\tprintk(KERN_ERR \"ns558: Memory allocation failed\\n\");\n\t\tkfree(ns558);\n\t\tgameport_free_port(port);\n\t\treturn -ENOMEM;\n\t}\n\n\tns558->io = ioport;\n\tns558->size = iolen;\n\tns558->dev = dev;\n\tns558->gameport = port;\n\n\tgameport_set_name(port, \"NS558 PnP Gameport\");\n\tgameport_set_phys(port, \"pnp%s/gameport0\", dev_name(&dev->dev));\n\tport->dev.parent = &dev->dev;\n\tport->io = ioport;\n\n\tgameport_register_port(port);\n\n\tlist_add_tail(&ns558->node, &ns558_list);\n\treturn 0;\n}\n\nstatic struct pnp_driver ns558_pnp_driver = {\n\t.name\t\t= \"ns558\",\n\t.id_table\t= pnp_devids,\n\t.probe\t\t= ns558_pnp_probe,\n};\n\n#else\n\nstatic struct pnp_driver ns558_pnp_driver;\n\n#endif\n\nstatic int __init ns558_init(void)\n{\n\tint i = 0;\n\tint error;\n\n\terror = pnp_register_driver(&ns558_pnp_driver);\n\tif (error && error != -ENODEV)\t \n\t\treturn error;\n\n \n\n\twhile (ns558_isa_portlist[i])\n\t\tns558_isa_probe(ns558_isa_portlist[i++]);\n\n\treturn list_empty(&ns558_list) && error ? -ENODEV : 0;\n}\n\nstatic void __exit ns558_exit(void)\n{\n\tstruct ns558 *ns558, *safe;\n\n\tlist_for_each_entry_safe(ns558, safe, &ns558_list, node) {\n\t\tgameport_unregister_port(ns558->gameport);\n\t\trelease_region(ns558->io & ~(ns558->size - 1), ns558->size);\n\t\tkfree(ns558);\n\t}\n\n\tpnp_unregister_driver(&ns558_pnp_driver);\n}\n\nmodule_init(ns558_init);\nmodule_exit(ns558_exit);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}