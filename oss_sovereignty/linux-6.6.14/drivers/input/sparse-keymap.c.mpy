{
  "module_name": "sparse-keymap.c",
  "hash_id": "e4ceea6161df8f8a560b0e6e43f14b924f2b2c453fddd4fa8407f7fdcc56fe21",
  "original_prompt": "Ingested from linux-6.6.14/drivers/input/sparse-keymap.c",
  "human_readable_source": "\n \n\n#include <linux/input.h>\n#include <linux/input/sparse-keymap.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n\nMODULE_AUTHOR(\"Dmitry Torokhov <dtor@mail.ru>\");\nMODULE_DESCRIPTION(\"Generic support for sparse keymaps\");\nMODULE_LICENSE(\"GPL v2\");\n\nstatic unsigned int sparse_keymap_get_key_index(struct input_dev *dev,\n\t\t\t\t\t\tconst struct key_entry *k)\n{\n\tstruct key_entry *key;\n\tunsigned int idx = 0;\n\n\tfor (key = dev->keycode; key->type != KE_END; key++) {\n\t\tif (key->type == KE_KEY) {\n\t\t\tif (key == k)\n\t\t\t\tbreak;\n\t\t\tidx++;\n\t\t}\n\t}\n\n\treturn idx;\n}\n\nstatic struct key_entry *sparse_keymap_entry_by_index(struct input_dev *dev,\n\t\t\t\t\t\t      unsigned int index)\n{\n\tstruct key_entry *key;\n\tunsigned int key_cnt = 0;\n\n\tfor (key = dev->keycode; key->type != KE_END; key++)\n\t\tif (key->type == KE_KEY)\n\t\t\tif (key_cnt++ == index)\n\t\t\t\treturn key;\n\n\treturn NULL;\n}\n\n \nstruct key_entry *sparse_keymap_entry_from_scancode(struct input_dev *dev,\n\t\t\t\t\t\t    unsigned int code)\n{\n\tstruct key_entry *key;\n\n\tfor (key = dev->keycode; key->type != KE_END; key++)\n\t\tif (code == key->code)\n\t\t\treturn key;\n\n\treturn NULL;\n}\nEXPORT_SYMBOL(sparse_keymap_entry_from_scancode);\n\n \nstruct key_entry *sparse_keymap_entry_from_keycode(struct input_dev *dev,\n\t\t\t\t\t\t   unsigned int keycode)\n{\n\tstruct key_entry *key;\n\n\tfor (key = dev->keycode; key->type != KE_END; key++)\n\t\tif (key->type == KE_KEY && keycode == key->keycode)\n\t\t\treturn key;\n\n\treturn NULL;\n}\nEXPORT_SYMBOL(sparse_keymap_entry_from_keycode);\n\nstatic struct key_entry *sparse_keymap_locate(struct input_dev *dev,\n\t\t\t\t\tconst struct input_keymap_entry *ke)\n{\n\tstruct key_entry *key;\n\tunsigned int scancode;\n\n\tif (ke->flags & INPUT_KEYMAP_BY_INDEX)\n\t\tkey = sparse_keymap_entry_by_index(dev, ke->index);\n\telse if (input_scancode_to_scalar(ke, &scancode) == 0)\n\t\tkey = sparse_keymap_entry_from_scancode(dev, scancode);\n\telse\n\t\tkey = NULL;\n\n\treturn key;\n}\n\nstatic int sparse_keymap_getkeycode(struct input_dev *dev,\n\t\t\t\t    struct input_keymap_entry *ke)\n{\n\tconst struct key_entry *key;\n\n\tif (dev->keycode) {\n\t\tkey = sparse_keymap_locate(dev, ke);\n\t\tif (key && key->type == KE_KEY) {\n\t\t\tke->keycode = key->keycode;\n\t\t\tif (!(ke->flags & INPUT_KEYMAP_BY_INDEX))\n\t\t\t\tke->index =\n\t\t\t\t\tsparse_keymap_get_key_index(dev, key);\n\t\t\tke->len = sizeof(key->code);\n\t\t\tmemcpy(ke->scancode, &key->code, sizeof(key->code));\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\treturn -EINVAL;\n}\n\nstatic int sparse_keymap_setkeycode(struct input_dev *dev,\n\t\t\t\t    const struct input_keymap_entry *ke,\n\t\t\t\t    unsigned int *old_keycode)\n{\n\tstruct key_entry *key;\n\n\tif (dev->keycode) {\n\t\tkey = sparse_keymap_locate(dev, ke);\n\t\tif (key && key->type == KE_KEY) {\n\t\t\t*old_keycode = key->keycode;\n\t\t\tkey->keycode = ke->keycode;\n\t\t\tset_bit(ke->keycode, dev->keybit);\n\t\t\tif (!sparse_keymap_entry_from_keycode(dev, *old_keycode))\n\t\t\t\tclear_bit(*old_keycode, dev->keybit);\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\treturn -EINVAL;\n}\n\n \nint sparse_keymap_setup(struct input_dev *dev,\n\t\t\tconst struct key_entry *keymap,\n\t\t\tint (*setup)(struct input_dev *, struct key_entry *))\n{\n\tsize_t map_size = 1;  \n\tconst struct key_entry *e;\n\tstruct key_entry *map, *entry;\n\tint i;\n\tint error;\n\n\tfor (e = keymap; e->type != KE_END; e++)\n\t\tmap_size++;\n\n\tmap = devm_kmemdup(&dev->dev, keymap, map_size * sizeof(*map),\n\t\t\t   GFP_KERNEL);\n\tif (!map)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < map_size; i++) {\n\t\tentry = &map[i];\n\n\t\tif (setup) {\n\t\t\terror = setup(dev, entry);\n\t\t\tif (error)\n\t\t\t\treturn error;\n\t\t}\n\n\t\tswitch (entry->type) {\n\t\tcase KE_KEY:\n\t\t\t__set_bit(EV_KEY, dev->evbit);\n\t\t\t__set_bit(entry->keycode, dev->keybit);\n\t\t\tbreak;\n\n\t\tcase KE_SW:\n\t\tcase KE_VSW:\n\t\t\t__set_bit(EV_SW, dev->evbit);\n\t\t\t__set_bit(entry->sw.code, dev->swbit);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (test_bit(EV_KEY, dev->evbit)) {\n\t\t__set_bit(KEY_UNKNOWN, dev->keybit);\n\t\t__set_bit(EV_MSC, dev->evbit);\n\t\t__set_bit(MSC_SCAN, dev->mscbit);\n\t}\n\n\tdev->keycode = map;\n\tdev->keycodemax = map_size;\n\tdev->getkeycode = sparse_keymap_getkeycode;\n\tdev->setkeycode = sparse_keymap_setkeycode;\n\n\treturn 0;\n}\nEXPORT_SYMBOL(sparse_keymap_setup);\n\n \nvoid sparse_keymap_report_entry(struct input_dev *dev, const struct key_entry *ke,\n\t\t\t\tunsigned int value, bool autorelease)\n{\n\tswitch (ke->type) {\n\tcase KE_KEY:\n\t\tinput_event(dev, EV_MSC, MSC_SCAN, ke->code);\n\t\tinput_report_key(dev, ke->keycode, value);\n\t\tinput_sync(dev);\n\t\tif (value && autorelease) {\n\t\t\tinput_report_key(dev, ke->keycode, 0);\n\t\t\tinput_sync(dev);\n\t\t}\n\t\tbreak;\n\n\tcase KE_SW:\n\t\tvalue = ke->sw.value;\n\t\tfallthrough;\n\n\tcase KE_VSW:\n\t\tinput_report_switch(dev, ke->sw.code, value);\n\t\tinput_sync(dev);\n\t\tbreak;\n\t}\n}\nEXPORT_SYMBOL(sparse_keymap_report_entry);\n\n \nbool sparse_keymap_report_event(struct input_dev *dev, unsigned int code,\n\t\t\t\tunsigned int value, bool autorelease)\n{\n\tconst struct key_entry *ke =\n\t\tsparse_keymap_entry_from_scancode(dev, code);\n\tstruct key_entry unknown_ke;\n\n\tif (ke) {\n\t\tsparse_keymap_report_entry(dev, ke, value, autorelease);\n\t\treturn true;\n\t}\n\n\t \n\tunknown_ke.type = KE_KEY;\n\tunknown_ke.code = code;\n\tunknown_ke.keycode = KEY_UNKNOWN;\n\tsparse_keymap_report_entry(dev, &unknown_ke, value, true);\n\n\treturn false;\n}\nEXPORT_SYMBOL(sparse_keymap_report_event);\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}