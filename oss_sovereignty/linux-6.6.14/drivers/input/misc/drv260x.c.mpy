{
  "module_name": "drv260x.c",
  "hash_id": "a9eb19f2cc24dffea3b1447dc24a9f868117a82675e3dd9d176d07faf6dae2dd",
  "original_prompt": "Ingested from linux-6.6.14/drivers/input/misc/drv260x.c",
  "human_readable_source": "\n \n\n#include <linux/i2c.h>\n#include <linux/input.h>\n#include <linux/module.h>\n#include <linux/regmap.h>\n#include <linux/slab.h>\n#include <linux/delay.h>\n#include <linux/gpio/consumer.h>\n#include <linux/regulator/consumer.h>\n\n#include <dt-bindings/input/ti-drv260x.h>\n\n#define DRV260X_STATUS\t\t0x0\n#define DRV260X_MODE\t\t0x1\n#define DRV260X_RT_PB_IN\t0x2\n#define DRV260X_LIB_SEL\t\t0x3\n#define DRV260X_WV_SEQ_1\t0x4\n#define DRV260X_WV_SEQ_2\t0x5\n#define DRV260X_WV_SEQ_3\t0x6\n#define DRV260X_WV_SEQ_4\t0x7\n#define DRV260X_WV_SEQ_5\t0x8\n#define DRV260X_WV_SEQ_6\t0x9\n#define DRV260X_WV_SEQ_7\t0xa\n#define DRV260X_WV_SEQ_8\t0xb\n#define DRV260X_GO\t\t\t\t0xc\n#define DRV260X_OVERDRIVE_OFF\t0xd\n#define DRV260X_SUSTAIN_P_OFF\t0xe\n#define DRV260X_SUSTAIN_N_OFF\t0xf\n#define DRV260X_BRAKE_OFF\t\t0x10\n#define DRV260X_A_TO_V_CTRL\t\t0x11\n#define DRV260X_A_TO_V_MIN_INPUT\t0x12\n#define DRV260X_A_TO_V_MAX_INPUT\t0x13\n#define DRV260X_A_TO_V_MIN_OUT\t0x14\n#define DRV260X_A_TO_V_MAX_OUT\t0x15\n#define DRV260X_RATED_VOLT\t\t0x16\n#define DRV260X_OD_CLAMP_VOLT\t0x17\n#define DRV260X_CAL_COMP\t\t0x18\n#define DRV260X_CAL_BACK_EMF\t0x19\n#define DRV260X_FEEDBACK_CTRL\t0x1a\n#define DRV260X_CTRL1\t\t\t0x1b\n#define DRV260X_CTRL2\t\t\t0x1c\n#define DRV260X_CTRL3\t\t\t0x1d\n#define DRV260X_CTRL4\t\t\t0x1e\n#define DRV260X_CTRL5\t\t\t0x1f\n#define DRV260X_LRA_LOOP_PERIOD\t0x20\n#define DRV260X_VBAT_MON\t\t0x21\n#define DRV260X_LRA_RES_PERIOD\t0x22\n#define DRV260X_MAX_REG\t\t\t0x23\n\n#define DRV260X_GO_BIT\t\t\t\t0x01\n\n \n#define DRV260X_LIB_SEL_MASK\t\t0x07\n#define DRV260X_LIB_SEL_RAM\t\t\t0x0\n#define DRV260X_LIB_SEL_OD\t\t\t0x1\n#define DRV260X_LIB_SEL_40_60\t\t0x2\n#define DRV260X_LIB_SEL_60_80\t\t0x3\n#define DRV260X_LIB_SEL_100_140\t\t0x4\n#define DRV260X_LIB_SEL_140_PLUS\t0x5\n\n#define DRV260X_LIB_SEL_HIZ_MASK\t0x10\n#define DRV260X_LIB_SEL_HIZ_EN\t\t0x01\n#define DRV260X_LIB_SEL_HIZ_DIS\t\t0\n\n \n#define DRV260X_STANDBY\t\t\t\t(1 << 6)\n#define DRV260X_STANDBY_MASK\t\t0x40\n#define DRV260X_INTERNAL_TRIGGER\t0x00\n#define DRV260X_EXT_TRIGGER_EDGE\t0x01\n#define DRV260X_EXT_TRIGGER_LEVEL\t0x02\n#define DRV260X_PWM_ANALOG_IN\t\t0x03\n#define DRV260X_AUDIOHAPTIC\t\t\t0x04\n#define DRV260X_RT_PLAYBACK\t\t\t0x05\n#define DRV260X_DIAGNOSTICS\t\t\t0x06\n#define DRV260X_AUTO_CAL\t\t\t0x07\n\n \n#define DRV260X_AUDIO_HAPTICS_PEAK_10MS\t\t(0 << 2)\n#define DRV260X_AUDIO_HAPTICS_PEAK_20MS\t\t(1 << 2)\n#define DRV260X_AUDIO_HAPTICS_PEAK_30MS\t\t(2 << 2)\n#define DRV260X_AUDIO_HAPTICS_PEAK_40MS\t\t(3 << 2)\n\n#define DRV260X_AUDIO_HAPTICS_FILTER_100HZ\t0x00\n#define DRV260X_AUDIO_HAPTICS_FILTER_125HZ\t0x01\n#define DRV260X_AUDIO_HAPTICS_FILTER_150HZ\t0x02\n#define DRV260X_AUDIO_HAPTICS_FILTER_200HZ\t0x03\n\n \n#define DRV260X_AUDIO_HAPTICS_MIN_IN_VOLT\t0x19\n#define DRV260X_AUDIO_HAPTICS_MAX_IN_VOLT\t0x64\n#define DRV260X_AUDIO_HAPTICS_MIN_OUT_VOLT\t0x19\n#define DRV260X_AUDIO_HAPTICS_MAX_OUT_VOLT\t0xFF\n\n \n#define DRV260X_FB_REG_ERM_MODE\t\t\t0x7f\n#define DRV260X_FB_REG_LRA_MODE\t\t\t(1 << 7)\n\n#define DRV260X_BRAKE_FACTOR_MASK\t0x1f\n#define DRV260X_BRAKE_FACTOR_2X\t\t(1 << 0)\n#define DRV260X_BRAKE_FACTOR_3X\t\t(2 << 4)\n#define DRV260X_BRAKE_FACTOR_4X\t\t(3 << 4)\n#define DRV260X_BRAKE_FACTOR_6X\t\t(4 << 4)\n#define DRV260X_BRAKE_FACTOR_8X\t\t(5 << 4)\n#define DRV260X_BRAKE_FACTOR_16\t\t(6 << 4)\n#define DRV260X_BRAKE_FACTOR_DIS\t(7 << 4)\n\n#define DRV260X_LOOP_GAIN_LOW\t\t0xf3\n#define DRV260X_LOOP_GAIN_MED\t\t(1 << 2)\n#define DRV260X_LOOP_GAIN_HIGH\t\t(2 << 2)\n#define DRV260X_LOOP_GAIN_VERY_HIGH\t(3 << 2)\n\n#define DRV260X_BEMF_GAIN_0\t\t\t0xfc\n#define DRV260X_BEMF_GAIN_1\t\t(1 << 0)\n#define DRV260X_BEMF_GAIN_2\t\t(2 << 0)\n#define DRV260X_BEMF_GAIN_3\t\t(3 << 0)\n\n \n#define DRV260X_AC_CPLE_EN\t\t\t(1 << 5)\n#define DRV260X_STARTUP_BOOST\t\t(1 << 7)\n\n \n\n#define DRV260X_IDISS_TIME_45\t\t0\n#define DRV260X_IDISS_TIME_75\t\t(1 << 0)\n#define DRV260X_IDISS_TIME_150\t\t(1 << 1)\n#define DRV260X_IDISS_TIME_225\t\t0x03\n\n#define DRV260X_BLANK_TIME_45\t(0 << 2)\n#define DRV260X_BLANK_TIME_75\t(1 << 2)\n#define DRV260X_BLANK_TIME_150\t(2 << 2)\n#define DRV260X_BLANK_TIME_225\t(3 << 2)\n\n#define DRV260X_SAMP_TIME_150\t(0 << 4)\n#define DRV260X_SAMP_TIME_200\t(1 << 4)\n#define DRV260X_SAMP_TIME_250\t(2 << 4)\n#define DRV260X_SAMP_TIME_300\t(3 << 4)\n\n#define DRV260X_BRAKE_STABILIZER\t(1 << 6)\n#define DRV260X_UNIDIR_IN\t\t\t(0 << 7)\n#define DRV260X_BIDIR_IN\t\t\t(1 << 7)\n\n \n#define DRV260X_LRA_OPEN_LOOP\t\t(1 << 0)\n#define DRV260X_ANALOG_IN\t\t\t(1 << 1)\n#define DRV260X_LRA_DRV_MODE\t\t(1 << 2)\n#define DRV260X_RTP_UNSIGNED_DATA\t(1 << 3)\n#define DRV260X_SUPPLY_COMP_DIS\t\t(1 << 4)\n#define DRV260X_ERM_OPEN_LOOP\t\t(1 << 5)\n#define DRV260X_NG_THRESH_0\t\t\t(0 << 6)\n#define DRV260X_NG_THRESH_2\t\t\t(1 << 6)\n#define DRV260X_NG_THRESH_4\t\t\t(2 << 6)\n#define DRV260X_NG_THRESH_8\t\t\t(3 << 6)\n\n \n#define DRV260X_AUTOCAL_TIME_150MS\t\t(0 << 4)\n#define DRV260X_AUTOCAL_TIME_250MS\t\t(1 << 4)\n#define DRV260X_AUTOCAL_TIME_500MS\t\t(2 << 4)\n#define DRV260X_AUTOCAL_TIME_1000MS\t\t(3 << 4)\n\n \nstruct drv260x_data {\n\tstruct input_dev *input_dev;\n\tstruct i2c_client *client;\n\tstruct regmap *regmap;\n\tstruct work_struct work;\n\tstruct gpio_desc *enable_gpio;\n\tstruct regulator *regulator;\n\tu8 magnitude;\n\tu32 mode;\n\tu32 library;\n\tint rated_voltage;\n\tint overdrive_voltage;\n};\n\n#define DRV260X_DEF_RATED_VOLT\t\t0x90\n#define DRV260X_DEF_OD_CLAMP_VOLT\t0x90\n\n \nstatic int drv260x_calculate_voltage(unsigned int voltage)\n{\n\treturn (voltage * 255 / 5600);\n}\n\nstatic void drv260x_worker(struct work_struct *work)\n{\n\tstruct drv260x_data *haptics = container_of(work, struct drv260x_data, work);\n\tint error;\n\n\tgpiod_set_value(haptics->enable_gpio, 1);\n\t \n\tudelay(250);\n\n\terror = regmap_write(haptics->regmap,\n\t\t\t     DRV260X_MODE, DRV260X_RT_PLAYBACK);\n\tif (error) {\n\t\tdev_err(&haptics->client->dev,\n\t\t\t\"Failed to write set mode: %d\\n\", error);\n\t} else {\n\t\terror = regmap_write(haptics->regmap,\n\t\t\t\t     DRV260X_RT_PB_IN, haptics->magnitude);\n\t\tif (error)\n\t\t\tdev_err(&haptics->client->dev,\n\t\t\t\t\"Failed to set magnitude: %d\\n\", error);\n\t}\n}\n\nstatic int drv260x_haptics_play(struct input_dev *input, void *data,\n\t\t\t\tstruct ff_effect *effect)\n{\n\tstruct drv260x_data *haptics = input_get_drvdata(input);\n\n\thaptics->mode = DRV260X_LRA_NO_CAL_MODE;\n\n\t \n\tif (effect->u.rumble.strong_magnitude > 0)\n\t\thaptics->magnitude = effect->u.rumble.strong_magnitude >> 8;\n\telse if (effect->u.rumble.weak_magnitude > 0)\n\t\thaptics->magnitude = effect->u.rumble.weak_magnitude >> 8;\n\telse\n\t\thaptics->magnitude = 0;\n\n\tschedule_work(&haptics->work);\n\n\treturn 0;\n}\n\nstatic void drv260x_close(struct input_dev *input)\n{\n\tstruct drv260x_data *haptics = input_get_drvdata(input);\n\tint error;\n\n\tcancel_work_sync(&haptics->work);\n\n\terror = regmap_write(haptics->regmap, DRV260X_MODE, DRV260X_STANDBY);\n\tif (error)\n\t\tdev_err(&haptics->client->dev,\n\t\t\t\"Failed to enter standby mode: %d\\n\", error);\n\n\tgpiod_set_value(haptics->enable_gpio, 0);\n}\n\nstatic const struct reg_sequence drv260x_lra_cal_regs[] = {\n\t{ DRV260X_MODE, DRV260X_AUTO_CAL },\n\t{ DRV260X_CTRL3, DRV260X_NG_THRESH_2 | DRV260X_RTP_UNSIGNED_DATA },\n\t{ DRV260X_FEEDBACK_CTRL, DRV260X_FB_REG_LRA_MODE |\n\t\tDRV260X_BRAKE_FACTOR_4X | DRV260X_LOOP_GAIN_HIGH },\n};\n\nstatic const struct reg_sequence drv260x_lra_init_regs[] = {\n\t{ DRV260X_MODE, DRV260X_RT_PLAYBACK },\n\t{ DRV260X_A_TO_V_CTRL, DRV260X_AUDIO_HAPTICS_PEAK_20MS |\n\t\tDRV260X_AUDIO_HAPTICS_FILTER_125HZ },\n\t{ DRV260X_A_TO_V_MIN_INPUT, DRV260X_AUDIO_HAPTICS_MIN_IN_VOLT },\n\t{ DRV260X_A_TO_V_MAX_INPUT, DRV260X_AUDIO_HAPTICS_MAX_IN_VOLT },\n\t{ DRV260X_A_TO_V_MIN_OUT, DRV260X_AUDIO_HAPTICS_MIN_OUT_VOLT },\n\t{ DRV260X_A_TO_V_MAX_OUT, DRV260X_AUDIO_HAPTICS_MAX_OUT_VOLT },\n\t{ DRV260X_FEEDBACK_CTRL, DRV260X_FB_REG_LRA_MODE |\n\t\tDRV260X_BRAKE_FACTOR_2X | DRV260X_LOOP_GAIN_MED |\n\t\tDRV260X_BEMF_GAIN_3 },\n\t{ DRV260X_CTRL1, DRV260X_STARTUP_BOOST },\n\t{ DRV260X_CTRL2, DRV260X_SAMP_TIME_250 },\n\t{ DRV260X_CTRL3, DRV260X_NG_THRESH_2 | DRV260X_RTP_UNSIGNED_DATA | DRV260X_ANALOG_IN },\n\t{ DRV260X_CTRL4, DRV260X_AUTOCAL_TIME_500MS },\n};\n\nstatic const struct reg_sequence drv260x_erm_cal_regs[] = {\n\t{ DRV260X_MODE, DRV260X_AUTO_CAL },\n\t{ DRV260X_A_TO_V_MIN_INPUT, DRV260X_AUDIO_HAPTICS_MIN_IN_VOLT },\n\t{ DRV260X_A_TO_V_MAX_INPUT, DRV260X_AUDIO_HAPTICS_MAX_IN_VOLT },\n\t{ DRV260X_A_TO_V_MIN_OUT, DRV260X_AUDIO_HAPTICS_MIN_OUT_VOLT },\n\t{ DRV260X_A_TO_V_MAX_OUT, DRV260X_AUDIO_HAPTICS_MAX_OUT_VOLT },\n\t{ DRV260X_FEEDBACK_CTRL, DRV260X_BRAKE_FACTOR_3X |\n\t\tDRV260X_LOOP_GAIN_MED | DRV260X_BEMF_GAIN_2 },\n\t{ DRV260X_CTRL1, DRV260X_STARTUP_BOOST },\n\t{ DRV260X_CTRL2, DRV260X_SAMP_TIME_250 | DRV260X_BLANK_TIME_75 |\n\t\tDRV260X_IDISS_TIME_75 },\n\t{ DRV260X_CTRL3, DRV260X_NG_THRESH_2 | DRV260X_RTP_UNSIGNED_DATA },\n\t{ DRV260X_CTRL4, DRV260X_AUTOCAL_TIME_500MS },\n};\n\nstatic int drv260x_init(struct drv260x_data *haptics)\n{\n\tint error;\n\tunsigned int cal_buf;\n\n\terror = regmap_write(haptics->regmap,\n\t\t\t     DRV260X_RATED_VOLT, haptics->rated_voltage);\n\tif (error) {\n\t\tdev_err(&haptics->client->dev,\n\t\t\t\"Failed to write DRV260X_RATED_VOLT register: %d\\n\",\n\t\t\terror);\n\t\treturn error;\n\t}\n\n\terror = regmap_write(haptics->regmap,\n\t\t\t     DRV260X_OD_CLAMP_VOLT, haptics->overdrive_voltage);\n\tif (error) {\n\t\tdev_err(&haptics->client->dev,\n\t\t\t\"Failed to write DRV260X_OD_CLAMP_VOLT register: %d\\n\",\n\t\t\terror);\n\t\treturn error;\n\t}\n\n\tswitch (haptics->mode) {\n\tcase DRV260X_LRA_MODE:\n\t\terror = regmap_register_patch(haptics->regmap,\n\t\t\t\t\t      drv260x_lra_cal_regs,\n\t\t\t\t\t      ARRAY_SIZE(drv260x_lra_cal_regs));\n\t\tif (error) {\n\t\t\tdev_err(&haptics->client->dev,\n\t\t\t\t\"Failed to write LRA calibration registers: %d\\n\",\n\t\t\t\terror);\n\t\t\treturn error;\n\t\t}\n\n\t\tbreak;\n\n\tcase DRV260X_ERM_MODE:\n\t\terror = regmap_register_patch(haptics->regmap,\n\t\t\t\t\t      drv260x_erm_cal_regs,\n\t\t\t\t\t      ARRAY_SIZE(drv260x_erm_cal_regs));\n\t\tif (error) {\n\t\t\tdev_err(&haptics->client->dev,\n\t\t\t\t\"Failed to write ERM calibration registers: %d\\n\",\n\t\t\t\terror);\n\t\t\treturn error;\n\t\t}\n\n\t\terror = regmap_update_bits(haptics->regmap, DRV260X_LIB_SEL,\n\t\t\t\t\t   DRV260X_LIB_SEL_MASK,\n\t\t\t\t\t   haptics->library);\n\t\tif (error) {\n\t\t\tdev_err(&haptics->client->dev,\n\t\t\t\t\"Failed to write DRV260X_LIB_SEL register: %d\\n\",\n\t\t\t\terror);\n\t\t\treturn error;\n\t\t}\n\n\t\tbreak;\n\n\tdefault:\n\t\terror = regmap_register_patch(haptics->regmap,\n\t\t\t\t\t      drv260x_lra_init_regs,\n\t\t\t\t\t      ARRAY_SIZE(drv260x_lra_init_regs));\n\t\tif (error) {\n\t\t\tdev_err(&haptics->client->dev,\n\t\t\t\t\"Failed to write LRA init registers: %d\\n\",\n\t\t\t\terror);\n\t\t\treturn error;\n\t\t}\n\n\t\terror = regmap_update_bits(haptics->regmap, DRV260X_LIB_SEL,\n\t\t\t\t\t   DRV260X_LIB_SEL_MASK,\n\t\t\t\t\t   haptics->library);\n\t\tif (error) {\n\t\t\tdev_err(&haptics->client->dev,\n\t\t\t\t\"Failed to write DRV260X_LIB_SEL register: %d\\n\",\n\t\t\t\terror);\n\t\t\treturn error;\n\t\t}\n\n\t\t \n\t\treturn 0;\n\t}\n\n\terror = regmap_write(haptics->regmap, DRV260X_GO, DRV260X_GO_BIT);\n\tif (error) {\n\t\tdev_err(&haptics->client->dev,\n\t\t\t\"Failed to write GO register: %d\\n\",\n\t\t\terror);\n\t\treturn error;\n\t}\n\n\tdo {\n\t\tusleep_range(15000, 15500);\n\t\terror = regmap_read(haptics->regmap, DRV260X_GO, &cal_buf);\n\t\tif (error) {\n\t\t\tdev_err(&haptics->client->dev,\n\t\t\t\t\"Failed to read GO register: %d\\n\",\n\t\t\t\terror);\n\t\t\treturn error;\n\t\t}\n\t} while (cal_buf == DRV260X_GO_BIT);\n\n\treturn 0;\n}\n\nstatic const struct regmap_config drv260x_regmap_config = {\n\t.reg_bits = 8,\n\t.val_bits = 8,\n\n\t.max_register = DRV260X_MAX_REG,\n\t.cache_type = REGCACHE_NONE,\n};\n\nstatic int drv260x_probe(struct i2c_client *client)\n{\n\tstruct device *dev = &client->dev;\n\tstruct drv260x_data *haptics;\n\tu32 voltage;\n\tint error;\n\n\thaptics = devm_kzalloc(dev, sizeof(*haptics), GFP_KERNEL);\n\tif (!haptics)\n\t\treturn -ENOMEM;\n\n\terror = device_property_read_u32(dev, \"mode\", &haptics->mode);\n\tif (error) {\n\t\tdev_err(dev, \"Can't fetch 'mode' property: %d\\n\", error);\n\t\treturn error;\n\t}\n\n\tif (haptics->mode < DRV260X_LRA_MODE ||\n\t    haptics->mode > DRV260X_ERM_MODE) {\n\t\tdev_err(dev, \"Vibrator mode is invalid: %i\\n\", haptics->mode);\n\t\treturn -EINVAL;\n\t}\n\n\terror = device_property_read_u32(dev, \"library-sel\", &haptics->library);\n\tif (error) {\n\t\tdev_err(dev, \"Can't fetch 'library-sel' property: %d\\n\", error);\n\t\treturn error;\n\t}\n\n\tif (haptics->library < DRV260X_LIB_EMPTY ||\n\t    haptics->library > DRV260X_ERM_LIB_F) {\n\t\tdev_err(dev,\n\t\t\t\"Library value is invalid: %i\\n\", haptics->library);\n\t\treturn -EINVAL;\n\t}\n\n\tif (haptics->mode == DRV260X_LRA_MODE &&\n\t    haptics->library != DRV260X_LIB_EMPTY &&\n\t    haptics->library != DRV260X_LIB_LRA) {\n\t\tdev_err(dev, \"LRA Mode with ERM Library mismatch\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (haptics->mode == DRV260X_ERM_MODE &&\n\t    (haptics->library == DRV260X_LIB_EMPTY ||\n\t     haptics->library == DRV260X_LIB_LRA)) {\n\t\tdev_err(dev, \"ERM Mode with LRA Library mismatch\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\terror = device_property_read_u32(dev, \"vib-rated-mv\", &voltage);\n\thaptics->rated_voltage = error ? DRV260X_DEF_RATED_VOLT :\n\t\t\t\t\t drv260x_calculate_voltage(voltage);\n\n\terror = device_property_read_u32(dev, \"vib-overdrive-mv\", &voltage);\n\thaptics->overdrive_voltage = error ? DRV260X_DEF_OD_CLAMP_VOLT :\n\t\t\t\t\t     drv260x_calculate_voltage(voltage);\n\n\thaptics->regulator = devm_regulator_get(dev, \"vbat\");\n\tif (IS_ERR(haptics->regulator)) {\n\t\terror = PTR_ERR(haptics->regulator);\n\t\tdev_err(dev, \"unable to get regulator, error: %d\\n\", error);\n\t\treturn error;\n\t}\n\n\thaptics->enable_gpio = devm_gpiod_get_optional(dev, \"enable\",\n\t\t\t\t\t\t       GPIOD_OUT_HIGH);\n\tif (IS_ERR(haptics->enable_gpio))\n\t\treturn PTR_ERR(haptics->enable_gpio);\n\n\thaptics->input_dev = devm_input_allocate_device(dev);\n\tif (!haptics->input_dev) {\n\t\tdev_err(dev, \"Failed to allocate input device\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\thaptics->input_dev->name = \"drv260x:haptics\";\n\thaptics->input_dev->close = drv260x_close;\n\tinput_set_drvdata(haptics->input_dev, haptics);\n\tinput_set_capability(haptics->input_dev, EV_FF, FF_RUMBLE);\n\n\terror = input_ff_create_memless(haptics->input_dev, NULL,\n\t\t\t\t\tdrv260x_haptics_play);\n\tif (error) {\n\t\tdev_err(dev, \"input_ff_create() failed: %d\\n\", error);\n\t\treturn error;\n\t}\n\n\tINIT_WORK(&haptics->work, drv260x_worker);\n\n\thaptics->client = client;\n\ti2c_set_clientdata(client, haptics);\n\n\thaptics->regmap = devm_regmap_init_i2c(client, &drv260x_regmap_config);\n\tif (IS_ERR(haptics->regmap)) {\n\t\terror = PTR_ERR(haptics->regmap);\n\t\tdev_err(dev, \"Failed to allocate register map: %d\\n\", error);\n\t\treturn error;\n\t}\n\n\terror = drv260x_init(haptics);\n\tif (error) {\n\t\tdev_err(dev, \"Device init failed: %d\\n\", error);\n\t\treturn error;\n\t}\n\n\terror = input_register_device(haptics->input_dev);\n\tif (error) {\n\t\tdev_err(dev, \"couldn't register input device: %d\\n\", error);\n\t\treturn error;\n\t}\n\n\treturn 0;\n}\n\nstatic int drv260x_suspend(struct device *dev)\n{\n\tstruct drv260x_data *haptics = dev_get_drvdata(dev);\n\tint ret = 0;\n\n\tmutex_lock(&haptics->input_dev->mutex);\n\n\tif (input_device_enabled(haptics->input_dev)) {\n\t\tret = regmap_update_bits(haptics->regmap,\n\t\t\t\t\t DRV260X_MODE,\n\t\t\t\t\t DRV260X_STANDBY_MASK,\n\t\t\t\t\t DRV260X_STANDBY);\n\t\tif (ret) {\n\t\t\tdev_err(dev, \"Failed to set standby mode\\n\");\n\t\t\tgoto out;\n\t\t}\n\n\t\tgpiod_set_value(haptics->enable_gpio, 0);\n\n\t\tret = regulator_disable(haptics->regulator);\n\t\tif (ret) {\n\t\t\tdev_err(dev, \"Failed to disable regulator\\n\");\n\t\t\tregmap_update_bits(haptics->regmap,\n\t\t\t\t\t   DRV260X_MODE,\n\t\t\t\t\t   DRV260X_STANDBY_MASK, 0);\n\t\t}\n\t}\nout:\n\tmutex_unlock(&haptics->input_dev->mutex);\n\treturn ret;\n}\n\nstatic int drv260x_resume(struct device *dev)\n{\n\tstruct drv260x_data *haptics = dev_get_drvdata(dev);\n\tint ret = 0;\n\n\tmutex_lock(&haptics->input_dev->mutex);\n\n\tif (input_device_enabled(haptics->input_dev)) {\n\t\tret = regulator_enable(haptics->regulator);\n\t\tif (ret) {\n\t\t\tdev_err(dev, \"Failed to enable regulator\\n\");\n\t\t\tgoto out;\n\t\t}\n\n\t\tret = regmap_update_bits(haptics->regmap,\n\t\t\t\t\t DRV260X_MODE,\n\t\t\t\t\t DRV260X_STANDBY_MASK, 0);\n\t\tif (ret) {\n\t\t\tdev_err(dev, \"Failed to unset standby mode\\n\");\n\t\t\tregulator_disable(haptics->regulator);\n\t\t\tgoto out;\n\t\t}\n\n\t\tgpiod_set_value(haptics->enable_gpio, 1);\n\t}\n\nout:\n\tmutex_unlock(&haptics->input_dev->mutex);\n\treturn ret;\n}\n\nstatic DEFINE_SIMPLE_DEV_PM_OPS(drv260x_pm_ops, drv260x_suspend, drv260x_resume);\n\nstatic const struct i2c_device_id drv260x_id[] = {\n\t{ \"drv2605l\", 0 },\n\t{ }\n};\nMODULE_DEVICE_TABLE(i2c, drv260x_id);\n\nstatic const struct of_device_id drv260x_of_match[] = {\n\t{ .compatible = \"ti,drv2604\", },\n\t{ .compatible = \"ti,drv2604l\", },\n\t{ .compatible = \"ti,drv2605\", },\n\t{ .compatible = \"ti,drv2605l\", },\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, drv260x_of_match);\n\nstatic struct i2c_driver drv260x_driver = {\n\t.probe\t\t= drv260x_probe,\n\t.driver\t\t= {\n\t\t.name\t= \"drv260x-haptics\",\n\t\t.of_match_table = drv260x_of_match,\n\t\t.pm\t= pm_sleep_ptr(&drv260x_pm_ops),\n\t},\n\t.id_table = drv260x_id,\n};\nmodule_i2c_driver(drv260x_driver);\n\nMODULE_DESCRIPTION(\"TI DRV260x haptics driver\");\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Dan Murphy <dmurphy@ti.com>\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}