{
  "module_name": "drv2665.c",
  "hash_id": "522414b262032762f3b5125facabd33dcf7e719b9c33d46ac5ee7704b350085c",
  "original_prompt": "Ingested from linux-6.6.14/drivers/input/misc/drv2665.c",
  "human_readable_source": "\n \n\n#include <linux/i2c.h>\n#include <linux/input.h>\n#include <linux/module.h>\n#include <linux/regmap.h>\n#include <linux/slab.h>\n#include <linux/delay.h>\n#include <linux/regulator/consumer.h>\n\n \n#define DRV2665_STATUS\t0x00\n#define DRV2665_CTRL_1\t0x01\n#define DRV2665_CTRL_2\t0x02\n#define DRV2665_FIFO\t0x0b\n\n \n#define DRV2665_FIFO_FULL\t\tBIT(0)\n#define DRV2665_FIFO_EMPTY\t\tBIT(1)\n\n \n#define DRV2665_25_VPP_GAIN\t\t0x00\n#define DRV2665_50_VPP_GAIN\t\t0x01\n#define DRV2665_75_VPP_GAIN\t\t0x02\n#define DRV2665_100_VPP_GAIN\t\t0x03\n#define DRV2665_DIGITAL_IN\t\t0xfc\n#define DRV2665_ANALOG_IN\t\tBIT(2)\n\n \n#define DRV2665_BOOST_EN\t\tBIT(1)\n#define DRV2665_STANDBY\t\t\tBIT(6)\n#define DRV2665_DEV_RST\t\t\tBIT(7)\n#define DRV2665_5_MS_IDLE_TOUT\t\t0x00\n#define DRV2665_10_MS_IDLE_TOUT\t\t0x04\n#define DRV2665_15_MS_IDLE_TOUT\t\t0x08\n#define DRV2665_20_MS_IDLE_TOUT\t\t0x0c\n\n \nstruct drv2665_data {\n\tstruct input_dev *input_dev;\n\tstruct i2c_client *client;\n\tstruct regmap *regmap;\n\tstruct work_struct work;\n\tstruct regulator *regulator;\n};\n\n \nstatic const u8 drv2665_sine_wave_form[] = {\n\t0x00, 0x10, 0x20, 0x2e, 0x3c, 0x48, 0x53, 0x5b, 0x61, 0x65, 0x66,\n\t0x65, 0x61, 0x5b, 0x53, 0x48, 0x3c, 0x2e, 0x20, 0x10,\n\t0x00, 0xf0, 0xe0, 0xd2, 0xc4, 0xb8, 0xad, 0xa5, 0x9f, 0x9b, 0x9a,\n\t0x9b, 0x9f, 0xa5, 0xad, 0xb8, 0xc4, 0xd2, 0xe0, 0xf0, 0x00,\n};\n\nstatic const struct reg_default drv2665_reg_defs[] = {\n\t{ DRV2665_STATUS, 0x02 },\n\t{ DRV2665_CTRL_1, 0x28 },\n\t{ DRV2665_CTRL_2, 0x40 },\n\t{ DRV2665_FIFO, 0x00 },\n};\n\nstatic void drv2665_worker(struct work_struct *work)\n{\n\tstruct drv2665_data *haptics =\n\t\t\t\tcontainer_of(work, struct drv2665_data, work);\n\tunsigned int read_buf;\n\tint error;\n\n\terror = regmap_read(haptics->regmap, DRV2665_STATUS, &read_buf);\n\tif (error) {\n\t\tdev_err(&haptics->client->dev,\n\t\t\t\"Failed to read status: %d\\n\", error);\n\t\treturn;\n\t}\n\n\tif (read_buf & DRV2665_FIFO_EMPTY) {\n\t\terror = regmap_bulk_write(haptics->regmap,\n\t\t\t\t\t  DRV2665_FIFO,\n\t\t\t\t\t  drv2665_sine_wave_form,\n\t\t\t\t\t  ARRAY_SIZE(drv2665_sine_wave_form));\n\t\tif (error) {\n\t\t\tdev_err(&haptics->client->dev,\n\t\t\t\t\"Failed to write FIFO: %d\\n\", error);\n\t\t\treturn;\n\t\t}\n\t}\n}\n\nstatic int drv2665_haptics_play(struct input_dev *input, void *data,\n\t\t\t\tstruct ff_effect *effect)\n{\n\tstruct drv2665_data *haptics = input_get_drvdata(input);\n\n\tschedule_work(&haptics->work);\n\n\treturn 0;\n}\n\nstatic void drv2665_close(struct input_dev *input)\n{\n\tstruct drv2665_data *haptics = input_get_drvdata(input);\n\tint error;\n\n\tcancel_work_sync(&haptics->work);\n\n\terror = regmap_update_bits(haptics->regmap, DRV2665_CTRL_2,\n\t\t\t\t   DRV2665_STANDBY, DRV2665_STANDBY);\n\tif (error)\n\t\tdev_err(&haptics->client->dev,\n\t\t\t\"Failed to enter standby mode: %d\\n\", error);\n}\n\nstatic const struct reg_sequence drv2665_init_regs[] = {\n\t{ DRV2665_CTRL_2, 0 | DRV2665_10_MS_IDLE_TOUT },\n\t{ DRV2665_CTRL_1, DRV2665_25_VPP_GAIN },\n};\n\nstatic int drv2665_init(struct drv2665_data *haptics)\n{\n\tint error;\n\n\terror = regmap_register_patch(haptics->regmap,\n\t\t\t\t      drv2665_init_regs,\n\t\t\t\t      ARRAY_SIZE(drv2665_init_regs));\n\tif (error) {\n\t\tdev_err(&haptics->client->dev,\n\t\t\t\"Failed to write init registers: %d\\n\",\n\t\t\terror);\n\t\treturn error;\n\t}\n\n\treturn 0;\n}\n\nstatic const struct regmap_config drv2665_regmap_config = {\n\t.reg_bits = 8,\n\t.val_bits = 8,\n\n\t.max_register = DRV2665_FIFO,\n\t.reg_defaults = drv2665_reg_defs,\n\t.num_reg_defaults = ARRAY_SIZE(drv2665_reg_defs),\n\t.cache_type = REGCACHE_NONE,\n};\n\nstatic int drv2665_probe(struct i2c_client *client)\n{\n\tstruct drv2665_data *haptics;\n\tint error;\n\n\thaptics = devm_kzalloc(&client->dev, sizeof(*haptics), GFP_KERNEL);\n\tif (!haptics)\n\t\treturn -ENOMEM;\n\n\thaptics->regulator = devm_regulator_get(&client->dev, \"vbat\");\n\tif (IS_ERR(haptics->regulator)) {\n\t\terror = PTR_ERR(haptics->regulator);\n\t\tdev_err(&client->dev,\n\t\t\t\"unable to get regulator, error: %d\\n\", error);\n\t\treturn error;\n\t}\n\n\thaptics->input_dev = devm_input_allocate_device(&client->dev);\n\tif (!haptics->input_dev) {\n\t\tdev_err(&client->dev, \"Failed to allocate input device\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\thaptics->input_dev->name = \"drv2665:haptics\";\n\thaptics->input_dev->dev.parent = client->dev.parent;\n\thaptics->input_dev->close = drv2665_close;\n\tinput_set_drvdata(haptics->input_dev, haptics);\n\tinput_set_capability(haptics->input_dev, EV_FF, FF_RUMBLE);\n\n\terror = input_ff_create_memless(haptics->input_dev, NULL,\n\t\t\t\t\tdrv2665_haptics_play);\n\tif (error) {\n\t\tdev_err(&client->dev, \"input_ff_create() failed: %d\\n\",\n\t\t\terror);\n\t\treturn error;\n\t}\n\n\tINIT_WORK(&haptics->work, drv2665_worker);\n\n\thaptics->client = client;\n\ti2c_set_clientdata(client, haptics);\n\n\thaptics->regmap = devm_regmap_init_i2c(client, &drv2665_regmap_config);\n\tif (IS_ERR(haptics->regmap)) {\n\t\terror = PTR_ERR(haptics->regmap);\n\t\tdev_err(&client->dev, \"Failed to allocate register map: %d\\n\",\n\t\t\terror);\n\t\treturn error;\n\t}\n\n\terror = drv2665_init(haptics);\n\tif (error) {\n\t\tdev_err(&client->dev, \"Device init failed: %d\\n\", error);\n\t\treturn error;\n\t}\n\n\terror = input_register_device(haptics->input_dev);\n\tif (error) {\n\t\tdev_err(&client->dev, \"couldn't register input device: %d\\n\",\n\t\t\terror);\n\t\treturn error;\n\t}\n\n\treturn 0;\n}\n\nstatic int drv2665_suspend(struct device *dev)\n{\n\tstruct drv2665_data *haptics = dev_get_drvdata(dev);\n\tint ret = 0;\n\n\tmutex_lock(&haptics->input_dev->mutex);\n\n\tif (input_device_enabled(haptics->input_dev)) {\n\t\tret = regmap_update_bits(haptics->regmap, DRV2665_CTRL_2,\n\t\t\t\t\t DRV2665_STANDBY, DRV2665_STANDBY);\n\t\tif (ret) {\n\t\t\tdev_err(dev, \"Failed to set standby mode\\n\");\n\t\t\tregulator_disable(haptics->regulator);\n\t\t\tgoto out;\n\t\t}\n\n\t\tret = regulator_disable(haptics->regulator);\n\t\tif (ret) {\n\t\t\tdev_err(dev, \"Failed to disable regulator\\n\");\n\t\t\tregmap_update_bits(haptics->regmap,\n\t\t\t\t\t   DRV2665_CTRL_2,\n\t\t\t\t\t   DRV2665_STANDBY, 0);\n\t\t}\n\t}\nout:\n\tmutex_unlock(&haptics->input_dev->mutex);\n\treturn ret;\n}\n\nstatic int drv2665_resume(struct device *dev)\n{\n\tstruct drv2665_data *haptics = dev_get_drvdata(dev);\n\tint ret = 0;\n\n\tmutex_lock(&haptics->input_dev->mutex);\n\n\tif (input_device_enabled(haptics->input_dev)) {\n\t\tret = regulator_enable(haptics->regulator);\n\t\tif (ret) {\n\t\t\tdev_err(dev, \"Failed to enable regulator\\n\");\n\t\t\tgoto out;\n\t\t}\n\n\t\tret = regmap_update_bits(haptics->regmap, DRV2665_CTRL_2,\n\t\t\t\t\t DRV2665_STANDBY, 0);\n\t\tif (ret) {\n\t\t\tdev_err(dev, \"Failed to unset standby mode\\n\");\n\t\t\tregulator_disable(haptics->regulator);\n\t\t\tgoto out;\n\t\t}\n\n\t}\n\nout:\n\tmutex_unlock(&haptics->input_dev->mutex);\n\treturn ret;\n}\n\nstatic DEFINE_SIMPLE_DEV_PM_OPS(drv2665_pm_ops, drv2665_suspend, drv2665_resume);\n\nstatic const struct i2c_device_id drv2665_id[] = {\n\t{ \"drv2665\", 0 },\n\t{ }\n};\nMODULE_DEVICE_TABLE(i2c, drv2665_id);\n\n#ifdef CONFIG_OF\nstatic const struct of_device_id drv2665_of_match[] = {\n\t{ .compatible = \"ti,drv2665\", },\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, drv2665_of_match);\n#endif\n\nstatic struct i2c_driver drv2665_driver = {\n\t.probe\t\t= drv2665_probe,\n\t.driver\t\t= {\n\t\t.name\t= \"drv2665-haptics\",\n\t\t.of_match_table = of_match_ptr(drv2665_of_match),\n\t\t.pm\t= pm_sleep_ptr(&drv2665_pm_ops),\n\t},\n\t.id_table = drv2665_id,\n};\nmodule_i2c_driver(drv2665_driver);\n\nMODULE_DESCRIPTION(\"TI DRV2665 haptics driver\");\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Dan Murphy <dmurphy@ti.com>\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}