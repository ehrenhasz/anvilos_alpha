{
  "module_name": "apanel.c",
  "hash_id": "c26d6e8a18866ef7c378d5e7e8b21a6f05388a8e163e332b817b9721526cf2a7",
  "original_prompt": "Ingested from linux-6.6.14/drivers/input/misc/apanel.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/ioport.h>\n#include <linux/io.h>\n#include <linux/input.h>\n#include <linux/i2c.h>\n#include <linux/leds.h>\n\n#define APANEL_NAME\t\"Fujitsu Application Panel\"\n#define APANEL\t\t\"apanel\"\n\n \n#define POLL_INTERVAL_DEFAULT\t1000\n\n \nenum apanel_devid {\n\tAPANEL_DEV_NONE\t  = 0,\n\tAPANEL_DEV_APPBTN = 1,\n\tAPANEL_DEV_CDBTN  = 2,\n\tAPANEL_DEV_LCD\t  = 3,\n\tAPANEL_DEV_LED\t  = 4,\n\n\tAPANEL_DEV_MAX,\n};\n\nenum apanel_chip {\n\tCHIP_NONE    = 0,\n\tCHIP_OZ992C  = 1,\n\tCHIP_OZ163T  = 2,\n\tCHIP_OZ711M3 = 4,\n};\n\n \nstatic enum apanel_chip device_chip[APANEL_DEV_MAX];\n\n#define MAX_PANEL_KEYS\t12\n\nstruct apanel {\n\tstruct input_dev *idev;\n\tstruct i2c_client *client;\n\tunsigned short keymap[MAX_PANEL_KEYS];\n\tu16 nkeys;\n\tstruct led_classdev mail_led;\n};\n\nstatic const unsigned short apanel_keymap[MAX_PANEL_KEYS] = {\n\t[0] = KEY_MAIL,\n\t[1] = KEY_WWW,\n\t[2] = KEY_PROG2,\n\t[3] = KEY_PROG1,\n\n\t[8] = KEY_FORWARD,\n\t[9] = KEY_REWIND,\n\t[10] = KEY_STOPCD,\n\t[11] = KEY_PLAYPAUSE,\n};\n\nstatic void report_key(struct input_dev *input, unsigned keycode)\n{\n\tdev_dbg(input->dev.parent, \"report key %#x\\n\", keycode);\n\tinput_report_key(input, keycode, 1);\n\tinput_sync(input);\n\n\tinput_report_key(input, keycode, 0);\n\tinput_sync(input);\n}\n\n \nstatic void apanel_poll(struct input_dev *idev)\n{\n\tstruct apanel *ap = input_get_drvdata(idev);\n\tu8 cmd = device_chip[APANEL_DEV_APPBTN] == CHIP_OZ992C ? 0 : 8;\n\ts32 data;\n\tint i;\n\n\tdata = i2c_smbus_read_word_data(ap->client, cmd);\n\tif (data < 0)\n\t\treturn;\t \n\n\t \n\ti2c_smbus_write_word_data(ap->client, cmd, 0);\n\n\tif (!data)\n\t\treturn;\n\n\tdev_dbg(&idev->dev, APANEL \": data %#x\\n\", data);\n\tfor (i = 0; i < idev->keycodemax; i++)\n\t\tif ((1u << i) & data)\n\t\t\treport_key(idev, ap->keymap[i]);\n}\n\nstatic int mail_led_set(struct led_classdev *led,\n\t\t\t enum led_brightness value)\n{\n\tstruct apanel *ap = container_of(led, struct apanel, mail_led);\n\tu16 led_bits = value != LED_OFF ? 0x8000 : 0x0000;\n\n\treturn i2c_smbus_write_word_data(ap->client, 0x10, led_bits);\n}\n\nstatic int apanel_probe(struct i2c_client *client)\n{\n\tstruct apanel *ap;\n\tstruct input_dev *idev;\n\tu8 cmd = device_chip[APANEL_DEV_APPBTN] == CHIP_OZ992C ? 0 : 8;\n\tint i, err;\n\n\tap = devm_kzalloc(&client->dev, sizeof(*ap), GFP_KERNEL);\n\tif (!ap)\n\t\treturn -ENOMEM;\n\n\tidev = devm_input_allocate_device(&client->dev);\n\tif (!idev)\n\t\treturn -ENOMEM;\n\n\tap->idev = idev;\n\tap->client = client;\n\n\ti2c_set_clientdata(client, ap);\n\n\terr = i2c_smbus_write_word_data(client, cmd, 0);\n\tif (err) {\n\t\tdev_warn(&client->dev, \"smbus write error %d\\n\", err);\n\t\treturn err;\n\t}\n\n\tinput_set_drvdata(idev, ap);\n\n\tidev->name = APANEL_NAME \" buttons\";\n\tidev->phys = \"apanel/input0\";\n\tidev->id.bustype = BUS_HOST;\n\n\tmemcpy(ap->keymap, apanel_keymap, sizeof(apanel_keymap));\n\tidev->keycode = ap->keymap;\n\tidev->keycodesize = sizeof(ap->keymap[0]);\n\tidev->keycodemax = (device_chip[APANEL_DEV_CDBTN] != CHIP_NONE) ? 12 : 4;\n\n\tset_bit(EV_KEY, idev->evbit);\n\tfor (i = 0; i < idev->keycodemax; i++)\n\t\tif (ap->keymap[i])\n\t\t\tset_bit(ap->keymap[i], idev->keybit);\n\n\terr = input_setup_polling(idev, apanel_poll);\n\tif (err)\n\t\treturn err;\n\n\tinput_set_poll_interval(idev, POLL_INTERVAL_DEFAULT);\n\n\terr = input_register_device(idev);\n\tif (err)\n\t\treturn err;\n\n\tif (device_chip[APANEL_DEV_LED] != CHIP_NONE) {\n\t\tap->mail_led.name = \"mail:blue\";\n\t\tap->mail_led.brightness_set_blocking = mail_led_set;\n\t\terr = devm_led_classdev_register(&client->dev, &ap->mail_led);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\nstatic void apanel_shutdown(struct i2c_client *client)\n{\n\tstruct apanel *ap = i2c_get_clientdata(client);\n\n\tif (device_chip[APANEL_DEV_LED] != CHIP_NONE)\n\t\tled_set_brightness(&ap->mail_led, LED_OFF);\n}\n\nstatic const struct i2c_device_id apanel_id[] = {\n\t{ \"fujitsu_apanel\", 0 },\n\t{ }\n};\nMODULE_DEVICE_TABLE(i2c, apanel_id);\n\nstatic struct i2c_driver apanel_driver = {\n\t.driver = {\n\t\t.name = APANEL,\n\t},\n\t.probe\t\t= apanel_probe,\n\t.shutdown\t= apanel_shutdown,\n\t.id_table\t= apanel_id,\n};\n\n \nstatic __init const void __iomem *bios_signature(const void __iomem *bios)\n{\n\tssize_t offset;\n\tconst unsigned char signature[] = \"FJKEYINF\";\n\n\tfor (offset = 0; offset < 0x10000; offset += 0x10) {\n\t\tif (check_signature(bios + offset, signature,\n\t\t\t\t    sizeof(signature)-1))\n\t\t\treturn bios + offset;\n\t}\n\tpr_notice(APANEL \": Fujitsu BIOS signature '%s' not found...\\n\",\n\t\t  signature);\n\treturn NULL;\n}\n\nstatic int __init apanel_init(void)\n{\n\tvoid __iomem *bios;\n\tconst void __iomem *p;\n\tu8 devno;\n\tunsigned char i2c_addr;\n\tint found = 0;\n\n\tbios = ioremap(0xF0000, 0x10000);  \n\n\tp = bios_signature(bios);\n\tif (!p) {\n\t\tiounmap(bios);\n\t\treturn -ENODEV;\n\t}\n\n\t \n\tp += 8;\n\ti2c_addr = readb(p + 3) >> 1;\n\n\tfor ( ; (devno = readb(p)) & 0x7f; p += 4) {\n\t\tunsigned char method, slave, chip;\n\n\t\tmethod = readb(p + 1);\n\t\tchip = readb(p + 2);\n\t\tslave = readb(p + 3) >> 1;\n\n\t\tif (slave != i2c_addr) {\n\t\t\tpr_notice(APANEL \": only one SMBus slave \"\n\t\t\t\t  \"address supported, skipping device...\\n\");\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\tswitch (devno) {\n\t\tcase 6:\n\t\t\tdevno = APANEL_DEV_APPBTN;\n\t\t\tbreak;\n\t\tcase 7:\n\t\t\tdevno = APANEL_DEV_LED;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (devno >= APANEL_DEV_MAX)\n\t\t\tpr_notice(APANEL \": unknown device %u found\\n\", devno);\n\t\telse if (device_chip[devno] != CHIP_NONE)\n\t\t\tpr_warn(APANEL \": duplicate entry for devno %u\\n\",\n\t\t\t\tdevno);\n\n\t\telse if (method != 1 && method != 2 && method != 4) {\n\t\t\tpr_notice(APANEL \": unknown method %u for devno %u\\n\",\n\t\t\t\t  method, devno);\n\t\t} else {\n\t\t\tdevice_chip[devno] = (enum apanel_chip) chip;\n\t\t\t++found;\n\t\t}\n\t}\n\tiounmap(bios);\n\n\tif (found == 0) {\n\t\tpr_info(APANEL \": no input devices reported by BIOS\\n\");\n\t\treturn -EIO;\n\t}\n\n\treturn i2c_add_driver(&apanel_driver);\n}\nmodule_init(apanel_init);\n\nstatic void __exit apanel_cleanup(void)\n{\n\ti2c_del_driver(&apanel_driver);\n}\nmodule_exit(apanel_cleanup);\n\nMODULE_AUTHOR(\"Stephen Hemminger <shemminger@linux-foundation.org>\");\nMODULE_DESCRIPTION(APANEL_NAME \" driver\");\nMODULE_LICENSE(\"GPL\");\n\nMODULE_ALIAS(\"dmi:*:svnFUJITSU:pnLifeBook*:pvr*:rvnFUJITSU:*\");\nMODULE_ALIAS(\"dmi:*:svnFUJITSU:pnLifebook*:pvr*:rvnFUJITSU:*\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}