{
  "module_name": "regulator-haptic.c",
  "hash_id": "613be7d195a91b3e7615b921051141798845d9032d0b47da356f55558903f964",
  "original_prompt": "Ingested from linux-6.6.14/drivers/input/misc/regulator-haptic.c",
  "human_readable_source": "\n \n\n#include <linux/input.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/platform_data/regulator-haptic.h>\n#include <linux/platform_device.h>\n#include <linux/regulator/consumer.h>\n#include <linux/slab.h>\n\n#define MAX_MAGNITUDE_SHIFT\t16\n\nstruct regulator_haptic {\n\tstruct device *dev;\n\tstruct input_dev *input_dev;\n\tstruct regulator *regulator;\n\n\tstruct work_struct work;\n\tstruct mutex mutex;\n\n\tbool active;\n\tbool suspended;\n\n\tunsigned int max_volt;\n\tunsigned int min_volt;\n\tunsigned int magnitude;\n};\n\nstatic int regulator_haptic_toggle(struct regulator_haptic *haptic, bool on)\n{\n\tint error;\n\n\tif (haptic->active != on) {\n\n\t\terror = on ? regulator_enable(haptic->regulator) :\n\t\t\t     regulator_disable(haptic->regulator);\n\t\tif (error) {\n\t\t\tdev_err(haptic->dev,\n\t\t\t\t\"failed to switch regulator %s: %d\\n\",\n\t\t\t\ton ? \"on\" : \"off\", error);\n\t\t\treturn error;\n\t\t}\n\n\t\thaptic->active = on;\n\t}\n\n\treturn 0;\n}\n\nstatic int regulator_haptic_set_voltage(struct regulator_haptic *haptic,\n\t\t\t\t\t unsigned int magnitude)\n{\n\tu64 volt_mag_multi;\n\tunsigned int intensity;\n\tint error;\n\n\tvolt_mag_multi = (u64)(haptic->max_volt - haptic->min_volt) * magnitude;\n\tintensity = (unsigned int)(volt_mag_multi >> MAX_MAGNITUDE_SHIFT);\n\n\terror = regulator_set_voltage(haptic->regulator,\n\t\t\t\t      intensity + haptic->min_volt,\n\t\t\t\t      haptic->max_volt);\n\tif (error) {\n\t\tdev_err(haptic->dev, \"cannot set regulator voltage to %d: %d\\n\",\n\t\t\tintensity + haptic->min_volt, error);\n\t\treturn error;\n\t}\n\n\tregulator_haptic_toggle(haptic, !!magnitude);\n\n\treturn 0;\n}\n\nstatic void regulator_haptic_work(struct work_struct *work)\n{\n\tstruct regulator_haptic *haptic = container_of(work,\n\t\t\t\t\tstruct regulator_haptic, work);\n\n\tmutex_lock(&haptic->mutex);\n\n\tif (!haptic->suspended)\n\t\tregulator_haptic_set_voltage(haptic, haptic->magnitude);\n\n\tmutex_unlock(&haptic->mutex);\n}\n\nstatic int regulator_haptic_play_effect(struct input_dev *input, void *data,\n\t\t\t\t\tstruct ff_effect *effect)\n{\n\tstruct regulator_haptic *haptic = input_get_drvdata(input);\n\n\thaptic->magnitude = effect->u.rumble.strong_magnitude;\n\tif (!haptic->magnitude)\n\t\thaptic->magnitude = effect->u.rumble.weak_magnitude;\n\n\tschedule_work(&haptic->work);\n\n\treturn 0;\n}\n\nstatic void regulator_haptic_close(struct input_dev *input)\n{\n\tstruct regulator_haptic *haptic = input_get_drvdata(input);\n\n\tcancel_work_sync(&haptic->work);\n\tregulator_haptic_set_voltage(haptic, 0);\n}\n\nstatic int __maybe_unused\nregulator_haptic_parse_dt(struct device *dev, struct regulator_haptic *haptic)\n{\n\tstruct device_node *node;\n\tint error;\n\n\tnode = dev->of_node;\n\tif(!node) {\n\t\tdev_err(dev, \"Missing device tree data\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\terror = of_property_read_u32(node, \"max-microvolt\", &haptic->max_volt);\n\tif (error) {\n\t\tdev_err(dev, \"cannot parse max-microvolt\\n\");\n\t\treturn error;\n\t}\n\n\terror = of_property_read_u32(node, \"min-microvolt\", &haptic->min_volt);\n\tif (error) {\n\t\tdev_err(dev, \"cannot parse min-microvolt\\n\");\n\t\treturn error;\n\t}\n\n\treturn 0;\n}\n\nstatic int regulator_haptic_probe(struct platform_device *pdev)\n{\n\tconst struct regulator_haptic_data *pdata = dev_get_platdata(&pdev->dev);\n\tstruct regulator_haptic *haptic;\n\tstruct input_dev *input_dev;\n\tint error;\n\n\thaptic = devm_kzalloc(&pdev->dev, sizeof(*haptic), GFP_KERNEL);\n\tif (!haptic)\n\t\treturn -ENOMEM;\n\n\tplatform_set_drvdata(pdev, haptic);\n\thaptic->dev = &pdev->dev;\n\tmutex_init(&haptic->mutex);\n\tINIT_WORK(&haptic->work, regulator_haptic_work);\n\n\tif (pdata) {\n\t\thaptic->max_volt = pdata->max_volt;\n\t\thaptic->min_volt = pdata->min_volt;\n\t} else if (IS_ENABLED(CONFIG_OF)) {\n\t\terror = regulator_haptic_parse_dt(&pdev->dev, haptic);\n\t\tif (error)\n\t\t\treturn error;\n\t} else {\n\t\tdev_err(&pdev->dev, \"Missing platform data\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\thaptic->regulator = devm_regulator_get_exclusive(&pdev->dev, \"haptic\");\n\tif (IS_ERR(haptic->regulator)) {\n\t\tdev_err(&pdev->dev, \"failed to get regulator\\n\");\n\t\treturn PTR_ERR(haptic->regulator);\n\t}\n\n\tinput_dev = devm_input_allocate_device(&pdev->dev);\n\tif (!input_dev)\n\t\treturn\t-ENOMEM;\n\n\thaptic->input_dev = input_dev;\n\thaptic->input_dev->name = \"regulator-haptic\";\n\thaptic->input_dev->dev.parent = &pdev->dev;\n\thaptic->input_dev->close = regulator_haptic_close;\n\tinput_set_drvdata(haptic->input_dev, haptic);\n\tinput_set_capability(haptic->input_dev, EV_FF, FF_RUMBLE);\n\n\terror = input_ff_create_memless(input_dev, NULL,\n\t\t\t\t\tregulator_haptic_play_effect);\n\tif (error) {\n\t\tdev_err(&pdev->dev, \"failed to create force-feedback\\n\");\n\t\treturn error;\n\t}\n\n\terror = input_register_device(haptic->input_dev);\n\tif (error) {\n\t\tdev_err(&pdev->dev, \"failed to register input device\\n\");\n\t\treturn error;\n\t}\n\n\treturn 0;\n}\n\nstatic int regulator_haptic_suspend(struct device *dev)\n{\n\tstruct platform_device *pdev = to_platform_device(dev);\n\tstruct regulator_haptic *haptic = platform_get_drvdata(pdev);\n\tint error;\n\n\terror = mutex_lock_interruptible(&haptic->mutex);\n\tif (error)\n\t\treturn error;\n\n\tregulator_haptic_set_voltage(haptic, 0);\n\n\thaptic->suspended = true;\n\n\tmutex_unlock(&haptic->mutex);\n\n\treturn 0;\n}\n\nstatic int regulator_haptic_resume(struct device *dev)\n{\n\tstruct platform_device *pdev = to_platform_device(dev);\n\tstruct regulator_haptic *haptic = platform_get_drvdata(pdev);\n\tunsigned int magnitude;\n\n\tmutex_lock(&haptic->mutex);\n\n\thaptic->suspended = false;\n\n\tmagnitude = READ_ONCE(haptic->magnitude);\n\tif (magnitude)\n\t\tregulator_haptic_set_voltage(haptic, magnitude);\n\n\tmutex_unlock(&haptic->mutex);\n\n\treturn 0;\n}\n\nstatic DEFINE_SIMPLE_DEV_PM_OPS(regulator_haptic_pm_ops,\n\t\tregulator_haptic_suspend, regulator_haptic_resume);\n\nstatic const struct of_device_id regulator_haptic_dt_match[] = {\n\t{ .compatible = \"regulator-haptic\" },\n\t{   },\n};\nMODULE_DEVICE_TABLE(of, regulator_haptic_dt_match);\n\nstatic struct platform_driver regulator_haptic_driver = {\n\t.probe\t\t= regulator_haptic_probe,\n\t.driver\t\t= {\n\t\t.name\t\t= \"regulator-haptic\",\n\t\t.of_match_table = regulator_haptic_dt_match,\n\t\t.pm\t\t= pm_sleep_ptr(&regulator_haptic_pm_ops),\n\t},\n};\nmodule_platform_driver(regulator_haptic_driver);\n\nMODULE_AUTHOR(\"Jaewon Kim <jaewon02.kim@samsung.com>\");\nMODULE_AUTHOR(\"Hyunhee Kim <hyunhee.kim@samsung.com>\");\nMODULE_DESCRIPTION(\"Regulator haptic driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}