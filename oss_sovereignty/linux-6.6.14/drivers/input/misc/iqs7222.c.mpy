{
  "module_name": "iqs7222.c",
  "hash_id": "8fc571481a68905a80d417a0b0e03fc13c22b0656a07f1d33dc0b68ca90f5237",
  "original_prompt": "Ingested from linux-6.6.14/drivers/input/misc/iqs7222.c",
  "human_readable_source": "\n \n\n#include <linux/bits.h>\n#include <linux/delay.h>\n#include <linux/device.h>\n#include <linux/err.h>\n#include <linux/gpio/consumer.h>\n#include <linux/i2c.h>\n#include <linux/input.h>\n#include <linux/input/touchscreen.h>\n#include <linux/interrupt.h>\n#include <linux/kernel.h>\n#include <linux/ktime.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include <linux/property.h>\n#include <linux/slab.h>\n#include <asm/unaligned.h>\n\n#define IQS7222_PROD_NUM\t\t\t0x00\n#define IQS7222_PROD_NUM_A\t\t\t840\n#define IQS7222_PROD_NUM_B\t\t\t698\n#define IQS7222_PROD_NUM_C\t\t\t863\n#define IQS7222_PROD_NUM_D\t\t\t1046\n\n#define IQS7222_SYS_STATUS\t\t\t0x10\n#define IQS7222_SYS_STATUS_RESET\t\tBIT(3)\n#define IQS7222_SYS_STATUS_ATI_ERROR\t\tBIT(1)\n#define IQS7222_SYS_STATUS_ATI_ACTIVE\t\tBIT(0)\n\n#define IQS7222_CHAN_SETUP_0_REF_MODE_MASK\tGENMASK(15, 14)\n#define IQS7222_CHAN_SETUP_0_REF_MODE_FOLLOW\tBIT(15)\n#define IQS7222_CHAN_SETUP_0_REF_MODE_REF\tBIT(14)\n#define IQS7222_CHAN_SETUP_0_CHAN_EN\t\tBIT(8)\n\n#define IQS7222_SLDR_SETUP_0_CHAN_CNT_MASK\tGENMASK(2, 0)\n#define IQS7222_SLDR_SETUP_2_RES_MASK\t\tGENMASK(15, 8)\n#define IQS7222_SLDR_SETUP_2_RES_SHIFT\t\t8\n#define IQS7222_SLDR_SETUP_2_TOP_SPEED_MASK\tGENMASK(7, 0)\n\n#define IQS7222_GPIO_SETUP_0_GPIO_EN\t\tBIT(0)\n\n#define IQS7222_SYS_SETUP\t\t\t0xD0\n#define IQS7222_SYS_SETUP_INTF_MODE_MASK\tGENMASK(7, 6)\n#define IQS7222_SYS_SETUP_INTF_MODE_TOUCH\tBIT(7)\n#define IQS7222_SYS_SETUP_INTF_MODE_EVENT\tBIT(6)\n#define IQS7222_SYS_SETUP_PWR_MODE_MASK\t\tGENMASK(5, 4)\n#define IQS7222_SYS_SETUP_PWR_MODE_AUTO\t\tIQS7222_SYS_SETUP_PWR_MODE_MASK\n#define IQS7222_SYS_SETUP_REDO_ATI\t\tBIT(2)\n#define IQS7222_SYS_SETUP_ACK_RESET\t\tBIT(0)\n\n#define IQS7222_EVENT_MASK_ATI\t\t\tBIT(12)\n#define IQS7222_EVENT_MASK_SLDR\t\t\tBIT(10)\n#define IQS7222_EVENT_MASK_TPAD\t\t\tIQS7222_EVENT_MASK_SLDR\n#define IQS7222_EVENT_MASK_TOUCH\t\tBIT(1)\n#define IQS7222_EVENT_MASK_PROX\t\t\tBIT(0)\n\n#define IQS7222_COMMS_HOLD\t\t\tBIT(0)\n#define IQS7222_COMMS_ERROR\t\t\t0xEEEE\n#define IQS7222_COMMS_RETRY_MS\t\t\t50\n#define IQS7222_COMMS_TIMEOUT_MS\t\t100\n#define IQS7222_RESET_TIMEOUT_MS\t\t250\n#define IQS7222_ATI_TIMEOUT_MS\t\t\t2000\n\n#define IQS7222_MAX_COLS_STAT\t\t\t8\n#define IQS7222_MAX_COLS_CYCLE\t\t\t3\n#define IQS7222_MAX_COLS_GLBL\t\t\t3\n#define IQS7222_MAX_COLS_BTN\t\t\t3\n#define IQS7222_MAX_COLS_CHAN\t\t\t6\n#define IQS7222_MAX_COLS_FILT\t\t\t2\n#define IQS7222_MAX_COLS_SLDR\t\t\t11\n#define IQS7222_MAX_COLS_TPAD\t\t\t24\n#define IQS7222_MAX_COLS_GPIO\t\t\t3\n#define IQS7222_MAX_COLS_SYS\t\t\t13\n\n#define IQS7222_MAX_CHAN\t\t\t20\n#define IQS7222_MAX_SLDR\t\t\t2\n\n#define IQS7222_NUM_RETRIES\t\t\t5\n#define IQS7222_REG_OFFSET\t\t\t0x100\n\nenum iqs7222_reg_key_id {\n\tIQS7222_REG_KEY_NONE,\n\tIQS7222_REG_KEY_PROX,\n\tIQS7222_REG_KEY_TOUCH,\n\tIQS7222_REG_KEY_DEBOUNCE,\n\tIQS7222_REG_KEY_TAP,\n\tIQS7222_REG_KEY_TAP_LEGACY,\n\tIQS7222_REG_KEY_AXIAL,\n\tIQS7222_REG_KEY_AXIAL_LEGACY,\n\tIQS7222_REG_KEY_WHEEL,\n\tIQS7222_REG_KEY_NO_WHEEL,\n\tIQS7222_REG_KEY_RESERVED\n};\n\nenum iqs7222_reg_grp_id {\n\tIQS7222_REG_GRP_STAT,\n\tIQS7222_REG_GRP_FILT,\n\tIQS7222_REG_GRP_CYCLE,\n\tIQS7222_REG_GRP_GLBL,\n\tIQS7222_REG_GRP_BTN,\n\tIQS7222_REG_GRP_CHAN,\n\tIQS7222_REG_GRP_SLDR,\n\tIQS7222_REG_GRP_TPAD,\n\tIQS7222_REG_GRP_GPIO,\n\tIQS7222_REG_GRP_SYS,\n\tIQS7222_NUM_REG_GRPS\n};\n\nstatic const char * const iqs7222_reg_grp_names[IQS7222_NUM_REG_GRPS] = {\n\t[IQS7222_REG_GRP_CYCLE] = \"cycle-%d\",\n\t[IQS7222_REG_GRP_CHAN] = \"channel-%d\",\n\t[IQS7222_REG_GRP_SLDR] = \"slider-%d\",\n\t[IQS7222_REG_GRP_TPAD] = \"trackpad\",\n\t[IQS7222_REG_GRP_GPIO] = \"gpio-%d\",\n};\n\nstatic const unsigned int iqs7222_max_cols[IQS7222_NUM_REG_GRPS] = {\n\t[IQS7222_REG_GRP_STAT] = IQS7222_MAX_COLS_STAT,\n\t[IQS7222_REG_GRP_CYCLE] = IQS7222_MAX_COLS_CYCLE,\n\t[IQS7222_REG_GRP_GLBL] = IQS7222_MAX_COLS_GLBL,\n\t[IQS7222_REG_GRP_BTN] = IQS7222_MAX_COLS_BTN,\n\t[IQS7222_REG_GRP_CHAN] = IQS7222_MAX_COLS_CHAN,\n\t[IQS7222_REG_GRP_FILT] = IQS7222_MAX_COLS_FILT,\n\t[IQS7222_REG_GRP_SLDR] = IQS7222_MAX_COLS_SLDR,\n\t[IQS7222_REG_GRP_TPAD] = IQS7222_MAX_COLS_TPAD,\n\t[IQS7222_REG_GRP_GPIO] = IQS7222_MAX_COLS_GPIO,\n\t[IQS7222_REG_GRP_SYS] = IQS7222_MAX_COLS_SYS,\n};\n\nstatic const unsigned int iqs7222_gpio_links[] = { 2, 5, 6, };\n\nstruct iqs7222_event_desc {\n\tconst char *name;\n\tu16 link;\n\tu16 mask;\n\tu16 val;\n\tu16 strict;\n\tu16 enable;\n\tenum iqs7222_reg_key_id reg_key;\n};\n\nstatic const struct iqs7222_event_desc iqs7222_kp_events[] = {\n\t{\n\t\t.name = \"event-prox\",\n\t\t.enable = IQS7222_EVENT_MASK_PROX,\n\t\t.reg_key = IQS7222_REG_KEY_PROX,\n\t},\n\t{\n\t\t.name = \"event-touch\",\n\t\t.enable = IQS7222_EVENT_MASK_TOUCH,\n\t\t.reg_key = IQS7222_REG_KEY_TOUCH,\n\t},\n};\n\nstatic const struct iqs7222_event_desc iqs7222_sl_events[] = {\n\t{ .name = \"event-press\", },\n\t{\n\t\t.name = \"event-tap\",\n\t\t.mask = BIT(0),\n\t\t.val = BIT(0),\n\t\t.enable = BIT(0),\n\t\t.reg_key = IQS7222_REG_KEY_TAP,\n\t},\n\t{\n\t\t.name = \"event-swipe-pos\",\n\t\t.mask = BIT(5) | BIT(1),\n\t\t.val = BIT(1),\n\t\t.enable = BIT(1),\n\t\t.reg_key = IQS7222_REG_KEY_AXIAL,\n\t},\n\t{\n\t\t.name = \"event-swipe-neg\",\n\t\t.mask = BIT(5) | BIT(1),\n\t\t.val = BIT(5) | BIT(1),\n\t\t.enable = BIT(1),\n\t\t.reg_key = IQS7222_REG_KEY_AXIAL,\n\t},\n\t{\n\t\t.name = \"event-flick-pos\",\n\t\t.mask = BIT(5) | BIT(2),\n\t\t.val = BIT(2),\n\t\t.enable = BIT(2),\n\t\t.reg_key = IQS7222_REG_KEY_AXIAL,\n\t},\n\t{\n\t\t.name = \"event-flick-neg\",\n\t\t.mask = BIT(5) | BIT(2),\n\t\t.val = BIT(5) | BIT(2),\n\t\t.enable = BIT(2),\n\t\t.reg_key = IQS7222_REG_KEY_AXIAL,\n\t},\n};\n\nstatic const struct iqs7222_event_desc iqs7222_tp_events[] = {\n\t{\n\t\t.name = \"event-press\",\n\t\t.link = BIT(7),\n\t},\n\t{\n\t\t.name = \"event-tap\",\n\t\t.link = BIT(0),\n\t\t.mask = BIT(0),\n\t\t.val = BIT(0),\n\t\t.enable = BIT(0),\n\t\t.reg_key = IQS7222_REG_KEY_TAP,\n\t},\n\t{\n\t\t.name = \"event-swipe-x-pos\",\n\t\t.link = BIT(2),\n\t\t.mask = BIT(2) | BIT(1),\n\t\t.val = BIT(2),\n\t\t.strict = BIT(4),\n\t\t.enable = BIT(1),\n\t\t.reg_key = IQS7222_REG_KEY_AXIAL,\n\t},\n\t{\n\t\t.name = \"event-swipe-y-pos\",\n\t\t.link = BIT(3),\n\t\t.mask = BIT(3) | BIT(1),\n\t\t.val = BIT(3),\n\t\t.strict = BIT(3),\n\t\t.enable = BIT(1),\n\t\t.reg_key = IQS7222_REG_KEY_AXIAL,\n\t},\n\t{\n\t\t.name = \"event-swipe-x-neg\",\n\t\t.link = BIT(4),\n\t\t.mask = BIT(4) | BIT(1),\n\t\t.val = BIT(4),\n\t\t.strict = BIT(4),\n\t\t.enable = BIT(1),\n\t\t.reg_key = IQS7222_REG_KEY_AXIAL,\n\t},\n\t{\n\t\t.name = \"event-swipe-y-neg\",\n\t\t.link = BIT(5),\n\t\t.mask = BIT(5) | BIT(1),\n\t\t.val = BIT(5),\n\t\t.strict = BIT(3),\n\t\t.enable = BIT(1),\n\t\t.reg_key = IQS7222_REG_KEY_AXIAL,\n\t},\n\t{\n\t\t.name = \"event-flick-x-pos\",\n\t\t.link = BIT(2),\n\t\t.mask = BIT(2) | BIT(1),\n\t\t.val = BIT(2) | BIT(1),\n\t\t.strict = BIT(4),\n\t\t.enable = BIT(2),\n\t\t.reg_key = IQS7222_REG_KEY_AXIAL,\n\t},\n\t{\n\t\t.name = \"event-flick-y-pos\",\n\t\t.link = BIT(3),\n\t\t.mask = BIT(3) | BIT(1),\n\t\t.val = BIT(3) | BIT(1),\n\t\t.strict = BIT(3),\n\t\t.enable = BIT(2),\n\t\t.reg_key = IQS7222_REG_KEY_AXIAL,\n\t},\n\t{\n\t\t.name = \"event-flick-x-neg\",\n\t\t.link = BIT(4),\n\t\t.mask = BIT(4) | BIT(1),\n\t\t.val = BIT(4) | BIT(1),\n\t\t.strict = BIT(4),\n\t\t.enable = BIT(2),\n\t\t.reg_key = IQS7222_REG_KEY_AXIAL,\n\t},\n\t{\n\t\t.name = \"event-flick-y-neg\",\n\t\t.link = BIT(5),\n\t\t.mask = BIT(5) | BIT(1),\n\t\t.val = BIT(5) | BIT(1),\n\t\t.strict = BIT(3),\n\t\t.enable = BIT(2),\n\t\t.reg_key = IQS7222_REG_KEY_AXIAL,\n\t},\n};\n\nstruct iqs7222_reg_grp_desc {\n\tu16 base;\n\tint num_row;\n\tint num_col;\n};\n\nstruct iqs7222_dev_desc {\n\tu16 prod_num;\n\tu16 fw_major;\n\tu16 fw_minor;\n\tu16 sldr_res;\n\tu16 touch_link;\n\tu16 wheel_enable;\n\tint allow_offset;\n\tint event_offset;\n\tint comms_offset;\n\tbool legacy_gesture;\n\tstruct iqs7222_reg_grp_desc reg_grps[IQS7222_NUM_REG_GRPS];\n};\n\nstatic const struct iqs7222_dev_desc iqs7222_devs[] = {\n\t{\n\t\t.prod_num = IQS7222_PROD_NUM_A,\n\t\t.fw_major = 1,\n\t\t.fw_minor = 13,\n\t\t.sldr_res = U8_MAX * 16,\n\t\t.touch_link = 1768,\n\t\t.allow_offset = 9,\n\t\t.event_offset = 10,\n\t\t.comms_offset = 12,\n\t\t.reg_grps = {\n\t\t\t[IQS7222_REG_GRP_STAT] = {\n\t\t\t\t.base = IQS7222_SYS_STATUS,\n\t\t\t\t.num_row = 1,\n\t\t\t\t.num_col = 8,\n\t\t\t},\n\t\t\t[IQS7222_REG_GRP_CYCLE] = {\n\t\t\t\t.base = 0x8000,\n\t\t\t\t.num_row = 7,\n\t\t\t\t.num_col = 3,\n\t\t\t},\n\t\t\t[IQS7222_REG_GRP_GLBL] = {\n\t\t\t\t.base = 0x8700,\n\t\t\t\t.num_row = 1,\n\t\t\t\t.num_col = 3,\n\t\t\t},\n\t\t\t[IQS7222_REG_GRP_BTN] = {\n\t\t\t\t.base = 0x9000,\n\t\t\t\t.num_row = 12,\n\t\t\t\t.num_col = 3,\n\t\t\t},\n\t\t\t[IQS7222_REG_GRP_CHAN] = {\n\t\t\t\t.base = 0xA000,\n\t\t\t\t.num_row = 12,\n\t\t\t\t.num_col = 6,\n\t\t\t},\n\t\t\t[IQS7222_REG_GRP_FILT] = {\n\t\t\t\t.base = 0xAC00,\n\t\t\t\t.num_row = 1,\n\t\t\t\t.num_col = 2,\n\t\t\t},\n\t\t\t[IQS7222_REG_GRP_SLDR] = {\n\t\t\t\t.base = 0xB000,\n\t\t\t\t.num_row = 2,\n\t\t\t\t.num_col = 11,\n\t\t\t},\n\t\t\t[IQS7222_REG_GRP_GPIO] = {\n\t\t\t\t.base = 0xC000,\n\t\t\t\t.num_row = 1,\n\t\t\t\t.num_col = 3,\n\t\t\t},\n\t\t\t[IQS7222_REG_GRP_SYS] = {\n\t\t\t\t.base = IQS7222_SYS_SETUP,\n\t\t\t\t.num_row = 1,\n\t\t\t\t.num_col = 13,\n\t\t\t},\n\t\t},\n\t},\n\t{\n\t\t.prod_num = IQS7222_PROD_NUM_A,\n\t\t.fw_major = 1,\n\t\t.fw_minor = 12,\n\t\t.sldr_res = U8_MAX * 16,\n\t\t.touch_link = 1768,\n\t\t.allow_offset = 9,\n\t\t.event_offset = 10,\n\t\t.comms_offset = 12,\n\t\t.legacy_gesture = true,\n\t\t.reg_grps = {\n\t\t\t[IQS7222_REG_GRP_STAT] = {\n\t\t\t\t.base = IQS7222_SYS_STATUS,\n\t\t\t\t.num_row = 1,\n\t\t\t\t.num_col = 8,\n\t\t\t},\n\t\t\t[IQS7222_REG_GRP_CYCLE] = {\n\t\t\t\t.base = 0x8000,\n\t\t\t\t.num_row = 7,\n\t\t\t\t.num_col = 3,\n\t\t\t},\n\t\t\t[IQS7222_REG_GRP_GLBL] = {\n\t\t\t\t.base = 0x8700,\n\t\t\t\t.num_row = 1,\n\t\t\t\t.num_col = 3,\n\t\t\t},\n\t\t\t[IQS7222_REG_GRP_BTN] = {\n\t\t\t\t.base = 0x9000,\n\t\t\t\t.num_row = 12,\n\t\t\t\t.num_col = 3,\n\t\t\t},\n\t\t\t[IQS7222_REG_GRP_CHAN] = {\n\t\t\t\t.base = 0xA000,\n\t\t\t\t.num_row = 12,\n\t\t\t\t.num_col = 6,\n\t\t\t},\n\t\t\t[IQS7222_REG_GRP_FILT] = {\n\t\t\t\t.base = 0xAC00,\n\t\t\t\t.num_row = 1,\n\t\t\t\t.num_col = 2,\n\t\t\t},\n\t\t\t[IQS7222_REG_GRP_SLDR] = {\n\t\t\t\t.base = 0xB000,\n\t\t\t\t.num_row = 2,\n\t\t\t\t.num_col = 11,\n\t\t\t},\n\t\t\t[IQS7222_REG_GRP_GPIO] = {\n\t\t\t\t.base = 0xC000,\n\t\t\t\t.num_row = 1,\n\t\t\t\t.num_col = 3,\n\t\t\t},\n\t\t\t[IQS7222_REG_GRP_SYS] = {\n\t\t\t\t.base = IQS7222_SYS_SETUP,\n\t\t\t\t.num_row = 1,\n\t\t\t\t.num_col = 13,\n\t\t\t},\n\t\t},\n\t},\n\t{\n\t\t.prod_num = IQS7222_PROD_NUM_B,\n\t\t.fw_major = 1,\n\t\t.fw_minor = 43,\n\t\t.event_offset = 10,\n\t\t.comms_offset = 11,\n\t\t.reg_grps = {\n\t\t\t[IQS7222_REG_GRP_STAT] = {\n\t\t\t\t.base = IQS7222_SYS_STATUS,\n\t\t\t\t.num_row = 1,\n\t\t\t\t.num_col = 6,\n\t\t\t},\n\t\t\t[IQS7222_REG_GRP_CYCLE] = {\n\t\t\t\t.base = 0x8000,\n\t\t\t\t.num_row = 10,\n\t\t\t\t.num_col = 2,\n\t\t\t},\n\t\t\t[IQS7222_REG_GRP_GLBL] = {\n\t\t\t\t.base = 0x8A00,\n\t\t\t\t.num_row = 1,\n\t\t\t\t.num_col = 3,\n\t\t\t},\n\t\t\t[IQS7222_REG_GRP_BTN] = {\n\t\t\t\t.base = 0x9000,\n\t\t\t\t.num_row = 20,\n\t\t\t\t.num_col = 2,\n\t\t\t},\n\t\t\t[IQS7222_REG_GRP_CHAN] = {\n\t\t\t\t.base = 0xB000,\n\t\t\t\t.num_row = 20,\n\t\t\t\t.num_col = 4,\n\t\t\t},\n\t\t\t[IQS7222_REG_GRP_FILT] = {\n\t\t\t\t.base = 0xC400,\n\t\t\t\t.num_row = 1,\n\t\t\t\t.num_col = 2,\n\t\t\t},\n\t\t\t[IQS7222_REG_GRP_SYS] = {\n\t\t\t\t.base = IQS7222_SYS_SETUP,\n\t\t\t\t.num_row = 1,\n\t\t\t\t.num_col = 13,\n\t\t\t},\n\t\t},\n\t},\n\t{\n\t\t.prod_num = IQS7222_PROD_NUM_B,\n\t\t.fw_major = 1,\n\t\t.fw_minor = 27,\n\t\t.reg_grps = {\n\t\t\t[IQS7222_REG_GRP_STAT] = {\n\t\t\t\t.base = IQS7222_SYS_STATUS,\n\t\t\t\t.num_row = 1,\n\t\t\t\t.num_col = 6,\n\t\t\t},\n\t\t\t[IQS7222_REG_GRP_CYCLE] = {\n\t\t\t\t.base = 0x8000,\n\t\t\t\t.num_row = 10,\n\t\t\t\t.num_col = 2,\n\t\t\t},\n\t\t\t[IQS7222_REG_GRP_GLBL] = {\n\t\t\t\t.base = 0x8A00,\n\t\t\t\t.num_row = 1,\n\t\t\t\t.num_col = 3,\n\t\t\t},\n\t\t\t[IQS7222_REG_GRP_BTN] = {\n\t\t\t\t.base = 0x9000,\n\t\t\t\t.num_row = 20,\n\t\t\t\t.num_col = 2,\n\t\t\t},\n\t\t\t[IQS7222_REG_GRP_CHAN] = {\n\t\t\t\t.base = 0xB000,\n\t\t\t\t.num_row = 20,\n\t\t\t\t.num_col = 4,\n\t\t\t},\n\t\t\t[IQS7222_REG_GRP_FILT] = {\n\t\t\t\t.base = 0xC400,\n\t\t\t\t.num_row = 1,\n\t\t\t\t.num_col = 2,\n\t\t\t},\n\t\t\t[IQS7222_REG_GRP_SYS] = {\n\t\t\t\t.base = IQS7222_SYS_SETUP,\n\t\t\t\t.num_row = 1,\n\t\t\t\t.num_col = 10,\n\t\t\t},\n\t\t},\n\t},\n\t{\n\t\t.prod_num = IQS7222_PROD_NUM_C,\n\t\t.fw_major = 2,\n\t\t.fw_minor = 6,\n\t\t.sldr_res = U16_MAX,\n\t\t.touch_link = 1686,\n\t\t.wheel_enable = BIT(3),\n\t\t.event_offset = 9,\n\t\t.comms_offset = 10,\n\t\t.reg_grps = {\n\t\t\t[IQS7222_REG_GRP_STAT] = {\n\t\t\t\t.base = IQS7222_SYS_STATUS,\n\t\t\t\t.num_row = 1,\n\t\t\t\t.num_col = 6,\n\t\t\t},\n\t\t\t[IQS7222_REG_GRP_CYCLE] = {\n\t\t\t\t.base = 0x8000,\n\t\t\t\t.num_row = 5,\n\t\t\t\t.num_col = 3,\n\t\t\t},\n\t\t\t[IQS7222_REG_GRP_GLBL] = {\n\t\t\t\t.base = 0x8500,\n\t\t\t\t.num_row = 1,\n\t\t\t\t.num_col = 3,\n\t\t\t},\n\t\t\t[IQS7222_REG_GRP_BTN] = {\n\t\t\t\t.base = 0x9000,\n\t\t\t\t.num_row = 10,\n\t\t\t\t.num_col = 3,\n\t\t\t},\n\t\t\t[IQS7222_REG_GRP_CHAN] = {\n\t\t\t\t.base = 0xA000,\n\t\t\t\t.num_row = 10,\n\t\t\t\t.num_col = 6,\n\t\t\t},\n\t\t\t[IQS7222_REG_GRP_FILT] = {\n\t\t\t\t.base = 0xAA00,\n\t\t\t\t.num_row = 1,\n\t\t\t\t.num_col = 2,\n\t\t\t},\n\t\t\t[IQS7222_REG_GRP_SLDR] = {\n\t\t\t\t.base = 0xB000,\n\t\t\t\t.num_row = 2,\n\t\t\t\t.num_col = 10,\n\t\t\t},\n\t\t\t[IQS7222_REG_GRP_GPIO] = {\n\t\t\t\t.base = 0xC000,\n\t\t\t\t.num_row = 3,\n\t\t\t\t.num_col = 3,\n\t\t\t},\n\t\t\t[IQS7222_REG_GRP_SYS] = {\n\t\t\t\t.base = IQS7222_SYS_SETUP,\n\t\t\t\t.num_row = 1,\n\t\t\t\t.num_col = 12,\n\t\t\t},\n\t\t},\n\t},\n\t{\n\t\t.prod_num = IQS7222_PROD_NUM_C,\n\t\t.fw_major = 1,\n\t\t.fw_minor = 13,\n\t\t.sldr_res = U16_MAX,\n\t\t.touch_link = 1674,\n\t\t.wheel_enable = BIT(3),\n\t\t.event_offset = 9,\n\t\t.comms_offset = 10,\n\t\t.reg_grps = {\n\t\t\t[IQS7222_REG_GRP_STAT] = {\n\t\t\t\t.base = IQS7222_SYS_STATUS,\n\t\t\t\t.num_row = 1,\n\t\t\t\t.num_col = 6,\n\t\t\t},\n\t\t\t[IQS7222_REG_GRP_CYCLE] = {\n\t\t\t\t.base = 0x8000,\n\t\t\t\t.num_row = 5,\n\t\t\t\t.num_col = 3,\n\t\t\t},\n\t\t\t[IQS7222_REG_GRP_GLBL] = {\n\t\t\t\t.base = 0x8500,\n\t\t\t\t.num_row = 1,\n\t\t\t\t.num_col = 3,\n\t\t\t},\n\t\t\t[IQS7222_REG_GRP_BTN] = {\n\t\t\t\t.base = 0x9000,\n\t\t\t\t.num_row = 10,\n\t\t\t\t.num_col = 3,\n\t\t\t},\n\t\t\t[IQS7222_REG_GRP_CHAN] = {\n\t\t\t\t.base = 0xA000,\n\t\t\t\t.num_row = 10,\n\t\t\t\t.num_col = 6,\n\t\t\t},\n\t\t\t[IQS7222_REG_GRP_FILT] = {\n\t\t\t\t.base = 0xAA00,\n\t\t\t\t.num_row = 1,\n\t\t\t\t.num_col = 2,\n\t\t\t},\n\t\t\t[IQS7222_REG_GRP_SLDR] = {\n\t\t\t\t.base = 0xB000,\n\t\t\t\t.num_row = 2,\n\t\t\t\t.num_col = 10,\n\t\t\t},\n\t\t\t[IQS7222_REG_GRP_GPIO] = {\n\t\t\t\t.base = 0xC000,\n\t\t\t\t.num_row = 1,\n\t\t\t\t.num_col = 3,\n\t\t\t},\n\t\t\t[IQS7222_REG_GRP_SYS] = {\n\t\t\t\t.base = IQS7222_SYS_SETUP,\n\t\t\t\t.num_row = 1,\n\t\t\t\t.num_col = 11,\n\t\t\t},\n\t\t},\n\t},\n\t{\n\t\t.prod_num = IQS7222_PROD_NUM_D,\n\t\t.fw_major = 0,\n\t\t.fw_minor = 37,\n\t\t.touch_link = 1770,\n\t\t.allow_offset = 9,\n\t\t.event_offset = 10,\n\t\t.comms_offset = 11,\n\t\t.reg_grps = {\n\t\t\t[IQS7222_REG_GRP_STAT] = {\n\t\t\t\t.base = IQS7222_SYS_STATUS,\n\t\t\t\t.num_row = 1,\n\t\t\t\t.num_col = 7,\n\t\t\t},\n\t\t\t[IQS7222_REG_GRP_CYCLE] = {\n\t\t\t\t.base = 0x8000,\n\t\t\t\t.num_row = 7,\n\t\t\t\t.num_col = 2,\n\t\t\t},\n\t\t\t[IQS7222_REG_GRP_GLBL] = {\n\t\t\t\t.base = 0x8700,\n\t\t\t\t.num_row = 1,\n\t\t\t\t.num_col = 3,\n\t\t\t},\n\t\t\t[IQS7222_REG_GRP_BTN] = {\n\t\t\t\t.base = 0x9000,\n\t\t\t\t.num_row = 14,\n\t\t\t\t.num_col = 3,\n\t\t\t},\n\t\t\t[IQS7222_REG_GRP_CHAN] = {\n\t\t\t\t.base = 0xA000,\n\t\t\t\t.num_row = 14,\n\t\t\t\t.num_col = 4,\n\t\t\t},\n\t\t\t[IQS7222_REG_GRP_FILT] = {\n\t\t\t\t.base = 0xAE00,\n\t\t\t\t.num_row = 1,\n\t\t\t\t.num_col = 2,\n\t\t\t},\n\t\t\t[IQS7222_REG_GRP_TPAD] = {\n\t\t\t\t.base = 0xB000,\n\t\t\t\t.num_row = 1,\n\t\t\t\t.num_col = 24,\n\t\t\t},\n\t\t\t[IQS7222_REG_GRP_GPIO] = {\n\t\t\t\t.base = 0xC000,\n\t\t\t\t.num_row = 3,\n\t\t\t\t.num_col = 3,\n\t\t\t},\n\t\t\t[IQS7222_REG_GRP_SYS] = {\n\t\t\t\t.base = IQS7222_SYS_SETUP,\n\t\t\t\t.num_row = 1,\n\t\t\t\t.num_col = 12,\n\t\t\t},\n\t\t},\n\t},\n};\n\nstruct iqs7222_prop_desc {\n\tconst char *name;\n\tenum iqs7222_reg_grp_id reg_grp;\n\tenum iqs7222_reg_key_id reg_key;\n\tint reg_offset;\n\tint reg_shift;\n\tint reg_width;\n\tint val_pitch;\n\tint val_min;\n\tint val_max;\n\tbool invert;\n\tconst char *label;\n};\n\nstatic const struct iqs7222_prop_desc iqs7222_props[] = {\n\t{\n\t\t.name = \"azoteq,conv-period\",\n\t\t.reg_grp = IQS7222_REG_GRP_CYCLE,\n\t\t.reg_offset = 0,\n\t\t.reg_shift = 8,\n\t\t.reg_width = 8,\n\t\t.label = \"conversion period\",\n\t},\n\t{\n\t\t.name = \"azoteq,conv-frac\",\n\t\t.reg_grp = IQS7222_REG_GRP_CYCLE,\n\t\t.reg_offset = 0,\n\t\t.reg_shift = 0,\n\t\t.reg_width = 8,\n\t\t.label = \"conversion frequency fractional divider\",\n\t},\n\t{\n\t\t.name = \"azoteq,rx-float-inactive\",\n\t\t.reg_grp = IQS7222_REG_GRP_CYCLE,\n\t\t.reg_offset = 1,\n\t\t.reg_shift = 6,\n\t\t.reg_width = 1,\n\t\t.invert = true,\n\t},\n\t{\n\t\t.name = \"azoteq,dead-time-enable\",\n\t\t.reg_grp = IQS7222_REG_GRP_CYCLE,\n\t\t.reg_offset = 1,\n\t\t.reg_shift = 5,\n\t\t.reg_width = 1,\n\t},\n\t{\n\t\t.name = \"azoteq,tx-freq-fosc\",\n\t\t.reg_grp = IQS7222_REG_GRP_CYCLE,\n\t\t.reg_offset = 1,\n\t\t.reg_shift = 4,\n\t\t.reg_width = 1,\n\t},\n\t{\n\t\t.name = \"azoteq,vbias-enable\",\n\t\t.reg_grp = IQS7222_REG_GRP_CYCLE,\n\t\t.reg_offset = 1,\n\t\t.reg_shift = 3,\n\t\t.reg_width = 1,\n\t},\n\t{\n\t\t.name = \"azoteq,sense-mode\",\n\t\t.reg_grp = IQS7222_REG_GRP_CYCLE,\n\t\t.reg_offset = 1,\n\t\t.reg_shift = 0,\n\t\t.reg_width = 3,\n\t\t.val_max = 3,\n\t\t.label = \"sensing mode\",\n\t},\n\t{\n\t\t.name = \"azoteq,iref-enable\",\n\t\t.reg_grp = IQS7222_REG_GRP_CYCLE,\n\t\t.reg_offset = 2,\n\t\t.reg_shift = 10,\n\t\t.reg_width = 1,\n\t},\n\t{\n\t\t.name = \"azoteq,iref-level\",\n\t\t.reg_grp = IQS7222_REG_GRP_CYCLE,\n\t\t.reg_offset = 2,\n\t\t.reg_shift = 4,\n\t\t.reg_width = 4,\n\t\t.label = \"current reference level\",\n\t},\n\t{\n\t\t.name = \"azoteq,iref-trim\",\n\t\t.reg_grp = IQS7222_REG_GRP_CYCLE,\n\t\t.reg_offset = 2,\n\t\t.reg_shift = 0,\n\t\t.reg_width = 4,\n\t\t.label = \"current reference trim\",\n\t},\n\t{\n\t\t.name = \"azoteq,max-counts\",\n\t\t.reg_grp = IQS7222_REG_GRP_GLBL,\n\t\t.reg_offset = 0,\n\t\t.reg_shift = 13,\n\t\t.reg_width = 2,\n\t\t.label = \"maximum counts\",\n\t},\n\t{\n\t\t.name = \"azoteq,auto-mode\",\n\t\t.reg_grp = IQS7222_REG_GRP_GLBL,\n\t\t.reg_offset = 0,\n\t\t.reg_shift = 2,\n\t\t.reg_width = 2,\n\t\t.label = \"number of conversions\",\n\t},\n\t{\n\t\t.name = \"azoteq,ati-frac-div-fine\",\n\t\t.reg_grp = IQS7222_REG_GRP_GLBL,\n\t\t.reg_offset = 1,\n\t\t.reg_shift = 9,\n\t\t.reg_width = 5,\n\t\t.label = \"ATI fine fractional divider\",\n\t},\n\t{\n\t\t.name = \"azoteq,ati-frac-div-coarse\",\n\t\t.reg_grp = IQS7222_REG_GRP_GLBL,\n\t\t.reg_offset = 1,\n\t\t.reg_shift = 0,\n\t\t.reg_width = 5,\n\t\t.label = \"ATI coarse fractional divider\",\n\t},\n\t{\n\t\t.name = \"azoteq,ati-comp-select\",\n\t\t.reg_grp = IQS7222_REG_GRP_GLBL,\n\t\t.reg_offset = 2,\n\t\t.reg_shift = 0,\n\t\t.reg_width = 10,\n\t\t.label = \"ATI compensation selection\",\n\t},\n\t{\n\t\t.name = \"azoteq,ati-band\",\n\t\t.reg_grp = IQS7222_REG_GRP_CHAN,\n\t\t.reg_offset = 0,\n\t\t.reg_shift = 12,\n\t\t.reg_width = 2,\n\t\t.label = \"ATI band\",\n\t},\n\t{\n\t\t.name = \"azoteq,global-halt\",\n\t\t.reg_grp = IQS7222_REG_GRP_CHAN,\n\t\t.reg_offset = 0,\n\t\t.reg_shift = 11,\n\t\t.reg_width = 1,\n\t},\n\t{\n\t\t.name = \"azoteq,invert-enable\",\n\t\t.reg_grp = IQS7222_REG_GRP_CHAN,\n\t\t.reg_offset = 0,\n\t\t.reg_shift = 10,\n\t\t.reg_width = 1,\n\t},\n\t{\n\t\t.name = \"azoteq,dual-direction\",\n\t\t.reg_grp = IQS7222_REG_GRP_CHAN,\n\t\t.reg_offset = 0,\n\t\t.reg_shift = 9,\n\t\t.reg_width = 1,\n\t},\n\t{\n\t\t.name = \"azoteq,samp-cap-double\",\n\t\t.reg_grp = IQS7222_REG_GRP_CHAN,\n\t\t.reg_offset = 0,\n\t\t.reg_shift = 3,\n\t\t.reg_width = 1,\n\t},\n\t{\n\t\t.name = \"azoteq,vref-half\",\n\t\t.reg_grp = IQS7222_REG_GRP_CHAN,\n\t\t.reg_offset = 0,\n\t\t.reg_shift = 2,\n\t\t.reg_width = 1,\n\t},\n\t{\n\t\t.name = \"azoteq,proj-bias\",\n\t\t.reg_grp = IQS7222_REG_GRP_CHAN,\n\t\t.reg_offset = 0,\n\t\t.reg_shift = 0,\n\t\t.reg_width = 2,\n\t\t.label = \"projected bias current\",\n\t},\n\t{\n\t\t.name = \"azoteq,ati-target\",\n\t\t.reg_grp = IQS7222_REG_GRP_CHAN,\n\t\t.reg_offset = 1,\n\t\t.reg_shift = 8,\n\t\t.reg_width = 8,\n\t\t.val_pitch = 8,\n\t\t.label = \"ATI target\",\n\t},\n\t{\n\t\t.name = \"azoteq,ati-base\",\n\t\t.reg_grp = IQS7222_REG_GRP_CHAN,\n\t\t.reg_offset = 1,\n\t\t.reg_shift = 3,\n\t\t.reg_width = 5,\n\t\t.val_pitch = 16,\n\t\t.label = \"ATI base\",\n\t},\n\t{\n\t\t.name = \"azoteq,ati-mode\",\n\t\t.reg_grp = IQS7222_REG_GRP_CHAN,\n\t\t.reg_offset = 1,\n\t\t.reg_shift = 0,\n\t\t.reg_width = 3,\n\t\t.val_max = 5,\n\t\t.label = \"ATI mode\",\n\t},\n\t{\n\t\t.name = \"azoteq,ati-frac-div-fine\",\n\t\t.reg_grp = IQS7222_REG_GRP_CHAN,\n\t\t.reg_offset = 2,\n\t\t.reg_shift = 9,\n\t\t.reg_width = 5,\n\t\t.label = \"ATI fine fractional divider\",\n\t},\n\t{\n\t\t.name = \"azoteq,ati-frac-mult-coarse\",\n\t\t.reg_grp = IQS7222_REG_GRP_CHAN,\n\t\t.reg_offset = 2,\n\t\t.reg_shift = 5,\n\t\t.reg_width = 4,\n\t\t.label = \"ATI coarse fractional multiplier\",\n\t},\n\t{\n\t\t.name = \"azoteq,ati-frac-div-coarse\",\n\t\t.reg_grp = IQS7222_REG_GRP_CHAN,\n\t\t.reg_offset = 2,\n\t\t.reg_shift = 0,\n\t\t.reg_width = 5,\n\t\t.label = \"ATI coarse fractional divider\",\n\t},\n\t{\n\t\t.name = \"azoteq,ati-comp-div\",\n\t\t.reg_grp = IQS7222_REG_GRP_CHAN,\n\t\t.reg_offset = 3,\n\t\t.reg_shift = 11,\n\t\t.reg_width = 5,\n\t\t.label = \"ATI compensation divider\",\n\t},\n\t{\n\t\t.name = \"azoteq,ati-comp-select\",\n\t\t.reg_grp = IQS7222_REG_GRP_CHAN,\n\t\t.reg_offset = 3,\n\t\t.reg_shift = 0,\n\t\t.reg_width = 10,\n\t\t.label = \"ATI compensation selection\",\n\t},\n\t{\n\t\t.name = \"azoteq,debounce-exit\",\n\t\t.reg_grp = IQS7222_REG_GRP_BTN,\n\t\t.reg_key = IQS7222_REG_KEY_DEBOUNCE,\n\t\t.reg_offset = 0,\n\t\t.reg_shift = 12,\n\t\t.reg_width = 4,\n\t\t.label = \"debounce exit factor\",\n\t},\n\t{\n\t\t.name = \"azoteq,debounce-enter\",\n\t\t.reg_grp = IQS7222_REG_GRP_BTN,\n\t\t.reg_key = IQS7222_REG_KEY_DEBOUNCE,\n\t\t.reg_offset = 0,\n\t\t.reg_shift = 8,\n\t\t.reg_width = 4,\n\t\t.label = \"debounce entrance factor\",\n\t},\n\t{\n\t\t.name = \"azoteq,thresh\",\n\t\t.reg_grp = IQS7222_REG_GRP_BTN,\n\t\t.reg_key = IQS7222_REG_KEY_PROX,\n\t\t.reg_offset = 0,\n\t\t.reg_shift = 0,\n\t\t.reg_width = 8,\n\t\t.val_max = 127,\n\t\t.label = \"threshold\",\n\t},\n\t{\n\t\t.name = \"azoteq,thresh\",\n\t\t.reg_grp = IQS7222_REG_GRP_BTN,\n\t\t.reg_key = IQS7222_REG_KEY_TOUCH,\n\t\t.reg_offset = 1,\n\t\t.reg_shift = 0,\n\t\t.reg_width = 8,\n\t\t.label = \"threshold\",\n\t},\n\t{\n\t\t.name = \"azoteq,hyst\",\n\t\t.reg_grp = IQS7222_REG_GRP_BTN,\n\t\t.reg_key = IQS7222_REG_KEY_TOUCH,\n\t\t.reg_offset = 1,\n\t\t.reg_shift = 8,\n\t\t.reg_width = 8,\n\t\t.label = \"hysteresis\",\n\t},\n\t{\n\t\t.name = \"azoteq,lta-beta-lp\",\n\t\t.reg_grp = IQS7222_REG_GRP_FILT,\n\t\t.reg_offset = 0,\n\t\t.reg_shift = 12,\n\t\t.reg_width = 4,\n\t\t.label = \"low-power mode long-term average beta\",\n\t},\n\t{\n\t\t.name = \"azoteq,lta-beta-np\",\n\t\t.reg_grp = IQS7222_REG_GRP_FILT,\n\t\t.reg_offset = 0,\n\t\t.reg_shift = 8,\n\t\t.reg_width = 4,\n\t\t.label = \"normal-power mode long-term average beta\",\n\t},\n\t{\n\t\t.name = \"azoteq,counts-beta-lp\",\n\t\t.reg_grp = IQS7222_REG_GRP_FILT,\n\t\t.reg_offset = 0,\n\t\t.reg_shift = 4,\n\t\t.reg_width = 4,\n\t\t.label = \"low-power mode counts beta\",\n\t},\n\t{\n\t\t.name = \"azoteq,counts-beta-np\",\n\t\t.reg_grp = IQS7222_REG_GRP_FILT,\n\t\t.reg_offset = 0,\n\t\t.reg_shift = 0,\n\t\t.reg_width = 4,\n\t\t.label = \"normal-power mode counts beta\",\n\t},\n\t{\n\t\t.name = \"azoteq,lta-fast-beta-lp\",\n\t\t.reg_grp = IQS7222_REG_GRP_FILT,\n\t\t.reg_offset = 1,\n\t\t.reg_shift = 4,\n\t\t.reg_width = 4,\n\t\t.label = \"low-power mode long-term average fast beta\",\n\t},\n\t{\n\t\t.name = \"azoteq,lta-fast-beta-np\",\n\t\t.reg_grp = IQS7222_REG_GRP_FILT,\n\t\t.reg_offset = 1,\n\t\t.reg_shift = 0,\n\t\t.reg_width = 4,\n\t\t.label = \"normal-power mode long-term average fast beta\",\n\t},\n\t{\n\t\t.name = \"azoteq,lower-cal\",\n\t\t.reg_grp = IQS7222_REG_GRP_SLDR,\n\t\t.reg_offset = 0,\n\t\t.reg_shift = 8,\n\t\t.reg_width = 8,\n\t\t.label = \"lower calibration\",\n\t},\n\t{\n\t\t.name = \"azoteq,static-beta\",\n\t\t.reg_grp = IQS7222_REG_GRP_SLDR,\n\t\t.reg_key = IQS7222_REG_KEY_NO_WHEEL,\n\t\t.reg_offset = 0,\n\t\t.reg_shift = 6,\n\t\t.reg_width = 1,\n\t},\n\t{\n\t\t.name = \"azoteq,bottom-beta\",\n\t\t.reg_grp = IQS7222_REG_GRP_SLDR,\n\t\t.reg_key = IQS7222_REG_KEY_NO_WHEEL,\n\t\t.reg_offset = 0,\n\t\t.reg_shift = 3,\n\t\t.reg_width = 3,\n\t\t.label = \"bottom beta\",\n\t},\n\t{\n\t\t.name = \"azoteq,static-beta\",\n\t\t.reg_grp = IQS7222_REG_GRP_SLDR,\n\t\t.reg_key = IQS7222_REG_KEY_WHEEL,\n\t\t.reg_offset = 0,\n\t\t.reg_shift = 7,\n\t\t.reg_width = 1,\n\t},\n\t{\n\t\t.name = \"azoteq,bottom-beta\",\n\t\t.reg_grp = IQS7222_REG_GRP_SLDR,\n\t\t.reg_key = IQS7222_REG_KEY_WHEEL,\n\t\t.reg_offset = 0,\n\t\t.reg_shift = 4,\n\t\t.reg_width = 3,\n\t\t.label = \"bottom beta\",\n\t},\n\t{\n\t\t.name = \"azoteq,bottom-speed\",\n\t\t.reg_grp = IQS7222_REG_GRP_SLDR,\n\t\t.reg_offset = 1,\n\t\t.reg_shift = 8,\n\t\t.reg_width = 8,\n\t\t.label = \"bottom speed\",\n\t},\n\t{\n\t\t.name = \"azoteq,upper-cal\",\n\t\t.reg_grp = IQS7222_REG_GRP_SLDR,\n\t\t.reg_offset = 1,\n\t\t.reg_shift = 0,\n\t\t.reg_width = 8,\n\t\t.label = \"upper calibration\",\n\t},\n\t{\n\t\t.name = \"azoteq,gesture-max-ms\",\n\t\t.reg_grp = IQS7222_REG_GRP_SLDR,\n\t\t.reg_key = IQS7222_REG_KEY_TAP,\n\t\t.reg_offset = 9,\n\t\t.reg_shift = 8,\n\t\t.reg_width = 8,\n\t\t.val_pitch = 16,\n\t\t.label = \"maximum gesture time\",\n\t},\n\t{\n\t\t.name = \"azoteq,gesture-max-ms\",\n\t\t.reg_grp = IQS7222_REG_GRP_SLDR,\n\t\t.reg_key = IQS7222_REG_KEY_TAP_LEGACY,\n\t\t.reg_offset = 9,\n\t\t.reg_shift = 8,\n\t\t.reg_width = 8,\n\t\t.val_pitch = 4,\n\t\t.label = \"maximum gesture time\",\n\t},\n\t{\n\t\t.name = \"azoteq,gesture-min-ms\",\n\t\t.reg_grp = IQS7222_REG_GRP_SLDR,\n\t\t.reg_key = IQS7222_REG_KEY_TAP,\n\t\t.reg_offset = 9,\n\t\t.reg_shift = 3,\n\t\t.reg_width = 5,\n\t\t.val_pitch = 16,\n\t\t.label = \"minimum gesture time\",\n\t},\n\t{\n\t\t.name = \"azoteq,gesture-min-ms\",\n\t\t.reg_grp = IQS7222_REG_GRP_SLDR,\n\t\t.reg_key = IQS7222_REG_KEY_TAP_LEGACY,\n\t\t.reg_offset = 9,\n\t\t.reg_shift = 3,\n\t\t.reg_width = 5,\n\t\t.val_pitch = 4,\n\t\t.label = \"minimum gesture time\",\n\t},\n\t{\n\t\t.name = \"azoteq,gesture-dist\",\n\t\t.reg_grp = IQS7222_REG_GRP_SLDR,\n\t\t.reg_key = IQS7222_REG_KEY_AXIAL,\n\t\t.reg_offset = 10,\n\t\t.reg_shift = 8,\n\t\t.reg_width = 8,\n\t\t.val_pitch = 16,\n\t\t.label = \"gesture distance\",\n\t},\n\t{\n\t\t.name = \"azoteq,gesture-dist\",\n\t\t.reg_grp = IQS7222_REG_GRP_SLDR,\n\t\t.reg_key = IQS7222_REG_KEY_AXIAL_LEGACY,\n\t\t.reg_offset = 10,\n\t\t.reg_shift = 8,\n\t\t.reg_width = 8,\n\t\t.val_pitch = 16,\n\t\t.label = \"gesture distance\",\n\t},\n\t{\n\t\t.name = \"azoteq,gesture-max-ms\",\n\t\t.reg_grp = IQS7222_REG_GRP_SLDR,\n\t\t.reg_key = IQS7222_REG_KEY_AXIAL,\n\t\t.reg_offset = 10,\n\t\t.reg_shift = 0,\n\t\t.reg_width = 8,\n\t\t.val_pitch = 16,\n\t\t.label = \"maximum gesture time\",\n\t},\n\t{\n\t\t.name = \"azoteq,gesture-max-ms\",\n\t\t.reg_grp = IQS7222_REG_GRP_SLDR,\n\t\t.reg_key = IQS7222_REG_KEY_AXIAL_LEGACY,\n\t\t.reg_offset = 10,\n\t\t.reg_shift = 0,\n\t\t.reg_width = 8,\n\t\t.val_pitch = 4,\n\t\t.label = \"maximum gesture time\",\n\t},\n\t{\n\t\t.name = \"azoteq,num-rows\",\n\t\t.reg_grp = IQS7222_REG_GRP_TPAD,\n\t\t.reg_offset = 0,\n\t\t.reg_shift = 4,\n\t\t.reg_width = 4,\n\t\t.val_min = 1,\n\t\t.val_max = 12,\n\t\t.label = \"number of rows\",\n\t},\n\t{\n\t\t.name = \"azoteq,num-cols\",\n\t\t.reg_grp = IQS7222_REG_GRP_TPAD,\n\t\t.reg_offset = 0,\n\t\t.reg_shift = 0,\n\t\t.reg_width = 4,\n\t\t.val_min = 1,\n\t\t.val_max = 12,\n\t\t.label = \"number of columns\",\n\t},\n\t{\n\t\t.name = \"azoteq,lower-cal-y\",\n\t\t.reg_grp = IQS7222_REG_GRP_TPAD,\n\t\t.reg_offset = 1,\n\t\t.reg_shift = 8,\n\t\t.reg_width = 8,\n\t\t.label = \"lower vertical calibration\",\n\t},\n\t{\n\t\t.name = \"azoteq,lower-cal-x\",\n\t\t.reg_grp = IQS7222_REG_GRP_TPAD,\n\t\t.reg_offset = 1,\n\t\t.reg_shift = 0,\n\t\t.reg_width = 8,\n\t\t.label = \"lower horizontal calibration\",\n\t},\n\t{\n\t\t.name = \"azoteq,upper-cal-y\",\n\t\t.reg_grp = IQS7222_REG_GRP_TPAD,\n\t\t.reg_offset = 2,\n\t\t.reg_shift = 8,\n\t\t.reg_width = 8,\n\t\t.label = \"upper vertical calibration\",\n\t},\n\t{\n\t\t.name = \"azoteq,upper-cal-x\",\n\t\t.reg_grp = IQS7222_REG_GRP_TPAD,\n\t\t.reg_offset = 2,\n\t\t.reg_shift = 0,\n\t\t.reg_width = 8,\n\t\t.label = \"upper horizontal calibration\",\n\t},\n\t{\n\t\t.name = \"azoteq,top-speed\",\n\t\t.reg_grp = IQS7222_REG_GRP_TPAD,\n\t\t.reg_offset = 3,\n\t\t.reg_shift = 8,\n\t\t.reg_width = 8,\n\t\t.val_pitch = 4,\n\t\t.label = \"top speed\",\n\t},\n\t{\n\t\t.name = \"azoteq,bottom-speed\",\n\t\t.reg_grp = IQS7222_REG_GRP_TPAD,\n\t\t.reg_offset = 3,\n\t\t.reg_shift = 0,\n\t\t.reg_width = 8,\n\t\t.label = \"bottom speed\",\n\t},\n\t{\n\t\t.name = \"azoteq,gesture-min-ms\",\n\t\t.reg_grp = IQS7222_REG_GRP_TPAD,\n\t\t.reg_key = IQS7222_REG_KEY_TAP,\n\t\t.reg_offset = 20,\n\t\t.reg_shift = 8,\n\t\t.reg_width = 8,\n\t\t.val_pitch = 16,\n\t\t.label = \"minimum gesture time\",\n\t},\n\t{\n\t\t.name = \"azoteq,gesture-max-ms\",\n\t\t.reg_grp = IQS7222_REG_GRP_TPAD,\n\t\t.reg_key = IQS7222_REG_KEY_AXIAL,\n\t\t.reg_offset = 21,\n\t\t.reg_shift = 8,\n\t\t.reg_width = 8,\n\t\t.val_pitch = 16,\n\t\t.label = \"maximum gesture time\",\n\t},\n\t{\n\t\t.name = \"azoteq,gesture-max-ms\",\n\t\t.reg_grp = IQS7222_REG_GRP_TPAD,\n\t\t.reg_key = IQS7222_REG_KEY_TAP,\n\t\t.reg_offset = 21,\n\t\t.reg_shift = 0,\n\t\t.reg_width = 8,\n\t\t.val_pitch = 16,\n\t\t.label = \"maximum gesture time\",\n\t},\n\t{\n\t\t.name = \"azoteq,gesture-dist\",\n\t\t.reg_grp = IQS7222_REG_GRP_TPAD,\n\t\t.reg_key = IQS7222_REG_KEY_TAP,\n\t\t.reg_offset = 22,\n\t\t.reg_shift = 0,\n\t\t.reg_width = 16,\n\t\t.label = \"gesture distance\",\n\t},\n\t{\n\t\t.name = \"azoteq,gesture-dist\",\n\t\t.reg_grp = IQS7222_REG_GRP_TPAD,\n\t\t.reg_key = IQS7222_REG_KEY_AXIAL,\n\t\t.reg_offset = 23,\n\t\t.reg_shift = 0,\n\t\t.reg_width = 16,\n\t\t.label = \"gesture distance\",\n\t},\n\t{\n\t\t.name = \"drive-open-drain\",\n\t\t.reg_grp = IQS7222_REG_GRP_GPIO,\n\t\t.reg_offset = 0,\n\t\t.reg_shift = 1,\n\t\t.reg_width = 1,\n\t},\n\t{\n\t\t.name = \"azoteq,timeout-ati-ms\",\n\t\t.reg_grp = IQS7222_REG_GRP_SYS,\n\t\t.reg_offset = 1,\n\t\t.reg_shift = 0,\n\t\t.reg_width = 16,\n\t\t.val_pitch = 500,\n\t\t.label = \"ATI error timeout\",\n\t},\n\t{\n\t\t.name = \"azoteq,rate-ati-ms\",\n\t\t.reg_grp = IQS7222_REG_GRP_SYS,\n\t\t.reg_offset = 2,\n\t\t.reg_shift = 0,\n\t\t.reg_width = 16,\n\t\t.label = \"ATI report rate\",\n\t},\n\t{\n\t\t.name = \"azoteq,timeout-np-ms\",\n\t\t.reg_grp = IQS7222_REG_GRP_SYS,\n\t\t.reg_offset = 3,\n\t\t.reg_shift = 0,\n\t\t.reg_width = 16,\n\t\t.label = \"normal-power mode timeout\",\n\t},\n\t{\n\t\t.name = \"azoteq,rate-np-ms\",\n\t\t.reg_grp = IQS7222_REG_GRP_SYS,\n\t\t.reg_offset = 4,\n\t\t.reg_shift = 0,\n\t\t.reg_width = 16,\n\t\t.val_max = 3000,\n\t\t.label = \"normal-power mode report rate\",\n\t},\n\t{\n\t\t.name = \"azoteq,timeout-lp-ms\",\n\t\t.reg_grp = IQS7222_REG_GRP_SYS,\n\t\t.reg_offset = 5,\n\t\t.reg_shift = 0,\n\t\t.reg_width = 16,\n\t\t.label = \"low-power mode timeout\",\n\t},\n\t{\n\t\t.name = \"azoteq,rate-lp-ms\",\n\t\t.reg_grp = IQS7222_REG_GRP_SYS,\n\t\t.reg_offset = 6,\n\t\t.reg_shift = 0,\n\t\t.reg_width = 16,\n\t\t.val_max = 3000,\n\t\t.label = \"low-power mode report rate\",\n\t},\n\t{\n\t\t.name = \"azoteq,timeout-ulp-ms\",\n\t\t.reg_grp = IQS7222_REG_GRP_SYS,\n\t\t.reg_offset = 7,\n\t\t.reg_shift = 0,\n\t\t.reg_width = 16,\n\t\t.label = \"ultra-low-power mode timeout\",\n\t},\n\t{\n\t\t.name = \"azoteq,rate-ulp-ms\",\n\t\t.reg_grp = IQS7222_REG_GRP_SYS,\n\t\t.reg_offset = 8,\n\t\t.reg_shift = 0,\n\t\t.reg_width = 16,\n\t\t.val_max = 3000,\n\t\t.label = \"ultra-low-power mode report rate\",\n\t},\n};\n\nstruct iqs7222_private {\n\tconst struct iqs7222_dev_desc *dev_desc;\n\tstruct gpio_desc *reset_gpio;\n\tstruct gpio_desc *irq_gpio;\n\tstruct i2c_client *client;\n\tstruct input_dev *keypad;\n\tstruct touchscreen_properties prop;\n\tunsigned int kp_type[IQS7222_MAX_CHAN][ARRAY_SIZE(iqs7222_kp_events)];\n\tunsigned int kp_code[IQS7222_MAX_CHAN][ARRAY_SIZE(iqs7222_kp_events)];\n\tunsigned int sl_code[IQS7222_MAX_SLDR][ARRAY_SIZE(iqs7222_sl_events)];\n\tunsigned int sl_axis[IQS7222_MAX_SLDR];\n\tunsigned int tp_code[ARRAY_SIZE(iqs7222_tp_events)];\n\tu16 cycle_setup[IQS7222_MAX_CHAN / 2][IQS7222_MAX_COLS_CYCLE];\n\tu16 glbl_setup[IQS7222_MAX_COLS_GLBL];\n\tu16 btn_setup[IQS7222_MAX_CHAN][IQS7222_MAX_COLS_BTN];\n\tu16 chan_setup[IQS7222_MAX_CHAN][IQS7222_MAX_COLS_CHAN];\n\tu16 filt_setup[IQS7222_MAX_COLS_FILT];\n\tu16 sldr_setup[IQS7222_MAX_SLDR][IQS7222_MAX_COLS_SLDR];\n\tu16 tpad_setup[IQS7222_MAX_COLS_TPAD];\n\tu16 gpio_setup[ARRAY_SIZE(iqs7222_gpio_links)][IQS7222_MAX_COLS_GPIO];\n\tu16 sys_setup[IQS7222_MAX_COLS_SYS];\n};\n\nstatic u16 *iqs7222_setup(struct iqs7222_private *iqs7222,\n\t\t\t  enum iqs7222_reg_grp_id reg_grp, int row)\n{\n\tswitch (reg_grp) {\n\tcase IQS7222_REG_GRP_CYCLE:\n\t\treturn iqs7222->cycle_setup[row];\n\n\tcase IQS7222_REG_GRP_GLBL:\n\t\treturn iqs7222->glbl_setup;\n\n\tcase IQS7222_REG_GRP_BTN:\n\t\treturn iqs7222->btn_setup[row];\n\n\tcase IQS7222_REG_GRP_CHAN:\n\t\treturn iqs7222->chan_setup[row];\n\n\tcase IQS7222_REG_GRP_FILT:\n\t\treturn iqs7222->filt_setup;\n\n\tcase IQS7222_REG_GRP_SLDR:\n\t\treturn iqs7222->sldr_setup[row];\n\n\tcase IQS7222_REG_GRP_TPAD:\n\t\treturn iqs7222->tpad_setup;\n\n\tcase IQS7222_REG_GRP_GPIO:\n\t\treturn iqs7222->gpio_setup[row];\n\n\tcase IQS7222_REG_GRP_SYS:\n\t\treturn iqs7222->sys_setup;\n\n\tdefault:\n\t\treturn NULL;\n\t}\n}\n\nstatic int iqs7222_irq_poll(struct iqs7222_private *iqs7222, u16 timeout_ms)\n{\n\tktime_t irq_timeout = ktime_add_ms(ktime_get(), timeout_ms);\n\tint ret;\n\n\tdo {\n\t\tusleep_range(1000, 1100);\n\n\t\tret = gpiod_get_value_cansleep(iqs7222->irq_gpio);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\telse if (ret > 0)\n\t\t\treturn 0;\n\t} while (ktime_compare(ktime_get(), irq_timeout) < 0);\n\n\treturn -EBUSY;\n}\n\nstatic int iqs7222_hard_reset(struct iqs7222_private *iqs7222)\n{\n\tstruct i2c_client *client = iqs7222->client;\n\tint error;\n\n\tif (!iqs7222->reset_gpio)\n\t\treturn 0;\n\n\tgpiod_set_value_cansleep(iqs7222->reset_gpio, 1);\n\tusleep_range(1000, 1100);\n\n\tgpiod_set_value_cansleep(iqs7222->reset_gpio, 0);\n\n\terror = iqs7222_irq_poll(iqs7222, IQS7222_RESET_TIMEOUT_MS);\n\tif (error)\n\t\tdev_err(&client->dev, \"Failed to reset device: %d\\n\", error);\n\n\treturn error;\n}\n\nstatic int iqs7222_force_comms(struct iqs7222_private *iqs7222)\n{\n\tu8 msg_buf[] = { 0xFF, };\n\tint ret;\n\n\t \n\tret = gpiod_get_value_cansleep(iqs7222->irq_gpio);\n\tif (ret < 0)\n\t\treturn ret;\n\telse if (ret > 0)\n\t\treturn 0;\n\n\tret = i2c_master_send(iqs7222->client, msg_buf, sizeof(msg_buf));\n\tif (ret < (int)sizeof(msg_buf)) {\n\t\tif (ret >= 0)\n\t\t\tret = -EIO;\n\n\t\t \n\t\tmsleep(IQS7222_COMMS_RETRY_MS);\n\t\treturn ret;\n\t}\n\n\treturn iqs7222_irq_poll(iqs7222, IQS7222_COMMS_TIMEOUT_MS);\n}\n\nstatic int iqs7222_read_burst(struct iqs7222_private *iqs7222,\n\t\t\t      u16 reg, void *val, u16 num_val)\n{\n\tu8 reg_buf[sizeof(__be16)];\n\tint ret, i;\n\tstruct i2c_client *client = iqs7222->client;\n\tstruct i2c_msg msg[] = {\n\t\t{\n\t\t\t.addr = client->addr,\n\t\t\t.flags = 0,\n\t\t\t.len = reg > U8_MAX ? sizeof(reg) : sizeof(u8),\n\t\t\t.buf = reg_buf,\n\t\t},\n\t\t{\n\t\t\t.addr = client->addr,\n\t\t\t.flags = I2C_M_RD,\n\t\t\t.len = num_val * sizeof(__le16),\n\t\t\t.buf = (u8 *)val,\n\t\t},\n\t};\n\n\tif (reg > U8_MAX)\n\t\tput_unaligned_be16(reg, reg_buf);\n\telse\n\t\t*reg_buf = (u8)reg;\n\n\t \n\tfor (i = 0; i < IQS7222_NUM_RETRIES; i++) {\n\t\tret = iqs7222_force_comms(iqs7222);\n\t\tif (ret < 0)\n\t\t\tcontinue;\n\n\t\tret = i2c_transfer(client->adapter, msg, ARRAY_SIZE(msg));\n\t\tif (ret < (int)ARRAY_SIZE(msg)) {\n\t\t\tif (ret >= 0)\n\t\t\t\tret = -EIO;\n\n\t\t\tmsleep(IQS7222_COMMS_RETRY_MS);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (get_unaligned_le16(msg[1].buf) == IQS7222_COMMS_ERROR) {\n\t\t\tret = -ENODATA;\n\t\t\tcontinue;\n\t\t}\n\n\t\tret = 0;\n\t\tbreak;\n\t}\n\n\t \n\tusleep_range(50, 100);\n\n\tif (ret < 0)\n\t\tdev_err(&client->dev,\n\t\t\t\"Failed to read from address 0x%04X: %d\\n\", reg, ret);\n\n\treturn ret;\n}\n\nstatic int iqs7222_read_word(struct iqs7222_private *iqs7222, u16 reg, u16 *val)\n{\n\t__le16 val_buf;\n\tint error;\n\n\terror = iqs7222_read_burst(iqs7222, reg, &val_buf, 1);\n\tif (error)\n\t\treturn error;\n\n\t*val = le16_to_cpu(val_buf);\n\n\treturn 0;\n}\n\nstatic int iqs7222_write_burst(struct iqs7222_private *iqs7222,\n\t\t\t       u16 reg, const void *val, u16 num_val)\n{\n\tint reg_len = reg > U8_MAX ? sizeof(reg) : sizeof(u8);\n\tint val_len = num_val * sizeof(__le16);\n\tint msg_len = reg_len + val_len;\n\tint ret, i;\n\tstruct i2c_client *client = iqs7222->client;\n\tu8 *msg_buf;\n\n\tmsg_buf = kzalloc(msg_len, GFP_KERNEL);\n\tif (!msg_buf)\n\t\treturn -ENOMEM;\n\n\tif (reg > U8_MAX)\n\t\tput_unaligned_be16(reg, msg_buf);\n\telse\n\t\t*msg_buf = (u8)reg;\n\n\tmemcpy(msg_buf + reg_len, val, val_len);\n\n\t \n\tfor (i = 0; i < IQS7222_NUM_RETRIES; i++) {\n\t\tret = iqs7222_force_comms(iqs7222);\n\t\tif (ret < 0)\n\t\t\tcontinue;\n\n\t\tret = i2c_master_send(client, msg_buf, msg_len);\n\t\tif (ret < msg_len) {\n\t\t\tif (ret >= 0)\n\t\t\t\tret = -EIO;\n\n\t\t\tmsleep(IQS7222_COMMS_RETRY_MS);\n\t\t\tcontinue;\n\t\t}\n\n\t\tret = 0;\n\t\tbreak;\n\t}\n\n\tkfree(msg_buf);\n\n\tusleep_range(50, 100);\n\n\tif (ret < 0)\n\t\tdev_err(&client->dev,\n\t\t\t\"Failed to write to address 0x%04X: %d\\n\", reg, ret);\n\n\treturn ret;\n}\n\nstatic int iqs7222_write_word(struct iqs7222_private *iqs7222, u16 reg, u16 val)\n{\n\t__le16 val_buf = cpu_to_le16(val);\n\n\treturn iqs7222_write_burst(iqs7222, reg, &val_buf, 1);\n}\n\nstatic int iqs7222_ati_trigger(struct iqs7222_private *iqs7222)\n{\n\tstruct i2c_client *client = iqs7222->client;\n\tktime_t ati_timeout;\n\tu16 sys_status = 0;\n\tu16 sys_setup;\n\tint error, i;\n\n\t \n\terror = iqs7222_read_word(iqs7222, IQS7222_SYS_SETUP, &sys_setup);\n\tif (error)\n\t\treturn error;\n\n\tfor (i = 0; i < IQS7222_NUM_RETRIES; i++) {\n\t\t \n\t\terror = iqs7222_write_word(iqs7222, IQS7222_SYS_SETUP,\n\t\t\t\t\t   sys_setup |\n\t\t\t\t\t   IQS7222_SYS_SETUP_REDO_ATI);\n\t\tif (error)\n\t\t\treturn error;\n\n\t\tati_timeout = ktime_add_ms(ktime_get(), IQS7222_ATI_TIMEOUT_MS);\n\n\t\tdo {\n\t\t\terror = iqs7222_irq_poll(iqs7222,\n\t\t\t\t\t\t IQS7222_COMMS_TIMEOUT_MS);\n\t\t\tif (error)\n\t\t\t\tcontinue;\n\n\t\t\terror = iqs7222_read_word(iqs7222, IQS7222_SYS_STATUS,\n\t\t\t\t\t\t  &sys_status);\n\t\t\tif (error)\n\t\t\t\treturn error;\n\n\t\t\tif (sys_status & IQS7222_SYS_STATUS_RESET)\n\t\t\t\treturn 0;\n\n\t\t\tif (sys_status & IQS7222_SYS_STATUS_ATI_ERROR)\n\t\t\t\tbreak;\n\n\t\t\tif (sys_status & IQS7222_SYS_STATUS_ATI_ACTIVE)\n\t\t\t\tcontinue;\n\n\t\t\t \n\t\t\tsys_setup |= test_bit(EV_ABS, iqs7222->keypad->evbit)\n\t\t\t\t   ? IQS7222_SYS_SETUP_INTF_MODE_TOUCH\n\t\t\t\t   : IQS7222_SYS_SETUP_INTF_MODE_EVENT;\n\t\t\tsys_setup |= IQS7222_SYS_SETUP_PWR_MODE_AUTO;\n\n\t\t\treturn iqs7222_write_word(iqs7222, IQS7222_SYS_SETUP,\n\t\t\t\t\t\t  sys_setup);\n\t\t} while (ktime_compare(ktime_get(), ati_timeout) < 0);\n\n\t\tdev_err(&client->dev,\n\t\t\t\"ATI attempt %d of %d failed with status 0x%02X, %s\\n\",\n\t\t\ti + 1, IQS7222_NUM_RETRIES, (u8)sys_status,\n\t\t\ti + 1 < IQS7222_NUM_RETRIES ? \"retrying\" : \"stopping\");\n\t}\n\n\treturn -ETIMEDOUT;\n}\n\nstatic int iqs7222_dev_init(struct iqs7222_private *iqs7222, int dir)\n{\n\tconst struct iqs7222_dev_desc *dev_desc = iqs7222->dev_desc;\n\tint comms_offset = dev_desc->comms_offset;\n\tint error, i, j, k;\n\n\t \n\tif (dir == WRITE) {\n\t\tu16 reg = dev_desc->reg_grps[IQS7222_REG_GRP_FILT].base + 1;\n\t\tu16 filt_setup;\n\n\t\terror = iqs7222_write_word(iqs7222, IQS7222_SYS_SETUP,\n\t\t\t\t\t   iqs7222->sys_setup[0] |\n\t\t\t\t\t   IQS7222_SYS_SETUP_ACK_RESET);\n\t\tif (error)\n\t\t\treturn error;\n\n\t\terror = iqs7222_read_word(iqs7222, reg, &filt_setup);\n\t\tif (error)\n\t\t\treturn error;\n\n\t\tiqs7222->filt_setup[1] &= GENMASK(7, 0);\n\t\tiqs7222->filt_setup[1] |= (filt_setup & ~GENMASK(7, 0));\n\t}\n\n\t \n\tif (comms_offset) {\n\t\tu16 comms_setup;\n\n\t\terror = iqs7222_read_word(iqs7222,\n\t\t\t\t\t  IQS7222_SYS_SETUP + comms_offset,\n\t\t\t\t\t  &comms_setup);\n\t\tif (error)\n\t\t\treturn error;\n\n\t\terror = iqs7222_write_word(iqs7222,\n\t\t\t\t\t   IQS7222_SYS_SETUP + comms_offset,\n\t\t\t\t\t   comms_setup | IQS7222_COMMS_HOLD);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\tfor (i = 0; i < IQS7222_NUM_REG_GRPS; i++) {\n\t\tint num_row = dev_desc->reg_grps[i].num_row;\n\t\tint num_col = dev_desc->reg_grps[i].num_col;\n\t\tu16 reg = dev_desc->reg_grps[i].base;\n\t\t__le16 *val_buf;\n\t\tu16 *val;\n\n\t\tif (!num_col)\n\t\t\tcontinue;\n\n\t\tval = iqs7222_setup(iqs7222, i, 0);\n\t\tif (!val)\n\t\t\tcontinue;\n\n\t\tval_buf = kcalloc(num_col, sizeof(__le16), GFP_KERNEL);\n\t\tif (!val_buf)\n\t\t\treturn -ENOMEM;\n\n\t\tfor (j = 0; j < num_row; j++) {\n\t\t\tswitch (dir) {\n\t\t\tcase READ:\n\t\t\t\terror = iqs7222_read_burst(iqs7222, reg,\n\t\t\t\t\t\t\t   val_buf, num_col);\n\t\t\t\tfor (k = 0; k < num_col; k++)\n\t\t\t\t\tval[k] = le16_to_cpu(val_buf[k]);\n\t\t\t\tbreak;\n\n\t\t\tcase WRITE:\n\t\t\t\tfor (k = 0; k < num_col; k++)\n\t\t\t\t\tval_buf[k] = cpu_to_le16(val[k]);\n\t\t\t\terror = iqs7222_write_burst(iqs7222, reg,\n\t\t\t\t\t\t\t    val_buf, num_col);\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\terror = -EINVAL;\n\t\t\t}\n\n\t\t\tif (error)\n\t\t\t\tbreak;\n\n\t\t\treg += IQS7222_REG_OFFSET;\n\t\t\tval += iqs7222_max_cols[i];\n\t\t}\n\n\t\tkfree(val_buf);\n\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\tif (comms_offset) {\n\t\tu16 comms_setup;\n\n\t\terror = iqs7222_read_word(iqs7222,\n\t\t\t\t\t  IQS7222_SYS_SETUP + comms_offset,\n\t\t\t\t\t  &comms_setup);\n\t\tif (error)\n\t\t\treturn error;\n\n\t\terror = iqs7222_write_word(iqs7222,\n\t\t\t\t\t   IQS7222_SYS_SETUP + comms_offset,\n\t\t\t\t\t   comms_setup & ~IQS7222_COMMS_HOLD);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\tif (dir == READ) {\n\t\tiqs7222->sys_setup[0] &= ~IQS7222_SYS_SETUP_INTF_MODE_MASK;\n\t\tiqs7222->sys_setup[0] &= ~IQS7222_SYS_SETUP_PWR_MODE_MASK;\n\t\treturn 0;\n\t}\n\n\treturn iqs7222_ati_trigger(iqs7222);\n}\n\nstatic int iqs7222_dev_info(struct iqs7222_private *iqs7222)\n{\n\tstruct i2c_client *client = iqs7222->client;\n\tbool prod_num_valid = false;\n\t__le16 dev_id[3];\n\tint error, i;\n\n\terror = iqs7222_read_burst(iqs7222, IQS7222_PROD_NUM, dev_id,\n\t\t\t\t   ARRAY_SIZE(dev_id));\n\tif (error)\n\t\treturn error;\n\n\tfor (i = 0; i < ARRAY_SIZE(iqs7222_devs); i++) {\n\t\tif (le16_to_cpu(dev_id[0]) != iqs7222_devs[i].prod_num)\n\t\t\tcontinue;\n\n\t\tprod_num_valid = true;\n\n\t\tif (le16_to_cpu(dev_id[1]) < iqs7222_devs[i].fw_major)\n\t\t\tcontinue;\n\n\t\tif (le16_to_cpu(dev_id[2]) < iqs7222_devs[i].fw_minor)\n\t\t\tcontinue;\n\n\t\tiqs7222->dev_desc = &iqs7222_devs[i];\n\t\treturn 0;\n\t}\n\n\tif (prod_num_valid)\n\t\tdev_err(&client->dev, \"Unsupported firmware revision: %u.%u\\n\",\n\t\t\tle16_to_cpu(dev_id[1]), le16_to_cpu(dev_id[2]));\n\telse\n\t\tdev_err(&client->dev, \"Unrecognized product number: %u\\n\",\n\t\t\tle16_to_cpu(dev_id[0]));\n\n\treturn -EINVAL;\n}\n\nstatic int iqs7222_gpio_select(struct iqs7222_private *iqs7222,\n\t\t\t       struct fwnode_handle *child_node,\n\t\t\t       int child_enable, u16 child_link)\n{\n\tconst struct iqs7222_dev_desc *dev_desc = iqs7222->dev_desc;\n\tstruct i2c_client *client = iqs7222->client;\n\tint num_gpio = dev_desc->reg_grps[IQS7222_REG_GRP_GPIO].num_row;\n\tint error, count, i;\n\tunsigned int gpio_sel[ARRAY_SIZE(iqs7222_gpio_links)];\n\n\tif (!num_gpio)\n\t\treturn 0;\n\n\tif (!fwnode_property_present(child_node, \"azoteq,gpio-select\"))\n\t\treturn 0;\n\n\tcount = fwnode_property_count_u32(child_node, \"azoteq,gpio-select\");\n\tif (count > num_gpio) {\n\t\tdev_err(&client->dev, \"Invalid number of %s GPIOs\\n\",\n\t\t\tfwnode_get_name(child_node));\n\t\treturn -EINVAL;\n\t} else if (count < 0) {\n\t\tdev_err(&client->dev, \"Failed to count %s GPIOs: %d\\n\",\n\t\t\tfwnode_get_name(child_node), count);\n\t\treturn count;\n\t}\n\n\terror = fwnode_property_read_u32_array(child_node,\n\t\t\t\t\t       \"azoteq,gpio-select\",\n\t\t\t\t\t       gpio_sel, count);\n\tif (error) {\n\t\tdev_err(&client->dev, \"Failed to read %s GPIOs: %d\\n\",\n\t\t\tfwnode_get_name(child_node), error);\n\t\treturn error;\n\t}\n\n\tfor (i = 0; i < count; i++) {\n\t\tu16 *gpio_setup;\n\n\t\tif (gpio_sel[i] >= num_gpio) {\n\t\t\tdev_err(&client->dev, \"Invalid %s GPIO: %u\\n\",\n\t\t\t\tfwnode_get_name(child_node), gpio_sel[i]);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tgpio_setup = iqs7222->gpio_setup[gpio_sel[i]];\n\n\t\tif (gpio_setup[2] && child_link != gpio_setup[2]) {\n\t\t\tdev_err(&client->dev,\n\t\t\t\t\"Conflicting GPIO %u event types\\n\",\n\t\t\t\tgpio_sel[i]);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tgpio_setup[0] |= IQS7222_GPIO_SETUP_0_GPIO_EN;\n\t\tgpio_setup[1] |= child_enable;\n\t\tgpio_setup[2] = child_link;\n\t}\n\n\treturn 0;\n}\n\nstatic int iqs7222_parse_props(struct iqs7222_private *iqs7222,\n\t\t\t       struct fwnode_handle *reg_grp_node,\n\t\t\t       int reg_grp_index,\n\t\t\t       enum iqs7222_reg_grp_id reg_grp,\n\t\t\t       enum iqs7222_reg_key_id reg_key)\n{\n\tu16 *setup = iqs7222_setup(iqs7222, reg_grp, reg_grp_index);\n\tstruct i2c_client *client = iqs7222->client;\n\tint i;\n\n\tif (!setup)\n\t\treturn 0;\n\n\tfor (i = 0; i < ARRAY_SIZE(iqs7222_props); i++) {\n\t\tconst char *name = iqs7222_props[i].name;\n\t\tint reg_offset = iqs7222_props[i].reg_offset;\n\t\tint reg_shift = iqs7222_props[i].reg_shift;\n\t\tint reg_width = iqs7222_props[i].reg_width;\n\t\tint val_pitch = iqs7222_props[i].val_pitch ? : 1;\n\t\tint val_min = iqs7222_props[i].val_min;\n\t\tint val_max = iqs7222_props[i].val_max;\n\t\tbool invert = iqs7222_props[i].invert;\n\t\tconst char *label = iqs7222_props[i].label ? : name;\n\t\tunsigned int val;\n\t\tint error;\n\n\t\tif (iqs7222_props[i].reg_grp != reg_grp ||\n\t\t    iqs7222_props[i].reg_key != reg_key)\n\t\t\tcontinue;\n\n\t\t \n\t\tif (reg_width == 1) {\n\t\t\tif (invert)\n\t\t\t\tsetup[reg_offset] |= BIT(reg_shift);\n\t\t\telse\n\t\t\t\tsetup[reg_offset] &= ~BIT(reg_shift);\n\t\t}\n\n\t\tif (!fwnode_property_present(reg_grp_node, name))\n\t\t\tcontinue;\n\n\t\tif (reg_width == 1) {\n\t\t\tif (invert)\n\t\t\t\tsetup[reg_offset] &= ~BIT(reg_shift);\n\t\t\telse\n\t\t\t\tsetup[reg_offset] |= BIT(reg_shift);\n\n\t\t\tcontinue;\n\t\t}\n\n\t\terror = fwnode_property_read_u32(reg_grp_node, name, &val);\n\t\tif (error) {\n\t\t\tdev_err(&client->dev, \"Failed to read %s %s: %d\\n\",\n\t\t\t\tfwnode_get_name(reg_grp_node), label, error);\n\t\t\treturn error;\n\t\t}\n\n\t\tif (!val_max)\n\t\t\tval_max = GENMASK(reg_width - 1, 0) * val_pitch;\n\n\t\tif (val < val_min || val > val_max) {\n\t\t\tdev_err(&client->dev, \"Invalid %s %s: %u\\n\",\n\t\t\t\tfwnode_get_name(reg_grp_node), label, val);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tsetup[reg_offset] &= ~GENMASK(reg_shift + reg_width - 1,\n\t\t\t\t\t      reg_shift);\n\t\tsetup[reg_offset] |= (val / val_pitch << reg_shift);\n\t}\n\n\treturn 0;\n}\n\nstatic int iqs7222_parse_event(struct iqs7222_private *iqs7222,\n\t\t\t       struct fwnode_handle *event_node,\n\t\t\t       int reg_grp_index,\n\t\t\t       enum iqs7222_reg_grp_id reg_grp,\n\t\t\t       enum iqs7222_reg_key_id reg_key,\n\t\t\t       u16 event_enable, u16 event_link,\n\t\t\t       unsigned int *event_type,\n\t\t\t       unsigned int *event_code)\n{\n\tstruct i2c_client *client = iqs7222->client;\n\tint error;\n\n\terror = iqs7222_parse_props(iqs7222, event_node, reg_grp_index,\n\t\t\t\t    reg_grp, reg_key);\n\tif (error)\n\t\treturn error;\n\n\terror = iqs7222_gpio_select(iqs7222, event_node, event_enable,\n\t\t\t\t    event_link);\n\tif (error)\n\t\treturn error;\n\n\terror = fwnode_property_read_u32(event_node, \"linux,code\", event_code);\n\tif (error == -EINVAL) {\n\t\treturn 0;\n\t} else if (error) {\n\t\tdev_err(&client->dev, \"Failed to read %s code: %d\\n\",\n\t\t\tfwnode_get_name(event_node), error);\n\t\treturn error;\n\t}\n\n\tif (!event_type) {\n\t\tinput_set_capability(iqs7222->keypad, EV_KEY, *event_code);\n\t\treturn 0;\n\t}\n\n\terror = fwnode_property_read_u32(event_node, \"linux,input-type\",\n\t\t\t\t\t event_type);\n\tif (error == -EINVAL) {\n\t\t*event_type = EV_KEY;\n\t} else if (error) {\n\t\tdev_err(&client->dev, \"Failed to read %s input type: %d\\n\",\n\t\t\tfwnode_get_name(event_node), error);\n\t\treturn error;\n\t} else if (*event_type != EV_KEY && *event_type != EV_SW) {\n\t\tdev_err(&client->dev, \"Invalid %s input type: %d\\n\",\n\t\t\tfwnode_get_name(event_node), *event_type);\n\t\treturn -EINVAL;\n\t}\n\n\tinput_set_capability(iqs7222->keypad, *event_type, *event_code);\n\n\treturn 0;\n}\n\nstatic int iqs7222_parse_cycle(struct iqs7222_private *iqs7222,\n\t\t\t       struct fwnode_handle *cycle_node, int cycle_index)\n{\n\tu16 *cycle_setup = iqs7222->cycle_setup[cycle_index];\n\tstruct i2c_client *client = iqs7222->client;\n\tunsigned int pins[9];\n\tint error, count, i;\n\n\t \n\tif (!fwnode_property_present(cycle_node, \"azoteq,tx-enable\"))\n\t\treturn 0;\n\n\tcount = fwnode_property_count_u32(cycle_node, \"azoteq,tx-enable\");\n\tif (count < 0) {\n\t\tdev_err(&client->dev, \"Failed to count %s CTx pins: %d\\n\",\n\t\t\tfwnode_get_name(cycle_node), count);\n\t\treturn count;\n\t} else if (count > ARRAY_SIZE(pins)) {\n\t\tdev_err(&client->dev, \"Invalid number of %s CTx pins\\n\",\n\t\t\tfwnode_get_name(cycle_node));\n\t\treturn -EINVAL;\n\t}\n\n\terror = fwnode_property_read_u32_array(cycle_node, \"azoteq,tx-enable\",\n\t\t\t\t\t       pins, count);\n\tif (error) {\n\t\tdev_err(&client->dev, \"Failed to read %s CTx pins: %d\\n\",\n\t\t\tfwnode_get_name(cycle_node), error);\n\t\treturn error;\n\t}\n\n\tcycle_setup[1] &= ~GENMASK(7 + ARRAY_SIZE(pins) - 1, 7);\n\n\tfor (i = 0; i < count; i++) {\n\t\tif (pins[i] > 8) {\n\t\t\tdev_err(&client->dev, \"Invalid %s CTx pin: %u\\n\",\n\t\t\t\tfwnode_get_name(cycle_node), pins[i]);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tcycle_setup[1] |= BIT(pins[i] + 7);\n\t}\n\n\treturn 0;\n}\n\nstatic int iqs7222_parse_chan(struct iqs7222_private *iqs7222,\n\t\t\t      struct fwnode_handle *chan_node, int chan_index)\n{\n\tconst struct iqs7222_dev_desc *dev_desc = iqs7222->dev_desc;\n\tstruct i2c_client *client = iqs7222->client;\n\tint num_chan = dev_desc->reg_grps[IQS7222_REG_GRP_CHAN].num_row;\n\tint ext_chan = rounddown(num_chan, 10);\n\tint error, i;\n\tu16 *chan_setup = iqs7222->chan_setup[chan_index];\n\tu16 *sys_setup = iqs7222->sys_setup;\n\tunsigned int val;\n\n\tif (dev_desc->allow_offset &&\n\t    fwnode_property_present(chan_node, \"azoteq,ulp-allow\"))\n\t\tsys_setup[dev_desc->allow_offset] &= ~BIT(chan_index);\n\n\tchan_setup[0] |= IQS7222_CHAN_SETUP_0_CHAN_EN;\n\n\t \n\tif (dev_desc->reg_grps[IQS7222_REG_GRP_CHAN].num_col > 4 &&\n\t    fwnode_property_present(chan_node, \"azoteq,ref-select\")) {\n\t\tu16 *ref_setup;\n\n\t\terror = fwnode_property_read_u32(chan_node, \"azoteq,ref-select\",\n\t\t\t\t\t\t &val);\n\t\tif (error) {\n\t\t\tdev_err(&client->dev,\n\t\t\t\t\"Failed to read %s reference channel: %d\\n\",\n\t\t\t\tfwnode_get_name(chan_node), error);\n\t\t\treturn error;\n\t\t}\n\n\t\tif (val >= ext_chan) {\n\t\t\tdev_err(&client->dev,\n\t\t\t\t\"Invalid %s reference channel: %u\\n\",\n\t\t\t\tfwnode_get_name(chan_node), val);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tref_setup = iqs7222->chan_setup[val];\n\n\t\t \n\t\tchan_setup[0] |= IQS7222_CHAN_SETUP_0_REF_MODE_FOLLOW;\n\t\tchan_setup[4] = val * 42 + 1048;\n\n\t\terror = fwnode_property_read_u32(chan_node, \"azoteq,ref-weight\",\n\t\t\t\t\t\t &val);\n\t\tif (!error) {\n\t\t\tif (val > U16_MAX) {\n\t\t\t\tdev_err(&client->dev,\n\t\t\t\t\t\"Invalid %s reference weight: %u\\n\",\n\t\t\t\t\tfwnode_get_name(chan_node), val);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\n\t\t\tchan_setup[5] = val;\n\t\t} else if (error != -EINVAL) {\n\t\t\tdev_err(&client->dev,\n\t\t\t\t\"Failed to read %s reference weight: %d\\n\",\n\t\t\t\tfwnode_get_name(chan_node), error);\n\t\t\treturn error;\n\t\t}\n\n\t\t \n\t\tref_setup[0] |= IQS7222_CHAN_SETUP_0_REF_MODE_REF;\n\t\tref_setup[5] |= BIT(chan_index);\n\n\t\tref_setup[4] = dev_desc->touch_link;\n\t\tif (fwnode_property_present(chan_node, \"azoteq,use-prox\"))\n\t\t\tref_setup[4] -= 2;\n\t} else if (dev_desc->reg_grps[IQS7222_REG_GRP_TPAD].num_row &&\n\t\t   fwnode_property_present(chan_node,\n\t\t\t\t\t   \"azoteq,counts-filt-enable\")) {\n\t\t \n\t\tchan_setup[0] |= IQS7222_CHAN_SETUP_0_REF_MODE_REF;\n\t}\n\n\tif (fwnode_property_present(chan_node, \"azoteq,rx-enable\")) {\n\t\t \n\t\tunsigned int pins[4];\n\t\tint count;\n\n\t\tcount = fwnode_property_count_u32(chan_node,\n\t\t\t\t\t\t  \"azoteq,rx-enable\");\n\t\tif (count < 0) {\n\t\t\tdev_err(&client->dev,\n\t\t\t\t\"Failed to count %s CRx pins: %d\\n\",\n\t\t\t\tfwnode_get_name(chan_node), count);\n\t\t\treturn count;\n\t\t} else if (count > ARRAY_SIZE(pins)) {\n\t\t\tdev_err(&client->dev,\n\t\t\t\t\"Invalid number of %s CRx pins\\n\",\n\t\t\t\tfwnode_get_name(chan_node));\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\terror = fwnode_property_read_u32_array(chan_node,\n\t\t\t\t\t\t       \"azoteq,rx-enable\",\n\t\t\t\t\t\t       pins, count);\n\t\tif (error) {\n\t\t\tdev_err(&client->dev,\n\t\t\t\t\"Failed to read %s CRx pins: %d\\n\",\n\t\t\t\tfwnode_get_name(chan_node), error);\n\t\t\treturn error;\n\t\t}\n\n\t\tchan_setup[0] &= ~GENMASK(4 + ARRAY_SIZE(pins) - 1, 4);\n\n\t\tfor (i = 0; i < count; i++) {\n\t\t\tint min_crx = chan_index < ext_chan / 2 ? 0 : 4;\n\n\t\t\tif (pins[i] < min_crx || pins[i] > min_crx + 3) {\n\t\t\t\tdev_err(&client->dev,\n\t\t\t\t\t\"Invalid %s CRx pin: %u\\n\",\n\t\t\t\t\tfwnode_get_name(chan_node), pins[i]);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\n\t\t\tchan_setup[0] |= BIT(pins[i] + 4 - min_crx);\n\t\t}\n\t}\n\n\tfor (i = 0; i < ARRAY_SIZE(iqs7222_kp_events); i++) {\n\t\tconst char *event_name = iqs7222_kp_events[i].name;\n\t\tu16 event_enable = iqs7222_kp_events[i].enable;\n\t\tstruct fwnode_handle *event_node;\n\n\t\tevent_node = fwnode_get_named_child_node(chan_node, event_name);\n\t\tif (!event_node)\n\t\t\tcontinue;\n\n\t\terror = fwnode_property_read_u32(event_node,\n\t\t\t\t\t\t \"azoteq,timeout-press-ms\",\n\t\t\t\t\t\t &val);\n\t\tif (!error) {\n\t\t\t \n\t\t\tu16 *setup = dev_desc->reg_grps\n\t\t\t\t     [IQS7222_REG_GRP_BTN].num_col > 2 ?\n\t\t\t\t     &iqs7222->btn_setup[chan_index][2] :\n\t\t\t\t     &sys_setup[9];\n\n\t\t\tif (val > U8_MAX * 500) {\n\t\t\t\tdev_err(&client->dev,\n\t\t\t\t\t\"Invalid %s press timeout: %u\\n\",\n\t\t\t\t\tfwnode_get_name(event_node), val);\n\t\t\t\tfwnode_handle_put(event_node);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\n\t\t\t*setup &= ~(U8_MAX << i * 8);\n\t\t\t*setup |= (val / 500 << i * 8);\n\t\t} else if (error != -EINVAL) {\n\t\t\tdev_err(&client->dev,\n\t\t\t\t\"Failed to read %s press timeout: %d\\n\",\n\t\t\t\tfwnode_get_name(event_node), error);\n\t\t\tfwnode_handle_put(event_node);\n\t\t\treturn error;\n\t\t}\n\n\t\terror = iqs7222_parse_event(iqs7222, event_node, chan_index,\n\t\t\t\t\t    IQS7222_REG_GRP_BTN,\n\t\t\t\t\t    iqs7222_kp_events[i].reg_key,\n\t\t\t\t\t    BIT(chan_index),\n\t\t\t\t\t    dev_desc->touch_link - (i ? 0 : 2),\n\t\t\t\t\t    &iqs7222->kp_type[chan_index][i],\n\t\t\t\t\t    &iqs7222->kp_code[chan_index][i]);\n\t\tfwnode_handle_put(event_node);\n\t\tif (error)\n\t\t\treturn error;\n\n\t\tif (!dev_desc->event_offset)\n\t\t\tcontinue;\n\n\t\tsys_setup[dev_desc->event_offset] |= event_enable;\n\t}\n\n\t \n\treturn iqs7222_parse_props(iqs7222, chan_node, chan_index,\n\t\t\t\t   IQS7222_REG_GRP_BTN,\n\t\t\t\t   IQS7222_REG_KEY_DEBOUNCE);\n}\n\nstatic int iqs7222_parse_sldr(struct iqs7222_private *iqs7222,\n\t\t\t      struct fwnode_handle *sldr_node, int sldr_index)\n{\n\tconst struct iqs7222_dev_desc *dev_desc = iqs7222->dev_desc;\n\tstruct i2c_client *client = iqs7222->client;\n\tint num_chan = dev_desc->reg_grps[IQS7222_REG_GRP_CHAN].num_row;\n\tint ext_chan = rounddown(num_chan, 10);\n\tint count, error, reg_offset, i;\n\tu16 *event_mask = &iqs7222->sys_setup[dev_desc->event_offset];\n\tu16 *sldr_setup = iqs7222->sldr_setup[sldr_index];\n\tunsigned int chan_sel[4], val;\n\n\t \n\tcount = fwnode_property_count_u32(sldr_node, \"azoteq,channel-select\");\n\tif (count < 0) {\n\t\tdev_err(&client->dev, \"Failed to count %s channels: %d\\n\",\n\t\t\tfwnode_get_name(sldr_node), count);\n\t\treturn count;\n\t} else if (count < 3 || count > ARRAY_SIZE(chan_sel)) {\n\t\tdev_err(&client->dev, \"Invalid number of %s channels\\n\",\n\t\t\tfwnode_get_name(sldr_node));\n\t\treturn -EINVAL;\n\t}\n\n\terror = fwnode_property_read_u32_array(sldr_node,\n\t\t\t\t\t       \"azoteq,channel-select\",\n\t\t\t\t\t       chan_sel, count);\n\tif (error) {\n\t\tdev_err(&client->dev, \"Failed to read %s channels: %d\\n\",\n\t\t\tfwnode_get_name(sldr_node), error);\n\t\treturn error;\n\t}\n\n\t \n\treg_offset = dev_desc->sldr_res < U16_MAX ? 0 : 1;\n\n\tsldr_setup[0] |= count;\n\tsldr_setup[3 + reg_offset] &= ~GENMASK(ext_chan - 1, 0);\n\n\tfor (i = 0; i < ARRAY_SIZE(chan_sel); i++) {\n\t\tsldr_setup[5 + reg_offset + i] = 0;\n\t\tif (i >= count)\n\t\t\tcontinue;\n\n\t\tif (chan_sel[i] >= ext_chan) {\n\t\t\tdev_err(&client->dev, \"Invalid %s channel: %u\\n\",\n\t\t\t\tfwnode_get_name(sldr_node), chan_sel[i]);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\t \n\t\tsldr_setup[3 + reg_offset] |= BIT(chan_sel[i]);\n\t\tsldr_setup[5 + reg_offset + i] = chan_sel[i] * 42 + 1080;\n\t}\n\n\tsldr_setup[4 + reg_offset] = dev_desc->touch_link;\n\tif (fwnode_property_present(sldr_node, \"azoteq,use-prox\"))\n\t\tsldr_setup[4 + reg_offset] -= 2;\n\n\terror = fwnode_property_read_u32(sldr_node, \"azoteq,slider-size\", &val);\n\tif (!error) {\n\t\tif (val > dev_desc->sldr_res) {\n\t\t\tdev_err(&client->dev, \"Invalid %s size: %u\\n\",\n\t\t\t\tfwnode_get_name(sldr_node), val);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (reg_offset) {\n\t\t\tsldr_setup[3] = val;\n\t\t} else {\n\t\t\tsldr_setup[2] &= ~IQS7222_SLDR_SETUP_2_RES_MASK;\n\t\t\tsldr_setup[2] |= (val / 16 <<\n\t\t\t\t\t  IQS7222_SLDR_SETUP_2_RES_SHIFT);\n\t\t}\n\t} else if (error != -EINVAL) {\n\t\tdev_err(&client->dev, \"Failed to read %s size: %d\\n\",\n\t\t\tfwnode_get_name(sldr_node), error);\n\t\treturn error;\n\t}\n\n\tif (!(reg_offset ? sldr_setup[3]\n\t\t\t : sldr_setup[2] & IQS7222_SLDR_SETUP_2_RES_MASK)) {\n\t\tdev_err(&client->dev, \"Undefined %s size\\n\",\n\t\t\tfwnode_get_name(sldr_node));\n\t\treturn -EINVAL;\n\t}\n\n\terror = fwnode_property_read_u32(sldr_node, \"azoteq,top-speed\", &val);\n\tif (!error) {\n\t\tif (val > (reg_offset ? U16_MAX : U8_MAX * 4)) {\n\t\t\tdev_err(&client->dev, \"Invalid %s top speed: %u\\n\",\n\t\t\t\tfwnode_get_name(sldr_node), val);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (reg_offset) {\n\t\t\tsldr_setup[2] = val;\n\t\t} else {\n\t\t\tsldr_setup[2] &= ~IQS7222_SLDR_SETUP_2_TOP_SPEED_MASK;\n\t\t\tsldr_setup[2] |= (val / 4);\n\t\t}\n\t} else if (error != -EINVAL) {\n\t\tdev_err(&client->dev, \"Failed to read %s top speed: %d\\n\",\n\t\t\tfwnode_get_name(sldr_node), error);\n\t\treturn error;\n\t}\n\n\terror = fwnode_property_read_u32(sldr_node, \"linux,axis\", &val);\n\tif (!error) {\n\t\tu16 sldr_max = sldr_setup[3] - 1;\n\n\t\tif (!reg_offset) {\n\t\t\tsldr_max = sldr_setup[2];\n\n\t\t\tsldr_max &= IQS7222_SLDR_SETUP_2_RES_MASK;\n\t\t\tsldr_max >>= IQS7222_SLDR_SETUP_2_RES_SHIFT;\n\n\t\t\tsldr_max = sldr_max * 16 - 1;\n\t\t}\n\n\t\tinput_set_abs_params(iqs7222->keypad, val, 0, sldr_max, 0, 0);\n\t\tiqs7222->sl_axis[sldr_index] = val;\n\t} else if (error != -EINVAL) {\n\t\tdev_err(&client->dev, \"Failed to read %s axis: %d\\n\",\n\t\t\tfwnode_get_name(sldr_node), error);\n\t\treturn error;\n\t}\n\n\tif (dev_desc->wheel_enable) {\n\t\tsldr_setup[0] &= ~dev_desc->wheel_enable;\n\t\tif (iqs7222->sl_axis[sldr_index] == ABS_WHEEL)\n\t\t\tsldr_setup[0] |= dev_desc->wheel_enable;\n\t}\n\n\t \n\tif (!reg_offset)\n\t\tfor (i = 0; i < ARRAY_SIZE(iqs7222_sl_events); i++)\n\t\t\tsldr_setup[9] &= ~iqs7222_sl_events[i].enable;\n\n\tfor (i = 0; i < ARRAY_SIZE(iqs7222_sl_events); i++) {\n\t\tconst char *event_name = iqs7222_sl_events[i].name;\n\t\tstruct fwnode_handle *event_node;\n\t\tenum iqs7222_reg_key_id reg_key;\n\n\t\tevent_node = fwnode_get_named_child_node(sldr_node, event_name);\n\t\tif (!event_node)\n\t\t\tcontinue;\n\n\t\t \n\t\tif (reg_offset)\n\t\t\treg_key = IQS7222_REG_KEY_RESERVED;\n\t\telse if (dev_desc->legacy_gesture &&\n\t\t\t iqs7222_sl_events[i].reg_key == IQS7222_REG_KEY_TAP)\n\t\t\treg_key = IQS7222_REG_KEY_TAP_LEGACY;\n\t\telse if (dev_desc->legacy_gesture &&\n\t\t\t iqs7222_sl_events[i].reg_key == IQS7222_REG_KEY_AXIAL)\n\t\t\treg_key = IQS7222_REG_KEY_AXIAL_LEGACY;\n\t\telse\n\t\t\treg_key = iqs7222_sl_events[i].reg_key;\n\n\t\t \n\t\terror = iqs7222_parse_event(iqs7222, event_node, sldr_index,\n\t\t\t\t\t    IQS7222_REG_GRP_SLDR, reg_key,\n\t\t\t\t\t    i ? iqs7222_sl_events[i].enable\n\t\t\t\t\t      : sldr_setup[3 + reg_offset],\n\t\t\t\t\t    i ? 1568 + sldr_index * 30\n\t\t\t\t\t      : sldr_setup[4 + reg_offset],\n\t\t\t\t\t    NULL,\n\t\t\t\t\t    &iqs7222->sl_code[sldr_index][i]);\n\t\tfwnode_handle_put(event_node);\n\t\tif (error)\n\t\t\treturn error;\n\n\t\tif (!reg_offset)\n\t\t\tsldr_setup[9] |= iqs7222_sl_events[i].enable;\n\n\t\tif (!dev_desc->event_offset)\n\t\t\tcontinue;\n\n\t\t \n\t\tif (i && !reg_offset)\n\t\t\t*event_mask |= (IQS7222_EVENT_MASK_SLDR << sldr_index);\n\t\telse if (sldr_setup[4 + reg_offset] == dev_desc->touch_link)\n\t\t\t*event_mask |= IQS7222_EVENT_MASK_TOUCH;\n\t\telse\n\t\t\t*event_mask |= IQS7222_EVENT_MASK_PROX;\n\t}\n\n\t \n\treturn iqs7222_parse_props(iqs7222, sldr_node, sldr_index,\n\t\t\t\t   IQS7222_REG_GRP_SLDR,\n\t\t\t\t   dev_desc->wheel_enable ?\n\t\t\t\t   IQS7222_REG_KEY_WHEEL :\n\t\t\t\t   IQS7222_REG_KEY_NO_WHEEL);\n}\n\nstatic int iqs7222_parse_tpad(struct iqs7222_private *iqs7222,\n\t\t\t      struct fwnode_handle *tpad_node, int tpad_index)\n{\n\tconst struct iqs7222_dev_desc *dev_desc = iqs7222->dev_desc;\n\tstruct touchscreen_properties *prop = &iqs7222->prop;\n\tstruct i2c_client *client = iqs7222->client;\n\tint num_chan = dev_desc->reg_grps[IQS7222_REG_GRP_CHAN].num_row;\n\tint count, error, i;\n\tu16 *event_mask = &iqs7222->sys_setup[dev_desc->event_offset];\n\tu16 *tpad_setup = iqs7222->tpad_setup;\n\tunsigned int chan_sel[12];\n\n\terror = iqs7222_parse_props(iqs7222, tpad_node, tpad_index,\n\t\t\t\t    IQS7222_REG_GRP_TPAD,\n\t\t\t\t    IQS7222_REG_KEY_NONE);\n\tif (error)\n\t\treturn error;\n\n\tcount = fwnode_property_count_u32(tpad_node, \"azoteq,channel-select\");\n\tif (count < 0) {\n\t\tdev_err(&client->dev, \"Failed to count %s channels: %d\\n\",\n\t\t\tfwnode_get_name(tpad_node), count);\n\t\treturn count;\n\t} else if (!count || count > ARRAY_SIZE(chan_sel)) {\n\t\tdev_err(&client->dev, \"Invalid number of %s channels\\n\",\n\t\t\tfwnode_get_name(tpad_node));\n\t\treturn -EINVAL;\n\t}\n\n\terror = fwnode_property_read_u32_array(tpad_node,\n\t\t\t\t\t       \"azoteq,channel-select\",\n\t\t\t\t\t       chan_sel, count);\n\tif (error) {\n\t\tdev_err(&client->dev, \"Failed to read %s channels: %d\\n\",\n\t\t\tfwnode_get_name(tpad_node), error);\n\t\treturn error;\n\t}\n\n\ttpad_setup[6] &= ~GENMASK(num_chan - 1, 0);\n\n\tfor (i = 0; i < ARRAY_SIZE(chan_sel); i++) {\n\t\ttpad_setup[8 + i] = 0;\n\t\tif (i >= count || chan_sel[i] == U8_MAX)\n\t\t\tcontinue;\n\n\t\tif (chan_sel[i] >= num_chan) {\n\t\t\tdev_err(&client->dev, \"Invalid %s channel: %u\\n\",\n\t\t\t\tfwnode_get_name(tpad_node), chan_sel[i]);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\t \n\t\ttpad_setup[6] |= BIT(chan_sel[i]);\n\t\ttpad_setup[8 + i] = chan_sel[i] * 34 + 1072;\n\t}\n\n\ttpad_setup[7] = dev_desc->touch_link;\n\tif (fwnode_property_present(tpad_node, \"azoteq,use-prox\"))\n\t\ttpad_setup[7] -= 2;\n\n\tfor (i = 0; i < ARRAY_SIZE(iqs7222_tp_events); i++)\n\t\ttpad_setup[20] &= ~(iqs7222_tp_events[i].strict |\n\t\t\t\t    iqs7222_tp_events[i].enable);\n\n\tfor (i = 0; i < ARRAY_SIZE(iqs7222_tp_events); i++) {\n\t\tconst char *event_name = iqs7222_tp_events[i].name;\n\t\tstruct fwnode_handle *event_node;\n\n\t\tevent_node = fwnode_get_named_child_node(tpad_node, event_name);\n\t\tif (!event_node)\n\t\t\tcontinue;\n\n\t\tif (fwnode_property_present(event_node,\n\t\t\t\t\t    \"azoteq,gesture-angle-tighten\"))\n\t\t\ttpad_setup[20] |= iqs7222_tp_events[i].strict;\n\n\t\ttpad_setup[20] |= iqs7222_tp_events[i].enable;\n\n\t\terror = iqs7222_parse_event(iqs7222, event_node, tpad_index,\n\t\t\t\t\t    IQS7222_REG_GRP_TPAD,\n\t\t\t\t\t    iqs7222_tp_events[i].reg_key,\n\t\t\t\t\t    iqs7222_tp_events[i].link, 1566,\n\t\t\t\t\t    NULL,\n\t\t\t\t\t    &iqs7222->tp_code[i]);\n\t\tfwnode_handle_put(event_node);\n\t\tif (error)\n\t\t\treturn error;\n\n\t\tif (!dev_desc->event_offset)\n\t\t\tcontinue;\n\n\t\t \n\t\tif (i)\n\t\t\t*event_mask |= IQS7222_EVENT_MASK_TPAD;\n\t\telse if (tpad_setup[7] == dev_desc->touch_link)\n\t\t\t*event_mask |= IQS7222_EVENT_MASK_TOUCH;\n\t\telse\n\t\t\t*event_mask |= IQS7222_EVENT_MASK_PROX;\n\t}\n\n\tif (!iqs7222->tp_code[0])\n\t\treturn 0;\n\n\tinput_set_abs_params(iqs7222->keypad, ABS_X,\n\t\t\t     0, (tpad_setup[4] ? : 1) - 1, 0, 0);\n\n\tinput_set_abs_params(iqs7222->keypad, ABS_Y,\n\t\t\t     0, (tpad_setup[5] ? : 1) - 1, 0, 0);\n\n\ttouchscreen_parse_properties(iqs7222->keypad, false, prop);\n\n\tif (prop->max_x >= U16_MAX || prop->max_y >= U16_MAX) {\n\t\tdev_err(&client->dev, \"Invalid trackpad size: %u*%u\\n\",\n\t\t\tprop->max_x, prop->max_y);\n\t\treturn -EINVAL;\n\t}\n\n\ttpad_setup[4] = prop->max_x + 1;\n\ttpad_setup[5] = prop->max_y + 1;\n\n\treturn 0;\n}\n\nstatic int (*iqs7222_parse_extra[IQS7222_NUM_REG_GRPS])\n\t\t\t\t(struct iqs7222_private *iqs7222,\n\t\t\t\t struct fwnode_handle *reg_grp_node,\n\t\t\t\t int reg_grp_index) = {\n\t[IQS7222_REG_GRP_CYCLE] = iqs7222_parse_cycle,\n\t[IQS7222_REG_GRP_CHAN] = iqs7222_parse_chan,\n\t[IQS7222_REG_GRP_SLDR] = iqs7222_parse_sldr,\n\t[IQS7222_REG_GRP_TPAD] = iqs7222_parse_tpad,\n};\n\nstatic int iqs7222_parse_reg_grp(struct iqs7222_private *iqs7222,\n\t\t\t\t enum iqs7222_reg_grp_id reg_grp,\n\t\t\t\t int reg_grp_index)\n{\n\tstruct i2c_client *client = iqs7222->client;\n\tstruct fwnode_handle *reg_grp_node;\n\tint error;\n\n\tif (iqs7222_reg_grp_names[reg_grp]) {\n\t\tchar reg_grp_name[16];\n\n\t\tsnprintf(reg_grp_name, sizeof(reg_grp_name),\n\t\t\t iqs7222_reg_grp_names[reg_grp], reg_grp_index);\n\n\t\treg_grp_node = device_get_named_child_node(&client->dev,\n\t\t\t\t\t\t\t   reg_grp_name);\n\t} else {\n\t\treg_grp_node = fwnode_handle_get(dev_fwnode(&client->dev));\n\t}\n\n\tif (!reg_grp_node)\n\t\treturn 0;\n\n\terror = iqs7222_parse_props(iqs7222, reg_grp_node, reg_grp_index,\n\t\t\t\t    reg_grp, IQS7222_REG_KEY_NONE);\n\n\tif (!error && iqs7222_parse_extra[reg_grp])\n\t\terror = iqs7222_parse_extra[reg_grp](iqs7222, reg_grp_node,\n\t\t\t\t\t\t     reg_grp_index);\n\n\tfwnode_handle_put(reg_grp_node);\n\n\treturn error;\n}\n\nstatic int iqs7222_parse_all(struct iqs7222_private *iqs7222)\n{\n\tconst struct iqs7222_dev_desc *dev_desc = iqs7222->dev_desc;\n\tconst struct iqs7222_reg_grp_desc *reg_grps = dev_desc->reg_grps;\n\tu16 *sys_setup = iqs7222->sys_setup;\n\tint error, i, j;\n\n\tif (dev_desc->allow_offset)\n\t\tsys_setup[dev_desc->allow_offset] = U16_MAX;\n\n\tif (dev_desc->event_offset)\n\t\tsys_setup[dev_desc->event_offset] = IQS7222_EVENT_MASK_ATI;\n\n\tfor (i = 0; i < reg_grps[IQS7222_REG_GRP_GPIO].num_row; i++) {\n\t\tu16 *gpio_setup = iqs7222->gpio_setup[i];\n\n\t\tgpio_setup[0] &= ~IQS7222_GPIO_SETUP_0_GPIO_EN;\n\t\tgpio_setup[1] = 0;\n\t\tgpio_setup[2] = 0;\n\n\t\tif (reg_grps[IQS7222_REG_GRP_GPIO].num_row == 1)\n\t\t\tcontinue;\n\n\t\t \n\t\tfor (j = 0; j < ARRAY_SIZE(iqs7222_gpio_links); j++)\n\t\t\tgpio_setup[0] &= ~BIT(iqs7222_gpio_links[j]);\n\n\t\tgpio_setup[0] |= BIT(iqs7222_gpio_links[i]);\n\t}\n\n\tfor (i = 0; i < reg_grps[IQS7222_REG_GRP_CHAN].num_row; i++) {\n\t\tu16 *chan_setup = iqs7222->chan_setup[i];\n\n\t\tchan_setup[0] &= ~IQS7222_CHAN_SETUP_0_REF_MODE_MASK;\n\t\tchan_setup[0] &= ~IQS7222_CHAN_SETUP_0_CHAN_EN;\n\n\t\tchan_setup[5] = 0;\n\t}\n\n\tfor (i = 0; i < reg_grps[IQS7222_REG_GRP_SLDR].num_row; i++) {\n\t\tu16 *sldr_setup = iqs7222->sldr_setup[i];\n\n\t\tsldr_setup[0] &= ~IQS7222_SLDR_SETUP_0_CHAN_CNT_MASK;\n\t}\n\n\tfor (i = 0; i < IQS7222_NUM_REG_GRPS; i++) {\n\t\tfor (j = 0; j < reg_grps[i].num_row; j++) {\n\t\t\terror = iqs7222_parse_reg_grp(iqs7222, i, j);\n\t\t\tif (error)\n\t\t\t\treturn error;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int iqs7222_report(struct iqs7222_private *iqs7222)\n{\n\tconst struct iqs7222_dev_desc *dev_desc = iqs7222->dev_desc;\n\tstruct i2c_client *client = iqs7222->client;\n\tint num_chan = dev_desc->reg_grps[IQS7222_REG_GRP_CHAN].num_row;\n\tint num_stat = dev_desc->reg_grps[IQS7222_REG_GRP_STAT].num_col;\n\tint error, i, j;\n\t__le16 status[IQS7222_MAX_COLS_STAT];\n\n\terror = iqs7222_read_burst(iqs7222, IQS7222_SYS_STATUS, status,\n\t\t\t\t   num_stat);\n\tif (error)\n\t\treturn error;\n\n\tif (le16_to_cpu(status[0]) & IQS7222_SYS_STATUS_RESET) {\n\t\tdev_err(&client->dev, \"Unexpected device reset\\n\");\n\t\treturn iqs7222_dev_init(iqs7222, WRITE);\n\t}\n\n\tif (le16_to_cpu(status[0]) & IQS7222_SYS_STATUS_ATI_ERROR) {\n\t\tdev_err(&client->dev, \"Unexpected ATI error\\n\");\n\t\treturn iqs7222_ati_trigger(iqs7222);\n\t}\n\n\tif (le16_to_cpu(status[0]) & IQS7222_SYS_STATUS_ATI_ACTIVE)\n\t\treturn 0;\n\n\tfor (i = 0; i < num_chan; i++) {\n\t\tu16 *chan_setup = iqs7222->chan_setup[i];\n\n\t\tif (!(chan_setup[0] & IQS7222_CHAN_SETUP_0_CHAN_EN))\n\t\t\tcontinue;\n\n\t\tfor (j = 0; j < ARRAY_SIZE(iqs7222_kp_events); j++) {\n\t\t\t \n\t\t\tint k = 2 + j * (num_chan > 16 ? 2 : 1);\n\t\t\tu16 state = le16_to_cpu(status[k + i / 16]);\n\n\t\t\tif (!iqs7222->kp_type[i][j])\n\t\t\t\tcontinue;\n\n\t\t\tinput_event(iqs7222->keypad,\n\t\t\t\t    iqs7222->kp_type[i][j],\n\t\t\t\t    iqs7222->kp_code[i][j],\n\t\t\t\t    !!(state & BIT(i % 16)));\n\t\t}\n\t}\n\n\tfor (i = 0; i < dev_desc->reg_grps[IQS7222_REG_GRP_SLDR].num_row; i++) {\n\t\tu16 *sldr_setup = iqs7222->sldr_setup[i];\n\t\tu16 sldr_pos = le16_to_cpu(status[4 + i]);\n\t\tu16 state = le16_to_cpu(status[6 + i]);\n\n\t\tif (!(sldr_setup[0] & IQS7222_SLDR_SETUP_0_CHAN_CNT_MASK))\n\t\t\tcontinue;\n\n\t\tif (sldr_pos < dev_desc->sldr_res)\n\t\t\tinput_report_abs(iqs7222->keypad, iqs7222->sl_axis[i],\n\t\t\t\t\t sldr_pos);\n\n\t\tinput_report_key(iqs7222->keypad, iqs7222->sl_code[i][0],\n\t\t\t\t sldr_pos < dev_desc->sldr_res);\n\n\t\t \n\t\tif (dev_desc->sldr_res == U16_MAX)\n\t\t\tcontinue;\n\n\t\tif (!(le16_to_cpu(status[1]) & IQS7222_EVENT_MASK_SLDR << i))\n\t\t\tcontinue;\n\n\t\t \n\t\tfor (j = 1; j < ARRAY_SIZE(iqs7222_sl_events); j++) {\n\t\t\tu16 mask = iqs7222_sl_events[j].mask;\n\t\t\tu16 val = iqs7222_sl_events[j].val;\n\n\t\t\tinput_report_key(iqs7222->keypad,\n\t\t\t\t\t iqs7222->sl_code[i][j],\n\t\t\t\t\t (state & mask) == val);\n\t\t}\n\n\t\tinput_sync(iqs7222->keypad);\n\n\t\tfor (j = 1; j < ARRAY_SIZE(iqs7222_sl_events); j++)\n\t\t\tinput_report_key(iqs7222->keypad,\n\t\t\t\t\t iqs7222->sl_code[i][j], 0);\n\t}\n\n\tfor (i = 0; i < dev_desc->reg_grps[IQS7222_REG_GRP_TPAD].num_row; i++) {\n\t\tu16 tpad_pos_x = le16_to_cpu(status[4]);\n\t\tu16 tpad_pos_y = le16_to_cpu(status[5]);\n\t\tu16 state = le16_to_cpu(status[6]);\n\n\t\tinput_report_key(iqs7222->keypad, iqs7222->tp_code[0],\n\t\t\t\t tpad_pos_x < U16_MAX);\n\n\t\tif (tpad_pos_x < U16_MAX)\n\t\t\ttouchscreen_report_pos(iqs7222->keypad, &iqs7222->prop,\n\t\t\t\t\t       tpad_pos_x, tpad_pos_y, false);\n\n\t\tif (!(le16_to_cpu(status[1]) & IQS7222_EVENT_MASK_TPAD))\n\t\t\tcontinue;\n\n\t\t \n\t\tfor (j = 1; j < ARRAY_SIZE(iqs7222_tp_events); j++) {\n\t\t\tu16 mask = iqs7222_tp_events[j].mask;\n\t\t\tu16 val = iqs7222_tp_events[j].val;\n\n\t\t\tinput_report_key(iqs7222->keypad,\n\t\t\t\t\t iqs7222->tp_code[j],\n\t\t\t\t\t (state & mask) == val);\n\t\t}\n\n\t\tinput_sync(iqs7222->keypad);\n\n\t\tfor (j = 1; j < ARRAY_SIZE(iqs7222_tp_events); j++)\n\t\t\tinput_report_key(iqs7222->keypad,\n\t\t\t\t\t iqs7222->tp_code[j], 0);\n\t}\n\n\tinput_sync(iqs7222->keypad);\n\n\treturn 0;\n}\n\nstatic irqreturn_t iqs7222_irq(int irq, void *context)\n{\n\tstruct iqs7222_private *iqs7222 = context;\n\n\treturn iqs7222_report(iqs7222) ? IRQ_NONE : IRQ_HANDLED;\n}\n\nstatic int iqs7222_probe(struct i2c_client *client)\n{\n\tstruct iqs7222_private *iqs7222;\n\tunsigned long irq_flags;\n\tint error, irq;\n\n\tiqs7222 = devm_kzalloc(&client->dev, sizeof(*iqs7222), GFP_KERNEL);\n\tif (!iqs7222)\n\t\treturn -ENOMEM;\n\n\ti2c_set_clientdata(client, iqs7222);\n\tiqs7222->client = client;\n\n\tiqs7222->keypad = devm_input_allocate_device(&client->dev);\n\tif (!iqs7222->keypad)\n\t\treturn -ENOMEM;\n\n\tiqs7222->keypad->name = client->name;\n\tiqs7222->keypad->id.bustype = BUS_I2C;\n\n\t \n\tiqs7222->irq_gpio = devm_gpiod_get(&client->dev, \"irq\", GPIOD_IN);\n\tif (IS_ERR(iqs7222->irq_gpio)) {\n\t\terror = PTR_ERR(iqs7222->irq_gpio);\n\t\tdev_err(&client->dev, \"Failed to request IRQ GPIO: %d\\n\",\n\t\t\terror);\n\t\treturn error;\n\t}\n\n\tiqs7222->reset_gpio = devm_gpiod_get_optional(&client->dev, \"reset\",\n\t\t\t\t\t\t      GPIOD_OUT_HIGH);\n\tif (IS_ERR(iqs7222->reset_gpio)) {\n\t\terror = PTR_ERR(iqs7222->reset_gpio);\n\t\tdev_err(&client->dev, \"Failed to request reset GPIO: %d\\n\",\n\t\t\terror);\n\t\treturn error;\n\t}\n\n\terror = iqs7222_hard_reset(iqs7222);\n\tif (error)\n\t\treturn error;\n\n\terror = iqs7222_dev_info(iqs7222);\n\tif (error)\n\t\treturn error;\n\n\terror = iqs7222_dev_init(iqs7222, READ);\n\tif (error)\n\t\treturn error;\n\n\terror = iqs7222_parse_all(iqs7222);\n\tif (error)\n\t\treturn error;\n\n\terror = iqs7222_dev_init(iqs7222, WRITE);\n\tif (error)\n\t\treturn error;\n\n\terror = iqs7222_report(iqs7222);\n\tif (error)\n\t\treturn error;\n\n\terror = input_register_device(iqs7222->keypad);\n\tif (error) {\n\t\tdev_err(&client->dev, \"Failed to register device: %d\\n\", error);\n\t\treturn error;\n\t}\n\n\tirq = gpiod_to_irq(iqs7222->irq_gpio);\n\tif (irq < 0)\n\t\treturn irq;\n\n\tirq_flags = gpiod_is_active_low(iqs7222->irq_gpio) ? IRQF_TRIGGER_LOW\n\t\t\t\t\t\t\t   : IRQF_TRIGGER_HIGH;\n\tirq_flags |= IRQF_ONESHOT;\n\n\terror = devm_request_threaded_irq(&client->dev, irq, NULL, iqs7222_irq,\n\t\t\t\t\t  irq_flags, client->name, iqs7222);\n\tif (error)\n\t\tdev_err(&client->dev, \"Failed to request IRQ: %d\\n\", error);\n\n\treturn error;\n}\n\nstatic const struct of_device_id iqs7222_of_match[] = {\n\t{ .compatible = \"azoteq,iqs7222a\" },\n\t{ .compatible = \"azoteq,iqs7222b\" },\n\t{ .compatible = \"azoteq,iqs7222c\" },\n\t{ .compatible = \"azoteq,iqs7222d\" },\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, iqs7222_of_match);\n\nstatic struct i2c_driver iqs7222_i2c_driver = {\n\t.driver = {\n\t\t.name = \"iqs7222\",\n\t\t.of_match_table = iqs7222_of_match,\n\t},\n\t.probe = iqs7222_probe,\n};\nmodule_i2c_driver(iqs7222_i2c_driver);\n\nMODULE_AUTHOR(\"Jeff LaBundy <jeff@labundy.com>\");\nMODULE_DESCRIPTION(\"Azoteq IQS7222A/B/C/D Capacitive Touch Controller\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}