{
  "module_name": "da9063_onkey.c",
  "hash_id": "6a506588e7f54102920f004a71d040916217cbd22707022154e9fdfc63235d1d",
  "original_prompt": "Ingested from linux-6.6.14/drivers/input/misc/da9063_onkey.c",
  "human_readable_source": "\n \n\n#include <linux/devm-helpers.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/input.h>\n#include <linux/interrupt.h>\n#include <linux/platform_device.h>\n#include <linux/pm_wakeirq.h>\n#include <linux/workqueue.h>\n#include <linux/regmap.h>\n#include <linux/of.h>\n#include <linux/mfd/da9063/core.h>\n#include <linux/mfd/da9063/registers.h>\n#include <linux/mfd/da9062/core.h>\n#include <linux/mfd/da9062/registers.h>\n\nstruct da906x_chip_config {\n\t \n\tint onkey_status;\n\tint onkey_pwr_signalling;\n\tint onkey_fault_log;\n\tint onkey_shutdown;\n\t \n\tint onkey_nonkey_mask;\n\tint onkey_nonkey_lock_mask;\n\tint onkey_key_reset_mask;\n\tint onkey_shutdown_mask;\n\t \n\tconst char *name;\n};\n\nstruct da9063_onkey {\n\tstruct delayed_work work;\n\tstruct input_dev *input;\n\tstruct device *dev;\n\tstruct regmap *regmap;\n\tconst struct da906x_chip_config *config;\n\tchar phys[32];\n\tbool key_power;\n};\n\nstatic const struct da906x_chip_config da9063_regs = {\n\t \n\t.onkey_status = DA9063_REG_STATUS_A,\n\t.onkey_pwr_signalling = DA9063_REG_CONTROL_B,\n\t.onkey_fault_log = DA9063_REG_FAULT_LOG,\n\t.onkey_shutdown = DA9063_REG_CONTROL_F,\n\t \n\t.onkey_nonkey_mask = DA9063_NONKEY,\n\t.onkey_nonkey_lock_mask = DA9063_NONKEY_LOCK,\n\t.onkey_key_reset_mask = DA9063_KEY_RESET,\n\t.onkey_shutdown_mask = DA9063_SHUTDOWN,\n\t \n\t.name = DA9063_DRVNAME_ONKEY,\n};\n\nstatic const struct da906x_chip_config da9062_regs = {\n\t \n\t.onkey_status = DA9062AA_STATUS_A,\n\t.onkey_pwr_signalling = DA9062AA_CONTROL_B,\n\t.onkey_fault_log = DA9062AA_FAULT_LOG,\n\t.onkey_shutdown = DA9062AA_CONTROL_F,\n\t \n\t.onkey_nonkey_mask = DA9062AA_NONKEY_MASK,\n\t.onkey_nonkey_lock_mask = DA9062AA_NONKEY_LOCK_MASK,\n\t.onkey_key_reset_mask = DA9062AA_KEY_RESET_MASK,\n\t.onkey_shutdown_mask = DA9062AA_SHUTDOWN_MASK,\n\t \n\t.name = \"da9062-onkey\",\n};\n\nstatic const struct of_device_id da9063_compatible_reg_id_table[] = {\n\t{ .compatible = \"dlg,da9063-onkey\", .data = &da9063_regs },\n\t{ .compatible = \"dlg,da9062-onkey\", .data = &da9062_regs },\n\t{ },\n};\nMODULE_DEVICE_TABLE(of, da9063_compatible_reg_id_table);\n\nstatic void da9063_poll_on(struct work_struct *work)\n{\n\tstruct da9063_onkey *onkey = container_of(work,\n\t\t\t\t\t\tstruct da9063_onkey,\n\t\t\t\t\t\twork.work);\n\tconst struct da906x_chip_config *config = onkey->config;\n\tunsigned int val;\n\tint fault_log = 0;\n\tbool poll = true;\n\tint error;\n\n\t \n\terror = regmap_read(onkey->regmap,\n\t\t\t    config->onkey_status,\n\t\t\t    &val);\n\tif (error) {\n\t\tdev_err(onkey->dev,\n\t\t\t\"Failed to read ON status: %d\\n\", error);\n\t\tgoto err_poll;\n\t}\n\n\tif (!(val & config->onkey_nonkey_mask)) {\n\t\terror = regmap_update_bits(onkey->regmap,\n\t\t\t\t\t   config->onkey_pwr_signalling,\n\t\t\t\t\t   config->onkey_nonkey_lock_mask,\n\t\t\t\t\t   0);\n\t\tif (error) {\n\t\t\tdev_err(onkey->dev,\n\t\t\t\t\"Failed to reset the Key Delay %d\\n\", error);\n\t\t\tgoto err_poll;\n\t\t}\n\n\t\tinput_report_key(onkey->input, KEY_POWER, 0);\n\t\tinput_sync(onkey->input);\n\n\t\tpoll = false;\n\t}\n\n\t \n\terror = regmap_read(onkey->regmap,\n\t\t\t    config->onkey_fault_log,\n\t\t\t    &fault_log);\n\tif (error) {\n\t\tdev_warn(&onkey->input->dev,\n\t\t\t \"Cannot read FAULT_LOG: %d\\n\", error);\n\t} else if (fault_log & config->onkey_key_reset_mask) {\n\t\terror = regmap_write(onkey->regmap,\n\t\t\t\t     config->onkey_fault_log,\n\t\t\t\t     config->onkey_key_reset_mask);\n\t\tif (error) {\n\t\t\tdev_warn(&onkey->input->dev,\n\t\t\t\t \"Cannot reset KEY_RESET fault log: %d\\n\",\n\t\t\t\t error);\n\t\t} else {\n\t\t\t \n\t\t\tdev_dbg(&onkey->input->dev,\n\t\t\t\t\"Sending SHUTDOWN to PMIC ...\\n\");\n\t\t\terror = regmap_write(onkey->regmap,\n\t\t\t\t\t     config->onkey_shutdown,\n\t\t\t\t\t     config->onkey_shutdown_mask);\n\t\t\tif (error)\n\t\t\t\tdev_err(&onkey->input->dev,\n\t\t\t\t\t\"Cannot SHUTDOWN PMIC: %d\\n\",\n\t\t\t\t\terror);\n\t\t}\n\t}\n\nerr_poll:\n\tif (poll)\n\t\tschedule_delayed_work(&onkey->work, msecs_to_jiffies(50));\n}\n\nstatic irqreturn_t da9063_onkey_irq_handler(int irq, void *data)\n{\n\tstruct da9063_onkey *onkey = data;\n\tconst struct da906x_chip_config *config = onkey->config;\n\tunsigned int val;\n\tint error;\n\n\terror = regmap_read(onkey->regmap,\n\t\t\t    config->onkey_status,\n\t\t\t    &val);\n\tif (onkey->key_power && !error && (val & config->onkey_nonkey_mask)) {\n\t\tinput_report_key(onkey->input, KEY_POWER, 1);\n\t\tinput_sync(onkey->input);\n\t\tschedule_delayed_work(&onkey->work, 0);\n\t\tdev_dbg(onkey->dev, \"KEY_POWER long press.\\n\");\n\t} else {\n\t\tinput_report_key(onkey->input, KEY_POWER, 1);\n\t\tinput_sync(onkey->input);\n\t\tinput_report_key(onkey->input, KEY_POWER, 0);\n\t\tinput_sync(onkey->input);\n\t\tdev_dbg(onkey->dev, \"KEY_POWER short press.\\n\");\n\t}\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int da9063_onkey_probe(struct platform_device *pdev)\n{\n\tstruct da9063_onkey *onkey;\n\tconst struct of_device_id *match;\n\tint irq;\n\tint error;\n\n\tmatch = of_match_node(da9063_compatible_reg_id_table,\n\t\t\t      pdev->dev.of_node);\n\tif (!match)\n\t\treturn -ENXIO;\n\n\tonkey = devm_kzalloc(&pdev->dev, sizeof(struct da9063_onkey),\n\t\t\t     GFP_KERNEL);\n\tif (!onkey) {\n\t\tdev_err(&pdev->dev, \"Failed to allocate memory.\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tonkey->config = match->data;\n\tonkey->dev = &pdev->dev;\n\n\tonkey->regmap = dev_get_regmap(pdev->dev.parent, NULL);\n\tif (!onkey->regmap) {\n\t\tdev_err(&pdev->dev, \"Parent regmap unavailable.\\n\");\n\t\treturn -ENXIO;\n\t}\n\n\tonkey->key_power = !of_property_read_bool(pdev->dev.of_node,\n\t\t\t\t\t\t  \"dlg,disable-key-power\");\n\n\tonkey->input = devm_input_allocate_device(&pdev->dev);\n\tif (!onkey->input) {\n\t\tdev_err(&pdev->dev, \"Failed to allocated input device.\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tonkey->input->name = onkey->config->name;\n\tsnprintf(onkey->phys, sizeof(onkey->phys), \"%s/input0\",\n\t\t onkey->config->name);\n\tonkey->input->phys = onkey->phys;\n\tonkey->input->dev.parent = &pdev->dev;\n\n\tinput_set_capability(onkey->input, EV_KEY, KEY_POWER);\n\n\terror = devm_delayed_work_autocancel(&pdev->dev, &onkey->work,\n\t\t\t\t\t     da9063_poll_on);\n\tif (error) {\n\t\tdev_err(&pdev->dev,\n\t\t\t\"Failed to add cancel poll action: %d\\n\",\n\t\t\terror);\n\t\treturn error;\n\t}\n\n\tirq = platform_get_irq_byname(pdev, \"ONKEY\");\n\tif (irq < 0)\n\t\treturn irq;\n\n\terror = devm_request_threaded_irq(&pdev->dev, irq,\n\t\t\t\t\t  NULL, da9063_onkey_irq_handler,\n\t\t\t\t\t  IRQF_TRIGGER_LOW | IRQF_ONESHOT,\n\t\t\t\t\t  \"ONKEY\", onkey);\n\tif (error) {\n\t\tdev_err(&pdev->dev,\n\t\t\t\"Failed to request IRQ %d: %d\\n\", irq, error);\n\t\treturn error;\n\t}\n\n\terror = dev_pm_set_wake_irq(&pdev->dev, irq);\n\tif (error)\n\t\tdev_warn(&pdev->dev,\n\t\t\t \"Failed to set IRQ %d as a wake IRQ: %d\\n\",\n\t\t\t irq, error);\n\telse\n\t\tdevice_init_wakeup(&pdev->dev, true);\n\n\terror = input_register_device(onkey->input);\n\tif (error) {\n\t\tdev_err(&pdev->dev,\n\t\t\t\"Failed to register input device: %d\\n\", error);\n\t\treturn error;\n\t}\n\n\treturn 0;\n}\n\nstatic struct platform_driver da9063_onkey_driver = {\n\t.probe\t= da9063_onkey_probe,\n\t.driver\t= {\n\t\t.name\t= DA9063_DRVNAME_ONKEY,\n\t\t.of_match_table = da9063_compatible_reg_id_table,\n\t},\n};\nmodule_platform_driver(da9063_onkey_driver);\n\nMODULE_AUTHOR(\"S Twiss <stwiss.opensource@diasemi.com>\");\nMODULE_DESCRIPTION(\"Onkey device driver for Dialog DA9063, DA9062 and DA9061\");\nMODULE_LICENSE(\"GPL\");\nMODULE_ALIAS(\"platform:\" DA9063_DRVNAME_ONKEY);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}