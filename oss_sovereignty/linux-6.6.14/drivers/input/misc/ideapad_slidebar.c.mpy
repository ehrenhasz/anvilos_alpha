{
  "module_name": "ideapad_slidebar.c",
  "hash_id": "6e38ccc5f4c3e6d5f1c6fe0f364af689dfe882f14ca1d86459208fa84d4a6055",
  "original_prompt": "Ingested from linux-6.6.14/drivers/input/misc/ideapad_slidebar.c",
  "human_readable_source": "\n \n\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/dmi.h>\n#include <linux/spinlock.h>\n#include <linux/platform_device.h>\n#include <linux/input.h>\n#include <linux/io.h>\n#include <linux/ioport.h>\n#include <linux/i8042.h>\n#include <linux/serio.h>\n\n#define IDEAPAD_BASE\t0xff29\n\nstatic bool force;\nmodule_param(force, bool, 0);\nMODULE_PARM_DESC(force, \"Force driver load, ignore DMI data\");\n\nstatic DEFINE_SPINLOCK(io_lock);\n\nstatic struct input_dev *slidebar_input_dev;\nstatic struct platform_device *slidebar_platform_dev;\n\nstatic u8 slidebar_pos_get(void)\n{\n\tu8 res;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&io_lock, flags);\n\toutb(0xf4, 0xff29);\n\toutb(0xbf, 0xff2a);\n\tres = inb(0xff2b);\n\tspin_unlock_irqrestore(&io_lock, flags);\n\n\treturn res;\n}\n\nstatic u8 slidebar_mode_get(void)\n{\n\tu8 res;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&io_lock, flags);\n\toutb(0xf7, 0xff29);\n\toutb(0x8b, 0xff2a);\n\tres = inb(0xff2b);\n\tspin_unlock_irqrestore(&io_lock, flags);\n\n\treturn res;\n}\n\nstatic void slidebar_mode_set(u8 mode)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&io_lock, flags);\n\toutb(0xf7, 0xff29);\n\toutb(0x8b, 0xff2a);\n\toutb(mode, 0xff2b);\n\tspin_unlock_irqrestore(&io_lock, flags);\n}\n\nstatic bool slidebar_i8042_filter(unsigned char data, unsigned char str,\n\t\t\t\t  struct serio *port)\n{\n\tstatic bool extended = false;\n\n\t \n\tif (str & I8042_STR_AUXDATA)\n\t\treturn false;\n\n\t \n\tif (data == 0xe0) {\n\t\textended = true;\n\t\treturn true;\n\t}\n\n\tif (!extended)\n\t\treturn false;\n\n\textended = false;\n\n\tif (likely((data & 0x7f) != 0x3b)) {\n\t\tserio_interrupt(port, 0xe0, 0);\n\t\treturn false;\n\t}\n\n\tif (data & 0x80) {\n\t\tinput_report_key(slidebar_input_dev, BTN_TOUCH, 0);\n\t} else {\n\t\tinput_report_key(slidebar_input_dev, BTN_TOUCH, 1);\n\t\tinput_report_abs(slidebar_input_dev, ABS_X, slidebar_pos_get());\n\t}\n\tinput_sync(slidebar_input_dev);\n\n\treturn true;\n}\n\nstatic ssize_t show_slidebar_mode(struct device *dev,\n\t\t\t\t  struct device_attribute *attr,\n\t\t\t\t  char *buf)\n{\n\treturn sprintf(buf, \"%x\\n\", slidebar_mode_get());\n}\n\nstatic ssize_t store_slidebar_mode(struct device *dev,\n\t\t\t\t   struct device_attribute *attr,\n\t\t\t\t   const char *buf, size_t count)\n{\n\tu8 mode;\n\tint error;\n\n\terror = kstrtou8(buf, 0, &mode);\n\tif (error)\n\t\treturn error;\n\n\tslidebar_mode_set(mode);\n\n\treturn count;\n}\n\nstatic DEVICE_ATTR(slidebar_mode, S_IWUSR | S_IRUGO,\n\t\t   show_slidebar_mode, store_slidebar_mode);\n\nstatic struct attribute *ideapad_attrs[] = {\n\t&dev_attr_slidebar_mode.attr,\n\tNULL\n};\n\nstatic struct attribute_group ideapad_attr_group = {\n\t.attrs = ideapad_attrs\n};\n\nstatic const struct attribute_group *ideapad_attr_groups[] = {\n\t&ideapad_attr_group,\n\tNULL\n};\n\nstatic int __init ideapad_probe(struct platform_device* pdev)\n{\n\tint err;\n\n\tif (!request_region(IDEAPAD_BASE, 3, \"ideapad_slidebar\")) {\n\t\tdev_err(&pdev->dev, \"IO ports are busy\\n\");\n\t\treturn -EBUSY;\n\t}\n\n\tslidebar_input_dev = input_allocate_device();\n\tif (!slidebar_input_dev) {\n\t\tdev_err(&pdev->dev, \"Failed to allocate input device\\n\");\n\t\terr = -ENOMEM;\n\t\tgoto err_release_ports;\n\t}\n\n\tslidebar_input_dev->name = \"IdeaPad Slidebar\";\n\tslidebar_input_dev->id.bustype = BUS_HOST;\n\tslidebar_input_dev->dev.parent = &pdev->dev;\n\tinput_set_capability(slidebar_input_dev, EV_KEY, BTN_TOUCH);\n\tinput_set_capability(slidebar_input_dev, EV_ABS, ABS_X);\n\tinput_set_abs_params(slidebar_input_dev, ABS_X, 0, 0xff, 0, 0);\n\n\terr = i8042_install_filter(slidebar_i8042_filter);\n\tif (err) {\n\t\tdev_err(&pdev->dev,\n\t\t\t\"Failed to install i8042 filter: %d\\n\", err);\n\t\tgoto err_free_dev;\n\t}\n\n\terr = input_register_device(slidebar_input_dev);\n\tif (err) {\n\t\tdev_err(&pdev->dev,\n\t\t\t\"Failed to register input device: %d\\n\", err);\n\t\tgoto err_remove_filter;\n\t}\n\n\treturn 0;\n\nerr_remove_filter:\n\ti8042_remove_filter(slidebar_i8042_filter);\nerr_free_dev:\n\tinput_free_device(slidebar_input_dev);\nerr_release_ports:\n\trelease_region(IDEAPAD_BASE, 3);\n\treturn err;\n}\n\nstatic int ideapad_remove(struct platform_device *pdev)\n{\n\ti8042_remove_filter(slidebar_i8042_filter);\n\tinput_unregister_device(slidebar_input_dev);\n\trelease_region(IDEAPAD_BASE, 3);\n\n\treturn 0;\n}\n\nstatic struct platform_driver slidebar_drv = {\n\t.driver = {\n\t\t.name = \"ideapad_slidebar\",\n\t},\n\t.remove = ideapad_remove,\n};\n\nstatic int __init ideapad_dmi_check(const struct dmi_system_id *id)\n{\n\tpr_info(\"Laptop model '%s'\\n\", id->ident);\n\treturn 1;\n}\n\nstatic const struct dmi_system_id ideapad_dmi[] __initconst = {\n\t{\n\t\t.ident = \"Lenovo IdeaPad Y550\",\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"LENOVO\"),\n\t\t\tDMI_MATCH(DMI_PRODUCT_NAME, \"20017\"),\n\t\t\tDMI_MATCH(DMI_PRODUCT_VERSION, \"Lenovo IdeaPad Y550\")\n\t\t},\n\t\t.callback = ideapad_dmi_check\n\t},\n\t{\n\t\t.ident = \"Lenovo IdeaPad Y550P\",\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"LENOVO\"),\n\t\t\tDMI_MATCH(DMI_PRODUCT_NAME, \"20035\"),\n\t\t\tDMI_MATCH(DMI_PRODUCT_VERSION, \"Lenovo IdeaPad Y550P\")\n\t\t},\n\t\t.callback = ideapad_dmi_check\n\t},\n\t{ NULL, }\n};\nMODULE_DEVICE_TABLE(dmi, ideapad_dmi);\n\nstatic int __init slidebar_init(void)\n{\n\tint err;\n\n\tif (!force && !dmi_check_system(ideapad_dmi)) {\n\t\tpr_err(\"DMI does not match\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tslidebar_platform_dev = platform_device_alloc(\"ideapad_slidebar\", -1);\n\tif (!slidebar_platform_dev) {\n\t\tpr_err(\"Not enough memory\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tslidebar_platform_dev->dev.groups = ideapad_attr_groups;\n\n\terr = platform_device_add(slidebar_platform_dev);\n\tif (err) {\n\t\tpr_err(\"Failed to register platform device\\n\");\n\t\tgoto err_free_dev;\n\t}\n\n\terr = platform_driver_probe(&slidebar_drv, ideapad_probe);\n\tif (err) {\n\t\tpr_err(\"Failed to register platform driver\\n\");\n\t\tgoto err_delete_dev;\n\t}\n\n\treturn 0;\n\nerr_delete_dev:\n\tplatform_device_del(slidebar_platform_dev);\nerr_free_dev:\n\tplatform_device_put(slidebar_platform_dev);\n\treturn err;\n}\n\nstatic void __exit slidebar_exit(void)\n{\n\tplatform_device_unregister(slidebar_platform_dev);\n\tplatform_driver_unregister(&slidebar_drv);\n}\n\nmodule_init(slidebar_init);\nmodule_exit(slidebar_exit);\n\nMODULE_AUTHOR(\"Andrey Moiseev <o2g.org.ru@gmail.com>\");\nMODULE_DESCRIPTION(\"Slidebar input support for some Lenovo IdeaPad laptops\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}