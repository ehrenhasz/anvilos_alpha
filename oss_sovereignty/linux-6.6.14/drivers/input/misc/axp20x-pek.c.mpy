{
  "module_name": "axp20x-pek.c",
  "hash_id": "be8d7494bc6ded0046a5cfd80f054efdc1d91000714b7792c7bae18d9880b025",
  "original_prompt": "Ingested from linux-6.6.14/drivers/input/misc/axp20x-pek.c",
  "human_readable_source": " \n\n#include <linux/acpi.h>\n#include <linux/errno.h>\n#include <linux/irq.h>\n#include <linux/init.h>\n#include <linux/input.h>\n#include <linux/interrupt.h>\n#include <linux/kernel.h>\n#include <linux/mfd/axp20x.h>\n#include <linux/module.h>\n#include <linux/platform_data/x86/soc.h>\n#include <linux/platform_device.h>\n#include <linux/regmap.h>\n#include <linux/slab.h>\n\n#define AXP20X_PEK_STARTUP_MASK\t\t(0xc0)\n#define AXP20X_PEK_SHUTDOWN_MASK\t(0x03)\n\nstruct axp20x_info {\n\tconst struct axp20x_time *startup_time;\n\tunsigned int startup_mask;\n\tconst struct axp20x_time *shutdown_time;\n\tunsigned int shutdown_mask;\n};\n\nstruct axp20x_pek {\n\tstruct axp20x_dev *axp20x;\n\tstruct input_dev *input;\n\tstruct axp20x_info *info;\n\tint irq_dbr;\n\tint irq_dbf;\n};\n\nstruct axp20x_time {\n\tunsigned int time;\n\tunsigned int idx;\n};\n\nstatic const struct axp20x_time startup_time[] = {\n\t{ .time = 128,  .idx = 0 },\n\t{ .time = 1000, .idx = 2 },\n\t{ .time = 3000, .idx = 1 },\n\t{ .time = 2000, .idx = 3 },\n};\n\nstatic const struct axp20x_time axp221_startup_time[] = {\n\t{ .time = 128,  .idx = 0 },\n\t{ .time = 1000, .idx = 1 },\n\t{ .time = 2000, .idx = 2 },\n\t{ .time = 3000, .idx = 3 },\n};\n\nstatic const struct axp20x_time shutdown_time[] = {\n\t{ .time = 4000,  .idx = 0 },\n\t{ .time = 6000,  .idx = 1 },\n\t{ .time = 8000,  .idx = 2 },\n\t{ .time = 10000, .idx = 3 },\n};\n\nstatic const struct axp20x_info axp20x_info = {\n\t.startup_time = startup_time,\n\t.startup_mask = AXP20X_PEK_STARTUP_MASK,\n\t.shutdown_time = shutdown_time,\n\t.shutdown_mask = AXP20X_PEK_SHUTDOWN_MASK,\n};\n\nstatic const struct axp20x_info axp221_info = {\n\t.startup_time = axp221_startup_time,\n\t.startup_mask = AXP20X_PEK_STARTUP_MASK,\n\t.shutdown_time = shutdown_time,\n\t.shutdown_mask = AXP20X_PEK_SHUTDOWN_MASK,\n};\n\nstatic ssize_t axp20x_show_attr(struct device *dev,\n\t\t\t\tconst struct axp20x_time *time,\n\t\t\t\tunsigned int mask, char *buf)\n{\n\tstruct axp20x_pek *axp20x_pek = dev_get_drvdata(dev);\n\tunsigned int val;\n\tint ret, i;\n\n\tret = regmap_read(axp20x_pek->axp20x->regmap, AXP20X_PEK_KEY, &val);\n\tif (ret != 0)\n\t\treturn ret;\n\n\tval &= mask;\n\tval >>= ffs(mask) - 1;\n\n\tfor (i = 0; i < 4; i++)\n\t\tif (val == time[i].idx)\n\t\t\tval = time[i].time;\n\n\treturn sprintf(buf, \"%u\\n\", val);\n}\n\nstatic ssize_t axp20x_show_attr_startup(struct device *dev,\n\t\t\t\t\tstruct device_attribute *attr,\n\t\t\t\t\tchar *buf)\n{\n\tstruct axp20x_pek *axp20x_pek = dev_get_drvdata(dev);\n\n\treturn axp20x_show_attr(dev, axp20x_pek->info->startup_time,\n\t\t\t\taxp20x_pek->info->startup_mask, buf);\n}\n\nstatic ssize_t axp20x_show_attr_shutdown(struct device *dev,\n\t\t\t\t\t struct device_attribute *attr,\n\t\t\t\t\t char *buf)\n{\n\tstruct axp20x_pek *axp20x_pek = dev_get_drvdata(dev);\n\n\treturn axp20x_show_attr(dev, axp20x_pek->info->shutdown_time,\n\t\t\t\taxp20x_pek->info->shutdown_mask, buf);\n}\n\nstatic ssize_t axp20x_store_attr(struct device *dev,\n\t\t\t\t const struct axp20x_time *time,\n\t\t\t\t unsigned int mask, const char *buf,\n\t\t\t\t size_t count)\n{\n\tstruct axp20x_pek *axp20x_pek = dev_get_drvdata(dev);\n\tchar val_str[20];\n\tsize_t len;\n\tint ret, i;\n\tunsigned int val, idx = 0;\n\tunsigned int best_err = UINT_MAX;\n\n\tval_str[sizeof(val_str) - 1] = '\\0';\n\tstrncpy(val_str, buf, sizeof(val_str) - 1);\n\tlen = strlen(val_str);\n\n\tif (len && val_str[len - 1] == '\\n')\n\t\tval_str[len - 1] = '\\0';\n\n\tret = kstrtouint(val_str, 10, &val);\n\tif (ret)\n\t\treturn ret;\n\n\tfor (i = 3; i >= 0; i--) {\n\t\tunsigned int err;\n\n\t\terr = abs(time[i].time - val);\n\t\tif (err < best_err) {\n\t\t\tbest_err = err;\n\t\t\tidx = time[i].idx;\n\t\t}\n\n\t\tif (!err)\n\t\t\tbreak;\n\t}\n\n\tidx <<= ffs(mask) - 1;\n\tret = regmap_update_bits(axp20x_pek->axp20x->regmap, AXP20X_PEK_KEY,\n\t\t\t\t mask, idx);\n\tif (ret != 0)\n\t\treturn -EINVAL;\n\n\treturn count;\n}\n\nstatic ssize_t axp20x_store_attr_startup(struct device *dev,\n\t\t\t\t\t struct device_attribute *attr,\n\t\t\t\t\t const char *buf, size_t count)\n{\n\tstruct axp20x_pek *axp20x_pek = dev_get_drvdata(dev);\n\n\treturn axp20x_store_attr(dev, axp20x_pek->info->startup_time,\n\t\t\t\t axp20x_pek->info->startup_mask, buf, count);\n}\n\nstatic ssize_t axp20x_store_attr_shutdown(struct device *dev,\n\t\t\t\t\t  struct device_attribute *attr,\n\t\t\t\t\t  const char *buf, size_t count)\n{\n\tstruct axp20x_pek *axp20x_pek = dev_get_drvdata(dev);\n\n\treturn axp20x_store_attr(dev, axp20x_pek->info->shutdown_time,\n\t\t\t\t axp20x_pek->info->shutdown_mask, buf, count);\n}\n\nstatic DEVICE_ATTR(startup, 0644, axp20x_show_attr_startup,\n\t\t   axp20x_store_attr_startup);\nstatic DEVICE_ATTR(shutdown, 0644, axp20x_show_attr_shutdown,\n\t\t   axp20x_store_attr_shutdown);\n\nstatic struct attribute *axp20x_attrs[] = {\n\t&dev_attr_startup.attr,\n\t&dev_attr_shutdown.attr,\n\tNULL,\n};\nATTRIBUTE_GROUPS(axp20x);\n\nstatic irqreturn_t axp20x_pek_irq(int irq, void *pwr)\n{\n\tstruct input_dev *idev = pwr;\n\tstruct axp20x_pek *axp20x_pek = input_get_drvdata(idev);\n\n\t \n\tif (irq == axp20x_pek->irq_dbf)\n\t\tinput_report_key(idev, KEY_POWER, true);\n\telse if (irq == axp20x_pek->irq_dbr)\n\t\tinput_report_key(idev, KEY_POWER, false);\n\n\tinput_sync(idev);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int axp20x_pek_probe_input_device(struct axp20x_pek *axp20x_pek,\n\t\t\t\t\t struct platform_device *pdev)\n{\n\tstruct axp20x_dev *axp20x = axp20x_pek->axp20x;\n\tstruct input_dev *idev;\n\tint error;\n\n\taxp20x_pek->irq_dbr = platform_get_irq_byname(pdev, \"PEK_DBR\");\n\tif (axp20x_pek->irq_dbr < 0)\n\t\treturn axp20x_pek->irq_dbr;\n\taxp20x_pek->irq_dbr = regmap_irq_get_virq(axp20x->regmap_irqc,\n\t\t\t\t\t\t  axp20x_pek->irq_dbr);\n\n\taxp20x_pek->irq_dbf = platform_get_irq_byname(pdev, \"PEK_DBF\");\n\tif (axp20x_pek->irq_dbf < 0)\n\t\treturn axp20x_pek->irq_dbf;\n\taxp20x_pek->irq_dbf = regmap_irq_get_virq(axp20x->regmap_irqc,\n\t\t\t\t\t\t  axp20x_pek->irq_dbf);\n\n\taxp20x_pek->input = devm_input_allocate_device(&pdev->dev);\n\tif (!axp20x_pek->input)\n\t\treturn -ENOMEM;\n\n\tidev = axp20x_pek->input;\n\n\tidev->name = \"axp20x-pek\";\n\tidev->phys = \"m1kbd/input2\";\n\tidev->dev.parent = &pdev->dev;\n\n\tinput_set_capability(idev, EV_KEY, KEY_POWER);\n\n\tinput_set_drvdata(idev, axp20x_pek);\n\n\terror = devm_request_any_context_irq(&pdev->dev, axp20x_pek->irq_dbr,\n\t\t\t\t\t     axp20x_pek_irq, 0,\n\t\t\t\t\t     \"axp20x-pek-dbr\", idev);\n\tif (error < 0) {\n\t\tdev_err(&pdev->dev, \"Failed to request dbr IRQ#%d: %d\\n\",\n\t\t\taxp20x_pek->irq_dbr, error);\n\t\treturn error;\n\t}\n\n\terror = devm_request_any_context_irq(&pdev->dev, axp20x_pek->irq_dbf,\n\t\t\t\t\t  axp20x_pek_irq, 0,\n\t\t\t\t\t  \"axp20x-pek-dbf\", idev);\n\tif (error < 0) {\n\t\tdev_err(&pdev->dev, \"Failed to request dbf IRQ#%d: %d\\n\",\n\t\t\taxp20x_pek->irq_dbf, error);\n\t\treturn error;\n\t}\n\n\terror = input_register_device(idev);\n\tif (error) {\n\t\tdev_err(&pdev->dev, \"Can't register input device: %d\\n\",\n\t\t\terror);\n\t\treturn error;\n\t}\n\n\tdevice_init_wakeup(&pdev->dev, true);\n\n\treturn 0;\n}\n\nstatic bool axp20x_pek_should_register_input(struct axp20x_pek *axp20x_pek)\n{\n\tif (IS_ENABLED(CONFIG_INPUT_SOC_BUTTON_ARRAY) &&\n\t    axp20x_pek->axp20x->variant == AXP288_ID) {\n\t\t \n\t\tif (soc_intel_is_cht() &&\n\t\t\t\t(acpi_dev_present(\"INTCFD9\", NULL, -1) ||\n\t\t\t\t acpi_dev_present(\"ACPI0011\", NULL, -1)))\n\t\t\treturn false;\n\t}\n\n\treturn true;\n}\n\nstatic int axp20x_pek_probe(struct platform_device *pdev)\n{\n\tstruct axp20x_pek *axp20x_pek;\n\tconst struct platform_device_id *match = platform_get_device_id(pdev);\n\tint error;\n\n\tif (!match) {\n\t\tdev_err(&pdev->dev, \"Failed to get platform_device_id\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\taxp20x_pek = devm_kzalloc(&pdev->dev, sizeof(struct axp20x_pek),\n\t\t\t\t  GFP_KERNEL);\n\tif (!axp20x_pek)\n\t\treturn -ENOMEM;\n\n\taxp20x_pek->axp20x = dev_get_drvdata(pdev->dev.parent);\n\n\tif (axp20x_pek_should_register_input(axp20x_pek)) {\n\t\terror = axp20x_pek_probe_input_device(axp20x_pek, pdev);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\taxp20x_pek->info = (struct axp20x_info *)match->driver_data;\n\n\tplatform_set_drvdata(pdev, axp20x_pek);\n\n\treturn 0;\n}\n\nstatic int axp20x_pek_suspend(struct device *dev)\n{\n\tstruct axp20x_pek *axp20x_pek = dev_get_drvdata(dev);\n\n\t \n\tif (device_may_wakeup(dev)) {\n\t\tenable_irq_wake(axp20x_pek->irq_dbf);\n\t\tenable_irq_wake(axp20x_pek->irq_dbr);\n\t} else {\n\t\tdisable_irq(axp20x_pek->irq_dbf);\n\t\tdisable_irq(axp20x_pek->irq_dbr);\n\t}\n\n\treturn 0;\n}\n\nstatic int axp20x_pek_resume(struct device *dev)\n{\n\tstruct axp20x_pek *axp20x_pek = dev_get_drvdata(dev);\n\n\tif (device_may_wakeup(dev)) {\n\t\tdisable_irq_wake(axp20x_pek->irq_dbf);\n\t\tdisable_irq_wake(axp20x_pek->irq_dbr);\n\t} else {\n\t\tenable_irq(axp20x_pek->irq_dbf);\n\t\tenable_irq(axp20x_pek->irq_dbr);\n\t}\n\n\treturn 0;\n}\n\nstatic int __maybe_unused axp20x_pek_resume_noirq(struct device *dev)\n{\n\tstruct axp20x_pek *axp20x_pek = dev_get_drvdata(dev);\n\n\tif (axp20x_pek->axp20x->variant != AXP288_ID)\n\t\treturn 0;\n\n\t \n\tregmap_write(axp20x_pek->axp20x->regmap,\n\t\t     AXP20X_IRQ1_STATE + AXP288_IRQ_POKN / 8,\n\t\t     BIT(AXP288_IRQ_POKN % 8));\n\n\treturn 0;\n}\n\nstatic const struct dev_pm_ops axp20x_pek_pm_ops = {\n\tSYSTEM_SLEEP_PM_OPS(axp20x_pek_suspend, axp20x_pek_resume)\n\t.resume_noirq = pm_sleep_ptr(axp20x_pek_resume_noirq),\n};\n\nstatic const struct platform_device_id axp_pek_id_match[] = {\n\t{\n\t\t.name = \"axp20x-pek\",\n\t\t.driver_data = (kernel_ulong_t)&axp20x_info,\n\t},\n\t{\n\t\t.name = \"axp221-pek\",\n\t\t.driver_data = (kernel_ulong_t)&axp221_info,\n\t},\n\t{   }\n};\nMODULE_DEVICE_TABLE(platform, axp_pek_id_match);\n\nstatic struct platform_driver axp20x_pek_driver = {\n\t.probe\t\t= axp20x_pek_probe,\n\t.id_table\t= axp_pek_id_match,\n\t.driver\t\t= {\n\t\t.name\t\t= \"axp20x-pek\",\n\t\t.pm\t\t= pm_sleep_ptr(&axp20x_pek_pm_ops),\n\t\t.dev_groups\t= axp20x_groups,\n\t},\n};\nmodule_platform_driver(axp20x_pek_driver);\n\nMODULE_DESCRIPTION(\"axp20x Power Button\");\nMODULE_AUTHOR(\"Carlo Caione <carlo@caione.org>\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}