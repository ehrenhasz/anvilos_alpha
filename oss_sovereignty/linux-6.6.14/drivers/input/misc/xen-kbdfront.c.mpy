{
  "module_name": "xen-kbdfront.c",
  "hash_id": "a8645e29472bfe487d4de9aa871ee34ac98038267c399e83994a6bb1736ad9ab",
  "original_prompt": "Ingested from linux-6.6.14/drivers/input/misc/xen-kbdfront.c",
  "human_readable_source": " \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/kernel.h>\n#include <linux/errno.h>\n#include <linux/module.h>\n#include <linux/input.h>\n#include <linux/input/mt.h>\n#include <linux/slab.h>\n\n#include <asm/xen/hypervisor.h>\n\n#include <xen/xen.h>\n#include <xen/events.h>\n#include <xen/page.h>\n#include <xen/grant_table.h>\n#include <xen/interface/grant_table.h>\n#include <xen/interface/io/fbif.h>\n#include <xen/interface/io/kbdif.h>\n#include <xen/xenbus.h>\n#include <xen/platform_pci.h>\n\nstruct xenkbd_info {\n\tstruct input_dev *kbd;\n\tstruct input_dev *ptr;\n\tstruct input_dev *mtouch;\n\tstruct xenkbd_page *page;\n\tint gref;\n\tint irq;\n\tstruct xenbus_device *xbdev;\n\tchar phys[32];\n\t \n\tint mtouch_cur_contact_id;\n};\n\nenum { KPARAM_X, KPARAM_Y, KPARAM_CNT };\nstatic int ptr_size[KPARAM_CNT] = { XENFB_WIDTH, XENFB_HEIGHT };\nmodule_param_array(ptr_size, int, NULL, 0444);\nMODULE_PARM_DESC(ptr_size,\n\t\"Pointing device width, height in pixels (default 800,600)\");\n\nstatic void xenkbd_remove(struct xenbus_device *);\nstatic int xenkbd_connect_backend(struct xenbus_device *, struct xenkbd_info *);\nstatic void xenkbd_disconnect_backend(struct xenkbd_info *);\n\n \n\nstatic void xenkbd_handle_motion_event(struct xenkbd_info *info,\n\t\t\t\t       struct xenkbd_motion *motion)\n{\n\tif (unlikely(!info->ptr))\n\t\treturn;\n\n\tinput_report_rel(info->ptr, REL_X, motion->rel_x);\n\tinput_report_rel(info->ptr, REL_Y, motion->rel_y);\n\tif (motion->rel_z)\n\t\tinput_report_rel(info->ptr, REL_WHEEL, -motion->rel_z);\n\tinput_sync(info->ptr);\n}\n\nstatic void xenkbd_handle_position_event(struct xenkbd_info *info,\n\t\t\t\t\t struct xenkbd_position *pos)\n{\n\tif (unlikely(!info->ptr))\n\t\treturn;\n\n\tinput_report_abs(info->ptr, ABS_X, pos->abs_x);\n\tinput_report_abs(info->ptr, ABS_Y, pos->abs_y);\n\tif (pos->rel_z)\n\t\tinput_report_rel(info->ptr, REL_WHEEL, -pos->rel_z);\n\tinput_sync(info->ptr);\n}\n\nstatic void xenkbd_handle_key_event(struct xenkbd_info *info,\n\t\t\t\t    struct xenkbd_key *key)\n{\n\tstruct input_dev *dev;\n\tint value = key->pressed;\n\n\tif (test_bit(key->keycode, info->ptr->keybit)) {\n\t\tdev = info->ptr;\n\t} else if (test_bit(key->keycode, info->kbd->keybit)) {\n\t\tdev = info->kbd;\n\t\tif (key->pressed && test_bit(key->keycode, info->kbd->key))\n\t\t\tvalue = 2;  \n\t} else {\n\t\tpr_warn(\"unhandled keycode 0x%x\\n\", key->keycode);\n\t\treturn;\n\t}\n\n\tif (unlikely(!dev))\n\t\treturn;\n\n\tinput_event(dev, EV_KEY, key->keycode, value);\n\tinput_sync(dev);\n}\n\nstatic void xenkbd_handle_mt_event(struct xenkbd_info *info,\n\t\t\t\t   struct xenkbd_mtouch *mtouch)\n{\n\tif (unlikely(!info->mtouch))\n\t\treturn;\n\n\tif (mtouch->contact_id != info->mtouch_cur_contact_id) {\n\t\tinfo->mtouch_cur_contact_id = mtouch->contact_id;\n\t\tinput_mt_slot(info->mtouch, mtouch->contact_id);\n\t}\n\n\tswitch (mtouch->event_type) {\n\tcase XENKBD_MT_EV_DOWN:\n\t\tinput_mt_report_slot_state(info->mtouch, MT_TOOL_FINGER, true);\n\t\tfallthrough;\n\n\tcase XENKBD_MT_EV_MOTION:\n\t\tinput_report_abs(info->mtouch, ABS_MT_POSITION_X,\n\t\t\t\t mtouch->u.pos.abs_x);\n\t\tinput_report_abs(info->mtouch, ABS_MT_POSITION_Y,\n\t\t\t\t mtouch->u.pos.abs_y);\n\t\tbreak;\n\n\tcase XENKBD_MT_EV_SHAPE:\n\t\tinput_report_abs(info->mtouch, ABS_MT_TOUCH_MAJOR,\n\t\t\t\t mtouch->u.shape.major);\n\t\tinput_report_abs(info->mtouch, ABS_MT_TOUCH_MINOR,\n\t\t\t\t mtouch->u.shape.minor);\n\t\tbreak;\n\n\tcase XENKBD_MT_EV_ORIENT:\n\t\tinput_report_abs(info->mtouch, ABS_MT_ORIENTATION,\n\t\t\t\t mtouch->u.orientation);\n\t\tbreak;\n\n\tcase XENKBD_MT_EV_UP:\n\t\tinput_mt_report_slot_inactive(info->mtouch);\n\t\tbreak;\n\n\tcase XENKBD_MT_EV_SYN:\n\t\tinput_mt_sync_frame(info->mtouch);\n\t\tinput_sync(info->mtouch);\n\t\tbreak;\n\t}\n}\n\nstatic void xenkbd_handle_event(struct xenkbd_info *info,\n\t\t\t\tunion xenkbd_in_event *event)\n{\n\tswitch (event->type) {\n\tcase XENKBD_TYPE_MOTION:\n\t\txenkbd_handle_motion_event(info, &event->motion);\n\t\tbreak;\n\n\tcase XENKBD_TYPE_KEY:\n\t\txenkbd_handle_key_event(info, &event->key);\n\t\tbreak;\n\n\tcase XENKBD_TYPE_POS:\n\t\txenkbd_handle_position_event(info, &event->pos);\n\t\tbreak;\n\n\tcase XENKBD_TYPE_MTOUCH:\n\t\txenkbd_handle_mt_event(info, &event->mtouch);\n\t\tbreak;\n\t}\n}\n\nstatic irqreturn_t input_handler(int rq, void *dev_id)\n{\n\tstruct xenkbd_info *info = dev_id;\n\tstruct xenkbd_page *page = info->page;\n\t__u32 cons, prod;\n\n\tprod = page->in_prod;\n\tif (prod == page->in_cons)\n\t\treturn IRQ_HANDLED;\n\trmb();\t\t\t \n\tfor (cons = page->in_cons; cons != prod; cons++)\n\t\txenkbd_handle_event(info, &XENKBD_IN_RING_REF(page, cons));\n\tmb();\t\t\t \n\tpage->in_cons = cons;\n\tnotify_remote_via_irq(info->irq);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int xenkbd_probe(struct xenbus_device *dev,\n\t\t\t\t  const struct xenbus_device_id *id)\n{\n\tint ret, i;\n\tbool with_mtouch, with_kbd, with_ptr;\n\tstruct xenkbd_info *info;\n\tstruct input_dev *kbd, *ptr, *mtouch;\n\n\tinfo = kzalloc(sizeof(*info), GFP_KERNEL);\n\tif (!info) {\n\t\txenbus_dev_fatal(dev, -ENOMEM, \"allocating info structure\");\n\t\treturn -ENOMEM;\n\t}\n\tdev_set_drvdata(&dev->dev, info);\n\tinfo->xbdev = dev;\n\tinfo->irq = -1;\n\tinfo->gref = -1;\n\tsnprintf(info->phys, sizeof(info->phys), \"xenbus/%s\", dev->nodename);\n\n\tinfo->page = (void *)__get_free_page(GFP_KERNEL | __GFP_ZERO);\n\tif (!info->page)\n\t\tgoto error_nomem;\n\n\t \n\twith_kbd = !xenbus_read_unsigned(dev->otherend,\n\t\t\t\t\t XENKBD_FIELD_FEAT_DSBL_KEYBRD, 0);\n\n\twith_ptr = !xenbus_read_unsigned(dev->otherend,\n\t\t\t\t\t XENKBD_FIELD_FEAT_DSBL_POINTER, 0);\n\n\t \n\twith_mtouch = xenbus_read_unsigned(dev->otherend,\n\t\t\t\t\t   XENKBD_FIELD_FEAT_MTOUCH, 0);\n\tif (with_mtouch) {\n\t\tret = xenbus_write(XBT_NIL, dev->nodename,\n\t\t\t\t   XENKBD_FIELD_REQ_MTOUCH, \"1\");\n\t\tif (ret) {\n\t\t\tpr_warn(\"xenkbd: can't request multi-touch\");\n\t\t\twith_mtouch = 0;\n\t\t}\n\t}\n\n\t \n\tif (with_kbd) {\n\t\tkbd = input_allocate_device();\n\t\tif (!kbd)\n\t\t\tgoto error_nomem;\n\t\tkbd->name = \"Xen Virtual Keyboard\";\n\t\tkbd->phys = info->phys;\n\t\tkbd->id.bustype = BUS_PCI;\n\t\tkbd->id.vendor = 0x5853;\n\t\tkbd->id.product = 0xffff;\n\n\t\t__set_bit(EV_KEY, kbd->evbit);\n\t\tfor (i = KEY_ESC; i < KEY_UNKNOWN; i++)\n\t\t\t__set_bit(i, kbd->keybit);\n\t\tfor (i = KEY_OK; i < KEY_MAX; i++)\n\t\t\t__set_bit(i, kbd->keybit);\n\n\t\tret = input_register_device(kbd);\n\t\tif (ret) {\n\t\t\tinput_free_device(kbd);\n\t\t\txenbus_dev_fatal(dev, ret,\n\t\t\t\t\t \"input_register_device(kbd)\");\n\t\t\tgoto error;\n\t\t}\n\t\tinfo->kbd = kbd;\n\t}\n\n\t \n\tif (with_ptr) {\n\t\tunsigned int abs;\n\n\t\t \n\t\tabs = xenbus_read_unsigned(dev->otherend,\n\t\t\t\t\t   XENKBD_FIELD_FEAT_ABS_POINTER, 0);\n\t\tptr_size[KPARAM_X] = xenbus_read_unsigned(dev->otherend,\n\t\t\t\t\t\t\t  XENKBD_FIELD_WIDTH,\n\t\t\t\t\t\t\t  ptr_size[KPARAM_X]);\n\t\tptr_size[KPARAM_Y] = xenbus_read_unsigned(dev->otherend,\n\t\t\t\t\t\t\t  XENKBD_FIELD_HEIGHT,\n\t\t\t\t\t\t\t  ptr_size[KPARAM_Y]);\n\t\tif (abs) {\n\t\t\tret = xenbus_write(XBT_NIL, dev->nodename,\n\t\t\t\t\t   XENKBD_FIELD_REQ_ABS_POINTER, \"1\");\n\t\t\tif (ret) {\n\t\t\t\tpr_warn(\"xenkbd: can't request abs-pointer\\n\");\n\t\t\t\tabs = 0;\n\t\t\t}\n\t\t}\n\n\t\tptr = input_allocate_device();\n\t\tif (!ptr)\n\t\t\tgoto error_nomem;\n\t\tptr->name = \"Xen Virtual Pointer\";\n\t\tptr->phys = info->phys;\n\t\tptr->id.bustype = BUS_PCI;\n\t\tptr->id.vendor = 0x5853;\n\t\tptr->id.product = 0xfffe;\n\n\t\tif (abs) {\n\t\t\t__set_bit(EV_ABS, ptr->evbit);\n\t\t\tinput_set_abs_params(ptr, ABS_X, 0,\n\t\t\t\t\t     ptr_size[KPARAM_X], 0, 0);\n\t\t\tinput_set_abs_params(ptr, ABS_Y, 0,\n\t\t\t\t\t     ptr_size[KPARAM_Y], 0, 0);\n\t\t} else {\n\t\t\tinput_set_capability(ptr, EV_REL, REL_X);\n\t\t\tinput_set_capability(ptr, EV_REL, REL_Y);\n\t\t}\n\t\tinput_set_capability(ptr, EV_REL, REL_WHEEL);\n\n\t\t__set_bit(EV_KEY, ptr->evbit);\n\t\tfor (i = BTN_LEFT; i <= BTN_TASK; i++)\n\t\t\t__set_bit(i, ptr->keybit);\n\n\t\tret = input_register_device(ptr);\n\t\tif (ret) {\n\t\t\tinput_free_device(ptr);\n\t\t\txenbus_dev_fatal(dev, ret,\n\t\t\t\t\t \"input_register_device(ptr)\");\n\t\t\tgoto error;\n\t\t}\n\t\tinfo->ptr = ptr;\n\t}\n\n\t \n\tif (with_mtouch) {\n\t\tint num_cont, width, height;\n\n\t\tmtouch = input_allocate_device();\n\t\tif (!mtouch)\n\t\t\tgoto error_nomem;\n\n\t\tnum_cont = xenbus_read_unsigned(info->xbdev->otherend,\n\t\t\t\t\t\tXENKBD_FIELD_MT_NUM_CONTACTS,\n\t\t\t\t\t\t1);\n\t\twidth = xenbus_read_unsigned(info->xbdev->otherend,\n\t\t\t\t\t     XENKBD_FIELD_MT_WIDTH,\n\t\t\t\t\t     XENFB_WIDTH);\n\t\theight = xenbus_read_unsigned(info->xbdev->otherend,\n\t\t\t\t\t      XENKBD_FIELD_MT_HEIGHT,\n\t\t\t\t\t      XENFB_HEIGHT);\n\n\t\tmtouch->name = \"Xen Virtual Multi-touch\";\n\t\tmtouch->phys = info->phys;\n\t\tmtouch->id.bustype = BUS_PCI;\n\t\tmtouch->id.vendor = 0x5853;\n\t\tmtouch->id.product = 0xfffd;\n\n\t\tinput_set_abs_params(mtouch, ABS_MT_TOUCH_MAJOR,\n\t\t\t\t     0, 255, 0, 0);\n\t\tinput_set_abs_params(mtouch, ABS_MT_POSITION_X,\n\t\t\t\t     0, width, 0, 0);\n\t\tinput_set_abs_params(mtouch, ABS_MT_POSITION_Y,\n\t\t\t\t     0, height, 0, 0);\n\n\t\tret = input_mt_init_slots(mtouch, num_cont, INPUT_MT_DIRECT);\n\t\tif (ret) {\n\t\t\tinput_free_device(mtouch);\n\t\t\txenbus_dev_fatal(info->xbdev, ret,\n\t\t\t\t\t \"input_mt_init_slots\");\n\t\t\tgoto error;\n\t\t}\n\n\t\tret = input_register_device(mtouch);\n\t\tif (ret) {\n\t\t\tinput_free_device(mtouch);\n\t\t\txenbus_dev_fatal(info->xbdev, ret,\n\t\t\t\t\t \"input_register_device(mtouch)\");\n\t\t\tgoto error;\n\t\t}\n\t\tinfo->mtouch_cur_contact_id = -1;\n\t\tinfo->mtouch = mtouch;\n\t}\n\n\tif (!(with_kbd || with_ptr || with_mtouch)) {\n\t\tret = -ENXIO;\n\t\tgoto error;\n\t}\n\n\tret = xenkbd_connect_backend(dev, info);\n\tif (ret < 0)\n\t\tgoto error;\n\n\treturn 0;\n\n error_nomem:\n\tret = -ENOMEM;\n\txenbus_dev_fatal(dev, ret, \"allocating device memory\");\n error:\n\txenkbd_remove(dev);\n\treturn ret;\n}\n\nstatic int xenkbd_resume(struct xenbus_device *dev)\n{\n\tstruct xenkbd_info *info = dev_get_drvdata(&dev->dev);\n\n\txenkbd_disconnect_backend(info);\n\tmemset(info->page, 0, PAGE_SIZE);\n\treturn xenkbd_connect_backend(dev, info);\n}\n\nstatic void xenkbd_remove(struct xenbus_device *dev)\n{\n\tstruct xenkbd_info *info = dev_get_drvdata(&dev->dev);\n\n\txenkbd_disconnect_backend(info);\n\tif (info->kbd)\n\t\tinput_unregister_device(info->kbd);\n\tif (info->ptr)\n\t\tinput_unregister_device(info->ptr);\n\tif (info->mtouch)\n\t\tinput_unregister_device(info->mtouch);\n\tfree_page((unsigned long)info->page);\n\tkfree(info);\n}\n\nstatic int xenkbd_connect_backend(struct xenbus_device *dev,\n\t\t\t\t  struct xenkbd_info *info)\n{\n\tint ret, evtchn;\n\tstruct xenbus_transaction xbt;\n\n\tret = gnttab_grant_foreign_access(dev->otherend_id,\n\t                                  virt_to_gfn(info->page), 0);\n\tif (ret < 0)\n\t\treturn ret;\n\tinfo->gref = ret;\n\n\tret = xenbus_alloc_evtchn(dev, &evtchn);\n\tif (ret)\n\t\tgoto error_grant;\n\tret = bind_evtchn_to_irqhandler(evtchn, input_handler,\n\t\t\t\t\t0, dev->devicetype, info);\n\tif (ret < 0) {\n\t\txenbus_dev_fatal(dev, ret, \"bind_evtchn_to_irqhandler\");\n\t\tgoto error_evtchan;\n\t}\n\tinfo->irq = ret;\n\n again:\n\tret = xenbus_transaction_start(&xbt);\n\tif (ret) {\n\t\txenbus_dev_fatal(dev, ret, \"starting transaction\");\n\t\tgoto error_irqh;\n\t}\n\tret = xenbus_printf(xbt, dev->nodename, XENKBD_FIELD_RING_REF, \"%lu\",\n\t\t\t    virt_to_gfn(info->page));\n\tif (ret)\n\t\tgoto error_xenbus;\n\tret = xenbus_printf(xbt, dev->nodename, XENKBD_FIELD_RING_GREF,\n\t\t\t    \"%u\", info->gref);\n\tif (ret)\n\t\tgoto error_xenbus;\n\tret = xenbus_printf(xbt, dev->nodename, XENKBD_FIELD_EVT_CHANNEL, \"%u\",\n\t\t\t    evtchn);\n\tif (ret)\n\t\tgoto error_xenbus;\n\tret = xenbus_transaction_end(xbt, 0);\n\tif (ret) {\n\t\tif (ret == -EAGAIN)\n\t\t\tgoto again;\n\t\txenbus_dev_fatal(dev, ret, \"completing transaction\");\n\t\tgoto error_irqh;\n\t}\n\n\txenbus_switch_state(dev, XenbusStateInitialised);\n\treturn 0;\n\n error_xenbus:\n\txenbus_transaction_end(xbt, 1);\n\txenbus_dev_fatal(dev, ret, \"writing xenstore\");\n error_irqh:\n\tunbind_from_irqhandler(info->irq, info);\n\tinfo->irq = -1;\n error_evtchan:\n\txenbus_free_evtchn(dev, evtchn);\n error_grant:\n\tgnttab_end_foreign_access(info->gref, NULL);\n\tinfo->gref = -1;\n\treturn ret;\n}\n\nstatic void xenkbd_disconnect_backend(struct xenkbd_info *info)\n{\n\tif (info->irq >= 0)\n\t\tunbind_from_irqhandler(info->irq, info);\n\tinfo->irq = -1;\n\tif (info->gref >= 0)\n\t\tgnttab_end_foreign_access(info->gref, NULL);\n\tinfo->gref = -1;\n}\n\nstatic void xenkbd_backend_changed(struct xenbus_device *dev,\n\t\t\t\t   enum xenbus_state backend_state)\n{\n\tswitch (backend_state) {\n\tcase XenbusStateInitialising:\n\tcase XenbusStateInitialised:\n\tcase XenbusStateReconfiguring:\n\tcase XenbusStateReconfigured:\n\tcase XenbusStateUnknown:\n\t\tbreak;\n\n\tcase XenbusStateInitWait:\n\t\txenbus_switch_state(dev, XenbusStateConnected);\n\t\tbreak;\n\n\tcase XenbusStateConnected:\n\t\t \n\t\tif (dev->state != XenbusStateConnected)\n\t\t\txenbus_switch_state(dev, XenbusStateConnected);\n\t\tbreak;\n\n\tcase XenbusStateClosed:\n\t\tif (dev->state == XenbusStateClosed)\n\t\t\tbreak;\n\t\tfallthrough;\t \n\tcase XenbusStateClosing:\n\t\txenbus_frontend_closed(dev);\n\t\tbreak;\n\t}\n}\n\nstatic const struct xenbus_device_id xenkbd_ids[] = {\n\t{ XENKBD_DRIVER_NAME },\n\t{ \"\" }\n};\n\nstatic struct xenbus_driver xenkbd_driver = {\n\t.ids = xenkbd_ids,\n\t.probe = xenkbd_probe,\n\t.remove = xenkbd_remove,\n\t.resume = xenkbd_resume,\n\t.otherend_changed = xenkbd_backend_changed,\n\t.not_essential = true,\n};\n\nstatic int __init xenkbd_init(void)\n{\n\tif (!xen_domain())\n\t\treturn -ENODEV;\n\n\t \n\tif (xen_initial_domain())\n\t\treturn -ENODEV;\n\n\tif (!xen_has_pv_devices())\n\t\treturn -ENODEV;\n\n\treturn xenbus_register_frontend(&xenkbd_driver);\n}\n\nstatic void __exit xenkbd_cleanup(void)\n{\n\txenbus_unregister_driver(&xenkbd_driver);\n}\n\nmodule_init(xenkbd_init);\nmodule_exit(xenkbd_cleanup);\n\nMODULE_DESCRIPTION(\"Xen virtual keyboard/pointer device frontend\");\nMODULE_LICENSE(\"GPL\");\nMODULE_ALIAS(\"xen:\" XENKBD_DRIVER_NAME);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}