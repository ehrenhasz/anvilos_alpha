{
  "module_name": "keyspan_remote.c",
  "hash_id": "66e12bd5b5539d39134ee7f736f127a8b5b2605d21af0ce29adb1dabef4bf936",
  "original_prompt": "Ingested from linux-6.6.14/drivers/input/misc/keyspan_remote.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/errno.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/usb/input.h>\n\n \nstatic int debug;\nmodule_param(debug, int, 0444);\nMODULE_PARM_DESC(debug, \"Enable extra debug messages and information\");\n\n \n#define USB_KEYSPAN_VENDOR_ID\t\t0x06CD\n#define USB_KEYSPAN_PRODUCT_UIA11\t0x0202\n\n \n#define ZERO\t\t0x18\n#define ZERO_MASK\t0x1F\t \n#define ONE\t\t0x3C\n#define ONE_MASK\t0x3F\t \n#define SYNC\t\t0x3F80\n#define SYNC_MASK\t0x3FFF\t \n#define STOP\t\t0x00\n#define STOP_MASK\t0x1F\t \n#define GAP\t\t0xFF\n\n#define RECV_SIZE\t8\t \n\n \nstatic const unsigned short keyspan_key_table[] = {\n\tKEY_RESERVED,\t\t \n\tKEY_RESERVED,\n\tKEY_STOP,\n\tKEY_PLAYCD,\n\tKEY_RESERVED,\n\tKEY_PREVIOUSSONG,\n\tKEY_REWIND,\n\tKEY_FORWARD,\n\tKEY_NEXTSONG,\n\tKEY_RESERVED,\n\tKEY_RESERVED,\n\tKEY_RESERVED,\n\tKEY_PAUSE,\n\tKEY_VOLUMEUP,\n\tKEY_RESERVED,\n\tKEY_RESERVED,\n\tKEY_RESERVED,\n\tKEY_VOLUMEDOWN,\n\tKEY_RESERVED,\n\tKEY_UP,\n\tKEY_RESERVED,\n\tKEY_MUTE,\n\tKEY_LEFT,\n\tKEY_ENTER,\n\tKEY_RIGHT,\n\tKEY_RESERVED,\n\tKEY_RESERVED,\n\tKEY_DOWN,\n\tKEY_RESERVED,\n\tKEY_KPASTERISK,\n\tKEY_RESERVED,\n\tKEY_MENU\n};\n\n \nstatic const struct usb_device_id keyspan_table[] = {\n\t{ USB_DEVICE(USB_KEYSPAN_VENDOR_ID, USB_KEYSPAN_PRODUCT_UIA11) },\n\t{ }\t\t\t\t\t \n};\n\n \nstruct keyspan_message {\n\tu16\tsystem;\n\tu8\tbutton;\n\tu8\ttoggle;\n};\n\n \nstruct bit_tester {\n\tu32\ttester;\n\tint\tlen;\n\tint\tpos;\n\tint\tbits_left;\n\tu8\tbuffer[32];\n};\n\n \nstruct usb_keyspan {\n\tchar\t\t\t\tname[128];\n\tchar\t\t\t\tphys[64];\n\tunsigned short\t\t\tkeymap[ARRAY_SIZE(keyspan_key_table)];\n\tstruct usb_device\t\t*udev;\n\tstruct input_dev\t\t*input;\n\tstruct usb_interface\t\t*interface;\n\tstruct usb_endpoint_descriptor\t*in_endpoint;\n\tstruct urb*\t\t\tirq_urb;\n\tint\t\t\t\topen;\n\tdma_addr_t\t\t\tin_dma;\n\tunsigned char\t\t\t*in_buffer;\n\n\t \n\tstruct bit_tester\t\tdata;\n\tint\t\t\t\tstage;\n\tint\t\t\t\ttoggle;\n};\n\nstatic struct usb_driver keyspan_driver;\n\n \nstatic void keyspan_print(struct usb_keyspan* dev)  \n{\n\tchar codes[4 * RECV_SIZE];\n\tint i;\n\n\tfor (i = 0; i < RECV_SIZE; i++)\n\t\tsnprintf(codes + i * 3, 4, \"%02x \", dev->in_buffer[i]);\n\n\tdev_info(&dev->udev->dev, \"%s\\n\", codes);\n}\n\n \nstatic int keyspan_load_tester(struct usb_keyspan* dev, int bits_needed)\n{\n\tif (dev->data.bits_left >= bits_needed)\n\t\treturn 0;\n\n\t \n\tif (dev->data.pos >= dev->data.len) {\n\t\tdev_dbg(&dev->interface->dev,\n\t\t\t\"%s - Error ran out of data. pos: %d, len: %d\\n\",\n\t\t\t__func__, dev->data.pos, dev->data.len);\n\t\treturn -1;\n\t}\n\n\t \n\twhile ((dev->data.bits_left + 7 < (sizeof(dev->data.tester) * 8)) &&\n\t       (dev->data.pos < dev->data.len)) {\n\t\tdev->data.tester += (dev->data.buffer[dev->data.pos++] << dev->data.bits_left);\n\t\tdev->data.bits_left += 8;\n\t}\n\n\treturn 0;\n}\n\nstatic void keyspan_report_button(struct usb_keyspan *remote, int button, int press)\n{\n\tstruct input_dev *input = remote->input;\n\n\tinput_event(input, EV_MSC, MSC_SCAN, button);\n\tinput_report_key(input, remote->keymap[button], press);\n\tinput_sync(input);\n}\n\n \nstatic void keyspan_check_data(struct usb_keyspan *remote)\n{\n\tint i;\n\tint found = 0;\n\tstruct keyspan_message message;\n\n\tswitch(remote->stage) {\n\tcase 0:\n\t\t \n\t\tfor (i = 0; i < RECV_SIZE && remote->in_buffer[i] == GAP; ++i);\n\n\t\tif (i < RECV_SIZE) {\n\t\t\tmemcpy(remote->data.buffer, remote->in_buffer, RECV_SIZE);\n\t\t\tremote->data.len = RECV_SIZE;\n\t\t\tremote->data.pos = 0;\n\t\t\tremote->data.tester = 0;\n\t\t\tremote->data.bits_left = 0;\n\t\t\tremote->stage = 1;\n\t\t}\n\t\tbreak;\n\n\tcase 1:\n\t\t \n\t\tmemcpy(remote->data.buffer + remote->data.len, remote->in_buffer, RECV_SIZE);\n\t\tremote->data.len += RECV_SIZE;\n\n\t\tfound = 0;\n\t\twhile ((remote->data.bits_left >= 14 || remote->data.pos < remote->data.len) && !found) {\n\t\t\tfor (i = 0; i < 8; ++i) {\n\t\t\t\tif (keyspan_load_tester(remote, 14) != 0) {\n\t\t\t\t\tremote->stage = 0;\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tif ((remote->data.tester & SYNC_MASK) == SYNC) {\n\t\t\t\t\tremote->data.tester = remote->data.tester >> 14;\n\t\t\t\t\tremote->data.bits_left -= 14;\n\t\t\t\t\tfound = 1;\n\t\t\t\t\tbreak;\n\t\t\t\t} else {\n\t\t\t\t\tremote->data.tester = remote->data.tester >> 1;\n\t\t\t\t\t--remote->data.bits_left;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (!found) {\n\t\t\tremote->stage = 0;\n\t\t\tremote->data.len = 0;\n\t\t} else {\n\t\t\tremote->stage = 2;\n\t\t}\n\t\tbreak;\n\n\tcase 2:\n\t\t \n\t\tmemcpy(remote->data.buffer + remote->data.len, remote->in_buffer, RECV_SIZE);\n\t\tremote->data.len += RECV_SIZE;\n\n\t\tmessage.system = 0;\n\t\tfor (i = 0; i < 9; i++) {\n\t\t\tkeyspan_load_tester(remote, 6);\n\n\t\t\tif ((remote->data.tester & ZERO_MASK) == ZERO) {\n\t\t\t\tmessage.system = message.system << 1;\n\t\t\t\tremote->data.tester = remote->data.tester >> 5;\n\t\t\t\tremote->data.bits_left -= 5;\n\t\t\t} else if ((remote->data.tester & ONE_MASK) == ONE) {\n\t\t\t\tmessage.system = (message.system << 1) + 1;\n\t\t\t\tremote->data.tester = remote->data.tester >> 6;\n\t\t\t\tremote->data.bits_left -= 6;\n\t\t\t} else {\n\t\t\t\tdev_err(&remote->interface->dev,\n\t\t\t\t\t\"%s - Unknown sequence found in system data.\\n\",\n\t\t\t\t\t__func__);\n\t\t\t\tremote->stage = 0;\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\tmessage.button = 0;\n\t\tfor (i = 0; i < 5; i++) {\n\t\t\tkeyspan_load_tester(remote, 6);\n\n\t\t\tif ((remote->data.tester & ZERO_MASK) == ZERO) {\n\t\t\t\tmessage.button = message.button << 1;\n\t\t\t\tremote->data.tester = remote->data.tester >> 5;\n\t\t\t\tremote->data.bits_left -= 5;\n\t\t\t} else if ((remote->data.tester & ONE_MASK) == ONE) {\n\t\t\t\tmessage.button = (message.button << 1) + 1;\n\t\t\t\tremote->data.tester = remote->data.tester >> 6;\n\t\t\t\tremote->data.bits_left -= 6;\n\t\t\t} else {\n\t\t\t\tdev_err(&remote->interface->dev,\n\t\t\t\t\t\"%s - Unknown sequence found in button data.\\n\",\n\t\t\t\t\t__func__);\n\t\t\t\tremote->stage = 0;\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\tkeyspan_load_tester(remote, 6);\n\t\tif ((remote->data.tester & ZERO_MASK) == ZERO) {\n\t\t\tmessage.toggle = 0;\n\t\t\tremote->data.tester = remote->data.tester >> 5;\n\t\t\tremote->data.bits_left -= 5;\n\t\t} else if ((remote->data.tester & ONE_MASK) == ONE) {\n\t\t\tmessage.toggle = 1;\n\t\t\tremote->data.tester = remote->data.tester >> 6;\n\t\t\tremote->data.bits_left -= 6;\n\t\t} else {\n\t\t\tdev_err(&remote->interface->dev,\n\t\t\t\t\"%s - Error in message, invalid toggle.\\n\",\n\t\t\t\t__func__);\n\t\t\tremote->stage = 0;\n\t\t\treturn;\n\t\t}\n\n\t\tkeyspan_load_tester(remote, 5);\n\t\tif ((remote->data.tester & STOP_MASK) == STOP) {\n\t\t\tremote->data.tester = remote->data.tester >> 5;\n\t\t\tremote->data.bits_left -= 5;\n\t\t} else {\n\t\t\tdev_err(&remote->interface->dev,\n\t\t\t\t\"Bad message received, no stop bit found.\\n\");\n\t\t}\n\n\t\tdev_dbg(&remote->interface->dev,\n\t\t\t\"%s found valid message: system: %d, button: %d, toggle: %d\\n\",\n\t\t\t__func__, message.system, message.button, message.toggle);\n\n\t\tif (message.toggle != remote->toggle) {\n\t\t\tkeyspan_report_button(remote, message.button, 1);\n\t\t\tkeyspan_report_button(remote, message.button, 0);\n\t\t\tremote->toggle = message.toggle;\n\t\t}\n\n\t\tremote->stage = 0;\n\t\tbreak;\n\t}\n}\n\n \nstatic int keyspan_setup(struct usb_device* dev)\n{\n\tint retval = 0;\n\n\tretval = usb_control_msg(dev, usb_sndctrlpipe(dev, 0),\n\t\t\t\t 0x11, 0x40, 0x5601, 0x0, NULL, 0,\n\t\t\t\t USB_CTRL_SET_TIMEOUT);\n\tif (retval) {\n\t\tdev_dbg(&dev->dev, \"%s - failed to set bit rate due to error: %d\\n\",\n\t\t\t__func__, retval);\n\t\treturn(retval);\n\t}\n\n\tretval = usb_control_msg(dev, usb_sndctrlpipe(dev, 0),\n\t\t\t\t 0x44, 0x40, 0x0, 0x0, NULL, 0,\n\t\t\t\t USB_CTRL_SET_TIMEOUT);\n\tif (retval) {\n\t\tdev_dbg(&dev->dev, \"%s - failed to set resume sensitivity due to error: %d\\n\",\n\t\t\t__func__, retval);\n\t\treturn(retval);\n\t}\n\n\tretval = usb_control_msg(dev, usb_sndctrlpipe(dev, 0),\n\t\t\t\t 0x22, 0x40, 0x0, 0x0, NULL, 0,\n\t\t\t\t USB_CTRL_SET_TIMEOUT);\n\tif (retval) {\n\t\tdev_dbg(&dev->dev, \"%s - failed to turn receive on due to error: %d\\n\",\n\t\t\t__func__, retval);\n\t\treturn(retval);\n\t}\n\n\tdev_dbg(&dev->dev, \"%s - Setup complete.\\n\", __func__);\n\treturn(retval);\n}\n\n \nstatic void keyspan_irq_recv(struct urb *urb)\n{\n\tstruct usb_keyspan *dev = urb->context;\n\tint retval;\n\n\t \n\tswitch (urb->status) {\n\tcase 0:\n\t\tbreak;\n\n\t \n\tcase -ECONNRESET:\n\tcase -ENOENT:\n\tcase -ESHUTDOWN:\n\t\treturn;\n\n\tdefault:\n\t\tgoto resubmit;\n\t}\n\n\tif (debug)\n\t\tkeyspan_print(dev);\n\n\tkeyspan_check_data(dev);\n\nresubmit:\n\tretval = usb_submit_urb(urb, GFP_ATOMIC);\n\tif (retval)\n\t\tdev_err(&dev->interface->dev,\n\t\t\t\"%s - usb_submit_urb failed with result: %d\\n\",\n\t\t\t__func__, retval);\n}\n\nstatic int keyspan_open(struct input_dev *dev)\n{\n\tstruct usb_keyspan *remote = input_get_drvdata(dev);\n\n\tremote->irq_urb->dev = remote->udev;\n\tif (usb_submit_urb(remote->irq_urb, GFP_KERNEL))\n\t\treturn -EIO;\n\n\treturn 0;\n}\n\nstatic void keyspan_close(struct input_dev *dev)\n{\n\tstruct usb_keyspan *remote = input_get_drvdata(dev);\n\n\tusb_kill_urb(remote->irq_urb);\n}\n\nstatic struct usb_endpoint_descriptor *keyspan_get_in_endpoint(struct usb_host_interface *iface)\n{\n\n\tstruct usb_endpoint_descriptor *endpoint;\n\tint i;\n\n\tfor (i = 0; i < iface->desc.bNumEndpoints; ++i) {\n\t\tendpoint = &iface->endpoint[i].desc;\n\n\t\tif (usb_endpoint_is_int_in(endpoint)) {\n\t\t\t \n\t\t\treturn endpoint;\n\t\t}\n\t}\n\n\treturn NULL;\n}\n\n \nstatic int keyspan_probe(struct usb_interface *interface, const struct usb_device_id *id)\n{\n\tstruct usb_device *udev = interface_to_usbdev(interface);\n\tstruct usb_endpoint_descriptor *endpoint;\n\tstruct usb_keyspan *remote;\n\tstruct input_dev *input_dev;\n\tint i, error;\n\n\tendpoint = keyspan_get_in_endpoint(interface->cur_altsetting);\n\tif (!endpoint)\n\t\treturn -ENODEV;\n\n\tremote = kzalloc(sizeof(*remote), GFP_KERNEL);\n\tinput_dev = input_allocate_device();\n\tif (!remote || !input_dev) {\n\t\terror = -ENOMEM;\n\t\tgoto fail1;\n\t}\n\n\tremote->udev = udev;\n\tremote->input = input_dev;\n\tremote->interface = interface;\n\tremote->in_endpoint = endpoint;\n\tremote->toggle = -1;\t \n\n\tremote->in_buffer = usb_alloc_coherent(udev, RECV_SIZE, GFP_KERNEL, &remote->in_dma);\n\tif (!remote->in_buffer) {\n\t\terror = -ENOMEM;\n\t\tgoto fail1;\n\t}\n\n\tremote->irq_urb = usb_alloc_urb(0, GFP_KERNEL);\n\tif (!remote->irq_urb) {\n\t\terror = -ENOMEM;\n\t\tgoto fail2;\n\t}\n\n\terror = keyspan_setup(udev);\n\tif (error) {\n\t\terror = -ENODEV;\n\t\tgoto fail3;\n\t}\n\n\tif (udev->manufacturer)\n\t\tstrscpy(remote->name, udev->manufacturer, sizeof(remote->name));\n\n\tif (udev->product) {\n\t\tif (udev->manufacturer)\n\t\t\tstrlcat(remote->name, \" \", sizeof(remote->name));\n\t\tstrlcat(remote->name, udev->product, sizeof(remote->name));\n\t}\n\n\tif (!strlen(remote->name))\n\t\tsnprintf(remote->name, sizeof(remote->name),\n\t\t\t \"USB Keyspan Remote %04x:%04x\",\n\t\t\t le16_to_cpu(udev->descriptor.idVendor),\n\t\t\t le16_to_cpu(udev->descriptor.idProduct));\n\n\tusb_make_path(udev, remote->phys, sizeof(remote->phys));\n\tstrlcat(remote->phys, \"/input0\", sizeof(remote->phys));\n\tmemcpy(remote->keymap, keyspan_key_table, sizeof(remote->keymap));\n\n\tinput_dev->name = remote->name;\n\tinput_dev->phys = remote->phys;\n\tusb_to_input_id(udev, &input_dev->id);\n\tinput_dev->dev.parent = &interface->dev;\n\tinput_dev->keycode = remote->keymap;\n\tinput_dev->keycodesize = sizeof(unsigned short);\n\tinput_dev->keycodemax = ARRAY_SIZE(remote->keymap);\n\n\tinput_set_capability(input_dev, EV_MSC, MSC_SCAN);\n\t__set_bit(EV_KEY, input_dev->evbit);\n\tfor (i = 0; i < ARRAY_SIZE(keyspan_key_table); i++)\n\t\t__set_bit(keyspan_key_table[i], input_dev->keybit);\n\t__clear_bit(KEY_RESERVED, input_dev->keybit);\n\n\tinput_set_drvdata(input_dev, remote);\n\n\tinput_dev->open = keyspan_open;\n\tinput_dev->close = keyspan_close;\n\n\t \n\tusb_fill_int_urb(remote->irq_urb,\n\t\t\t remote->udev,\n\t\t\t usb_rcvintpipe(remote->udev, endpoint->bEndpointAddress),\n\t\t\t remote->in_buffer, RECV_SIZE, keyspan_irq_recv, remote,\n\t\t\t endpoint->bInterval);\n\tremote->irq_urb->transfer_dma = remote->in_dma;\n\tremote->irq_urb->transfer_flags |= URB_NO_TRANSFER_DMA_MAP;\n\n\t \n\terror = input_register_device(remote->input);\n\tif (error)\n\t\tgoto fail3;\n\n\t \n\tusb_set_intfdata(interface, remote);\n\n\treturn 0;\n\n fail3:\tusb_free_urb(remote->irq_urb);\n fail2:\tusb_free_coherent(udev, RECV_SIZE, remote->in_buffer, remote->in_dma);\n fail1:\tkfree(remote);\n\tinput_free_device(input_dev);\n\n\treturn error;\n}\n\n \nstatic void keyspan_disconnect(struct usb_interface *interface)\n{\n\tstruct usb_keyspan *remote;\n\n\tremote = usb_get_intfdata(interface);\n\tusb_set_intfdata(interface, NULL);\n\n\tif (remote) {\t \n\t\tinput_unregister_device(remote->input);\n\t\tusb_kill_urb(remote->irq_urb);\n\t\tusb_free_urb(remote->irq_urb);\n\t\tusb_free_coherent(remote->udev, RECV_SIZE, remote->in_buffer, remote->in_dma);\n\t\tkfree(remote);\n\t}\n}\n\n \nstatic struct usb_driver keyspan_driver =\n{\n\t.name =\t\t\"keyspan_remote\",\n\t.probe =\tkeyspan_probe,\n\t.disconnect =\tkeyspan_disconnect,\n\t.id_table =\tkeyspan_table\n};\n\nmodule_usb_driver(keyspan_driver);\n\nMODULE_DEVICE_TABLE(usb, keyspan_table);\nMODULE_AUTHOR(\"Michael Downey <downey@zymeta.com>\");\nMODULE_DESCRIPTION(\"Driver for the USB Keyspan remote control.\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}