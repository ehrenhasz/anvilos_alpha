{
  "module_name": "da9055_onkey.c",
  "hash_id": "8e045da3a516746f005492b860275238fa26737ab429b029f269abd7eb96b4aa",
  "original_prompt": "Ingested from linux-6.6.14/drivers/input/misc/da9055_onkey.c",
  "human_readable_source": "\n \n\n#include <linux/input.h>\n#include <linux/module.h>\n#include <linux/platform_device.h>\n\n#include <linux/mfd/da9055/core.h>\n#include <linux/mfd/da9055/reg.h>\n\nstruct da9055_onkey {\n\tstruct da9055 *da9055;\n\tstruct input_dev *input;\n\tstruct delayed_work work;\n};\n\nstatic void da9055_onkey_query(struct da9055_onkey *onkey)\n{\n\tint key_stat;\n\n\tkey_stat = da9055_reg_read(onkey->da9055, DA9055_REG_STATUS_A);\n\tif (key_stat < 0) {\n\t\tdev_err(onkey->da9055->dev,\n\t\t\t\"Failed to read onkey event %d\\n\", key_stat);\n\t} else {\n\t\tkey_stat &= DA9055_NOKEY_STS;\n\t\t \n\t\tif (!key_stat) {\n\t\t\tinput_report_key(onkey->input, KEY_POWER, 0);\n\t\t\tinput_sync(onkey->input);\n\t\t}\n\t}\n\n\t \n\tif (key_stat)\n\t\tschedule_delayed_work(&onkey->work, msecs_to_jiffies(10));\n\n}\n\nstatic void da9055_onkey_work(struct work_struct *work)\n{\n\tstruct da9055_onkey *onkey = container_of(work, struct da9055_onkey,\n\t\t\t\t\t\t  work.work);\n\n\tda9055_onkey_query(onkey);\n}\n\nstatic irqreturn_t da9055_onkey_irq(int irq, void *data)\n{\n\tstruct da9055_onkey *onkey = data;\n\n\tinput_report_key(onkey->input, KEY_POWER, 1);\n\tinput_sync(onkey->input);\n\n\tda9055_onkey_query(onkey);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int da9055_onkey_probe(struct platform_device *pdev)\n{\n\tstruct da9055 *da9055 = dev_get_drvdata(pdev->dev.parent);\n\tstruct da9055_onkey *onkey;\n\tstruct input_dev *input_dev;\n\tint irq, err;\n\n\tirq = platform_get_irq_byname(pdev, \"ONKEY\");\n\tif (irq < 0)\n\t\treturn -EINVAL;\n\n\tonkey = devm_kzalloc(&pdev->dev, sizeof(*onkey), GFP_KERNEL);\n\tif (!onkey) {\n\t\tdev_err(&pdev->dev, \"Failed to allocate memory\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tinput_dev = input_allocate_device();\n\tif (!input_dev) {\n\t\tdev_err(&pdev->dev, \"Failed to allocate memory\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tonkey->input = input_dev;\n\tonkey->da9055 = da9055;\n\tinput_dev->name = \"da9055-onkey\";\n\tinput_dev->phys = \"da9055-onkey/input0\";\n\tinput_dev->dev.parent = &pdev->dev;\n\n\tinput_dev->evbit[0] = BIT_MASK(EV_KEY);\n\t__set_bit(KEY_POWER, input_dev->keybit);\n\n\tINIT_DELAYED_WORK(&onkey->work, da9055_onkey_work);\n\n\terr = request_threaded_irq(irq, NULL, da9055_onkey_irq,\n\t\t\t\t   IRQF_TRIGGER_HIGH | IRQF_ONESHOT,\n\t\t\t\t   \"ONKEY\", onkey);\n\tif (err < 0) {\n\t\tdev_err(&pdev->dev,\n\t\t\t\"Failed to register ONKEY IRQ %d, error = %d\\n\",\n\t\t\tirq, err);\n\t\tgoto err_free_input;\n\t}\n\n\terr = input_register_device(input_dev);\n\tif (err) {\n\t\tdev_err(&pdev->dev, \"Unable to register input device, %d\\n\",\n\t\t\terr);\n\t\tgoto err_free_irq;\n\t}\n\n\tplatform_set_drvdata(pdev, onkey);\n\n\treturn 0;\n\nerr_free_irq:\n\tfree_irq(irq, onkey);\n\tcancel_delayed_work_sync(&onkey->work);\nerr_free_input:\n\tinput_free_device(input_dev);\n\n\treturn err;\n}\n\nstatic int da9055_onkey_remove(struct platform_device *pdev)\n{\n\tstruct da9055_onkey *onkey = platform_get_drvdata(pdev);\n\tint irq = platform_get_irq_byname(pdev, \"ONKEY\");\n\n\tirq = regmap_irq_get_virq(onkey->da9055->irq_data, irq);\n\tfree_irq(irq, onkey);\n\tcancel_delayed_work_sync(&onkey->work);\n\tinput_unregister_device(onkey->input);\n\n\treturn 0;\n}\n\nstatic struct platform_driver da9055_onkey_driver = {\n\t.probe\t= da9055_onkey_probe,\n\t.remove\t= da9055_onkey_remove,\n\t.driver = {\n\t\t.name\t= \"da9055-onkey\",\n\t},\n};\n\nmodule_platform_driver(da9055_onkey_driver);\n\nMODULE_AUTHOR(\"David Dajun Chen <dchen@diasemi.com>\");\nMODULE_DESCRIPTION(\"Onkey driver for DA9055\");\nMODULE_LICENSE(\"GPL\");\nMODULE_ALIAS(\"platform:da9055-onkey\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}