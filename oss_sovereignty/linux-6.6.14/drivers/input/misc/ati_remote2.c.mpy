{
  "module_name": "ati_remote2.c",
  "hash_id": "89102b5b121a065f4610831c4b6ce98c6e4c4bb714e710248b48d8234f81a324",
  "original_prompt": "Ingested from linux-6.6.14/drivers/input/misc/ati_remote2.c",
  "human_readable_source": "\n \n\n#include <linux/usb/input.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\n#define DRIVER_DESC    \"ATI/Philips USB RF remote driver\"\n\nMODULE_DESCRIPTION(DRIVER_DESC);\nMODULE_AUTHOR(\"Ville Syrjala <syrjala@sci.fi>\");\nMODULE_LICENSE(\"GPL\");\n\n \n\nenum {\n\tATI_REMOTE2_MAX_CHANNEL_MASK = 0xFFFF,\n\tATI_REMOTE2_MAX_MODE_MASK = 0x1F,\n};\n\nstatic int ati_remote2_set_mask(const char *val,\n\t\t\t\tconst struct kernel_param *kp,\n\t\t\t\tunsigned int max)\n{\n\tunsigned int mask;\n\tint ret;\n\n\tif (!val)\n\t\treturn -EINVAL;\n\n\tret = kstrtouint(val, 0, &mask);\n\tif (ret)\n\t\treturn ret;\n\n\tif (mask & ~max)\n\t\treturn -EINVAL;\n\n\t*(unsigned int *)kp->arg = mask;\n\n\treturn 0;\n}\n\nstatic int ati_remote2_set_channel_mask(const char *val,\n\t\t\t\t\tconst struct kernel_param *kp)\n{\n\tpr_debug(\"%s()\\n\", __func__);\n\n\treturn ati_remote2_set_mask(val, kp, ATI_REMOTE2_MAX_CHANNEL_MASK);\n}\n\nstatic int ati_remote2_get_channel_mask(char *buffer,\n\t\t\t\t\tconst struct kernel_param *kp)\n{\n\tpr_debug(\"%s()\\n\", __func__);\n\n\treturn sprintf(buffer, \"0x%04x\\n\", *(unsigned int *)kp->arg);\n}\n\nstatic int ati_remote2_set_mode_mask(const char *val,\n\t\t\t\t     const struct kernel_param *kp)\n{\n\tpr_debug(\"%s()\\n\", __func__);\n\n\treturn ati_remote2_set_mask(val, kp, ATI_REMOTE2_MAX_MODE_MASK);\n}\n\nstatic int ati_remote2_get_mode_mask(char *buffer,\n\t\t\t\t     const struct kernel_param *kp)\n{\n\tpr_debug(\"%s()\\n\", __func__);\n\n\treturn sprintf(buffer, \"0x%02x\\n\", *(unsigned int *)kp->arg);\n}\n\nstatic unsigned int channel_mask = ATI_REMOTE2_MAX_CHANNEL_MASK;\n#define param_check_channel_mask(name, p) __param_check(name, p, unsigned int)\nstatic const struct kernel_param_ops param_ops_channel_mask = {\n\t.set = ati_remote2_set_channel_mask,\n\t.get = ati_remote2_get_channel_mask,\n};\nmodule_param(channel_mask, channel_mask, 0644);\nMODULE_PARM_DESC(channel_mask, \"Bitmask of channels to accept <15:Channel16>...<1:Channel2><0:Channel1>\");\n\nstatic unsigned int mode_mask = ATI_REMOTE2_MAX_MODE_MASK;\n#define param_check_mode_mask(name, p) __param_check(name, p, unsigned int)\nstatic const struct kernel_param_ops param_ops_mode_mask = {\n\t.set = ati_remote2_set_mode_mask,\n\t.get = ati_remote2_get_mode_mask,\n};\nmodule_param(mode_mask, mode_mask, 0644);\nMODULE_PARM_DESC(mode_mask, \"Bitmask of modes to accept <4:PC><3:AUX4><2:AUX3><1:AUX2><0:AUX1>\");\n\nstatic const struct usb_device_id ati_remote2_id_table[] = {\n\t{ USB_DEVICE(0x0471, 0x0602) },\t \n\t{ }\n};\nMODULE_DEVICE_TABLE(usb, ati_remote2_id_table);\n\nstatic DEFINE_MUTEX(ati_remote2_mutex);\n\nenum {\n\tATI_REMOTE2_OPENED = 0x1,\n\tATI_REMOTE2_SUSPENDED = 0x2,\n};\n\nenum {\n\tATI_REMOTE2_AUX1,\n\tATI_REMOTE2_AUX2,\n\tATI_REMOTE2_AUX3,\n\tATI_REMOTE2_AUX4,\n\tATI_REMOTE2_PC,\n\tATI_REMOTE2_MODES,\n};\n\nstatic const struct {\n\tu8  hw_code;\n\tu16 keycode;\n} ati_remote2_key_table[] = {\n\t{ 0x00, KEY_0 },\n\t{ 0x01, KEY_1 },\n\t{ 0x02, KEY_2 },\n\t{ 0x03, KEY_3 },\n\t{ 0x04, KEY_4 },\n\t{ 0x05, KEY_5 },\n\t{ 0x06, KEY_6 },\n\t{ 0x07, KEY_7 },\n\t{ 0x08, KEY_8 },\n\t{ 0x09, KEY_9 },\n\t{ 0x0c, KEY_POWER },\n\t{ 0x0d, KEY_MUTE },\n\t{ 0x10, KEY_VOLUMEUP },\n\t{ 0x11, KEY_VOLUMEDOWN },\n\t{ 0x20, KEY_CHANNELUP },\n\t{ 0x21, KEY_CHANNELDOWN },\n\t{ 0x28, KEY_FORWARD },\n\t{ 0x29, KEY_REWIND },\n\t{ 0x2c, KEY_PLAY },\n\t{ 0x30, KEY_PAUSE },\n\t{ 0x31, KEY_STOP },\n\t{ 0x37, KEY_RECORD },\n\t{ 0x38, KEY_DVD },\n\t{ 0x39, KEY_TV },\n\t{ 0x3f, KEY_PROG1 },  \n\t{ 0x54, KEY_MENU },\n\t{ 0x58, KEY_UP },\n\t{ 0x59, KEY_DOWN },\n\t{ 0x5a, KEY_LEFT },\n\t{ 0x5b, KEY_RIGHT },\n\t{ 0x5c, KEY_OK },\n\t{ 0x78, KEY_A },\n\t{ 0x79, KEY_B },\n\t{ 0x7a, KEY_C },\n\t{ 0x7b, KEY_D },\n\t{ 0x7c, KEY_E },\n\t{ 0x7d, KEY_F },\n\t{ 0x82, KEY_ENTER },\n\t{ 0x8e, KEY_VENDOR },\n\t{ 0x96, KEY_COFFEE },\n\t{ 0xa9, BTN_LEFT },\n\t{ 0xaa, BTN_RIGHT },\n\t{ 0xbe, KEY_QUESTION },\n\t{ 0xd0, KEY_EDIT },\n\t{ 0xd5, KEY_FRONT },\n\t{ 0xf9, KEY_INFO },\n};\n\nstruct ati_remote2 {\n\tstruct input_dev *idev;\n\tstruct usb_device *udev;\n\n\tstruct usb_interface *intf[2];\n\tstruct usb_endpoint_descriptor *ep[2];\n\tstruct urb *urb[2];\n\tvoid *buf[2];\n\tdma_addr_t buf_dma[2];\n\n\tunsigned long jiffies;\n\tint mode;\n\n\tchar name[64];\n\tchar phys[64];\n\n\t \n\tu16 keycode[ATI_REMOTE2_MODES][ARRAY_SIZE(ati_remote2_key_table)];\n\n\tunsigned int flags;\n\n\tunsigned int channel_mask;\n\tunsigned int mode_mask;\n};\n\nstatic int ati_remote2_probe(struct usb_interface *interface, const struct usb_device_id *id);\nstatic void ati_remote2_disconnect(struct usb_interface *interface);\nstatic int ati_remote2_suspend(struct usb_interface *interface, pm_message_t message);\nstatic int ati_remote2_resume(struct usb_interface *interface);\nstatic int ati_remote2_reset_resume(struct usb_interface *interface);\nstatic int ati_remote2_pre_reset(struct usb_interface *interface);\nstatic int ati_remote2_post_reset(struct usb_interface *interface);\n\nstatic struct usb_driver ati_remote2_driver = {\n\t.name       = \"ati_remote2\",\n\t.probe      = ati_remote2_probe,\n\t.disconnect = ati_remote2_disconnect,\n\t.id_table   = ati_remote2_id_table,\n\t.suspend    = ati_remote2_suspend,\n\t.resume     = ati_remote2_resume,\n\t.reset_resume = ati_remote2_reset_resume,\n\t.pre_reset  = ati_remote2_pre_reset,\n\t.post_reset = ati_remote2_post_reset,\n\t.supports_autosuspend = 1,\n};\n\nstatic int ati_remote2_submit_urbs(struct ati_remote2 *ar2)\n{\n\tint r;\n\n\tr = usb_submit_urb(ar2->urb[0], GFP_KERNEL);\n\tif (r) {\n\t\tdev_err(&ar2->intf[0]->dev,\n\t\t\t\"%s(): usb_submit_urb() = %d\\n\", __func__, r);\n\t\treturn r;\n\t}\n\tr = usb_submit_urb(ar2->urb[1], GFP_KERNEL);\n\tif (r) {\n\t\tusb_kill_urb(ar2->urb[0]);\n\t\tdev_err(&ar2->intf[1]->dev,\n\t\t\t\"%s(): usb_submit_urb() = %d\\n\", __func__, r);\n\t\treturn r;\n\t}\n\n\treturn 0;\n}\n\nstatic void ati_remote2_kill_urbs(struct ati_remote2 *ar2)\n{\n\tusb_kill_urb(ar2->urb[1]);\n\tusb_kill_urb(ar2->urb[0]);\n}\n\nstatic int ati_remote2_open(struct input_dev *idev)\n{\n\tstruct ati_remote2 *ar2 = input_get_drvdata(idev);\n\tint r;\n\n\tdev_dbg(&ar2->intf[0]->dev, \"%s()\\n\", __func__);\n\n\tr = usb_autopm_get_interface(ar2->intf[0]);\n\tif (r) {\n\t\tdev_err(&ar2->intf[0]->dev,\n\t\t\t\"%s(): usb_autopm_get_interface() = %d\\n\", __func__, r);\n\t\tgoto fail1;\n\t}\n\n\tmutex_lock(&ati_remote2_mutex);\n\n\tif (!(ar2->flags & ATI_REMOTE2_SUSPENDED)) {\n\t\tr = ati_remote2_submit_urbs(ar2);\n\t\tif (r)\n\t\t\tgoto fail2;\n\t}\n\n\tar2->flags |= ATI_REMOTE2_OPENED;\n\n\tmutex_unlock(&ati_remote2_mutex);\n\n\tusb_autopm_put_interface(ar2->intf[0]);\n\n\treturn 0;\n\n fail2:\n\tmutex_unlock(&ati_remote2_mutex);\n\tusb_autopm_put_interface(ar2->intf[0]);\n fail1:\n\treturn r;\n}\n\nstatic void ati_remote2_close(struct input_dev *idev)\n{\n\tstruct ati_remote2 *ar2 = input_get_drvdata(idev);\n\n\tdev_dbg(&ar2->intf[0]->dev, \"%s()\\n\", __func__);\n\n\tmutex_lock(&ati_remote2_mutex);\n\n\tif (!(ar2->flags & ATI_REMOTE2_SUSPENDED))\n\t\tati_remote2_kill_urbs(ar2);\n\n\tar2->flags &= ~ATI_REMOTE2_OPENED;\n\n\tmutex_unlock(&ati_remote2_mutex);\n}\n\nstatic void ati_remote2_input_mouse(struct ati_remote2 *ar2)\n{\n\tstruct input_dev *idev = ar2->idev;\n\tu8 *data = ar2->buf[0];\n\tint channel, mode;\n\n\tchannel = data[0] >> 4;\n\n\tif (!((1 << channel) & ar2->channel_mask))\n\t\treturn;\n\n\tmode = data[0] & 0x0F;\n\n\tif (mode > ATI_REMOTE2_PC) {\n\t\tdev_err(&ar2->intf[0]->dev,\n\t\t\t\"Unknown mode byte (%02x %02x %02x %02x)\\n\",\n\t\t\tdata[3], data[2], data[1], data[0]);\n\t\treturn;\n\t}\n\n\tif (!((1 << mode) & ar2->mode_mask))\n\t\treturn;\n\n\tinput_event(idev, EV_REL, REL_X, (s8) data[1]);\n\tinput_event(idev, EV_REL, REL_Y, (s8) data[2]);\n\tinput_sync(idev);\n}\n\nstatic int ati_remote2_lookup(unsigned int hw_code)\n{\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(ati_remote2_key_table); i++)\n\t\tif (ati_remote2_key_table[i].hw_code == hw_code)\n\t\t\treturn i;\n\n\treturn -1;\n}\n\nstatic void ati_remote2_input_key(struct ati_remote2 *ar2)\n{\n\tstruct input_dev *idev = ar2->idev;\n\tu8 *data = ar2->buf[1];\n\tint channel, mode, hw_code, index;\n\n\tchannel = data[0] >> 4;\n\n\tif (!((1 << channel) & ar2->channel_mask))\n\t\treturn;\n\n\tmode = data[0] & 0x0F;\n\n\tif (mode > ATI_REMOTE2_PC) {\n\t\tdev_err(&ar2->intf[1]->dev,\n\t\t\t\"Unknown mode byte (%02x %02x %02x %02x)\\n\",\n\t\t\tdata[3], data[2], data[1], data[0]);\n\t\treturn;\n\t}\n\n\thw_code = data[2];\n\tif (hw_code == 0x3f) {\n\t\t \n\t\tif (ar2->mode == mode)\n\t\t\treturn;\n\n\t\tif (data[1] == 0)\n\t\t\tar2->mode = mode;\n\t}\n\n\tif (!((1 << mode) & ar2->mode_mask))\n\t\treturn;\n\n\tindex = ati_remote2_lookup(hw_code);\n\tif (index < 0) {\n\t\tdev_err(&ar2->intf[1]->dev,\n\t\t\t\"Unknown code byte (%02x %02x %02x %02x)\\n\",\n\t\t\tdata[3], data[2], data[1], data[0]);\n\t\treturn;\n\t}\n\n\tswitch (data[1]) {\n\tcase 0:\t \n\t\tbreak;\n\tcase 1:\t \n\t\tar2->jiffies = jiffies + msecs_to_jiffies(idev->rep[REP_DELAY]);\n\t\tbreak;\n\tcase 2:\t \n\n\t\t \n\t\tif (ar2->keycode[mode][index] == BTN_LEFT ||\n\t\t    ar2->keycode[mode][index] == BTN_RIGHT)\n\t\t\treturn;\n\n\t\tif (!time_after_eq(jiffies, ar2->jiffies))\n\t\t\treturn;\n\n\t\tar2->jiffies = jiffies + msecs_to_jiffies(idev->rep[REP_PERIOD]);\n\t\tbreak;\n\tdefault:\n\t\tdev_err(&ar2->intf[1]->dev,\n\t\t\t\"Unknown state byte (%02x %02x %02x %02x)\\n\",\n\t\t\tdata[3], data[2], data[1], data[0]);\n\t\treturn;\n\t}\n\n\tinput_event(idev, EV_KEY, ar2->keycode[mode][index], data[1]);\n\tinput_sync(idev);\n}\n\nstatic void ati_remote2_complete_mouse(struct urb *urb)\n{\n\tstruct ati_remote2 *ar2 = urb->context;\n\tint r;\n\n\tswitch (urb->status) {\n\tcase 0:\n\t\tusb_mark_last_busy(ar2->udev);\n\t\tati_remote2_input_mouse(ar2);\n\t\tbreak;\n\tcase -ENOENT:\n\tcase -EILSEQ:\n\tcase -ECONNRESET:\n\tcase -ESHUTDOWN:\n\t\tdev_dbg(&ar2->intf[0]->dev,\n\t\t\t\"%s(): urb status = %d\\n\", __func__, urb->status);\n\t\treturn;\n\tdefault:\n\t\tusb_mark_last_busy(ar2->udev);\n\t\tdev_err(&ar2->intf[0]->dev,\n\t\t\t\"%s(): urb status = %d\\n\", __func__, urb->status);\n\t}\n\n\tr = usb_submit_urb(urb, GFP_ATOMIC);\n\tif (r)\n\t\tdev_err(&ar2->intf[0]->dev,\n\t\t\t\"%s(): usb_submit_urb() = %d\\n\", __func__, r);\n}\n\nstatic void ati_remote2_complete_key(struct urb *urb)\n{\n\tstruct ati_remote2 *ar2 = urb->context;\n\tint r;\n\n\tswitch (urb->status) {\n\tcase 0:\n\t\tusb_mark_last_busy(ar2->udev);\n\t\tati_remote2_input_key(ar2);\n\t\tbreak;\n\tcase -ENOENT:\n\tcase -EILSEQ:\n\tcase -ECONNRESET:\n\tcase -ESHUTDOWN:\n\t\tdev_dbg(&ar2->intf[1]->dev,\n\t\t\t\"%s(): urb status = %d\\n\", __func__, urb->status);\n\t\treturn;\n\tdefault:\n\t\tusb_mark_last_busy(ar2->udev);\n\t\tdev_err(&ar2->intf[1]->dev,\n\t\t\t\"%s(): urb status = %d\\n\", __func__, urb->status);\n\t}\n\n\tr = usb_submit_urb(urb, GFP_ATOMIC);\n\tif (r)\n\t\tdev_err(&ar2->intf[1]->dev,\n\t\t\t\"%s(): usb_submit_urb() = %d\\n\", __func__, r);\n}\n\nstatic int ati_remote2_getkeycode(struct input_dev *idev,\n\t\t\t\t  struct input_keymap_entry *ke)\n{\n\tstruct ati_remote2 *ar2 = input_get_drvdata(idev);\n\tunsigned int mode;\n\tint offset;\n\tunsigned int index;\n\tunsigned int scancode;\n\n\tif (ke->flags & INPUT_KEYMAP_BY_INDEX) {\n\t\tindex = ke->index;\n\t\tif (index >= ATI_REMOTE2_MODES *\n\t\t\t\tARRAY_SIZE(ati_remote2_key_table))\n\t\t\treturn -EINVAL;\n\n\t\tmode = ke->index / ARRAY_SIZE(ati_remote2_key_table);\n\t\toffset = ke->index % ARRAY_SIZE(ati_remote2_key_table);\n\t\tscancode = (mode << 8) + ati_remote2_key_table[offset].hw_code;\n\t} else {\n\t\tif (input_scancode_to_scalar(ke, &scancode))\n\t\t\treturn -EINVAL;\n\n\t\tmode = scancode >> 8;\n\t\tif (mode > ATI_REMOTE2_PC)\n\t\t\treturn -EINVAL;\n\n\t\toffset = ati_remote2_lookup(scancode & 0xff);\n\t\tif (offset < 0)\n\t\t\treturn -EINVAL;\n\n\t\tindex = mode * ARRAY_SIZE(ati_remote2_key_table) + offset;\n\t}\n\n\tke->keycode = ar2->keycode[mode][offset];\n\tke->len = sizeof(scancode);\n\tmemcpy(&ke->scancode, &scancode, sizeof(scancode));\n\tke->index = index;\n\n\treturn 0;\n}\n\nstatic int ati_remote2_setkeycode(struct input_dev *idev,\n\t\t\t\t  const struct input_keymap_entry *ke,\n\t\t\t\t  unsigned int *old_keycode)\n{\n\tstruct ati_remote2 *ar2 = input_get_drvdata(idev);\n\tunsigned int mode;\n\tint offset;\n\tunsigned int index;\n\tunsigned int scancode;\n\n\tif (ke->flags & INPUT_KEYMAP_BY_INDEX) {\n\t\tif (ke->index >= ATI_REMOTE2_MODES *\n\t\t\t\tARRAY_SIZE(ati_remote2_key_table))\n\t\t\treturn -EINVAL;\n\n\t\tmode = ke->index / ARRAY_SIZE(ati_remote2_key_table);\n\t\toffset = ke->index % ARRAY_SIZE(ati_remote2_key_table);\n\t} else {\n\t\tif (input_scancode_to_scalar(ke, &scancode))\n\t\t\treturn -EINVAL;\n\n\t\tmode = scancode >> 8;\n\t\tif (mode > ATI_REMOTE2_PC)\n\t\t\treturn -EINVAL;\n\n\t\toffset = ati_remote2_lookup(scancode & 0xff);\n\t\tif (offset < 0)\n\t\t\treturn -EINVAL;\n\t}\n\n\t*old_keycode = ar2->keycode[mode][offset];\n\tar2->keycode[mode][offset] = ke->keycode;\n\t__set_bit(ke->keycode, idev->keybit);\n\n\tfor (mode = 0; mode < ATI_REMOTE2_MODES; mode++) {\n\t\tfor (index = 0; index < ARRAY_SIZE(ati_remote2_key_table); index++) {\n\t\t\tif (ar2->keycode[mode][index] == *old_keycode)\n\t\t\t\treturn 0;\n\t\t}\n\t}\n\n\t__clear_bit(*old_keycode, idev->keybit);\n\n\treturn 0;\n}\n\nstatic int ati_remote2_input_init(struct ati_remote2 *ar2)\n{\n\tstruct input_dev *idev;\n\tint index, mode, retval;\n\n\tidev = input_allocate_device();\n\tif (!idev)\n\t\treturn -ENOMEM;\n\n\tar2->idev = idev;\n\tinput_set_drvdata(idev, ar2);\n\n\tidev->evbit[0] = BIT_MASK(EV_KEY) | BIT_MASK(EV_REP) | BIT_MASK(EV_REL);\n\tidev->keybit[BIT_WORD(BTN_MOUSE)] = BIT_MASK(BTN_LEFT) |\n\t\tBIT_MASK(BTN_RIGHT);\n\tidev->relbit[0] = BIT_MASK(REL_X) | BIT_MASK(REL_Y);\n\n\tfor (mode = 0; mode < ATI_REMOTE2_MODES; mode++) {\n\t\tfor (index = 0; index < ARRAY_SIZE(ati_remote2_key_table); index++) {\n\t\t\tar2->keycode[mode][index] = ati_remote2_key_table[index].keycode;\n\t\t\t__set_bit(ar2->keycode[mode][index], idev->keybit);\n\t\t}\n\t}\n\n\t \n\tindex = ati_remote2_lookup(0x3f);\n\tar2->keycode[ATI_REMOTE2_AUX1][index] = KEY_PROG1;\n\tar2->keycode[ATI_REMOTE2_AUX2][index] = KEY_PROG2;\n\tar2->keycode[ATI_REMOTE2_AUX3][index] = KEY_PROG3;\n\tar2->keycode[ATI_REMOTE2_AUX4][index] = KEY_PROG4;\n\tar2->keycode[ATI_REMOTE2_PC][index] = KEY_PC;\n\t__set_bit(KEY_PROG1, idev->keybit);\n\t__set_bit(KEY_PROG2, idev->keybit);\n\t__set_bit(KEY_PROG3, idev->keybit);\n\t__set_bit(KEY_PROG4, idev->keybit);\n\t__set_bit(KEY_PC, idev->keybit);\n\n\tidev->rep[REP_DELAY]  = 250;\n\tidev->rep[REP_PERIOD] = 33;\n\n\tidev->open = ati_remote2_open;\n\tidev->close = ati_remote2_close;\n\n\tidev->getkeycode = ati_remote2_getkeycode;\n\tidev->setkeycode = ati_remote2_setkeycode;\n\n\tidev->name = ar2->name;\n\tidev->phys = ar2->phys;\n\n\tusb_to_input_id(ar2->udev, &idev->id);\n\tidev->dev.parent = &ar2->udev->dev;\n\n\tretval = input_register_device(idev);\n\tif (retval)\n\t\tinput_free_device(idev);\n\n\treturn retval;\n}\n\nstatic int ati_remote2_urb_init(struct ati_remote2 *ar2)\n{\n\tstruct usb_device *udev = ar2->udev;\n\tint i, pipe, maxp;\n\n\tfor (i = 0; i < 2; i++) {\n\t\tar2->buf[i] = usb_alloc_coherent(udev, 4, GFP_KERNEL, &ar2->buf_dma[i]);\n\t\tif (!ar2->buf[i])\n\t\t\treturn -ENOMEM;\n\n\t\tar2->urb[i] = usb_alloc_urb(0, GFP_KERNEL);\n\t\tif (!ar2->urb[i])\n\t\t\treturn -ENOMEM;\n\n\t\tpipe = usb_rcvintpipe(udev, ar2->ep[i]->bEndpointAddress);\n\t\tmaxp = usb_maxpacket(udev, pipe);\n\t\tmaxp = maxp > 4 ? 4 : maxp;\n\n\t\tusb_fill_int_urb(ar2->urb[i], udev, pipe, ar2->buf[i], maxp,\n\t\t\t\t i ? ati_remote2_complete_key : ati_remote2_complete_mouse,\n\t\t\t\t ar2, ar2->ep[i]->bInterval);\n\t\tar2->urb[i]->transfer_dma = ar2->buf_dma[i];\n\t\tar2->urb[i]->transfer_flags |= URB_NO_TRANSFER_DMA_MAP;\n\t}\n\n\treturn 0;\n}\n\nstatic void ati_remote2_urb_cleanup(struct ati_remote2 *ar2)\n{\n\tint i;\n\n\tfor (i = 0; i < 2; i++) {\n\t\tusb_free_urb(ar2->urb[i]);\n\t\tusb_free_coherent(ar2->udev, 4, ar2->buf[i], ar2->buf_dma[i]);\n\t}\n}\n\nstatic int ati_remote2_setup(struct ati_remote2 *ar2, unsigned int ch_mask)\n{\n\tint r, i, channel;\n\n\t \n\n\tchannel = 0;\n\tfor (i = 0; i < 16; i++) {\n\t\tif ((1 << i) & ch_mask) {\n\t\t\tif (!(~(1 << i) & ch_mask))\n\t\t\t\tchannel = i + 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tr = usb_control_msg(ar2->udev, usb_sndctrlpipe(ar2->udev, 0),\n\t\t\t    0x20,\n\t\t\t    USB_DIR_OUT | USB_TYPE_VENDOR | USB_RECIP_INTERFACE,\n\t\t\t    channel, 0x0, NULL, 0, USB_CTRL_SET_TIMEOUT);\n\tif (r) {\n\t\tdev_err(&ar2->udev->dev, \"%s - failed to set channel due to error: %d\\n\",\n\t\t\t__func__, r);\n\t\treturn r;\n\t}\n\n\treturn 0;\n}\n\nstatic ssize_t ati_remote2_show_channel_mask(struct device *dev,\n\t\t\t\t\t     struct device_attribute *attr,\n\t\t\t\t\t     char *buf)\n{\n\tstruct usb_device *udev = to_usb_device(dev);\n\tstruct usb_interface *intf = usb_ifnum_to_if(udev, 0);\n\tstruct ati_remote2 *ar2 = usb_get_intfdata(intf);\n\n\treturn sprintf(buf, \"0x%04x\\n\", ar2->channel_mask);\n}\n\nstatic ssize_t ati_remote2_store_channel_mask(struct device *dev,\n\t\t\t\t\t      struct device_attribute *attr,\n\t\t\t\t\t      const char *buf, size_t count)\n{\n\tstruct usb_device *udev = to_usb_device(dev);\n\tstruct usb_interface *intf = usb_ifnum_to_if(udev, 0);\n\tstruct ati_remote2 *ar2 = usb_get_intfdata(intf);\n\tunsigned int mask;\n\tint r;\n\n\tr = kstrtouint(buf, 0, &mask);\n\tif (r)\n\t\treturn r;\n\n\tif (mask & ~ATI_REMOTE2_MAX_CHANNEL_MASK)\n\t\treturn -EINVAL;\n\n\tr = usb_autopm_get_interface(ar2->intf[0]);\n\tif (r) {\n\t\tdev_err(&ar2->intf[0]->dev,\n\t\t\t\"%s(): usb_autopm_get_interface() = %d\\n\", __func__, r);\n\t\treturn r;\n\t}\n\n\tmutex_lock(&ati_remote2_mutex);\n\n\tif (mask != ar2->channel_mask) {\n\t\tr = ati_remote2_setup(ar2, mask);\n\t\tif (!r)\n\t\t\tar2->channel_mask = mask;\n\t}\n\n\tmutex_unlock(&ati_remote2_mutex);\n\n\tusb_autopm_put_interface(ar2->intf[0]);\n\n\treturn r ? r : count;\n}\n\nstatic ssize_t ati_remote2_show_mode_mask(struct device *dev,\n\t\t\t\t\t  struct device_attribute *attr,\n\t\t\t\t\t  char *buf)\n{\n\tstruct usb_device *udev = to_usb_device(dev);\n\tstruct usb_interface *intf = usb_ifnum_to_if(udev, 0);\n\tstruct ati_remote2 *ar2 = usb_get_intfdata(intf);\n\n\treturn sprintf(buf, \"0x%02x\\n\", ar2->mode_mask);\n}\n\nstatic ssize_t ati_remote2_store_mode_mask(struct device *dev,\n\t\t\t\t\t   struct device_attribute *attr,\n\t\t\t\t\t   const char *buf, size_t count)\n{\n\tstruct usb_device *udev = to_usb_device(dev);\n\tstruct usb_interface *intf = usb_ifnum_to_if(udev, 0);\n\tstruct ati_remote2 *ar2 = usb_get_intfdata(intf);\n\tunsigned int mask;\n\tint err;\n\n\terr = kstrtouint(buf, 0, &mask);\n\tif (err)\n\t\treturn err;\n\n\tif (mask & ~ATI_REMOTE2_MAX_MODE_MASK)\n\t\treturn -EINVAL;\n\n\tar2->mode_mask = mask;\n\n\treturn count;\n}\n\nstatic DEVICE_ATTR(channel_mask, 0644, ati_remote2_show_channel_mask,\n\t\t   ati_remote2_store_channel_mask);\n\nstatic DEVICE_ATTR(mode_mask, 0644, ati_remote2_show_mode_mask,\n\t\t   ati_remote2_store_mode_mask);\n\nstatic struct attribute *ati_remote2_attrs[] = {\n\t&dev_attr_channel_mask.attr,\n\t&dev_attr_mode_mask.attr,\n\tNULL,\n};\n\nstatic struct attribute_group ati_remote2_attr_group = {\n\t.attrs = ati_remote2_attrs,\n};\n\nstatic int ati_remote2_probe(struct usb_interface *interface, const struct usb_device_id *id)\n{\n\tstruct usb_device *udev = interface_to_usbdev(interface);\n\tstruct usb_host_interface *alt = interface->cur_altsetting;\n\tstruct ati_remote2 *ar2;\n\tint r;\n\n\tif (alt->desc.bInterfaceNumber)\n\t\treturn -ENODEV;\n\n\tar2 = kzalloc(sizeof (struct ati_remote2), GFP_KERNEL);\n\tif (!ar2)\n\t\treturn -ENOMEM;\n\n\tar2->udev = udev;\n\n\t \n\tif (alt->desc.bNumEndpoints < 1 || !alt->endpoint) {\n\t\tdev_err(&interface->dev,\n\t\t\t\"%s(): interface 0 must have an endpoint\\n\", __func__);\n\t\tr = -ENODEV;\n\t\tgoto fail1;\n\t}\n\tar2->intf[0] = interface;\n\tar2->ep[0] = &alt->endpoint[0].desc;\n\n\t \n\tar2->intf[1] = usb_ifnum_to_if(udev, 1);\n\tif ((udev->actconfig->desc.bNumInterfaces < 2) || !ar2->intf[1]) {\n\t\tdev_err(&interface->dev, \"%s(): need 2 interfaces, found %d\\n\",\n\t\t\t__func__, udev->actconfig->desc.bNumInterfaces);\n\t\tr = -ENODEV;\n\t\tgoto fail1;\n\t}\n\n\tr = usb_driver_claim_interface(&ati_remote2_driver, ar2->intf[1], ar2);\n\tif (r)\n\t\tgoto fail1;\n\n\t \n\talt = ar2->intf[1]->cur_altsetting;\n\tif (alt->desc.bNumEndpoints < 1 || !alt->endpoint) {\n\t\tdev_err(&interface->dev,\n\t\t\t\"%s(): interface 1 must have an endpoint\\n\", __func__);\n\t\tr = -ENODEV;\n\t\tgoto fail2;\n\t}\n\tar2->ep[1] = &alt->endpoint[0].desc;\n\n\tr = ati_remote2_urb_init(ar2);\n\tif (r)\n\t\tgoto fail3;\n\n\tar2->channel_mask = channel_mask;\n\tar2->mode_mask = mode_mask;\n\n\tr = ati_remote2_setup(ar2, ar2->channel_mask);\n\tif (r)\n\t\tgoto fail3;\n\n\tusb_make_path(udev, ar2->phys, sizeof(ar2->phys));\n\tstrlcat(ar2->phys, \"/input0\", sizeof(ar2->phys));\n\n\tstrlcat(ar2->name, \"ATI Remote Wonder II\", sizeof(ar2->name));\n\n\tr = sysfs_create_group(&udev->dev.kobj, &ati_remote2_attr_group);\n\tif (r)\n\t\tgoto fail3;\n\n\tr = ati_remote2_input_init(ar2);\n\tif (r)\n\t\tgoto fail4;\n\n\tusb_set_intfdata(interface, ar2);\n\n\tinterface->needs_remote_wakeup = 1;\n\n\treturn 0;\n\n fail4:\n\tsysfs_remove_group(&udev->dev.kobj, &ati_remote2_attr_group);\n fail3:\n\tati_remote2_urb_cleanup(ar2);\n fail2:\n\tusb_driver_release_interface(&ati_remote2_driver, ar2->intf[1]);\n fail1:\n\tkfree(ar2);\n\n\treturn r;\n}\n\nstatic void ati_remote2_disconnect(struct usb_interface *interface)\n{\n\tstruct ati_remote2 *ar2;\n\tstruct usb_host_interface *alt = interface->cur_altsetting;\n\n\tif (alt->desc.bInterfaceNumber)\n\t\treturn;\n\n\tar2 = usb_get_intfdata(interface);\n\tusb_set_intfdata(interface, NULL);\n\n\tinput_unregister_device(ar2->idev);\n\n\tsysfs_remove_group(&ar2->udev->dev.kobj, &ati_remote2_attr_group);\n\n\tati_remote2_urb_cleanup(ar2);\n\n\tusb_driver_release_interface(&ati_remote2_driver, ar2->intf[1]);\n\n\tkfree(ar2);\n}\n\nstatic int ati_remote2_suspend(struct usb_interface *interface,\n\t\t\t       pm_message_t message)\n{\n\tstruct ati_remote2 *ar2;\n\tstruct usb_host_interface *alt = interface->cur_altsetting;\n\n\tif (alt->desc.bInterfaceNumber)\n\t\treturn 0;\n\n\tar2 = usb_get_intfdata(interface);\n\n\tdev_dbg(&ar2->intf[0]->dev, \"%s()\\n\", __func__);\n\n\tmutex_lock(&ati_remote2_mutex);\n\n\tif (ar2->flags & ATI_REMOTE2_OPENED)\n\t\tati_remote2_kill_urbs(ar2);\n\n\tar2->flags |= ATI_REMOTE2_SUSPENDED;\n\n\tmutex_unlock(&ati_remote2_mutex);\n\n\treturn 0;\n}\n\nstatic int ati_remote2_resume(struct usb_interface *interface)\n{\n\tstruct ati_remote2 *ar2;\n\tstruct usb_host_interface *alt = interface->cur_altsetting;\n\tint r = 0;\n\n\tif (alt->desc.bInterfaceNumber)\n\t\treturn 0;\n\n\tar2 = usb_get_intfdata(interface);\n\n\tdev_dbg(&ar2->intf[0]->dev, \"%s()\\n\", __func__);\n\n\tmutex_lock(&ati_remote2_mutex);\n\n\tif (ar2->flags & ATI_REMOTE2_OPENED)\n\t\tr = ati_remote2_submit_urbs(ar2);\n\n\tif (!r)\n\t\tar2->flags &= ~ATI_REMOTE2_SUSPENDED;\n\n\tmutex_unlock(&ati_remote2_mutex);\n\n\treturn r;\n}\n\nstatic int ati_remote2_reset_resume(struct usb_interface *interface)\n{\n\tstruct ati_remote2 *ar2;\n\tstruct usb_host_interface *alt = interface->cur_altsetting;\n\tint r = 0;\n\n\tif (alt->desc.bInterfaceNumber)\n\t\treturn 0;\n\n\tar2 = usb_get_intfdata(interface);\n\n\tdev_dbg(&ar2->intf[0]->dev, \"%s()\\n\", __func__);\n\n\tmutex_lock(&ati_remote2_mutex);\n\n\tr = ati_remote2_setup(ar2, ar2->channel_mask);\n\tif (r)\n\t\tgoto out;\n\n\tif (ar2->flags & ATI_REMOTE2_OPENED)\n\t\tr = ati_remote2_submit_urbs(ar2);\n\n\tif (!r)\n\t\tar2->flags &= ~ATI_REMOTE2_SUSPENDED;\n\n out:\n\tmutex_unlock(&ati_remote2_mutex);\n\n\treturn r;\n}\n\nstatic int ati_remote2_pre_reset(struct usb_interface *interface)\n{\n\tstruct ati_remote2 *ar2;\n\tstruct usb_host_interface *alt = interface->cur_altsetting;\n\n\tif (alt->desc.bInterfaceNumber)\n\t\treturn 0;\n\n\tar2 = usb_get_intfdata(interface);\n\n\tdev_dbg(&ar2->intf[0]->dev, \"%s()\\n\", __func__);\n\n\tmutex_lock(&ati_remote2_mutex);\n\n\tif (ar2->flags == ATI_REMOTE2_OPENED)\n\t\tati_remote2_kill_urbs(ar2);\n\n\treturn 0;\n}\n\nstatic int ati_remote2_post_reset(struct usb_interface *interface)\n{\n\tstruct ati_remote2 *ar2;\n\tstruct usb_host_interface *alt = interface->cur_altsetting;\n\tint r = 0;\n\n\tif (alt->desc.bInterfaceNumber)\n\t\treturn 0;\n\n\tar2 = usb_get_intfdata(interface);\n\n\tdev_dbg(&ar2->intf[0]->dev, \"%s()\\n\", __func__);\n\n\tif (ar2->flags == ATI_REMOTE2_OPENED)\n\t\tr = ati_remote2_submit_urbs(ar2);\n\n\tmutex_unlock(&ati_remote2_mutex);\n\n\treturn r;\n}\n\nmodule_usb_driver(ati_remote2_driver);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}