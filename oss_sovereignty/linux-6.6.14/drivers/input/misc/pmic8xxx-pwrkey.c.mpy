{
  "module_name": "pmic8xxx-pwrkey.c",
  "hash_id": "488966ef4cd5dfe28dbf25ad3ff80bdfea2ec80287f593904174390e2c6a1ffa",
  "original_prompt": "Ingested from linux-6.6.14/drivers/input/misc/pmic8xxx-pwrkey.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/errno.h>\n#include <linux/slab.h>\n#include <linux/input.h>\n#include <linux/interrupt.h>\n#include <linux/platform_device.h>\n#include <linux/regmap.h>\n#include <linux/log2.h>\n#include <linux/of.h>\n\n#define PON_CNTL_1 0x1C\n#define PON_CNTL_PULL_UP BIT(7)\n#define PON_CNTL_TRIG_DELAY_MASK (0x7)\n#define PON_CNTL_1_PULL_UP_EN\t\t\t0xe0\n#define PON_CNTL_1_USB_PWR_EN\t\t\t0x10\n#define PON_CNTL_1_WD_EN_RESET\t\t\t0x08\n\n#define PM8058_SLEEP_CTRL\t\t\t0x02b\n#define PM8921_SLEEP_CTRL\t\t\t0x10a\n\n#define SLEEP_CTRL_SMPL_EN_RESET\t\t0x04\n\n \n#define REG_PM8058_VREG_EN_MSM\t\t\t0x018\n#define REG_PM8058_VREG_EN_GRP_5_4\t\t0x1c8\n\n \n#define PM8058_S0_CTRL\t\t\t\t0x004\n#define PM8058_S1_CTRL\t\t\t\t0x005\n#define PM8058_S3_CTRL\t\t\t\t0x111\n#define PM8058_L21_CTRL\t\t\t\t0x120\n#define PM8058_L22_CTRL\t\t\t\t0x121\n\n#define PM8058_REGULATOR_ENABLE_MASK\t\t0x80\n#define PM8058_REGULATOR_ENABLE\t\t\t0x80\n#define PM8058_REGULATOR_DISABLE\t\t0x00\n#define PM8058_REGULATOR_PULL_DOWN_MASK\t\t0x40\n#define PM8058_REGULATOR_PULL_DOWN_EN\t\t0x40\n\n \n#define PM8058_SMPS_LEGACY_VREF_SEL\t\t0x20\n#define PM8058_SMPS_LEGACY_VPROG_MASK\t\t0x1f\n#define PM8058_SMPS_ADVANCED_BAND_MASK\t\t0xC0\n#define PM8058_SMPS_ADVANCED_BAND_SHIFT\t\t6\n#define PM8058_SMPS_ADVANCED_VPROG_MASK\t\t0x3f\n\n \n#define PM8058_S0_TEST2\t\t\t\t0x084\n#define PM8058_S1_TEST2\t\t\t\t0x085\n#define PM8058_S3_TEST2\t\t\t\t0x11a\n\n#define PM8058_REGULATOR_BANK_WRITE\t\t0x80\n#define PM8058_REGULATOR_BANK_MASK\t\t0x70\n#define PM8058_REGULATOR_BANK_SHIFT\t\t4\n#define PM8058_REGULATOR_BANK_SEL(n)\t((n) << PM8058_REGULATOR_BANK_SHIFT)\n\n \n#define PM8058_SMPS_LEGACY_VLOW_SEL\t\t0x01\n\n \n#define PM8058_SMPS_ADVANCED_MODE_MASK\t\t0x02\n#define PM8058_SMPS_ADVANCED_MODE\t\t0x02\n#define PM8058_SMPS_LEGACY_MODE\t\t\t0x00\n\n \nstruct pmic8xxx_pwrkey {\n\tint key_press_irq;\n\tstruct regmap *regmap;\n\tint (*shutdown_fn)(struct pmic8xxx_pwrkey *, bool);\n};\n\nstatic irqreturn_t pwrkey_press_irq(int irq, void *_pwr)\n{\n\tstruct input_dev *pwr = _pwr;\n\n\tinput_report_key(pwr, KEY_POWER, 1);\n\tinput_sync(pwr);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic irqreturn_t pwrkey_release_irq(int irq, void *_pwr)\n{\n\tstruct input_dev *pwr = _pwr;\n\n\tinput_report_key(pwr, KEY_POWER, 0);\n\tinput_sync(pwr);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int pmic8xxx_pwrkey_suspend(struct device *dev)\n{\n\tstruct pmic8xxx_pwrkey *pwrkey = dev_get_drvdata(dev);\n\n\tif (device_may_wakeup(dev))\n\t\tenable_irq_wake(pwrkey->key_press_irq);\n\n\treturn 0;\n}\n\nstatic int pmic8xxx_pwrkey_resume(struct device *dev)\n{\n\tstruct pmic8xxx_pwrkey *pwrkey = dev_get_drvdata(dev);\n\n\tif (device_may_wakeup(dev))\n\t\tdisable_irq_wake(pwrkey->key_press_irq);\n\n\treturn 0;\n}\n\nstatic DEFINE_SIMPLE_DEV_PM_OPS(pm8xxx_pwr_key_pm_ops,\n\t\tpmic8xxx_pwrkey_suspend, pmic8xxx_pwrkey_resume);\n\nstatic void pmic8xxx_pwrkey_shutdown(struct platform_device *pdev)\n{\n\tstruct pmic8xxx_pwrkey *pwrkey = platform_get_drvdata(pdev);\n\tint error;\n\tu8 mask, val;\n\tbool reset = system_state == SYSTEM_RESTART;\n\n\tif (pwrkey->shutdown_fn) {\n\t\terror = pwrkey->shutdown_fn(pwrkey, reset);\n\t\tif (error)\n\t\t\treturn;\n\t}\n\n\t \n\tmask = PON_CNTL_1_PULL_UP_EN | PON_CNTL_1_USB_PWR_EN;\n\tmask |= PON_CNTL_1_WD_EN_RESET;\n\tval = mask;\n\tif (!reset)\n\t\tval &= ~PON_CNTL_1_WD_EN_RESET;\n\n\tregmap_update_bits(pwrkey->regmap, PON_CNTL_1, mask, val);\n}\n\n \nstatic int pm8058_disable_smps_locally_set_pull_down(struct regmap *regmap,\n\tu16 ctrl_addr, u16 test2_addr, u16 master_enable_addr,\n\tu8 master_enable_bit)\n{\n\tint error;\n\tu8 vref_sel, vlow_sel, band, vprog, bank;\n\tunsigned int reg;\n\n\tbank = PM8058_REGULATOR_BANK_SEL(7);\n\terror = regmap_write(regmap, test2_addr, bank);\n\tif (error)\n\t\treturn error;\n\n\terror = regmap_read(regmap, test2_addr, &reg);\n\tif (error)\n\t\treturn error;\n\n\treg &= PM8058_SMPS_ADVANCED_MODE_MASK;\n\t \n\tif (reg == PM8058_SMPS_ADVANCED_MODE) {\n\t\t \n\t\terror = regmap_read(regmap, ctrl_addr, &reg);\n\t\tif (error)\n\t\t\treturn error;\n\n\t\tband = reg & PM8058_SMPS_ADVANCED_BAND_MASK;\n\t\tband >>= PM8058_SMPS_ADVANCED_BAND_SHIFT;\n\t\tswitch (band) {\n\t\tcase 3:\n\t\t\tvref_sel = 0;\n\t\t\tvlow_sel = 0;\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tvref_sel = PM8058_SMPS_LEGACY_VREF_SEL;\n\t\t\tvlow_sel = 0;\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tvref_sel = PM8058_SMPS_LEGACY_VREF_SEL;\n\t\t\tvlow_sel = PM8058_SMPS_LEGACY_VLOW_SEL;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tpr_err(\"%s: regulator already disabled\\n\", __func__);\n\t\t\treturn -EPERM;\n\t\t}\n\t\tvprog = reg & PM8058_SMPS_ADVANCED_VPROG_MASK;\n\t\t \n\t\tvprog = (vprog + 1) >> 1;\n\t\tif (vprog > PM8058_SMPS_LEGACY_VPROG_MASK)\n\t\t\tvprog = PM8058_SMPS_LEGACY_VPROG_MASK;\n\n\t\t \n\t\tbank = PM8058_REGULATOR_BANK_SEL(1);\n\t\terror = regmap_write(regmap, test2_addr, bank);\n\t\tif (error)\n\t\t\treturn error;\n\n\t\terror = regmap_update_bits(regmap, test2_addr,\n\t\t\tPM8058_REGULATOR_BANK_WRITE | PM8058_REGULATOR_BANK_MASK\n\t\t\t\t| PM8058_SMPS_LEGACY_VLOW_SEL,\n\t\t\tPM8058_REGULATOR_BANK_WRITE |\n\t\t\tPM8058_REGULATOR_BANK_SEL(1) | vlow_sel);\n\t\tif (error)\n\t\t\treturn error;\n\n\t\t \n\t\tbank = PM8058_REGULATOR_BANK_SEL(7);\n\t\terror = regmap_write(regmap, test2_addr, bank);\n\t\tif (error)\n\t\t\treturn error;\n\n\t\terror = regmap_update_bits(regmap, test2_addr,\n\t\t\t\tPM8058_REGULATOR_BANK_WRITE |\n\t\t\t\tPM8058_REGULATOR_BANK_MASK |\n\t\t\t\tPM8058_SMPS_ADVANCED_MODE_MASK,\n\t\t\t\tPM8058_REGULATOR_BANK_WRITE |\n\t\t\t\tPM8058_REGULATOR_BANK_SEL(7) |\n\t\t\t\tPM8058_SMPS_LEGACY_MODE);\n\t\tif (error)\n\t\t\treturn error;\n\n\t\t \n\t\terror = regmap_update_bits(regmap, ctrl_addr,\n\t\t\tPM8058_REGULATOR_ENABLE_MASK |\n\t\t\tPM8058_REGULATOR_PULL_DOWN_MASK |\n\t\t\tPM8058_SMPS_LEGACY_VREF_SEL |\n\t\t\tPM8058_SMPS_LEGACY_VPROG_MASK,\n\t\t\tPM8058_REGULATOR_ENABLE | PM8058_REGULATOR_PULL_DOWN_EN\n\t\t\t\t| vref_sel | vprog);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\t \n\terror = regmap_update_bits(regmap, master_enable_addr,\n\t\t\tmaster_enable_bit, master_enable_bit);\n\tif (error)\n\t\treturn error;\n\n\t \n\treturn regmap_update_bits(regmap, ctrl_addr,\n\t\tPM8058_REGULATOR_ENABLE_MASK | PM8058_REGULATOR_PULL_DOWN_MASK,\n\t\tPM8058_REGULATOR_DISABLE | PM8058_REGULATOR_PULL_DOWN_EN);\n}\n\nstatic int pm8058_disable_ldo_locally_set_pull_down(struct regmap *regmap,\n\t\tu16 ctrl_addr, u16 master_enable_addr, u8 master_enable_bit)\n{\n\tint error;\n\n\t \n\terror = regmap_update_bits(regmap, master_enable_addr,\n\t\t\tmaster_enable_bit, master_enable_bit);\n\tif (error)\n\t\treturn error;\n\n\t \n\treturn regmap_update_bits(regmap, ctrl_addr,\n\t\tPM8058_REGULATOR_ENABLE_MASK | PM8058_REGULATOR_PULL_DOWN_MASK,\n\t\tPM8058_REGULATOR_DISABLE | PM8058_REGULATOR_PULL_DOWN_EN);\n}\n\nstatic int pm8058_pwrkey_shutdown(struct pmic8xxx_pwrkey *pwrkey, bool reset)\n{\n\tint error;\n\tstruct regmap *regmap = pwrkey->regmap;\n\tu8 mask, val;\n\n\t \n\tif (!reset) {\n\t\t \n\t\tpm8058_disable_smps_locally_set_pull_down(regmap,\n\t\t\tPM8058_S0_CTRL, PM8058_S0_TEST2,\n\t\t\tREG_PM8058_VREG_EN_MSM, BIT(7));\n\t\tpm8058_disable_smps_locally_set_pull_down(regmap,\n\t\t\tPM8058_S1_CTRL, PM8058_S1_TEST2,\n\t\t\tREG_PM8058_VREG_EN_MSM, BIT(6));\n\t\tpm8058_disable_smps_locally_set_pull_down(regmap,\n\t\t\tPM8058_S3_CTRL, PM8058_S3_TEST2,\n\t\t\tREG_PM8058_VREG_EN_GRP_5_4, BIT(7) | BIT(4));\n\t\t \n\t\tpm8058_disable_ldo_locally_set_pull_down(regmap,\n\t\t\tPM8058_L21_CTRL, REG_PM8058_VREG_EN_GRP_5_4,\n\t\t\tBIT(1));\n\t}\n\n\t \n\terror = regmap_update_bits(regmap, PM8058_L22_CTRL, 0xbf, 0x93);\n\tif (error)\n\t\treturn error;\n\n\t \n\tmask = SLEEP_CTRL_SMPL_EN_RESET;\n\tval = 0;\n\tif (reset)\n\t\tval = mask;\n\treturn regmap_update_bits(regmap, PM8058_SLEEP_CTRL, mask, val);\n}\n\nstatic int pm8921_pwrkey_shutdown(struct pmic8xxx_pwrkey *pwrkey, bool reset)\n{\n\tstruct regmap *regmap = pwrkey->regmap;\n\tu8 mask = SLEEP_CTRL_SMPL_EN_RESET;\n\tu8 val = 0;\n\n\t \n\tif (reset)\n\t\tval = mask;\n\treturn regmap_update_bits(regmap, PM8921_SLEEP_CTRL, mask, val);\n}\n\nstatic int pmic8xxx_pwrkey_probe(struct platform_device *pdev)\n{\n\tstruct input_dev *pwr;\n\tint key_release_irq = platform_get_irq(pdev, 0);\n\tint key_press_irq = platform_get_irq(pdev, 1);\n\tint err;\n\tunsigned int delay;\n\tunsigned int pon_cntl;\n\tstruct regmap *regmap;\n\tstruct pmic8xxx_pwrkey *pwrkey;\n\tu32 kpd_delay;\n\tbool pull_up;\n\n\tif (of_property_read_u32(pdev->dev.of_node, \"debounce\", &kpd_delay))\n\t\tkpd_delay = 15625;\n\n\t \n\tif (kpd_delay > USEC_PER_SEC * 2 || kpd_delay < USEC_PER_SEC / 64) {\n\t\tdev_err(&pdev->dev, \"invalid power key trigger delay\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tpull_up = of_property_read_bool(pdev->dev.of_node, \"pull-up\");\n\n\tregmap = dev_get_regmap(pdev->dev.parent, NULL);\n\tif (!regmap) {\n\t\tdev_err(&pdev->dev, \"failed to locate regmap for the device\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tpwrkey = devm_kzalloc(&pdev->dev, sizeof(*pwrkey), GFP_KERNEL);\n\tif (!pwrkey)\n\t\treturn -ENOMEM;\n\n\tpwrkey->shutdown_fn = of_device_get_match_data(&pdev->dev);\n\tpwrkey->regmap = regmap;\n\tpwrkey->key_press_irq = key_press_irq;\n\n\tpwr = devm_input_allocate_device(&pdev->dev);\n\tif (!pwr) {\n\t\tdev_dbg(&pdev->dev, \"Can't allocate power button\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tinput_set_capability(pwr, EV_KEY, KEY_POWER);\n\n\tpwr->name = \"pmic8xxx_pwrkey\";\n\tpwr->phys = \"pmic8xxx_pwrkey/input0\";\n\n\tdelay = (kpd_delay << 6) / USEC_PER_SEC;\n\tdelay = ilog2(delay);\n\n\terr = regmap_read(regmap, PON_CNTL_1, &pon_cntl);\n\tif (err < 0) {\n\t\tdev_err(&pdev->dev, \"failed reading PON_CNTL_1 err=%d\\n\", err);\n\t\treturn err;\n\t}\n\n\tpon_cntl &= ~PON_CNTL_TRIG_DELAY_MASK;\n\tpon_cntl |= (delay & PON_CNTL_TRIG_DELAY_MASK);\n\tif (pull_up)\n\t\tpon_cntl |= PON_CNTL_PULL_UP;\n\telse\n\t\tpon_cntl &= ~PON_CNTL_PULL_UP;\n\n\terr = regmap_write(regmap, PON_CNTL_1, pon_cntl);\n\tif (err < 0) {\n\t\tdev_err(&pdev->dev, \"failed writing PON_CNTL_1 err=%d\\n\", err);\n\t\treturn err;\n\t}\n\n\terr = devm_request_irq(&pdev->dev, key_press_irq, pwrkey_press_irq,\n\t\t\t       IRQF_TRIGGER_RISING,\n\t\t\t       \"pmic8xxx_pwrkey_press\", pwr);\n\tif (err) {\n\t\tdev_err(&pdev->dev, \"Can't get %d IRQ for pwrkey: %d\\n\",\n\t\t\tkey_press_irq, err);\n\t\treturn err;\n\t}\n\n\terr = devm_request_irq(&pdev->dev, key_release_irq, pwrkey_release_irq,\n\t\t\t       IRQF_TRIGGER_RISING,\n\t\t\t       \"pmic8xxx_pwrkey_release\", pwr);\n\tif (err) {\n\t\tdev_err(&pdev->dev, \"Can't get %d IRQ for pwrkey: %d\\n\",\n\t\t\tkey_release_irq, err);\n\t\treturn err;\n\t}\n\n\terr = input_register_device(pwr);\n\tif (err) {\n\t\tdev_err(&pdev->dev, \"Can't register power key: %d\\n\", err);\n\t\treturn err;\n\t}\n\n\tplatform_set_drvdata(pdev, pwrkey);\n\tdevice_init_wakeup(&pdev->dev, 1);\n\n\treturn 0;\n}\n\nstatic const struct of_device_id pm8xxx_pwr_key_id_table[] = {\n\t{ .compatible = \"qcom,pm8058-pwrkey\", .data = &pm8058_pwrkey_shutdown },\n\t{ .compatible = \"qcom,pm8921-pwrkey\", .data = &pm8921_pwrkey_shutdown },\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, pm8xxx_pwr_key_id_table);\n\nstatic struct platform_driver pmic8xxx_pwrkey_driver = {\n\t.probe\t\t= pmic8xxx_pwrkey_probe,\n\t.shutdown\t= pmic8xxx_pwrkey_shutdown,\n\t.driver\t\t= {\n\t\t.name\t= \"pm8xxx-pwrkey\",\n\t\t.pm\t= pm_sleep_ptr(&pm8xxx_pwr_key_pm_ops),\n\t\t.of_match_table = pm8xxx_pwr_key_id_table,\n\t},\n};\nmodule_platform_driver(pmic8xxx_pwrkey_driver);\n\nMODULE_ALIAS(\"platform:pmic8xxx_pwrkey\");\nMODULE_DESCRIPTION(\"PMIC8XXX Power Key driver\");\nMODULE_LICENSE(\"GPL v2\");\nMODULE_AUTHOR(\"Trilok Soni <tsoni@codeaurora.org>\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}