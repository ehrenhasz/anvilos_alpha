{
  "module_name": "max8925_onkey.c",
  "hash_id": "847745406acbe0a6bab3f2b4b8846380150ab7baa66ebeacdbd6aab9b87d1e34",
  "original_prompt": "Ingested from linux-6.6.14/drivers/input/misc/max8925_onkey.c",
  "human_readable_source": " \n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/platform_device.h>\n#include <linux/i2c.h>\n#include <linux/input.h>\n#include <linux/interrupt.h>\n#include <linux/mfd/max8925.h>\n#include <linux/slab.h>\n#include <linux/device.h>\n\n#define SW_INPUT\t\t(1 << 7)\t \n#define HARDRESET_EN\t\t(1 << 7)\n#define PWREN_EN\t\t(1 << 7)\n\nstruct max8925_onkey_info {\n\tstruct input_dev\t*idev;\n\tstruct i2c_client\t*i2c;\n\tstruct device\t\t*dev;\n\tunsigned int\t\tirq[2];\n};\n\n \nstatic irqreturn_t max8925_onkey_handler(int irq, void *data)\n{\n\tstruct max8925_onkey_info *info = data;\n\tint state;\n\n\tstate = max8925_reg_read(info->i2c, MAX8925_ON_OFF_STATUS);\n\n\tinput_report_key(info->idev, KEY_POWER, state & SW_INPUT);\n\tinput_sync(info->idev);\n\n\tdev_dbg(info->dev, \"onkey state:%d\\n\", state);\n\n\t \n\tmax8925_set_bits(info->i2c, MAX8925_SYSENSEL,\n\t\t\t HARDRESET_EN, HARDRESET_EN);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int max8925_onkey_probe(struct platform_device *pdev)\n{\n\tstruct max8925_chip *chip = dev_get_drvdata(pdev->dev.parent);\n\tstruct max8925_onkey_info *info;\n\tstruct input_dev *input;\n\tint irq[2], error;\n\n\tirq[0] = platform_get_irq(pdev, 0);\n\tif (irq[0] < 0)\n\t\treturn -EINVAL;\n\n\tirq[1] = platform_get_irq(pdev, 1);\n\tif (irq[1] < 0)\n\t\treturn -EINVAL;\n\n\tinfo = devm_kzalloc(&pdev->dev, sizeof(struct max8925_onkey_info),\n\t\t\t    GFP_KERNEL);\n\tif (!info)\n\t\treturn -ENOMEM;\n\n\tinput = devm_input_allocate_device(&pdev->dev);\n\tif (!input)\n\t\treturn -ENOMEM;\n\n\tinfo->idev = input;\n\tinfo->i2c = chip->i2c;\n\tinfo->dev = &pdev->dev;\n\tinfo->irq[0] = irq[0];\n\tinfo->irq[1] = irq[1];\n\n\tinput->name = \"max8925_on\";\n\tinput->phys = \"max8925_on/input0\";\n\tinput->id.bustype = BUS_I2C;\n\tinput->dev.parent = &pdev->dev;\n\tinput_set_capability(input, EV_KEY, KEY_POWER);\n\n\terror = devm_request_threaded_irq(&pdev->dev, irq[0], NULL,\n\t\t\t\t\t  max8925_onkey_handler, IRQF_ONESHOT,\n\t\t\t\t\t  \"onkey-down\", info);\n\tif (error < 0) {\n\t\tdev_err(chip->dev, \"Failed to request IRQ: #%d: %d\\n\",\n\t\t\tirq[0], error);\n\t\treturn error;\n\t}\n\n\terror = devm_request_threaded_irq(&pdev->dev, irq[1], NULL,\n\t\t\t\t\t  max8925_onkey_handler, IRQF_ONESHOT,\n\t\t\t\t\t  \"onkey-up\", info);\n\tif (error < 0) {\n\t\tdev_err(chip->dev, \"Failed to request IRQ: #%d: %d\\n\",\n\t\t\tirq[1], error);\n\t\treturn error;\n\t}\n\n\terror = input_register_device(info->idev);\n\tif (error) {\n\t\tdev_err(chip->dev, \"Can't register input device: %d\\n\", error);\n\t\treturn error;\n\t}\n\n\tplatform_set_drvdata(pdev, info);\n\tdevice_init_wakeup(&pdev->dev, 1);\n\n\treturn 0;\n}\n\nstatic int max8925_onkey_suspend(struct device *dev)\n{\n\tstruct platform_device *pdev = to_platform_device(dev);\n\tstruct max8925_onkey_info *info = platform_get_drvdata(pdev);\n\tstruct max8925_chip *chip = dev_get_drvdata(pdev->dev.parent);\n\n\tif (device_may_wakeup(dev)) {\n\t\tchip->wakeup_flag |= 1 << info->irq[0];\n\t\tchip->wakeup_flag |= 1 << info->irq[1];\n\t}\n\n\treturn 0;\n}\n\nstatic int max8925_onkey_resume(struct device *dev)\n{\n\tstruct platform_device *pdev = to_platform_device(dev);\n\tstruct max8925_onkey_info *info = platform_get_drvdata(pdev);\n\tstruct max8925_chip *chip = dev_get_drvdata(pdev->dev.parent);\n\n\tif (device_may_wakeup(dev)) {\n\t\tchip->wakeup_flag &= ~(1 << info->irq[0]);\n\t\tchip->wakeup_flag &= ~(1 << info->irq[1]);\n\t}\n\n\treturn 0;\n}\n\nstatic DEFINE_SIMPLE_DEV_PM_OPS(max8925_onkey_pm_ops,\n\t\t\t\tmax8925_onkey_suspend, max8925_onkey_resume);\n\nstatic struct platform_driver max8925_onkey_driver = {\n\t.driver\t\t= {\n\t\t.name\t= \"max8925-onkey\",\n\t\t.pm\t= pm_sleep_ptr(&max8925_onkey_pm_ops),\n\t},\n\t.probe\t\t= max8925_onkey_probe,\n};\nmodule_platform_driver(max8925_onkey_driver);\n\nMODULE_DESCRIPTION(\"Maxim MAX8925 ONKEY driver\");\nMODULE_AUTHOR(\"Haojian Zhuang <haojian.zhuang@marvell.com>\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}