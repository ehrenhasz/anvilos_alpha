{
  "module_name": "adxl34x.c",
  "hash_id": "268307eaf4699e0040c13787ada6abe36d2531d5ed279aa75089fd0eef731ec3",
  "original_prompt": "Ingested from linux-6.6.14/drivers/input/misc/adxl34x.c",
  "human_readable_source": "\n \n\n#include <linux/device.h>\n#include <linux/delay.h>\n#include <linux/input.h>\n#include <linux/interrupt.h>\n#include <linux/irq.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/input/adxl34x.h>\n#include <linux/module.h>\n\n#include \"adxl34x.h\"\n\n \n#define DEVID\t\t0x00\t \n#define THRESH_TAP\t0x1D\t \n#define OFSX\t\t0x1E\t \n#define OFSY\t\t0x1F\t \n#define OFSZ\t\t0x20\t \n#define DUR\t\t0x21\t \n#define LATENT\t\t0x22\t \n#define WINDOW\t\t0x23\t \n#define THRESH_ACT\t0x24\t \n#define THRESH_INACT\t0x25\t \n#define TIME_INACT\t0x26\t \n#define ACT_INACT_CTL\t0x27\t \n\t\t\t\t \n#define THRESH_FF\t0x28\t \n#define TIME_FF\t\t0x29\t \n#define TAP_AXES\t0x2A\t \n#define ACT_TAP_STATUS\t0x2B\t \n#define BW_RATE\t\t0x2C\t \n#define POWER_CTL\t0x2D\t \n#define INT_ENABLE\t0x2E\t \n#define INT_MAP\t\t0x2F\t \n#define INT_SOURCE\t0x30\t \n#define DATA_FORMAT\t0x31\t \n#define DATAX0\t\t0x32\t \n#define DATAX1\t\t0x33\t \n#define DATAY0\t\t0x34\t \n#define DATAY1\t\t0x35\t \n#define DATAZ0\t\t0x36\t \n#define DATAZ1\t\t0x37\t \n#define FIFO_CTL\t0x38\t \n#define FIFO_STATUS\t0x39\t \n#define TAP_SIGN\t0x3A\t \n \n#define ORIENT_CONF\t0x3B\t \n#define ORIENT\t\t0x3C\t \n\n \n#define ID_ADXL345\t0xE5\n#define ID_ADXL346\t0xE6\n\n \n#define DATA_READY\t(1 << 7)\n#define SINGLE_TAP\t(1 << 6)\n#define DOUBLE_TAP\t(1 << 5)\n#define ACTIVITY\t(1 << 4)\n#define INACTIVITY\t(1 << 3)\n#define FREE_FALL\t(1 << 2)\n#define WATERMARK\t(1 << 1)\n#define OVERRUN\t\t(1 << 0)\n\n \n#define ACT_ACDC\t(1 << 7)\n#define ACT_X_EN\t(1 << 6)\n#define ACT_Y_EN\t(1 << 5)\n#define ACT_Z_EN\t(1 << 4)\n#define INACT_ACDC\t(1 << 3)\n#define INACT_X_EN\t(1 << 2)\n#define INACT_Y_EN\t(1 << 1)\n#define INACT_Z_EN\t(1 << 0)\n\n \n#define SUPPRESS\t(1 << 3)\n#define TAP_X_EN\t(1 << 2)\n#define TAP_Y_EN\t(1 << 1)\n#define TAP_Z_EN\t(1 << 0)\n\n \n#define ACT_X_SRC\t(1 << 6)\n#define ACT_Y_SRC\t(1 << 5)\n#define ACT_Z_SRC\t(1 << 4)\n#define ASLEEP\t\t(1 << 3)\n#define TAP_X_SRC\t(1 << 2)\n#define TAP_Y_SRC\t(1 << 1)\n#define TAP_Z_SRC\t(1 << 0)\n\n \n#define LOW_POWER\t(1 << 4)\n#define RATE(x)\t\t((x) & 0xF)\n\n \n#define PCTL_LINK\t(1 << 5)\n#define PCTL_AUTO_SLEEP (1 << 4)\n#define PCTL_MEASURE\t(1 << 3)\n#define PCTL_SLEEP\t(1 << 2)\n#define PCTL_WAKEUP(x)\t((x) & 0x3)\n\n \n#define SELF_TEST\t(1 << 7)\n#define SPI\t\t(1 << 6)\n#define INT_INVERT\t(1 << 5)\n#define FULL_RES\t(1 << 3)\n#define JUSTIFY\t\t(1 << 2)\n#define RANGE(x)\t((x) & 0x3)\n#define RANGE_PM_2g\t0\n#define RANGE_PM_4g\t1\n#define RANGE_PM_8g\t2\n#define RANGE_PM_16g\t3\n\n \n#define ADXL_FULLRES_MAX_VAL 4096\n\n \n#define ADXL_FIXEDRES_MAX_VAL 512\n\n \n#define FIFO_MODE(x)\t(((x) & 0x3) << 6)\n#define FIFO_BYPASS\t0\n#define FIFO_FIFO\t1\n#define FIFO_STREAM\t2\n#define FIFO_TRIGGER\t3\n#define TRIGGER\t\t(1 << 5)\n#define SAMPLES(x)\t((x) & 0x1F)\n\n \n#define FIFO_TRIG\t(1 << 7)\n#define ENTRIES(x)\t((x) & 0x3F)\n\n \n#define XSIGN\t\t(1 << 6)\n#define YSIGN\t\t(1 << 5)\n#define ZSIGN\t\t(1 << 4)\n#define XTAP\t\t(1 << 3)\n#define YTAP\t\t(1 << 2)\n#define ZTAP\t\t(1 << 1)\n\n \n#define ORIENT_DEADZONE(x)\t(((x) & 0x7) << 4)\n#define ORIENT_DIVISOR(x)\t((x) & 0x7)\n\n \n#define ADXL346_2D_VALID\t\t(1 << 6)\n#define ADXL346_2D_ORIENT(x)\t\t(((x) & 0x30) >> 4)\n#define ADXL346_3D_VALID\t\t(1 << 3)\n#define ADXL346_3D_ORIENT(x)\t\t((x) & 0x7)\n#define ADXL346_2D_PORTRAIT_POS\t\t0\t \n#define ADXL346_2D_PORTRAIT_NEG\t\t1\t \n#define ADXL346_2D_LANDSCAPE_POS\t2\t \n#define ADXL346_2D_LANDSCAPE_NEG\t3\t \n\n#define ADXL346_3D_FRONT\t\t3\t \n#define ADXL346_3D_BACK\t\t\t4\t \n#define ADXL346_3D_RIGHT\t\t2\t \n#define ADXL346_3D_LEFT\t\t\t5\t \n#define ADXL346_3D_TOP\t\t\t1\t \n#define ADXL346_3D_BOTTOM\t\t6\t \n\n#undef ADXL_DEBUG\n\n#define ADXL_X_AXIS\t\t\t0\n#define ADXL_Y_AXIS\t\t\t1\n#define ADXL_Z_AXIS\t\t\t2\n\n#define AC_READ(ac, reg)\t((ac)->bops->read((ac)->dev, reg))\n#define AC_WRITE(ac, reg, val)\t((ac)->bops->write((ac)->dev, reg, val))\n\nstruct axis_triple {\n\tint x;\n\tint y;\n\tint z;\n};\n\nstruct adxl34x {\n\tstruct device *dev;\n\tstruct input_dev *input;\n\tstruct mutex mutex;\t \n\tstruct adxl34x_platform_data pdata;\n\tstruct axis_triple swcal;\n\tstruct axis_triple hwcal;\n\tstruct axis_triple saved;\n\tchar phys[32];\n\tunsigned orient2d_saved;\n\tunsigned orient3d_saved;\n\tbool disabled;\t \n\tbool opened;\t \n\tbool suspended;\t \n\tbool fifo_delay;\n\tint irq;\n\tunsigned model;\n\tunsigned int_mask;\n\n\tconst struct adxl34x_bus_ops *bops;\n};\n\nstatic const struct adxl34x_platform_data adxl34x_default_init = {\n\t.tap_threshold = 35,\n\t.tap_duration = 3,\n\t.tap_latency = 20,\n\t.tap_window = 20,\n\t.tap_axis_control = ADXL_TAP_X_EN | ADXL_TAP_Y_EN | ADXL_TAP_Z_EN,\n\t.act_axis_control = 0xFF,\n\t.activity_threshold = 6,\n\t.inactivity_threshold = 4,\n\t.inactivity_time = 3,\n\t.free_fall_threshold = 8,\n\t.free_fall_time = 0x20,\n\t.data_rate = 8,\n\t.data_range = ADXL_FULL_RES,\n\n\t.ev_type = EV_ABS,\n\t.ev_code_x = ABS_X,\t \n\t.ev_code_y = ABS_Y,\t \n\t.ev_code_z = ABS_Z,\t \n\n\t.ev_code_tap = {BTN_TOUCH, BTN_TOUCH, BTN_TOUCH},  \n\t.power_mode = ADXL_AUTO_SLEEP | ADXL_LINK,\n\t.fifo_mode = ADXL_FIFO_STREAM,\n\t.watermark = 0,\n};\n\nstatic void adxl34x_get_triple(struct adxl34x *ac, struct axis_triple *axis)\n{\n\t__le16 buf[3];\n\n\tac->bops->read_block(ac->dev, DATAX0, DATAZ1 - DATAX0 + 1, buf);\n\n\tmutex_lock(&ac->mutex);\n\tac->saved.x = (s16) le16_to_cpu(buf[0]);\n\taxis->x = ac->saved.x;\n\n\tac->saved.y = (s16) le16_to_cpu(buf[1]);\n\taxis->y = ac->saved.y;\n\n\tac->saved.z = (s16) le16_to_cpu(buf[2]);\n\taxis->z = ac->saved.z;\n\tmutex_unlock(&ac->mutex);\n}\n\nstatic void adxl34x_service_ev_fifo(struct adxl34x *ac)\n{\n\tstruct adxl34x_platform_data *pdata = &ac->pdata;\n\tstruct axis_triple axis;\n\n\tadxl34x_get_triple(ac, &axis);\n\n\tinput_event(ac->input, pdata->ev_type, pdata->ev_code_x,\n\t\t    axis.x - ac->swcal.x);\n\tinput_event(ac->input, pdata->ev_type, pdata->ev_code_y,\n\t\t    axis.y - ac->swcal.y);\n\tinput_event(ac->input, pdata->ev_type, pdata->ev_code_z,\n\t\t    axis.z - ac->swcal.z);\n}\n\nstatic void adxl34x_report_key_single(struct input_dev *input, int key)\n{\n\tinput_report_key(input, key, true);\n\tinput_sync(input);\n\tinput_report_key(input, key, false);\n}\n\nstatic void adxl34x_send_key_events(struct adxl34x *ac,\n\t\tstruct adxl34x_platform_data *pdata, int status, int press)\n{\n\tint i;\n\n\tfor (i = ADXL_X_AXIS; i <= ADXL_Z_AXIS; i++) {\n\t\tif (status & (1 << (ADXL_Z_AXIS - i)))\n\t\t\tinput_report_key(ac->input,\n\t\t\t\t\t pdata->ev_code_tap[i], press);\n\t}\n}\n\nstatic void adxl34x_do_tap(struct adxl34x *ac,\n\t\tstruct adxl34x_platform_data *pdata, int status)\n{\n\tadxl34x_send_key_events(ac, pdata, status, true);\n\tinput_sync(ac->input);\n\tadxl34x_send_key_events(ac, pdata, status, false);\n}\n\nstatic irqreturn_t adxl34x_irq(int irq, void *handle)\n{\n\tstruct adxl34x *ac = handle;\n\tstruct adxl34x_platform_data *pdata = &ac->pdata;\n\tint int_stat, tap_stat, samples, orient, orient_code;\n\n\t \n\n\tif (pdata->tap_axis_control & (TAP_X_EN | TAP_Y_EN | TAP_Z_EN))\n\t\ttap_stat = AC_READ(ac, ACT_TAP_STATUS);\n\telse\n\t\ttap_stat = 0;\n\n\tint_stat = AC_READ(ac, INT_SOURCE);\n\n\tif (int_stat & FREE_FALL)\n\t\tadxl34x_report_key_single(ac->input, pdata->ev_code_ff);\n\n\tif (int_stat & OVERRUN)\n\t\tdev_dbg(ac->dev, \"OVERRUN\\n\");\n\n\tif (int_stat & (SINGLE_TAP | DOUBLE_TAP)) {\n\t\tadxl34x_do_tap(ac, pdata, tap_stat);\n\n\t\tif (int_stat & DOUBLE_TAP)\n\t\t\tadxl34x_do_tap(ac, pdata, tap_stat);\n\t}\n\n\tif (pdata->ev_code_act_inactivity) {\n\t\tif (int_stat & ACTIVITY)\n\t\t\tinput_report_key(ac->input,\n\t\t\t\t\t pdata->ev_code_act_inactivity, 1);\n\t\tif (int_stat & INACTIVITY)\n\t\t\tinput_report_key(ac->input,\n\t\t\t\t\t pdata->ev_code_act_inactivity, 0);\n\t}\n\n\t \n\tif (pdata->orientation_enable) {\n\t\torient = AC_READ(ac, ORIENT);\n\t\tif ((pdata->orientation_enable & ADXL_EN_ORIENTATION_2D) &&\n\t\t    (orient & ADXL346_2D_VALID)) {\n\n\t\t\torient_code = ADXL346_2D_ORIENT(orient);\n\t\t\t \n\t\t\tif (ac->orient2d_saved != orient_code) {\n\t\t\t\tac->orient2d_saved = orient_code;\n\t\t\t\tadxl34x_report_key_single(ac->input,\n\t\t\t\t\tpdata->ev_codes_orient_2d[orient_code]);\n\t\t\t}\n\t\t}\n\n\t\tif ((pdata->orientation_enable & ADXL_EN_ORIENTATION_3D) &&\n\t\t    (orient & ADXL346_3D_VALID)) {\n\n\t\t\torient_code = ADXL346_3D_ORIENT(orient) - 1;\n\t\t\t \n\t\t\tif (ac->orient3d_saved != orient_code) {\n\t\t\t\tac->orient3d_saved = orient_code;\n\t\t\t\tadxl34x_report_key_single(ac->input,\n\t\t\t\t\tpdata->ev_codes_orient_3d[orient_code]);\n\t\t\t}\n\t\t}\n\t}\n\n\tif (int_stat & (DATA_READY | WATERMARK)) {\n\n\t\tif (pdata->fifo_mode)\n\t\t\tsamples = ENTRIES(AC_READ(ac, FIFO_STATUS)) + 1;\n\t\telse\n\t\t\tsamples = 1;\n\n\t\tfor (; samples > 0; samples--) {\n\t\t\tadxl34x_service_ev_fifo(ac);\n\t\t\t \n\t\t\tif (ac->fifo_delay && (samples > 1))\n\t\t\t\tudelay(3);\n\t\t}\n\t}\n\n\tinput_sync(ac->input);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic void __adxl34x_disable(struct adxl34x *ac)\n{\n\t \n\tAC_WRITE(ac, POWER_CTL, 0);\n}\n\nstatic void __adxl34x_enable(struct adxl34x *ac)\n{\n\tAC_WRITE(ac, POWER_CTL, ac->pdata.power_mode | PCTL_MEASURE);\n}\n\nstatic int adxl34x_suspend(struct device *dev)\n{\n\tstruct adxl34x *ac = dev_get_drvdata(dev);\n\n\tmutex_lock(&ac->mutex);\n\n\tif (!ac->suspended && !ac->disabled && ac->opened)\n\t\t__adxl34x_disable(ac);\n\n\tac->suspended = true;\n\n\tmutex_unlock(&ac->mutex);\n\n\treturn 0;\n}\n\nstatic int adxl34x_resume(struct device *dev)\n{\n\tstruct adxl34x *ac = dev_get_drvdata(dev);\n\n\tmutex_lock(&ac->mutex);\n\n\tif (ac->suspended && !ac->disabled && ac->opened)\n\t\t__adxl34x_enable(ac);\n\n\tac->suspended = false;\n\n\tmutex_unlock(&ac->mutex);\n\n\treturn 0;\n}\n\nstatic ssize_t adxl34x_disable_show(struct device *dev,\n\t\t\t\t    struct device_attribute *attr, char *buf)\n{\n\tstruct adxl34x *ac = dev_get_drvdata(dev);\n\n\treturn sprintf(buf, \"%u\\n\", ac->disabled);\n}\n\nstatic ssize_t adxl34x_disable_store(struct device *dev,\n\t\t\t\t     struct device_attribute *attr,\n\t\t\t\t     const char *buf, size_t count)\n{\n\tstruct adxl34x *ac = dev_get_drvdata(dev);\n\tunsigned int val;\n\tint error;\n\n\terror = kstrtouint(buf, 10, &val);\n\tif (error)\n\t\treturn error;\n\n\tmutex_lock(&ac->mutex);\n\n\tif (!ac->suspended && ac->opened) {\n\t\tif (val) {\n\t\t\tif (!ac->disabled)\n\t\t\t\t__adxl34x_disable(ac);\n\t\t} else {\n\t\t\tif (ac->disabled)\n\t\t\t\t__adxl34x_enable(ac);\n\t\t}\n\t}\n\n\tac->disabled = !!val;\n\n\tmutex_unlock(&ac->mutex);\n\n\treturn count;\n}\n\nstatic DEVICE_ATTR(disable, 0664, adxl34x_disable_show, adxl34x_disable_store);\n\nstatic ssize_t adxl34x_calibrate_show(struct device *dev,\n\t\t\t\t      struct device_attribute *attr, char *buf)\n{\n\tstruct adxl34x *ac = dev_get_drvdata(dev);\n\tssize_t count;\n\n\tmutex_lock(&ac->mutex);\n\tcount = sprintf(buf, \"%d,%d,%d\\n\",\n\t\t\tac->hwcal.x * 4 + ac->swcal.x,\n\t\t\tac->hwcal.y * 4 + ac->swcal.y,\n\t\t\tac->hwcal.z * 4 + ac->swcal.z);\n\tmutex_unlock(&ac->mutex);\n\n\treturn count;\n}\n\nstatic ssize_t adxl34x_calibrate_store(struct device *dev,\n\t\t\t\t       struct device_attribute *attr,\n\t\t\t\t       const char *buf, size_t count)\n{\n\tstruct adxl34x *ac = dev_get_drvdata(dev);\n\n\t \n\n\tmutex_lock(&ac->mutex);\n\tac->hwcal.x -= (ac->saved.x / 4);\n\tac->swcal.x = ac->saved.x % 4;\n\n\tac->hwcal.y -= (ac->saved.y / 4);\n\tac->swcal.y = ac->saved.y % 4;\n\n\tac->hwcal.z -= (ac->saved.z / 4);\n\tac->swcal.z = ac->saved.z % 4;\n\n\tAC_WRITE(ac, OFSX, (s8) ac->hwcal.x);\n\tAC_WRITE(ac, OFSY, (s8) ac->hwcal.y);\n\tAC_WRITE(ac, OFSZ, (s8) ac->hwcal.z);\n\tmutex_unlock(&ac->mutex);\n\n\treturn count;\n}\n\nstatic DEVICE_ATTR(calibrate, 0664,\n\t\t   adxl34x_calibrate_show, adxl34x_calibrate_store);\n\nstatic ssize_t adxl34x_rate_show(struct device *dev,\n\t\t\t\t struct device_attribute *attr, char *buf)\n{\n\tstruct adxl34x *ac = dev_get_drvdata(dev);\n\n\treturn sprintf(buf, \"%u\\n\", RATE(ac->pdata.data_rate));\n}\n\nstatic ssize_t adxl34x_rate_store(struct device *dev,\n\t\t\t\t  struct device_attribute *attr,\n\t\t\t\t  const char *buf, size_t count)\n{\n\tstruct adxl34x *ac = dev_get_drvdata(dev);\n\tunsigned char val;\n\tint error;\n\n\terror = kstrtou8(buf, 10, &val);\n\tif (error)\n\t\treturn error;\n\n\tmutex_lock(&ac->mutex);\n\n\tac->pdata.data_rate = RATE(val);\n\tAC_WRITE(ac, BW_RATE,\n\t\t ac->pdata.data_rate |\n\t\t\t(ac->pdata.low_power_mode ? LOW_POWER : 0));\n\n\tmutex_unlock(&ac->mutex);\n\n\treturn count;\n}\n\nstatic DEVICE_ATTR(rate, 0664, adxl34x_rate_show, adxl34x_rate_store);\n\nstatic ssize_t adxl34x_autosleep_show(struct device *dev,\n\t\t\t\t struct device_attribute *attr, char *buf)\n{\n\tstruct adxl34x *ac = dev_get_drvdata(dev);\n\n\treturn sprintf(buf, \"%u\\n\",\n\t\tac->pdata.power_mode & (PCTL_AUTO_SLEEP | PCTL_LINK) ? 1 : 0);\n}\n\nstatic ssize_t adxl34x_autosleep_store(struct device *dev,\n\t\t\t\t  struct device_attribute *attr,\n\t\t\t\t  const char *buf, size_t count)\n{\n\tstruct adxl34x *ac = dev_get_drvdata(dev);\n\tunsigned int val;\n\tint error;\n\n\terror = kstrtouint(buf, 10, &val);\n\tif (error)\n\t\treturn error;\n\n\tmutex_lock(&ac->mutex);\n\n\tif (val)\n\t\tac->pdata.power_mode |= (PCTL_AUTO_SLEEP | PCTL_LINK);\n\telse\n\t\tac->pdata.power_mode &= ~(PCTL_AUTO_SLEEP | PCTL_LINK);\n\n\tif (!ac->disabled && !ac->suspended && ac->opened)\n\t\tAC_WRITE(ac, POWER_CTL, ac->pdata.power_mode | PCTL_MEASURE);\n\n\tmutex_unlock(&ac->mutex);\n\n\treturn count;\n}\n\nstatic DEVICE_ATTR(autosleep, 0664,\n\t\t   adxl34x_autosleep_show, adxl34x_autosleep_store);\n\nstatic ssize_t adxl34x_position_show(struct device *dev,\n\t\t\t\t struct device_attribute *attr, char *buf)\n{\n\tstruct adxl34x *ac = dev_get_drvdata(dev);\n\tssize_t count;\n\n\tmutex_lock(&ac->mutex);\n\tcount = sprintf(buf, \"(%d, %d, %d)\\n\",\n\t\t\tac->saved.x, ac->saved.y, ac->saved.z);\n\tmutex_unlock(&ac->mutex);\n\n\treturn count;\n}\n\nstatic DEVICE_ATTR(position, S_IRUGO, adxl34x_position_show, NULL);\n\n#ifdef ADXL_DEBUG\nstatic ssize_t adxl34x_write_store(struct device *dev,\n\t\t\t\t   struct device_attribute *attr,\n\t\t\t\t   const char *buf, size_t count)\n{\n\tstruct adxl34x *ac = dev_get_drvdata(dev);\n\tunsigned int val;\n\tint error;\n\n\t \n\terror = kstrtouint(buf, 16, &val);\n\tif (error)\n\t\treturn error;\n\n\tmutex_lock(&ac->mutex);\n\tAC_WRITE(ac, val >> 8, val & 0xFF);\n\tmutex_unlock(&ac->mutex);\n\n\treturn count;\n}\n\nstatic DEVICE_ATTR(write, 0664, NULL, adxl34x_write_store);\n#endif\n\nstatic struct attribute *adxl34x_attributes[] = {\n\t&dev_attr_disable.attr,\n\t&dev_attr_calibrate.attr,\n\t&dev_attr_rate.attr,\n\t&dev_attr_autosleep.attr,\n\t&dev_attr_position.attr,\n#ifdef ADXL_DEBUG\n\t&dev_attr_write.attr,\n#endif\n\tNULL\n};\n\nstatic const struct attribute_group adxl34x_attr_group = {\n\t.attrs = adxl34x_attributes,\n};\n\nstatic int adxl34x_input_open(struct input_dev *input)\n{\n\tstruct adxl34x *ac = input_get_drvdata(input);\n\n\tmutex_lock(&ac->mutex);\n\n\tif (!ac->suspended && !ac->disabled)\n\t\t__adxl34x_enable(ac);\n\n\tac->opened = true;\n\n\tmutex_unlock(&ac->mutex);\n\n\treturn 0;\n}\n\nstatic void adxl34x_input_close(struct input_dev *input)\n{\n\tstruct adxl34x *ac = input_get_drvdata(input);\n\n\tmutex_lock(&ac->mutex);\n\n\tif (!ac->suspended && !ac->disabled)\n\t\t__adxl34x_disable(ac);\n\n\tac->opened = false;\n\n\tmutex_unlock(&ac->mutex);\n}\n\nstruct adxl34x *adxl34x_probe(struct device *dev, int irq,\n\t\t\t      bool fifo_delay_default,\n\t\t\t      const struct adxl34x_bus_ops *bops)\n{\n\tstruct adxl34x *ac;\n\tstruct input_dev *input_dev;\n\tconst struct adxl34x_platform_data *pdata;\n\tint err, range, i;\n\tint revid;\n\n\tif (!irq) {\n\t\tdev_err(dev, \"no IRQ?\\n\");\n\t\terr = -ENODEV;\n\t\tgoto err_out;\n\t}\n\n\tac = kzalloc(sizeof(*ac), GFP_KERNEL);\n\tinput_dev = input_allocate_device();\n\tif (!ac || !input_dev) {\n\t\terr = -ENOMEM;\n\t\tgoto err_free_mem;\n\t}\n\n\tac->fifo_delay = fifo_delay_default;\n\n\tpdata = dev_get_platdata(dev);\n\tif (!pdata) {\n\t\tdev_dbg(dev,\n\t\t\t\"No platform data: Using default initialization\\n\");\n\t\tpdata = &adxl34x_default_init;\n\t}\n\n\tac->pdata = *pdata;\n\tpdata = &ac->pdata;\n\n\tac->input = input_dev;\n\tac->dev = dev;\n\tac->irq = irq;\n\tac->bops = bops;\n\n\tmutex_init(&ac->mutex);\n\n\tinput_dev->name = \"ADXL34x accelerometer\";\n\trevid = AC_READ(ac, DEVID);\n\n\tswitch (revid) {\n\tcase ID_ADXL345:\n\t\tac->model = 345;\n\t\tbreak;\n\tcase ID_ADXL346:\n\t\tac->model = 346;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(dev, \"Failed to probe %s\\n\", input_dev->name);\n\t\terr = -ENODEV;\n\t\tgoto err_free_mem;\n\t}\n\n\tsnprintf(ac->phys, sizeof(ac->phys), \"%s/input0\", dev_name(dev));\n\n\tinput_dev->phys = ac->phys;\n\tinput_dev->dev.parent = dev;\n\tinput_dev->id.product = ac->model;\n\tinput_dev->id.bustype = bops->bustype;\n\tinput_dev->open = adxl34x_input_open;\n\tinput_dev->close = adxl34x_input_close;\n\n\tinput_set_drvdata(input_dev, ac);\n\n\t__set_bit(ac->pdata.ev_type, input_dev->evbit);\n\n\tif (ac->pdata.ev_type == EV_REL) {\n\t\t__set_bit(REL_X, input_dev->relbit);\n\t\t__set_bit(REL_Y, input_dev->relbit);\n\t\t__set_bit(REL_Z, input_dev->relbit);\n\t} else {\n\t\t \n\t\t__set_bit(ABS_X, input_dev->absbit);\n\t\t__set_bit(ABS_Y, input_dev->absbit);\n\t\t__set_bit(ABS_Z, input_dev->absbit);\n\n\t\tif (pdata->data_range & FULL_RES)\n\t\t\trange = ADXL_FULLRES_MAX_VAL;\t \n\t\telse\n\t\t\trange = ADXL_FIXEDRES_MAX_VAL;\t \n\n\t\tinput_set_abs_params(input_dev, ABS_X, -range, range, 3, 3);\n\t\tinput_set_abs_params(input_dev, ABS_Y, -range, range, 3, 3);\n\t\tinput_set_abs_params(input_dev, ABS_Z, -range, range, 3, 3);\n\t}\n\n\t__set_bit(EV_KEY, input_dev->evbit);\n\t__set_bit(pdata->ev_code_tap[ADXL_X_AXIS], input_dev->keybit);\n\t__set_bit(pdata->ev_code_tap[ADXL_Y_AXIS], input_dev->keybit);\n\t__set_bit(pdata->ev_code_tap[ADXL_Z_AXIS], input_dev->keybit);\n\n\tif (pdata->ev_code_ff) {\n\t\tac->int_mask = FREE_FALL;\n\t\t__set_bit(pdata->ev_code_ff, input_dev->keybit);\n\t}\n\n\tif (pdata->ev_code_act_inactivity)\n\t\t__set_bit(pdata->ev_code_act_inactivity, input_dev->keybit);\n\n\tac->int_mask |= ACTIVITY | INACTIVITY;\n\n\tif (pdata->watermark) {\n\t\tac->int_mask |= WATERMARK;\n\t\tif (FIFO_MODE(pdata->fifo_mode) == FIFO_BYPASS)\n\t\t\tac->pdata.fifo_mode |= FIFO_STREAM;\n\t} else {\n\t\tac->int_mask |= DATA_READY;\n\t}\n\n\tif (pdata->tap_axis_control & (TAP_X_EN | TAP_Y_EN | TAP_Z_EN))\n\t\tac->int_mask |= SINGLE_TAP | DOUBLE_TAP;\n\n\tif (FIFO_MODE(pdata->fifo_mode) == FIFO_BYPASS)\n\t\tac->fifo_delay = false;\n\n\tAC_WRITE(ac, POWER_CTL, 0);\n\n\terr = request_threaded_irq(ac->irq, NULL, adxl34x_irq,\n\t\t\t\t   IRQF_ONESHOT, dev_name(dev), ac);\n\tif (err) {\n\t\tdev_err(dev, \"irq %d busy?\\n\", ac->irq);\n\t\tgoto err_free_mem;\n\t}\n\n\terr = sysfs_create_group(&dev->kobj, &adxl34x_attr_group);\n\tif (err)\n\t\tgoto err_free_irq;\n\n\terr = input_register_device(input_dev);\n\tif (err)\n\t\tgoto err_remove_attr;\n\n\tAC_WRITE(ac, OFSX, pdata->x_axis_offset);\n\tac->hwcal.x = pdata->x_axis_offset;\n\tAC_WRITE(ac, OFSY, pdata->y_axis_offset);\n\tac->hwcal.y = pdata->y_axis_offset;\n\tAC_WRITE(ac, OFSZ, pdata->z_axis_offset);\n\tac->hwcal.z = pdata->z_axis_offset;\n\tAC_WRITE(ac, THRESH_TAP, pdata->tap_threshold);\n\tAC_WRITE(ac, DUR, pdata->tap_duration);\n\tAC_WRITE(ac, LATENT, pdata->tap_latency);\n\tAC_WRITE(ac, WINDOW, pdata->tap_window);\n\tAC_WRITE(ac, THRESH_ACT, pdata->activity_threshold);\n\tAC_WRITE(ac, THRESH_INACT, pdata->inactivity_threshold);\n\tAC_WRITE(ac, TIME_INACT, pdata->inactivity_time);\n\tAC_WRITE(ac, THRESH_FF, pdata->free_fall_threshold);\n\tAC_WRITE(ac, TIME_FF, pdata->free_fall_time);\n\tAC_WRITE(ac, TAP_AXES, pdata->tap_axis_control);\n\tAC_WRITE(ac, ACT_INACT_CTL, pdata->act_axis_control);\n\tAC_WRITE(ac, BW_RATE, RATE(ac->pdata.data_rate) |\n\t\t (pdata->low_power_mode ? LOW_POWER : 0));\n\tAC_WRITE(ac, DATA_FORMAT, pdata->data_range);\n\tAC_WRITE(ac, FIFO_CTL, FIFO_MODE(pdata->fifo_mode) |\n\t\t\tSAMPLES(pdata->watermark));\n\n\tif (pdata->use_int2) {\n\t\t \n\t\tAC_WRITE(ac, INT_MAP, ac->int_mask | OVERRUN);\n\t} else {\n\t\t \n\t\tAC_WRITE(ac, INT_MAP, 0);\n\t}\n\n\tif (ac->model == 346 && ac->pdata.orientation_enable) {\n\t\tAC_WRITE(ac, ORIENT_CONF,\n\t\t\tORIENT_DEADZONE(ac->pdata.deadzone_angle) |\n\t\t\tORIENT_DIVISOR(ac->pdata.divisor_length));\n\n\t\tac->orient2d_saved = 1234;\n\t\tac->orient3d_saved = 1234;\n\n\t\tif (pdata->orientation_enable & ADXL_EN_ORIENTATION_3D)\n\t\t\tfor (i = 0; i < ARRAY_SIZE(pdata->ev_codes_orient_3d); i++)\n\t\t\t\t__set_bit(pdata->ev_codes_orient_3d[i],\n\t\t\t\t\t  input_dev->keybit);\n\n\t\tif (pdata->orientation_enable & ADXL_EN_ORIENTATION_2D)\n\t\t\tfor (i = 0; i < ARRAY_SIZE(pdata->ev_codes_orient_2d); i++)\n\t\t\t\t__set_bit(pdata->ev_codes_orient_2d[i],\n\t\t\t\t\t  input_dev->keybit);\n\t} else {\n\t\tac->pdata.orientation_enable = 0;\n\t}\n\n\tAC_WRITE(ac, INT_ENABLE, ac->int_mask | OVERRUN);\n\n\tac->pdata.power_mode &= (PCTL_AUTO_SLEEP | PCTL_LINK);\n\n\treturn ac;\n\n err_remove_attr:\n\tsysfs_remove_group(&dev->kobj, &adxl34x_attr_group);\n err_free_irq:\n\tfree_irq(ac->irq, ac);\n err_free_mem:\n\tinput_free_device(input_dev);\n\tkfree(ac);\n err_out:\n\treturn ERR_PTR(err);\n}\nEXPORT_SYMBOL_GPL(adxl34x_probe);\n\nvoid adxl34x_remove(struct adxl34x *ac)\n{\n\tsysfs_remove_group(&ac->dev->kobj, &adxl34x_attr_group);\n\tfree_irq(ac->irq, ac);\n\tinput_unregister_device(ac->input);\n\tdev_dbg(ac->dev, \"unregistered accelerometer\\n\");\n\tkfree(ac);\n}\nEXPORT_SYMBOL_GPL(adxl34x_remove);\n\nEXPORT_GPL_SIMPLE_DEV_PM_OPS(adxl34x_pm, adxl34x_suspend, adxl34x_resume);\n\nMODULE_AUTHOR(\"Michael Hennerich <hennerich@blackfin.uclinux.org>\");\nMODULE_DESCRIPTION(\"ADXL345/346 Three-Axis Digital Accelerometer Driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}